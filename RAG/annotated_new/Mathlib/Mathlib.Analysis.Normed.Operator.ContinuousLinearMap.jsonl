{"name":"continuous_of_linear_of_boundâ‚›â‚—","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_3\nF : Type u_4\ninstâœâµ : Ring ğ•œ\ninstâœâ´ : Ring ğ•œâ‚‚\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : SeminormedAddCommGroup F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œâ‚‚ F\nÏƒ : RingHom ğ•œ ğ•œâ‚‚\nf : E â†’ F\nh_add : âˆ€ (x y : E), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\nh_smul : âˆ€ (c : ğ•œ) (x : E), Eq (f (HSMul.hSMul c x)) (HSMul.hSMul (Ïƒ c) (f x))\nC : Real\nh_bound : âˆ€ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\nâŠ¢ Continuous f","decl":"theorem continuous_of_linear_of_boundâ‚›â‚— {f : E â†’ F} (h_add : âˆ€ x y, f (x + y) = f x + f y)\n    (h_smul : âˆ€ (c : ğ•œ) (x), f (c â€¢ x) = Ïƒ c â€¢ f x) {C : â„} (h_bound : âˆ€ x, â€–f xâ€– â‰¤ C * â€–xâ€–) :\n    Continuous f :=\n  let Ï† : E â†’â‚›â‚—[Ïƒ] F :=\n    { toFun := f\n      map_add' := h_add\n      map_smul' := h_smul }\n  AddMonoidHomClass.continuous_of_bound Ï† C h_bound\n\n"}
{"name":"continuous_of_linear_of_bound","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\nG : Type u_5\ninstâœâ´ : Ring ğ•œ\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : SeminormedAddCommGroup G\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œ G\nf : E â†’ G\nh_add : âˆ€ (x y : E), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\nh_smul : âˆ€ (c : ğ•œ) (x : E), Eq (f (HSMul.hSMul c x)) (HSMul.hSMul c (f x))\nC : Real\nh_bound : âˆ€ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\nâŠ¢ Continuous f","decl":"theorem continuous_of_linear_of_bound {f : E â†’ G} (h_add : âˆ€ x y, f (x + y) = f x + f y)\n    (h_smul : âˆ€ (c : ğ•œ) (x), f (c â€¢ x) = c â€¢ f x) {C : â„} (h_bound : âˆ€ x, â€–f xâ€– â‰¤ C * â€–xâ€–) :\n    Continuous f :=\n  let Ï† : E â†’â‚—[ğ•œ] G :=\n    { toFun := f\n      map_add' := h_add\n      map_smul' := h_smul }\n  AddMonoidHomClass.continuous_of_bound Ï† C h_bound\n\n"}
{"name":"LinearMap.mkContinuous_coe","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_3\nF : Type u_4\ninstâœâµ : Ring ğ•œ\ninstâœâ´ : Ring ğ•œâ‚‚\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : SeminormedAddCommGroup F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œâ‚‚ F\nÏƒ : RingHom ğ•œ ğ•œâ‚‚\nf : LinearMap Ïƒ E F\nC : Real\nh : âˆ€ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\nâŠ¢ Eq (â†‘(f.mkContinuous C h)) f","decl":"@[simp, norm_cast]\ntheorem LinearMap.mkContinuous_coe (C : â„) (h : âˆ€ x, â€–f xâ€– â‰¤ C * â€–xâ€–) :\n    (f.mkContinuous C h : E â†’â‚›â‚—[Ïƒ] F) = f :=\n  rfl\n\n"}
{"name":"LinearMap.mkContinuous_apply","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_3\nF : Type u_4\ninstâœâµ : Ring ğ•œ\ninstâœâ´ : Ring ğ•œâ‚‚\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : SeminormedAddCommGroup F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œâ‚‚ F\nÏƒ : RingHom ğ•œ ğ•œâ‚‚\nf : LinearMap Ïƒ E F\nC : Real\nh : âˆ€ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\nx : E\nâŠ¢ Eq ((f.mkContinuous C h) x) (f x)","decl":"@[simp]\ntheorem LinearMap.mkContinuous_apply (C : â„) (h : âˆ€ x, â€–f xâ€– â‰¤ C * â€–xâ€–) (x : E) :\n    f.mkContinuous C h x = f x :=\n  rfl\n\n"}
{"name":"LinearMap.mkContinuousOfExistsBound_coe","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_3\nF : Type u_4\ninstâœâµ : Ring ğ•œ\ninstâœâ´ : Ring ğ•œâ‚‚\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : SeminormedAddCommGroup F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œâ‚‚ F\nÏƒ : RingHom ğ•œ ğ•œâ‚‚\nf : LinearMap Ïƒ E F\nh : Exists fun C => âˆ€ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\nâŠ¢ Eq (â†‘(f.mkContinuousOfExistsBound h)) f","decl":"@[simp, norm_cast]\ntheorem LinearMap.mkContinuousOfExistsBound_coe (h : âˆƒ C, âˆ€ x, â€–f xâ€– â‰¤ C * â€–xâ€–) :\n    (f.mkContinuousOfExistsBound h : E â†’â‚›â‚—[Ïƒ] F) = f :=\n  rfl\n\n"}
{"name":"LinearMap.mkContinuousOfExistsBound_apply","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_3\nF : Type u_4\ninstâœâµ : Ring ğ•œ\ninstâœâ´ : Ring ğ•œâ‚‚\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : SeminormedAddCommGroup F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œâ‚‚ F\nÏƒ : RingHom ğ•œ ğ•œâ‚‚\nf : LinearMap Ïƒ E F\nh : Exists fun C => âˆ€ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\nx : E\nâŠ¢ Eq ((f.mkContinuousOfExistsBound h) x) (f x)","decl":"@[simp]\ntheorem LinearMap.mkContinuousOfExistsBound_apply (h : âˆƒ C, âˆ€ x, â€–f xâ€– â‰¤ C * â€–xâ€–) (x : E) :\n    f.mkContinuousOfExistsBound h x = f x :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.antilipschitz_of_bound","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_3\nF : Type u_4\ninstâœâµ : Ring ğ•œ\ninstâœâ´ : Ring ğ•œâ‚‚\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : SeminormedAddCommGroup F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œâ‚‚ F\nÏƒ : RingHom ğ•œ ğ•œâ‚‚\nf : ContinuousLinearMap Ïƒ E F\nK : NNReal\nh : âˆ€ (x : E), LE.le (Norm.norm x) (HMul.hMul (â†‘K) (Norm.norm (f x)))\nâŠ¢ AntilipschitzWith K â‡‘f","decl":"theorem antilipschitz_of_bound (f : E â†’SL[Ïƒ] F) {K : â„â‰¥0} (h : âˆ€ x, â€–xâ€– â‰¤ K * â€–f xâ€–) :\n    AntilipschitzWith K f :=\n  AddMonoidHomClass.antilipschitz_of_bound _ h\n\n"}
{"name":"ContinuousLinearMap.bound_of_antilipschitz","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_3\nF : Type u_4\ninstâœâµ : Ring ğ•œ\ninstâœâ´ : Ring ğ•œâ‚‚\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : SeminormedAddCommGroup F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œâ‚‚ F\nÏƒ : RingHom ğ•œ ğ•œâ‚‚\nf : ContinuousLinearMap Ïƒ E F\nK : NNReal\nh : AntilipschitzWith K â‡‘f\nx : E\nâŠ¢ LE.le (Norm.norm x) (HMul.hMul (â†‘K) (Norm.norm (f x)))","decl":"theorem bound_of_antilipschitz (f : E â†’SL[Ïƒ] F) {K : â„â‰¥0} (h : AntilipschitzWith K f) (x) :\n    â€–xâ€– â‰¤ K * â€–f xâ€– :=\n  ZeroHomClass.bound_of_antilipschitz _ h x\n\n"}
{"name":"LinearMap.toContinuousLinearMapâ‚_coe","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ³ : SeminormedRing ğ•œ\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : BoundedSMul ğ•œ E\nf : LinearMap (RingHom.id ğ•œ) ğ•œ E\nâŠ¢ Eq (â†‘f.toContinuousLinearMapâ‚) f","decl":"@[simp]\ntheorem LinearMap.toContinuousLinearMapâ‚_coe (f : ğ•œ â†’â‚—[ğ•œ] E) :\n    (f.toContinuousLinearMapâ‚ : ğ•œ â†’â‚—[ğ•œ] E) = f :=\n  rfl\n\n"}
{"name":"LinearMap.toContinuousLinearMapâ‚_apply","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_3\ninstâœÂ³ : SeminormedRing ğ•œ\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : BoundedSMul ğ•œ E\nf : LinearMap (RingHom.id ğ•œ) ğ•œ E\nx : ğ•œ\nâŠ¢ Eq (f.toContinuousLinearMapâ‚ x) (f x)","decl":"@[simp]\ntheorem LinearMap.toContinuousLinearMapâ‚_apply (f : ğ•œ â†’â‚—[ğ•œ] E) (x) :\n    f.toContinuousLinearMapâ‚ x = f x :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.isUniformEmbedding_of_bound","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_3\nF : Type u_4\ninstâœâµ : Ring ğ•œ\ninstâœâ´ : Ring ğ•œâ‚‚\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œâ‚‚ F\nÏƒ : RingHom ğ•œ ğ•œâ‚‚\nf : ContinuousLinearMap Ïƒ E F\nK : NNReal\nhf : âˆ€ (x : E), LE.le (Norm.norm x) (HMul.hMul (â†‘K) (Norm.norm (f x)))\nâŠ¢ IsUniformEmbedding â‡‘f","decl":"theorem ContinuousLinearMap.isUniformEmbedding_of_bound {K : â„â‰¥0} (hf : âˆ€ x, â€–xâ€– â‰¤ K * â€–f xâ€–) :\n    IsUniformEmbedding f :=\n  (AddMonoidHomClass.antilipschitz_of_bound f hf).isUniformEmbedding f.uniformContinuous\n\n"}
{"name":"ContinuousLinearMap.uniformEmbedding_of_bound","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_3\nF : Type u_4\ninstâœâµ : Ring ğ•œ\ninstâœâ´ : Ring ğ•œâ‚‚\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œâ‚‚ F\nÏƒ : RingHom ğ•œ ğ•œâ‚‚\nf : ContinuousLinearMap Ïƒ E F\nK : NNReal\nhf : âˆ€ (x : E), LE.le (Norm.norm x) (HMul.hMul (â†‘K) (Norm.norm (f x)))\nâŠ¢ IsUniformEmbedding â‡‘f","decl":"@[deprecated (since := \"2024-10-01\")]\nalias ContinuousLinearMap.uniformEmbedding_of_bound :=\n  ContinuousLinearMap.isUniformEmbedding_of_bound\n\n"}
{"name":"ContinuousLinearEquiv.homothety_inverse","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_3\nF : Type u_4\ninstâœâ· : Ring ğ•œ\ninstâœâ¶ : Ring ğ•œâ‚‚\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : SeminormedAddCommGroup F\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : Module ğ•œâ‚‚ F\nÏƒ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚‚â‚ : RingHom ğ•œâ‚‚ ğ•œ\ninstâœÂ¹ : RingHomInvPair Ïƒ Ïƒâ‚‚â‚\ninstâœ : RingHomInvPair Ïƒâ‚‚â‚ Ïƒ\na : Real\nha : LT.lt 0 a\nf : LinearEquiv Ïƒ E F\naâœ : âˆ€ (x : E), Eq (Norm.norm (f x)) (HMul.hMul a (Norm.norm x))\ny : F\nâŠ¢ Eq (Norm.norm (f.symm y)) (HMul.hMul (Inv.inv a) (Norm.norm y))","decl":"theorem ContinuousLinearEquiv.homothety_inverse (a : â„) (ha : 0 < a) (f : E â‰ƒâ‚›â‚—[Ïƒ] F) :\n    (âˆ€ x : E, â€–f xâ€– = a * â€–xâ€–) â†’ âˆ€ y : F, â€–f.symm yâ€– = aâ»Â¹ * â€–yâ€– := by\n  intro hf y\n  calc\n    â€–f.symm yâ€– = aâ»Â¹ * (a * â€–f.symm yâ€–) := by\n      rw [â† mul_assoc, inv_mul_cancelâ‚€ (ne_of_lt ha).symm, one_mul]\n    _ = aâ»Â¹ * â€–f (f.symm y)â€– := by rw [hf]\n    _ = aâ»Â¹ * â€–yâ€– := by simp\n\n"}
