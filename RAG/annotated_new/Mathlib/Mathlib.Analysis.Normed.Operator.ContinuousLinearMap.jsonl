{"name":"continuous_of_linear_of_boundₛₗ","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_3\nF : Type u_4\ninst✝⁵ : Ring 𝕜\ninst✝⁴ : Ring 𝕜₂\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : SeminormedAddCommGroup F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜₂ F\nσ : RingHom 𝕜 𝕜₂\nf : E → F\nh_add : ∀ (x y : E), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\nh_smul : ∀ (c : 𝕜) (x : E), Eq (f (HSMul.hSMul c x)) (HSMul.hSMul (σ c) (f x))\nC : Real\nh_bound : ∀ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\n⊢ Continuous f","decl":"theorem continuous_of_linear_of_boundₛₗ {f : E → F} (h_add : ∀ x y, f (x + y) = f x + f y)\n    (h_smul : ∀ (c : 𝕜) (x), f (c • x) = σ c • f x) {C : ℝ} (h_bound : ∀ x, ‖f x‖ ≤ C * ‖x‖) :\n    Continuous f :=\n  let φ : E →ₛₗ[σ] F :=\n    { toFun := f\n      map_add' := h_add\n      map_smul' := h_smul }\n  AddMonoidHomClass.continuous_of_bound φ C h_bound\n\n"}
{"name":"continuous_of_linear_of_bound","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"𝕜 : Type u_1\nE : Type u_3\nG : Type u_5\ninst✝⁴ : Ring 𝕜\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : SeminormedAddCommGroup G\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜 G\nf : E → G\nh_add : ∀ (x y : E), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\nh_smul : ∀ (c : 𝕜) (x : E), Eq (f (HSMul.hSMul c x)) (HSMul.hSMul c (f x))\nC : Real\nh_bound : ∀ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\n⊢ Continuous f","decl":"theorem continuous_of_linear_of_bound {f : E → G} (h_add : ∀ x y, f (x + y) = f x + f y)\n    (h_smul : ∀ (c : 𝕜) (x), f (c • x) = c • f x) {C : ℝ} (h_bound : ∀ x, ‖f x‖ ≤ C * ‖x‖) :\n    Continuous f :=\n  let φ : E →ₗ[𝕜] G :=\n    { toFun := f\n      map_add' := h_add\n      map_smul' := h_smul }\n  AddMonoidHomClass.continuous_of_bound φ C h_bound\n\n"}
{"name":"LinearMap.mkContinuous_coe","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_3\nF : Type u_4\ninst✝⁵ : Ring 𝕜\ninst✝⁴ : Ring 𝕜₂\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : SeminormedAddCommGroup F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜₂ F\nσ : RingHom 𝕜 𝕜₂\nf : LinearMap σ E F\nC : Real\nh : ∀ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\n⊢ Eq (↑(f.mkContinuous C h)) f","decl":"@[simp, norm_cast]\ntheorem LinearMap.mkContinuous_coe (C : ℝ) (h : ∀ x, ‖f x‖ ≤ C * ‖x‖) :\n    (f.mkContinuous C h : E →ₛₗ[σ] F) = f :=\n  rfl\n\n"}
{"name":"LinearMap.mkContinuous_apply","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_3\nF : Type u_4\ninst✝⁵ : Ring 𝕜\ninst✝⁴ : Ring 𝕜₂\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : SeminormedAddCommGroup F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜₂ F\nσ : RingHom 𝕜 𝕜₂\nf : LinearMap σ E F\nC : Real\nh : ∀ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\nx : E\n⊢ Eq ((f.mkContinuous C h) x) (f x)","decl":"@[simp]\ntheorem LinearMap.mkContinuous_apply (C : ℝ) (h : ∀ x, ‖f x‖ ≤ C * ‖x‖) (x : E) :\n    f.mkContinuous C h x = f x :=\n  rfl\n\n"}
{"name":"LinearMap.mkContinuousOfExistsBound_coe","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_3\nF : Type u_4\ninst✝⁵ : Ring 𝕜\ninst✝⁴ : Ring 𝕜₂\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : SeminormedAddCommGroup F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜₂ F\nσ : RingHom 𝕜 𝕜₂\nf : LinearMap σ E F\nh : Exists fun C => ∀ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\n⊢ Eq (↑(f.mkContinuousOfExistsBound h)) f","decl":"@[simp, norm_cast]\ntheorem LinearMap.mkContinuousOfExistsBound_coe (h : ∃ C, ∀ x, ‖f x‖ ≤ C * ‖x‖) :\n    (f.mkContinuousOfExistsBound h : E →ₛₗ[σ] F) = f :=\n  rfl\n\n"}
{"name":"LinearMap.mkContinuousOfExistsBound_apply","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_3\nF : Type u_4\ninst✝⁵ : Ring 𝕜\ninst✝⁴ : Ring 𝕜₂\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : SeminormedAddCommGroup F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜₂ F\nσ : RingHom 𝕜 𝕜₂\nf : LinearMap σ E F\nh : Exists fun C => ∀ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\nx : E\n⊢ Eq ((f.mkContinuousOfExistsBound h) x) (f x)","decl":"@[simp]\ntheorem LinearMap.mkContinuousOfExistsBound_apply (h : ∃ C, ∀ x, ‖f x‖ ≤ C * ‖x‖) (x : E) :\n    f.mkContinuousOfExistsBound h x = f x :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.antilipschitz_of_bound","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_3\nF : Type u_4\ninst✝⁵ : Ring 𝕜\ninst✝⁴ : Ring 𝕜₂\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : SeminormedAddCommGroup F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜₂ F\nσ : RingHom 𝕜 𝕜₂\nf : ContinuousLinearMap σ E F\nK : NNReal\nh : ∀ (x : E), LE.le (Norm.norm x) (HMul.hMul (↑K) (Norm.norm (f x)))\n⊢ AntilipschitzWith K ⇑f","decl":"theorem antilipschitz_of_bound (f : E →SL[σ] F) {K : ℝ≥0} (h : ∀ x, ‖x‖ ≤ K * ‖f x‖) :\n    AntilipschitzWith K f :=\n  AddMonoidHomClass.antilipschitz_of_bound _ h\n\n"}
{"name":"ContinuousLinearMap.bound_of_antilipschitz","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_3\nF : Type u_4\ninst✝⁵ : Ring 𝕜\ninst✝⁴ : Ring 𝕜₂\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : SeminormedAddCommGroup F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜₂ F\nσ : RingHom 𝕜 𝕜₂\nf : ContinuousLinearMap σ E F\nK : NNReal\nh : AntilipschitzWith K ⇑f\nx : E\n⊢ LE.le (Norm.norm x) (HMul.hMul (↑K) (Norm.norm (f x)))","decl":"theorem bound_of_antilipschitz (f : E →SL[σ] F) {K : ℝ≥0} (h : AntilipschitzWith K f) (x) :\n    ‖x‖ ≤ K * ‖f x‖ :=\n  ZeroHomClass.bound_of_antilipschitz _ h x\n\n"}
{"name":"LinearMap.toContinuousLinearMap₁_coe","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝³ : SeminormedRing 𝕜\ninst✝² : SeminormedAddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : BoundedSMul 𝕜 E\nf : LinearMap (RingHom.id 𝕜) 𝕜 E\n⊢ Eq (↑f.toContinuousLinearMap₁) f","decl":"@[simp]\ntheorem LinearMap.toContinuousLinearMap₁_coe (f : 𝕜 →ₗ[𝕜] E) :\n    (f.toContinuousLinearMap₁ : 𝕜 →ₗ[𝕜] E) = f :=\n  rfl\n\n"}
{"name":"LinearMap.toContinuousLinearMap₁_apply","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"𝕜 : Type u_1\nE : Type u_3\ninst✝³ : SeminormedRing 𝕜\ninst✝² : SeminormedAddCommGroup E\ninst✝¹ : Module 𝕜 E\ninst✝ : BoundedSMul 𝕜 E\nf : LinearMap (RingHom.id 𝕜) 𝕜 E\nx : 𝕜\n⊢ Eq (f.toContinuousLinearMap₁ x) (f x)","decl":"@[simp]\ntheorem LinearMap.toContinuousLinearMap₁_apply (f : 𝕜 →ₗ[𝕜] E) (x) :\n    f.toContinuousLinearMap₁ x = f x :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.isUniformEmbedding_of_bound","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_3\nF : Type u_4\ninst✝⁵ : Ring 𝕜\ninst✝⁴ : Ring 𝕜₂\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜₂ F\nσ : RingHom 𝕜 𝕜₂\nf : ContinuousLinearMap σ E F\nK : NNReal\nhf : ∀ (x : E), LE.le (Norm.norm x) (HMul.hMul (↑K) (Norm.norm (f x)))\n⊢ IsUniformEmbedding ⇑f","decl":"theorem ContinuousLinearMap.isUniformEmbedding_of_bound {K : ℝ≥0} (hf : ∀ x, ‖x‖ ≤ K * ‖f x‖) :\n    IsUniformEmbedding f :=\n  (AddMonoidHomClass.antilipschitz_of_bound f hf).isUniformEmbedding f.uniformContinuous\n\n"}
{"name":"ContinuousLinearMap.uniformEmbedding_of_bound","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_3\nF : Type u_4\ninst✝⁵ : Ring 𝕜\ninst✝⁴ : Ring 𝕜₂\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜₂ F\nσ : RingHom 𝕜 𝕜₂\nf : ContinuousLinearMap σ E F\nK : NNReal\nhf : ∀ (x : E), LE.le (Norm.norm x) (HMul.hMul (↑K) (Norm.norm (f x)))\n⊢ IsUniformEmbedding ⇑f","decl":"@[deprecated (since := \"2024-10-01\")]\nalias ContinuousLinearMap.uniformEmbedding_of_bound :=\n  ContinuousLinearMap.isUniformEmbedding_of_bound\n\n"}
{"name":"ContinuousLinearEquiv.homothety_inverse","module":"Mathlib.Analysis.Normed.Operator.ContinuousLinearMap","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_3\nF : Type u_4\ninst✝⁷ : Ring 𝕜\ninst✝⁶ : Ring 𝕜₂\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : SeminormedAddCommGroup F\ninst✝³ : Module 𝕜 E\ninst✝² : Module 𝕜₂ F\nσ : RingHom 𝕜 𝕜₂\nσ₂₁ : RingHom 𝕜₂ 𝕜\ninst✝¹ : RingHomInvPair σ σ₂₁\ninst✝ : RingHomInvPair σ₂₁ σ\na : Real\nha : LT.lt 0 a\nf : LinearEquiv σ E F\na✝ : ∀ (x : E), Eq (Norm.norm (f x)) (HMul.hMul a (Norm.norm x))\ny : F\n⊢ Eq (Norm.norm (f.symm y)) (HMul.hMul (Inv.inv a) (Norm.norm y))","decl":"theorem ContinuousLinearEquiv.homothety_inverse (a : ℝ) (ha : 0 < a) (f : E ≃ₛₗ[σ] F) :\n    (∀ x : E, ‖f x‖ = a * ‖x‖) → ∀ y : F, ‖f.symm y‖ = a⁻¹ * ‖y‖ := by\n  intro hf y\n  calc\n    ‖f.symm y‖ = a⁻¹ * (a * ‖f.symm y‖) := by\n      rw [← mul_assoc, inv_mul_cancel₀ (ne_of_lt ha).symm, one_mul]\n    _ = a⁻¹ * ‖f (f.symm y)‖ := by rw [hf]\n    _ = a⁻¹ * ‖y‖ := by simp\n\n"}
