{"name":"Acc.rank_eq","module":"Mathlib.SetTheory.Ordinal.Rank","initialProofState":"α : Type u\na : α\nr : α → α → Prop\nh : Acc r a\n⊢ Eq h.rank (iSup fun b => Order.succ ⋯.rank)","decl":"theorem rank_eq (h : Acc r a) :\n    h.rank = ⨆ b : { b // r b a }, Order.succ (h.inv b.2).rank := by\n  change (Acc.intro a fun _ => h.inv).rank = _\n  rfl\n\n"}
{"name":"Acc.rank_lt_of_rel","module":"Mathlib.SetTheory.Ordinal.Rank","initialProofState":"α : Type u\na b : α\nr : α → α → Prop\nhb : Acc r b\nh : r a b\n⊢ LT.lt ⋯.rank hb.rank","decl":"/-- if `r a b` then the rank of `a` is less than the rank of `b`. -/\ntheorem rank_lt_of_rel (hb : Acc r b) (h : r a b) : (hb.inv h).rank < hb.rank :=\n  (Order.lt_succ _).trans_le <| by\n    rw [hb.rank_eq]\n    exact Ordinal.le_iSup _ (⟨a, h⟩ : {a // r a b})\n\n"}
{"name":"Acc.mem_range_rank_of_le","module":"Mathlib.SetTheory.Ordinal.Rank","initialProofState":"α : Type u\na : α\nr : α → α → Prop\no : Ordinal.{u}\nha : Acc r a\nho : LE.le o ha.rank\n⊢ Exists fun b => Exists fun hb => Eq hb.rank o","decl":"theorem mem_range_rank_of_le {o : Ordinal} (ha : Acc r a) (ho : o ≤ ha.rank) :\n    ∃ (b : α) (hb : Acc r b), hb.rank = o := by\n  obtain rfl | ho := ho.eq_or_lt\n  · exact ⟨a, ha, rfl⟩\n  · revert ho\n    refine ha.recOn fun a ha IH ho ↦ ?_\n    rw [rank_eq, Ordinal.lt_iSup_iff] at ho\n    obtain ⟨⟨b, hb⟩, ho⟩ := ho\n    rw [Order.lt_succ_iff] at ho\n    obtain rfl | ho := ho.eq_or_lt\n    exacts [⟨b, ha b hb, rfl⟩, IH _ hb ho]\n\n"}
{"name":"IsWellFounded.rank_eq","module":"Mathlib.SetTheory.Ordinal.Rank","initialProofState":"α : Type u\nr : α → α → Prop\nhwf : IsWellFounded α r\na : α\n⊢ Eq (IsWellFounded.rank r a) (iSup fun b => Order.succ (IsWellFounded.rank r ↑b))","decl":"theorem rank_eq (a : α) : rank r a = ⨆ b : { b // r b a }, Order.succ (rank r b) :=\n  (hwf.apply r a).rank_eq\n\n"}
{"name":"IsWellFounded.rank_lt_of_rel","module":"Mathlib.SetTheory.Ordinal.Rank","initialProofState":"α : Type u\na b : α\nr : α → α → Prop\nhwf : IsWellFounded α r\nh : r a b\n⊢ LT.lt (IsWellFounded.rank r a) (IsWellFounded.rank r b)","decl":"theorem rank_lt_of_rel (h : r a b) : rank r a < rank r b :=\n  Acc.rank_lt_of_rel _ h\n\n"}
{"name":"IsWellFounded.mem_range_rank_of_le","module":"Mathlib.SetTheory.Ordinal.Rank","initialProofState":"α : Type u\na : α\nr : α → α → Prop\nhwf : IsWellFounded α r\no : Ordinal.{u}\nh : LE.le o (IsWellFounded.rank r a)\n⊢ Membership.mem (Set.range (IsWellFounded.rank r)) o","decl":"theorem mem_range_rank_of_le {o : Ordinal} (h : o ≤ rank r a) : o ∈ Set.range (rank r) := by\n  obtain ⟨b, hb, rfl⟩ := Acc.mem_range_rank_of_le (hwf.apply r a) h\n  exact ⟨b, rfl⟩\n\n"}
{"name":"WellFoundedLT.rank_strictMono","module":"Mathlib.SetTheory.Ordinal.Rank","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : WellFoundedLT α\n⊢ StrictMono (IsWellFounded.rank fun x1 x2 => LT.lt x1 x2)","decl":"theorem WellFoundedLT.rank_strictMono [Preorder α] [WellFoundedLT α] :\n    StrictMono (IsWellFounded.rank (α := α) (· < ·)) :=\n  fun _ _ => IsWellFounded.rank_lt_of_rel\n\n"}
{"name":"WellFoundedGT.rank_strictAnti","module":"Mathlib.SetTheory.Ordinal.Rank","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : WellFoundedGT α\n⊢ StrictAnti (IsWellFounded.rank fun x1 x2 => GT.gt x1 x2)","decl":"theorem WellFoundedGT.rank_strictAnti [Preorder α] [WellFoundedGT α] :\n    StrictAnti (IsWellFounded.rank (α := α) (· > ·)) :=\n  fun _ _ a => IsWellFounded.rank_lt_of_rel a\n\n"}
{"name":"IsWellFounded.rank_eq_typein","module":"Mathlib.SetTheory.Ordinal.Rank","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellOrder α r\n⊢ Eq (IsWellFounded.rank r) ⇑(Ordinal.typein r).toRelEmbedding","decl":"@[simp]\ntheorem IsWellFounded.rank_eq_typein (r) [IsWellOrder α r] : rank r = Ordinal.typein r := by\n  classical\n  letI := linearOrderOfSTO r\n  ext a\n  exact InitialSeg.eq (⟨(OrderEmbedding.ofStrictMono _ WellFoundedLT.rank_strictMono).ltEmbedding,\n    fun a b h ↦ mem_range_rank_of_le h.le⟩) (Ordinal.typein r) a\n\n"}
{"name":"WellFounded.rank_eq","module":"Mathlib.SetTheory.Ordinal.Rank","initialProofState":"α : Type u\na : α\nr : α → α → Prop\nhwf : WellFounded r\n⊢ Eq (hwf.rank a) (iSup fun b => Order.succ (hwf.rank ↑b))","decl":"set_option linter.deprecated false in\n@[deprecated IsWellFounded.rank_eq (since := \"2024-09-07\")]\ntheorem rank_eq : hwf.rank a = ⨆ b : { b // r b a }, Order.succ (hwf.rank b) :=\n  (hwf.apply a).rank_eq\n\n"}
{"name":"WellFounded.rank_lt_of_rel","module":"Mathlib.SetTheory.Ordinal.Rank","initialProofState":"α : Type u\na b : α\nr : α → α → Prop\nhwf : WellFounded r\nh : r a b\n⊢ LT.lt (hwf.rank a) (hwf.rank b)","decl":"set_option linter.deprecated false in\n@[deprecated IsWellFounded.rank_lt_of_rel (since := \"2024-09-07\")]\ntheorem rank_lt_of_rel (h : r a b) : hwf.rank a < hwf.rank b :=\n  Acc.rank_lt_of_rel _ h\n\n"}
{"name":"WellFounded.rank_strictMono","module":"Mathlib.SetTheory.Ordinal.Rank","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : WellFoundedLT α\n⊢ StrictMono ⋯.rank","decl":"set_option linter.deprecated false in\n@[deprecated WellFoundedLT.rank_strictMono (since := \"2024-09-07\")]\ntheorem rank_strictMono [Preorder α] [WellFoundedLT α] :\n    StrictMono (rank <| @wellFounded_lt α _ _) := fun _ _ => rank_lt_of_rel _\n\n"}
{"name":"WellFounded.rank_strictAnti","module":"Mathlib.SetTheory.Ordinal.Rank","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : WellFoundedGT α\n⊢ StrictAnti ⋯.rank","decl":"set_option linter.deprecated false in\n@[deprecated WellFoundedGT.rank_strictAnti (since := \"2024-09-07\")]\ntheorem rank_strictAnti [Preorder α] [WellFoundedGT α] :\n    StrictAnti (rank <| @wellFounded_gt α _ _) := fun _ _ => rank_lt_of_rel wellFounded_gt\n\n"}
