{"name":"ENNReal.lintegral_mul_le_one_of_lintegral_rpow_eq_one","module":"Mathlib.MeasureTheory.Integral.MeanInequalities","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\np q : Real\nhpq : p.IsConjExponent q\nf g : α → ENNReal\nhf : AEMeasurable f μ\nhf_norm : Eq (MeasureTheory.lintegral μ fun a => HPow.hPow (f a) p) 1\nhg_norm : Eq (MeasureTheory.lintegral μ fun a => HPow.hPow (g a) q) 1\n⊢ LE.le (MeasureTheory.lintegral μ fun a => HMul.hMul f g a) 1","decl":"theorem lintegral_mul_le_one_of_lintegral_rpow_eq_one {p q : ℝ} (hpq : p.IsConjExponent q)\n    {f g : α → ℝ≥0∞} (hf : AEMeasurable f μ) (hf_norm : ∫⁻ a, f a ^ p ∂μ = 1)\n    (hg_norm : ∫⁻ a, g a ^ q ∂μ = 1) : (∫⁻ a, (f * g) a ∂μ) ≤ 1 := by\n  calc\n    (∫⁻ a : α, (f * g) a ∂μ) ≤\n        ∫⁻ a : α, f a ^ p / ENNReal.ofReal p + g a ^ q / ENNReal.ofReal q ∂μ :=\n      lintegral_mono fun a => young_inequality (f a) (g a) hpq\n    _ = 1 := by\n      simp only [div_eq_mul_inv]\n      rw [lintegral_add_left']\n      · rw [lintegral_mul_const'' _ (hf.pow_const p), lintegral_mul_const', hf_norm, hg_norm,\n          one_mul, one_mul, hpq.inv_add_inv_conj_ennreal]\n        simp [hpq.symm.pos]\n      · exact (hf.pow_const _).mul_const _\n\n"}
{"name":"ENNReal.fun_eq_funMulInvSnorm_mul_eLpNorm","module":"Mathlib.MeasureTheory.Integral.MeanInequalities","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\np : Real\nf : α → ENNReal\nhf_nonzero : Ne (MeasureTheory.lintegral μ fun a => HPow.hPow (f a) p) 0\nhf_top : Ne (MeasureTheory.lintegral μ fun a => HPow.hPow (f a) p) Top.top\na : α\n⊢ Eq (f a) (HMul.hMul (ENNReal.funMulInvSnorm f p μ a) (HPow.hPow (MeasureTheory.lintegral μ fun c => HPow.hPow (f c) p) (HDiv.hDiv 1 p)))","decl":"theorem fun_eq_funMulInvSnorm_mul_eLpNorm {p : ℝ} (f : α → ℝ≥0∞)\n    (hf_nonzero : (∫⁻ a, f a ^ p ∂μ) ≠ 0) (hf_top : (∫⁻ a, f a ^ p ∂μ) ≠ ⊤) {a : α} :\n    f a = funMulInvSnorm f p μ a * (∫⁻ c, f c ^ p ∂μ) ^ (1 / p) := by\n  simp [funMulInvSnorm, mul_assoc, ENNReal.inv_mul_cancel, hf_nonzero, hf_top]\n\n"}
{"name":"ENNReal.funMulInvSnorm_rpow","module":"Mathlib.MeasureTheory.Integral.MeanInequalities","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\np : Real\nhp0 : LT.lt 0 p\nf : α → ENNReal\na : α\n⊢ Eq (HPow.hPow (ENNReal.funMulInvSnorm f p μ a) p) (HMul.hMul (HPow.hPow (f a) p) (Inv.inv (MeasureTheory.lintegral μ fun c => HPow.hPow (f c) p)))","decl":"theorem funMulInvSnorm_rpow {p : ℝ} (hp0 : 0 < p) {f : α → ℝ≥0∞} {a : α} :\n    funMulInvSnorm f p μ a ^ p = f a ^ p * (∫⁻ c, f c ^ p ∂μ)⁻¹ := by\n  rw [funMulInvSnorm, mul_rpow_of_nonneg _ _ (le_of_lt hp0)]\n  suffices h_inv_rpow : ((∫⁻ c : α, f c ^ p ∂μ) ^ (1 / p))⁻¹ ^ p = (∫⁻ c : α, f c ^ p ∂μ)⁻¹ by\n    rw [h_inv_rpow]\n  rw [inv_rpow, ← rpow_mul, one_div_mul_cancel hp0.ne', rpow_one]\n\n"}
{"name":"ENNReal.lintegral_rpow_funMulInvSnorm_eq_one","module":"Mathlib.MeasureTheory.Integral.MeanInequalities","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\np : Real\nhp0_lt : LT.lt 0 p\nf : α → ENNReal\nhf_nonzero : Ne (MeasureTheory.lintegral μ fun a => HPow.hPow (f a) p) 0\nhf_top : Ne (MeasureTheory.lintegral μ fun a => HPow.hPow (f a) p) Top.top\n⊢ Eq (MeasureTheory.lintegral μ fun c => HPow.hPow (ENNReal.funMulInvSnorm f p μ c) p) 1","decl":"theorem lintegral_rpow_funMulInvSnorm_eq_one {p : ℝ} (hp0_lt : 0 < p) {f : α → ℝ≥0∞}\n    (hf_nonzero : (∫⁻ a, f a ^ p ∂μ) ≠ 0) (hf_top : (∫⁻ a, f a ^ p ∂μ) ≠ ⊤) :\n    ∫⁻ c, funMulInvSnorm f p μ c ^ p ∂μ = 1 := by\n  simp_rw [funMulInvSnorm_rpow hp0_lt]\n  rw [lintegral_mul_const', ENNReal.mul_inv_cancel hf_nonzero hf_top]\n  rwa [inv_ne_top]\n\n"}
{"name":"ENNReal.lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_ne_top","module":"Mathlib.MeasureTheory.Integral.MeanInequalities","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\np q : Real\nhpq : p.IsConjExponent q\nf g : α → ENNReal\nhf : AEMeasurable f μ\nhf_nontop : Ne (MeasureTheory.lintegral μ fun a => HPow.hPow (f a) p) Top.top\nhg_nontop : Ne (MeasureTheory.lintegral μ fun a => HPow.hPow (g a) q) Top.top\nhf_nonzero : Ne (MeasureTheory.lintegral μ fun a => HPow.hPow (f a) p) 0\nhg_nonzero : Ne (MeasureTheory.lintegral μ fun a => HPow.hPow (g a) q) 0\n⊢ LE.le (MeasureTheory.lintegral μ fun a => HMul.hMul f g a) (HMul.hMul (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (f a) p) (HDiv.hDiv 1 p)) (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (g a) q) (HDiv.hDiv 1 q)))","decl":"/-- Hölder's inequality in case of finite non-zero integrals -/\ntheorem lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_ne_top {p q : ℝ} (hpq : p.IsConjExponent q)\n    {f g : α → ℝ≥0∞} (hf : AEMeasurable f μ) (hf_nontop : (∫⁻ a, f a ^ p ∂μ) ≠ ⊤)\n    (hg_nontop : (∫⁻ a, g a ^ q ∂μ) ≠ ⊤) (hf_nonzero : (∫⁻ a, f a ^ p ∂μ) ≠ 0)\n    (hg_nonzero : (∫⁻ a, g a ^ q ∂μ) ≠ 0) :\n    (∫⁻ a, (f * g) a ∂μ) ≤ (∫⁻ a, f a ^ p ∂μ) ^ (1 / p) * (∫⁻ a, g a ^ q ∂μ) ^ (1 / q) := by\n  let npf := (∫⁻ c : α, f c ^ p ∂μ) ^ (1 / p)\n  let nqg := (∫⁻ c : α, g c ^ q ∂μ) ^ (1 / q)\n  calc\n    (∫⁻ a : α, (f * g) a ∂μ) =\n        ∫⁻ a : α, (funMulInvSnorm f p μ * funMulInvSnorm g q μ) a * (npf * nqg) ∂μ := by\n      refine lintegral_congr fun a => ?_\n      rw [Pi.mul_apply, fun_eq_funMulInvSnorm_mul_eLpNorm f hf_nonzero hf_nontop,\n        fun_eq_funMulInvSnorm_mul_eLpNorm g hg_nonzero hg_nontop, Pi.mul_apply]\n      ring\n    _ ≤ npf * nqg := by\n      rw [lintegral_mul_const' (npf * nqg) _\n          (by simp [npf, nqg, hf_nontop, hg_nontop, hf_nonzero, hg_nonzero, ENNReal.mul_eq_top])]\n      refine mul_le_of_le_one_left' ?_\n      have hf1 := lintegral_rpow_funMulInvSnorm_eq_one hpq.pos hf_nonzero hf_nontop\n      have hg1 := lintegral_rpow_funMulInvSnorm_eq_one hpq.symm.pos hg_nonzero hg_nontop\n      exact lintegral_mul_le_one_of_lintegral_rpow_eq_one hpq (hf.mul_const _) hf1 hg1\n\n"}
{"name":"ENNReal.ae_eq_zero_of_lintegral_rpow_eq_zero","module":"Mathlib.MeasureTheory.Integral.MeanInequalities","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\np : Real\nhp0 : LE.le 0 p\nf : α → ENNReal\nhf : AEMeasurable f μ\nhf_zero : Eq (MeasureTheory.lintegral μ fun a => HPow.hPow (f a) p) 0\n⊢ (MeasureTheory.ae μ).EventuallyEq f 0","decl":"theorem ae_eq_zero_of_lintegral_rpow_eq_zero {p : ℝ} (hp0 : 0 ≤ p) {f : α → ℝ≥0∞}\n    (hf : AEMeasurable f μ) (hf_zero : ∫⁻ a, f a ^ p ∂μ = 0) : f =ᵐ[μ] 0 := by\n  rw [lintegral_eq_zero_iff' (hf.pow_const p)] at hf_zero\n  filter_upwards [hf_zero] with x\n  rw [Pi.zero_apply, ← not_imp_not]\n  exact fun hx => (rpow_pos_of_nonneg (pos_iff_ne_zero.2 hx) hp0).ne'\n\n"}
{"name":"ENNReal.lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero","module":"Mathlib.MeasureTheory.Integral.MeanInequalities","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\np : Real\nhp0 : LE.le 0 p\nf g : α → ENNReal\nhf : AEMeasurable f μ\nhf_zero : Eq (MeasureTheory.lintegral μ fun a => HPow.hPow (f a) p) 0\n⊢ Eq (MeasureTheory.lintegral μ fun a => HMul.hMul f g a) 0","decl":"theorem lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero {p : ℝ} (hp0 : 0 ≤ p) {f g : α → ℝ≥0∞}\n    (hf : AEMeasurable f μ) (hf_zero : ∫⁻ a, f a ^ p ∂μ = 0) : (∫⁻ a, (f * g) a ∂μ) = 0 := by\n  rw [← @lintegral_zero_fun α _ μ]\n  refine lintegral_congr_ae ?_\n  suffices h_mul_zero : f * g =ᵐ[μ] 0 * g by rwa [zero_mul] at h_mul_zero\n  have hf_eq_zero : f =ᵐ[μ] 0 := ae_eq_zero_of_lintegral_rpow_eq_zero hp0 hf hf_zero\n  exact hf_eq_zero.mul (ae_eq_refl g)\n\n"}
{"name":"ENNReal.lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_eq_top","module":"Mathlib.MeasureTheory.Integral.MeanInequalities","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\np q : Real\nhp0_lt : LT.lt 0 p\nhq0 : LE.le 0 q\nf g : α → ENNReal\nhf_top : Eq (MeasureTheory.lintegral μ fun a => HPow.hPow (f a) p) Top.top\nhg_nonzero : Ne (MeasureTheory.lintegral μ fun a => HPow.hPow (g a) q) 0\n⊢ LE.le (MeasureTheory.lintegral μ fun a => HMul.hMul f g a) (HMul.hMul (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (f a) p) (HDiv.hDiv 1 p)) (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (g a) q) (HDiv.hDiv 1 q)))","decl":"theorem lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_eq_top {p q : ℝ} (hp0_lt : 0 < p) (hq0 : 0 ≤ q)\n    {f g : α → ℝ≥0∞} (hf_top : ∫⁻ a, f a ^ p ∂μ = ⊤) (hg_nonzero : (∫⁻ a, g a ^ q ∂μ) ≠ 0) :\n    (∫⁻ a, (f * g) a ∂μ) ≤ (∫⁻ a, f a ^ p ∂μ) ^ (1 / p) * (∫⁻ a, g a ^ q ∂μ) ^ (1 / q) := by\n  refine le_trans le_top (le_of_eq ?_)\n  have hp0_inv_lt : 0 < 1 / p := by simp [hp0_lt]\n  rw [hf_top, ENNReal.top_rpow_of_pos hp0_inv_lt]\n  simp [hq0, hg_nonzero]\n\n"}
{"name":"ENNReal.lintegral_mul_le_Lp_mul_Lq","module":"Mathlib.MeasureTheory.Integral.MeanInequalities","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\np q : Real\nhpq : p.IsConjExponent q\nf g : α → ENNReal\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ LE.le (MeasureTheory.lintegral μ fun a => HMul.hMul f g a) (HMul.hMul (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (f a) p) (HDiv.hDiv 1 p)) (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (g a) q) (HDiv.hDiv 1 q)))","decl":"/-- Hölder's inequality for functions `α → ℝ≥0∞`. The integral of the product of two functions\nis bounded by the product of their `ℒp` and `ℒq` seminorms when `p` and `q` are conjugate\nexponents. -/\ntheorem lintegral_mul_le_Lp_mul_Lq (μ : Measure α) {p q : ℝ} (hpq : p.IsConjExponent q)\n    {f g : α → ℝ≥0∞} (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    (∫⁻ a, (f * g) a ∂μ) ≤ (∫⁻ a, f a ^ p ∂μ) ^ (1 / p) * (∫⁻ a, g a ^ q ∂μ) ^ (1 / q) := by\n  by_cases hf_zero : ∫⁻ a, f a ^ p ∂μ = 0\n  · refine Eq.trans_le ?_ (zero_le _)\n    exact lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero hpq.nonneg hf hf_zero\n  by_cases hg_zero : ∫⁻ a, g a ^ q ∂μ = 0\n  · refine Eq.trans_le ?_ (zero_le _)\n    rw [mul_comm]\n    exact lintegral_mul_eq_zero_of_lintegral_rpow_eq_zero hpq.symm.nonneg hg hg_zero\n  by_cases hf_top : ∫⁻ a, f a ^ p ∂μ = ⊤\n  · exact lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_eq_top hpq.pos hpq.symm.nonneg hf_top hg_zero\n  by_cases hg_top : ∫⁻ a, g a ^ q ∂μ = ⊤\n  · rw [mul_comm, mul_comm ((∫⁻ a : α, f a ^ p ∂μ) ^ (1 / p))]\n    exact lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_eq_top hpq.symm.pos hpq.nonneg hg_top hf_zero\n  -- non-⊤ non-zero case\n  exact ENNReal.lintegral_mul_le_Lp_mul_Lq_of_ne_zero_of_ne_top hpq hf hf_top hg_top hf_zero hg_zero\n\n"}
{"name":"ENNReal.lintegral_mul_norm_pow_le","module":"Mathlib.MeasureTheory.Integral.MeanInequalities","initialProofState":"α : Type u_2\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\np q : Real\nhp : LE.le 0 p\nhq : LE.le 0 q\nhpq : Eq (HAdd.hAdd p q) 1\n⊢ LE.le (MeasureTheory.lintegral μ fun a => HMul.hMul (HPow.hPow (f a) p) (HPow.hPow (g a) q)) (HMul.hMul (HPow.hPow (MeasureTheory.lintegral μ fun a => f a) p) (HPow.hPow (MeasureTheory.lintegral μ fun a => g a) q))","decl":"/-- A different formulation of Hölder's inequality for two functions, with two exponents that sum to\n1, instead of reciprocals of  -/\ntheorem lintegral_mul_norm_pow_le {α} [MeasurableSpace α] {μ : Measure α}\n    {f g : α → ℝ≥0∞} (hf : AEMeasurable f μ) (hg : AEMeasurable g μ)\n    {p q : ℝ} (hp : 0 ≤ p) (hq : 0 ≤ q) (hpq : p + q = 1) :\n    ∫⁻ a, f a ^ p * g a ^ q ∂μ ≤ (∫⁻ a, f a ∂μ) ^ p * (∫⁻ a, g a ∂μ) ^ q := by\n  rcases hp.eq_or_lt with rfl|hp\n  · rw [zero_add] at hpq\n    simp [hpq]\n  rcases hq.eq_or_lt with rfl|hq\n  · rw [add_zero] at hpq\n    simp [hpq]\n  have h2p : 1 < 1 / p := by\n    rw [one_div, one_lt_inv₀ hp]\n    linarith\n  have h2pq : (1 / p)⁻¹ + (1 / q)⁻¹ = 1 := by simp [hp.ne', hq.ne', hpq]\n  have := ENNReal.lintegral_mul_le_Lp_mul_Lq μ ⟨h2p, h2pq⟩ (hf.pow_const p) (hg.pow_const q)\n  simpa [← ENNReal.rpow_mul, hp.ne', hq.ne'] using this\n\n"}
{"name":"ENNReal.lintegral_prod_norm_pow_le","module":"Mathlib.MeasureTheory.Integral.MeanInequalities","initialProofState":"α : Type u_2\nι : Type u_3\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Finset ι\nf : ι → α → ENNReal\nhf : ∀ (i : ι), Membership.mem s i → AEMeasurable (f i) μ\np : ι → Real\nhp : Eq (s.sum fun i => p i) 1\nh2p : ∀ (i : ι), Membership.mem s i → LE.le 0 (p i)\n⊢ LE.le (MeasureTheory.lintegral μ fun a => s.prod fun i => HPow.hPow (f i a) (p i)) (s.prod fun i => HPow.hPow (MeasureTheory.lintegral μ fun a => f i a) (p i))","decl":"/-- A version of Hölder with multiple arguments -/\ntheorem lintegral_prod_norm_pow_le {α ι : Type*} [MeasurableSpace α] {μ : Measure α}\n    (s : Finset ι) {f : ι → α → ℝ≥0∞} (hf : ∀ i ∈ s, AEMeasurable (f i) μ)\n    {p : ι → ℝ} (hp : ∑ i ∈ s, p i = 1) (h2p : ∀ i ∈ s, 0 ≤ p i) :\n    ∫⁻ a, ∏ i ∈ s, f i a ^ p i ∂μ ≤ ∏ i ∈ s, (∫⁻ a, f i a ∂μ) ^ p i := by\n  classical\n  induction s using Finset.induction generalizing p with\n  | empty =>\n    simp at hp\n  | @insert i₀ s hi₀ ih =>\n    rcases eq_or_ne (p i₀) 1 with h2i₀|h2i₀\n    · simp only [hi₀, not_false_eq_true, prod_insert]\n      have h2p : ∀ i ∈ s, p i = 0 := by\n        simpa [hi₀, h2i₀, sum_eq_zero_iff_of_nonneg (fun i hi ↦ h2p i <| mem_insert_of_mem hi)]\n          using hp\n      calc ∫⁻ a, f i₀ a ^ p i₀ * ∏ i ∈ s, f i a ^ p i ∂μ\n          = ∫⁻ a, f i₀ a ^ p i₀ * ∏ i ∈ s, 1 ∂μ := by\n            congr! 3 with x\n            apply prod_congr rfl fun i hi ↦ by rw [h2p i hi, ENNReal.rpow_zero]\n        _ ≤ (∫⁻ a, f i₀ a ∂μ) ^ p i₀ * ∏ i ∈ s, 1 := by simp [h2i₀]\n        _ = (∫⁻ a, f i₀ a ∂μ) ^ p i₀ * ∏ i ∈ s, (∫⁻ a, f i a ∂μ) ^ p i := by\n            congr 1\n            apply prod_congr rfl fun i hi ↦ by rw [h2p i hi, ENNReal.rpow_zero]\n    · have hpi₀ : 0 ≤ 1 - p i₀ := by\n        simp_rw [sub_nonneg, ← hp, single_le_sum h2p (mem_insert_self ..)]\n      have h2pi₀ : 1 - p i₀ ≠ 0 := by\n        rwa [sub_ne_zero, ne_comm]\n      let q := fun i ↦ p i / (1 - p i₀)\n      have hq : ∑ i ∈ s, q i = 1 := by\n        rw [← Finset.sum_div, ← sum_insert_sub hi₀, hp, div_self h2pi₀]\n      have h2q : ∀ i ∈ s, 0 ≤ q i :=\n        fun i hi ↦ div_nonneg (h2p i <| mem_insert_of_mem hi) hpi₀\n      calc ∫⁻ a, ∏ i ∈ insert i₀ s, f i a ^ p i ∂μ\n          = ∫⁻ a, f i₀ a ^ p i₀ * ∏ i ∈ s, f i a ^ p i ∂μ := by simp [hi₀]\n        _ = ∫⁻ a, f i₀ a ^ p i₀ * (∏ i ∈ s, f i a ^ q i) ^ (1 - p i₀) ∂μ := by\n            simp [q, ← ENNReal.prod_rpow_of_nonneg hpi₀, ← ENNReal.rpow_mul,\n              div_mul_cancel₀ (h := h2pi₀)]\n        _ ≤ (∫⁻ a, f i₀ a ∂μ) ^ p i₀ * (∫⁻ a, ∏ i ∈ s, f i a ^ q i ∂μ) ^ (1 - p i₀) := by\n            apply ENNReal.lintegral_mul_norm_pow_le\n            · exact hf i₀ <| mem_insert_self ..\n            · exact s.aemeasurable_prod fun i hi ↦ (hf i <| mem_insert_of_mem hi).pow_const _\n            · exact h2p i₀ <| mem_insert_self ..\n            · exact hpi₀\n            · apply add_sub_cancel\n        _ ≤ (∫⁻ a, f i₀ a ∂μ) ^ p i₀ * (∏ i ∈ s, (∫⁻ a, f i a ∂μ) ^ q i) ^ (1 - p i₀) := by\n            gcongr -- behavior of gcongr is heartbeat-dependent, which makes code really fragile...\n            exact ih (fun i hi ↦ hf i <| mem_insert_of_mem hi) hq h2q\n        _ = (∫⁻ a, f i₀ a ∂μ) ^ p i₀ * ∏ i ∈ s, (∫⁻ a, f i a ∂μ) ^ p i := by\n            simp [q, ← ENNReal.prod_rpow_of_nonneg hpi₀, ← ENNReal.rpow_mul,\n              div_mul_cancel₀ (h := h2pi₀)]\n        _ = ∏ i ∈ insert i₀ s, (∫⁻ a, f i a ∂μ) ^ p i := by simp [hi₀]\n\n"}
{"name":"ENNReal.lintegral_mul_prod_norm_pow_le","module":"Mathlib.MeasureTheory.Integral.MeanInequalities","initialProofState":"α : Type u_2\nι : Type u_3\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Finset ι\ng : α → ENNReal\nf : ι → α → ENNReal\nhg : AEMeasurable g μ\nhf : ∀ (i : ι), Membership.mem s i → AEMeasurable (f i) μ\nq : Real\np : ι → Real\nhpq : Eq (HAdd.hAdd q (s.sum fun i => p i)) 1\nhq : LE.le 0 q\nhp : ∀ (i : ι), Membership.mem s i → LE.le 0 (p i)\n⊢ LE.le (MeasureTheory.lintegral μ fun a => HMul.hMul (HPow.hPow (g a) q) (s.prod fun i => HPow.hPow (f i a) (p i))) (HMul.hMul (HPow.hPow (MeasureTheory.lintegral μ fun a => g a) q) (s.prod fun i => HPow.hPow (MeasureTheory.lintegral μ fun a => f i a) (p i)))","decl":"/-- A version of Hölder with multiple arguments, one of which plays a distinguished role. -/\ntheorem lintegral_mul_prod_norm_pow_le {α ι : Type*} [MeasurableSpace α] {μ : Measure α}\n    (s : Finset ι) {g : α →  ℝ≥0∞} {f : ι → α → ℝ≥0∞} (hg : AEMeasurable g μ)\n    (hf : ∀ i ∈ s, AEMeasurable (f i) μ) (q : ℝ) {p : ι → ℝ} (hpq : q + ∑ i ∈ s, p i = 1)\n    (hq :  0 ≤ q) (hp : ∀ i ∈ s, 0 ≤ p i) :\n    ∫⁻ a, g a ^ q * ∏ i ∈ s, f i a ^ p i ∂μ ≤\n      (∫⁻ a, g a ∂μ) ^ q * ∏ i ∈ s, (∫⁻ a, f i a ∂μ) ^ p i := by\n  suffices\n    ∫⁻ t, ∏ j ∈ insertNone s, Option.elim j (g t) (fun j ↦ f j t) ^ Option.elim j q p ∂μ\n    ≤ ∏ j ∈ insertNone s, (∫⁻ t, Option.elim j (g t) (fun j ↦ f j t) ∂μ) ^ Option.elim j q p by\n    simpa using this\n  refine ENNReal.lintegral_prod_norm_pow_le _ ?_ ?_ ?_\n  · rintro (_|i) hi\n    · exact hg\n    · refine hf i ?_\n      simpa using hi\n  · simp_rw [sum_insertNone, Option.elim]\n    exact hpq\n  · rintro (_|i) hi\n    · exact hq\n    · refine hp i ?_\n      simpa using hi\n\n"}
{"name":"ENNReal.lintegral_rpow_add_lt_top_of_lintegral_rpow_lt_top","module":"Mathlib.MeasureTheory.Integral.MeanInequalities","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\np : Real\nf g : α → ENNReal\nhf : AEMeasurable f μ\nhf_top : LT.lt (MeasureTheory.lintegral μ fun a => HPow.hPow (f a) p) Top.top\nhg_top : LT.lt (MeasureTheory.lintegral μ fun a => HPow.hPow (g a) p) Top.top\nhp1 : LE.le 1 p\n⊢ LT.lt (MeasureTheory.lintegral μ fun a => HPow.hPow (HAdd.hAdd f g a) p) Top.top","decl":"theorem lintegral_rpow_add_lt_top_of_lintegral_rpow_lt_top {p : ℝ} {f g : α → ℝ≥0∞}\n    (hf : AEMeasurable f μ) (hf_top : (∫⁻ a, f a ^ p ∂μ) < ⊤) (hg_top : (∫⁻ a, g a ^ p ∂μ) < ⊤)\n    (hp1 : 1 ≤ p) : (∫⁻ a, (f + g) a ^ p ∂μ) < ⊤ := by\n  have hp0_lt : 0 < p := lt_of_lt_of_le zero_lt_one hp1\n  have hp0 : 0 ≤ p := le_of_lt hp0_lt\n  calc\n    (∫⁻ a : α, (f a + g a) ^ p ∂μ) ≤\n        ∫⁻ a, (2 : ℝ≥0∞) ^ (p - 1) * f a ^ p + (2 : ℝ≥0∞) ^ (p - 1) * g a ^ p ∂μ := by\n      refine lintegral_mono fun a => ?_\n      dsimp only\n      have h_zero_lt_half_rpow : (0 : ℝ≥0∞) < (1 / 2 : ℝ≥0∞) ^ p := by\n        rw [← ENNReal.zero_rpow_of_pos hp0_lt]\n        exact ENNReal.rpow_lt_rpow (by simp [zero_lt_one]) hp0_lt\n      have h_rw : (1 / 2 : ℝ≥0∞) ^ p * (2 : ℝ≥0∞) ^ (p - 1) = 1 / 2 := by\n        rw [sub_eq_add_neg, ENNReal.rpow_add _ _ two_ne_zero ENNReal.coe_ne_top, ← mul_assoc, ←\n          ENNReal.mul_rpow_of_nonneg _ _ hp0, one_div,\n          ENNReal.inv_mul_cancel two_ne_zero ENNReal.coe_ne_top, ENNReal.one_rpow, one_mul,\n          ENNReal.rpow_neg_one]\n      rw [← ENNReal.mul_le_mul_left (ne_of_lt h_zero_lt_half_rpow).symm _]\n      · rw [mul_add, ← mul_assoc, ← mul_assoc, h_rw, ← ENNReal.mul_rpow_of_nonneg _ _ hp0, mul_add]\n        refine\n          ENNReal.rpow_arith_mean_le_arith_mean2_rpow (1 / 2 : ℝ≥0∞) (1 / 2 : ℝ≥0∞) (f a) (g a) ?_\n            hp1\n        rw [ENNReal.div_add_div_same, one_add_one_eq_two,\n          ENNReal.div_self two_ne_zero ENNReal.coe_ne_top]\n      · rw [← lt_top_iff_ne_top]\n        refine ENNReal.rpow_lt_top_of_nonneg hp0 ?_\n        rw [one_div, ENNReal.inv_ne_top]\n        exact two_ne_zero\n    _ < ⊤ := by\n      have h_two : (2 : ℝ≥0∞) ^ (p - 1) ≠ ⊤ :=\n        ENNReal.rpow_ne_top_of_nonneg (by simp [hp1]) ENNReal.coe_ne_top\n      rw [lintegral_add_left', lintegral_const_mul'' _ (hf.pow_const p),\n        lintegral_const_mul' _ _ h_two, ENNReal.add_lt_top]\n      · exact ⟨ENNReal.mul_lt_top h_two.lt_top hf_top, ENNReal.mul_lt_top h_two.lt_top hg_top⟩\n      · exact (hf.pow_const p).const_mul _\n\n"}
{"name":"ENNReal.lintegral_Lp_mul_le_Lq_mul_Lr","module":"Mathlib.MeasureTheory.Integral.MeanInequalities","initialProofState":"α : Type u_2\ninst✝ : MeasurableSpace α\np q r : Real\nhp0_lt : LT.lt 0 p\nhpq : LT.lt p q\nhpqr : Eq (HDiv.hDiv 1 p) (HAdd.hAdd (HDiv.hDiv 1 q) (HDiv.hDiv 1 r))\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ LE.le (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (HMul.hMul f g a) p) (HDiv.hDiv 1 p)) (HMul.hMul (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (f a) q) (HDiv.hDiv 1 q)) (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (g a) r) (HDiv.hDiv 1 r)))","decl":"theorem lintegral_Lp_mul_le_Lq_mul_Lr {α} [MeasurableSpace α] {p q r : ℝ} (hp0_lt : 0 < p)\n    (hpq : p < q) (hpqr : 1 / p = 1 / q + 1 / r) (μ : Measure α) {f g : α → ℝ≥0∞}\n    (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    (∫⁻ a, (f * g) a ^ p ∂μ) ^ (1 / p) ≤\n      (∫⁻ a, f a ^ q ∂μ) ^ (1 / q) * (∫⁻ a, g a ^ r ∂μ) ^ (1 / r) := by\n  have hp0_ne : p ≠ 0 := (ne_of_lt hp0_lt).symm\n  have hp0 : 0 ≤ p := le_of_lt hp0_lt\n  have hq0_lt : 0 < q := lt_of_le_of_lt hp0 hpq\n  have hq0_ne : q ≠ 0 := (ne_of_lt hq0_lt).symm\n  have h_one_div_r : 1 / r = 1 / p - 1 / q := by rw [hpqr]; simp\n  let p2 := q / p\n  let q2 := p2.conjExponent\n  have hp2q2 : p2.IsConjExponent q2 :=\n    .conjExponent (by simp [p2, q2, _root_.lt_div_iff₀, hpq, hp0_lt])\n  calc\n    (∫⁻ a : α, (f * g) a ^ p ∂μ) ^ (1 / p) = (∫⁻ a : α, f a ^ p * g a ^ p ∂μ) ^ (1 / p) := by\n      simp_rw [Pi.mul_apply, ENNReal.mul_rpow_of_nonneg _ _ hp0]\n    _ ≤ ((∫⁻ a, f a ^ (p * p2) ∂μ) ^ (1 / p2) *\n        (∫⁻ a, g a ^ (p * q2) ∂μ) ^ (1 / q2)) ^ (1 / p) := by\n      gcongr\n      simp_rw [ENNReal.rpow_mul]\n      exact ENNReal.lintegral_mul_le_Lp_mul_Lq μ hp2q2 (hf.pow_const _) (hg.pow_const _)\n    _ = (∫⁻ a : α, f a ^ q ∂μ) ^ (1 / q) * (∫⁻ a : α, g a ^ r ∂μ) ^ (1 / r) := by\n      rw [@ENNReal.mul_rpow_of_nonneg _ _ (1 / p) (by simp [hp0]), ← ENNReal.rpow_mul, ←\n        ENNReal.rpow_mul]\n      have hpp2 : p * p2 = q := by\n        symm\n        rw [mul_comm, ← div_eq_iff hp0_ne]\n      have hpq2 : p * q2 = r := by\n        rw [← inv_inv r, ← one_div, ← one_div, h_one_div_r]\n        field_simp [p2, q2, Real.conjExponent, hp0_ne, hq0_ne]\n      simp_rw [div_mul_div_comm, mul_one, mul_comm p2, mul_comm q2, hpp2, hpq2]\n\n"}
{"name":"ENNReal.lintegral_mul_rpow_le_lintegral_rpow_mul_lintegral_rpow","module":"Mathlib.MeasureTheory.Integral.MeanInequalities","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\np q : Real\nhpq : p.IsConjExponent q\nf g : α → ENNReal\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\nhf_top : Ne (MeasureTheory.lintegral μ fun a => HPow.hPow (f a) p) Top.top\n⊢ LE.le (MeasureTheory.lintegral μ fun a => HMul.hMul (f a) (HPow.hPow (g a) (HSub.hSub p 1))) (HMul.hMul (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (f a) p) (HDiv.hDiv 1 p)) (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (g a) p) (HDiv.hDiv 1 q)))","decl":"theorem lintegral_mul_rpow_le_lintegral_rpow_mul_lintegral_rpow {p q : ℝ}\n    (hpq : p.IsConjExponent q) {f g : α → ℝ≥0∞} (hf : AEMeasurable f μ) (hg : AEMeasurable g μ)\n    (hf_top : (∫⁻ a, f a ^ p ∂μ) ≠ ⊤) :\n    (∫⁻ a, f a * g a ^ (p - 1) ∂μ) ≤\n      (∫⁻ a, f a ^ p ∂μ) ^ (1 / p) * (∫⁻ a, g a ^ p ∂μ) ^ (1 / q) := by\n  refine le_trans (ENNReal.lintegral_mul_le_Lp_mul_Lq μ hpq hf (hg.pow_const _)) ?_\n  by_cases hf_zero_rpow : (∫⁻ a : α, f a ^ p ∂μ) ^ (1 / p) = 0\n  · rw [hf_zero_rpow, zero_mul]\n    exact zero_le _\n  have hf_top_rpow : (∫⁻ a : α, f a ^ p ∂μ) ^ (1 / p) ≠ ⊤ := by\n    by_contra h\n    refine hf_top ?_\n    have hp_not_neg : ¬p < 0 := by simp [hpq.nonneg]\n    simpa [hpq.pos, hp_not_neg] using h\n  refine (ENNReal.mul_le_mul_left hf_zero_rpow hf_top_rpow).mpr (le_of_eq ?_)\n  congr\n  ext1 a\n  rw [← ENNReal.rpow_mul, hpq.sub_one_mul_conj]\n\n"}
{"name":"ENNReal.lintegral_rpow_add_le_add_eLpNorm_mul_lintegral_rpow_add","module":"Mathlib.MeasureTheory.Integral.MeanInequalities","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\np q : Real\nhpq : p.IsConjExponent q\nf g : α → ENNReal\nhf : AEMeasurable f μ\nhf_top : Ne (MeasureTheory.lintegral μ fun a => HPow.hPow (f a) p) Top.top\nhg : AEMeasurable g μ\nhg_top : Ne (MeasureTheory.lintegral μ fun a => HPow.hPow (g a) p) Top.top\n⊢ LE.le (MeasureTheory.lintegral μ fun a => HPow.hPow (HAdd.hAdd f g a) p) (HMul.hMul (HAdd.hAdd (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (f a) p) (HDiv.hDiv 1 p)) (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (g a) p) (HDiv.hDiv 1 p))) (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (HAdd.hAdd (f a) (g a)) p) (HDiv.hDiv 1 q)))","decl":"theorem lintegral_rpow_add_le_add_eLpNorm_mul_lintegral_rpow_add {p q : ℝ}\n    (hpq : p.IsConjExponent q) {f g : α → ℝ≥0∞} (hf : AEMeasurable f μ)\n    (hf_top : (∫⁻ a, f a ^ p ∂μ) ≠ ⊤) (hg : AEMeasurable g μ) (hg_top : (∫⁻ a, g a ^ p ∂μ) ≠ ⊤) :\n    (∫⁻ a, (f + g) a ^ p ∂μ) ≤\n      ((∫⁻ a, f a ^ p ∂μ) ^ (1 / p) + (∫⁻ a, g a ^ p ∂μ) ^ (1 / p)) *\n        (∫⁻ a, (f a + g a) ^ p ∂μ) ^ (1 / q) := by\n  calc\n    (∫⁻ a, (f + g) a ^ p ∂μ) ≤ ∫⁻ a, (f + g) a * (f + g) a ^ (p - 1) ∂μ := by\n      gcongr with a\n      by_cases h_zero : (f + g) a = 0\n      · rw [h_zero, ENNReal.zero_rpow_of_pos hpq.pos]\n        exact zero_le _\n      by_cases h_top : (f + g) a = ⊤\n      · rw [h_top, ENNReal.top_rpow_of_pos hpq.sub_one_pos, ENNReal.top_mul_top]\n        exact le_top\n      refine le_of_eq ?_\n      nth_rw 2 [← ENNReal.rpow_one ((f + g) a)]\n      rw [← ENNReal.rpow_add _ _ h_zero h_top, add_sub_cancel]\n    _ = (∫⁻ a : α, f a * (f + g) a ^ (p - 1) ∂μ) + ∫⁻ a : α, g a * (f + g) a ^ (p - 1) ∂μ := by\n      have h_add_m : AEMeasurable (fun a : α => (f + g) a ^ (p - 1 : ℝ)) μ :=\n        (hf.add hg).pow_const _\n      have h_add_apply :\n        (∫⁻ a : α, (f + g) a * (f + g) a ^ (p - 1) ∂μ) =\n          ∫⁻ a : α, (f a + g a) * (f + g) a ^ (p - 1) ∂μ :=\n        rfl\n      simp_rw [h_add_apply, add_mul]\n      rw [lintegral_add_left' (hf.mul h_add_m)]\n    _ ≤\n        ((∫⁻ a, f a ^ p ∂μ) ^ (1 / p) + (∫⁻ a, g a ^ p ∂μ) ^ (1 / p)) *\n          (∫⁻ a, (f a + g a) ^ p ∂μ) ^ (1 / q) := by\n      rw [add_mul]\n      gcongr\n      · exact lintegral_mul_rpow_le_lintegral_rpow_mul_lintegral_rpow hpq hf (hf.add hg) hf_top\n      · exact lintegral_mul_rpow_le_lintegral_rpow_mul_lintegral_rpow hpq hg (hf.add hg) hg_top\n\n"}
{"name":"ENNReal.lintegral_Lp_add_le","module":"Mathlib.MeasureTheory.Integral.MeanInequalities","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\np : Real\nf g : α → ENNReal\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\nhp1 : LE.le 1 p\n⊢ LE.le (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (HAdd.hAdd f g a) p) (HDiv.hDiv 1 p)) (HAdd.hAdd (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (f a) p) (HDiv.hDiv 1 p)) (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (g a) p) (HDiv.hDiv 1 p)))","decl":"/-- **Minkowski's inequality for functions** `α → ℝ≥0∞`: the `ℒp` seminorm of the sum of two\nfunctions is bounded by the sum of their `ℒp` seminorms. -/\ntheorem lintegral_Lp_add_le {p : ℝ} {f g : α → ℝ≥0∞} (hf : AEMeasurable f μ) (hg : AEMeasurable g μ)\n    (hp1 : 1 ≤ p) :\n    (∫⁻ a, (f + g) a ^ p ∂μ) ^ (1 / p) ≤\n      (∫⁻ a, f a ^ p ∂μ) ^ (1 / p) + (∫⁻ a, g a ^ p ∂μ) ^ (1 / p) := by\n  have hp_pos : 0 < p := lt_of_lt_of_le zero_lt_one hp1\n  by_cases hf_top : ∫⁻ a, f a ^ p ∂μ = ⊤\n  · simp [hf_top, hp_pos]\n  by_cases hg_top : ∫⁻ a, g a ^ p ∂μ = ⊤\n  · simp [hg_top, hp_pos]\n  by_cases h1 : p = 1\n  · refine le_of_eq ?_\n    simp_rw [h1, one_div_one, ENNReal.rpow_one]\n    exact lintegral_add_left' hf _\n  have hp1_lt : 1 < p := by\n    refine lt_of_le_of_ne hp1 ?_\n    symm\n    exact h1\n  have hpq := Real.IsConjExponent.conjExponent hp1_lt\n  by_cases h0 : (∫⁻ a, (f + g) a ^ p ∂μ) = 0\n  · rw [h0, @ENNReal.zero_rpow_of_pos (1 / p) (by simp [lt_of_lt_of_le zero_lt_one hp1])]\n    exact zero_le _\n  have htop : (∫⁻ a, (f + g) a ^ p ∂μ) ≠ ⊤ := by\n    rw [← Ne] at hf_top hg_top\n    rw [← lt_top_iff_ne_top] at hf_top hg_top ⊢\n    exact lintegral_rpow_add_lt_top_of_lintegral_rpow_lt_top hf hf_top hg_top hp1\n  exact lintegral_Lp_add_le_aux hpq hf hf_top hg hg_top h0 htop\n\n"}
{"name":"ENNReal.lintegral_Lp_add_le_of_le_one","module":"Mathlib.MeasureTheory.Integral.MeanInequalities","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\np : Real\nf g : α → ENNReal\nhf : AEMeasurable f μ\nhp0 : LE.le 0 p\nhp1 : LE.le p 1\n⊢ LE.le (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (HAdd.hAdd f g a) p) (HDiv.hDiv 1 p)) (HMul.hMul (HPow.hPow 2 (HSub.hSub (HDiv.hDiv 1 p) 1)) (HAdd.hAdd (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (f a) p) (HDiv.hDiv 1 p)) (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (g a) p) (HDiv.hDiv 1 p))))","decl":"/-- Variant of Minkowski's inequality for functions `α → ℝ≥0∞` in `ℒp` with `p ≤ 1`: the `ℒp`\nseminorm of the sum of two functions is bounded by a constant multiple of the sum\nof their `ℒp` seminorms. -/\ntheorem lintegral_Lp_add_le_of_le_one {p : ℝ} {f g : α → ℝ≥0∞} (hf : AEMeasurable f μ) (hp0 : 0 ≤ p)\n    (hp1 : p ≤ 1) :\n    (∫⁻ a, (f + g) a ^ p ∂μ) ^ (1 / p) ≤\n      (2 : ℝ≥0∞) ^ (1 / p - 1) * ((∫⁻ a, f a ^ p ∂μ) ^ (1 / p) + (∫⁻ a, g a ^ p ∂μ) ^ (1 / p)) := by\n  rcases eq_or_lt_of_le hp0 with (rfl | hp)\n  · simp only [Pi.add_apply, rpow_zero, lintegral_one, _root_.div_zero, zero_sub]\n    norm_num\n    rw [rpow_neg, rpow_one, ENNReal.inv_mul_cancel two_ne_zero ofNat_ne_top]\n  calc\n    (∫⁻ a, (f + g) a ^ p ∂μ) ^ (1 / p) ≤ ((∫⁻ a, f a ^ p ∂μ) + ∫⁻ a, g a ^ p ∂μ) ^ (1 / p) := by\n      rw [← lintegral_add_left' (hf.pow_const p)]\n      gcongr with a\n      exact rpow_add_le_add_rpow _ _ hp0 hp1\n    _ ≤ (2 : ℝ≥0∞) ^ (1 / p - 1) * ((∫⁻ a, f a ^ p ∂μ) ^ (1 / p) + (∫⁻ a, g a ^ p ∂μ) ^ (1 / p)) :=\n      rpow_add_le_mul_rpow_add_rpow _ _ ((one_le_div hp).2 hp1)\n\n"}
{"name":"NNReal.lintegral_mul_le_Lp_mul_Lq","module":"Mathlib.MeasureTheory.Integral.MeanInequalities","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\np q : Real\nhpq : p.IsConjExponent q\nf g : α → NNReal\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ LE.le (MeasureTheory.lintegral μ fun a => ↑(HMul.hMul f g a)) (HMul.hMul (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (↑(f a)) p) (HDiv.hDiv 1 p)) (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (↑(g a)) q) (HDiv.hDiv 1 q)))","decl":"/-- Hölder's inequality for functions `α → ℝ≥0`. The integral of the product of two functions\nis bounded by the product of their `ℒp` and `ℒq` seminorms when `p` and `q` are conjugate\nexponents. -/\ntheorem NNReal.lintegral_mul_le_Lp_mul_Lq {p q : ℝ} (hpq : p.IsConjExponent q) {f g : α → ℝ≥0}\n    (hf : AEMeasurable f μ) (hg : AEMeasurable g μ) :\n    (∫⁻ a, (f * g) a ∂μ) ≤\n      (∫⁻ a, (f a : ℝ≥0∞) ^ p ∂μ) ^ (1 / p) * (∫⁻ a, (g a : ℝ≥0∞) ^ q ∂μ) ^ (1 / q) := by\n  simp_rw [Pi.mul_apply, ENNReal.coe_mul]\n  exact ENNReal.lintegral_mul_le_Lp_mul_Lq μ hpq hf.coe_nnreal_ennreal hg.coe_nnreal_ennreal\n\n"}
