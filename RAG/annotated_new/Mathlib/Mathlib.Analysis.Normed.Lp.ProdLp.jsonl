{"name":"WithLp.zero_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommGroup α\ninst✝ : AddCommGroup β\n⊢ Eq 0.1 0","decl":"@[simp]\ntheorem zero_fst : (0 : WithLp p (α × β)).fst = 0 :=\n  rfl\n\n"}
{"name":"WithLp.zero_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommGroup α\ninst✝ : AddCommGroup β\n⊢ Eq 0.2 0","decl":"@[simp]\ntheorem zero_snd : (0 : WithLp p (α × β)).snd = 0 :=\n  rfl\n\n"}
{"name":"WithLp.add_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommGroup α\ninst✝ : AddCommGroup β\nx y : WithLp p (Prod α β)\n⊢ Eq (HAdd.hAdd x y).1 (HAdd.hAdd x.1 y.1)","decl":"@[simp]\ntheorem add_fst : (x + y).fst = x.fst + y.fst :=\n  rfl\n\n"}
{"name":"WithLp.add_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommGroup α\ninst✝ : AddCommGroup β\nx y : WithLp p (Prod α β)\n⊢ Eq (HAdd.hAdd x y).2 (HAdd.hAdd x.2 y.2)","decl":"@[simp]\ntheorem add_snd : (x + y).snd = x.snd + y.snd :=\n  rfl\n\n"}
{"name":"WithLp.sub_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommGroup α\ninst✝ : AddCommGroup β\nx y : WithLp p (Prod α β)\n⊢ Eq (HSub.hSub x y).1 (HSub.hSub x.1 y.1)","decl":"@[simp]\ntheorem sub_fst : (x - y).fst = x.fst - y.fst :=\n  rfl\n\n"}
{"name":"WithLp.sub_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommGroup α\ninst✝ : AddCommGroup β\nx y : WithLp p (Prod α β)\n⊢ Eq (HSub.hSub x y).2 (HSub.hSub x.2 y.2)","decl":"@[simp]\ntheorem sub_snd : (x - y).snd = x.snd - y.snd :=\n  rfl\n\n"}
{"name":"WithLp.neg_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommGroup α\ninst✝ : AddCommGroup β\nx : WithLp p (Prod α β)\n⊢ Eq (Neg.neg x).1 (Neg.neg x.1)","decl":"@[simp]\ntheorem neg_fst : (-x).fst = -x.fst :=\n  rfl\n\n"}
{"name":"WithLp.neg_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommGroup α\ninst✝ : AddCommGroup β\nx : WithLp p (Prod α β)\n⊢ Eq (Neg.neg x).2 (Neg.neg x.2)","decl":"@[simp]\ntheorem neg_snd : (-x).snd = -x.snd :=\n  rfl\n\n"}
{"name":"WithLp.smul_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\n𝕜 : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : Semiring 𝕜\ninst✝³ : AddCommGroup α\ninst✝² : AddCommGroup β\nx : WithLp p (Prod α β)\nc : 𝕜\ninst✝¹ : Module 𝕜 α\ninst✝ : Module 𝕜 β\n⊢ Eq (HSMul.hSMul c x).1 (HSMul.hSMul c x.1)","decl":"@[simp]\ntheorem smul_fst : (c • x).fst = c • x.fst :=\n  rfl\n\n"}
{"name":"WithLp.smul_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\n𝕜 : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : Semiring 𝕜\ninst✝³ : AddCommGroup α\ninst✝² : AddCommGroup β\nx : WithLp p (Prod α β)\nc : 𝕜\ninst✝¹ : Module 𝕜 α\ninst✝ : Module 𝕜 β\n⊢ Eq (HSMul.hSMul c x).2 (HSMul.hSMul c x.2)","decl":"@[simp]\ntheorem smul_snd : (c • x).snd = c • x.snd :=\n  rfl\n\n"}
{"name":"WithLp.equiv_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nx : WithLp p (Prod α β)\n⊢ Eq ((WithLp.equiv p (Prod α β)) x).1 x.1","decl":"@[simp]\ntheorem equiv_fst (x : WithLp p (α × β)) : (WithLp.equiv p (α × β) x).fst = x.fst :=\n  rfl\n\n"}
{"name":"WithLp.equiv_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nx : WithLp p (Prod α β)\n⊢ Eq ((WithLp.equiv p (Prod α β)) x).2 x.2","decl":"@[simp]\ntheorem equiv_snd (x : WithLp p (α × β)) : (WithLp.equiv p (α × β) x).snd = x.snd :=\n  rfl\n\n"}
{"name":"WithLp.equiv_symm_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nx : Prod α β\n⊢ Eq ((WithLp.equiv p (Prod α β)).symm x).1 x.1","decl":"@[simp]\ntheorem equiv_symm_fst (x : α × β) : ((WithLp.equiv p (α × β)).symm x).fst = x.fst :=\n  rfl\n\n"}
{"name":"WithLp.equiv_symm_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nx : Prod α β\n⊢ Eq ((WithLp.equiv p (Prod α β)).symm x).2 x.2","decl":"@[simp]\ntheorem equiv_symm_snd (x : α × β) : ((WithLp.equiv p (α × β)).symm x).snd = x.snd :=\n  rfl\n\n"}
{"name":"WithLp.prod_edist_eq_card","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : EDist α\ninst✝ : EDist β\nf g : WithLp 0 (Prod α β)\n⊢ Eq (EDist.edist f g) (HAdd.hAdd (ite (Eq (EDist.edist f.1 g.1) 0) 0 1) (ite (Eq (EDist.edist f.2 g.2) 0) 0 1))","decl":"@[simp]\ntheorem prod_edist_eq_card (f g : WithLp 0 (α × β)) :\n    edist f g =\n      (if edist f.fst g.fst = 0 then 0 else 1) + (if edist f.snd g.snd = 0 then 0 else 1) := by\n  convert if_pos rfl\n\n"}
{"name":"WithLp.prod_edist_eq_add","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\ninst✝¹ : EDist α\ninst✝ : EDist β\nhp : LT.lt 0 p.toReal\nf g : WithLp p (Prod α β)\n⊢ Eq (EDist.edist f g) (HPow.hPow (HAdd.hAdd (HPow.hPow (EDist.edist f.1 g.1) p.toReal) (HPow.hPow (EDist.edist f.2 g.2) p.toReal)) (HDiv.hDiv 1 p.toReal))","decl":"theorem prod_edist_eq_add (hp : 0 < p.toReal) (f g : WithLp p (α × β)) :\n    edist f g = (edist f.fst g.fst ^ p.toReal + edist f.snd g.snd ^ p.toReal) ^ (1 / p.toReal) :=\n  let hp' := ENNReal.toReal_pos_iff.mp hp\n  (if_neg hp'.1.ne').trans (if_neg hp'.2.ne)\n\n"}
{"name":"WithLp.prod_edist_eq_sup","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : EDist α\ninst✝ : EDist β\nf g : WithLp Top.top (Prod α β)\n⊢ Eq (EDist.edist f g) (Max.max (EDist.edist f.1 g.1) (EDist.edist f.2 g.2))","decl":"theorem prod_edist_eq_sup (f g : WithLp ∞ (α × β)) :\n    edist f g = edist f.fst g.fst ⊔ edist f.snd g.snd := rfl\n\n"}
{"name":"WithLp.prod_edist_self","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf : WithLp p (Prod α β)\n⊢ Eq (EDist.edist f f) 0","decl":"/-- The distance from one point to itself is always zero.\n\nThis holds independent of `p` and does not require `[Fact (1 ≤ p)]`. We keep it separate\nfrom `WithLp.instProdPseudoEMetricSpace` so it can be used also for `p < 1`. -/\ntheorem prod_edist_self (f : WithLp p (α × β)) : edist f f = 0 := by\n  rcases p.trichotomy with (rfl | rfl | h)\n  · classical\n    simp\n  · simp [prod_edist_eq_sup]\n  · simp [prod_edist_eq_add h, ENNReal.zero_rpow_of_pos h,\n      ENNReal.zero_rpow_of_pos (inv_pos.2 <| h)]\n\n"}
{"name":"WithLp.prod_edist_comm","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\nf g : WithLp p (Prod α β)\n⊢ Eq (EDist.edist f g) (EDist.edist g f)","decl":"/-- The distance is symmetric.\n\nThis holds independent of `p` and does not require `[Fact (1 ≤ p)]`. We keep it separate\nfrom `WithLp.instProdPseudoEMetricSpace` so it can be used also for `p < 1`. -/\ntheorem prod_edist_comm (f g : WithLp p (α × β)) : edist f g = edist g f := by\n  classical\n  rcases p.trichotomy with (rfl | rfl | h)\n  · simp only [prod_edist_eq_card, edist_comm]\n  · simp only [prod_edist_eq_sup, edist_comm]\n  · simp only [prod_edist_eq_add h, edist_comm]\n\n"}
{"name":"WithLp.prod_dist_eq_card","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Dist α\ninst✝ : Dist β\nf g : WithLp 0 (Prod α β)\n⊢ Eq (Dist.dist f g) (HAdd.hAdd (ite (Eq (Dist.dist f.1 g.1) 0) 0 1) (ite (Eq (Dist.dist f.2 g.2) 0) 0 1))","decl":"theorem prod_dist_eq_card (f g : WithLp 0 (α × β)) : dist f g =\n    (if dist f.fst g.fst = 0 then 0 else 1) + (if dist f.snd g.snd = 0 then 0 else 1) := by\n  convert if_pos rfl\n\n"}
{"name":"WithLp.prod_dist_eq_add","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\ninst✝¹ : Dist α\ninst✝ : Dist β\nhp : LT.lt 0 p.toReal\nf g : WithLp p (Prod α β)\n⊢ Eq (Dist.dist f g) (HPow.hPow (HAdd.hAdd (HPow.hPow (Dist.dist f.1 g.1) p.toReal) (HPow.hPow (Dist.dist f.2 g.2) p.toReal)) (HDiv.hDiv 1 p.toReal))","decl":"theorem prod_dist_eq_add (hp : 0 < p.toReal) (f g : WithLp p (α × β)) :\n    dist f g = (dist f.fst g.fst ^ p.toReal + dist f.snd g.snd ^ p.toReal) ^ (1 / p.toReal) :=\n  let hp' := ENNReal.toReal_pos_iff.mp hp\n  (if_neg hp'.1.ne').trans (if_neg hp'.2.ne)\n\n"}
{"name":"WithLp.prod_dist_eq_sup","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Dist α\ninst✝ : Dist β\nf g : WithLp Top.top (Prod α β)\n⊢ Eq (Dist.dist f g) (Max.max (Dist.dist f.1 g.1) (Dist.dist f.2 g.2))","decl":"theorem prod_dist_eq_sup (f g : WithLp ∞ (α × β)) :\n    dist f g = dist f.fst g.fst ⊔ dist f.snd g.snd := rfl\n\n"}
{"name":"WithLp.prod_norm_eq_card","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Norm α\ninst✝ : Norm β\nf : WithLp 0 (Prod α β)\n⊢ Eq (Norm.norm f) (HAdd.hAdd (ite (Eq (Norm.norm f.1) 0) 0 1) (ite (Eq (Norm.norm f.2) 0) 0 1))","decl":"@[simp]\ntheorem prod_norm_eq_card (f : WithLp 0 (α × β)) :\n    ‖f‖ = (if ‖f.fst‖ = 0 then 0 else 1) + (if ‖f.snd‖ = 0 then 0 else 1) := by\n  convert if_pos rfl\n\n"}
{"name":"WithLp.prod_norm_eq_sup","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Norm α\ninst✝ : Norm β\nf : WithLp Top.top (Prod α β)\n⊢ Eq (Norm.norm f) (Max.max (Norm.norm f.1) (Norm.norm f.2))","decl":"theorem prod_norm_eq_sup (f : WithLp ∞ (α × β)) : ‖f‖ = ‖f.fst‖ ⊔ ‖f.snd‖ := rfl\n\n"}
{"name":"WithLp.prod_norm_eq_add","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\ninst✝¹ : Norm α\ninst✝ : Norm β\nhp : LT.lt 0 p.toReal\nf : WithLp p (Prod α β)\n⊢ Eq (Norm.norm f) (HPow.hPow (HAdd.hAdd (HPow.hPow (Norm.norm f.1) p.toReal) (HPow.hPow (Norm.norm f.2) p.toReal)) (HDiv.hDiv 1 p.toReal))","decl":"theorem prod_norm_eq_add (hp : 0 < p.toReal) (f : WithLp p (α × β)) :\n    ‖f‖ = (‖f.fst‖ ^ p.toReal + ‖f.snd‖ ^ p.toReal) ^ (1 / p.toReal) :=\n  let hp' := ENNReal.toReal_pos_iff.mp hp\n  (if_neg hp'.1.ne').trans (if_neg hp'.2.ne)\n\n"}
{"name":"WithLp.prod_sup_edist_ne_top_aux","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nf g : WithLp Top.top (Prod α β)\n⊢ Ne (Max.max (EDist.edist f.1 g.1) (EDist.edist f.2 g.2)) Top.top","decl":"/-- An auxiliary lemma used twice in the proof of `WithLp.prodPseudoMetricAux` below. Not intended\nfor use outside this file. -/\ntheorem prod_sup_edist_ne_top_aux [PseudoMetricSpace α] [PseudoMetricSpace β]\n    (f g : WithLp ∞ (α × β)) :\n    edist f.fst g.fst ⊔ edist f.snd g.snd ≠ ⊤ :=\n  ne_of_lt <| by simp [edist, PseudoMetricSpace.edist_dist]\n\n"}
{"name":"WithLp.prod_lipschitzWith_equiv_aux","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nhp : Fact (LE.le 1 p)\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\n⊢ LipschitzWith 1 ⇑(WithLp.equiv p (Prod α β))","decl":"theorem prod_lipschitzWith_equiv_aux [PseudoEMetricSpace α] [PseudoEMetricSpace β] :\n    LipschitzWith 1 (WithLp.equiv p (α × β)) := by\n  intro x y\n  rcases p.dichotomy with (rfl | h)\n  · simp [edist]\n  · have cancel : p.toReal * (1 / p.toReal) = 1 := mul_div_cancel₀ 1 (zero_lt_one.trans_le h).ne'\n    rw [prod_edist_eq_add (zero_lt_one.trans_le h)]\n    simp only [edist, forall_prop_of_true, one_mul, ENNReal.coe_one, sup_le_iff]\n    constructor\n    · calc\n        edist x.fst y.fst ≤ (edist x.fst y.fst ^ p.toReal) ^ (1 / p.toReal) := by\n          simp only [← ENNReal.rpow_mul, cancel, ENNReal.rpow_one, le_refl]\n        _ ≤ (edist x.fst y.fst ^ p.toReal + edist x.snd y.snd ^ p.toReal) ^ (1 / p.toReal) := by\n          gcongr\n          simp only [self_le_add_right]\n    · calc\n        edist x.snd y.snd ≤ (edist x.snd y.snd ^ p.toReal) ^ (1 / p.toReal) := by\n          simp only [← ENNReal.rpow_mul, cancel, ENNReal.rpow_one, le_refl]\n        _ ≤ (edist x.fst y.fst ^ p.toReal + edist x.snd y.snd ^ p.toReal) ^ (1 / p.toReal) := by\n          gcongr\n          simp only [self_le_add_left]\n\n"}
{"name":"WithLp.prod_antilipschitzWith_equiv_aux","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nhp : Fact (LE.le 1 p)\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\n⊢ AntilipschitzWith (HPow.hPow 2 (HDiv.hDiv 1 p).toReal) ⇑(WithLp.equiv p (Prod α β))","decl":"theorem prod_antilipschitzWith_equiv_aux [PseudoEMetricSpace α] [PseudoEMetricSpace β] :\n    AntilipschitzWith ((2 : ℝ≥0) ^ (1 / p).toReal) (WithLp.equiv p (α × β)) := by\n  intro x y\n  rcases p.dichotomy with (rfl | h)\n  · simp [edist]\n  · have pos : 0 < p.toReal := by positivity\n    have nonneg : 0 ≤ 1 / p.toReal := by positivity\n    have cancel : p.toReal * (1 / p.toReal) = 1 := mul_div_cancel₀ 1 (ne_of_gt pos)\n    rw [prod_edist_eq_add pos, ENNReal.toReal_div 1 p]\n    simp only [edist, ← one_div, ENNReal.one_toReal]\n    calc\n      (edist x.fst y.fst ^ p.toReal + edist x.snd y.snd ^ p.toReal) ^ (1 / p.toReal) ≤\n          (edist (WithLp.equiv p _ x) (WithLp.equiv p _ y) ^ p.toReal +\n          edist (WithLp.equiv p _ x) (WithLp.equiv p _ y) ^ p.toReal) ^ (1 / p.toReal) := by\n        gcongr <;> simp [edist]\n      _ = (2 ^ (1 / p.toReal) : ℝ≥0) * edist (WithLp.equiv p _ x) (WithLp.equiv p _ y) := by\n        simp only [← two_mul, ENNReal.mul_rpow_of_nonneg _ _ nonneg, ← ENNReal.rpow_mul, cancel,\n          ENNReal.rpow_one, ENNReal.coe_rpow_of_nonneg _ nonneg, coe_ofNat]\n\n"}
{"name":"WithLp.prod_aux_uniformity_eq","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nhp : Fact (LE.le 1 p)\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\n⊢ Eq (uniformity (WithLp p (Prod α β))) (uniformity (Prod α β))","decl":"theorem prod_aux_uniformity_eq [PseudoEMetricSpace α] [PseudoEMetricSpace β] :\n    𝓤 (WithLp p (α × β)) = 𝓤[instUniformSpaceProd] := by\n  have A : IsUniformInducing (WithLp.equiv p (α × β)) :=\n    (prod_antilipschitzWith_equiv_aux p α β).isUniformInducing\n      (prod_lipschitzWith_equiv_aux p α β).uniformContinuous\n  have : (fun x : WithLp p (α × β) × WithLp p (α × β) =>\n    ((WithLp.equiv p (α × β)) x.fst, (WithLp.equiv p (α × β)) x.snd)) = id := by\n    ext i <;> rfl\n  rw [← A.comap_uniformity, this, comap_id]\n\n"}
{"name":"WithLp.prod_aux_cobounded_eq","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nhp : Fact (LE.le 1 p)\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\n⊢ Eq (Bornology.cobounded (WithLp p (Prod α β))) (Bornology.cobounded (Prod α β))","decl":"theorem prod_aux_cobounded_eq [PseudoMetricSpace α] [PseudoMetricSpace β] :\n    cobounded (WithLp p (α × β)) = @cobounded _ Prod.instBornology :=\n  calc\n    cobounded (WithLp p (α × β)) = comap (WithLp.equiv p (α × β)) (cobounded _) :=\n      le_antisymm (prod_antilipschitzWith_equiv_aux p α β).tendsto_cobounded.le_comap\n        (prod_lipschitzWith_equiv_aux p α β).comap_cobounded_le\n    _ = _ := comap_id\n\n"}
{"name":"WithLp.prod_continuous_equiv","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\n⊢ Continuous ⇑(WithLp.equiv p (Prod α β))","decl":"@[continuity]\ntheorem prod_continuous_equiv : Continuous (WithLp.equiv p (α × β)) :=\n  continuous_id\n\n"}
{"name":"WithLp.prod_continuous_equiv_symm","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\n⊢ Continuous ⇑(WithLp.equiv p (Prod α β)).symm","decl":"@[continuity]\ntheorem prod_continuous_equiv_symm : Continuous (WithLp.equiv p (α × β)).symm :=\n  continuous_id\n\n"}
{"name":"WithLp.instProdT0Space","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\ninst✝³ : TopologicalSpace α\ninst✝² : TopologicalSpace β\ninst✝¹ : T0Space α\ninst✝ : T0Space β\n⊢ T0Space (WithLp p (Prod α β))","decl":"instance instProdT0Space : T0Space (WithLp p (α × β)) :=\n  Prod.instT0Space\n\n"}
{"name":"WithLp.prod_uniformContinuous_equiv","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\n⊢ UniformContinuous ⇑(WithLp.equiv p (Prod α β))","decl":"theorem prod_uniformContinuous_equiv : UniformContinuous (WithLp.equiv p (α × β)) :=\n  uniformContinuous_id\n\n"}
{"name":"WithLp.prod_uniformContinuous_equiv_symm","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\ninst✝¹ : UniformSpace α\ninst✝ : UniformSpace β\n⊢ UniformContinuous ⇑(WithLp.equiv p (Prod α β)).symm","decl":"theorem prod_uniformContinuous_equiv_symm : UniformContinuous (WithLp.equiv p (α × β)).symm :=\n  uniformContinuous_id\n\n"}
{"name":"WithLp.instProdCompleteSpace","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\ninst✝³ : UniformSpace α\ninst✝² : UniformSpace β\ninst✝¹ : CompleteSpace α\ninst✝ : CompleteSpace β\n⊢ CompleteSpace (WithLp p (Prod α β))","decl":"instance instProdCompleteSpace : CompleteSpace (WithLp p (α × β)) :=\n  CompleteSpace.prod\n\n"}
{"name":"WithLp.prodContinuousLinearEquiv_apply","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\n𝕜 : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : TopologicalSpace β\ninst✝⁴ : Semiring 𝕜\ninst✝³ : AddCommGroup α\ninst✝² : AddCommGroup β\ninst✝¹ : Module 𝕜 α\ninst✝ : Module 𝕜 β\n⊢ Eq ⇑(WithLp.prodContinuousLinearEquiv p 𝕜 α β) ⇑(WithLp.equiv p (Prod α β))","decl":"/-- `WithLp.equiv` as a continuous linear equivalence. -/\n@[simps! (config := .asFn) apply symm_apply]\nprotected def prodContinuousLinearEquiv : WithLp p (α × β) ≃L[𝕜] α × β where\n  toLinearEquiv := WithLp.linearEquiv _ _ _\n  continuous_toFun := prod_continuous_equiv _ _ _\n  continuous_invFun := prod_continuous_equiv_symm _ _ _\n\n"}
{"name":"WithLp.prodContinuousLinearEquiv_symm_apply","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\n𝕜 : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁶ : TopologicalSpace α\ninst✝⁵ : TopologicalSpace β\ninst✝⁴ : Semiring 𝕜\ninst✝³ : AddCommGroup α\ninst✝² : AddCommGroup β\ninst✝¹ : Module 𝕜 α\ninst✝ : Module 𝕜 β\n⊢ Eq ⇑(WithLp.prodContinuousLinearEquiv p 𝕜 α β).symm ⇑(WithLp.equiv p (Prod α β)).symm","decl":"/-- `WithLp.equiv` as a continuous linear equivalence. -/\n@[simps! (config := .asFn) apply symm_apply]\nprotected def prodContinuousLinearEquiv : WithLp p (α × β) ≃L[𝕜] α × β where\n  toLinearEquiv := WithLp.linearEquiv _ _ _\n  continuous_toFun := prod_continuous_equiv _ _ _\n  continuous_invFun := prod_continuous_equiv_symm _ _ _\n\n"}
{"name":"WithLp.prod_nndist_eq_add","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nhp✝ : Fact (LE.le 1 p)\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nhp : Ne p Top.top\nx y : WithLp p (Prod α β)\n⊢ Eq (NNDist.nndist x y) (HPow.hPow (HAdd.hAdd (HPow.hPow (NNDist.nndist x.1 y.1) p.toReal) (HPow.hPow (NNDist.nndist x.2 y.2) p.toReal)) (HDiv.hDiv 1 p.toReal))","decl":"theorem prod_nndist_eq_add [PseudoMetricSpace α] [PseudoMetricSpace β]\n    (hp : p ≠ ∞) (x y : WithLp p (α × β)) :\n    nndist x y = (nndist x.fst y.fst ^ p.toReal + nndist x.snd y.snd ^ p.toReal) ^ (1 / p.toReal) :=\n  NNReal.eq <| by\n    push_cast\n    exact prod_dist_eq_add (p.toReal_pos_iff_ne_top.mpr hp) _ _\n\n"}
{"name":"WithLp.prod_nndist_eq_sup","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : PseudoMetricSpace α\ninst✝ : PseudoMetricSpace β\nx y : WithLp Top.top (Prod α β)\n⊢ Eq (NNDist.nndist x y) (Max.max (NNDist.nndist x.1 y.1) (NNDist.nndist x.2 y.2))","decl":"theorem prod_nndist_eq_sup [PseudoMetricSpace α] [PseudoMetricSpace β] (x y : WithLp ∞ (α × β)) :\n    nndist x y = nndist x.fst y.fst ⊔ nndist x.snd y.snd :=\n  NNReal.eq <| by\n    push_cast\n    exact prod_dist_eq_sup _ _\n\n"}
{"name":"WithLp.prod_lipschitzWith_equiv","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nhp : Fact (LE.le 1 p)\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\n⊢ LipschitzWith 1 ⇑(WithLp.equiv p (Prod α β))","decl":"theorem prod_lipschitzWith_equiv [PseudoEMetricSpace α] [PseudoEMetricSpace β] :\n    LipschitzWith 1 (WithLp.equiv p (α × β)) :=\n  prod_lipschitzWith_equiv_aux p α β\n\n"}
{"name":"WithLp.prod_antilipschitzWith_equiv","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nhp : Fact (LE.le 1 p)\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\n⊢ AntilipschitzWith (HPow.hPow 2 (HDiv.hDiv 1 p).toReal) ⇑(WithLp.equiv p (Prod α β))","decl":"theorem prod_antilipschitzWith_equiv [PseudoEMetricSpace α] [PseudoEMetricSpace β] :\n    AntilipschitzWith ((2 : ℝ≥0) ^ (1 / p).toReal) (WithLp.equiv p (α × β)) :=\n  prod_antilipschitzWith_equiv_aux p α β\n\n"}
{"name":"WithLp.prod_infty_equiv_isometry","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : PseudoEMetricSpace α\ninst✝ : PseudoEMetricSpace β\n⊢ Isometry ⇑(WithLp.equiv Top.top (Prod α β))","decl":"theorem prod_infty_equiv_isometry [PseudoEMetricSpace α] [PseudoEMetricSpace β] :\n    Isometry (WithLp.equiv ∞ (α × β)) :=\n  fun x y =>\n  le_antisymm (by simpa only [ENNReal.coe_one, one_mul] using prod_lipschitzWith_equiv ∞ α β x y)\n    (by\n      simpa only [ENNReal.div_top, ENNReal.zero_toReal, NNReal.rpow_zero, ENNReal.coe_one,\n        one_mul] using prod_antilipschitzWith_equiv ∞ α β x y)\n\n"}
{"name":"WithLp.prod_norm_eq_of_nat","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nhp : Fact (LE.le 1 p)\ninst✝¹ : Norm α\ninst✝ : Norm β\nn : Nat\nh : Eq p ↑n\nf : WithLp p (Prod α β)\n⊢ Eq (Norm.norm f) (HPow.hPow (HAdd.hAdd (HPow.hPow (Norm.norm f.1) n) (HPow.hPow (Norm.norm f.2) n)) (HDiv.hDiv 1 ↑n))","decl":"theorem prod_norm_eq_of_nat [Norm α] [Norm β] (n : ℕ) (h : p = n) (f : WithLp p (α × β)) :\n    ‖f‖ = (‖f.fst‖ ^ n + ‖f.snd‖ ^ n) ^ (1 / (n : ℝ)) := by\n  have := p.toReal_pos_iff_ne_top.mpr (ne_of_eq_of_ne h <| ENNReal.natCast_ne_top n)\n  simp only [one_div, h, Real.rpow_natCast, ENNReal.toReal_nat, eq_self_iff_true, Finset.sum_congr,\n    prod_norm_eq_add this]\n\n"}
{"name":"WithLp.prod_nnnorm_eq_add","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nhp✝ : Fact (LE.le 1 p)\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nhp : Ne p Top.top\nf : WithLp p (Prod α β)\n⊢ Eq (NNNorm.nnnorm f) (HPow.hPow (HAdd.hAdd (HPow.hPow (NNNorm.nnnorm f.1) p.toReal) (HPow.hPow (NNNorm.nnnorm f.2) p.toReal)) (HDiv.hDiv 1 p.toReal))","decl":"theorem prod_nnnorm_eq_add (hp : p ≠ ∞) (f : WithLp p (α × β)) :\n    ‖f‖₊ = (‖f.fst‖₊ ^ p.toReal + ‖f.snd‖₊ ^ p.toReal) ^ (1 / p.toReal) := by\n  ext\n  simp [prod_norm_eq_add (p.toReal_pos_iff_ne_top.mpr hp)]\n\n"}
{"name":"WithLp.prod_nnnorm_eq_sup","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nf : WithLp Top.top (Prod α β)\n⊢ Eq (NNNorm.nnnorm f) (Max.max (NNNorm.nnnorm f.1) (NNNorm.nnnorm f.2))","decl":"theorem prod_nnnorm_eq_sup (f : WithLp ∞ (α × β)) : ‖f‖₊ = ‖f.fst‖₊ ⊔  ‖f.snd‖₊ := by\n  ext\n  norm_cast\n\n"}
{"name":"WithLp.prod_nnnorm_equiv","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nf : WithLp Top.top (Prod α β)\n⊢ Eq (NNNorm.nnnorm ((WithLp.equiv Top.top (Prod α β)) f)) (NNNorm.nnnorm f)","decl":"@[simp] theorem prod_nnnorm_equiv (f : WithLp ∞ (α × β)) : ‖WithLp.equiv ⊤ _ f‖₊ = ‖f‖₊ := by\n  rw [prod_nnnorm_eq_sup, Prod.nnnorm_def, equiv_fst, equiv_snd]\n\n"}
{"name":"WithLp.prod_nnnorm_equiv_symm","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nf : Prod α β\n⊢ Eq (NNNorm.nnnorm ((WithLp.equiv Top.top (Prod α β)).symm f)) (NNNorm.nnnorm f)","decl":"@[simp] theorem prod_nnnorm_equiv_symm (f : α × β) : ‖(WithLp.equiv ⊤ _).symm f‖₊ = ‖f‖₊ :=\n  (prod_nnnorm_equiv _).symm\n\n"}
{"name":"WithLp.prod_norm_equiv","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nf : WithLp Top.top (Prod α β)\n⊢ Eq (Norm.norm ((WithLp.equiv Top.top (Prod α β)) f)) (Norm.norm f)","decl":"@[simp] theorem prod_norm_equiv (f : WithLp ∞ (α × β)) : ‖WithLp.equiv ⊤ _ f‖ = ‖f‖ :=\n  congr_arg NNReal.toReal <| prod_nnnorm_equiv f\n\n"}
{"name":"WithLp.prod_norm_equiv_symm","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nf : Prod α β\n⊢ Eq (Norm.norm ((WithLp.equiv Top.top (Prod α β)).symm f)) (Norm.norm f)","decl":"@[simp] theorem prod_norm_equiv_symm (f : α × β) : ‖(WithLp.equiv ⊤ _).symm f‖ = ‖f‖ :=\n  (prod_norm_equiv _).symm\n\n"}
{"name":"WithLp.prod_norm_eq_of_L1","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nx : WithLp 1 (Prod α β)\n⊢ Eq (Norm.norm x) (HAdd.hAdd (Norm.norm x.1) (Norm.norm x.2))","decl":"theorem prod_norm_eq_of_L1 (x : WithLp 1 (α × β)) :\n    ‖x‖ = ‖x.fst‖ + ‖x.snd‖ := by\n  simp [prod_norm_eq_add]\n\n"}
{"name":"WithLp.prod_nnnorm_eq_of_L1","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nx : WithLp 1 (Prod α β)\n⊢ Eq (NNNorm.nnnorm x) (HAdd.hAdd (NNNorm.nnnorm x.1) (NNNorm.nnnorm x.2))","decl":"theorem prod_nnnorm_eq_of_L1 (x : WithLp 1 (α × β)) :\n    ‖x‖₊ = ‖x.fst‖₊ + ‖x.snd‖₊ :=\n  NNReal.eq <| by\n    push_cast\n    exact prod_norm_eq_of_L1 x\n\n"}
{"name":"WithLp.prod_dist_eq_of_L1","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nx y : WithLp 1 (Prod α β)\n⊢ Eq (Dist.dist x y) (HAdd.hAdd (Dist.dist x.1 y.1) (Dist.dist x.2 y.2))","decl":"theorem prod_dist_eq_of_L1 (x y : WithLp 1 (α × β)) :\n    dist x y = dist x.fst y.fst + dist x.snd y.snd := by\n  simp_rw [dist_eq_norm, prod_norm_eq_of_L1, sub_fst, sub_snd]\n\n"}
{"name":"WithLp.prod_nndist_eq_of_L1","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nx y : WithLp 1 (Prod α β)\n⊢ Eq (NNDist.nndist x y) (HAdd.hAdd (NNDist.nndist x.1 y.1) (NNDist.nndist x.2 y.2))","decl":"theorem prod_nndist_eq_of_L1 (x y : WithLp 1 (α × β)) :\n    nndist x y = nndist x.fst y.fst + nndist x.snd y.snd :=\n  NNReal.eq <| by\n    push_cast\n    exact prod_dist_eq_of_L1 _ _\n\n"}
{"name":"WithLp.prod_edist_eq_of_L1","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nx y : WithLp 1 (Prod α β)\n⊢ Eq (EDist.edist x y) (HAdd.hAdd (EDist.edist x.1 y.1) (EDist.edist x.2 y.2))","decl":"theorem prod_edist_eq_of_L1 (x y : WithLp 1 (α × β)) :\n    edist x y = edist x.fst y.fst + edist x.snd y.snd := by\n  simp [prod_edist_eq_add]\n\n"}
{"name":"WithLp.prod_norm_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nx : WithLp 2 (Prod α β)\n⊢ Eq (Norm.norm x) (HAdd.hAdd (HPow.hPow (Norm.norm x.1) 2) (HPow.hPow (Norm.norm x.2) 2)).sqrt","decl":"theorem prod_norm_eq_of_L2 (x : WithLp 2 (α × β)) :\n    ‖x‖ = √(‖x.fst‖ ^ 2 + ‖x.snd‖ ^ 2) := by\n  rw [prod_norm_eq_of_nat 2 (by norm_cast) _, Real.sqrt_eq_rpow]\n  norm_cast\n\n"}
{"name":"WithLp.prod_nnnorm_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nx : WithLp 2 (Prod α β)\n⊢ Eq (NNNorm.nnnorm x) (NNReal.sqrt (HAdd.hAdd (HPow.hPow (NNNorm.nnnorm x.1) 2) (HPow.hPow (NNNorm.nnnorm x.2) 2)))","decl":"theorem prod_nnnorm_eq_of_L2 (x : WithLp 2 (α × β)) :\n    ‖x‖₊ = NNReal.sqrt (‖x.fst‖₊ ^ 2 + ‖x.snd‖₊ ^ 2) :=\n  NNReal.eq <| by\n    push_cast\n    exact prod_norm_eq_of_L2 x\n\n"}
{"name":"WithLp.prod_norm_sq_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nx : WithLp 2 (Prod α β)\n⊢ Eq (HPow.hPow (Norm.norm x) 2) (HAdd.hAdd (HPow.hPow (Norm.norm x.1) 2) (HPow.hPow (Norm.norm x.2) 2))","decl":"theorem prod_norm_sq_eq_of_L2 (x : WithLp 2 (α × β)) : ‖x‖ ^ 2 = ‖x.fst‖ ^ 2 + ‖x.snd‖ ^ 2 := by\n  suffices ‖x‖₊ ^ 2 = ‖x.fst‖₊ ^ 2 + ‖x.snd‖₊ ^ 2 by\n    simpa only [NNReal.coe_sum] using congr_arg ((↑) : ℝ≥0 → ℝ) this\n  rw [prod_nnnorm_eq_of_L2, NNReal.sq_sqrt]\n\n"}
{"name":"WithLp.prod_dist_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nx y : WithLp 2 (Prod α β)\n⊢ Eq (Dist.dist x y) (HAdd.hAdd (HPow.hPow (Dist.dist x.1 y.1) 2) (HPow.hPow (Dist.dist x.2 y.2) 2)).sqrt","decl":"theorem prod_dist_eq_of_L2 (x y : WithLp 2 (α × β)) :\n    dist x y = √(dist x.fst y.fst ^ 2 + dist x.snd y.snd ^ 2) := by\n  simp_rw [dist_eq_norm, prod_norm_eq_of_L2, sub_fst, sub_snd]\n\n"}
{"name":"WithLp.prod_nndist_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nx y : WithLp 2 (Prod α β)\n⊢ Eq (NNDist.nndist x y) (NNReal.sqrt (HAdd.hAdd (HPow.hPow (NNDist.nndist x.1 y.1) 2) (HPow.hPow (NNDist.nndist x.2 y.2) 2)))","decl":"theorem prod_nndist_eq_of_L2 (x y : WithLp 2 (α × β)) :\n    nndist x y = NNReal.sqrt (nndist x.fst y.fst ^ 2 + nndist x.snd y.snd ^ 2) :=\n  NNReal.eq <| by\n    push_cast\n    exact prod_dist_eq_of_L2 _ _\n\n"}
{"name":"WithLp.prod_edist_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nx y : WithLp 2 (Prod α β)\n⊢ Eq (EDist.edist x y) (HPow.hPow (HAdd.hAdd (HPow.hPow (EDist.edist x.1 y.1) 2) (HPow.hPow (EDist.edist x.2 y.2) 2)) (1 / 2))","decl":"theorem prod_edist_eq_of_L2 (x y : WithLp 2 (α × β)) :\n    edist x y = (edist x.fst y.fst ^ 2 + edist x.snd y.snd ^ 2) ^ (1 / 2 : ℝ) := by\n  simp [prod_edist_eq_add]\n\n"}
{"name":"WithLp.nnnorm_equiv_symm_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nhp : Fact (LE.le 1 p)\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nx : α\n⊢ Eq (NNNorm.nnnorm ((WithLp.equiv p (Prod α β)).symm { fst := x, snd := 0 })) (NNNorm.nnnorm x)","decl":"@[simp]\ntheorem nnnorm_equiv_symm_fst (x : α) :\n    ‖(WithLp.equiv p (α × β)).symm (x, 0)‖₊ = ‖x‖₊ := by\n  induction p generalizing hp with\n  | top =>\n    simp [prod_nnnorm_eq_sup]\n  | coe p =>\n    have hp0 : (p : ℝ) ≠ 0 := mod_cast (zero_lt_one.trans_le <| Fact.out (p := 1 ≤ (p : ℝ≥0∞))).ne'\n    simp [prod_nnnorm_eq_add, NNReal.zero_rpow hp0, ← NNReal.rpow_mul, mul_inv_cancel₀ hp0]\n\n"}
{"name":"WithLp.nnnorm_equiv_symm_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nhp : Fact (LE.le 1 p)\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\ny : β\n⊢ Eq (NNNorm.nnnorm ((WithLp.equiv p (Prod α β)).symm { fst := 0, snd := y })) (NNNorm.nnnorm y)","decl":"@[simp]\ntheorem nnnorm_equiv_symm_snd (y : β) :\n    ‖(WithLp.equiv p (α × β)).symm (0, y)‖₊ = ‖y‖₊ := by\n  induction p generalizing hp with\n  | top =>\n    simp [prod_nnnorm_eq_sup]\n  | coe p =>\n    have hp0 : (p : ℝ) ≠ 0 := mod_cast (zero_lt_one.trans_le <| Fact.out (p := 1 ≤ (p : ℝ≥0∞))).ne'\n    simp [prod_nnnorm_eq_add, NNReal.zero_rpow hp0, ← NNReal.rpow_mul, mul_inv_cancel₀ hp0]\n\n"}
{"name":"WithLp.norm_equiv_symm_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nhp : Fact (LE.le 1 p)\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nx : α\n⊢ Eq (Norm.norm ((WithLp.equiv p (Prod α β)).symm { fst := x, snd := 0 })) (Norm.norm x)","decl":"@[simp]\ntheorem norm_equiv_symm_fst (x : α) : ‖(WithLp.equiv p (α × β)).symm (x, 0)‖ = ‖x‖ :=\n  congr_arg ((↑) : ℝ≥0 → ℝ) <| nnnorm_equiv_symm_fst p α β x\n\n"}
{"name":"WithLp.norm_equiv_symm_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nhp : Fact (LE.le 1 p)\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\ny : β\n⊢ Eq (Norm.norm ((WithLp.equiv p (Prod α β)).symm { fst := 0, snd := y })) (Norm.norm y)","decl":"@[simp]\ntheorem norm_equiv_symm_snd (y : β) : ‖(WithLp.equiv p (α × β)).symm (0, y)‖ = ‖y‖ :=\n  congr_arg ((↑) : ℝ≥0 → ℝ) <| nnnorm_equiv_symm_snd p α β y\n\n"}
{"name":"WithLp.nndist_equiv_symm_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nhp : Fact (LE.le 1 p)\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nx₁ x₂ : α\n⊢ Eq (NNDist.nndist ((WithLp.equiv p (Prod α β)).symm { fst := x₁, snd := 0 }) ((WithLp.equiv p (Prod α β)).symm { fst := x₂, snd := 0 })) (NNDist.nndist x₁ x₂)","decl":"@[simp]\ntheorem nndist_equiv_symm_fst (x₁ x₂ : α) :\n    nndist ((WithLp.equiv p (α × β)).symm (x₁, 0)) ((WithLp.equiv p (α × β)).symm (x₂, 0)) =\n      nndist x₁ x₂ := by\n  rw [nndist_eq_nnnorm, nndist_eq_nnnorm, ← WithLp.equiv_symm_sub, Prod.mk_sub_mk, sub_zero,\n    nnnorm_equiv_symm_fst]\n\n"}
{"name":"WithLp.nndist_equiv_symm_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nhp : Fact (LE.le 1 p)\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\ny₁ y₂ : β\n⊢ Eq (NNDist.nndist ((WithLp.equiv p (Prod α β)).symm { fst := 0, snd := y₁ }) ((WithLp.equiv p (Prod α β)).symm { fst := 0, snd := y₂ })) (NNDist.nndist y₁ y₂)","decl":"@[simp]\ntheorem nndist_equiv_symm_snd (y₁ y₂ : β) :\n    nndist ((WithLp.equiv p (α × β)).symm (0, y₁)) ((WithLp.equiv p (α × β)).symm (0, y₂)) =\n      nndist y₁ y₂ := by\n  rw [nndist_eq_nnnorm, nndist_eq_nnnorm, ← WithLp.equiv_symm_sub, Prod.mk_sub_mk, sub_zero,\n    nnnorm_equiv_symm_snd]\n\n"}
{"name":"WithLp.dist_equiv_symm_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nhp : Fact (LE.le 1 p)\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nx₁ x₂ : α\n⊢ Eq (Dist.dist ((WithLp.equiv p (Prod α β)).symm { fst := x₁, snd := 0 }) ((WithLp.equiv p (Prod α β)).symm { fst := x₂, snd := 0 })) (Dist.dist x₁ x₂)","decl":"@[simp]\ntheorem dist_equiv_symm_fst (x₁ x₂ : α) :\n    dist ((WithLp.equiv p (α × β)).symm (x₁, 0)) ((WithLp.equiv p (α × β)).symm (x₂, 0)) =\n      dist x₁ x₂ :=\n  congr_arg ((↑) : ℝ≥0 → ℝ) <| nndist_equiv_symm_fst p α β x₁ x₂\n\n"}
{"name":"WithLp.dist_equiv_symm_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nhp : Fact (LE.le 1 p)\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\ny₁ y₂ : β\n⊢ Eq (Dist.dist ((WithLp.equiv p (Prod α β)).symm { fst := 0, snd := y₁ }) ((WithLp.equiv p (Prod α β)).symm { fst := 0, snd := y₂ })) (Dist.dist y₁ y₂)","decl":"@[simp]\ntheorem dist_equiv_symm_snd (y₁ y₂ : β) :\n    dist ((WithLp.equiv p (α × β)).symm (0, y₁)) ((WithLp.equiv p (α × β)).symm (0, y₂)) =\n      dist y₁ y₂ :=\n  congr_arg ((↑) : ℝ≥0 → ℝ) <| nndist_equiv_symm_snd p α β y₁ y₂\n\n"}
{"name":"WithLp.edist_equiv_symm_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nhp : Fact (LE.le 1 p)\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\nx₁ x₂ : α\n⊢ Eq (EDist.edist ((WithLp.equiv p (Prod α β)).symm { fst := x₁, snd := 0 }) ((WithLp.equiv p (Prod α β)).symm { fst := x₂, snd := 0 })) (EDist.edist x₁ x₂)","decl":"@[simp]\ntheorem edist_equiv_symm_fst (x₁ x₂ : α) :\n    edist ((WithLp.equiv p (α × β)).symm (x₁, 0)) ((WithLp.equiv p (α × β)).symm (x₂, 0)) =\n      edist x₁ x₂ := by\n  simp only [edist_nndist, nndist_equiv_symm_fst p α β x₁ x₂]\n\n"}
{"name":"WithLp.edist_equiv_symm_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nα : Type u_2\nβ : Type u_3\nhp : Fact (LE.le 1 p)\ninst✝¹ : SeminormedAddCommGroup α\ninst✝ : SeminormedAddCommGroup β\ny₁ y₂ : β\n⊢ Eq (EDist.edist ((WithLp.equiv p (Prod α β)).symm { fst := 0, snd := y₁ }) ((WithLp.equiv p (Prod α β)).symm { fst := 0, snd := y₂ })) (EDist.edist y₁ y₂)","decl":"@[simp]\ntheorem edist_equiv_symm_snd (y₁ y₂ : β) :\n    edist ((WithLp.equiv p (α × β)).symm (0, y₁)) ((WithLp.equiv p (α × β)).symm (0, y₂)) =\n      edist y₁ y₂ := by\n  simp only [edist_nndist, nndist_equiv_symm_snd p α β y₁ y₂]\n\n"}
{"name":"WithLp.instProdBoundedSMul","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\n𝕜 : Type u_1\nα : Type u_2\nβ : Type u_3\nhp : Fact (LE.le 1 p)\ninst✝⁴ : SeminormedAddCommGroup α\ninst✝³ : SeminormedAddCommGroup β\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : Module 𝕜 α\ninst✝ : Module 𝕜 β\n⊢ BoundedSMul 𝕜 (WithLp p (Prod α β))","decl":"instance instProdBoundedSMul : BoundedSMul 𝕜 (WithLp p (α × β)) :=\n  .of_nnnorm_smul_le fun c f => by\n    rcases p.dichotomy with (rfl | hp)\n    · simp only [← prod_nnnorm_equiv, WithLp.equiv_smul]\n      exact norm_smul_le _ _\n    · have hp0 : 0 < p.toReal := zero_lt_one.trans_le hp\n      have hpt : p ≠ ⊤ := p.toReal_pos_iff_ne_top.mp hp0\n      rw [prod_nnnorm_eq_add hpt, prod_nnnorm_eq_add hpt, one_div, NNReal.rpow_inv_le_iff hp0,\n        NNReal.mul_rpow, ← NNReal.rpow_mul, inv_mul_cancel₀ hp0.ne', NNReal.rpow_one, mul_add,\n        ← NNReal.mul_rpow, ← NNReal.mul_rpow]\n      exact add_le_add\n        (NNReal.rpow_le_rpow (nnnorm_smul_le _ _) hp0.le)\n        (NNReal.rpow_le_rpow (nnnorm_smul_le _ _) hp0.le)\n\n"}
