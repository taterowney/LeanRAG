{"name":"WithLp.zero_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : AddCommGroup Î±\ninstâœ : AddCommGroup Î²\nâŠ¢ Eq 0.1 0","decl":"@[simp]\ntheorem zero_fst : (0 : WithLp p (Î± Ã— Î²)).fst = 0 :=\n  rfl\n\n"}
{"name":"WithLp.zero_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : AddCommGroup Î±\ninstâœ : AddCommGroup Î²\nâŠ¢ Eq 0.2 0","decl":"@[simp]\ntheorem zero_snd : (0 : WithLp p (Î± Ã— Î²)).snd = 0 :=\n  rfl\n\n"}
{"name":"WithLp.add_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : AddCommGroup Î±\ninstâœ : AddCommGroup Î²\nx y : WithLp p (Prod Î± Î²)\nâŠ¢ Eq (HAdd.hAdd x y).1 (HAdd.hAdd x.1 y.1)","decl":"@[simp]\ntheorem add_fst : (x + y).fst = x.fst + y.fst :=\n  rfl\n\n"}
{"name":"WithLp.add_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : AddCommGroup Î±\ninstâœ : AddCommGroup Î²\nx y : WithLp p (Prod Î± Î²)\nâŠ¢ Eq (HAdd.hAdd x y).2 (HAdd.hAdd x.2 y.2)","decl":"@[simp]\ntheorem add_snd : (x + y).snd = x.snd + y.snd :=\n  rfl\n\n"}
{"name":"WithLp.sub_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : AddCommGroup Î±\ninstâœ : AddCommGroup Î²\nx y : WithLp p (Prod Î± Î²)\nâŠ¢ Eq (HSub.hSub x y).1 (HSub.hSub x.1 y.1)","decl":"@[simp]\ntheorem sub_fst : (x - y).fst = x.fst - y.fst :=\n  rfl\n\n"}
{"name":"WithLp.sub_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : AddCommGroup Î±\ninstâœ : AddCommGroup Î²\nx y : WithLp p (Prod Î± Î²)\nâŠ¢ Eq (HSub.hSub x y).2 (HSub.hSub x.2 y.2)","decl":"@[simp]\ntheorem sub_snd : (x - y).snd = x.snd - y.snd :=\n  rfl\n\n"}
{"name":"WithLp.neg_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : AddCommGroup Î±\ninstâœ : AddCommGroup Î²\nx : WithLp p (Prod Î± Î²)\nâŠ¢ Eq (Neg.neg x).1 (Neg.neg x.1)","decl":"@[simp]\ntheorem neg_fst : (-x).fst = -x.fst :=\n  rfl\n\n"}
{"name":"WithLp.neg_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : AddCommGroup Î±\ninstâœ : AddCommGroup Î²\nx : WithLp p (Prod Î± Î²)\nâŠ¢ Eq (Neg.neg x).2 (Neg.neg x.2)","decl":"@[simp]\ntheorem neg_snd : (-x).snd = -x.snd :=\n  rfl\n\n"}
{"name":"WithLp.smul_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœâ´ : Semiring ğ•œ\ninstâœÂ³ : AddCommGroup Î±\ninstâœÂ² : AddCommGroup Î²\nx : WithLp p (Prod Î± Î²)\nc : ğ•œ\ninstâœÂ¹ : Module ğ•œ Î±\ninstâœ : Module ğ•œ Î²\nâŠ¢ Eq (HSMul.hSMul c x).1 (HSMul.hSMul c x.1)","decl":"@[simp]\ntheorem smul_fst : (c â€¢ x).fst = c â€¢ x.fst :=\n  rfl\n\n"}
{"name":"WithLp.smul_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœâ´ : Semiring ğ•œ\ninstâœÂ³ : AddCommGroup Î±\ninstâœÂ² : AddCommGroup Î²\nx : WithLp p (Prod Î± Î²)\nc : ğ•œ\ninstâœÂ¹ : Module ğ•œ Î±\ninstâœ : Module ğ•œ Î²\nâŠ¢ Eq (HSMul.hSMul c x).2 (HSMul.hSMul c x.2)","decl":"@[simp]\ntheorem smul_snd : (c â€¢ x).snd = c â€¢ x.snd :=\n  rfl\n\n"}
{"name":"WithLp.equiv_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nx : WithLp p (Prod Î± Î²)\nâŠ¢ Eq ((WithLp.equiv p (Prod Î± Î²)) x).1 x.1","decl":"@[simp]\ntheorem equiv_fst (x : WithLp p (Î± Ã— Î²)) : (WithLp.equiv p (Î± Ã— Î²) x).fst = x.fst :=\n  rfl\n\n"}
{"name":"WithLp.equiv_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nx : WithLp p (Prod Î± Î²)\nâŠ¢ Eq ((WithLp.equiv p (Prod Î± Î²)) x).2 x.2","decl":"@[simp]\ntheorem equiv_snd (x : WithLp p (Î± Ã— Î²)) : (WithLp.equiv p (Î± Ã— Î²) x).snd = x.snd :=\n  rfl\n\n"}
{"name":"WithLp.equiv_symm_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nx : Prod Î± Î²\nâŠ¢ Eq ((WithLp.equiv p (Prod Î± Î²)).symm x).1 x.1","decl":"@[simp]\ntheorem equiv_symm_fst (x : Î± Ã— Î²) : ((WithLp.equiv p (Î± Ã— Î²)).symm x).fst = x.fst :=\n  rfl\n\n"}
{"name":"WithLp.equiv_symm_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nx : Prod Î± Î²\nâŠ¢ Eq ((WithLp.equiv p (Prod Î± Î²)).symm x).2 x.2","decl":"@[simp]\ntheorem equiv_symm_snd (x : Î± Ã— Î²) : ((WithLp.equiv p (Î± Ã— Î²)).symm x).snd = x.snd :=\n  rfl\n\n"}
{"name":"WithLp.prod_edist_eq_card","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : EDist Î±\ninstâœ : EDist Î²\nf g : WithLp 0 (Prod Î± Î²)\nâŠ¢ Eq (EDist.edist f g) (HAdd.hAdd (ite (Eq (EDist.edist f.1 g.1) 0) 0 1) (ite (Eq (EDist.edist f.2 g.2) 0) 0 1))","decl":"@[simp]\ntheorem prod_edist_eq_card (f g : WithLp 0 (Î± Ã— Î²)) :\n    edist f g =\n      (if edist f.fst g.fst = 0 then 0 else 1) + (if edist f.snd g.snd = 0 then 0 else 1) := by\n  convert if_pos rfl\n\n"}
{"name":"WithLp.prod_edist_eq_add","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : EDist Î±\ninstâœ : EDist Î²\nhp : LT.lt 0 p.toReal\nf g : WithLp p (Prod Î± Î²)\nâŠ¢ Eq (EDist.edist f g) (HPow.hPow (HAdd.hAdd (HPow.hPow (EDist.edist f.1 g.1) p.toReal) (HPow.hPow (EDist.edist f.2 g.2) p.toReal)) (HDiv.hDiv 1 p.toReal))","decl":"theorem prod_edist_eq_add (hp : 0 < p.toReal) (f g : WithLp p (Î± Ã— Î²)) :\n    edist f g = (edist f.fst g.fst ^ p.toReal + edist f.snd g.snd ^ p.toReal) ^ (1 / p.toReal) :=\n  let hp' := ENNReal.toReal_pos_iff.mp hp\n  (if_neg hp'.1.ne').trans (if_neg hp'.2.ne)\n\n"}
{"name":"WithLp.prod_edist_eq_sup","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : EDist Î±\ninstâœ : EDist Î²\nf g : WithLp Top.top (Prod Î± Î²)\nâŠ¢ Eq (EDist.edist f g) (Max.max (EDist.edist f.1 g.1) (EDist.edist f.2 g.2))","decl":"theorem prod_edist_eq_sup (f g : WithLp âˆ (Î± Ã— Î²)) :\n    edist f g = edist f.fst g.fst âŠ” edist f.snd g.snd := rfl\n\n"}
{"name":"WithLp.prod_edist_self","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nf : WithLp p (Prod Î± Î²)\nâŠ¢ Eq (EDist.edist f f) 0","decl":"/-- The distance from one point to itself is always zero.\n\nThis holds independent of `p` and does not require `[Fact (1 â‰¤ p)]`. We keep it separate\nfrom `WithLp.instProdPseudoEMetricSpace` so it can be used also for `p < 1`. -/\ntheorem prod_edist_self (f : WithLp p (Î± Ã— Î²)) : edist f f = 0 := by\n  rcases p.trichotomy with (rfl | rfl | h)\n  Â· classical\n    simp\n  Â· simp [prod_edist_eq_sup]\n  Â· simp [prod_edist_eq_add h, ENNReal.zero_rpow_of_pos h,\n      ENNReal.zero_rpow_of_pos (inv_pos.2 <| h)]\n\n"}
{"name":"WithLp.prod_edist_comm","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nf g : WithLp p (Prod Î± Î²)\nâŠ¢ Eq (EDist.edist f g) (EDist.edist g f)","decl":"/-- The distance is symmetric.\n\nThis holds independent of `p` and does not require `[Fact (1 â‰¤ p)]`. We keep it separate\nfrom `WithLp.instProdPseudoEMetricSpace` so it can be used also for `p < 1`. -/\ntheorem prod_edist_comm (f g : WithLp p (Î± Ã— Î²)) : edist f g = edist g f := by\n  classical\n  rcases p.trichotomy with (rfl | rfl | h)\n  Â· simp only [prod_edist_eq_card, edist_comm]\n  Â· simp only [prod_edist_eq_sup, edist_comm]\n  Â· simp only [prod_edist_eq_add h, edist_comm]\n\n"}
{"name":"WithLp.prod_dist_eq_card","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : Dist Î±\ninstâœ : Dist Î²\nf g : WithLp 0 (Prod Î± Î²)\nâŠ¢ Eq (Dist.dist f g) (HAdd.hAdd (ite (Eq (Dist.dist f.1 g.1) 0) 0 1) (ite (Eq (Dist.dist f.2 g.2) 0) 0 1))","decl":"theorem prod_dist_eq_card (f g : WithLp 0 (Î± Ã— Î²)) : dist f g =\n    (if dist f.fst g.fst = 0 then 0 else 1) + (if dist f.snd g.snd = 0 then 0 else 1) := by\n  convert if_pos rfl\n\n"}
{"name":"WithLp.prod_dist_eq_add","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : Dist Î±\ninstâœ : Dist Î²\nhp : LT.lt 0 p.toReal\nf g : WithLp p (Prod Î± Î²)\nâŠ¢ Eq (Dist.dist f g) (HPow.hPow (HAdd.hAdd (HPow.hPow (Dist.dist f.1 g.1) p.toReal) (HPow.hPow (Dist.dist f.2 g.2) p.toReal)) (HDiv.hDiv 1 p.toReal))","decl":"theorem prod_dist_eq_add (hp : 0 < p.toReal) (f g : WithLp p (Î± Ã— Î²)) :\n    dist f g = (dist f.fst g.fst ^ p.toReal + dist f.snd g.snd ^ p.toReal) ^ (1 / p.toReal) :=\n  let hp' := ENNReal.toReal_pos_iff.mp hp\n  (if_neg hp'.1.ne').trans (if_neg hp'.2.ne)\n\n"}
{"name":"WithLp.prod_dist_eq_sup","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : Dist Î±\ninstâœ : Dist Î²\nf g : WithLp Top.top (Prod Î± Î²)\nâŠ¢ Eq (Dist.dist f g) (Max.max (Dist.dist f.1 g.1) (Dist.dist f.2 g.2))","decl":"theorem prod_dist_eq_sup (f g : WithLp âˆ (Î± Ã— Î²)) :\n    dist f g = dist f.fst g.fst âŠ” dist f.snd g.snd := rfl\n\n"}
{"name":"WithLp.prod_norm_eq_card","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : Norm Î±\ninstâœ : Norm Î²\nf : WithLp 0 (Prod Î± Î²)\nâŠ¢ Eq (Norm.norm f) (HAdd.hAdd (ite (Eq (Norm.norm f.1) 0) 0 1) (ite (Eq (Norm.norm f.2) 0) 0 1))","decl":"@[simp]\ntheorem prod_norm_eq_card (f : WithLp 0 (Î± Ã— Î²)) :\n    â€–fâ€– = (if â€–f.fstâ€– = 0 then 0 else 1) + (if â€–f.sndâ€– = 0 then 0 else 1) := by\n  convert if_pos rfl\n\n"}
{"name":"WithLp.prod_norm_eq_sup","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : Norm Î±\ninstâœ : Norm Î²\nf : WithLp Top.top (Prod Î± Î²)\nâŠ¢ Eq (Norm.norm f) (Max.max (Norm.norm f.1) (Norm.norm f.2))","decl":"theorem prod_norm_eq_sup (f : WithLp âˆ (Î± Ã— Î²)) : â€–fâ€– = â€–f.fstâ€– âŠ” â€–f.sndâ€– := rfl\n\n"}
{"name":"WithLp.prod_norm_eq_add","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : Norm Î±\ninstâœ : Norm Î²\nhp : LT.lt 0 p.toReal\nf : WithLp p (Prod Î± Î²)\nâŠ¢ Eq (Norm.norm f) (HPow.hPow (HAdd.hAdd (HPow.hPow (Norm.norm f.1) p.toReal) (HPow.hPow (Norm.norm f.2) p.toReal)) (HDiv.hDiv 1 p.toReal))","decl":"theorem prod_norm_eq_add (hp : 0 < p.toReal) (f : WithLp p (Î± Ã— Î²)) :\n    â€–fâ€– = (â€–f.fstâ€– ^ p.toReal + â€–f.sndâ€– ^ p.toReal) ^ (1 / p.toReal) :=\n  let hp' := ENNReal.toReal_pos_iff.mp hp\n  (if_neg hp'.1.ne').trans (if_neg hp'.2.ne)\n\n"}
{"name":"WithLp.prod_sup_edist_ne_top_aux","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : PseudoMetricSpace Î±\ninstâœ : PseudoMetricSpace Î²\nf g : WithLp Top.top (Prod Î± Î²)\nâŠ¢ Ne (Max.max (EDist.edist f.1 g.1) (EDist.edist f.2 g.2)) Top.top","decl":"/-- An auxiliary lemma used twice in the proof of `WithLp.prodPseudoMetricAux` below. Not intended\nfor use outside this file. -/\ntheorem prod_sup_edist_ne_top_aux [PseudoMetricSpace Î±] [PseudoMetricSpace Î²]\n    (f g : WithLp âˆ (Î± Ã— Î²)) :\n    edist f.fst g.fst âŠ” edist f.snd g.snd â‰  âŠ¤ :=\n  ne_of_lt <| by simp [edist, PseudoMetricSpace.edist_dist]\n\n"}
{"name":"WithLp.prod_lipschitzWith_equiv_aux","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nhp : Fact (LE.le 1 p)\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nâŠ¢ LipschitzWith 1 â‡‘(WithLp.equiv p (Prod Î± Î²))","decl":"theorem prod_lipschitzWith_equiv_aux [PseudoEMetricSpace Î±] [PseudoEMetricSpace Î²] :\n    LipschitzWith 1 (WithLp.equiv p (Î± Ã— Î²)) := by\n  intro x y\n  rcases p.dichotomy with (rfl | h)\n  Â· simp [edist]\n  Â· have cancel : p.toReal * (1 / p.toReal) = 1 := mul_div_cancelâ‚€ 1 (zero_lt_one.trans_le h).ne'\n    rw [prod_edist_eq_add (zero_lt_one.trans_le h)]\n    simp only [edist, forall_prop_of_true, one_mul, ENNReal.coe_one, sup_le_iff]\n    constructor\n    Â· calc\n        edist x.fst y.fst â‰¤ (edist x.fst y.fst ^ p.toReal) ^ (1 / p.toReal) := by\n          simp only [â† ENNReal.rpow_mul, cancel, ENNReal.rpow_one, le_refl]\n        _ â‰¤ (edist x.fst y.fst ^ p.toReal + edist x.snd y.snd ^ p.toReal) ^ (1 / p.toReal) := by\n          gcongr\n          simp only [self_le_add_right]\n    Â· calc\n        edist x.snd y.snd â‰¤ (edist x.snd y.snd ^ p.toReal) ^ (1 / p.toReal) := by\n          simp only [â† ENNReal.rpow_mul, cancel, ENNReal.rpow_one, le_refl]\n        _ â‰¤ (edist x.fst y.fst ^ p.toReal + edist x.snd y.snd ^ p.toReal) ^ (1 / p.toReal) := by\n          gcongr\n          simp only [self_le_add_left]\n\n"}
{"name":"WithLp.prod_antilipschitzWith_equiv_aux","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nhp : Fact (LE.le 1 p)\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nâŠ¢ AntilipschitzWith (HPow.hPow 2 (HDiv.hDiv 1 p).toReal) â‡‘(WithLp.equiv p (Prod Î± Î²))","decl":"theorem prod_antilipschitzWith_equiv_aux [PseudoEMetricSpace Î±] [PseudoEMetricSpace Î²] :\n    AntilipschitzWith ((2 : â„â‰¥0) ^ (1 / p).toReal) (WithLp.equiv p (Î± Ã— Î²)) := by\n  intro x y\n  rcases p.dichotomy with (rfl | h)\n  Â· simp [edist]\n  Â· have pos : 0 < p.toReal := by positivity\n    have nonneg : 0 â‰¤ 1 / p.toReal := by positivity\n    have cancel : p.toReal * (1 / p.toReal) = 1 := mul_div_cancelâ‚€ 1 (ne_of_gt pos)\n    rw [prod_edist_eq_add pos, ENNReal.toReal_div 1 p]\n    simp only [edist, â† one_div, ENNReal.one_toReal]\n    calc\n      (edist x.fst y.fst ^ p.toReal + edist x.snd y.snd ^ p.toReal) ^ (1 / p.toReal) â‰¤\n          (edist (WithLp.equiv p _ x) (WithLp.equiv p _ y) ^ p.toReal +\n          edist (WithLp.equiv p _ x) (WithLp.equiv p _ y) ^ p.toReal) ^ (1 / p.toReal) := by\n        gcongr <;> simp [edist]\n      _ = (2 ^ (1 / p.toReal) : â„â‰¥0) * edist (WithLp.equiv p _ x) (WithLp.equiv p _ y) := by\n        simp only [â† two_mul, ENNReal.mul_rpow_of_nonneg _ _ nonneg, â† ENNReal.rpow_mul, cancel,\n          ENNReal.rpow_one, ENNReal.coe_rpow_of_nonneg _ nonneg, coe_ofNat]\n\n"}
{"name":"WithLp.prod_aux_uniformity_eq","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nhp : Fact (LE.le 1 p)\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nâŠ¢ Eq (uniformity (WithLp p (Prod Î± Î²))) (uniformity (Prod Î± Î²))","decl":"theorem prod_aux_uniformity_eq [PseudoEMetricSpace Î±] [PseudoEMetricSpace Î²] :\n    ğ“¤ (WithLp p (Î± Ã— Î²)) = ğ“¤[instUniformSpaceProd] := by\n  have A : IsUniformInducing (WithLp.equiv p (Î± Ã— Î²)) :=\n    (prod_antilipschitzWith_equiv_aux p Î± Î²).isUniformInducing\n      (prod_lipschitzWith_equiv_aux p Î± Î²).uniformContinuous\n  have : (fun x : WithLp p (Î± Ã— Î²) Ã— WithLp p (Î± Ã— Î²) =>\n    ((WithLp.equiv p (Î± Ã— Î²)) x.fst, (WithLp.equiv p (Î± Ã— Î²)) x.snd)) = id := by\n    ext i <;> rfl\n  rw [â† A.comap_uniformity, this, comap_id]\n\n"}
{"name":"WithLp.prod_aux_cobounded_eq","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nhp : Fact (LE.le 1 p)\ninstâœÂ¹ : PseudoMetricSpace Î±\ninstâœ : PseudoMetricSpace Î²\nâŠ¢ Eq (Bornology.cobounded (WithLp p (Prod Î± Î²))) (Bornology.cobounded (Prod Î± Î²))","decl":"theorem prod_aux_cobounded_eq [PseudoMetricSpace Î±] [PseudoMetricSpace Î²] :\n    cobounded (WithLp p (Î± Ã— Î²)) = @cobounded _ Prod.instBornology :=\n  calc\n    cobounded (WithLp p (Î± Ã— Î²)) = comap (WithLp.equiv p (Î± Ã— Î²)) (cobounded _) :=\n      le_antisymm (prod_antilipschitzWith_equiv_aux p Î± Î²).tendsto_cobounded.le_comap\n        (prod_lipschitzWith_equiv_aux p Î± Î²).comap_cobounded_le\n    _ = _ := comap_id\n\n"}
{"name":"WithLp.prod_continuous_equiv","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\nâŠ¢ Continuous â‡‘(WithLp.equiv p (Prod Î± Î²))","decl":"@[continuity]\ntheorem prod_continuous_equiv : Continuous (WithLp.equiv p (Î± Ã— Î²)) :=\n  continuous_id\n\n"}
{"name":"WithLp.prod_continuous_equiv_symm","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : TopologicalSpace Î²\nâŠ¢ Continuous â‡‘(WithLp.equiv p (Prod Î± Î²)).symm","decl":"@[continuity]\ntheorem prod_continuous_equiv_symm : Continuous (WithLp.equiv p (Î± Ã— Î²)).symm :=\n  continuous_id\n\n"}
{"name":"WithLp.instProdT0Space","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : TopologicalSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : T0Space Î±\ninstâœ : T0Space Î²\nâŠ¢ T0Space (WithLp p (Prod Î± Î²))","decl":"instance instProdT0Space : T0Space (WithLp p (Î± Ã— Î²)) :=\n  Prod.instT0Space\n\n"}
{"name":"WithLp.prod_uniformContinuous_equiv","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nâŠ¢ UniformContinuous â‡‘(WithLp.equiv p (Prod Î± Î²))","decl":"theorem prod_uniformContinuous_equiv : UniformContinuous (WithLp.equiv p (Î± Ã— Î²)) :=\n  uniformContinuous_id\n\n"}
{"name":"WithLp.prod_uniformContinuous_equiv_symm","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : UniformSpace Î±\ninstâœ : UniformSpace Î²\nâŠ¢ UniformContinuous â‡‘(WithLp.equiv p (Prod Î± Î²)).symm","decl":"theorem prod_uniformContinuous_equiv_symm : UniformContinuous (WithLp.equiv p (Î± Ã— Î²)).symm :=\n  uniformContinuous_id\n\n"}
{"name":"WithLp.instProdCompleteSpace","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœÂ³ : UniformSpace Î±\ninstâœÂ² : UniformSpace Î²\ninstâœÂ¹ : CompleteSpace Î±\ninstâœ : CompleteSpace Î²\nâŠ¢ CompleteSpace (WithLp p (Prod Î± Î²))","decl":"instance instProdCompleteSpace : CompleteSpace (WithLp p (Î± Ã— Î²)) :=\n  CompleteSpace.prod\n\n"}
{"name":"WithLp.prodContinuousLinearEquiv_apply","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœâ¶ : TopologicalSpace Î±\ninstâœâµ : TopologicalSpace Î²\ninstâœâ´ : Semiring ğ•œ\ninstâœÂ³ : AddCommGroup Î±\ninstâœÂ² : AddCommGroup Î²\ninstâœÂ¹ : Module ğ•œ Î±\ninstâœ : Module ğ•œ Î²\nâŠ¢ Eq â‡‘(WithLp.prodContinuousLinearEquiv p ğ•œ Î± Î²) â‡‘(WithLp.equiv p (Prod Î± Î²))","decl":"/-- `WithLp.equiv` as a continuous linear equivalence. -/\n@[simps! (config := .asFn) apply symm_apply]\nprotected def prodContinuousLinearEquiv : WithLp p (Î± Ã— Î²) â‰ƒL[ğ•œ] Î± Ã— Î² where\n  toLinearEquiv := WithLp.linearEquiv _ _ _\n  continuous_toFun := prod_continuous_equiv _ _ _\n  continuous_invFun := prod_continuous_equiv_symm _ _ _\n\n"}
{"name":"WithLp.prodContinuousLinearEquiv_symm_apply","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\ninstâœâ¶ : TopologicalSpace Î±\ninstâœâµ : TopologicalSpace Î²\ninstâœâ´ : Semiring ğ•œ\ninstâœÂ³ : AddCommGroup Î±\ninstâœÂ² : AddCommGroup Î²\ninstâœÂ¹ : Module ğ•œ Î±\ninstâœ : Module ğ•œ Î²\nâŠ¢ Eq â‡‘(WithLp.prodContinuousLinearEquiv p ğ•œ Î± Î²).symm â‡‘(WithLp.equiv p (Prod Î± Î²)).symm","decl":"/-- `WithLp.equiv` as a continuous linear equivalence. -/\n@[simps! (config := .asFn) apply symm_apply]\nprotected def prodContinuousLinearEquiv : WithLp p (Î± Ã— Î²) â‰ƒL[ğ•œ] Î± Ã— Î² where\n  toLinearEquiv := WithLp.linearEquiv _ _ _\n  continuous_toFun := prod_continuous_equiv _ _ _\n  continuous_invFun := prod_continuous_equiv_symm _ _ _\n\n"}
{"name":"WithLp.prod_nndist_eq_add","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nhpâœ : Fact (LE.le 1 p)\ninstâœÂ¹ : PseudoMetricSpace Î±\ninstâœ : PseudoMetricSpace Î²\nhp : Ne p Top.top\nx y : WithLp p (Prod Î± Î²)\nâŠ¢ Eq (NNDist.nndist x y) (HPow.hPow (HAdd.hAdd (HPow.hPow (NNDist.nndist x.1 y.1) p.toReal) (HPow.hPow (NNDist.nndist x.2 y.2) p.toReal)) (HDiv.hDiv 1 p.toReal))","decl":"theorem prod_nndist_eq_add [PseudoMetricSpace Î±] [PseudoMetricSpace Î²]\n    (hp : p â‰  âˆ) (x y : WithLp p (Î± Ã— Î²)) :\n    nndist x y = (nndist x.fst y.fst ^ p.toReal + nndist x.snd y.snd ^ p.toReal) ^ (1 / p.toReal) :=\n  NNReal.eq <| by\n    push_cast\n    exact prod_dist_eq_add (p.toReal_pos_iff_ne_top.mpr hp) _ _\n\n"}
{"name":"WithLp.prod_nndist_eq_sup","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : PseudoMetricSpace Î±\ninstâœ : PseudoMetricSpace Î²\nx y : WithLp Top.top (Prod Î± Î²)\nâŠ¢ Eq (NNDist.nndist x y) (Max.max (NNDist.nndist x.1 y.1) (NNDist.nndist x.2 y.2))","decl":"theorem prod_nndist_eq_sup [PseudoMetricSpace Î±] [PseudoMetricSpace Î²] (x y : WithLp âˆ (Î± Ã— Î²)) :\n    nndist x y = nndist x.fst y.fst âŠ” nndist x.snd y.snd :=\n  NNReal.eq <| by\n    push_cast\n    exact prod_dist_eq_sup _ _\n\n"}
{"name":"WithLp.prod_lipschitzWith_equiv","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nhp : Fact (LE.le 1 p)\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nâŠ¢ LipschitzWith 1 â‡‘(WithLp.equiv p (Prod Î± Î²))","decl":"theorem prod_lipschitzWith_equiv [PseudoEMetricSpace Î±] [PseudoEMetricSpace Î²] :\n    LipschitzWith 1 (WithLp.equiv p (Î± Ã— Î²)) :=\n  prod_lipschitzWith_equiv_aux p Î± Î²\n\n"}
{"name":"WithLp.prod_antilipschitzWith_equiv","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nhp : Fact (LE.le 1 p)\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nâŠ¢ AntilipschitzWith (HPow.hPow 2 (HDiv.hDiv 1 p).toReal) â‡‘(WithLp.equiv p (Prod Î± Î²))","decl":"theorem prod_antilipschitzWith_equiv [PseudoEMetricSpace Î±] [PseudoEMetricSpace Î²] :\n    AntilipschitzWith ((2 : â„â‰¥0) ^ (1 / p).toReal) (WithLp.equiv p (Î± Ã— Î²)) :=\n  prod_antilipschitzWith_equiv_aux p Î± Î²\n\n"}
{"name":"WithLp.prod_infty_equiv_isometry","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : PseudoEMetricSpace Î±\ninstâœ : PseudoEMetricSpace Î²\nâŠ¢ Isometry â‡‘(WithLp.equiv Top.top (Prod Î± Î²))","decl":"theorem prod_infty_equiv_isometry [PseudoEMetricSpace Î±] [PseudoEMetricSpace Î²] :\n    Isometry (WithLp.equiv âˆ (Î± Ã— Î²)) :=\n  fun x y =>\n  le_antisymm (by simpa only [ENNReal.coe_one, one_mul] using prod_lipschitzWith_equiv âˆ Î± Î² x y)\n    (by\n      simpa only [ENNReal.div_top, ENNReal.zero_toReal, NNReal.rpow_zero, ENNReal.coe_one,\n        one_mul] using prod_antilipschitzWith_equiv âˆ Î± Î² x y)\n\n"}
{"name":"WithLp.prod_norm_eq_of_nat","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nhp : Fact (LE.le 1 p)\ninstâœÂ¹ : Norm Î±\ninstâœ : Norm Î²\nn : Nat\nh : Eq p â†‘n\nf : WithLp p (Prod Î± Î²)\nâŠ¢ Eq (Norm.norm f) (HPow.hPow (HAdd.hAdd (HPow.hPow (Norm.norm f.1) n) (HPow.hPow (Norm.norm f.2) n)) (HDiv.hDiv 1 â†‘n))","decl":"theorem prod_norm_eq_of_nat [Norm Î±] [Norm Î²] (n : â„•) (h : p = n) (f : WithLp p (Î± Ã— Î²)) :\n    â€–fâ€– = (â€–f.fstâ€– ^ n + â€–f.sndâ€– ^ n) ^ (1 / (n : â„)) := by\n  have := p.toReal_pos_iff_ne_top.mpr (ne_of_eq_of_ne h <| ENNReal.natCast_ne_top n)\n  simp only [one_div, h, Real.rpow_natCast, ENNReal.toReal_nat, eq_self_iff_true, Finset.sum_congr,\n    prod_norm_eq_add this]\n\n"}
{"name":"WithLp.prod_nnnorm_eq_add","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nhpâœ : Fact (LE.le 1 p)\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nhp : Ne p Top.top\nf : WithLp p (Prod Î± Î²)\nâŠ¢ Eq (NNNorm.nnnorm f) (HPow.hPow (HAdd.hAdd (HPow.hPow (NNNorm.nnnorm f.1) p.toReal) (HPow.hPow (NNNorm.nnnorm f.2) p.toReal)) (HDiv.hDiv 1 p.toReal))","decl":"theorem prod_nnnorm_eq_add (hp : p â‰  âˆ) (f : WithLp p (Î± Ã— Î²)) :\n    â€–fâ€–â‚Š = (â€–f.fstâ€–â‚Š ^ p.toReal + â€–f.sndâ€–â‚Š ^ p.toReal) ^ (1 / p.toReal) := by\n  ext\n  simp [prod_norm_eq_add (p.toReal_pos_iff_ne_top.mpr hp)]\n\n"}
{"name":"WithLp.prod_nnnorm_eq_sup","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : WithLp Top.top (Prod Î± Î²)\nâŠ¢ Eq (NNNorm.nnnorm f) (Max.max (NNNorm.nnnorm f.1) (NNNorm.nnnorm f.2))","decl":"theorem prod_nnnorm_eq_sup (f : WithLp âˆ (Î± Ã— Î²)) : â€–fâ€–â‚Š = â€–f.fstâ€–â‚Š âŠ”  â€–f.sndâ€–â‚Š := by\n  ext\n  norm_cast\n\n"}
{"name":"WithLp.prod_nnnorm_equiv","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : WithLp Top.top (Prod Î± Î²)\nâŠ¢ Eq (NNNorm.nnnorm ((WithLp.equiv Top.top (Prod Î± Î²)) f)) (NNNorm.nnnorm f)","decl":"@[simp] theorem prod_nnnorm_equiv (f : WithLp âˆ (Î± Ã— Î²)) : â€–WithLp.equiv âŠ¤ _ fâ€–â‚Š = â€–fâ€–â‚Š := by\n  rw [prod_nnnorm_eq_sup, Prod.nnnorm_def, equiv_fst, equiv_snd]\n\n"}
{"name":"WithLp.prod_nnnorm_equiv_symm","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : Prod Î± Î²\nâŠ¢ Eq (NNNorm.nnnorm ((WithLp.equiv Top.top (Prod Î± Î²)).symm f)) (NNNorm.nnnorm f)","decl":"@[simp] theorem prod_nnnorm_equiv_symm (f : Î± Ã— Î²) : â€–(WithLp.equiv âŠ¤ _).symm fâ€–â‚Š = â€–fâ€–â‚Š :=\n  (prod_nnnorm_equiv _).symm\n\n"}
{"name":"WithLp.prod_norm_equiv","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : WithLp Top.top (Prod Î± Î²)\nâŠ¢ Eq (Norm.norm ((WithLp.equiv Top.top (Prod Î± Î²)) f)) (Norm.norm f)","decl":"@[simp] theorem prod_norm_equiv (f : WithLp âˆ (Î± Ã— Î²)) : â€–WithLp.equiv âŠ¤ _ fâ€– = â€–fâ€– :=\n  congr_arg NNReal.toReal <| prod_nnnorm_equiv f\n\n"}
{"name":"WithLp.prod_norm_equiv_symm","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nf : Prod Î± Î²\nâŠ¢ Eq (Norm.norm ((WithLp.equiv Top.top (Prod Î± Î²)).symm f)) (Norm.norm f)","decl":"@[simp] theorem prod_norm_equiv_symm (f : Î± Ã— Î²) : â€–(WithLp.equiv âŠ¤ _).symm fâ€– = â€–fâ€– :=\n  (prod_norm_equiv _).symm\n\n"}
{"name":"WithLp.prod_norm_eq_of_L1","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nx : WithLp 1 (Prod Î± Î²)\nâŠ¢ Eq (Norm.norm x) (HAdd.hAdd (Norm.norm x.1) (Norm.norm x.2))","decl":"theorem prod_norm_eq_of_L1 (x : WithLp 1 (Î± Ã— Î²)) :\n    â€–xâ€– = â€–x.fstâ€– + â€–x.sndâ€– := by\n  simp [prod_norm_eq_add]\n\n"}
{"name":"WithLp.prod_nnnorm_eq_of_L1","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nx : WithLp 1 (Prod Î± Î²)\nâŠ¢ Eq (NNNorm.nnnorm x) (HAdd.hAdd (NNNorm.nnnorm x.1) (NNNorm.nnnorm x.2))","decl":"theorem prod_nnnorm_eq_of_L1 (x : WithLp 1 (Î± Ã— Î²)) :\n    â€–xâ€–â‚Š = â€–x.fstâ€–â‚Š + â€–x.sndâ€–â‚Š :=\n  NNReal.eq <| by\n    push_cast\n    exact prod_norm_eq_of_L1 x\n\n"}
{"name":"WithLp.prod_dist_eq_of_L1","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nx y : WithLp 1 (Prod Î± Î²)\nâŠ¢ Eq (Dist.dist x y) (HAdd.hAdd (Dist.dist x.1 y.1) (Dist.dist x.2 y.2))","decl":"theorem prod_dist_eq_of_L1 (x y : WithLp 1 (Î± Ã— Î²)) :\n    dist x y = dist x.fst y.fst + dist x.snd y.snd := by\n  simp_rw [dist_eq_norm, prod_norm_eq_of_L1, sub_fst, sub_snd]\n\n"}
{"name":"WithLp.prod_nndist_eq_of_L1","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nx y : WithLp 1 (Prod Î± Î²)\nâŠ¢ Eq (NNDist.nndist x y) (HAdd.hAdd (NNDist.nndist x.1 y.1) (NNDist.nndist x.2 y.2))","decl":"theorem prod_nndist_eq_of_L1 (x y : WithLp 1 (Î± Ã— Î²)) :\n    nndist x y = nndist x.fst y.fst + nndist x.snd y.snd :=\n  NNReal.eq <| by\n    push_cast\n    exact prod_dist_eq_of_L1 _ _\n\n"}
{"name":"WithLp.prod_edist_eq_of_L1","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nx y : WithLp 1 (Prod Î± Î²)\nâŠ¢ Eq (EDist.edist x y) (HAdd.hAdd (EDist.edist x.1 y.1) (EDist.edist x.2 y.2))","decl":"theorem prod_edist_eq_of_L1 (x y : WithLp 1 (Î± Ã— Î²)) :\n    edist x y = edist x.fst y.fst + edist x.snd y.snd := by\n  simp [prod_edist_eq_add]\n\n"}
{"name":"WithLp.prod_norm_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nx : WithLp 2 (Prod Î± Î²)\nâŠ¢ Eq (Norm.norm x) (HAdd.hAdd (HPow.hPow (Norm.norm x.1) 2) (HPow.hPow (Norm.norm x.2) 2)).sqrt","decl":"theorem prod_norm_eq_of_L2 (x : WithLp 2 (Î± Ã— Î²)) :\n    â€–xâ€– = âˆš(â€–x.fstâ€– ^ 2 + â€–x.sndâ€– ^ 2) := by\n  rw [prod_norm_eq_of_nat 2 (by norm_cast) _, Real.sqrt_eq_rpow]\n  norm_cast\n\n"}
{"name":"WithLp.prod_nnnorm_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nx : WithLp 2 (Prod Î± Î²)\nâŠ¢ Eq (NNNorm.nnnorm x) (NNReal.sqrt (HAdd.hAdd (HPow.hPow (NNNorm.nnnorm x.1) 2) (HPow.hPow (NNNorm.nnnorm x.2) 2)))","decl":"theorem prod_nnnorm_eq_of_L2 (x : WithLp 2 (Î± Ã— Î²)) :\n    â€–xâ€–â‚Š = NNReal.sqrt (â€–x.fstâ€–â‚Š ^ 2 + â€–x.sndâ€–â‚Š ^ 2) :=\n  NNReal.eq <| by\n    push_cast\n    exact prod_norm_eq_of_L2 x\n\n"}
{"name":"WithLp.prod_norm_sq_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nx : WithLp 2 (Prod Î± Î²)\nâŠ¢ Eq (HPow.hPow (Norm.norm x) 2) (HAdd.hAdd (HPow.hPow (Norm.norm x.1) 2) (HPow.hPow (Norm.norm x.2) 2))","decl":"theorem prod_norm_sq_eq_of_L2 (x : WithLp 2 (Î± Ã— Î²)) : â€–xâ€– ^ 2 = â€–x.fstâ€– ^ 2 + â€–x.sndâ€– ^ 2 := by\n  suffices â€–xâ€–â‚Š ^ 2 = â€–x.fstâ€–â‚Š ^ 2 + â€–x.sndâ€–â‚Š ^ 2 by\n    simpa only [NNReal.coe_sum] using congr_arg ((â†‘) : â„â‰¥0 â†’ â„) this\n  rw [prod_nnnorm_eq_of_L2, NNReal.sq_sqrt]\n\n"}
{"name":"WithLp.prod_dist_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nx y : WithLp 2 (Prod Î± Î²)\nâŠ¢ Eq (Dist.dist x y) (HAdd.hAdd (HPow.hPow (Dist.dist x.1 y.1) 2) (HPow.hPow (Dist.dist x.2 y.2) 2)).sqrt","decl":"theorem prod_dist_eq_of_L2 (x y : WithLp 2 (Î± Ã— Î²)) :\n    dist x y = âˆš(dist x.fst y.fst ^ 2 + dist x.snd y.snd ^ 2) := by\n  simp_rw [dist_eq_norm, prod_norm_eq_of_L2, sub_fst, sub_snd]\n\n"}
{"name":"WithLp.prod_nndist_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nx y : WithLp 2 (Prod Î± Î²)\nâŠ¢ Eq (NNDist.nndist x y) (NNReal.sqrt (HAdd.hAdd (HPow.hPow (NNDist.nndist x.1 y.1) 2) (HPow.hPow (NNDist.nndist x.2 y.2) 2)))","decl":"theorem prod_nndist_eq_of_L2 (x y : WithLp 2 (Î± Ã— Î²)) :\n    nndist x y = NNReal.sqrt (nndist x.fst y.fst ^ 2 + nndist x.snd y.snd ^ 2) :=\n  NNReal.eq <| by\n    push_cast\n    exact prod_dist_eq_of_L2 _ _\n\n"}
{"name":"WithLp.prod_edist_eq_of_L2","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"Î± : Type u_2\nÎ² : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nx y : WithLp 2 (Prod Î± Î²)\nâŠ¢ Eq (EDist.edist x y) (HPow.hPow (HAdd.hAdd (HPow.hPow (EDist.edist x.1 y.1) 2) (HPow.hPow (EDist.edist x.2 y.2) 2)) (1 / 2))","decl":"theorem prod_edist_eq_of_L2 (x y : WithLp 2 (Î± Ã— Î²)) :\n    edist x y = (edist x.fst y.fst ^ 2 + edist x.snd y.snd ^ 2) ^ (1 / 2 : â„) := by\n  simp [prod_edist_eq_add]\n\n"}
{"name":"WithLp.nnnorm_equiv_symm_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nhp : Fact (LE.le 1 p)\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nx : Î±\nâŠ¢ Eq (NNNorm.nnnorm ((WithLp.equiv p (Prod Î± Î²)).symm { fst := x, snd := 0 })) (NNNorm.nnnorm x)","decl":"@[simp]\ntheorem nnnorm_equiv_symm_fst (x : Î±) :\n    â€–(WithLp.equiv p (Î± Ã— Î²)).symm (x, 0)â€–â‚Š = â€–xâ€–â‚Š := by\n  induction p generalizing hp with\n  | top =>\n    simp [prod_nnnorm_eq_sup]\n  | coe p =>\n    have hp0 : (p : â„) â‰  0 := mod_cast (zero_lt_one.trans_le <| Fact.out (p := 1 â‰¤ (p : â„â‰¥0âˆ))).ne'\n    simp [prod_nnnorm_eq_add, NNReal.zero_rpow hp0, â† NNReal.rpow_mul, mul_inv_cancelâ‚€ hp0]\n\n"}
{"name":"WithLp.nnnorm_equiv_symm_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nhp : Fact (LE.le 1 p)\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\ny : Î²\nâŠ¢ Eq (NNNorm.nnnorm ((WithLp.equiv p (Prod Î± Î²)).symm { fst := 0, snd := y })) (NNNorm.nnnorm y)","decl":"@[simp]\ntheorem nnnorm_equiv_symm_snd (y : Î²) :\n    â€–(WithLp.equiv p (Î± Ã— Î²)).symm (0, y)â€–â‚Š = â€–yâ€–â‚Š := by\n  induction p generalizing hp with\n  | top =>\n    simp [prod_nnnorm_eq_sup]\n  | coe p =>\n    have hp0 : (p : â„) â‰  0 := mod_cast (zero_lt_one.trans_le <| Fact.out (p := 1 â‰¤ (p : â„â‰¥0âˆ))).ne'\n    simp [prod_nnnorm_eq_add, NNReal.zero_rpow hp0, â† NNReal.rpow_mul, mul_inv_cancelâ‚€ hp0]\n\n"}
{"name":"WithLp.norm_equiv_symm_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nhp : Fact (LE.le 1 p)\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nx : Î±\nâŠ¢ Eq (Norm.norm ((WithLp.equiv p (Prod Î± Î²)).symm { fst := x, snd := 0 })) (Norm.norm x)","decl":"@[simp]\ntheorem norm_equiv_symm_fst (x : Î±) : â€–(WithLp.equiv p (Î± Ã— Î²)).symm (x, 0)â€– = â€–xâ€– :=\n  congr_arg ((â†‘) : â„â‰¥0 â†’ â„) <| nnnorm_equiv_symm_fst p Î± Î² x\n\n"}
{"name":"WithLp.norm_equiv_symm_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nhp : Fact (LE.le 1 p)\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\ny : Î²\nâŠ¢ Eq (Norm.norm ((WithLp.equiv p (Prod Î± Î²)).symm { fst := 0, snd := y })) (Norm.norm y)","decl":"@[simp]\ntheorem norm_equiv_symm_snd (y : Î²) : â€–(WithLp.equiv p (Î± Ã— Î²)).symm (0, y)â€– = â€–yâ€– :=\n  congr_arg ((â†‘) : â„â‰¥0 â†’ â„) <| nnnorm_equiv_symm_snd p Î± Î² y\n\n"}
{"name":"WithLp.nndist_equiv_symm_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nhp : Fact (LE.le 1 p)\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nxâ‚ xâ‚‚ : Î±\nâŠ¢ Eq (NNDist.nndist ((WithLp.equiv p (Prod Î± Î²)).symm { fst := xâ‚, snd := 0 }) ((WithLp.equiv p (Prod Î± Î²)).symm { fst := xâ‚‚, snd := 0 })) (NNDist.nndist xâ‚ xâ‚‚)","decl":"@[simp]\ntheorem nndist_equiv_symm_fst (xâ‚ xâ‚‚ : Î±) :\n    nndist ((WithLp.equiv p (Î± Ã— Î²)).symm (xâ‚, 0)) ((WithLp.equiv p (Î± Ã— Î²)).symm (xâ‚‚, 0)) =\n      nndist xâ‚ xâ‚‚ := by\n  rw [nndist_eq_nnnorm, nndist_eq_nnnorm, â† WithLp.equiv_symm_sub, Prod.mk_sub_mk, sub_zero,\n    nnnorm_equiv_symm_fst]\n\n"}
{"name":"WithLp.nndist_equiv_symm_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nhp : Fact (LE.le 1 p)\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nyâ‚ yâ‚‚ : Î²\nâŠ¢ Eq (NNDist.nndist ((WithLp.equiv p (Prod Î± Î²)).symm { fst := 0, snd := yâ‚ }) ((WithLp.equiv p (Prod Î± Î²)).symm { fst := 0, snd := yâ‚‚ })) (NNDist.nndist yâ‚ yâ‚‚)","decl":"@[simp]\ntheorem nndist_equiv_symm_snd (yâ‚ yâ‚‚ : Î²) :\n    nndist ((WithLp.equiv p (Î± Ã— Î²)).symm (0, yâ‚)) ((WithLp.equiv p (Î± Ã— Î²)).symm (0, yâ‚‚)) =\n      nndist yâ‚ yâ‚‚ := by\n  rw [nndist_eq_nnnorm, nndist_eq_nnnorm, â† WithLp.equiv_symm_sub, Prod.mk_sub_mk, sub_zero,\n    nnnorm_equiv_symm_snd]\n\n"}
{"name":"WithLp.dist_equiv_symm_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nhp : Fact (LE.le 1 p)\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nxâ‚ xâ‚‚ : Î±\nâŠ¢ Eq (Dist.dist ((WithLp.equiv p (Prod Î± Î²)).symm { fst := xâ‚, snd := 0 }) ((WithLp.equiv p (Prod Î± Î²)).symm { fst := xâ‚‚, snd := 0 })) (Dist.dist xâ‚ xâ‚‚)","decl":"@[simp]\ntheorem dist_equiv_symm_fst (xâ‚ xâ‚‚ : Î±) :\n    dist ((WithLp.equiv p (Î± Ã— Î²)).symm (xâ‚, 0)) ((WithLp.equiv p (Î± Ã— Î²)).symm (xâ‚‚, 0)) =\n      dist xâ‚ xâ‚‚ :=\n  congr_arg ((â†‘) : â„â‰¥0 â†’ â„) <| nndist_equiv_symm_fst p Î± Î² xâ‚ xâ‚‚\n\n"}
{"name":"WithLp.dist_equiv_symm_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nhp : Fact (LE.le 1 p)\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nyâ‚ yâ‚‚ : Î²\nâŠ¢ Eq (Dist.dist ((WithLp.equiv p (Prod Î± Î²)).symm { fst := 0, snd := yâ‚ }) ((WithLp.equiv p (Prod Î± Î²)).symm { fst := 0, snd := yâ‚‚ })) (Dist.dist yâ‚ yâ‚‚)","decl":"@[simp]\ntheorem dist_equiv_symm_snd (yâ‚ yâ‚‚ : Î²) :\n    dist ((WithLp.equiv p (Î± Ã— Î²)).symm (0, yâ‚)) ((WithLp.equiv p (Î± Ã— Î²)).symm (0, yâ‚‚)) =\n      dist yâ‚ yâ‚‚ :=\n  congr_arg ((â†‘) : â„â‰¥0 â†’ â„) <| nndist_equiv_symm_snd p Î± Î² yâ‚ yâ‚‚\n\n"}
{"name":"WithLp.edist_equiv_symm_fst","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nhp : Fact (LE.le 1 p)\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nxâ‚ xâ‚‚ : Î±\nâŠ¢ Eq (EDist.edist ((WithLp.equiv p (Prod Î± Î²)).symm { fst := xâ‚, snd := 0 }) ((WithLp.equiv p (Prod Î± Î²)).symm { fst := xâ‚‚, snd := 0 })) (EDist.edist xâ‚ xâ‚‚)","decl":"@[simp]\ntheorem edist_equiv_symm_fst (xâ‚ xâ‚‚ : Î±) :\n    edist ((WithLp.equiv p (Î± Ã— Î²)).symm (xâ‚, 0)) ((WithLp.equiv p (Î± Ã— Î²)).symm (xâ‚‚, 0)) =\n      edist xâ‚ xâ‚‚ := by\n  simp only [edist_nndist, nndist_equiv_symm_fst p Î± Î² xâ‚ xâ‚‚]\n\n"}
{"name":"WithLp.edist_equiv_symm_snd","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nÎ± : Type u_2\nÎ² : Type u_3\nhp : Fact (LE.le 1 p)\ninstâœÂ¹ : SeminormedAddCommGroup Î±\ninstâœ : SeminormedAddCommGroup Î²\nyâ‚ yâ‚‚ : Î²\nâŠ¢ Eq (EDist.edist ((WithLp.equiv p (Prod Î± Î²)).symm { fst := 0, snd := yâ‚ }) ((WithLp.equiv p (Prod Î± Î²)).symm { fst := 0, snd := yâ‚‚ })) (EDist.edist yâ‚ yâ‚‚)","decl":"@[simp]\ntheorem edist_equiv_symm_snd (yâ‚ yâ‚‚ : Î²) :\n    edist ((WithLp.equiv p (Î± Ã— Î²)).symm (0, yâ‚)) ((WithLp.equiv p (Î± Ã— Î²)).symm (0, yâ‚‚)) =\n      edist yâ‚ yâ‚‚ := by\n  simp only [edist_nndist, nndist_equiv_symm_snd p Î± Î² yâ‚ yâ‚‚]\n\n"}
{"name":"WithLp.instProdBoundedSMul","module":"Mathlib.Analysis.Normed.Lp.ProdLp","initialProofState":"p : ENNReal\nğ•œ : Type u_1\nÎ± : Type u_2\nÎ² : Type u_3\nhp : Fact (LE.le 1 p)\ninstâœâ´ : SeminormedAddCommGroup Î±\ninstâœÂ³ : SeminormedAddCommGroup Î²\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : Module ğ•œ Î±\ninstâœ : Module ğ•œ Î²\nâŠ¢ BoundedSMul ğ•œ (WithLp p (Prod Î± Î²))","decl":"instance instProdBoundedSMul : BoundedSMul ğ•œ (WithLp p (Î± Ã— Î²)) :=\n  .of_nnnorm_smul_le fun c f => by\n    rcases p.dichotomy with (rfl | hp)\n    Â· simp only [â† prod_nnnorm_equiv, WithLp.equiv_smul]\n      exact norm_smul_le _ _\n    Â· have hp0 : 0 < p.toReal := zero_lt_one.trans_le hp\n      have hpt : p â‰  âŠ¤ := p.toReal_pos_iff_ne_top.mp hp0\n      rw [prod_nnnorm_eq_add hpt, prod_nnnorm_eq_add hpt, one_div, NNReal.rpow_inv_le_iff hp0,\n        NNReal.mul_rpow, â† NNReal.rpow_mul, inv_mul_cancelâ‚€ hp0.ne', NNReal.rpow_one, mul_add,\n        â† NNReal.mul_rpow, â† NNReal.mul_rpow]\n      exact add_le_add\n        (NNReal.rpow_le_rpow (nnnorm_smul_le _ _) hp0.le)\n        (NNReal.rpow_le_rpow (nnnorm_smul_le _ _) hp0.le)\n\n"}
