{"name":"CovBySMul.rfl","module":"Mathlib.Combinatorics.Additive.CovBySMul","initialProofState":"M : Type u_1\nX : Type u_3\ninst✝¹ : Monoid M\ninst✝ : MulAction M X\nA : Set X\n⊢ CovBySMul M 1 A A","decl":"@[to_additive (attr := simp, refl)]\nlemma CovBySMul.rfl : CovBySMul M 1 A A := ⟨1, by simp⟩\n\n"}
{"name":"CovByVAdd.rfl","module":"Mathlib.Combinatorics.Additive.CovBySMul","initialProofState":"M : Type u_1\nX : Type u_3\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M X\nA : Set X\n⊢ CovByVAdd M 1 A A","decl":"@[to_additive (attr := simp, refl)]\nlemma CovBySMul.rfl : CovBySMul M 1 A A := ⟨1, by simp⟩\n\n"}
{"name":"CovByVAdd.of_subset","module":"Mathlib.Combinatorics.Additive.CovBySMul","initialProofState":"M : Type u_1\nX : Type u_3\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M X\nA B : Set X\nhAB : HasSubset.Subset A B\n⊢ CovByVAdd M 1 A B","decl":"@[to_additive (attr := simp)]\nlemma CovBySMul.of_subset (hAB : A ⊆ B) : CovBySMul M 1 A B := ⟨1, by simpa⟩\n\n"}
{"name":"CovBySMul.of_subset","module":"Mathlib.Combinatorics.Additive.CovBySMul","initialProofState":"M : Type u_1\nX : Type u_3\ninst✝¹ : Monoid M\ninst✝ : MulAction M X\nA B : Set X\nhAB : HasSubset.Subset A B\n⊢ CovBySMul M 1 A B","decl":"@[to_additive (attr := simp)]\nlemma CovBySMul.of_subset (hAB : A ⊆ B) : CovBySMul M 1 A B := ⟨1, by simpa⟩\n\n"}
{"name":"CovByVAdd.nonneg","module":"Mathlib.Combinatorics.Additive.CovBySMul","initialProofState":"M : Type u_1\nX : Type u_3\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M X\nK : Real\nA B : Set X\na✝ : CovByVAdd M K A B\n⊢ LE.le 0 K","decl":"@[to_additive] lemma CovBySMul.nonneg : CovBySMul M K A B → 0 ≤ K := by\n  rintro ⟨F, hF, -⟩; exact (#F).cast_nonneg.trans hF\n\n"}
{"name":"CovBySMul.nonneg","module":"Mathlib.Combinatorics.Additive.CovBySMul","initialProofState":"M : Type u_1\nX : Type u_3\ninst✝¹ : Monoid M\ninst✝ : MulAction M X\nK : Real\nA B : Set X\na✝ : CovBySMul M K A B\n⊢ LE.le 0 K","decl":"@[to_additive] lemma CovBySMul.nonneg : CovBySMul M K A B → 0 ≤ K := by\n  rintro ⟨F, hF, -⟩; exact (#F).cast_nonneg.trans hF\n\n"}
{"name":"covByVAdd_zero","module":"Mathlib.Combinatorics.Additive.CovBySMul","initialProofState":"M : Type u_1\nX : Type u_3\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M X\nA B : Set X\n⊢ Iff (CovByVAdd M 0 A B) (Eq A EmptyCollection.emptyCollection)","decl":"@[to_additive (attr := simp)]\nlemma covBySMul_zero : CovBySMul M 0 A B ↔ A = ∅ := by simp [CovBySMul]\n\n"}
{"name":"covBySMul_zero","module":"Mathlib.Combinatorics.Additive.CovBySMul","initialProofState":"M : Type u_1\nX : Type u_3\ninst✝¹ : Monoid M\ninst✝ : MulAction M X\nA B : Set X\n⊢ Iff (CovBySMul M 0 A B) (Eq A EmptyCollection.emptyCollection)","decl":"@[to_additive (attr := simp)]\nlemma covBySMul_zero : CovBySMul M 0 A B ↔ A = ∅ := by simp [CovBySMul]\n\n"}
{"name":"CovByVAdd.mono","module":"Mathlib.Combinatorics.Additive.CovBySMul","initialProofState":"M : Type u_1\nX : Type u_3\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M X\nK L : Real\nA B : Set X\nhKL : LE.le K L\na✝ : CovByVAdd M K A B\n⊢ CovByVAdd M L A B","decl":"@[to_additive]\nlemma CovBySMul.mono (hKL : K ≤ L) : CovBySMul M K A B → CovBySMul M L A B := by\n  rintro ⟨F, hF, hFAB⟩; exact ⟨F, hF.trans hKL, hFAB⟩\n\n"}
{"name":"CovBySMul.mono","module":"Mathlib.Combinatorics.Additive.CovBySMul","initialProofState":"M : Type u_1\nX : Type u_3\ninst✝¹ : Monoid M\ninst✝ : MulAction M X\nK L : Real\nA B : Set X\nhKL : LE.le K L\na✝ : CovBySMul M K A B\n⊢ CovBySMul M L A B","decl":"@[to_additive]\nlemma CovBySMul.mono (hKL : K ≤ L) : CovBySMul M K A B → CovBySMul M L A B := by\n  rintro ⟨F, hF, hFAB⟩; exact ⟨F, hF.trans hKL, hFAB⟩\n\n"}
{"name":"CovByVAdd.trans","module":"Mathlib.Combinatorics.Additive.CovBySMul","initialProofState":"M : Type u_1\nN : Type u_2\nX : Type u_3\ninst✝⁵ : AddMonoid M\ninst✝⁴ : AddMonoid N\ninst✝³ : AddAction M X\ninst✝² : AddAction N X\nK L : Real\nA B C : Set X\ninst✝¹ : AddAction M N\ninst✝ : VAddAssocClass M N X\nhAB : CovByVAdd M K A B\nhBC : CovByVAdd N L B C\n⊢ CovByVAdd N (HMul.hMul K L) A C","decl":"@[to_additive] lemma CovBySMul.trans [MulAction M N] [IsScalarTower M N X]\n    (hAB : CovBySMul M K A B) (hBC : CovBySMul N L B C) : CovBySMul N (K * L) A C := by\n  classical\n  have := hAB.nonneg\n  obtain ⟨F₁, hF₁, hFAB⟩ := hAB\n  obtain ⟨F₂, hF₂, hFBC⟩ := hBC\n  refine ⟨F₁ • F₂, ?_, ?_⟩\n  · calc\n      (#(F₁ • F₂) : ℝ) ≤ #F₁ * #F₂ := mod_cast Finset.card_smul_le\n      _ ≤ K * L := by gcongr\n  · calc\n      A ⊆ (F₁ : Set M) • B := hFAB\n      _ ⊆ (F₁ : Set M) • (F₂ : Set N) • C := by gcongr\n      _ = (↑(F₁ • F₂) : Set N) • C := by simp\n\n"}
{"name":"CovBySMul.trans","module":"Mathlib.Combinatorics.Additive.CovBySMul","initialProofState":"M : Type u_1\nN : Type u_2\nX : Type u_3\ninst✝⁵ : Monoid M\ninst✝⁴ : Monoid N\ninst✝³ : MulAction M X\ninst✝² : MulAction N X\nK L : Real\nA B C : Set X\ninst✝¹ : MulAction M N\ninst✝ : IsScalarTower M N X\nhAB : CovBySMul M K A B\nhBC : CovBySMul N L B C\n⊢ CovBySMul N (HMul.hMul K L) A C","decl":"@[to_additive] lemma CovBySMul.trans [MulAction M N] [IsScalarTower M N X]\n    (hAB : CovBySMul M K A B) (hBC : CovBySMul N L B C) : CovBySMul N (K * L) A C := by\n  classical\n  have := hAB.nonneg\n  obtain ⟨F₁, hF₁, hFAB⟩ := hAB\n  obtain ⟨F₂, hF₂, hFBC⟩ := hBC\n  refine ⟨F₁ • F₂, ?_, ?_⟩\n  · calc\n      (#(F₁ • F₂) : ℝ) ≤ #F₁ * #F₂ := mod_cast Finset.card_smul_le\n      _ ≤ K * L := by gcongr\n  · calc\n      A ⊆ (F₁ : Set M) • B := hFAB\n      _ ⊆ (F₁ : Set M) • (F₂ : Set N) • C := by gcongr\n      _ = (↑(F₁ • F₂) : Set N) • C := by simp\n\n"}
{"name":"CovBySMul.subset_left","module":"Mathlib.Combinatorics.Additive.CovBySMul","initialProofState":"M : Type u_1\nX : Type u_3\ninst✝¹ : Monoid M\ninst✝ : MulAction M X\nK : Real\nA₁ A₂ B : Set X\nhA : HasSubset.Subset A₁ A₂\nhAB : CovBySMul M K A₂ B\n⊢ CovBySMul M K A₁ B","decl":"@[to_additive]\nlemma CovBySMul.subset_left (hA : A₁ ⊆ A₂) (hAB : CovBySMul M K A₂ B) :\n    CovBySMul M K A₁ B := by simpa using (CovBySMul.of_subset (M := M) hA).trans hAB\n\n"}
{"name":"CovByVAdd.subset_left","module":"Mathlib.Combinatorics.Additive.CovBySMul","initialProofState":"M : Type u_1\nX : Type u_3\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M X\nK : Real\nA₁ A₂ B : Set X\nhA : HasSubset.Subset A₁ A₂\nhAB : CovByVAdd M K A₂ B\n⊢ CovByVAdd M K A₁ B","decl":"@[to_additive]\nlemma CovBySMul.subset_left (hA : A₁ ⊆ A₂) (hAB : CovBySMul M K A₂ B) :\n    CovBySMul M K A₁ B := by simpa using (CovBySMul.of_subset (M := M) hA).trans hAB\n\n"}
{"name":"CovBySMul.subset_right","module":"Mathlib.Combinatorics.Additive.CovBySMul","initialProofState":"M : Type u_1\nX : Type u_3\ninst✝¹ : Monoid M\ninst✝ : MulAction M X\nK : Real\nA B₁ B₂ : Set X\nhB : HasSubset.Subset B₁ B₂\nhAB : CovBySMul M K A B₁\n⊢ CovBySMul M K A B₂","decl":"@[to_additive]\nlemma CovBySMul.subset_right (hB : B₁ ⊆ B₂) (hAB : CovBySMul M K A B₁) :\n    CovBySMul M K A B₂ := by simpa using hAB.trans (.of_subset (M := M) hB)\n\n"}
{"name":"CovByVAdd.subset_right","module":"Mathlib.Combinatorics.Additive.CovBySMul","initialProofState":"M : Type u_1\nX : Type u_3\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M X\nK : Real\nA B₁ B₂ : Set X\nhB : HasSubset.Subset B₁ B₂\nhAB : CovByVAdd M K A B₁\n⊢ CovByVAdd M K A B₂","decl":"@[to_additive]\nlemma CovBySMul.subset_right (hB : B₁ ⊆ B₂) (hAB : CovBySMul M K A B₁) :\n    CovBySMul M K A B₂ := by simpa using hAB.trans (.of_subset (M := M) hB)\n\n"}
{"name":"CovByVAdd.subset","module":"Mathlib.Combinatorics.Additive.CovBySMul","initialProofState":"M : Type u_1\nX : Type u_3\ninst✝¹ : AddMonoid M\ninst✝ : AddAction M X\nK : Real\nA₁ A₂ B₁ B₂ : Set X\nhA : HasSubset.Subset A₁ A₂\nhB : HasSubset.Subset B₁ B₂\nhAB : CovByVAdd M K A₂ B₁\n⊢ CovByVAdd M K A₁ B₂","decl":"@[to_additive]\nlemma CovBySMul.subset (hA : A₁ ⊆ A₂) (hB : B₁ ⊆ B₂) (hAB : CovBySMul M K A₂ B₁) :\n    CovBySMul M K A₁ B₂ := (hAB.subset_left hA).subset_right hB\n"}
{"name":"CovBySMul.subset","module":"Mathlib.Combinatorics.Additive.CovBySMul","initialProofState":"M : Type u_1\nX : Type u_3\ninst✝¹ : Monoid M\ninst✝ : MulAction M X\nK : Real\nA₁ A₂ B₁ B₂ : Set X\nhA : HasSubset.Subset A₁ A₂\nhB : HasSubset.Subset B₁ B₂\nhAB : CovBySMul M K A₂ B₁\n⊢ CovBySMul M K A₁ B₂","decl":"@[to_additive]\nlemma CovBySMul.subset (hA : A₁ ⊆ A₂) (hB : B₁ ⊆ B₂) (hAB : CovBySMul M K A₂ B₁) :\n    CovBySMul M K A₁ B₂ := (hAB.subset_left hA).subset_right hB\n"}
