{"name":"CategoryTheory.Sheaf.isSeparating","module":"Mathlib.CategoryTheory.Generator.Sheaf","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} A\ninst✝¹ : CategoryTheory.Limits.HasCoproducts A\ninst✝ : CategoryTheory.HasWeakSheafify J A\nι : Type w\nS : ι → A\nhS : CategoryTheory.IsSeparating (Set.range S)\n⊢ CategoryTheory.IsSeparating (Set.range fun x => CategoryTheory.Sheaf.isSeparating.match_1 (fun x => CategoryTheory.Sheaf J A) x fun X i => CategoryTheory.Sheaf.freeYoneda J X (S i))","decl":"lemma isSeparating {ι : Type w} {S : ι → A} (hS : IsSeparating (Set.range S)) :\n    IsSeparating (Set.range (fun (⟨X, i⟩ : C × ι) ↦ freeYoneda J X (S i))) := by\n  intro F G f g hfg\n  refine (sheafToPresheaf J A).map_injective (Presheaf.isSeparating C hS _ _ ?_)\n  rintro _ ⟨⟨X, i⟩, rfl⟩ a\n  apply ((sheafificationAdjunction _ _).homEquiv _ _).symm.injective\n  simpa only [← Adjunction.homEquiv_naturality_right_symm] using\n    hfg _ ⟨⟨X, i⟩, rfl⟩ (((sheafificationAdjunction _ _).homEquiv _ _).symm a)\n\n"}
{"name":"CategoryTheory.Sheaf.isSeparator","module":"Mathlib.CategoryTheory.Generator.Sheaf","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} A\ninst✝³ : CategoryTheory.Limits.HasCoproducts A\ninst✝² : CategoryTheory.HasWeakSheafify J A\nι : Type w\nS : ι → A\nhS : CategoryTheory.IsSeparating (Set.range S)\ninst✝¹ : CategoryTheory.Limits.HasCoproduct fun x => CategoryTheory.Sheaf.isSeparating.match_1 (fun x => CategoryTheory.Sheaf J A) x fun X i => CategoryTheory.Sheaf.freeYoneda J X (S i)\ninst✝ : CategoryTheory.Preadditive A\n⊢ CategoryTheory.IsSeparator (CategoryTheory.Limits.sigmaObj fun x => CategoryTheory.Sheaf.isSeparating.match_1 (fun x => CategoryTheory.Sheaf J A) x fun X i => CategoryTheory.Sheaf.freeYoneda J X (S i))","decl":"lemma isSeparator {ι : Type w} {S : ι → A} (hS : IsSeparating (Set.range S))\n    [HasCoproduct (fun (⟨X, i⟩ : C × ι) ↦ freeYoneda J X (S i))] [Preadditive A] :\n    IsSeparator (∐ (fun (⟨X, i⟩ : C × ι) ↦ freeYoneda J X (S i))) :=\n  (isSeparating J hS).isSeparator_coproduct\n\n"}
{"name":"CategoryTheory.Sheaf.hasSeparator","module":"Mathlib.CategoryTheory.Generator.Sheaf","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u'\ninst✝⁵ : CategoryTheory.Category.{v', u'} A\ninst✝⁴ : CategoryTheory.Limits.HasCoproducts A\ninst✝³ : CategoryTheory.HasWeakSheafify J A\ninst✝² : CategoryTheory.HasSeparator A\ninst✝¹ : CategoryTheory.Preadditive A\ninst✝ : CategoryTheory.Limits.HasCoproducts A\n⊢ CategoryTheory.HasSeparator (CategoryTheory.Sheaf J A)","decl":"variable (A) in\ninstance hasSeparator [HasSeparator A] [Preadditive A] [HasCoproducts.{u} A] :\n    HasSeparator (Sheaf J A) where\n  hasSeparator := ⟨_, isSeparator J (S := fun (_ : Unit) ↦ separator A)\n      (by simpa using isSeparator_separator A)⟩\n\n"}
