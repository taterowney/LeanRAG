{"name":"CategoryTheory.Triangulated.TStructure.LE_closedUnderIsomorphisms","module":"Mathlib.CategoryTheory.Triangulated.TStructure.Basic","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nself : CategoryTheory.Triangulated.TStructure C\nn : Int\n⊢ CategoryTheory.ClosedUnderIsomorphisms (self.LE n)","decl":"/-- `TStructure C` is the type of t-structures on the (pre)triangulated category `C`. -/\nstructure TStructure where\n  /-- the predicate of objects that are `≤ n` for `n : ℤ`. -/\n  LE (n : ℤ) : C → Prop\n  /-- the predicate of objects that are `≥ n` for `n : ℤ`. -/\n  GE (n : ℤ) : C → Prop\n  LE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (LE n) := by infer_instance\n  GE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (GE n) := by infer_instance\n  LE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : LE n X) : LE n' (X⟦a⟧)\n  GE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : GE n X) : GE n' (X⟦a⟧)\n  zero' ⦃X Y : C⦄ (f : X ⟶ Y) (hX : LE 0 X) (hY : GE 1 Y) : f = 0\n  LE_zero_le : LE 0 ≤ LE 1\n  GE_one_le : GE 1 ≤ GE 0\n  exists_triangle_zero_one (A : C) : ∃ (X Y : C) (_ : LE 0 X) (_ : GE 1 Y)\n    (f : X ⟶ A) (g : A ⟶ Y) (h : Y ⟶ X⟦(1 : ℤ)⟧), Triangle.mk f g h ∈ distTriang C\n\n"}
{"name":"CategoryTheory.Triangulated.TStructure.mk.injEq","module":"Mathlib.CategoryTheory.Triangulated.TStructure.Basic","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nLE✝ GE✝ : Int → C → Prop\nLE_closedUnderIsomorphisms✝ : autoParam (∀ (n : Int), CategoryTheory.ClosedUnderIsomorphisms (LE✝ n)) _auto✝\nGE_closedUnderIsomorphisms✝ : autoParam (∀ (n : Int), CategoryTheory.ClosedUnderIsomorphisms (GE✝ n)) _auto✝\nLE_shift✝ : ∀ (n a n' : Int), Eq (HAdd.hAdd a n') n → ∀ (X : C), LE✝ n X → LE✝ n' ((CategoryTheory.shiftFunctor C a).obj X)\nGE_shift✝ : ∀ (n a n' : Int), Eq (HAdd.hAdd a n') n → ∀ (X : C), GE✝ n X → GE✝ n' ((CategoryTheory.shiftFunctor C a).obj X)\nzero'✝ : ∀ ⦃X Y : C⦄ (f : Quiver.Hom X Y), LE✝ 0 X → GE✝ 1 Y → Eq f 0\nLE_zero_le✝ : LE.le (LE✝ 0) (LE✝ 1)\nGE_one_le✝ : LE.le (GE✝ 1) (GE✝ 0)\nexists_triangle_zero_one✝ : ∀ (A : C), Exists fun X => Exists fun Y => Exists fun x => Exists fun x => Exists fun f => Exists fun g => Exists fun h => Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk f g h)\nLE GE : Int → C → Prop\nLE_closedUnderIsomorphisms : autoParam (∀ (n : Int), CategoryTheory.ClosedUnderIsomorphisms (LE n)) _auto✝\nGE_closedUnderIsomorphisms : autoParam (∀ (n : Int), CategoryTheory.ClosedUnderIsomorphisms (GE n)) _auto✝\nLE_shift : ∀ (n a n' : Int), Eq (HAdd.hAdd a n') n → ∀ (X : C), LE n X → LE n' ((CategoryTheory.shiftFunctor C a).obj X)\nGE_shift : ∀ (n a n' : Int), Eq (HAdd.hAdd a n') n → ∀ (X : C), GE n X → GE n' ((CategoryTheory.shiftFunctor C a).obj X)\nzero' : ∀ ⦃X Y : C⦄ (f : Quiver.Hom X Y), LE 0 X → GE 1 Y → Eq f 0\nLE_zero_le : LE.le (LE 0) (LE 1)\nGE_one_le : LE.le (GE 1) (GE 0)\nexists_triangle_zero_one : ∀ (A : C), Exists fun X => Exists fun Y => Exists fun x => Exists fun x => Exists fun f => Exists fun g => Exists fun h => Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk f g h)\n⊢ Eq (Eq { LE := LE✝, GE := GE✝, LE_closedUnderIsomorphisms := LE_closedUnderIsomorphisms✝, GE_closedUnderIsomorphisms := GE_closedUnderIsomorphisms✝, LE_shift := LE_shift✝, GE_shift := GE_shift✝, zero' := zero'✝, LE_zero_le := LE_zero_le✝, GE_one_le := GE_one_le✝, exists_triangle_zero_one := exists_triangle_zero_one✝ } { LE := LE, GE := GE, LE_closedUnderIsomorphisms := LE_closedUnderIsomorphisms, GE_closedUnderIsomorphisms := GE_closedUnderIsomorphisms, LE_shift := LE_shift, GE_shift := GE_shift, zero' := zero', LE_zero_le := LE_zero_le, GE_one_le := GE_one_le, exists_triangle_zero_one := exists_triangle_zero_one }) (And (Eq LE✝ LE) (Eq GE✝ GE))","decl":"/-- `TStructure C` is the type of t-structures on the (pre)triangulated category `C`. -/\nstructure TStructure where\n  /-- the predicate of objects that are `≤ n` for `n : ℤ`. -/\n  LE (n : ℤ) : C → Prop\n  /-- the predicate of objects that are `≥ n` for `n : ℤ`. -/\n  GE (n : ℤ) : C → Prop\n  LE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (LE n) := by infer_instance\n  GE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (GE n) := by infer_instance\n  LE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : LE n X) : LE n' (X⟦a⟧)\n  GE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : GE n X) : GE n' (X⟦a⟧)\n  zero' ⦃X Y : C⦄ (f : X ⟶ Y) (hX : LE 0 X) (hY : GE 1 Y) : f = 0\n  LE_zero_le : LE 0 ≤ LE 1\n  GE_one_le : GE 1 ≤ GE 0\n  exists_triangle_zero_one (A : C) : ∃ (X Y : C) (_ : LE 0 X) (_ : GE 1 Y)\n    (f : X ⟶ A) (g : A ⟶ Y) (h : Y ⟶ X⟦(1 : ℤ)⟧), Triangle.mk f g h ∈ distTriang C\n\n"}
{"name":"CategoryTheory.Triangulated.TStructure.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Triangulated.TStructure.Basic","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝¹ : CategoryTheory.Pretriangulated C\ninst✝ : SizeOf C\nLE GE : Int → C → Prop\nLE_closedUnderIsomorphisms : autoParam (∀ (n : Int), CategoryTheory.ClosedUnderIsomorphisms (LE n)) _auto✝\nGE_closedUnderIsomorphisms : autoParam (∀ (n : Int), CategoryTheory.ClosedUnderIsomorphisms (GE n)) _auto✝\nLE_shift : ∀ (n a n' : Int), Eq (HAdd.hAdd a n') n → ∀ (X : C), LE n X → LE n' ((CategoryTheory.shiftFunctor C a).obj X)\nGE_shift : ∀ (n a n' : Int), Eq (HAdd.hAdd a n') n → ∀ (X : C), GE n X → GE n' ((CategoryTheory.shiftFunctor C a).obj X)\nzero' : ∀ ⦃X Y : C⦄ (f : Quiver.Hom X Y), LE 0 X → GE 1 Y → Eq f 0\nLE_zero_le : LE.le (LE 0) (LE 1)\nGE_one_le : LE.le (GE 1) (GE 0)\nexists_triangle_zero_one : ∀ (A : C), Exists fun X => Exists fun Y => Exists fun x => Exists fun x => Exists fun f => Exists fun g => Exists fun h => Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk f g h)\n⊢ Eq (SizeOf.sizeOf { LE := LE, GE := GE, LE_closedUnderIsomorphisms := LE_closedUnderIsomorphisms, GE_closedUnderIsomorphisms := GE_closedUnderIsomorphisms, LE_shift := LE_shift, GE_shift := GE_shift, zero' := zero', LE_zero_le := LE_zero_le, GE_one_le := GE_one_le, exists_triangle_zero_one := exists_triangle_zero_one }) 1","decl":"/-- `TStructure C` is the type of t-structures on the (pre)triangulated category `C`. -/\nstructure TStructure where\n  /-- the predicate of objects that are `≤ n` for `n : ℤ`. -/\n  LE (n : ℤ) : C → Prop\n  /-- the predicate of objects that are `≥ n` for `n : ℤ`. -/\n  GE (n : ℤ) : C → Prop\n  LE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (LE n) := by infer_instance\n  GE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (GE n) := by infer_instance\n  LE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : LE n X) : LE n' (X⟦a⟧)\n  GE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : GE n X) : GE n' (X⟦a⟧)\n  zero' ⦃X Y : C⦄ (f : X ⟶ Y) (hX : LE 0 X) (hY : GE 1 Y) : f = 0\n  LE_zero_le : LE 0 ≤ LE 1\n  GE_one_le : GE 1 ≤ GE 0\n  exists_triangle_zero_one (A : C) : ∃ (X Y : C) (_ : LE 0 X) (_ : GE 1 Y)\n    (f : X ⟶ A) (g : A ⟶ Y) (h : Y ⟶ X⟦(1 : ℤ)⟧), Triangle.mk f g h ∈ distTriang C\n\n"}
{"name":"CategoryTheory.Triangulated.TStructure.GE_one_le","module":"Mathlib.CategoryTheory.Triangulated.TStructure.Basic","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nself : CategoryTheory.Triangulated.TStructure C\n⊢ LE.le (self.GE 1) (self.GE 0)","decl":"/-- `TStructure C` is the type of t-structures on the (pre)triangulated category `C`. -/\nstructure TStructure where\n  /-- the predicate of objects that are `≤ n` for `n : ℤ`. -/\n  LE (n : ℤ) : C → Prop\n  /-- the predicate of objects that are `≥ n` for `n : ℤ`. -/\n  GE (n : ℤ) : C → Prop\n  LE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (LE n) := by infer_instance\n  GE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (GE n) := by infer_instance\n  LE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : LE n X) : LE n' (X⟦a⟧)\n  GE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : GE n X) : GE n' (X⟦a⟧)\n  zero' ⦃X Y : C⦄ (f : X ⟶ Y) (hX : LE 0 X) (hY : GE 1 Y) : f = 0\n  LE_zero_le : LE 0 ≤ LE 1\n  GE_one_le : GE 1 ≤ GE 0\n  exists_triangle_zero_one (A : C) : ∃ (X Y : C) (_ : LE 0 X) (_ : GE 1 Y)\n    (f : X ⟶ A) (g : A ⟶ Y) (h : Y ⟶ X⟦(1 : ℤ)⟧), Triangle.mk f g h ∈ distTriang C\n\n"}
{"name":"CategoryTheory.Triangulated.TStructure.mk.inj","module":"Mathlib.CategoryTheory.Triangulated.TStructure.Basic","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nLE✝ GE✝ : Int → C → Prop\nLE_closedUnderIsomorphisms✝ : autoParam (∀ (n : Int), CategoryTheory.ClosedUnderIsomorphisms (LE✝ n)) _auto✝\nGE_closedUnderIsomorphisms✝ : autoParam (∀ (n : Int), CategoryTheory.ClosedUnderIsomorphisms (GE✝ n)) _auto✝\nLE_shift✝ : ∀ (n a n' : Int), Eq (HAdd.hAdd a n') n → ∀ (X : C), LE✝ n X → LE✝ n' ((CategoryTheory.shiftFunctor C a).obj X)\nGE_shift✝ : ∀ (n a n' : Int), Eq (HAdd.hAdd a n') n → ∀ (X : C), GE✝ n X → GE✝ n' ((CategoryTheory.shiftFunctor C a).obj X)\nzero'✝ : ∀ ⦃X Y : C⦄ (f : Quiver.Hom X Y), LE✝ 0 X → GE✝ 1 Y → Eq f 0\nLE_zero_le✝ : LE.le (LE✝ 0) (LE✝ 1)\nGE_one_le✝ : LE.le (GE✝ 1) (GE✝ 0)\nexists_triangle_zero_one✝ : ∀ (A : C), Exists fun X => Exists fun Y => Exists fun x => Exists fun x => Exists fun f => Exists fun g => Exists fun h => Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk f g h)\nLE GE : Int → C → Prop\nLE_closedUnderIsomorphisms : autoParam (∀ (n : Int), CategoryTheory.ClosedUnderIsomorphisms (LE n)) _auto✝\nGE_closedUnderIsomorphisms : autoParam (∀ (n : Int), CategoryTheory.ClosedUnderIsomorphisms (GE n)) _auto✝\nLE_shift : ∀ (n a n' : Int), Eq (HAdd.hAdd a n') n → ∀ (X : C), LE n X → LE n' ((CategoryTheory.shiftFunctor C a).obj X)\nGE_shift : ∀ (n a n' : Int), Eq (HAdd.hAdd a n') n → ∀ (X : C), GE n X → GE n' ((CategoryTheory.shiftFunctor C a).obj X)\nzero' : ∀ ⦃X Y : C⦄ (f : Quiver.Hom X Y), LE 0 X → GE 1 Y → Eq f 0\nLE_zero_le : LE.le (LE 0) (LE 1)\nGE_one_le : LE.le (GE 1) (GE 0)\nexists_triangle_zero_one : ∀ (A : C), Exists fun X => Exists fun Y => Exists fun x => Exists fun x => Exists fun f => Exists fun g => Exists fun h => Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk f g h)\nx✝ : Eq { LE := LE✝, GE := GE✝, LE_closedUnderIsomorphisms := LE_closedUnderIsomorphisms✝, GE_closedUnderIsomorphisms := GE_closedUnderIsomorphisms✝, LE_shift := LE_shift✝, GE_shift := GE_shift✝, zero' := zero'✝, LE_zero_le := LE_zero_le✝, GE_one_le := GE_one_le✝, exists_triangle_zero_one := exists_triangle_zero_one✝ } { LE := LE, GE := GE, LE_closedUnderIsomorphisms := LE_closedUnderIsomorphisms, GE_closedUnderIsomorphisms := GE_closedUnderIsomorphisms, LE_shift := LE_shift, GE_shift := GE_shift, zero' := zero', LE_zero_le := LE_zero_le, GE_one_le := GE_one_le, exists_triangle_zero_one := exists_triangle_zero_one }\n⊢ And (Eq LE✝ LE) (Eq GE✝ GE)","decl":"/-- `TStructure C` is the type of t-structures on the (pre)triangulated category `C`. -/\nstructure TStructure where\n  /-- the predicate of objects that are `≤ n` for `n : ℤ`. -/\n  LE (n : ℤ) : C → Prop\n  /-- the predicate of objects that are `≥ n` for `n : ℤ`. -/\n  GE (n : ℤ) : C → Prop\n  LE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (LE n) := by infer_instance\n  GE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (GE n) := by infer_instance\n  LE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : LE n X) : LE n' (X⟦a⟧)\n  GE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : GE n X) : GE n' (X⟦a⟧)\n  zero' ⦃X Y : C⦄ (f : X ⟶ Y) (hX : LE 0 X) (hY : GE 1 Y) : f = 0\n  LE_zero_le : LE 0 ≤ LE 1\n  GE_one_le : GE 1 ≤ GE 0\n  exists_triangle_zero_one (A : C) : ∃ (X Y : C) (_ : LE 0 X) (_ : GE 1 Y)\n    (f : X ⟶ A) (g : A ⟶ Y) (h : Y ⟶ X⟦(1 : ℤ)⟧), Triangle.mk f g h ∈ distTriang C\n\n"}
{"name":"CategoryTheory.Triangulated.TStructure.zero'","module":"Mathlib.CategoryTheory.Triangulated.TStructure.Basic","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nself : CategoryTheory.Triangulated.TStructure C\nX Y : C\nf : Quiver.Hom X Y\nhX : self.LE 0 X\nhY : self.GE 1 Y\n⊢ Eq f 0","decl":"/-- `TStructure C` is the type of t-structures on the (pre)triangulated category `C`. -/\nstructure TStructure where\n  /-- the predicate of objects that are `≤ n` for `n : ℤ`. -/\n  LE (n : ℤ) : C → Prop\n  /-- the predicate of objects that are `≥ n` for `n : ℤ`. -/\n  GE (n : ℤ) : C → Prop\n  LE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (LE n) := by infer_instance\n  GE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (GE n) := by infer_instance\n  LE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : LE n X) : LE n' (X⟦a⟧)\n  GE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : GE n X) : GE n' (X⟦a⟧)\n  zero' ⦃X Y : C⦄ (f : X ⟶ Y) (hX : LE 0 X) (hY : GE 1 Y) : f = 0\n  LE_zero_le : LE 0 ≤ LE 1\n  GE_one_le : GE 1 ≤ GE 0\n  exists_triangle_zero_one (A : C) : ∃ (X Y : C) (_ : LE 0 X) (_ : GE 1 Y)\n    (f : X ⟶ A) (g : A ⟶ Y) (h : Y ⟶ X⟦(1 : ℤ)⟧), Triangle.mk f g h ∈ distTriang C\n\n"}
{"name":"CategoryTheory.Triangulated.TStructure.GE_shift","module":"Mathlib.CategoryTheory.Triangulated.TStructure.Basic","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nself : CategoryTheory.Triangulated.TStructure C\nn a n' : Int\nh : Eq (HAdd.hAdd a n') n\nX : C\nhX : self.GE n X\n⊢ self.GE n' ((CategoryTheory.shiftFunctor C a).obj X)","decl":"/-- `TStructure C` is the type of t-structures on the (pre)triangulated category `C`. -/\nstructure TStructure where\n  /-- the predicate of objects that are `≤ n` for `n : ℤ`. -/\n  LE (n : ℤ) : C → Prop\n  /-- the predicate of objects that are `≥ n` for `n : ℤ`. -/\n  GE (n : ℤ) : C → Prop\n  LE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (LE n) := by infer_instance\n  GE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (GE n) := by infer_instance\n  LE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : LE n X) : LE n' (X⟦a⟧)\n  GE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : GE n X) : GE n' (X⟦a⟧)\n  zero' ⦃X Y : C⦄ (f : X ⟶ Y) (hX : LE 0 X) (hY : GE 1 Y) : f = 0\n  LE_zero_le : LE 0 ≤ LE 1\n  GE_one_le : GE 1 ≤ GE 0\n  exists_triangle_zero_one (A : C) : ∃ (X Y : C) (_ : LE 0 X) (_ : GE 1 Y)\n    (f : X ⟶ A) (g : A ⟶ Y) (h : Y ⟶ X⟦(1 : ℤ)⟧), Triangle.mk f g h ∈ distTriang C\n\n"}
{"name":"CategoryTheory.Triangulated.TStructure.exists_triangle_zero_one","module":"Mathlib.CategoryTheory.Triangulated.TStructure.Basic","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nself : CategoryTheory.Triangulated.TStructure C\nA : C\n⊢ Exists fun X => Exists fun Y => Exists fun x => Exists fun x => Exists fun f => Exists fun g => Exists fun h => Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk f g h)","decl":"/-- `TStructure C` is the type of t-structures on the (pre)triangulated category `C`. -/\nstructure TStructure where\n  /-- the predicate of objects that are `≤ n` for `n : ℤ`. -/\n  LE (n : ℤ) : C → Prop\n  /-- the predicate of objects that are `≥ n` for `n : ℤ`. -/\n  GE (n : ℤ) : C → Prop\n  LE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (LE n) := by infer_instance\n  GE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (GE n) := by infer_instance\n  LE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : LE n X) : LE n' (X⟦a⟧)\n  GE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : GE n X) : GE n' (X⟦a⟧)\n  zero' ⦃X Y : C⦄ (f : X ⟶ Y) (hX : LE 0 X) (hY : GE 1 Y) : f = 0\n  LE_zero_le : LE 0 ≤ LE 1\n  GE_one_le : GE 1 ≤ GE 0\n  exists_triangle_zero_one (A : C) : ∃ (X Y : C) (_ : LE 0 X) (_ : GE 1 Y)\n    (f : X ⟶ A) (g : A ⟶ Y) (h : Y ⟶ X⟦(1 : ℤ)⟧), Triangle.mk f g h ∈ distTriang C\n\n"}
{"name":"CategoryTheory.Triangulated.TStructure.LE_shift","module":"Mathlib.CategoryTheory.Triangulated.TStructure.Basic","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nself : CategoryTheory.Triangulated.TStructure C\nn a n' : Int\nh : Eq (HAdd.hAdd a n') n\nX : C\nhX : self.LE n X\n⊢ self.LE n' ((CategoryTheory.shiftFunctor C a).obj X)","decl":"/-- `TStructure C` is the type of t-structures on the (pre)triangulated category `C`. -/\nstructure TStructure where\n  /-- the predicate of objects that are `≤ n` for `n : ℤ`. -/\n  LE (n : ℤ) : C → Prop\n  /-- the predicate of objects that are `≥ n` for `n : ℤ`. -/\n  GE (n : ℤ) : C → Prop\n  LE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (LE n) := by infer_instance\n  GE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (GE n) := by infer_instance\n  LE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : LE n X) : LE n' (X⟦a⟧)\n  GE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : GE n X) : GE n' (X⟦a⟧)\n  zero' ⦃X Y : C⦄ (f : X ⟶ Y) (hX : LE 0 X) (hY : GE 1 Y) : f = 0\n  LE_zero_le : LE 0 ≤ LE 1\n  GE_one_le : GE 1 ≤ GE 0\n  exists_triangle_zero_one (A : C) : ∃ (X Y : C) (_ : LE 0 X) (_ : GE 1 Y)\n    (f : X ⟶ A) (g : A ⟶ Y) (h : Y ⟶ X⟦(1 : ℤ)⟧), Triangle.mk f g h ∈ distTriang C\n\n"}
{"name":"CategoryTheory.Triangulated.TStructure.GE_closedUnderIsomorphisms","module":"Mathlib.CategoryTheory.Triangulated.TStructure.Basic","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nself : CategoryTheory.Triangulated.TStructure C\nn : Int\n⊢ CategoryTheory.ClosedUnderIsomorphisms (self.GE n)","decl":"/-- `TStructure C` is the type of t-structures on the (pre)triangulated category `C`. -/\nstructure TStructure where\n  /-- the predicate of objects that are `≤ n` for `n : ℤ`. -/\n  LE (n : ℤ) : C → Prop\n  /-- the predicate of objects that are `≥ n` for `n : ℤ`. -/\n  GE (n : ℤ) : C → Prop\n  LE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (LE n) := by infer_instance\n  GE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (GE n) := by infer_instance\n  LE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : LE n X) : LE n' (X⟦a⟧)\n  GE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : GE n X) : GE n' (X⟦a⟧)\n  zero' ⦃X Y : C⦄ (f : X ⟶ Y) (hX : LE 0 X) (hY : GE 1 Y) : f = 0\n  LE_zero_le : LE 0 ≤ LE 1\n  GE_one_le : GE 1 ≤ GE 0\n  exists_triangle_zero_one (A : C) : ∃ (X Y : C) (_ : LE 0 X) (_ : GE 1 Y)\n    (f : X ⟶ A) (g : A ⟶ Y) (h : Y ⟶ X⟦(1 : ℤ)⟧), Triangle.mk f g h ∈ distTriang C\n\n"}
{"name":"CategoryTheory.Triangulated.TStructure.LE_zero_le","module":"Mathlib.CategoryTheory.Triangulated.TStructure.Basic","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nself : CategoryTheory.Triangulated.TStructure C\n⊢ LE.le (self.LE 0) (self.LE 1)","decl":"/-- `TStructure C` is the type of t-structures on the (pre)triangulated category `C`. -/\nstructure TStructure where\n  /-- the predicate of objects that are `≤ n` for `n : ℤ`. -/\n  LE (n : ℤ) : C → Prop\n  /-- the predicate of objects that are `≥ n` for `n : ℤ`. -/\n  GE (n : ℤ) : C → Prop\n  LE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (LE n) := by infer_instance\n  GE_closedUnderIsomorphisms (n : ℤ) : ClosedUnderIsomorphisms (GE n) := by infer_instance\n  LE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : LE n X) : LE n' (X⟦a⟧)\n  GE_shift (n a n' : ℤ) (h : a + n' = n) (X : C) (hX : GE n X) : GE n' (X⟦a⟧)\n  zero' ⦃X Y : C⦄ (f : X ⟶ Y) (hX : LE 0 X) (hY : GE 1 Y) : f = 0\n  LE_zero_le : LE 0 ≤ LE 1\n  GE_one_le : GE 1 ≤ GE 0\n  exists_triangle_zero_one (A : C) : ∃ (X Y : C) (_ : LE 0 X) (_ : GE 1 Y)\n    (f : X ⟶ A) (g : A ⟶ Y) (h : Y ⟶ X⟦(1 : ℤ)⟧), Triangle.mk f g h ∈ distTriang C\n\n"}
{"name":"CategoryTheory.Triangulated.TStructure.exists_triangle","module":"Mathlib.CategoryTheory.Triangulated.TStructure.Basic","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nt : CategoryTheory.Triangulated.TStructure C\nA : C\nn₀ n₁ : Int\nh : Eq (HAdd.hAdd n₀ 1) n₁\n⊢ Exists fun X => Exists fun Y => Exists fun x => Exists fun x => Exists fun f => Exists fun g => Exists fun h => Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles (CategoryTheory.Pretriangulated.Triangle.mk f g h)","decl":"lemma exists_triangle (A : C) (n₀ n₁ : ℤ) (h : n₀ + 1 = n₁) :\n    ∃ (X Y : C) (_ : t.LE n₀ X) (_ : t.GE n₁ Y) (f : X ⟶ A) (g : A ⟶ Y)\n      (h : Y ⟶ X⟦(1 : ℤ)⟧), Triangle.mk f g h ∈ distTriang C := by\n  obtain ⟨X, Y, hX, hY, f, g, h, mem⟩ := t.exists_triangle_zero_one (A⟦n₀⟧)\n  let T := (Triangle.shiftFunctor C (-n₀)).obj (Triangle.mk f g h)\n  let e := (shiftEquiv C n₀).unitIso.symm.app A\n  have hT' : Triangle.mk (T.mor₁ ≫ e.hom) (e.inv ≫ T.mor₂) T.mor₃ ∈ distTriang C := by\n    refine isomorphic_distinguished _ (Triangle.shift_distinguished _ mem (-n₀)) _ ?_\n    refine Triangle.isoMk _ _ (Iso.refl _) e.symm (Iso.refl _) ?_ ?_ ?_\n    all_goals dsimp; simp [T]\n  exact ⟨_, _, t.LE_shift _ _ _ (neg_add_cancel n₀) _ hX,\n    t.GE_shift _ _ _ (by omega) _ hY, _, _, _, hT'⟩\n\n"}
{"name":"CategoryTheory.Triangulated.TStructure.predicateShift_LE","module":"Mathlib.CategoryTheory.Triangulated.TStructure.Basic","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nt : CategoryTheory.Triangulated.TStructure C\na n n' : Int\nhn' : Eq (HAdd.hAdd a n) n'\n⊢ Eq (CategoryTheory.PredicateShift (t.LE n) a) (t.LE n')","decl":"lemma predicateShift_LE (a n n' : ℤ) (hn' : a + n = n') :\n    (PredicateShift (t.LE n) a) = t.LE n' := by\n  ext X\n  constructor\n  · intro hX\n    exact (mem_iff_of_iso (LE t n') ((shiftEquiv C a).unitIso.symm.app X)).1\n      (t.LE_shift n (-a) n' (by omega) _ hX)\n  · intro hX\n    exact t.LE_shift _ _ _ hn' X hX\n\n"}
{"name":"CategoryTheory.Triangulated.TStructure.predicateShift_GE","module":"Mathlib.CategoryTheory.Triangulated.TStructure.Basic","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nt : CategoryTheory.Triangulated.TStructure C\na n n' : Int\nhn' : Eq (HAdd.hAdd a n) n'\n⊢ Eq (CategoryTheory.PredicateShift (t.GE n) a) (t.GE n')","decl":"lemma predicateShift_GE (a n n' : ℤ) (hn' : a + n = n') :\n    (PredicateShift (t.GE n) a) = t.GE n' := by\n  ext X\n  constructor\n  · intro hX\n    exact (mem_iff_of_iso (GE t n') ((shiftEquiv C a).unitIso.symm.app X)).1\n      (t.GE_shift n (-a) n' (by omega) _ hX)\n  · intro hX\n    exact t.GE_shift _ _ _ hn' X hX\n\n"}
{"name":"CategoryTheory.Triangulated.TStructure.LE_monotone","module":"Mathlib.CategoryTheory.Triangulated.TStructure.Basic","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nt : CategoryTheory.Triangulated.TStructure C\n⊢ Monotone t.LE","decl":"lemma LE_monotone : Monotone t.LE := by\n  let H := fun (a : ℕ) => ∀ (n : ℤ), t.LE n ≤ t.LE (n + a)\n  suffices ∀ (a : ℕ), H a by\n    intro n₀ n₁ h\n    obtain ⟨a, ha⟩ := Int.nonneg_def.1 h\n    obtain rfl : n₁ = n₀ + a := by omega\n    apply this\n  have H_zero : H 0 := fun n => by\n    simp only [Nat.cast_zero, add_zero]\n    rfl\n  have H_one : H 1 := fun n X hX => by\n    rw [← t.predicateShift_LE n 1 (n + (1 : ℕ)) rfl, predicateShift_iff]\n    rw [← t.predicateShift_LE n 0 n (add_zero n), predicateShift_iff] at hX\n    exact t.LE_zero_le _ hX\n  have H_add : ∀ (a b c : ℕ) (_ : a + b = c) (_ : H a) (_ : H b), H c := by\n    intro a b c h ha hb n\n    rw [← h, Nat.cast_add, ← add_assoc]\n    exact (ha n).trans (hb (n+a))\n  intro a\n  induction' a with a ha\n  · exact H_zero\n  · exact H_add a 1 _ rfl ha H_one\n\n"}
{"name":"CategoryTheory.Triangulated.TStructure.GE_antitone","module":"Mathlib.CategoryTheory.Triangulated.TStructure.Basic","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nt : CategoryTheory.Triangulated.TStructure C\n⊢ Antitone t.GE","decl":"lemma GE_antitone : Antitone t.GE := by\n  let H := fun (a : ℕ) => ∀ (n : ℤ), t.GE (n + a) ≤ t.GE n\n  suffices ∀ (a : ℕ), H a by\n    intro n₀ n₁ h\n    obtain ⟨a, ha⟩ := Int.nonneg_def.1 h\n    obtain rfl : n₁ = n₀ + a := by omega\n    apply this\n  have H_zero : H 0 := fun n => by\n    simp only [Nat.cast_zero, add_zero]\n    rfl\n  have H_one : H 1 := fun n X hX => by\n    rw [← t.predicateShift_GE n 1 (n + (1 : ℕ)) (by simp), predicateShift_iff] at hX\n    rw [← t.predicateShift_GE n 0 n (add_zero n)]\n    exact t.GE_one_le _ hX\n  have H_add : ∀ (a b c : ℕ) (_ : a + b = c) (_ : H a) (_ : H b), H c := by\n    intro a b c h ha hb n\n    rw [← h, Nat.cast_add, ← add_assoc ]\n    exact (hb (n + a)).trans (ha n)\n  intro a\n  induction' a with a ha\n  · exact H_zero\n  · exact H_add a 1 _ rfl ha H_one\n\n"}
{"name":"CategoryTheory.Triangulated.TStructure.IsLE.le","module":"Mathlib.CategoryTheory.Triangulated.TStructure.Basic","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nt : CategoryTheory.Triangulated.TStructure C\nX : C\nn : Int\nself : t.IsLE X n\n⊢ t.LE n X","decl":"/-- Given a t-structure `t` on a pretriangulated category `C`, the property `t.IsLE X n`\nholds if `X : C` is `≤ n` for the t-structure. -/\nclass IsLE (X : C) (n : ℤ) : Prop where\n  le : t.LE n X\n\n"}
{"name":"CategoryTheory.Triangulated.TStructure.IsGE.ge","module":"Mathlib.CategoryTheory.Triangulated.TStructure.Basic","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nt : CategoryTheory.Triangulated.TStructure C\nX : C\nn : Int\nself : t.IsGE X n\n⊢ t.GE n X","decl":"/-- Given a t-structure `t` on a pretriangulated category `C`, the property `t.IsGE X n`\nholds if `X : C` is `≥ n` for the t-structure. -/\nclass IsGE (X : C) (n : ℤ) : Prop where\n  ge : t.GE n X\n\n"}
{"name":"CategoryTheory.Triangulated.TStructure.mem_of_isLE","module":"Mathlib.CategoryTheory.Triangulated.TStructure.Basic","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝¹ : CategoryTheory.Pretriangulated C\nt : CategoryTheory.Triangulated.TStructure C\nX : C\nn : Int\ninst✝ : t.IsLE X n\n⊢ t.LE n X","decl":"lemma mem_of_isLE (X : C) (n : ℤ) [t.IsLE X n] : t.LE n X := IsLE.le\n\n"}
{"name":"CategoryTheory.Triangulated.TStructure.mem_of_isGE","module":"Mathlib.CategoryTheory.Triangulated.TStructure.Basic","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝¹ : CategoryTheory.Pretriangulated C\nt : CategoryTheory.Triangulated.TStructure C\nX : C\nn : Int\ninst✝ : t.IsGE X n\n⊢ t.GE n X","decl":"lemma mem_of_isGE (X : C) (n : ℤ) [t.IsGE X n] : t.GE n X := IsGE.ge\n\n"}
