{"name":"IntermediateField.mem_adjoin_range_iff","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nι : Type u_3\ni : ι → E\nx : E\n⊢ Iff (Membership.mem (IntermediateField.adjoin F (Set.range i)) x) (Exists fun r => Exists fun s => Eq x (HDiv.hDiv ((MvPolynomial.aeval i) r) ((MvPolynomial.aeval i) s)))","decl":"theorem mem_adjoin_range_iff {ι : Type*} (i : ι → E) (x : E) :\n    x ∈ adjoin F (Set.range i) ↔ ∃ r s : MvPolynomial ι F,\n      x = MvPolynomial.aeval i r / MvPolynomial.aeval i s := by\n  simp_rw [adjoin, mem_mk, Subring.mem_toSubsemiring, Subfield.mem_toSubring,\n    Subfield.mem_closure_iff, ← Algebra.adjoin_eq_ring_closure, Subalgebra.mem_toSubring,\n    Algebra.adjoin_range_eq_range_aeval, AlgHom.mem_range, exists_exists_eq_and]\n  tauto\n\n"}
{"name":"IntermediateField.mem_adjoin_iff","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nS : Set E\nx : E\n⊢ Iff (Membership.mem (IntermediateField.adjoin F S) x) (Exists fun r => Exists fun s => Eq x (HDiv.hDiv ((MvPolynomial.aeval Subtype.val) r) ((MvPolynomial.aeval Subtype.val) s)))","decl":"theorem mem_adjoin_iff (x : E) :\n    x ∈ adjoin F S ↔ ∃ r s : MvPolynomial S F,\n      x = MvPolynomial.aeval Subtype.val r / MvPolynomial.aeval Subtype.val s := by\n  rw [← mem_adjoin_range_iff, Subtype.range_coe]\n\n"}
{"name":"IntermediateField.mem_adjoin_simple_iff","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nα x : E\n⊢ Iff (Membership.mem (IntermediateField.adjoin F (Singleton.singleton α)) x) (Exists fun r => Exists fun s => Eq x (HDiv.hDiv ((Polynomial.aeval α) r) ((Polynomial.aeval α) s)))","decl":"theorem mem_adjoin_simple_iff {α : E} (x : E) :\n    x ∈ adjoin F {α} ↔ ∃ r s : F[X], x = aeval α r / aeval α s := by\n  simp only [adjoin, mem_mk, Subring.mem_toSubsemiring, Subfield.mem_toSubring,\n    Subfield.mem_closure_iff, ← Algebra.adjoin_eq_ring_closure, Subalgebra.mem_toSubring,\n    Algebra.adjoin_singleton_eq_range_aeval, AlgHom.mem_range, exists_exists_eq_and]\n  tauto\n\n"}
{"name":"IntermediateField.finiteDimensional_sup","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_3\nL : Type u_4\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\nE1 E2 : IntermediateField K L\ninst✝¹ : FiniteDimensional K (Subtype fun x => Membership.mem E1 x)\ninst✝ : FiniteDimensional K (Subtype fun x => Membership.mem E2 x)\n⊢ FiniteDimensional K (Subtype fun x => Membership.mem (Max.max E1 E2) x)","decl":"instance finiteDimensional_sup [FiniteDimensional K E1] [FiniteDimensional K E2] :\n    FiniteDimensional K (E1 ⊔ E2 : IntermediateField K L) := by\n  let g := Algebra.TensorProduct.productMap E1.val E2.val\n  suffices g.range = (E1 ⊔ E2).toSubalgebra by\n    have h : FiniteDimensional K (Subalgebra.toSubmodule g.range) :=\n      g.toLinearMap.finiteDimensional_range\n    rwa [this] at h\n  rw [Algebra.TensorProduct.productMap_range, E1.range_val, E2.range_val, sup_toSubalgebra_of_left]\n\n"}
{"name":"IntermediateField.rank_sup_le_of_isAlgebraic","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_3\nL : Type u_4\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nE1 E2 : IntermediateField K L\nhalg : Or (Algebra.IsAlgebraic K (Subtype fun x => Membership.mem E1 x)) (Algebra.IsAlgebraic K (Subtype fun x => Membership.mem E2 x))\n⊢ LE.le (Module.rank K (Subtype fun x => Membership.mem (Max.max E1 E2) x)) (HMul.hMul (Module.rank K (Subtype fun x => Membership.mem E1 x)) (Module.rank K (Subtype fun x => Membership.mem E2 x)))","decl":"/-- If `E1` and `E2` are intermediate fields, and at least one them are algebraic, then the rank of\nthe compositum of `E1` and `E2` is less than or equal to the product of that of `E1` and `E2`.\nNote that this result is also true without algebraic assumption,\nbut the proof becomes very complicated. -/\ntheorem rank_sup_le_of_isAlgebraic\n    (halg : Algebra.IsAlgebraic K E1 ∨ Algebra.IsAlgebraic K E2) :\n    Module.rank K ↥(E1 ⊔ E2) ≤ Module.rank K E1 * Module.rank K E2 := by\n  have := E1.toSubalgebra.rank_sup_le_of_free E2.toSubalgebra\n  rwa [← sup_toSubalgebra_of_isAlgebraic E1 E2 halg] at this\n\n"}
{"name":"IntermediateField.finrank_sup_le","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_3\nL : Type u_4\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nE1 E2 : IntermediateField K L\n⊢ LE.le (Module.finrank K (Subtype fun x => Membership.mem (Max.max E1 E2) x)) (HMul.hMul (Module.finrank K (Subtype fun x => Membership.mem E1 x)) (Module.finrank K (Subtype fun x => Membership.mem E2 x)))","decl":"/-- If `E1` and `E2` are intermediate fields, then the `Module.finrank` of\nthe compositum of `E1` and `E2` is less than or equal to the product of that of `E1` and `E2`. -/\ntheorem finrank_sup_le :\n    finrank K ↥(E1 ⊔ E2) ≤ finrank K E1 * finrank K E2 := by\n  by_cases h : FiniteDimensional K E1\n  · have := E1.toSubalgebra.finrank_sup_le_of_free E2.toSubalgebra\n    change _ ≤ finrank K E1 * finrank K E2 at this\n    rwa [← sup_toSubalgebra_of_left] at this\n  rw [FiniteDimensional, ← rank_lt_aleph0_iff, not_lt] at h\n  have := LinearMap.rank_le_of_injective _ <| Submodule.inclusion_injective <|\n    show Subalgebra.toSubmodule E1.toSubalgebra ≤ Subalgebra.toSubmodule (E1 ⊔ E2).toSubalgebra by\n      simp\n  rw [show finrank K E1 = 0 from Cardinal.toNat_apply_of_aleph0_le h,\n    show finrank K ↥(E1 ⊔ E2) = 0 from Cardinal.toNat_apply_of_aleph0_le (h.trans this), zero_mul]\n\n"}
{"name":"IntermediateField.coe_iSup_of_directed","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_3\nL : Type u_4\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\nι : Type u_5\nt : ι → IntermediateField K L\ninst✝ : Nonempty ι\ndir : Directed (fun x1 x2 => LE.le x1 x2) t\n⊢ Eq (↑(iSup t)) (Set.iUnion fun i => ↑(t i))","decl":"theorem coe_iSup_of_directed [Nonempty ι] (dir : Directed (· ≤ ·) t) :\n    ↑(iSup t) = ⋃ i, (t i : Set L) :=\n  let M : IntermediateField K L :=\n    { __ := Subalgebra.copy _ _ (Subalgebra.coe_iSup_of_directed dir).symm\n      inv_mem' := fun _ hx ↦ have ⟨i, hi⟩ := Set.mem_iUnion.mp hx\n        Set.mem_iUnion.mpr ⟨i, (t i).inv_mem hi⟩ }\n  have : iSup t = M := le_antisymm\n    (iSup_le fun i ↦ le_iSup (fun i ↦ (t i : Set L)) i) (Set.iUnion_subset fun _ ↦ le_iSup t _)\n  this.symm ▸ rfl\n\n"}
{"name":"IntermediateField.toSubalgebra_iSup_of_directed","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_3\nL : Type u_4\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nι : Type u_5\nt : ι → IntermediateField K L\ndir : Directed (fun x1 x2 => LE.le x1 x2) t\n⊢ Eq (iSup t).toSubalgebra (iSup fun i => (t i).toSubalgebra)","decl":"theorem toSubalgebra_iSup_of_directed (dir : Directed (· ≤ ·) t) :\n    (iSup t).toSubalgebra = ⨆ i, (t i).toSubalgebra := by\n  cases isEmpty_or_nonempty ι\n  · simp_rw [iSup_of_empty, bot_toSubalgebra]\n  · exact SetLike.ext' ((coe_iSup_of_directed dir).trans (Subalgebra.coe_iSup_of_directed dir).symm)\n\n"}
{"name":"IntermediateField.finiteDimensional_iSup_of_finite","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_3\nL : Type u_4\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\nι : Type u_5\nt : ι → IntermediateField K L\nh : Finite ι\ninst✝ : ∀ (i : ι), FiniteDimensional K (Subtype fun x => Membership.mem (t i) x)\n⊢ FiniteDimensional K (Subtype fun x => Membership.mem (iSup fun i => t i) x)","decl":"instance finiteDimensional_iSup_of_finite [h : Finite ι] [∀ i, FiniteDimensional K (t i)] :\n    FiniteDimensional K (⨆ i, t i : IntermediateField K L) := by\n  rw [← iSup_univ]\n  refine Set.Finite.induction_on\n    (motive := fun s _ => FiniteDimensional K (⨆ i ∈ s, t i : IntermediateField K L))\n    _ Set.finite_univ ?_ ?_\n  all_goals dsimp\n  · rw [iSup_emptyset]\n    exact (botEquiv K L).symm.toLinearEquiv.finiteDimensional\n  · intro _ s _ _ hs\n    rw [iSup_insert]\n    exact IntermediateField.finiteDimensional_sup _ _\n\n"}
{"name":"IntermediateField.finiteDimensional_iSup_of_finset","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_3\nL : Type u_4\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\nι : Type u_5\nt : ι → IntermediateField K L\ns : Finset ι\ninst✝ : ∀ (i : ι), FiniteDimensional K (Subtype fun x => Membership.mem (t i) x)\n⊢ FiniteDimensional K (Subtype fun x => Membership.mem (iSup fun i => iSup fun h => t i) x)","decl":"instance finiteDimensional_iSup_of_finset\n    /- Porting note: changed `h` from `∀ i ∈ s, FiniteDimensional K (t i)` because this caused an\n      error. See `finiteDimensional_iSup_of_finset'` for a stronger version, that was the one\n      used in mathlib3. -/\n    {s : Finset ι} [∀ i, FiniteDimensional K (t i)] :\n    FiniteDimensional K (⨆ i ∈ s, t i : IntermediateField K L) :=\n  iSup_subtype'' s t ▸ IntermediateField.finiteDimensional_iSup_of_finite\n\n"}
{"name":"IntermediateField.finiteDimensional_iSup_of_finset'","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_3\nL : Type u_4\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nι : Type u_5\nt : ι → IntermediateField K L\ns : Finset ι\nh : ∀ (i : ι), Membership.mem s i → FiniteDimensional K (Subtype fun x => Membership.mem (t i) x)\n⊢ FiniteDimensional K (Subtype fun x => Membership.mem (iSup fun i => iSup fun h => t i) x)","decl":"theorem finiteDimensional_iSup_of_finset'\n    /- Porting note: this was the mathlib3 version. Using `[h : ...]`, as in mathlib3, causes the\n    error \"invalid parametric local instance\". -/\n    {s : Finset ι} (h : ∀ i ∈ s, FiniteDimensional K (t i)) :\n    FiniteDimensional K (⨆ i ∈ s, t i : IntermediateField K L) :=\n  have := Subtype.forall'.mp h\n  iSup_subtype'' s t ▸ IntermediateField.finiteDimensional_iSup_of_finite\n\n"}
{"name":"IntermediateField.isSplittingField_iSup","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_3\nL : Type u_4\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nι : Type u_5\nt : ι → IntermediateField K L\np : ι → Polynomial K\ns : Finset ι\nh0 : Ne (s.prod fun i => p i) 0\nh : ∀ (i : ι), Membership.mem s i → Polynomial.IsSplittingField K (Subtype fun x => Membership.mem (t i) x) (p i)\n⊢ Polynomial.IsSplittingField K (Subtype fun x => Membership.mem (iSup fun i => iSup fun h => t i) x) (s.prod fun i => p i)","decl":"/-- A compositum of splitting fields is a splitting field -/\ntheorem isSplittingField_iSup {p : ι → K[X]}\n    {s : Finset ι} (h0 : ∏ i ∈ s, p i ≠ 0) (h : ∀ i ∈ s, (p i).IsSplittingField K (t i)) :\n    (∏ i ∈ s, p i).IsSplittingField K (⨆ i ∈ s, t i : IntermediateField K L) := by\n  let F : IntermediateField K L := ⨆ i ∈ s, t i\n  have hF : ∀ i ∈ s, t i ≤ F := fun i hi ↦ le_iSup_of_le i (le_iSup (fun _ ↦ t i) hi)\n  simp only [isSplittingField_iff] at h ⊢\n  refine\n    ⟨splits_prod (algebraMap K F) fun i hi ↦\n        splits_comp_of_splits (algebraMap K (t i)) (inclusion (hF i hi)).toRingHom\n          (h i hi).1,\n      ?_⟩\n  simp only [rootSet_prod p s h0, ← Set.iSup_eq_iUnion, (@gc K _ L _ _).l_iSup₂]\n  exact iSup_congr fun i ↦ iSup_congr fun hi ↦ (h i hi).2\n\n"}
{"name":"IntermediateField.adjoin_rank_le_of_isAlgebraic","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝⁶ : Field F\nE : Type u_2\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type u_3\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\nL : IntermediateField F K\nhalg : Or (Algebra.IsAlgebraic F E) (Algebra.IsAlgebraic F (Subtype fun x => Membership.mem L x))\n⊢ LE.le (Module.rank E (Subtype fun x => Membership.mem (IntermediateField.adjoin E ↑L) x)) (Module.rank F (Subtype fun x => Membership.mem L x))","decl":"/-- If `K / E / F` is a field extension tower, `L` is an intermediate field of `K / F`, such that\neither `E / F` or `L / F` is algebraic, then `[E(L) : E] ≤ [L : F]`. A corollary of\n`Subalgebra.adjoin_rank_le` since in this case `E(L) = E[L]`. -/\ntheorem adjoin_rank_le_of_isAlgebraic (L : IntermediateField F K)\n    (halg : Algebra.IsAlgebraic F E ∨ Algebra.IsAlgebraic F L) :\n    Module.rank E (adjoin E (L : Set K)) ≤ Module.rank F L := by\n  have h : (adjoin E (L.toSubalgebra : Set K)).toSubalgebra =\n      Algebra.adjoin E (L.toSubalgebra : Set K) :=\n    L.adjoin_toSubalgebra_of_isAlgebraic E halg\n  have := L.toSubalgebra.adjoin_rank_le E\n  rwa [(Subalgebra.equivOfEq _ _ h).symm.toLinearEquiv.rank_eq] at this\n\n"}
{"name":"IntermediateField.adjoin_rank_le_of_isAlgebraic_left","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝⁶ : Field F\nE : Type u_2\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type u_3\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\nL : IntermediateField F K\nhalg : Algebra.IsAlgebraic F E\n⊢ LE.le (Module.rank E (Subtype fun x => Membership.mem (IntermediateField.adjoin E ↑L) x)) (Module.rank F (Subtype fun x => Membership.mem L x))","decl":"theorem adjoin_rank_le_of_isAlgebraic_left (L : IntermediateField F K)\n    [halg : Algebra.IsAlgebraic F E] :\n    Module.rank E (adjoin E (L : Set K)) ≤ Module.rank F L :=\n  adjoin_rank_le_of_isAlgebraic E L (Or.inl halg)\n\n"}
{"name":"IntermediateField.adjoin_rank_le_of_isAlgebraic_right","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝⁶ : Field F\nE : Type u_2\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type u_3\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\nL : IntermediateField F K\nhalg : Algebra.IsAlgebraic F (Subtype fun x => Membership.mem L x)\n⊢ LE.le (Module.rank E (Subtype fun x => Membership.mem (IntermediateField.adjoin E ↑L) x)) (Module.rank F (Subtype fun x => Membership.mem L x))","decl":"theorem adjoin_rank_le_of_isAlgebraic_right (L : IntermediateField F K)\n    [halg : Algebra.IsAlgebraic F L] :\n    Module.rank E (adjoin E (L : Set K)) ≤ Module.rank F L :=\n  adjoin_rank_le_of_isAlgebraic E L (Or.inr halg)\n\n"}
{"name":"IntermediateField.adjoin_simple_isCompactElement","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nx : E\n⊢ CompleteLattice.IsCompactElement (IntermediateField.adjoin F (Singleton.singleton x))","decl":"/-- Adjoining a single element is compact in the lattice of intermediate fields. -/\ntheorem adjoin_simple_isCompactElement (x : E) : IsCompactElement F⟮x⟯ := by\n  simp_rw [isCompactElement_iff_le_of_directed_sSup_le,\n    adjoin_simple_le_iff, sSup_eq_iSup', ← exists_prop]\n  intro s hne hs hx\n  have := hne.to_subtype\n  rwa [← SetLike.mem_coe, coe_iSup_of_directed hs.directed_val, mem_iUnion, Subtype.exists] at hx\n\n-- Porting note: original proof times out.\n"}
{"name":"IntermediateField.adjoin_finset_isCompactElement","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nS : Finset E\n⊢ CompleteLattice.IsCompactElement (IntermediateField.adjoin F ↑S)","decl":"/-- Adjoining a finite subset is compact in the lattice of intermediate fields. -/\ntheorem adjoin_finset_isCompactElement (S : Finset E) :\n    IsCompactElement (adjoin F S : IntermediateField F E) := by\n  rw [← biSup_adjoin_simple]\n  simp_rw [Finset.mem_coe, ← Finset.sup_eq_iSup]\n  exact isCompactElement_finsetSup S fun x _ => adjoin_simple_isCompactElement x\n\n"}
{"name":"IntermediateField.adjoin_finite_isCompactElement","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nS : Set E\nh : S.Finite\n⊢ CompleteLattice.IsCompactElement (IntermediateField.adjoin F S)","decl":"/-- Adjoining a finite subset is compact in the lattice of intermediate fields. -/\ntheorem adjoin_finite_isCompactElement {S : Set E} (h : S.Finite) : IsCompactElement (adjoin F S) :=\n  Finite.coe_toFinset h ▸ adjoin_finset_isCompactElement h.toFinset\n\n"}
{"name":"IntermediateField.instIsCompactlyGenerated","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ IsCompactlyGenerated (IntermediateField F E)","decl":"/-- The lattice of intermediate fields is compactly generated. -/\ninstance : IsCompactlyGenerated (IntermediateField F E) :=\n  ⟨fun s =>\n    ⟨(fun x => F⟮x⟯) '' s,\n      ⟨by rintro t ⟨x, _, rfl⟩; exact adjoin_simple_isCompactElement x,\n        sSup_image.trans <| (biSup_adjoin_simple _).trans <|\n          le_antisymm (adjoin_le_iff.mpr le_rfl) <| subset_adjoin F (s : Set E)⟩⟩⟩\n\n"}
{"name":"IntermediateField.exists_finset_of_mem_iSup","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nι : Type u_3\nf : ι → IntermediateField F E\nx : E\nhx : Membership.mem (iSup fun i => f i) x\n⊢ Exists fun s => Membership.mem (iSup fun i => iSup fun h => f i) x","decl":"theorem exists_finset_of_mem_iSup {ι : Type*} {f : ι → IntermediateField F E} {x : E}\n    (hx : x ∈ ⨆ i, f i) : ∃ s : Finset ι, x ∈ ⨆ i ∈ s, f i := by\n  have := (adjoin_simple_isCompactElement x).exists_finset_of_le_iSup (IntermediateField F E) f\n  simp only [adjoin_simple_le_iff] at this\n  exact this hx\n\n"}
{"name":"IntermediateField.exists_finset_of_mem_supr'","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nι : Type u_3\nf : ι → IntermediateField F E\nx : E\nhx : Membership.mem (iSup fun i => f i) x\n⊢ Exists fun s => Membership.mem (iSup fun i => iSup fun h => IntermediateField.adjoin F (Singleton.singleton ↑i.snd)) x","decl":"theorem exists_finset_of_mem_supr' {ι : Type*} {f : ι → IntermediateField F E} {x : E}\n    (hx : x ∈ ⨆ i, f i) : ∃ s : Finset (Σ i, f i), x ∈ ⨆ i ∈ s, F⟮(i.2 : E)⟯ := by\n-- Porting note: writing `fun i x h => ...` does not work.\n  refine exists_finset_of_mem_iSup (SetLike.le_def.mp (iSup_le fun i ↦ ?_) hx)\n  exact fun x h ↦ SetLike.le_def.mp (le_iSup_of_le ⟨i, x, h⟩ (by simp)) (mem_adjoin_simple_self F x)\n\n"}
{"name":"IntermediateField.exists_finset_of_mem_supr''","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nι : Type u_3\nf : ι → IntermediateField F E\nh : ∀ (i : ι), Algebra.IsAlgebraic F (Subtype fun x => Membership.mem (f i) x)\nx : E\nhx : Membership.mem (iSup fun i => f i) x\n⊢ Exists fun s => Membership.mem (iSup fun i => iSup fun h => IntermediateField.adjoin F ((minpoly F i.snd).rootSet E)) x","decl":"theorem exists_finset_of_mem_supr'' {ι : Type*} {f : ι → IntermediateField F E}\n    (h : ∀ i, Algebra.IsAlgebraic F (f i)) {x : E} (hx : x ∈ ⨆ i, f i) :\n    ∃ s : Finset (Σ i, f i), x ∈ ⨆ i ∈ s, adjoin F ((minpoly F (i.2 :)).rootSet E) := by\n-- Porting note: writing `fun i x1 hx1 => ...` does not work.\n  refine exists_finset_of_mem_iSup (SetLike.le_def.mp (iSup_le (fun i => ?_)) hx)\n  intro x1 hx1\n  refine SetLike.le_def.mp (le_iSup_of_le ⟨i, x1, hx1⟩ ?_)\n    (subset_adjoin F (rootSet (minpoly F x1) E) ?_)\n  · rw [IntermediateField.minpoly_eq, Subtype.coe_mk]\n  · rw [mem_rootSet_of_ne, minpoly.aeval]\n    exact minpoly.ne_zero (isIntegral_iff.mp (Algebra.IsIntegral.isIntegral (⟨x1, hx1⟩ : f i)))\n\n"}
{"name":"IntermediateField.exists_finset_of_mem_adjoin","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nS : Set E\nx : E\nhx : Membership.mem (IntermediateField.adjoin F S) x\n⊢ Exists fun T => And (HasSubset.Subset (↑T) S) (Membership.mem (IntermediateField.adjoin F ↑T) x)","decl":"theorem exists_finset_of_mem_adjoin {S : Set E} {x : E} (hx : x ∈ adjoin F S) :\n    ∃ T : Finset E, (T : Set E) ⊆ S ∧ x ∈ adjoin F (T : Set E) := by\n  simp_rw [← biSup_adjoin_simple S, ← iSup_subtype''] at hx\n  obtain ⟨s, hx'⟩ := exists_finset_of_mem_iSup hx\n  classical\n  refine ⟨s.image Subtype.val, by simp, SetLike.le_def.mp ?_ hx'⟩\n  simp_rw [Finset.coe_image, iSup_le_iff, adjoin_le_iff]\n  rintro _ h _ rfl\n  exact subset_adjoin F _ ⟨_, h, rfl⟩\n\n"}
{"name":"IntermediateField.rank_eq_one_iff","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nK : IntermediateField F E\n⊢ Iff (Eq (Module.rank F (Subtype fun x => Membership.mem K x)) 1) (Eq K Bot.bot)","decl":"@[simp]\ntheorem rank_eq_one_iff : Module.rank F K = 1 ↔ K = ⊥ := by\n  rw [← toSubalgebra_inj, ← rank_eq_rank_subalgebra, Subalgebra.rank_eq_one_iff,\n    bot_toSubalgebra]\n\n"}
{"name":"IntermediateField.finrank_eq_one_iff","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nK : IntermediateField F E\n⊢ Iff (Eq (Module.finrank F (Subtype fun x => Membership.mem K x)) 1) (Eq K Bot.bot)","decl":"@[simp]\ntheorem finrank_eq_one_iff : finrank F K = 1 ↔ K = ⊥ := by\n  rw [← toSubalgebra_inj, ← finrank_eq_finrank_subalgebra, Subalgebra.finrank_eq_one_iff,\n    bot_toSubalgebra]\n\n"}
{"name":"IntermediateField.rank_bot","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (Module.rank F (Subtype fun x => Membership.mem Bot.bot x)) 1","decl":"@[simp]\nprotected theorem rank_bot : Module.rank F (⊥ : IntermediateField F E) = 1 := by\n  rw [rank_eq_one_iff]\n\n"}
{"name":"IntermediateField.finrank_bot","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (Module.finrank F (Subtype fun x => Membership.mem Bot.bot x)) 1","decl":"@[simp]\nprotected theorem finrank_bot : finrank F (⊥ : IntermediateField F E) = 1 := by\n  rw [finrank_eq_one_iff]\n\n"}
{"name":"IntermediateField.rank_bot'","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (Module.rank (Subtype fun x => Membership.mem Bot.bot x) E) (Module.rank F E)","decl":"@[simp] theorem rank_bot' : Module.rank (⊥ : IntermediateField F E) E = Module.rank F E := by\n  rw [← rank_mul_rank F (⊥ : IntermediateField F E) E, IntermediateField.rank_bot, one_mul]\n\n"}
{"name":"IntermediateField.finrank_bot'","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (Module.finrank (Subtype fun x => Membership.mem Bot.bot x) E) (Module.finrank F E)","decl":"@[simp] theorem finrank_bot' : finrank (⊥ : IntermediateField F E) E = finrank F E :=\n  congr(Cardinal.toNat $(rank_bot'))\n\n"}
{"name":"IntermediateField.rank_top","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (Module.rank (Subtype fun x => Membership.mem Top.top x) E) 1","decl":"@[simp] protected theorem rank_top : Module.rank (⊤ : IntermediateField F E) E = 1 :=\n  Subalgebra.bot_eq_top_iff_rank_eq_one.mp <| top_le_iff.mp fun x _ ↦ ⟨⟨x, trivial⟩, rfl⟩\n\n"}
{"name":"IntermediateField.finrank_top","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (Module.finrank (Subtype fun x => Membership.mem Top.top x) E) 1","decl":"@[simp] protected theorem finrank_top : finrank (⊤ : IntermediateField F E) E = 1 :=\n  rank_eq_one_iff_finrank_eq_one.mp IntermediateField.rank_top\n\n"}
{"name":"IntermediateField.rank_top'","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (Module.rank F (Subtype fun x => Membership.mem Top.top x)) (Module.rank F E)","decl":"@[simp] theorem rank_top' : Module.rank F (⊤ : IntermediateField F E) = Module.rank F E :=\n  rank_top F E\n\n"}
{"name":"IntermediateField.finrank_top'","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (Module.finrank F (Subtype fun x => Membership.mem Top.top x)) (Module.finrank F E)","decl":"@[simp] theorem finrank_top' : finrank F (⊤ : IntermediateField F E) = finrank F E :=\n  finrank_top F E\n\n"}
{"name":"IntermediateField.rank_adjoin_eq_one_iff","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nS : Set E\n⊢ Iff (Eq (Module.rank F (Subtype fun x => Membership.mem (IntermediateField.adjoin F S) x)) 1) (HasSubset.Subset S ↑Bot.bot)","decl":"theorem rank_adjoin_eq_one_iff : Module.rank F (adjoin F S) = 1 ↔ S ⊆ (⊥ : IntermediateField F E) :=\n  Iff.trans rank_eq_one_iff adjoin_eq_bot_iff\n\n"}
{"name":"IntermediateField.rank_adjoin_simple_eq_one_iff","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nα : E\n⊢ Iff (Eq (Module.rank F (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Singleton.singleton α)) x)) 1) (Membership.mem Bot.bot α)","decl":"theorem rank_adjoin_simple_eq_one_iff :\n    Module.rank F F⟮α⟯ = 1 ↔ α ∈ (⊥ : IntermediateField F E) := by\n  rw [rank_adjoin_eq_one_iff]; exact Set.singleton_subset_iff\n\n"}
{"name":"IntermediateField.finrank_adjoin_eq_one_iff","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nS : Set E\n⊢ Iff (Eq (Module.finrank F (Subtype fun x => Membership.mem (IntermediateField.adjoin F S) x)) 1) (HasSubset.Subset S ↑Bot.bot)","decl":"theorem finrank_adjoin_eq_one_iff : finrank F (adjoin F S) = 1 ↔ S ⊆ (⊥ : IntermediateField F E) :=\n  Iff.trans finrank_eq_one_iff adjoin_eq_bot_iff\n\n"}
{"name":"IntermediateField.finrank_adjoin_simple_eq_one_iff","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nα : E\n⊢ Iff (Eq (Module.finrank F (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Singleton.singleton α)) x)) 1) (Membership.mem Bot.bot α)","decl":"theorem finrank_adjoin_simple_eq_one_iff :\n    finrank F F⟮α⟯ = 1 ↔ α ∈ (⊥ : IntermediateField F E) := by\n  rw [finrank_adjoin_eq_one_iff]; exact Set.singleton_subset_iff\n\n"}
{"name":"IntermediateField.bot_eq_top_of_rank_adjoin_eq_one","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nh : ∀ (x : E), Eq (Module.rank F (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin F (Singleton.singleton x)) x_1)) 1\n⊢ Eq Bot.bot Top.top","decl":"/-- If `F⟮x⟯` has dimension `1` over `F` for every `x ∈ E` then `F = E`. -/\ntheorem bot_eq_top_of_rank_adjoin_eq_one (h : ∀ x : E, Module.rank F F⟮x⟯ = 1) :\n    (⊥ : IntermediateField F E) = ⊤ := by\n  ext y\n  rw [iff_true_right IntermediateField.mem_top]\n  exact rank_adjoin_simple_eq_one_iff.mp (h y)\n\n"}
{"name":"IntermediateField.bot_eq_top_of_finrank_adjoin_eq_one","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nh : ∀ (x : E), Eq (Module.finrank F (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin F (Singleton.singleton x)) x_1)) 1\n⊢ Eq Bot.bot Top.top","decl":"theorem bot_eq_top_of_finrank_adjoin_eq_one (h : ∀ x : E, finrank F F⟮x⟯ = 1) :\n    (⊥ : IntermediateField F E) = ⊤ := by\n  ext y\n  rw [iff_true_right IntermediateField.mem_top]\n  exact finrank_adjoin_simple_eq_one_iff.mp (h y)\n\n"}
{"name":"IntermediateField.subsingleton_of_rank_adjoin_eq_one","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nh : ∀ (x : E), Eq (Module.rank F (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin F (Singleton.singleton x)) x_1)) 1\n⊢ Subsingleton (IntermediateField F E)","decl":"theorem subsingleton_of_rank_adjoin_eq_one (h : ∀ x : E, Module.rank F F⟮x⟯ = 1) :\n    Subsingleton (IntermediateField F E) :=\n  subsingleton_of_bot_eq_top (bot_eq_top_of_rank_adjoin_eq_one h)\n\n"}
{"name":"IntermediateField.subsingleton_of_finrank_adjoin_eq_one","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nh : ∀ (x : E), Eq (Module.finrank F (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin F (Singleton.singleton x)) x_1)) 1\n⊢ Subsingleton (IntermediateField F E)","decl":"theorem subsingleton_of_finrank_adjoin_eq_one (h : ∀ x : E, finrank F F⟮x⟯ = 1) :\n    Subsingleton (IntermediateField F E) :=\n  subsingleton_of_bot_eq_top (bot_eq_top_of_finrank_adjoin_eq_one h)\n\n"}
{"name":"IntermediateField.bot_eq_top_of_finrank_adjoin_le_one","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝³ : Field F\nE : Type u_2\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : FiniteDimensional F E\nh : ∀ (x : E), LE.le (Module.finrank F (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin F (Singleton.singleton x)) x_1)) 1\n⊢ Eq Bot.bot Top.top","decl":"/-- If `F⟮x⟯` has dimension `≤1` over `F` for every `x ∈ E` then `F = E`. -/\ntheorem bot_eq_top_of_finrank_adjoin_le_one [FiniteDimensional F E]\n    (h : ∀ x : E, finrank F F⟮x⟯ ≤ 1) : (⊥ : IntermediateField F E) = ⊤ := by\n  apply bot_eq_top_of_finrank_adjoin_eq_one\n  exact fun x => by linarith [h x, show 0 < finrank F F⟮x⟯ from finrank_pos]\n\n"}
{"name":"IntermediateField.subsingleton_of_finrank_adjoin_le_one","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝³ : Field F\nE : Type u_2\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : FiniteDimensional F E\nh : ∀ (x : E), LE.le (Module.finrank F (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin F (Singleton.singleton x)) x_1)) 1\n⊢ Subsingleton (IntermediateField F E)","decl":"theorem subsingleton_of_finrank_adjoin_le_one [FiniteDimensional F E]\n    (h : ∀ x : E, finrank F F⟮x⟯ ≤ 1) : Subsingleton (IntermediateField F E) :=\n  subsingleton_of_bot_eq_top (bot_eq_top_of_finrank_adjoin_le_one h)\n\n"}
{"name":"IntermediateField.minpoly_gen","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nα : E\n⊢ Eq (minpoly F (IntermediateField.AdjoinSimple.gen F α)) (minpoly F α)","decl":"theorem minpoly_gen (α : E) :\n    minpoly F (AdjoinSimple.gen F α) = minpoly F α := by\n  rw [← minpoly.algebraMap_eq (algebraMap F⟮α⟯ E).injective, AdjoinSimple.algebraMap_gen]\n\n"}
{"name":"IntermediateField.aeval_gen_minpoly","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nα : E\n⊢ Eq ((Polynomial.aeval (IntermediateField.AdjoinSimple.gen F α)) (minpoly F α)) 0","decl":"theorem aeval_gen_minpoly (α : E) : aeval (AdjoinSimple.gen F α) (minpoly F α) = 0 := by\n  ext\n  convert minpoly.aeval F α\n  conv in aeval α => rw [← AdjoinSimple.algebraMap_gen F α]\n  exact (aeval_algebraMap_apply E (AdjoinSimple.gen F α) _).symm\n\n-- Porting note: original proof used `Exists.cases_on`.\n"}
{"name":"IntermediateField.adjoinRootEquivAdjoin_apply_root","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nα : E\nh : IsIntegral F α\n⊢ Eq ((IntermediateField.adjoinRootEquivAdjoin F h) (AdjoinRoot.root (minpoly F α))) (IntermediateField.AdjoinSimple.gen F α)","decl":"theorem adjoinRootEquivAdjoin_apply_root (h : IsIntegral F α) :\n    adjoinRootEquivAdjoin F h (AdjoinRoot.root (minpoly F α)) = AdjoinSimple.gen F α :=\n  AdjoinRoot.lift_root (aeval_gen_minpoly F α)\n\n"}
{"name":"IntermediateField.adjoinRootEquivAdjoin_symm_apply_gen","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\nα : E\nh : IsIntegral F α\n⊢ Eq ((IntermediateField.adjoinRootEquivAdjoin F h).symm (IntermediateField.AdjoinSimple.gen F α)) (AdjoinRoot.root (minpoly F α))","decl":"@[simp]\ntheorem adjoinRootEquivAdjoin_symm_apply_gen (h : IsIntegral F α) :\n    (adjoinRootEquivAdjoin F h).symm (AdjoinSimple.gen F α) = AdjoinRoot.root (minpoly F α) := by\n  rw [AlgEquiv.symm_apply_eq, adjoinRootEquivAdjoin_apply_root]\n\n"}
{"name":"IntermediateField.adjoin_root_eq_top","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u\ninst✝¹ : Field K\np : Polynomial K\ninst✝ : Fact (Irreducible p)\n⊢ Eq (IntermediateField.adjoin K (Singleton.singleton (AdjoinRoot.root p))) Top.top","decl":"theorem adjoin_root_eq_top (p : K[X]) [Fact (Irreducible p)] : K⟮AdjoinRoot.root p⟯ = ⊤ :=\n  (eq_adjoin_of_eq_algebra_adjoin K _ ⊤ (AdjoinRoot.adjoinRoot_eq_top (f := p)).symm).symm\n\n"}
{"name":"IntermediateField.adjoin.powerBasis_dim","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u\ninst✝² : Field K\nL : Type u_3\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx : L\nhx : IsIntegral K x\n⊢ Eq (IntermediateField.adjoin.powerBasis hx).dim (minpoly K x).natDegree","decl":"/-- The power basis `1, x, ..., x ^ (d - 1)` for `K⟮x⟯`,\nwhere `d` is the degree of the minimal polynomial of `x`. -/\n@[simps]\nnoncomputable def adjoin.powerBasis {x : L} (hx : IsIntegral K x) : PowerBasis K K⟮x⟯ where\n  gen := AdjoinSimple.gen K x\n  dim := (minpoly K x).natDegree\n  basis := powerBasisAux hx\n  basis_eq_pow i := by\n    -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n    erw [powerBasisAux, Basis.map_apply, PowerBasis.basis_eq_pow, AlgEquiv.toLinearEquiv_apply,\n      map_pow, AdjoinRoot.powerBasis_gen, adjoinRootEquivAdjoin_apply_root]\n\n"}
{"name":"IntermediateField.adjoin.powerBasis_gen","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u\ninst✝² : Field K\nL : Type u_3\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx : L\nhx : IsIntegral K x\n⊢ Eq (IntermediateField.adjoin.powerBasis hx).gen (IntermediateField.AdjoinSimple.gen K x)","decl":"/-- The power basis `1, x, ..., x ^ (d - 1)` for `K⟮x⟯`,\nwhere `d` is the degree of the minimal polynomial of `x`. -/\n@[simps]\nnoncomputable def adjoin.powerBasis {x : L} (hx : IsIntegral K x) : PowerBasis K K⟮x⟯ where\n  gen := AdjoinSimple.gen K x\n  dim := (minpoly K x).natDegree\n  basis := powerBasisAux hx\n  basis_eq_pow i := by\n    -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n    erw [powerBasisAux, Basis.map_apply, PowerBasis.basis_eq_pow, AlgEquiv.toLinearEquiv_apply,\n      map_pow, AdjoinRoot.powerBasis_gen, adjoinRootEquivAdjoin_apply_root]\n\n"}
{"name":"IntermediateField.adjoin.finiteDimensional","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u\ninst✝² : Field K\nL : Type u_3\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx : L\nhx : IsIntegral K x\n⊢ FiniteDimensional K (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin K (Singleton.singleton x)) x_1)","decl":"theorem adjoin.finiteDimensional {x : L} (hx : IsIntegral K x) : FiniteDimensional K K⟮x⟯ :=\n  (adjoin.powerBasis hx).finite\n\n"}
{"name":"IntermediateField.isAlgebraic_adjoin_simple","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u\ninst✝² : Field K\nL : Type u_3\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx : L\nhx : IsIntegral K x\n⊢ Algebra.IsAlgebraic K (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin K (Singleton.singleton x)) x_1)","decl":"theorem isAlgebraic_adjoin_simple {x : L} (hx : IsIntegral K x) : Algebra.IsAlgebraic K K⟮x⟯ :=\n  have := adjoin.finiteDimensional hx; Algebra.IsAlgebraic.of_finite K K⟮x⟯\n\n"}
{"name":"IntermediateField.adjoin.finrank","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u\ninst✝² : Field K\nL : Type u_3\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx : L\nhx : IsIntegral K x\n⊢ Eq (Module.finrank K (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin K (Singleton.singleton x)) x_1)) (minpoly K x).natDegree","decl":"/-- If `x` is an algebraic element of field `K`, then its minimal polynomial has degree\n`[K(x) : K]`. -/\n@[stacks 09GN]\ntheorem adjoin.finrank {x : L} (hx : IsIntegral K x) :\n    Module.finrank K K⟮x⟯ = (minpoly K x).natDegree := by\n  rw [PowerBasis.finrank (adjoin.powerBasis hx :)]\n  rfl\n\n"}
{"name":"IntermediateField.adjoin_eq_top_of_adjoin_eq_top","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝⁶ : Field F\nE : Type u_2\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type u\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\nS : Set K\nhprim : Eq (IntermediateField.adjoin F S) Top.top\n⊢ Eq (IntermediateField.adjoin E S) Top.top","decl":"/-- If `K / E / F` is a field extension tower, `S ⊂ K` is such that `F(S) = K`,\nthen `E(S) = K`. -/\ntheorem adjoin_eq_top_of_adjoin_eq_top [Algebra E K] [IsScalarTower F E K]\n    {S : Set K} (hprim : adjoin F S = ⊤) : adjoin E S = ⊤ :=\n  restrictScalars_injective F <| by\n    rw [restrictScalars_top, ← top_le_iff, ← hprim, adjoin_le_iff,\n      coe_restrictScalars, ← adjoin_le_iff]\n\n"}
{"name":"IntermediateField.adjoin_minpoly_coeff_of_exists_primitive_element","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝³ : Field F\nE : Type u_2\ninst✝² : Field E\ninst✝¹ : Algebra F E\nα : E\ninst✝ : FiniteDimensional F E\nhprim : Eq (IntermediateField.adjoin F (Singleton.singleton α)) Top.top\nK : IntermediateField F E\n⊢ Eq (IntermediateField.adjoin F ↑(Polynomial.map (algebraMap (Subtype fun x => Membership.mem K x) E) (minpoly (Subtype fun x => Membership.mem K x) α)).coeffs) K","decl":"/-- If `E / F` is a finite extension such that `E = F(α)`, then for any intermediate field `K`, the\n`F` adjoin the coefficients of `minpoly K α` is equal to `K` itself. -/\ntheorem adjoin_minpoly_coeff_of_exists_primitive_element\n    [FiniteDimensional F E] (hprim : adjoin F {α} = ⊤) (K : IntermediateField F E) :\n    adjoin F ((minpoly K α).map (algebraMap K E)).coeffs = K := by\n  set g := (minpoly K α).map (algebraMap K E)\n  set K' : IntermediateField F E := adjoin F g.coeffs\n  have hsub : K' ≤ K := by\n    refine adjoin_le_iff.mpr fun x ↦ ?_\n    rw [Finset.mem_coe, mem_coeffs_iff]\n    rintro ⟨n, -, rfl⟩\n    rw [coeff_map]\n    apply Subtype.mem\n  have dvd_g : minpoly K' α ∣ g.toSubring K'.toSubring (subset_adjoin F _) := by\n    apply minpoly.dvd\n    erw [aeval_def, eval₂_eq_eval_map, g.map_toSubring K'.toSubring, eval_map, ← aeval_def]\n    exact minpoly.aeval K α\n  have finrank_eq : ∀ K : IntermediateField F E, finrank K E = natDegree (minpoly K α) := by\n    intro K\n    have := adjoin.finrank (.of_finite K α)\n    erw [adjoin_eq_top_of_adjoin_eq_top F hprim, finrank_top K E] at this\n    exact this\n  refine eq_of_le_of_finrank_le' hsub ?_\n  simp_rw [finrank_eq]\n  convert natDegree_le_of_dvd dvd_g\n    ((g.monic_toSubring _ _).mpr <| (minpoly.monic <| .of_finite K α).map _).ne_zero using 1\n  rw [natDegree_toSubring, natDegree_map]\n\n"}
{"name":"IntermediateField.instFiniteSubtypeMemBot","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_2\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Module.Finite F (Subtype fun x => Membership.mem Bot.bot x)","decl":"instance : Module.Finite F (⊥ : IntermediateField F E) := Subalgebra.finite_bot\n\n"}
{"name":"IntermediateField.exists_lt_finrank_of_infinite_dimensional","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝³ : Field F\nE : Type u_2\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsAlgebraic F E\nhnfd : Not (FiniteDimensional F E)\nn : Nat\n⊢ Exists fun L => And (FiniteDimensional F (Subtype fun x => Membership.mem L x)) (LT.lt n (Module.finrank F (Subtype fun x => Membership.mem L x)))","decl":"variable {F} in\n/-- If `E / F` is an infinite algebraic extension, then there exists an intermediate field\n`L / F` with arbitrarily large finite extension degree. -/\ntheorem exists_lt_finrank_of_infinite_dimensional\n    [Algebra.IsAlgebraic F E] (hnfd : ¬ FiniteDimensional F E) (n : ℕ) :\n    ∃ L : IntermediateField F E, FiniteDimensional F L ∧ n < finrank F L := by\n  induction' n with n ih\n  · exact ⟨⊥, Subalgebra.finite_bot, finrank_pos⟩\n  obtain ⟨L, fin, hn⟩ := ih\n  obtain ⟨x, hx⟩ : ∃ x : E, x ∉ L := by\n    contrapose! hnfd\n    rw [show L = ⊤ from eq_top_iff.2 fun x _ ↦ hnfd x] at fin\n    exact topEquiv.toLinearEquiv.finiteDimensional\n  let L' := L ⊔ F⟮x⟯\n  haveI := adjoin.finiteDimensional (Algebra.IsIntegral.isIntegral (R := F) x)\n  refine ⟨L', inferInstance, by_contra fun h ↦ ?_⟩\n  have h1 : L = L' := eq_of_le_of_finrank_le le_sup_left ((not_lt.1 h).trans hn)\n  have h2 : F⟮x⟯ ≤ L' := le_sup_right\n  exact hx <| (h1.symm ▸ h2) <| mem_adjoin_simple_self F x\n\n"}
{"name":"minpoly.natDegree_le","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u\ninst✝³ : Field K\nL : Type u_3\ninst✝² : Field L\ninst✝¹ : Algebra K L\nx : L\ninst✝ : FiniteDimensional K L\n⊢ LE.le (minpoly K x).natDegree (Module.finrank K L)","decl":"theorem _root_.minpoly.natDegree_le (x : L) [FiniteDimensional K L] :\n    (minpoly K x).natDegree ≤ finrank K L :=\n  le_of_eq_of_le (IntermediateField.adjoin.finrank (.of_finite _ _)).symm\n    K⟮x⟯.toSubmodule.finrank_le\n\n"}
{"name":"minpoly.degree_le","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u\ninst✝³ : Field K\nL : Type u_3\ninst✝² : Field L\ninst✝¹ : Algebra K L\nx : L\ninst✝ : FiniteDimensional K L\n⊢ LE.le (minpoly K x).degree ↑(Module.finrank K L)","decl":"theorem _root_.minpoly.degree_le (x : L) [FiniteDimensional K L] :\n    (minpoly K x).degree ≤ finrank K L :=\n  degree_le_of_natDegree_le (minpoly.natDegree_le x)\n\n"}
{"name":"minpoly.degree_dvd","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u\ninst✝² : Field K\nL : Type u_3\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx : L\nhx : IsIntegral K x\n⊢ Dvd.dvd (minpoly K x).natDegree (Module.finrank K L)","decl":"/-- If `x : L` is an integral element in a field extension `L` over `K`, then the degree of the\n  minimal polynomial of `x` over `K` divides `[L : K]`.-/\ntheorem _root_.minpoly.degree_dvd {x : L} (hx : IsIntegral K x) :\n    (minpoly K x).natDegree ∣ finrank K L := by\n  rw [dvd_iff_exists_eq_mul_left, ← IntermediateField.adjoin.finrank hx]\n  use finrank K⟮x⟯ L\n  rw [mul_comm, finrank_mul_finrank]\n\n-- TODO: generalize to `Sort`\n"}
{"name":"IntermediateField.isAlgebraic_iSup","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u\ninst✝² : Field K\nL : Type u_3\ninst✝¹ : Field L\ninst✝ : Algebra K L\nι : Type u_4\nt : ι → IntermediateField K L\nh : ∀ (i : ι), Algebra.IsAlgebraic K (Subtype fun x => Membership.mem (t i) x)\n⊢ Algebra.IsAlgebraic K (Subtype fun x => Membership.mem (iSup fun i => t i) x)","decl":"/-- A compositum of algebraic extensions is algebraic -/\ntheorem isAlgebraic_iSup {ι : Type*} {t : ι → IntermediateField K L}\n    (h : ∀ i, Algebra.IsAlgebraic K (t i)) :\n    Algebra.IsAlgebraic K (⨆ i, t i : IntermediateField K L) := by\n  constructor\n  rintro ⟨x, hx⟩\n  obtain ⟨s, hx⟩ := exists_finset_of_mem_supr' hx\n  rw [isAlgebraic_iff, Subtype.coe_mk, ← Subtype.coe_mk (p := (· ∈ _)) x hx, ← isAlgebraic_iff]\n  haveI : ∀ i : Σ i, t i, FiniteDimensional K K⟮(i.2 : L)⟯ := fun ⟨i, x⟩ ↦\n    adjoin.finiteDimensional (isIntegral_iff.1 (Algebra.IsIntegral.isIntegral x))\n  apply IsAlgebraic.of_finite\n\n"}
{"name":"IntermediateField.isAlgebraic_adjoin","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u\ninst✝² : Field K\nL : Type u_3\ninst✝¹ : Field L\ninst✝ : Algebra K L\nS : Set L\nhS : ∀ (x : L), Membership.mem S x → IsIntegral K x\n⊢ Algebra.IsAlgebraic K (Subtype fun x => Membership.mem (IntermediateField.adjoin K S) x)","decl":"theorem isAlgebraic_adjoin {S : Set L} (hS : ∀ x ∈ S, IsIntegral K x) :\n    Algebra.IsAlgebraic K (adjoin K S) := by\n  rw [← biSup_adjoin_simple, ← iSup_subtype'']\n  exact isAlgebraic_iSup fun x ↦ isAlgebraic_adjoin_simple (hS x x.2)\n\n"}
{"name":"IntermediateField.finiteDimensional_adjoin","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u\ninst✝³ : Field K\nL : Type u_3\ninst✝² : Field L\ninst✝¹ : Algebra K L\nS : Set L\ninst✝ : Finite ↑S\nhS : ∀ (x : L), Membership.mem S x → IsIntegral K x\n⊢ FiniteDimensional K (Subtype fun x => Membership.mem (IntermediateField.adjoin K S) x)","decl":"/-- If `L / K` is a field extension, `S` is a finite subset of `L`, such that every element of `S`\nis integral (= algebraic) over `K`, then `K(S) / K` is a finite extension.\nA direct corollary of `finiteDimensional_iSup_of_finite`. -/\ntheorem finiteDimensional_adjoin {S : Set L} [Finite S] (hS : ∀ x ∈ S, IsIntegral K x) :\n    FiniteDimensional K (adjoin K S) := by\n  rw [← biSup_adjoin_simple, ← iSup_subtype'']\n  haveI (x : S) := adjoin.finiteDimensional (hS x.1 x.2)\n  exact finiteDimensional_iSup_of_finite\n\n"}
{"name":"IntermediateField.algHomAdjoinIntegralEquiv_symm_apply_gen","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝⁴ : Field F\nE : Type u_2\ninst✝³ : Field E\ninst✝² : Algebra F E\nα : E\nK : Type u\ninst✝¹ : Field K\ninst✝ : Algebra F K\nh : IsIntegral F α\nx : Subtype fun x => Membership.mem ((minpoly F α).aroots K) x\n⊢ Eq (((IntermediateField.algHomAdjoinIntegralEquiv F h).symm x) (IntermediateField.AdjoinSimple.gen F α)) ↑x","decl":"lemma algHomAdjoinIntegralEquiv_symm_apply_gen (h : IsIntegral F α)\n    (x : { x // x ∈ (minpoly F α).aroots K }) :\n    (algHomAdjoinIntegralEquiv F h).symm x (AdjoinSimple.gen F α) = x :=\n  (adjoin.powerBasis h).lift_gen x.val <| by\n    rw [adjoin.powerBasis_gen, minpoly_gen]; exact (mem_aroots.mp x.2).2\n\n"}
{"name":"IntermediateField.card_algHom_adjoin_integral","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u_1\ninst✝⁴ : Field F\nE : Type u_2\ninst✝³ : Field E\ninst✝² : Algebra F E\nα : E\nK : Type u\ninst✝¹ : Field K\ninst✝ : Algebra F K\nh : IsIntegral F α\nh_sep : IsSeparable F α\nh_splits : Polynomial.Splits (algebraMap F K) (minpoly F α)\n⊢ Eq (Fintype.card (AlgHom F (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Singleton.singleton α)) x) K)) (minpoly F α).natDegree","decl":"theorem card_algHom_adjoin_integral (h : IsIntegral F α) (h_sep : IsSeparable F α)\n    (h_splits : (minpoly F α).Splits (algebraMap F K)) :\n    @Fintype.card (F⟮α⟯ →ₐ[F] K) (fintypeOfAlgHomAdjoinIntegral F h) = (minpoly F α).natDegree := by\n  rw [AlgHom.card_of_powerBasis] <;>\n    simp only [IsSeparable, adjoin.powerBasis_dim, adjoin.powerBasis_gen, minpoly_gen, h_splits]\n  exact h_sep\n\n-- Apparently `K⟮root f⟯ →+* K⟮root f⟯` is expensive to unify during instance synthesis.\n"}
{"name":"Polynomial.irreducible_comp","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u\ninst✝ : Field K\nf g : Polynomial K\nhfm : f.Monic\nhgm : g.Monic\nhf : Irreducible f\nhg : ∀ (E : Type u) [inst : Field E] [inst_1 : Algebra K E] (x : E), Eq (minpoly K x) f → Irreducible (HSub.hSub (Polynomial.map (algebraMap K (Subtype fun x_2 => Membership.mem (IntermediateField.adjoin K (Singleton.singleton x)) x_2)) g) (Polynomial.C (IntermediateField.AdjoinSimple.gen K x)))\n⊢ Irreducible (f.comp g)","decl":"open Module AdjoinRoot in\n/-- Let `f, g` be monic polynomials over `K`. If `f` is irreducible, and `g(x) - α` is irreducible\nin `K⟮α⟯` with `α` a root of `f`, then `f(g(x))` is irreducible. -/\ntheorem _root_.Polynomial.irreducible_comp {f g : K[X]} (hfm : f.Monic) (hgm : g.Monic)\n    (hf : Irreducible f)\n    (hg : ∀ (E : Type u) [Field E] [Algebra K E] (x : E) (_ : minpoly K x = f),\n      Irreducible (g.map (algebraMap _ _) - C (AdjoinSimple.gen K x))) :\n    Irreducible (f.comp g) := by\n  have hf' : natDegree f ≠ 0 :=\n    fun e ↦ not_irreducible_C (f.coeff 0) (eq_C_of_natDegree_eq_zero e ▸ hf)\n  have hg' : natDegree g ≠ 0 := by\n    have := Fact.mk hf\n    intro e\n    apply not_irreducible_C ((g.map (algebraMap _ _)).coeff 0 - AdjoinSimple.gen K (root f))\n    -- Needed to specialize `map_sub` to avoid a timeout https://github.com/leanprover-community/mathlib4/pull/8386\n    rw [RingHom.map_sub, coeff_map, ← map_C, ← eq_C_of_natDegree_eq_zero e]\n    apply hg (AdjoinRoot f)\n    rw [AdjoinRoot.minpoly_root hf.ne_zero, hfm, inv_one, map_one, mul_one]\n  have H₁ : f.comp g ≠ 0 := fun h ↦ by simpa [hf', hg', natDegree_comp] using congr_arg natDegree h\n  have H₂ : ¬ IsUnit (f.comp g) := fun h ↦\n    by simpa [hf', hg', natDegree_comp] using natDegree_eq_zero_of_isUnit h\n  have ⟨p, hp₁, hp₂⟩ := WfDvdMonoid.exists_irreducible_factor H₂ H₁\n  suffices natDegree p = natDegree f * natDegree g from (associated_of_dvd_of_natDegree_le hp₂ H₁\n    (this.trans natDegree_comp.symm).ge).irreducible hp₁\n  have := Fact.mk hp₁\n  let Kx := AdjoinRoot p\n  letI := (AdjoinRoot.powerBasis hp₁.ne_zero).finite\n  have key₁ : f = minpoly K (aeval (root p) g) := by\n    refine minpoly.eq_of_irreducible_of_monic hf ?_ hfm\n    rw [← aeval_comp]\n    exact aeval_eq_zero_of_dvd_aeval_eq_zero hp₂ (AdjoinRoot.eval₂_root p)\n  have key₁' : finrank K K⟮aeval (root p) g⟯ = natDegree f := by\n    rw [adjoin.finrank, ← key₁]\n    exact IsIntegral.of_finite _ _\n  have key₂ : g.map (algebraMap _ _) - C (AdjoinSimple.gen K (aeval (root p) g)) =\n      minpoly K⟮aeval (root p) g⟯ (root p) :=\n    minpoly.eq_of_irreducible_of_monic (hg _ _ key₁.symm) (by simp [AdjoinSimple.gen])\n      (Monic.sub_of_left (hgm.map _) (degree_lt_degree (by simpa [Nat.pos_iff_ne_zero] using hg')))\n  have key₂' : finrank K⟮aeval (root p) g⟯ Kx = natDegree g := by\n    trans natDegree (minpoly K⟮aeval (root p) g⟯ (root p))\n    · have : K⟮aeval (root p) g⟯⟮root p⟯ = ⊤ := by\n        apply restrictScalars_injective K\n        rw [restrictScalars_top, adjoin_adjoin_left, Set.union_comm, ← adjoin_adjoin_left,\n          adjoin_root_eq_top p, restrictScalars_adjoin]\n        simp\n      rw [← finrank_top', ← this, adjoin.finrank]\n      exact IsIntegral.of_finite _ _\n    · simp [← key₂]\n  have := Module.finrank_mul_finrank K K⟮aeval (root p) g⟯ Kx\n  rwa [key₁', key₂', (AdjoinRoot.powerBasis hp₁.ne_zero).finrank, powerBasis_dim, eq_comm] at this\n\n"}
{"name":"AdjoinRoot.coe_algHomOfDvd","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\np q : Polynomial K\nhpq : Dvd.dvd q p\n⊢ Eq (↑↑(AdjoinRoot.algHomOfDvd hpq).toRingHom).toFun ⇑(AdjoinRoot.liftHom p (AdjoinRoot.root q) ⋯)","decl":"theorem coe_algHomOfDvd {p q : K[X]} (hpq : q ∣ p) :\n    (algHomOfDvd hpq).toFun = liftHom p (root q) (by simp only [aeval_eq, mk_eq_zero, hpq]) :=\n  rfl\n\n"}
{"name":"AdjoinRoot.algHomOfDvd_apply_root","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\np q : Polynomial K\nhpq : Dvd.dvd q p\n⊢ Eq ((AdjoinRoot.algHomOfDvd hpq) (AdjoinRoot.root p)) (AdjoinRoot.root q)","decl":"/-- `algHomOfDvd` sends `AdjoinRoot.root p` to `AdjoinRoot.root q`. -/\ntheorem algHomOfDvd_apply_root {p q : K[X]} (hpq : q ∣ p) :\n    algHomOfDvd hpq (root p) = root q := by\n  rw [algHomOfDvd, liftHom_root]\n\n"}
{"name":"AdjoinRoot.coe_algEquivOfEq","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\np q : Polynomial K\nhp : Ne p 0\nh_eq : Eq p q\n⊢ Eq (AdjoinRoot.algEquivOfEq hp h_eq).toFun ⇑(AdjoinRoot.liftHom p (AdjoinRoot.root q) ⋯)","decl":"theorem coe_algEquivOfEq {p q : K[X]} (hp : p ≠ 0) (h_eq : p = q) :\n    (algEquivOfEq hp h_eq).toFun = liftHom p (root q) (by rw [h_eq, aeval_eq, mk_self]) :=\n  rfl\n\n"}
{"name":"AdjoinRoot.algEquivOfEq_toAlgHom","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\np q : Polynomial K\nhp : Ne p 0\nh_eq : Eq p q\n⊢ Eq (↑(AdjoinRoot.algEquivOfEq hp h_eq)) (AdjoinRoot.liftHom p (AdjoinRoot.root q) ⋯)","decl":"theorem algEquivOfEq_toAlgHom {p q : K[X]} (hp : p ≠ 0) (h_eq : p = q) :\n    (algEquivOfEq hp h_eq).toAlgHom = liftHom p (root q) (by rw [h_eq, aeval_eq, mk_self]) :=\n  rfl\n\n"}
{"name":"AdjoinRoot.algEquivOfEq_apply_root","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\np q : Polynomial K\nhp : Ne p 0\nh_eq : Eq p q\n⊢ Eq ((AdjoinRoot.algEquivOfEq hp h_eq) (AdjoinRoot.root p)) (AdjoinRoot.root q)","decl":"/-- `algEquivOfEq` sends `AdjoinRoot.root p` to `AdjoinRoot.root q`. -/\ntheorem algEquivOfEq_apply_root {p q : K[X]} (hp : p ≠ 0) (h_eq : p = q) :\n    algEquivOfEq hp h_eq (root p) = root q := by\n  rw [← coe_algHom, algEquivOfEq_toAlgHom, liftHom_root]\n\n"}
{"name":"AdjoinRoot.coe_algEquivOfAssociated","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\np q : Polynomial K\nhp : Ne p 0\nhpq : Associated p q\n⊢ Eq (AdjoinRoot.algEquivOfAssociated hp hpq).toFun ⇑(AdjoinRoot.liftHom p (AdjoinRoot.root q) ⋯)","decl":"theorem coe_algEquivOfAssociated {p q : K[X]} (hp : p ≠ 0) (hpq : Associated p q) :\n    (algEquivOfAssociated hp hpq).toFun =\n      liftHom p (root q) (by simp only [aeval_eq, mk_eq_zero, hpq.symm.dvd]) :=\n  rfl\n\n"}
{"name":"AdjoinRoot.algEquivOfAssociated_toAlgHom","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\np q : Polynomial K\nhp : Ne p 0\nhpq : Associated p q\n⊢ Eq (↑(AdjoinRoot.algEquivOfAssociated hp hpq)) (AdjoinRoot.liftHom p (AdjoinRoot.root q) ⋯)","decl":"theorem algEquivOfAssociated_toAlgHom {p q : K[X]} (hp : p ≠ 0) (hpq : Associated p q) :\n    (algEquivOfAssociated hp hpq).toAlgHom =\n      liftHom p (root q) (by simp only [aeval_eq, mk_eq_zero, hpq.symm.dvd]) :=\n  rfl\n\n"}
{"name":"AdjoinRoot.algEquivOfAssociated_apply_root","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_1\ninst✝ : Field K\np q : Polynomial K\nhp : Ne p 0\nhpq : Associated p q\n⊢ Eq ((AdjoinRoot.algEquivOfAssociated hp hpq) (AdjoinRoot.root p)) (AdjoinRoot.root q)","decl":"/-- `algEquivOfAssociated` sends `AdjoinRoot.root p` to `AdjoinRoot.root q`. -/\ntheorem algEquivOfAssociated_apply_root {p q : K[X]} (hp : p ≠ 0) (hpq : Associated p q) :\n    algEquivOfAssociated hp hpq (root p) = root q := by\n  rw [← coe_algHom, algEquivOfAssociated_toAlgHom, liftHom_root]\n\n"}
{"name":"minpoly.eq_of_root","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx y : L\nhx : IsAlgebraic K x\nh_ev : Eq ((Polynomial.aeval y) (minpoly K x)) 0\n⊢ Eq (minpoly K y) (minpoly K x)","decl":"/-- If `y : L` is a root of `minpoly K x`, then `minpoly K y = minpoly K x`. -/\ntheorem eq_of_root {x y : L} (hx : IsAlgebraic K x)\n    (h_ev : Polynomial.aeval y (minpoly K x) = 0) : minpoly K y = minpoly K x :=\n  ((eq_iff_aeval_minpoly_eq_zero hx.isIntegral).mpr h_ev).symm\n\n"}
{"name":"minpoly.algEquiv_apply","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx y : L\nhx : IsAlgebraic K x\nh_mp : Eq (minpoly K x) (minpoly K y)\n⊢ Eq ((minpoly.algEquiv hx h_mp) (IntermediateField.AdjoinSimple.gen K x)) (IntermediateField.AdjoinSimple.gen K y)","decl":"/-- `minpoly.algEquiv` sends the generator of `K⟮x⟯` to the generator of `K⟮y⟯`. -/\ntheorem algEquiv_apply {x y : L} (hx : IsAlgebraic K x) (h_mp : minpoly K x = minpoly K y) :\n    algEquiv hx h_mp (AdjoinSimple.gen K x) = AdjoinSimple.gen K y := by\n  have hy : IsAlgebraic K y := ⟨minpoly K x, ne_zero hx.isIntegral, (h_mp ▸ aeval _ _)⟩\n  rw [algEquiv, trans_apply, ← adjoinRootEquivAdjoin_apply_root K hx.isIntegral,\n    symm_apply_apply, trans_apply, AdjoinRoot.algEquivOfEq_apply_root,\n    adjoinRootEquivAdjoin_apply_root K hy.isIntegral]\n\n"}
{"name":"PowerBasis.equivAdjoinSimple_aeval","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\npb : PowerBasis K L\nf : Polynomial K\n⊢ Eq (pb.equivAdjoinSimple ((Polynomial.aeval (IntermediateField.AdjoinSimple.gen K pb.gen)) f)) ((Polynomial.aeval pb.gen) f)","decl":"@[simp]\ntheorem equivAdjoinSimple_aeval (pb : PowerBasis K L) (f : K[X]) :\n    pb.equivAdjoinSimple (aeval (AdjoinSimple.gen K pb.gen) f) = aeval pb.gen f :=\n  equivOfMinpoly_aeval _ pb _ f\n\n"}
{"name":"PowerBasis.equivAdjoinSimple_gen","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\npb : PowerBasis K L\n⊢ Eq (pb.equivAdjoinSimple (IntermediateField.AdjoinSimple.gen K pb.gen)) pb.gen","decl":"@[simp]\ntheorem equivAdjoinSimple_gen (pb : PowerBasis K L) :\n    pb.equivAdjoinSimple (AdjoinSimple.gen K pb.gen) = pb.gen :=\n  equivOfMinpoly_gen _ pb _\n\n"}
{"name":"PowerBasis.equivAdjoinSimple_symm_aeval","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\npb : PowerBasis K L\nf : Polynomial K\n⊢ Eq (pb.equivAdjoinSimple.symm ((Polynomial.aeval pb.gen) f)) ((Polynomial.aeval (IntermediateField.AdjoinSimple.gen K pb.gen)) f)","decl":"@[simp]\ntheorem equivAdjoinSimple_symm_aeval (pb : PowerBasis K L) (f : K[X]) :\n    pb.equivAdjoinSimple.symm (aeval pb.gen f) = aeval (AdjoinSimple.gen K pb.gen) f := by\n  rw [equivAdjoinSimple, equivOfMinpoly_symm, equivOfMinpoly_aeval, adjoin.powerBasis_gen]\n\n"}
{"name":"PowerBasis.equivAdjoinSimple_symm_gen","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"K : Type u_1\nL : Type u_2\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\npb : PowerBasis K L\n⊢ Eq (pb.equivAdjoinSimple.symm pb.gen) (IntermediateField.AdjoinSimple.gen K pb.gen)","decl":"@[simp]\ntheorem equivAdjoinSimple_symm_gen (pb : PowerBasis K L) :\n    pb.equivAdjoinSimple.symm pb.gen = AdjoinSimple.gen K pb.gen := by\n  rw [equivAdjoinSimple, equivOfMinpoly_symm, equivOfMinpoly_gen, adjoin.powerBasis_gen]\n\n"}
{"name":"IntermediateField.lift_cardinalMk_adjoin_le","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u\ninst✝² : Field F\nE : Type v\ninst✝¹ : Field E\ninst✝ : Algebra F E\ns : Set E\n⊢ LE.le (Cardinal.lift.{u, v} (Cardinal.mk (Subtype fun x => Membership.mem (IntermediateField.adjoin F s) x))) (Max.max (Max.max (Cardinal.lift.{v, u} (Cardinal.mk F)) (Cardinal.lift.{u, v} (Cardinal.mk ↑s))) Cardinal.aleph0)","decl":"theorem lift_cardinalMk_adjoin_le {E : Type v} [Field E] [Algebra F E] (s : Set E) :\n    Cardinal.lift.{u} #(adjoin F s) ≤ Cardinal.lift.{v} #F ⊔ Cardinal.lift.{u} #s ⊔ ℵ₀ := by\n  rw [show ↥(adjoin F s) = (adjoin F s).toSubfield from rfl, adjoin_toSubfield]\n  apply (Cardinal.lift_le.mpr (Subfield.cardinalMk_closure_le_max _)).trans\n  rw [lift_max, sup_le_iff, lift_aleph0]\n  refine ⟨(Cardinal.lift_le.mpr ((mk_union_le _ _).trans <| add_le_max _ _)).trans ?_, le_sup_right⟩\n  simp_rw [lift_max, lift_aleph0, sup_assoc]\n  exact sup_le_sup_right mk_range_le_lift _\n\n"}
{"name":"IntermediateField.cardinalMk_adjoin_le","module":"Mathlib.FieldTheory.IntermediateField.Adjoin.Basic","initialProofState":"F : Type u\ninst✝² : Field F\nE : Type u\ninst✝¹ : Field E\ninst✝ : Algebra F E\ns : Set E\n⊢ LE.le (Cardinal.mk (Subtype fun x => Membership.mem (IntermediateField.adjoin F s) x)) (Max.max (Max.max (Cardinal.mk F) (Cardinal.mk ↑s)) Cardinal.aleph0)","decl":"theorem cardinalMk_adjoin_le {E : Type u} [Field E] [Algebra F E] (s : Set E) :\n    #(adjoin F s) ≤ #F ⊔ #s ⊔ ℵ₀ := by\n  simpa using lift_cardinalMk_adjoin_le F s\n\n"}
