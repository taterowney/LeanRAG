{"name":"CategoryTheory.isFiltered_of_isFiltered_costructuredArrow","module":"Mathlib.CategoryTheory.Filtered.CostructuredArrow","initialProofState":"A : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} B\nT : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\ninst✝² : CategoryTheory.IsFiltered B\ninst✝¹ : R.Final\ninst✝ : ∀ (b : B), CategoryTheory.IsFiltered (CategoryTheory.CostructuredArrow L (R.obj b))\n⊢ CategoryTheory.IsFiltered A","decl":"/-- Given functors `L : A ⥤ T` and `R : B ⥤ T` with a common codomain we can conclude that `A`\nis filtered given that `R` is final, `B` is filtered and each costructured arrow category\n`CostructuredArrow L (R.obj b)` is filtered. -/\ntheorem isFiltered_of_isFiltered_costructuredArrow (L : A ⥤ T) (R : B ⥤ T)\n    [IsFiltered B] [Final R] [∀ b, IsFiltered (CostructuredArrow L (R.obj b))] : IsFiltered A := by\n  let sA : A ≌ AsSmall.{max u₁ u₂ u₃ v₁ v₂ v₃} A := AsSmall.equiv\n  let sB : B ≌ AsSmall.{max u₁ u₂ u₃ v₁ v₂ v₃} B := AsSmall.equiv\n  let sT : T ≌ AsSmall.{max u₁ u₂ u₃ v₁ v₂ v₃} T := AsSmall.equiv\n  let sC : ∀ b, CostructuredArrow (sA.inverse ⋙ L ⋙ sT.functor)\n      ((sB.inverse ⋙ R ⋙ sT.functor).obj ⟨b⟩) ≌ CostructuredArrow L (R.obj b) := fun b =>\n    (CostructuredArrow.pre sA.inverse (L ⋙ sT.functor) _).asEquivalence.trans\n      (CostructuredArrow.post L sT.functor _).asEquivalence.symm\n  haveI : ∀ b, IsFiltered (CostructuredArrow _ ((sB.inverse ⋙ R ⋙ sT.functor).obj b)) :=\n    fun b => IsFiltered.of_equivalence (sC b.1).symm\n  haveI := isFiltered_of_isFiltered_costructuredArrow_small\n    (sA.inverse ⋙ L ⋙ sT.functor) (sB.inverse ⋙ R ⋙ sT.functor)\n  exact IsFiltered.of_equivalence sA.symm\n\n"}
