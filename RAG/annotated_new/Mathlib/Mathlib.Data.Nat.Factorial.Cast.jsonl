{"name":"Nat.cast_ascFactorial","module":"Mathlib.Data.Nat.Factorial.Cast","initialProofState":"S : Type u_1\ninst✝ : Semiring S\na b : Nat\n⊢ Eq (↑(a.ascFactorial b)) (Polynomial.eval (↑a) (ascPochhammer S b))","decl":"theorem cast_ascFactorial : (a.ascFactorial b : S) = (ascPochhammer S b).eval (a : S) := by\n  rw [← ascPochhammer_nat_eq_ascFactorial, ascPochhammer_eval_cast]\n\n-- Porting note: added type ascription around a - (b - 1)\n"}
{"name":"Nat.cast_descFactorial","module":"Mathlib.Data.Nat.Factorial.Cast","initialProofState":"S : Type u_1\ninst✝ : Semiring S\na b : Nat\n⊢ Eq (↑(a.descFactorial b)) (Polynomial.eval (↑(HSub.hSub a (HSub.hSub b 1))) (ascPochhammer S b))","decl":"theorem cast_descFactorial :\n    (a.descFactorial b : S) = (ascPochhammer S b).eval (a - (b - 1) : S) := by\n  rw [← ascPochhammer_eval_cast, ascPochhammer_nat_eq_descFactorial]\n  induction' b with b\n  · simp\n  · simp_rw [add_succ, Nat.add_one_sub_one]\n    obtain h | h := le_total a b\n    · rw [descFactorial_of_lt (lt_succ_of_le h), descFactorial_of_lt (lt_succ_of_le _)]\n      rw [tsub_eq_zero_iff_le.mpr h, zero_add]\n    · rw [tsub_add_cancel_of_le h]\n\n"}
{"name":"Nat.cast_factorial","module":"Mathlib.Data.Nat.Factorial.Cast","initialProofState":"S : Type u_1\ninst✝ : Semiring S\na : Nat\n⊢ Eq (↑a.factorial) (Polynomial.eval 1 (ascPochhammer S a))","decl":"theorem cast_factorial : (a ! : S) = (ascPochhammer S a).eval 1 := by\n  rw [← one_ascFactorial, cast_ascFactorial, cast_one]\n\n"}
{"name":"Nat.cast_descFactorial_two","module":"Mathlib.Data.Nat.Factorial.Cast","initialProofState":"S : Type u_1\ninst✝ : Ring S\na : Nat\n⊢ Eq (↑(a.descFactorial 2)) (HMul.hMul (↑a) (HSub.hSub (↑a) 1))","decl":"/-- Convenience lemma. The `a - 1` is not using truncated subtraction, as opposed to the definition\nof `Nat.descFactorial` as a natural. -/\ntheorem cast_descFactorial_two : (a.descFactorial 2 : S) = a * (a - 1) := by\n  rw [cast_descFactorial]\n  cases a\n  · simp\n  · rw [succ_sub_succ, tsub_zero, cast_succ, add_sub_cancel_right, ascPochhammer_succ_right,\n      ascPochhammer_one, Polynomial.X_mul, Polynomial.eval_mul_X, Polynomial.eval_add,\n      Polynomial.eval_X, cast_one, Polynomial.eval_one]\n\n"}
