{"name":"HomologicalComplex.extend.isZero_X","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nc : ComplexShape ι\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c\ni : Option ι\nhi : Eq i Option.none\n⊢ CategoryTheory.Limits.IsZero (HomologicalComplex.extend.X K i)","decl":"lemma isZero_X {i : Option ι} (hi : i = none) :\n    IsZero (X K i) := by\n  subst hi\n  exact Limits.isZero_zero _\n\n"}
{"name":"HomologicalComplex.extend.d_none_eq_zero","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nc : ComplexShape ι\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c\ni j : Option ι\nhi : Eq i Option.none\n⊢ Eq (HomologicalComplex.extend.d K i j) 0","decl":"lemma d_none_eq_zero (i j : Option ι) (hi : i = none) :\n    d K i j = 0 := by subst hi; rfl\n\n"}
{"name":"HomologicalComplex.extend.d_none_eq_zero'","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nc : ComplexShape ι\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c\ni j : Option ι\nhj : Eq j Option.none\n⊢ Eq (HomologicalComplex.extend.d K i j) 0","decl":"lemma d_none_eq_zero' (i j : Option ι) (hj : j = none) :\n    d K i j = 0 := by subst hj; cases i <;> rfl\n\n"}
{"name":"HomologicalComplex.extend.d_eq","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nc : ComplexShape ι\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c\ni j : Option ι\na b : ι\nhi : Eq i (Option.some a)\nhj : Eq j (Option.some b)\n⊢ Eq (HomologicalComplex.extend.d K i j) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.extend.XIso K hi).hom (CategoryTheory.CategoryStruct.comp (K.d a b) (HomologicalComplex.extend.XIso K hj).inv))","decl":"lemma d_eq {i j : Option ι} {a b : ι} (hi : i = some a) (hj : j = some b) :\n    d K i j = (XIso K hi).hom ≫ K.d a b ≫ (XIso K hj).inv := by\n  subst hi hj\n  dsimp [XIso, d]\n  erw [id_comp, comp_id]\n\n"}
{"name":"HomologicalComplex.extend.XOpIso_hom_d_op_assoc","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nc : ComplexShape ι\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c\ni j : Option ι\nZ : Opposite C\nh : Quiver.Hom { unop := HomologicalComplex.extend.X K j } Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.extend.XOpIso K i).hom (CategoryTheory.CategoryStruct.comp (HomologicalComplex.extend.d K j i).op h)) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.extend.d K.op i j) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.extend.XOpIso K j).hom h))","decl":"@[reassoc]\nlemma XOpIso_hom_d_op (i j : Option ι) :\n    (XOpIso K i).hom ≫ (d K j i).op =\n      d K.op i j ≫ (XOpIso K j).hom :=\n  match i, j with\n  | none, _ => by\n      simp only [d_none_eq_zero, d_none_eq_zero', comp_zero, zero_comp, op_zero]\n  | some i, some j => by\n      dsimp [XOpIso]\n      simp only [d_eq _ rfl rfl, Option.some.injEq, d_eq, op_comp, assoc,\n        id_comp, comp_id]\n      rfl\n  | some _, none => by\n      simp only [d_none_eq_zero, d_none_eq_zero', comp_zero, zero_comp, op_zero]\n\n"}
{"name":"HomologicalComplex.extend.XOpIso_hom_d_op","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nc : ComplexShape ι\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c\ni j : Option ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.extend.XOpIso K i).hom (HomologicalComplex.extend.d K j i).op) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.extend.d K.op i j) (HomologicalComplex.extend.XOpIso K j).hom)","decl":"@[reassoc]\nlemma XOpIso_hom_d_op (i j : Option ι) :\n    (XOpIso K i).hom ≫ (d K j i).op =\n      d K.op i j ≫ (XOpIso K j).hom :=\n  match i, j with\n  | none, _ => by\n      simp only [d_none_eq_zero, d_none_eq_zero', comp_zero, zero_comp, op_zero]\n  | some i, some j => by\n      dsimp [XOpIso]\n      simp only [d_eq _ rfl rfl, Option.some.injEq, d_eq, op_comp, assoc,\n        id_comp, comp_id]\n      rfl\n  | some _, none => by\n      simp only [d_none_eq_zero, d_none_eq_zero', comp_zero, zero_comp, op_zero]\n\n"}
{"name":"HomologicalComplex.extend.mapX_some","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nc : ComplexShape ι\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK L : HomologicalComplex C c\nφ : Quiver.Hom K L\ni : Option ι\na : ι\nhi : Eq i (Option.some a)\n⊢ Eq (HomologicalComplex.extend.mapX φ i) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.extend.XIso K hi).hom (CategoryTheory.CategoryStruct.comp (φ.f a) (HomologicalComplex.extend.XIso L hi).inv))","decl":"lemma mapX_some {i : Option ι} {a : ι} (hi : i = some a) :\n    mapX φ i = (XIso K hi).hom ≫ φ.f a ≫ (XIso L hi).inv := by\n  subst hi\n  dsimp [XIso]\n  erw [id_comp, comp_id]\n  rfl\n\n"}
{"name":"HomologicalComplex.extend.mapX_none","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nc : ComplexShape ι\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK L : HomologicalComplex C c\nφ : Quiver.Hom K L\ni : Option ι\nhi : Eq i Option.none\n⊢ Eq (HomologicalComplex.extend.mapX φ i) 0","decl":"lemma mapX_none {i : Option ι} (hi : i = none) :\n    mapX φ i = 0 := by subst hi; rfl\n\n"}
{"name":"HomologicalComplex.isZero_extend_X'","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni' : ι'\nhi' : Eq (e.r i') Option.none\n⊢ CategoryTheory.Limits.IsZero ((K.extend e).X i')","decl":"lemma isZero_extend_X' (i' : ι') (hi' : e.r i' = none) :\n    IsZero ((K.extend e).X i') :=\n  extend.isZero_X K hi'\n\n"}
{"name":"HomologicalComplex.isZero_extend_X","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni' : ι'\nhi' : ∀ (i : ι), Ne (e.f i) i'\n⊢ CategoryTheory.Limits.IsZero ((K.extend e).X i')","decl":"lemma isZero_extend_X (i' : ι') (hi' : ∀ i, e.f i ≠ i') :\n    IsZero ((K.extend e).X i') :=\n  K.isZero_extend_X' e i' (by\n    obtain hi'|⟨i, hi⟩ := (e.r i').eq_none_or_eq_some\n    · exact hi'\n    · exfalso\n      exact hi' _ (e.f_eq_of_r_eq_some hi))\n\n"}
{"name":"HomologicalComplex.instIsStrictlySupportedExtend","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c\ne : c.Embedding c'\n⊢ (K.extend e).IsStrictlySupported e","decl":"instance : (K.extend e).IsStrictlySupported e where\n  isZero i' hi' := K.isZero_extend_X e i' hi'\n\n"}
{"name":"HomologicalComplex.extend_d_eq","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni' j' : ι'\ni j : ι\nhi : Eq (e.f i) i'\nhj : Eq (e.f j) j'\n⊢ Eq ((K.extend e).d i' j') (CategoryTheory.CategoryStruct.comp (K.extendXIso e hi).hom (CategoryTheory.CategoryStruct.comp (K.d i j) (K.extendXIso e hj).inv))","decl":"lemma extend_d_eq {i' j' : ι'} {i j : ι} (hi : e.f i = i') (hj : e.f j = j') :\n    (K.extend e).d i' j' = (K.extendXIso e hi).hom ≫ K.d i j ≫\n      (K.extendXIso e hj).inv := by\n  apply extend.d_eq\n\n"}
{"name":"HomologicalComplex.extend_d_from_eq_zero","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni' j' : ι'\ni : ι\nhi : Eq (e.f i) i'\nhi' : Not (c.Rel i (c.next i))\n⊢ Eq ((K.extend e).d i' j') 0","decl":"lemma extend_d_from_eq_zero (i' j' : ι') (i : ι) (hi : e.f i = i') (hi' : ¬ c.Rel i (c.next i)) :\n    (K.extend e).d i' j' = 0 := by\n  obtain hj'|⟨j, hj⟩ := (e.r j').eq_none_or_eq_some\n  · exact extend.d_none_eq_zero' _ _ _ hj'\n  · rw [extend_d_eq K e hi (e.f_eq_of_r_eq_some hj), K.shape, zero_comp, comp_zero]\n    intro hij\n    obtain rfl := c.next_eq' hij\n    exact hi' hij\n\n"}
{"name":"HomologicalComplex.extend_d_to_eq_zero","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni' j' : ι'\nj : ι\nhj : Eq (e.f j) j'\nhj' : Not (c.Rel (c.prev j) j)\n⊢ Eq ((K.extend e).d i' j') 0","decl":"lemma extend_d_to_eq_zero (i' j' : ι') (j : ι) (hj : e.f j = j') (hj' : ¬ c.Rel (c.prev j) j) :\n    (K.extend e).d i' j' = 0 := by\n  obtain hi'|⟨i, hi⟩ := (e.r i').eq_none_or_eq_some\n  · exact extend.d_none_eq_zero _ _ _ hi'\n  · rw [extend_d_eq K e (e.f_eq_of_r_eq_some hi) hj, K.shape, zero_comp, comp_zero]\n    intro hij\n    obtain rfl := c.prev_eq' hij\n    exact hj' hij\n\n"}
{"name":"HomologicalComplex.extendMap_f","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK L : HomologicalComplex C c\nφ : Quiver.Hom K L\ne : c.Embedding c'\ni : ι\ni' : ι'\nh : Eq (e.f i) i'\n⊢ Eq ((HomologicalComplex.extendMap φ e).f i') (CategoryTheory.CategoryStruct.comp (K.extendXIso e h).hom (CategoryTheory.CategoryStruct.comp (φ.f i) (L.extendXIso e h).inv))","decl":"lemma extendMap_f {i : ι} {i' : ι'} (h : e.f i = i') :\n    (extendMap φ e).f i' =\n      (extendXIso K e h).hom ≫ φ.f i ≫ (extendXIso L e h).inv := by\n  dsimp [extendMap]\n  rw [extend.mapX_some φ (e.r_eq_some h)]\n  rfl\n\n"}
{"name":"HomologicalComplex.extendMap_f_eq_zero","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK L : HomologicalComplex C c\nφ : Quiver.Hom K L\ne : c.Embedding c'\ni' : ι'\nhi' : ∀ (i : ι), Ne (e.f i) i'\n⊢ Eq ((HomologicalComplex.extendMap φ e).f i') 0","decl":"lemma extendMap_f_eq_zero (i' : ι') (hi' : ∀ i, e.f i ≠ i') :\n    (extendMap φ e).f i' = 0 := by\n  dsimp [extendMap]\n  rw [extend.mapX_none φ (e.r_eq_none i' hi')]\n\n"}
{"name":"HomologicalComplex.extendMap_comp_assoc","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK L M : HomologicalComplex C c\nφ : Quiver.Hom K L\nφ' : Quiver.Hom L M\ne : c.Embedding c'\nZ : HomologicalComplex C c'\nh : Quiver.Hom (M.extend e) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.extendMap (CategoryTheory.CategoryStruct.comp φ φ') e) h) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.extendMap φ e) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.extendMap φ' e) h))","decl":"@[reassoc, simp]\nlemma extendMap_comp :\n    extendMap (φ ≫ φ') e = extendMap φ e ≫ extendMap φ' e := by\n  ext i'\n  by_cases hi' : ∃ i, e.f i = i'\n  · obtain ⟨i, hi⟩ := hi'\n    simp [extendMap_f _ e hi]\n  · simp [extendMap_f_eq_zero _ e i' (fun i hi => hi' ⟨i, hi⟩)]\n\n"}
{"name":"HomologicalComplex.extendMap_comp","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK L M : HomologicalComplex C c\nφ : Quiver.Hom K L\nφ' : Quiver.Hom L M\ne : c.Embedding c'\n⊢ Eq (HomologicalComplex.extendMap (CategoryTheory.CategoryStruct.comp φ φ') e) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.extendMap φ e) (HomologicalComplex.extendMap φ' e))","decl":"@[reassoc, simp]\nlemma extendMap_comp :\n    extendMap (φ ≫ φ') e = extendMap φ e ≫ extendMap φ' e := by\n  ext i'\n  by_cases hi' : ∃ i, e.f i = i'\n  · obtain ⟨i, hi⟩ := hi'\n    simp [extendMap_f _ e hi]\n  · simp [extendMap_f_eq_zero _ e i' (fun i hi => hi' ⟨i, hi⟩)]\n\n"}
{"name":"HomologicalComplex.extendMap_id_f","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni' : ι'\n⊢ Eq ((HomologicalComplex.extendMap (CategoryTheory.CategoryStruct.id K) e).f i') (CategoryTheory.CategoryStruct.id ((K.extend e).X i'))","decl":"lemma extendMap_id_f (i' : ι') : (extendMap (𝟙 K) e).f i' = 𝟙 _ := by\n  by_cases hi' : ∃ i, e.f i = i'\n  · obtain ⟨i, hi⟩ := hi'\n    simp [extendMap_f _ e hi]\n  · apply (K.isZero_extend_X e i' (fun i hi => hi' ⟨i, hi⟩)).eq_of_src\n\n"}
{"name":"HomologicalComplex.extendMap_id","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c\ne : c.Embedding c'\n⊢ Eq (HomologicalComplex.extendMap (CategoryTheory.CategoryStruct.id K) e) (CategoryTheory.CategoryStruct.id (K.extend e))","decl":"@[simp]\nlemma extendMap_id : extendMap (𝟙 K) e = 𝟙 _ := by\n  ext i'\n  by_cases hi' : ∃ i, e.f i = i'\n  · obtain ⟨i, hi⟩ := hi'\n    simp [extendMap_f _ e hi]\n  · apply (K.isZero_extend_X e i' (fun i hi => hi' ⟨i, hi⟩)).eq_of_src\n\n"}
{"name":"HomologicalComplex.extendMap_zero","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK L : HomologicalComplex C c\ne : c.Embedding c'\n⊢ Eq (HomologicalComplex.extendMap 0 e) 0","decl":"@[simp]\nlemma extendMap_zero : extendMap (0 : K ⟶ L) e = 0 := by\n  ext i'\n  by_cases hi' : ∃ i, e.f i = i'\n  · obtain ⟨i, hi⟩ := hi'\n    simp [extendMap_f _ e hi]\n  · apply (K.isZero_extend_X e i' (fun i hi => hi' ⟨i, hi⟩)).eq_of_src\n\n"}
{"name":"HomologicalComplex.extend_op_d","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni' j' : ι'\n⊢ Eq ((K.op.extend e.op).d i' j') (CategoryTheory.CategoryStruct.comp ((K.extendOpIso e).hom.f i') (CategoryTheory.CategoryStruct.comp ((K.extend e).d j' i').op ((K.extendOpIso e).inv.f j')))","decl":"@[reassoc]\nlemma extend_op_d (i' j' : ι') :\n    (K.op.extend e.op).d i' j' =\n      (K.extendOpIso e).hom.f i' ≫ ((K.extend e).d j' i').op ≫\n        (K.extendOpIso e).inv.f j' := by\n  have := (K.extendOpIso e).inv.comm i' j'\n  dsimp at this\n  rw [← this, ← comp_f_assoc, Iso.hom_inv_id, id_f, id_comp]\n\n"}
{"name":"HomologicalComplex.extend_op_d_assoc","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c\ne : c.Embedding c'\ni' j' : ι'\nZ : Opposite C\nh : Quiver.Hom ((K.op.extend e.op).X j') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((K.op.extend e.op).d i' j') h) (CategoryTheory.CategoryStruct.comp ((K.extendOpIso e).hom.f i') (CategoryTheory.CategoryStruct.comp ((K.extend e).d j' i').op (CategoryTheory.CategoryStruct.comp ((K.extendOpIso e).inv.f j') h)))","decl":"@[reassoc]\nlemma extend_op_d (i' j' : ι') :\n    (K.op.extend e.op).d i' j' =\n      (K.extendOpIso e).hom.f i' ≫ ((K.extend e).d j' i').op ≫\n        (K.extendOpIso e).inv.f j' := by\n  have := (K.extendOpIso e).inv.comm i' j'\n  dsimp at this\n  rw [← this, ← comp_f_assoc, Iso.hom_inv_id, id_f, id_comp]\n\n"}
{"name":"HomologicalComplex.extendMap_add","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Preadditive C\nK L : HomologicalComplex C c\nφ φ' : Quiver.Hom K L\ne : c.Embedding c'\n⊢ Eq (HomologicalComplex.extendMap (HAdd.hAdd φ φ') e) (HAdd.hAdd (HomologicalComplex.extendMap φ e) (HomologicalComplex.extendMap φ' e))","decl":"@[simp]\nlemma extendMap_add [Preadditive C] {K L : HomologicalComplex C c} (φ φ' : K ⟶ L)\n    (e : c.Embedding c') : extendMap (φ + φ' : K ⟶ L) e = extendMap φ e + extendMap φ' e := by\n  ext i'\n  by_cases hi' : ∃ i, e.f i = i'\n  · obtain ⟨i, hi⟩ := hi'\n    simp [extendMap_f _ e hi]\n  · apply (K.isZero_extend_X e i' (fun i hi => hi' ⟨i, hi⟩)).eq_of_src\n\n"}
{"name":"ComplexShape.Embedding.extendFunctor_obj","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nK : HomologicalComplex C c\n⊢ Eq ((e.extendFunctor C).obj K) (K.extend e)","decl":"/-- Given an embedding `e : c.Embedding c'` of complex shapes, this is\nthe functor `HomologicalComplex C c ⥤ HomologicalComplex C c'` which\nextend complexes along `e`: the extended complexes are zero\nin the degrees that are not in the image of `e.f`. -/\n@[simps]\nnoncomputable def extendFunctor [HasZeroMorphisms C] :\n    HomologicalComplex C c ⥤ HomologicalComplex C c' where\n  obj K := K.extend e\n  map φ := HomologicalComplex.extendMap φ e\n\n"}
{"name":"ComplexShape.Embedding.extendFunctor_map","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX✝ Y✝ : HomologicalComplex C c\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq ((e.extendFunctor C).map φ) (HomologicalComplex.extendMap φ e)","decl":"/-- Given an embedding `e : c.Embedding c'` of complex shapes, this is\nthe functor `HomologicalComplex C c ⥤ HomologicalComplex C c'` which\nextend complexes along `e`: the extended complexes are zero\nin the degrees that are not in the image of `e.f`. -/\n@[simps]\nnoncomputable def extendFunctor [HasZeroMorphisms C] :\n    HomologicalComplex C c ⥤ HomologicalComplex C c' where\n  obj K := K.extend e\n  map φ := HomologicalComplex.extendMap φ e\n\n"}
{"name":"ComplexShape.Embedding.instPreservesZeroMorphismsHomologicalComplexExtendFunctor","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\n⊢ (e.extendFunctor C).PreservesZeroMorphisms","decl":"instance [HasZeroMorphisms C] : (e.extendFunctor C).PreservesZeroMorphisms where\n\n"}
{"name":"ComplexShape.Embedding.instAdditiveHomologicalComplexExtendFunctor","module":"Mathlib.Algebra.Homology.Embedding.Extend","initialProofState":"ι : Type u_1\nι' : Type u_2\nc : ComplexShape ι\nc' : ComplexShape ι'\ne : c.Embedding c'\nC : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝ : CategoryTheory.Preadditive C\n⊢ (e.extendFunctor C).Additive","decl":"instance [Preadditive C] : (e.extendFunctor C).Additive where\n\n"}
