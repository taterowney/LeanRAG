{"name":"CategoryTheory.Iso.app_hom","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F G\nX : C\n‚ä¢ Eq (Œ±.app X).hom (Œ±.hom.app X)","decl":"/-- The application of a natural isomorphism to an object. We put this definition in a different\nnamespace, so that we can use `Œ±.app` -/\n@[simps]\ndef app {F G : C ‚•§ D} (Œ± : F ‚âÖ G) (X : C) :\n    F.obj X ‚âÖ G.obj X where\n  hom := Œ±.hom.app X\n  inv := Œ±.inv.app X\n  hom_inv_id := by rw [‚Üê comp_app, Iso.hom_inv_id]; rfl\n  inv_hom_id := by rw [‚Üê comp_app, Iso.inv_hom_id]; rfl\n\n"}
{"name":"CategoryTheory.Iso.app_inv","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F G\nX : C\n‚ä¢ Eq (Œ±.app X).inv (Œ±.inv.app X)","decl":"/-- The application of a natural isomorphism to an object. We put this definition in a different\nnamespace, so that we can use `Œ±.app` -/\n@[simps]\ndef app {F G : C ‚•§ D} (Œ± : F ‚âÖ G) (X : C) :\n    F.obj X ‚âÖ G.obj X where\n  hom := Œ±.hom.app X\n  inv := Œ±.inv.app X\n  hom_inv_id := by rw [‚Üê comp_app, Iso.hom_inv_id]; rfl\n  inv_hom_id := by rw [‚Üê comp_app, Iso.inv_hom_id]; rfl\n\n"}
{"name":"CategoryTheory.Iso.hom_inv_id_app_assoc","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F G\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Œ±.hom.app X) (CategoryTheory.CategoryStruct.comp (Œ±.inv.app X) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem hom_inv_id_app {F G : C ‚•§ D} (Œ± : F ‚âÖ G) (X : C) :\n    Œ±.hom.app X ‚â´ Œ±.inv.app X = ùüô (F.obj X) :=\n  congr_fun (congr_arg NatTrans.app Œ±.hom_inv_id) X\n\n"}
{"name":"CategoryTheory.Iso.hom_inv_id_app","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F G\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Œ±.hom.app X) (Œ±.inv.app X)) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"@[reassoc (attr := simp)]\ntheorem hom_inv_id_app {F G : C ‚•§ D} (Œ± : F ‚âÖ G) (X : C) :\n    Œ±.hom.app X ‚â´ Œ±.inv.app X = ùüô (F.obj X) :=\n  congr_fun (congr_arg NatTrans.app Œ±.hom_inv_id) X\n\n"}
{"name":"CategoryTheory.Iso.inv_hom_id_app_assoc","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F G\nX : C\nZ : D\nh : Quiver.Hom (G.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Œ±.inv.app X) (CategoryTheory.CategoryStruct.comp (Œ±.hom.app X) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem inv_hom_id_app {F G : C ‚•§ D} (Œ± : F ‚âÖ G) (X : C) :\n    Œ±.inv.app X ‚â´ Œ±.hom.app X = ùüô (G.obj X) :=\n  congr_fun (congr_arg NatTrans.app Œ±.inv_hom_id) X\n\n"}
{"name":"CategoryTheory.Iso.inv_hom_id_app","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F G\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Œ±.inv.app X) (Œ±.hom.app X)) (CategoryTheory.CategoryStruct.id (G.obj X))","decl":"@[reassoc (attr := simp)]\ntheorem inv_hom_id_app {F G : C ‚•§ D} (Œ± : F ‚âÖ G) (X : C) :\n    Œ±.inv.app X ‚â´ Œ±.hom.app X = ùüô (G.obj X) :=\n  congr_fun (congr_arg NatTrans.app Œ±.inv_hom_id) X\n\n"}
{"name":"CategoryTheory.Iso.hom_inv_id_app_app_assoc","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF G : CategoryTheory.Functor C (CategoryTheory.Functor D E)\ne : CategoryTheory.Iso F G\nX‚ÇÅ : C\nX‚ÇÇ : D\nZ : E\nh : Quiver.Hom ((F.obj X‚ÇÅ).obj X‚ÇÇ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((e.hom.app X‚ÇÅ).app X‚ÇÇ) (CategoryTheory.CategoryStruct.comp ((e.inv.app X‚ÇÅ).app X‚ÇÇ) h)) h","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id_app_app {F G : C ‚•§ D ‚•§ E} (e : F ‚âÖ G) (X‚ÇÅ : C) (X‚ÇÇ : D) :\n    (e.hom.app X‚ÇÅ).app X‚ÇÇ ‚â´ (e.inv.app X‚ÇÅ).app X‚ÇÇ = ùüô _ := by\n  rw [‚Üê NatTrans.comp_app, Iso.hom_inv_id_app, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.Iso.hom_inv_id_app_app","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF G : CategoryTheory.Functor C (CategoryTheory.Functor D E)\ne : CategoryTheory.Iso F G\nX‚ÇÅ : C\nX‚ÇÇ : D\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((e.hom.app X‚ÇÅ).app X‚ÇÇ) ((e.inv.app X‚ÇÅ).app X‚ÇÇ)) (CategoryTheory.CategoryStruct.id ((F.obj X‚ÇÅ).obj X‚ÇÇ))","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id_app_app {F G : C ‚•§ D ‚•§ E} (e : F ‚âÖ G) (X‚ÇÅ : C) (X‚ÇÇ : D) :\n    (e.hom.app X‚ÇÅ).app X‚ÇÇ ‚â´ (e.inv.app X‚ÇÅ).app X‚ÇÇ = ùüô _ := by\n  rw [‚Üê NatTrans.comp_app, Iso.hom_inv_id_app, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.Iso.inv_hom_id_app_app_assoc","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF G : CategoryTheory.Functor C (CategoryTheory.Functor D E)\ne : CategoryTheory.Iso F G\nX‚ÇÅ : C\nX‚ÇÇ : D\nZ : E\nh : Quiver.Hom ((G.obj X‚ÇÅ).obj X‚ÇÇ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((e.inv.app X‚ÇÅ).app X‚ÇÇ) (CategoryTheory.CategoryStruct.comp ((e.hom.app X‚ÇÅ).app X‚ÇÇ) h)) h","decl":"@[reassoc (attr := simp)]\nlemma inv_hom_id_app_app {F G : C ‚•§ D ‚•§ E} (e : F ‚âÖ G) (X‚ÇÅ : C) (X‚ÇÇ : D) :\n    (e.inv.app X‚ÇÅ).app X‚ÇÇ ‚â´ (e.hom.app X‚ÇÅ).app X‚ÇÇ = ùüô _ := by\n  rw [‚Üê NatTrans.comp_app, Iso.inv_hom_id_app, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.Iso.inv_hom_id_app_app","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF G : CategoryTheory.Functor C (CategoryTheory.Functor D E)\ne : CategoryTheory.Iso F G\nX‚ÇÅ : C\nX‚ÇÇ : D\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((e.inv.app X‚ÇÅ).app X‚ÇÇ) ((e.hom.app X‚ÇÅ).app X‚ÇÇ)) (CategoryTheory.CategoryStruct.id ((G.obj X‚ÇÅ).obj X‚ÇÇ))","decl":"@[reassoc (attr := simp)]\nlemma inv_hom_id_app_app {F G : C ‚•§ D ‚•§ E} (e : F ‚âÖ G) (X‚ÇÅ : C) (X‚ÇÇ : D) :\n    (e.inv.app X‚ÇÅ).app X‚ÇÇ ‚â´ (e.hom.app X‚ÇÅ).app X‚ÇÇ = ùüô _ := by\n  rw [‚Üê NatTrans.comp_app, Iso.inv_hom_id_app, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.Iso.hom_inv_id_app_app_app","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nE' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} E'\nF G : CategoryTheory.Functor C (CategoryTheory.Functor D (CategoryTheory.Functor E E'))\ne : CategoryTheory.Iso F G\nX‚ÇÅ : C\nX‚ÇÇ : D\nX‚ÇÉ : E\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((e.hom.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ) (((e.inv.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ)) (CategoryTheory.CategoryStruct.id (((F.obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ))","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id_app_app_app {F G : C ‚•§ D ‚•§ E ‚•§ E'} (e : F ‚âÖ G)\n    (X‚ÇÅ : C) (X‚ÇÇ : D) (X‚ÇÉ : E) :\n    ((e.hom.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ ‚â´ ((e.inv.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ = ùüô _ := by\n  rw [‚Üê NatTrans.comp_app, ‚Üê NatTrans.comp_app, Iso.hom_inv_id_app,\n    NatTrans.id_app, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.Iso.hom_inv_id_app_app_app_assoc","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nE' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} E'\nF G : CategoryTheory.Functor C (CategoryTheory.Functor D (CategoryTheory.Functor E E'))\ne : CategoryTheory.Iso F G\nX‚ÇÅ : C\nX‚ÇÇ : D\nX‚ÇÉ : E\nZ : E'\nh : Quiver.Hom (((F.obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((e.hom.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ) (CategoryTheory.CategoryStruct.comp (((e.inv.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ) h)) h","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id_app_app_app {F G : C ‚•§ D ‚•§ E ‚•§ E'} (e : F ‚âÖ G)\n    (X‚ÇÅ : C) (X‚ÇÇ : D) (X‚ÇÉ : E) :\n    ((e.hom.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ ‚â´ ((e.inv.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ = ùüô _ := by\n  rw [‚Üê NatTrans.comp_app, ‚Üê NatTrans.comp_app, Iso.hom_inv_id_app,\n    NatTrans.id_app, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.Iso.inv_hom_id_app_app_app_assoc","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nE' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} E'\nF G : CategoryTheory.Functor C (CategoryTheory.Functor D (CategoryTheory.Functor E E'))\ne : CategoryTheory.Iso F G\nX‚ÇÅ : C\nX‚ÇÇ : D\nX‚ÇÉ : E\nZ : E'\nh : Quiver.Hom (((G.obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((e.inv.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ) (CategoryTheory.CategoryStruct.comp (((e.hom.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ) h)) h","decl":"@[reassoc (attr := simp)]\nlemma inv_hom_id_app_app_app {F G : C ‚•§ D ‚•§ E ‚•§ E'} (e : F ‚âÖ G)\n    (X‚ÇÅ : C) (X‚ÇÇ : D) (X‚ÇÉ : E) :\n    ((e.inv.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ ‚â´ ((e.hom.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ = ùüô _ := by\n  rw [‚Üê NatTrans.comp_app, ‚Üê NatTrans.comp_app, Iso.inv_hom_id_app,\n    NatTrans.id_app, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.Iso.inv_hom_id_app_app_app","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nE' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} E'\nF G : CategoryTheory.Functor C (CategoryTheory.Functor D (CategoryTheory.Functor E E'))\ne : CategoryTheory.Iso F G\nX‚ÇÅ : C\nX‚ÇÇ : D\nX‚ÇÉ : E\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((e.inv.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ) (((e.hom.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ)) (CategoryTheory.CategoryStruct.id (((G.obj X‚ÇÅ).obj X‚ÇÇ).obj X‚ÇÉ))","decl":"@[reassoc (attr := simp)]\nlemma inv_hom_id_app_app_app {F G : C ‚•§ D ‚•§ E ‚•§ E'} (e : F ‚âÖ G)\n    (X‚ÇÅ : C) (X‚ÇÇ : D) (X‚ÇÉ : E) :\n    ((e.inv.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ ‚â´ ((e.hom.app X‚ÇÅ).app X‚ÇÇ).app X‚ÇÉ = ùüô _ := by\n  rw [‚Üê NatTrans.comp_app, ‚Üê NatTrans.comp_app, Iso.inv_hom_id_app,\n    NatTrans.id_app, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.NatIso.trans_app","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G H : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F G\nŒ≤ : CategoryTheory.Iso G H\nX : C\n‚ä¢ Eq ((Œ±.trans Œ≤).app X) ((Œ±.app X).trans (Œ≤.app X))","decl":"@[simp]\ntheorem trans_app {F G H : C ‚•§ D} (Œ± : F ‚âÖ G) (Œ≤ : G ‚âÖ H) (X : C) :\n    (Œ± ‚â™‚â´ Œ≤).app X = Œ±.app X ‚â™‚â´ Œ≤.app X :=\n  rfl\n\n"}
{"name":"CategoryTheory.NatIso.app_hom","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F G\nX : C\n‚ä¢ Eq (Œ±.app X).hom (Œ±.hom.app X)","decl":"theorem app_hom {F G : C ‚•§ D} (Œ± : F ‚âÖ G) (X : C) : (Œ±.app X).hom = Œ±.hom.app X :=\n  rfl\n\n"}
{"name":"CategoryTheory.NatIso.app_inv","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F G\nX : C\n‚ä¢ Eq (Œ±.app X).inv (Œ±.inv.app X)","decl":"theorem app_inv {F G : C ‚•§ D} (Œ± : F ‚âÖ G) (X : C) : (Œ±.app X).inv = Œ±.inv.app X :=\n  rfl\n\n"}
{"name":"CategoryTheory.NatIso.hom_app_isIso","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F G\nX : C\n‚ä¢ CategoryTheory.IsIso (Œ±.hom.app X)","decl":"instance hom_app_isIso (Œ± : F ‚âÖ G) (X : C) : IsIso (Œ±.hom.app X) :=\n  ‚ü®‚ü®Œ±.inv.app X,\n    ‚ü®by rw [‚Üê comp_app, Iso.hom_inv_id, ‚Üê id_app], by rw [‚Üê comp_app, Iso.inv_hom_id, ‚Üê id_app]‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.NatIso.inv_app_isIso","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F G\nX : C\n‚ä¢ CategoryTheory.IsIso (Œ±.inv.app X)","decl":"instance inv_app_isIso (Œ± : F ‚âÖ G) (X : C) : IsIso (Œ±.inv.app X) :=\n  ‚ü®‚ü®Œ±.hom.app X,\n    ‚ü®by rw [‚Üê comp_app, Iso.inv_hom_id, ‚Üê id_app], by rw [‚Üê comp_app, Iso.hom_inv_id, ‚Üê id_app]‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.NatIso.cancel_natIso_hom_left","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F G\nX : C\nZ : D\ng g' : Quiver.Hom (G.obj X) Z\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp (Œ±.hom.app X) g) (CategoryTheory.CategoryStruct.comp (Œ±.hom.app X) g')) (Eq g g')","decl":"@[simp]\ntheorem cancel_natIso_hom_left {X : C} {Z : D} (g g' : G.obj X ‚ü∂ Z) :\n    Œ±.hom.app X ‚â´ g = Œ±.hom.app X ‚â´ g' ‚Üî g = g' := by simp only [cancel_epi, refl]\n\n"}
{"name":"CategoryTheory.NatIso.cancel_natIso_inv_left","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F G\nX : C\nZ : D\ng g' : Quiver.Hom (F.obj X) Z\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp (Œ±.inv.app X) g) (CategoryTheory.CategoryStruct.comp (Œ±.inv.app X) g')) (Eq g g')","decl":"@[simp]\ntheorem cancel_natIso_inv_left {X : C} {Z : D} (g g' : F.obj X ‚ü∂ Z) :\n    Œ±.inv.app X ‚â´ g = Œ±.inv.app X ‚â´ g' ‚Üî g = g' := by simp only [cancel_epi, refl]\n\n"}
{"name":"CategoryTheory.NatIso.cancel_natIso_hom_right","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F G\nX : D\nY : C\nf f' : Quiver.Hom X (F.obj Y)\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f (Œ±.hom.app Y)) (CategoryTheory.CategoryStruct.comp f' (Œ±.hom.app Y))) (Eq f f')","decl":"@[simp]\ntheorem cancel_natIso_hom_right {X : D} {Y : C} (f f' : X ‚ü∂ F.obj Y) :\n    f ‚â´ Œ±.hom.app Y = f' ‚â´ Œ±.hom.app Y ‚Üî f = f' := by simp only [cancel_mono, refl]\n\n"}
{"name":"CategoryTheory.NatIso.cancel_natIso_inv_right","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F G\nX : D\nY : C\nf f' : Quiver.Hom X (G.obj Y)\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f (Œ±.inv.app Y)) (CategoryTheory.CategoryStruct.comp f' (Œ±.inv.app Y))) (Eq f f')","decl":"@[simp]\ntheorem cancel_natIso_inv_right {X : D} {Y : C} (f f' : X ‚ü∂ G.obj Y) :\n    f ‚â´ Œ±.inv.app Y = f' ‚â´ Œ±.inv.app Y ‚Üî f = f' := by simp only [cancel_mono, refl]\n\n"}
{"name":"CategoryTheory.NatIso.cancel_natIso_hom_right_assoc","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F G\nW X X' : D\nY : C\nf : Quiver.Hom W X\ng : Quiver.Hom X (F.obj Y)\nf' : Quiver.Hom W X'\ng' : Quiver.Hom X' (F.obj Y)\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g (Œ±.hom.app Y))) (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.CategoryStruct.comp g' (Œ±.hom.app Y)))) (Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f' g'))","decl":"@[simp]\ntheorem cancel_natIso_hom_right_assoc {W X X' : D} {Y : C} (f : W ‚ü∂ X) (g : X ‚ü∂ F.obj Y)\n    (f' : W ‚ü∂ X') (g' : X' ‚ü∂ F.obj Y) :\n    f ‚â´ g ‚â´ Œ±.hom.app Y = f' ‚â´ g' ‚â´ Œ±.hom.app Y ‚Üî f ‚â´ g = f' ‚â´ g' := by\n  simp only [‚Üê Category.assoc, cancel_mono, refl]\n\n"}
{"name":"CategoryTheory.NatIso.cancel_natIso_inv_right_assoc","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F G\nW X X' : D\nY : C\nf : Quiver.Hom W X\ng : Quiver.Hom X (G.obj Y)\nf' : Quiver.Hom W X'\ng' : Quiver.Hom X' (G.obj Y)\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g (Œ±.inv.app Y))) (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.CategoryStruct.comp g' (Œ±.inv.app Y)))) (Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f' g'))","decl":"@[simp]\ntheorem cancel_natIso_inv_right_assoc {W X X' : D} {Y : C} (f : W ‚ü∂ X) (g : X ‚ü∂ G.obj Y)\n    (f' : W ‚ü∂ X') (g' : X' ‚ü∂ G.obj Y) :\n    f ‚â´ g ‚â´ Œ±.inv.app Y = f' ‚â´ g' ‚â´ Œ±.inv.app Y ‚Üî f ‚â´ g = f' ‚â´ g' := by\n  simp only [‚Üê Category.assoc, cancel_mono, refl]\n\n"}
{"name":"CategoryTheory.NatIso.inv_inv_app","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F G\nX : C\n‚ä¢ Eq (CategoryTheory.inv (e.inv.app X)) (e.hom.app X)","decl":"@[simp]\ntheorem inv_inv_app {F G : C ‚•§ D} (e : F ‚âÖ G) (X : C) : inv (e.inv.app X) = e.hom.app X := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.NatIso.naturality_1","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nX Y : C\nŒ± : CategoryTheory.Iso F G\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Œ±.inv.app X) (CategoryTheory.CategoryStruct.comp (F.map f) (Œ±.hom.app Y))) (G.map f)","decl":"theorem naturality_1 (Œ± : F ‚âÖ G) (f : X ‚ü∂ Y) : Œ±.inv.app X ‚â´ F.map f ‚â´ Œ±.hom.app Y = G.map f := by\n  simp\n\n"}
{"name":"CategoryTheory.NatIso.naturality_2","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nX Y : C\nŒ± : CategoryTheory.Iso F G\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Œ±.hom.app X) (CategoryTheory.CategoryStruct.comp (G.map f) (Œ±.inv.app Y))) (F.map f)","decl":"theorem naturality_2 (Œ± : F ‚âÖ G) (f : X ‚ü∂ Y) : Œ±.hom.app X ‚â´ G.map f ‚â´ Œ±.inv.app Y = F.map f := by\n  simp\n\n"}
{"name":"CategoryTheory.NatIso.naturality_1'","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nX Y : C\nŒ± : Quiver.Hom F G\nf : Quiver.Hom X Y\nx‚úù : CategoryTheory.IsIso (Œ±.app X)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (Œ±.app X)) (CategoryTheory.CategoryStruct.comp (F.map f) (Œ±.app Y))) (G.map f)","decl":"theorem naturality_1' (Œ± : F ‚ü∂ G) (f : X ‚ü∂ Y) {_ : IsIso (Œ±.app X)} :\n    inv (Œ±.app X) ‚â´ F.map f ‚â´ Œ±.app Y = G.map f := by simp\n\n"}
{"name":"CategoryTheory.NatIso.naturality_2'_assoc","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nX Y : C\nŒ± : Quiver.Hom F G\nf : Quiver.Hom X Y\nx‚úù : CategoryTheory.IsIso (Œ±.app Y)\nZ : D\nh : Quiver.Hom (F.obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Œ±.app X) (CategoryTheory.CategoryStruct.comp (G.map f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv (Œ±.app Y)) h))) (CategoryTheory.CategoryStruct.comp (F.map f) h)","decl":"@[reassoc (attr := simp)]\ntheorem naturality_2' (Œ± : F ‚ü∂ G) (f : X ‚ü∂ Y) {_ : IsIso (Œ±.app Y)} :\n    Œ±.app X ‚â´ G.map f ‚â´ inv (Œ±.app Y) = F.map f := by\n  rw [‚Üê Category.assoc, ‚Üê naturality, Category.assoc, IsIso.hom_inv_id, Category.comp_id]\n\n"}
{"name":"CategoryTheory.NatIso.naturality_2'","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nX Y : C\nŒ± : Quiver.Hom F G\nf : Quiver.Hom X Y\nx‚úù : CategoryTheory.IsIso (Œ±.app Y)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Œ±.app X) (CategoryTheory.CategoryStruct.comp (G.map f) (CategoryTheory.inv (Œ±.app Y)))) (F.map f)","decl":"@[reassoc (attr := simp)]\ntheorem naturality_2' (Œ± : F ‚ü∂ G) (f : X ‚ü∂ Y) {_ : IsIso (Œ±.app Y)} :\n    Œ±.app X ‚â´ G.map f ‚â´ inv (Œ±.app Y) = F.map f := by\n  rw [‚Üê Category.assoc, ‚Üê naturality, Category.assoc, IsIso.hom_inv_id, Category.comp_id]\n\n"}
{"name":"CategoryTheory.NatIso.isIso_app_of_isIso","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : Quiver.Hom F G\ninst‚úù : CategoryTheory.IsIso Œ±\nX : C\n‚ä¢ CategoryTheory.IsIso (Œ±.app X)","decl":"/-- The components of a natural isomorphism are isomorphisms.\n-/\ninstance isIso_app_of_isIso (Œ± : F ‚ü∂ G) [IsIso Œ±] (X) : IsIso (Œ±.app X) :=\n  ‚ü®‚ü®(inv Œ±).app X,\n      ‚ü®congr_fun (congr_arg NatTrans.app (IsIso.hom_inv_id Œ±)) X,\n        congr_fun (congr_arg NatTrans.app (IsIso.inv_hom_id Œ±)) X‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.NatIso.isIso_inv_app","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : Quiver.Hom F G\nx‚úù : CategoryTheory.IsIso Œ±\nX : C\n‚ä¢ Eq ((CategoryTheory.inv Œ±).app X) (CategoryTheory.inv (Œ±.app X))","decl":"@[simp]\ntheorem isIso_inv_app (Œ± : F ‚ü∂ G) {_ : IsIso Œ±} (X) : (inv Œ±).app X = inv (Œ±.app X) := by\n  -- Porting note: the next lemma used to be in `ext`, but that is no longer allowed.\n  -- We've added an aesop apply rule;\n  -- it would be nice to have a hook to run those without aesop warning it didn't close the goal.\n  apply IsIso.eq_inv_of_hom_inv_id\n  rw [‚Üê NatTrans.comp_app]\n  simp\n\n"}
{"name":"CategoryTheory.NatIso.inv_map_inv_app","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nX Y : C\ne : CategoryTheory.Iso X Y\nZ : D\n‚ä¢ Eq (CategoryTheory.inv ((F.map e.inv).app Z)) ((F.map e.hom).app Z)","decl":"@[simp]\ntheorem inv_map_inv_app (F : C ‚•§ D ‚•§ E) {X Y : C} (e : X ‚âÖ Y) (Z : D) :\n    inv ((F.map e.inv).app Z) = (F.map e.hom).app Z := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.NatIso.ofComponents_inv_app","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\napp : (X : C) ‚Üí CategoryTheory.Iso (F.obj X) (G.obj X)\nnaturality : autoParam (‚àÄ {X Y : C} (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (app Y).hom) (CategoryTheory.CategoryStruct.comp (app X).hom (G.map f))) _auto‚úù\nX : C\n‚ä¢ Eq ((CategoryTheory.NatIso.ofComponents app naturality).inv.app X) (app X).inv","decl":"/-- Construct a natural isomorphism between functors by giving object level isomorphisms,\nand checking naturality only in the forward direction.\n-/\n@[simps]\ndef ofComponents (app : ‚àÄ X : C, F.obj X ‚âÖ G.obj X)\n    (naturality : ‚àÄ {X Y : C} (f : X ‚ü∂ Y),\n      F.map f ‚â´ (app Y).hom = (app X).hom ‚â´ G.map f := by aesop_cat) :\n    F ‚âÖ G where\n  hom := { app := fun X => (app X).hom }\n  inv :=\n    { app := fun X => (app X).inv,\n      naturality := fun X Y f => by\n        have h := congr_arg (fun f => (app X).inv ‚â´ f ‚â´ (app Y).inv) (naturality f).symm\n        simp only [Iso.inv_hom_id_assoc, Iso.hom_inv_id, assoc, comp_id, cancel_mono] at h\n        exact h }\n\n"}
{"name":"CategoryTheory.NatIso.ofComponents_hom_app","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\napp : (X : C) ‚Üí CategoryTheory.Iso (F.obj X) (G.obj X)\nnaturality : autoParam (‚àÄ {X Y : C} (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (app Y).hom) (CategoryTheory.CategoryStruct.comp (app X).hom (G.map f))) _auto‚úù\nX : C\n‚ä¢ Eq ((CategoryTheory.NatIso.ofComponents app naturality).hom.app X) (app X).hom","decl":"/-- Construct a natural isomorphism between functors by giving object level isomorphisms,\nand checking naturality only in the forward direction.\n-/\n@[simps]\ndef ofComponents (app : ‚àÄ X : C, F.obj X ‚âÖ G.obj X)\n    (naturality : ‚àÄ {X Y : C} (f : X ‚ü∂ Y),\n      F.map f ‚â´ (app Y).hom = (app X).hom ‚â´ G.map f := by aesop_cat) :\n    F ‚âÖ G where\n  hom := { app := fun X => (app X).hom }\n  inv :=\n    { app := fun X => (app X).inv,\n      naturality := fun X Y f => by\n        have h := congr_arg (fun f => (app X).inv ‚â´ f ‚â´ (app Y).inv) (naturality f).symm\n        simp only [Iso.inv_hom_id_assoc, Iso.hom_inv_id, assoc, comp_id, cancel_mono] at h\n        exact h }\n\n"}
{"name":"CategoryTheory.NatIso.ofComponents.app","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\napp' : (X : C) ‚Üí CategoryTheory.Iso (F.obj X) (G.obj X)\nnaturality : ‚àÄ {X Y : C} (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (F.map f) (app' Y).hom) (CategoryTheory.CategoryStruct.comp (app' X).hom (G.map f))\nX : C\n‚ä¢ Eq ((CategoryTheory.NatIso.ofComponents app' naturality).app X) (app' X)","decl":"@[simp]\ntheorem ofComponents.app (app' : ‚àÄ X : C, F.obj X ‚âÖ G.obj X) (naturality) (X) :\n    (ofComponents app' naturality).app X = app' X := by aesop\n\n-- Making this an instance would cause a typeclass inference loop with `isIso_app_of_isIso`.\n"}
{"name":"CategoryTheory.NatIso.isIso_of_isIso_app","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nŒ± : Quiver.Hom F G\ninst‚úù : ‚àÄ (X : C), CategoryTheory.IsIso (Œ±.app X)\n‚ä¢ CategoryTheory.IsIso Œ±","decl":"/-- A natural transformation is an isomorphism if all its components are isomorphisms.\n-/\ntheorem isIso_of_isIso_app (Œ± : F ‚ü∂ G) [‚àÄ X : C, IsIso (Œ±.app X)] : IsIso Œ± :=\n  (ofComponents (fun X => asIso (Œ±.app X)) (by simp)).isIso_hom\n\n"}
{"name":"CategoryTheory.NatIso.hcomp_hom","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF G : CategoryTheory.Functor C D\nH I : CategoryTheory.Functor D E\nŒ± : CategoryTheory.Iso F G\nŒ≤ : CategoryTheory.Iso H I\n‚ä¢ Eq (CategoryTheory.NatIso.hcomp Œ± Œ≤).hom (CategoryTheory.NatTrans.hcomp Œ±.hom Œ≤.hom)","decl":"/-- Horizontal composition of natural isomorphisms. -/\n@[simps]\ndef hcomp {F G : C ‚•§ D} {H I : D ‚•§ E} (Œ± : F ‚âÖ G) (Œ≤ : H ‚âÖ I) : F ‚ãô H ‚âÖ G ‚ãô I := by\n  refine ‚ü®Œ±.hom ‚ó´ Œ≤.hom, Œ±.inv ‚ó´ Œ≤.inv, ?_, ?_‚ü©\n  ¬∑ ext\n    rw [‚Üê NatTrans.exchange]\n    simp\n  ext; rw [‚Üê NatTrans.exchange]; simp\n\n"}
{"name":"CategoryTheory.NatIso.hcomp_inv","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF G : CategoryTheory.Functor C D\nH I : CategoryTheory.Functor D E\nŒ± : CategoryTheory.Iso F G\nŒ≤ : CategoryTheory.Iso H I\n‚ä¢ Eq (CategoryTheory.NatIso.hcomp Œ± Œ≤).inv (CategoryTheory.NatTrans.hcomp Œ±.inv Œ≤.inv)","decl":"/-- Horizontal composition of natural isomorphisms. -/\n@[simps]\ndef hcomp {F G : C ‚•§ D} {H I : D ‚•§ E} (Œ± : F ‚âÖ G) (Œ≤ : H ‚âÖ I) : F ‚ãô H ‚âÖ G ‚ãô I := by\n  refine ‚ü®Œ±.hom ‚ó´ Œ≤.hom, Œ±.inv ‚ó´ Œ≤.inv, ?_, ?_‚ü©\n  ¬∑ ext\n    rw [‚Üê NatTrans.exchange]\n    simp\n  ext; rw [‚Üê NatTrans.exchange]; simp\n\n"}
{"name":"CategoryTheory.NatIso.isIso_map_iff","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F‚ÇÅ F‚ÇÇ\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Iff (CategoryTheory.IsIso (F‚ÇÅ.map f)) (CategoryTheory.IsIso (F‚ÇÇ.map f))","decl":"theorem isIso_map_iff {F‚ÇÅ F‚ÇÇ : C ‚•§ D} (e : F‚ÇÅ ‚âÖ F‚ÇÇ) {X Y : C} (f : X ‚ü∂ Y) :\n    IsIso (F‚ÇÅ.map f) ‚Üî IsIso (F‚ÇÇ.map f) := by\n  revert F‚ÇÅ F‚ÇÇ\n  suffices ‚àÄ {F‚ÇÅ F‚ÇÇ : C ‚•§ D} (_ : F‚ÇÅ ‚âÖ F‚ÇÇ) (_ : IsIso (F‚ÇÅ.map f)), IsIso (F‚ÇÇ.map f) by\n    exact fun F‚ÇÅ F‚ÇÇ e => ‚ü®this e, this e.symm‚ü©\n  intro F‚ÇÅ F‚ÇÇ e hf\n  refine IsIso.mk ‚ü®e.inv.app Y ‚â´ inv (F‚ÇÅ.map f) ‚â´ e.hom.app X, ?_, ?_‚ü©\n  ¬∑ simp only [NatTrans.naturality_assoc, IsIso.hom_inv_id_assoc, Iso.inv_hom_id_app]\n  ¬∑ simp only [assoc, ‚Üê e.hom.naturality, IsIso.inv_hom_id_assoc, Iso.inv_hom_id_app]\n\n"}
{"name":"CategoryTheory.NatTrans.isIso_iff_isIso_app","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\nœÑ : Quiver.Hom F G\n‚ä¢ Iff (CategoryTheory.IsIso œÑ) (‚àÄ (X : C), CategoryTheory.IsIso (œÑ.app X))","decl":"lemma NatTrans.isIso_iff_isIso_app {F G : C ‚•§ D} (œÑ : F ‚ü∂ G) :\n    IsIso œÑ ‚Üî ‚àÄ X, IsIso (œÑ.app X) :=\n  ‚ü®fun _ ‚Ü¶ inferInstance, fun _ ‚Ü¶ NatIso.isIso_of_isIso_app _‚ü©\n\n"}
{"name":"CategoryTheory.Functor.copyObj_obj","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nobj : C ‚Üí D\ne : (X : C) ‚Üí CategoryTheory.Iso (F.obj X) (obj X)\na‚úù : C\n‚ä¢ Eq ((F.copyObj obj e).obj a‚úù) (obj a‚úù)","decl":"/-- Constructor for a functor that is isomorphic to a given functor `F : C ‚•§ D`,\nwhile being definitionally equal on objects to a given map `obj : C ‚Üí D`\nsuch that for all `X : C`, we have an isomorphism `F.obj X ‚âÖ obj X`. -/\n@[simps obj]\ndef copyObj : C ‚•§ D where\n  obj := obj\n  map f := (e _).inv ‚â´ F.map f ‚â´ (e _).hom\n\n"}
{"name":"CategoryTheory.Functor.isoCopyObj_hom_app","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nobj : C ‚Üí D\ne : (X : C) ‚Üí CategoryTheory.Iso (F.obj X) (obj X)\nX : C\n‚ä¢ Eq ((F.isoCopyObj obj e).hom.app X) (e X).hom","decl":"/-- The functor constructed with `copyObj` is isomorphic to the given functor. -/\n@[simps!]\ndef isoCopyObj : F ‚âÖ F.copyObj obj e :=\n  NatIso.ofComponents e (by simp [Functor.copyObj])\n\n"}
{"name":"CategoryTheory.Functor.isoCopyObj_inv_app","module":"Mathlib.CategoryTheory.NatIso","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nobj : C ‚Üí D\ne : (X : C) ‚Üí CategoryTheory.Iso (F.obj X) (obj X)\nX : C\n‚ä¢ Eq ((F.isoCopyObj obj e).inv.app X) (e X).inv","decl":"/-- The functor constructed with `copyObj` is isomorphic to the given functor. -/\n@[simps!]\ndef isoCopyObj : F ‚âÖ F.copyObj obj e :=\n  NatIso.ofComponents e (by simp [Functor.copyObj])\n\n"}
