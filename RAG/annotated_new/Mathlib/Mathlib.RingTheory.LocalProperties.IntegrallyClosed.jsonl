{"name":"IsIntegrallyClosed.of_localization_maximal","module":"Mathlib.RingTheory.LocalProperties.IntegrallyClosed","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nh : ∀ (p : Ideal R), Ne p Bot.bot → ∀ [inst : p.IsMaximal], IsIntegrallyClosed (Localization.AtPrime p)\n⊢ IsIntegrallyClosed R","decl":"/-- An integral domain `R` is integral closed if `Rₘ` is integral closed\n  for any maximal ideal `m` of `R`. -/\ntheorem IsIntegrallyClosed.of_localization_maximal {R : Type*} [CommRing R] [IsDomain R]\n    (h : ∀ p : Ideal R, p ≠ ⊥ → [p.IsMaximal] → IsIntegrallyClosed (Localization.AtPrime p)) :\n    IsIntegrallyClosed R := by\n  by_cases hf : IsField R\n  · exact hf.toField.instIsIntegrallyClosed\n  apply (isIntegrallyClosed_iff (FractionRing R)).mpr\n  rintro ⟨x⟩ hx\n  let I : Ideal R := span {x.2.1} / span {x.1}\n  have h1 : 1 ∈ I := by\n    apply I.eq_top_iff_one.mp\n    by_contra hn\n    rcases I.exists_le_maximal hn with ⟨p, hpm, hpi⟩\n    have hic := h p (Ring.ne_bot_of_isMaximal_of_not_isField hpm hf)\n    have hxp : IsIntegral (Localization.AtPrime p) (mk x.1 x.2) := hx.tower_top\n    /- `x.1 / x.2.1 ∈ Rₚ` since it is integral over `Rₚ` and `Rₚ` is integrally closed.\n      More precisely, `x.1 / x.2.1 = y.1 / y.2.1` where `y.1, y.2.1 ∈ R` and `y.2.1 ∉ p`. -/\n    rcases (isIntegrallyClosed_iff (FractionRing R)).mp hic hxp with ⟨⟨y⟩, hy⟩\n    /- `y.2.1 ∈ I` since for all `a ∈ Ideal.span {x.1}`, say `a = b * x.1`,\n      we have `y.2 * a = b * x.1 * y.2 = b * y.1 * x.2.1 ∈ Ideal.span {x.2.1}`. -/\n    have hyi : y.2.1 ∈ I := by\n      intro a ha\n      rcases mem_span_singleton'.mp ha with ⟨b, hb⟩\n      apply mem_span_singleton'.mpr ⟨b * y.1, _⟩\n      rw [← hb, ← mul_assoc, mul_comm y.2.1 b, mul_assoc, mul_assoc]\n      exact congrArg (HMul.hMul b) <| (mul_comm y.1 x.2.1).trans <|\n        NoZeroSMulDivisors.algebraMap_injective R (Localization R⁰) <| mk'_eq_iff_eq.mp <|\n          (mk'_eq_algebraMap_mk'_of_submonoid_le _ _ p.primeCompl_le_nonZeroDivisors y.1 y.2).trans\n            <| show algebraMap (Localization.AtPrime p) _ (mk' _ y.1 y.2) = mk' _ x.1 x.2\n              by simpa only [← mk_eq_mk', ← hy] using by rfl\n    -- `y.2.1 ∈ I` implies `y.2.1 ∈ p` since `I ⊆ p`, which contradicts to the choice of `y`.\n    exact y.2.2 (hpi hyi)\n  rcases mem_span_singleton'.mp (h1 x.1 (mem_span_singleton_self x.1)) with ⟨y, hy⟩\n  exact ⟨y, (eq_mk'_of_mul_eq (hy.trans (one_mul x.1))).trans (mk_eq_mk'_apply x.1 x.2).symm⟩\n\n"}
{"name":"isIntegrallyClosed_ofLocalizationMaximal","module":"Mathlib.RingTheory.LocalProperties.IntegrallyClosed","initialProofState":"⊢ OfLocalizationMaximal fun R x => ∀ [inst : IsDomain R], IsIntegrallyClosed R","decl":"theorem isIntegrallyClosed_ofLocalizationMaximal :\n    OfLocalizationMaximal fun R _ => ([IsDomain R] → IsIntegrallyClosed R) :=\n  fun _ _ h _ ↦ IsIntegrallyClosed.of_localization_maximal fun p _ hpm ↦ h p hpm\n"}
