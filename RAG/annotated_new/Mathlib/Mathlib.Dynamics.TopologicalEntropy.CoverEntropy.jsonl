{"name":"Dynamics.IsDynCoverOf.of_le","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nm n : Nat\nm_n : LE.le m n\ns : Set X\nh : Dynamics.IsDynCoverOf T F U n s\n⊢ Dynamics.IsDynCoverOf T F U m s","decl":"lemma IsDynCoverOf.of_le {T : X → X} {F : Set X} {U : Set (X × X)} {m n : ℕ} (m_n : m ≤ n)\n    {s : Set X} (h : IsDynCoverOf T F U n s) :\n    IsDynCoverOf T F U m s := by\n  exact Subset.trans (c := ⋃ x ∈ s, ball x (dynEntourage T U m)) h\n    (iUnion₂_mono fun x _ ↦ ball_mono (dynEntourage_antitone T U m_n) x)\n\n"}
{"name":"Dynamics.IsDynCoverOf.of_entourage_subset","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU V : Set (Prod X X)\nU_V : HasSubset.Subset U V\nn : Nat\ns : Set X\nh : Dynamics.IsDynCoverOf T F U n s\n⊢ Dynamics.IsDynCoverOf T F V n s","decl":"lemma IsDynCoverOf.of_entourage_subset {T : X → X} {F : Set X} {U V : Set (X × X)} (U_V : U ⊆ V)\n    {n : ℕ} {s : Set X} (h : IsDynCoverOf T F U n s) :\n    IsDynCoverOf T F V n s := by\n  exact Subset.trans (c := ⋃ x ∈ s, ball x (dynEntourage T V n)) h\n    (iUnion₂_mono fun x _ ↦ ball_mono (dynEntourage_monotone T n U_V) x)\n\n"}
{"name":"Dynamics.isDynCoverOf_empty","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nU : Set (Prod X X)\nn : Nat\ns : Set X\n⊢ Dynamics.IsDynCoverOf T EmptyCollection.emptyCollection U n s","decl":"@[simp]\nlemma isDynCoverOf_empty {T : X → X} {U : Set (X × X)} {n : ℕ} {s : Set X} :\n    IsDynCoverOf T ∅ U n s := by\n  simp only [IsDynCoverOf, empty_subset]\n\n"}
{"name":"Dynamics.IsDynCoverOf.nonempty","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nh : F.Nonempty\nU : Set (Prod X X)\nn : Nat\ns : Set X\nh' : Dynamics.IsDynCoverOf T F U n s\n⊢ s.Nonempty","decl":"lemma IsDynCoverOf.nonempty {T : X → X} {F : Set X} (h : F.Nonempty) {U : Set (X × X)} {n : ℕ}\n    {s : Set X} (h' : IsDynCoverOf T F U n s) :\n    s.Nonempty := by\n  rcases nonempty_biUnion.1 (Nonempty.mono h' h) with ⟨x, x_s, _⟩\n  exact nonempty_of_mem x_s\n\n"}
{"name":"Dynamics.isDynCoverOf_zero","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\ns : Set X\nh : s.Nonempty\n⊢ Dynamics.IsDynCoverOf T F U 0 s","decl":"lemma isDynCoverOf_zero (T : X → X) (F : Set X) (U : Set (X × X)) {s : Set X} (h : s.Nonempty) :\n    IsDynCoverOf T F U 0 s := by\n  simp only [IsDynCoverOf, ball, dynEntourage, not_lt_zero', Prod.map_iterate, iInter_of_empty,\n    iInter_univ, preimage_univ]\n  rcases h with ⟨x, x_s⟩\n  exact subset_iUnion₂_of_subset x x_s (subset_univ F)\n\n"}
{"name":"Dynamics.isDynCoverOf_univ","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nn : Nat\ns : Set X\nh : s.Nonempty\n⊢ Dynamics.IsDynCoverOf T F Set.univ n s","decl":"lemma isDynCoverOf_univ (T : X → X) (F : Set X) (n : ℕ) {s : Set X} (h : s.Nonempty) :\n    IsDynCoverOf T F univ n s := by\n  simp only [IsDynCoverOf, ball, dynEntourage, Prod.map_iterate, preimage_univ, iInter_univ,\n    iUnion_coe_set]\n  rcases h with ⟨x, x_s⟩\n  exact subset_iUnion₂_of_subset x x_s (subset_univ F)\n\n"}
{"name":"Dynamics.IsDynCoverOf.nonempty_inter","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nn : Nat\ns : Finset X\nh : Dynamics.IsDynCoverOf T F U n ↑s\n⊢ Exists fun t => And (Dynamics.IsDynCoverOf T F U n ↑t) (And (LE.le t.card s.card) (∀ (x : X), Membership.mem t x → (Inter.inter (UniformSpace.ball x (Dynamics.dynEntourage T U n)) F).Nonempty))","decl":"lemma IsDynCoverOf.nonempty_inter {T : X → X} {F : Set X} {U : Set (X × X)} {n : ℕ} {s : Finset X}\n    (h : IsDynCoverOf T F U n s) :\n    ∃ t : Finset X, IsDynCoverOf T F U n t ∧ t.card ≤ s.card\n    ∧ ∀ x ∈ t, ((ball x (dynEntourage T U n)) ∩ F).Nonempty := by\n  classical\n  use Finset.filter (fun x : X ↦ ((ball x (dynEntourage T U n)) ∩ F).Nonempty) s\n  simp only [Finset.coe_filter, Finset.mem_filter, and_imp, imp_self, implies_true, and_true]\n  refine ⟨fun y y_F ↦ ?_, Finset.card_mono (Finset.filter_subset _ s)⟩\n  specialize h y_F\n  simp only [Finset.coe_sort_coe, mem_iUnion, Subtype.exists, exists_prop] at h\n  rcases h with ⟨z, z_s, y_Bz⟩\n  simp only [coe_setOf, mem_setOf_eq, mem_iUnion, Subtype.exists, exists_prop]\n  exact ⟨z, ⟨z_s, nonempty_of_mem ⟨y_Bz, y_F⟩⟩, y_Bz⟩\n\n"}
{"name":"Dynamics.IsDynCoverOf.iterate_le_pow","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_symm : SymmetricRel U\nm n : Nat\ns : Finset X\nh : Dynamics.IsDynCoverOf T F U m ↑s\n⊢ Exists fun t => And (Dynamics.IsDynCoverOf T F (compRel U U) (HMul.hMul m n) ↑t) (LE.le t.card (HPow.hPow s.card n))","decl":"/-- From a dynamical cover `s` with entourage `U` and time `m`, we construct covers with entourage\n`U ○ U` and any multiple `m * n` of `m` with controlled cardinality. This lemma is the first step\nin a submultiplicative-like property of `coverMincard`, with consequences such as explicit bounds\nfor the topological entropy (`coverEntropyInfEntourage_le_card_div`) and an equality between\ntwo notions of topological entropy (`coverEntropyInf_eq_coverEntropySup_of_inv`).-/\nlemma IsDynCoverOf.iterate_le_pow {T : X → X} {F : Set X} (F_inv : MapsTo T F F) {U : Set (X × X)}\n    (U_symm : SymmetricRel U) {m : ℕ} (n : ℕ) {s : Finset X} (h : IsDynCoverOf T F U m s) :\n    ∃ t : Finset X, IsDynCoverOf T F (U ○ U) (m * n) t ∧ t.card ≤ s.card ^ n := by\n  classical\n  -- Deal with the edge cases: `F = ∅` or `m = 0`.\n  rcases F.eq_empty_or_nonempty with rfl | F_nemp\n  · exact ⟨∅, by simp⟩\n  have _ : Nonempty X := nonempty_of_exists F_nemp\n  have s_nemp := h.nonempty F_nemp\n  rcases F_nemp with ⟨x, x_F⟩\n  rcases m.eq_zero_or_pos with rfl | m_pos\n  · use {x}\n    simp only [zero_mul, Finset.coe_singleton, Finset.card_singleton]\n    exact And.intro (isDynCoverOf_zero T F (U ○ U) (singleton_nonempty x))\n      <| one_le_pow_of_one_le' (Nat.one_le_of_lt (Finset.Nonempty.card_pos s_nemp)) n\n  -- The proof goes as follows. Given an orbit of length `(m * n)` starting from `y`, each of its\n  -- iterates `y`, `T^[m] y`, `T^[m]^[2] y` ... is `(dynEntourage T U m)`-close to a point of `s`.\n  -- Conversely, given a sequence `t 0`, `t 1`, `t 2` of points in `s`, we choose a point\n  -- `z = dyncover t` such that  `z`, `T^[m] z`, `T^[m]^[2] z` ... are `(dynEntourage T U m)`-close\n  --  to `t 0`, `t 1`, `t 2`... Then  `y`, `T^[m] y`, `T^[m]^[2] y` ... are\n  -- `(dynEntourage T (U ○ U) m)`-close to `z`, `T^[m] z`, `T^[m]^[2] z`, so that the union of such\n  -- `z` provides the desired cover. Since there are at most `s.card ^ n` sequences of\n  -- length `n` with values in `s`, we get the upper bound we want on the cardinality.\n  -- First step: construct `dyncover`. Given `t 0`, `t 1`, `t 2`, if we cannot find such a point\n  -- `dyncover t`, we use the dummy `x`.\n  have (t : Fin n → s) : ∃ y : X, (⋂ k : Fin n, T^[m * k] ⁻¹' ball (t k) (dynEntourage T U m)) ⊆\n      ball y (dynEntourage T (U ○ U) (m * n)) := by\n    rcases (⋂ k : Fin n, T^[m * k] ⁻¹' ball (t k) (dynEntourage T U m)).eq_empty_or_nonempty\n      with inter_empt | inter_nemp\n    · exact inter_empt ▸ ⟨x, empty_subset _⟩\n    · rcases inter_nemp with ⟨y, y_int⟩\n      refine ⟨y, fun z z_int ↦ ?_⟩\n      simp only [ball, dynEntourage, Prod.map_iterate, mem_preimage, mem_iInter,\n        Prod.map_apply] at y_int z_int ⊢\n      intro k k_mn\n      replace k_mn := Nat.div_lt_of_lt_mul k_mn\n      specialize z_int ⟨(k / m), k_mn⟩ (k % m) (Nat.mod_lt k m_pos)\n      specialize y_int ⟨(k / m), k_mn⟩ (k % m) (Nat.mod_lt k m_pos)\n      rw [← Function.iterate_add_apply T (k % m) (m * (k / m)), Nat.mod_add_div k m] at y_int z_int\n      exact mem_comp_of_mem_ball U_symm y_int z_int\n  choose! dyncover h_dyncover using this\n  -- The cover we want is the set of all `dyncover t`, that is, `range dyncover`. We need to check\n  -- that it is indeed a `(U ○ U, m * n)` cover, and that its cardinality is at most `card s ^ n`.\n  -- Only the first point requires significant work.\n  let sn := range dyncover\n  have := fintypeRange dyncover\n  refine ⟨sn.toFinset, ?_, ?_⟩\n  · -- We implement the argument at the beginning: given `y ∈ F`, we extract `t 0`, `t 1`, `t 2`\n    -- such that `y`, `T^[m] y`, `T^[m]^[2] y` ... is `(dynEntourage T U m)`-close to `t 0`, `t 1`,\n    -- `t 2`... Then `dyncover t` is a point of `range dyncover` which satisfies the conclusion\n    -- of the lemma.\n    rw [Finset.coe_nonempty] at s_nemp\n    have _ : Nonempty s := Finset.Nonempty.coe_sort s_nemp\n    intro y y_F\n    have key : ∀ k : Fin n, ∃ z : s, y ∈ T^[m * k] ⁻¹' ball z (dynEntourage T U m) := by\n      intro k\n      have := h (MapsTo.iterate F_inv (m * k) y_F)\n      simp only [Finset.coe_sort_coe, mem_iUnion, Subtype.exists, exists_prop] at this\n      rcases this with ⟨z, z_s, hz⟩\n      exact ⟨⟨z, z_s⟩, hz⟩\n    choose! t ht using key\n    simp only [toFinset_range, Finset.coe_image, Finset.coe_univ, image_univ, mem_range,\n      iUnion_exists, iUnion_iUnion_eq', mem_iUnion, sn]\n    use t\n    apply h_dyncover t\n    simp only [mem_iInter, mem_preimage] at ht ⊢\n    exact ht\n  · rw [toFinset_card]\n    apply (Fintype.card_range_le dyncover).trans\n    simp only [Fintype.card_fun, Fintype.card_coe, Fintype.card_fin, le_refl]\n\n"}
{"name":"Dynamics.exists_isDynCoverOf_of_isCompact_uniformContinuous","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nT : X → X\nF : Set X\nF_comp : IsCompact F\nh : UniformContinuous T\nU : Set (Prod X X)\nU_uni : Membership.mem (uniformity X) U\nn : Nat\n⊢ Exists fun s => Dynamics.IsDynCoverOf T F U n ↑s","decl":"lemma exists_isDynCoverOf_of_isCompact_uniformContinuous [UniformSpace X] {T : X → X} {F : Set X}\n    (F_comp : IsCompact F) (h : UniformContinuous T) {U : Set (X × X)} (U_uni : U ∈ 𝓤 X) (n : ℕ) :\n    ∃ s : Finset X, IsDynCoverOf T F U n s := by\n  have uni_ite := dynEntourage_mem_uniformity h U_uni n\n  let open_cover := fun x : X ↦ ball x (dynEntourage T U n)\n  obtain ⟨s, _, s_cover⟩ := IsCompact.elim_nhds_subcover F_comp open_cover\n    (fun (x : X) _ ↦ ball_mem_nhds x uni_ite)\n  exact ⟨s, s_cover⟩\n\n"}
{"name":"Dynamics.exists_isDynCoverOf_of_isCompact_invariant","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nT : X → X\nF : Set X\nF_comp : IsCompact F\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_uni : Membership.mem (uniformity X) U\nn : Nat\n⊢ Exists fun s => Dynamics.IsDynCoverOf T F U n ↑s","decl":"lemma exists_isDynCoverOf_of_isCompact_invariant [UniformSpace X] {T : X → X} {F : Set X}\n    (F_comp : IsCompact F) (F_inv : MapsTo T F F) {U : Set (X × X)} (U_uni : U ∈ 𝓤 X) (n : ℕ) :\n    ∃ s : Finset X, IsDynCoverOf T F U n s := by\n  rcases comp_symm_mem_uniformity_sets U_uni with ⟨V, V_uni, V_symm, V_U⟩\n  obtain ⟨s, _, s_cover⟩ := IsCompact.elim_nhds_subcover F_comp (fun x : X ↦ ball x V)\n    (fun (x : X) _ ↦ ball_mem_nhds x V_uni)\n  have : IsDynCoverOf T F V 1 s := by\n    simp only [IsDynCoverOf, Finset.mem_coe, dynEntourage_one, s_cover]\n  rcases this.iterate_le_pow F_inv V_symm n with ⟨t, t_dyncover, t_card⟩\n  rw [one_mul n] at t_dyncover\n  exact ⟨t, t_dyncover.of_entourage_subset V_U⟩\n\n"}
{"name":"Dynamics.IsDynCoverOf.coverMincard_le_card","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nn : Nat\ns : Finset X\nh : Dynamics.IsDynCoverOf T F U n ↑s\n⊢ LE.le (Dynamics.coverMincard T F U n) ↑s.card","decl":"lemma IsDynCoverOf.coverMincard_le_card {T : X → X} {F : Set X} {U : Set (X × X)} {n : ℕ}\n    {s : Finset X} (h : IsDynCoverOf T F U n s) :\n    coverMincard T F U n ≤ s.card := iInf₂_le s h\n\n"}
{"name":"Dynamics.coverMincard_monotone_time","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\n⊢ Monotone fun n => Dynamics.coverMincard T F U n","decl":"lemma coverMincard_monotone_time (T : X → X) (F : Set X) (U : Set (X × X)) :\n    Monotone (fun n : ℕ ↦ coverMincard T F U n) :=\n  fun _ _ m_n ↦ biInf_mono fun _ h ↦ h.of_le m_n\n\n"}
{"name":"Dynamics.coverMincard_antitone","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nn : Nat\n⊢ Antitone fun U => Dynamics.coverMincard T F U n","decl":"lemma coverMincard_antitone (T : X → X) (F : Set X) (n : ℕ) :\n    Antitone (fun U : Set (X × X) ↦ coverMincard T F U n) :=\n  fun _ _ U_V ↦ biInf_mono fun _ h ↦ h.of_entourage_subset U_V\n\n"}
{"name":"Dynamics.coverMincard_finite_iff","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nn : Nat\n⊢ Iff (LT.lt (Dynamics.coverMincard T F U n) Top.top) (Exists fun s => And (Dynamics.IsDynCoverOf T F U n ↑s) (Eq (↑s.card) (Dynamics.coverMincard T F U n)))","decl":"lemma coverMincard_finite_iff (T : X → X) (F : Set X) (U : Set (X × X)) (n : ℕ) :\n    coverMincard T F U n < ⊤ ↔\n    ∃ s : Finset X, IsDynCoverOf T F U n s ∧ s.card = coverMincard T F U n := by\n  refine ⟨fun h_fin ↦ ?_, (fun ⟨s, _, s_coverMincard⟩ ↦ s_coverMincard ▸ WithTop.coe_lt_top s.card)⟩\n  rcases WithTop.ne_top_iff_exists.1 (ne_of_lt h_fin) with ⟨k, k_min⟩\n  rw [← k_min]\n  simp only [ENat.some_eq_coe, Nat.cast_inj]\n  have : Nonempty {s : Finset X // IsDynCoverOf T F U n s} := by\n    by_contra h\n    apply ENat.coe_ne_top k\n    rw [← ENat.some_eq_coe, k_min, coverMincard, iInf₂_eq_top]\n    simp only [ENat.coe_ne_top, imp_false]\n    rw [nonempty_subtype, not_exists] at h\n    exact h\n  have key := ciInf_mem (fun s : {s : Finset X // IsDynCoverOf T F U n s} ↦ (s.val.card : ℕ∞))\n  rw [coverMincard, iInf_subtype'] at k_min\n  rw [← k_min, mem_range, Subtype.exists] at key\n  simp only [ENat.some_eq_coe, Nat.cast_inj, exists_prop] at key\n  exact key\n\n"}
{"name":"Dynamics.coverMincard_empty","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nU : Set (Prod X X)\nn : Nat\n⊢ Eq (Dynamics.coverMincard T EmptyCollection.emptyCollection U n) 0","decl":"@[simp]\nlemma coverMincard_empty {T : X → X} {U : Set (X × X)} {n : ℕ} : coverMincard T ∅ U n = 0 :=\n  (sInf_le (by simp [IsDynCoverOf])).antisymm (zero_le (coverMincard T ∅ U n))\n\n"}
{"name":"Dynamics.coverMincard_eq_zero_iff","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nn : Nat\n⊢ Iff (Eq (Dynamics.coverMincard T F U n) 0) (Eq F EmptyCollection.emptyCollection)","decl":"lemma coverMincard_eq_zero_iff (T : X → X) (F : Set X) (U : Set (X × X)) (n : ℕ) :\n    coverMincard T F U n = 0 ↔ F = ∅ := by\n  refine Iff.intro (fun h ↦ subset_empty_iff.1 ?_) (fun F_empt ↦ by rw [F_empt, coverMincard_empty])\n  have := coverMincard_finite_iff T F U n\n  rw [h, eq_true ENat.top_pos, true_iff] at this\n  simp only [IsDynCoverOf, Finset.mem_coe, Nat.cast_eq_zero, Finset.card_eq_zero, exists_eq_right,\n    Finset.not_mem_empty, iUnion_of_empty, iUnion_empty] at this\n  exact this\n\n"}
{"name":"Dynamics.one_le_coverMincard_iff","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nn : Nat\n⊢ Iff (LE.le 1 (Dynamics.coverMincard T F U n)) F.Nonempty","decl":"lemma one_le_coverMincard_iff (T : X → X) (F : Set X) (U : Set (X × X)) (n : ℕ) :\n    1 ≤ coverMincard T F U n ↔ F.Nonempty := by\n  rw [ENat.one_le_iff_ne_zero, nonempty_iff_ne_empty, not_iff_not]\n  exact coverMincard_eq_zero_iff T F U n\n\n"}
{"name":"Dynamics.coverMincard_zero","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nh : F.Nonempty\nU : Set (Prod X X)\n⊢ Eq (Dynamics.coverMincard T F U 0) 1","decl":"lemma coverMincard_zero (T : X → X) {F : Set X} (h : F.Nonempty) (U : Set (X × X)) :\n    coverMincard T F U 0 = 1 := by\n  apply le_antisymm _ ((one_le_coverMincard_iff T F U 0).2 h)\n  rcases h with ⟨x, _⟩\n  have := isDynCoverOf_zero T F U (singleton_nonempty x)\n  rw [← Finset.coe_singleton] at this\n  apply this.coverMincard_le_card.trans_eq\n  rw [Finset.card_singleton, Nat.cast_one]\n\n"}
{"name":"Dynamics.coverMincard_univ","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nh : F.Nonempty\nn : Nat\n⊢ Eq (Dynamics.coverMincard T F Set.univ n) 1","decl":"lemma coverMincard_univ (T : X → X) {F : Set X} (h : F.Nonempty) (n : ℕ) :\n    coverMincard T F univ n = 1 := by\n  apply le_antisymm _ ((one_le_coverMincard_iff T F univ n).2 h)\n  rcases h with ⟨x, _⟩\n  have := isDynCoverOf_univ T F n (singleton_nonempty x)\n  rw [← Finset.coe_singleton] at this\n  apply this.coverMincard_le_card.trans_eq\n  rw [Finset.card_singleton, Nat.cast_one]\n\n"}
{"name":"Dynamics.coverMincard_mul_le_pow","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_symm : SymmetricRel U\nm n : Nat\n⊢ LE.le (Dynamics.coverMincard T F (compRel U U) (HMul.hMul m n)) (HPow.hPow (Dynamics.coverMincard T F U m) n)","decl":"lemma coverMincard_mul_le_pow {T : X → X} {F : Set X} (F_inv : MapsTo T F F) {U : Set (X × X)}\n    (U_symm : SymmetricRel U) (m n : ℕ) :\n    coverMincard T F (U ○ U) (m * n) ≤ coverMincard T F U m ^ n := by\n  rcases F.eq_empty_or_nonempty with rfl | F_nonempty\n  · rw [coverMincard_empty]; exact zero_le _\n  rcases n.eq_zero_or_pos with rfl | n_pos\n  · rw [mul_zero, coverMincard_zero T F_nonempty (U ○ U), pow_zero]\n  rcases eq_top_or_lt_top (coverMincard T F U m) with h | h\n  · exact h ▸ (le_top (α := ℕ∞)).trans_eq (ENat.top_pow n_pos).symm\n  · rcases (coverMincard_finite_iff T F U m).1 h with ⟨s, s_cover, s_coverMincard⟩\n    rcases s_cover.iterate_le_pow F_inv U_symm n with ⟨t, t_cover, t_le_sn⟩\n    rw [← s_coverMincard]\n    exact t_cover.coverMincard_le_card.trans (WithTop.coe_le_coe.2 t_le_sn)\n\n"}
{"name":"Dynamics.coverMincard_le_pow","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_symm : SymmetricRel U\nm : Nat\nm_pos : LT.lt 0 m\nn : Nat\n⊢ LE.le (Dynamics.coverMincard T F (compRel U U) n) (HPow.hPow (Dynamics.coverMincard T F U m) (HAdd.hAdd (HDiv.hDiv n m) 1))","decl":"lemma coverMincard_le_pow {T : X → X} {F : Set X} (F_inv : MapsTo T F F) {U : Set (X × X)}\n    (U_symm : SymmetricRel U) {m : ℕ} (m_pos : 0 < m) (n : ℕ) :\n    coverMincard T F (U ○ U) n ≤ coverMincard T F U m ^ (n / m + 1) :=\n  (coverMincard_monotone_time T F (U ○ U) (Nat.lt_mul_div_succ n m_pos).le).trans\n    (coverMincard_mul_le_pow F_inv U_symm m (n / m + 1))\n\n"}
{"name":"Dynamics.coverMincard_finite_of_isCompact_uniformContinuous","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nT : X → X\nF : Set X\nF_comp : IsCompact F\nh : UniformContinuous T\nU : Set (Prod X X)\nU_uni : Membership.mem (uniformity X) U\nn : Nat\n⊢ LT.lt (Dynamics.coverMincard T F U n) Top.top","decl":"lemma coverMincard_finite_of_isCompact_uniformContinuous [UniformSpace X] {T : X → X}\n    {F : Set X} (F_comp : IsCompact F) (h : UniformContinuous T) {U : Set (X × X)} (U_uni : U ∈ 𝓤 X)\n    (n : ℕ) :\n    coverMincard T F U n < ⊤ := by\n  rcases exists_isDynCoverOf_of_isCompact_uniformContinuous F_comp h U_uni n with ⟨s, s_cover⟩\n  exact s_cover.coverMincard_le_card.trans_lt (WithTop.coe_lt_top s.card)\n\n"}
{"name":"Dynamics.coverMincard_finite_of_isCompact_invariant","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nT : X → X\nF : Set X\nF_comp : IsCompact F\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_uni : Membership.mem (uniformity X) U\nn : Nat\n⊢ LT.lt (Dynamics.coverMincard T F U n) Top.top","decl":"lemma coverMincard_finite_of_isCompact_invariant [UniformSpace X] {T : X → X} {F : Set X}\n    (F_comp : IsCompact F) (F_inv : MapsTo T F F) {U : Set (X × X)} (U_uni : U ∈ 𝓤 X) (n : ℕ) :\n    coverMincard T F U n < ⊤ := by\n  rcases exists_isDynCoverOf_of_isCompact_invariant F_comp F_inv U_uni n with ⟨s, s_cover⟩\n  exact s_cover.coverMincard_le_card.trans_lt (WithTop.coe_lt_top s.card)\n\n"}
{"name":"Dynamics.nonempty_inter_of_coverMincard","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\nn : Nat\ns : Finset X\nh : Dynamics.IsDynCoverOf T F U n ↑s\nh' : Eq (↑s.card) (Dynamics.coverMincard T F U n)\nx : X\na✝ : Membership.mem s x\n⊢ (Inter.inter F (UniformSpace.ball x (Dynamics.dynEntourage T U n))).Nonempty","decl":"/-- All dynamical balls of a minimal dynamical cover of `F` intersect `F`. This lemma is the key\n  to relate Bowen-Dinaburg's definition of topological entropy with covers and their definition\n  of topological entropy with nets.-/\nlemma nonempty_inter_of_coverMincard {T : X → X} {F : Set X} {U : Set (X × X)} {n : ℕ}\n    {s : Finset X} (h : IsDynCoverOf T F U n s) (h' : s.card = coverMincard T F U n) :\n    ∀ x ∈ s, (F ∩ ball x (dynEntourage T U n)).Nonempty := by\n  -- Otherwise, there is a ball which does not intersect `F`. Removing it yields a smaller cover.\n  classical\n  by_contra! hypo\n  rcases hypo with ⟨x, x_s, ball_empt⟩\n  have smaller_cover : IsDynCoverOf T F U n (Finset.erase s x) := by\n    intro y y_F\n    specialize h y_F\n    simp only [Finset.mem_coe, mem_iUnion, exists_prop] at h\n    rcases h with ⟨z, z_s, hz⟩\n    simp only [Finset.coe_erase, mem_diff, Finset.mem_coe, mem_singleton_iff, mem_iUnion,\n      exists_prop]\n    refine ⟨z, And.intro (And.intro z_s fun z_x ↦ not_mem_empty y ?_) hz⟩\n    rw [← ball_empt]\n    rw [z_x] at hz\n    exact mem_inter y_F hz\n  apply smaller_cover.coverMincard_le_card.not_lt\n  rw [← h']\n  exact_mod_cast Finset.card_erase_lt_of_mem x_s\n\n"}
{"name":"Dynamics.log_coverMincard_nonneg","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nh : F.Nonempty\nU : Set (Prod X X)\nn : Nat\n⊢ LE.le 0 (↑(Dynamics.coverMincard T F U n)).log","decl":"lemma log_coverMincard_nonneg (T : X → X) {F : Set X} (h : F.Nonempty) (U : Set (X × X)) (n : ℕ) :\n    0 ≤ log (coverMincard T F U n) := by\n  apply zero_le_log_iff.2\n  rw [← ENat.toENNReal_one, ENat.toENNReal_le]\n  exact (one_le_coverMincard_iff T F U n).2 h\n\n"}
{"name":"Dynamics.log_coverMincard_iterate_le","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_symm : SymmetricRel U\nm n : Nat\nn_pos : LT.lt 0 n\n⊢ LE.le (HDiv.hDiv (↑(Dynamics.coverMincard T F (compRel U U) (HMul.hMul m n))).log ↑n) (↑(Dynamics.coverMincard T F U m)).log","decl":"lemma log_coverMincard_iterate_le {T : X → X} {F : Set X} (F_inv : MapsTo T F F) {U : Set (X × X)}\n    (U_symm : SymmetricRel U) (m : ℕ) {n : ℕ} (n_pos : 0 < n) :\n    log (coverMincard T F (U ○ U) (m * n)) / n ≤ log (coverMincard T F U m) := by\n  apply (EReal.div_le_iff_le_mul (b := n) (Nat.cast_pos'.2 n_pos) (natCast_ne_top n)).2\n  rw [← log_pow, StrictMono.le_iff_le log_strictMono]\n  nth_rw 2 [← ENat.toENNRealRingHom_apply]\n  rw [← RingHom.map_pow ENat.toENNRealRingHom _ n, ENat.toENNRealRingHom_apply, ENat.toENNReal_le]\n  exact coverMincard_mul_le_pow F_inv U_symm m n\n\n"}
{"name":"Dynamics.log_coverMincard_le_add","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_symm : SymmetricRel U\nm n : Nat\nm_pos : LT.lt 0 m\nn_pos : LT.lt 0 n\n⊢ LE.le (HDiv.hDiv (↑(Dynamics.coverMincard T F (compRel U U) n)).log ↑n) (HAdd.hAdd (HDiv.hDiv (↑(Dynamics.coverMincard T F U m)).log ↑m) (HDiv.hDiv (↑(Dynamics.coverMincard T F U m)).log ↑n))","decl":"lemma log_coverMincard_le_add {T : X → X} {F : Set X} (F_inv : MapsTo T F F)\n    {U : Set (X × X)} (U_symm : SymmetricRel U) {m n : ℕ} (m_pos : 0 < m) (n_pos : 0 < n) :\n    log (coverMincard T F (U ○ U) n) / n\n    ≤ log (coverMincard T F U m) / m + log (coverMincard T F U m) / n := by\n  -- If `n` is a multiple of `m`, this follows directly from `log_coverMincard_iterate_le`.\n  -- Otherwise, we bound the LHS by the smallest multiple of `m` larger than `n`, which gives the\n  -- error term `log (coverMincard T F U m) / n`.\n  rcases F.eq_empty_or_nonempty with rfl | F_nemp\n  · rw [coverMincard_empty, ENat.toENNReal_zero, log_zero,\n      bot_div_of_pos_ne_top (Nat.cast_pos'.2 n_pos) (natCast_ne_top n)]\n    exact bot_le\n  have h_nm : (0 : EReal) ≤ (n / m : ℕ) := Nat.cast_nonneg' (n / m)\n  have h_log := log_coverMincard_nonneg T F_nemp U m\n  have n_div_n := EReal.div_self (natCast_ne_bot n) (natCast_ne_top n)\n    (Nat.cast_pos'.2 n_pos).ne.symm\n  apply le_trans <| div_le_div_right_of_nonneg (Nat.cast_pos'.2 n_pos).le\n    (log_monotone (ENat.toENNReal_le.2 (coverMincard_le_pow F_inv U_symm m_pos n)))\n  rw [ENat.toENNReal_pow, log_pow, Nat.cast_add, Nat.cast_one, right_distrib_of_nonneg h_nm\n    zero_le_one, one_mul, div_right_distrib_of_nonneg (Left.mul_nonneg h_nm h_log) h_log, mul_comm,\n    ← EReal.mul_div, div_eq_mul_inv _ (m : EReal)]\n  apply add_le_add_right (mul_le_mul_of_nonneg_left _ h_log)\n  apply (div_le_div_right_of_nonneg (Nat.cast_pos'.2 n_pos).le (natCast_div_le n m)).trans_eq\n  rw [EReal.div_div, mul_comm, ← EReal.div_div, n_div_n, one_div (m : EReal)]\n\n"}
{"name":"Dynamics.coverEntropyInfEntourage_antitone","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\n⊢ Antitone fun U => Dynamics.coverEntropyInfEntourage T F U","decl":"lemma coverEntropyInfEntourage_antitone (T : X → X) (F : Set X) :\n    Antitone (fun U : Set (X × X) ↦ coverEntropyInfEntourage T F U) :=\n  fun _ _ U_V ↦ (liminf_le_liminf) <| Eventually.of_forall\n    fun n ↦ monotone_div_right_of_nonneg (Nat.cast_nonneg' n)\n    <| log_monotone (ENat.toENNReal_mono (coverMincard_antitone T F n U_V))\n\n"}
{"name":"Dynamics.coverEntropyEntourage_antitone","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\n⊢ Antitone fun U => Dynamics.coverEntropyEntourage T F U","decl":"lemma coverEntropyEntourage_antitone (T : X → X) (F : Set X) :\n    Antitone (fun U : Set (X × X) ↦ coverEntropyEntourage T F U) :=\n  fun _ _ U_V ↦ (limsup_le_limsup) <| Eventually.of_forall\n    fun n ↦ monotone_div_right_of_nonneg (Nat.cast_nonneg' n)\n    <| log_monotone (ENat.toENNReal_mono (coverMincard_antitone T F n U_V))\n\n"}
{"name":"Dynamics.coverEntropyInfEntourage_le_coverEntropyEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nU : Set (Prod X X)\n⊢ LE.le (Dynamics.coverEntropyInfEntourage T F U) (Dynamics.coverEntropyEntourage T F U)","decl":"lemma coverEntropyInfEntourage_le_coverEntropyEntourage (T : X → X) (F : Set X) (U : Set (X × X)) :\n    coverEntropyInfEntourage T F U ≤ coverEntropyEntourage T F U := liminf_le_limsup\n\n"}
{"name":"Dynamics.coverEntropyEntourage_empty","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nU : Set (Prod X X)\n⊢ Eq (Dynamics.coverEntropyEntourage T EmptyCollection.emptyCollection U) Bot.bot","decl":"@[simp]\nlemma coverEntropyEntourage_empty {T : X → X} {U : Set (X × X)} :\n    coverEntropyEntourage T ∅ U = ⊥ := by\n  suffices h : ∀ᶠ n : ℕ in atTop, log (coverMincard T ∅ U n) / n = ⊥ by\n    rw [coverEntropyEntourage]\n    exact limsup_congr h ▸ limsup_const ⊥\n  · simp only [coverMincard_empty, ENat.toENNReal_zero, log_zero, eventually_atTop]\n    exact ⟨1, fun n n_pos ↦ bot_div_of_pos_ne_top (Nat.cast_pos'.2 n_pos) (natCast_ne_top n)⟩\n\n"}
{"name":"Dynamics.coverEntropyInfEntourage_empty","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nU : Set (Prod X X)\n⊢ Eq (Dynamics.coverEntropyInfEntourage T EmptyCollection.emptyCollection U) Bot.bot","decl":"@[simp]\nlemma coverEntropyInfEntourage_empty {T : X → X} {U : Set (X × X)} :\n    coverEntropyInfEntourage T ∅ U = ⊥ :=\n  eq_bot_mono (coverEntropyInfEntourage_le_coverEntropyEntourage T ∅ U) coverEntropyEntourage_empty\n\n"}
{"name":"Dynamics.coverEntropyInfEntourage_nonneg","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nh : F.Nonempty\nU : Set (Prod X X)\n⊢ LE.le 0 (Dynamics.coverEntropyInfEntourage T F U)","decl":"lemma coverEntropyInfEntourage_nonneg (T : X → X) {F : Set X} (h : F.Nonempty) (U : Set (X × X)) :\n    0 ≤ coverEntropyInfEntourage T F U :=\n  (le_iInf fun n ↦ div_nonneg (log_coverMincard_nonneg T h U n) (Nat.cast_nonneg' n)).trans\n    iInf_le_liminf\n\n"}
{"name":"Dynamics.coverEntropyEntourage_nonneg","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nh : F.Nonempty\nU : Set (Prod X X)\n⊢ LE.le 0 (Dynamics.coverEntropyEntourage T F U)","decl":"lemma coverEntropyEntourage_nonneg (T : X → X) {F : Set X} (h : F.Nonempty) (U : Set (X × X)) :\n    0 ≤ coverEntropyEntourage T F U :=\n  (coverEntropyInfEntourage_nonneg T h U).trans\n    (coverEntropyInfEntourage_le_coverEntropyEntourage T F U)\n\n"}
{"name":"Dynamics.coverEntropyEntourage_univ","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nh : F.Nonempty\n⊢ Eq (Dynamics.coverEntropyEntourage T F Set.univ) 0","decl":"lemma coverEntropyEntourage_univ (T : X → X) {F : Set X} (h : F.Nonempty) :\n    coverEntropyEntourage T F univ = 0 := by\n  simp [coverEntropyEntourage, coverMincard_univ T h]\n\n"}
{"name":"Dynamics.coverEntropyInfEntourage_univ","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nh : F.Nonempty\n⊢ Eq (Dynamics.coverEntropyInfEntourage T F Set.univ) 0","decl":"lemma coverEntropyInfEntourage_univ (T : X → X) {F : Set X} (h : F.Nonempty) :\n    coverEntropyInfEntourage T F univ = 0 := by\n  simp [coverEntropyInfEntourage, coverMincard_univ T h]\n\n"}
{"name":"Dynamics.coverEntropyEntourage_le_log_coverMincard_div","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_symm : SymmetricRel U\nn : Nat\nn_pos : LT.lt 0 n\n⊢ LE.le (Dynamics.coverEntropyEntourage T F (compRel U U)) (HDiv.hDiv (↑(Dynamics.coverMincard T F U n)).log ↑n)","decl":"lemma coverEntropyEntourage_le_log_coverMincard_div {T : X → X} {F : Set X} (F_inv : MapsTo T F F)\n    {U : Set (X × X)} (U_symm : SymmetricRel U) {n : ℕ} (n_pos : 0 < n) :\n    coverEntropyEntourage T F (U ○ U) ≤ log (coverMincard T F U n) / n := by\n  -- Deal with the edge cases: `F = ∅` or `F` has no finite cover.\n  rcases eq_or_ne (log (coverMincard T F U n)) ⊥ with logm_bot | logm_nneg\n  · rw [log_eq_bot_iff, ← ENat.toENNReal_zero, ENat.toENNReal_inj,\n      coverMincard_eq_zero_iff T F U n] at logm_bot\n    simp [logm_bot]\n  rcases eq_or_ne (log (coverMincard T F U n)) ⊤ with logm_top | logm_fin\n  · rw [logm_top, top_div_of_pos_ne_top (Nat.cast_pos'.2 n_pos) (natCast_ne_top n)]\n    exact le_top\n  -- The general case follows from `log_coverMincard_le_add`, with careful manipulation of limits.\n  let u := fun _ : ℕ ↦ log (coverMincard T F U n) / n\n  let v := fun m : ℕ ↦ log (coverMincard T F U n) / m\n  let w := fun m : ℕ ↦ log (coverMincard T F (U ○ U) m) / m\n  have key : w ≤ᶠ[atTop] u + v :=\n    eventually_atTop.2 ⟨1, fun m m_pos ↦ log_coverMincard_le_add F_inv U_symm n_pos m_pos⟩\n  apply ((limsup_le_limsup) key).trans\n  suffices h : atTop.limsup v = 0 by\n    have := @limsup_add_le ℕ atTop u v\n    rw [h, add_zero] at this\n    specialize this (Or.inr EReal.zero_ne_top) (Or.inr EReal.zero_ne_bot)\n    exact this.trans_eq (limsup_const (log (coverMincard T F U n) / n))\n  exact Tendsto.limsup_eq (EReal.tendsto_const_div_atTop_nhds_zero_nat logm_nneg logm_fin)\n\n"}
{"name":"Dynamics.IsDynCoverOf.coverEntropyEntourage_le_log_card_div","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_symm : SymmetricRel U\nn : Nat\nn_pos : LT.lt 0 n\ns : Finset X\nh : Dynamics.IsDynCoverOf T F U n ↑s\n⊢ LE.le (Dynamics.coverEntropyEntourage T F (compRel U U)) (HDiv.hDiv (↑s.card).log ↑n)","decl":"lemma IsDynCoverOf.coverEntropyEntourage_le_log_card_div {T : X → X} {F : Set X}\n    (F_inv : MapsTo T F F) {U : Set (X × X)} (U_symm : SymmetricRel U) {n : ℕ} (n_pos : 0 < n)\n    {s : Finset X} (h : IsDynCoverOf T F U n s) :\n    coverEntropyEntourage T F (U ○ U) ≤ log s.card / n := by\n  apply (coverEntropyEntourage_le_log_coverMincard_div F_inv U_symm n_pos).trans\n  apply monotone_div_right_of_nonneg (Nat.cast_nonneg' n) (log_monotone _)\n  exact_mod_cast coverMincard_le_card h\n\n"}
{"name":"Dynamics.coverEntropyEntourage_le_coverEntropyInfEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_symm : SymmetricRel U\n⊢ LE.le (Dynamics.coverEntropyEntourage T F (compRel U U)) (Dynamics.coverEntropyInfEntourage T F U)","decl":"lemma coverEntropyEntourage_le_coverEntropyInfEntourage {T : X → X} {F : Set X}\n    (F_inv : MapsTo T F F) {U : Set (X × X)} (U_symm : SymmetricRel U) :\n    coverEntropyEntourage T F (U ○ U) ≤ coverEntropyInfEntourage T F U :=\n  (le_liminf_of_le) (eventually_atTop.2\n    ⟨1, fun m m_pos ↦ coverEntropyEntourage_le_log_coverMincard_div F_inv U_symm m_pos⟩)\n\n"}
{"name":"Dynamics.coverEntropyEntourage_finite_of_isCompact_invariant","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nT : X → X\nF : Set X\nF_comp : IsCompact F\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_uni : Membership.mem (uniformity X) U\n⊢ LT.lt (Dynamics.coverEntropyEntourage T F U) Top.top","decl":"lemma coverEntropyEntourage_finite_of_isCompact_invariant [UniformSpace X] {T : X → X} {F : Set X}\n    (F_comp : IsCompact F) (F_inv : MapsTo T F F) {U : Set (X × X)} (U_uni : U ∈ 𝓤 X) :\n    coverEntropyEntourage T F U < ⊤ := by\n  rcases comp_symm_mem_uniformity_sets U_uni with ⟨V, V_uni, V_symm, V_U⟩\n  rcases exists_isDynCoverOf_of_isCompact_invariant F_comp F_inv V_uni 1 with ⟨s, s_cover⟩\n  apply (coverEntropyEntourage_antitone T F V_U).trans_lt\n  apply (s_cover.coverEntropyEntourage_le_log_card_div F_inv V_symm zero_lt_one).trans_lt\n  rw [Nat.cast_one, div_one, log_lt_top_iff, ← ENat.toENNReal_top]\n  exact_mod_cast Ne.lt_top (ENat.coe_ne_top (Finset.card s))\n\n"}
{"name":"Dynamics.coverEntropyInf_antitone","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\n⊢ Antitone fun u => Dynamics.coverEntropyInf T F","decl":"lemma coverEntropyInf_antitone (T : X → X) (F : Set X) :\n    Antitone fun (u : UniformSpace X) ↦ @coverEntropyInf X u T F :=\n  fun _ _ h ↦ iSup₂_mono' fun U U_uni ↦ ⟨U, (le_def.1 h) U U_uni, le_refl _⟩\n\n"}
{"name":"Dynamics.coverEntropy_antitone","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X → X\nF : Set X\n⊢ Antitone fun u => Dynamics.coverEntropy T F","decl":"lemma coverEntropy_antitone (T : X → X) (F : Set X) :\n    Antitone fun (u : UniformSpace X) ↦ @coverEntropy X u T F :=\n  fun _ _ h ↦ iSup₂_mono' fun U U_uni ↦ ⟨U, (le_def.1 h) U U_uni, le_refl _⟩\n\n"}
{"name":"Dynamics.coverEntropyEntourage_le_coverEntropy","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nT : X → X\nF : Set X\nU : Set (Prod X X)\nh : Membership.mem (uniformity X) U\n⊢ LE.le (Dynamics.coverEntropyEntourage T F U) (Dynamics.coverEntropy T F)","decl":"lemma coverEntropyEntourage_le_coverEntropy (T : X → X) (F : Set X) {U : Set (X × X)}\n    (h : U ∈ 𝓤 X) :\n    coverEntropyEntourage T F U ≤ coverEntropy T F :=\n  le_iSup₂ (f := fun (U : Set (X × X)) (_ : U ∈ 𝓤 X) ↦ coverEntropyEntourage T F U) U h\n\n"}
{"name":"Dynamics.coverEntropyInfEntourage_le_coverEntropyInf","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nT : X → X\nF : Set X\nU : Set (Prod X X)\nh : Membership.mem (uniformity X) U\n⊢ LE.le (Dynamics.coverEntropyInfEntourage T F U) (Dynamics.coverEntropyInf T F)","decl":"lemma coverEntropyInfEntourage_le_coverEntropyInf (T : X → X) (F : Set X) {U : Set (X × X)}\n    (h : U ∈ 𝓤 X) :\n    coverEntropyInfEntourage T F U ≤ coverEntropyInf T F :=\n  le_iSup₂ (f := fun (U : Set (X × X)) (_ : U ∈ 𝓤 X) ↦ coverEntropyInfEntourage T F U) U h\n\n"}
{"name":"Dynamics.coverEntropy_eq_iSup_basis","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nι : Sort u_2\np : ι → Prop\ns : ι → Set (Prod X X)\nh : (uniformity X).HasBasis p s\nT : X → X\nF : Set X\n⊢ Eq (Dynamics.coverEntropy T F) (iSup fun i => iSup fun x => Dynamics.coverEntropyEntourage T F (s i))","decl":"lemma coverEntropy_eq_iSup_basis {ι : Sort*} {p : ι → Prop} {s : ι → Set (X × X)}\n    (h : (𝓤 X).HasBasis p s) (T : X → X) (F : Set X) :\n    coverEntropy T F = ⨆ (i : ι) (_ : p i), coverEntropyEntourage T F (s i) := by\n  refine (iSup₂_le fun U U_uni ↦ ?_).antisymm\n    (iSup₂_mono' fun i h_i ↦ ⟨s i, HasBasis.mem_of_mem h h_i, le_refl _⟩)\n  rcases (HasBasis.mem_iff h).1 U_uni with ⟨i, h_i, si_U⟩\n  exact (coverEntropyEntourage_antitone T F si_U).trans\n    (le_iSup₂ (f := fun (i : ι) (_ : p i) ↦ coverEntropyEntourage T F (s i)) i h_i)\n\n"}
{"name":"Dynamics.coverEntropyInf_eq_iSup_basis","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nι : Sort u_2\np : ι → Prop\ns : ι → Set (Prod X X)\nh : (uniformity X).HasBasis p s\nT : X → X\nF : Set X\n⊢ Eq (Dynamics.coverEntropyInf T F) (iSup fun i => iSup fun x => Dynamics.coverEntropyInfEntourage T F (s i))","decl":"lemma coverEntropyInf_eq_iSup_basis {ι : Sort*} {p : ι → Prop} {s : ι → Set (X × X)}\n    (h : (𝓤 X).HasBasis p s) (T : X → X) (F : Set X) :\n    coverEntropyInf T F = ⨆ (i : ι) (_ : p i), coverEntropyInfEntourage T F (s i) := by\n  refine (iSup₂_le fun U U_uni ↦ ?_).antisymm\n    (iSup₂_mono' fun i h_i ↦ ⟨s i, HasBasis.mem_of_mem h h_i, le_refl _⟩)\n  rcases (HasBasis.mem_iff h).1 U_uni with ⟨i, h_i, si_U⟩\n  exact (coverEntropyInfEntourage_antitone T F si_U).trans\n    (le_iSup₂ (f := fun (i : ι) (_ : p i) ↦ coverEntropyInfEntourage T F (s i)) i h_i)\n\n"}
{"name":"Dynamics.coverEntropyInf_le_coverEntropy","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nT : X → X\nF : Set X\n⊢ LE.le (Dynamics.coverEntropyInf T F) (Dynamics.coverEntropy T F)","decl":"lemma coverEntropyInf_le_coverEntropy (T : X → X) (F : Set X) :\n    coverEntropyInf T F ≤ coverEntropy T F :=\n  iSup₂_mono fun (U : Set (X × X)) (_ : U ∈ 𝓤 X) ↦\n    coverEntropyInfEntourage_le_coverEntropyEntourage T F U\n\n"}
{"name":"Dynamics.coverEntropy_empty","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nT : X → X\n⊢ Eq (Dynamics.coverEntropy T EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\nlemma coverEntropy_empty {T : X → X} : coverEntropy T ∅ = ⊥ := by\n  simp only [coverEntropy, coverEntropyEntourage_empty, iSup_bot]\n\n"}
{"name":"Dynamics.coverEntropyInf_empty","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nT : X → X\n⊢ Eq (Dynamics.coverEntropyInf T EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\nlemma coverEntropyInf_empty {T : X → X} : coverEntropyInf T ∅ = ⊥ := by\n  simp only [coverEntropyInf, coverEntropyInfEntourage_empty, iSup_bot]\n\n"}
{"name":"Dynamics.coverEntropyInf_nonneg","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nT : X → X\nF : Set X\nh : F.Nonempty\n⊢ LE.le 0 (Dynamics.coverEntropyInf T F)","decl":"lemma coverEntropyInf_nonneg (T : X → X) {F : Set X} (h : F.Nonempty) :\n    0 ≤ coverEntropyInf T F :=\n  (coverEntropyInfEntourage_le_coverEntropyInf T F univ_mem).trans_eq'\n    (coverEntropyInfEntourage_univ T h).symm\n\n"}
{"name":"Dynamics.coverEntropy_nonneg","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nT : X → X\nF : Set X\nh : F.Nonempty\n⊢ LE.le 0 (Dynamics.coverEntropy T F)","decl":"lemma coverEntropy_nonneg (T : X → X) {F : Set X} (h : F.Nonempty) :\n    0 ≤ coverEntropy T F :=\n  (coverEntropyInf_nonneg T h).trans (coverEntropyInf_le_coverEntropy T F)\n\n"}
{"name":"Dynamics.coverEntropyInf_eq_coverEntropy","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nT : X → X\nF : Set X\nh : Set.MapsTo T F F\n⊢ Eq (Dynamics.coverEntropyInf T F) (Dynamics.coverEntropy T F)","decl":"lemma coverEntropyInf_eq_coverEntropy (T : X → X) {F : Set X} (h : MapsTo T F F) :\n    coverEntropyInf T F = coverEntropy T F := by\n  refine le_antisymm (coverEntropyInf_le_coverEntropy T F) (iSup₂_le fun U U_uni ↦ ?_)\n  rcases comp_symm_mem_uniformity_sets U_uni with ⟨V, V_uni, V_symm, V_U⟩\n  exact (coverEntropyEntourage_antitone T F V_U).trans\n    (le_iSup₂_of_le V V_uni (coverEntropyEntourage_le_coverEntropyInfEntourage h V_symm))\n\n"}
