{"name":"Dynamics.IsDynCoverOf.of_le","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nm n : Nat\nm_n : LE.le m n\ns : Set X\nh : Dynamics.IsDynCoverOf T F U n s\n‚ä¢ Dynamics.IsDynCoverOf T F U m s","decl":"lemma IsDynCoverOf.of_le {T : X ‚Üí X} {F : Set X} {U : Set (X √ó X)} {m n : ‚Ñï} (m_n : m ‚â§ n)\n    {s : Set X} (h : IsDynCoverOf T F U n s) :\n    IsDynCoverOf T F U m s := by\n  exact Subset.trans (c := ‚ãÉ x ‚àà s, ball x (dynEntourage T U m)) h\n    (iUnion‚ÇÇ_mono fun x _ ‚Ü¶ ball_mono (dynEntourage_antitone T U m_n) x)\n\n"}
{"name":"Dynamics.IsDynCoverOf.of_entourage_subset","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU V : Set (Prod X X)\nU_V : HasSubset.Subset U V\nn : Nat\ns : Set X\nh : Dynamics.IsDynCoverOf T F U n s\n‚ä¢ Dynamics.IsDynCoverOf T F V n s","decl":"lemma IsDynCoverOf.of_entourage_subset {T : X ‚Üí X} {F : Set X} {U V : Set (X √ó X)} (U_V : U ‚äÜ V)\n    {n : ‚Ñï} {s : Set X} (h : IsDynCoverOf T F U n s) :\n    IsDynCoverOf T F V n s := by\n  exact Subset.trans (c := ‚ãÉ x ‚àà s, ball x (dynEntourage T V n)) h\n    (iUnion‚ÇÇ_mono fun x _ ‚Ü¶ ball_mono (dynEntourage_monotone T n U_V) x)\n\n"}
{"name":"Dynamics.isDynCoverOf_empty","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nU : Set (Prod X X)\nn : Nat\ns : Set X\n‚ä¢ Dynamics.IsDynCoverOf T EmptyCollection.emptyCollection U n s","decl":"@[simp]\nlemma isDynCoverOf_empty {T : X ‚Üí X} {U : Set (X √ó X)} {n : ‚Ñï} {s : Set X} :\n    IsDynCoverOf T ‚àÖ U n s := by\n  simp only [IsDynCoverOf, empty_subset]\n\n"}
{"name":"Dynamics.IsDynCoverOf.nonempty","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nh : F.Nonempty\nU : Set (Prod X X)\nn : Nat\ns : Set X\nh' : Dynamics.IsDynCoverOf T F U n s\n‚ä¢ s.Nonempty","decl":"lemma IsDynCoverOf.nonempty {T : X ‚Üí X} {F : Set X} (h : F.Nonempty) {U : Set (X √ó X)} {n : ‚Ñï}\n    {s : Set X} (h' : IsDynCoverOf T F U n s) :\n    s.Nonempty := by\n  rcases nonempty_biUnion.1 (Nonempty.mono h' h) with ‚ü®x, x_s, _‚ü©\n  exact nonempty_of_mem x_s\n\n"}
{"name":"Dynamics.isDynCoverOf_zero","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\ns : Set X\nh : s.Nonempty\n‚ä¢ Dynamics.IsDynCoverOf T F U 0 s","decl":"lemma isDynCoverOf_zero (T : X ‚Üí X) (F : Set X) (U : Set (X √ó X)) {s : Set X} (h : s.Nonempty) :\n    IsDynCoverOf T F U 0 s := by\n  simp only [IsDynCoverOf, ball, dynEntourage, not_lt_zero', Prod.map_iterate, iInter_of_empty,\n    iInter_univ, preimage_univ]\n  rcases h with ‚ü®x, x_s‚ü©\n  exact subset_iUnion‚ÇÇ_of_subset x x_s (subset_univ F)\n\n"}
{"name":"Dynamics.isDynCoverOf_univ","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nn : Nat\ns : Set X\nh : s.Nonempty\n‚ä¢ Dynamics.IsDynCoverOf T F Set.univ n s","decl":"lemma isDynCoverOf_univ (T : X ‚Üí X) (F : Set X) (n : ‚Ñï) {s : Set X} (h : s.Nonempty) :\n    IsDynCoverOf T F univ n s := by\n  simp only [IsDynCoverOf, ball, dynEntourage, Prod.map_iterate, preimage_univ, iInter_univ,\n    iUnion_coe_set]\n  rcases h with ‚ü®x, x_s‚ü©\n  exact subset_iUnion‚ÇÇ_of_subset x x_s (subset_univ F)\n\n"}
{"name":"Dynamics.IsDynCoverOf.nonempty_inter","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nn : Nat\ns : Finset X\nh : Dynamics.IsDynCoverOf T F U n ‚Üës\n‚ä¢ Exists fun t => And (Dynamics.IsDynCoverOf T F U n ‚Üët) (And (LE.le t.card s.card) (‚àÄ (x : X), Membership.mem t x ‚Üí (Inter.inter (UniformSpace.ball x (Dynamics.dynEntourage T U n)) F).Nonempty))","decl":"lemma IsDynCoverOf.nonempty_inter {T : X ‚Üí X} {F : Set X} {U : Set (X √ó X)} {n : ‚Ñï} {s : Finset X}\n    (h : IsDynCoverOf T F U n s) :\n    ‚àÉ t : Finset X, IsDynCoverOf T F U n t ‚àß t.card ‚â§ s.card\n    ‚àß ‚àÄ x ‚àà t, ((ball x (dynEntourage T U n)) ‚à© F).Nonempty := by\n  classical\n  use Finset.filter (fun x : X ‚Ü¶ ((ball x (dynEntourage T U n)) ‚à© F).Nonempty) s\n  simp only [Finset.coe_filter, Finset.mem_filter, and_imp, imp_self, implies_true, and_true]\n  refine ‚ü®fun y y_F ‚Ü¶ ?_, Finset.card_mono (Finset.filter_subset _ s)‚ü©\n  specialize h y_F\n  simp only [Finset.coe_sort_coe, mem_iUnion, Subtype.exists, exists_prop] at h\n  rcases h with ‚ü®z, z_s, y_Bz‚ü©\n  simp only [coe_setOf, mem_setOf_eq, mem_iUnion, Subtype.exists, exists_prop]\n  exact ‚ü®z, ‚ü®z_s, nonempty_of_mem ‚ü®y_Bz, y_F‚ü©‚ü©, y_Bz‚ü©\n\n"}
{"name":"Dynamics.IsDynCoverOf.iterate_le_pow","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_symm : SymmetricRel U\nm n : Nat\ns : Finset X\nh : Dynamics.IsDynCoverOf T F U m ‚Üës\n‚ä¢ Exists fun t => And (Dynamics.IsDynCoverOf T F (compRel U U) (HMul.hMul m n) ‚Üët) (LE.le t.card (HPow.hPow s.card n))","decl":"/-- From a dynamical cover `s` with entourage `U` and time `m`, we construct covers with entourage\n`U ‚óã U` and any multiple `m * n` of `m` with controlled cardinality. This lemma is the first step\nin a submultiplicative-like property of `coverMincard`, with consequences such as explicit bounds\nfor the topological entropy (`coverEntropyInfEntourage_le_card_div`) and an equality between\ntwo notions of topological entropy (`coverEntropyInf_eq_coverEntropySup_of_inv`).-/\nlemma IsDynCoverOf.iterate_le_pow {T : X ‚Üí X} {F : Set X} (F_inv : MapsTo T F F) {U : Set (X √ó X)}\n    (U_symm : SymmetricRel U) {m : ‚Ñï} (n : ‚Ñï) {s : Finset X} (h : IsDynCoverOf T F U m s) :\n    ‚àÉ t : Finset X, IsDynCoverOf T F (U ‚óã U) (m * n) t ‚àß t.card ‚â§ s.card ^ n := by\n  classical\n  -- Deal with the edge cases: `F = ‚àÖ` or `m = 0`.\n  rcases F.eq_empty_or_nonempty with rfl | F_nemp\n  ¬∑ exact ‚ü®‚àÖ, by simp‚ü©\n  have _ : Nonempty X := nonempty_of_exists F_nemp\n  have s_nemp := h.nonempty F_nemp\n  rcases F_nemp with ‚ü®x, x_F‚ü©\n  rcases m.eq_zero_or_pos with rfl | m_pos\n  ¬∑ use {x}\n    simp only [zero_mul, Finset.coe_singleton, Finset.card_singleton]\n    exact And.intro (isDynCoverOf_zero T F (U ‚óã U) (singleton_nonempty x))\n      <| one_le_pow_of_one_le' (Nat.one_le_of_lt (Finset.Nonempty.card_pos s_nemp)) n\n  -- The proof goes as follows. Given an orbit of length `(m * n)` starting from `y`, each of its\n  -- iterates `y`, `T^[m] y`, `T^[m]^[2] y` ... is `(dynEntourage T U m)`-close to a point of `s`.\n  -- Conversely, given a sequence `t 0`, `t 1`, `t 2` of points in `s`, we choose a point\n  -- `z = dyncover t` such that  `z`, `T^[m] z`, `T^[m]^[2] z` ... are `(dynEntourage T U m)`-close\n  --  to `t 0`, `t 1`, `t 2`... Then  `y`, `T^[m] y`, `T^[m]^[2] y` ... are\n  -- `(dynEntourage T (U ‚óã U) m)`-close to `z`, `T^[m] z`, `T^[m]^[2] z`, so that the union of such\n  -- `z` provides the desired cover. Since there are at most `s.card ^ n` sequences of\n  -- length `n` with values in `s`, we get the upper bound we want on the cardinality.\n  -- First step: construct `dyncover`. Given `t 0`, `t 1`, `t 2`, if we cannot find such a point\n  -- `dyncover t`, we use the dummy `x`.\n  have (t : Fin n ‚Üí s) : ‚àÉ y : X, (‚ãÇ k : Fin n, T^[m * k] ‚Åª¬π' ball (t k) (dynEntourage T U m)) ‚äÜ\n      ball y (dynEntourage T (U ‚óã U) (m * n)) := by\n    rcases (‚ãÇ k : Fin n, T^[m * k] ‚Åª¬π' ball (t k) (dynEntourage T U m)).eq_empty_or_nonempty\n      with inter_empt | inter_nemp\n    ¬∑ exact inter_empt ‚ñ∏ ‚ü®x, empty_subset _‚ü©\n    ¬∑ rcases inter_nemp with ‚ü®y, y_int‚ü©\n      refine ‚ü®y, fun z z_int ‚Ü¶ ?_‚ü©\n      simp only [ball, dynEntourage, Prod.map_iterate, mem_preimage, mem_iInter,\n        Prod.map_apply] at y_int z_int ‚ä¢\n      intro k k_mn\n      replace k_mn := Nat.div_lt_of_lt_mul k_mn\n      specialize z_int ‚ü®(k / m), k_mn‚ü© (k % m) (Nat.mod_lt k m_pos)\n      specialize y_int ‚ü®(k / m), k_mn‚ü© (k % m) (Nat.mod_lt k m_pos)\n      rw [‚Üê Function.iterate_add_apply T (k % m) (m * (k / m)), Nat.mod_add_div k m] at y_int z_int\n      exact mem_comp_of_mem_ball U_symm y_int z_int\n  choose! dyncover h_dyncover using this\n  -- The cover we want is the set of all `dyncover t`, that is, `range dyncover`. We need to check\n  -- that it is indeed a `(U ‚óã U, m * n)` cover, and that its cardinality is at most `card s ^ n`.\n  -- Only the first point requires significant work.\n  let sn := range dyncover\n  have := fintypeRange dyncover\n  refine ‚ü®sn.toFinset, ?_, ?_‚ü©\n  ¬∑ -- We implement the argument at the beginning: given `y ‚àà F`, we extract `t 0`, `t 1`, `t 2`\n    -- such that `y`, `T^[m] y`, `T^[m]^[2] y` ... is `(dynEntourage T U m)`-close to `t 0`, `t 1`,\n    -- `t 2`... Then `dyncover t` is a point of `range dyncover` which satisfies the conclusion\n    -- of the lemma.\n    rw [Finset.coe_nonempty] at s_nemp\n    have _ : Nonempty s := Finset.Nonempty.coe_sort s_nemp\n    intro y y_F\n    have key : ‚àÄ k : Fin n, ‚àÉ z : s, y ‚àà T^[m * k] ‚Åª¬π' ball z (dynEntourage T U m) := by\n      intro k\n      have := h (MapsTo.iterate F_inv (m * k) y_F)\n      simp only [Finset.coe_sort_coe, mem_iUnion, Subtype.exists, exists_prop] at this\n      rcases this with ‚ü®z, z_s, hz‚ü©\n      exact ‚ü®‚ü®z, z_s‚ü©, hz‚ü©\n    choose! t ht using key\n    simp only [toFinset_range, Finset.coe_image, Finset.coe_univ, image_univ, mem_range,\n      iUnion_exists, iUnion_iUnion_eq', mem_iUnion, sn]\n    use t\n    apply h_dyncover t\n    simp only [mem_iInter, mem_preimage] at ht ‚ä¢\n    exact ht\n  ¬∑ rw [toFinset_card]\n    apply (Fintype.card_range_le dyncover).trans\n    simp only [Fintype.card_fun, Fintype.card_coe, Fintype.card_fin, le_refl]\n\n"}
{"name":"Dynamics.exists_isDynCoverOf_of_isCompact_uniformContinuous","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\nT : X ‚Üí X\nF : Set X\nF_comp : IsCompact F\nh : UniformContinuous T\nU : Set (Prod X X)\nU_uni : Membership.mem (uniformity X) U\nn : Nat\n‚ä¢ Exists fun s => Dynamics.IsDynCoverOf T F U n ‚Üës","decl":"lemma exists_isDynCoverOf_of_isCompact_uniformContinuous [UniformSpace X] {T : X ‚Üí X} {F : Set X}\n    (F_comp : IsCompact F) (h : UniformContinuous T) {U : Set (X √ó X)} (U_uni : U ‚àà ùì§ X) (n : ‚Ñï) :\n    ‚àÉ s : Finset X, IsDynCoverOf T F U n s := by\n  have uni_ite := dynEntourage_mem_uniformity h U_uni n\n  let open_cover := fun x : X ‚Ü¶ ball x (dynEntourage T U n)\n  obtain ‚ü®s, _, s_cover‚ü© := IsCompact.elim_nhds_subcover F_comp open_cover\n    (fun (x : X) _ ‚Ü¶ ball_mem_nhds x uni_ite)\n  exact ‚ü®s, s_cover‚ü©\n\n"}
{"name":"Dynamics.exists_isDynCoverOf_of_isCompact_invariant","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\nT : X ‚Üí X\nF : Set X\nF_comp : IsCompact F\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_uni : Membership.mem (uniformity X) U\nn : Nat\n‚ä¢ Exists fun s => Dynamics.IsDynCoverOf T F U n ‚Üës","decl":"lemma exists_isDynCoverOf_of_isCompact_invariant [UniformSpace X] {T : X ‚Üí X} {F : Set X}\n    (F_comp : IsCompact F) (F_inv : MapsTo T F F) {U : Set (X √ó X)} (U_uni : U ‚àà ùì§ X) (n : ‚Ñï) :\n    ‚àÉ s : Finset X, IsDynCoverOf T F U n s := by\n  rcases comp_symm_mem_uniformity_sets U_uni with ‚ü®V, V_uni, V_symm, V_U‚ü©\n  obtain ‚ü®s, _, s_cover‚ü© := IsCompact.elim_nhds_subcover F_comp (fun x : X ‚Ü¶ ball x V)\n    (fun (x : X) _ ‚Ü¶ ball_mem_nhds x V_uni)\n  have : IsDynCoverOf T F V 1 s := by\n    simp only [IsDynCoverOf, Finset.mem_coe, dynEntourage_one, s_cover]\n  rcases this.iterate_le_pow F_inv V_symm n with ‚ü®t, t_dyncover, t_card‚ü©\n  rw [one_mul n] at t_dyncover\n  exact ‚ü®t, t_dyncover.of_entourage_subset V_U‚ü©\n\n"}
{"name":"Dynamics.IsDynCoverOf.coverMincard_le_card","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nn : Nat\ns : Finset X\nh : Dynamics.IsDynCoverOf T F U n ‚Üës\n‚ä¢ LE.le (Dynamics.coverMincard T F U n) ‚Üës.card","decl":"lemma IsDynCoverOf.coverMincard_le_card {T : X ‚Üí X} {F : Set X} {U : Set (X √ó X)} {n : ‚Ñï}\n    {s : Finset X} (h : IsDynCoverOf T F U n s) :\n    coverMincard T F U n ‚â§ s.card := iInf‚ÇÇ_le s h\n\n"}
{"name":"Dynamics.coverMincard_monotone_time","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\n‚ä¢ Monotone fun n => Dynamics.coverMincard T F U n","decl":"lemma coverMincard_monotone_time (T : X ‚Üí X) (F : Set X) (U : Set (X √ó X)) :\n    Monotone (fun n : ‚Ñï ‚Ü¶ coverMincard T F U n) :=\n  fun _ _ m_n ‚Ü¶ biInf_mono fun _ h ‚Ü¶ h.of_le m_n\n\n"}
{"name":"Dynamics.coverMincard_antitone","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nn : Nat\n‚ä¢ Antitone fun U => Dynamics.coverMincard T F U n","decl":"lemma coverMincard_antitone (T : X ‚Üí X) (F : Set X) (n : ‚Ñï) :\n    Antitone (fun U : Set (X √ó X) ‚Ü¶ coverMincard T F U n) :=\n  fun _ _ U_V ‚Ü¶ biInf_mono fun _ h ‚Ü¶ h.of_entourage_subset U_V\n\n"}
{"name":"Dynamics.coverMincard_finite_iff","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nn : Nat\n‚ä¢ Iff (LT.lt (Dynamics.coverMincard T F U n) Top.top) (Exists fun s => And (Dynamics.IsDynCoverOf T F U n ‚Üës) (Eq (‚Üës.card) (Dynamics.coverMincard T F U n)))","decl":"lemma coverMincard_finite_iff (T : X ‚Üí X) (F : Set X) (U : Set (X √ó X)) (n : ‚Ñï) :\n    coverMincard T F U n < ‚ä§ ‚Üî\n    ‚àÉ s : Finset X, IsDynCoverOf T F U n s ‚àß s.card = coverMincard T F U n := by\n  refine ‚ü®fun h_fin ‚Ü¶ ?_, (fun ‚ü®s, _, s_coverMincard‚ü© ‚Ü¶ s_coverMincard ‚ñ∏ WithTop.coe_lt_top s.card)‚ü©\n  rcases WithTop.ne_top_iff_exists.1 (ne_of_lt h_fin) with ‚ü®k, k_min‚ü©\n  rw [‚Üê k_min]\n  simp only [ENat.some_eq_coe, Nat.cast_inj]\n  have : Nonempty {s : Finset X // IsDynCoverOf T F U n s} := by\n    by_contra h\n    apply ENat.coe_ne_top k\n    rw [‚Üê ENat.some_eq_coe, k_min, coverMincard, iInf‚ÇÇ_eq_top]\n    simp only [ENat.coe_ne_top, imp_false]\n    rw [nonempty_subtype, not_exists] at h\n    exact h\n  have key := ciInf_mem (fun s : {s : Finset X // IsDynCoverOf T F U n s} ‚Ü¶ (s.val.card : ‚Ñï‚àû))\n  rw [coverMincard, iInf_subtype'] at k_min\n  rw [‚Üê k_min, mem_range, Subtype.exists] at key\n  simp only [ENat.some_eq_coe, Nat.cast_inj, exists_prop] at key\n  exact key\n\n"}
{"name":"Dynamics.coverMincard_empty","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nU : Set (Prod X X)\nn : Nat\n‚ä¢ Eq (Dynamics.coverMincard T EmptyCollection.emptyCollection U n) 0","decl":"@[simp]\nlemma coverMincard_empty {T : X ‚Üí X} {U : Set (X √ó X)} {n : ‚Ñï} : coverMincard T ‚àÖ U n = 0 :=\n  (sInf_le (by simp [IsDynCoverOf])).antisymm (zero_le (coverMincard T ‚àÖ U n))\n\n"}
{"name":"Dynamics.coverMincard_eq_zero_iff","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nn : Nat\n‚ä¢ Iff (Eq (Dynamics.coverMincard T F U n) 0) (Eq F EmptyCollection.emptyCollection)","decl":"lemma coverMincard_eq_zero_iff (T : X ‚Üí X) (F : Set X) (U : Set (X √ó X)) (n : ‚Ñï) :\n    coverMincard T F U n = 0 ‚Üî F = ‚àÖ := by\n  refine Iff.intro (fun h ‚Ü¶ subset_empty_iff.1 ?_) (fun F_empt ‚Ü¶ by rw [F_empt, coverMincard_empty])\n  have := coverMincard_finite_iff T F U n\n  rw [h, eq_true ENat.top_pos, true_iff] at this\n  simp only [IsDynCoverOf, Finset.mem_coe, Nat.cast_eq_zero, Finset.card_eq_zero, exists_eq_right,\n    Finset.not_mem_empty, iUnion_of_empty, iUnion_empty] at this\n  exact this\n\n"}
{"name":"Dynamics.one_le_coverMincard_iff","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nn : Nat\n‚ä¢ Iff (LE.le 1 (Dynamics.coverMincard T F U n)) F.Nonempty","decl":"lemma one_le_coverMincard_iff (T : X ‚Üí X) (F : Set X) (U : Set (X √ó X)) (n : ‚Ñï) :\n    1 ‚â§ coverMincard T F U n ‚Üî F.Nonempty := by\n  rw [ENat.one_le_iff_ne_zero, nonempty_iff_ne_empty, not_iff_not]\n  exact coverMincard_eq_zero_iff T F U n\n\n"}
{"name":"Dynamics.coverMincard_zero","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nh : F.Nonempty\nU : Set (Prod X X)\n‚ä¢ Eq (Dynamics.coverMincard T F U 0) 1","decl":"lemma coverMincard_zero (T : X ‚Üí X) {F : Set X} (h : F.Nonempty) (U : Set (X √ó X)) :\n    coverMincard T F U 0 = 1 := by\n  apply le_antisymm _ ((one_le_coverMincard_iff T F U 0).2 h)\n  rcases h with ‚ü®x, _‚ü©\n  have := isDynCoverOf_zero T F U (singleton_nonempty x)\n  rw [‚Üê Finset.coe_singleton] at this\n  apply this.coverMincard_le_card.trans_eq\n  rw [Finset.card_singleton, Nat.cast_one]\n\n"}
{"name":"Dynamics.coverMincard_univ","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nh : F.Nonempty\nn : Nat\n‚ä¢ Eq (Dynamics.coverMincard T F Set.univ n) 1","decl":"lemma coverMincard_univ (T : X ‚Üí X) {F : Set X} (h : F.Nonempty) (n : ‚Ñï) :\n    coverMincard T F univ n = 1 := by\n  apply le_antisymm _ ((one_le_coverMincard_iff T F univ n).2 h)\n  rcases h with ‚ü®x, _‚ü©\n  have := isDynCoverOf_univ T F n (singleton_nonempty x)\n  rw [‚Üê Finset.coe_singleton] at this\n  apply this.coverMincard_le_card.trans_eq\n  rw [Finset.card_singleton, Nat.cast_one]\n\n"}
{"name":"Dynamics.coverMincard_mul_le_pow","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_symm : SymmetricRel U\nm n : Nat\n‚ä¢ LE.le (Dynamics.coverMincard T F (compRel U U) (HMul.hMul m n)) (HPow.hPow (Dynamics.coverMincard T F U m) n)","decl":"lemma coverMincard_mul_le_pow {T : X ‚Üí X} {F : Set X} (F_inv : MapsTo T F F) {U : Set (X √ó X)}\n    (U_symm : SymmetricRel U) (m n : ‚Ñï) :\n    coverMincard T F (U ‚óã U) (m * n) ‚â§ coverMincard T F U m ^ n := by\n  rcases F.eq_empty_or_nonempty with rfl | F_nonempty\n  ¬∑ rw [coverMincard_empty]; exact zero_le _\n  rcases n.eq_zero_or_pos with rfl | n_pos\n  ¬∑ rw [mul_zero, coverMincard_zero T F_nonempty (U ‚óã U), pow_zero]\n  rcases eq_top_or_lt_top (coverMincard T F U m) with h | h\n  ¬∑ exact h ‚ñ∏ (le_top (Œ± := ‚Ñï‚àû)).trans_eq (ENat.top_pow n_pos).symm\n  ¬∑ rcases (coverMincard_finite_iff T F U m).1 h with ‚ü®s, s_cover, s_coverMincard‚ü©\n    rcases s_cover.iterate_le_pow F_inv U_symm n with ‚ü®t, t_cover, t_le_sn‚ü©\n    rw [‚Üê s_coverMincard]\n    exact t_cover.coverMincard_le_card.trans (WithTop.coe_le_coe.2 t_le_sn)\n\n"}
{"name":"Dynamics.coverMincard_le_pow","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_symm : SymmetricRel U\nm : Nat\nm_pos : LT.lt 0 m\nn : Nat\n‚ä¢ LE.le (Dynamics.coverMincard T F (compRel U U) n) (HPow.hPow (Dynamics.coverMincard T F U m) (HAdd.hAdd (HDiv.hDiv n m) 1))","decl":"lemma coverMincard_le_pow {T : X ‚Üí X} {F : Set X} (F_inv : MapsTo T F F) {U : Set (X √ó X)}\n    (U_symm : SymmetricRel U) {m : ‚Ñï} (m_pos : 0 < m) (n : ‚Ñï) :\n    coverMincard T F (U ‚óã U) n ‚â§ coverMincard T F U m ^ (n / m + 1) :=\n  (coverMincard_monotone_time T F (U ‚óã U) (Nat.lt_mul_div_succ n m_pos).le).trans\n    (coverMincard_mul_le_pow F_inv U_symm m (n / m + 1))\n\n"}
{"name":"Dynamics.coverMincard_finite_of_isCompact_uniformContinuous","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\nT : X ‚Üí X\nF : Set X\nF_comp : IsCompact F\nh : UniformContinuous T\nU : Set (Prod X X)\nU_uni : Membership.mem (uniformity X) U\nn : Nat\n‚ä¢ LT.lt (Dynamics.coverMincard T F U n) Top.top","decl":"lemma coverMincard_finite_of_isCompact_uniformContinuous [UniformSpace X] {T : X ‚Üí X}\n    {F : Set X} (F_comp : IsCompact F) (h : UniformContinuous T) {U : Set (X √ó X)} (U_uni : U ‚àà ùì§ X)\n    (n : ‚Ñï) :\n    coverMincard T F U n < ‚ä§ := by\n  rcases exists_isDynCoverOf_of_isCompact_uniformContinuous F_comp h U_uni n with ‚ü®s, s_cover‚ü©\n  exact s_cover.coverMincard_le_card.trans_lt (WithTop.coe_lt_top s.card)\n\n"}
{"name":"Dynamics.coverMincard_finite_of_isCompact_invariant","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\nT : X ‚Üí X\nF : Set X\nF_comp : IsCompact F\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_uni : Membership.mem (uniformity X) U\nn : Nat\n‚ä¢ LT.lt (Dynamics.coverMincard T F U n) Top.top","decl":"lemma coverMincard_finite_of_isCompact_invariant [UniformSpace X] {T : X ‚Üí X} {F : Set X}\n    (F_comp : IsCompact F) (F_inv : MapsTo T F F) {U : Set (X √ó X)} (U_uni : U ‚àà ùì§ X) (n : ‚Ñï) :\n    coverMincard T F U n < ‚ä§ := by\n  rcases exists_isDynCoverOf_of_isCompact_invariant F_comp F_inv U_uni n with ‚ü®s, s_cover‚ü©\n  exact s_cover.coverMincard_le_card.trans_lt (WithTop.coe_lt_top s.card)\n\n"}
{"name":"Dynamics.nonempty_inter_of_coverMincard","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nn : Nat\ns : Finset X\nh : Dynamics.IsDynCoverOf T F U n ‚Üës\nh' : Eq (‚Üës.card) (Dynamics.coverMincard T F U n)\nx : X\na‚úù : Membership.mem s x\n‚ä¢ (Inter.inter F (UniformSpace.ball x (Dynamics.dynEntourage T U n))).Nonempty","decl":"/-- All dynamical balls of a minimal dynamical cover of `F` intersect `F`. This lemma is the key\n  to relate Bowen-Dinaburg's definition of topological entropy with covers and their definition\n  of topological entropy with nets.-/\nlemma nonempty_inter_of_coverMincard {T : X ‚Üí X} {F : Set X} {U : Set (X √ó X)} {n : ‚Ñï}\n    {s : Finset X} (h : IsDynCoverOf T F U n s) (h' : s.card = coverMincard T F U n) :\n    ‚àÄ x ‚àà s, (F ‚à© ball x (dynEntourage T U n)).Nonempty := by\n  -- Otherwise, there is a ball which does not intersect `F`. Removing it yields a smaller cover.\n  classical\n  by_contra! hypo\n  rcases hypo with ‚ü®x, x_s, ball_empt‚ü©\n  have smaller_cover : IsDynCoverOf T F U n (Finset.erase s x) := by\n    intro y y_F\n    specialize h y_F\n    simp only [Finset.mem_coe, mem_iUnion, exists_prop] at h\n    rcases h with ‚ü®z, z_s, hz‚ü©\n    simp only [Finset.coe_erase, mem_diff, Finset.mem_coe, mem_singleton_iff, mem_iUnion,\n      exists_prop]\n    refine ‚ü®z, And.intro (And.intro z_s fun z_x ‚Ü¶ not_mem_empty y ?_) hz‚ü©\n    rw [‚Üê ball_empt]\n    rw [z_x] at hz\n    exact mem_inter y_F hz\n  apply smaller_cover.coverMincard_le_card.not_lt\n  rw [‚Üê h']\n  exact_mod_cast Finset.card_erase_lt_of_mem x_s\n\n"}
{"name":"Dynamics.log_coverMincard_nonneg","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nh : F.Nonempty\nU : Set (Prod X X)\nn : Nat\n‚ä¢ LE.le 0 (‚Üë(Dynamics.coverMincard T F U n)).log","decl":"lemma log_coverMincard_nonneg (T : X ‚Üí X) {F : Set X} (h : F.Nonempty) (U : Set (X √ó X)) (n : ‚Ñï) :\n    0 ‚â§ log (coverMincard T F U n) := by\n  apply zero_le_log_iff.2\n  rw [‚Üê ENat.toENNReal_one, ENat.toENNReal_le]\n  exact (one_le_coverMincard_iff T F U n).2 h\n\n"}
{"name":"Dynamics.log_coverMincard_iterate_le","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_symm : SymmetricRel U\nm n : Nat\nn_pos : LT.lt 0 n\n‚ä¢ LE.le (HDiv.hDiv (‚Üë(Dynamics.coverMincard T F (compRel U U) (HMul.hMul m n))).log ‚Üën) (‚Üë(Dynamics.coverMincard T F U m)).log","decl":"lemma log_coverMincard_iterate_le {T : X ‚Üí X} {F : Set X} (F_inv : MapsTo T F F) {U : Set (X √ó X)}\n    (U_symm : SymmetricRel U) (m : ‚Ñï) {n : ‚Ñï} (n_pos : 0 < n) :\n    log (coverMincard T F (U ‚óã U) (m * n)) / n ‚â§ log (coverMincard T F U m) := by\n  apply (EReal.div_le_iff_le_mul (b := n) (Nat.cast_pos'.2 n_pos) (natCast_ne_top n)).2\n  rw [‚Üê log_pow, StrictMono.le_iff_le log_strictMono]\n  nth_rw 2 [‚Üê ENat.toENNRealRingHom_apply]\n  rw [‚Üê RingHom.map_pow ENat.toENNRealRingHom _ n, ENat.toENNRealRingHom_apply, ENat.toENNReal_le]\n  exact coverMincard_mul_le_pow F_inv U_symm m n\n\n"}
{"name":"Dynamics.log_coverMincard_le_add","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_symm : SymmetricRel U\nm n : Nat\nm_pos : LT.lt 0 m\nn_pos : LT.lt 0 n\n‚ä¢ LE.le (HDiv.hDiv (‚Üë(Dynamics.coverMincard T F (compRel U U) n)).log ‚Üën) (HAdd.hAdd (HDiv.hDiv (‚Üë(Dynamics.coverMincard T F U m)).log ‚Üëm) (HDiv.hDiv (‚Üë(Dynamics.coverMincard T F U m)).log ‚Üën))","decl":"lemma log_coverMincard_le_add {T : X ‚Üí X} {F : Set X} (F_inv : MapsTo T F F)\n    {U : Set (X √ó X)} (U_symm : SymmetricRel U) {m n : ‚Ñï} (m_pos : 0 < m) (n_pos : 0 < n) :\n    log (coverMincard T F (U ‚óã U) n) / n\n    ‚â§ log (coverMincard T F U m) / m + log (coverMincard T F U m) / n := by\n  -- If `n` is a multiple of `m`, this follows directly from `log_coverMincard_iterate_le`.\n  -- Otherwise, we bound the LHS by the smallest multiple of `m` larger than `n`, which gives the\n  -- error term `log (coverMincard T F U m) / n`.\n  rcases F.eq_empty_or_nonempty with rfl | F_nemp\n  ¬∑ rw [coverMincard_empty, ENat.toENNReal_zero, log_zero,\n      bot_div_of_pos_ne_top (Nat.cast_pos'.2 n_pos) (natCast_ne_top n)]\n    exact bot_le\n  have h_nm : (0 : EReal) ‚â§ (n / m : ‚Ñï) := Nat.cast_nonneg' (n / m)\n  have h_log := log_coverMincard_nonneg T F_nemp U m\n  have n_div_n := EReal.div_self (natCast_ne_bot n) (natCast_ne_top n)\n    (Nat.cast_pos'.2 n_pos).ne.symm\n  apply le_trans <| div_le_div_right_of_nonneg (Nat.cast_pos'.2 n_pos).le\n    (log_monotone (ENat.toENNReal_le.2 (coverMincard_le_pow F_inv U_symm m_pos n)))\n  rw [ENat.toENNReal_pow, log_pow, Nat.cast_add, Nat.cast_one, right_distrib_of_nonneg h_nm\n    zero_le_one, one_mul, div_right_distrib_of_nonneg (Left.mul_nonneg h_nm h_log) h_log, mul_comm,\n    ‚Üê EReal.mul_div, div_eq_mul_inv _ (m : EReal)]\n  apply add_le_add_right (mul_le_mul_of_nonneg_left _ h_log)\n  apply (div_le_div_right_of_nonneg (Nat.cast_pos'.2 n_pos).le (natCast_div_le n m)).trans_eq\n  rw [EReal.div_div, mul_comm, ‚Üê EReal.div_div, n_div_n, one_div (m : EReal)]\n\n"}
{"name":"Dynamics.coverEntropyInfEntourage_antitone","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\n‚ä¢ Antitone fun U => Dynamics.coverEntropyInfEntourage T F U","decl":"lemma coverEntropyInfEntourage_antitone (T : X ‚Üí X) (F : Set X) :\n    Antitone (fun U : Set (X √ó X) ‚Ü¶ coverEntropyInfEntourage T F U) :=\n  fun _ _ U_V ‚Ü¶ (liminf_le_liminf) <| Eventually.of_forall\n    fun n ‚Ü¶ monotone_div_right_of_nonneg (Nat.cast_nonneg' n)\n    <| log_monotone (ENat.toENNReal_mono (coverMincard_antitone T F n U_V))\n\n"}
{"name":"Dynamics.coverEntropyEntourage_antitone","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\n‚ä¢ Antitone fun U => Dynamics.coverEntropyEntourage T F U","decl":"lemma coverEntropyEntourage_antitone (T : X ‚Üí X) (F : Set X) :\n    Antitone (fun U : Set (X √ó X) ‚Ü¶ coverEntropyEntourage T F U) :=\n  fun _ _ U_V ‚Ü¶ (limsup_le_limsup) <| Eventually.of_forall\n    fun n ‚Ü¶ monotone_div_right_of_nonneg (Nat.cast_nonneg' n)\n    <| log_monotone (ENat.toENNReal_mono (coverMincard_antitone T F n U_V))\n\n"}
{"name":"Dynamics.coverEntropyInfEntourage_le_coverEntropyEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\n‚ä¢ LE.le (Dynamics.coverEntropyInfEntourage T F U) (Dynamics.coverEntropyEntourage T F U)","decl":"lemma coverEntropyInfEntourage_le_coverEntropyEntourage (T : X ‚Üí X) (F : Set X) (U : Set (X √ó X)) :\n    coverEntropyInfEntourage T F U ‚â§ coverEntropyEntourage T F U := liminf_le_limsup\n\n"}
{"name":"Dynamics.coverEntropyEntourage_empty","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nU : Set (Prod X X)\n‚ä¢ Eq (Dynamics.coverEntropyEntourage T EmptyCollection.emptyCollection U) Bot.bot","decl":"@[simp]\nlemma coverEntropyEntourage_empty {T : X ‚Üí X} {U : Set (X √ó X)} :\n    coverEntropyEntourage T ‚àÖ U = ‚ä• := by\n  suffices h : ‚àÄ·∂† n : ‚Ñï in atTop, log (coverMincard T ‚àÖ U n) / n = ‚ä• by\n    rw [coverEntropyEntourage]\n    exact limsup_congr h ‚ñ∏ limsup_const ‚ä•\n  ¬∑ simp only [coverMincard_empty, ENat.toENNReal_zero, log_zero, eventually_atTop]\n    exact ‚ü®1, fun n n_pos ‚Ü¶ bot_div_of_pos_ne_top (Nat.cast_pos'.2 n_pos) (natCast_ne_top n)‚ü©\n\n"}
{"name":"Dynamics.coverEntropyInfEntourage_empty","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nU : Set (Prod X X)\n‚ä¢ Eq (Dynamics.coverEntropyInfEntourage T EmptyCollection.emptyCollection U) Bot.bot","decl":"@[simp]\nlemma coverEntropyInfEntourage_empty {T : X ‚Üí X} {U : Set (X √ó X)} :\n    coverEntropyInfEntourage T ‚àÖ U = ‚ä• :=\n  eq_bot_mono (coverEntropyInfEntourage_le_coverEntropyEntourage T ‚àÖ U) coverEntropyEntourage_empty\n\n"}
{"name":"Dynamics.coverEntropyInfEntourage_nonneg","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nh : F.Nonempty\nU : Set (Prod X X)\n‚ä¢ LE.le 0 (Dynamics.coverEntropyInfEntourage T F U)","decl":"lemma coverEntropyInfEntourage_nonneg (T : X ‚Üí X) {F : Set X} (h : F.Nonempty) (U : Set (X √ó X)) :\n    0 ‚â§ coverEntropyInfEntourage T F U :=\n  (le_iInf fun n ‚Ü¶ div_nonneg (log_coverMincard_nonneg T h U n) (Nat.cast_nonneg' n)).trans\n    iInf_le_liminf\n\n"}
{"name":"Dynamics.coverEntropyEntourage_nonneg","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nh : F.Nonempty\nU : Set (Prod X X)\n‚ä¢ LE.le 0 (Dynamics.coverEntropyEntourage T F U)","decl":"lemma coverEntropyEntourage_nonneg (T : X ‚Üí X) {F : Set X} (h : F.Nonempty) (U : Set (X √ó X)) :\n    0 ‚â§ coverEntropyEntourage T F U :=\n  (coverEntropyInfEntourage_nonneg T h U).trans\n    (coverEntropyInfEntourage_le_coverEntropyEntourage T F U)\n\n"}
{"name":"Dynamics.coverEntropyEntourage_univ","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nh : F.Nonempty\n‚ä¢ Eq (Dynamics.coverEntropyEntourage T F Set.univ) 0","decl":"lemma coverEntropyEntourage_univ (T : X ‚Üí X) {F : Set X} (h : F.Nonempty) :\n    coverEntropyEntourage T F univ = 0 := by\n  simp [coverEntropyEntourage, coverMincard_univ T h]\n\n"}
{"name":"Dynamics.coverEntropyInfEntourage_univ","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nh : F.Nonempty\n‚ä¢ Eq (Dynamics.coverEntropyInfEntourage T F Set.univ) 0","decl":"lemma coverEntropyInfEntourage_univ (T : X ‚Üí X) {F : Set X} (h : F.Nonempty) :\n    coverEntropyInfEntourage T F univ = 0 := by\n  simp [coverEntropyInfEntourage, coverMincard_univ T h]\n\n"}
{"name":"Dynamics.coverEntropyEntourage_le_log_coverMincard_div","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_symm : SymmetricRel U\nn : Nat\nn_pos : LT.lt 0 n\n‚ä¢ LE.le (Dynamics.coverEntropyEntourage T F (compRel U U)) (HDiv.hDiv (‚Üë(Dynamics.coverMincard T F U n)).log ‚Üën)","decl":"lemma coverEntropyEntourage_le_log_coverMincard_div {T : X ‚Üí X} {F : Set X} (F_inv : MapsTo T F F)\n    {U : Set (X √ó X)} (U_symm : SymmetricRel U) {n : ‚Ñï} (n_pos : 0 < n) :\n    coverEntropyEntourage T F (U ‚óã U) ‚â§ log (coverMincard T F U n) / n := by\n  -- Deal with the edge cases: `F = ‚àÖ` or `F` has no finite cover.\n  rcases eq_or_ne (log (coverMincard T F U n)) ‚ä• with logm_bot | logm_nneg\n  ¬∑ rw [log_eq_bot_iff, ‚Üê ENat.toENNReal_zero, ENat.toENNReal_inj,\n      coverMincard_eq_zero_iff T F U n] at logm_bot\n    simp [logm_bot]\n  rcases eq_or_ne (log (coverMincard T F U n)) ‚ä§ with logm_top | logm_fin\n  ¬∑ rw [logm_top, top_div_of_pos_ne_top (Nat.cast_pos'.2 n_pos) (natCast_ne_top n)]\n    exact le_top\n  -- The general case follows from `log_coverMincard_le_add`, with careful manipulation of limits.\n  let u := fun _ : ‚Ñï ‚Ü¶ log (coverMincard T F U n) / n\n  let v := fun m : ‚Ñï ‚Ü¶ log (coverMincard T F U n) / m\n  let w := fun m : ‚Ñï ‚Ü¶ log (coverMincard T F (U ‚óã U) m) / m\n  have key : w ‚â§·∂†[atTop] u + v :=\n    eventually_atTop.2 ‚ü®1, fun m m_pos ‚Ü¶ log_coverMincard_le_add F_inv U_symm n_pos m_pos‚ü©\n  apply ((limsup_le_limsup) key).trans\n  suffices h : atTop.limsup v = 0 by\n    have := @limsup_add_le ‚Ñï atTop u v\n    rw [h, add_zero] at this\n    specialize this (Or.inr EReal.zero_ne_top) (Or.inr EReal.zero_ne_bot)\n    exact this.trans_eq (limsup_const (log (coverMincard T F U n) / n))\n  exact Tendsto.limsup_eq (EReal.tendsto_const_div_atTop_nhds_zero_nat logm_nneg logm_fin)\n\n"}
{"name":"Dynamics.IsDynCoverOf.coverEntropyEntourage_le_log_card_div","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_symm : SymmetricRel U\nn : Nat\nn_pos : LT.lt 0 n\ns : Finset X\nh : Dynamics.IsDynCoverOf T F U n ‚Üës\n‚ä¢ LE.le (Dynamics.coverEntropyEntourage T F (compRel U U)) (HDiv.hDiv (‚Üës.card).log ‚Üën)","decl":"lemma IsDynCoverOf.coverEntropyEntourage_le_log_card_div {T : X ‚Üí X} {F : Set X}\n    (F_inv : MapsTo T F F) {U : Set (X √ó X)} (U_symm : SymmetricRel U) {n : ‚Ñï} (n_pos : 0 < n)\n    {s : Finset X} (h : IsDynCoverOf T F U n s) :\n    coverEntropyEntourage T F (U ‚óã U) ‚â§ log s.card / n := by\n  apply (coverEntropyEntourage_le_log_coverMincard_div F_inv U_symm n_pos).trans\n  apply monotone_div_right_of_nonneg (Nat.cast_nonneg' n) (log_monotone _)\n  exact_mod_cast coverMincard_le_card h\n\n"}
{"name":"Dynamics.coverEntropyEntourage_le_coverEntropyInfEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_symm : SymmetricRel U\n‚ä¢ LE.le (Dynamics.coverEntropyEntourage T F (compRel U U)) (Dynamics.coverEntropyInfEntourage T F U)","decl":"lemma coverEntropyEntourage_le_coverEntropyInfEntourage {T : X ‚Üí X} {F : Set X}\n    (F_inv : MapsTo T F F) {U : Set (X √ó X)} (U_symm : SymmetricRel U) :\n    coverEntropyEntourage T F (U ‚óã U) ‚â§ coverEntropyInfEntourage T F U :=\n  (le_liminf_of_le) (eventually_atTop.2\n    ‚ü®1, fun m m_pos ‚Ü¶ coverEntropyEntourage_le_log_coverMincard_div F_inv U_symm m_pos‚ü©)\n\n"}
{"name":"Dynamics.coverEntropyEntourage_finite_of_isCompact_invariant","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\nT : X ‚Üí X\nF : Set X\nF_comp : IsCompact F\nF_inv : Set.MapsTo T F F\nU : Set (Prod X X)\nU_uni : Membership.mem (uniformity X) U\n‚ä¢ LT.lt (Dynamics.coverEntropyEntourage T F U) Top.top","decl":"lemma coverEntropyEntourage_finite_of_isCompact_invariant [UniformSpace X] {T : X ‚Üí X} {F : Set X}\n    (F_comp : IsCompact F) (F_inv : MapsTo T F F) {U : Set (X √ó X)} (U_uni : U ‚àà ùì§ X) :\n    coverEntropyEntourage T F U < ‚ä§ := by\n  rcases comp_symm_mem_uniformity_sets U_uni with ‚ü®V, V_uni, V_symm, V_U‚ü©\n  rcases exists_isDynCoverOf_of_isCompact_invariant F_comp F_inv V_uni 1 with ‚ü®s, s_cover‚ü©\n  apply (coverEntropyEntourage_antitone T F V_U).trans_lt\n  apply (s_cover.coverEntropyEntourage_le_log_card_div F_inv V_symm zero_lt_one).trans_lt\n  rw [Nat.cast_one, div_one, log_lt_top_iff, ‚Üê ENat.toENNReal_top]\n  exact_mod_cast Ne.lt_top (ENat.coe_ne_top (Finset.card s))\n\n"}
{"name":"Dynamics.coverEntropyInf_antitone","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\n‚ä¢ Antitone fun u => Dynamics.coverEntropyInf T F","decl":"lemma coverEntropyInf_antitone (T : X ‚Üí X) (F : Set X) :\n    Antitone fun (u : UniformSpace X) ‚Ü¶ @coverEntropyInf X u T F :=\n  fun _ _ h ‚Ü¶ iSup‚ÇÇ_mono' fun U U_uni ‚Ü¶ ‚ü®U, (le_def.1 h) U U_uni, le_refl _‚ü©\n\n"}
{"name":"Dynamics.coverEntropy_antitone","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\nT : X ‚Üí X\nF : Set X\n‚ä¢ Antitone fun u => Dynamics.coverEntropy T F","decl":"lemma coverEntropy_antitone (T : X ‚Üí X) (F : Set X) :\n    Antitone fun (u : UniformSpace X) ‚Ü¶ @coverEntropy X u T F :=\n  fun _ _ h ‚Ü¶ iSup‚ÇÇ_mono' fun U U_uni ‚Ü¶ ‚ü®U, (le_def.1 h) U U_uni, le_refl _‚ü©\n\n"}
{"name":"Dynamics.coverEntropyEntourage_le_coverEntropy","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nh : Membership.mem (uniformity X) U\n‚ä¢ LE.le (Dynamics.coverEntropyEntourage T F U) (Dynamics.coverEntropy T F)","decl":"lemma coverEntropyEntourage_le_coverEntropy (T : X ‚Üí X) (F : Set X) {U : Set (X √ó X)}\n    (h : U ‚àà ùì§ X) :\n    coverEntropyEntourage T F U ‚â§ coverEntropy T F :=\n  le_iSup‚ÇÇ (f := fun (U : Set (X √ó X)) (_ : U ‚àà ùì§ X) ‚Ü¶ coverEntropyEntourage T F U) U h\n\n"}
{"name":"Dynamics.coverEntropyInfEntourage_le_coverEntropyInf","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\nT : X ‚Üí X\nF : Set X\nU : Set (Prod X X)\nh : Membership.mem (uniformity X) U\n‚ä¢ LE.le (Dynamics.coverEntropyInfEntourage T F U) (Dynamics.coverEntropyInf T F)","decl":"lemma coverEntropyInfEntourage_le_coverEntropyInf (T : X ‚Üí X) (F : Set X) {U : Set (X √ó X)}\n    (h : U ‚àà ùì§ X) :\n    coverEntropyInfEntourage T F U ‚â§ coverEntropyInf T F :=\n  le_iSup‚ÇÇ (f := fun (U : Set (X √ó X)) (_ : U ‚àà ùì§ X) ‚Ü¶ coverEntropyInfEntourage T F U) U h\n\n"}
{"name":"Dynamics.coverEntropy_eq_iSup_basis","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\nŒπ : Sort u_2\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set (Prod X X)\nh : (uniformity X).HasBasis p s\nT : X ‚Üí X\nF : Set X\n‚ä¢ Eq (Dynamics.coverEntropy T F) (iSup fun i => iSup fun x => Dynamics.coverEntropyEntourage T F (s i))","decl":"lemma coverEntropy_eq_iSup_basis {Œπ : Sort*} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set (X √ó X)}\n    (h : (ùì§ X).HasBasis p s) (T : X ‚Üí X) (F : Set X) :\n    coverEntropy T F = ‚®Ü (i : Œπ) (_ : p i), coverEntropyEntourage T F (s i) := by\n  refine (iSup‚ÇÇ_le fun U U_uni ‚Ü¶ ?_).antisymm\n    (iSup‚ÇÇ_mono' fun i h_i ‚Ü¶ ‚ü®s i, HasBasis.mem_of_mem h h_i, le_refl _‚ü©)\n  rcases (HasBasis.mem_iff h).1 U_uni with ‚ü®i, h_i, si_U‚ü©\n  exact (coverEntropyEntourage_antitone T F si_U).trans\n    (le_iSup‚ÇÇ (f := fun (i : Œπ) (_ : p i) ‚Ü¶ coverEntropyEntourage T F (s i)) i h_i)\n\n"}
{"name":"Dynamics.coverEntropyInf_eq_iSup_basis","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\nŒπ : Sort u_2\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set (Prod X X)\nh : (uniformity X).HasBasis p s\nT : X ‚Üí X\nF : Set X\n‚ä¢ Eq (Dynamics.coverEntropyInf T F) (iSup fun i => iSup fun x => Dynamics.coverEntropyInfEntourage T F (s i))","decl":"lemma coverEntropyInf_eq_iSup_basis {Œπ : Sort*} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set (X √ó X)}\n    (h : (ùì§ X).HasBasis p s) (T : X ‚Üí X) (F : Set X) :\n    coverEntropyInf T F = ‚®Ü (i : Œπ) (_ : p i), coverEntropyInfEntourage T F (s i) := by\n  refine (iSup‚ÇÇ_le fun U U_uni ‚Ü¶ ?_).antisymm\n    (iSup‚ÇÇ_mono' fun i h_i ‚Ü¶ ‚ü®s i, HasBasis.mem_of_mem h h_i, le_refl _‚ü©)\n  rcases (HasBasis.mem_iff h).1 U_uni with ‚ü®i, h_i, si_U‚ü©\n  exact (coverEntropyInfEntourage_antitone T F si_U).trans\n    (le_iSup‚ÇÇ (f := fun (i : Œπ) (_ : p i) ‚Ü¶ coverEntropyInfEntourage T F (s i)) i h_i)\n\n"}
{"name":"Dynamics.coverEntropyInf_le_coverEntropy","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\nT : X ‚Üí X\nF : Set X\n‚ä¢ LE.le (Dynamics.coverEntropyInf T F) (Dynamics.coverEntropy T F)","decl":"lemma coverEntropyInf_le_coverEntropy (T : X ‚Üí X) (F : Set X) :\n    coverEntropyInf T F ‚â§ coverEntropy T F :=\n  iSup‚ÇÇ_mono fun (U : Set (X √ó X)) (_ : U ‚àà ùì§ X) ‚Ü¶\n    coverEntropyInfEntourage_le_coverEntropyEntourage T F U\n\n"}
{"name":"Dynamics.coverEntropy_empty","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\nT : X ‚Üí X\n‚ä¢ Eq (Dynamics.coverEntropy T EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\nlemma coverEntropy_empty {T : X ‚Üí X} : coverEntropy T ‚àÖ = ‚ä• := by\n  simp only [coverEntropy, coverEntropyEntourage_empty, iSup_bot]\n\n"}
{"name":"Dynamics.coverEntropyInf_empty","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\nT : X ‚Üí X\n‚ä¢ Eq (Dynamics.coverEntropyInf T EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\nlemma coverEntropyInf_empty {T : X ‚Üí X} : coverEntropyInf T ‚àÖ = ‚ä• := by\n  simp only [coverEntropyInf, coverEntropyInfEntourage_empty, iSup_bot]\n\n"}
{"name":"Dynamics.coverEntropyInf_nonneg","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\nT : X ‚Üí X\nF : Set X\nh : F.Nonempty\n‚ä¢ LE.le 0 (Dynamics.coverEntropyInf T F)","decl":"lemma coverEntropyInf_nonneg (T : X ‚Üí X) {F : Set X} (h : F.Nonempty) :\n    0 ‚â§ coverEntropyInf T F :=\n  (coverEntropyInfEntourage_le_coverEntropyInf T F univ_mem).trans_eq'\n    (coverEntropyInfEntourage_univ T h).symm\n\n"}
{"name":"Dynamics.coverEntropy_nonneg","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\nT : X ‚Üí X\nF : Set X\nh : F.Nonempty\n‚ä¢ LE.le 0 (Dynamics.coverEntropy T F)","decl":"lemma coverEntropy_nonneg (T : X ‚Üí X) {F : Set X} (h : F.Nonempty) :\n    0 ‚â§ coverEntropy T F :=\n  (coverEntropyInf_nonneg T h).trans (coverEntropyInf_le_coverEntropy T F)\n\n"}
{"name":"Dynamics.coverEntropyInf_eq_coverEntropy","module":"Mathlib.Dynamics.TopologicalEntropy.CoverEntropy","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\nT : X ‚Üí X\nF : Set X\nh : Set.MapsTo T F F\n‚ä¢ Eq (Dynamics.coverEntropyInf T F) (Dynamics.coverEntropy T F)","decl":"lemma coverEntropyInf_eq_coverEntropy (T : X ‚Üí X) {F : Set X} (h : MapsTo T F F) :\n    coverEntropyInf T F = coverEntropy T F := by\n  refine le_antisymm (coverEntropyInf_le_coverEntropy T F) (iSup‚ÇÇ_le fun U U_uni ‚Ü¶ ?_)\n  rcases comp_symm_mem_uniformity_sets U_uni with ‚ü®V, V_uni, V_symm, V_U‚ü©\n  exact (coverEntropyEntourage_antitone T F V_U).trans\n    (le_iSup‚ÇÇ_of_le V V_uni (coverEntropyEntourage_le_coverEntropyInfEntourage h V_symm))\n\n"}
