{"name":"Set.nil_mem_subchain","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ninst✝ : LT α\ns : Set α\n⊢ Membership.mem s.subchain List.nil","decl":"@[simp] -- porting note: new `simp`\ntheorem nil_mem_subchain : [] ∈ s.subchain := ⟨trivial, fun _ ↦ nofun⟩\n\n"}
{"name":"Set.cons_mem_subchain_iff","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ninst✝ : LT α\ns : Set α\nl : List α\na : α\n⊢ Iff (Membership.mem s.subchain (List.cons a l)) (And (Membership.mem s a) (And (Membership.mem s.subchain l) (∀ (b : α), Membership.mem l.head? b → LT.lt a b)))","decl":"theorem cons_mem_subchain_iff :\n    (a::l) ∈ s.subchain ↔ a ∈ s ∧ l ∈ s.subchain ∧ ∀ b ∈ l.head?, a < b := by\n  simp only [subchain, mem_setOf_eq, forall_mem_cons, chain'_cons', and_left_comm, and_comm,\n    and_assoc]\n\n"}
{"name":"Set.singleton_mem_subchain_iff","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ninst✝ : LT α\ns : Set α\na : α\n⊢ Iff (Membership.mem s.subchain (List.cons a List.nil)) (Membership.mem s a)","decl":"@[simp]\ntheorem singleton_mem_subchain_iff : [a] ∈ s.subchain ↔ a ∈ s := by simp [cons_mem_subchain_iff]\n\n"}
{"name":"Set.instNonemptyElemListSubchain","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ninst✝ : LT α\ns : Set α\n⊢ Nonempty ↑s.subchain","decl":"instance : Nonempty s.subchain :=\n  ⟨⟨[], s.nil_mem_subchain⟩⟩\n\n"}
{"name":"Set.chainHeight_eq_iSup_subtype","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ninst✝ : LT α\ns : Set α\n⊢ Eq s.chainHeight (iSup fun l => ↑(↑l).length)","decl":"theorem chainHeight_eq_iSup_subtype : s.chainHeight = ⨆ l : s.subchain, ↑l.1.length :=\n  iSup_subtype'\n\n"}
{"name":"Set.exists_chain_of_le_chainHeight","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ninst✝ : LT α\ns : Set α\nn : Nat\nhn : LE.le (↑n) s.chainHeight\n⊢ Exists fun l => And (Membership.mem s.subchain l) (Eq l.length n)","decl":"theorem exists_chain_of_le_chainHeight {n : ℕ} (hn : ↑n ≤ s.chainHeight) :\n    ∃ l ∈ s.subchain, length l = n := by\n  rcases (le_top : s.chainHeight ≤ ⊤).eq_or_lt with ha | ha <;>\n    rw [chainHeight_eq_iSup_subtype] at ha\n  · obtain ⟨_, ⟨⟨l, h₁, h₂⟩, rfl⟩, h₃⟩ :=\n      not_bddAbove_iff'.mp (WithTop.iSup_coe_eq_top.1 ha) n\n    exact ⟨l.take n, ⟨h₁.take _, fun x h ↦ h₂ _ <| take_subset _ _ h⟩,\n      (l.length_take n).trans <| min_eq_left <| le_of_not_ge h₃⟩\n  · rw [ENat.iSup_coe_lt_top] at ha\n    obtain ⟨⟨l, h₁, h₂⟩, e : l.length = _⟩ := Nat.sSup_mem (Set.range_nonempty _) ha\n    refine\n      ⟨l.take n, ⟨h₁.take _, fun x h ↦ h₂ _ <| take_subset _ _ h⟩,\n        (l.length_take n).trans <| min_eq_left <| ?_⟩\n    rwa [e, ← Nat.cast_le (α := ℕ∞), sSup_range, ENat.coe_iSup ha, ← chainHeight_eq_iSup_subtype]\n\n"}
{"name":"Set.le_chainHeight_TFAE","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ninst✝ : LT α\ns : Set α\nn : Nat\n⊢ (List.cons (LE.le (↑n) s.chainHeight) (List.cons (Exists fun l => And (Membership.mem s.subchain l) (Eq l.length n)) (List.cons (Exists fun l => And (Membership.mem s.subchain l) (LE.le n l.length)) List.nil))).TFAE","decl":"theorem le_chainHeight_TFAE (n : ℕ) :\n    TFAE [↑n ≤ s.chainHeight, ∃ l ∈ s.subchain, length l = n, ∃ l ∈ s.subchain, n ≤ length l] := by\n  tfae_have 1 → 2 := s.exists_chain_of_le_chainHeight\n  tfae_have 2 → 3 := fun ⟨l, hls, he⟩ ↦ ⟨l, hls, he.ge⟩\n  tfae_have 3 → 1 := fun ⟨l, hs, hn⟩ ↦ le_iSup₂_of_le l hs (WithTop.coe_le_coe.2 hn)\n  tfae_finish\n\n"}
{"name":"Set.le_chainHeight_iff","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ninst✝ : LT α\ns : Set α\nn : Nat\n⊢ Iff (LE.le (↑n) s.chainHeight) (Exists fun l => And (Membership.mem s.subchain l) (Eq l.length n))","decl":"theorem le_chainHeight_iff {n : ℕ} : ↑n ≤ s.chainHeight ↔ ∃ l ∈ s.subchain, length l = n :=\n  (le_chainHeight_TFAE s n).out 0 1\n\n"}
{"name":"Set.length_le_chainHeight_of_mem_subchain","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ninst✝ : LT α\ns : Set α\nl : List α\nhl : Membership.mem s.subchain l\n⊢ LE.le (↑l.length) s.chainHeight","decl":"theorem length_le_chainHeight_of_mem_subchain (hl : l ∈ s.subchain) : ↑l.length ≤ s.chainHeight :=\n  le_chainHeight_iff.mpr ⟨l, hl, rfl⟩\n\n"}
{"name":"Set.chainHeight_eq_top_iff","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ninst✝ : LT α\ns : Set α\n⊢ Iff (Eq s.chainHeight Top.top) (∀ (n : Nat), Exists fun l => And (Membership.mem s.subchain l) (Eq l.length n))","decl":"theorem chainHeight_eq_top_iff : s.chainHeight = ⊤ ↔ ∀ n, ∃ l ∈ s.subchain, length l = n := by\n  refine ⟨fun h n ↦ le_chainHeight_iff.1 (le_top.trans_eq h.symm), fun h ↦ ?_⟩\n  contrapose! h; obtain ⟨n, hn⟩ := WithTop.ne_top_iff_exists.1 h\n  exact ⟨n + 1, fun l hs ↦ (Nat.lt_succ_iff.2 <| Nat.cast_le.1 <|\n    (length_le_chainHeight_of_mem_subchain hs).trans_eq hn.symm).ne⟩\n\n"}
{"name":"Set.one_le_chainHeight_iff","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ninst✝ : LT α\ns : Set α\n⊢ Iff (LE.le 1 s.chainHeight) s.Nonempty","decl":"@[simp]\ntheorem one_le_chainHeight_iff : 1 ≤ s.chainHeight ↔ s.Nonempty := by\n  rw [← Nat.cast_one, Set.le_chainHeight_iff]\n  simp only [length_eq_one, @and_comm (_ ∈ _), @eq_comm _ _ [_], exists_exists_eq_and,\n    singleton_mem_subchain_iff, Set.Nonempty]\n\n"}
{"name":"Set.chainHeight_eq_zero_iff","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ninst✝ : LT α\ns : Set α\n⊢ Iff (Eq s.chainHeight 0) (Eq s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem chainHeight_eq_zero_iff : s.chainHeight = 0 ↔ s = ∅ := by\n  rw [← not_iff_not, ← Ne, ← ENat.one_le_iff_ne_zero, one_le_chainHeight_iff,\n    nonempty_iff_ne_empty]\n\n"}
{"name":"Set.chainHeight_empty","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ninst✝ : LT α\n⊢ Eq EmptyCollection.emptyCollection.chainHeight 0","decl":"@[simp]\ntheorem chainHeight_empty : (∅ : Set α).chainHeight = 0 :=\n  chainHeight_eq_zero_iff.2 rfl\n\n"}
{"name":"Set.chainHeight_of_isEmpty","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ns : Set α\ninst✝ : IsEmpty α\n⊢ Eq s.chainHeight 0","decl":"@[simp]\ntheorem chainHeight_of_isEmpty [IsEmpty α] : s.chainHeight = 0 :=\n  chainHeight_eq_zero_iff.mpr (Subsingleton.elim _ _)\n\n"}
{"name":"Set.le_chainHeight_add_nat_iff","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ninst✝ : LT α\ns : Set α\nn m : Nat\n⊢ Iff (LE.le (↑n) (HAdd.hAdd s.chainHeight ↑m)) (Exists fun l => And (Membership.mem s.subchain l) (LE.le n (HAdd.hAdd l.length m)))","decl":"theorem le_chainHeight_add_nat_iff {n m : ℕ} :\n    ↑n ≤ s.chainHeight + m ↔ ∃ l ∈ s.subchain, n ≤ length l + m := by\n  simp_rw [← tsub_le_iff_right, ← ENat.coe_sub, (le_chainHeight_TFAE s (n - m)).out 0 2]\n\n"}
{"name":"Set.chainHeight_add_le_chainHeight_add","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\ns : Set α\nt : Set β\nn m : Nat\n⊢ Iff (LE.le (HAdd.hAdd s.chainHeight ↑n) (HAdd.hAdd t.chainHeight ↑m)) (∀ (l : List α), Membership.mem s.subchain l → Exists fun l' => And (Membership.mem t.subchain l') (LE.le (HAdd.hAdd l.length n) (HAdd.hAdd l'.length m)))","decl":"theorem chainHeight_add_le_chainHeight_add (s : Set α) (t : Set β) (n m : ℕ) :\n    s.chainHeight + n ≤ t.chainHeight + m ↔\n      ∀ l ∈ s.subchain, ∃ l' ∈ t.subchain, length l + n ≤ length l' + m := by\n  refine\n    ⟨fun e l h ↦\n      le_chainHeight_add_nat_iff.1\n        ((add_le_add_right (length_le_chainHeight_of_mem_subchain h) _).trans e),\n      fun H ↦ ?_⟩\n  by_cases h : s.chainHeight = ⊤\n  · suffices t.chainHeight = ⊤ by\n      rw [this, top_add]\n      exact le_top\n    rw [chainHeight_eq_top_iff] at h ⊢\n    intro k\n    have := (le_chainHeight_TFAE t k).out 1 2\n    rw [this]\n    obtain ⟨l, hs, hl⟩ := h (k + m)\n    obtain ⟨l', ht, hl'⟩ := H l hs\n    exact ⟨l', ht, (add_le_add_iff_right m).1 <| _root_.trans (hl.symm.trans_le le_self_add) hl'⟩\n  · obtain ⟨k, hk⟩ := WithTop.ne_top_iff_exists.1 h\n    obtain ⟨l, hs, hl⟩ := le_chainHeight_iff.1 hk.le\n    rw [← hk, ← hl]\n    exact le_chainHeight_add_nat_iff.2 (H l hs)\n\n"}
{"name":"Set.chainHeight_le_chainHeight_TFAE","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\ns : Set α\nt : Set β\n⊢ (List.cons (LE.le s.chainHeight t.chainHeight) (List.cons (∀ (l : List α), Membership.mem s.subchain l → Exists fun l' => And (Membership.mem t.subchain l') (Eq l.length l'.length)) (List.cons (∀ (l : List α), Membership.mem s.subchain l → Exists fun l' => And (Membership.mem t.subchain l') (LE.le l.length l'.length)) List.nil))).TFAE","decl":"theorem chainHeight_le_chainHeight_TFAE (s : Set α) (t : Set β) :\n    TFAE [s.chainHeight ≤ t.chainHeight, ∀ l ∈ s.subchain, ∃ l' ∈ t.subchain, length l = length l',\n      ∀ l ∈ s.subchain, ∃ l' ∈ t.subchain, length l ≤ length l'] := by\n  tfae_have 1 ↔ 3 := by\n    convert ← chainHeight_add_le_chainHeight_add s t 0 0 <;> apply add_zero\n  tfae_have 2 ↔ 3 := by\n    refine forall₂_congr fun l _ ↦ ?_\n    simp_rw [← (le_chainHeight_TFAE t l.length).out 1 2, eq_comm]\n  tfae_finish\n\n"}
{"name":"Set.chainHeight_le_chainHeight_iff","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\ns : Set α\nt : Set β\n⊢ Iff (LE.le s.chainHeight t.chainHeight) (∀ (l : List α), Membership.mem s.subchain l → Exists fun l' => And (Membership.mem t.subchain l') (Eq l.length l'.length))","decl":"theorem chainHeight_le_chainHeight_iff {t : Set β} :\n    s.chainHeight ≤ t.chainHeight ↔ ∀ l ∈ s.subchain, ∃ l' ∈ t.subchain, length l = length l' :=\n  (chainHeight_le_chainHeight_TFAE s t).out 0 1\n\n"}
{"name":"Set.chainHeight_le_chainHeight_iff_le","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\ns : Set α\nt : Set β\n⊢ Iff (LE.le s.chainHeight t.chainHeight) (∀ (l : List α), Membership.mem s.subchain l → Exists fun l' => And (Membership.mem t.subchain l') (LE.le l.length l'.length))","decl":"theorem chainHeight_le_chainHeight_iff_le {t : Set β} :\n    s.chainHeight ≤ t.chainHeight ↔ ∀ l ∈ s.subchain, ∃ l' ∈ t.subchain, length l ≤ length l' :=\n  (chainHeight_le_chainHeight_TFAE s t).out 0 2\n\n"}
{"name":"Set.chainHeight_mono","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ninst✝ : LT α\ns t : Set α\nh : HasSubset.Subset s t\n⊢ LE.le s.chainHeight t.chainHeight","decl":"theorem chainHeight_mono (h : s ⊆ t) : s.chainHeight ≤ t.chainHeight :=\n  chainHeight_le_chainHeight_iff.2 fun l hl ↦ ⟨l, ⟨hl.1, fun i hi ↦ h <| hl.2 i hi⟩, rfl⟩\n\n"}
{"name":"Set.chainHeight_image","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LT α\ninst✝ : LT β\nf : α → β\nhf : ∀ {x y : α}, Iff (LT.lt x y) (LT.lt (f x) (f y))\ns : Set α\n⊢ Eq (Set.image f s).chainHeight s.chainHeight","decl":"theorem chainHeight_image (f : α → β) (hf : ∀ {x y}, x < y ↔ f x < f y) (s : Set α) :\n    (f '' s).chainHeight = s.chainHeight := by\n  apply le_antisymm <;> rw [chainHeight_le_chainHeight_iff]\n  · suffices ∀ l ∈ (f '' s).subchain, ∃ l' ∈ s.subchain, map f l' = l by\n      intro l hl\n      obtain ⟨l', h₁, rfl⟩ := this l hl\n      exact ⟨l', h₁, length_map _ _⟩\n    intro l\n    induction' l with x xs hx\n    · exact fun _ ↦ ⟨nil, ⟨trivial, fun x h ↦ (not_mem_nil x h).elim⟩, rfl⟩\n    · intro h\n      rw [cons_mem_subchain_iff] at h\n      obtain ⟨⟨x, hx', rfl⟩, h₁, h₂⟩ := h\n      obtain ⟨l', h₃, rfl⟩ := hx h₁\n      refine ⟨x::l', Set.cons_mem_subchain_iff.mpr ⟨hx', h₃, ?_⟩, rfl⟩\n      cases l'\n      · simp\n      · simpa [← hf] using h₂\n  · intro l hl\n    refine ⟨l.map f, ⟨?_, ?_⟩, ?_⟩\n    · simp_rw [chain'_map, ← hf]\n      exact hl.1\n    · intro _ e\n      obtain ⟨a, ha, rfl⟩ := mem_map.mp e\n      exact Set.mem_image_of_mem _ (hl.2 _ ha)\n    · rw [length_map]\n\n"}
{"name":"Set.chainHeight_dual","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ninst✝ : LT α\ns : Set α\n⊢ Eq (Set.preimage (⇑OrderDual.ofDual) s).chainHeight s.chainHeight","decl":"@[simp]\ntheorem chainHeight_dual : (ofDual ⁻¹' s).chainHeight = s.chainHeight := by\n  apply le_antisymm <;>\n  · rw [chainHeight_le_chainHeight_iff]\n    rintro l ⟨h₁, h₂⟩\n    exact ⟨l.reverse, ⟨chain'_reverse.mpr h₁, fun i h ↦ h₂ i (mem_reverse.mp h)⟩,\n      (length_reverse _).symm⟩\n\n"}
{"name":"Set.chainHeight_eq_iSup_Ici","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Preorder α\n⊢ Eq s.chainHeight (iSup fun i => iSup fun h => (Inter.inter s (Set.Ici i)).chainHeight)","decl":"theorem chainHeight_eq_iSup_Ici : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Ici i).chainHeight := by\n  apply le_antisymm\n  · refine iSup₂_le ?_\n    rintro (_ | ⟨x, xs⟩) h\n    · exact zero_le _\n    · apply le_trans _ (le_iSup₂ x (cons_mem_subchain_iff.mp h).1)\n      apply length_le_chainHeight_of_mem_subchain\n      refine ⟨h.1, fun i hi ↦ ⟨h.2 i hi, ?_⟩⟩\n      cases hi\n      · exact left_mem_Ici\n      rename_i hi\n      cases' chain'_iff_pairwise.mp h.1 with _ _ h'\n      exact (h' _ hi).le\n  · exact iSup₂_le fun i _ ↦ chainHeight_mono Set.inter_subset_left\n\n"}
{"name":"Set.chainHeight_eq_iSup_Iic","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Preorder α\n⊢ Eq s.chainHeight (iSup fun i => iSup fun h => (Inter.inter s (Set.Iic i)).chainHeight)","decl":"theorem chainHeight_eq_iSup_Iic : s.chainHeight = ⨆ i ∈ s, (s ∩ Set.Iic i).chainHeight := by\n  simp_rw [← chainHeight_dual (_ ∩ _)]\n  rw [← chainHeight_dual, chainHeight_eq_iSup_Ici]\n  rfl\n\n"}
{"name":"Set.chainHeight_insert_of_forall_gt","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Preorder α\na : α\nhx : ∀ (b : α), Membership.mem s b → LT.lt a b\n⊢ Eq (Insert.insert a s).chainHeight (HAdd.hAdd s.chainHeight 1)","decl":"theorem chainHeight_insert_of_forall_gt (a : α) (hx : ∀ b ∈ s, a < b) :\n    (insert a s).chainHeight = s.chainHeight + 1 := by\n  rw [← add_zero (insert a s).chainHeight]\n  change (insert a s).chainHeight + (0 : ℕ) = s.chainHeight + (1 : ℕ)\n  apply le_antisymm <;> rw [chainHeight_add_le_chainHeight_add]\n  · rintro (_ | ⟨y, ys⟩) h\n    · exact ⟨[], nil_mem_subchain _, zero_le _⟩\n    · have h' := cons_mem_subchain_iff.mp h\n      refine ⟨ys, ⟨h'.2.1.1, fun i hi ↦ ?_⟩, by simp⟩\n      apply (h'.2.1.2 i hi).resolve_left\n      rintro rfl\n      cases' chain'_iff_pairwise.mp h.1 with _ _ hy\n      cases' h'.1 with h' h'\n      exacts [(hy _ hi).ne h', not_le_of_gt (hy _ hi) (hx _ h').le]\n  · intro l hl\n    refine ⟨a::l, ⟨?_, ?_⟩, by simp⟩\n    · rw [chain'_cons']\n      exact ⟨fun y hy ↦ hx _ (hl.2 _ (mem_of_mem_head? hy)), hl.1⟩\n    · -- Porting note: originally this was\n        -- rintro x (rfl | hx)\n        -- exacts [Or.inl (Set.mem_singleton x), Or.inr (hl.2 x hx)]\n      -- but this fails because `List.Mem` is now an inductive prop.\n      -- I couldn't work out how to drive `rcases` here but asked at\n      -- https://leanprover.zulipchat.com/#narrow/stream/348111-std4/topic/rcases.3F/near/347976083\n      rintro x (_ | _)\n      exacts [Or.inl (Set.mem_singleton a), Or.inr (hl.2 x ‹_›)]\n\n"}
{"name":"Set.chainHeight_insert_of_forall_lt","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Preorder α\na : α\nha : ∀ (b : α), Membership.mem s b → LT.lt b a\n⊢ Eq (Insert.insert a s).chainHeight (HAdd.hAdd s.chainHeight 1)","decl":"theorem chainHeight_insert_of_forall_lt (a : α) (ha : ∀ b ∈ s, b < a) :\n    (insert a s).chainHeight = s.chainHeight + 1 := by\n  rw [← chainHeight_dual, ← chainHeight_dual s]\n  exact chainHeight_insert_of_forall_gt _ ha\n\n"}
{"name":"Set.chainHeight_union_le","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ns t : Set α\ninst✝ : Preorder α\n⊢ LE.le (Union.union s t).chainHeight (HAdd.hAdd s.chainHeight t.chainHeight)","decl":"theorem chainHeight_union_le : (s ∪ t).chainHeight ≤ s.chainHeight + t.chainHeight := by\n  classical\n    refine iSup₂_le fun l hl ↦ ?_\n    let l₁ := l.filter (· ∈ s)\n    let l₂ := l.filter (· ∈ t)\n    have hl₁ : ↑l₁.length ≤ s.chainHeight := by\n      apply Set.length_le_chainHeight_of_mem_subchain\n      exact ⟨hl.1.sublist (filter_sublist _), fun i h ↦ by simpa using (of_mem_filter h :)⟩\n    have hl₂ : ↑l₂.length ≤ t.chainHeight := by\n      apply Set.length_le_chainHeight_of_mem_subchain\n      exact ⟨hl.1.sublist (filter_sublist _), fun i h ↦ by simpa using (of_mem_filter h :)⟩\n    refine le_trans ?_ (add_le_add hl₁ hl₂)\n    simp_rw [l₁, l₂, ← Nat.cast_add, ← Multiset.coe_card, ← Multiset.card_add,\n      ← Multiset.filter_coe]\n    rw [Multiset.filter_add_filter, Multiset.filter_eq_self.mpr, Multiset.card_add, Nat.cast_add]\n    exacts [le_add_right rfl.le, hl.2]\n\n"}
{"name":"Set.chainHeight_union_eq","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns t : Set α\nH : ∀ (a : α), Membership.mem s a → ∀ (b : α), Membership.mem t b → LT.lt a b\n⊢ Eq (Union.union s t).chainHeight (HAdd.hAdd s.chainHeight t.chainHeight)","decl":"theorem chainHeight_union_eq (s t : Set α) (H : ∀ a ∈ s, ∀ b ∈ t, a < b) :\n    (s ∪ t).chainHeight = s.chainHeight + t.chainHeight := by\n  cases h : t.chainHeight\n  · rw [add_top, eq_top_iff, ← h]\n    exact Set.chainHeight_mono subset_union_right\n  apply le_antisymm\n  · rw [← h]\n    exact chainHeight_union_le\n  rw [← add_zero (s ∪ t).chainHeight, ← WithTop.coe_zero,\n    ENat.some_eq_coe, chainHeight_add_le_chainHeight_add]\n  intro l hl\n  obtain ⟨l', hl', rfl⟩ := exists_chain_of_le_chainHeight t h.symm.le\n  refine ⟨l ++ l', ⟨Chain'.append hl.1 hl'.1 fun x hx y hy ↦ ?_, fun i hi ↦ ?_⟩, by simp⟩\n  · exact H x (hl.2 _ <| mem_of_mem_getLast? hx) y (hl'.2 _ <| mem_of_mem_head? hy)\n  · rw [mem_append] at hi\n    cases' hi with hi hi\n    exacts [Or.inl (hl.2 _ hi), Or.inr (hl'.2 _ hi)]\n\n"}
{"name":"Set.wellFoundedGT_of_chainHeight_ne_top","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nhs : Ne s.chainHeight Top.top\n⊢ WellFoundedGT ↑s","decl":"theorem wellFoundedGT_of_chainHeight_ne_top (s : Set α) (hs : s.chainHeight ≠ ⊤) :\n    WellFoundedGT s := by\n  -- Porting note: added\n  haveI : IsTrans { x // x ∈ s } (↑· < ↑·) := inferInstance\n\n  obtain ⟨n, hn⟩ := WithTop.ne_top_iff_exists.1 hs\n  refine ⟨RelEmbedding.wellFounded_iff_no_descending_seq.2 ⟨fun f ↦ ?_⟩⟩\n  refine n.lt_succ_self.not_le (WithTop.coe_le_coe.1 <| hn.symm ▸ ?_)\n  refine le_iSup₂_of_le ((ofFn (n := n.succ) fun i ↦ f i).map Subtype.val)\n    ⟨chain'_map_of_chain' ((↑) : {x // x ∈ s} → α) (fun _ _ ↦ id)\n      (chain'_iff_pairwise.2 <| pairwise_ofFn.2 fun i j ↦ f.map_rel_iff.2), fun i h ↦ ?_⟩ ?_\n  · obtain ⟨a, -, rfl⟩ := mem_map.1 h\n    exact a.prop\n  · rw [length_map, length_ofFn]\n    exact le_rfl\n\n"}
{"name":"Set.wellFoundedLT_of_chainHeight_ne_top","module":"Mathlib.Order.Height","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nhs : Ne s.chainHeight Top.top\n⊢ WellFoundedLT ↑s","decl":"theorem wellFoundedLT_of_chainHeight_ne_top (s : Set α) (hs : s.chainHeight ≠ ⊤) :\n    WellFoundedLT s :=\n  wellFoundedGT_of_chainHeight_ne_top (ofDual ⁻¹' s) <| by rwa [chainHeight_dual]\n\n"}
