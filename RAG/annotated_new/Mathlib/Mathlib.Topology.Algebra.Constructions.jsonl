{"name":"MulOpposite.continuous_unop","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœ : TopologicalSpace M\nâŠ¢ Continuous MulOpposite.unop","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_unop : Continuous (unop : Máµáµ’áµ– â†’ M) :=\n  continuous_induced_dom\n\n"}
{"name":"AddOpposite.continuous_unop","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœ : TopologicalSpace M\nâŠ¢ Continuous AddOpposite.unop","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_unop : Continuous (unop : Máµáµ’áµ– â†’ M) :=\n  continuous_induced_dom\n\n"}
{"name":"MulOpposite.continuous_op","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœ : TopologicalSpace M\nâŠ¢ Continuous MulOpposite.op","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_op : Continuous (op : M â†’ Máµáµ’áµ–) :=\n  continuous_induced_rng.2 continuous_id\n\n"}
{"name":"AddOpposite.continuous_op","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœ : TopologicalSpace M\nâŠ¢ Continuous AddOpposite.op","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_op : Continuous (op : M â†’ Máµáµ’áµ–) :=\n  continuous_induced_rng.2 continuous_id\n\n"}
{"name":"MulOpposite.opHomeomorph_symm_apply","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœ : TopologicalSpace M\naâœ : MulOpposite M\nâŠ¢ Eq (MulOpposite.opHomeomorph.symm aâœ) (MulOpposite.unop aâœ)","decl":"/-- `MulOpposite.op` as a homeomorphism. -/\n@[to_additive (attr := simps!) \"`AddOpposite.op` as a homeomorphism.\"]\ndef opHomeomorph : M â‰ƒâ‚œ Máµáµ’áµ– where\n  toEquiv := opEquiv\n  continuous_toFun := continuous_op\n  continuous_invFun := continuous_unop\n\n"}
{"name":"MulOpposite.opHomeomorph_apply","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœ : TopologicalSpace M\naâœ : M\nâŠ¢ Eq (MulOpposite.opHomeomorph aâœ) (MulOpposite.op aâœ)","decl":"/-- `MulOpposite.op` as a homeomorphism. -/\n@[to_additive (attr := simps!) \"`AddOpposite.op` as a homeomorphism.\"]\ndef opHomeomorph : M â‰ƒâ‚œ Máµáµ’áµ– where\n  toEquiv := opEquiv\n  continuous_toFun := continuous_op\n  continuous_invFun := continuous_unop\n\n"}
{"name":"AddOpposite.opHomeomorph_apply","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœ : TopologicalSpace M\naâœ : M\nâŠ¢ Eq (AddOpposite.opHomeomorph aâœ) (AddOpposite.op aâœ)","decl":"/-- `MulOpposite.op` as a homeomorphism. -/\n@[to_additive (attr := simps!) \"`AddOpposite.op` as a homeomorphism.\"]\ndef opHomeomorph : M â‰ƒâ‚œ Máµáµ’áµ– where\n  toEquiv := opEquiv\n  continuous_toFun := continuous_op\n  continuous_invFun := continuous_unop\n\n"}
{"name":"AddOpposite.opHomeomorph_symm_apply","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœ : TopologicalSpace M\naâœ : AddOpposite M\nâŠ¢ Eq (AddOpposite.opHomeomorph.symm aâœ) (AddOpposite.unop aâœ)","decl":"/-- `MulOpposite.op` as a homeomorphism. -/\n@[to_additive (attr := simps!) \"`AddOpposite.op` as a homeomorphism.\"]\ndef opHomeomorph : M â‰ƒâ‚œ Máµáµ’áµ– where\n  toEquiv := opEquiv\n  continuous_toFun := continuous_op\n  continuous_invFun := continuous_unop\n\n"}
{"name":"AddOpposite.instT2Space","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : T2Space M\nâŠ¢ T2Space (AddOpposite M)","decl":"@[to_additive]\ninstance instT2Space [T2Space M] : T2Space Máµáµ’áµ– := opHomeomorph.t2Space\n\n"}
{"name":"MulOpposite.instT2Space","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : T2Space M\nâŠ¢ T2Space (MulOpposite M)","decl":"@[to_additive]\ninstance instT2Space [T2Space M] : T2Space Máµáµ’áµ– := opHomeomorph.t2Space\n\n"}
{"name":"AddOpposite.instDiscreteTopology","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : DiscreteTopology M\nâŠ¢ DiscreteTopology (AddOpposite M)","decl":"@[to_additive]\ninstance instDiscreteTopology [DiscreteTopology M] : DiscreteTopology Máµáµ’áµ– :=\n  opHomeomorph.symm.isEmbedding.discreteTopology\n\n"}
{"name":"MulOpposite.instDiscreteTopology","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : DiscreteTopology M\nâŠ¢ DiscreteTopology (MulOpposite M)","decl":"@[to_additive]\ninstance instDiscreteTopology [DiscreteTopology M] : DiscreteTopology Máµáµ’áµ– :=\n  opHomeomorph.symm.isEmbedding.discreteTopology\n\n"}
{"name":"MulOpposite.map_op_nhds","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœ : TopologicalSpace M\nx : M\nâŠ¢ Eq (Filter.map MulOpposite.op (nhds x)) (nhds (MulOpposite.op x))","decl":"@[to_additive (attr := simp)]\ntheorem map_op_nhds (x : M) : map (op : M â†’ Máµáµ’áµ–) (ğ“ x) = ğ“ (op x) :=\n  opHomeomorph.map_nhds_eq x\n\n"}
{"name":"AddOpposite.map_op_nhds","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœ : TopologicalSpace M\nx : M\nâŠ¢ Eq (Filter.map AddOpposite.op (nhds x)) (nhds (AddOpposite.op x))","decl":"@[to_additive (attr := simp)]\ntheorem map_op_nhds (x : M) : map (op : M â†’ Máµáµ’áµ–) (ğ“ x) = ğ“ (op x) :=\n  opHomeomorph.map_nhds_eq x\n\n"}
{"name":"MulOpposite.map_unop_nhds","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœ : TopologicalSpace M\nx : MulOpposite M\nâŠ¢ Eq (Filter.map MulOpposite.unop (nhds x)) (nhds (MulOpposite.unop x))","decl":"@[to_additive (attr := simp)]\ntheorem map_unop_nhds (x : Máµáµ’áµ–) : map (unop : Máµáµ’áµ– â†’ M) (ğ“ x) = ğ“ (unop x) :=\n  opHomeomorph.symm.map_nhds_eq x\n\n"}
{"name":"AddOpposite.map_unop_nhds","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœ : TopologicalSpace M\nx : AddOpposite M\nâŠ¢ Eq (Filter.map AddOpposite.unop (nhds x)) (nhds (AddOpposite.unop x))","decl":"@[to_additive (attr := simp)]\ntheorem map_unop_nhds (x : Máµáµ’áµ–) : map (unop : Máµáµ’áµ– â†’ M) (ğ“ x) = ğ“ (unop x) :=\n  opHomeomorph.symm.map_nhds_eq x\n\n"}
{"name":"MulOpposite.comap_op_nhds","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœ : TopologicalSpace M\nx : MulOpposite M\nâŠ¢ Eq (Filter.comap MulOpposite.op (nhds x)) (nhds (MulOpposite.unop x))","decl":"@[to_additive (attr := simp)]\ntheorem comap_op_nhds (x : Máµáµ’áµ–) : comap (op : M â†’ Máµáµ’áµ–) (ğ“ x) = ğ“ (unop x) :=\n  opHomeomorph.comap_nhds_eq x\n\n"}
{"name":"AddOpposite.comap_op_nhds","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœ : TopologicalSpace M\nx : AddOpposite M\nâŠ¢ Eq (Filter.comap AddOpposite.op (nhds x)) (nhds (AddOpposite.unop x))","decl":"@[to_additive (attr := simp)]\ntheorem comap_op_nhds (x : Máµáµ’áµ–) : comap (op : M â†’ Máµáµ’áµ–) (ğ“ x) = ğ“ (unop x) :=\n  opHomeomorph.comap_nhds_eq x\n\n"}
{"name":"MulOpposite.comap_unop_nhds","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœ : TopologicalSpace M\nx : M\nâŠ¢ Eq (Filter.comap MulOpposite.unop (nhds x)) (nhds (MulOpposite.op x))","decl":"@[to_additive (attr := simp)]\ntheorem comap_unop_nhds (x : M) : comap (unop : Máµáµ’áµ– â†’ M) (ğ“ x) = ğ“ (op x) :=\n  opHomeomorph.symm.comap_nhds_eq x\n\n"}
{"name":"AddOpposite.comap_unop_nhds","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœ : TopologicalSpace M\nx : M\nâŠ¢ Eq (Filter.comap AddOpposite.unop (nhds x)) (nhds (AddOpposite.op x))","decl":"@[to_additive (attr := simp)]\ntheorem comap_unop_nhds (x : M) : comap (unop : Máµáµ’áµ– â†’ M) (ğ“ x) = ğ“ (op x) :=\n  opHomeomorph.symm.comap_nhds_eq x\n\n"}
{"name":"AddUnits.isInducing_embedProduct","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : AddMonoid M\nâŠ¢ Topology.IsInducing â‡‘(AddUnits.embedProduct M)","decl":"@[to_additive]\ntheorem isInducing_embedProduct : IsInducing (embedProduct M) := âŸ¨rflâŸ©\n\n"}
{"name":"Units.isInducing_embedProduct","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : Monoid M\nâŠ¢ Topology.IsInducing â‡‘(Units.embedProduct M)","decl":"@[to_additive]\ntheorem isInducing_embedProduct : IsInducing (embedProduct M) := âŸ¨rflâŸ©\n\n"}
{"name":"Units.inducing_embedProduct","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : Monoid M\nâŠ¢ Topology.IsInducing â‡‘(Units.embedProduct M)","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_embedProduct := isInducing_embedProduct\n\n"}
{"name":"Units.isEmbedding_embedProduct","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : Monoid M\nâŠ¢ Topology.IsEmbedding â‡‘(Units.embedProduct M)","decl":"@[to_additive]\ntheorem isEmbedding_embedProduct : IsEmbedding (embedProduct M) :=\n  âŸ¨isInducing_embedProduct, embedProduct_injective MâŸ©\n\n"}
{"name":"AddUnits.isEmbedding_embedProduct","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : AddMonoid M\nâŠ¢ Topology.IsEmbedding â‡‘(AddUnits.embedProduct M)","decl":"@[to_additive]\ntheorem isEmbedding_embedProduct : IsEmbedding (embedProduct M) :=\n  âŸ¨isInducing_embedProduct, embedProduct_injective MâŸ©\n\n"}
{"name":"Units.embedding_embedProduct","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : Monoid M\nâŠ¢ Topology.IsEmbedding â‡‘(Units.embedProduct M)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_embedProduct := isEmbedding_embedProduct\n\n"}
{"name":"Units.instT2Space","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : T2Space M\nâŠ¢ T2Space (Units M)","decl":"@[to_additive]\ninstance instT2Space [T2Space M] : T2Space MË£ := isEmbedding_embedProduct.t2Space\n\n"}
{"name":"AddUnits.instT2Space","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : T2Space M\nâŠ¢ T2Space (AddUnits M)","decl":"@[to_additive]\ninstance instT2Space [T2Space M] : T2Space MË£ := isEmbedding_embedProduct.t2Space\n\n"}
{"name":"AddUnits.instDiscreteTopology","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : DiscreteTopology M\nâŠ¢ DiscreteTopology (AddUnits M)","decl":"@[to_additive]\ninstance instDiscreteTopology [DiscreteTopology M] : DiscreteTopology MË£ :=\n  isEmbedding_embedProduct.discreteTopology\n\n"}
{"name":"Units.instDiscreteTopology","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : DiscreteTopology M\nâŠ¢ DiscreteTopology (Units M)","decl":"@[to_additive]\ninstance instDiscreteTopology [DiscreteTopology M] : DiscreteTopology MË£ :=\n  isEmbedding_embedProduct.discreteTopology\n\n"}
{"name":"Units.topology_eq_inf","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : Monoid M\nâŠ¢ Eq Units.instTopologicalSpaceUnits (Min.min (TopologicalSpace.induced Units.val instâœÂ¹) (TopologicalSpace.induced (fun u => â†‘(Inv.inv u)) instâœÂ¹))","decl":"@[to_additive] lemma topology_eq_inf :\n    instTopologicalSpaceUnits =\n      .induced (val : MË£ â†’ M) â€¹_â€º âŠ“ .induced (fun u â†¦ â†‘uâ»Â¹ : MË£ â†’ M) â€¹_â€º := by\n  simp only [isInducing_embedProduct.1, instTopologicalSpaceProd, induced_inf,\n    instTopologicalSpaceMulOpposite, induced_compose]; rfl\n\n"}
{"name":"AddUnits.topology_eq_inf","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : AddMonoid M\nâŠ¢ Eq AddUnits.instTopologicalSpaceAddUnits (Min.min (TopologicalSpace.induced AddUnits.val instâœÂ¹) (TopologicalSpace.induced (fun u => â†‘(Neg.neg u)) instâœÂ¹))","decl":"@[to_additive] lemma topology_eq_inf :\n    instTopologicalSpaceUnits =\n      .induced (val : MË£ â†’ M) â€¹_â€º âŠ“ .induced (fun u â†¦ â†‘uâ»Â¹ : MË£ â†’ M) â€¹_â€º := by\n  simp only [isInducing_embedProduct.1, instTopologicalSpaceProd, induced_inf,\n    instTopologicalSpaceMulOpposite, induced_compose]; rfl\n\n"}
{"name":"AddUnits.isEmbedding_val_mk'","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_3\ninstâœÂ¹ : AddMonoid M\ninstâœ : TopologicalSpace M\nf : M â†’ M\nhc : ContinuousOn f (setOf fun x => IsAddUnit x)\nhf : âˆ€ (u : AddUnits M), Eq (f â†‘u) â†‘(Neg.neg u)\nâŠ¢ Topology.IsEmbedding AddUnits.val","decl":"/-- An auxiliary lemma that can be used to prove that coercion `MË£ â†’ M` is a topological embedding.\nUse `Units.isEmbedding_valâ‚€`, `Units.isEmbedding_val`, or `toUnits_homeomorph` instead. -/\n@[to_additive \"An auxiliary lemma that can be used to prove that coercion `AddUnits M â†’ M` is a\ntopological embedding. Use `AddUnits.isEmbedding_val` or `toAddUnits_homeomorph` instead.\"]\nlemma isEmbedding_val_mk' {M : Type*} [Monoid M] [TopologicalSpace M] {f : M â†’ M}\n    (hc : ContinuousOn f {x : M | IsUnit x}) (hf : âˆ€ u : MË£, f u.1 = â†‘uâ»Â¹) :\n    IsEmbedding (val : MË£ â†’ M) := by\n  refine âŸ¨âŸ¨?_âŸ©, extâŸ©\n  rw [topology_eq_inf, inf_eq_left, â† continuous_iff_le_induced,\n    @continuous_iff_continuousAt _ _ (.induced _ _)]\n  intros u s hs\n  simp only [â† hf, nhds_induced, Filter.mem_map] at hs âŠ¢\n  exact âŸ¨_, mem_inf_principal.1 (hc u u.isUnit hs), fun u' hu' â†¦ hu' u'.isUnitâŸ©\n\n"}
{"name":"Units.isEmbedding_val_mk'","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_3\ninstâœÂ¹ : Monoid M\ninstâœ : TopologicalSpace M\nf : M â†’ M\nhc : ContinuousOn f (setOf fun x => IsUnit x)\nhf : âˆ€ (u : Units M), Eq (f â†‘u) â†‘(Inv.inv u)\nâŠ¢ Topology.IsEmbedding Units.val","decl":"/-- An auxiliary lemma that can be used to prove that coercion `MË£ â†’ M` is a topological embedding.\nUse `Units.isEmbedding_valâ‚€`, `Units.isEmbedding_val`, or `toUnits_homeomorph` instead. -/\n@[to_additive \"An auxiliary lemma that can be used to prove that coercion `AddUnits M â†’ M` is a\ntopological embedding. Use `AddUnits.isEmbedding_val` or `toAddUnits_homeomorph` instead.\"]\nlemma isEmbedding_val_mk' {M : Type*} [Monoid M] [TopologicalSpace M] {f : M â†’ M}\n    (hc : ContinuousOn f {x : M | IsUnit x}) (hf : âˆ€ u : MË£, f u.1 = â†‘uâ»Â¹) :\n    IsEmbedding (val : MË£ â†’ M) := by\n  refine âŸ¨âŸ¨?_âŸ©, extâŸ©\n  rw [topology_eq_inf, inf_eq_left, â† continuous_iff_le_induced,\n    @continuous_iff_continuousAt _ _ (.induced _ _)]\n  intros u s hs\n  simp only [â† hf, nhds_induced, Filter.mem_map] at hs âŠ¢\n  exact âŸ¨_, mem_inf_principal.1 (hc u u.isUnit hs), fun u' hu' â†¦ hu' u'.isUnitâŸ©\n\n"}
{"name":"Units.embedding_val_mk'","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_3\ninstâœÂ¹ : Monoid M\ninstâœ : TopologicalSpace M\nf : M â†’ M\nhc : ContinuousOn f (setOf fun x => IsUnit x)\nhf : âˆ€ (u : Units M), Eq (f â†‘u) â†‘(Inv.inv u)\nâŠ¢ Topology.IsEmbedding Units.val","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_val_mk' := isEmbedding_val_mk'\n\n"}
{"name":"Units.embedding_val_mk","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_3\ninstâœÂ¹ : DivisionMonoid M\ninstâœ : TopologicalSpace M\nh : ContinuousOn Inv.inv (setOf fun x => IsUnit x)\nâŠ¢ Topology.IsEmbedding Units.val","decl":"/-- An auxiliary lemma that can be used to prove that coercion `MË£ â†’ M` is a topological embedding.\nUse `Units.isEmbedding_valâ‚€`, `Units.isEmbedding_val`, or `toUnits_homeomorph` instead. -/\n@[to_additive \"An auxiliary lemma that can be used to prove that coercion `AddUnits M â†’ M` is a\ntopological embedding. Use `AddUnits.isEmbedding_val` or `toAddUnits_homeomorph` instead.\"]\nlemma embedding_val_mk {M : Type*} [DivisionMonoid M] [TopologicalSpace M]\n    (h : ContinuousOn Inv.inv {x : M | IsUnit x}) : IsEmbedding (val : MË£ â†’ M) :=\n  isEmbedding_val_mk' h fun u â†¦ (val_inv_eq_inv_val u).symm\n\n"}
{"name":"AddUnits.embedding_val_mk","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_3\ninstâœÂ¹ : SubtractionMonoid M\ninstâœ : TopologicalSpace M\nh : ContinuousOn Neg.neg (setOf fun x => IsAddUnit x)\nâŠ¢ Topology.IsEmbedding AddUnits.val","decl":"/-- An auxiliary lemma that can be used to prove that coercion `MË£ â†’ M` is a topological embedding.\nUse `Units.isEmbedding_valâ‚€`, `Units.isEmbedding_val`, or `toUnits_homeomorph` instead. -/\n@[to_additive \"An auxiliary lemma that can be used to prove that coercion `AddUnits M â†’ M` is a\ntopological embedding. Use `AddUnits.isEmbedding_val` or `toAddUnits_homeomorph` instead.\"]\nlemma embedding_val_mk {M : Type*} [DivisionMonoid M] [TopologicalSpace M]\n    (h : ContinuousOn Inv.inv {x : M | IsUnit x}) : IsEmbedding (val : MË£ â†’ M) :=\n  isEmbedding_val_mk' h fun u â†¦ (val_inv_eq_inv_val u).symm\n\n"}
{"name":"AddUnits.continuous_embedProduct","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : AddMonoid M\nâŠ¢ Continuous â‡‘(AddUnits.embedProduct M)","decl":"@[to_additive]\ntheorem continuous_embedProduct : Continuous (embedProduct M) :=\n  continuous_induced_dom\n\n"}
{"name":"Units.continuous_embedProduct","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : Monoid M\nâŠ¢ Continuous â‡‘(Units.embedProduct M)","decl":"@[to_additive]\ntheorem continuous_embedProduct : Continuous (embedProduct M) :=\n  continuous_induced_dom\n\n"}
{"name":"Units.continuous_val","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : Monoid M\nâŠ¢ Continuous Units.val","decl":"@[to_additive]\ntheorem continuous_val : Continuous ((â†‘) : MË£ â†’ M) :=\n  (@continuous_embedProduct M _ _).fst\n\n"}
{"name":"AddUnits.continuous_val","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : AddMonoid M\nâŠ¢ Continuous AddUnits.val","decl":"@[to_additive]\ntheorem continuous_val : Continuous ((â†‘) : MË£ â†’ M) :=\n  (@continuous_embedProduct M _ _).fst\n\n"}
{"name":"Units.continuous_iff","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\nX : Type u_2\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : Monoid M\ninstâœ : TopologicalSpace X\nf : X â†’ Units M\nâŠ¢ Iff (Continuous f) (And (Continuous (Function.comp Units.val f)) (Continuous fun x => â†‘(Inv.inv (f x))))","decl":"@[to_additive]\nprotected theorem continuous_iff {f : X â†’ MË£} :\n    Continuous f â†” Continuous (val âˆ˜ f) âˆ§ Continuous (fun x => â†‘(f x)â»Â¹ : X â†’ M) := by\n  simp only [isInducing_embedProduct.continuous_iff, embedProduct_apply, Function.comp_def,\n    continuous_prod_mk, opHomeomorph.symm.isInducing.continuous_iff, opHomeomorph_symm_apply,\n    unop_op]\n\n"}
{"name":"AddUnits.continuous_iff","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\nX : Type u_2\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : AddMonoid M\ninstâœ : TopologicalSpace X\nf : X â†’ AddUnits M\nâŠ¢ Iff (Continuous f) (And (Continuous (Function.comp AddUnits.val f)) (Continuous fun x => â†‘(Neg.neg (f x))))","decl":"@[to_additive]\nprotected theorem continuous_iff {f : X â†’ MË£} :\n    Continuous f â†” Continuous (val âˆ˜ f) âˆ§ Continuous (fun x => â†‘(f x)â»Â¹ : X â†’ M) := by\n  simp only [isInducing_embedProduct.continuous_iff, embedProduct_apply, Function.comp_def,\n    continuous_prod_mk, opHomeomorph.symm.isInducing.continuous_iff, opHomeomorph_symm_apply,\n    unop_op]\n\n"}
{"name":"Units.continuous_coe_inv","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : Monoid M\nâŠ¢ Continuous fun u => â†‘(Inv.inv u)","decl":"@[to_additive]\ntheorem continuous_coe_inv : Continuous (fun u => â†‘uâ»Â¹ : MË£ â†’ M) :=\n  (Units.continuous_iff.1 continuous_id).2\n\n"}
{"name":"AddUnits.continuous_coe_neg","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : AddMonoid M\nâŠ¢ Continuous fun u => â†‘(Neg.neg u)","decl":"@[to_additive]\ntheorem continuous_coe_inv : Continuous (fun u => â†‘uâ»Â¹ : MË£ â†’ M) :=\n  (Units.continuous_iff.1 continuous_id).2\n\n"}
