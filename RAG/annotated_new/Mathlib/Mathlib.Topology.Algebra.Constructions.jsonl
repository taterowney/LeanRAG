{"name":"MulOpposite.continuous_unop","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù : TopologicalSpace M\n‚ä¢ Continuous MulOpposite.unop","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_unop : Continuous (unop : M·µê·µí·µñ ‚Üí M) :=\n  continuous_induced_dom\n\n"}
{"name":"AddOpposite.continuous_unop","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù : TopologicalSpace M\n‚ä¢ Continuous AddOpposite.unop","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_unop : Continuous (unop : M·µê·µí·µñ ‚Üí M) :=\n  continuous_induced_dom\n\n"}
{"name":"MulOpposite.continuous_op","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù : TopologicalSpace M\n‚ä¢ Continuous MulOpposite.op","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_op : Continuous (op : M ‚Üí M·µê·µí·µñ) :=\n  continuous_induced_rng.2 continuous_id\n\n"}
{"name":"AddOpposite.continuous_op","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù : TopologicalSpace M\n‚ä¢ Continuous AddOpposite.op","decl":"@[to_additive (attr := continuity)]\ntheorem continuous_op : Continuous (op : M ‚Üí M·µê·µí·µñ) :=\n  continuous_induced_rng.2 continuous_id\n\n"}
{"name":"MulOpposite.opHomeomorph_symm_apply","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù : TopologicalSpace M\na‚úù : MulOpposite M\n‚ä¢ Eq (MulOpposite.opHomeomorph.symm a‚úù) (MulOpposite.unop a‚úù)","decl":"/-- `MulOpposite.op` as a homeomorphism. -/\n@[to_additive (attr := simps!) \"`AddOpposite.op` as a homeomorphism.\"]\ndef opHomeomorph : M ‚âÉ‚Çú M·µê·µí·µñ where\n  toEquiv := opEquiv\n  continuous_toFun := continuous_op\n  continuous_invFun := continuous_unop\n\n"}
{"name":"MulOpposite.opHomeomorph_apply","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù : TopologicalSpace M\na‚úù : M\n‚ä¢ Eq (MulOpposite.opHomeomorph a‚úù) (MulOpposite.op a‚úù)","decl":"/-- `MulOpposite.op` as a homeomorphism. -/\n@[to_additive (attr := simps!) \"`AddOpposite.op` as a homeomorphism.\"]\ndef opHomeomorph : M ‚âÉ‚Çú M·µê·µí·µñ where\n  toEquiv := opEquiv\n  continuous_toFun := continuous_op\n  continuous_invFun := continuous_unop\n\n"}
{"name":"AddOpposite.opHomeomorph_apply","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù : TopologicalSpace M\na‚úù : M\n‚ä¢ Eq (AddOpposite.opHomeomorph a‚úù) (AddOpposite.op a‚úù)","decl":"/-- `MulOpposite.op` as a homeomorphism. -/\n@[to_additive (attr := simps!) \"`AddOpposite.op` as a homeomorphism.\"]\ndef opHomeomorph : M ‚âÉ‚Çú M·µê·µí·µñ where\n  toEquiv := opEquiv\n  continuous_toFun := continuous_op\n  continuous_invFun := continuous_unop\n\n"}
{"name":"AddOpposite.opHomeomorph_symm_apply","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù : TopologicalSpace M\na‚úù : AddOpposite M\n‚ä¢ Eq (AddOpposite.opHomeomorph.symm a‚úù) (AddOpposite.unop a‚úù)","decl":"/-- `MulOpposite.op` as a homeomorphism. -/\n@[to_additive (attr := simps!) \"`AddOpposite.op` as a homeomorphism.\"]\ndef opHomeomorph : M ‚âÉ‚Çú M·µê·µí·µñ where\n  toEquiv := opEquiv\n  continuous_toFun := continuous_op\n  continuous_invFun := continuous_unop\n\n"}
{"name":"AddOpposite.instT2Space","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : T2Space M\n‚ä¢ T2Space (AddOpposite M)","decl":"@[to_additive]\ninstance instT2Space [T2Space M] : T2Space M·µê·µí·µñ := opHomeomorph.t2Space\n\n"}
{"name":"MulOpposite.instT2Space","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : T2Space M\n‚ä¢ T2Space (MulOpposite M)","decl":"@[to_additive]\ninstance instT2Space [T2Space M] : T2Space M·µê·µí·µñ := opHomeomorph.t2Space\n\n"}
{"name":"AddOpposite.instDiscreteTopology","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : DiscreteTopology M\n‚ä¢ DiscreteTopology (AddOpposite M)","decl":"@[to_additive]\ninstance instDiscreteTopology [DiscreteTopology M] : DiscreteTopology M·µê·µí·µñ :=\n  opHomeomorph.symm.isEmbedding.discreteTopology\n\n"}
{"name":"MulOpposite.instDiscreteTopology","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : DiscreteTopology M\n‚ä¢ DiscreteTopology (MulOpposite M)","decl":"@[to_additive]\ninstance instDiscreteTopology [DiscreteTopology M] : DiscreteTopology M·µê·µí·µñ :=\n  opHomeomorph.symm.isEmbedding.discreteTopology\n\n"}
{"name":"MulOpposite.map_op_nhds","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù : TopologicalSpace M\nx : M\n‚ä¢ Eq (Filter.map MulOpposite.op (nhds x)) (nhds (MulOpposite.op x))","decl":"@[to_additive (attr := simp)]\ntheorem map_op_nhds (x : M) : map (op : M ‚Üí M·µê·µí·µñ) (ùìù x) = ùìù (op x) :=\n  opHomeomorph.map_nhds_eq x\n\n"}
{"name":"AddOpposite.map_op_nhds","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù : TopologicalSpace M\nx : M\n‚ä¢ Eq (Filter.map AddOpposite.op (nhds x)) (nhds (AddOpposite.op x))","decl":"@[to_additive (attr := simp)]\ntheorem map_op_nhds (x : M) : map (op : M ‚Üí M·µê·µí·µñ) (ùìù x) = ùìù (op x) :=\n  opHomeomorph.map_nhds_eq x\n\n"}
{"name":"MulOpposite.map_unop_nhds","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù : TopologicalSpace M\nx : MulOpposite M\n‚ä¢ Eq (Filter.map MulOpposite.unop (nhds x)) (nhds (MulOpposite.unop x))","decl":"@[to_additive (attr := simp)]\ntheorem map_unop_nhds (x : M·µê·µí·µñ) : map (unop : M·µê·µí·µñ ‚Üí M) (ùìù x) = ùìù (unop x) :=\n  opHomeomorph.symm.map_nhds_eq x\n\n"}
{"name":"AddOpposite.map_unop_nhds","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù : TopologicalSpace M\nx : AddOpposite M\n‚ä¢ Eq (Filter.map AddOpposite.unop (nhds x)) (nhds (AddOpposite.unop x))","decl":"@[to_additive (attr := simp)]\ntheorem map_unop_nhds (x : M·µê·µí·µñ) : map (unop : M·µê·µí·µñ ‚Üí M) (ùìù x) = ùìù (unop x) :=\n  opHomeomorph.symm.map_nhds_eq x\n\n"}
{"name":"MulOpposite.comap_op_nhds","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù : TopologicalSpace M\nx : MulOpposite M\n‚ä¢ Eq (Filter.comap MulOpposite.op (nhds x)) (nhds (MulOpposite.unop x))","decl":"@[to_additive (attr := simp)]\ntheorem comap_op_nhds (x : M·µê·µí·µñ) : comap (op : M ‚Üí M·µê·µí·µñ) (ùìù x) = ùìù (unop x) :=\n  opHomeomorph.comap_nhds_eq x\n\n"}
{"name":"AddOpposite.comap_op_nhds","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù : TopologicalSpace M\nx : AddOpposite M\n‚ä¢ Eq (Filter.comap AddOpposite.op (nhds x)) (nhds (AddOpposite.unop x))","decl":"@[to_additive (attr := simp)]\ntheorem comap_op_nhds (x : M·µê·µí·µñ) : comap (op : M ‚Üí M·µê·µí·µñ) (ùìù x) = ùìù (unop x) :=\n  opHomeomorph.comap_nhds_eq x\n\n"}
{"name":"MulOpposite.comap_unop_nhds","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù : TopologicalSpace M\nx : M\n‚ä¢ Eq (Filter.comap MulOpposite.unop (nhds x)) (nhds (MulOpposite.op x))","decl":"@[to_additive (attr := simp)]\ntheorem comap_unop_nhds (x : M) : comap (unop : M·µê·µí·µñ ‚Üí M) (ùìù x) = ùìù (op x) :=\n  opHomeomorph.symm.comap_nhds_eq x\n\n"}
{"name":"AddOpposite.comap_unop_nhds","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù : TopologicalSpace M\nx : M\n‚ä¢ Eq (Filter.comap AddOpposite.unop (nhds x)) (nhds (AddOpposite.op x))","decl":"@[to_additive (attr := simp)]\ntheorem comap_unop_nhds (x : M) : comap (unop : M·µê·µí·µñ ‚Üí M) (ùìù x) = ùìù (op x) :=\n  opHomeomorph.symm.comap_nhds_eq x\n\n"}
{"name":"AddUnits.isInducing_embedProduct","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : AddMonoid M\n‚ä¢ Topology.IsInducing ‚áë(AddUnits.embedProduct M)","decl":"@[to_additive]\ntheorem isInducing_embedProduct : IsInducing (embedProduct M) := ‚ü®rfl‚ü©\n\n"}
{"name":"Units.isInducing_embedProduct","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : Monoid M\n‚ä¢ Topology.IsInducing ‚áë(Units.embedProduct M)","decl":"@[to_additive]\ntheorem isInducing_embedProduct : IsInducing (embedProduct M) := ‚ü®rfl‚ü©\n\n"}
{"name":"Units.inducing_embedProduct","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : Monoid M\n‚ä¢ Topology.IsInducing ‚áë(Units.embedProduct M)","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_embedProduct := isInducing_embedProduct\n\n"}
{"name":"Units.isEmbedding_embedProduct","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : Monoid M\n‚ä¢ Topology.IsEmbedding ‚áë(Units.embedProduct M)","decl":"@[to_additive]\ntheorem isEmbedding_embedProduct : IsEmbedding (embedProduct M) :=\n  ‚ü®isInducing_embedProduct, embedProduct_injective M‚ü©\n\n"}
{"name":"AddUnits.isEmbedding_embedProduct","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : AddMonoid M\n‚ä¢ Topology.IsEmbedding ‚áë(AddUnits.embedProduct M)","decl":"@[to_additive]\ntheorem isEmbedding_embedProduct : IsEmbedding (embedProduct M) :=\n  ‚ü®isInducing_embedProduct, embedProduct_injective M‚ü©\n\n"}
{"name":"Units.embedding_embedProduct","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : Monoid M\n‚ä¢ Topology.IsEmbedding ‚áë(Units.embedProduct M)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_embedProduct := isEmbedding_embedProduct\n\n"}
{"name":"Units.instT2Space","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬≤ : TopologicalSpace M\ninst‚úù¬π : Monoid M\ninst‚úù : T2Space M\n‚ä¢ T2Space (Units M)","decl":"@[to_additive]\ninstance instT2Space [T2Space M] : T2Space MÀ£ := isEmbedding_embedProduct.t2Space\n\n"}
{"name":"AddUnits.instT2Space","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬≤ : TopologicalSpace M\ninst‚úù¬π : AddMonoid M\ninst‚úù : T2Space M\n‚ä¢ T2Space (AddUnits M)","decl":"@[to_additive]\ninstance instT2Space [T2Space M] : T2Space MÀ£ := isEmbedding_embedProduct.t2Space\n\n"}
{"name":"AddUnits.instDiscreteTopology","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬≤ : TopologicalSpace M\ninst‚úù¬π : AddMonoid M\ninst‚úù : DiscreteTopology M\n‚ä¢ DiscreteTopology (AddUnits M)","decl":"@[to_additive]\ninstance instDiscreteTopology [DiscreteTopology M] : DiscreteTopology MÀ£ :=\n  isEmbedding_embedProduct.discreteTopology\n\n"}
{"name":"Units.instDiscreteTopology","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬≤ : TopologicalSpace M\ninst‚úù¬π : Monoid M\ninst‚úù : DiscreteTopology M\n‚ä¢ DiscreteTopology (Units M)","decl":"@[to_additive]\ninstance instDiscreteTopology [DiscreteTopology M] : DiscreteTopology MÀ£ :=\n  isEmbedding_embedProduct.discreteTopology\n\n"}
{"name":"Units.topology_eq_inf","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : Monoid M\n‚ä¢ Eq Units.instTopologicalSpaceUnits (Min.min (TopologicalSpace.induced Units.val inst‚úù¬π) (TopologicalSpace.induced (fun u => ‚Üë(Inv.inv u)) inst‚úù¬π))","decl":"@[to_additive] lemma topology_eq_inf :\n    instTopologicalSpaceUnits =\n      .induced (val : MÀ£ ‚Üí M) ‚Äπ_‚Ä∫ ‚äì .induced (fun u ‚Ü¶ ‚Üëu‚Åª¬π : MÀ£ ‚Üí M) ‚Äπ_‚Ä∫ := by\n  simp only [isInducing_embedProduct.1, instTopologicalSpaceProd, induced_inf,\n    instTopologicalSpaceMulOpposite, induced_compose]; rfl\n\n"}
{"name":"AddUnits.topology_eq_inf","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : AddMonoid M\n‚ä¢ Eq AddUnits.instTopologicalSpaceAddUnits (Min.min (TopologicalSpace.induced AddUnits.val inst‚úù¬π) (TopologicalSpace.induced (fun u => ‚Üë(Neg.neg u)) inst‚úù¬π))","decl":"@[to_additive] lemma topology_eq_inf :\n    instTopologicalSpaceUnits =\n      .induced (val : MÀ£ ‚Üí M) ‚Äπ_‚Ä∫ ‚äì .induced (fun u ‚Ü¶ ‚Üëu‚Åª¬π : MÀ£ ‚Üí M) ‚Äπ_‚Ä∫ := by\n  simp only [isInducing_embedProduct.1, instTopologicalSpaceProd, induced_inf,\n    instTopologicalSpaceMulOpposite, induced_compose]; rfl\n\n"}
{"name":"AddUnits.isEmbedding_val_mk'","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_3\ninst‚úù¬π : AddMonoid M\ninst‚úù : TopologicalSpace M\nf : M ‚Üí M\nhc : ContinuousOn f (setOf fun x => IsAddUnit x)\nhf : ‚àÄ (u : AddUnits M), Eq (f ‚Üëu) ‚Üë(Neg.neg u)\n‚ä¢ Topology.IsEmbedding AddUnits.val","decl":"/-- An auxiliary lemma that can be used to prove that coercion `MÀ£ ‚Üí M` is a topological embedding.\nUse `Units.isEmbedding_val‚ÇÄ`, `Units.isEmbedding_val`, or `toUnits_homeomorph` instead. -/\n@[to_additive \"An auxiliary lemma that can be used to prove that coercion `AddUnits M ‚Üí M` is a\ntopological embedding. Use `AddUnits.isEmbedding_val` or `toAddUnits_homeomorph` instead.\"]\nlemma isEmbedding_val_mk' {M : Type*} [Monoid M] [TopologicalSpace M] {f : M ‚Üí M}\n    (hc : ContinuousOn f {x : M | IsUnit x}) (hf : ‚àÄ u : MÀ£, f u.1 = ‚Üëu‚Åª¬π) :\n    IsEmbedding (val : MÀ£ ‚Üí M) := by\n  refine ‚ü®‚ü®?_‚ü©, ext‚ü©\n  rw [topology_eq_inf, inf_eq_left, ‚Üê continuous_iff_le_induced,\n    @continuous_iff_continuousAt _ _ (.induced _ _)]\n  intros u s hs\n  simp only [‚Üê hf, nhds_induced, Filter.mem_map] at hs ‚ä¢\n  exact ‚ü®_, mem_inf_principal.1 (hc u u.isUnit hs), fun u' hu' ‚Ü¶ hu' u'.isUnit‚ü©\n\n"}
{"name":"Units.isEmbedding_val_mk'","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_3\ninst‚úù¬π : Monoid M\ninst‚úù : TopologicalSpace M\nf : M ‚Üí M\nhc : ContinuousOn f (setOf fun x => IsUnit x)\nhf : ‚àÄ (u : Units M), Eq (f ‚Üëu) ‚Üë(Inv.inv u)\n‚ä¢ Topology.IsEmbedding Units.val","decl":"/-- An auxiliary lemma that can be used to prove that coercion `MÀ£ ‚Üí M` is a topological embedding.\nUse `Units.isEmbedding_val‚ÇÄ`, `Units.isEmbedding_val`, or `toUnits_homeomorph` instead. -/\n@[to_additive \"An auxiliary lemma that can be used to prove that coercion `AddUnits M ‚Üí M` is a\ntopological embedding. Use `AddUnits.isEmbedding_val` or `toAddUnits_homeomorph` instead.\"]\nlemma isEmbedding_val_mk' {M : Type*} [Monoid M] [TopologicalSpace M] {f : M ‚Üí M}\n    (hc : ContinuousOn f {x : M | IsUnit x}) (hf : ‚àÄ u : MÀ£, f u.1 = ‚Üëu‚Åª¬π) :\n    IsEmbedding (val : MÀ£ ‚Üí M) := by\n  refine ‚ü®‚ü®?_‚ü©, ext‚ü©\n  rw [topology_eq_inf, inf_eq_left, ‚Üê continuous_iff_le_induced,\n    @continuous_iff_continuousAt _ _ (.induced _ _)]\n  intros u s hs\n  simp only [‚Üê hf, nhds_induced, Filter.mem_map] at hs ‚ä¢\n  exact ‚ü®_, mem_inf_principal.1 (hc u u.isUnit hs), fun u' hu' ‚Ü¶ hu' u'.isUnit‚ü©\n\n"}
{"name":"Units.embedding_val_mk'","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_3\ninst‚úù¬π : Monoid M\ninst‚úù : TopologicalSpace M\nf : M ‚Üí M\nhc : ContinuousOn f (setOf fun x => IsUnit x)\nhf : ‚àÄ (u : Units M), Eq (f ‚Üëu) ‚Üë(Inv.inv u)\n‚ä¢ Topology.IsEmbedding Units.val","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_val_mk' := isEmbedding_val_mk'\n\n"}
{"name":"Units.embedding_val_mk","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_3\ninst‚úù¬π : DivisionMonoid M\ninst‚úù : TopologicalSpace M\nh : ContinuousOn Inv.inv (setOf fun x => IsUnit x)\n‚ä¢ Topology.IsEmbedding Units.val","decl":"/-- An auxiliary lemma that can be used to prove that coercion `MÀ£ ‚Üí M` is a topological embedding.\nUse `Units.isEmbedding_val‚ÇÄ`, `Units.isEmbedding_val`, or `toUnits_homeomorph` instead. -/\n@[to_additive \"An auxiliary lemma that can be used to prove that coercion `AddUnits M ‚Üí M` is a\ntopological embedding. Use `AddUnits.isEmbedding_val` or `toAddUnits_homeomorph` instead.\"]\nlemma embedding_val_mk {M : Type*} [DivisionMonoid M] [TopologicalSpace M]\n    (h : ContinuousOn Inv.inv {x : M | IsUnit x}) : IsEmbedding (val : MÀ£ ‚Üí M) :=\n  isEmbedding_val_mk' h fun u ‚Ü¶ (val_inv_eq_inv_val u).symm\n\n"}
{"name":"AddUnits.embedding_val_mk","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_3\ninst‚úù¬π : SubtractionMonoid M\ninst‚úù : TopologicalSpace M\nh : ContinuousOn Neg.neg (setOf fun x => IsAddUnit x)\n‚ä¢ Topology.IsEmbedding AddUnits.val","decl":"/-- An auxiliary lemma that can be used to prove that coercion `MÀ£ ‚Üí M` is a topological embedding.\nUse `Units.isEmbedding_val‚ÇÄ`, `Units.isEmbedding_val`, or `toUnits_homeomorph` instead. -/\n@[to_additive \"An auxiliary lemma that can be used to prove that coercion `AddUnits M ‚Üí M` is a\ntopological embedding. Use `AddUnits.isEmbedding_val` or `toAddUnits_homeomorph` instead.\"]\nlemma embedding_val_mk {M : Type*} [DivisionMonoid M] [TopologicalSpace M]\n    (h : ContinuousOn Inv.inv {x : M | IsUnit x}) : IsEmbedding (val : MÀ£ ‚Üí M) :=\n  isEmbedding_val_mk' h fun u ‚Ü¶ (val_inv_eq_inv_val u).symm\n\n"}
{"name":"AddUnits.continuous_embedProduct","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : AddMonoid M\n‚ä¢ Continuous ‚áë(AddUnits.embedProduct M)","decl":"@[to_additive]\ntheorem continuous_embedProduct : Continuous (embedProduct M) :=\n  continuous_induced_dom\n\n"}
{"name":"Units.continuous_embedProduct","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : Monoid M\n‚ä¢ Continuous ‚áë(Units.embedProduct M)","decl":"@[to_additive]\ntheorem continuous_embedProduct : Continuous (embedProduct M) :=\n  continuous_induced_dom\n\n"}
{"name":"Units.continuous_val","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : Monoid M\n‚ä¢ Continuous Units.val","decl":"@[to_additive]\ntheorem continuous_val : Continuous ((‚Üë) : MÀ£ ‚Üí M) :=\n  (@continuous_embedProduct M _ _).fst\n\n"}
{"name":"AddUnits.continuous_val","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : AddMonoid M\n‚ä¢ Continuous AddUnits.val","decl":"@[to_additive]\ntheorem continuous_val : Continuous ((‚Üë) : MÀ£ ‚Üí M) :=\n  (@continuous_embedProduct M _ _).fst\n\n"}
{"name":"Units.continuous_iff","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù¬≤ : TopologicalSpace M\ninst‚úù¬π : Monoid M\ninst‚úù : TopologicalSpace X\nf : X ‚Üí Units M\n‚ä¢ Iff (Continuous f) (And (Continuous (Function.comp Units.val f)) (Continuous fun x => ‚Üë(Inv.inv (f x))))","decl":"@[to_additive]\nprotected theorem continuous_iff {f : X ‚Üí MÀ£} :\n    Continuous f ‚Üî Continuous (val ‚àò f) ‚àß Continuous (fun x => ‚Üë(f x)‚Åª¬π : X ‚Üí M) := by\n  simp only [isInducing_embedProduct.continuous_iff, embedProduct_apply, Function.comp_def,\n    continuous_prod_mk, opHomeomorph.symm.isInducing.continuous_iff, opHomeomorph_symm_apply,\n    unop_op]\n\n"}
{"name":"AddUnits.continuous_iff","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù¬≤ : TopologicalSpace M\ninst‚úù¬π : AddMonoid M\ninst‚úù : TopologicalSpace X\nf : X ‚Üí AddUnits M\n‚ä¢ Iff (Continuous f) (And (Continuous (Function.comp AddUnits.val f)) (Continuous fun x => ‚Üë(Neg.neg (f x))))","decl":"@[to_additive]\nprotected theorem continuous_iff {f : X ‚Üí MÀ£} :\n    Continuous f ‚Üî Continuous (val ‚àò f) ‚àß Continuous (fun x => ‚Üë(f x)‚Åª¬π : X ‚Üí M) := by\n  simp only [isInducing_embedProduct.continuous_iff, embedProduct_apply, Function.comp_def,\n    continuous_prod_mk, opHomeomorph.symm.isInducing.continuous_iff, opHomeomorph_symm_apply,\n    unop_op]\n\n"}
{"name":"Units.continuous_coe_inv","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : Monoid M\n‚ä¢ Continuous fun u => ‚Üë(Inv.inv u)","decl":"@[to_additive]\ntheorem continuous_coe_inv : Continuous (fun u => ‚Üëu‚Åª¬π : MÀ£ ‚Üí M) :=\n  (Units.continuous_iff.1 continuous_id).2\n\n"}
{"name":"AddUnits.continuous_coe_neg","module":"Mathlib.Topology.Algebra.Constructions","initialProofState":"M : Type u_1\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : AddMonoid M\n‚ä¢ Continuous fun u => ‚Üë(Neg.neg u)","decl":"@[to_additive]\ntheorem continuous_coe_inv : Continuous (fun u => ‚Üëu‚Åª¬π : MÀ£ ‚Üí M) :=\n  (Units.continuous_iff.1 continuous_id).2\n\n"}
