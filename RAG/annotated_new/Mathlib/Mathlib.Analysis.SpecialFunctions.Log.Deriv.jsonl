{"name":"Real.hasStrictDerivAt_log_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"x : Real\nhx : LT.lt 0 x\n⊢ HasStrictDerivAt Real.log (Inv.inv x) x","decl":"theorem hasStrictDerivAt_log_of_pos (hx : 0 < x) : HasStrictDerivAt log x⁻¹ x := by\n  have : HasStrictDerivAt log (exp <| log x)⁻¹ x :=\n    (hasStrictDerivAt_exp <| log x).of_local_left_inverse (continuousAt_log hx.ne')\n        (ne_of_gt <| exp_pos _) <|\n      Eventually.mono (lt_mem_nhds hx) @exp_log\n  rwa [exp_log hx] at this\n\n"}
{"name":"Real.hasStrictDerivAt_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"x : Real\nhx : Ne x 0\n⊢ HasStrictDerivAt Real.log (Inv.inv x) x","decl":"theorem hasStrictDerivAt_log (hx : x ≠ 0) : HasStrictDerivAt log x⁻¹ x := by\n  cases' hx.lt_or_lt with hx hx\n  · convert (hasStrictDerivAt_log_of_pos (neg_pos.mpr hx)).comp x (hasStrictDerivAt_neg x) using 1\n    · ext y; exact (log_neg_eq_log y).symm\n    · field_simp [hx.ne]\n  · exact hasStrictDerivAt_log_of_pos hx\n\n"}
{"name":"Real.hasDerivAt_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"x : Real\nhx : Ne x 0\n⊢ HasDerivAt Real.log (Inv.inv x) x","decl":"theorem hasDerivAt_log (hx : x ≠ 0) : HasDerivAt log x⁻¹ x :=\n  (hasStrictDerivAt_log hx).hasDerivAt\n\n"}
{"name":"Real.differentiableAt_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"x : Real\nhx : Ne x 0\n⊢ DifferentiableAt Real Real.log x","decl":"@[fun_prop] theorem differentiableAt_log (hx : x ≠ 0) : DifferentiableAt ℝ log x :=\n  (hasDerivAt_log hx).differentiableAt\n\n"}
{"name":"Real.differentiableOn_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"⊢ DifferentiableOn Real Real.log (HasCompl.compl (Singleton.singleton 0))","decl":"theorem differentiableOn_log : DifferentiableOn ℝ log {0}ᶜ := fun _x hx =>\n  (differentiableAt_log hx).differentiableWithinAt\n\n"}
{"name":"Real.differentiableAt_log_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"x : Real\n⊢ Iff (DifferentiableAt Real Real.log x) (Ne x 0)","decl":"@[simp]\ntheorem differentiableAt_log_iff : DifferentiableAt ℝ log x ↔ x ≠ 0 :=\n  ⟨fun h => continuousAt_log_iff.1 h.continuousAt, differentiableAt_log⟩\n\n"}
{"name":"Real.deriv_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"x : Real\n⊢ Eq (deriv Real.log x) (Inv.inv x)","decl":"theorem deriv_log (x : ℝ) : deriv log x = x⁻¹ :=\n  if hx : x = 0 then by\n    rw [deriv_zero_of_not_differentiableAt (differentiableAt_log_iff.not_left.2 hx), hx, inv_zero]\n  else (hasDerivAt_log hx).deriv\n\n"}
{"name":"Real.deriv_log'","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"⊢ Eq (deriv Real.log) Inv.inv","decl":"@[simp]\ntheorem deriv_log' : deriv log = Inv.inv :=\n  funext deriv_log\n\n"}
{"name":"Real.contDiffAt_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"n : WithTop ENat\nx : Real\n⊢ Iff (ContDiffAt Real n Real.log x) (Ne x 0)","decl":"theorem contDiffAt_log {n : WithTop ℕ∞} {x : ℝ} : ContDiffAt ℝ n log x ↔ x ≠ 0 := by\n  refine ⟨fun h ↦ continuousAt_log_iff.1 h.continuousAt, fun hx ↦ ?_⟩\n  have A y (hy : 0 < y) : ContDiffAt ℝ n log y := by\n    apply expPartialHomeomorph.contDiffAt_symm_deriv (f₀' := y) hy.ne' (by simpa)\n    · convert hasDerivAt_exp (log y)\n      rw [exp_log hy]\n    · exact analyticAt_rexp.contDiffAt\n  rcases hx.lt_or_lt with hx | hx\n  · have : ContDiffAt ℝ n (log ∘ (fun y ↦ -y)) x := by\n      apply ContDiffAt.comp\n      apply A _ (Left.neg_pos_iff.mpr hx)\n      apply contDiffAt_id.neg\n    convert this\n    ext x\n    simp\n  · exact A x hx\n\n"}
{"name":"Real.contDiffOn_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"n : WithTop ENat\n⊢ ContDiffOn Real n Real.log (HasCompl.compl (Singleton.singleton 0))","decl":"theorem contDiffOn_log {n : WithTop ℕ∞} : ContDiffOn ℝ n log {0}ᶜ := by\n  intro x hx\n  simp only [mem_compl_iff, mem_singleton_iff] at hx\n  exact (contDiffAt_log.2 hx).contDiffWithinAt\n\n"}
{"name":"HasDerivWithinAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"f : Real → Real\nx f' : Real\ns : Set Real\nhf : HasDerivWithinAt f f' s x\nhx : Ne (f x) 0\n⊢ HasDerivWithinAt (fun y => Real.log (f y)) (HDiv.hDiv f' (f x)) s x","decl":"theorem HasDerivWithinAt.log (hf : HasDerivWithinAt f f' s x) (hx : f x ≠ 0) :\n    HasDerivWithinAt (fun y => log (f y)) (f' / f x) s x := by\n  rw [div_eq_inv_mul]\n  exact (hasDerivAt_log hx).comp_hasDerivWithinAt x hf\n\n"}
{"name":"HasDerivAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"f : Real → Real\nx f' : Real\nhf : HasDerivAt f f' x\nhx : Ne (f x) 0\n⊢ HasDerivAt (fun y => Real.log (f y)) (HDiv.hDiv f' (f x)) x","decl":"theorem HasDerivAt.log (hf : HasDerivAt f f' x) (hx : f x ≠ 0) :\n    HasDerivAt (fun y => log (f y)) (f' / f x) x := by\n  rw [← hasDerivWithinAt_univ] at *\n  exact hf.log hx\n\n"}
{"name":"HasStrictDerivAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"f : Real → Real\nx f' : Real\nhf : HasStrictDerivAt f f' x\nhx : Ne (f x) 0\n⊢ HasStrictDerivAt (fun y => Real.log (f y)) (HDiv.hDiv f' (f x)) x","decl":"theorem HasStrictDerivAt.log (hf : HasStrictDerivAt f f' x) (hx : f x ≠ 0) :\n    HasStrictDerivAt (fun y => log (f y)) (f' / f x) x := by\n  rw [div_eq_inv_mul]\n  exact (hasStrictDerivAt_log hx).comp x hf\n\n"}
{"name":"derivWithin.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"f : Real → Real\nx : Real\ns : Set Real\nhf : DifferentiableWithinAt Real f s x\nhx : Ne (f x) 0\nhxs : UniqueDiffWithinAt Real s x\n⊢ Eq (derivWithin (fun x => Real.log (f x)) s x) (HDiv.hDiv (derivWithin f s x) (f x))","decl":"theorem derivWithin.log (hf : DifferentiableWithinAt ℝ f s x) (hx : f x ≠ 0)\n    (hxs : UniqueDiffWithinAt ℝ s x) :\n    derivWithin (fun x => log (f x)) s x = derivWithin f s x / f x :=\n  (hf.hasDerivWithinAt.log hx).derivWithin hxs\n\n"}
{"name":"deriv.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"f : Real → Real\nx : Real\nhf : DifferentiableAt Real f x\nhx : Ne (f x) 0\n⊢ Eq (deriv (fun x => Real.log (f x)) x) (HDiv.hDiv (deriv f x) (f x))","decl":"@[simp]\ntheorem deriv.log (hf : DifferentiableAt ℝ f x) (hx : f x ≠ 0) :\n    deriv (fun x => log (f x)) x = deriv f x / f x :=\n  (hf.hasDerivAt.log hx).deriv\n\n"}
{"name":"Real.deriv_log_comp_eq_logDeriv","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"f : Real → Real\nx : Real\nh₁ : DifferentiableAt Real f x\nh₂ : Ne (f x) 0\n⊢ Eq (deriv (Function.comp Real.log f) x) (logDeriv f x)","decl":"/-- The derivative of `log ∘ f` is the logarithmic derivative provided `f` is differentiable and\n`f x  ≠ 0`. -/\nlemma Real.deriv_log_comp_eq_logDeriv {f : ℝ → ℝ} {x : ℝ} (h₁ : DifferentiableAt ℝ f x)\n    (h₂ : f x ≠ 0) : deriv (log ∘ f) x = logDeriv f x := by\n  simp only [ne_eq, logDeriv, Pi.div_apply, ← deriv.log h₁ h₂, Function.comp_def]\n\n"}
{"name":"HasFDerivWithinAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nx : E\nf' : ContinuousLinearMap (RingHom.id Real) E Real\ns : Set E\nhf : HasFDerivWithinAt f f' s x\nhx : Ne (f x) 0\n⊢ HasFDerivWithinAt (fun x => Real.log (f x)) (HSMul.hSMul (Inv.inv (f x)) f') s x","decl":"theorem HasFDerivWithinAt.log (hf : HasFDerivWithinAt f f' s x) (hx : f x ≠ 0) :\n    HasFDerivWithinAt (fun x => log (f x)) ((f x)⁻¹ • f') s x :=\n  (hasDerivAt_log hx).comp_hasFDerivWithinAt x hf\n\n"}
{"name":"HasFDerivAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nx : E\nf' : ContinuousLinearMap (RingHom.id Real) E Real\nhf : HasFDerivAt f f' x\nhx : Ne (f x) 0\n⊢ HasFDerivAt (fun x => Real.log (f x)) (HSMul.hSMul (Inv.inv (f x)) f') x","decl":"theorem HasFDerivAt.log (hf : HasFDerivAt f f' x) (hx : f x ≠ 0) :\n    HasFDerivAt (fun x => log (f x)) ((f x)⁻¹ • f') x :=\n  (hasDerivAt_log hx).comp_hasFDerivAt x hf\n\n"}
{"name":"HasStrictFDerivAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nx : E\nf' : ContinuousLinearMap (RingHom.id Real) E Real\nhf : HasStrictFDerivAt f f' x\nhx : Ne (f x) 0\n⊢ HasStrictFDerivAt (fun x => Real.log (f x)) (HSMul.hSMul (Inv.inv (f x)) f') x","decl":"theorem HasStrictFDerivAt.log (hf : HasStrictFDerivAt f f' x) (hx : f x ≠ 0) :\n    HasStrictFDerivAt (fun x => log (f x)) ((f x)⁻¹ • f') x :=\n  (hasStrictDerivAt_log hx).comp_hasStrictFDerivAt x hf\n\n"}
{"name":"DifferentiableWithinAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nx : E\ns : Set E\nhf : DifferentiableWithinAt Real f s x\nhx : Ne (f x) 0\n⊢ DifferentiableWithinAt Real (fun x => Real.log (f x)) s x","decl":"theorem DifferentiableWithinAt.log (hf : DifferentiableWithinAt ℝ f s x) (hx : f x ≠ 0) :\n    DifferentiableWithinAt ℝ (fun x => log (f x)) s x :=\n  (hf.hasFDerivWithinAt.log hx).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nx : E\nhf : DifferentiableAt Real f x\nhx : Ne (f x) 0\n⊢ DifferentiableAt Real (fun x => Real.log (f x)) x","decl":"@[simp, fun_prop]\ntheorem DifferentiableAt.log (hf : DifferentiableAt ℝ f x) (hx : f x ≠ 0) :\n    DifferentiableAt ℝ (fun x => log (f x)) x :=\n  (hf.hasFDerivAt.log hx).differentiableAt\n\n"}
{"name":"ContDiffAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nx : E\nn : WithTop ENat\nhf : ContDiffAt Real n f x\nhx : Ne (f x) 0\n⊢ ContDiffAt Real n (fun x => Real.log (f x)) x","decl":"theorem ContDiffAt.log {n} (hf : ContDiffAt ℝ n f x) (hx : f x ≠ 0) :\n    ContDiffAt ℝ n (fun x => log (f x)) x :=\n  (contDiffAt_log.2 hx).comp x hf\n\n"}
{"name":"ContDiffWithinAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nx : E\ns : Set E\nn : WithTop ENat\nhf : ContDiffWithinAt Real n f s x\nhx : Ne (f x) 0\n⊢ ContDiffWithinAt Real n (fun x => Real.log (f x)) s x","decl":"theorem ContDiffWithinAt.log {n} (hf : ContDiffWithinAt ℝ n f s x) (hx : f x ≠ 0) :\n    ContDiffWithinAt ℝ n (fun x => log (f x)) s x :=\n  (contDiffAt_log.2 hx).comp_contDiffWithinAt x hf\n\n"}
{"name":"ContDiffOn.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\ns : Set E\nn : WithTop ENat\nhf : ContDiffOn Real n f s\nhs : ∀ (x : E), Membership.mem s x → Ne (f x) 0\n⊢ ContDiffOn Real n (fun x => Real.log (f x)) s","decl":"theorem ContDiffOn.log {n} (hf : ContDiffOn ℝ n f s) (hs : ∀ x ∈ s, f x ≠ 0) :\n    ContDiffOn ℝ n (fun x => log (f x)) s := fun x hx => (hf x hx).log (hs x hx)\n\n"}
{"name":"ContDiff.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nn : WithTop ENat\nhf : ContDiff Real n f\nh : ∀ (x : E), Ne (f x) 0\n⊢ ContDiff Real n fun x => Real.log (f x)","decl":"theorem ContDiff.log {n} (hf : ContDiff ℝ n f) (h : ∀ x, f x ≠ 0) :\n    ContDiff ℝ n fun x => log (f x) :=\n  contDiff_iff_contDiffAt.2 fun x => hf.contDiffAt.log (h x)\n\n"}
{"name":"DifferentiableOn.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\ns : Set E\nhf : DifferentiableOn Real f s\nhx : ∀ (x : E), Membership.mem s x → Ne (f x) 0\n⊢ DifferentiableOn Real (fun x => Real.log (f x)) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.log (hf : DifferentiableOn ℝ f s) (hx : ∀ x ∈ s, f x ≠ 0) :\n    DifferentiableOn ℝ (fun x => log (f x)) s := fun x h => (hf x h).log (hx x h)\n\n"}
{"name":"Differentiable.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nhf : Differentiable Real f\nhx : ∀ (x : E), Ne (f x) 0\n⊢ Differentiable Real fun x => Real.log (f x)","decl":"@[simp, fun_prop]\ntheorem Differentiable.log (hf : Differentiable ℝ f) (hx : ∀ x, f x ≠ 0) :\n    Differentiable ℝ fun x => log (f x) := fun x => (hf x).log (hx x)\n\n"}
{"name":"fderivWithin.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nx : E\ns : Set E\nhf : DifferentiableWithinAt Real f s x\nhx : Ne (f x) 0\nhxs : UniqueDiffWithinAt Real s x\n⊢ Eq (fderivWithin Real (fun x => Real.log (f x)) s x) (HSMul.hSMul (Inv.inv (f x)) (fderivWithin Real f s x))","decl":"theorem fderivWithin.log (hf : DifferentiableWithinAt ℝ f s x) (hx : f x ≠ 0)\n    (hxs : UniqueDiffWithinAt ℝ s x) :\n    fderivWithin ℝ (fun x => log (f x)) s x = (f x)⁻¹ • fderivWithin ℝ f s x :=\n  (hf.hasFDerivWithinAt.log hx).fderivWithin hxs\n\n"}
{"name":"fderiv.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : E → Real\nx : E\nhf : DifferentiableAt Real f x\nhx : Ne (f x) 0\n⊢ Eq (fderiv Real (fun x => Real.log (f x)) x) (HSMul.hSMul (Inv.inv (f x)) (fderiv Real f x))","decl":"@[simp]\ntheorem fderiv.log (hf : DifferentiableAt ℝ f x) (hx : f x ≠ 0) :\n    fderiv ℝ (fun x => log (f x)) x = (f x)⁻¹ • fderiv ℝ f x :=\n  (hf.hasFDerivAt.log hx).fderiv\n\n"}
{"name":"Real.tendsto_mul_log_one_plus_div_atTop","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"t : Real\n⊢ Filter.Tendsto (fun x => HMul.hMul x (Real.log (HAdd.hAdd 1 (HDiv.hDiv t x)))) Filter.atTop (nhds t)","decl":"/-- The function `x * log (1 + t / x)` tends to `t` at `+∞`. -/\ntheorem tendsto_mul_log_one_plus_div_atTop (t : ℝ) :\n    Tendsto (fun x => x * log (1 + t / x)) atTop (𝓝 t) := by\n  have h₁ : Tendsto (fun h => h⁻¹ * log (1 + t * h)) (𝓝[≠] 0) (𝓝 t) := by\n    simpa [hasDerivAt_iff_tendsto_slope, slope_fun_def] using\n      (((hasDerivAt_id (0 : ℝ)).const_mul t).const_add 1).log (by simp)\n  have h₂ : Tendsto (fun x : ℝ => x⁻¹) atTop (𝓝[≠] 0) :=\n    tendsto_inv_atTop_nhdsGT_zero.mono_right (nhdsGT_le_nhdsNE _)\n  simpa only [Function.comp_def, inv_inv] using h₁.comp h₂\n\n"}
{"name":"Real.abs_log_sub_add_sum_range_le","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"x : Real\nh : LT.lt (abs x) 1\nn : Nat\n⊢ LE.le (abs (HAdd.hAdd ((Finset.range n).sum fun i => HDiv.hDiv (HPow.hPow x (HAdd.hAdd i 1)) (HAdd.hAdd (↑i) 1)) (Real.log (HSub.hSub 1 x)))) (HDiv.hDiv (HPow.hPow (abs x) (HAdd.hAdd n 1)) (HSub.hSub 1 (abs x)))","decl":"/-- A crude lemma estimating the difference between `log (1-x)` and its Taylor series at `0`,\nwhere the main point of the bound is that it tends to `0`. The goal is to deduce the series\nexpansion of the logarithm, in `hasSum_pow_div_log_of_abs_lt_1`.\n\nPorting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: use one of generic theorems about Taylor's series\nto prove this estimate.\n-/\ntheorem abs_log_sub_add_sum_range_le {x : ℝ} (h : |x| < 1) (n : ℕ) :\n    |(∑ i ∈ range n, x ^ (i + 1) / (i + 1)) + log (1 - x)| ≤ |x| ^ (n + 1) / (1 - |x|) := by\n  /- For the proof, we show that the derivative of the function to be estimated is small,\n    and then apply the mean value inequality. -/\n  let F : ℝ → ℝ := fun x => (∑ i ∈ range n, x ^ (i + 1) / (i + 1)) + log (1 - x)\n  let F' : ℝ → ℝ := fun x ↦ -x ^ n / (1 - x)\n  -- Porting note: In `mathlib3`, the proof used `deriv`/`DifferentiableAt`. `simp` failed to\n  -- compute `deriv`, so I changed the proof to use `HasDerivAt` instead\n  -- First step: compute the derivative of `F`\n  have A : ∀ y ∈ Ioo (-1 : ℝ) 1, HasDerivAt F (F' y) y := fun y hy ↦ by\n    have : HasDerivAt F ((∑ i ∈ range n, ↑(i + 1) * y ^ i / (↑i + 1)) + (-1) / (1 - y)) y :=\n      .add (.sum fun i _ ↦ (hasDerivAt_pow (i + 1) y).div_const ((i : ℝ) + 1))\n        (((hasDerivAt_id y).const_sub _).log <| sub_ne_zero.2 hy.2.ne')\n    convert this using 1\n    calc\n      -y ^ n / (1 - y) = ∑ i ∈ Finset.range n, y ^ i + -1 / (1 - y) := by\n        field_simp [geom_sum_eq hy.2.ne, sub_ne_zero.2 hy.2.ne, sub_ne_zero.2 hy.2.ne']\n        ring\n      _ = ∑ i ∈ Finset.range n, ↑(i + 1) * y ^ i / (↑i + 1) + -1 / (1 - y) := by\n        congr with i\n        rw [Nat.cast_succ, mul_div_cancel_left₀ _ (Nat.cast_add_one_pos i).ne']\n  -- second step: show that the derivative of `F` is small\n  have B : ∀ y ∈ Icc (-|x|) |x|, |F' y| ≤ |x| ^ n / (1 - |x|) := fun y hy ↦\n    calc\n      |F' y| = |y| ^ n / |1 - y| := by simp [F', abs_div]\n      _ ≤ |x| ^ n / (1 - |x|) := by\n        have : |y| ≤ |x| := abs_le.2 hy\n        have : 1 - |x| ≤ |1 - y| := le_trans (by linarith [hy.2]) (le_abs_self _)\n        gcongr\n        exact sub_pos.2 h\n  -- third step: apply the mean value inequality\n  have C : ‖F x - F 0‖ ≤ |x| ^ n / (1 - |x|) * ‖x - 0‖ := by\n    refine Convex.norm_image_sub_le_of_norm_hasDerivWithin_le\n      (fun y hy ↦ (A _ ?_).hasDerivWithinAt) B (convex_Icc _ _) ?_ ?_\n    · exact Icc_subset_Ioo (neg_lt_neg h) h hy\n    · simp\n    · simp [le_abs_self x, neg_le.mp (neg_le_abs x)]\n  -- fourth step: conclude by massaging the inequality of the third step\n  simpa [F, div_mul_eq_mul_div, pow_succ] using C\n\n"}
{"name":"Real.hasSum_pow_div_log_of_abs_lt_one","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"x : Real\nh : LT.lt (abs x) 1\n⊢ HasSum (fun n => HDiv.hDiv (HPow.hPow x (HAdd.hAdd n 1)) (HAdd.hAdd (↑n) 1)) (Neg.neg (Real.log (HSub.hSub 1 x)))","decl":"/-- Power series expansion of the logarithm around `1`. -/\ntheorem hasSum_pow_div_log_of_abs_lt_one {x : ℝ} (h : |x| < 1) :\n    HasSum (fun n : ℕ => x ^ (n + 1) / (n + 1)) (-log (1 - x)) := by\n  rw [Summable.hasSum_iff_tendsto_nat]\n  · show Tendsto (fun n : ℕ => ∑ i ∈ range n, x ^ (i + 1) / (i + 1)) atTop (𝓝 (-log (1 - x)))\n    rw [tendsto_iff_norm_sub_tendsto_zero]\n    simp only [norm_eq_abs, sub_neg_eq_add]\n    refine squeeze_zero (fun n => abs_nonneg _) (abs_log_sub_add_sum_range_le h) ?_\n    suffices Tendsto (fun t : ℕ => |x| ^ (t + 1) / (1 - |x|)) atTop (𝓝 (|x| * 0 / (1 - |x|))) by\n      simpa\n    simp only [pow_succ']\n    refine (tendsto_const_nhds.mul ?_).div_const _\n    exact tendsto_pow_atTop_nhds_zero_of_lt_one (abs_nonneg _) h\n  show Summable fun n : ℕ => x ^ (n + 1) / (n + 1)\n  refine .of_norm_bounded _ (summable_geometric_of_lt_one (abs_nonneg _) h) fun i => ?_\n  calc\n    ‖x ^ (i + 1) / (i + 1)‖ = |x| ^ (i + 1) / (i + 1) := by\n      have : (0 : ℝ) ≤ i + 1 := le_of_lt (Nat.cast_add_one_pos i)\n      rw [norm_eq_abs, abs_div, ← pow_abs, abs_of_nonneg this]\n    _ ≤ |x| ^ (i + 1) / (0 + 1) := by\n      gcongr\n      exact i.cast_nonneg\n    _ ≤ |x| ^ i := by\n      simpa [pow_succ] using mul_le_of_le_one_right (pow_nonneg (abs_nonneg x) i) (le_of_lt h)\n\n"}
{"name":"Real.hasSum_log_sub_log_of_abs_lt_one","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"x : Real\nh : LT.lt (abs x) 1\n⊢ HasSum (fun k => HMul.hMul (HMul.hMul 2 (HDiv.hDiv 1 (HAdd.hAdd (HMul.hMul 2 ↑k) 1))) (HPow.hPow x (HAdd.hAdd (HMul.hMul 2 k) 1))) (HSub.hSub (Real.log (HAdd.hAdd 1 x)) (Real.log (HSub.hSub 1 x)))","decl":"/-- Power series expansion of `log(1 + x) - log(1 - x)` for `|x| < 1`. -/\ntheorem hasSum_log_sub_log_of_abs_lt_one {x : ℝ} (h : |x| < 1) :\n    HasSum (fun k : ℕ => (2 : ℝ) * (1 / (2 * k + 1)) * x ^ (2 * k + 1))\n      (log (1 + x) - log (1 - x)) := by\n  set term := fun n : ℕ => -1 * ((-x) ^ (n + 1) / ((n : ℝ) + 1)) + x ^ (n + 1) / (n + 1)\n  have h_term_eq_goal :\n      term ∘ (2 * ·) = fun k : ℕ => 2 * (1 / (2 * k + 1)) * x ^ (2 * k + 1) := by\n    ext n\n    dsimp only [term, (· ∘ ·)]\n    rw [Odd.neg_pow (⟨n, rfl⟩ : Odd (2 * n + 1)) x]\n    push_cast\n    ring_nf\n  rw [← h_term_eq_goal, (mul_right_injective₀ (two_ne_zero' ℕ)).hasSum_iff]\n  · have h₁ := (hasSum_pow_div_log_of_abs_lt_one (Eq.trans_lt (abs_neg x) h)).mul_left (-1)\n    convert h₁.add (hasSum_pow_div_log_of_abs_lt_one h) using 1\n    ring_nf\n  · intro m hm\n    rw [range_two_mul, Set.mem_setOf_eq, ← Nat.even_add_one] at hm\n    dsimp [term]\n    rw [Even.neg_pow hm, neg_one_mul, neg_add_cancel]\n\n"}
{"name":"Real.hasSum_log_one_add_inv","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"a : Real\nh : LT.lt 0 a\n⊢ HasSum (fun k => HMul.hMul (HMul.hMul 2 (HDiv.hDiv 1 (HAdd.hAdd (HMul.hMul 2 ↑k) 1))) (HPow.hPow (HDiv.hDiv 1 (HAdd.hAdd (HMul.hMul 2 a) 1)) (HAdd.hAdd (HMul.hMul 2 k) 1))) (Real.log (HAdd.hAdd 1 (Inv.inv a)))","decl":"/-- Expansion of `log (1 + a⁻¹)` as a series in powers of `1 / (2 * a + 1)`. -/\ntheorem hasSum_log_one_add_inv {a : ℝ} (h : 0 < a) :\n    HasSum (fun k : ℕ => (2 : ℝ) * (1 / (2 * k + 1)) * (1 / (2 * a + 1)) ^ (2 * k + 1))\n      (log (1 + a⁻¹)) := by\n  have h₁ : |1 / (2 * a + 1)| < 1 := by\n    rw [abs_of_pos, div_lt_one]\n    · linarith\n    · linarith\n    · exact div_pos one_pos (by linarith)\n  convert hasSum_log_sub_log_of_abs_lt_one h₁ using 1\n  have h₂ : (2 : ℝ) * a + 1 ≠ 0 := by linarith\n  have h₃ := h.ne'\n  rw [← log_div]\n  · congr\n    field_simp\n    linarith\n  · field_simp\n    linarith\n  · field_simp\n\n"}
