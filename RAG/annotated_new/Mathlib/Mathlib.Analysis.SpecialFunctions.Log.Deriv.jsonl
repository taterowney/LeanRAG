{"name":"Real.hasStrictDerivAt_log_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"x : Real\nhx : LT.lt 0 x\n‚ä¢ HasStrictDerivAt Real.log (Inv.inv x) x","decl":"theorem hasStrictDerivAt_log_of_pos (hx : 0 < x) : HasStrictDerivAt log x‚Åª¬π x := by\n  have : HasStrictDerivAt log (exp <| log x)‚Åª¬π x :=\n    (hasStrictDerivAt_exp <| log x).of_local_left_inverse (continuousAt_log hx.ne')\n        (ne_of_gt <| exp_pos _) <|\n      Eventually.mono (lt_mem_nhds hx) @exp_log\n  rwa [exp_log hx] at this\n\n"}
{"name":"Real.hasStrictDerivAt_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"x : Real\nhx : Ne x 0\n‚ä¢ HasStrictDerivAt Real.log (Inv.inv x) x","decl":"theorem hasStrictDerivAt_log (hx : x ‚â† 0) : HasStrictDerivAt log x‚Åª¬π x := by\n  cases' hx.lt_or_lt with hx hx\n  ¬∑ convert (hasStrictDerivAt_log_of_pos (neg_pos.mpr hx)).comp x (hasStrictDerivAt_neg x) using 1\n    ¬∑ ext y; exact (log_neg_eq_log y).symm\n    ¬∑ field_simp [hx.ne]\n  ¬∑ exact hasStrictDerivAt_log_of_pos hx\n\n"}
{"name":"Real.hasDerivAt_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"x : Real\nhx : Ne x 0\n‚ä¢ HasDerivAt Real.log (Inv.inv x) x","decl":"theorem hasDerivAt_log (hx : x ‚â† 0) : HasDerivAt log x‚Åª¬π x :=\n  (hasStrictDerivAt_log hx).hasDerivAt\n\n"}
{"name":"Real.differentiableAt_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"x : Real\nhx : Ne x 0\n‚ä¢ DifferentiableAt Real Real.log x","decl":"@[fun_prop] theorem differentiableAt_log (hx : x ‚â† 0) : DifferentiableAt ‚Ñù log x :=\n  (hasDerivAt_log hx).differentiableAt\n\n"}
{"name":"Real.differentiableOn_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"‚ä¢ DifferentiableOn Real Real.log (HasCompl.compl (Singleton.singleton 0))","decl":"theorem differentiableOn_log : DifferentiableOn ‚Ñù log {0}·∂ú := fun _x hx =>\n  (differentiableAt_log hx).differentiableWithinAt\n\n"}
{"name":"Real.differentiableAt_log_iff","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"x : Real\n‚ä¢ Iff (DifferentiableAt Real Real.log x) (Ne x 0)","decl":"@[simp]\ntheorem differentiableAt_log_iff : DifferentiableAt ‚Ñù log x ‚Üî x ‚â† 0 :=\n  ‚ü®fun h => continuousAt_log_iff.1 h.continuousAt, differentiableAt_log‚ü©\n\n"}
{"name":"Real.deriv_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"x : Real\n‚ä¢ Eq (deriv Real.log x) (Inv.inv x)","decl":"theorem deriv_log (x : ‚Ñù) : deriv log x = x‚Åª¬π :=\n  if hx : x = 0 then by\n    rw [deriv_zero_of_not_differentiableAt (differentiableAt_log_iff.not_left.2 hx), hx, inv_zero]\n  else (hasDerivAt_log hx).deriv\n\n"}
{"name":"Real.deriv_log'","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"‚ä¢ Eq (deriv Real.log) Inv.inv","decl":"@[simp]\ntheorem deriv_log' : deriv log = Inv.inv :=\n  funext deriv_log\n\n"}
{"name":"Real.contDiffAt_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"n : WithTop ENat\nx : Real\n‚ä¢ Iff (ContDiffAt Real n Real.log x) (Ne x 0)","decl":"theorem contDiffAt_log {n : WithTop ‚Ñï‚àû} {x : ‚Ñù} : ContDiffAt ‚Ñù n log x ‚Üî x ‚â† 0 := by\n  refine ‚ü®fun h ‚Ü¶ continuousAt_log_iff.1 h.continuousAt, fun hx ‚Ü¶ ?_‚ü©\n  have A y (hy : 0 < y) : ContDiffAt ‚Ñù n log y := by\n    apply expPartialHomeomorph.contDiffAt_symm_deriv (f‚ÇÄ' := y) hy.ne' (by simpa)\n    ¬∑ convert hasDerivAt_exp (log y)\n      rw [exp_log hy]\n    ¬∑ exact analyticAt_rexp.contDiffAt\n  rcases hx.lt_or_lt with hx | hx\n  ¬∑ have : ContDiffAt ‚Ñù n (log ‚àò (fun y ‚Ü¶ -y)) x := by\n      apply ContDiffAt.comp\n      apply A _ (Left.neg_pos_iff.mpr hx)\n      apply contDiffAt_id.neg\n    convert this\n    ext x\n    simp\n  ¬∑ exact A x hx\n\n"}
{"name":"Real.contDiffOn_log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"n : WithTop ENat\n‚ä¢ ContDiffOn Real n Real.log (HasCompl.compl (Singleton.singleton 0))","decl":"theorem contDiffOn_log {n : WithTop ‚Ñï‚àû} : ContDiffOn ‚Ñù n log {0}·∂ú := by\n  intro x hx\n  simp only [mem_compl_iff, mem_singleton_iff] at hx\n  exact (contDiffAt_log.2 hx).contDiffWithinAt\n\n"}
{"name":"HasDerivWithinAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"f : Real ‚Üí Real\nx f' : Real\ns : Set Real\nhf : HasDerivWithinAt f f' s x\nhx : Ne (f x) 0\n‚ä¢ HasDerivWithinAt (fun y => Real.log (f y)) (HDiv.hDiv f' (f x)) s x","decl":"theorem HasDerivWithinAt.log (hf : HasDerivWithinAt f f' s x) (hx : f x ‚â† 0) :\n    HasDerivWithinAt (fun y => log (f y)) (f' / f x) s x := by\n  rw [div_eq_inv_mul]\n  exact (hasDerivAt_log hx).comp_hasDerivWithinAt x hf\n\n"}
{"name":"HasDerivAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"f : Real ‚Üí Real\nx f' : Real\nhf : HasDerivAt f f' x\nhx : Ne (f x) 0\n‚ä¢ HasDerivAt (fun y => Real.log (f y)) (HDiv.hDiv f' (f x)) x","decl":"theorem HasDerivAt.log (hf : HasDerivAt f f' x) (hx : f x ‚â† 0) :\n    HasDerivAt (fun y => log (f y)) (f' / f x) x := by\n  rw [‚Üê hasDerivWithinAt_univ] at *\n  exact hf.log hx\n\n"}
{"name":"HasStrictDerivAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"f : Real ‚Üí Real\nx f' : Real\nhf : HasStrictDerivAt f f' x\nhx : Ne (f x) 0\n‚ä¢ HasStrictDerivAt (fun y => Real.log (f y)) (HDiv.hDiv f' (f x)) x","decl":"theorem HasStrictDerivAt.log (hf : HasStrictDerivAt f f' x) (hx : f x ‚â† 0) :\n    HasStrictDerivAt (fun y => log (f y)) (f' / f x) x := by\n  rw [div_eq_inv_mul]\n  exact (hasStrictDerivAt_log hx).comp x hf\n\n"}
{"name":"derivWithin.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"f : Real ‚Üí Real\nx : Real\ns : Set Real\nhf : DifferentiableWithinAt Real f s x\nhx : Ne (f x) 0\nhxs : UniqueDiffWithinAt Real s x\n‚ä¢ Eq (derivWithin (fun x => Real.log (f x)) s x) (HDiv.hDiv (derivWithin f s x) (f x))","decl":"theorem derivWithin.log (hf : DifferentiableWithinAt ‚Ñù f s x) (hx : f x ‚â† 0)\n    (hxs : UniqueDiffWithinAt ‚Ñù s x) :\n    derivWithin (fun x => log (f x)) s x = derivWithin f s x / f x :=\n  (hf.hasDerivWithinAt.log hx).derivWithin hxs\n\n"}
{"name":"deriv.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"f : Real ‚Üí Real\nx : Real\nhf : DifferentiableAt Real f x\nhx : Ne (f x) 0\n‚ä¢ Eq (deriv (fun x => Real.log (f x)) x) (HDiv.hDiv (deriv f x) (f x))","decl":"@[simp]\ntheorem deriv.log (hf : DifferentiableAt ‚Ñù f x) (hx : f x ‚â† 0) :\n    deriv (fun x => log (f x)) x = deriv f x / f x :=\n  (hf.hasDerivAt.log hx).deriv\n\n"}
{"name":"Real.deriv_log_comp_eq_logDeriv","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"f : Real ‚Üí Real\nx : Real\nh‚ÇÅ : DifferentiableAt Real f x\nh‚ÇÇ : Ne (f x) 0\n‚ä¢ Eq (deriv (Function.comp Real.log f) x) (logDeriv f x)","decl":"/-- The derivative of `log ‚àò f` is the logarithmic derivative provided `f` is differentiable and\n`f x  ‚â† 0`. -/\nlemma Real.deriv_log_comp_eq_logDeriv {f : ‚Ñù ‚Üí ‚Ñù} {x : ‚Ñù} (h‚ÇÅ : DifferentiableAt ‚Ñù f x)\n    (h‚ÇÇ : f x ‚â† 0) : deriv (log ‚àò f) x = logDeriv f x := by\n  simp only [ne_eq, logDeriv, Pi.div_apply, ‚Üê deriv.log h‚ÇÅ h‚ÇÇ, Function.comp_def]\n\n"}
{"name":"HasFDerivWithinAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : E ‚Üí Real\nx : E\nf' : ContinuousLinearMap (RingHom.id Real) E Real\ns : Set E\nhf : HasFDerivWithinAt f f' s x\nhx : Ne (f x) 0\n‚ä¢ HasFDerivWithinAt (fun x => Real.log (f x)) (HSMul.hSMul (Inv.inv (f x)) f') s x","decl":"theorem HasFDerivWithinAt.log (hf : HasFDerivWithinAt f f' s x) (hx : f x ‚â† 0) :\n    HasFDerivWithinAt (fun x => log (f x)) ((f x)‚Åª¬π ‚Ä¢ f') s x :=\n  (hasDerivAt_log hx).comp_hasFDerivWithinAt x hf\n\n"}
{"name":"HasFDerivAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : E ‚Üí Real\nx : E\nf' : ContinuousLinearMap (RingHom.id Real) E Real\nhf : HasFDerivAt f f' x\nhx : Ne (f x) 0\n‚ä¢ HasFDerivAt (fun x => Real.log (f x)) (HSMul.hSMul (Inv.inv (f x)) f') x","decl":"theorem HasFDerivAt.log (hf : HasFDerivAt f f' x) (hx : f x ‚â† 0) :\n    HasFDerivAt (fun x => log (f x)) ((f x)‚Åª¬π ‚Ä¢ f') x :=\n  (hasDerivAt_log hx).comp_hasFDerivAt x hf\n\n"}
{"name":"HasStrictFDerivAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : E ‚Üí Real\nx : E\nf' : ContinuousLinearMap (RingHom.id Real) E Real\nhf : HasStrictFDerivAt f f' x\nhx : Ne (f x) 0\n‚ä¢ HasStrictFDerivAt (fun x => Real.log (f x)) (HSMul.hSMul (Inv.inv (f x)) f') x","decl":"theorem HasStrictFDerivAt.log (hf : HasStrictFDerivAt f f' x) (hx : f x ‚â† 0) :\n    HasStrictFDerivAt (fun x => log (f x)) ((f x)‚Åª¬π ‚Ä¢ f') x :=\n  (hasStrictDerivAt_log hx).comp_hasStrictFDerivAt x hf\n\n"}
{"name":"DifferentiableWithinAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : E ‚Üí Real\nx : E\ns : Set E\nhf : DifferentiableWithinAt Real f s x\nhx : Ne (f x) 0\n‚ä¢ DifferentiableWithinAt Real (fun x => Real.log (f x)) s x","decl":"theorem DifferentiableWithinAt.log (hf : DifferentiableWithinAt ‚Ñù f s x) (hx : f x ‚â† 0) :\n    DifferentiableWithinAt ‚Ñù (fun x => log (f x)) s x :=\n  (hf.hasFDerivWithinAt.log hx).differentiableWithinAt\n\n"}
{"name":"DifferentiableAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : E ‚Üí Real\nx : E\nhf : DifferentiableAt Real f x\nhx : Ne (f x) 0\n‚ä¢ DifferentiableAt Real (fun x => Real.log (f x)) x","decl":"@[simp, fun_prop]\ntheorem DifferentiableAt.log (hf : DifferentiableAt ‚Ñù f x) (hx : f x ‚â† 0) :\n    DifferentiableAt ‚Ñù (fun x => log (f x)) x :=\n  (hf.hasFDerivAt.log hx).differentiableAt\n\n"}
{"name":"ContDiffAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : E ‚Üí Real\nx : E\nn : WithTop ENat\nhf : ContDiffAt Real n f x\nhx : Ne (f x) 0\n‚ä¢ ContDiffAt Real n (fun x => Real.log (f x)) x","decl":"theorem ContDiffAt.log {n} (hf : ContDiffAt ‚Ñù n f x) (hx : f x ‚â† 0) :\n    ContDiffAt ‚Ñù n (fun x => log (f x)) x :=\n  (contDiffAt_log.2 hx).comp x hf\n\n"}
{"name":"ContDiffWithinAt.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : E ‚Üí Real\nx : E\ns : Set E\nn : WithTop ENat\nhf : ContDiffWithinAt Real n f s x\nhx : Ne (f x) 0\n‚ä¢ ContDiffWithinAt Real n (fun x => Real.log (f x)) s x","decl":"theorem ContDiffWithinAt.log {n} (hf : ContDiffWithinAt ‚Ñù n f s x) (hx : f x ‚â† 0) :\n    ContDiffWithinAt ‚Ñù n (fun x => log (f x)) s x :=\n  (contDiffAt_log.2 hx).comp_contDiffWithinAt x hf\n\n"}
{"name":"ContDiffOn.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : E ‚Üí Real\ns : Set E\nn : WithTop ENat\nhf : ContDiffOn Real n f s\nhs : ‚àÄ (x : E), Membership.mem s x ‚Üí Ne (f x) 0\n‚ä¢ ContDiffOn Real n (fun x => Real.log (f x)) s","decl":"theorem ContDiffOn.log {n} (hf : ContDiffOn ‚Ñù n f s) (hs : ‚àÄ x ‚àà s, f x ‚â† 0) :\n    ContDiffOn ‚Ñù n (fun x => log (f x)) s := fun x hx => (hf x hx).log (hs x hx)\n\n"}
{"name":"ContDiff.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : E ‚Üí Real\nn : WithTop ENat\nhf : ContDiff Real n f\nh : ‚àÄ (x : E), Ne (f x) 0\n‚ä¢ ContDiff Real n fun x => Real.log (f x)","decl":"theorem ContDiff.log {n} (hf : ContDiff ‚Ñù n f) (h : ‚àÄ x, f x ‚â† 0) :\n    ContDiff ‚Ñù n fun x => log (f x) :=\n  contDiff_iff_contDiffAt.2 fun x => hf.contDiffAt.log (h x)\n\n"}
{"name":"DifferentiableOn.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : E ‚Üí Real\ns : Set E\nhf : DifferentiableOn Real f s\nhx : ‚àÄ (x : E), Membership.mem s x ‚Üí Ne (f x) 0\n‚ä¢ DifferentiableOn Real (fun x => Real.log (f x)) s","decl":"@[fun_prop]\ntheorem DifferentiableOn.log (hf : DifferentiableOn ‚Ñù f s) (hx : ‚àÄ x ‚àà s, f x ‚â† 0) :\n    DifferentiableOn ‚Ñù (fun x => log (f x)) s := fun x h => (hf x h).log (hx x h)\n\n"}
{"name":"Differentiable.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : E ‚Üí Real\nhf : Differentiable Real f\nhx : ‚àÄ (x : E), Ne (f x) 0\n‚ä¢ Differentiable Real fun x => Real.log (f x)","decl":"@[simp, fun_prop]\ntheorem Differentiable.log (hf : Differentiable ‚Ñù f) (hx : ‚àÄ x, f x ‚â† 0) :\n    Differentiable ‚Ñù fun x => log (f x) := fun x => (hf x).log (hx x)\n\n"}
{"name":"fderivWithin.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : E ‚Üí Real\nx : E\ns : Set E\nhf : DifferentiableWithinAt Real f s x\nhx : Ne (f x) 0\nhxs : UniqueDiffWithinAt Real s x\n‚ä¢ Eq (fderivWithin Real (fun x => Real.log (f x)) s x) (HSMul.hSMul (Inv.inv (f x)) (fderivWithin Real f s x))","decl":"theorem fderivWithin.log (hf : DifferentiableWithinAt ‚Ñù f s x) (hx : f x ‚â† 0)\n    (hxs : UniqueDiffWithinAt ‚Ñù s x) :\n    fderivWithin ‚Ñù (fun x => log (f x)) s x = (f x)‚Åª¬π ‚Ä¢ fderivWithin ‚Ñù f s x :=\n  (hf.hasFDerivWithinAt.log hx).fderivWithin hxs\n\n"}
{"name":"fderiv.log","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"E : Type u_1\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nf : E ‚Üí Real\nx : E\nhf : DifferentiableAt Real f x\nhx : Ne (f x) 0\n‚ä¢ Eq (fderiv Real (fun x => Real.log (f x)) x) (HSMul.hSMul (Inv.inv (f x)) (fderiv Real f x))","decl":"@[simp]\ntheorem fderiv.log (hf : DifferentiableAt ‚Ñù f x) (hx : f x ‚â† 0) :\n    fderiv ‚Ñù (fun x => log (f x)) x = (f x)‚Åª¬π ‚Ä¢ fderiv ‚Ñù f x :=\n  (hf.hasFDerivAt.log hx).fderiv\n\n"}
{"name":"Real.tendsto_mul_log_one_plus_div_atTop","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"t : Real\n‚ä¢ Filter.Tendsto (fun x => HMul.hMul x (Real.log (HAdd.hAdd 1 (HDiv.hDiv t x)))) Filter.atTop (nhds t)","decl":"/-- The function `x * log (1 + t / x)` tends to `t` at `+‚àû`. -/\ntheorem tendsto_mul_log_one_plus_div_atTop (t : ‚Ñù) :\n    Tendsto (fun x => x * log (1 + t / x)) atTop (ùìù t) := by\n  have h‚ÇÅ : Tendsto (fun h => h‚Åª¬π * log (1 + t * h)) (ùìù[‚â†] 0) (ùìù t) := by\n    simpa [hasDerivAt_iff_tendsto_slope, slope_fun_def] using\n      (((hasDerivAt_id (0 : ‚Ñù)).const_mul t).const_add 1).log (by simp)\n  have h‚ÇÇ : Tendsto (fun x : ‚Ñù => x‚Åª¬π) atTop (ùìù[‚â†] 0) :=\n    tendsto_inv_atTop_nhdsGT_zero.mono_right (nhdsGT_le_nhdsNE _)\n  simpa only [Function.comp_def, inv_inv] using h‚ÇÅ.comp h‚ÇÇ\n\n"}
{"name":"Real.abs_log_sub_add_sum_range_le","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"x : Real\nh : LT.lt (abs x) 1\nn : Nat\n‚ä¢ LE.le (abs (HAdd.hAdd ((Finset.range n).sum fun i => HDiv.hDiv (HPow.hPow x (HAdd.hAdd i 1)) (HAdd.hAdd (‚Üëi) 1)) (Real.log (HSub.hSub 1 x)))) (HDiv.hDiv (HPow.hPow (abs x) (HAdd.hAdd n 1)) (HSub.hSub 1 (abs x)))","decl":"/-- A crude lemma estimating the difference between `log (1-x)` and its Taylor series at `0`,\nwhere the main point of the bound is that it tends to `0`. The goal is to deduce the series\nexpansion of the logarithm, in `hasSum_pow_div_log_of_abs_lt_1`.\n\nPorting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: use one of generic theorems about Taylor's series\nto prove this estimate.\n-/\ntheorem abs_log_sub_add_sum_range_le {x : ‚Ñù} (h : |x| < 1) (n : ‚Ñï) :\n    |(‚àë i ‚àà range n, x ^ (i + 1) / (i + 1)) + log (1 - x)| ‚â§ |x| ^ (n + 1) / (1 - |x|) := by\n  /- For the proof, we show that the derivative of the function to be estimated is small,\n    and then apply the mean value inequality. -/\n  let F : ‚Ñù ‚Üí ‚Ñù := fun x => (‚àë i ‚àà range n, x ^ (i + 1) / (i + 1)) + log (1 - x)\n  let F' : ‚Ñù ‚Üí ‚Ñù := fun x ‚Ü¶ -x ^ n / (1 - x)\n  -- Porting note: In `mathlib3`, the proof used `deriv`/`DifferentiableAt`. `simp` failed to\n  -- compute `deriv`, so I changed the proof to use `HasDerivAt` instead\n  -- First step: compute the derivative of `F`\n  have A : ‚àÄ y ‚àà Ioo (-1 : ‚Ñù) 1, HasDerivAt F (F' y) y := fun y hy ‚Ü¶ by\n    have : HasDerivAt F ((‚àë i ‚àà range n, ‚Üë(i + 1) * y ^ i / (‚Üëi + 1)) + (-1) / (1 - y)) y :=\n      .add (.sum fun i _ ‚Ü¶ (hasDerivAt_pow (i + 1) y).div_const ((i : ‚Ñù) + 1))\n        (((hasDerivAt_id y).const_sub _).log <| sub_ne_zero.2 hy.2.ne')\n    convert this using 1\n    calc\n      -y ^ n / (1 - y) = ‚àë i ‚àà Finset.range n, y ^ i + -1 / (1 - y) := by\n        field_simp [geom_sum_eq hy.2.ne, sub_ne_zero.2 hy.2.ne, sub_ne_zero.2 hy.2.ne']\n        ring\n      _ = ‚àë i ‚àà Finset.range n, ‚Üë(i + 1) * y ^ i / (‚Üëi + 1) + -1 / (1 - y) := by\n        congr with i\n        rw [Nat.cast_succ, mul_div_cancel_left‚ÇÄ _ (Nat.cast_add_one_pos i).ne']\n  -- second step: show that the derivative of `F` is small\n  have B : ‚àÄ y ‚àà Icc (-|x|) |x|, |F' y| ‚â§ |x| ^ n / (1 - |x|) := fun y hy ‚Ü¶\n    calc\n      |F' y| = |y| ^ n / |1 - y| := by simp [F', abs_div]\n      _ ‚â§ |x| ^ n / (1 - |x|) := by\n        have : |y| ‚â§ |x| := abs_le.2 hy\n        have : 1 - |x| ‚â§ |1 - y| := le_trans (by linarith [hy.2]) (le_abs_self _)\n        gcongr\n        exact sub_pos.2 h\n  -- third step: apply the mean value inequality\n  have C : ‚ÄñF x - F 0‚Äñ ‚â§ |x| ^ n / (1 - |x|) * ‚Äñx - 0‚Äñ := by\n    refine Convex.norm_image_sub_le_of_norm_hasDerivWithin_le\n      (fun y hy ‚Ü¶ (A _ ?_).hasDerivWithinAt) B (convex_Icc _ _) ?_ ?_\n    ¬∑ exact Icc_subset_Ioo (neg_lt_neg h) h hy\n    ¬∑ simp\n    ¬∑ simp [le_abs_self x, neg_le.mp (neg_le_abs x)]\n  -- fourth step: conclude by massaging the inequality of the third step\n  simpa [F, div_mul_eq_mul_div, pow_succ] using C\n\n"}
{"name":"Real.hasSum_pow_div_log_of_abs_lt_one","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"x : Real\nh : LT.lt (abs x) 1\n‚ä¢ HasSum (fun n => HDiv.hDiv (HPow.hPow x (HAdd.hAdd n 1)) (HAdd.hAdd (‚Üën) 1)) (Neg.neg (Real.log (HSub.hSub 1 x)))","decl":"/-- Power series expansion of the logarithm around `1`. -/\ntheorem hasSum_pow_div_log_of_abs_lt_one {x : ‚Ñù} (h : |x| < 1) :\n    HasSum (fun n : ‚Ñï => x ^ (n + 1) / (n + 1)) (-log (1 - x)) := by\n  rw [Summable.hasSum_iff_tendsto_nat]\n  ¬∑ show Tendsto (fun n : ‚Ñï => ‚àë i ‚àà range n, x ^ (i + 1) / (i + 1)) atTop (ùìù (-log (1 - x)))\n    rw [tendsto_iff_norm_sub_tendsto_zero]\n    simp only [norm_eq_abs, sub_neg_eq_add]\n    refine squeeze_zero (fun n => abs_nonneg _) (abs_log_sub_add_sum_range_le h) ?_\n    suffices Tendsto (fun t : ‚Ñï => |x| ^ (t + 1) / (1 - |x|)) atTop (ùìù (|x| * 0 / (1 - |x|))) by\n      simpa\n    simp only [pow_succ']\n    refine (tendsto_const_nhds.mul ?_).div_const _\n    exact tendsto_pow_atTop_nhds_zero_of_lt_one (abs_nonneg _) h\n  show Summable fun n : ‚Ñï => x ^ (n + 1) / (n + 1)\n  refine .of_norm_bounded _ (summable_geometric_of_lt_one (abs_nonneg _) h) fun i => ?_\n  calc\n    ‚Äñx ^ (i + 1) / (i + 1)‚Äñ = |x| ^ (i + 1) / (i + 1) := by\n      have : (0 : ‚Ñù) ‚â§ i + 1 := le_of_lt (Nat.cast_add_one_pos i)\n      rw [norm_eq_abs, abs_div, ‚Üê pow_abs, abs_of_nonneg this]\n    _ ‚â§ |x| ^ (i + 1) / (0 + 1) := by\n      gcongr\n      exact i.cast_nonneg\n    _ ‚â§ |x| ^ i := by\n      simpa [pow_succ] using mul_le_of_le_one_right (pow_nonneg (abs_nonneg x) i) (le_of_lt h)\n\n"}
{"name":"Real.hasSum_log_sub_log_of_abs_lt_one","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"x : Real\nh : LT.lt (abs x) 1\n‚ä¢ HasSum (fun k => HMul.hMul (HMul.hMul 2 (HDiv.hDiv 1 (HAdd.hAdd (HMul.hMul 2 ‚Üëk) 1))) (HPow.hPow x (HAdd.hAdd (HMul.hMul 2 k) 1))) (HSub.hSub (Real.log (HAdd.hAdd 1 x)) (Real.log (HSub.hSub 1 x)))","decl":"/-- Power series expansion of `log(1 + x) - log(1 - x)` for `|x| < 1`. -/\ntheorem hasSum_log_sub_log_of_abs_lt_one {x : ‚Ñù} (h : |x| < 1) :\n    HasSum (fun k : ‚Ñï => (2 : ‚Ñù) * (1 / (2 * k + 1)) * x ^ (2 * k + 1))\n      (log (1 + x) - log (1 - x)) := by\n  set term := fun n : ‚Ñï => -1 * ((-x) ^ (n + 1) / ((n : ‚Ñù) + 1)) + x ^ (n + 1) / (n + 1)\n  have h_term_eq_goal :\n      term ‚àò (2 * ¬∑) = fun k : ‚Ñï => 2 * (1 / (2 * k + 1)) * x ^ (2 * k + 1) := by\n    ext n\n    dsimp only [term, (¬∑ ‚àò ¬∑)]\n    rw [Odd.neg_pow (‚ü®n, rfl‚ü© : Odd (2 * n + 1)) x]\n    push_cast\n    ring_nf\n  rw [‚Üê h_term_eq_goal, (mul_right_injective‚ÇÄ (two_ne_zero' ‚Ñï)).hasSum_iff]\n  ¬∑ have h‚ÇÅ := (hasSum_pow_div_log_of_abs_lt_one (Eq.trans_lt (abs_neg x) h)).mul_left (-1)\n    convert h‚ÇÅ.add (hasSum_pow_div_log_of_abs_lt_one h) using 1\n    ring_nf\n  ¬∑ intro m hm\n    rw [range_two_mul, Set.mem_setOf_eq, ‚Üê Nat.even_add_one] at hm\n    dsimp [term]\n    rw [Even.neg_pow hm, neg_one_mul, neg_add_cancel]\n\n"}
{"name":"Real.hasSum_log_one_add_inv","module":"Mathlib.Analysis.SpecialFunctions.Log.Deriv","initialProofState":"a : Real\nh : LT.lt 0 a\n‚ä¢ HasSum (fun k => HMul.hMul (HMul.hMul 2 (HDiv.hDiv 1 (HAdd.hAdd (HMul.hMul 2 ‚Üëk) 1))) (HPow.hPow (HDiv.hDiv 1 (HAdd.hAdd (HMul.hMul 2 a) 1)) (HAdd.hAdd (HMul.hMul 2 k) 1))) (Real.log (HAdd.hAdd 1 (Inv.inv a)))","decl":"/-- Expansion of `log (1 + a‚Åª¬π)` as a series in powers of `1 / (2 * a + 1)`. -/\ntheorem hasSum_log_one_add_inv {a : ‚Ñù} (h : 0 < a) :\n    HasSum (fun k : ‚Ñï => (2 : ‚Ñù) * (1 / (2 * k + 1)) * (1 / (2 * a + 1)) ^ (2 * k + 1))\n      (log (1 + a‚Åª¬π)) := by\n  have h‚ÇÅ : |1 / (2 * a + 1)| < 1 := by\n    rw [abs_of_pos, div_lt_one]\n    ¬∑ linarith\n    ¬∑ linarith\n    ¬∑ exact div_pos one_pos (by linarith)\n  convert hasSum_log_sub_log_of_abs_lt_one h‚ÇÅ using 1\n  have h‚ÇÇ : (2 : ‚Ñù) * a + 1 ‚â† 0 := by linarith\n  have h‚ÇÉ := h.ne'\n  rw [‚Üê log_div]\n  ¬∑ congr\n    field_simp\n    linarith\n  ¬∑ field_simp\n    linarith\n  ¬∑ field_simp\n\n"}
