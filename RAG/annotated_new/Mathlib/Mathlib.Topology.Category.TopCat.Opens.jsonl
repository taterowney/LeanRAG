{"name":"TopologicalSpace.Opens.infLELeft_apply","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU V : TopologicalSpace.Opens ‚ÜëX\nx : Subtype fun x => Membership.mem (Min.min U V) x\n‚ä¢ Eq ((fun x => ‚ü®‚Üëx, ‚ãØ‚ü©) x) ‚ü®‚Üëx, ‚ãØ‚ü©","decl":"theorem infLELeft_apply (U V : Opens X) (x) :\n    (infLELeft U V) x = ‚ü®x.1, (@inf_le_left _ _ U V : _ ‚â§ _) x.2‚ü© :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.infLELeft_apply_mk","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU V : TopologicalSpace.Opens ‚ÜëX\nx : ‚ÜëX\nm : Membership.mem (Min.min U V) x\n‚ä¢ Eq ((fun x => ‚ü®‚Üëx, ‚ãØ‚ü©) ‚ü®x, m‚ü©) ‚ü®x, ‚ãØ‚ü©","decl":"@[simp]\ntheorem infLELeft_apply_mk (U V : Opens X) (x) (m) :\n    (infLELeft U V) ‚ü®x, m‚ü© = ‚ü®x, (@inf_le_left _ _ U V : _ ‚â§ _) m‚ü© :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.leSupr_apply_mk","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nŒπ : Type u_1\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\ni : Œπ\nx : ‚ÜëX\nm : Membership.mem (U i) x\n‚ä¢ Eq ((fun x => ‚ü®‚Üëx, ‚ãØ‚ü©) ‚ü®x, m‚ü©) ‚ü®x, ‚ãØ‚ü©","decl":"@[simp]\ntheorem leSupr_apply_mk {Œπ : Type*} (U : Œπ ‚Üí Opens X) (i : Œπ) (x) (m) :\n    (leSupr U i) ‚ü®x, m‚ü© = ‚ü®x, (le_iSup U i :) m‚ü© :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.toTopCat_map","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU V : TopologicalSpace.Opens ‚ÜëX\nf : Quiver.Hom U V\nx : ‚ÜëX\nh : Membership.mem U x\n‚ä¢ Eq (((TopologicalSpace.Opens.toTopCat X).map f) ‚ü®x, h‚ü©) ‚ü®x, ‚ãØ‚ü©","decl":"@[simp]\ntheorem toTopCat_map (X : TopCat.{u}) {U V : Opens X} {f : U ‚ü∂ V} {x} {h} :\n    ((toTopCat X).map f) ‚ü®x, h‚ü© = ‚ü®x, f.le h‚ü© :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.inclusion'_apply","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq (‚áëU.inclusion') Subtype.val","decl":"/-- The inclusion map from an open subset to the whole space, as a morphism in `TopCat`.\n-/\n@[simps (config := .asFn)]\ndef inclusion' {X : TopCat.{u}} (U : Opens X) : (toTopCat X).obj U ‚ü∂ X where\n  toFun := _\n  continuous_toFun := continuous_subtype_val\n\n"}
{"name":"TopologicalSpace.Opens.coe_inclusion'","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq (‚áëU.inclusion') Subtype.val","decl":"@[simp]\ntheorem coe_inclusion' {X : TopCat} {U : Opens X} :\n    (inclusion' U : U ‚Üí X) = Subtype.val := rfl\n\n"}
{"name":"TopologicalSpace.Opens.isOpenEmbedding","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Topology.IsOpenEmbedding ‚áëU.inclusion'","decl":"theorem isOpenEmbedding {X : TopCat.{u}} (U : Opens X) : IsOpenEmbedding (inclusion' U) :=\n  U.2.isOpenEmbedding_subtypeVal\n\n"}
{"name":"TopologicalSpace.Opens.openEmbedding","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Topology.IsOpenEmbedding ‚áëU.inclusion'","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding := isOpenEmbedding\n\n"}
{"name":"TopologicalSpace.Opens.map_coe","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nU : TopologicalSpace.Opens ‚ÜëY\n‚ä¢ Eq (‚Üë((TopologicalSpace.Opens.map f).obj U)) (Set.preimage ‚áëf ‚ÜëU)","decl":"@[simp]\ntheorem map_coe (f : X ‚ü∂ Y) (U : Opens Y) : ((map f).obj U : Set X) = f ‚Åª¬π' (U : Set Y) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.map_obj","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nU : Set ‚ÜëY\np : IsOpen U\n‚ä¢ Eq ((TopologicalSpace.Opens.map f).obj { carrier := U, is_open' := p }) { carrier := Set.preimage (‚áëf) U, is_open' := ‚ãØ }","decl":"@[simp]\ntheorem map_obj (f : X ‚ü∂ Y) (U) (p) : (map f).obj ‚ü®U, p‚ü© = ‚ü®f ‚Åª¬π' U, p.preimage f.continuous‚ü© :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.map_homOfLE","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nU V : TopologicalSpace.Opens ‚ÜëY\ne : LE.le U V\n‚ä¢ Eq ((TopologicalSpace.Opens.map f).map (CategoryTheory.homOfLE e)) (CategoryTheory.homOfLE ‚ãØ)","decl":"@[simp]\nlemma map_homOfLE (f : X ‚ü∂ Y) {U V : Opens Y} (e : U ‚â§ V) :\n    (TopologicalSpace.Opens.map f).map (homOfLE e) =\n      homOfLE (show (Opens.map f).obj U ‚â§ (Opens.map f).obj V from fun _ hx ‚Ü¶ e hx) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.map_id_obj","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq ((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.id X)).obj U) U","decl":"@[simp]\ntheorem map_id_obj (U : Opens X) : (map (ùüô X)).obj U = U :=\n  let ‚ü®_, _‚ü© := U\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.map_id_obj'","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : Set ‚ÜëX\np : IsOpen U\n‚ä¢ Eq ((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.id X)).obj { carrier := U, is_open' := p }) { carrier := U, is_open' := p }","decl":"@[simp]\ntheorem map_id_obj' (U) (p) : (map (ùüô X)).obj ‚ü®U, p‚ü© = ‚ü®U, p‚ü© :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.map_id_obj_unop","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : Opposite (TopologicalSpace.Opens ‚ÜëX)\n‚ä¢ Eq ((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.id X)).obj (Opposite.unop U)) (Opposite.unop U)","decl":"theorem map_id_obj_unop (U : (Opens X)·µí·µñ) : (map (ùüô X)).obj (unop U) = unop U := by\n  simp\n\n"}
{"name":"TopologicalSpace.Opens.op_map_id_obj","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : Opposite (TopologicalSpace.Opens ‚ÜëX)\n‚ä¢ Eq ((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.id X)).op.obj U) U","decl":"theorem op_map_id_obj (U : (Opens X)·µí·µñ) : (map (ùüô X)).op.obj U = U := by simp\n\n"}
{"name":"TopologicalSpace.Opens.map_top","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\n‚ä¢ Eq ((TopologicalSpace.Opens.map f).obj Top.top) Top.top","decl":"@[simp]\nlemma map_top (f : X ‚ü∂ Y) : (Opens.map f).obj ‚ä§ = ‚ä§ := rfl\n\n"}
{"name":"TopologicalSpace.Opens.map_comp_obj","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nU : TopologicalSpace.Opens ‚ÜëZ\n‚ä¢ Eq ((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.comp f g)).obj U) ((TopologicalSpace.Opens.map f).obj ((TopologicalSpace.Opens.map g).obj U))","decl":"@[simp]\ntheorem map_comp_obj (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (U) :\n    (map (f ‚â´ g)).obj U = (map f).obj ((map g).obj U) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.map_comp_obj'","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nU : Set ‚ÜëZ\np : IsOpen U\n‚ä¢ Eq ((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.comp f g)).obj { carrier := U, is_open' := p }) ((TopologicalSpace.Opens.map f).obj ((TopologicalSpace.Opens.map g).obj { carrier := U, is_open' := p }))","decl":"@[simp]\ntheorem map_comp_obj' (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (U) (p) :\n    (map (f ‚â´ g)).obj ‚ü®U, p‚ü© = (map f).obj ((map g).obj ‚ü®U, p‚ü©) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.map_comp_map","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nU V : TopologicalSpace.Opens ‚ÜëZ\ni : Quiver.Hom U V\n‚ä¢ Eq ((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.comp f g)).map i) ((TopologicalSpace.Opens.map f).map ((TopologicalSpace.Opens.map g).map i))","decl":"@[simp]\ntheorem map_comp_map (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) {U V} (i : U ‚ü∂ V) :\n    (map (f ‚â´ g)).map i = (map f).map ((map g).map i) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.map_comp_obj_unop","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nU : Opposite (TopologicalSpace.Opens ‚ÜëZ)\n‚ä¢ Eq ((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.comp f g)).obj (Opposite.unop U)) ((TopologicalSpace.Opens.map f).obj ((TopologicalSpace.Opens.map g).obj (Opposite.unop U)))","decl":"@[simp]\ntheorem map_comp_obj_unop (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (U) :\n    (map (f ‚â´ g)).obj (unop U) = (map f).obj ((map g).obj (unop U)) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.op_map_comp_obj","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nU : Opposite (TopologicalSpace.Opens ‚ÜëZ)\n‚ä¢ Eq ((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.comp f g)).op.obj U) ((TopologicalSpace.Opens.map f).op.obj ((TopologicalSpace.Opens.map g).op.obj U))","decl":"@[simp]\ntheorem op_map_comp_obj (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (U) :\n    (map (f ‚â´ g)).op.obj U = (map f).op.obj ((map g).op.obj U) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.map_iSup","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nŒπ : Type u_1\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëY\n‚ä¢ Eq ((TopologicalSpace.Opens.map f).obj (iSup U)) (iSup (Function.comp (TopologicalSpace.Opens.map f).obj U))","decl":"theorem map_iSup (f : X ‚ü∂ Y) {Œπ : Type*} (U : Œπ ‚Üí Opens Y) :\n    (map f).obj (iSup U) = iSup ((map f).obj ‚àò U) := by\n  ext1; rw [iSup_def, iSup_def, map_obj]\n  dsimp; rw [Set.preimage_iUnion]\n\n"}
{"name":"TopologicalSpace.Opens.mapId_inv_app","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq ((TopologicalSpace.Opens.mapId X).inv.app U) (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- The functor `Opens X ‚•§ Opens X` given by taking preimages under the identity function\nis naturally isomorphic to the identity functor.\n-/\n@[simps]\ndef mapId : map (ùüô X) ‚âÖ ùü≠ (Opens X) where\n  hom := { app := fun U => eqToHom (map_id_obj U) }\n  inv := { app := fun U => eqToHom (map_id_obj U).symm }\n\n"}
{"name":"TopologicalSpace.Opens.mapId_hom_app","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq ((TopologicalSpace.Opens.mapId X).hom.app U) (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- The functor `Opens X ‚•§ Opens X` given by taking preimages under the identity function\nis naturally isomorphic to the identity functor.\n-/\n@[simps]\ndef mapId : map (ùüô X) ‚âÖ ùü≠ (Opens X) where\n  hom := { app := fun U => eqToHom (map_id_obj U) }\n  inv := { app := fun U => eqToHom (map_id_obj U).symm }\n\n"}
{"name":"TopologicalSpace.Opens.map_id_eq","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\n‚ä¢ Eq (TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.Functor.id (TopologicalSpace.Opens ‚ÜëX))","decl":"theorem map_id_eq : map (ùüô X) = ùü≠ (Opens X) := by\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.mapComp_inv_app","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nU : TopologicalSpace.Opens ‚ÜëZ\n‚ä¢ Eq ((TopologicalSpace.Opens.mapComp f g).inv.app U) (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- The natural isomorphism between taking preimages under `f ‚â´ g`, and the composite\nof taking preimages under `g`, then preimages under `f`.\n-/\n@[simps]\ndef mapComp (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : map (f ‚â´ g) ‚âÖ map g ‚ãô map f where\n  hom := { app := fun U => eqToHom (map_comp_obj f g U) }\n  inv := { app := fun U => eqToHom (map_comp_obj f g U).symm }\n\n"}
{"name":"TopologicalSpace.Opens.mapComp_hom_app","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nU : TopologicalSpace.Opens ‚ÜëZ\n‚ä¢ Eq ((TopologicalSpace.Opens.mapComp f g).hom.app U) (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- The natural isomorphism between taking preimages under `f ‚â´ g`, and the composite\nof taking preimages under `g`, then preimages under `f`.\n-/\n@[simps]\ndef mapComp (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : map (f ‚â´ g) ‚âÖ map g ‚ãô map f where\n  hom := { app := fun U => eqToHom (map_comp_obj f g U) }\n  inv := { app := fun U => eqToHom (map_comp_obj f g U).symm }\n\n"}
{"name":"TopologicalSpace.Opens.map_comp_eq","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.comp f g)) ((TopologicalSpace.Opens.map g).comp (TopologicalSpace.Opens.map f))","decl":"theorem map_comp_eq (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : map (f ‚â´ g) = map g ‚ãô map f :=\n  rfl\n\n-- We could make `f g` implicit here, but it's nice to be able to see when\n-- they are the identity (often!)\n"}
{"name":"TopologicalSpace.Opens.map_eq","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf g : Quiver.Hom X Y\nh : Eq f g\n‚ä¢ Eq (TopologicalSpace.Opens.map f) (TopologicalSpace.Opens.map g)","decl":"theorem map_eq (f g : X ‚ü∂ Y) (h : f = g) : map f = map g := by\n  subst h\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.mapIso_refl","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nh : Eq f f\n‚ä¢ Eq (TopologicalSpace.Opens.mapIso f f h) (CategoryTheory.Iso.refl (TopologicalSpace.Opens.map f))","decl":"@[simp]\ntheorem mapIso_refl (f : X ‚ü∂ Y) (h) : mapIso f f h = Iso.refl (map _) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.mapIso_hom_app","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf g : Quiver.Hom X Y\nh : Eq f g\nU : TopologicalSpace.Opens ‚ÜëY\n‚ä¢ Eq ((TopologicalSpace.Opens.mapIso f g h).hom.app U) (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\ntheorem mapIso_hom_app (f g : X ‚ü∂ Y) (h : f = g) (U : Opens Y) :\n    (mapIso f g h).hom.app U = eqToHom (by rw [h]) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.mapIso_inv_app","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf g : Quiver.Hom X Y\nh : Eq f g\nU : TopologicalSpace.Opens ‚ÜëY\n‚ä¢ Eq ((TopologicalSpace.Opens.mapIso f g h).inv.app U) (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\ntheorem mapIso_inv_app (f g : X ‚ü∂ Y) (h : f = g) (U : Opens Y) :\n    (mapIso f g h).inv.app U = eqToHom (by rw [h]) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.mapMapIso_functor","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nH : CategoryTheory.Iso X Y\n‚ä¢ Eq (TopologicalSpace.Opens.mapMapIso H).functor (TopologicalSpace.Opens.map H.hom)","decl":"/-- A homeomorphism of spaces gives an equivalence of categories of open sets.\n\nTODO: define `OrderIso.equivalence`, use it.\n-/\n@[simps]\ndef mapMapIso {X Y : TopCat.{u}} (H : X ‚âÖ Y) : Opens Y ‚âå Opens X where\n  functor := map H.hom\n  inverse := map H.inv\n  unitIso := NatIso.ofComponents fun U => eqToIso (by simp [map, Set.preimage_preimage])\n  counitIso := NatIso.ofComponents fun U => eqToIso (by simp [map, Set.preimage_preimage])\n\n"}
{"name":"TopologicalSpace.Opens.mapMapIso_unitIso","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nH : CategoryTheory.Iso X Y\n‚ä¢ Eq (TopologicalSpace.Opens.mapMapIso H).unitIso (CategoryTheory.NatIso.ofComponents (fun U => CategoryTheory.eqToIso ‚ãØ) ‚ãØ)","decl":"/-- A homeomorphism of spaces gives an equivalence of categories of open sets.\n\nTODO: define `OrderIso.equivalence`, use it.\n-/\n@[simps]\ndef mapMapIso {X Y : TopCat.{u}} (H : X ‚âÖ Y) : Opens Y ‚âå Opens X where\n  functor := map H.hom\n  inverse := map H.inv\n  unitIso := NatIso.ofComponents fun U => eqToIso (by simp [map, Set.preimage_preimage])\n  counitIso := NatIso.ofComponents fun U => eqToIso (by simp [map, Set.preimage_preimage])\n\n"}
{"name":"TopologicalSpace.Opens.mapMapIso_counitIso","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nH : CategoryTheory.Iso X Y\n‚ä¢ Eq (TopologicalSpace.Opens.mapMapIso H).counitIso (CategoryTheory.NatIso.ofComponents (fun U => CategoryTheory.eqToIso ‚ãØ) ‚ãØ)","decl":"/-- A homeomorphism of spaces gives an equivalence of categories of open sets.\n\nTODO: define `OrderIso.equivalence`, use it.\n-/\n@[simps]\ndef mapMapIso {X Y : TopCat.{u}} (H : X ‚âÖ Y) : Opens Y ‚âå Opens X where\n  functor := map H.hom\n  inverse := map H.inv\n  unitIso := NatIso.ofComponents fun U => eqToIso (by simp [map, Set.preimage_preimage])\n  counitIso := NatIso.ofComponents fun U => eqToIso (by simp [map, Set.preimage_preimage])\n\n"}
{"name":"TopologicalSpace.Opens.mapMapIso_inverse","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nH : CategoryTheory.Iso X Y\n‚ä¢ Eq (TopologicalSpace.Opens.mapMapIso H).inverse (TopologicalSpace.Opens.map H.inv)","decl":"/-- A homeomorphism of spaces gives an equivalence of categories of open sets.\n\nTODO: define `OrderIso.equivalence`, use it.\n-/\n@[simps]\ndef mapMapIso {X Y : TopCat.{u}} (H : X ‚âÖ Y) : Opens Y ‚âå Opens X where\n  functor := map H.hom\n  inverse := map H.inv\n  unitIso := NatIso.ofComponents fun U => eqToIso (by simp [map, Set.preimage_preimage])\n  counitIso := NatIso.ofComponents fun U => eqToIso (by simp [map, Set.preimage_preimage])\n\n"}
{"name":"IsOpenMap.coe_functor_obj","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : IsOpenMap ‚áëf\nU : TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq (‚Üë(hf.functor.obj U)) (Set.image ‚áëf ‚ÜëU)","decl":"/-- An open map `f : X ‚ü∂ Y` induces a functor `Opens X ‚•§ Opens Y`.\n-/\n@[simps obj_coe]\ndef IsOpenMap.functor {X Y : TopCat} {f : X ‚ü∂ Y} (hf : IsOpenMap f) : Opens X ‚•§ Opens Y where\n  obj U := ‚ü®f '' (U : Set X), hf (U : Set X) U.2‚ü©\n  map h := ‚ü®‚ü®Set.image_subset _ h.down.down‚ü©‚ü©\n\n"}
{"name":"IsOpenMap.functorFullOfMono","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : IsOpenMap ‚áëf\nH : CategoryTheory.Mono f\n‚ä¢ hf.functor.Full","decl":"instance IsOpenMap.functorFullOfMono {X Y : TopCat} {f : X ‚ü∂ Y} (hf : IsOpenMap f) [H : Mono f] :\n    hf.functor.Full where\n  map_surjective i :=\n    ‚ü®homOfLE fun x hx => by\n      obtain ‚ü®y, hy, eq‚ü© := i.le ‚ü®x, hx, rfl‚ü©\n      exact (TopCat.mono_iff_injective f).mp H eq ‚ñ∏ hy, rfl‚ü©\n\n"}
{"name":"IsOpenMap.functor_faithful","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : IsOpenMap ‚áëf\n‚ä¢ hf.functor.Faithful","decl":"instance IsOpenMap.functor_faithful {X Y : TopCat} {f : X ‚ü∂ Y} (hf : IsOpenMap f) :\n    hf.functor.Faithful where\n\n"}
{"name":"Topology.IsOpenEmbedding.functor_obj_injective","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : Topology.IsOpenEmbedding ‚áëf\n‚ä¢ Function.Injective ‚ãØ.functor.obj","decl":"lemma Topology.IsOpenEmbedding.functor_obj_injective {X Y : TopCat} {f : X ‚ü∂ Y}\n    (hf : IsOpenEmbedding f) : Function.Injective hf.isOpenMap.functor.obj :=\n  fun _ _ e ‚Ü¶ Opens.ext (Set.image_injective.mpr hf.injective (congr_arg (‚Üë¬∑ : Opens Y ‚Üí Set Y) e))\n\n"}
{"name":"OpenEmbedding.functor_obj_injective","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : Topology.IsOpenEmbedding ‚áëf\n‚ä¢ Function.Injective ‚ãØ.functor.obj","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.functor_obj_injective := IsOpenEmbedding.functor_obj_injective\n\n"}
{"name":"Topology.IsInducing.map_functorObj","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : Topology.IsInducing ‚áëf\nU : TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq ((TopologicalSpace.Opens.map f).obj (hf.functorObj U)) U","decl":"lemma map_functorObj {X Y : TopCat} {f : X ‚ü∂ Y} (hf : IsInducing f)\n    (U : Opens X) :\n    (Opens.map f).obj (hf.functorObj U) = U := by\n  apply le_antisymm\n  ¬∑ rintro x ‚ü®_, ‚ü®s, rfl‚ü©, _, ‚ü®rfl : _ = U, rfl‚ü©, hx : f x ‚àà s‚ü©; exact hx\n  ¬∑ intros x hx\n    obtain ‚ü®U, hU‚ü© := U\n    obtain ‚ü®t, ht, rfl‚ü© := hf.isOpen_iff.mp hU\n    exact Opens.mem_sSup.mpr ‚ü®‚ü®_, ht‚ü©, rfl, hx‚ü©\n\n"}
{"name":"Topology.IsInducing.mem_functorObj_iff","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : Topology.IsInducing ‚áëf\nU : TopologicalSpace.Opens ‚ÜëX\nx : ‚ÜëX\n‚ä¢ Iff (Membership.mem (hf.functorObj U) (f x)) (Membership.mem U x)","decl":"lemma mem_functorObj_iff {X Y : TopCat} {f : X ‚ü∂ Y} (hf : IsInducing f) (U : Opens X)\n    {x : X} : f x ‚àà hf.functorObj U ‚Üî x ‚àà U := by\n  conv_rhs => rw [‚Üê hf.map_functorObj U]\n  rfl\n\n"}
{"name":"Topology.IsInducing.le_functorObj_iff","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : Topology.IsInducing ‚áëf\nU : TopologicalSpace.Opens ‚ÜëX\nV : TopologicalSpace.Opens ‚ÜëY\n‚ä¢ Iff (LE.le V (hf.functorObj U)) (LE.le ((TopologicalSpace.Opens.map f).obj V) U)","decl":"lemma le_functorObj_iff {X Y : TopCat} {f : X ‚ü∂ Y} (hf : IsInducing f) {U : Opens X}\n    {V : Opens Y} : V ‚â§ hf.functorObj U ‚Üî (Opens.map f).obj V ‚â§ U := by\n  obtain ‚ü®U, hU‚ü© := U\n  obtain ‚ü®t, ht, rfl‚ü© := hf.isOpen_iff.mp hU\n  constructor\n  ¬∑ exact fun i x hx ‚Ü¶ (hf.mem_functorObj_iff ((Opens.map f).obj ‚ü®t, ht‚ü©)).mp (i hx)\n  ¬∑ intros h x hx\n    refine Opens.mem_sSup.mpr ‚ü®‚ü®_, V.2.union ht‚ü©, Opens.ext ?_, Set.mem_union_left t hx‚ü©\n    dsimp\n    rwa [Set.union_eq_right]\n\n"}
{"name":"Topology.IsInducing.functor_obj","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : Topology.IsInducing ‚áëf\nU : TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq (hf.functor.obj U) (hf.functorObj U)","decl":"/-- An inducing map `f : X ‚ü∂ Y` induces a functor `Opens X ‚•§ Opens Y`. -/\n@[simps]\ndef functor {X Y : TopCat} {f : X ‚ü∂ Y} (hf : IsInducing f) :\n    Opens X ‚•§ Opens Y where\n  obj := hf.functorObj\n  map {U V} h := homOfLE (hf.le_functorObj_iff.mpr ((hf.map_functorObj U).trans_le h.le))\n\n"}
{"name":"Topology.IsInducing.functor_map","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : Topology.IsInducing ‚áëf\nU V : TopologicalSpace.Opens ‚ÜëX\nh : Quiver.Hom U V\n‚ä¢ Eq (hf.functor.map h) (CategoryTheory.homOfLE ‚ãØ)","decl":"/-- An inducing map `f : X ‚ü∂ Y` induces a functor `Opens X ‚•§ Opens Y`. -/\n@[simps]\ndef functor {X Y : TopCat} {f : X ‚ü∂ Y} (hf : IsInducing f) :\n    Opens X ‚•§ Opens Y where\n  obj := hf.functorObj\n  map {U V} h := homOfLE (hf.le_functorObj_iff.mpr ((hf.map_functorObj U).trans_le h.le))\n\n"}
{"name":"TopologicalSpace.Opens.isOpenEmbedding_obj_top","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq (‚ãØ.functor.obj Top.top) U","decl":"@[simp]\ntheorem isOpenEmbedding_obj_top {X : TopCat} (U : Opens X) :\n    U.isOpenEmbedding.isOpenMap.functor.obj ‚ä§ = U := by\n  ext1\n  exact Set.image_univ.trans Subtype.range_coe\n\n"}
{"name":"TopologicalSpace.Opens.openEmbedding_obj_top","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq (‚ãØ.functor.obj Top.top) U","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_obj_top := isOpenEmbedding_obj_top\n\n"}
{"name":"TopologicalSpace.Opens.inclusion'_map_eq_top","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq ((TopologicalSpace.Opens.map U.inclusion').obj U) Top.top","decl":"@[simp]\ntheorem inclusion'_map_eq_top {X : TopCat} (U : Opens X) : (Opens.map U.inclusion').obj U = ‚ä§ := by\n  ext1\n  exact Subtype.coe_preimage_self _\n\n"}
{"name":"TopologicalSpace.Opens.adjunction_counit_app_self","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq (‚ãØ.adjunction.counit.app U) (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\ntheorem adjunction_counit_app_self {X : TopCat} (U : Opens X) :\n    U.isOpenEmbedding.isOpenMap.adjunction.counit.app U = eqToHom (by simp) := Subsingleton.elim _ _\n\n"}
{"name":"TopologicalSpace.Opens.inclusion'_top_functor","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\n‚ä¢ Eq ‚ãØ.functor (TopologicalSpace.Opens.map (TopologicalSpace.Opens.inclusionTopIso X).inv)","decl":"theorem inclusion'_top_functor (X : TopCat) :\n    (@Opens.isOpenEmbedding X ‚ä§).isOpenMap.functor = map (inclusionTopIso X).inv := by\n  refine CategoryTheory.Functor.ext ?_ ?_\n  ¬∑ intro U\n    ext x\n    exact ‚ü®fun ‚ü®‚ü®_, _‚ü©, h, rfl‚ü© => h, fun h => ‚ü®‚ü®x, trivial‚ü©, h, rfl‚ü©‚ü©\n  ¬∑ subsingleton\n\n"}
{"name":"TopologicalSpace.Opens.functor_obj_map_obj","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : IsOpenMap ‚áëf\nU : TopologicalSpace.Opens ‚ÜëY\n‚ä¢ Eq (hf.functor.obj ((TopologicalSpace.Opens.map f).obj U)) (Min.min (hf.functor.obj Top.top) U)","decl":"theorem functor_obj_map_obj {X Y : TopCat} {f : X ‚ü∂ Y} (hf : IsOpenMap f) (U : Opens Y) :\n    hf.functor.obj ((Opens.map f).obj U) = hf.functor.obj ‚ä§ ‚äì U := by\n  ext\n  constructor\n  ¬∑ rintro ‚ü®x, hx, rfl‚ü©\n    exact ‚ü®‚ü®x, trivial, rfl‚ü©, hx‚ü©\n  ¬∑ rintro ‚ü®‚ü®x, -, rfl‚ü©, hx‚ü©\n    exact ‚ü®x, hx, rfl‚ü©\n\n-- Porting note: added to ease the proof of `functor_map_eq_inf`\n"}
{"name":"TopologicalSpace.Opens.set_range_inclusion'","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq (Set.range ‚áëU.inclusion') ‚ÜëU","decl":"lemma set_range_inclusion' {X : TopCat} (U : Opens X) :\n    Set.range (inclusion' U) = (U : Set X) := by\n  ext x\n  constructor\n  ¬∑ rintro ‚ü®x, rfl‚ü©\n    exact x.2\n  ¬∑ intro h\n    exact ‚ü®‚ü®x, h‚ü©, rfl‚ü©\n"}
{"name":"TopologicalSpace.Opens.set_range_forget_map_inclusion'","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq (Set.range ‚áëU.inclusion') ‚ÜëU","decl":"@[deprecated (since := \"2024-09-07\")] alias set_range_forget_map_inclusion' := set_range_inclusion'\n\n"}
{"name":"TopologicalSpace.Opens.functor_map_eq_inf","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU V : TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq (‚ãØ.functor.obj ((TopologicalSpace.Opens.map U.inclusion').obj V)) (Min.min V U)","decl":"@[simp]\ntheorem functor_map_eq_inf {X : TopCat} (U V : Opens X) :\n    U.isOpenEmbedding.isOpenMap.functor.obj ((Opens.map U.inclusion').obj V) = V ‚äì U := by\n  ext1\n  simp only [IsOpenMap.coe_functor_obj, map_coe, coe_inf,\n    Set.image_preimage_eq_inter_range, set_range_inclusion' U]\n\n"}
{"name":"TopologicalSpace.Opens.map_functor_eq'","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X U : TopCat\nf : Quiver.Hom U X\nhf : Topology.IsOpenEmbedding ‚áëf\nV : TopologicalSpace.Opens ‚ÜëU\n‚ä¢ Eq ((TopologicalSpace.Opens.map f).obj (‚ãØ.functor.obj V)) V","decl":"theorem map_functor_eq' {X U : TopCat} (f : U ‚ü∂ X) (hf : IsOpenEmbedding f) (V) :\n    ((Opens.map f).obj <| hf.isOpenMap.functor.obj V) = V :=\n  Opens.ext <| Set.preimage_image_eq _ hf.injective\n\n"}
{"name":"TopologicalSpace.Opens.map_functor_eq","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens ‚ÜëX\nV : TopologicalSpace.Opens (Subtype fun x => Membership.mem U x)\n‚ä¢ Eq ((TopologicalSpace.Opens.map U.inclusion').obj (‚ãØ.functor.obj V)) V","decl":"@[simp]\ntheorem map_functor_eq {X : TopCat} {U : Opens X} (V : Opens U) :\n    ((Opens.map U.inclusion').obj <| U.isOpenEmbedding.isOpenMap.functor.obj V) = V :=\n  TopologicalSpace.Opens.map_functor_eq' _ U.isOpenEmbedding V\n\n"}
{"name":"TopologicalSpace.Opens.adjunction_counit_map_functor","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens ‚ÜëX\nV : TopologicalSpace.Opens (Subtype fun x => Membership.mem U x)\n‚ä¢ Eq (‚ãØ.adjunction.counit.app (‚ãØ.functor.obj V)) (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\ntheorem adjunction_counit_map_functor {X : TopCat} {U : Opens X} (V : Opens U) :\n    U.isOpenEmbedding.isOpenMap.adjunction.counit.app (U.isOpenEmbedding.isOpenMap.functor.obj V) =\n      eqToHom (by dsimp; rw [map_functor_eq V]) := by\n  subsingleton\n\n"}
