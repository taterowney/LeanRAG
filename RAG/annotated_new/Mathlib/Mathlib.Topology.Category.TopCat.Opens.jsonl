{"name":"TopologicalSpace.Opens.infLELeft_apply","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU V : TopologicalSpace.Opens â†‘X\nx : Subtype fun x => Membership.mem (Min.min U V) x\nâŠ¢ Eq ((fun x => âŸ¨â†‘x, â‹¯âŸ©) x) âŸ¨â†‘x, â‹¯âŸ©","decl":"theorem infLELeft_apply (U V : Opens X) (x) :\n    (infLELeft U V) x = âŸ¨x.1, (@inf_le_left _ _ U V : _ â‰¤ _) x.2âŸ© :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.infLELeft_apply_mk","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU V : TopologicalSpace.Opens â†‘X\nx : â†‘X\nm : Membership.mem (Min.min U V) x\nâŠ¢ Eq ((fun x => âŸ¨â†‘x, â‹¯âŸ©) âŸ¨x, mâŸ©) âŸ¨x, â‹¯âŸ©","decl":"@[simp]\ntheorem infLELeft_apply_mk (U V : Opens X) (x) (m) :\n    (infLELeft U V) âŸ¨x, mâŸ© = âŸ¨x, (@inf_le_left _ _ U V : _ â‰¤ _) mâŸ© :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.leSupr_apply_mk","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nÎ¹ : Type u_1\nU : Î¹ â†’ TopologicalSpace.Opens â†‘X\ni : Î¹\nx : â†‘X\nm : Membership.mem (U i) x\nâŠ¢ Eq ((fun x => âŸ¨â†‘x, â‹¯âŸ©) âŸ¨x, mâŸ©) âŸ¨x, â‹¯âŸ©","decl":"@[simp]\ntheorem leSupr_apply_mk {Î¹ : Type*} (U : Î¹ â†’ Opens X) (i : Î¹) (x) (m) :\n    (leSupr U i) âŸ¨x, mâŸ© = âŸ¨x, (le_iSup U i :) mâŸ© :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.toTopCat_map","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU V : TopologicalSpace.Opens â†‘X\nf : Quiver.Hom U V\nx : â†‘X\nh : Membership.mem U x\nâŠ¢ Eq (((TopologicalSpace.Opens.toTopCat X).map f) âŸ¨x, hâŸ©) âŸ¨x, â‹¯âŸ©","decl":"@[simp]\ntheorem toTopCat_map (X : TopCat.{u}) {U V : Opens X} {f : U âŸ¶ V} {x} {h} :\n    ((toTopCat X).map f) âŸ¨x, hâŸ© = âŸ¨x, f.le hâŸ© :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.inclusion'_apply","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens â†‘X\nâŠ¢ Eq (â‡‘U.inclusion') Subtype.val","decl":"/-- The inclusion map from an open subset to the whole space, as a morphism in `TopCat`.\n-/\n@[simps (config := .asFn)]\ndef inclusion' {X : TopCat.{u}} (U : Opens X) : (toTopCat X).obj U âŸ¶ X where\n  toFun := _\n  continuous_toFun := continuous_subtype_val\n\n"}
{"name":"TopologicalSpace.Opens.coe_inclusion'","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens â†‘X\nâŠ¢ Eq (â‡‘U.inclusion') Subtype.val","decl":"@[simp]\ntheorem coe_inclusion' {X : TopCat} {U : Opens X} :\n    (inclusion' U : U â†’ X) = Subtype.val := rfl\n\n"}
{"name":"TopologicalSpace.Opens.isOpenEmbedding","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens â†‘X\nâŠ¢ Topology.IsOpenEmbedding â‡‘U.inclusion'","decl":"theorem isOpenEmbedding {X : TopCat.{u}} (U : Opens X) : IsOpenEmbedding (inclusion' U) :=\n  U.2.isOpenEmbedding_subtypeVal\n\n"}
{"name":"TopologicalSpace.Opens.openEmbedding","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens â†‘X\nâŠ¢ Topology.IsOpenEmbedding â‡‘U.inclusion'","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding := isOpenEmbedding\n\n"}
{"name":"TopologicalSpace.Opens.map_coe","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nU : TopologicalSpace.Opens â†‘Y\nâŠ¢ Eq (â†‘((TopologicalSpace.Opens.map f).obj U)) (Set.preimage â‡‘f â†‘U)","decl":"@[simp]\ntheorem map_coe (f : X âŸ¶ Y) (U : Opens Y) : ((map f).obj U : Set X) = f â»Â¹' (U : Set Y) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.map_obj","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nU : Set â†‘Y\np : IsOpen U\nâŠ¢ Eq ((TopologicalSpace.Opens.map f).obj { carrier := U, is_open' := p }) { carrier := Set.preimage (â‡‘f) U, is_open' := â‹¯ }","decl":"@[simp]\ntheorem map_obj (f : X âŸ¶ Y) (U) (p) : (map f).obj âŸ¨U, pâŸ© = âŸ¨f â»Â¹' U, p.preimage f.continuousâŸ© :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.map_homOfLE","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nU V : TopologicalSpace.Opens â†‘Y\ne : LE.le U V\nâŠ¢ Eq ((TopologicalSpace.Opens.map f).map (CategoryTheory.homOfLE e)) (CategoryTheory.homOfLE â‹¯)","decl":"@[simp]\nlemma map_homOfLE (f : X âŸ¶ Y) {U V : Opens Y} (e : U â‰¤ V) :\n    (TopologicalSpace.Opens.map f).map (homOfLE e) =\n      homOfLE (show (Opens.map f).obj U â‰¤ (Opens.map f).obj V from fun _ hx â†¦ e hx) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.map_id_obj","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens â†‘X\nâŠ¢ Eq ((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.id X)).obj U) U","decl":"@[simp]\ntheorem map_id_obj (U : Opens X) : (map (ðŸ™ X)).obj U = U :=\n  let âŸ¨_, _âŸ© := U\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.map_id_obj'","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : Set â†‘X\np : IsOpen U\nâŠ¢ Eq ((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.id X)).obj { carrier := U, is_open' := p }) { carrier := U, is_open' := p }","decl":"@[simp]\ntheorem map_id_obj' (U) (p) : (map (ðŸ™ X)).obj âŸ¨U, pâŸ© = âŸ¨U, pâŸ© :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.map_id_obj_unop","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : Opposite (TopologicalSpace.Opens â†‘X)\nâŠ¢ Eq ((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.id X)).obj (Opposite.unop U)) (Opposite.unop U)","decl":"theorem map_id_obj_unop (U : (Opens X)áµ’áµ–) : (map (ðŸ™ X)).obj (unop U) = unop U := by\n  simp\n\n"}
{"name":"TopologicalSpace.Opens.op_map_id_obj","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : Opposite (TopologicalSpace.Opens â†‘X)\nâŠ¢ Eq ((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.id X)).op.obj U) U","decl":"theorem op_map_id_obj (U : (Opens X)áµ’áµ–) : (map (ðŸ™ X)).op.obj U = U := by simp\n\n"}
{"name":"TopologicalSpace.Opens.map_top","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nâŠ¢ Eq ((TopologicalSpace.Opens.map f).obj Top.top) Top.top","decl":"@[simp]\nlemma map_top (f : X âŸ¶ Y) : (Opens.map f).obj âŠ¤ = âŠ¤ := rfl\n\n"}
{"name":"TopologicalSpace.Opens.map_comp_obj","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nU : TopologicalSpace.Opens â†‘Z\nâŠ¢ Eq ((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.comp f g)).obj U) ((TopologicalSpace.Opens.map f).obj ((TopologicalSpace.Opens.map g).obj U))","decl":"@[simp]\ntheorem map_comp_obj (f : X âŸ¶ Y) (g : Y âŸ¶ Z) (U) :\n    (map (f â‰« g)).obj U = (map f).obj ((map g).obj U) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.map_comp_obj'","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nU : Set â†‘Z\np : IsOpen U\nâŠ¢ Eq ((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.comp f g)).obj { carrier := U, is_open' := p }) ((TopologicalSpace.Opens.map f).obj ((TopologicalSpace.Opens.map g).obj { carrier := U, is_open' := p }))","decl":"@[simp]\ntheorem map_comp_obj' (f : X âŸ¶ Y) (g : Y âŸ¶ Z) (U) (p) :\n    (map (f â‰« g)).obj âŸ¨U, pâŸ© = (map f).obj ((map g).obj âŸ¨U, pâŸ©) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.map_comp_map","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nU V : TopologicalSpace.Opens â†‘Z\ni : Quiver.Hom U V\nâŠ¢ Eq ((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.comp f g)).map i) ((TopologicalSpace.Opens.map f).map ((TopologicalSpace.Opens.map g).map i))","decl":"@[simp]\ntheorem map_comp_map (f : X âŸ¶ Y) (g : Y âŸ¶ Z) {U V} (i : U âŸ¶ V) :\n    (map (f â‰« g)).map i = (map f).map ((map g).map i) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.map_comp_obj_unop","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nU : Opposite (TopologicalSpace.Opens â†‘Z)\nâŠ¢ Eq ((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.comp f g)).obj (Opposite.unop U)) ((TopologicalSpace.Opens.map f).obj ((TopologicalSpace.Opens.map g).obj (Opposite.unop U)))","decl":"@[simp]\ntheorem map_comp_obj_unop (f : X âŸ¶ Y) (g : Y âŸ¶ Z) (U) :\n    (map (f â‰« g)).obj (unop U) = (map f).obj ((map g).obj (unop U)) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.op_map_comp_obj","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nU : Opposite (TopologicalSpace.Opens â†‘Z)\nâŠ¢ Eq ((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.comp f g)).op.obj U) ((TopologicalSpace.Opens.map f).op.obj ((TopologicalSpace.Opens.map g).op.obj U))","decl":"@[simp]\ntheorem op_map_comp_obj (f : X âŸ¶ Y) (g : Y âŸ¶ Z) (U) :\n    (map (f â‰« g)).op.obj U = (map f).op.obj ((map g).op.obj U) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.map_iSup","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nÎ¹ : Type u_1\nU : Î¹ â†’ TopologicalSpace.Opens â†‘Y\nâŠ¢ Eq ((TopologicalSpace.Opens.map f).obj (iSup U)) (iSup (Function.comp (TopologicalSpace.Opens.map f).obj U))","decl":"theorem map_iSup (f : X âŸ¶ Y) {Î¹ : Type*} (U : Î¹ â†’ Opens Y) :\n    (map f).obj (iSup U) = iSup ((map f).obj âˆ˜ U) := by\n  ext1; rw [iSup_def, iSup_def, map_obj]\n  dsimp; rw [Set.preimage_iUnion]\n\n"}
{"name":"TopologicalSpace.Opens.mapId_inv_app","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens â†‘X\nâŠ¢ Eq ((TopologicalSpace.Opens.mapId X).inv.app U) (CategoryTheory.eqToHom â‹¯)","decl":"/-- The functor `Opens X â¥¤ Opens X` given by taking preimages under the identity function\nis naturally isomorphic to the identity functor.\n-/\n@[simps]\ndef mapId : map (ðŸ™ X) â‰… ðŸ­ (Opens X) where\n  hom := { app := fun U => eqToHom (map_id_obj U) }\n  inv := { app := fun U => eqToHom (map_id_obj U).symm }\n\n"}
{"name":"TopologicalSpace.Opens.mapId_hom_app","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens â†‘X\nâŠ¢ Eq ((TopologicalSpace.Opens.mapId X).hom.app U) (CategoryTheory.eqToHom â‹¯)","decl":"/-- The functor `Opens X â¥¤ Opens X` given by taking preimages under the identity function\nis naturally isomorphic to the identity functor.\n-/\n@[simps]\ndef mapId : map (ðŸ™ X) â‰… ðŸ­ (Opens X) where\n  hom := { app := fun U => eqToHom (map_id_obj U) }\n  inv := { app := fun U => eqToHom (map_id_obj U).symm }\n\n"}
{"name":"TopologicalSpace.Opens.map_id_eq","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nâŠ¢ Eq (TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.Functor.id (TopologicalSpace.Opens â†‘X))","decl":"theorem map_id_eq : map (ðŸ™ X) = ðŸ­ (Opens X) := by\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.mapComp_inv_app","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nU : TopologicalSpace.Opens â†‘Z\nâŠ¢ Eq ((TopologicalSpace.Opens.mapComp f g).inv.app U) (CategoryTheory.eqToHom â‹¯)","decl":"/-- The natural isomorphism between taking preimages under `f â‰« g`, and the composite\nof taking preimages under `g`, then preimages under `f`.\n-/\n@[simps]\ndef mapComp (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : map (f â‰« g) â‰… map g â‹™ map f where\n  hom := { app := fun U => eqToHom (map_comp_obj f g U) }\n  inv := { app := fun U => eqToHom (map_comp_obj f g U).symm }\n\n"}
{"name":"TopologicalSpace.Opens.mapComp_hom_app","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nU : TopologicalSpace.Opens â†‘Z\nâŠ¢ Eq ((TopologicalSpace.Opens.mapComp f g).hom.app U) (CategoryTheory.eqToHom â‹¯)","decl":"/-- The natural isomorphism between taking preimages under `f â‰« g`, and the composite\nof taking preimages under `g`, then preimages under `f`.\n-/\n@[simps]\ndef mapComp (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : map (f â‰« g) â‰… map g â‹™ map f where\n  hom := { app := fun U => eqToHom (map_comp_obj f g U) }\n  inv := { app := fun U => eqToHom (map_comp_obj f g U).symm }\n\n"}
{"name":"TopologicalSpace.Opens.map_comp_eq","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y Z : TopCat\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nâŠ¢ Eq (TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.comp f g)) ((TopologicalSpace.Opens.map g).comp (TopologicalSpace.Opens.map f))","decl":"theorem map_comp_eq (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : map (f â‰« g) = map g â‹™ map f :=\n  rfl\n\n-- We could make `f g` implicit here, but it's nice to be able to see when\n-- they are the identity (often!)\n"}
{"name":"TopologicalSpace.Opens.map_eq","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf g : Quiver.Hom X Y\nh : Eq f g\nâŠ¢ Eq (TopologicalSpace.Opens.map f) (TopologicalSpace.Opens.map g)","decl":"theorem map_eq (f g : X âŸ¶ Y) (h : f = g) : map f = map g := by\n  subst h\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.mapIso_refl","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nh : Eq f f\nâŠ¢ Eq (TopologicalSpace.Opens.mapIso f f h) (CategoryTheory.Iso.refl (TopologicalSpace.Opens.map f))","decl":"@[simp]\ntheorem mapIso_refl (f : X âŸ¶ Y) (h) : mapIso f f h = Iso.refl (map _) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.mapIso_hom_app","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf g : Quiver.Hom X Y\nh : Eq f g\nU : TopologicalSpace.Opens â†‘Y\nâŠ¢ Eq ((TopologicalSpace.Opens.mapIso f g h).hom.app U) (CategoryTheory.eqToHom â‹¯)","decl":"@[simp]\ntheorem mapIso_hom_app (f g : X âŸ¶ Y) (h : f = g) (U : Opens Y) :\n    (mapIso f g h).hom.app U = eqToHom (by rw [h]) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.mapIso_inv_app","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf g : Quiver.Hom X Y\nh : Eq f g\nU : TopologicalSpace.Opens â†‘Y\nâŠ¢ Eq ((TopologicalSpace.Opens.mapIso f g h).inv.app U) (CategoryTheory.eqToHom â‹¯)","decl":"@[simp]\ntheorem mapIso_inv_app (f g : X âŸ¶ Y) (h : f = g) (U : Opens Y) :\n    (mapIso f g h).inv.app U = eqToHom (by rw [h]) :=\n  rfl\n\n"}
{"name":"TopologicalSpace.Opens.mapMapIso_functor","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nH : CategoryTheory.Iso X Y\nâŠ¢ Eq (TopologicalSpace.Opens.mapMapIso H).functor (TopologicalSpace.Opens.map H.hom)","decl":"/-- A homeomorphism of spaces gives an equivalence of categories of open sets.\n\nTODO: define `OrderIso.equivalence`, use it.\n-/\n@[simps]\ndef mapMapIso {X Y : TopCat.{u}} (H : X â‰… Y) : Opens Y â‰Œ Opens X where\n  functor := map H.hom\n  inverse := map H.inv\n  unitIso := NatIso.ofComponents fun U => eqToIso (by simp [map, Set.preimage_preimage])\n  counitIso := NatIso.ofComponents fun U => eqToIso (by simp [map, Set.preimage_preimage])\n\n"}
{"name":"TopologicalSpace.Opens.mapMapIso_unitIso","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nH : CategoryTheory.Iso X Y\nâŠ¢ Eq (TopologicalSpace.Opens.mapMapIso H).unitIso (CategoryTheory.NatIso.ofComponents (fun U => CategoryTheory.eqToIso â‹¯) â‹¯)","decl":"/-- A homeomorphism of spaces gives an equivalence of categories of open sets.\n\nTODO: define `OrderIso.equivalence`, use it.\n-/\n@[simps]\ndef mapMapIso {X Y : TopCat.{u}} (H : X â‰… Y) : Opens Y â‰Œ Opens X where\n  functor := map H.hom\n  inverse := map H.inv\n  unitIso := NatIso.ofComponents fun U => eqToIso (by simp [map, Set.preimage_preimage])\n  counitIso := NatIso.ofComponents fun U => eqToIso (by simp [map, Set.preimage_preimage])\n\n"}
{"name":"TopologicalSpace.Opens.mapMapIso_counitIso","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nH : CategoryTheory.Iso X Y\nâŠ¢ Eq (TopologicalSpace.Opens.mapMapIso H).counitIso (CategoryTheory.NatIso.ofComponents (fun U => CategoryTheory.eqToIso â‹¯) â‹¯)","decl":"/-- A homeomorphism of spaces gives an equivalence of categories of open sets.\n\nTODO: define `OrderIso.equivalence`, use it.\n-/\n@[simps]\ndef mapMapIso {X Y : TopCat.{u}} (H : X â‰… Y) : Opens Y â‰Œ Opens X where\n  functor := map H.hom\n  inverse := map H.inv\n  unitIso := NatIso.ofComponents fun U => eqToIso (by simp [map, Set.preimage_preimage])\n  counitIso := NatIso.ofComponents fun U => eqToIso (by simp [map, Set.preimage_preimage])\n\n"}
{"name":"TopologicalSpace.Opens.mapMapIso_inverse","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nH : CategoryTheory.Iso X Y\nâŠ¢ Eq (TopologicalSpace.Opens.mapMapIso H).inverse (TopologicalSpace.Opens.map H.inv)","decl":"/-- A homeomorphism of spaces gives an equivalence of categories of open sets.\n\nTODO: define `OrderIso.equivalence`, use it.\n-/\n@[simps]\ndef mapMapIso {X Y : TopCat.{u}} (H : X â‰… Y) : Opens Y â‰Œ Opens X where\n  functor := map H.hom\n  inverse := map H.inv\n  unitIso := NatIso.ofComponents fun U => eqToIso (by simp [map, Set.preimage_preimage])\n  counitIso := NatIso.ofComponents fun U => eqToIso (by simp [map, Set.preimage_preimage])\n\n"}
{"name":"IsOpenMap.coe_functor_obj","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : IsOpenMap â‡‘f\nU : TopologicalSpace.Opens â†‘X\nâŠ¢ Eq (â†‘(hf.functor.obj U)) (Set.image â‡‘f â†‘U)","decl":"/-- An open map `f : X âŸ¶ Y` induces a functor `Opens X â¥¤ Opens Y`.\n-/\n@[simps obj_coe]\ndef IsOpenMap.functor {X Y : TopCat} {f : X âŸ¶ Y} (hf : IsOpenMap f) : Opens X â¥¤ Opens Y where\n  obj U := âŸ¨f '' (U : Set X), hf (U : Set X) U.2âŸ©\n  map h := âŸ¨âŸ¨Set.image_subset _ h.down.downâŸ©âŸ©\n\n"}
{"name":"IsOpenMap.functorFullOfMono","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : IsOpenMap â‡‘f\nH : CategoryTheory.Mono f\nâŠ¢ hf.functor.Full","decl":"instance IsOpenMap.functorFullOfMono {X Y : TopCat} {f : X âŸ¶ Y} (hf : IsOpenMap f) [H : Mono f] :\n    hf.functor.Full where\n  map_surjective i :=\n    âŸ¨homOfLE fun x hx => by\n      obtain âŸ¨y, hy, eqâŸ© := i.le âŸ¨x, hx, rflâŸ©\n      exact (TopCat.mono_iff_injective f).mp H eq â–¸ hy, rflâŸ©\n\n"}
{"name":"IsOpenMap.functor_faithful","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : IsOpenMap â‡‘f\nâŠ¢ hf.functor.Faithful","decl":"instance IsOpenMap.functor_faithful {X Y : TopCat} {f : X âŸ¶ Y} (hf : IsOpenMap f) :\n    hf.functor.Faithful where\n\n"}
{"name":"Topology.IsOpenEmbedding.functor_obj_injective","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : Topology.IsOpenEmbedding â‡‘f\nâŠ¢ Function.Injective â‹¯.functor.obj","decl":"lemma Topology.IsOpenEmbedding.functor_obj_injective {X Y : TopCat} {f : X âŸ¶ Y}\n    (hf : IsOpenEmbedding f) : Function.Injective hf.isOpenMap.functor.obj :=\n  fun _ _ e â†¦ Opens.ext (Set.image_injective.mpr hf.injective (congr_arg (â†‘Â· : Opens Y â†’ Set Y) e))\n\n"}
{"name":"OpenEmbedding.functor_obj_injective","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : Topology.IsOpenEmbedding â‡‘f\nâŠ¢ Function.Injective â‹¯.functor.obj","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.functor_obj_injective := IsOpenEmbedding.functor_obj_injective\n\n"}
{"name":"Topology.IsInducing.map_functorObj","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : Topology.IsInducing â‡‘f\nU : TopologicalSpace.Opens â†‘X\nâŠ¢ Eq ((TopologicalSpace.Opens.map f).obj (hf.functorObj U)) U","decl":"lemma map_functorObj {X Y : TopCat} {f : X âŸ¶ Y} (hf : IsInducing f)\n    (U : Opens X) :\n    (Opens.map f).obj (hf.functorObj U) = U := by\n  apply le_antisymm\n  Â· rintro x âŸ¨_, âŸ¨s, rflâŸ©, _, âŸ¨rfl : _ = U, rflâŸ©, hx : f x âˆˆ sâŸ©; exact hx\n  Â· intros x hx\n    obtain âŸ¨U, hUâŸ© := U\n    obtain âŸ¨t, ht, rflâŸ© := hf.isOpen_iff.mp hU\n    exact Opens.mem_sSup.mpr âŸ¨âŸ¨_, htâŸ©, rfl, hxâŸ©\n\n"}
{"name":"Topology.IsInducing.mem_functorObj_iff","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : Topology.IsInducing â‡‘f\nU : TopologicalSpace.Opens â†‘X\nx : â†‘X\nâŠ¢ Iff (Membership.mem (hf.functorObj U) (f x)) (Membership.mem U x)","decl":"lemma mem_functorObj_iff {X Y : TopCat} {f : X âŸ¶ Y} (hf : IsInducing f) (U : Opens X)\n    {x : X} : f x âˆˆ hf.functorObj U â†” x âˆˆ U := by\n  conv_rhs => rw [â† hf.map_functorObj U]\n  rfl\n\n"}
{"name":"Topology.IsInducing.le_functorObj_iff","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : Topology.IsInducing â‡‘f\nU : TopologicalSpace.Opens â†‘X\nV : TopologicalSpace.Opens â†‘Y\nâŠ¢ Iff (LE.le V (hf.functorObj U)) (LE.le ((TopologicalSpace.Opens.map f).obj V) U)","decl":"lemma le_functorObj_iff {X Y : TopCat} {f : X âŸ¶ Y} (hf : IsInducing f) {U : Opens X}\n    {V : Opens Y} : V â‰¤ hf.functorObj U â†” (Opens.map f).obj V â‰¤ U := by\n  obtain âŸ¨U, hUâŸ© := U\n  obtain âŸ¨t, ht, rflâŸ© := hf.isOpen_iff.mp hU\n  constructor\n  Â· exact fun i x hx â†¦ (hf.mem_functorObj_iff ((Opens.map f).obj âŸ¨t, htâŸ©)).mp (i hx)\n  Â· intros h x hx\n    refine Opens.mem_sSup.mpr âŸ¨âŸ¨_, V.2.union htâŸ©, Opens.ext ?_, Set.mem_union_left t hxâŸ©\n    dsimp\n    rwa [Set.union_eq_right]\n\n"}
{"name":"Topology.IsInducing.functor_obj","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : Topology.IsInducing â‡‘f\nU : TopologicalSpace.Opens â†‘X\nâŠ¢ Eq (hf.functor.obj U) (hf.functorObj U)","decl":"/-- An inducing map `f : X âŸ¶ Y` induces a functor `Opens X â¥¤ Opens Y`. -/\n@[simps]\ndef functor {X Y : TopCat} {f : X âŸ¶ Y} (hf : IsInducing f) :\n    Opens X â¥¤ Opens Y where\n  obj := hf.functorObj\n  map {U V} h := homOfLE (hf.le_functorObj_iff.mpr ((hf.map_functorObj U).trans_le h.le))\n\n"}
{"name":"Topology.IsInducing.functor_map","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : Topology.IsInducing â‡‘f\nU V : TopologicalSpace.Opens â†‘X\nh : Quiver.Hom U V\nâŠ¢ Eq (hf.functor.map h) (CategoryTheory.homOfLE â‹¯)","decl":"/-- An inducing map `f : X âŸ¶ Y` induces a functor `Opens X â¥¤ Opens Y`. -/\n@[simps]\ndef functor {X Y : TopCat} {f : X âŸ¶ Y} (hf : IsInducing f) :\n    Opens X â¥¤ Opens Y where\n  obj := hf.functorObj\n  map {U V} h := homOfLE (hf.le_functorObj_iff.mpr ((hf.map_functorObj U).trans_le h.le))\n\n"}
{"name":"TopologicalSpace.Opens.isOpenEmbedding_obj_top","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens â†‘X\nâŠ¢ Eq (â‹¯.functor.obj Top.top) U","decl":"@[simp]\ntheorem isOpenEmbedding_obj_top {X : TopCat} (U : Opens X) :\n    U.isOpenEmbedding.isOpenMap.functor.obj âŠ¤ = U := by\n  ext1\n  exact Set.image_univ.trans Subtype.range_coe\n\n"}
{"name":"TopologicalSpace.Opens.openEmbedding_obj_top","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens â†‘X\nâŠ¢ Eq (â‹¯.functor.obj Top.top) U","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_obj_top := isOpenEmbedding_obj_top\n\n"}
{"name":"TopologicalSpace.Opens.inclusion'_map_eq_top","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens â†‘X\nâŠ¢ Eq ((TopologicalSpace.Opens.map U.inclusion').obj U) Top.top","decl":"@[simp]\ntheorem inclusion'_map_eq_top {X : TopCat} (U : Opens X) : (Opens.map U.inclusion').obj U = âŠ¤ := by\n  ext1\n  exact Subtype.coe_preimage_self _\n\n"}
{"name":"TopologicalSpace.Opens.adjunction_counit_app_self","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens â†‘X\nâŠ¢ Eq (â‹¯.adjunction.counit.app U) (CategoryTheory.eqToHom â‹¯)","decl":"@[simp]\ntheorem adjunction_counit_app_self {X : TopCat} (U : Opens X) :\n    U.isOpenEmbedding.isOpenMap.adjunction.counit.app U = eqToHom (by simp) := Subsingleton.elim _ _\n\n"}
{"name":"TopologicalSpace.Opens.inclusion'_top_functor","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nâŠ¢ Eq â‹¯.functor (TopologicalSpace.Opens.map (TopologicalSpace.Opens.inclusionTopIso X).inv)","decl":"theorem inclusion'_top_functor (X : TopCat) :\n    (@Opens.isOpenEmbedding X âŠ¤).isOpenMap.functor = map (inclusionTopIso X).inv := by\n  refine CategoryTheory.Functor.ext ?_ ?_\n  Â· intro U\n    ext x\n    exact âŸ¨fun âŸ¨âŸ¨_, _âŸ©, h, rflâŸ© => h, fun h => âŸ¨âŸ¨x, trivialâŸ©, h, rflâŸ©âŸ©\n  Â· subsingleton\n\n"}
{"name":"TopologicalSpace.Opens.functor_obj_map_obj","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X Y : TopCat\nf : Quiver.Hom X Y\nhf : IsOpenMap â‡‘f\nU : TopologicalSpace.Opens â†‘Y\nâŠ¢ Eq (hf.functor.obj ((TopologicalSpace.Opens.map f).obj U)) (Min.min (hf.functor.obj Top.top) U)","decl":"theorem functor_obj_map_obj {X Y : TopCat} {f : X âŸ¶ Y} (hf : IsOpenMap f) (U : Opens Y) :\n    hf.functor.obj ((Opens.map f).obj U) = hf.functor.obj âŠ¤ âŠ“ U := by\n  ext\n  constructor\n  Â· rintro âŸ¨x, hx, rflâŸ©\n    exact âŸ¨âŸ¨x, trivial, rflâŸ©, hxâŸ©\n  Â· rintro âŸ¨âŸ¨x, -, rflâŸ©, hxâŸ©\n    exact âŸ¨x, hx, rflâŸ©\n\n-- Porting note: added to ease the proof of `functor_map_eq_inf`\n"}
{"name":"TopologicalSpace.Opens.set_range_inclusion'","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens â†‘X\nâŠ¢ Eq (Set.range â‡‘U.inclusion') â†‘U","decl":"lemma set_range_inclusion' {X : TopCat} (U : Opens X) :\n    Set.range (inclusion' U) = (U : Set X) := by\n  ext x\n  constructor\n  Â· rintro âŸ¨x, rflâŸ©\n    exact x.2\n  Â· intro h\n    exact âŸ¨âŸ¨x, hâŸ©, rflâŸ©\n"}
{"name":"TopologicalSpace.Opens.set_range_forget_map_inclusion'","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens â†‘X\nâŠ¢ Eq (Set.range â‡‘U.inclusion') â†‘U","decl":"@[deprecated (since := \"2024-09-07\")] alias set_range_forget_map_inclusion' := set_range_inclusion'\n\n"}
{"name":"TopologicalSpace.Opens.functor_map_eq_inf","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU V : TopologicalSpace.Opens â†‘X\nâŠ¢ Eq (â‹¯.functor.obj ((TopologicalSpace.Opens.map U.inclusion').obj V)) (Min.min V U)","decl":"@[simp]\ntheorem functor_map_eq_inf {X : TopCat} (U V : Opens X) :\n    U.isOpenEmbedding.isOpenMap.functor.obj ((Opens.map U.inclusion').obj V) = V âŠ“ U := by\n  ext1\n  simp only [IsOpenMap.coe_functor_obj, map_coe, coe_inf,\n    Set.image_preimage_eq_inter_range, set_range_inclusion' U]\n\n"}
{"name":"TopologicalSpace.Opens.map_functor_eq'","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X U : TopCat\nf : Quiver.Hom U X\nhf : Topology.IsOpenEmbedding â‡‘f\nV : TopologicalSpace.Opens â†‘U\nâŠ¢ Eq ((TopologicalSpace.Opens.map f).obj (â‹¯.functor.obj V)) V","decl":"theorem map_functor_eq' {X U : TopCat} (f : U âŸ¶ X) (hf : IsOpenEmbedding f) (V) :\n    ((Opens.map f).obj <| hf.isOpenMap.functor.obj V) = V :=\n  Opens.ext <| Set.preimage_image_eq _ hf.injective\n\n"}
{"name":"TopologicalSpace.Opens.map_functor_eq","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens â†‘X\nV : TopologicalSpace.Opens (Subtype fun x => Membership.mem U x)\nâŠ¢ Eq ((TopologicalSpace.Opens.map U.inclusion').obj (â‹¯.functor.obj V)) V","decl":"@[simp]\ntheorem map_functor_eq {X : TopCat} {U : Opens X} (V : Opens U) :\n    ((Opens.map U.inclusion').obj <| U.isOpenEmbedding.isOpenMap.functor.obj V) = V :=\n  TopologicalSpace.Opens.map_functor_eq' _ U.isOpenEmbedding V\n\n"}
{"name":"TopologicalSpace.Opens.adjunction_counit_map_functor","module":"Mathlib.Topology.Category.TopCat.Opens","initialProofState":"X : TopCat\nU : TopologicalSpace.Opens â†‘X\nV : TopologicalSpace.Opens (Subtype fun x => Membership.mem U x)\nâŠ¢ Eq (â‹¯.adjunction.counit.app (â‹¯.functor.obj V)) (CategoryTheory.eqToHom â‹¯)","decl":"@[simp]\ntheorem adjunction_counit_map_functor {X : TopCat} {U : Opens X} (V : Opens U) :\n    U.isOpenEmbedding.isOpenMap.adjunction.counit.app (U.isOpenEmbedding.isOpenMap.functor.obj V) =\n      eqToHom (by dsimp; rw [map_functor_eq V]) := by\n  subsingleton\n\n"}
