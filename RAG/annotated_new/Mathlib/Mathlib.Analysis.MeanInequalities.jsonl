{"name":"Real.geom_mean_le_arith_mean_weighted","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nw z : Œπ ‚Üí Real\nhw : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LE.le 0 (w i)\nhw' : Eq (s.sum fun i => w i) 1\nhz : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LE.le 0 (z i)\n‚ä¢ LE.le (s.prod fun i => HPow.hPow (z i) (w i)) (s.sum fun i => HMul.hMul (w i) (z i))","decl":"/-- **AM-GM inequality**: The geometric mean is less than or equal to the arithmetic mean, weighted\nversion for real-valued nonnegative functions. -/\ntheorem geom_mean_le_arith_mean_weighted (w z : Œπ ‚Üí ‚Ñù) (hw : ‚àÄ i ‚àà s, 0 ‚â§ w i)\n    (hw' : ‚àë i ‚àà s, w i = 1) (hz : ‚àÄ i ‚àà s, 0 ‚â§ z i) :\n    ‚àè i ‚àà s, z i ^ w i ‚â§ ‚àë i ‚àà s, w i * z i := by\n  -- If some number `z i` equals zero and has non-zero weight, then LHS is 0 and RHS is nonnegative.\n  by_cases A : ‚àÉ i ‚àà s, z i = 0 ‚àß w i ‚â† 0\n  ¬∑ rcases A with ‚ü®i, his, hzi, hwi‚ü©\n    rw [prod_eq_zero his]\n    ¬∑ exact sum_nonneg fun j hj => mul_nonneg (hw j hj) (hz j hj)\n    ¬∑ rw [hzi]\n      exact zero_rpow hwi\n  -- If all numbers `z i` with non-zero weight are positive, then we apply Jensen's inequality\n  -- for `exp` and numbers `log (z i)` with weights `w i`.\n  ¬∑ simp only [not_exists, not_and, Ne, Classical.not_not] at A\n    have := convexOn_exp.map_sum_le hw hw' fun i _ => Set.mem_univ <| log (z i)\n    simp only [exp_sum, smul_eq_mul, mul_comm (w _) (log _)] at this\n    convert this using 1 <;> [apply prod_congr rfl;apply sum_congr rfl] <;> intro i hi\n    ¬∑ cases' eq_or_lt_of_le (hz i hi) with hz hz\n      ¬∑ simp [A i hi hz.symm]\n      ¬∑ exact rpow_def_of_pos hz _\n    ¬∑ cases' eq_or_lt_of_le (hz i hi) with hz hz\n      ¬∑ simp [A i hi hz.symm]\n      ¬∑ rw [exp_log hz]\n\n"}
{"name":"Real.geom_mean_le_arith_mean","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u_1\ns : Finset Œπ\nw z : Œπ ‚Üí Real\nhw : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LE.le 0 (w i)\nhw' : LT.lt 0 (s.sum fun i => w i)\nhz : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LE.le 0 (z i)\n‚ä¢ LE.le (HPow.hPow (s.prod fun i => HPow.hPow (z i) (w i)) (Inv.inv (s.sum fun i => w i))) (HDiv.hDiv (s.sum fun i => HMul.hMul (w i) (z i)) (s.sum fun i => w i))","decl":"/-- **AM-GM inequality**: The **geometric mean is less than or equal to the arithmetic mean. -/\ntheorem geom_mean_le_arith_mean {Œπ : Type*} (s : Finset Œπ) (w : Œπ ‚Üí ‚Ñù) (z : Œπ ‚Üí ‚Ñù)\n    (hw : ‚àÄ i ‚àà s, 0 ‚â§ w i) (hw' : 0 < ‚àë i ‚àà s, w i) (hz : ‚àÄ i ‚àà s, 0 ‚â§ z i) :\n    (‚àè i ‚àà s, z i ^ w i) ^ (‚àë i ‚àà s, w i)‚Åª¬π  ‚â§  (‚àë i ‚àà s, w i * z i) / (‚àë i ‚àà s, w i) := by\n  convert geom_mean_le_arith_mean_weighted s (fun i => (w i) / ‚àë i ‚àà s, w i) z ?_ ?_ hz using 2\n  ¬∑ rw [‚Üê finset_prod_rpow _ _ (fun i hi => rpow_nonneg (hz _ hi) _) _]\n    refine Finset.prod_congr rfl (fun _ ih => ?_)\n    rw [div_eq_mul_inv, rpow_mul (hz _ ih)]\n  ¬∑ simp_rw [div_eq_mul_inv, mul_assoc, mul_comm, ‚Üê mul_assoc, ‚Üê Finset.sum_mul, mul_comm]\n  ¬∑ exact fun _ hi => div_nonneg (hw _ hi) (le_of_lt hw')\n  ¬∑ simp_rw [div_eq_mul_inv, ‚Üê Finset.sum_mul]\n    exact mul_inv_cancel‚ÇÄ (by linarith)\n\n"}
{"name":"Real.geom_mean_weighted_of_constant","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nw z : Œπ ‚Üí Real\nx : Real\nhw : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LE.le 0 (w i)\nhw' : Eq (s.sum fun i => w i) 1\nhz : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LE.le 0 (z i)\nhx : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí Ne (w i) 0 ‚Üí Eq (z i) x\n‚ä¢ Eq (s.prod fun i => HPow.hPow (z i) (w i)) x","decl":"theorem geom_mean_weighted_of_constant (w z : Œπ ‚Üí ‚Ñù) (x : ‚Ñù) (hw : ‚àÄ i ‚àà s, 0 ‚â§ w i)\n    (hw' : ‚àë i ‚àà s, w i = 1) (hz : ‚àÄ i ‚àà s, 0 ‚â§ z i) (hx : ‚àÄ i ‚àà s, w i ‚â† 0 ‚Üí z i = x) :\n    ‚àè i ‚àà s, z i ^ w i = x :=\n  calc\n    ‚àè i ‚àà s, z i ^ w i = ‚àè i ‚àà s, x ^ w i := by\n      refine prod_congr rfl fun i hi => ?_\n      rcases eq_or_ne (w i) 0 with h‚ÇÄ | h‚ÇÄ\n      ¬∑ rw [h‚ÇÄ, rpow_zero, rpow_zero]\n      ¬∑ rw [hx i hi h‚ÇÄ]\n    _ = x := by\n      rw [‚Üê rpow_sum_of_nonneg _ hw, hw', rpow_one]\n      have : (‚àë i ‚àà s, w i) ‚â† 0 := by\n        rw [hw']\n        exact one_ne_zero\n      obtain ‚ü®i, his, hi‚ü© := exists_ne_zero_of_sum_ne_zero this\n      rw [‚Üê hx i his hi]\n      exact hz i his\n\n"}
{"name":"Real.arith_mean_weighted_of_constant","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nw z : Œπ ‚Üí Real\nx : Real\nhw' : Eq (s.sum fun i => w i) 1\nhx : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí Ne (w i) 0 ‚Üí Eq (z i) x\n‚ä¢ Eq (s.sum fun i => HMul.hMul (w i) (z i)) x","decl":"theorem arith_mean_weighted_of_constant (w z : Œπ ‚Üí ‚Ñù) (x : ‚Ñù) (hw' : ‚àë i ‚àà s, w i = 1)\n    (hx : ‚àÄ i ‚àà s, w i ‚â† 0 ‚Üí z i = x) : ‚àë i ‚àà s, w i * z i = x :=\n  calc\n    ‚àë i ‚àà s, w i * z i = ‚àë i ‚àà s, w i * x := by\n      refine sum_congr rfl fun i hi => ?_\n      rcases eq_or_ne (w i) 0 with hwi | hwi\n      ¬∑ rw [hwi, zero_mul, zero_mul]\n      ¬∑ rw [hx i hi hwi]\n    _ = x := by rw [‚Üê sum_mul, hw', one_mul]\n\n"}
{"name":"Real.geom_mean_eq_arith_mean_weighted_of_constant","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nw z : Œπ ‚Üí Real\nx : Real\nhw : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LE.le 0 (w i)\nhw' : Eq (s.sum fun i => w i) 1\nhz : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LE.le 0 (z i)\nhx : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí Ne (w i) 0 ‚Üí Eq (z i) x\n‚ä¢ Eq (s.prod fun i => HPow.hPow (z i) (w i)) (s.sum fun i => HMul.hMul (w i) (z i))","decl":"theorem geom_mean_eq_arith_mean_weighted_of_constant (w z : Œπ ‚Üí ‚Ñù) (x : ‚Ñù) (hw : ‚àÄ i ‚àà s, 0 ‚â§ w i)\n    (hw' : ‚àë i ‚àà s, w i = 1) (hz : ‚àÄ i ‚àà s, 0 ‚â§ z i) (hx : ‚àÄ i ‚àà s, w i ‚â† 0 ‚Üí z i = x) :\n    ‚àè i ‚àà s, z i ^ w i = ‚àë i ‚àà s, w i * z i := by\n  rw [geom_mean_weighted_of_constant, arith_mean_weighted_of_constant] <;> assumption\n\n"}
{"name":"Real.geom_mean_eq_arith_mean_weighted_iff'","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nw z : Œπ ‚Üí Real\nhw : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LT.lt 0 (w i)\nhw' : Eq (s.sum fun i => w i) 1\nhz : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LE.le 0 (z i)\n‚ä¢ Iff (Eq (s.prod fun i => HPow.hPow (z i) (w i)) (s.sum fun i => HMul.hMul (w i) (z i))) (‚àÄ (j : Œπ), Membership.mem s j ‚Üí Eq (z j) (s.sum fun i => HMul.hMul (w i) (z i)))","decl":"/-- **AM-GM inequality - equality condition**: This theorem provides the equality condition for the\n*positive* weighted version of the AM-GM inequality for real-valued nonnegative functions. -/\ntheorem geom_mean_eq_arith_mean_weighted_iff' (w z : Œπ ‚Üí ‚Ñù) (hw : ‚àÄ i ‚àà s, 0 < w i)\n    (hw' : ‚àë i ‚àà s, w i = 1) (hz : ‚àÄ i ‚àà s, 0 ‚â§ z i) :\n    ‚àè i ‚àà s, z i ^ w i = ‚àë i ‚àà s, w i * z i ‚Üî ‚àÄ j ‚àà s, z j = ‚àë i ‚àà s, w i * z i := by\n  by_cases A : ‚àÉ i ‚àà s, z i = 0 ‚àß w i ‚â† 0\n  ¬∑ rcases A with ‚ü®i, his, hzi, hwi‚ü©\n    rw [prod_eq_zero his]\n    ¬∑ constructor\n      ¬∑ intro h\n        rw [‚Üê h]\n        intro j hj\n        apply eq_zero_of_ne_zero_of_mul_left_eq_zero (ne_of_lt (hw j hj)).symm\n        apply (sum_eq_zero_iff_of_nonneg ?_).mp h.symm j hj\n        exact fun i hi => (mul_nonneg_iff_of_pos_left (hw i hi)).mpr (hz i hi)\n      ¬∑ intro h\n        convert h i his\n        exact hzi.symm\n    ¬∑ rw [hzi]\n      exact zero_rpow hwi\n  ¬∑ simp only [not_exists, not_and] at A\n    have hz' := fun i h => lt_of_le_of_ne (hz i h) (fun a => (A i h a.symm) (ne_of_gt (hw i h)))\n    have := strictConvexOn_exp.map_sum_eq_iff hw hw' fun i _ => Set.mem_univ <| log (z i)\n    simp only [exp_sum, smul_eq_mul, mul_comm (w _) (log _)] at this\n    convert this using 1\n    ¬∑ apply Eq.congr <;>\n      [apply prod_congr rfl; apply sum_congr rfl] <;>\n      intro i hi <;>\n      simp only [exp_mul, exp_log (hz' i hi)]\n    ¬∑ constructor <;> intro h j hj\n      ¬∑ rw [‚Üê arith_mean_weighted_of_constant s w _ (log (z j)) hw' fun i _ => congrFun rfl]\n        apply sum_congr rfl\n        intro x hx\n        simp only [mul_comm, h j hj, h x hx]\n      ¬∑ rw [‚Üê arith_mean_weighted_of_constant s w _ (z j) hw' fun i _ => congrFun rfl]\n        apply sum_congr rfl\n        intro x hx\n        simp only [log_injOn_pos (hz' j hj) (hz' x hx), h j hj, h x hx]\n\n"}
{"name":"Real.geom_mean_eq_arith_mean_weighted_iff","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nw z : Œπ ‚Üí Real\nhw : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LE.le 0 (w i)\nhw' : Eq (s.sum fun i => w i) 1\nhz : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LE.le 0 (z i)\n‚ä¢ Iff (Eq (s.prod fun i => HPow.hPow (z i) (w i)) (s.sum fun i => HMul.hMul (w i) (z i))) (‚àÄ (j : Œπ), Membership.mem s j ‚Üí Ne (w j) 0 ‚Üí Eq (z j) (s.sum fun i => HMul.hMul (w i) (z i)))","decl":"/-- **AM-GM inequality - equality condition**: This theorem provides the equality condition for the\nweighted version of the AM-GM inequality for real-valued nonnegative functions. -/\ntheorem geom_mean_eq_arith_mean_weighted_iff (w z : Œπ ‚Üí ‚Ñù) (hw : ‚àÄ i ‚àà s, 0 ‚â§ w i)\n    (hw' : ‚àë i ‚àà s, w i = 1) (hz : ‚àÄ i ‚àà s, 0 ‚â§ z i) :\n    ‚àè i ‚àà s, z i ^ w i = ‚àë i ‚àà s, w i * z i ‚Üî ‚àÄ j ‚àà s, w j ‚â† 0 ‚Üí z j = ‚àë i ‚àà s, w i * z i := by\n  have h (i) (_ : i ‚àà s) : w i * z i ‚â† 0 ‚Üí w i ‚â† 0 := by apply left_ne_zero_of_mul\n  have h' (i) (_ : i ‚àà s) : z i ^ w i ‚â† 1 ‚Üí w i ‚â† 0 := by\n    by_contra!\n    obtain ‚ü®h1, h2‚ü© := this\n    simp only [h2, rpow_zero, ne_self_iff_false] at h1\n  rw [‚Üê sum_filter_of_ne h, ‚Üê prod_filter_of_ne h', geom_mean_eq_arith_mean_weighted_iff']\n  ¬∑ simp\n  ¬∑ simp +contextual [(hw _ _).gt_iff_ne]\n  ¬∑ rwa [sum_filter_ne_zero]\n  ¬∑ simp_all only [ne_eq, mul_eq_zero, not_or, not_false_eq_true, and_imp, implies_true, mem_filter]\n\n"}
{"name":"Real.geom_mean_lt_arith_mean_weighted_iff_of_pos","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nw z : Œπ ‚Üí Real\nhw : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LT.lt 0 (w i)\nhw' : Eq (s.sum fun i => w i) 1\nhz : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LE.le 0 (z i)\n‚ä¢ Iff (LT.lt (s.prod fun i => HPow.hPow (z i) (w i)) (s.sum fun i => HMul.hMul (w i) (z i))) (Exists fun j => And (Membership.mem s j) (Exists fun k => And (Membership.mem s k) (Ne (z j) (z k))))","decl":"/-- **AM-GM inequality - strict inequality condition**: This theorem provides the strict inequality\ncondition for the *positive* weighted version of the AM-GM inequality for real-valued nonnegative\nfunctions. -/\ntheorem geom_mean_lt_arith_mean_weighted_iff_of_pos (w z : Œπ ‚Üí ‚Ñù) (hw : ‚àÄ i ‚àà s, 0 < w i)\n    (hw' : ‚àë i ‚àà s, w i = 1) (hz : ‚àÄ i ‚àà s, 0 ‚â§ z i) :\n    ‚àè i ‚àà s, z i ^ w i < ‚àë i ‚àà s, w i * z i ‚Üî ‚àÉ j ‚àà s, ‚àÉ k ‚àà s, z j ‚â† z k:= by\n  constructor\n  ¬∑ intro h\n    by_contra! h_contra\n    rw [(geom_mean_eq_arith_mean_weighted_iff' s w z hw hw' hz).mpr ?_] at h\n    ¬∑ exact (lt_self_iff_false _).mp h\n    ¬∑ intro j hjs\n      rw [‚Üê arith_mean_weighted_of_constant s w (fun _ => z j) (z j) hw' fun _ _ => congrFun rfl]\n      apply sum_congr rfl (fun x a => congrArg (HMul.hMul (w x)) (h_contra j hjs x a))\n  ¬∑ rintro ‚ü®j, hjs, k, hks, hzjk‚ü©\n    have := geom_mean_le_arith_mean_weighted s w z (fun i a => le_of_lt (hw i a)) hw' hz\n    by_contra! h\n    apply le_antisymm this at h\n    apply (geom_mean_eq_arith_mean_weighted_iff' s w z hw hw' hz).mp at h\n    simp only [h j hjs, h k hks, ne_eq, not_true_eq_false] at hzjk\n\n"}
{"name":"NNReal.geom_mean_le_arith_mean_weighted","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nw z : Œπ ‚Üí NNReal\nhw' : Eq (s.sum fun i => w i) 1\n‚ä¢ LE.le (s.prod fun i => HPow.hPow (z i) ‚Üë(w i)) (s.sum fun i => HMul.hMul (w i) (z i))","decl":"/-- **AM-GM inequality**: The geometric mean is less than or equal to the arithmetic mean, weighted\nversion for `NNReal`-valued functions. -/\ntheorem geom_mean_le_arith_mean_weighted (w z : Œπ ‚Üí ‚Ñù‚â•0) (hw' : ‚àë i ‚àà s, w i = 1) :\n    (‚àè i ‚àà s, z i ^ (w i : ‚Ñù)) ‚â§ ‚àë i ‚àà s, w i * z i :=\n  mod_cast\n    Real.geom_mean_le_arith_mean_weighted _ _ _ (fun i _ => (w i).coe_nonneg)\n      (by assumption_mod_cast) fun i _ => (z i).coe_nonneg\n\n"}
{"name":"NNReal.geom_mean_le_arith_mean2_weighted","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"w‚ÇÅ w‚ÇÇ p‚ÇÅ p‚ÇÇ : NNReal\na‚úù : Eq (HAdd.hAdd w‚ÇÅ w‚ÇÇ) 1\n‚ä¢ LE.le (HMul.hMul (HPow.hPow p‚ÇÅ ‚Üëw‚ÇÅ) (HPow.hPow p‚ÇÇ ‚Üëw‚ÇÇ)) (HAdd.hAdd (HMul.hMul w‚ÇÅ p‚ÇÅ) (HMul.hMul w‚ÇÇ p‚ÇÇ))","decl":"/-- **AM-GM inequality**: The geometric mean is less than or equal to the arithmetic mean, weighted\nversion for two `NNReal` numbers. -/\ntheorem geom_mean_le_arith_mean2_weighted (w‚ÇÅ w‚ÇÇ p‚ÇÅ p‚ÇÇ : ‚Ñù‚â•0) :\n    w‚ÇÅ + w‚ÇÇ = 1 ‚Üí p‚ÇÅ ^ (w‚ÇÅ : ‚Ñù) * p‚ÇÇ ^ (w‚ÇÇ : ‚Ñù) ‚â§ w‚ÇÅ * p‚ÇÅ + w‚ÇÇ * p‚ÇÇ := by\n  simpa only [Fin.prod_univ_succ, Fin.sum_univ_succ, Finset.prod_empty, Finset.sum_empty,\n    Finset.univ_eq_empty, Fin.cons_succ, Fin.cons_zero, add_zero, mul_one] using\n    geom_mean_le_arith_mean_weighted univ ![w‚ÇÅ, w‚ÇÇ] ![p‚ÇÅ, p‚ÇÇ]\n\n"}
{"name":"NNReal.geom_mean_le_arith_mean3_weighted","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"w‚ÇÅ w‚ÇÇ w‚ÇÉ p‚ÇÅ p‚ÇÇ p‚ÇÉ : NNReal\na‚úù : Eq (HAdd.hAdd (HAdd.hAdd w‚ÇÅ w‚ÇÇ) w‚ÇÉ) 1\n‚ä¢ LE.le (HMul.hMul (HMul.hMul (HPow.hPow p‚ÇÅ ‚Üëw‚ÇÅ) (HPow.hPow p‚ÇÇ ‚Üëw‚ÇÇ)) (HPow.hPow p‚ÇÉ ‚Üëw‚ÇÉ)) (HAdd.hAdd (HAdd.hAdd (HMul.hMul w‚ÇÅ p‚ÇÅ) (HMul.hMul w‚ÇÇ p‚ÇÇ)) (HMul.hMul w‚ÇÉ p‚ÇÉ))","decl":"theorem geom_mean_le_arith_mean3_weighted (w‚ÇÅ w‚ÇÇ w‚ÇÉ p‚ÇÅ p‚ÇÇ p‚ÇÉ : ‚Ñù‚â•0) :\n    w‚ÇÅ + w‚ÇÇ + w‚ÇÉ = 1 ‚Üí\n      p‚ÇÅ ^ (w‚ÇÅ : ‚Ñù) * p‚ÇÇ ^ (w‚ÇÇ : ‚Ñù) * p‚ÇÉ ^ (w‚ÇÉ : ‚Ñù) ‚â§ w‚ÇÅ * p‚ÇÅ + w‚ÇÇ * p‚ÇÇ + w‚ÇÉ * p‚ÇÉ := by\n  simpa only [Fin.prod_univ_succ, Fin.sum_univ_succ, Finset.prod_empty, Finset.sum_empty,\n    Finset.univ_eq_empty, Fin.cons_succ, Fin.cons_zero, add_zero, mul_one, ‚Üê add_assoc,\n    mul_assoc] using geom_mean_le_arith_mean_weighted univ ![w‚ÇÅ, w‚ÇÇ, w‚ÇÉ] ![p‚ÇÅ, p‚ÇÇ, p‚ÇÉ]\n\n"}
{"name":"NNReal.geom_mean_le_arith_mean4_weighted","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : NNReal\na‚úù : Eq (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd w‚ÇÅ w‚ÇÇ) w‚ÇÉ) w‚ÇÑ) 1\n‚ä¢ LE.le (HMul.hMul (HMul.hMul (HMul.hMul (HPow.hPow p‚ÇÅ ‚Üëw‚ÇÅ) (HPow.hPow p‚ÇÇ ‚Üëw‚ÇÇ)) (HPow.hPow p‚ÇÉ ‚Üëw‚ÇÉ)) (HPow.hPow p‚ÇÑ ‚Üëw‚ÇÑ)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HMul.hMul w‚ÇÅ p‚ÇÅ) (HMul.hMul w‚ÇÇ p‚ÇÇ)) (HMul.hMul w‚ÇÉ p‚ÇÉ)) (HMul.hMul w‚ÇÑ p‚ÇÑ))","decl":"theorem geom_mean_le_arith_mean4_weighted (w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : ‚Ñù‚â•0) :\n    w‚ÇÅ + w‚ÇÇ + w‚ÇÉ + w‚ÇÑ = 1 ‚Üí\n      p‚ÇÅ ^ (w‚ÇÅ : ‚Ñù) * p‚ÇÇ ^ (w‚ÇÇ : ‚Ñù) * p‚ÇÉ ^ (w‚ÇÉ : ‚Ñù) * p‚ÇÑ ^ (w‚ÇÑ : ‚Ñù) ‚â§\n        w‚ÇÅ * p‚ÇÅ + w‚ÇÇ * p‚ÇÇ + w‚ÇÉ * p‚ÇÉ + w‚ÇÑ * p‚ÇÑ := by\n  simpa only [Fin.prod_univ_succ, Fin.sum_univ_succ, Finset.prod_empty, Finset.sum_empty,\n    Finset.univ_eq_empty, Fin.cons_succ, Fin.cons_zero, add_zero, mul_one, ‚Üê add_assoc,\n    mul_assoc] using geom_mean_le_arith_mean_weighted univ ![w‚ÇÅ, w‚ÇÇ, w‚ÇÉ, w‚ÇÑ] ![p‚ÇÅ, p‚ÇÇ, p‚ÇÉ, p‚ÇÑ]\n\n"}
{"name":"Real.geom_mean_le_arith_mean2_weighted","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"w‚ÇÅ w‚ÇÇ p‚ÇÅ p‚ÇÇ : Real\nhw‚ÇÅ : LE.le 0 w‚ÇÅ\nhw‚ÇÇ : LE.le 0 w‚ÇÇ\nhp‚ÇÅ : LE.le 0 p‚ÇÅ\nhp‚ÇÇ : LE.le 0 p‚ÇÇ\nhw : Eq (HAdd.hAdd w‚ÇÅ w‚ÇÇ) 1\n‚ä¢ LE.le (HMul.hMul (HPow.hPow p‚ÇÅ w‚ÇÅ) (HPow.hPow p‚ÇÇ w‚ÇÇ)) (HAdd.hAdd (HMul.hMul w‚ÇÅ p‚ÇÅ) (HMul.hMul w‚ÇÇ p‚ÇÇ))","decl":"theorem geom_mean_le_arith_mean2_weighted {w‚ÇÅ w‚ÇÇ p‚ÇÅ p‚ÇÇ : ‚Ñù} (hw‚ÇÅ : 0 ‚â§ w‚ÇÅ) (hw‚ÇÇ : 0 ‚â§ w‚ÇÇ)\n    (hp‚ÇÅ : 0 ‚â§ p‚ÇÅ) (hp‚ÇÇ : 0 ‚â§ p‚ÇÇ) (hw : w‚ÇÅ + w‚ÇÇ = 1) : p‚ÇÅ ^ w‚ÇÅ * p‚ÇÇ ^ w‚ÇÇ ‚â§ w‚ÇÅ * p‚ÇÅ + w‚ÇÇ * p‚ÇÇ :=\n  NNReal.geom_mean_le_arith_mean2_weighted ‚ü®w‚ÇÅ, hw‚ÇÅ‚ü© ‚ü®w‚ÇÇ, hw‚ÇÇ‚ü© ‚ü®p‚ÇÅ, hp‚ÇÅ‚ü© ‚ü®p‚ÇÇ, hp‚ÇÇ‚ü© <|\n    NNReal.coe_inj.1 <| by assumption\n\n"}
{"name":"Real.geom_mean_le_arith_mean3_weighted","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"w‚ÇÅ w‚ÇÇ w‚ÇÉ p‚ÇÅ p‚ÇÇ p‚ÇÉ : Real\nhw‚ÇÅ : LE.le 0 w‚ÇÅ\nhw‚ÇÇ : LE.le 0 w‚ÇÇ\nhw‚ÇÉ : LE.le 0 w‚ÇÉ\nhp‚ÇÅ : LE.le 0 p‚ÇÅ\nhp‚ÇÇ : LE.le 0 p‚ÇÇ\nhp‚ÇÉ : LE.le 0 p‚ÇÉ\nhw : Eq (HAdd.hAdd (HAdd.hAdd w‚ÇÅ w‚ÇÇ) w‚ÇÉ) 1\n‚ä¢ LE.le (HMul.hMul (HMul.hMul (HPow.hPow p‚ÇÅ w‚ÇÅ) (HPow.hPow p‚ÇÇ w‚ÇÇ)) (HPow.hPow p‚ÇÉ w‚ÇÉ)) (HAdd.hAdd (HAdd.hAdd (HMul.hMul w‚ÇÅ p‚ÇÅ) (HMul.hMul w‚ÇÇ p‚ÇÇ)) (HMul.hMul w‚ÇÉ p‚ÇÉ))","decl":"theorem geom_mean_le_arith_mean3_weighted {w‚ÇÅ w‚ÇÇ w‚ÇÉ p‚ÇÅ p‚ÇÇ p‚ÇÉ : ‚Ñù} (hw‚ÇÅ : 0 ‚â§ w‚ÇÅ) (hw‚ÇÇ : 0 ‚â§ w‚ÇÇ)\n    (hw‚ÇÉ : 0 ‚â§ w‚ÇÉ) (hp‚ÇÅ : 0 ‚â§ p‚ÇÅ) (hp‚ÇÇ : 0 ‚â§ p‚ÇÇ) (hp‚ÇÉ : 0 ‚â§ p‚ÇÉ) (hw : w‚ÇÅ + w‚ÇÇ + w‚ÇÉ = 1) :\n    p‚ÇÅ ^ w‚ÇÅ * p‚ÇÇ ^ w‚ÇÇ * p‚ÇÉ ^ w‚ÇÉ ‚â§ w‚ÇÅ * p‚ÇÅ + w‚ÇÇ * p‚ÇÇ + w‚ÇÉ * p‚ÇÉ :=\n  NNReal.geom_mean_le_arith_mean3_weighted ‚ü®w‚ÇÅ, hw‚ÇÅ‚ü© ‚ü®w‚ÇÇ, hw‚ÇÇ‚ü© ‚ü®w‚ÇÉ, hw‚ÇÉ‚ü© ‚ü®p‚ÇÅ, hp‚ÇÅ‚ü© ‚ü®p‚ÇÇ, hp‚ÇÇ‚ü©\n      ‚ü®p‚ÇÉ, hp‚ÇÉ‚ü© <|\n    NNReal.coe_inj.1 hw\n\n"}
{"name":"Real.geom_mean_le_arith_mean4_weighted","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : Real\nhw‚ÇÅ : LE.le 0 w‚ÇÅ\nhw‚ÇÇ : LE.le 0 w‚ÇÇ\nhw‚ÇÉ : LE.le 0 w‚ÇÉ\nhw‚ÇÑ : LE.le 0 w‚ÇÑ\nhp‚ÇÅ : LE.le 0 p‚ÇÅ\nhp‚ÇÇ : LE.le 0 p‚ÇÇ\nhp‚ÇÉ : LE.le 0 p‚ÇÉ\nhp‚ÇÑ : LE.le 0 p‚ÇÑ\nhw : Eq (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd w‚ÇÅ w‚ÇÇ) w‚ÇÉ) w‚ÇÑ) 1\n‚ä¢ LE.le (HMul.hMul (HMul.hMul (HMul.hMul (HPow.hPow p‚ÇÅ w‚ÇÅ) (HPow.hPow p‚ÇÇ w‚ÇÇ)) (HPow.hPow p‚ÇÉ w‚ÇÉ)) (HPow.hPow p‚ÇÑ w‚ÇÑ)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HMul.hMul w‚ÇÅ p‚ÇÅ) (HMul.hMul w‚ÇÇ p‚ÇÇ)) (HMul.hMul w‚ÇÉ p‚ÇÉ)) (HMul.hMul w‚ÇÑ p‚ÇÑ))","decl":"theorem geom_mean_le_arith_mean4_weighted {w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ p‚ÇÅ p‚ÇÇ p‚ÇÉ p‚ÇÑ : ‚Ñù} (hw‚ÇÅ : 0 ‚â§ w‚ÇÅ)\n    (hw‚ÇÇ : 0 ‚â§ w‚ÇÇ) (hw‚ÇÉ : 0 ‚â§ w‚ÇÉ) (hw‚ÇÑ : 0 ‚â§ w‚ÇÑ) (hp‚ÇÅ : 0 ‚â§ p‚ÇÅ) (hp‚ÇÇ : 0 ‚â§ p‚ÇÇ) (hp‚ÇÉ : 0 ‚â§ p‚ÇÉ)\n    (hp‚ÇÑ : 0 ‚â§ p‚ÇÑ) (hw : w‚ÇÅ + w‚ÇÇ + w‚ÇÉ + w‚ÇÑ = 1) :\n    p‚ÇÅ ^ w‚ÇÅ * p‚ÇÇ ^ w‚ÇÇ * p‚ÇÉ ^ w‚ÇÉ * p‚ÇÑ ^ w‚ÇÑ ‚â§ w‚ÇÅ * p‚ÇÅ + w‚ÇÇ * p‚ÇÇ + w‚ÇÉ * p‚ÇÉ + w‚ÇÑ * p‚ÇÑ :=\n  NNReal.geom_mean_le_arith_mean4_weighted ‚ü®w‚ÇÅ, hw‚ÇÅ‚ü© ‚ü®w‚ÇÇ, hw‚ÇÇ‚ü© ‚ü®w‚ÇÉ, hw‚ÇÉ‚ü© ‚ü®w‚ÇÑ, hw‚ÇÑ‚ü© ‚ü®p‚ÇÅ, hp‚ÇÅ‚ü©\n      ‚ü®p‚ÇÇ, hp‚ÇÇ‚ü© ‚ü®p‚ÇÉ, hp‚ÇÉ‚ü© ‚ü®p‚ÇÑ, hp‚ÇÑ‚ü© <|\n    NNReal.coe_inj.1 <| by assumption\n\n"}
{"name":"Real.harm_mean_le_geom_mean_weighted","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nw z : Œπ ‚Üí Real\nhs : s.Nonempty\nhw : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LT.lt 0 (w i)\nhw' : Eq (s.sum fun i => w i) 1\nhz : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LT.lt 0 (z i)\n‚ä¢ LE.le (Inv.inv (s.sum fun i => HDiv.hDiv (w i) (z i))) (s.prod fun i => HPow.hPow (z i) (w i))","decl":"/-- **HM-GM inequality**: The harmonic mean is less than or equal to the geometric mean, weighted\nversion for real-valued nonnegative functions. -/\ntheorem harm_mean_le_geom_mean_weighted (w z : Œπ ‚Üí ‚Ñù) (hs : s.Nonempty) (hw : ‚àÄ i ‚àà s, 0 < w i)\n    (hw' : ‚àë i ‚àà s, w i = 1) (hz : ‚àÄ i ‚àà s, 0 < z i) :\n    (‚àë i ‚àà s, w i / z i)‚Åª¬π ‚â§ ‚àè i ‚àà s, z i ^ w i  := by\n    have : ‚àè i ‚àà s, (1 / z) i ^ w i ‚â§ ‚àë i ‚àà s, w i * (1 / z) i :=\n      geom_mean_le_arith_mean_weighted s w (1/z) (fun i hi ‚Ü¶ le_of_lt (hw i hi)) hw'\n      (fun i hi ‚Ü¶ one_div_nonneg.2 (le_of_lt (hz i hi)))\n    have p_pos : 0 < ‚àè i ‚àà s, (z i)‚Åª¬π ^ w i :=\n      prod_pos fun i hi => rpow_pos_of_pos (inv_pos.2 (hz i hi)) _\n    have s_pos : 0 < ‚àë i ‚àà s, w i * (z i)‚Åª¬π :=\n      sum_pos (fun i hi => mul_pos (hw i hi) (inv_pos.2 (hz i hi))) hs\n    norm_num at this\n    rw [‚Üê inv_le_inv‚ÇÄ s_pos p_pos] at this\n    apply le_trans this\n    have p_pos‚ÇÇ : 0 < (‚àè i ‚àà s, (z i) ^ w i)‚Åª¬π :=\n      inv_pos.2 (prod_pos fun i hi => rpow_pos_of_pos ((hz i hi)) _ )\n    rw [‚Üê inv_inv (‚àè i ‚àà s, z i ^ w i), inv_le_inv‚ÇÄ p_pos p_pos‚ÇÇ, ‚Üê Finset.prod_inv_distrib]\n    gcongr\n    ¬∑ exact fun i hi ‚Ü¶ inv_nonneg.mpr (Real.rpow_nonneg (le_of_lt (hz i hi)) _)\n    ¬∑ rw [Real.inv_rpow]; apply fun i hi ‚Ü¶ le_of_lt (hz i hi); assumption\n\n\n"}
{"name":"Real.harm_mean_le_geom_mean","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u_1\ns : Finset Œπ\nhs : s.Nonempty\nw z : Œπ ‚Üí Real\nhw : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LT.lt 0 (w i)\nhw' : LT.lt 0 (s.sum fun i => w i)\nhz : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LT.lt 0 (z i)\n‚ä¢ LE.le (HDiv.hDiv (s.sum fun i => w i) (s.sum fun i => HDiv.hDiv (w i) (z i))) (HPow.hPow (s.prod fun i => HPow.hPow (z i) (w i)) (Inv.inv (s.sum fun i => w i)))","decl":"/-- **HM-GM inequality**: The **harmonic mean is less than or equal to the geometric mean. -/\ntheorem harm_mean_le_geom_mean {Œπ : Type*} (s : Finset Œπ) (hs : s.Nonempty) (w : Œπ ‚Üí ‚Ñù)\n    (z : Œπ ‚Üí ‚Ñù) (hw : ‚àÄ i ‚àà s, 0 < w i) (hw' : 0 < ‚àë i ‚àà s, w i) (hz : ‚àÄ i ‚àà s, 0 < z i) :\n    (‚àë i ‚àà s, w i) / (‚àë i ‚àà s, w i / z i) ‚â§ (‚àè i ‚àà s, z i ^ w i) ^ (‚àë i ‚àà s, w i)‚Åª¬π := by\n  have := harm_mean_le_geom_mean_weighted s (fun i => (w i) / ‚àë i ‚àà s, w i) z hs ?_ ?_ hz\n  ¬∑ simp only at this\n    set n := ‚àë i ‚àà s, w i\n    nth_rw 1 [div_eq_mul_inv, (show n = (n‚Åª¬π)‚Åª¬π by norm_num), ‚Üê mul_inv, Finset.mul_sum _ _ n‚Åª¬π]\n    simp_rw [inv_mul_eq_div n ((w _)/(z _)), div_right_comm _ _ n]\n    convert this\n    rw [‚Üê Real.finset_prod_rpow s _ (fun i hi ‚Ü¶ Real.rpow_nonneg (le_of_lt <| hz i hi) _)]\n    refine Finset.prod_congr rfl (fun i hi => ?_)\n    rw [‚Üê Real.rpow_mul (le_of_lt <| hz i hi) (w _) n‚Åª¬π, div_eq_mul_inv (w _) n]\n  ¬∑ exact fun i hi ‚Ü¶ div_pos (hw i hi) hw'\n  ¬∑ simp_rw [div_eq_mul_inv (w _) (‚àë i ‚àà s, w i), ‚Üê Finset.sum_mul _ _ (‚àë i ‚àà s, w i)‚Åª¬π]\n    exact mul_inv_cancel‚ÇÄ hw'.ne'\n\n"}
{"name":"Real.young_inequality_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"a b p q : Real\nha : LE.le 0 a\nhb : LE.le 0 b\nhpq : p.IsConjExponent q\n‚ä¢ LE.le (HMul.hMul a b) (HAdd.hAdd (HDiv.hDiv (HPow.hPow a p) p) (HDiv.hDiv (HPow.hPow b q) q))","decl":"/-- **Young's inequality**, a version for nonnegative real numbers. -/\ntheorem young_inequality_of_nonneg {a b p q : ‚Ñù} (ha : 0 ‚â§ a) (hb : 0 ‚â§ b)\n    (hpq : p.IsConjExponent q) : a * b ‚â§ a ^ p / p + b ^ q / q := by\n  simpa [‚Üê rpow_mul, ha, hb, hpq.ne_zero, hpq.symm.ne_zero, _root_.div_eq_inv_mul] using\n    geom_mean_le_arith_mean2_weighted hpq.inv_nonneg hpq.symm.inv_nonneg\n      (rpow_nonneg ha p) (rpow_nonneg hb q) hpq.inv_add_inv_conj\n\n"}
{"name":"Real.young_inequality","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"a b p q : Real\nhpq : p.IsConjExponent q\n‚ä¢ LE.le (HMul.hMul a b) (HAdd.hAdd (HDiv.hDiv (HPow.hPow (abs a) p) p) (HDiv.hDiv (HPow.hPow (abs b) q) q))","decl":"/-- **Young's inequality**, a version for arbitrary real numbers. -/\ntheorem young_inequality (a b : ‚Ñù) {p q : ‚Ñù} (hpq : p.IsConjExponent q) :\n    a * b ‚â§ |a| ^ p / p + |b| ^ q / q :=\n  calc\n    a * b ‚â§ |a * b| := le_abs_self (a * b)\n    _ = |a| * |b| := abs_mul a b\n    _ ‚â§ |a| ^ p / p + |b| ^ q / q :=\n      Real.young_inequality_of_nonneg (abs_nonneg a) (abs_nonneg b) hpq\n\n"}
{"name":"NNReal.young_inequality","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"a b p q : NNReal\nhpq : p.IsConjExponent q\n‚ä¢ LE.le (HMul.hMul a b) (HAdd.hAdd (HDiv.hDiv (HPow.hPow a ‚Üëp) p) (HDiv.hDiv (HPow.hPow b ‚Üëq) q))","decl":"/-- **Young's inequality**, `‚Ñù‚â•0` version. We use `{p q : ‚Ñù‚â•0}` in order to avoid constructing\nwitnesses of `0 ‚â§ p` and `0 ‚â§ q` for the denominators. -/\ntheorem young_inequality (a b : ‚Ñù‚â•0) {p q : ‚Ñù‚â•0} (hpq : p.IsConjExponent q) :\n    a * b ‚â§ a ^ (p : ‚Ñù) / p + b ^ (q : ‚Ñù) / q :=\n  Real.young_inequality_of_nonneg a.coe_nonneg b.coe_nonneg hpq.coe\n\n"}
{"name":"NNReal.young_inequality_real","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"a b : NNReal\np q : Real\nhpq : p.IsConjExponent q\n‚ä¢ LE.le (HMul.hMul a b) (HAdd.hAdd (HDiv.hDiv (HPow.hPow a p) p.toNNReal) (HDiv.hDiv (HPow.hPow b q) q.toNNReal))","decl":"/-- **Young's inequality**, `‚Ñù‚â•0` version with real conjugate exponents. -/\ntheorem young_inequality_real (a b : ‚Ñù‚â•0) {p q : ‚Ñù} (hpq : p.IsConjExponent q) :\n    a * b ‚â§ a ^ p / Real.toNNReal p + b ^ q / Real.toNNReal q := by\n  simpa [Real.coe_toNNReal, hpq.nonneg, hpq.symm.nonneg] using young_inequality a b hpq.toNNReal\n\n"}
{"name":"ENNReal.young_inequality","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"a b : ENNReal\np q : Real\nhpq : p.IsConjExponent q\n‚ä¢ LE.le (HMul.hMul a b) (HAdd.hAdd (HDiv.hDiv (HPow.hPow a p) (ENNReal.ofReal p)) (HDiv.hDiv (HPow.hPow b q) (ENNReal.ofReal q)))","decl":"/-- **Young's inequality**, `‚Ñù‚â•0‚àû` version with real conjugate exponents. -/\ntheorem young_inequality (a b : ‚Ñù‚â•0‚àû) {p q : ‚Ñù} (hpq : p.IsConjExponent q) :\n    a * b ‚â§ a ^ p / ENNReal.ofReal p + b ^ q / ENNReal.ofReal q := by\n  by_cases h : a = ‚ä§ ‚à® b = ‚ä§\n  ¬∑ refine le_trans le_top (le_of_eq ?_)\n    repeat rw [div_eq_mul_inv]\n    cases' h with h h <;> rw [h] <;> simp [h, hpq.pos, hpq.symm.pos]\n  push_neg at h\n  -- if a ‚â† ‚ä§ and b ‚â† ‚ä§, use the nnreal version: nnreal.young_inequality_real\n  rw [‚Üê coe_toNNReal h.left, ‚Üê coe_toNNReal h.right, ‚Üê coe_mul, ‚Üê coe_rpow_of_nonneg _ hpq.nonneg,\n    ‚Üê coe_rpow_of_nonneg _ hpq.symm.nonneg, ENNReal.ofReal, ENNReal.ofReal, ‚Üê\n    @coe_div (Real.toNNReal p) _ (by simp [hpq.pos]), ‚Üê\n    @coe_div (Real.toNNReal q) _ (by simp [hpq.symm.pos]), ‚Üê coe_add, coe_le_coe]\n  exact NNReal.young_inequality_real a.toNNReal b.toNNReal hpq\n\n"}
{"name":"NNReal.inner_le_Lp_mul_Lq","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nf g : Œπ ‚Üí NNReal\np q : Real\nhpq : p.IsConjExponent q\n‚ä¢ LE.le (s.sum fun i => HMul.hMul (f i) (g i)) (HMul.hMul (HPow.hPow (s.sum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (s.sum fun i => HPow.hPow (g i) q) (HDiv.hDiv 1 q)))","decl":"/-- **H√∂lder inequality**: The scalar product of two functions is bounded by the product of their\n`L^p` and `L^q` norms when `p` and `q` are conjugate exponents. Version for sums over finite sets,\nwith `‚Ñù‚â•0`-valued functions. -/\ntheorem inner_le_Lp_mul_Lq (f g : Œπ ‚Üí ‚Ñù‚â•0) {p q : ‚Ñù} (hpq : p.IsConjExponent q) :\n    ‚àë i ‚àà s, f i * g i ‚â§ (‚àë i ‚àà s, f i ^ p) ^ (1 / p) * (‚àë i ‚àà s, g i ^ q) ^ (1 / q) := by\n  obtain hf | hf := eq_zero_or_pos (‚àë i ‚àà s, f i ^ p)\n  ¬∑ exact inner_le_Lp_mul_Lp_of_norm_eq_zero s f g hpq hf\n  obtain hg | hg := eq_zero_or_pos (‚àë i ‚àà s, g i ^ q)\n  ¬∑ calc\n      ‚àë i ‚àà s, f i * g i = ‚àë i ‚àà s, g i * f i := by\n        congr with i\n        rw [mul_comm]\n      _ ‚â§ (‚àë i ‚àà s, g i ^ q) ^ (1 / q) * (‚àë i ‚àà s, f i ^ p) ^ (1 / p) :=\n        (inner_le_Lp_mul_Lp_of_norm_eq_zero s g f hpq.symm hg)\n      _ = (‚àë i ‚àà s, f i ^ p) ^ (1 / p) * (‚àë i ‚àà s, g i ^ q) ^ (1 / q) := mul_comm _ _\n  let f' i := f i / (‚àë i ‚àà s, f i ^ p) ^ (1 / p)\n  let g' i := g i / (‚àë i ‚àà s, g i ^ q) ^ (1 / q)\n  suffices (‚àë i ‚àà s, f' i * g' i) ‚â§ 1 by\n    simp_rw [f', g', div_mul_div_comm, ‚Üê sum_div] at this\n    rwa [div_le_iff‚ÇÄ, one_mul] at this\n    -- TODO: We are missing a positivity  extension here\n    exact mul_pos (rpow_pos hf) (rpow_pos hg)\n  refine inner_le_Lp_mul_Lp_of_norm_le_one s f' g' hpq (le_of_eq ?_) (le_of_eq ?_)\n  ¬∑ simp_rw [f', div_rpow, ‚Üê sum_div, ‚Üê rpow_mul, one_div, inv_mul_cancel‚ÇÄ hpq.ne_zero, rpow_one,\n      div_self hf.ne']\n  ¬∑ simp_rw [g', div_rpow, ‚Üê sum_div, ‚Üê rpow_mul, one_div, inv_mul_cancel‚ÇÄ hpq.symm.ne_zero,\n      rpow_one, div_self hg.ne']\n\n"}
{"name":"NNReal.inner_le_weight_mul_Lp","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\np : Real\nhp : LE.le 1 p\nw f : Œπ ‚Üí NNReal\n‚ä¢ LE.le (s.sum fun i => HMul.hMul (w i) (f i)) (HMul.hMul (HPow.hPow (s.sum fun i => w i) (HSub.hSub 1 (Inv.inv p))) (HPow.hPow (s.sum fun i => HMul.hMul (w i) (HPow.hPow (f i) p)) (Inv.inv p)))","decl":"/-- **Weighted H√∂lder inequality**. -/\nlemma inner_le_weight_mul_Lp (s : Finset Œπ) {p : ‚Ñù} (hp : 1 ‚â§ p) (w f : Œπ ‚Üí ‚Ñù‚â•0) :\n    ‚àë i ‚àà s, w i * f i ‚â§ (‚àë i ‚àà s, w i) ^ (1 - p‚Åª¬π) * (‚àë i ‚àà s, w i * f i ^ p) ^ p‚Åª¬π := by\n  obtain rfl | hp := hp.eq_or_lt\n  ¬∑ simp\n  calc\n    _ = ‚àë i ‚àà s, w i ^ (1 - p‚Åª¬π) * (w i ^ p‚Åª¬π * f i) := ?_\n    _ ‚â§ (‚àë i ‚àà s, (w i ^ (1 - p‚Åª¬π)) ^ (1 - p‚Åª¬π)‚Åª¬π) ^ (1 / (1 - p‚Åª¬π)‚Åª¬π) *\n          (‚àë i ‚àà s, (w i ^ p‚Åª¬π * f i) ^ p) ^ (1 / p) :=\n        inner_le_Lp_mul_Lq _ _ _ (.symm ‚ü®hp, by simp‚ü©)\n    _ = _ := ?_\n  ¬∑ congr with i\n    rw [‚Üê mul_assoc, ‚Üê rpow_of_add_eq _ one_ne_zero, rpow_one]\n    simp\n  ¬∑ have hp‚ÇÄ : p ‚â† 0 := by positivity\n    have hp‚ÇÅ : 1 - p‚Åª¬π ‚â† 0 := by simp [sub_eq_zero, hp.ne']\n    simp [mul_rpow, div_inv_eq_mul, one_mul, one_div, hp‚ÇÄ, hp‚ÇÅ]\n\n"}
{"name":"NNReal.inner_le_Lp_mul_Lq_tsum","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\nf g : Œπ ‚Üí NNReal\np q : Real\nhpq : p.IsConjExponent q\nhf : Summable fun i => HPow.hPow (f i) p\nhg : Summable fun i => HPow.hPow (g i) q\n‚ä¢ And (Summable fun i => HMul.hMul (f i) (g i)) (LE.le (tsum fun i => HMul.hMul (f i) (g i)) (HMul.hMul (HPow.hPow (tsum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (tsum fun i => HPow.hPow (g i) q) (HDiv.hDiv 1 q))))","decl":"/-- **H√∂lder inequality**: the scalar product of two functions is bounded by the product of their\n`L^p` and `L^q` norms when `p` and `q` are conjugate exponents. A version for `NNReal`-valued\nfunctions. For an alternative version, convenient if the infinite sums are already expressed as\n`p`-th powers, see `inner_le_Lp_mul_Lq_hasSum`. -/\ntheorem inner_le_Lp_mul_Lq_tsum {f g : Œπ ‚Üí ‚Ñù‚â•0} {p q : ‚Ñù} (hpq : p.IsConjExponent q)\n    (hf : Summable fun i => f i ^ p) (hg : Summable fun i => g i ^ q) :\n    (Summable fun i => f i * g i) ‚àß\n      ‚àë' i, f i * g i ‚â§ (‚àë' i, f i ^ p) ^ (1 / p) * (‚àë' i, g i ^ q) ^ (1 / q) := by\n  have H‚ÇÅ : ‚àÄ s : Finset Œπ,\n      ‚àë i ‚àà s, f i * g i ‚â§ (‚àë' i, f i ^ p) ^ (1 / p) * (‚àë' i, g i ^ q) ^ (1 / q) := by\n    intro s\n    refine le_trans (inner_le_Lp_mul_Lq s f g hpq) (mul_le_mul ?_ ?_ bot_le bot_le)\n    ¬∑ rw [NNReal.rpow_le_rpow_iff (one_div_pos.mpr hpq.pos)]\n      exact sum_le_tsum _ (fun _ _ => zero_le _) hf\n    ¬∑ rw [NNReal.rpow_le_rpow_iff (one_div_pos.mpr hpq.symm.pos)]\n      exact sum_le_tsum _ (fun _ _ => zero_le _) hg\n  have bdd : BddAbove (Set.range fun s => ‚àë i ‚àà s, f i * g i) := by\n    refine ‚ü®(‚àë' i, f i ^ p) ^ (1 / p) * (‚àë' i, g i ^ q) ^ (1 / q), ?_‚ü©\n    rintro a ‚ü®s, rfl‚ü©\n    exact H‚ÇÅ s\n  have H‚ÇÇ : Summable _ := (hasSum_of_isLUB _ (isLUB_ciSup bdd)).summable\n  exact ‚ü®H‚ÇÇ, tsum_le_of_sum_le H‚ÇÇ H‚ÇÅ‚ü©\n\n"}
{"name":"NNReal.summable_mul_of_Lp_Lq","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\nf g : Œπ ‚Üí NNReal\np q : Real\nhpq : p.IsConjExponent q\nhf : Summable fun i => HPow.hPow (f i) p\nhg : Summable fun i => HPow.hPow (g i) q\n‚ä¢ Summable fun i => HMul.hMul (f i) (g i)","decl":"theorem summable_mul_of_Lp_Lq {f g : Œπ ‚Üí ‚Ñù‚â•0} {p q : ‚Ñù} (hpq : p.IsConjExponent q)\n    (hf : Summable fun i => f i ^ p) (hg : Summable fun i => g i ^ q) :\n    Summable fun i => f i * g i :=\n  (inner_le_Lp_mul_Lq_tsum hpq hf hg).1\n\n"}
{"name":"NNReal.inner_le_Lp_mul_Lq_tsum'","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\nf g : Œπ ‚Üí NNReal\np q : Real\nhpq : p.IsConjExponent q\nhf : Summable fun i => HPow.hPow (f i) p\nhg : Summable fun i => HPow.hPow (g i) q\n‚ä¢ LE.le (tsum fun i => HMul.hMul (f i) (g i)) (HMul.hMul (HPow.hPow (tsum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (tsum fun i => HPow.hPow (g i) q) (HDiv.hDiv 1 q)))","decl":"theorem inner_le_Lp_mul_Lq_tsum' {f g : Œπ ‚Üí ‚Ñù‚â•0} {p q : ‚Ñù} (hpq : p.IsConjExponent q)\n    (hf : Summable fun i => f i ^ p) (hg : Summable fun i => g i ^ q) :\n    ‚àë' i, f i * g i ‚â§ (‚àë' i, f i ^ p) ^ (1 / p) * (‚àë' i, g i ^ q) ^ (1 / q) :=\n  (inner_le_Lp_mul_Lq_tsum hpq hf hg).2\n\n"}
{"name":"NNReal.inner_le_Lp_mul_Lq_hasSum","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\nf g : Œπ ‚Üí NNReal\nA B : NNReal\np q : Real\nhpq : p.IsConjExponent q\nhf : HasSum (fun i => HPow.hPow (f i) p) (HPow.hPow A p)\nhg : HasSum (fun i => HPow.hPow (g i) q) (HPow.hPow B q)\n‚ä¢ Exists fun C => And (LE.le C (HMul.hMul A B)) (HasSum (fun i => HMul.hMul (f i) (g i)) C)","decl":"/-- **H√∂lder inequality**: the scalar product of two functions is bounded by the product of their\n`L^p` and `L^q` norms when `p` and `q` are conjugate exponents. A version for `NNReal`-valued\nfunctions. For an alternative version, convenient if the infinite sums are not already expressed as\n`p`-th powers, see `inner_le_Lp_mul_Lq_tsum`. -/\ntheorem inner_le_Lp_mul_Lq_hasSum {f g : Œπ ‚Üí ‚Ñù‚â•0} {A B : ‚Ñù‚â•0} {p q : ‚Ñù}\n    (hpq : p.IsConjExponent q) (hf : HasSum (fun i => f i ^ p) (A ^ p))\n    (hg : HasSum (fun i => g i ^ q) (B ^ q)) : ‚àÉ C, C ‚â§ A * B ‚àß HasSum (fun i => f i * g i) C := by\n  obtain ‚ü®H‚ÇÅ, H‚ÇÇ‚ü© := inner_le_Lp_mul_Lq_tsum hpq hf.summable hg.summable\n  have hA : A = (‚àë' i : Œπ, f i ^ p) ^ (1 / p) := by rw [hf.tsum_eq, rpow_inv_rpow_self hpq.ne_zero]\n  have hB : B = (‚àë' i : Œπ, g i ^ q) ^ (1 / q) := by\n    rw [hg.tsum_eq, rpow_inv_rpow_self hpq.symm.ne_zero]\n  refine ‚ü®‚àë' i, f i * g i, ?_, ?_‚ü©\n  ¬∑ simpa [hA, hB] using H‚ÇÇ\n  ¬∑ simpa only [rpow_self_rpow_inv hpq.ne_zero] using H‚ÇÅ.hasSum\n\n"}
{"name":"NNReal.rpow_sum_le_const_mul_sum_rpow","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nf : Œπ ‚Üí NNReal\np : Real\nhp : LE.le 1 p\n‚ä¢ LE.le (HPow.hPow (s.sum fun i => f i) p) (HMul.hMul (HPow.hPow (‚Üës.card) (HSub.hSub p 1)) (s.sum fun i => HPow.hPow (f i) p))","decl":"/-- For `1 ‚â§ p`, the `p`-th power of the sum of `f i` is bounded above by a constant times the\nsum of the `p`-th powers of `f i`. Version for sums over finite sets, with `‚Ñù‚â•0`-valued functions.\n-/\ntheorem rpow_sum_le_const_mul_sum_rpow (f : Œπ ‚Üí ‚Ñù‚â•0) {p : ‚Ñù} (hp : 1 ‚â§ p) :\n    (‚àë i ‚àà s, f i) ^ p ‚â§ (#s : ‚Ñù‚â•0) ^ (p - 1) * ‚àë i ‚àà s, f i ^ p := by\n  cases' eq_or_lt_of_le hp with hp hp\n  ¬∑ simp [‚Üê hp]\n  let q : ‚Ñù := p / (p - 1)\n  have hpq : p.IsConjExponent q := .conjExponent hp\n  have hp‚ÇÅ : 1 / p * p = 1 := one_div_mul_cancel hpq.ne_zero\n  have hq : 1 / q * p = p - 1 := by\n    rw [‚Üê hpq.div_conj_eq_sub_one]\n    ring\n  simpa only [NNReal.mul_rpow, ‚Üê NNReal.rpow_mul, hp‚ÇÅ, hq, one_mul, one_rpow, rpow_one,\n    Pi.one_apply, sum_const, Nat.smul_one_eq_cast] using\n    NNReal.rpow_le_rpow (inner_le_Lp_mul_Lq s 1 f hpq.symm) hpq.nonneg\n\n"}
{"name":"NNReal.isGreatest_Lp","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nf : Œπ ‚Üí NNReal\np q : Real\nhpq : p.IsConjExponent q\n‚ä¢ IsGreatest (Set.image (fun g => s.sum fun i => HMul.hMul (f i) (g i)) (setOf fun g => LE.le (s.sum fun i => HPow.hPow (g i) q) 1)) (HPow.hPow (s.sum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p))","decl":"/-- The `L_p` seminorm of a vector `f` is the greatest value of the inner product\n`‚àë i ‚àà s, f i * g i` over functions `g` of `L_q` seminorm less than or equal to one. -/\ntheorem isGreatest_Lp (f : Œπ ‚Üí ‚Ñù‚â•0) {p q : ‚Ñù} (hpq : p.IsConjExponent q) :\n    IsGreatest ((fun g : Œπ ‚Üí ‚Ñù‚â•0 => ‚àë i ‚àà s, f i * g i) '' { g | ‚àë i ‚àà s, g i ^ q ‚â§ 1 })\n      ((‚àë i ‚àà s, f i ^ p) ^ (1 / p)) := by\n  constructor\n  ¬∑ use fun i => f i ^ p / f i / (‚àë i ‚àà s, f i ^ p) ^ (1 / q)\n    obtain hf | hf := eq_zero_or_pos (‚àë i ‚àà s, f i ^ p)\n    ¬∑ simp [hf, hpq.ne_zero, hpq.symm.ne_zero]\n    ¬∑ have A : p + q - q ‚â† 0 := by simp [hpq.ne_zero]\n      have B : ‚àÄ y : ‚Ñù‚â•0, y * y ^ p / y = y ^ p := by\n        refine fun y => mul_div_cancel_left_of_imp fun h => ?_\n        simp [h, hpq.ne_zero]\n      simp only [Set.mem_setOf_eq, div_rpow, ‚Üê sum_div, ‚Üê rpow_mul,\n        div_mul_cancel‚ÇÄ _ hpq.symm.ne_zero, rpow_one, div_le_iff‚ÇÄ hf, one_mul, hpq.mul_eq_add, ‚Üê\n        rpow_sub' A, add_sub_cancel_right, le_refl, true_and, ‚Üê mul_div_assoc, B]\n      rw [div_eq_iff, ‚Üê rpow_add hf.ne', one_div, one_div, hpq.inv_add_inv_conj, rpow_one]\n      simpa [hpq.symm.ne_zero] using hf.ne'\n  ¬∑ rintro _ ‚ü®g, hg, rfl‚ü©\n    apply le_trans (inner_le_Lp_mul_Lq s f g hpq)\n    simpa only [mul_one] using\n      mul_le_mul_left' (NNReal.rpow_le_one hg (le_of_lt hpq.symm.one_div_pos)) _\n\n"}
{"name":"NNReal.Lp_add_le","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nf g : Œπ ‚Üí NNReal\np : Real\nhp : LE.le 1 p\n‚ä¢ LE.le (HPow.hPow (s.sum fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (HDiv.hDiv 1 p)) (HAdd.hAdd (HPow.hPow (s.sum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (s.sum fun i => HPow.hPow (g i) p) (HDiv.hDiv 1 p)))","decl":"/-- **Minkowski inequality**: the `L_p` seminorm of the sum of two vectors is less than or equal\nto the sum of the `L_p`-seminorms of the summands. A version for `NNReal`-valued functions. -/\ntheorem Lp_add_le (f g : Œπ ‚Üí ‚Ñù‚â•0) {p : ‚Ñù} (hp : 1 ‚â§ p) :\n    (‚àë i ‚àà s, (f i + g i) ^ p) ^ (1 / p) ‚â§\n      (‚àë i ‚àà s, f i ^ p) ^ (1 / p) + (‚àë i ‚àà s, g i ^ p) ^ (1 / p) := by\n  -- The result is trivial when `p = 1`, so we can assume `1 < p`.\n  rcases eq_or_lt_of_le hp with (rfl | hp)\n  ¬∑ simp [Finset.sum_add_distrib]\n  have hpq := Real.IsConjExponent.conjExponent hp\n  have := isGreatest_Lp s (f + g) hpq\n  simp only [Pi.add_apply, add_mul, sum_add_distrib] at this\n  rcases this.1 with ‚ü®œÜ, hœÜ, H‚ü©\n  rw [‚Üê H]\n  exact\n    add_le_add ((isGreatest_Lp s f hpq).2 ‚ü®œÜ, hœÜ, rfl‚ü©) ((isGreatest_Lp s g hpq).2 ‚ü®œÜ, hœÜ, rfl‚ü©)\n\n"}
{"name":"NNReal.Lp_add_le_tsum","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\nf g : Œπ ‚Üí NNReal\np : Real\nhp : LE.le 1 p\nhf : Summable fun i => HPow.hPow (f i) p\nhg : Summable fun i => HPow.hPow (g i) p\n‚ä¢ And (Summable fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (LE.le (HPow.hPow (tsum fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (HDiv.hDiv 1 p)) (HAdd.hAdd (HPow.hPow (tsum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (tsum fun i => HPow.hPow (g i) p) (HDiv.hDiv 1 p))))","decl":"/-- **Minkowski inequality**: the `L_p` seminorm of the infinite sum of two vectors is less than or\nequal to the infinite sum of the `L_p`-seminorms of the summands, if these infinite sums both\nexist. A version for `NNReal`-valued functions. For an alternative version, convenient if the\ninfinite sums are already expressed as `p`-th powers, see `Lp_add_le_hasSum_of_nonneg`. -/\ntheorem Lp_add_le_tsum {f g : Œπ ‚Üí ‚Ñù‚â•0} {p : ‚Ñù} (hp : 1 ‚â§ p) (hf : Summable fun i => f i ^ p)\n    (hg : Summable fun i => g i ^ p) :\n    (Summable fun i => (f i + g i) ^ p) ‚àß\n      (‚àë' i, (f i + g i) ^ p) ^ (1 / p) ‚â§\n        (‚àë' i, f i ^ p) ^ (1 / p) + (‚àë' i, g i ^ p) ^ (1 / p) := by\n  have pos : 0 < p := lt_of_lt_of_le zero_lt_one hp\n  have H‚ÇÅ : ‚àÄ s : Finset Œπ,\n      (‚àë i ‚àà s, (f i + g i) ^ p) ‚â§\n        ((‚àë' i, f i ^ p) ^ (1 / p) + (‚àë' i, g i ^ p) ^ (1 / p)) ^ p := by\n    intro s\n    rw [one_div, ‚Üê NNReal.rpow_inv_le_iff pos, ‚Üê one_div]\n    refine le_trans (Lp_add_le s f g hp) (add_le_add ?_ ?_) <;>\n        rw [NNReal.rpow_le_rpow_iff (one_div_pos.mpr pos)] <;>\n      refine sum_le_tsum _ (fun _ _ => zero_le _) ?_\n    exacts [hf, hg]\n  have bdd : BddAbove (Set.range fun s => ‚àë i ‚àà s, (f i + g i) ^ p) := by\n    refine ‚ü®((‚àë' i, f i ^ p) ^ (1 / p) + (‚àë' i, g i ^ p) ^ (1 / p)) ^ p, ?_‚ü©\n    rintro a ‚ü®s, rfl‚ü©\n    exact H‚ÇÅ s\n  have H‚ÇÇ : Summable _ := (hasSum_of_isLUB _ (isLUB_ciSup bdd)).summable\n  refine ‚ü®H‚ÇÇ, ?_‚ü©\n  rw [one_div, NNReal.rpow_inv_le_iff pos, ‚Üê one_div]\n  exact tsum_le_of_sum_le H‚ÇÇ H‚ÇÅ\n\n"}
{"name":"NNReal.summable_Lp_add","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\nf g : Œπ ‚Üí NNReal\np : Real\nhp : LE.le 1 p\nhf : Summable fun i => HPow.hPow (f i) p\nhg : Summable fun i => HPow.hPow (g i) p\n‚ä¢ Summable fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p","decl":"theorem summable_Lp_add {f g : Œπ ‚Üí ‚Ñù‚â•0} {p : ‚Ñù} (hp : 1 ‚â§ p) (hf : Summable fun i => f i ^ p)\n    (hg : Summable fun i => g i ^ p) : Summable fun i => (f i + g i) ^ p :=\n  (Lp_add_le_tsum hp hf hg).1\n\n"}
{"name":"NNReal.Lp_add_le_tsum'","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\nf g : Œπ ‚Üí NNReal\np : Real\nhp : LE.le 1 p\nhf : Summable fun i => HPow.hPow (f i) p\nhg : Summable fun i => HPow.hPow (g i) p\n‚ä¢ LE.le (HPow.hPow (tsum fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (HDiv.hDiv 1 p)) (HAdd.hAdd (HPow.hPow (tsum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (tsum fun i => HPow.hPow (g i) p) (HDiv.hDiv 1 p)))","decl":"theorem Lp_add_le_tsum' {f g : Œπ ‚Üí ‚Ñù‚â•0} {p : ‚Ñù} (hp : 1 ‚â§ p) (hf : Summable fun i => f i ^ p)\n    (hg : Summable fun i => g i ^ p) :\n    (‚àë' i, (f i + g i) ^ p) ^ (1 / p) ‚â§ (‚àë' i, f i ^ p) ^ (1 / p) + (‚àë' i, g i ^ p) ^ (1 / p) :=\n  (Lp_add_le_tsum hp hf hg).2\n\n"}
{"name":"NNReal.Lp_add_le_hasSum","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\nf g : Œπ ‚Üí NNReal\nA B : NNReal\np : Real\nhp : LE.le 1 p\nhf : HasSum (fun i => HPow.hPow (f i) p) (HPow.hPow A p)\nhg : HasSum (fun i => HPow.hPow (g i) p) (HPow.hPow B p)\n‚ä¢ Exists fun C => And (LE.le C (HAdd.hAdd A B)) (HasSum (fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (HPow.hPow C p))","decl":"/-- **Minkowski inequality**: the `L_p` seminorm of the infinite sum of two vectors is less than or\nequal to the infinite sum of the `L_p`-seminorms of the summands, if these infinite sums both\nexist. A version for `NNReal`-valued functions. For an alternative version, convenient if the\ninfinite sums are not already expressed as `p`-th powers, see `Lp_add_le_tsum_of_nonneg`. -/\ntheorem Lp_add_le_hasSum {f g : Œπ ‚Üí ‚Ñù‚â•0} {A B : ‚Ñù‚â•0} {p : ‚Ñù} (hp : 1 ‚â§ p)\n    (hf : HasSum (fun i => f i ^ p) (A ^ p)) (hg : HasSum (fun i => g i ^ p) (B ^ p)) :\n    ‚àÉ C, C ‚â§ A + B ‚àß HasSum (fun i => (f i + g i) ^ p) (C ^ p) := by\n  have hp' : p ‚â† 0 := (lt_of_lt_of_le zero_lt_one hp).ne'\n  obtain ‚ü®H‚ÇÅ, H‚ÇÇ‚ü© := Lp_add_le_tsum hp hf.summable hg.summable\n  have hA : A = (‚àë' i : Œπ, f i ^ p) ^ (1 / p) := by rw [hf.tsum_eq, rpow_inv_rpow_self hp']\n  have hB : B = (‚àë' i : Œπ, g i ^ p) ^ (1 / p) := by rw [hg.tsum_eq, rpow_inv_rpow_self hp']\n  refine ‚ü®(‚àë' i, (f i + g i) ^ p) ^ (1 / p), ?_, ?_‚ü©\n  ¬∑ simpa [hA, hB] using H‚ÇÇ\n  ¬∑ simpa only [rpow_self_rpow_inv hp'] using H‚ÇÅ.hasSum\n\n"}
{"name":"Real.inner_le_Lp_mul_Lq","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nf g : Œπ ‚Üí Real\np q : Real\nhpq : p.IsConjExponent q\n‚ä¢ LE.le (s.sum fun i => HMul.hMul (f i) (g i)) (HMul.hMul (HPow.hPow (s.sum fun i => HPow.hPow (abs (f i)) p) (HDiv.hDiv 1 p)) (HPow.hPow (s.sum fun i => HPow.hPow (abs (g i)) q) (HDiv.hDiv 1 q)))","decl":"/-- **H√∂lder inequality**: the scalar product of two functions is bounded by the product of their\n`L^p` and `L^q` norms when `p` and `q` are conjugate exponents. Version for sums over finite sets,\nwith real-valued functions. -/\ntheorem inner_le_Lp_mul_Lq (hpq : IsConjExponent p q) :\n    ‚àë i ‚àà s, f i * g i ‚â§ (‚àë i ‚àà s, |f i| ^ p) ^ (1 / p) * (‚àë i ‚àà s, |g i| ^ q) ^ (1 / q) := by\n  have :=\n    NNReal.coe_le_coe.2\n      (NNReal.inner_le_Lp_mul_Lq s (fun i => ‚ü®_, abs_nonneg (f i)‚ü©) (fun i => ‚ü®_, abs_nonneg (g i)‚ü©)\n        hpq)\n  push_cast at this\n  refine le_trans (sum_le_sum fun i _ => ?_) this\n  simp only [‚Üê abs_mul, le_abs_self]\n\n"}
{"name":"Real.rpow_sum_le_const_mul_sum_rpow","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nf : Œπ ‚Üí Real\np : Real\nhp : LE.le 1 p\n‚ä¢ LE.le (HPow.hPow (s.sum fun i => abs (f i)) p) (HMul.hMul (HPow.hPow (‚Üës.card) (HSub.hSub p 1)) (s.sum fun i => HPow.hPow (abs (f i)) p))","decl":"/-- For `1 ‚â§ p`, the `p`-th power of the sum of `f i` is bounded above by a constant times the\nsum of the `p`-th powers of `f i`. Version for sums over finite sets, with `‚Ñù`-valued functions. -/\ntheorem rpow_sum_le_const_mul_sum_rpow (hp : 1 ‚â§ p) :\n    (‚àë i ‚àà s, |f i|) ^ p ‚â§ (#s : ‚Ñù) ^ (p - 1) * ‚àë i ‚àà s, |f i| ^ p := by\n  have :=\n    NNReal.coe_le_coe.2\n      (NNReal.rpow_sum_le_const_mul_sum_rpow s (fun i => ‚ü®_, abs_nonneg (f i)‚ü©) hp)\n  push_cast at this\n  exact this\n\n-- for some reason `exact_mod_cast` can't replace this argument\n"}
{"name":"Real.Lp_add_le","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nf g : Œπ ‚Üí Real\np : Real\nhp : LE.le 1 p\n‚ä¢ LE.le (HPow.hPow (s.sum fun i => HPow.hPow (abs (HAdd.hAdd (f i) (g i))) p) (HDiv.hDiv 1 p)) (HAdd.hAdd (HPow.hPow (s.sum fun i => HPow.hPow (abs (f i)) p) (HDiv.hDiv 1 p)) (HPow.hPow (s.sum fun i => HPow.hPow (abs (g i)) p) (HDiv.hDiv 1 p)))","decl":"/-- **Minkowski inequality**: the `L_p` seminorm of the sum of two vectors is less than or equal\nto the sum of the `L_p`-seminorms of the summands. A version for `Real`-valued functions. -/\ntheorem Lp_add_le (hp : 1 ‚â§ p) :\n    (‚àë i ‚àà s, |f i + g i| ^ p) ^ (1 / p) ‚â§\n      (‚àë i ‚àà s, |f i| ^ p) ^ (1 / p) + (‚àë i ‚àà s, |g i| ^ p) ^ (1 / p) := by\n  have :=\n    NNReal.coe_le_coe.2\n      (NNReal.Lp_add_le s (fun i => ‚ü®_, abs_nonneg (f i)‚ü©) (fun i => ‚ü®_, abs_nonneg (g i)‚ü©) hp)\n  push_cast at this\n  refine le_trans (rpow_le_rpow ?_ (sum_le_sum fun i _ => ?_) ?_) this <;>\n    simp [sum_nonneg, rpow_nonneg, abs_nonneg, le_trans zero_le_one hp, abs_add,\n      rpow_le_rpow]\n\n"}
{"name":"Real.inner_le_Lp_mul_Lq_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nf g : Œπ ‚Üí Real\np q : Real\nhpq : p.IsConjExponent q\nhf : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LE.le 0 (f i)\nhg : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LE.le 0 (g i)\n‚ä¢ LE.le (s.sum fun i => HMul.hMul (f i) (g i)) (HMul.hMul (HPow.hPow (s.sum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (s.sum fun i => HPow.hPow (g i) q) (HDiv.hDiv 1 q)))","decl":"/-- **H√∂lder inequality**: the scalar product of two functions is bounded by the product of their\n`L^p` and `L^q` norms when `p` and `q` are conjugate exponents. Version for sums over finite sets,\nwith real-valued nonnegative functions. -/\ntheorem inner_le_Lp_mul_Lq_of_nonneg (hpq : IsConjExponent p q) (hf : ‚àÄ i ‚àà s, 0 ‚â§ f i)\n    (hg : ‚àÄ i ‚àà s, 0 ‚â§ g i) :\n    ‚àë i ‚àà s, f i * g i ‚â§ (‚àë i ‚àà s, f i ^ p) ^ (1 / p) * (‚àë i ‚àà s, g i ^ q) ^ (1 / q) := by\n  convert inner_le_Lp_mul_Lq s f g hpq using 3 <;> apply sum_congr rfl <;> intro i hi <;>\n    simp only [abs_of_nonneg, hf i hi, hg i hi]\n\n"}
{"name":"Real.inner_le_weight_mul_Lp_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\np : Real\nhp : LE.le 1 p\nw f : Œπ ‚Üí Real\nhw : ‚àÄ (i : Œπ), LE.le 0 (w i)\nhf : ‚àÄ (i : Œπ), LE.le 0 (f i)\n‚ä¢ LE.le (s.sum fun i => HMul.hMul (w i) (f i)) (HMul.hMul (HPow.hPow (s.sum fun i => w i) (HSub.hSub 1 (Inv.inv p))) (HPow.hPow (s.sum fun i => HMul.hMul (w i) (HPow.hPow (f i) p)) (Inv.inv p)))","decl":"/-- **Weighted H√∂lder inequality**. -/\nlemma inner_le_weight_mul_Lp_of_nonneg (s : Finset Œπ) {p : ‚Ñù} (hp : 1 ‚â§ p) (w f : Œπ ‚Üí ‚Ñù)\n    (hw : ‚àÄ i, 0 ‚â§ w i) (hf : ‚àÄ i, 0 ‚â§ f i) :\n    ‚àë i ‚àà s, w i * f i ‚â§ (‚àë i ‚àà s, w i) ^ (1 - p‚Åª¬π) * (‚àë i ‚àà s, w i * f i ^ p) ^ p‚Åª¬π := by\n  lift w to Œπ ‚Üí ‚Ñù‚â•0 using hw\n  lift f to Œπ ‚Üí ‚Ñù‚â•0 using hf\n  beta_reduce at *\n  norm_cast at *\n  exact NNReal.inner_le_weight_mul_Lp _ hp _ _\n\n"}
{"name":"Real.compact_inner_le_weight_mul_Lp_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\np : Real\nhp : LE.le 1 p\nw f : Œπ ‚Üí Real\nhw : ‚àÄ (i : Œπ), LE.le 0 (w i)\nhf : ‚àÄ (i : Œπ), LE.le 0 (f i)\n‚ä¢ LE.le (s.expect fun i => HMul.hMul (w i) (f i)) (HMul.hMul (HPow.hPow (s.expect fun i => w i) (HSub.hSub 1 (Inv.inv p))) (HPow.hPow (s.expect fun i => HMul.hMul (w i) (HPow.hPow (f i) p)) (Inv.inv p)))","decl":"/-- **Weighted H√∂lder inequality** in terms of `Finset.expect`. -/\nlemma compact_inner_le_weight_mul_Lp_of_nonneg (s : Finset Œπ) {p : ‚Ñù} (hp : 1 ‚â§ p) {w f : Œπ ‚Üí ‚Ñù}\n    (hw : ‚àÄ i, 0 ‚â§ w i) (hf : ‚àÄ i, 0 ‚â§ f i) :\n    ùîº i ‚àà s, w i * f i ‚â§ (ùîº i ‚àà s, w i) ^ (1 - p‚Åª¬π) * (ùîº i ‚àà s, w i * f i ^ p) ^ p‚Åª¬π := by\n  simp_rw [expect_eq_sum_div_card]\n  rw [div_rpow, div_rpow, div_mul_div_comm, ‚Üê rpow_add', sub_add_cancel, rpow_one]\n  ¬∑ gcongr\n    exact inner_le_weight_mul_Lp_of_nonneg s hp _ _ hw hf\n  any_goals simp\n  ¬∑ exact sum_nonneg fun i _ ‚Ü¶ by have := hw i; have := hf i; positivity\n  ¬∑ exact sum_nonneg fun i _ ‚Ü¶ by have := hw i; positivity\n\n"}
{"name":"Real.inner_le_Lp_mul_Lq_tsum_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\nf g : Œπ ‚Üí Real\np q : Real\nhpq : p.IsConjExponent q\nhf : ‚àÄ (i : Œπ), LE.le 0 (f i)\nhg : ‚àÄ (i : Œπ), LE.le 0 (g i)\nhf_sum : Summable fun i => HPow.hPow (f i) p\nhg_sum : Summable fun i => HPow.hPow (g i) q\n‚ä¢ And (Summable fun i => HMul.hMul (f i) (g i)) (LE.le (tsum fun i => HMul.hMul (f i) (g i)) (HMul.hMul (HPow.hPow (tsum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (tsum fun i => HPow.hPow (g i) q) (HDiv.hDiv 1 q))))","decl":"/-- **H√∂lder inequality**: the scalar product of two functions is bounded by the product of their\n`L^p` and `L^q` norms when `p` and `q` are conjugate exponents. A version for `‚Ñù`-valued functions.\nFor an alternative version, convenient if the infinite sums are already expressed as `p`-th powers,\nsee `inner_le_Lp_mul_Lq_hasSum_of_nonneg`. -/\ntheorem inner_le_Lp_mul_Lq_tsum_of_nonneg (hpq : p.IsConjExponent q) (hf : ‚àÄ i, 0 ‚â§ f i)\n    (hg : ‚àÄ i, 0 ‚â§ g i) (hf_sum : Summable fun i => f i ^ p) (hg_sum : Summable fun i => g i ^ q) :\n    (Summable fun i => f i * g i) ‚àß\n      ‚àë' i, f i * g i ‚â§ (‚àë' i, f i ^ p) ^ (1 / p) * (‚àë' i, g i ^ q) ^ (1 / q) := by\n  lift f to Œπ ‚Üí ‚Ñù‚â•0 using hf\n  lift g to Œπ ‚Üí ‚Ñù‚â•0 using hg\n  -- After https://github.com/leanprover/lean4/pull/2734, `norm_cast` needs help with beta reduction.\n  beta_reduce at *\n  norm_cast at *\n  exact NNReal.inner_le_Lp_mul_Lq_tsum hpq hf_sum hg_sum\n\n"}
{"name":"Real.summable_mul_of_Lp_Lq_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\nf g : Œπ ‚Üí Real\np q : Real\nhpq : p.IsConjExponent q\nhf : ‚àÄ (i : Œπ), LE.le 0 (f i)\nhg : ‚àÄ (i : Œπ), LE.le 0 (g i)\nhf_sum : Summable fun i => HPow.hPow (f i) p\nhg_sum : Summable fun i => HPow.hPow (g i) q\n‚ä¢ Summable fun i => HMul.hMul (f i) (g i)","decl":"theorem summable_mul_of_Lp_Lq_of_nonneg (hpq : p.IsConjExponent q) (hf : ‚àÄ i, 0 ‚â§ f i)\n    (hg : ‚àÄ i, 0 ‚â§ g i) (hf_sum : Summable fun i => f i ^ p) (hg_sum : Summable fun i => g i ^ q) :\n    Summable fun i => f i * g i :=\n  (inner_le_Lp_mul_Lq_tsum_of_nonneg hpq hf hg hf_sum hg_sum).1\n\n"}
{"name":"Real.inner_le_Lp_mul_Lq_tsum_of_nonneg'","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\nf g : Œπ ‚Üí Real\np q : Real\nhpq : p.IsConjExponent q\nhf : ‚àÄ (i : Œπ), LE.le 0 (f i)\nhg : ‚àÄ (i : Œπ), LE.le 0 (g i)\nhf_sum : Summable fun i => HPow.hPow (f i) p\nhg_sum : Summable fun i => HPow.hPow (g i) q\n‚ä¢ LE.le (tsum fun i => HMul.hMul (f i) (g i)) (HMul.hMul (HPow.hPow (tsum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (tsum fun i => HPow.hPow (g i) q) (HDiv.hDiv 1 q)))","decl":"theorem inner_le_Lp_mul_Lq_tsum_of_nonneg' (hpq : p.IsConjExponent q) (hf : ‚àÄ i, 0 ‚â§ f i)\n    (hg : ‚àÄ i, 0 ‚â§ g i) (hf_sum : Summable fun i => f i ^ p) (hg_sum : Summable fun i => g i ^ q) :\n    ‚àë' i, f i * g i ‚â§ (‚àë' i, f i ^ p) ^ (1 / p) * (‚àë' i, g i ^ q) ^ (1 / q) :=\n  (inner_le_Lp_mul_Lq_tsum_of_nonneg hpq hf hg hf_sum hg_sum).2\n\n"}
{"name":"Real.inner_le_Lp_mul_Lq_hasSum_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\nf g : Œπ ‚Üí Real\np q : Real\nhpq : p.IsConjExponent q\nA B : Real\nhA : LE.le 0 A\nhB : LE.le 0 B\nhf : ‚àÄ (i : Œπ), LE.le 0 (f i)\nhg : ‚àÄ (i : Œπ), LE.le 0 (g i)\nhf_sum : HasSum (fun i => HPow.hPow (f i) p) (HPow.hPow A p)\nhg_sum : HasSum (fun i => HPow.hPow (g i) q) (HPow.hPow B q)\n‚ä¢ Exists fun C => And (LE.le 0 C) (And (LE.le C (HMul.hMul A B)) (HasSum (fun i => HMul.hMul (f i) (g i)) C))","decl":"/-- **H√∂lder inequality**: the scalar product of two functions is bounded by the product of their\n`L^p` and `L^q` norms when `p` and `q` are conjugate exponents. A version for `NNReal`-valued\nfunctions. For an alternative version, convenient if the infinite sums are not already expressed as\n`p`-th powers, see `inner_le_Lp_mul_Lq_tsum_of_nonneg`. -/\ntheorem inner_le_Lp_mul_Lq_hasSum_of_nonneg (hpq : p.IsConjExponent q) {A B : ‚Ñù} (hA : 0 ‚â§ A)\n    (hB : 0 ‚â§ B) (hf : ‚àÄ i, 0 ‚â§ f i) (hg : ‚àÄ i, 0 ‚â§ g i)\n    (hf_sum : HasSum (fun i => f i ^ p) (A ^ p)) (hg_sum : HasSum (fun i => g i ^ q) (B ^ q)) :\n    ‚àÉ C : ‚Ñù, 0 ‚â§ C ‚àß C ‚â§ A * B ‚àß HasSum (fun i => f i * g i) C := by\n  lift f to Œπ ‚Üí ‚Ñù‚â•0 using hf\n  lift g to Œπ ‚Üí ‚Ñù‚â•0 using hg\n  lift A to ‚Ñù‚â•0 using hA\n  lift B to ‚Ñù‚â•0 using hB\n  -- After https://github.com/leanprover/lean4/pull/2734, `norm_cast` needs help with beta reduction.\n  beta_reduce at *\n  norm_cast at hf_sum hg_sum\n  obtain ‚ü®C, hC, H‚ü© := NNReal.inner_le_Lp_mul_Lq_hasSum hpq hf_sum hg_sum\n  refine ‚ü®C, C.prop, hC, ?_‚ü©\n  norm_cast\n\n"}
{"name":"Real.rpow_sum_le_const_mul_sum_rpow_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nf : Œπ ‚Üí Real\np : Real\nhp : LE.le 1 p\nhf : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LE.le 0 (f i)\n‚ä¢ LE.le (HPow.hPow (s.sum fun i => f i) p) (HMul.hMul (HPow.hPow (‚Üës.card) (HSub.hSub p 1)) (s.sum fun i => HPow.hPow (f i) p))","decl":"/-- For `1 ‚â§ p`, the `p`-th power of the sum of `f i` is bounded above by a constant times the\nsum of the `p`-th powers of `f i`. Version for sums over finite sets, with nonnegative `‚Ñù`-valued\nfunctions. -/\ntheorem rpow_sum_le_const_mul_sum_rpow_of_nonneg (hp : 1 ‚â§ p) (hf : ‚àÄ i ‚àà s, 0 ‚â§ f i) :\n    (‚àë i ‚àà s, f i) ^ p ‚â§ (#s : ‚Ñù) ^ (p - 1) * ‚àë i ‚àà s, f i ^ p := by\n  convert rpow_sum_le_const_mul_sum_rpow s f hp using 2 <;> apply sum_congr rfl <;> intro i hi <;>\n    simp only [abs_of_nonneg, hf i hi]\n\n"}
{"name":"Real.Lp_add_le_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nf g : Œπ ‚Üí Real\np : Real\nhp : LE.le 1 p\nhf : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LE.le 0 (f i)\nhg : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí LE.le 0 (g i)\n‚ä¢ LE.le (HPow.hPow (s.sum fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (HDiv.hDiv 1 p)) (HAdd.hAdd (HPow.hPow (s.sum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (s.sum fun i => HPow.hPow (g i) p) (HDiv.hDiv 1 p)))","decl":"/-- **Minkowski inequality**: the `L_p` seminorm of the sum of two vectors is less than or equal\nto the sum of the `L_p`-seminorms of the summands. A version for `‚Ñù`-valued nonnegative\nfunctions. -/\ntheorem Lp_add_le_of_nonneg (hp : 1 ‚â§ p) (hf : ‚àÄ i ‚àà s, 0 ‚â§ f i) (hg : ‚àÄ i ‚àà s, 0 ‚â§ g i) :\n    (‚àë i ‚àà s, (f i + g i) ^ p) ^ (1 / p) ‚â§\n      (‚àë i ‚àà s, f i ^ p) ^ (1 / p) + (‚àë i ‚àà s, g i ^ p) ^ (1 / p) := by\n  convert Lp_add_le s f g hp using 2 <;> [skip;congr 1;congr 1] <;> apply sum_congr rfl <;>\n      intro i hi <;>\n    simp only [abs_of_nonneg, hf i hi, hg i hi, add_nonneg]\n\n"}
{"name":"Real.Lp_add_le_tsum_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\nf g : Œπ ‚Üí Real\np : Real\nhp : LE.le 1 p\nhf : ‚àÄ (i : Œπ), LE.le 0 (f i)\nhg : ‚àÄ (i : Œπ), LE.le 0 (g i)\nhf_sum : Summable fun i => HPow.hPow (f i) p\nhg_sum : Summable fun i => HPow.hPow (g i) p\n‚ä¢ And (Summable fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (LE.le (HPow.hPow (tsum fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (HDiv.hDiv 1 p)) (HAdd.hAdd (HPow.hPow (tsum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (tsum fun i => HPow.hPow (g i) p) (HDiv.hDiv 1 p))))","decl":"/-- **Minkowski inequality**: the `L_p` seminorm of the infinite sum of two vectors is less than or\nequal to the infinite sum of the `L_p`-seminorms of the summands, if these infinite sums both\nexist. A version for `‚Ñù`-valued functions. For an alternative version, convenient if the infinite\nsums are already expressed as `p`-th powers, see `Lp_add_le_hasSum_of_nonneg`. -/\ntheorem Lp_add_le_tsum_of_nonneg (hp : 1 ‚â§ p) (hf : ‚àÄ i, 0 ‚â§ f i) (hg : ‚àÄ i, 0 ‚â§ g i)\n    (hf_sum : Summable fun i => f i ^ p) (hg_sum : Summable fun i => g i ^ p) :\n    (Summable fun i => (f i + g i) ^ p) ‚àß\n      (‚àë' i, (f i + g i) ^ p) ^ (1 / p) ‚â§\n        (‚àë' i, f i ^ p) ^ (1 / p) + (‚àë' i, g i ^ p) ^ (1 / p) := by\n  lift f to Œπ ‚Üí ‚Ñù‚â•0 using hf\n  lift g to Œπ ‚Üí ‚Ñù‚â•0 using hg\n  -- After https://github.com/leanprover/lean4/pull/2734, `norm_cast` needs help with beta reduction.\n  beta_reduce at *\n  norm_cast0 at *\n  exact NNReal.Lp_add_le_tsum hp hf_sum hg_sum\n\n"}
{"name":"Real.summable_Lp_add_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\nf g : Œπ ‚Üí Real\np : Real\nhp : LE.le 1 p\nhf : ‚àÄ (i : Œπ), LE.le 0 (f i)\nhg : ‚àÄ (i : Œπ), LE.le 0 (g i)\nhf_sum : Summable fun i => HPow.hPow (f i) p\nhg_sum : Summable fun i => HPow.hPow (g i) p\n‚ä¢ Summable fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p","decl":"theorem summable_Lp_add_of_nonneg (hp : 1 ‚â§ p) (hf : ‚àÄ i, 0 ‚â§ f i) (hg : ‚àÄ i, 0 ‚â§ g i)\n    (hf_sum : Summable fun i => f i ^ p) (hg_sum : Summable fun i => g i ^ p) :\n    Summable fun i => (f i + g i) ^ p :=\n  (Lp_add_le_tsum_of_nonneg hp hf hg hf_sum hg_sum).1\n\n"}
{"name":"Real.Lp_add_le_tsum_of_nonneg'","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\nf g : Œπ ‚Üí Real\np : Real\nhp : LE.le 1 p\nhf : ‚àÄ (i : Œπ), LE.le 0 (f i)\nhg : ‚àÄ (i : Œπ), LE.le 0 (g i)\nhf_sum : Summable fun i => HPow.hPow (f i) p\nhg_sum : Summable fun i => HPow.hPow (g i) p\n‚ä¢ LE.le (HPow.hPow (tsum fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (HDiv.hDiv 1 p)) (HAdd.hAdd (HPow.hPow (tsum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (tsum fun i => HPow.hPow (g i) p) (HDiv.hDiv 1 p)))","decl":"theorem Lp_add_le_tsum_of_nonneg' (hp : 1 ‚â§ p) (hf : ‚àÄ i, 0 ‚â§ f i) (hg : ‚àÄ i, 0 ‚â§ g i)\n    (hf_sum : Summable fun i => f i ^ p) (hg_sum : Summable fun i => g i ^ p) :\n    (‚àë' i, (f i + g i) ^ p) ^ (1 / p) ‚â§ (‚àë' i, f i ^ p) ^ (1 / p) + (‚àë' i, g i ^ p) ^ (1 / p) :=\n  (Lp_add_le_tsum_of_nonneg hp hf hg hf_sum hg_sum).2\n\n"}
{"name":"Real.Lp_add_le_hasSum_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\nf g : Œπ ‚Üí Real\np : Real\nhp : LE.le 1 p\nhf : ‚àÄ (i : Œπ), LE.le 0 (f i)\nhg : ‚àÄ (i : Œπ), LE.le 0 (g i)\nA B : Real\nhA : LE.le 0 A\nhB : LE.le 0 B\nhfA : HasSum (fun i => HPow.hPow (f i) p) (HPow.hPow A p)\nhgB : HasSum (fun i => HPow.hPow (g i) p) (HPow.hPow B p)\n‚ä¢ Exists fun C => And (LE.le 0 C) (And (LE.le C (HAdd.hAdd A B)) (HasSum (fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (HPow.hPow C p)))","decl":"/-- **Minkowski inequality**: the `L_p` seminorm of the infinite sum of two vectors is less than or\nequal to the infinite sum of the `L_p`-seminorms of the summands, if these infinite sums both\nexist. A version for `‚Ñù`-valued functions. For an alternative version, convenient if the infinite\nsums are not already expressed as `p`-th powers, see `Lp_add_le_tsum_of_nonneg`. -/\ntheorem Lp_add_le_hasSum_of_nonneg (hp : 1 ‚â§ p) (hf : ‚àÄ i, 0 ‚â§ f i) (hg : ‚àÄ i, 0 ‚â§ g i) {A B : ‚Ñù}\n    (hA : 0 ‚â§ A) (hB : 0 ‚â§ B) (hfA : HasSum (fun i => f i ^ p) (A ^ p))\n    (hgB : HasSum (fun i => g i ^ p) (B ^ p)) :\n    ‚àÉ C, 0 ‚â§ C ‚àß C ‚â§ A + B ‚àß HasSum (fun i => (f i + g i) ^ p) (C ^ p) := by\n  lift f to Œπ ‚Üí ‚Ñù‚â•0 using hf\n  lift g to Œπ ‚Üí ‚Ñù‚â•0 using hg\n  lift A to ‚Ñù‚â•0 using hA\n  lift B to ‚Ñù‚â•0 using hB\n  -- After https://github.com/leanprover/lean4/pull/2734, `norm_cast` needs help with beta reduction.\n  beta_reduce at hfA hgB\n  norm_cast at hfA hgB\n  obtain ‚ü®C, hC‚ÇÅ, hC‚ÇÇ‚ü© := NNReal.Lp_add_le_hasSum hp hfA hgB\n  use C\n  -- After https://github.com/leanprover/lean4/pull/2734, `norm_cast` needs help with beta reduction.\n  beta_reduce\n  norm_cast\n  exact ‚ü®zero_le _, hC‚ÇÅ, hC‚ÇÇ‚ü©\n\n"}
{"name":"ENNReal.inner_le_Lp_mul_Lq","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nf g : Œπ ‚Üí ENNReal\np q : Real\nhpq : p.IsConjExponent q\n‚ä¢ LE.le (s.sum fun i => HMul.hMul (f i) (g i)) (HMul.hMul (HPow.hPow (s.sum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (s.sum fun i => HPow.hPow (g i) q) (HDiv.hDiv 1 q)))","decl":"/-- **H√∂lder inequality**: the scalar product of two functions is bounded by the product of their\n`L^p` and `L^q` norms when `p` and `q` are conjugate exponents. Version for sums over finite sets,\nwith `‚Ñù‚â•0‚àû`-valued functions. -/\ntheorem inner_le_Lp_mul_Lq (hpq : p.IsConjExponent q) :\n    ‚àë i ‚àà s, f i * g i ‚â§ (‚àë i ‚àà s, f i ^ p) ^ (1 / p) * (‚àë i ‚àà s, g i ^ q) ^ (1 / q) := by\n  by_cases H : (‚àë i ‚àà s, f i ^ p) ^ (1 / p) = 0 ‚à® (‚àë i ‚àà s, g i ^ q) ^ (1 / q) = 0\n  ¬∑ replace H : (‚àÄ i ‚àà s, f i = 0) ‚à® ‚àÄ i ‚àà s, g i = 0 := by\n      simpa [ENNReal.rpow_eq_zero_iff, hpq.pos, hpq.symm.pos, asymm hpq.pos, asymm hpq.symm.pos,\n        sum_eq_zero_iff_of_nonneg] using H\n    have : ‚àÄ i ‚àà s, f i * g i = 0 := fun i hi => by cases' H with H H <;> simp [H i hi]\n    simp [sum_eq_zero this]\n  push_neg at H\n  by_cases H' : (‚àë i ‚àà s, f i ^ p) ^ (1 / p) = ‚ä§ ‚à® (‚àë i ‚àà s, g i ^ q) ^ (1 / q) = ‚ä§\n  ¬∑ cases' H' with H' H' <;> simp [H', -one_div, -sum_eq_zero_iff, -rpow_eq_zero_iff, H]\n  replace H' : (‚àÄ i ‚àà s, f i ‚â† ‚ä§) ‚àß ‚àÄ i ‚àà s, g i ‚â† ‚ä§ := by\n    simpa [ENNReal.rpow_eq_top_iff, asymm hpq.pos, asymm hpq.symm.pos, hpq.pos, hpq.symm.pos,\n      ENNReal.sum_eq_top, not_or] using H'\n  have := ENNReal.coe_le_coe.2 (@NNReal.inner_le_Lp_mul_Lq _ s (fun i => ENNReal.toNNReal (f i))\n    (fun i => ENNReal.toNNReal (g i)) _ _ hpq)\n  simp [ENNReal.coe_rpow_of_nonneg, hpq.pos.le, hpq.one_div_pos.le, hpq.symm.pos.le,\n    hpq.symm.one_div_pos.le] at this\n  convert this using 1 <;> [skip; congr 2] <;> [skip; skip; simp; skip; simp] <;>\n    ¬∑ refine Finset.sum_congr rfl fun i hi => ?_\n      simp [H'.1 i hi, H'.2 i hi, -WithZero.coe_mul]\n\n"}
{"name":"ENNReal.inner_le_weight_mul_Lp_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\np : Real\nhp : LE.le 1 p\nw f : Œπ ‚Üí ENNReal\n‚ä¢ LE.le (s.sum fun i => HMul.hMul (w i) (f i)) (HMul.hMul (HPow.hPow (s.sum fun i => w i) (HSub.hSub 1 (Inv.inv p))) (HPow.hPow (s.sum fun i => HMul.hMul (w i) (HPow.hPow (f i) p)) (Inv.inv p)))","decl":"/-- **Weighted H√∂lder inequality**. -/\nlemma inner_le_weight_mul_Lp_of_nonneg (s : Finset Œπ) {p : ‚Ñù} (hp : 1 ‚â§ p) (w f : Œπ ‚Üí ‚Ñù‚â•0‚àû) :\n    ‚àë i ‚àà s, w i * f i ‚â§ (‚àë i ‚àà s, w i) ^ (1 - p‚Åª¬π) * (‚àë i ‚àà s, w i * f i ^ p) ^ p‚Åª¬π := by\n  obtain rfl | hp := hp.eq_or_lt\n  ¬∑ simp\n  have hp‚ÇÄ : 0 < p := by positivity\n  have hp‚ÇÅ : p‚Åª¬π < 1 := inv_lt_one_of_one_lt‚ÇÄ hp\n  by_cases H : (‚àë i ‚àà s, w i) ^ (1 - p‚Åª¬π) = 0 ‚à® (‚àë i ‚àà s, w i * f i ^ p) ^ p‚Åª¬π = 0\n  ¬∑ replace H : (‚àÄ i ‚àà s, w i = 0) ‚à® ‚àÄ i ‚àà s, w i = 0 ‚à® f i = 0 := by\n      simpa [hp‚ÇÄ, hp‚ÇÅ, hp‚ÇÄ.not_lt, hp‚ÇÅ.not_lt, sum_eq_zero_iff_of_nonneg] using H\n    have (i) (hi : i ‚àà s) : w i * f i = 0 := by cases' H with H H <;> simp [H i hi]\n    simp [sum_eq_zero this]\n  push_neg at H\n  by_cases H' : (‚àë i ‚àà s, w i) ^ (1 - p‚Åª¬π) = ‚ä§ ‚à® (‚àë i ‚àà s, w i * f i ^ p) ^ p‚Åª¬π = ‚ä§\n  ¬∑ cases' H' with H' H' <;> simp [H', -one_div, -sum_eq_zero_iff, -rpow_eq_zero_iff, H]\n  replace H' : (‚àÄ i ‚àà s, w i ‚â† ‚ä§) ‚àß ‚àÄ i ‚àà s, w i * f i ^ p ‚â† ‚ä§ := by\n    simpa [rpow_eq_top_iff,hp‚ÇÄ, hp‚ÇÅ, hp‚ÇÄ.not_lt, hp‚ÇÅ.not_lt, sum_eq_top, not_or] using H'\n  have := coe_le_coe.2 <| NNReal.inner_le_weight_mul_Lp s hp.le (fun i ‚Ü¶ ENNReal.toNNReal (w i))\n    fun i ‚Ü¶ ENNReal.toNNReal (f i)\n  rw [coe_mul] at this\n  simp_rw [coe_rpow_of_nonneg _ <| inv_nonneg.2 hp‚ÇÄ.le, coe_finset_sum, ‚Üê ENNReal.toNNReal_rpow,\n    ‚Üê ENNReal.toNNReal_mul, sum_congr rfl fun i hi ‚Ü¶ coe_toNNReal (H'.2 i hi)] at this\n  simp [ENNReal.coe_rpow_of_nonneg, hp‚ÇÄ.le, hp‚ÇÅ.le] at this\n  convert this using 2 with i hi\n  ¬∑ obtain hw | hw := eq_or_ne (w i) 0\n    ¬∑ simp [hw]\n    rw [coe_toNNReal (H'.1 _ hi), coe_toNNReal]\n    simpa [mul_eq_top, hw, hp‚ÇÄ, hp‚ÇÄ.not_lt, H'.1 _ hi] using H'.2 _ hi\n  ¬∑ convert rfl with i hi\n    exact coe_toNNReal (H'.1 _ hi)\n\n"}
{"name":"ENNReal.rpow_sum_le_const_mul_sum_rpow","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nf : Œπ ‚Üí ENNReal\np : Real\nhp : LE.le 1 p\n‚ä¢ LE.le (HPow.hPow (s.sum fun i => f i) p) (HMul.hMul (HPow.hPow (‚Üës.card) (HSub.hSub p 1)) (s.sum fun i => HPow.hPow (f i) p))","decl":"/-- For `1 ‚â§ p`, the `p`-th power of the sum of `f i` is bounded above by a constant times the\nsum of the `p`-th powers of `f i`. Version for sums over finite sets, with `‚Ñù‚â•0‚àû`-valued functions.\n-/\ntheorem rpow_sum_le_const_mul_sum_rpow (hp : 1 ‚â§ p) :\n    (‚àë i ‚àà s, f i) ^ p ‚â§ (card s : ‚Ñù‚â•0‚àû) ^ (p - 1) * ‚àë i ‚àà s, f i ^ p := by\n  cases' eq_or_lt_of_le hp with hp hp\n  ¬∑ simp [‚Üê hp]\n  let q : ‚Ñù := p / (p - 1)\n  have hpq : p.IsConjExponent q := .conjExponent hp\n  have hp‚ÇÅ : 1 / p * p = 1 := one_div_mul_cancel hpq.ne_zero\n  have hq : 1 / q * p = p - 1 := by\n    rw [‚Üê hpq.div_conj_eq_sub_one]\n    ring\n  simpa only [ENNReal.mul_rpow_of_nonneg _ _ hpq.nonneg, ‚Üê ENNReal.rpow_mul, hp‚ÇÅ, hq, coe_one,\n    one_mul, one_rpow, rpow_one, Pi.one_apply, sum_const, Nat.smul_one_eq_cast] using\n    ENNReal.rpow_le_rpow (inner_le_Lp_mul_Lq s 1 f hpq.symm) hpq.nonneg\n\n"}
{"name":"ENNReal.Lp_add_le","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"Œπ : Type u\ns : Finset Œπ\nf g : Œπ ‚Üí ENNReal\np : Real\nhp : LE.le 1 p\n‚ä¢ LE.le (HPow.hPow (s.sum fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (HDiv.hDiv 1 p)) (HAdd.hAdd (HPow.hPow (s.sum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (s.sum fun i => HPow.hPow (g i) p) (HDiv.hDiv 1 p)))","decl":"/-- **Minkowski inequality**: the `L_p` seminorm of the sum of two vectors is less than or equal\nto the sum of the `L_p`-seminorms of the summands. A version for `‚Ñù‚â•0‚àû` valued nonnegative\nfunctions. -/\ntheorem Lp_add_le (hp : 1 ‚â§ p) :\n    (‚àë i ‚àà s, (f i + g i) ^ p) ^ (1 / p) ‚â§\n      (‚àë i ‚àà s, f i ^ p) ^ (1 / p) + (‚àë i ‚àà s, g i ^ p) ^ (1 / p) := by\n  by_cases H' : (‚àë i ‚àà s, f i ^ p) ^ (1 / p) = ‚ä§ ‚à® (‚àë i ‚àà s, g i ^ p) ^ (1 / p) = ‚ä§\n  ¬∑ cases' H' with H' H' <;> simp [H', -one_div]\n  have pos : 0 < p := lt_of_lt_of_le zero_lt_one hp\n  replace H' : (‚àÄ i ‚àà s, f i ‚â† ‚ä§) ‚àß ‚àÄ i ‚àà s, g i ‚â† ‚ä§ := by\n    simpa [ENNReal.rpow_eq_top_iff, asymm pos, pos, ENNReal.sum_eq_top, not_or] using H'\n  have :=\n    ENNReal.coe_le_coe.2\n      (@NNReal.Lp_add_le _ s (fun i => ENNReal.toNNReal (f i)) (fun i => ENNReal.toNNReal (g i)) _\n        hp)\n  push_cast [ENNReal.coe_rpow_of_nonneg, le_of_lt pos, le_of_lt (one_div_pos.2 pos)] at this\n  convert this using 2 <;> [skip; congr 1; congr 1] <;>\n    ¬∑ refine Finset.sum_congr rfl fun i hi => ?_\n      simp [H'.1 i hi, H'.2 i hi]\n\n"}
