{"name":"Real.geom_mean_le_arith_mean_weighted","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nw z : ι → Real\nhw : ∀ (i : ι), Membership.mem s i → LE.le 0 (w i)\nhw' : Eq (s.sum fun i => w i) 1\nhz : ∀ (i : ι), Membership.mem s i → LE.le 0 (z i)\n⊢ LE.le (s.prod fun i => HPow.hPow (z i) (w i)) (s.sum fun i => HMul.hMul (w i) (z i))","decl":"/-- **AM-GM inequality**: The geometric mean is less than or equal to the arithmetic mean, weighted\nversion for real-valued nonnegative functions. -/\ntheorem geom_mean_le_arith_mean_weighted (w z : ι → ℝ) (hw : ∀ i ∈ s, 0 ≤ w i)\n    (hw' : ∑ i ∈ s, w i = 1) (hz : ∀ i ∈ s, 0 ≤ z i) :\n    ∏ i ∈ s, z i ^ w i ≤ ∑ i ∈ s, w i * z i := by\n  -- If some number `z i` equals zero and has non-zero weight, then LHS is 0 and RHS is nonnegative.\n  by_cases A : ∃ i ∈ s, z i = 0 ∧ w i ≠ 0\n  · rcases A with ⟨i, his, hzi, hwi⟩\n    rw [prod_eq_zero his]\n    · exact sum_nonneg fun j hj => mul_nonneg (hw j hj) (hz j hj)\n    · rw [hzi]\n      exact zero_rpow hwi\n  -- If all numbers `z i` with non-zero weight are positive, then we apply Jensen's inequality\n  -- for `exp` and numbers `log (z i)` with weights `w i`.\n  · simp only [not_exists, not_and, Ne, Classical.not_not] at A\n    have := convexOn_exp.map_sum_le hw hw' fun i _ => Set.mem_univ <| log (z i)\n    simp only [exp_sum, smul_eq_mul, mul_comm (w _) (log _)] at this\n    convert this using 1 <;> [apply prod_congr rfl;apply sum_congr rfl] <;> intro i hi\n    · cases' eq_or_lt_of_le (hz i hi) with hz hz\n      · simp [A i hi hz.symm]\n      · exact rpow_def_of_pos hz _\n    · cases' eq_or_lt_of_le (hz i hi) with hz hz\n      · simp [A i hi hz.symm]\n      · rw [exp_log hz]\n\n"}
{"name":"Real.geom_mean_le_arith_mean","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u_1\ns : Finset ι\nw z : ι → Real\nhw : ∀ (i : ι), Membership.mem s i → LE.le 0 (w i)\nhw' : LT.lt 0 (s.sum fun i => w i)\nhz : ∀ (i : ι), Membership.mem s i → LE.le 0 (z i)\n⊢ LE.le (HPow.hPow (s.prod fun i => HPow.hPow (z i) (w i)) (Inv.inv (s.sum fun i => w i))) (HDiv.hDiv (s.sum fun i => HMul.hMul (w i) (z i)) (s.sum fun i => w i))","decl":"/-- **AM-GM inequality**: The **geometric mean is less than or equal to the arithmetic mean. -/\ntheorem geom_mean_le_arith_mean {ι : Type*} (s : Finset ι) (w : ι → ℝ) (z : ι → ℝ)\n    (hw : ∀ i ∈ s, 0 ≤ w i) (hw' : 0 < ∑ i ∈ s, w i) (hz : ∀ i ∈ s, 0 ≤ z i) :\n    (∏ i ∈ s, z i ^ w i) ^ (∑ i ∈ s, w i)⁻¹  ≤  (∑ i ∈ s, w i * z i) / (∑ i ∈ s, w i) := by\n  convert geom_mean_le_arith_mean_weighted s (fun i => (w i) / ∑ i ∈ s, w i) z ?_ ?_ hz using 2\n  · rw [← finset_prod_rpow _ _ (fun i hi => rpow_nonneg (hz _ hi) _) _]\n    refine Finset.prod_congr rfl (fun _ ih => ?_)\n    rw [div_eq_mul_inv, rpow_mul (hz _ ih)]\n  · simp_rw [div_eq_mul_inv, mul_assoc, mul_comm, ← mul_assoc, ← Finset.sum_mul, mul_comm]\n  · exact fun _ hi => div_nonneg (hw _ hi) (le_of_lt hw')\n  · simp_rw [div_eq_mul_inv, ← Finset.sum_mul]\n    exact mul_inv_cancel₀ (by linarith)\n\n"}
{"name":"Real.geom_mean_weighted_of_constant","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nw z : ι → Real\nx : Real\nhw : ∀ (i : ι), Membership.mem s i → LE.le 0 (w i)\nhw' : Eq (s.sum fun i => w i) 1\nhz : ∀ (i : ι), Membership.mem s i → LE.le 0 (z i)\nhx : ∀ (i : ι), Membership.mem s i → Ne (w i) 0 → Eq (z i) x\n⊢ Eq (s.prod fun i => HPow.hPow (z i) (w i)) x","decl":"theorem geom_mean_weighted_of_constant (w z : ι → ℝ) (x : ℝ) (hw : ∀ i ∈ s, 0 ≤ w i)\n    (hw' : ∑ i ∈ s, w i = 1) (hz : ∀ i ∈ s, 0 ≤ z i) (hx : ∀ i ∈ s, w i ≠ 0 → z i = x) :\n    ∏ i ∈ s, z i ^ w i = x :=\n  calc\n    ∏ i ∈ s, z i ^ w i = ∏ i ∈ s, x ^ w i := by\n      refine prod_congr rfl fun i hi => ?_\n      rcases eq_or_ne (w i) 0 with h₀ | h₀\n      · rw [h₀, rpow_zero, rpow_zero]\n      · rw [hx i hi h₀]\n    _ = x := by\n      rw [← rpow_sum_of_nonneg _ hw, hw', rpow_one]\n      have : (∑ i ∈ s, w i) ≠ 0 := by\n        rw [hw']\n        exact one_ne_zero\n      obtain ⟨i, his, hi⟩ := exists_ne_zero_of_sum_ne_zero this\n      rw [← hx i his hi]\n      exact hz i his\n\n"}
{"name":"Real.arith_mean_weighted_of_constant","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nw z : ι → Real\nx : Real\nhw' : Eq (s.sum fun i => w i) 1\nhx : ∀ (i : ι), Membership.mem s i → Ne (w i) 0 → Eq (z i) x\n⊢ Eq (s.sum fun i => HMul.hMul (w i) (z i)) x","decl":"theorem arith_mean_weighted_of_constant (w z : ι → ℝ) (x : ℝ) (hw' : ∑ i ∈ s, w i = 1)\n    (hx : ∀ i ∈ s, w i ≠ 0 → z i = x) : ∑ i ∈ s, w i * z i = x :=\n  calc\n    ∑ i ∈ s, w i * z i = ∑ i ∈ s, w i * x := by\n      refine sum_congr rfl fun i hi => ?_\n      rcases eq_or_ne (w i) 0 with hwi | hwi\n      · rw [hwi, zero_mul, zero_mul]\n      · rw [hx i hi hwi]\n    _ = x := by rw [← sum_mul, hw', one_mul]\n\n"}
{"name":"Real.geom_mean_eq_arith_mean_weighted_of_constant","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nw z : ι → Real\nx : Real\nhw : ∀ (i : ι), Membership.mem s i → LE.le 0 (w i)\nhw' : Eq (s.sum fun i => w i) 1\nhz : ∀ (i : ι), Membership.mem s i → LE.le 0 (z i)\nhx : ∀ (i : ι), Membership.mem s i → Ne (w i) 0 → Eq (z i) x\n⊢ Eq (s.prod fun i => HPow.hPow (z i) (w i)) (s.sum fun i => HMul.hMul (w i) (z i))","decl":"theorem geom_mean_eq_arith_mean_weighted_of_constant (w z : ι → ℝ) (x : ℝ) (hw : ∀ i ∈ s, 0 ≤ w i)\n    (hw' : ∑ i ∈ s, w i = 1) (hz : ∀ i ∈ s, 0 ≤ z i) (hx : ∀ i ∈ s, w i ≠ 0 → z i = x) :\n    ∏ i ∈ s, z i ^ w i = ∑ i ∈ s, w i * z i := by\n  rw [geom_mean_weighted_of_constant, arith_mean_weighted_of_constant] <;> assumption\n\n"}
{"name":"Real.geom_mean_eq_arith_mean_weighted_iff'","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nw z : ι → Real\nhw : ∀ (i : ι), Membership.mem s i → LT.lt 0 (w i)\nhw' : Eq (s.sum fun i => w i) 1\nhz : ∀ (i : ι), Membership.mem s i → LE.le 0 (z i)\n⊢ Iff (Eq (s.prod fun i => HPow.hPow (z i) (w i)) (s.sum fun i => HMul.hMul (w i) (z i))) (∀ (j : ι), Membership.mem s j → Eq (z j) (s.sum fun i => HMul.hMul (w i) (z i)))","decl":"/-- **AM-GM inequality - equality condition**: This theorem provides the equality condition for the\n*positive* weighted version of the AM-GM inequality for real-valued nonnegative functions. -/\ntheorem geom_mean_eq_arith_mean_weighted_iff' (w z : ι → ℝ) (hw : ∀ i ∈ s, 0 < w i)\n    (hw' : ∑ i ∈ s, w i = 1) (hz : ∀ i ∈ s, 0 ≤ z i) :\n    ∏ i ∈ s, z i ^ w i = ∑ i ∈ s, w i * z i ↔ ∀ j ∈ s, z j = ∑ i ∈ s, w i * z i := by\n  by_cases A : ∃ i ∈ s, z i = 0 ∧ w i ≠ 0\n  · rcases A with ⟨i, his, hzi, hwi⟩\n    rw [prod_eq_zero his]\n    · constructor\n      · intro h\n        rw [← h]\n        intro j hj\n        apply eq_zero_of_ne_zero_of_mul_left_eq_zero (ne_of_lt (hw j hj)).symm\n        apply (sum_eq_zero_iff_of_nonneg ?_).mp h.symm j hj\n        exact fun i hi => (mul_nonneg_iff_of_pos_left (hw i hi)).mpr (hz i hi)\n      · intro h\n        convert h i his\n        exact hzi.symm\n    · rw [hzi]\n      exact zero_rpow hwi\n  · simp only [not_exists, not_and] at A\n    have hz' := fun i h => lt_of_le_of_ne (hz i h) (fun a => (A i h a.symm) (ne_of_gt (hw i h)))\n    have := strictConvexOn_exp.map_sum_eq_iff hw hw' fun i _ => Set.mem_univ <| log (z i)\n    simp only [exp_sum, smul_eq_mul, mul_comm (w _) (log _)] at this\n    convert this using 1\n    · apply Eq.congr <;>\n      [apply prod_congr rfl; apply sum_congr rfl] <;>\n      intro i hi <;>\n      simp only [exp_mul, exp_log (hz' i hi)]\n    · constructor <;> intro h j hj\n      · rw [← arith_mean_weighted_of_constant s w _ (log (z j)) hw' fun i _ => congrFun rfl]\n        apply sum_congr rfl\n        intro x hx\n        simp only [mul_comm, h j hj, h x hx]\n      · rw [← arith_mean_weighted_of_constant s w _ (z j) hw' fun i _ => congrFun rfl]\n        apply sum_congr rfl\n        intro x hx\n        simp only [log_injOn_pos (hz' j hj) (hz' x hx), h j hj, h x hx]\n\n"}
{"name":"Real.geom_mean_eq_arith_mean_weighted_iff","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nw z : ι → Real\nhw : ∀ (i : ι), Membership.mem s i → LE.le 0 (w i)\nhw' : Eq (s.sum fun i => w i) 1\nhz : ∀ (i : ι), Membership.mem s i → LE.le 0 (z i)\n⊢ Iff (Eq (s.prod fun i => HPow.hPow (z i) (w i)) (s.sum fun i => HMul.hMul (w i) (z i))) (∀ (j : ι), Membership.mem s j → Ne (w j) 0 → Eq (z j) (s.sum fun i => HMul.hMul (w i) (z i)))","decl":"/-- **AM-GM inequality - equality condition**: This theorem provides the equality condition for the\nweighted version of the AM-GM inequality for real-valued nonnegative functions. -/\ntheorem geom_mean_eq_arith_mean_weighted_iff (w z : ι → ℝ) (hw : ∀ i ∈ s, 0 ≤ w i)\n    (hw' : ∑ i ∈ s, w i = 1) (hz : ∀ i ∈ s, 0 ≤ z i) :\n    ∏ i ∈ s, z i ^ w i = ∑ i ∈ s, w i * z i ↔ ∀ j ∈ s, w j ≠ 0 → z j = ∑ i ∈ s, w i * z i := by\n  have h (i) (_ : i ∈ s) : w i * z i ≠ 0 → w i ≠ 0 := by apply left_ne_zero_of_mul\n  have h' (i) (_ : i ∈ s) : z i ^ w i ≠ 1 → w i ≠ 0 := by\n    by_contra!\n    obtain ⟨h1, h2⟩ := this\n    simp only [h2, rpow_zero, ne_self_iff_false] at h1\n  rw [← sum_filter_of_ne h, ← prod_filter_of_ne h', geom_mean_eq_arith_mean_weighted_iff']\n  · simp\n  · simp +contextual [(hw _ _).gt_iff_ne]\n  · rwa [sum_filter_ne_zero]\n  · simp_all only [ne_eq, mul_eq_zero, not_or, not_false_eq_true, and_imp, implies_true, mem_filter]\n\n"}
{"name":"Real.geom_mean_lt_arith_mean_weighted_iff_of_pos","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nw z : ι → Real\nhw : ∀ (i : ι), Membership.mem s i → LT.lt 0 (w i)\nhw' : Eq (s.sum fun i => w i) 1\nhz : ∀ (i : ι), Membership.mem s i → LE.le 0 (z i)\n⊢ Iff (LT.lt (s.prod fun i => HPow.hPow (z i) (w i)) (s.sum fun i => HMul.hMul (w i) (z i))) (Exists fun j => And (Membership.mem s j) (Exists fun k => And (Membership.mem s k) (Ne (z j) (z k))))","decl":"/-- **AM-GM inequality - strict inequality condition**: This theorem provides the strict inequality\ncondition for the *positive* weighted version of the AM-GM inequality for real-valued nonnegative\nfunctions. -/\ntheorem geom_mean_lt_arith_mean_weighted_iff_of_pos (w z : ι → ℝ) (hw : ∀ i ∈ s, 0 < w i)\n    (hw' : ∑ i ∈ s, w i = 1) (hz : ∀ i ∈ s, 0 ≤ z i) :\n    ∏ i ∈ s, z i ^ w i < ∑ i ∈ s, w i * z i ↔ ∃ j ∈ s, ∃ k ∈ s, z j ≠ z k:= by\n  constructor\n  · intro h\n    by_contra! h_contra\n    rw [(geom_mean_eq_arith_mean_weighted_iff' s w z hw hw' hz).mpr ?_] at h\n    · exact (lt_self_iff_false _).mp h\n    · intro j hjs\n      rw [← arith_mean_weighted_of_constant s w (fun _ => z j) (z j) hw' fun _ _ => congrFun rfl]\n      apply sum_congr rfl (fun x a => congrArg (HMul.hMul (w x)) (h_contra j hjs x a))\n  · rintro ⟨j, hjs, k, hks, hzjk⟩\n    have := geom_mean_le_arith_mean_weighted s w z (fun i a => le_of_lt (hw i a)) hw' hz\n    by_contra! h\n    apply le_antisymm this at h\n    apply (geom_mean_eq_arith_mean_weighted_iff' s w z hw hw' hz).mp at h\n    simp only [h j hjs, h k hks, ne_eq, not_true_eq_false] at hzjk\n\n"}
{"name":"NNReal.geom_mean_le_arith_mean_weighted","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nw z : ι → NNReal\nhw' : Eq (s.sum fun i => w i) 1\n⊢ LE.le (s.prod fun i => HPow.hPow (z i) ↑(w i)) (s.sum fun i => HMul.hMul (w i) (z i))","decl":"/-- **AM-GM inequality**: The geometric mean is less than or equal to the arithmetic mean, weighted\nversion for `NNReal`-valued functions. -/\ntheorem geom_mean_le_arith_mean_weighted (w z : ι → ℝ≥0) (hw' : ∑ i ∈ s, w i = 1) :\n    (∏ i ∈ s, z i ^ (w i : ℝ)) ≤ ∑ i ∈ s, w i * z i :=\n  mod_cast\n    Real.geom_mean_le_arith_mean_weighted _ _ _ (fun i _ => (w i).coe_nonneg)\n      (by assumption_mod_cast) fun i _ => (z i).coe_nonneg\n\n"}
{"name":"NNReal.geom_mean_le_arith_mean2_weighted","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"w₁ w₂ p₁ p₂ : NNReal\na✝ : Eq (HAdd.hAdd w₁ w₂) 1\n⊢ LE.le (HMul.hMul (HPow.hPow p₁ ↑w₁) (HPow.hPow p₂ ↑w₂)) (HAdd.hAdd (HMul.hMul w₁ p₁) (HMul.hMul w₂ p₂))","decl":"/-- **AM-GM inequality**: The geometric mean is less than or equal to the arithmetic mean, weighted\nversion for two `NNReal` numbers. -/\ntheorem geom_mean_le_arith_mean2_weighted (w₁ w₂ p₁ p₂ : ℝ≥0) :\n    w₁ + w₂ = 1 → p₁ ^ (w₁ : ℝ) * p₂ ^ (w₂ : ℝ) ≤ w₁ * p₁ + w₂ * p₂ := by\n  simpa only [Fin.prod_univ_succ, Fin.sum_univ_succ, Finset.prod_empty, Finset.sum_empty,\n    Finset.univ_eq_empty, Fin.cons_succ, Fin.cons_zero, add_zero, mul_one] using\n    geom_mean_le_arith_mean_weighted univ ![w₁, w₂] ![p₁, p₂]\n\n"}
{"name":"NNReal.geom_mean_le_arith_mean3_weighted","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"w₁ w₂ w₃ p₁ p₂ p₃ : NNReal\na✝ : Eq (HAdd.hAdd (HAdd.hAdd w₁ w₂) w₃) 1\n⊢ LE.le (HMul.hMul (HMul.hMul (HPow.hPow p₁ ↑w₁) (HPow.hPow p₂ ↑w₂)) (HPow.hPow p₃ ↑w₃)) (HAdd.hAdd (HAdd.hAdd (HMul.hMul w₁ p₁) (HMul.hMul w₂ p₂)) (HMul.hMul w₃ p₃))","decl":"theorem geom_mean_le_arith_mean3_weighted (w₁ w₂ w₃ p₁ p₂ p₃ : ℝ≥0) :\n    w₁ + w₂ + w₃ = 1 →\n      p₁ ^ (w₁ : ℝ) * p₂ ^ (w₂ : ℝ) * p₃ ^ (w₃ : ℝ) ≤ w₁ * p₁ + w₂ * p₂ + w₃ * p₃ := by\n  simpa only [Fin.prod_univ_succ, Fin.sum_univ_succ, Finset.prod_empty, Finset.sum_empty,\n    Finset.univ_eq_empty, Fin.cons_succ, Fin.cons_zero, add_zero, mul_one, ← add_assoc,\n    mul_assoc] using geom_mean_le_arith_mean_weighted univ ![w₁, w₂, w₃] ![p₁, p₂, p₃]\n\n"}
{"name":"NNReal.geom_mean_le_arith_mean4_weighted","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"w₁ w₂ w₃ w₄ p₁ p₂ p₃ p₄ : NNReal\na✝ : Eq (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd w₁ w₂) w₃) w₄) 1\n⊢ LE.le (HMul.hMul (HMul.hMul (HMul.hMul (HPow.hPow p₁ ↑w₁) (HPow.hPow p₂ ↑w₂)) (HPow.hPow p₃ ↑w₃)) (HPow.hPow p₄ ↑w₄)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HMul.hMul w₁ p₁) (HMul.hMul w₂ p₂)) (HMul.hMul w₃ p₃)) (HMul.hMul w₄ p₄))","decl":"theorem geom_mean_le_arith_mean4_weighted (w₁ w₂ w₃ w₄ p₁ p₂ p₃ p₄ : ℝ≥0) :\n    w₁ + w₂ + w₃ + w₄ = 1 →\n      p₁ ^ (w₁ : ℝ) * p₂ ^ (w₂ : ℝ) * p₃ ^ (w₃ : ℝ) * p₄ ^ (w₄ : ℝ) ≤\n        w₁ * p₁ + w₂ * p₂ + w₃ * p₃ + w₄ * p₄ := by\n  simpa only [Fin.prod_univ_succ, Fin.sum_univ_succ, Finset.prod_empty, Finset.sum_empty,\n    Finset.univ_eq_empty, Fin.cons_succ, Fin.cons_zero, add_zero, mul_one, ← add_assoc,\n    mul_assoc] using geom_mean_le_arith_mean_weighted univ ![w₁, w₂, w₃, w₄] ![p₁, p₂, p₃, p₄]\n\n"}
{"name":"Real.geom_mean_le_arith_mean2_weighted","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"w₁ w₂ p₁ p₂ : Real\nhw₁ : LE.le 0 w₁\nhw₂ : LE.le 0 w₂\nhp₁ : LE.le 0 p₁\nhp₂ : LE.le 0 p₂\nhw : Eq (HAdd.hAdd w₁ w₂) 1\n⊢ LE.le (HMul.hMul (HPow.hPow p₁ w₁) (HPow.hPow p₂ w₂)) (HAdd.hAdd (HMul.hMul w₁ p₁) (HMul.hMul w₂ p₂))","decl":"theorem geom_mean_le_arith_mean2_weighted {w₁ w₂ p₁ p₂ : ℝ} (hw₁ : 0 ≤ w₁) (hw₂ : 0 ≤ w₂)\n    (hp₁ : 0 ≤ p₁) (hp₂ : 0 ≤ p₂) (hw : w₁ + w₂ = 1) : p₁ ^ w₁ * p₂ ^ w₂ ≤ w₁ * p₁ + w₂ * p₂ :=\n  NNReal.geom_mean_le_arith_mean2_weighted ⟨w₁, hw₁⟩ ⟨w₂, hw₂⟩ ⟨p₁, hp₁⟩ ⟨p₂, hp₂⟩ <|\n    NNReal.coe_inj.1 <| by assumption\n\n"}
{"name":"Real.geom_mean_le_arith_mean3_weighted","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"w₁ w₂ w₃ p₁ p₂ p₃ : Real\nhw₁ : LE.le 0 w₁\nhw₂ : LE.le 0 w₂\nhw₃ : LE.le 0 w₃\nhp₁ : LE.le 0 p₁\nhp₂ : LE.le 0 p₂\nhp₃ : LE.le 0 p₃\nhw : Eq (HAdd.hAdd (HAdd.hAdd w₁ w₂) w₃) 1\n⊢ LE.le (HMul.hMul (HMul.hMul (HPow.hPow p₁ w₁) (HPow.hPow p₂ w₂)) (HPow.hPow p₃ w₃)) (HAdd.hAdd (HAdd.hAdd (HMul.hMul w₁ p₁) (HMul.hMul w₂ p₂)) (HMul.hMul w₃ p₃))","decl":"theorem geom_mean_le_arith_mean3_weighted {w₁ w₂ w₃ p₁ p₂ p₃ : ℝ} (hw₁ : 0 ≤ w₁) (hw₂ : 0 ≤ w₂)\n    (hw₃ : 0 ≤ w₃) (hp₁ : 0 ≤ p₁) (hp₂ : 0 ≤ p₂) (hp₃ : 0 ≤ p₃) (hw : w₁ + w₂ + w₃ = 1) :\n    p₁ ^ w₁ * p₂ ^ w₂ * p₃ ^ w₃ ≤ w₁ * p₁ + w₂ * p₂ + w₃ * p₃ :=\n  NNReal.geom_mean_le_arith_mean3_weighted ⟨w₁, hw₁⟩ ⟨w₂, hw₂⟩ ⟨w₃, hw₃⟩ ⟨p₁, hp₁⟩ ⟨p₂, hp₂⟩\n      ⟨p₃, hp₃⟩ <|\n    NNReal.coe_inj.1 hw\n\n"}
{"name":"Real.geom_mean_le_arith_mean4_weighted","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"w₁ w₂ w₃ w₄ p₁ p₂ p₃ p₄ : Real\nhw₁ : LE.le 0 w₁\nhw₂ : LE.le 0 w₂\nhw₃ : LE.le 0 w₃\nhw₄ : LE.le 0 w₄\nhp₁ : LE.le 0 p₁\nhp₂ : LE.le 0 p₂\nhp₃ : LE.le 0 p₃\nhp₄ : LE.le 0 p₄\nhw : Eq (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd w₁ w₂) w₃) w₄) 1\n⊢ LE.le (HMul.hMul (HMul.hMul (HMul.hMul (HPow.hPow p₁ w₁) (HPow.hPow p₂ w₂)) (HPow.hPow p₃ w₃)) (HPow.hPow p₄ w₄)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HMul.hMul w₁ p₁) (HMul.hMul w₂ p₂)) (HMul.hMul w₃ p₃)) (HMul.hMul w₄ p₄))","decl":"theorem geom_mean_le_arith_mean4_weighted {w₁ w₂ w₃ w₄ p₁ p₂ p₃ p₄ : ℝ} (hw₁ : 0 ≤ w₁)\n    (hw₂ : 0 ≤ w₂) (hw₃ : 0 ≤ w₃) (hw₄ : 0 ≤ w₄) (hp₁ : 0 ≤ p₁) (hp₂ : 0 ≤ p₂) (hp₃ : 0 ≤ p₃)\n    (hp₄ : 0 ≤ p₄) (hw : w₁ + w₂ + w₃ + w₄ = 1) :\n    p₁ ^ w₁ * p₂ ^ w₂ * p₃ ^ w₃ * p₄ ^ w₄ ≤ w₁ * p₁ + w₂ * p₂ + w₃ * p₃ + w₄ * p₄ :=\n  NNReal.geom_mean_le_arith_mean4_weighted ⟨w₁, hw₁⟩ ⟨w₂, hw₂⟩ ⟨w₃, hw₃⟩ ⟨w₄, hw₄⟩ ⟨p₁, hp₁⟩\n      ⟨p₂, hp₂⟩ ⟨p₃, hp₃⟩ ⟨p₄, hp₄⟩ <|\n    NNReal.coe_inj.1 <| by assumption\n\n"}
{"name":"Real.harm_mean_le_geom_mean_weighted","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nw z : ι → Real\nhs : s.Nonempty\nhw : ∀ (i : ι), Membership.mem s i → LT.lt 0 (w i)\nhw' : Eq (s.sum fun i => w i) 1\nhz : ∀ (i : ι), Membership.mem s i → LT.lt 0 (z i)\n⊢ LE.le (Inv.inv (s.sum fun i => HDiv.hDiv (w i) (z i))) (s.prod fun i => HPow.hPow (z i) (w i))","decl":"/-- **HM-GM inequality**: The harmonic mean is less than or equal to the geometric mean, weighted\nversion for real-valued nonnegative functions. -/\ntheorem harm_mean_le_geom_mean_weighted (w z : ι → ℝ) (hs : s.Nonempty) (hw : ∀ i ∈ s, 0 < w i)\n    (hw' : ∑ i ∈ s, w i = 1) (hz : ∀ i ∈ s, 0 < z i) :\n    (∑ i ∈ s, w i / z i)⁻¹ ≤ ∏ i ∈ s, z i ^ w i  := by\n    have : ∏ i ∈ s, (1 / z) i ^ w i ≤ ∑ i ∈ s, w i * (1 / z) i :=\n      geom_mean_le_arith_mean_weighted s w (1/z) (fun i hi ↦ le_of_lt (hw i hi)) hw'\n      (fun i hi ↦ one_div_nonneg.2 (le_of_lt (hz i hi)))\n    have p_pos : 0 < ∏ i ∈ s, (z i)⁻¹ ^ w i :=\n      prod_pos fun i hi => rpow_pos_of_pos (inv_pos.2 (hz i hi)) _\n    have s_pos : 0 < ∑ i ∈ s, w i * (z i)⁻¹ :=\n      sum_pos (fun i hi => mul_pos (hw i hi) (inv_pos.2 (hz i hi))) hs\n    norm_num at this\n    rw [← inv_le_inv₀ s_pos p_pos] at this\n    apply le_trans this\n    have p_pos₂ : 0 < (∏ i ∈ s, (z i) ^ w i)⁻¹ :=\n      inv_pos.2 (prod_pos fun i hi => rpow_pos_of_pos ((hz i hi)) _ )\n    rw [← inv_inv (∏ i ∈ s, z i ^ w i), inv_le_inv₀ p_pos p_pos₂, ← Finset.prod_inv_distrib]\n    gcongr\n    · exact fun i hi ↦ inv_nonneg.mpr (Real.rpow_nonneg (le_of_lt (hz i hi)) _)\n    · rw [Real.inv_rpow]; apply fun i hi ↦ le_of_lt (hz i hi); assumption\n\n\n"}
{"name":"Real.harm_mean_le_geom_mean","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u_1\ns : Finset ι\nhs : s.Nonempty\nw z : ι → Real\nhw : ∀ (i : ι), Membership.mem s i → LT.lt 0 (w i)\nhw' : LT.lt 0 (s.sum fun i => w i)\nhz : ∀ (i : ι), Membership.mem s i → LT.lt 0 (z i)\n⊢ LE.le (HDiv.hDiv (s.sum fun i => w i) (s.sum fun i => HDiv.hDiv (w i) (z i))) (HPow.hPow (s.prod fun i => HPow.hPow (z i) (w i)) (Inv.inv (s.sum fun i => w i)))","decl":"/-- **HM-GM inequality**: The **harmonic mean is less than or equal to the geometric mean. -/\ntheorem harm_mean_le_geom_mean {ι : Type*} (s : Finset ι) (hs : s.Nonempty) (w : ι → ℝ)\n    (z : ι → ℝ) (hw : ∀ i ∈ s, 0 < w i) (hw' : 0 < ∑ i ∈ s, w i) (hz : ∀ i ∈ s, 0 < z i) :\n    (∑ i ∈ s, w i) / (∑ i ∈ s, w i / z i) ≤ (∏ i ∈ s, z i ^ w i) ^ (∑ i ∈ s, w i)⁻¹ := by\n  have := harm_mean_le_geom_mean_weighted s (fun i => (w i) / ∑ i ∈ s, w i) z hs ?_ ?_ hz\n  · simp only at this\n    set n := ∑ i ∈ s, w i\n    nth_rw 1 [div_eq_mul_inv, (show n = (n⁻¹)⁻¹ by norm_num), ← mul_inv, Finset.mul_sum _ _ n⁻¹]\n    simp_rw [inv_mul_eq_div n ((w _)/(z _)), div_right_comm _ _ n]\n    convert this\n    rw [← Real.finset_prod_rpow s _ (fun i hi ↦ Real.rpow_nonneg (le_of_lt <| hz i hi) _)]\n    refine Finset.prod_congr rfl (fun i hi => ?_)\n    rw [← Real.rpow_mul (le_of_lt <| hz i hi) (w _) n⁻¹, div_eq_mul_inv (w _) n]\n  · exact fun i hi ↦ div_pos (hw i hi) hw'\n  · simp_rw [div_eq_mul_inv (w _) (∑ i ∈ s, w i), ← Finset.sum_mul _ _ (∑ i ∈ s, w i)⁻¹]\n    exact mul_inv_cancel₀ hw'.ne'\n\n"}
{"name":"Real.young_inequality_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"a b p q : Real\nha : LE.le 0 a\nhb : LE.le 0 b\nhpq : p.IsConjExponent q\n⊢ LE.le (HMul.hMul a b) (HAdd.hAdd (HDiv.hDiv (HPow.hPow a p) p) (HDiv.hDiv (HPow.hPow b q) q))","decl":"/-- **Young's inequality**, a version for nonnegative real numbers. -/\ntheorem young_inequality_of_nonneg {a b p q : ℝ} (ha : 0 ≤ a) (hb : 0 ≤ b)\n    (hpq : p.IsConjExponent q) : a * b ≤ a ^ p / p + b ^ q / q := by\n  simpa [← rpow_mul, ha, hb, hpq.ne_zero, hpq.symm.ne_zero, _root_.div_eq_inv_mul] using\n    geom_mean_le_arith_mean2_weighted hpq.inv_nonneg hpq.symm.inv_nonneg\n      (rpow_nonneg ha p) (rpow_nonneg hb q) hpq.inv_add_inv_conj\n\n"}
{"name":"Real.young_inequality","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"a b p q : Real\nhpq : p.IsConjExponent q\n⊢ LE.le (HMul.hMul a b) (HAdd.hAdd (HDiv.hDiv (HPow.hPow (abs a) p) p) (HDiv.hDiv (HPow.hPow (abs b) q) q))","decl":"/-- **Young's inequality**, a version for arbitrary real numbers. -/\ntheorem young_inequality (a b : ℝ) {p q : ℝ} (hpq : p.IsConjExponent q) :\n    a * b ≤ |a| ^ p / p + |b| ^ q / q :=\n  calc\n    a * b ≤ |a * b| := le_abs_self (a * b)\n    _ = |a| * |b| := abs_mul a b\n    _ ≤ |a| ^ p / p + |b| ^ q / q :=\n      Real.young_inequality_of_nonneg (abs_nonneg a) (abs_nonneg b) hpq\n\n"}
{"name":"NNReal.young_inequality","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"a b p q : NNReal\nhpq : p.IsConjExponent q\n⊢ LE.le (HMul.hMul a b) (HAdd.hAdd (HDiv.hDiv (HPow.hPow a ↑p) p) (HDiv.hDiv (HPow.hPow b ↑q) q))","decl":"/-- **Young's inequality**, `ℝ≥0` version. We use `{p q : ℝ≥0}` in order to avoid constructing\nwitnesses of `0 ≤ p` and `0 ≤ q` for the denominators. -/\ntheorem young_inequality (a b : ℝ≥0) {p q : ℝ≥0} (hpq : p.IsConjExponent q) :\n    a * b ≤ a ^ (p : ℝ) / p + b ^ (q : ℝ) / q :=\n  Real.young_inequality_of_nonneg a.coe_nonneg b.coe_nonneg hpq.coe\n\n"}
{"name":"NNReal.young_inequality_real","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"a b : NNReal\np q : Real\nhpq : p.IsConjExponent q\n⊢ LE.le (HMul.hMul a b) (HAdd.hAdd (HDiv.hDiv (HPow.hPow a p) p.toNNReal) (HDiv.hDiv (HPow.hPow b q) q.toNNReal))","decl":"/-- **Young's inequality**, `ℝ≥0` version with real conjugate exponents. -/\ntheorem young_inequality_real (a b : ℝ≥0) {p q : ℝ} (hpq : p.IsConjExponent q) :\n    a * b ≤ a ^ p / Real.toNNReal p + b ^ q / Real.toNNReal q := by\n  simpa [Real.coe_toNNReal, hpq.nonneg, hpq.symm.nonneg] using young_inequality a b hpq.toNNReal\n\n"}
{"name":"ENNReal.young_inequality","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"a b : ENNReal\np q : Real\nhpq : p.IsConjExponent q\n⊢ LE.le (HMul.hMul a b) (HAdd.hAdd (HDiv.hDiv (HPow.hPow a p) (ENNReal.ofReal p)) (HDiv.hDiv (HPow.hPow b q) (ENNReal.ofReal q)))","decl":"/-- **Young's inequality**, `ℝ≥0∞` version with real conjugate exponents. -/\ntheorem young_inequality (a b : ℝ≥0∞) {p q : ℝ} (hpq : p.IsConjExponent q) :\n    a * b ≤ a ^ p / ENNReal.ofReal p + b ^ q / ENNReal.ofReal q := by\n  by_cases h : a = ⊤ ∨ b = ⊤\n  · refine le_trans le_top (le_of_eq ?_)\n    repeat rw [div_eq_mul_inv]\n    cases' h with h h <;> rw [h] <;> simp [h, hpq.pos, hpq.symm.pos]\n  push_neg at h\n  -- if a ≠ ⊤ and b ≠ ⊤, use the nnreal version: nnreal.young_inequality_real\n  rw [← coe_toNNReal h.left, ← coe_toNNReal h.right, ← coe_mul, ← coe_rpow_of_nonneg _ hpq.nonneg,\n    ← coe_rpow_of_nonneg _ hpq.symm.nonneg, ENNReal.ofReal, ENNReal.ofReal, ←\n    @coe_div (Real.toNNReal p) _ (by simp [hpq.pos]), ←\n    @coe_div (Real.toNNReal q) _ (by simp [hpq.symm.pos]), ← coe_add, coe_le_coe]\n  exact NNReal.young_inequality_real a.toNNReal b.toNNReal hpq\n\n"}
{"name":"NNReal.inner_le_Lp_mul_Lq","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nf g : ι → NNReal\np q : Real\nhpq : p.IsConjExponent q\n⊢ LE.le (s.sum fun i => HMul.hMul (f i) (g i)) (HMul.hMul (HPow.hPow (s.sum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (s.sum fun i => HPow.hPow (g i) q) (HDiv.hDiv 1 q)))","decl":"/-- **Hölder inequality**: The scalar product of two functions is bounded by the product of their\n`L^p` and `L^q` norms when `p` and `q` are conjugate exponents. Version for sums over finite sets,\nwith `ℝ≥0`-valued functions. -/\ntheorem inner_le_Lp_mul_Lq (f g : ι → ℝ≥0) {p q : ℝ} (hpq : p.IsConjExponent q) :\n    ∑ i ∈ s, f i * g i ≤ (∑ i ∈ s, f i ^ p) ^ (1 / p) * (∑ i ∈ s, g i ^ q) ^ (1 / q) := by\n  obtain hf | hf := eq_zero_or_pos (∑ i ∈ s, f i ^ p)\n  · exact inner_le_Lp_mul_Lp_of_norm_eq_zero s f g hpq hf\n  obtain hg | hg := eq_zero_or_pos (∑ i ∈ s, g i ^ q)\n  · calc\n      ∑ i ∈ s, f i * g i = ∑ i ∈ s, g i * f i := by\n        congr with i\n        rw [mul_comm]\n      _ ≤ (∑ i ∈ s, g i ^ q) ^ (1 / q) * (∑ i ∈ s, f i ^ p) ^ (1 / p) :=\n        (inner_le_Lp_mul_Lp_of_norm_eq_zero s g f hpq.symm hg)\n      _ = (∑ i ∈ s, f i ^ p) ^ (1 / p) * (∑ i ∈ s, g i ^ q) ^ (1 / q) := mul_comm _ _\n  let f' i := f i / (∑ i ∈ s, f i ^ p) ^ (1 / p)\n  let g' i := g i / (∑ i ∈ s, g i ^ q) ^ (1 / q)\n  suffices (∑ i ∈ s, f' i * g' i) ≤ 1 by\n    simp_rw [f', g', div_mul_div_comm, ← sum_div] at this\n    rwa [div_le_iff₀, one_mul] at this\n    -- TODO: We are missing a positivity  extension here\n    exact mul_pos (rpow_pos hf) (rpow_pos hg)\n  refine inner_le_Lp_mul_Lp_of_norm_le_one s f' g' hpq (le_of_eq ?_) (le_of_eq ?_)\n  · simp_rw [f', div_rpow, ← sum_div, ← rpow_mul, one_div, inv_mul_cancel₀ hpq.ne_zero, rpow_one,\n      div_self hf.ne']\n  · simp_rw [g', div_rpow, ← sum_div, ← rpow_mul, one_div, inv_mul_cancel₀ hpq.symm.ne_zero,\n      rpow_one, div_self hg.ne']\n\n"}
{"name":"NNReal.inner_le_weight_mul_Lp","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\np : Real\nhp : LE.le 1 p\nw f : ι → NNReal\n⊢ LE.le (s.sum fun i => HMul.hMul (w i) (f i)) (HMul.hMul (HPow.hPow (s.sum fun i => w i) (HSub.hSub 1 (Inv.inv p))) (HPow.hPow (s.sum fun i => HMul.hMul (w i) (HPow.hPow (f i) p)) (Inv.inv p)))","decl":"/-- **Weighted Hölder inequality**. -/\nlemma inner_le_weight_mul_Lp (s : Finset ι) {p : ℝ} (hp : 1 ≤ p) (w f : ι → ℝ≥0) :\n    ∑ i ∈ s, w i * f i ≤ (∑ i ∈ s, w i) ^ (1 - p⁻¹) * (∑ i ∈ s, w i * f i ^ p) ^ p⁻¹ := by\n  obtain rfl | hp := hp.eq_or_lt\n  · simp\n  calc\n    _ = ∑ i ∈ s, w i ^ (1 - p⁻¹) * (w i ^ p⁻¹ * f i) := ?_\n    _ ≤ (∑ i ∈ s, (w i ^ (1 - p⁻¹)) ^ (1 - p⁻¹)⁻¹) ^ (1 / (1 - p⁻¹)⁻¹) *\n          (∑ i ∈ s, (w i ^ p⁻¹ * f i) ^ p) ^ (1 / p) :=\n        inner_le_Lp_mul_Lq _ _ _ (.symm ⟨hp, by simp⟩)\n    _ = _ := ?_\n  · congr with i\n    rw [← mul_assoc, ← rpow_of_add_eq _ one_ne_zero, rpow_one]\n    simp\n  · have hp₀ : p ≠ 0 := by positivity\n    have hp₁ : 1 - p⁻¹ ≠ 0 := by simp [sub_eq_zero, hp.ne']\n    simp [mul_rpow, div_inv_eq_mul, one_mul, one_div, hp₀, hp₁]\n\n"}
{"name":"NNReal.inner_le_Lp_mul_Lq_tsum","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\nf g : ι → NNReal\np q : Real\nhpq : p.IsConjExponent q\nhf : Summable fun i => HPow.hPow (f i) p\nhg : Summable fun i => HPow.hPow (g i) q\n⊢ And (Summable fun i => HMul.hMul (f i) (g i)) (LE.le (tsum fun i => HMul.hMul (f i) (g i)) (HMul.hMul (HPow.hPow (tsum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (tsum fun i => HPow.hPow (g i) q) (HDiv.hDiv 1 q))))","decl":"/-- **Hölder inequality**: the scalar product of two functions is bounded by the product of their\n`L^p` and `L^q` norms when `p` and `q` are conjugate exponents. A version for `NNReal`-valued\nfunctions. For an alternative version, convenient if the infinite sums are already expressed as\n`p`-th powers, see `inner_le_Lp_mul_Lq_hasSum`. -/\ntheorem inner_le_Lp_mul_Lq_tsum {f g : ι → ℝ≥0} {p q : ℝ} (hpq : p.IsConjExponent q)\n    (hf : Summable fun i => f i ^ p) (hg : Summable fun i => g i ^ q) :\n    (Summable fun i => f i * g i) ∧\n      ∑' i, f i * g i ≤ (∑' i, f i ^ p) ^ (1 / p) * (∑' i, g i ^ q) ^ (1 / q) := by\n  have H₁ : ∀ s : Finset ι,\n      ∑ i ∈ s, f i * g i ≤ (∑' i, f i ^ p) ^ (1 / p) * (∑' i, g i ^ q) ^ (1 / q) := by\n    intro s\n    refine le_trans (inner_le_Lp_mul_Lq s f g hpq) (mul_le_mul ?_ ?_ bot_le bot_le)\n    · rw [NNReal.rpow_le_rpow_iff (one_div_pos.mpr hpq.pos)]\n      exact sum_le_tsum _ (fun _ _ => zero_le _) hf\n    · rw [NNReal.rpow_le_rpow_iff (one_div_pos.mpr hpq.symm.pos)]\n      exact sum_le_tsum _ (fun _ _ => zero_le _) hg\n  have bdd : BddAbove (Set.range fun s => ∑ i ∈ s, f i * g i) := by\n    refine ⟨(∑' i, f i ^ p) ^ (1 / p) * (∑' i, g i ^ q) ^ (1 / q), ?_⟩\n    rintro a ⟨s, rfl⟩\n    exact H₁ s\n  have H₂ : Summable _ := (hasSum_of_isLUB _ (isLUB_ciSup bdd)).summable\n  exact ⟨H₂, tsum_le_of_sum_le H₂ H₁⟩\n\n"}
{"name":"NNReal.summable_mul_of_Lp_Lq","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\nf g : ι → NNReal\np q : Real\nhpq : p.IsConjExponent q\nhf : Summable fun i => HPow.hPow (f i) p\nhg : Summable fun i => HPow.hPow (g i) q\n⊢ Summable fun i => HMul.hMul (f i) (g i)","decl":"theorem summable_mul_of_Lp_Lq {f g : ι → ℝ≥0} {p q : ℝ} (hpq : p.IsConjExponent q)\n    (hf : Summable fun i => f i ^ p) (hg : Summable fun i => g i ^ q) :\n    Summable fun i => f i * g i :=\n  (inner_le_Lp_mul_Lq_tsum hpq hf hg).1\n\n"}
{"name":"NNReal.inner_le_Lp_mul_Lq_tsum'","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\nf g : ι → NNReal\np q : Real\nhpq : p.IsConjExponent q\nhf : Summable fun i => HPow.hPow (f i) p\nhg : Summable fun i => HPow.hPow (g i) q\n⊢ LE.le (tsum fun i => HMul.hMul (f i) (g i)) (HMul.hMul (HPow.hPow (tsum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (tsum fun i => HPow.hPow (g i) q) (HDiv.hDiv 1 q)))","decl":"theorem inner_le_Lp_mul_Lq_tsum' {f g : ι → ℝ≥0} {p q : ℝ} (hpq : p.IsConjExponent q)\n    (hf : Summable fun i => f i ^ p) (hg : Summable fun i => g i ^ q) :\n    ∑' i, f i * g i ≤ (∑' i, f i ^ p) ^ (1 / p) * (∑' i, g i ^ q) ^ (1 / q) :=\n  (inner_le_Lp_mul_Lq_tsum hpq hf hg).2\n\n"}
{"name":"NNReal.inner_le_Lp_mul_Lq_hasSum","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\nf g : ι → NNReal\nA B : NNReal\np q : Real\nhpq : p.IsConjExponent q\nhf : HasSum (fun i => HPow.hPow (f i) p) (HPow.hPow A p)\nhg : HasSum (fun i => HPow.hPow (g i) q) (HPow.hPow B q)\n⊢ Exists fun C => And (LE.le C (HMul.hMul A B)) (HasSum (fun i => HMul.hMul (f i) (g i)) C)","decl":"/-- **Hölder inequality**: the scalar product of two functions is bounded by the product of their\n`L^p` and `L^q` norms when `p` and `q` are conjugate exponents. A version for `NNReal`-valued\nfunctions. For an alternative version, convenient if the infinite sums are not already expressed as\n`p`-th powers, see `inner_le_Lp_mul_Lq_tsum`. -/\ntheorem inner_le_Lp_mul_Lq_hasSum {f g : ι → ℝ≥0} {A B : ℝ≥0} {p q : ℝ}\n    (hpq : p.IsConjExponent q) (hf : HasSum (fun i => f i ^ p) (A ^ p))\n    (hg : HasSum (fun i => g i ^ q) (B ^ q)) : ∃ C, C ≤ A * B ∧ HasSum (fun i => f i * g i) C := by\n  obtain ⟨H₁, H₂⟩ := inner_le_Lp_mul_Lq_tsum hpq hf.summable hg.summable\n  have hA : A = (∑' i : ι, f i ^ p) ^ (1 / p) := by rw [hf.tsum_eq, rpow_inv_rpow_self hpq.ne_zero]\n  have hB : B = (∑' i : ι, g i ^ q) ^ (1 / q) := by\n    rw [hg.tsum_eq, rpow_inv_rpow_self hpq.symm.ne_zero]\n  refine ⟨∑' i, f i * g i, ?_, ?_⟩\n  · simpa [hA, hB] using H₂\n  · simpa only [rpow_self_rpow_inv hpq.ne_zero] using H₁.hasSum\n\n"}
{"name":"NNReal.rpow_sum_le_const_mul_sum_rpow","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nf : ι → NNReal\np : Real\nhp : LE.le 1 p\n⊢ LE.le (HPow.hPow (s.sum fun i => f i) p) (HMul.hMul (HPow.hPow (↑s.card) (HSub.hSub p 1)) (s.sum fun i => HPow.hPow (f i) p))","decl":"/-- For `1 ≤ p`, the `p`-th power of the sum of `f i` is bounded above by a constant times the\nsum of the `p`-th powers of `f i`. Version for sums over finite sets, with `ℝ≥0`-valued functions.\n-/\ntheorem rpow_sum_le_const_mul_sum_rpow (f : ι → ℝ≥0) {p : ℝ} (hp : 1 ≤ p) :\n    (∑ i ∈ s, f i) ^ p ≤ (#s : ℝ≥0) ^ (p - 1) * ∑ i ∈ s, f i ^ p := by\n  cases' eq_or_lt_of_le hp with hp hp\n  · simp [← hp]\n  let q : ℝ := p / (p - 1)\n  have hpq : p.IsConjExponent q := .conjExponent hp\n  have hp₁ : 1 / p * p = 1 := one_div_mul_cancel hpq.ne_zero\n  have hq : 1 / q * p = p - 1 := by\n    rw [← hpq.div_conj_eq_sub_one]\n    ring\n  simpa only [NNReal.mul_rpow, ← NNReal.rpow_mul, hp₁, hq, one_mul, one_rpow, rpow_one,\n    Pi.one_apply, sum_const, Nat.smul_one_eq_cast] using\n    NNReal.rpow_le_rpow (inner_le_Lp_mul_Lq s 1 f hpq.symm) hpq.nonneg\n\n"}
{"name":"NNReal.isGreatest_Lp","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nf : ι → NNReal\np q : Real\nhpq : p.IsConjExponent q\n⊢ IsGreatest (Set.image (fun g => s.sum fun i => HMul.hMul (f i) (g i)) (setOf fun g => LE.le (s.sum fun i => HPow.hPow (g i) q) 1)) (HPow.hPow (s.sum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p))","decl":"/-- The `L_p` seminorm of a vector `f` is the greatest value of the inner product\n`∑ i ∈ s, f i * g i` over functions `g` of `L_q` seminorm less than or equal to one. -/\ntheorem isGreatest_Lp (f : ι → ℝ≥0) {p q : ℝ} (hpq : p.IsConjExponent q) :\n    IsGreatest ((fun g : ι → ℝ≥0 => ∑ i ∈ s, f i * g i) '' { g | ∑ i ∈ s, g i ^ q ≤ 1 })\n      ((∑ i ∈ s, f i ^ p) ^ (1 / p)) := by\n  constructor\n  · use fun i => f i ^ p / f i / (∑ i ∈ s, f i ^ p) ^ (1 / q)\n    obtain hf | hf := eq_zero_or_pos (∑ i ∈ s, f i ^ p)\n    · simp [hf, hpq.ne_zero, hpq.symm.ne_zero]\n    · have A : p + q - q ≠ 0 := by simp [hpq.ne_zero]\n      have B : ∀ y : ℝ≥0, y * y ^ p / y = y ^ p := by\n        refine fun y => mul_div_cancel_left_of_imp fun h => ?_\n        simp [h, hpq.ne_zero]\n      simp only [Set.mem_setOf_eq, div_rpow, ← sum_div, ← rpow_mul,\n        div_mul_cancel₀ _ hpq.symm.ne_zero, rpow_one, div_le_iff₀ hf, one_mul, hpq.mul_eq_add, ←\n        rpow_sub' A, add_sub_cancel_right, le_refl, true_and, ← mul_div_assoc, B]\n      rw [div_eq_iff, ← rpow_add hf.ne', one_div, one_div, hpq.inv_add_inv_conj, rpow_one]\n      simpa [hpq.symm.ne_zero] using hf.ne'\n  · rintro _ ⟨g, hg, rfl⟩\n    apply le_trans (inner_le_Lp_mul_Lq s f g hpq)\n    simpa only [mul_one] using\n      mul_le_mul_left' (NNReal.rpow_le_one hg (le_of_lt hpq.symm.one_div_pos)) _\n\n"}
{"name":"NNReal.Lp_add_le","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nf g : ι → NNReal\np : Real\nhp : LE.le 1 p\n⊢ LE.le (HPow.hPow (s.sum fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (HDiv.hDiv 1 p)) (HAdd.hAdd (HPow.hPow (s.sum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (s.sum fun i => HPow.hPow (g i) p) (HDiv.hDiv 1 p)))","decl":"/-- **Minkowski inequality**: the `L_p` seminorm of the sum of two vectors is less than or equal\nto the sum of the `L_p`-seminorms of the summands. A version for `NNReal`-valued functions. -/\ntheorem Lp_add_le (f g : ι → ℝ≥0) {p : ℝ} (hp : 1 ≤ p) :\n    (∑ i ∈ s, (f i + g i) ^ p) ^ (1 / p) ≤\n      (∑ i ∈ s, f i ^ p) ^ (1 / p) + (∑ i ∈ s, g i ^ p) ^ (1 / p) := by\n  -- The result is trivial when `p = 1`, so we can assume `1 < p`.\n  rcases eq_or_lt_of_le hp with (rfl | hp)\n  · simp [Finset.sum_add_distrib]\n  have hpq := Real.IsConjExponent.conjExponent hp\n  have := isGreatest_Lp s (f + g) hpq\n  simp only [Pi.add_apply, add_mul, sum_add_distrib] at this\n  rcases this.1 with ⟨φ, hφ, H⟩\n  rw [← H]\n  exact\n    add_le_add ((isGreatest_Lp s f hpq).2 ⟨φ, hφ, rfl⟩) ((isGreatest_Lp s g hpq).2 ⟨φ, hφ, rfl⟩)\n\n"}
{"name":"NNReal.Lp_add_le_tsum","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\nf g : ι → NNReal\np : Real\nhp : LE.le 1 p\nhf : Summable fun i => HPow.hPow (f i) p\nhg : Summable fun i => HPow.hPow (g i) p\n⊢ And (Summable fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (LE.le (HPow.hPow (tsum fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (HDiv.hDiv 1 p)) (HAdd.hAdd (HPow.hPow (tsum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (tsum fun i => HPow.hPow (g i) p) (HDiv.hDiv 1 p))))","decl":"/-- **Minkowski inequality**: the `L_p` seminorm of the infinite sum of two vectors is less than or\nequal to the infinite sum of the `L_p`-seminorms of the summands, if these infinite sums both\nexist. A version for `NNReal`-valued functions. For an alternative version, convenient if the\ninfinite sums are already expressed as `p`-th powers, see `Lp_add_le_hasSum_of_nonneg`. -/\ntheorem Lp_add_le_tsum {f g : ι → ℝ≥0} {p : ℝ} (hp : 1 ≤ p) (hf : Summable fun i => f i ^ p)\n    (hg : Summable fun i => g i ^ p) :\n    (Summable fun i => (f i + g i) ^ p) ∧\n      (∑' i, (f i + g i) ^ p) ^ (1 / p) ≤\n        (∑' i, f i ^ p) ^ (1 / p) + (∑' i, g i ^ p) ^ (1 / p) := by\n  have pos : 0 < p := lt_of_lt_of_le zero_lt_one hp\n  have H₁ : ∀ s : Finset ι,\n      (∑ i ∈ s, (f i + g i) ^ p) ≤\n        ((∑' i, f i ^ p) ^ (1 / p) + (∑' i, g i ^ p) ^ (1 / p)) ^ p := by\n    intro s\n    rw [one_div, ← NNReal.rpow_inv_le_iff pos, ← one_div]\n    refine le_trans (Lp_add_le s f g hp) (add_le_add ?_ ?_) <;>\n        rw [NNReal.rpow_le_rpow_iff (one_div_pos.mpr pos)] <;>\n      refine sum_le_tsum _ (fun _ _ => zero_le _) ?_\n    exacts [hf, hg]\n  have bdd : BddAbove (Set.range fun s => ∑ i ∈ s, (f i + g i) ^ p) := by\n    refine ⟨((∑' i, f i ^ p) ^ (1 / p) + (∑' i, g i ^ p) ^ (1 / p)) ^ p, ?_⟩\n    rintro a ⟨s, rfl⟩\n    exact H₁ s\n  have H₂ : Summable _ := (hasSum_of_isLUB _ (isLUB_ciSup bdd)).summable\n  refine ⟨H₂, ?_⟩\n  rw [one_div, NNReal.rpow_inv_le_iff pos, ← one_div]\n  exact tsum_le_of_sum_le H₂ H₁\n\n"}
{"name":"NNReal.summable_Lp_add","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\nf g : ι → NNReal\np : Real\nhp : LE.le 1 p\nhf : Summable fun i => HPow.hPow (f i) p\nhg : Summable fun i => HPow.hPow (g i) p\n⊢ Summable fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p","decl":"theorem summable_Lp_add {f g : ι → ℝ≥0} {p : ℝ} (hp : 1 ≤ p) (hf : Summable fun i => f i ^ p)\n    (hg : Summable fun i => g i ^ p) : Summable fun i => (f i + g i) ^ p :=\n  (Lp_add_le_tsum hp hf hg).1\n\n"}
{"name":"NNReal.Lp_add_le_tsum'","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\nf g : ι → NNReal\np : Real\nhp : LE.le 1 p\nhf : Summable fun i => HPow.hPow (f i) p\nhg : Summable fun i => HPow.hPow (g i) p\n⊢ LE.le (HPow.hPow (tsum fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (HDiv.hDiv 1 p)) (HAdd.hAdd (HPow.hPow (tsum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (tsum fun i => HPow.hPow (g i) p) (HDiv.hDiv 1 p)))","decl":"theorem Lp_add_le_tsum' {f g : ι → ℝ≥0} {p : ℝ} (hp : 1 ≤ p) (hf : Summable fun i => f i ^ p)\n    (hg : Summable fun i => g i ^ p) :\n    (∑' i, (f i + g i) ^ p) ^ (1 / p) ≤ (∑' i, f i ^ p) ^ (1 / p) + (∑' i, g i ^ p) ^ (1 / p) :=\n  (Lp_add_le_tsum hp hf hg).2\n\n"}
{"name":"NNReal.Lp_add_le_hasSum","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\nf g : ι → NNReal\nA B : NNReal\np : Real\nhp : LE.le 1 p\nhf : HasSum (fun i => HPow.hPow (f i) p) (HPow.hPow A p)\nhg : HasSum (fun i => HPow.hPow (g i) p) (HPow.hPow B p)\n⊢ Exists fun C => And (LE.le C (HAdd.hAdd A B)) (HasSum (fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (HPow.hPow C p))","decl":"/-- **Minkowski inequality**: the `L_p` seminorm of the infinite sum of two vectors is less than or\nequal to the infinite sum of the `L_p`-seminorms of the summands, if these infinite sums both\nexist. A version for `NNReal`-valued functions. For an alternative version, convenient if the\ninfinite sums are not already expressed as `p`-th powers, see `Lp_add_le_tsum_of_nonneg`. -/\ntheorem Lp_add_le_hasSum {f g : ι → ℝ≥0} {A B : ℝ≥0} {p : ℝ} (hp : 1 ≤ p)\n    (hf : HasSum (fun i => f i ^ p) (A ^ p)) (hg : HasSum (fun i => g i ^ p) (B ^ p)) :\n    ∃ C, C ≤ A + B ∧ HasSum (fun i => (f i + g i) ^ p) (C ^ p) := by\n  have hp' : p ≠ 0 := (lt_of_lt_of_le zero_lt_one hp).ne'\n  obtain ⟨H₁, H₂⟩ := Lp_add_le_tsum hp hf.summable hg.summable\n  have hA : A = (∑' i : ι, f i ^ p) ^ (1 / p) := by rw [hf.tsum_eq, rpow_inv_rpow_self hp']\n  have hB : B = (∑' i : ι, g i ^ p) ^ (1 / p) := by rw [hg.tsum_eq, rpow_inv_rpow_self hp']\n  refine ⟨(∑' i, (f i + g i) ^ p) ^ (1 / p), ?_, ?_⟩\n  · simpa [hA, hB] using H₂\n  · simpa only [rpow_self_rpow_inv hp'] using H₁.hasSum\n\n"}
{"name":"Real.inner_le_Lp_mul_Lq","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nf g : ι → Real\np q : Real\nhpq : p.IsConjExponent q\n⊢ LE.le (s.sum fun i => HMul.hMul (f i) (g i)) (HMul.hMul (HPow.hPow (s.sum fun i => HPow.hPow (abs (f i)) p) (HDiv.hDiv 1 p)) (HPow.hPow (s.sum fun i => HPow.hPow (abs (g i)) q) (HDiv.hDiv 1 q)))","decl":"/-- **Hölder inequality**: the scalar product of two functions is bounded by the product of their\n`L^p` and `L^q` norms when `p` and `q` are conjugate exponents. Version for sums over finite sets,\nwith real-valued functions. -/\ntheorem inner_le_Lp_mul_Lq (hpq : IsConjExponent p q) :\n    ∑ i ∈ s, f i * g i ≤ (∑ i ∈ s, |f i| ^ p) ^ (1 / p) * (∑ i ∈ s, |g i| ^ q) ^ (1 / q) := by\n  have :=\n    NNReal.coe_le_coe.2\n      (NNReal.inner_le_Lp_mul_Lq s (fun i => ⟨_, abs_nonneg (f i)⟩) (fun i => ⟨_, abs_nonneg (g i)⟩)\n        hpq)\n  push_cast at this\n  refine le_trans (sum_le_sum fun i _ => ?_) this\n  simp only [← abs_mul, le_abs_self]\n\n"}
{"name":"Real.rpow_sum_le_const_mul_sum_rpow","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nf : ι → Real\np : Real\nhp : LE.le 1 p\n⊢ LE.le (HPow.hPow (s.sum fun i => abs (f i)) p) (HMul.hMul (HPow.hPow (↑s.card) (HSub.hSub p 1)) (s.sum fun i => HPow.hPow (abs (f i)) p))","decl":"/-- For `1 ≤ p`, the `p`-th power of the sum of `f i` is bounded above by a constant times the\nsum of the `p`-th powers of `f i`. Version for sums over finite sets, with `ℝ`-valued functions. -/\ntheorem rpow_sum_le_const_mul_sum_rpow (hp : 1 ≤ p) :\n    (∑ i ∈ s, |f i|) ^ p ≤ (#s : ℝ) ^ (p - 1) * ∑ i ∈ s, |f i| ^ p := by\n  have :=\n    NNReal.coe_le_coe.2\n      (NNReal.rpow_sum_le_const_mul_sum_rpow s (fun i => ⟨_, abs_nonneg (f i)⟩) hp)\n  push_cast at this\n  exact this\n\n-- for some reason `exact_mod_cast` can't replace this argument\n"}
{"name":"Real.Lp_add_le","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nf g : ι → Real\np : Real\nhp : LE.le 1 p\n⊢ LE.le (HPow.hPow (s.sum fun i => HPow.hPow (abs (HAdd.hAdd (f i) (g i))) p) (HDiv.hDiv 1 p)) (HAdd.hAdd (HPow.hPow (s.sum fun i => HPow.hPow (abs (f i)) p) (HDiv.hDiv 1 p)) (HPow.hPow (s.sum fun i => HPow.hPow (abs (g i)) p) (HDiv.hDiv 1 p)))","decl":"/-- **Minkowski inequality**: the `L_p` seminorm of the sum of two vectors is less than or equal\nto the sum of the `L_p`-seminorms of the summands. A version for `Real`-valued functions. -/\ntheorem Lp_add_le (hp : 1 ≤ p) :\n    (∑ i ∈ s, |f i + g i| ^ p) ^ (1 / p) ≤\n      (∑ i ∈ s, |f i| ^ p) ^ (1 / p) + (∑ i ∈ s, |g i| ^ p) ^ (1 / p) := by\n  have :=\n    NNReal.coe_le_coe.2\n      (NNReal.Lp_add_le s (fun i => ⟨_, abs_nonneg (f i)⟩) (fun i => ⟨_, abs_nonneg (g i)⟩) hp)\n  push_cast at this\n  refine le_trans (rpow_le_rpow ?_ (sum_le_sum fun i _ => ?_) ?_) this <;>\n    simp [sum_nonneg, rpow_nonneg, abs_nonneg, le_trans zero_le_one hp, abs_add,\n      rpow_le_rpow]\n\n"}
{"name":"Real.inner_le_Lp_mul_Lq_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nf g : ι → Real\np q : Real\nhpq : p.IsConjExponent q\nhf : ∀ (i : ι), Membership.mem s i → LE.le 0 (f i)\nhg : ∀ (i : ι), Membership.mem s i → LE.le 0 (g i)\n⊢ LE.le (s.sum fun i => HMul.hMul (f i) (g i)) (HMul.hMul (HPow.hPow (s.sum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (s.sum fun i => HPow.hPow (g i) q) (HDiv.hDiv 1 q)))","decl":"/-- **Hölder inequality**: the scalar product of two functions is bounded by the product of their\n`L^p` and `L^q` norms when `p` and `q` are conjugate exponents. Version for sums over finite sets,\nwith real-valued nonnegative functions. -/\ntheorem inner_le_Lp_mul_Lq_of_nonneg (hpq : IsConjExponent p q) (hf : ∀ i ∈ s, 0 ≤ f i)\n    (hg : ∀ i ∈ s, 0 ≤ g i) :\n    ∑ i ∈ s, f i * g i ≤ (∑ i ∈ s, f i ^ p) ^ (1 / p) * (∑ i ∈ s, g i ^ q) ^ (1 / q) := by\n  convert inner_le_Lp_mul_Lq s f g hpq using 3 <;> apply sum_congr rfl <;> intro i hi <;>\n    simp only [abs_of_nonneg, hf i hi, hg i hi]\n\n"}
{"name":"Real.inner_le_weight_mul_Lp_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\np : Real\nhp : LE.le 1 p\nw f : ι → Real\nhw : ∀ (i : ι), LE.le 0 (w i)\nhf : ∀ (i : ι), LE.le 0 (f i)\n⊢ LE.le (s.sum fun i => HMul.hMul (w i) (f i)) (HMul.hMul (HPow.hPow (s.sum fun i => w i) (HSub.hSub 1 (Inv.inv p))) (HPow.hPow (s.sum fun i => HMul.hMul (w i) (HPow.hPow (f i) p)) (Inv.inv p)))","decl":"/-- **Weighted Hölder inequality**. -/\nlemma inner_le_weight_mul_Lp_of_nonneg (s : Finset ι) {p : ℝ} (hp : 1 ≤ p) (w f : ι → ℝ)\n    (hw : ∀ i, 0 ≤ w i) (hf : ∀ i, 0 ≤ f i) :\n    ∑ i ∈ s, w i * f i ≤ (∑ i ∈ s, w i) ^ (1 - p⁻¹) * (∑ i ∈ s, w i * f i ^ p) ^ p⁻¹ := by\n  lift w to ι → ℝ≥0 using hw\n  lift f to ι → ℝ≥0 using hf\n  beta_reduce at *\n  norm_cast at *\n  exact NNReal.inner_le_weight_mul_Lp _ hp _ _\n\n"}
{"name":"Real.compact_inner_le_weight_mul_Lp_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\np : Real\nhp : LE.le 1 p\nw f : ι → Real\nhw : ∀ (i : ι), LE.le 0 (w i)\nhf : ∀ (i : ι), LE.le 0 (f i)\n⊢ LE.le (s.expect fun i => HMul.hMul (w i) (f i)) (HMul.hMul (HPow.hPow (s.expect fun i => w i) (HSub.hSub 1 (Inv.inv p))) (HPow.hPow (s.expect fun i => HMul.hMul (w i) (HPow.hPow (f i) p)) (Inv.inv p)))","decl":"/-- **Weighted Hölder inequality** in terms of `Finset.expect`. -/\nlemma compact_inner_le_weight_mul_Lp_of_nonneg (s : Finset ι) {p : ℝ} (hp : 1 ≤ p) {w f : ι → ℝ}\n    (hw : ∀ i, 0 ≤ w i) (hf : ∀ i, 0 ≤ f i) :\n    𝔼 i ∈ s, w i * f i ≤ (𝔼 i ∈ s, w i) ^ (1 - p⁻¹) * (𝔼 i ∈ s, w i * f i ^ p) ^ p⁻¹ := by\n  simp_rw [expect_eq_sum_div_card]\n  rw [div_rpow, div_rpow, div_mul_div_comm, ← rpow_add', sub_add_cancel, rpow_one]\n  · gcongr\n    exact inner_le_weight_mul_Lp_of_nonneg s hp _ _ hw hf\n  any_goals simp\n  · exact sum_nonneg fun i _ ↦ by have := hw i; have := hf i; positivity\n  · exact sum_nonneg fun i _ ↦ by have := hw i; positivity\n\n"}
{"name":"Real.inner_le_Lp_mul_Lq_tsum_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\nf g : ι → Real\np q : Real\nhpq : p.IsConjExponent q\nhf : ∀ (i : ι), LE.le 0 (f i)\nhg : ∀ (i : ι), LE.le 0 (g i)\nhf_sum : Summable fun i => HPow.hPow (f i) p\nhg_sum : Summable fun i => HPow.hPow (g i) q\n⊢ And (Summable fun i => HMul.hMul (f i) (g i)) (LE.le (tsum fun i => HMul.hMul (f i) (g i)) (HMul.hMul (HPow.hPow (tsum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (tsum fun i => HPow.hPow (g i) q) (HDiv.hDiv 1 q))))","decl":"/-- **Hölder inequality**: the scalar product of two functions is bounded by the product of their\n`L^p` and `L^q` norms when `p` and `q` are conjugate exponents. A version for `ℝ`-valued functions.\nFor an alternative version, convenient if the infinite sums are already expressed as `p`-th powers,\nsee `inner_le_Lp_mul_Lq_hasSum_of_nonneg`. -/\ntheorem inner_le_Lp_mul_Lq_tsum_of_nonneg (hpq : p.IsConjExponent q) (hf : ∀ i, 0 ≤ f i)\n    (hg : ∀ i, 0 ≤ g i) (hf_sum : Summable fun i => f i ^ p) (hg_sum : Summable fun i => g i ^ q) :\n    (Summable fun i => f i * g i) ∧\n      ∑' i, f i * g i ≤ (∑' i, f i ^ p) ^ (1 / p) * (∑' i, g i ^ q) ^ (1 / q) := by\n  lift f to ι → ℝ≥0 using hf\n  lift g to ι → ℝ≥0 using hg\n  -- After https://github.com/leanprover/lean4/pull/2734, `norm_cast` needs help with beta reduction.\n  beta_reduce at *\n  norm_cast at *\n  exact NNReal.inner_le_Lp_mul_Lq_tsum hpq hf_sum hg_sum\n\n"}
{"name":"Real.summable_mul_of_Lp_Lq_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\nf g : ι → Real\np q : Real\nhpq : p.IsConjExponent q\nhf : ∀ (i : ι), LE.le 0 (f i)\nhg : ∀ (i : ι), LE.le 0 (g i)\nhf_sum : Summable fun i => HPow.hPow (f i) p\nhg_sum : Summable fun i => HPow.hPow (g i) q\n⊢ Summable fun i => HMul.hMul (f i) (g i)","decl":"theorem summable_mul_of_Lp_Lq_of_nonneg (hpq : p.IsConjExponent q) (hf : ∀ i, 0 ≤ f i)\n    (hg : ∀ i, 0 ≤ g i) (hf_sum : Summable fun i => f i ^ p) (hg_sum : Summable fun i => g i ^ q) :\n    Summable fun i => f i * g i :=\n  (inner_le_Lp_mul_Lq_tsum_of_nonneg hpq hf hg hf_sum hg_sum).1\n\n"}
{"name":"Real.inner_le_Lp_mul_Lq_tsum_of_nonneg'","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\nf g : ι → Real\np q : Real\nhpq : p.IsConjExponent q\nhf : ∀ (i : ι), LE.le 0 (f i)\nhg : ∀ (i : ι), LE.le 0 (g i)\nhf_sum : Summable fun i => HPow.hPow (f i) p\nhg_sum : Summable fun i => HPow.hPow (g i) q\n⊢ LE.le (tsum fun i => HMul.hMul (f i) (g i)) (HMul.hMul (HPow.hPow (tsum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (tsum fun i => HPow.hPow (g i) q) (HDiv.hDiv 1 q)))","decl":"theorem inner_le_Lp_mul_Lq_tsum_of_nonneg' (hpq : p.IsConjExponent q) (hf : ∀ i, 0 ≤ f i)\n    (hg : ∀ i, 0 ≤ g i) (hf_sum : Summable fun i => f i ^ p) (hg_sum : Summable fun i => g i ^ q) :\n    ∑' i, f i * g i ≤ (∑' i, f i ^ p) ^ (1 / p) * (∑' i, g i ^ q) ^ (1 / q) :=\n  (inner_le_Lp_mul_Lq_tsum_of_nonneg hpq hf hg hf_sum hg_sum).2\n\n"}
{"name":"Real.inner_le_Lp_mul_Lq_hasSum_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\nf g : ι → Real\np q : Real\nhpq : p.IsConjExponent q\nA B : Real\nhA : LE.le 0 A\nhB : LE.le 0 B\nhf : ∀ (i : ι), LE.le 0 (f i)\nhg : ∀ (i : ι), LE.le 0 (g i)\nhf_sum : HasSum (fun i => HPow.hPow (f i) p) (HPow.hPow A p)\nhg_sum : HasSum (fun i => HPow.hPow (g i) q) (HPow.hPow B q)\n⊢ Exists fun C => And (LE.le 0 C) (And (LE.le C (HMul.hMul A B)) (HasSum (fun i => HMul.hMul (f i) (g i)) C))","decl":"/-- **Hölder inequality**: the scalar product of two functions is bounded by the product of their\n`L^p` and `L^q` norms when `p` and `q` are conjugate exponents. A version for `NNReal`-valued\nfunctions. For an alternative version, convenient if the infinite sums are not already expressed as\n`p`-th powers, see `inner_le_Lp_mul_Lq_tsum_of_nonneg`. -/\ntheorem inner_le_Lp_mul_Lq_hasSum_of_nonneg (hpq : p.IsConjExponent q) {A B : ℝ} (hA : 0 ≤ A)\n    (hB : 0 ≤ B) (hf : ∀ i, 0 ≤ f i) (hg : ∀ i, 0 ≤ g i)\n    (hf_sum : HasSum (fun i => f i ^ p) (A ^ p)) (hg_sum : HasSum (fun i => g i ^ q) (B ^ q)) :\n    ∃ C : ℝ, 0 ≤ C ∧ C ≤ A * B ∧ HasSum (fun i => f i * g i) C := by\n  lift f to ι → ℝ≥0 using hf\n  lift g to ι → ℝ≥0 using hg\n  lift A to ℝ≥0 using hA\n  lift B to ℝ≥0 using hB\n  -- After https://github.com/leanprover/lean4/pull/2734, `norm_cast` needs help with beta reduction.\n  beta_reduce at *\n  norm_cast at hf_sum hg_sum\n  obtain ⟨C, hC, H⟩ := NNReal.inner_le_Lp_mul_Lq_hasSum hpq hf_sum hg_sum\n  refine ⟨C, C.prop, hC, ?_⟩\n  norm_cast\n\n"}
{"name":"Real.rpow_sum_le_const_mul_sum_rpow_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nf : ι → Real\np : Real\nhp : LE.le 1 p\nhf : ∀ (i : ι), Membership.mem s i → LE.le 0 (f i)\n⊢ LE.le (HPow.hPow (s.sum fun i => f i) p) (HMul.hMul (HPow.hPow (↑s.card) (HSub.hSub p 1)) (s.sum fun i => HPow.hPow (f i) p))","decl":"/-- For `1 ≤ p`, the `p`-th power of the sum of `f i` is bounded above by a constant times the\nsum of the `p`-th powers of `f i`. Version for sums over finite sets, with nonnegative `ℝ`-valued\nfunctions. -/\ntheorem rpow_sum_le_const_mul_sum_rpow_of_nonneg (hp : 1 ≤ p) (hf : ∀ i ∈ s, 0 ≤ f i) :\n    (∑ i ∈ s, f i) ^ p ≤ (#s : ℝ) ^ (p - 1) * ∑ i ∈ s, f i ^ p := by\n  convert rpow_sum_le_const_mul_sum_rpow s f hp using 2 <;> apply sum_congr rfl <;> intro i hi <;>\n    simp only [abs_of_nonneg, hf i hi]\n\n"}
{"name":"Real.Lp_add_le_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nf g : ι → Real\np : Real\nhp : LE.le 1 p\nhf : ∀ (i : ι), Membership.mem s i → LE.le 0 (f i)\nhg : ∀ (i : ι), Membership.mem s i → LE.le 0 (g i)\n⊢ LE.le (HPow.hPow (s.sum fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (HDiv.hDiv 1 p)) (HAdd.hAdd (HPow.hPow (s.sum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (s.sum fun i => HPow.hPow (g i) p) (HDiv.hDiv 1 p)))","decl":"/-- **Minkowski inequality**: the `L_p` seminorm of the sum of two vectors is less than or equal\nto the sum of the `L_p`-seminorms of the summands. A version for `ℝ`-valued nonnegative\nfunctions. -/\ntheorem Lp_add_le_of_nonneg (hp : 1 ≤ p) (hf : ∀ i ∈ s, 0 ≤ f i) (hg : ∀ i ∈ s, 0 ≤ g i) :\n    (∑ i ∈ s, (f i + g i) ^ p) ^ (1 / p) ≤\n      (∑ i ∈ s, f i ^ p) ^ (1 / p) + (∑ i ∈ s, g i ^ p) ^ (1 / p) := by\n  convert Lp_add_le s f g hp using 2 <;> [skip;congr 1;congr 1] <;> apply sum_congr rfl <;>\n      intro i hi <;>\n    simp only [abs_of_nonneg, hf i hi, hg i hi, add_nonneg]\n\n"}
{"name":"Real.Lp_add_le_tsum_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\nf g : ι → Real\np : Real\nhp : LE.le 1 p\nhf : ∀ (i : ι), LE.le 0 (f i)\nhg : ∀ (i : ι), LE.le 0 (g i)\nhf_sum : Summable fun i => HPow.hPow (f i) p\nhg_sum : Summable fun i => HPow.hPow (g i) p\n⊢ And (Summable fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (LE.le (HPow.hPow (tsum fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (HDiv.hDiv 1 p)) (HAdd.hAdd (HPow.hPow (tsum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (tsum fun i => HPow.hPow (g i) p) (HDiv.hDiv 1 p))))","decl":"/-- **Minkowski inequality**: the `L_p` seminorm of the infinite sum of two vectors is less than or\nequal to the infinite sum of the `L_p`-seminorms of the summands, if these infinite sums both\nexist. A version for `ℝ`-valued functions. For an alternative version, convenient if the infinite\nsums are already expressed as `p`-th powers, see `Lp_add_le_hasSum_of_nonneg`. -/\ntheorem Lp_add_le_tsum_of_nonneg (hp : 1 ≤ p) (hf : ∀ i, 0 ≤ f i) (hg : ∀ i, 0 ≤ g i)\n    (hf_sum : Summable fun i => f i ^ p) (hg_sum : Summable fun i => g i ^ p) :\n    (Summable fun i => (f i + g i) ^ p) ∧\n      (∑' i, (f i + g i) ^ p) ^ (1 / p) ≤\n        (∑' i, f i ^ p) ^ (1 / p) + (∑' i, g i ^ p) ^ (1 / p) := by\n  lift f to ι → ℝ≥0 using hf\n  lift g to ι → ℝ≥0 using hg\n  -- After https://github.com/leanprover/lean4/pull/2734, `norm_cast` needs help with beta reduction.\n  beta_reduce at *\n  norm_cast0 at *\n  exact NNReal.Lp_add_le_tsum hp hf_sum hg_sum\n\n"}
{"name":"Real.summable_Lp_add_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\nf g : ι → Real\np : Real\nhp : LE.le 1 p\nhf : ∀ (i : ι), LE.le 0 (f i)\nhg : ∀ (i : ι), LE.le 0 (g i)\nhf_sum : Summable fun i => HPow.hPow (f i) p\nhg_sum : Summable fun i => HPow.hPow (g i) p\n⊢ Summable fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p","decl":"theorem summable_Lp_add_of_nonneg (hp : 1 ≤ p) (hf : ∀ i, 0 ≤ f i) (hg : ∀ i, 0 ≤ g i)\n    (hf_sum : Summable fun i => f i ^ p) (hg_sum : Summable fun i => g i ^ p) :\n    Summable fun i => (f i + g i) ^ p :=\n  (Lp_add_le_tsum_of_nonneg hp hf hg hf_sum hg_sum).1\n\n"}
{"name":"Real.Lp_add_le_tsum_of_nonneg'","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\nf g : ι → Real\np : Real\nhp : LE.le 1 p\nhf : ∀ (i : ι), LE.le 0 (f i)\nhg : ∀ (i : ι), LE.le 0 (g i)\nhf_sum : Summable fun i => HPow.hPow (f i) p\nhg_sum : Summable fun i => HPow.hPow (g i) p\n⊢ LE.le (HPow.hPow (tsum fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (HDiv.hDiv 1 p)) (HAdd.hAdd (HPow.hPow (tsum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (tsum fun i => HPow.hPow (g i) p) (HDiv.hDiv 1 p)))","decl":"theorem Lp_add_le_tsum_of_nonneg' (hp : 1 ≤ p) (hf : ∀ i, 0 ≤ f i) (hg : ∀ i, 0 ≤ g i)\n    (hf_sum : Summable fun i => f i ^ p) (hg_sum : Summable fun i => g i ^ p) :\n    (∑' i, (f i + g i) ^ p) ^ (1 / p) ≤ (∑' i, f i ^ p) ^ (1 / p) + (∑' i, g i ^ p) ^ (1 / p) :=\n  (Lp_add_le_tsum_of_nonneg hp hf hg hf_sum hg_sum).2\n\n"}
{"name":"Real.Lp_add_le_hasSum_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\nf g : ι → Real\np : Real\nhp : LE.le 1 p\nhf : ∀ (i : ι), LE.le 0 (f i)\nhg : ∀ (i : ι), LE.le 0 (g i)\nA B : Real\nhA : LE.le 0 A\nhB : LE.le 0 B\nhfA : HasSum (fun i => HPow.hPow (f i) p) (HPow.hPow A p)\nhgB : HasSum (fun i => HPow.hPow (g i) p) (HPow.hPow B p)\n⊢ Exists fun C => And (LE.le 0 C) (And (LE.le C (HAdd.hAdd A B)) (HasSum (fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (HPow.hPow C p)))","decl":"/-- **Minkowski inequality**: the `L_p` seminorm of the infinite sum of two vectors is less than or\nequal to the infinite sum of the `L_p`-seminorms of the summands, if these infinite sums both\nexist. A version for `ℝ`-valued functions. For an alternative version, convenient if the infinite\nsums are not already expressed as `p`-th powers, see `Lp_add_le_tsum_of_nonneg`. -/\ntheorem Lp_add_le_hasSum_of_nonneg (hp : 1 ≤ p) (hf : ∀ i, 0 ≤ f i) (hg : ∀ i, 0 ≤ g i) {A B : ℝ}\n    (hA : 0 ≤ A) (hB : 0 ≤ B) (hfA : HasSum (fun i => f i ^ p) (A ^ p))\n    (hgB : HasSum (fun i => g i ^ p) (B ^ p)) :\n    ∃ C, 0 ≤ C ∧ C ≤ A + B ∧ HasSum (fun i => (f i + g i) ^ p) (C ^ p) := by\n  lift f to ι → ℝ≥0 using hf\n  lift g to ι → ℝ≥0 using hg\n  lift A to ℝ≥0 using hA\n  lift B to ℝ≥0 using hB\n  -- After https://github.com/leanprover/lean4/pull/2734, `norm_cast` needs help with beta reduction.\n  beta_reduce at hfA hgB\n  norm_cast at hfA hgB\n  obtain ⟨C, hC₁, hC₂⟩ := NNReal.Lp_add_le_hasSum hp hfA hgB\n  use C\n  -- After https://github.com/leanprover/lean4/pull/2734, `norm_cast` needs help with beta reduction.\n  beta_reduce\n  norm_cast\n  exact ⟨zero_le _, hC₁, hC₂⟩\n\n"}
{"name":"ENNReal.inner_le_Lp_mul_Lq","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nf g : ι → ENNReal\np q : Real\nhpq : p.IsConjExponent q\n⊢ LE.le (s.sum fun i => HMul.hMul (f i) (g i)) (HMul.hMul (HPow.hPow (s.sum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (s.sum fun i => HPow.hPow (g i) q) (HDiv.hDiv 1 q)))","decl":"/-- **Hölder inequality**: the scalar product of two functions is bounded by the product of their\n`L^p` and `L^q` norms when `p` and `q` are conjugate exponents. Version for sums over finite sets,\nwith `ℝ≥0∞`-valued functions. -/\ntheorem inner_le_Lp_mul_Lq (hpq : p.IsConjExponent q) :\n    ∑ i ∈ s, f i * g i ≤ (∑ i ∈ s, f i ^ p) ^ (1 / p) * (∑ i ∈ s, g i ^ q) ^ (1 / q) := by\n  by_cases H : (∑ i ∈ s, f i ^ p) ^ (1 / p) = 0 ∨ (∑ i ∈ s, g i ^ q) ^ (1 / q) = 0\n  · replace H : (∀ i ∈ s, f i = 0) ∨ ∀ i ∈ s, g i = 0 := by\n      simpa [ENNReal.rpow_eq_zero_iff, hpq.pos, hpq.symm.pos, asymm hpq.pos, asymm hpq.symm.pos,\n        sum_eq_zero_iff_of_nonneg] using H\n    have : ∀ i ∈ s, f i * g i = 0 := fun i hi => by cases' H with H H <;> simp [H i hi]\n    simp [sum_eq_zero this]\n  push_neg at H\n  by_cases H' : (∑ i ∈ s, f i ^ p) ^ (1 / p) = ⊤ ∨ (∑ i ∈ s, g i ^ q) ^ (1 / q) = ⊤\n  · cases' H' with H' H' <;> simp [H', -one_div, -sum_eq_zero_iff, -rpow_eq_zero_iff, H]\n  replace H' : (∀ i ∈ s, f i ≠ ⊤) ∧ ∀ i ∈ s, g i ≠ ⊤ := by\n    simpa [ENNReal.rpow_eq_top_iff, asymm hpq.pos, asymm hpq.symm.pos, hpq.pos, hpq.symm.pos,\n      ENNReal.sum_eq_top, not_or] using H'\n  have := ENNReal.coe_le_coe.2 (@NNReal.inner_le_Lp_mul_Lq _ s (fun i => ENNReal.toNNReal (f i))\n    (fun i => ENNReal.toNNReal (g i)) _ _ hpq)\n  simp [ENNReal.coe_rpow_of_nonneg, hpq.pos.le, hpq.one_div_pos.le, hpq.symm.pos.le,\n    hpq.symm.one_div_pos.le] at this\n  convert this using 1 <;> [skip; congr 2] <;> [skip; skip; simp; skip; simp] <;>\n    · refine Finset.sum_congr rfl fun i hi => ?_\n      simp [H'.1 i hi, H'.2 i hi, -WithZero.coe_mul]\n\n"}
{"name":"ENNReal.inner_le_weight_mul_Lp_of_nonneg","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\np : Real\nhp : LE.le 1 p\nw f : ι → ENNReal\n⊢ LE.le (s.sum fun i => HMul.hMul (w i) (f i)) (HMul.hMul (HPow.hPow (s.sum fun i => w i) (HSub.hSub 1 (Inv.inv p))) (HPow.hPow (s.sum fun i => HMul.hMul (w i) (HPow.hPow (f i) p)) (Inv.inv p)))","decl":"/-- **Weighted Hölder inequality**. -/\nlemma inner_le_weight_mul_Lp_of_nonneg (s : Finset ι) {p : ℝ} (hp : 1 ≤ p) (w f : ι → ℝ≥0∞) :\n    ∑ i ∈ s, w i * f i ≤ (∑ i ∈ s, w i) ^ (1 - p⁻¹) * (∑ i ∈ s, w i * f i ^ p) ^ p⁻¹ := by\n  obtain rfl | hp := hp.eq_or_lt\n  · simp\n  have hp₀ : 0 < p := by positivity\n  have hp₁ : p⁻¹ < 1 := inv_lt_one_of_one_lt₀ hp\n  by_cases H : (∑ i ∈ s, w i) ^ (1 - p⁻¹) = 0 ∨ (∑ i ∈ s, w i * f i ^ p) ^ p⁻¹ = 0\n  · replace H : (∀ i ∈ s, w i = 0) ∨ ∀ i ∈ s, w i = 0 ∨ f i = 0 := by\n      simpa [hp₀, hp₁, hp₀.not_lt, hp₁.not_lt, sum_eq_zero_iff_of_nonneg] using H\n    have (i) (hi : i ∈ s) : w i * f i = 0 := by cases' H with H H <;> simp [H i hi]\n    simp [sum_eq_zero this]\n  push_neg at H\n  by_cases H' : (∑ i ∈ s, w i) ^ (1 - p⁻¹) = ⊤ ∨ (∑ i ∈ s, w i * f i ^ p) ^ p⁻¹ = ⊤\n  · cases' H' with H' H' <;> simp [H', -one_div, -sum_eq_zero_iff, -rpow_eq_zero_iff, H]\n  replace H' : (∀ i ∈ s, w i ≠ ⊤) ∧ ∀ i ∈ s, w i * f i ^ p ≠ ⊤ := by\n    simpa [rpow_eq_top_iff,hp₀, hp₁, hp₀.not_lt, hp₁.not_lt, sum_eq_top, not_or] using H'\n  have := coe_le_coe.2 <| NNReal.inner_le_weight_mul_Lp s hp.le (fun i ↦ ENNReal.toNNReal (w i))\n    fun i ↦ ENNReal.toNNReal (f i)\n  rw [coe_mul] at this\n  simp_rw [coe_rpow_of_nonneg _ <| inv_nonneg.2 hp₀.le, coe_finset_sum, ← ENNReal.toNNReal_rpow,\n    ← ENNReal.toNNReal_mul, sum_congr rfl fun i hi ↦ coe_toNNReal (H'.2 i hi)] at this\n  simp [ENNReal.coe_rpow_of_nonneg, hp₀.le, hp₁.le] at this\n  convert this using 2 with i hi\n  · obtain hw | hw := eq_or_ne (w i) 0\n    · simp [hw]\n    rw [coe_toNNReal (H'.1 _ hi), coe_toNNReal]\n    simpa [mul_eq_top, hw, hp₀, hp₀.not_lt, H'.1 _ hi] using H'.2 _ hi\n  · convert rfl with i hi\n    exact coe_toNNReal (H'.1 _ hi)\n\n"}
{"name":"ENNReal.rpow_sum_le_const_mul_sum_rpow","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nf : ι → ENNReal\np : Real\nhp : LE.le 1 p\n⊢ LE.le (HPow.hPow (s.sum fun i => f i) p) (HMul.hMul (HPow.hPow (↑s.card) (HSub.hSub p 1)) (s.sum fun i => HPow.hPow (f i) p))","decl":"/-- For `1 ≤ p`, the `p`-th power of the sum of `f i` is bounded above by a constant times the\nsum of the `p`-th powers of `f i`. Version for sums over finite sets, with `ℝ≥0∞`-valued functions.\n-/\ntheorem rpow_sum_le_const_mul_sum_rpow (hp : 1 ≤ p) :\n    (∑ i ∈ s, f i) ^ p ≤ (card s : ℝ≥0∞) ^ (p - 1) * ∑ i ∈ s, f i ^ p := by\n  cases' eq_or_lt_of_le hp with hp hp\n  · simp [← hp]\n  let q : ℝ := p / (p - 1)\n  have hpq : p.IsConjExponent q := .conjExponent hp\n  have hp₁ : 1 / p * p = 1 := one_div_mul_cancel hpq.ne_zero\n  have hq : 1 / q * p = p - 1 := by\n    rw [← hpq.div_conj_eq_sub_one]\n    ring\n  simpa only [ENNReal.mul_rpow_of_nonneg _ _ hpq.nonneg, ← ENNReal.rpow_mul, hp₁, hq, coe_one,\n    one_mul, one_rpow, rpow_one, Pi.one_apply, sum_const, Nat.smul_one_eq_cast] using\n    ENNReal.rpow_le_rpow (inner_le_Lp_mul_Lq s 1 f hpq.symm) hpq.nonneg\n\n"}
{"name":"ENNReal.Lp_add_le","module":"Mathlib.Analysis.MeanInequalities","initialProofState":"ι : Type u\ns : Finset ι\nf g : ι → ENNReal\np : Real\nhp : LE.le 1 p\n⊢ LE.le (HPow.hPow (s.sum fun i => HPow.hPow (HAdd.hAdd (f i) (g i)) p) (HDiv.hDiv 1 p)) (HAdd.hAdd (HPow.hPow (s.sum fun i => HPow.hPow (f i) p) (HDiv.hDiv 1 p)) (HPow.hPow (s.sum fun i => HPow.hPow (g i) p) (HDiv.hDiv 1 p)))","decl":"/-- **Minkowski inequality**: the `L_p` seminorm of the sum of two vectors is less than or equal\nto the sum of the `L_p`-seminorms of the summands. A version for `ℝ≥0∞` valued nonnegative\nfunctions. -/\ntheorem Lp_add_le (hp : 1 ≤ p) :\n    (∑ i ∈ s, (f i + g i) ^ p) ^ (1 / p) ≤\n      (∑ i ∈ s, f i ^ p) ^ (1 / p) + (∑ i ∈ s, g i ^ p) ^ (1 / p) := by\n  by_cases H' : (∑ i ∈ s, f i ^ p) ^ (1 / p) = ⊤ ∨ (∑ i ∈ s, g i ^ p) ^ (1 / p) = ⊤\n  · cases' H' with H' H' <;> simp [H', -one_div]\n  have pos : 0 < p := lt_of_lt_of_le zero_lt_one hp\n  replace H' : (∀ i ∈ s, f i ≠ ⊤) ∧ ∀ i ∈ s, g i ≠ ⊤ := by\n    simpa [ENNReal.rpow_eq_top_iff, asymm pos, pos, ENNReal.sum_eq_top, not_or] using H'\n  have :=\n    ENNReal.coe_le_coe.2\n      (@NNReal.Lp_add_le _ s (fun i => ENNReal.toNNReal (f i)) (fun i => ENNReal.toNNReal (g i)) _\n        hp)\n  push_cast [ENNReal.coe_rpow_of_nonneg, le_of_lt pos, le_of_lt (one_div_pos.2 pos)] at this\n  convert this using 2 <;> [skip; congr 1; congr 1] <;>\n    · refine Finset.sum_congr rfl fun i hi => ?_\n      simp [H'.1 i hi, H'.2 i hi]\n\n"}
