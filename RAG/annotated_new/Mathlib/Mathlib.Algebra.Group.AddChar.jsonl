{"name":"AddChar.map_zero_eq_one'","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\ninst✝¹ : AddMonoid A\nM : Type u_2\ninst✝ : Monoid M\nself : AddChar A M\n⊢ Eq (self.toFun 0) 1","decl":"/-- `AddChar A M` is the type of maps `A → M`, for `A` an additive monoid and `M` a multiplicative\nmonoid, which intertwine addition in `A` with multiplication in `M`.\n\nWe only put the typeclasses needed for the definition, although in practice we are usually\ninterested in much more specific cases (e.g. when `A` is a group and `M` a commutative ring).\n -/\nstructure AddChar where\n  /-- The underlying function.\n\n  Do not use this function directly. Instead use the coercion coming from the `FunLike`\n  instance. -/\n  toFun : A → M\n  /-- The function maps `0` to `1`.\n\n  Do not use this directly. Instead use `AddChar.map_zero_eq_one`. -/\n  map_zero_eq_one' : toFun 0 = 1\n  /-- The function maps addition in `A` to multiplication in `M`.\n\n  Do not use this directly. Instead use `AddChar.map_add_eq_mul`. -/\n  map_add_eq_mul' : ∀ a b : A, toFun (a + b) = toFun a * toFun b\n\n"}
{"name":"AddChar.mk.sizeOf_spec","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\ninst✝³ : AddMonoid A\nM : Type u_2\ninst✝² : Monoid M\ninst✝¹ : SizeOf A\ninst✝ : SizeOf M\ntoFun : A → M\nmap_zero_eq_one' : Eq (toFun 0) 1\nmap_add_eq_mul' : ∀ (a b : A), Eq (toFun (HAdd.hAdd a b)) (HMul.hMul (toFun a) (toFun b))\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, map_zero_eq_one' := map_zero_eq_one', map_add_eq_mul' := map_add_eq_mul' }) (HAdd.hAdd 1 (SizeOf.sizeOf map_zero_eq_one'))","decl":"/-- `AddChar A M` is the type of maps `A → M`, for `A` an additive monoid and `M` a multiplicative\nmonoid, which intertwine addition in `A` with multiplication in `M`.\n\nWe only put the typeclasses needed for the definition, although in practice we are usually\ninterested in much more specific cases (e.g. when `A` is a group and `M` a commutative ring).\n -/\nstructure AddChar where\n  /-- The underlying function.\n\n  Do not use this function directly. Instead use the coercion coming from the `FunLike`\n  instance. -/\n  toFun : A → M\n  /-- The function maps `0` to `1`.\n\n  Do not use this directly. Instead use `AddChar.map_zero_eq_one`. -/\n  map_zero_eq_one' : toFun 0 = 1\n  /-- The function maps addition in `A` to multiplication in `M`.\n\n  Do not use this directly. Instead use `AddChar.map_add_eq_mul`. -/\n  map_add_eq_mul' : ∀ a b : A, toFun (a + b) = toFun a * toFun b\n\n"}
{"name":"AddChar.map_add_eq_mul'","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\ninst✝¹ : AddMonoid A\nM : Type u_2\ninst✝ : Monoid M\nself : AddChar A M\na b : A\n⊢ Eq (self.toFun (HAdd.hAdd a b)) (HMul.hMul (self.toFun a) (self.toFun b))","decl":"/-- `AddChar A M` is the type of maps `A → M`, for `A` an additive monoid and `M` a multiplicative\nmonoid, which intertwine addition in `A` with multiplication in `M`.\n\nWe only put the typeclasses needed for the definition, although in practice we are usually\ninterested in much more specific cases (e.g. when `A` is a group and `M` a commutative ring).\n -/\nstructure AddChar where\n  /-- The underlying function.\n\n  Do not use this function directly. Instead use the coercion coming from the `FunLike`\n  instance. -/\n  toFun : A → M\n  /-- The function maps `0` to `1`.\n\n  Do not use this directly. Instead use `AddChar.map_zero_eq_one`. -/\n  map_zero_eq_one' : toFun 0 = 1\n  /-- The function maps addition in `A` to multiplication in `M`.\n\n  Do not use this directly. Instead use `AddChar.map_add_eq_mul`. -/\n  map_add_eq_mul' : ∀ a b : A, toFun (a + b) = toFun a * toFun b\n\n"}
{"name":"AddChar.mk.injEq","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\ninst✝¹ : AddMonoid A\nM : Type u_2\ninst✝ : Monoid M\ntoFun✝ : A → M\nmap_zero_eq_one'✝ : Eq (toFun✝ 0) 1\nmap_add_eq_mul'✝ : ∀ (a b : A), Eq (toFun✝ (HAdd.hAdd a b)) (HMul.hMul (toFun✝ a) (toFun✝ b))\ntoFun : A → M\nmap_zero_eq_one' : Eq (toFun 0) 1\nmap_add_eq_mul' : ∀ (a b : A), Eq (toFun (HAdd.hAdd a b)) (HMul.hMul (toFun a) (toFun b))\n⊢ Eq (Eq { toFun := toFun✝, map_zero_eq_one' := map_zero_eq_one'✝, map_add_eq_mul' := map_add_eq_mul'✝ } { toFun := toFun, map_zero_eq_one' := map_zero_eq_one', map_add_eq_mul' := map_add_eq_mul' }) (Eq toFun✝ toFun)","decl":"/-- `AddChar A M` is the type of maps `A → M`, for `A` an additive monoid and `M` a multiplicative\nmonoid, which intertwine addition in `A` with multiplication in `M`.\n\nWe only put the typeclasses needed for the definition, although in practice we are usually\ninterested in much more specific cases (e.g. when `A` is a group and `M` a commutative ring).\n -/\nstructure AddChar where\n  /-- The underlying function.\n\n  Do not use this function directly. Instead use the coercion coming from the `FunLike`\n  instance. -/\n  toFun : A → M\n  /-- The function maps `0` to `1`.\n\n  Do not use this directly. Instead use `AddChar.map_zero_eq_one`. -/\n  map_zero_eq_one' : toFun 0 = 1\n  /-- The function maps addition in `A` to multiplication in `M`.\n\n  Do not use this directly. Instead use `AddChar.map_add_eq_mul`. -/\n  map_add_eq_mul' : ∀ a b : A, toFun (a + b) = toFun a * toFun b\n\n"}
{"name":"AddChar.mk.inj","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\ninst✝¹ : AddMonoid A\nM : Type u_2\ninst✝ : Monoid M\ntoFun✝ : A → M\nmap_zero_eq_one'✝ : Eq (toFun✝ 0) 1\nmap_add_eq_mul'✝ : ∀ (a b : A), Eq (toFun✝ (HAdd.hAdd a b)) (HMul.hMul (toFun✝ a) (toFun✝ b))\ntoFun : A → M\nmap_zero_eq_one' : Eq (toFun 0) 1\nmap_add_eq_mul' : ∀ (a b : A), Eq (toFun (HAdd.hAdd a b)) (HMul.hMul (toFun a) (toFun b))\nx✝ : Eq { toFun := toFun✝, map_zero_eq_one' := map_zero_eq_one'✝, map_add_eq_mul' := map_add_eq_mul'✝ } { toFun := toFun, map_zero_eq_one' := map_zero_eq_one', map_add_eq_mul' := map_add_eq_mul' }\n⊢ Eq toFun✝ toFun","decl":"/-- `AddChar A M` is the type of maps `A → M`, for `A` an additive monoid and `M` a multiplicative\nmonoid, which intertwine addition in `A` with multiplication in `M`.\n\nWe only put the typeclasses needed for the definition, although in practice we are usually\ninterested in much more specific cases (e.g. when `A` is a group and `M` a commutative ring).\n -/\nstructure AddChar where\n  /-- The underlying function.\n\n  Do not use this function directly. Instead use the coercion coming from the `FunLike`\n  instance. -/\n  toFun : A → M\n  /-- The function maps `0` to `1`.\n\n  Do not use this directly. Instead use `AddChar.map_zero_eq_one`. -/\n  map_zero_eq_one' : toFun 0 = 1\n  /-- The function maps addition in `A` to multiplication in `M`.\n\n  Do not use this directly. Instead use `AddChar.map_add_eq_mul`. -/\n  map_add_eq_mul' : ∀ a b : A, toFun (a + b) = toFun a * toFun b\n\n"}
{"name":"AddChar.ext","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nf g : AddChar A M\nh : ∀ (x : A), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext] lemma ext (f g : AddChar A M) (h : ∀ x : A, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"AddChar.ext_iff","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nf g : AddChar A M\n⊢ Iff (Eq f g) (∀ (x : A), Eq (f x) (g x))","decl":"@[ext] lemma ext (f g : AddChar A M) (h : ∀ x : A, f x = g x) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"AddChar.coe_mk","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nf : A → M\nmap_zero_eq_one' : Eq (f 0) 1\nmap_add_eq_mul' : ∀ (a b : A), Eq (f (HAdd.hAdd a b)) (HMul.hMul (f a) (f b))\n⊢ Eq (⇑{ toFun := f, map_zero_eq_one' := map_zero_eq_one', map_add_eq_mul' := map_add_eq_mul' }) f","decl":"@[simp] lemma coe_mk (f : A → M)\n    (map_zero_eq_one' : f 0 = 1) (map_add_eq_mul' : ∀ a b : A, f (a + b) = f a * f b) :\n    AddChar.mk f map_zero_eq_one' map_add_eq_mul' = f := by\n  rfl\n\n"}
{"name":"AddChar.map_zero_eq_one","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nψ : AddChar A M\n⊢ Eq (ψ 0) 1","decl":"/-- An additive character maps `0` to `1`. -/\n@[simp] lemma map_zero_eq_one (ψ : AddChar A M) : ψ 0 = 1 := ψ.map_zero_eq_one'\n\n"}
{"name":"AddChar.map_add_eq_mul","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nψ : AddChar A M\nx y : A\n⊢ Eq (ψ (HAdd.hAdd x y)) (HMul.hMul (ψ x) (ψ y))","decl":"/-- An additive character maps sums to products. -/\nlemma map_add_eq_mul (ψ : AddChar A M) (x y : A) : ψ (x + y) = ψ x * ψ y := ψ.map_add_eq_mul' x y\n\n"}
{"name":"AddChar.toMonoidHom_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nψ : AddChar A M\na : Multiplicative A\n⊢ Eq (ψ.toMonoidHom a) (ψ (Multiplicative.toAdd a))","decl":"@[simp] lemma toMonoidHom_apply (ψ : AddChar A M) (a : Multiplicative A) :\n  ψ.toMonoidHom a = ψ a.toAdd :=\n  rfl\n\n"}
{"name":"AddChar.map_nsmul_eq_pow","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nψ : AddChar A M\nn : Nat\nx : A\n⊢ Eq (ψ (HSMul.hSMul n x)) (HPow.hPow (ψ x) n)","decl":"/-- An additive character maps multiples by natural numbers to powers. -/\nlemma map_nsmul_eq_pow (ψ : AddChar A M) (n : ℕ) (x : A) : ψ (n • x) = ψ x ^ n :=\n  ψ.toMonoidHom.map_pow x n\n\n"}
{"name":"AddChar.coe_toMonoidHomEquiv","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nψ : AddChar A M\n⊢ Eq (⇑(AddChar.toMonoidHomEquiv ψ)) (Function.comp ⇑ψ ⇑Multiplicative.toAdd)","decl":"@[simp, norm_cast] lemma coe_toMonoidHomEquiv (ψ : AddChar A M) :\n    ⇑(toMonoidHomEquiv ψ) = ψ ∘ Multiplicative.toAdd := rfl\n\n"}
{"name":"AddChar.coe_toMonoidHomEquiv_symm","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nψ : MonoidHom (Multiplicative A) M\n⊢ Eq (⇑(AddChar.toMonoidHomEquiv.symm ψ)) (Function.comp ⇑ψ ⇑Multiplicative.ofAdd)","decl":"@[simp, norm_cast] lemma coe_toMonoidHomEquiv_symm (ψ : Multiplicative A →* M) :\n    ⇑(toMonoidHomEquiv.symm ψ) = ψ ∘ Multiplicative.ofAdd := rfl\n\n"}
{"name":"AddChar.toMonoidHomEquiv_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nψ : AddChar A M\na : Multiplicative A\n⊢ Eq ((AddChar.toMonoidHomEquiv ψ) a) (ψ (Multiplicative.toAdd a))","decl":"@[simp] lemma toMonoidHomEquiv_apply (ψ : AddChar A M) (a : Multiplicative A) :\n    toMonoidHomEquiv ψ a = ψ a.toAdd := rfl\n\n"}
{"name":"AddChar.toMonoidHomEquiv_symm_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nψ : MonoidHom (Multiplicative A) M\na : A\n⊢ Eq ((AddChar.toMonoidHomEquiv.symm ψ) a) (ψ (Multiplicative.ofAdd a))","decl":"@[simp] lemma toMonoidHomEquiv_symm_apply (ψ : Multiplicative A →* M) (a : A) :\n    toMonoidHomEquiv.symm ψ a = ψ (Multiplicative.ofAdd a) := rfl\n\n"}
{"name":"AddChar.coe_toAddMonoidHom","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nψ : AddChar A M\n⊢ Eq (⇑ψ.toAddMonoidHom) (Function.comp ⇑Additive.ofMul ⇑ψ)","decl":"@[simp] lemma coe_toAddMonoidHom (ψ : AddChar A M) : ⇑ψ.toAddMonoidHom = Additive.ofMul ∘ ψ := rfl\n\n"}
{"name":"AddChar.toAddMonoidHom_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nψ : AddChar A M\na : A\n⊢ Eq (ψ.toAddMonoidHom a) (Additive.ofMul (ψ a))","decl":"@[simp] lemma toAddMonoidHom_apply (ψ : AddChar A M) (a : A) :\n    ψ.toAddMonoidHom a = Additive.ofMul (ψ a) := rfl\n\n"}
{"name":"AddChar.coe_toAddMonoidHomEquiv","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nψ : AddChar A M\n⊢ Eq (⇑(AddChar.toAddMonoidHomEquiv ψ)) (Function.comp ⇑Additive.ofMul ⇑ψ)","decl":"@[simp, norm_cast]\nlemma coe_toAddMonoidHomEquiv (ψ : AddChar A M) :\n    ⇑(toAddMonoidHomEquiv ψ) = Additive.ofMul ∘ ψ := rfl\n\n"}
{"name":"AddChar.coe_toAddMonoidHomEquiv_symm","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nψ : AddMonoidHom A (Additive M)\n⊢ Eq (⇑(AddChar.toAddMonoidHomEquiv.symm ψ)) (Function.comp ⇑Additive.toMul ⇑ψ)","decl":"@[simp, norm_cast] lemma coe_toAddMonoidHomEquiv_symm (ψ : A →+ Additive M) :\n    ⇑(toAddMonoidHomEquiv.symm ψ) = Additive.toMul ∘ ψ := rfl\n\n"}
{"name":"AddChar.toAddMonoidHomEquiv_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nψ : AddChar A M\na : A\n⊢ Eq ((AddChar.toAddMonoidHomEquiv ψ) a) (Additive.ofMul (ψ a))","decl":"@[simp] lemma toAddMonoidHomEquiv_apply (ψ : AddChar A M) (a : A) :\n    toAddMonoidHomEquiv ψ a = Additive.ofMul (ψ a) := rfl\n\n"}
{"name":"AddChar.toAddMonoidHomEquiv_symm_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nψ : AddMonoidHom A (Additive M)\na : A\n⊢ Eq ((AddChar.toAddMonoidHomEquiv.symm ψ) a) (Additive.toMul (ψ a))","decl":"@[simp] lemma toAddMonoidHomEquiv_symm_apply (ψ : A →+ Additive M) (a : A) :\n    toAddMonoidHomEquiv.symm ψ a = (ψ a).toMul  := rfl\n\n"}
{"name":"AddChar.coe_one","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\n⊢ Eq (⇑1) 1","decl":"@[simp, norm_cast] lemma coe_one : ⇑(1 : AddChar A M) = 1 := rfl\n"}
{"name":"AddChar.coe_zero","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\n⊢ Eq (⇑0) 1","decl":"@[simp, norm_cast] lemma coe_zero : ⇑(0 : AddChar A M) = 1 := rfl\n"}
{"name":"AddChar.one_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\na : A\n⊢ Eq (1 a) 1","decl":"@[simp] lemma one_apply (a : A) : (1 : AddChar A M) a = 1 := rfl\n"}
{"name":"AddChar.zero_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\na : A\n⊢ Eq (0 a) 1","decl":"@[simp] lemma zero_apply (a : A) : (0 : AddChar A M) a = 1 := rfl\n\n"}
{"name":"AddChar.one_eq_zero","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\n⊢ Eq 1 0","decl":"lemma one_eq_zero : (1 : AddChar A M) = (0 : AddChar A M) := rfl\n\n"}
{"name":"AddChar.coe_eq_one","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nψ : AddChar A M\n⊢ Iff (Eq (⇑ψ) 1) (Eq ψ 0)","decl":"@[simp, norm_cast] lemma coe_eq_one : ⇑ψ = 1 ↔ ψ = 0 := by rw [← coe_zero, DFunLike.coe_fn_eq]\n\n"}
{"name":"AddChar.toMonoidHomEquiv_zero","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\n⊢ Eq (AddChar.toMonoidHomEquiv 0) 1","decl":"@[simp] lemma toMonoidHomEquiv_zero : toMonoidHomEquiv (0 : AddChar A M) = 1 := rfl\n"}
{"name":"AddChar.toMonoidHomEquiv_symm_one","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\n⊢ Eq (AddChar.toMonoidHomEquiv.symm 1) 0","decl":"@[simp] lemma toMonoidHomEquiv_symm_one :\n    toMonoidHomEquiv.symm (1 : Multiplicative A →* M) = 0 := rfl\n\n"}
{"name":"AddChar.toAddMonoidHomEquiv_zero","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\n⊢ Eq (AddChar.toAddMonoidHomEquiv 0) 0","decl":"@[simp] lemma toAddMonoidHomEquiv_zero : toAddMonoidHomEquiv (0 : AddChar A M) = 0 := rfl\n"}
{"name":"AddChar.toAddMonoidHomEquiv_symm_zero","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\n⊢ Eq (AddChar.toAddMonoidHomEquiv.symm 0) 0","decl":"@[simp] lemma toAddMonoidHomEquiv_symm_zero :\n    toAddMonoidHomEquiv.symm (0 : A →+ Additive M) = 0 := rfl\n\n"}
{"name":"MonoidHom.coe_compAddChar","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝² : AddMonoid A\ninst✝¹ : Monoid M\nN : Type u_5\ninst✝ : Monoid N\nf : MonoidHom M N\nφ : AddChar A M\n⊢ Eq (⇑(f.compAddChar φ)) (Function.comp ⇑f ⇑φ)","decl":"@[simp, norm_cast]\nlemma _root_.MonoidHom.coe_compAddChar {N : Type*} [Monoid N] (f : M →* N) (φ : AddChar A M) :\n    f.compAddChar φ = f ∘ φ :=\n  rfl\n\n"}
{"name":"MonoidHom.compAddChar_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝² : AddMonoid A\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nf : MonoidHom M N\nφ : AddChar A M\n⊢ Eq (⇑(f.compAddChar φ)) (Function.comp ⇑f ⇑φ)","decl":"@[simp, norm_cast]\nlemma _root_.MonoidHom.compAddChar_apply (f : M →* N) (φ : AddChar A M) : f.compAddChar φ = f ∘ φ :=\n  rfl\n\n"}
{"name":"MonoidHom.compAddChar_injective_left","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝² : AddMonoid A\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nψ : AddChar A M\nhψ : Function.Surjective ⇑ψ\n⊢ Function.Injective fun f => f.compAddChar ψ","decl":"lemma _root_.MonoidHom.compAddChar_injective_left (ψ : AddChar A M) (hψ : Surjective ψ) :\n    Injective fun f : M →* N ↦ f.compAddChar ψ := by\n  rintro f g h; rw [DFunLike.ext'_iff] at h ⊢; exact hψ.injective_comp_right h\n\n"}
{"name":"MonoidHom.compAddChar_injective_right","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"B : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝² : AddMonoid B\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nf : MonoidHom M N\nhf : Function.Injective ⇑f\n⊢ Function.Injective fun ψ => f.compAddChar ψ","decl":"lemma _root_.MonoidHom.compAddChar_injective_right (f : M →* N) (hf : Injective f) :\n    Injective fun ψ : AddChar B M ↦ f.compAddChar ψ := by\n  rintro ψ χ h; rw [DFunLike.ext'_iff] at h ⊢; exact hf.comp_left h\n\n"}
{"name":"AddChar.coe_compAddMonoidHom","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nB : Type u_2\nM : Type u_3\ninst✝² : AddMonoid A\ninst✝¹ : AddMonoid B\ninst✝ : Monoid M\nφ : AddChar B M\nf : AddMonoidHom A B\n⊢ Eq (⇑(φ.compAddMonoidHom f)) (Function.comp ⇑φ ⇑f)","decl":"@[simp, norm_cast]\nlemma coe_compAddMonoidHom (φ : AddChar B M) (f : A →+ B) : φ.compAddMonoidHom f = φ ∘ f := rfl\n\n"}
{"name":"AddChar.compAddMonoidHom_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nB : Type u_2\nM : Type u_3\ninst✝² : AddMonoid A\ninst✝¹ : AddMonoid B\ninst✝ : Monoid M\nψ : AddChar B M\nf : AddMonoidHom A B\na : A\n⊢ Eq ((ψ.compAddMonoidHom f) a) (ψ (f a))","decl":"@[simp] lemma compAddMonoidHom_apply (ψ : AddChar B M) (f : A →+ B)\n    (a : A) : ψ.compAddMonoidHom f a = ψ (f a) := rfl\n\n"}
{"name":"AddChar.compAddMonoidHom_injective_left","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nB : Type u_2\nM : Type u_3\ninst✝² : AddMonoid A\ninst✝¹ : AddMonoid B\ninst✝ : Monoid M\nf : AddMonoidHom A B\nhf : Function.Surjective ⇑f\n⊢ Function.Injective fun ψ => ψ.compAddMonoidHom f","decl":"lemma compAddMonoidHom_injective_left (f : A →+ B) (hf : Surjective f) :\n    Injective fun ψ : AddChar B M ↦ ψ.compAddMonoidHom f := by\n  rintro ψ χ h; rw [DFunLike.ext'_iff] at h ⊢; exact hf.injective_comp_right h\n\n"}
{"name":"AddChar.compAddMonoidHom_injective_right","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nB : Type u_2\nM : Type u_3\ninst✝² : AddMonoid A\ninst✝¹ : AddMonoid B\ninst✝ : Monoid M\nψ : AddChar B M\nhψ : Function.Injective ⇑ψ\n⊢ Function.Injective fun f => ψ.compAddMonoidHom f","decl":"lemma compAddMonoidHom_injective_right (ψ : AddChar B M) (hψ : Injective ψ) :\n    Injective fun f : A →+ B ↦ ψ.compAddMonoidHom f := by\n  rintro f g h\n  rw [DFunLike.ext'_iff] at h ⊢; exact hψ.comp_left h\n\n"}
{"name":"AddChar.eq_one_iff","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nψ : AddChar A M\n⊢ Iff (Eq ψ 1) (∀ (x : A), Eq (ψ x) 1)","decl":"lemma eq_one_iff : ψ = 1 ↔ ∀ x, ψ x = 1 := DFunLike.ext_iff\n"}
{"name":"AddChar.eq_zero_iff","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nψ : AddChar A M\n⊢ Iff (Eq ψ 0) (∀ (x : A), Eq (ψ x) 1)","decl":"lemma eq_zero_iff : ψ = 0 ↔ ∀ x, ψ x = 1 := DFunLike.ext_iff\n"}
{"name":"AddChar.ne_one_iff","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nψ : AddChar A M\n⊢ Iff (Ne ψ 1) (Exists fun x => Ne (ψ x) 1)","decl":"lemma ne_one_iff : ψ ≠ 1 ↔ ∃ x, ψ x ≠ 1 := DFunLike.ne_iff\n"}
{"name":"AddChar.ne_zero_iff","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : Monoid M\nψ : AddChar A M\n⊢ Iff (Ne ψ 0) (Exists fun x => Ne (ψ x) 1)","decl":"lemma ne_zero_iff : ψ ≠ 0 ↔ ∃ x, ψ x ≠ 1 := DFunLike.ne_iff\n\n"}
{"name":"AddChar.coe_mul","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_2\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : CommMonoid M\nψ χ : AddChar A M\n⊢ Eq (⇑(HMul.hMul ψ χ)) (HMul.hMul ⇑ψ ⇑χ)","decl":"@[simp, norm_cast] lemma coe_mul (ψ χ : AddChar A M) : ⇑(ψ * χ) = ψ * χ := rfl\n"}
{"name":"AddChar.coe_add","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_2\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : CommMonoid M\nψ χ : AddChar A M\n⊢ Eq (⇑(HAdd.hAdd ψ χ)) (HMul.hMul ⇑ψ ⇑χ)","decl":"@[simp, norm_cast] lemma coe_add (ψ χ : AddChar A M) : ⇑(ψ + χ) = ψ * χ := rfl\n"}
{"name":"AddChar.coe_pow","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_2\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : CommMonoid M\nψ : AddChar A M\nn : Nat\n⊢ Eq (⇑(HPow.hPow ψ n)) (HPow.hPow (⇑ψ) n)","decl":"@[simp, norm_cast] lemma coe_pow (ψ : AddChar A M) (n : ℕ) : ⇑(ψ ^ n) = ψ ^ n := rfl\n"}
{"name":"AddChar.coe_nsmul","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_2\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : CommMonoid M\nn : Nat\nψ : AddChar A M\n⊢ Eq (⇑(HSMul.hSMul n ψ)) (HPow.hPow (⇑ψ) n)","decl":"@[simp, norm_cast] lemma coe_nsmul (n : ℕ) (ψ : AddChar A M) : ⇑(n • ψ) = ψ ^ n := rfl\n\n"}
{"name":"AddChar.coe_prod","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"ι : Type u_1\nA : Type u_2\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : CommMonoid M\ns : Finset ι\nψ : ι → AddChar A M\n⊢ Eq (⇑(s.prod fun i => ψ i)) (s.prod fun i => ⇑(ψ i))","decl":"@[simp, norm_cast]\nlemma coe_prod (s : Finset ι) (ψ : ι → AddChar A M) : ∏ i ∈ s, ψ i = ∏ i ∈ s, ⇑(ψ i) := by\n  induction s using Finset.cons_induction <;> simp [*]\n\n"}
{"name":"AddChar.coe_sum","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"ι : Type u_1\nA : Type u_2\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : CommMonoid M\ns : Finset ι\nψ : ι → AddChar A M\n⊢ Eq (⇑(s.sum fun i => ψ i)) (s.prod fun i => ⇑(ψ i))","decl":"@[simp, norm_cast]\nlemma coe_sum (s : Finset ι) (ψ : ι → AddChar A M) : ∑ i ∈ s, ψ i = ∏ i ∈ s, ⇑(ψ i) := by\n  induction s using Finset.cons_induction <;> simp [*]\n\n"}
{"name":"AddChar.mul_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_2\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : CommMonoid M\nψ φ : AddChar A M\na : A\n⊢ Eq ((HMul.hMul ψ φ) a) (HMul.hMul (ψ a) (φ a))","decl":"@[simp] lemma mul_apply (ψ φ : AddChar A M) (a : A) : (ψ * φ) a = ψ a * φ a := rfl\n"}
{"name":"AddChar.add_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_2\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : CommMonoid M\nψ φ : AddChar A M\na : A\n⊢ Eq ((HAdd.hAdd ψ φ) a) (HMul.hMul (ψ a) (φ a))","decl":"@[simp] lemma add_apply (ψ φ : AddChar A M) (a : A) : (ψ + φ) a = ψ a * φ a := rfl\n"}
{"name":"AddChar.pow_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_2\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : CommMonoid M\nψ : AddChar A M\nn : Nat\na : A\n⊢ Eq ((HPow.hPow ψ n) a) (HPow.hPow (ψ a) n)","decl":"@[simp] lemma pow_apply (ψ : AddChar A M) (n : ℕ) (a : A) : (ψ ^ n) a = (ψ a) ^ n := rfl\n"}
{"name":"AddChar.nsmul_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_2\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : CommMonoid M\nψ : AddChar A M\nn : Nat\na : A\n⊢ Eq ((HSMul.hSMul n ψ) a) (HPow.hPow (ψ a) n)","decl":"@[simp] lemma nsmul_apply (ψ : AddChar A M) (n : ℕ) (a : A) : (n • ψ) a = (ψ a) ^ n := rfl\n\n"}
{"name":"AddChar.prod_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"ι : Type u_1\nA : Type u_2\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : CommMonoid M\ns : Finset ι\nψ : ι → AddChar A M\na : A\n⊢ Eq ((s.prod fun i => ψ i) a) (s.prod fun i => (ψ i) a)","decl":"lemma prod_apply (s : Finset ι) (ψ : ι → AddChar A M) (a : A) :\n    (∏ i ∈ s, ψ i) a = ∏ i ∈ s, ψ i a := by rw [coe_prod, Finset.prod_apply]\n\n"}
{"name":"AddChar.sum_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"ι : Type u_1\nA : Type u_2\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : CommMonoid M\ns : Finset ι\nψ : ι → AddChar A M\na : A\n⊢ Eq ((s.sum fun i => ψ i) a) (s.prod fun i => (ψ i) a)","decl":"lemma sum_apply (s : Finset ι) (ψ : ι → AddChar A M) (a : A) :\n    (∑ i ∈ s, ψ i) a = ∏ i ∈ s, ψ i a := by rw [coe_sum, Finset.prod_apply]\n\n"}
{"name":"AddChar.mul_eq_add","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_2\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : CommMonoid M\nψ χ : AddChar A M\n⊢ Eq (HMul.hMul ψ χ) (HAdd.hAdd ψ χ)","decl":"lemma mul_eq_add (ψ χ : AddChar A M) : ψ * χ = ψ + χ := rfl\n"}
{"name":"AddChar.pow_eq_nsmul","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_2\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : CommMonoid M\nψ : AddChar A M\nn : Nat\n⊢ Eq (HPow.hPow ψ n) (HSMul.hSMul n ψ)","decl":"lemma pow_eq_nsmul (ψ : AddChar A M) (n : ℕ) : ψ ^ n = n • ψ := rfl\n"}
{"name":"AddChar.prod_eq_sum","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"ι : Type u_1\nA : Type u_2\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : CommMonoid M\ns : Finset ι\nψ : ι → AddChar A M\n⊢ Eq (s.prod fun i => ψ i) (s.sum fun i => ψ i)","decl":"lemma prod_eq_sum (s : Finset ι) (ψ : ι → AddChar A M) : ∏ i ∈ s, ψ i = ∑ i ∈ s, ψ i := rfl\n\n"}
{"name":"AddChar.toMonoidHomEquiv_add","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_2\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : CommMonoid M\nψ φ : AddChar A M\n⊢ Eq (AddChar.toMonoidHomEquiv (HAdd.hAdd ψ φ)) (HMul.hMul (AddChar.toMonoidHomEquiv ψ) (AddChar.toMonoidHomEquiv φ))","decl":"@[simp] lemma toMonoidHomEquiv_add (ψ φ : AddChar A M) :\n    toMonoidHomEquiv (ψ + φ) = toMonoidHomEquiv ψ * toMonoidHomEquiv φ := rfl\n"}
{"name":"AddChar.toMonoidHomEquiv_symm_mul","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_2\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : CommMonoid M\nψ φ : MonoidHom (Multiplicative A) M\n⊢ Eq (AddChar.toMonoidHomEquiv.symm (HMul.hMul ψ φ)) (HAdd.hAdd (AddChar.toMonoidHomEquiv.symm ψ) (AddChar.toMonoidHomEquiv.symm φ))","decl":"@[simp] lemma toMonoidHomEquiv_symm_mul (ψ φ : Multiplicative A →* M) :\n    toMonoidHomEquiv.symm (ψ * φ) = toMonoidHomEquiv.symm ψ + toMonoidHomEquiv.symm φ := rfl\n\n"}
{"name":"AddChar.doubleDualEmb_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_2\nM : Type u_3\ninst✝¹ : AddMonoid A\ninst✝ : CommMonoid M\na : A\nψ : AddChar A M\n⊢ Eq ((AddChar.doubleDualEmb a) ψ) (ψ a)","decl":"@[simp] lemma doubleDualEmb_apply (a : A) (ψ : AddChar A M) : doubleDualEmb a ψ = ψ a := rfl\n\n"}
{"name":"AddChar.sum_eq_ite","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nR : Type u_2\ninst✝⁴ : AddGroup A\ninst✝³ : Fintype A\ninst✝² : CommSemiring R\ninst✝¹ : IsDomain R\nψ : AddChar A R\ninst✝ : Decidable (Eq ψ 0)\n⊢ Eq (Finset.univ.sum fun a => ψ a) (ite (Eq ψ 0) (↑(Fintype.card A)) 0)","decl":"lemma sum_eq_ite (ψ : AddChar A R) [Decidable (ψ = 0)] :\n    ∑ a, ψ a = if ψ = 0 then ↑(card A) else 0 := by\n  split_ifs with h\n  · simp [h, card_univ]\n  obtain ⟨x, hx⟩ := ne_one_iff.1 h\n  refine eq_zero_of_mul_eq_self_left hx ?_\n  rw [Finset.mul_sum]\n  exact Fintype.sum_equiv (Equiv.addLeft x) _ _ fun y ↦ (map_add_eq_mul ..).symm\n\n"}
{"name":"AddChar.sum_eq_zero_iff_ne_zero","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nR : Type u_2\ninst✝⁴ : AddGroup A\ninst✝³ : Fintype A\ninst✝² : CommSemiring R\ninst✝¹ : IsDomain R\nψ : AddChar A R\ninst✝ : CharZero R\n⊢ Iff (Eq (Finset.univ.sum fun x => ψ x) 0) (Ne ψ 0)","decl":"lemma sum_eq_zero_iff_ne_zero : ∑ x, ψ x = 0 ↔ ψ ≠ 0 := by\n  classical\n  rw [sum_eq_ite, Ne.ite_eq_right_iff]; exact Nat.cast_ne_zero.2 Fintype.card_ne_zero\n\n"}
{"name":"AddChar.sum_ne_zero_iff_eq_zero","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nR : Type u_2\ninst✝⁴ : AddGroup A\ninst✝³ : Fintype A\ninst✝² : CommSemiring R\ninst✝¹ : IsDomain R\nψ : AddChar A R\ninst✝ : CharZero R\n⊢ Iff (Ne (Finset.univ.sum fun x => ψ x) 0) (Eq ψ 0)","decl":"lemma sum_ne_zero_iff_eq_zero : ∑ x, ψ x ≠ 0 ↔ ψ = 0 := sum_eq_zero_iff_ne_zero.not_left\n\n"}
{"name":"AddChar.inv_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_2\ninst✝¹ : AddCommGroup A\ninst✝ : CommMonoid M\nψ : AddChar A M\na : A\n⊢ Eq ((Inv.inv ψ) a) (ψ (Neg.neg a))","decl":"@[simp] lemma inv_apply (ψ : AddChar A M) (a : A) : ψ⁻¹ a = ψ (-a) := rfl\n"}
{"name":"AddChar.neg_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_2\ninst✝¹ : AddCommGroup A\ninst✝ : CommMonoid M\nψ : AddChar A M\na : A\n⊢ Eq ((Neg.neg ψ) a) (ψ (Neg.neg a))","decl":"@[simp] lemma neg_apply (ψ : AddChar A M) (a : A) : (-ψ) a = ψ (-a) := rfl\n"}
{"name":"AddChar.div_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_2\ninst✝¹ : AddCommGroup A\ninst✝ : CommMonoid M\nψ χ : AddChar A M\na : A\n⊢ Eq ((HDiv.hDiv ψ χ) a) (HMul.hMul (ψ a) (χ (Neg.neg a)))","decl":"lemma div_apply (ψ χ : AddChar A M) (a : A) : (ψ / χ) a = ψ a * χ (-a) := rfl\n"}
{"name":"AddChar.sub_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_2\ninst✝¹ : AddCommGroup A\ninst✝ : CommMonoid M\nψ χ : AddChar A M\na : A\n⊢ Eq ((HSub.hSub ψ χ) a) (HMul.hMul (ψ a) (χ (Neg.neg a)))","decl":"lemma sub_apply (ψ χ : AddChar A M) (a : A) : (ψ - χ) a = ψ a * χ (-a) := rfl\n\n"}
{"name":"AddChar.val_isUnit","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_2\ninst✝¹ : AddGroup A\ninst✝ : Monoid M\nφ : AddChar A M\na : A\n⊢ IsUnit (φ a)","decl":"/-- The values of an additive character on an additive group are units. -/\nlemma val_isUnit {A M} [AddGroup A] [Monoid M] (φ : AddChar A M) (a : A) : IsUnit (φ a) :=\n  IsUnit.map φ.toMonoidHom <| Group.isUnit (Multiplicative.ofAdd a)\n\n"}
{"name":"AddChar.map_neg_eq_inv","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_2\ninst✝¹ : AddGroup A\ninst✝ : DivisionMonoid M\nψ : AddChar A M\na : A\n⊢ Eq (ψ (Neg.neg a)) (Inv.inv (ψ a))","decl":"/-- An additive character maps negatives to inverses (when defined) -/\nlemma map_neg_eq_inv (ψ : AddChar A M) (a : A) : ψ (-a) = (ψ a)⁻¹ := by\n  apply eq_inv_of_mul_eq_one_left\n  simp only [← map_add_eq_mul, neg_add_cancel, map_zero_eq_one]\n\n"}
{"name":"AddChar.map_zsmul_eq_zpow","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_2\ninst✝¹ : AddGroup A\ninst✝ : DivisionMonoid M\nψ : AddChar A M\nn : Int\na : A\n⊢ Eq (ψ (HSMul.hSMul n a)) (HPow.hPow (ψ a) n)","decl":"/-- An additive character maps integer scalar multiples to integer powers. -/\nlemma map_zsmul_eq_zpow (ψ : AddChar A M) (n : ℤ) (a : A) : ψ (n • a) = (ψ a) ^ n :=\n  ψ.toMonoidHom.map_zpow a n\n\n"}
{"name":"AddChar.inv_apply'","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_2\ninst✝¹ : AddCommGroup A\ninst✝ : DivisionCommMonoid M\nψ : AddChar A M\na : A\n⊢ Eq ((Inv.inv ψ) a) (Inv.inv (ψ a))","decl":"lemma inv_apply' (ψ : AddChar A M) (a : A) : ψ⁻¹ a = (ψ a)⁻¹ := by rw [inv_apply, map_neg_eq_inv]\n"}
{"name":"AddChar.neg_apply'","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_2\ninst✝¹ : AddCommGroup A\ninst✝ : DivisionCommMonoid M\nψ : AddChar A M\na : A\n⊢ Eq ((Neg.neg ψ) a) (Inv.inv (ψ a))","decl":"lemma neg_apply' (ψ : AddChar A M) (a : A) : (-ψ) a = (ψ a)⁻¹ := map_neg_eq_inv _ _\n\n"}
{"name":"AddChar.div_apply'","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_2\ninst✝¹ : AddCommGroup A\ninst✝ : DivisionCommMonoid M\nψ χ : AddChar A M\na : A\n⊢ Eq ((HDiv.hDiv ψ χ) a) (HDiv.hDiv (ψ a) (χ a))","decl":"lemma div_apply' (ψ χ : AddChar A M) (a : A) : (ψ / χ) a = ψ a / χ a := by\n  rw [div_apply, map_neg_eq_inv, div_eq_mul_inv]\n\n"}
{"name":"AddChar.sub_apply'","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_2\ninst✝¹ : AddCommGroup A\ninst✝ : DivisionCommMonoid M\nψ χ : AddChar A M\na : A\n⊢ Eq ((HSub.hSub ψ χ) a) (HDiv.hDiv (ψ a) (χ a))","decl":"lemma sub_apply' (ψ χ : AddChar A M) (a : A) : (ψ - χ) a = ψ a / χ a := by\n  rw [sub_apply, map_neg_eq_inv, div_eq_mul_inv]\n\n"}
{"name":"AddChar.zsmul_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_2\ninst✝¹ : AddCommGroup A\ninst✝ : DivisionCommMonoid M\nn : Int\nψ : AddChar A M\na : A\n⊢ Eq ((HSMul.hSMul n ψ) a) (HPow.hPow (ψ a) n)","decl":"@[simp] lemma zsmul_apply (n : ℤ) (ψ : AddChar A M) (a : A) : (n • ψ) a = ψ a ^ n := by\n  cases n <;> simp [-neg_apply, neg_apply']\n\n"}
{"name":"AddChar.zpow_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_2\ninst✝¹ : AddCommGroup A\ninst✝ : DivisionCommMonoid M\nψ : AddChar A M\nn : Int\na : A\n⊢ Eq ((HPow.hPow ψ n) a) (HPow.hPow (ψ a) n)","decl":"@[simp] lemma zpow_apply (ψ : AddChar A M) (n : ℤ) (a : A) : (ψ ^ n) a = ψ a ^ n := zsmul_apply ..\n\n"}
{"name":"AddChar.map_sub_eq_div","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_2\ninst✝¹ : AddCommGroup A\ninst✝ : DivisionCommMonoid M\nψ : AddChar A M\na b : A\n⊢ Eq (ψ (HSub.hSub a b)) (HDiv.hDiv (ψ a) (ψ b))","decl":"lemma map_sub_eq_div (ψ : AddChar A M) (a b : A) : ψ (a - b) = ψ a / ψ b :=\n  ψ.toMonoidHom.map_div _ _\n\n"}
{"name":"AddChar.injective_iff","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM : Type u_2\ninst✝¹ : AddCommGroup A\ninst✝ : DivisionCommMonoid M\nψ : AddChar A M\n⊢ Iff (Function.Injective ⇑ψ) (∀ ⦃x : A⦄, Eq (ψ x) 1 → Eq x 0)","decl":"lemma injective_iff {ψ : AddChar A M} : Injective ψ ↔ ∀ ⦃x⦄, ψ x = 1 → x = 0 :=\n  ψ.toMonoidHom.ker_eq_bot_iff.symm.trans eq_bot_iff\n\n"}
{"name":"AddChar.coe_ne_zero","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"A : Type u_1\nM₀ : Type u_2\ninst✝² : AddGroup A\ninst✝¹ : MonoidWithZero M₀\ninst✝ : Nontrivial M₀\nψ : AddChar A M₀\n⊢ Ne (⇑ψ) 0","decl":"@[simp] lemma coe_ne_zero (ψ : AddChar A M₀) : (ψ : A → M₀) ≠ 0 :=\n  ne_iff.2 ⟨0, fun h ↦ by simpa only [h, Pi.zero_apply, zero_ne_one] using map_zero_eq_one ψ⟩\n\n"}
{"name":"AddChar.mulShift_apply","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : Ring R\ninst✝ : CommMonoid M\nψ : AddChar R M\nr x : R\n⊢ Eq ((ψ.mulShift r) x) (ψ (HMul.hMul r x))","decl":"@[simp] lemma mulShift_apply {ψ : AddChar R M} {r : R} {x : R} : mulShift ψ r x = ψ (r * x) :=\n  rfl\n\n"}
{"name":"AddChar.inv_mulShift","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : Ring R\ninst✝ : CommMonoid M\nψ : AddChar R M\n⊢ Eq (Inv.inv ψ) (ψ.mulShift (-1))","decl":"/-- `ψ⁻¹ = mulShift ψ (-1))`. -/\ntheorem inv_mulShift (ψ : AddChar R M) : ψ⁻¹ = mulShift ψ (-1) := by\n  ext\n  rw [inv_apply, mulShift_apply, neg_mul, one_mul]\n\n"}
{"name":"AddChar.mulShift_spec'","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : Ring R\ninst✝ : CommMonoid M\nψ : AddChar R M\nn : Nat\nx : R\n⊢ Eq ((ψ.mulShift ↑n) x) (HPow.hPow (ψ x) n)","decl":"/-- If `n` is a natural number, then `mulShift ψ n x = (ψ x) ^ n`. -/\ntheorem mulShift_spec' (ψ : AddChar R M) (n : ℕ) (x : R) : mulShift ψ n x = ψ x ^ n := by\n  rw [mulShift_apply, ← nsmul_eq_mul, map_nsmul_eq_pow]\n\n"}
{"name":"AddChar.pow_mulShift","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : Ring R\ninst✝ : CommMonoid M\nψ : AddChar R M\nn : Nat\n⊢ Eq (HPow.hPow ψ n) (ψ.mulShift ↑n)","decl":"/-- If `n` is a natural number, then `ψ ^ n = mulShift ψ n`. -/\ntheorem pow_mulShift (ψ : AddChar R M) (n : ℕ) : ψ ^ n = mulShift ψ n := by\n  ext x\n  rw [pow_apply, ← mulShift_spec']\n\n"}
{"name":"AddChar.mulShift_mul","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : Ring R\ninst✝ : CommMonoid M\nψ : AddChar R M\nr s : R\n⊢ Eq (HMul.hMul (ψ.mulShift r) (ψ.mulShift s)) (ψ.mulShift (HAdd.hAdd r s))","decl":"/-- The product of `mulShift ψ r` and `mulShift ψ s` is `mulShift ψ (r + s)`. -/\ntheorem mulShift_mul (ψ : AddChar R M) (r s : R) :\n    mulShift ψ r * mulShift ψ s = mulShift ψ (r + s) := by\n  ext\n  rw [mulShift_apply, right_distrib, map_add_eq_mul]; norm_cast\n\n"}
{"name":"AddChar.mulShift_mulShift","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : Ring R\ninst✝ : CommMonoid M\nψ : AddChar R M\nr s : R\n⊢ Eq ((ψ.mulShift r).mulShift s) (ψ.mulShift (HMul.hMul r s))","decl":"lemma mulShift_mulShift (ψ : AddChar R M) (r s : R) :\n    mulShift (mulShift ψ r) s = mulShift ψ (r * s) := by\n  ext\n  simp only [mulShift_apply, mul_assoc]\n\n"}
{"name":"AddChar.mulShift_zero","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : Ring R\ninst✝ : CommMonoid M\nψ : AddChar R M\n⊢ Eq (ψ.mulShift 0) 1","decl":"/-- `mulShift ψ 0` is the trivial character. -/\n@[simp]\ntheorem mulShift_zero (ψ : AddChar R M) : mulShift ψ 0 = 1 := by\n  ext; rw [mulShift_apply, zero_mul, map_zero_eq_one, one_apply]\n\n"}
{"name":"AddChar.mulShift_one","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : Ring R\ninst✝ : CommMonoid M\nψ : AddChar R M\n⊢ Eq (ψ.mulShift 1) ψ","decl":"@[simp]\nlemma mulShift_one (ψ : AddChar R M) : mulShift ψ 1 = ψ := by\n  ext; rw [mulShift_apply, one_mul]\n\n"}
{"name":"AddChar.mulShift_unit_eq_one_iff","module":"Mathlib.Algebra.Group.AddChar","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝¹ : Ring R\ninst✝ : CommMonoid M\nψ : AddChar R M\nu : R\nhu : IsUnit u\n⊢ Iff (Eq (ψ.mulShift u) 1) (Eq ψ 1)","decl":"lemma mulShift_unit_eq_one_iff (ψ : AddChar R M) {u : R} (hu : IsUnit u) :\n    ψ.mulShift u = 1 ↔ ψ = 1 := by\n  refine ⟨fun h ↦ ?_, ?_⟩\n  · ext1 y\n    rw [show y = u * (hu.unit⁻¹ * y) by rw [← mul_assoc, IsUnit.mul_val_inv, one_mul]]\n    simpa only [mulShift_apply] using DFunLike.ext_iff.mp h (hu.unit⁻¹ * y)\n  · rintro rfl\n    ext1 y\n    rw [mulShift_apply, one_apply, one_apply]\n\n"}
