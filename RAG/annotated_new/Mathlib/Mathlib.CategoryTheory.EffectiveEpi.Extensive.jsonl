{"name":"CategoryTheory.effectiveEpi_desc_iff_effectiveEpiFamily","module":"Mathlib.CategoryTheory.EffectiveEpi.Extensive","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.FinitaryPreExtensive C\nα : Type\ninst✝ : Finite α\nB : C\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\n⊢ Iff (CategoryTheory.EffectiveEpi (CategoryTheory.Limits.Sigma.desc π)) (CategoryTheory.EffectiveEpiFamily X π)","decl":"theorem effectiveEpi_desc_iff_effectiveEpiFamily {α : Type} [Finite α]\n    {B : C} (X : α → C) (π : (a : α) → X a ⟶ B) :\n    EffectiveEpi (Sigma.desc π) ↔ EffectiveEpiFamily X π := by\n  exact ⟨fun h ↦ ⟨⟨@effectiveEpiFamilyStructOfEffectiveEpiDesc _ _ _ _ X π _ h _ _ (fun g ↦\n    (FinitaryPreExtensive.sigma_desc_iso (fun a ↦ Sigma.ι X a) g inferInstance).epi_of_iso)⟩⟩,\n    fun _ ↦ inferInstance⟩\n\n"}
{"name":"CategoryTheory.instReflectsFiniteEffectiveEpiFamiliesOfReflectsEffectiveEpis","module":"Mathlib.CategoryTheory.EffectiveEpi.Extensive","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝ : F.ReflectsEffectiveEpis\n⊢ F.ReflectsFiniteEffectiveEpiFamilies","decl":"instance [F.ReflectsEffectiveEpis] : F.ReflectsFiniteEffectiveEpiFamilies where\n  reflects {α _ B} X π h := by\n    simp only [← effectiveEpi_desc_iff_effectiveEpiFamily]\n    apply F.effectiveEpi_of_map\n    convert (inferInstance :\n      EffectiveEpi (inv (sigmaComparison F X) ≫ (Sigma.desc (fun a ↦ F.map (π a)))))\n    simp\n\n"}
{"name":"CategoryTheory.instPreservesFiniteEffectiveEpiFamiliesOfPreservesEffectiveEpis","module":"Mathlib.CategoryTheory.EffectiveEpi.Extensive","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\ninst✝ : F.PreservesEffectiveEpis\n⊢ F.PreservesFiniteEffectiveEpiFamilies","decl":"instance [F.PreservesEffectiveEpis] : F.PreservesFiniteEffectiveEpiFamilies where\n  preserves {α _ B} X π h := by\n    simp only [← effectiveEpi_desc_iff_effectiveEpiFamily]\n    convert (inferInstance :\n      EffectiveEpi ((sigmaComparison F X) ≫ (F.map (Sigma.desc π))))\n    simp\n\n"}
