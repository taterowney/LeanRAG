{"name":"Matrix.charmatrix_apply","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nn : Type u_4\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\ni j : n\n⊢ Eq (M.charmatrix i j) (HSub.hSub (Matrix.diagonal (fun x => Polynomial.X) i j) (Polynomial.C (M i j)))","decl":"theorem charmatrix_apply :\n    charmatrix M i j = (Matrix.diagonal fun _ : n => X) i j - C (M i j) :=\n  rfl\n\n"}
{"name":"Matrix.charmatrix_apply_eq","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nn : Type u_4\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\ni : n\n⊢ Eq (M.charmatrix i i) (HSub.hSub Polynomial.X (Polynomial.C (M i i)))","decl":"@[simp]\ntheorem charmatrix_apply_eq : charmatrix M i i = (X : R[X]) - C (M i i) := by\n  simp only [charmatrix, RingHom.mapMatrix_apply, sub_apply, scalar_apply, map_apply,\n    diagonal_apply_eq]\n\n"}
{"name":"Matrix.charmatrix_apply_ne","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nn : Type u_4\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\ni j : n\nh : Ne i j\n⊢ Eq (M.charmatrix i j) (Neg.neg (Polynomial.C (M i j)))","decl":"@[simp]\ntheorem charmatrix_apply_ne (h : i ≠ j) : charmatrix M i j = -C (M i j) := by\n  simp only [charmatrix, RingHom.mapMatrix_apply, sub_apply, scalar_apply, diagonal_apply_ne _ h,\n    map_apply, sub_eq_neg_self]\n\n"}
{"name":"Matrix.matPolyEquiv_charmatrix","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nn : Type u_4\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\n⊢ Eq (matPolyEquiv M.charmatrix) (HSub.hSub Polynomial.X (Polynomial.C M))","decl":"theorem matPolyEquiv_charmatrix : matPolyEquiv (charmatrix M) = X - C M := by\n  ext k i j\n  simp only [matPolyEquiv_coeff_apply, coeff_sub, Pi.sub_apply]\n  by_cases h : i = j\n  · subst h\n    rw [charmatrix_apply_eq, coeff_sub]\n    simp only [coeff_X, coeff_C]\n    split_ifs <;> simp\n  · rw [charmatrix_apply_ne _ _ _ h, coeff_X, coeff_neg, coeff_C, coeff_C]\n    split_ifs <;> simp [h]\n\n"}
{"name":"Matrix.charmatrix_reindex","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nm : Type u_3\nn : Type u_4\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\ninst✝¹ : Fintype m\ninst✝ : Fintype n\nM : Matrix n n R\ne : Equiv n m\n⊢ Eq ((Matrix.reindex e e) M).charmatrix ((Matrix.reindex e e) M.charmatrix)","decl":"theorem charmatrix_reindex (e : n ≃ m) :\n    charmatrix (reindex e e M) = reindex e e (charmatrix M) := by\n  ext i j x\n  by_cases h : i = j\n  all_goals simp [h]\n\n"}
{"name":"Matrix.charmatrix_map","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\nn : Type u_4\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\nf : RingHom R S\n⊢ Eq (M.map ⇑f).charmatrix (M.charmatrix.map (Polynomial.map f))","decl":"lemma charmatrix_map (M : Matrix n n R) (f : R →+* S) :\n    charmatrix (M.map f) = (charmatrix M).map (Polynomial.map f) := by\n  ext i j\n  by_cases h : i = j <;> simp [h, charmatrix, diagonal]\n\n"}
{"name":"Matrix.charmatrix_fromBlocks","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nm : Type u_3\nn : Type u_4\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\ninst✝¹ : Fintype m\ninst✝ : Fintype n\nM₁₁ : Matrix m m R\nM₁₂ : Matrix m n R\nM₂₁ : Matrix n m R\nM₂₂ : Matrix n n R\n⊢ Eq (Matrix.fromBlocks M₁₁ M₁₂ M₂₁ M₂₂).charmatrix (Matrix.fromBlocks M₁₁.charmatrix (Neg.neg (M₁₂.map ⇑Polynomial.C)) (Neg.neg (M₂₁.map ⇑Polynomial.C)) M₂₂.charmatrix)","decl":"lemma charmatrix_fromBlocks :\n    charmatrix (fromBlocks M₁₁ M₁₂ M₂₁ M₂₂) =\n      fromBlocks (charmatrix M₁₁) (- M₁₂.map C) (- M₂₁.map C) (charmatrix M₂₂) := by\n  simp only [charmatrix]\n  ext (i|i) (j|j) : 2 <;> simp [diagonal]\n\n-- TODO: importing block triangular here is somewhat expensive, if more lemmas about it are added\n-- to this file, it may be worth extracting things out to Charpoly/Block.lean\n"}
{"name":"Matrix.charmatrix_blockTriangular_iff","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nn : Type u_4\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nα : Type u_5\ninst✝ : Preorder α\nM : Matrix n n R\nb : n → α\n⊢ Iff (M.charmatrix.BlockTriangular b) (M.BlockTriangular b)","decl":"@[simp]\nlemma charmatrix_blockTriangular_iff {α : Type*} [Preorder α] {M : Matrix n n R} {b : n → α} :\n    M.charmatrix.BlockTriangular b ↔ M.BlockTriangular b := by\n  rw [charmatrix, scalar_apply, RingHom.mapMatrix_apply, (blockTriangular_diagonal _).sub_iff_right]\n  simp [BlockTriangular]\n\n"}
{"name":"Matrix.BlockTriangular.of_charmatrix","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nn : Type u_4\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nα : Type u_5\ninst✝ : Preorder α\nM : Matrix n n R\nb : n → α\na✝ : M.charmatrix.BlockTriangular b\n⊢ M.BlockTriangular b","decl":"alias ⟨BlockTriangular.of_charmatrix, BlockTriangular.charmatrix⟩ := charmatrix_blockTriangular_iff\n\n"}
{"name":"Matrix.BlockTriangular.charmatrix","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nn : Type u_4\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nα : Type u_5\ninst✝ : Preorder α\nM : Matrix n n R\nb : n → α\na✝ : M.BlockTriangular b\n⊢ M.charmatrix.BlockTriangular b","decl":"alias ⟨BlockTriangular.of_charmatrix, BlockTriangular.charmatrix⟩ := charmatrix_blockTriangular_iff\n\n"}
{"name":"Matrix.charpoly_reindex","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nm : Type u_3\nn : Type u_4\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\ninst✝¹ : Fintype m\ninst✝ : Fintype n\ne : Equiv n m\nM : Matrix n n R\n⊢ Eq ((Matrix.reindex e e) M).charpoly M.charpoly","decl":"theorem charpoly_reindex (e : n ≃ m)\n    (M : Matrix n n R) : (reindex e e M).charpoly = M.charpoly := by\n  unfold Matrix.charpoly\n  rw [charmatrix_reindex, Matrix.det_reindex_self]\n\n"}
{"name":"Matrix.charpoly_map","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\nn : Type u_4\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\nf : RingHom R S\n⊢ Eq (M.map ⇑f).charpoly (Polynomial.map f M.charpoly)","decl":"lemma charpoly_map (M : Matrix n n R) (f : R →+* S) :\n    (M.map f).charpoly = M.charpoly.map f := by\n  rw [charpoly, charmatrix_map, ← Polynomial.coe_mapRingHom, charpoly, RingHom.map_det,\n    RingHom.mapMatrix_apply]\n\n"}
{"name":"Matrix.charpoly_fromBlocks_zero₁₂","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nm : Type u_3\nn : Type u_4\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\ninst✝¹ : Fintype m\ninst✝ : Fintype n\nM₁₁ : Matrix m m R\nM₂₁ : Matrix n m R\nM₂₂ : Matrix n n R\n⊢ Eq (Matrix.fromBlocks M₁₁ 0 M₂₁ M₂₂).charpoly (HMul.hMul M₁₁.charpoly M₂₂.charpoly)","decl":"@[simp]\nlemma charpoly_fromBlocks_zero₁₂ :\n    (fromBlocks M₁₁ 0 M₂₁ M₂₂).charpoly = (M₁₁.charpoly * M₂₂.charpoly) := by\n  simp only [charpoly, charmatrix_fromBlocks, Matrix.map_zero _ (Polynomial.C_0), neg_zero,\n    det_fromBlocks_zero₁₂]\n\n"}
{"name":"Matrix.charpoly_fromBlocks_zero₂₁","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nm : Type u_3\nn : Type u_4\ninst✝³ : DecidableEq m\ninst✝² : DecidableEq n\ninst✝¹ : Fintype m\ninst✝ : Fintype n\nM₁₁ : Matrix m m R\nM₁₂ : Matrix m n R\nM₂₂ : Matrix n n R\n⊢ Eq (Matrix.fromBlocks M₁₁ M₁₂ 0 M₂₂).charpoly (HMul.hMul M₁₁.charpoly M₂₂.charpoly)","decl":"@[simp]\nlemma charpoly_fromBlocks_zero₂₁ :\n    (fromBlocks M₁₁ M₁₂ 0 M₂₂).charpoly = (M₁₁.charpoly * M₂₂.charpoly) := by\n  simp only [charpoly, charmatrix_fromBlocks, Matrix.map_zero _ (Polynomial.C_0), neg_zero,\n    det_fromBlocks_zero₂₁]\n\n"}
{"name":"Matrix.charmatrix_toSquareBlock","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nn : Type u_4\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nM : Matrix n n R\nα : Type u_5\ninst✝ : DecidableEq α\nb : n → α\na : α\n⊢ Eq (M.toSquareBlock b a).charmatrix (M.charmatrix.toSquareBlock b a)","decl":"lemma charmatrix_toSquareBlock {α : Type*} [DecidableEq α] {b : n → α} {a : α} :\n    (M.toSquareBlock b a).charmatrix = M.charmatrix.toSquareBlock b a := by\n  ext i j : 1\n  simp [charmatrix_apply, toSquareBlock_def, diagonal_apply, Subtype.ext_iff]\n\n"}
{"name":"Matrix.BlockTriangular.charpoly","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nn : Type u_4\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\nM : Matrix n n R\nα : Type u_5\nb : n → α\ninst✝ : LinearOrder α\nh : M.BlockTriangular b\n⊢ Eq M.charpoly ((Finset.image b Finset.univ).prod fun a => (M.toSquareBlock b a).charpoly)","decl":"lemma BlockTriangular.charpoly {α : Type*} {b : n → α} [LinearOrder α] (h : M.BlockTriangular b) :\n    M.charpoly = ∏ a ∈ image b univ, (M.toSquareBlock b a).charpoly := by\n  simp only [Matrix.charpoly, h.charmatrix.det, charmatrix_toSquareBlock]\n\n"}
{"name":"Matrix.charpoly_of_upperTriangular","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Basic","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nn : Type u_4\ninst✝² : DecidableEq n\ninst✝¹ : Fintype n\ninst✝ : LinearOrder n\nM : Matrix n n R\nh : M.BlockTriangular id\n⊢ Eq M.charpoly (Finset.univ.prod fun i => HSub.hSub Polynomial.X (Polynomial.C (M i i)))","decl":"lemma charpoly_of_upperTriangular [LinearOrder n] (M : Matrix n n R) (h : M.BlockTriangular id) :\n    M.charpoly = ∏ i : n, (X - C (M i i)) := by\n  simp [charpoly, det_of_upperTriangular h.charmatrix]\n\n-- This proof follows http://drorbn.net/AcademicPensieve/2015-12/CayleyHamilton.pdf\n"}
{"name":"Matrix.aeval_self_charpoly","module":"Mathlib.LinearAlgebra.Matrix.Charpoly.Basic","initialProofState":"R : Type u_1\ninst✝² : CommRing R\nn : Type u_4\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\n⊢ Eq ((Polynomial.aeval M) M.charpoly) 0","decl":"/-- The **Cayley-Hamilton Theorem**, that the characteristic polynomial of a matrix,\napplied to the matrix itself, is zero.\n\nThis holds over any commutative ring.\n\nSee `LinearMap.aeval_self_charpoly` for the equivalent statement about endomorphisms.\n-/\ntheorem aeval_self_charpoly (M : Matrix n n R) : aeval M M.charpoly = 0 := by\n  -- We begin with the fact $χ_M(t) I = adjugate (t I - M) * (t I - M)$,\n  -- as an identity in `Matrix n n R[X]`.\n  have h : M.charpoly • (1 : Matrix n n R[X]) = adjugate (charmatrix M) * charmatrix M :=\n    (adjugate_mul _).symm\n  -- Using the algebra isomorphism `Matrix n n R[X] ≃ₐ[R] Polynomial (Matrix n n R)`,\n  -- we have the same identity in `Polynomial (Matrix n n R)`.\n  apply_fun matPolyEquiv at h\n  simp only [_root_.map_mul, matPolyEquiv_charmatrix] at h\n  -- Because the coefficient ring `Matrix n n R` is non-commutative,\n  -- evaluation at `M` is not multiplicative.\n  -- However, any polynomial which is a product of the form $N * (t I - M)$\n  -- is sent to zero, because the evaluation function puts the polynomial variable\n  -- to the right of any coefficients, so everything telescopes.\n  apply_fun fun p => p.eval M at h\n  rw [eval_mul_X_sub_C] at h\n  -- Now $χ_M (t) I$, when thought of as a polynomial of matrices\n  -- and evaluated at some `N` is exactly $χ_M (N)$.\n  rw [matPolyEquiv_smul_one, eval_map] at h\n  -- Thus we have $χ_M(M) = 0$, which is the desired result.\n  exact h\n\n"}
