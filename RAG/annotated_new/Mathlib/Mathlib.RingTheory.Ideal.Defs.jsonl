{"name":"Ideal.zero_mem","module":"Mathlib.RingTheory.Ideal.Defs","initialProofState":"α : Type u\ninst✝ : Semiring α\nI : Ideal α\n⊢ Membership.mem I 0","decl":"protected theorem zero_mem : (0 : α) ∈ I :=\n  Submodule.zero_mem I\n\n"}
{"name":"Ideal.add_mem","module":"Mathlib.RingTheory.Ideal.Defs","initialProofState":"α : Type u\ninst✝ : Semiring α\nI : Ideal α\na b : α\na✝¹ : Membership.mem I a\na✝ : Membership.mem I b\n⊢ Membership.mem I (HAdd.hAdd a b)","decl":"protected theorem add_mem : a ∈ I → b ∈ I → a + b ∈ I :=\n  Submodule.add_mem I\n\n"}
{"name":"Ideal.mul_mem_left","module":"Mathlib.RingTheory.Ideal.Defs","initialProofState":"α : Type u\ninst✝ : Semiring α\nI : Ideal α\na b : α\na✝ : Membership.mem I b\n⊢ Membership.mem I (HMul.hMul a b)","decl":"theorem mul_mem_left : b ∈ I → a * b ∈ I :=\n  Submodule.smul_mem I a\n\n"}
{"name":"Ideal.ext","module":"Mathlib.RingTheory.Ideal.Defs","initialProofState":"α : Type u\ninst✝ : Semiring α\nI J : Ideal α\nh : ∀ (x : α), Iff (Membership.mem I x) (Membership.mem J x)\n⊢ Eq I J","decl":"@[ext]\ntheorem ext {I J : Ideal α} (h : ∀ x, x ∈ I ↔ x ∈ J) : I = J :=\n  Submodule.ext h\n\n"}
{"name":"Ideal.ext_iff","module":"Mathlib.RingTheory.Ideal.Defs","initialProofState":"α : Type u\ninst✝ : Semiring α\nI J : Ideal α\n⊢ Iff (Eq I J) (∀ (x : α), Iff (Membership.mem I x) (Membership.mem J x))","decl":"@[ext]\ntheorem ext {I J : Ideal α} (h : ∀ x, x ∈ I ↔ x ∈ J) : I = J :=\n  Submodule.ext h\n\n"}
{"name":"Ideal.unit_mul_mem_iff_mem","module":"Mathlib.RingTheory.Ideal.Defs","initialProofState":"α : Type u\ninst✝ : Semiring α\nI : Ideal α\nx y : α\nhy : IsUnit y\n⊢ Iff (Membership.mem I (HMul.hMul y x)) (Membership.mem I x)","decl":"@[simp]\ntheorem unit_mul_mem_iff_mem {x y : α} (hy : IsUnit y) : y * x ∈ I ↔ x ∈ I := by\n  refine ⟨fun h => ?_, fun h => I.mul_mem_left y h⟩\n  obtain ⟨y', hy'⟩ := hy.exists_left_inv\n  have := I.mul_mem_left y' h\n  rwa [← mul_assoc, hy', one_mul] at this\n\n"}
{"name":"Ideal.pow_mem_of_mem","module":"Mathlib.RingTheory.Ideal.Defs","initialProofState":"α : Type u\ninst✝ : Semiring α\nI : Ideal α\na : α\nha : Membership.mem I a\nn : Nat\nhn : LT.lt 0 n\n⊢ Membership.mem I (HPow.hPow a n)","decl":"theorem pow_mem_of_mem (ha : a ∈ I) (n : ℕ) (hn : 0 < n) : a ^ n ∈ I :=\n  Nat.casesOn n (Not.elim (by decide))\n    (fun m _hm => (pow_succ a m).symm ▸ I.mul_mem_left (a ^ m) ha) hn\n\n"}
{"name":"Ideal.pow_mem_of_pow_mem","module":"Mathlib.RingTheory.Ideal.Defs","initialProofState":"α : Type u\ninst✝ : Semiring α\nI : Ideal α\na : α\nm n : Nat\nha : Membership.mem I (HPow.hPow a m)\nh : LE.le m n\n⊢ Membership.mem I (HPow.hPow a n)","decl":"theorem pow_mem_of_pow_mem {m n : ℕ} (ha : a ^ m ∈ I) (h : m ≤ n) : a ^ n ∈ I := by\n  rw [← Nat.add_sub_of_le h, add_comm, pow_add]\n  exact I.mul_mem_left _ ha\n\n"}
{"name":"Ideal.mul_unit_mem_iff_mem","module":"Mathlib.RingTheory.Ideal.Defs","initialProofState":"α : Type u\ninst✝ : CommSemiring α\nI : Ideal α\nx y : α\nhy : IsUnit y\n⊢ Iff (Membership.mem I (HMul.hMul x y)) (Membership.mem I x)","decl":"@[simp]\ntheorem mul_unit_mem_iff_mem {x y : α} (hy : IsUnit y) : x * y ∈ I ↔ x ∈ I :=\n  mul_comm y x ▸ unit_mul_mem_iff_mem I hy\n\n"}
{"name":"Ideal.mul_mem_right","module":"Mathlib.RingTheory.Ideal.Defs","initialProofState":"α : Type u\na b : α\ninst✝ : CommSemiring α\nI : Ideal α\nh : Membership.mem I a\n⊢ Membership.mem I (HMul.hMul a b)","decl":"theorem mul_mem_right (h : a ∈ I) : a * b ∈ I :=\n  mul_comm b a ▸ I.mul_mem_left b h\n\n"}
{"name":"Ideal.mem_of_dvd","module":"Mathlib.RingTheory.Ideal.Defs","initialProofState":"α : Type u\na b : α\ninst✝ : CommSemiring α\nI : Ideal α\nhab : Dvd.dvd a b\nha : Membership.mem I a\n⊢ Membership.mem I b","decl":"lemma mem_of_dvd (hab : a ∣ b) (ha : a ∈ I) : b ∈ I := by\n  obtain ⟨c, rfl⟩ := hab; exact I.mul_mem_right _ ha\n\n"}
{"name":"Ideal.neg_mem_iff","module":"Mathlib.RingTheory.Ideal.Defs","initialProofState":"α : Type u\ninst✝ : Ring α\nI : Ideal α\na : α\n⊢ Iff (Membership.mem I (Neg.neg a)) (Membership.mem I a)","decl":"protected theorem neg_mem_iff : -a ∈ I ↔ a ∈ I :=\n  Submodule.neg_mem_iff I\n\n"}
{"name":"Ideal.add_mem_iff_left","module":"Mathlib.RingTheory.Ideal.Defs","initialProofState":"α : Type u\ninst✝ : Ring α\nI : Ideal α\na b : α\na✝ : Membership.mem I b\n⊢ Iff (Membership.mem I (HAdd.hAdd a b)) (Membership.mem I a)","decl":"protected theorem add_mem_iff_left : b ∈ I → (a + b ∈ I ↔ a ∈ I) :=\n  Submodule.add_mem_iff_left I\n\n"}
{"name":"Ideal.add_mem_iff_right","module":"Mathlib.RingTheory.Ideal.Defs","initialProofState":"α : Type u\ninst✝ : Ring α\nI : Ideal α\na b : α\na✝ : Membership.mem I a\n⊢ Iff (Membership.mem I (HAdd.hAdd a b)) (Membership.mem I b)","decl":"protected theorem add_mem_iff_right : a ∈ I → (a + b ∈ I ↔ b ∈ I) :=\n  Submodule.add_mem_iff_right I\n\n"}
{"name":"Ideal.sub_mem","module":"Mathlib.RingTheory.Ideal.Defs","initialProofState":"α : Type u\ninst✝ : Ring α\nI : Ideal α\na b : α\na✝¹ : Membership.mem I a\na✝ : Membership.mem I b\n⊢ Membership.mem I (HSub.hSub a b)","decl":"protected theorem sub_mem : a ∈ I → b ∈ I → a - b ∈ I :=\n  Submodule.sub_mem I\n\n"}
{"name":"Ideal.mul_sub_mul_mem","module":"Mathlib.RingTheory.Ideal.Defs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nI : Ideal R\na b c d : R\nh1 : Membership.mem I (HSub.hSub a b)\nh2 : Membership.mem I (HSub.hSub c d)\n⊢ Membership.mem I (HSub.hSub (HMul.hMul a c) (HMul.hMul b d))","decl":"theorem mul_sub_mul_mem {R : Type*} [CommRing R] (I : Ideal R) {a b c d : R} (h1 : a - b ∈ I)\n    (h2 : c - d ∈ I) : a * c - b * d ∈ I := by\n  rw [show a * c - b * d = (a - b) * c + b * (c - d) by rw [sub_mul, mul_sub]; abel]\n  exact I.add_mem (I.mul_mem_right _ h1) (I.mul_mem_left _ h2)\n\n"}
