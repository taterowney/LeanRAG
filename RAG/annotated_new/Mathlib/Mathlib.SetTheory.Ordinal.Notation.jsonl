{"name":"ONote.oadd.injEq","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"a✝⁵ : ONote\na✝⁴ : PNat\na✝³ a✝² : ONote\na✝¹ : PNat\na✝ : ONote\n⊢ Eq (Eq (a✝⁵.oadd a✝⁴ a✝³) (a✝².oadd a✝¹ a✝)) (And (Eq a✝⁵ a✝²) (And (Eq a✝⁴ a✝¹) (Eq a✝³ a✝)))","decl":"set_option genSizeOfSpec false in\n/-- Recursive definition of an ordinal notation. `zero` denotes the ordinal 0, and `oadd e n a` is\nintended to refer to `ω ^ e * n + a`. For this to be a valid Cantor normal form, we must have the\nexponents decrease to the right, but we can't state this condition until we've defined `repr`, so we\nmake it a separate definition `NF`. -/\ninductive ONote : Type\n  | zero : ONote\n  | oadd : ONote → ℕ+ → ONote → ONote\n  deriving DecidableEq\n\n"}
{"name":"ONote.oadd.inj","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"a✝⁵ : ONote\na✝⁴ : PNat\na✝³ a✝² : ONote\na✝¹ : PNat\na✝ : ONote\nx✝ : Eq (a✝⁵.oadd a✝⁴ a✝³) (a✝².oadd a✝¹ a✝)\n⊢ And (Eq a✝⁵ a✝²) (And (Eq a✝⁴ a✝¹) (Eq a✝³ a✝))","decl":"set_option genSizeOfSpec false in\n/-- Recursive definition of an ordinal notation. `zero` denotes the ordinal 0, and `oadd e n a` is\nintended to refer to `ω ^ e * n + a`. For this to be a valid Cantor normal form, we must have the\nexponents decrease to the right, but we can't state this condition until we've defined `repr`, so we\nmake it a separate definition `NF`. -/\ninductive ONote : Type\n  | zero : ONote\n  | oadd : ONote → ℕ+ → ONote → ONote\n  deriving DecidableEq\n\n"}
{"name":"ONote.zero_def","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"⊢ Eq ONote.zero 0","decl":"@[simp]\ntheorem zero_def : zero = 0 :=\n  rfl\n\n"}
{"name":"ONote.repr_zero","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"⊢ Eq (ONote.repr 0) 0","decl":"@[simp] theorem repr_zero : repr 0 = 0 := rfl\n"}
{"name":"ONote.lt_def","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"x y : ONote\n⊢ Iff (LT.lt x y) (LT.lt x.repr y.repr)","decl":"theorem lt_def {x y : ONote} : x < y ↔ repr x < repr y :=\n  Iff.rfl\n\n"}
{"name":"ONote.le_def","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"x y : ONote\n⊢ Iff (LE.le x y) (LE.le x.repr y.repr)","decl":"theorem le_def {x y : ONote} : x ≤ y ↔ repr x ≤ repr y :=\n  Iff.rfl\n\n"}
{"name":"ONote.ofNat_zero","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"⊢ Eq (↑0) 0","decl":"@[simp] theorem ofNat_zero : ofNat 0 = 0 :=\n  rfl\n\n"}
{"name":"ONote.ofNat_succ","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"n : Nat\n⊢ Eq (↑n.succ) (ONote.oadd 0 n.succPNat 0)","decl":"@[simp] theorem ofNat_succ (n) : ofNat (Nat.succ n) = oadd 0 n.succPNat 0 :=\n  rfl\n\n"}
{"name":"ONote.ofNat_one","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"⊢ Eq (↑1) 1","decl":"@[simp 1200] theorem ofNat_one : ofNat 1 = 1 := rfl\n\n"}
{"name":"ONote.repr_ofNat","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"n : Nat\n⊢ Eq (↑n).repr ↑n","decl":"@[simp] theorem repr_ofNat (n : ℕ) : repr (ofNat n) = n := by cases n <;> simp\n\n"}
{"name":"ONote.repr_one","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"⊢ Eq (ONote.repr 1) ↑1","decl":"@[simp] theorem repr_one : repr 1 = (1 : ℕ) := repr_ofNat 1\n\n"}
{"name":"ONote.omega0_le_oadd","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e : ONote\nn : PNat\na : ONote\n⊢ LE.le (HPow.hPow Ordinal.omega0 e.repr) (e.oadd n a).repr","decl":"theorem omega0_le_oadd (e n a) : ω ^ repr e ≤ repr (oadd e n a) := by\n  refine le_trans ?_ (le_add_right _ _)\n  simpa using (Ordinal.mul_le_mul_iff_left <| opow_pos (repr e) omega0_pos).2 (Nat.cast_le.2 n.2)\n\n"}
{"name":"ONote.omega_le_oadd","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e : ONote\nn : PNat\na : ONote\n⊢ LE.le (HPow.hPow Ordinal.omega0 e.repr) (e.oadd n a).repr","decl":"@[deprecated (since := \"2024-09-30\")]\nalias omega_le_oadd := omega0_le_oadd\n\n"}
{"name":"ONote.oadd_pos","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e : ONote\nn : PNat\na : ONote\n⊢ LT.lt 0 (e.oadd n a)","decl":"theorem oadd_pos (e n a) : 0 < oadd e n a :=\n  @lt_of_lt_of_le _ _ _ (ω ^ repr e) _ (opow_pos (repr e) omega0_pos) (omega0_le_oadd e n a)\n\n"}
{"name":"ONote.eq_of_cmp_eq","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o₁ o₂ : ONote\na✝ : Eq (o₁.cmp o₂) Ordering.eq\n⊢ Eq o₁ o₂","decl":"theorem eq_of_cmp_eq : ∀ {o₁ o₂}, cmp o₁ o₂ = Ordering.eq → o₁ = o₂\n  | 0, 0, _ => rfl\n  | oadd e n a, 0, h => by injection h\n  | 0, oadd e n a, h => by injection h\n  | oadd e₁ n₁ a₁, oadd e₂ n₂ a₂, h => by\n    revert h; simp only [cmp]\n    cases h₁ : cmp e₁ e₂ <;> intro h <;> try cases h\n    obtain rfl := eq_of_cmp_eq h₁\n    revert h; cases h₂ : _root_.cmp (n₁ : ℕ) n₂ <;> intro h <;> try cases h\n    obtain rfl := eq_of_cmp_eq h\n    rw [_root_.cmp, cmpUsing_eq_eq, not_lt, not_lt, ← le_antisymm_iff] at h₂\n    obtain rfl := Subtype.eq h₂\n    simp\n\n"}
{"name":"ONote.zero_lt_one","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"⊢ LT.lt 0 1","decl":"protected theorem zero_lt_one : (0 : ONote) < 1 := by\n  simp only [lt_def, repr_zero, repr_one, Nat.cast_one, zero_lt_one]\n\n"}
{"name":"ONote.NF.out","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o : ONote\nself : o.NF\n⊢ Exists o.NFBelow","decl":"/-- A normal form ordinal notation has the form\n\n`ω ^ a₁ * n₁ + ω ^ a₂ * n₂ + ⋯ + ω ^ aₖ * nₖ`\n\nwhere `a₁ > a₂ > ⋯ > aₖ` and all the `aᵢ` are also in normal form.\n\nWe will essentially only be interested in normal form ordinal notations, but to avoid complicating\nthe algorithms, we define everything over general ordinal notations and only prove correctness with\nnormal form as an invariant. -/\nclass NF (o : ONote) : Prop where\n  out : Exists (NFBelow o)\n\n"}
{"name":"ONote.NF.zero","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"⊢ ONote.NF 0","decl":"instance NF.zero : NF 0 :=\n  ⟨⟨0, NFBelow.zero⟩⟩\n\n"}
{"name":"ONote.NFBelow.oadd","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e : ONote\nn : PNat\na : ONote\nb : Ordinal.{0}\na✝² : e.NF\na✝¹ : a.NFBelow e.repr\na✝ : LT.lt e.repr b\n⊢ (e.oadd n a).NFBelow b","decl":"theorem NFBelow.oadd {e n a b} : NF e → NFBelow a (repr e) → repr e < b → NFBelow (oadd e n a) b\n  | ⟨⟨_, h⟩⟩ => NFBelow.oadd' h\n\n"}
{"name":"ONote.NFBelow.fst","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e : ONote\nn : PNat\na : ONote\nb : Ordinal.{0}\nh : (e.oadd n a).NFBelow b\n⊢ e.NF","decl":"theorem NFBelow.fst {e n a b} (h : NFBelow (ONote.oadd e n a) b) : NF e := by\n  cases' h with _ _ _ _ eb _ h₁ h₂ h₃; exact ⟨⟨_, h₁⟩⟩\n\n"}
{"name":"ONote.NF.fst","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e : ONote\nn : PNat\na : ONote\na✝ : (e.oadd n a).NF\n⊢ e.NF","decl":"theorem NF.fst {e n a} : NF (oadd e n a) → NF e\n  | ⟨⟨_, h⟩⟩ => h.fst\n\n"}
{"name":"ONote.NFBelow.snd","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e : ONote\nn : PNat\na : ONote\nb : Ordinal.{0}\nh : (e.oadd n a).NFBelow b\n⊢ a.NFBelow e.repr","decl":"theorem NFBelow.snd {e n a b} (h : NFBelow (ONote.oadd e n a) b) : NFBelow a (repr e) := by\n  cases' h with _ _ _ _ eb _ h₁ h₂ h₃; exact h₂\n\n"}
{"name":"ONote.NF.snd'","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e : ONote\nn : PNat\na : ONote\na✝ : (e.oadd n a).NF\n⊢ a.NFBelow e.repr","decl":"theorem NF.snd' {e n a} : NF (oadd e n a) → NFBelow a (repr e)\n  | ⟨⟨_, h⟩⟩ => h.snd\n\n"}
{"name":"ONote.NF.snd","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e : ONote\nn : PNat\na : ONote\nh : (e.oadd n a).NF\n⊢ a.NF","decl":"theorem NF.snd {e n a} (h : NF (oadd e n a)) : NF a :=\n  ⟨⟨_, h.snd'⟩⟩\n\n"}
{"name":"ONote.NF.oadd","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e a : ONote\nh₁ : e.NF\nn : PNat\nh₂ : a.NFBelow e.repr\n⊢ (e.oadd n a).NF","decl":"theorem NF.oadd {e a} (h₁ : NF e) (n) (h₂ : NFBelow a (repr e)) : NF (oadd e n a) :=\n  ⟨⟨_, NFBelow.oadd h₁ h₂ (lt_succ _)⟩⟩\n\n"}
{"name":"ONote.NF.oadd_zero","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e : ONote\nn : PNat\nh : e.NF\n⊢ (e.oadd n 0).NF","decl":"instance NF.oadd_zero (e n) [h : NF e] : NF (ONote.oadd e n 0) :=\n  h.oadd _ NFBelow.zero\n\n"}
{"name":"ONote.NFBelow.lt","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e : ONote\nn : PNat\na : ONote\nb : Ordinal.{0}\nh : (e.oadd n a).NFBelow b\n⊢ LT.lt e.repr b","decl":"theorem NFBelow.lt {e n a b} (h : NFBelow (ONote.oadd e n a) b) : repr e < b := by\n  cases' h with _ _ _ _ eb _ h₁ h₂ h₃; exact h₃\n\n"}
{"name":"ONote.NFBelow_zero","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o : ONote\n⊢ Iff (o.NFBelow 0) (Eq o 0)","decl":"theorem NFBelow_zero : ∀ {o}, NFBelow o 0 ↔ o = 0\n  | 0 => ⟨fun _ => rfl, fun _ => NFBelow.zero⟩\n  | oadd _ _ _ =>\n    ⟨fun h => (not_le_of_lt h.lt).elim (Ordinal.zero_le _), fun e => e.symm ▸ NFBelow.zero⟩\n\n"}
{"name":"ONote.NF.zero_of_zero","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e : ONote\nn : PNat\na : ONote\nh : (e.oadd n a).NF\ne0 : Eq e 0\n⊢ Eq a 0","decl":"theorem NF.zero_of_zero {e n a} (h : NF (ONote.oadd e n a)) (e0 : e = 0) : a = 0 := by\n  simpa [e0, NFBelow_zero] using h.snd'\n\n"}
{"name":"ONote.NFBelow.repr_lt","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o : ONote\nb : Ordinal.{0}\nh : o.NFBelow b\n⊢ LT.lt o.repr (HPow.hPow Ordinal.omega0 b)","decl":"theorem NFBelow.repr_lt {o b} (h : NFBelow o b) : repr o < ω ^ b := by\n  induction h with\n  | zero => exact opow_pos _ omega0_pos\n  | oadd' _ _ h₃ _ IH =>\n    rw [repr]\n    apply ((add_lt_add_iff_left _).2 IH).trans_le\n    rw [← mul_succ]\n    apply (mul_le_mul_left' (succ_le_of_lt (nat_lt_omega0 _)) _).trans\n    rw [← opow_succ]\n    exact opow_le_opow_right omega0_pos (succ_le_of_lt h₃)\n\n"}
{"name":"ONote.NFBelow.mono","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o : ONote\nb₁ b₂ : Ordinal.{0}\nbb : LE.le b₁ b₂\nh : o.NFBelow b₁\n⊢ o.NFBelow b₂","decl":"theorem NFBelow.mono {o b₁ b₂} (bb : b₁ ≤ b₂) (h : NFBelow o b₁) : NFBelow o b₂ := by\n  induction h with\n  | zero => exact zero\n  | oadd' h₁ h₂ h₃ _ _ => constructor; exacts [h₁, h₂, lt_of_lt_of_le h₃ bb]\n\n"}
{"name":"ONote.NF.below_of_lt","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e : ONote\nn : PNat\na : ONote\nb : Ordinal.{0}\nH : LT.lt e.repr b\na✝ : (e.oadd n a).NF\n⊢ (e.oadd n a).NFBelow b","decl":"theorem NF.below_of_lt {e n a b} (H : repr e < b) :\n    NF (ONote.oadd e n a) → NFBelow (ONote.oadd e n a) b\n  | ⟨⟨b', h⟩⟩ => by (cases' h with _ _ _ _ eb _ h₁ h₂ h₃; exact NFBelow.oadd' h₁ h₂ H)\n\n"}
{"name":"ONote.NF.below_of_lt'","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o : ONote\nb : Ordinal.{0}\na✝¹ : LT.lt o.repr (HPow.hPow Ordinal.omega0 b)\na✝ : o.NF\n⊢ o.NFBelow b","decl":"theorem NF.below_of_lt' : ∀ {o b}, repr o < ω ^ b → NF o → NFBelow o b\n  | 0, _, _, _ => NFBelow.zero\n  | ONote.oadd _ _ _, _, H, h =>\n    h.below_of_lt <|\n      (opow_lt_opow_iff_right one_lt_omega0).1 <| lt_of_le_of_lt (omega0_le_oadd _ _ _) H\n\n"}
{"name":"ONote.nfBelow_ofNat","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"n : Nat\n⊢ (↑n).NFBelow 1","decl":"theorem nfBelow_ofNat : ∀ n, NFBelow (ofNat n) 1\n  | 0 => NFBelow.zero\n  | Nat.succ _ => NFBelow.oadd NF.zero NFBelow.zero zero_lt_one\n\n"}
{"name":"ONote.nf_ofNat","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"n : Nat\n⊢ (↑n).NF","decl":"instance nf_ofNat (n) : NF (ofNat n) :=\n  ⟨⟨_, nfBelow_ofNat n⟩⟩\n\n"}
{"name":"ONote.nf_one","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"⊢ ONote.NF 1","decl":"instance nf_one : NF 1 := by rw [← ofNat_one]; infer_instance\n\n"}
{"name":"ONote.oadd_lt_oadd_1","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e₁ : ONote\nn₁ : PNat\no₁ e₂ : ONote\nn₂ : PNat\no₂ : ONote\nh₁ : (e₁.oadd n₁ o₁).NF\nh : LT.lt e₁ e₂\n⊢ LT.lt (e₁.oadd n₁ o₁) (e₂.oadd n₂ o₂)","decl":"theorem oadd_lt_oadd_1 {e₁ n₁ o₁ e₂ n₂ o₂} (h₁ : NF (oadd e₁ n₁ o₁)) (h : e₁ < e₂) :\n    oadd e₁ n₁ o₁ < oadd e₂ n₂ o₂ :=\n  @lt_of_lt_of_le _ _ (repr (oadd e₁ n₁ o₁)) _ _\n    (NF.below_of_lt h h₁).repr_lt (omega0_le_oadd e₂ n₂ o₂)\n\n"}
{"name":"ONote.oadd_lt_oadd_2","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e o₁ o₂ : ONote\nn₁ n₂ : PNat\nh₁ : (e.oadd n₁ o₁).NF\nh : LT.lt ↑n₁ ↑n₂\n⊢ LT.lt (e.oadd n₁ o₁) (e.oadd n₂ o₂)","decl":"theorem oadd_lt_oadd_2 {e o₁ o₂ : ONote} {n₁ n₂ : ℕ+} (h₁ : NF (oadd e n₁ o₁)) (h : (n₁ : ℕ) < n₂) :\n    oadd e n₁ o₁ < oadd e n₂ o₂ := by\n  simp only [lt_def, repr]\n  refine lt_of_lt_of_le ((add_lt_add_iff_left _).2 h₁.snd'.repr_lt) (le_trans ?_ (le_add_right _ _))\n  rwa [← mul_succ,Ordinal.mul_le_mul_iff_left (opow_pos _ omega0_pos), succ_le_iff, Nat.cast_lt]\n\n"}
{"name":"ONote.oadd_lt_oadd_3","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e : ONote\nn : PNat\na₁ a₂ : ONote\nh : LT.lt a₁ a₂\n⊢ LT.lt (e.oadd n a₁) (e.oadd n a₂)","decl":"theorem oadd_lt_oadd_3 {e n a₁ a₂} (h : a₁ < a₂) : oadd e n a₁ < oadd e n a₂ := by\n  rw [lt_def]; unfold repr\n  exact @add_lt_add_left _ _ _ _ (repr a₁) _ h _\n\n"}
{"name":"ONote.cmp_compares","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"a b : ONote\ninst✝¹ : a.NF\ninst✝ : b.NF\n⊢ (a.cmp b).Compares a b","decl":"theorem cmp_compares : ∀ (a b : ONote) [NF a] [NF b], (cmp a b).Compares a b\n  | 0, 0, _, _ => rfl\n  | oadd _ _ _, 0, _, _ => oadd_pos _ _ _\n  | 0, oadd _ _ _, _, _ => oadd_pos _ _ _\n  | o₁@(oadd e₁ n₁ a₁), o₂@(oadd e₂ n₂ a₂), h₁, h₂ => by -- TODO: golf\n    rw [cmp]\n    have IHe := @cmp_compares _ _ h₁.fst h₂.fst\n    simp only [Ordering.Compares, gt_iff_lt] at IHe; revert IHe\n    cases cmp e₁ e₂\n    case lt => intro IHe; exact oadd_lt_oadd_1 h₁ IHe\n    case gt => intro IHe; exact oadd_lt_oadd_1 h₂ IHe\n    case eq =>\n      intro IHe; dsimp at IHe; subst IHe\n      unfold _root_.cmp; cases nh : cmpUsing (· < ·) (n₁ : ℕ) n₂ <;>\n      rw [cmpUsing, ite_eq_iff, not_lt] at nh\n      case lt =>\n        cases' nh with nh nh\n        · exact oadd_lt_oadd_2 h₁ nh.left\n        · rw [ite_eq_iff] at nh; cases' nh.right with nh nh <;> cases nh <;> contradiction\n      case gt =>\n        cases' nh with nh nh\n        · cases nh; contradiction\n        · cases' nh with _ nh\n          rw [ite_eq_iff] at nh; cases' nh with nh nh\n          · exact oadd_lt_oadd_2 h₂ nh.left\n          · cases nh; contradiction\n      cases' nh with nh nh\n      · cases nh; contradiction\n      cases' nh with nhl nhr\n      rw [ite_eq_iff] at nhr\n      cases' nhr with nhr nhr\n      · cases nhr; contradiction\n      obtain rfl := Subtype.eq (nhl.eq_of_not_lt nhr.1)\n      have IHa := @cmp_compares _ _ h₁.snd h₂.snd\n      revert IHa; cases cmp a₁ a₂ <;> intro IHa <;> dsimp at IHa\n      case lt => exact oadd_lt_oadd_3 IHa\n      case gt => exact oadd_lt_oadd_3 IHa\n      subst IHa; exact rfl\n\n"}
{"name":"ONote.repr_inj","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"a b : ONote\ninst✝¹ : a.NF\ninst✝ : b.NF\n⊢ Iff (Eq a.repr b.repr) (Eq a b)","decl":"theorem repr_inj {a b} [NF a] [NF b] : repr a = repr b ↔ a = b :=\n  ⟨fun e => match cmp a b, cmp_compares a b with\n    | Ordering.lt, (h : repr a < repr b) => (ne_of_lt h e).elim\n    | Ordering.gt, (h : repr a > repr b)=> (ne_of_gt h e).elim\n    | Ordering.eq, h => h,\n    congr_arg _⟩\n\n"}
{"name":"ONote.NF.of_dvd_omega0_opow","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"b : Ordinal.{0}\ne : ONote\nn : PNat\na : ONote\nh : (e.oadd n a).NF\nd : Dvd.dvd (HPow.hPow Ordinal.omega0 b) (e.oadd n a).repr\n⊢ And (LE.le b e.repr) (Dvd.dvd (HPow.hPow Ordinal.omega0 b) a.repr)","decl":"theorem NF.of_dvd_omega0_opow {b e n a} (h : NF (ONote.oadd e n a))\n    (d : ω ^ b ∣ repr (ONote.oadd e n a)) :\n    b ≤ repr e ∧ ω ^ b ∣ repr a := by\n  have := mt repr_inj.1 (fun h => by injection h : ONote.oadd e n a ≠ 0)\n  have L := le_of_not_lt fun l => not_le_of_lt (h.below_of_lt l).repr_lt (le_of_dvd this d)\n  simp only [repr] at d\n  exact ⟨L, (dvd_add_iff <| (opow_dvd_opow _ L).mul_right _).1 d⟩\n\n"}
{"name":"ONote.NF.of_dvd_omega_opow","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"b : Ordinal.{0}\ne : ONote\nn : PNat\na : ONote\nh : (e.oadd n a).NF\nd : Dvd.dvd (HPow.hPow Ordinal.omega0 b) (e.oadd n a).repr\n⊢ And (LE.le b e.repr) (Dvd.dvd (HPow.hPow Ordinal.omega0 b) a.repr)","decl":"@[deprecated (since := \"2024-09-30\")]\nalias NF.of_dvd_omega_opow := NF.of_dvd_omega0_opow\n\n"}
{"name":"ONote.NF.of_dvd_omega0","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e : ONote\nn : PNat\na : ONote\nh : (e.oadd n a).NF\na✝ : Dvd.dvd Ordinal.omega0 (e.oadd n a).repr\n⊢ And (Ne e.repr 0) (Dvd.dvd Ordinal.omega0 a.repr)","decl":"theorem NF.of_dvd_omega0 {e n a} (h : NF (ONote.oadd e n a)) :\n    ω ∣ repr (ONote.oadd e n a) → repr e ≠ 0 ∧ ω ∣ repr a := by\n  (rw [← opow_one ω, ← one_le_iff_ne_zero]; exact h.of_dvd_omega0_opow)\n\n"}
{"name":"ONote.NF.of_dvd_omega","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e : ONote\nn : PNat\na : ONote\nh : (e.oadd n a).NF\na✝ : Dvd.dvd Ordinal.omega0 (e.oadd n a).repr\n⊢ And (Ne e.repr 0) (Dvd.dvd Ordinal.omega0 a.repr)","decl":"@[deprecated (since := \"2024-09-30\")]\nalias NF.of_dvd_omega := NF.of_dvd_omega0\n\n"}
{"name":"ONote.nfBelow_iff_topBelow","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"b : ONote\ninst✝ : b.NF\no : ONote\n⊢ Iff (o.NFBelow b.repr) (And o.NF (b.TopBelow o))","decl":"theorem nfBelow_iff_topBelow {b} [NF b] : ∀ {o}, NFBelow o (repr b) ↔ NF o ∧ TopBelow b o\n  | 0 => ⟨fun h => ⟨⟨⟨_, h⟩⟩, trivial⟩, fun _ => NFBelow.zero⟩\n  | oadd _ _ _ =>\n    ⟨fun h => ⟨⟨⟨_, h⟩⟩, (@cmp_compares _ b h.fst _).eq_lt.2 h.lt⟩, fun ⟨h₁, h₂⟩ =>\n      h₁.below_of_lt <| (@cmp_compares _ b h₁.fst _).eq_lt.1 h₂⟩\n\n"}
{"name":"ONote.zero_add","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o : ONote\n⊢ Eq (HAdd.hAdd 0 o) o","decl":"@[simp]\ntheorem zero_add (o : ONote) : 0 + o = o :=\n  rfl\n\n"}
{"name":"ONote.oadd_add","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e : ONote\nn : PNat\na o : ONote\n⊢ Eq (HAdd.hAdd (e.oadd n a) o) (e.addAux n (HAdd.hAdd a o))","decl":"theorem oadd_add (e n a o) : oadd e n a + o = addAux e n (a + o) :=\n  rfl\n\n"}
{"name":"ONote.add_nfBelow","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"b : Ordinal.{0}\no₁ o₂ : ONote\na✝¹ : o₁.NFBelow b\na✝ : o₂.NFBelow b\n⊢ (HAdd.hAdd o₁ o₂).NFBelow b","decl":"theorem add_nfBelow {b} : ∀ {o₁ o₂}, NFBelow o₁ b → NFBelow o₂ b → NFBelow (o₁ + o₂) b\n  | 0, _, _, h₂ => h₂\n  | oadd e n a, o, h₁, h₂ => by\n    have h' := add_nfBelow (h₁.snd.mono <| le_of_lt h₁.lt) h₂\n    simp only [oadd_add]; revert h'; cases' a + o with e' n' a' <;> intro h'\n    · exact NFBelow.oadd h₁.fst NFBelow.zero h₁.lt\n    have : ((e.cmp e').Compares e e') := @cmp_compares _ _ h₁.fst h'.fst\n    cases h : cmp e e' <;> dsimp [addAux] <;> simp only [h]\n    · exact h'\n    · simp only [h] at this\n      subst e'\n      exact NFBelow.oadd h'.fst h'.snd h'.lt\n    · simp only [h] at this\n      exact NFBelow.oadd h₁.fst (NF.below_of_lt this ⟨⟨_, h'⟩⟩) h₁.lt\n\n"}
{"name":"ONote.add_nf","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o₁ o₂ : ONote\ninst✝¹ : o₁.NF\ninst✝ : o₂.NF\n⊢ (HAdd.hAdd o₁ o₂).NF","decl":"instance add_nf (o₁ o₂) : ∀ [NF o₁] [NF o₂], NF (o₁ + o₂)\n  | ⟨⟨b₁, h₁⟩⟩, ⟨⟨b₂, h₂⟩⟩ =>\n    ⟨(le_total b₁ b₂).elim (fun h => ⟨b₂, add_nfBelow (h₁.mono h) h₂⟩) fun h =>\n        ⟨b₁, add_nfBelow h₁ (h₂.mono h)⟩⟩\n\n"}
{"name":"ONote.repr_add","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o₁ o₂ : ONote\ninst✝¹ : o₁.NF\ninst✝ : o₂.NF\n⊢ Eq (HAdd.hAdd o₁ o₂).repr (HAdd.hAdd o₁.repr o₂.repr)","decl":"@[simp]\ntheorem repr_add : ∀ (o₁ o₂) [NF o₁] [NF o₂], repr (o₁ + o₂) = repr o₁ + repr o₂\n  | 0, o, _, _ => by simp\n  | oadd e n a, o, h₁, h₂ => by\n    haveI := h₁.snd; have h' := repr_add a o\n    conv_lhs at h' => simp [HAdd.hAdd, Add.add]\n    have nf := ONote.add_nf a o\n    conv at nf => simp [HAdd.hAdd, Add.add]\n    conv in _ + o => simp [HAdd.hAdd, Add.add]\n    cases' h : add a o with e' n' a' <;>\n      simp only [Add.add, add, addAux, h'.symm, h, add_assoc, repr_zero, repr] at nf h₁ ⊢\n    have := h₁.fst; haveI := nf.fst; have ee := cmp_compares e e'\n    cases he : cmp e e' <;> simp only [he, Ordering.compares_gt, Ordering.compares_lt,\n        Ordering.compares_eq, repr, gt_iff_lt, PNat.add_coe, Nat.cast_add] at ee ⊢\n    · rw [← add_assoc, @add_absorp _ (repr e') (ω ^ repr e' * (n' : ℕ))]\n      · have := (h₁.below_of_lt ee).repr_lt\n        unfold repr at this\n        cases he' : e' <;> simp only [he', zero_def, opow_zero, repr, gt_iff_lt] at this ⊢ <;>\n        exact lt_of_le_of_lt (le_add_right _ _) this\n      · simpa using (Ordinal.mul_le_mul_iff_left <| opow_pos (repr e') omega0_pos).2\n          (Nat.cast_le.2 n'.pos)\n    · rw [ee, ← add_assoc, ← mul_add]\n\n"}
{"name":"ONote.sub_nfBelow","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o₁ o₂ : ONote\nb : Ordinal.{0}\na✝¹ : o₁.NFBelow b\na✝ : o₂.NF\n⊢ (HSub.hSub o₁ o₂).NFBelow b","decl":"theorem sub_nfBelow : ∀ {o₁ o₂ b}, NFBelow o₁ b → NF o₂ → NFBelow (o₁ - o₂) b\n  | 0, o, b, _, h₂ => by cases o <;> exact NFBelow.zero\n  | oadd _ _ _, 0, _, h₁, _ => h₁\n  | oadd e₁ n₁ a₁, oadd e₂ n₂ a₂, b, h₁, h₂ => by\n    have h' := sub_nfBelow h₁.snd h₂.snd\n    simp only [HSub.hSub, Sub.sub, sub] at h' ⊢\n    have := @cmp_compares _ _ h₁.fst h₂.fst\n    cases h : cmp e₁ e₂\n    · apply NFBelow.zero\n    · rw [Nat.sub_eq]\n      simp only [h, Ordering.compares_eq] at this\n      subst e₂\n      cases (n₁ : ℕ) - n₂\n      · by_cases en : n₁ = n₂ <;> simp only [en, ↓reduceIte]\n        · exact h'.mono (le_of_lt h₁.lt)\n        · exact NFBelow.zero\n      · exact NFBelow.oadd h₁.fst h₁.snd h₁.lt\n    · exact h₁\n\n"}
{"name":"ONote.sub_nf","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o₁ o₂ : ONote\ninst✝¹ : o₁.NF\ninst✝ : o₂.NF\n⊢ (HSub.hSub o₁ o₂).NF","decl":"instance sub_nf (o₁ o₂) : ∀ [NF o₁] [NF o₂], NF (o₁ - o₂)\n  | ⟨⟨b₁, h₁⟩⟩, h₂ => ⟨⟨b₁, sub_nfBelow h₁ h₂⟩⟩\n\n"}
{"name":"ONote.repr_sub","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o₁ o₂ : ONote\ninst✝¹ : o₁.NF\ninst✝ : o₂.NF\n⊢ Eq (HSub.hSub o₁ o₂).repr (HSub.hSub o₁.repr o₂.repr)","decl":"@[simp]\ntheorem repr_sub : ∀ (o₁ o₂) [NF o₁] [NF o₂], repr (o₁ - o₂) = repr o₁ - repr o₂\n  | 0, o, _, h₂ => by cases o <;> exact (Ordinal.zero_sub _).symm\n  | oadd _ _ _, 0, _, _ => (Ordinal.sub_zero _).symm\n  | oadd e₁ n₁ a₁, oadd e₂ n₂ a₂, h₁, h₂ => by\n    haveI := h₁.snd; haveI := h₂.snd; have h' := repr_sub a₁ a₂\n    conv_lhs at h' => dsimp [HSub.hSub, Sub.sub, sub]\n    conv_lhs => dsimp only [HSub.hSub, Sub.sub]; dsimp only [sub]\n    have ee := @cmp_compares _ _ h₁.fst h₂.fst\n    cases h : cmp e₁ e₂ <;> simp only [h] at ee\n    · rw [Ordinal.sub_eq_zero_iff_le.2]\n      · rfl\n      exact le_of_lt (oadd_lt_oadd_1 h₁ ee)\n    · change e₁ = e₂ at ee\n      subst e₂\n      dsimp only\n      cases mn : (n₁ : ℕ) - n₂ <;> dsimp only\n      · by_cases en : n₁ = n₂\n        · simpa [en]\n        · simp only [en, ite_false]\n          exact\n            (Ordinal.sub_eq_zero_iff_le.2 <|\n                le_of_lt <|\n                  oadd_lt_oadd_2 h₁ <|\n                    lt_of_le_of_ne (tsub_eq_zero_iff_le.1 mn) (mt PNat.eq en)).symm\n      · simp [Nat.succPNat]\n        rw [(tsub_eq_iff_eq_add_of_le <| le_of_lt <| Nat.lt_of_sub_eq_succ mn).1 mn, add_comm,\n          Nat.cast_add, mul_add, add_assoc, add_sub_add_cancel]\n        refine\n          (Ordinal.sub_eq_of_add_eq <|\n              add_absorp h₂.snd'.repr_lt <| le_trans ?_ (le_add_right _ _)).symm\n        exact Ordinal.le_mul_left _ (Nat.cast_lt.2 <| Nat.succ_pos _)\n    · exact\n        (Ordinal.sub_eq_of_add_eq <|\n            add_absorp (h₂.below_of_lt ee).repr_lt <| omega0_le_oadd _ _ _).symm\n\n"}
{"name":"ONote.oadd_mul","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e₁ : ONote\nn₁ : PNat\na₁ e₂ : ONote\nn₂ : PNat\na₂ : ONote\n⊢ Eq (HMul.hMul (e₁.oadd n₁ a₁) (e₂.oadd n₂ a₂)) (ite (Eq e₂ 0) (e₁.oadd (HMul.hMul n₁ n₂) a₁) ((HAdd.hAdd e₁ e₂).oadd n₂ (HMul.hMul (e₁.oadd n₁ a₁) a₂)))","decl":"theorem oadd_mul (e₁ n₁ a₁ e₂ n₂ a₂) :\n    oadd e₁ n₁ a₁ * oadd e₂ n₂ a₂ =\n      if e₂ = 0 then oadd e₁ (n₁ * n₂) a₁ else oadd (e₁ + e₂) n₂ (oadd e₁ n₁ a₁ * a₂) :=\n  rfl\n\n"}
{"name":"ONote.oadd_mul_nfBelow","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e₁ : ONote\nn₁ : PNat\na₁ : ONote\nb₁ : Ordinal.{0}\nh₁ : (e₁.oadd n₁ a₁).NFBelow b₁\no₂ : ONote\nb₂ : Ordinal.{0}\na✝ : o₂.NFBelow b₂\n⊢ (HMul.hMul (e₁.oadd n₁ a₁) o₂).NFBelow (HAdd.hAdd e₁.repr b₂)","decl":"theorem oadd_mul_nfBelow {e₁ n₁ a₁ b₁} (h₁ : NFBelow (oadd e₁ n₁ a₁) b₁) :\n    ∀ {o₂ b₂}, NFBelow o₂ b₂ → NFBelow (oadd e₁ n₁ a₁ * o₂) (repr e₁ + b₂)\n  | 0, _, _ => NFBelow.zero\n  | oadd e₂ n₂ a₂, b₂, h₂ => by\n    have IH := oadd_mul_nfBelow h₁ h₂.snd\n    by_cases e0 : e₂ = 0 <;> simp only [e0, oadd_mul, ↓reduceIte]\n    · apply NFBelow.oadd h₁.fst h₁.snd\n      simpa using (add_lt_add_iff_left (repr e₁)).2 (lt_of_le_of_lt (Ordinal.zero_le _) h₂.lt)\n    · haveI := h₁.fst\n      haveI := h₂.fst\n      apply NFBelow.oadd\n      · infer_instance\n      · rwa [repr_add]\n      · rw [repr_add, add_lt_add_iff_left]\n        exact h₂.lt\n\n"}
{"name":"ONote.mul_nf","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o₁ o₂ : ONote\ninst✝¹ : o₁.NF\ninst✝ : o₂.NF\n⊢ (HMul.hMul o₁ o₂).NF","decl":"instance mul_nf : ∀ (o₁ o₂) [NF o₁] [NF o₂], NF (o₁ * o₂)\n  | 0, o, _, h₂ => by cases o <;> exact NF.zero\n  | oadd _ _ _, _, ⟨⟨_, hb₁⟩⟩, ⟨⟨_, hb₂⟩⟩ => ⟨⟨_, oadd_mul_nfBelow hb₁ hb₂⟩⟩\n\n"}
{"name":"ONote.repr_mul","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o₁ o₂ : ONote\ninst✝¹ : o₁.NF\ninst✝ : o₂.NF\n⊢ Eq (HMul.hMul o₁ o₂).repr (HMul.hMul o₁.repr o₂.repr)","decl":"@[simp]\ntheorem repr_mul : ∀ (o₁ o₂) [NF o₁] [NF o₂], repr (o₁ * o₂) = repr o₁ * repr o₂\n  | 0, o, _, h₂ => by cases o <;> exact (zero_mul _).symm\n  | oadd _ _ _, 0, _, _ => (mul_zero _).symm\n  | oadd e₁ n₁ a₁, oadd e₂ n₂ a₂, h₁, h₂ => by\n    have IH : repr (mul _ _) = _ := @repr_mul _ _ h₁ h₂.snd\n    conv =>\n      lhs\n      simp [(· * ·)]\n    have ao : repr a₁ + ω ^ repr e₁ * (n₁ : ℕ) = ω ^ repr e₁ * (n₁ : ℕ) := by\n      apply add_absorp h₁.snd'.repr_lt\n      simpa using (Ordinal.mul_le_mul_iff_left <| opow_pos _ omega0_pos).2 (Nat.cast_le.2 n₁.2)\n    by_cases e0 : e₂ = 0\n    · cases' Nat.exists_eq_succ_of_ne_zero n₂.ne_zero with x xe\n      simp only [Mul.mul, mul, e0, ↓reduceIte, repr, PNat.mul_coe, natCast_mul, opow_zero, one_mul]\n      simp only [xe, h₂.zero_of_zero e0, repr, add_zero]\n      rw [natCast_succ x, add_mul_succ _ ao, mul_assoc]\n    · simp only [repr]\n      haveI := h₁.fst\n      haveI := h₂.fst\n      simp only [Mul.mul, mul, e0, ite_false, repr.eq_2, repr_add, opow_add, IH, repr, mul_add]\n      rw [← mul_assoc]\n      congr 2\n      have := mt repr_inj.1 e0\n      rw [add_mul_limit ao (isLimit_opow_left isLimit_omega0 this), mul_assoc,\n        mul_omega0_dvd (Nat.cast_pos'.2 n₁.pos) (nat_lt_omega0 _)]\n      simpa using opow_dvd_opow ω (one_le_iff_ne_zero.2 this)\n\n"}
{"name":"ONote.opow_def","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o₁ o₂ : ONote\n⊢ Eq (HPow.hPow o₁ o₂) (o₂.opowAux2 o₁.split)","decl":"theorem opow_def (o₁ o₂ : ONote) : o₁ ^ o₂ = opowAux2 o₂ (split o₁) :=\n  rfl\n\n"}
{"name":"ONote.split_eq_scale_split'","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o o' : ONote\nm : Nat\ninst✝ : o.NF\na✝ : Eq o.split' { fst := o', snd := m }\n⊢ Eq o.split { fst := ONote.scale 1 o', snd := m }","decl":"theorem split_eq_scale_split' : ∀ {o o' m} [NF o], split' o = (o', m) → split o = (scale 1 o', m)\n  | 0, o', m, _, p => by injection p; substs o' m; rfl\n  | oadd e n a, o', m, h, p => by\n    by_cases e0 : e = 0 <;> simp only [split', e0, ↓reduceIte, Prod.mk.injEq, split] at p ⊢\n    · rcases p with ⟨rfl, rfl⟩\n      exact ⟨rfl, rfl⟩\n    · revert p\n      cases' h' : split' a with a' m'\n      haveI := h.fst\n      haveI := h.snd\n      simp only [split_eq_scale_split' h', and_imp]\n      have : 1 + (e - 1) = e := by\n        refine repr_inj.1 ?_\n        simp only [repr_add, repr_one, Nat.cast_one, repr_sub]\n        have := mt repr_inj.1 e0\n        exact Ordinal.add_sub_cancel_of_le <| one_le_iff_ne_zero.2 this\n      intros\n      substs o' m\n      simp [scale, this]\n\n"}
{"name":"ONote.nf_repr_split'","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o o' : ONote\nm : Nat\ninst✝ : o.NF\na✝ : Eq o.split' { fst := o', snd := m }\n⊢ And o'.NF (Eq o.repr (HAdd.hAdd (HMul.hMul Ordinal.omega0 o'.repr) ↑m))","decl":"theorem nf_repr_split' : ∀ {o o' m} [NF o], split' o = (o', m) → NF o' ∧ repr o = ω * repr o' + m\n  | 0, o', m, _, p => by injection p; substs o' m; simp [NF.zero]\n  | oadd e n a, o', m, h, p => by\n    by_cases e0 : e = 0 <;> simp [e0, split, split'] at p ⊢\n    · rcases p with ⟨rfl, rfl⟩\n      simp [h.zero_of_zero e0, NF.zero]\n    · revert p\n      cases' h' : split' a with a' m'\n      haveI := h.fst\n      haveI := h.snd\n      cases' nf_repr_split' h' with IH₁ IH₂\n      simp only [IH₂, and_imp]\n      intros\n      substs o' m\n      have : (ω : Ordinal.{0}) ^ repr e = ω ^ (1 : Ordinal.{0}) * ω ^ (repr e - 1) := by\n        have := mt repr_inj.1 e0\n        rw [← opow_add, Ordinal.add_sub_cancel_of_le (one_le_iff_ne_zero.2 this)]\n      refine ⟨NF.oadd (by infer_instance) _ ?_, ?_⟩\n      · simp only [opow_one, repr_sub, repr_one, Nat.cast_one] at this ⊢\n        refine IH₁.below_of_lt'\n          ((Ordinal.mul_lt_mul_iff_left omega0_pos).1 <| lt_of_le_of_lt (le_add_right _ m') ?_)\n        rw [← this, ← IH₂]\n        exact h.snd'.repr_lt\n      · rw [this]\n        simp [mul_add, mul_assoc, add_assoc]\n\n"}
{"name":"ONote.scale_eq_mul","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"x : ONote\ninst✝¹ : x.NF\no : ONote\ninst✝ : o.NF\n⊢ Eq (x.scale o) (HMul.hMul (x.oadd 1 0) o)","decl":"theorem scale_eq_mul (x) [NF x] : ∀ (o) [NF o], scale x o = oadd x 1 0 * o\n  | 0, _ => rfl\n  | oadd e n a, h => by\n    simp only [HMul.hMul]; simp only [scale]\n    haveI := h.snd\n    by_cases e0 : e = 0\n    · simp_rw [scale_eq_mul]\n      simp [Mul.mul, mul, scale_eq_mul, e0, h.zero_of_zero,\n        show x + 0 = x from repr_inj.1 (by simp)]\n    · simp [e0, Mul.mul, mul, scale_eq_mul, (· * ·)]\n\n"}
{"name":"ONote.nf_scale","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"x : ONote\ninst✝¹ : x.NF\no : ONote\ninst✝ : o.NF\n⊢ (x.scale o).NF","decl":"instance nf_scale (x) [NF x] (o) [NF o] : NF (scale x o) := by\n  rw [scale_eq_mul]\n  infer_instance\n\n"}
{"name":"ONote.repr_scale","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"x : ONote\ninst✝¹ : x.NF\no : ONote\ninst✝ : o.NF\n⊢ Eq (x.scale o).repr (HMul.hMul (HPow.hPow Ordinal.omega0 x.repr) o.repr)","decl":"@[simp]\ntheorem repr_scale (x) [NF x] (o) [NF o] : repr (scale x o) = ω ^ repr x * repr o := by\n  simp only [scale_eq_mul, repr_mul, repr, PNat.one_coe, Nat.cast_one, mul_one, add_zero]\n\n"}
{"name":"ONote.nf_repr_split","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o o' : ONote\nm : Nat\ninst✝ : o.NF\nh : Eq o.split { fst := o', snd := m }\n⊢ And o'.NF (Eq o.repr (HAdd.hAdd o'.repr ↑m))","decl":"theorem nf_repr_split {o o' m} [NF o] (h : split o = (o', m)) : NF o' ∧ repr o = repr o' + m := by\n  cases' e : split' o with a n\n  cases' nf_repr_split' e with s₁ s₂\n  rw [split_eq_scale_split' e] at h\n  injection h; substs o' n\n  simp only [repr_scale, repr_one, Nat.cast_one, opow_one, ← s₂, and_true]\n  infer_instance\n\n"}
{"name":"ONote.split_dvd","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o o' : ONote\nm : Nat\ninst✝ : o.NF\nh : Eq o.split { fst := o', snd := m }\n⊢ Dvd.dvd Ordinal.omega0 o'.repr","decl":"theorem split_dvd {o o' m} [NF o] (h : split o = (o', m)) : ω ∣ repr o' := by\n  cases' e : split' o with a n\n  rw [split_eq_scale_split' e] at h\n  injection h; subst o'\n  cases nf_repr_split' e; simp\n\n"}
{"name":"ONote.split_add_lt","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o e : ONote\nn : PNat\na : ONote\nm : Nat\ninst✝ : o.NF\nh : Eq o.split { fst := e.oadd n a, snd := m }\n⊢ LT.lt (HAdd.hAdd a.repr ↑m) (HPow.hPow Ordinal.omega0 e.repr)","decl":"theorem split_add_lt {o e n a m} [NF o] (h : split o = (oadd e n a, m)) :\n    repr a + m < ω ^ repr e := by\n  cases' nf_repr_split h with h₁ h₂\n  cases' h₁.of_dvd_omega0 (split_dvd h) with e0 d\n  apply principal_add_omega0_opow _ h₁.snd'.repr_lt (lt_of_lt_of_le (nat_lt_omega0 _) _)\n  simpa using opow_le_opow_right omega0_pos (one_le_iff_ne_zero.2 e0)\n\n"}
{"name":"ONote.mulNat_eq_mul","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"n : Nat\no : ONote\n⊢ Eq (o.mulNat n) (HMul.hMul o ↑n)","decl":"@[simp]\ntheorem mulNat_eq_mul (n o) : mulNat o n = o * ofNat n := by cases o <;> cases n <;> rfl\n\n"}
{"name":"ONote.nf_mulNat","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o : ONote\ninst✝ : o.NF\nn : Nat\n⊢ (o.mulNat n).NF","decl":"instance nf_mulNat (o) [NF o] (n) : NF (mulNat o n) := by simpa using ONote.mul_nf o (ofNat n)\n\n"}
{"name":"ONote.nf_opowAux","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e a0 a : ONote\ninst✝² : e.NF\ninst✝¹ : a0.NF\ninst✝ : a.NF\nk m : Nat\n⊢ (e.opowAux a0 a k m).NF","decl":"instance nf_opowAux (e a0 a) [NF e] [NF a0] [NF a] : ∀ k m, NF (opowAux e a0 a k m) := by\n  intro k m\n  unfold opowAux\n  cases' m with m m\n  · cases k <;> exact NF.zero\n  cases' k with k k\n  · exact NF.oadd_zero _ _\n  · haveI := nf_opowAux e a0 a k\n    simp only [Nat.succ_ne_zero m, IsEmpty.forall_iff, mulNat_eq_mul]; infer_instance\n\n"}
{"name":"ONote.nf_opow","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o₁ o₂ : ONote\ninst✝¹ : o₁.NF\ninst✝ : o₂.NF\n⊢ (HPow.hPow o₁ o₂).NF","decl":"instance nf_opow (o₁ o₂) [NF o₁] [NF o₂] : NF (o₁ ^ o₂) := by\n  cases' e₁ : split o₁ with a m\n  have na := (nf_repr_split e₁).1\n  cases' e₂ : split' o₂ with b' k\n  haveI := (nf_repr_split' e₂).1\n  cases' a with a0 n a'\n  · cases' m with m\n    · by_cases o₂ = 0 <;> simp only [(· ^ ·), Pow.pow, opow, opowAux2, *] <;> decide\n    · by_cases m = 0\n      · simp only [(· ^ ·), Pow.pow, opow, opowAux2, *, zero_def]\n        decide\n      · simp only [(· ^ ·), Pow.pow, opow, opowAux2, mulNat_eq_mul, ofNat, *]\n        infer_instance\n  · simp only [(· ^ ·), Pow.pow, opow, opowAux2, e₁, split_eq_scale_split' e₂, mulNat_eq_mul]\n    have := na.fst\n    cases' k with k\n    · infer_instance\n    · cases k <;> cases m <;> infer_instance\n\n"}
{"name":"ONote.scale_opowAux","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e a0 a : ONote\ninst✝² : e.NF\ninst✝¹ : a0.NF\ninst✝ : a.NF\nk m : Nat\n⊢ Eq (e.opowAux a0 a k m).repr (HMul.hMul (HPow.hPow Ordinal.omega0 e.repr) (ONote.opowAux 0 a0 a k m).repr)","decl":"theorem scale_opowAux (e a0 a : ONote) [NF e] [NF a0] [NF a] :\n    ∀ k m, repr (opowAux e a0 a k m) = ω ^ repr e * repr (opowAux 0 a0 a k m)\n  | 0, m => by cases m <;> simp [opowAux]\n  | k + 1, m => by\n    by_cases h : m = 0\n    · simp [h, opowAux, mul_add, opow_add, mul_assoc, scale_opowAux _ _ _ k]\n    · -- Porting note: rewrote proof\n      rw [opowAux]; swap\n      · assumption\n      rw [opowAux]; swap\n      · assumption\n      rw [repr_add, repr_scale, scale_opowAux _ _ _ k]\n      simp only [repr_add, repr_scale, opow_add, mul_assoc, zero_add, mul_add]\n\n"}
{"name":"ONote.repr_opow_aux₁","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"e a : ONote\nNe : e.NF\nNa : a.NF\na' : Ordinal.{0}\ne0 : _root_.Ne e.repr 0\nh : LT.lt a' (HPow.hPow Ordinal.omega0 e.repr)\naa : Eq a.repr a'\nn : PNat\n⊢ Eq (HPow.hPow (HAdd.hAdd (HMul.hMul (HPow.hPow Ordinal.omega0 e.repr) ↑↑n) a') Ordinal.omega0) (HPow.hPow (HPow.hPow Ordinal.omega0 e.repr) Ordinal.omega0)","decl":"theorem repr_opow_aux₁ {e a} [Ne : NF e] [Na : NF a] {a' : Ordinal} (e0 : repr e ≠ 0)\n    (h : a' < (ω : Ordinal.{0}) ^ repr e) (aa : repr a = a') (n : ℕ+) :\n    ((ω : Ordinal.{0}) ^ repr e * (n : ℕ) + a') ^ (ω : Ordinal.{0}) =\n      (ω ^ repr e) ^ (ω : Ordinal.{0}) := by\n  subst aa\n  have No := Ne.oadd n (Na.below_of_lt' h)\n  have := omega0_le_oadd e n a\n  rw [repr] at this\n  refine le_antisymm ?_ (opow_le_opow_left _ this)\n  apply (opow_le_of_limit ((opow_pos _ omega0_pos).trans_le this).ne' isLimit_omega0).2\n  intro b l\n  have := (No.below_of_lt (lt_succ _)).repr_lt\n  rw [repr] at this\n  apply (opow_le_opow_left b <| this.le).trans\n  rw [← opow_mul, ← opow_mul]\n  apply opow_le_opow_right omega0_pos\n  rcases le_or_lt ω (repr e) with h | h\n  · apply (mul_le_mul_left' (le_succ b) _).trans\n    rw [← add_one_eq_succ, add_mul_succ _ (one_add_of_omega0_le h), add_one_eq_succ, succ_le_iff,\n      Ordinal.mul_lt_mul_iff_left (Ordinal.pos_iff_ne_zero.2 e0)]\n    exact isLimit_omega0.succ_lt l\n  · apply (principal_mul_omega0 (isLimit_omega0.succ_lt h) l).le.trans\n    simpa using mul_le_mul_right' (one_le_iff_ne_zero.2 e0) ω\n\n"}
{"name":"ONote.repr_opow_aux₂","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"a0 a' : ONote\nN0 : a0.NF\nNa' : a'.NF\nm : Nat\nd : Dvd.dvd Ordinal.omega0 a'.repr\ne0 : Ne a0.repr 0\nh : LT.lt (HAdd.hAdd a'.repr ↑m) (HPow.hPow Ordinal.omega0 a0.repr)\nn : PNat\nk : Nat\n⊢ let R := (ONote.opowAux 0 a0 (HMul.hMul (a0.oadd n a') ↑m) k m).repr;\n  And (Ne k 0 → LT.lt R (HPow.hPow (HPow.hPow Ordinal.omega0 a0.repr) (Order.succ ↑k))) (Eq (HAdd.hAdd (HMul.hMul (HPow.hPow (HPow.hPow Ordinal.omega0 a0.repr) ↑k) (HAdd.hAdd (HMul.hMul (HPow.hPow Ordinal.omega0 a0.repr) ↑↑n) a'.repr)) R) (HPow.hPow (HAdd.hAdd (HAdd.hAdd (HMul.hMul (HPow.hPow Ordinal.omega0 a0.repr) ↑↑n) a'.repr) ↑m) (Order.succ ↑k)))","decl":"set_option linter.unusedVariables false in\ntheorem repr_opow_aux₂ {a0 a'} [N0 : NF a0] [Na' : NF a'] (m : ℕ) (d : ω ∣ repr a')\n    (e0 : repr a0 ≠ 0) (h : repr a' + m < (ω ^ repr a0)) (n : ℕ+) (k : ℕ) :\n    let R := repr (opowAux 0 a0 (oadd a0 n a' * ofNat m) k m)\n    (k ≠ 0 → R < ((ω ^ repr a0) ^ succ (k : Ordinal))) ∧\n      ((ω ^ repr a0) ^ (k : Ordinal)) * ((ω ^ repr a0) * (n : ℕ) + repr a') + R =\n        ((ω ^ repr a0) * (n : ℕ) + repr a' + m) ^ succ (k : Ordinal) := by\n  intro R'\n  haveI No : NF (oadd a0 n a') :=\n    N0.oadd n (Na'.below_of_lt' <| lt_of_le_of_lt (le_add_right _ _) h)\n  induction' k with k IH\n  · cases m <;> simp [R', opowAux]\n  -- rename R => R'\n  let R := repr (opowAux 0 a0 (oadd a0 n a' * ofNat m) k m)\n  let ω0 := ω ^ repr a0\n  let α' := ω0 * n + repr a'\n  change (k ≠ 0 → R < (ω0 ^ succ (k : Ordinal))) ∧ (ω0 ^ (k : Ordinal)) * α' + R\n    = (α' + m) ^ (succ ↑k : Ordinal) at IH\n  have RR : R' = ω0 ^ (k : Ordinal) * (α' * m) + R := by\n    by_cases h : m = 0\n    · simp only [R, R', h, ONote.ofNat, Nat.cast_zero, zero_add, ONote.repr, mul_zero,\n        ONote.opowAux, add_zero]\n    · simp only [α', ω0, R, R', ONote.repr_scale, ONote.repr, ONote.mulNat_eq_mul, ONote.opowAux,\n        ONote.repr_ofNat, ONote.repr_mul, ONote.repr_add, Ordinal.opow_mul, ONote.zero_add]\n  have α0 : 0 < α' := by simpa [lt_def, repr] using oadd_pos a0 n a'\n  have ω00 : 0 < ω0 ^ (k : Ordinal) := opow_pos _ (opow_pos _ omega0_pos)\n  have Rl : R < ω ^ (repr a0 * succ ↑k) := by\n    by_cases k0 : k = 0\n    · simp only [k0, Nat.cast_zero, succ_zero, mul_one, R]\n      refine lt_of_lt_of_le ?_ (opow_le_opow_right omega0_pos (one_le_iff_ne_zero.2 e0))\n      cases' m with m <;> simp [opowAux, omega0_pos]\n      rw [← add_one_eq_succ, ← Nat.cast_succ]\n      apply nat_lt_omega0\n    · rw [opow_mul]\n      exact IH.1 k0\n  refine ⟨fun _ => ?_, ?_⟩\n  · rw [RR, ← opow_mul _ _ (succ k.succ)]\n    have e0 := Ordinal.pos_iff_ne_zero.2 e0\n    have rr0 : 0 < repr a0 + repr a0 := lt_of_lt_of_le e0 (le_add_left _ _)\n    apply principal_add_omega0_opow\n    · simp only [Nat.succ_eq_add_one, Nat.cast_add, Nat.cast_one, add_one_eq_succ,\n        opow_mul, opow_succ, mul_assoc]\n      rw [Ordinal.mul_lt_mul_iff_left ω00, ← Ordinal.opow_add]\n      have : _ < ω ^ (repr a0 + repr a0) := (No.below_of_lt ?_).repr_lt\n      · exact mul_lt_omega0_opow rr0 this (nat_lt_omega0 _)\n      · simpa using (add_lt_add_iff_left (repr a0)).2 e0\n    · exact\n        lt_of_lt_of_le Rl\n          (opow_le_opow_right omega0_pos <|\n            mul_le_mul_left' (succ_le_succ_iff.2 (Nat.cast_le.2 (le_of_lt k.lt_succ_self))) _)\n  calc\n    (ω0 ^ (k.succ : Ordinal)) * α' + R'\n    _ = (ω0 ^ succ (k : Ordinal)) * α' + ((ω0 ^ (k : Ordinal)) * α' * m + R) := by\n        rw [natCast_succ, RR, ← mul_assoc]\n    _ = ((ω0 ^ (k : Ordinal)) * α' + R) * α' + ((ω0 ^ (k : Ordinal)) * α' + R) * m := ?_\n    _ = (α' + m) ^ succ (k.succ : Ordinal) := by rw [← mul_add, natCast_succ, opow_succ, IH.2]\n  congr 1\n  · have αd : ω ∣ α' :=\n      dvd_add (dvd_mul_of_dvd_left (by simpa using opow_dvd_opow ω (one_le_iff_ne_zero.2 e0)) _) d\n    rw [mul_add (ω0 ^ (k : Ordinal)), add_assoc, ← mul_assoc, ← opow_succ,\n      add_mul_limit _ (isLimit_iff_omega0_dvd.2 ⟨ne_of_gt α0, αd⟩), mul_assoc,\n      @mul_omega0_dvd n (Nat.cast_pos'.2 n.pos) (nat_lt_omega0 _) _ αd]\n    apply @add_absorp _ (repr a0 * succ ↑k)\n    · refine principal_add_omega0_opow _ ?_ Rl\n      rw [opow_mul, opow_succ, Ordinal.mul_lt_mul_iff_left ω00]\n      exact No.snd'.repr_lt\n    · have := mul_le_mul_left' (one_le_iff_pos.2 <| Nat.cast_pos'.2 n.pos) (ω0 ^ succ (k : Ordinal))\n      rw [opow_mul]\n      simpa [-opow_succ]\n  · cases m\n    · have : R = 0 := by cases k <;> simp [R, opowAux]\n      simp [this]\n    · rw [natCast_succ, add_mul_succ]\n      apply add_absorp Rl\n      rw [opow_mul, opow_succ]\n      apply mul_le_mul_left'\n      simpa [repr] using omega0_le_oadd a0 n a'\n\n"}
{"name":"ONote.repr_opow","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o₁ o₂ : ONote\ninst✝¹ : o₁.NF\ninst✝ : o₂.NF\n⊢ Eq (HPow.hPow o₁ o₂).repr (HPow.hPow o₁.repr o₂.repr)","decl":"theorem repr_opow (o₁ o₂) [NF o₁] [NF o₂] : repr (o₁ ^ o₂) = repr o₁ ^ repr o₂ := by\n  cases' e₁ : split o₁ with a m\n  cases' nf_repr_split e₁ with N₁ r₁\n  cases' a with a0 n a'\n  · cases' m with m\n    · by_cases h : o₂ = 0 <;> simp [opow_def, opowAux2, opow, e₁, h, r₁]\n      have := mt repr_inj.1 h\n      rw [zero_opow this]\n    · cases' e₂ : split' o₂ with b' k\n      cases' nf_repr_split' e₂ with _ r₂\n      by_cases h : m = 0\n      · simp [opowAux2, opow_def, opow, e₁, h, r₁, e₂, r₂]\n      simp only [opow_def, opowAux2, opow, e₁, h, r₁, e₂, r₂, repr,\n          opow_zero, Nat.succPNat_coe, Nat.cast_succ, Nat.cast_zero, _root_.zero_add, mul_one,\n          add_zero, one_opow, npow_eq_pow]\n      rw [opow_add, opow_mul, opow_omega0, add_one_eq_succ]\n      · congr\n        conv_lhs =>\n          dsimp [(· ^ ·)]\n          simp [Pow.pow, opow, Ordinal.succ_ne_zero]\n        rw [opow_natCast]\n      · simpa [Nat.one_le_iff_ne_zero]\n      · rw [← Nat.cast_succ, lt_omega0]\n        exact ⟨_, rfl⟩\n  · haveI := N₁.fst\n    haveI := N₁.snd\n    cases' N₁.of_dvd_omega0 (split_dvd e₁) with a00 ad\n    have al := split_add_lt e₁\n    have aa : repr (a' + ofNat m) = repr a' + m := by\n      simp only [eq_self_iff_true, ONote.repr_ofNat, ONote.repr_add]\n    cases' e₂ : split' o₂ with b' k\n    cases' nf_repr_split' e₂ with _ r₂\n    simp only [opow_def, opow, e₁, r₁, split_eq_scale_split' e₂, opowAux2, repr]\n    cases' k with k\n    · simp [r₂, opow_mul, repr_opow_aux₁ a00 al aa, add_assoc]\n    · simp [opow, opowAux2, r₂, opow_add, opow_mul, mul_assoc, add_assoc]\n      rw [repr_opow_aux₁ a00 al aa, scale_opowAux]\n      simp only [repr_mul, repr_scale, repr, opow_zero, PNat.val_ofNat, Nat.cast_one, mul_one,\n        add_zero, opow_one, opow_mul]\n      rw [← mul_add, ← add_assoc ((ω : Ordinal.{0}) ^ repr a0 * (n : ℕ))]\n      congr 1\n      rw [← pow_succ, ← opow_natCast, ← opow_natCast]\n      exact (repr_opow_aux₂ _ ad a00 al _ _).2\n\n"}
{"name":"ONote.fundamentalSequenceProp_inl_none","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o : ONote\n⊢ Iff (o.FundamentalSequenceProp (Sum.inl Option.none)) (Eq o 0)","decl":"theorem fundamentalSequenceProp_inl_none (o) :\n    FundamentalSequenceProp o (Sum.inl none) ↔ o = 0 :=\n  Iff.rfl\n\n"}
{"name":"ONote.fundamentalSequenceProp_inl_some","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o a : ONote\n⊢ Iff (o.FundamentalSequenceProp (Sum.inl (Option.some a))) (And (Eq o.repr (Order.succ a.repr)) (o.NF → a.NF))","decl":"theorem fundamentalSequenceProp_inl_some (o a) :\n    FundamentalSequenceProp o (Sum.inl (some a)) ↔ o.repr = succ a.repr ∧ (o.NF → a.NF) :=\n  Iff.rfl\n\n"}
{"name":"ONote.fundamentalSequenceProp_inr","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o : ONote\nf : Nat → ONote\n⊢ Iff (o.FundamentalSequenceProp (Sum.inr f)) (And o.repr.IsLimit (And (∀ (i : Nat), And (LT.lt (f i) (f (HAdd.hAdd i 1))) (And (LT.lt (f i) o) (o.NF → (f i).NF))) (∀ (a : Ordinal.{0}), LT.lt a o.repr → Exists fun i => LT.lt a (f i).repr)))","decl":"theorem fundamentalSequenceProp_inr (o f) :\n    FundamentalSequenceProp o (Sum.inr f) ↔\n      o.repr.IsLimit ∧\n        (∀ i, f i < f (i + 1) ∧ f i < o ∧ (o.NF → (f i).NF)) ∧\n        ∀ a, a < o.repr → ∃ i, a < (f i).repr :=\n  Iff.rfl\n\n"}
{"name":"ONote.fundamentalSequence_has_prop","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o : ONote\n⊢ o.FundamentalSequenceProp o.fundamentalSequence","decl":"theorem fundamentalSequence_has_prop (o) : FundamentalSequenceProp o (fundamentalSequence o) := by\n  induction' o with a m b iha ihb; · exact rfl\n  rw [fundamentalSequence]\n  rcases e : b.fundamentalSequence with (⟨_ | b'⟩ | f) <;>\n    simp only [FundamentalSequenceProp] <;>\n    rw [e, FundamentalSequenceProp] at ihb\n  · rcases e : a.fundamentalSequence with (⟨_ | a'⟩ | f) <;> cases' e' : m.natPred with m' <;>\n      simp only [FundamentalSequenceProp] <;>\n      rw [e, FundamentalSequenceProp] at iha <;>\n      (try rw [show m = 1 by\n            have := PNat.natPred_add_one m; rw [e'] at this; exact PNat.coe_inj.1 this.symm]) <;>\n      (try rw [show m = (m' + 1).succPNat by\n              rw [← e', ← PNat.coe_inj, Nat.succPNat_coe, ← Nat.add_one, PNat.natPred_add_one]]) <;>\n      simp only [repr, iha, ihb, opow_lt_opow_iff_right one_lt_omega0, add_lt_add_iff_left,\n        add_zero, eq_self_iff_true, lt_add_iff_pos_right, lt_def, mul_one, Nat.cast_zero,\n        Nat.cast_succ, Nat.succPNat_coe, opow_succ, opow_zero, mul_add_one, PNat.one_coe, succ_zero,\n        _root_.zero_add, zero_def]\n    · decide\n    · exact ⟨rfl, inferInstance⟩\n    · have := opow_pos (repr a') omega0_pos\n      refine\n        ⟨isLimit_mul this isLimit_omega0, fun i =>\n          ⟨this, ?_, fun H => @NF.oadd_zero _ _ (iha.2 H.fst)⟩, exists_lt_mul_omega0'⟩\n      rw [← mul_succ, ← natCast_succ, Ordinal.mul_lt_mul_iff_left this]\n      apply nat_lt_omega0\n    · have := opow_pos (repr a') omega0_pos\n      refine\n        ⟨isLimit_add _ (isLimit_mul this isLimit_omega0), fun i => ⟨this, ?_, ?_⟩,\n          exists_lt_add exists_lt_mul_omega0'⟩\n      · rw [← mul_succ, ← natCast_succ, Ordinal.mul_lt_mul_iff_left this]\n        apply nat_lt_omega0\n      · refine fun H => H.fst.oadd _ (NF.below_of_lt' ?_ (@NF.oadd_zero _ _ (iha.2 H.fst)))\n        rw [repr, ← zero_def, repr, add_zero, iha.1, opow_succ, Ordinal.mul_lt_mul_iff_left this]\n        apply nat_lt_omega0\n    · rcases iha with ⟨h1, h2, h3⟩\n      refine ⟨isLimit_opow one_lt_omega0 h1, fun i => ?_,\n        exists_lt_omega0_opow' one_lt_omega0 h1 h3⟩\n      obtain ⟨h4, h5, h6⟩ := h2 i\n      exact ⟨h4, h5, fun H => @NF.oadd_zero _ _ (h6 H.fst)⟩\n    · rcases iha with ⟨h1, h2, h3⟩\n      refine\n        ⟨isLimit_add _ (isLimit_opow one_lt_omega0 h1), fun i => ?_,\n          exists_lt_add (exists_lt_omega0_opow' one_lt_omega0 h1 h3)⟩\n      obtain ⟨h4, h5, h6⟩ := h2 i\n      refine ⟨h4, h5, fun H => H.fst.oadd _ (NF.below_of_lt' ?_ (@NF.oadd_zero _ _ (h6 H.fst)))⟩\n      rwa [repr, ← zero_def, repr, add_zero, PNat.one_coe, Nat.cast_one, mul_one,\n        opow_lt_opow_iff_right one_lt_omega0]\n  · refine ⟨by\n      rw [repr, ihb.1, add_succ, repr], fun H => H.fst.oadd _ (NF.below_of_lt' ?_ (ihb.2 H.snd))⟩\n    have := H.snd'.repr_lt\n    rw [ihb.1] at this\n    exact (lt_succ _).trans this\n  · rcases ihb with ⟨h1, h2, h3⟩\n    simp only [repr]\n    exact\n      ⟨Ordinal.isLimit_add _ h1, fun i =>\n        ⟨oadd_lt_oadd_3 (h2 i).1, oadd_lt_oadd_3 (h2 i).2.1, fun H =>\n          H.fst.oadd _ (NF.below_of_lt' (lt_trans (h2 i).2.1 H.snd'.repr_lt) ((h2 i).2.2 H.snd))⟩,\n        exists_lt_add h3⟩\n\n"}
{"name":"ONote.fastGrowing_def","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o : ONote\nx : Sum (Option ONote) (Nat → ONote)\ne : Eq o.fundamentalSequence x\n⊢ Eq o.fastGrowing (ONote.fastGrowing.match_1 o (fun x a => Nat → Nat) x ⋯ (fun x => Nat.succ) (fun a x i => Nat.iterate a.fastGrowing i i) fun f x i => (f i).fastGrowing i)","decl":"@[nolint unusedHavesSuffices]\ntheorem fastGrowing_def {o : ONote} {x} (e : fundamentalSequence o = x) :\n    fastGrowing o =\n      match\n        (motive := (x : Option ONote ⊕ (ℕ → ONote)) → FundamentalSequenceProp o x → ℕ → ℕ)\n        x, e ▸ fundamentalSequence_has_prop o with\n      | Sum.inl none, _ => Nat.succ\n      | Sum.inl (some a), _ =>\n        fun i => (fastGrowing a)^[i] i\n      | Sum.inr f, _ => fun i =>\n        fastGrowing (f i) i := by\n  subst x\n  rw [fastGrowing]\n\n"}
{"name":"ONote.fastGrowing_zero'","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o : ONote\nh : Eq o.fundamentalSequence (Sum.inl Option.none)\n⊢ Eq o.fastGrowing Nat.succ","decl":"theorem fastGrowing_zero' (o : ONote) (h : fundamentalSequence o = Sum.inl none) :\n    fastGrowing o = Nat.succ := by\n  rw [fastGrowing_def h]\n\n"}
{"name":"ONote.fastGrowing_succ","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o a : ONote\nh : Eq o.fundamentalSequence (Sum.inl (Option.some a))\n⊢ Eq o.fastGrowing fun i => Nat.iterate a.fastGrowing i i","decl":"theorem fastGrowing_succ (o) {a} (h : fundamentalSequence o = Sum.inl (some a)) :\n    fastGrowing o = fun i => (fastGrowing a)^[i] i := by\n  rw [fastGrowing_def h]\n\n"}
{"name":"ONote.fastGrowing_limit","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o : ONote\nf : Nat → ONote\nh : Eq o.fundamentalSequence (Sum.inr f)\n⊢ Eq o.fastGrowing fun i => (f i).fastGrowing i","decl":"theorem fastGrowing_limit (o) {f} (h : fundamentalSequence o = Sum.inr f) :\n    fastGrowing o = fun i => fastGrowing (f i) i := by\n  rw [fastGrowing_def h]\n\n"}
{"name":"ONote.fastGrowing_zero","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"⊢ Eq (ONote.fastGrowing 0) Nat.succ","decl":"@[simp]\ntheorem fastGrowing_zero : fastGrowing 0 = Nat.succ :=\n  fastGrowing_zero' _ rfl\n\n"}
{"name":"ONote.fastGrowing_one","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"⊢ Eq (ONote.fastGrowing 1) fun n => HMul.hMul 2 n","decl":"@[simp]\ntheorem fastGrowing_one : fastGrowing 1 = fun n => 2 * n := by\n  rw [@fastGrowing_succ 1 0 rfl]; funext i; rw [two_mul, fastGrowing_zero]\n  suffices ∀ a b, Nat.succ^[a] b = b + a from this _ _\n  intro a b; induction a <;> simp [*, Function.iterate_succ', Nat.add_assoc, -Function.iterate_succ]\n\n"}
{"name":"ONote.fastGrowing_two","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"⊢ Eq (ONote.fastGrowing 2) fun n => HMul.hMul (HPow.hPow 2 n) n","decl":"@[simp]\ntheorem fastGrowing_two : fastGrowing 2 = fun n => (2 ^ n) * n := by\n  rw [@fastGrowing_succ 2 1 rfl]; funext i; rw [fastGrowing_one]\n  suffices ∀ a b, (fun n : ℕ => 2 * n)^[a] b = (2 ^ a) * b from this _ _\n  intro a b; induction a <;>\n    simp [*, Function.iterate_succ, pow_succ, mul_assoc, -Function.iterate_succ]\n\n"}
{"name":"ONote.fastGrowingε₀_zero","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"⊢ Eq (ONote.fastGrowingε₀ 0) 1","decl":"theorem fastGrowingε₀_zero : fastGrowingε₀ 0 = 1 := by simp [fastGrowingε₀]\n\n"}
{"name":"ONote.fastGrowingε₀_one","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"⊢ Eq (ONote.fastGrowingε₀ 1) 2","decl":"theorem fastGrowingε₀_one : fastGrowingε₀ 1 = 2 := by\n  simp [fastGrowingε₀, show oadd 0 1 0 = 1 from rfl]\n\n"}
{"name":"ONote.fastGrowingε₀_two","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"⊢ Eq (ONote.fastGrowingε₀ 2) 2048","decl":"theorem fastGrowingε₀_two : fastGrowingε₀ 2 = 2048 := by\n  norm_num [fastGrowingε₀, show oadd 0 1 0 = 1 from rfl, @fastGrowing_limit (oadd 1 1 0) _ rfl,\n    show oadd 0 (2 : Nat).succPNat 0 = 3 from rfl, @fastGrowing_succ 3 2 rfl]\n\n"}
{"name":"NONote.NF","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"o : NONote\n⊢ (↑o).NF","decl":"instance NF (o : NONote) : NF o.1 :=\n  o.2\n\n"}
{"name":"NONote.lt_wf","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"⊢ WellFounded fun x1 x2 => LT.lt x1 x2","decl":"theorem lt_wf : @WellFounded NONote (· < ·) :=\n  InvImage.wf repr Ordinal.lt_wf\n\n"}
{"name":"NONote.instWellFoundedLT","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"⊢ WellFoundedLT NONote","decl":"instance : WellFoundedLT NONote :=\n  ⟨lt_wf⟩\n\n"}
{"name":"NONote.cmp_compares","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"a b : NONote\n⊢ (a.cmp b).Compares a b","decl":"theorem cmp_compares : ∀ a b : NONote, (cmp a b).Compares a b\n  | ⟨a, ha⟩, ⟨b, hb⟩ => by\n    dsimp [cmp]\n    have := ONote.cmp_compares a b\n    cases h : ONote.cmp a b <;> simp only [h] at this <;> try exact this\n    exact Subtype.mk_eq_mk.2 this\n\n"}
{"name":"NONote.repr_add","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"a b : NONote\n⊢ Eq (HAdd.hAdd a b).repr (HAdd.hAdd a.repr b.repr)","decl":"theorem repr_add (a b) : repr (a + b) = repr a + repr b :=\n  ONote.repr_add a.1 b.1\n\n"}
{"name":"NONote.repr_sub","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"a b : NONote\n⊢ Eq (HSub.hSub a b).repr (HSub.hSub a.repr b.repr)","decl":"theorem repr_sub (a b) : repr (a - b) = repr a - repr b :=\n  ONote.repr_sub a.1 b.1\n\n"}
{"name":"NONote.repr_mul","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"a b : NONote\n⊢ Eq (HMul.hMul a b).repr (HMul.hMul a.repr b.repr)","decl":"theorem repr_mul (a b) : repr (a * b) = repr a * repr b :=\n  ONote.repr_mul a.1 b.1\n\n"}
{"name":"NONote.repr_opow","module":"Mathlib.SetTheory.Ordinal.Notation","initialProofState":"a b : NONote\n⊢ Eq (a.opow b).repr (HPow.hPow a.repr b.repr)","decl":"theorem repr_opow (a b) : repr (opow a b) = repr a ^ repr b :=\n  ONote.repr_opow a.1 b.1\n\n"}
