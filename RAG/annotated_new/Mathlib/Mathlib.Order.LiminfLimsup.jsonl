{"name":"Filter.isBounded_iff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nr : α → α → Prop\nf : Filter α\n⊢ Iff (Filter.IsBounded r f) (Exists fun s => And (Membership.mem f.sets s) (Exists fun b => HasSubset.Subset s (setOf fun x => r x b)))","decl":"/-- `f` is eventually bounded if and only if, there exists an admissible set on which it is\nbounded. -/\ntheorem isBounded_iff : f.IsBounded r ↔ ∃ s ∈ f.sets, ∃ b, s ⊆ { x | r x b } :=\n  Iff.intro (fun ⟨b, hb⟩ => ⟨{ a | r a b }, hb, b, Subset.refl _⟩) fun ⟨_, hs, b, hb⟩ =>\n    ⟨b, mem_of_superset hs hb⟩\n\n"}
{"name":"Filter.isBoundedUnder_of","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\nf : Filter β\nu : β → α\na✝ : Exists fun b => ∀ (x : β), r (u x) b\n⊢ Filter.IsBoundedUnder r f u","decl":"/-- A bounded function `u` is in particular eventually bounded. -/\ntheorem isBoundedUnder_of {f : Filter β} {u : β → α} : (∃ b, ∀ x, r (u x) b) → f.IsBoundedUnder r u\n  | ⟨b, hb⟩ => ⟨b, show ∀ᶠ x in f, r (u x) b from Eventually.of_forall hb⟩\n\n"}
{"name":"Filter.isBounded_bot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Iff (Filter.IsBounded r Bot.bot) (Nonempty α)","decl":"theorem isBounded_bot : IsBounded r ⊥ ↔ Nonempty α := by simp [IsBounded, exists_true_iff_nonempty]\n\n"}
{"name":"Filter.isBounded_top","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Iff (Filter.IsBounded r Top.top) (Exists fun t => ∀ (x : α), r x t)","decl":"theorem isBounded_top : IsBounded r ⊤ ↔ ∃ t, ∀ x, r x t := by simp [IsBounded, eq_univ_iff_forall]\n\n"}
{"name":"Filter.isBounded_principal","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\n⊢ Iff (Filter.IsBounded r (Filter.principal s)) (Exists fun t => ∀ (x : α), Membership.mem s x → r x t)","decl":"theorem isBounded_principal (s : Set α) : IsBounded r (𝓟 s) ↔ ∃ t, ∀ x ∈ s, r x t := by\n  simp [IsBounded, subset_def]\n\n"}
{"name":"Filter.isBounded_sup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nr : α → α → Prop\nf g : Filter α\ninst✝¹ : IsTrans α r\ninst✝ : IsDirected α r\na✝¹ : Filter.IsBounded r f\na✝ : Filter.IsBounded r g\n⊢ Filter.IsBounded r (Max.max f g)","decl":"theorem isBounded_sup [IsTrans α r] [IsDirected α r] :\n    IsBounded r f → IsBounded r g → IsBounded r (f ⊔ g)\n  | ⟨b₁, h₁⟩, ⟨b₂, h₂⟩ =>\n    let ⟨b, rb₁b, rb₂b⟩ := directed_of r b₁ b₂\n    ⟨b, eventually_sup.mpr\n      ⟨h₁.mono fun _ h => _root_.trans h rb₁b, h₂.mono fun _ h => _root_.trans h rb₂b⟩⟩\n\n"}
{"name":"Filter.IsBounded.mono","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nr : α → α → Prop\nf g : Filter α\nh : LE.le f g\na✝ : Filter.IsBounded r g\n⊢ Filter.IsBounded r f","decl":"theorem IsBounded.mono (h : f ≤ g) : IsBounded r g → IsBounded r f\n  | ⟨b, hb⟩ => ⟨b, h hb⟩\n\n"}
{"name":"Filter.IsBoundedUnder.mono","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\nf g : Filter β\nu : β → α\nh : LE.le f g\na✝ : Filter.IsBoundedUnder r g u\n⊢ Filter.IsBoundedUnder r f u","decl":"theorem IsBoundedUnder.mono {f g : Filter β} {u : β → α} (h : f ≤ g) :\n    g.IsBoundedUnder r u → f.IsBoundedUnder r u := fun hg => IsBounded.mono (map_mono h) hg\n\n"}
{"name":"Filter.IsBoundedUnder.mono_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nl : Filter α\nu v : α → β\nhu : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l u\nhv : l.EventuallyLE v u\n⊢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l v","decl":"theorem IsBoundedUnder.mono_le [Preorder β] {l : Filter α} {u v : α → β}\n    (hu : IsBoundedUnder (· ≤ ·) l u) (hv : v ≤ᶠ[l] u) : IsBoundedUnder (· ≤ ·) l v := by\n  apply hu.imp\n  exact fun b hb => (eventually_map.1 hb).mp <| hv.mono fun x => le_trans\n\n"}
{"name":"Filter.IsBoundedUnder.mono_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder β\nl : Filter α\nu v : α → β\nhu : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l u\nhv : l.EventuallyLE u v\n⊢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l v","decl":"theorem IsBoundedUnder.mono_ge [Preorder β] {l : Filter α} {u v : α → β}\n    (hu : IsBoundedUnder (· ≥ ·) l u) (hv : u ≤ᶠ[l] v) : IsBoundedUnder (· ≥ ·) l v :=\n  IsBoundedUnder.mono_le (β := βᵒᵈ) hu hv\n\n"}
{"name":"Filter.isBoundedUnder_const","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ninst✝ : IsRefl α r\nl : Filter β\na : α\n⊢ Filter.IsBoundedUnder r l fun x => a","decl":"theorem isBoundedUnder_const [IsRefl α r] {l : Filter β} {a : α} : IsBoundedUnder r l fun _ => a :=\n  ⟨a, eventually_map.2 <| Eventually.of_forall fun _ => refl _⟩\n\n"}
{"name":"Filter.IsBounded.isBoundedUnder","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\nf : Filter α\nq : β → β → Prop\nu : α → β\nhu : ∀ (a₀ a₁ : α), r a₀ a₁ → q (u a₀) (u a₁)\na✝ : Filter.IsBounded r f\n⊢ Filter.IsBoundedUnder q f u","decl":"theorem IsBounded.isBoundedUnder {q : β → β → Prop} {u : α → β}\n    (hu : ∀ a₀ a₁, r a₀ a₁ → q (u a₀) (u a₁)) : f.IsBounded r → f.IsBoundedUnder q u\n  | ⟨b, h⟩ => ⟨u b, show ∀ᶠ x in f, q (u x) (u b) from h.mono fun x => hu x b⟩\n\n"}
{"name":"Filter.IsBoundedUnder.comp","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nr : α → α → Prop\nl : Filter γ\nq : β → β → Prop\nu : γ → α\nv : α → β\nhv : ∀ (a₀ a₁ : α), r a₀ a₁ → q (v a₀) (v a₁)\na✝ : Filter.IsBoundedUnder r l u\n⊢ Filter.IsBoundedUnder q l (Function.comp v u)","decl":"theorem IsBoundedUnder.comp {l : Filter γ} {q : β → β → Prop} {u : γ → α} {v : α → β}\n    (hv : ∀ a₀ a₁, r a₀ a₁ → q (v a₀) (v a₁)) : l.IsBoundedUnder r u → l.IsBoundedUnder q (v ∘ u)\n  | ⟨a, h⟩ => ⟨v a, show ∀ᶠ x in map u l, q (v x) (v a) from h.mono fun x => hv x a⟩\n\n"}
{"name":"Filter.IsBoundedUnder.eventually_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder α\nf : Filter β\nu : β → α\nh : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u\n⊢ Exists fun a => Filter.Eventually (fun x => LE.le (u x) a) f","decl":"lemma IsBoundedUnder.eventually_le (h : IsBoundedUnder (· ≤ ·) f u) :\n    ∃ a, ∀ᶠ x in f, u x ≤ a := by\n  obtain ⟨a, ha⟩ := h\n  use a\n  exact eventually_map.1 ha\n\n"}
{"name":"Filter.IsBoundedUnder.eventually_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder α\nf : Filter β\nu : β → α\nh : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u\n⊢ Exists fun a => Filter.Eventually (fun x => LE.le a (u x)) f","decl":"lemma IsBoundedUnder.eventually_ge (h : IsBoundedUnder (· ≥ ·) f u) :\n    ∃ a, ∀ᶠ x in f, a ≤ u x :=\n  IsBoundedUnder.eventually_le (α := αᵒᵈ) h\n\n"}
{"name":"Filter.isBoundedUnder_of_eventually_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder α\nf : Filter β\nu : β → α\na : α\nh : Filter.Eventually (fun x => LE.le (u x) a) f\n⊢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u","decl":"lemma isBoundedUnder_of_eventually_le {a : α} (h : ∀ᶠ x in f, u x ≤ a) :\n    IsBoundedUnder (· ≤ ·) f u := ⟨a, h⟩\n\n"}
{"name":"Filter.isBoundedUnder_of_eventually_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder α\nf : Filter β\nu : β → α\na : α\nh : Filter.Eventually (fun x => LE.le a (u x)) f\n⊢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u","decl":"lemma isBoundedUnder_of_eventually_ge {a : α} (h : ∀ᶠ x in f, a ≤ u x) :\n    IsBoundedUnder (· ≥ ·) f u := ⟨a, h⟩\n\n"}
{"name":"Filter.isBoundedUnder_iff_eventually_bddAbove","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder α\nf : Filter β\nu : β → α\n⊢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) (Exists fun s => And (BddAbove (Set.image u s)) (Filter.Eventually (fun x => Membership.mem s x) f))","decl":"lemma isBoundedUnder_iff_eventually_bddAbove :\n    f.IsBoundedUnder (· ≤ ·) u ↔ ∃ s, BddAbove (u '' s) ∧ ∀ᶠ x in f, x ∈ s := by\n  constructor\n  · rintro ⟨b, hb⟩\n    exact ⟨{a | u a ≤ b}, ⟨b, by rintro _ ⟨a, ha, rfl⟩; exact ha⟩, hb⟩\n  · rintro ⟨s, ⟨b, hb⟩, hs⟩\n    exact ⟨b, hs.mono <| by simpa [upperBounds] using hb⟩\n\n"}
{"name":"Filter.isBoundedUnder_iff_eventually_bddBelow","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder α\nf : Filter β\nu : β → α\n⊢ Iff (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) (Exists fun s => And (BddBelow (Set.image u s)) (Filter.Eventually (fun x => Membership.mem s x) f))","decl":"lemma isBoundedUnder_iff_eventually_bddBelow :\n    f.IsBoundedUnder (· ≥ ·) u ↔ ∃ s, BddBelow (u '' s) ∧ ∀ᶠ x in f, x ∈ s :=\n  isBoundedUnder_iff_eventually_bddAbove (α := αᵒᵈ)\n\n"}
{"name":"BddAbove.isBoundedUnder","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder α\nf : Filter β\nu : β → α\ns : Set β\nhs : Membership.mem f s\nhu : BddAbove (Set.image u s)\n⊢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u","decl":"lemma _root_.BddAbove.isBoundedUnder (hs : s ∈ f) (hu : BddAbove (u '' s)) :\n    f.IsBoundedUnder (· ≤ ·) u := isBoundedUnder_iff_eventually_bddAbove.2 ⟨_, hu, hs⟩\n\n"}
{"name":"BddAbove.isBoundedUnder_of_range","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder α\nf : Filter β\nu : β → α\nhu : BddAbove (Set.range u)\n⊢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u","decl":"/-- A bounded above function `u` is in particular eventually bounded above. -/\nlemma _root_.BddAbove.isBoundedUnder_of_range (hu : BddAbove (Set.range u)) :\n    f.IsBoundedUnder (· ≤ ·) u := BddAbove.isBoundedUnder (s := univ) f.univ_mem (by simpa)\n\n"}
{"name":"BddBelow.isBoundedUnder","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder α\nf : Filter β\nu : β → α\ns : Set β\nhs : Membership.mem f s\nhu : BddBelow (Set.image u s)\n⊢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u","decl":"lemma _root_.BddBelow.isBoundedUnder (hs : s ∈ f) (hu : BddBelow (u '' s)) :\n    f.IsBoundedUnder (· ≥ ·) u := isBoundedUnder_iff_eventually_bddBelow.2 ⟨_, hu, hs⟩\n\n"}
{"name":"BddBelow.isBoundedUnder_of_range","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Preorder α\nf : Filter β\nu : β → α\nhu : BddBelow (Set.range u)\n⊢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u","decl":"/-- A bounded below function `u` is in particular eventually bounded below. -/\nlemma _root_.BddBelow.isBoundedUnder_of_range (hu : BddBelow (Set.range u)) :\n    f.IsBoundedUnder (· ≥ ·) u := BddBelow.isBoundedUnder (s := univ) f.univ_mem (by simpa)\n\n"}
{"name":"Filter.IsBoundedUnder.le_of_finite","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Nonempty α\ninst✝¹ : IsDirected α fun x1 x2 => LE.le x1 x2\ninst✝ : Finite β\nf : Filter β\nu : β → α\n⊢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u","decl":"lemma IsBoundedUnder.le_of_finite [Nonempty α] [IsDirected α (· ≤ ·)] [Finite β]\n    {f : Filter β} {u : β → α} : IsBoundedUnder (· ≤ ·) f u :=\n  (Set.toFinite _).bddAbove.isBoundedUnder_of_range\n\n"}
{"name":"Filter.IsBoundedUnder.ge_of_finite","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Nonempty α\ninst✝¹ : IsDirected α fun x1 x2 => GE.ge x1 x2\ninst✝ : Finite β\nf : Filter β\nu : β → α\n⊢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u","decl":"lemma IsBoundedUnder.ge_of_finite [Nonempty α] [IsDirected α (· ≥ ·)] [Finite β]\n    {f : Filter β} {u : β → α} : IsBoundedUnder (· ≥ ·) f u :=\n  (Set.toFinite _).bddBelow.isBoundedUnder_of_range\n\n"}
{"name":"Monotone.isBoundedUnder_le_comp","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : Filter γ\nu : γ → α\nv : α → β\nhv : Monotone v\nhl : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l u\n⊢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp v u)","decl":"theorem _root_.Monotone.isBoundedUnder_le_comp [Preorder α] [Preorder β] {l : Filter γ} {u : γ → α}\n    {v : α → β} (hv : Monotone v) (hl : l.IsBoundedUnder (· ≤ ·) u) :\n    l.IsBoundedUnder (· ≤ ·) (v ∘ u) :=\n  hl.comp hv\n\n"}
{"name":"Monotone.isBoundedUnder_ge_comp","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : Filter γ\nu : γ → α\nv : α → β\nhv : Monotone v\nhl : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l u\n⊢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l (Function.comp v u)","decl":"theorem _root_.Monotone.isBoundedUnder_ge_comp [Preorder α] [Preorder β] {l : Filter γ} {u : γ → α}\n    {v : α → β} (hv : Monotone v) (hl : l.IsBoundedUnder (· ≥ ·) u) :\n    l.IsBoundedUnder (· ≥ ·) (v ∘ u) :=\n  hl.comp (swap hv)\n\n"}
{"name":"Antitone.isBoundedUnder_le_comp","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : Filter γ\nu : γ → α\nv : α → β\nhv : Antitone v\nhl : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l u\n⊢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp v u)","decl":"theorem _root_.Antitone.isBoundedUnder_le_comp [Preorder α] [Preorder β] {l : Filter γ} {u : γ → α}\n    {v : α → β} (hv : Antitone v) (hl : l.IsBoundedUnder (· ≥ ·) u) :\n    l.IsBoundedUnder (· ≤ ·) (v ∘ u) :=\n  hl.comp (swap hv)\n\n"}
{"name":"Antitone.isBoundedUnder_ge_comp","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\nl : Filter γ\nu : γ → α\nv : α → β\nhv : Antitone v\nhl : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l u\n⊢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l (Function.comp v u)","decl":"theorem _root_.Antitone.isBoundedUnder_ge_comp [Preorder α] [Preorder β] {l : Filter γ} {u : γ → α}\n    {v : α → β} (hv : Antitone v) (hl : l.IsBoundedUnder (· ≤ ·) u) :\n    l.IsBoundedUnder (· ≥ ·) (v ∘ u) :=\n  hl.comp hv\n\n"}
{"name":"Filter.not_isBoundedUnder_of_tendsto_atTop","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Preorder β\ninst✝¹ : NoMaxOrder β\nf : α → β\nl : Filter α\ninst✝ : l.NeBot\nhf : Filter.Tendsto f l Filter.atTop\n⊢ Not (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l f)","decl":"theorem not_isBoundedUnder_of_tendsto_atTop [Preorder β] [NoMaxOrder β] {f : α → β} {l : Filter α}\n    [l.NeBot] (hf : Tendsto f l atTop) : ¬IsBoundedUnder (· ≤ ·) l f := by\n  rintro ⟨b, hb⟩\n  rw [eventually_map] at hb\n  obtain ⟨b', h⟩ := exists_gt b\n  have hb' := (tendsto_atTop.mp hf) b'\n  have : { x : α | f x ≤ b } ∩ { x : α | b' ≤ f x } = ∅ :=\n    eq_empty_of_subset_empty fun x hx => (not_le_of_lt h) (le_trans hx.2 hx.1)\n  exact (nonempty_of_mem (hb.and hb')).ne_empty this\n\n"}
{"name":"Filter.not_isBoundedUnder_of_tendsto_atBot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Preorder β\ninst✝¹ : NoMinOrder β\nf : α → β\nl : Filter α\ninst✝ : l.NeBot\nhf : Filter.Tendsto f l Filter.atBot\n⊢ Not (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l f)","decl":"theorem not_isBoundedUnder_of_tendsto_atBot [Preorder β] [NoMinOrder β] {f : α → β} {l : Filter α}\n    [l.NeBot] (hf : Tendsto f l atBot) : ¬IsBoundedUnder (· ≥ ·) l f :=\n  not_isBoundedUnder_of_tendsto_atTop (β := βᵒᵈ) hf\n\n"}
{"name":"Filter.IsBoundedUnder.bddAbove_range_of_cofinite","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder β\ninst✝ : IsDirected β fun x1 x2 => LE.le x1 x2\nf : α → β\nhf : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) Filter.cofinite f\n⊢ BddAbove (Set.range f)","decl":"theorem IsBoundedUnder.bddAbove_range_of_cofinite [Preorder β] [IsDirected β (· ≤ ·)] {f : α → β}\n    (hf : IsBoundedUnder (· ≤ ·) cofinite f) : BddAbove (range f) := by\n  rcases hf with ⟨b, hb⟩\n  haveI : Nonempty β := ⟨b⟩\n  rw [← image_univ, ← union_compl_self { x | f x ≤ b }, image_union, bddAbove_union]\n  exact ⟨⟨b, forall_mem_image.2 fun x => id⟩, (hb.image f).bddAbove⟩\n\n"}
{"name":"Filter.IsBoundedUnder.bddBelow_range_of_cofinite","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder β\ninst✝ : IsDirected β fun x1 x2 => GE.ge x1 x2\nf : α → β\nhf : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) Filter.cofinite f\n⊢ BddBelow (Set.range f)","decl":"theorem IsBoundedUnder.bddBelow_range_of_cofinite [Preorder β] [IsDirected β (· ≥ ·)] {f : α → β}\n    (hf : IsBoundedUnder (· ≥ ·) cofinite f) : BddBelow (range f) :=\n  IsBoundedUnder.bddAbove_range_of_cofinite (β := βᵒᵈ) hf\n\n"}
{"name":"Filter.IsBoundedUnder.bddAbove_range","module":"Mathlib.Order.LiminfLimsup","initialProofState":"β : Type u_2\ninst✝¹ : Preorder β\ninst✝ : IsDirected β fun x1 x2 => LE.le x1 x2\nf : Nat → β\nhf : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) Filter.atTop f\n⊢ BddAbove (Set.range f)","decl":"theorem IsBoundedUnder.bddAbove_range [Preorder β] [IsDirected β (· ≤ ·)] {f : ℕ → β}\n    (hf : IsBoundedUnder (· ≤ ·) atTop f) : BddAbove (range f) := by\n  rw [← Nat.cofinite_eq_atTop] at hf\n  exact hf.bddAbove_range_of_cofinite\n\n"}
{"name":"Filter.IsBoundedUnder.bddBelow_range","module":"Mathlib.Order.LiminfLimsup","initialProofState":"β : Type u_2\ninst✝¹ : Preorder β\ninst✝ : IsDirected β fun x1 x2 => GE.ge x1 x2\nf : Nat → β\nhf : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) Filter.atTop f\n⊢ BddBelow (Set.range f)","decl":"theorem IsBoundedUnder.bddBelow_range [Preorder β] [IsDirected β (· ≥ ·)] {f : ℕ → β}\n    (hf : IsBoundedUnder (· ≥ ·) atTop f) : BddBelow (range f) :=\n  IsBoundedUnder.bddAbove_range (β := βᵒᵈ) hf\n\n"}
{"name":"Filter.IsCobounded.mk","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nr : α → α → Prop\nf : Filter α\ninst✝ : IsTrans α r\na : α\nh : ∀ (s : Set α), Membership.mem f s → Exists fun x => And (Membership.mem s x) (r a x)\n⊢ Filter.IsCobounded r f","decl":"/-- To check that a filter is frequently bounded, it suffices to have a witness\nwhich bounds `f` at some point for every admissible set.\n\nThis is only an implication, as the other direction is wrong for the trivial filter. -/\ntheorem IsCobounded.mk [IsTrans α r] (a : α) (h : ∀ s ∈ f, ∃ x ∈ s, r a x) : f.IsCobounded r :=\n  ⟨a, fun _ s =>\n    let ⟨_, h₁, h₂⟩ := h _ s\n    _root_.trans h₂ h₁⟩\n\n"}
{"name":"Filter.IsBounded.isCobounded_flip","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nr : α → α → Prop\nf : Filter α\ninst✝¹ : IsTrans α r\ninst✝ : f.NeBot\na✝ : Filter.IsBounded r f\n⊢ Filter.IsCobounded (flip r) f","decl":"/-- A filter which is eventually bounded is in particular frequently bounded (in the opposite\ndirection). At least if the filter is not trivial. -/\ntheorem IsBounded.isCobounded_flip [IsTrans α r] [NeBot f] : f.IsBounded r → f.IsCobounded (flip r)\n  | ⟨a, ha⟩ =>\n    ⟨a, fun b hb =>\n      let ⟨_, rxa, rbx⟩ := (ha.and hb).exists\n      show r b a from _root_.trans rbx rxa⟩\n\n"}
{"name":"Filter.IsBounded.isCobounded_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nf : Filter α\ninst✝¹ : Preorder α\ninst✝ : f.NeBot\nh : Filter.IsBounded (fun x1 x2 => LE.le x1 x2) f\n⊢ Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) f","decl":"theorem IsBounded.isCobounded_ge [Preorder α] [NeBot f] (h : f.IsBounded (· ≤ ·)) :\n    f.IsCobounded (· ≥ ·) :=\n  h.isCobounded_flip\n\n"}
{"name":"Filter.IsBounded.isCobounded_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nf : Filter α\ninst✝¹ : Preorder α\ninst✝ : f.NeBot\nh : Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) f\n⊢ Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) f","decl":"theorem IsBounded.isCobounded_le [Preorder α] [NeBot f] (h : f.IsBounded (· ≥ ·)) :\n    f.IsCobounded (· ≤ ·) :=\n  h.isCobounded_flip\n\n"}
{"name":"Filter.IsBoundedUnder.isCoboundedUnder_flip","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nγ : Type u_3\nr : α → α → Prop\nu : γ → α\nl : Filter γ\ninst✝¹ : IsTrans α r\ninst✝ : l.NeBot\nh : Filter.IsBoundedUnder r l u\n⊢ Filter.IsCoboundedUnder (flip r) l u","decl":"theorem IsBoundedUnder.isCoboundedUnder_flip {u : γ → α} {l : Filter γ} [IsTrans α r] [NeBot l]\n    (h : l.IsBoundedUnder r u) : l.IsCoboundedUnder (flip r) u :=\n  h.isCobounded_flip\n\n"}
{"name":"Filter.IsBoundedUnder.isCoboundedUnder_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nγ : Type u_3\nu : γ → α\nl : Filter γ\ninst✝¹ : Preorder α\ninst✝ : l.NeBot\nh : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l u\n⊢ Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) l u","decl":"theorem IsBoundedUnder.isCoboundedUnder_le {u : γ → α} {l : Filter γ} [Preorder α] [NeBot l]\n    (h : l.IsBoundedUnder (· ≥ ·) u) : l.IsCoboundedUnder (· ≤ ·) u :=\n  h.isCoboundedUnder_flip\n\n"}
{"name":"Filter.IsBoundedUnder.isCoboundedUnder_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nγ : Type u_3\nu : γ → α\nl : Filter γ\ninst✝¹ : Preorder α\ninst✝ : l.NeBot\nh : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l u\n⊢ Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) l u","decl":"theorem IsBoundedUnder.isCoboundedUnder_ge {u : γ → α} {l : Filter γ} [Preorder α] [NeBot l]\n    (h : l.IsBoundedUnder (· ≤ ·) u) : l.IsCoboundedUnder (· ≥ ·) u :=\n  h.isCoboundedUnder_flip\n\n"}
{"name":"Filter.isCoboundedUnder_le_of_eventually_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : Preorder α\nl : Filter ι\ninst✝ : l.NeBot\nf : ι → α\nx : α\nhf : Filter.Eventually (fun i => LE.le x (f i)) l\n⊢ Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) l f","decl":"lemma isCoboundedUnder_le_of_eventually_le [Preorder α] (l : Filter ι) [NeBot l] {f : ι → α} {x : α}\n    (hf : ∀ᶠ i in l, x ≤ f i) :\n    IsCoboundedUnder (· ≤ ·) l f :=\n  IsBoundedUnder.isCoboundedUnder_le ⟨x, hf⟩\n\n"}
{"name":"Filter.isCoboundedUnder_ge_of_eventually_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : Preorder α\nl : Filter ι\ninst✝ : l.NeBot\nf : ι → α\nx : α\nhf : Filter.Eventually (fun i => LE.le (f i) x) l\n⊢ Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) l f","decl":"lemma isCoboundedUnder_ge_of_eventually_le [Preorder α] (l : Filter ι) [NeBot l] {f : ι → α} {x : α}\n    (hf : ∀ᶠ i in l, f i ≤ x) :\n    IsCoboundedUnder (· ≥ ·) l f :=\n  IsBoundedUnder.isCoboundedUnder_ge ⟨x, hf⟩\n\n"}
{"name":"Filter.isCoboundedUnder_le_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : Preorder α\nl : Filter ι\ninst✝ : l.NeBot\nf : ι → α\nx : α\nhf : ∀ (i : ι), LE.le x (f i)\n⊢ Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) l f","decl":"lemma isCoboundedUnder_le_of_le [Preorder α] (l : Filter ι) [NeBot l] {f : ι → α} {x : α}\n    (hf : ∀ i, x ≤ f i) :\n    IsCoboundedUnder (· ≤ ·) l f :=\n  isCoboundedUnder_le_of_eventually_le l (Eventually.of_forall hf)\n\n"}
{"name":"Filter.isCoboundedUnder_ge_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : Preorder α\nl : Filter ι\ninst✝ : l.NeBot\nf : ι → α\nx : α\nhf : ∀ (i : ι), LE.le (f i) x\n⊢ Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) l f","decl":"lemma isCoboundedUnder_ge_of_le [Preorder α] (l : Filter ι) [NeBot l] {f : ι → α} {x : α}\n    (hf : ∀ i, f i ≤ x) :\n    IsCoboundedUnder (· ≥ ·) l f :=\n  isCoboundedUnder_ge_of_eventually_le l (Eventually.of_forall hf)\n\n"}
{"name":"Filter.isCobounded_bot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Iff (Filter.IsCobounded r Bot.bot) (Exists fun b => ∀ (x : α), r b x)","decl":"theorem isCobounded_bot : IsCobounded r ⊥ ↔ ∃ b, ∀ x, r b x := by simp [IsCobounded]\n\n"}
{"name":"Filter.isCobounded_top","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Iff (Filter.IsCobounded r Top.top) (Nonempty α)","decl":"theorem isCobounded_top : IsCobounded r ⊤ ↔ Nonempty α := by\n  simp +contextual [IsCobounded, eq_univ_iff_forall,\n    exists_true_iff_nonempty]\n\n"}
{"name":"Filter.isCobounded_principal","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\n⊢ Iff (Filter.IsCobounded r (Filter.principal s)) (Exists fun b => ∀ (a : α), (∀ (x : α), Membership.mem s x → r x a) → r b a)","decl":"theorem isCobounded_principal (s : Set α) :\n    (𝓟 s).IsCobounded r ↔ ∃ b, ∀ a, (∀ x ∈ s, r x a) → r b a := by simp [IsCobounded, subset_def]\n\n"}
{"name":"Filter.IsCobounded.mono","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nr : α → α → Prop\nf g : Filter α\nh : LE.le f g\na✝ : Filter.IsCobounded r f\n⊢ Filter.IsCobounded r g","decl":"theorem IsCobounded.mono (h : f ≤ g) : f.IsCobounded r → g.IsCobounded r\n  | ⟨b, hb⟩ => ⟨b, fun a ha => hb a (h ha)⟩\n\n"}
{"name":"Filter.IsCobounded.frequently_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nf : Filter α\ninst✝¹ : LinearOrder α\ninst✝ : f.NeBot\ncobdd : Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) f\n⊢ Exists fun l => Filter.Frequently (fun x => LE.le l x) f","decl":"/-- For nontrivial filters in linear orders, coboundedness for `≤` implies frequent boundedness\nfrom below. -/\nlemma IsCobounded.frequently_ge [LinearOrder α] [NeBot f] (cobdd : IsCobounded (· ≤ ·) f) :\n    ∃ l, ∃ᶠ x in f, l ≤ x := by\n  obtain ⟨t, ht⟩ := cobdd\n  rcases isBot_or_exists_lt t with tbot | ⟨t', ht'⟩\n  · exact ⟨t, .of_forall fun r ↦ tbot r⟩\n  refine ⟨t', fun ev ↦ ?_⟩\n  specialize ht t' (by filter_upwards [ev] with _ h using (not_le.mp h).le)\n  exact not_lt_of_le ht ht'\n\n"}
{"name":"Filter.IsCobounded.frequently_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nf : Filter α\ninst✝¹ : LinearOrder α\ninst✝ : f.NeBot\ncobdd : Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) f\n⊢ Exists fun u => Filter.Frequently (fun x => LE.le x u) f","decl":"/-- For nontrivial filters in linear orders, coboundedness for `≥` implies frequent boundedness\nfrom above. -/\nlemma IsCobounded.frequently_le [LinearOrder α] [NeBot f] (cobdd : IsCobounded (· ≥ ·) f) :\n    ∃ u, ∃ᶠ x in f, x ≤ u :=\n  cobdd.frequently_ge (α := αᵒᵈ)\n\n"}
{"name":"Filter.IsCobounded.of_frequently_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nf : Filter α\ninst✝ : LinearOrder α\nl : α\nfreq_ge : Filter.Frequently (fun x => LE.le l x) f\n⊢ Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) f","decl":"/-- In linear orders, frequent boundedness from below implies coboundedness for `≤`. -/\nlemma IsCobounded.of_frequently_ge [LinearOrder α] {l : α} (freq_ge : ∃ᶠ x in f, l ≤ x) :\n    IsCobounded (· ≤ ·) f := by\n  rcases isBot_or_exists_lt l with lbot | ⟨l', hl'⟩\n  · exact ⟨l, fun x _ ↦ lbot x⟩\n  refine ⟨l', fun u hu ↦ ?_⟩\n  obtain ⟨w, l_le_w, w_le_u⟩ := (freq_ge.and_eventually hu).exists\n  exact hl'.le.trans (l_le_w.trans w_le_u)\n\n"}
{"name":"Filter.IsCobounded.of_frequently_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nf : Filter α\ninst✝ : LinearOrder α\nu : α\nfreq_le : Filter.Frequently (fun r => LE.le r u) f\n⊢ Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) f","decl":"/-- In linear orders, frequent boundedness from above implies coboundedness for `≥`. -/\nlemma IsCobounded.of_frequently_le [LinearOrder α] {u : α} (freq_le : ∃ᶠ r in f, r ≤ u) :\n    IsCobounded (· ≥ ·) f :=\n  IsCobounded.of_frequently_ge (α := αᵒᵈ) freq_le\n\n"}
{"name":"Filter.IsCoboundedUnder.frequently_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : LinearOrder α\nf : Filter ι\ninst✝ : f.NeBot\nu : ι → α\nh : Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u\n⊢ Exists fun a => Filter.Frequently (fun x => LE.le a (u x)) f","decl":"lemma IsCoboundedUnder.frequently_ge [LinearOrder α] {f : Filter ι} [NeBot f] {u : ι → α}\n    (h : IsCoboundedUnder (· ≤ ·) f u) :\n    ∃ a, ∃ᶠ x in f, a ≤ u x :=\n  IsCobounded.frequently_ge h\n\n"}
{"name":"Filter.IsCoboundedUnder.frequently_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝¹ : LinearOrder α\nf : Filter ι\ninst✝ : f.NeBot\nu : ι → α\nh : Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f u\n⊢ Exists fun a => Filter.Frequently (fun x => LE.le (u x) a) f","decl":"lemma IsCoboundedUnder.frequently_le [LinearOrder α] {f : Filter ι} [NeBot f] {u : ι → α}\n    (h : IsCoboundedUnder (· ≥ ·) f u) :\n    ∃ a, ∃ᶠ x in f, u x ≤ a :=\n  IsCobounded.frequently_le h\n\n"}
{"name":"Filter.IsCoboundedUnder.of_frequently_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝ : LinearOrder α\nf : Filter ι\nu : ι → α\na : α\nfreq_ge : Filter.Frequently (fun x => LE.le a (u x)) f\n⊢ Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u","decl":"lemma IsCoboundedUnder.of_frequently_ge [LinearOrder α] {f : Filter ι} {u : ι → α}\n    {a : α} (freq_ge : ∃ᶠ x in f, a ≤ u x) :\n    IsCoboundedUnder (· ≤ ·) f u :=\n  IsCobounded.of_frequently_ge freq_ge\n\n"}
{"name":"Filter.IsCoboundedUnder.of_frequently_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝ : LinearOrder α\nf : Filter ι\nu : ι → α\na : α\nfreq_le : Filter.Frequently (fun x => LE.le (u x) a) f\n⊢ Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f u","decl":"lemma IsCoboundedUnder.of_frequently_le [LinearOrder α] {f : Filter ι} {u : ι → α}\n    {a : α} (freq_le : ∃ᶠ x in f, u x ≤ a) :\n    IsCoboundedUnder (· ≥ ·) f u :=\n  IsCobounded.of_frequently_le freq_le\n\n"}
{"name":"Filter.isBoundedUnder_sum","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_6\nf : Filter α\nR : Type u_7\nκ : Type u_8\ninst✝ : AddCommMonoid R\nr : R → R → Prop\nhr : ∀ (v₁ v₂ : α → R), Filter.IsBoundedUnder r f v₁ → Filter.IsBoundedUnder r f v₂ → Filter.IsBoundedUnder r f (HAdd.hAdd v₁ v₂)\nhr₀ : r 0 0\nu : κ → α → R\ns : Finset κ\nh : ∀ (k : κ), Membership.mem s k → Filter.IsBoundedUnder r f (u k)\n⊢ Filter.IsBoundedUnder r f (s.sum fun k => u k)","decl":"lemma isBoundedUnder_sum {κ : Type*} [AddCommMonoid R] {r : R → R → Prop}\n    (hr : ∀ (v₁ v₂ : α → R), f.IsBoundedUnder r v₁ → f.IsBoundedUnder r v₂\n      → f.IsBoundedUnder r (v₁ + v₂)) (hr₀ : r 0 0)\n    {u : κ → α → R} (s : Finset κ) (h : ∀ k ∈ s, f.IsBoundedUnder r (u k)) :\n    f.IsBoundedUnder r (∑ k ∈ s, u k) := by\n  induction s using Finset.cons_induction\n  case empty =>\n    rw [Finset.sum_empty]\n    exact ⟨0, by simp_all only [eventually_map, Pi.zero_apply, eventually_true]⟩\n  case cons k₀ s k₀_notin_s ih =>\n    simp only [Finset.forall_mem_cons] at *\n    simpa only [Finset.sum_cons] using hr _ _ h.1 (ih h.2)\n\n"}
{"name":"Filter.isBoundedUnder_ge_add","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_6\nf : Filter α\nR : Type u_7\ninst✝³ : Preorder R\ninst✝² : Add R\ninst✝¹ : AddLeftMono R\ninst✝ : AddRightMono R\nu v : α → R\nu_bdd_ge : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u\nv_bdd_ge : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f v\n⊢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f (HAdd.hAdd u v)","decl":"lemma isBoundedUnder_ge_add [Add R] [AddLeftMono R] [AddRightMono R]\n    {u v : α → R} (u_bdd_ge : f.IsBoundedUnder (· ≥ ·) u) (v_bdd_ge : f.IsBoundedUnder (· ≥ ·) v) :\n    f.IsBoundedUnder (· ≥ ·) (u + v) := by\n  obtain ⟨U, hU⟩ := u_bdd_ge\n  obtain ⟨V, hV⟩ := v_bdd_ge\n  use U + V\n  simp only [eventually_map, Pi.add_apply] at hU hV ⊢\n  filter_upwards [hU, hV] with a hu hv using add_le_add hu hv\n\n"}
{"name":"Filter.isBoundedUnder_le_add","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_6\nf : Filter α\nR : Type u_7\ninst✝³ : Preorder R\ninst✝² : Add R\ninst✝¹ : AddLeftMono R\ninst✝ : AddRightMono R\nu v : α → R\nu_bdd_le : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u\nv_bdd_le : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f v\n⊢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f (HAdd.hAdd u v)","decl":"lemma isBoundedUnder_le_add [Add R] [AddLeftMono R] [AddRightMono R]\n    {u v : α → R} (u_bdd_le : f.IsBoundedUnder (· ≤ ·) u) (v_bdd_le : f.IsBoundedUnder (· ≤ ·) v) :\n    f.IsBoundedUnder (· ≤ ·) (u + v) := by\n  obtain ⟨U, hU⟩ := u_bdd_le\n  obtain ⟨V, hV⟩ := v_bdd_le\n  use U + V\n  simp only [eventually_map, Pi.add_apply] at hU hV ⊢\n  filter_upwards [hU, hV] with a hu hv using add_le_add hu hv\n\n"}
{"name":"Filter.isBoundedUnder_le_sum","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_6\nf : Filter α\nR : Type u_7\ninst✝³ : Preorder R\nκ : Type u_8\ninst✝² : AddCommMonoid R\ninst✝¹ : AddLeftMono R\ninst✝ : AddRightMono R\nu : κ → α → R\ns : Finset κ\na✝ : ∀ (k : κ), Membership.mem s k → Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f (u k)\n⊢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f (s.sum fun k => u k)","decl":"lemma isBoundedUnder_le_sum {κ : Type*} [AddCommMonoid R] [AddLeftMono R] [AddRightMono R]\n    {u : κ → α → R} (s : Finset κ) :\n    (∀ k ∈ s, f.IsBoundedUnder (· ≤ ·) (u k)) → f.IsBoundedUnder (· ≤ ·) (∑ k ∈ s, u k) :=\n  fun h ↦ isBoundedUnder_sum (fun _ _ ↦ isBoundedUnder_le_add) le_rfl s h\n\n"}
{"name":"Filter.isBoundedUnder_ge_sum","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_6\nf : Filter α\nR : Type u_7\ninst✝³ : Preorder R\nκ : Type u_8\ninst✝² : AddCommMonoid R\ninst✝¹ : AddLeftMono R\ninst✝ : AddRightMono R\nu : κ → α → R\ns : Finset κ\na✝ : ∀ (k : κ), Membership.mem s k → Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f (u k)\n⊢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f (s.sum fun k => u k)","decl":"lemma isBoundedUnder_ge_sum {κ : Type*} [AddCommMonoid R] [AddLeftMono R] [AddRightMono R]\n    {u : κ → α → R} (s : Finset κ) :\n    (∀ k ∈ s, f.IsBoundedUnder (· ≥ ·) (u k)) →\n      f.IsBoundedUnder (· ≥ ·) (∑ k ∈ s, u k) :=\n  fun h ↦ isBoundedUnder_sum (fun _ _ ↦ isBoundedUnder_ge_add) le_rfl s h\n\n"}
{"name":"Filter.isCoboundedUnder_ge_add","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_6\nR : Type u_7\ninst✝⁴ : LinearOrder R\ninst✝³ : Add R\nf : Filter α\ninst✝² : f.NeBot\ninst✝¹ : CovariantClass R R (fun a b => HAdd.hAdd a b) fun x1 x2 => LE.le x1 x2\ninst✝ : CovariantClass R R (fun a b => HAdd.hAdd b a) fun x1 x2 => LE.le x1 x2\nu v : α → R\nhu : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u\nhv : Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f v\n⊢ Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f (HAdd.hAdd u v)","decl":"lemma isCoboundedUnder_ge_add (hu : f.IsBoundedUnder (· ≤ ·) u)\n    (hv : f.IsCoboundedUnder (· ≥ ·) v) :\n    f.IsCoboundedUnder (· ≥ ·) (u + v) := by\n  obtain ⟨U, hU⟩ := hu.eventually_le\n  obtain ⟨V, hV⟩ := hv.frequently_le\n  apply IsCoboundedUnder.of_frequently_le (a := U + V)\n  exact (hV.and_eventually hU).mono fun x hx ↦ add_le_add hx.2 hx.1\n\n"}
{"name":"Filter.isCoboundedUnder_le_add","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_6\nR : Type u_7\ninst✝⁴ : LinearOrder R\ninst✝³ : Add R\nf : Filter α\ninst✝² : f.NeBot\ninst✝¹ : CovariantClass R R (fun a b => HAdd.hAdd a b) fun x1 x2 => LE.le x1 x2\ninst✝ : CovariantClass R R (fun a b => HAdd.hAdd b a) fun x1 x2 => LE.le x1 x2\nu v : α → R\nhu : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u\nhv : Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f v\n⊢ Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f (HAdd.hAdd u v)","decl":"lemma isCoboundedUnder_le_add (hu : f.IsBoundedUnder (· ≥ ·) u)\n    (hv : f.IsCoboundedUnder (· ≤ ·) v) :\n    f.IsCoboundedUnder (· ≤ ·) (u + v) := by\n  obtain ⟨U, hU⟩ := hu.eventually_ge\n  obtain ⟨V, hV⟩ := hv.frequently_ge\n  apply IsCoboundedUnder.of_frequently_ge (a := U + V)\n  exact (hV.and_eventually hU).mono fun x hx ↦ add_le_add hx.2 hx.1\n\n"}
{"name":"Filter.isBoundedUnder_le_mul_of_nonneg","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝⁴ : Mul α\ninst✝³ : Zero α\ninst✝² : Preorder α\ninst✝¹ : PosMulMono α\ninst✝ : MulPosMono α\nf : Filter ι\nu v : ι → α\nh₁ : f.EventuallyLE 0 u\nh₂ : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u\nh₃ : f.EventuallyLE 0 v\nh₄ : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f v\n⊢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f (HMul.hMul u v)","decl":"lemma isBoundedUnder_le_mul_of_nonneg [Mul α] [Zero α] [Preorder α] [PosMulMono α]\n    [MulPosMono α] {f : Filter ι} {u v : ι → α} (h₁ : 0 ≤ᶠ[f] u)\n    (h₂ : IsBoundedUnder (fun x1 x2 ↦ x1 ≤ x2) f u)\n    (h₃ : 0 ≤ᶠ[f] v)\n    (h₄ : IsBoundedUnder (fun x1 x2 ↦ x1 ≤ x2) f v) :\n    IsBoundedUnder (fun x1 x2 ↦ x1 ≤ x2) f (u * v) := by\n  obtain ⟨U, hU⟩ := h₂.eventually_le\n  obtain ⟨V, hV⟩ := h₄.eventually_le\n  refine isBoundedUnder_of_eventually_le (a := U * V) ?_\n  filter_upwards [hU, hV, h₁, h₃] with x x_U x_V u_0 v_0\n  exact mul_le_mul x_U x_V v_0 (u_0.trans x_U)\n\n"}
{"name":"Filter.isCoboundedUnder_ge_mul_of_nonneg","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝⁵ : Mul α\ninst✝⁴ : Zero α\ninst✝³ : LinearOrder α\ninst✝² : PosMulMono α\ninst✝¹ : MulPosMono α\nf : Filter ι\ninst✝ : f.NeBot\nu v : ι → α\nh₁ : f.EventuallyLE 0 u\nh₂ : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u\nh₃ : f.EventuallyLE 0 v\nh₄ : Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f v\n⊢ Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f (HMul.hMul u v)","decl":"lemma isCoboundedUnder_ge_mul_of_nonneg [Mul α] [Zero α] [LinearOrder α] [PosMulMono α]\n    [MulPosMono α] {f : Filter ι} [f.NeBot] {u v : ι → α} (h₁ : 0 ≤ᶠ[f] u)\n    (h₂ : IsBoundedUnder (fun x1 x2 ↦ x1 ≤ x2) f u)\n    (h₃ : 0 ≤ᶠ[f] v)\n    (h₄ : IsCoboundedUnder (fun x1 x2 ↦ x1 ≥ x2) f v) :\n    IsCoboundedUnder (fun x1 x2 ↦ x1 ≥ x2) f (u * v) := by\n  obtain ⟨U, hU⟩ := h₂.eventually_le\n  obtain ⟨V, hV⟩ := h₄.frequently_le\n  exact IsCoboundedUnder.of_frequently_le (a := U * V)\n    <| (hV.and_eventually (hU.and (h₁.and h₃))).mono fun x ⟨x_V, x_U, u_0, v_0⟩ ↦\n    mul_le_mul x_U x_V v_0 (u_0.trans x_U)\n\n"}
{"name":"Filter.isBounded_le_atBot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\n⊢ Filter.IsBounded (fun x1 x2 => LE.le x1 x2) Filter.atBot","decl":"theorem isBounded_le_atBot : (atBot : Filter α).IsBounded (· ≤ ·) :=\n  ‹Nonempty α›.elim fun a => ⟨a, eventually_le_atBot _⟩\n\n"}
{"name":"Filter.isBounded_ge_atTop","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\n⊢ Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) Filter.atTop","decl":"theorem isBounded_ge_atTop : (atTop : Filter α).IsBounded (· ≥ ·) :=\n  ‹Nonempty α›.elim fun a => ⟨a, eventually_ge_atTop _⟩\n\n"}
{"name":"Filter.Tendsto.isBoundedUnder_le_atBot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\nf : Filter β\nu : β → α\nh : Filter.Tendsto u f Filter.atBot\n⊢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u","decl":"theorem Tendsto.isBoundedUnder_le_atBot (h : Tendsto u f atBot) : f.IsBoundedUnder (· ≤ ·) u :=\n  isBounded_le_atBot.mono h\n\n"}
{"name":"Filter.Tendsto.isBoundedUnder_ge_atTop","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\nf : Filter β\nu : β → α\nh : Filter.Tendsto u f Filter.atTop\n⊢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u","decl":"theorem Tendsto.isBoundedUnder_ge_atTop (h : Tendsto u f atTop) : f.IsBoundedUnder (· ≥ ·) u :=\n  isBounded_ge_atTop.mono h\n\n"}
{"name":"Filter.bddAbove_range_of_tendsto_atTop_atBot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : Nonempty α\ninst✝ : IsDirected α fun x1 x2 => LE.le x1 x2\nu : Nat → α\nhx : Filter.Tendsto u Filter.atTop Filter.atBot\n⊢ BddAbove (Set.range u)","decl":"theorem bddAbove_range_of_tendsto_atTop_atBot [IsDirected α (· ≤ ·)] {u : ℕ → α}\n    (hx : Tendsto u atTop atBot) : BddAbove (Set.range u) :=\n  hx.isBoundedUnder_le_atBot.bddAbove_range\n\n"}
{"name":"Filter.bddBelow_range_of_tendsto_atTop_atTop","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : Nonempty α\ninst✝ : IsDirected α fun x1 x2 => GE.ge x1 x2\nu : Nat → α\nhx : Filter.Tendsto u Filter.atTop Filter.atTop\n⊢ BddBelow (Set.range u)","decl":"theorem bddBelow_range_of_tendsto_atTop_atTop [IsDirected α (· ≥ ·)] {u : ℕ → α}\n    (hx : Tendsto u atTop atTop) : BddBelow (Set.range u) :=\n  hx.isBoundedUnder_ge_atTop.bddBelow_range\n\n"}
{"name":"Filter.isCobounded_le_of_bot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\nf : Filter α\n⊢ Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) f","decl":"theorem isCobounded_le_of_bot [Preorder α] [OrderBot α] {f : Filter α} : f.IsCobounded (· ≤ ·) :=\n  ⟨⊥, fun _ _ => bot_le⟩\n\n"}
{"name":"Filter.isCobounded_ge_of_top","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\nf : Filter α\n⊢ Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) f","decl":"theorem isCobounded_ge_of_top [Preorder α] [OrderTop α] {f : Filter α} : f.IsCobounded (· ≥ ·) :=\n  ⟨⊤, fun _ _ => le_top⟩\n\n"}
{"name":"Filter.isBounded_le_of_top","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\nf : Filter α\n⊢ Filter.IsBounded (fun x1 x2 => LE.le x1 x2) f","decl":"theorem isBounded_le_of_top [Preorder α] [OrderTop α] {f : Filter α} : f.IsBounded (· ≤ ·) :=\n  ⟨⊤, Eventually.of_forall fun _ => le_top⟩\n\n"}
{"name":"Filter.isBounded_ge_of_bot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\nf : Filter α\n⊢ Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) f","decl":"theorem isBounded_ge_of_bot [Preorder α] [OrderBot α] {f : Filter α} : f.IsBounded (· ≥ ·) :=\n  ⟨⊥, Eventually.of_forall fun _ => bot_le⟩\n\n"}
{"name":"OrderIso.isBoundedUnder_le_comp","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderIso α β\nl : Filter γ\nu : γ → α\n⊢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l fun x => e (u x)) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l u)","decl":"@[simp]\ntheorem _root_.OrderIso.isBoundedUnder_le_comp [Preorder α] [Preorder β] (e : α ≃o β) {l : Filter γ}\n    {u : γ → α} : (IsBoundedUnder (· ≤ ·) l fun x => e (u x)) ↔ IsBoundedUnder (· ≤ ·) l u :=\n  (Function.Surjective.exists e.surjective).trans <|\n    exists_congr fun a => by simp only [eventually_map, e.le_iff_le]\n\n"}
{"name":"OrderIso.isBoundedUnder_ge_comp","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderIso α β\nl : Filter γ\nu : γ → α\n⊢ Iff (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l fun x => e (u x)) (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l u)","decl":"@[simp]\ntheorem _root_.OrderIso.isBoundedUnder_ge_comp [Preorder α] [Preorder β] (e : α ≃o β) {l : Filter γ}\n    {u : γ → α} : (IsBoundedUnder (· ≥ ·) l fun x => e (u x)) ↔ IsBoundedUnder (· ≥ ·) l u :=\n  OrderIso.isBoundedUnder_le_comp e.dual\n\n"}
{"name":"Filter.isBoundedUnder_le_neg","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : OrderedAddCommGroup α\nl : Filter β\nu : β → α\n⊢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l fun x => Neg.neg (u x)) (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l u)","decl":"@[to_additive (attr := simp)]\ntheorem isBoundedUnder_le_inv [OrderedCommGroup α] {l : Filter β} {u : β → α} :\n    (IsBoundedUnder (· ≤ ·) l fun x => (u x)⁻¹) ↔ IsBoundedUnder (· ≥ ·) l u :=\n  (OrderIso.inv α).isBoundedUnder_ge_comp\n\n"}
{"name":"Filter.isBoundedUnder_le_inv","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : OrderedCommGroup α\nl : Filter β\nu : β → α\n⊢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l fun x => Inv.inv (u x)) (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l u)","decl":"@[to_additive (attr := simp)]\ntheorem isBoundedUnder_le_inv [OrderedCommGroup α] {l : Filter β} {u : β → α} :\n    (IsBoundedUnder (· ≤ ·) l fun x => (u x)⁻¹) ↔ IsBoundedUnder (· ≥ ·) l u :=\n  (OrderIso.inv α).isBoundedUnder_ge_comp\n\n"}
{"name":"Filter.isBoundedUnder_ge_inv","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : OrderedCommGroup α\nl : Filter β\nu : β → α\n⊢ Iff (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l fun x => Inv.inv (u x)) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l u)","decl":"@[to_additive (attr := simp)]\ntheorem isBoundedUnder_ge_inv [OrderedCommGroup α] {l : Filter β} {u : β → α} :\n    (IsBoundedUnder (· ≥ ·) l fun x => (u x)⁻¹) ↔ IsBoundedUnder (· ≤ ·) l u :=\n  (OrderIso.inv α).isBoundedUnder_le_comp\n\n"}
{"name":"Filter.isBoundedUnder_ge_neg","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : OrderedAddCommGroup α\nl : Filter β\nu : β → α\n⊢ Iff (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l fun x => Neg.neg (u x)) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l u)","decl":"@[to_additive (attr := simp)]\ntheorem isBoundedUnder_ge_inv [OrderedCommGroup α] {l : Filter β} {u : β → α} :\n    (IsBoundedUnder (· ≥ ·) l fun x => (u x)⁻¹) ↔ IsBoundedUnder (· ≤ ·) l u :=\n  (OrderIso.inv α).isBoundedUnder_le_comp\n\n"}
{"name":"Filter.IsBoundedUnder.sup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : SemilatticeSup α\nf : Filter β\nu v : β → α\na✝¹ : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u\na✝ : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f v\n⊢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f fun a => Max.max (u a) (v a)","decl":"theorem IsBoundedUnder.sup [SemilatticeSup α] {f : Filter β} {u v : β → α} :\n    f.IsBoundedUnder (· ≤ ·) u →\n      f.IsBoundedUnder (· ≤ ·) v → f.IsBoundedUnder (· ≤ ·) fun a => u a ⊔ v a\n  | ⟨bu, (hu : ∀ᶠ x in f, u x ≤ bu)⟩, ⟨bv, (hv : ∀ᶠ x in f, v x ≤ bv)⟩ =>\n    ⟨bu ⊔ bv, show ∀ᶠ x in f, u x ⊔ v x ≤ bu ⊔ bv\n      by filter_upwards [hu, hv] with _ using sup_le_sup⟩\n\n"}
{"name":"Filter.isBoundedUnder_le_sup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : SemilatticeSup α\nf : Filter β\nu v : β → α\n⊢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f fun a => Max.max (u a) (v a)) (And (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f v))","decl":"@[simp]\ntheorem isBoundedUnder_le_sup [SemilatticeSup α] {f : Filter β} {u v : β → α} :\n    (f.IsBoundedUnder (· ≤ ·) fun a => u a ⊔ v a) ↔\n      f.IsBoundedUnder (· ≤ ·) u ∧ f.IsBoundedUnder (· ≤ ·) v :=\n  ⟨fun h =>\n    ⟨h.mono_le <| Eventually.of_forall fun _ => le_sup_left,\n      h.mono_le <| Eventually.of_forall fun _ => le_sup_right⟩,\n    fun h => h.1.sup h.2⟩\n\n"}
{"name":"Filter.IsBoundedUnder.inf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : SemilatticeInf α\nf : Filter β\nu v : β → α\na✝¹ : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u\na✝ : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f v\n⊢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f fun a => Min.min (u a) (v a)","decl":"theorem IsBoundedUnder.inf [SemilatticeInf α] {f : Filter β} {u v : β → α} :\n    f.IsBoundedUnder (· ≥ ·) u →\n      f.IsBoundedUnder (· ≥ ·) v → f.IsBoundedUnder (· ≥ ·) fun a => u a ⊓ v a :=\n  IsBoundedUnder.sup (α := αᵒᵈ)\n\n"}
{"name":"Filter.isBoundedUnder_ge_inf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : SemilatticeInf α\nf : Filter β\nu v : β → α\n⊢ Iff (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f fun a => Min.min (u a) (v a)) (And (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f v))","decl":"@[simp]\ntheorem isBoundedUnder_ge_inf [SemilatticeInf α] {f : Filter β} {u v : β → α} :\n    (f.IsBoundedUnder (· ≥ ·) fun a => u a ⊓ v a) ↔\n      f.IsBoundedUnder (· ≥ ·) u ∧ f.IsBoundedUnder (· ≥ ·) v :=\n  isBoundedUnder_le_sup (α := αᵒᵈ)\n\n"}
{"name":"Filter.isBoundedUnder_le_abs","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrderedAddCommGroup α\nf : Filter β\nu : β → α\n⊢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f fun a => abs (u a)) (And (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u))","decl":"theorem isBoundedUnder_le_abs [LinearOrderedAddCommGroup α] {f : Filter β} {u : β → α} :\n    (f.IsBoundedUnder (· ≤ ·) fun a => |u a|) ↔\n      f.IsBoundedUnder (· ≤ ·) u ∧ f.IsBoundedUnder (· ≥ ·) u :=\n  isBoundedUnder_le_sup.trans <| and_congr Iff.rfl isBoundedUnder_le_neg\n\n"}
{"name":"Filter.limsup_eq","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\nf : Filter β\nu : β → α\n⊢ Eq (Filter.limsup u f) (InfSet.sInf (setOf fun a => Filter.Eventually (fun n => LE.le (u n) a) f))","decl":"theorem limsup_eq : limsup u f = sInf { a | ∀ᶠ n in f, u n ≤ a } :=\n  rfl\n\n"}
{"name":"Filter.liminf_eq","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\nf : Filter β\nu : β → α\n⊢ Eq (Filter.liminf u f) (SupSet.sSup (setOf fun a => Filter.Eventually (fun n => LE.le a (u n)) f))","decl":"theorem liminf_eq : liminf u f = sSup { a | ∀ᶠ n in f, a ≤ u n } :=\n  rfl\n\n"}
{"name":"Filter.blimsup_eq","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\nf : Filter β\nu : β → α\np : β → Prop\n⊢ Eq (Filter.blimsup u f p) (InfSet.sInf (setOf fun a => Filter.Eventually (fun x => p x → LE.le (u x) a) f))","decl":"theorem blimsup_eq : blimsup u f p = sInf { a | ∀ᶠ x in f, p x → u x ≤ a } :=\n  rfl\n\n"}
{"name":"Filter.bliminf_eq","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\nf : Filter β\nu : β → α\np : β → Prop\n⊢ Eq (Filter.bliminf u f p) (SupSet.sSup (setOf fun a => Filter.Eventually (fun x => p x → LE.le a (u x)) f))","decl":"theorem bliminf_eq : bliminf u f p = sSup { a | ∀ᶠ x in f, p x → a ≤ u x } :=\n  rfl\n\n"}
{"name":"Filter.liminf_comp","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : ConditionallyCompleteLattice α\nu : β → α\nv : γ → β\nf : Filter γ\n⊢ Eq (Filter.liminf (Function.comp u v) f) (Filter.liminf u (Filter.map v f))","decl":"lemma liminf_comp (u : β → α) (v : γ → β) (f : Filter γ) :\n    liminf (u ∘ v) f = liminf u (map v f) := rfl\n\n"}
{"name":"Filter.limsup_comp","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : ConditionallyCompleteLattice α\nu : β → α\nv : γ → β\nf : Filter γ\n⊢ Eq (Filter.limsup (Function.comp u v) f) (Filter.limsup u (Filter.map v f))","decl":"lemma limsup_comp (u : β → α) (v : γ → β) (f : Filter γ) :\n    limsup (u ∘ v) f = limsup u (map v f) := rfl\n\n"}
{"name":"Filter.blimsup_true","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\nf : Filter β\nu : β → α\n⊢ Eq (Filter.blimsup u f fun x => True) (Filter.limsup u f)","decl":"@[simp]\ntheorem blimsup_true (f : Filter β) (u : β → α) : (blimsup u f fun _ => True) = limsup u f := by\n  simp [blimsup_eq, limsup_eq]\n\n"}
{"name":"Filter.bliminf_true","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\nf : Filter β\nu : β → α\n⊢ Eq (Filter.bliminf u f fun x => True) (Filter.liminf u f)","decl":"@[simp]\ntheorem bliminf_true (f : Filter β) (u : β → α) : (bliminf u f fun _ => True) = liminf u f := by\n  simp [bliminf_eq, liminf_eq]\n\n"}
{"name":"Filter.blimsup_eq_limsup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\nf : Filter β\nu : β → α\np : β → Prop\n⊢ Eq (Filter.blimsup u f p) (Filter.limsup u (Min.min f (Filter.principal (setOf fun x => p x))))","decl":"lemma blimsup_eq_limsup {f : Filter β} {u : β → α} {p : β → Prop} :\n    blimsup u f p = limsup u (f ⊓ 𝓟 {x | p x}) := by\n  simp only [blimsup_eq, limsup_eq, eventually_inf_principal, mem_setOf_eq]\n\n"}
{"name":"Filter.bliminf_eq_liminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\nf : Filter β\nu : β → α\np : β → Prop\n⊢ Eq (Filter.bliminf u f p) (Filter.liminf u (Min.min f (Filter.principal (setOf fun x => p x))))","decl":"lemma bliminf_eq_liminf {f : Filter β} {u : β → α} {p : β → Prop} :\n    bliminf u f p = liminf u (f ⊓ 𝓟 {x | p x}) :=\n  blimsup_eq_limsup (α := αᵒᵈ)\n\n"}
{"name":"Filter.blimsup_eq_limsup_subtype","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\nf : Filter β\nu : β → α\np : β → Prop\n⊢ Eq (Filter.blimsup u f p) (Filter.limsup (Function.comp u Subtype.val) (Filter.comap Subtype.val f))","decl":"theorem blimsup_eq_limsup_subtype {f : Filter β} {u : β → α} {p : β → Prop} :\n    blimsup u f p = limsup (u ∘ ((↑) : { x | p x } → β)) (comap (↑) f) := by\n  rw [blimsup_eq_limsup, limsup, limsup, ← map_map, map_comap_setCoe_val]\n\n"}
{"name":"Filter.bliminf_eq_liminf_subtype","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\nf : Filter β\nu : β → α\np : β → Prop\n⊢ Eq (Filter.bliminf u f p) (Filter.liminf (Function.comp u Subtype.val) (Filter.comap Subtype.val f))","decl":"theorem bliminf_eq_liminf_subtype {f : Filter β} {u : β → α} {p : β → Prop} :\n    bliminf u f p = liminf (u ∘ ((↑) : { x | p x } → β)) (comap (↑) f) :=\n  blimsup_eq_limsup_subtype (α := αᵒᵈ)\n\n"}
{"name":"Filter.limsSup_le_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\nf : Filter α\na : α\nhf : autoParam (Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) f) _auto✝\nh : Filter.Eventually (fun n => LE.le n a) f\n⊢ LE.le f.limsSup a","decl":"theorem limsSup_le_of_le {f : Filter α} {a}\n    (hf : f.IsCobounded (· ≤ ·) := by isBoundedDefault)\n    (h : ∀ᶠ n in f, n ≤ a) : limsSup f ≤ a :=\n  csInf_le hf h\n\n"}
{"name":"Filter.le_limsInf_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\nf : Filter α\na : α\nhf : autoParam (Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) f) _auto✝\nh : Filter.Eventually (fun n => LE.le a n) f\n⊢ LE.le a f.limsInf","decl":"theorem le_limsInf_of_le {f : Filter α} {a}\n    (hf : f.IsCobounded (· ≥ ·) := by isBoundedDefault)\n    (h : ∀ᶠ n in f, a ≤ n) : a ≤ limsInf f :=\n  le_csSup hf h\n\n"}
{"name":"Filter.limsup_le_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\nf : Filter β\nu : β → α\na : α\nhf : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\nh : Filter.Eventually (fun n => LE.le (u n) a) f\n⊢ LE.le (Filter.limsup u f) a","decl":"theorem limsup_le_of_le {f : Filter β} {u : β → α} {a}\n    (hf : f.IsCoboundedUnder (· ≤ ·) u := by isBoundedDefault)\n    (h : ∀ᶠ n in f, u n ≤ a) : limsup u f ≤ a :=\n  csInf_le hf h\n\n"}
{"name":"Filter.le_liminf_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\nf : Filter β\nu : β → α\na : α\nhf : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\nh : Filter.Eventually (fun n => LE.le a (u n)) f\n⊢ LE.le a (Filter.liminf u f)","decl":"theorem le_liminf_of_le {f : Filter β} {u : β → α} {a}\n    (hf : f.IsCoboundedUnder (· ≥ ·) u := by isBoundedDefault)\n    (h : ∀ᶠ n in f, a ≤ u n) : a ≤ liminf u f :=\n  le_csSup hf h\n\n"}
{"name":"Filter.le_limsSup_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\nf : Filter α\na : α\nhf : autoParam (Filter.IsBounded (fun x1 x2 => LE.le x1 x2) f) _auto✝\nh : ∀ (b : α), Filter.Eventually (fun n => LE.le n b) f → LE.le a b\n⊢ LE.le a f.limsSup","decl":"theorem le_limsSup_of_le {f : Filter α} {a}\n    (hf : f.IsBounded (· ≤ ·) := by isBoundedDefault)\n    (h : ∀ b, (∀ᶠ n in f, n ≤ b) → a ≤ b) : a ≤ limsSup f :=\n  le_csInf hf h\n\n"}
{"name":"Filter.limsInf_le_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\nf : Filter α\na : α\nhf : autoParam (Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) f) _auto✝\nh : ∀ (b : α), Filter.Eventually (fun n => LE.le b n) f → LE.le b a\n⊢ LE.le f.limsInf a","decl":"theorem limsInf_le_of_le {f : Filter α} {a}\n    (hf : f.IsBounded (· ≥ ·) := by isBoundedDefault)\n    (h : ∀ b, (∀ᶠ n in f, b ≤ n) → b ≤ a) : limsInf f ≤ a :=\n  csSup_le hf h\n\n"}
{"name":"Filter.le_limsup_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\nf : Filter β\nu : β → α\na : α\nhf : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\nh : ∀ (b : α), Filter.Eventually (fun n => LE.le (u n) b) f → LE.le a b\n⊢ LE.le a (Filter.limsup u f)","decl":"theorem le_limsup_of_le {f : Filter β} {u : β → α} {a}\n    (hf : f.IsBoundedUnder (· ≤ ·) u := by isBoundedDefault)\n    (h : ∀ b, (∀ᶠ n in f, u n ≤ b) → a ≤ b) : a ≤ limsup u f :=\n  le_csInf hf h\n\n"}
{"name":"Filter.liminf_le_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\nf : Filter β\nu : β → α\na : α\nhf : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\nh : ∀ (b : α), Filter.Eventually (fun n => LE.le b (u n)) f → LE.le b a\n⊢ LE.le (Filter.liminf u f) a","decl":"theorem liminf_le_of_le {f : Filter β} {u : β → α} {a}\n    (hf : f.IsBoundedUnder (· ≥ ·) u := by isBoundedDefault)\n    (h : ∀ b, (∀ᶠ n in f, b ≤ u n) → b ≤ a) : liminf u f ≤ a :=\n  csSup_le hf h\n\n"}
{"name":"Filter.limsInf_le_limsSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝¹ : ConditionallyCompleteLattice α\nf : Filter α\ninst✝ : f.NeBot\nh₁ : autoParam (Filter.IsBounded (fun x1 x2 => LE.le x1 x2) f) _auto✝\nh₂ : autoParam (Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) f) _auto✝\n⊢ LE.le f.limsInf f.limsSup","decl":"theorem limsInf_le_limsSup {f : Filter α} [NeBot f]\n    (h₁ : f.IsBounded (· ≤ ·) := by isBoundedDefault)\n    (h₂ : f.IsBounded (· ≥ ·) := by isBoundedDefault) :\n    limsInf f ≤ limsSup f :=\n  liminf_le_of_le h₂ fun a₀ ha₀ =>\n    le_limsup_of_le h₁ fun a₁ ha₁ =>\n      show a₀ ≤ a₁ from\n        let ⟨_, hb₀, hb₁⟩ := (ha₀.and ha₁).exists\n        le_trans hb₀ hb₁\n\n"}
{"name":"Filter.liminf_le_limsup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : ConditionallyCompleteLattice α\nf : Filter β\ninst✝ : f.NeBot\nu : β → α\nh : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\nh' : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\n⊢ LE.le (Filter.liminf u f) (Filter.limsup u f)","decl":"theorem liminf_le_limsup {f : Filter β} [NeBot f] {u : β → α}\n    (h : f.IsBoundedUnder (· ≤ ·) u := by isBoundedDefault)\n    (h' : f.IsBoundedUnder (· ≥ ·) u := by isBoundedDefault) :\n    liminf u f ≤ limsup u f :=\n  limsInf_le_limsSup h h'\n\n"}
{"name":"Filter.limsSup_le_limsSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\nf g : Filter α\nhf : autoParam (Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) f) _auto✝\nhg : autoParam (Filter.IsBounded (fun x1 x2 => LE.le x1 x2) g) _auto✝\nh : ∀ (a : α), Filter.Eventually (fun n => LE.le n a) g → Filter.Eventually (fun n => LE.le n a) f\n⊢ LE.le f.limsSup g.limsSup","decl":"theorem limsSup_le_limsSup {f g : Filter α}\n    (hf : f.IsCobounded (· ≤ ·) := by isBoundedDefault)\n    (hg : g.IsBounded (· ≤ ·) := by isBoundedDefault)\n    (h : ∀ a, (∀ᶠ n in g, n ≤ a) → ∀ᶠ n in f, n ≤ a) : limsSup f ≤ limsSup g :=\n  csInf_le_csInf hf hg h\n\n"}
{"name":"Filter.limsInf_le_limsInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\nf g : Filter α\nhf : autoParam (Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) f) _auto✝\nhg : autoParam (Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) g) _auto✝\nh : ∀ (a : α), Filter.Eventually (fun n => LE.le a n) f → Filter.Eventually (fun n => LE.le a n) g\n⊢ LE.le f.limsInf g.limsInf","decl":"theorem limsInf_le_limsInf {f g : Filter α}\n    (hf : f.IsBounded (· ≥ ·) := by isBoundedDefault)\n    (hg : g.IsCobounded (· ≥ ·) := by isBoundedDefault)\n    (h : ∀ a, (∀ᶠ n in f, a ≤ n) → ∀ᶠ n in g, a ≤ n) : limsInf f ≤ limsInf g :=\n  csSup_le_csSup hg hf h\n\n"}
{"name":"Filter.limsup_le_limsup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"β : Type u_2\nα : Type u_6\ninst✝ : ConditionallyCompleteLattice β\nf : Filter α\nu v : α → β\nh : f.EventuallyLE u v\nhu : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\nhv : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f v) _auto✝\n⊢ LE.le (Filter.limsup u f) (Filter.limsup v f)","decl":"theorem limsup_le_limsup {α : Type*} [ConditionallyCompleteLattice β] {f : Filter α} {u v : α → β}\n    (h : u ≤ᶠ[f] v)\n    (hu : f.IsCoboundedUnder (· ≤ ·) u := by isBoundedDefault)\n    (hv : f.IsBoundedUnder (· ≤ ·) v := by isBoundedDefault) :\n    limsup u f ≤ limsup v f :=\n  limsSup_le_limsSup hu hv fun _ => h.trans\n\n"}
{"name":"Filter.liminf_le_liminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"β : Type u_2\nα : Type u_6\ninst✝ : ConditionallyCompleteLattice β\nf : Filter α\nu v : α → β\nh : Filter.Eventually (fun a => LE.le (u a) (v a)) f\nhu : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\nhv : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f v) _auto✝\n⊢ LE.le (Filter.liminf u f) (Filter.liminf v f)","decl":"theorem liminf_le_liminf {α : Type*} [ConditionallyCompleteLattice β] {f : Filter α} {u v : α → β}\n    (h : ∀ᶠ a in f, u a ≤ v a)\n    (hu : f.IsBoundedUnder (· ≥ ·) u := by isBoundedDefault)\n    (hv : f.IsCoboundedUnder (· ≥ ·) v := by isBoundedDefault) :\n    liminf u f ≤ liminf v f :=\n  limsup_le_limsup (β := βᵒᵈ) h hv hu\n\n"}
{"name":"Filter.limsSup_le_limsSup_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\nf g : Filter α\nh : LE.le f g\nhf : autoParam (Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) f) _auto✝\nhg : autoParam (Filter.IsBounded (fun x1 x2 => LE.le x1 x2) g) _auto✝\n⊢ LE.le f.limsSup g.limsSup","decl":"theorem limsSup_le_limsSup_of_le {f g : Filter α} (h : f ≤ g)\n    (hf : f.IsCobounded (· ≤ ·) := by isBoundedDefault)\n    (hg : g.IsBounded (· ≤ ·) := by isBoundedDefault) :\n    limsSup f ≤ limsSup g :=\n  limsSup_le_limsSup hf hg fun _ ha => h ha\n\n"}
{"name":"Filter.limsInf_le_limsInf_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\nf g : Filter α\nh : LE.le g f\nhf : autoParam (Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) f) _auto✝\nhg : autoParam (Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) g) _auto✝\n⊢ LE.le f.limsInf g.limsInf","decl":"theorem limsInf_le_limsInf_of_le {f g : Filter α} (h : g ≤ f)\n    (hf : f.IsBounded (· ≥ ·) := by isBoundedDefault)\n    (hg : g.IsCobounded (· ≥ ·) := by isBoundedDefault) :\n    limsInf f ≤ limsInf g :=\n  limsInf_le_limsInf hf hg fun _ ha => h ha\n\n"}
{"name":"Filter.limsup_le_limsup_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝ : ConditionallyCompleteLattice β\nf g : Filter α\nh : LE.le f g\nu : α → β\nhf : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\nhg : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) g u) _auto✝\n⊢ LE.le (Filter.limsup u f) (Filter.limsup u g)","decl":"theorem limsup_le_limsup_of_le {α β} [ConditionallyCompleteLattice β] {f g : Filter α} (h : f ≤ g)\n    {u : α → β}\n    (hf : f.IsCoboundedUnder (· ≤ ·) u := by isBoundedDefault)\n    (hg : g.IsBoundedUnder (· ≤ ·) u := by isBoundedDefault) :\n    limsup u f ≤ limsup u g :=\n  limsSup_le_limsSup_of_le (map_mono h) hf hg\n\n"}
{"name":"Filter.liminf_le_liminf_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝ : ConditionallyCompleteLattice β\nf g : Filter α\nh : LE.le g f\nu : α → β\nhf : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\nhg : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) g u) _auto✝\n⊢ LE.le (Filter.liminf u f) (Filter.liminf u g)","decl":"theorem liminf_le_liminf_of_le {α β} [ConditionallyCompleteLattice β] {f g : Filter α} (h : g ≤ f)\n    {u : α → β}\n    (hf : f.IsBoundedUnder (· ≥ ·) u := by isBoundedDefault)\n    (hg : g.IsCoboundedUnder (· ≥ ·) u := by isBoundedDefault) :\n    liminf u f ≤ liminf u g :=\n  limsInf_le_limsInf_of_le (map_mono h) hf hg\n\n"}
{"name":"Filter.limsSup_principal_eq_csSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\nh : BddAbove s\nhs : s.Nonempty\n⊢ Eq (Filter.principal s).limsSup (SupSet.sSup s)","decl":"lemma limsSup_principal_eq_csSup (h : BddAbove s) (hs : s.Nonempty) : limsSup (𝓟 s) = sSup s := by\n  simp only [limsSup, eventually_principal]; exact csInf_upperBounds_eq_csSup h hs\n\n"}
{"name":"Filter.limsInf_principal_eq_csSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\ns : Set α\nh : BddBelow s\nhs : s.Nonempty\n⊢ Eq (Filter.principal s).limsInf (InfSet.sInf s)","decl":"lemma limsInf_principal_eq_csSup (h : BddBelow s) (hs : s.Nonempty) : limsInf (𝓟 s) = sInf s :=\n  limsSup_principal_eq_csSup (α := αᵒᵈ) h hs\n\n"}
{"name":"Filter.limsup_top_eq_ciSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : ConditionallyCompleteLattice α\nu : β → α\ninst✝ : Nonempty β\nhu : BddAbove (Set.range u)\n⊢ Eq (Filter.limsup u Top.top) (iSup fun i => u i)","decl":"lemma limsup_top_eq_ciSup [Nonempty β] (hu : BddAbove (range u)) : limsup u ⊤ = ⨆ i, u i := by\n  rw [limsup, map_top, limsSup_principal_eq_csSup hu (range_nonempty _), sSup_range]\n\n"}
{"name":"Filter.liminf_top_eq_ciInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : ConditionallyCompleteLattice α\nu : β → α\ninst✝ : Nonempty β\nhu : BddBelow (Set.range u)\n⊢ Eq (Filter.liminf u Top.top) (iInf fun i => u i)","decl":"lemma liminf_top_eq_ciInf [Nonempty β] (hu : BddBelow (range u)) : liminf u ⊤ = ⨅ i, u i := by\n  rw [liminf, map_top, limsInf_principal_eq_csSup hu (range_nonempty _), sInf_range]\n\n"}
{"name":"Filter.limsup_congr","module":"Mathlib.Order.LiminfLimsup","initialProofState":"β : Type u_2\nα : Type u_6\ninst✝ : ConditionallyCompleteLattice β\nf : Filter α\nu v : α → β\nh : Filter.Eventually (fun a => Eq (u a) (v a)) f\n⊢ Eq (Filter.limsup u f) (Filter.limsup v f)","decl":"theorem limsup_congr {α : Type*} [ConditionallyCompleteLattice β] {f : Filter α} {u v : α → β}\n    (h : ∀ᶠ a in f, u a = v a) : limsup u f = limsup v f := by\n  rw [limsup_eq]\n  congr with b\n  exact eventually_congr (h.mono fun x hx => by simp [hx])\n\n"}
{"name":"Filter.blimsup_congr","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\nf : Filter β\nu v : β → α\np : β → Prop\nh : Filter.Eventually (fun a => p a → Eq (u a) (v a)) f\n⊢ Eq (Filter.blimsup u f p) (Filter.blimsup v f p)","decl":"theorem blimsup_congr {f : Filter β} {u v : β → α} {p : β → Prop} (h : ∀ᶠ a in f, p a → u a = v a) :\n    blimsup u f p = blimsup v f p := by\n  simpa only [blimsup_eq_limsup] using limsup_congr <| eventually_inf_principal.2 h\n\n"}
{"name":"Filter.bliminf_congr","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLattice α\nf : Filter β\nu v : β → α\np : β → Prop\nh : Filter.Eventually (fun a => p a → Eq (u a) (v a)) f\n⊢ Eq (Filter.bliminf u f p) (Filter.bliminf v f p)","decl":"theorem bliminf_congr {f : Filter β} {u v : β → α} {p : β → Prop} (h : ∀ᶠ a in f, p a → u a = v a) :\n    bliminf u f p = bliminf v f p :=\n  blimsup_congr (α := αᵒᵈ) h\n\n"}
{"name":"Filter.liminf_congr","module":"Mathlib.Order.LiminfLimsup","initialProofState":"β : Type u_2\nα : Type u_6\ninst✝ : ConditionallyCompleteLattice β\nf : Filter α\nu v : α → β\nh : Filter.Eventually (fun a => Eq (u a) (v a)) f\n⊢ Eq (Filter.liminf u f) (Filter.liminf v f)","decl":"theorem liminf_congr {α : Type*} [ConditionallyCompleteLattice β] {f : Filter α} {u v : α → β}\n    (h : ∀ᶠ a in f, u a = v a) : liminf u f = liminf v f :=\n  limsup_congr (β := βᵒᵈ) h\n\n"}
{"name":"Filter.limsup_const","module":"Mathlib.Order.LiminfLimsup","initialProofState":"β : Type u_2\nα : Type u_6\ninst✝¹ : ConditionallyCompleteLattice β\nf : Filter α\ninst✝ : f.NeBot\nb : β\n⊢ Eq (Filter.limsup (fun x => b) f) b","decl":"@[simp]\ntheorem limsup_const {α : Type*} [ConditionallyCompleteLattice β] {f : Filter α} [NeBot f]\n    (b : β) : limsup (fun _ => b) f = b := by\n  simpa only [limsup_eq, eventually_const] using csInf_Ici\n\n"}
{"name":"Filter.liminf_const","module":"Mathlib.Order.LiminfLimsup","initialProofState":"β : Type u_2\nα : Type u_6\ninst✝¹ : ConditionallyCompleteLattice β\nf : Filter α\ninst✝ : f.NeBot\nb : β\n⊢ Eq (Filter.liminf (fun x => b) f) b","decl":"@[simp]\ntheorem liminf_const {α : Type*} [ConditionallyCompleteLattice β] {f : Filter α} [NeBot f]\n    (b : β) : liminf (fun _ => b) f = b :=\n  limsup_const (β := βᵒᵈ) b\n\n"}
{"name":"Filter.HasBasis.liminf_eq_sSup_iUnion_iInter","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\nι : Type u_6\nι' : Type u_7\nf : ι → α\nv : Filter ι\np : ι' → Prop\ns : ι' → Set ι\nhv : v.HasBasis p s\n⊢ Eq (Filter.liminf f v) (SupSet.sSup (Set.iUnion fun j => Set.iInter fun i => Set.Iic (f ↑i)))","decl":"theorem HasBasis.liminf_eq_sSup_iUnion_iInter {ι ι' : Type*} {f : ι → α} {v : Filter ι}\n    {p : ι' → Prop} {s : ι' → Set ι} (hv : v.HasBasis p s) :\n    liminf f v = sSup (⋃ (j : Subtype p), ⋂ (i : s j), Iic (f i)) := by\n  simp_rw [liminf_eq, hv.eventually_iff]\n  congr\n  ext x\n  simp only [mem_setOf_eq, iInter_coe_set, mem_iUnion, mem_iInter, mem_Iic, Subtype.exists,\n    exists_prop]\n\n"}
{"name":"Filter.HasBasis.liminf_eq_sSup_univ_of_empty","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\nι' : Type u_5\ninst✝ : ConditionallyCompleteLattice α\nf : ι → α\nv : Filter ι\np : ι' → Prop\ns : ι' → Set ι\nhv : v.HasBasis p s\ni : ι'\nhi : p i\nh'i : Eq (s i) EmptyCollection.emptyCollection\n⊢ Eq (Filter.liminf f v) (SupSet.sSup Set.univ)","decl":"theorem HasBasis.liminf_eq_sSup_univ_of_empty {f : ι → α} {v : Filter ι}\n    {p : ι' → Prop} {s : ι' → Set ι} (hv : v.HasBasis p s) (i : ι') (hi : p i) (h'i : s i = ∅) :\n    liminf f v = sSup univ := by\n  simp [hv.eq_bot_iff.2 ⟨i, hi, h'i⟩, liminf_eq]\n\n"}
{"name":"Filter.HasBasis.limsup_eq_sInf_iUnion_iInter","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\nι : Type u_6\nι' : Type u_7\nf : ι → α\nv : Filter ι\np : ι' → Prop\ns : ι' → Set ι\nhv : v.HasBasis p s\n⊢ Eq (Filter.limsup f v) (InfSet.sInf (Set.iUnion fun j => Set.iInter fun i => Set.Ici (f ↑i)))","decl":"theorem HasBasis.limsup_eq_sInf_iUnion_iInter {ι ι' : Type*} {f : ι → α} {v : Filter ι}\n    {p : ι' → Prop} {s : ι' → Set ι} (hv : v.HasBasis p s) :\n    limsup f v = sInf (⋃ (j : Subtype p), ⋂ (i : s j), Ici (f i)) :=\n  HasBasis.liminf_eq_sSup_iUnion_iInter (α := αᵒᵈ) hv\n\n"}
{"name":"Filter.HasBasis.limsup_eq_sInf_univ_of_empty","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\nι' : Type u_5\ninst✝ : ConditionallyCompleteLattice α\nf : ι → α\nv : Filter ι\np : ι' → Prop\ns : ι' → Set ι\nhv : v.HasBasis p s\ni : ι'\nhi : p i\nh'i : Eq (s i) EmptyCollection.emptyCollection\n⊢ Eq (Filter.limsup f v) (InfSet.sInf Set.univ)","decl":"theorem HasBasis.limsup_eq_sInf_univ_of_empty {f : ι → α} {v : Filter ι}\n    {p : ι' → Prop} {s : ι' → Set ι} (hv : v.HasBasis p s) (i : ι') (hi : p i) (h'i : s i = ∅) :\n    limsup f v = sInf univ :=\n  HasBasis.liminf_eq_sSup_univ_of_empty (α := αᵒᵈ) hv i hi h'i\n\n"}
{"name":"Filter.liminf_nat_add","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\nf : Nat → α\nk : Nat\n⊢ Eq (Filter.liminf (fun i => f (HAdd.hAdd i k)) Filter.atTop) (Filter.liminf f Filter.atTop)","decl":"@[simp]\ntheorem liminf_nat_add (f : ℕ → α) (k : ℕ) :\n    liminf (fun i => f (i + k)) atTop = liminf f atTop := by\n  change liminf (f ∘ (· + k)) atTop = liminf f atTop\n  rw [liminf, liminf, ← map_map, map_add_atTop_eq_nat]\n\n"}
{"name":"Filter.limsup_nat_add","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLattice α\nf : Nat → α\nk : Nat\n⊢ Eq (Filter.limsup (fun i => f (HAdd.hAdd i k)) Filter.atTop) (Filter.limsup f Filter.atTop)","decl":"@[simp]\ntheorem limsup_nat_add (f : ℕ → α) (k : ℕ) : limsup (fun i => f (i + k)) atTop = limsup f atTop :=\n  @liminf_nat_add αᵒᵈ _ f k\n\n"}
{"name":"Filter.limsSup_bot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\n⊢ Eq Bot.bot.limsSup Bot.bot","decl":"@[simp]\ntheorem limsSup_bot : limsSup (⊥ : Filter α) = ⊥ :=\n  bot_unique <| sInf_le <| by simp\n\n"}
{"name":"Filter.limsup_bot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : β → α\n⊢ Eq (Filter.limsup f Bot.bot) Bot.bot","decl":"@[simp] theorem limsup_bot (f : β → α) : limsup f ⊥ = ⊥ := by simp [limsup]\n\n"}
{"name":"Filter.limsInf_bot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\n⊢ Eq Bot.bot.limsInf Top.top","decl":"@[simp]\ntheorem limsInf_bot : limsInf (⊥ : Filter α) = ⊤ :=\n  top_unique <| le_sSup <| by simp\n\n"}
{"name":"Filter.liminf_bot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : β → α\n⊢ Eq (Filter.liminf f Bot.bot) Top.top","decl":"@[simp] theorem liminf_bot (f : β → α) : liminf f ⊥ = ⊤ := by simp [liminf]\n\n"}
{"name":"Filter.limsSup_top","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\n⊢ Eq Top.top.limsSup Top.top","decl":"@[simp]\ntheorem limsSup_top : limsSup (⊤ : Filter α) = ⊤ :=\n  top_unique <| le_sInf <| by simpa [eq_univ_iff_forall] using fun b hb => top_unique <| hb _\n\n"}
{"name":"Filter.limsInf_top","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\n⊢ Eq Top.top.limsInf Bot.bot","decl":"@[simp]\ntheorem limsInf_top : limsInf (⊤ : Filter α) = ⊥ :=\n  bot_unique <| sSup_le <| by simpa [eq_univ_iff_forall] using fun b hb => bot_unique <| hb _\n\n"}
{"name":"Filter.blimsup_false","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\nu : β → α\n⊢ Eq (Filter.blimsup u f fun x => False) Bot.bot","decl":"@[simp]\ntheorem blimsup_false {f : Filter β} {u : β → α} : (blimsup u f fun _ => False) = ⊥ := by\n  simp [blimsup_eq]\n\n"}
{"name":"Filter.bliminf_false","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\nu : β → α\n⊢ Eq (Filter.bliminf u f fun x => False) Top.top","decl":"@[simp]\ntheorem bliminf_false {f : Filter β} {u : β → α} : (bliminf u f fun _ => False) = ⊤ := by\n  simp [bliminf_eq]\n\n"}
{"name":"Filter.limsup_const_bot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\n⊢ Eq (Filter.limsup (fun x => Bot.bot) f) Bot.bot","decl":"/-- Same as limsup_const applied to `⊥` but without the `NeBot f` assumption -/\n@[simp]\ntheorem limsup_const_bot {f : Filter β} : limsup (fun _ : β => (⊥ : α)) f = (⊥ : α) := by\n  rw [limsup_eq, eq_bot_iff]\n  exact sInf_le (Eventually.of_forall fun _ => le_rfl)\n\n"}
{"name":"Filter.liminf_const_top","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\n⊢ Eq (Filter.liminf (fun x => Top.top) f) Top.top","decl":"/-- Same as limsup_const applied to `⊤` but without the `NeBot f` assumption -/\n@[simp]\ntheorem liminf_const_top {f : Filter β} : liminf (fun _ : β => (⊤ : α)) f = (⊤ : α) :=\n  limsup_const_bot (α := αᵒᵈ)\n\n"}
{"name":"Filter.HasBasis.limsSup_eq_iInf_sSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nι : Sort u_6\np : ι → Prop\ns : ι → Set α\nf : Filter α\nh : f.HasBasis p s\n⊢ Eq f.limsSup (iInf fun i => iInf fun x => SupSet.sSup (s i))","decl":"theorem HasBasis.limsSup_eq_iInf_sSup {ι} {p : ι → Prop} {s} {f : Filter α} (h : f.HasBasis p s) :\n    limsSup f = ⨅ (i) (_ : p i), sSup (s i) :=\n  le_antisymm (le_iInf₂ fun i hi => sInf_le <| h.eventually_iff.2 ⟨i, hi, fun _ => le_sSup⟩)\n    (le_sInf fun _ ha =>\n      let ⟨_, hi, ha⟩ := h.eventually_iff.1 ha\n      iInf₂_le_of_le _ hi <| sSup_le ha)\n\n"}
{"name":"Filter.HasBasis.limsInf_eq_iSup_sInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝ : CompleteLattice α\np : ι → Prop\ns : ι → Set α\nf : Filter α\nh : f.HasBasis p s\n⊢ Eq f.limsInf (iSup fun i => iSup fun x => InfSet.sInf (s i))","decl":"theorem HasBasis.limsInf_eq_iSup_sInf {p : ι → Prop} {s : ι → Set α} {f : Filter α}\n    (h : f.HasBasis p s) : limsInf f = ⨆ (i) (_ : p i), sInf (s i) :=\n  HasBasis.limsSup_eq_iInf_sSup (α := αᵒᵈ) h\n\n"}
{"name":"Filter.limsSup_eq_iInf_sSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nf : Filter α\n⊢ Eq f.limsSup (iInf fun s => iInf fun h => SupSet.sSup s)","decl":"theorem limsSup_eq_iInf_sSup {f : Filter α} : limsSup f = ⨅ s ∈ f, sSup s :=\n  f.basis_sets.limsSup_eq_iInf_sSup\n\n"}
{"name":"Filter.limsInf_eq_iSup_sInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nf : Filter α\n⊢ Eq f.limsInf (iSup fun s => iSup fun h => InfSet.sInf s)","decl":"theorem limsInf_eq_iSup_sInf {f : Filter α} : limsInf f = ⨆ s ∈ f, sInf s :=\n  limsSup_eq_iInf_sSup (α := αᵒᵈ)\n\n"}
{"name":"Filter.limsup_le_iSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\nu : β → α\n⊢ LE.le (Filter.limsup u f) (iSup fun n => u n)","decl":"theorem limsup_le_iSup {f : Filter β} {u : β → α} : limsup u f ≤ ⨆ n, u n :=\n  limsup_le_of_le (by isBoundedDefault) (Eventually.of_forall (le_iSup u))\n\n"}
{"name":"Filter.iInf_le_liminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\nu : β → α\n⊢ LE.le (iInf fun n => u n) (Filter.liminf u f)","decl":"theorem iInf_le_liminf {f : Filter β} {u : β → α} : ⨅ n, u n ≤ liminf u f :=\n  le_liminf_of_le (by isBoundedDefault) (Eventually.of_forall (iInf_le u))\n\n"}
{"name":"Filter.limsup_eq_iInf_iSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\nu : β → α\n⊢ Eq (Filter.limsup u f) (iInf fun s => iInf fun h => iSup fun a => iSup fun h => u a)","decl":"/-- In a complete lattice, the limsup of a function is the infimum over sets `s` in the filter\nof the supremum of the function over `s` -/\ntheorem limsup_eq_iInf_iSup {f : Filter β} {u : β → α} : limsup u f = ⨅ s ∈ f, ⨆ a ∈ s, u a :=\n  (f.basis_sets.map u).limsSup_eq_iInf_sSup.trans <| by simp only [sSup_image, id]\n\n"}
{"name":"Filter.limsup_eq_iInf_iSup_of_nat","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nu : Nat → α\n⊢ Eq (Filter.limsup u Filter.atTop) (iInf fun n => iSup fun i => iSup fun h => u i)","decl":"theorem limsup_eq_iInf_iSup_of_nat {u : ℕ → α} : limsup u atTop = ⨅ n : ℕ, ⨆ i ≥ n, u i :=\n  (atTop_basis.map u).limsSup_eq_iInf_sSup.trans <| by simp only [sSup_image, iInf_const]; rfl\n\n"}
{"name":"Filter.limsup_eq_iInf_iSup_of_nat'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nu : Nat → α\n⊢ Eq (Filter.limsup u Filter.atTop) (iInf fun n => iSup fun i => u (HAdd.hAdd i n))","decl":"theorem limsup_eq_iInf_iSup_of_nat' {u : ℕ → α} : limsup u atTop = ⨅ n : ℕ, ⨆ i : ℕ, u (i + n) := by\n  simp only [limsup_eq_iInf_iSup_of_nat, iSup_ge_eq_iSup_nat_add]\n\n"}
{"name":"Filter.HasBasis.limsup_eq_iInf_iSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\ninst✝ : CompleteLattice α\np : ι → Prop\ns : ι → Set β\nf : Filter β\nu : β → α\nh : f.HasBasis p s\n⊢ Eq (Filter.limsup u f) (iInf fun i => iInf fun x => iSup fun a => iSup fun h => u a)","decl":"theorem HasBasis.limsup_eq_iInf_iSup {p : ι → Prop} {s : ι → Set β} {f : Filter β} {u : β → α}\n    (h : f.HasBasis p s) : limsup u f = ⨅ (i) (_ : p i), ⨆ a ∈ s i, u a :=\n  (h.map u).limsSup_eq_iInf_sSup.trans <| by simp only [sSup_image, id]\n\n"}
{"name":"Filter.limsSup_principal_eq_sSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\n⊢ Eq (Filter.principal s).limsSup (SupSet.sSup s)","decl":"lemma limsSup_principal_eq_sSup (s : Set α) : limsSup (𝓟 s) = sSup s := by\n  simpa only [limsSup, eventually_principal] using sInf_upperBounds_eq_csSup s\n\n"}
{"name":"Filter.limsInf_principal_eq_sInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\n⊢ Eq (Filter.principal s).limsInf (InfSet.sInf s)","decl":"lemma limsInf_principal_eq_sInf (s : Set α) : limsInf (𝓟 s) = sInf s := by\n  simpa only [limsInf, eventually_principal] using sSup_lowerBounds_eq_sInf s\n\n"}
{"name":"Filter.limsup_top_eq_iSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nu : β → α\n⊢ Eq (Filter.limsup u Top.top) (iSup fun i => u i)","decl":"@[simp] lemma limsup_top_eq_iSup (u : β → α) : limsup u ⊤ = ⨆ i, u i := by\n  rw [limsup, map_top, limsSup_principal_eq_sSup, sSup_range]\n\n"}
{"name":"Filter.liminf_top_eq_iInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nu : β → α\n⊢ Eq (Filter.liminf u Top.top) (iInf fun i => u i)","decl":"@[simp] lemma liminf_top_eq_iInf (u : β → α) : liminf u ⊤ = ⨅ i, u i := by\n  rw [liminf, map_top, limsInf_principal_eq_sInf, sInf_range]\n\n"}
{"name":"Filter.limsSup_principal","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\n⊢ Eq (Filter.principal s).limsSup (SupSet.sSup s)","decl":"@[deprecated (since := \"2024-08-27\")] alias limsSup_principal := limsSup_principal_eq_sSup\n"}
{"name":"Filter.limsInf_principal","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\n⊢ Eq (Filter.principal s).limsInf (InfSet.sInf s)","decl":"@[deprecated (since := \"2024-08-27\")] alias limsInf_principal := limsInf_principal_eq_sInf\n"}
{"name":"Filter.limsup_top","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nu : β → α\n⊢ Eq (Filter.limsup u Top.top) (iSup fun i => u i)","decl":"@[deprecated (since := \"2024-08-27\")] alias limsup_top := limsup_top_eq_iSup\n"}
{"name":"Filter.liminf_top","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nu : β → α\n⊢ Eq (Filter.liminf u Top.top) (iInf fun i => u i)","decl":"@[deprecated (since := \"2024-08-27\")] alias liminf_top := liminf_top_eq_iInf\n\n"}
{"name":"Filter.blimsup_congr'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np q : β → Prop\nu : β → α\nh : Filter.Eventually (fun x => Ne (u x) Bot.bot → Iff (p x) (q x)) f\n⊢ Eq (Filter.blimsup u f p) (Filter.blimsup u f q)","decl":"theorem blimsup_congr' {f : Filter β} {p q : β → Prop} {u : β → α}\n    (h : ∀ᶠ x in f, u x ≠ ⊥ → (p x ↔ q x)) : blimsup u f p = blimsup u f q := by\n  simp only [blimsup_eq]\n  congr with a\n  refine eventually_congr (h.mono fun b hb => ?_)\n  rcases eq_or_ne (u b) ⊥ with hu | hu; · simp [hu]\n  rw [hb hu]\n\n"}
{"name":"Filter.bliminf_congr'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np q : β → Prop\nu : β → α\nh : Filter.Eventually (fun x => Ne (u x) Top.top → Iff (p x) (q x)) f\n⊢ Eq (Filter.bliminf u f p) (Filter.bliminf u f q)","decl":"theorem bliminf_congr' {f : Filter β} {p q : β → Prop} {u : β → α}\n    (h : ∀ᶠ x in f, u x ≠ ⊤ → (p x ↔ q x)) : bliminf u f p = bliminf u f q :=\n  blimsup_congr' (α := αᵒᵈ) h\n\n"}
{"name":"Filter.HasBasis.blimsup_eq_iInf_iSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\ninst✝ : CompleteLattice α\np : ι → Prop\ns : ι → Set β\nf : Filter β\nu : β → α\nhf : f.HasBasis p s\nq : β → Prop\n⊢ Eq (Filter.blimsup u f q) (iInf fun i => iInf fun x => iSup fun a => iSup fun h => iSup fun x => u a)","decl":"lemma HasBasis.blimsup_eq_iInf_iSup {p : ι → Prop} {s : ι → Set β} {f : Filter β} {u : β → α}\n    (hf : f.HasBasis p s) {q : β → Prop} :\n    blimsup u f q = ⨅ (i) (_ : p i), ⨆ a ∈ s i, ⨆ (_ : q a), u a := by\n  simp only [blimsup_eq_limsup, (hf.inf_principal _).limsup_eq_iInf_iSup, mem_inter_iff, iSup_and,\n    mem_setOf_eq]\n\n"}
{"name":"Filter.blimsup_eq_iInf_biSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np : β → Prop\nu : β → α\n⊢ Eq (Filter.blimsup u f p) (iInf fun s => iInf fun h => iSup fun b => iSup fun x => u b)","decl":"theorem blimsup_eq_iInf_biSup {f : Filter β} {p : β → Prop} {u : β → α} :\n    blimsup u f p = ⨅ s ∈ f, ⨆ (b) (_ : p b ∧ b ∈ s), u b := by\n  simp only [f.basis_sets.blimsup_eq_iInf_iSup, iSup_and', id, and_comm]\n\n"}
{"name":"Filter.blimsup_eq_iInf_biSup_of_nat","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\np : Nat → Prop\nu : Nat → α\n⊢ Eq (Filter.blimsup u Filter.atTop p) (iInf fun i => iSup fun j => iSup fun x => u j)","decl":"theorem blimsup_eq_iInf_biSup_of_nat {p : ℕ → Prop} {u : ℕ → α} :\n    blimsup u atTop p = ⨅ i, ⨆ (j) (_ : p j ∧ i ≤ j), u j := by\n  simp only [atTop_basis.blimsup_eq_iInf_iSup, @and_comm (p _), iSup_and, mem_Ici, iInf_true]\n\n"}
{"name":"Filter.liminf_eq_iSup_iInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\nu : β → α\n⊢ Eq (Filter.liminf u f) (iSup fun s => iSup fun h => iInf fun a => iInf fun h => u a)","decl":"/-- In a complete lattice, the liminf of a function is the infimum over sets `s` in the filter\nof the supremum of the function over `s` -/\ntheorem liminf_eq_iSup_iInf {f : Filter β} {u : β → α} : liminf u f = ⨆ s ∈ f, ⨅ a ∈ s, u a :=\n  limsup_eq_iInf_iSup (α := αᵒᵈ)\n\n"}
{"name":"Filter.liminf_eq_iSup_iInf_of_nat","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nu : Nat → α\n⊢ Eq (Filter.liminf u Filter.atTop) (iSup fun n => iInf fun i => iInf fun h => u i)","decl":"theorem liminf_eq_iSup_iInf_of_nat {u : ℕ → α} : liminf u atTop = ⨆ n : ℕ, ⨅ i ≥ n, u i :=\n  @limsup_eq_iInf_iSup_of_nat αᵒᵈ _ u\n\n"}
{"name":"Filter.liminf_eq_iSup_iInf_of_nat'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nu : Nat → α\n⊢ Eq (Filter.liminf u Filter.atTop) (iSup fun n => iInf fun i => u (HAdd.hAdd i n))","decl":"theorem liminf_eq_iSup_iInf_of_nat' {u : ℕ → α} : liminf u atTop = ⨆ n : ℕ, ⨅ i : ℕ, u (i + n) :=\n  @limsup_eq_iInf_iSup_of_nat' αᵒᵈ _ _\n\n"}
{"name":"Filter.HasBasis.liminf_eq_iSup_iInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\ninst✝ : CompleteLattice α\np : ι → Prop\ns : ι → Set β\nf : Filter β\nu : β → α\nh : f.HasBasis p s\n⊢ Eq (Filter.liminf u f) (iSup fun i => iSup fun x => iInf fun a => iInf fun h => u a)","decl":"theorem HasBasis.liminf_eq_iSup_iInf {p : ι → Prop} {s : ι → Set β} {f : Filter β} {u : β → α}\n    (h : f.HasBasis p s) : liminf u f = ⨆ (i) (_ : p i), ⨅ a ∈ s i, u a :=\n  HasBasis.limsup_eq_iInf_iSup (α := αᵒᵈ) h\n\n"}
{"name":"Filter.bliminf_eq_iSup_biInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np : β → Prop\nu : β → α\n⊢ Eq (Filter.bliminf u f p) (iSup fun s => iSup fun h => iInf fun b => iInf fun x => u b)","decl":"theorem bliminf_eq_iSup_biInf {f : Filter β} {p : β → Prop} {u : β → α} :\n    bliminf u f p = ⨆ s ∈ f, ⨅ (b) (_ : p b ∧ b ∈ s), u b :=\n  @blimsup_eq_iInf_biSup αᵒᵈ β _ f p u\n\n"}
{"name":"Filter.bliminf_eq_iSup_biInf_of_nat","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\np : Nat → Prop\nu : Nat → α\n⊢ Eq (Filter.bliminf u Filter.atTop p) (iSup fun i => iInf fun j => iInf fun x => u j)","decl":"theorem bliminf_eq_iSup_biInf_of_nat {p : ℕ → Prop} {u : ℕ → α} :\n    bliminf u atTop p = ⨆ i, ⨅ (j) (_ : p j ∧ i ≤ j), u j :=\n  @blimsup_eq_iInf_biSup_of_nat αᵒᵈ _ p u\n\n"}
{"name":"Filter.limsup_eq_sInf_sSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"ι : Type u_6\nR : Type u_7\nF : Filter ι\ninst✝ : CompleteLattice R\na : ι → R\n⊢ Eq (Filter.limsup a F) (InfSet.sInf (Set.image (fun I => SupSet.sSup (Set.image a I)) F.sets))","decl":"theorem limsup_eq_sInf_sSup {ι R : Type*} (F : Filter ι) [CompleteLattice R] (a : ι → R) :\n    limsup a F = sInf ((fun I => sSup (a '' I)) '' F.sets) := by\n  apply le_antisymm\n  · rw [limsup_eq]\n    refine sInf_le_sInf fun x hx => ?_\n    rcases (mem_image _ F.sets x).mp hx with ⟨I, ⟨I_mem_F, hI⟩⟩\n    filter_upwards [I_mem_F] with i hi\n    exact hI ▸ le_sSup (mem_image_of_mem _ hi)\n  · refine le_sInf fun b hb => sInf_le_of_le (mem_image_of_mem _ hb) <| sSup_le ?_\n    rintro _ ⟨_, h, rfl⟩\n    exact h\n\n"}
{"name":"Filter.liminf_eq_sSup_sInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"ι : Type u_6\nR : Type u_7\nF : Filter ι\ninst✝ : CompleteLattice R\na : ι → R\n⊢ Eq (Filter.liminf a F) (SupSet.sSup (Set.image (fun I => InfSet.sInf (Set.image a I)) F.sets))","decl":"theorem liminf_eq_sSup_sInf {ι R : Type*} (F : Filter ι) [CompleteLattice R] (a : ι → R) :\n    liminf a F = sSup ((fun I => sInf (a '' I)) '' F.sets) :=\n  @Filter.limsup_eq_sInf_sSup ι (OrderDual R) _ _ a\n\n"}
{"name":"Filter.liminf_le_of_frequently_le'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝ : CompleteLattice β\nf : Filter α\nu : α → β\nx : β\nh : Filter.Frequently (fun a => LE.le (u a) x) f\n⊢ LE.le (Filter.liminf u f) x","decl":"theorem liminf_le_of_frequently_le' {α β} [CompleteLattice β] {f : Filter α} {u : α → β} {x : β}\n    (h : ∃ᶠ a in f, u a ≤ x) : liminf u f ≤ x := by\n  rw [liminf_eq]\n  refine sSup_le fun b hb => ?_\n  have hbx : ∃ᶠ _ in f, b ≤ x := by\n    revert h\n    rw [← not_imp_not, not_frequently, not_frequently]\n    exact fun h => hb.mp (h.mono fun a hbx hba hax => hbx (hba.trans hax))\n  exact hbx.exists.choose_spec\n\n"}
{"name":"Filter.le_limsup_of_frequently_le'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝ : CompleteLattice β\nf : Filter α\nu : α → β\nx : β\nh : Filter.Frequently (fun a => LE.le x (u a)) f\n⊢ LE.le x (Filter.limsup u f)","decl":"theorem le_limsup_of_frequently_le' {α β} [CompleteLattice β] {f : Filter α} {u : α → β} {x : β}\n    (h : ∃ᶠ a in f, x ≤ u a) : x ≤ limsup u f :=\n  liminf_le_of_frequently_le' (β := βᵒᵈ) h\n\n"}
{"name":"CompleteLatticeHom.apply_limsup_iterate","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nf : CompleteLatticeHom α α\na : α\n⊢ Eq (f (Filter.limsup (fun n => Nat.iterate (⇑f) n a) Filter.atTop)) (Filter.limsup (fun n => Nat.iterate (⇑f) n a) Filter.atTop)","decl":"/-- If `f : α → α` is a morphism of complete lattices, then the limsup of its iterates of any\n`a : α` is a fixed point. -/\n@[simp]\ntheorem _root_.CompleteLatticeHom.apply_limsup_iterate (f : CompleteLatticeHom α α) (a : α) :\n    f (limsup (fun n => f^[n] a) atTop) = limsup (fun n => f^[n] a) atTop := by\n  rw [limsup_eq_iInf_iSup_of_nat', map_iInf]\n  simp_rw [_root_.map_iSup, ← Function.comp_apply (f := f), ← Function.iterate_succ' f,\n    ← Nat.add_succ]\n  conv_rhs => rw [iInf_split _ (0 < ·)]\n  simp only [not_lt, Nat.le_zero, iInf_iInf_eq_left, add_zero, iInf_nat_gt_zero_eq, left_eq_inf]\n  refine (iInf_le (fun i => ⨆ j, f^[j + (i + 1)] a) 0).trans ?_\n  simp only [zero_add, Function.comp_apply, iSup_le_iff]\n  exact fun i => le_iSup (fun i => f^[i] a) (i + 1)\n\n"}
{"name":"CompleteLatticeHom.apply_liminf_iterate","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nf : CompleteLatticeHom α α\na : α\n⊢ Eq (f (Filter.liminf (fun n => Nat.iterate (⇑f) n a) Filter.atTop)) (Filter.liminf (fun n => Nat.iterate (⇑f) n a) Filter.atTop)","decl":"/-- If `f : α → α` is a morphism of complete lattices, then the liminf of its iterates of any\n`a : α` is a fixed point. -/\ntheorem _root_.CompleteLatticeHom.apply_liminf_iterate (f : CompleteLatticeHom α α) (a : α) :\n    f (liminf (fun n => f^[n] a) atTop) = liminf (fun n => f^[n] a) atTop :=\n  (CompleteLatticeHom.dual f).apply_limsup_iterate _\n\n"}
{"name":"Filter.blimsup_mono","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np q : β → Prop\nu : β → α\nh : ∀ (x : β), p x → q x\n⊢ LE.le (Filter.blimsup u f p) (Filter.blimsup u f q)","decl":"theorem blimsup_mono (h : ∀ x, p x → q x) : blimsup u f p ≤ blimsup u f q :=\n  sInf_le_sInf fun a ha => ha.mono <| by tauto\n\n"}
{"name":"Filter.bliminf_antitone","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np q : β → Prop\nu : β → α\nh : ∀ (x : β), p x → q x\n⊢ LE.le (Filter.bliminf u f q) (Filter.bliminf u f p)","decl":"theorem bliminf_antitone (h : ∀ x, p x → q x) : bliminf u f q ≤ bliminf u f p :=\n  sSup_le_sSup fun a ha => ha.mono <| by tauto\n\n"}
{"name":"Filter.mono_blimsup'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np : β → Prop\nu v : β → α\nh : Filter.Eventually (fun x => p x → LE.le (u x) (v x)) f\n⊢ LE.le (Filter.blimsup u f p) (Filter.blimsup v f p)","decl":"theorem mono_blimsup' (h : ∀ᶠ x in f, p x → u x ≤ v x) : blimsup u f p ≤ blimsup v f p :=\n  sInf_le_sInf fun _ ha => (ha.and h).mono fun _ hx hx' => (hx.2 hx').trans (hx.1 hx')\n\n"}
{"name":"Filter.mono_blimsup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np : β → Prop\nu v : β → α\nh : ∀ (x : β), p x → LE.le (u x) (v x)\n⊢ LE.le (Filter.blimsup u f p) (Filter.blimsup v f p)","decl":"theorem mono_blimsup (h : ∀ x, p x → u x ≤ v x) : blimsup u f p ≤ blimsup v f p :=\n  mono_blimsup' <| Eventually.of_forall h\n\n"}
{"name":"Filter.mono_bliminf'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np : β → Prop\nu v : β → α\nh : Filter.Eventually (fun x => p x → LE.le (u x) (v x)) f\n⊢ LE.le (Filter.bliminf u f p) (Filter.bliminf v f p)","decl":"theorem mono_bliminf' (h : ∀ᶠ x in f, p x → u x ≤ v x) : bliminf u f p ≤ bliminf v f p :=\n  sSup_le_sSup fun _ ha => (ha.and h).mono fun _ hx hx' => (hx.1 hx').trans (hx.2 hx')\n\n"}
{"name":"Filter.mono_bliminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np : β → Prop\nu v : β → α\nh : ∀ (x : β), p x → LE.le (u x) (v x)\n⊢ LE.le (Filter.bliminf u f p) (Filter.bliminf v f p)","decl":"theorem mono_bliminf (h : ∀ x, p x → u x ≤ v x) : bliminf u f p ≤ bliminf v f p :=\n  mono_bliminf' <| Eventually.of_forall h\n\n"}
{"name":"Filter.bliminf_antitone_filter","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf g : Filter β\np : β → Prop\nu : β → α\nh : LE.le f g\n⊢ LE.le (Filter.bliminf u g p) (Filter.bliminf u f p)","decl":"theorem bliminf_antitone_filter (h : f ≤ g) : bliminf u g p ≤ bliminf u f p :=\n  sSup_le_sSup fun _ ha => ha.filter_mono h\n\n"}
{"name":"Filter.blimsup_monotone_filter","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf g : Filter β\np : β → Prop\nu : β → α\nh : LE.le f g\n⊢ LE.le (Filter.blimsup u f p) (Filter.blimsup u g p)","decl":"theorem blimsup_monotone_filter (h : f ≤ g) : blimsup u f p ≤ blimsup u g p :=\n  sInf_le_sInf fun _ ha => ha.filter_mono h\n\n-- @[simp] -- Porting note: simp_nf linter, lhs simplifies, added _aux versions below\n"}
{"name":"Filter.blimsup_and_le_inf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np q : β → Prop\nu : β → α\n⊢ LE.le (Filter.blimsup u f fun x => And (p x) (q x)) (Min.min (Filter.blimsup u f p) (Filter.blimsup u f q))","decl":"theorem blimsup_and_le_inf : (blimsup u f fun x => p x ∧ q x) ≤ blimsup u f p ⊓ blimsup u f q :=\n  le_inf (blimsup_mono <| by tauto) (blimsup_mono <| by tauto)\n\n"}
{"name":"Filter.bliminf_sup_le_inf_aux_left","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np q : β → Prop\nu : β → α\n⊢ LE.le (Filter.blimsup u f fun x => And (p x) (q x)) (Filter.blimsup u f p)","decl":"@[simp]\ntheorem bliminf_sup_le_inf_aux_left :\n    (blimsup u f fun x => p x ∧ q x) ≤ blimsup u f p :=\n  blimsup_and_le_inf.trans inf_le_left\n\n"}
{"name":"Filter.bliminf_sup_le_inf_aux_right","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np q : β → Prop\nu : β → α\n⊢ LE.le (Filter.blimsup u f fun x => And (p x) (q x)) (Filter.blimsup u f q)","decl":"@[simp]\ntheorem bliminf_sup_le_inf_aux_right :\n    (blimsup u f fun x => p x ∧ q x) ≤ blimsup u f q :=\n  blimsup_and_le_inf.trans inf_le_right\n\n-- @[simp] -- Porting note: simp_nf linter, lhs simplifies, added _aux simp version below\n"}
{"name":"Filter.bliminf_sup_le_and","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np q : β → Prop\nu : β → α\n⊢ LE.le (Max.max (Filter.bliminf u f p) (Filter.bliminf u f q)) (Filter.bliminf u f fun x => And (p x) (q x))","decl":"theorem bliminf_sup_le_and : bliminf u f p ⊔ bliminf u f q ≤ bliminf u f fun x => p x ∧ q x :=\n  blimsup_and_le_inf (α := αᵒᵈ)\n\n"}
{"name":"Filter.bliminf_sup_le_and_aux_left","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np q : β → Prop\nu : β → α\n⊢ LE.le (Filter.bliminf u f p) (Filter.bliminf u f fun x => And (p x) (q x))","decl":"@[simp]\ntheorem bliminf_sup_le_and_aux_left : bliminf u f p ≤ bliminf u f fun x => p x ∧ q x :=\n  le_sup_left.trans bliminf_sup_le_and\n\n"}
{"name":"Filter.bliminf_sup_le_and_aux_right","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np q : β → Prop\nu : β → α\n⊢ LE.le (Filter.bliminf u f q) (Filter.bliminf u f fun x => And (p x) (q x))","decl":"@[simp]\ntheorem bliminf_sup_le_and_aux_right : bliminf u f q ≤ bliminf u f fun x => p x ∧ q x :=\n  le_sup_right.trans bliminf_sup_le_and\n\n"}
{"name":"Filter.blimsup_sup_le_or","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np q : β → Prop\nu : β → α\n⊢ LE.le (Max.max (Filter.blimsup u f p) (Filter.blimsup u f q)) (Filter.blimsup u f fun x => Or (p x) (q x))","decl":"/-- See also `Filter.blimsup_or_eq_sup`. -/\n-- @[simp] -- Porting note: simp_nf linter, lhs simplifies, added _aux simp versions below\ntheorem blimsup_sup_le_or : blimsup u f p ⊔ blimsup u f q ≤ blimsup u f fun x => p x ∨ q x :=\n  sup_le (blimsup_mono <| by tauto) (blimsup_mono <| by tauto)\n\n"}
{"name":"Filter.bliminf_sup_le_or_aux_left","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np q : β → Prop\nu : β → α\n⊢ LE.le (Filter.blimsup u f p) (Filter.blimsup u f fun x => Or (p x) (q x))","decl":"@[simp]\ntheorem bliminf_sup_le_or_aux_left : blimsup u f p ≤ blimsup u f fun x => p x ∨ q x :=\n  le_sup_left.trans blimsup_sup_le_or\n\n"}
{"name":"Filter.bliminf_sup_le_or_aux_right","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np q : β → Prop\nu : β → α\n⊢ LE.le (Filter.blimsup u f q) (Filter.blimsup u f fun x => Or (p x) (q x))","decl":"@[simp]\ntheorem bliminf_sup_le_or_aux_right : blimsup u f q ≤ blimsup u f fun x => p x ∨ q x :=\n  le_sup_right.trans blimsup_sup_le_or\n\n"}
{"name":"Filter.bliminf_or_le_inf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np q : β → Prop\nu : β → α\n⊢ LE.le (Filter.bliminf u f fun x => Or (p x) (q x)) (Min.min (Filter.bliminf u f p) (Filter.bliminf u f q))","decl":"/-- See also `Filter.bliminf_or_eq_inf`. -/\n--@[simp] -- Porting note: simp_nf linter, lhs simplifies, added _aux simp versions below\ntheorem bliminf_or_le_inf : (bliminf u f fun x => p x ∨ q x) ≤ bliminf u f p ⊓ bliminf u f q :=\n  blimsup_sup_le_or (α := αᵒᵈ)\n\n"}
{"name":"Filter.bliminf_or_le_inf_aux_left","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np q : β → Prop\nu : β → α\n⊢ LE.le (Filter.bliminf u f fun x => Or (p x) (q x)) (Filter.bliminf u f p)","decl":"@[simp]\ntheorem bliminf_or_le_inf_aux_left : (bliminf u f fun x => p x ∨ q x) ≤ bliminf u f p :=\n  bliminf_or_le_inf.trans inf_le_left\n\n"}
{"name":"Filter.bliminf_or_le_inf_aux_right","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteLattice α\nf : Filter β\np q : β → Prop\nu : β → α\n⊢ LE.le (Filter.bliminf u f fun x => Or (p x) (q x)) (Filter.bliminf u f q)","decl":"@[simp]\ntheorem bliminf_or_le_inf_aux_right : (bliminf u f fun x => p x ∨ q x) ≤ bliminf u f q :=\n  bliminf_or_le_inf.trans inf_le_right\n\n"}
{"name":"OrderIso.apply_blimsup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CompleteLattice α\nf : Filter β\np : β → Prop\nu : β → α\ninst✝ : CompleteLattice γ\ne : OrderIso α γ\n⊢ Eq (e (Filter.blimsup u f p)) (Filter.blimsup (Function.comp (⇑e) u) f p)","decl":"theorem _root_.OrderIso.apply_blimsup [CompleteLattice γ] (e : α ≃o γ) :\n    e (blimsup u f p) = blimsup (e ∘ u) f p := by\n  simp only [blimsup_eq, map_sInf, Function.comp_apply, e.image_eq_preimage,\n    Set.preimage_setOf_eq, e.le_symm_apply]\n\n"}
{"name":"OrderIso.apply_bliminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CompleteLattice α\nf : Filter β\np : β → Prop\nu : β → α\ninst✝ : CompleteLattice γ\ne : OrderIso α γ\n⊢ Eq (e (Filter.bliminf u f p)) (Filter.bliminf (Function.comp (⇑e) u) f p)","decl":"theorem _root_.OrderIso.apply_bliminf [CompleteLattice γ] (e : α ≃o γ) :\n    e (bliminf u f p) = bliminf (e ∘ u) f p :=\n  e.dual.apply_blimsup\n\n"}
{"name":"sSupHom.apply_blimsup_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CompleteLattice α\nf : Filter β\np : β → Prop\nu : β → α\ninst✝ : CompleteLattice γ\ng : sSupHom α γ\n⊢ LE.le (g (Filter.blimsup u f p)) (Filter.blimsup (Function.comp (⇑g) u) f p)","decl":"theorem _root_.sSupHom.apply_blimsup_le [CompleteLattice γ] (g : sSupHom α γ) :\n    g (blimsup u f p) ≤ blimsup (g ∘ u) f p := by\n  simp only [blimsup_eq_iInf_biSup, Function.comp]\n  refine ((OrderHomClass.mono g).map_iInf₂_le _).trans ?_\n  simp only [_root_.map_iSup, le_refl]\n\n"}
{"name":"sInfHom.le_apply_bliminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CompleteLattice α\nf : Filter β\np : β → Prop\nu : β → α\ninst✝ : CompleteLattice γ\ng : sInfHom α γ\n⊢ LE.le (Filter.bliminf (Function.comp (⇑g) u) f p) (g (Filter.bliminf u f p))","decl":"theorem _root_.sInfHom.le_apply_bliminf [CompleteLattice γ] (g : sInfHom α γ) :\n    bliminf (g ∘ u) f p ≤ g (bliminf u f p) :=\n  (sInfHom.dual g).apply_blimsup_le\n\n"}
{"name":"Filter.limsup_sup_filter","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteDistribLattice α\nf : Filter β\nu : β → α\ng : Filter β\n⊢ Eq (Filter.limsup u (Max.max f g)) (Max.max (Filter.limsup u f) (Filter.limsup u g))","decl":"lemma limsup_sup_filter {g} : limsup u (f ⊔ g) = limsup u f ⊔ limsup u g := by\n  refine le_antisymm ?_\n    (sup_le (limsup_le_limsup_of_le le_sup_left) (limsup_le_limsup_of_le le_sup_right))\n  simp_rw [limsup_eq, sInf_sup_eq, sup_sInf_eq, mem_setOf_eq, le_iInf₂_iff]\n  intro a ha b hb\n  exact sInf_le ⟨ha.mono fun _ h ↦ h.trans le_sup_left, hb.mono fun _ h ↦ h.trans le_sup_right⟩\n\n"}
{"name":"Filter.liminf_sup_filter","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteDistribLattice α\nf : Filter β\nu : β → α\ng : Filter β\n⊢ Eq (Filter.liminf u (Max.max f g)) (Min.min (Filter.liminf u f) (Filter.liminf u g))","decl":"lemma liminf_sup_filter {g} : liminf u (f ⊔ g) = liminf u f ⊓ liminf u g :=\n  limsup_sup_filter (α := αᵒᵈ)\n\n"}
{"name":"Filter.blimsup_or_eq_sup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteDistribLattice α\nf : Filter β\np q : β → Prop\nu : β → α\n⊢ Eq (Filter.blimsup u f fun x => Or (p x) (q x)) (Max.max (Filter.blimsup u f p) (Filter.blimsup u f q))","decl":"@[simp]\ntheorem blimsup_or_eq_sup : (blimsup u f fun x => p x ∨ q x) = blimsup u f p ⊔ blimsup u f q := by\n  simp only [blimsup_eq_limsup, ← limsup_sup_filter, ← inf_sup_left, sup_principal, setOf_or]\n\n"}
{"name":"Filter.bliminf_or_eq_inf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteDistribLattice α\nf : Filter β\np q : β → Prop\nu : β → α\n⊢ Eq (Filter.bliminf u f fun x => Or (p x) (q x)) (Min.min (Filter.bliminf u f p) (Filter.bliminf u f q))","decl":"@[simp]\ntheorem bliminf_or_eq_inf : (bliminf u f fun x => p x ∨ q x) = bliminf u f p ⊓ bliminf u f q :=\n  blimsup_or_eq_sup (α := αᵒᵈ)\n\n"}
{"name":"Filter.blimsup_sup_not","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteDistribLattice α\nf : Filter β\np : β → Prop\nu : β → α\n⊢ Eq (Max.max (Filter.blimsup u f p) (Filter.blimsup u f fun x => Not (p x))) (Filter.limsup u f)","decl":"@[simp]\nlemma blimsup_sup_not : blimsup u f p ⊔ blimsup u f (¬p ·) = limsup u f := by\n  simp_rw [← blimsup_or_eq_sup, or_not, blimsup_true]\n\n"}
{"name":"Filter.bliminf_inf_not","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteDistribLattice α\nf : Filter β\np : β → Prop\nu : β → α\n⊢ Eq (Min.min (Filter.bliminf u f p) (Filter.bliminf u f fun x => Not (p x))) (Filter.liminf u f)","decl":"@[simp]\nlemma bliminf_inf_not : bliminf u f p ⊓ bliminf u f (¬p ·) = liminf u f :=\n  blimsup_sup_not (α := αᵒᵈ)\n\n"}
{"name":"Filter.blimsup_not_sup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteDistribLattice α\nf : Filter β\np : β → Prop\nu : β → α\n⊢ Eq (Max.max (Filter.blimsup u f fun x => Not (p x)) (Filter.blimsup u f p)) (Filter.limsup u f)","decl":"@[simp]\nlemma blimsup_not_sup : blimsup u f (¬p ·) ⊔ blimsup u f p = limsup u f := by\n  simpa only [not_not] using blimsup_sup_not (p := (¬p ·))\n\n"}
{"name":"Filter.bliminf_not_inf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteDistribLattice α\nf : Filter β\np : β → Prop\nu : β → α\n⊢ Eq (Min.min (Filter.bliminf u f fun x => Not (p x)) (Filter.bliminf u f p)) (Filter.liminf u f)","decl":"@[simp]\nlemma bliminf_not_inf : bliminf u f (¬p ·) ⊓ bliminf u f p = liminf u f :=\n  blimsup_not_sup (α := αᵒᵈ)\n\n"}
{"name":"Filter.limsup_piecewise","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteDistribLattice α\nf : Filter β\nu : β → α\ns : Set β\ninst✝ : DecidablePred fun x => Membership.mem s x\nv : β → α\n⊢ Eq (Filter.limsup (s.piecewise u v) f) (Max.max (Filter.blimsup u f fun x => Membership.mem s x) (Filter.blimsup v f fun x => Not (Membership.mem s x)))","decl":"lemma limsup_piecewise {s : Set β} [DecidablePred (· ∈ s)] {v} :\n    limsup (s.piecewise u v) f = blimsup u f (· ∈ s) ⊔ blimsup v f (· ∉ s) := by\n  rw [← blimsup_sup_not (p := (· ∈ s))]\n  refine congr_arg₂ _ (blimsup_congr ?_) (blimsup_congr ?_) <;>\n    filter_upwards with _ h using by simp [h]\n\n"}
{"name":"Filter.liminf_piecewise","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteDistribLattice α\nf : Filter β\nu : β → α\ns : Set β\ninst✝ : DecidablePred fun x => Membership.mem s x\nv : β → α\n⊢ Eq (Filter.liminf (s.piecewise u v) f) (Min.min (Filter.bliminf u f fun x => Membership.mem s x) (Filter.bliminf v f fun x => Not (Membership.mem s x)))","decl":"lemma liminf_piecewise {s : Set β} [DecidablePred (· ∈ s)] {v} :\n    liminf (s.piecewise u v) f = bliminf u f (· ∈ s) ⊓ bliminf v f (· ∉ s) :=\n  limsup_piecewise (α := αᵒᵈ)\n\n"}
{"name":"Filter.sup_limsup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteDistribLattice α\nf : Filter β\nu : β → α\ninst✝ : f.NeBot\na : α\n⊢ Eq (Max.max a (Filter.limsup u f)) (Filter.limsup (fun x => Max.max a (u x)) f)","decl":"theorem sup_limsup [NeBot f] (a : α) : a ⊔ limsup u f = limsup (fun x => a ⊔ u x) f := by\n  simp only [limsup_eq_iInf_iSup, iSup_sup_eq, sup_iInf₂_eq]\n  congr; ext s; congr; ext hs; congr\n  exact (biSup_const (nonempty_of_mem hs)).symm\n\n"}
{"name":"Filter.inf_liminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteDistribLattice α\nf : Filter β\nu : β → α\ninst✝ : f.NeBot\na : α\n⊢ Eq (Min.min a (Filter.liminf u f)) (Filter.liminf (fun x => Min.min a (u x)) f)","decl":"theorem inf_liminf [NeBot f] (a : α) : a ⊓ liminf u f = liminf (fun x => a ⊓ u x) f :=\n  sup_limsup (α := αᵒᵈ) a\n\n"}
{"name":"Filter.sup_liminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteDistribLattice α\nf : Filter β\nu : β → α\na : α\n⊢ Eq (Max.max a (Filter.liminf u f)) (Filter.liminf (fun x => Max.max a (u x)) f)","decl":"theorem sup_liminf (a : α) : a ⊔ liminf u f = liminf (fun x => a ⊔ u x) f := by\n  simp only [liminf_eq_iSup_iInf]\n  rw [sup_comm, biSup_sup (⟨univ, univ_mem⟩ : ∃ i : Set β, i ∈ f)]\n  simp_rw [iInf₂_sup_eq, sup_comm (a := a)]\n\n"}
{"name":"Filter.inf_limsup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteDistribLattice α\nf : Filter β\nu : β → α\na : α\n⊢ Eq (Min.min a (Filter.limsup u f)) (Filter.limsup (fun x => Min.min a (u x)) f)","decl":"theorem inf_limsup (a : α) : a ⊓ limsup u f = limsup (fun x => a ⊓ u x) f :=\n  sup_liminf (α := αᵒᵈ) a\n\n"}
{"name":"Filter.limsup_compl","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteBooleanAlgebra α\nf : Filter β\nu : β → α\n⊢ Eq (HasCompl.compl (Filter.limsup u f)) (Filter.liminf (Function.comp HasCompl.compl u) f)","decl":"theorem limsup_compl : (limsup u f)ᶜ = liminf (compl ∘ u) f := by\n  simp only [limsup_eq_iInf_iSup, compl_iInf, compl_iSup, liminf_eq_iSup_iInf, Function.comp_apply]\n\n"}
{"name":"Filter.liminf_compl","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteBooleanAlgebra α\nf : Filter β\nu : β → α\n⊢ Eq (HasCompl.compl (Filter.liminf u f)) (Filter.limsup (Function.comp HasCompl.compl u) f)","decl":"theorem liminf_compl : (liminf u f)ᶜ = limsup (compl ∘ u) f := by\n  simp only [limsup_eq_iInf_iSup, compl_iInf, compl_iSup, liminf_eq_iSup_iInf, Function.comp_apply]\n\n"}
{"name":"Filter.limsup_sdiff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteBooleanAlgebra α\nf : Filter β\nu : β → α\na : α\n⊢ Eq (SDiff.sdiff (Filter.limsup u f) a) (Filter.limsup (fun b => SDiff.sdiff (u b) a) f)","decl":"theorem limsup_sdiff (a : α) : limsup u f \\ a = limsup (fun b => u b \\ a) f := by\n  simp only [limsup_eq_iInf_iSup, sdiff_eq]\n  rw [biInf_inf (⟨univ, univ_mem⟩ : ∃ i : Set β, i ∈ f)]\n  simp_rw [inf_comm, inf_iSup₂_eq, inf_comm]\n\n"}
{"name":"Filter.liminf_sdiff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteBooleanAlgebra α\nf : Filter β\nu : β → α\ninst✝ : f.NeBot\na : α\n⊢ Eq (SDiff.sdiff (Filter.liminf u f) a) (Filter.liminf (fun b => SDiff.sdiff (u b) a) f)","decl":"theorem liminf_sdiff [NeBot f] (a : α) : liminf u f \\ a = liminf (fun b => u b \\ a) f := by\n  simp only [sdiff_eq, inf_comm _ aᶜ, inf_liminf]\n\n"}
{"name":"Filter.sdiff_limsup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CompleteBooleanAlgebra α\nf : Filter β\nu : β → α\ninst✝ : f.NeBot\na : α\n⊢ Eq (SDiff.sdiff a (Filter.limsup u f)) (Filter.liminf (fun b => SDiff.sdiff a (u b)) f)","decl":"theorem sdiff_limsup [NeBot f] (a : α) : a \\ limsup u f = liminf (fun b => a \\ u b) f := by\n  rw [← compl_inj_iff]\n  simp only [sdiff_eq, liminf_compl, comp_def, compl_inf, compl_compl, sup_limsup]\n\n"}
{"name":"Filter.sdiff_liminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : CompleteBooleanAlgebra α\nf : Filter β\nu : β → α\na : α\n⊢ Eq (SDiff.sdiff a (Filter.liminf u f)) (Filter.limsup (fun b => SDiff.sdiff a (u b)) f)","decl":"theorem sdiff_liminf (a : α) : a \\ liminf u f = limsup (fun b => a \\ u b) f := by\n  rw [← compl_inj_iff]\n  simp only [sdiff_eq, limsup_compl, comp_def, compl_inf, compl_compl, sup_liminf]\n\n"}
{"name":"Filter.mem_liminf_iff_eventually_mem","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\ns : ι → Set α\n𝓕 : Filter ι\na : α\n⊢ Iff (Membership.mem (Filter.liminf s 𝓕) a) (Filter.Eventually (fun i => Membership.mem (s i) a) 𝓕)","decl":"lemma mem_liminf_iff_eventually_mem : (a ∈ liminf s 𝓕) ↔ (∀ᶠ i in 𝓕, a ∈ s i) := by\n  simpa only [liminf_eq_iSup_iInf, iSup_eq_iUnion, iInf_eq_iInter, mem_iUnion, mem_iInter]\n    using ⟨fun ⟨S, hS, hS'⟩ ↦ mem_of_superset hS (by tauto), fun h ↦ ⟨{i | a ∈ s i}, h, by tauto⟩⟩\n\n"}
{"name":"Filter.mem_limsup_iff_frequently_mem","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\ns : ι → Set α\n𝓕 : Filter ι\na : α\n⊢ Iff (Membership.mem (Filter.limsup s 𝓕) a) (Filter.Frequently (fun i => Membership.mem (s i) a) 𝓕)","decl":"lemma mem_limsup_iff_frequently_mem : (a ∈ limsup s 𝓕) ↔ (∃ᶠ i in 𝓕, a ∈ s i) := by\n  simp only [Filter.Frequently, iff_not_comm, ← mem_compl_iff, limsup_compl, comp_apply,\n    mem_liminf_iff_eventually_mem]\n\n"}
{"name":"Filter.cofinite.blimsup_set_eq","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\np : ι → Prop\ns : ι → Set α\n⊢ Eq (Filter.blimsup s Filter.cofinite p) (setOf fun x => (setOf fun n => And (p n) (Membership.mem (s n) x)).Infinite)","decl":"theorem cofinite.blimsup_set_eq :\n    blimsup s cofinite p = { x | { n | p n ∧ x ∈ s n }.Infinite } := by\n  simp only [blimsup_eq, le_eq_subset, eventually_cofinite, not_forall, sInf_eq_sInter, exists_prop]\n  ext x\n  refine ⟨fun h => ?_, fun hx t h => ?_⟩ <;> contrapose! h\n  · simp only [mem_sInter, mem_setOf_eq, not_forall, exists_prop]\n    exact ⟨{x}ᶜ, by simpa using h, by simp⟩\n  · exact hx.mono fun i hi => ⟨hi.1, fun hit => h (hit hi.2)⟩\n\n"}
{"name":"Filter.cofinite.bliminf_set_eq","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\np : ι → Prop\ns : ι → Set α\n⊢ Eq (Filter.bliminf s Filter.cofinite p) (setOf fun x => (setOf fun n => And (p n) (Not (Membership.mem (s n) x))).Finite)","decl":"theorem cofinite.bliminf_set_eq : bliminf s cofinite p = { x | { n | p n ∧ x ∉ s n }.Finite } := by\n  rw [← compl_inj_iff]\n  simp only [bliminf_eq_iSup_biInf, compl_iInf, compl_iSup, ← blimsup_eq_iInf_biSup,\n    cofinite.blimsup_set_eq]\n  rfl\n\n"}
{"name":"Filter.cofinite.limsup_set_eq","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\ns : ι → Set α\n⊢ Eq (Filter.limsup s Filter.cofinite) (setOf fun x => (setOf fun n => Membership.mem (s n) x).Infinite)","decl":"/-- In other words, `limsup cofinite s` is the set of elements lying inside the family `s`\ninfinitely often. -/\ntheorem cofinite.limsup_set_eq : limsup s cofinite = { x | { n | x ∈ s n }.Infinite } := by\n  simp only [← cofinite.blimsup_true s, cofinite.blimsup_set_eq, true_and]\n\n"}
{"name":"Filter.cofinite.liminf_set_eq","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\ns : ι → Set α\n⊢ Eq (Filter.liminf s Filter.cofinite) (setOf fun x => (setOf fun n => Not (Membership.mem (s n) x)).Finite)","decl":"/-- In other words, `liminf cofinite s` is the set of elements lying outside the family `s`\nfinitely often. -/\ntheorem cofinite.liminf_set_eq : liminf s cofinite = { x | { n | x ∉ s n }.Finite } := by\n  simp only [← cofinite.bliminf_true s, cofinite.bliminf_set_eq, true_and]\n\n"}
{"name":"Filter.exists_forall_mem_of_hasBasis_mem_blimsup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\nl : Filter β\nb : ι → Set β\nq : ι → Prop\nhl : l.HasBasis q b\nu : β → Set α\np : β → Prop\nx : α\nhx : Membership.mem (Filter.blimsup u l p) x\n⊢ Exists fun f => ∀ (i : ↑(setOf fun i => q i)), And (Membership.mem (u (f i)) x) (And (p (f i)) (Membership.mem (b ↑i) (f i)))","decl":"theorem exists_forall_mem_of_hasBasis_mem_blimsup {l : Filter β} {b : ι → Set β} {q : ι → Prop}\n    (hl : l.HasBasis q b) {u : β → Set α} {p : β → Prop} {x : α} (hx : x ∈ blimsup u l p) :\n    ∃ f : { i | q i } → β, ∀ i, x ∈ u (f i) ∧ p (f i) ∧ f i ∈ b i := by\n  rw [blimsup_eq_iInf_biSup] at hx\n  simp only [iSup_eq_iUnion, iInf_eq_iInter, mem_iInter, mem_iUnion, exists_prop] at hx\n  choose g hg hg' using hx\n  refine ⟨fun i : { i | q i } => g (b i) (hl.mem_of_mem i.2), fun i => ⟨?_, ?_⟩⟩\n  · exact hg' (b i) (hl.mem_of_mem i.2)\n  · exact hg (b i) (hl.mem_of_mem i.2)\n\n"}
{"name":"Filter.exists_forall_mem_of_hasBasis_mem_blimsup'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\nl : Filter β\nb : ι → Set β\nhl : l.HasBasis (fun x => True) b\nu : β → Set α\np : β → Prop\nx : α\nhx : Membership.mem (Filter.blimsup u l p) x\n⊢ Exists fun f => ∀ (i : ι), And (Membership.mem (u (f i)) x) (And (p (f i)) (Membership.mem (b i) (f i)))","decl":"theorem exists_forall_mem_of_hasBasis_mem_blimsup' {l : Filter β} {b : ι → Set β}\n    (hl : l.HasBasis (fun _ => True) b) {u : β → Set α} {p : β → Prop} {x : α}\n    (hx : x ∈ blimsup u l p) : ∃ f : ι → β, ∀ i, x ∈ u (f i) ∧ p (f i) ∧ f i ∈ b i := by\n  obtain ⟨f, hf⟩ := exists_forall_mem_of_hasBasis_mem_blimsup hl hx\n  exact ⟨fun i => f ⟨i, trivial⟩, fun i => hf ⟨i, trivial⟩⟩\n\n"}
{"name":"Filter.frequently_lt_of_lt_limsSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nf : Filter α\ninst✝ : ConditionallyCompleteLinearOrder α\na : α\nhf : autoParam (Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) f) _auto✝\nh : LT.lt a f.limsSup\n⊢ Filter.Frequently (fun n => LT.lt a n) f","decl":"theorem frequently_lt_of_lt_limsSup {f : Filter α} [ConditionallyCompleteLinearOrder α] {a : α}\n    (hf : f.IsCobounded (· ≤ ·) := by isBoundedDefault)\n    (h : a < limsSup f) : ∃ᶠ n in f, a < n := by\n  contrapose! h\n  simp only [not_frequently, not_lt] at h\n  exact limsSup_le_of_le hf h\n\n"}
{"name":"Filter.frequently_lt_of_limsInf_lt","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nf : Filter α\ninst✝ : ConditionallyCompleteLinearOrder α\na : α\nhf : autoParam (Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) f) _auto✝\nh : LT.lt f.limsInf a\n⊢ Filter.Frequently (fun n => LT.lt n a) f","decl":"theorem frequently_lt_of_limsInf_lt {f : Filter α} [ConditionallyCompleteLinearOrder α] {a : α}\n    (hf : f.IsCobounded (· ≥ ·) := by isBoundedDefault)\n    (h : limsInf f < a) : ∃ᶠ n in f, n < a :=\n  frequently_lt_of_lt_limsSup (α := OrderDual α) hf h\n\n"}
{"name":"Filter.eventually_lt_of_lt_liminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ninst✝ : ConditionallyCompleteLinearOrder β\nu : α → β\nb : β\nh : LT.lt b (Filter.liminf u f)\nhu : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\n⊢ Filter.Eventually (fun a => LT.lt b (u a)) f","decl":"theorem eventually_lt_of_lt_liminf {f : Filter α} [ConditionallyCompleteLinearOrder β] {u : α → β}\n    {b : β} (h : b < liminf u f)\n    (hu : f.IsBoundedUnder (· ≥ ·) u := by isBoundedDefault) :\n    ∀ᶠ a in f, b < u a := by\n  obtain ⟨c, hc, hbc⟩ : ∃ (c : β) (_ : c ∈ { c : β | ∀ᶠ n : α in f, c ≤ u n }), b < c := by\n    simp_rw [exists_prop]\n    exact exists_lt_of_lt_csSup hu h\n  exact hc.mono fun x hx => lt_of_lt_of_le hbc hx\n\n"}
{"name":"Filter.eventually_lt_of_limsup_lt","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ninst✝ : ConditionallyCompleteLinearOrder β\nu : α → β\nb : β\nh : LT.lt (Filter.limsup u f) b\nhu : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\n⊢ Filter.Eventually (fun a => LT.lt (u a) b) f","decl":"theorem eventually_lt_of_limsup_lt {f : Filter α} [ConditionallyCompleteLinearOrder β] {u : α → β}\n    {b : β} (h : limsup u f < b)\n    (hu : f.IsBoundedUnder (· ≤ ·) u := by isBoundedDefault) :\n    ∀ᶠ a in f, u a < b :=\n  eventually_lt_of_lt_liminf (β := βᵒᵈ) h hu\n\n"}
{"name":"Filter.eventually_lt_add_pos_of_limsup_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : Preorder β\ninst✝¹ : AddMonoid α\ninst✝ : AddLeftStrictMono α\nx ε : α\nu : β → α\nhu_bdd : Filter.IsBoundedUnder LE.le Filter.atTop u\nhu : LE.le (Filter.limsup u Filter.atTop) x\nhε : LT.lt 0 ε\n⊢ Filter.Eventually (fun b => LT.lt (u b) (HAdd.hAdd x ε)) Filter.atTop","decl":"/-- If `Filter.limsup u atTop ≤ x`, then for all `ε > 0`, eventually we have `u b < x + ε`. -/\ntheorem eventually_lt_add_pos_of_limsup_le [Preorder β] [AddMonoid α] [AddLeftStrictMono α]\n    {x ε : α} {u : β → α} (hu_bdd : IsBoundedUnder LE.le atTop u) (hu : Filter.limsup u atTop ≤ x)\n    (hε : 0 < ε) :\n    ∀ᶠ b : β in atTop, u b < x + ε :=\n  eventually_lt_of_limsup_lt (lt_of_le_of_lt hu (lt_add_of_pos_right x hε)) hu_bdd\n\n"}
{"name":"Filter.eventually_add_neg_lt_of_le_liminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : ConditionallyCompleteLinearOrder α\ninst✝² : Preorder β\ninst✝¹ : AddMonoid α\ninst✝ : AddLeftStrictMono α\nx ε : α\nu : β → α\nhu_bdd : Filter.IsBoundedUnder GE.ge Filter.atTop u\nhu : LE.le x (Filter.liminf u Filter.atTop)\nhε : LT.lt ε 0\n⊢ Filter.Eventually (fun b => LT.lt (HAdd.hAdd x ε) (u b)) Filter.atTop","decl":"/-- If `x ≤ Filter.liminf u atTop`, then for all `ε < 0`, eventually we have `x + ε < u b`. -/\ntheorem eventually_add_neg_lt_of_le_liminf [Preorder β] [AddMonoid α] [AddLeftStrictMono α]\n    {x ε : α} {u : β → α} (hu_bdd : IsBoundedUnder GE.ge atTop u) (hu : x ≤ Filter.liminf u atTop )\n    (hε : ε < 0) :\n    ∀ᶠ b : β in atTop, x + ε < u b :=\n  eventually_lt_of_lt_liminf (lt_of_lt_of_le (add_lt_of_neg_right x hε) hu) hu_bdd\n\n"}
{"name":"Filter.exists_lt_of_limsup_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : AddMonoid α\ninst✝ : AddLeftStrictMono α\nx ε : α\nu : Nat → α\nhu_bdd : Filter.IsBoundedUnder LE.le Filter.atTop u\nhu : LE.le (Filter.limsup u Filter.atTop) x\nhε : LT.lt 0 ε\n⊢ Exists fun n => LT.lt (u ↑n) (HAdd.hAdd x ε)","decl":"/-- If `Filter.limsup u atTop ≤ x`, then for all `ε > 0`, there exists a positive natural\n  number `n` such that `u n < x + ε`.  -/\ntheorem exists_lt_of_limsup_le [AddMonoid α] [AddLeftStrictMono α] {x ε : α} {u : ℕ → α}\n    (hu_bdd : IsBoundedUnder LE.le atTop u) (hu : Filter.limsup u atTop ≤ x) (hε : 0 < ε) :\n    ∃ n : PNat, u n < x + ε := by\n  have h : ∀ᶠ n : ℕ in atTop, u n < x + ε := eventually_lt_add_pos_of_limsup_le hu_bdd hu hε\n  simp only [eventually_atTop] at h\n  obtain ⟨n, hn⟩ := h\n  exact ⟨⟨n + 1, Nat.succ_pos _⟩, hn (n + 1) (Nat.le_succ _)⟩\n\n"}
{"name":"Filter.exists_lt_of_le_liminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝² : ConditionallyCompleteLinearOrder α\ninst✝¹ : AddMonoid α\ninst✝ : AddLeftStrictMono α\nx ε : α\nu : Nat → α\nhu_bdd : Filter.IsBoundedUnder GE.ge Filter.atTop u\nhu : LE.le x (Filter.liminf u Filter.atTop)\nhε : LT.lt ε 0\n⊢ Exists fun n => LT.lt (HAdd.hAdd x ε) (u ↑n)","decl":"/-- If `x ≤ Filter.liminf u atTop`, then for all `ε < 0`, there exists a positive natural\n  number `n` such that ` x + ε < u n`.  -/\ntheorem exists_lt_of_le_liminf [AddMonoid α] [AddLeftStrictMono α] {x ε : α} {u : ℕ → α}\n    (hu_bdd : IsBoundedUnder GE.ge atTop u) (hu : x ≤ Filter.liminf u atTop) (hε : ε < 0) :\n    ∃ n : PNat, x + ε < u n := by\n  have h : ∀ᶠ n : ℕ in atTop, x + ε < u n := eventually_add_neg_lt_of_le_liminf hu_bdd hu hε\n  simp only [eventually_atTop] at h\n  obtain ⟨n, hn⟩ := h\n  exact ⟨⟨n + 1, Nat.succ_pos _⟩, hn (n + 1) (Nat.le_succ _)⟩\n"}
{"name":"Filter.le_limsup_of_frequently_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝ : ConditionallyCompleteLinearOrder β\nf : Filter α\nu : α → β\nb : β\nhu_le : Filter.Frequently (fun x => LE.le b (u x)) f\nhu : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\n⊢ LE.le b (Filter.limsup u f)","decl":"theorem le_limsup_of_frequently_le {α β} [ConditionallyCompleteLinearOrder β] {f : Filter α}\n    {u : α → β} {b : β} (hu_le : ∃ᶠ x in f, b ≤ u x)\n    (hu : f.IsBoundedUnder (· ≤ ·) u := by isBoundedDefault) :\n    b ≤ limsup u f := by\n  revert hu_le\n  rw [← not_imp_not, not_frequently]\n  simp_rw [← lt_iff_not_ge]\n  exact fun h => eventually_lt_of_limsup_lt h hu\n\n"}
{"name":"Filter.liminf_le_of_frequently_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝ : ConditionallyCompleteLinearOrder β\nf : Filter α\nu : α → β\nb : β\nhu_le : Filter.Frequently (fun x => LE.le (u x) b) f\nhu : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\n⊢ LE.le (Filter.liminf u f) b","decl":"theorem liminf_le_of_frequently_le {α β} [ConditionallyCompleteLinearOrder β] {f : Filter α}\n    {u : α → β} {b : β} (hu_le : ∃ᶠ x in f, u x ≤ b)\n    (hu : f.IsBoundedUnder (· ≥ ·) u := by isBoundedDefault) :\n    liminf u f ≤ b :=\n  le_limsup_of_frequently_le (β := βᵒᵈ) hu_le hu\n\n"}
{"name":"Filter.frequently_lt_of_lt_limsup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝ : ConditionallyCompleteLinearOrder β\nf : Filter α\nu : α → β\nb : β\nhu : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\nh : LT.lt b (Filter.limsup u f)\n⊢ Filter.Frequently (fun x => LT.lt b (u x)) f","decl":"theorem frequently_lt_of_lt_limsup {α β} [ConditionallyCompleteLinearOrder β] {f : Filter α}\n    {u : α → β} {b : β}\n    (hu : f.IsCoboundedUnder (· ≤ ·) u := by isBoundedDefault)\n    (h : b < limsup u f) : ∃ᶠ x in f, b < u x := by\n  contrapose! h\n  apply limsSup_le_of_le hu\n  simpa using h\n\n"}
{"name":"Filter.frequently_lt_of_liminf_lt","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝ : ConditionallyCompleteLinearOrder β\nf : Filter α\nu : α → β\nb : β\nhu : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\nh : LT.lt (Filter.liminf u f) b\n⊢ Filter.Frequently (fun x => LT.lt (u x) b) f","decl":"theorem frequently_lt_of_liminf_lt {α β} [ConditionallyCompleteLinearOrder β] {f : Filter α}\n    {u : α → β} {b : β}\n    (hu : f.IsCoboundedUnder (· ≥ ·) u := by isBoundedDefault)\n    (h : liminf u f < b) : ∃ᶠ x in f, u x < b :=\n  frequently_lt_of_lt_limsup (β := βᵒᵈ) hu h\n\n"}
{"name":"Filter.limsup_le_iff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝ : ConditionallyCompleteLinearOrder β\nf : Filter α\nu : α → β\nx : β\nh₁ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\nh₂ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\n⊢ Iff (LE.le (Filter.limsup u f) x) (∀ (y : β), GT.gt y x → Filter.Eventually (fun a => LT.lt (u a) y) f)","decl":"theorem limsup_le_iff {α β} [ConditionallyCompleteLinearOrder β] {f : Filter α} {u : α → β} {x : β}\n    (h₁ : f.IsCoboundedUnder (· ≤ ·) u := by isBoundedDefault)\n    (h₂ : f.IsBoundedUnder (· ≤ ·) u := by isBoundedDefault) :\n    limsup u f ≤ x ↔ ∀ y > x, ∀ᶠ a in f, u a < y := by\n  refine ⟨fun h _ h' ↦ eventually_lt_of_limsup_lt (lt_of_le_of_lt h h') h₂, fun h ↦ ?_⟩\n  --Two cases: Either `x` is a cluster point from above, or it is not.\n  --In the first case, we use `forall_lt_iff_le'` and split an interval.\n  --In the second case, the function `u` must eventually be smaller or equal to `x`.\n  by_cases h' : ∀ y > x, ∃ z, x < z ∧ z < y\n  · rw [← forall_lt_iff_le']\n    intro y x_y\n    rcases h' y x_y with ⟨z, x_z, z_y⟩\n    exact lt_of_le_of_lt (limsup_le_of_le h₁ ((h z x_z).mono (fun _ ↦ le_of_lt))) z_y\n  · apply limsup_le_of_le h₁\n    set_option push_neg.use_distrib true in push_neg at h'\n    rcases h' with ⟨z, x_z, hz⟩\n    exact (h z x_z).mono  <| fun w hw ↦ (or_iff_left (not_le_of_lt hw)).1 (hz (u w))\n\n"}
{"name":"Filter.le_limsup_iff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝ : ConditionallyCompleteLinearOrder β\nf : Filter α\nu : α → β\nx : β\nh₁ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\nh₂ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\n⊢ Iff (LE.le x (Filter.limsup u f)) (∀ (y : β), LT.lt y x → Filter.Frequently (fun a => LT.lt y (u a)) f)","decl":"theorem le_limsup_iff {α β} [ConditionallyCompleteLinearOrder β] {f : Filter α} {u : α → β} {x : β}\n    (h₁ : f.IsCoboundedUnder (· ≤ ·) u := by isBoundedDefault)\n    (h₂ : f.IsBoundedUnder (· ≤ ·) u := by isBoundedDefault) :\n    x ≤ limsup u f ↔ ∀ y < x, ∃ᶠ a in f, y < u a := by\n  refine ⟨fun h _ h' ↦ frequently_lt_of_lt_limsup h₁ (lt_of_lt_of_le h' h), fun h ↦ ?_⟩\n  --Two cases: Either `x` is a cluster point from below, or it is not.\n  --In the first case, we use `forall_lt_iff_le` and split an interval.\n  --In the second case, the function `u` must frequently be larger or equal to `x`.\n  by_cases h' : ∀ y < x, ∃ z, y < z ∧ z < x\n  · rw [← forall_lt_iff_le]\n    intro y y_x\n    rcases h' y y_x with ⟨z, y_z, z_x⟩\n    exact lt_of_lt_of_le y_z (le_limsup_of_frequently_le ((h z z_x).mono (fun _ ↦ le_of_lt)) h₂)\n  · apply le_limsup_of_frequently_le _ h₂\n    set_option push_neg.use_distrib true in push_neg at h'\n    rcases h' with ⟨z, z_x, hz⟩\n    exact (h z z_x).mono <| fun w hw ↦ (or_iff_right (not_le_of_lt hw)).1 (hz (u w))\n\n"}
{"name":"Filter.le_liminf_iff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝ : ConditionallyCompleteLinearOrder β\nf : Filter α\nu : α → β\nx : β\nh₁ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\nh₂ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\n⊢ Iff (LE.le x (Filter.liminf u f)) (∀ (y : β), LT.lt y x → Filter.Eventually (fun a => LT.lt y (u a)) f)","decl":"theorem le_liminf_iff {α β} [ConditionallyCompleteLinearOrder β] {f : Filter α} {u : α → β} {x : β}\n    (h₁ : f.IsCoboundedUnder (· ≥ ·) u := by isBoundedDefault)\n    (h₂ : f.IsBoundedUnder (· ≥ ·) u := by isBoundedDefault) :\n    x ≤ liminf u f ↔ ∀ y < x, ∀ᶠ a in f, y < u a := limsup_le_iff (β := βᵒᵈ) h₁ h₂\n\n"}
{"name":"Filter.liminf_le_iff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝ : ConditionallyCompleteLinearOrder β\nf : Filter α\nu : α → β\nx : β\nh₁ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\nh₂ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\n⊢ Iff (LE.le (Filter.liminf u f) x) (∀ (y : β), GT.gt y x → Filter.Frequently (fun a => LT.lt (u a) y) f)","decl":"theorem liminf_le_iff {α β} [ConditionallyCompleteLinearOrder β] {f : Filter α} {u : α → β} {x : β}\n    (h₁ : f.IsCoboundedUnder (· ≥ ·) u := by isBoundedDefault)\n    (h₂ : f.IsBoundedUnder (· ≥ ·) u := by isBoundedDefault) :\n    liminf u f ≤ x ↔ ∀ y > x, ∃ᶠ a in f, u a < y := le_limsup_iff (β := βᵒᵈ) h₁ h₂\n\n"}
{"name":"Filter.lt_mem_sets_of_limsSup_lt","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrder α\nf : Filter α\nb : α\nh : Filter.IsBounded (fun x1 x2 => LE.le x1 x2) f\nl : LT.lt f.limsSup b\n⊢ Filter.Eventually (fun a => LT.lt a b) f","decl":"set_option linter.unusedVariables false in\ntheorem lt_mem_sets_of_limsSup_lt (h : f.IsBounded (· ≤ ·)) (l : f.limsSup < b) :\n    ∀ᶠ a in f, a < b :=\n  let ⟨c, (h : ∀ᶠ a in f, a ≤ c), hcb⟩ := exists_lt_of_csInf_lt h l\n  mem_of_superset h fun _a => hcb.trans_le'\n\n"}
{"name":"Filter.gt_mem_sets_of_limsInf_gt","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\ninst✝ : ConditionallyCompleteLinearOrder α\nf : Filter α\nb : α\na✝¹ : Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) f\na✝ : LT.lt b f.limsInf\n⊢ Filter.Eventually (fun a => LT.lt b a) f","decl":"theorem gt_mem_sets_of_limsInf_gt : f.IsBounded (· ≥ ·) → b < f.limsInf → ∀ᶠ a in f, b < a :=\n  @lt_mem_sets_of_limsSup_lt αᵒᵈ _ _ _\n\n"}
{"name":"Filter.HasBasis.liminf_eq_ciSup_ciInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\nι' : Type u_5\ninst✝² : ConditionallyCompleteLinearOrder α\nv : Filter ι\np : ι' → Prop\ns : ι' → Set ι\ninst✝¹ : Countable (Subtype p)\ninst✝ : Nonempty (Subtype p)\nhv : v.HasBasis p s\nf : ι → α\nhs : ∀ (j : Subtype p), (s ↑j).Nonempty\nH : Exists fun j => BddBelow (Set.range fun i => f ↑i)\n⊢ Eq (Filter.liminf f v) (iSup fun j => iInf fun i => f ↑i)","decl":"/-- Writing a liminf as a supremum of infimum, in a (possibly non-complete) conditionally complete\nlinear order. A reparametrization trick is needed to avoid taking the infimum of sets which are\nnot bounded below. -/\ntheorem HasBasis.liminf_eq_ciSup_ciInf {v : Filter ι}\n    {p : ι' → Prop} {s : ι' → Set ι} [Countable (Subtype p)] [Nonempty (Subtype p)]\n    (hv : v.HasBasis p s) {f : ι → α} (hs : ∀ (j : Subtype p), (s j).Nonempty)\n    (H : ∃ (j : Subtype p), BddBelow (range (fun (i : s j) ↦ f i))) :\n    liminf f v = ⨆ (j : Subtype p), ⨅ (i : s (liminf_reparam f s p j)), f i := by\n  classical\n  rcases H with ⟨j0, hj0⟩\n  let m : Set (Subtype p) := {j | BddBelow (range (fun (i : s j) ↦ f i))}\n  have : ∀ (j : Subtype p), Nonempty (s j) := fun j ↦ Nonempty.coe_sort (hs j)\n  have A : ⋃ (j : Subtype p), ⋂ (i : s j), Iic (f i) =\n         ⋃ (j : Subtype p), ⋂ (i : s (liminf_reparam f s p j)), Iic (f i) := by\n    apply Subset.antisymm\n    · apply iUnion_subset (fun j ↦ ?_)\n      by_cases hj : j ∈ m\n      · have : j = liminf_reparam f s p j := by simp only [m, liminf_reparam, hj, ite_true]\n        conv_lhs => rw [this]\n        apply subset_iUnion _ j\n      · simp only [m, mem_setOf_eq, ← nonempty_iInter_Iic_iff, not_nonempty_iff_eq_empty] at hj\n        simp only [hj, empty_subset]\n    · apply iUnion_subset (fun j ↦ ?_)\n      exact subset_iUnion (fun (k : Subtype p) ↦ (⋂ (i : s k), Iic (f i))) (liminf_reparam f s p j)\n  have B : ∀ (j : Subtype p), ⋂ (i : s (liminf_reparam f s p j)), Iic (f i) =\n                                Iic (⨅ (i : s (liminf_reparam f s p j)), f i) := by\n    intro j\n    apply (Iic_ciInf _).symm\n    change liminf_reparam f s p j ∈ m\n    by_cases Hj : j ∈ m\n    · simpa only [m, liminf_reparam, if_pos Hj] using Hj\n    · simp only [m, liminf_reparam, if_neg Hj]\n      have Z : ∃ n, (exists_surjective_nat (Subtype p)).choose n ∈ m ∨ ∀ j, j ∉ m := by\n        rcases (exists_surjective_nat (Subtype p)).choose_spec j0 with ⟨n, rfl⟩\n        exact ⟨n, Or.inl hj0⟩\n      rcases Nat.find_spec Z with hZ|hZ\n      · exact hZ\n      · exact (hZ j0 hj0).elim\n  simp_rw [hv.liminf_eq_sSup_iUnion_iInter, A, B, sSup_iUnion_Iic]\n\n"}
{"name":"Filter.HasBasis.liminf_eq_ite","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\nι' : Type u_5\ninst✝² : ConditionallyCompleteLinearOrder α\nv : Filter ι\np : ι' → Prop\ns : ι' → Set ι\ninst✝¹ : Countable (Subtype p)\ninst✝ : Nonempty (Subtype p)\nhv : v.HasBasis p s\nf : ι → α\n⊢ Eq (Filter.liminf f v) (ite (Exists fun j => Eq (s ↑j) EmptyCollection.emptyCollection) (SupSet.sSup Set.univ) (ite (∀ (j : Subtype p), Not (BddBelow (Set.range fun i => f ↑i))) (SupSet.sSup EmptyCollection.emptyCollection) (iSup fun j => iInf fun i => f ↑i)))","decl":"open Classical in\n/-- Writing a liminf as a supremum of infimum, in a (possibly non-complete) conditionally complete\nlinear order. A reparametrization trick is needed to avoid taking the infimum of sets which are\nnot bounded below. -/\ntheorem HasBasis.liminf_eq_ite {v : Filter ι} {p : ι' → Prop} {s : ι' → Set ι}\n    [Countable (Subtype p)] [Nonempty (Subtype p)] (hv : v.HasBasis p s) (f : ι → α) :\n    liminf f v = if ∃ (j : Subtype p), s j = ∅ then sSup univ else\n      if ∀ (j : Subtype p), ¬BddBelow (range (fun (i : s j) ↦ f i)) then sSup ∅\n      else ⨆ (j : Subtype p), ⨅ (i : s (liminf_reparam f s p j)), f i := by\n  by_cases H : ∃ (j : Subtype p), s j = ∅\n  · rw [if_pos H]\n    rcases H with ⟨j, hj⟩\n    simp [hv.liminf_eq_sSup_univ_of_empty j j.2 hj]\n  rw [if_neg H]\n  by_cases H' : ∀ (j : Subtype p), ¬BddBelow (range (fun (i : s j) ↦ f i))\n  · have A : ∀ (j : Subtype p), ⋂ (i : s j), Iic (f i) = ∅ := by\n      simp_rw [← not_nonempty_iff_eq_empty, nonempty_iInter_Iic_iff]\n      exact H'\n    simp_rw [if_pos H', hv.liminf_eq_sSup_iUnion_iInter, A, iUnion_empty]\n  rw [if_neg H']\n  apply hv.liminf_eq_ciSup_ciInf\n  · push_neg at H\n    simpa only [nonempty_iff_ne_empty] using H\n  · push_neg at H'\n    exact H'\n\n"}
{"name":"Filter.HasBasis.limsup_eq_ciInf_ciSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\nι' : Type u_5\ninst✝² : ConditionallyCompleteLinearOrder α\nv : Filter ι\np : ι' → Prop\ns : ι' → Set ι\ninst✝¹ : Countable (Subtype p)\ninst✝ : Nonempty (Subtype p)\nhv : v.HasBasis p s\nf : ι → α\nhs : ∀ (j : Subtype p), (s ↑j).Nonempty\nH : Exists fun j => BddAbove (Set.range fun i => f ↑i)\n⊢ Eq (Filter.limsup f v) (iInf fun j => iSup fun i => f ↑i)","decl":"/-- Writing a limsup as an infimum of supremum, in a (possibly non-complete) conditionally complete\nlinear order. A reparametrization trick is needed to avoid taking the supremum of sets which are\nnot bounded above. -/\ntheorem HasBasis.limsup_eq_ciInf_ciSup {v : Filter ι}\n    {p : ι' → Prop} {s : ι' → Set ι} [Countable (Subtype p)] [Nonempty (Subtype p)]\n    (hv : v.HasBasis p s) {f : ι → α} (hs : ∀ (j : Subtype p), (s j).Nonempty)\n    (H : ∃ (j : Subtype p), BddAbove (range (fun (i : s j) ↦ f i))) :\n    limsup f v = ⨅ (j : Subtype p), ⨆ (i : s (limsup_reparam f s p j)), f i :=\n  HasBasis.liminf_eq_ciSup_ciInf (α := αᵒᵈ) hv hs H\n\n"}
{"name":"Filter.HasBasis.limsup_eq_ite","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nι : Type u_4\nι' : Type u_5\ninst✝² : ConditionallyCompleteLinearOrder α\nv : Filter ι\np : ι' → Prop\ns : ι' → Set ι\ninst✝¹ : Countable (Subtype p)\ninst✝ : Nonempty (Subtype p)\nhv : v.HasBasis p s\nf : ι → α\n⊢ Eq (Filter.limsup f v) (ite (Exists fun j => Eq (s ↑j) EmptyCollection.emptyCollection) (InfSet.sInf Set.univ) (ite (∀ (j : Subtype p), Not (BddAbove (Set.range fun i => f ↑i))) (InfSet.sInf EmptyCollection.emptyCollection) (iInf fun j => iSup fun i => f ↑i)))","decl":"open Classical in\n/-- Writing a limsup as an infimum of supremum, in a (possibly non-complete) conditionally complete\nlinear order. A reparametrization trick is needed to avoid taking the supremum of sets which are\nnot bounded below. -/\ntheorem HasBasis.limsup_eq_ite {v : Filter ι} {p : ι' → Prop} {s : ι' → Set ι}\n    [Countable (Subtype p)] [Nonempty (Subtype p)] (hv : v.HasBasis p s) (f : ι → α) :\n    limsup f v = if ∃ (j : Subtype p), s j = ∅ then sInf univ else\n      if ∀ (j : Subtype p), ¬BddAbove (range (fun (i : s j) ↦ f i)) then sInf ∅\n      else ⨅ (j : Subtype p), ⨆ (i : s (limsup_reparam f s p j)), f i :=\n  HasBasis.liminf_eq_ite (α := αᵒᵈ) hv f\n\n"}
{"name":"Monotone.isBoundedUnder_le_comp_iff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : Nonempty β\ninst✝² : LinearOrder β\ninst✝¹ : Preorder γ\ninst✝ : NoMaxOrder γ\ng : β → γ\nf : α → β\nl : Filter α\nhg : Monotone g\nhg' : Filter.Tendsto g Filter.atTop Filter.atTop\n⊢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp g f)) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l f)","decl":"theorem Monotone.isBoundedUnder_le_comp_iff [Nonempty β] [LinearOrder β] [Preorder γ] [NoMaxOrder γ]\n    {g : β → γ} {f : α → β} {l : Filter α} (hg : Monotone g) (hg' : Tendsto g atTop atTop) :\n    IsBoundedUnder (· ≤ ·) l (g ∘ f) ↔ IsBoundedUnder (· ≤ ·) l f := by\n  refine ⟨?_, fun h => h.isBoundedUnder (α := β) hg⟩\n  rintro ⟨c, hc⟩; rw [eventually_map] at hc\n  obtain ⟨b, hb⟩ : ∃ b, ∀ a ≥ b, c < g a := eventually_atTop.1 (hg'.eventually_gt_atTop c)\n  exact ⟨b, hc.mono fun x hx => not_lt.1 fun h => (hb _ h.le).not_le hx⟩\n\n"}
{"name":"Monotone.isBoundedUnder_ge_comp_iff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : Nonempty β\ninst✝² : LinearOrder β\ninst✝¹ : Preorder γ\ninst✝ : NoMinOrder γ\ng : β → γ\nf : α → β\nl : Filter α\nhg : Monotone g\nhg' : Filter.Tendsto g Filter.atBot Filter.atBot\n⊢ Iff (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l (Function.comp g f)) (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l f)","decl":"theorem Monotone.isBoundedUnder_ge_comp_iff [Nonempty β] [LinearOrder β] [Preorder γ] [NoMinOrder γ]\n    {g : β → γ} {f : α → β} {l : Filter α} (hg : Monotone g) (hg' : Tendsto g atBot atBot) :\n    IsBoundedUnder (· ≥ ·) l (g ∘ f) ↔ IsBoundedUnder (· ≥ ·) l f :=\n  hg.dual.isBoundedUnder_le_comp_iff hg'\n\n"}
{"name":"Antitone.isBoundedUnder_le_comp_iff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : Nonempty β\ninst✝² : LinearOrder β\ninst✝¹ : Preorder γ\ninst✝ : NoMaxOrder γ\ng : β → γ\nf : α → β\nl : Filter α\nhg : Antitone g\nhg' : Filter.Tendsto g Filter.atBot Filter.atTop\n⊢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp g f)) (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l f)","decl":"theorem Antitone.isBoundedUnder_le_comp_iff [Nonempty β] [LinearOrder β] [Preorder γ] [NoMaxOrder γ]\n    {g : β → γ} {f : α → β} {l : Filter α} (hg : Antitone g) (hg' : Tendsto g atBot atTop) :\n    IsBoundedUnder (· ≤ ·) l (g ∘ f) ↔ IsBoundedUnder (· ≥ ·) l f :=\n  hg.dual_right.isBoundedUnder_ge_comp_iff hg'\n\n"}
{"name":"Antitone.isBoundedUnder_ge_comp_iff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : Nonempty β\ninst✝² : LinearOrder β\ninst✝¹ : Preorder γ\ninst✝ : NoMinOrder γ\ng : β → γ\nf : α → β\nl : Filter α\nhg : Antitone g\nhg' : Filter.Tendsto g Filter.atTop Filter.atBot\n⊢ Iff (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l (Function.comp g f)) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l f)","decl":"theorem Antitone.isBoundedUnder_ge_comp_iff [Nonempty β] [LinearOrder β] [Preorder γ] [NoMinOrder γ]\n    {g : β → γ} {f : α → β} {l : Filter α} (hg : Antitone g) (hg' : Tendsto g atTop atBot) :\n    IsBoundedUnder (· ≥ ·) l (g ∘ f) ↔ IsBoundedUnder (· ≤ ·) l f :=\n  hg.dual_right.isBoundedUnder_le_comp_iff hg'\n\n"}
{"name":"GaloisConnection.l_limsup_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : ConditionallyCompleteLattice β\ninst✝ : ConditionallyCompleteLattice γ\nf : Filter α\nv : α → β\nl : β → γ\nu : γ → β\ngc : GaloisConnection l u\nhlv : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f fun x => l (v x)) _auto✝\nhv_co : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f v) _auto✝\n⊢ LE.le (l (Filter.limsup v f)) (Filter.limsup (fun x => l (v x)) f)","decl":"theorem GaloisConnection.l_limsup_le [ConditionallyCompleteLattice β]\n    [ConditionallyCompleteLattice γ] {f : Filter α} {v : α → β} {l : β → γ} {u : γ → β}\n    (gc : GaloisConnection l u)\n    (hlv : f.IsBoundedUnder (· ≤ ·) fun x => l (v x) := by isBoundedDefault)\n    (hv_co : f.IsCoboundedUnder (· ≤ ·) v := by isBoundedDefault) :\n    l (limsup v f) ≤ limsup (fun x => l (v x)) f := by\n  refine le_limsSup_of_le hlv fun c hc => ?_\n  rw [Filter.eventually_map] at hc\n  simp_rw [gc _ _] at hc ⊢\n  exact limsSup_le_of_le hv_co hc\n\n"}
{"name":"OrderIso.limsup_apply","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_6\ninst✝¹ : ConditionallyCompleteLattice β\ninst✝ : ConditionallyCompleteLattice γ\nf : Filter α\nu : α → β\ng : OrderIso β γ\nhu : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\nhu_co : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\nhgu : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f fun x => g (u x)) _auto✝\nhgu_co : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f fun x => g (u x)) _auto✝\n⊢ Eq (g (Filter.limsup u f)) (Filter.limsup (fun x => g (u x)) f)","decl":"theorem OrderIso.limsup_apply {γ} [ConditionallyCompleteLattice β] [ConditionallyCompleteLattice γ]\n    {f : Filter α} {u : α → β} (g : β ≃o γ)\n    (hu : f.IsBoundedUnder (· ≤ ·) u := by isBoundedDefault)\n    (hu_co : f.IsCoboundedUnder (· ≤ ·) u := by isBoundedDefault)\n    (hgu : f.IsBoundedUnder (· ≤ ·) fun x => g (u x) := by isBoundedDefault)\n    (hgu_co : f.IsCoboundedUnder (· ≤ ·) fun x => g (u x) := by isBoundedDefault) :\n    g (limsup u f) = limsup (fun x => g (u x)) f := by\n  refine le_antisymm ((OrderIso.to_galoisConnection g).l_limsup_le hgu hu_co) ?_\n  rw [← g.symm.symm_apply_apply <| limsup (fun x => g (u x)) f, g.symm_symm]\n  refine g.monotone ?_\n  have hf : u = fun i => g.symm (g (u i)) := funext fun i => (g.symm_apply_apply (u i)).symm\n  -- Porting note: nth_rw 1 to nth_rw 2\n  nth_rw 2 [hf]\n  refine (OrderIso.to_galoisConnection g.symm).l_limsup_le ?_ hgu_co\n  simp_rw [g.symm_apply_apply]\n  exact hu\n\n"}
{"name":"OrderIso.liminf_apply","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_6\ninst✝¹ : ConditionallyCompleteLattice β\ninst✝ : ConditionallyCompleteLattice γ\nf : Filter α\nu : α → β\ng : OrderIso β γ\nhu : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\nhu_co : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\nhgu : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f fun x => g (u x)) _auto✝\nhgu_co : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f fun x => g (u x)) _auto✝\n⊢ Eq (g (Filter.liminf u f)) (Filter.liminf (fun x => g (u x)) f)","decl":"theorem OrderIso.liminf_apply {γ} [ConditionallyCompleteLattice β] [ConditionallyCompleteLattice γ]\n    {f : Filter α} {u : α → β} (g : β ≃o γ)\n    (hu : f.IsBoundedUnder (· ≥ ·) u := by isBoundedDefault)\n    (hu_co : f.IsCoboundedUnder (· ≥ ·) u := by isBoundedDefault)\n    (hgu : f.IsBoundedUnder (· ≥ ·) fun x => g (u x) := by isBoundedDefault)\n    (hgu_co : f.IsCoboundedUnder (· ≥ ·) fun x => g (u x) := by isBoundedDefault) :\n    g (liminf u f) = liminf (fun x => g (u x)) f :=\n  OrderIso.limsup_apply (β := βᵒᵈ) (γ := γᵒᵈ) g.dual hu hu_co hgu hgu_co\n\n"}
{"name":"isCoboundedUnder_le_max","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : LinearOrder β\nf : Filter α\nu v : α → β\nh : Or (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u) (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f v)\n⊢ Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f fun a => Max.max (u a) (v a)","decl":"theorem isCoboundedUnder_le_max [LinearOrder β] {f : Filter α} {u v : α → β}\n    (h : f.IsCoboundedUnder (· ≤ ·) u ∨ f.IsCoboundedUnder (· ≤ ·) v) :\n    f.IsCoboundedUnder (· ≤ ·) (fun a ↦ max (u a) (v a)) := by\n  rcases h with (h' | h') <;>\n  · rcases h' with ⟨b, hb⟩\n    use b\n    intro c hc\n    apply hb c\n    rw [eventually_map] at hc ⊢\n    refine hc.mono (fun _ ↦ ?_)\n    simp +contextual only [implies_true, max_le_iff, and_imp]\n\n"}
{"name":"limsup_max","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder β\nf : Filter α\nu v : α → β\nh₁ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\nh₂ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f v) _auto✝\nh₃ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto✝\nh₄ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f v) _auto✝\n⊢ Eq (Filter.limsup (fun a => Max.max (u a) (v a)) f) (Max.max (Filter.limsup u f) (Filter.limsup v f))","decl":"theorem limsup_max [ConditionallyCompleteLinearOrder β] {f : Filter α} {u v : α → β}\n    (h₁ : f.IsCoboundedUnder (· ≤ ·) u := by isBoundedDefault)\n    (h₂ : f.IsCoboundedUnder (· ≤ ·) v := by isBoundedDefault)\n    (h₃ : f.IsBoundedUnder (· ≤ ·) u := by isBoundedDefault)\n    (h₄ : f.IsBoundedUnder (· ≤ ·) v := by isBoundedDefault) :\n    limsup (fun a ↦ max (u a) (v a)) f = max (limsup u f) (limsup v f) := by\n  have bddmax := IsBoundedUnder.sup h₃ h₄\n  have cobddmax := isCoboundedUnder_le_max (v := v) (Or.inl h₁)\n  apply le_antisymm\n  · refine (limsup_le_iff cobddmax bddmax).2 (fun b hb ↦ ?_)\n    have hu := eventually_lt_of_limsup_lt (lt_of_le_of_lt (le_max_left _ _) hb) h₃\n    have hv := eventually_lt_of_limsup_lt (lt_of_le_of_lt (le_max_right _ _) hb) h₄\n    refine mem_of_superset (inter_mem hu hv) (fun _ ↦ by simp)\n  · exact max_le (c := limsup (fun a ↦ max (u a) (v a)) f)\n      (limsup_le_limsup (Eventually.of_forall (fun a : α ↦ le_max_left (u a) (v a))) h₁ bddmax)\n      (limsup_le_limsup (Eventually.of_forall (fun a : α ↦ le_max_right (u a) (v a))) h₂ bddmax)\n\n"}
{"name":"liminf_min","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : ConditionallyCompleteLinearOrder β\nf : Filter α\nu v : α → β\nh₁ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\nh₂ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f v) _auto✝\nh₃ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto✝\nh₄ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f v) _auto✝\n⊢ Eq (Filter.liminf (fun a => Min.min (u a) (v a)) f) (Min.min (Filter.liminf u f) (Filter.liminf v f))","decl":"theorem liminf_min [ConditionallyCompleteLinearOrder β] {f : Filter α} {u v : α → β}\n    (h₁ : f.IsCoboundedUnder (· ≥ ·) u := by isBoundedDefault)\n    (h₂ : f.IsCoboundedUnder (· ≥ ·) v := by isBoundedDefault)\n    (h₃ : f.IsBoundedUnder (· ≥ ·) u := by isBoundedDefault)\n    (h₄ : f.IsBoundedUnder (· ≥ ·) v := by isBoundedDefault) :\n    liminf (fun a ↦ min (u a) (v a)) f = min (liminf u f) (liminf v f) :=\n  limsup_max (β := βᵒᵈ) h₁ h₂ h₃ h₄\n\n"}
{"name":"isBoundedUnder_le_finset_sup'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\ninst✝¹ : LinearOrder β\ninst✝ : Nonempty β\nf : Filter α\nF : ι → α → β\ns : Finset ι\nhs : s.Nonempty\nh : ∀ (i : ι), Membership.mem s i → Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f (F i)\n⊢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f fun a => s.sup' hs fun i => F i a","decl":"theorem isBoundedUnder_le_finset_sup' [LinearOrder β] [Nonempty β] {f : Filter α} {F : ι → α → β}\n    {s : Finset ι} (hs : s.Nonempty) (h : ∀ i ∈ s, f.IsBoundedUnder (· ≤ ·) (F i)) :\n    f.IsBoundedUnder (· ≤ ·) (fun a ↦ sup' s hs (fun i ↦ F i a)) := by\n  choose! m hm using h\n  use sup' s hs m\n  simp only [eventually_map] at hm ⊢\n  rw [← eventually_all_finset s] at hm\n  refine hm.mono fun a h ↦ ?_\n  simp only [Finset.sup'_apply, sup'_le_iff]\n  exact fun i i_s ↦ le_trans (h i i_s) (le_sup' m i_s)\n\n"}
{"name":"isCoboundedUnder_le_finset_sup'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\ninst✝ : LinearOrder β\nf : Filter α\nF : ι → α → β\ns : Finset ι\nhs : s.Nonempty\nh : Exists fun i => And (Membership.mem s i) (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f (F i))\n⊢ Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f fun a => s.sup' hs fun i => F i a","decl":"theorem isCoboundedUnder_le_finset_sup' [LinearOrder β] {f : Filter α} {F : ι → α → β}\n    {s : Finset ι} (hs : s.Nonempty) (h : ∃ i ∈ s, f.IsCoboundedUnder (· ≤ ·) (F i)) :\n    f.IsCoboundedUnder (· ≤ ·) (fun a ↦ sup' s hs (fun i ↦ F i a)) := by\n  rcases h with ⟨i, i_s, b, hb⟩\n  use b\n  refine fun c hc ↦ hb c ?_\n  rw [eventually_map] at hc ⊢\n  refine hc.mono fun a h ↦ ?_\n  simp only [Finset.sup'_apply, sup'_le_iff] at h ⊢\n  exact h i i_s\n\n"}
{"name":"isBoundedUnder_le_finset_sup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\ninst✝¹ : LinearOrder β\ninst✝ : OrderBot β\nf : Filter α\nF : ι → α → β\ns : Finset ι\nh : ∀ (i : ι), Membership.mem s i → Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f (F i)\n⊢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f fun a => s.sup fun i => F i a","decl":"theorem isBoundedUnder_le_finset_sup [LinearOrder β] [OrderBot β] {f : Filter α} {F : ι → α → β}\n    {s : Finset ι} (h : ∀ i ∈ s, f.IsBoundedUnder (· ≤ ·) (F i)) :\n    f.IsBoundedUnder (· ≤ ·) (fun a ↦ sup s (fun i ↦ F i a)) := by\n  choose! m hm using h\n  use sup s m\n  simp only [eventually_map] at hm ⊢\n  rw [← eventually_all_finset s] at hm\n  exact hm.mono fun _ h ↦ sup_mono_fun h\n\n"}
{"name":"isBoundedUnder_ge_finset_inf'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\ninst✝¹ : LinearOrder β\ninst✝ : Nonempty β\nf : Filter α\nF : ι → α → β\ns : Finset ι\nhs : s.Nonempty\nh : ∀ (i : ι), Membership.mem s i → Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f (F i)\n⊢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f fun a => s.inf' hs fun i => F i a","decl":"theorem isBoundedUnder_ge_finset_inf' [LinearOrder β] [Nonempty β] {f : Filter α} {F : ι → α → β}\n    {s : Finset ι} (hs : s.Nonempty) (h : ∀ i ∈ s, f.IsBoundedUnder (· ≥ ·) (F i)) :\n    f.IsBoundedUnder (· ≥ ·) (fun a ↦ inf' s hs (fun i ↦ F i a)) :=\n  isBoundedUnder_le_finset_sup' (β := βᵒᵈ) hs h\n\n"}
{"name":"isCoboundedUnder_ge_finset_inf'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\ninst✝ : LinearOrder β\nf : Filter α\nF : ι → α → β\ns : Finset ι\nhs : s.Nonempty\nh : Exists fun i => And (Membership.mem s i) (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f (F i))\n⊢ Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f fun a => s.inf' hs fun i => F i a","decl":"theorem isCoboundedUnder_ge_finset_inf' [LinearOrder β] {f : Filter α} {F : ι → α → β}\n    {s : Finset ι} (hs : s.Nonempty) (h : ∃ i ∈ s, f.IsCoboundedUnder (· ≥ ·) (F i)) :\n    f.IsCoboundedUnder (· ≥ ·) (fun a ↦ inf' s hs (fun i ↦ F i a)) :=\n  isCoboundedUnder_le_finset_sup' (β := βᵒᵈ) hs h\n\n"}
{"name":"isBoundedUnder_ge_finset_inf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\ninst✝¹ : LinearOrder β\ninst✝ : OrderTop β\nf : Filter α\nF : ι → α → β\ns : Finset ι\nh : ∀ (i : ι), Membership.mem s i → Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f (F i)\n⊢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f fun a => s.inf fun i => F i a","decl":"theorem isBoundedUnder_ge_finset_inf [LinearOrder β] [OrderTop β] {f : Filter α} {F : ι → α → β}\n    {s : Finset ι} (h : ∀ i ∈ s, f.IsBoundedUnder (· ≥ ·) (F i)) :\n    f.IsBoundedUnder (· ≥ ·) (fun a ↦ inf s (fun i ↦ F i a)) :=\n  isBoundedUnder_le_finset_sup (β := βᵒᵈ) h\n\n"}
{"name":"limsup_finset_sup'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\ninst✝ : ConditionallyCompleteLinearOrder β\nf : Filter α\nF : ι → α → β\ns : Finset ι\nhs : s.Nonempty\nh₁ : autoParam (∀ (i : ι), Membership.mem s i → Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f (F i)) _auto✝\nh₂ : autoParam (∀ (i : ι), Membership.mem s i → Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f (F i)) _auto✝\n⊢ Eq (Filter.limsup (fun a => s.sup' hs fun i => F i a) f) (s.sup' hs fun i => Filter.limsup (F i) f)","decl":"theorem limsup_finset_sup' [ConditionallyCompleteLinearOrder β] {f : Filter α}\n    {F : ι → α → β} {s : Finset ι} (hs : s.Nonempty)\n    (h₁ : ∀ i ∈ s, f.IsCoboundedUnder (· ≤ ·) (F i) := by exact fun _ _ ↦ by isBoundedDefault)\n    (h₂ : ∀ i ∈ s, f.IsBoundedUnder (· ≤ ·) (F i) := by exact fun _ _ ↦ by isBoundedDefault) :\n    limsup (fun a ↦ sup' s hs (fun i ↦ F i a)) f = sup' s hs (fun i ↦ limsup (F i) f) := by\n  have bddsup := isBoundedUnder_le_finset_sup' hs h₂\n  apply le_antisymm\n  · have h₃ : ∃ i ∈ s, f.IsCoboundedUnder (· ≤ ·) (F i) := by\n      rcases hs with ⟨i, i_s⟩\n      use i, i_s\n      exact h₁ i i_s\n    have cobddsup := isCoboundedUnder_le_finset_sup' hs h₃\n    refine (limsup_le_iff cobddsup bddsup).2 (fun b hb ↦ ?_)\n    rw [eventually_iff_exists_mem]\n    use ⋂ i ∈ s, {a | F i a < b}\n    split_ands\n    · rw [biInter_finset_mem]\n      suffices key : ∀ i ∈ s, ∀ᶠ a in f, F i a < b from fun i i_s ↦ eventually_iff.1 (key i i_s)\n      intro i i_s\n      apply eventually_lt_of_limsup_lt _ (h₂ i i_s)\n      exact lt_of_le_of_lt (Finset.le_sup' (f := fun i ↦ limsup (F i) f) i_s) hb\n    · simp only [mem_iInter, mem_setOf_eq, Finset.sup'_apply, sup'_lt_iff, imp_self, implies_true]\n  · apply Finset.sup'_le hs (fun i ↦ limsup (F i) f)\n    refine fun i i_s ↦ limsup_le_limsup (Eventually.of_forall (fun a ↦ ?_)) (h₁ i i_s) bddsup\n    simp only [Finset.sup'_apply, le_sup'_iff]\n    use i, i_s\n\n"}
{"name":"limsup_finset_sup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\ninst✝¹ : ConditionallyCompleteLinearOrder β\ninst✝ : OrderBot β\nf : Filter α\nF : ι → α → β\ns : Finset ι\nh₁ : autoParam (∀ (i : ι), Membership.mem s i → Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f (F i)) _auto✝\nh₂ : autoParam (∀ (i : ι), Membership.mem s i → Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f (F i)) _auto✝\n⊢ Eq (Filter.limsup (fun a => s.sup fun i => F i a) f) (s.sup fun i => Filter.limsup (F i) f)","decl":"theorem limsup_finset_sup [ConditionallyCompleteLinearOrder β] [OrderBot β] {f : Filter α}\n    {F : ι → α → β} {s : Finset ι}\n    (h₁ : ∀ i ∈ s, f.IsCoboundedUnder (· ≤ ·) (F i) := by exact fun _ _ ↦ by isBoundedDefault)\n    (h₂ : ∀ i ∈ s, f.IsBoundedUnder (· ≤ ·) (F i) := by exact fun _ _ ↦ by isBoundedDefault) :\n    limsup (fun a ↦ sup s (fun i ↦ F i a)) f = sup s (fun i ↦ limsup (F i) f) := by\n  rcases eq_or_neBot f with (rfl | _)\n  · simp [limsup_eq, csInf_univ]\n  rcases Finset.eq_empty_or_nonempty s with (rfl | s_nemp)\n  · simp only [Finset.sup_apply, sup_empty, limsup_const]\n  rw [← Finset.sup'_eq_sup s_nemp fun i ↦ limsup (F i) f, ← limsup_finset_sup' s_nemp h₁ h₂]\n  congr\n  ext a\n  exact Eq.symm (Finset.sup'_eq_sup s_nemp (fun i ↦ F i a))\n\n"}
{"name":"liminf_finset_inf'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\ninst✝ : ConditionallyCompleteLinearOrder β\nf : Filter α\nF : ι → α → β\ns : Finset ι\nhs : s.Nonempty\nh₁ : autoParam (∀ (i : ι), Membership.mem s i → Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f (F i)) _auto✝\nh₂ : autoParam (∀ (i : ι), Membership.mem s i → Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f (F i)) _auto✝\n⊢ Eq (Filter.liminf (fun a => s.inf' hs fun i => F i a) f) (s.inf' hs fun i => Filter.liminf (F i) f)","decl":"theorem liminf_finset_inf' [ConditionallyCompleteLinearOrder β] {f : Filter α}\n    {F : ι → α → β} {s : Finset ι} (hs : s.Nonempty)\n    (h₁ : ∀ i ∈ s, f.IsCoboundedUnder (· ≥ ·) (F i) := by exact fun _ _ ↦ by isBoundedDefault)\n    (h₂ : ∀ i ∈ s, f.IsBoundedUnder (· ≥ ·) (F i) := by exact fun _ _ ↦ by isBoundedDefault) :\n    liminf (fun a ↦ inf' s hs (fun i ↦ F i a)) f = inf' s hs (fun i ↦ liminf (F i) f) :=\n  limsup_finset_sup' (β := βᵒᵈ) hs h₁ h₂\n\n"}
{"name":"liminf_finset_inf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_4\ninst✝¹ : ConditionallyCompleteLinearOrder β\ninst✝ : OrderTop β\nf : Filter α\nF : ι → α → β\ns : Finset ι\nh₁ : autoParam (∀ (i : ι), Membership.mem s i → Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f (F i)) _auto✝\nh₂ : autoParam (∀ (i : ι), Membership.mem s i → Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f (F i)) _auto✝\n⊢ Eq (Filter.liminf (fun a => s.inf fun i => F i a) f) (s.inf fun i => Filter.liminf (F i) f)","decl":"theorem liminf_finset_inf [ConditionallyCompleteLinearOrder β] [OrderTop β] {f : Filter α}\n    {F : ι → α → β} {s : Finset ι}\n    (h₁ : ∀ i ∈ s, f.IsCoboundedUnder (· ≥ ·) (F i) := by exact fun _ _ ↦ by isBoundedDefault)\n    (h₂ : ∀ i ∈ s, f.IsBoundedUnder (· ≥ ·) (F i) := by exact fun _ _ ↦ by isBoundedDefault) :\n    liminf (fun a ↦ inf s (fun i ↦ F i a)) f = inf s (fun i ↦ liminf (F i) f) :=\n  limsup_finset_sup (β := βᵒᵈ) h₁ h₂\n\n"}
{"name":"Monotone.frequently_ge_map_of_frequently_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"R : Type u_6\nS : Type u_7\nF : Filter R\ninst✝¹ : LinearOrder R\ninst✝ : LinearOrder S\nf : R → S\nf_incr : Monotone f\nl : R\nfreq_ge : Filter.Frequently (fun x => LE.le l x) F\n⊢ Filter.Frequently (fun x' => LE.le (f l) x') (Filter.map f F)","decl":"lemma Monotone.frequently_ge_map_of_frequently_ge {f : R → S} (f_incr : Monotone f)\n    {l : R} (freq_ge : ∃ᶠ x in F, l ≤ x) :\n    ∃ᶠ x' in F.map f, f l ≤ x' := by\n  refine fun ev ↦ freq_ge ?_\n  simp only [not_le, not_lt] at ev freq_ge ⊢\n  filter_upwards [ev] with z hz\n  by_contra con\n  exact lt_irrefl (f l) <| lt_of_le_of_lt (f_incr <| not_lt.mp con) hz\n\n"}
{"name":"Monotone.frequently_le_map_of_frequently_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"R : Type u_6\nS : Type u_7\nF : Filter R\ninst✝¹ : LinearOrder R\ninst✝ : LinearOrder S\nf : R → S\nf_incr : Monotone f\nu : R\nfreq_le : Filter.Frequently (fun x => LE.le x u) F\n⊢ Filter.Frequently (fun y => LE.le y (f u)) (Filter.map f F)","decl":"lemma Monotone.frequently_le_map_of_frequently_le {f : R → S} (f_incr : Monotone f)\n    {u : R} (freq_le : ∃ᶠ x in F, x ≤ u) :\n    ∃ᶠ y in F.map f, y ≤ f u := by\n  refine fun ev ↦ freq_le ?_\n  simp only [not_le, not_lt] at ev freq_le ⊢\n  filter_upwards [ev] with z hz\n  by_contra con\n  apply lt_irrefl (f u) <| lt_of_lt_of_le hz <| f_incr (not_lt.mp con)\n\n"}
{"name":"Antitone.frequently_le_map_of_frequently_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"R : Type u_6\nS : Type u_7\nF : Filter R\ninst✝¹ : LinearOrder R\ninst✝ : LinearOrder S\nf : R → S\nf_decr : Antitone f\nl : R\nfrbdd : Filter.Frequently (fun x => LE.le l x) F\n⊢ Filter.Frequently (fun y => LE.le y (f l)) (Filter.map f F)","decl":"lemma Antitone.frequently_le_map_of_frequently_ge {f : R → S} (f_decr : Antitone f)\n    {l : R} (frbdd : ∃ᶠ x in F, l ≤ x) :\n    ∃ᶠ y in F.map f, y ≤ f l :=\n  Monotone.frequently_ge_map_of_frequently_ge (S := Sᵒᵈ) f_decr frbdd\n\n"}
{"name":"Antitone.frequently_ge_map_of_frequently_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"R : Type u_6\nS : Type u_7\nF : Filter R\ninst✝¹ : LinearOrder R\ninst✝ : LinearOrder S\nf : R → S\nf_decr : Antitone f\nu : R\nfrbdd : Filter.Frequently (fun x => LE.le x u) F\n⊢ Filter.Frequently (fun y => LE.le (f u) y) (Filter.map f F)","decl":"lemma Antitone.frequently_ge_map_of_frequently_le {f : R → S} (f_decr : Antitone f)\n    {u : R} (frbdd : ∃ᶠ x in F, x ≤ u) :\n    ∃ᶠ y in F.map f, f u ≤ y :=\n  Monotone.frequently_le_map_of_frequently_le (S := Sᵒᵈ) f_decr frbdd\n\n"}
{"name":"Monotone.isCoboundedUnder_le_of_isCobounded","module":"Mathlib.Order.LiminfLimsup","initialProofState":"R : Type u_6\nS : Type u_7\nF : Filter R\ninst✝² : LinearOrder R\ninst✝¹ : LinearOrder S\nf : R → S\nf_incr : Monotone f\ninst✝ : F.NeBot\ncobdd : Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) F\n⊢ Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) F f","decl":"lemma Monotone.isCoboundedUnder_le_of_isCobounded {f : R → S} (f_incr : Monotone f)\n    [NeBot F] (cobdd : IsCobounded (· ≤ ·) F) :\n    F.IsCoboundedUnder (· ≤ ·) f := by\n  obtain ⟨l, hl⟩ := IsCobounded.frequently_ge cobdd\n  exact IsCobounded.of_frequently_ge <| f_incr.frequently_ge_map_of_frequently_ge hl\n\n"}
{"name":"Monotone.isCoboundedUnder_ge_of_isCobounded","module":"Mathlib.Order.LiminfLimsup","initialProofState":"R : Type u_6\nS : Type u_7\nF : Filter R\ninst✝² : LinearOrder R\ninst✝¹ : LinearOrder S\nf : R → S\nf_incr : Monotone f\ninst✝ : F.NeBot\ncobdd : Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) F\n⊢ Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) F f","decl":"lemma Monotone.isCoboundedUnder_ge_of_isCobounded {f : R → S} (f_incr : Monotone f)\n    [NeBot F] (cobdd : IsCobounded (· ≥ ·) F) :\n    F.IsCoboundedUnder (· ≥ ·) f :=\n  Monotone.isCoboundedUnder_le_of_isCobounded (R := Rᵒᵈ) (S := Sᵒᵈ) f_incr.dual cobdd\n\n"}
{"name":"Antitone.isCoboundedUnder_le_of_isCobounded","module":"Mathlib.Order.LiminfLimsup","initialProofState":"R : Type u_6\nS : Type u_7\nF : Filter R\ninst✝² : LinearOrder R\ninst✝¹ : LinearOrder S\nf : R → S\nf_decr : Antitone f\ninst✝ : F.NeBot\ncobdd : Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) F\n⊢ Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) F f","decl":"lemma Antitone.isCoboundedUnder_le_of_isCobounded {f : R → S} (f_decr : Antitone f)\n    [NeBot F] (cobdd : IsCobounded (· ≥ ·) F) :\n    F.IsCoboundedUnder (· ≤ ·) f :=\n  Monotone.isCoboundedUnder_le_of_isCobounded (R := Rᵒᵈ) f_decr.dual cobdd\n\n"}
{"name":"Antitone.isCoboundedUnder_ge_of_isCobounded","module":"Mathlib.Order.LiminfLimsup","initialProofState":"R : Type u_6\nS : Type u_7\nF : Filter R\ninst✝² : LinearOrder R\ninst✝¹ : LinearOrder S\nf : R → S\nf_decr : Antitone f\ninst✝ : F.NeBot\ncobdd : Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) F\n⊢ Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) F f","decl":"lemma Antitone.isCoboundedUnder_ge_of_isCobounded {f : R → S} (f_decr : Antitone f)\n    [NeBot F] (cobdd : IsCobounded (· ≤ ·) F) :\n    F.IsCoboundedUnder (· ≥ ·) f :=\n  Monotone.isCoboundedUnder_le_of_isCobounded (S := Sᵒᵈ) f_decr cobdd\n\n"}
