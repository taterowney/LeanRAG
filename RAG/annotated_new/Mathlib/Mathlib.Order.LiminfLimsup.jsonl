{"name":"Filter.isBounded_iff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nr : Œ± ‚Üí Œ± ‚Üí Prop\nf : Filter Œ±\n‚ä¢ Iff (Filter.IsBounded r f) (Exists fun s => And (Membership.mem f.sets s) (Exists fun b => HasSubset.Subset s (setOf fun x => r x b)))","decl":"/-- `f` is eventually bounded if and only if, there exists an admissible set on which it is\nbounded. -/\ntheorem isBounded_iff : f.IsBounded r ‚Üî ‚àÉ s ‚àà f.sets, ‚àÉ b, s ‚äÜ { x | r x b } :=\n  Iff.intro (fun ‚ü®b, hb‚ü© => ‚ü®{ a | r a b }, hb, b, Subset.refl _‚ü©) fun ‚ü®_, hs, b, hb‚ü© =>\n    ‚ü®b, mem_of_superset hs hb‚ü©\n\n"}
{"name":"Filter.isBoundedUnder_of","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nr : Œ± ‚Üí Œ± ‚Üí Prop\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\na‚úù : Exists fun b => ‚àÄ (x : Œ≤), r (u x) b\n‚ä¢ Filter.IsBoundedUnder r f u","decl":"/-- A bounded function `u` is in particular eventually bounded. -/\ntheorem isBoundedUnder_of {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} : (‚àÉ b, ‚àÄ x, r (u x) b) ‚Üí f.IsBoundedUnder r u\n  | ‚ü®b, hb‚ü© => ‚ü®b, show ‚àÄ·∂† x in f, r (u x) b from Eventually.of_forall hb‚ü©\n\n"}
{"name":"Filter.isBounded_bot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nr : Œ± ‚Üí Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.IsBounded r Bot.bot) (Nonempty Œ±)","decl":"theorem isBounded_bot : IsBounded r ‚ä• ‚Üî Nonempty Œ± := by simp [IsBounded, exists_true_iff_nonempty]\n\n"}
{"name":"Filter.isBounded_top","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nr : Œ± ‚Üí Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.IsBounded r Top.top) (Exists fun t => ‚àÄ (x : Œ±), r x t)","decl":"theorem isBounded_top : IsBounded r ‚ä§ ‚Üî ‚àÉ t, ‚àÄ x, r x t := by simp [IsBounded, eq_univ_iff_forall]\n\n"}
{"name":"Filter.isBounded_principal","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nr : Œ± ‚Üí Œ± ‚Üí Prop\ns : Set Œ±\n‚ä¢ Iff (Filter.IsBounded r (Filter.principal s)) (Exists fun t => ‚àÄ (x : Œ±), Membership.mem s x ‚Üí r x t)","decl":"theorem isBounded_principal (s : Set Œ±) : IsBounded r (ùìü s) ‚Üî ‚àÉ t, ‚àÄ x ‚àà s, r x t := by\n  simp [IsBounded, subset_def]\n\n"}
{"name":"Filter.isBounded_sup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nr : Œ± ‚Üí Œ± ‚Üí Prop\nf g : Filter Œ±\ninst‚úù¬π : IsTrans Œ± r\ninst‚úù : IsDirected Œ± r\na‚úù¬π : Filter.IsBounded r f\na‚úù : Filter.IsBounded r g\n‚ä¢ Filter.IsBounded r (Max.max f g)","decl":"theorem isBounded_sup [IsTrans Œ± r] [IsDirected Œ± r] :\n    IsBounded r f ‚Üí IsBounded r g ‚Üí IsBounded r (f ‚äî g)\n  | ‚ü®b‚ÇÅ, h‚ÇÅ‚ü©, ‚ü®b‚ÇÇ, h‚ÇÇ‚ü© =>\n    let ‚ü®b, rb‚ÇÅb, rb‚ÇÇb‚ü© := directed_of r b‚ÇÅ b‚ÇÇ\n    ‚ü®b, eventually_sup.mpr\n      ‚ü®h‚ÇÅ.mono fun _ h => _root_.trans h rb‚ÇÅb, h‚ÇÇ.mono fun _ h => _root_.trans h rb‚ÇÇb‚ü©‚ü©\n\n"}
{"name":"Filter.IsBounded.mono","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nr : Œ± ‚Üí Œ± ‚Üí Prop\nf g : Filter Œ±\nh : LE.le f g\na‚úù : Filter.IsBounded r g\n‚ä¢ Filter.IsBounded r f","decl":"theorem IsBounded.mono (h : f ‚â§ g) : IsBounded r g ‚Üí IsBounded r f\n  | ‚ü®b, hb‚ü© => ‚ü®b, h hb‚ü©\n\n"}
{"name":"Filter.IsBoundedUnder.mono","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nr : Œ± ‚Üí Œ± ‚Üí Prop\nf g : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\nh : LE.le f g\na‚úù : Filter.IsBoundedUnder r g u\n‚ä¢ Filter.IsBoundedUnder r f u","decl":"theorem IsBoundedUnder.mono {f g : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} (h : f ‚â§ g) :\n    g.IsBoundedUnder r u ‚Üí f.IsBoundedUnder r u := fun hg => IsBounded.mono (map_mono h) hg\n\n"}
{"name":"Filter.IsBoundedUnder.mono_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : Preorder Œ≤\nl : Filter Œ±\nu v : Œ± ‚Üí Œ≤\nhu : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l u\nhv : l.EventuallyLE v u\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l v","decl":"theorem IsBoundedUnder.mono_le [Preorder Œ≤] {l : Filter Œ±} {u v : Œ± ‚Üí Œ≤}\n    (hu : IsBoundedUnder (¬∑ ‚â§ ¬∑) l u) (hv : v ‚â§·∂†[l] u) : IsBoundedUnder (¬∑ ‚â§ ¬∑) l v := by\n  apply hu.imp\n  exact fun b hb => (eventually_map.1 hb).mp <| hv.mono fun x => le_trans\n\n"}
{"name":"Filter.IsBoundedUnder.mono_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : Preorder Œ≤\nl : Filter Œ±\nu v : Œ± ‚Üí Œ≤\nhu : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l u\nhv : l.EventuallyLE u v\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l v","decl":"theorem IsBoundedUnder.mono_ge [Preorder Œ≤] {l : Filter Œ±} {u v : Œ± ‚Üí Œ≤}\n    (hu : IsBoundedUnder (¬∑ ‚â• ¬∑) l u) (hv : u ‚â§·∂†[l] v) : IsBoundedUnder (¬∑ ‚â• ¬∑) l v :=\n  IsBoundedUnder.mono_le (Œ≤ := Œ≤·µí·µà) hu hv\n\n"}
{"name":"Filter.isBoundedUnder_const","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nr : Œ± ‚Üí Œ± ‚Üí Prop\ninst‚úù : IsRefl Œ± r\nl : Filter Œ≤\na : Œ±\n‚ä¢ Filter.IsBoundedUnder r l fun x => a","decl":"theorem isBoundedUnder_const [IsRefl Œ± r] {l : Filter Œ≤} {a : Œ±} : IsBoundedUnder r l fun _ => a :=\n  ‚ü®a, eventually_map.2 <| Eventually.of_forall fun _ => refl _‚ü©\n\n"}
{"name":"Filter.IsBounded.isBoundedUnder","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nr : Œ± ‚Üí Œ± ‚Üí Prop\nf : Filter Œ±\nq : Œ≤ ‚Üí Œ≤ ‚Üí Prop\nu : Œ± ‚Üí Œ≤\nhu : ‚àÄ (a‚ÇÄ a‚ÇÅ : Œ±), r a‚ÇÄ a‚ÇÅ ‚Üí q (u a‚ÇÄ) (u a‚ÇÅ)\na‚úù : Filter.IsBounded r f\n‚ä¢ Filter.IsBoundedUnder q f u","decl":"theorem IsBounded.isBoundedUnder {q : Œ≤ ‚Üí Œ≤ ‚Üí Prop} {u : Œ± ‚Üí Œ≤}\n    (hu : ‚àÄ a‚ÇÄ a‚ÇÅ, r a‚ÇÄ a‚ÇÅ ‚Üí q (u a‚ÇÄ) (u a‚ÇÅ)) : f.IsBounded r ‚Üí f.IsBoundedUnder q u\n  | ‚ü®b, h‚ü© => ‚ü®u b, show ‚àÄ·∂† x in f, q (u x) (u b) from h.mono fun x => hu x b‚ü©\n\n"}
{"name":"Filter.IsBoundedUnder.comp","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nr : Œ± ‚Üí Œ± ‚Üí Prop\nl : Filter Œ≥\nq : Œ≤ ‚Üí Œ≤ ‚Üí Prop\nu : Œ≥ ‚Üí Œ±\nv : Œ± ‚Üí Œ≤\nhv : ‚àÄ (a‚ÇÄ a‚ÇÅ : Œ±), r a‚ÇÄ a‚ÇÅ ‚Üí q (v a‚ÇÄ) (v a‚ÇÅ)\na‚úù : Filter.IsBoundedUnder r l u\n‚ä¢ Filter.IsBoundedUnder q l (Function.comp v u)","decl":"theorem IsBoundedUnder.comp {l : Filter Œ≥} {q : Œ≤ ‚Üí Œ≤ ‚Üí Prop} {u : Œ≥ ‚Üí Œ±} {v : Œ± ‚Üí Œ≤}\n    (hv : ‚àÄ a‚ÇÄ a‚ÇÅ, r a‚ÇÄ a‚ÇÅ ‚Üí q (v a‚ÇÄ) (v a‚ÇÅ)) : l.IsBoundedUnder r u ‚Üí l.IsBoundedUnder q (v ‚àò u)\n  | ‚ü®a, h‚ü© => ‚ü®v a, show ‚àÄ·∂† x in map u l, q (v x) (v a) from h.mono fun x => hv x a‚ü©\n\n"}
{"name":"Filter.IsBoundedUnder.eventually_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : Preorder Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\nh : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u\n‚ä¢ Exists fun a => Filter.Eventually (fun x => LE.le (u x) a) f","decl":"lemma IsBoundedUnder.eventually_le (h : IsBoundedUnder (¬∑ ‚â§ ¬∑) f u) :\n    ‚àÉ a, ‚àÄ·∂† x in f, u x ‚â§ a := by\n  obtain ‚ü®a, ha‚ü© := h\n  use a\n  exact eventually_map.1 ha\n\n"}
{"name":"Filter.IsBoundedUnder.eventually_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : Preorder Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\nh : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u\n‚ä¢ Exists fun a => Filter.Eventually (fun x => LE.le a (u x)) f","decl":"lemma IsBoundedUnder.eventually_ge (h : IsBoundedUnder (¬∑ ‚â• ¬∑) f u) :\n    ‚àÉ a, ‚àÄ·∂† x in f, a ‚â§ u x :=\n  IsBoundedUnder.eventually_le (Œ± := Œ±·µí·µà) h\n\n"}
{"name":"Filter.isBoundedUnder_of_eventually_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : Preorder Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\na : Œ±\nh : Filter.Eventually (fun x => LE.le (u x) a) f\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u","decl":"lemma isBoundedUnder_of_eventually_le {a : Œ±} (h : ‚àÄ·∂† x in f, u x ‚â§ a) :\n    IsBoundedUnder (¬∑ ‚â§ ¬∑) f u := ‚ü®a, h‚ü©\n\n"}
{"name":"Filter.isBoundedUnder_of_eventually_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : Preorder Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\na : Œ±\nh : Filter.Eventually (fun x => LE.le a (u x)) f\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u","decl":"lemma isBoundedUnder_of_eventually_ge {a : Œ±} (h : ‚àÄ·∂† x in f, a ‚â§ u x) :\n    IsBoundedUnder (¬∑ ‚â• ¬∑) f u := ‚ü®a, h‚ü©\n\n"}
{"name":"Filter.isBoundedUnder_iff_eventually_bddAbove","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : Preorder Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) (Exists fun s => And (BddAbove (Set.image u s)) (Filter.Eventually (fun x => Membership.mem s x) f))","decl":"lemma isBoundedUnder_iff_eventually_bddAbove :\n    f.IsBoundedUnder (¬∑ ‚â§ ¬∑) u ‚Üî ‚àÉ s, BddAbove (u '' s) ‚àß ‚àÄ·∂† x in f, x ‚àà s := by\n  constructor\n  ¬∑ rintro ‚ü®b, hb‚ü©\n    exact ‚ü®{a | u a ‚â§ b}, ‚ü®b, by rintro _ ‚ü®a, ha, rfl‚ü©; exact ha‚ü©, hb‚ü©\n  ¬∑ rintro ‚ü®s, ‚ü®b, hb‚ü©, hs‚ü©\n    exact ‚ü®b, hs.mono <| by simpa [upperBounds] using hb‚ü©\n\n"}
{"name":"Filter.isBoundedUnder_iff_eventually_bddBelow","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : Preorder Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Iff (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) (Exists fun s => And (BddBelow (Set.image u s)) (Filter.Eventually (fun x => Membership.mem s x) f))","decl":"lemma isBoundedUnder_iff_eventually_bddBelow :\n    f.IsBoundedUnder (¬∑ ‚â• ¬∑) u ‚Üî ‚àÉ s, BddBelow (u '' s) ‚àß ‚àÄ·∂† x in f, x ‚àà s :=\n  isBoundedUnder_iff_eventually_bddAbove (Œ± := Œ±·µí·µà)\n\n"}
{"name":"BddAbove.isBoundedUnder","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : Preorder Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\ns : Set Œ≤\nhs : Membership.mem f s\nhu : BddAbove (Set.image u s)\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u","decl":"lemma _root_.BddAbove.isBoundedUnder (hs : s ‚àà f) (hu : BddAbove (u '' s)) :\n    f.IsBoundedUnder (¬∑ ‚â§ ¬∑) u := isBoundedUnder_iff_eventually_bddAbove.2 ‚ü®_, hu, hs‚ü©\n\n"}
{"name":"BddAbove.isBoundedUnder_of_range","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : Preorder Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\nhu : BddAbove (Set.range u)\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u","decl":"/-- A bounded above function `u` is in particular eventually bounded above. -/\nlemma _root_.BddAbove.isBoundedUnder_of_range (hu : BddAbove (Set.range u)) :\n    f.IsBoundedUnder (¬∑ ‚â§ ¬∑) u := BddAbove.isBoundedUnder (s := univ) f.univ_mem (by simpa)\n\n"}
{"name":"BddBelow.isBoundedUnder","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : Preorder Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\ns : Set Œ≤\nhs : Membership.mem f s\nhu : BddBelow (Set.image u s)\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u","decl":"lemma _root_.BddBelow.isBoundedUnder (hs : s ‚àà f) (hu : BddBelow (u '' s)) :\n    f.IsBoundedUnder (¬∑ ‚â• ¬∑) u := isBoundedUnder_iff_eventually_bddBelow.2 ‚ü®_, hu, hs‚ü©\n\n"}
{"name":"BddBelow.isBoundedUnder_of_range","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : Preorder Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\nhu : BddBelow (Set.range u)\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u","decl":"/-- A bounded below function `u` is in particular eventually bounded below. -/\nlemma _root_.BddBelow.isBoundedUnder_of_range (hu : BddBelow (Set.range u)) :\n    f.IsBoundedUnder (¬∑ ‚â• ¬∑) u := BddBelow.isBoundedUnder (s := univ) f.univ_mem (by simpa)\n\n"}
{"name":"Filter.IsBoundedUnder.le_of_finite","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : Nonempty Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => LE.le x1 x2\ninst‚úù : Finite Œ≤\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u","decl":"lemma IsBoundedUnder.le_of_finite [Nonempty Œ±] [IsDirected Œ± (¬∑ ‚â§ ¬∑)] [Finite Œ≤]\n    {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} : IsBoundedUnder (¬∑ ‚â§ ¬∑) f u :=\n  (Set.toFinite _).bddAbove.isBoundedUnder_of_range\n\n"}
{"name":"Filter.IsBoundedUnder.ge_of_finite","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : Preorder Œ±\ninst‚úù¬≤ : Nonempty Œ±\ninst‚úù¬π : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\ninst‚úù : Finite Œ≤\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u","decl":"lemma IsBoundedUnder.ge_of_finite [Nonempty Œ±] [IsDirected Œ± (¬∑ ‚â• ¬∑)] [Finite Œ≤]\n    {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} : IsBoundedUnder (¬∑ ‚â• ¬∑) f u :=\n  (Set.toFinite _).bddBelow.isBoundedUnder_of_range\n\n"}
{"name":"Monotone.isBoundedUnder_le_comp","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\nl : Filter Œ≥\nu : Œ≥ ‚Üí Œ±\nv : Œ± ‚Üí Œ≤\nhv : Monotone v\nhl : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l u\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp v u)","decl":"theorem _root_.Monotone.isBoundedUnder_le_comp [Preorder Œ±] [Preorder Œ≤] {l : Filter Œ≥} {u : Œ≥ ‚Üí Œ±}\n    {v : Œ± ‚Üí Œ≤} (hv : Monotone v) (hl : l.IsBoundedUnder (¬∑ ‚â§ ¬∑) u) :\n    l.IsBoundedUnder (¬∑ ‚â§ ¬∑) (v ‚àò u) :=\n  hl.comp hv\n\n"}
{"name":"Monotone.isBoundedUnder_ge_comp","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\nl : Filter Œ≥\nu : Œ≥ ‚Üí Œ±\nv : Œ± ‚Üí Œ≤\nhv : Monotone v\nhl : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l u\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l (Function.comp v u)","decl":"theorem _root_.Monotone.isBoundedUnder_ge_comp [Preorder Œ±] [Preorder Œ≤] {l : Filter Œ≥} {u : Œ≥ ‚Üí Œ±}\n    {v : Œ± ‚Üí Œ≤} (hv : Monotone v) (hl : l.IsBoundedUnder (¬∑ ‚â• ¬∑) u) :\n    l.IsBoundedUnder (¬∑ ‚â• ¬∑) (v ‚àò u) :=\n  hl.comp (swap hv)\n\n"}
{"name":"Antitone.isBoundedUnder_le_comp","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\nl : Filter Œ≥\nu : Œ≥ ‚Üí Œ±\nv : Œ± ‚Üí Œ≤\nhv : Antitone v\nhl : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l u\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp v u)","decl":"theorem _root_.Antitone.isBoundedUnder_le_comp [Preorder Œ±] [Preorder Œ≤] {l : Filter Œ≥} {u : Œ≥ ‚Üí Œ±}\n    {v : Œ± ‚Üí Œ≤} (hv : Antitone v) (hl : l.IsBoundedUnder (¬∑ ‚â• ¬∑) u) :\n    l.IsBoundedUnder (¬∑ ‚â§ ¬∑) (v ‚àò u) :=\n  hl.comp (swap hv)\n\n"}
{"name":"Antitone.isBoundedUnder_ge_comp","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\nl : Filter Œ≥\nu : Œ≥ ‚Üí Œ±\nv : Œ± ‚Üí Œ≤\nhv : Antitone v\nhl : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l u\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l (Function.comp v u)","decl":"theorem _root_.Antitone.isBoundedUnder_ge_comp [Preorder Œ±] [Preorder Œ≤] {l : Filter Œ≥} {u : Œ≥ ‚Üí Œ±}\n    {v : Œ± ‚Üí Œ≤} (hv : Antitone v) (hl : l.IsBoundedUnder (¬∑ ‚â§ ¬∑) u) :\n    l.IsBoundedUnder (¬∑ ‚â• ¬∑) (v ‚àò u) :=\n  hl.comp hv\n\n"}
{"name":"Filter.not_isBoundedUnder_of_tendsto_atTop","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : NoMaxOrder Œ≤\nf : Œ± ‚Üí Œ≤\nl : Filter Œ±\ninst‚úù : l.NeBot\nhf : Filter.Tendsto f l Filter.atTop\n‚ä¢ Not (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l f)","decl":"theorem not_isBoundedUnder_of_tendsto_atTop [Preorder Œ≤] [NoMaxOrder Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±}\n    [l.NeBot] (hf : Tendsto f l atTop) : ¬¨IsBoundedUnder (¬∑ ‚â§ ¬∑) l f := by\n  rintro ‚ü®b, hb‚ü©\n  rw [eventually_map] at hb\n  obtain ‚ü®b', h‚ü© := exists_gt b\n  have hb' := (tendsto_atTop.mp hf) b'\n  have : { x : Œ± | f x ‚â§ b } ‚à© { x : Œ± | b' ‚â§ f x } = ‚àÖ :=\n    eq_empty_of_subset_empty fun x hx => (not_le_of_lt h) (le_trans hx.2 hx.1)\n  exact (nonempty_of_mem (hb.and hb')).ne_empty this\n\n"}
{"name":"Filter.not_isBoundedUnder_of_tendsto_atBot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : NoMinOrder Œ≤\nf : Œ± ‚Üí Œ≤\nl : Filter Œ±\ninst‚úù : l.NeBot\nhf : Filter.Tendsto f l Filter.atBot\n‚ä¢ Not (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l f)","decl":"theorem not_isBoundedUnder_of_tendsto_atBot [Preorder Œ≤] [NoMinOrder Œ≤] {f : Œ± ‚Üí Œ≤} {l : Filter Œ±}\n    [l.NeBot] (hf : Tendsto f l atBot) : ¬¨IsBoundedUnder (¬∑ ‚â• ¬∑) l f :=\n  not_isBoundedUnder_of_tendsto_atTop (Œ≤ := Œ≤·µí·µà) hf\n\n"}
{"name":"Filter.IsBoundedUnder.bddAbove_range_of_cofinite","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : Preorder Œ≤\ninst‚úù : IsDirected Œ≤ fun x1 x2 => LE.le x1 x2\nf : Œ± ‚Üí Œ≤\nhf : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) Filter.cofinite f\n‚ä¢ BddAbove (Set.range f)","decl":"theorem IsBoundedUnder.bddAbove_range_of_cofinite [Preorder Œ≤] [IsDirected Œ≤ (¬∑ ‚â§ ¬∑)] {f : Œ± ‚Üí Œ≤}\n    (hf : IsBoundedUnder (¬∑ ‚â§ ¬∑) cofinite f) : BddAbove (range f) := by\n  rcases hf with ‚ü®b, hb‚ü©\n  haveI : Nonempty Œ≤ := ‚ü®b‚ü©\n  rw [‚Üê image_univ, ‚Üê union_compl_self { x | f x ‚â§ b }, image_union, bddAbove_union]\n  exact ‚ü®‚ü®b, forall_mem_image.2 fun x => id‚ü©, (hb.image f).bddAbove‚ü©\n\n"}
{"name":"Filter.IsBoundedUnder.bddBelow_range_of_cofinite","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : Preorder Œ≤\ninst‚úù : IsDirected Œ≤ fun x1 x2 => GE.ge x1 x2\nf : Œ± ‚Üí Œ≤\nhf : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) Filter.cofinite f\n‚ä¢ BddBelow (Set.range f)","decl":"theorem IsBoundedUnder.bddBelow_range_of_cofinite [Preorder Œ≤] [IsDirected Œ≤ (¬∑ ‚â• ¬∑)] {f : Œ± ‚Üí Œ≤}\n    (hf : IsBoundedUnder (¬∑ ‚â• ¬∑) cofinite f) : BddBelow (range f) :=\n  IsBoundedUnder.bddAbove_range_of_cofinite (Œ≤ := Œ≤·µí·µà) hf\n\n"}
{"name":"Filter.IsBoundedUnder.bddAbove_range","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ≤ : Type u_2\ninst‚úù¬π : Preorder Œ≤\ninst‚úù : IsDirected Œ≤ fun x1 x2 => LE.le x1 x2\nf : Nat ‚Üí Œ≤\nhf : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) Filter.atTop f\n‚ä¢ BddAbove (Set.range f)","decl":"theorem IsBoundedUnder.bddAbove_range [Preorder Œ≤] [IsDirected Œ≤ (¬∑ ‚â§ ¬∑)] {f : ‚Ñï ‚Üí Œ≤}\n    (hf : IsBoundedUnder (¬∑ ‚â§ ¬∑) atTop f) : BddAbove (range f) := by\n  rw [‚Üê Nat.cofinite_eq_atTop] at hf\n  exact hf.bddAbove_range_of_cofinite\n\n"}
{"name":"Filter.IsBoundedUnder.bddBelow_range","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ≤ : Type u_2\ninst‚úù¬π : Preorder Œ≤\ninst‚úù : IsDirected Œ≤ fun x1 x2 => GE.ge x1 x2\nf : Nat ‚Üí Œ≤\nhf : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) Filter.atTop f\n‚ä¢ BddBelow (Set.range f)","decl":"theorem IsBoundedUnder.bddBelow_range [Preorder Œ≤] [IsDirected Œ≤ (¬∑ ‚â• ¬∑)] {f : ‚Ñï ‚Üí Œ≤}\n    (hf : IsBoundedUnder (¬∑ ‚â• ¬∑) atTop f) : BddBelow (range f) :=\n  IsBoundedUnder.bddAbove_range (Œ≤ := Œ≤·µí·µà) hf\n\n"}
{"name":"Filter.IsCobounded.mk","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nr : Œ± ‚Üí Œ± ‚Üí Prop\nf : Filter Œ±\ninst‚úù : IsTrans Œ± r\na : Œ±\nh : ‚àÄ (s : Set Œ±), Membership.mem f s ‚Üí Exists fun x => And (Membership.mem s x) (r a x)\n‚ä¢ Filter.IsCobounded r f","decl":"/-- To check that a filter is frequently bounded, it suffices to have a witness\nwhich bounds `f` at some point for every admissible set.\n\nThis is only an implication, as the other direction is wrong for the trivial filter. -/\ntheorem IsCobounded.mk [IsTrans Œ± r] (a : Œ±) (h : ‚àÄ s ‚àà f, ‚àÉ x ‚àà s, r a x) : f.IsCobounded r :=\n  ‚ü®a, fun _ s =>\n    let ‚ü®_, h‚ÇÅ, h‚ÇÇ‚ü© := h _ s\n    _root_.trans h‚ÇÇ h‚ÇÅ‚ü©\n\n"}
{"name":"Filter.IsBounded.isCobounded_flip","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nr : Œ± ‚Üí Œ± ‚Üí Prop\nf : Filter Œ±\ninst‚úù¬π : IsTrans Œ± r\ninst‚úù : f.NeBot\na‚úù : Filter.IsBounded r f\n‚ä¢ Filter.IsCobounded (flip r) f","decl":"/-- A filter which is eventually bounded is in particular frequently bounded (in the opposite\ndirection). At least if the filter is not trivial. -/\ntheorem IsBounded.isCobounded_flip [IsTrans Œ± r] [NeBot f] : f.IsBounded r ‚Üí f.IsCobounded (flip r)\n  | ‚ü®a, ha‚ü© =>\n    ‚ü®a, fun b hb =>\n      let ‚ü®_, rxa, rbx‚ü© := (ha.and hb).exists\n      show r b a from _root_.trans rbx rxa‚ü©\n\n"}
{"name":"Filter.IsBounded.isCobounded_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nf : Filter Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : f.NeBot\nh : Filter.IsBounded (fun x1 x2 => LE.le x1 x2) f\n‚ä¢ Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) f","decl":"theorem IsBounded.isCobounded_ge [Preorder Œ±] [NeBot f] (h : f.IsBounded (¬∑ ‚â§ ¬∑)) :\n    f.IsCobounded (¬∑ ‚â• ¬∑) :=\n  h.isCobounded_flip\n\n"}
{"name":"Filter.IsBounded.isCobounded_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nf : Filter Œ±\ninst‚úù¬π : Preorder Œ±\ninst‚úù : f.NeBot\nh : Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) f\n‚ä¢ Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) f","decl":"theorem IsBounded.isCobounded_le [Preorder Œ±] [NeBot f] (h : f.IsBounded (¬∑ ‚â• ¬∑)) :\n    f.IsCobounded (¬∑ ‚â§ ¬∑) :=\n  h.isCobounded_flip\n\n"}
{"name":"Filter.IsBoundedUnder.isCoboundedUnder_flip","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≥ : Type u_3\nr : Œ± ‚Üí Œ± ‚Üí Prop\nu : Œ≥ ‚Üí Œ±\nl : Filter Œ≥\ninst‚úù¬π : IsTrans Œ± r\ninst‚úù : l.NeBot\nh : Filter.IsBoundedUnder r l u\n‚ä¢ Filter.IsCoboundedUnder (flip r) l u","decl":"theorem IsBoundedUnder.isCoboundedUnder_flip {u : Œ≥ ‚Üí Œ±} {l : Filter Œ≥} [IsTrans Œ± r] [NeBot l]\n    (h : l.IsBoundedUnder r u) : l.IsCoboundedUnder (flip r) u :=\n  h.isCobounded_flip\n\n"}
{"name":"Filter.IsBoundedUnder.isCoboundedUnder_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≥ : Type u_3\nu : Œ≥ ‚Üí Œ±\nl : Filter Œ≥\ninst‚úù¬π : Preorder Œ±\ninst‚úù : l.NeBot\nh : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l u\n‚ä¢ Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) l u","decl":"theorem IsBoundedUnder.isCoboundedUnder_le {u : Œ≥ ‚Üí Œ±} {l : Filter Œ≥} [Preorder Œ±] [NeBot l]\n    (h : l.IsBoundedUnder (¬∑ ‚â• ¬∑) u) : l.IsCoboundedUnder (¬∑ ‚â§ ¬∑) u :=\n  h.isCoboundedUnder_flip\n\n"}
{"name":"Filter.IsBoundedUnder.isCoboundedUnder_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≥ : Type u_3\nu : Œ≥ ‚Üí Œ±\nl : Filter Œ≥\ninst‚úù¬π : Preorder Œ±\ninst‚úù : l.NeBot\nh : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l u\n‚ä¢ Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) l u","decl":"theorem IsBoundedUnder.isCoboundedUnder_ge {u : Œ≥ ‚Üí Œ±} {l : Filter Œ≥} [Preorder Œ±] [NeBot l]\n    (h : l.IsBoundedUnder (¬∑ ‚â§ ¬∑) u) : l.IsCoboundedUnder (¬∑ ‚â• ¬∑) u :=\n  h.isCoboundedUnder_flip\n\n"}
{"name":"Filter.isCoboundedUnder_le_of_eventually_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\ninst‚úù¬π : Preorder Œ±\nl : Filter Œπ\ninst‚úù : l.NeBot\nf : Œπ ‚Üí Œ±\nx : Œ±\nhf : Filter.Eventually (fun i => LE.le x (f i)) l\n‚ä¢ Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) l f","decl":"lemma isCoboundedUnder_le_of_eventually_le [Preorder Œ±] (l : Filter Œπ) [NeBot l] {f : Œπ ‚Üí Œ±} {x : Œ±}\n    (hf : ‚àÄ·∂† i in l, x ‚â§ f i) :\n    IsCoboundedUnder (¬∑ ‚â§ ¬∑) l f :=\n  IsBoundedUnder.isCoboundedUnder_le ‚ü®x, hf‚ü©\n\n"}
{"name":"Filter.isCoboundedUnder_ge_of_eventually_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\ninst‚úù¬π : Preorder Œ±\nl : Filter Œπ\ninst‚úù : l.NeBot\nf : Œπ ‚Üí Œ±\nx : Œ±\nhf : Filter.Eventually (fun i => LE.le (f i) x) l\n‚ä¢ Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) l f","decl":"lemma isCoboundedUnder_ge_of_eventually_le [Preorder Œ±] (l : Filter Œπ) [NeBot l] {f : Œπ ‚Üí Œ±} {x : Œ±}\n    (hf : ‚àÄ·∂† i in l, f i ‚â§ x) :\n    IsCoboundedUnder (¬∑ ‚â• ¬∑) l f :=\n  IsBoundedUnder.isCoboundedUnder_ge ‚ü®x, hf‚ü©\n\n"}
{"name":"Filter.isCoboundedUnder_le_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\ninst‚úù¬π : Preorder Œ±\nl : Filter Œπ\ninst‚úù : l.NeBot\nf : Œπ ‚Üí Œ±\nx : Œ±\nhf : ‚àÄ (i : Œπ), LE.le x (f i)\n‚ä¢ Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) l f","decl":"lemma isCoboundedUnder_le_of_le [Preorder Œ±] (l : Filter Œπ) [NeBot l] {f : Œπ ‚Üí Œ±} {x : Œ±}\n    (hf : ‚àÄ i, x ‚â§ f i) :\n    IsCoboundedUnder (¬∑ ‚â§ ¬∑) l f :=\n  isCoboundedUnder_le_of_eventually_le l (Eventually.of_forall hf)\n\n"}
{"name":"Filter.isCoboundedUnder_ge_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\ninst‚úù¬π : Preorder Œ±\nl : Filter Œπ\ninst‚úù : l.NeBot\nf : Œπ ‚Üí Œ±\nx : Œ±\nhf : ‚àÄ (i : Œπ), LE.le (f i) x\n‚ä¢ Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) l f","decl":"lemma isCoboundedUnder_ge_of_le [Preorder Œ±] (l : Filter Œπ) [NeBot l] {f : Œπ ‚Üí Œ±} {x : Œ±}\n    (hf : ‚àÄ i, f i ‚â§ x) :\n    IsCoboundedUnder (¬∑ ‚â• ¬∑) l f :=\n  isCoboundedUnder_ge_of_eventually_le l (Eventually.of_forall hf)\n\n"}
{"name":"Filter.isCobounded_bot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nr : Œ± ‚Üí Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.IsCobounded r Bot.bot) (Exists fun b => ‚àÄ (x : Œ±), r b x)","decl":"theorem isCobounded_bot : IsCobounded r ‚ä• ‚Üî ‚àÉ b, ‚àÄ x, r b x := by simp [IsCobounded]\n\n"}
{"name":"Filter.isCobounded_top","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nr : Œ± ‚Üí Œ± ‚Üí Prop\n‚ä¢ Iff (Filter.IsCobounded r Top.top) (Nonempty Œ±)","decl":"theorem isCobounded_top : IsCobounded r ‚ä§ ‚Üî Nonempty Œ± := by\n  simp +contextual [IsCobounded, eq_univ_iff_forall,\n    exists_true_iff_nonempty]\n\n"}
{"name":"Filter.isCobounded_principal","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nr : Œ± ‚Üí Œ± ‚Üí Prop\ns : Set Œ±\n‚ä¢ Iff (Filter.IsCobounded r (Filter.principal s)) (Exists fun b => ‚àÄ (a : Œ±), (‚àÄ (x : Œ±), Membership.mem s x ‚Üí r x a) ‚Üí r b a)","decl":"theorem isCobounded_principal (s : Set Œ±) :\n    (ùìü s).IsCobounded r ‚Üî ‚àÉ b, ‚àÄ a, (‚àÄ x ‚àà s, r x a) ‚Üí r b a := by simp [IsCobounded, subset_def]\n\n"}
{"name":"Filter.IsCobounded.mono","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nr : Œ± ‚Üí Œ± ‚Üí Prop\nf g : Filter Œ±\nh : LE.le f g\na‚úù : Filter.IsCobounded r f\n‚ä¢ Filter.IsCobounded r g","decl":"theorem IsCobounded.mono (h : f ‚â§ g) : f.IsCobounded r ‚Üí g.IsCobounded r\n  | ‚ü®b, hb‚ü© => ‚ü®b, fun a ha => hb a (h ha)‚ü©\n\n"}
{"name":"Filter.IsCobounded.frequently_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nf : Filter Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : f.NeBot\ncobdd : Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) f\n‚ä¢ Exists fun l => Filter.Frequently (fun x => LE.le l x) f","decl":"/-- For nontrivial filters in linear orders, coboundedness for `‚â§` implies frequent boundedness\nfrom below. -/\nlemma IsCobounded.frequently_ge [LinearOrder Œ±] [NeBot f] (cobdd : IsCobounded (¬∑ ‚â§ ¬∑) f) :\n    ‚àÉ l, ‚àÉ·∂† x in f, l ‚â§ x := by\n  obtain ‚ü®t, ht‚ü© := cobdd\n  rcases isBot_or_exists_lt t with tbot | ‚ü®t', ht'‚ü©\n  ¬∑ exact ‚ü®t, .of_forall fun r ‚Ü¶ tbot r‚ü©\n  refine ‚ü®t', fun ev ‚Ü¶ ?_‚ü©\n  specialize ht t' (by filter_upwards [ev] with _ h using (not_le.mp h).le)\n  exact not_lt_of_le ht ht'\n\n"}
{"name":"Filter.IsCobounded.frequently_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nf : Filter Œ±\ninst‚úù¬π : LinearOrder Œ±\ninst‚úù : f.NeBot\ncobdd : Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) f\n‚ä¢ Exists fun u => Filter.Frequently (fun x => LE.le x u) f","decl":"/-- For nontrivial filters in linear orders, coboundedness for `‚â•` implies frequent boundedness\nfrom above. -/\nlemma IsCobounded.frequently_le [LinearOrder Œ±] [NeBot f] (cobdd : IsCobounded (¬∑ ‚â• ¬∑) f) :\n    ‚àÉ u, ‚àÉ·∂† x in f, x ‚â§ u :=\n  cobdd.frequently_ge (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.IsCobounded.of_frequently_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nf : Filter Œ±\ninst‚úù : LinearOrder Œ±\nl : Œ±\nfreq_ge : Filter.Frequently (fun x => LE.le l x) f\n‚ä¢ Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) f","decl":"/-- In linear orders, frequent boundedness from below implies coboundedness for `‚â§`. -/\nlemma IsCobounded.of_frequently_ge [LinearOrder Œ±] {l : Œ±} (freq_ge : ‚àÉ·∂† x in f, l ‚â§ x) :\n    IsCobounded (¬∑ ‚â§ ¬∑) f := by\n  rcases isBot_or_exists_lt l with lbot | ‚ü®l', hl'‚ü©\n  ¬∑ exact ‚ü®l, fun x _ ‚Ü¶ lbot x‚ü©\n  refine ‚ü®l', fun u hu ‚Ü¶ ?_‚ü©\n  obtain ‚ü®w, l_le_w, w_le_u‚ü© := (freq_ge.and_eventually hu).exists\n  exact hl'.le.trans (l_le_w.trans w_le_u)\n\n"}
{"name":"Filter.IsCobounded.of_frequently_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nf : Filter Œ±\ninst‚úù : LinearOrder Œ±\nu : Œ±\nfreq_le : Filter.Frequently (fun r => LE.le r u) f\n‚ä¢ Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) f","decl":"/-- In linear orders, frequent boundedness from above implies coboundedness for `‚â•`. -/\nlemma IsCobounded.of_frequently_le [LinearOrder Œ±] {u : Œ±} (freq_le : ‚àÉ·∂† r in f, r ‚â§ u) :\n    IsCobounded (¬∑ ‚â• ¬∑) f :=\n  IsCobounded.of_frequently_ge (Œ± := Œ±·µí·µà) freq_le\n\n"}
{"name":"Filter.IsCoboundedUnder.frequently_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\ninst‚úù¬π : LinearOrder Œ±\nf : Filter Œπ\ninst‚úù : f.NeBot\nu : Œπ ‚Üí Œ±\nh : Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u\n‚ä¢ Exists fun a => Filter.Frequently (fun x => LE.le a (u x)) f","decl":"lemma IsCoboundedUnder.frequently_ge [LinearOrder Œ±] {f : Filter Œπ} [NeBot f] {u : Œπ ‚Üí Œ±}\n    (h : IsCoboundedUnder (¬∑ ‚â§ ¬∑) f u) :\n    ‚àÉ a, ‚àÉ·∂† x in f, a ‚â§ u x :=\n  IsCobounded.frequently_ge h\n\n"}
{"name":"Filter.IsCoboundedUnder.frequently_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\ninst‚úù¬π : LinearOrder Œ±\nf : Filter Œπ\ninst‚úù : f.NeBot\nu : Œπ ‚Üí Œ±\nh : Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f u\n‚ä¢ Exists fun a => Filter.Frequently (fun x => LE.le (u x) a) f","decl":"lemma IsCoboundedUnder.frequently_le [LinearOrder Œ±] {f : Filter Œπ} [NeBot f] {u : Œπ ‚Üí Œ±}\n    (h : IsCoboundedUnder (¬∑ ‚â• ¬∑) f u) :\n    ‚àÉ a, ‚àÉ·∂† x in f, u x ‚â§ a :=\n  IsCobounded.frequently_le h\n\n"}
{"name":"Filter.IsCoboundedUnder.of_frequently_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\ninst‚úù : LinearOrder Œ±\nf : Filter Œπ\nu : Œπ ‚Üí Œ±\na : Œ±\nfreq_ge : Filter.Frequently (fun x => LE.le a (u x)) f\n‚ä¢ Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u","decl":"lemma IsCoboundedUnder.of_frequently_ge [LinearOrder Œ±] {f : Filter Œπ} {u : Œπ ‚Üí Œ±}\n    {a : Œ±} (freq_ge : ‚àÉ·∂† x in f, a ‚â§ u x) :\n    IsCoboundedUnder (¬∑ ‚â§ ¬∑) f u :=\n  IsCobounded.of_frequently_ge freq_ge\n\n"}
{"name":"Filter.IsCoboundedUnder.of_frequently_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\ninst‚úù : LinearOrder Œ±\nf : Filter Œπ\nu : Œπ ‚Üí Œ±\na : Œ±\nfreq_le : Filter.Frequently (fun x => LE.le (u x) a) f\n‚ä¢ Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f u","decl":"lemma IsCoboundedUnder.of_frequently_le [LinearOrder Œ±] {f : Filter Œπ} {u : Œπ ‚Üí Œ±}\n    {a : Œ±} (freq_le : ‚àÉ·∂† x in f, u x ‚â§ a) :\n    IsCoboundedUnder (¬∑ ‚â• ¬∑) f u :=\n  IsCobounded.of_frequently_le freq_le\n\n"}
{"name":"Filter.isBoundedUnder_sum","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_6\nf : Filter Œ±\nR : Type u_7\nŒ∫ : Type u_8\ninst‚úù : AddCommMonoid R\nr : R ‚Üí R ‚Üí Prop\nhr : ‚àÄ (v‚ÇÅ v‚ÇÇ : Œ± ‚Üí R), Filter.IsBoundedUnder r f v‚ÇÅ ‚Üí Filter.IsBoundedUnder r f v‚ÇÇ ‚Üí Filter.IsBoundedUnder r f (HAdd.hAdd v‚ÇÅ v‚ÇÇ)\nhr‚ÇÄ : r 0 0\nu : Œ∫ ‚Üí Œ± ‚Üí R\ns : Finset Œ∫\nh : ‚àÄ (k : Œ∫), Membership.mem s k ‚Üí Filter.IsBoundedUnder r f (u k)\n‚ä¢ Filter.IsBoundedUnder r f (s.sum fun k => u k)","decl":"lemma isBoundedUnder_sum {Œ∫ : Type*} [AddCommMonoid R] {r : R ‚Üí R ‚Üí Prop}\n    (hr : ‚àÄ (v‚ÇÅ v‚ÇÇ : Œ± ‚Üí R), f.IsBoundedUnder r v‚ÇÅ ‚Üí f.IsBoundedUnder r v‚ÇÇ\n      ‚Üí f.IsBoundedUnder r (v‚ÇÅ + v‚ÇÇ)) (hr‚ÇÄ : r 0 0)\n    {u : Œ∫ ‚Üí Œ± ‚Üí R} (s : Finset Œ∫) (h : ‚àÄ k ‚àà s, f.IsBoundedUnder r (u k)) :\n    f.IsBoundedUnder r (‚àë k ‚àà s, u k) := by\n  induction s using Finset.cons_induction\n  case empty =>\n    rw [Finset.sum_empty]\n    exact ‚ü®0, by simp_all only [eventually_map, Pi.zero_apply, eventually_true]‚ü©\n  case cons k‚ÇÄ s k‚ÇÄ_notin_s ih =>\n    simp only [Finset.forall_mem_cons] at *\n    simpa only [Finset.sum_cons] using hr _ _ h.1 (ih h.2)\n\n"}
{"name":"Filter.isBoundedUnder_ge_add","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_6\nf : Filter Œ±\nR : Type u_7\ninst‚úù¬≥ : Preorder R\ninst‚úù¬≤ : Add R\ninst‚úù¬π : AddLeftMono R\ninst‚úù : AddRightMono R\nu v : Œ± ‚Üí R\nu_bdd_ge : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u\nv_bdd_ge : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f v\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f (HAdd.hAdd u v)","decl":"lemma isBoundedUnder_ge_add [Add R] [AddLeftMono R] [AddRightMono R]\n    {u v : Œ± ‚Üí R} (u_bdd_ge : f.IsBoundedUnder (¬∑ ‚â• ¬∑) u) (v_bdd_ge : f.IsBoundedUnder (¬∑ ‚â• ¬∑) v) :\n    f.IsBoundedUnder (¬∑ ‚â• ¬∑) (u + v) := by\n  obtain ‚ü®U, hU‚ü© := u_bdd_ge\n  obtain ‚ü®V, hV‚ü© := v_bdd_ge\n  use U + V\n  simp only [eventually_map, Pi.add_apply] at hU hV ‚ä¢\n  filter_upwards [hU, hV] with a hu hv using add_le_add hu hv\n\n"}
{"name":"Filter.isBoundedUnder_le_add","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_6\nf : Filter Œ±\nR : Type u_7\ninst‚úù¬≥ : Preorder R\ninst‚úù¬≤ : Add R\ninst‚úù¬π : AddLeftMono R\ninst‚úù : AddRightMono R\nu v : Œ± ‚Üí R\nu_bdd_le : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u\nv_bdd_le : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f v\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f (HAdd.hAdd u v)","decl":"lemma isBoundedUnder_le_add [Add R] [AddLeftMono R] [AddRightMono R]\n    {u v : Œ± ‚Üí R} (u_bdd_le : f.IsBoundedUnder (¬∑ ‚â§ ¬∑) u) (v_bdd_le : f.IsBoundedUnder (¬∑ ‚â§ ¬∑) v) :\n    f.IsBoundedUnder (¬∑ ‚â§ ¬∑) (u + v) := by\n  obtain ‚ü®U, hU‚ü© := u_bdd_le\n  obtain ‚ü®V, hV‚ü© := v_bdd_le\n  use U + V\n  simp only [eventually_map, Pi.add_apply] at hU hV ‚ä¢\n  filter_upwards [hU, hV] with a hu hv using add_le_add hu hv\n\n"}
{"name":"Filter.isBoundedUnder_le_sum","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_6\nf : Filter Œ±\nR : Type u_7\ninst‚úù¬≥ : Preorder R\nŒ∫ : Type u_8\ninst‚úù¬≤ : AddCommMonoid R\ninst‚úù¬π : AddLeftMono R\ninst‚úù : AddRightMono R\nu : Œ∫ ‚Üí Œ± ‚Üí R\ns : Finset Œ∫\na‚úù : ‚àÄ (k : Œ∫), Membership.mem s k ‚Üí Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f (u k)\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f (s.sum fun k => u k)","decl":"lemma isBoundedUnder_le_sum {Œ∫ : Type*} [AddCommMonoid R] [AddLeftMono R] [AddRightMono R]\n    {u : Œ∫ ‚Üí Œ± ‚Üí R} (s : Finset Œ∫) :\n    (‚àÄ k ‚àà s, f.IsBoundedUnder (¬∑ ‚â§ ¬∑) (u k)) ‚Üí f.IsBoundedUnder (¬∑ ‚â§ ¬∑) (‚àë k ‚àà s, u k) :=\n  fun h ‚Ü¶ isBoundedUnder_sum (fun _ _ ‚Ü¶ isBoundedUnder_le_add) le_rfl s h\n\n"}
{"name":"Filter.isBoundedUnder_ge_sum","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_6\nf : Filter Œ±\nR : Type u_7\ninst‚úù¬≥ : Preorder R\nŒ∫ : Type u_8\ninst‚úù¬≤ : AddCommMonoid R\ninst‚úù¬π : AddLeftMono R\ninst‚úù : AddRightMono R\nu : Œ∫ ‚Üí Œ± ‚Üí R\ns : Finset Œ∫\na‚úù : ‚àÄ (k : Œ∫), Membership.mem s k ‚Üí Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f (u k)\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f (s.sum fun k => u k)","decl":"lemma isBoundedUnder_ge_sum {Œ∫ : Type*} [AddCommMonoid R] [AddLeftMono R] [AddRightMono R]\n    {u : Œ∫ ‚Üí Œ± ‚Üí R} (s : Finset Œ∫) :\n    (‚àÄ k ‚àà s, f.IsBoundedUnder (¬∑ ‚â• ¬∑) (u k)) ‚Üí\n      f.IsBoundedUnder (¬∑ ‚â• ¬∑) (‚àë k ‚àà s, u k) :=\n  fun h ‚Ü¶ isBoundedUnder_sum (fun _ _ ‚Ü¶ isBoundedUnder_ge_add) le_rfl s h\n\n"}
{"name":"Filter.isCoboundedUnder_ge_add","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_6\nR : Type u_7\ninst‚úù‚Å¥ : LinearOrder R\ninst‚úù¬≥ : Add R\nf : Filter Œ±\ninst‚úù¬≤ : f.NeBot\ninst‚úù¬π : CovariantClass R R (fun a b => HAdd.hAdd a b) fun x1 x2 => LE.le x1 x2\ninst‚úù : CovariantClass R R (fun a b => HAdd.hAdd b a) fun x1 x2 => LE.le x1 x2\nu v : Œ± ‚Üí R\nhu : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u\nhv : Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f v\n‚ä¢ Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f (HAdd.hAdd u v)","decl":"lemma isCoboundedUnder_ge_add (hu : f.IsBoundedUnder (¬∑ ‚â§ ¬∑) u)\n    (hv : f.IsCoboundedUnder (¬∑ ‚â• ¬∑) v) :\n    f.IsCoboundedUnder (¬∑ ‚â• ¬∑) (u + v) := by\n  obtain ‚ü®U, hU‚ü© := hu.eventually_le\n  obtain ‚ü®V, hV‚ü© := hv.frequently_le\n  apply IsCoboundedUnder.of_frequently_le (a := U + V)\n  exact (hV.and_eventually hU).mono fun x hx ‚Ü¶ add_le_add hx.2 hx.1\n\n"}
{"name":"Filter.isCoboundedUnder_le_add","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_6\nR : Type u_7\ninst‚úù‚Å¥ : LinearOrder R\ninst‚úù¬≥ : Add R\nf : Filter Œ±\ninst‚úù¬≤ : f.NeBot\ninst‚úù¬π : CovariantClass R R (fun a b => HAdd.hAdd a b) fun x1 x2 => LE.le x1 x2\ninst‚úù : CovariantClass R R (fun a b => HAdd.hAdd b a) fun x1 x2 => LE.le x1 x2\nu v : Œ± ‚Üí R\nhu : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u\nhv : Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f v\n‚ä¢ Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f (HAdd.hAdd u v)","decl":"lemma isCoboundedUnder_le_add (hu : f.IsBoundedUnder (¬∑ ‚â• ¬∑) u)\n    (hv : f.IsCoboundedUnder (¬∑ ‚â§ ¬∑) v) :\n    f.IsCoboundedUnder (¬∑ ‚â§ ¬∑) (u + v) := by\n  obtain ‚ü®U, hU‚ü© := hu.eventually_ge\n  obtain ‚ü®V, hV‚ü© := hv.frequently_ge\n  apply IsCoboundedUnder.of_frequently_ge (a := U + V)\n  exact (hV.and_eventually hU).mono fun x hx ‚Ü¶ add_le_add hx.2 hx.1\n\n"}
{"name":"Filter.isBoundedUnder_le_mul_of_nonneg","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\ninst‚úù‚Å¥ : Mul Œ±\ninst‚úù¬≥ : Zero Œ±\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : PosMulMono Œ±\ninst‚úù : MulPosMono Œ±\nf : Filter Œπ\nu v : Œπ ‚Üí Œ±\nh‚ÇÅ : f.EventuallyLE 0 u\nh‚ÇÇ : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u\nh‚ÇÉ : f.EventuallyLE 0 v\nh‚ÇÑ : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f v\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f (HMul.hMul u v)","decl":"lemma isBoundedUnder_le_mul_of_nonneg [Mul Œ±] [Zero Œ±] [Preorder Œ±] [PosMulMono Œ±]\n    [MulPosMono Œ±] {f : Filter Œπ} {u v : Œπ ‚Üí Œ±} (h‚ÇÅ : 0 ‚â§·∂†[f] u)\n    (h‚ÇÇ : IsBoundedUnder (fun x1 x2 ‚Ü¶ x1 ‚â§ x2) f u)\n    (h‚ÇÉ : 0 ‚â§·∂†[f] v)\n    (h‚ÇÑ : IsBoundedUnder (fun x1 x2 ‚Ü¶ x1 ‚â§ x2) f v) :\n    IsBoundedUnder (fun x1 x2 ‚Ü¶ x1 ‚â§ x2) f (u * v) := by\n  obtain ‚ü®U, hU‚ü© := h‚ÇÇ.eventually_le\n  obtain ‚ü®V, hV‚ü© := h‚ÇÑ.eventually_le\n  refine isBoundedUnder_of_eventually_le (a := U * V) ?_\n  filter_upwards [hU, hV, h‚ÇÅ, h‚ÇÉ] with x x_U x_V u_0 v_0\n  exact mul_le_mul x_U x_V v_0 (u_0.trans x_U)\n\n"}
{"name":"Filter.isCoboundedUnder_ge_mul_of_nonneg","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\ninst‚úù‚Åµ : Mul Œ±\ninst‚úù‚Å¥ : Zero Œ±\ninst‚úù¬≥ : LinearOrder Œ±\ninst‚úù¬≤ : PosMulMono Œ±\ninst‚úù¬π : MulPosMono Œ±\nf : Filter Œπ\ninst‚úù : f.NeBot\nu v : Œπ ‚Üí Œ±\nh‚ÇÅ : f.EventuallyLE 0 u\nh‚ÇÇ : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u\nh‚ÇÉ : f.EventuallyLE 0 v\nh‚ÇÑ : Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f v\n‚ä¢ Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f (HMul.hMul u v)","decl":"lemma isCoboundedUnder_ge_mul_of_nonneg [Mul Œ±] [Zero Œ±] [LinearOrder Œ±] [PosMulMono Œ±]\n    [MulPosMono Œ±] {f : Filter Œπ} [f.NeBot] {u v : Œπ ‚Üí Œ±} (h‚ÇÅ : 0 ‚â§·∂†[f] u)\n    (h‚ÇÇ : IsBoundedUnder (fun x1 x2 ‚Ü¶ x1 ‚â§ x2) f u)\n    (h‚ÇÉ : 0 ‚â§·∂†[f] v)\n    (h‚ÇÑ : IsCoboundedUnder (fun x1 x2 ‚Ü¶ x1 ‚â• x2) f v) :\n    IsCoboundedUnder (fun x1 x2 ‚Ü¶ x1 ‚â• x2) f (u * v) := by\n  obtain ‚ü®U, hU‚ü© := h‚ÇÇ.eventually_le\n  obtain ‚ü®V, hV‚ü© := h‚ÇÑ.frequently_le\n  exact IsCoboundedUnder.of_frequently_le (a := U * V)\n    <| (hV.and_eventually (hU.and (h‚ÇÅ.and h‚ÇÉ))).mono fun x ‚ü®x_V, x_U, u_0, v_0‚ü© ‚Ü¶\n    mul_le_mul x_U x_V v_0 (u_0.trans x_U)\n\n"}
{"name":"Filter.isBounded_le_atBot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Nonempty Œ±\n‚ä¢ Filter.IsBounded (fun x1 x2 => LE.le x1 x2) Filter.atBot","decl":"theorem isBounded_le_atBot : (atBot : Filter Œ±).IsBounded (¬∑ ‚â§ ¬∑) :=\n  ‚ÄπNonempty Œ±‚Ä∫.elim fun a => ‚ü®a, eventually_le_atBot _‚ü©\n\n"}
{"name":"Filter.isBounded_ge_atTop","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Nonempty Œ±\n‚ä¢ Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) Filter.atTop","decl":"theorem isBounded_ge_atTop : (atTop : Filter Œ±).IsBounded (¬∑ ‚â• ¬∑) :=\n  ‚ÄπNonempty Œ±‚Ä∫.elim fun a => ‚ü®a, eventually_ge_atTop _‚ü©\n\n"}
{"name":"Filter.Tendsto.isBoundedUnder_le_atBot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Nonempty Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\nh : Filter.Tendsto u f Filter.atBot\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u","decl":"theorem Tendsto.isBoundedUnder_le_atBot (h : Tendsto u f atBot) : f.IsBoundedUnder (¬∑ ‚â§ ¬∑) u :=\n  isBounded_le_atBot.mono h\n\n"}
{"name":"Filter.Tendsto.isBoundedUnder_ge_atTop","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Nonempty Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\nh : Filter.Tendsto u f Filter.atTop\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u","decl":"theorem Tendsto.isBoundedUnder_ge_atTop (h : Tendsto u f atTop) : f.IsBoundedUnder (¬∑ ‚â• ¬∑) u :=\n  isBounded_ge_atTop.mono h\n\n"}
{"name":"Filter.bddAbove_range_of_tendsto_atTop_atBot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : Nonempty Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => LE.le x1 x2\nu : Nat ‚Üí Œ±\nhx : Filter.Tendsto u Filter.atTop Filter.atBot\n‚ä¢ BddAbove (Set.range u)","decl":"theorem bddAbove_range_of_tendsto_atTop_atBot [IsDirected Œ± (¬∑ ‚â§ ¬∑)] {u : ‚Ñï ‚Üí Œ±}\n    (hx : Tendsto u atTop atBot) : BddAbove (Set.range u) :=\n  hx.isBoundedUnder_le_atBot.bddAbove_range\n\n"}
{"name":"Filter.bddBelow_range_of_tendsto_atTop_atTop","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : Preorder Œ±\ninst‚úù¬π : Nonempty Œ±\ninst‚úù : IsDirected Œ± fun x1 x2 => GE.ge x1 x2\nu : Nat ‚Üí Œ±\nhx : Filter.Tendsto u Filter.atTop Filter.atTop\n‚ä¢ BddBelow (Set.range u)","decl":"theorem bddBelow_range_of_tendsto_atTop_atTop [IsDirected Œ± (¬∑ ‚â• ¬∑)] {u : ‚Ñï ‚Üí Œ±}\n    (hx : Tendsto u atTop atTop) : BddBelow (Set.range u) :=\n  hx.isBoundedUnder_ge_atTop.bddBelow_range\n\n"}
{"name":"Filter.isCobounded_le_of_bot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderBot Œ±\nf : Filter Œ±\n‚ä¢ Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) f","decl":"theorem isCobounded_le_of_bot [Preorder Œ±] [OrderBot Œ±] {f : Filter Œ±} : f.IsCobounded (¬∑ ‚â§ ¬∑) :=\n  ‚ü®‚ä•, fun _ _ => bot_le‚ü©\n\n"}
{"name":"Filter.isCobounded_ge_of_top","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTop Œ±\nf : Filter Œ±\n‚ä¢ Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) f","decl":"theorem isCobounded_ge_of_top [Preorder Œ±] [OrderTop Œ±] {f : Filter Œ±} : f.IsCobounded (¬∑ ‚â• ¬∑) :=\n  ‚ü®‚ä§, fun _ _ => le_top‚ü©\n\n"}
{"name":"Filter.isBounded_le_of_top","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderTop Œ±\nf : Filter Œ±\n‚ä¢ Filter.IsBounded (fun x1 x2 => LE.le x1 x2) f","decl":"theorem isBounded_le_of_top [Preorder Œ±] [OrderTop Œ±] {f : Filter Œ±} : f.IsBounded (¬∑ ‚â§ ¬∑) :=\n  ‚ü®‚ä§, Eventually.of_forall fun _ => le_top‚ü©\n\n"}
{"name":"Filter.isBounded_ge_of_bot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : Preorder Œ±\ninst‚úù : OrderBot Œ±\nf : Filter Œ±\n‚ä¢ Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) f","decl":"theorem isBounded_ge_of_bot [Preorder Œ±] [OrderBot Œ±] {f : Filter Œ±} : f.IsBounded (¬∑ ‚â• ¬∑) :=\n  ‚ü®‚ä•, Eventually.of_forall fun _ => bot_le‚ü©\n\n"}
{"name":"OrderIso.isBoundedUnder_le_comp","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\ne : OrderIso Œ± Œ≤\nl : Filter Œ≥\nu : Œ≥ ‚Üí Œ±\n‚ä¢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l fun x => e (u x)) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l u)","decl":"@[simp]\ntheorem _root_.OrderIso.isBoundedUnder_le_comp [Preorder Œ±] [Preorder Œ≤] (e : Œ± ‚âÉo Œ≤) {l : Filter Œ≥}\n    {u : Œ≥ ‚Üí Œ±} : (IsBoundedUnder (¬∑ ‚â§ ¬∑) l fun x => e (u x)) ‚Üî IsBoundedUnder (¬∑ ‚â§ ¬∑) l u :=\n  (Function.Surjective.exists e.surjective).trans <|\n    exists_congr fun a => by simp only [eventually_map, e.le_iff_le]\n\n"}
{"name":"OrderIso.isBoundedUnder_ge_comp","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬π : Preorder Œ±\ninst‚úù : Preorder Œ≤\ne : OrderIso Œ± Œ≤\nl : Filter Œ≥\nu : Œ≥ ‚Üí Œ±\n‚ä¢ Iff (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l fun x => e (u x)) (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l u)","decl":"@[simp]\ntheorem _root_.OrderIso.isBoundedUnder_ge_comp [Preorder Œ±] [Preorder Œ≤] (e : Œ± ‚âÉo Œ≤) {l : Filter Œ≥}\n    {u : Œ≥ ‚Üí Œ±} : (IsBoundedUnder (¬∑ ‚â• ¬∑) l fun x => e (u x)) ‚Üî IsBoundedUnder (¬∑ ‚â• ¬∑) l u :=\n  OrderIso.isBoundedUnder_le_comp e.dual\n\n"}
{"name":"Filter.isBoundedUnder_le_neg","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : OrderedAddCommGroup Œ±\nl : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l fun x => Neg.neg (u x)) (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l u)","decl":"@[to_additive (attr := simp)]\ntheorem isBoundedUnder_le_inv [OrderedCommGroup Œ±] {l : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} :\n    (IsBoundedUnder (¬∑ ‚â§ ¬∑) l fun x => (u x)‚Åª¬π) ‚Üî IsBoundedUnder (¬∑ ‚â• ¬∑) l u :=\n  (OrderIso.inv Œ±).isBoundedUnder_ge_comp\n\n"}
{"name":"Filter.isBoundedUnder_le_inv","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : OrderedCommGroup Œ±\nl : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l fun x => Inv.inv (u x)) (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l u)","decl":"@[to_additive (attr := simp)]\ntheorem isBoundedUnder_le_inv [OrderedCommGroup Œ±] {l : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} :\n    (IsBoundedUnder (¬∑ ‚â§ ¬∑) l fun x => (u x)‚Åª¬π) ‚Üî IsBoundedUnder (¬∑ ‚â• ¬∑) l u :=\n  (OrderIso.inv Œ±).isBoundedUnder_ge_comp\n\n"}
{"name":"Filter.isBoundedUnder_ge_inv","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : OrderedCommGroup Œ±\nl : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Iff (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l fun x => Inv.inv (u x)) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l u)","decl":"@[to_additive (attr := simp)]\ntheorem isBoundedUnder_ge_inv [OrderedCommGroup Œ±] {l : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} :\n    (IsBoundedUnder (¬∑ ‚â• ¬∑) l fun x => (u x)‚Åª¬π) ‚Üî IsBoundedUnder (¬∑ ‚â§ ¬∑) l u :=\n  (OrderIso.inv Œ±).isBoundedUnder_le_comp\n\n"}
{"name":"Filter.isBoundedUnder_ge_neg","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : OrderedAddCommGroup Œ±\nl : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Iff (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l fun x => Neg.neg (u x)) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l u)","decl":"@[to_additive (attr := simp)]\ntheorem isBoundedUnder_ge_inv [OrderedCommGroup Œ±] {l : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} :\n    (IsBoundedUnder (¬∑ ‚â• ¬∑) l fun x => (u x)‚Åª¬π) ‚Üî IsBoundedUnder (¬∑ ‚â§ ¬∑) l u :=\n  (OrderIso.inv Œ±).isBoundedUnder_le_comp\n\n"}
{"name":"Filter.IsBoundedUnder.sup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : SemilatticeSup Œ±\nf : Filter Œ≤\nu v : Œ≤ ‚Üí Œ±\na‚úù¬π : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u\na‚úù : Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f v\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f fun a => Max.max (u a) (v a)","decl":"theorem IsBoundedUnder.sup [SemilatticeSup Œ±] {f : Filter Œ≤} {u v : Œ≤ ‚Üí Œ±} :\n    f.IsBoundedUnder (¬∑ ‚â§ ¬∑) u ‚Üí\n      f.IsBoundedUnder (¬∑ ‚â§ ¬∑) v ‚Üí f.IsBoundedUnder (¬∑ ‚â§ ¬∑) fun a => u a ‚äî v a\n  | ‚ü®bu, (hu : ‚àÄ·∂† x in f, u x ‚â§ bu)‚ü©, ‚ü®bv, (hv : ‚àÄ·∂† x in f, v x ‚â§ bv)‚ü© =>\n    ‚ü®bu ‚äî bv, show ‚àÄ·∂† x in f, u x ‚äî v x ‚â§ bu ‚äî bv\n      by filter_upwards [hu, hv] with _ using sup_le_sup‚ü©\n\n"}
{"name":"Filter.isBoundedUnder_le_sup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : SemilatticeSup Œ±\nf : Filter Œ≤\nu v : Œ≤ ‚Üí Œ±\n‚ä¢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f fun a => Max.max (u a) (v a)) (And (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f v))","decl":"@[simp]\ntheorem isBoundedUnder_le_sup [SemilatticeSup Œ±] {f : Filter Œ≤} {u v : Œ≤ ‚Üí Œ±} :\n    (f.IsBoundedUnder (¬∑ ‚â§ ¬∑) fun a => u a ‚äî v a) ‚Üî\n      f.IsBoundedUnder (¬∑ ‚â§ ¬∑) u ‚àß f.IsBoundedUnder (¬∑ ‚â§ ¬∑) v :=\n  ‚ü®fun h =>\n    ‚ü®h.mono_le <| Eventually.of_forall fun _ => le_sup_left,\n      h.mono_le <| Eventually.of_forall fun _ => le_sup_right‚ü©,\n    fun h => h.1.sup h.2‚ü©\n\n"}
{"name":"Filter.IsBoundedUnder.inf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : SemilatticeInf Œ±\nf : Filter Œ≤\nu v : Œ≤ ‚Üí Œ±\na‚úù¬π : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u\na‚úù : Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f v\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f fun a => Min.min (u a) (v a)","decl":"theorem IsBoundedUnder.inf [SemilatticeInf Œ±] {f : Filter Œ≤} {u v : Œ≤ ‚Üí Œ±} :\n    f.IsBoundedUnder (¬∑ ‚â• ¬∑) u ‚Üí\n      f.IsBoundedUnder (¬∑ ‚â• ¬∑) v ‚Üí f.IsBoundedUnder (¬∑ ‚â• ¬∑) fun a => u a ‚äì v a :=\n  IsBoundedUnder.sup (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.isBoundedUnder_ge_inf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : SemilatticeInf Œ±\nf : Filter Œ≤\nu v : Œ≤ ‚Üí Œ±\n‚ä¢ Iff (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f fun a => Min.min (u a) (v a)) (And (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f v))","decl":"@[simp]\ntheorem isBoundedUnder_ge_inf [SemilatticeInf Œ±] {f : Filter Œ≤} {u v : Œ≤ ‚Üí Œ±} :\n    (f.IsBoundedUnder (¬∑ ‚â• ¬∑) fun a => u a ‚äì v a) ‚Üî\n      f.IsBoundedUnder (¬∑ ‚â• ¬∑) u ‚àß f.IsBoundedUnder (¬∑ ‚â• ¬∑) v :=\n  isBoundedUnder_le_sup (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.isBoundedUnder_le_abs","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : LinearOrderedAddCommGroup Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f fun a => abs (u a)) (And (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u))","decl":"theorem isBoundedUnder_le_abs [LinearOrderedAddCommGroup Œ±] {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} :\n    (f.IsBoundedUnder (¬∑ ‚â§ ¬∑) fun a => |u a|) ‚Üî\n      f.IsBoundedUnder (¬∑ ‚â§ ¬∑) u ‚àß f.IsBoundedUnder (¬∑ ‚â• ¬∑) u :=\n  isBoundedUnder_le_sup.trans <| and_congr Iff.rfl isBoundedUnder_le_neg\n\n"}
{"name":"Filter.limsup_eq","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Filter.limsup u f) (InfSet.sInf (setOf fun a => Filter.Eventually (fun n => LE.le (u n) a) f))","decl":"theorem limsup_eq : limsup u f = sInf { a | ‚àÄ·∂† n in f, u n ‚â§ a } :=\n  rfl\n\n"}
{"name":"Filter.liminf_eq","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Filter.liminf u f) (SupSet.sSup (setOf fun a => Filter.Eventually (fun n => LE.le a (u n)) f))","decl":"theorem liminf_eq : liminf u f = sSup { a | ‚àÄ·∂† n in f, a ‚â§ u n } :=\n  rfl\n\n"}
{"name":"Filter.blimsup_eq","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\np : Œ≤ ‚Üí Prop\n‚ä¢ Eq (Filter.blimsup u f p) (InfSet.sInf (setOf fun a => Filter.Eventually (fun x => p x ‚Üí LE.le (u x) a) f))","decl":"theorem blimsup_eq : blimsup u f p = sInf { a | ‚àÄ·∂† x in f, p x ‚Üí u x ‚â§ a } :=\n  rfl\n\n"}
{"name":"Filter.bliminf_eq","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\np : Œ≤ ‚Üí Prop\n‚ä¢ Eq (Filter.bliminf u f p) (SupSet.sSup (setOf fun a => Filter.Eventually (fun x => p x ‚Üí LE.le a (u x)) f))","decl":"theorem bliminf_eq : bliminf u f p = sSup { a | ‚àÄ·∂† x in f, p x ‚Üí a ‚â§ u x } :=\n  rfl\n\n"}
{"name":"Filter.liminf_comp","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù : ConditionallyCompleteLattice Œ±\nu : Œ≤ ‚Üí Œ±\nv : Œ≥ ‚Üí Œ≤\nf : Filter Œ≥\n‚ä¢ Eq (Filter.liminf (Function.comp u v) f) (Filter.liminf u (Filter.map v f))","decl":"lemma liminf_comp (u : Œ≤ ‚Üí Œ±) (v : Œ≥ ‚Üí Œ≤) (f : Filter Œ≥) :\n    liminf (u ‚àò v) f = liminf u (map v f) := rfl\n\n"}
{"name":"Filter.limsup_comp","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù : ConditionallyCompleteLattice Œ±\nu : Œ≤ ‚Üí Œ±\nv : Œ≥ ‚Üí Œ≤\nf : Filter Œ≥\n‚ä¢ Eq (Filter.limsup (Function.comp u v) f) (Filter.limsup u (Filter.map v f))","decl":"lemma limsup_comp (u : Œ≤ ‚Üí Œ±) (v : Œ≥ ‚Üí Œ≤) (f : Filter Œ≥) :\n    limsup (u ‚àò v) f = limsup u (map v f) := rfl\n\n"}
{"name":"Filter.blimsup_true","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Filter.blimsup u f fun x => True) (Filter.limsup u f)","decl":"@[simp]\ntheorem blimsup_true (f : Filter Œ≤) (u : Œ≤ ‚Üí Œ±) : (blimsup u f fun _ => True) = limsup u f := by\n  simp [blimsup_eq, limsup_eq]\n\n"}
{"name":"Filter.bliminf_true","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Filter.bliminf u f fun x => True) (Filter.liminf u f)","decl":"@[simp]\ntheorem bliminf_true (f : Filter Œ≤) (u : Œ≤ ‚Üí Œ±) : (bliminf u f fun _ => True) = liminf u f := by\n  simp [bliminf_eq, liminf_eq]\n\n"}
{"name":"Filter.blimsup_eq_limsup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\np : Œ≤ ‚Üí Prop\n‚ä¢ Eq (Filter.blimsup u f p) (Filter.limsup u (Min.min f (Filter.principal (setOf fun x => p x))))","decl":"lemma blimsup_eq_limsup {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} {p : Œ≤ ‚Üí Prop} :\n    blimsup u f p = limsup u (f ‚äì ùìü {x | p x}) := by\n  simp only [blimsup_eq, limsup_eq, eventually_inf_principal, mem_setOf_eq]\n\n"}
{"name":"Filter.bliminf_eq_liminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\np : Œ≤ ‚Üí Prop\n‚ä¢ Eq (Filter.bliminf u f p) (Filter.liminf u (Min.min f (Filter.principal (setOf fun x => p x))))","decl":"lemma bliminf_eq_liminf {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} {p : Œ≤ ‚Üí Prop} :\n    bliminf u f p = liminf u (f ‚äì ùìü {x | p x}) :=\n  blimsup_eq_limsup (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.blimsup_eq_limsup_subtype","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\np : Œ≤ ‚Üí Prop\n‚ä¢ Eq (Filter.blimsup u f p) (Filter.limsup (Function.comp u Subtype.val) (Filter.comap Subtype.val f))","decl":"theorem blimsup_eq_limsup_subtype {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} {p : Œ≤ ‚Üí Prop} :\n    blimsup u f p = limsup (u ‚àò ((‚Üë) : { x | p x } ‚Üí Œ≤)) (comap (‚Üë) f) := by\n  rw [blimsup_eq_limsup, limsup, limsup, ‚Üê map_map, map_comap_setCoe_val]\n\n"}
{"name":"Filter.bliminf_eq_liminf_subtype","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\np : Œ≤ ‚Üí Prop\n‚ä¢ Eq (Filter.bliminf u f p) (Filter.liminf (Function.comp u Subtype.val) (Filter.comap Subtype.val f))","decl":"theorem bliminf_eq_liminf_subtype {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} {p : Œ≤ ‚Üí Prop} :\n    bliminf u f p = liminf (u ‚àò ((‚Üë) : { x | p x } ‚Üí Œ≤)) (comap (‚Üë) f) :=\n  blimsup_eq_limsup_subtype (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.limsSup_le_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Filter Œ±\na : Œ±\nhf : autoParam (Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) f) _auto‚úù\nh : Filter.Eventually (fun n => LE.le n a) f\n‚ä¢ LE.le f.limsSup a","decl":"theorem limsSup_le_of_le {f : Filter Œ±} {a}\n    (hf : f.IsCobounded (¬∑ ‚â§ ¬∑) := by isBoundedDefault)\n    (h : ‚àÄ·∂† n in f, n ‚â§ a) : limsSup f ‚â§ a :=\n  csInf_le hf h\n\n"}
{"name":"Filter.le_limsInf_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Filter Œ±\na : Œ±\nhf : autoParam (Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) f) _auto‚úù\nh : Filter.Eventually (fun n => LE.le a n) f\n‚ä¢ LE.le a f.limsInf","decl":"theorem le_limsInf_of_le {f : Filter Œ±} {a}\n    (hf : f.IsCobounded (¬∑ ‚â• ¬∑) := by isBoundedDefault)\n    (h : ‚àÄ·∂† n in f, a ‚â§ n) : a ‚â§ limsInf f :=\n  le_csSup hf h\n\n"}
{"name":"Filter.limsup_le_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\na : Œ±\nhf : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto‚úù\nh : Filter.Eventually (fun n => LE.le (u n) a) f\n‚ä¢ LE.le (Filter.limsup u f) a","decl":"theorem limsup_le_of_le {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a}\n    (hf : f.IsCoboundedUnder (¬∑ ‚â§ ¬∑) u := by isBoundedDefault)\n    (h : ‚àÄ·∂† n in f, u n ‚â§ a) : limsup u f ‚â§ a :=\n  csInf_le hf h\n\n"}
{"name":"Filter.le_liminf_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\na : Œ±\nhf : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto‚úù\nh : Filter.Eventually (fun n => LE.le a (u n)) f\n‚ä¢ LE.le a (Filter.liminf u f)","decl":"theorem le_liminf_of_le {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a}\n    (hf : f.IsCoboundedUnder (¬∑ ‚â• ¬∑) u := by isBoundedDefault)\n    (h : ‚àÄ·∂† n in f, a ‚â§ u n) : a ‚â§ liminf u f :=\n  le_csSup hf h\n\n"}
{"name":"Filter.le_limsSup_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Filter Œ±\na : Œ±\nhf : autoParam (Filter.IsBounded (fun x1 x2 => LE.le x1 x2) f) _auto‚úù\nh : ‚àÄ (b : Œ±), Filter.Eventually (fun n => LE.le n b) f ‚Üí LE.le a b\n‚ä¢ LE.le a f.limsSup","decl":"theorem le_limsSup_of_le {f : Filter Œ±} {a}\n    (hf : f.IsBounded (¬∑ ‚â§ ¬∑) := by isBoundedDefault)\n    (h : ‚àÄ b, (‚àÄ·∂† n in f, n ‚â§ b) ‚Üí a ‚â§ b) : a ‚â§ limsSup f :=\n  le_csInf hf h\n\n"}
{"name":"Filter.limsInf_le_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Filter Œ±\na : Œ±\nhf : autoParam (Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) f) _auto‚úù\nh : ‚àÄ (b : Œ±), Filter.Eventually (fun n => LE.le b n) f ‚Üí LE.le b a\n‚ä¢ LE.le f.limsInf a","decl":"theorem limsInf_le_of_le {f : Filter Œ±} {a}\n    (hf : f.IsBounded (¬∑ ‚â• ¬∑) := by isBoundedDefault)\n    (h : ‚àÄ b, (‚àÄ·∂† n in f, b ‚â§ n) ‚Üí b ‚â§ a) : limsInf f ‚â§ a :=\n  csSup_le hf h\n\n"}
{"name":"Filter.le_limsup_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\na : Œ±\nhf : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto‚úù\nh : ‚àÄ (b : Œ±), Filter.Eventually (fun n => LE.le (u n) b) f ‚Üí LE.le a b\n‚ä¢ LE.le a (Filter.limsup u f)","decl":"theorem le_limsup_of_le {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a}\n    (hf : f.IsBoundedUnder (¬∑ ‚â§ ¬∑) u := by isBoundedDefault)\n    (h : ‚àÄ b, (‚àÄ·∂† n in f, u n ‚â§ b) ‚Üí a ‚â§ b) : a ‚â§ limsup u f :=\n  le_csInf hf h\n\n"}
{"name":"Filter.liminf_le_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\na : Œ±\nhf : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto‚úù\nh : ‚àÄ (b : Œ±), Filter.Eventually (fun n => LE.le b (u n)) f ‚Üí LE.le b a\n‚ä¢ LE.le (Filter.liminf u f) a","decl":"theorem liminf_le_of_le {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} {a}\n    (hf : f.IsBoundedUnder (¬∑ ‚â• ¬∑) u := by isBoundedDefault)\n    (h : ‚àÄ b, (‚àÄ·∂† n in f, b ‚â§ u n) ‚Üí b ‚â§ a) : liminf u f ‚â§ a :=\n  csSup_le hf h\n\n"}
{"name":"Filter.limsInf_le_limsSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : ConditionallyCompleteLattice Œ±\nf : Filter Œ±\ninst‚úù : f.NeBot\nh‚ÇÅ : autoParam (Filter.IsBounded (fun x1 x2 => LE.le x1 x2) f) _auto‚úù\nh‚ÇÇ : autoParam (Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) f) _auto‚úù\n‚ä¢ LE.le f.limsInf f.limsSup","decl":"theorem limsInf_le_limsSup {f : Filter Œ±} [NeBot f]\n    (h‚ÇÅ : f.IsBounded (¬∑ ‚â§ ¬∑) := by isBoundedDefault)\n    (h‚ÇÇ : f.IsBounded (¬∑ ‚â• ¬∑) := by isBoundedDefault) :\n    limsInf f ‚â§ limsSup f :=\n  liminf_le_of_le h‚ÇÇ fun a‚ÇÄ ha‚ÇÄ =>\n    le_limsup_of_le h‚ÇÅ fun a‚ÇÅ ha‚ÇÅ =>\n      show a‚ÇÄ ‚â§ a‚ÇÅ from\n        let ‚ü®_, hb‚ÇÄ, hb‚ÇÅ‚ü© := (ha‚ÇÄ.and ha‚ÇÅ).exists\n        le_trans hb‚ÇÄ hb‚ÇÅ\n\n"}
{"name":"Filter.liminf_le_limsup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : ConditionallyCompleteLattice Œ±\nf : Filter Œ≤\ninst‚úù : f.NeBot\nu : Œ≤ ‚Üí Œ±\nh : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto‚úù\nh' : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto‚úù\n‚ä¢ LE.le (Filter.liminf u f) (Filter.limsup u f)","decl":"theorem liminf_le_limsup {f : Filter Œ≤} [NeBot f] {u : Œ≤ ‚Üí Œ±}\n    (h : f.IsBoundedUnder (¬∑ ‚â§ ¬∑) u := by isBoundedDefault)\n    (h' : f.IsBoundedUnder (¬∑ ‚â• ¬∑) u := by isBoundedDefault) :\n    liminf u f ‚â§ limsup u f :=\n  limsInf_le_limsSup h h'\n\n"}
{"name":"Filter.limsSup_le_limsSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : ConditionallyCompleteLattice Œ±\nf g : Filter Œ±\nhf : autoParam (Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) f) _auto‚úù\nhg : autoParam (Filter.IsBounded (fun x1 x2 => LE.le x1 x2) g) _auto‚úù\nh : ‚àÄ (a : Œ±), Filter.Eventually (fun n => LE.le n a) g ‚Üí Filter.Eventually (fun n => LE.le n a) f\n‚ä¢ LE.le f.limsSup g.limsSup","decl":"theorem limsSup_le_limsSup {f g : Filter Œ±}\n    (hf : f.IsCobounded (¬∑ ‚â§ ¬∑) := by isBoundedDefault)\n    (hg : g.IsBounded (¬∑ ‚â§ ¬∑) := by isBoundedDefault)\n    (h : ‚àÄ a, (‚àÄ·∂† n in g, n ‚â§ a) ‚Üí ‚àÄ·∂† n in f, n ‚â§ a) : limsSup f ‚â§ limsSup g :=\n  csInf_le_csInf hf hg h\n\n"}
{"name":"Filter.limsInf_le_limsInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : ConditionallyCompleteLattice Œ±\nf g : Filter Œ±\nhf : autoParam (Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) f) _auto‚úù\nhg : autoParam (Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) g) _auto‚úù\nh : ‚àÄ (a : Œ±), Filter.Eventually (fun n => LE.le a n) f ‚Üí Filter.Eventually (fun n => LE.le a n) g\n‚ä¢ LE.le f.limsInf g.limsInf","decl":"theorem limsInf_le_limsInf {f g : Filter Œ±}\n    (hf : f.IsBounded (¬∑ ‚â• ¬∑) := by isBoundedDefault)\n    (hg : g.IsCobounded (¬∑ ‚â• ¬∑) := by isBoundedDefault)\n    (h : ‚àÄ a, (‚àÄ·∂† n in f, a ‚â§ n) ‚Üí ‚àÄ·∂† n in g, a ‚â§ n) : limsInf f ‚â§ limsInf g :=\n  csSup_le_csSup hg hf h\n\n"}
{"name":"Filter.limsup_le_limsup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ≤ : Type u_2\nŒ± : Type u_6\ninst‚úù : ConditionallyCompleteLattice Œ≤\nf : Filter Œ±\nu v : Œ± ‚Üí Œ≤\nh : f.EventuallyLE u v\nhu : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto‚úù\nhv : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f v) _auto‚úù\n‚ä¢ LE.le (Filter.limsup u f) (Filter.limsup v f)","decl":"theorem limsup_le_limsup {Œ± : Type*} [ConditionallyCompleteLattice Œ≤] {f : Filter Œ±} {u v : Œ± ‚Üí Œ≤}\n    (h : u ‚â§·∂†[f] v)\n    (hu : f.IsCoboundedUnder (¬∑ ‚â§ ¬∑) u := by isBoundedDefault)\n    (hv : f.IsBoundedUnder (¬∑ ‚â§ ¬∑) v := by isBoundedDefault) :\n    limsup u f ‚â§ limsup v f :=\n  limsSup_le_limsSup hu hv fun _ => h.trans\n\n"}
{"name":"Filter.liminf_le_liminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ≤ : Type u_2\nŒ± : Type u_6\ninst‚úù : ConditionallyCompleteLattice Œ≤\nf : Filter Œ±\nu v : Œ± ‚Üí Œ≤\nh : Filter.Eventually (fun a => LE.le (u a) (v a)) f\nhu : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto‚úù\nhv : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f v) _auto‚úù\n‚ä¢ LE.le (Filter.liminf u f) (Filter.liminf v f)","decl":"theorem liminf_le_liminf {Œ± : Type*} [ConditionallyCompleteLattice Œ≤] {f : Filter Œ±} {u v : Œ± ‚Üí Œ≤}\n    (h : ‚àÄ·∂† a in f, u a ‚â§ v a)\n    (hu : f.IsBoundedUnder (¬∑ ‚â• ¬∑) u := by isBoundedDefault)\n    (hv : f.IsCoboundedUnder (¬∑ ‚â• ¬∑) v := by isBoundedDefault) :\n    liminf u f ‚â§ liminf v f :=\n  limsup_le_limsup (Œ≤ := Œ≤·µí·µà) h hv hu\n\n"}
{"name":"Filter.limsSup_le_limsSup_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : ConditionallyCompleteLattice Œ±\nf g : Filter Œ±\nh : LE.le f g\nhf : autoParam (Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) f) _auto‚úù\nhg : autoParam (Filter.IsBounded (fun x1 x2 => LE.le x1 x2) g) _auto‚úù\n‚ä¢ LE.le f.limsSup g.limsSup","decl":"theorem limsSup_le_limsSup_of_le {f g : Filter Œ±} (h : f ‚â§ g)\n    (hf : f.IsCobounded (¬∑ ‚â§ ¬∑) := by isBoundedDefault)\n    (hg : g.IsBounded (¬∑ ‚â§ ¬∑) := by isBoundedDefault) :\n    limsSup f ‚â§ limsSup g :=\n  limsSup_le_limsSup hf hg fun _ ha => h ha\n\n"}
{"name":"Filter.limsInf_le_limsInf_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : ConditionallyCompleteLattice Œ±\nf g : Filter Œ±\nh : LE.le g f\nhf : autoParam (Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) f) _auto‚úù\nhg : autoParam (Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) g) _auto‚úù\n‚ä¢ LE.le f.limsInf g.limsInf","decl":"theorem limsInf_le_limsInf_of_le {f g : Filter Œ±} (h : g ‚â§ f)\n    (hf : f.IsBounded (¬∑ ‚â• ¬∑) := by isBoundedDefault)\n    (hg : g.IsCobounded (¬∑ ‚â• ¬∑) := by isBoundedDefault) :\n    limsInf f ‚â§ limsInf g :=\n  limsInf_le_limsInf hf hg fun _ ha => h ha\n\n"}
{"name":"Filter.limsup_le_limsup_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_6\nŒ≤ : Type u_7\ninst‚úù : ConditionallyCompleteLattice Œ≤\nf g : Filter Œ±\nh : LE.le f g\nu : Œ± ‚Üí Œ≤\nhf : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto‚úù\nhg : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) g u) _auto‚úù\n‚ä¢ LE.le (Filter.limsup u f) (Filter.limsup u g)","decl":"theorem limsup_le_limsup_of_le {Œ± Œ≤} [ConditionallyCompleteLattice Œ≤] {f g : Filter Œ±} (h : f ‚â§ g)\n    {u : Œ± ‚Üí Œ≤}\n    (hf : f.IsCoboundedUnder (¬∑ ‚â§ ¬∑) u := by isBoundedDefault)\n    (hg : g.IsBoundedUnder (¬∑ ‚â§ ¬∑) u := by isBoundedDefault) :\n    limsup u f ‚â§ limsup u g :=\n  limsSup_le_limsSup_of_le (map_mono h) hf hg\n\n"}
{"name":"Filter.liminf_le_liminf_of_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_6\nŒ≤ : Type u_7\ninst‚úù : ConditionallyCompleteLattice Œ≤\nf g : Filter Œ±\nh : LE.le g f\nu : Œ± ‚Üí Œ≤\nhf : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto‚úù\nhg : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) g u) _auto‚úù\n‚ä¢ LE.le (Filter.liminf u f) (Filter.liminf u g)","decl":"theorem liminf_le_liminf_of_le {Œ± Œ≤} [ConditionallyCompleteLattice Œ≤] {f g : Filter Œ±} (h : g ‚â§ f)\n    {u : Œ± ‚Üí Œ≤}\n    (hf : f.IsBoundedUnder (¬∑ ‚â• ¬∑) u := by isBoundedDefault)\n    (hg : g.IsCoboundedUnder (¬∑ ‚â• ¬∑) u := by isBoundedDefault) :\n    liminf u f ‚â§ liminf u g :=\n  limsInf_le_limsInf_of_le (map_mono h) hf hg\n\n"}
{"name":"Filter.limsSup_principal_eq_csSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : ConditionallyCompleteLattice Œ±\ns : Set Œ±\nh : BddAbove s\nhs : s.Nonempty\n‚ä¢ Eq (Filter.principal s).limsSup (SupSet.sSup s)","decl":"lemma limsSup_principal_eq_csSup (h : BddAbove s) (hs : s.Nonempty) : limsSup (ùìü s) = sSup s := by\n  simp only [limsSup, eventually_principal]; exact csInf_upperBounds_eq_csSup h hs\n\n"}
{"name":"Filter.limsInf_principal_eq_csSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : ConditionallyCompleteLattice Œ±\ns : Set Œ±\nh : BddBelow s\nhs : s.Nonempty\n‚ä¢ Eq (Filter.principal s).limsInf (InfSet.sInf s)","decl":"lemma limsInf_principal_eq_csSup (h : BddBelow s) (hs : s.Nonempty) : limsInf (ùìü s) = sInf s :=\n  limsSup_principal_eq_csSup (Œ± := Œ±·µí·µà) h hs\n\n"}
{"name":"Filter.limsup_top_eq_ciSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : ConditionallyCompleteLattice Œ±\nu : Œ≤ ‚Üí Œ±\ninst‚úù : Nonempty Œ≤\nhu : BddAbove (Set.range u)\n‚ä¢ Eq (Filter.limsup u Top.top) (iSup fun i => u i)","decl":"lemma limsup_top_eq_ciSup [Nonempty Œ≤] (hu : BddAbove (range u)) : limsup u ‚ä§ = ‚®Ü i, u i := by\n  rw [limsup, map_top, limsSup_principal_eq_csSup hu (range_nonempty _), sSup_range]\n\n"}
{"name":"Filter.liminf_top_eq_ciInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : ConditionallyCompleteLattice Œ±\nu : Œ≤ ‚Üí Œ±\ninst‚úù : Nonempty Œ≤\nhu : BddBelow (Set.range u)\n‚ä¢ Eq (Filter.liminf u Top.top) (iInf fun i => u i)","decl":"lemma liminf_top_eq_ciInf [Nonempty Œ≤] (hu : BddBelow (range u)) : liminf u ‚ä§ = ‚®Ö i, u i := by\n  rw [liminf, map_top, limsInf_principal_eq_csSup hu (range_nonempty _), sInf_range]\n\n"}
{"name":"Filter.limsup_congr","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ≤ : Type u_2\nŒ± : Type u_6\ninst‚úù : ConditionallyCompleteLattice Œ≤\nf : Filter Œ±\nu v : Œ± ‚Üí Œ≤\nh : Filter.Eventually (fun a => Eq (u a) (v a)) f\n‚ä¢ Eq (Filter.limsup u f) (Filter.limsup v f)","decl":"theorem limsup_congr {Œ± : Type*} [ConditionallyCompleteLattice Œ≤] {f : Filter Œ±} {u v : Œ± ‚Üí Œ≤}\n    (h : ‚àÄ·∂† a in f, u a = v a) : limsup u f = limsup v f := by\n  rw [limsup_eq]\n  congr with b\n  exact eventually_congr (h.mono fun x hx => by simp [hx])\n\n"}
{"name":"Filter.blimsup_congr","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Filter Œ≤\nu v : Œ≤ ‚Üí Œ±\np : Œ≤ ‚Üí Prop\nh : Filter.Eventually (fun a => p a ‚Üí Eq (u a) (v a)) f\n‚ä¢ Eq (Filter.blimsup u f p) (Filter.blimsup v f p)","decl":"theorem blimsup_congr {f : Filter Œ≤} {u v : Œ≤ ‚Üí Œ±} {p : Œ≤ ‚Üí Prop} (h : ‚àÄ·∂† a in f, p a ‚Üí u a = v a) :\n    blimsup u f p = blimsup v f p := by\n  simpa only [blimsup_eq_limsup] using limsup_congr <| eventually_inf_principal.2 h\n\n"}
{"name":"Filter.bliminf_congr","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Filter Œ≤\nu v : Œ≤ ‚Üí Œ±\np : Œ≤ ‚Üí Prop\nh : Filter.Eventually (fun a => p a ‚Üí Eq (u a) (v a)) f\n‚ä¢ Eq (Filter.bliminf u f p) (Filter.bliminf v f p)","decl":"theorem bliminf_congr {f : Filter Œ≤} {u v : Œ≤ ‚Üí Œ±} {p : Œ≤ ‚Üí Prop} (h : ‚àÄ·∂† a in f, p a ‚Üí u a = v a) :\n    bliminf u f p = bliminf v f p :=\n  blimsup_congr (Œ± := Œ±·µí·µà) h\n\n"}
{"name":"Filter.liminf_congr","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ≤ : Type u_2\nŒ± : Type u_6\ninst‚úù : ConditionallyCompleteLattice Œ≤\nf : Filter Œ±\nu v : Œ± ‚Üí Œ≤\nh : Filter.Eventually (fun a => Eq (u a) (v a)) f\n‚ä¢ Eq (Filter.liminf u f) (Filter.liminf v f)","decl":"theorem liminf_congr {Œ± : Type*} [ConditionallyCompleteLattice Œ≤] {f : Filter Œ±} {u v : Œ± ‚Üí Œ≤}\n    (h : ‚àÄ·∂† a in f, u a = v a) : liminf u f = liminf v f :=\n  limsup_congr (Œ≤ := Œ≤·µí·µà) h\n\n"}
{"name":"Filter.limsup_const","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ≤ : Type u_2\nŒ± : Type u_6\ninst‚úù¬π : ConditionallyCompleteLattice Œ≤\nf : Filter Œ±\ninst‚úù : f.NeBot\nb : Œ≤\n‚ä¢ Eq (Filter.limsup (fun x => b) f) b","decl":"@[simp]\ntheorem limsup_const {Œ± : Type*} [ConditionallyCompleteLattice Œ≤] {f : Filter Œ±} [NeBot f]\n    (b : Œ≤) : limsup (fun _ => b) f = b := by\n  simpa only [limsup_eq, eventually_const] using csInf_Ici\n\n"}
{"name":"Filter.liminf_const","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ≤ : Type u_2\nŒ± : Type u_6\ninst‚úù¬π : ConditionallyCompleteLattice Œ≤\nf : Filter Œ±\ninst‚úù : f.NeBot\nb : Œ≤\n‚ä¢ Eq (Filter.liminf (fun x => b) f) b","decl":"@[simp]\ntheorem liminf_const {Œ± : Type*} [ConditionallyCompleteLattice Œ≤] {f : Filter Œ±} [NeBot f]\n    (b : Œ≤) : liminf (fun _ => b) f = b :=\n  limsup_const (Œ≤ := Œ≤·µí·µà) b\n\n"}
{"name":"Filter.HasBasis.liminf_eq_sSup_iUnion_iInter","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : ConditionallyCompleteLattice Œ±\nŒπ : Type u_6\nŒπ' : Type u_7\nf : Œπ ‚Üí Œ±\nv : Filter Œπ\np : Œπ' ‚Üí Prop\ns : Œπ' ‚Üí Set Œπ\nhv : v.HasBasis p s\n‚ä¢ Eq (Filter.liminf f v) (SupSet.sSup (Set.iUnion fun j => Set.iInter fun i => Set.Iic (f ‚Üëi)))","decl":"theorem HasBasis.liminf_eq_sSup_iUnion_iInter {Œπ Œπ' : Type*} {f : Œπ ‚Üí Œ±} {v : Filter Œπ}\n    {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí Set Œπ} (hv : v.HasBasis p s) :\n    liminf f v = sSup (‚ãÉ (j : Subtype p), ‚ãÇ (i : s j), Iic (f i)) := by\n  simp_rw [liminf_eq, hv.eventually_iff]\n  congr\n  ext x\n  simp only [mem_setOf_eq, iInter_coe_set, mem_iUnion, mem_iInter, mem_Iic, Subtype.exists,\n    exists_prop]\n\n"}
{"name":"Filter.HasBasis.liminf_eq_sSup_univ_of_empty","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\nŒπ' : Type u_5\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Œπ ‚Üí Œ±\nv : Filter Œπ\np : Œπ' ‚Üí Prop\ns : Œπ' ‚Üí Set Œπ\nhv : v.HasBasis p s\ni : Œπ'\nhi : p i\nh'i : Eq (s i) EmptyCollection.emptyCollection\n‚ä¢ Eq (Filter.liminf f v) (SupSet.sSup Set.univ)","decl":"theorem HasBasis.liminf_eq_sSup_univ_of_empty {f : Œπ ‚Üí Œ±} {v : Filter Œπ}\n    {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí Set Œπ} (hv : v.HasBasis p s) (i : Œπ') (hi : p i) (h'i : s i = ‚àÖ) :\n    liminf f v = sSup univ := by\n  simp [hv.eq_bot_iff.2 ‚ü®i, hi, h'i‚ü©, liminf_eq]\n\n"}
{"name":"Filter.HasBasis.limsup_eq_sInf_iUnion_iInter","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : ConditionallyCompleteLattice Œ±\nŒπ : Type u_6\nŒπ' : Type u_7\nf : Œπ ‚Üí Œ±\nv : Filter Œπ\np : Œπ' ‚Üí Prop\ns : Œπ' ‚Üí Set Œπ\nhv : v.HasBasis p s\n‚ä¢ Eq (Filter.limsup f v) (InfSet.sInf (Set.iUnion fun j => Set.iInter fun i => Set.Ici (f ‚Üëi)))","decl":"theorem HasBasis.limsup_eq_sInf_iUnion_iInter {Œπ Œπ' : Type*} {f : Œπ ‚Üí Œ±} {v : Filter Œπ}\n    {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí Set Œπ} (hv : v.HasBasis p s) :\n    limsup f v = sInf (‚ãÉ (j : Subtype p), ‚ãÇ (i : s j), Ici (f i)) :=\n  HasBasis.liminf_eq_sSup_iUnion_iInter (Œ± := Œ±·µí·µà) hv\n\n"}
{"name":"Filter.HasBasis.limsup_eq_sInf_univ_of_empty","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\nŒπ' : Type u_5\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Œπ ‚Üí Œ±\nv : Filter Œπ\np : Œπ' ‚Üí Prop\ns : Œπ' ‚Üí Set Œπ\nhv : v.HasBasis p s\ni : Œπ'\nhi : p i\nh'i : Eq (s i) EmptyCollection.emptyCollection\n‚ä¢ Eq (Filter.limsup f v) (InfSet.sInf Set.univ)","decl":"theorem HasBasis.limsup_eq_sInf_univ_of_empty {f : Œπ ‚Üí Œ±} {v : Filter Œπ}\n    {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí Set Œπ} (hv : v.HasBasis p s) (i : Œπ') (hi : p i) (h'i : s i = ‚àÖ) :\n    limsup f v = sInf univ :=\n  HasBasis.liminf_eq_sSup_univ_of_empty (Œ± := Œ±·µí·µà) hv i hi h'i\n\n"}
{"name":"Filter.liminf_nat_add","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Nat ‚Üí Œ±\nk : Nat\n‚ä¢ Eq (Filter.liminf (fun i => f (HAdd.hAdd i k)) Filter.atTop) (Filter.liminf f Filter.atTop)","decl":"@[simp]\ntheorem liminf_nat_add (f : ‚Ñï ‚Üí Œ±) (k : ‚Ñï) :\n    liminf (fun i => f (i + k)) atTop = liminf f atTop := by\n  change liminf (f ‚àò (¬∑ + k)) atTop = liminf f atTop\n  rw [liminf, liminf, ‚Üê map_map, map_add_atTop_eq_nat]\n\n"}
{"name":"Filter.limsup_nat_add","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : ConditionallyCompleteLattice Œ±\nf : Nat ‚Üí Œ±\nk : Nat\n‚ä¢ Eq (Filter.limsup (fun i => f (HAdd.hAdd i k)) Filter.atTop) (Filter.limsup f Filter.atTop)","decl":"@[simp]\ntheorem limsup_nat_add (f : ‚Ñï ‚Üí Œ±) (k : ‚Ñï) : limsup (fun i => f (i + k)) atTop = limsup f atTop :=\n  @liminf_nat_add Œ±·µí·µà _ f k\n\n"}
{"name":"Filter.limsSup_bot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : CompleteLattice Œ±\n‚ä¢ Eq Bot.bot.limsSup Bot.bot","decl":"@[simp]\ntheorem limsSup_bot : limsSup (‚ä• : Filter Œ±) = ‚ä• :=\n  bot_unique <| sInf_le <| by simp\n\n"}
{"name":"Filter.limsup_bot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Filter.limsup f Bot.bot) Bot.bot","decl":"@[simp] theorem limsup_bot (f : Œ≤ ‚Üí Œ±) : limsup f ‚ä• = ‚ä• := by simp [limsup]\n\n"}
{"name":"Filter.limsInf_bot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : CompleteLattice Œ±\n‚ä¢ Eq Bot.bot.limsInf Top.top","decl":"@[simp]\ntheorem limsInf_bot : limsInf (‚ä• : Filter Œ±) = ‚ä§ :=\n  top_unique <| le_sSup <| by simp\n\n"}
{"name":"Filter.liminf_bot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Filter.liminf f Bot.bot) Top.top","decl":"@[simp] theorem liminf_bot (f : Œ≤ ‚Üí Œ±) : liminf f ‚ä• = ‚ä§ := by simp [liminf]\n\n"}
{"name":"Filter.limsSup_top","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : CompleteLattice Œ±\n‚ä¢ Eq Top.top.limsSup Top.top","decl":"@[simp]\ntheorem limsSup_top : limsSup (‚ä§ : Filter Œ±) = ‚ä§ :=\n  top_unique <| le_sInf <| by simpa [eq_univ_iff_forall] using fun b hb => top_unique <| hb _\n\n"}
{"name":"Filter.limsInf_top","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : CompleteLattice Œ±\n‚ä¢ Eq Top.top.limsInf Bot.bot","decl":"@[simp]\ntheorem limsInf_top : limsInf (‚ä§ : Filter Œ±) = ‚ä• :=\n  bot_unique <| sSup_le <| by simpa [eq_univ_iff_forall] using fun b hb => bot_unique <| hb _\n\n"}
{"name":"Filter.blimsup_false","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Filter.blimsup u f fun x => False) Bot.bot","decl":"@[simp]\ntheorem blimsup_false {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} : (blimsup u f fun _ => False) = ‚ä• := by\n  simp [blimsup_eq]\n\n"}
{"name":"Filter.bliminf_false","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Filter.bliminf u f fun x => False) Top.top","decl":"@[simp]\ntheorem bliminf_false {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} : (bliminf u f fun _ => False) = ‚ä§ := by\n  simp [bliminf_eq]\n\n"}
{"name":"Filter.limsup_const_bot","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\n‚ä¢ Eq (Filter.limsup (fun x => Bot.bot) f) Bot.bot","decl":"/-- Same as limsup_const applied to `‚ä•` but without the `NeBot f` assumption -/\n@[simp]\ntheorem limsup_const_bot {f : Filter Œ≤} : limsup (fun _ : Œ≤ => (‚ä• : Œ±)) f = (‚ä• : Œ±) := by\n  rw [limsup_eq, eq_bot_iff]\n  exact sInf_le (Eventually.of_forall fun _ => le_rfl)\n\n"}
{"name":"Filter.liminf_const_top","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\n‚ä¢ Eq (Filter.liminf (fun x => Top.top) f) Top.top","decl":"/-- Same as limsup_const applied to `‚ä§` but without the `NeBot f` assumption -/\n@[simp]\ntheorem liminf_const_top {f : Filter Œ≤} : liminf (fun _ : Œ≤ => (‚ä§ : Œ±)) f = (‚ä§ : Œ±) :=\n  limsup_const_bot (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.HasBasis.limsSup_eq_iInf_sSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : CompleteLattice Œ±\nŒπ : Sort u_6\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set Œ±\nf : Filter Œ±\nh : f.HasBasis p s\n‚ä¢ Eq f.limsSup (iInf fun i => iInf fun x => SupSet.sSup (s i))","decl":"theorem HasBasis.limsSup_eq_iInf_sSup {Œπ} {p : Œπ ‚Üí Prop} {s} {f : Filter Œ±} (h : f.HasBasis p s) :\n    limsSup f = ‚®Ö (i) (_ : p i), sSup (s i) :=\n  le_antisymm (le_iInf‚ÇÇ fun i hi => sInf_le <| h.eventually_iff.2 ‚ü®i, hi, fun _ => le_sSup‚ü©)\n    (le_sInf fun _ ha =>\n      let ‚ü®_, hi, ha‚ü© := h.eventually_iff.1 ha\n      iInf‚ÇÇ_le_of_le _ hi <| sSup_le ha)\n\n"}
{"name":"Filter.HasBasis.limsInf_eq_iSup_sInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\ninst‚úù : CompleteLattice Œ±\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set Œ±\nf : Filter Œ±\nh : f.HasBasis p s\n‚ä¢ Eq f.limsInf (iSup fun i => iSup fun x => InfSet.sInf (s i))","decl":"theorem HasBasis.limsInf_eq_iSup_sInf {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ±} {f : Filter Œ±}\n    (h : f.HasBasis p s) : limsInf f = ‚®Ü (i) (_ : p i), sInf (s i) :=\n  HasBasis.limsSup_eq_iInf_sSup (Œ± := Œ±·µí·µà) h\n\n"}
{"name":"Filter.limsSup_eq_iInf_sSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ±\n‚ä¢ Eq f.limsSup (iInf fun s => iInf fun h => SupSet.sSup s)","decl":"theorem limsSup_eq_iInf_sSup {f : Filter Œ±} : limsSup f = ‚®Ö s ‚àà f, sSup s :=\n  f.basis_sets.limsSup_eq_iInf_sSup\n\n"}
{"name":"Filter.limsInf_eq_iSup_sInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ±\n‚ä¢ Eq f.limsInf (iSup fun s => iSup fun h => InfSet.sInf s)","decl":"theorem limsInf_eq_iSup_sInf {f : Filter Œ±} : limsInf f = ‚®Ü s ‚àà f, sInf s :=\n  limsSup_eq_iInf_sSup (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.limsup_le_iSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\n‚ä¢ LE.le (Filter.limsup u f) (iSup fun n => u n)","decl":"theorem limsup_le_iSup {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} : limsup u f ‚â§ ‚®Ü n, u n :=\n  limsup_le_of_le (by isBoundedDefault) (Eventually.of_forall (le_iSup u))\n\n"}
{"name":"Filter.iInf_le_liminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\n‚ä¢ LE.le (iInf fun n => u n) (Filter.liminf u f)","decl":"theorem iInf_le_liminf {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} : ‚®Ö n, u n ‚â§ liminf u f :=\n  le_liminf_of_le (by isBoundedDefault) (Eventually.of_forall (iInf_le u))\n\n"}
{"name":"Filter.limsup_eq_iInf_iSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Filter.limsup u f) (iInf fun s => iInf fun h => iSup fun a => iSup fun h => u a)","decl":"/-- In a complete lattice, the limsup of a function is the infimum over sets `s` in the filter\nof the supremum of the function over `s` -/\ntheorem limsup_eq_iInf_iSup {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} : limsup u f = ‚®Ö s ‚àà f, ‚®Ü a ‚àà s, u a :=\n  (f.basis_sets.map u).limsSup_eq_iInf_sSup.trans <| by simp only [sSup_image, id]\n\n"}
{"name":"Filter.limsup_eq_iInf_iSup_of_nat","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : CompleteLattice Œ±\nu : Nat ‚Üí Œ±\n‚ä¢ Eq (Filter.limsup u Filter.atTop) (iInf fun n => iSup fun i => iSup fun h => u i)","decl":"theorem limsup_eq_iInf_iSup_of_nat {u : ‚Ñï ‚Üí Œ±} : limsup u atTop = ‚®Ö n : ‚Ñï, ‚®Ü i ‚â• n, u i :=\n  (atTop_basis.map u).limsSup_eq_iInf_sSup.trans <| by simp only [sSup_image, iInf_const]; rfl\n\n"}
{"name":"Filter.limsup_eq_iInf_iSup_of_nat'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : CompleteLattice Œ±\nu : Nat ‚Üí Œ±\n‚ä¢ Eq (Filter.limsup u Filter.atTop) (iInf fun n => iSup fun i => u (HAdd.hAdd i n))","decl":"theorem limsup_eq_iInf_iSup_of_nat' {u : ‚Ñï ‚Üí Œ±} : limsup u atTop = ‚®Ö n : ‚Ñï, ‚®Ü i : ‚Ñï, u (i + n) := by\n  simp only [limsup_eq_iInf_iSup_of_nat, iSup_ge_eq_iSup_nat_add]\n\n"}
{"name":"Filter.HasBasis.limsup_eq_iInf_iSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_4\ninst‚úù : CompleteLattice Œ±\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set Œ≤\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\nh : f.HasBasis p s\n‚ä¢ Eq (Filter.limsup u f) (iInf fun i => iInf fun x => iSup fun a => iSup fun h => u a)","decl":"theorem HasBasis.limsup_eq_iInf_iSup {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ≤} {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±}\n    (h : f.HasBasis p s) : limsup u f = ‚®Ö (i) (_ : p i), ‚®Ü a ‚àà s i, u a :=\n  (h.map u).limsSup_eq_iInf_sSup.trans <| by simp only [sSup_image, id]\n\n"}
{"name":"Filter.limsSup_principal_eq_sSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : CompleteLattice Œ±\ns : Set Œ±\n‚ä¢ Eq (Filter.principal s).limsSup (SupSet.sSup s)","decl":"lemma limsSup_principal_eq_sSup (s : Set Œ±) : limsSup (ùìü s) = sSup s := by\n  simpa only [limsSup, eventually_principal] using sInf_upperBounds_eq_csSup s\n\n"}
{"name":"Filter.limsInf_principal_eq_sInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : CompleteLattice Œ±\ns : Set Œ±\n‚ä¢ Eq (Filter.principal s).limsInf (InfSet.sInf s)","decl":"lemma limsInf_principal_eq_sInf (s : Set Œ±) : limsInf (ùìü s) = sInf s := by\n  simpa only [limsInf, eventually_principal] using sSup_lowerBounds_eq_sInf s\n\n"}
{"name":"Filter.limsup_top_eq_iSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Filter.limsup u Top.top) (iSup fun i => u i)","decl":"@[simp] lemma limsup_top_eq_iSup (u : Œ≤ ‚Üí Œ±) : limsup u ‚ä§ = ‚®Ü i, u i := by\n  rw [limsup, map_top, limsSup_principal_eq_sSup, sSup_range]\n\n"}
{"name":"Filter.liminf_top_eq_iInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Filter.liminf u Top.top) (iInf fun i => u i)","decl":"@[simp] lemma liminf_top_eq_iInf (u : Œ≤ ‚Üí Œ±) : liminf u ‚ä§ = ‚®Ö i, u i := by\n  rw [liminf, map_top, limsInf_principal_eq_sInf, sInf_range]\n\n"}
{"name":"Filter.limsSup_principal","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : CompleteLattice Œ±\ns : Set Œ±\n‚ä¢ Eq (Filter.principal s).limsSup (SupSet.sSup s)","decl":"@[deprecated (since := \"2024-08-27\")] alias limsSup_principal := limsSup_principal_eq_sSup\n"}
{"name":"Filter.limsInf_principal","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : CompleteLattice Œ±\ns : Set Œ±\n‚ä¢ Eq (Filter.principal s).limsInf (InfSet.sInf s)","decl":"@[deprecated (since := \"2024-08-27\")] alias limsInf_principal := limsInf_principal_eq_sInf\n"}
{"name":"Filter.limsup_top","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Filter.limsup u Top.top) (iSup fun i => u i)","decl":"@[deprecated (since := \"2024-08-27\")] alias limsup_top := limsup_top_eq_iSup\n"}
{"name":"Filter.liminf_top","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Filter.liminf u Top.top) (iInf fun i => u i)","decl":"@[deprecated (since := \"2024-08-27\")] alias liminf_top := liminf_top_eq_iInf\n\n"}
{"name":"Filter.blimsup_congr'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np q : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\nh : Filter.Eventually (fun x => Ne (u x) Bot.bot ‚Üí Iff (p x) (q x)) f\n‚ä¢ Eq (Filter.blimsup u f p) (Filter.blimsup u f q)","decl":"theorem blimsup_congr' {f : Filter Œ≤} {p q : Œ≤ ‚Üí Prop} {u : Œ≤ ‚Üí Œ±}\n    (h : ‚àÄ·∂† x in f, u x ‚â† ‚ä• ‚Üí (p x ‚Üî q x)) : blimsup u f p = blimsup u f q := by\n  simp only [blimsup_eq]\n  congr with a\n  refine eventually_congr (h.mono fun b hb => ?_)\n  rcases eq_or_ne (u b) ‚ä• with hu | hu; ¬∑ simp [hu]\n  rw [hb hu]\n\n"}
{"name":"Filter.bliminf_congr'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np q : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\nh : Filter.Eventually (fun x => Ne (u x) Top.top ‚Üí Iff (p x) (q x)) f\n‚ä¢ Eq (Filter.bliminf u f p) (Filter.bliminf u f q)","decl":"theorem bliminf_congr' {f : Filter Œ≤} {p q : Œ≤ ‚Üí Prop} {u : Œ≤ ‚Üí Œ±}\n    (h : ‚àÄ·∂† x in f, u x ‚â† ‚ä§ ‚Üí (p x ‚Üî q x)) : bliminf u f p = bliminf u f q :=\n  blimsup_congr' (Œ± := Œ±·µí·µà) h\n\n"}
{"name":"Filter.HasBasis.blimsup_eq_iInf_iSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_4\ninst‚úù : CompleteLattice Œ±\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set Œ≤\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\nhf : f.HasBasis p s\nq : Œ≤ ‚Üí Prop\n‚ä¢ Eq (Filter.blimsup u f q) (iInf fun i => iInf fun x => iSup fun a => iSup fun h => iSup fun x => u a)","decl":"lemma HasBasis.blimsup_eq_iInf_iSup {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ≤} {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±}\n    (hf : f.HasBasis p s) {q : Œ≤ ‚Üí Prop} :\n    blimsup u f q = ‚®Ö (i) (_ : p i), ‚®Ü a ‚àà s i, ‚®Ü (_ : q a), u a := by\n  simp only [blimsup_eq_limsup, (hf.inf_principal _).limsup_eq_iInf_iSup, mem_inter_iff, iSup_and,\n    mem_setOf_eq]\n\n"}
{"name":"Filter.blimsup_eq_iInf_biSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Filter.blimsup u f p) (iInf fun s => iInf fun h => iSup fun b => iSup fun x => u b)","decl":"theorem blimsup_eq_iInf_biSup {f : Filter Œ≤} {p : Œ≤ ‚Üí Prop} {u : Œ≤ ‚Üí Œ±} :\n    blimsup u f p = ‚®Ö s ‚àà f, ‚®Ü (b) (_ : p b ‚àß b ‚àà s), u b := by\n  simp only [f.basis_sets.blimsup_eq_iInf_iSup, iSup_and', id, and_comm]\n\n"}
{"name":"Filter.blimsup_eq_iInf_biSup_of_nat","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : CompleteLattice Œ±\np : Nat ‚Üí Prop\nu : Nat ‚Üí Œ±\n‚ä¢ Eq (Filter.blimsup u Filter.atTop p) (iInf fun i => iSup fun j => iSup fun x => u j)","decl":"theorem blimsup_eq_iInf_biSup_of_nat {p : ‚Ñï ‚Üí Prop} {u : ‚Ñï ‚Üí Œ±} :\n    blimsup u atTop p = ‚®Ö i, ‚®Ü (j) (_ : p j ‚àß i ‚â§ j), u j := by\n  simp only [atTop_basis.blimsup_eq_iInf_iSup, @and_comm (p _), iSup_and, mem_Ici, iInf_true]\n\n"}
{"name":"Filter.liminf_eq_iSup_iInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Filter.liminf u f) (iSup fun s => iSup fun h => iInf fun a => iInf fun h => u a)","decl":"/-- In a complete lattice, the liminf of a function is the infimum over sets `s` in the filter\nof the supremum of the function over `s` -/\ntheorem liminf_eq_iSup_iInf {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±} : liminf u f = ‚®Ü s ‚àà f, ‚®Ö a ‚àà s, u a :=\n  limsup_eq_iInf_iSup (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.liminf_eq_iSup_iInf_of_nat","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : CompleteLattice Œ±\nu : Nat ‚Üí Œ±\n‚ä¢ Eq (Filter.liminf u Filter.atTop) (iSup fun n => iInf fun i => iInf fun h => u i)","decl":"theorem liminf_eq_iSup_iInf_of_nat {u : ‚Ñï ‚Üí Œ±} : liminf u atTop = ‚®Ü n : ‚Ñï, ‚®Ö i ‚â• n, u i :=\n  @limsup_eq_iInf_iSup_of_nat Œ±·µí·µà _ u\n\n"}
{"name":"Filter.liminf_eq_iSup_iInf_of_nat'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : CompleteLattice Œ±\nu : Nat ‚Üí Œ±\n‚ä¢ Eq (Filter.liminf u Filter.atTop) (iSup fun n => iInf fun i => u (HAdd.hAdd i n))","decl":"theorem liminf_eq_iSup_iInf_of_nat' {u : ‚Ñï ‚Üí Œ±} : liminf u atTop = ‚®Ü n : ‚Ñï, ‚®Ö i : ‚Ñï, u (i + n) :=\n  @limsup_eq_iInf_iSup_of_nat' Œ±·µí·µà _ _\n\n"}
{"name":"Filter.HasBasis.liminf_eq_iSup_iInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_4\ninst‚úù : CompleteLattice Œ±\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set Œ≤\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\nh : f.HasBasis p s\n‚ä¢ Eq (Filter.liminf u f) (iSup fun i => iSup fun x => iInf fun a => iInf fun h => u a)","decl":"theorem HasBasis.liminf_eq_iSup_iInf {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ≤} {f : Filter Œ≤} {u : Œ≤ ‚Üí Œ±}\n    (h : f.HasBasis p s) : liminf u f = ‚®Ü (i) (_ : p i), ‚®Ö a ‚àà s i, u a :=\n  HasBasis.limsup_eq_iInf_iSup (Œ± := Œ±·µí·µà) h\n\n"}
{"name":"Filter.bliminf_eq_iSup_biInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Filter.bliminf u f p) (iSup fun s => iSup fun h => iInf fun b => iInf fun x => u b)","decl":"theorem bliminf_eq_iSup_biInf {f : Filter Œ≤} {p : Œ≤ ‚Üí Prop} {u : Œ≤ ‚Üí Œ±} :\n    bliminf u f p = ‚®Ü s ‚àà f, ‚®Ö (b) (_ : p b ‚àß b ‚àà s), u b :=\n  @blimsup_eq_iInf_biSup Œ±·µí·µà Œ≤ _ f p u\n\n"}
{"name":"Filter.bliminf_eq_iSup_biInf_of_nat","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : CompleteLattice Œ±\np : Nat ‚Üí Prop\nu : Nat ‚Üí Œ±\n‚ä¢ Eq (Filter.bliminf u Filter.atTop p) (iSup fun i => iInf fun j => iInf fun x => u j)","decl":"theorem bliminf_eq_iSup_biInf_of_nat {p : ‚Ñï ‚Üí Prop} {u : ‚Ñï ‚Üí Œ±} :\n    bliminf u atTop p = ‚®Ü i, ‚®Ö (j) (_ : p j ‚àß i ‚â§ j), u j :=\n  @blimsup_eq_iInf_biSup_of_nat Œ±·µí·µà _ p u\n\n"}
{"name":"Filter.limsup_eq_sInf_sSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œπ : Type u_6\nR : Type u_7\nF : Filter Œπ\ninst‚úù : CompleteLattice R\na : Œπ ‚Üí R\n‚ä¢ Eq (Filter.limsup a F) (InfSet.sInf (Set.image (fun I => SupSet.sSup (Set.image a I)) F.sets))","decl":"theorem limsup_eq_sInf_sSup {Œπ R : Type*} (F : Filter Œπ) [CompleteLattice R] (a : Œπ ‚Üí R) :\n    limsup a F = sInf ((fun I => sSup (a '' I)) '' F.sets) := by\n  apply le_antisymm\n  ¬∑ rw [limsup_eq]\n    refine sInf_le_sInf fun x hx => ?_\n    rcases (mem_image _ F.sets x).mp hx with ‚ü®I, ‚ü®I_mem_F, hI‚ü©‚ü©\n    filter_upwards [I_mem_F] with i hi\n    exact hI ‚ñ∏ le_sSup (mem_image_of_mem _ hi)\n  ¬∑ refine le_sInf fun b hb => sInf_le_of_le (mem_image_of_mem _ hb) <| sSup_le ?_\n    rintro _ ‚ü®_, h, rfl‚ü©\n    exact h\n\n"}
{"name":"Filter.liminf_eq_sSup_sInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œπ : Type u_6\nR : Type u_7\nF : Filter Œπ\ninst‚úù : CompleteLattice R\na : Œπ ‚Üí R\n‚ä¢ Eq (Filter.liminf a F) (SupSet.sSup (Set.image (fun I => InfSet.sInf (Set.image a I)) F.sets))","decl":"theorem liminf_eq_sSup_sInf {Œπ R : Type*} (F : Filter Œπ) [CompleteLattice R] (a : Œπ ‚Üí R) :\n    liminf a F = sSup ((fun I => sInf (a '' I)) '' F.sets) :=\n  @Filter.limsup_eq_sInf_sSup Œπ (OrderDual R) _ _ a\n\n"}
{"name":"Filter.liminf_le_of_frequently_le'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_6\nŒ≤ : Type u_7\ninst‚úù : CompleteLattice Œ≤\nf : Filter Œ±\nu : Œ± ‚Üí Œ≤\nx : Œ≤\nh : Filter.Frequently (fun a => LE.le (u a) x) f\n‚ä¢ LE.le (Filter.liminf u f) x","decl":"theorem liminf_le_of_frequently_le' {Œ± Œ≤} [CompleteLattice Œ≤] {f : Filter Œ±} {u : Œ± ‚Üí Œ≤} {x : Œ≤}\n    (h : ‚àÉ·∂† a in f, u a ‚â§ x) : liminf u f ‚â§ x := by\n  rw [liminf_eq]\n  refine sSup_le fun b hb => ?_\n  have hbx : ‚àÉ·∂† _ in f, b ‚â§ x := by\n    revert h\n    rw [‚Üê not_imp_not, not_frequently, not_frequently]\n    exact fun h => hb.mp (h.mono fun a hbx hba hax => hbx (hba.trans hax))\n  exact hbx.exists.choose_spec\n\n"}
{"name":"Filter.le_limsup_of_frequently_le'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_6\nŒ≤ : Type u_7\ninst‚úù : CompleteLattice Œ≤\nf : Filter Œ±\nu : Œ± ‚Üí Œ≤\nx : Œ≤\nh : Filter.Frequently (fun a => LE.le x (u a)) f\n‚ä¢ LE.le x (Filter.limsup u f)","decl":"theorem le_limsup_of_frequently_le' {Œ± Œ≤} [CompleteLattice Œ≤] {f : Filter Œ±} {u : Œ± ‚Üí Œ≤} {x : Œ≤}\n    (h : ‚àÉ·∂† a in f, x ‚â§ u a) : x ‚â§ limsup u f :=\n  liminf_le_of_frequently_le' (Œ≤ := Œ≤·µí·µà) h\n\n"}
{"name":"CompleteLatticeHom.apply_limsup_iterate","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : CompleteLattice Œ±\nf : CompleteLatticeHom Œ± Œ±\na : Œ±\n‚ä¢ Eq (f (Filter.limsup (fun n => Nat.iterate (‚áëf) n a) Filter.atTop)) (Filter.limsup (fun n => Nat.iterate (‚áëf) n a) Filter.atTop)","decl":"/-- If `f : Œ± ‚Üí Œ±` is a morphism of complete lattices, then the limsup of its iterates of any\n`a : Œ±` is a fixed point. -/\n@[simp]\ntheorem _root_.CompleteLatticeHom.apply_limsup_iterate (f : CompleteLatticeHom Œ± Œ±) (a : Œ±) :\n    f (limsup (fun n => f^[n] a) atTop) = limsup (fun n => f^[n] a) atTop := by\n  rw [limsup_eq_iInf_iSup_of_nat', map_iInf]\n  simp_rw [_root_.map_iSup, ‚Üê Function.comp_apply (f := f), ‚Üê Function.iterate_succ' f,\n    ‚Üê Nat.add_succ]\n  conv_rhs => rw [iInf_split _ (0 < ¬∑)]\n  simp only [not_lt, Nat.le_zero, iInf_iInf_eq_left, add_zero, iInf_nat_gt_zero_eq, left_eq_inf]\n  refine (iInf_le (fun i => ‚®Ü j, f^[j + (i + 1)] a) 0).trans ?_\n  simp only [zero_add, Function.comp_apply, iSup_le_iff]\n  exact fun i => le_iSup (fun i => f^[i] a) (i + 1)\n\n"}
{"name":"CompleteLatticeHom.apply_liminf_iterate","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : CompleteLattice Œ±\nf : CompleteLatticeHom Œ± Œ±\na : Œ±\n‚ä¢ Eq (f (Filter.liminf (fun n => Nat.iterate (‚áëf) n a) Filter.atTop)) (Filter.liminf (fun n => Nat.iterate (‚áëf) n a) Filter.atTop)","decl":"/-- If `f : Œ± ‚Üí Œ±` is a morphism of complete lattices, then the liminf of its iterates of any\n`a : Œ±` is a fixed point. -/\ntheorem _root_.CompleteLatticeHom.apply_liminf_iterate (f : CompleteLatticeHom Œ± Œ±) (a : Œ±) :\n    f (liminf (fun n => f^[n] a) atTop) = liminf (fun n => f^[n] a) atTop :=\n  (CompleteLatticeHom.dual f).apply_limsup_iterate _\n\n"}
{"name":"Filter.blimsup_mono","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np q : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\nh : ‚àÄ (x : Œ≤), p x ‚Üí q x\n‚ä¢ LE.le (Filter.blimsup u f p) (Filter.blimsup u f q)","decl":"theorem blimsup_mono (h : ‚àÄ x, p x ‚Üí q x) : blimsup u f p ‚â§ blimsup u f q :=\n  sInf_le_sInf fun a ha => ha.mono <| by tauto\n\n"}
{"name":"Filter.bliminf_antitone","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np q : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\nh : ‚àÄ (x : Œ≤), p x ‚Üí q x\n‚ä¢ LE.le (Filter.bliminf u f q) (Filter.bliminf u f p)","decl":"theorem bliminf_antitone (h : ‚àÄ x, p x ‚Üí q x) : bliminf u f q ‚â§ bliminf u f p :=\n  sSup_le_sSup fun a ha => ha.mono <| by tauto\n\n"}
{"name":"Filter.mono_blimsup'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np : Œ≤ ‚Üí Prop\nu v : Œ≤ ‚Üí Œ±\nh : Filter.Eventually (fun x => p x ‚Üí LE.le (u x) (v x)) f\n‚ä¢ LE.le (Filter.blimsup u f p) (Filter.blimsup v f p)","decl":"theorem mono_blimsup' (h : ‚àÄ·∂† x in f, p x ‚Üí u x ‚â§ v x) : blimsup u f p ‚â§ blimsup v f p :=\n  sInf_le_sInf fun _ ha => (ha.and h).mono fun _ hx hx' => (hx.2 hx').trans (hx.1 hx')\n\n"}
{"name":"Filter.mono_blimsup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np : Œ≤ ‚Üí Prop\nu v : Œ≤ ‚Üí Œ±\nh : ‚àÄ (x : Œ≤), p x ‚Üí LE.le (u x) (v x)\n‚ä¢ LE.le (Filter.blimsup u f p) (Filter.blimsup v f p)","decl":"theorem mono_blimsup (h : ‚àÄ x, p x ‚Üí u x ‚â§ v x) : blimsup u f p ‚â§ blimsup v f p :=\n  mono_blimsup' <| Eventually.of_forall h\n\n"}
{"name":"Filter.mono_bliminf'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np : Œ≤ ‚Üí Prop\nu v : Œ≤ ‚Üí Œ±\nh : Filter.Eventually (fun x => p x ‚Üí LE.le (u x) (v x)) f\n‚ä¢ LE.le (Filter.bliminf u f p) (Filter.bliminf v f p)","decl":"theorem mono_bliminf' (h : ‚àÄ·∂† x in f, p x ‚Üí u x ‚â§ v x) : bliminf u f p ‚â§ bliminf v f p :=\n  sSup_le_sSup fun _ ha => (ha.and h).mono fun _ hx hx' => (hx.1 hx').trans (hx.2 hx')\n\n"}
{"name":"Filter.mono_bliminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np : Œ≤ ‚Üí Prop\nu v : Œ≤ ‚Üí Œ±\nh : ‚àÄ (x : Œ≤), p x ‚Üí LE.le (u x) (v x)\n‚ä¢ LE.le (Filter.bliminf u f p) (Filter.bliminf v f p)","decl":"theorem mono_bliminf (h : ‚àÄ x, p x ‚Üí u x ‚â§ v x) : bliminf u f p ‚â§ bliminf v f p :=\n  mono_bliminf' <| Eventually.of_forall h\n\n"}
{"name":"Filter.bliminf_antitone_filter","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf g : Filter Œ≤\np : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\nh : LE.le f g\n‚ä¢ LE.le (Filter.bliminf u g p) (Filter.bliminf u f p)","decl":"theorem bliminf_antitone_filter (h : f ‚â§ g) : bliminf u g p ‚â§ bliminf u f p :=\n  sSup_le_sSup fun _ ha => ha.filter_mono h\n\n"}
{"name":"Filter.blimsup_monotone_filter","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf g : Filter Œ≤\np : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\nh : LE.le f g\n‚ä¢ LE.le (Filter.blimsup u f p) (Filter.blimsup u g p)","decl":"theorem blimsup_monotone_filter (h : f ‚â§ g) : blimsup u f p ‚â§ blimsup u g p :=\n  sInf_le_sInf fun _ ha => ha.filter_mono h\n\n-- @[simp] -- Porting note: simp_nf linter, lhs simplifies, added _aux versions below\n"}
{"name":"Filter.blimsup_and_le_inf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np q : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\n‚ä¢ LE.le (Filter.blimsup u f fun x => And (p x) (q x)) (Min.min (Filter.blimsup u f p) (Filter.blimsup u f q))","decl":"theorem blimsup_and_le_inf : (blimsup u f fun x => p x ‚àß q x) ‚â§ blimsup u f p ‚äì blimsup u f q :=\n  le_inf (blimsup_mono <| by tauto) (blimsup_mono <| by tauto)\n\n"}
{"name":"Filter.bliminf_sup_le_inf_aux_left","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np q : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\n‚ä¢ LE.le (Filter.blimsup u f fun x => And (p x) (q x)) (Filter.blimsup u f p)","decl":"@[simp]\ntheorem bliminf_sup_le_inf_aux_left :\n    (blimsup u f fun x => p x ‚àß q x) ‚â§ blimsup u f p :=\n  blimsup_and_le_inf.trans inf_le_left\n\n"}
{"name":"Filter.bliminf_sup_le_inf_aux_right","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np q : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\n‚ä¢ LE.le (Filter.blimsup u f fun x => And (p x) (q x)) (Filter.blimsup u f q)","decl":"@[simp]\ntheorem bliminf_sup_le_inf_aux_right :\n    (blimsup u f fun x => p x ‚àß q x) ‚â§ blimsup u f q :=\n  blimsup_and_le_inf.trans inf_le_right\n\n-- @[simp] -- Porting note: simp_nf linter, lhs simplifies, added _aux simp version below\n"}
{"name":"Filter.bliminf_sup_le_and","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np q : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\n‚ä¢ LE.le (Max.max (Filter.bliminf u f p) (Filter.bliminf u f q)) (Filter.bliminf u f fun x => And (p x) (q x))","decl":"theorem bliminf_sup_le_and : bliminf u f p ‚äî bliminf u f q ‚â§ bliminf u f fun x => p x ‚àß q x :=\n  blimsup_and_le_inf (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.bliminf_sup_le_and_aux_left","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np q : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\n‚ä¢ LE.le (Filter.bliminf u f p) (Filter.bliminf u f fun x => And (p x) (q x))","decl":"@[simp]\ntheorem bliminf_sup_le_and_aux_left : bliminf u f p ‚â§ bliminf u f fun x => p x ‚àß q x :=\n  le_sup_left.trans bliminf_sup_le_and\n\n"}
{"name":"Filter.bliminf_sup_le_and_aux_right","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np q : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\n‚ä¢ LE.le (Filter.bliminf u f q) (Filter.bliminf u f fun x => And (p x) (q x))","decl":"@[simp]\ntheorem bliminf_sup_le_and_aux_right : bliminf u f q ‚â§ bliminf u f fun x => p x ‚àß q x :=\n  le_sup_right.trans bliminf_sup_le_and\n\n"}
{"name":"Filter.blimsup_sup_le_or","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np q : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\n‚ä¢ LE.le (Max.max (Filter.blimsup u f p) (Filter.blimsup u f q)) (Filter.blimsup u f fun x => Or (p x) (q x))","decl":"/-- See also `Filter.blimsup_or_eq_sup`. -/\n-- @[simp] -- Porting note: simp_nf linter, lhs simplifies, added _aux simp versions below\ntheorem blimsup_sup_le_or : blimsup u f p ‚äî blimsup u f q ‚â§ blimsup u f fun x => p x ‚à® q x :=\n  sup_le (blimsup_mono <| by tauto) (blimsup_mono <| by tauto)\n\n"}
{"name":"Filter.bliminf_sup_le_or_aux_left","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np q : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\n‚ä¢ LE.le (Filter.blimsup u f p) (Filter.blimsup u f fun x => Or (p x) (q x))","decl":"@[simp]\ntheorem bliminf_sup_le_or_aux_left : blimsup u f p ‚â§ blimsup u f fun x => p x ‚à® q x :=\n  le_sup_left.trans blimsup_sup_le_or\n\n"}
{"name":"Filter.bliminf_sup_le_or_aux_right","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np q : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\n‚ä¢ LE.le (Filter.blimsup u f q) (Filter.blimsup u f fun x => Or (p x) (q x))","decl":"@[simp]\ntheorem bliminf_sup_le_or_aux_right : blimsup u f q ‚â§ blimsup u f fun x => p x ‚à® q x :=\n  le_sup_right.trans blimsup_sup_le_or\n\n"}
{"name":"Filter.bliminf_or_le_inf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np q : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\n‚ä¢ LE.le (Filter.bliminf u f fun x => Or (p x) (q x)) (Min.min (Filter.bliminf u f p) (Filter.bliminf u f q))","decl":"/-- See also `Filter.bliminf_or_eq_inf`. -/\n--@[simp] -- Porting note: simp_nf linter, lhs simplifies, added _aux simp versions below\ntheorem bliminf_or_le_inf : (bliminf u f fun x => p x ‚à® q x) ‚â§ bliminf u f p ‚äì bliminf u f q :=\n  blimsup_sup_le_or (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.bliminf_or_le_inf_aux_left","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np q : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\n‚ä¢ LE.le (Filter.bliminf u f fun x => Or (p x) (q x)) (Filter.bliminf u f p)","decl":"@[simp]\ntheorem bliminf_or_le_inf_aux_left : (bliminf u f fun x => p x ‚à® q x) ‚â§ bliminf u f p :=\n  bliminf_or_le_inf.trans inf_le_left\n\n"}
{"name":"Filter.bliminf_or_le_inf_aux_right","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteLattice Œ±\nf : Filter Œ≤\np q : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\n‚ä¢ LE.le (Filter.bliminf u f fun x => Or (p x) (q x)) (Filter.bliminf u f q)","decl":"@[simp]\ntheorem bliminf_or_le_inf_aux_right : (bliminf u f fun x => p x ‚à® q x) ‚â§ bliminf u f q :=\n  bliminf_or_le_inf.trans inf_le_right\n\n"}
{"name":"OrderIso.apply_blimsup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬π : CompleteLattice Œ±\nf : Filter Œ≤\np : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\ninst‚úù : CompleteLattice Œ≥\ne : OrderIso Œ± Œ≥\n‚ä¢ Eq (e (Filter.blimsup u f p)) (Filter.blimsup (Function.comp (‚áëe) u) f p)","decl":"theorem _root_.OrderIso.apply_blimsup [CompleteLattice Œ≥] (e : Œ± ‚âÉo Œ≥) :\n    e (blimsup u f p) = blimsup (e ‚àò u) f p := by\n  simp only [blimsup_eq, map_sInf, Function.comp_apply, e.image_eq_preimage,\n    Set.preimage_setOf_eq, e.le_symm_apply]\n\n"}
{"name":"OrderIso.apply_bliminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬π : CompleteLattice Œ±\nf : Filter Œ≤\np : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\ninst‚úù : CompleteLattice Œ≥\ne : OrderIso Œ± Œ≥\n‚ä¢ Eq (e (Filter.bliminf u f p)) (Filter.bliminf (Function.comp (‚áëe) u) f p)","decl":"theorem _root_.OrderIso.apply_bliminf [CompleteLattice Œ≥] (e : Œ± ‚âÉo Œ≥) :\n    e (bliminf u f p) = bliminf (e ‚àò u) f p :=\n  e.dual.apply_blimsup\n\n"}
{"name":"sSupHom.apply_blimsup_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬π : CompleteLattice Œ±\nf : Filter Œ≤\np : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\ninst‚úù : CompleteLattice Œ≥\ng : sSupHom Œ± Œ≥\n‚ä¢ LE.le (g (Filter.blimsup u f p)) (Filter.blimsup (Function.comp (‚áëg) u) f p)","decl":"theorem _root_.sSupHom.apply_blimsup_le [CompleteLattice Œ≥] (g : sSupHom Œ± Œ≥) :\n    g (blimsup u f p) ‚â§ blimsup (g ‚àò u) f p := by\n  simp only [blimsup_eq_iInf_biSup, Function.comp]\n  refine ((OrderHomClass.mono g).map_iInf‚ÇÇ_le _).trans ?_\n  simp only [_root_.map_iSup, le_refl]\n\n"}
{"name":"sInfHom.le_apply_bliminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬π : CompleteLattice Œ±\nf : Filter Œ≤\np : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\ninst‚úù : CompleteLattice Œ≥\ng : sInfHom Œ± Œ≥\n‚ä¢ LE.le (Filter.bliminf (Function.comp (‚áëg) u) f p) (g (Filter.bliminf u f p))","decl":"theorem _root_.sInfHom.le_apply_bliminf [CompleteLattice Œ≥] (g : sInfHom Œ± Œ≥) :\n    bliminf (g ‚àò u) f p ‚â§ g (bliminf u f p) :=\n  (sInfHom.dual g).apply_blimsup_le\n\n"}
{"name":"Filter.limsup_sup_filter","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteDistribLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\ng : Filter Œ≤\n‚ä¢ Eq (Filter.limsup u (Max.max f g)) (Max.max (Filter.limsup u f) (Filter.limsup u g))","decl":"lemma limsup_sup_filter {g} : limsup u (f ‚äî g) = limsup u f ‚äî limsup u g := by\n  refine le_antisymm ?_\n    (sup_le (limsup_le_limsup_of_le le_sup_left) (limsup_le_limsup_of_le le_sup_right))\n  simp_rw [limsup_eq, sInf_sup_eq, sup_sInf_eq, mem_setOf_eq, le_iInf‚ÇÇ_iff]\n  intro a ha b hb\n  exact sInf_le ‚ü®ha.mono fun _ h ‚Ü¶ h.trans le_sup_left, hb.mono fun _ h ‚Ü¶ h.trans le_sup_right‚ü©\n\n"}
{"name":"Filter.liminf_sup_filter","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteDistribLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\ng : Filter Œ≤\n‚ä¢ Eq (Filter.liminf u (Max.max f g)) (Min.min (Filter.liminf u f) (Filter.liminf u g))","decl":"lemma liminf_sup_filter {g} : liminf u (f ‚äî g) = liminf u f ‚äì liminf u g :=\n  limsup_sup_filter (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.blimsup_or_eq_sup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteDistribLattice Œ±\nf : Filter Œ≤\np q : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Filter.blimsup u f fun x => Or (p x) (q x)) (Max.max (Filter.blimsup u f p) (Filter.blimsup u f q))","decl":"@[simp]\ntheorem blimsup_or_eq_sup : (blimsup u f fun x => p x ‚à® q x) = blimsup u f p ‚äî blimsup u f q := by\n  simp only [blimsup_eq_limsup, ‚Üê limsup_sup_filter, ‚Üê inf_sup_left, sup_principal, setOf_or]\n\n"}
{"name":"Filter.bliminf_or_eq_inf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteDistribLattice Œ±\nf : Filter Œ≤\np q : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Filter.bliminf u f fun x => Or (p x) (q x)) (Min.min (Filter.bliminf u f p) (Filter.bliminf u f q))","decl":"@[simp]\ntheorem bliminf_or_eq_inf : (bliminf u f fun x => p x ‚à® q x) = bliminf u f p ‚äì bliminf u f q :=\n  blimsup_or_eq_sup (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.blimsup_sup_not","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteDistribLattice Œ±\nf : Filter Œ≤\np : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Max.max (Filter.blimsup u f p) (Filter.blimsup u f fun x => Not (p x))) (Filter.limsup u f)","decl":"@[simp]\nlemma blimsup_sup_not : blimsup u f p ‚äî blimsup u f (¬¨p ¬∑) = limsup u f := by\n  simp_rw [‚Üê blimsup_or_eq_sup, or_not, blimsup_true]\n\n"}
{"name":"Filter.bliminf_inf_not","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteDistribLattice Œ±\nf : Filter Œ≤\np : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Min.min (Filter.bliminf u f p) (Filter.bliminf u f fun x => Not (p x))) (Filter.liminf u f)","decl":"@[simp]\nlemma bliminf_inf_not : bliminf u f p ‚äì bliminf u f (¬¨p ¬∑) = liminf u f :=\n  blimsup_sup_not (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.blimsup_not_sup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteDistribLattice Œ±\nf : Filter Œ≤\np : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Max.max (Filter.blimsup u f fun x => Not (p x)) (Filter.blimsup u f p)) (Filter.limsup u f)","decl":"@[simp]\nlemma blimsup_not_sup : blimsup u f (¬¨p ¬∑) ‚äî blimsup u f p = limsup u f := by\n  simpa only [not_not] using blimsup_sup_not (p := (¬¨p ¬∑))\n\n"}
{"name":"Filter.bliminf_not_inf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteDistribLattice Œ±\nf : Filter Œ≤\np : Œ≤ ‚Üí Prop\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Min.min (Filter.bliminf u f fun x => Not (p x)) (Filter.bliminf u f p)) (Filter.liminf u f)","decl":"@[simp]\nlemma bliminf_not_inf : bliminf u f (¬¨p ¬∑) ‚äì bliminf u f p = liminf u f :=\n  blimsup_not_sup (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.limsup_piecewise","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : CompleteDistribLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\ns : Set Œ≤\ninst‚úù : DecidablePred fun x => Membership.mem s x\nv : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Filter.limsup (s.piecewise u v) f) (Max.max (Filter.blimsup u f fun x => Membership.mem s x) (Filter.blimsup v f fun x => Not (Membership.mem s x)))","decl":"lemma limsup_piecewise {s : Set Œ≤} [DecidablePred (¬∑ ‚àà s)] {v} :\n    limsup (s.piecewise u v) f = blimsup u f (¬∑ ‚àà s) ‚äî blimsup v f (¬∑ ‚àâ s) := by\n  rw [‚Üê blimsup_sup_not (p := (¬∑ ‚àà s))]\n  refine congr_arg‚ÇÇ _ (blimsup_congr ?_) (blimsup_congr ?_) <;>\n    filter_upwards with _ h using by simp [h]\n\n"}
{"name":"Filter.liminf_piecewise","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : CompleteDistribLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\ns : Set Œ≤\ninst‚úù : DecidablePred fun x => Membership.mem s x\nv : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (Filter.liminf (s.piecewise u v) f) (Min.min (Filter.bliminf u f fun x => Membership.mem s x) (Filter.bliminf v f fun x => Not (Membership.mem s x)))","decl":"lemma liminf_piecewise {s : Set Œ≤} [DecidablePred (¬∑ ‚àà s)] {v} :\n    liminf (s.piecewise u v) f = bliminf u f (¬∑ ‚àà s) ‚äì bliminf v f (¬∑ ‚àâ s) :=\n  limsup_piecewise (Œ± := Œ±·µí·µà)\n\n"}
{"name":"Filter.sup_limsup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : CompleteDistribLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\ninst‚úù : f.NeBot\na : Œ±\n‚ä¢ Eq (Max.max a (Filter.limsup u f)) (Filter.limsup (fun x => Max.max a (u x)) f)","decl":"theorem sup_limsup [NeBot f] (a : Œ±) : a ‚äî limsup u f = limsup (fun x => a ‚äî u x) f := by\n  simp only [limsup_eq_iInf_iSup, iSup_sup_eq, sup_iInf‚ÇÇ_eq]\n  congr; ext s; congr; ext hs; congr\n  exact (biSup_const (nonempty_of_mem hs)).symm\n\n"}
{"name":"Filter.inf_liminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : CompleteDistribLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\ninst‚úù : f.NeBot\na : Œ±\n‚ä¢ Eq (Min.min a (Filter.liminf u f)) (Filter.liminf (fun x => Min.min a (u x)) f)","decl":"theorem inf_liminf [NeBot f] (a : Œ±) : a ‚äì liminf u f = liminf (fun x => a ‚äì u x) f :=\n  sup_limsup (Œ± := Œ±·µí·µà) a\n\n"}
{"name":"Filter.sup_liminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteDistribLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\na : Œ±\n‚ä¢ Eq (Max.max a (Filter.liminf u f)) (Filter.liminf (fun x => Max.max a (u x)) f)","decl":"theorem sup_liminf (a : Œ±) : a ‚äî liminf u f = liminf (fun x => a ‚äî u x) f := by\n  simp only [liminf_eq_iSup_iInf]\n  rw [sup_comm, biSup_sup (‚ü®univ, univ_mem‚ü© : ‚àÉ i : Set Œ≤, i ‚àà f)]\n  simp_rw [iInf‚ÇÇ_sup_eq, sup_comm (a := a)]\n\n"}
{"name":"Filter.inf_limsup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteDistribLattice Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\na : Œ±\n‚ä¢ Eq (Min.min a (Filter.limsup u f)) (Filter.limsup (fun x => Min.min a (u x)) f)","decl":"theorem inf_limsup (a : Œ±) : a ‚äì limsup u f = limsup (fun x => a ‚äì u x) f :=\n  sup_liminf (Œ± := Œ±·µí·µà) a\n\n"}
{"name":"Filter.limsup_compl","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteBooleanAlgebra Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (HasCompl.compl (Filter.limsup u f)) (Filter.liminf (Function.comp HasCompl.compl u) f)","decl":"theorem limsup_compl : (limsup u f)·∂ú = liminf (compl ‚àò u) f := by\n  simp only [limsup_eq_iInf_iSup, compl_iInf, compl_iSup, liminf_eq_iSup_iInf, Function.comp_apply]\n\n"}
{"name":"Filter.liminf_compl","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteBooleanAlgebra Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\n‚ä¢ Eq (HasCompl.compl (Filter.liminf u f)) (Filter.limsup (Function.comp HasCompl.compl u) f)","decl":"theorem liminf_compl : (liminf u f)·∂ú = limsup (compl ‚àò u) f := by\n  simp only [limsup_eq_iInf_iSup, compl_iInf, compl_iSup, liminf_eq_iSup_iInf, Function.comp_apply]\n\n"}
{"name":"Filter.limsup_sdiff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteBooleanAlgebra Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\na : Œ±\n‚ä¢ Eq (SDiff.sdiff (Filter.limsup u f) a) (Filter.limsup (fun b => SDiff.sdiff (u b) a) f)","decl":"theorem limsup_sdiff (a : Œ±) : limsup u f \\ a = limsup (fun b => u b \\ a) f := by\n  simp only [limsup_eq_iInf_iSup, sdiff_eq]\n  rw [biInf_inf (‚ü®univ, univ_mem‚ü© : ‚àÉ i : Set Œ≤, i ‚àà f)]\n  simp_rw [inf_comm, inf_iSup‚ÇÇ_eq, inf_comm]\n\n"}
{"name":"Filter.liminf_sdiff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : CompleteBooleanAlgebra Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\ninst‚úù : f.NeBot\na : Œ±\n‚ä¢ Eq (SDiff.sdiff (Filter.liminf u f) a) (Filter.liminf (fun b => SDiff.sdiff (u b) a) f)","decl":"theorem liminf_sdiff [NeBot f] (a : Œ±) : liminf u f \\ a = liminf (fun b => u b \\ a) f := by\n  simp only [sdiff_eq, inf_comm _ a·∂ú, inf_liminf]\n\n"}
{"name":"Filter.sdiff_limsup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : CompleteBooleanAlgebra Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\ninst‚úù : f.NeBot\na : Œ±\n‚ä¢ Eq (SDiff.sdiff a (Filter.limsup u f)) (Filter.liminf (fun b => SDiff.sdiff a (u b)) f)","decl":"theorem sdiff_limsup [NeBot f] (a : Œ±) : a \\ limsup u f = liminf (fun b => a \\ u b) f := by\n  rw [‚Üê compl_inj_iff]\n  simp only [sdiff_eq, liminf_compl, comp_def, compl_inf, compl_compl, sup_limsup]\n\n"}
{"name":"Filter.sdiff_liminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : CompleteBooleanAlgebra Œ±\nf : Filter Œ≤\nu : Œ≤ ‚Üí Œ±\na : Œ±\n‚ä¢ Eq (SDiff.sdiff a (Filter.liminf u f)) (Filter.limsup (fun b => SDiff.sdiff a (u b)) f)","decl":"theorem sdiff_liminf (a : Œ±) : a \\ liminf u f = limsup (fun b => a \\ u b) f := by\n  rw [‚Üê compl_inj_iff]\n  simp only [sdiff_eq, limsup_compl, comp_def, compl_inf, compl_compl, sup_liminf]\n\n"}
{"name":"Filter.mem_liminf_iff_eventually_mem","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\ns : Œπ ‚Üí Set Œ±\nùìï : Filter Œπ\na : Œ±\n‚ä¢ Iff (Membership.mem (Filter.liminf s ùìï) a) (Filter.Eventually (fun i => Membership.mem (s i) a) ùìï)","decl":"lemma mem_liminf_iff_eventually_mem : (a ‚àà liminf s ùìï) ‚Üî (‚àÄ·∂† i in ùìï, a ‚àà s i) := by\n  simpa only [liminf_eq_iSup_iInf, iSup_eq_iUnion, iInf_eq_iInter, mem_iUnion, mem_iInter]\n    using ‚ü®fun ‚ü®S, hS, hS'‚ü© ‚Ü¶ mem_of_superset hS (by tauto), fun h ‚Ü¶ ‚ü®{i | a ‚àà s i}, h, by tauto‚ü©‚ü©\n\n"}
{"name":"Filter.mem_limsup_iff_frequently_mem","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\ns : Œπ ‚Üí Set Œ±\nùìï : Filter Œπ\na : Œ±\n‚ä¢ Iff (Membership.mem (Filter.limsup s ùìï) a) (Filter.Frequently (fun i => Membership.mem (s i) a) ùìï)","decl":"lemma mem_limsup_iff_frequently_mem : (a ‚àà limsup s ùìï) ‚Üî (‚àÉ·∂† i in ùìï, a ‚àà s i) := by\n  simp only [Filter.Frequently, iff_not_comm, ‚Üê mem_compl_iff, limsup_compl, comp_apply,\n    mem_liminf_iff_eventually_mem]\n\n"}
{"name":"Filter.cofinite.blimsup_set_eq","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set Œ±\n‚ä¢ Eq (Filter.blimsup s Filter.cofinite p) (setOf fun x => (setOf fun n => And (p n) (Membership.mem (s n) x)).Infinite)","decl":"theorem cofinite.blimsup_set_eq :\n    blimsup s cofinite p = { x | { n | p n ‚àß x ‚àà s n }.Infinite } := by\n  simp only [blimsup_eq, le_eq_subset, eventually_cofinite, not_forall, sInf_eq_sInter, exists_prop]\n  ext x\n  refine ‚ü®fun h => ?_, fun hx t h => ?_‚ü© <;> contrapose! h\n  ¬∑ simp only [mem_sInter, mem_setOf_eq, not_forall, exists_prop]\n    exact ‚ü®{x}·∂ú, by simpa using h, by simp‚ü©\n  ¬∑ exact hx.mono fun i hi => ‚ü®hi.1, fun hit => h (hit hi.2)‚ü©\n\n"}
{"name":"Filter.cofinite.bliminf_set_eq","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set Œ±\n‚ä¢ Eq (Filter.bliminf s Filter.cofinite p) (setOf fun x => (setOf fun n => And (p n) (Not (Membership.mem (s n) x))).Finite)","decl":"theorem cofinite.bliminf_set_eq : bliminf s cofinite p = { x | { n | p n ‚àß x ‚àâ s n }.Finite } := by\n  rw [‚Üê compl_inj_iff]\n  simp only [bliminf_eq_iSup_biInf, compl_iInf, compl_iSup, ‚Üê blimsup_eq_iInf_biSup,\n    cofinite.blimsup_set_eq]\n  rfl\n\n"}
{"name":"Filter.cofinite.limsup_set_eq","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\ns : Œπ ‚Üí Set Œ±\n‚ä¢ Eq (Filter.limsup s Filter.cofinite) (setOf fun x => (setOf fun n => Membership.mem (s n) x).Infinite)","decl":"/-- In other words, `limsup cofinite s` is the set of elements lying inside the family `s`\ninfinitely often. -/\ntheorem cofinite.limsup_set_eq : limsup s cofinite = { x | { n | x ‚àà s n }.Infinite } := by\n  simp only [‚Üê cofinite.blimsup_true s, cofinite.blimsup_set_eq, true_and]\n\n"}
{"name":"Filter.cofinite.liminf_set_eq","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\ns : Œπ ‚Üí Set Œ±\n‚ä¢ Eq (Filter.liminf s Filter.cofinite) (setOf fun x => (setOf fun n => Not (Membership.mem (s n) x)).Finite)","decl":"/-- In other words, `liminf cofinite s` is the set of elements lying outside the family `s`\nfinitely often. -/\ntheorem cofinite.liminf_set_eq : liminf s cofinite = { x | { n | x ‚àâ s n }.Finite } := by\n  simp only [‚Üê cofinite.bliminf_true s, cofinite.bliminf_set_eq, true_and]\n\n"}
{"name":"Filter.exists_forall_mem_of_hasBasis_mem_blimsup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_4\nl : Filter Œ≤\nb : Œπ ‚Üí Set Œ≤\nq : Œπ ‚Üí Prop\nhl : l.HasBasis q b\nu : Œ≤ ‚Üí Set Œ±\np : Œ≤ ‚Üí Prop\nx : Œ±\nhx : Membership.mem (Filter.blimsup u l p) x\n‚ä¢ Exists fun f => ‚àÄ (i : ‚Üë(setOf fun i => q i)), And (Membership.mem (u (f i)) x) (And (p (f i)) (Membership.mem (b ‚Üëi) (f i)))","decl":"theorem exists_forall_mem_of_hasBasis_mem_blimsup {l : Filter Œ≤} {b : Œπ ‚Üí Set Œ≤} {q : Œπ ‚Üí Prop}\n    (hl : l.HasBasis q b) {u : Œ≤ ‚Üí Set Œ±} {p : Œ≤ ‚Üí Prop} {x : Œ±} (hx : x ‚àà blimsup u l p) :\n    ‚àÉ f : { i | q i } ‚Üí Œ≤, ‚àÄ i, x ‚àà u (f i) ‚àß p (f i) ‚àß f i ‚àà b i := by\n  rw [blimsup_eq_iInf_biSup] at hx\n  simp only [iSup_eq_iUnion, iInf_eq_iInter, mem_iInter, mem_iUnion, exists_prop] at hx\n  choose g hg hg' using hx\n  refine ‚ü®fun i : { i | q i } => g (b i) (hl.mem_of_mem i.2), fun i => ‚ü®?_, ?_‚ü©‚ü©\n  ¬∑ exact hg' (b i) (hl.mem_of_mem i.2)\n  ¬∑ exact hg (b i) (hl.mem_of_mem i.2)\n\n"}
{"name":"Filter.exists_forall_mem_of_hasBasis_mem_blimsup'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_4\nl : Filter Œ≤\nb : Œπ ‚Üí Set Œ≤\nhl : l.HasBasis (fun x => True) b\nu : Œ≤ ‚Üí Set Œ±\np : Œ≤ ‚Üí Prop\nx : Œ±\nhx : Membership.mem (Filter.blimsup u l p) x\n‚ä¢ Exists fun f => ‚àÄ (i : Œπ), And (Membership.mem (u (f i)) x) (And (p (f i)) (Membership.mem (b i) (f i)))","decl":"theorem exists_forall_mem_of_hasBasis_mem_blimsup' {l : Filter Œ≤} {b : Œπ ‚Üí Set Œ≤}\n    (hl : l.HasBasis (fun _ => True) b) {u : Œ≤ ‚Üí Set Œ±} {p : Œ≤ ‚Üí Prop} {x : Œ±}\n    (hx : x ‚àà blimsup u l p) : ‚àÉ f : Œπ ‚Üí Œ≤, ‚àÄ i, x ‚àà u (f i) ‚àß p (f i) ‚àß f i ‚àà b i := by\n  obtain ‚ü®f, hf‚ü© := exists_forall_mem_of_hasBasis_mem_blimsup hl hx\n  exact ‚ü®fun i => f ‚ü®i, trivial‚ü©, fun i => hf ‚ü®i, trivial‚ü©‚ü©\n\n"}
{"name":"Filter.frequently_lt_of_lt_limsSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nf : Filter Œ±\ninst‚úù : ConditionallyCompleteLinearOrder Œ±\na : Œ±\nhf : autoParam (Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) f) _auto‚úù\nh : LT.lt a f.limsSup\n‚ä¢ Filter.Frequently (fun n => LT.lt a n) f","decl":"theorem frequently_lt_of_lt_limsSup {f : Filter Œ±} [ConditionallyCompleteLinearOrder Œ±] {a : Œ±}\n    (hf : f.IsCobounded (¬∑ ‚â§ ¬∑) := by isBoundedDefault)\n    (h : a < limsSup f) : ‚àÉ·∂† n in f, a < n := by\n  contrapose! h\n  simp only [not_frequently, not_lt] at h\n  exact limsSup_le_of_le hf h\n\n"}
{"name":"Filter.frequently_lt_of_limsInf_lt","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nf : Filter Œ±\ninst‚úù : ConditionallyCompleteLinearOrder Œ±\na : Œ±\nhf : autoParam (Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) f) _auto‚úù\nh : LT.lt f.limsInf a\n‚ä¢ Filter.Frequently (fun n => LT.lt n a) f","decl":"theorem frequently_lt_of_limsInf_lt {f : Filter Œ±} [ConditionallyCompleteLinearOrder Œ±] {a : Œ±}\n    (hf : f.IsCobounded (¬∑ ‚â• ¬∑) := by isBoundedDefault)\n    (h : limsInf f < a) : ‚àÉ·∂† n in f, n < a :=\n  frequently_lt_of_lt_limsSup (Œ± := OrderDual Œ±) hf h\n\n"}
{"name":"Filter.eventually_lt_of_lt_liminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ninst‚úù : ConditionallyCompleteLinearOrder Œ≤\nu : Œ± ‚Üí Œ≤\nb : Œ≤\nh : LT.lt b (Filter.liminf u f)\nhu : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto‚úù\n‚ä¢ Filter.Eventually (fun a => LT.lt b (u a)) f","decl":"theorem eventually_lt_of_lt_liminf {f : Filter Œ±} [ConditionallyCompleteLinearOrder Œ≤] {u : Œ± ‚Üí Œ≤}\n    {b : Œ≤} (h : b < liminf u f)\n    (hu : f.IsBoundedUnder (¬∑ ‚â• ¬∑) u := by isBoundedDefault) :\n    ‚àÄ·∂† a in f, b < u a := by\n  obtain ‚ü®c, hc, hbc‚ü© : ‚àÉ (c : Œ≤) (_ : c ‚àà { c : Œ≤ | ‚àÄ·∂† n : Œ± in f, c ‚â§ u n }), b < c := by\n    simp_rw [exists_prop]\n    exact exists_lt_of_lt_csSup hu h\n  exact hc.mono fun x hx => lt_of_lt_of_le hbc hx\n\n"}
{"name":"Filter.eventually_lt_of_limsup_lt","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ninst‚úù : ConditionallyCompleteLinearOrder Œ≤\nu : Œ± ‚Üí Œ≤\nb : Œ≤\nh : LT.lt (Filter.limsup u f) b\nhu : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto‚úù\n‚ä¢ Filter.Eventually (fun a => LT.lt (u a) b) f","decl":"theorem eventually_lt_of_limsup_lt {f : Filter Œ±} [ConditionallyCompleteLinearOrder Œ≤] {u : Œ± ‚Üí Œ≤}\n    {b : Œ≤} (h : limsup u f < b)\n    (hu : f.IsBoundedUnder (¬∑ ‚â§ ¬∑) u := by isBoundedDefault) :\n    ‚àÄ·∂† a in f, u a < b :=\n  eventually_lt_of_lt_liminf (Œ≤ := Œ≤·µí·µà) h hu\n\n"}
{"name":"Filter.eventually_lt_add_pos_of_limsup_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : AddMonoid Œ±\ninst‚úù : AddLeftStrictMono Œ±\nx Œµ : Œ±\nu : Œ≤ ‚Üí Œ±\nhu_bdd : Filter.IsBoundedUnder LE.le Filter.atTop u\nhu : LE.le (Filter.limsup u Filter.atTop) x\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Filter.Eventually (fun b => LT.lt (u b) (HAdd.hAdd x Œµ)) Filter.atTop","decl":"/-- If `Filter.limsup u atTop ‚â§ x`, then for all `Œµ > 0`, eventually we have `u b < x + Œµ`. -/\ntheorem eventually_lt_add_pos_of_limsup_le [Preorder Œ≤] [AddMonoid Œ±] [AddLeftStrictMono Œ±]\n    {x Œµ : Œ±} {u : Œ≤ ‚Üí Œ±} (hu_bdd : IsBoundedUnder LE.le atTop u) (hu : Filter.limsup u atTop ‚â§ x)\n    (hŒµ : 0 < Œµ) :\n    ‚àÄ·∂† b : Œ≤ in atTop, u b < x + Œµ :=\n  eventually_lt_of_limsup_lt (lt_of_le_of_lt hu (lt_add_of_pos_right x hŒµ)) hu_bdd\n\n"}
{"name":"Filter.eventually_add_neg_lt_of_le_liminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≥ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù¬≤ : Preorder Œ≤\ninst‚úù¬π : AddMonoid Œ±\ninst‚úù : AddLeftStrictMono Œ±\nx Œµ : Œ±\nu : Œ≤ ‚Üí Œ±\nhu_bdd : Filter.IsBoundedUnder GE.ge Filter.atTop u\nhu : LE.le x (Filter.liminf u Filter.atTop)\nhŒµ : LT.lt Œµ 0\n‚ä¢ Filter.Eventually (fun b => LT.lt (HAdd.hAdd x Œµ) (u b)) Filter.atTop","decl":"/-- If `x ‚â§ Filter.liminf u atTop`, then for all `Œµ < 0`, eventually we have `x + Œµ < u b`. -/\ntheorem eventually_add_neg_lt_of_le_liminf [Preorder Œ≤] [AddMonoid Œ±] [AddLeftStrictMono Œ±]\n    {x Œµ : Œ±} {u : Œ≤ ‚Üí Œ±} (hu_bdd : IsBoundedUnder GE.ge atTop u) (hu : x ‚â§ Filter.liminf u atTop )\n    (hŒµ : Œµ < 0) :\n    ‚àÄ·∂† b : Œ≤ in atTop, x + Œµ < u b :=\n  eventually_lt_of_lt_liminf (lt_of_lt_of_le (add_lt_of_neg_right x hŒµ) hu) hu_bdd\n\n"}
{"name":"Filter.exists_lt_of_limsup_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù¬π : AddMonoid Œ±\ninst‚úù : AddLeftStrictMono Œ±\nx Œµ : Œ±\nu : Nat ‚Üí Œ±\nhu_bdd : Filter.IsBoundedUnder LE.le Filter.atTop u\nhu : LE.le (Filter.limsup u Filter.atTop) x\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun n => LT.lt (u ‚Üën) (HAdd.hAdd x Œµ)","decl":"/-- If `Filter.limsup u atTop ‚â§ x`, then for all `Œµ > 0`, there exists a positive natural\n  number `n` such that `u n < x + Œµ`.  -/\ntheorem exists_lt_of_limsup_le [AddMonoid Œ±] [AddLeftStrictMono Œ±] {x Œµ : Œ±} {u : ‚Ñï ‚Üí Œ±}\n    (hu_bdd : IsBoundedUnder LE.le atTop u) (hu : Filter.limsup u atTop ‚â§ x) (hŒµ : 0 < Œµ) :\n    ‚àÉ n : PNat, u n < x + Œµ := by\n  have h : ‚àÄ·∂† n : ‚Ñï in atTop, u n < x + Œµ := eventually_lt_add_pos_of_limsup_le hu_bdd hu hŒµ\n  simp only [eventually_atTop] at h\n  obtain ‚ü®n, hn‚ü© := h\n  exact ‚ü®‚ü®n + 1, Nat.succ_pos _‚ü©, hn (n + 1) (Nat.le_succ _)‚ü©\n\n"}
{"name":"Filter.exists_lt_of_le_liminf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù¬≤ : ConditionallyCompleteLinearOrder Œ±\ninst‚úù¬π : AddMonoid Œ±\ninst‚úù : AddLeftStrictMono Œ±\nx Œµ : Œ±\nu : Nat ‚Üí Œ±\nhu_bdd : Filter.IsBoundedUnder GE.ge Filter.atTop u\nhu : LE.le x (Filter.liminf u Filter.atTop)\nhŒµ : LT.lt Œµ 0\n‚ä¢ Exists fun n => LT.lt (HAdd.hAdd x Œµ) (u ‚Üën)","decl":"/-- If `x ‚â§ Filter.liminf u atTop`, then for all `Œµ < 0`, there exists a positive natural\n  number `n` such that ` x + Œµ < u n`.  -/\ntheorem exists_lt_of_le_liminf [AddMonoid Œ±] [AddLeftStrictMono Œ±] {x Œµ : Œ±} {u : ‚Ñï ‚Üí Œ±}\n    (hu_bdd : IsBoundedUnder GE.ge atTop u) (hu : x ‚â§ Filter.liminf u atTop) (hŒµ : Œµ < 0) :\n    ‚àÉ n : PNat, x + Œµ < u n := by\n  have h : ‚àÄ·∂† n : ‚Ñï in atTop, x + Œµ < u n := eventually_add_neg_lt_of_le_liminf hu_bdd hu hŒµ\n  simp only [eventually_atTop] at h\n  obtain ‚ü®n, hn‚ü© := h\n  exact ‚ü®‚ü®n + 1, Nat.succ_pos _‚ü©, hn (n + 1) (Nat.le_succ _)‚ü©\n"}
{"name":"Filter.le_limsup_of_frequently_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_6\nŒ≤ : Type u_7\ninst‚úù : ConditionallyCompleteLinearOrder Œ≤\nf : Filter Œ±\nu : Œ± ‚Üí Œ≤\nb : Œ≤\nhu_le : Filter.Frequently (fun x => LE.le b (u x)) f\nhu : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto‚úù\n‚ä¢ LE.le b (Filter.limsup u f)","decl":"theorem le_limsup_of_frequently_le {Œ± Œ≤} [ConditionallyCompleteLinearOrder Œ≤] {f : Filter Œ±}\n    {u : Œ± ‚Üí Œ≤} {b : Œ≤} (hu_le : ‚àÉ·∂† x in f, b ‚â§ u x)\n    (hu : f.IsBoundedUnder (¬∑ ‚â§ ¬∑) u := by isBoundedDefault) :\n    b ‚â§ limsup u f := by\n  revert hu_le\n  rw [‚Üê not_imp_not, not_frequently]\n  simp_rw [‚Üê lt_iff_not_ge]\n  exact fun h => eventually_lt_of_limsup_lt h hu\n\n"}
{"name":"Filter.liminf_le_of_frequently_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_6\nŒ≤ : Type u_7\ninst‚úù : ConditionallyCompleteLinearOrder Œ≤\nf : Filter Œ±\nu : Œ± ‚Üí Œ≤\nb : Œ≤\nhu_le : Filter.Frequently (fun x => LE.le (u x) b) f\nhu : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto‚úù\n‚ä¢ LE.le (Filter.liminf u f) b","decl":"theorem liminf_le_of_frequently_le {Œ± Œ≤} [ConditionallyCompleteLinearOrder Œ≤] {f : Filter Œ±}\n    {u : Œ± ‚Üí Œ≤} {b : Œ≤} (hu_le : ‚àÉ·∂† x in f, u x ‚â§ b)\n    (hu : f.IsBoundedUnder (¬∑ ‚â• ¬∑) u := by isBoundedDefault) :\n    liminf u f ‚â§ b :=\n  le_limsup_of_frequently_le (Œ≤ := Œ≤·µí·µà) hu_le hu\n\n"}
{"name":"Filter.frequently_lt_of_lt_limsup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_6\nŒ≤ : Type u_7\ninst‚úù : ConditionallyCompleteLinearOrder Œ≤\nf : Filter Œ±\nu : Œ± ‚Üí Œ≤\nb : Œ≤\nhu : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto‚úù\nh : LT.lt b (Filter.limsup u f)\n‚ä¢ Filter.Frequently (fun x => LT.lt b (u x)) f","decl":"theorem frequently_lt_of_lt_limsup {Œ± Œ≤} [ConditionallyCompleteLinearOrder Œ≤] {f : Filter Œ±}\n    {u : Œ± ‚Üí Œ≤} {b : Œ≤}\n    (hu : f.IsCoboundedUnder (¬∑ ‚â§ ¬∑) u := by isBoundedDefault)\n    (h : b < limsup u f) : ‚àÉ·∂† x in f, b < u x := by\n  contrapose! h\n  apply limsSup_le_of_le hu\n  simpa using h\n\n"}
{"name":"Filter.frequently_lt_of_liminf_lt","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_6\nŒ≤ : Type u_7\ninst‚úù : ConditionallyCompleteLinearOrder Œ≤\nf : Filter Œ±\nu : Œ± ‚Üí Œ≤\nb : Œ≤\nhu : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto‚úù\nh : LT.lt (Filter.liminf u f) b\n‚ä¢ Filter.Frequently (fun x => LT.lt (u x) b) f","decl":"theorem frequently_lt_of_liminf_lt {Œ± Œ≤} [ConditionallyCompleteLinearOrder Œ≤] {f : Filter Œ±}\n    {u : Œ± ‚Üí Œ≤} {b : Œ≤}\n    (hu : f.IsCoboundedUnder (¬∑ ‚â• ¬∑) u := by isBoundedDefault)\n    (h : liminf u f < b) : ‚àÉ·∂† x in f, u x < b :=\n  frequently_lt_of_lt_limsup (Œ≤ := Œ≤·µí·µà) hu h\n\n"}
{"name":"Filter.limsup_le_iff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_6\nŒ≤ : Type u_7\ninst‚úù : ConditionallyCompleteLinearOrder Œ≤\nf : Filter Œ±\nu : Œ± ‚Üí Œ≤\nx : Œ≤\nh‚ÇÅ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto‚úù\nh‚ÇÇ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto‚úù\n‚ä¢ Iff (LE.le (Filter.limsup u f) x) (‚àÄ (y : Œ≤), GT.gt y x ‚Üí Filter.Eventually (fun a => LT.lt (u a) y) f)","decl":"theorem limsup_le_iff {Œ± Œ≤} [ConditionallyCompleteLinearOrder Œ≤] {f : Filter Œ±} {u : Œ± ‚Üí Œ≤} {x : Œ≤}\n    (h‚ÇÅ : f.IsCoboundedUnder (¬∑ ‚â§ ¬∑) u := by isBoundedDefault)\n    (h‚ÇÇ : f.IsBoundedUnder (¬∑ ‚â§ ¬∑) u := by isBoundedDefault) :\n    limsup u f ‚â§ x ‚Üî ‚àÄ y > x, ‚àÄ·∂† a in f, u a < y := by\n  refine ‚ü®fun h _ h' ‚Ü¶ eventually_lt_of_limsup_lt (lt_of_le_of_lt h h') h‚ÇÇ, fun h ‚Ü¶ ?_‚ü©\n  --Two cases: Either `x` is a cluster point from above, or it is not.\n  --In the first case, we use `forall_lt_iff_le'` and split an interval.\n  --In the second case, the function `u` must eventually be smaller or equal to `x`.\n  by_cases h' : ‚àÄ y > x, ‚àÉ z, x < z ‚àß z < y\n  ¬∑ rw [‚Üê forall_lt_iff_le']\n    intro y x_y\n    rcases h' y x_y with ‚ü®z, x_z, z_y‚ü©\n    exact lt_of_le_of_lt (limsup_le_of_le h‚ÇÅ ((h z x_z).mono (fun _ ‚Ü¶ le_of_lt))) z_y\n  ¬∑ apply limsup_le_of_le h‚ÇÅ\n    set_option push_neg.use_distrib true in push_neg at h'\n    rcases h' with ‚ü®z, x_z, hz‚ü©\n    exact (h z x_z).mono  <| fun w hw ‚Ü¶ (or_iff_left (not_le_of_lt hw)).1 (hz (u w))\n\n"}
{"name":"Filter.le_limsup_iff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_6\nŒ≤ : Type u_7\ninst‚úù : ConditionallyCompleteLinearOrder Œ≤\nf : Filter Œ±\nu : Œ± ‚Üí Œ≤\nx : Œ≤\nh‚ÇÅ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto‚úù\nh‚ÇÇ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto‚úù\n‚ä¢ Iff (LE.le x (Filter.limsup u f)) (‚àÄ (y : Œ≤), LT.lt y x ‚Üí Filter.Frequently (fun a => LT.lt y (u a)) f)","decl":"theorem le_limsup_iff {Œ± Œ≤} [ConditionallyCompleteLinearOrder Œ≤] {f : Filter Œ±} {u : Œ± ‚Üí Œ≤} {x : Œ≤}\n    (h‚ÇÅ : f.IsCoboundedUnder (¬∑ ‚â§ ¬∑) u := by isBoundedDefault)\n    (h‚ÇÇ : f.IsBoundedUnder (¬∑ ‚â§ ¬∑) u := by isBoundedDefault) :\n    x ‚â§ limsup u f ‚Üî ‚àÄ y < x, ‚àÉ·∂† a in f, y < u a := by\n  refine ‚ü®fun h _ h' ‚Ü¶ frequently_lt_of_lt_limsup h‚ÇÅ (lt_of_lt_of_le h' h), fun h ‚Ü¶ ?_‚ü©\n  --Two cases: Either `x` is a cluster point from below, or it is not.\n  --In the first case, we use `forall_lt_iff_le` and split an interval.\n  --In the second case, the function `u` must frequently be larger or equal to `x`.\n  by_cases h' : ‚àÄ y < x, ‚àÉ z, y < z ‚àß z < x\n  ¬∑ rw [‚Üê forall_lt_iff_le]\n    intro y y_x\n    rcases h' y y_x with ‚ü®z, y_z, z_x‚ü©\n    exact lt_of_lt_of_le y_z (le_limsup_of_frequently_le ((h z z_x).mono (fun _ ‚Ü¶ le_of_lt)) h‚ÇÇ)\n  ¬∑ apply le_limsup_of_frequently_le _ h‚ÇÇ\n    set_option push_neg.use_distrib true in push_neg at h'\n    rcases h' with ‚ü®z, z_x, hz‚ü©\n    exact (h z z_x).mono <| fun w hw ‚Ü¶ (or_iff_right (not_le_of_lt hw)).1 (hz (u w))\n\n"}
{"name":"Filter.le_liminf_iff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_6\nŒ≤ : Type u_7\ninst‚úù : ConditionallyCompleteLinearOrder Œ≤\nf : Filter Œ±\nu : Œ± ‚Üí Œ≤\nx : Œ≤\nh‚ÇÅ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto‚úù\nh‚ÇÇ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto‚úù\n‚ä¢ Iff (LE.le x (Filter.liminf u f)) (‚àÄ (y : Œ≤), LT.lt y x ‚Üí Filter.Eventually (fun a => LT.lt y (u a)) f)","decl":"theorem le_liminf_iff {Œ± Œ≤} [ConditionallyCompleteLinearOrder Œ≤] {f : Filter Œ±} {u : Œ± ‚Üí Œ≤} {x : Œ≤}\n    (h‚ÇÅ : f.IsCoboundedUnder (¬∑ ‚â• ¬∑) u := by isBoundedDefault)\n    (h‚ÇÇ : f.IsBoundedUnder (¬∑ ‚â• ¬∑) u := by isBoundedDefault) :\n    x ‚â§ liminf u f ‚Üî ‚àÄ y < x, ‚àÄ·∂† a in f, y < u a := limsup_le_iff (Œ≤ := Œ≤·µí·µà) h‚ÇÅ h‚ÇÇ\n\n"}
{"name":"Filter.liminf_le_iff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_6\nŒ≤ : Type u_7\ninst‚úù : ConditionallyCompleteLinearOrder Œ≤\nf : Filter Œ±\nu : Œ± ‚Üí Œ≤\nx : Œ≤\nh‚ÇÅ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto‚úù\nh‚ÇÇ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto‚úù\n‚ä¢ Iff (LE.le (Filter.liminf u f) x) (‚àÄ (y : Œ≤), GT.gt y x ‚Üí Filter.Frequently (fun a => LT.lt (u a) y) f)","decl":"theorem liminf_le_iff {Œ± Œ≤} [ConditionallyCompleteLinearOrder Œ≤] {f : Filter Œ±} {u : Œ± ‚Üí Œ≤} {x : Œ≤}\n    (h‚ÇÅ : f.IsCoboundedUnder (¬∑ ‚â• ¬∑) u := by isBoundedDefault)\n    (h‚ÇÇ : f.IsBoundedUnder (¬∑ ‚â• ¬∑) u := by isBoundedDefault) :\n    liminf u f ‚â§ x ‚Üî ‚àÄ y > x, ‚àÉ·∂† a in f, u a < y := le_limsup_iff (Œ≤ := Œ≤·µí·µà) h‚ÇÅ h‚ÇÇ\n\n"}
{"name":"Filter.lt_mem_sets_of_limsSup_lt","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : ConditionallyCompleteLinearOrder Œ±\nf : Filter Œ±\nb : Œ±\nh : Filter.IsBounded (fun x1 x2 => LE.le x1 x2) f\nl : LT.lt f.limsSup b\n‚ä¢ Filter.Eventually (fun a => LT.lt a b) f","decl":"set_option linter.unusedVariables false in\ntheorem lt_mem_sets_of_limsSup_lt (h : f.IsBounded (¬∑ ‚â§ ¬∑)) (l : f.limsSup < b) :\n    ‚àÄ·∂† a in f, a < b :=\n  let ‚ü®c, (h : ‚àÄ·∂† a in f, a ‚â§ c), hcb‚ü© := exists_lt_of_csInf_lt h l\n  mem_of_superset h fun _a => hcb.trans_le'\n\n"}
{"name":"Filter.gt_mem_sets_of_limsInf_gt","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù : ConditionallyCompleteLinearOrder Œ±\nf : Filter Œ±\nb : Œ±\na‚úù¬π : Filter.IsBounded (fun x1 x2 => GE.ge x1 x2) f\na‚úù : LT.lt b f.limsInf\n‚ä¢ Filter.Eventually (fun a => LT.lt b a) f","decl":"theorem gt_mem_sets_of_limsInf_gt : f.IsBounded (¬∑ ‚â• ¬∑) ‚Üí b < f.limsInf ‚Üí ‚àÄ·∂† a in f, b < a :=\n  @lt_mem_sets_of_limsSup_lt Œ±·µí·µà _ _ _\n\n"}
{"name":"Filter.HasBasis.liminf_eq_ciSup_ciInf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\nŒπ' : Type u_5\ninst‚úù¬≤ : ConditionallyCompleteLinearOrder Œ±\nv : Filter Œπ\np : Œπ' ‚Üí Prop\ns : Œπ' ‚Üí Set Œπ\ninst‚úù¬π : Countable (Subtype p)\ninst‚úù : Nonempty (Subtype p)\nhv : v.HasBasis p s\nf : Œπ ‚Üí Œ±\nhs : ‚àÄ (j : Subtype p), (s ‚Üëj).Nonempty\nH : Exists fun j => BddBelow (Set.range fun i => f ‚Üëi)\n‚ä¢ Eq (Filter.liminf f v) (iSup fun j => iInf fun i => f ‚Üëi)","decl":"/-- Writing a liminf as a supremum of infimum, in a (possibly non-complete) conditionally complete\nlinear order. A reparametrization trick is needed to avoid taking the infimum of sets which are\nnot bounded below. -/\ntheorem HasBasis.liminf_eq_ciSup_ciInf {v : Filter Œπ}\n    {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí Set Œπ} [Countable (Subtype p)] [Nonempty (Subtype p)]\n    (hv : v.HasBasis p s) {f : Œπ ‚Üí Œ±} (hs : ‚àÄ (j : Subtype p), (s j).Nonempty)\n    (H : ‚àÉ (j : Subtype p), BddBelow (range (fun (i : s j) ‚Ü¶ f i))) :\n    liminf f v = ‚®Ü (j : Subtype p), ‚®Ö (i : s (liminf_reparam f s p j)), f i := by\n  classical\n  rcases H with ‚ü®j0, hj0‚ü©\n  let m : Set (Subtype p) := {j | BddBelow (range (fun (i : s j) ‚Ü¶ f i))}\n  have : ‚àÄ (j : Subtype p), Nonempty (s j) := fun j ‚Ü¶ Nonempty.coe_sort (hs j)\n  have A : ‚ãÉ (j : Subtype p), ‚ãÇ (i : s j), Iic (f i) =\n         ‚ãÉ (j : Subtype p), ‚ãÇ (i : s (liminf_reparam f s p j)), Iic (f i) := by\n    apply Subset.antisymm\n    ¬∑ apply iUnion_subset (fun j ‚Ü¶ ?_)\n      by_cases hj : j ‚àà m\n      ¬∑ have : j = liminf_reparam f s p j := by simp only [m, liminf_reparam, hj, ite_true]\n        conv_lhs => rw [this]\n        apply subset_iUnion _ j\n      ¬∑ simp only [m, mem_setOf_eq, ‚Üê nonempty_iInter_Iic_iff, not_nonempty_iff_eq_empty] at hj\n        simp only [hj, empty_subset]\n    ¬∑ apply iUnion_subset (fun j ‚Ü¶ ?_)\n      exact subset_iUnion (fun (k : Subtype p) ‚Ü¶ (‚ãÇ (i : s k), Iic (f i))) (liminf_reparam f s p j)\n  have B : ‚àÄ (j : Subtype p), ‚ãÇ (i : s (liminf_reparam f s p j)), Iic (f i) =\n                                Iic (‚®Ö (i : s (liminf_reparam f s p j)), f i) := by\n    intro j\n    apply (Iic_ciInf _).symm\n    change liminf_reparam f s p j ‚àà m\n    by_cases Hj : j ‚àà m\n    ¬∑ simpa only [m, liminf_reparam, if_pos Hj] using Hj\n    ¬∑ simp only [m, liminf_reparam, if_neg Hj]\n      have Z : ‚àÉ n, (exists_surjective_nat (Subtype p)).choose n ‚àà m ‚à® ‚àÄ j, j ‚àâ m := by\n        rcases (exists_surjective_nat (Subtype p)).choose_spec j0 with ‚ü®n, rfl‚ü©\n        exact ‚ü®n, Or.inl hj0‚ü©\n      rcases Nat.find_spec Z with hZ|hZ\n      ¬∑ exact hZ\n      ¬∑ exact (hZ j0 hj0).elim\n  simp_rw [hv.liminf_eq_sSup_iUnion_iInter, A, B, sSup_iUnion_Iic]\n\n"}
{"name":"Filter.HasBasis.liminf_eq_ite","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\nŒπ' : Type u_5\ninst‚úù¬≤ : ConditionallyCompleteLinearOrder Œ±\nv : Filter Œπ\np : Œπ' ‚Üí Prop\ns : Œπ' ‚Üí Set Œπ\ninst‚úù¬π : Countable (Subtype p)\ninst‚úù : Nonempty (Subtype p)\nhv : v.HasBasis p s\nf : Œπ ‚Üí Œ±\n‚ä¢ Eq (Filter.liminf f v) (ite (Exists fun j => Eq (s ‚Üëj) EmptyCollection.emptyCollection) (SupSet.sSup Set.univ) (ite (‚àÄ (j : Subtype p), Not (BddBelow (Set.range fun i => f ‚Üëi))) (SupSet.sSup EmptyCollection.emptyCollection) (iSup fun j => iInf fun i => f ‚Üëi)))","decl":"open Classical in\n/-- Writing a liminf as a supremum of infimum, in a (possibly non-complete) conditionally complete\nlinear order. A reparametrization trick is needed to avoid taking the infimum of sets which are\nnot bounded below. -/\ntheorem HasBasis.liminf_eq_ite {v : Filter Œπ} {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí Set Œπ}\n    [Countable (Subtype p)] [Nonempty (Subtype p)] (hv : v.HasBasis p s) (f : Œπ ‚Üí Œ±) :\n    liminf f v = if ‚àÉ (j : Subtype p), s j = ‚àÖ then sSup univ else\n      if ‚àÄ (j : Subtype p), ¬¨BddBelow (range (fun (i : s j) ‚Ü¶ f i)) then sSup ‚àÖ\n      else ‚®Ü (j : Subtype p), ‚®Ö (i : s (liminf_reparam f s p j)), f i := by\n  by_cases H : ‚àÉ (j : Subtype p), s j = ‚àÖ\n  ¬∑ rw [if_pos H]\n    rcases H with ‚ü®j, hj‚ü©\n    simp [hv.liminf_eq_sSup_univ_of_empty j j.2 hj]\n  rw [if_neg H]\n  by_cases H' : ‚àÄ (j : Subtype p), ¬¨BddBelow (range (fun (i : s j) ‚Ü¶ f i))\n  ¬∑ have A : ‚àÄ (j : Subtype p), ‚ãÇ (i : s j), Iic (f i) = ‚àÖ := by\n      simp_rw [‚Üê not_nonempty_iff_eq_empty, nonempty_iInter_Iic_iff]\n      exact H'\n    simp_rw [if_pos H', hv.liminf_eq_sSup_iUnion_iInter, A, iUnion_empty]\n  rw [if_neg H']\n  apply hv.liminf_eq_ciSup_ciInf\n  ¬∑ push_neg at H\n    simpa only [nonempty_iff_ne_empty] using H\n  ¬∑ push_neg at H'\n    exact H'\n\n"}
{"name":"Filter.HasBasis.limsup_eq_ciInf_ciSup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\nŒπ' : Type u_5\ninst‚úù¬≤ : ConditionallyCompleteLinearOrder Œ±\nv : Filter Œπ\np : Œπ' ‚Üí Prop\ns : Œπ' ‚Üí Set Œπ\ninst‚úù¬π : Countable (Subtype p)\ninst‚úù : Nonempty (Subtype p)\nhv : v.HasBasis p s\nf : Œπ ‚Üí Œ±\nhs : ‚àÄ (j : Subtype p), (s ‚Üëj).Nonempty\nH : Exists fun j => BddAbove (Set.range fun i => f ‚Üëi)\n‚ä¢ Eq (Filter.limsup f v) (iInf fun j => iSup fun i => f ‚Üëi)","decl":"/-- Writing a limsup as an infimum of supremum, in a (possibly non-complete) conditionally complete\nlinear order. A reparametrization trick is needed to avoid taking the supremum of sets which are\nnot bounded above. -/\ntheorem HasBasis.limsup_eq_ciInf_ciSup {v : Filter Œπ}\n    {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí Set Œπ} [Countable (Subtype p)] [Nonempty (Subtype p)]\n    (hv : v.HasBasis p s) {f : Œπ ‚Üí Œ±} (hs : ‚àÄ (j : Subtype p), (s j).Nonempty)\n    (H : ‚àÉ (j : Subtype p), BddAbove (range (fun (i : s j) ‚Ü¶ f i))) :\n    limsup f v = ‚®Ö (j : Subtype p), ‚®Ü (i : s (limsup_reparam f s p j)), f i :=\n  HasBasis.liminf_eq_ciSup_ciInf (Œ± := Œ±·µí·µà) hv hs H\n\n"}
{"name":"Filter.HasBasis.limsup_eq_ite","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒπ : Type u_4\nŒπ' : Type u_5\ninst‚úù¬≤ : ConditionallyCompleteLinearOrder Œ±\nv : Filter Œπ\np : Œπ' ‚Üí Prop\ns : Œπ' ‚Üí Set Œπ\ninst‚úù¬π : Countable (Subtype p)\ninst‚úù : Nonempty (Subtype p)\nhv : v.HasBasis p s\nf : Œπ ‚Üí Œ±\n‚ä¢ Eq (Filter.limsup f v) (ite (Exists fun j => Eq (s ‚Üëj) EmptyCollection.emptyCollection) (InfSet.sInf Set.univ) (ite (‚àÄ (j : Subtype p), Not (BddAbove (Set.range fun i => f ‚Üëi))) (InfSet.sInf EmptyCollection.emptyCollection) (iInf fun j => iSup fun i => f ‚Üëi)))","decl":"open Classical in\n/-- Writing a limsup as an infimum of supremum, in a (possibly non-complete) conditionally complete\nlinear order. A reparametrization trick is needed to avoid taking the supremum of sets which are\nnot bounded below. -/\ntheorem HasBasis.limsup_eq_ite {v : Filter Œπ} {p : Œπ' ‚Üí Prop} {s : Œπ' ‚Üí Set Œπ}\n    [Countable (Subtype p)] [Nonempty (Subtype p)] (hv : v.HasBasis p s) (f : Œπ ‚Üí Œ±) :\n    limsup f v = if ‚àÉ (j : Subtype p), s j = ‚àÖ then sInf univ else\n      if ‚àÄ (j : Subtype p), ¬¨BddAbove (range (fun (i : s j) ‚Ü¶ f i)) then sInf ‚àÖ\n      else ‚®Ö (j : Subtype p), ‚®Ü (i : s (limsup_reparam f s p j)), f i :=\n  HasBasis.liminf_eq_ite (Œ± := Œ±·µí·µà) hv f\n\n"}
{"name":"Monotone.isBoundedUnder_le_comp_iff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬≥ : Nonempty Œ≤\ninst‚úù¬≤ : LinearOrder Œ≤\ninst‚úù¬π : Preorder Œ≥\ninst‚úù : NoMaxOrder Œ≥\ng : Œ≤ ‚Üí Œ≥\nf : Œ± ‚Üí Œ≤\nl : Filter Œ±\nhg : Monotone g\nhg' : Filter.Tendsto g Filter.atTop Filter.atTop\n‚ä¢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp g f)) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l f)","decl":"theorem Monotone.isBoundedUnder_le_comp_iff [Nonempty Œ≤] [LinearOrder Œ≤] [Preorder Œ≥] [NoMaxOrder Œ≥]\n    {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} {l : Filter Œ±} (hg : Monotone g) (hg' : Tendsto g atTop atTop) :\n    IsBoundedUnder (¬∑ ‚â§ ¬∑) l (g ‚àò f) ‚Üî IsBoundedUnder (¬∑ ‚â§ ¬∑) l f := by\n  refine ‚ü®?_, fun h => h.isBoundedUnder (Œ± := Œ≤) hg‚ü©\n  rintro ‚ü®c, hc‚ü©; rw [eventually_map] at hc\n  obtain ‚ü®b, hb‚ü© : ‚àÉ b, ‚àÄ a ‚â• b, c < g a := eventually_atTop.1 (hg'.eventually_gt_atTop c)\n  exact ‚ü®b, hc.mono fun x hx => not_lt.1 fun h => (hb _ h.le).not_le hx‚ü©\n\n"}
{"name":"Monotone.isBoundedUnder_ge_comp_iff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬≥ : Nonempty Œ≤\ninst‚úù¬≤ : LinearOrder Œ≤\ninst‚úù¬π : Preorder Œ≥\ninst‚úù : NoMinOrder Œ≥\ng : Œ≤ ‚Üí Œ≥\nf : Œ± ‚Üí Œ≤\nl : Filter Œ±\nhg : Monotone g\nhg' : Filter.Tendsto g Filter.atBot Filter.atBot\n‚ä¢ Iff (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l (Function.comp g f)) (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l f)","decl":"theorem Monotone.isBoundedUnder_ge_comp_iff [Nonempty Œ≤] [LinearOrder Œ≤] [Preorder Œ≥] [NoMinOrder Œ≥]\n    {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} {l : Filter Œ±} (hg : Monotone g) (hg' : Tendsto g atBot atBot) :\n    IsBoundedUnder (¬∑ ‚â• ¬∑) l (g ‚àò f) ‚Üî IsBoundedUnder (¬∑ ‚â• ¬∑) l f :=\n  hg.dual.isBoundedUnder_le_comp_iff hg'\n\n"}
{"name":"Antitone.isBoundedUnder_le_comp_iff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬≥ : Nonempty Œ≤\ninst‚úù¬≤ : LinearOrder Œ≤\ninst‚úù¬π : Preorder Œ≥\ninst‚úù : NoMaxOrder Œ≥\ng : Œ≤ ‚Üí Œ≥\nf : Œ± ‚Üí Œ≤\nl : Filter Œ±\nhg : Antitone g\nhg' : Filter.Tendsto g Filter.atBot Filter.atTop\n‚ä¢ Iff (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l (Function.comp g f)) (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l f)","decl":"theorem Antitone.isBoundedUnder_le_comp_iff [Nonempty Œ≤] [LinearOrder Œ≤] [Preorder Œ≥] [NoMaxOrder Œ≥]\n    {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} {l : Filter Œ±} (hg : Antitone g) (hg' : Tendsto g atBot atTop) :\n    IsBoundedUnder (¬∑ ‚â§ ¬∑) l (g ‚àò f) ‚Üî IsBoundedUnder (¬∑ ‚â• ¬∑) l f :=\n  hg.dual_right.isBoundedUnder_ge_comp_iff hg'\n\n"}
{"name":"Antitone.isBoundedUnder_ge_comp_iff","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬≥ : Nonempty Œ≤\ninst‚úù¬≤ : LinearOrder Œ≤\ninst‚úù¬π : Preorder Œ≥\ninst‚úù : NoMinOrder Œ≥\ng : Œ≤ ‚Üí Œ≥\nf : Œ± ‚Üí Œ≤\nl : Filter Œ±\nhg : Antitone g\nhg' : Filter.Tendsto g Filter.atTop Filter.atBot\n‚ä¢ Iff (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) l (Function.comp g f)) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) l f)","decl":"theorem Antitone.isBoundedUnder_ge_comp_iff [Nonempty Œ≤] [LinearOrder Œ≤] [Preorder Œ≥] [NoMinOrder Œ≥]\n    {g : Œ≤ ‚Üí Œ≥} {f : Œ± ‚Üí Œ≤} {l : Filter Œ±} (hg : Antitone g) (hg' : Tendsto g atTop atBot) :\n    IsBoundedUnder (¬∑ ‚â• ¬∑) l (g ‚àò f) ‚Üî IsBoundedUnder (¬∑ ‚â§ ¬∑) l f :=\n  hg.dual_right.isBoundedUnder_le_comp_iff hg'\n\n"}
{"name":"GaloisConnection.l_limsup_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬π : ConditionallyCompleteLattice Œ≤\ninst‚úù : ConditionallyCompleteLattice Œ≥\nf : Filter Œ±\nv : Œ± ‚Üí Œ≤\nl : Œ≤ ‚Üí Œ≥\nu : Œ≥ ‚Üí Œ≤\ngc : GaloisConnection l u\nhlv : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f fun x => l (v x)) _auto‚úù\nhv_co : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f v) _auto‚úù\n‚ä¢ LE.le (l (Filter.limsup v f)) (Filter.limsup (fun x => l (v x)) f)","decl":"theorem GaloisConnection.l_limsup_le [ConditionallyCompleteLattice Œ≤]\n    [ConditionallyCompleteLattice Œ≥] {f : Filter Œ±} {v : Œ± ‚Üí Œ≤} {l : Œ≤ ‚Üí Œ≥} {u : Œ≥ ‚Üí Œ≤}\n    (gc : GaloisConnection l u)\n    (hlv : f.IsBoundedUnder (¬∑ ‚â§ ¬∑) fun x => l (v x) := by isBoundedDefault)\n    (hv_co : f.IsCoboundedUnder (¬∑ ‚â§ ¬∑) v := by isBoundedDefault) :\n    l (limsup v f) ‚â§ limsup (fun x => l (v x)) f := by\n  refine le_limsSup_of_le hlv fun c hc => ?_\n  rw [Filter.eventually_map] at hc\n  simp_rw [gc _ _] at hc ‚ä¢\n  exact limsSup_le_of_le hv_co hc\n\n"}
{"name":"OrderIso.limsup_apply","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_6\ninst‚úù¬π : ConditionallyCompleteLattice Œ≤\ninst‚úù : ConditionallyCompleteLattice Œ≥\nf : Filter Œ±\nu : Œ± ‚Üí Œ≤\ng : OrderIso Œ≤ Œ≥\nhu : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto‚úù\nhu_co : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto‚úù\nhgu : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f fun x => g (u x)) _auto‚úù\nhgu_co : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f fun x => g (u x)) _auto‚úù\n‚ä¢ Eq (g (Filter.limsup u f)) (Filter.limsup (fun x => g (u x)) f)","decl":"theorem OrderIso.limsup_apply {Œ≥} [ConditionallyCompleteLattice Œ≤] [ConditionallyCompleteLattice Œ≥]\n    {f : Filter Œ±} {u : Œ± ‚Üí Œ≤} (g : Œ≤ ‚âÉo Œ≥)\n    (hu : f.IsBoundedUnder (¬∑ ‚â§ ¬∑) u := by isBoundedDefault)\n    (hu_co : f.IsCoboundedUnder (¬∑ ‚â§ ¬∑) u := by isBoundedDefault)\n    (hgu : f.IsBoundedUnder (¬∑ ‚â§ ¬∑) fun x => g (u x) := by isBoundedDefault)\n    (hgu_co : f.IsCoboundedUnder (¬∑ ‚â§ ¬∑) fun x => g (u x) := by isBoundedDefault) :\n    g (limsup u f) = limsup (fun x => g (u x)) f := by\n  refine le_antisymm ((OrderIso.to_galoisConnection g).l_limsup_le hgu hu_co) ?_\n  rw [‚Üê g.symm.symm_apply_apply <| limsup (fun x => g (u x)) f, g.symm_symm]\n  refine g.monotone ?_\n  have hf : u = fun i => g.symm (g (u i)) := funext fun i => (g.symm_apply_apply (u i)).symm\n  -- Porting note: nth_rw 1 to nth_rw 2\n  nth_rw 2 [hf]\n  refine (OrderIso.to_galoisConnection g.symm).l_limsup_le ?_ hgu_co\n  simp_rw [g.symm_apply_apply]\n  exact hu\n\n"}
{"name":"OrderIso.liminf_apply","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_6\ninst‚úù¬π : ConditionallyCompleteLattice Œ≤\ninst‚úù : ConditionallyCompleteLattice Œ≥\nf : Filter Œ±\nu : Œ± ‚Üí Œ≤\ng : OrderIso Œ≤ Œ≥\nhu : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto‚úù\nhu_co : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto‚úù\nhgu : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f fun x => g (u x)) _auto‚úù\nhgu_co : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f fun x => g (u x)) _auto‚úù\n‚ä¢ Eq (g (Filter.liminf u f)) (Filter.liminf (fun x => g (u x)) f)","decl":"theorem OrderIso.liminf_apply {Œ≥} [ConditionallyCompleteLattice Œ≤] [ConditionallyCompleteLattice Œ≥]\n    {f : Filter Œ±} {u : Œ± ‚Üí Œ≤} (g : Œ≤ ‚âÉo Œ≥)\n    (hu : f.IsBoundedUnder (¬∑ ‚â• ¬∑) u := by isBoundedDefault)\n    (hu_co : f.IsCoboundedUnder (¬∑ ‚â• ¬∑) u := by isBoundedDefault)\n    (hgu : f.IsBoundedUnder (¬∑ ‚â• ¬∑) fun x => g (u x) := by isBoundedDefault)\n    (hgu_co : f.IsCoboundedUnder (¬∑ ‚â• ¬∑) fun x => g (u x) := by isBoundedDefault) :\n    g (liminf u f) = liminf (fun x => g (u x)) f :=\n  OrderIso.limsup_apply (Œ≤ := Œ≤·µí·µà) (Œ≥ := Œ≥·µí·µà) g.dual hu hu_co hgu hgu_co\n\n"}
{"name":"isCoboundedUnder_le_max","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : LinearOrder Œ≤\nf : Filter Œ±\nu v : Œ± ‚Üí Œ≤\nh : Or (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u) (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f v)\n‚ä¢ Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f fun a => Max.max (u a) (v a)","decl":"theorem isCoboundedUnder_le_max [LinearOrder Œ≤] {f : Filter Œ±} {u v : Œ± ‚Üí Œ≤}\n    (h : f.IsCoboundedUnder (¬∑ ‚â§ ¬∑) u ‚à® f.IsCoboundedUnder (¬∑ ‚â§ ¬∑) v) :\n    f.IsCoboundedUnder (¬∑ ‚â§ ¬∑) (fun a ‚Ü¶ max (u a) (v a)) := by\n  rcases h with (h' | h') <;>\n  ¬∑ rcases h' with ‚ü®b, hb‚ü©\n    use b\n    intro c hc\n    apply hb c\n    rw [eventually_map] at hc ‚ä¢\n    refine hc.mono (fun _ ‚Ü¶ ?_)\n    simp +contextual only [implies_true, max_le_iff, and_imp]\n\n"}
{"name":"limsup_max","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : ConditionallyCompleteLinearOrder Œ≤\nf : Filter Œ±\nu v : Œ± ‚Üí Œ≤\nh‚ÇÅ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto‚úù\nh‚ÇÇ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f v) _auto‚úù\nh‚ÇÉ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f u) _auto‚úù\nh‚ÇÑ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f v) _auto‚úù\n‚ä¢ Eq (Filter.limsup (fun a => Max.max (u a) (v a)) f) (Max.max (Filter.limsup u f) (Filter.limsup v f))","decl":"theorem limsup_max [ConditionallyCompleteLinearOrder Œ≤] {f : Filter Œ±} {u v : Œ± ‚Üí Œ≤}\n    (h‚ÇÅ : f.IsCoboundedUnder (¬∑ ‚â§ ¬∑) u := by isBoundedDefault)\n    (h‚ÇÇ : f.IsCoboundedUnder (¬∑ ‚â§ ¬∑) v := by isBoundedDefault)\n    (h‚ÇÉ : f.IsBoundedUnder (¬∑ ‚â§ ¬∑) u := by isBoundedDefault)\n    (h‚ÇÑ : f.IsBoundedUnder (¬∑ ‚â§ ¬∑) v := by isBoundedDefault) :\n    limsup (fun a ‚Ü¶ max (u a) (v a)) f = max (limsup u f) (limsup v f) := by\n  have bddmax := IsBoundedUnder.sup h‚ÇÉ h‚ÇÑ\n  have cobddmax := isCoboundedUnder_le_max (v := v) (Or.inl h‚ÇÅ)\n  apply le_antisymm\n  ¬∑ refine (limsup_le_iff cobddmax bddmax).2 (fun b hb ‚Ü¶ ?_)\n    have hu := eventually_lt_of_limsup_lt (lt_of_le_of_lt (le_max_left _ _) hb) h‚ÇÉ\n    have hv := eventually_lt_of_limsup_lt (lt_of_le_of_lt (le_max_right _ _) hb) h‚ÇÑ\n    refine mem_of_superset (inter_mem hu hv) (fun _ ‚Ü¶ by simp)\n  ¬∑ exact max_le (c := limsup (fun a ‚Ü¶ max (u a) (v a)) f)\n      (limsup_le_limsup (Eventually.of_forall (fun a : Œ± ‚Ü¶ le_max_left (u a) (v a))) h‚ÇÅ bddmax)\n      (limsup_le_limsup (Eventually.of_forall (fun a : Œ± ‚Ü¶ le_max_right (u a) (v a))) h‚ÇÇ bddmax)\n\n"}
{"name":"liminf_min","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : ConditionallyCompleteLinearOrder Œ≤\nf : Filter Œ±\nu v : Œ± ‚Üí Œ≤\nh‚ÇÅ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto‚úù\nh‚ÇÇ : autoParam (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f v) _auto‚úù\nh‚ÇÉ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f u) _auto‚úù\nh‚ÇÑ : autoParam (Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f v) _auto‚úù\n‚ä¢ Eq (Filter.liminf (fun a => Min.min (u a) (v a)) f) (Min.min (Filter.liminf u f) (Filter.liminf v f))","decl":"theorem liminf_min [ConditionallyCompleteLinearOrder Œ≤] {f : Filter Œ±} {u v : Œ± ‚Üí Œ≤}\n    (h‚ÇÅ : f.IsCoboundedUnder (¬∑ ‚â• ¬∑) u := by isBoundedDefault)\n    (h‚ÇÇ : f.IsCoboundedUnder (¬∑ ‚â• ¬∑) v := by isBoundedDefault)\n    (h‚ÇÉ : f.IsBoundedUnder (¬∑ ‚â• ¬∑) u := by isBoundedDefault)\n    (h‚ÇÑ : f.IsBoundedUnder (¬∑ ‚â• ¬∑) v := by isBoundedDefault) :\n    liminf (fun a ‚Ü¶ min (u a) (v a)) f = min (liminf u f) (liminf v f) :=\n  limsup_max (Œ≤ := Œ≤·µí·µà) h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ\n\n"}
{"name":"isBoundedUnder_le_finset_sup'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_4\ninst‚úù¬π : LinearOrder Œ≤\ninst‚úù : Nonempty Œ≤\nf : Filter Œ±\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\ns : Finset Œπ\nhs : s.Nonempty\nh : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f (F i)\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f fun a => s.sup' hs fun i => F i a","decl":"theorem isBoundedUnder_le_finset_sup' [LinearOrder Œ≤] [Nonempty Œ≤] {f : Filter Œ±} {F : Œπ ‚Üí Œ± ‚Üí Œ≤}\n    {s : Finset Œπ} (hs : s.Nonempty) (h : ‚àÄ i ‚àà s, f.IsBoundedUnder (¬∑ ‚â§ ¬∑) (F i)) :\n    f.IsBoundedUnder (¬∑ ‚â§ ¬∑) (fun a ‚Ü¶ sup' s hs (fun i ‚Ü¶ F i a)) := by\n  choose! m hm using h\n  use sup' s hs m\n  simp only [eventually_map] at hm ‚ä¢\n  rw [‚Üê eventually_all_finset s] at hm\n  refine hm.mono fun a h ‚Ü¶ ?_\n  simp only [Finset.sup'_apply, sup'_le_iff]\n  exact fun i i_s ‚Ü¶ le_trans (h i i_s) (le_sup' m i_s)\n\n"}
{"name":"isCoboundedUnder_le_finset_sup'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_4\ninst‚úù : LinearOrder Œ≤\nf : Filter Œ±\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\ns : Finset Œπ\nhs : s.Nonempty\nh : Exists fun i => And (Membership.mem s i) (Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f (F i))\n‚ä¢ Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f fun a => s.sup' hs fun i => F i a","decl":"theorem isCoboundedUnder_le_finset_sup' [LinearOrder Œ≤] {f : Filter Œ±} {F : Œπ ‚Üí Œ± ‚Üí Œ≤}\n    {s : Finset Œπ} (hs : s.Nonempty) (h : ‚àÉ i ‚àà s, f.IsCoboundedUnder (¬∑ ‚â§ ¬∑) (F i)) :\n    f.IsCoboundedUnder (¬∑ ‚â§ ¬∑) (fun a ‚Ü¶ sup' s hs (fun i ‚Ü¶ F i a)) := by\n  rcases h with ‚ü®i, i_s, b, hb‚ü©\n  use b\n  refine fun c hc ‚Ü¶ hb c ?_\n  rw [eventually_map] at hc ‚ä¢\n  refine hc.mono fun a h ‚Ü¶ ?_\n  simp only [Finset.sup'_apply, sup'_le_iff] at h ‚ä¢\n  exact h i i_s\n\n"}
{"name":"isBoundedUnder_le_finset_sup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_4\ninst‚úù¬π : LinearOrder Œ≤\ninst‚úù : OrderBot Œ≤\nf : Filter Œ±\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\ns : Finset Œπ\nh : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f (F i)\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f fun a => s.sup fun i => F i a","decl":"theorem isBoundedUnder_le_finset_sup [LinearOrder Œ≤] [OrderBot Œ≤] {f : Filter Œ±} {F : Œπ ‚Üí Œ± ‚Üí Œ≤}\n    {s : Finset Œπ} (h : ‚àÄ i ‚àà s, f.IsBoundedUnder (¬∑ ‚â§ ¬∑) (F i)) :\n    f.IsBoundedUnder (¬∑ ‚â§ ¬∑) (fun a ‚Ü¶ sup s (fun i ‚Ü¶ F i a)) := by\n  choose! m hm using h\n  use sup s m\n  simp only [eventually_map] at hm ‚ä¢\n  rw [‚Üê eventually_all_finset s] at hm\n  exact hm.mono fun _ h ‚Ü¶ sup_mono_fun h\n\n"}
{"name":"isBoundedUnder_ge_finset_inf'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_4\ninst‚úù¬π : LinearOrder Œ≤\ninst‚úù : Nonempty Œ≤\nf : Filter Œ±\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\ns : Finset Œπ\nhs : s.Nonempty\nh : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f (F i)\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f fun a => s.inf' hs fun i => F i a","decl":"theorem isBoundedUnder_ge_finset_inf' [LinearOrder Œ≤] [Nonempty Œ≤] {f : Filter Œ±} {F : Œπ ‚Üí Œ± ‚Üí Œ≤}\n    {s : Finset Œπ} (hs : s.Nonempty) (h : ‚àÄ i ‚àà s, f.IsBoundedUnder (¬∑ ‚â• ¬∑) (F i)) :\n    f.IsBoundedUnder (¬∑ ‚â• ¬∑) (fun a ‚Ü¶ inf' s hs (fun i ‚Ü¶ F i a)) :=\n  isBoundedUnder_le_finset_sup' (Œ≤ := Œ≤·µí·µà) hs h\n\n"}
{"name":"isCoboundedUnder_ge_finset_inf'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_4\ninst‚úù : LinearOrder Œ≤\nf : Filter Œ±\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\ns : Finset Œπ\nhs : s.Nonempty\nh : Exists fun i => And (Membership.mem s i) (Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f (F i))\n‚ä¢ Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f fun a => s.inf' hs fun i => F i a","decl":"theorem isCoboundedUnder_ge_finset_inf' [LinearOrder Œ≤] {f : Filter Œ±} {F : Œπ ‚Üí Œ± ‚Üí Œ≤}\n    {s : Finset Œπ} (hs : s.Nonempty) (h : ‚àÉ i ‚àà s, f.IsCoboundedUnder (¬∑ ‚â• ¬∑) (F i)) :\n    f.IsCoboundedUnder (¬∑ ‚â• ¬∑) (fun a ‚Ü¶ inf' s hs (fun i ‚Ü¶ F i a)) :=\n  isCoboundedUnder_le_finset_sup' (Œ≤ := Œ≤·µí·µà) hs h\n\n"}
{"name":"isBoundedUnder_ge_finset_inf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_4\ninst‚úù¬π : LinearOrder Œ≤\ninst‚úù : OrderTop Œ≤\nf : Filter Œ±\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\ns : Finset Œπ\nh : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f (F i)\n‚ä¢ Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f fun a => s.inf fun i => F i a","decl":"theorem isBoundedUnder_ge_finset_inf [LinearOrder Œ≤] [OrderTop Œ≤] {f : Filter Œ±} {F : Œπ ‚Üí Œ± ‚Üí Œ≤}\n    {s : Finset Œπ} (h : ‚àÄ i ‚àà s, f.IsBoundedUnder (¬∑ ‚â• ¬∑) (F i)) :\n    f.IsBoundedUnder (¬∑ ‚â• ¬∑) (fun a ‚Ü¶ inf s (fun i ‚Ü¶ F i a)) :=\n  isBoundedUnder_le_finset_sup (Œ≤ := Œ≤·µí·µà) h\n\n"}
{"name":"limsup_finset_sup'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_4\ninst‚úù : ConditionallyCompleteLinearOrder Œ≤\nf : Filter Œ±\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\ns : Finset Œπ\nhs : s.Nonempty\nh‚ÇÅ : autoParam (‚àÄ (i : Œπ), Membership.mem s i ‚Üí Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f (F i)) _auto‚úù\nh‚ÇÇ : autoParam (‚àÄ (i : Œπ), Membership.mem s i ‚Üí Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f (F i)) _auto‚úù\n‚ä¢ Eq (Filter.limsup (fun a => s.sup' hs fun i => F i a) f) (s.sup' hs fun i => Filter.limsup (F i) f)","decl":"theorem limsup_finset_sup' [ConditionallyCompleteLinearOrder Œ≤] {f : Filter Œ±}\n    {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {s : Finset Œπ} (hs : s.Nonempty)\n    (h‚ÇÅ : ‚àÄ i ‚àà s, f.IsCoboundedUnder (¬∑ ‚â§ ¬∑) (F i) := by exact fun _ _ ‚Ü¶ by isBoundedDefault)\n    (h‚ÇÇ : ‚àÄ i ‚àà s, f.IsBoundedUnder (¬∑ ‚â§ ¬∑) (F i) := by exact fun _ _ ‚Ü¶ by isBoundedDefault) :\n    limsup (fun a ‚Ü¶ sup' s hs (fun i ‚Ü¶ F i a)) f = sup' s hs (fun i ‚Ü¶ limsup (F i) f) := by\n  have bddsup := isBoundedUnder_le_finset_sup' hs h‚ÇÇ\n  apply le_antisymm\n  ¬∑ have h‚ÇÉ : ‚àÉ i ‚àà s, f.IsCoboundedUnder (¬∑ ‚â§ ¬∑) (F i) := by\n      rcases hs with ‚ü®i, i_s‚ü©\n      use i, i_s\n      exact h‚ÇÅ i i_s\n    have cobddsup := isCoboundedUnder_le_finset_sup' hs h‚ÇÉ\n    refine (limsup_le_iff cobddsup bddsup).2 (fun b hb ‚Ü¶ ?_)\n    rw [eventually_iff_exists_mem]\n    use ‚ãÇ i ‚àà s, {a | F i a < b}\n    split_ands\n    ¬∑ rw [biInter_finset_mem]\n      suffices key : ‚àÄ i ‚àà s, ‚àÄ·∂† a in f, F i a < b from fun i i_s ‚Ü¶ eventually_iff.1 (key i i_s)\n      intro i i_s\n      apply eventually_lt_of_limsup_lt _ (h‚ÇÇ i i_s)\n      exact lt_of_le_of_lt (Finset.le_sup' (f := fun i ‚Ü¶ limsup (F i) f) i_s) hb\n    ¬∑ simp only [mem_iInter, mem_setOf_eq, Finset.sup'_apply, sup'_lt_iff, imp_self, implies_true]\n  ¬∑ apply Finset.sup'_le hs (fun i ‚Ü¶ limsup (F i) f)\n    refine fun i i_s ‚Ü¶ limsup_le_limsup (Eventually.of_forall (fun a ‚Ü¶ ?_)) (h‚ÇÅ i i_s) bddsup\n    simp only [Finset.sup'_apply, le_sup'_iff]\n    use i, i_s\n\n"}
{"name":"limsup_finset_sup","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_4\ninst‚úù¬π : ConditionallyCompleteLinearOrder Œ≤\ninst‚úù : OrderBot Œ≤\nf : Filter Œ±\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\ns : Finset Œπ\nh‚ÇÅ : autoParam (‚àÄ (i : Œπ), Membership.mem s i ‚Üí Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) f (F i)) _auto‚úù\nh‚ÇÇ : autoParam (‚àÄ (i : Œπ), Membership.mem s i ‚Üí Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) f (F i)) _auto‚úù\n‚ä¢ Eq (Filter.limsup (fun a => s.sup fun i => F i a) f) (s.sup fun i => Filter.limsup (F i) f)","decl":"theorem limsup_finset_sup [ConditionallyCompleteLinearOrder Œ≤] [OrderBot Œ≤] {f : Filter Œ±}\n    {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {s : Finset Œπ}\n    (h‚ÇÅ : ‚àÄ i ‚àà s, f.IsCoboundedUnder (¬∑ ‚â§ ¬∑) (F i) := by exact fun _ _ ‚Ü¶ by isBoundedDefault)\n    (h‚ÇÇ : ‚àÄ i ‚àà s, f.IsBoundedUnder (¬∑ ‚â§ ¬∑) (F i) := by exact fun _ _ ‚Ü¶ by isBoundedDefault) :\n    limsup (fun a ‚Ü¶ sup s (fun i ‚Ü¶ F i a)) f = sup s (fun i ‚Ü¶ limsup (F i) f) := by\n  rcases eq_or_neBot f with (rfl | _)\n  ¬∑ simp [limsup_eq, csInf_univ]\n  rcases Finset.eq_empty_or_nonempty s with (rfl | s_nemp)\n  ¬∑ simp only [Finset.sup_apply, sup_empty, limsup_const]\n  rw [‚Üê Finset.sup'_eq_sup s_nemp fun i ‚Ü¶ limsup (F i) f, ‚Üê limsup_finset_sup' s_nemp h‚ÇÅ h‚ÇÇ]\n  congr\n  ext a\n  exact Eq.symm (Finset.sup'_eq_sup s_nemp (fun i ‚Ü¶ F i a))\n\n"}
{"name":"liminf_finset_inf'","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_4\ninst‚úù : ConditionallyCompleteLinearOrder Œ≤\nf : Filter Œ±\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\ns : Finset Œπ\nhs : s.Nonempty\nh‚ÇÅ : autoParam (‚àÄ (i : Œπ), Membership.mem s i ‚Üí Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f (F i)) _auto‚úù\nh‚ÇÇ : autoParam (‚àÄ (i : Œπ), Membership.mem s i ‚Üí Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f (F i)) _auto‚úù\n‚ä¢ Eq (Filter.liminf (fun a => s.inf' hs fun i => F i a) f) (s.inf' hs fun i => Filter.liminf (F i) f)","decl":"theorem liminf_finset_inf' [ConditionallyCompleteLinearOrder Œ≤] {f : Filter Œ±}\n    {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {s : Finset Œπ} (hs : s.Nonempty)\n    (h‚ÇÅ : ‚àÄ i ‚àà s, f.IsCoboundedUnder (¬∑ ‚â• ¬∑) (F i) := by exact fun _ _ ‚Ü¶ by isBoundedDefault)\n    (h‚ÇÇ : ‚àÄ i ‚àà s, f.IsBoundedUnder (¬∑ ‚â• ¬∑) (F i) := by exact fun _ _ ‚Ü¶ by isBoundedDefault) :\n    liminf (fun a ‚Ü¶ inf' s hs (fun i ‚Ü¶ F i a)) f = inf' s hs (fun i ‚Ü¶ liminf (F i) f) :=\n  limsup_finset_sup' (Œ≤ := Œ≤·µí·µà) hs h‚ÇÅ h‚ÇÇ\n\n"}
{"name":"liminf_finset_inf","module":"Mathlib.Order.LiminfLimsup","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_4\ninst‚úù¬π : ConditionallyCompleteLinearOrder Œ≤\ninst‚úù : OrderTop Œ≤\nf : Filter Œ±\nF : Œπ ‚Üí Œ± ‚Üí Œ≤\ns : Finset Œπ\nh‚ÇÅ : autoParam (‚àÄ (i : Œπ), Membership.mem s i ‚Üí Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) f (F i)) _auto‚úù\nh‚ÇÇ : autoParam (‚àÄ (i : Œπ), Membership.mem s i ‚Üí Filter.IsBoundedUnder (fun x1 x2 => GE.ge x1 x2) f (F i)) _auto‚úù\n‚ä¢ Eq (Filter.liminf (fun a => s.inf fun i => F i a) f) (s.inf fun i => Filter.liminf (F i) f)","decl":"theorem liminf_finset_inf [ConditionallyCompleteLinearOrder Œ≤] [OrderTop Œ≤] {f : Filter Œ±}\n    {F : Œπ ‚Üí Œ± ‚Üí Œ≤} {s : Finset Œπ}\n    (h‚ÇÅ : ‚àÄ i ‚àà s, f.IsCoboundedUnder (¬∑ ‚â• ¬∑) (F i) := by exact fun _ _ ‚Ü¶ by isBoundedDefault)\n    (h‚ÇÇ : ‚àÄ i ‚àà s, f.IsBoundedUnder (¬∑ ‚â• ¬∑) (F i) := by exact fun _ _ ‚Ü¶ by isBoundedDefault) :\n    liminf (fun a ‚Ü¶ inf s (fun i ‚Ü¶ F i a)) f = inf s (fun i ‚Ü¶ liminf (F i) f) :=\n  limsup_finset_sup (Œ≤ := Œ≤·µí·µà) h‚ÇÅ h‚ÇÇ\n\n"}
{"name":"Monotone.frequently_ge_map_of_frequently_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"R : Type u_6\nS : Type u_7\nF : Filter R\ninst‚úù¬π : LinearOrder R\ninst‚úù : LinearOrder S\nf : R ‚Üí S\nf_incr : Monotone f\nl : R\nfreq_ge : Filter.Frequently (fun x => LE.le l x) F\n‚ä¢ Filter.Frequently (fun x' => LE.le (f l) x') (Filter.map f F)","decl":"lemma Monotone.frequently_ge_map_of_frequently_ge {f : R ‚Üí S} (f_incr : Monotone f)\n    {l : R} (freq_ge : ‚àÉ·∂† x in F, l ‚â§ x) :\n    ‚àÉ·∂† x' in F.map f, f l ‚â§ x' := by\n  refine fun ev ‚Ü¶ freq_ge ?_\n  simp only [not_le, not_lt] at ev freq_ge ‚ä¢\n  filter_upwards [ev] with z hz\n  by_contra con\n  exact lt_irrefl (f l) <| lt_of_le_of_lt (f_incr <| not_lt.mp con) hz\n\n"}
{"name":"Monotone.frequently_le_map_of_frequently_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"R : Type u_6\nS : Type u_7\nF : Filter R\ninst‚úù¬π : LinearOrder R\ninst‚úù : LinearOrder S\nf : R ‚Üí S\nf_incr : Monotone f\nu : R\nfreq_le : Filter.Frequently (fun x => LE.le x u) F\n‚ä¢ Filter.Frequently (fun y => LE.le y (f u)) (Filter.map f F)","decl":"lemma Monotone.frequently_le_map_of_frequently_le {f : R ‚Üí S} (f_incr : Monotone f)\n    {u : R} (freq_le : ‚àÉ·∂† x in F, x ‚â§ u) :\n    ‚àÉ·∂† y in F.map f, y ‚â§ f u := by\n  refine fun ev ‚Ü¶ freq_le ?_\n  simp only [not_le, not_lt] at ev freq_le ‚ä¢\n  filter_upwards [ev] with z hz\n  by_contra con\n  apply lt_irrefl (f u) <| lt_of_lt_of_le hz <| f_incr (not_lt.mp con)\n\n"}
{"name":"Antitone.frequently_le_map_of_frequently_ge","module":"Mathlib.Order.LiminfLimsup","initialProofState":"R : Type u_6\nS : Type u_7\nF : Filter R\ninst‚úù¬π : LinearOrder R\ninst‚úù : LinearOrder S\nf : R ‚Üí S\nf_decr : Antitone f\nl : R\nfrbdd : Filter.Frequently (fun x => LE.le l x) F\n‚ä¢ Filter.Frequently (fun y => LE.le y (f l)) (Filter.map f F)","decl":"lemma Antitone.frequently_le_map_of_frequently_ge {f : R ‚Üí S} (f_decr : Antitone f)\n    {l : R} (frbdd : ‚àÉ·∂† x in F, l ‚â§ x) :\n    ‚àÉ·∂† y in F.map f, y ‚â§ f l :=\n  Monotone.frequently_ge_map_of_frequently_ge (S := S·µí·µà) f_decr frbdd\n\n"}
{"name":"Antitone.frequently_ge_map_of_frequently_le","module":"Mathlib.Order.LiminfLimsup","initialProofState":"R : Type u_6\nS : Type u_7\nF : Filter R\ninst‚úù¬π : LinearOrder R\ninst‚úù : LinearOrder S\nf : R ‚Üí S\nf_decr : Antitone f\nu : R\nfrbdd : Filter.Frequently (fun x => LE.le x u) F\n‚ä¢ Filter.Frequently (fun y => LE.le (f u) y) (Filter.map f F)","decl":"lemma Antitone.frequently_ge_map_of_frequently_le {f : R ‚Üí S} (f_decr : Antitone f)\n    {u : R} (frbdd : ‚àÉ·∂† x in F, x ‚â§ u) :\n    ‚àÉ·∂† y in F.map f, f u ‚â§ y :=\n  Monotone.frequently_le_map_of_frequently_le (S := S·µí·µà) f_decr frbdd\n\n"}
{"name":"Monotone.isCoboundedUnder_le_of_isCobounded","module":"Mathlib.Order.LiminfLimsup","initialProofState":"R : Type u_6\nS : Type u_7\nF : Filter R\ninst‚úù¬≤ : LinearOrder R\ninst‚úù¬π : LinearOrder S\nf : R ‚Üí S\nf_incr : Monotone f\ninst‚úù : F.NeBot\ncobdd : Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) F\n‚ä¢ Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) F f","decl":"lemma Monotone.isCoboundedUnder_le_of_isCobounded {f : R ‚Üí S} (f_incr : Monotone f)\n    [NeBot F] (cobdd : IsCobounded (¬∑ ‚â§ ¬∑) F) :\n    F.IsCoboundedUnder (¬∑ ‚â§ ¬∑) f := by\n  obtain ‚ü®l, hl‚ü© := IsCobounded.frequently_ge cobdd\n  exact IsCobounded.of_frequently_ge <| f_incr.frequently_ge_map_of_frequently_ge hl\n\n"}
{"name":"Monotone.isCoboundedUnder_ge_of_isCobounded","module":"Mathlib.Order.LiminfLimsup","initialProofState":"R : Type u_6\nS : Type u_7\nF : Filter R\ninst‚úù¬≤ : LinearOrder R\ninst‚úù¬π : LinearOrder S\nf : R ‚Üí S\nf_incr : Monotone f\ninst‚úù : F.NeBot\ncobdd : Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) F\n‚ä¢ Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) F f","decl":"lemma Monotone.isCoboundedUnder_ge_of_isCobounded {f : R ‚Üí S} (f_incr : Monotone f)\n    [NeBot F] (cobdd : IsCobounded (¬∑ ‚â• ¬∑) F) :\n    F.IsCoboundedUnder (¬∑ ‚â• ¬∑) f :=\n  Monotone.isCoboundedUnder_le_of_isCobounded (R := R·µí·µà) (S := S·µí·µà) f_incr.dual cobdd\n\n"}
{"name":"Antitone.isCoboundedUnder_le_of_isCobounded","module":"Mathlib.Order.LiminfLimsup","initialProofState":"R : Type u_6\nS : Type u_7\nF : Filter R\ninst‚úù¬≤ : LinearOrder R\ninst‚úù¬π : LinearOrder S\nf : R ‚Üí S\nf_decr : Antitone f\ninst‚úù : F.NeBot\ncobdd : Filter.IsCobounded (fun x1 x2 => GE.ge x1 x2) F\n‚ä¢ Filter.IsCoboundedUnder (fun x1 x2 => LE.le x1 x2) F f","decl":"lemma Antitone.isCoboundedUnder_le_of_isCobounded {f : R ‚Üí S} (f_decr : Antitone f)\n    [NeBot F] (cobdd : IsCobounded (¬∑ ‚â• ¬∑) F) :\n    F.IsCoboundedUnder (¬∑ ‚â§ ¬∑) f :=\n  Monotone.isCoboundedUnder_le_of_isCobounded (R := R·µí·µà) f_decr.dual cobdd\n\n"}
{"name":"Antitone.isCoboundedUnder_ge_of_isCobounded","module":"Mathlib.Order.LiminfLimsup","initialProofState":"R : Type u_6\nS : Type u_7\nF : Filter R\ninst‚úù¬≤ : LinearOrder R\ninst‚úù¬π : LinearOrder S\nf : R ‚Üí S\nf_decr : Antitone f\ninst‚úù : F.NeBot\ncobdd : Filter.IsCobounded (fun x1 x2 => LE.le x1 x2) F\n‚ä¢ Filter.IsCoboundedUnder (fun x1 x2 => GE.ge x1 x2) F f","decl":"lemma Antitone.isCoboundedUnder_ge_of_isCobounded {f : R ‚Üí S} (f_decr : Antitone f)\n    [NeBot F] (cobdd : IsCobounded (¬∑ ‚â§ ¬∑) F) :\n    F.IsCoboundedUnder (¬∑ ‚â• ¬∑) f :=\n  Monotone.isCoboundedUnder_le_of_isCobounded (S := S·µí·µà) f_decr cobdd\n\n"}
