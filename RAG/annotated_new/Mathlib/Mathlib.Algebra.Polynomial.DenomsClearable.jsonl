{"name":"denomsClearable_zero","module":"Mathlib.Algebra.Polynomial.DenomsClearable","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝¹ : Semiring R\ninst✝ : CommSemiring K\ni : RingHom R K\nb : R\nbi : K\nN : Nat\na : R\nbu : Eq (HMul.hMul bi (i b)) 1\n⊢ DenomsClearable a b N 0 i","decl":"theorem denomsClearable_zero (N : ℕ) (a : R) (bu : bi * i b = 1) : DenomsClearable a b N 0 i :=\n  ⟨0, bi, bu, by\n    simp only [eval_zero, RingHom.map_zero, mul_zero, Polynomial.map_zero]⟩\n\n"}
{"name":"denomsClearable_C_mul_X_pow","module":"Mathlib.Algebra.Polynomial.DenomsClearable","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝¹ : Semiring R\ninst✝ : CommSemiring K\ni : RingHom R K\nb : R\nbi : K\nN : Nat\na : R\nbu : Eq (HMul.hMul bi (i b)) 1\nn : Nat\nr : R\nnN : LE.le n N\n⊢ DenomsClearable a b N (HMul.hMul (Polynomial.C r) (HPow.hPow Polynomial.X n)) i","decl":"theorem denomsClearable_C_mul_X_pow {N : ℕ} (a : R) (bu : bi * i b = 1) {n : ℕ} (r : R)\n    (nN : n ≤ N) : DenomsClearable a b N (C r * X ^ n) i := by\n  refine ⟨r * a ^ n * b ^ (N - n), bi, bu, ?_⟩\n  rw [C_mul_X_pow_eq_monomial, map_monomial, ← C_mul_X_pow_eq_monomial, eval_mul, eval_pow, eval_C]\n  rw [RingHom.map_mul, RingHom.map_mul, RingHom.map_pow, RingHom.map_pow, eval_X, mul_comm]\n  rw [← tsub_add_cancel_of_le nN]\n  conv_lhs => rw [← mul_one (i a), ← bu]\n  simp [mul_assoc, mul_comm, mul_left_comm, pow_add, mul_pow]\n\n"}
{"name":"DenomsClearable.add","module":"Mathlib.Algebra.Polynomial.DenomsClearable","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝¹ : Semiring R\ninst✝ : CommSemiring K\ni : RingHom R K\na b : R\nN : Nat\nf g : Polynomial R\na✝¹ : DenomsClearable a b N f i\na✝ : DenomsClearable a b N g i\n⊢ DenomsClearable a b N (HAdd.hAdd f g) i","decl":"theorem DenomsClearable.add {N : ℕ} {f g : R[X]} :\n    DenomsClearable a b N f i → DenomsClearable a b N g i → DenomsClearable a b N (f + g) i :=\n  fun ⟨Df, bf, bfu, Hf⟩ ⟨Dg, bg, bgu, Hg⟩ =>\n  ⟨Df + Dg, bf, bfu, by\n    rw [RingHom.map_add, Polynomial.map_add, eval_add, mul_add, Hf, Hg]\n    congr\n    refine @inv_unique K _ (i b) bg bf ?_ ?_ <;> rwa [mul_comm]⟩\n\n"}
{"name":"denomsClearable_of_natDegree_le","module":"Mathlib.Algebra.Polynomial.DenomsClearable","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝¹ : Semiring R\ninst✝ : CommSemiring K\ni : RingHom R K\nb : R\nbi : K\nN : Nat\na : R\nbu : Eq (HMul.hMul bi (i b)) 1\nf : Polynomial R\na✝ : LE.le f.natDegree N\n⊢ DenomsClearable a b N f i","decl":"theorem denomsClearable_of_natDegree_le (N : ℕ) (a : R) (bu : bi * i b = 1) :\n    ∀ f : R[X], f.natDegree ≤ N → DenomsClearable a b N f i :=\n  induction_with_natDegree_le _ N (denomsClearable_zero N a bu)\n    (fun _ r _ => denomsClearable_C_mul_X_pow a bu r) fun _ _ _ _ df dg => df.add dg\n\n"}
{"name":"denomsClearable_natDegree","module":"Mathlib.Algebra.Polynomial.DenomsClearable","initialProofState":"R : Type u_1\nK : Type u_2\ninst✝¹ : Semiring R\ninst✝ : CommSemiring K\nb : R\nbi : K\ni : RingHom R K\nf : Polynomial R\na : R\nbu : Eq (HMul.hMul bi (i b)) 1\n⊢ DenomsClearable a b f.natDegree f i","decl":"/-- If `i : R → K` is a ring homomorphism, `f` is a polynomial with coefficients in `R`,\n`a, b` are elements of `R`, with `i b` invertible, then there is a `D ∈ R` such that\n`b ^ f.natDegree * f (a / b)` equals `i D`. -/\ntheorem denomsClearable_natDegree (i : R →+* K) (f : R[X]) (a : R) (bu : bi * i b = 1) :\n    DenomsClearable a b f.natDegree f i :=\n  denomsClearable_of_natDegree_le f.natDegree a bu f le_rfl\n\n"}
{"name":"one_le_pow_mul_abs_eval_div","module":"Mathlib.Algebra.Polynomial.DenomsClearable","initialProofState":"K : Type u_1\ninst✝ : LinearOrderedField K\nf : Polynomial Int\na b : Int\nb0 : LT.lt 0 b\nfab : Ne (Polynomial.eval (HDiv.hDiv ↑a ↑b) (Polynomial.map (algebraMap Int K) f)) 0\n⊢ LE.le 1 (HMul.hMul (HPow.hPow (↑b) f.natDegree) (abs (Polynomial.eval (HDiv.hDiv ↑a ↑b) (Polynomial.map (algebraMap Int K) f))))","decl":"/-- Evaluating a polynomial with integer coefficients at a rational number and clearing\ndenominators, yields a number greater than or equal to one.  The target can be any\n`LinearOrderedField K`.\nThe assumption on `K` could be weakened to `LinearOrderedCommRing` assuming that the\nimage of the denominator is invertible in `K`. -/\ntheorem one_le_pow_mul_abs_eval_div {K : Type*} [LinearOrderedField K] {f : ℤ[X]} {a b : ℤ}\n    (b0 : 0 < b) (fab : eval ((a : K) / b) (f.map (algebraMap ℤ K)) ≠ 0) :\n    (1 : K) ≤ (b : K) ^ f.natDegree * |eval ((a : K) / b) (f.map (algebraMap ℤ K))| := by\n  obtain ⟨ev, bi, bu, hF⟩ :=\n    denomsClearable_natDegree (b := b) (algebraMap ℤ K) f a\n      (by\n        rw [eq_intCast, one_div_mul_cancel]\n        rw [Int.cast_ne_zero]\n        exact b0.ne.symm)\n  obtain Fa := congr_arg abs hF\n  rw [eq_one_div_of_mul_eq_one_left bu, eq_intCast, eq_intCast, abs_mul] at Fa\n  rw [abs_of_pos (pow_pos (Int.cast_pos.mpr b0) _ : 0 < (b : K) ^ _), one_div, eq_intCast] at Fa\n  rw [div_eq_mul_inv, ← Fa, ← Int.cast_abs, ← Int.cast_one, Int.cast_le]\n  refine Int.le_of_lt_add_one ((lt_add_iff_pos_left 1).mpr (abs_pos.mpr fun F0 => fab ?_))\n  rw [eq_one_div_of_mul_eq_one_left bu, F0, one_div, eq_intCast, Int.cast_zero, zero_eq_mul] at hF\n  cases' hF with hF hF\n  · exact (not_le.mpr b0 (le_of_eq (Int.cast_eq_zero.mp (pow_eq_zero hF)))).elim\n  · rwa [div_eq_mul_inv]\n"}
