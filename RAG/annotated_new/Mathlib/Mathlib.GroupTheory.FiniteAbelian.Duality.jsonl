{"name":"CommGroup.exists_apply_ne_one_of_hasEnoughRootsOfUnity","module":"Mathlib.GroupTheory.FiniteAbelian.Duality","initialProofState":"G : Type u_1\nM : Type u_2\ninst✝³ : CommGroup G\ninst✝² : Finite G\ninst✝¹ : CommMonoid M\ninst✝ : HasEnoughRootsOfUnity M (Monoid.exponent G)\na : G\nha : Ne a 1\n⊢ Exists fun φ => Ne (φ a) 1","decl":"/-- If `G` is a finite commutative group of exponent `n` and `M` is a commutative monoid\nwith enough `n`th roots of unity, then for each `a ≠ 1` in `G`, there exists a\ngroup homomorphism `φ : G → Mˣ` such that `φ a ≠ 1`. -/\ntheorem exists_apply_ne_one_of_hasEnoughRootsOfUnity {a : G} (ha : a ≠ 1) :\n    ∃ φ : G →* Mˣ, φ a ≠ 1 := by\n  refine exists_apply_ne_one_aux G Mˣ (fun n hn a ha₀ ↦ ?_) ha\n  have : NeZero n := ⟨fun H ↦ NeZero.ne _ <| Nat.eq_zero_of_zero_dvd (H ▸ hn)⟩\n  have := HasEnoughRootsOfUnity.of_dvd M hn\n  exact ZMod.exists_monoidHom_apply_ne_one (HasEnoughRootsOfUnity.exists_primitiveRoot M n) ha₀\n\n"}
{"name":"CommGroup.monoidHom_mulEquiv_of_hasEnoughRootsOfUnity","module":"Mathlib.GroupTheory.FiniteAbelian.Duality","initialProofState":"G : Type u_1\nM : Type u_2\ninst✝³ : CommGroup G\ninst✝² : Finite G\ninst✝¹ : CommMonoid M\ninst✝ : HasEnoughRootsOfUnity M (Monoid.exponent G)\n⊢ Nonempty (MulEquiv (MonoidHom G (Units M)) G)","decl":"/-- A finite commutative group `G` is (noncanonically) isomorphic to the group `G →* Mˣ`\nwhen `M` is a commutative monoid with enough `n`th roots of unity, where `n` is the exponent\nof `G`. -/\ntheorem monoidHom_mulEquiv_of_hasEnoughRootsOfUnity : Nonempty ((G →* Mˣ) ≃* G) := by\n  classical -- to get `DecidableEq ι`\n  obtain ⟨ι, _, n, ⟨h₁, h₂⟩⟩ := equiv_prod_multiplicative_zmod_of_finite G\n  let e := h₂.some\n  let e' := Pi.monoidHomMulEquiv (fun i ↦ Multiplicative (ZMod (n i))) Mˣ\n  let e'' := MulEquiv.monoidHomCongr e (.refl Mˣ)\n  have : ∀ i, NeZero (n i) := fun i ↦ NeZero.of_gt (h₁ i)\n  have inst i : HasEnoughRootsOfUnity M <| Nat.card <| Multiplicative <| ZMod (n i) := by\n    have hdvd : Nat.card (Multiplicative (ZMod (n i))) ∣ Monoid.exponent G := by\n      simpa only [Nat.card_eq_fintype_card, Fintype.card_multiplicative, ZMod.card]\n        using dvd_exponent e i\n    exact HasEnoughRootsOfUnity.of_dvd M hdvd\n  let E i := (IsCyclic.monoidHom_equiv_self (Multiplicative (ZMod (n i))) M).some\n  exact ⟨e''.trans <| e'.trans <| (MulEquiv.piCongrRight E).trans e.symm⟩\n\n"}
