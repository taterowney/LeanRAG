{"name":"IsLocalization.mk'_mem_iff","module":"Mathlib.RingTheory.Localization.Ideal","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\ny : Subtype fun x => Membership.mem M x\nI : Ideal S\n⊢ Iff (Membership.mem I (IsLocalization.mk' S x y)) (Membership.mem I ((algebraMap R S) x))","decl":"variable {M S} in\ntheorem mk'_mem_iff {x} {y : M} {I : Ideal S} : mk' S x y ∈ I ↔ algebraMap R S x ∈ I := by\n  constructor <;> intro h\n  · rw [← mk'_spec S x y, mul_comm]\n    exact I.mul_mem_left ((algebraMap R S) y) h\n  · rw [← mk'_spec S x y] at h\n    obtain ⟨b, hb⟩ := isUnit_iff_exists_inv.1 (map_units S y)\n    have := I.mul_mem_left b h\n    rwa [mul_comm, mul_assoc, hb, mul_one] at this\n\n"}
{"name":"IsLocalization.mem_map_algebraMap_iff","module":"Mathlib.RingTheory.Localization.Ideal","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nI : Ideal R\nz : S\n⊢ Iff (Membership.mem (Ideal.map (algebraMap R S) I) z) (Exists fun x => Eq (HMul.hMul z ((algebraMap R S) ↑x.2)) ((algebraMap R S) ↑x.1))","decl":"theorem mem_map_algebraMap_iff {I : Ideal R} {z} : z ∈ Ideal.map (algebraMap R S) I ↔\n    ∃ x : I × M, z * algebraMap R S x.2 = algebraMap R S x.1 := by\n  constructor\n  · change _ → z ∈ map_ideal M S I\n    refine fun h => Ideal.mem_sInf.1 h fun z hz => ?_\n    obtain ⟨y, hy⟩ := hz\n    let Z : { x // x ∈ I } := ⟨y, hy.left⟩\n    use ⟨Z, 1⟩\n    simp [Z, hy.right]\n  · rintro ⟨⟨a, s⟩, h⟩\n    rw [← Ideal.unit_mul_mem_iff_mem _ (map_units S s), mul_comm]\n    exact h.symm ▸ Ideal.mem_map_of_mem _ a.2\n\n"}
{"name":"IsLocalization.mk'_mem_map_algebraMap_iff","module":"Mathlib.RingTheory.Localization.Ideal","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nI : Ideal R\nx : R\ns : Subtype fun x => Membership.mem M x\n⊢ Iff (Membership.mem (Ideal.map (algebraMap R S) I) (IsLocalization.mk' S x s)) (Exists fun s => And (Membership.mem M s) (Membership.mem I (HMul.hMul s x)))","decl":"lemma mk'_mem_map_algebraMap_iff (I : Ideal R) (x : R) (s : M) :\n    IsLocalization.mk' S x s ∈ I.map (algebraMap R S) ↔ ∃ s ∈ M, s * x ∈ I := by\n  rw [← Ideal.unit_mul_mem_iff_mem _ (IsLocalization.map_units S s), IsLocalization.mk'_spec',\n    IsLocalization.mem_map_algebraMap_iff M]\n  simp_rw [← map_mul, IsLocalization.eq_iff_exists M, mul_comm x, ← mul_assoc, ← Submonoid.coe_mul]\n  exact ⟨fun ⟨⟨y, t⟩, c, h⟩ ↦ ⟨_, (c * t).2, h ▸ I.mul_mem_left c.1 y.2⟩, fun ⟨s, hs, h⟩ ↦\n    ⟨⟨⟨_, h⟩, ⟨s, hs⟩⟩, 1, by simp⟩⟩\n\n"}
{"name":"IsLocalization.algebraMap_mem_map_algebraMap_iff","module":"Mathlib.RingTheory.Localization.Ideal","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nI : Ideal R\nx : R\n⊢ Iff (Membership.mem (Ideal.map (algebraMap R S) I) ((algebraMap R S) x)) (Exists fun m => And (Membership.mem M m) (Membership.mem I (HMul.hMul m x)))","decl":"lemma algebraMap_mem_map_algebraMap_iff (I : Ideal R) (x : R) :\n    algebraMap R S x ∈ I.map (algebraMap R S) ↔\n      ∃ m ∈ M, m * x ∈ I := by\n  rw [← IsLocalization.mk'_one (M := M), mk'_mem_map_algebraMap_iff]\n\n"}
{"name":"IsLocalization.map_algebraMap_ne_top_iff_disjoint","module":"Mathlib.RingTheory.Localization.Ideal","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nI : Ideal R\n⊢ Iff (Ne (Ideal.map (algebraMap R S) I) Top.top) (Disjoint ↑M ↑I)","decl":"lemma map_algebraMap_ne_top_iff_disjoint (I : Ideal R) :\n    I.map (algebraMap R S) ≠ ⊤ ↔ Disjoint (M : Set R) (I : Set R) := by\n  simp only [ne_eq, Ideal.eq_top_iff_one, ← map_one (algebraMap R S), not_iff_comm,\n    IsLocalization.algebraMap_mem_map_algebraMap_iff M]\n  simp [Set.disjoint_left]\n\n"}
{"name":"IsLocalization.map_comap","module":"Mathlib.RingTheory.Localization.Ideal","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nJ : Ideal S\n⊢ Eq (Ideal.map (algebraMap R S) (Ideal.comap (algebraMap R S) J)) J","decl":"include M in\ntheorem map_comap (J : Ideal S) :\n    Ideal.map (algebraMap R S) (Ideal.comap (algebraMap R S) J) = J :=\n  le_antisymm (Ideal.map_le_iff_le_comap.2 le_rfl) fun x hJ => by\n    obtain ⟨r, s, hx⟩ := mk'_surjective M x\n    rw [← hx] at hJ ⊢\n    exact\n      Ideal.mul_mem_right _ _\n        (Ideal.mem_map_of_mem _\n          (show (algebraMap R S) r ∈ J from\n            mk'_spec S r s ▸ J.mul_mem_right ((algebraMap R S) s) hJ))\n\n"}
{"name":"IsLocalization.comap_map_of_isPrime_disjoint","module":"Mathlib.RingTheory.Localization.Ideal","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nI : Ideal R\nhI : I.IsPrime\nhM : Disjoint ↑M ↑I\n⊢ Eq (Ideal.comap (algebraMap R S) (Ideal.map (algebraMap R S) I)) I","decl":"theorem comap_map_of_isPrime_disjoint (I : Ideal R) (hI : I.IsPrime) (hM : Disjoint (M : Set R) I) :\n    Ideal.comap (algebraMap R S) (Ideal.map (algebraMap R S) I) = I := by\n  refine le_antisymm ?_ Ideal.le_comap_map\n  refine (fun a ha => ?_)\n  obtain ⟨⟨b, s⟩, h⟩ := (mem_map_algebraMap_iff M S).1 (Ideal.mem_comap.1 ha)\n  replace h : algebraMap R S (s * a) = algebraMap R S b := by\n    simpa only [← map_mul, mul_comm] using h\n  obtain ⟨c, hc⟩ := (eq_iff_exists M S).1 h\n  have : ↑c * ↑s * a ∈ I := by\n    rw [mul_assoc, hc]\n    exact I.mul_mem_left c b.2\n  exact (hI.mem_or_mem this).resolve_left fun hsc => hM.le_bot ⟨(c * s).2, hsc⟩\n\n"}
{"name":"IsLocalization.isPrime_iff_isPrime_disjoint","module":"Mathlib.RingTheory.Localization.Ideal","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nJ : Ideal S\n⊢ Iff J.IsPrime (And (Ideal.comap (algebraMap R S) J).IsPrime (Disjoint ↑M ↑(Ideal.comap (algebraMap R S) J)))","decl":"/-- If `R` is a ring, then prime ideals in the localization at `M`\ncorrespond to prime ideals in the original ring `R` that are disjoint from `M`.\nThis lemma gives the particular case for an ideal and its comap,\nsee `le_rel_iso_of_prime` for the more general relation isomorphism -/\ntheorem isPrime_iff_isPrime_disjoint (J : Ideal S) :\n    J.IsPrime ↔\n      (Ideal.comap (algebraMap R S) J).IsPrime ∧\n        Disjoint (M : Set R) ↑(Ideal.comap (algebraMap R S) J) := by\n  constructor\n  · refine fun h =>\n      ⟨⟨?_, ?_⟩,\n        Set.disjoint_left.mpr fun m hm1 hm2 =>\n          h.ne_top (Ideal.eq_top_of_isUnit_mem _ hm2 (map_units S ⟨m, hm1⟩))⟩\n    · refine fun hJ => h.ne_top ?_\n      rw [eq_top_iff, ← (orderEmbedding M S).le_iff_le]\n      exact le_of_eq hJ.symm\n    · intro x y hxy\n      rw [Ideal.mem_comap, RingHom.map_mul] at hxy\n      exact h.mem_or_mem hxy\n  · refine fun h => ⟨fun hJ => h.left.ne_top (eq_top_iff.2 ?_), ?_⟩\n    · rwa [eq_top_iff, ← (orderEmbedding M S).le_iff_le] at hJ\n    · intro x y hxy\n      obtain ⟨a, s, ha⟩ := mk'_surjective M x\n      obtain ⟨b, t, hb⟩ := mk'_surjective M y\n      have : mk' S (a * b) (s * t) ∈ J := by rwa [mk'_mul, ha, hb]\n      rw [mk'_mem_iff, ← Ideal.mem_comap] at this\n      have this₂ := (h.1).mul_mem_iff_mem_or_mem.1 this\n      rw [Ideal.mem_comap, Ideal.mem_comap] at this₂\n      rwa [← ha, ← hb, mk'_mem_iff, mk'_mem_iff]\n\n"}
{"name":"IsLocalization.isPrime_of_isPrime_disjoint","module":"Mathlib.RingTheory.Localization.Ideal","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nI : Ideal R\nhp : I.IsPrime\nhd : Disjoint ↑M ↑I\n⊢ (Ideal.map (algebraMap R S) I).IsPrime","decl":"/-- If `R` is a ring, then prime ideals in the localization at `M`\ncorrespond to prime ideals in the original ring `R` that are disjoint from `M`.\nThis lemma gives the particular case for an ideal and its map,\nsee `le_rel_iso_of_prime` for the more general relation isomorphism, and the reverse implication -/\ntheorem isPrime_of_isPrime_disjoint (I : Ideal R) (hp : I.IsPrime) (hd : Disjoint (M : Set R) ↑I) :\n    (Ideal.map (algebraMap R S) I).IsPrime := by\n  rw [isPrime_iff_isPrime_disjoint M S, comap_map_of_isPrime_disjoint M S I hp hd]\n  exact ⟨hp, hd⟩\n\n"}
{"name":"IsLocalization.surjective_quotientMap_of_maximal_of_localization","module":"Mathlib.RingTheory.Localization.Ideal","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : IsLocalization M S\nI : Ideal S\ninst✝ : I.IsPrime\nJ : Ideal R\nH : LE.le J (Ideal.comap (algebraMap R S) I)\nhI : (Ideal.comap (algebraMap R S) I).IsMaximal\n⊢ Function.Surjective ⇑(Ideal.quotientMap I (algebraMap R S) H)","decl":"include M in\n/-- `quotientMap` applied to maximal ideals of a localization is `surjective`.\n  The quotient by a maximal ideal is a field, so inverses to elements already exist,\n  and the localization necessarily maps the equivalence class of the inverse in the localization -/\ntheorem surjective_quotientMap_of_maximal_of_localization {I : Ideal S} [I.IsPrime] {J : Ideal R}\n    {H : J ≤ I.comap (algebraMap R S)} (hI : (I.comap (algebraMap R S)).IsMaximal) :\n    Function.Surjective (Ideal.quotientMap I (algebraMap R S) H) := by\n  intro s\n  obtain ⟨s, rfl⟩ := Ideal.Quotient.mk_surjective s\n  obtain ⟨r, ⟨m, hm⟩, rfl⟩ := mk'_surjective M s\n  by_cases hM : (Ideal.Quotient.mk (I.comap (algebraMap R S))) m = 0\n  · have : I = ⊤ := by\n      rw [Ideal.eq_top_iff_one]\n      rw [Ideal.Quotient.eq_zero_iff_mem, Ideal.mem_comap] at hM\n      convert I.mul_mem_right (mk' S (1 : R) ⟨m, hm⟩) hM\n      rw [← mk'_eq_mul_mk'_one, mk'_self]\n    exact ⟨0, eq_comm.1 (by simp [Ideal.Quotient.eq_zero_iff_mem, this])⟩\n  · rw [Ideal.Quotient.maximal_ideal_iff_isField_quotient] at hI\n    obtain ⟨n, hn⟩ := hI.3 hM\n    obtain ⟨rn, rfl⟩ := Ideal.Quotient.mk_surjective n\n    refine ⟨(Ideal.Quotient.mk J) (r * rn), ?_⟩\n    -- The rest of the proof is essentially just algebraic manipulations to prove the equality\n    replace hn := congr_arg (Ideal.quotientMap I (algebraMap R S) le_rfl) hn\n    rw [RingHom.map_one, RingHom.map_mul] at hn\n    rw [Ideal.quotientMap_mk, ← sub_eq_zero, ← RingHom.map_sub, Ideal.Quotient.eq_zero_iff_mem, ←\n      Ideal.Quotient.eq_zero_iff_mem, RingHom.map_sub, sub_eq_zero, mk'_eq_mul_mk'_one]\n    simp only [mul_eq_mul_left_iff, RingHom.map_mul]\n    refine\n      Or.inl\n        (mul_left_cancel₀ (M₀ := S ⧸ I)\n          (fun hn =>\n            hM\n              (Ideal.Quotient.eq_zero_iff_mem.2\n                (Ideal.mem_comap.2 (Ideal.Quotient.eq_zero_iff_mem.1 hn))))\n          (_root_.trans hn ?_))\n    rw [← map_mul, ← mk'_eq_mul_mk'_one, mk'_self, RingHom.map_one]\n\n"}
{"name":"IsLocalization.bot_lt_comap_prime","module":"Mathlib.RingTheory.Localization.Ideal","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : IsLocalization M S\ninst✝ : IsDomain R\nhM : LE.le M (nonZeroDivisors R)\np : Ideal S\nhpp : p.IsPrime\nhp0 : Ne p Bot.bot\n⊢ LT.lt Bot.bot (Ideal.comap (algebraMap R S) p)","decl":"theorem bot_lt_comap_prime [IsDomain R] (hM : M ≤ R⁰) (p : Ideal S) [hpp : p.IsPrime]\n    (hp0 : p ≠ ⊥) : ⊥ < Ideal.comap (algebraMap R S) p := by\n  haveI : IsDomain S := isDomain_of_le_nonZeroDivisors _ hM\n  rw [← Ideal.comap_bot_of_injective (algebraMap R S) (IsLocalization.injective _ hM)]\n  convert (orderIsoOfPrime M S).lt_iff_lt.mpr (show (⟨⊥, Ideal.bot_prime⟩ :\n    { p : Ideal S // p.IsPrime }) < ⟨p, hpp⟩ from hp0.bot_lt)\n\n"}
{"name":"IsLocalization.ideal_eq_iInf_comap_map_away","module":"Mathlib.RingTheory.Localization.Ideal","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nS : Finset R\nhS : Eq (Ideal.span ↑S) Top.top\nI : Ideal R\n⊢ Eq I (iInf fun f => iInf fun h => Ideal.comap (algebraMap R (Localization.Away f)) (Ideal.map (algebraMap R (Localization.Away f)) I))","decl":"theorem ideal_eq_iInf_comap_map_away {S : Finset R} (hS : Ideal.span (α := R) S = ⊤) (I : Ideal R) :\n    I = ⨅ f ∈ S, (I.map (algebraMap R (Localization.Away f))).comap\n    (algebraMap R (Localization.Away f)) := by\n  apply le_antisymm\n  · simp only [le_iInf₂_iff, ← Ideal.map_le_iff_le_comap, le_refl, implies_true]\n  · intro x hx\n    apply Submodule.mem_of_span_eq_top_of_smul_pow_mem _ _ hS\n    rintro ⟨s, hs⟩\n    simp only [Ideal.mem_iInf, Ideal.mem_comap] at hx\n    obtain ⟨⟨y, ⟨_, n, rfl⟩⟩, e⟩ :=\n      (IsLocalization.mem_map_algebraMap_iff (.powers s) _).mp (hx s hs)\n    dsimp only at e\n    rw [← map_mul, IsLocalization.eq_iff_exists (.powers s)] at e\n    obtain ⟨⟨_, m, rfl⟩, e⟩ := e\n    use m + n\n    dsimp at e ⊢\n    rw [pow_add, mul_assoc, ← mul_comm x, e]\n    exact I.mul_mem_left _ y.2\n\n"}
{"name":"NoZeroSMulDivisors_of_isLocalization","module":"Mathlib.RingTheory.Localization.Ideal","initialProofState":"R : Type u_1\ninst✝¹⁴ : CommRing R\nS : Type u_2\ninst✝¹³ : CommRing S\ninst✝¹² : Algebra R S\nRₚ : Type u_3\nSₚ : Type u_4\ninst✝¹¹ : CommRing Rₚ\ninst✝¹⁰ : CommRing Sₚ\ninst✝⁹ : Algebra R Rₚ\ninst✝⁸ : Algebra R Sₚ\ninst✝⁷ : Algebra S Sₚ\ninst✝⁶ : Algebra Rₚ Sₚ\ninst✝⁵ : IsScalarTower R S Sₚ\ninst✝⁴ : IsScalarTower R Rₚ Sₚ\nM : Submonoid R\nhM : LE.le M (nonZeroDivisors R)\ninst✝³ : IsLocalization M Rₚ\ninst✝² : IsLocalization (Algebra.algebraMapSubmonoid S M) Sₚ\ninst✝¹ : NoZeroSMulDivisors R S\ninst✝ : IsDomain S\n⊢ NoZeroSMulDivisors Rₚ Sₚ","decl":"variable (R) in\nlemma _root_.NoZeroSMulDivisors_of_isLocalization (Rₚ Sₚ : Type*) [CommRing Rₚ] [CommRing Sₚ]\n    [Algebra R Rₚ] [Algebra R Sₚ] [Algebra S Sₚ] [Algebra Rₚ Sₚ] [IsScalarTower R S Sₚ]\n    [IsScalarTower R Rₚ Sₚ] {M : Submonoid R} (hM : M ≤ R⁰) [IsLocalization M Rₚ]\n    [IsLocalization (Algebra.algebraMapSubmonoid S M) Sₚ] [NoZeroSMulDivisors R S] [IsDomain S] :\n    NoZeroSMulDivisors Rₚ Sₚ := by\n  have e : Algebra.algebraMapSubmonoid S M ≤ S⁰ :=\n    Submonoid.map_le_of_le_comap _ <| hM.trans\n      (nonZeroDivisors_le_comap_nonZeroDivisors_of_injective _\n        (NoZeroSMulDivisors.algebraMap_injective _ _))\n  have : IsDomain Sₚ := IsLocalization.isDomain_of_le_nonZeroDivisors S e\n  have : algebraMap Rₚ Sₚ = IsLocalization.map (T := Algebra.algebraMapSubmonoid S M) Sₚ\n    (algebraMap R S) (Submonoid.le_comap_map M) := by\n    apply IsLocalization.ringHom_ext M\n    simp only [IsLocalization.map_comp, ← IsScalarTower.algebraMap_eq]\n  rw [NoZeroSMulDivisors.iff_algebraMap_injective, RingHom.injective_iff_ker_eq_bot,\n    RingHom.ker_eq_bot_iff_eq_zero]\n  intro x hx\n  obtain ⟨x, s, rfl⟩ := IsLocalization.mk'_surjective M x\n  simp only [RingHom.algebraMap_toAlgebra, IsLocalization.map_mk', IsLocalization.mk'_eq_zero_iff,\n    Subtype.exists, exists_prop, this] at hx ⊢\n  obtain ⟨_, ⟨a, ha, rfl⟩, H⟩ := hx\n  simp only [← _root_.map_mul,\n    (injective_iff_map_eq_zero' _).mp (NoZeroSMulDivisors.algebraMap_injective R S)] at H\n  exact ⟨a, ha, H⟩\n\n"}
