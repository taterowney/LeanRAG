{"name":"CategoryTheory.Adjunction.functorialityUnit_app_hom","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nJ : Type u\ninst‚úù : CategoryTheory.Category.{v, u} J\nK : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone K\n‚ä¢ Eq ((adj.functorialityUnit K).app c).hom (adj.unit.app c.pt)","decl":"/-- The unit for the adjunction for `Cocones.functoriality K F : Cocone K ‚•§ Cocone (K ‚ãô F)`.\n\nAuxiliary definition for `functorialityIsLeftAdjoint`.\n-/\n@[simps]\ndef functorialityUnit :\n    ùü≠ (Cocone K) ‚ü∂ Cocones.functoriality _ F ‚ãô functorialityRightAdjoint adj K where\n  app c := { hom := adj.unit.app c.pt }\n\n"}
{"name":"CategoryTheory.Adjunction.functorialityCounit_app_hom","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nJ : Type u\ninst‚úù : CategoryTheory.Category.{v, u} J\nK : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone (K.comp F)\n‚ä¢ Eq ((adj.functorialityCounit K).app c).hom (adj.counit.app c.pt)","decl":"/-- The counit for the adjunction for `Cocones.functoriality K F : Cocone K ‚•§ Cocone (K ‚ãô F)`.\n\nAuxiliary definition for `functorialityIsLeftAdjoint`.\n-/\n@[simps]\ndef functorialityCounit :\n    functorialityRightAdjoint adj K ‚ãô Cocones.functoriality _ F ‚ü∂ ùü≠ (Cocone (K ‚ãô F)) where\n  app c := { hom := adj.counit.app c.pt }\n\n"}
{"name":"CategoryTheory.Adjunction.leftAdjoint_preservesColimits","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfSize.{v, u, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"include adj in\n/-- A left adjoint preserves colimits. -/\n@[stacks 0038]\nlemma leftAdjoint_preservesColimits : PreservesColimitsOfSize.{v, u} F where\n  preservesColimitsOfShape :=\n    { preservesColimit :=\n        { preserves := fun hc =>\n            ‚ü®IsColimit.isoUniqueCoconeMorphism.inv fun _ =>\n              @Equiv.unique _ _ (IsColimit.isoUniqueCoconeMorphism.hom hc _)\n                ((adj.functorialityAdjunction _).homEquiv _ _)‚ü© } }\n\n"}
{"name":"CategoryTheory.Adjunction.leftAdjointPreservesColimits","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfSize.{v, u, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} F","decl":"include adj in\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-11-19\")]\nlemma leftAdjointPreservesColimits : PreservesColimitsOfSize.{v, u} F :=\n  adj.leftAdjoint_preservesColimits\n\n"}
{"name":"CategoryTheory.Adjunction.colim_preservesColimits","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} J\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape J C\n‚ä¢ CategoryTheory.Limits.PreservesColimits CategoryTheory.Limits.colim","decl":"noncomputable\ninstance colim_preservesColimits [HasColimitsOfShape J C] :\n    PreservesColimits (colim (J := J) (C := C)) :=\n  colimConstAdj.leftAdjoint_preservesColimits\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Adjunction.isEquivalence_preservesColimits","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : CategoryTheory.Functor C D\ninst‚úù : E.IsEquivalence\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfSize.{v, u, v‚ÇÅ, v‚ÇÇ, u‚ÇÅ, u‚ÇÇ} E","decl":"noncomputable instance (priority := 100) isEquivalence_preservesColimits\n    (E : C ‚•§ D) [E.IsEquivalence] :\n    PreservesColimitsOfSize.{v, u} E :=\n  leftAdjoint_preservesColimits E.adjunction\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Functor.reflectsColimits_of_isEquivalence","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : CategoryTheory.Functor D C\ninst‚úù : E.IsEquivalence\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfSize.{v, u, v‚ÇÇ, v‚ÇÅ, u‚ÇÇ, u‚ÇÅ} E","decl":"noncomputable instance (priority := 100)\n    _root_.CategoryTheory.Functor.reflectsColimits_of_isEquivalence\n    (E : D ‚•§ C) [E.IsEquivalence] :\n    ReflectsColimitsOfSize.{v, u} E where\n  reflectsColimitsOfShape :=\n    { reflectsColimit :=\n        { reflects := fun t =>\n          ‚ü®(isColimitOfPreserves E.inv t).mapCoconeEquiv E.asEquivalence.unitIso.symm‚ü© } }\n\n"}
{"name":"CategoryTheory.Adjunction.isEquivalenceReflectsColimits","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : CategoryTheory.Functor D C\ninst‚úù : E.IsEquivalence\n‚ä¢ CategoryTheory.Limits.ReflectsColimitsOfSize.{v, u, v‚ÇÇ, v‚ÇÅ, u‚ÇÇ, u‚ÇÅ} E","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-11-18\")]\nlemma isEquivalenceReflectsColimits (E : D ‚•§ C) [E.IsEquivalence] :\n    ReflectsColimitsOfSize.{v, u} E :=\n  Functor.reflectsColimits_of_isEquivalence E\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Adjunction.hasColimit_comp_equivalence","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} J\nK : CategoryTheory.Functor J C\nE : CategoryTheory.Functor C D\ninst‚úù¬π : E.IsEquivalence\ninst‚úù : CategoryTheory.Limits.HasColimit K\n‚ä¢ CategoryTheory.Limits.HasColimit (K.comp E)","decl":"theorem hasColimit_comp_equivalence (E : C ‚•§ D) [E.IsEquivalence] [HasColimit K] :\n    HasColimit (K ‚ãô E) :=\n  HasColimit.mk\n    { cocone := E.mapCocone (colimit.cocone K)\n      isColimit := isColimitOfPreserves _ (colimit.isColimit K) }\n\n"}
{"name":"CategoryTheory.Adjunction.hasColimit_of_comp_equivalence","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} J\nK : CategoryTheory.Functor J C\nE : CategoryTheory.Functor C D\ninst‚úù¬π : E.IsEquivalence\ninst‚úù : CategoryTheory.Limits.HasColimit (K.comp E)\n‚ä¢ CategoryTheory.Limits.HasColimit K","decl":"theorem hasColimit_of_comp_equivalence (E : C ‚•§ D) [E.IsEquivalence] [HasColimit (K ‚ãô E)] :\n    HasColimit K :=\n  @hasColimitOfIso _ _ _ _ (K ‚ãô E ‚ãô E.inv) K\n    (@hasColimit_comp_equivalence _ _ _ _ _ _ (K ‚ãô E) E.inv _ _)\n    ((Functor.rightUnitor _).symm ‚â™‚â´ isoWhiskerLeft K E.asEquivalence.unitIso)\n\n"}
{"name":"CategoryTheory.Adjunction.hasColimitsOfShape_of_equivalence","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} J\nE : CategoryTheory.Functor C D\ninst‚úù¬π : E.IsEquivalence\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape J D\n‚ä¢ CategoryTheory.Limits.HasColimitsOfShape J C","decl":"/-- Transport a `HasColimitsOfShape` instance across an equivalence. -/\ntheorem hasColimitsOfShape_of_equivalence (E : C ‚•§ D) [E.IsEquivalence] [HasColimitsOfShape J D] :\n    HasColimitsOfShape J C :=\n  ‚ü®fun F => hasColimit_of_comp_equivalence F E‚ü©\n\n"}
{"name":"CategoryTheory.Adjunction.has_colimits_of_equivalence","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : CategoryTheory.Functor C D\ninst‚úù¬π : E.IsEquivalence\ninst‚úù : CategoryTheory.Limits.HasColimitsOfSize.{v, u, v‚ÇÇ, u‚ÇÇ} D\n‚ä¢ CategoryTheory.Limits.HasColimitsOfSize.{v, u, v‚ÇÅ, u‚ÇÅ} C","decl":"/-- Transport a `HasColimitsOfSize` instance across an equivalence. -/\ntheorem has_colimits_of_equivalence (E : C ‚•§ D) [E.IsEquivalence] [HasColimitsOfSize.{v, u} D] :\n    HasColimitsOfSize.{v, u} C :=\n  ‚ü®fun _ _ => hasColimitsOfShape_of_equivalence E‚ü©\n\n"}
{"name":"CategoryTheory.Adjunction.functorialityUnit'_app_hom","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nJ : Type u\ninst‚úù : CategoryTheory.Category.{v, u} J\nK : CategoryTheory.Functor J D\nc : CategoryTheory.Limits.Cone (K.comp G)\n‚ä¢ Eq ((adj.functorialityUnit' K).app c).hom (adj.unit.app c.pt)","decl":"/-- The unit for the adjunction for `Cones.functoriality K G : Cone K ‚•§ Cone (K ‚ãô G)`.\n\nAuxiliary definition for `functorialityIsRightAdjoint`.\n-/\n@[simps]\ndef functorialityUnit' :\n    ùü≠ (Cone (K ‚ãô G)) ‚ü∂ functorialityLeftAdjoint adj K ‚ãô Cones.functoriality _ G where\n  app c := { hom := adj.unit.app c.pt }\n\n"}
{"name":"CategoryTheory.Adjunction.functorialityCounit'_app_hom","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nJ : Type u\ninst‚úù : CategoryTheory.Category.{v, u} J\nK : CategoryTheory.Functor J D\nc : CategoryTheory.Limits.Cone K\n‚ä¢ Eq ((adj.functorialityCounit' K).app c).hom (adj.counit.app c.pt)","decl":"/-- The counit for the adjunction for `Cones.functoriality K G : Cone K ‚•§ Cone (K ‚ãô G)`.\n\nAuxiliary definition for `functorialityIsRightAdjoint`.\n-/\n@[simps]\ndef functorialityCounit' :\n    Cones.functoriality _ G ‚ãô functorialityLeftAdjoint adj K ‚ü∂ ùü≠ (Cone K) where\n  app c := { hom := adj.counit.app c.pt }\n\n"}
{"name":"CategoryTheory.Adjunction.rightAdjoint_preservesLimits","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{v, u, v‚ÇÇ, v‚ÇÅ, u‚ÇÇ, u‚ÇÅ} G","decl":"include adj in\n/-- A right adjoint preserves limits. -/\n@[stacks 0038]\nlemma rightAdjoint_preservesLimits : PreservesLimitsOfSize.{v, u} G where\n  preservesLimitsOfShape :=\n    { preservesLimit :=\n        { preserves := fun hc =>\n            ‚ü®IsLimit.isoUniqueConeMorphism.inv fun _ =>\n              @Equiv.unique _ _ (IsLimit.isoUniqueConeMorphism.hom hc _)\n                ((adj.functorialityAdjunction' _).homEquiv _ _).symm‚ü© } }\n\n"}
{"name":"CategoryTheory.Adjunction.rightAdjointPreservesLimits","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{v, u, v‚ÇÇ, v‚ÇÅ, u‚ÇÇ, u‚ÇÅ} G","decl":"include adj in\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-11-19\")]\nlemma rightAdjointPreservesLimits : PreservesLimitsOfSize.{v, u} G :=\n  adj.rightAdjoint_preservesLimits\n\n"}
{"name":"CategoryTheory.Adjunction.lim_preservesLimits","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} J\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape J C\n‚ä¢ CategoryTheory.Limits.PreservesLimits CategoryTheory.Limits.lim","decl":"instance lim_preservesLimits [HasLimitsOfShape J C] :\n    PreservesLimits (lim (J := J) (C := C)) :=\n  constLimAdj.rightAdjoint_preservesLimits\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Adjunction.isEquivalencePreservesLimits","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : CategoryTheory.Functor D C\ninst‚úù : E.IsEquivalence\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{v, u, v‚ÇÇ, v‚ÇÅ, u‚ÇÇ, u‚ÇÅ} E","decl":"instance (priority := 100) isEquivalencePreservesLimits\n    (E : D ‚•§ C) [E.IsEquivalence] :\n    PreservesLimitsOfSize.{v, u} E :=\n  rightAdjoint_preservesLimits E.asEquivalence.symm.toAdjunction\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Functor.reflectsLimits_of_isEquivalence","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : CategoryTheory.Functor D C\ninst‚úù : E.IsEquivalence\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{v, u, v‚ÇÇ, v‚ÇÅ, u‚ÇÇ, u‚ÇÅ} E","decl":"noncomputable instance (priority := 100)\n    _root_.CategoryTheory.Functor.reflectsLimits_of_isEquivalence\n    (E : D ‚•§ C) [E.IsEquivalence] :\n    ReflectsLimitsOfSize.{v, u} E where\n  reflectsLimitsOfShape :=\n    { reflectsLimit :=\n        { reflects := fun t =>\n            ‚ü®(isLimitOfPreserves E.inv t).mapConeEquiv E.asEquivalence.unitIso.symm‚ü© } }\n\n"}
{"name":"CategoryTheory.Adjunction.isEquivalenceReflectsLimits","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : CategoryTheory.Functor D C\ninst‚úù : E.IsEquivalence\n‚ä¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{v, u, v‚ÇÇ, v‚ÇÅ, u‚ÇÇ, u‚ÇÅ} E","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-11-18\")]\nlemma isEquivalenceReflectsLimits (E : D ‚•§ C) [E.IsEquivalence] :\n    ReflectsLimitsOfSize.{v, u} E :=\n  Functor.reflectsLimits_of_isEquivalence E\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Adjunction.hasLimit_comp_equivalence","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} J\nK : CategoryTheory.Functor J D\nE : CategoryTheory.Functor D C\ninst‚úù¬π : E.IsEquivalence\ninst‚úù : CategoryTheory.Limits.HasLimit K\n‚ä¢ CategoryTheory.Limits.HasLimit (K.comp E)","decl":"theorem hasLimit_comp_equivalence (E : D ‚•§ C) [E.IsEquivalence] [HasLimit K] : HasLimit (K ‚ãô E) :=\n  HasLimit.mk\n    { cone := E.mapCone (limit.cone K)\n      isLimit := isLimitOfPreserves _ (limit.isLimit K) }\n\n"}
{"name":"CategoryTheory.Adjunction.hasLimit_of_comp_equivalence","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} J\nK : CategoryTheory.Functor J D\nE : CategoryTheory.Functor D C\ninst‚úù¬π : E.IsEquivalence\ninst‚úù : CategoryTheory.Limits.HasLimit (K.comp E)\n‚ä¢ CategoryTheory.Limits.HasLimit K","decl":"theorem hasLimit_of_comp_equivalence (E : D ‚•§ C) [E.IsEquivalence] [HasLimit (K ‚ãô E)] :\n    HasLimit K :=\n  @hasLimitOfIso _ _ _ _ (K ‚ãô E ‚ãô E.inv) K\n    (@hasLimit_comp_equivalence _ _ _ _ _ _ (K ‚ãô E) E.inv _ _)\n    (isoWhiskerLeft K E.asEquivalence.unitIso.symm ‚â™‚â´ Functor.rightUnitor _)\n\n"}
{"name":"CategoryTheory.Adjunction.hasLimitsOfShape_of_equivalence","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} J\nE : CategoryTheory.Functor D C\ninst‚úù¬π : E.IsEquivalence\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape J C\n‚ä¢ CategoryTheory.Limits.HasLimitsOfShape J D","decl":"/-- Transport a `HasLimitsOfShape` instance across an equivalence. -/\ntheorem hasLimitsOfShape_of_equivalence (E : D ‚•§ C) [E.IsEquivalence] [HasLimitsOfShape J C] :\n    HasLimitsOfShape J D :=\n  ‚ü®fun F => hasLimit_of_comp_equivalence F E‚ü©\n\n"}
{"name":"CategoryTheory.Adjunction.has_limits_of_equivalence","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : CategoryTheory.Functor D C\ninst‚úù¬π : E.IsEquivalence\ninst‚úù : CategoryTheory.Limits.HasLimitsOfSize.{v, u, v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ CategoryTheory.Limits.HasLimitsOfSize.{v, u, v‚ÇÇ, u‚ÇÇ} D","decl":"/-- Transport a `HasLimitsOfSize` instance across an equivalence. -/\ntheorem has_limits_of_equivalence (E : D ‚•§ C) [E.IsEquivalence] [HasLimitsOfSize.{v, u} C] :\n    HasLimitsOfSize.{v, u} D :=\n  ‚ü®fun _ _ => hasLimitsOfShape_of_equivalence E‚ü©\n\n"}
{"name":"CategoryTheory.Functor.instPreservesColimitsOfShapeOfIsLeftAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"J : Type u_1\nC : Type u_2\nD : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} J\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.IsLeftAdjoint\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape J F","decl":"noncomputable instance [IsLeftAdjoint F] : PreservesColimitsOfShape J F :=\n  (Adjunction.ofIsLeftAdjoint F).leftAdjoint_preservesColimits.preservesColimitsOfShape\n\n"}
{"name":"CategoryTheory.Functor.instPreservesColimitsOfSizeOfIsLeftAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u_2\nD : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.IsLeftAdjoint\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfSize.{v, u, u_4, u_5, u_2, u_3} F","decl":"noncomputable instance [IsLeftAdjoint F] : PreservesColimitsOfSize.{v, u} F where\n\n"}
{"name":"CategoryTheory.Functor.instPreservesLimitsOfShapeOfIsRightAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"J : Type u_1\nC : Type u_2\nD : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} J\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} C\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_3} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.IsRightAdjoint\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J F","decl":"noncomputable instance [IsRightAdjoint F] : PreservesLimitsOfShape J F :=\n  (Adjunction.ofIsRightAdjoint F).rightAdjoint_preservesLimits.preservesLimitsOfShape\n\n"}
{"name":"CategoryTheory.Functor.instPreservesLimitsOfSizeOfIsRightAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u_2\nD : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} C\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_3} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.IsRightAdjoint\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{v, u, u_5, u_4, u_2, u_3} F","decl":"noncomputable instance [IsRightAdjoint F] : PreservesLimitsOfSize.{v, u} F where\n\n"}
