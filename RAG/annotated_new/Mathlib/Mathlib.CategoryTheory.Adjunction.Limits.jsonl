{"name":"CategoryTheory.Adjunction.functorialityUnit_app_hom","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nJ : Type u\ninstâœ : CategoryTheory.Category.{v, u} J\nK : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone K\nâŠ¢ Eq ((adj.functorialityUnit K).app c).hom (adj.unit.app c.pt)","decl":"/-- The unit for the adjunction for `Cocones.functoriality K F : Cocone K â¥¤ Cocone (K â‹™ F)`.\n\nAuxiliary definition for `functorialityIsLeftAdjoint`.\n-/\n@[simps]\ndef functorialityUnit :\n    ğŸ­ (Cocone K) âŸ¶ Cocones.functoriality _ F â‹™ functorialityRightAdjoint adj K where\n  app c := { hom := adj.unit.app c.pt }\n\n"}
{"name":"CategoryTheory.Adjunction.functorialityCounit_app_hom","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nJ : Type u\ninstâœ : CategoryTheory.Category.{v, u} J\nK : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cocone (K.comp F)\nâŠ¢ Eq ((adj.functorialityCounit K).app c).hom (adj.counit.app c.pt)","decl":"/-- The counit for the adjunction for `Cocones.functoriality K F : Cocone K â¥¤ Cocone (K â‹™ F)`.\n\nAuxiliary definition for `functorialityIsLeftAdjoint`.\n-/\n@[simps]\ndef functorialityCounit :\n    functorialityRightAdjoint adj K â‹™ Cocones.functoriality _ F âŸ¶ ğŸ­ (Cocone (K â‹™ F)) where\n  app c := { hom := adj.counit.app c.pt }\n\n"}
{"name":"CategoryTheory.Adjunction.leftAdjoint_preservesColimits","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nâŠ¢ CategoryTheory.Limits.PreservesColimitsOfSize.{v, u, vâ‚, vâ‚‚, uâ‚, uâ‚‚} F","decl":"include adj in\n/-- A left adjoint preserves colimits. -/\n@[stacks 0038]\nlemma leftAdjoint_preservesColimits : PreservesColimitsOfSize.{v, u} F where\n  preservesColimitsOfShape :=\n    { preservesColimit :=\n        { preserves := fun hc =>\n            âŸ¨IsColimit.isoUniqueCoconeMorphism.inv fun _ =>\n              @Equiv.unique _ _ (IsColimit.isoUniqueCoconeMorphism.hom hc _)\n                ((adj.functorialityAdjunction _).homEquiv _ _)âŸ© } }\n\n"}
{"name":"CategoryTheory.Adjunction.leftAdjointPreservesColimits","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nâŠ¢ CategoryTheory.Limits.PreservesColimitsOfSize.{v, u, vâ‚, vâ‚‚, uâ‚, uâ‚‚} F","decl":"include adj in\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-11-19\")]\nlemma leftAdjointPreservesColimits : PreservesColimitsOfSize.{v, u} F :=\n  adj.leftAdjoint_preservesColimits\n\n"}
{"name":"CategoryTheory.Adjunction.colim_preservesColimits","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nJ : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} J\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape J C\nâŠ¢ CategoryTheory.Limits.PreservesColimits CategoryTheory.Limits.colim","decl":"noncomputable\ninstance colim_preservesColimits [HasColimitsOfShape J C] :\n    PreservesColimits (colim (J := J) (C := C)) :=\n  colimConstAdj.leftAdjoint_preservesColimits\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Adjunction.isEquivalence_preservesColimits","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : CategoryTheory.Functor C D\ninstâœ : E.IsEquivalence\nâŠ¢ CategoryTheory.Limits.PreservesColimitsOfSize.{v, u, vâ‚, vâ‚‚, uâ‚, uâ‚‚} E","decl":"noncomputable instance (priority := 100) isEquivalence_preservesColimits\n    (E : C â¥¤ D) [E.IsEquivalence] :\n    PreservesColimitsOfSize.{v, u} E :=\n  leftAdjoint_preservesColimits E.adjunction\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Functor.reflectsColimits_of_isEquivalence","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : CategoryTheory.Functor D C\ninstâœ : E.IsEquivalence\nâŠ¢ CategoryTheory.Limits.ReflectsColimitsOfSize.{v, u, vâ‚‚, vâ‚, uâ‚‚, uâ‚} E","decl":"noncomputable instance (priority := 100)\n    _root_.CategoryTheory.Functor.reflectsColimits_of_isEquivalence\n    (E : D â¥¤ C) [E.IsEquivalence] :\n    ReflectsColimitsOfSize.{v, u} E where\n  reflectsColimitsOfShape :=\n    { reflectsColimit :=\n        { reflects := fun t =>\n          âŸ¨(isColimitOfPreserves E.inv t).mapCoconeEquiv E.asEquivalence.unitIso.symmâŸ© } }\n\n"}
{"name":"CategoryTheory.Adjunction.isEquivalenceReflectsColimits","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : CategoryTheory.Functor D C\ninstâœ : E.IsEquivalence\nâŠ¢ CategoryTheory.Limits.ReflectsColimitsOfSize.{v, u, vâ‚‚, vâ‚, uâ‚‚, uâ‚} E","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-11-18\")]\nlemma isEquivalenceReflectsColimits (E : D â¥¤ C) [E.IsEquivalence] :\n    ReflectsColimitsOfSize.{v, u} E :=\n  Functor.reflectsColimits_of_isEquivalence E\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Adjunction.hasColimit_comp_equivalence","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nJ : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} J\nK : CategoryTheory.Functor J C\nE : CategoryTheory.Functor C D\ninstâœÂ¹ : E.IsEquivalence\ninstâœ : CategoryTheory.Limits.HasColimit K\nâŠ¢ CategoryTheory.Limits.HasColimit (K.comp E)","decl":"theorem hasColimit_comp_equivalence (E : C â¥¤ D) [E.IsEquivalence] [HasColimit K] :\n    HasColimit (K â‹™ E) :=\n  HasColimit.mk\n    { cocone := E.mapCocone (colimit.cocone K)\n      isColimit := isColimitOfPreserves _ (colimit.isColimit K) }\n\n"}
{"name":"CategoryTheory.Adjunction.hasColimit_of_comp_equivalence","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nJ : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} J\nK : CategoryTheory.Functor J C\nE : CategoryTheory.Functor C D\ninstâœÂ¹ : E.IsEquivalence\ninstâœ : CategoryTheory.Limits.HasColimit (K.comp E)\nâŠ¢ CategoryTheory.Limits.HasColimit K","decl":"theorem hasColimit_of_comp_equivalence (E : C â¥¤ D) [E.IsEquivalence] [HasColimit (K â‹™ E)] :\n    HasColimit K :=\n  @hasColimitOfIso _ _ _ _ (K â‹™ E â‹™ E.inv) K\n    (@hasColimit_comp_equivalence _ _ _ _ _ _ (K â‹™ E) E.inv _ _)\n    ((Functor.rightUnitor _).symm â‰ªâ‰« isoWhiskerLeft K E.asEquivalence.unitIso)\n\n"}
{"name":"CategoryTheory.Adjunction.hasColimitsOfShape_of_equivalence","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nJ : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} J\nE : CategoryTheory.Functor C D\ninstâœÂ¹ : E.IsEquivalence\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape J D\nâŠ¢ CategoryTheory.Limits.HasColimitsOfShape J C","decl":"/-- Transport a `HasColimitsOfShape` instance across an equivalence. -/\ntheorem hasColimitsOfShape_of_equivalence (E : C â¥¤ D) [E.IsEquivalence] [HasColimitsOfShape J D] :\n    HasColimitsOfShape J C :=\n  âŸ¨fun F => hasColimit_of_comp_equivalence F EâŸ©\n\n"}
{"name":"CategoryTheory.Adjunction.has_colimits_of_equivalence","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : CategoryTheory.Functor C D\ninstâœÂ¹ : E.IsEquivalence\ninstâœ : CategoryTheory.Limits.HasColimitsOfSize.{v, u, vâ‚‚, uâ‚‚} D\nâŠ¢ CategoryTheory.Limits.HasColimitsOfSize.{v, u, vâ‚, uâ‚} C","decl":"/-- Transport a `HasColimitsOfSize` instance across an equivalence. -/\ntheorem has_colimits_of_equivalence (E : C â¥¤ D) [E.IsEquivalence] [HasColimitsOfSize.{v, u} D] :\n    HasColimitsOfSize.{v, u} C :=\n  âŸ¨fun _ _ => hasColimitsOfShape_of_equivalence EâŸ©\n\n"}
{"name":"CategoryTheory.Adjunction.functorialityUnit'_app_hom","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nJ : Type u\ninstâœ : CategoryTheory.Category.{v, u} J\nK : CategoryTheory.Functor J D\nc : CategoryTheory.Limits.Cone (K.comp G)\nâŠ¢ Eq ((adj.functorialityUnit' K).app c).hom (adj.unit.app c.pt)","decl":"/-- The unit for the adjunction for `Cones.functoriality K G : Cone K â¥¤ Cone (K â‹™ G)`.\n\nAuxiliary definition for `functorialityIsRightAdjoint`.\n-/\n@[simps]\ndef functorialityUnit' :\n    ğŸ­ (Cone (K â‹™ G)) âŸ¶ functorialityLeftAdjoint adj K â‹™ Cones.functoriality _ G where\n  app c := { hom := adj.unit.app c.pt }\n\n"}
{"name":"CategoryTheory.Adjunction.functorialityCounit'_app_hom","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nJ : Type u\ninstâœ : CategoryTheory.Category.{v, u} J\nK : CategoryTheory.Functor J D\nc : CategoryTheory.Limits.Cone K\nâŠ¢ Eq ((adj.functorialityCounit' K).app c).hom (adj.counit.app c.pt)","decl":"/-- The counit for the adjunction for `Cones.functoriality K G : Cone K â¥¤ Cone (K â‹™ G)`.\n\nAuxiliary definition for `functorialityIsRightAdjoint`.\n-/\n@[simps]\ndef functorialityCounit' :\n    Cones.functoriality _ G â‹™ functorialityLeftAdjoint adj K âŸ¶ ğŸ­ (Cone K) where\n  app c := { hom := adj.counit.app c.pt }\n\n"}
{"name":"CategoryTheory.Adjunction.rightAdjoint_preservesLimits","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nâŠ¢ CategoryTheory.Limits.PreservesLimitsOfSize.{v, u, vâ‚‚, vâ‚, uâ‚‚, uâ‚} G","decl":"include adj in\n/-- A right adjoint preserves limits. -/\n@[stacks 0038]\nlemma rightAdjoint_preservesLimits : PreservesLimitsOfSize.{v, u} G where\n  preservesLimitsOfShape :=\n    { preservesLimit :=\n        { preserves := fun hc =>\n            âŸ¨IsLimit.isoUniqueConeMorphism.inv fun _ =>\n              @Equiv.unique _ _ (IsLimit.isoUniqueConeMorphism.hom hc _)\n                ((adj.functorialityAdjunction' _).homEquiv _ _).symmâŸ© } }\n\n"}
{"name":"CategoryTheory.Adjunction.rightAdjointPreservesLimits","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nâŠ¢ CategoryTheory.Limits.PreservesLimitsOfSize.{v, u, vâ‚‚, vâ‚, uâ‚‚, uâ‚} G","decl":"include adj in\n@[deprecated \"No deprecation message was provided.\" (since := \"2024-11-19\")]\nlemma rightAdjointPreservesLimits : PreservesLimitsOfSize.{v, u} G :=\n  adj.rightAdjoint_preservesLimits\n\n"}
{"name":"CategoryTheory.Adjunction.lim_preservesLimits","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nJ : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} J\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape J C\nâŠ¢ CategoryTheory.Limits.PreservesLimits CategoryTheory.Limits.lim","decl":"instance lim_preservesLimits [HasLimitsOfShape J C] :\n    PreservesLimits (lim (J := J) (C := C)) :=\n  constLimAdj.rightAdjoint_preservesLimits\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Adjunction.isEquivalencePreservesLimits","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : CategoryTheory.Functor D C\ninstâœ : E.IsEquivalence\nâŠ¢ CategoryTheory.Limits.PreservesLimitsOfSize.{v, u, vâ‚‚, vâ‚, uâ‚‚, uâ‚} E","decl":"instance (priority := 100) isEquivalencePreservesLimits\n    (E : D â¥¤ C) [E.IsEquivalence] :\n    PreservesLimitsOfSize.{v, u} E :=\n  rightAdjoint_preservesLimits E.asEquivalence.symm.toAdjunction\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Functor.reflectsLimits_of_isEquivalence","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : CategoryTheory.Functor D C\ninstâœ : E.IsEquivalence\nâŠ¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{v, u, vâ‚‚, vâ‚, uâ‚‚, uâ‚} E","decl":"noncomputable instance (priority := 100)\n    _root_.CategoryTheory.Functor.reflectsLimits_of_isEquivalence\n    (E : D â¥¤ C) [E.IsEquivalence] :\n    ReflectsLimitsOfSize.{v, u} E where\n  reflectsLimitsOfShape :=\n    { reflectsLimit :=\n        { reflects := fun t =>\n            âŸ¨(isLimitOfPreserves E.inv t).mapConeEquiv E.asEquivalence.unitIso.symmâŸ© } }\n\n"}
{"name":"CategoryTheory.Adjunction.isEquivalenceReflectsLimits","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : CategoryTheory.Functor D C\ninstâœ : E.IsEquivalence\nâŠ¢ CategoryTheory.Limits.ReflectsLimitsOfSize.{v, u, vâ‚‚, vâ‚, uâ‚‚, uâ‚} E","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-11-18\")]\nlemma isEquivalenceReflectsLimits (E : D â¥¤ C) [E.IsEquivalence] :\n    ReflectsLimitsOfSize.{v, u} E :=\n  Functor.reflectsLimits_of_isEquivalence E\n\n-- see Note [lower instance priority]\n"}
{"name":"CategoryTheory.Adjunction.hasLimit_comp_equivalence","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nJ : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} J\nK : CategoryTheory.Functor J D\nE : CategoryTheory.Functor D C\ninstâœÂ¹ : E.IsEquivalence\ninstâœ : CategoryTheory.Limits.HasLimit K\nâŠ¢ CategoryTheory.Limits.HasLimit (K.comp E)","decl":"theorem hasLimit_comp_equivalence (E : D â¥¤ C) [E.IsEquivalence] [HasLimit K] : HasLimit (K â‹™ E) :=\n  HasLimit.mk\n    { cone := E.mapCone (limit.cone K)\n      isLimit := isLimitOfPreserves _ (limit.isLimit K) }\n\n"}
{"name":"CategoryTheory.Adjunction.hasLimit_of_comp_equivalence","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nJ : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} J\nK : CategoryTheory.Functor J D\nE : CategoryTheory.Functor D C\ninstâœÂ¹ : E.IsEquivalence\ninstâœ : CategoryTheory.Limits.HasLimit (K.comp E)\nâŠ¢ CategoryTheory.Limits.HasLimit K","decl":"theorem hasLimit_of_comp_equivalence (E : D â¥¤ C) [E.IsEquivalence] [HasLimit (K â‹™ E)] :\n    HasLimit K :=\n  @hasLimitOfIso _ _ _ _ (K â‹™ E â‹™ E.inv) K\n    (@hasLimit_comp_equivalence _ _ _ _ _ _ (K â‹™ E) E.inv _ _)\n    (isoWhiskerLeft K E.asEquivalence.unitIso.symm â‰ªâ‰« Functor.rightUnitor _)\n\n"}
{"name":"CategoryTheory.Adjunction.hasLimitsOfShape_of_equivalence","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nJ : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} J\nE : CategoryTheory.Functor D C\ninstâœÂ¹ : E.IsEquivalence\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape J C\nâŠ¢ CategoryTheory.Limits.HasLimitsOfShape J D","decl":"/-- Transport a `HasLimitsOfShape` instance across an equivalence. -/\ntheorem hasLimitsOfShape_of_equivalence (E : D â¥¤ C) [E.IsEquivalence] [HasLimitsOfShape J C] :\n    HasLimitsOfShape J D :=\n  âŸ¨fun F => hasLimit_of_comp_equivalence F EâŸ©\n\n"}
{"name":"CategoryTheory.Adjunction.has_limits_of_equivalence","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : CategoryTheory.Functor D C\ninstâœÂ¹ : E.IsEquivalence\ninstâœ : CategoryTheory.Limits.HasLimitsOfSize.{v, u, vâ‚, uâ‚} C\nâŠ¢ CategoryTheory.Limits.HasLimitsOfSize.{v, u, vâ‚‚, uâ‚‚} D","decl":"/-- Transport a `HasLimitsOfSize` instance across an equivalence. -/\ntheorem has_limits_of_equivalence (E : D â¥¤ C) [E.IsEquivalence] [HasLimitsOfSize.{v, u} C] :\n    HasLimitsOfSize.{v, u} D :=\n  âŸ¨fun _ _ => hasLimitsOfShape_of_equivalence EâŸ©\n\n"}
{"name":"CategoryTheory.Functor.instPreservesColimitsOfShapeOfIsLeftAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"J : Type u_1\nC : Type u_2\nD : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} J\ninstâœÂ² : CategoryTheory.Category.{u_4, u_2} C\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} D\nF : CategoryTheory.Functor C D\ninstâœ : F.IsLeftAdjoint\nâŠ¢ CategoryTheory.Limits.PreservesColimitsOfShape J F","decl":"noncomputable instance [IsLeftAdjoint F] : PreservesColimitsOfShape J F :=\n  (Adjunction.ofIsLeftAdjoint F).leftAdjoint_preservesColimits.preservesColimitsOfShape\n\n"}
{"name":"CategoryTheory.Functor.instPreservesColimitsOfSizeOfIsLeftAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u_2\nD : Type u_3\ninstâœÂ² : CategoryTheory.Category.{u_4, u_2} C\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_3} D\nF : CategoryTheory.Functor C D\ninstâœ : F.IsLeftAdjoint\nâŠ¢ CategoryTheory.Limits.PreservesColimitsOfSize.{v, u, u_4, u_5, u_2, u_3} F","decl":"noncomputable instance [IsLeftAdjoint F] : PreservesColimitsOfSize.{v, u} F where\n\n"}
{"name":"CategoryTheory.Functor.instPreservesLimitsOfShapeOfIsRightAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"J : Type u_1\nC : Type u_2\nD : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} J\ninstâœÂ² : CategoryTheory.Category.{u_5, u_2} C\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_3} D\nF : CategoryTheory.Functor C D\ninstâœ : F.IsRightAdjoint\nâŠ¢ CategoryTheory.Limits.PreservesLimitsOfShape J F","decl":"noncomputable instance [IsRightAdjoint F] : PreservesLimitsOfShape J F :=\n  (Adjunction.ofIsRightAdjoint F).rightAdjoint_preservesLimits.preservesLimitsOfShape\n\n"}
{"name":"CategoryTheory.Functor.instPreservesLimitsOfSizeOfIsRightAdjoint","module":"Mathlib.CategoryTheory.Adjunction.Limits","initialProofState":"C : Type u_2\nD : Type u_3\ninstâœÂ² : CategoryTheory.Category.{u_5, u_2} C\ninstâœÂ¹ : CategoryTheory.Category.{u_4, u_3} D\nF : CategoryTheory.Functor C D\ninstâœ : F.IsRightAdjoint\nâŠ¢ CategoryTheory.Limits.PreservesLimitsOfSize.{v, u, u_5, u_4, u_2, u_3} F","decl":"noncomputable instance [IsRightAdjoint F] : PreservesLimitsOfSize.{v, u} F where\n\n"}
