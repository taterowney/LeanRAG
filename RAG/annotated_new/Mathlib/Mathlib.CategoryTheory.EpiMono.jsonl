{"name":"CategoryTheory.unop_mono_of_epi","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA B : Opposite C\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Epi f\n‚ä¢ CategoryTheory.Mono f.unop","decl":"instance unop_mono_of_epi {A B : C·µí·µñ} (f : A ‚ü∂ B) [Epi f] : Mono f.unop :=\n  ‚ü®fun _ _ eq => Quiver.Hom.op_inj ((cancel_epi f).1 (Quiver.Hom.unop_inj eq))‚ü©\n\n"}
{"name":"CategoryTheory.unop_epi_of_mono","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA B : Opposite C\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ CategoryTheory.Epi f.unop","decl":"instance unop_epi_of_mono {A B : C·µí·µñ} (f : A ‚ü∂ B) [Mono f] : Epi f.unop :=\n  ‚ü®fun _ _ eq => Quiver.Hom.op_inj ((cancel_mono f).1 (Quiver.Hom.unop_inj eq))‚ü©\n\n"}
{"name":"CategoryTheory.op_mono_of_epi","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA B : C\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Epi f\n‚ä¢ CategoryTheory.Mono f.op","decl":"instance op_mono_of_epi {A B : C} (f : A ‚ü∂ B) [Epi f] : Mono f.op :=\n  ‚ü®fun _ _ eq => Quiver.Hom.unop_inj ((cancel_epi f).1 (Quiver.Hom.op_inj eq))‚ü©\n\n"}
{"name":"CategoryTheory.op_epi_of_mono","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA B : C\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ CategoryTheory.Epi f.op","decl":"instance op_epi_of_mono {A B : C} (f : A ‚ü∂ B) [Mono f] : Epi f.op :=\n  ‚ü®fun _ _ eq => Quiver.Hom.unop_inj ((cancel_mono f).1 (Quiver.Hom.op_inj eq))‚ü©\n\n"}
{"name":"CategoryTheory.SplitMono.ext_iff","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nx y : CategoryTheory.SplitMono f\n‚ä¢ Iff (Eq x y) (Eq x.retraction y.retraction)","decl":"/-- A split monomorphism is a morphism `f : X ‚ü∂ Y` with a given retraction `retraction f : Y ‚ü∂ X`\nsuch that `f ‚â´ retraction f = ùüô X`.\n\nEvery split monomorphism is a monomorphism.\n-/\n@[ext, aesop apply safe (rule_sets := [CategoryTheory])]\nstructure SplitMono {X Y : C} (f : X ‚ü∂ Y) where\n  /-- The map splitting `f` -/\n  retraction : Y ‚ü∂ X\n  /-- `f` composed with `retraction` is the identity -/\n  id : f ‚â´ retraction = ùüô X := by aesop_cat\n\n"}
{"name":"CategoryTheory.SplitMono.ext","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nx y : CategoryTheory.SplitMono f\nretraction : Eq x.retraction y.retraction\n‚ä¢ Eq x y","decl":"/-- A split monomorphism is a morphism `f : X ‚ü∂ Y` with a given retraction `retraction f : Y ‚ü∂ X`\nsuch that `f ‚â´ retraction f = ùüô X`.\n\nEvery split monomorphism is a monomorphism.\n-/\n@[ext, aesop apply safe (rule_sets := [CategoryTheory])]\nstructure SplitMono {X Y : C} (f : X ‚ü∂ Y) where\n  /-- The map splitting `f` -/\n  retraction : Y ‚ü∂ X\n  /-- `f` composed with `retraction` is the identity -/\n  id : f ‚â´ retraction = ùüô X := by aesop_cat\n\n"}
{"name":"CategoryTheory.SplitMono.mk.injEq","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nretraction‚úù : Quiver.Hom Y X\nid‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp f retraction‚úù) (CategoryTheory.CategoryStruct.id X)) _auto‚úù\nretraction : Quiver.Hom Y X\nid : autoParam (Eq (CategoryTheory.CategoryStruct.comp f retraction) (CategoryTheory.CategoryStruct.id X)) _auto‚úù\n‚ä¢ Eq (Eq { retraction := retraction‚úù, id := id‚úù } { retraction := retraction, id := id }) (Eq retraction‚úù retraction)","decl":"/-- A split monomorphism is a morphism `f : X ‚ü∂ Y` with a given retraction `retraction f : Y ‚ü∂ X`\nsuch that `f ‚â´ retraction f = ùüô X`.\n\nEvery split monomorphism is a monomorphism.\n-/\n@[ext, aesop apply safe (rule_sets := [CategoryTheory])]\nstructure SplitMono {X Y : C} (f : X ‚ü∂ Y) where\n  /-- The map splitting `f` -/\n  retraction : Y ‚ü∂ X\n  /-- `f` composed with `retraction` is the identity -/\n  id : f ‚â´ retraction = ùüô X := by aesop_cat\n\n"}
{"name":"CategoryTheory.SplitMono.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : SizeOf C\nretraction : Quiver.Hom Y X\nid : autoParam (Eq (CategoryTheory.CategoryStruct.comp f retraction) (CategoryTheory.CategoryStruct.id X)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { retraction := retraction, id := id }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf retraction)) (SizeOf.sizeOf id))","decl":"/-- A split monomorphism is a morphism `f : X ‚ü∂ Y` with a given retraction `retraction f : Y ‚ü∂ X`\nsuch that `f ‚â´ retraction f = ùüô X`.\n\nEvery split monomorphism is a monomorphism.\n-/\n@[ext, aesop apply safe (rule_sets := [CategoryTheory])]\nstructure SplitMono {X Y : C} (f : X ‚ü∂ Y) where\n  /-- The map splitting `f` -/\n  retraction : Y ‚ü∂ X\n  /-- `f` composed with `retraction` is the identity -/\n  id : f ‚â´ retraction = ùüô X := by aesop_cat\n\n"}
{"name":"CategoryTheory.SplitMono.mk.inj","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nretraction‚úù : Quiver.Hom Y X\nid‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp f retraction‚úù) (CategoryTheory.CategoryStruct.id X)) _auto‚úù\nretraction : Quiver.Hom Y X\nid : autoParam (Eq (CategoryTheory.CategoryStruct.comp f retraction) (CategoryTheory.CategoryStruct.id X)) _auto‚úù\nx‚úù : Eq { retraction := retraction‚úù, id := id‚úù } { retraction := retraction, id := id }\n‚ä¢ Eq retraction‚úù retraction","decl":"/-- A split monomorphism is a morphism `f : X ‚ü∂ Y` with a given retraction `retraction f : Y ‚ü∂ X`\nsuch that `f ‚â´ retraction f = ùüô X`.\n\nEvery split monomorphism is a monomorphism.\n-/\n@[ext, aesop apply safe (rule_sets := [CategoryTheory])]\nstructure SplitMono {X Y : C} (f : X ‚ü∂ Y) where\n  /-- The map splitting `f` -/\n  retraction : Y ‚ü∂ X\n  /-- `f` composed with `retraction` is the identity -/\n  id : f ‚â´ retraction = ùüô X := by aesop_cat\n\n"}
{"name":"CategoryTheory.SplitMono.id","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.SplitMono f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f self.retraction) (CategoryTheory.CategoryStruct.id X)","decl":"/-- A split monomorphism is a morphism `f : X ‚ü∂ Y` with a given retraction `retraction f : Y ‚ü∂ X`\nsuch that `f ‚â´ retraction f = ùüô X`.\n\nEvery split monomorphism is a monomorphism.\n-/\n@[ext, aesop apply safe (rule_sets := [CategoryTheory])]\nstructure SplitMono {X Y : C} (f : X ‚ü∂ Y) where\n  /-- The map splitting `f` -/\n  retraction : Y ‚ü∂ X\n  /-- `f` composed with `retraction` is the identity -/\n  id : f ‚â´ retraction = ùüô X := by aesop_cat\n\n"}
{"name":"CategoryTheory.SplitMono.id_assoc","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.SplitMono f\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp self.retraction h)) h","decl":"attribute [reassoc (attr := simp)] SplitMono.id\n\n"}
{"name":"CategoryTheory.IsSplitMono.exists_splitMono","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.IsSplitMono f\n‚ä¢ Nonempty (CategoryTheory.SplitMono f)","decl":"/-- `IsSplitMono f` is the assertion that `f` admits a retraction -/\nclass IsSplitMono {X Y : C} (f : X ‚ü∂ Y) : Prop where\n  /-- There is a splitting -/\n  exists_splitMono : Nonempty (SplitMono f)\n\n"}
{"name":"CategoryTheory.SplitMono.comp_retraction","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nsmf : CategoryTheory.SplitMono f\nsmg : CategoryTheory.SplitMono g\n‚ä¢ Eq (smf.comp smg).retraction (CategoryTheory.CategoryStruct.comp smg.retraction smf.retraction)","decl":"/-- A composition of `SplitMono` is a `SplitMono`. --/\n@[simps]\ndef SplitMono.comp {X Y Z : C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} (smf : SplitMono f) (smg : SplitMono g) :\n    SplitMono (f ‚â´ g) where\n  retraction := smg.retraction ‚â´ smf.retraction\n\n"}
{"name":"CategoryTheory.IsSplitMono.mk'","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nsm : CategoryTheory.SplitMono f\n‚ä¢ CategoryTheory.IsSplitMono f","decl":"/-- A constructor for `IsSplitMono f` taking a `SplitMono f` as an argument -/\ntheorem IsSplitMono.mk' {X Y : C} {f : X ‚ü∂ Y} (sm : SplitMono f) : IsSplitMono f :=\n  ‚ü®Nonempty.intro sm‚ü©\n\n"}
{"name":"CategoryTheory.SplitEpi.id","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.SplitEpi f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.section_ f) (CategoryTheory.CategoryStruct.id Y)","decl":"/-- A split epimorphism is a morphism `f : X ‚ü∂ Y` with a given section `section_ f : Y ‚ü∂ X`\nsuch that `section_ f ‚â´ f = ùüô Y`.\n(Note that `section` is a reserved keyword, so we append an underscore.)\n\nEvery split epimorphism is an epimorphism.\n-/\n@[ext, aesop apply safe (rule_sets := [CategoryTheory])]\nstructure SplitEpi {X Y : C} (f : X ‚ü∂ Y) where\n  /-- The map splitting `f` -/\n  section_ : Y ‚ü∂ X\n  /--  `section_` composed with `f` is the identity -/\n  id : section_ ‚â´ f = ùüô Y := by aesop_cat\n\n"}
{"name":"CategoryTheory.SplitEpi.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : SizeOf C\nsection_ : Quiver.Hom Y X\nid : autoParam (Eq (CategoryTheory.CategoryStruct.comp section_ f) (CategoryTheory.CategoryStruct.id Y)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { section_ := section_, id := id }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf section_)) (SizeOf.sizeOf id))","decl":"/-- A split epimorphism is a morphism `f : X ‚ü∂ Y` with a given section `section_ f : Y ‚ü∂ X`\nsuch that `section_ f ‚â´ f = ùüô Y`.\n(Note that `section` is a reserved keyword, so we append an underscore.)\n\nEvery split epimorphism is an epimorphism.\n-/\n@[ext, aesop apply safe (rule_sets := [CategoryTheory])]\nstructure SplitEpi {X Y : C} (f : X ‚ü∂ Y) where\n  /-- The map splitting `f` -/\n  section_ : Y ‚ü∂ X\n  /--  `section_` composed with `f` is the identity -/\n  id : section_ ‚â´ f = ùüô Y := by aesop_cat\n\n"}
{"name":"CategoryTheory.SplitEpi.ext","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nx y : CategoryTheory.SplitEpi f\nsection_ : Eq x.section_ y.section_\n‚ä¢ Eq x y","decl":"/-- A split epimorphism is a morphism `f : X ‚ü∂ Y` with a given section `section_ f : Y ‚ü∂ X`\nsuch that `section_ f ‚â´ f = ùüô Y`.\n(Note that `section` is a reserved keyword, so we append an underscore.)\n\nEvery split epimorphism is an epimorphism.\n-/\n@[ext, aesop apply safe (rule_sets := [CategoryTheory])]\nstructure SplitEpi {X Y : C} (f : X ‚ü∂ Y) where\n  /-- The map splitting `f` -/\n  section_ : Y ‚ü∂ X\n  /--  `section_` composed with `f` is the identity -/\n  id : section_ ‚â´ f = ùüô Y := by aesop_cat\n\n"}
{"name":"CategoryTheory.SplitEpi.mk.injEq","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nsection_‚úù : Quiver.Hom Y X\nid‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp section_‚úù f) (CategoryTheory.CategoryStruct.id Y)) _auto‚úù\nsection_ : Quiver.Hom Y X\nid : autoParam (Eq (CategoryTheory.CategoryStruct.comp section_ f) (CategoryTheory.CategoryStruct.id Y)) _auto‚úù\n‚ä¢ Eq (Eq { section_ := section_‚úù, id := id‚úù } { section_ := section_, id := id }) (Eq section_‚úù section_)","decl":"/-- A split epimorphism is a morphism `f : X ‚ü∂ Y` with a given section `section_ f : Y ‚ü∂ X`\nsuch that `section_ f ‚â´ f = ùüô Y`.\n(Note that `section` is a reserved keyword, so we append an underscore.)\n\nEvery split epimorphism is an epimorphism.\n-/\n@[ext, aesop apply safe (rule_sets := [CategoryTheory])]\nstructure SplitEpi {X Y : C} (f : X ‚ü∂ Y) where\n  /-- The map splitting `f` -/\n  section_ : Y ‚ü∂ X\n  /--  `section_` composed with `f` is the identity -/\n  id : section_ ‚â´ f = ùüô Y := by aesop_cat\n\n"}
{"name":"CategoryTheory.SplitEpi.mk.inj","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nsection_‚úù : Quiver.Hom Y X\nid‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp section_‚úù f) (CategoryTheory.CategoryStruct.id Y)) _auto‚úù\nsection_ : Quiver.Hom Y X\nid : autoParam (Eq (CategoryTheory.CategoryStruct.comp section_ f) (CategoryTheory.CategoryStruct.id Y)) _auto‚úù\nx‚úù : Eq { section_ := section_‚úù, id := id‚úù } { section_ := section_, id := id }\n‚ä¢ Eq section_‚úù section_","decl":"/-- A split epimorphism is a morphism `f : X ‚ü∂ Y` with a given section `section_ f : Y ‚ü∂ X`\nsuch that `section_ f ‚â´ f = ùüô Y`.\n(Note that `section` is a reserved keyword, so we append an underscore.)\n\nEvery split epimorphism is an epimorphism.\n-/\n@[ext, aesop apply safe (rule_sets := [CategoryTheory])]\nstructure SplitEpi {X Y : C} (f : X ‚ü∂ Y) where\n  /-- The map splitting `f` -/\n  section_ : Y ‚ü∂ X\n  /--  `section_` composed with `f` is the identity -/\n  id : section_ ‚â´ f = ùüô Y := by aesop_cat\n\n"}
{"name":"CategoryTheory.SplitEpi.ext_iff","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nx y : CategoryTheory.SplitEpi f\n‚ä¢ Iff (Eq x y) (Eq x.section_ y.section_)","decl":"/-- A split epimorphism is a morphism `f : X ‚ü∂ Y` with a given section `section_ f : Y ‚ü∂ X`\nsuch that `section_ f ‚â´ f = ùüô Y`.\n(Note that `section` is a reserved keyword, so we append an underscore.)\n\nEvery split epimorphism is an epimorphism.\n-/\n@[ext, aesop apply safe (rule_sets := [CategoryTheory])]\nstructure SplitEpi {X Y : C} (f : X ‚ü∂ Y) where\n  /-- The map splitting `f` -/\n  section_ : Y ‚ü∂ X\n  /--  `section_` composed with `f` is the identity -/\n  id : section_ ‚â´ f = ùüô Y := by aesop_cat\n\n"}
{"name":"CategoryTheory.SplitEpi.id_assoc","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.SplitEpi f\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.section_ (CategoryTheory.CategoryStruct.comp f h)) h","decl":"attribute [reassoc (attr := simp)] SplitEpi.id\n\n"}
{"name":"CategoryTheory.IsSplitEpi.exists_splitEpi","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nself : CategoryTheory.IsSplitEpi f\n‚ä¢ Nonempty (CategoryTheory.SplitEpi f)","decl":"/-- `IsSplitEpi f` is the assertion that `f` admits a section -/\nclass IsSplitEpi {X Y : C} (f : X ‚ü∂ Y) : Prop where\n  /-- There is a splitting -/\n  exists_splitEpi : Nonempty (SplitEpi f)\n\n"}
{"name":"CategoryTheory.SplitEpi.comp_section_","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nsef : CategoryTheory.SplitEpi f\nseg : CategoryTheory.SplitEpi g\n‚ä¢ Eq (sef.comp seg).section_ (CategoryTheory.CategoryStruct.comp seg.section_ sef.section_)","decl":"/-- A composition of `SplitEpi` is a split `SplitEpi`. --/\n@[simps]\ndef SplitEpi.comp {X Y Z : C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} (sef : SplitEpi f) (seg : SplitEpi g) :\n    SplitEpi (f ‚â´ g) where\n  section_ := seg.section_ ‚â´ sef.section_\n\n"}
{"name":"CategoryTheory.IsSplitEpi.mk'","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nse : CategoryTheory.SplitEpi f\n‚ä¢ CategoryTheory.IsSplitEpi f","decl":"/-- A constructor for `IsSplitEpi f` taking a `SplitEpi f` as an argument -/\ntheorem IsSplitEpi.mk' {X Y : C} {f : X ‚ü∂ Y} (se : SplitEpi f) : IsSplitEpi f :=\n  ‚ü®Nonempty.intro se‚ü©\n\n"}
{"name":"CategoryTheory.IsSplitMono.id_assoc","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nhf : CategoryTheory.IsSplitMono f\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.retraction f) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem IsSplitMono.id {X Y : C} (f : X ‚ü∂ Y) [hf : IsSplitMono f] : f ‚â´ retraction f = ùüô X :=\n  hf.exists_splitMono.some.id\n\n"}
{"name":"CategoryTheory.IsSplitMono.id","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nhf : CategoryTheory.IsSplitMono f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.retraction f)) (CategoryTheory.CategoryStruct.id X)","decl":"@[reassoc (attr := simp)]\ntheorem IsSplitMono.id {X Y : C} (f : X ‚ü∂ Y) [hf : IsSplitMono f] : f ‚â´ retraction f = ùüô X :=\n  hf.exists_splitMono.some.id\n\n"}
{"name":"CategoryTheory.retraction_isSplitEpi","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsSplitMono f\n‚ä¢ CategoryTheory.IsSplitEpi (CategoryTheory.retraction f)","decl":"/-- The retraction of a split monomorphism is itself a split epimorphism. -/\ninstance retraction_isSplitEpi {X Y : C} (f : X ‚ü∂ Y) [IsSplitMono f] :\n    IsSplitEpi (retraction f) :=\n  IsSplitEpi.mk' (SplitMono.splitEpi _)\n\n"}
{"name":"CategoryTheory.isIso_of_epi_of_isSplitMono","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.IsSplitMono f\ninst‚úù : CategoryTheory.Epi f\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- A split mono which is epi is an iso. -/\ntheorem isIso_of_epi_of_isSplitMono {X Y : C} (f : X ‚ü∂ Y) [IsSplitMono f] [Epi f] : IsIso f :=\n  ‚ü®‚ü®retraction f, ‚ü®by simp, by simp [‚Üê cancel_epi f]‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.IsSplitEpi.id_assoc","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nhf : CategoryTheory.IsSplitEpi f\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.section_ f) (CategoryTheory.CategoryStruct.comp f h)) h","decl":"@[reassoc (attr := simp)]\ntheorem IsSplitEpi.id {X Y : C} (f : X ‚ü∂ Y) [hf : IsSplitEpi f] : section_ f ‚â´ f = ùüô Y :=\n  hf.exists_splitEpi.some.id\n\n"}
{"name":"CategoryTheory.IsSplitEpi.id","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nhf : CategoryTheory.IsSplitEpi f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.section_ f) f) (CategoryTheory.CategoryStruct.id Y)","decl":"@[reassoc (attr := simp)]\ntheorem IsSplitEpi.id {X Y : C} (f : X ‚ü∂ Y) [hf : IsSplitEpi f] : section_ f ‚â´ f = ùüô Y :=\n  hf.exists_splitEpi.some.id\n\n"}
{"name":"CategoryTheory.section_isSplitMono","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsSplitEpi f\n‚ä¢ CategoryTheory.IsSplitMono (CategoryTheory.section_ f)","decl":"/-- The section of a split epimorphism is itself a split monomorphism. -/\ninstance section_isSplitMono {X Y : C} (f : X ‚ü∂ Y) [IsSplitEpi f] : IsSplitMono (section_ f) :=\n  IsSplitMono.mk' (SplitEpi.splitMono _)\n\n"}
{"name":"CategoryTheory.isIso_of_mono_of_isSplitEpi","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.Mono f\ninst‚úù : CategoryTheory.IsSplitEpi f\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- A split epi which is mono is an iso. -/\ntheorem isIso_of_mono_of_isSplitEpi {X Y : C} (f : X ‚ü∂ Y) [Mono f] [IsSplitEpi f] : IsIso f :=\n  ‚ü®‚ü®section_ f, ‚ü®by simp [‚Üê cancel_mono f], by simp‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.IsSplitMono.of_iso","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ CategoryTheory.IsSplitMono f","decl":"/-- Every iso is a split mono. -/\ninstance (priority := 100) IsSplitMono.of_iso {X Y : C} (f : X ‚ü∂ Y) [IsIso f] : IsSplitMono f :=\n  IsSplitMono.mk' { retraction := inv f }\n\n"}
{"name":"CategoryTheory.IsSplitEpi.of_iso","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ CategoryTheory.IsSplitEpi f","decl":"/-- Every iso is a split epi. -/\ninstance (priority := 100) IsSplitEpi.of_iso {X Y : C} (f : X ‚ü∂ Y) [IsIso f] : IsSplitEpi f :=\n  IsSplitEpi.mk' { section_ := inv f }\n\n"}
{"name":"CategoryTheory.SplitMono.mono","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nsm : CategoryTheory.SplitMono f\n‚ä¢ CategoryTheory.Mono f","decl":"theorem SplitMono.mono {X Y : C} {f : X ‚ü∂ Y} (sm : SplitMono f) : Mono f :=\n  { right_cancellation := fun g h w => by replace w := w =‚â´ sm.retraction; simpa using w }\n\n"}
{"name":"CategoryTheory.IsSplitMono.mono","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nhf : CategoryTheory.IsSplitMono f\n‚ä¢ CategoryTheory.Mono f","decl":"/-- Every split mono is a mono. -/\ninstance (priority := 100) IsSplitMono.mono {X Y : C} (f : X ‚ü∂ Y) [hf : IsSplitMono f] : Mono f :=\n  hf.exists_splitMono.some.mono\n\n"}
{"name":"CategoryTheory.SplitEpi.epi","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nse : CategoryTheory.SplitEpi f\n‚ä¢ CategoryTheory.Epi f","decl":"theorem SplitEpi.epi {X Y : C} {f : X ‚ü∂ Y} (se : SplitEpi f) : Epi f :=\n  { left_cancellation := fun g h w => by replace w := se.section_ ‚â´= w; simpa using w }\n\n"}
{"name":"CategoryTheory.IsSplitEpi.epi","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nhf : CategoryTheory.IsSplitEpi f\n‚ä¢ CategoryTheory.Epi f","decl":"/-- Every split epi is an epi. -/\ninstance (priority := 100) IsSplitEpi.epi {X Y : C} (f : X ‚ü∂ Y) [hf : IsSplitEpi f] : Epi f :=\n  hf.exists_splitEpi.some.epi\n\n"}
{"name":"CategoryTheory.instIsSplitMonoComp","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nhf : CategoryTheory.IsSplitMono f\nhg : CategoryTheory.IsSplitMono g\n‚ä¢ CategoryTheory.IsSplitMono (CategoryTheory.CategoryStruct.comp f g)","decl":"instance {X Y Z : C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} [hf : IsSplitMono f] [hg : IsSplitMono g] :\n    IsSplitMono (f ‚â´ g) := IsSplitMono.mk' <| hf.exists_splitMono.some.comp hg.exists_splitMono.some\n\n"}
{"name":"CategoryTheory.instIsSplitEpiComp","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nhf : CategoryTheory.IsSplitEpi f\nhg : CategoryTheory.IsSplitEpi g\n‚ä¢ CategoryTheory.IsSplitEpi (CategoryTheory.CategoryStruct.comp f g)","decl":"instance {X Y Z : C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} [hf : IsSplitEpi f] [hg : IsSplitEpi g] :\n    IsSplitEpi (f ‚â´ g) := IsSplitEpi.mk' <| hf.exists_splitEpi.some.comp hg.exists_splitEpi.some\n\n"}
{"name":"CategoryTheory.IsIso.of_mono_retraction'","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nhf : CategoryTheory.SplitMono f\ninst‚úù : CategoryTheory.Mono hf.retraction\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- Every split mono whose retraction is mono is an iso. -/\ntheorem IsIso.of_mono_retraction' {X Y : C} {f : X ‚ü∂ Y} (hf : SplitMono f) [Mono <| hf.retraction] :\n    IsIso f :=\n  ‚ü®‚ü®hf.retraction, ‚ü®by simp, (cancel_mono_id <| hf.retraction).mp (by simp)‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.IsIso.of_mono_retraction","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nhf : CategoryTheory.IsSplitMono f\nhf' : CategoryTheory.Mono (CategoryTheory.retraction f)\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- Every split mono whose retraction is mono is an iso. -/\ntheorem IsIso.of_mono_retraction {X Y : C} (f : X ‚ü∂ Y) [hf : IsSplitMono f]\n    [hf' : Mono <| retraction f] : IsIso f :=\n  @IsIso.of_mono_retraction' _ _ _ _ _ hf.exists_splitMono.some hf'\n\n"}
{"name":"CategoryTheory.IsIso.of_epi_section'","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nhf : CategoryTheory.SplitEpi f\ninst‚úù : CategoryTheory.Epi hf.section_\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- Every split epi whose section is epi is an iso. -/\ntheorem IsIso.of_epi_section' {X Y : C} {f : X ‚ü∂ Y} (hf : SplitEpi f) [Epi <| hf.section_] :\n    IsIso f :=\n  ‚ü®‚ü®hf.section_, ‚ü®(cancel_epi_id <| hf.section_).mp (by simp), by simp‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.IsIso.of_epi_section","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nhf : CategoryTheory.IsSplitEpi f\nhf' : CategoryTheory.Epi (CategoryTheory.section_ f)\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- Every split epi whose section is epi is an iso. -/\ntheorem IsIso.of_epi_section {X Y : C} (f : X ‚ü∂ Y) [hf : IsSplitEpi f] [hf' : Epi <| section_ f] :\n    IsIso f :=\n  @IsIso.of_epi_section' _ _ _ _ _ hf.exists_splitEpi.some hf'\n\n-- FIXME this has unnecessarily become noncomputable!\n"}
{"name":"CategoryTheory.SplitMonoCategory.isSplitMono_of_mono","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nself : CategoryTheory.SplitMonoCategory C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ CategoryTheory.IsSplitMono f","decl":"/-- A split mono category is a category in which every monomorphism is split. -/\nclass SplitMonoCategory : Prop where\n  /-- All monos are split -/\n  isSplitMono_of_mono : ‚àÄ {X Y : C} (f : X ‚ü∂ Y) [Mono f], IsSplitMono f\n\n"}
{"name":"CategoryTheory.SplitEpiCategory.isSplitEpi_of_epi","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nself : CategoryTheory.SplitEpiCategory C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Epi f\n‚ä¢ CategoryTheory.IsSplitEpi f","decl":"/-- A split epi category is a category in which every epimorphism is split. -/\nclass SplitEpiCategory : Prop where\n  /-- All epis are split -/\n  isSplitEpi_of_epi : ‚àÄ {X Y : C} (f : X ‚ü∂ Y) [Epi f], IsSplitEpi f\n\n"}
{"name":"CategoryTheory.isSplitMono_of_mono","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.SplitMonoCategory C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ CategoryTheory.IsSplitMono f","decl":"/-- In a category in which every monomorphism is split, every monomorphism splits. This is not an\n    instance because it would create an instance loop. -/\ntheorem isSplitMono_of_mono [SplitMonoCategory C] {X Y : C} (f : X ‚ü∂ Y) [Mono f] : IsSplitMono f :=\n  SplitMonoCategory.isSplitMono_of_mono _\n\n"}
{"name":"CategoryTheory.isSplitEpi_of_epi","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.SplitEpiCategory C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Epi f\n‚ä¢ CategoryTheory.IsSplitEpi f","decl":"/-- In a category in which every epimorphism is split, every epimorphism splits. This is not an\n    instance because it would create an instance loop. -/\ntheorem isSplitEpi_of_epi [SplitEpiCategory C] {X Y : C} (f : X ‚ü∂ Y) [Epi f] : IsSplitEpi f :=\n  SplitEpiCategory.isSplitEpi_of_epi _\n\n"}
{"name":"CategoryTheory.SplitMono.map_retraction","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX Y : C\nf : Quiver.Hom X Y\nsm : CategoryTheory.SplitMono f\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (sm.map F).retraction (F.map sm.retraction)","decl":"/-- Split monomorphisms are also absolute monomorphisms. -/\n@[simps]\ndef SplitMono.map {X Y : C} {f : X ‚ü∂ Y} (sm : SplitMono f) (F : C ‚•§ D) : SplitMono (F.map f) where\n  retraction := F.map sm.retraction\n  id := by rw [‚Üê Functor.map_comp, SplitMono.id, Functor.map_id]\n\n"}
{"name":"CategoryTheory.SplitEpi.map_section_","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX Y : C\nf : Quiver.Hom X Y\nse : CategoryTheory.SplitEpi f\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (se.map F).section_ (F.map se.section_)","decl":"/-- Split epimorphisms are also absolute epimorphisms. -/\n@[simps]\ndef SplitEpi.map {X Y : C} {f : X ‚ü∂ Y} (se : SplitEpi f) (F : C ‚•§ D) : SplitEpi (F.map f) where\n  section_ := F.map se.section_\n  id := by rw [‚Üê Functor.map_comp, SplitEpi.id, Functor.map_id]\n\n"}
{"name":"CategoryTheory.instIsSplitMonoMap","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX Y : C\nf : Quiver.Hom X Y\nhf : CategoryTheory.IsSplitMono f\nF : CategoryTheory.Functor C D\n‚ä¢ CategoryTheory.IsSplitMono (F.map f)","decl":"instance {X Y : C} (f : X ‚ü∂ Y) [hf : IsSplitMono f] (F : C ‚•§ D) : IsSplitMono (F.map f) :=\n  IsSplitMono.mk' (hf.exists_splitMono.some.map F)\n\n"}
{"name":"CategoryTheory.instIsSplitEpiMap","module":"Mathlib.CategoryTheory.EpiMono","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX Y : C\nf : Quiver.Hom X Y\nhf : CategoryTheory.IsSplitEpi f\nF : CategoryTheory.Functor C D\n‚ä¢ CategoryTheory.IsSplitEpi (F.map f)","decl":"instance {X Y : C} (f : X ‚ü∂ Y) [hf : IsSplitEpi f] (F : C ‚•§ D) : IsSplitEpi (F.map f) :=\n  IsSplitEpi.mk' (hf.exists_splitEpi.some.map F)\n\n"}
