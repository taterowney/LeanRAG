{"name":"Set.enumerate_eq_none_of_sel","module":"Mathlib.Data.Set.Enumerate","initialProofState":"α : Type u_1\nsel : Set α → Option α\ns : Set α\nh : Eq (sel s) Option.none\nn : Nat\n⊢ Eq (Set.enumerate sel s n) Option.none","decl":"theorem enumerate_eq_none_of_sel {s : Set α} (h : sel s = none) : ∀ {n}, enumerate sel s n = none\n  | 0 => by simp [h, enumerate]\n  | n + 1 => by simp [h, enumerate]\n\n"}
{"name":"Set.enumerate_eq_none","module":"Mathlib.Data.Set.Enumerate","initialProofState":"α : Type u_1\nsel : Set α → Option α\ns : Set α\nn₁ n₂ : Nat\na✝¹ : Eq (Set.enumerate sel s n₁) Option.none\na✝ : LE.le n₁ n₂\n⊢ Eq (Set.enumerate sel s n₂) Option.none","decl":"theorem enumerate_eq_none :\n    ∀ {s n₁ n₂}, enumerate sel s n₁ = none → n₁ ≤ n₂ → enumerate sel s n₂ = none\n  | _, 0, _ => fun h _ ↦ enumerate_eq_none_of_sel sel h\n  | s, n + 1, m => fun h hm ↦ by\n    cases hs : sel s\n    · exact enumerate_eq_none_of_sel sel hs\n    · cases m with\n      | zero => contradiction\n      | succ m' =>\n        simp? [hs, enumerate] at h ⊢ says\n          simp only [enumerate, hs, Option.bind_eq_bind, Option.some_bind] at h ⊢\n        have hm : n ≤ m' := Nat.le_of_succ_le_succ hm\n        exact enumerate_eq_none h hm\n\n"}
{"name":"Set.enumerate_mem","module":"Mathlib.Data.Set.Enumerate","initialProofState":"α : Type u_1\nsel : Set α → Option α\nh_sel : ∀ (s : Set α) (a : α), Eq (sel s) (Option.some a) → Membership.mem s a\ns : Set α\nn : Nat\na : α\na✝ : Eq (Set.enumerate sel s n) (Option.some a)\n⊢ Membership.mem s a","decl":"theorem enumerate_mem (h_sel : ∀ s a, sel s = some a → a ∈ s) :\n    ∀ {s n a}, enumerate sel s n = some a → a ∈ s\n  | s, 0, a => h_sel s a\n  | s, n + 1, a => by\n    cases h : sel s with\n    | none => simp [enumerate_eq_none_of_sel, h]\n    | some a' =>\n      simp only [enumerate, h, Nat.add_eq, add_zero]\n      exact fun h' : enumerate sel (s \\ {a'}) n = some a ↦\n        have : a ∈ s \\ {a'} := enumerate_mem h_sel h'\n        this.left\n\n"}
{"name":"Set.enumerate_inj","module":"Mathlib.Data.Set.Enumerate","initialProofState":"α : Type u_1\nsel : Set α → Option α\nn₁ n₂ : Nat\na : α\ns : Set α\nh_sel : ∀ (s : Set α) (a : α), Eq (sel s) (Option.some a) → Membership.mem s a\nh₁ : Eq (Set.enumerate sel s n₁) (Option.some a)\nh₂ : Eq (Set.enumerate sel s n₂) (Option.some a)\n⊢ Eq n₁ n₂","decl":"theorem enumerate_inj {n₁ n₂ : ℕ} {a : α} {s : Set α} (h_sel : ∀ s a, sel s = some a → a ∈ s)\n    (h₁ : enumerate sel s n₁ = some a) (h₂ : enumerate sel s n₂ = some a) : n₁ = n₂ := by\n  /- Porting note: The `rcase, on_goal, all_goals` has been used instead of\n     the not-yet-ported `wlog` -/\n  rcases le_total n₁ n₂ with (hn|hn)\n  on_goal 2 => swap_var n₁ ↔ n₂, h₁ ↔ h₂\n  all_goals\n    rcases Nat.le.dest hn with ⟨m, rfl⟩\n    clear hn\n    induction n₁ generalizing s with\n    | zero =>\n      cases m with\n      | zero => rfl\n      | succ m =>\n        have h' : enumerate sel (s \\ {a}) m = some a := by\n          simp_all only [enumerate, Nat.add_eq, zero_add]; exact h₂\n        have : a ∈ s \\ {a} := enumerate_mem sel h_sel h'\n        simp_all [Set.mem_diff_singleton]\n    | succ k ih =>\n      cases h : sel s with\n      /- Porting note: The original covered both goals with just `simp_all <;> tauto` -/\n      | none =>\n        simp_all only [add_comm, self_eq_add_left, Nat.add_succ, enumerate_eq_none_of_sel _ h,\n          reduceCtorEq]\n      | some =>\n        simp_all only [add_comm, self_eq_add_left, enumerate, Option.some.injEq,\n                       Nat.add_succ, Nat.succ.injEq]\n        exact ih h₁ h₂\n\n"}
