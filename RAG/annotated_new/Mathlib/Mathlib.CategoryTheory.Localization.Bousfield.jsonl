{"name":"CategoryTheory.Localization.LeftBousfield.W.homEquiv_apply","module":"Mathlib.CategoryTheory.Localization.Bousfield","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_3, u_1} C\nP : C → Prop\nX Y : C\nf : Quiver.Hom X Y\nhf : CategoryTheory.Localization.LeftBousfield.W P f\nZ : C\nhZ : P Z\ng : Quiver.Hom Y Z\n⊢ Eq ((hf.homEquiv Z hZ) g) (CategoryTheory.CategoryStruct.comp f g)","decl":"variable {P} in\n/-- The bijection `(Y ⟶ Z) ≃ (X ⟶ Z)` induced by `f : X ⟶ Y` when `LeftBousfield.W P f`\nand `P Z`. -/\n@[simps! apply]\nnoncomputable def W.homEquiv {X Y : C} {f : X ⟶ Y} (hf : W P f) (Z : C) (hZ : P Z) :\n    (Y ⟶ Z) ≃ (X ⟶ Z) :=\n  Equiv.ofBijective _ (hf Z hZ)\n\n"}
{"name":"CategoryTheory.Localization.LeftBousfield.W_isoClosure","module":"Mathlib.CategoryTheory.Localization.Bousfield","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_3, u_1} C\nP : C → Prop\n⊢ Eq (CategoryTheory.Localization.LeftBousfield.W (CategoryTheory.isoClosure P)) (CategoryTheory.Localization.LeftBousfield.W P)","decl":"lemma W_isoClosure : W (isoClosure P) = W P := by\n  ext X Y f\n  constructor\n  · intro hf Z hZ\n    exact hf _ (le_isoClosure _ _ hZ)\n  · rintro hf Z ⟨Z', hZ', ⟨e⟩⟩\n    constructor\n    · intro g₁ g₂ eq\n      rw [← cancel_mono e.hom]\n      apply (hf _ hZ').1\n      simp only [reassoc_of% eq]\n    · intro g\n      obtain ⟨a, h⟩ := (hf _ hZ').2 (g ≫ e.hom)\n      exact ⟨a ≫ e.inv, by simp only [reassoc_of% h, e.hom_inv_id, comp_id]⟩\n\n"}
{"name":"CategoryTheory.Localization.LeftBousfield.instIsMultiplicativeW","module":"Mathlib.CategoryTheory.Localization.Bousfield","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_3, u_1} C\nP : C → Prop\n⊢ (CategoryTheory.Localization.LeftBousfield.W P).IsMultiplicative","decl":"instance : (W P).IsMultiplicative where\n  id_mem X Z _ := by simpa [id_comp] using Function.bijective_id\n  comp_mem f g hf hg Z hZ := by\n    simpa using Function.Bijective.comp (hf Z hZ) (hg Z hZ)\n\n"}
{"name":"CategoryTheory.Localization.LeftBousfield.instHasTwoOutOfThreePropertyW","module":"Mathlib.CategoryTheory.Localization.Bousfield","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_3, u_1} C\nP : C → Prop\n⊢ (CategoryTheory.Localization.LeftBousfield.W P).HasTwoOutOfThreeProperty","decl":"instance : (W P).HasTwoOutOfThreeProperty where\n  of_postcomp f g hg hfg Z hZ := by\n    rw [← Function.Bijective.of_comp_iff _ (hg Z hZ)]\n    simpa using hfg Z hZ\n  of_precomp f g hf hfg Z hZ := by\n    rw [← Function.Bijective.of_comp_iff' (hf Z hZ)]\n    simpa using hfg Z hZ\n\n"}
{"name":"CategoryTheory.Localization.LeftBousfield.W_of_isIso","module":"Mathlib.CategoryTheory.Localization.Bousfield","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\nP : C → Prop\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\n⊢ CategoryTheory.Localization.LeftBousfield.W P f","decl":"lemma W_of_isIso {X Y : C} (f : X ⟶ Y) [IsIso f] : W P f := fun Z _ => by\n  constructor\n  · intro g₁ g₂ _\n    simpa only [← cancel_epi f]\n  · intro g\n    exact ⟨inv f ≫ g, by simp⟩\n\n"}
{"name":"CategoryTheory.Localization.LeftBousfield.W_iff_isIso","module":"Mathlib.CategoryTheory.Localization.Bousfield","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_3, u_1} C\nP : C → Prop\nX Y : C\nf : Quiver.Hom X Y\nhX : P X\nhY : P Y\n⊢ Iff (CategoryTheory.Localization.LeftBousfield.W P f) (CategoryTheory.IsIso f)","decl":"lemma W_iff_isIso {X Y : C} (f : X ⟶ Y) (hX : P X) (hY : P Y) :\n    W P f ↔ IsIso f := by\n  constructor\n  · intro hf\n    obtain ⟨g, hg⟩ := (hf _ hX).2 (𝟙 X)\n    exact ⟨g, hg, (hf _ hY).1 (by simp only [reassoc_of% hg, comp_id])⟩\n  · apply W_of_isIso\n\n"}
{"name":"CategoryTheory.Localization.LeftBousfield.W_adj_unit_app","module":"Mathlib.CategoryTheory.Localization.Bousfield","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_3, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction G F\ninst✝¹ : F.Full\ninst✝ : F.Faithful\nX : D\n⊢ CategoryTheory.Localization.LeftBousfield.W (fun x => Membership.mem (Set.range F.obj) x) (adj.unit.app X)","decl":"lemma W_adj_unit_app (X : D) : W (· ∈ Set.range F.obj) (adj.unit.app X) := by\n  rintro _ ⟨Y, rfl⟩\n  convert ((Functor.FullyFaithful.ofFullyFaithful F).homEquiv.symm.trans\n    (adj.homEquiv X Y)).bijective using 1\n  dsimp [Adjunction.homEquiv]\n  aesop\n\n"}
{"name":"CategoryTheory.Localization.LeftBousfield.W_iff_isIso_map","module":"Mathlib.CategoryTheory.Localization.Bousfield","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_3, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction G F\ninst✝¹ : F.Full\ninst✝ : F.Faithful\nX Y : D\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.Localization.LeftBousfield.W (fun x => Membership.mem (Set.range F.obj) x) f) (CategoryTheory.IsIso (G.map f))","decl":"lemma W_iff_isIso_map {X Y : D} (f : X ⟶ Y) :\n    W (· ∈ Set.range F.obj) f ↔ IsIso (G.map f) := by\n  rw [← (W (· ∈ Set.range F.obj)).postcomp_iff _ _ (W_adj_unit_app adj Y)]\n  erw [adj.unit.naturality f]\n  rw [(W (· ∈ Set.range F.obj)).precomp_iff _ _ (W_adj_unit_app adj X),\n    W_iff_isIso _ _ ⟨_, rfl⟩ ⟨_, rfl⟩]\n  constructor\n  · intro h\n    dsimp at h\n    exact isIso_of_fully_faithful F (G.map f)\n  · intro\n    rw [Functor.comp_map]\n    infer_instance\n\n"}
{"name":"CategoryTheory.Localization.LeftBousfield.W_eq_inverseImage_isomorphisms","module":"Mathlib.CategoryTheory.Localization.Bousfield","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_3, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction G F\ninst✝¹ : F.Full\ninst✝ : F.Faithful\n⊢ Eq (CategoryTheory.Localization.LeftBousfield.W fun x => Membership.mem (Set.range F.obj) x) ((CategoryTheory.MorphismProperty.isomorphisms C).inverseImage G)","decl":"lemma W_eq_inverseImage_isomorphisms :\n    W (· ∈ Set.range F.obj) = (MorphismProperty.isomorphisms _).inverseImage G := by\n  ext P₁ P₂ f\n  rw [W_iff_isIso_map adj]\n  rfl\n\n"}
{"name":"CategoryTheory.Localization.LeftBousfield.isLocalization","module":"Mathlib.CategoryTheory.Localization.Bousfield","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_3, u_2} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction G F\ninst✝¹ : F.Full\ninst✝ : F.Faithful\n⊢ G.IsLocalization (CategoryTheory.Localization.LeftBousfield.W fun x => Membership.mem (Set.range F.obj) x)","decl":"lemma isLocalization : G.IsLocalization (W (· ∈ Set.range F.obj)) := by\n  rw [W_eq_inverseImage_isomorphisms adj]\n  exact adj.isLocalization\n\n"}
