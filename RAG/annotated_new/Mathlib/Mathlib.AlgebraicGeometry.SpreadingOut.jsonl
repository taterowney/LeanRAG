{"name":"AlgebraicGeometry.Scheme.IsGermInjectiveAt.cond","module":"Mathlib.AlgebraicGeometry.SpreadingOut","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ‚Üë‚ÜëX.toPresheafedSpace\nself : X.IsGermInjectiveAt x\n‚ä¢ Exists fun U => Exists fun hx => And (AlgebraicGeometry.IsAffineOpen U) (Function.Injective ‚áë(CategoryTheory.ConcreteCategory.hom (X.presheaf.germ U x hx)))","decl":"/-- The germ map at `x` is injective if there exists some affine `U ‚àã x`\n  such that the map `Œì(X, U) ‚ü∂ X_x` is injective -/\nclass Scheme.IsGermInjectiveAt (X : Scheme.{u}) (x : X) : Prop where\n  cond : ‚àÉ (U : X.Opens) (hx : x ‚àà U), IsAffineOpen U ‚àß Function.Injective (X.presheaf.germ U x hx)\n\n"}
{"name":"AlgebraicGeometry.injective_germ_basicOpen","module":"Mathlib.AlgebraicGeometry.SpreadingOut","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\nx : ‚Üë‚ÜëX.toPresheafedSpace\nhx : Membership.mem U x\nf : ‚Üë(X.presheaf.obj { unop := U })\nhf : Membership.mem (X.basicOpen f) x\nH : Function.Injective ‚áë(CategoryTheory.ConcreteCategory.hom (X.presheaf.germ U x hx))\n‚ä¢ Function.Injective ‚áë(CategoryTheory.ConcreteCategory.hom (X.presheaf.germ (X.basicOpen f) x hf))","decl":"lemma injective_germ_basicOpen (U : X.Opens) (hU : IsAffineOpen U)\n    (x : X) (hx : x ‚àà U) (f : Œì(X, U))\n    (hf : x ‚àà X.basicOpen f)\n    (H : Function.Injective (X.presheaf.germ U x hx)) :\n    Function.Injective (X.presheaf.germ (X.basicOpen f) x hf) := by\n  rw [RingHom.injective_iff_ker_eq_bot, RingHom.ker_eq_bot_iff_eq_zero] at H ‚ä¢\n  intros t ht\n  have := hU.isLocalization_basicOpen f\n  obtain ‚ü®t, s, rfl‚ü© := IsLocalization.mk'_surjective (.powers f) t\n  rw [‚Üê RingHom.mem_ker, IsLocalization.mk'_eq_mul_mk'_one, Ideal.mul_unit_mem_iff_mem,\n    RingHom.mem_ker, RingHom.algebraMap_toAlgebra, CommRingCat.germ_res_apply] at ht\n  swap; ¬∑ exact @isUnit_of_invertible _ _ _ (@IsLocalization.invertible_mk'_one ..)\n  rw [H _ ht, IsLocalization.mk'_zero]\n\n"}
{"name":"AlgebraicGeometry.Scheme.exists_germ_injective","module":"Mathlib.AlgebraicGeometry.SpreadingOut","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ‚Üë‚ÜëX.toPresheafedSpace\ninst‚úù : X.IsGermInjectiveAt x\n‚ä¢ Exists fun U => Exists fun hx => And (AlgebraicGeometry.IsAffineOpen U) (Function.Injective ‚áë(CategoryTheory.ConcreteCategory.hom (X.presheaf.germ U x hx)))","decl":"lemma Scheme.exists_germ_injective (X : Scheme.{u}) (x : X) [X.IsGermInjectiveAt x] :\n    ‚àÉ (U : X.Opens) (hx : x ‚àà U),\n      IsAffineOpen U ‚àß Function.Injective (X.presheaf.germ U x hx) :=\n  Scheme.IsGermInjectiveAt.cond\n\n"}
{"name":"AlgebraicGeometry.Scheme.exists_le_and_germ_injective","module":"Mathlib.AlgebraicGeometry.SpreadingOut","initialProofState":"X : AlgebraicGeometry.Scheme\nx : ‚Üë‚ÜëX.toPresheafedSpace\ninst‚úù : X.IsGermInjectiveAt x\nV : X.Opens\nhxV : Membership.mem V x\n‚ä¢ Exists fun U => Exists fun hx => And (AlgebraicGeometry.IsAffineOpen U) (And (LE.le U V) (Function.Injective ‚áë(CategoryTheory.ConcreteCategory.hom (X.presheaf.germ U x hx))))","decl":"lemma Scheme.exists_le_and_germ_injective (X : Scheme.{u}) (x : X) [X.IsGermInjectiveAt x]\n    (V : X.Opens) (hxV : x ‚àà V) :\n    ‚àÉ (U : X.Opens) (hx : x ‚àà U),\n      IsAffineOpen U ‚àß U ‚â§ V ‚àß Function.Injective (X.presheaf.germ U x hx) := by\n  obtain ‚ü®U, hx, hU, H‚ü© := Scheme.IsGermInjectiveAt.cond (x := x)\n  obtain ‚ü®f, hf, hxf‚ü© := hU.exists_basicOpen_le ‚ü®x, hxV‚ü© hx\n  exact ‚ü®X.basicOpen f, hxf, hU.basicOpen f, hf, injective_germ_basicOpen U hU x hx f hxf H‚ü©\n\n"}
{"name":"AlgebraicGeometry.instIsGermInjectiveAtCoeHomTopCatCarrierCommRingCatŒ±TopologicalSpaceBaseOfIsOpenImmersion","module":"Mathlib.AlgebraicGeometry.SpreadingOut","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nx : ‚Üë‚ÜëX.toPresheafedSpace\ninst‚úù¬π : X.IsGermInjectiveAt x\ninst‚úù : AlgebraicGeometry.IsOpenImmersion f\n‚ä¢ Y.IsGermInjectiveAt (f.base x)","decl":"instance (x : X) [X.IsGermInjectiveAt x] [IsOpenImmersion f] :\n    Y.IsGermInjectiveAt (f.base x) := by\n  obtain ‚ü®U, hxU, hU, H‚ü© := X.exists_germ_injective x\n  refine ‚ü®‚ü®f ''·µÅ U, ‚ü®x, hxU, rfl‚ü©, hU.image_of_isOpenImmersion f, ?_‚ü©‚ü©\n  refine ((MorphismProperty.injective CommRingCat).cancel_right_of_respectsIso _\n    (f.stalkMap x)).mp ?_\n  refine ((MorphismProperty.injective CommRingCat).cancel_left_of_respectsIso\n    (f.appIso U).inv _).mp ?_\n  simpa\n\n"}
{"name":"AlgebraicGeometry.isGermInjectiveAt_iff_of_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.SpreadingOut","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nx : ‚Üë‚ÜëX.toPresheafedSpace\ninst‚úù : AlgebraicGeometry.IsOpenImmersion f\n‚ä¢ Iff (Y.IsGermInjectiveAt (f.base x)) (X.IsGermInjectiveAt x)","decl":"variable {f} in\nlemma isGermInjectiveAt_iff_of_isOpenImmersion {x : X} [IsOpenImmersion f] :\n    Y.IsGermInjectiveAt (f.base x) ‚Üî X.IsGermInjectiveAt x := by\n  refine ‚ü®fun H ‚Ü¶ ?_, fun _ ‚Ü¶ inferInstance‚ü©\n  obtain ‚ü®U, hxU, hU, hU', H‚ü© :=\n    Y.exists_le_and_germ_injective (f.base x) (V := f.opensRange) ‚ü®x, rfl‚ü©\n  obtain ‚ü®V, hV‚ü© := (IsOpenImmersion.affineOpensEquiv f).surjective ‚ü®‚ü®U, hU‚ü©, hU'‚ü©\n  obtain rfl : f ''·µÅ V = U := Subtype.eq_iff.mp (Subtype.eq_iff.mp hV)\n  obtain ‚ü®y, hy, e : f.base y = f.base x‚ü© := hxU\n  obtain rfl := f.isOpenEmbedding.injective e\n  refine ‚ü®V, hy, V.2, ?_‚ü©\n  replace H := ((MorphismProperty.injective CommRingCat).cancel_right_of_respectsIso _\n    (f.stalkMap y)).mpr H\n  replace H := ((MorphismProperty.injective CommRingCat).cancel_left_of_respectsIso\n    (f.appIso V).inv _).mpr H\n  simpa using H\n\n"}
{"name":"AlgebraicGeometry.Scheme.IsGermInjective.of_openCover","module":"Mathlib.AlgebraicGeometry.SpreadingOut","initialProofState":"X : AlgebraicGeometry.Scheme\nùí∞ : X.OpenCover\ninst‚úù : ‚àÄ (i : ùí∞.J), (ùí∞.obj i).IsGermInjective\n‚ä¢ X.IsGermInjective","decl":"lemma Scheme.IsGermInjective.of_openCover\n    {X : Scheme.{u}} (ùí∞ : X.OpenCover) [‚àÄ i, (ùí∞.obj i).IsGermInjective] : X.IsGermInjective := by\n  intro x\n  rw [‚Üê (ùí∞.covers x).choose_spec]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.IsGermInjective.Spec","module":"Mathlib.AlgebraicGeometry.SpreadingOut","initialProofState":"R : CommRingCat\nH : ‚àÄ (I : Ideal ‚ÜëR), I.IsPrime ‚Üí Exists fun f => And (Not (Membership.mem I f)) (‚àÄ (x y : ‚ÜëR), Eq (HMul.hMul y x) 0 ‚Üí Not (Membership.mem I y) ‚Üí Exists fun n => Eq (HMul.hMul (HPow.hPow f n) x) 0)\n‚ä¢ (AlgebraicGeometry.Spec R).IsGermInjective","decl":"protected\nlemma Scheme.IsGermInjective.Spec\n    (H : ‚àÄ I : Ideal R, I.IsPrime ‚Üí\n      ‚àÉ f : R, f ‚àâ I ‚àß ‚àÄ (x y : R), y * x = 0 ‚Üí y ‚àâ I ‚Üí ‚àÉ n, f ^ n * x = 0) :\n    (Spec R).IsGermInjective := by\n  refine fun p ‚Ü¶ ‚ü®?_‚ü©\n  obtain ‚ü®f, hf, H‚ü© := H p.asIdeal p.2\n  refine ‚ü®PrimeSpectrum.basicOpen f, hf, ?_, ?_‚ü©\n  ¬∑ rw [‚Üê basicOpen_eq_of_affine]\n    exact (isAffineOpen_top (Spec R)).basicOpen _\n  rw [RingHom.injective_iff_ker_eq_bot, RingHom.ker_eq_bot_iff_eq_zero]\n  intro x hx\n  obtain ‚ü®x, s, rfl‚ü© := IsLocalization.mk'_surjective\n    (S := ((Spec.structureSheaf R).val.obj (.op <| PrimeSpectrum.basicOpen f))) (.powers f) x\n  rw [‚Üê RingHom.mem_ker, IsLocalization.mk'_eq_mul_mk'_one, Ideal.mul_unit_mem_iff_mem,\n    RingHom.mem_ker, RingHom.algebraMap_toAlgebra] at hx\n  swap; ¬∑ exact @isUnit_of_invertible _ _ _ (@IsLocalization.invertible_mk'_one ..)\n  erw [StructureSheaf.germ_toOpen] at hx\n  obtain ‚ü®‚ü®y, hy‚ü©, hy'‚ü© := (IsLocalization.map_eq_zero_iff p.asIdeal.primeCompl\n    ((Spec.structureSheaf R).presheaf.stalk p) _).mp hx\n  obtain ‚ü®n, hn‚ü© := H x y hy' hy\n  refine (@IsLocalization.mk'_eq_zero_iff ..).mpr ?_\n  exact ‚ü®‚ü®_, n, rfl‚ü©, hn‚ü©\n\n"}
{"name":"AlgebraicGeometry.instIsGermInjectiveOfIsIntegral","module":"Mathlib.AlgebraicGeometry.SpreadingOut","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsIntegral X\n‚ä¢ X.IsGermInjective","decl":"instance (priority := 100) [IsIntegral X] : X.IsGermInjective := by\n  refine fun x ‚Ü¶ ‚ü®‚ü®(X.affineCover.map x).opensRange, X.affineCover.covers x,\n    (isAffineOpen_opensRange (X.affineCover.map x)), ?_‚ü©‚ü©\n  have : Nonempty (X.affineCover.map x).opensRange := ‚ü®‚ü®_, X.affineCover.covers x‚ü©‚ü©\n  have := (isAffineOpen_opensRange (X.affineCover.map x)).isLocalization_stalk\n    ‚ü®_, X.affineCover.covers x‚ü©\n  exact @IsLocalization.injective _ _ _ _ _ (show _ from _) this\n    (Ideal.primeCompl_le_nonZeroDivisors _)\n\n"}
{"name":"AlgebraicGeometry.instIsGermInjectiveOfIsLocallyNoetherian","module":"Mathlib.AlgebraicGeometry.SpreadingOut","initialProofState":"X : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsLocallyNoetherian X\n‚ä¢ X.IsGermInjective","decl":"instance (priority := 100) [IsLocallyNoetherian X] : X.IsGermInjective := by\n  suffices ‚àÄ (R : CommRingCat.{u}) (_ : IsNoetherianRing R), (Spec R).IsGermInjective by\n    refine @Scheme.IsGermInjective.of_openCover _ (X.affineOpenCover.openCover) (fun i ‚Ü¶ this _ ?_)\n    have := isLocallyNoetherian_of_isOpenImmersion (X.affineOpenCover.map i)\n    infer_instance\n  refine fun R hR ‚Ü¶ Scheme.IsGermInjective.Spec fun I hI ‚Ü¶ ?_\n  let J := RingHom.ker <| algebraMap R (Localization.AtPrime I)\n  have hJ (x) : x ‚àà J ‚Üî ‚àÉ y : I.primeCompl, y * x = 0 :=\n    IsLocalization.map_eq_zero_iff I.primeCompl _ x\n  choose f hf using fun x ‚Ü¶ (hJ x).mp\n  obtain ‚ü®s, hs‚ü© := (isNoetherianRing_iff_ideal_fg R).mp ‚Äπ_‚Ä∫ J\n  have hs' : (s : Set R) ‚äÜ J := hs ‚ñ∏ Ideal.subset_span\n  refine ‚ü®_, (s.attach.prod fun x ‚Ü¶ f x (hs' x.2)).2, fun x y e hy ‚Ü¶ ‚ü®1, ?_‚ü©‚ü©\n  rw [pow_one, mul_comm, ‚Üê smul_eq_mul, ‚Üê Submodule.mem_annihilator_span_singleton]\n  refine SetLike.le_def.mp ?_ ((hJ x).mpr ‚ü®‚ü®y, hy‚ü©, e‚ü©)\n  rw [‚Üê hs, Ideal.span_le]\n  intro i hi\n  rw [SetLike.mem_coe, Submodule.mem_annihilator_span_singleton, smul_eq_mul,\n    mul_comm, ‚Üê smul_eq_mul, ‚Üê Submodule.mem_annihilator_span_singleton, Submonoid.coe_finset_prod]\n  refine Ideal.mem_of_dvd _ (Finset.dvd_prod_of_mem _ (s.mem_attach ‚ü®i, hi‚ü©)) ?_\n  rw [Submodule.mem_annihilator_span_singleton, smul_eq_mul]\n  exact hf i _\n\n"}
{"name":"AlgebraicGeometry.spread_out_unique_of_isGermInjective","module":"Mathlib.AlgebraicGeometry.SpreadingOut","initialProofState":"X Y : AlgebraicGeometry.Scheme\nx : ‚Üë‚ÜëX.toPresheafedSpace\ninst‚úù : X.IsGermInjectiveAt x\nf g : Quiver.Hom X Y\ne : Eq (f.base x) (g.base x)\nH : Eq (AlgebraicGeometry.Scheme.Hom.stalkMap f x) (CategoryTheory.CategoryStruct.comp (Y.presheaf.stalkSpecializes ‚ãØ) (AlgebraicGeometry.Scheme.Hom.stalkMap g x))\n‚ä¢ Exists fun U => And (Membership.mem U x) (Eq (CategoryTheory.CategoryStruct.comp U.Œπ f) (CategoryTheory.CategoryStruct.comp U.Œπ g))","decl":"/--\nLet `x : X` and `f g : X ‚ü∂ Y` be two morphisms such that `f x = g x`.\nIf `f` and `g` agree on the stalk of `x`, then they agree on an open neighborhood of `x`,\nprovided `X` is \"germ-injective\" at `x` (e.g. when it's integral or locally noetherian).\n\nTODO: The condition on `X` is unnecessary when `Y` is locally of finite type.\n-/\n@[stacks 0BX6]\nlemma spread_out_unique_of_isGermInjective {x : X} [X.IsGermInjectiveAt x]\n    (f g : X ‚ü∂ Y) (e : f.base x = g.base x)\n    (H : f.stalkMap x =\n      Y.presheaf.stalkSpecializes (Inseparable.of_eq e.symm).specializes ‚â´ g.stalkMap x) :\n    ‚àÉ (U : X.Opens), x ‚àà U ‚àß U.Œπ ‚â´ f = U.Œπ ‚â´ g := by\n  obtain ‚ü®_, ‚ü®V : Y.Opens, hV, rfl‚ü©, hxV, -‚ü© :=\n    (isBasis_affine_open Y).exists_subset_of_mem_open (Set.mem_univ (f.base x)) isOpen_univ\n  have hxV' : g.base x ‚àà V := e ‚ñ∏ hxV\n  obtain ‚ü®U, hxU, _, hUV, HU‚ü© := X.exists_le_and_germ_injective x (f ‚Åª¬π·µÅ V ‚äì g ‚Åª¬π·µÅ V) ‚ü®hxV, hxV'‚ü©\n  refine ‚ü®U, hxU, ?_‚ü©\n  rw [‚Üê Scheme.Hom.resLE_comp_Œπ _ (hUV.trans inf_le_left),\n    ‚Üê Scheme.Hom.resLE_comp_Œπ _ (hUV.trans inf_le_right)]\n  congr 1\n  have : IsAffine V := hV\n  suffices ‚àÄ (U‚ÇÄ V‚ÇÄ) (eU : U = U‚ÇÄ) (eV : V = V‚ÇÄ),\n      f.appLE V‚ÇÄ U‚ÇÄ (eU ‚ñ∏ eV ‚ñ∏ hUV.trans inf_le_left) =\n        g.appLE V‚ÇÄ U‚ÇÄ (eU ‚ñ∏ eV ‚ñ∏ hUV.trans inf_le_right) by\n    rw [‚Üê cancel_mono V.toScheme.isoSpec.hom]\n    simp only [Scheme.isoSpec, asIso_hom, Scheme.toSpecŒì_naturality,\n      Scheme.Hom.app_eq_appLE, Scheme.Hom.resLE_appLE]\n    congr 2\n    apply this <;> simp\n  rintro U V rfl rfl\n  have := ConcreteCategory.mono_of_injective _ HU\n  rw [‚Üê cancel_mono (X.presheaf.germ U x hxU)]\n  simp only [Scheme.Hom.appLE, Category.assoc, X.presheaf.germ_res', ‚Üê Scheme.stalkMap_germ, H]\n  simp only [TopCat.Presheaf.germ_stalkSpecializes_assoc, Scheme.stalkMap_germ]\n\n"}
{"name":"AlgebraicGeometry.spread_out_unique_of_isGermInjective'","module":"Mathlib.AlgebraicGeometry.SpreadingOut","initialProofState":"X Y : AlgebraicGeometry.Scheme\nx : ‚Üë‚ÜëX.toPresheafedSpace\ninst‚úù : X.IsGermInjectiveAt x\nf g : Quiver.Hom X Y\ne : Eq (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk x) f) (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk x) g)\n‚ä¢ Exists fun U => And (Membership.mem U x) (Eq (CategoryTheory.CategoryStruct.comp U.Œπ f) (CategoryTheory.CategoryStruct.comp U.Œπ g))","decl":"/--\nA variant of `spread_out_unique_of_isGermInjective`\nwhose condition is an equality of scheme morphisms instead of ring homomorphisms.\n-/\nlemma spread_out_unique_of_isGermInjective' {x : X} [X.IsGermInjectiveAt x]\n    (f g : X ‚ü∂ Y)\n    (e : X.fromSpecStalk x ‚â´ f = X.fromSpecStalk x ‚â´ g) :\n    ‚àÉ (U : X.Opens), x ‚àà U ‚àß U.Œπ ‚â´ f = U.Œπ ‚â´ g := by\n  fapply spread_out_unique_of_isGermInjective\n  ¬∑ simpa using congr(($e).base (IsLocalRing.closedPoint _))\n  ¬∑ apply Spec.map_injective\n    rw [‚Üê cancel_mono (Y.fromSpecStalk _)]\n    simpa [Scheme.Spec_map_stalkSpecializes_fromSpecStalk]\n\n"}
{"name":"AlgebraicGeometry.exists_lift_of_germInjective_aux","module":"Mathlib.AlgebraicGeometry.SpreadingOut","initialProofState":"X : AlgebraicGeometry.Scheme\nR A : CommRingCat\nU : X.Opens\nx : ‚Üë‚ÜëX.toPresheafedSpace\nhxU : Membership.mem U x\nœÜ : Quiver.Hom A (X.presheaf.stalk x)\nœÜRA : Quiver.Hom R A\nœÜRX : Quiver.Hom R (X.presheaf.obj { unop := U })\nhœÜRA : (CommRingCat.Hom.hom œÜRA).FiniteType\ne : Eq (CategoryTheory.CategoryStruct.comp œÜRA œÜ) (CategoryTheory.CategoryStruct.comp œÜRX (X.presheaf.germ U x hxU))\n‚ä¢ Exists fun V => Exists fun hxV => And (LE.le V U) (LE.le (CommRingCat.Hom.hom œÜ).range (CommRingCat.Hom.hom (X.presheaf.germ V x hxV)).range)","decl":"lemma exists_lift_of_germInjective_aux {U : X.Opens} {x : X} (hxU)\n    (œÜ : A ‚ü∂ X.presheaf.stalk x) (œÜRA : R ‚ü∂ A) (œÜRX : R ‚ü∂ Œì(X, U))\n    (hœÜRA : RingHom.FiniteType œÜRA.hom)\n    (e : œÜRA ‚â´ œÜ = œÜRX ‚â´ X.presheaf.germ U x hxU) :\n    ‚àÉ (V : X.Opens) (hxV : x ‚àà V),\n      V ‚â§ U ‚àß RingHom.range œÜ.hom ‚â§ RingHom.range (X.presheaf.germ V x hxV).hom := by\n  letI := œÜRA.hom.toAlgebra\n  obtain ‚ü®s, hs‚ü© := hœÜRA\n  choose W hxW f hf using fun t ‚Ü¶ X.presheaf.germ_exist x (œÜ t)\n  have H : x ‚àà s.inf W ‚äì U := by\n    rw [‚Üê SetLike.mem_coe, TopologicalSpace.Opens.coe_inf, TopologicalSpace.Opens.coe_finset_inf]\n    exact ‚ü®by simpa using fun x _ ‚Ü¶ hxW x, hxU‚ü©\n  refine ‚ü®s.inf W ‚äì U, H, inf_le_right, ?_‚ü©\n  letI := œÜRX.hom.toAlgebra\n  letI := (œÜRX ‚â´ X.presheaf.germ U x hxU).hom.toAlgebra\n  letI := (œÜRX ‚â´ X.presheaf.map (homOfLE (inf_le_right (a := s.inf W))).op).hom.toAlgebra\n  let œÜ' : A ‚Üí‚Çê[R] X.presheaf.stalk x :=\n    { œÜ.hom with commutes' := DFunLike.congr_fun (congr_arg CommRingCat.Hom.hom e) }\n  let œà : Œì(X, s.inf W ‚äì U) ‚Üí‚Çê[R] X.presheaf.stalk x :=\n    { (X.presheaf.germ _ x H).hom with commutes' := fun x ‚Ü¶ X.presheaf.germ_res_apply _ _ _ _ }\n  show AlgHom.range œÜ' ‚â§ AlgHom.range œà\n  rw [‚Üê Algebra.map_top, ‚Üê hs, AlgHom.map_adjoin, Algebra.adjoin_le_iff]\n  rintro _ ‚ü®i, hi, rfl : œÜ i = _‚ü©\n  refine ‚ü®X.presheaf.map (homOfLE (inf_le_left.trans (Finset.inf_le hi))).op (f i), ?_‚ü©\n  exact (X.presheaf.germ_res_apply _ _ _ _).trans (hf _)\n\n"}
{"name":"AlgebraicGeometry.exists_lift_of_germInjective","module":"Mathlib.AlgebraicGeometry.SpreadingOut","initialProofState":"X : AlgebraicGeometry.Scheme\nR A : CommRingCat\nx : ‚Üë‚ÜëX.toPresheafedSpace\ninst‚úù : X.IsGermInjectiveAt x\nU : X.Opens\nhxU : Membership.mem U x\nœÜ : Quiver.Hom A (X.presheaf.stalk x)\nœÜRA : Quiver.Hom R A\nœÜRX : Quiver.Hom R (X.presheaf.obj { unop := U })\nhœÜRA : (CommRingCat.Hom.hom œÜRA).FiniteType\ne : Eq (CategoryTheory.CategoryStruct.comp œÜRA œÜ) (CategoryTheory.CategoryStruct.comp œÜRX (X.presheaf.germ U x hxU))\n‚ä¢ Exists fun V => Exists fun hxV => Exists fun œÜ' => Exists fun i => And (AlgebraicGeometry.IsAffineOpen V) (And (Eq œÜ (CategoryTheory.CategoryStruct.comp œÜ' (X.presheaf.germ V x hxV))) (Eq (CategoryTheory.CategoryStruct.comp œÜRX (X.presheaf.map i.hom.op)) (CategoryTheory.CategoryStruct.comp œÜRA œÜ')))","decl":"/--\nSuppose `X` is a scheme, `x : X` such that the germ map at `x` is (locally) injective,\nand `U` is a neighborhood of `x`.\nGiven a commutative diagram of `CommRingCat`\n```\nR ‚ü∂ Œì(X, U)\n‚Üì    ‚Üì\nA ‚ü∂ ùí™_{X, x}\n```\nsuch that `R` is of finite type over `A`, we may lift `A ‚ü∂ ùí™_{X, x}` to some `A ‚ü∂ Œì(X, V)`.\n-/\nlemma exists_lift_of_germInjective {x : X} [X.IsGermInjectiveAt x] {U : X.Opens} (hxU : x ‚àà U)\n    (œÜ : A ‚ü∂ X.presheaf.stalk x) (œÜRA : R ‚ü∂ A) (œÜRX : R ‚ü∂ Œì(X, U))\n    (hœÜRA : RingHom.FiniteType œÜRA.hom)\n    (e : œÜRA ‚â´ œÜ = œÜRX ‚â´ X.presheaf.germ U x hxU) :\n    ‚àÉ (V : X.Opens) (hxV : x ‚àà V) (œÜ' : A ‚ü∂ Œì(X, V)) (i : V ‚â§ U), IsAffineOpen V ‚àß\n      œÜ = œÜ' ‚â´ X.presheaf.germ V x hxV ‚àß œÜRX ‚â´ X.presheaf.map i.hom.op = œÜRA ‚â´ œÜ' := by\n  obtain ‚ü®V, hxV, iVU, hV‚ü© := exists_lift_of_germInjective_aux hxU œÜ œÜRA œÜRX hœÜRA e\n  obtain ‚ü®V', hxV', hV', iV'V, H‚ü© := X.exists_le_and_germ_injective x V hxV\n  let f := X.presheaf.germ V' x hxV'\n  have hf' : RingHom.range (X.presheaf.germ V x hxV).hom ‚â§ RingHom.range f.hom := by\n    rw [‚Üê X.presheaf.germ_res iV'V.hom _ hxV']\n    exact Set.range_comp_subset_range (X.presheaf.map iV'V.hom.op) f\n  let e := RingEquiv.ofLeftInverse H.hasLeftInverse.choose_spec\n  refine ‚ü®V', hxV', CommRingCat.ofHom (e.symm.toRingHom.comp\n    (œÜ.hom.codRestrict _ (fun x ‚Ü¶ hf' (hV ‚ü®x, rfl‚ü©)))), iV'V.trans iVU, hV', ?_, ?_‚ü©\n  ¬∑ ext a\n    show œÜ a = (e (e.symm _)).1\n    simp only [RingEquiv.apply_symm_apply]\n    rfl\n  ¬∑ ext a\n    apply e.injective\n    show e _ = e (e.symm _)\n    rw [RingEquiv.apply_symm_apply]\n    ext\n    show X.presheaf.germ _ _ _ (X.presheaf.map _ _) = (œÜRA ‚â´ œÜ) a\n    rw [CommRingCat.germ_res_apply, ‚ÄπœÜRA ‚â´ œÜ = _‚Ä∫]\n    rfl\n\n"}
{"name":"AlgebraicGeometry.spread_out_of_isGermInjective","module":"Mathlib.AlgebraicGeometry.SpreadingOut","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nsX : Quiver.Hom X S\nsY : Quiver.Hom Y S\ninst‚úù¬π : AlgebraicGeometry.LocallyOfFiniteType sY\nx : ‚Üë‚ÜëX.toPresheafedSpace\ninst‚úù : X.IsGermInjectiveAt x\ny : ‚Üë‚ÜëY.toPresheafedSpace\ne : Eq (sX.base x) (sY.base y)\nœÜ : Quiver.Hom (Y.presheaf.stalk y) (X.presheaf.stalk x)\nh : Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.stalkMap sY y) œÜ) (CategoryTheory.CategoryStruct.comp (S.presheaf.stalkSpecializes ‚ãØ) (AlgebraicGeometry.Scheme.Hom.stalkMap sX x))\n‚ä¢ Exists fun U => Exists fun hxU => Exists fun f => And (Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Spec.map œÜ) (Y.fromSpecStalk y)) (CategoryTheory.CategoryStruct.comp (U.fromSpecStalkOfMem x hxU) f)) (Eq (CategoryTheory.CategoryStruct.comp f sY) (CategoryTheory.CategoryStruct.comp U.Œπ sX))","decl":"/--\nGiven `S`-schemes `X Y` and points `x : X` `y : Y` over `s : S`.\nSuppose we have the following diagram of `S`-schemes\n```\nSpec ùí™_{X, x} ‚ü∂ X\n    |\n  Spec(œÜ)\n    ‚Üì\nSpec ùí™_{Y, y} ‚ü∂ Y\n```\nThen the map `Spec(œÜ)` spreads out to an `S`-morphism on an open subscheme `U ‚äÜ X`,\n```\nSpec ùí™_{X, x} ‚ü∂ U ‚äÜ X\n    |             |\n  Spec(œÜ)         |\n    ‚Üì             ‚Üì\nSpec ùí™_{Y, y} ‚ü∂ Y\n```\nprovided that `Y` is locally of finite type over `S` and\n`X` is \"germ-injective\" at `x` (e.g. when it's integral or locally noetherian).\n\nTODO: The condition on `X` is unnecessary when `Y` is locally of finite presentation.\n-/\n@[stacks 0BX6]\nlemma spread_out_of_isGermInjective [LocallyOfFiniteType sY] {x : X} [X.IsGermInjectiveAt x] {y : Y}\n    (e : sX.base x = sY.base y) (œÜ : Y.presheaf.stalk y ‚ü∂ X.presheaf.stalk x)\n    (h : sY.stalkMap y ‚â´ œÜ =\n      S.presheaf.stalkSpecializes (Inseparable.of_eq e).specializes ‚â´ sX.stalkMap x) :\n    ‚àÉ (U : X.Opens) (hxU : x ‚àà U) (f : U.toScheme ‚ü∂ Y),\n      Spec.map œÜ ‚â´ Y.fromSpecStalk y = U.fromSpecStalkOfMem x hxU ‚â´ f ‚àß\n      f ‚â´ sY = U.Œπ ‚â´ sX := by\n  obtain ‚ü®_, ‚ü®U, hU, rfl‚ü©, hxU, -‚ü© :=\n    (isBasis_affine_open S).exists_subset_of_mem_open (Set.mem_univ (sX.base x)) isOpen_univ\n  have hyU : sY.base y ‚àà U := e ‚ñ∏ hxU\n  obtain ‚ü®_, ‚ü®V : Y.Opens, hV, rfl‚ü©, hyV, iVU‚ü© :=\n    (isBasis_affine_open Y).exists_subset_of_mem_open hyU (sY ‚Åª¬π·µÅ U).2\n  have : sY.appLE U V iVU ‚â´ Y.presheaf.germ V y hyV ‚â´ œÜ =\n      sX.app U ‚â´ X.presheaf.germ (sX ‚Åª¬π·µÅ U) x hxU := by\n    rw [Scheme.Hom.appLE, Category.assoc, Y.presheaf.germ_res_assoc,\n      ‚Üê Scheme.stalkMap_germ_assoc, h]\n    simp\n  obtain ‚ü®W, hxW, œÜ', i, hW, h‚ÇÅ, h‚ÇÇ‚ü© :=\n    exists_lift_of_germInjective (R := Œì(S, U)) (A := Œì(Y, V)) (U := sX ‚Åª¬π·µÅ U) (x := x) hxU\n    (Y.presheaf.germ _ y hyV ‚â´ œÜ) (sY.appLE U V iVU) (sX.app U)\n    (LocallyOfFiniteType.finiteType_of_affine_subset ‚ü®_, hU‚ü© ‚ü®_, hV‚ü© _) this\n  refine ‚ü®W, hxW, W.toSpecŒì ‚â´ Spec.map œÜ' ‚â´ hV.fromSpec, ?_, ?_‚ü©\n  ¬∑ rw [W.fromSpecStalkOfMem_toSpecŒì_assoc x hxW, ‚Üê Spec.map_comp_assoc, ‚Üê h‚ÇÅ,\n      Spec.map_comp, Category.assoc, ‚Üê IsAffineOpen.fromSpecStalk,\n      IsAffineOpen.fromSpecStalk_eq_fromSpecStalk]\n  ¬∑ simp only [Category.assoc, IsAffineOpen.isoSpec_inv_Œπ_assoc]\n    rw [‚Üê IsAffineOpen.Spec_map_appLE_fromSpec sY hU hV iVU, ‚Üê Spec.map_comp_assoc, ‚Üê h‚ÇÇ,\n      ‚Üê Scheme.Hom.appLE, ‚Üê hW.isoSpec_hom, IsAffineOpen.Spec_map_appLE_fromSpec sX hU hW i,\n      ‚Üê Iso.eq_inv_comp, IsAffineOpen.isoSpec_inv_Œπ_assoc]\n\n"}
{"name":"AlgebraicGeometry.spread_out_of_isGermInjective'","module":"Mathlib.AlgebraicGeometry.SpreadingOut","initialProofState":"X Y S : AlgebraicGeometry.Scheme\nsX : Quiver.Hom X S\nsY : Quiver.Hom Y S\ninst‚úù¬π : AlgebraicGeometry.LocallyOfFiniteType sY\nx : ‚Üë‚ÜëX.toPresheafedSpace\ninst‚úù : X.IsGermInjectiveAt x\nœÜ : Quiver.Hom (AlgebraicGeometry.Spec (X.presheaf.stalk x)) Y\nh : Eq (CategoryTheory.CategoryStruct.comp œÜ sY) (CategoryTheory.CategoryStruct.comp (X.fromSpecStalk x) sX)\n‚ä¢ Exists fun U => Exists fun hxU => Exists fun f => And (Eq œÜ (CategoryTheory.CategoryStruct.comp (U.fromSpecStalkOfMem x hxU) f)) (Eq (CategoryTheory.CategoryStruct.comp f sY) (CategoryTheory.CategoryStruct.comp U.Œπ sX))","decl":"/--\nGiven `S`-schemes `X Y`, a point `x : X`, and a `S`-morphism `œÜ : Spec ùí™_{X, x} ‚ü∂ Y`,\nwe may spread it out to an `S`-morphism `f : U ‚ü∂ Y`\nprovided that `Y` is locally of finite type over `S` and\n`X` is \"germ-injective\" at `x` (e.g. when it's integral or locally noetherian).\n\nTODO: The condition on `X` is unnecessary when `Y` is locally of finite presentation.\n-/\nlemma spread_out_of_isGermInjective' [LocallyOfFiniteType sY] {x : X} [X.IsGermInjectiveAt x]\n    (œÜ : Spec (X.presheaf.stalk x) ‚ü∂ Y)\n    (h : œÜ ‚â´ sY = X.fromSpecStalk x ‚â´ sX) :\n    ‚àÉ (U : X.Opens) (hxU : x ‚àà U) (f : U.toScheme ‚ü∂ Y),\n      œÜ = U.fromSpecStalkOfMem x hxU ‚â´ f ‚àß f ‚â´ sY = U.Œπ ‚â´ sX := by\n  have := spread_out_of_isGermInjective sX sY ?_ (Scheme.stalkClosedPointTo œÜ) ?_\n  ¬∑ simpa only [Scheme.Spec_stalkClosedPointTo_fromSpecStalk] using this\n  ¬∑ rw [‚Üê Scheme.comp_base_apply, h, Scheme.comp_base_apply, Scheme.fromSpecStalk_closedPoint]\n  ¬∑ apply Spec.map_injective\n    rw [‚Üê cancel_mono (S.fromSpecStalk _)]\n    simpa only [Spec.map_comp, Category.assoc, Scheme.Spec_map_stalkMap_fromSpecStalk,\n      Scheme.Spec_stalkClosedPointTo_fromSpecStalk_assoc,\n      Scheme.Spec_map_stalkSpecializes_fromSpecStalk]\n\n"}
