{"name":"Ideal.Cotangent.isScalarTower","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\nS : Type v\nS' : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra S R\ninst✝³ : CommSemiring S'\ninst✝² : Algebra S' R\ninst✝¹ : Algebra S S'\ninst✝ : IsScalarTower S S' R\nI : Ideal R\n⊢ IsScalarTower S S' I.Cotangent","decl":"instance Cotangent.isScalarTower : IsScalarTower S S' I.Cotangent :=\n  Submodule.Quotient.isScalarTower _ _\n\n"}
{"name":"Ideal.instIsNoetherianCotangentOfSubtypeMem","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝¹ : CommRing R\nI : Ideal R\ninst✝ : IsNoetherian R (Subtype fun x => Membership.mem I x)\n⊢ IsNoetherian R I.Cotangent","decl":"instance [IsNoetherian R I] : IsNoetherian R I.Cotangent :=\n  inferInstanceAs (IsNoetherian R (I ⧸ (I • ⊤ : Submodule R I)))\n\n"}
{"name":"Ideal.toCotangent_apply","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\na✝ : Subtype fun x => Membership.mem I x\n⊢ Eq (I.toCotangent a✝) (Submodule.Quotient.mk a✝)","decl":"/-- The quotient map from `I` to `I ⧸ I ^ 2`. -/\n@[simps! (config := .lemmasOnly) apply]\ndef toCotangent : I →ₗ[R] I.Cotangent := Submodule.mkQ _\n\n"}
{"name":"Ideal.map_toCotangent_ker","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Eq (Submodule.map (Submodule.subtype I) (LinearMap.ker I.toCotangent)) (HPow.hPow I 2)","decl":"theorem map_toCotangent_ker : I.toCotangent.ker.map I.subtype = I ^ 2 := by\n  rw [Ideal.toCotangent, Submodule.ker_mkQ, pow_two, Submodule.map_smul'' I ⊤ (Submodule.subtype I),\n    Algebra.id.smul_eq_mul, Submodule.map_subtype_top]\n\n"}
{"name":"Ideal.mem_toCotangent_ker","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nx : Subtype fun x => Membership.mem I x\n⊢ Iff (Membership.mem (LinearMap.ker I.toCotangent) x) (Membership.mem (HPow.hPow I 2) ↑x)","decl":"theorem mem_toCotangent_ker {x : I} : x ∈ LinearMap.ker I.toCotangent ↔ (x : R) ∈ I ^ 2 := by\n  rw [← I.map_toCotangent_ker]\n  simp\n\n"}
{"name":"Ideal.toCotangent_eq","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nx y : Subtype fun x => Membership.mem I x\n⊢ Iff (Eq (I.toCotangent x) (I.toCotangent y)) (Membership.mem (HPow.hPow I 2) (HSub.hSub ↑x ↑y))","decl":"theorem toCotangent_eq {x y : I} : I.toCotangent x = I.toCotangent y ↔ (x - y : R) ∈ I ^ 2 := by\n  rw [← sub_eq_zero]\n  exact I.mem_toCotangent_ker\n\n"}
{"name":"Ideal.toCotangent_eq_zero","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nx : Subtype fun x => Membership.mem I x\n⊢ Iff (Eq (I.toCotangent x) 0) (Membership.mem (HPow.hPow I 2) ↑x)","decl":"theorem toCotangent_eq_zero (x : I) : I.toCotangent x = 0 ↔ (x : R) ∈ I ^ 2 := I.mem_toCotangent_ker\n\n"}
{"name":"Ideal.toCotangent_surjective","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Function.Surjective ⇑I.toCotangent","decl":"theorem toCotangent_surjective : Function.Surjective I.toCotangent := Submodule.mkQ_surjective _\n\n"}
{"name":"Ideal.toCotangent_range","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Eq (LinearMap.range I.toCotangent) Top.top","decl":"theorem toCotangent_range : LinearMap.range I.toCotangent = ⊤ := Submodule.range_mkQ _\n\n"}
{"name":"Ideal.cotangent_subsingleton_iff","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Iff (Subsingleton I.Cotangent) (IsIdempotentElem I)","decl":"theorem cotangent_subsingleton_iff : Subsingleton I.Cotangent ↔ IsIdempotentElem I := by\n  constructor\n  · intro H\n    refine (pow_two I).symm.trans (le_antisymm (Ideal.pow_le_self two_ne_zero) ?_)\n    exact fun x hx => (I.toCotangent_eq_zero ⟨x, hx⟩).mp (Subsingleton.elim _ _)\n  · exact fun e =>\n      ⟨fun x y =>\n        Quotient.inductionOn₂' x y fun x y =>\n          I.toCotangent_eq.mpr <| ((pow_two I).trans e).symm ▸ I.sub_mem x.prop y.prop⟩\n\n"}
{"name":"Ideal.to_quotient_square_comp_toCotangent","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Eq (I.cotangentToQuotientSquare.comp I.toCotangent) ((Submodule.mkQ (HPow.hPow I 2)).comp (Submodule.subtype I))","decl":"theorem to_quotient_square_comp_toCotangent :\n    I.cotangentToQuotientSquare.comp I.toCotangent = (I ^ 2).mkQ.comp (Submodule.subtype I) :=\n  LinearMap.ext fun _ => rfl\n\n"}
{"name":"Ideal.toCotangent_to_quotient_square","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nx : Subtype fun x => Membership.mem I x\n⊢ Eq (I.cotangentToQuotientSquare (I.toCotangent x)) ((Submodule.mkQ (HPow.hPow I 2)) ↑x)","decl":"@[simp]\ntheorem toCotangent_to_quotient_square (x : I) :\n    I.cotangentToQuotientSquare (I.toCotangent x) = (I ^ 2).mkQ x := rfl\n\n"}
{"name":"Ideal.Cotangent.smul_eq_zero_of_mem","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nx : R\nhx : Membership.mem I x\nm : I.Cotangent\n⊢ Eq (HSMul.hSMul x m) 0","decl":"lemma Cotangent.smul_eq_zero_of_mem {I : Ideal R}\n    {x} (hx : x ∈ I) (m : I.Cotangent) : x • m = 0 := by\n  obtain ⟨m, rfl⟩ := Ideal.toCotangent_surjective _ m\n  rw [← map_smul, Ideal.toCotangent_eq_zero, pow_two]\n  exact Ideal.mul_mem_mul hx m.2\n\n"}
{"name":"Ideal.isTorsionBySet_cotangent","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Module.IsTorsionBySet R I.Cotangent ↑I","decl":"lemma isTorsionBySet_cotangent :\n    Module.IsTorsionBySet R I.Cotangent I :=\n  fun m x ↦ m.smul_eq_zero_of_mem x.2\n\n"}
{"name":"Ideal.cotangentIdeal_square","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Eq (HPow.hPow I.cotangentIdeal 2) Bot.bot","decl":"theorem cotangentIdeal_square (I : Ideal R) : I.cotangentIdeal ^ 2 = ⊥ := by\n  rw [eq_bot_iff, pow_two I.cotangentIdeal, ← smul_eq_mul]\n  intro x hx\n  refine Submodule.smul_induction_on hx ?_ ?_\n  · rintro _ ⟨x, hx, rfl⟩ _ ⟨y, hy, rfl⟩; apply (Submodule.Quotient.eq _).mpr _\n    rw [sub_zero, pow_two]; exact Ideal.mul_mem_mul hx hy\n  · intro x y hx hy; exact add_mem hx hy\n\n"}
{"name":"Ideal.mk_mem_cotangentIdeal","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nx : R\n⊢ Iff (Membership.mem I.cotangentIdeal ((Ideal.Quotient.mk (HPow.hPow I 2)) x)) (Membership.mem I x)","decl":"lemma mk_mem_cotangentIdeal {I : Ideal R} {x : R} :\n    Quotient.mk (I ^ 2) x ∈ I.cotangentIdeal ↔ x ∈ I := by\n  refine ⟨fun ⟨y, hy, e⟩ ↦ ?_,  fun h ↦ ⟨x, h, rfl⟩⟩\n  simpa using sub_mem hy (Ideal.pow_le_self two_ne_zero\n    ((Ideal.Quotient.mk_eq_mk_iff_sub_mem _ _).mp e))\n\n"}
{"name":"Ideal.comap_cotangentIdeal","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Eq (Ideal.comap (Ideal.Quotient.mk (HPow.hPow I 2)) I.cotangentIdeal) I","decl":"lemma comap_cotangentIdeal (I : Ideal R) :\n    I.cotangentIdeal.comap (Quotient.mk (I ^ 2)) = I :=\n  Ideal.ext fun _ ↦ mk_mem_cotangentIdeal\n\n"}
{"name":"Ideal.range_cotangentToQuotientSquare","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Eq (LinearMap.range I.cotangentToQuotientSquare) (Submodule.restrictScalars R I.cotangentIdeal)","decl":"theorem range_cotangentToQuotientSquare :\n    LinearMap.range I.cotangentToQuotientSquare = I.cotangentIdeal.restrictScalars R := by\n  trans LinearMap.range (I.cotangentToQuotientSquare.comp I.toCotangent)\n  · rw [LinearMap.range_comp, I.toCotangent_range, Submodule.map_top]\n  · rw [to_quotient_square_comp_toCotangent, LinearMap.range_comp, I.range_subtype]; ext; rfl\n\n"}
{"name":"Ideal.to_quotient_square_range","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\n⊢ Eq (LinearMap.range I.cotangentToQuotientSquare) (Submodule.restrictScalars R I.cotangentIdeal)","decl":"@[deprecated (since := \"2025-01-04\")]\nalias to_quotient_square_range := range_cotangentToQuotientSquare\n\n"}
{"name":"Ideal.cotangentEquivIdeal_apply","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nx : I.Cotangent\n⊢ Eq (↑(I.cotangentEquivIdeal x)) (I.cotangentToQuotientSquare x)","decl":"@[simp]\ntheorem cotangentEquivIdeal_apply (x : I.Cotangent) :\n    ↑(I.cotangentEquivIdeal x) = I.cotangentToQuotientSquare x := rfl\n\n"}
{"name":"Ideal.cotangentEquivIdeal_symm_apply","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝ : CommRing R\nI : Ideal R\nx : R\nhx : Membership.mem I x\n⊢ Eq (I.cotangentEquivIdeal.symm ⟨(Submodule.mkQ (HPow.hPow I 2)) x, ⋯⟩) (I.toCotangent ⟨x, hx⟩)","decl":"theorem cotangentEquivIdeal_symm_apply (x : R) (hx : x ∈ I) :\n    -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to specify `(R₂ := R)` because `I.toCotangent` suggested `R ⧸ I^2` instead\n    I.cotangentEquivIdeal.symm ⟨(I ^ 2).mkQ x,\n      -- timeout (200000 heartbeats) without `by exact`\n      by exact Submodule.mem_map_of_mem (F := R →ₗ[R] R ⧸ I ^ 2) (f := (I ^ 2).mkQ) hx⟩ =\n      I.toCotangent (R := R) ⟨x, hx⟩ := by\n  apply I.cotangentEquivIdeal.injective\n  rw [I.cotangentEquivIdeal.apply_symm_apply]\n  ext\n  rfl\n\n"}
{"name":"AlgHom.ker_kerSquareLift","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nA : Type u_1\nB : Type u_2\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgHom R A B\n⊢ Eq (RingHom.ker f.kerSquareLift.toRingHom) (RingHom.ker f.toRingHom).cotangentIdeal","decl":"theorem _root_.AlgHom.ker_kerSquareLift (f : A →ₐ[R] B) :\n    RingHom.ker f.kerSquareLift.toRingHom = f.toRingHom.ker.cotangentIdeal := by\n  apply le_antisymm\n  · intro x hx; obtain ⟨x, rfl⟩ := Ideal.Quotient.mk_surjective x; exact ⟨x, hx, rfl⟩\n  · rintro _ ⟨x, hx, rfl⟩; exact hx\n\n"}
{"name":"Ideal.instIsScalarTowerQuotientHPowKerRingHomAlgebraMapOfNat","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝⁶ : CommRing R\nA : Type u_1\nB : Type u_2\ninst✝⁵ : CommRing A\ninst✝⁴ : CommRing B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\ninst✝¹ : Algebra A B\ninst✝ : IsScalarTower R A B\n⊢ IsScalarTower R (HasQuotient.Quotient A (HPow.hPow (RingHom.ker (algebraMap A B)) 2)) B","decl":"instance [Algebra A B] [IsScalarTower R A B] :\n    IsScalarTower R (A ⧸ (RingHom.ker (algebraMap A B) ^ 2)) B :=\n  IsScalarTower.of_algebraMap_eq'\n    (IsScalarTower.toAlgHom R A B).kerSquareLift.comp_algebraMap.symm\n\n"}
{"name":"Ideal.mapCotangent_toCotangent","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u\ninst✝⁴ : CommRing R\nA : Type u_1\nB : Type u_2\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nI₁ : Ideal A\nI₂ : Ideal B\nf : AlgHom R A B\nh : LE.le I₁ (Ideal.comap f I₂)\nx : Subtype fun x => Membership.mem I₁ x\n⊢ Eq ((I₁.mapCotangent I₂ f h) (I₁.toCotangent x)) (I₂.toCotangent ⟨f ↑x, ⋯⟩)","decl":"@[simp]\nlemma mapCotangent_toCotangent\n    (I₁ : Ideal A) (I₂ : Ideal B) (f : A →ₐ[R] B) (h : I₁ ≤ I₂.comap f) (x : I₁) :\n    Ideal.mapCotangent I₁ I₂ f h (Ideal.toCotangent I₁ x) = Ideal.toCotangent I₂ ⟨f x, h x.2⟩ := rfl\n\n"}
{"name":"IsLocalRing.instIsScalarTowerResidueFieldCotangentSpace","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\ninst✝ : IsLocalRing R\n⊢ IsScalarTower R (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R)","decl":"instance : IsScalarTower R (ResidueField R) (CotangentSpace R) :=\n  Module.IsTorsionBySet.isScalarTower _\n\n"}
{"name":"IsLocalRing.instFiniteDimensionalResidueFieldCotangentSpaceOfIsNoetherianRing","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsLocalRing R\ninst✝ : IsNoetherianRing R\n⊢ FiniteDimensional (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R)","decl":"instance [IsNoetherianRing R] : FiniteDimensional (ResidueField R) (CotangentSpace R) :=\n  Module.Finite.of_restrictScalars_finite R _ _\n\n"}
{"name":"IsLocalRing.subsingleton_cotangentSpace_iff","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsLocalRing R\ninst✝ : IsNoetherianRing R\n⊢ Iff (Subsingleton (IsLocalRing.CotangentSpace R)) (IsField R)","decl":"lemma subsingleton_cotangentSpace_iff [IsNoetherianRing R] :\n    Subsingleton (CotangentSpace R) ↔ IsField R := by\n  refine (maximalIdeal R).cotangent_subsingleton_iff.trans ?_\n  rw [IsLocalRing.isField_iff_maximalIdeal_eq,\n    Ideal.isIdempotentElem_iff_eq_bot_or_top_of_isLocalRing]\n  simp [(maximalIdeal.isMaximal R).ne_top]\n\n"}
{"name":"IsLocalRing.CotangentSpace.map_eq_top_iff","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsLocalRing R\ninst✝ : IsNoetherianRing R\nM : Submodule R (Subtype fun x => Membership.mem (IsLocalRing.maximalIdeal R) x)\n⊢ Iff (Eq (Submodule.map (IsLocalRing.maximalIdeal R).toCotangent M) Top.top) (Eq M Top.top)","decl":"lemma CotangentSpace.map_eq_top_iff [IsNoetherianRing R] {M : Submodule R (maximalIdeal R)} :\n    M.map (maximalIdeal R).toCotangent = ⊤ ↔ M = ⊤ := by\n  refine ⟨fun H ↦ eq_top_iff.mpr ?_, by rintro rfl; simp [Ideal.toCotangent_range]⟩\n  refine (Submodule.map_le_map_iff_of_injective (Submodule.injective_subtype _) _ _).mp ?_\n  rw [Submodule.map_top, Submodule.range_subtype]\n  apply Submodule.le_of_le_smul_of_le_jacobson_bot (IsNoetherian.noetherian _)\n    (IsLocalRing.jacobson_eq_maximalIdeal _ bot_ne_top).ge\n  rw [smul_eq_mul, ← pow_two, ← Ideal.map_toCotangent_ker, ← Submodule.map_sup,\n    ← Submodule.comap_map_eq, H, Submodule.comap_top, Submodule.map_top, Submodule.range_subtype]\n\n"}
{"name":"IsLocalRing.CotangentSpace.span_image_eq_top_iff","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsLocalRing R\ninst✝ : IsNoetherianRing R\ns : Set (Subtype fun x => Membership.mem (IsLocalRing.maximalIdeal R) x)\n⊢ Iff (Eq (Submodule.span (IsLocalRing.ResidueField R) (Set.image (⇑(IsLocalRing.maximalIdeal R).toCotangent) s)) Top.top) (Eq (Submodule.span R s) Top.top)","decl":"lemma CotangentSpace.span_image_eq_top_iff [IsNoetherianRing R] {s : Set (maximalIdeal R)} :\n    Submodule.span (ResidueField R) ((maximalIdeal R).toCotangent '' s) = ⊤ ↔\n      Submodule.span R s = ⊤ := by\n  rw [← map_eq_top_iff, ← (Submodule.restrictScalars_injective R ..).eq_iff,\n    Submodule.restrictScalars_span]\n  · simp only [Ideal.toCotangent_apply, Submodule.restrictScalars_top, Submodule.map_span]\n  · exact Ideal.Quotient.mk_surjective\n\n"}
{"name":"IsLocalRing.finrank_cotangentSpace_eq_zero_iff","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsLocalRing R\ninst✝ : IsNoetherianRing R\n⊢ Iff (Eq (Module.finrank (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R)) 0) (IsField R)","decl":"lemma finrank_cotangentSpace_eq_zero_iff [IsNoetherianRing R] :\n    finrank (ResidueField R) (CotangentSpace R) = 0 ↔ IsField R := by\n  rw [finrank_zero_iff, subsingleton_cotangentSpace_iff]\n\n"}
{"name":"IsLocalRing.finrank_cotangentSpace_eq_zero","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u_2\ninst✝ : Field R\n⊢ Eq (Module.finrank (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R)) 0","decl":"lemma finrank_cotangentSpace_eq_zero (R) [Field R] :\n    finrank (ResidueField R) (CotangentSpace R) = 0 :=\n  finrank_cotangentSpace_eq_zero_iff.mpr (Field.toIsField R)\n\n"}
{"name":"IsLocalRing.finrank_cotangentSpace_le_one_iff","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsLocalRing R\ninst✝ : IsNoetherianRing R\n⊢ Iff (LE.le (Module.finrank (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R)) 1) (Submodule.IsPrincipal (IsLocalRing.maximalIdeal R))","decl":"open Submodule in\ntheorem finrank_cotangentSpace_le_one_iff [IsNoetherianRing R] :\n    finrank (ResidueField R) (CotangentSpace R) ≤ 1 ↔ (maximalIdeal R).IsPrincipal := by\n  rw [Module.finrank_le_one_iff_top_isPrincipal, isPrincipal_iff,\n    (maximalIdeal R).toCotangent_surjective.exists, isPrincipal_iff]\n  simp_rw [← Set.image_singleton, eq_comm (a := ⊤), CotangentSpace.span_image_eq_top_iff,\n    ← (map_injective_of_injective (injective_subtype _)).eq_iff, map_span, Set.image_singleton,\n    Submodule.map_top, range_subtype, eq_comm (a := maximalIdeal R)]\n  exact ⟨fun ⟨x, h⟩ ↦ ⟨_, h⟩, fun ⟨x, h⟩ ↦ ⟨⟨x, h ▸ subset_span (Set.mem_singleton x)⟩, h⟩⟩\n\n"}
{"name":"LocalRing.subsingleton_cotangentSpace_iff","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsLocalRing R\ninst✝ : IsNoetherianRing R\n⊢ Iff (Subsingleton (IsLocalRing.CotangentSpace R)) (IsField R)","decl":"@[deprecated (since := \"2024-11-11\")]\nalias LocalRing.subsingleton_cotangentSpace_iff := IsLocalRing.subsingleton_cotangentSpace_iff\n\n"}
{"name":"LocalRing.map_eq_top_iff","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsLocalRing R\ninst✝ : IsNoetherianRing R\nM : Submodule R (Subtype fun x => Membership.mem (IsLocalRing.maximalIdeal R) x)\n⊢ Iff (Eq (Submodule.map (IsLocalRing.maximalIdeal R).toCotangent M) Top.top) (Eq M Top.top)","decl":"@[deprecated (since := \"2024-11-11\")]\nalias LocalRing.map_eq_top_iff := IsLocalRing.CotangentSpace.map_eq_top_iff\n\n"}
{"name":"LocalRing.span_image_eq_top_iff","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsLocalRing R\ninst✝ : IsNoetherianRing R\ns : Set (Subtype fun x => Membership.mem (IsLocalRing.maximalIdeal R) x)\n⊢ Iff (Eq (Submodule.span (IsLocalRing.ResidueField R) (Set.image (⇑(IsLocalRing.maximalIdeal R).toCotangent) s)) Top.top) (Eq (Submodule.span R s) Top.top)","decl":"@[deprecated (since := \"2024-11-11\")]\nalias LocalRing.span_image_eq_top_iff := IsLocalRing.CotangentSpace.span_image_eq_top_iff\n\n"}
{"name":"LocalRing.finrank_cotangentSpace_eq_zero_iff","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsLocalRing R\ninst✝ : IsNoetherianRing R\n⊢ Iff (Eq (Module.finrank (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R)) 0) (IsField R)","decl":"@[deprecated (since := \"2024-11-11\")]\nalias LocalRing.finrank_cotangentSpace_eq_zero_iff := IsLocalRing.finrank_cotangentSpace_eq_zero_iff\n\n"}
{"name":"LocalRing.finrank_cotangentSpace_eq_zero","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u_2\ninst✝ : Field R\n⊢ Eq (Module.finrank (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R)) 0","decl":"@[deprecated (since := \"2024-11-11\")]\nalias LocalRing.finrank_cotangentSpace_eq_zero := IsLocalRing.finrank_cotangentSpace_eq_zero\n\n"}
{"name":"LocalRing.finrank_cotangentSpace_le_one_iff","module":"Mathlib.RingTheory.Ideal.Cotangent","initialProofState":"R : Type u_1\ninst✝² : CommRing R\ninst✝¹ : IsLocalRing R\ninst✝ : IsNoetherianRing R\n⊢ Iff (LE.le (Module.finrank (IsLocalRing.ResidueField R) (IsLocalRing.CotangentSpace R)) 1) (Submodule.IsPrincipal (IsLocalRing.maximalIdeal R))","decl":"@[deprecated (since := \"2024-11-11\")]\nalias LocalRing.finrank_cotangentSpace_le_one_iff := IsLocalRing.finrank_cotangentSpace_le_one_iff\n"}
