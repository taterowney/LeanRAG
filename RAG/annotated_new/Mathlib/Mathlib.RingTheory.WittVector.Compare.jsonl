{"name":"TruncatedWittVector.eq_of_le_of_cast_pow_eq_zero","module":"Mathlib.RingTheory.WittVector.Compare","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\nR : Type u_1\ninst‚úù¬π : CommRing R\ninst‚úù : CharP R p\ni : Nat\nhin : LE.le i n\nhpi : Eq (HPow.hPow (‚Üëp) i) 0\n‚ä¢ Eq i n","decl":"theorem eq_of_le_of_cast_pow_eq_zero [CharP R p] (i : ‚Ñï) (hin : i ‚â§ n)\n    (hpi : (p : TruncatedWittVector p n R) ^ i = 0) : i = n := by\n  contrapose! hpi\n  replace hin := lt_of_le_of_ne hin hpi; clear hpi\n  have : (p : TruncatedWittVector p n R) ^ i = WittVector.truncate n ((p : ùïé R) ^ i) := by\n    rw [RingHom.map_pow, map_natCast]\n  rw [this, ne_eq, TruncatedWittVector.ext_iff, not_forall]; clear this\n  use ‚ü®i, hin‚ü©\n  rw [WittVector.coeff_truncate, coeff_zero, Fin.val_mk, WittVector.coeff_p_pow]\n  haveI : Nontrivial R := CharP.nontrivial_of_char_ne_one hp.1.ne_one\n  exact one_ne_zero\n\n"}
{"name":"TruncatedWittVector.card_zmod","module":"Mathlib.RingTheory.WittVector.Compare","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ Eq (Fintype.card (TruncatedWittVector p n (ZMod p))) (HPow.hPow p n)","decl":"theorem card_zmod : Fintype.card (TruncatedWittVector p n (ZMod p)) = p ^ n := by\n  rw [card, ZMod.card]\n\n"}
{"name":"TruncatedWittVector.charP_zmod","module":"Mathlib.RingTheory.WittVector.Compare","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ CharP (TruncatedWittVector p n (ZMod p)) (HPow.hPow p n)","decl":"theorem charP_zmod : CharP (TruncatedWittVector p n (ZMod p)) (p ^ n) :=\n  charP_of_prime_pow_injective _ _ _ (card_zmod _ _) (eq_of_le_of_cast_pow_eq_zero p n (ZMod p))\n\n"}
{"name":"TruncatedWittVector.zmodEquivTrunc_apply","module":"Mathlib.RingTheory.WittVector.Compare","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\nx : ZMod (HPow.hPow p n)\n‚ä¢ Eq ((TruncatedWittVector.zmodEquivTrunc p n) x) ((ZMod.castHom ‚ãØ (TruncatedWittVector p n (ZMod p))) x)","decl":"theorem zmodEquivTrunc_apply {x : ZMod (p ^ n)} :\n    zmodEquivTrunc p n x =\n      ZMod.castHom (m := p ^ n) (by rfl) (TruncatedWittVector p n (ZMod p)) x :=\n  rfl\n\n"}
{"name":"TruncatedWittVector.commutes","module":"Mathlib.RingTheory.WittVector.Compare","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn m : Nat\nhm : LE.le n m\n‚ä¢ Eq ((TruncatedWittVector.truncate hm).comp (TruncatedWittVector.zmodEquivTrunc p m).toRingHom) ((TruncatedWittVector.zmodEquivTrunc p n).toRingHom.comp (ZMod.castHom ‚ãØ (ZMod (HPow.hPow p n))))","decl":"/-- The following diagram commutes:\n```text\n          ZMod (p^n) ----------------------------> ZMod (p^m)\n            |                                        |\n            |                                        |\n            v                                        v\nTruncatedWittVector p n (ZMod p) ----> TruncatedWittVector p m (ZMod p)\n```\nHere the vertical arrows are `TruncatedWittVector.zmodEquivTrunc`,\nthe horizontal arrow at the top is `ZMod.castHom`,\nand the horizontal arrow at the bottom is `TruncatedWittVector.truncate`.\n-/\ntheorem commutes {m : ‚Ñï} (hm : n ‚â§ m) :\n    (truncate hm).comp (zmodEquivTrunc p m).toRingHom =\n      (zmodEquivTrunc p n).toRingHom.comp (ZMod.castHom (pow_dvd_pow p hm) _) :=\n  RingHom.ext_zmod _ _\n\n"}
{"name":"TruncatedWittVector.commutes'","module":"Mathlib.RingTheory.WittVector.Compare","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn m : Nat\nhm : LE.le n m\nx : ZMod (HPow.hPow p m)\n‚ä¢ Eq ((TruncatedWittVector.truncate hm) ((TruncatedWittVector.zmodEquivTrunc p m) x)) ((TruncatedWittVector.zmodEquivTrunc p n) ((ZMod.castHom ‚ãØ (ZMod (HPow.hPow p n))) x))","decl":"theorem commutes' {m : ‚Ñï} (hm : n ‚â§ m) (x : ZMod (p ^ m)) :\n    truncate hm (zmodEquivTrunc p m x) = zmodEquivTrunc p n (ZMod.castHom (pow_dvd_pow p hm) _ x) :=\n  show (truncate hm).comp (zmodEquivTrunc p m).toRingHom x = _ by rw [commutes _ _ hm]; rfl\n\n"}
{"name":"TruncatedWittVector.commutes_symm'","module":"Mathlib.RingTheory.WittVector.Compare","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn m : Nat\nhm : LE.le n m\nx : TruncatedWittVector p m (ZMod p)\n‚ä¢ Eq ((TruncatedWittVector.zmodEquivTrunc p n).symm ((TruncatedWittVector.truncate hm) x)) ((ZMod.castHom ‚ãØ (ZMod (HPow.hPow p n))) ((TruncatedWittVector.zmodEquivTrunc p m).symm x))","decl":"theorem commutes_symm' {m : ‚Ñï} (hm : n ‚â§ m) (x : TruncatedWittVector p m (ZMod p)) :\n    (zmodEquivTrunc p n).symm (truncate hm x) =\n      ZMod.castHom (pow_dvd_pow p hm) _ ((zmodEquivTrunc p m).symm x) := by\n  apply (zmodEquivTrunc p n).injective\n  rw [‚Üê commutes' _ _ hm]\n  simp\n\n"}
{"name":"TruncatedWittVector.commutes_symm","module":"Mathlib.RingTheory.WittVector.Compare","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn m : Nat\nhm : LE.le n m\n‚ä¢ Eq ((TruncatedWittVector.zmodEquivTrunc p n).symm.toRingHom.comp (TruncatedWittVector.truncate hm)) ((ZMod.castHom ‚ãØ (ZMod (HPow.hPow p n))).comp (TruncatedWittVector.zmodEquivTrunc p m).symm.toRingHom)","decl":"/-- The following diagram commutes:\n```text\nTruncatedWittVector p n (ZMod p) ----> TruncatedWittVector p m (ZMod p)\n            |                                        |\n            |                                        |\n            v                                        v\n          ZMod (p^n) ----------------------------> ZMod (p^m)\n```\nHere the vertical arrows are `(TruncatedWittVector.zmodEquivTrunc p _).symm`,\nthe horizontal arrow at the top is `ZMod.castHom`,\nand the horizontal arrow at the bottom is `TruncatedWittVector.truncate`.\n-/\ntheorem commutes_symm {m : ‚Ñï} (hm : n ‚â§ m) :\n    (zmodEquivTrunc p n).symm.toRingHom.comp (truncate hm) =\n      (ZMod.castHom (pow_dvd_pow p hm) _).comp (zmodEquivTrunc p m).symm.toRingHom := by\n  ext; apply commutes_symm'\n\n"}
{"name":"WittVector.toZModPow_compat","module":"Mathlib.RingTheory.WittVector.Compare","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nm n : Nat\nh : LE.le m n\n‚ä¢ Eq ((ZMod.castHom ‚ãØ (ZMod (HPow.hPow p m))).comp (WittVector.toZModPow p n)) (WittVector.toZModPow p m)","decl":"theorem toZModPow_compat (m n : ‚Ñï) (h : m ‚â§ n) :\n    (ZMod.castHom (pow_dvd_pow p h) (ZMod (p ^ m))).comp (toZModPow p n) = toZModPow p m :=\n  calc\n    (ZMod.castHom _ (ZMod (p ^ m))).comp ((zmodEquivTrunc p n).symm.toRingHom.comp (truncate n))\n    _ = ((zmodEquivTrunc p m).symm.toRingHom.comp (TruncatedWittVector.truncate h)).comp\n          (truncate n) := by\n      rw [commutes_symm, RingHom.comp_assoc]\n    _ = (zmodEquivTrunc p m).symm.toRingHom.comp (truncate m) := by\n      rw [RingHom.comp_assoc, truncate_comp_wittVector_truncate]\n\n"}
{"name":"WittVector.zmodEquivTrunc_compat","module":"Mathlib.RingTheory.WittVector.Compare","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nk‚ÇÅ k‚ÇÇ : Nat\nhk : LE.le k‚ÇÅ k‚ÇÇ\n‚ä¢ Eq ((TruncatedWittVector.truncate hk).comp ((TruncatedWittVector.zmodEquivTrunc p k‚ÇÇ).toRingHom.comp (PadicInt.toZModPow k‚ÇÇ))) ((TruncatedWittVector.zmodEquivTrunc p k‚ÇÅ).toRingHom.comp (PadicInt.toZModPow k‚ÇÅ))","decl":"theorem zmodEquivTrunc_compat (k‚ÇÅ k‚ÇÇ : ‚Ñï) (hk : k‚ÇÅ ‚â§ k‚ÇÇ) :\n    (TruncatedWittVector.truncate hk).comp\n        ((zmodEquivTrunc p k‚ÇÇ).toRingHom.comp (PadicInt.toZModPow k‚ÇÇ)) =\n      (zmodEquivTrunc p k‚ÇÅ).toRingHom.comp (PadicInt.toZModPow k‚ÇÅ) := by\n  rw [‚Üê RingHom.comp_assoc, commutes, RingHom.comp_assoc,\n    PadicInt.zmod_cast_comp_toZModPow _ _ hk]\n\n"}
{"name":"WittVector.toPadicInt_comp_fromPadicInt","module":"Mathlib.RingTheory.WittVector.Compare","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n‚ä¢ Eq ((WittVector.toPadicInt p).comp (WittVector.fromPadicInt p)) (RingHom.id (PadicInt p))","decl":"theorem toPadicInt_comp_fromPadicInt : (toPadicInt p).comp (fromPadicInt p) = RingHom.id ‚Ñ§_[p] := by\n  rw [‚Üê PadicInt.toZModPow_eq_iff_ext]\n  intro n\n  rw [‚Üê RingHom.comp_assoc, toPadicInt, PadicInt.lift_spec]\n  simp only [fromPadicInt, toZModPow, RingHom.comp_id]\n  rw [RingHom.comp_assoc, truncate_comp_lift, ‚Üê RingHom.comp_assoc]\n  simp only [RingEquiv.symm_toRingHom_comp_toRingHom, RingHom.id_comp]\n\n"}
{"name":"WittVector.toPadicInt_comp_fromPadicInt_ext","module":"Mathlib.RingTheory.WittVector.Compare","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : PadicInt p\n‚ä¢ Eq (((WittVector.toPadicInt p).comp (WittVector.fromPadicInt p)) x) ((RingHom.id (PadicInt p)) x)","decl":"theorem toPadicInt_comp_fromPadicInt_ext (x) :\n    (toPadicInt p).comp (fromPadicInt p) x = RingHom.id ‚Ñ§_[p] x := by\n  rw [toPadicInt_comp_fromPadicInt]\n\n"}
{"name":"WittVector.fromPadicInt_comp_toPadicInt","module":"Mathlib.RingTheory.WittVector.Compare","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n‚ä¢ Eq ((WittVector.fromPadicInt p).comp (WittVector.toPadicInt p)) (RingHom.id (WittVector p (ZMod p)))","decl":"theorem fromPadicInt_comp_toPadicInt :\n    (fromPadicInt p).comp (toPadicInt p) = RingHom.id (ùïé (ZMod p)) := by\n  apply WittVector.hom_ext\n  intro n\n  rw [fromPadicInt, ‚Üê RingHom.comp_assoc, truncate_comp_lift, RingHom.comp_assoc]\n  simp only [toPadicInt, toZModPow, RingHom.comp_id, PadicInt.lift_spec, RingHom.id_comp, ‚Üê\n    RingHom.comp_assoc, RingEquiv.toRingHom_comp_symm_toRingHom]\n\n"}
{"name":"WittVector.fromPadicInt_comp_toPadicInt_ext","module":"Mathlib.RingTheory.WittVector.Compare","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : WittVector p (ZMod p)\n‚ä¢ Eq (((WittVector.fromPadicInt p).comp (WittVector.toPadicInt p)) x) ((RingHom.id (WittVector p (ZMod p))) x)","decl":"theorem fromPadicInt_comp_toPadicInt_ext (x) :\n    (fromPadicInt p).comp (toPadicInt p) x = RingHom.id (ùïé (ZMod p)) x := by\n  rw [fromPadicInt_comp_toPadicInt]\n\n"}
