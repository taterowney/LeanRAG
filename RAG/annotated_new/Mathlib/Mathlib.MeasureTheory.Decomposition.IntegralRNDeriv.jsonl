{"name":"MeasureTheory.le_integral_rnDeriv_of_ac","module":"Mathlib.MeasureTheory.Decomposition.IntegralRNDeriv","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nf : Real → Real\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : MeasureTheory.IsProbabilityMeasure ν\nhf_cvx : ConvexOn Real (Set.Ici 0) f\nhf_cont : ContinuousWithinAt f (Set.Ici 0) 0\nhf_int : MeasureTheory.Integrable (fun x => f (μ.rnDeriv ν x).toReal) ν\nhμν : μ.AbsolutelyContinuous ν\n⊢ LE.le (f (μ Set.univ).toReal) (MeasureTheory.integral ν fun x => f (μ.rnDeriv ν x).toReal)","decl":"/-- For a convex continuous function `f` on `[0, ∞)`, if `μ` is absolutely continuous\nwith respect to a probability measure `ν`, then\n`f (μ univ).toReal ≤ ∫ x, f (μ.rnDeriv ν x).toReal ∂ν`. -/\nlemma le_integral_rnDeriv_of_ac [IsFiniteMeasure μ] [IsProbabilityMeasure ν]\n    (hf_cvx : ConvexOn ℝ (Ici 0) f) (hf_cont : ContinuousWithinAt f (Ici 0) 0)\n    (hf_int : Integrable (fun x ↦ f (μ.rnDeriv ν x).toReal) ν) (hμν : μ ≪ ν) :\n    f (μ univ).toReal ≤ ∫ x, f (μ.rnDeriv ν x).toReal ∂ν := by\n  have hf_cont' : ContinuousOn f (Ici 0) := by\n    intro x hx\n    rcases eq_or_lt_of_le (α := ℝ) (hx : 0 ≤ x) with rfl | hx_pos\n    · exact hf_cont\n    · have h := hf_cvx.continuousOn_interior x\n      simp only [nonempty_Iio, interior_Ici', mem_Ioi] at h\n      rw [continuousWithinAt_iff_continuousAt (Ioi_mem_nhds hx_pos)] at h\n      exact (h hx_pos).continuousWithinAt\n  calc f (μ univ).toReal\n    = f (∫ x, (μ.rnDeriv ν x).toReal ∂ν) := by rw [Measure.integral_toReal_rnDeriv hμν]\n  _ ≤ ∫ x, f (μ.rnDeriv ν x).toReal ∂ν := by\n    rw [← average_eq_integral, ← average_eq_integral]\n    exact ConvexOn.map_average_le hf_cvx hf_cont' isClosed_Ici (by simp)\n      Measure.integrable_toReal_rnDeriv hf_int\n\n"}
{"name":"MeasureTheory.mul_le_integral_rnDeriv_of_ac","module":"Mathlib.MeasureTheory.Decomposition.IntegralRNDeriv","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nf : Real → Real\ninst✝¹ : MeasureTheory.IsFiniteMeasure μ\ninst✝ : MeasureTheory.IsFiniteMeasure ν\nhf_cvx : ConvexOn Real (Set.Ici 0) f\nhf_cont : ContinuousWithinAt f (Set.Ici 0) 0\nhf_int : MeasureTheory.Integrable (fun x => f (μ.rnDeriv ν x).toReal) ν\nhμν : μ.AbsolutelyContinuous ν\n⊢ LE.le (HMul.hMul (ν Set.univ).toReal (f (HDiv.hDiv (μ Set.univ).toReal (ν Set.univ).toReal))) (MeasureTheory.integral ν fun x => f (μ.rnDeriv ν x).toReal)","decl":"/-- For a convex continuous function `f` on `[0, ∞)`, if `μ` is absolutely continuous\nwith respect to `ν`, then\n`(ν univ).toReal * f ((μ univ).toReal / (ν univ).toReal) ≤ ∫ x, f (μ.rnDeriv ν x).toReal ∂ν`. -/\nlemma mul_le_integral_rnDeriv_of_ac [IsFiniteMeasure μ] [IsFiniteMeasure ν]\n    (hf_cvx : ConvexOn ℝ (Ici 0) f) (hf_cont : ContinuousWithinAt f (Ici 0) 0)\n    (hf_int : Integrable (fun x ↦ f (μ.rnDeriv ν x).toReal) ν) (hμν : μ ≪ ν) :\n    (ν univ).toReal * f ((μ univ).toReal / (ν univ).toReal)\n      ≤ ∫ x, f (μ.rnDeriv ν x).toReal ∂ν := by\n  by_cases hν : ν = 0\n  · simp [hν]\n  have : NeZero ν := ⟨hν⟩\n  let μ' := (ν univ)⁻¹ • μ\n  let ν' := (ν univ)⁻¹ • ν\n  have : IsFiniteMeasure μ' := μ.smul_finite (by simp [hν])\n  have hμν' : μ' ≪ ν' := hμν.smul _\n  have h_rnDeriv_eq : μ'.rnDeriv ν' =ᵐ[ν] μ.rnDeriv ν := by\n    have h1' : μ'.rnDeriv ν' =ᵐ[ν'] (ν univ)⁻¹ • μ.rnDeriv ν' :=\n      Measure.rnDeriv_smul_left_of_ne_top' (μ := ν') (ν := μ) (by simp [hν])\n    have h1 : μ'.rnDeriv ν' =ᵐ[ν] (ν univ)⁻¹ • μ.rnDeriv ν' := by\n      rwa [Measure.ae_smul_measure_eq] at h1'\n      simp\n    have h2 : μ.rnDeriv ν' =ᵐ[ν] (ν univ)⁻¹⁻¹ • μ.rnDeriv ν :=\n      Measure.rnDeriv_smul_right_of_ne_top' (μ := ν) (ν := μ) (by simp) (by simp [hν])\n    filter_upwards [h1, h2] with x h1 h2\n    rw [h1, Pi.smul_apply, smul_eq_mul, h2]\n    simp only [inv_inv, Pi.smul_apply, smul_eq_mul]\n    rw [← mul_assoc, ENNReal.inv_mul_cancel, one_mul]\n    · simp [hν]\n    · simp\n  have h_eq : ∫ x, f (μ'.rnDeriv ν' x).toReal ∂ν'\n      = (ν univ).toReal⁻¹ * ∫ x, f ((μ.rnDeriv ν x).toReal) ∂ν := by\n    rw [integral_smul_measure, smul_eq_mul, ENNReal.toReal_inv]\n    congr 1\n    refine integral_congr_ae ?_\n    filter_upwards [h_rnDeriv_eq] with x hx\n    rw [hx]\n  have h : f (μ' univ).toReal ≤ ∫ x, f (μ'.rnDeriv ν' x).toReal ∂ν' :=\n    le_integral_rnDeriv_of_ac hf_cvx hf_cont ?_ hμν'\n  swap\n  · refine Integrable.smul_measure ?_ (by simp [hν])\n    refine (integrable_congr ?_).mpr hf_int\n    filter_upwards [h_rnDeriv_eq] with x hx\n    rw [hx]\n  rw [h_eq, mul_comm, ← div_le_iff₀, div_eq_inv_mul, inv_inv] at h\n  · convert h\n    · simp only [div_eq_inv_mul, Measure.smul_apply, smul_eq_mul, ENNReal.toReal_mul,\n      ENNReal.toReal_inv, μ']\n  · simp [ENNReal.toReal_pos_iff, hν]\n\n"}
