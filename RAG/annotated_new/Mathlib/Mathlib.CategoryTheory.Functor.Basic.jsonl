{"name":"CategoryTheory.Functor.map_comp","module":"Mathlib.CategoryTheory.Functor.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nself : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (self.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (self.map f) (self.map g))","decl":"/-- `Functor C D` represents a functor between categories `C` and `D`.\n\nTo apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.\n\nThe axiom `map_id` expresses preservation of identities, and\n`map_comp` expresses functoriality. -/\n@[stacks 001B]\nstructure Functor (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] (D : Type u‚ÇÇ) [Category.{v‚ÇÇ} D]\n    extends Prefunctor C D : Type max v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ where\n  /-- A functor preserves identity morphisms. -/\n  map_id : ‚àÄ X : C, map (ùüô X) = ùüô (obj X) := by aesop_cat\n  /-- A functor preserves composition. -/\n  map_comp : ‚àÄ {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z), map (f ‚â´ g) = map f ‚â´ map g := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Functor.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : SizeOf C\ninst‚úù : SizeOf D\ntoPrefunctor : Prefunctor C D\nmap_id : autoParam (‚àÄ (X : C), Eq (toPrefunctor.map (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.CategoryStruct.id (toPrefunctor.obj X))) _auto‚úù\nmap_comp : autoParam (‚àÄ {X Y Z : C} (f : Quiver.Hom X Y) (g : Quiver.Hom Y Z), Eq (toPrefunctor.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (toPrefunctor.map f) (toPrefunctor.map g))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { toPrefunctor := toPrefunctor, map_id := map_id, map_comp := map_comp }) (HAdd.hAdd 1 (SizeOf.sizeOf toPrefunctor))","decl":"/-- `Functor C D` represents a functor between categories `C` and `D`.\n\nTo apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.\n\nThe axiom `map_id` expresses preservation of identities, and\n`map_comp` expresses functoriality. -/\n@[stacks 001B]\nstructure Functor (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] (D : Type u‚ÇÇ) [Category.{v‚ÇÇ} D]\n    extends Prefunctor C D : Type max v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ where\n  /-- A functor preserves identity morphisms. -/\n  map_id : ‚àÄ X : C, map (ùüô X) = ùüô (obj X) := by aesop_cat\n  /-- A functor preserves composition. -/\n  map_comp : ‚àÄ {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z), map (f ‚â´ g) = map f ‚â´ map g := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.mk.inj","module":"Mathlib.CategoryTheory.Functor.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ntoPrefunctor‚úù : Prefunctor C D\nmap_id‚úù : autoParam (‚àÄ (X : C), Eq (toPrefunctor‚úù.map (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.CategoryStruct.id (toPrefunctor‚úù.obj X))) _auto‚úù\nmap_comp‚úù : autoParam (‚àÄ {X Y Z : C} (f : Quiver.Hom X Y) (g : Quiver.Hom Y Z), Eq (toPrefunctor‚úù.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (toPrefunctor‚úù.map f) (toPrefunctor‚úù.map g))) _auto‚úù\ntoPrefunctor : Prefunctor C D\nmap_id : autoParam (‚àÄ (X : C), Eq (toPrefunctor.map (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.CategoryStruct.id (toPrefunctor.obj X))) _auto‚úù\nmap_comp : autoParam (‚àÄ {X Y Z : C} (f : Quiver.Hom X Y) (g : Quiver.Hom Y Z), Eq (toPrefunctor.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (toPrefunctor.map f) (toPrefunctor.map g))) _auto‚úù\nx‚úù : Eq { toPrefunctor := toPrefunctor‚úù, map_id := map_id‚úù, map_comp := map_comp‚úù } { toPrefunctor := toPrefunctor, map_id := map_id, map_comp := map_comp }\n‚ä¢ Eq toPrefunctor‚úù toPrefunctor","decl":"/-- `Functor C D` represents a functor between categories `C` and `D`.\n\nTo apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.\n\nThe axiom `map_id` expresses preservation of identities, and\n`map_comp` expresses functoriality. -/\n@[stacks 001B]\nstructure Functor (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] (D : Type u‚ÇÇ) [Category.{v‚ÇÇ} D]\n    extends Prefunctor C D : Type max v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ where\n  /-- A functor preserves identity morphisms. -/\n  map_id : ‚àÄ X : C, map (ùüô X) = ùüô (obj X) := by aesop_cat\n  /-- A functor preserves composition. -/\n  map_comp : ‚àÄ {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z), map (f ‚â´ g) = map f ‚â´ map g := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.mk.injEq","module":"Mathlib.CategoryTheory.Functor.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ntoPrefunctor‚úù : Prefunctor C D\nmap_id‚úù : autoParam (‚àÄ (X : C), Eq (toPrefunctor‚úù.map (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.CategoryStruct.id (toPrefunctor‚úù.obj X))) _auto‚úù\nmap_comp‚úù : autoParam (‚àÄ {X Y Z : C} (f : Quiver.Hom X Y) (g : Quiver.Hom Y Z), Eq (toPrefunctor‚úù.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (toPrefunctor‚úù.map f) (toPrefunctor‚úù.map g))) _auto‚úù\ntoPrefunctor : Prefunctor C D\nmap_id : autoParam (‚àÄ (X : C), Eq (toPrefunctor.map (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.CategoryStruct.id (toPrefunctor.obj X))) _auto‚úù\nmap_comp : autoParam (‚àÄ {X Y Z : C} (f : Quiver.Hom X Y) (g : Quiver.Hom Y Z), Eq (toPrefunctor.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (toPrefunctor.map f) (toPrefunctor.map g))) _auto‚úù\n‚ä¢ Eq (Eq { toPrefunctor := toPrefunctor‚úù, map_id := map_id‚úù, map_comp := map_comp‚úù } { toPrefunctor := toPrefunctor, map_id := map_id, map_comp := map_comp }) (Eq toPrefunctor‚úù toPrefunctor)","decl":"/-- `Functor C D` represents a functor between categories `C` and `D`.\n\nTo apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.\n\nThe axiom `map_id` expresses preservation of identities, and\n`map_comp` expresses functoriality. -/\n@[stacks 001B]\nstructure Functor (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] (D : Type u‚ÇÇ) [Category.{v‚ÇÇ} D]\n    extends Prefunctor C D : Type max v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ where\n  /-- A functor preserves identity morphisms. -/\n  map_id : ‚àÄ X : C, map (ùüô X) = ùüô (obj X) := by aesop_cat\n  /-- A functor preserves composition. -/\n  map_comp : ‚àÄ {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z), map (f ‚â´ g) = map f ‚â´ map g := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.map_id","module":"Mathlib.CategoryTheory.Functor.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nself : CategoryTheory.Functor C D\nX : C\n‚ä¢ Eq (self.map (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.CategoryStruct.id (self.obj X))","decl":"/-- `Functor C D` represents a functor between categories `C` and `D`.\n\nTo apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.\n\nThe axiom `map_id` expresses preservation of identities, and\n`map_comp` expresses functoriality. -/\n@[stacks 001B]\nstructure Functor (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] (D : Type u‚ÇÇ) [Category.{v‚ÇÇ} D]\n    extends Prefunctor C D : Type max v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ where\n  /-- A functor preserves identity morphisms. -/\n  map_id : ‚àÄ X : C, map (ùüô X) = ùüô (obj X) := by aesop_cat\n  /-- A functor preserves composition. -/\n  map_comp : ‚àÄ {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z), map (f ‚â´ g) = map f ‚â´ map g := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.map_comp_assoc","module":"Mathlib.CategoryTheory.Functor.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u_1, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{u_2, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nW : D\nh : Quiver.Hom (F.obj Z) W\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (F.map f) (CategoryTheory.CategoryStruct.comp (F.map g) h))","decl":"lemma Functor.map_comp_assoc {C : Type u‚ÇÅ} [Category C] {D : Type u‚ÇÇ} [Category D] (F : C ‚•§ D)\n    {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) {W : D} (h : F.obj Z ‚ü∂ W) :\n    (F.map (f ‚â´ g)) ‚â´ h = F.map f ‚â´ F.map g ‚â´ h := by\n  rw [F.map_comp, Category.assoc]\n\n"}
{"name":"CategoryTheory.Functor.id_obj","module":"Mathlib.CategoryTheory.Functor.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq ((CategoryTheory.Functor.id C).obj X) X","decl":"@[simp]\ntheorem id_obj (X : C) : (ùü≠ C).obj X = X := rfl\n\n"}
{"name":"CategoryTheory.Functor.id_map","module":"Mathlib.CategoryTheory.Functor.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Functor.id C).map f) f","decl":"@[simp]\ntheorem id_map {X Y : C} (f : X ‚ü∂ Y) : (ùü≠ C).map f = f := rfl\n\n"}
{"name":"CategoryTheory.Functor.comp_obj","module":"Mathlib.CategoryTheory.Functor.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nX : C\n‚ä¢ Eq ((F.comp G).obj X) (G.obj (F.obj X))","decl":"/-- `F ‚ãô G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).\n-/\n@[simps obj]\ndef comp (F : C ‚•§ D) (G : D ‚•§ E) : C ‚•§ E where\n  obj X := G.obj (F.obj X)\n  map f := G.map (F.map f)\n  map_comp := by intros; dsimp; rw [F.map_comp, G.map_comp]\n\n"}
{"name":"CategoryTheory.Functor.comp_map","module":"Mathlib.CategoryTheory.Functor.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((F.comp G).map f) (G.map (F.map f))","decl":"@[simp]\ntheorem comp_map (F : C ‚•§ D) (G : D ‚•§ E) {X Y : C} (f : X ‚ü∂ Y) :\n    (F ‚ãô G).map f = G.map (F.map f) := rfl\n\n-- These are not simp lemmas because rewriting along equalities between functors\n-- is not necessarily a good idea.\n-- Natural isomorphisms are also provided in `Whiskering.lean`.\n"}
{"name":"CategoryTheory.Functor.comp_id","module":"Mathlib.CategoryTheory.Functor.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (F.comp (CategoryTheory.Functor.id D)) F","decl":"protected theorem comp_id (F : C ‚•§ D) : F ‚ãô ùü≠ D = F := by cases F; rfl\n\n"}
{"name":"CategoryTheory.Functor.id_comp","module":"Mathlib.CategoryTheory.Functor.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\n‚ä¢ Eq ((CategoryTheory.Functor.id C).comp F) F","decl":"protected theorem id_comp (F : C ‚•§ D) : ùü≠ C ‚ãô F = F := by cases F; rfl\n\n"}
{"name":"CategoryTheory.Functor.map_dite","module":"Mathlib.CategoryTheory.Functor.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : C\nP : Prop\ninst‚úù : Decidable P\nf : P ‚Üí Quiver.Hom X Y\ng : Not P ‚Üí Quiver.Hom X Y\n‚ä¢ Eq (F.map (dite P (fun h => f h) fun h => g h)) (dite P (fun h => F.map (f h)) fun h => F.map (g h))","decl":"@[simp]\ntheorem map_dite (F : C ‚•§ D) {X Y : C} {P : Prop} [Decidable P]\n    (f : P ‚Üí (X ‚ü∂ Y)) (g : ¬¨P ‚Üí (X ‚ü∂ Y)) :\n    F.map (if h : P then f h else g h) = if h : P then F.map (f h) else F.map (g h) := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.toPrefunctor_comp","module":"Mathlib.CategoryTheory.Functor.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\n‚ä¢ Eq (F.comp G.toPrefunctor) (F.comp G).toPrefunctor","decl":"@[simp]\ntheorem toPrefunctor_comp (F : C ‚•§ D) (G : D ‚•§ E) :\n    F.toPrefunctor.comp G.toPrefunctor = (F ‚ãô G).toPrefunctor := rfl\n\n"}
