{"name":"Compactum.instFaithfulForget","module":"Mathlib.Topology.Category.Compactum","initialProofState":"‚ä¢ Compactum.forget.Faithful","decl":"instance : forget.Faithful :=\n  show (Monad.forget _).Faithful from inferInstance\n\n"}
{"name":"Compactum.instHasLimits","module":"Mathlib.Topology.Category.Compactum","initialProofState":"‚ä¢ CategoryTheory.Limits.HasLimits Compactum","decl":"instance : HasLimits Compactum :=\n  hasLimits_of_hasLimits_createsLimits forget\n\n"}
{"name":"Compactum.str_incl","module":"Mathlib.Topology.Category.Compactum","initialProofState":"X : Compactum\nx : X.A\n‚ä¢ Eq (X.str (X.incl x)) x","decl":"@[simp]\ntheorem str_incl (X : Compactum) (x : X) : X.str (X.incl x) = x := by\n  change ((Œ≤ ).Œ∑.app _ ‚â´ X.a) _ = _\n  rw [Monad.Algebra.unit]\n  rfl\n\n"}
{"name":"Compactum.str_hom_commute","module":"Mathlib.Topology.Category.Compactum","initialProofState":"X Y : Compactum\nf : Quiver.Hom X Y\nxs : Ultrafilter X.A\n‚ä¢ Eq (f.f (X.str xs)) (Y.str (Ultrafilter.map f.f xs))","decl":"@[simp]\ntheorem str_hom_commute (X Y : Compactum) (f : X ‚ü∂ Y) (xs : Ultrafilter X) :\n    f (X.str xs) = Y.str (map f xs) := by\n  change (X.a ‚â´ f.f) _ = _\n  rw [‚Üê f.h]\n  rfl\n\n"}
{"name":"Compactum.join_distrib","module":"Mathlib.Topology.Category.Compactum","initialProofState":"X : Compactum\nuux : Ultrafilter (Ultrafilter X.A)\n‚ä¢ Eq (X.str (X.join uux)) (X.str (Ultrafilter.map X.str uux))","decl":"@[simp]\ntheorem join_distrib (X : Compactum) (uux : Ultrafilter (Ultrafilter X)) :\n    X.str (X.join uux) = X.str (map X.str uux) := by\n  change ((Œ≤ ).Œº.app _ ‚â´ X.a) _ = _\n  rw [Monad.Algebra.assoc]\n  rfl\n\n-- Porting note: changes to X.A from X since Lean can't see through X to X.A below\n"}
{"name":"Compactum.isClosed_iff","module":"Mathlib.Topology.Category.Compactum","initialProofState":"X : Compactum\nS : Set X.A\n‚ä¢ Iff (IsClosed S) (‚àÄ (F : Ultrafilter X.A), Membership.mem F S ‚Üí Membership.mem S (X.str F))","decl":"theorem isClosed_iff {X : Compactum} (S : Set X) :\n    IsClosed S ‚Üî ‚àÄ F : Ultrafilter X, S ‚àà F ‚Üí X.str F ‚àà S := by\n  rw [‚Üê isOpen_compl_iff]\n  constructor\n  ¬∑ intro cond F h\n    by_contra c\n    specialize cond F c\n    rw [compl_mem_iff_not_mem] at cond\n    contradiction\n  ¬∑ intro h1 F h2\n    specialize h1 F\n    cases' F.mem_or_compl_mem S with h h\n    exacts [absurd (h1 h) h2, h]\n\n"}
{"name":"Compactum.instCompactSpaceA","module":"Mathlib.Topology.Category.Compactum","initialProofState":"X : Compactum\n‚ä¢ CompactSpace X.A","decl":"instance {X : Compactum} : CompactSpace X := by\n  constructor\n  rw [isCompact_iff_ultrafilter_le_nhds]\n  intro F _\n  refine ‚ü®X.str F, by tauto, ?_‚ü©\n  rw [le_nhds_iff]\n  intro S h1 h2\n  exact h2 F h1\n\n"}
{"name":"Compactum.isClosed_cl","module":"Mathlib.Topology.Category.Compactum","initialProofState":"X : Compactum\nA : Set X.A\n‚ä¢ IsClosed (Compactum.cl A)","decl":"theorem isClosed_cl {X : Compactum} (A : Set X) : IsClosed (cl A) := by\n  rw [isClosed_iff]\n  intro F hF\n  exact cl_cl _ ‚ü®F, hF, rfl‚ü©\n\n"}
{"name":"Compactum.str_eq_of_le_nhds","module":"Mathlib.Topology.Category.Compactum","initialProofState":"X : Compactum\nF : Ultrafilter X.A\nx : X.A\na‚úù : LE.le (‚ÜëF) (nhds x)\n‚ä¢ Eq (X.str F) x","decl":"theorem str_eq_of_le_nhds {X : Compactum} (F : Ultrafilter X) (x : X) : ‚ÜëF ‚â§ ùìù x ‚Üí X.str F = x := by\n  -- Notation to be used in this proof.\n  let fsu := Finset (Set (Ultrafilter X))\n  let ssu := Set (Set (Ultrafilter X))\n  let Œπ : fsu ‚Üí ssu := fun x ‚Ü¶ ‚Üëx\n  let T0 : ssu := { S | ‚àÉ A ‚àà F, S = basic A }\n  let AA := X.str ‚Åª¬π' {x}\n  let T1 := insert AA T0\n  let T2 := finiteInterClosure T1\n  intro cond\n  -- If F contains a closed set A, then x is contained in A.\n  have claim1 : ‚àÄ A : Set X, IsClosed A ‚Üí A ‚àà F ‚Üí x ‚àà A := by\n    intro A hA h\n    by_contra H\n    rw [le_nhds_iff] at cond\n    specialize cond A·∂ú H hA.isOpen_compl\n    rw [Ultrafilter.mem_coe, Ultrafilter.compl_mem_iff_not_mem] at cond\n    contradiction\n  -- If A ‚àà F, then x ‚àà cl A.\n  have claim2 : ‚àÄ A : Set X, A ‚àà F ‚Üí x ‚àà cl A := by\n    intro A hA\n    exact claim1 (cl A) (isClosed_cl A) (mem_of_superset hA (subset_cl A))\n  -- T0 is closed under intersections.\n  have claim3 : ‚àÄ (S1) (_ : S1 ‚àà T0) (S2) (_ : S2 ‚àà T0), S1 ‚à© S2 ‚àà T0 := by\n    rintro S1 ‚ü®S1, hS1, rfl‚ü© S2 ‚ü®S2, hS2, rfl‚ü©\n    exact ‚ü®S1 ‚à© S2, inter_mem hS1 hS2, by simp [basic_inter]‚ü©\n  -- For every S ‚àà T0, the intersection AA ‚à© S is nonempty.\n  have claim4 : ‚àÄ S ‚àà T0, (AA ‚à© S).Nonempty := by\n    rintro S ‚ü®S, hS, rfl‚ü©\n    rcases claim2 _ hS with ‚ü®G, hG, hG2‚ü©\n    exact ‚ü®G, hG2, hG‚ü©\n  -- Every element of T0 is nonempty.\n  have claim5 : ‚àÄ S ‚àà T0, Set.Nonempty S := by\n    rintro S ‚ü®S, hS, rfl‚ü©\n    exact ‚ü®F, hS‚ü©\n  -- Every element of T2 is nonempty.\n  have claim6 : ‚àÄ S ‚àà T2, Set.Nonempty S := by\n    suffices ‚àÄ S ‚àà T2, S ‚àà T0 ‚à® ‚àÉ Q ‚àà T0, S = AA ‚à© Q by\n      intro S hS\n      cases' this _ hS with h h\n      ¬∑ exact claim5 S h\n      ¬∑ rcases h with ‚ü®Q, hQ, rfl‚ü©\n        exact claim4 Q hQ\n    intro S hS\n    apply finiteInterClosure_insert\n    ¬∑ constructor\n      ¬∑ use Set.univ\n        refine ‚ü®Filter.univ_sets _, ?_‚ü©\n        ext\n        refine ‚ü®?_, by tauto‚ü©\n        ¬∑ intro\n          apply Filter.univ_sets\n      ¬∑ exact claim3\n    ¬∑ exact hS\n  -- It suffices to show that the intersection of any finite subset of T1 is nonempty.\n  suffices ‚àÄ F : fsu, ‚ÜëF ‚äÜ T1 ‚Üí (‚ãÇ‚ÇÄ Œπ F).Nonempty by\n    obtain ‚ü®G, h1‚ü© := Ultrafilter.exists_ultrafilter_of_finite_inter_nonempty _ this\n    have c1 : X.join G = F := Ultrafilter.coe_le_coe.1 fun P hP => h1 (Or.inr ‚ü®P, hP, rfl‚ü©)\n    have c2 : G.map X.str = X.incl x := by\n      refine Ultrafilter.coe_le_coe.1 fun P hP => ?_\n      apply mem_of_superset (h1 (Or.inl rfl))\n      rintro x ‚ü®rfl‚ü©\n      exact hP\n    simp [‚Üê c1, c2]\n  -- Finish...\n  intro T hT\n  refine claim6 _ (finiteInter_mem (.finiteInterClosure_finiteInter _) _ ?_)\n  intro t ht\n  exact finiteInterClosure.basic (@hT t ht)\n\n"}
{"name":"Compactum.le_nhds_of_str_eq","module":"Mathlib.Topology.Category.Compactum","initialProofState":"X : Compactum\nF : Ultrafilter X.A\nx : X.A\na‚úù : Eq (X.str F) x\n‚ä¢ LE.le (‚ÜëF) (nhds x)","decl":"theorem le_nhds_of_str_eq {X : Compactum} (F : Ultrafilter X) (x : X) : X.str F = x ‚Üí ‚ÜëF ‚â§ ùìù x :=\n  fun h => le_nhds_iff.mpr fun s hx hs => hs _ <| by rwa [h]\n\n-- All the hard work above boils down to this `T2Space` instance.\n"}
{"name":"Compactum.instT2SpaceA","module":"Mathlib.Topology.Category.Compactum","initialProofState":"X : Compactum\n‚ä¢ T2Space X.A","decl":"instance {X : Compactum} : T2Space X := by\n  rw [t2_iff_ultrafilter]\n  intro _ _ F hx hy\n  rw [‚Üê str_eq_of_le_nhds _ _ hx, ‚Üê str_eq_of_le_nhds _ _ hy]\n\n"}
{"name":"Compactum.lim_eq_str","module":"Mathlib.Topology.Category.Compactum","initialProofState":"X : Compactum\nF : Ultrafilter X.A\n‚ä¢ Eq F.lim (X.str F)","decl":"/-- The structure map of a compactum actually computes limits. -/\ntheorem lim_eq_str {X : Compactum} (F : Ultrafilter X) : F.lim = X.str F := by\n  rw [Ultrafilter.lim_eq_iff_le_nhds, le_nhds_iff]\n  tauto\n\n"}
{"name":"Compactum.cl_eq_closure","module":"Mathlib.Topology.Category.Compactum","initialProofState":"X : Compactum\nA : Set X.A\n‚ä¢ Eq (Compactum.cl A) (closure A)","decl":"theorem cl_eq_closure {X : Compactum} (A : Set X) : cl A = closure A := by\n  ext\n  rw [mem_closure_iff_ultrafilter]\n  constructor\n  ¬∑ rintro ‚ü®F, h1, h2‚ü©\n    exact ‚ü®F, h1, le_nhds_of_str_eq _ _ h2‚ü©\n  ¬∑ rintro ‚ü®F, h1, h2‚ü©\n    exact ‚ü®F, h1, str_eq_of_le_nhds _ _ h2‚ü©\n\n"}
{"name":"Compactum.continuous_of_hom","module":"Mathlib.Topology.Category.Compactum","initialProofState":"X Y : Compactum\nf : Quiver.Hom X Y\n‚ä¢ Continuous f.f","decl":"/-- Any morphism of compacta is continuous. -/\ntheorem continuous_of_hom {X Y : Compactum} (f : X ‚ü∂ Y) : Continuous f := by\n  rw [continuous_iff_ultrafilter]\n  intro x g h\n  rw [Tendsto, ‚Üê coe_map]\n  apply le_nhds_of_str_eq\n  rw [‚Üê str_hom_commute, str_eq_of_le_nhds _ x _]\n  apply h\n\n"}
{"name":"compactumToCompHaus.full","module":"Mathlib.Topology.Category.Compactum","initialProofState":"‚ä¢ compactumToCompHaus.Full","decl":"/-- The functor `compactumToCompHaus` is full. -/\ninstance full : compactumToCompHaus.{u}.Full where\n  map_surjective f := ‚ü®Compactum.homOfContinuous f.1 f.2, rfl‚ü©\n\n"}
{"name":"compactumToCompHaus.faithful","module":"Mathlib.Topology.Category.Compactum","initialProofState":"‚ä¢ compactumToCompHaus.Faithful","decl":"/-- The functor `compactumToCompHaus` is faithful. -/\ninstance faithful : compactumToCompHaus.Faithful where\n  -- Porting note: this used to be obviously (though it consumed a bit of memory)\n  map_injective := by\n    intro _ _ _ _ h\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` gets confused by coercion using forget.\n    apply Monad.Algebra.Hom.ext\n    apply congrArg (fun f => f.toFun) h\n\n"}
{"name":"compactumToCompHaus.essSurj","module":"Mathlib.Topology.Category.Compactum","initialProofState":"‚ä¢ compactumToCompHaus.EssSurj","decl":"/-- The functor `compactumToCompHaus` is essentially surjective. -/\ninstance essSurj : compactumToCompHaus.EssSurj :=\n  { mem_essImage := fun X => ‚ü®Compactum.ofTopologicalSpace X, ‚ü®isoOfTopologicalSpace‚ü©‚ü© }\n\n"}
{"name":"compactumToCompHaus.isEquivalence","module":"Mathlib.Topology.Category.Compactum","initialProofState":"‚ä¢ compactumToCompHaus.IsEquivalence","decl":"/-- The functor `compactumToCompHaus` is an equivalence of categories. -/\ninstance isEquivalence : compactumToCompHaus.IsEquivalence where\n\n"}
