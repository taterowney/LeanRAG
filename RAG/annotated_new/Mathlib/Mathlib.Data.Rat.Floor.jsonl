{"name":"Rat.floor_def'","module":"Mathlib.Data.Rat.Floor","initialProofState":"a : Rat\n⊢ Eq a.floor (HDiv.hDiv a.num ↑a.den)","decl":"protected theorem floor_def' (a : ℚ) : a.floor = a.num / a.den := by\n  rw [Rat.floor]\n  split\n  · next h => simp [h]\n  · next => rfl\n\n"}
{"name":"Rat.le_floor","module":"Mathlib.Data.Rat.Floor","initialProofState":"z : Int\nr : Rat\n⊢ Iff (LE.le z r.floor) (LE.le (↑z) r)","decl":"protected theorem le_floor {z : ℤ} : ∀ {r : ℚ}, z ≤ Rat.floor r ↔ (z : ℚ) ≤ r\n  | ⟨n, d, h, c⟩ => by\n    simp only [Rat.floor_def']\n    rw [mk'_eq_divInt]\n    have h' := Int.ofNat_lt.2 (Nat.pos_of_ne_zero h)\n    conv =>\n      rhs\n      rw [intCast_eq_divInt, Rat.divInt_le_divInt zero_lt_one h', mul_one]\n    exact Int.le_ediv_iff_mul_le h'\n\n"}
{"name":"Rat.floor_def","module":"Mathlib.Data.Rat.Floor","initialProofState":"q : Rat\n⊢ Eq (Int.floor q) (HDiv.hDiv q.num ↑q.den)","decl":"protected theorem floor_def {q : ℚ} : ⌊q⌋ = q.num / q.den := Rat.floor_def' q\n\n"}
{"name":"Rat.ceil_def","module":"Mathlib.Data.Rat.Floor","initialProofState":"q : Rat\n⊢ Eq (Int.ceil q) (Neg.neg (HDiv.hDiv (Neg.neg q.num) ↑q.den))","decl":"protected theorem ceil_def (q : ℚ) : ⌈q⌉ = -(-q.num / ↑q.den) := by\n  change -⌊-q⌋ = _\n  rw [Rat.floor_def, num_neg_eq_neg_num, den_neg_eq_den]\n\n\n"}
{"name":"Rat.floor_intCast_div_natCast","module":"Mathlib.Data.Rat.Floor","initialProofState":"n : Int\nd : Nat\n⊢ Eq (Int.floor (HDiv.hDiv ↑n ↑d)) (HDiv.hDiv n ↑d)","decl":"@[norm_cast]\ntheorem floor_intCast_div_natCast (n : ℤ) (d : ℕ) : ⌊(↑n / ↑d : ℚ)⌋ = n / (↑d : ℤ) := by\n  rw [Rat.floor_def]\n  obtain rfl | hd := eq_zero_or_pos (a := d)\n  · simp\n  set q := (n : ℚ) / d with q_eq\n  obtain ⟨c, n_eq_c_mul_num, d_eq_c_mul_denom⟩ : ∃ c, n = c * q.num ∧ (d : ℤ) = c * q.den := by\n    rw [q_eq]\n    exact mod_cast @Rat.exists_eq_mul_div_num_and_eq_mul_div_den n d (mod_cast hd.ne')\n  rw [n_eq_c_mul_num, d_eq_c_mul_denom]\n  refine (Int.mul_ediv_mul_of_pos _ _ <| pos_of_mul_pos_left ?_ <| Int.natCast_nonneg q.den).symm\n  rwa [← d_eq_c_mul_denom, Int.natCast_pos]\n\n"}
{"name":"Rat.ceil_intCast_div_natCast","module":"Mathlib.Data.Rat.Floor","initialProofState":"n : Int\nd : Nat\n⊢ Eq (Int.ceil (HDiv.hDiv ↑n ↑d)) (Neg.neg (HDiv.hDiv (Neg.neg n) ↑d))","decl":"@[norm_cast]\ntheorem ceil_intCast_div_natCast (n : ℤ) (d : ℕ) : ⌈(↑n / ↑d : ℚ)⌉ = -((-n) / (↑d : ℤ)) := by\n  conv_lhs => rw [← neg_neg ⌈_⌉, ← floor_neg]\n  rw [← neg_div, ← Int.cast_neg, floor_intCast_div_natCast]\n\n"}
{"name":"Rat.floor_natCast_div_natCast","module":"Mathlib.Data.Rat.Floor","initialProofState":"n d : Nat\n⊢ Eq (Int.floor (HDiv.hDiv ↑n ↑d)) (HDiv.hDiv ↑n ↑d)","decl":"@[norm_cast]\ntheorem floor_natCast_div_natCast (n d : ℕ) : ⌊(↑n / ↑d : ℚ)⌋ = n / d :=\n  floor_intCast_div_natCast n d\n\n"}
{"name":"Rat.ceil_natCast_div_natCast","module":"Mathlib.Data.Rat.Floor","initialProofState":"n d : Nat\n⊢ Eq (Int.ceil (HDiv.hDiv ↑n ↑d)) (Neg.neg (HDiv.hDiv (Neg.neg ↑n) ↑d))","decl":"@[norm_cast]\ntheorem ceil_natCast_div_natCast (n d : ℕ) : ⌈(↑n / ↑d : ℚ)⌉ = -((-n) / d) :=\n  ceil_intCast_div_natCast n d\n\n"}
{"name":"Rat.natFloor_natCast_div_natCast","module":"Mathlib.Data.Rat.Floor","initialProofState":"n d : Nat\n⊢ Eq (Nat.floor (HDiv.hDiv ↑n ↑d)) (HDiv.hDiv n d)","decl":"@[norm_cast]\ntheorem natFloor_natCast_div_natCast (n d : ℕ) : ⌊(↑n / ↑d : ℚ)⌋₊ = n / d := by\n  rw [← Int.ofNat_inj, Int.natCast_floor_eq_floor (by positivity)]\n  push_cast\n  exact floor_intCast_div_natCast n d\n\n"}
{"name":"Rat.floor_cast","module":"Mathlib.Data.Rat.Floor","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : FloorRing α\nx : Rat\n⊢ Eq (Int.floor ↑x) (Int.floor x)","decl":"@[simp, norm_cast]\ntheorem floor_cast (x : ℚ) : ⌊(x : α)⌋ = ⌊x⌋ :=\n  floor_eq_iff.2 (mod_cast floor_eq_iff.1 (Eq.refl ⌊x⌋))\n\n"}
{"name":"Rat.ceil_cast","module":"Mathlib.Data.Rat.Floor","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : FloorRing α\nx : Rat\n⊢ Eq (Int.ceil ↑x) (Int.ceil x)","decl":"@[simp, norm_cast]\ntheorem ceil_cast (x : ℚ) : ⌈(x : α)⌉ = ⌈x⌉ := by\n  rw [← neg_inj, ← floor_neg, ← floor_neg, ← Rat.cast_neg, Rat.floor_cast]\n\n"}
{"name":"Rat.round_cast","module":"Mathlib.Data.Rat.Floor","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : FloorRing α\nx : Rat\n⊢ Eq (round ↑x) (round x)","decl":"@[simp, norm_cast]\ntheorem round_cast (x : ℚ) : round (x : α) = round x := by\n  have : ((x + 1 / 2 : ℚ) : α) = x + 1 / 2 := by simp\n  rw [round_eq, round_eq, ← this, floor_cast]\n\n"}
{"name":"Rat.cast_fract","module":"Mathlib.Data.Rat.Floor","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : FloorRing α\nx : Rat\n⊢ Eq (↑(Int.fract x)) (Int.fract ↑x)","decl":"@[simp, norm_cast]\ntheorem cast_fract (x : ℚ) : (↑(fract x) : α) = fract (x : α) := by\n  simp only [fract, cast_sub, cast_intCast, floor_cast]\n\n"}
{"name":"Rat.isNat_intFloor","module":"Mathlib.Data.Rat.Floor","initialProofState":"R : Type u_2\ninst✝¹ : LinearOrderedRing R\ninst✝ : FloorRing R\nr : R\nm : Nat\na✝ : Mathlib.Meta.NormNum.IsNat r m\n⊢ Mathlib.Meta.NormNum.IsNat (Int.floor r) m","decl":"theorem isNat_intFloor {R} [LinearOrderedRing R] [FloorRing R] (r : R) (m : ℕ) :\n    IsNat r m → IsNat ⌊r⌋ m := by rintro ⟨⟨⟩⟩; exact ⟨by simp⟩\n\n"}
{"name":"Rat.isInt_intFloor","module":"Mathlib.Data.Rat.Floor","initialProofState":"R : Type u_2\ninst✝¹ : LinearOrderedRing R\ninst✝ : FloorRing R\nr : R\nm : Int\na✝ : Mathlib.Meta.NormNum.IsInt r m\n⊢ Mathlib.Meta.NormNum.IsInt (Int.floor r) m","decl":"theorem isInt_intFloor {R} [LinearOrderedRing R] [FloorRing R] (r : R) (m : ℤ) :\n    IsInt r m → IsInt ⌊r⌋ m := by rintro ⟨⟨⟩⟩; exact ⟨by simp⟩\n\n"}
{"name":"Rat.isInt_intFloor_ofIsRat","module":"Mathlib.Data.Rat.Floor","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : FloorRing α\nr : α\nn : Int\nd : Nat\na✝ : Mathlib.Meta.NormNum.IsRat r n d\n⊢ Mathlib.Meta.NormNum.IsInt (Int.floor r) (HDiv.hDiv n ↑d)","decl":"theorem isInt_intFloor_ofIsRat (r : α) (n : ℤ) (d : ℕ) :\n    IsRat r n d → IsInt ⌊r⌋ (n / d) := by\n  rintro ⟨inv, rfl⟩\n  constructor\n  simp only [invOf_eq_inv, ← div_eq_mul_inv, Int.cast_id]\n  rw [← floor_intCast_div_natCast n d, ← floor_cast (α := α), Rat.cast_div,\n    cast_intCast, cast_natCast]\n\n"}
{"name":"Rat.isNat_intCeil","module":"Mathlib.Data.Rat.Floor","initialProofState":"R : Type u_2\ninst✝¹ : LinearOrderedRing R\ninst✝ : FloorRing R\nr : R\nm : Nat\na✝ : Mathlib.Meta.NormNum.IsNat r m\n⊢ Mathlib.Meta.NormNum.IsNat (Int.ceil r) m","decl":"theorem isNat_intCeil {R} [LinearOrderedRing R] [FloorRing R] (r : R) (m : ℕ) :\n    IsNat r m → IsNat ⌈r⌉ m := by rintro ⟨⟨⟩⟩; exact ⟨by simp⟩\n\n"}
{"name":"Rat.isInt_intCeil","module":"Mathlib.Data.Rat.Floor","initialProofState":"R : Type u_2\ninst✝¹ : LinearOrderedRing R\ninst✝ : FloorRing R\nr : R\nm : Int\na✝ : Mathlib.Meta.NormNum.IsInt r m\n⊢ Mathlib.Meta.NormNum.IsInt (Int.ceil r) m","decl":"theorem isInt_intCeil {R} [LinearOrderedRing R] [FloorRing R] (r : R) (m : ℤ) :\n    IsInt r m → IsInt ⌈r⌉ m := by rintro ⟨⟨⟩⟩; exact ⟨by simp⟩\n\n"}
{"name":"Rat.isInt_intCeil_ofIsRat","module":"Mathlib.Data.Rat.Floor","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedField α\ninst✝ : FloorRing α\nr : α\nn : Int\nd : Nat\na✝ : Mathlib.Meta.NormNum.IsRat r n d\n⊢ Mathlib.Meta.NormNum.IsInt (Int.ceil r) (Neg.neg (HDiv.hDiv (Neg.neg n) ↑d))","decl":"theorem isInt_intCeil_ofIsRat (r : α) (n : ℤ) (d : ℕ) :\n    IsRat r n d → IsInt ⌈r⌉ (-(-n / d)) := by\n  rintro ⟨inv, rfl⟩\n  constructor\n  simp only [invOf_eq_inv, ← div_eq_mul_inv, Int.cast_id]\n  rw [← ceil_intCast_div_natCast n d, ← ceil_cast (α := α), Rat.cast_div,\n    cast_intCast, cast_natCast]\n\n"}
{"name":"Int.mod_nat_eq_sub_mul_floor_rat_div","module":"Mathlib.Data.Rat.Floor","initialProofState":"n : Int\nd : Nat\n⊢ Eq (HMod.hMod n ↑d) (HSub.hSub n (HMul.hMul (↑d) (Int.floor (HDiv.hDiv ↑n ↑d))))","decl":"theorem Int.mod_nat_eq_sub_mul_floor_rat_div {n : ℤ} {d : ℕ} : n % d = n - d * ⌊(n : ℚ) / d⌋ := by\n  rw [eq_sub_of_add_eq <| Int.emod_add_ediv n d, Rat.floor_intCast_div_natCast]\n\n"}
{"name":"Nat.coprime_sub_mul_floor_rat_div_of_coprime","module":"Mathlib.Data.Rat.Floor","initialProofState":"n d : Nat\nn_coprime_d : n.Coprime d\n⊢ (HSub.hSub (↑n) (HMul.hMul (↑d) (Int.floor (HDiv.hDiv ↑n ↑d)))).natAbs.Coprime d","decl":"theorem Nat.coprime_sub_mul_floor_rat_div_of_coprime {n d : ℕ} (n_coprime_d : n.Coprime d) :\n    ((n : ℤ) - d * ⌊(n : ℚ) / d⌋).natAbs.Coprime d := by\n  have : (n : ℤ) % d = n - d * ⌊(n : ℚ) / d⌋ := Int.mod_nat_eq_sub_mul_floor_rat_div\n  rw [← this]\n  have : d.Coprime n := n_coprime_d.symm\n  rwa [Nat.Coprime, Nat.gcd_rec] at this\n\n"}
{"name":"Rat.num_lt_succ_floor_mul_den","module":"Mathlib.Data.Rat.Floor","initialProofState":"q : Rat\n⊢ LT.lt q.num (HMul.hMul (HAdd.hAdd (Int.floor q) 1) ↑q.den)","decl":"theorem num_lt_succ_floor_mul_den (q : ℚ) : q.num < (⌊q⌋ + 1) * q.den := by\n  suffices (q.num : ℚ) < (⌊q⌋ + 1) * q.den from mod_cast this\n  suffices (q.num : ℚ) < (q - fract q + 1) * q.den by\n    have : (⌊q⌋ : ℚ) = q - fract q := eq_sub_of_add_eq <| floor_add_fract q\n    rwa [this]\n  suffices (q.num : ℚ) < q.num + (1 - fract q) * q.den by\n    have : (q - fract q + 1) * q.den = q.num + (1 - fract q) * q.den := by\n      calc\n        (q - fract q + 1) * q.den = (q + (1 - fract q)) * q.den := by ring\n        _ = q * q.den + (1 - fract q) * q.den := by rw [add_mul]\n        _ = q.num + (1 - fract q) * q.den := by simp\n    rwa [this]\n  suffices 0 < (1 - fract q) * q.den by\n    rw [← sub_lt_iff_lt_add']\n    simpa\n  have : 0 < 1 - fract q := by\n    have : fract q < 1 := fract_lt_one q\n    have : 0 + fract q < 1 := by simp [this]\n    rwa [lt_sub_iff_add_lt]\n  exact mul_pos this (by exact mod_cast q.pos)\n\n"}
{"name":"Rat.fract_inv_num_lt_num_of_pos","module":"Mathlib.Data.Rat.Floor","initialProofState":"q : Rat\nq_pos : LT.lt 0 q\n⊢ LT.lt (Int.fract (Inv.inv q)).num q.num","decl":"theorem fract_inv_num_lt_num_of_pos {q : ℚ} (q_pos : 0 < q) : (fract q⁻¹).num < q.num := by\n  -- we know that the numerator must be positive\n  have q_num_pos : 0 < q.num := Rat.num_pos.mpr q_pos\n  -- we will work with the absolute value of the numerator, which is equal to the numerator\n  have q_num_abs_eq_q_num : (q.num.natAbs : ℤ) = q.num := Int.natAbs_of_nonneg q_num_pos.le\n  set q_inv : ℚ := q.den / q.num with q_inv_def\n  have q_inv_eq : q⁻¹ = q_inv := by rw [q_inv_def, inv_def', divInt_eq_div, Int.cast_natCast]\n  suffices (q_inv - ⌊q_inv⌋).num < q.num by rwa [q_inv_eq]\n  suffices ((q.den - q.num * ⌊q_inv⌋ : ℚ) / q.num).num < q.num by\n    field_simp [q_inv, this, ne_of_gt q_num_pos]\n  suffices (q.den : ℤ) - q.num * ⌊q_inv⌋ < q.num by\n    -- use that `q.num` and `q.den` are coprime to show that the numerator stays unreduced\n    have : ((q.den - q.num * ⌊q_inv⌋ : ℚ) / q.num).num = q.den - q.num * ⌊q_inv⌋ := by\n      suffices ((q.den : ℤ) - q.num * ⌊q_inv⌋).natAbs.Coprime q.num.natAbs from\n        mod_cast Rat.num_div_eq_of_coprime q_num_pos this\n      have tmp := Nat.coprime_sub_mul_floor_rat_div_of_coprime q.reduced.symm\n      simpa only [Nat.cast_natAbs, abs_of_nonneg q_num_pos.le] using tmp\n    rwa [this]\n  -- to show the claim, start with the following inequality\n  have q_inv_num_denom_ineq : q⁻¹.num - ⌊q⁻¹⌋ * q⁻¹.den < q⁻¹.den := by\n    have : q⁻¹.num < (⌊q⁻¹⌋ + 1) * q⁻¹.den := Rat.num_lt_succ_floor_mul_den q⁻¹\n    have : q⁻¹.num < ⌊q⁻¹⌋ * q⁻¹.den + q⁻¹.den := by rwa [right_distrib, one_mul] at this\n    rwa [← sub_lt_iff_lt_add'] at this\n  -- use that `q.num` and `q.den` are coprime to show that q_inv is the unreduced reciprocal\n  -- of `q`\n  have : q_inv.num = q.den ∧ q_inv.den = q.num.natAbs := by\n    have coprime_q_denom_q_num : q.den.Coprime q.num.natAbs := q.reduced.symm\n    have : Int.natAbs q.den = q.den := by simp\n    rw [← this] at coprime_q_denom_q_num\n    rw [q_inv_def]\n    constructor\n    · exact mod_cast Rat.num_div_eq_of_coprime q_num_pos coprime_q_denom_q_num\n    · suffices (((q.den : ℚ) / q.num).den : ℤ) = q.num.natAbs by exact mod_cast this\n      rw [q_num_abs_eq_q_num]\n      exact mod_cast Rat.den_div_eq_of_coprime q_num_pos coprime_q_denom_q_num\n  rwa [q_inv_eq, this.left, this.right, q_num_abs_eq_q_num, mul_comm] at q_inv_num_denom_ineq\n\n"}
