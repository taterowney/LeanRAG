{"name":"List.TProd.fst_mk","module":"Mathlib.Data.Prod.TProd","initialProofState":"ι : Type u\nα : ι → Type v\ni : ι\nl : List ι\nf : (i : ι) → α i\n⊢ Eq (List.TProd.mk (List.cons i l) f).1 (f i)","decl":"@[simp]\ntheorem fst_mk (i : ι) (l : List ι) (f : ∀ i, α i) : (TProd.mk (i :: l) f).1 = f i :=\n  rfl\n\n"}
{"name":"List.TProd.snd_mk","module":"Mathlib.Data.Prod.TProd","initialProofState":"ι : Type u\nα : ι → Type v\ni : ι\nl : List ι\nf : (i : ι) → α i\n⊢ Eq (List.TProd.mk (List.cons i l) f).2 (List.TProd.mk l f)","decl":"@[simp]\ntheorem snd_mk (i : ι) (l : List ι) (f : ∀ i, α i) :\n    (TProd.mk.{u,v} (i :: l) f).2 = TProd.mk.{u,v} l f :=\n  rfl\n\n"}
{"name":"List.TProd.elim_self","module":"Mathlib.Data.Prod.TProd","initialProofState":"ι : Type u\nα : ι → Type v\ni : ι\nl : List ι\ninst✝ : DecidableEq ι\nv : List.TProd α (List.cons i l)\n⊢ Eq (v.elim ⋯) v.1","decl":"@[simp]\ntheorem elim_self (v : TProd α (i :: l)) : v.elim (l.mem_cons_self i) = v.1 := by simp [TProd.elim]\n\n"}
{"name":"List.TProd.elim_of_ne","module":"Mathlib.Data.Prod.TProd","initialProofState":"ι : Type u\nα : ι → Type v\ni j : ι\nl : List ι\ninst✝ : DecidableEq ι\nhj : Membership.mem (List.cons i l) j\nhji : Ne j i\nv : List.TProd α (List.cons i l)\n⊢ Eq (v.elim hj) (List.TProd.elim v.2 ⋯)","decl":"@[simp]\ntheorem elim_of_ne (hj : j ∈ i :: l) (hji : j ≠ i) (v : TProd α (i :: l)) :\n    v.elim hj = TProd.elim v.2 ((List.mem_cons.mp hj).resolve_left hji) := by simp [TProd.elim, hji]\n\n"}
{"name":"List.TProd.elim_of_mem","module":"Mathlib.Data.Prod.TProd","initialProofState":"ι : Type u\nα : ι → Type v\ni j : ι\nl : List ι\ninst✝ : DecidableEq ι\nhl : (List.cons i l).Nodup\nhj : Membership.mem l j\nv : List.TProd α (List.cons i l)\n⊢ Eq (v.elim ⋯) (List.TProd.elim v.2 hj)","decl":"@[simp]\ntheorem elim_of_mem (hl : (i :: l).Nodup) (hj : j ∈ l) (v : TProd α (i :: l)) :\n    v.elim (mem_cons_of_mem _ hj) = TProd.elim v.2 hj := by\n  apply elim_of_ne\n  rintro rfl\n  exact hl.not_mem hj\n\n"}
{"name":"List.TProd.elim_mk","module":"Mathlib.Data.Prod.TProd","initialProofState":"ι : Type u\nα : ι → Type v\ninst✝ : DecidableEq ι\nl : List ι\nf : (i : ι) → α i\ni : ι\nhi : Membership.mem l i\n⊢ Eq ((List.TProd.mk l f).elim hi) (f i)","decl":"theorem elim_mk : ∀ (l : List ι) (f : ∀ i, α i) {i : ι} (hi : i ∈ l), (TProd.mk l f).elim hi = f i\n  | i :: is, f, j, hj => by\n    by_cases hji : j = i\n    · subst hji\n      simp\n    · rw [TProd.elim_of_ne _ hji, snd_mk, elim_mk is]\n\n"}
{"name":"List.TProd.ext_iff","module":"Mathlib.Data.Prod.TProd","initialProofState":"ι : Type u\nα : ι → Type v\ninst✝ : DecidableEq ι\nl : List ι\nx✝ : l.Nodup\nv w : List.TProd α l\n⊢ Iff (Eq v w) (∀ (i : ι) (hi : Membership.mem l i), Eq (v.elim hi) (w.elim hi))","decl":"@[ext]\ntheorem ext :\n    ∀ {l : List ι} (_ : l.Nodup) {v w : TProd α l}\n      (_ : ∀ (i) (hi : i ∈ l), v.elim hi = w.elim hi), v = w\n  | [], _, v, w, _ => PUnit.ext v w\n  | i :: is, hl, v, w, hvw => by\n    apply Prod.ext\n    · rw [← elim_self v, hvw, elim_self]\n    refine ext (nodup_cons.mp hl).2 fun j hj => ?_\n    rw [← elim_of_mem hl, hvw, elim_of_mem hl]\n\n"}
{"name":"List.TProd.ext","module":"Mathlib.Data.Prod.TProd","initialProofState":"ι : Type u\nα : ι → Type v\ninst✝ : DecidableEq ι\nl : List ι\nx✝¹ : l.Nodup\nv w : List.TProd α l\nx✝ : ∀ (i : ι) (hi : Membership.mem l i), Eq (v.elim hi) (w.elim hi)\n⊢ Eq v w","decl":"@[ext]\ntheorem ext :\n    ∀ {l : List ι} (_ : l.Nodup) {v w : TProd α l}\n      (_ : ∀ (i) (hi : i ∈ l), v.elim hi = w.elim hi), v = w\n  | [], _, v, w, _ => PUnit.ext v w\n  | i :: is, hl, v, w, hvw => by\n    apply Prod.ext\n    · rw [← elim_self v, hvw, elim_self]\n    refine ext (nodup_cons.mp hl).2 fun j hj => ?_\n    rw [← elim_of_mem hl, hvw, elim_of_mem hl]\n\n"}
{"name":"List.TProd.mk_elim","module":"Mathlib.Data.Prod.TProd","initialProofState":"ι : Type u\nα : ι → Type v\nl : List ι\ninst✝ : DecidableEq ι\nhnd : l.Nodup\nh : ∀ (i : ι), Membership.mem l i\nv : List.TProd α l\n⊢ Eq (List.TProd.mk l (List.TProd.elim' h v)) v","decl":"theorem mk_elim (hnd : l.Nodup) (h : ∀ i, i ∈ l) (v : TProd α l) : TProd.mk l (v.elim' h) = v :=\n  TProd.ext hnd fun i hi => by simp [elim_mk]\n\n"}
{"name":"Set.mk_preimage_tprod","module":"Mathlib.Data.Prod.TProd","initialProofState":"ι : Type u\nα : ι → Type v\nl : List ι\nt : (i : ι) → Set (α i)\n⊢ Eq (Set.preimage (List.TProd.mk l) (Set.tprod l t)) ((setOf fun i => Membership.mem l i).pi t)","decl":"theorem mk_preimage_tprod :\n    ∀ (l : List ι) (t : ∀ i, Set (α i)), TProd.mk l ⁻¹' Set.tprod l t = { i | i ∈ l }.pi t\n  | [], t => by simp [Set.tprod]\n  | i :: l, t => by\n    ext f\n    have h : TProd.mk l f ∈ Set.tprod l t ↔ ∀ i : ι, i ∈ l → f i ∈ t i := by\n      change f ∈ TProd.mk l ⁻¹' Set.tprod l t ↔ f ∈ { x | x ∈ l }.pi t\n      rw [mk_preimage_tprod l t]\n\n    -- `simp [Set.TProd, TProd.mk, this]` can close this goal but is slow.\n    rw [Set.tprod, TProd.mk, mem_preimage, mem_pi, prod_mk_mem_set_prod_eq]\n    simp_rw [mem_setOf_eq, mem_cons]\n    rw [forall_eq_or_imp, and_congr_right_iff]\n    exact fun _ => h\n\n"}
{"name":"Set.elim_preimage_pi","module":"Mathlib.Data.Prod.TProd","initialProofState":"ι : Type u\nα : ι → Type v\ninst✝ : DecidableEq ι\nl : List ι\nhnd : l.Nodup\nh : ∀ (i : ι), Membership.mem l i\nt : (i : ι) → Set (α i)\n⊢ Eq (Set.preimage (List.TProd.elim' h) (Set.univ.pi t)) (Set.tprod l t)","decl":"theorem elim_preimage_pi [DecidableEq ι] {l : List ι} (hnd : l.Nodup) (h : ∀ i, i ∈ l)\n    (t : ∀ i, Set (α i)) : TProd.elim' h ⁻¹' pi univ t = Set.tprod l t := by\n  have h2 : { i | i ∈ l } = univ := by\n    ext i\n    simp [h]\n  rw [← h2, ← mk_preimage_tprod, preimage_preimage]\n  simp only [TProd.mk_elim hnd h]\n  dsimp\n\n"}
