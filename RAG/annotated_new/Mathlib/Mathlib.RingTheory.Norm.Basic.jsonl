{"name":"Algebra.PowerBasis.norm_gen_eq_coeff_zero_minpoly","module":"Mathlib.RingTheory.Norm.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\npb : PowerBasis R S\n⊢ Eq ((Algebra.norm R) pb.gen) (HMul.hMul (HPow.hPow (-1) pb.dim) ((minpoly R pb.gen).coeff 0))","decl":"/-- Given `pb : PowerBasis K S`, then the norm of `pb.gen` is\n`(-1) ^ pb.dim * coeff (minpoly K pb.gen) 0`. -/\ntheorem PowerBasis.norm_gen_eq_coeff_zero_minpoly (pb : PowerBasis R S) :\n    norm R pb.gen = (-1) ^ pb.dim * coeff (minpoly R pb.gen) 0 := by\n  rw [norm_eq_matrix_det pb.basis, det_eq_sign_charpoly_coeff, charpoly_leftMulMatrix,\n    Fintype.card_fin]\n\n"}
{"name":"Algebra.PowerBasis.norm_gen_eq_prod_roots","module":"Mathlib.RingTheory.Norm.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\ninst✝² : Algebra R S\nF : Type u_6\ninst✝¹ : Field F\ninst✝ : Algebra R F\npb : PowerBasis R S\nhf : Polynomial.Splits (algebraMap R F) (minpoly R pb.gen)\n⊢ Eq ((algebraMap R F) ((Algebra.norm R) pb.gen)) ((minpoly R pb.gen).aroots F).prod","decl":"/-- Given `pb : PowerBasis R S`, then the norm of `pb.gen` is\n`((minpoly R pb.gen).aroots F).prod`. -/\ntheorem PowerBasis.norm_gen_eq_prod_roots [Algebra R F] (pb : PowerBasis R S)\n    (hf : (minpoly R pb.gen).Splits (algebraMap R F)) :\n    algebraMap R F (norm R pb.gen) = ((minpoly R pb.gen).aroots F).prod := by\n  haveI := Module.nontrivial R F\n  have := minpoly.monic pb.isIntegral_gen\n  rw [PowerBasis.norm_gen_eq_coeff_zero_minpoly, ← pb.natDegree_minpoly, RingHom.map_mul,\n    ← coeff_map,\n    prod_roots_eq_coeff_zero_of_monic_of_splits (this.map _) ((splits_id_iff_splits _).2 hf),\n    this.natDegree_map, map_pow, ← mul_assoc, ← mul_pow]\n  simp only [map_neg, _root_.map_one, neg_mul, neg_neg, one_pow, one_mul]\n\n"}
{"name":"Algebra.norm_zero","module":"Mathlib.RingTheory.Norm.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : Ring S\ninst✝³ : Algebra R S\ninst✝² : Nontrivial S\ninst✝¹ : Module.Free R S\ninst✝ : Module.Finite R S\n⊢ Eq ((Algebra.norm R) 0) 0","decl":"@[simp]\ntheorem norm_zero [Nontrivial S] [Module.Free R S] [Module.Finite R S] : norm R (0 : S) = 0 := by\n  nontriviality\n  rw [norm_apply, coe_lmul_eq_mul, map_zero, LinearMap.det_zero' (Module.Free.chooseBasis R S)]\n\n"}
{"name":"Algebra.norm_eq_zero_iff","module":"Mathlib.RingTheory.Norm.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : Ring S\ninst✝⁴ : Algebra R S\ninst✝³ : IsDomain R\ninst✝² : IsDomain S\ninst✝¹ : Module.Free R S\ninst✝ : Module.Finite R S\nx : S\n⊢ Iff (Eq ((Algebra.norm R) x) 0) (Eq x 0)","decl":"@[simp]\ntheorem norm_eq_zero_iff [IsDomain R] [IsDomain S] [Module.Free R S] [Module.Finite R S] {x : S} :\n    norm R x = 0 ↔ x = 0 := by\n  constructor\n  swap\n  · rintro rfl; exact norm_zero\n  · let b := Module.Free.chooseBasis R S\n    let decEq := Classical.decEq (Module.Free.ChooseBasisIndex R S)\n    rw [norm_eq_matrix_det b, ← Matrix.exists_mulVec_eq_zero_iff]\n    rintro ⟨v, v_ne, hv⟩\n    rw [← b.equivFun.apply_symm_apply v, b.equivFun_symm_apply, b.equivFun_apply,\n      leftMulMatrix_mulVec_repr] at hv\n    refine (mul_eq_zero.mp (b.ext_elem fun i => ?_)).resolve_right (show ∑ i, v i • b i ≠ 0 from ?_)\n    · simpa only [LinearEquiv.map_zero, Pi.zero_apply] using congr_fun hv i\n    · contrapose! v_ne with sum_eq\n      apply b.equivFun.symm.injective\n      rw [b.equivFun_symm_apply, sum_eq, LinearEquiv.map_zero]\n\n"}
{"name":"Algebra.norm_ne_zero_iff","module":"Mathlib.RingTheory.Norm.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : Ring S\ninst✝⁴ : Algebra R S\ninst✝³ : IsDomain R\ninst✝² : IsDomain S\ninst✝¹ : Module.Free R S\ninst✝ : Module.Finite R S\nx : S\n⊢ Iff (Ne ((Algebra.norm R) x) 0) (Ne x 0)","decl":"theorem norm_ne_zero_iff [IsDomain R] [IsDomain S] [Module.Free R S] [Module.Finite R S] {x : S} :\n    norm R x ≠ 0 ↔ x ≠ 0 := not_iff_not.mpr norm_eq_zero_iff\n\n"}
{"name":"Algebra.norm_eq_zero_iff'","module":"Mathlib.RingTheory.Norm.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : Ring S\ninst✝⁴ : Algebra R S\ninst✝³ : IsDomain R\ninst✝² : IsDomain S\ninst✝¹ : Module.Free R S\ninst✝ : Module.Finite R S\nx : S\n⊢ Iff (Eq (LinearMap.det ((LinearMap.mul R S) x)) 0) (Eq x 0)","decl":"/-- This is `Algebra.norm_eq_zero_iff` composed with `Algebra.norm_apply`. -/\n@[simp]\ntheorem norm_eq_zero_iff' [IsDomain R] [IsDomain S] [Module.Free R S] [Module.Finite R S] {x : S} :\n    LinearMap.det (LinearMap.mul R S x) = 0 ↔ x = 0 := norm_eq_zero_iff\n\n"}
{"name":"Algebra.norm_eq_zero_iff_of_basis","module":"Mathlib.RingTheory.Norm.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : Ring S\ninst✝³ : Algebra R S\nι : Type w\ninst✝² : Finite ι\ninst✝¹ : IsDomain R\ninst✝ : IsDomain S\nb : Basis ι R S\nx : S\n⊢ Iff (Eq ((Algebra.norm R) x) 0) (Eq x 0)","decl":"theorem norm_eq_zero_iff_of_basis [IsDomain R] [IsDomain S] (b : Basis ι R S) {x : S} :\n    Algebra.norm R x = 0 ↔ x = 0 := by\n  haveI : Module.Free R S := Module.Free.of_basis b\n  haveI : Module.Finite R S := Module.Finite.of_basis b\n  exact norm_eq_zero_iff\n\n"}
{"name":"Algebra.norm_ne_zero_iff_of_basis","module":"Mathlib.RingTheory.Norm.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : Ring S\ninst✝³ : Algebra R S\nι : Type w\ninst✝² : Finite ι\ninst✝¹ : IsDomain R\ninst✝ : IsDomain S\nb : Basis ι R S\nx : S\n⊢ Iff (Ne ((Algebra.norm R) x) 0) (Ne x 0)","decl":"theorem norm_ne_zero_iff_of_basis [IsDomain R] [IsDomain S] (b : Basis ι R S) {x : S} :\n    Algebra.norm R x ≠ 0 ↔ x ≠ 0 :=\n  not_iff_not.mpr (norm_eq_zero_iff_of_basis b)\n\n"}
{"name":"Algebra.norm_eq_norm_adjoin","module":"Mathlib.RingTheory.Norm.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : FiniteDimensional K L\ninst✝ : Algebra.IsSeparable K L\nx : L\n⊢ Eq ((Algebra.norm K) x) (HPow.hPow ((Algebra.norm K) (IntermediateField.AdjoinSimple.gen K x)) (Module.finrank (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin K (Singleton.singleton x)) x_1) L))","decl":"theorem norm_eq_norm_adjoin [FiniteDimensional K L] [Algebra.IsSeparable K L] (x : L) :\n    norm K x = norm K (AdjoinSimple.gen K x) ^ finrank K⟮x⟯ L := by\n  letI := Algebra.isSeparable_tower_top_of_isSeparable K K⟮x⟯ L\n  let pbL := Field.powerBasisOfFiniteOfSeparable K⟮x⟯ L\n  let pbx := IntermediateField.adjoin.powerBasis (Algebra.IsSeparable.isIntegral K x)\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [← AdjoinSimple.algebraMap_gen K x, norm_eq_matrix_det (pbx.basis.smulTower pbL.basis) _,\n    smulTower_leftMulMatrix_algebraMap, det_blockDiagonal, norm_eq_matrix_det pbx.basis]\n  simp only [Finset.card_fin, Finset.prod_const]\n  congr\n  rw [← PowerBasis.finrank, AdjoinSimple.algebraMap_gen K x]\n\n"}
{"name":"IntermediateField.AdjoinSimple.norm_gen_eq_one","module":"Mathlib.RingTheory.Norm.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx : L\nhx : Not (IsIntegral K x)\n⊢ Eq ((Algebra.norm K) (IntermediateField.AdjoinSimple.gen K x)) 1","decl":"theorem _root_.IntermediateField.AdjoinSimple.norm_gen_eq_one {x : L} (hx : ¬IsIntegral K x) :\n    norm K (AdjoinSimple.gen K x) = 1 := by\n  rw [norm_eq_one_of_not_exists_basis]\n  contrapose! hx\n  obtain ⟨s, ⟨b⟩⟩ := hx\n  refine .of_mem_of_fg K⟮x⟯.toSubalgebra ?_ x ?_\n  · exact (Submodule.fg_iff_finiteDimensional _).mpr (.of_fintype_basis b)\n  · exact IntermediateField.subset_adjoin K _ (Set.mem_singleton x)\n\n"}
{"name":"IntermediateField.AdjoinSimple.norm_gen_eq_prod_roots","module":"Mathlib.RingTheory.Norm.Basic","initialProofState":"K : Type u_4\nL : Type u_5\nF : Type u_6\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Field F\ninst✝¹ : Algebra K L\ninst✝ : Algebra K F\nx : L\nhf : Polynomial.Splits (algebraMap K F) (minpoly K x)\n⊢ Eq ((algebraMap K F) ((Algebra.norm K) (IntermediateField.AdjoinSimple.gen K x))) ((minpoly K x).aroots F).prod","decl":"theorem _root_.IntermediateField.AdjoinSimple.norm_gen_eq_prod_roots (x : L)\n    (hf : (minpoly K x).Splits (algebraMap K F)) :\n    (algebraMap K F) (norm K (AdjoinSimple.gen K x)) =\n      ((minpoly K x).aroots F).prod := by\n  have injKxL := (algebraMap K⟮x⟯ L).injective\n  by_cases hx : IsIntegral K x; swap\n  · simp [minpoly.eq_zero hx, IntermediateField.AdjoinSimple.norm_gen_eq_one hx, aroots_def]\n  rw [← adjoin.powerBasis_gen hx, PowerBasis.norm_gen_eq_prod_roots] <;>\n    rw [adjoin.powerBasis_gen hx, ← minpoly.algebraMap_eq injKxL] <;>\n    simp only [AdjoinSimple.algebraMap_gen _ _, hf]\n\n"}
{"name":"Algebra.norm_eq_prod_embeddings_gen","module":"Mathlib.RingTheory.Norm.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\ninst✝² : Algebra R S\nF : Type u_6\ninst✝¹ : Field F\ninst✝ : Algebra R F\npb : PowerBasis R S\nhE : Polynomial.Splits (algebraMap R F) (minpoly R pb.gen)\nhfx : IsSeparable R pb.gen\n⊢ Eq ((algebraMap R F) ((Algebra.norm R) pb.gen)) (Finset.univ.prod fun σ => σ pb.gen)","decl":"theorem norm_eq_prod_embeddings_gen [Algebra R F] (pb : PowerBasis R S)\n    (hE : (minpoly R pb.gen).Splits (algebraMap R F)) (hfx : IsSeparable R pb.gen) :\n    algebraMap R F (norm R pb.gen) =\n      (@Finset.univ _ (PowerBasis.AlgHom.fintype pb)).prod fun σ => σ pb.gen := by\n  letI := Classical.decEq F\n  rw [PowerBasis.norm_gen_eq_prod_roots pb hE]\n  rw [@Fintype.prod_equiv (S →ₐ[R] F) _ _ (PowerBasis.AlgHom.fintype pb) _ _ pb.liftEquiv'\n    (fun σ => σ pb.gen) (fun x => x) ?_]\n  · rw [Finset.prod_mem_multiset, Finset.prod_eq_multiset_prod, Multiset.toFinset_val,\n      Multiset.dedup_eq_self.mpr, Multiset.map_id]\n    · exact nodup_roots hfx.map\n    · intro x; rfl\n  · intro σ; simp only [PowerBasis.liftEquiv'_apply_coe]\n\n"}
{"name":"Algebra.norm_eq_prod_roots","module":"Mathlib.RingTheory.Norm.Basic","initialProofState":"K : Type u_4\nL : Type u_5\nF : Type u_6\ninst✝⁶ : Field K\ninst✝⁵ : Field L\ninst✝⁴ : Field F\ninst✝³ : Algebra K L\ninst✝² : Algebra K F\ninst✝¹ : Algebra.IsSeparable K L\ninst✝ : FiniteDimensional K L\nx : L\nhF : Polynomial.Splits (algebraMap K F) (minpoly K x)\n⊢ Eq ((algebraMap K F) ((Algebra.norm K) x)) (HPow.hPow ((minpoly K x).aroots F).prod (Module.finrank (Subtype fun x_1 => Membership.mem (IntermediateField.adjoin K (Singleton.singleton x)) x_1) L))","decl":"theorem norm_eq_prod_roots [Algebra.IsSeparable K L] [FiniteDimensional K L] {x : L}\n    (hF : (minpoly K x).Splits (algebraMap K F)) :\n    algebraMap K F (norm K x) =\n      ((minpoly K x).aroots F).prod ^ finrank K⟮x⟯ L := by\n  rw [norm_eq_norm_adjoin K x, map_pow, IntermediateField.AdjoinSimple.norm_gen_eq_prod_roots _ hF]\n\n"}
{"name":"Algebra.prod_embeddings_eq_finrank_pow","module":"Mathlib.RingTheory.Norm.Basic","initialProofState":"K : Type u_4\nL : Type u_5\nF : Type u_6\ninst✝¹¹ : Field K\ninst✝¹⁰ : Field L\ninst✝⁹ : Field F\ninst✝⁸ : Algebra K L\ninst✝⁷ : Algebra K F\nE : Type u_7\ninst✝⁶ : Field E\ninst✝⁵ : Algebra K E\ninst✝⁴ : Algebra L F\ninst✝³ : IsScalarTower K L F\ninst✝² : IsAlgClosed E\ninst✝¹ : Algebra.IsSeparable K F\ninst✝ : FiniteDimensional K F\npb : PowerBasis K L\n⊢ Eq (Finset.univ.prod fun σ => σ ((algebraMap L F) pb.gen)) (HPow.hPow (Finset.univ.prod fun σ => σ pb.gen) (Module.finrank L F))","decl":"theorem prod_embeddings_eq_finrank_pow [Algebra L F] [IsScalarTower K L F] [IsAlgClosed E]\n    [Algebra.IsSeparable K F] [FiniteDimensional K F] (pb : PowerBasis K L) :\n    ∏ σ : F →ₐ[K] E, σ (algebraMap L F pb.gen) =\n      ((@Finset.univ _ (PowerBasis.AlgHom.fintype pb)).prod\n        fun σ : L →ₐ[K] E => σ pb.gen) ^ finrank L F := by\n  haveI : FiniteDimensional L F := FiniteDimensional.right K L F\n  haveI : Algebra.IsSeparable L F := Algebra.isSeparable_tower_top_of_isSeparable K L F\n  letI : Fintype (L →ₐ[K] E) := PowerBasis.AlgHom.fintype pb\n  rw [Fintype.prod_equiv algHomEquivSigma (fun σ : F →ₐ[K] E => _) fun σ => σ.1 pb.gen,\n    ← Finset.univ_sigma_univ, Finset.prod_sigma, ← Finset.prod_pow]\n  · refine Finset.prod_congr rfl fun σ _ => ?_\n    letI : Algebra L E := σ.toRingHom.toAlgebra\n    simp_rw [Finset.prod_const]\n    congr\n    exact AlgHom.card L F E\n  · intro σ\n    simp only [algHomEquivSigma, Equiv.coe_fn_mk, AlgHom.restrictDomain, AlgHom.comp_apply,\n      IsScalarTower.coe_toAlgHom']\n\n"}
{"name":"Algebra.norm_eq_prod_embeddings","module":"Mathlib.RingTheory.Norm.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝⁷ : Field K\ninst✝⁶ : Field L\ninst✝⁵ : Algebra K L\nE : Type u_7\ninst✝⁴ : Field E\ninst✝³ : Algebra K E\ninst✝² : FiniteDimensional K L\ninst✝¹ : Algebra.IsSeparable K L\ninst✝ : IsAlgClosed E\nx : L\n⊢ Eq ((algebraMap K E) ((Algebra.norm K) x)) (Finset.univ.prod fun σ => σ x)","decl":"/-- For `L/K` a finite separable extension of fields and `E` an algebraically closed extension\nof `K`, the norm (down to `K`) of an element `x` of `L` is equal to the product of the images\nof `x` over all the `K`-embeddings `σ` of `L` into `E`. -/\ntheorem norm_eq_prod_embeddings [FiniteDimensional K L] [Algebra.IsSeparable K L] [IsAlgClosed E]\n    (x : L) : algebraMap K E (norm K x) = ∏ σ : L →ₐ[K] E, σ x := by\n  have hx := Algebra.IsSeparable.isIntegral K x\n  rw [norm_eq_norm_adjoin K x, RingHom.map_pow, ← adjoin.powerBasis_gen hx,\n    norm_eq_prod_embeddings_gen E (adjoin.powerBasis hx) (IsAlgClosed.splits_codomain _)]\n  · exact (prod_embeddings_eq_finrank_pow L (L := K⟮x⟯) E (adjoin.powerBasis hx)).symm\n  · haveI := Algebra.isSeparable_tower_bot_of_isSeparable K K⟮x⟯ L\n    exact Algebra.IsSeparable.isSeparable K _\n\n"}
{"name":"Algebra.norm_eq_prod_automorphisms","module":"Mathlib.RingTheory.Norm.Basic","initialProofState":"K : Type u_4\nL : Type u_5\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : FiniteDimensional K L\ninst✝ : IsGalois K L\nx : L\n⊢ Eq ((algebraMap K L) ((Algebra.norm K) x)) (Finset.univ.prod fun σ => σ x)","decl":"theorem norm_eq_prod_automorphisms [FiniteDimensional K L] [IsGalois K L] (x : L) :\n    algebraMap K L (norm K x) = ∏ σ : L ≃ₐ[K] L, σ x := by\n  apply NoZeroSMulDivisors.algebraMap_injective L (AlgebraicClosure L)\n  rw [map_prod (algebraMap L (AlgebraicClosure L))]\n  rw [← Fintype.prod_equiv (Normal.algHomEquivAut K (AlgebraicClosure L) L)]\n  · rw [← norm_eq_prod_embeddings _ _ x, ← IsScalarTower.algebraMap_apply]\n  · intro σ\n    simp only [Normal.algHomEquivAut, AlgHom.restrictNormal', Equiv.coe_fn_mk,\n      AlgEquiv.coe_ofBijective, AlgHom.restrictNormal_commutes, id.map_eq_id, RingHom.id_apply]\n\n"}
{"name":"Algebra.isIntegral_norm","module":"Mathlib.RingTheory.Norm.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommRing R\nK : Type u_4\nL : Type u_5\ninst✝⁷ : Field K\ninst✝⁶ : Field L\ninst✝⁵ : Algebra K L\ninst✝⁴ : Algebra R L\ninst✝³ : Algebra R K\ninst✝² : IsScalarTower R K L\ninst✝¹ : Algebra.IsSeparable K L\ninst✝ : FiniteDimensional K L\nx : L\nhx : IsIntegral R x\n⊢ IsIntegral R ((Algebra.norm K) x)","decl":"theorem isIntegral_norm [Algebra R L] [Algebra R K] [IsScalarTower R K L] [Algebra.IsSeparable K L]\n    [FiniteDimensional K L] {x : L} (hx : IsIntegral R x) : IsIntegral R (norm K x) := by\n  have hx' : IsIntegral K x := hx.tower_top\n  rw [← isIntegral_algebraMap_iff (algebraMap K (AlgebraicClosure L)).injective, norm_eq_prod_roots]\n  · refine (IsIntegral.multiset_prod fun y hy => ?_).pow _\n    rw [mem_roots_map (minpoly.ne_zero hx')] at hy\n    use minpoly R x, minpoly.monic hx\n    rw [← aeval_def] at hy ⊢\n    exact minpoly.aeval_of_isScalarTower R x y hy\n  · apply IsAlgClosed.splits_codomain\n\n"}
{"name":"Algebra.norm_eq_of_algEquiv","module":"Mathlib.RingTheory.Norm.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\ninst✝² : Algebra R S\ninst✝¹ : Ring T\ninst✝ : Algebra R T\ne : AlgEquiv R S T\nx : S\n⊢ Eq ((Algebra.norm R) (e x)) ((Algebra.norm R) x)","decl":"lemma norm_eq_of_algEquiv [Ring T] [Algebra R T] (e : S ≃ₐ[R] T) (x) :\n    Algebra.norm R (e x) = Algebra.norm R x := by\n  simp_rw [Algebra.norm_apply, ← LinearMap.det_conj _ e.toLinearEquiv]; congr; ext; simp\n\n"}
{"name":"Algebra.norm_eq_of_ringEquiv","module":"Mathlib.RingTheory.Norm.Basic","initialProofState":"A : Type u_8\nB : Type u_9\nC : Type u_10\ninst✝⁴ : CommRing A\ninst✝³ : CommRing B\ninst✝² : Ring C\ninst✝¹ : Algebra A C\ninst✝ : Algebra B C\ne : RingEquiv A B\nhe : Eq ((algebraMap B C).comp ↑e) (algebraMap A C)\nx : C\n⊢ Eq (e ((Algebra.norm A) x)) ((Algebra.norm B) x)","decl":"lemma norm_eq_of_ringEquiv {A B C : Type*} [CommRing A] [CommRing B] [Ring C]\n    [Algebra A C] [Algebra B C] (e : A ≃+* B) (he : (algebraMap B C).comp e = algebraMap A C)\n    (x : C) :\n    e (Algebra.norm A x) = Algebra.norm B x := by\n  classical\n  by_cases h : ∃ s : Finset C, Nonempty (Basis s B C)\n  · obtain ⟨s, ⟨b⟩⟩ := h\n    letI : Algebra A B := RingHom.toAlgebra e\n    letI : IsScalarTower A B C := IsScalarTower.of_algebraMap_eq' he.symm\n    rw [Algebra.norm_eq_matrix_det b,\n      Algebra.norm_eq_matrix_det (b.mapCoeffs e.symm (by simp [Algebra.smul_def, ← he])),\n      e.map_det]\n    congr\n    ext i j\n    simp [leftMulMatrix_apply, LinearMap.toMatrix_apply]\n  rw [norm_eq_one_of_not_exists_basis _ h, norm_eq_one_of_not_exists_basis, _root_.map_one]\n  intro ⟨s, ⟨b⟩⟩\n  exact h ⟨s, ⟨b.mapCoeffs e (by simp [Algebra.smul_def, ← he])⟩⟩\n\n"}
{"name":"Algebra.norm_eq_of_equiv_equiv","module":"Mathlib.RingTheory.Norm.Basic","initialProofState":"A₁ : Type u_8\nB₁ : Type u_9\nA₂ : Type u_10\nB₂ : Type u_11\ninst✝⁵ : CommRing A₁\ninst✝⁴ : Ring B₁\ninst✝³ : CommRing A₂\ninst✝² : Ring B₂\ninst✝¹ : Algebra A₁ B₁\ninst✝ : Algebra A₂ B₂\ne₁ : RingEquiv A₁ A₂\ne₂ : RingEquiv B₁ B₂\nhe : Eq ((algebraMap A₂ B₂).comp ↑e₁) ((↑e₂).comp (algebraMap A₁ B₁))\nx : B₁\n⊢ Eq ((Algebra.norm A₁) x) (e₁.symm ((Algebra.norm A₂) (e₂ x)))","decl":"lemma norm_eq_of_equiv_equiv {A₁ B₁ A₂ B₂ : Type*} [CommRing A₁] [Ring B₁]\n    [CommRing A₂] [Ring B₂] [Algebra A₁ B₁] [Algebra A₂ B₂] (e₁ : A₁ ≃+* A₂) (e₂ : B₁ ≃+* B₂)\n    (he : RingHom.comp (algebraMap A₂ B₂) ↑e₁ = RingHom.comp ↑e₂ (algebraMap A₁ B₁)) (x) :\n    Algebra.norm A₁ x = e₁.symm (Algebra.norm A₂ (e₂ x)) := by\n  letI := (RingHom.comp (e₂ : B₁ →+* B₂) (algebraMap A₁ B₁)).toAlgebra' ?_\n  · let e' : B₁ ≃ₐ[A₁] B₂ := { e₂ with commutes' := fun _ ↦ rfl }\n    rw [← Algebra.norm_eq_of_ringEquiv e₁ he, ← Algebra.norm_eq_of_algEquiv e']\n    simp [e']\n  intros c x\n  apply e₂.symm.injective\n  simp only [RingHom.coe_comp, RingHom.coe_coe, Function.comp_apply, _root_.map_mul,\n    RingEquiv.symm_apply_apply, commutes]\n\n"}
