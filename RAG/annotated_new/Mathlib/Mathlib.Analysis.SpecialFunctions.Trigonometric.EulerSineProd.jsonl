{"name":"EulerSine.antideriv_cos_comp_const_mul","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.EulerSineProd","initialProofState":"z : Complex\nhz : Ne z 0\nx : Real\n⊢ HasDerivAt (fun y => HDiv.hDiv (Complex.sin (HMul.hMul (HMul.hMul 2 z) ↑y)) (HMul.hMul 2 z)) (Complex.cos (HMul.hMul (HMul.hMul 2 z) ↑x)) x","decl":"theorem antideriv_cos_comp_const_mul (hz : z ≠ 0) (x : ℝ) :\n    HasDerivAt (fun y : ℝ => Complex.sin (2 * z * y) / (2 * z)) (Complex.cos (2 * z * x)) x := by\n  have a : HasDerivAt (fun y : ℂ => y * (2 * z)) _ x := hasDerivAt_mul_const _\n  have b : HasDerivAt (Complex.sin ∘ fun y : ℂ => (y * (2 * z))) _ x :=\n    HasDerivAt.comp (x : ℂ) (Complex.hasDerivAt_sin (x * (2 * z))) a\n  have c := b.comp_ofReal.div_const (2 * z)\n  field_simp at c; simp only [fun y => mul_comm y (2 * z)] at c\n  exact c\n\n"}
{"name":"EulerSine.antideriv_sin_comp_const_mul","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.EulerSineProd","initialProofState":"z : Complex\nhz : Ne z 0\nx : Real\n⊢ HasDerivAt (fun y => HDiv.hDiv (Neg.neg (Complex.cos (HMul.hMul (HMul.hMul 2 z) ↑y))) (HMul.hMul 2 z)) (Complex.sin (HMul.hMul (HMul.hMul 2 z) ↑x)) x","decl":"theorem antideriv_sin_comp_const_mul (hz : z ≠ 0) (x : ℝ) :\n    HasDerivAt (fun y : ℝ => -Complex.cos (2 * z * y) / (2 * z)) (Complex.sin (2 * z * x)) x := by\n  have a : HasDerivAt (fun y : ℂ => y * (2 * z)) _ x := hasDerivAt_mul_const _\n  have b : HasDerivAt (Complex.cos ∘ fun y : ℂ => (y * (2 * z))) _ x :=\n    HasDerivAt.comp (x : ℂ) (Complex.hasDerivAt_cos (x * (2 * z))) a\n  have c := (b.comp_ofReal.div_const (2 * z)).neg\n  field_simp at c; simp only [fun y => mul_comm y (2 * z)] at c\n  exact c\n\n"}
{"name":"EulerSine.integral_cos_mul_cos_pow_aux","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.EulerSineProd","initialProofState":"z : Complex\nn : Nat\nhn : LE.le 2 n\nhz : Ne z 0\n⊢ Eq (intervalIntegral (fun x => HMul.hMul (Complex.cos (HMul.hMul (HMul.hMul 2 z) ↑x)) (HPow.hPow (↑(Real.cos x)) n)) 0 (HDiv.hDiv Real.pi 2) MeasureTheory.MeasureSpace.volume) (HMul.hMul (HDiv.hDiv (↑n) (HMul.hMul 2 z)) (intervalIntegral (fun x => HMul.hMul (HMul.hMul (Complex.sin (HMul.hMul (HMul.hMul 2 z) ↑x)) ↑(Real.sin x)) (HPow.hPow (↑(Real.cos x)) (HSub.hSub n 1))) 0 (HDiv.hDiv Real.pi 2) MeasureTheory.MeasureSpace.volume))","decl":"theorem integral_cos_mul_cos_pow_aux (hn : 2 ≤ n) (hz : z ≠ 0) :\n    (∫ x in (0 : ℝ)..π / 2, Complex.cos (2 * z * x) * (cos x : ℂ) ^ n) =\n      n / (2 * z) *\n        ∫ x in (0 : ℝ)..π / 2, Complex.sin (2 * z * x) * sin x * (cos x : ℂ) ^ (n - 1) := by\n  have der1 :\n    ∀ x : ℝ,\n      x ∈ uIcc 0 (π / 2) →\n        HasDerivAt (fun y : ℝ => (cos y : ℂ) ^ n) (-n * sin x * (cos x : ℂ) ^ (n - 1)) x := by\n    intro x _\n    have b : HasDerivAt (fun y : ℝ => (cos y : ℂ)) (-sin x) x := by\n      simpa using (hasDerivAt_cos x).ofReal_comp\n    convert HasDerivAt.comp x (hasDerivAt_pow _ _) b using 1\n    ring\n  convert (config := { sameFun := true })\n    integral_mul_deriv_eq_deriv_mul der1 (fun x _ => antideriv_cos_comp_const_mul hz x) _ _ using 2\n  · ext1 x; rw [mul_comm]\n  · rw [Complex.ofReal_zero, mul_zero, Complex.sin_zero, zero_div, mul_zero, sub_zero,\n      cos_pi_div_two, Complex.ofReal_zero, zero_pow (by positivity : n ≠ 0), zero_mul, zero_sub,\n      ← integral_neg, ← integral_const_mul]\n    refine integral_congr fun x _ => ?_\n    field_simp; ring\n  · apply Continuous.intervalIntegrable\n    exact\n      (continuous_const.mul (Complex.continuous_ofReal.comp continuous_sin)).mul\n        ((Complex.continuous_ofReal.comp continuous_cos).pow (n - 1))\n  · apply Continuous.intervalIntegrable\n    exact Complex.continuous_cos.comp (continuous_const.mul Complex.continuous_ofReal)\n\n"}
{"name":"EulerSine.integral_sin_mul_sin_mul_cos_pow_eq","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.EulerSineProd","initialProofState":"z : Complex\nn : Nat\nhn : LE.le 2 n\nhz : Ne z 0\n⊢ Eq (intervalIntegral (fun x => HMul.hMul (HMul.hMul (Complex.sin (HMul.hMul (HMul.hMul 2 z) ↑x)) ↑(Real.sin x)) (HPow.hPow (↑(Real.cos x)) (HSub.hSub n 1))) 0 (HDiv.hDiv Real.pi 2) MeasureTheory.MeasureSpace.volume) (HSub.hSub (HMul.hMul (HDiv.hDiv (↑n) (HMul.hMul 2 z)) (intervalIntegral (fun x => HMul.hMul (Complex.cos (HMul.hMul (HMul.hMul 2 z) ↑x)) (HPow.hPow (↑(Real.cos x)) n)) 0 (HDiv.hDiv Real.pi 2) MeasureTheory.MeasureSpace.volume)) (HMul.hMul (HDiv.hDiv (HSub.hSub (↑n) 1) (HMul.hMul 2 z)) (intervalIntegral (fun x => HMul.hMul (Complex.cos (HMul.hMul (HMul.hMul 2 z) ↑x)) (HPow.hPow (↑(Real.cos x)) (HSub.hSub n 2))) 0 (HDiv.hDiv Real.pi 2) MeasureTheory.MeasureSpace.volume)))","decl":"theorem integral_sin_mul_sin_mul_cos_pow_eq (hn : 2 ≤ n) (hz : z ≠ 0) :\n    (∫ x in (0 : ℝ)..π / 2, Complex.sin (2 * z * x) * sin x * (cos x : ℂ) ^ (n - 1)) =\n      (n / (2 * z) * ∫ x in (0 : ℝ)..π / 2, Complex.cos (2 * z * x) * (cos x : ℂ) ^ n) -\n        (n - 1) / (2 * z) *\n          ∫ x in (0 : ℝ)..π / 2, Complex.cos (2 * z * x) * (cos x : ℂ) ^ (n - 2) := by\n  have der1 :\n    ∀ x : ℝ,\n      x ∈ uIcc 0 (π / 2) →\n        HasDerivAt (fun y : ℝ => sin y * (cos y : ℂ) ^ (n - 1))\n          ((cos x : ℂ) ^ n - (n - 1) * (sin x : ℂ) ^ 2 * (cos x : ℂ) ^ (n - 2)) x := by\n    intro x _\n    have c := HasDerivAt.comp (x : ℂ) (hasDerivAt_pow (n - 1) _) (Complex.hasDerivAt_cos x)\n    convert ((Complex.hasDerivAt_sin x).mul c).comp_ofReal using 1\n    · ext1 y; simp only [Complex.ofReal_sin, Complex.ofReal_cos, Function.comp]\n    · simp only [Complex.ofReal_cos, Complex.ofReal_sin]\n      rw [mul_neg, mul_neg, ← sub_eq_add_neg, Function.comp_apply]\n      congr 1\n      · rw [← pow_succ', Nat.sub_add_cancel (by omega : 1 ≤ n)]\n      · have : ((n - 1 : ℕ) : ℂ) = (n : ℂ) - 1 := by\n          rw [Nat.cast_sub (one_le_two.trans hn), Nat.cast_one]\n        rw [Nat.sub_sub, this]\n        ring\n  convert\n    integral_mul_deriv_eq_deriv_mul der1 (fun x _ => antideriv_sin_comp_const_mul hz x) _ _ using 1\n  · refine integral_congr fun x _ => ?_\n    ring_nf\n  · -- now a tedious rearrangement of terms\n    -- gather into a single integral, and deal with continuity subgoals:\n    rw [sin_zero, cos_pi_div_two, Complex.ofReal_zero, zero_pow, zero_mul,\n      mul_zero, zero_mul, zero_mul, sub_zero, zero_sub, ←\n      integral_neg, ← integral_const_mul, ← integral_const_mul, ← integral_sub]\n    rotate_left\n    · apply Continuous.intervalIntegrable\n      exact\n        continuous_const.mul\n          ((Complex.continuous_cos.comp (continuous_const.mul Complex.continuous_ofReal)).mul\n            ((Complex.continuous_ofReal.comp continuous_cos).pow n))\n    · apply Continuous.intervalIntegrable\n      exact\n        continuous_const.mul\n          ((Complex.continuous_cos.comp (continuous_const.mul Complex.continuous_ofReal)).mul\n            ((Complex.continuous_ofReal.comp continuous_cos).pow (n - 2)))\n    · exact Nat.sub_ne_zero_of_lt hn\n    refine integral_congr fun x _ => ?_\n    dsimp only\n    -- get rid of real trig functions and divisions by 2 * z:\n    rw [Complex.ofReal_cos, Complex.ofReal_sin, Complex.sin_sq, ← mul_div_right_comm, ←\n      mul_div_right_comm, ← sub_div, mul_div, ← neg_div]\n    congr 1\n    have : Complex.cos x ^ n = Complex.cos x ^ (n - 2) * Complex.cos x ^ 2 := by\n      conv_lhs => rw [← Nat.sub_add_cancel hn, pow_add]\n    rw [this]\n    ring\n  · apply Continuous.intervalIntegrable\n    exact\n      ((Complex.continuous_ofReal.comp continuous_cos).pow n).sub\n        ((continuous_const.mul ((Complex.continuous_ofReal.comp continuous_sin).pow 2)).mul\n          ((Complex.continuous_ofReal.comp continuous_cos).pow (n - 2)))\n  · apply Continuous.intervalIntegrable\n    exact Complex.continuous_sin.comp (continuous_const.mul Complex.continuous_ofReal)\n\n"}
{"name":"EulerSine.integral_cos_mul_cos_pow","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.EulerSineProd","initialProofState":"z : Complex\nn : Nat\nhn : LE.le 2 n\nhz : Ne z 0\n⊢ Eq (HMul.hMul (HSub.hSub 1 (HDiv.hDiv (HMul.hMul 4 (HPow.hPow z 2)) (HPow.hPow (↑n) 2))) (intervalIntegral (fun x => HMul.hMul (Complex.cos (HMul.hMul (HMul.hMul 2 z) ↑x)) (HPow.hPow (↑(Real.cos x)) n)) 0 (HDiv.hDiv Real.pi 2) MeasureTheory.MeasureSpace.volume)) (HMul.hMul (HDiv.hDiv (HSub.hSub (↑n) 1) ↑n) (intervalIntegral (fun x => HMul.hMul (Complex.cos (HMul.hMul (HMul.hMul 2 z) ↑x)) (HPow.hPow (↑(Real.cos x)) (HSub.hSub n 2))) 0 (HDiv.hDiv Real.pi 2) MeasureTheory.MeasureSpace.volume))","decl":"/-- Note this also holds for `z = 0`, but we do not need this case for `sin_pi_mul_eq`. -/\ntheorem integral_cos_mul_cos_pow (hn : 2 ≤ n) (hz : z ≠ 0) :\n    (((1 : ℂ) - (4 : ℂ) * z ^ 2 / (n : ℂ) ^ 2) *\n      ∫ x in (0 : ℝ)..π / 2, Complex.cos (2 * z * x) * (cos x : ℂ) ^ n) =\n      (n - 1 : ℂ) / n *\n        ∫ x in (0 : ℝ)..π / 2, Complex.cos (2 * z * x) * (cos x : ℂ) ^ (n - 2) := by\n  have nne : (n : ℂ) ≠ 0 := by\n    contrapose! hn; rw [Nat.cast_eq_zero] at hn; rw [hn]; exact zero_lt_two\n  have := integral_cos_mul_cos_pow_aux hn hz\n  rw [integral_sin_mul_sin_mul_cos_pow_eq hn hz, sub_eq_neg_add, mul_add, ← sub_eq_iff_eq_add]\n    at this\n  convert congr_arg (fun u : ℂ => -u * (2 * z) ^ 2 / n ^ 2) this using 1 <;> field_simp <;> ring\n\n"}
{"name":"EulerSine.integral_cos_mul_cos_pow_even","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.EulerSineProd","initialProofState":"z : Complex\nn : Nat\nhz : Ne z 0\n⊢ Eq (HMul.hMul (HSub.hSub 1 (HDiv.hDiv (HPow.hPow z 2) (HPow.hPow (HAdd.hAdd (↑n) 1) 2))) (intervalIntegral (fun x => HMul.hMul (Complex.cos (HMul.hMul (HMul.hMul 2 z) ↑x)) (HPow.hPow (↑(Real.cos x)) (HAdd.hAdd (HMul.hMul 2 n) 2))) 0 (HDiv.hDiv Real.pi 2) MeasureTheory.MeasureSpace.volume)) (HMul.hMul (HDiv.hDiv (HAdd.hAdd (HMul.hMul 2 ↑n) 1) (HAdd.hAdd (HMul.hMul 2 ↑n) 2)) (intervalIntegral (fun x => HMul.hMul (Complex.cos (HMul.hMul (HMul.hMul 2 z) ↑x)) (HPow.hPow (↑(Real.cos x)) (HMul.hMul 2 n))) 0 (HDiv.hDiv Real.pi 2) MeasureTheory.MeasureSpace.volume))","decl":"/-- Note this also holds for `z = 0`, but we do not need this case for `sin_pi_mul_eq`. -/\ntheorem integral_cos_mul_cos_pow_even (n : ℕ) (hz : z ≠ 0) :\n    (((1 : ℂ) - z ^ 2 / ((n : ℂ) + 1) ^ 2) *\n        ∫ x in (0 : ℝ)..π / 2, Complex.cos (2 * z * x) * (cos x : ℂ) ^ (2 * n + 2)) =\n      (2 * n + 1 : ℂ) / (2 * n + 2) *\n        ∫ x in (0 : ℝ)..π / 2, Complex.cos (2 * z * x) * (cos x : ℂ) ^ (2 * n) := by\n  convert integral_cos_mul_cos_pow (by omega : 2 ≤ 2 * n + 2) hz using 3\n  · simp only [Nat.cast_add, Nat.cast_mul, Nat.cast_two]\n    nth_rw 2 [← mul_one (2 : ℂ)]\n    rw [← mul_add, mul_pow, ← div_div]\n    ring\n  · push_cast; ring\n  · push_cast; ring\n\n"}
{"name":"EulerSine.integral_cos_pow_eq","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.EulerSineProd","initialProofState":"n : Nat\n⊢ Eq (intervalIntegral (fun x => HPow.hPow (Real.cos x) n) 0 (HDiv.hDiv Real.pi 2) MeasureTheory.MeasureSpace.volume) (HMul.hMul (1 / 2) (intervalIntegral (fun x => HPow.hPow (Real.sin x) n) 0 Real.pi MeasureTheory.MeasureSpace.volume))","decl":"/-- Relate the integral `cos x ^ n` over `[0, π/2]` to the integral of `sin x ^ n` over `[0, π]`,\nwhich is studied in `Data.Real.Pi.Wallis` and other places. -/\ntheorem integral_cos_pow_eq (n : ℕ) :\n    (∫ x in (0 : ℝ)..π / 2, cos x ^ n) = 1 / 2 * ∫ x in (0 : ℝ)..π, sin x ^ n := by\n  rw [mul_comm (1 / 2 : ℝ), ← div_eq_iff (one_div_ne_zero (two_ne_zero' ℝ)), ← div_mul, div_one,\n    mul_two]\n  have L : IntervalIntegrable _ volume 0 (π / 2) := (continuous_sin.pow n).intervalIntegrable _ _\n  have R : IntervalIntegrable _ volume (π / 2) π := (continuous_sin.pow n).intervalIntegrable _ _\n  rw [← integral_add_adjacent_intervals L R]\n  congr 1\n  · nth_rw 1 [(by ring : 0 = π / 2 - π / 2)]\n    nth_rw 3 [(by ring : π / 2 = π / 2 - 0)]\n    rw [← integral_comp_sub_left]\n    refine integral_congr fun x _ => ?_\n    rw [cos_pi_div_two_sub]\n  · nth_rw 3 [(by ring : π = π / 2 + π / 2)]\n    nth_rw 2 [(by ring : π / 2 = 0 + π / 2)]\n    rw [← integral_comp_add_right]\n    refine integral_congr fun x _ => ?_\n    rw [sin_add_pi_div_two]\n\n"}
{"name":"EulerSine.integral_cos_pow_pos","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.EulerSineProd","initialProofState":"n : Nat\n⊢ LT.lt 0 (intervalIntegral (fun x => HPow.hPow (Real.cos x) n) 0 (HDiv.hDiv Real.pi 2) MeasureTheory.MeasureSpace.volume)","decl":"theorem integral_cos_pow_pos (n : ℕ) : 0 < ∫ x in (0 : ℝ)..π / 2, cos x ^ n :=\n  (integral_cos_pow_eq n).symm ▸ mul_pos one_half_pos (integral_sin_pow_pos _)\n\n"}
{"name":"EulerSine.sin_pi_mul_eq","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.EulerSineProd","initialProofState":"z : Complex\nn : Nat\n⊢ Eq (Complex.sin (HMul.hMul (↑Real.pi) z)) (HDiv.hDiv (HMul.hMul (HMul.hMul (HMul.hMul (↑Real.pi) z) ((Finset.range n).prod fun j => HSub.hSub 1 (HDiv.hDiv (HPow.hPow z 2) (HPow.hPow (HAdd.hAdd (↑j) 1) 2)))) (intervalIntegral (fun x => HMul.hMul (Complex.cos (HMul.hMul (HMul.hMul 2 z) ↑x)) (HPow.hPow (↑(Real.cos x)) (HMul.hMul 2 n))) 0 (HDiv.hDiv Real.pi 2) MeasureTheory.MeasureSpace.volume)) ↑(intervalIntegral (fun x => HPow.hPow (Real.cos x) (HMul.hMul 2 n)) 0 (HDiv.hDiv Real.pi 2) MeasureTheory.MeasureSpace.volume))","decl":"/-- Finite form of Euler's sine product, with remainder term expressed as a ratio of cosine\nintegrals. -/\ntheorem sin_pi_mul_eq (z : ℂ) (n : ℕ) :\n    Complex.sin (π * z) =\n      ((π * z * ∏ j ∈ Finset.range n, ((1 : ℂ) - z ^ 2 / ((j : ℂ) + 1) ^ 2)) *\n          ∫ x in (0 : ℝ)..π / 2, Complex.cos (2 * z * x) * (cos x : ℂ) ^ (2 * n)) /\n        (∫ x in (0 : ℝ)..π / 2, cos x ^ (2 * n) : ℝ) := by\n  rcases eq_or_ne z 0 with (rfl | hz)\n  · simp\n  induction' n with n hn\n  · simp_rw [mul_zero, pow_zero, mul_one, Finset.prod_range_zero, mul_one,\n      integral_one, sub_zero]\n    rw [integral_cos_mul_complex (mul_ne_zero two_ne_zero hz), Complex.ofReal_zero,\n      mul_zero, Complex.sin_zero, zero_div, sub_zero,\n      (by push_cast; field_simp; ring : 2 * z * ↑(π / 2) = π * z)]\n    field_simp [Complex.ofReal_ne_zero.mpr pi_pos.ne']\n    ring\n  · rw [hn, Finset.prod_range_succ]\n    set A := ∏ j ∈ Finset.range n, ((1 : ℂ) - z ^ 2 / ((j : ℂ) + 1) ^ 2)\n    set B := ∫ x in (0 : ℝ)..π / 2, Complex.cos (2 * z * x) * (cos x : ℂ) ^ (2 * n)\n    set C := ∫ x in (0 : ℝ)..π / 2, cos x ^ (2 * n)\n    have aux' : 2 * n.succ = 2 * n + 2 := by rw [Nat.succ_eq_add_one, mul_add, mul_one]\n    have : (∫ x in (0 : ℝ)..π / 2, cos x ^ (2 * n.succ)) = (2 * (n : ℝ) + 1) / (2 * n + 2) * C := by\n      rw [integral_cos_pow_eq]\n      dsimp only [C]\n      rw [integral_cos_pow_eq, aux', integral_sin_pow, sin_zero, sin_pi, pow_succ',\n        zero_mul, zero_mul, zero_mul, sub_zero, zero_div,\n        zero_add, ← mul_assoc, ← mul_assoc, mul_comm (1 / 2 : ℝ) _, Nat.cast_mul, Nat.cast_ofNat]\n    rw [this]\n    change\n      π * z * A * B / C =\n        (π * z * (A * ((1 : ℂ) - z ^ 2 / ((n : ℂ) + 1) ^ 2)) *\n            ∫ x in (0 : ℝ)..π / 2, Complex.cos (2 * z * x) * (cos x : ℂ) ^ (2 * n.succ)) /\n          ((2 * n + 1) / (2 * n + 2) * C : ℝ)\n    have :\n      (π * z * (A * ((1 : ℂ) - z ^ 2 / ((n : ℂ) + 1) ^ 2)) *\n          ∫ x in (0 : ℝ)..π / 2, Complex.cos (2 * z * x) * (cos x : ℂ) ^ (2 * n.succ)) =\n        π * z * A *\n          (((1 : ℂ) - z ^ 2 / (n.succ : ℂ) ^ 2) *\n            ∫ x in (0 : ℝ)..π / 2, Complex.cos (2 * z * x) * (cos x : ℂ) ^ (2 * n.succ)) := by\n      nth_rw 2 [Nat.succ_eq_add_one]\n      rw [Nat.cast_add_one]\n      ring\n    rw [this]\n    suffices\n      (((1 : ℂ) - z ^ 2 / (n.succ : ℂ) ^ 2) *\n          ∫ x in (0 : ℝ)..π / 2, Complex.cos (2 * z * x) * (cos x : ℂ) ^ (2 * n.succ)) =\n        (2 * n + 1) / (2 * n + 2) * B by\n      rw [this, Complex.ofReal_mul, Complex.ofReal_div]\n      have : (C : ℂ) ≠ 0 := Complex.ofReal_ne_zero.mpr (integral_cos_pow_pos _).ne'\n      have : 2 * (n : ℂ) + 1 ≠ 0 := by\n        convert (Nat.cast_add_one_ne_zero (2 * n) : (↑(2 * n) + 1 : ℂ) ≠ 0)\n        simp\n      have : 2 * (n : ℂ) + 2 ≠ 0 := by\n        convert (Nat.cast_add_one_ne_zero (2 * n + 1) : (↑(2 * n + 1) + 1 : ℂ) ≠ 0) using 1\n        push_cast; ring\n      field_simp; ring\n    convert integral_cos_mul_cos_pow_even n hz\n    rw [Nat.cast_succ]\n\n"}
{"name":"EulerSine.tendsto_integral_cos_pow_mul_div","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.EulerSineProd","initialProofState":"f : Real → Complex\nhf : ContinuousOn f (Set.Icc 0 (HDiv.hDiv Real.pi 2))\n⊢ Filter.Tendsto (fun n => HDiv.hDiv (intervalIntegral (fun x => HMul.hMul (HPow.hPow (↑(Real.cos x)) n) (f x)) 0 (HDiv.hDiv Real.pi 2) MeasureTheory.MeasureSpace.volume) ↑(intervalIntegral (fun x => HPow.hPow (Real.cos x) n) 0 (HDiv.hDiv Real.pi 2) MeasureTheory.MeasureSpace.volume)) Filter.atTop (nhds (f 0))","decl":"theorem tendsto_integral_cos_pow_mul_div {f : ℝ → ℂ} (hf : ContinuousOn f (Icc 0 (π / 2))) :\n    Tendsto\n      (fun n : ℕ => (∫ x in (0 : ℝ)..π / 2, (cos x : ℂ) ^ n * f x) /\n        (∫ x in (0 : ℝ)..π / 2, cos x ^ n : ℝ))\n      atTop (𝓝 <| f 0) := by\n  simp_rw [div_eq_inv_mul (α := ℂ), ← Complex.ofReal_inv, integral_of_le pi_div_two_pos.le,\n    ← MeasureTheory.integral_Icc_eq_integral_Ioc, ← Complex.ofReal_pow, ← Complex.real_smul]\n  have c_lt : ∀ y : ℝ, y ∈ Icc 0 (π / 2) → y ≠ 0 → cos y < cos 0 := fun y hy hy' =>\n    cos_lt_cos_of_nonneg_of_le_pi_div_two (le_refl 0) hy.2 (lt_of_le_of_ne hy.1 hy'.symm)\n  have c_nonneg : ∀ x : ℝ, x ∈ Icc 0 (π / 2) → 0 ≤ cos x := fun x hx =>\n    cos_nonneg_of_mem_Icc ((Icc_subset_Icc_left (neg_nonpos_of_nonneg pi_div_two_pos.le)) hx)\n  have c_zero_pos : 0 < cos 0 := by rw [cos_zero]; exact zero_lt_one\n  have zero_mem : (0 : ℝ) ∈ closure (interior (Icc 0 (π / 2))) := by\n    rw [interior_Icc, closure_Ioo pi_div_two_pos.ne, left_mem_Icc]\n    exact pi_div_two_pos.le\n  exact\n    tendsto_setIntegral_pow_smul_of_unique_maximum_of_isCompact_of_continuousOn isCompact_Icc\n      continuousOn_cos c_lt c_nonneg c_zero_pos zero_mem hf\n\n"}
{"name":"Complex.tendsto_euler_sin_prod","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.EulerSineProd","initialProofState":"z : Complex\n⊢ Filter.Tendsto (fun n => HMul.hMul (HMul.hMul (↑Real.pi) z) ((Finset.range n).prod fun j => HSub.hSub 1 (HDiv.hDiv (HPow.hPow z 2) (HPow.hPow (HAdd.hAdd (↑j) 1) 2)))) Filter.atTop (nhds (Complex.sin (HMul.hMul (↑Real.pi) z)))","decl":"/-- Euler's infinite product formula for the complex sine function. -/\ntheorem _root_.Complex.tendsto_euler_sin_prod (z : ℂ) :\n    Tendsto (fun n : ℕ => π * z * ∏ j ∈ Finset.range n, ((1 : ℂ) - z ^ 2 / ((j : ℂ) + 1) ^ 2))\n      atTop (𝓝 <| Complex.sin (π * z)) := by\n  have A :\n    Tendsto\n      (fun n : ℕ =>\n        ((π * z * ∏ j ∈ Finset.range n, ((1 : ℂ) - z ^ 2 / ((j : ℂ) + 1) ^ 2)) *\n            ∫ x in (0 : ℝ)..π / 2, Complex.cos (2 * z * x) * (cos x : ℂ) ^ (2 * n)) /\n          (∫ x in (0 : ℝ)..π / 2, cos x ^ (2 * n) : ℝ))\n      atTop (𝓝 <| _) :=\n    Tendsto.congr (fun n => sin_pi_mul_eq z n) tendsto_const_nhds\n  have : 𝓝 (Complex.sin (π * z)) = 𝓝 (Complex.sin (π * z) * 1) := by rw [mul_one]\n  simp_rw [this, mul_div_assoc] at A\n  convert (tendsto_mul_iff_of_ne_zero _ one_ne_zero).mp A\n  suffices Tendsto (fun n : ℕ =>\n        (∫ x in (0 : ℝ)..π / 2, Complex.cos (2 * z * x) * (cos x : ℂ) ^ n) /\n          (∫ x in (0 : ℝ)..π / 2, cos x ^ n : ℝ)) atTop (𝓝 1) from\n    this.comp (tendsto_id.const_mul_atTop' zero_lt_two)\n  have : ContinuousOn (fun x : ℝ => Complex.cos (2 * z * x)) (Icc 0 (π / 2)) :=\n    (Complex.continuous_cos.comp (continuous_const.mul Complex.continuous_ofReal)).continuousOn\n  convert tendsto_integral_cos_pow_mul_div this using 1\n  · ext1 n; congr 2 with x : 1; rw [mul_comm]\n  · rw [Complex.ofReal_zero, mul_zero, Complex.cos_zero]\n\n"}
{"name":"Real.tendsto_euler_sin_prod","module":"Mathlib.Analysis.SpecialFunctions.Trigonometric.EulerSineProd","initialProofState":"x : Real\n⊢ Filter.Tendsto (fun n => HMul.hMul (HMul.hMul Real.pi x) ((Finset.range n).prod fun j => HSub.hSub 1 (HDiv.hDiv (HPow.hPow x 2) (HPow.hPow (HAdd.hAdd (↑j) 1) 2)))) Filter.atTop (nhds (Real.sin (HMul.hMul Real.pi x)))","decl":"/-- Euler's infinite product formula for the real sine function. -/\ntheorem _root_.Real.tendsto_euler_sin_prod (x : ℝ) :\n    Tendsto (fun n : ℕ => π * x * ∏ j ∈ Finset.range n, ((1 : ℝ) - x ^ 2 / ((j : ℝ) + 1) ^ 2))\n      atTop (𝓝 <| sin (π * x)) := by\n  convert (Complex.continuous_re.tendsto _).comp (Complex.tendsto_euler_sin_prod x) using 1\n  · ext1 n\n    rw [Function.comp_apply, ← Complex.ofReal_mul, Complex.re_ofReal_mul]\n    suffices\n      (∏ j ∈ Finset.range n, (1 - x ^ 2 / (j + 1) ^ 2) : ℂ) =\n        (∏ j ∈ Finset.range n, (1 - x ^ 2 / (j + 1) ^ 2) : ℝ) by\n      rw [this, Complex.ofReal_re]\n    rw [Complex.ofReal_prod]\n    refine Finset.prod_congr (by rfl) fun n _ => ?_\n    norm_cast\n  · rw [← Complex.ofReal_mul, ← Complex.ofReal_sin, Complex.ofReal_re]\n\n"}
