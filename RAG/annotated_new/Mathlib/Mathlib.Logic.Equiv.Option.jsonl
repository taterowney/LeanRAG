{"name":"Equiv.optionCongr_apply","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\na✝ : Option α\n⊢ Eq (e.optionCongr a✝) (Option.map (⇑e) a✝)","decl":"/-- A universe-polymorphic version of `EquivFunctor.mapEquiv Option e`. -/\n@[simps apply]\ndef optionCongr (e : α ≃ β) : Option α ≃ Option β where\n  toFun := Option.map e\n  invFun := Option.map e.symm\n  left_inv x := (Option.map_map _ _ _).trans <| e.symm_comp_self.symm ▸ congr_fun Option.map_id x\n  right_inv x := (Option.map_map _ _ _).trans <| e.self_comp_symm.symm ▸ congr_fun Option.map_id x\n\n"}
{"name":"Equiv.optionCongr_refl","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\n⊢ Eq (Equiv.refl α).optionCongr (Equiv.refl (Option α))","decl":"@[simp]\ntheorem optionCongr_refl : optionCongr (Equiv.refl α) = Equiv.refl _ :=\n  ext <| congr_fun Option.map_id\n\n"}
{"name":"Equiv.optionCongr_symm","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\n⊢ Eq e.optionCongr.symm e.symm.optionCongr","decl":"@[simp]\ntheorem optionCongr_symm (e : α ≃ β) : (optionCongr e).symm = optionCongr e.symm :=\n  rfl\n\n"}
{"name":"Equiv.optionCongr_trans","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ne₁ : Equiv α β\ne₂ : Equiv β γ\n⊢ Eq (e₁.optionCongr.trans e₂.optionCongr) (e₁.trans e₂).optionCongr","decl":"@[simp]\ntheorem optionCongr_trans (e₁ : α ≃ β) (e₂ : β ≃ γ) :\n    (optionCongr e₁).trans (optionCongr e₂) = optionCongr (e₁.trans e₂) :=\n  ext <| Option.map_map _ _\n\n"}
{"name":"Equiv.optionCongr_eq_equivFunctor_mapEquiv","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α β : Type u\ne : Equiv α β\n⊢ Eq e.optionCongr (EquivFunctor.mapEquiv Option e)","decl":"/-- When `α` and `β` are in the same universe, this is the same as the result of\n`EquivFunctor.mapEquiv`. -/\ntheorem optionCongr_eq_equivFunctor_mapEquiv {α β : Type u} (e : α ≃ β) :\n    optionCongr e = EquivFunctor.mapEquiv Option e :=\n  rfl\n\n"}
{"name":"Equiv.removeNone_aux_some","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv (Option α) (Option β)\nx : α\nh : Exists fun x' => Eq (e (Option.some x)) (Option.some x')\n⊢ Eq (Option.some (e.removeNone_aux x)) (e (Option.some x))","decl":"theorem removeNone_aux_some {x : α} (h : ∃ x', e (some x) = some x') :\n    some (removeNone_aux e x) = e (some x) := by\n  simp [removeNone_aux, Option.isSome_iff_exists.mpr h]\n\n"}
{"name":"Equiv.removeNone_aux_none","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv (Option α) (Option β)\nx : α\nh : Eq (e (Option.some x)) Option.none\n⊢ Eq (Option.some (e.removeNone_aux x)) (e Option.none)","decl":"theorem removeNone_aux_none {x : α} (h : e (some x) = none) :\n    some (removeNone_aux e x) = e none := by\n  simp [removeNone_aux, Option.not_isSome_iff_eq_none.mpr h]\n\n"}
{"name":"Equiv.removeNone_aux_inv","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv (Option α) (Option β)\nx : α\n⊢ Eq (e.symm.removeNone_aux (e.removeNone_aux x)) x","decl":"theorem removeNone_aux_inv (x : α) : removeNone_aux e.symm (removeNone_aux e x) = x :=\n  Option.some_injective _\n    (by\n      cases h1 : e.symm (some (removeNone_aux e x)) <;> cases h2 : e (some x)\n      · rw [removeNone_aux_none _ h1]\n        exact (e.eq_symm_apply.mpr h2).symm\n\n      · rw [removeNone_aux_some _ ⟨_, h2⟩] at h1\n        simp at h1\n\n      · rw [removeNone_aux_none _ h2] at h1\n        simp at h1\n\n      · rw [removeNone_aux_some _ ⟨_, h1⟩]\n        rw [removeNone_aux_some _ ⟨_, h2⟩]\n        simp)\n\n"}
{"name":"Equiv.removeNone_symm","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv (Option α) (Option β)\n⊢ Eq e.removeNone.symm e.symm.removeNone","decl":"@[simp]\ntheorem removeNone_symm : (removeNone e).symm = removeNone e.symm :=\n  rfl\n\n"}
{"name":"Equiv.removeNone_some","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv (Option α) (Option β)\nx : α\nh : Exists fun x' => Eq (e (Option.some x)) (Option.some x')\n⊢ Eq (Option.some (e.removeNone x)) (e (Option.some x))","decl":"theorem removeNone_some {x : α} (h : ∃ x', e (some x) = some x') :\n    some (removeNone e x) = e (some x) :=\n  removeNone_aux_some e h\n\n"}
{"name":"Equiv.removeNone_none","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv (Option α) (Option β)\nx : α\nh : Eq (e (Option.some x)) Option.none\n⊢ Eq (Option.some (e.removeNone x)) (e Option.none)","decl":"theorem removeNone_none {x : α} (h : e (some x) = none) : some (removeNone e x) = e none :=\n  removeNone_aux_none e h\n\n"}
{"name":"Equiv.option_symm_apply_none_iff","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv (Option α) (Option β)\n⊢ Iff (Eq (e.symm Option.none) Option.none) (Eq (e Option.none) Option.none)","decl":"@[simp]\ntheorem option_symm_apply_none_iff : e.symm none = none ↔ e none = none :=\n  ⟨fun h => by simpa using (congr_arg e h).symm, fun h => by simpa using (congr_arg e.symm h).symm⟩\n\n"}
{"name":"Equiv.some_removeNone_iff","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv (Option α) (Option β)\nx : α\n⊢ Iff (Eq (Option.some (e.removeNone x)) (e Option.none)) (Eq (e.symm Option.none) (Option.some x))","decl":"theorem some_removeNone_iff {x : α} : some (removeNone e x) = e none ↔ e.symm none = some x := by\n  rcases h : e (some x) with a | a\n  · rw [removeNone_none _ h]\n    simpa using (congr_arg e.symm h).symm\n  · rw [removeNone_some _ ⟨a, h⟩]\n    have h1 := congr_arg e.symm h\n    rw [symm_apply_apply] at h1\n    simp only [apply_eq_iff_eq, reduceCtorEq]\n    simp [h1, apply_eq_iff_eq]\n\n"}
{"name":"Equiv.removeNone_optionCongr","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv α β\n⊢ Eq e.optionCongr.removeNone e","decl":"@[simp]\ntheorem removeNone_optionCongr (e : α ≃ β) : removeNone e.optionCongr = e :=\n  Equiv.ext fun x => Option.some_injective _ <| removeNone_some _ ⟨e x, by simp [EquivFunctor.map]⟩\n\n"}
{"name":"Equiv.optionCongr_injective","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Function.Injective Equiv.optionCongr","decl":"theorem optionCongr_injective : Function.Injective (optionCongr : α ≃ β → Option α ≃ Option β) :=\n  Function.LeftInverse.injective removeNone_optionCongr\n\n"}
{"name":"Equiv.optionSubtype_apply_apply","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nx : β\ne : Subtype fun e => Eq (e Option.none) x\na : α\nh : Ne (↑e (Option.some a)) x\n⊢ Eq (((Equiv.optionSubtype x) e) a) ⟨↑e (Option.some a), h⟩","decl":"@[simp]\ntheorem optionSubtype_apply_apply\n    [DecidableEq β] (x : β)\n    (e : { e : Option α ≃ β // e none = x })\n    (a : α)\n    (h) : optionSubtype x e a = ⟨(e : Option α ≃ β) a, h⟩ := rfl\n\n"}
{"name":"Equiv.coe_optionSubtype_apply_apply","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nx : β\ne : Subtype fun e => Eq (e Option.none) x\na : α\n⊢ Eq (↑(((Equiv.optionSubtype x) e) a)) (↑e (Option.some a))","decl":"@[simp]\ntheorem coe_optionSubtype_apply_apply\n    [DecidableEq β] (x : β)\n    (e : { e : Option α ≃ β // e none = x })\n    (a : α) : ↑(optionSubtype x e a) = (e : Option α ≃ β) a := rfl\n\n"}
{"name":"Equiv.optionSubtype_apply_symm_apply","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nx : β\ne : Subtype fun e => Eq (e Option.none) x\nb : Subtype fun y => Ne y x\n⊢ Eq (Option.some (((Equiv.optionSubtype x) e).symm b)) ((↑e).symm ↑b)","decl":"@[simp]\ntheorem optionSubtype_apply_symm_apply\n    [DecidableEq β] (x : β)\n    (e : { e : Option α ≃ β // e none = x })\n    (b : { y : β // y ≠ x }) : ↑((optionSubtype x e).symm b) = (e : Option α ≃ β).symm b := by\n  dsimp only [optionSubtype]\n  simp\n\n"}
{"name":"Equiv.optionSubtype_symm_apply_apply_coe","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nx : β\ne : Equiv α (Subtype fun y => Ne y x)\na : α\n⊢ Eq (↑((Equiv.optionSubtype x).symm e) (Option.some a)) ↑(e a)","decl":"@[simp]\ntheorem optionSubtype_symm_apply_apply_coe [DecidableEq β] (x : β) (e : α ≃ { y : β // y ≠ x })\n    (a : α) : ((optionSubtype x).symm e : Option α ≃ β) a = e a :=\n  rfl\n\n"}
{"name":"Equiv.optionSubtype_symm_apply_apply_some","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nx : β\ne : Equiv α (Subtype fun y => Ne y x)\na : α\n⊢ Eq (↑((Equiv.optionSubtype x).symm e) (Option.some a)) ↑(e a)","decl":"@[simp]\ntheorem optionSubtype_symm_apply_apply_some\n    [DecidableEq β]\n    (x : β)\n    (e : α ≃ { y : β // y ≠ x })\n    (a : α) : ((optionSubtype x).symm e : Option α ≃ β) (some a) = e a :=\n  rfl\n\n"}
{"name":"Equiv.optionSubtype_symm_apply_apply_none","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nx : β\ne : Equiv α (Subtype fun y => Ne y x)\n⊢ Eq (↑((Equiv.optionSubtype x).symm e) Option.none) x","decl":"@[simp]\ntheorem optionSubtype_symm_apply_apply_none\n    [DecidableEq β]\n    (x : β)\n    (e : α ≃ { y : β // y ≠ x }) : ((optionSubtype x).symm e : Option α ≃ β) none = x :=\n  rfl\n\n"}
{"name":"Equiv.optionSubtype_symm_apply_symm_apply","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nx : β\ne : Equiv α (Subtype fun y => Ne y x)\nb : Subtype fun y => Ne y x\n⊢ Eq ((↑((Equiv.optionSubtype x).symm e)).symm ↑b) (Option.some (e.symm b))","decl":"@[simp]\ntheorem optionSubtype_symm_apply_symm_apply [DecidableEq β] (x : β) (e : α ≃ { y : β // y ≠ x })\n    (b : { y : β // y ≠ x }) : ((optionSubtype x).symm e : Option α ≃ β).symm b = e.symm b := by\n  simp only [optionSubtype, coe_fn_symm_mk, Subtype.coe_mk,\n             Subtype.coe_eta, dite_eq_ite, ite_eq_right_iff]\n  exact fun h => False.elim (b.property h)\n\n"}
{"name":"Equiv.optionSubtypeNe_apply","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na✝ : α\na : Option (Subtype fun y => Ne y a✝)\n⊢ Eq ((Equiv.optionSubtypeNe a✝) a) (a.casesOn' a✝ Subtype.val)","decl":"/-- Any type with a distinguished element is equivalent to an `Option` type on the subtype excluding\nthat element. -/\n@[simps!]\ndef optionSubtypeNe (a : α) : Option {b // b ≠ a} ≃ α := optionSubtype a |>.symm (.refl _) |>.1\n\n"}
{"name":"Equiv.optionSubtypeNe_symm_apply","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\n⊢ Eq ((Equiv.optionSubtypeNe a).symm b) (dite (Eq b a) (fun h => Option.none) fun h => Option.some ⟨b, h⟩)","decl":"/-- Any type with a distinguished element is equivalent to an `Option` type on the subtype excluding\nthat element. -/\n@[simps!]\ndef optionSubtypeNe (a : α) : Option {b // b ≠ a} ≃ α := optionSubtype a |>.symm (.refl _) |>.1\n\n"}
{"name":"Equiv.optionSubtypeNe_symm_self","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq ((Equiv.optionSubtypeNe a).symm a) Option.none","decl":"lemma optionSubtypeNe_symm_self (a : α) : (optionSubtypeNe a).symm a = none := by simp\n"}
{"name":"Equiv.optionSubtypeNe_symm_of_ne","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na b : α\nhba : Ne b a\n⊢ Eq ((Equiv.optionSubtypeNe a).symm b) (Option.some ⟨b, hba⟩)","decl":"lemma optionSubtypeNe_symm_of_ne (hba : b ≠ a) : (optionSubtypeNe a).symm b = some ⟨b, hba⟩ := by\n  simp [hba]\n\n"}
{"name":"Equiv.optionSubtypeNe_none","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq ((Equiv.optionSubtypeNe a) Option.none) a","decl":"@[simp] lemma optionSubtypeNe_none (a : α) : optionSubtypeNe a none = a := rfl\n"}
{"name":"Equiv.optionSubtypeNe_some","module":"Mathlib.Logic.Equiv.Option","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nb : Subtype fun b => Ne b a\n⊢ Eq ((Equiv.optionSubtypeNe a) (Option.some b)) ↑b","decl":"@[simp] lemma optionSubtypeNe_some (a : α) (b) : optionSubtypeNe a (some b) = b := rfl\n\n"}
