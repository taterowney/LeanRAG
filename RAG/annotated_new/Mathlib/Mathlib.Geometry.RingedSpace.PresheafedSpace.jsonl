{"name":"AlgebraicGeometry.PresheafedSpace.mk.sizeOf_spec","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : SizeOf C\ncarrier : TopCat\npresheaf : TopCat.Presheaf C carrier\n‚ä¢ Eq (SizeOf.sizeOf { carrier := carrier, presheaf := presheaf }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf carrier)) (SizeOf.sizeOf presheaf))","decl":"/-- A `PresheafedSpace C` is a topological space equipped with a presheaf of `C`s. -/\nstructure PresheafedSpace where\n  carrier : TopCat\n  protected presheaf : carrier.Presheaf C\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.mk.inj","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\ncarrier‚úù : TopCat\npresheaf‚úù : TopCat.Presheaf C carrier‚úù\ncarrier : TopCat\npresheaf : TopCat.Presheaf C carrier\nx‚úù : Eq { carrier := carrier‚úù, presheaf := presheaf‚úù } { carrier := carrier, presheaf := presheaf }\n‚ä¢ And (Eq carrier‚úù carrier) (HEq presheaf‚úù presheaf)","decl":"/-- A `PresheafedSpace C` is a topological space equipped with a presheaf of `C`s. -/\nstructure PresheafedSpace where\n  carrier : TopCat\n  protected presheaf : carrier.Presheaf C\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.mk.injEq","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\ncarrier‚úù : TopCat\npresheaf‚úù : TopCat.Presheaf C carrier‚úù\ncarrier : TopCat\npresheaf : TopCat.Presheaf C carrier\n‚ä¢ Eq (Eq { carrier := carrier‚úù, presheaf := presheaf‚úù } { carrier := carrier, presheaf := presheaf }) (And (Eq carrier‚úù carrier) (HEq presheaf‚úù presheaf))","decl":"/-- A `PresheafedSpace C` is a topological space equipped with a presheaf of `C`s. -/\nstructure PresheafedSpace where\n  carrier : TopCat\n  protected presheaf : carrier.Presheaf C\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.mk_coe","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_3, u_1} C\ncarrier : TopCat\npresheaf : TopCat.Presheaf C carrier\n‚ä¢ Eq (‚Üë{ carrier := carrier, presheaf := presheaf }) carrier","decl":"theorem mk_coe (carrier) (presheaf) :\n    (({ carrier\n        presheaf } : PresheafedSpace C) : TopCat) = carrier :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.Hom.mk.sizeOf_spec","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX Y : AlgebraicGeometry.PresheafedSpace C\ninst‚úù : SizeOf C\nbase : Quiver.Hom ‚ÜëX ‚ÜëY\nc : Quiver.Hom Y.presheaf ((TopCat.Presheaf.pushforward C base).obj X.presheaf)\n‚ä¢ Eq (SizeOf.sizeOf { base := base, c := c }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf base)) (SizeOf.sizeOf c))","decl":"/-- A morphism between presheafed spaces `X` and `Y` consists of a continuous map\n    `f` between the underlying topological spaces, and a (notice contravariant!) map\n    from the presheaf on `Y` to the pushforward of the presheaf on `X` via `f`. -/\nstructure Hom (X Y : PresheafedSpace C) where\n  base : (X : TopCat) ‚ü∂ (Y : TopCat)\n  c : Y.presheaf ‚ü∂ base _* X.presheaf\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): eventually, the `ext` lemma shall be applied to terms in `X ‚ü∂ Y`\n-- rather than `Hom X Y`, this one was renamed `Hom.ext` instead of `ext`,\n-- and the more practical lemma `ext` is defined just after the definition\n-- of the `Category` instance\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.Hom.mk.inj","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y : AlgebraicGeometry.PresheafedSpace C\nbase‚úù : Quiver.Hom ‚ÜëX ‚ÜëY\nc‚úù : Quiver.Hom Y.presheaf ((TopCat.Presheaf.pushforward C base‚úù).obj X.presheaf)\nbase : Quiver.Hom ‚ÜëX ‚ÜëY\nc : Quiver.Hom Y.presheaf ((TopCat.Presheaf.pushforward C base).obj X.presheaf)\nx‚úù : Eq { base := base‚úù, c := c‚úù } { base := base, c := c }\n‚ä¢ And (Eq base‚úù base) (HEq c‚úù c)","decl":"/-- A morphism between presheafed spaces `X` and `Y` consists of a continuous map\n    `f` between the underlying topological spaces, and a (notice contravariant!) map\n    from the presheaf on `Y` to the pushforward of the presheaf on `X` via `f`. -/\nstructure Hom (X Y : PresheafedSpace C) where\n  base : (X : TopCat) ‚ü∂ (Y : TopCat)\n  c : Y.presheaf ‚ü∂ base _* X.presheaf\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): eventually, the `ext` lemma shall be applied to terms in `X ‚ü∂ Y`\n-- rather than `Hom X Y`, this one was renamed `Hom.ext` instead of `ext`,\n-- and the more practical lemma `ext` is defined just after the definition\n-- of the `Category` instance\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.Hom.mk.injEq","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y : AlgebraicGeometry.PresheafedSpace C\nbase‚úù : Quiver.Hom ‚ÜëX ‚ÜëY\nc‚úù : Quiver.Hom Y.presheaf ((TopCat.Presheaf.pushforward C base‚úù).obj X.presheaf)\nbase : Quiver.Hom ‚ÜëX ‚ÜëY\nc : Quiver.Hom Y.presheaf ((TopCat.Presheaf.pushforward C base).obj X.presheaf)\n‚ä¢ Eq (Eq { base := base‚úù, c := c‚úù } { base := base, c := c }) (And (Eq base‚úù base) (HEq c‚úù c))","decl":"/-- A morphism between presheafed spaces `X` and `Y` consists of a continuous map\n    `f` between the underlying topological spaces, and a (notice contravariant!) map\n    from the presheaf on `Y` to the pushforward of the presheaf on `X` via `f`. -/\nstructure Hom (X Y : PresheafedSpace C) where\n  base : (X : TopCat) ‚ü∂ (Y : TopCat)\n  c : Y.presheaf ‚ü∂ base _* X.presheaf\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): eventually, the `ext` lemma shall be applied to terms in `X ‚ü∂ Y`\n-- rather than `Hom X Y`, this one was renamed `Hom.ext` instead of `ext`,\n-- and the more practical lemma `ext` is defined just after the definition\n-- of the `Category` instance\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.Hom.ext","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y : AlgebraicGeometry.PresheafedSpace C\nŒ± Œ≤ : X.Hom Y\nw : Eq Œ±.base Œ≤.base\nh : Eq (CategoryTheory.CategoryStruct.comp Œ±.c (CategoryTheory.whiskerRight (CategoryTheory.eqToHom ‚ãØ) X.presheaf)) Œ≤.c\n‚ä¢ Eq Œ± Œ≤","decl":"@[ext (iff := false)]\ntheorem Hom.ext {X Y : PresheafedSpace C} (Œ± Œ≤ : Hom X Y) (w : Œ±.base = Œ≤.base)\n    (h : Œ±.c ‚â´ whiskerRight (eqToHom (by rw [w])) _ = Œ≤.c) : Œ± = Œ≤ := by\n  rcases Œ± with ‚ü®base, c‚ü©\n  rcases Œ≤ with ‚ü®base', c'‚ü©\n  dsimp at w\n  subst w\n  dsimp at h\n  erw [whiskerRight_id', comp_id] at h\n  subst h\n  rfl\n\n-- TODO including `injections` would make tidy work earlier.\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.hext","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y : AlgebraicGeometry.PresheafedSpace C\nŒ± Œ≤ : X.Hom Y\nw : Eq Œ±.base Œ≤.base\nh : HEq Œ±.c Œ≤.c\n‚ä¢ Eq Œ± Œ≤","decl":"theorem hext {X Y : PresheafedSpace C} (Œ± Œ≤ : Hom X Y) (w : Œ±.base = Œ≤.base) (h : HEq Œ±.c Œ≤.c) :\n    Œ± = Œ≤ := by\n  cases Œ±\n  cases Œ≤\n  congr\n\n-- Porting note: `eqToHom` is no longer necessary in the definition of `c`\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.comp_c","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y Z : AlgebraicGeometry.PresheafedSpace C\nŒ± : X.Hom Y\nŒ≤ : Y.Hom Z\n‚ä¢ Eq (AlgebraicGeometry.PresheafedSpace.comp Œ± Œ≤).c (CategoryTheory.CategoryStruct.comp Œ≤.c ((TopCat.Presheaf.pushforward C Œ≤.base).map Œ±.c))","decl":"theorem comp_c {X Y Z : PresheafedSpace C} (Œ± : Hom X Y) (Œ≤ : Hom Y Z) :\n    (comp Œ± Œ≤).c = Œ≤.c ‚â´ (Presheaf.pushforward _ Œ≤.base).map Œ±.c :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.ext","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y : AlgebraicGeometry.PresheafedSpace C\nŒ± Œ≤ : Quiver.Hom X Y\nw : Eq Œ±.base Œ≤.base\nh : Eq (CategoryTheory.CategoryStruct.comp Œ±.c (CategoryTheory.whiskerRight (CategoryTheory.eqToHom ‚ãØ) X.presheaf)) Œ≤.c\n‚ä¢ Eq Œ± Œ≤","decl":"@[ext (iff := false)]\ntheorem ext {X Y : PresheafedSpace C} (Œ± Œ≤ : X ‚ü∂ Y) (w : Œ±.base = Œ≤.base)\n    (h : Œ±.c ‚â´ whiskerRight (eqToHom (by rw [w])) _ = Œ≤.c) : Œ± = Œ≤ :=\n  Hom.ext Œ± Œ≤ w h\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.id_base","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : AlgebraicGeometry.PresheafedSpace C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X).base (CategoryTheory.CategoryStruct.id ‚ÜëX)","decl":"@[simp]\ntheorem id_base (X : PresheafedSpace C) : (ùüô X : X ‚ü∂ X).base = ùüô (X : TopCat) :=\n  rfl\n\n-- Porting note: `eqToHom` is no longer needed in the statements of `id_c` and `id_c_app`\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.id_c","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : AlgebraicGeometry.PresheafedSpace C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X).c (CategoryTheory.CategoryStruct.id X.presheaf)","decl":"theorem id_c (X : PresheafedSpace C) :\n    (ùüô X : X ‚ü∂ X).c = ùüô X.presheaf :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.id_c_app","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : AlgebraicGeometry.PresheafedSpace C\nU : Opposite (TopologicalSpace.Opens ‚Üë‚ÜëX)\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.id X).c.app U) (X.presheaf.map (CategoryTheory.CategoryStruct.id U))","decl":"@[simp]\ntheorem id_c_app (X : PresheafedSpace C) (U) :\n    (ùüô X : X ‚ü∂ X).c.app U = X.presheaf.map (ùüô U) := by\n  rw [id_c, map_id]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.comp_base","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y Z : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).base (CategoryTheory.CategoryStruct.comp f.base g.base)","decl":"@[simp]\ntheorem comp_base {X Y Z : PresheafedSpace C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    (f ‚â´ g).base = f.base ‚â´ g.base :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.comp_c_app_assoc","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y Z‚úù : AlgebraicGeometry.PresheafedSpace C\nŒ± : Quiver.Hom X Y\nŒ≤ : Quiver.Hom Y Z‚úù\nU : Opposite (TopologicalSpace.Opens ‚Üë‚ÜëZ‚úù)\nZ : C\nh : Quiver.Hom (((TopCat.Presheaf.pushforward C (CategoryTheory.CategoryStruct.comp Œ± Œ≤).base).obj X.presheaf).obj U) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CategoryStruct.comp Œ± Œ≤).c.app U) h) (CategoryTheory.CategoryStruct.comp (Œ≤.c.app U) (CategoryTheory.CategoryStruct.comp (Œ±.c.app { unop := (TopologicalSpace.Opens.map Œ≤.base).obj (Opposite.unop U) }) h))","decl":"/-- Sometimes rewriting with `comp_c_app` doesn't work because of dependent type issues.\nIn that case, `erw comp_c_app_assoc` might make progress.\nThe lemma `comp_c_app_assoc` is also better suited for rewrites in the opposite direction. -/\n@[reassoc, simp]\ntheorem comp_c_app {X Y Z : PresheafedSpace C} (Œ± : X ‚ü∂ Y) (Œ≤ : Y ‚ü∂ Z) (U) :\n    (Œ± ‚â´ Œ≤).c.app U = Œ≤.c.app U ‚â´ Œ±.c.app (op ((Opens.map Œ≤.base).obj (unop U))) :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.comp_c_app","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y Z : AlgebraicGeometry.PresheafedSpace C\nŒ± : Quiver.Hom X Y\nŒ≤ : Quiver.Hom Y Z\nU : Opposite (TopologicalSpace.Opens ‚Üë‚ÜëZ)\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.comp Œ± Œ≤).c.app U) (CategoryTheory.CategoryStruct.comp (Œ≤.c.app U) (Œ±.c.app { unop := (TopologicalSpace.Opens.map Œ≤.base).obj (Opposite.unop U) }))","decl":"/-- Sometimes rewriting with `comp_c_app` doesn't work because of dependent type issues.\nIn that case, `erw comp_c_app_assoc` might make progress.\nThe lemma `comp_c_app_assoc` is also better suited for rewrites in the opposite direction. -/\n@[reassoc, simp]\ntheorem comp_c_app {X Y Z : PresheafedSpace C} (Œ± : X ‚ü∂ Y) (Œ≤ : Y ‚ü∂ Z) (U) :\n    (Œ± ‚â´ Œ≤).c.app U = Œ≤.c.app U ‚â´ Œ±.c.app (op ((Opens.map Œ≤.base).obj (unop U))) :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.congr_app","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y : AlgebraicGeometry.PresheafedSpace C\nŒ± Œ≤ : Quiver.Hom X Y\nh : Eq Œ± Œ≤\nU : Opposite (TopologicalSpace.Opens ‚Üë‚ÜëY)\n‚ä¢ Eq (Œ±.c.app U) (CategoryTheory.CategoryStruct.comp (Œ≤.c.app U) (X.presheaf.map (CategoryTheory.eqToHom ‚ãØ)))","decl":"theorem congr_app {X Y : PresheafedSpace C} {Œ± Œ≤ : X ‚ü∂ Y} (h : Œ± = Œ≤) (U) :\n    Œ±.c.app U = Œ≤.c.app U ‚â´ X.presheaf.map (eqToHom (by subst h; rfl)) := by\n  subst h\n  simp\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.forget_map","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX‚úù Y‚úù : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((AlgebraicGeometry.PresheafedSpace.forget C).map f) f.base","decl":"/-- The forgetful functor from `PresheafedSpace` to `TopCat`. -/\n@[simps]\ndef forget : PresheafedSpace C ‚•§ TopCat where\n  obj X := (X : TopCat)\n  map f := f.base\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.forget_obj","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : AlgebraicGeometry.PresheafedSpace C\n‚ä¢ Eq ((AlgebraicGeometry.PresheafedSpace.forget C).obj X) ‚ÜëX","decl":"/-- The forgetful functor from `PresheafedSpace` to `TopCat`. -/\n@[simps]\ndef forget : PresheafedSpace C ‚•§ TopCat where\n  obj X := (X : TopCat)\n  map f := f.base\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.isoOfComponents_inv","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y : AlgebraicGeometry.PresheafedSpace C\nH : CategoryTheory.Iso ‚ÜëX ‚ÜëY\nŒ± : CategoryTheory.Iso ((TopCat.Presheaf.pushforward C H.hom).obj X.presheaf) Y.presheaf\n‚ä¢ Eq (AlgebraicGeometry.PresheafedSpace.isoOfComponents H Œ±).inv { base := H.inv, c := TopCat.Presheaf.toPushforwardOfIso H Œ±.hom }","decl":"/-- An isomorphism of `PresheafedSpace`s is a homeomorphism of the underlying space, and a\nnatural transformation between the sheaves.\n-/\n@[simps hom inv]\ndef isoOfComponents (H : X.1 ‚âÖ Y.1) (Œ± : H.hom _* X.2 ‚âÖ Y.2) : X ‚âÖ Y where\n  hom :=\n    { base := H.hom\n      c := Œ±.inv }\n  inv :=\n    { base := H.inv\n      c := Presheaf.toPushforwardOfIso H Œ±.hom }\n  hom_inv_id := by ext <;> simp\n  inv_hom_id := by\n    ext\n    ¬∑ dsimp\n      rw [H.inv_hom_id]\n    dsimp\n    simp only [Presheaf.toPushforwardOfIso_app, assoc, ‚Üê Œ±.hom.naturality]\n    simp only [eqToHom_map, eqToHom_app, eqToHom_trans_assoc, eqToHom_refl, id_comp]\n    apply Iso.inv_hom_id_app\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.isoOfComponents_hom","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y : AlgebraicGeometry.PresheafedSpace C\nH : CategoryTheory.Iso ‚ÜëX ‚ÜëY\nŒ± : CategoryTheory.Iso ((TopCat.Presheaf.pushforward C H.hom).obj X.presheaf) Y.presheaf\n‚ä¢ Eq (AlgebraicGeometry.PresheafedSpace.isoOfComponents H Œ±).hom { base := H.hom, c := Œ±.inv }","decl":"/-- An isomorphism of `PresheafedSpace`s is a homeomorphism of the underlying space, and a\nnatural transformation between the sheaves.\n-/\n@[simps hom inv]\ndef isoOfComponents (H : X.1 ‚âÖ Y.1) (Œ± : H.hom _* X.2 ‚âÖ Y.2) : X ‚âÖ Y where\n  hom :=\n    { base := H.hom\n      c := Œ±.inv }\n  inv :=\n    { base := H.inv\n      c := Presheaf.toPushforwardOfIso H Œ±.hom }\n  hom_inv_id := by ext <;> simp\n  inv_hom_id := by\n    ext\n    ¬∑ dsimp\n      rw [H.inv_hom_id]\n    dsimp\n    simp only [Presheaf.toPushforwardOfIso_app, assoc, ‚Üê Œ±.hom.naturality]\n    simp only [eqToHom_map, eqToHom_app, eqToHom_trans_assoc, eqToHom_refl, id_comp]\n    apply Iso.inv_hom_id_app\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.sheafIsoOfIso_hom","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y : AlgebraicGeometry.PresheafedSpace C\nH : CategoryTheory.Iso X Y\n‚ä¢ Eq (AlgebraicGeometry.PresheafedSpace.sheafIsoOfIso H).hom H.hom.c","decl":"/-- Isomorphic `PresheafedSpace`s have naturally isomorphic presheaves. -/\n@[simps]\ndef sheafIsoOfIso (H : X ‚âÖ Y) : Y.2 ‚âÖ H.hom.base _* X.2 where\n  hom := H.hom.c\n  inv := Presheaf.pushforwardToOfIso ((forget _).mapIso H).symm H.inv.c\n  hom_inv_id := by\n    ext U\n    rw [NatTrans.comp_app]\n    simpa using congr_arg (fun f => f ‚â´ eqToHom _) (congr_app H.inv_hom_id (op U))\n  inv_hom_id := by\n    ext U\n    dsimp\n    rw [NatTrans.id_app]\n    simp only [Presheaf.pushforwardToOfIso_app, Iso.symm_inv, mapIso_hom, forget_map,\n      Iso.symm_hom, mapIso_inv, eqToHom_map, assoc]\n    have eq‚ÇÅ := congr_app H.hom_inv_id (op ((Opens.map H.hom.base).obj U))\n    have eq‚ÇÇ := H.hom.c.naturality (eqToHom (congr_obj (congr_arg Opens.map\n      ((forget C).congr_map H.inv_hom_id.symm)) U)).op\n    rw [id_c, NatTrans.id_app, id_comp, eqToHom_map, comp_c_app] at eq‚ÇÅ\n    rw [eqToHom_op, eqToHom_map] at eq‚ÇÇ\n    erw [eq‚ÇÇ, reassoc_of% eq‚ÇÅ]\n    simp\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.sheafIsoOfIso_inv","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y : AlgebraicGeometry.PresheafedSpace C\nH : CategoryTheory.Iso X Y\n‚ä¢ Eq (AlgebraicGeometry.PresheafedSpace.sheafIsoOfIso H).inv (TopCat.Presheaf.pushforwardToOfIso ((AlgebraicGeometry.PresheafedSpace.forget C).mapIso H).symm H.inv.c)","decl":"/-- Isomorphic `PresheafedSpace`s have naturally isomorphic presheaves. -/\n@[simps]\ndef sheafIsoOfIso (H : X ‚âÖ Y) : Y.2 ‚âÖ H.hom.base _* X.2 where\n  hom := H.hom.c\n  inv := Presheaf.pushforwardToOfIso ((forget _).mapIso H).symm H.inv.c\n  hom_inv_id := by\n    ext U\n    rw [NatTrans.comp_app]\n    simpa using congr_arg (fun f => f ‚â´ eqToHom _) (congr_app H.inv_hom_id (op U))\n  inv_hom_id := by\n    ext U\n    dsimp\n    rw [NatTrans.id_app]\n    simp only [Presheaf.pushforwardToOfIso_app, Iso.symm_inv, mapIso_hom, forget_map,\n      Iso.symm_hom, mapIso_inv, eqToHom_map, assoc]\n    have eq‚ÇÅ := congr_app H.hom_inv_id (op ((Opens.map H.hom.base).obj U))\n    have eq‚ÇÇ := H.hom.c.naturality (eqToHom (congr_obj (congr_arg Opens.map\n      ((forget C).congr_map H.inv_hom_id.symm)) U)).op\n    rw [id_c, NatTrans.id_app, id_comp, eqToHom_map, comp_c_app] at eq‚ÇÅ\n    rw [eqToHom_op, eqToHom_map] at eq‚ÇÇ\n    erw [eq‚ÇÇ, reassoc_of% eq‚ÇÅ]\n    simp\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.base_isIso_of_iso","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX Y : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ CategoryTheory.IsIso f.base","decl":"instance base_isIso_of_iso (f : X ‚ü∂ Y) [IsIso f] : IsIso f.base :=\n  ((forget _).mapIso (asIso f)).isIso_hom\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.c_isIso_of_iso","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX Y : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ CategoryTheory.IsIso f.c","decl":"instance c_isIso_of_iso (f : X ‚ü∂ Y) [IsIso f] : IsIso f.c :=\n  (sheafIsoOfIso (asIso f)).isIso_hom\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.isIso_of_components","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\nX Y : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom X Y\ninst‚úù¬π : CategoryTheory.IsIso f.base\ninst‚úù : CategoryTheory.IsIso f.c\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- This could be used in conjunction with `CategoryTheory.NatIso.isIso_of_isIso_app`. -/\ntheorem isIso_of_components (f : X ‚ü∂ Y) [IsIso f.base] [IsIso f.c] : IsIso f :=\n  (isoOfComponents (asIso f.base) (asIso f.c).symm).isIso_hom\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.restrict_carrier","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nU : TopCat\nX : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom U ‚ÜëX\nh : Topology.IsOpenEmbedding ‚áëf\n‚ä¢ Eq (‚Üë(X.restrict h)) U","decl":"/-- The restriction of a presheafed space along an open embedding into the space.\n-/\n@[simps]\ndef restrict {U : TopCat} (X : PresheafedSpace C) {f : U ‚ü∂ (X : TopCat)}\n    (h : IsOpenEmbedding f) : PresheafedSpace C where\n  carrier := U\n  presheaf := h.isOpenMap.functor.op ‚ãô X.presheaf\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.restrict_presheaf","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nU : TopCat\nX : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom U ‚ÜëX\nh : Topology.IsOpenEmbedding ‚áëf\n‚ä¢ Eq (X.restrict h).presheaf (‚ãØ.functor.op.comp X.presheaf)","decl":"/-- The restriction of a presheafed space along an open embedding into the space.\n-/\n@[simps]\ndef restrict {U : TopCat} (X : PresheafedSpace C) {f : U ‚ü∂ (X : TopCat)}\n    (h : IsOpenEmbedding f) : PresheafedSpace C where\n  carrier := U\n  presheaf := h.isOpenMap.functor.op ‚ãô X.presheaf\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.ofRestrict_base","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nU : TopCat\nX : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom U ‚ÜëX\nh : Topology.IsOpenEmbedding ‚áëf\n‚ä¢ Eq (X.ofRestrict h).base f","decl":"/-- The map from the restriction of a presheafed space.\n-/\n@[simps]\ndef ofRestrict {U : TopCat} (X : PresheafedSpace C) {f : U ‚ü∂ (X : TopCat)}\n    (h : IsOpenEmbedding f) : X.restrict h ‚ü∂ X where\n  base := f\n  c :=\n    { app := fun V => X.presheaf.map (h.isOpenMap.adjunction.counit.app V.unop).op\n      naturality := fun U V f =>\n        show _ = _ ‚â´ X.presheaf.map _ by\n          rw [‚Üê map_comp, ‚Üê map_comp]\n          rfl }\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.ofRestrict_c_app","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nU : TopCat\nX : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom U ‚ÜëX\nh : Topology.IsOpenEmbedding ‚áëf\nV : Opposite (TopologicalSpace.Opens ‚Üë‚ÜëX)\n‚ä¢ Eq ((X.ofRestrict h).c.app V) (X.presheaf.map (‚ãØ.adjunction.counit.app (Opposite.unop V)).op)","decl":"/-- The map from the restriction of a presheafed space.\n-/\n@[simps]\ndef ofRestrict {U : TopCat} (X : PresheafedSpace C) {f : U ‚ü∂ (X : TopCat)}\n    (h : IsOpenEmbedding f) : X.restrict h ‚ü∂ X where\n  base := f\n  c :=\n    { app := fun V => X.presheaf.map (h.isOpenMap.adjunction.counit.app V.unop).op\n      naturality := fun U V f =>\n        show _ = _ ‚â´ X.presheaf.map _ by\n          rw [‚Üê map_comp, ‚Üê map_comp]\n          rfl }\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.ofRestrict_mono","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_3, u_1} C\nU : TopCat\nX : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom U ‚ÜëX\nhf : Topology.IsOpenEmbedding ‚áëf\n‚ä¢ CategoryTheory.Mono (X.ofRestrict hf)","decl":"instance ofRestrict_mono {U : TopCat} (X : PresheafedSpace C) (f : U ‚ü∂ X.1)\n    (hf : IsOpenEmbedding f) : Mono (X.ofRestrict hf) := by\n  haveI : Mono f := (TopCat.mono_iff_injective _).mpr hf.injective\n  constructor\n  intro Z g‚ÇÅ g‚ÇÇ eq\n  ext1\n  ¬∑ have := congr_arg PresheafedSpace.Hom.base eq\n    simp only [PresheafedSpace.comp_base, PresheafedSpace.ofRestrict_base] at this\n    rw [cancel_mono] at this\n    exact this\n  ¬∑ ext V\n    have hV : (Opens.map (X.ofRestrict hf).base).obj (hf.isOpenMap.functor.obj V) = V := by\n      ext1\n      exact Set.preimage_image_eq _ hf.injective\n    haveI :\n      IsIso (hf.isOpenMap.adjunction.counit.app (unop (op (hf.isOpenMap.functor.obj V)))) :=\n        NatIso.isIso_app_of_isIso\n          (whiskerLeft hf.isOpenMap.functor hf.isOpenMap.adjunction.counit) V\n    have := PresheafedSpace.congr_app eq (op (hf.isOpenMap.functor.obj V))\n    rw [PresheafedSpace.comp_c_app, PresheafedSpace.comp_c_app,\n      PresheafedSpace.ofRestrict_c_app, Category.assoc, cancel_epi] at this\n    have h : _ ‚â´ _ = _ ‚â´ _ ‚â´ _ :=\n      congr_arg (fun f => (X.restrict hf).presheaf.map (eqToHom hV).op ‚â´ f) this\n    simp only [g‚ÇÅ.c.naturality, g‚ÇÇ.c.naturality_assoc] at h\n    simp only [eqToHom_op, eqToHom_unop, eqToHom_map, eqToHom_trans,\n      ‚Üê IsIso.comp_inv_eq, inv_eqToHom, Category.assoc] at h\n    simpa using h\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.restrict_top_presheaf","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : AlgebraicGeometry.PresheafedSpace C\n‚ä¢ Eq (X.restrict ‚ãØ).presheaf ((TopCat.Presheaf.pushforward C (TopologicalSpace.Opens.inclusionTopIso ‚ÜëX).inv).obj X.presheaf)","decl":"theorem restrict_top_presheaf (X : PresheafedSpace C) :\n    (X.restrict (Opens.isOpenEmbedding ‚ä§)).presheaf =\n      (Opens.inclusionTopIso X.carrier).inv _* X.presheaf := by\n  dsimp\n  rw [Opens.inclusion'_top_functor X.carrier]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.ofRestrict_top_c","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : AlgebraicGeometry.PresheafedSpace C\n‚ä¢ Eq (X.ofRestrict ‚ãØ).c (CategoryTheory.eqToHom ‚ãØ)","decl":"theorem ofRestrict_top_c (X : PresheafedSpace C) :\n    (X.ofRestrict (Opens.isOpenEmbedding ‚ä§)).c =\n      eqToHom\n        (by\n          rw [restrict_top_presheaf, ‚Üê Presheaf.Pushforward.comp_eq]\n          erw [Iso.inv_hom_id]\n          rw [Presheaf.id_pushforward]\n          dsimp) := by\n  /- another approach would be to prove the left hand side\n       is a natural isomorphism, but I encountered a universe\n       issue when `apply NatIso.isIso_of_isIso_app`. -/\n  ext\n  dsimp [ofRestrict]\n  erw [eqToHom_map, eqToHom_app]\n  simp\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.toRestrictTop_c","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : AlgebraicGeometry.PresheafedSpace C\n‚ä¢ Eq X.toRestrictTop.c (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- The map to the restriction of a presheafed space along the canonical inclusion from the top\nsubspace.\n-/\n@[simps]\ndef toRestrictTop (X : PresheafedSpace C) : X ‚ü∂ X.restrict (Opens.isOpenEmbedding ‚ä§) where\n  base := (Opens.inclusionTopIso X.carrier).inv\n  c := eqToHom (restrict_top_presheaf X)\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.toRestrictTop_base","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : AlgebraicGeometry.PresheafedSpace C\n‚ä¢ Eq X.toRestrictTop.base (TopologicalSpace.Opens.inclusionTopIso ‚ÜëX).inv","decl":"/-- The map to the restriction of a presheafed space along the canonical inclusion from the top\nsubspace.\n-/\n@[simps]\ndef toRestrictTop (X : PresheafedSpace C) : X ‚ü∂ X.restrict (Opens.isOpenEmbedding ‚ä§) where\n  base := (Opens.inclusionTopIso X.carrier).inv\n  c := eqToHom (restrict_top_presheaf X)\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.restrictTopIso_hom","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : AlgebraicGeometry.PresheafedSpace C\n‚ä¢ Eq X.restrictTopIso.hom (X.ofRestrict ‚ãØ)","decl":"/-- The isomorphism from the restriction to the top subspace.\n-/\n@[simps]\ndef restrictTopIso (X : PresheafedSpace C) : X.restrict (Opens.isOpenEmbedding ‚ä§) ‚âÖ X where\n  hom := X.ofRestrict _\n  inv := X.toRestrictTop\n  hom_inv_id := by\n    ext\n    ¬∑ rfl\n    ¬∑ erw [comp_c, toRestrictTop_c, whiskerRight_id',\n        comp_id, ofRestrict_top_c, eqToHom_map, eqToHom_trans, eqToHom_refl]\n      rfl\n  inv_hom_id := by\n    ext\n    ¬∑ rfl\n    ¬∑ erw [comp_c, ofRestrict_top_c, toRestrictTop_c, eqToHom_map, whiskerRight_id', comp_id,\n        eqToHom_trans, eqToHom_refl]\n      rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.restrictTopIso_inv","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : AlgebraicGeometry.PresheafedSpace C\n‚ä¢ Eq X.restrictTopIso.inv X.toRestrictTop","decl":"/-- The isomorphism from the restriction to the top subspace.\n-/\n@[simps]\ndef restrictTopIso (X : PresheafedSpace C) : X.restrict (Opens.isOpenEmbedding ‚ä§) ‚âÖ X where\n  hom := X.ofRestrict _\n  inv := X.toRestrictTop\n  hom_inv_id := by\n    ext\n    ¬∑ rfl\n    ¬∑ erw [comp_c, toRestrictTop_c, whiskerRight_id',\n        comp_id, ofRestrict_top_c, eqToHom_map, eqToHom_trans, eqToHom_refl]\n      rfl\n  inv_hom_id := by\n    ext\n    ¬∑ rfl\n    ¬∑ erw [comp_c, ofRestrict_top_c, toRestrictTop_c, eqToHom_map, whiskerRight_id', comp_id,\n        eqToHom_trans, eqToHom_refl]\n      rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.Œì_obj","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : Opposite (AlgebraicGeometry.PresheafedSpace C)\n‚ä¢ Eq (AlgebraicGeometry.PresheafedSpace.Œì.obj X) ((Opposite.unop X).presheaf.obj { unop := Top.top })","decl":"/-- The global sections, notated Gamma.\n-/\n@[simps]\ndef Œì : (PresheafedSpace C)·µí·µñ ‚•§ C where\n  obj X := (unop X).presheaf.obj (op ‚ä§)\n  map f := f.unop.c.app (op ‚ä§)\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.Œì_map","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX‚úù Y‚úù : Opposite (AlgebraicGeometry.PresheafedSpace C)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (AlgebraicGeometry.PresheafedSpace.Œì.map f) (f.unop.c.app { unop := Top.top })","decl":"/-- The global sections, notated Gamma.\n-/\n@[simps]\ndef Œì : (PresheafedSpace C)·µí·µñ ‚•§ C where\n  obj X := (unop X).presheaf.obj (op ‚ä§)\n  map f := f.unop.c.app (op ‚ä§)\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.Œì_obj_op","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : AlgebraicGeometry.PresheafedSpace C\n‚ä¢ Eq (AlgebraicGeometry.PresheafedSpace.Œì.obj { unop := X }) (X.presheaf.obj { unop := Top.top })","decl":"theorem Œì_obj_op (X : PresheafedSpace C) : Œì.obj (op X) = X.presheaf.obj (op ‚ä§) :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.Œì_map_op","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX Y : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom X Y\n‚ä¢ Eq (AlgebraicGeometry.PresheafedSpace.Œì.map f.op) (f.c.app { unop := Top.top })","decl":"theorem Œì_map_op {X Y : PresheafedSpace C} (f : X ‚ü∂ Y) : Œì.map f.op = f.c.app (op ‚ä§) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.mapPresheaf_obj_X","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nX : AlgebraicGeometry.PresheafedSpace C\n‚ä¢ Eq ‚Üë(F.mapPresheaf.obj X) ‚ÜëX","decl":"@[simp]\ntheorem mapPresheaf_obj_X (F : C ‚•§ D) (X : PresheafedSpace C) :\n    (F.mapPresheaf.obj X : TopCat) = (X : TopCat) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.mapPresheaf_obj_presheaf","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nX : AlgebraicGeometry.PresheafedSpace C\n‚ä¢ Eq (F.mapPresheaf.obj X).presheaf (CategoryTheory.Functor.comp X.presheaf F)","decl":"@[simp]\ntheorem mapPresheaf_obj_presheaf (F : C ‚•§ D) (X : PresheafedSpace C) :\n    (F.mapPresheaf.obj X).presheaf = X.presheaf ‚ãô F :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.mapPresheaf_map_f","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nX Y : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom X Y\n‚ä¢ Eq (F.mapPresheaf.map f).base f.base","decl":"@[simp]\ntheorem mapPresheaf_map_f (F : C ‚•§ D) {X Y : PresheafedSpace C} (f : X ‚ü∂ Y) :\n    (F.mapPresheaf.map f).base = f.base :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.mapPresheaf_map_c","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_4, u_2} D\nF : CategoryTheory.Functor C D\nX Y : AlgebraicGeometry.PresheafedSpace C\nf : Quiver.Hom X Y\n‚ä¢ Eq (F.mapPresheaf.map f).c (CategoryTheory.whiskerRight f.c F)","decl":"@[simp]\ntheorem mapPresheaf_map_c (F : C ‚•§ D) {X Y : PresheafedSpace C} (f : X ‚ü∂ Y) :\n    (F.mapPresheaf.map f).c = whiskerRight f.c F :=\n  rfl\n\n"}
