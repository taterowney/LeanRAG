{"name":"PowerBasis.mk.sizeOf_spec","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"R : Type u_7\nS : Type u_8\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\ninst✝² : Algebra R S\ninst✝¹ : SizeOf R\ninst✝ : SizeOf S\ngen : S\ndim : Nat\nbasis : Basis (Fin dim) R S\nbasis_eq_pow : ∀ (i : Fin dim), Eq (basis i) (HPow.hPow gen ↑i)\n⊢ Eq (SizeOf.sizeOf { gen := gen, dim := dim, basis := basis, basis_eq_pow := basis_eq_pow }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf gen)) (SizeOf.sizeOf dim)) (SizeOf.sizeOf basis))","decl":"/-- `pb : PowerBasis R S` states that `1, pb.gen, ..., pb.gen ^ (pb.dim - 1)`\nis a basis for the `R`-algebra `S` (viewed as `R`-module).\n\nThis is a structure, not a class, since the same algebra can have many power bases.\nFor the common case where `S` is defined by adjoining an integral element to `R`,\nthe canonical power basis is given by `{Algebra,IntermediateField}.adjoin.powerBasis`.\n-/\nstructure PowerBasis (R S : Type*) [CommRing R] [Ring S] [Algebra R S] where\n  gen : S\n  dim : ℕ\n  basis : Basis (Fin dim) R S\n  basis_eq_pow : ∀ (i), basis i = gen ^ (i : ℕ)\n\n-- this is usually not needed because of `basis_eq_pow` but can be needed in some cases;\n-- in such circumstances, add it manually using `@[simps dim gen basis]`.\n"}
{"name":"PowerBasis.mk.inj","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"R : Type u_7\nS : Type u_8\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\ngen✝ : S\ndim✝ : Nat\nbasis✝ : Basis (Fin dim✝) R S\nbasis_eq_pow✝ : ∀ (i : Fin dim✝), Eq (basis✝ i) (HPow.hPow gen✝ ↑i)\ngen : S\ndim : Nat\nbasis : Basis (Fin dim) R S\nbasis_eq_pow : ∀ (i : Fin dim), Eq (basis i) (HPow.hPow gen ↑i)\nx✝ : Eq { gen := gen✝, dim := dim✝, basis := basis✝, basis_eq_pow := basis_eq_pow✝ } { gen := gen, dim := dim, basis := basis, basis_eq_pow := basis_eq_pow }\n⊢ And (Eq gen✝ gen) (And (Eq dim✝ dim) (HEq basis✝ basis))","decl":"/-- `pb : PowerBasis R S` states that `1, pb.gen, ..., pb.gen ^ (pb.dim - 1)`\nis a basis for the `R`-algebra `S` (viewed as `R`-module).\n\nThis is a structure, not a class, since the same algebra can have many power bases.\nFor the common case where `S` is defined by adjoining an integral element to `R`,\nthe canonical power basis is given by `{Algebra,IntermediateField}.adjoin.powerBasis`.\n-/\nstructure PowerBasis (R S : Type*) [CommRing R] [Ring S] [Algebra R S] where\n  gen : S\n  dim : ℕ\n  basis : Basis (Fin dim) R S\n  basis_eq_pow : ∀ (i), basis i = gen ^ (i : ℕ)\n\n-- this is usually not needed because of `basis_eq_pow` but can be needed in some cases;\n-- in such circumstances, add it manually using `@[simps dim gen basis]`.\n"}
{"name":"PowerBasis.mk.injEq","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"R : Type u_7\nS : Type u_8\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\ngen✝ : S\ndim✝ : Nat\nbasis✝ : Basis (Fin dim✝) R S\nbasis_eq_pow✝ : ∀ (i : Fin dim✝), Eq (basis✝ i) (HPow.hPow gen✝ ↑i)\ngen : S\ndim : Nat\nbasis : Basis (Fin dim) R S\nbasis_eq_pow : ∀ (i : Fin dim), Eq (basis i) (HPow.hPow gen ↑i)\n⊢ Eq (Eq { gen := gen✝, dim := dim✝, basis := basis✝, basis_eq_pow := basis_eq_pow✝ } { gen := gen, dim := dim, basis := basis, basis_eq_pow := basis_eq_pow }) (And (Eq gen✝ gen) (And (Eq dim✝ dim) (HEq basis✝ basis)))","decl":"/-- `pb : PowerBasis R S` states that `1, pb.gen, ..., pb.gen ^ (pb.dim - 1)`\nis a basis for the `R`-algebra `S` (viewed as `R`-module).\n\nThis is a structure, not a class, since the same algebra can have many power bases.\nFor the common case where `S` is defined by adjoining an integral element to `R`,\nthe canonical power basis is given by `{Algebra,IntermediateField}.adjoin.powerBasis`.\n-/\nstructure PowerBasis (R S : Type*) [CommRing R] [Ring S] [Algebra R S] where\n  gen : S\n  dim : ℕ\n  basis : Basis (Fin dim) R S\n  basis_eq_pow : ∀ (i), basis i = gen ^ (i : ℕ)\n\n-- this is usually not needed because of `basis_eq_pow` but can be needed in some cases;\n-- in such circumstances, add it manually using `@[simps dim gen basis]`.\n"}
{"name":"PowerBasis.basis_eq_pow","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"R : Type u_7\nS : Type u_8\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nself : PowerBasis R S\ni : Fin self.dim\n⊢ Eq (self.basis i) (HPow.hPow self.gen ↑i)","decl":"/-- `pb : PowerBasis R S` states that `1, pb.gen, ..., pb.gen ^ (pb.dim - 1)`\nis a basis for the `R`-algebra `S` (viewed as `R`-module).\n\nThis is a structure, not a class, since the same algebra can have many power bases.\nFor the common case where `S` is defined by adjoining an integral element to `R`,\nthe canonical power basis is given by `{Algebra,IntermediateField}.adjoin.powerBasis`.\n-/\nstructure PowerBasis (R S : Type*) [CommRing R] [Ring S] [Algebra R S] where\n  gen : S\n  dim : ℕ\n  basis : Basis (Fin dim) R S\n  basis_eq_pow : ∀ (i), basis i = gen ^ (i : ℕ)\n\n-- this is usually not needed because of `basis_eq_pow` but can be needed in some cases;\n-- in such circumstances, add it manually using `@[simps dim gen basis]`.\n"}
{"name":"PowerBasis.coe_basis","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\npb : PowerBasis R S\n⊢ Eq ⇑pb.basis fun i => HPow.hPow pb.gen ↑i","decl":"@[simp]\ntheorem coe_basis (pb : PowerBasis R S) : ⇑pb.basis = fun i : Fin pb.dim => pb.gen ^ (i : ℕ) :=\n  funext pb.basis_eq_pow\n\n"}
{"name":"PowerBasis.finite","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\npb : PowerBasis R S\n⊢ Module.Finite R S","decl":"/-- Cannot be an instance because `PowerBasis` cannot be a class. -/\ntheorem finite (pb : PowerBasis R S) : Module.Finite R S := .of_basis pb.basis\n\n\n"}
{"name":"PowerBasis.finrank","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\ninst✝ : StrongRankCondition R\npb : PowerBasis R S\n⊢ Eq (Module.finrank R S) pb.dim","decl":"theorem finrank [StrongRankCondition R] (pb : PowerBasis R S) :\n    Module.finrank R S = pb.dim := by\n  rw [Module.finrank_eq_card_basis pb.basis, Fintype.card_fin]\n\n"}
{"name":"PowerBasis.mem_span_pow'","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nx y : S\nd : Nat\n⊢ Iff (Membership.mem (Submodule.span R (Set.range fun i => HPow.hPow x ↑i)) y) (Exists fun f => And (LT.lt f.degree ↑d) (Eq y ((Polynomial.aeval x) f)))","decl":"theorem mem_span_pow' {x y : S} {d : ℕ} :\n    y ∈ Submodule.span R (Set.range fun i : Fin d => x ^ (i : ℕ)) ↔\n      ∃ f : R[X], f.degree < d ∧ y = aeval x f := by\n  have : (Set.range fun i : Fin d => x ^ (i : ℕ)) = (fun i : ℕ => x ^ i) '' ↑(Finset.range d) := by\n    ext n\n    simp_rw [Set.mem_range, Set.mem_image, Finset.mem_coe, Finset.mem_range]\n    exact ⟨fun ⟨⟨i, hi⟩, hy⟩ => ⟨i, hi, hy⟩, fun ⟨i, hi, hy⟩ => ⟨⟨i, hi⟩, hy⟩⟩\n  simp only [this, mem_span_image_iff_linearCombination, degree_lt_iff_coeff_zero, Finsupp.support,\n    exists_iff_exists_finsupp, coeff, aeval_def, eval₂RingHom', eval₂_eq_sum, Polynomial.sum,\n    mem_supported', linearCombination, Finsupp.sum, Algebra.smul_def, eval₂_zero, exists_prop,\n    LinearMap.id_coe, eval₂_one, id, not_lt, Finsupp.coe_lsum, LinearMap.coe_smulRight,\n    Finset.mem_range, AlgHom.coe_mks, Finset.mem_coe]\n  simp_rw [@eq_comm _ y]\n  exact Iff.rfl\n\n"}
{"name":"PowerBasis.mem_span_pow","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nx y : S\nd : Nat\nhd : Ne d 0\n⊢ Iff (Membership.mem (Submodule.span R (Set.range fun i => HPow.hPow x ↑i)) y) (Exists fun f => And (LT.lt f.natDegree d) (Eq y ((Polynomial.aeval x) f)))","decl":"theorem mem_span_pow {x y : S} {d : ℕ} (hd : d ≠ 0) :\n    y ∈ Submodule.span R (Set.range fun i : Fin d => x ^ (i : ℕ)) ↔\n      ∃ f : R[X], f.natDegree < d ∧ y = aeval x f := by\n  rw [mem_span_pow']\n  constructor <;>\n    · rintro ⟨f, h, hy⟩\n      refine ⟨f, ?_, hy⟩\n      by_cases hf : f = 0\n      · simp only [hf, natDegree_zero, degree_zero] at h ⊢\n        first | exact lt_of_le_of_ne (Nat.zero_le d) hd.symm | exact WithBot.bot_lt_coe d\n      simp_all only [degree_eq_natDegree hf]\n      · first | exact WithBot.coe_lt_coe.1 h | exact WithBot.coe_lt_coe.2 h\n\n"}
{"name":"PowerBasis.dim_ne_zero","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\ninst✝ : Nontrivial S\npb : PowerBasis R S\n⊢ Ne pb.dim 0","decl":"theorem dim_ne_zero [Nontrivial S] (pb : PowerBasis R S) : pb.dim ≠ 0 := fun h =>\n  not_nonempty_iff.mpr (h.symm ▸ Fin.isEmpty : IsEmpty (Fin pb.dim)) pb.basis.index_nonempty\n\n"}
{"name":"PowerBasis.dim_pos","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\ninst✝ : Nontrivial S\npb : PowerBasis R S\n⊢ LT.lt 0 pb.dim","decl":"theorem dim_pos [Nontrivial S] (pb : PowerBasis R S) : 0 < pb.dim :=\n  Nat.pos_of_ne_zero pb.dim_ne_zero\n\n"}
{"name":"PowerBasis.exists_eq_aeval","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\ninst✝ : Nontrivial S\npb : PowerBasis R S\ny : S\n⊢ Exists fun f => And (LT.lt f.natDegree pb.dim) (Eq y ((Polynomial.aeval pb.gen) f))","decl":"theorem exists_eq_aeval [Nontrivial S] (pb : PowerBasis R S) (y : S) :\n    ∃ f : R[X], f.natDegree < pb.dim ∧ y = aeval pb.gen f :=\n  (mem_span_pow pb.dim_ne_zero).mp (by simpa using pb.basis.mem_span y)\n\n"}
{"name":"PowerBasis.exists_eq_aeval'","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\npb : PowerBasis R S\ny : S\n⊢ Exists fun f => Eq y ((Polynomial.aeval pb.gen) f)","decl":"theorem exists_eq_aeval' (pb : PowerBasis R S) (y : S) : ∃ f : R[X], y = aeval pb.gen f := by\n  nontriviality S\n  obtain ⟨f, _, hf⟩ := exists_eq_aeval pb y\n  exact ⟨f, hf⟩\n\n"}
{"name":"PowerBasis.algHom_ext","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\ninst✝² : Algebra R S\nS' : Type u_7\ninst✝¹ : Semiring S'\ninst✝ : Algebra R S'\npb : PowerBasis R S\nf g : AlgHom R S S'\nh : Eq (f pb.gen) (g pb.gen)\n⊢ Eq f g","decl":"theorem algHom_ext {S' : Type*} [Semiring S'] [Algebra R S'] (pb : PowerBasis R S)\n    ⦃f g : S →ₐ[R] S'⦄ (h : f pb.gen = g pb.gen) : f = g := by\n  ext x\n  obtain ⟨f, rfl⟩ := pb.exists_eq_aeval' x\n  rw [← Polynomial.aeval_algHom_apply, ← Polynomial.aeval_algHom_apply, h]\n\n"}
{"name":"PowerBasis.exists_smodEq","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"A : Type u_4\nB : Type u_5\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\npb : PowerBasis A B\nb : B\n⊢ Exists fun a => SModEq (Ideal.span (Singleton.singleton pb.gen)) b ((algebraMap A B) a)","decl":"open Ideal Finset Submodule in\ntheorem exists_smodEq (pb : PowerBasis A B) (b : B) :\n    ∃ a, SModEq (Ideal.span ({pb.gen})) b (algebraMap A B a) := by\n  rcases subsingleton_or_nontrivial B\n  · exact ⟨0, by rw [SModEq, Subsingleton.eq_zero b, _root_.map_zero]⟩\n  refine ⟨pb.basis.repr b ⟨0, pb.dim_pos⟩, ?_⟩\n  have H := pb.basis.sum_repr b\n  rw [← insert_erase (mem_univ ⟨0, pb.dim_pos⟩), sum_insert (not_mem_erase _ _)] at H\n  rw [SModEq, ← add_zero (algebraMap _ _ _), Quotient.mk_add]\n  nth_rewrite 1 [← H]\n  rw [Quotient.mk_add]\n  congr 1\n  · simp [Algebra.algebraMap_eq_smul_one ((pb.basis.repr b) _)]\n  · rw [Quotient.mk_zero, Quotient.mk_eq_zero, coe_basis]\n    refine sum_mem _ (fun i hi ↦ ?_)\n    rw [Algebra.smul_def']\n    refine Ideal.mul_mem_left _ _ <| Ideal.pow_mem_of_mem _ (Ideal.subset_span (by simp)) _ <|\n      Nat.pos_of_ne_zero <| fun h ↦ not_mem_erase i univ <| Fin.eq_mk_iff_val_eq.2 h ▸ hi\n\n"}
{"name":"PowerBasis.exists_gen_dvd_sub","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"A : Type u_4\nB : Type u_5\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : Algebra A B\npb : PowerBasis A B\nb : B\n⊢ Exists fun a => Dvd.dvd pb.gen (HSub.hSub b ((algebraMap A B) a))","decl":"open Submodule.Quotient in\ntheorem exists_gen_dvd_sub (pb : PowerBasis A B) (b : B) : ∃ a, pb.gen ∣ b - algebraMap A B a := by\n  simpa [← Ideal.mem_span_singleton, ← mk_eq_zero, mk_sub, sub_eq_zero] using pb.exists_smodEq b\n\n"}
{"name":"PowerBasis.aeval_minpolyGen","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝² : Ring S\nA : Type u_4\ninst✝¹ : CommRing A\ninst✝ : Algebra A S\npb : PowerBasis A S\n⊢ Eq ((Polynomial.aeval pb.gen) pb.minpolyGen) 0","decl":"theorem aeval_minpolyGen (pb : PowerBasis A S) : aeval pb.gen (minpolyGen pb) = 0 := by\n  simp_rw [minpolyGen, map_sub, map_sum, map_mul, map_pow, aeval_C, ← Algebra.smul_def, aeval_X]\n  refine sub_eq_zero.mpr ((pb.basis.linearCombination_repr (pb.gen ^ pb.dim)).symm.trans ?_)\n  rw [Finsupp.linearCombination_apply, Finsupp.sum_fintype] <;>\n    simp only [pb.coe_basis, zero_smul, eq_self_iff_true, imp_true_iff]\n\n"}
{"name":"PowerBasis.minpolyGen_monic","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝² : Ring S\nA : Type u_4\ninst✝¹ : CommRing A\ninst✝ : Algebra A S\npb : PowerBasis A S\n⊢ pb.minpolyGen.Monic","decl":"theorem minpolyGen_monic (pb : PowerBasis A S) : Monic (minpolyGen pb) := by\n  nontriviality A\n  apply (monic_X_pow _).sub_of_left _\n  rw [degree_X_pow]\n  exact degree_sum_fin_lt _\n\n"}
{"name":"PowerBasis.dim_le_natDegree_of_root","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝² : Ring S\nA : Type u_4\ninst✝¹ : CommRing A\ninst✝ : Algebra A S\npb : PowerBasis A S\np : Polynomial A\nne_zero : Ne p 0\nroot : Eq ((Polynomial.aeval pb.gen) p) 0\n⊢ LE.le pb.dim p.natDegree","decl":"theorem dim_le_natDegree_of_root (pb : PowerBasis A S) {p : A[X]} (ne_zero : p ≠ 0)\n    (root : aeval pb.gen p = 0) : pb.dim ≤ p.natDegree := by\n  refine le_of_not_lt fun hlt => ne_zero ?_\n  rw [p.as_sum_range' _ hlt, Finset.sum_range]\n  refine Fintype.sum_eq_zero _ fun i => ?_\n  simp_rw [aeval_eq_sum_range' hlt, Finset.sum_range, ← pb.basis_eq_pow] at root\n  have := Fintype.linearIndependent_iff.1 pb.basis.linearIndependent _ root\n  rw [this, monomial_zero_right]\n\n"}
{"name":"PowerBasis.dim_le_degree_of_root","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝² : Ring S\nA : Type u_4\ninst✝¹ : CommRing A\ninst✝ : Algebra A S\nh : PowerBasis A S\np : Polynomial A\nne_zero : Ne p 0\nroot : Eq ((Polynomial.aeval h.gen) p) 0\n⊢ LE.le (↑h.dim) p.degree","decl":"theorem dim_le_degree_of_root (h : PowerBasis A S) {p : A[X]} (ne_zero : p ≠ 0)\n    (root : aeval h.gen p = 0) : ↑h.dim ≤ p.degree := by\n  rw [degree_eq_natDegree ne_zero]\n  exact WithBot.coe_le_coe.2 (h.dim_le_natDegree_of_root ne_zero root)\n\n"}
{"name":"PowerBasis.degree_minpolyGen","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝³ : Ring S\nA : Type u_4\ninst✝² : CommRing A\ninst✝¹ : Algebra A S\ninst✝ : Nontrivial A\npb : PowerBasis A S\n⊢ Eq pb.minpolyGen.degree ↑pb.dim","decl":"theorem degree_minpolyGen [Nontrivial A] (pb : PowerBasis A S) :\n    degree (minpolyGen pb) = pb.dim := by\n  unfold minpolyGen\n  rw [degree_sub_eq_left_of_degree_lt] <;> rw [degree_X_pow]\n  apply degree_sum_fin_lt\n\n"}
{"name":"PowerBasis.natDegree_minpolyGen","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝³ : Ring S\nA : Type u_4\ninst✝² : CommRing A\ninst✝¹ : Algebra A S\ninst✝ : Nontrivial A\npb : PowerBasis A S\n⊢ Eq pb.minpolyGen.natDegree pb.dim","decl":"theorem natDegree_minpolyGen [Nontrivial A] (pb : PowerBasis A S) :\n    natDegree (minpolyGen pb) = pb.dim :=\n  natDegree_eq_of_degree_eq_some pb.degree_minpolyGen\n\n"}
{"name":"PowerBasis.minpolyGen_eq","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝² : Ring S\nA : Type u_4\ninst✝¹ : CommRing A\ninst✝ : Algebra A S\npb : PowerBasis A S\n⊢ Eq pb.minpolyGen (minpoly A pb.gen)","decl":"@[simp]\ntheorem minpolyGen_eq (pb : PowerBasis A S) : pb.minpolyGen = minpoly A pb.gen := by\n  nontriviality A\n  refine minpoly.unique' A _ pb.minpolyGen_monic pb.aeval_minpolyGen fun q hq =>\n    or_iff_not_imp_left.2 fun hn0 h0 => ?_\n  exact (pb.dim_le_degree_of_root hn0 h0).not_lt (pb.degree_minpolyGen ▸ hq)\n\n"}
{"name":"PowerBasis.isIntegral_gen","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝² : Ring S\nA : Type u_4\ninst✝¹ : CommRing A\ninst✝ : Algebra A S\npb : PowerBasis A S\n⊢ IsIntegral A pb.gen","decl":"theorem isIntegral_gen (pb : PowerBasis A S) : IsIntegral A pb.gen :=\n  ⟨minpolyGen pb, minpolyGen_monic pb, aeval_minpolyGen pb⟩\n\n"}
{"name":"PowerBasis.degree_minpoly","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝³ : Ring S\nA : Type u_4\ninst✝² : CommRing A\ninst✝¹ : Algebra A S\ninst✝ : Nontrivial A\npb : PowerBasis A S\n⊢ Eq (minpoly A pb.gen).degree ↑pb.dim","decl":"@[simp]\ntheorem degree_minpoly [Nontrivial A] (pb : PowerBasis A S) :\n    degree (minpoly A pb.gen) = pb.dim := by rw [← minpolyGen_eq, degree_minpolyGen]\n\n"}
{"name":"PowerBasis.natDegree_minpoly","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝³ : Ring S\nA : Type u_4\ninst✝² : CommRing A\ninst✝¹ : Algebra A S\ninst✝ : Nontrivial A\npb : PowerBasis A S\n⊢ Eq (minpoly A pb.gen).natDegree pb.dim","decl":"@[simp]\ntheorem natDegree_minpoly [Nontrivial A] (pb : PowerBasis A S) :\n    (minpoly A pb.gen).natDegree = pb.dim := by rw [← minpolyGen_eq, natDegree_minpolyGen]\n\n"}
{"name":"PowerBasis.leftMulMatrix","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝² : Ring S\nA : Type u_4\ninst✝¹ : CommRing A\ninst✝ : Algebra A S\npb : PowerBasis A S\n⊢ Eq ((Algebra.leftMulMatrix pb.basis) pb.gen) (Matrix.of fun i j => ite (Eq (HAdd.hAdd (↑j) 1) pb.dim) (Neg.neg (pb.minpolyGen.coeff ↑i)) (ite (Eq (↑i) (HAdd.hAdd (↑j) 1)) 1 0))","decl":"protected theorem leftMulMatrix (pb : PowerBasis A S) : Algebra.leftMulMatrix pb.basis pb.gen =\n    @Matrix.of (Fin pb.dim) (Fin pb.dim) _ fun i j =>\n      if ↑j + 1 = pb.dim then -pb.minpolyGen.coeff ↑i else if (i : ℕ) = j + 1 then 1 else 0 := by\n  cases subsingleton_or_nontrivial A; · subsingleton\n  rw [Algebra.leftMulMatrix_apply, ← LinearEquiv.eq_symm_apply, LinearMap.toMatrix_symm]\n  refine pb.basis.ext fun k => ?_\n  simp_rw [Matrix.toLin_self, Matrix.of_apply, pb.basis_eq_pow]\n  apply (pow_succ' _ _).symm.trans\n  split_ifs with h\n  · simp_rw [h, neg_smul, Finset.sum_neg_distrib, eq_neg_iff_add_eq_zero]\n    convert pb.aeval_minpolyGen\n    rw [add_comm, aeval_eq_sum_range, Finset.sum_range_succ, ← leadingCoeff,\n      pb.minpolyGen_monic.leadingCoeff, one_smul, natDegree_minpolyGen, Finset.sum_range]\n  · rw [Fintype.sum_eq_single (⟨(k : ℕ) + 1, lt_of_le_of_ne k.2 h⟩ : Fin pb.dim), if_pos, one_smul]\n    · rfl\n    intro x hx\n    rw [if_neg, zero_smul]\n    apply mt Fin.ext hx\n\n"}
{"name":"PowerBasis.constr_pow_aeval","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁴ : Ring S\nA : Type u_4\ninst✝³ : CommRing A\ninst✝² : Algebra A S\nS' : Type u_7\ninst✝¹ : Ring S'\ninst✝ : Algebra A S'\npb : PowerBasis A S\ny : S'\nhy : Eq ((Polynomial.aeval y) (minpoly A pb.gen)) 0\nf : Polynomial A\n⊢ Eq (((pb.basis.constr A) fun i => HPow.hPow y ↑i) ((Polynomial.aeval pb.gen) f)) ((Polynomial.aeval y) f)","decl":"theorem constr_pow_aeval (pb : PowerBasis A S) {y : S'} (hy : aeval y (minpoly A pb.gen) = 0)\n    (f : A[X]) : pb.basis.constr A (fun i => y ^ (i : ℕ)) (aeval pb.gen f) = aeval y f := by\n  cases subsingleton_or_nontrivial A\n  · rw [(Subsingleton.elim _ _ : f = 0), aeval_zero, map_zero, aeval_zero]\n  rw [← aeval_modByMonic_eq_self_of_root (minpoly.monic pb.isIntegral_gen) (minpoly.aeval _ _), ←\n    @aeval_modByMonic_eq_self_of_root _ _ _ _ _ f _ (minpoly.monic pb.isIntegral_gen) y hy]\n  by_cases hf : f %ₘ minpoly A pb.gen = 0\n  · simp only [hf, map_zero]\n  have : (f %ₘ minpoly A pb.gen).natDegree < pb.dim := by\n    rw [← pb.natDegree_minpoly]\n    apply natDegree_lt_natDegree hf\n    exact degree_modByMonic_lt _ (minpoly.monic pb.isIntegral_gen)\n  rw [aeval_eq_sum_range' this, aeval_eq_sum_range' this, map_sum]\n  refine Finset.sum_congr rfl fun i (hi : i ∈ Finset.range pb.dim) => ?_\n  rw [Finset.mem_range] at hi\n  rw [LinearMap.map_smul]\n  congr\n  rw [← Fin.val_mk hi, ← pb.basis_eq_pow ⟨i, hi⟩, Basis.constr_basis]\n\n"}
{"name":"PowerBasis.constr_pow_gen","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁴ : Ring S\nA : Type u_4\ninst✝³ : CommRing A\ninst✝² : Algebra A S\nS' : Type u_7\ninst✝¹ : Ring S'\ninst✝ : Algebra A S'\npb : PowerBasis A S\ny : S'\nhy : Eq ((Polynomial.aeval y) (minpoly A pb.gen)) 0\n⊢ Eq (((pb.basis.constr A) fun i => HPow.hPow y ↑i) pb.gen) y","decl":"theorem constr_pow_gen (pb : PowerBasis A S) {y : S'} (hy : aeval y (minpoly A pb.gen) = 0) :\n    pb.basis.constr A (fun i => y ^ (i : ℕ)) pb.gen = y := by\n  convert pb.constr_pow_aeval hy X <;> rw [aeval_X]\n\n"}
{"name":"PowerBasis.constr_pow_algebraMap","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁴ : Ring S\nA : Type u_4\ninst✝³ : CommRing A\ninst✝² : Algebra A S\nS' : Type u_7\ninst✝¹ : Ring S'\ninst✝ : Algebra A S'\npb : PowerBasis A S\ny : S'\nhy : Eq ((Polynomial.aeval y) (minpoly A pb.gen)) 0\nx : A\n⊢ Eq (((pb.basis.constr A) fun i => HPow.hPow y ↑i) ((algebraMap A S) x)) ((algebraMap A S') x)","decl":"theorem constr_pow_algebraMap (pb : PowerBasis A S) {y : S'} (hy : aeval y (minpoly A pb.gen) = 0)\n    (x : A) : pb.basis.constr A (fun i => y ^ (i : ℕ)) (algebraMap A S x) = algebraMap A S' x := by\n  convert pb.constr_pow_aeval hy (C x) <;> rw [aeval_C]\n\n"}
{"name":"PowerBasis.constr_pow_mul","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁴ : Ring S\nA : Type u_4\ninst✝³ : CommRing A\ninst✝² : Algebra A S\nS' : Type u_7\ninst✝¹ : Ring S'\ninst✝ : Algebra A S'\npb : PowerBasis A S\ny : S'\nhy : Eq ((Polynomial.aeval y) (minpoly A pb.gen)) 0\nx x' : S\n⊢ Eq (((pb.basis.constr A) fun i => HPow.hPow y ↑i) (HMul.hMul x x')) (HMul.hMul (((pb.basis.constr A) fun i => HPow.hPow y ↑i) x) (((pb.basis.constr A) fun i => HPow.hPow y ↑i) x'))","decl":"theorem constr_pow_mul (pb : PowerBasis A S) {y : S'} (hy : aeval y (minpoly A pb.gen) = 0)\n    (x x' : S) : pb.basis.constr A (fun i => y ^ (i : ℕ)) (x * x') =\n      pb.basis.constr A (fun i => y ^ (i : ℕ)) x * pb.basis.constr A (fun i => y ^ (i : ℕ)) x' := by\n  obtain ⟨f, rfl⟩ := pb.exists_eq_aeval' x\n  obtain ⟨g, rfl⟩ := pb.exists_eq_aeval' x'\n  simp only [← aeval_mul, pb.constr_pow_aeval hy]\n\n"}
{"name":"PowerBasis.lift_gen","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁴ : Ring S\nA : Type u_4\ninst✝³ : CommRing A\ninst✝² : Algebra A S\nS' : Type u_7\ninst✝¹ : Ring S'\ninst✝ : Algebra A S'\npb : PowerBasis A S\ny : S'\nhy : Eq ((Polynomial.aeval y) (minpoly A pb.gen)) 0\n⊢ Eq ((pb.lift y hy) pb.gen) y","decl":"@[simp]\ntheorem lift_gen (pb : PowerBasis A S) (y : S') (hy : aeval y (minpoly A pb.gen) = 0) :\n    pb.lift y hy pb.gen = y :=\n  pb.constr_pow_gen hy\n\n"}
{"name":"PowerBasis.lift_aeval","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁴ : Ring S\nA : Type u_4\ninst✝³ : CommRing A\ninst✝² : Algebra A S\nS' : Type u_7\ninst✝¹ : Ring S'\ninst✝ : Algebra A S'\npb : PowerBasis A S\ny : S'\nhy : Eq ((Polynomial.aeval y) (minpoly A pb.gen)) 0\nf : Polynomial A\n⊢ Eq ((pb.lift y hy) ((Polynomial.aeval pb.gen) f)) ((Polynomial.aeval y) f)","decl":"@[simp]\ntheorem lift_aeval (pb : PowerBasis A S) (y : S') (hy : aeval y (minpoly A pb.gen) = 0) (f : A[X]) :\n    pb.lift y hy (aeval pb.gen f) = aeval y f :=\n  pb.constr_pow_aeval hy f\n\n"}
{"name":"PowerBasis.liftEquiv_apply_coe","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁴ : Ring S\nA : Type u_4\ninst✝³ : CommRing A\ninst✝² : Algebra A S\nS' : Type u_7\ninst✝¹ : Ring S'\ninst✝ : Algebra A S'\npb : PowerBasis A S\nf : AlgHom A S S'\n⊢ Eq (↑(pb.liftEquiv f)) (f pb.gen)","decl":"/-- `pb.liftEquiv` states that roots of the minimal polynomial of `pb.gen` correspond to\nmaps sending `pb.gen` to that root.\n\nThis is the bundled equiv version of `PowerBasis.lift`.\nIf the codomain of the `AlgHom`s is an integral domain, then the roots form a multiset,\nsee `liftEquiv'` for the corresponding statement.\n-/\n@[simps]\nnoncomputable def liftEquiv (pb : PowerBasis A S) :\n    (S →ₐ[A] S') ≃ { y : S' // aeval y (minpoly A pb.gen) = 0 } where\n  toFun f := ⟨f pb.gen, by rw [aeval_algHom_apply, minpoly.aeval, map_zero]⟩\n  invFun y := pb.lift y y.2\n  left_inv _ := pb.algHom_ext <| lift_gen _ _ _\n  right_inv y := Subtype.ext <| lift_gen _ _ y.prop\n\n"}
{"name":"PowerBasis.liftEquiv_symm_apply","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁴ : Ring S\nA : Type u_4\ninst✝³ : CommRing A\ninst✝² : Algebra A S\nS' : Type u_7\ninst✝¹ : Ring S'\ninst✝ : Algebra A S'\npb : PowerBasis A S\ny : Subtype fun y => Eq ((Polynomial.aeval y) (minpoly A pb.gen)) 0\n⊢ Eq (pb.liftEquiv.symm y) (pb.lift ↑y ⋯)","decl":"/-- `pb.liftEquiv` states that roots of the minimal polynomial of `pb.gen` correspond to\nmaps sending `pb.gen` to that root.\n\nThis is the bundled equiv version of `PowerBasis.lift`.\nIf the codomain of the `AlgHom`s is an integral domain, then the roots form a multiset,\nsee `liftEquiv'` for the corresponding statement.\n-/\n@[simps]\nnoncomputable def liftEquiv (pb : PowerBasis A S) :\n    (S →ₐ[A] S') ≃ { y : S' // aeval y (minpoly A pb.gen) = 0 } where\n  toFun f := ⟨f pb.gen, by rw [aeval_algHom_apply, minpoly.aeval, map_zero]⟩\n  invFun y := pb.lift y y.2\n  left_inv _ := pb.algHom_ext <| lift_gen _ _ _\n  right_inv y := Subtype.ext <| lift_gen _ _ y.prop\n\n"}
{"name":"PowerBasis.liftEquiv'_symm_apply_apply","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁵ : Ring S\nA : Type u_4\nB : Type u_5\ninst✝⁴ : CommRing A\ninst✝³ : CommRing B\ninst✝² : Algebra A B\ninst✝¹ : Algebra A S\ninst✝ : IsDomain B\npb : PowerBasis A S\na✝ : Subtype fun y => Membership.mem ((minpoly A pb.gen).aroots B) y\n⊢ Eq ⇑(pb.liftEquiv'.symm a✝) ⇑((pb.basis.constr A) fun i => HPow.hPow ↑a✝ ↑i)","decl":"/-- `pb.liftEquiv'` states that elements of the root set of the minimal\npolynomial of `pb.gen` correspond to maps sending `pb.gen` to that root. -/\n@[simps! (config := .asFn)]\nnoncomputable def liftEquiv' [IsDomain B] (pb : PowerBasis A S) :\n    (S →ₐ[A] B) ≃ { y : B // y ∈ (minpoly A pb.gen).aroots B } :=\n  pb.liftEquiv.trans ((Equiv.refl _).subtypeEquiv fun x => by\n    rw [Equiv.refl_apply, mem_roots_iff_aeval_eq_zero]\n    · simp\n    · exact map_monic_ne_zero (minpoly.monic pb.isIntegral_gen))\n\n"}
{"name":"PowerBasis.liftEquiv'_apply_coe","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁵ : Ring S\nA : Type u_4\nB : Type u_5\ninst✝⁴ : CommRing A\ninst✝³ : CommRing B\ninst✝² : Algebra A B\ninst✝¹ : Algebra A S\ninst✝ : IsDomain B\npb : PowerBasis A S\na✝ : AlgHom A S B\n⊢ Eq (↑(pb.liftEquiv' a✝)) (a✝ pb.gen)","decl":"/-- `pb.liftEquiv'` states that elements of the root set of the minimal\npolynomial of `pb.gen` correspond to maps sending `pb.gen` to that root. -/\n@[simps! (config := .asFn)]\nnoncomputable def liftEquiv' [IsDomain B] (pb : PowerBasis A S) :\n    (S →ₐ[A] B) ≃ { y : B // y ∈ (minpoly A pb.gen).aroots B } :=\n  pb.liftEquiv.trans ((Equiv.refl _).subtypeEquiv fun x => by\n    rw [Equiv.refl_apply, mem_roots_iff_aeval_eq_zero]\n    · simp\n    · exact map_monic_ne_zero (minpoly.monic pb.isIntegral_gen))\n\n"}
{"name":"PowerBasis.equivOfRoot_apply","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁴ : Ring S\nA : Type u_4\ninst✝³ : CommRing A\ninst✝² : Algebra A S\nS' : Type u_7\ninst✝¹ : Ring S'\ninst✝ : Algebra A S'\npb : PowerBasis A S\npb' : PowerBasis A S'\nh₁ : Eq ((Polynomial.aeval pb.gen) (minpoly A pb'.gen)) 0\nh₂ : Eq ((Polynomial.aeval pb'.gen) (minpoly A pb.gen)) 0\na : S\n⊢ Eq ((pb.equivOfRoot pb' h₁ h₂) a) ((pb.lift pb'.gen h₂) a)","decl":"/-- `pb.equivOfRoot pb' h₁ h₂` is an equivalence of algebras with the same power basis,\nwhere \"the same\" means that `pb` is a root of `pb'`s minimal polynomial and vice versa.\n\nSee also `PowerBasis.equivOfMinpoly` which takes the hypothesis that the\nminimal polynomials are identical.\n-/\n@[simps! (config := .lemmasOnly) apply]\nnoncomputable def equivOfRoot (pb : PowerBasis A S) (pb' : PowerBasis A S')\n    (h₁ : aeval pb.gen (minpoly A pb'.gen) = 0) (h₂ : aeval pb'.gen (minpoly A pb.gen) = 0) :\n    S ≃ₐ[A] S' :=\n  AlgEquiv.ofAlgHom (pb.lift pb'.gen h₂) (pb'.lift pb.gen h₁)\n    (by\n      ext x\n      obtain ⟨f, hf, rfl⟩ := pb'.exists_eq_aeval' x\n      simp)\n    (by\n      ext x\n      obtain ⟨f, hf, rfl⟩ := pb.exists_eq_aeval' x\n      simp)\n\n"}
{"name":"PowerBasis.equivOfRoot_aeval","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁴ : Ring S\nA : Type u_4\ninst✝³ : CommRing A\ninst✝² : Algebra A S\nS' : Type u_7\ninst✝¹ : Ring S'\ninst✝ : Algebra A S'\npb : PowerBasis A S\npb' : PowerBasis A S'\nh₁ : Eq ((Polynomial.aeval pb.gen) (minpoly A pb'.gen)) 0\nh₂ : Eq ((Polynomial.aeval pb'.gen) (minpoly A pb.gen)) 0\nf : Polynomial A\n⊢ Eq ((pb.equivOfRoot pb' h₁ h₂) ((Polynomial.aeval pb.gen) f)) ((Polynomial.aeval pb'.gen) f)","decl":"@[simp]\ntheorem equivOfRoot_aeval (pb : PowerBasis A S) (pb' : PowerBasis A S')\n    (h₁ : aeval pb.gen (minpoly A pb'.gen) = 0) (h₂ : aeval pb'.gen (minpoly A pb.gen) = 0)\n    (f : A[X]) : pb.equivOfRoot pb' h₁ h₂ (aeval pb.gen f) = aeval pb'.gen f :=\n  pb.lift_aeval _ h₂ _\n\n"}
{"name":"PowerBasis.equivOfRoot_gen","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁴ : Ring S\nA : Type u_4\ninst✝³ : CommRing A\ninst✝² : Algebra A S\nS' : Type u_7\ninst✝¹ : Ring S'\ninst✝ : Algebra A S'\npb : PowerBasis A S\npb' : PowerBasis A S'\nh₁ : Eq ((Polynomial.aeval pb.gen) (minpoly A pb'.gen)) 0\nh₂ : Eq ((Polynomial.aeval pb'.gen) (minpoly A pb.gen)) 0\n⊢ Eq ((pb.equivOfRoot pb' h₁ h₂) pb.gen) pb'.gen","decl":"@[simp]\ntheorem equivOfRoot_gen (pb : PowerBasis A S) (pb' : PowerBasis A S')\n    (h₁ : aeval pb.gen (minpoly A pb'.gen) = 0) (h₂ : aeval pb'.gen (minpoly A pb.gen) = 0) :\n    pb.equivOfRoot pb' h₁ h₂ pb.gen = pb'.gen :=\n  pb.lift_gen _ h₂\n\n"}
{"name":"PowerBasis.equivOfRoot_symm","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁴ : Ring S\nA : Type u_4\ninst✝³ : CommRing A\ninst✝² : Algebra A S\nS' : Type u_7\ninst✝¹ : Ring S'\ninst✝ : Algebra A S'\npb : PowerBasis A S\npb' : PowerBasis A S'\nh₁ : Eq ((Polynomial.aeval pb.gen) (minpoly A pb'.gen)) 0\nh₂ : Eq ((Polynomial.aeval pb'.gen) (minpoly A pb.gen)) 0\n⊢ Eq (pb.equivOfRoot pb' h₁ h₂).symm (pb'.equivOfRoot pb h₂ h₁)","decl":"@[simp]\ntheorem equivOfRoot_symm (pb : PowerBasis A S) (pb' : PowerBasis A S')\n    (h₁ : aeval pb.gen (minpoly A pb'.gen) = 0) (h₂ : aeval pb'.gen (minpoly A pb.gen) = 0) :\n    (pb.equivOfRoot pb' h₁ h₂).symm = pb'.equivOfRoot pb h₂ h₁ :=\n  rfl\n\n"}
{"name":"PowerBasis.equivOfMinpoly_apply","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁴ : Ring S\nA : Type u_4\ninst✝³ : CommRing A\ninst✝² : Algebra A S\nS' : Type u_7\ninst✝¹ : Ring S'\ninst✝ : Algebra A S'\npb : PowerBasis A S\npb' : PowerBasis A S'\nh : Eq (minpoly A pb.gen) (minpoly A pb'.gen)\na : S\n⊢ Eq ((pb.equivOfMinpoly pb' h) a) ((pb.lift pb'.gen ⋯) a)","decl":"/-- `pb.equivOfMinpoly pb' h` is an equivalence of algebras with the same power basis,\nwhere \"the same\" means that they have identical minimal polynomials.\n\nSee also `PowerBasis.equivOfRoot` which takes the hypothesis that each generator is a root of the\nother basis' minimal polynomial; `PowerBasis.equivOfRoot` is more general if `A` is not a field.\n-/\n@[simps! (config := .lemmasOnly) apply]\nnoncomputable def equivOfMinpoly (pb : PowerBasis A S) (pb' : PowerBasis A S')\n    (h : minpoly A pb.gen = minpoly A pb'.gen) : S ≃ₐ[A] S' :=\n  pb.equivOfRoot pb' (h ▸ minpoly.aeval _ _) (h.symm ▸ minpoly.aeval _ _)\n\n"}
{"name":"PowerBasis.equivOfMinpoly_aeval","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁴ : Ring S\nA : Type u_4\ninst✝³ : CommRing A\ninst✝² : Algebra A S\nS' : Type u_7\ninst✝¹ : Ring S'\ninst✝ : Algebra A S'\npb : PowerBasis A S\npb' : PowerBasis A S'\nh : Eq (minpoly A pb.gen) (minpoly A pb'.gen)\nf : Polynomial A\n⊢ Eq ((pb.equivOfMinpoly pb' h) ((Polynomial.aeval pb.gen) f)) ((Polynomial.aeval pb'.gen) f)","decl":"@[simp]\ntheorem equivOfMinpoly_aeval (pb : PowerBasis A S) (pb' : PowerBasis A S')\n    (h : minpoly A pb.gen = minpoly A pb'.gen) (f : A[X]) :\n    pb.equivOfMinpoly pb' h (aeval pb.gen f) = aeval pb'.gen f :=\n  pb.equivOfRoot_aeval pb' _ _ _\n\n"}
{"name":"PowerBasis.equivOfMinpoly_gen","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁴ : Ring S\nA : Type u_4\ninst✝³ : CommRing A\ninst✝² : Algebra A S\nS' : Type u_7\ninst✝¹ : Ring S'\ninst✝ : Algebra A S'\npb : PowerBasis A S\npb' : PowerBasis A S'\nh : Eq (minpoly A pb.gen) (minpoly A pb'.gen)\n⊢ Eq ((pb.equivOfMinpoly pb' h) pb.gen) pb'.gen","decl":"@[simp]\ntheorem equivOfMinpoly_gen (pb : PowerBasis A S) (pb' : PowerBasis A S')\n    (h : minpoly A pb.gen = minpoly A pb'.gen) : pb.equivOfMinpoly pb' h pb.gen = pb'.gen :=\n  pb.equivOfRoot_gen pb' _ _\n\n"}
{"name":"PowerBasis.equivOfMinpoly_symm","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁴ : Ring S\nA : Type u_4\ninst✝³ : CommRing A\ninst✝² : Algebra A S\nS' : Type u_7\ninst✝¹ : Ring S'\ninst✝ : Algebra A S'\npb : PowerBasis A S\npb' : PowerBasis A S'\nh : Eq (minpoly A pb.gen) (minpoly A pb'.gen)\n⊢ Eq (pb.equivOfMinpoly pb' h).symm (pb'.equivOfMinpoly pb ⋯)","decl":"@[simp]\ntheorem equivOfMinpoly_symm (pb : PowerBasis A S) (pb' : PowerBasis A S')\n    (h : minpoly A pb.gen = minpoly A pb'.gen) :\n    (pb.equivOfMinpoly pb' h).symm = pb'.equivOfMinpoly pb h.symm :=\n  rfl\n\n"}
{"name":"linearIndependent_pow","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝² : Ring S\nK : Type u_6\ninst✝¹ : Field K\ninst✝ : Algebra K S\nx : S\n⊢ LinearIndependent K fun i => HPow.hPow x ↑i","decl":"/-- Useful lemma to show `x` generates a power basis:\nthe powers of `x` less than the degree of `x`'s minimal polynomial are linearly independent. -/\ntheorem linearIndependent_pow [Algebra K S] (x : S) :\n    LinearIndependent K fun i : Fin (minpoly K x).natDegree => x ^ (i : ℕ) := by\n  by_cases h : IsIntegral K x; swap\n  · rw [minpoly.eq_zero h, natDegree_zero]\n    exact linearIndependent_empty_type\n  refine Fintype.linearIndependent_iff.2 fun g hg i => ?_\n  simp only at hg\n  simp_rw [Algebra.smul_def, ← aeval_monomial, ← map_sum] at hg\n  apply (fun hn0 => (minpoly.degree_le_of_ne_zero K x (mt (fun h0 => ?_) hn0) hg).not_lt).mtr\n  · simp_rw [← C_mul_X_pow_eq_monomial]\n    exact (degree_eq_natDegree <| minpoly.ne_zero h).symm ▸ degree_sum_fin_lt _\n  · apply_fun lcoeff K i at h0\n    simp_rw [map_sum, lcoeff_apply, coeff_monomial, Fin.val_eq_val, Finset.sum_ite_eq'] at h0\n    exact (if_pos <| Finset.mem_univ _).symm.trans h0\n\n"}
{"name":"IsIntegral.mem_span_pow","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\ninst✝ : Nontrivial R\nx y : S\nhx : IsIntegral R x\nhy : Exists fun f => Eq y ((Polynomial.aeval x) f)\n⊢ Membership.mem (Submodule.span R (Set.range fun i => HPow.hPow x ↑i)) y","decl":"theorem IsIntegral.mem_span_pow [Nontrivial R] {x y : S} (hx : IsIntegral R x)\n    (hy : ∃ f : R[X], y = aeval x f) :\n    y ∈ Submodule.span R (Set.range fun i : Fin (minpoly R x).natDegree => x ^ (i : ℕ)) := by\n  obtain ⟨f, rfl⟩ := hy\n  apply mem_span_pow'.mpr _\n  have := minpoly.monic hx\n  refine ⟨f %ₘ minpoly R x, (degree_modByMonic_lt _ this).trans_le degree_le_natDegree, ?_⟩\n  conv_lhs => rw [← modByMonic_add_div f this]\n  simp only [add_zero, zero_mul, minpoly.aeval, aeval_add, map_mul]\n\n"}
{"name":"PowerBasis.map_basis","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\ninst✝² : Algebra R S\nS' : Type u_7\ninst✝¹ : CommRing S'\ninst✝ : Algebra R S'\npb : PowerBasis R S\ne : AlgEquiv R S S'\n⊢ Eq (pb.map e).basis (pb.basis.map e.toLinearEquiv)","decl":"/-- `PowerBasis.map pb (e : S ≃ₐ[R] S')` is the power basis for `S'` generated by `e pb.gen`. -/\n@[simps dim gen basis]\nnoncomputable def map (pb : PowerBasis R S) (e : S ≃ₐ[R] S') : PowerBasis R S' where\n  dim := pb.dim\n  basis := pb.basis.map e.toLinearEquiv\n  gen := e pb.gen\n  basis_eq_pow i := by rw [Basis.map_apply, pb.basis_eq_pow, e.toLinearEquiv_apply, map_pow]\n\n"}
{"name":"PowerBasis.map_dim","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\ninst✝² : Algebra R S\nS' : Type u_7\ninst✝¹ : CommRing S'\ninst✝ : Algebra R S'\npb : PowerBasis R S\ne : AlgEquiv R S S'\n⊢ Eq (pb.map e).dim pb.dim","decl":"/-- `PowerBasis.map pb (e : S ≃ₐ[R] S')` is the power basis for `S'` generated by `e pb.gen`. -/\n@[simps dim gen basis]\nnoncomputable def map (pb : PowerBasis R S) (e : S ≃ₐ[R] S') : PowerBasis R S' where\n  dim := pb.dim\n  basis := pb.basis.map e.toLinearEquiv\n  gen := e pb.gen\n  basis_eq_pow i := by rw [Basis.map_apply, pb.basis_eq_pow, e.toLinearEquiv_apply, map_pow]\n\n"}
{"name":"PowerBasis.map_gen","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\ninst✝² : Algebra R S\nS' : Type u_7\ninst✝¹ : CommRing S'\ninst✝ : Algebra R S'\npb : PowerBasis R S\ne : AlgEquiv R S S'\n⊢ Eq (pb.map e).gen (e pb.gen)","decl":"/-- `PowerBasis.map pb (e : S ≃ₐ[R] S')` is the power basis for `S'` generated by `e pb.gen`. -/\n@[simps dim gen basis]\nnoncomputable def map (pb : PowerBasis R S) (e : S ≃ₐ[R] S') : PowerBasis R S' where\n  dim := pb.dim\n  basis := pb.basis.map e.toLinearEquiv\n  gen := e pb.gen\n  basis_eq_pow i := by rw [Basis.map_apply, pb.basis_eq_pow, e.toLinearEquiv_apply, map_pow]\n\n"}
{"name":"PowerBasis.minpolyGen_map","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁴ : Ring S\nA : Type u_4\ninst✝³ : CommRing A\nS' : Type u_7\ninst✝² : CommRing S'\ninst✝¹ : Algebra A S\ninst✝ : Algebra A S'\npb : PowerBasis A S\ne : AlgEquiv A S S'\n⊢ Eq (pb.map e).minpolyGen pb.minpolyGen","decl":"theorem minpolyGen_map (pb : PowerBasis A S) (e : S ≃ₐ[A] S') :\n    (pb.map e).minpolyGen = pb.minpolyGen := by\n  dsimp only [minpolyGen, map_dim]\n  -- Turn `Fin (pb.map e).dim` into `Fin pb.dim`\n  simp only [LinearEquiv.trans_apply, map_basis, Basis.map_repr, map_gen,\n    AlgEquiv.toLinearEquiv_apply, e.toLinearEquiv_symm, map_pow,\n    AlgEquiv.symm_apply_apply, sub_right_inj]\n\n"}
{"name":"PowerBasis.equivOfRoot_map","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁴ : Ring S\nA : Type u_4\ninst✝³ : CommRing A\nS' : Type u_7\ninst✝² : CommRing S'\ninst✝¹ : Algebra A S\ninst✝ : Algebra A S'\npb : PowerBasis A S\ne : AlgEquiv A S S'\nh₁ : Eq ((Polynomial.aeval pb.gen) (minpoly A (pb.map e).gen)) 0\nh₂ : Eq ((Polynomial.aeval (pb.map e).gen) (minpoly A pb.gen)) 0\n⊢ Eq (pb.equivOfRoot (pb.map e) h₁ h₂) e","decl":"@[simp]\ntheorem equivOfRoot_map (pb : PowerBasis A S) (e : S ≃ₐ[A] S') (h₁ h₂) :\n    pb.equivOfRoot (pb.map e) h₁ h₂ = e := by\n  ext x\n  obtain ⟨f, rfl⟩ := pb.exists_eq_aeval' x\n  simp [aeval_algEquiv]\n\n"}
{"name":"PowerBasis.equivOfMinpoly_map","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁴ : Ring S\nA : Type u_4\ninst✝³ : CommRing A\nS' : Type u_7\ninst✝² : CommRing S'\ninst✝¹ : Algebra A S\ninst✝ : Algebra A S'\npb : PowerBasis A S\ne : AlgEquiv A S S'\nh : Eq (minpoly A pb.gen) (minpoly A (pb.map e).gen)\n⊢ Eq (pb.equivOfMinpoly (pb.map e) h) e","decl":"@[simp]\ntheorem equivOfMinpoly_map (pb : PowerBasis A S) (e : S ≃ₐ[A] S')\n    (h : minpoly A pb.gen = minpoly A (pb.map e).gen) : pb.equivOfMinpoly (pb.map e) h = e :=\n  pb.equivOfRoot_map _ _ _\n\n"}
{"name":"PowerBasis.adjoin_gen_eq_top","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nB : PowerBasis R S\n⊢ Eq (Algebra.adjoin R (Singleton.singleton B.gen)) Top.top","decl":"theorem adjoin_gen_eq_top (B : PowerBasis R S) : adjoin R ({B.gen} : Set S) = ⊤ := by\n  rw [← toSubmodule_eq_top, _root_.eq_top_iff, ← B.basis.span_eq, Submodule.span_le]\n  rintro x ⟨i, rfl⟩\n  rw [B.basis_eq_pow i]\n  exact Subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton _)) _\n\n"}
{"name":"PowerBasis.adjoin_eq_top_of_gen_mem_adjoin","module":"Mathlib.RingTheory.PowerBasis","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nB : PowerBasis R S\nx : S\nhx : Membership.mem (Algebra.adjoin R (Singleton.singleton x)) B.gen\n⊢ Eq (Algebra.adjoin R (Singleton.singleton x)) Top.top","decl":"theorem adjoin_eq_top_of_gen_mem_adjoin {B : PowerBasis R S} {x : S}\n    (hx : B.gen ∈ adjoin R ({x} : Set S)) : adjoin R ({x} : Set S) = ⊤ := by\n  rw [_root_.eq_top_iff, ← B.adjoin_gen_eq_top]\n  refine adjoin_le ?_\n  simp [hx]\n\n"}
