{"name":"Nat.instNontrivial","module":"Mathlib.Data.Nat.Defs","initialProofState":"⊢ Nontrivial Nat","decl":"instance instNontrivial : Nontrivial ℕ := ⟨⟨0, 1, Nat.zero_ne_one⟩⟩\n\n"}
{"name":"Nat.default_eq_zero","module":"Mathlib.Data.Nat.Defs","initialProofState":"⊢ Eq Inhabited.default 0","decl":"@[simp] theorem default_eq_zero : default = 0 := rfl\n\n"}
{"name":"Nat.succ_pos'","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ LT.lt 0 n.succ","decl":"lemma succ_pos' : 0 < succ n := succ_pos n\n\n"}
{"name":"Nat.succ_inj","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\n⊢ Iff (Eq a.succ b.succ) (Eq a b)","decl":"alias succ_inj := succ_inj'\n\n"}
{"name":"Nat.succ_injective","module":"Mathlib.Data.Nat.Defs","initialProofState":"⊢ Function.Injective Nat.succ","decl":"lemma succ_injective : Injective Nat.succ := @succ.inj\n\n"}
{"name":"Nat.succ_ne_succ","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (Ne m.succ n.succ) (Ne m n)","decl":"lemma succ_ne_succ : succ m ≠ succ n ↔ m ≠ n := succ_injective.ne_iff\n\n"}
{"name":"Nat.succ_succ_ne_one","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Ne n.succ.succ 1","decl":"lemma succ_succ_ne_one (n : ℕ) : n.succ.succ ≠ 1 := by simp\n\n"}
{"name":"Nat.one_lt_succ_succ","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ LT.lt 1 n.succ.succ","decl":"lemma one_lt_succ_succ (n : ℕ) : 1 < n.succ.succ := succ_lt_succ <| succ_pos n\n\n-- Moved to Batteries\n\n"}
{"name":"LT.lt.nat_succ_le","module":"Mathlib.Data.Nat.Defs","initialProofState":"n m : Nat\nh : LT.lt n m\n⊢ LE.le n.succ m","decl":"alias _root_.LT.lt.nat_succ_le := succ_le_of_lt\n\n"}
{"name":"Nat.not_succ_lt_self","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Not (LT.lt n.succ n)","decl":"lemma not_succ_lt_self : ¬ succ n < n := Nat.not_lt_of_ge n.le_succ\n\n"}
{"name":"Nat.succ_le_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (LE.le m.succ n) (LT.lt m n)","decl":"lemma succ_le_iff : succ m ≤ n ↔ m < n := ⟨lt_of_succ_le, succ_le_of_lt⟩\n\n"}
{"name":"Nat.le_succ_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (LE.le m n.succ) (Or (LE.le m n) (Eq m n.succ))","decl":"lemma le_succ_iff : m ≤ n.succ ↔ m ≤ n ∨ m = n.succ := by\n  refine ⟨fun hmn ↦ (Nat.lt_or_eq_of_le hmn).imp_left le_of_lt_succ, ?_⟩\n  rintro (hmn | rfl)\n  · exact le_succ_of_le hmn\n  · exact Nat.le_refl _\n\n"}
{"name":"Nat.of_le_succ","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\na✝ : LE.le m n.succ\n⊢ Or (LE.le m n) (Eq m n.succ)","decl":"alias ⟨of_le_succ, _⟩ := le_succ_iff\n\n"}
{"name":"Nat.lt_iff_le_pred","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\na✝ : LT.lt 0 n\n⊢ Iff (LT.lt m n) (LE.le m (HSub.hSub n 1))","decl":"lemma lt_iff_le_pred : ∀ {n}, 0 < n → (m < n ↔ m ≤ n - 1) | _ + 1, _ => Nat.lt_succ_iff\n\n"}
{"name":"Nat.le_of_pred_lt","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\nm : Nat\na✝ : LT.lt m.pred n\n⊢ LE.le m n","decl":"lemma le_of_pred_lt : ∀ {m}, pred m < n → m ≤ n\n  | 0 => Nat.le_of_lt\n  | _ + 1 => id\n\n"}
{"name":"Nat.lt_iff_add_one_le","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (LT.lt m n) (LE.le (HAdd.hAdd m 1) n)","decl":"lemma lt_iff_add_one_le : m < n ↔ m + 1 ≤ n := by rw [succ_le_iff]\n\n-- A flipped version of `lt_add_one_iff`.\n"}
{"name":"Nat.lt_one_add_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (LT.lt m (HAdd.hAdd 1 n)) (LE.le m n)","decl":"lemma lt_one_add_iff : m < 1 + n ↔ m ≤ n := by simp only [Nat.add_comm, Nat.lt_succ_iff]\n\n"}
{"name":"Nat.one_add_le_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (LE.le (HAdd.hAdd 1 m) n) (LT.lt m n)","decl":"lemma one_add_le_iff : 1 + m ≤ n ↔ m < n := by simp only [Nat.add_comm, add_one_le_iff]\n\n"}
{"name":"Nat.one_le_iff_ne_zero","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Iff (LE.le 1 n) (Ne n 0)","decl":"lemma one_le_iff_ne_zero : 1 ≤ n ↔ n ≠ 0 := Nat.pos_iff_ne_zero\n\n"}
{"name":"Nat.one_lt_iff_ne_zero_and_ne_one","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Iff (LT.lt 1 n) (And (Ne n 0) (Ne n 1))","decl":"lemma one_lt_iff_ne_zero_and_ne_one : ∀ {n : ℕ}, 1 < n ↔ n ≠ 0 ∧ n ≠ 1\n  | 0 => by decide\n  | 1 => by decide\n  | n + 2 => by omega\n\n"}
{"name":"Nat.le_one_iff_eq_zero_or_eq_one","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Iff (LE.le n 1) (Or (Eq n 0) (Eq n 1))","decl":"lemma le_one_iff_eq_zero_or_eq_one : ∀ {n : ℕ}, n ≤ 1 ↔ n = 0 ∨ n = 1 := by simp [le_succ_iff]\n\n"}
{"name":"Nat.one_le_of_lt","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nh : LT.lt a b\n⊢ LE.le 1 b","decl":"lemma one_le_of_lt (h : a < b) : 1 ≤ b := Nat.lt_of_le_of_lt (Nat.zero_le _) h\n\n"}
{"name":"Nat.min_left_comm","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\n⊢ Eq (Min.min a (Min.min b c)) (Min.min b (Min.min a c))","decl":"protected lemma min_left_comm (a b c : ℕ) : min a (min b c) = min b (min a c) := by\n  rw [← Nat.min_assoc, ← Nat.min_assoc, b.min_comm]\n\n"}
{"name":"Nat.max_left_comm","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\n⊢ Eq (Max.max a (Max.max b c)) (Max.max b (Max.max a c))","decl":"protected lemma max_left_comm (a b c : ℕ) : max a (max b c) = max b (max a c) := by\n  rw [← Nat.max_assoc, ← Nat.max_assoc, b.max_comm]\n\n"}
{"name":"Nat.min_right_comm","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\n⊢ Eq (Min.min (Min.min a b) c) (Min.min (Min.min a c) b)","decl":"protected lemma min_right_comm (a b c : ℕ) : min (min a b) c = min (min a c) b := by\n  rw [Nat.min_assoc, Nat.min_assoc, b.min_comm]\n\n"}
{"name":"Nat.max_right_comm","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\n⊢ Eq (Max.max (Max.max a b) c) (Max.max (Max.max a c) b)","decl":"protected lemma max_right_comm (a b c : ℕ) : max (max a b) c = max (max a c) b := by\n  rw [Nat.max_assoc, Nat.max_assoc, b.max_comm]\n\n"}
{"name":"Nat.min_eq_zero_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (Eq (Min.min m n) 0) (Or (Eq m 0) (Eq n 0))","decl":"@[simp] lemma min_eq_zero_iff : min m n = 0 ↔ m = 0 ∨ n = 0 := by omega\n"}
{"name":"Nat.max_eq_zero_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (Eq (Max.max m n) 0) (And (Eq m 0) (Eq n 0))","decl":"@[simp] lemma max_eq_zero_iff : max m n = 0 ↔ m = 0 ∧ n = 0 := by omega\n\n-- Moved to Batteries\n\n"}
{"name":"Nat.pred_one_add","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd 1 n).pred n","decl":"lemma pred_one_add (n : ℕ) : pred (1 + n) = n := by rw [Nat.add_comm, add_one, Nat.pred_succ]\n\n"}
{"name":"Nat.pred_eq_self_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Iff (Eq n.pred n) (Eq n 0)","decl":"lemma pred_eq_self_iff : n.pred = n ↔ n = 0 := by cases n <;> simp [(Nat.succ_ne_self _).symm]\n\n"}
{"name":"Nat.pred_eq_of_eq_succ","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\nH : Eq m n.succ\n⊢ Eq m.pred n","decl":"lemma pred_eq_of_eq_succ (H : m = n.succ) : m.pred = n := by simp [H]\n\n"}
{"name":"Nat.pred_eq_succ_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (Eq (HSub.hSub n 1) (HAdd.hAdd m 1)) (Eq n (HAdd.hAdd m 2))","decl":"@[simp] lemma pred_eq_succ_iff : n - 1 = m + 1 ↔ n = m + 2 := by\n  cases n <;> constructor <;> rintro ⟨⟩ <;> rfl\n\n"}
{"name":"Nat.forall_lt_succ","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\np : Nat → Prop\n⊢ Iff (∀ (m : Nat), LT.lt m (HAdd.hAdd n 1) → p m) (And (∀ (m : Nat), LT.lt m n → p m) (p n))","decl":"lemma forall_lt_succ : (∀ m < n + 1, p m) ↔ (∀ m < n, p m) ∧ p n := by\n  simp only [Nat.lt_succ_iff, Nat.le_iff_lt_or_eq, or_comm, forall_eq_or_imp, and_comm]\n\n"}
{"name":"Nat.exists_lt_succ","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\np : Nat → Prop\n⊢ Iff (Exists fun m => And (LT.lt m (HAdd.hAdd n 1)) (p m)) (Or (Exists fun m => And (LT.lt m n) (p m)) (p n))","decl":"lemma exists_lt_succ : (∃ m < n + 1, p m) ↔ (∃ m < n, p m) ∨ p n := by\n  rw [← not_iff_not]\n  push_neg\n  exact forall_lt_succ\n\n"}
{"name":"Nat.two_lt_of_ne","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\na✝² : Ne n 0\na✝¹ : Ne n 1\na✝ : Ne n 2\n⊢ LT.lt 2 n","decl":"lemma two_lt_of_ne : ∀ {n}, n ≠ 0 → n ≠ 1 → n ≠ 2 → 2 < n\n  | 0, h, _, _ => (h rfl).elim\n  | 1, _, h, _ => (h rfl).elim\n  | 2, _, _, h => (h rfl).elim\n  -- Porting note: was `by decide`\n  | n + 3, _, _, _ => le_add_left 3 n\n\n"}
{"name":"Nat.add_succ_sub_one","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Eq (HSub.hSub (HAdd.hAdd m n.succ) 1) (HAdd.hAdd m n)","decl":"@[simp] lemma add_succ_sub_one (m n : ℕ) : m + succ n - 1 = m + n := rfl\n\n"}
{"name":"Nat.succ_add_sub_one","module":"Mathlib.Data.Nat.Defs","initialProofState":"n m : Nat\n⊢ Eq (HSub.hSub (HAdd.hAdd m.succ n) 1) (HAdd.hAdd m n)","decl":"@[simp]\nlemma succ_add_sub_one (n m : ℕ) : succ m + n - 1 = m + n := by rw [succ_add, Nat.add_one_sub_one]\n\n"}
{"name":"Nat.pred_sub","module":"Mathlib.Data.Nat.Defs","initialProofState":"n m : Nat\n⊢ Eq (HSub.hSub n.pred m) (HSub.hSub n m).pred","decl":"lemma pred_sub (n m : ℕ) : pred n - m = pred (n - m) := by\n  rw [← Nat.sub_one, Nat.sub_sub, one_add, sub_succ]\n\n"}
{"name":"Nat.self_add_sub_one","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd n (HSub.hSub n 1)) (HSub.hSub (HMul.hMul 2 n) 1)","decl":"lemma self_add_sub_one : ∀ n, n + (n - 1) = 2 * n - 1\n  | 0 => rfl\n  | n + 1 => by rw [Nat.two_mul]; exact (add_succ_sub_one (Nat.succ _) _).symm\n\n"}
{"name":"Nat.sub_one_add_self","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd (HSub.hSub n 1) n) (HSub.hSub (HMul.hMul 2 n) 1)","decl":"lemma sub_one_add_self (n : ℕ) : (n - 1) + n = 2 * n - 1 := Nat.add_comm _ n ▸ self_add_sub_one n\n\n"}
{"name":"Nat.self_add_pred","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd n n.pred) (HMul.hMul 2 n).pred","decl":"lemma self_add_pred (n : ℕ) : n + pred n = (2 * n).pred := self_add_sub_one n\n"}
{"name":"Nat.pred_add_self","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd n.pred n) (HMul.hMul 2 n).pred","decl":"lemma pred_add_self (n : ℕ) : pred n + n = (2 * n).pred := sub_one_add_self n\n\n"}
{"name":"Nat.pred_le_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (LE.le m.pred n) (LE.le m n.succ)","decl":"lemma pred_le_iff : pred m ≤ n ↔ m ≤ succ n :=\n  ⟨le_succ_of_pred_le, by cases m; exacts [fun _ ↦ zero_le n, le_of_succ_le_succ]⟩\n\n"}
{"name":"Nat.lt_of_lt_pred","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\nh : LT.lt m (HSub.hSub n 1)\n⊢ LT.lt m n","decl":"lemma lt_of_lt_pred (h : m < n - 1) : m < n := by omega\n\n"}
{"name":"Nat.le_add_pred_of_pos","module":"Mathlib.Data.Nat.Defs","initialProofState":"b a : Nat\nhb : Ne b 0\n⊢ LE.le a (HAdd.hAdd b (HSub.hSub a 1))","decl":"lemma le_add_pred_of_pos (a : ℕ) (hb : b ≠ 0) : a ≤ b + (a - 1) := by omega\n\n"}
{"name":"Nat.add_left_inj","module":"Mathlib.Data.Nat.Defs","initialProofState":"m k n : Nat\n⊢ Iff (Eq (HAdd.hAdd m n) (HAdd.hAdd k n)) (Eq m k)","decl":"@[simp, nolint simpNF] protected alias add_left_inj := Nat.add_right_cancel_iff\n"}
{"name":"Nat.add_right_inj","module":"Mathlib.Data.Nat.Defs","initialProofState":"m k n : Nat\n⊢ Iff (Eq (HAdd.hAdd n m) (HAdd.hAdd n k)) (Eq m k)","decl":"@[simp, nolint simpNF] protected alias add_right_inj := Nat.add_left_cancel_iff\n"}
{"name":"Nat.add_eq_left","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\n⊢ Iff (Eq (HAdd.hAdd a b) a) (Eq b 0)","decl":"@[simp, nolint simpNF] protected lemma add_eq_left : a + b = a ↔ b = 0 := by omega\n"}
{"name":"Nat.add_eq_right","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\n⊢ Iff (Eq (HAdd.hAdd a b) b) (Eq a 0)","decl":"@[simp, nolint simpNF] protected lemma add_eq_right : a + b = b ↔ a = 0 := by omega\n\n"}
{"name":"Nat.two_le_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Iff (LE.le 2 n) (And (Ne n 0) (Ne n 1))","decl":"lemma two_le_iff : ∀ n, 2 ≤ n ↔ n ≠ 0 ∧ n ≠ 1\n  | 0 => by simp\n  | 1 => by simp\n  | n + 2 => by simp\n\n"}
{"name":"Nat.add_eq_max_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (Eq (HAdd.hAdd m n) (Max.max m n)) (Or (Eq m 0) (Eq n 0))","decl":"lemma add_eq_max_iff : m + n = max m n ↔ m = 0 ∨ n = 0 := by omega\n"}
{"name":"Nat.add_eq_min_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (Eq (HAdd.hAdd m n) (Min.min m n)) (And (Eq m 0) (Eq n 0))","decl":"lemma add_eq_min_iff : m + n = min m n ↔ m = 0 ∧ n = 0 := by omega\n\n-- We want to use this lemma earlier than the lemma simp can prove it with\n"}
{"name":"Nat.add_eq_zero","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (Eq (HAdd.hAdd m n) 0) (And (Eq m 0) (Eq n 0))","decl":"@[simp, nolint simpNF] protected lemma add_eq_zero : m + n = 0 ↔ m = 0 ∧ n = 0 := by omega\n\n"}
{"name":"Nat.add_pos_iff_pos_or_pos","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (LT.lt 0 (HAdd.hAdd m n)) (Or (LT.lt 0 m) (LT.lt 0 n))","decl":"lemma add_pos_iff_pos_or_pos : 0 < m + n ↔ 0 < m ∨ 0 < n := by omega\n\n"}
{"name":"Nat.add_eq_one_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (Eq (HAdd.hAdd m n) 1) (Or (And (Eq m 0) (Eq n 1)) (And (Eq m 1) (Eq n 0)))","decl":"lemma add_eq_one_iff : m + n = 1 ↔ m = 0 ∧ n = 1 ∨ m = 1 ∧ n = 0 := by omega\n\n"}
{"name":"Nat.add_eq_two_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (Eq (HAdd.hAdd m n) 2) (Or (And (Eq m 0) (Eq n 2)) (Or (And (Eq m 1) (Eq n 1)) (And (Eq m 2) (Eq n 0))))","decl":"lemma add_eq_two_iff : m + n = 2 ↔ m = 0 ∧ n = 2 ∨ m = 1 ∧ n = 1 ∨ m = 2 ∧ n = 0 := by\n  omega\n\n"}
{"name":"Nat.add_eq_three_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (Eq (HAdd.hAdd m n) 3) (Or (And (Eq m 0) (Eq n 3)) (Or (And (Eq m 1) (Eq n 2)) (Or (And (Eq m 2) (Eq n 1)) (And (Eq m 3) (Eq n 0)))))","decl":"lemma add_eq_three_iff :\n    m + n = 3 ↔ m = 0 ∧ n = 3 ∨ m = 1 ∧ n = 2 ∨ m = 2 ∧ n = 1 ∨ m = 3 ∧ n = 0 := by\n  omega\n\n"}
{"name":"Nat.le_add_one_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (LE.le m (HAdd.hAdd n 1)) (Or (LE.le m n) (Eq m (HAdd.hAdd n 1)))","decl":"lemma le_add_one_iff : m ≤ n + 1 ↔ m ≤ n ∨ m = n + 1 := by omega\n\n"}
{"name":"Nat.le_and_le_add_one_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (And (LE.le n m) (LE.le m (HAdd.hAdd n 1))) (Or (Eq m n) (Eq m (HAdd.hAdd n 1)))","decl":"lemma le_and_le_add_one_iff : n ≤ m ∧ m ≤ n + 1 ↔ m = n ∨ m = n + 1 := by omega\n\n"}
{"name":"Nat.add_succ_lt_add","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c d : Nat\nhab : LT.lt a b\nhcd : LT.lt c d\n⊢ LT.lt (HAdd.hAdd (HAdd.hAdd a c) 1) (HAdd.hAdd b d)","decl":"lemma add_succ_lt_add (hab : a < b) (hcd : c < d) : a + c + 1 < b + d := by omega\n\n"}
{"name":"Nat.le_or_le_of_add_eq_add_pred","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c d : Nat\nh : Eq (HAdd.hAdd a c) (HSub.hSub (HAdd.hAdd b d) 1)\n⊢ Or (LE.le b a) (LE.le d c)","decl":"theorem le_or_le_of_add_eq_add_pred (h : a + c = b + d - 1) : b ≤ a ∨ d ≤ c := by omega\n\n"}
{"name":"Nat.sub_succ'","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Eq (HSub.hSub m n.succ) (HSub.hSub (HSub.hSub m n) 1)","decl":"/-- A version of `Nat.sub_succ` in the form `_ - 1` instead of `Nat.pred _`. -/\nlemma sub_succ' (m n : ℕ) : m - n.succ = m - n - 1 := rfl\n\n"}
{"name":"Nat.sub_eq_of_eq_add'","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nh : Eq a (HAdd.hAdd b c)\n⊢ Eq (HSub.hSub a b) c","decl":"protected lemma sub_eq_of_eq_add' (h : a = b + c) : a - b = c := by omega\n"}
{"name":"Nat.eq_sub_of_add_eq","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nh : Eq (HAdd.hAdd c b) a\n⊢ Eq c (HSub.hSub a b)","decl":"protected lemma eq_sub_of_add_eq (h : c + b = a) : c = a - b := by omega\n"}
{"name":"Nat.eq_sub_of_add_eq'","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nh : Eq (HAdd.hAdd b c) a\n⊢ Eq c (HSub.hSub a b)","decl":"protected lemma eq_sub_of_add_eq' (h : b + c = a) : c = a - b := by omega\n\n"}
{"name":"Nat.lt_sub_iff_add_lt","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\n⊢ Iff (LT.lt a (HSub.hSub c b)) (LT.lt (HAdd.hAdd a b) c)","decl":"protected lemma lt_sub_iff_add_lt : a < c - b ↔ a + b < c := ⟨add_lt_of_lt_sub, lt_sub_of_add_lt⟩\n"}
{"name":"Nat.lt_sub_iff_add_lt'","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\n⊢ Iff (LT.lt a (HSub.hSub c b)) (LT.lt (HAdd.hAdd b a) c)","decl":"protected lemma lt_sub_iff_add_lt' : a < c - b ↔ b + a < c := by omega\n"}
{"name":"Nat.sub_lt_iff_lt_add","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nhba : LE.le b a\n⊢ Iff (LT.lt (HSub.hSub a b) c) (LT.lt a (HAdd.hAdd b c))","decl":"protected lemma sub_lt_iff_lt_add (hba : b ≤ a) : a - b < c ↔ a < b + c := by omega\n"}
{"name":"Nat.sub_lt_iff_lt_add'","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nhba : LE.le b a\n⊢ Iff (LT.lt (HSub.hSub a b) c) (LT.lt a (HAdd.hAdd c b))","decl":"protected lemma sub_lt_iff_lt_add' (hba : b ≤ a) : a - b < c ↔ a < c + b := by omega\n\n"}
{"name":"Nat.sub_sub_sub_cancel_right","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nh : LE.le c b\n⊢ Eq (HSub.hSub (HSub.hSub a c) (HSub.hSub b c)) (HSub.hSub a b)","decl":"protected lemma sub_sub_sub_cancel_right (h : c ≤ b) : a - c - (b - c) = a - b := by omega\n"}
{"name":"Nat.add_sub_sub_cancel","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nh : LE.le c a\n⊢ Eq (HSub.hSub (HAdd.hAdd a b) (HSub.hSub a c)) (HAdd.hAdd b c)","decl":"protected lemma add_sub_sub_cancel (h : c ≤ a) : a + b - (a - c) = b + c := by omega\n"}
{"name":"Nat.sub_add_sub_cancel","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nhab : LE.le b a\nhcb : LE.le c b\n⊢ Eq (HAdd.hAdd (HSub.hSub a b) (HSub.hSub b c)) (HSub.hSub a c)","decl":"protected lemma sub_add_sub_cancel (hab : b ≤ a) (hcb : c ≤ b) : a - b + (b - c) = a - c := by omega\n\n"}
{"name":"Nat.lt_pred_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\n⊢ Iff (LT.lt a b.pred) (LT.lt a.succ b)","decl":"lemma lt_pred_iff : a < pred b ↔ succ a < b := Nat.lt_sub_iff_add_lt (b := 1)\n\n"}
{"name":"Nat.sub_lt_sub_iff_right","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nh : LE.le c a\n⊢ Iff (LT.lt (HSub.hSub a c) (HSub.hSub b c)) (LT.lt a b)","decl":"protected lemma sub_lt_sub_iff_right (h : c ≤ a) : a - c < b - c ↔ a < b := by omega\n\n"}
{"name":"Nat.mul_def","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Eq (m.mul n) (HMul.hMul m n)","decl":"@[simp] lemma mul_def : Nat.mul m n = m * n := rfl\n\n-- Porting note: removing `simp` attribute\n"}
{"name":"Nat.zero_eq_mul","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (Eq 0 (HMul.hMul m n)) (Or (Eq m 0) (Eq n 0))","decl":"protected lemma zero_eq_mul : 0 = m * n ↔ m = 0 ∨ n = 0 := by rw [eq_comm, Nat.mul_eq_zero]\n\n"}
{"name":"Nat.two_mul_ne_two_mul_add_one","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Ne (HMul.hMul 2 n) (HAdd.hAdd (HMul.hMul 2 m) 1)","decl":"lemma two_mul_ne_two_mul_add_one : 2 * n ≠ 2 * m + 1 :=\n  mt (congrArg (· % 2))\n    (by rw [Nat.add_comm, add_mul_mod_self_left, mul_mod_right, mod_eq_of_lt] <;> simp)\n\n-- TODO: Replace `Nat.mul_right_cancel_iff` with `Nat.mul_left_inj`\n"}
{"name":"Nat.mul_left_inj","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nha : Ne a 0\n⊢ Iff (Eq (HMul.hMul b a) (HMul.hMul c a)) (Eq b c)","decl":"protected lemma mul_left_inj (ha : a ≠ 0) : b * a = c * a ↔ b = c :=\n  Nat.mul_right_cancel_iff (Nat.pos_iff_ne_zero.2 ha)\n\n-- TODO: Replace `Nat.mul_left_cancel_iff` with `Nat.mul_right_inj`\n"}
{"name":"Nat.mul_right_inj","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nha : Ne a 0\n⊢ Iff (Eq (HMul.hMul a b) (HMul.hMul a c)) (Eq b c)","decl":"protected lemma mul_right_inj (ha : a ≠ 0) : a * b = a * c ↔ b = c :=\n  Nat.mul_left_cancel_iff (Nat.pos_iff_ne_zero.2 ha)\n\n"}
{"name":"Nat.mul_ne_mul_left","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nha : Ne a 0\n⊢ Iff (Ne (HMul.hMul b a) (HMul.hMul c a)) (Ne b c)","decl":"protected lemma mul_ne_mul_left (ha : a ≠ 0) : b * a ≠ c * a ↔ b ≠ c :=\n  not_congr (Nat.mul_left_inj ha)\n\n"}
{"name":"Nat.mul_ne_mul_right","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nha : Ne a 0\n⊢ Iff (Ne (HMul.hMul a b) (HMul.hMul a c)) (Ne b c)","decl":"protected lemma mul_ne_mul_right (ha : a ≠ 0) : a * b ≠ a * c ↔ b ≠ c :=\n  not_congr (Nat.mul_right_inj ha)\n\n"}
{"name":"Nat.mul_eq_left","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nha : Ne a 0\n⊢ Iff (Eq (HMul.hMul a b) a) (Eq b 1)","decl":"lemma mul_eq_left (ha : a ≠ 0) : a * b = a ↔ b = 1 := by simpa using Nat.mul_right_inj ha (c := 1)\n"}
{"name":"Nat.mul_eq_right","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nhb : Ne b 0\n⊢ Iff (Eq (HMul.hMul a b) b) (Eq a 1)","decl":"lemma mul_eq_right (hb : b ≠ 0) : a * b = b ↔ a = 1 := by simpa using Nat.mul_left_inj hb (c := 1)\n\n-- TODO: Deprecate\n"}
{"name":"Nat.mul_right_eq_self_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nha : LT.lt 0 a\n⊢ Iff (Eq (HMul.hMul a b) a) (Eq b 1)","decl":"lemma mul_right_eq_self_iff (ha : 0 < a) : a * b = a ↔ b = 1 := mul_eq_left <| ne_of_gt ha\n\n"}
{"name":"Nat.mul_left_eq_self_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nhb : LT.lt 0 b\n⊢ Iff (Eq (HMul.hMul a b) b) (Eq a 1)","decl":"lemma mul_left_eq_self_iff (hb : 0 < b) : a * b = b ↔ a = 1 := mul_eq_right <| ne_of_gt hb\n\n"}
{"name":"Nat.le_of_mul_le_mul_right","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nh : LE.le (HMul.hMul a c) (HMul.hMul b c)\nhc : LT.lt 0 c\n⊢ LE.le a b","decl":"protected lemma le_of_mul_le_mul_right (h : a * c ≤ b * c) (hc : 0 < c) : a ≤ b :=\n  Nat.le_of_mul_le_mul_left (by simpa [Nat.mul_comm]) hc\n\n"}
{"name":"Nat.mul_sub","module":"Mathlib.Data.Nat.Defs","initialProofState":"n m k : Nat\n⊢ Eq (HMul.hMul n (HSub.hSub m k)) (HSub.hSub (HMul.hMul n m) (HMul.hMul n k))","decl":"protected alias mul_sub := Nat.mul_sub_left_distrib\n"}
{"name":"Nat.sub_mul","module":"Mathlib.Data.Nat.Defs","initialProofState":"n m k : Nat\n⊢ Eq (HMul.hMul (HSub.hSub n m) k) (HSub.hSub (HMul.hMul n k) (HMul.hMul m k))","decl":"protected alias sub_mul := Nat.mul_sub_right_distrib\n\n"}
{"name":"Nat.one_lt_mul_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (LT.lt 1 (HMul.hMul m n)) (And (LT.lt 0 m) (And (LT.lt 0 n) (Or (LT.lt 1 m) (LT.lt 1 n))))","decl":"set_option push_neg.use_distrib true in\n/-- The product of two natural numbers is greater than 1 if and only if\n  at least one of them is greater than 1 and both are positive. -/\nlemma one_lt_mul_iff : 1 < m * n ↔ 0 < m ∧ 0 < n ∧ (1 < m ∨ 1 < n) := by\n  constructor <;> intro h\n  · by_contra h'; push_neg at h'; simp [Nat.le_zero] at h'\n    obtain rfl | rfl | h' := h'\n    · simp at h\n    · simp at h\n    · exact Nat.not_lt_of_le (Nat.mul_le_mul h'.1 h'.2) h\n  · obtain hm | hn := h.2.2\n    · exact Nat.mul_lt_mul_of_lt_of_le' hm h.2.1 Nat.zero_lt_one\n    · exact Nat.mul_lt_mul_of_le_of_lt h.1 hn h.1\n\n"}
{"name":"Nat.eq_one_of_mul_eq_one_right","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\nH : Eq (HMul.hMul m n) 1\n⊢ Eq m 1","decl":"lemma eq_one_of_mul_eq_one_right (H : m * n = 1) : m = 1 := eq_one_of_dvd_one ⟨n, H.symm⟩\n\n"}
{"name":"Nat.eq_one_of_mul_eq_one_left","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\nH : Eq (HMul.hMul m n) 1\n⊢ Eq n 1","decl":"lemma eq_one_of_mul_eq_one_left (H : m * n = 1) : n = 1 :=\n  eq_one_of_mul_eq_one_right (n := m) (by rwa [Nat.mul_comm])\n\n"}
{"name":"Nat.lt_mul_iff_one_lt_left","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nhb : LT.lt 0 b\n⊢ Iff (LT.lt b (HMul.hMul a b)) (LT.lt 1 a)","decl":"@[simp] protected lemma lt_mul_iff_one_lt_left (hb : 0 < b) : b < a * b ↔ 1 < a := by\n  simpa using Nat.mul_lt_mul_right (b := 1) hb\n\n"}
{"name":"Nat.lt_mul_iff_one_lt_right","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nha : LT.lt 0 a\n⊢ Iff (LT.lt a (HMul.hMul a b)) (LT.lt 1 b)","decl":"@[simp] protected lemma lt_mul_iff_one_lt_right (ha : 0 < a) : a < a * b ↔ 1 < b := by\n  simpa using Nat.mul_lt_mul_left (b := 1) ha\n\n"}
{"name":"Nat.eq_zero_of_double_le","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\nh : LE.le (HMul.hMul 2 n) n\n⊢ Eq n 0","decl":"lemma eq_zero_of_double_le (h : 2 * n ≤ n) : n = 0 := by omega\n\n"}
{"name":"Nat.eq_zero_of_mul_le","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\nhb : LE.le 2 n\nh : LE.le (HMul.hMul n m) m\n⊢ Eq m 0","decl":"lemma eq_zero_of_mul_le (hb : 2 ≤ n) (h : n * m ≤ m) : m = 0 :=\n  eq_zero_of_double_le <| Nat.le_trans (Nat.mul_le_mul_right _ hb) h\n\n"}
{"name":"Nat.succ_mul_pos","module":"Mathlib.Data.Nat.Defs","initialProofState":"n m : Nat\nhn : LT.lt 0 n\n⊢ LT.lt 0 (HMul.hMul m.succ n)","decl":"lemma succ_mul_pos (m : ℕ) (hn : 0 < n) : 0 < succ m * n := Nat.mul_pos m.succ_pos hn\n\n"}
{"name":"Nat.mul_self_le_mul_self","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\nh : LE.le m n\n⊢ LE.le (HMul.hMul m m) (HMul.hMul n n)","decl":"lemma mul_self_le_mul_self (h : m ≤ n) : m * m ≤ n * n := Nat.mul_le_mul h h\n\n"}
{"name":"Nat.mul_lt_mul''","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c d : Nat\nhac : LT.lt a c\nhbd : LT.lt b d\n⊢ LT.lt (HMul.hMul a b) (HMul.hMul c d)","decl":"lemma mul_lt_mul'' (hac : a < c) (hbd : b < d) : a * b < c * d :=\n  Nat.mul_lt_mul_of_lt_of_le hac (Nat.le_of_lt hbd) <| by omega\n\n"}
{"name":"Nat.mul_self_lt_mul_self","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\nh : LT.lt m n\n⊢ LT.lt (HMul.hMul m m) (HMul.hMul n n)","decl":"lemma mul_self_lt_mul_self (h : m < n) : m * m < n * n := mul_lt_mul'' h h\n\n"}
{"name":"Nat.mul_self_le_mul_self_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (LE.le (HMul.hMul m m) (HMul.hMul n n)) (LE.le m n)","decl":"lemma mul_self_le_mul_self_iff : m * m ≤ n * n ↔ m ≤ n :=\n  ⟨fun h => Nat.le_of_not_lt fun h' => Nat.not_le_of_gt (mul_self_lt_mul_self h') h,\n   mul_self_le_mul_self⟩\n\n"}
{"name":"Nat.mul_self_lt_mul_self_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (LT.lt (HMul.hMul m m) (HMul.hMul n n)) (LT.lt m n)","decl":"lemma mul_self_lt_mul_self_iff : m * m < n * n ↔ m < n := by\n  simp only [← Nat.not_le, mul_self_le_mul_self_iff]\n\n"}
{"name":"Nat.le_mul_self","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ LE.le n (HMul.hMul n n)","decl":"lemma le_mul_self : ∀ n : ℕ, n ≤ n * n\n  | 0 => Nat.le_refl _\n  | n + 1 => by simp [Nat.mul_add]\n\n"}
{"name":"Nat.mul_self_inj","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (Eq (HMul.hMul m m) (HMul.hMul n n)) (Eq m n)","decl":"lemma mul_self_inj : m * m = n * n ↔ m = n := by\n  simp [Nat.le_antisymm_iff, mul_self_le_mul_self_iff]\n\n"}
{"name":"Nat.lt_mul_self_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Iff (LT.lt n (HMul.hMul n n)) (LT.lt 1 n)","decl":"@[simp] lemma lt_mul_self_iff : ∀ {n : ℕ}, n < n * n ↔ 1 < n\n  | 0 => by simp\n  | n + 1 => Nat.lt_mul_iff_one_lt_left n.succ_pos\n\n"}
{"name":"Nat.add_sub_one_le_mul","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nha : Ne a 0\nhb : Ne b 0\n⊢ LE.le (HSub.hSub (HAdd.hAdd a b) 1) (HMul.hMul a b)","decl":"lemma add_sub_one_le_mul (ha : a ≠ 0) (hb : b ≠ 0) : a + b - 1 ≤ a * b := by\n  cases a\n  · cases ha rfl\n  · rw [succ_add, Nat.add_one_sub_one, succ_mul]\n    exact Nat.add_le_add_right (Nat.le_mul_of_pos_right _ <| Nat.pos_iff_ne_zero.2 hb) _\n\n"}
{"name":"Nat.add_le_mul","module":"Mathlib.Data.Nat.Defs","initialProofState":"a : Nat\nha : LE.le 2 a\nb : Nat\nx✝ : LE.le 2 b\n⊢ LE.le (HAdd.hAdd a b) (HMul.hMul a b)","decl":"protected lemma add_le_mul {a : ℕ} (ha : 2 ≤ a) : ∀ {b : ℕ} (_ : 2 ≤ b), a + b ≤ a * b\n  | 2, _ => by omega\n  | b + 3, _ => by have := Nat.add_le_mul ha (Nat.le_add_left _ b); rw [mul_succ]; omega\n\n"}
{"name":"Nat.le_div_two_iff_mul_two_le","module":"Mathlib.Data.Nat.Defs","initialProofState":"n m : Nat\n⊢ Iff (LE.le m (HDiv.hDiv n 2)) (LE.le (HMul.hMul (↑m) 2) ↑n)","decl":"lemma le_div_two_iff_mul_two_le {n m : ℕ} : m ≤ n / 2 ↔ (m : ℤ) * 2 ≤ n := by\n  rw [Nat.le_div_iff_mul_le Nat.zero_lt_two, ← Int.ofNat_le, Int.ofNat_mul]; rfl\n\n"}
{"name":"Nat.div_le_iff_le_mul_add_pred","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nhb : LT.lt 0 b\n⊢ Iff (LE.le (HDiv.hDiv a b) c) (LE.le a (HAdd.hAdd (HMul.hMul b c) (HSub.hSub b 1)))","decl":"lemma div_le_iff_le_mul_add_pred (hb : 0 < b) : a / b ≤ c ↔ a ≤ b * c + (b - 1) := by\n  rw [← Nat.lt_succ_iff, div_lt_iff_lt_mul hb, succ_mul, Nat.mul_comm]\n  cases hb <;> exact Nat.lt_succ_iff\n\n"}
{"name":"Nat.div_lt_self'","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\n⊢ LT.lt (HDiv.hDiv (HAdd.hAdd a 1) (HAdd.hAdd b 2)) (HAdd.hAdd a 1)","decl":"/-- A version of `Nat.div_lt_self` using successors, rather than additional hypotheses. -/\nlemma div_lt_self' (a b : ℕ) : (a + 1) / (b + 2) < a + 1 :=\n  Nat.div_lt_self (Nat.succ_pos _) (Nat.succ_lt_succ (Nat.succ_pos _))\n\n"}
{"name":"Nat.le_div_iff_mul_le'","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nhb : LT.lt 0 b\n⊢ Iff (LE.le a (HDiv.hDiv c b)) (LE.le (HMul.hMul a b) c)","decl":"@[deprecated le_div_iff_mul_le (since := \"2024-11-06\")]\nlemma le_div_iff_mul_le' (hb : 0 < b) : a ≤ c / b ↔ a * b ≤ c := le_div_iff_mul_le hb\n\n"}
{"name":"Nat.div_lt_iff_lt_mul'","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nhb : LT.lt 0 b\n⊢ Iff (LT.lt (HDiv.hDiv a b) c) (LT.lt a (HMul.hMul c b))","decl":"@[deprecated div_lt_iff_lt_mul (since := \"2024-11-06\")]\nlemma div_lt_iff_lt_mul' (hb : 0 < b) : a / b < c ↔ a < c * b := div_lt_iff_lt_mul hb\n\n"}
{"name":"Nat.one_le_div_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nhb : LT.lt 0 b\n⊢ Iff (LE.le 1 (HDiv.hDiv a b)) (LE.le b a)","decl":"lemma one_le_div_iff (hb : 0 < b) : 1 ≤ a / b ↔ b ≤ a := by rw [le_div_iff_mul_le hb, Nat.one_mul]\n\n"}
{"name":"Nat.div_lt_one_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nhb : LT.lt 0 b\n⊢ Iff (LT.lt (HDiv.hDiv a b) 1) (LT.lt a b)","decl":"lemma div_lt_one_iff (hb : 0 < b) : a / b < 1 ↔ a < b := by\n  simp only [← Nat.not_le, one_le_div_iff hb]\n\n"}
{"name":"Nat.div_le_div_right","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nh : LE.le a b\n⊢ LE.le (HDiv.hDiv a c) (HDiv.hDiv b c)","decl":"@[gcongr]\nprotected lemma div_le_div_right (h : a ≤ b) : a / c ≤ b / c :=\n  (c.eq_zero_or_pos.elim fun hc ↦ by simp [hc]) fun hc ↦\n    (le_div_iff_mul_le hc).2 <| Nat.le_trans (Nat.div_mul_le_self _ _) h\n\n"}
{"name":"Nat.lt_of_div_lt_div","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nh : LT.lt (HDiv.hDiv a c) (HDiv.hDiv b c)\n⊢ LT.lt a b","decl":"lemma lt_of_div_lt_div (h : a / c < b / c) : a < b :=\n  Nat.lt_of_not_le fun hab ↦ Nat.not_le_of_lt h <| Nat.div_le_div_right hab\n\n"}
{"name":"Nat.div_eq_zero_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\n⊢ Iff (Eq (HDiv.hDiv a b) 0) (Or (Eq b 0) (LT.lt a b))","decl":"@[simp] protected lemma div_eq_zero_iff : a / b = 0 ↔ b = 0 ∨ a < b where\n  mp h := by\n    rw [← mod_add_div a b, h, Nat.mul_zero, Nat.add_zero, or_iff_not_imp_left]\n    exact mod_lt _ ∘ Nat.pos_iff_ne_zero.2\n  mpr := by\n    obtain rfl | hb := eq_or_ne b 0\n    · simp\n    simp only [hb, false_or]\n    rw [← Nat.mul_right_inj hb, ← Nat.add_left_cancel_iff, mod_add_div]\n    simp +contextual [mod_eq_of_lt]\n\n"}
{"name":"Nat.div_ne_zero_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\n⊢ Iff (Ne (HDiv.hDiv a b) 0) (And (Ne b 0) (LE.le b a))","decl":"protected lemma div_ne_zero_iff : a / b ≠ 0 ↔ b ≠ 0 ∧ b ≤ a := by simp\n\n"}
{"name":"Nat.div_pos_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\n⊢ Iff (LT.lt 0 (HDiv.hDiv a b)) (And (LT.lt 0 b) (LE.le b a))","decl":"@[simp] protected lemma div_pos_iff : 0 < a / b ↔ 0 < b ∧ b ≤ a := by\n  simp [Nat.pos_iff_ne_zero]\n\n"}
{"name":"Nat.div_pos","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nhba : LE.le b a\nhb : LT.lt 0 b\n⊢ LT.lt 0 (HDiv.hDiv a b)","decl":"protected lemma div_pos (hba : b ≤ a) (hb : 0 < b) : 0 < a / b := Nat.div_pos_iff.2 ⟨hb, hba⟩\n\n"}
{"name":"Nat.lt_mul_of_div_lt","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nh : LT.lt (HDiv.hDiv a c) b\nhc : LT.lt 0 c\n⊢ LT.lt a (HMul.hMul b c)","decl":"lemma lt_mul_of_div_lt (h : a / c < b) (hc : 0 < c) : a < b * c :=\n  Nat.lt_of_not_ge <| Nat.not_le_of_gt h ∘ (Nat.le_div_iff_mul_le hc).2\n\n"}
{"name":"Nat.mul_div_le_mul_div_assoc","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\n⊢ LE.le (HMul.hMul a (HDiv.hDiv b c)) (HDiv.hDiv (HMul.hMul a b) c)","decl":"lemma mul_div_le_mul_div_assoc (a b c : ℕ) : a * (b / c) ≤ a * b / c :=\n  if hc0 : c = 0 then by simp [hc0] else\n    (Nat.le_div_iff_mul_le (Nat.pos_of_ne_zero hc0)).2\n      (by rw [Nat.mul_assoc]; exact Nat.mul_le_mul_left _ (Nat.div_mul_le_self _ _))\n\n"}
{"name":"Nat.eq_mul_of_div_eq_left","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nH1 : Dvd.dvd b a\nH2 : Eq (HDiv.hDiv a b) c\n⊢ Eq a (HMul.hMul c b)","decl":"protected lemma eq_mul_of_div_eq_left (H1 : b ∣ a) (H2 : a / b = c) : a = c * b := by\n  rw [Nat.mul_comm, Nat.eq_mul_of_div_eq_right H1 H2]\n\n"}
{"name":"Nat.mul_div_cancel_left'","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nHd : Dvd.dvd a b\n⊢ Eq (HMul.hMul a (HDiv.hDiv b a)) b","decl":"protected lemma mul_div_cancel_left' (Hd : a ∣ b) : a * (b / a) = b := by\n  rw [Nat.mul_comm, Nat.div_mul_cancel Hd]\n\n"}
{"name":"Nat.lt_div_mul_add","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nhb : LT.lt 0 b\n⊢ LT.lt a (HAdd.hAdd (HMul.hMul (HDiv.hDiv a b) b) b)","decl":"lemma lt_div_mul_add (hb : 0 < b) : a < a / b * b + b := by\n  rw [← Nat.succ_mul, ← Nat.div_lt_iff_lt_mul hb]; exact Nat.lt_succ_self _\n\n"}
{"name":"Nat.div_left_inj","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b d : Nat\nhda : Dvd.dvd d a\nhdb : Dvd.dvd d b\n⊢ Iff (Eq (HDiv.hDiv a d) (HDiv.hDiv b d)) (Eq a b)","decl":"@[simp]\nprotected lemma div_left_inj (hda : d ∣ a) (hdb : d ∣ b) : a / d = b / d ↔ a = b := by\n  refine ⟨fun h ↦ ?_, congrArg fun b ↦ b / d⟩\n  rw [← Nat.mul_div_cancel' hda, ← Nat.mul_div_cancel' hdb, h]\n\n"}
{"name":"Nat.div_mul_div_comm","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c d : Nat\na✝¹ : Dvd.dvd b a\na✝ : Dvd.dvd d c\n⊢ Eq (HMul.hMul (HDiv.hDiv a b) (HDiv.hDiv c d)) (HDiv.hDiv (HMul.hMul a c) (HMul.hMul b d))","decl":"lemma div_mul_div_comm : b ∣ a → d ∣ c → (a / b) * (c / d) = (a * c) / (b * d) := by\n  rintro ⟨x, rfl⟩ ⟨y, rfl⟩\n  obtain rfl | hb := b.eq_zero_or_pos\n  · simp\n  obtain rfl | hd := d.eq_zero_or_pos\n  · simp\n  rw [Nat.mul_div_cancel_left _ hb, Nat.mul_div_cancel_left _ hd, Nat.mul_assoc b,\n    Nat.mul_left_comm x, ← Nat.mul_assoc b, Nat.mul_div_cancel_left _ (Nat.mul_pos hb hd)]\n\n"}
{"name":"Nat.mul_div_mul_comm","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c d : Nat\nhba : Dvd.dvd b a\nhdc : Dvd.dvd d c\n⊢ Eq (HDiv.hDiv (HMul.hMul a c) (HMul.hMul b d)) (HMul.hMul (HDiv.hDiv a b) (HDiv.hDiv c d))","decl":"protected lemma mul_div_mul_comm (hba : b ∣ a) (hdc : d ∣ c) : a * c / (b * d) = a / b * (c / d) :=\n  (div_mul_div_comm hba hdc).symm\n\n"}
{"name":"Nat.eq_zero_of_le_div","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\nhn : LE.le 2 n\nh : LE.le m (HDiv.hDiv m n)\n⊢ Eq m 0","decl":"lemma eq_zero_of_le_div (hn : 2 ≤ n) (h : m ≤ m / n) : m = 0 :=\n  eq_zero_of_mul_le hn <| by\n    rw [Nat.mul_comm]; exact (Nat.le_div_iff_mul_le (Nat.lt_of_lt_of_le (by decide) hn)).1 h\n\n"}
{"name":"Nat.div_mul_div_le_div","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\n⊢ LE.le (HDiv.hDiv (HMul.hMul (HDiv.hDiv a c) b) a) (HDiv.hDiv b c)","decl":"lemma div_mul_div_le_div (a b c : ℕ) : a / c * b / a ≤ b / c := by\n  obtain rfl | ha := Nat.eq_zero_or_pos a\n  · simp\n  · calc\n      a / c * b / a ≤ b * a / c / a :=\n        Nat.div_le_div_right (by rw [Nat.mul_comm]; exact mul_div_le_mul_div_assoc _ _ _)\n      _ = b / c := by rw [Nat.div_div_eq_div_mul, Nat.mul_comm b, Nat.mul_comm c,\n          Nat.mul_div_mul_left _ _ ha]\n\n"}
{"name":"Nat.eq_zero_of_le_half","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\nh : LE.le n (HDiv.hDiv n 2)\n⊢ Eq n 0","decl":"lemma eq_zero_of_le_half (h : n ≤ n / 2) : n = 0 := eq_zero_of_le_div (Nat.le_refl _) h\n\n"}
{"name":"Nat.le_half_of_half_lt_sub","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nh : LT.lt (HDiv.hDiv a 2) (HSub.hSub a b)\n⊢ LE.le b (HDiv.hDiv a 2)","decl":"lemma le_half_of_half_lt_sub (h : a / 2 < a - b) : b ≤ a / 2 := by\n  omega\n\n"}
{"name":"Nat.half_le_of_sub_le_half","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nh : LE.le (HSub.hSub a b) (HDiv.hDiv a 2)\n⊢ LE.le (HDiv.hDiv a 2) b","decl":"lemma half_le_of_sub_le_half (h : a - b ≤ a / 2) : a / 2 ≤ b := by\n  omega\n\n"}
{"name":"Nat.div_le_of_le_mul'","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n k : Nat\nh : LE.le m (HMul.hMul k n)\n⊢ LE.le (HDiv.hDiv m k) n","decl":"protected lemma div_le_of_le_mul' (h : m ≤ k * n) : m / k ≤ n := by\n  obtain rfl | hk := k.eq_zero_or_pos\n  · simp\n  · refine Nat.le_of_mul_le_mul_left ?_ hk\n    calc\n      k * (m / k) ≤ m % k + k * (m / k) := Nat.le_add_left _ _\n      _ = m := mod_add_div _ _\n      _ ≤ k * n := h\n\n"}
{"name":"Nat.div_le_div_of_mul_le_mul","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c d : Nat\nhd : Ne d 0\nhdc : Dvd.dvd d c\nh : LE.le (HMul.hMul a d) (HMul.hMul c b)\n⊢ LE.le (HDiv.hDiv a b) (HDiv.hDiv c d)","decl":"protected lemma div_le_div_of_mul_le_mul (hd : d ≠ 0) (hdc : d ∣ c) (h : a * d ≤ c * b) :\n    a / b ≤ c / d :=\n  Nat.div_le_of_le_mul' <| by\n    rwa [← Nat.mul_div_assoc _ hdc, Nat.le_div_iff_mul_le (Nat.pos_iff_ne_zero.2 hd), b.mul_comm]\n\n"}
{"name":"Nat.div_le_self'","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ LE.le (HDiv.hDiv m n) m","decl":"protected lemma div_le_self' (m n : ℕ) : m / n ≤ m := by\n  obtain rfl | hn := n.eq_zero_or_pos\n  · simp\n  · refine Nat.div_le_of_le_mul' ?_\n    calc\n      m = 1 * m := by rw [Nat.one_mul]\n      _ ≤ n * m := Nat.mul_le_mul_right _ hn\n\n"}
{"name":"Nat.two_mul_odd_div_two","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\nhn : Eq (HMod.hMod n 2) 1\n⊢ Eq (HMul.hMul 2 (HDiv.hDiv n 2)) (HSub.hSub n 1)","decl":"lemma two_mul_odd_div_two (hn : n % 2 = 1) : 2 * (n / 2) = n - 1 := by\n  conv => rhs; rw [← Nat.mod_add_div n 2, hn, Nat.add_sub_cancel_left]\n\n"}
{"name":"Nat.div_le_div_left","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nhcb : LE.le c b\nhc : LT.lt 0 c\n⊢ LE.le (HDiv.hDiv a b) (HDiv.hDiv a c)","decl":"@[gcongr]\nlemma div_le_div_left (hcb : c ≤ b) (hc : 0 < c) : a / b ≤ a / c :=\n  (Nat.le_div_iff_mul_le hc).2 <| Nat.le_trans (Nat.mul_le_mul_left _ hcb) (div_mul_le_self _ _)\n\n"}
{"name":"Nat.div_eq_self","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (Eq (HDiv.hDiv m n) m) (Or (Eq m 0) (Eq n 1))","decl":"lemma div_eq_self : m / n = m ↔ m = 0 ∨ n = 1 := by\n  constructor\n  · intro\n    match n with\n    | 0 => simp_all\n    | 1 => right; rfl\n    | n+2 =>\n      left\n      have : m / (n + 2) ≤ m / 2 := div_le_div_left (by simp) (by decide)\n      refine eq_zero_of_le_half ?_\n      simp_all\n  · rintro (rfl | rfl) <;> simp\n\n"}
{"name":"Nat.div_eq_sub_mod_div","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Eq (HDiv.hDiv m n) (HDiv.hDiv (HSub.hSub m (HMod.hMod m n)) n)","decl":"lemma div_eq_sub_mod_div : m / n = (m - m % n) / n := by\n  obtain rfl | hn := n.eq_zero_or_pos\n  · rw [Nat.div_zero, Nat.div_zero]\n  · have : m - m % n = n * (m / n) := by\n      rw [Nat.sub_eq_iff_eq_add (Nat.mod_le _ _), Nat.add_comm, mod_add_div]\n    rw [this, mul_div_right _ hn]\n\n"}
{"name":"Nat.eq_div_of_mul_eq_left","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nhc : Ne c 0\nh : Eq (HMul.hMul a c) b\n⊢ Eq a (HDiv.hDiv b c)","decl":"protected lemma eq_div_of_mul_eq_left (hc : c ≠ 0) (h : a * c = b) : a = b / c := by\n  rw [← h, Nat.mul_div_cancel _ (Nat.pos_iff_ne_zero.2 hc)]\n\n"}
{"name":"Nat.eq_div_of_mul_eq_right","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nhc : Ne c 0\nh : Eq (HMul.hMul c a) b\n⊢ Eq a (HDiv.hDiv b c)","decl":"protected lemma eq_div_of_mul_eq_right (hc : c ≠ 0) (h : c * a = b) : a = b / c := by\n  rw [← h, Nat.mul_div_cancel_left _ (Nat.pos_iff_ne_zero.2 hc)]\n\n"}
{"name":"Nat.mul_le_of_le_div","module":"Mathlib.Data.Nat.Defs","initialProofState":"k x y : Nat\nh : LE.le x (HDiv.hDiv y k)\n⊢ LE.le (HMul.hMul x k) y","decl":"protected lemma mul_le_of_le_div (k x y : ℕ) (h : x ≤ y / k) : x * k ≤ y := by\n  if hk : k = 0 then\n    rw [hk, Nat.mul_zero]; exact zero_le _\n  else\n    rwa [← le_div_iff_mul_le (Nat.pos_iff_ne_zero.2 hk)]\n\n"}
{"name":"Nat.div_mul_div_le","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c d : Nat\n⊢ LE.le (HMul.hMul (HDiv.hDiv a b) (HDiv.hDiv c d)) (HDiv.hDiv (HMul.hMul a c) (HMul.hMul b d))","decl":"protected lemma div_mul_div_le (a b c d : ℕ) :\n    (a / b) * (c / d) ≤ (a * c) / (b * d) := by\n  if hb : b = 0 then simp [hb] else\n  if hd : d = 0 then simp [hd] else\n  have hbd : b * d ≠ 0 := Nat.mul_ne_zero hb hd\n  rw [le_div_iff_mul_le (Nat.pos_of_ne_zero hbd)]\n  transitivity ((a / b) * b) * ((c / d) * d)\n  · apply Nat.le_of_eq; simp only [Nat.mul_assoc, Nat.mul_left_comm]\n  · apply Nat.mul_le_mul <;> apply div_mul_le_self\n\n"}
{"name":"Nat.pow_lt_pow_left","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nh : LT.lt a b\nn : Nat\na✝ : Ne n 0\n⊢ LT.lt (HPow.hPow a n) (HPow.hPow b n)","decl":"protected lemma pow_lt_pow_left (h : a < b) : ∀ {n : ℕ}, n ≠ 0 → a ^ n < b ^ n\n  | 1, _ => by simpa\n  | n + 2, _ => Nat.mul_lt_mul_of_lt_of_le (Nat.pow_lt_pow_left h n.succ_ne_zero) (Nat.le_of_lt h)\n    (zero_lt_of_lt h)\n\n"}
{"name":"Nat.pow_lt_pow_right","module":"Mathlib.Data.Nat.Defs","initialProofState":"a m n : Nat\nha : LT.lt 1 a\nh : LT.lt m n\n⊢ LT.lt (HPow.hPow a m) (HPow.hPow a n)","decl":"protected lemma pow_lt_pow_right (ha : 1 < a) (h : m < n) : a ^ m < a ^ n :=\n  (Nat.pow_lt_pow_iff_right ha).2 h\n\n"}
{"name":"Nat.pow_le_pow_iff_left","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b n : Nat\nhn : Ne n 0\n⊢ Iff (LE.le (HPow.hPow a n) (HPow.hPow b n)) (LE.le a b)","decl":"protected lemma pow_le_pow_iff_left {n : ℕ} (hn : n ≠ 0) : a ^ n ≤ b ^ n ↔ a ≤ b where\n  mp := by simpa only [← Nat.not_le, Decidable.not_imp_not] using (Nat.pow_lt_pow_left · hn)\n  mpr h := Nat.pow_le_pow_left h _\n\n"}
{"name":"Nat.pow_lt_pow_iff_left","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b n : Nat\nhn : Ne n 0\n⊢ Iff (LT.lt (HPow.hPow a n) (HPow.hPow b n)) (LT.lt a b)","decl":"protected lemma pow_lt_pow_iff_left (hn : n ≠ 0) : a ^ n < b ^ n ↔ a < b := by\n  simp only [← Nat.not_le, Nat.pow_le_pow_iff_left hn]\n\n"}
{"name":"Nat.pow_left_injective","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\nhn : Ne n 0\n⊢ Function.Injective fun a => HPow.hPow a n","decl":"lemma pow_left_injective (hn : n ≠ 0) : Injective (fun a : ℕ ↦ a ^ n) := by\n  simp [Injective, le_antisymm_iff, Nat.pow_le_pow_iff_left hn]\n\n"}
{"name":"Nat.pow_right_injective","module":"Mathlib.Data.Nat.Defs","initialProofState":"a : Nat\nha : LE.le 2 a\n⊢ Function.Injective fun x => HPow.hPow a x","decl":"protected lemma pow_right_injective (ha : 2 ≤ a) : Injective (a ^ ·) := by\n  simp [Injective, le_antisymm_iff, Nat.pow_le_pow_iff_right ha]\n\n-- We want to use this lemma earlier than the lemma simp can prove it with\n"}
{"name":"Nat.pow_eq_zero","module":"Mathlib.Data.Nat.Defs","initialProofState":"a n : Nat\n⊢ Iff (Eq (HPow.hPow a n) 0) (And (Eq a 0) (Ne n 0))","decl":"@[simp, nolint simpNF] protected lemma pow_eq_zero {a : ℕ} : ∀ {n : ℕ}, a ^ n = 0 ↔ a = 0 ∧ n ≠ 0\n  | 0 => by simp\n  | n + 1 => by rw [Nat.pow_succ, mul_eq_zero, Nat.pow_eq_zero]; omega\n\n"}
{"name":"Nat.pow_eq_self_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nha : LT.lt 1 a\n⊢ Iff (Eq (HPow.hPow a b) a) (Eq b 1)","decl":"/-- For `a > 1`, `a ^ b = a` iff `b = 1`. -/\nlemma pow_eq_self_iff {a b : ℕ} (ha : 1 < a) : a ^ b = a ↔ b = 1 :=\n  (Nat.pow_right_injective ha).eq_iff' a.pow_one\n\n"}
{"name":"Nat.le_self_pow","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\nhn : Ne n 0\na : Nat\n⊢ LE.le a (HPow.hPow a n)","decl":"lemma le_self_pow (hn : n ≠ 0) : ∀ a : ℕ, a ≤ a ^ n\n  | 0 => zero_le _\n  | a + 1 => by simpa using Nat.pow_le_pow_right a.succ_pos (Nat.one_le_iff_ne_zero.2 hn)\n\n"}
{"name":"Nat.one_le_pow","module":"Mathlib.Data.Nat.Defs","initialProofState":"n m : Nat\nh : LT.lt 0 m\n⊢ LE.le 1 (HPow.hPow m n)","decl":"lemma one_le_pow (n m : ℕ) (h : 0 < m) : 1 ≤ m ^ n := by simpa using Nat.pow_le_pow_of_le_left h n\n\n"}
{"name":"Nat.one_le_pow'","module":"Mathlib.Data.Nat.Defs","initialProofState":"n m : Nat\n⊢ LE.le 1 (HPow.hPow (HAdd.hAdd m 1) n)","decl":"lemma one_le_pow' (n m : ℕ) : 1 ≤ (m + 1) ^ n := one_le_pow n (m + 1) (succ_pos m)\n\n"}
{"name":"Nat.one_lt_pow","module":"Mathlib.Data.Nat.Defs","initialProofState":"a n : Nat\nhn : Ne n 0\nha : LT.lt 1 a\n⊢ LT.lt 1 (HPow.hPow a n)","decl":"lemma one_lt_pow (hn : n ≠ 0) (ha : 1 < a) : 1 < a ^ n := by simpa using Nat.pow_lt_pow_left ha hn\n\n"}
{"name":"Nat.two_pow_succ","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Eq (HPow.hPow 2 (HAdd.hAdd n 1)) (HAdd.hAdd (HPow.hPow 2 n) (HPow.hPow 2 n))","decl":"lemma two_pow_succ (n : ℕ) : 2 ^ (n + 1) = 2 ^ n + 2 ^ n := by simp [Nat.pow_succ, Nat.mul_two]\n\n"}
{"name":"Nat.one_lt_pow'","module":"Mathlib.Data.Nat.Defs","initialProofState":"n m : Nat\n⊢ LT.lt 1 (HPow.hPow (HAdd.hAdd m 2) (HAdd.hAdd n 1))","decl":"lemma one_lt_pow' (n m : ℕ) : 1 < (m + 2) ^ (n + 1) :=\n  one_lt_pow n.succ_ne_zero (Nat.lt_of_sub_eq_succ rfl)\n\n"}
{"name":"Nat.one_lt_pow_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\nhn : Ne n 0\na : Nat\n⊢ Iff (LT.lt 1 (HPow.hPow a n)) (LT.lt 1 a)","decl":"@[simp] lemma one_lt_pow_iff {n : ℕ} (hn : n ≠ 0) : ∀ {a}, 1 < a ^ n ↔ 1 < a\n | 0 => by simp [Nat.zero_pow (Nat.pos_of_ne_zero hn)]\n | 1 => by simp\n | a + 2 => by simp [one_lt_pow hn]\n\n"}
{"name":"Nat.one_lt_two_pow'","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ LT.lt 1 (HPow.hPow 2 (HAdd.hAdd n 1))","decl":"lemma one_lt_two_pow' (n : ℕ) : 1 < 2 ^ (n + 1) := one_lt_pow n.succ_ne_zero (by decide)\n\n"}
{"name":"Nat.mul_lt_mul_pow_succ","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b n : Nat\nha : LT.lt 0 a\nhb : LT.lt 1 b\n⊢ LT.lt (HMul.hMul n b) (HMul.hMul a (HPow.hPow b (HAdd.hAdd n 1)))","decl":"lemma mul_lt_mul_pow_succ (ha : 0 < a) (hb : 1 < b) : n * b < a * b ^ (n + 1) := by\n  rw [Nat.pow_succ, ← Nat.mul_assoc, Nat.mul_lt_mul_right (Nat.lt_trans Nat.zero_lt_one hb)]\n  exact Nat.lt_of_le_of_lt (Nat.le_mul_of_pos_left _ ha)\n    ((Nat.mul_lt_mul_left ha).2 <| Nat.lt_pow_self hb)\n\n"}
{"name":"Nat.sq_sub_sq","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\n⊢ Eq (HSub.hSub (HPow.hPow a 2) (HPow.hPow b 2)) (HMul.hMul (HAdd.hAdd a b) (HSub.hSub a b))","decl":"lemma sq_sub_sq (a b : ℕ) : a ^ 2 - b ^ 2 = (a + b) * (a - b) := by\n  simpa [Nat.pow_succ] using Nat.mul_self_sub_mul_self_eq a b\n\n"}
{"name":"Nat.pow_two_sub_pow_two","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\n⊢ Eq (HSub.hSub (HPow.hPow a 2) (HPow.hPow b 2)) (HMul.hMul (HAdd.hAdd a b) (HSub.hSub a b))","decl":"alias pow_two_sub_pow_two := sq_sub_sq\n\n"}
{"name":"Nat.div_pow","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nh : Dvd.dvd a b\n⊢ Eq (HPow.hPow (HDiv.hDiv b a) c) (HDiv.hDiv (HPow.hPow b c) (HPow.hPow a c))","decl":"protected lemma div_pow (h : a ∣ b) : (b / a) ^ c = b ^ c / a ^ c := by\n  obtain rfl | hc := c.eq_zero_or_pos\n  · simp\n  obtain rfl | ha := a.eq_zero_or_pos\n  · simp [Nat.zero_pow hc]\n  refine (Nat.div_eq_of_eq_mul_right (pos_pow_of_pos c ha) ?_).symm\n  rw [← Nat.mul_pow, Nat.mul_div_cancel_left' h]\n\n"}
{"name":"Nat.pow_pos_iff","module":"Mathlib.Data.Nat.Defs","initialProofState":"a n : Nat\n⊢ Iff (LT.lt 0 (HPow.hPow a n)) (Or (LT.lt 0 a) (Eq n 0))","decl":"protected lemma pow_pos_iff : 0 < a ^ n ↔ 0 < a ∨ n = 0 := by\n  simp [Nat.pos_iff_ne_zero, imp_iff_not_or]\n\n"}
{"name":"Nat.pow_self_pos","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ LT.lt 0 (HPow.hPow n n)","decl":"lemma pow_self_pos : 0 < n ^ n := by simp [Nat.pow_pos_iff, n.eq_zero_or_pos.symm]\n\n"}
{"name":"Nat.pow_self_mul_pow_self_le","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ LE.le (HMul.hMul (HPow.hPow m m) (HPow.hPow n n)) (HPow.hPow (HAdd.hAdd m n) (HAdd.hAdd m n))","decl":"lemma pow_self_mul_pow_self_le : m ^ m * n ^ n ≤ (m + n) ^ (m + n) := by\n  rw [Nat.pow_add]\n  exact Nat.mul_le_mul (Nat.pow_le_pow_left (le_add_right ..) _)\n    (Nat.pow_le_pow_left (le_add_left ..) _)\n\n"}
{"name":"Nat.rec_zero","module":"Mathlib.Data.Nat.Defs","initialProofState":"C : Nat → Sort u_1\nh0 : C 0\nh : (n : Nat) → C n → C (HAdd.hAdd n 1)\n⊢ Eq (Nat.rec h0 h 0) h0","decl":"@[simp]\nlemma rec_zero {C : ℕ → Sort*} (h0 : C 0) (h : ∀ n, C n → C (n + 1)) : Nat.rec h0 h 0 = h0 := rfl\n\n"}
{"name":"Nat.rec_add_one","module":"Mathlib.Data.Nat.Defs","initialProofState":"C : Nat → Sort u_1\nh0 : C 0\nh : (n : Nat) → C n → C (HAdd.hAdd n 1)\nn : Nat\n⊢ Eq (Nat.rec h0 h (HAdd.hAdd n 1)) (h n (Nat.rec h0 h n))","decl":"lemma rec_add_one {C : ℕ → Sort*} (h0 : C 0) (h : ∀ n, C n → C (n + 1)) (n : ℕ) :\n    Nat.rec h0 h (n + 1) = h n (Nat.rec h0 h n) := rfl\n\n"}
{"name":"Nat.rec_one","module":"Mathlib.Data.Nat.Defs","initialProofState":"C : Nat → Sort u_1\nh0 : C 0\nh : (n : Nat) → C n → C (HAdd.hAdd n 1)\n⊢ Eq (Nat.rec h0 h 1) (h 0 h0)","decl":"@[simp] lemma rec_one {C : ℕ → Sort*} (h0 : C 0) (h : ∀ n, C n → C (n + 1)) :\n    Nat.rec (motive := C) h0 h 1 = h 0 h0 := rfl\n\n"}
{"name":"Nat.leRec_eq_leRec","module":"Mathlib.Data.Nat.Defs","initialProofState":"⊢ Eq @Nat.leRec @Nat.le.rec","decl":"theorem leRec_eq_leRec : @Nat.leRec.{0} = @Nat.le.rec := rfl\n\n"}
{"name":"Nat.leRec_self","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\nmotive : (m : Nat) → LE.le n m → Sort u_1\nrefl : motive n ⋯\nle_succ_of_le : ⦃k : Nat⦄ → (h : LE.le n k) → motive k h → motive (HAdd.hAdd k 1) ⋯\n⊢ Eq (Nat.leRec refl le_succ_of_le ⋯) refl","decl":"@[simp]\nlemma leRec_self {n} {motive : (m : ℕ) → n ≤ m → Sort*}\n    (refl : motive n le_rfl)\n    (le_succ_of_le : ∀ ⦃k⦄ (h : n ≤ k), motive k h → motive (k + 1) (le_succ_of_le h)) :\n    (leRec (motive := motive) refl le_succ_of_le le_rfl : motive n le_rfl) = refl := by\n  cases n <;> simp [leRec, Or.by_cases, dif_neg]\n\n"}
{"name":"Nat.leRec_succ","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\nmotive : (m : Nat) → LE.le n m → Sort u_1\nrefl : motive n ⋯\nle_succ_of_le : ⦃k : Nat⦄ → (h : LE.le n k) → motive k h → motive (HAdd.hAdd k 1) ⋯\nh1 : LE.le n m\nh2 : LE.le n (HAdd.hAdd m 1)\n⊢ Eq (Nat.leRec refl le_succ_of_le h2) (le_succ_of_le h1 (Nat.leRec refl le_succ_of_le h1))","decl":"@[simp]\nlemma leRec_succ {n} {motive : (m : ℕ) → n ≤ m → Sort*}\n    (refl : motive n le_rfl)\n    (le_succ_of_le : ∀ ⦃k⦄ (h : n ≤ k), motive k h → motive (k + 1) (le_succ_of_le h))\n    (h1 : n ≤ m) {h2 : n ≤ m + 1} :\n    (leRec (motive := motive) refl le_succ_of_le h2) =\n      le_succ_of_le h1 (leRec (motive := motive) refl le_succ_of_le h1) := by\n  conv =>\n    lhs\n    rw [leRec, Or.by_cases, dif_pos h1]\n\n"}
{"name":"Nat.leRec_succ'","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\nmotive : (m : Nat) → LE.le n m → Sort u_1\nrefl : motive n ⋯\nle_succ_of_le : ⦃k : Nat⦄ → (h : LE.le n k) → motive k h → motive (HAdd.hAdd k 1) ⋯\n⊢ Eq (Nat.leRec refl le_succ_of_le ⋯) (le_succ_of_le ⋯ refl)","decl":"lemma leRec_succ' {n} {motive : (m : ℕ) → n ≤ m → Sort*} (refl le_succ_of_le) :\n    (leRec (motive := motive) refl le_succ_of_le (le_succ _)) = le_succ_of_le _ refl := by\n  rw [leRec_succ, leRec_self]\n\n"}
{"name":"Nat.leRec_trans","module":"Mathlib.Data.Nat.Defs","initialProofState":"n m k : Nat\nmotive : (m : Nat) → LE.le n m → Sort u_1\nrefl : motive n ⋯\nle_succ_of_le : ⦃k : Nat⦄ → (h : LE.le n k) → motive k h → motive (HAdd.hAdd k 1) ⋯\nhnm : LE.le n m\nhmk : LE.le m k\n⊢ Eq (Nat.leRec refl le_succ_of_le ⋯) (Nat.leRec (Nat.leRec refl (fun x h => le_succ_of_le h) hnm) (fun x h => le_succ_of_le ⋯) hmk)","decl":"lemma leRec_trans {n m k} {motive : (m : ℕ) → n ≤ m → Sort*} (refl le_succ_of_le)\n    (hnm : n ≤ m) (hmk : m ≤ k) :\n    leRec (motive := motive) refl le_succ_of_le (Nat.le_trans hnm hmk) =\n      leRec\n        (leRec refl (fun _ h => le_succ_of_le h) hnm)\n        (fun _ h => le_succ_of_le <| Nat.le_trans hnm h) hmk := by\n  induction hmk with\n  | refl => rw [leRec_self]\n  | step hmk ih => rw [leRec_succ _ _ (Nat.le_trans hnm hmk), ih, leRec_succ]\n\n"}
{"name":"Nat.leRec_succ_left","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\nmotive : (m : Nat) → LE.le n m → Sort u_1\nrefl : motive n ⋯\nle_succ_of_le : ⦃k : Nat⦄ → (h : LE.le n k) → motive k h → motive (HAdd.hAdd k 1) ⋯\nm : Nat\nh1 : LE.le n m\nh2 : LE.le (HAdd.hAdd n 1) m\n⊢ Eq (Nat.leRec (le_succ_of_le ⋯ refl) (fun x h ih => le_succ_of_le ⋯ ih) h2) (Nat.leRec refl le_succ_of_le h1)","decl":"lemma leRec_succ_left {motive : (m : ℕ) → n ≤ m → Sort*}\n    (refl le_succ_of_le) {m} (h1 : n ≤ m) (h2 : n + 1 ≤ m) :\n    -- the `@` is needed for this to elaborate, even though we only provide explicit arguments!\n    @leRec _ _ (le_succ_of_le le_rfl refl) (fun _ h ih => le_succ_of_le (le_of_succ_le h) ih) _ h2 =\n      leRec (motive := motive) refl le_succ_of_le h1 := by\n  rw [leRec_trans _ _ (le_succ n) h2, leRec_succ']\n\n"}
{"name":"Nat.leRecOn_self","module":"Mathlib.Data.Nat.Defs","initialProofState":"C : Nat → Sort u_1\nn : Nat\nnext : {k : Nat} → C k → C (HAdd.hAdd k 1)\nx : C n\n⊢ Eq (Nat.leRecOn ⋯ (fun {k} => next) x) x","decl":"lemma leRecOn_self {C : ℕ → Sort*} {n} {next : ∀ {k}, C k → C (k + 1)} (x : C n) :\n    (leRecOn n.le_refl next x : C n) = x :=\n  leRec_self _ _\n\n"}
{"name":"Nat.leRecOn_succ","module":"Mathlib.Data.Nat.Defs","initialProofState":"C : Nat → Sort u_1\nn m : Nat\nh1 : LE.le n m\nh2 : LE.le n (HAdd.hAdd m 1)\nnext : {k : Nat} → C k → C (HAdd.hAdd k 1)\nx : C n\n⊢ Eq (Nat.leRecOn h2 next x) (next (Nat.leRecOn h1 (fun {k} => next) x))","decl":"lemma leRecOn_succ {C : ℕ → Sort*} {n m} (h1 : n ≤ m) {h2 : n ≤ m + 1} {next} (x : C n) :\n    (leRecOn h2 next x : C (m + 1)) = next (leRecOn h1 next x : C m) :=\n  leRec_succ _ _ _\n\n"}
{"name":"Nat.leRecOn_succ'","module":"Mathlib.Data.Nat.Defs","initialProofState":"C : Nat → Sort u_1\nn : Nat\nh : LE.le n (HAdd.hAdd n 1)\nnext : {k : Nat} → C k → C (HAdd.hAdd k 1)\nx : C n\n⊢ Eq (Nat.leRecOn h (fun {k} => next) x) (next x)","decl":"lemma leRecOn_succ' {C : ℕ → Sort*} {n} {h : n ≤ n + 1} {next : ∀ {k}, C k → C (k + 1)} (x : C n) :\n    (leRecOn h next x : C (n + 1)) = next x :=\n  leRec_succ' _ _\n\n"}
{"name":"Nat.leRecOn_trans","module":"Mathlib.Data.Nat.Defs","initialProofState":"C : Nat → Sort u_1\nn m k : Nat\nhnm : LE.le n m\nhmk : LE.le m k\nnext : {k : Nat} → C k → C (HAdd.hAdd k 1)\nx : C n\n⊢ Eq (Nat.leRecOn ⋯ next x) (Nat.leRecOn hmk next (Nat.leRecOn hnm next x))","decl":"lemma leRecOn_trans {C : ℕ → Sort*} {n m k} (hnm : n ≤ m) (hmk : m ≤ k) {next} (x : C n) :\n    (leRecOn (Nat.le_trans hnm hmk) (@next) x : C k) =\n      leRecOn hmk (@next) (leRecOn hnm (@next) x) :=\n  leRec_trans _ _ _ _\n\n"}
{"name":"Nat.leRecOn_succ_left","module":"Mathlib.Data.Nat.Defs","initialProofState":"C : Nat → Sort u_1\nn m : Nat\nnext : {k : Nat} → C k → C (HAdd.hAdd k 1)\nx : C n\nh1 : LE.le n m\nh2 : LE.le (HAdd.hAdd n 1) m\n⊢ Eq (Nat.leRecOn h2 (fun {k} => next) (next x)) (Nat.leRecOn h1 (fun {k} => next) x)","decl":"lemma leRecOn_succ_left {C : ℕ → Sort*} {n m}\n    {next : ∀ {k}, C k → C (k + 1)} (x : C n) (h1 : n ≤ m) (h2 : n + 1 ≤ m) :\n    (leRecOn h2 next (next x) : C m) = (leRecOn h1 next x : C m) :=\n  leRec_succ_left (motive := fun n _ => C n) _ (fun _ _ => @next _) _ _\n\n"}
{"name":"Nat.leRecOn_injective","module":"Mathlib.Data.Nat.Defs","initialProofState":"C : Nat → Sort u_1\nn m : Nat\nhnm : LE.le n m\nnext : {k : Nat} → C k → C (HAdd.hAdd k 1)\nHnext : ∀ (n : Nat), Function.Injective next\n⊢ Function.Injective (Nat.leRecOn hnm fun {k} => next)","decl":"lemma leRecOn_injective {C : ℕ → Sort*} {n m} (hnm : n ≤ m) (next : ∀ {k}, C k → C (k + 1))\n    (Hnext : ∀ n, Injective (@next n)) : Injective (@leRecOn C n m hnm next) := by\n  induction hnm with\n  | refl =>\n    intro x y H\n    rwa [leRecOn_self, leRecOn_self] at H\n  | step hnm ih =>\n    intro x y H\n    rw [leRecOn_succ hnm, leRecOn_succ hnm] at H\n    exact ih (Hnext _ H)\n\n"}
{"name":"Nat.leRecOn_surjective","module":"Mathlib.Data.Nat.Defs","initialProofState":"C : Nat → Sort u_1\nn m : Nat\nhnm : LE.le n m\nnext : {k : Nat} → C k → C (HAdd.hAdd k 1)\nHnext : ∀ (n : Nat), Function.Surjective next\n⊢ Function.Surjective (Nat.leRecOn hnm fun {k} => next)","decl":"lemma leRecOn_surjective {C : ℕ → Sort*} {n m} (hnm : n ≤ m) (next : ∀ {k}, C k → C (k + 1))\n    (Hnext : ∀ n, Surjective (@next n)) : Surjective (@leRecOn C n m hnm next) := by\n  induction hnm with\n  | refl =>\n    intro x\n    refine ⟨x, ?_⟩\n    rw [leRecOn_self]\n  | step hnm ih =>\n    intro x\n    obtain ⟨w, rfl⟩ := Hnext _ x\n    obtain ⟨x, rfl⟩ := ih w\n    refine ⟨x, ?_⟩\n    rw [leRecOn_succ]\n\n"}
{"name":"Nat.strongRecOn'_beta","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\nP : Nat → Sort u_1\nh : (n : Nat) → ((m : Nat) → LT.lt m n → P m) → P n\n⊢ Eq (n.strongRecOn' h) (h n fun m x => m.strongRecOn' h)","decl":"lemma strongRecOn'_beta {P : ℕ → Sort*} {h} :\n    (strongRecOn' n h : P n) = h n fun m _ ↦ (strongRecOn' m h : P m) := by\n  simp only [strongRecOn']; rw [Nat.strongRec']\n\n"}
{"name":"Nat.le_induction","module":"Mathlib.Data.Nat.Defs","initialProofState":"m : Nat\nP : (n : Nat) → LE.le m n → Prop\nbase : P m ⋯\nsucc : ∀ (n : Nat) (hmn : LE.le m n), P n hmn → P (HAdd.hAdd n 1) ⋯\nn : Nat\nhmn : LE.le m n\n⊢ P n hmn","decl":"/-- Induction principle starting at a non-zero number.\nTo use in an induction proof, the syntax is `induction n, hn using Nat.le_induction` (or the same\nfor `induction'`).\n\nThis is an alias of `Nat.leRec`, specialized to `Prop`. -/\n@[elab_as_elim]\nlemma le_induction {m : ℕ} {P : ∀ n, m ≤ n → Prop} (base : P m m.le_refl)\n    (succ : ∀ n hmn, P n hmn → P (n + 1) (le_succ_of_le hmn)) : ∀ n hmn, P n hmn :=\n  @Nat.leRec (motive := P) _ base succ\n\n"}
{"name":"Nat.strong_induction_on","module":"Mathlib.Data.Nat.Defs","initialProofState":"p : Nat → Prop\nn : Nat\nh : ∀ (n : Nat), (∀ (m : Nat), LT.lt m n → p m) → p n\n⊢ p n","decl":"@[elab_as_elim]\nprotected theorem strong_induction_on {p : ℕ → Prop} (n : ℕ)\n    (h : ∀ n, (∀ m, m < n → p m) → p n) : p n :=\n  Nat.strongRecOn n h\n\n"}
{"name":"Nat.case_strong_induction_on","module":"Mathlib.Data.Nat.Defs","initialProofState":"p : Nat → Prop\na : Nat\nhz : p 0\nhi : ∀ (n : Nat), (∀ (m : Nat), LE.le m n → p m) → p (HAdd.hAdd n 1)\n⊢ p a","decl":"protected theorem case_strong_induction_on {p : ℕ → Prop} (a : ℕ) (hz : p 0)\n    (hi : ∀ n, (∀ m, m ≤ n → p m) → p (n + 1)) : p a :=\n  Nat.caseStrongRecOn a hz hi\n\n"}
{"name":"Nat.decreasingInduction_self","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\nmotive : (m : Nat) → LE.le m n → Sort u_1\nof_succ : (k : Nat) → (h : LT.lt k n) → motive (HAdd.hAdd k 1) h → motive k ⋯\nself : motive n ⋯\n⊢ Eq (Nat.decreasingInduction of_succ self ⋯) self","decl":"@[simp]\nlemma decreasingInduction_self {n} {motive : (m : ℕ) → m ≤ n → Sort*} (of_succ self) :\n    (decreasingInduction (motive := motive) of_succ self le_rfl) = self := by\n  dsimp only [decreasingInduction]\n  rw [leRec_self]\n\n"}
{"name":"Nat.decreasingInduction_succ","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\nmotive : (m : Nat) → LE.le m (HAdd.hAdd n 1) → Sort u_1\nof_succ : (k : Nat) → (h : LT.lt k (HAdd.hAdd n 1)) → motive (HAdd.hAdd k 1) h → motive k ⋯\nself : motive (HAdd.hAdd n 1) ⋯\nmn : LE.le m n\nmsn : LE.le m (HAdd.hAdd n 1)\n⊢ Eq (Nat.decreasingInduction of_succ self msn) (Nat.decreasingInduction (fun x x_1 => of_succ x ⋯) (of_succ n ⋯ self) mn)","decl":"lemma decreasingInduction_succ {n} {motive : (m : ℕ) → m ≤ n + 1 → Sort*} (of_succ self)\n    (mn : m ≤ n) (msn : m ≤ n + 1) :\n    (decreasingInduction (motive := motive) of_succ self msn : motive m msn) =\n      decreasingInduction (motive := fun m h => motive m (le_succ_of_le h))\n        (fun _ _ => of_succ _ _) (of_succ _ _ self) mn := by\n  dsimp only [decreasingInduction]; rw [leRec_succ]\n\n"}
{"name":"Nat.decreasingInduction_succ'","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\nmotive : (m : Nat) → LE.le m (HAdd.hAdd n 1) → Sort u_1\nof_succ : (k : Nat) → (h : LT.lt k (HAdd.hAdd n 1)) → motive (HAdd.hAdd k 1) h → motive k ⋯\nself : motive (HAdd.hAdd n 1) ⋯\n⊢ Eq (Nat.decreasingInduction of_succ self ⋯) (of_succ n ⋯ self)","decl":"@[simp]\nlemma decreasingInduction_succ' {n} {motive : (m : ℕ) → m ≤ n + 1 → Sort*} (of_succ self) :\n    decreasingInduction (motive := motive) of_succ self n.le_succ = of_succ _ _ self := by\n  dsimp only [decreasingInduction]; rw [leRec_succ']\n\n"}
{"name":"Nat.decreasingInduction_trans","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n k : Nat\nmotive : (m : Nat) → LE.le m k → Sort u_1\nhmn : LE.le m n\nhnk : LE.le n k\nof_succ : (k_1 : Nat) → (h : LT.lt k_1 k) → motive (HAdd.hAdd k_1 1) h → motive k_1 ⋯\nself : motive k ⋯\n⊢ Eq (Nat.decreasingInduction of_succ self ⋯) (Nat.decreasingInduction (fun x x_1 => of_succ x ⋯) (Nat.decreasingInduction of_succ self hnk) hmn)","decl":"lemma decreasingInduction_trans {motive : (m : ℕ) → m ≤ k → Sort*} (hmn : m ≤ n) (hnk : n ≤ k)\n    (of_succ self) :\n    (decreasingInduction (motive := motive) of_succ self (Nat.le_trans hmn hnk) : motive m _) =\n    decreasingInduction (fun _ _ => of_succ _ _) (decreasingInduction of_succ self hnk) hmn := by\n  induction hnk with\n  | refl => rw [decreasingInduction_self]\n  | step hnk ih =>\n      rw [decreasingInduction_succ _ _ (Nat.le_trans hmn hnk), ih, decreasingInduction_succ]\n\n"}
{"name":"Nat.decreasingInduction_succ_left","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\nmotive : (m : Nat) → LE.le m n → Sort u_1\nof_succ : (k : Nat) → (h : LT.lt k n) → motive (HAdd.hAdd k 1) h → motive k ⋯\nself : motive n ⋯\nsmn : LE.le (HAdd.hAdd m 1) n\nmn : LE.le m n\n⊢ Eq (Nat.decreasingInduction of_succ self mn) (of_succ m smn (Nat.decreasingInduction of_succ self smn))","decl":"lemma decreasingInduction_succ_left  {motive : (m : ℕ) → m ≤ n → Sort*} (of_succ self)\n    (smn : m + 1 ≤ n) (mn : m ≤ n) :\n    decreasingInduction (motive := motive) of_succ self mn =\n      of_succ m smn (decreasingInduction of_succ self smn) := by\n  rw [Subsingleton.elim mn (Nat.le_trans (le_succ m) smn), decreasingInduction_trans,\n    decreasingInduction_succ']\n\n"}
{"name":"Nat.diag_induction","module":"Mathlib.Data.Nat.Defs","initialProofState":"P : Nat → Nat → Prop\nha : ∀ (a : Nat), P (HAdd.hAdd a 1) (HAdd.hAdd a 1)\nhb : ∀ (b : Nat), P 0 (HAdd.hAdd b 1)\nhd : ∀ (a b : Nat), LT.lt a b → P (HAdd.hAdd a 1) b → P a (HAdd.hAdd b 1) → P (HAdd.hAdd a 1) (HAdd.hAdd b 1)\na b : Nat\na✝ : LT.lt a b\n⊢ P a b","decl":"/-- Given a predicate on two naturals `P : ℕ → ℕ → Prop`, `P a b` is true for all `a < b` if\n`P (a + 1) (a + 1)` is true for all `a`, `P 0 (b + 1)` is true for all `b` and for all\n`a < b`, `P (a + 1) b` is true and `P a (b + 1)` is true implies `P (a + 1) (b + 1)` is true. -/\n@[elab_as_elim]\ntheorem diag_induction (P : ℕ → ℕ → Prop) (ha : ∀ a, P (a + 1) (a + 1)) (hb : ∀ b, P 0 (b + 1))\n    (hd : ∀ a b, a < b → P (a + 1) b → P a (b + 1) → P (a + 1) (b + 1)) : ∀ a b, a < b → P a b\n  | 0, _ + 1, _ => hb _\n  | a + 1, b + 1, h => by\n    apply hd _ _ (Nat.add_lt_add_iff_right.1 h)\n    · have this : a + 1 = b ∨ a + 1 < b := by omega\n      have wf : (a + 1) + b < (a + 1) + (b + 1) := by simp\n      rcases this with (rfl | h)\n      · exact ha _\n      apply diag_induction P ha hb hd (a + 1) b h\n    have _ : a + (b + 1) < (a + 1) + (b + 1) := by simp\n    apply diag_induction P ha hb hd a (b + 1)\n    apply Nat.lt_of_le_of_lt (Nat.le_succ _) h\n\n"}
{"name":"Nat.set_induction_bounded","module":"Mathlib.Data.Nat.Defs","initialProofState":"n k : Nat\nS : Set Nat\nhk : Membership.mem S k\nh_ind : ∀ (k : Nat), Membership.mem S k → Membership.mem S (HAdd.hAdd k 1)\nhnk : LE.le k n\n⊢ Membership.mem S n","decl":"/-- A subset of `ℕ` containing `k : ℕ` and closed under `Nat.succ` contains every `n ≥ k`. -/\nlemma set_induction_bounded {S : Set ℕ} (hk : k ∈ S) (h_ind : ∀ k : ℕ, k ∈ S → k + 1 ∈ S)\n    (hnk : k ≤ n) : n ∈ S :=\n  @leRecOn (fun n => n ∈ S) k n hnk @h_ind hk\n\n"}
{"name":"Nat.set_induction","module":"Mathlib.Data.Nat.Defs","initialProofState":"S : Set Nat\nhb : Membership.mem S 0\nh_ind : ∀ (k : Nat), Membership.mem S k → Membership.mem S (HAdd.hAdd k 1)\nn : Nat\n⊢ Membership.mem S n","decl":"/-- A subset of `ℕ` containing zero and closed under `Nat.succ` contains all of `ℕ`. -/\nlemma set_induction {S : Set ℕ} (hb : 0 ∈ S) (h_ind : ∀ k : ℕ, k ∈ S → k + 1 ∈ S) (n : ℕ) :\n    n ∈ S :=\n  set_induction_bounded hb h_ind (zero_le n)\n\n"}
{"name":"Nat.mod_two_not_eq_one","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Iff (Not (Eq (HMod.hMod n 2) 1)) (Eq (HMod.hMod n 2) 0)","decl":"@[simp] lemma mod_two_not_eq_one : ¬n % 2 = 1 ↔ n % 2 = 0 := by\n  cases mod_two_eq_zero_or_one n <;> simp [*]\n\n"}
{"name":"Nat.mod_two_not_eq_zero","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Iff (Not (Eq (HMod.hMod n 2) 0)) (Eq (HMod.hMod n 2) 1)","decl":"@[simp] lemma mod_two_not_eq_zero : ¬n % 2 = 0 ↔ n % 2 = 1 := by\n  cases mod_two_eq_zero_or_one n <;> simp [*]\n\n"}
{"name":"Nat.mod_two_ne_one","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Iff (Ne (HMod.hMod n 2) 1) (Eq (HMod.hMod n 2) 0)","decl":"lemma mod_two_ne_one : n % 2 ≠ 1 ↔ n % 2 = 0 := mod_two_not_eq_one\n"}
{"name":"Nat.mod_two_ne_zero","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Iff (Ne (HMod.hMod n 2) 0) (Eq (HMod.hMod n 2) 1)","decl":"lemma mod_two_ne_zero : n % 2 ≠ 0 ↔ n % 2 = 1 := mod_two_not_eq_zero\n\n"}
{"name":"Nat.lt_div_iff_mul_lt'","module":"Mathlib.Data.Nat.Defs","initialProofState":"d n : Nat\nhdn : Dvd.dvd d n\na : Nat\n⊢ Iff (LT.lt a (HDiv.hDiv n d)) (LT.lt (HMul.hMul d a) n)","decl":"/-- Variant of `Nat.lt_div_iff_mul_lt` that assumes `d ∣ n`. -/\nprotected lemma lt_div_iff_mul_lt' (hdn : d ∣ n) (a : ℕ) : a < n / d ↔ d * a < n := by\n  obtain rfl | hd := d.eq_zero_or_pos\n  · simp [Nat.zero_dvd.1 hdn]\n  · rw [← Nat.mul_lt_mul_left hd, ← Nat.eq_mul_of_div_eq_right hdn rfl]\n\n"}
{"name":"Nat.mul_div_eq_iff_dvd","module":"Mathlib.Data.Nat.Defs","initialProofState":"n d : Nat\n⊢ Iff (Eq (HMul.hMul d (HDiv.hDiv n d)) n) (Dvd.dvd d n)","decl":"lemma mul_div_eq_iff_dvd {n d : ℕ} : d * (n / d) = n ↔ d ∣ n :=\n  calc\n    d * (n / d) = n ↔ d * (n / d) = d * (n / d) + (n % d) := by rw [div_add_mod]\n    _ ↔ d ∣ n := by rw [eq_comm, Nat.add_eq_left, dvd_iff_mod_eq_zero]\n\n"}
{"name":"Nat.mul_div_lt_iff_not_dvd","module":"Mathlib.Data.Nat.Defs","initialProofState":"d n : Nat\n⊢ Iff (LT.lt (HMul.hMul d (HDiv.hDiv n d)) n) (Not (Dvd.dvd d n))","decl":"lemma mul_div_lt_iff_not_dvd : d * (n / d) < n ↔ ¬ d ∣ n := by\n  simp [Nat.lt_iff_le_and_ne, mul_div_eq_iff_dvd, mul_div_le]\n\n"}
{"name":"Nat.div_eq_iff_eq_of_dvd_dvd","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b n : Nat\nhn : Ne n 0\nha : Dvd.dvd a n\nhb : Dvd.dvd b n\n⊢ Iff (Eq (HDiv.hDiv n a) (HDiv.hDiv n b)) (Eq a b)","decl":"lemma div_eq_iff_eq_of_dvd_dvd (hn : n ≠ 0) (ha : a ∣ n) (hb : b ∣ n) : n / a = n / b ↔ a = b := by\n  constructor <;> intro h\n  · rw [← Nat.mul_right_inj hn]\n    apply Nat.eq_mul_of_div_eq_left (Nat.dvd_trans hb (Nat.dvd_mul_right _ _))\n    rw [eq_comm, Nat.mul_comm, Nat.mul_div_assoc _ hb]\n    exact Nat.eq_mul_of_div_eq_right ha h\n  · rw [h]\n\n"}
{"name":"Nat.le_iff_ne_zero_of_dvd","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nha : Ne a 0\nhab : Dvd.dvd a b\n⊢ Iff (LE.le a b) (Ne b 0)","decl":"lemma le_iff_ne_zero_of_dvd (ha : a ≠ 0) (hab : a ∣ b) : a ≤ b ↔ b ≠ 0 where\n  mp := by rw [← Nat.pos_iff_ne_zero] at ha ⊢; exact Nat.lt_of_lt_of_le ha\n  mpr hb := Nat.le_of_dvd (Nat.pos_iff_ne_zero.2 hb) hab\n\n"}
{"name":"Nat.div_ne_zero_iff_of_dvd","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nhba : Dvd.dvd b a\n⊢ Iff (Ne (HDiv.hDiv a b) 0) (And (Ne a 0) (Ne b 0))","decl":"lemma div_ne_zero_iff_of_dvd (hba : b ∣ a) : a / b ≠ 0 ↔ a ≠ 0 ∧ b ≠ 0 := by\n  obtain rfl | hb := eq_or_ne b 0 <;> simp [Nat.div_ne_zero_iff, Nat.le_iff_ne_zero_of_dvd, *]\n\n"}
{"name":"Nat.mul_mod_mod","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\n⊢ Eq (HMod.hMod (HMul.hMul a (HMod.hMod b c)) c) (HMod.hMod (HMul.hMul a b) c)","decl":"@[simp] lemma mul_mod_mod (a b c : ℕ) : (a * (b % c)) % c = a * b % c := by\n  rw [mul_mod, mod_mod, ← mul_mod]\n\n"}
{"name":"Nat.pow_mod","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b n : Nat\n⊢ Eq (HMod.hMod (HPow.hPow a b) n) (HMod.hMod (HPow.hPow (HMod.hMod a n) b) n)","decl":"lemma pow_mod (a b n : ℕ) : a ^ b % n = (a % n) ^ b % n := by\n  induction b with\n  | zero => rfl\n  | succ b ih => simp [Nat.pow_succ, Nat.mul_mod, ih]\n\n"}
{"name":"Nat.not_pos_pow_dvd","module":"Mathlib.Data.Nat.Defs","initialProofState":"a n : Nat\nx✝¹ : LT.lt 1 a\nx✝ : LT.lt 1 n\n⊢ Not (Dvd.dvd (HPow.hPow a n) a)","decl":"lemma not_pos_pow_dvd : ∀ {a n : ℕ} (_ : 1 < a) (_ : 1 < n), ¬ a ^ n ∣ a\n  | succ a, succ n, hp, hk, h =>\n    have : succ a * succ a ^ n ∣ succ a * 1 := by simpa [pow_succ'] using h\n    have : succ a ^ n ∣ 1 := Nat.dvd_of_mul_dvd_mul_left (succ_pos _) this\n    have he : succ a ^ n = 1 := eq_one_of_dvd_one this\n    have : n < succ a ^ n := n.lt_pow_self hp\n    have : n < 1 := by rwa [he] at this\n    have : n = 0 := Nat.eq_zero_of_le_zero <| le_of_lt_succ this\n    have : 1 < 1 := by rwa [this] at hk\n    absurd this (by decide)\n\n"}
{"name":"Nat.lt_of_pow_dvd_right","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b n : Nat\nhb : Ne b 0\nha : LE.le 2 a\nh : Dvd.dvd (HPow.hPow a n) b\n⊢ LT.lt n b","decl":"lemma lt_of_pow_dvd_right (hb : b ≠ 0) (ha : 2 ≤ a) (h : a ^ n ∣ b) : n < b := by\n  rw [← Nat.pow_lt_pow_iff_right (succ_le_iff.1 ha)]\n  exact Nat.lt_of_le_of_lt (le_of_dvd (Nat.pos_iff_ne_zero.2 hb) h) (Nat.lt_pow_self ha)\n\n"}
{"name":"Nat.div_dvd_of_dvd","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\nh : Dvd.dvd n m\n⊢ Dvd.dvd (HDiv.hDiv m n) m","decl":"lemma div_dvd_of_dvd (h : n ∣ m) : m / n ∣ m := ⟨n, (Nat.div_mul_cancel h).symm⟩\n\n"}
{"name":"Nat.div_div_self","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\nh : Dvd.dvd n m\nhm : Ne m 0\n⊢ Eq (HDiv.hDiv m (HDiv.hDiv m n)) n","decl":"protected lemma div_div_self (h : n ∣ m) (hm : m ≠ 0) : m / (m / n) = n := by\n  rcases h with ⟨_, rfl⟩\n  rw [Nat.mul_ne_zero_iff] at hm\n  rw [mul_div_right _ (Nat.pos_of_ne_zero hm.1), mul_div_left _ (Nat.pos_of_ne_zero hm.2)]\n\n"}
{"name":"Nat.not_dvd_of_pos_of_lt","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\nh1 : LT.lt 0 n\nh2 : LT.lt n m\n⊢ Not (Dvd.dvd m n)","decl":"lemma not_dvd_of_pos_of_lt (h1 : 0 < n) (h2 : n < m) : ¬m ∣ n := by\n  rintro ⟨k, rfl⟩\n  rcases Nat.eq_zero_or_pos k with (rfl | hk)\n  · exact Nat.lt_irrefl 0 h1\n  · exact Nat.not_lt.2 (Nat.le_mul_of_pos_right _ hk) h2\n\n"}
{"name":"Nat.eq_of_dvd_of_lt_two_mul","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nha : Ne a 0\nhdvd : Dvd.dvd b a\nhlt : LT.lt a (HMul.hMul 2 b)\n⊢ Eq a b","decl":"lemma eq_of_dvd_of_lt_two_mul (ha : a ≠ 0) (hdvd : b ∣ a) (hlt : a < 2 * b) : a = b := by\n  obtain ⟨_ | _ | c, rfl⟩ := hdvd\n  · simp at ha\n  · exact Nat.mul_one _\n  · rw [Nat.mul_comm] at hlt\n    cases Nat.not_le_of_lt hlt (Nat.mul_le_mul_right _ (by omega))\n\n"}
{"name":"Nat.mod_eq_iff_lt","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\nhn : Ne n 0\n⊢ Iff (Eq (HMod.hMod m n) m) (LT.lt m n)","decl":"lemma mod_eq_iff_lt (hn : n ≠ 0) : m % n = m ↔ m < n :=\n  ⟨fun h ↦ by rw [← h]; exact mod_lt _ <| Nat.pos_iff_ne_zero.2 hn, mod_eq_of_lt⟩\n\n"}
{"name":"Nat.mod_succ_eq_iff_lt","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (Eq (HMod.hMod m n.succ) m) (LT.lt m n.succ)","decl":"@[simp]\nlemma mod_succ_eq_iff_lt : m % n.succ = m ↔ m < n.succ :=\n  mod_eq_iff_lt (succ_ne_zero _)\n\n"}
{"name":"Nat.mod_succ","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Eq (HMod.hMod n n.succ) n","decl":"@[simp] lemma mod_succ (n : ℕ) : n % n.succ = n := mod_eq_of_lt n.lt_succ_self\n\n-- Porting note `Nat.div_add_mod` is now in core.\n\n"}
{"name":"Nat.mod_add_div'","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\n⊢ Eq (HAdd.hAdd (HMod.hMod a b) (HMul.hMul (HDiv.hDiv a b) b)) a","decl":"lemma mod_add_div' (a b : ℕ) : a % b + a / b * b = a := by rw [Nat.mul_comm]; exact mod_add_div _ _\n\n"}
{"name":"Nat.div_add_mod'","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\n⊢ Eq (HAdd.hAdd (HMul.hMul (HDiv.hDiv a b) b) (HMod.hMod a b)) a","decl":"lemma div_add_mod' (a b : ℕ) : a / b * b + a % b = a := by rw [Nat.mul_comm]; exact div_add_mod _ _\n\n"}
{"name":"Nat.div_mod_unique","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c d : Nat\nh : LT.lt 0 b\n⊢ Iff (And (Eq (HDiv.hDiv a b) d) (Eq (HMod.hMod a b) c)) (And (Eq (HAdd.hAdd c (HMul.hMul b d)) a) (LT.lt c b))","decl":"/-- See also `Nat.divModEquiv` for a similar statement as an `Equiv`. -/\nprotected lemma div_mod_unique (h : 0 < b) :\n    a / b = d ∧ a % b = c ↔ c + b * d = a ∧ c < b :=\n  ⟨fun ⟨e₁, e₂⟩ ↦ e₁ ▸ e₂ ▸ ⟨mod_add_div _ _, mod_lt _ h⟩, fun ⟨h₁, h₂⟩ ↦ h₁ ▸ by\n    rw [add_mul_div_left _ _ h, add_mul_mod_self_left]; simp [div_eq_of_lt, mod_eq_of_lt, h₂]⟩\n\n"}
{"name":"Nat.sub_mod_eq_zero_of_mod_eq","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n k : Nat\nh : Eq (HMod.hMod m k) (HMod.hMod n k)\n⊢ Eq (HMod.hMod (HSub.hSub m n) k) 0","decl":"/-- If `m` and `n` are equal mod `k`, `m - n` is zero mod `k`. -/\nlemma sub_mod_eq_zero_of_mod_eq (h : m % k = n % k) : (m - n) % k = 0 := by\n  rw [← Nat.mod_add_div m k, ← Nat.mod_add_div n k, ← h, ← Nat.sub_sub,\n    Nat.add_sub_cancel_left, ← k.mul_sub, Nat.mul_mod_right]\n\n"}
{"name":"Nat.one_mod","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Eq (HMod.hMod 1 (HAdd.hAdd n 2)) 1","decl":"@[simp] lemma one_mod (n : ℕ) : 1 % (n + 2) = 1 :=\n  Nat.mod_eq_of_lt (Nat.add_lt_add_right n.succ_pos 1)\n\n"}
{"name":"Nat.one_mod_eq_one","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Iff (Eq (HMod.hMod 1 n) 1) (Ne n 1)","decl":"lemma one_mod_eq_one : ∀ {n : ℕ}, 1 % n = 1 ↔ n ≠ 1\n  | 0 | 1 | n + 2 => by simp\n\n"}
{"name":"Nat.one_mod_of_ne_one","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\na✝ : Ne n 1\n⊢ Eq (HMod.hMod 1 n) 1","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-08-28\")]\nlemma one_mod_of_ne_one  : ∀ {n : ℕ}, n ≠ 1 → 1 % n = 1 := one_mod_eq_one.mpr\n\n"}
{"name":"Nat.dvd_sub_mod","module":"Mathlib.Data.Nat.Defs","initialProofState":"n k : Nat\n⊢ Dvd.dvd n (HSub.hSub k (HMod.hMod k n))","decl":"lemma dvd_sub_mod (k : ℕ) : n ∣ k - k % n :=\n  ⟨k / n, Nat.sub_eq_of_eq_add (Nat.div_add_mod k n).symm⟩\n\n"}
{"name":"Nat.add_mod_eq_ite","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n k : Nat\n⊢ Eq (HMod.hMod (HAdd.hAdd m n) k) (ite (LE.le k (HAdd.hAdd (HMod.hMod m k) (HMod.hMod n k))) (HSub.hSub (HAdd.hAdd (HMod.hMod m k) (HMod.hMod n k)) k) (HAdd.hAdd (HMod.hMod m k) (HMod.hMod n k)))","decl":"lemma add_mod_eq_ite :\n    (m + n) % k = if k ≤ m % k + n % k then m % k + n % k - k else m % k + n % k := by\n  cases k\n  · simp\n  rw [Nat.add_mod]\n  split_ifs with h\n  · rw [Nat.mod_eq_sub_mod h, Nat.mod_eq_of_lt]\n    exact (Nat.sub_lt_iff_lt_add h).mpr (Nat.add_lt_add (m.mod_lt (zero_lt_succ _))\n      (n.mod_lt (zero_lt_succ _)))\n  · exact Nat.mod_eq_of_lt (Nat.lt_of_not_ge h)\n\n"}
{"name":"Nat.not_dvd_of_between_consec_multiples","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n k : Nat\nh1 : LT.lt (HMul.hMul n k) m\nh2 : LT.lt m (HMul.hMul n (HAdd.hAdd k 1))\n⊢ Not (Dvd.dvd n m)","decl":"/-- `m` is not divisible by `n` if it is between `n * k` and `n * (k + 1)` for some `k`. -/\ntheorem not_dvd_of_between_consec_multiples (h1 : n * k < m) (h2 : m < n * (k + 1)) : ¬n ∣ m := by\n  rintro ⟨d, rfl⟩\n  have := Nat.lt_of_mul_lt_mul_left h1\n  have := Nat.lt_of_mul_lt_mul_left h2\n  omega\n\n-- TODO: Replace `Nat.dvd_add_iff_left`\n"}
{"name":"Nat.dvd_add_left","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nh : Dvd.dvd a c\n⊢ Iff (Dvd.dvd a (HAdd.hAdd b c)) (Dvd.dvd a b)","decl":"protected lemma dvd_add_left (h : a ∣ c) : a ∣ b + c ↔ a ∣ b := (Nat.dvd_add_iff_left h).symm\n\n"}
{"name":"Nat.dvd_add_right","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nh : Dvd.dvd a b\n⊢ Iff (Dvd.dvd a (HAdd.hAdd b c)) (Dvd.dvd a c)","decl":"protected lemma dvd_add_right (h : a ∣ b) : a ∣ b + c ↔ a ∣ c := (Nat.dvd_add_iff_right h).symm\n\n"}
{"name":"Nat.mul_dvd_mul_iff_left","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nha : LT.lt 0 a\n⊢ Iff (Dvd.dvd (HMul.hMul a b) (HMul.hMul a c)) (Dvd.dvd b c)","decl":"/-- special case of `mul_dvd_mul_iff_left` for `ℕ`.\nDuplicated here to keep simple imports for this file. -/\nprotected lemma mul_dvd_mul_iff_left (ha : 0 < a) : a * b ∣ a * c ↔ b ∣ c :=\n  exists_congr fun d ↦ by rw [Nat.mul_assoc, Nat.mul_right_inj <| ne_of_gt ha]\n\n"}
{"name":"Nat.mul_dvd_mul_iff_right","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nhc : LT.lt 0 c\n⊢ Iff (Dvd.dvd (HMul.hMul a c) (HMul.hMul b c)) (Dvd.dvd a b)","decl":"/-- special case of `mul_dvd_mul_iff_right` for `ℕ`.\nDuplicated here to keep simple imports for this file. -/\nprotected lemma mul_dvd_mul_iff_right (hc : 0 < c) : a * c ∣ b * c ↔ a ∣ b :=\n  exists_congr fun d ↦ by rw [Nat.mul_right_comm, Nat.mul_left_inj <| ne_of_gt hc]\n\n-- Moved to Batteries\n\n"}
{"name":"Nat.add_mod_eq_add_mod_right","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b d c : Nat\nH : Eq (HMod.hMod a d) (HMod.hMod b d)\n⊢ Eq (HMod.hMod (HAdd.hAdd a c) d) (HMod.hMod (HAdd.hAdd b c) d)","decl":"lemma add_mod_eq_add_mod_right (c : ℕ) (H : a % d = b % d) : (a + c) % d = (b + c) % d := by\n  rw [← mod_add_mod, ← mod_add_mod b, H]\n\n"}
{"name":"Nat.add_mod_eq_add_mod_left","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b d c : Nat\nH : Eq (HMod.hMod a d) (HMod.hMod b d)\n⊢ Eq (HMod.hMod (HAdd.hAdd c a) d) (HMod.hMod (HAdd.hAdd c b) d)","decl":"lemma add_mod_eq_add_mod_left (c : ℕ) (H : a % d = b % d) : (c + a) % d = (c + b) % d := by\n  rw [Nat.add_comm, add_mod_eq_add_mod_right _ H, Nat.add_comm]\n\n-- Moved to Batteries\n\n"}
{"name":"Nat.mul_dvd_of_dvd_div","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nhcb : Dvd.dvd c b\nh : Dvd.dvd a (HDiv.hDiv b c)\n⊢ Dvd.dvd (HMul.hMul c a) b","decl":"lemma mul_dvd_of_dvd_div (hcb : c ∣ b) (h : a ∣ b / c) : c * a ∣ b :=\n  have ⟨d, hd⟩ := h\n  ⟨d, by simpa [Nat.mul_comm, Nat.mul_left_comm] using Nat.eq_mul_of_div_eq_left hcb hd⟩\n\n"}
{"name":"Nat.eq_of_dvd_of_div_eq_one","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nhab : Dvd.dvd a b\nh : Eq (HDiv.hDiv b a) 1\n⊢ Eq a b","decl":"lemma eq_of_dvd_of_div_eq_one (hab : a ∣ b) (h : b / a = 1) : a = b := by\n  rw [← Nat.div_mul_cancel hab, h, Nat.one_mul]\n\n"}
{"name":"Nat.eq_zero_of_dvd_of_div_eq_zero","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nhab : Dvd.dvd a b\nh : Eq (HDiv.hDiv b a) 0\n⊢ Eq b 0","decl":"lemma eq_zero_of_dvd_of_div_eq_zero (hab : a ∣ b) (h : b / a = 0) : b = 0 := by\n  rw [← Nat.div_mul_cancel hab, h, Nat.zero_mul]\n\n"}
{"name":"Nat.div_le_div","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c d : Nat\nh1 : LE.le a b\nh2 : LE.le d c\nh3 : Ne d 0\n⊢ LE.le (HDiv.hDiv a c) (HDiv.hDiv b d)","decl":"@[gcongr]\nprotected theorem div_le_div {a b c d : ℕ} (h1 : a ≤ b) (h2 : d ≤ c) (h3 : d ≠ 0) : a / c ≤ b / d :=\n  calc a / c ≤ b / c := Nat.div_le_div_right h1\n    _ ≤ b / d := Nat.div_le_div_left h2 (Nat.pos_of_ne_zero h3)\n\n-- Moved to Batteries\n\n"}
{"name":"Nat.lt_mul_div_succ","module":"Mathlib.Data.Nat.Defs","initialProofState":"b a : Nat\nhb : LT.lt 0 b\n⊢ LT.lt a (HMul.hMul b (HAdd.hAdd (HDiv.hDiv a b) 1))","decl":"lemma lt_mul_div_succ (a : ℕ) (hb : 0 < b) : a < b * (a / b + 1) := by\n  rw [Nat.mul_comm, ← Nat.div_lt_iff_lt_mul hb]\n  exact lt_succ_self _\n\n-- TODO: Batteries claimed this name but flipped the order of multiplication\n"}
{"name":"Nat.mul_add_mod'","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\n⊢ Eq (HMod.hMod (HAdd.hAdd (HMul.hMul a b) c) b) (HMod.hMod c b)","decl":"lemma mul_add_mod' (a b c : ℕ) : (a * b + c) % b = c % b := by rw [Nat.mul_comm, Nat.mul_add_mod]\n\n"}
{"name":"Nat.mul_add_mod_of_lt","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nh : LT.lt c b\n⊢ Eq (HMod.hMod (HAdd.hAdd (HMul.hMul a b) c) b) c","decl":"lemma mul_add_mod_of_lt (h : c < b) : (a * b + c) % b = c := by\n  rw [Nat.mul_add_mod', Nat.mod_eq_of_lt h]\n\n"}
{"name":"Nat.not_two_dvd_bit1","module":"Mathlib.Data.Nat.Defs","initialProofState":"n : Nat\n⊢ Not (Dvd.dvd 2 (HAdd.hAdd (HMul.hMul 2 n) 1))","decl":"@[simp]\nprotected theorem not_two_dvd_bit1 (n : ℕ) : ¬2 ∣ 2 * n + 1 := by\n  omega\n\n"}
{"name":"Nat.dvd_add_self_left","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (Dvd.dvd m (HAdd.hAdd m n)) (Dvd.dvd m n)","decl":"/-- A natural number `m` divides the sum `m + n` if and only if `m` divides `n`.-/\n@[simp] protected lemma dvd_add_self_left : m ∣ m + n ↔ m ∣ n := Nat.dvd_add_right (Nat.dvd_refl m)\n\n"}
{"name":"Nat.dvd_add_self_right","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (Dvd.dvd m (HAdd.hAdd n m)) (Dvd.dvd m n)","decl":"/-- A natural number `m` divides the sum `n + m` if and only if `m` divides `n`.-/\n@[simp] protected lemma dvd_add_self_right : m ∣ n + m ↔ m ∣ n := Nat.dvd_add_left (Nat.dvd_refl m)\n\n-- TODO: update `Nat.dvd_sub` in core\n"}
{"name":"Nat.dvd_sub'","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n k : Nat\nh₁ : Dvd.dvd k m\nh₂ : Dvd.dvd k n\n⊢ Dvd.dvd k (HSub.hSub m n)","decl":"lemma dvd_sub' (h₁ : k ∣ m) (h₂ : k ∣ n) : k ∣ m - n := by\n  rcases le_total n m with H | H\n  · exact dvd_sub H h₁ h₂\n  · rw [Nat.sub_eq_zero_iff_le.mpr H]\n    exact Nat.dvd_zero k\n\n"}
{"name":"Nat.succ_div","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\n⊢ Eq (HDiv.hDiv (HAdd.hAdd a 1) b) (HAdd.hAdd (HDiv.hDiv a b) (ite (Dvd.dvd b (HAdd.hAdd a 1)) 1 0))","decl":"lemma succ_div : ∀ a b : ℕ, (a + 1) / b = a / b + if b ∣ a + 1 then 1 else 0\n  | a, 0 => by simp\n  | 0, 1 => by simp\n  | 0, b + 2 => by\n    have hb2 : b + 2 > 1 := by simp\n    simp [ne_of_gt hb2, div_eq_of_lt hb2]\n  | a + 1, b + 1 => by\n    rw [Nat.div_eq]\n    conv_rhs => rw [Nat.div_eq]\n    by_cases hb_eq_a : b = a + 1\n    · simp [hb_eq_a, Nat.le_refl, Nat.not_succ_le_self, Nat.dvd_refl]\n    by_cases hb_le_a1 : b ≤ a + 1\n    · have hb_le_a : b ≤ a := le_of_lt_succ (lt_of_le_of_ne hb_le_a1 hb_eq_a)\n      have h₁ : 0 < b + 1 ∧ b + 1 ≤ a + 1 + 1 := ⟨succ_pos _, Nat.add_le_add_iff_right.2 hb_le_a1⟩\n      have h₂ : 0 < b + 1 ∧ b + 1 ≤ a + 1 := ⟨succ_pos _, Nat.add_le_add_iff_right.2 hb_le_a⟩\n      have dvd_iff : b + 1 ∣ a - b + 1 ↔ b + 1 ∣ a + 1 + 1 := by\n        rw [Nat.dvd_add_iff_left (Nat.dvd_refl (b + 1)), ← Nat.add_sub_add_right a 1 b,\n          Nat.add_comm (_ - _), Nat.add_assoc, Nat.sub_add_cancel (succ_le_succ hb_le_a),\n          Nat.add_comm 1]\n      have wf : a - b < a + 1 := lt_succ_of_le (Nat.sub_le _ _)\n      rw [if_pos h₁, if_pos h₂, Nat.add_sub_add_right, Nat.add_sub_add_right, Nat.add_comm a,\n        Nat.add_sub_assoc hb_le_a, Nat.add_comm 1,\n        have := wf\n        succ_div (a - b)]\n      simp [dvd_iff, Nat.add_comm 1, Nat.add_assoc]\n    · have hba : ¬b ≤ a := not_le_of_gt (lt_trans (lt_succ_self a) (lt_of_not_ge hb_le_a1))\n      have hb_dvd_a : ¬b + 1 ∣ a + 2 := fun h =>\n        hb_le_a1 (le_of_succ_le_succ (le_of_dvd (succ_pos _) h))\n      simp [hba, hb_le_a1, hb_dvd_a]\n\n"}
{"name":"Nat.succ_div_of_dvd","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nhba : Dvd.dvd b (HAdd.hAdd a 1)\n⊢ Eq (HDiv.hDiv (HAdd.hAdd a 1) b) (HAdd.hAdd (HDiv.hDiv a b) 1)","decl":"lemma succ_div_of_dvd (hba : b ∣ a + 1) : (a + 1) / b = a / b + 1 := by rw [succ_div, if_pos hba]\n\n"}
{"name":"Nat.succ_div_of_not_dvd","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nhba : Not (Dvd.dvd b (HAdd.hAdd a 1))\n⊢ Eq (HDiv.hDiv (HAdd.hAdd a 1) b) (HDiv.hDiv a b)","decl":"lemma succ_div_of_not_dvd (hba : ¬b ∣ a + 1) : (a + 1) / b = a / b := by\n  rw [succ_div, if_neg hba, Nat.add_zero]\n\n"}
{"name":"Nat.dvd_iff_div_mul_eq","module":"Mathlib.Data.Nat.Defs","initialProofState":"n d : Nat\n⊢ Iff (Dvd.dvd d n) (Eq (HMul.hMul (HDiv.hDiv n d) d) n)","decl":"lemma dvd_iff_div_mul_eq (n d : ℕ) : d ∣ n ↔ n / d * d = n :=\n  ⟨fun h => Nat.div_mul_cancel h, fun h => by rw [← h]; exact Nat.dvd_mul_left _ _⟩\n\n"}
{"name":"Nat.dvd_iff_le_div_mul","module":"Mathlib.Data.Nat.Defs","initialProofState":"n d : Nat\n⊢ Iff (Dvd.dvd d n) (LE.le n (HMul.hMul (HDiv.hDiv n d) d))","decl":"lemma dvd_iff_le_div_mul (n d : ℕ) : d ∣ n ↔ n ≤ n / d * d :=\n  ((dvd_iff_div_mul_eq _ _).trans le_antisymm_iff).trans (and_iff_right (div_mul_le_self n d))\n\n"}
{"name":"Nat.dvd_iff_dvd_dvd","module":"Mathlib.Data.Nat.Defs","initialProofState":"n d : Nat\n⊢ Iff (Dvd.dvd d n) (∀ (k : Nat), Dvd.dvd k d → Dvd.dvd k n)","decl":"lemma dvd_iff_dvd_dvd (n d : ℕ) : d ∣ n ↔ ∀ k : ℕ, k ∣ d → k ∣ n :=\n  ⟨fun h _ hkd => Nat.dvd_trans hkd h, fun h => h _ (Nat.dvd_refl _)⟩\n\n"}
{"name":"Nat.dvd_div_of_mul_dvd","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nh : Dvd.dvd (HMul.hMul a b) c\n⊢ Dvd.dvd b (HDiv.hDiv c a)","decl":"lemma dvd_div_of_mul_dvd (h : a * b ∣ c) : b ∣ c / a :=\n  if ha : a = 0 then by simp [ha]\n  else\n    have ha : 0 < a := Nat.pos_of_ne_zero ha\n    have h1 : ∃ d, c = a * b * d := h\n    let ⟨d, hd⟩ := h1\n    have h2 : c / a = b * d := Nat.div_eq_of_eq_mul_right ha (by simpa [Nat.mul_assoc] using hd)\n    show ∃ d, c / a = b * d from ⟨d, h2⟩\n\n"}
{"name":"Nat.dvd_div_iff_mul_dvd","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nhbc : Dvd.dvd c b\n⊢ Iff (Dvd.dvd a (HDiv.hDiv b c)) (Dvd.dvd (HMul.hMul c a) b)","decl":"@[simp] lemma dvd_div_iff_mul_dvd (hbc : c ∣ b) : a ∣ b / c ↔ c * a ∣ b :=\n  ⟨fun h => mul_dvd_of_dvd_div hbc h, fun h => dvd_div_of_mul_dvd h⟩\n\n"}
{"name":"Nat.dvd_mul_of_div_dvd","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nh : Dvd.dvd b a\nhdiv : Dvd.dvd (HDiv.hDiv a b) c\n⊢ Dvd.dvd a (HMul.hMul b c)","decl":"lemma dvd_mul_of_div_dvd (h : b ∣ a) (hdiv : a / b ∣ c) : a ∣ b * c := by\n  obtain ⟨e, rfl⟩ := hdiv\n  rw [← Nat.mul_assoc, Nat.mul_comm _ (a / b), Nat.div_mul_cancel h]\n  exact Nat.dvd_mul_right a e\n\n"}
{"name":"Nat.div_dvd_iff_dvd_mul","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\nh : Dvd.dvd b a\nhb : Ne b 0\n⊢ Iff (Dvd.dvd (HDiv.hDiv a b) c) (Dvd.dvd a (HMul.hMul b c))","decl":"@[simp] lemma div_dvd_iff_dvd_mul (h : b ∣ a) (hb : b ≠ 0) : a / b ∣ c ↔ a ∣ b * c :=\n  exists_congr <| fun d => by\n  have := Nat.dvd_trans (Nat.dvd_mul_left _ d) (Nat.mul_dvd_mul_left d h)\n  rw [eq_comm, Nat.mul_comm, ← Nat.mul_div_assoc d h,\n    Nat.div_eq_iff_eq_mul_right (Nat.pos_of_ne_zero hb) this, Nat.mul_comm, eq_comm]\n\n"}
{"name":"Nat.div_div_div_eq_div","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b c : Nat\ndvd : Dvd.dvd b a\ndvd2 : Dvd.dvd a c\n⊢ Eq (HDiv.hDiv (HDiv.hDiv c (HDiv.hDiv a b)) b) (HDiv.hDiv c a)","decl":"@[simp] lemma div_div_div_eq_div (dvd : b ∣ a) (dvd2 : a ∣ c) : c / (a / b) / b = c / a :=\n  match a, b, c with\n  | 0, _, _ => by simp\n  | a + 1, 0, _ => by simp at dvd\n  | a + 1, c + 1, _ => by\n    have a_split : a + 1 ≠ 0 := succ_ne_zero a\n    have c_split : c + 1 ≠ 0 := succ_ne_zero c\n    rcases dvd2 with ⟨k, rfl⟩\n    rcases dvd with ⟨k2, pr⟩\n    have k2_nonzero : k2 ≠ 0 := fun k2_zero => by simp [k2_zero] at pr\n    rw [Nat.mul_div_cancel_left k (Nat.pos_of_ne_zero a_split), pr,\n      Nat.mul_div_cancel_left k2 (Nat.pos_of_ne_zero c_split), Nat.mul_comm ((c + 1) * k2) k, ←\n      Nat.mul_assoc k (c + 1) k2, Nat.mul_div_cancel _ (Nat.pos_of_ne_zero k2_nonzero),\n      Nat.mul_div_cancel _ (Nat.pos_of_ne_zero c_split)]\n\n"}
{"name":"Nat.eq_zero_of_dvd_of_lt","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b : Nat\nw : Dvd.dvd a b\nh : LT.lt b a\n⊢ Eq b 0","decl":"/-- If a small natural number is divisible by a larger natural number,\nthe small number is zero. -/\nlemma eq_zero_of_dvd_of_lt (w : a ∣ b) (h : b < a) : b = 0 :=\n  Nat.eq_zero_of_dvd_of_div_eq_zero w (by simp [h])\n\n"}
{"name":"Nat.le_of_lt_add_of_dvd","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b n : Nat\nh : LT.lt a (HAdd.hAdd b n)\na✝¹ : Dvd.dvd n a\na✝ : Dvd.dvd n b\n⊢ LE.le a b","decl":"lemma le_of_lt_add_of_dvd (h : a < b + n) : n ∣ a → n ∣ b → a ≤ b := by\n  rintro ⟨a, rfl⟩ ⟨b, rfl⟩\n  rw [← mul_succ] at h\n  exact Nat.mul_le_mul_left _ (Nat.lt_succ_iff.1 <| Nat.lt_of_mul_lt_mul_left h)\n\n"}
{"name":"Nat.not_dvd_iff_between_consec_multiples","module":"Mathlib.Data.Nat.Defs","initialProofState":"n a : Nat\nha : LT.lt 0 a\n⊢ Iff (Exists fun k => And (LT.lt (HMul.hMul a k) n) (LT.lt n (HMul.hMul a (HAdd.hAdd k 1)))) (Not (Dvd.dvd a n))","decl":"/-- `n` is not divisible by `a` iff it is between `a * k` and `a * (k + 1)` for some `k`. -/\nlemma not_dvd_iff_between_consec_multiples (n : ℕ) {a : ℕ} (ha : 0 < a) :\n    (∃ k : ℕ, a * k < n ∧ n < a * (k + 1)) ↔ ¬a ∣ n := by\n  refine\n    ⟨fun ⟨k, hk1, hk2⟩ => not_dvd_of_between_consec_multiples hk1 hk2, fun han =>\n      ⟨n / a, ⟨lt_of_le_of_ne (mul_div_le n a) ?_, lt_mul_div_succ _ ha⟩⟩⟩\n  exact mt (⟨n / a, Eq.symm ·⟩) han\n\n"}
{"name":"Nat.dvd_right_iff_eq","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (∀ (a : Nat), Iff (Dvd.dvd m a) (Dvd.dvd n a)) (Eq m n)","decl":"/-- Two natural numbers are equal if and only if they have the same multiples. -/\nlemma dvd_right_iff_eq : (∀ a : ℕ, m ∣ a ↔ n ∣ a) ↔ m = n :=\n  ⟨fun h => Nat.dvd_antisymm ((h _).mpr (Nat.dvd_refl _)) ((h _).mp (Nat.dvd_refl _)),\n    fun h n => by rw [h]⟩\n\n"}
{"name":"Nat.dvd_left_iff_eq","module":"Mathlib.Data.Nat.Defs","initialProofState":"m n : Nat\n⊢ Iff (∀ (a : Nat), Iff (Dvd.dvd a m) (Dvd.dvd a n)) (Eq m n)","decl":"/-- Two natural numbers are equal if and only if they have the same divisors. -/\nlemma dvd_left_iff_eq : (∀ a : ℕ, a ∣ m ↔ a ∣ n) ↔ m = n :=\n  ⟨fun h => Nat.dvd_antisymm ((h _).mp (Nat.dvd_refl _)) ((h _).mpr (Nat.dvd_refl _)),\n    fun h n => by rw [h]⟩\n\n"}
{"name":"Nat.dvd_left_injective","module":"Mathlib.Data.Nat.Defs","initialProofState":"⊢ Function.Injective fun x1 x2 => Dvd.dvd x1 x2","decl":"/-- `dvd` is injective in the left argument -/\nlemma dvd_left_injective : Function.Injective ((· ∣ ·) : ℕ → ℕ → Prop) := fun _ _ h =>\n  dvd_right_iff_eq.mp fun a => iff_of_eq (congr_fun h a)\n\n"}
{"name":"Nat.div_lt_div_of_lt_of_dvd","module":"Mathlib.Data.Nat.Defs","initialProofState":"a b d : Nat\nhdb : Dvd.dvd d b\nh : LT.lt a b\n⊢ LT.lt (HDiv.hDiv a d) (HDiv.hDiv b d)","decl":"lemma div_lt_div_of_lt_of_dvd {a b d : ℕ} (hdb : d ∣ b) (h : a < b) : a / d < b / d := by\n  rw [Nat.lt_div_iff_mul_lt' hdb]\n  exact lt_of_le_of_lt (mul_div_le a d) h\n\n"}
