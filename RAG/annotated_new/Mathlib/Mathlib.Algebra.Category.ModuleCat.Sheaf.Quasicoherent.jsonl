{"name":"SheafOfModules.Presentation.mk.injEq","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Quasicoherent","initialProofState":"C : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninst✝² : CategoryTheory.HasWeakSheafify J AddCommGrp\ninst✝¹ : J.WEqualsLocallyBijective AddCommGrp\ninst✝ : J.HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\ngenerators✝ : M.GeneratingSections\nrelations✝ : (CategoryTheory.Limits.kernel generators✝.π).GeneratingSections\ngenerators : M.GeneratingSections\nrelations : (CategoryTheory.Limits.kernel generators.π).GeneratingSections\n⊢ Eq (Eq { generators := generators✝, relations := relations✝ } { generators := generators, relations := relations }) (And (Eq generators✝ generators) (HEq relations✝ relations))","decl":"/-- A global presentation of a sheaf of modules `M` consists of a family `generators.s`\nof sections `s` which generate `M`, and a family of sections which generate\nthe kernel of the morphism `generators.π : free (generators.I) ⟶ M`. -/\nstructure Presentation where\n  /-- generators -/\n  generators : M.GeneratingSections\n  /-- relations -/\n  relations : (kernel generators.π).GeneratingSections\n\n"}
{"name":"SheafOfModules.Presentation.mk.inj","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Quasicoherent","initialProofState":"C : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninst✝² : CategoryTheory.HasWeakSheafify J AddCommGrp\ninst✝¹ : J.WEqualsLocallyBijective AddCommGrp\ninst✝ : J.HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\ngenerators✝ : M.GeneratingSections\nrelations✝ : (CategoryTheory.Limits.kernel generators✝.π).GeneratingSections\ngenerators : M.GeneratingSections\nrelations : (CategoryTheory.Limits.kernel generators.π).GeneratingSections\nx✝ : Eq { generators := generators✝, relations := relations✝ } { generators := generators, relations := relations }\n⊢ And (Eq generators✝ generators) (HEq relations✝ relations)","decl":"/-- A global presentation of a sheaf of modules `M` consists of a family `generators.s`\nof sections `s` which generate `M`, and a family of sections which generate\nthe kernel of the morphism `generators.π : free (generators.I) ⟶ M`. -/\nstructure Presentation where\n  /-- generators -/\n  generators : M.GeneratingSections\n  /-- relations -/\n  relations : (kernel generators.π).GeneratingSections\n\n"}
{"name":"SheafOfModules.Presentation.mk.sizeOf_spec","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Quasicoherent","initialProofState":"C : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninst✝³ : CategoryTheory.HasWeakSheafify J AddCommGrp\ninst✝² : J.WEqualsLocallyBijective AddCommGrp\ninst✝¹ : J.HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\ninst✝ : SizeOf C\ngenerators : M.GeneratingSections\nrelations : (CategoryTheory.Limits.kernel generators.π).GeneratingSections\n⊢ Eq (SizeOf.sizeOf { generators := generators, relations := relations }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf generators)) (SizeOf.sizeOf relations))","decl":"/-- A global presentation of a sheaf of modules `M` consists of a family `generators.s`\nof sections `s` which generate `M`, and a family of sections which generate\nthe kernel of the morphism `generators.π : free (generators.I) ⟶ M`. -/\nstructure Presentation where\n  /-- generators -/\n  generators : M.GeneratingSections\n  /-- relations -/\n  relations : (kernel generators.π).GeneratingSections\n\n"}
{"name":"SheafOfModules.QuasicoherentData.mk.sizeOf_spec","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Quasicoherent","initialProofState":"C : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninst✝³ : ∀ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\ninst✝² : ∀ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninst✝¹ : ∀ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\ninst✝ : SizeOf C\nI : Type u'\nX : I → C\ncoversTop : J.CoversTop X\npresentation : (i : I) → (M.over (X i)).Presentation\n⊢ Eq (SizeOf.sizeOf { I := I, X := X, coversTop := coversTop, presentation := presentation }) (HAdd.hAdd 1 (SizeOf.sizeOf I))","decl":"/-- This structure contains the data of a family of objects `X i` which cover\nthe terminal object, and of a presentation of `M.over (X i)` for all `i`. -/\nstructure QuasicoherentData where\n  /-- the index type of the covering -/\n  I : Type u'\n  /-- a family of objects which cover the terminal object -/\n  X : I → C\n  coversTop : J.CoversTop X\n  /-- a presentation of the sheaf of modules `M.over (X i)` for any `i : I` -/\n  presentation (i : I) : (M.over (X i)).Presentation\n\n"}
{"name":"SheafOfModules.QuasicoherentData.mk.injEq","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Quasicoherent","initialProofState":"C : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninst✝² : ∀ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\ninst✝¹ : ∀ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninst✝ : ∀ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\nI✝ : Type u'\nX✝ : I✝ → C\ncoversTop✝ : J.CoversTop X✝\npresentation✝ : (i : I✝) → (M.over (X✝ i)).Presentation\nI : Type u'\nX : I → C\ncoversTop : J.CoversTop X\npresentation : (i : I) → (M.over (X i)).Presentation\n⊢ Eq (Eq { I := I✝, X := X✝, coversTop := coversTop✝, presentation := presentation✝ } { I := I, X := X, coversTop := coversTop, presentation := presentation }) (And (Eq I✝ I) (And (HEq X✝ X) (HEq presentation✝ presentation)))","decl":"/-- This structure contains the data of a family of objects `X i` which cover\nthe terminal object, and of a presentation of `M.over (X i)` for all `i`. -/\nstructure QuasicoherentData where\n  /-- the index type of the covering -/\n  I : Type u'\n  /-- a family of objects which cover the terminal object -/\n  X : I → C\n  coversTop : J.CoversTop X\n  /-- a presentation of the sheaf of modules `M.over (X i)` for any `i : I` -/\n  presentation (i : I) : (M.over (X i)).Presentation\n\n"}
{"name":"SheafOfModules.QuasicoherentData.mk.inj","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Quasicoherent","initialProofState":"C : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninst✝² : ∀ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\ninst✝¹ : ∀ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninst✝ : ∀ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\nI✝ : Type u'\nX✝ : I✝ → C\ncoversTop✝ : J.CoversTop X✝\npresentation✝ : (i : I✝) → (M.over (X✝ i)).Presentation\nI : Type u'\nX : I → C\ncoversTop : J.CoversTop X\npresentation : (i : I) → (M.over (X i)).Presentation\nx✝ : Eq { I := I✝, X := X✝, coversTop := coversTop✝, presentation := presentation✝ } { I := I, X := X, coversTop := coversTop, presentation := presentation }\n⊢ And (Eq I✝ I) (And (HEq X✝ X) (HEq presentation✝ presentation))","decl":"/-- This structure contains the data of a family of objects `X i` which cover\nthe terminal object, and of a presentation of `M.over (X i)` for all `i`. -/\nstructure QuasicoherentData where\n  /-- the index type of the covering -/\n  I : Type u'\n  /-- a family of objects which cover the terminal object -/\n  X : I → C\n  coversTop : J.CoversTop X\n  /-- a presentation of the sheaf of modules `M.over (X i)` for any `i : I` -/\n  presentation (i : I) : (M.over (X i)).Presentation\n\n"}
{"name":"SheafOfModules.QuasicoherentData.coversTop","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Quasicoherent","initialProofState":"C : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninst✝² : ∀ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\ninst✝¹ : ∀ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninst✝ : ∀ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\nself : M.QuasicoherentData\n⊢ J.CoversTop self.X","decl":"/-- This structure contains the data of a family of objects `X i` which cover\nthe terminal object, and of a presentation of `M.over (X i)` for all `i`. -/\nstructure QuasicoherentData where\n  /-- the index type of the covering -/\n  I : Type u'\n  /-- a family of objects which cover the terminal object -/\n  X : I → C\n  coversTop : J.CoversTop X\n  /-- a presentation of the sheaf of modules `M.over (X i)` for any `i : I` -/\n  presentation (i : I) : (M.over (X i)).Presentation\n\n"}
{"name":"SheafOfModules.QuasicoherentData.localGeneratorsData_I","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Quasicoherent","initialProofState":"C : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninst✝² : ∀ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\ninst✝¹ : ∀ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninst✝ : ∀ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\nq : M.QuasicoherentData\n⊢ Eq q.localGeneratorsData.I q.I","decl":"/-- If `M` is quasicoherent, it is locally generated by sections. -/\n@[simps]\ndef localGeneratorsData (q : M.QuasicoherentData) : M.LocalGeneratorsData where\n  I := q.I\n  X := q.X\n  coversTop := q.coversTop\n  generators i := (q.presentation i).generators\n\n"}
{"name":"SheafOfModules.QuasicoherentData.localGeneratorsData_generators","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Quasicoherent","initialProofState":"C : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninst✝² : ∀ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\ninst✝¹ : ∀ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninst✝ : ∀ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\nq : M.QuasicoherentData\ni : q.I\n⊢ Eq (q.localGeneratorsData.generators i) (q.presentation i).generators","decl":"/-- If `M` is quasicoherent, it is locally generated by sections. -/\n@[simps]\ndef localGeneratorsData (q : M.QuasicoherentData) : M.LocalGeneratorsData where\n  I := q.I\n  X := q.X\n  coversTop := q.coversTop\n  generators i := (q.presentation i).generators\n\n"}
{"name":"SheafOfModules.QuasicoherentData.localGeneratorsData_X","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Quasicoherent","initialProofState":"C : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninst✝² : ∀ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\ninst✝¹ : ∀ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninst✝ : ∀ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\nq : M.QuasicoherentData\na✝ : q.I\n⊢ Eq (q.localGeneratorsData.X a✝) (q.X a✝)","decl":"/-- If `M` is quasicoherent, it is locally generated by sections. -/\n@[simps]\ndef localGeneratorsData (q : M.QuasicoherentData) : M.LocalGeneratorsData where\n  I := q.I\n  X := q.X\n  coversTop := q.coversTop\n  generators i := (q.presentation i).generators\n\n"}
{"name":"SheafOfModules.IsQuasicoherent.nonempty_quasicoherentData","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Quasicoherent","initialProofState":"C : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninst✝² : ∀ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\ninst✝¹ : ∀ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninst✝ : ∀ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\nself : M.IsQuasicoherent\n⊢ Nonempty M.QuasicoherentData","decl":"/-- A sheaf of modules is quasi-coherent if it is locally the cokernel of a\nmorphism between coproducts of copies of the sheaf of rings. -/\nclass IsQuasicoherent : Prop where\n  nonempty_quasicoherentData : Nonempty M.QuasicoherentData\n\n"}
{"name":"SheafOfModules.IsFinitePresentation.exists_quasicoherentData","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Quasicoherent","initialProofState":"C : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninst✝² : ∀ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\ninst✝¹ : ∀ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninst✝ : ∀ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\nself : M.IsFinitePresentation\n⊢ Exists fun σ => ∀ (i : σ.I), And (Finite (σ.presentation i).generators.I) (Finite (σ.presentation i).relations.I)","decl":"/-- A sheaf of modules is finitely presented if it is locally the cokernel of a\nmorphism between coproducts of finitely many copies of the sheaf of rings.. -/\nclass IsFinitePresentation : Prop where\n  exists_quasicoherentData :\n    ∃ (σ : M.QuasicoherentData), ∀ (i : σ.I), (Finite (σ.presentation i).generators.I ∧\n      Finite (σ.presentation i).relations.I)\n\n"}
{"name":"SheafOfModules.instFiniteIOverXQuasicoherentDataOfIsFinitePresentationGeneratorsPresentation","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Quasicoherent","initialProofState":"C : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninst✝² : ∀ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\ninst✝¹ : ∀ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninst✝ : ∀ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\nh : M.IsFinitePresentation\ni : M.quasicoherentDataOfIsFinitePresentation.I\n⊢ Finite (M.quasicoherentDataOfIsFinitePresentation.presentation i).generators.I","decl":"instance (i : M.quasicoherentDataOfIsFinitePresentation.I) :\n    Finite (M.quasicoherentDataOfIsFinitePresentation.presentation i).generators.I :=\n  have : _ ∧ Finite (M.quasicoherentDataOfIsFinitePresentation.presentation i).relations.I :=\n    h.exists_quasicoherentData.choose_spec i\n  this.1\n\n"}
{"name":"SheafOfModules.instFiniteIOverXQuasicoherentDataOfIsFinitePresentationRelationsPresentation","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Quasicoherent","initialProofState":"C : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninst✝² : ∀ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\ninst✝¹ : ∀ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninst✝ : ∀ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\nh : M.IsFinitePresentation\ni : M.quasicoherentDataOfIsFinitePresentation.I\n⊢ Finite (M.quasicoherentDataOfIsFinitePresentation.presentation i).relations.I","decl":"instance (i : M.quasicoherentDataOfIsFinitePresentation.I) :\n    Finite (M.quasicoherentDataOfIsFinitePresentation.presentation i).relations.I :=\n  have : _ ∧ Finite (M.quasicoherentDataOfIsFinitePresentation.presentation i).relations.I :=\n    h.exists_quasicoherentData.choose_spec i\n  this.2\n\n"}
{"name":"SheafOfModules.instIsFiniteTypeOfIsFinitePresentation","module":"Mathlib.Algebra.Category.ModuleCat.Sheaf.Quasicoherent","initialProofState":"C : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\nM : SheafOfModules R\ninst✝³ : ∀ (X : C), (J.over X).HasSheafCompose (CategoryTheory.forget₂ RingCat AddCommGrp)\ninst✝² : ∀ (X : C), CategoryTheory.HasWeakSheafify (J.over X) AddCommGrp\ninst✝¹ : ∀ (X : C), (J.over X).WEqualsLocallyBijective AddCommGrp\ninst✝ : M.IsFinitePresentation\n⊢ M.IsFiniteType","decl":"instance [M.IsFinitePresentation] : M.IsFiniteType where\n  exists_localGeneratorsData :=\n    ⟨M.quasicoherentDataOfIsFinitePresentation.localGeneratorsData,\n      by intro; dsimp; infer_instance⟩\n\n"}
