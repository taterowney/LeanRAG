{"name":"CliffordAlgebra.EquivEven.Q'_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nm : Prod M R\n⊢ Eq ((CliffordAlgebra.EquivEven.Q' Q) m) (HSub.hSub (Q m.1) (HMul.hMul m.2 m.2))","decl":"theorem Q'_apply (m : M × R) : Q' Q m = Q m.1 - m.2 * m.2 :=\n  (sub_eq_add_neg _ _).symm\n\n"}
{"name":"CliffordAlgebra.EquivEven.ι_eq_v_add_smul_e0","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nm : M\nr : R\n⊢ Eq ((CliffordAlgebra.ι (CliffordAlgebra.EquivEven.Q' Q)) { fst := m, snd := r }) (HAdd.hAdd ((CliffordAlgebra.EquivEven.v Q) m) (HSMul.hSMul r (CliffordAlgebra.EquivEven.e0 Q)))","decl":"theorem ι_eq_v_add_smul_e0 (m : M) (r : R) : ι (Q' Q) (m, r) = v Q m + r • e0 Q := by\n  rw [e0, v, LinearMap.comp_apply, LinearMap.inl_apply, ← LinearMap.map_smul, Prod.smul_mk,\n    smul_zero, smul_eq_mul, mul_one, ← LinearMap.map_add, Prod.mk_add_mk, zero_add, add_zero]\n\n"}
{"name":"CliffordAlgebra.EquivEven.e0_mul_e0","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Eq (HMul.hMul (CliffordAlgebra.EquivEven.e0 Q) (CliffordAlgebra.EquivEven.e0 Q)) (-1)","decl":"theorem e0_mul_e0 : e0 Q * e0 Q = -1 :=\n  (ι_sq_scalar _ _).trans <| by simp\n\n"}
{"name":"CliffordAlgebra.EquivEven.v_sq_scalar","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nm : M\n⊢ Eq (HMul.hMul ((CliffordAlgebra.EquivEven.v Q) m) ((CliffordAlgebra.EquivEven.v Q) m)) ((algebraMap R (CliffordAlgebra (CliffordAlgebra.EquivEven.Q' Q))) (Q m))","decl":"theorem v_sq_scalar (m : M) : v Q m * v Q m = algebraMap _ _ (Q m) :=\n  (ι_sq_scalar _ _).trans <| by simp\n\n"}
{"name":"CliffordAlgebra.EquivEven.neg_e0_mul_v","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nm : M\n⊢ Eq (Neg.neg (HMul.hMul (CliffordAlgebra.EquivEven.e0 Q) ((CliffordAlgebra.EquivEven.v Q) m))) (HMul.hMul ((CliffordAlgebra.EquivEven.v Q) m) (CliffordAlgebra.EquivEven.e0 Q))","decl":"theorem neg_e0_mul_v (m : M) : -(e0 Q * v Q m) = v Q m * e0 Q := by\n  refine neg_eq_of_add_eq_zero_right ((ι_mul_ι_add_swap _ _).trans ?_)\n  dsimp [QuadraticMap.polar]\n  simp only [add_zero, mul_zero, mul_one, zero_add, neg_zero, QuadraticMap.map_zero,\n    add_sub_cancel_right, sub_self, map_zero, zero_sub]\n\n"}
{"name":"CliffordAlgebra.EquivEven.neg_v_mul_e0","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nm : M\n⊢ Eq (Neg.neg (HMul.hMul ((CliffordAlgebra.EquivEven.v Q) m) (CliffordAlgebra.EquivEven.e0 Q))) (HMul.hMul (CliffordAlgebra.EquivEven.e0 Q) ((CliffordAlgebra.EquivEven.v Q) m))","decl":"theorem neg_v_mul_e0 (m : M) : -(v Q m * e0 Q) = e0 Q * v Q m := by\n  rw [neg_eq_iff_eq_neg]\n  exact (neg_e0_mul_v _ m).symm\n\n"}
{"name":"CliffordAlgebra.EquivEven.e0_mul_v_mul_e0","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nm : M\n⊢ Eq (HMul.hMul (HMul.hMul (CliffordAlgebra.EquivEven.e0 Q) ((CliffordAlgebra.EquivEven.v Q) m)) (CliffordAlgebra.EquivEven.e0 Q)) ((CliffordAlgebra.EquivEven.v Q) m)","decl":"@[simp]\ntheorem e0_mul_v_mul_e0 (m : M) : e0 Q * v Q m * e0 Q = v Q m := by\n  rw [← neg_v_mul_e0, ← neg_mul, mul_assoc, e0_mul_e0, mul_neg_one, neg_neg]\n\n"}
{"name":"CliffordAlgebra.EquivEven.reverse_v","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nm : M\n⊢ Eq (CliffordAlgebra.reverse ((CliffordAlgebra.EquivEven.v Q) m)) ((CliffordAlgebra.EquivEven.v Q) m)","decl":"@[simp]\ntheorem reverse_v (m : M) : reverse (Q := Q' Q) (v Q m) = v Q m :=\n  reverse_ι _\n\n"}
{"name":"CliffordAlgebra.EquivEven.involute_v","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nm : M\n⊢ Eq (CliffordAlgebra.involute ((CliffordAlgebra.EquivEven.v Q) m)) (Neg.neg ((CliffordAlgebra.EquivEven.v Q) m))","decl":"@[simp]\ntheorem involute_v (m : M) : involute (v Q m) = -v Q m :=\n  involute_ι _\n\n"}
{"name":"CliffordAlgebra.EquivEven.reverse_e0","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Eq (CliffordAlgebra.reverse (CliffordAlgebra.EquivEven.e0 Q)) (CliffordAlgebra.EquivEven.e0 Q)","decl":"@[simp]\ntheorem reverse_e0 : reverse (Q := Q' Q) (e0 Q) = e0 Q :=\n  reverse_ι _\n\n"}
{"name":"CliffordAlgebra.EquivEven.involute_e0","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Eq (CliffordAlgebra.involute (CliffordAlgebra.EquivEven.e0 Q)) (Neg.neg (CliffordAlgebra.EquivEven.e0 Q))","decl":"@[simp]\ntheorem involute_e0 : involute (e0 Q) = -e0 Q :=\n  involute_ι _\n\n"}
{"name":"CliffordAlgebra.toEven_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nm : M\n⊢ Eq (↑((CliffordAlgebra.toEven Q) ((CliffordAlgebra.ι Q) m))) (HMul.hMul (CliffordAlgebra.EquivEven.e0 Q) ((CliffordAlgebra.EquivEven.v Q) m))","decl":"theorem toEven_ι (m : M) : (toEven Q (ι Q m) : CliffordAlgebra (Q' Q)) = e0 Q * v Q m := by\n  rw [toEven, CliffordAlgebra.lift_ι_apply]\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11224): was `rw`\n  erw [LinearMap.codRestrict_apply]\n  rw [LinearMap.coe_comp, Function.comp_apply, LinearMap.mulLeft_apply]\n\n"}
{"name":"CliffordAlgebra.ofEven_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx y : Prod M R\n⊢ Eq ((CliffordAlgebra.ofEven Q) (((CliffordAlgebra.even.ι (CliffordAlgebra.EquivEven.Q' Q)).bilin x) y)) (HMul.hMul (HAdd.hAdd ((CliffordAlgebra.ι Q) x.1) ((algebraMap R (CliffordAlgebra Q)) x.2)) (HSub.hSub ((CliffordAlgebra.ι Q) y.1) ((algebraMap R (CliffordAlgebra Q)) y.2)))","decl":"theorem ofEven_ι (x y : M × R) :\n    ofEven Q ((even.ι (Q' Q)).bilin x y) =\n      (ι Q x.1 + algebraMap R _ x.2) * (ι Q y.1 - algebraMap R _ y.2) :=\n  even.lift_ι (Q' Q) _ x y\n\n"}
{"name":"CliffordAlgebra.toEven_comp_ofEven","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Eq ((CliffordAlgebra.toEven Q).comp (CliffordAlgebra.ofEven Q)) (AlgHom.id R (Subtype fun x => Membership.mem (CliffordAlgebra.even (CliffordAlgebra.EquivEven.Q' Q)) x))","decl":"theorem toEven_comp_ofEven : (toEven Q).comp (ofEven Q) = AlgHom.id R _ :=\n  even.algHom_ext (Q' Q) <|\n    EvenHom.ext <|\n      LinearMap.ext fun m₁ =>\n        LinearMap.ext fun m₂ =>\n          Subtype.ext <|\n            let ⟨m₁, r₁⟩ := m₁\n            let ⟨m₂, r₂⟩ := m₂\n            calc\n              ↑(toEven Q (ofEven Q ((even.ι (Q' Q)).bilin (m₁, r₁) (m₂, r₂)))) =\n                  (e0 Q * v Q m₁ + algebraMap R _ r₁) * (e0 Q * v Q m₂ - algebraMap R _ r₂) := by\n                rw [ofEven_ι, map_mul, map_add, map_sub, AlgHom.commutes,\n                  AlgHom.commutes, Subalgebra.coe_mul, Subalgebra.coe_add, Subalgebra.coe_sub,\n                  toEven_ι, toEven_ι, Subalgebra.coe_algebraMap, Subalgebra.coe_algebraMap]\n              _ =\n                  e0 Q * v Q m₁ * (e0 Q * v Q m₂) + r₁ • e0 Q * v Q m₂ - r₂ • e0 Q * v Q m₁ -\n                    algebraMap R _ (r₁ * r₂) := by\n                rw [mul_sub, add_mul, add_mul, ← Algebra.commutes, ← Algebra.smul_def, ← map_mul, ←\n                  Algebra.smul_def, sub_add_eq_sub_sub, smul_mul_assoc, smul_mul_assoc]\n              _ =\n                  v Q m₁ * v Q m₂ + r₁ • e0 Q * v Q m₂ + v Q m₁ * r₂ • e0 Q +\n                    r₁ • e0 Q * r₂ • e0 Q := by\n                have h1 : e0 Q * v Q m₁ * (e0 Q * v Q m₂) = v Q m₁ * v Q m₂ := by\n                  rw [← mul_assoc, e0_mul_v_mul_e0]\n                have h2 : -(r₂ • e0 Q * v Q m₁) = v Q m₁ * r₂ • e0 Q := by\n                  rw [mul_smul_comm, smul_mul_assoc, ← smul_neg, neg_e0_mul_v]\n                have h3 : -algebraMap R _ (r₁ * r₂) = r₁ • e0 Q * r₂ • e0 Q := by\n                  rw [Algebra.algebraMap_eq_smul_one, smul_mul_smul_comm, e0_mul_e0, smul_neg]\n                rw [sub_eq_add_neg, sub_eq_add_neg, h1, h2, h3]\n              _ = ι (Q' Q) (m₁, r₁) * ι (Q' Q) (m₂, r₂) := by\n                rw [ι_eq_v_add_smul_e0, ι_eq_v_add_smul_e0, mul_add, add_mul, add_mul, add_assoc]\n\n"}
{"name":"CliffordAlgebra.ofEven_comp_toEven","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\n⊢ Eq ((CliffordAlgebra.ofEven Q).comp (CliffordAlgebra.toEven Q)) (AlgHom.id R (CliffordAlgebra Q))","decl":"theorem ofEven_comp_toEven : (ofEven Q).comp (toEven Q) = AlgHom.id R _ :=\n  CliffordAlgebra.hom_ext <|\n    LinearMap.ext fun m =>\n      calc\n        ofEven Q (toEven Q (ι Q m)) = ofEven Q ⟨_, (toEven Q (ι Q m)).prop⟩ := by\n          rw [Subtype.coe_eta]\n        _ = (ι Q 0 + algebraMap R _ 1) * (ι Q m - algebraMap R _ 0) := by\n          simp_rw [toEven_ι]\n          exact ofEven_ι Q _ _\n        _ = ι Q m := by rw [map_one, map_zero, map_zero, sub_zero, zero_add, one_mul]\n\n"}
{"name":"CliffordAlgebra.coe_toEven_reverse_involute","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\n⊢ Eq (↑((CliffordAlgebra.toEven Q) (CliffordAlgebra.reverse (CliffordAlgebra.involute x)))) (CliffordAlgebra.reverse ↑((CliffordAlgebra.toEven Q) x))","decl":"/-- The representation of the clifford conjugate (i.e. the reverse of the involute) in the even\nsubalgebra is just the reverse of the representation. -/\ntheorem coe_toEven_reverse_involute (x : CliffordAlgebra Q) :\n    ↑(toEven Q (reverse (involute x))) =\n      reverse (Q := Q' Q) (toEven Q x : CliffordAlgebra (Q' Q)) := by\n  induction x using CliffordAlgebra.induction with\n  | algebraMap r => simp only [AlgHom.commutes, Subalgebra.coe_algebraMap, reverse.commutes]\n  | ι m =>\n    -- Porting note: added `letI`\n    letI : SubtractionMonoid (even (Q' Q)) := AddGroup.toSubtractionMonoid\n    simp only [involute_ι, Subalgebra.coe_neg, toEven_ι, reverse.map_mul, reverse_v, reverse_e0,\n      reverse_ι, neg_e0_mul_v, map_neg]\n  | mul x y hx hy => simp only [map_mul, Subalgebra.coe_mul, reverse.map_mul, hx, hy]\n  | add x y hx hy => simp only [map_add, Subalgebra.coe_add, hx, hy]\n\n"}
{"name":"CliffordAlgebra.evenToNeg_ι","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ Q' : QuadraticForm R M\nh : Eq Q' (Neg.neg Q)\nm₁ m₂ : M\n⊢ Eq ((CliffordAlgebra.evenToNeg Q Q' h) (((CliffordAlgebra.even.ι Q).bilin m₁) m₂)) (Neg.neg (((CliffordAlgebra.even.ι Q').bilin m₁) m₂))","decl":"@[simp, nolint simpNF]\ntheorem evenToNeg_ι (Q' : QuadraticForm R M) (h : Q' = -Q) (m₁ m₂ : M) :\n    evenToNeg Q Q' h ((even.ι Q).bilin m₁ m₂) = -(even.ι Q').bilin m₁ m₂ :=\n  even.lift_ι _ _ m₁ m₂\n\n"}
{"name":"CliffordAlgebra.evenToNeg_comp_evenToNeg","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ Q' : QuadraticForm R M\nh : Eq Q' (Neg.neg Q)\nh' : Eq Q (Neg.neg Q')\n⊢ Eq ((CliffordAlgebra.evenToNeg Q' Q h').comp (CliffordAlgebra.evenToNeg Q Q' h)) (AlgHom.id R (Subtype fun x => Membership.mem (CliffordAlgebra.even Q) x))","decl":"theorem evenToNeg_comp_evenToNeg (Q' : QuadraticForm R M) (h : Q' = -Q) (h' : Q = -Q') :\n    (evenToNeg Q' Q h').comp (evenToNeg Q Q' h) = AlgHom.id R _ := by\n  ext m₁ m₂ : 4\n  simp [evenToNeg_ι]\n\n"}
{"name":"CliffordAlgebra.evenEquivEvenNeg_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\na : Subtype fun x => Membership.mem (CliffordAlgebra.even Q) x\n⊢ Eq ((CliffordAlgebra.evenEquivEvenNeg Q) a) ((CliffordAlgebra.evenToNeg Q (Neg.neg Q) ⋯) a)","decl":"/-- The even subalgebras of the algebras with quadratic form `Q` and `-Q` are isomorphic.\n\nStated another way, `𝒞ℓ⁺(p,q,r)` and `𝒞ℓ⁺(q,p,r)` are isomorphic. -/\n@[simps!]\ndef evenEquivEvenNeg : CliffordAlgebra.even Q ≃ₐ[R] CliffordAlgebra.even (-Q) :=\n  AlgEquiv.ofAlgHom (evenToNeg Q _ rfl) (evenToNeg (-Q) _ (neg_neg _).symm)\n    (evenToNeg_comp_evenToNeg _ _ _ _) (evenToNeg_comp_evenToNeg _ _ _ _)\n\n-- Note: times out on linting CI\n"}
{"name":"CliffordAlgebra.evenEquivEvenNeg_symm_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nQ : QuadraticForm R M\na : Subtype fun x => Membership.mem (CliffordAlgebra.even (Neg.neg Q)) x\n⊢ Eq ((CliffordAlgebra.evenEquivEvenNeg Q).symm a) ((CliffordAlgebra.evenToNeg (Neg.neg Q) Q ⋯) a)","decl":"/-- The even subalgebras of the algebras with quadratic form `Q` and `-Q` are isomorphic.\n\nStated another way, `𝒞ℓ⁺(p,q,r)` and `𝒞ℓ⁺(q,p,r)` are isomorphic. -/\n@[simps!]\ndef evenEquivEvenNeg : CliffordAlgebra.even Q ≃ₐ[R] CliffordAlgebra.even (-Q) :=\n  AlgEquiv.ofAlgHom (evenToNeg Q _ rfl) (evenToNeg (-Q) _ (neg_neg _).symm)\n    (evenToNeg_comp_evenToNeg _ _ _ _) (evenToNeg_comp_evenToNeg _ _ _ _)\n\n-- Note: times out on linting CI\n"}
