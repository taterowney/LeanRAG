{"name":"CliffordAlgebra.EquivEven.Q'_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nQ : QuadraticForm R M\nm : Prod M R\n‚ä¢ Eq ((CliffordAlgebra.EquivEven.Q' Q) m) (HSub.hSub (Q m.1) (HMul.hMul m.2 m.2))","decl":"theorem Q'_apply (m : M √ó R) : Q' Q m = Q m.1 - m.2 * m.2 :=\n  (sub_eq_add_neg _ _).symm\n\n"}
{"name":"CliffordAlgebra.EquivEven.Œπ_eq_v_add_smul_e0","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nQ : QuadraticForm R M\nm : M\nr : R\n‚ä¢ Eq ((CliffordAlgebra.Œπ (CliffordAlgebra.EquivEven.Q' Q)) { fst := m, snd := r }) (HAdd.hAdd ((CliffordAlgebra.EquivEven.v Q) m) (HSMul.hSMul r (CliffordAlgebra.EquivEven.e0 Q)))","decl":"theorem Œπ_eq_v_add_smul_e0 (m : M) (r : R) : Œπ (Q' Q) (m, r) = v Q m + r ‚Ä¢ e0 Q := by\n  rw [e0, v, LinearMap.comp_apply, LinearMap.inl_apply, ‚Üê LinearMap.map_smul, Prod.smul_mk,\n    smul_zero, smul_eq_mul, mul_one, ‚Üê LinearMap.map_add, Prod.mk_add_mk, zero_add, add_zero]\n\n"}
{"name":"CliffordAlgebra.EquivEven.e0_mul_e0","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nQ : QuadraticForm R M\n‚ä¢ Eq (HMul.hMul (CliffordAlgebra.EquivEven.e0 Q) (CliffordAlgebra.EquivEven.e0 Q)) (-1)","decl":"theorem e0_mul_e0 : e0 Q * e0 Q = -1 :=\n  (Œπ_sq_scalar _ _).trans <| by simp\n\n"}
{"name":"CliffordAlgebra.EquivEven.v_sq_scalar","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nQ : QuadraticForm R M\nm : M\n‚ä¢ Eq (HMul.hMul ((CliffordAlgebra.EquivEven.v Q) m) ((CliffordAlgebra.EquivEven.v Q) m)) ((algebraMap R (CliffordAlgebra (CliffordAlgebra.EquivEven.Q' Q))) (Q m))","decl":"theorem v_sq_scalar (m : M) : v Q m * v Q m = algebraMap _ _ (Q m) :=\n  (Œπ_sq_scalar _ _).trans <| by simp\n\n"}
{"name":"CliffordAlgebra.EquivEven.neg_e0_mul_v","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nQ : QuadraticForm R M\nm : M\n‚ä¢ Eq (Neg.neg (HMul.hMul (CliffordAlgebra.EquivEven.e0 Q) ((CliffordAlgebra.EquivEven.v Q) m))) (HMul.hMul ((CliffordAlgebra.EquivEven.v Q) m) (CliffordAlgebra.EquivEven.e0 Q))","decl":"theorem neg_e0_mul_v (m : M) : -(e0 Q * v Q m) = v Q m * e0 Q := by\n  refine neg_eq_of_add_eq_zero_right ((Œπ_mul_Œπ_add_swap _ _).trans ?_)\n  dsimp [QuadraticMap.polar]\n  simp only [add_zero, mul_zero, mul_one, zero_add, neg_zero, QuadraticMap.map_zero,\n    add_sub_cancel_right, sub_self, map_zero, zero_sub]\n\n"}
{"name":"CliffordAlgebra.EquivEven.neg_v_mul_e0","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nQ : QuadraticForm R M\nm : M\n‚ä¢ Eq (Neg.neg (HMul.hMul ((CliffordAlgebra.EquivEven.v Q) m) (CliffordAlgebra.EquivEven.e0 Q))) (HMul.hMul (CliffordAlgebra.EquivEven.e0 Q) ((CliffordAlgebra.EquivEven.v Q) m))","decl":"theorem neg_v_mul_e0 (m : M) : -(v Q m * e0 Q) = e0 Q * v Q m := by\n  rw [neg_eq_iff_eq_neg]\n  exact (neg_e0_mul_v _ m).symm\n\n"}
{"name":"CliffordAlgebra.EquivEven.e0_mul_v_mul_e0","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nQ : QuadraticForm R M\nm : M\n‚ä¢ Eq (HMul.hMul (HMul.hMul (CliffordAlgebra.EquivEven.e0 Q) ((CliffordAlgebra.EquivEven.v Q) m)) (CliffordAlgebra.EquivEven.e0 Q)) ((CliffordAlgebra.EquivEven.v Q) m)","decl":"@[simp]\ntheorem e0_mul_v_mul_e0 (m : M) : e0 Q * v Q m * e0 Q = v Q m := by\n  rw [‚Üê neg_v_mul_e0, ‚Üê neg_mul, mul_assoc, e0_mul_e0, mul_neg_one, neg_neg]\n\n"}
{"name":"CliffordAlgebra.EquivEven.reverse_v","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nQ : QuadraticForm R M\nm : M\n‚ä¢ Eq (CliffordAlgebra.reverse ((CliffordAlgebra.EquivEven.v Q) m)) ((CliffordAlgebra.EquivEven.v Q) m)","decl":"@[simp]\ntheorem reverse_v (m : M) : reverse (Q := Q' Q) (v Q m) = v Q m :=\n  reverse_Œπ _\n\n"}
{"name":"CliffordAlgebra.EquivEven.involute_v","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nQ : QuadraticForm R M\nm : M\n‚ä¢ Eq (CliffordAlgebra.involute ((CliffordAlgebra.EquivEven.v Q) m)) (Neg.neg ((CliffordAlgebra.EquivEven.v Q) m))","decl":"@[simp]\ntheorem involute_v (m : M) : involute (v Q m) = -v Q m :=\n  involute_Œπ _\n\n"}
{"name":"CliffordAlgebra.EquivEven.reverse_e0","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nQ : QuadraticForm R M\n‚ä¢ Eq (CliffordAlgebra.reverse (CliffordAlgebra.EquivEven.e0 Q)) (CliffordAlgebra.EquivEven.e0 Q)","decl":"@[simp]\ntheorem reverse_e0 : reverse (Q := Q' Q) (e0 Q) = e0 Q :=\n  reverse_Œπ _\n\n"}
{"name":"CliffordAlgebra.EquivEven.involute_e0","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nQ : QuadraticForm R M\n‚ä¢ Eq (CliffordAlgebra.involute (CliffordAlgebra.EquivEven.e0 Q)) (Neg.neg (CliffordAlgebra.EquivEven.e0 Q))","decl":"@[simp]\ntheorem involute_e0 : involute (e0 Q) = -e0 Q :=\n  involute_Œπ _\n\n"}
{"name":"CliffordAlgebra.toEven_Œπ","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nQ : QuadraticForm R M\nm : M\n‚ä¢ Eq (‚Üë((CliffordAlgebra.toEven Q) ((CliffordAlgebra.Œπ Q) m))) (HMul.hMul (CliffordAlgebra.EquivEven.e0 Q) ((CliffordAlgebra.EquivEven.v Q) m))","decl":"theorem toEven_Œπ (m : M) : (toEven Q (Œπ Q m) : CliffordAlgebra (Q' Q)) = e0 Q * v Q m := by\n  rw [toEven, CliffordAlgebra.lift_Œπ_apply]\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11224): was `rw`\n  erw [LinearMap.codRestrict_apply]\n  rw [LinearMap.coe_comp, Function.comp_apply, LinearMap.mulLeft_apply]\n\n"}
{"name":"CliffordAlgebra.ofEven_Œπ","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nQ : QuadraticForm R M\nx y : Prod M R\n‚ä¢ Eq ((CliffordAlgebra.ofEven Q) (((CliffordAlgebra.even.Œπ (CliffordAlgebra.EquivEven.Q' Q)).bilin x) y)) (HMul.hMul (HAdd.hAdd ((CliffordAlgebra.Œπ Q) x.1) ((algebraMap R (CliffordAlgebra Q)) x.2)) (HSub.hSub ((CliffordAlgebra.Œπ Q) y.1) ((algebraMap R (CliffordAlgebra Q)) y.2)))","decl":"theorem ofEven_Œπ (x y : M √ó R) :\n    ofEven Q ((even.Œπ (Q' Q)).bilin x y) =\n      (Œπ Q x.1 + algebraMap R _ x.2) * (Œπ Q y.1 - algebraMap R _ y.2) :=\n  even.lift_Œπ (Q' Q) _ x y\n\n"}
{"name":"CliffordAlgebra.toEven_comp_ofEven","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nQ : QuadraticForm R M\n‚ä¢ Eq ((CliffordAlgebra.toEven Q).comp (CliffordAlgebra.ofEven Q)) (AlgHom.id R (Subtype fun x => Membership.mem (CliffordAlgebra.even (CliffordAlgebra.EquivEven.Q' Q)) x))","decl":"theorem toEven_comp_ofEven : (toEven Q).comp (ofEven Q) = AlgHom.id R _ :=\n  even.algHom_ext (Q' Q) <|\n    EvenHom.ext <|\n      LinearMap.ext fun m‚ÇÅ =>\n        LinearMap.ext fun m‚ÇÇ =>\n          Subtype.ext <|\n            let ‚ü®m‚ÇÅ, r‚ÇÅ‚ü© := m‚ÇÅ\n            let ‚ü®m‚ÇÇ, r‚ÇÇ‚ü© := m‚ÇÇ\n            calc\n              ‚Üë(toEven Q (ofEven Q ((even.Œπ (Q' Q)).bilin (m‚ÇÅ, r‚ÇÅ) (m‚ÇÇ, r‚ÇÇ)))) =\n                  (e0 Q * v Q m‚ÇÅ + algebraMap R _ r‚ÇÅ) * (e0 Q * v Q m‚ÇÇ - algebraMap R _ r‚ÇÇ) := by\n                rw [ofEven_Œπ, map_mul, map_add, map_sub, AlgHom.commutes,\n                  AlgHom.commutes, Subalgebra.coe_mul, Subalgebra.coe_add, Subalgebra.coe_sub,\n                  toEven_Œπ, toEven_Œπ, Subalgebra.coe_algebraMap, Subalgebra.coe_algebraMap]\n              _ =\n                  e0 Q * v Q m‚ÇÅ * (e0 Q * v Q m‚ÇÇ) + r‚ÇÅ ‚Ä¢ e0 Q * v Q m‚ÇÇ - r‚ÇÇ ‚Ä¢ e0 Q * v Q m‚ÇÅ -\n                    algebraMap R _ (r‚ÇÅ * r‚ÇÇ) := by\n                rw [mul_sub, add_mul, add_mul, ‚Üê Algebra.commutes, ‚Üê Algebra.smul_def, ‚Üê map_mul, ‚Üê\n                  Algebra.smul_def, sub_add_eq_sub_sub, smul_mul_assoc, smul_mul_assoc]\n              _ =\n                  v Q m‚ÇÅ * v Q m‚ÇÇ + r‚ÇÅ ‚Ä¢ e0 Q * v Q m‚ÇÇ + v Q m‚ÇÅ * r‚ÇÇ ‚Ä¢ e0 Q +\n                    r‚ÇÅ ‚Ä¢ e0 Q * r‚ÇÇ ‚Ä¢ e0 Q := by\n                have h1 : e0 Q * v Q m‚ÇÅ * (e0 Q * v Q m‚ÇÇ) = v Q m‚ÇÅ * v Q m‚ÇÇ := by\n                  rw [‚Üê mul_assoc, e0_mul_v_mul_e0]\n                have h2 : -(r‚ÇÇ ‚Ä¢ e0 Q * v Q m‚ÇÅ) = v Q m‚ÇÅ * r‚ÇÇ ‚Ä¢ e0 Q := by\n                  rw [mul_smul_comm, smul_mul_assoc, ‚Üê smul_neg, neg_e0_mul_v]\n                have h3 : -algebraMap R _ (r‚ÇÅ * r‚ÇÇ) = r‚ÇÅ ‚Ä¢ e0 Q * r‚ÇÇ ‚Ä¢ e0 Q := by\n                  rw [Algebra.algebraMap_eq_smul_one, smul_mul_smul_comm, e0_mul_e0, smul_neg]\n                rw [sub_eq_add_neg, sub_eq_add_neg, h1, h2, h3]\n              _ = Œπ (Q' Q) (m‚ÇÅ, r‚ÇÅ) * Œπ (Q' Q) (m‚ÇÇ, r‚ÇÇ) := by\n                rw [Œπ_eq_v_add_smul_e0, Œπ_eq_v_add_smul_e0, mul_add, add_mul, add_mul, add_assoc]\n\n"}
{"name":"CliffordAlgebra.ofEven_comp_toEven","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nQ : QuadraticForm R M\n‚ä¢ Eq ((CliffordAlgebra.ofEven Q).comp (CliffordAlgebra.toEven Q)) (AlgHom.id R (CliffordAlgebra Q))","decl":"theorem ofEven_comp_toEven : (ofEven Q).comp (toEven Q) = AlgHom.id R _ :=\n  CliffordAlgebra.hom_ext <|\n    LinearMap.ext fun m =>\n      calc\n        ofEven Q (toEven Q (Œπ Q m)) = ofEven Q ‚ü®_, (toEven Q (Œπ Q m)).prop‚ü© := by\n          rw [Subtype.coe_eta]\n        _ = (Œπ Q 0 + algebraMap R _ 1) * (Œπ Q m - algebraMap R _ 0) := by\n          simp_rw [toEven_Œπ]\n          exact ofEven_Œπ Q _ _\n        _ = Œπ Q m := by rw [map_one, map_zero, map_zero, sub_zero, zero_add, one_mul]\n\n"}
{"name":"CliffordAlgebra.coe_toEven_reverse_involute","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nQ : QuadraticForm R M\nx : CliffordAlgebra Q\n‚ä¢ Eq (‚Üë((CliffordAlgebra.toEven Q) (CliffordAlgebra.reverse (CliffordAlgebra.involute x)))) (CliffordAlgebra.reverse ‚Üë((CliffordAlgebra.toEven Q) x))","decl":"/-- The representation of the clifford conjugate (i.e. the reverse of the involute) in the even\nsubalgebra is just the reverse of the representation. -/\ntheorem coe_toEven_reverse_involute (x : CliffordAlgebra Q) :\n    ‚Üë(toEven Q (reverse (involute x))) =\n      reverse (Q := Q' Q) (toEven Q x : CliffordAlgebra (Q' Q)) := by\n  induction x using CliffordAlgebra.induction with\n  | algebraMap r => simp only [AlgHom.commutes, Subalgebra.coe_algebraMap, reverse.commutes]\n  | Œπ m =>\n    -- Porting note: added `letI`\n    letI : SubtractionMonoid (even (Q' Q)) := AddGroup.toSubtractionMonoid\n    simp only [involute_Œπ, Subalgebra.coe_neg, toEven_Œπ, reverse.map_mul, reverse_v, reverse_e0,\n      reverse_Œπ, neg_e0_mul_v, map_neg]\n  | mul x y hx hy => simp only [map_mul, Subalgebra.coe_mul, reverse.map_mul, hx, hy]\n  | add x y hx hy => simp only [map_add, Subalgebra.coe_add, hx, hy]\n\n"}
{"name":"CliffordAlgebra.evenToNeg_Œπ","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nQ Q' : QuadraticForm R M\nh : Eq Q' (Neg.neg Q)\nm‚ÇÅ m‚ÇÇ : M\n‚ä¢ Eq ((CliffordAlgebra.evenToNeg Q Q' h) (((CliffordAlgebra.even.Œπ Q).bilin m‚ÇÅ) m‚ÇÇ)) (Neg.neg (((CliffordAlgebra.even.Œπ Q').bilin m‚ÇÅ) m‚ÇÇ))","decl":"@[simp, nolint simpNF]\ntheorem evenToNeg_Œπ (Q' : QuadraticForm R M) (h : Q' = -Q) (m‚ÇÅ m‚ÇÇ : M) :\n    evenToNeg Q Q' h ((even.Œπ Q).bilin m‚ÇÅ m‚ÇÇ) = -(even.Œπ Q').bilin m‚ÇÅ m‚ÇÇ :=\n  even.lift_Œπ _ _ m‚ÇÅ m‚ÇÇ\n\n"}
{"name":"CliffordAlgebra.evenToNeg_comp_evenToNeg","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nQ Q' : QuadraticForm R M\nh : Eq Q' (Neg.neg Q)\nh' : Eq Q (Neg.neg Q')\n‚ä¢ Eq ((CliffordAlgebra.evenToNeg Q' Q h').comp (CliffordAlgebra.evenToNeg Q Q' h)) (AlgHom.id R (Subtype fun x => Membership.mem (CliffordAlgebra.even Q) x))","decl":"theorem evenToNeg_comp_evenToNeg (Q' : QuadraticForm R M) (h : Q' = -Q) (h' : Q = -Q') :\n    (evenToNeg Q' Q h').comp (evenToNeg Q Q' h) = AlgHom.id R _ := by\n  ext m‚ÇÅ m‚ÇÇ : 4\n  simp [evenToNeg_Œπ]\n\n"}
{"name":"CliffordAlgebra.evenEquivEvenNeg_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nQ : QuadraticForm R M\na : Subtype fun x => Membership.mem (CliffordAlgebra.even Q) x\n‚ä¢ Eq ((CliffordAlgebra.evenEquivEvenNeg Q) a) ((CliffordAlgebra.evenToNeg Q (Neg.neg Q) ‚ãØ) a)","decl":"/-- The even subalgebras of the algebras with quadratic form `Q` and `-Q` are isomorphic.\n\nStated another way, `ùíû‚Ñì‚Å∫(p,q,r)` and `ùíû‚Ñì‚Å∫(q,p,r)` are isomorphic. -/\n@[simps!]\ndef evenEquivEvenNeg : CliffordAlgebra.even Q ‚âÉ‚Çê[R] CliffordAlgebra.even (-Q) :=\n  AlgEquiv.ofAlgHom (evenToNeg Q _ rfl) (evenToNeg (-Q) _ (neg_neg _).symm)\n    (evenToNeg_comp_evenToNeg _ _ _ _) (evenToNeg_comp_evenToNeg _ _ _ _)\n\n-- Note: times out on linting CI\n"}
{"name":"CliffordAlgebra.evenEquivEvenNeg_symm_apply","module":"Mathlib.LinearAlgebra.CliffordAlgebra.EvenEquiv","initialProofState":"R : Type u_1\nM : Type u_2\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\nQ : QuadraticForm R M\na : Subtype fun x => Membership.mem (CliffordAlgebra.even (Neg.neg Q)) x\n‚ä¢ Eq ((CliffordAlgebra.evenEquivEvenNeg Q).symm a) ((CliffordAlgebra.evenToNeg (Neg.neg Q) Q ‚ãØ) a)","decl":"/-- The even subalgebras of the algebras with quadratic form `Q` and `-Q` are isomorphic.\n\nStated another way, `ùíû‚Ñì‚Å∫(p,q,r)` and `ùíû‚Ñì‚Å∫(q,p,r)` are isomorphic. -/\n@[simps!]\ndef evenEquivEvenNeg : CliffordAlgebra.even Q ‚âÉ‚Çê[R] CliffordAlgebra.even (-Q) :=\n  AlgEquiv.ofAlgHom (evenToNeg Q _ rfl) (evenToNeg (-Q) _ (neg_neg _).symm)\n    (evenToNeg_comp_evenToNeg _ _ _ _) (evenToNeg_comp_evenToNeg _ _ _ _)\n\n-- Note: times out on linting CI\n"}
