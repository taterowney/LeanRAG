{"name":"Equiv.Perm.isConj_of_support_equiv","module":"Mathlib.GroupTheory.Perm.Finite","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nσ τ : Equiv.Perm α\nf : Equiv (Subtype fun x => Membership.mem (↑σ.support) x) (Subtype fun x => Membership.mem (↑τ.support) x)\nhf : ∀ (x : α) (hx : Membership.mem (↑σ.support) x), Eq (↑(f ⟨σ x, ⋯⟩)) (τ ↑(f ⟨x, hx⟩))\n⊢ IsConj σ τ","decl":"theorem isConj_of_support_equiv\n    (f : { x // x ∈ (σ.support : Set α) } ≃ { x // x ∈ (τ.support : Set α) })\n    (hf : ∀ (x : α) (hx : x ∈ (σ.support : Set α)),\n      (f ⟨σ x, apply_mem_support.2 hx⟩ : α) = τ ↑(f ⟨x, hx⟩)) :\n    IsConj σ τ := by\n  refine isConj_iff.2 ⟨Equiv.extendSubtype f, ?_⟩\n  rw [mul_inv_eq_iff_eq_mul]\n  ext x\n  simp only [Perm.mul_apply]\n  by_cases hx : x ∈ σ.support\n  · rw [Equiv.extendSubtype_apply_of_mem, Equiv.extendSubtype_apply_of_mem]\n    · exact hf x (Finset.mem_coe.2 hx)\n  · rwa [Classical.not_not.1 ((not_congr mem_support).1 (Equiv.extendSubtype_not_mem f _ _)),\n      Classical.not_not.1 ((not_congr mem_support).mp hx)]\n\n"}
{"name":"Equiv.Perm.perm_inv_on_of_perm_on_finset","module":"Mathlib.GroupTheory.Perm.Finite","initialProofState":"α : Type u\ns : Finset α\nf : Equiv.Perm α\nh : ∀ (x : α), Membership.mem s x → Membership.mem s (f x)\ny : α\nhy : Membership.mem s y\n⊢ Membership.mem s ((Inv.inv f) y)","decl":"theorem perm_inv_on_of_perm_on_finset {s : Finset α} {f : Perm α} (h : ∀ x ∈ s, f x ∈ s) {y : α}\n    (hy : y ∈ s) : f⁻¹ y ∈ s := by\n  have h0 : ∀ y ∈ s, ∃ (x : _) (hx : x ∈ s), y = (fun i (_ : i ∈ s) => f i) x hx :=\n    Finset.surj_on_of_inj_on_of_card_le (fun x hx => (fun i _ => f i) x hx) (fun a ha => h a ha)\n      (fun a₁ a₂ ha₁ ha₂ heq => (Equiv.apply_eq_iff_eq f).mp heq) rfl.ge\n  obtain ⟨y2, hy2, heq⟩ := h0 y hy\n  convert hy2\n  rw [heq]\n  simp only [inv_apply_self]\n\n"}
{"name":"Equiv.Perm.perm_inv_mapsTo_of_mapsTo","module":"Mathlib.GroupTheory.Perm.Finite","initialProofState":"α : Type u\nf : Equiv.Perm α\ns : Set α\ninst✝ : Finite ↑s\nh : Set.MapsTo (⇑f) s s\n⊢ Set.MapsTo (⇑(Inv.inv f)) s s","decl":"theorem perm_inv_mapsTo_of_mapsTo (f : Perm α) {s : Set α} [Finite s] (h : Set.MapsTo f s s) :\n    Set.MapsTo (f⁻¹ :) s s := by\n  cases nonempty_fintype s\n  exact fun x hx =>\n    Set.mem_toFinset.mp <|\n      perm_inv_on_of_perm_on_finset\n        (fun a ha => Set.mem_toFinset.mpr (h (Set.mem_toFinset.mp ha)))\n        (Set.mem_toFinset.mpr hx)\n\n"}
{"name":"Equiv.Perm.perm_inv_mapsTo_iff_mapsTo","module":"Mathlib.GroupTheory.Perm.Finite","initialProofState":"α : Type u\nf : Equiv.Perm α\ns : Set α\ninst✝ : Finite ↑s\n⊢ Iff (Set.MapsTo (⇑(Inv.inv f)) s s) (Set.MapsTo (⇑f) s s)","decl":"@[simp]\ntheorem perm_inv_mapsTo_iff_mapsTo {f : Perm α} {s : Set α} [Finite s] :\n    Set.MapsTo (f⁻¹ :) s s ↔ Set.MapsTo f s s :=\n  ⟨perm_inv_mapsTo_of_mapsTo f⁻¹, perm_inv_mapsTo_of_mapsTo f⟩\n\n"}
{"name":"Equiv.Perm.perm_inv_on_of_perm_on_finite","module":"Mathlib.GroupTheory.Perm.Finite","initialProofState":"α : Type u\nf : Equiv.Perm α\np : α → Prop\ninst✝ : Finite (Subtype fun x => p x)\nh : ∀ (x : α), p x → p (f x)\nx : α\nhx : p x\n⊢ p ((Inv.inv f) x)","decl":"theorem perm_inv_on_of_perm_on_finite {f : Perm α} {p : α → Prop} [Finite { x // p x }]\n    (h : ∀ x, p x → p (f x)) {x : α} (hx : p x) : p (f⁻¹ x) :=\n  -- Porting note: relies heavily on the definitions of `Subtype` and `setOf` unfolding to their\n  -- underlying predicate.\n  have : Finite { x | p x } := ‹_›\n  perm_inv_mapsTo_of_mapsTo (s := {x | p x}) f h hx\n\n"}
{"name":"Equiv.Perm.subtypePermOfFintype_apply","module":"Mathlib.GroupTheory.Perm.Finite","initialProofState":"α : Type u\nf : Equiv.Perm α\np : α → Prop\ninst✝ : Finite (Subtype fun x => p x)\nh : ∀ (x : α), p x → p (f x)\nx : Subtype fun x => p x\n⊢ Eq ((f.subtypePermOfFintype h) x) ⟨f ↑x, ⋯⟩","decl":"@[simp]\ntheorem subtypePermOfFintype_apply (f : Perm α) {p : α → Prop} [Finite { x // p x }]\n    (h : ∀ x, p x → p (f x)) (x : { x // p x }) : subtypePermOfFintype f h x = ⟨f x, h x x.2⟩ :=\n  rfl\n\n"}
{"name":"Equiv.Perm.subtypePermOfFintype_one","module":"Mathlib.GroupTheory.Perm.Finite","initialProofState":"α : Type u\np : α → Prop\ninst✝ : Finite (Subtype fun x => p x)\nh : ∀ (x : α), p x → p (1 x)\n⊢ Eq (Equiv.Perm.subtypePermOfFintype 1 h) 1","decl":"theorem subtypePermOfFintype_one (p : α → Prop) [Finite { x // p x }]\n    (h : ∀ x, p x → p ((1 : Perm α) x)) : @subtypePermOfFintype α 1 p _ h = 1 :=\n  rfl\n\n"}
{"name":"Equiv.Perm.perm_mapsTo_inl_iff_mapsTo_inr","module":"Mathlib.GroupTheory.Perm.Finite","initialProofState":"m : Type u_1\nn : Type u_2\ninst✝¹ : Finite m\ninst✝ : Finite n\nσ : Equiv.Perm (Sum m n)\n⊢ Iff (Set.MapsTo (⇑σ) (Set.range Sum.inl) (Set.range Sum.inl)) (Set.MapsTo (⇑σ) (Set.range Sum.inr) (Set.range Sum.inr))","decl":"theorem perm_mapsTo_inl_iff_mapsTo_inr {m n : Type*} [Finite m] [Finite n] (σ : Perm (m ⊕ n)) :\n    Set.MapsTo σ (Set.range Sum.inl) (Set.range Sum.inl) ↔\n      Set.MapsTo σ (Set.range Sum.inr) (Set.range Sum.inr) := by\n  constructor <;>\n    ( intro h\n      classical\n        rw [← perm_inv_mapsTo_iff_mapsTo] at h\n        intro x\n        cases' hx : σ x with l r)\n  · rintro ⟨a, rfl⟩\n    obtain ⟨y, hy⟩ := h ⟨l, rfl⟩\n    rw [← hx, σ.inv_apply_self] at hy\n    exact absurd hy Sum.inl_ne_inr\n  · rintro _; exact ⟨r, rfl⟩\n  · rintro _; exact ⟨l, rfl⟩\n  · rintro ⟨a, rfl⟩\n    obtain ⟨y, hy⟩ := h ⟨r, rfl⟩\n    rw [← hx, σ.inv_apply_self] at hy\n    exact absurd hy Sum.inr_ne_inl\n\n"}
{"name":"Equiv.Perm.mem_sumCongrHom_range_of_perm_mapsTo_inl","module":"Mathlib.GroupTheory.Perm.Finite","initialProofState":"m : Type u_1\nn : Type u_2\ninst✝¹ : Finite m\ninst✝ : Finite n\nσ : Equiv.Perm (Sum m n)\nh : Set.MapsTo (⇑σ) (Set.range Sum.inl) (Set.range Sum.inl)\n⊢ Membership.mem (Equiv.Perm.sumCongrHom m n).range σ","decl":"theorem mem_sumCongrHom_range_of_perm_mapsTo_inl {m n : Type*} [Finite m] [Finite n]\n    {σ : Perm (m ⊕ n)} (h : Set.MapsTo σ (Set.range Sum.inl) (Set.range Sum.inl)) :\n    σ ∈ (sumCongrHom m n).range := by\n  classical\n    have h1 : ∀ x : m ⊕ n, (∃ a : m, Sum.inl a = x) → ∃ a : m, Sum.inl a = σ x := by\n      rintro x ⟨a, ha⟩\n      apply h\n      rw [← ha]\n      exact ⟨a, rfl⟩\n    have h3 : ∀ x : m ⊕ n, (∃ b : n, Sum.inr b = x) → ∃ b : n, Sum.inr b = σ x := by\n      rintro x ⟨b, hb⟩\n      apply (perm_mapsTo_inl_iff_mapsTo_inr σ).mp h\n      rw [← hb]\n      exact ⟨b, rfl⟩\n    let σ₁' := subtypePermOfFintype σ h1\n    let σ₂' := subtypePermOfFintype σ h3\n    let σ₁ := permCongr (Equiv.ofInjective _ Sum.inl_injective).symm σ₁'\n    let σ₂ := permCongr (Equiv.ofInjective _ Sum.inr_injective).symm σ₂'\n    rw [MonoidHom.mem_range, Prod.exists]\n    use σ₁, σ₂\n    rw [Perm.sumCongrHom_apply]\n    ext x\n    cases' x with a b\n    · rw [Equiv.sumCongr_apply, Sum.map_inl, permCongr_apply, Equiv.symm_symm,\n        apply_ofInjective_symm Sum.inl_injective]\n      rw [ofInjective_apply, Subtype.coe_mk, Subtype.coe_mk]\n      -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n      erw [subtypePerm_apply]\n    · rw [Equiv.sumCongr_apply, Sum.map_inr, permCongr_apply, Equiv.symm_symm,\n        apply_ofInjective_symm Sum.inr_injective]\n      erw [subtypePerm_apply]\n      rw [ofInjective_apply, Subtype.coe_mk, Subtype.coe_mk]\n\n"}
{"name":"Equiv.Perm.Disjoint.orderOf","module":"Mathlib.GroupTheory.Perm.Finite","initialProofState":"α : Type u\nσ τ : Equiv.Perm α\nhστ : σ.Disjoint τ\n⊢ Eq (orderOf (HMul.hMul σ τ)) ((orderOf σ).lcm (orderOf τ))","decl":"nonrec theorem Disjoint.orderOf {σ τ : Perm α} (hστ : Disjoint σ τ) :\n    orderOf (σ * τ) = Nat.lcm (orderOf σ) (orderOf τ) :=\n  haveI h : ∀ n : ℕ, (σ * τ) ^ n = 1 ↔ σ ^ n = 1 ∧ τ ^ n = 1 := fun n => by\n    rw [hστ.commute.mul_pow, Disjoint.mul_eq_one_iff (hστ.pow_disjoint_pow n n)]\n  Nat.dvd_antisymm hστ.commute.orderOf_mul_dvd_lcm\n    (Nat.lcm_dvd\n      (orderOf_dvd_of_pow_eq_one ((h (orderOf (σ * τ))).mp (pow_orderOf_eq_one (σ * τ))).1)\n      (orderOf_dvd_of_pow_eq_one ((h (orderOf (σ * τ))).mp (pow_orderOf_eq_one (σ * τ))).2))\n\n"}
{"name":"Equiv.Perm.Disjoint.extendDomain","module":"Mathlib.GroupTheory.Perm.Finite","initialProofState":"α : Type u\nβ : Type v\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\nσ τ : Equiv.Perm α\nh : σ.Disjoint τ\n⊢ (σ.extendDomain f).Disjoint (τ.extendDomain f)","decl":"theorem Disjoint.extendDomain {p : β → Prop} [DecidablePred p] (f : α ≃ Subtype p)\n    {σ τ : Perm α} (h : Disjoint σ τ) : Disjoint (σ.extendDomain f) (τ.extendDomain f) := by\n  intro b\n  by_cases pb : p b\n  · refine (h (f.symm ⟨b, pb⟩)).imp ?_ ?_ <;>\n      · intro h\n        rw [extendDomain_apply_subtype _ _ pb, h, apply_symm_apply, Subtype.coe_mk]\n  · left\n    rw [extendDomain_apply_not_subtype _ _ pb]\n\n"}
{"name":"Equiv.Perm.Disjoint.isConj_mul","module":"Mathlib.GroupTheory.Perm.Finite","initialProofState":"α : Type u\ninst✝ : Finite α\nσ τ π ρ : Equiv.Perm α\nhc1 : IsConj σ π\nhc2 : IsConj τ ρ\nhd1 : σ.Disjoint τ\nhd2 : π.Disjoint ρ\n⊢ IsConj (HMul.hMul σ τ) (HMul.hMul π ρ)","decl":"theorem Disjoint.isConj_mul [Finite α] {σ τ π ρ : Perm α} (hc1 : IsConj σ π)\n    (hc2 : IsConj τ ρ) (hd1 : Disjoint σ τ) (hd2 : Disjoint π ρ) : IsConj (σ * τ) (π * ρ) := by\n  classical\n    cases nonempty_fintype α\n    obtain ⟨f, rfl⟩ := isConj_iff.1 hc1\n    obtain ⟨g, rfl⟩ := isConj_iff.1 hc2\n    have hd1' := coe_inj.2 hd1.support_mul\n    have hd2' := coe_inj.2 hd2.support_mul\n    rw [coe_union] at *\n    have hd1'' := disjoint_coe.2 (disjoint_iff_disjoint_support.1 hd1)\n    have hd2'' := disjoint_coe.2 (disjoint_iff_disjoint_support.1 hd2)\n    refine isConj_of_support_equiv ?_ ?_\n    · refine\n          ((Equiv.Set.ofEq hd1').trans (Equiv.Set.union hd1'')).trans\n            ((Equiv.sumCongr (subtypeEquiv f fun a => ?_) (subtypeEquiv g fun a => ?_)).trans\n              ((Equiv.Set.ofEq hd2').trans (Equiv.Set.union hd2'')).symm) <;>\n      · simp only [Set.mem_image, toEmbedding_apply, exists_eq_right, support_conj, coe_map,\n          apply_eq_iff_eq]\n    · intro x hx\n      simp only [trans_apply, symm_trans_apply, Equiv.Set.ofEq_apply, Equiv.Set.ofEq_symm_apply,\n        Equiv.sumCongr_apply]\n      rw [hd1', Set.mem_union] at hx\n      cases' hx with hxσ hxτ\n      · rw [mem_coe, mem_support] at hxσ\n        rw [Set.union_apply_left, Set.union_apply_left]\n        · simp only [subtypeEquiv_apply, Perm.coe_mul, Sum.map_inl, comp_apply,\n            Set.union_symm_apply_left, Subtype.coe_mk, apply_eq_iff_eq]\n          have h := (hd2 (f x)).resolve_left ?_\n          · rw [mul_apply, mul_apply] at h\n            rw [h, inv_apply_self, (hd1 x).resolve_left hxσ]\n          · rwa [mul_apply, mul_apply, inv_apply_self, apply_eq_iff_eq]\n        · rwa [Subtype.coe_mk, mem_coe, mem_support]\n        · rwa [Subtype.coe_mk, Perm.mul_apply, (hd1 x).resolve_left hxσ, mem_coe,\n            apply_mem_support, mem_support]\n      · rw [mem_coe, ← apply_mem_support, mem_support] at hxτ\n        rw [Set.union_apply_right, Set.union_apply_right]\n        · simp only [subtypeEquiv_apply, Perm.coe_mul, Sum.map_inr, comp_apply,\n            Set.union_symm_apply_right, Subtype.coe_mk, apply_eq_iff_eq]\n          have h := (hd2 (g (τ x))).resolve_right ?_\n          · rw [mul_apply, mul_apply] at h\n            rw [inv_apply_self, h, (hd1 (τ x)).resolve_right hxτ]\n          · rwa [mul_apply, mul_apply, inv_apply_self, apply_eq_iff_eq]\n        · rwa [Subtype.coe_mk, mem_coe, ← apply_mem_support, mem_support]\n        · rwa [Subtype.coe_mk, Perm.mul_apply, (hd1 (τ x)).resolve_right hxτ,\n            mem_coe, mem_support]\n\n"}
{"name":"Equiv.Perm.mem_fixedPoints_iff_apply_mem_of_mem_centralizer","module":"Mathlib.GroupTheory.Perm.Finite","initialProofState":"α : Type u\ng p : Equiv.Perm α\nhp : Membership.mem (Subgroup.centralizer (Singleton.singleton g)) p\nx : α\n⊢ Iff (Membership.mem (Function.fixedPoints ⇑g) x) (Membership.mem (Function.fixedPoints ⇑g) (p x))","decl":"theorem mem_fixedPoints_iff_apply_mem_of_mem_centralizer {g p : Perm α}\n    (hp : p ∈ Subgroup.centralizer {g}) {x : α} :\n    x ∈ Function.fixedPoints g ↔ p x ∈ Function.fixedPoints g :=  by\n  simp only [Subgroup.mem_centralizer_singleton_iff] at hp\n  simp only [Function.mem_fixedPoints_iff]\n  rw [← mul_apply, ← hp, mul_apply, EmbeddingLike.apply_eq_iff_eq]\n\n\n\n"}
{"name":"Equiv.Perm.disjoint_ofSubtype_of_memFixedPoints_self","module":"Mathlib.GroupTheory.Perm.Finite","initialProofState":"α : Type u\ninst✝ : DecidableEq α\ng : Equiv.Perm α\nu : Equiv.Perm ↑(Function.fixedPoints ⇑g)\n⊢ (Equiv.Perm.ofSubtype u).Disjoint g","decl":"lemma disjoint_ofSubtype_of_memFixedPoints_self {g : Perm α}\n    (u : Perm (Function.fixedPoints g)) :\n    Disjoint (ofSubtype u) g := by\n  rw [disjoint_iff_eq_or_eq]\n  intro x\n  by_cases hx : x ∈ Function.fixedPoints g\n  · right; exact hx\n  · left; rw [ofSubtype_apply_of_not_mem u hx]\n\n"}
{"name":"Equiv.Perm.support_pow_coprime","module":"Mathlib.GroupTheory.Perm.Finite","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nσ : Equiv.Perm α\nn : Nat\nh : n.Coprime (orderOf σ)\n⊢ Eq (HPow.hPow σ n).support σ.support","decl":"theorem support_pow_coprime {σ : Perm α} {n : ℕ} (h : Nat.Coprime n (orderOf σ)) :\n    (σ ^ n).support = σ.support := by\n  obtain ⟨m, hm⟩ := exists_pow_eq_self_of_coprime h\n  exact\n    le_antisymm (support_pow_le σ n)\n      (le_trans (ge_of_eq (congr_arg support hm)) (support_pow_le (σ ^ n) m))\n\n"}
{"name":"Equiv.Perm.ofSubtype_support_disjoint","module":"Mathlib.GroupTheory.Perm.Finite","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nσ : Equiv.Perm α\nx : Equiv.Perm ↑(Function.fixedPoints ⇑σ)\n⊢ Disjoint (Equiv.Perm.ofSubtype x).support σ.support","decl":"lemma ofSubtype_support_disjoint {σ : Perm α} (x : Perm (Function.fixedPoints σ)) :\n    _root_.Disjoint x.ofSubtype.support σ.support := by\n  rw [Finset.disjoint_iff_ne]\n  rintro a ha b hb rfl\n  rw [mem_support] at ha hb\n  exact ha (ofSubtype_apply_of_not_mem x (mt Function.mem_fixedPoints_iff.mp hb))\n\n"}
{"name":"Equiv.Perm.disjoint_of_disjoint_support","module":"Mathlib.GroupTheory.Perm.Finite","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nH K : Subgroup (Equiv.Perm α)\nh : ∀ (a : Equiv.Perm α), Membership.mem H a → ∀ (b : Equiv.Perm α), Membership.mem K b → Disjoint a.support b.support\n⊢ Disjoint H K","decl":"lemma disjoint_of_disjoint_support {H K : Subgroup (Perm α)}\n    (h : ∀ a ∈ H, ∀ b ∈ K, _root_.Disjoint a.support b.support) :\n    _root_.Disjoint H K := by\n  rw [disjoint_iff_inf_le]\n  intro x ⟨hx1, hx2⟩\n  specialize h x hx1 x hx2\n  rwa [disjoint_self, Finset.bot_eq_empty, support_eq_empty_iff] at h\n\n"}
{"name":"Equiv.Perm.support_closure_subset_union","module":"Mathlib.GroupTheory.Perm.Finite","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nS : Set (Equiv.Perm α)\na : Equiv.Perm α\na✝ : Membership.mem (Subgroup.closure S) a\n⊢ HasSubset.Subset (↑a.support) (Set.iUnion fun b => Set.iUnion fun h => ↑b.support)","decl":"lemma support_closure_subset_union (S : Set (Perm α)) :\n    ∀ a ∈ closure S, (a.support : Set α) ⊆ ⋃ b ∈ S, b.support := by\n  apply closure_induction\n  · exact fun x hx ↦ Set.subset_iUnion₂_of_subset x hx subset_rfl\n  · simp only [support_one, Finset.coe_empty, Set.empty_subset]\n  · intro a b ha hb hc hd\n    refine (Finset.coe_subset.mpr (support_mul_le a b)).trans ?_\n    rw [Finset.sup_eq_union, Finset.coe_union, Set.union_subset_iff]\n    exact ⟨hc, hd⟩\n  · simp only [support_inv, imp_self, implies_true]\n\n"}
{"name":"Equiv.Perm.disjoint_support_closure_of_disjoint_support","module":"Mathlib.GroupTheory.Perm.Finite","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nS T : Set (Equiv.Perm α)\nh : ∀ (a : Equiv.Perm α), Membership.mem S a → ∀ (b : Equiv.Perm α), Membership.mem T b → Disjoint a.support b.support\na : Equiv.Perm α\na✝¹ : Membership.mem (Subgroup.closure S) a\nb : Equiv.Perm α\na✝ : Membership.mem (Subgroup.closure T) b\n⊢ Disjoint a.support b.support","decl":"lemma disjoint_support_closure_of_disjoint_support {S T : Set (Perm α)}\n    (h : ∀ a ∈ S, ∀ b ∈ T, _root_.Disjoint a.support b.support) :\n    ∀ a ∈ closure S, ∀ b ∈ closure T, _root_.Disjoint a.support b.support := by\n  intro a ha b hb\n  have key1 := support_closure_subset_union S a ha\n  have key2 := support_closure_subset_union T b hb\n  have key := Set.disjoint_of_subset key1 key2\n  simp_rw [Set.disjoint_iUnion_left, Set.disjoint_iUnion_right, Finset.disjoint_coe] at key\n  exact key h\n\n"}
{"name":"Equiv.Perm.disjoint_closure_of_disjoint_support","module":"Mathlib.GroupTheory.Perm.Finite","initialProofState":"α : Type u\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\nS T : Set (Equiv.Perm α)\nh : ∀ (a : Equiv.Perm α), Membership.mem S a → ∀ (b : Equiv.Perm α), Membership.mem T b → Disjoint a.support b.support\n⊢ Disjoint (Subgroup.closure S) (Subgroup.closure T)","decl":"lemma disjoint_closure_of_disjoint_support {S T : Set (Perm α)}\n    (h : ∀ a ∈ S, ∀ b ∈ T, _root_.Disjoint a.support b.support) :\n    _root_.Disjoint (closure S) (closure T) := by\n  apply disjoint_of_disjoint_support\n  apply disjoint_support_closure_of_disjoint_support\n  exact h\n\n"}
