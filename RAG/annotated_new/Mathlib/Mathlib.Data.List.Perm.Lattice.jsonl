{"name":"List.Perm.bagInter_right","module":"Mathlib.Data.List.Perm.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl₁ l₂ t : List α\nh : l₁.Perm l₂\n⊢ (l₁.bagInter t).Perm (l₂.bagInter t)","decl":"theorem Perm.bagInter_right {l₁ l₂ : List α} (t : List α) (h : l₁ ~ l₂) :\n    l₁.bagInter t ~ l₂.bagInter t := by\n  induction h generalizing t with\n  | nil => simp\n  | cons x => by_cases x ∈ t <;> simp [*, Perm.cons]\n  | swap x y =>\n    by_cases h : x = y\n    · simp [h]\n    by_cases xt : x ∈ t <;> by_cases yt : y ∈ t\n    · simp [xt, yt, mem_erase_of_ne h, mem_erase_of_ne (Ne.symm h), erase_comm, swap]\n    · simp [xt, yt, mt mem_of_mem_erase, Perm.cons]\n    · simp [xt, yt, mt mem_of_mem_erase, Perm.cons]\n    · simp [xt, yt]\n  | trans _ _ ih_1 ih_2 => exact (ih_1 _).trans (ih_2 _)\n\n"}
{"name":"List.Perm.bagInter_left","module":"Mathlib.Data.List.Perm.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl t₁ t₂ : List α\np : t₁.Perm t₂\n⊢ Eq (l.bagInter t₁) (l.bagInter t₂)","decl":"theorem Perm.bagInter_left (l : List α) {t₁ t₂ : List α} (p : t₁ ~ t₂) :\n    l.bagInter t₁ = l.bagInter t₂ := by\n  induction' l with a l IH generalizing t₁ t₂ p; · simp\n  by_cases h : a ∈ t₁\n  · simp [h, p.subset h, IH (p.erase _)]\n  · simp [h, mt p.mem_iff.2 h, IH p]\n\n"}
{"name":"List.Perm.bagInter","module":"Mathlib.Data.List.Perm.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl₁ l₂ t₁ t₂ : List α\nhl : l₁.Perm l₂\nht : t₁.Perm t₂\n⊢ (l₁.bagInter t₁).Perm (l₂.bagInter t₂)","decl":"theorem Perm.bagInter {l₁ l₂ t₁ t₂ : List α} (hl : l₁ ~ l₂) (ht : t₁ ~ t₂) :\n    l₁.bagInter t₁ ~ l₂.bagInter t₂ :=\n  ht.bagInter_left l₂ ▸ hl.bagInter_right _\n\n"}
{"name":"List.Perm.inter_append","module":"Mathlib.Data.List.Perm.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl t₁ t₂ : List α\nh : t₁.Disjoint t₂\n⊢ (Inter.inter l (HAppend.hAppend t₁ t₂)).Perm (HAppend.hAppend (Inter.inter l t₁) (Inter.inter l t₂))","decl":"theorem Perm.inter_append {l t₁ t₂ : List α} (h : Disjoint t₁ t₂) :\n    l ∩ (t₁ ++ t₂) ~ l ∩ t₁ ++ l ∩ t₂ := by\n  induction l with\n  | nil => simp\n  | cons x xs l_ih =>\n    by_cases h₁ : x ∈ t₁\n    · have h₂ : x ∉ t₂ := h h₁\n      simp [*]\n    by_cases h₂ : x ∈ t₂\n    · simp only [*, inter_cons_of_not_mem, false_or, mem_append, inter_cons_of_mem,\n        not_false_iff]\n      refine Perm.trans (Perm.cons _ l_ih) ?_\n      change [x] ++ xs ∩ t₁ ++ xs ∩ t₂ ~ xs ∩ t₁ ++ ([x] ++ xs ∩ t₂)\n      rw [← List.append_assoc]\n      solve_by_elim [Perm.append_right, perm_append_comm]\n    · simp [*]\n\n"}
{"name":"List.Perm.take_inter","module":"Mathlib.Data.List.Perm.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nxs ys : List α\nn : Nat\nh : xs.Perm ys\nh' : ys.Nodup\n⊢ (List.take n xs).Perm (ys.inter (List.take n xs))","decl":"theorem Perm.take_inter {xs ys : List α} (n : ℕ) (h : xs ~ ys)\n    (h' : ys.Nodup) : xs.take n ~ ys.inter (xs.take n) := by\n  simp only [List.inter]\n  exact Perm.trans (show xs.take n ~ xs.filter (xs.take n).elem by\n      conv_lhs => rw [Nodup.take_eq_filter_mem ((Perm.nodup_iff h).2 h')])\n    (Perm.filter _ h)\n\n"}
{"name":"List.Perm.drop_inter","module":"Mathlib.Data.List.Perm.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nxs ys : List α\nn : Nat\nh : xs.Perm ys\nh' : ys.Nodup\n⊢ (List.drop n xs).Perm (ys.inter (List.drop n xs))","decl":"theorem Perm.drop_inter {xs ys : List α} (n : ℕ) (h : xs ~ ys) (h' : ys.Nodup) :\n    xs.drop n ~ ys.inter (xs.drop n) := by\n  by_cases h'' : n ≤ xs.length\n  · let n' := xs.length - n\n    have h₀ : n = xs.length - n' := by rwa [Nat.sub_sub_self]\n    have h₁ : xs.drop n = (xs.reverse.take n').reverse := by\n      rw [take_reverse, h₀, reverse_reverse]\n    rw [h₁]\n    apply (reverse_perm _).trans\n    rw [inter_reverse]\n    apply Perm.take_inter _ _ h'\n    apply (reverse_perm _).trans; assumption\n  · have : drop n xs = [] := by\n      apply eq_nil_of_length_eq_zero\n      rw [length_drop, Nat.sub_eq_zero_iff_le]\n      apply le_of_not_ge h''\n    simp [this, List.inter]\n\n"}
{"name":"List.Perm.dropSlice_inter","module":"Mathlib.Data.List.Perm.Lattice","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nxs ys : List α\nn m : Nat\nh : xs.Perm ys\nh' : ys.Nodup\n⊢ (List.dropSlice n m xs).Perm (Inter.inter ys (List.dropSlice n m xs))","decl":"theorem Perm.dropSlice_inter {xs ys : List α} (n m : ℕ) (h : xs ~ ys)\n    (h' : ys.Nodup) : List.dropSlice n m xs ~ ys ∩ List.dropSlice n m xs := by\n  simp only [dropSlice_eq]\n  have : n ≤ n + m := Nat.le_add_right _ _\n  have h₂ := h.nodup_iff.2 h'\n  apply Perm.trans _ (Perm.inter_append _).symm\n  · exact Perm.append (Perm.take_inter _ h h') (Perm.drop_inter _ h h')\n  · exact disjoint_take_drop h₂ this\n\n"}
