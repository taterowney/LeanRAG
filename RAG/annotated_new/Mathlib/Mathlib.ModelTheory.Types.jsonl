{"name":"FirstOrder.Language.Theory.CompleteType.isMaximal'","module":"Mathlib.ModelTheory.Types","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nself : T.CompleteType α\n⊢ self.toTheory.IsMaximal","decl":"/-- A complete type over a given theory in a certain type of variables is a maximally\n  consistent (with the theory) set of formulas in that type. -/\nstructure CompleteType where\n  toTheory : L[[α]].Theory\n  subset' : (L.lhomWithConstants α).onTheory T ⊆ toTheory\n  isMaximal' : toTheory.IsMaximal\n\n"}
{"name":"FirstOrder.Language.Theory.CompleteType.subset'","module":"Mathlib.ModelTheory.Types","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nself : T.CompleteType α\n⊢ HasSubset.Subset ((L.lhomWithConstants α).onTheory T) self.toTheory","decl":"/-- A complete type over a given theory in a certain type of variables is a maximally\n  consistent (with the theory) set of formulas in that type. -/\nstructure CompleteType where\n  toTheory : L[[α]].Theory\n  subset' : (L.lhomWithConstants α).onTheory T ⊆ toTheory\n  isMaximal' : toTheory.IsMaximal\n\n"}
{"name":"FirstOrder.Language.Theory.CompleteType.mk.sizeOf_spec","module":"Mathlib.ModelTheory.Types","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\ninst✝¹ : (a : L.Sentence) → SizeOf (T a)\ninst✝ : SizeOf α\ntoTheory : (L.withConstants α).Theory\nsubset' : HasSubset.Subset ((L.lhomWithConstants α).onTheory T) toTheory\nisMaximal' : toTheory.IsMaximal\n⊢ Eq (SizeOf.sizeOf { toTheory := toTheory, subset' := subset', isMaximal' := isMaximal' }) (HAdd.hAdd 1 (SizeOf.sizeOf isMaximal'))","decl":"/-- A complete type over a given theory in a certain type of variables is a maximally\n  consistent (with the theory) set of formulas in that type. -/\nstructure CompleteType where\n  toTheory : L[[α]].Theory\n  subset' : (L.lhomWithConstants α).onTheory T ⊆ toTheory\n  isMaximal' : toTheory.IsMaximal\n\n"}
{"name":"FirstOrder.Language.Theory.CompleteType.mk.inj","module":"Mathlib.ModelTheory.Types","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\ntoTheory✝ : (L.withConstants α).Theory\nsubset'✝ : HasSubset.Subset ((L.lhomWithConstants α).onTheory T) toTheory✝\nisMaximal'✝ : toTheory✝.IsMaximal\ntoTheory : (L.withConstants α).Theory\nsubset' : HasSubset.Subset ((L.lhomWithConstants α).onTheory T) toTheory\nisMaximal' : toTheory.IsMaximal\nx✝ : Eq { toTheory := toTheory✝, subset' := subset'✝, isMaximal' := isMaximal'✝ } { toTheory := toTheory, subset' := subset', isMaximal' := isMaximal' }\n⊢ Eq toTheory✝ toTheory","decl":"/-- A complete type over a given theory in a certain type of variables is a maximally\n  consistent (with the theory) set of formulas in that type. -/\nstructure CompleteType where\n  toTheory : L[[α]].Theory\n  subset' : (L.lhomWithConstants α).onTheory T ⊆ toTheory\n  isMaximal' : toTheory.IsMaximal\n\n"}
{"name":"FirstOrder.Language.Theory.CompleteType.mk.injEq","module":"Mathlib.ModelTheory.Types","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\ntoTheory✝ : (L.withConstants α).Theory\nsubset'✝ : HasSubset.Subset ((L.lhomWithConstants α).onTheory T) toTheory✝\nisMaximal'✝ : toTheory✝.IsMaximal\ntoTheory : (L.withConstants α).Theory\nsubset' : HasSubset.Subset ((L.lhomWithConstants α).onTheory T) toTheory\nisMaximal' : toTheory.IsMaximal\n⊢ Eq (Eq { toTheory := toTheory✝, subset' := subset'✝, isMaximal' := isMaximal'✝ } { toTheory := toTheory, subset' := subset', isMaximal' := isMaximal' }) (Eq toTheory✝ toTheory)","decl":"/-- A complete type over a given theory in a certain type of variables is a maximally\n  consistent (with the theory) set of formulas in that type. -/\nstructure CompleteType where\n  toTheory : L[[α]].Theory\n  subset' : (L.lhomWithConstants α).onTheory T ⊆ toTheory\n  isMaximal' : toTheory.IsMaximal\n\n"}
{"name":"FirstOrder.Language.Theory.CompleteType.isMaximal","module":"Mathlib.ModelTheory.Types","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\np : T.CompleteType α\n⊢ FirstOrder.Language.Theory.IsMaximal ↑p","decl":"theorem isMaximal (p : T.CompleteType α) : IsMaximal (p : L[[α]].Theory) :=\n  p.isMaximal'\n\n"}
{"name":"FirstOrder.Language.Theory.CompleteType.subset","module":"Mathlib.ModelTheory.Types","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\np : T.CompleteType α\n⊢ HasSubset.Subset ((L.lhomWithConstants α).onTheory T) ↑p","decl":"theorem subset (p : T.CompleteType α) : (L.lhomWithConstants α).onTheory T ⊆ (p : L[[α]].Theory) :=\n  p.subset'\n\n"}
{"name":"FirstOrder.Language.Theory.CompleteType.mem_or_not_mem","module":"Mathlib.ModelTheory.Types","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\np : T.CompleteType α\nφ : (L.withConstants α).Sentence\n⊢ Or (Membership.mem p φ) (Membership.mem p (FirstOrder.Language.Formula.not φ))","decl":"theorem mem_or_not_mem (p : T.CompleteType α) (φ : L[[α]].Sentence) : φ ∈ p ∨ φ.not ∈ p :=\n  p.isMaximal.mem_or_not_mem φ\n\n"}
{"name":"FirstOrder.Language.Theory.CompleteType.mem_of_models","module":"Mathlib.ModelTheory.Types","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\np : T.CompleteType α\nφ : (L.withConstants α).Sentence\nh : ((L.lhomWithConstants α).onTheory T).ModelsBoundedFormula φ\n⊢ Membership.mem p φ","decl":"theorem mem_of_models (p : T.CompleteType α) {φ : L[[α]].Sentence}\n    (h : (L.lhomWithConstants α).onTheory T ⊨ᵇ φ) : φ ∈ p :=\n  (p.mem_or_not_mem φ).resolve_right fun con =>\n    ((models_iff_not_satisfiable _).1 h)\n      (p.isMaximal.1.mono (union_subset p.subset (singleton_subset_iff.2 con)))\n\n"}
{"name":"FirstOrder.Language.Theory.CompleteType.not_mem_iff","module":"Mathlib.ModelTheory.Types","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\np : T.CompleteType α\nφ : (L.withConstants α).Sentence\n⊢ Iff (Membership.mem p (FirstOrder.Language.Formula.not φ)) (Not (Membership.mem p φ))","decl":"theorem not_mem_iff (p : T.CompleteType α) (φ : L[[α]].Sentence) : φ.not ∈ p ↔ ¬φ ∈ p :=\n  ⟨fun hf ht => by\n    have h : ¬IsSatisfiable ({φ, φ.not} : L[[α]].Theory) := by\n      rintro ⟨@⟨_, _, h, _⟩⟩\n      simp only [model_iff, mem_insert_iff, mem_singleton_iff, forall_eq_or_imp, forall_eq] at h\n      exact h.2 h.1\n    refine h (p.isMaximal.1.mono ?_)\n    rw [insert_subset_iff, singleton_subset_iff]\n    exact ⟨ht, hf⟩, (p.mem_or_not_mem φ).resolve_left⟩\n\n"}
{"name":"FirstOrder.Language.Theory.CompleteType.compl_setOf_mem","module":"Mathlib.ModelTheory.Types","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nφ : (L.withConstants α).Sentence\n⊢ Eq (HasCompl.compl (setOf fun p => Membership.mem p φ)) (setOf fun p => Membership.mem p (FirstOrder.Language.Formula.not φ))","decl":"@[simp]\ntheorem compl_setOf_mem {φ : L[[α]].Sentence} :\n    { p : T.CompleteType α | φ ∈ p }ᶜ = { p : T.CompleteType α | φ.not ∈ p } :=\n  ext fun _ => (not_mem_iff _ _).symm\n\n"}
{"name":"FirstOrder.Language.Theory.CompleteType.setOf_subset_eq_empty_iff","module":"Mathlib.ModelTheory.Types","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nS : (L.withConstants α).Theory\n⊢ Iff (Eq (setOf fun p => HasSubset.Subset S ↑p) EmptyCollection.emptyCollection) (Not (Union.union ((L.lhomWithConstants α).onTheory T) S).IsSatisfiable)","decl":"theorem setOf_subset_eq_empty_iff (S : L[[α]].Theory) :\n    { p : T.CompleteType α | S ⊆ ↑p } = ∅ ↔\n      ¬((L.lhomWithConstants α).onTheory T ∪ S).IsSatisfiable := by\n  rw [iff_not_comm, ← not_nonempty_iff_eq_empty, Classical.not_not, Set.Nonempty]\n  refine\n    ⟨fun h =>\n      ⟨⟨L[[α]].completeTheory h.some, (subset_union_left (t := S)).trans completeTheory.subset,\n          completeTheory.isMaximal (L[[α]]) h.some⟩,\n        (((L.lhomWithConstants α).onTheory T).subset_union_right).trans completeTheory.subset⟩,\n      ?_⟩\n  rintro ⟨p, hp⟩\n  exact p.isMaximal.1.mono (union_subset p.subset hp)\n\n"}
{"name":"FirstOrder.Language.Theory.CompleteType.setOf_mem_eq_univ_iff","module":"Mathlib.ModelTheory.Types","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nφ : (L.withConstants α).Sentence\n⊢ Iff (Eq (setOf fun p => Membership.mem p φ) Set.univ) (((L.lhomWithConstants α).onTheory T).ModelsBoundedFormula φ)","decl":"theorem setOf_mem_eq_univ_iff (φ : L[[α]].Sentence) :\n    { p : T.CompleteType α | φ ∈ p } = Set.univ ↔ (L.lhomWithConstants α).onTheory T ⊨ᵇ φ := by\n  rw [models_iff_not_satisfiable, ← compl_empty_iff, compl_setOf_mem, ← setOf_subset_eq_empty_iff]\n  simp\n\n"}
{"name":"FirstOrder.Language.Theory.CompleteType.setOf_subset_eq_univ_iff","module":"Mathlib.ModelTheory.Types","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nS : (L.withConstants α).Theory\n⊢ Iff (Eq (setOf fun p => HasSubset.Subset S ↑p) Set.univ) (∀ (φ : (L.withConstants α).Sentence), Membership.mem S φ → ((L.lhomWithConstants α).onTheory T).ModelsBoundedFormula φ)","decl":"theorem setOf_subset_eq_univ_iff (S : L[[α]].Theory) :\n    { p : T.CompleteType α | S ⊆ ↑p } = Set.univ ↔\n      ∀ φ, φ ∈ S → (L.lhomWithConstants α).onTheory T ⊨ᵇ φ := by\n  have h : { p : T.CompleteType α | S ⊆ ↑p } = ⋂₀ ((fun φ => { p | φ ∈ p }) '' S) := by\n    ext\n    simp [subset_def]\n  simp_rw [h, sInter_eq_univ, ← setOf_mem_eq_univ_iff]\n  refine ⟨fun h φ φS => h _ ⟨_, φS, rfl⟩, ?_⟩\n  rintro h _ ⟨φ, h1, rfl⟩\n  exact h _ h1\n\n"}
{"name":"FirstOrder.Language.Theory.CompleteType.nonempty_iff","module":"Mathlib.ModelTheory.Types","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\n⊢ Iff (Nonempty (T.CompleteType α)) T.IsSatisfiable","decl":"theorem nonempty_iff : Nonempty (T.CompleteType α) ↔ T.IsSatisfiable := by\n  rw [← isSatisfiable_onTheory_iff (lhomWithConstants_injective L α)]\n  rw [nonempty_iff_univ_nonempty, nonempty_iff_ne_empty, Ne, not_iff_comm,\n    ← union_empty ((L.lhomWithConstants α).onTheory T), ← setOf_subset_eq_empty_iff]\n  simp\n\n"}
{"name":"FirstOrder.Language.Theory.CompleteType.instNonempty","module":"Mathlib.ModelTheory.Types","initialProofState":"L : FirstOrder.Language\nα : Type w\n⊢ Nonempty (EmptyCollection.emptyCollection.CompleteType α)","decl":"instance instNonempty : Nonempty (CompleteType (∅ : L.Theory) α) :=\n  nonempty_iff.2 (isSatisfiable_empty L)\n\n"}
{"name":"FirstOrder.Language.Theory.CompleteType.iInter_setOf_subset","module":"Mathlib.ModelTheory.Types","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nι : Type u_1\nS : ι → (L.withConstants α).Theory\n⊢ Eq (Set.iInter fun i => setOf fun p => HasSubset.Subset (S i) ↑p) (setOf fun p => HasSubset.Subset (Set.iUnion fun i => S i) ↑p)","decl":"theorem iInter_setOf_subset {ι : Type*} (S : ι → L[[α]].Theory) :\n    ⋂ i : ι, { p : T.CompleteType α | S i ⊆ p } =\n      { p : T.CompleteType α | ⋃ i : ι, S i ⊆ p } := by\n  ext\n  simp only [mem_iInter, mem_setOf_eq, iUnion_subset_iff]\n\n"}
{"name":"FirstOrder.Language.Theory.CompleteType.toList_foldr_inf_mem","module":"Mathlib.ModelTheory.Types","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\np : T.CompleteType α\nt : Finset (L.withConstants α).Sentence\n⊢ Iff (Membership.mem p (List.foldr (fun x1 x2 => Min.min x1 x2) Top.top t.toList)) (HasSubset.Subset ↑t ↑p)","decl":"theorem toList_foldr_inf_mem {p : T.CompleteType α} {t : Finset (L[[α]]).Sentence} :\n    t.toList.foldr (· ⊓ ·) ⊤ ∈ p ↔ (t : L[[α]].Theory) ⊆ ↑p := by\n  simp_rw [subset_def, ← SetLike.mem_coe, p.isMaximal.mem_iff_models, models_sentence_iff,\n    Sentence.Realize, Formula.Realize, BoundedFormula.realize_foldr_inf, Finset.mem_toList]\n  exact ⟨fun h φ hφ M => h _ _ hφ, fun h M φ hφ => h _ hφ _⟩\n\n"}
{"name":"FirstOrder.Language.Theory.CompleteType.mem_typeOf","module":"Mathlib.ModelTheory.Types","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nM : Type w'\ninst✝² : L.Structure M\ninst✝¹ : Nonempty M\ninst✝ : FirstOrder.Language.Theory.Model M T\nv : α → M\nφ : (L.withConstants α).Sentence\n⊢ Iff (Membership.mem (T.typeOf v) φ) ((FirstOrder.Language.Formula.equivSentence.symm φ).Realize v)","decl":"@[simp]\ntheorem mem_typeOf {φ : L[[α]].Sentence} :\n    φ ∈ T.typeOf v ↔ (Formula.equivSentence.symm φ).Realize v :=\n  letI : (constantsOn α).Structure M := constantsOn.structure v\n  mem_completeTheory.trans (Formula.realize_equivSentence_symm _ _ _).symm\n\n"}
{"name":"FirstOrder.Language.Theory.CompleteType.formula_mem_typeOf","module":"Mathlib.ModelTheory.Types","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\nM : Type w'\ninst✝² : L.Structure M\ninst✝¹ : Nonempty M\ninst✝ : FirstOrder.Language.Theory.Model M T\nv : α → M\nφ : L.Formula α\n⊢ Iff (Membership.mem (T.typeOf v) (FirstOrder.Language.Formula.equivSentence φ)) (φ.Realize v)","decl":"theorem formula_mem_typeOf {φ : L.Formula α} :\n    Formula.equivSentence φ ∈ T.typeOf v ↔ φ.Realize v := by simp\n\n"}
{"name":"FirstOrder.Language.Theory.exists_modelType_is_realized_in","module":"Mathlib.ModelTheory.Types","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nα : Type w\np : T.CompleteType α\n⊢ Exists fun M => Membership.mem (T.realizedTypes (↑M) α) p","decl":"theorem exists_modelType_is_realized_in (p : T.CompleteType α) :\n    ∃ M : Theory.ModelType.{u, v, max u v w} T, p ∈ T.realizedTypes M α := by\n  obtain ⟨M⟩ := p.isMaximal.1\n  refine ⟨(M.subtheoryModel p.subset).reduct (L.lhomWithConstants α), fun a => (L.con a : M), ?_⟩\n  refine SetLike.ext fun φ => ?_\n  simp only [CompleteType.mem_typeOf]\n  refine\n    (@Formula.realize_equivSentence_symm_con _\n      ((M.subtheoryModel p.subset).reduct (L.lhomWithConstants α)) _ _ M.struc _ φ).trans\n      (_root_.trans (_root_.trans ?_ (p.isMaximal.isComplete.realize_sentence_iff φ M))\n        (p.isMaximal.mem_iff_models φ).symm)\n  rfl\n\n"}
