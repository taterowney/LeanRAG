{"name":"SimpleGraph.Dart.mk.inj","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\ntoProd✝ : Prod V V\nadj✝ : G.Adj toProd✝.1 toProd✝.2\ntoProd : Prod V V\nadj : G.Adj toProd.1 toProd.2\nx✝ : Eq { toProd := toProd✝, adj := adj✝ } { toProd := toProd, adj := adj }\n⊢ Eq toProd✝ toProd","decl":"/-- A `Dart` is an oriented edge, implemented as an ordered pair of adjacent vertices.\nThis terminology comes from combinatorial maps, and they are also known as \"half-edges\"\nor \"bonds.\" -/\nstructure Dart extends V × V where\n  adj : G.Adj fst snd\n  deriving DecidableEq\n\n"}
{"name":"SimpleGraph.Dart.mk.sizeOf_spec","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\ninst✝ : SizeOf V\ntoProd : Prod V V\nadj : G.Adj toProd.1 toProd.2\n⊢ Eq (SizeOf.sizeOf { toProd := toProd, adj := adj }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toProd)) (SizeOf.sizeOf adj))","decl":"/-- A `Dart` is an oriented edge, implemented as an ordered pair of adjacent vertices.\nThis terminology comes from combinatorial maps, and they are also known as \"half-edges\"\nor \"bonds.\" -/\nstructure Dart extends V × V where\n  adj : G.Adj fst snd\n  deriving DecidableEq\n\n"}
{"name":"SimpleGraph.Dart.adj","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\nself : G.Dart\n⊢ G.Adj self.toProd.1 self.toProd.2","decl":"/-- A `Dart` is an oriented edge, implemented as an ordered pair of adjacent vertices.\nThis terminology comes from combinatorial maps, and they are also known as \"half-edges\"\nor \"bonds.\" -/\nstructure Dart extends V × V where\n  adj : G.Adj fst snd\n  deriving DecidableEq\n\n"}
{"name":"SimpleGraph.Dart.mk.injEq","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\ntoProd✝ : Prod V V\nadj✝ : G.Adj toProd✝.1 toProd✝.2\ntoProd : Prod V V\nadj : G.Adj toProd.1 toProd.2\n⊢ Eq (Eq { toProd := toProd✝, adj := adj✝ } { toProd := toProd, adj := adj }) (Eq toProd✝ toProd)","decl":"/-- A `Dart` is an oriented edge, implemented as an ordered pair of adjacent vertices.\nThis terminology comes from combinatorial maps, and they are also known as \"half-edges\"\nor \"bonds.\" -/\nstructure Dart extends V × V where\n  adj : G.Adj fst snd\n  deriving DecidableEq\n\n"}
{"name":"SimpleGraph.Dart.ext_iff","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\nd₁ d₂ : G.Dart\n⊢ Iff (Eq d₁ d₂) (Eq d₁.toProd d₂.toProd)","decl":"theorem Dart.ext_iff (d₁ d₂ : G.Dart) : d₁ = d₂ ↔ d₁.toProd = d₂.toProd := by\n  cases d₁; cases d₂; simp\n\n"}
{"name":"SimpleGraph.Dart.ext","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\nd₁ d₂ : G.Dart\nh : Eq d₁.toProd d₂.toProd\n⊢ Eq d₁ d₂","decl":"@[ext]\ntheorem Dart.ext (d₁ d₂ : G.Dart) (h : d₁.toProd = d₂.toProd) : d₁ = d₂ :=\n  (Dart.ext_iff d₁ d₂).mpr h\n\n"}
{"name":"SimpleGraph.Dart.fst_ne_snd","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\nd : G.Dart\n⊢ Ne d.toProd.1 d.toProd.2","decl":"@[simp]\ntheorem Dart.fst_ne_snd (d : G.Dart) : d.fst ≠ d.snd :=\n  fun h ↦ G.irrefl (h ▸ d.adj)\n\n"}
{"name":"SimpleGraph.Dart.snd_ne_fst","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\nd : G.Dart\n⊢ Ne d.toProd.2 d.toProd.1","decl":"@[simp]\ntheorem Dart.snd_ne_fst (d : G.Dart) : d.snd ≠ d.fst :=\n  fun h ↦ G.irrefl (h ▸ d.adj)\n\n"}
{"name":"SimpleGraph.Dart.toProd_injective","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\n⊢ Function.Injective SimpleGraph.Dart.toProd","decl":"theorem Dart.toProd_injective : Function.Injective (Dart.toProd : G.Dart → V × V) :=\n  Dart.ext\n\n"}
{"name":"SimpleGraph.Dart.edge_mk","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\np : Prod V V\nh : G.Adj p.1 p.2\n⊢ Eq { toProd := p, adj := h }.edge (Sym2.mk p)","decl":"@[simp]\ntheorem Dart.edge_mk {p : V × V} (h : G.Adj p.1 p.2) : (Dart.mk p h).edge = Sym2.mk p :=\n  rfl\n\n"}
{"name":"SimpleGraph.Dart.edge_mem","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\nd : G.Dart\n⊢ Membership.mem G.edgeSet d.edge","decl":"@[simp]\ntheorem Dart.edge_mem (d : G.Dart) : d.edge ∈ G.edgeSet :=\n  d.adj\n\n"}
{"name":"SimpleGraph.Dart.symm_toProd","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\nd : G.Dart\n⊢ Eq d.symm.toProd d.swap","decl":"/-- The dart with reversed orientation from a given dart. -/\n@[simps]\ndef Dart.symm (d : G.Dart) : G.Dart :=\n  ⟨d.toProd.swap, G.symm d.adj⟩\n\n"}
{"name":"SimpleGraph.Dart.symm_mk","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\np : Prod V V\nh : G.Adj p.1 p.2\n⊢ Eq { toProd := p, adj := h }.symm { toProd := p.swap, adj := ⋯ }","decl":"@[simp]\ntheorem Dart.symm_mk {p : V × V} (h : G.Adj p.1 p.2) : (Dart.mk p h).symm = Dart.mk p.swap h.symm :=\n  rfl\n\n"}
{"name":"SimpleGraph.Dart.edge_symm","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\nd : G.Dart\n⊢ Eq d.symm.edge d.edge","decl":"@[simp]\ntheorem Dart.edge_symm (d : G.Dart) : d.symm.edge = d.edge :=\n  Sym2.mk_prod_swap_eq\n\n"}
{"name":"SimpleGraph.Dart.edge_comp_symm","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\n⊢ Eq (Function.comp SimpleGraph.Dart.edge SimpleGraph.Dart.symm) SimpleGraph.Dart.edge","decl":"@[simp]\ntheorem Dart.edge_comp_symm : Dart.edge ∘ Dart.symm = (Dart.edge : G.Dart → Sym2 V) :=\n  funext Dart.edge_symm\n\n"}
{"name":"SimpleGraph.Dart.symm_symm","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\nd : G.Dart\n⊢ Eq d.symm.symm d","decl":"@[simp]\ntheorem Dart.symm_symm (d : G.Dart) : d.symm.symm = d :=\n  Dart.ext _ _ <| Prod.swap_swap _\n\n"}
{"name":"SimpleGraph.Dart.symm_involutive","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\n⊢ Function.Involutive SimpleGraph.Dart.symm","decl":"@[simp]\ntheorem Dart.symm_involutive : Function.Involutive (Dart.symm : G.Dart → G.Dart) :=\n  Dart.symm_symm\n\n"}
{"name":"SimpleGraph.Dart.symm_ne","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\nd : G.Dart\n⊢ Ne d.symm d","decl":"theorem Dart.symm_ne (d : G.Dart) : d.symm ≠ d :=\n  ne_of_apply_ne (Prod.snd ∘ Dart.toProd) d.adj.ne\n\n"}
{"name":"SimpleGraph.dart_edge_eq_iff","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\nd₁ d₂ : G.Dart\n⊢ Iff (Eq d₁.edge d₂.edge) (Or (Eq d₁ d₂) (Eq d₁ d₂.symm))","decl":"theorem dart_edge_eq_iff : ∀ d₁ d₂ : G.Dart, d₁.edge = d₂.edge ↔ d₁ = d₂ ∨ d₁ = d₂.symm := by\n  rintro ⟨p, hp⟩ ⟨q, hq⟩\n  simp\n\n"}
{"name":"SimpleGraph.dart_edge_eq_mk'_iff","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\nd : G.Dart\np : Prod V V\n⊢ Iff (Eq d.edge (Sym2.mk p)) (Or (Eq d.toProd p) (Eq d.toProd p.swap))","decl":"theorem dart_edge_eq_mk'_iff :\n    ∀ {d : G.Dart} {p : V × V}, d.edge = Sym2.mk p ↔ d.toProd = p ∨ d.toProd = p.swap := by\n  rintro ⟨p, h⟩\n  apply Sym2.mk_eq_mk_iff\n\n"}
{"name":"SimpleGraph.dart_edge_eq_mk'_iff'","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\nd : G.Dart\nu v : V\n⊢ Iff (Eq d.edge (Sym2.mk { fst := u, snd := v })) (Or (And (Eq d.toProd.1 u) (Eq d.toProd.2 v)) (And (Eq d.toProd.1 v) (Eq d.toProd.2 u)))","decl":"theorem dart_edge_eq_mk'_iff' :\n    ∀ {d : G.Dart} {u v : V},\n      d.edge = s(u, v) ↔ d.fst = u ∧ d.snd = v ∨ d.fst = v ∧ d.snd = u := by\n  rintro ⟨⟨a, b⟩, h⟩ u v\n  rw [dart_edge_eq_mk'_iff]\n  simp\n\n"}
{"name":"SimpleGraph.dartOfNeighborSet_toProd","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\nw : ↑(G.neighborSet v)\n⊢ Eq (G.dartOfNeighborSet v w).toProd { fst := v, snd := ↑w }","decl":"/-- For a given vertex `v`, this is the bijective map from the neighbor set at `v`\nto the darts `d` with `d.fst = v`. -/\n@[simps]\ndef dartOfNeighborSet (v : V) (w : G.neighborSet v) : G.Dart :=\n  ⟨(v, w), w.property⟩\n\n"}
{"name":"SimpleGraph.dartOfNeighborSet_injective","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\n⊢ Function.Injective (G.dartOfNeighborSet v)","decl":"theorem dartOfNeighborSet_injective (v : V) : Function.Injective (G.dartOfNeighborSet v) :=\n  fun e₁ e₂ h =>\n  Subtype.ext <| by\n    injection h with h'\n    convert congr_arg Prod.snd h'\n\n"}
{"name":"SimpleGraph.nonempty_dart_top","module":"Mathlib.Combinatorics.SimpleGraph.Dart","initialProofState":"V : Type u_1\ninst✝ : Nontrivial V\n⊢ Nonempty Top.top.Dart","decl":"instance nonempty_dart_top [Nontrivial V] : Nonempty (⊤ : SimpleGraph V).Dart := by\n  obtain ⟨v, w, h⟩ := exists_pair_ne V\n  exact ⟨⟨(v, w), h⟩⟩\n\n"}
