{"name":"ModuleCat.instHasBinaryBiproducts","module":"Mathlib.Algebra.Category.ModuleCat.Biproducts","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ CategoryTheory.Limits.HasBinaryBiproducts (ModuleCat R)","decl":"instance : HasBinaryBiproducts (ModuleCat.{v} R) :=\n  HasBinaryBiproducts.of_hasBinaryProducts\n\n"}
{"name":"ModuleCat.instHasFiniteBiproducts","module":"Mathlib.Algebra.Category.ModuleCat.Biproducts","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ CategoryTheory.Limits.HasFiniteBiproducts (ModuleCat R)","decl":"instance : HasFiniteBiproducts (ModuleCat.{v} R) :=\n  HasFiniteBiproducts.of_hasFiniteProducts\n\n-- We now construct explicit limit data,\n-- so we can compare the biproducts to the usual unbundled constructions.\n"}
{"name":"ModuleCat.binaryProductLimitCone_cone_pt","module":"Mathlib.Algebra.Category.ModuleCat.Biproducts","initialProofState":"R : Type u\ninst✝ : Ring R\nM N : ModuleCat R\n⊢ Eq (M.binaryProductLimitCone N).cone.pt (ModuleCat.of R (Prod ↑M ↑N))","decl":"/-- Construct limit data for a binary product in `ModuleCat R`, using `ModuleCat.of R (M × N)`.\n-/\n@[simps cone_pt isLimit_lift]\ndef binaryProductLimitCone (M N : ModuleCat.{v} R) : Limits.LimitCone (pair M N) where\n  cone :=\n    { pt := ModuleCat.of R (M × N)\n      π :=\n        { app := fun j =>\n            Discrete.casesOn j fun j =>\n              WalkingPair.casesOn j (ofHom <| LinearMap.fst R M N) (ofHom <| LinearMap.snd R M N)\n          naturality := by rintro ⟨⟨⟩⟩ ⟨⟨⟩⟩ ⟨⟨⟨⟩⟩⟩ <;> rfl } }\n  isLimit :=\n    { lift := fun s => ofHom <| LinearMap.prod\n        (s.π.app ⟨WalkingPair.left⟩).hom\n        (s.π.app ⟨WalkingPair.right⟩).hom\n      fac := by rintro s (⟨⟩ | ⟨⟩) <;> rfl\n      uniq := fun s m w => by\n        simp_rw [← w ⟨WalkingPair.left⟩, ← w ⟨WalkingPair.right⟩]\n        rfl }\n\n"}
{"name":"ModuleCat.binaryProductLimitCone_isLimit_lift","module":"Mathlib.Algebra.Category.ModuleCat.Biproducts","initialProofState":"R : Type u\ninst✝ : Ring R\nM N : ModuleCat R\ns : CategoryTheory.Limits.Cone (CategoryTheory.Limits.pair M N)\n⊢ Eq ((M.binaryProductLimitCone N).isLimit.lift s) (ModuleCat.ofHom ((ModuleCat.Hom.hom (s.π.app { as := CategoryTheory.Limits.WalkingPair.left })).prod (ModuleCat.Hom.hom (s.π.app { as := CategoryTheory.Limits.WalkingPair.right }))))","decl":"/-- Construct limit data for a binary product in `ModuleCat R`, using `ModuleCat.of R (M × N)`.\n-/\n@[simps cone_pt isLimit_lift]\ndef binaryProductLimitCone (M N : ModuleCat.{v} R) : Limits.LimitCone (pair M N) where\n  cone :=\n    { pt := ModuleCat.of R (M × N)\n      π :=\n        { app := fun j =>\n            Discrete.casesOn j fun j =>\n              WalkingPair.casesOn j (ofHom <| LinearMap.fst R M N) (ofHom <| LinearMap.snd R M N)\n          naturality := by rintro ⟨⟨⟩⟩ ⟨⟨⟩⟩ ⟨⟨⟨⟩⟩⟩ <;> rfl } }\n  isLimit :=\n    { lift := fun s => ofHom <| LinearMap.prod\n        (s.π.app ⟨WalkingPair.left⟩).hom\n        (s.π.app ⟨WalkingPair.right⟩).hom\n      fac := by rintro s (⟨⟩ | ⟨⟩) <;> rfl\n      uniq := fun s m w => by\n        simp_rw [← w ⟨WalkingPair.left⟩, ← w ⟨WalkingPair.right⟩]\n        rfl }\n\n"}
{"name":"ModuleCat.binaryProductLimitCone_cone_π_app_left","module":"Mathlib.Algebra.Category.ModuleCat.Biproducts","initialProofState":"R : Type u\ninst✝ : Ring R\nM N : ModuleCat R\n⊢ Eq ((M.binaryProductLimitCone N).cone.π.app { as := CategoryTheory.Limits.WalkingPair.left }) (ModuleCat.ofHom (LinearMap.fst R ↑M ↑N))","decl":"@[simp]\ntheorem binaryProductLimitCone_cone_π_app_left (M N : ModuleCat.{v} R) :\n    (binaryProductLimitCone M N).cone.π.app ⟨WalkingPair.left⟩ = ofHom (LinearMap.fst R M N) :=\n  rfl\n\n"}
{"name":"ModuleCat.binaryProductLimitCone_cone_π_app_right","module":"Mathlib.Algebra.Category.ModuleCat.Biproducts","initialProofState":"R : Type u\ninst✝ : Ring R\nM N : ModuleCat R\n⊢ Eq ((M.binaryProductLimitCone N).cone.π.app { as := CategoryTheory.Limits.WalkingPair.right }) (ModuleCat.ofHom (LinearMap.snd R ↑M ↑N))","decl":"@[simp]\ntheorem binaryProductLimitCone_cone_π_app_right (M N : ModuleCat.{v} R) :\n    (binaryProductLimitCone M N).cone.π.app ⟨WalkingPair.right⟩ = ofHom (LinearMap.snd R M N) :=\n  rfl\n\n"}
{"name":"ModuleCat.biprodIsoProd_inv_comp_fst_apply","module":"Mathlib.Algebra.Category.ModuleCat.Biproducts","initialProofState":"R : Type u\ninst✝ : Ring R\nM N : ModuleCat R\nx : CategoryTheory.ToType (ModuleCat.of R (Prod ↑M ↑N))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom CategoryTheory.Limits.biprod.fst) ((CategoryTheory.ConcreteCategory.hom (M.biprodIsoProd N).inv) x)) x.1","decl":"@[simp, elementwise]\ntheorem biprodIsoProd_inv_comp_fst (M N : ModuleCat.{v} R) :\n    (biprodIsoProd M N).inv ≫ biprod.fst = ofHom (LinearMap.fst R M N) :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ (Discrete.mk WalkingPair.left)\n\n"}
{"name":"ModuleCat.biprodIsoProd_inv_comp_fst","module":"Mathlib.Algebra.Category.ModuleCat.Biproducts","initialProofState":"R : Type u\ninst✝ : Ring R\nM N : ModuleCat R\n⊢ Eq (CategoryTheory.CategoryStruct.comp (M.biprodIsoProd N).inv CategoryTheory.Limits.biprod.fst) (ModuleCat.ofHom (LinearMap.fst R ↑M ↑N))","decl":"@[simp, elementwise]\ntheorem biprodIsoProd_inv_comp_fst (M N : ModuleCat.{v} R) :\n    (biprodIsoProd M N).inv ≫ biprod.fst = ofHom (LinearMap.fst R M N) :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ (Discrete.mk WalkingPair.left)\n\n"}
{"name":"ModuleCat.biprodIsoProd_inv_comp_snd","module":"Mathlib.Algebra.Category.ModuleCat.Biproducts","initialProofState":"R : Type u\ninst✝ : Ring R\nM N : ModuleCat R\n⊢ Eq (CategoryTheory.CategoryStruct.comp (M.biprodIsoProd N).inv CategoryTheory.Limits.biprod.snd) (ModuleCat.ofHom (LinearMap.snd R ↑M ↑N))","decl":"@[simp, elementwise]\ntheorem biprodIsoProd_inv_comp_snd (M N : ModuleCat.{v} R) :\n    (biprodIsoProd M N).inv ≫ biprod.snd = ofHom (LinearMap.snd R M N) :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ (Discrete.mk WalkingPair.right)\n\n"}
{"name":"ModuleCat.biprodIsoProd_inv_comp_snd_apply","module":"Mathlib.Algebra.Category.ModuleCat.Biproducts","initialProofState":"R : Type u\ninst✝ : Ring R\nM N : ModuleCat R\nx : CategoryTheory.ToType (ModuleCat.of R (Prod ↑M ↑N))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom CategoryTheory.Limits.biprod.snd) ((CategoryTheory.ConcreteCategory.hom (M.biprodIsoProd N).inv) x)) x.2","decl":"@[simp, elementwise]\ntheorem biprodIsoProd_inv_comp_snd (M N : ModuleCat.{v} R) :\n    (biprodIsoProd M N).inv ≫ biprod.snd = ofHom (LinearMap.snd R M N) :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ (Discrete.mk WalkingPair.right)\n\n"}
{"name":"ModuleCat.HasLimit.lift_hom_apply","module":"Mathlib.Algebra.Category.ModuleCat.Biproducts","initialProofState":"R : Type u\ninst✝ : Ring R\nJ : Type w\nf : J → ModuleCat R\ns : CategoryTheory.Limits.Fan f\nx : ↑s.1\nj : J\n⊢ Eq ((ModuleCat.Hom.hom (ModuleCat.HasLimit.lift f s)) x j) ((CategoryTheory.ConcreteCategory.hom (s.π.app { as := j })) x)","decl":"/-- The map from an arbitrary cone over an indexed family of abelian groups\nto the cartesian product of those groups.\n-/\n@[simps!]\ndef lift (s : Fan f) : s.pt ⟶ ModuleCat.of R (∀ j, f j) :=\n  ofHom\n  { toFun := fun x j => s.π.app ⟨j⟩ x\n    map_add' := fun x y => by\n      simp only [Functor.const_obj_obj, map_add]\n      rfl\n    map_smul' := fun r x => by\n      simp only [Functor.const_obj_obj, map_smul]\n      rfl }\n\n"}
{"name":"ModuleCat.HasLimit.productLimitCone_isLimit_lift","module":"Mathlib.Algebra.Category.ModuleCat.Biproducts","initialProofState":"R : Type u\ninst✝ : Ring R\nJ : Type w\nf : J → ModuleCat R\ns : CategoryTheory.Limits.Fan f\n⊢ Eq ((ModuleCat.HasLimit.productLimitCone f).isLimit.lift s) (ModuleCat.HasLimit.lift f s)","decl":"/-- Construct limit data for a product in `ModuleCat R`, using `ModuleCat.of R (∀ j, F.obj j)`.\n-/\n@[simps]\ndef productLimitCone : Limits.LimitCone (Discrete.functor f) where\n  cone :=\n    { pt := ModuleCat.of R (∀ j, f j)\n      π := Discrete.natTrans fun j => ofHom (LinearMap.proj j.as : (∀ j, f j) →ₗ[R] f j.as) }\n  isLimit :=\n    { lift := lift.{_, v} f\n      fac := fun _ _ => rfl\n      uniq := fun s m w => by\n        ext x j\n        exact congr_arg (fun g : s.pt ⟶ f j => (g : s.pt → f j) x) (w ⟨j⟩) }\n\n"}
{"name":"ModuleCat.HasLimit.productLimitCone_cone_π","module":"Mathlib.Algebra.Category.ModuleCat.Biproducts","initialProofState":"R : Type u\ninst✝ : Ring R\nJ : Type w\nf : J → ModuleCat R\n⊢ Eq (ModuleCat.HasLimit.productLimitCone f).cone.π (CategoryTheory.Discrete.natTrans fun j => ModuleCat.ofHom (LinearMap.proj j.as))","decl":"/-- Construct limit data for a product in `ModuleCat R`, using `ModuleCat.of R (∀ j, F.obj j)`.\n-/\n@[simps]\ndef productLimitCone : Limits.LimitCone (Discrete.functor f) where\n  cone :=\n    { pt := ModuleCat.of R (∀ j, f j)\n      π := Discrete.natTrans fun j => ofHom (LinearMap.proj j.as : (∀ j, f j) →ₗ[R] f j.as) }\n  isLimit :=\n    { lift := lift.{_, v} f\n      fac := fun _ _ => rfl\n      uniq := fun s m w => by\n        ext x j\n        exact congr_arg (fun g : s.pt ⟶ f j => (g : s.pt → f j) x) (w ⟨j⟩) }\n\n"}
{"name":"ModuleCat.HasLimit.productLimitCone_cone_pt_isAddCommGroup","module":"Mathlib.Algebra.Category.ModuleCat.Biproducts","initialProofState":"R : Type u\ninst✝ : Ring R\nJ : Type w\nf : J → ModuleCat R\n⊢ Eq (ModuleCat.HasLimit.productLimitCone f).cone.pt.isAddCommGroup Pi.addCommGroup","decl":"/-- Construct limit data for a product in `ModuleCat R`, using `ModuleCat.of R (∀ j, F.obj j)`.\n-/\n@[simps]\ndef productLimitCone : Limits.LimitCone (Discrete.functor f) where\n  cone :=\n    { pt := ModuleCat.of R (∀ j, f j)\n      π := Discrete.natTrans fun j => ofHom (LinearMap.proj j.as : (∀ j, f j) →ₗ[R] f j.as) }\n  isLimit :=\n    { lift := lift.{_, v} f\n      fac := fun _ _ => rfl\n      uniq := fun s m w => by\n        ext x j\n        exact congr_arg (fun g : s.pt ⟶ f j => (g : s.pt → f j) x) (w ⟨j⟩) }\n\n"}
{"name":"ModuleCat.HasLimit.productLimitCone_cone_pt_isModule","module":"Mathlib.Algebra.Category.ModuleCat.Biproducts","initialProofState":"R : Type u\ninst✝ : Ring R\nJ : Type w\nf : J → ModuleCat R\n⊢ Eq (ModuleCat.HasLimit.productLimitCone f).cone.pt.isModule (Pi.module J (fun j => ↑(f j)) R)","decl":"/-- Construct limit data for a product in `ModuleCat R`, using `ModuleCat.of R (∀ j, F.obj j)`.\n-/\n@[simps]\ndef productLimitCone : Limits.LimitCone (Discrete.functor f) where\n  cone :=\n    { pt := ModuleCat.of R (∀ j, f j)\n      π := Discrete.natTrans fun j => ofHom (LinearMap.proj j.as : (∀ j, f j) →ₗ[R] f j.as) }\n  isLimit :=\n    { lift := lift.{_, v} f\n      fac := fun _ _ => rfl\n      uniq := fun s m w => by\n        ext x j\n        exact congr_arg (fun g : s.pt ⟶ f j => (g : s.pt → f j) x) (w ⟨j⟩) }\n\n"}
{"name":"ModuleCat.HasLimit.productLimitCone_cone_pt_carrier","module":"Mathlib.Algebra.Category.ModuleCat.Biproducts","initialProofState":"R : Type u\ninst✝ : Ring R\nJ : Type w\nf : J → ModuleCat R\n⊢ Eq (↑(ModuleCat.HasLimit.productLimitCone f).cone.pt) ((j : J) → ↑(f j))","decl":"/-- Construct limit data for a product in `ModuleCat R`, using `ModuleCat.of R (∀ j, F.obj j)`.\n-/\n@[simps]\ndef productLimitCone : Limits.LimitCone (Discrete.functor f) where\n  cone :=\n    { pt := ModuleCat.of R (∀ j, f j)\n      π := Discrete.natTrans fun j => ofHom (LinearMap.proj j.as : (∀ j, f j) →ₗ[R] f j.as) }\n  isLimit :=\n    { lift := lift.{_, v} f\n      fac := fun _ _ => rfl\n      uniq := fun s m w => by\n        ext x j\n        exact congr_arg (fun g : s.pt ⟶ f j => (g : s.pt → f j) x) (w ⟨j⟩) }\n\n"}
{"name":"ModuleCat.biproductIsoPi_inv_comp_π","module":"Mathlib.Algebra.Category.ModuleCat.Biproducts","initialProofState":"R : Type u\ninst✝¹ : Ring R\nJ : Type\ninst✝ : Finite J\nf : J → ModuleCat R\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (ModuleCat.biproductIsoPi f).inv (CategoryTheory.Limits.biproduct.π f j)) (ModuleCat.ofHom (LinearMap.proj j))","decl":"@[simp, elementwise]\ntheorem biproductIsoPi_inv_comp_π [Finite J] (f : J → ModuleCat.{v} R) (j : J) :\n    (biproductIsoPi f).inv ≫ biproduct.π f j = ofHom (LinearMap.proj j : (∀ j, f j) →ₗ[R] f j) :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ (Discrete.mk j)\n\n"}
{"name":"ModuleCat.biproductIsoPi_inv_comp_π_apply","module":"Mathlib.Algebra.Category.ModuleCat.Biproducts","initialProofState":"R : Type u\ninst✝¹ : Ring R\nJ : Type\ninst✝ : Finite J\nf : J → ModuleCat R\nj : J\nx : CategoryTheory.ToType (ModuleCat.of R ((j : J) → ↑(f j)))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.Limits.biproduct.π f j)) ((CategoryTheory.ConcreteCategory.hom (ModuleCat.biproductIsoPi f).inv) x)) (x j)","decl":"@[simp, elementwise]\ntheorem biproductIsoPi_inv_comp_π [Finite J] (f : J → ModuleCat.{v} R) (j : J) :\n    (biproductIsoPi f).inv ≫ biproduct.π f j = ofHom (LinearMap.proj j : (∀ j, f j) →ₗ[R] f j) :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ (Discrete.mk j)\n\n"}
