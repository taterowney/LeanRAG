{"name":"CategoryTheory.Functor.IsLocalization.isEquivalence","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nself : L.IsLocalization W\n‚ä¢ (CategoryTheory.Localization.Construction.lift L ‚ãØ).IsEquivalence","decl":"/-- The predicate expressing that, up to equivalence, a functor `L : C ‚•§ D`\nidentifies the category `D` with the localized category of `C` with respect\nto `W : MorphismProperty C`. -/\nclass IsLocalization : Prop where\n  /-- the functor inverts the given `MorphismProperty` -/\n  inverts : W.IsInvertedBy L\n  /-- the induced functor from the constructed localized category is an equivalence -/\n  isEquivalence : IsEquivalence (Localization.Construction.lift L inverts)\n\n"}
{"name":"CategoryTheory.Functor.IsLocalization.inverts","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nself : L.IsLocalization W\n‚ä¢ W.IsInvertedBy L","decl":"/-- The predicate expressing that, up to equivalence, a functor `L : C ‚•§ D`\nidentifies the category `D` with the localized category of `C` with respect\nto `W : MorphismProperty C`. -/\nclass IsLocalization : Prop where\n  /-- the functor inverts the given `MorphismProperty` -/\n  inverts : W.IsInvertedBy L\n  /-- the induced functor from the constructed localized category is an equivalence -/\n  isEquivalence : IsEquivalence (Localization.Construction.lift L inverts)\n\n"}
{"name":"CategoryTheory.Functor.q_isLocalization","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_4, u_1} C\nW : CategoryTheory.MorphismProperty C\n‚ä¢ W.Q.IsLocalization W","decl":"instance q_isLocalization : W.Q.IsLocalization W where\n  inverts := W.Q_inverts\n  isEquivalence := by\n    suffices Localization.Construction.lift W.Q W.Q_inverts = ùü≠ _ by\n      rw [this]\n      infer_instance\n    apply Localization.Construction.uniq\n    simp only [Localization.Construction.fac]\n    rfl\n\n"}
{"name":"CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.uniq","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} E\nself : CategoryTheory.Localization.StrictUniversalPropertyFixedTarget L W E\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor D E\nx‚úù : Eq (L.comp F‚ÇÅ) (L.comp F‚ÇÇ)\n‚ä¢ Eq F‚ÇÅ F‚ÇÇ","decl":"/-- This universal property states that a functor `L : C ‚•§ D` inverts morphisms\nin `W` and the all functors `D ‚•§ E` (for a fixed category `E`) uniquely factors\nthrough `L`. -/\nstructure StrictUniversalPropertyFixedTarget where\n  /-- the functor `L` inverts `W` -/\n  inverts : W.IsInvertedBy L\n  /-- any functor `C ‚•§ E` which inverts `W` can be lifted as a functor `D ‚•§ E`  -/\n  lift : ‚àÄ (F : C ‚•§ E) (_ : W.IsInvertedBy F), D ‚•§ E\n  /-- there is a factorisation involving the lifted functor  -/\n  fac : ‚àÄ (F : C ‚•§ E) (hF : W.IsInvertedBy F), L ‚ãô lift F hF = F\n  /-- uniqueness of the lifted functor -/\n  uniq : ‚àÄ (F‚ÇÅ F‚ÇÇ : D ‚•§ E) (_ : L ‚ãô F‚ÇÅ = L ‚ãô F‚ÇÇ), F‚ÇÅ = F‚ÇÇ\n\n"}
{"name":"CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.fac","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} E\nself : CategoryTheory.Localization.StrictUniversalPropertyFixedTarget L W E\nF : CategoryTheory.Functor C E\nhF : W.IsInvertedBy F\n‚ä¢ Eq (L.comp (self.lift F hF)) F","decl":"/-- This universal property states that a functor `L : C ‚•§ D` inverts morphisms\nin `W` and the all functors `D ‚•§ E` (for a fixed category `E`) uniquely factors\nthrough `L`. -/\nstructure StrictUniversalPropertyFixedTarget where\n  /-- the functor `L` inverts `W` -/\n  inverts : W.IsInvertedBy L\n  /-- any functor `C ‚•§ E` which inverts `W` can be lifted as a functor `D ‚•§ E`  -/\n  lift : ‚àÄ (F : C ‚•§ E) (_ : W.IsInvertedBy F), D ‚•§ E\n  /-- there is a factorisation involving the lifted functor  -/\n  fac : ‚àÄ (F : C ‚•§ E) (hF : W.IsInvertedBy F), L ‚ãô lift F hF = F\n  /-- uniqueness of the lifted functor -/\n  uniq : ‚àÄ (F‚ÇÅ F‚ÇÇ : D ‚•§ E) (_ : L ‚ãô F‚ÇÅ = L ‚ãô F‚ÇÇ), F‚ÇÅ = F‚ÇÇ\n\n"}
{"name":"CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.mk.inj","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} E\ninverts‚úù : W.IsInvertedBy L\nlift‚úù : (F : CategoryTheory.Functor C E) ‚Üí W.IsInvertedBy F ‚Üí CategoryTheory.Functor D E\nfac‚úù : ‚àÄ (F : CategoryTheory.Functor C E) (hF : W.IsInvertedBy F), Eq (L.comp (lift‚úù F hF)) F\nuniq‚úù : ‚àÄ (F‚ÇÅ F‚ÇÇ : CategoryTheory.Functor D E), Eq (L.comp F‚ÇÅ) (L.comp F‚ÇÇ) ‚Üí Eq F‚ÇÅ F‚ÇÇ\ninverts : W.IsInvertedBy L\nlift : (F : CategoryTheory.Functor C E) ‚Üí W.IsInvertedBy F ‚Üí CategoryTheory.Functor D E\nfac : ‚àÄ (F : CategoryTheory.Functor C E) (hF : W.IsInvertedBy F), Eq (L.comp (lift F hF)) F\nuniq : ‚àÄ (F‚ÇÅ F‚ÇÇ : CategoryTheory.Functor D E), Eq (L.comp F‚ÇÅ) (L.comp F‚ÇÇ) ‚Üí Eq F‚ÇÅ F‚ÇÇ\nx‚úù : Eq { inverts := inverts‚úù, lift := lift‚úù, fac := fac‚úù, uniq := uniq‚úù } { inverts := inverts, lift := lift, fac := fac, uniq := uniq }\n‚ä¢ Eq lift‚úù lift","decl":"/-- This universal property states that a functor `L : C ‚•§ D` inverts morphisms\nin `W` and the all functors `D ‚•§ E` (for a fixed category `E`) uniquely factors\nthrough `L`. -/\nstructure StrictUniversalPropertyFixedTarget where\n  /-- the functor `L` inverts `W` -/\n  inverts : W.IsInvertedBy L\n  /-- any functor `C ‚•§ E` which inverts `W` can be lifted as a functor `D ‚•§ E`  -/\n  lift : ‚àÄ (F : C ‚•§ E) (_ : W.IsInvertedBy F), D ‚•§ E\n  /-- there is a factorisation involving the lifted functor  -/\n  fac : ‚àÄ (F : C ‚•§ E) (hF : W.IsInvertedBy F), L ‚ãô lift F hF = F\n  /-- uniqueness of the lifted functor -/\n  uniq : ‚àÄ (F‚ÇÅ F‚ÇÇ : D ‚•§ E) (_ : L ‚ãô F‚ÇÅ = L ‚ãô F‚ÇÇ), F‚ÇÅ = F‚ÇÇ\n\n"}
{"name":"CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.mk.injEq","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} E\ninverts‚úù : W.IsInvertedBy L\nlift‚úù : (F : CategoryTheory.Functor C E) ‚Üí W.IsInvertedBy F ‚Üí CategoryTheory.Functor D E\nfac‚úù : ‚àÄ (F : CategoryTheory.Functor C E) (hF : W.IsInvertedBy F), Eq (L.comp (lift‚úù F hF)) F\nuniq‚úù : ‚àÄ (F‚ÇÅ F‚ÇÇ : CategoryTheory.Functor D E), Eq (L.comp F‚ÇÅ) (L.comp F‚ÇÇ) ‚Üí Eq F‚ÇÅ F‚ÇÇ\ninverts : W.IsInvertedBy L\nlift : (F : CategoryTheory.Functor C E) ‚Üí W.IsInvertedBy F ‚Üí CategoryTheory.Functor D E\nfac : ‚àÄ (F : CategoryTheory.Functor C E) (hF : W.IsInvertedBy F), Eq (L.comp (lift F hF)) F\nuniq : ‚àÄ (F‚ÇÅ F‚ÇÇ : CategoryTheory.Functor D E), Eq (L.comp F‚ÇÅ) (L.comp F‚ÇÇ) ‚Üí Eq F‚ÇÅ F‚ÇÇ\n‚ä¢ Eq (Eq { inverts := inverts‚úù, lift := lift‚úù, fac := fac‚úù, uniq := uniq‚úù } { inverts := inverts, lift := lift, fac := fac, uniq := uniq }) (Eq lift‚úù lift)","decl":"/-- This universal property states that a functor `L : C ‚•§ D` inverts morphisms\nin `W` and the all functors `D ‚•§ E` (for a fixed category `E`) uniquely factors\nthrough `L`. -/\nstructure StrictUniversalPropertyFixedTarget where\n  /-- the functor `L` inverts `W` -/\n  inverts : W.IsInvertedBy L\n  /-- any functor `C ‚•§ E` which inverts `W` can be lifted as a functor `D ‚•§ E`  -/\n  lift : ‚àÄ (F : C ‚•§ E) (_ : W.IsInvertedBy F), D ‚•§ E\n  /-- there is a factorisation involving the lifted functor  -/\n  fac : ‚àÄ (F : C ‚•§ E) (hF : W.IsInvertedBy F), L ‚ãô lift F hF = F\n  /-- uniqueness of the lifted functor -/\n  uniq : ‚àÄ (F‚ÇÅ F‚ÇÇ : D ‚•§ E) (_ : L ‚ãô F‚ÇÅ = L ‚ãô F‚ÇÇ), F‚ÇÅ = F‚ÇÇ\n\n"}
{"name":"CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.inverts","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} E\nself : CategoryTheory.Localization.StrictUniversalPropertyFixedTarget L W E\n‚ä¢ W.IsInvertedBy L","decl":"/-- This universal property states that a functor `L : C ‚•§ D` inverts morphisms\nin `W` and the all functors `D ‚•§ E` (for a fixed category `E`) uniquely factors\nthrough `L`. -/\nstructure StrictUniversalPropertyFixedTarget where\n  /-- the functor `L` inverts `W` -/\n  inverts : W.IsInvertedBy L\n  /-- any functor `C ‚•§ E` which inverts `W` can be lifted as a functor `D ‚•§ E`  -/\n  lift : ‚àÄ (F : C ‚•§ E) (_ : W.IsInvertedBy F), D ‚•§ E\n  /-- there is a factorisation involving the lifted functor  -/\n  fac : ‚àÄ (F : C ‚•§ E) (hF : W.IsInvertedBy F), L ‚ãô lift F hF = F\n  /-- uniqueness of the lifted functor -/\n  uniq : ‚àÄ (F‚ÇÅ F‚ÇÇ : D ‚•§ E) (_ : L ‚ãô F‚ÇÅ = L ‚ãô F‚ÇÇ), F‚ÇÅ = F‚ÇÇ\n\n"}
{"name":"CategoryTheory.Localization.StrictUniversalPropertyFixedTarget.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_3} E\ninst‚úù¬≥ : SizeOf C\ninst‚úù¬≤ : SizeOf D\ninst‚úù¬π : ‚¶ÉX Y : C‚¶Ñ ‚Üí (x : Quiver.Hom X Y) ‚Üí SizeOf (W x)\ninst‚úù : SizeOf E\ninverts : W.IsInvertedBy L\nlift : (F : CategoryTheory.Functor C E) ‚Üí W.IsInvertedBy F ‚Üí CategoryTheory.Functor D E\nfac : ‚àÄ (F : CategoryTheory.Functor C E) (hF : W.IsInvertedBy F), Eq (L.comp (lift F hF)) F\nuniq : ‚àÄ (F‚ÇÅ F‚ÇÇ : CategoryTheory.Functor D E), Eq (L.comp F‚ÇÅ) (L.comp F‚ÇÇ) ‚Üí Eq F‚ÇÅ F‚ÇÇ\n‚ä¢ Eq (SizeOf.sizeOf { inverts := inverts, lift := lift, fac := fac, uniq := uniq }) 1","decl":"/-- This universal property states that a functor `L : C ‚•§ D` inverts morphisms\nin `W` and the all functors `D ‚•§ E` (for a fixed category `E`) uniquely factors\nthrough `L`. -/\nstructure StrictUniversalPropertyFixedTarget where\n  /-- the functor `L` inverts `W` -/\n  inverts : W.IsInvertedBy L\n  /-- any functor `C ‚•§ E` which inverts `W` can be lifted as a functor `D ‚•§ E`  -/\n  lift : ‚àÄ (F : C ‚•§ E) (_ : W.IsInvertedBy F), D ‚•§ E\n  /-- there is a factorisation involving the lifted functor  -/\n  fac : ‚àÄ (F : C ‚•§ E) (hF : W.IsInvertedBy F), L ‚ãô lift F hF = F\n  /-- uniqueness of the lifted functor -/\n  uniq : ‚àÄ (F‚ÇÅ F‚ÇÇ : D ‚•§ E) (_ : L ‚ãô F‚ÇÅ = L ‚ãô F‚ÇÇ), F‚ÇÅ = F‚ÇÇ\n\n"}
{"name":"CategoryTheory.Localization.strictUniversalPropertyFixedTargetQ_lift","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù : CategoryTheory.Category.{u_5, u_3} E\nG : CategoryTheory.Functor C E\nhG : W.IsInvertedBy G\n‚ä¢ Eq ((CategoryTheory.Localization.strictUniversalPropertyFixedTargetQ W E).lift G hG) (CategoryTheory.Localization.Construction.lift G hG)","decl":"/-- The localized category `W.Localization` that was constructed satisfies\nthe universal property of the localization. -/\n@[simps]\ndef strictUniversalPropertyFixedTargetQ : StrictUniversalPropertyFixedTarget W.Q W E where\n  inverts := W.Q_inverts\n  lift := Construction.lift\n  fac := Construction.fac\n  uniq := Construction.uniq\n\n"}
{"name":"CategoryTheory.Localization.strictUniversalPropertyFixedTargetId_lift","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù : CategoryTheory.Category.{u_5, u_3} E\nhW : LE.le W (CategoryTheory.MorphismProperty.isomorphisms C)\nF : CategoryTheory.Functor C E\nx‚úù : W.IsInvertedBy F\n‚ä¢ Eq ((CategoryTheory.Localization.strictUniversalPropertyFixedTargetId W E hW).lift F x‚úù) F","decl":"/-- When `W` consists of isomorphisms, the identity satisfies the universal property\nof the localization. -/\n@[simps]\ndef strictUniversalPropertyFixedTargetId (hW : W ‚â§ MorphismProperty.isomorphisms C) :\n    StrictUniversalPropertyFixedTarget (ùü≠ C) W E where\n  inverts _ _ f hf := hW f hf\n  lift F _ := F\n  fac F hF := by\n    cases F\n    rfl\n  uniq F‚ÇÅ F‚ÇÇ eq := by\n    cases F‚ÇÅ\n    cases F‚ÇÇ\n    exact eq\n\n"}
{"name":"CategoryTheory.Functor.IsLocalization.mk'","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nh‚ÇÅ : CategoryTheory.Localization.StrictUniversalPropertyFixedTarget L W D\nh‚ÇÇ : CategoryTheory.Localization.StrictUniversalPropertyFixedTarget L W W.Localization\n‚ä¢ L.IsLocalization W","decl":"theorem IsLocalization.mk' (h‚ÇÅ : Localization.StrictUniversalPropertyFixedTarget L W D)\n    (h‚ÇÇ : Localization.StrictUniversalPropertyFixedTarget L W W.Localization) :\n    IsLocalization L W :=\n  { inverts := h‚ÇÅ.inverts\n    isEquivalence := IsEquivalence.mk' (h‚ÇÇ.lift W.Q W.Q_inverts)\n      (eqToIso (Localization.Construction.uniq _ _ (by\n        simp only [‚Üê Functor.assoc, Localization.Construction.fac, h‚ÇÇ.fac, Functor.comp_id])))\n      (eqToIso (h‚ÇÅ.uniq _ _ (by\n        simp only [‚Üê Functor.assoc, h‚ÇÇ.fac, Localization.Construction.fac, Functor.comp_id]))) }\n\n"}
{"name":"CategoryTheory.Functor.IsLocalization.for_id","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_4, u_1} C\nW : CategoryTheory.MorphismProperty C\nhW : LE.le W (CategoryTheory.MorphismProperty.isomorphisms C)\n‚ä¢ (CategoryTheory.Functor.id C).IsLocalization W","decl":"theorem IsLocalization.for_id (hW : W ‚â§ MorphismProperty.isomorphisms C) : (ùü≠ C).IsLocalization W :=\n  IsLocalization.mk' _ _ (Localization.strictUniversalPropertyFixedTargetId W _ hW)\n    (Localization.strictUniversalPropertyFixedTargetId W _ hW)\n\n"}
{"name":"CategoryTheory.Localization.inverts","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst‚úù : L.IsLocalization W\n‚ä¢ W.IsInvertedBy L","decl":"theorem inverts : W.IsInvertedBy L :=\n  (inferInstance : L.IsLocalization W).inverts\n\n"}
{"name":"CategoryTheory.Localization.isoOfHom_hom","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst‚úù : L.IsLocalization W\nX Y : C\nf : Quiver.Hom X Y\nhf : W f\n‚ä¢ Eq (CategoryTheory.Localization.isoOfHom L W f hf).hom (L.map f)","decl":"/-- The isomorphism `L.obj X ‚âÖ L.obj Y` that is deduced from a morphism `f : X ‚ü∂ Y` which\nbelongs to `W`, when `L.IsLocalization W`. -/\n@[simps! hom]\ndef isoOfHom {X Y : C} (f : X ‚ü∂ Y) (hf : W f) : L.obj X ‚âÖ L.obj Y :=\n  haveI : IsIso (L.map f) := inverts L W f hf\n  asIso (L.map f)\n\n"}
{"name":"CategoryTheory.Localization.isoOfHom_hom_inv_id","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst‚úù : L.IsLocalization W\nX Y : C\nf : Quiver.Hom X Y\nhf : W f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (L.map f) (CategoryTheory.Localization.isoOfHom L W f hf).inv) (CategoryTheory.CategoryStruct.id (L.obj X))","decl":"@[reassoc (attr := simp)]\nlemma isoOfHom_hom_inv_id {X Y : C} (f : X ‚ü∂ Y) (hf : W f) :\n    L.map f ‚â´ (isoOfHom L W f hf).inv = ùüô _ :=\n  (isoOfHom L W f hf).hom_inv_id\n\n"}
{"name":"CategoryTheory.Localization.isoOfHom_hom_inv_id_assoc","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst‚úù : L.IsLocalization W\nX Y : C\nf : Quiver.Hom X Y\nhf : W f\nZ : D\nh : Quiver.Hom (L.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (L.map f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.isoOfHom L W f hf).inv h)) h","decl":"@[reassoc (attr := simp)]\nlemma isoOfHom_hom_inv_id {X Y : C} (f : X ‚ü∂ Y) (hf : W f) :\n    L.map f ‚â´ (isoOfHom L W f hf).inv = ùüô _ :=\n  (isoOfHom L W f hf).hom_inv_id\n\n"}
{"name":"CategoryTheory.Localization.isoOfHom_inv_hom_id_assoc","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst‚úù : L.IsLocalization W\nX Y : C\nf : Quiver.Hom X Y\nhf : W f\nZ : D\nh : Quiver.Hom (L.obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.isoOfHom L W f hf).inv (CategoryTheory.CategoryStruct.comp (L.map f) h)) h","decl":"@[reassoc (attr := simp)]\nlemma isoOfHom_inv_hom_id {X Y : C} (f : X ‚ü∂ Y) (hf : W f) :\n    (isoOfHom L W f hf).inv ‚â´ L.map f = ùüô _ :=\n  (isoOfHom L W f hf).inv_hom_id\n\n"}
{"name":"CategoryTheory.Localization.isoOfHom_inv_hom_id","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst‚úù : L.IsLocalization W\nX Y : C\nf : Quiver.Hom X Y\nhf : W f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.isoOfHom L W f hf).inv (L.map f)) (CategoryTheory.CategoryStruct.id (L.obj Y))","decl":"@[reassoc (attr := simp)]\nlemma isoOfHom_inv_hom_id {X Y : C} (f : X ‚ü∂ Y) (hf : W f) :\n    (isoOfHom L W f hf).inv ‚â´ L.map f = ùüô _ :=\n  (isoOfHom L W f hf).inv_hom_id\n\n"}
{"name":"CategoryTheory.Localization.isoOfHom_id_inv","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst‚úù : L.IsLocalization W\nX : C\nhX : W (CategoryTheory.CategoryStruct.id X)\n‚ä¢ Eq (CategoryTheory.Localization.isoOfHom L W (CategoryTheory.CategoryStruct.id X) hX).inv (CategoryTheory.CategoryStruct.id (L.obj X))","decl":"@[simp]\nlemma isoOfHom_id_inv (X : C) (hX : W (ùüô X)) :\n    (isoOfHom L W (ùüô X) hX).inv = ùüô _ := by\n  rw [‚Üê cancel_mono (isoOfHom L W (ùüô X) hX).hom, Iso.inv_hom_id, id_comp,\n    isoOfHom_hom, Functor.map_id]\n\n"}
{"name":"CategoryTheory.Localization.Construction.wIso_eq_isoOfHom","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_4, u_1} C\nW : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\nhf : W f\n‚ä¢ Eq (CategoryTheory.Localization.Construction.wIso f hf) (CategoryTheory.Localization.isoOfHom W.Q W f hf)","decl":"lemma Construction.wIso_eq_isoOfHom {X Y : C} (f : X ‚ü∂ Y) (hf : W f) :\n    Construction.wIso f hf = isoOfHom W.Q W f hf := by ext; rfl\n\n"}
{"name":"CategoryTheory.Localization.Construction.wInv_eq_isoOfHom_inv","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_4, u_1} C\nW : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\nhf : W f\n‚ä¢ Eq (CategoryTheory.Localization.Construction.wInv f hf) (CategoryTheory.Localization.isoOfHom W.Q W f hf).inv","decl":"lemma Construction.wInv_eq_isoOfHom_inv {X Y : C} (f : X ‚ü∂ Y) (hf : W f) :\n    Construction.wInv f hf = (isoOfHom W.Q W f hf).inv :=\n  congr_arg Iso.inv (wIso_eq_isoOfHom f hf)\n\n"}
{"name":"CategoryTheory.Localization.instIsEquivalenceLocalizationLift","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst‚úù : L.IsLocalization W\n‚ä¢ (CategoryTheory.Localization.Construction.lift L ‚ãØ).IsEquivalence","decl":"instance : (Localization.Construction.lift L (inverts L W)).IsEquivalence :=\n  (inferInstance : L.IsLocalization W).isEquivalence\n\n"}
{"name":"CategoryTheory.Localization.essSurj","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst‚úù : L.IsLocalization W\n‚ä¢ L.EssSurj","decl":"theorem essSurj (W) [L.IsLocalization W] : L.EssSurj :=\n  ‚ü®fun X =>\n    ‚ü®(Construction.objEquiv W).invFun ((equivalenceFromModel L W).inverse.obj X),\n      Nonempty.intro\n        ((qCompEquivalenceFromModelFunctorIso L W).symm.app _ ‚â™‚â´\n          (equivalenceFromModel L W).counitIso.app X)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Localization.instIsEquivalenceFunctorFunctorsInvertingWhiskeringLeftFunctor","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_3} E\ninst‚úù : L.IsLocalization W\n‚ä¢ (CategoryTheory.Localization.whiskeringLeftFunctor L W E).IsEquivalence","decl":"instance : (whiskeringLeftFunctor L W E).IsEquivalence := by\n  let iso : (whiskeringLeft (MorphismProperty.Localization W) D E).obj\n    (equivalenceFromModel L W).functor ‚ãô\n      (Construction.whiskeringLeftEquivalence W E).functor ‚âÖ whiskeringLeftFunctor L W E :=\n    NatIso.ofComponents (fun F => eqToIso (by\n      ext\n      change (W.Q ‚ãô Localization.Construction.lift L (inverts L W)) ‚ãô F = L ‚ãô F\n      rw [Construction.fac])) (fun œÑ => by\n        ext\n        dsimp [Construction.whiskeringLeftEquivalence, equivalenceFromModel, whiskerLeft]\n        erw [NatTrans.comp_app, NatTrans.comp_app, eqToHom_app, eqToHom_app, eqToHom_refl,\n          eqToHom_refl, comp_id, id_comp]\n        ¬∑ rfl\n        all_goals\n          change (W.Q ‚ãô Localization.Construction.lift L (inverts L W)) ‚ãô _ = L ‚ãô _\n          rw [Construction.fac])\n  exact Functor.isEquivalence_of_iso iso\n\n"}
{"name":"CategoryTheory.Localization.whiskeringLeftFunctor'_eq","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} E\ninst‚úù : L.IsLocalization W\n‚ä¢ Eq (CategoryTheory.Localization.whiskeringLeftFunctor' L W E) ((CategoryTheory.Localization.whiskeringLeftFunctor L W E).comp (CategoryTheory.inducedFunctor CategoryTheory.FullSubcategory.obj))","decl":"theorem whiskeringLeftFunctor'_eq :\n    whiskeringLeftFunctor' L W E = Localization.whiskeringLeftFunctor L W E ‚ãô inducedFunctor _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Localization.whiskeringLeftFunctor'_obj","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} E\ninst‚úù : L.IsLocalization W\nF : CategoryTheory.Functor D E\n‚ä¢ Eq ((CategoryTheory.Localization.whiskeringLeftFunctor' L W E).obj F) (L.comp F)","decl":"variable {E} in\n@[simp]\ntheorem whiskeringLeftFunctor'_obj (F : D ‚•§ E) : (whiskeringLeftFunctor' L W E).obj F = L ‚ãô F :=\n  rfl\n\n"}
{"name":"CategoryTheory.Localization.instFullFunctorWhiskeringLeftFunctor'","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_3} E\ninst‚úù : L.IsLocalization W\n‚ä¢ (CategoryTheory.Localization.whiskeringLeftFunctor' L W E).Full","decl":"instance : (whiskeringLeftFunctor' L W E).Full := by\n  rw [whiskeringLeftFunctor'_eq]\n  apply @Functor.Full.comp _ _ _ _ _ _ _ _ ?_ ?_\n  ¬∑ infer_instance\n  apply InducedCategory.full -- why is it not found automatically ???\n\n"}
{"name":"CategoryTheory.Localization.instFaithfulFunctorWhiskeringLeftFunctor'","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_3} E\ninst‚úù : L.IsLocalization W\n‚ä¢ (CategoryTheory.Localization.whiskeringLeftFunctor' L W E).Faithful","decl":"instance : (whiskeringLeftFunctor' L W E).Faithful := by\n  rw [whiskeringLeftFunctor'_eq]\n  apply @Functor.Faithful.comp _ _ _ _ _ _ _ _ ?_ ?_\n  ¬∑ infer_instance\n  apply InducedCategory.faithful -- why is it not found automatically ???\n\n"}
{"name":"CategoryTheory.Localization.full_whiskeringLeft","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst‚úù¬π : L.IsLocalization W\nE : Type u_4\ninst‚úù : CategoryTheory.Category.{u_7, u_4} E\n‚ä¢ ((CategoryTheory.whiskeringLeft C D E).obj L).Full","decl":"lemma full_whiskeringLeft (L : C ‚•§ D) (W) [L.IsLocalization W] (E : Type*) [Category E] :\n    ((whiskeringLeft C D E).obj L).Full :=\n  inferInstanceAs (whiskeringLeftFunctor' L W E).Full\n\n"}
{"name":"CategoryTheory.Localization.faithful_whiskeringLeft","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst‚úù¬π : L.IsLocalization W\nE : Type u_4\ninst‚úù : CategoryTheory.Category.{u_7, u_4} E\n‚ä¢ ((CategoryTheory.whiskeringLeft C D E).obj L).Faithful","decl":"lemma faithful_whiskeringLeft (L : C ‚•§ D) (W) [L.IsLocalization W] (E : Type*) [Category E] :\n    ((whiskeringLeft C D E).obj L).Faithful :=\n  inferInstanceAs (whiskeringLeftFunctor' L W E).Faithful\n\n"}
{"name":"CategoryTheory.Localization.natTrans_ext","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\nE : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} E\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst‚úù : L.IsLocalization W\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor D E\nœÑ œÑ' : Quiver.Hom F‚ÇÅ F‚ÇÇ\nh : ‚àÄ (X : C), Eq (œÑ.app (L.obj X)) (œÑ'.app (L.obj X))\n‚ä¢ Eq œÑ œÑ'","decl":"theorem natTrans_ext (L : C ‚•§ D) (W) [L.IsLocalization W] {F‚ÇÅ F‚ÇÇ : D ‚•§ E} {œÑ œÑ' : F‚ÇÅ ‚ü∂ F‚ÇÇ}\n    (h : ‚àÄ X : C, œÑ.app (L.obj X) = œÑ'.app (L.obj X)) : œÑ = œÑ' := by\n  haveI := essSurj L W\n  ext Y\n  rw [‚Üê cancel_epi (F‚ÇÅ.map (L.objObjPreimageIso Y).hom), œÑ.naturality, œÑ'.naturality, h]\n\n-- Porting note: the field `iso` was renamed `Lifting.iso'` and it was redefined as\n-- `Lifting.iso` with explicit parameters\n"}
{"name":"CategoryTheory.Localization.liftNatTrans_app","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_3} E\ninst‚úù¬≤ : L.IsLocalization W\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor C E\nF‚ÇÅ' F‚ÇÇ' : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Localization.Lifting L W F‚ÇÅ F‚ÇÅ'\ninst‚úù : CategoryTheory.Localization.Lifting L W F‚ÇÇ F‚ÇÇ'\nœÑ : Quiver.Hom F‚ÇÅ F‚ÇÇ\nX : C\n‚ä¢ Eq ((CategoryTheory.Localization.liftNatTrans L W F‚ÇÅ F‚ÇÇ F‚ÇÅ' F‚ÇÇ' œÑ).app (L.obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Localization.Lifting.iso L W F‚ÇÅ F‚ÇÅ').hom.app X) (CategoryTheory.CategoryStruct.comp (œÑ.app X) ((CategoryTheory.Localization.Lifting.iso L W F‚ÇÇ F‚ÇÇ').inv.app X)))","decl":"@[simp]\ntheorem liftNatTrans_app (F‚ÇÅ F‚ÇÇ : C ‚•§ E) (F‚ÇÅ' F‚ÇÇ' : D ‚•§ E) [Lifting L W F‚ÇÅ F‚ÇÅ'] [Lifting L W F‚ÇÇ F‚ÇÇ']\n    (œÑ : F‚ÇÅ ‚ü∂ F‚ÇÇ) (X : C) :\n    (liftNatTrans L W F‚ÇÅ F‚ÇÇ F‚ÇÅ' F‚ÇÇ' œÑ).app (L.obj X) =\n      (Lifting.iso L W F‚ÇÅ F‚ÇÅ').hom.app X ‚â´ œÑ.app X ‚â´ (Lifting.iso L W F‚ÇÇ F‚ÇÇ').inv.app X :=\n  congr_app (Functor.map_preimage (whiskeringLeftFunctor' L W E) _) X\n\n"}
{"name":"CategoryTheory.Localization.comp_liftNatTrans_assoc","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} E\ninst‚úù : L.IsLocalization W\nF‚ÇÅ F‚ÇÇ F‚ÇÉ : CategoryTheory.Functor C E\nF‚ÇÅ' F‚ÇÇ' F‚ÇÉ' : CategoryTheory.Functor D E\nh‚ÇÅ : CategoryTheory.Localization.Lifting L W F‚ÇÅ F‚ÇÅ'\nh‚ÇÇ : CategoryTheory.Localization.Lifting L W F‚ÇÇ F‚ÇÇ'\nh‚ÇÉ : CategoryTheory.Localization.Lifting L W F‚ÇÉ F‚ÇÉ'\nœÑ : Quiver.Hom F‚ÇÅ F‚ÇÇ\nœÑ' : Quiver.Hom F‚ÇÇ F‚ÇÉ\nZ : CategoryTheory.Functor D E\nh : Quiver.Hom F‚ÇÉ' Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.liftNatTrans L W F‚ÇÅ F‚ÇÇ F‚ÇÅ' F‚ÇÇ' œÑ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.liftNatTrans L W F‚ÇÇ F‚ÇÉ F‚ÇÇ' F‚ÇÉ' œÑ') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.liftNatTrans L W F‚ÇÅ F‚ÇÉ F‚ÇÅ' F‚ÇÉ' (CategoryTheory.CategoryStruct.comp œÑ œÑ')) h)","decl":"@[reassoc (attr := simp)]\ntheorem comp_liftNatTrans (F‚ÇÅ F‚ÇÇ F‚ÇÉ : C ‚•§ E) (F‚ÇÅ' F‚ÇÇ' F‚ÇÉ' : D ‚•§ E) [h‚ÇÅ : Lifting L W F‚ÇÅ F‚ÇÅ']\n    [h‚ÇÇ : Lifting L W F‚ÇÇ F‚ÇÇ'] [h‚ÇÉ : Lifting L W F‚ÇÉ F‚ÇÉ'] (œÑ : F‚ÇÅ ‚ü∂ F‚ÇÇ) (œÑ' : F‚ÇÇ ‚ü∂ F‚ÇÉ) :\n    liftNatTrans L W F‚ÇÅ F‚ÇÇ F‚ÇÅ' F‚ÇÇ' œÑ ‚â´ liftNatTrans L W F‚ÇÇ F‚ÇÉ F‚ÇÇ' F‚ÇÉ' œÑ' =\n      liftNatTrans L W F‚ÇÅ F‚ÇÉ F‚ÇÅ' F‚ÇÉ' (œÑ ‚â´ œÑ') :=\n  natTrans_ext L W fun X => by\n    simp only [NatTrans.comp_app, liftNatTrans_app, assoc, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"CategoryTheory.Localization.comp_liftNatTrans","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} E\ninst‚úù : L.IsLocalization W\nF‚ÇÅ F‚ÇÇ F‚ÇÉ : CategoryTheory.Functor C E\nF‚ÇÅ' F‚ÇÇ' F‚ÇÉ' : CategoryTheory.Functor D E\nh‚ÇÅ : CategoryTheory.Localization.Lifting L W F‚ÇÅ F‚ÇÅ'\nh‚ÇÇ : CategoryTheory.Localization.Lifting L W F‚ÇÇ F‚ÇÇ'\nh‚ÇÉ : CategoryTheory.Localization.Lifting L W F‚ÇÉ F‚ÇÉ'\nœÑ : Quiver.Hom F‚ÇÅ F‚ÇÇ\nœÑ' : Quiver.Hom F‚ÇÇ F‚ÇÉ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Localization.liftNatTrans L W F‚ÇÅ F‚ÇÇ F‚ÇÅ' F‚ÇÇ' œÑ) (CategoryTheory.Localization.liftNatTrans L W F‚ÇÇ F‚ÇÉ F‚ÇÇ' F‚ÇÉ' œÑ')) (CategoryTheory.Localization.liftNatTrans L W F‚ÇÅ F‚ÇÉ F‚ÇÅ' F‚ÇÉ' (CategoryTheory.CategoryStruct.comp œÑ œÑ'))","decl":"@[reassoc (attr := simp)]\ntheorem comp_liftNatTrans (F‚ÇÅ F‚ÇÇ F‚ÇÉ : C ‚•§ E) (F‚ÇÅ' F‚ÇÇ' F‚ÇÉ' : D ‚•§ E) [h‚ÇÅ : Lifting L W F‚ÇÅ F‚ÇÅ']\n    [h‚ÇÇ : Lifting L W F‚ÇÇ F‚ÇÇ'] [h‚ÇÉ : Lifting L W F‚ÇÉ F‚ÇÉ'] (œÑ : F‚ÇÅ ‚ü∂ F‚ÇÇ) (œÑ' : F‚ÇÇ ‚ü∂ F‚ÇÉ) :\n    liftNatTrans L W F‚ÇÅ F‚ÇÇ F‚ÇÅ' F‚ÇÇ' œÑ ‚â´ liftNatTrans L W F‚ÇÇ F‚ÇÉ F‚ÇÇ' F‚ÇÉ' œÑ' =\n      liftNatTrans L W F‚ÇÅ F‚ÇÉ F‚ÇÅ' F‚ÇÉ' (œÑ ‚â´ œÑ') :=\n  natTrans_ext L W fun X => by\n    simp only [NatTrans.comp_app, liftNatTrans_app, assoc, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"CategoryTheory.Localization.liftNatTrans_id","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_3} E\ninst‚úù : L.IsLocalization W\nF : CategoryTheory.Functor C E\nF' : CategoryTheory.Functor D E\nh : CategoryTheory.Localization.Lifting L W F F'\n‚ä¢ Eq (CategoryTheory.Localization.liftNatTrans L W F F F' F' (CategoryTheory.CategoryStruct.id F)) (CategoryTheory.CategoryStruct.id F')","decl":"@[simp]\ntheorem liftNatTrans_id (F : C ‚•§ E) (F' : D ‚•§ E) [h : Lifting L W F F'] :\n    liftNatTrans L W F F F' F' (ùüô F) = ùüô F' :=\n  natTrans_ext L W fun X => by\n    simp only [liftNatTrans_app, NatTrans.id_app, id_comp, Iso.hom_inv_id_app]\n    rfl\n\n"}
{"name":"CategoryTheory.Localization.liftNatIso_inv","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} E\ninst‚úù : L.IsLocalization W\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor C E\nF‚ÇÅ' F‚ÇÇ' : CategoryTheory.Functor D E\nh‚ÇÅ : CategoryTheory.Localization.Lifting L W F‚ÇÅ F‚ÇÅ'\nh‚ÇÇ : CategoryTheory.Localization.Lifting L W F‚ÇÇ F‚ÇÇ'\ne : CategoryTheory.Iso F‚ÇÅ F‚ÇÇ\n‚ä¢ Eq (CategoryTheory.Localization.liftNatIso L W F‚ÇÅ F‚ÇÇ F‚ÇÅ' F‚ÇÇ' e).inv (CategoryTheory.Localization.liftNatTrans L W F‚ÇÇ F‚ÇÅ F‚ÇÇ' F‚ÇÅ' e.inv)","decl":"/-- Given a localization functor `L : C ‚•§ D` for `W : MorphismProperty C`,\nif `(F‚ÇÅ' F‚ÇÇ' : D ‚•§ E)` are functors which lifts functors `(F‚ÇÅ F‚ÇÇ : C ‚•§ E)`,\na natural isomorphism `œÑ : F‚ÇÅ ‚ü∂ F‚ÇÇ` lifts to a natural isomorphism `F‚ÇÅ' ‚ü∂ F‚ÇÇ'`. -/\n@[simps]\ndef liftNatIso (F‚ÇÅ F‚ÇÇ : C ‚•§ E) (F‚ÇÅ' F‚ÇÇ' : D ‚•§ E) [h‚ÇÅ : Lifting L W F‚ÇÅ F‚ÇÅ'] [h‚ÇÇ : Lifting L W F‚ÇÇ F‚ÇÇ']\n    (e : F‚ÇÅ ‚âÖ F‚ÇÇ) : F‚ÇÅ' ‚âÖ F‚ÇÇ' where\n  hom := liftNatTrans L W F‚ÇÅ F‚ÇÇ F‚ÇÅ' F‚ÇÇ' e.hom\n  inv := liftNatTrans L W F‚ÇÇ F‚ÇÅ F‚ÇÇ' F‚ÇÅ' e.inv\n\n"}
{"name":"CategoryTheory.Localization.liftNatIso_hom","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} E\ninst‚úù : L.IsLocalization W\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor C E\nF‚ÇÅ' F‚ÇÇ' : CategoryTheory.Functor D E\nh‚ÇÅ : CategoryTheory.Localization.Lifting L W F‚ÇÅ F‚ÇÅ'\nh‚ÇÇ : CategoryTheory.Localization.Lifting L W F‚ÇÇ F‚ÇÇ'\ne : CategoryTheory.Iso F‚ÇÅ F‚ÇÇ\n‚ä¢ Eq (CategoryTheory.Localization.liftNatIso L W F‚ÇÅ F‚ÇÇ F‚ÇÅ' F‚ÇÇ' e).hom (CategoryTheory.Localization.liftNatTrans L W F‚ÇÅ F‚ÇÇ F‚ÇÅ' F‚ÇÇ' e.hom)","decl":"/-- Given a localization functor `L : C ‚•§ D` for `W : MorphismProperty C`,\nif `(F‚ÇÅ' F‚ÇÇ' : D ‚•§ E)` are functors which lifts functors `(F‚ÇÅ F‚ÇÇ : C ‚•§ E)`,\na natural isomorphism `œÑ : F‚ÇÅ ‚ü∂ F‚ÇÇ` lifts to a natural isomorphism `F‚ÇÅ' ‚ü∂ F‚ÇÇ'`. -/\n@[simps]\ndef liftNatIso (F‚ÇÅ F‚ÇÇ : C ‚•§ E) (F‚ÇÅ' F‚ÇÇ' : D ‚•§ E) [h‚ÇÅ : Lifting L W F‚ÇÅ F‚ÇÅ'] [h‚ÇÇ : Lifting L W F‚ÇÇ F‚ÇÇ']\n    (e : F‚ÇÅ ‚âÖ F‚ÇÇ) : F‚ÇÅ' ‚âÖ F‚ÇÇ' where\n  hom := liftNatTrans L W F‚ÇÅ F‚ÇÇ F‚ÇÅ' F‚ÇÇ' e.hom\n  inv := liftNatTrans L W F‚ÇÇ F‚ÇÅ F‚ÇÇ' F‚ÇÅ' e.inv\n\n"}
{"name":"CategoryTheory.Localization.Lifting.compRight_iso'","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} E\nE' : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} E'\nF : CategoryTheory.Functor C E\nF' : CategoryTheory.Functor D E\ninst‚úù : CategoryTheory.Localization.Lifting L W F F'\nG : CategoryTheory.Functor E E'\n‚ä¢ Eq (CategoryTheory.Localization.Lifting.iso' W) (CategoryTheory.isoWhiskerRight (CategoryTheory.Localization.Lifting.iso L W F F') G)","decl":"@[simps]\ninstance compRight {E' : Type*} [Category E'] (F : C ‚•§ E) (F' : D ‚•§ E) [Lifting L W F F']\n    (G : E ‚•§ E') : Lifting L W (F ‚ãô G) (F' ‚ãô G) :=\n  ‚ü®isoWhiskerRight (iso L W F F') G‚ü©\n\n"}
{"name":"CategoryTheory.Localization.Lifting.id_iso'","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\n‚ä¢ Eq (CategoryTheory.Localization.Lifting.iso' W) L.rightUnitor","decl":"@[simps]\ninstance id : Lifting L W L (ùü≠ D) :=\n  ‚ü®Functor.rightUnitor L‚ü©\n\n"}
{"name":"CategoryTheory.Localization.Lifting.compLeft_iso'","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} E\nF : CategoryTheory.Functor D E\n‚ä¢ Eq (CategoryTheory.Localization.Lifting.iso' W) (CategoryTheory.Iso.refl (L.comp F))","decl":"@[simps]\ninstance compLeft (F : D ‚•§ E) : Localization.Lifting L W (L ‚ãô F) F := ‚ü®Iso.refl _‚ü©\n\n"}
{"name":"CategoryTheory.Localization.Lifting.compLeft_iso","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nE : Type u_3\ninst‚úù : CategoryTheory.Category.{u_6, u_3} E\nW : CategoryTheory.MorphismProperty C\nF : CategoryTheory.Functor D E\n‚ä¢ Eq (CategoryTheory.Localization.Lifting.iso L W (L.comp F) F) (CategoryTheory.Iso.refl (L.comp F))","decl":"@[simp]\nlemma compLeft_iso (W) (F : D ‚•§ E) : Localization.Lifting.iso L W (L ‚ãô F) F = Iso.refl _ := rfl\n\n"}
{"name":"CategoryTheory.Localization.Lifting.ofIsos_iso'","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} E\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor C E\nF‚ÇÅ' F‚ÇÇ' : CategoryTheory.Functor D E\ne : CategoryTheory.Iso F‚ÇÅ F‚ÇÇ\ne' : CategoryTheory.Iso F‚ÇÅ' F‚ÇÇ'\ninst‚úù : CategoryTheory.Localization.Lifting L W F‚ÇÅ F‚ÇÅ'\n‚ä¢ Eq (CategoryTheory.Localization.Lifting.iso' W) ((CategoryTheory.isoWhiskerLeft L e'.symm).trans ((CategoryTheory.Localization.Lifting.iso L W F‚ÇÅ F‚ÇÅ').trans e))","decl":"/-- Given a localization functor `L : C ‚•§ D` for `W : MorphismProperty C`,\nif `F‚ÇÅ' : D ‚•§ E` lifts a functor `F‚ÇÅ : C ‚•§ D`, then a functor `F‚ÇÇ'` which\nis isomorphic to `F‚ÇÅ'` also lifts a functor `F‚ÇÇ` that is isomorphic to `F‚ÇÅ`. -/\n@[simps]\ndef ofIsos {F‚ÇÅ F‚ÇÇ : C ‚•§ E} {F‚ÇÅ' F‚ÇÇ' : D ‚•§ E} (e : F‚ÇÅ ‚âÖ F‚ÇÇ) (e' : F‚ÇÅ' ‚âÖ F‚ÇÇ') [Lifting L W F‚ÇÅ F‚ÇÅ'] :\n    Lifting L W F‚ÇÇ F‚ÇÇ' :=\n  ‚ü®isoWhiskerLeft L e'.symm ‚â™‚â´ iso L W F‚ÇÅ F‚ÇÅ' ‚â™‚â´ e‚ü©\n\n"}
{"name":"CategoryTheory.Functor.IsLocalization.of_iso","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nW : CategoryTheory.MorphismProperty C\nL‚ÇÅ L‚ÇÇ : CategoryTheory.Functor C D\ne : CategoryTheory.Iso L‚ÇÅ L‚ÇÇ\ninst‚úù : L‚ÇÅ.IsLocalization W\n‚ä¢ L‚ÇÇ.IsLocalization W","decl":"theorem of_iso {L‚ÇÅ L‚ÇÇ : C ‚•§ D} (e : L‚ÇÅ ‚âÖ L‚ÇÇ) [L‚ÇÅ.IsLocalization W] : L‚ÇÇ.IsLocalization W := by\n  have h := Localization.inverts L‚ÇÅ W\n  rw [MorphismProperty.IsInvertedBy.iff_of_iso W e] at h\n  let F‚ÇÅ := Localization.Construction.lift L‚ÇÅ (Localization.inverts L‚ÇÅ W)\n  let F‚ÇÇ := Localization.Construction.lift L‚ÇÇ h\n  exact\n    { inverts := h\n      isEquivalence := Functor.isEquivalence_of_iso (liftNatIso W.Q W L‚ÇÅ L‚ÇÇ F‚ÇÅ F‚ÇÇ e) }\n\n"}
{"name":"CategoryTheory.Functor.IsLocalization.of_equivalence_target","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_4} E\nL' : CategoryTheory.Functor C E\neq : CategoryTheory.Equivalence D E\ninst‚úù : L.IsLocalization W\ne : CategoryTheory.Iso (L.comp eq.functor) L'\n‚ä¢ L'.IsLocalization W","decl":"/-- If `L : C ‚•§ D` is a localization for `W : MorphismProperty C`, then it is also\nthe case of a functor obtained by post-composing `L` with an equivalence of categories. -/\ntheorem of_equivalence_target {E : Type*} [Category E] (L' : C ‚•§ E) (eq : D ‚âå E)\n    [L.IsLocalization W] (e : L ‚ãô eq.functor ‚âÖ L') : L'.IsLocalization W := by\n  have h : W.IsInvertedBy L' := by\n    rw [‚Üê MorphismProperty.IsInvertedBy.iff_of_iso W e]\n    exact MorphismProperty.IsInvertedBy.of_comp W L (Localization.inverts L W) eq.functor\n  let F‚ÇÅ := Localization.Construction.lift L (Localization.inverts L W)\n  let F‚ÇÇ := Localization.Construction.lift L' h\n  let e' : F‚ÇÅ ‚ãô eq.functor ‚âÖ F‚ÇÇ := liftNatIso W.Q W (L ‚ãô eq.functor) L' _ _ e\n  exact\n    { inverts := h\n      isEquivalence := Functor.isEquivalence_of_iso e' }\n\n"}
{"name":"CategoryTheory.Functor.IsLocalization.instCompOfIsEquivalence","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nE : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_3} E\nF : CategoryTheory.Functor D E\ninst‚úù¬π : F.IsEquivalence\ninst‚úù : L.IsLocalization W\n‚ä¢ (L.comp F).IsLocalization W","decl":"instance (F : D ‚•§ E) [F.IsEquivalence] [L.IsLocalization W] :\n    (L ‚ãô F).IsLocalization W :=\n  of_equivalence_target L W _ F.asEquivalence (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.IsLocalization.of_isEquivalence","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nhW : LE.le W (CategoryTheory.MorphismProperty.isomorphisms C)\ninst‚úù : L.IsEquivalence\n‚ä¢ L.IsLocalization W","decl":"lemma of_isEquivalence (L : C ‚•§ D) (W : MorphismProperty C)\n    (hW : W ‚â§ MorphismProperty.isomorphisms C) [IsEquivalence L] :\n    L.IsLocalization W := by\n  haveI : (ùü≠ C).IsLocalization W := for_id W hW\n  exact of_equivalence_target (ùü≠ C) W L L.asEquivalence L.leftUnitor\n\n"}
{"name":"CategoryTheory.Localization.uniq_symm","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_8, u_1} C\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_4} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_5} D‚ÇÇ\nL‚ÇÅ : CategoryTheory.Functor C D‚ÇÅ\nL‚ÇÇ : CategoryTheory.Functor C D‚ÇÇ\nW' : CategoryTheory.MorphismProperty C\ninst‚úù¬π : L‚ÇÅ.IsLocalization W'\ninst‚úù : L‚ÇÇ.IsLocalization W'\n‚ä¢ Eq (CategoryTheory.Localization.uniq L‚ÇÅ L‚ÇÇ W').symm (CategoryTheory.Localization.uniq L‚ÇÇ L‚ÇÅ W')","decl":"lemma uniq_symm : (uniq L‚ÇÅ L‚ÇÇ W').symm = uniq L‚ÇÇ L‚ÇÅ W' := by\n  dsimp [uniq, Equivalence.trans]\n  ext <;> aesop\n\n"}
{"name":"CategoryTheory.areEqualizedByLocalization_iff","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\nX Y : C\nf g : Quiver.Hom X Y\ninst‚úù : L.IsLocalization W\n‚ä¢ Iff (CategoryTheory.AreEqualizedByLocalization W f g) (Eq (L.map f) (L.map g))","decl":"lemma areEqualizedByLocalization_iff [L.IsLocalization W] :\n    AreEqualizedByLocalization W f g ‚Üî L.map f = L.map g := by\n  dsimp [AreEqualizedByLocalization]\n  constructor\n  ¬∑ intro h\n    let e := Localization.compUniqFunctor W.Q L W\n    rw [‚Üê NatIso.naturality_1 e f, ‚Üê NatIso.naturality_1 e g]\n    dsimp\n    rw [h]\n  ¬∑ intro h\n    let e := Localization.compUniqFunctor L W.Q W\n    rw [‚Üê NatIso.naturality_1 e f, ‚Üê NatIso.naturality_1 e g]\n    dsimp\n    rw [h]\n\n"}
{"name":"CategoryTheory.AreEqualizedByLocalization.mk","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nW : CategoryTheory.MorphismProperty C\nX Y : C\nf g : Quiver.Hom X Y\nL : CategoryTheory.Functor C D\ninst‚úù : L.IsLocalization W\nh : Eq (L.map f) (L.map g)\n‚ä¢ CategoryTheory.AreEqualizedByLocalization W f g","decl":"lemma mk (L : C ‚•§ D) [L.IsLocalization W] (h : L.map f = L.map g) :\n    AreEqualizedByLocalization W f g :=\n  (areEqualizedByLocalization_iff L W f g).2 h\n\n"}
{"name":"CategoryTheory.AreEqualizedByLocalization.map_eq","module":"Mathlib.CategoryTheory.Localization.Predicate","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_2} D\nW : CategoryTheory.MorphismProperty C\nX Y : C\nf g : Quiver.Hom X Y\nh : CategoryTheory.AreEqualizedByLocalization W f g\nL : CategoryTheory.Functor C D\ninst‚úù : L.IsLocalization W\n‚ä¢ Eq (L.map f) (L.map g)","decl":"lemma map_eq (h : AreEqualizedByLocalization W f g) (L : C ‚•§ D) [L.IsLocalization W] :\n    L.map f = L.map g :=\n  (areEqualizedByLocalization_iff L W f g).1 h\n\n"}
