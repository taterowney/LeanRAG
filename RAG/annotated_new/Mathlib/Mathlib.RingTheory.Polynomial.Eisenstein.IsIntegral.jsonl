{"name":"cyclotomic_comp_X_add_one_isEisensteinAt","module":"Mathlib.RingTheory.Polynomial.Eisenstein.IsIntegral","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n‚ä¢ ((Polynomial.cyclotomic p Int).comp (HAdd.hAdd Polynomial.X 1)).IsEisensteinAt (Submodule.span Int (Singleton.singleton ‚Üëp))","decl":"theorem cyclotomic_comp_X_add_one_isEisensteinAt [hp : Fact p.Prime] :\n    ((cyclotomic p ‚Ñ§).comp (X + 1)).IsEisensteinAt ùìü := by\n  refine Monic.isEisensteinAt_of_mem_of_not_mem ?_\n      (Ideal.IsPrime.ne_top <| (Ideal.span_singleton_prime (mod_cast hp.out.ne_zero)).2 <|\n        Nat.prime_iff_prime_int.1 hp.out) (fun {i hi} => ?_) ?_\n  ¬∑ rw [show (X + 1 : ‚Ñ§[X]) = X + C 1 by simp]\n    refine (cyclotomic.monic p ‚Ñ§).comp (monic_X_add_C 1) fun h => ?_\n    rw [natDegree_X_add_C] at h\n    exact zero_ne_one h.symm\n  ¬∑ rw [cyclotomic_prime, geom_sum_X_comp_X_add_one_eq_sum, ‚Üê lcoeff_apply, map_sum]\n    conv =>\n      congr\n      congr\n      next => skip\n      congr\n      next => skip\n      ext\n      rw [lcoeff_apply, ‚Üê C_eq_natCast, C_mul_X_pow_eq_monomial, coeff_monomial]\n    rw [natDegree_comp, show (X + 1 : ‚Ñ§[X]) = X + C 1 by simp, natDegree_X_add_C, mul_one,\n      natDegree_cyclotomic, Nat.totient_prime hp.out] at hi\n    simp only [hi.trans_le (Nat.sub_le _ _), sum_ite_eq', mem_range, if_true,\n      Ideal.submodule_span_eq, Ideal.mem_span_singleton, Int.natCast_dvd_natCast]\n    exact hp.out.dvd_choose_self i.succ_ne_zero (lt_tsub_iff_right.1 hi)\n  ¬∑ rw [coeff_zero_eq_eval_zero, eval_comp, cyclotomic_prime, eval_add, eval_X, eval_one, zero_add,\n      eval_geom_sum, one_geom_sum, Ideal.submodule_span_eq, Ideal.span_singleton_pow,\n      Ideal.mem_span_singleton]\n    intro h\n    obtain ‚ü®k, hk‚ü© := Int.natCast_dvd_natCast.1 h\n    rw [mul_assoc, mul_comm 1, mul_one] at hk\n    nth_rw 1 [‚Üê Nat.mul_one p] at hk\n    rw [mul_right_inj' hp.out.ne_zero] at hk\n    exact Nat.Prime.not_dvd_one hp.out (Dvd.intro k hk.symm)\n\n"}
{"name":"cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt","module":"Mathlib.RingTheory.Polynomial.Eisenstein.IsIntegral","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ ((Polynomial.cyclotomic (HPow.hPow p (HAdd.hAdd n 1)) Int).comp (HAdd.hAdd Polynomial.X 1)).IsEisensteinAt (Submodule.span Int (Singleton.singleton ‚Üëp))","decl":"theorem cyclotomic_prime_pow_comp_X_add_one_isEisensteinAt [hp : Fact p.Prime] (n : ‚Ñï) :\n    ((cyclotomic (p ^ (n + 1)) ‚Ñ§).comp (X + 1)).IsEisensteinAt ùìü := by\n  refine Monic.isEisensteinAt_of_mem_of_not_mem ?_\n      (Ideal.IsPrime.ne_top <| (Ideal.span_singleton_prime (mod_cast hp.out.ne_zero)).2 <|\n        Nat.prime_iff_prime_int.1 hp.out) ?_ ?_\n  ¬∑ rw [show (X + 1 : ‚Ñ§[X]) = X + C 1 by simp]\n    refine (cyclotomic.monic _ ‚Ñ§).comp (monic_X_add_C 1) fun h => ?_\n    rw [natDegree_X_add_C] at h\n    exact zero_ne_one h.symm\n  ¬∑ induction' n with n hn\n    ¬∑ intro i hi\n      rw [Nat.zero_add, pow_one] at hi ‚ä¢\n      exact (cyclotomic_comp_X_add_one_isEisensteinAt p).mem hi\n    ¬∑ intro i hi\n      rw [Ideal.submodule_span_eq, Ideal.mem_span_singleton, ‚Üê ZMod.intCast_zmod_eq_zero_iff_dvd,\n        show ‚Üë(_ : ‚Ñ§) = Int.castRingHom (ZMod p) _ by rfl, ‚Üê coeff_map, map_comp, map_cyclotomic,\n        Polynomial.map_add, map_X, Polynomial.map_one, pow_add, pow_one,\n        cyclotomic_mul_prime_dvd_eq_pow, pow_comp, ‚Üê ZMod.expand_card, coeff_expand hp.out.pos]\n      ¬∑ simp only [ite_eq_right_iff]\n        rintro ‚ü®k, hk‚ü©\n        rw [natDegree_comp, show (X + 1 : ‚Ñ§[X]) = X + C 1 by simp, natDegree_X_add_C, mul_one,\n          natDegree_cyclotomic, Nat.totient_prime_pow hp.out (Nat.succ_pos _), Nat.add_one_sub_one]\n          at hn hi\n        rw [hk, pow_succ', mul_assoc] at hi\n        rw [hk, mul_comm, Nat.mul_div_cancel _ hp.out.pos]\n        replace hn := hn (lt_of_mul_lt_mul_left' hi)\n        rw [Ideal.submodule_span_eq, Ideal.mem_span_singleton, ‚Üê ZMod.intCast_zmod_eq_zero_iff_dvd,\n           show ‚Üë(_ : ‚Ñ§) = Int.castRingHom (ZMod p) _ by rfl, ‚Üê coeff_map] at hn\n        simpa [map_comp] using hn\n      ¬∑ exact ‚ü®p ^ n, by rw [pow_succ']‚ü©\n  ¬∑ rw [coeff_zero_eq_eval_zero, eval_comp, cyclotomic_prime_pow_eq_geom_sum hp.out, eval_add,\n      eval_X, eval_one, zero_add, eval_finset_sum]\n    simp only [eval_pow, eval_X, one_pow, sum_const, card_range, Nat.smul_one_eq_cast,\n      submodule_span_eq, Ideal.submodule_span_eq, Ideal.span_singleton_pow,\n      Ideal.mem_span_singleton]\n    intro h\n    obtain ‚ü®k, hk‚ü© := Int.natCast_dvd_natCast.1 h\n    rw [mul_assoc, mul_comm 1, mul_one] at hk\n    nth_rw 1 [‚Üê Nat.mul_one p] at hk\n    rw [mul_right_inj' hp.out.ne_zero] at hk\n    exact Nat.Prime.not_dvd_one hp.out (Dvd.intro k hk.symm)\n\n"}
{"name":"dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt","module":"Mathlib.RingTheory.Polynomial.Eisenstein.IsIntegral","initialProofState":"R : Type u\nK : Type v\nL : Type z\np : R\ninst‚úù¬π‚Å∞ : CommRing R\ninst‚úù‚Åπ : Field K\ninst‚úù‚Å∏ : Field L\ninst‚úù‚Å∑ : Algebra K L\ninst‚úù‚Å∂ : Algebra R L\ninst‚úù‚Åµ : Algebra R K\ninst‚úù‚Å¥ : IsScalarTower R K L\ninst‚úù¬≥ : Algebra.IsSeparable K L\ninst‚úù¬≤ : IsDomain R\ninst‚úù¬π : IsFractionRing R K\ninst‚úù : IsIntegrallyClosed R\nB : PowerBasis K L\nhp : Prime p\nhBint : IsIntegral R B.gen\nz : L\nQ : Polynomial R\nhQ : Eq ((Polynomial.aeval B.gen) Q) (HSMul.hSMul p z)\nhzint : IsIntegral R z\nhei : (minpoly R B.gen).IsEisensteinAt (Submodule.span R (Singleton.singleton p))\n‚ä¢ Dvd.dvd p (Q.coeff 0)","decl":"/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be a separable\nextension of `K`, generated by an integral power basis `B` such that the minimal polynomial of\n`B.gen` is Eisenstein at `p`. Given `z : L` integral over `R`, if `Q : R[X]` is such that\n`aeval B.gen Q = p ‚Ä¢ z`, then `p ‚à£ Q.coeff 0`. -/\ntheorem dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}\n    (hp : Prime p) (hBint : IsIntegral R B.gen) {z : L} {Q : R[X]} (hQ : aeval B.gen Q = p ‚Ä¢ z)\n    (hzint : IsIntegral R z) (hei : (minpoly R B.gen).IsEisensteinAt ùìü) : p ‚à£ Q.coeff 0 := by\n  -- First define some abbreviations.\n  letI := B.finite\n  let P := minpoly R B.gen\n  obtain ‚ü®n, hn‚ü© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'\n  have finrank_K_L : Module.finrank K L = B.dim := B.finrank\n  have deg_K_P : (minpoly K B.gen).natDegree = B.dim := B.natDegree_minpoly\n  have deg_R_P : P.natDegree = B.dim := by\n    rw [‚Üê deg_K_P, minpoly.isIntegrallyClosed_eq_field_fractions' K hBint,\n      (minpoly.monic hBint).natDegree_map (algebraMap R K)]\n  choose! f hf using\n    hei.isWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le (minpoly.aeval R B.gen)\n      (minpoly.monic hBint)\n  simp only [P, (minpoly.monic hBint).natDegree_map, deg_R_P] at hf\n\n  -- The Eisenstein condition shows that `p` divides `Q.coeff 0`\n  -- if `p^n.succ` divides the following multiple of `Q.coeff 0^n.succ`:\n  suffices\n      p ^ n.succ ‚à£ Q.coeff 0 ^ n.succ * ((-1) ^ (n.succ * n) * (minpoly R B.gen).coeff 0 ^ n) by\n    have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>\n      hei.not_mem ((span_singleton_pow p 2).symm ‚ñ∏ Ideal.mem_span_singleton.2 h)\n    refine @Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd R _ _ _ _ n hp (?_ : _ ‚à£ _) hndiv\n    convert (IsUnit.dvd_mul_right ‚ü®(-1) ^ (n.succ * n), rfl‚ü©).mpr this using 1\n    push_cast\n    ring_nf\n    rw [mul_comm _ 2, pow_mul, neg_one_sq, one_pow, mul_one]\n\n  -- We claim the quotient of `Q^n * _` by `p^n` is the following `r`:\n  have aux : ‚àÄ i ‚àà (range (Q.natDegree + 1)).erase 0, B.dim ‚â§ i + n := by\n    intro i hi\n    simp only [mem_range, mem_erase] at hi\n    rw [hn]\n    exact le_add_pred_of_pos _ hi.1\n  have hintsum :\n    IsIntegral R\n      (z * B.gen ^ n - ‚àë x ‚àà (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ f (x + n)) := by\n    refine (hzint.mul (hBint.pow _)).sub (.sum _ fun i hi => .smul _ ?_)\n    exact adjoin_le_integralClosure hBint (hf _ (aux i hi)).1\n  obtain ‚ü®r, hr‚ü© := isIntegral_iff.1 (isIntegral_norm K hintsum)\n  use r\n\n  -- Do the computation in `K` so we can work in terms of `z` instead of `r`.\n  apply IsFractionRing.injective R K\n  simp only [_root_.map_mul, map_pow, map_neg, map_one]\n  -- Both sides are actually norms:\n  calc\n    _ = norm K (Q.coeff 0 ‚Ä¢ B.gen ^ n) := ?_\n    _ = norm K (p ‚Ä¢ (z * B.gen ^ n) -\n          ‚àë x ‚àà (range (Q.natDegree + 1)).erase 0, p ‚Ä¢ Q.coeff x ‚Ä¢ f (x + n)) :=\n        (congr_arg (norm K) (eq_sub_of_add_eq ?_))\n    _ = _ := ?_\n  ¬∑ simp only [Algebra.smul_def, algebraMap_apply R K L, Algebra.norm_algebraMap, _root_.map_mul,\n      map_pow, finrank_K_L, PowerBasis.norm_gen_eq_coeff_zero_minpoly,\n      minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, coeff_map, ‚Üê hn]\n    ring\n  swap\n  ¬∑ simp_rw [‚Üê smul_sum, ‚Üê smul_sub, Algebra.smul_def p, algebraMap_apply R K L, _root_.map_mul,\n      Algebra.norm_algebraMap, finrank_K_L, hr, ‚Üê hn]\n  calc\n    _ = (Q.coeff 0 ‚Ä¢ ‚Üë1 + ‚àë x ‚àà (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ B.gen ^ x) *\n          B.gen ^ n := ?_\n    _ = (Q.coeff 0 ‚Ä¢ B.gen ^ 0 +\n        ‚àë x ‚àà (range (Q.natDegree + 1)).erase 0, Q.coeff x ‚Ä¢ B.gen ^ x) * B.gen ^ n := by\n      rw [pow_zero]\n    _ = aeval B.gen Q * B.gen ^ n := ?_\n    _ = _ := by rw [hQ, Algebra.smul_mul_assoc]\n  ¬∑ have : ‚àÄ i ‚àà (range (Q.natDegree + 1)).erase 0,\n        Q.coeff i ‚Ä¢ (B.gen ^ i * B.gen ^ n) = p ‚Ä¢ Q.coeff i ‚Ä¢ f (i + n) := by\n      intro i hi\n      rw [‚Üê pow_add, ‚Üê (hf _ (aux i hi)).2, ‚Üê Algebra.smul_def, smul_smul, mul_comm _ p, smul_smul]\n    simp only [add_mul, smul_mul_assoc, one_mul, sum_mul, sum_congr rfl this]\n  ¬∑ rw [aeval_eq_sum_range,\n      Finset.add_sum_erase (range (Q.natDegree + 1)) fun i => Q.coeff i ‚Ä¢ B.gen ^ i]\n    simp\n\n"}
{"name":"mem_adjoin_of_dvd_coeff_of_dvd_aeval","module":"Mathlib.RingTheory.Polynomial.Eisenstein.IsIntegral","initialProofState":"A : Type u_1\nB : Type u_2\ninst‚úù¬≥ : CommSemiring A\ninst‚úù¬≤ : CommRing B\ninst‚úù¬π : Algebra A B\ninst‚úù : NoZeroSMulDivisors A B\nQ : Polynomial A\np : A\nx z : B\nhp : Ne p 0\nhQ : ‚àÄ (i : Nat), Membership.mem (Finset.range (HAdd.hAdd Q.natDegree 1)) i ‚Üí Dvd.dvd p (Q.coeff i)\nhz : Eq ((Polynomial.aeval x) Q) (HSMul.hSMul p z)\n‚ä¢ Membership.mem (Algebra.adjoin A (Singleton.singleton x)) z","decl":"theorem mem_adjoin_of_dvd_coeff_of_dvd_aeval {A B : Type*} [CommSemiring A] [CommRing B]\n    [Algebra A B] [NoZeroSMulDivisors A B] {Q : A[X]} {p : A} {x z : B} (hp : p ‚â† 0)\n    (hQ : ‚àÄ i ‚àà range (Q.natDegree + 1), p ‚à£ Q.coeff i) (hz : aeval x Q = p ‚Ä¢ z) :\n    z ‚àà adjoin A ({x} : Set B) := by\n  choose! f hf using hQ\n  rw [aeval_eq_sum_range, sum_range] at hz\n  conv_lhs at hz =>\n    congr\n    next => skip\n    ext i\n    rw [hf i (mem_range.2 (Fin.is_lt i)), ‚Üê smul_smul]\n  rw [‚Üê smul_sum] at hz\n  rw [‚Üê smul_right_injective _ hp hz]\n  exact\n    Subalgebra.sum_mem _ fun _ _ =>\n      Subalgebra.smul_mem _ (Subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton _)) _) _\n\n"}
{"name":"mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt","module":"Mathlib.RingTheory.Polynomial.Eisenstein.IsIntegral","initialProofState":"R : Type u\nK : Type v\nL : Type z\np : R\ninst‚úù¬π‚Å∞ : CommRing R\ninst‚úù‚Åπ : Field K\ninst‚úù‚Å∏ : Field L\ninst‚úù‚Å∑ : Algebra K L\ninst‚úù‚Å∂ : Algebra R L\ninst‚úù‚Åµ : Algebra R K\ninst‚úù‚Å¥ : IsScalarTower R K L\ninst‚úù¬≥ : Algebra.IsSeparable K L\ninst‚úù¬≤ : IsDomain R\ninst‚úù¬π : IsFractionRing R K\ninst‚úù : IsIntegrallyClosed R\nB : PowerBasis K L\nhp : Prime p\nhBint : IsIntegral R B.gen\nz : L\nhzint : IsIntegral R z\nhz : Membership.mem (Algebra.adjoin R (Singleton.singleton B.gen)) (HSMul.hSMul p z)\nhei : (minpoly R B.gen).IsEisensteinAt (Submodule.span R (Singleton.singleton p))\n‚ä¢ Membership.mem (Algebra.adjoin R (Singleton.singleton B.gen)) z","decl":"/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be a separable\nextension of `K`, generated by an integral power basis `B` such that the minimal polynomial of\n`B.gen` is Eisenstein at `p`. Given `z : L` integral over `R`, if `p ‚Ä¢ z ‚àà adjoin R {B.gen}`, then\n`z ‚àà adjoin R {B.gen}`. -/\ntheorem mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}\n    (hp : Prime p) (hBint : IsIntegral R B.gen) {z : L} (hzint : IsIntegral R z)\n    (hz : p ‚Ä¢ z ‚àà adjoin R ({B.gen} : Set L)) (hei : (minpoly R B.gen).IsEisensteinAt ùìü) :\n    z ‚àà adjoin R ({B.gen} : Set L) := by\n  -- First define some abbreviations.\n  have hndiv : ¬¨p ^ 2 ‚à£ (minpoly R B.gen).coeff 0 := fun h =>\n    hei.not_mem ((span_singleton_pow p 2).symm ‚ñ∏ Ideal.mem_span_singleton.2 h)\n  have := B.finite\n  set P := minpoly R B.gen with hP\n  obtain ‚ü®n, hn‚ü© := Nat.exists_eq_succ_of_ne_zero B.dim_pos.ne'\n  haveI : NoZeroSMulDivisors R L := NoZeroSMulDivisors.trans R K L\n  let _ := P.map (algebraMap R L)\n  -- There is a polynomial `Q` such that `p ‚Ä¢ z = aeval B.gen Q`. We can assume that\n  -- `Q.degree < P.degree` and `Q ‚â† 0`.\n  rw [adjoin_singleton_eq_range_aeval] at hz\n  obtain ‚ü®Q‚ÇÅ, hQ‚ü© := hz\n  set Q := Q‚ÇÅ %‚Çò P with hQ‚ÇÅ\n  replace hQ : aeval B.gen Q = p ‚Ä¢ z := by\n    rw [‚Üê modByMonic_add_div Q‚ÇÅ (minpoly.monic hBint)] at hQ\n    simpa using hQ\n  by_cases hQzero : Q = 0\n  ¬∑ simp only [hQzero, Algebra.smul_def, zero_eq_mul, aeval_zero] at hQ\n    cases' hQ with H H‚ÇÅ\n    ¬∑ have : Function.Injective (algebraMap R L) := by\n        rw [algebraMap_eq R K L]\n        exact (algebraMap K L).injective.comp (IsFractionRing.injective R K)\n      exfalso\n      exact hp.ne_zero ((injective_iff_map_eq_zero _).1 this _ H)\n    ¬∑ rw [H‚ÇÅ]\n      exact Subalgebra.zero_mem _\n  -- It is enough to prove that all coefficients of `Q` are divisible by `p`, by induction.\n  -- The base case is `dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt`.\n  refine mem_adjoin_of_dvd_coeff_of_dvd_aeval hp.ne_zero (fun i => ?_) hQ\n  induction' i using Nat.case_strong_induction_on with j hind\n  ¬∑ intro _\n    exact dvd_coeff_zero_of_aeval_eq_prime_smul_of_minpoly_isEisensteinAt hp hBint hQ hzint hei\n  ¬∑ intro hj\n    convert hp.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd (n := n) _ hndiv\n    -- Two technical results we will need about `P.natDegree` and `Q.natDegree`.\n    have H := degree_modByMonic_lt Q‚ÇÅ (minpoly.monic hBint)\n    rw [‚Üê hQ‚ÇÅ, ‚Üê hP] at H\n    replace H := Nat.lt_iff_add_one_le.1\n      (lt_of_lt_of_le\n        (lt_of_le_of_lt (Nat.lt_iff_add_one_le.1 (Nat.lt_of_succ_lt_succ (mem_range.1 hj)))\n          (lt_succ_self _)) (Nat.lt_iff_add_one_le.1 ((natDegree_lt_natDegree_iff hQzero).2 H)))\n    have Hj : Q.natDegree + 1 = j + 1 + (Q.natDegree - j) := by\n      rw [‚Üê add_comm 1, ‚Üê add_comm 1, add_assoc, add_right_inj,\n        ‚Üê Nat.add_sub_assoc (Nat.lt_of_succ_lt_succ (mem_range.1 hj)).le, add_comm,\n        Nat.add_sub_cancel]\n    -- By induction hypothesis we can find `g : ‚Ñï ‚Üí R` such that\n    -- `k ‚àà range (j + 1) ‚Üí Q.coeff k ‚Ä¢ B.gen ^ k = (algebraMap R L) p * g k ‚Ä¢ B.gen ^ k`-\n    choose! g hg using hind\n    replace hg : ‚àÄ k ‚àà range (j + 1), Q.coeff k ‚Ä¢ B.gen ^ k =\n        algebraMap R L p * g k ‚Ä¢ B.gen ^ k := by\n      intro k hk\n      rw [hg k (mem_range_succ_iff.1 hk)\n        (mem_range_succ_iff.2\n          (le_trans (mem_range_succ_iff.1 hk) (succ_le_iff.1 (mem_range_succ_iff.1 hj)).le)),\n        Algebra.smul_def, Algebra.smul_def, RingHom.map_mul, mul_assoc]\n    -- Since `minpoly R B.gen` is Eiseinstein, we can find `f : ‚Ñï ‚Üí L` such that\n    -- `(map (algebraMap R L) (minpoly R B.gen)).nat_degree ‚â§ i` implies `f i ‚àà adjoin R {B.gen}`\n    -- and `(algebraMap R L) p * f i = B.gen ^ i`. We will also need `hf‚ÇÅ`, a reformulation of this\n    -- property.\n    choose! f hf using\n      IsWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le (minpoly.aeval R B.gen)\n        (minpoly.monic hBint) hei.isWeaklyEisensteinAt\n    have hf‚ÇÅ : ‚àÄ k ‚àà (range (Q.natDegree - j)).erase 0,\n        Q.coeff (j + 1 + k) ‚Ä¢ B.gen ^ (j + 1 + k) * B.gen ^ (P.natDegree - (j + 2)) =\n        (algebraMap R L) p * Q.coeff (j + 1 + k) ‚Ä¢ f (k + P.natDegree - 1) := by\n      intro k hk\n      rw [smul_mul_assoc, ‚Üê pow_add, ‚Üê Nat.add_sub_assoc H, add_comm (j + 1) 1,\n        add_assoc (j + 1), add_comm _ (k + P.natDegree), Nat.add_sub_add_right,\n        ‚Üê (hf (k + P.natDegree - 1) _).2, mul_smul_comm]\n      rw [(minpoly.monic hBint).natDegree_map, add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]\n      ¬∑ exact Nat.zero_le _\n      ¬∑ refine one_le_iff_ne_zero.2 fun h => ?_\n        rw [h] at hk\n        simp at hk\n\n    -- The Eisenstein condition shows that `p` divides `Q.coeff j`\n    -- if `p^n.succ` divides the following multiple of `Q.coeff (succ j)^n.succ`:\n    suffices\n        p ^ n.succ ‚à£ Q.coeff (succ j) ^ n.succ *\n          (minpoly R B.gen).coeff 0 ^ (succ j + (P.natDegree - (j + 2))) by\n      convert this\n      rw [Nat.succ_eq_add_one, add_assoc, ‚Üê Nat.add_sub_assoc H, add_comm (j + 1),\n        Nat.add_sub_add_left, ‚Üê Nat.add_sub_assoc, Nat.add_sub_add_left, hP, ‚Üê\n        (minpoly.monic hBint).natDegree_map (algebraMap R K), ‚Üê\n        minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, natDegree_minpoly, hn, Nat.sub_one,\n        Nat.pred_succ]\n      omega\n\n    -- Using `hQ : aeval B.gen Q = p ‚Ä¢ z`, we write `p ‚Ä¢ z` as a sum of terms of degree less than\n    -- `j+1`, that are multiples of `p` by induction, and terms of degree at least `j+1`.\n    rw [aeval_eq_sum_range, Hj, range_add, sum_union (disjoint_range_addLeftEmbedding _ _),\n      sum_congr rfl hg, add_comm] at hQ\n    -- We multiply this equality by `B.gen ^ (P.natDegree-(j+2))`, so we can use `hf‚ÇÅ` on the terms\n    -- we didn't know were multiples of `p`, and we take the norm on both sides.\n    replace hQ := congr_arg (fun x => x * B.gen ^ (P.natDegree - (j + 2))) hQ\n    simp_rw [sum_map, addLeftEmbedding_apply, add_mul, sum_mul, mul_assoc] at hQ\n    rw [‚Üê insert_erase\n      (mem_range.2 (tsub_pos_iff_lt.2 <| Nat.lt_of_succ_lt_succ <| mem_range.1 hj)),\n      sum_insert (not_mem_erase 0 _), add_zero, sum_congr rfl hf‚ÇÅ, ‚Üê mul_sum, ‚Üê mul_sum, add_assoc,\n      ‚Üê mul_add, smul_mul_assoc, ‚Üê pow_add, Algebra.smul_def] at hQ\n    replace hQ := congr_arg (norm K) (eq_sub_of_add_eq hQ)\n\n    -- We obtain an equality of elements of `K`, but everything is integral, so we can move to `R`\n    -- and simplify `hQ`.\n    have hintsum : IsIntegral R (z * B.gen ^ (P.natDegree - (j + 2)) -\n        (‚àë x ‚àà (range (Q.natDegree - j)).erase 0,\n          Q.coeff (j + 1 + x) ‚Ä¢ f (x + P.natDegree - 1) +\n            ‚àë x ‚àà range (j + 1), g x ‚Ä¢ B.gen ^ x * B.gen ^ (P.natDegree - (j + 2)))) := by\n      refine (hzint.mul (hBint.pow _)).sub\n        (.add (.sum _ fun k hk => .smul _ ?_)\n          (.sum _ fun k _ => .mul (.smul _ (.pow hBint _)) (hBint.pow _)))\n      refine adjoin_le_integralClosure hBint (hf _ ?_).1\n      rw [(minpoly.monic hBint).natDegree_map (algebraMap R L)]\n      rw [add_comm, Nat.add_sub_assoc, le_add_iff_nonneg_right]\n      ¬∑ exact _root_.zero_le _\n      ¬∑ refine one_le_iff_ne_zero.2 fun h => ?_\n        rw [h] at hk\n        simp at hk\n    obtain ‚ü®r, hr‚ü© := isIntegral_iff.1 (isIntegral_norm K hintsum)\n    rw [Algebra.smul_def, mul_assoc, ‚Üê mul_sub, _root_.map_mul, algebraMap_apply R K L, map_pow,\n      Algebra.norm_algebraMap, _root_.map_mul, algebraMap_apply R K L, Algebra.norm_algebraMap,\n      finrank B, ‚Üê hr, PowerBasis.norm_gen_eq_coeff_zero_minpoly,\n      minpoly.isIntegrallyClosed_eq_field_fractions' K hBint, coeff_map,\n      show (-1 : K) = algebraMap R K (-1) by simp, ‚Üê map_pow, ‚Üê map_pow, ‚Üê _root_.map_mul, ‚Üê\n      map_pow, ‚Üê _root_.map_mul, ‚Üê map_pow, ‚Üê _root_.map_mul] at hQ\n    -- We can now finish the proof.\n    have hppdiv : p ^ B.dim ‚à£ p ^ B.dim * r := dvd_mul_of_dvd_left dvd_rfl _\n    rwa [‚Üê IsFractionRing.injective R K hQ, mul_comm, ‚Üê Units.coe_neg_one, mul_pow, ‚Üê\n      Units.val_pow_eq_pow_val, ‚Üê Units.val_pow_eq_pow_val, mul_assoc,\n      Units.dvd_mul_left, mul_comm, ‚Üê Nat.succ_eq_add_one, hn] at hppdiv\n\n"}
{"name":"mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt","module":"Mathlib.RingTheory.Polynomial.Eisenstein.IsIntegral","initialProofState":"R : Type u\nK : Type v\nL : Type z\np : R\ninst‚úù¬π‚Å∞ : CommRing R\ninst‚úù‚Åπ : Field K\ninst‚úù‚Å∏ : Field L\ninst‚úù‚Å∑ : Algebra K L\ninst‚úù‚Å∂ : Algebra R L\ninst‚úù‚Åµ : Algebra R K\ninst‚úù‚Å¥ : IsScalarTower R K L\ninst‚úù¬≥ : Algebra.IsSeparable K L\ninst‚úù¬≤ : IsDomain R\ninst‚úù¬π : IsFractionRing R K\ninst‚úù : IsIntegrallyClosed R\nB : PowerBasis K L\nhp : Prime p\nhBint : IsIntegral R B.gen\nn : Nat\nz : L\nhzint : IsIntegral R z\nhz : Membership.mem (Algebra.adjoin R (Singleton.singleton B.gen)) (HSMul.hSMul (HPow.hPow p n) z)\nhei : (minpoly R B.gen).IsEisensteinAt (Submodule.span R (Singleton.singleton p))\n‚ä¢ Membership.mem (Algebra.adjoin R (Singleton.singleton B.gen)) z","decl":"/-- Let `K` be the field of fraction of an integrally closed domain `R` and let `L` be a separable\nextension of `K`, generated by an integral power basis `B` such that the minimal polynomial of\n`B.gen` is Eisenstein at `p`. Given `z : L` integral over `R`, if `p ^ n ‚Ä¢ z ‚àà adjoin R {B.gen}`,\nthen `z ‚àà adjoin R {B.gen}`. Together with `Algebra.discr_mul_isIntegral_mem_adjoin` this result\noften allows to compute the ring of integers of `L`. -/\ntheorem mem_adjoin_of_smul_prime_pow_smul_of_minpoly_isEisensteinAt {B : PowerBasis K L}\n    (hp : Prime p) (hBint : IsIntegral R B.gen) {n : ‚Ñï} {z : L} (hzint : IsIntegral R z)\n    (hz : p ^ n ‚Ä¢ z ‚àà adjoin R ({B.gen} : Set L)) (hei : (minpoly R B.gen).IsEisensteinAt ùìü) :\n    z ‚àà adjoin R ({B.gen} : Set L) := by\n  induction' n with n hn\n  ¬∑ simpa using hz\n  ¬∑ rw [_root_.pow_succ', mul_smul] at hz\n    exact\n      hn (mem_adjoin_of_smul_prime_smul_of_minpoly_isEisensteinAt hp hBint (hzint.smul _) hz hei)\n\n"}
