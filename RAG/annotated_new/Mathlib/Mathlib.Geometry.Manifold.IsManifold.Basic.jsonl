{"name":"ModelWithCorners.continuous_invFun","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nself : ModelWithCorners ð•œ E H\nâŠ¢ Continuous self.invFun","decl":"/-- A structure containing information on the way a space `H` embeds in a\nmodel vector space `E` over the field `ð•œ`. This is all what is needed to\ndefine a `C^n` manifold with model space `H`, and model vector space `E`.\n\nWe require two conditions `uniqueDiffOn'` and `target_subset_closure_interior`, which\nare satisfied in the relevant cases (where `range I = univ` or a half space or a quadrant) and\nuseful for technical reasons. The former makes sure that manifold derivatives are uniquely\ndefined, the latter ensures that for `C^2` maps the second derivatives are symmetric even for points\non the boundary, as these are limit points of interior points where symmetry holds. If further\nconditions turn out to be useful, they can be added here.\n-/\n@[ext]\nstructure ModelWithCorners (ð•œ : Type*) [NontriviallyNormedField ð•œ] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] (H : Type*) [TopologicalSpace H] extends\n    PartialEquiv H E where\n  source_eq : source = univ\n  uniqueDiffOn' : UniqueDiffOn ð•œ toPartialEquiv.target\n  target_subset_closure_interior : toPartialEquiv.target âŠ† closure (interior toPartialEquiv.target)\n  continuous_toFun : Continuous toFun := by continuity\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"ModelWithCorners.continuous_toFun","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nself : ModelWithCorners ð•œ E H\nâŠ¢ Continuous â†‘self.toPartialEquiv","decl":"/-- A structure containing information on the way a space `H` embeds in a\nmodel vector space `E` over the field `ð•œ`. This is all what is needed to\ndefine a `C^n` manifold with model space `H`, and model vector space `E`.\n\nWe require two conditions `uniqueDiffOn'` and `target_subset_closure_interior`, which\nare satisfied in the relevant cases (where `range I = univ` or a half space or a quadrant) and\nuseful for technical reasons. The former makes sure that manifold derivatives are uniquely\ndefined, the latter ensures that for `C^2` maps the second derivatives are symmetric even for points\non the boundary, as these are limit points of interior points where symmetry holds. If further\nconditions turn out to be useful, they can be added here.\n-/\n@[ext]\nstructure ModelWithCorners (ð•œ : Type*) [NontriviallyNormedField ð•œ] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] (H : Type*) [TopologicalSpace H] extends\n    PartialEquiv H E where\n  source_eq : source = univ\n  uniqueDiffOn' : UniqueDiffOn ð•œ toPartialEquiv.target\n  target_subset_closure_interior : toPartialEquiv.target âŠ† closure (interior toPartialEquiv.target)\n  continuous_toFun : Continuous toFun := by continuity\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"ModelWithCorners.ext_iff","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nx y : ModelWithCorners ð•œ E H\nâŠ¢ Iff (Eq x y) (And (Eq â†‘x.toPartialEquiv â†‘y.toPartialEquiv) (And (Eq x.invFun y.invFun) (And (Eq x.source y.source) (Eq x.target y.target))))","decl":"/-- A structure containing information on the way a space `H` embeds in a\nmodel vector space `E` over the field `ð•œ`. This is all what is needed to\ndefine a `C^n` manifold with model space `H`, and model vector space `E`.\n\nWe require two conditions `uniqueDiffOn'` and `target_subset_closure_interior`, which\nare satisfied in the relevant cases (where `range I = univ` or a half space or a quadrant) and\nuseful for technical reasons. The former makes sure that manifold derivatives are uniquely\ndefined, the latter ensures that for `C^2` maps the second derivatives are symmetric even for points\non the boundary, as these are limit points of interior points where symmetry holds. If further\nconditions turn out to be useful, they can be added here.\n-/\n@[ext]\nstructure ModelWithCorners (ð•œ : Type*) [NontriviallyNormedField ð•œ] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] (H : Type*) [TopologicalSpace H] extends\n    PartialEquiv H E where\n  source_eq : source = univ\n  uniqueDiffOn' : UniqueDiffOn ð•œ toPartialEquiv.target\n  target_subset_closure_interior : toPartialEquiv.target âŠ† closure (interior toPartialEquiv.target)\n  continuous_toFun : Continuous toFun := by continuity\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"ModelWithCorners.source_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nself : ModelWithCorners ð•œ E H\nâŠ¢ Eq self.source Set.univ","decl":"/-- A structure containing information on the way a space `H` embeds in a\nmodel vector space `E` over the field `ð•œ`. This is all what is needed to\ndefine a `C^n` manifold with model space `H`, and model vector space `E`.\n\nWe require two conditions `uniqueDiffOn'` and `target_subset_closure_interior`, which\nare satisfied in the relevant cases (where `range I = univ` or a half space or a quadrant) and\nuseful for technical reasons. The former makes sure that manifold derivatives are uniquely\ndefined, the latter ensures that for `C^2` maps the second derivatives are symmetric even for points\non the boundary, as these are limit points of interior points where symmetry holds. If further\nconditions turn out to be useful, they can be added here.\n-/\n@[ext]\nstructure ModelWithCorners (ð•œ : Type*) [NontriviallyNormedField ð•œ] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] (H : Type*) [TopologicalSpace H] extends\n    PartialEquiv H E where\n  source_eq : source = univ\n  uniqueDiffOn' : UniqueDiffOn ð•œ toPartialEquiv.target\n  target_subset_closure_interior : toPartialEquiv.target âŠ† closure (interior toPartialEquiv.target)\n  continuous_toFun : Continuous toFun := by continuity\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"ModelWithCorners.mk.sizeOf_spec","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ³ : TopologicalSpace H\ninstâœÂ² : SizeOf ð•œ\ninstâœÂ¹ : SizeOf E\ninstâœ : SizeOf H\ntoPartialEquiv : PartialEquiv H E\nsource_eq : Eq toPartialEquiv.source Set.univ\nuniqueDiffOn' : UniqueDiffOn ð•œ toPartialEquiv.target\ntarget_subset_closure_interior : HasSubset.Subset toPartialEquiv.target (closure (interior toPartialEquiv.target))\ncontinuous_toFun : autoParam (Continuous â†‘toPartialEquiv) _autoâœ\ncontinuous_invFun : autoParam (Continuous toPartialEquiv.invFun) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { toPartialEquiv := toPartialEquiv, source_eq := source_eq, uniqueDiffOn' := uniqueDiffOn', target_subset_closure_interior := target_subset_closure_interior, continuous_toFun := continuous_toFun, continuous_invFun := continuous_invFun }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toPartialEquiv)) (SizeOf.sizeOf source_eq)) (SizeOf.sizeOf continuous_toFun)) (SizeOf.sizeOf continuous_invFun))","decl":"/-- A structure containing information on the way a space `H` embeds in a\nmodel vector space `E` over the field `ð•œ`. This is all what is needed to\ndefine a `C^n` manifold with model space `H`, and model vector space `E`.\n\nWe require two conditions `uniqueDiffOn'` and `target_subset_closure_interior`, which\nare satisfied in the relevant cases (where `range I = univ` or a half space or a quadrant) and\nuseful for technical reasons. The former makes sure that manifold derivatives are uniquely\ndefined, the latter ensures that for `C^2` maps the second derivatives are symmetric even for points\non the boundary, as these are limit points of interior points where symmetry holds. If further\nconditions turn out to be useful, they can be added here.\n-/\n@[ext]\nstructure ModelWithCorners (ð•œ : Type*) [NontriviallyNormedField ð•œ] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] (H : Type*) [TopologicalSpace H] extends\n    PartialEquiv H E where\n  source_eq : source = univ\n  uniqueDiffOn' : UniqueDiffOn ð•œ toPartialEquiv.target\n  target_subset_closure_interior : toPartialEquiv.target âŠ† closure (interior toPartialEquiv.target)\n  continuous_toFun : Continuous toFun := by continuity\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"ModelWithCorners.uniqueDiffOn'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nself : ModelWithCorners ð•œ E H\nâŠ¢ UniqueDiffOn ð•œ self.target","decl":"/-- A structure containing information on the way a space `H` embeds in a\nmodel vector space `E` over the field `ð•œ`. This is all what is needed to\ndefine a `C^n` manifold with model space `H`, and model vector space `E`.\n\nWe require two conditions `uniqueDiffOn'` and `target_subset_closure_interior`, which\nare satisfied in the relevant cases (where `range I = univ` or a half space or a quadrant) and\nuseful for technical reasons. The former makes sure that manifold derivatives are uniquely\ndefined, the latter ensures that for `C^2` maps the second derivatives are symmetric even for points\non the boundary, as these are limit points of interior points where symmetry holds. If further\nconditions turn out to be useful, they can be added here.\n-/\n@[ext]\nstructure ModelWithCorners (ð•œ : Type*) [NontriviallyNormedField ð•œ] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] (H : Type*) [TopologicalSpace H] extends\n    PartialEquiv H E where\n  source_eq : source = univ\n  uniqueDiffOn' : UniqueDiffOn ð•œ toPartialEquiv.target\n  target_subset_closure_interior : toPartialEquiv.target âŠ† closure (interior toPartialEquiv.target)\n  continuous_toFun : Continuous toFun := by continuity\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"ModelWithCorners.mk.inj","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\ntoPartialEquivâœ : PartialEquiv H E\nsource_eqâœ : Eq toPartialEquivâœ.source Set.univ\nuniqueDiffOn'âœ : UniqueDiffOn ð•œ toPartialEquivâœ.target\ntarget_subset_closure_interiorâœ : HasSubset.Subset toPartialEquivâœ.target (closure (interior toPartialEquivâœ.target))\ncontinuous_toFunâœ : autoParam (Continuous â†‘toPartialEquivâœ) _autoâœ\ncontinuous_invFunâœ : autoParam (Continuous toPartialEquivâœ.invFun) _autoâœ\ntoPartialEquiv : PartialEquiv H E\nsource_eq : Eq toPartialEquiv.source Set.univ\nuniqueDiffOn' : UniqueDiffOn ð•œ toPartialEquiv.target\ntarget_subset_closure_interior : HasSubset.Subset toPartialEquiv.target (closure (interior toPartialEquiv.target))\ncontinuous_toFun : autoParam (Continuous â†‘toPartialEquiv) _autoâœ\ncontinuous_invFun : autoParam (Continuous toPartialEquiv.invFun) _autoâœ\nxâœ : Eq { toPartialEquiv := toPartialEquivâœ, source_eq := source_eqâœ, uniqueDiffOn' := uniqueDiffOn'âœ, target_subset_closure_interior := target_subset_closure_interiorâœ, continuous_toFun := continuous_toFunâœ, continuous_invFun := continuous_invFunâœ } { toPartialEquiv := toPartialEquiv, source_eq := source_eq, uniqueDiffOn' := uniqueDiffOn', target_subset_closure_interior := target_subset_closure_interior, continuous_toFun := continuous_toFun, continuous_invFun := continuous_invFun }\nâŠ¢ Eq toPartialEquivâœ toPartialEquiv","decl":"/-- A structure containing information on the way a space `H` embeds in a\nmodel vector space `E` over the field `ð•œ`. This is all what is needed to\ndefine a `C^n` manifold with model space `H`, and model vector space `E`.\n\nWe require two conditions `uniqueDiffOn'` and `target_subset_closure_interior`, which\nare satisfied in the relevant cases (where `range I = univ` or a half space or a quadrant) and\nuseful for technical reasons. The former makes sure that manifold derivatives are uniquely\ndefined, the latter ensures that for `C^2` maps the second derivatives are symmetric even for points\non the boundary, as these are limit points of interior points where symmetry holds. If further\nconditions turn out to be useful, they can be added here.\n-/\n@[ext]\nstructure ModelWithCorners (ð•œ : Type*) [NontriviallyNormedField ð•œ] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] (H : Type*) [TopologicalSpace H] extends\n    PartialEquiv H E where\n  source_eq : source = univ\n  uniqueDiffOn' : UniqueDiffOn ð•œ toPartialEquiv.target\n  target_subset_closure_interior : toPartialEquiv.target âŠ† closure (interior toPartialEquiv.target)\n  continuous_toFun : Continuous toFun := by continuity\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"ModelWithCorners.target_subset_closure_interior","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nself : ModelWithCorners ð•œ E H\nâŠ¢ HasSubset.Subset self.target (closure (interior self.target))","decl":"/-- A structure containing information on the way a space `H` embeds in a\nmodel vector space `E` over the field `ð•œ`. This is all what is needed to\ndefine a `C^n` manifold with model space `H`, and model vector space `E`.\n\nWe require two conditions `uniqueDiffOn'` and `target_subset_closure_interior`, which\nare satisfied in the relevant cases (where `range I = univ` or a half space or a quadrant) and\nuseful for technical reasons. The former makes sure that manifold derivatives are uniquely\ndefined, the latter ensures that for `C^2` maps the second derivatives are symmetric even for points\non the boundary, as these are limit points of interior points where symmetry holds. If further\nconditions turn out to be useful, they can be added here.\n-/\n@[ext]\nstructure ModelWithCorners (ð•œ : Type*) [NontriviallyNormedField ð•œ] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] (H : Type*) [TopologicalSpace H] extends\n    PartialEquiv H E where\n  source_eq : source = univ\n  uniqueDiffOn' : UniqueDiffOn ð•œ toPartialEquiv.target\n  target_subset_closure_interior : toPartialEquiv.target âŠ† closure (interior toPartialEquiv.target)\n  continuous_toFun : Continuous toFun := by continuity\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"ModelWithCorners.ext","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nx y : ModelWithCorners ð•œ E H\ntoFun : Eq â†‘x.toPartialEquiv â†‘y.toPartialEquiv\ninvFun : Eq x.invFun y.invFun\nsource : Eq x.source y.source\ntarget : Eq x.target y.target\nâŠ¢ Eq x y","decl":"/-- A structure containing information on the way a space `H` embeds in a\nmodel vector space `E` over the field `ð•œ`. This is all what is needed to\ndefine a `C^n` manifold with model space `H`, and model vector space `E`.\n\nWe require two conditions `uniqueDiffOn'` and `target_subset_closure_interior`, which\nare satisfied in the relevant cases (where `range I = univ` or a half space or a quadrant) and\nuseful for technical reasons. The former makes sure that manifold derivatives are uniquely\ndefined, the latter ensures that for `C^2` maps the second derivatives are symmetric even for points\non the boundary, as these are limit points of interior points where symmetry holds. If further\nconditions turn out to be useful, they can be added here.\n-/\n@[ext]\nstructure ModelWithCorners (ð•œ : Type*) [NontriviallyNormedField ð•œ] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] (H : Type*) [TopologicalSpace H] extends\n    PartialEquiv H E where\n  source_eq : source = univ\n  uniqueDiffOn' : UniqueDiffOn ð•œ toPartialEquiv.target\n  target_subset_closure_interior : toPartialEquiv.target âŠ† closure (interior toPartialEquiv.target)\n  continuous_toFun : Continuous toFun := by continuity\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"ModelWithCorners.mk.injEq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\ntoPartialEquivâœ : PartialEquiv H E\nsource_eqâœ : Eq toPartialEquivâœ.source Set.univ\nuniqueDiffOn'âœ : UniqueDiffOn ð•œ toPartialEquivâœ.target\ntarget_subset_closure_interiorâœ : HasSubset.Subset toPartialEquivâœ.target (closure (interior toPartialEquivâœ.target))\ncontinuous_toFunâœ : autoParam (Continuous â†‘toPartialEquivâœ) _autoâœ\ncontinuous_invFunâœ : autoParam (Continuous toPartialEquivâœ.invFun) _autoâœ\ntoPartialEquiv : PartialEquiv H E\nsource_eq : Eq toPartialEquiv.source Set.univ\nuniqueDiffOn' : UniqueDiffOn ð•œ toPartialEquiv.target\ntarget_subset_closure_interior : HasSubset.Subset toPartialEquiv.target (closure (interior toPartialEquiv.target))\ncontinuous_toFun : autoParam (Continuous â†‘toPartialEquiv) _autoâœ\ncontinuous_invFun : autoParam (Continuous toPartialEquiv.invFun) _autoâœ\nâŠ¢ Eq (Eq { toPartialEquiv := toPartialEquivâœ, source_eq := source_eqâœ, uniqueDiffOn' := uniqueDiffOn'âœ, target_subset_closure_interior := target_subset_closure_interiorâœ, continuous_toFun := continuous_toFunâœ, continuous_invFun := continuous_invFunâœ } { toPartialEquiv := toPartialEquiv, source_eq := source_eq, uniqueDiffOn' := uniqueDiffOn', target_subset_closure_interior := target_subset_closure_interior, continuous_toFun := continuous_toFun, continuous_invFun := continuous_invFun }) (Eq toPartialEquivâœ toPartialEquiv)","decl":"/-- A structure containing information on the way a space `H` embeds in a\nmodel vector space `E` over the field `ð•œ`. This is all what is needed to\ndefine a `C^n` manifold with model space `H`, and model vector space `E`.\n\nWe require two conditions `uniqueDiffOn'` and `target_subset_closure_interior`, which\nare satisfied in the relevant cases (where `range I = univ` or a half space or a quadrant) and\nuseful for technical reasons. The former makes sure that manifold derivatives are uniquely\ndefined, the latter ensures that for `C^2` maps the second derivatives are symmetric even for points\non the boundary, as these are limit points of interior points where symmetry holds. If further\nconditions turn out to be useful, they can be added here.\n-/\n@[ext]\nstructure ModelWithCorners (ð•œ : Type*) [NontriviallyNormedField ð•œ] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] (H : Type*) [TopologicalSpace H] extends\n    PartialEquiv H E where\n  source_eq : source = univ\n  uniqueDiffOn' : UniqueDiffOn ð•œ toPartialEquiv.target\n  target_subset_closure_interior : toPartialEquiv.target âŠ† closure (interior toPartialEquiv.target)\n  continuous_toFun : Continuous toFun := by continuity\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"ModelWithCorners.toPartialEquiv_coe","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nâŠ¢ Eq â†‘I.toPartialEquiv â†‘I","decl":"@[simp, mfld_simps]\ntheorem toPartialEquiv_coe : (I.toPartialEquiv : H â†’ E) = I :=\n  rfl\n\n"}
{"name":"ModelWithCorners.mk_coe","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\ne : PartialEquiv H E\na : Eq e.source Set.univ\nb : UniqueDiffOn ð•œ e.target\nc : HasSubset.Subset e.target (closure (interior e.target))\nd : Continuous â†‘e\nd' : Continuous e.invFun\nâŠ¢ Eq â†‘{ toPartialEquiv := e, source_eq := a, uniqueDiffOn' := b, target_subset_closure_interior := c, continuous_toFun := d, continuous_invFun := d' } â†‘e","decl":"@[simp, mfld_simps]\ntheorem mk_coe (e : PartialEquiv H E) (a b c d d') :\n    ((ModelWithCorners.mk e a b c d d' : ModelWithCorners ð•œ E H) : H â†’ E) = (e : H â†’ E) :=\n  rfl\n\n"}
{"name":"ModelWithCorners.toPartialEquiv_coe_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nâŠ¢ Eq â†‘I.symm â†‘I.symm","decl":"@[simp, mfld_simps]\ntheorem toPartialEquiv_coe_symm : (I.toPartialEquiv.symm : E â†’ H) = I.symm :=\n  rfl\n\n"}
{"name":"ModelWithCorners.mk_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\ne : PartialEquiv H E\na : Eq e.source Set.univ\nb : UniqueDiffOn ð•œ e.target\nc : HasSubset.Subset e.target (closure (interior e.target))\nd : Continuous â†‘e\nd' : Continuous e.invFun\nâŠ¢ Eq { toPartialEquiv := e, source_eq := a, uniqueDiffOn' := b, target_subset_closure_interior := c, continuous_toFun := d, continuous_invFun := d' }.symm e.symm","decl":"@[simp, mfld_simps]\ntheorem mk_symm (e : PartialEquiv H E) (a b c d d') :\n    (ModelWithCorners.mk e a b c d d' : ModelWithCorners ð•œ E H).symm = e.symm :=\n  rfl\n\n"}
{"name":"ModelWithCorners.continuous","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nâŠ¢ Continuous â†‘I","decl":"@[continuity]\nprotected theorem continuous : Continuous I :=\n  I.continuous_toFun\n\n"}
{"name":"ModelWithCorners.continuousAt","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nx : H\nâŠ¢ ContinuousAt (â†‘I) x","decl":"protected theorem continuousAt {x} : ContinuousAt I x :=\n  I.continuous.continuousAt\n\n"}
{"name":"ModelWithCorners.continuousWithinAt","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\ns : Set H\nx : H\nâŠ¢ ContinuousWithinAt (â†‘I) s x","decl":"protected theorem continuousWithinAt {s x} : ContinuousWithinAt I s x :=\n  I.continuousAt.continuousWithinAt\n\n"}
{"name":"ModelWithCorners.continuous_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nâŠ¢ Continuous â†‘I.symm","decl":"@[continuity]\ntheorem continuous_symm : Continuous I.symm :=\n  I.continuous_invFun\n\n"}
{"name":"ModelWithCorners.continuousAt_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nx : E\nâŠ¢ ContinuousAt (â†‘I.symm) x","decl":"theorem continuousAt_symm {x} : ContinuousAt I.symm x :=\n  I.continuous_symm.continuousAt\n\n"}
{"name":"ModelWithCorners.continuousWithinAt_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\ns : Set E\nx : E\nâŠ¢ ContinuousWithinAt (â†‘I.symm) s x","decl":"theorem continuousWithinAt_symm {s x} : ContinuousWithinAt I.symm s x :=\n  I.continuous_symm.continuousWithinAt\n\n"}
{"name":"ModelWithCorners.continuousOn_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\ns : Set E\nâŠ¢ ContinuousOn (â†‘I.symm) s","decl":"theorem continuousOn_symm {s} : ContinuousOn I.symm s :=\n  I.continuous_symm.continuousOn\n\n"}
{"name":"ModelWithCorners.target_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nâŠ¢ Eq I.target (Set.range â†‘I)","decl":"@[simp, mfld_simps]\ntheorem target_eq : I.target = range (I : H â†’ E) := by\n  rw [â† image_univ, â† I.source_eq]\n  exact I.image_source_eq_target.symm\n\n"}
{"name":"ModelWithCorners.uniqueDiffOn","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nâŠ¢ UniqueDiffOn ð•œ (Set.range â†‘I)","decl":"protected theorem uniqueDiffOn : UniqueDiffOn ð•œ (range I) :=\n  I.target_eq â–¸ I.uniqueDiffOn'\n\n"}
{"name":"ModelWithCorners.unique_diff","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nâŠ¢ UniqueDiffOn ð•œ (Set.range â†‘I)","decl":"@[deprecated (since := \"2024-09-30\")]\nprotected alias unique_diff := ModelWithCorners.uniqueDiffOn\n\n"}
{"name":"ModelWithCorners.range_subset_closure_interior","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nâŠ¢ HasSubset.Subset (Set.range â†‘I) (closure (interior (Set.range â†‘I)))","decl":"theorem range_subset_closure_interior : range I âŠ† closure (interior (range I)) := by\n  rw [â† I.target_eq]\n  exact I.target_subset_closure_interior\n\n"}
{"name":"ModelWithCorners.left_inv","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nx : H\nâŠ¢ Eq (â†‘I.symm (â†‘I x)) x","decl":"@[simp, mfld_simps]\nprotected theorem left_inv (x : H) : I.symm (I x) = x := by refine I.left_inv' ?_; simp\n\n"}
{"name":"ModelWithCorners.leftInverse","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nâŠ¢ Function.LeftInverse â†‘I.symm â†‘I","decl":"protected theorem leftInverse : LeftInverse I.symm I :=\n  I.left_inv\n\n"}
{"name":"ModelWithCorners.injective","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nâŠ¢ Function.Injective â†‘I","decl":"theorem injective : Injective I :=\n  I.leftInverse.injective\n\n"}
{"name":"ModelWithCorners.symm_comp_self","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nâŠ¢ Eq (Function.comp â†‘I.symm â†‘I) id","decl":"@[simp, mfld_simps]\ntheorem symm_comp_self : I.symm âˆ˜ I = id :=\n  I.leftInverse.comp_eq_id\n\n"}
{"name":"ModelWithCorners.rightInvOn","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nâŠ¢ Set.RightInvOn (â†‘I.symm) (â†‘I) (Set.range â†‘I)","decl":"protected theorem rightInvOn : RightInvOn I.symm I (range I) :=\n  I.leftInverse.rightInvOn_range\n\n"}
{"name":"ModelWithCorners.right_inv","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nx : E\nhx : Membership.mem (Set.range â†‘I) x\nâŠ¢ Eq (â†‘I (â†‘I.symm x)) x","decl":"@[simp, mfld_simps]\nprotected theorem right_inv {x : E} (hx : x âˆˆ range I) : I (I.symm x) = x :=\n  I.rightInvOn hx\n\n"}
{"name":"ModelWithCorners.preimage_image","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\ns : Set H\nâŠ¢ Eq (Set.preimage (â†‘I) (Set.image (â†‘I) s)) s","decl":"theorem preimage_image (s : Set H) : I â»Â¹' (I '' s) = s :=\n  I.injective.preimage_image s\n\n"}
{"name":"ModelWithCorners.image_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\ns : Set H\nâŠ¢ Eq (Set.image (â†‘I) s) (Inter.inter (Set.preimage (â†‘I.symm) s) (Set.range â†‘I))","decl":"protected theorem image_eq (s : Set H) : I '' s = I.symm â»Â¹' s âˆ© range I := by\n  refine (I.toPartialEquiv.image_eq_target_inter_inv_preimage ?_).trans ?_\n  Â· rw [I.source_eq]; exact subset_univ _\n  Â· rw [inter_comm, I.target_eq, I.toPartialEquiv_coe_symm]\n\n"}
{"name":"ModelWithCorners.isClosedEmbedding","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nâŠ¢ Topology.IsClosedEmbedding â†‘I","decl":"theorem isClosedEmbedding : IsClosedEmbedding I :=\n  I.leftInverse.isClosedEmbedding I.continuous_symm I.continuous\n\n"}
{"name":"ModelWithCorners.closedEmbedding","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nâŠ¢ Topology.IsClosedEmbedding â†‘I","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding := isClosedEmbedding\n\n"}
{"name":"ModelWithCorners.isClosed_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nâŠ¢ IsClosed (Set.range â†‘I)","decl":"theorem isClosed_range : IsClosed (range I) :=\n  I.isClosedEmbedding.isClosed_range\n\n\n"}
{"name":"ModelWithCorners.range_eq_closure_interior","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nâŠ¢ Eq (Set.range â†‘I) (closure (interior (Set.range â†‘I)))","decl":"theorem range_eq_closure_interior : range I = closure (interior (range I)) :=\n  Subset.antisymm I.range_subset_closure_interior I.isClosed_range.closure_interior_subset\n\n"}
{"name":"ModelWithCorners.map_nhds_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nx : H\nâŠ¢ Eq (Filter.map (â†‘I) (nhds x)) (nhdsWithin (â†‘I x) (Set.range â†‘I))","decl":"theorem map_nhds_eq (x : H) : map I (ð“ x) = ð“[range I] I x :=\n  I.isClosedEmbedding.isEmbedding.map_nhds_eq x\n\n"}
{"name":"ModelWithCorners.map_nhdsWithin_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\ns : Set H\nx : H\nâŠ¢ Eq (Filter.map (â†‘I) (nhdsWithin x s)) (nhdsWithin (â†‘I x) (Set.image (â†‘I) s))","decl":"theorem map_nhdsWithin_eq (s : Set H) (x : H) : map I (ð“[s] x) = ð“[I '' s] I x :=\n  I.isClosedEmbedding.isEmbedding.map_nhdsWithin_eq s x\n\n"}
{"name":"ModelWithCorners.image_mem_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nx : H\ns : Set H\nhs : Membership.mem (nhds x) s\nâŠ¢ Membership.mem (nhdsWithin (â†‘I x) (Set.range â†‘I)) (Set.image (â†‘I) s)","decl":"theorem image_mem_nhdsWithin {x : H} {s : Set H} (hs : s âˆˆ ð“ x) : I '' s âˆˆ ð“[range I] I x :=\n  I.map_nhds_eq x â–¸ image_mem_map hs\n\n"}
{"name":"ModelWithCorners.symm_map_nhdsWithin_image","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nx : H\ns : Set H\nâŠ¢ Eq (Filter.map (â†‘I.symm) (nhdsWithin (â†‘I x) (Set.image (â†‘I) s))) (nhdsWithin x s)","decl":"theorem symm_map_nhdsWithin_image {x : H} {s : Set H} : map I.symm (ð“[I '' s] I x) = ð“[s] x := by\n  rw [â† I.map_nhdsWithin_eq, map_map, I.symm_comp_self, map_id]\n\n"}
{"name":"ModelWithCorners.symm_map_nhdsWithin_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nx : H\nâŠ¢ Eq (Filter.map (â†‘I.symm) (nhdsWithin (â†‘I x) (Set.range â†‘I))) (nhds x)","decl":"theorem symm_map_nhdsWithin_range (x : H) : map I.symm (ð“[range I] I x) = ð“ x := by\n  rw [â† I.map_nhds_eq, map_map, I.symm_comp_self, map_id]\n\n"}
{"name":"ModelWithCorners.uniqueDiffOn_preimage","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\ns : Set H\nhs : IsOpen s\nâŠ¢ UniqueDiffOn ð•œ (Inter.inter (Set.preimage (â†‘I.symm) s) (Set.range â†‘I))","decl":"theorem uniqueDiffOn_preimage {s : Set H} (hs : IsOpen s) :\n    UniqueDiffOn ð•œ (I.symm â»Â¹' s âˆ© range I) := by\n  rw [inter_comm]\n  exact I.uniqueDiffOn.inter (hs.preimage I.continuous_invFun)\n\n"}
{"name":"ModelWithCorners.unique_diff_preimage","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\ns : Set H\nhs : IsOpen s\nâŠ¢ UniqueDiffOn ð•œ (Inter.inter (Set.preimage (â†‘I.symm) s) (Set.range â†‘I))","decl":"@[deprecated (since := \"2024-09-30\")]\nalias unique_diff_preimage := uniqueDiffOn_preimage\n\n"}
{"name":"ModelWithCorners.uniqueDiffOn_preimage_source","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ¹ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nÎ² : Type u_4\ninstâœ : TopologicalSpace Î²\ne : PartialHomeomorph H Î²\nâŠ¢ UniqueDiffOn ð•œ (Inter.inter (Set.preimage (â†‘I.symm) e.source) (Set.range â†‘I))","decl":"theorem uniqueDiffOn_preimage_source {Î² : Type*} [TopologicalSpace Î²] {e : PartialHomeomorph H Î²} :\n    UniqueDiffOn ð•œ (I.symm â»Â¹' e.source âˆ© range I) :=\n  I.uniqueDiffOn_preimage e.open_source\n\n"}
{"name":"ModelWithCorners.unique_diff_preimage_source","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ¹ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nÎ² : Type u_4\ninstâœ : TopologicalSpace Î²\ne : PartialHomeomorph H Î²\nâŠ¢ UniqueDiffOn ð•œ (Inter.inter (Set.preimage (â†‘I.symm) e.source) (Set.range â†‘I))","decl":"@[deprecated (since := \"2024-09-30\")]\nalias unique_diff_preimage_source := uniqueDiffOn_preimage_source\n\n"}
{"name":"ModelWithCorners.uniqueDiffWithinAt_image","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nx : H\nâŠ¢ UniqueDiffWithinAt ð•œ (Set.range â†‘I) (â†‘I x)","decl":"theorem uniqueDiffWithinAt_image {x : H} : UniqueDiffWithinAt ð•œ (range I) (I x) :=\n  I.uniqueDiffOn _ (mem_range_self _)\n\n"}
{"name":"ModelWithCorners.unique_diff_at_image","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nx : H\nâŠ¢ UniqueDiffWithinAt ð•œ (Set.range â†‘I) (â†‘I x)","decl":"@[deprecated (since := \"2024-09-30\")]\nalias unique_diff_at_image := uniqueDiffWithinAt_image\n\n"}
{"name":"ModelWithCorners.symm_continuousWithinAt_comp_right_iff","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ¹ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nX : Type u_4\ninstâœ : TopologicalSpace X\nf : H â†’ X\ns : Set H\nx : H\nâŠ¢ Iff (ContinuousWithinAt (Function.comp f â†‘I.symm) (Inter.inter (Set.preimage (â†‘I.symm) s) (Set.range â†‘I)) (â†‘I x)) (ContinuousWithinAt f s x)","decl":"theorem symm_continuousWithinAt_comp_right_iff {X} [TopologicalSpace X] {f : H â†’ X} {s : Set H}\n    {x : H} :\n    ContinuousWithinAt (f âˆ˜ I.symm) (I.symm â»Â¹' s âˆ© range I) (I x) â†” ContinuousWithinAt f s x := by\n  refine âŸ¨fun h => ?_, fun h => ?_âŸ©\n  Â· have := h.comp I.continuousWithinAt (mapsTo_preimage _ _)\n    simp_rw [preimage_inter, preimage_preimage, I.left_inv, preimage_id', preimage_range,\n      inter_univ] at this\n    rwa [Function.comp_assoc, I.symm_comp_self] at this\n  Â· rw [â† I.left_inv x] at h; exact h.comp I.continuousWithinAt_symm inter_subset_left\n\n"}
{"name":"ModelWithCorners.locallyCompactSpace","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : LocallyCompactSpace E\nI : ModelWithCorners ð•œ E H\nâŠ¢ LocallyCompactSpace H","decl":"protected theorem locallyCompactSpace [LocallyCompactSpace E] (I : ModelWithCorners ð•œ E H) :\n    LocallyCompactSpace H := by\n  have : âˆ€ x : H, (ð“ x).HasBasis (fun s => s âˆˆ ð“ (I x) âˆ§ IsCompact s)\n      fun s => I.symm '' (s âˆ© range I) := fun x â†¦ by\n    rw [â† I.symm_map_nhdsWithin_range]\n    exact ((compact_basis_nhds (I x)).inf_principal _).map _\n  refine .of_hasBasis this ?_\n  rintro x s âŸ¨-, hscâŸ©\n  exact (hsc.inter_right I.isClosed_range).image I.continuous_symm\n\n"}
{"name":"ModelWithCorners.secondCountableTopology","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : SecondCountableTopology E\nI : ModelWithCorners ð•œ E H\nâŠ¢ SecondCountableTopology H","decl":"protected theorem secondCountableTopology [SecondCountableTopology E] (I : ModelWithCorners ð•œ E H) :\n    SecondCountableTopology H :=\n  I.isClosedEmbedding.isEmbedding.secondCountableTopology\n\n"}
{"name":"ModelWithCorners.t1Space","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nâŠ¢ T1Space M","decl":"include I in\n/-- Every manifold is a FrÃ©chet space (T1 space) -- regardless of whether it is\nHausdorff. -/\nprotected theorem t1Space (M : Type*) [TopologicalSpace M] [ChartedSpace H M] : T1Space M := by\n  have : T2Space H := I.isClosedEmbedding.toIsEmbedding.t2Space\n  exact ChartedSpace.t1Space H M\n\n"}
{"name":"modelWithCornersSelf_partialEquiv","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ð•œ E\nâŠ¢ Eq (modelWithCornersSelf ð•œ E).toPartialEquiv (PartialEquiv.refl E)","decl":"/-- In the trivial model with corners, the associated `PartialEquiv` is the identity. -/\n@[simp, mfld_simps]\ntheorem modelWithCornersSelf_partialEquiv : ð“˜(ð•œ, E).toPartialEquiv = PartialEquiv.refl E :=\n  rfl\n\n"}
{"name":"modelWithCornersSelf_coe","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ð•œ E\nâŠ¢ Eq (â†‘(modelWithCornersSelf ð•œ E)) id","decl":"@[simp, mfld_simps]\ntheorem modelWithCornersSelf_coe : (ð“˜(ð•œ, E) : E â†’ E) = id :=\n  rfl\n\n"}
{"name":"modelWithCornersSelf_coe_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ð•œ E\nâŠ¢ Eq (â†‘(modelWithCornersSelf ð•œ E).symm) id","decl":"@[simp, mfld_simps]\ntheorem modelWithCornersSelf_coe_symm : (ð“˜(ð•œ, E).symm : E â†’ E) = id :=\n  rfl\n\n"}
{"name":"ModelWithCorners.prod_source","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ð•œ\nE : Type v\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\nH : Type w\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nE' : Type v'\ninstâœÂ² : NormedAddCommGroup E'\ninstâœÂ¹ : NormedSpace ð•œ E'\nH' : Type w'\ninstâœ : TopologicalSpace H'\nI' : ModelWithCorners ð•œ E' H'\nâŠ¢ Eq (I.prod I').source (setOf fun x => And (Membership.mem I.source x.1) (Membership.mem I'.source x.2))","decl":"/-- Given two model_with_corners `I` on `(E, H)` and `I'` on `(E', H')`, we define the model with\ncorners `I.prod I'` on `(E Ã— E', ModelProd H H')`. This appears in particular for the manifold\nstructure on the tangent bundle to a manifold modelled on `(E, H)`: it will be modelled on\n`(E Ã— E, H Ã— E)`. See note [Manifold type tags] for explanation about `ModelProd H H'`\nvs `H Ã— H'`. -/\n@[simps (config := .lemmasOnly)]\ndef ModelWithCorners.prod {ð•œ : Type u} [NontriviallyNormedField ð•œ] {E : Type v}\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] {H : Type w} [TopologicalSpace H]\n    (I : ModelWithCorners ð•œ E H) {E' : Type v'} [NormedAddCommGroup E'] [NormedSpace ð•œ E']\n    {H' : Type w'} [TopologicalSpace H'] (I' : ModelWithCorners ð•œ E' H') :\n    ModelWithCorners ð•œ (E Ã— E') (ModelProd H H') :=\n  { I.toPartialEquiv.prod I'.toPartialEquiv with\n    toFun := fun x => (I x.1, I' x.2)\n    invFun := fun x => (I.symm x.1, I'.symm x.2)\n    source := { x | x.1 âˆˆ I.source âˆ§ x.2 âˆˆ I'.source }\n    source_eq := by simp only [setOf_true, mfld_simps]\n    uniqueDiffOn' := I.uniqueDiffOn'.prod I'.uniqueDiffOn'\n    target_subset_closure_interior := by\n      simp only [PartialEquiv.prod_target, target_eq, interior_prod_eq, closure_prod_eq]\n      exact Set.prod_mono I.range_subset_closure_interior I'.range_subset_closure_interior\n    continuous_toFun := I.continuous_toFun.prodMap I'.continuous_toFun\n    continuous_invFun := I.continuous_invFun.prodMap I'.continuous_invFun }\n\n"}
{"name":"ModelWithCorners.prod_symm_apply","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ð•œ\nE : Type v\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\nH : Type w\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nE' : Type v'\ninstâœÂ² : NormedAddCommGroup E'\ninstâœÂ¹ : NormedSpace ð•œ E'\nH' : Type w'\ninstâœ : TopologicalSpace H'\nI' : ModelWithCorners ð•œ E' H'\nx : Prod E E'\nâŠ¢ Eq (â†‘(I.prod I').symm x) { fst := â†‘I.symm x.1, snd := â†‘I'.symm x.2 }","decl":"/-- Given two model_with_corners `I` on `(E, H)` and `I'` on `(E', H')`, we define the model with\ncorners `I.prod I'` on `(E Ã— E', ModelProd H H')`. This appears in particular for the manifold\nstructure on the tangent bundle to a manifold modelled on `(E, H)`: it will be modelled on\n`(E Ã— E, H Ã— E)`. See note [Manifold type tags] for explanation about `ModelProd H H'`\nvs `H Ã— H'`. -/\n@[simps (config := .lemmasOnly)]\ndef ModelWithCorners.prod {ð•œ : Type u} [NontriviallyNormedField ð•œ] {E : Type v}\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] {H : Type w} [TopologicalSpace H]\n    (I : ModelWithCorners ð•œ E H) {E' : Type v'} [NormedAddCommGroup E'] [NormedSpace ð•œ E']\n    {H' : Type w'} [TopologicalSpace H'] (I' : ModelWithCorners ð•œ E' H') :\n    ModelWithCorners ð•œ (E Ã— E') (ModelProd H H') :=\n  { I.toPartialEquiv.prod I'.toPartialEquiv with\n    toFun := fun x => (I x.1, I' x.2)\n    invFun := fun x => (I.symm x.1, I'.symm x.2)\n    source := { x | x.1 âˆˆ I.source âˆ§ x.2 âˆˆ I'.source }\n    source_eq := by simp only [setOf_true, mfld_simps]\n    uniqueDiffOn' := I.uniqueDiffOn'.prod I'.uniqueDiffOn'\n    target_subset_closure_interior := by\n      simp only [PartialEquiv.prod_target, target_eq, interior_prod_eq, closure_prod_eq]\n      exact Set.prod_mono I.range_subset_closure_interior I'.range_subset_closure_interior\n    continuous_toFun := I.continuous_toFun.prodMap I'.continuous_toFun\n    continuous_invFun := I.continuous_invFun.prodMap I'.continuous_invFun }\n\n"}
{"name":"ModelWithCorners.prod_apply","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ð•œ\nE : Type v\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\nH : Type w\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nE' : Type v'\ninstâœÂ² : NormedAddCommGroup E'\ninstâœÂ¹ : NormedSpace ð•œ E'\nH' : Type w'\ninstâœ : TopologicalSpace H'\nI' : ModelWithCorners ð•œ E' H'\nx : ModelProd H H'\nâŠ¢ Eq (â†‘(I.prod I') x) { fst := â†‘I x.1, snd := â†‘I' x.2 }","decl":"/-- Given two model_with_corners `I` on `(E, H)` and `I'` on `(E', H')`, we define the model with\ncorners `I.prod I'` on `(E Ã— E', ModelProd H H')`. This appears in particular for the manifold\nstructure on the tangent bundle to a manifold modelled on `(E, H)`: it will be modelled on\n`(E Ã— E, H Ã— E)`. See note [Manifold type tags] for explanation about `ModelProd H H'`\nvs `H Ã— H'`. -/\n@[simps (config := .lemmasOnly)]\ndef ModelWithCorners.prod {ð•œ : Type u} [NontriviallyNormedField ð•œ] {E : Type v}\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] {H : Type w} [TopologicalSpace H]\n    (I : ModelWithCorners ð•œ E H) {E' : Type v'} [NormedAddCommGroup E'] [NormedSpace ð•œ E']\n    {H' : Type w'} [TopologicalSpace H'] (I' : ModelWithCorners ð•œ E' H') :\n    ModelWithCorners ð•œ (E Ã— E') (ModelProd H H') :=\n  { I.toPartialEquiv.prod I'.toPartialEquiv with\n    toFun := fun x => (I x.1, I' x.2)\n    invFun := fun x => (I.symm x.1, I'.symm x.2)\n    source := { x | x.1 âˆˆ I.source âˆ§ x.2 âˆˆ I'.source }\n    source_eq := by simp only [setOf_true, mfld_simps]\n    uniqueDiffOn' := I.uniqueDiffOn'.prod I'.uniqueDiffOn'\n    target_subset_closure_interior := by\n      simp only [PartialEquiv.prod_target, target_eq, interior_prod_eq, closure_prod_eq]\n      exact Set.prod_mono I.range_subset_closure_interior I'.range_subset_closure_interior\n    continuous_toFun := I.continuous_toFun.prodMap I'.continuous_toFun\n    continuous_invFun := I.continuous_invFun.prodMap I'.continuous_invFun }\n\n"}
{"name":"ModelWithCorners.prod_target","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u\ninstâœâ¶ : NontriviallyNormedField ð•œ\nE : Type v\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\nH : Type w\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nE' : Type v'\ninstâœÂ² : NormedAddCommGroup E'\ninstâœÂ¹ : NormedSpace ð•œ E'\nH' : Type w'\ninstâœ : TopologicalSpace H'\nI' : ModelWithCorners ð•œ E' H'\nâŠ¢ Eq (I.prod I').target (I.prod I'.toPartialEquiv).target","decl":"/-- Given two model_with_corners `I` on `(E, H)` and `I'` on `(E', H')`, we define the model with\ncorners `I.prod I'` on `(E Ã— E', ModelProd H H')`. This appears in particular for the manifold\nstructure on the tangent bundle to a manifold modelled on `(E, H)`: it will be modelled on\n`(E Ã— E, H Ã— E)`. See note [Manifold type tags] for explanation about `ModelProd H H'`\nvs `H Ã— H'`. -/\n@[simps (config := .lemmasOnly)]\ndef ModelWithCorners.prod {ð•œ : Type u} [NontriviallyNormedField ð•œ] {E : Type v}\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] {H : Type w} [TopologicalSpace H]\n    (I : ModelWithCorners ð•œ E H) {E' : Type v'} [NormedAddCommGroup E'] [NormedSpace ð•œ E']\n    {H' : Type w'} [TopologicalSpace H'] (I' : ModelWithCorners ð•œ E' H') :\n    ModelWithCorners ð•œ (E Ã— E') (ModelProd H H') :=\n  { I.toPartialEquiv.prod I'.toPartialEquiv with\n    toFun := fun x => (I x.1, I' x.2)\n    invFun := fun x => (I.symm x.1, I'.symm x.2)\n    source := { x | x.1 âˆˆ I.source âˆ§ x.2 âˆˆ I'.source }\n    source_eq := by simp only [setOf_true, mfld_simps]\n    uniqueDiffOn' := I.uniqueDiffOn'.prod I'.uniqueDiffOn'\n    target_subset_closure_interior := by\n      simp only [PartialEquiv.prod_target, target_eq, interior_prod_eq, closure_prod_eq]\n      exact Set.prod_mono I.range_subset_closure_interior I'.range_subset_closure_interior\n    continuous_toFun := I.continuous_toFun.prodMap I'.continuous_toFun\n    continuous_invFun := I.continuous_invFun.prodMap I'.continuous_invFun }\n\n"}
{"name":"modelWithCorners_prod_toPartialEquiv","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ð•œ F\nH : Type u_5\ninstâœÂ¹ : TopologicalSpace H\nG : Type u_7\ninstâœ : TopologicalSpace G\nI : ModelWithCorners ð•œ E H\nJ : ModelWithCorners ð•œ F G\nâŠ¢ Eq (I.prod J).toPartialEquiv (I.prod J.toPartialEquiv)","decl":"@[simp, mfld_simps]\ntheorem modelWithCorners_prod_toPartialEquiv :\n    (I.prod J).toPartialEquiv = I.toPartialEquiv.prod J.toPartialEquiv :=\n  rfl\n\n"}
{"name":"modelWithCorners_prod_coe","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\nE' : Type u_3\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ð•œ E'\nH : Type u_5\ninstâœÂ¹ : TopologicalSpace H\nH' : Type u_6\ninstâœ : TopologicalSpace H'\nI : ModelWithCorners ð•œ E H\nI' : ModelWithCorners ð•œ E' H'\nâŠ¢ Eq (â†‘(I.prod I')) (Prod.map â†‘I â†‘I')","decl":"@[simp, mfld_simps]\ntheorem modelWithCorners_prod_coe (I : ModelWithCorners ð•œ E H) (I' : ModelWithCorners ð•œ E' H') :\n    (I.prod I' : _ Ã— _ â†’ _ Ã— _) = Prod.map I I' :=\n  rfl\n\n"}
{"name":"modelWithCorners_prod_coe_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\nE' : Type u_3\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ð•œ E'\nH : Type u_5\ninstâœÂ¹ : TopologicalSpace H\nH' : Type u_6\ninstâœ : TopologicalSpace H'\nI : ModelWithCorners ð•œ E H\nI' : ModelWithCorners ð•œ E' H'\nâŠ¢ Eq (â†‘(I.prod I').symm) (Prod.map â†‘I.symm â†‘I'.symm)","decl":"@[simp, mfld_simps]\ntheorem modelWithCorners_prod_coe_symm (I : ModelWithCorners ð•œ E H)\n    (I' : ModelWithCorners ð•œ E' H') :\n    ((I.prod I').symm : _ Ã— _ â†’ _ Ã— _) = Prod.map I.symm I'.symm :=\n  rfl\n\n"}
{"name":"modelWithCornersSelf_prod","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\nF : Type u_4\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nâŠ¢ Eq (modelWithCornersSelf ð•œ (Prod E F)) ((modelWithCornersSelf ð•œ E).prod (modelWithCornersSelf ð•œ F))","decl":"/-- This lemma should be erased, or at least burn in hell, as it uses bad defeq: the left model\nwith corners is for `E times F`, the right one for `ModelProd E F`, and there's a good reason\nwe are distinguishing them. -/\ntheorem modelWithCornersSelf_prod : ð“˜(ð•œ, E Ã— F) = ð“˜(ð•œ, E).prod ð“˜(ð•œ, F) := by ext1 <;> simp\n\n"}
{"name":"ModelWithCorners.range_prod","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\nF : Type u_4\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ð•œ F\nH : Type u_5\ninstâœÂ¹ : TopologicalSpace H\nG : Type u_7\ninstâœ : TopologicalSpace G\nI : ModelWithCorners ð•œ E H\nJ : ModelWithCorners ð•œ F G\nâŠ¢ Eq (Set.range â†‘(I.prod J)) (SProd.sprod (Set.range â†‘I) (Set.range â†‘J))","decl":"theorem ModelWithCorners.range_prod : range (I.prod J) = range I Ã—Ë¢ range J := by\n  simp_rw [â† ModelWithCorners.target_eq]; rfl\n\n"}
{"name":"ModelWithCorners.Boundaryless.range_eq_univ","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nself : I.Boundaryless\nâŠ¢ Eq (Set.range â†‘I) Set.univ","decl":"/-- Property ensuring that the model with corners `I` defines manifolds without boundary. This\n  differs from the more general `BoundarylessManifold`, which requires every point on the manifold\n  to be an interior point. -/\nclass ModelWithCorners.Boundaryless {ð•œ : Type*} [NontriviallyNormedField ð•œ] {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] {H : Type*} [TopologicalSpace H]\n    (I : ModelWithCorners ð•œ E H) : Prop where\n  range_eq_univ : range I = univ\n\n"}
{"name":"ModelWithCorners.range_eq_univ","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ¹ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\ninstâœ : I.Boundaryless\nâŠ¢ Eq (Set.range â†‘I) Set.univ","decl":"theorem ModelWithCorners.range_eq_univ {ð•œ : Type*} [NontriviallyNormedField ð•œ] {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] {H : Type*} [TopologicalSpace H]\n    (I : ModelWithCorners ð•œ E H) [I.Boundaryless] :\n    range I = univ := ModelWithCorners.Boundaryless.range_eq_univ\n\n"}
{"name":"ModelWithCorners.toHomeomorph_symm_apply","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ¹ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\ninstâœ : I.Boundaryless\naâœ : E\nâŠ¢ Eq (I.toHomeomorph.symm aâœ) (â†‘I.symm aâœ)","decl":"/-- If `I` is a `ModelWithCorners.Boundaryless` model, then it is a homeomorphism. -/\n@[simps (config := {simpRhs := true})]\ndef ModelWithCorners.toHomeomorph {ð•œ : Type*} [NontriviallyNormedField ð•œ] {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] {H : Type*} [TopologicalSpace H]\n    (I : ModelWithCorners ð•œ E H) [I.Boundaryless] : H â‰ƒâ‚œ E where\n  __ := I\n  left_inv := I.left_inv\n  right_inv _ := I.right_inv <| I.range_eq_univ.symm â–¸ mem_univ _\n\n"}
{"name":"ModelWithCorners.toHomeomorph_apply","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ¹ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\ninstâœ : I.Boundaryless\naâœ : H\nâŠ¢ Eq (I.toHomeomorph aâœ) (â†‘I aâœ)","decl":"/-- If `I` is a `ModelWithCorners.Boundaryless` model, then it is a homeomorphism. -/\n@[simps (config := {simpRhs := true})]\ndef ModelWithCorners.toHomeomorph {ð•œ : Type*} [NontriviallyNormedField ð•œ] {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] {H : Type*} [TopologicalSpace H]\n    (I : ModelWithCorners ð•œ E H) [I.Boundaryless] : H â‰ƒâ‚œ E where\n  __ := I\n  left_inv := I.left_inv\n  right_inv _ := I.right_inv <| I.range_eq_univ.symm â–¸ mem_univ _\n\n"}
{"name":"modelWithCornersSelf_boundaryless","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ð•œ E\nâŠ¢ (modelWithCornersSelf ð•œ E).Boundaryless","decl":"/-- The trivial model with corners has no boundary -/\ninstance modelWithCornersSelf_boundaryless (ð•œ : Type*) [NontriviallyNormedField ð•œ] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] : (modelWithCornersSelf ð•œ E).Boundaryless :=\n  âŸ¨by simpâŸ©\n\n"}
{"name":"ModelWithCorners.range_eq_univ_prod","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u\ninstâœâ¸ : NontriviallyNormedField ð•œ\nE : Type v\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ð•œ E\nH : Type w\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\ninstâœâ´ : I.Boundaryless\nE' : Type v'\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ð•œ E'\nH' : Type w'\ninstâœÂ¹ : TopologicalSpace H'\nI' : ModelWithCorners ð•œ E' H'\ninstâœ : I'.Boundaryless\nâŠ¢ (I.prod I').Boundaryless","decl":"/-- If two model with corners are boundaryless, their product also is -/\ninstance ModelWithCorners.range_eq_univ_prod {ð•œ : Type u} [NontriviallyNormedField ð•œ] {E : Type v}\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] {H : Type w} [TopologicalSpace H]\n    (I : ModelWithCorners ð•œ E H) [I.Boundaryless] {E' : Type v'} [NormedAddCommGroup E']\n    [NormedSpace ð•œ E'] {H' : Type w'} [TopologicalSpace H'] (I' : ModelWithCorners ð•œ E' H')\n    [I'.Boundaryless] : (I.prod I').Boundaryless := by\n  constructor\n  dsimp [ModelWithCorners.prod, ModelProd]\n  rw [â† prod_range_range_eq, ModelWithCorners.Boundaryless.range_eq_univ,\n    ModelWithCorners.Boundaryless.range_eq_univ, univ_prod_univ]\n\n"}
{"name":"contDiffGroupoid_le","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"m n : WithTop ENat\nð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nh : LE.le m n\nâŠ¢ LE.le (contDiffGroupoid n I) (contDiffGroupoid m I)","decl":"/-- Inclusion of the groupoid of `C^n` local diffeos in the groupoid of `C^m` local diffeos when\n`m â‰¤ n` -/\ntheorem contDiffGroupoid_le (h : m â‰¤ n) : contDiffGroupoid n I â‰¤ contDiffGroupoid m I := by\n  rw [contDiffGroupoid, contDiffGroupoid]\n  apply groupoid_of_pregroupoid_le\n  intro f s hfs\n  exact ContDiffOn.of_le hfs h\n\n"}
{"name":"contDiffGroupoid_zero_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nâŠ¢ Eq (contDiffGroupoid 0 I) (continuousGroupoid H)","decl":"/-- The groupoid of `0`-times continuously differentiable maps is just the groupoid of all\npartial homeomorphisms -/\ntheorem contDiffGroupoid_zero_eq : contDiffGroupoid 0 I = continuousGroupoid H := by\n  apply le_antisymm le_top\n  intro u _\n  -- we have to check that every partial homeomorphism belongs to `contDiffGroupoid 0 I`,\n  -- by unfolding its definition\n  change u âˆˆ contDiffGroupoid 0 I\n  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid, contDiffPregroupoid]\n  simp only [contDiffOn_zero]\n  constructor\n  Â· refine I.continuous.comp_continuousOn (u.continuousOn.comp I.continuousOn_symm ?_)\n    exact (mapsTo_preimage _ _).mono_left inter_subset_left\n  Â· refine I.continuous.comp_continuousOn (u.symm.continuousOn.comp I.continuousOn_symm ?_)\n    exact (mapsTo_preimage _ _).mono_left inter_subset_left\n\n-- FIXME: does this generalise to other groupoids? The argument is not specific\n-- to C^n functions, but uses something about the groupoid's property that is not easy to abstract.\n"}
{"name":"ContDiffGroupoid.mem_of_source_eq_empty","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"n : WithTop ENat\nð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nf : PartialHomeomorph H H\nhf : Eq f.source EmptyCollection.emptyCollection\nâŠ¢ Membership.mem (contDiffGroupoid n I) f","decl":"/-- Any change of coordinates with empty source belongs to `contDiffGroupoid`. -/\nlemma ContDiffGroupoid.mem_of_source_eq_empty (f : PartialHomeomorph H H)\n    (hf : f.source = âˆ…) : f âˆˆ contDiffGroupoid n I := by\n  constructor\n  Â· intro x âŸ¨hx, _âŸ©\n    rw [mem_preimage] at hx\n    simp_all only [mem_empty_iff_false]\n  Â· intro x âŸ¨hx, _âŸ©\n    have : f.target = âˆ… := by simp [â† f.image_source_eq_target, hf]\n    simp_all [hx]\n\n"}
{"name":"ContinuousGroupoid.mem_of_source_eq_empty","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nf : PartialHomeomorph H H\nhf : Eq f.source EmptyCollection.emptyCollection\nâŠ¢ Membership.mem (continuousGroupoid H) f","decl":"include I in\n/-- Any change of coordinates with empty source belongs to `continuousGroupoid`. -/\nlemma ContinuousGroupoid.mem_of_source_eq_empty (f : PartialHomeomorph H H)\n    (hf : f.source = âˆ…) : f âˆˆ continuousGroupoid H := by\n  rw [â† contDiffGroupoid_zero_eq (I := I)]\n  exact ContDiffGroupoid.mem_of_source_eq_empty f hf\n\n"}
{"name":"ofSet_mem_contDiffGroupoid","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"n : WithTop ENat\nð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\ns : Set H\nhs : IsOpen s\nâŠ¢ Membership.mem (contDiffGroupoid n I) (PartialHomeomorph.ofSet s hs)","decl":"/-- An identity partial homeomorphism belongs to the `C^n` groupoid. -/\ntheorem ofSet_mem_contDiffGroupoid {s : Set H} (hs : IsOpen s) :\n    PartialHomeomorph.ofSet s hs âˆˆ contDiffGroupoid n I := by\n  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid]\n  suffices h : ContDiffOn ð•œ n (I âˆ˜ I.symm) (I.symm â»Â¹' s âˆ© range I) by\n    simp [h, contDiffPregroupoid]\n  have : ContDiffOn ð•œ n id (univ : Set E) := contDiff_id.contDiffOn\n  exact this.congr_mono (fun x hx => I.right_inv hx.2) (subset_univ _)\n\n"}
{"name":"symm_trans_mem_contDiffGroupoid","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"n : WithTop ENat\nð•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ¹ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœ : TopologicalSpace M\ne : PartialHomeomorph M H\nâŠ¢ Membership.mem (contDiffGroupoid n I) (e.symm.trans e)","decl":"/-- The composition of a partial homeomorphism from `H` to `M` and its inverse belongs to\nthe `C^n` groupoid. -/\ntheorem symm_trans_mem_contDiffGroupoid (e : PartialHomeomorph M H) :\n    e.symm.trans e âˆˆ contDiffGroupoid n I :=\n  haveI : e.symm.trans e â‰ˆ PartialHomeomorph.ofSet e.target e.open_target :=\n    PartialHomeomorph.symm_trans_self _\n  StructureGroupoid.mem_of_eqOnSource _ (ofSet_mem_contDiffGroupoid e.open_target) this\n\n"}
{"name":"contDiffGroupoid_prod","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"n : WithTop ENat\nð•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ³ : TopologicalSpace H\nE' : Type u_5\nH' : Type u_6\ninstâœÂ² : NormedAddCommGroup E'\ninstâœÂ¹ : NormedSpace ð•œ E'\ninstâœ : TopologicalSpace H'\nI : ModelWithCorners ð•œ E H\nI' : ModelWithCorners ð•œ E' H'\ne : PartialHomeomorph H H\ne' : PartialHomeomorph H' H'\nhe : Membership.mem (contDiffGroupoid n I) e\nhe' : Membership.mem (contDiffGroupoid n I') e'\nâŠ¢ Membership.mem (contDiffGroupoid n (I.prod I')) (e.prod e')","decl":"/-- The product of two `C^n` partial homeomorphisms is `C^n`. -/\ntheorem contDiffGroupoid_prod {I : ModelWithCorners ð•œ E H} {I' : ModelWithCorners ð•œ E' H'}\n    {e : PartialHomeomorph H H} {e' : PartialHomeomorph H' H'} (he : e âˆˆ contDiffGroupoid n I)\n    (he' : e' âˆˆ contDiffGroupoid n I') : e.prod e' âˆˆ contDiffGroupoid n (I.prod I') := by\n  cases' he with he he_symm\n  cases' he' with he' he'_symm\n  simp only at he he_symm he' he'_symm\n  constructor <;> simp only [PartialEquiv.prod_source, PartialHomeomorph.prod_toPartialEquiv,\n    contDiffPregroupoid]\n  Â· have h3 := ContDiffOn.prod_map he he'\n    rw [â† I.image_eq, â† I'.image_eq, prod_image_image_eq] at h3\n    rw [â† (I.prod I').image_eq]\n    exact h3\n  Â· have h3 := ContDiffOn.prod_map he_symm he'_symm\n    rw [â† I.image_eq, â† I'.image_eq, prod_image_image_eq] at h3\n    rw [â† (I.prod I').image_eq]\n    exact h3\n\n"}
{"name":"instClosedUnderRestrictionContDiffGroupoid","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"n : WithTop ENat\nð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nâŠ¢ ClosedUnderRestriction (contDiffGroupoid n I)","decl":"/-- The `C^n` groupoid is closed under restriction. -/\ninstance : ClosedUnderRestriction (contDiffGroupoid n I) :=\n  (closedUnderRestriction_iff_id_le _).mpr\n    (by\n      rw [StructureGroupoid.le_iff]\n      rintro e âŸ¨s, hs, hesâŸ©\n      apply (contDiffGroupoid n I).mem_of_eqOnSource' _ _ _ hes\n      exact ofSet_mem_contDiffGroupoid hs)\n\n"}
{"name":"IsManifold.toHasGroupoid","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nn : WithTop ENat\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nself : IsManifold I n M\nâŠ¢ HasGroupoid M (contDiffGroupoid n I)","decl":"/-- Typeclass defining manifolds with respect to a model with corners, over a\nfield `ð•œ`. This definition includes the model with corners `I` (which might allow boundary, corners,\nor not, so this class covers both manifolds with boundary and manifolds without boundary), and\na smoothness parameter `n : WithTop â„•âˆž` (where `n = 0` means topological manifold, `n = âˆž` means\nsmooth manifold and `n = Ï‰` means analytic manifold). -/\nclass IsManifold {ð•œ : Type*} [NontriviallyNormedField ð•œ] {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] {H : Type*} [TopologicalSpace H]\n    (I : ModelWithCorners ð•œ E H) (n : WithTop â„•âˆž) (M : Type*)\n    [TopologicalSpace M] [ChartedSpace H M] extends\n    HasGroupoid M (contDiffGroupoid n I) : Prop\n\n"}
{"name":"IsManifold.mk'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nn : WithTop ENat\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ngr : HasGroupoid M (contDiffGroupoid n I)\nâŠ¢ IsManifold I n M","decl":"/-- Building a `C^n` manifold from a `HasGroupoid` assumption. -/\ntheorem IsManifold.mk' {ð•œ : Type*} [NontriviallyNormedField ð•œ] {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] {H : Type*} [TopologicalSpace H]\n    (I : ModelWithCorners ð•œ E H) (n : WithTop â„•âˆž)\n    (M : Type*) [TopologicalSpace M] [ChartedSpace H M]\n    [gr : HasGroupoid M (contDiffGroupoid n I)] : IsManifold I n M :=\n  { gr with }\n\n"}
{"name":"SmoothManifoldWithCorners.mk'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nn : WithTop ENat\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ngr : HasGroupoid M (contDiffGroupoid n I)\nâŠ¢ IsManifold I n M","decl":"@[deprecated (since := \"2025-01-09\")] alias SmoothManifoldWithCorners.mk' := IsManifold.mk'\n\n"}
{"name":"isManifold_of_contDiffOn","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nn : WithTop ENat\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nh : âˆ€ (e e' : PartialHomeomorph M H), Membership.mem (atlas H M) e â†’ Membership.mem (atlas H M) e' â†’ ContDiffOn ð•œ n (Function.comp (â†‘I) (Function.comp â†‘(e.symm.trans e') â†‘I.symm)) (Inter.inter (Set.preimage (â†‘I.symm) (e.symm.trans e').source) (Set.range â†‘I))\nâŠ¢ IsManifold I n M","decl":"theorem isManifold_of_contDiffOn {ð•œ : Type*} [NontriviallyNormedField ð•œ]\n    {E : Type*} [NormedAddCommGroup E] [NormedSpace ð•œ E] {H : Type*} [TopologicalSpace H]\n    (I : ModelWithCorners ð•œ E H) (n : WithTop â„•âˆž) (M : Type*)\n    [TopologicalSpace M] [ChartedSpace H M]\n    (h : âˆ€ e e' : PartialHomeomorph M H, e âˆˆ atlas H M â†’ e' âˆˆ atlas H M â†’\n      ContDiffOn ð•œ n (I âˆ˜ e.symm â‰«â‚• e' âˆ˜ I.symm) (I.symm â»Â¹' (e.symm â‰«â‚• e').source âˆ© range I)) :\n    IsManifold I n M where\n  compatible := by\n    haveI : HasGroupoid M (contDiffGroupoid n I) := hasGroupoid_of_pregroupoid _ (h _ _)\n    apply StructureGroupoid.compatible\n\n"}
{"name":"smoothManifoldWithCorners_of_contDiffOn","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nn : WithTop ENat\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nh : âˆ€ (e e' : PartialHomeomorph M H), Membership.mem (atlas H M) e â†’ Membership.mem (atlas H M) e' â†’ ContDiffOn ð•œ n (Function.comp (â†‘I) (Function.comp â†‘(e.symm.trans e') â†‘I.symm)) (Inter.inter (Set.preimage (â†‘I.symm) (e.symm.trans e').source) (Set.range â†‘I))\nâŠ¢ IsManifold I n M","decl":"@[deprecated (since := \"2025-01-09\")]\nalias smoothManifoldWithCorners_of_contDiffOn := isManifold_of_contDiffOn\n\n"}
{"name":"intIsManifoldModelSpace","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\nH : Type u_3\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nn : WithTop ENat\nâŠ¢ IsManifold I n H","decl":"/-- For any model with corners, the model space is a `C^n` manifold -/\ninstance intIsManifoldModelSpace {ð•œ : Type*} [NontriviallyNormedField ð•œ] {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace ð•œ E] {H : Type*} [TopologicalSpace H]\n    {I : ModelWithCorners ð•œ E H} {n : WithTop â„•âˆž} : IsManifold I n H :=\n  { hasGroupoid_model_space _ _ with }\n\n"}
{"name":"IsManifold.of_le","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\nm n : WithTop ENat\nhmn : LE.le m n\ninstâœ : IsManifold I n M\nâŠ¢ IsManifold I m M","decl":"protected theorem of_le {m n : WithTop â„•âˆž} (hmn : m â‰¤ n)\n    [IsManifold I n M] : IsManifold I m M := by\n  have : HasGroupoid M (contDiffGroupoid m I) :=\n    hasGroupoid_of_le (Gâ‚ := contDiffGroupoid n I) (by infer_instance)\n      (contDiffGroupoid_le hmn)\n  exact mk' I m M\n\n"}
{"name":"ENat.LEInfty.out","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"m : WithTop ENat\nself : ENat.LEInfty m\nâŠ¢ LE.le m â†‘Top.top","decl":"/-- A typeclass registering that a smoothness exponent is smaller than `âˆž`. Used to deduce that\nsome manifolds are `C^n` when they are `C^âˆž`. -/\nclass _root_.ENat.LEInfty (m : WithTop â„•âˆž) where\n  out : m â‰¤ âˆž\n\n"}
{"name":"IsManifold.instLEInftyCastWithTopENat","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"n : Nat\nâŠ¢ ENat.LEInfty â†‘n","decl":"instance (n : â„•) : LEInfty (n : WithTop â„•âˆž) := âŸ¨mod_cast le_topâŸ©\n"}
{"name":"IsManifold.instLEInftyOfNatWithTopENat","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"n : Nat\ninstâœ : n.AtLeastTwo\nâŠ¢ ENat.LEInfty (OfNat.ofNat n)","decl":"instance (n : â„•) [n.AtLeastTwo] : LEInfty (no_index (OfNat.ofNat n) : WithTop â„•âˆž) :=\n  inferInstanceAs (LEInfty (n : WithTop â„•âˆž))\n"}
{"name":"IsManifold.instLEInftyOfNatWithTopENat_1","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"âŠ¢ ENat.LEInfty 1","decl":"instance : LEInfty (1 : WithTop â„•âˆž) := inferInstanceAs (LEInfty ((1 : â„•) : WithTop â„•âˆž))\n"}
{"name":"IsManifold.instLEInftyOfNatWithTopENat_2","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"âŠ¢ ENat.LEInfty 0","decl":"instance : LEInfty (0 : WithTop â„•âˆž) := inferInstanceAs (LEInfty ((0 : â„•) : WithTop â„•âˆž))\n\n"}
{"name":"IsManifold.instOfSomeENatTopOfLEInfty","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\na : WithTop ENat\ninstâœ : IsManifold I (â†‘Top.top) M\nh : ENat.LEInfty a\nâŠ¢ IsManifold I a M","decl":"instance {a : WithTop â„•âˆž} [IsManifold I âˆž M] [h : LEInfty a] :\n    IsManifold I a M :=\n  IsManifold.of_le h.out\n\n"}
{"name":"IsManifold.instOfTopWithTopENat","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\na : WithTop ENat\ninstâœ : IsManifold I Top.top M\nâŠ¢ IsManifold I a M","decl":"instance {a : WithTop â„•âˆž} [IsManifold I Ï‰ M] :\n    IsManifold I a M :=\n  IsManifold.of_le le_top\n\n"}
{"name":"IsManifold.instOfNatWithTopENat","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nâŠ¢ IsManifold I 0 M","decl":"instance : IsManifold I 0 M := by\n  suffices HasGroupoid M (contDiffGroupoid 0 I) from mk' I 0 M\n  constructor\n  intro e e' he he'\n  rw [contDiffGroupoid_zero_eq]\n  trivial\n\n"}
{"name":"IsManifold.instOfNatWithTopENat_1","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : IsManifold I 2 M\nâŠ¢ IsManifold I 1 M","decl":"instance [IsManifold I 2 M] :\n    IsManifold I 1 M :=\n  IsManifold.of_le one_le_two\n\n"}
{"name":"IsManifold.subset_maximalAtlas","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nn : WithTop ENat\nM : Type u_4\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : IsManifold I n M\nâŠ¢ HasSubset.Subset (atlas H M) (IsManifold.maximalAtlas I n M)","decl":"theorem subset_maximalAtlas [IsManifold I n M] : atlas H M âŠ† maximalAtlas I n M :=\n  StructureGroupoid.subset_maximalAtlas _\n\n"}
{"name":"IsManifold.chart_mem_maximalAtlas","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nn : WithTop ENat\nM : Type u_4\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : IsManifold I n M\nx : M\nâŠ¢ Membership.mem (IsManifold.maximalAtlas I n M) (chartAt H x)","decl":"theorem chart_mem_maximalAtlas [IsManifold I n M] (x : M) :\n    chartAt H x âˆˆ maximalAtlas I n M :=\n  StructureGroupoid.chart_mem_maximalAtlas _ x\n\n"}
{"name":"IsManifold.compatible_of_mem_maximalAtlas","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nn : WithTop ENat\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\ne e' : PartialHomeomorph M H\nhe : Membership.mem (IsManifold.maximalAtlas I n M) e\nhe' : Membership.mem (IsManifold.maximalAtlas I n M) e'\nâŠ¢ Membership.mem (contDiffGroupoid n I) (e.symm.trans e')","decl":"theorem compatible_of_mem_maximalAtlas {e e' : PartialHomeomorph M H} (he : e âˆˆ maximalAtlas I n M)\n    (he' : e' âˆˆ maximalAtlas I n M) : e.symm.trans e' âˆˆ contDiffGroupoid n I :=\n  StructureGroupoid.compatible_of_mem_maximalAtlas he he'\n\n"}
{"name":"IsManifold.maximalAtlas_subset_of_le","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nm n : WithTop ENat\nh : LE.le m n\nâŠ¢ HasSubset.Subset (IsManifold.maximalAtlas I n M) (IsManifold.maximalAtlas I m M)","decl":"lemma maximalAtlas_subset_of_le {m n : WithTop â„•âˆž} (h : m â‰¤ n) :\n    maximalAtlas I n M âŠ† maximalAtlas I m M :=\n  StructureGroupoid.maximalAtlas_mono (contDiffGroupoid_le h)\n\n"}
{"name":"IsManifold.empty","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nn : WithTop ENat\nM : Type u_4\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : IsEmpty M\nâŠ¢ IsManifold I n M","decl":"/-- The empty set is a `C^n` manifold w.r.t. any charted space and model. -/\ninstance empty [IsEmpty M] : IsManifold I n M := by\n  apply isManifold_of_contDiffOn\n  intro e e' _ _ x hx\n  set t := I.symm â»Â¹' (e.symm â‰«â‚• e').source âˆ© range I\n  -- Since `M` is empty, the condition about compatibility of transition maps is vacuous.\n  have : (e.symm â‰«â‚• e').source = âˆ… := calc (e.symm â‰«â‚• e').source\n    _ = (e.symm.source) âˆ© e.symm â»Â¹' e'.source := by rw [â† PartialHomeomorph.trans_source]\n    _ = (e.symm.source) âˆ© e.symm â»Â¹' âˆ… := by rw [eq_empty_of_isEmpty (e'.source)]\n    _ = (e.symm.source) âˆ© âˆ… := by rw [preimage_empty]\n    _ = âˆ… := inter_empty e.symm.source\n  have : t = âˆ… := calc t\n    _ = I.symm â»Â¹' (e.symm â‰«â‚• e').source âˆ© range I := by\n      rw [â† Subtype.preimage_val_eq_preimage_val_iff]\n    _ = âˆ… âˆ© range I := by rw [this, preimage_empty]\n    _ = âˆ… := empty_inter (range I)\n  apply (this â–¸ hx).elim\n\n"}
{"name":"IsManifold.prod","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"n : WithTop ENat\nð•œ : Type u_5\ninstâœÂ¹Â² : NontriviallyNormedField ð•œ\nE : Type u_6\ninstâœÂ¹Â¹ : NormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace ð•œ E\nE' : Type u_7\ninstâœâ¹ : NormedAddCommGroup E'\ninstâœâ¸ : NormedSpace ð•œ E'\nH : Type u_8\ninstâœâ· : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nH' : Type u_9\ninstâœâ¶ : TopologicalSpace H'\nI' : ModelWithCorners ð•œ E' H'\nM : Type u_10\ninstâœâµ : TopologicalSpace M\ninstâœâ´ : ChartedSpace H M\ninstâœÂ³ : IsManifold I n M\nM' : Type u_11\ninstâœÂ² : TopologicalSpace M'\ninstâœÂ¹ : ChartedSpace H' M'\ninstâœ : IsManifold I' n M'\nâŠ¢ IsManifold (I.prod I') n (Prod M M')","decl":"/-- The product of two `C^n` manifolds is naturally a `C^n` manifold. -/\ninstance prod {ð•œ : Type*} [NontriviallyNormedField ð•œ] {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace ð•œ E] {E' : Type*} [NormedAddCommGroup E'] [NormedSpace ð•œ E'] {H : Type*}\n    [TopologicalSpace H] {I : ModelWithCorners ð•œ E H} {H' : Type*} [TopologicalSpace H']\n    {I' : ModelWithCorners ð•œ E' H'} (M : Type*) [TopologicalSpace M] [ChartedSpace H M]\n    [IsManifold I n M] (M' : Type*) [TopologicalSpace M'] [ChartedSpace H' M']\n    [IsManifold I' n M'] :\n    IsManifold (I.prod I') n (M Ã— M') where\n  compatible := by\n    rintro f g âŸ¨f1, hf1, f2, hf2, rflâŸ© âŸ¨g1, hg1, g2, hg2, rflâŸ©\n    rw [PartialHomeomorph.prod_symm, PartialHomeomorph.prod_trans]\n    have h1 := (contDiffGroupoid n I).compatible hf1 hg1\n    have h2 := (contDiffGroupoid n I').compatible hf2 hg2\n    exact contDiffGroupoid_prod h1 h2\n\n"}
{"name":"IsManifold.disjointUnion","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ð•œ E\nH : Type u_3\ninstâœâµ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nn : WithTop ENat\nM : Type u_4\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace H M\nM' : Type u_5\ninstâœÂ² : TopologicalSpace M'\ninstâœÂ¹ : ChartedSpace H M'\ninstâœ : Nonempty H\nâŠ¢ IsManifold I n (Sum M M')","decl":"/-- The disjoint union of two `C^n` manifolds modelled on `(E, H)`\nis a `C^n` manifold modeled on `(E, H)`. -/\ninstance disjointUnion [Nonempty H] : IsManifold I n (M âŠ• M') where\n  compatible {e} e' he he' := by\n    obtain (âŸ¨f, hf, hefâŸ© | âŸ¨f, hf, hefâŸ©) := ChartedSpace.mem_atlas_sum he\n    Â· obtain (âŸ¨f', hf', he'f'âŸ© | âŸ¨f', hf', he'f'âŸ©) := ChartedSpace.mem_atlas_sum he'\n      Â· rw [hef, he'f', f.lift_openEmbedding_trans f' IsOpenEmbedding.inl]\n        exact hM.compatible hf hf'\n      Â· rw [hef, he'f']\n        apply ContDiffGroupoid.mem_of_source_eq_empty\n        ext x\n        exact âŸ¨fun âŸ¨hxâ‚, hxâ‚‚âŸ© â†¦ by simp_all [hxâ‚‚], fun hx â†¦ hx.elimâŸ©\n    Â· -- Analogous argument to the first case: is there a way to deduplicate?\n      obtain (âŸ¨f', hf', he'f'âŸ© | âŸ¨f', hf', he'f'âŸ©) := ChartedSpace.mem_atlas_sum he'\n      Â· rw [hef, he'f']\n        apply ContDiffGroupoid.mem_of_source_eq_empty\n        ext x\n        exact âŸ¨fun âŸ¨hxâ‚, hxâ‚‚âŸ© â†¦ by simp_all [hxâ‚‚], fun hx â†¦ hx.elimâŸ©\n      Â· rw [hef, he'f', f.lift_openEmbedding_trans f' IsOpenEmbedding.inr]\n        exact hM'.compatible hf hf'\n\n"}
{"name":"PartialHomeomorph.isManifold_singleton","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ¹ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nn : WithTop ENat\nM : Type u_4\ninstâœ : TopologicalSpace M\ne : PartialHomeomorph M H\nh : Eq e.source Set.univ\nâŠ¢ IsManifold I n M","decl":"theorem PartialHomeomorph.isManifold_singleton\n    {ð•œ : Type*} [NontriviallyNormedField ð•œ] {E : Type*} [NormedAddCommGroup E] [NormedSpace ð•œ E]\n    {H : Type*} [TopologicalSpace H] {I : ModelWithCorners ð•œ E H} {n : WithTop â„•âˆž}\n    {M : Type*} [TopologicalSpace M] (e : PartialHomeomorph M H) (h : e.source = Set.univ) :\n    @IsManifold ð•œ _ E _ _ H _ I n M _ (e.singletonChartedSpace h) :=\n  @IsManifold.mk' _ _ _ _ _ _ _ _ _ _ _ (id _) <|\n    e.singleton_hasGroupoid h (contDiffGroupoid n I)\n\n"}
{"name":"PartialHomeomorph.singleton_smoothManifoldWithCorners","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ¹ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nn : WithTop ENat\nM : Type u_4\ninstâœ : TopologicalSpace M\ne : PartialHomeomorph M H\nh : Eq e.source Set.univ\nâŠ¢ IsManifold I n M","decl":"@[deprecated (since := \"2025-01-09\")]\nalias PartialHomeomorph.singleton_smoothManifoldWithCorners :=\n  PartialHomeomorph.isManifold_singleton\n\n"}
{"name":"Topology.IsOpenEmbedding.isManifold_singleton","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nH : Type u_3\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nn : WithTop ENat\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : Nonempty M\nf : M â†’ H\nh : Topology.IsOpenEmbedding f\nâŠ¢ IsManifold I n M","decl":"theorem Topology.IsOpenEmbedding.isManifold_singleton {ð•œ E H : Type*}\n    [NontriviallyNormedField ð•œ] [NormedAddCommGroup E] [NormedSpace ð•œ E] [TopologicalSpace H]\n    {I : ModelWithCorners ð•œ E H} {n : WithTop â„•âˆž}\n    {M : Type*} [TopologicalSpace M] [Nonempty M] {f : M â†’ H} (h : IsOpenEmbedding f) :\n    @IsManifold ð•œ _ E _ _ H _ I n M _ h.singletonChartedSpace :=\n  (h.toPartialHomeomorph f).isManifold_singleton (by simp)\n\n"}
{"name":"Topology.IsOpenEmbedding.singleton_smoothManifoldWithCorners","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nH : Type u_3\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nn : WithTop ENat\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : Nonempty M\nf : M â†’ H\nh : Topology.IsOpenEmbedding f\nâŠ¢ IsManifold I n M","decl":"@[deprecated (since := \"2025-01-09\")]\nalias Topology.IsOpenEmbedding.singleton_smoothManifoldWithCorners :=\n  Topology.IsOpenEmbedding.isManifold_singleton\n\n"}
{"name":"OpenEmbedding.singleton_smoothManifoldWithCorners","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nH : Type u_3\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nn : WithTop ENat\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : Nonempty M\nf : M â†’ H\nh : Topology.IsOpenEmbedding f\nâŠ¢ IsManifold I n M","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.singleton_smoothManifoldWithCorners :=\n  Topology.IsOpenEmbedding.isManifold_singleton\n\n"}
{"name":"TopologicalSpace.Opens.instIsManifoldSubtypeMem","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ³ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nn : WithTop ENat\nM : Type u_4\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : IsManifold I n M\ns : TopologicalSpace.Opens M\nâŠ¢ IsManifold I n (Subtype fun x => Membership.mem s x)","decl":"instance : IsManifold I n s :=\n  { s.instHasGroupoid (contDiffGroupoid n I) with }\n\n"}
{"name":"PartialHomeomorph.extend_coe","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nâŠ¢ Eq (â†‘(f.extend I)) (Function.comp â†‘I â†‘f)","decl":"theorem extend_coe : â‡‘(f.extend I) = I âˆ˜ f :=\n  rfl\n\n"}
{"name":"PartialHomeomorph.extend_coe_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nâŠ¢ Eq (â†‘(f.extend I).symm) (Function.comp â†‘f.symm â†‘I.symm)","decl":"theorem extend_coe_symm : â‡‘(f.extend I).symm = f.symm âˆ˜ I.symm :=\n  rfl\n\n"}
{"name":"PartialHomeomorph.extend_source","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nâŠ¢ Eq (f.extend I).source f.source","decl":"theorem extend_source : (f.extend I).source = f.source := by\n  rw [extend, PartialEquiv.trans_source, I.source_eq, preimage_univ, inter_univ]\n\n"}
{"name":"PartialHomeomorph.isOpen_extend_source","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nâŠ¢ IsOpen (f.extend I).source","decl":"theorem isOpen_extend_source : IsOpen (f.extend I).source := by\n  rw [extend_source]\n  exact f.open_source\n\n"}
{"name":"PartialHomeomorph.extend_target","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nâŠ¢ Eq (f.extend I).target (Inter.inter (Set.preimage (â†‘I.symm) f.target) (Set.range â†‘I))","decl":"theorem extend_target : (f.extend I).target = I.symm â»Â¹' f.target âˆ© range I := by\n  simp_rw [extend, PartialEquiv.trans_target, I.target_eq, I.toPartialEquiv_coe_symm, inter_comm]\n\n"}
{"name":"PartialHomeomorph.extend_target'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nâŠ¢ Eq (f.extend I).target (Set.image (â†‘I) f.target)","decl":"theorem extend_target' : (f.extend I).target = I '' f.target := by\n  rw [extend, PartialEquiv.trans_target'', I.source_eq, univ_inter, I.toPartialEquiv_coe]\n\n"}
{"name":"PartialHomeomorph.isOpen_extend_target","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ninstâœ : I.Boundaryless\nâŠ¢ IsOpen (f.extend I).target","decl":"lemma isOpen_extend_target [I.Boundaryless] : IsOpen (f.extend I).target := by\n  rw [extend_target, I.range_eq_univ, inter_univ]\n  exact I.continuous_symm.isOpen_preimage _ f.open_target\n\n"}
{"name":"PartialHomeomorph.mapsTo_extend","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ns : Set M\nhs : HasSubset.Subset s f.source\nâŠ¢ Set.MapsTo (â†‘(f.extend I)) s (Inter.inter (Set.preimage (â†‘(f.extend I).symm) s) (Set.range â†‘I))","decl":"theorem mapsTo_extend (hs : s âŠ† f.source) :\n    MapsTo (f.extend I) s ((f.extend I).symm â»Â¹' s âˆ© range I) := by\n  rw [mapsTo', extend_coe, extend_coe_symm, preimage_comp, â† I.image_eq, image_comp,\n    f.image_eq_target_inter_inv_preimage hs]\n  exact image_subset _ inter_subset_right\n\n"}
{"name":"PartialHomeomorph.extend_left_inv","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nx : M\nhxf : Membership.mem f.source x\nâŠ¢ Eq (â†‘(f.extend I).symm (â†‘(f.extend I) x)) x","decl":"theorem extend_left_inv {x : M} (hxf : x âˆˆ f.source) : (f.extend I).symm (f.extend I x) = x :=\n  (f.extend I).left_inv <| by rwa [f.extend_source]\n\n"}
{"name":"PartialHomeomorph.extend_left_inv'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nt : Set M\nht : HasSubset.Subset t f.source\nâŠ¢ Eq (Set.image (Function.comp â†‘(f.extend I).symm â†‘(f.extend I)) t) t","decl":"/-- Variant of `f.extend_left_inv I`, stated in terms of images. -/\nlemma extend_left_inv' (ht : t âŠ† f.source) : ((f.extend I).symm âˆ˜ (f.extend I)) '' t = t :=\n  EqOn.image_eq_self (fun _ hx â†¦ f.extend_left_inv (ht hx))\n\n"}
{"name":"PartialHomeomorph.extend_source_mem_nhds","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nx : M\nh : Membership.mem f.source x\nâŠ¢ Membership.mem (nhds x) (f.extend I).source","decl":"theorem extend_source_mem_nhds {x : M} (h : x âˆˆ f.source) : (f.extend I).source âˆˆ ð“ x :=\n  (isOpen_extend_source f).mem_nhds <| by rwa [f.extend_source]\n\n"}
{"name":"PartialHomeomorph.extend_source_mem_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ns : Set M\nx : M\nh : Membership.mem f.source x\nâŠ¢ Membership.mem (nhdsWithin x s) (f.extend I).source","decl":"theorem extend_source_mem_nhdsWithin {x : M} (h : x âˆˆ f.source) : (f.extend I).source âˆˆ ð“[s] x :=\n  mem_nhdsWithin_of_mem_nhds <| extend_source_mem_nhds f h\n\n"}
{"name":"PartialHomeomorph.continuousOn_extend","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nâŠ¢ ContinuousOn (â†‘(f.extend I)) (f.extend I).source","decl":"theorem continuousOn_extend : ContinuousOn (f.extend I) (f.extend I).source := by\n  refine I.continuous.comp_continuousOn ?_\n  rw [extend_source]\n  exact f.continuousOn\n\n"}
{"name":"PartialHomeomorph.continuousAt_extend","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nx : M\nh : Membership.mem f.source x\nâŠ¢ ContinuousAt (â†‘(f.extend I)) x","decl":"theorem continuousAt_extend {x : M} (h : x âˆˆ f.source) : ContinuousAt (f.extend I) x :=\n  (continuousOn_extend f).continuousAt <| extend_source_mem_nhds f h\n\n"}
{"name":"PartialHomeomorph.map_extend_nhds","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nx : M\nhy : Membership.mem f.source x\nâŠ¢ Eq (Filter.map (â†‘(f.extend I)) (nhds x)) (nhdsWithin (â†‘(f.extend I) x) (Set.range â†‘I))","decl":"theorem map_extend_nhds {x : M} (hy : x âˆˆ f.source) :\n    map (f.extend I) (ð“ x) = ð“[range I] f.extend I x := by\n  rwa [extend_coe, comp_apply, â† I.map_nhds_eq, â† f.map_nhds_eq, map_map]\n\n"}
{"name":"PartialHomeomorph.map_extend_nhds_of_mem_interior_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nx : M\nhx : Membership.mem f.source x\nh'x : Membership.mem (interior (Set.range â†‘I)) (â†‘(f.extend I) x)\nâŠ¢ Eq (Filter.map (â†‘(f.extend I)) (nhds x)) (nhds (â†‘(f.extend I) x))","decl":"theorem map_extend_nhds_of_mem_interior_range {x : M} (hx : x âˆˆ f.source)\n    (h'x : f.extend I x âˆˆ interior (range I)) :\n    map (f.extend I) (ð“ x) = ð“ (f.extend I x) := by\n  rw [f.map_extend_nhds hx, nhdsWithin_eq_nhds]\n  exact mem_of_superset (isOpen_interior.mem_nhds h'x) interior_subset\n\n"}
{"name":"PartialHomeomorph.map_extend_nhds_of_boundaryless","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ninstâœ : I.Boundaryless\nx : M\nhx : Membership.mem f.source x\nâŠ¢ Eq (Filter.map (â†‘(f.extend I)) (nhds x)) (nhds (â†‘(f.extend I) x))","decl":"theorem map_extend_nhds_of_boundaryless [I.Boundaryless] {x : M} (hx : x âˆˆ f.source) :\n    map (f.extend I) (ð“ x) = ð“ (f.extend I x) := by\n  rw [f.map_extend_nhds hx, I.range_eq_univ, nhdsWithin_univ]\n\n"}
{"name":"PartialHomeomorph.extend_target_mem_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ny : M\nhy : Membership.mem f.source y\nâŠ¢ Membership.mem (nhdsWithin (â†‘(f.extend I) y) (Set.range â†‘I)) (f.extend I).target","decl":"theorem extend_target_mem_nhdsWithin {y : M} (hy : y âˆˆ f.source) :\n    (f.extend I).target âˆˆ ð“[range I] f.extend I y := by\n  rw [â† PartialEquiv.image_source_eq_target, â† map_extend_nhds f hy]\n  exact image_mem_map (extend_source_mem_nhds _ hy)\n\n"}
{"name":"PartialHomeomorph.extend_image_nhd_mem_nhds_of_boundaryless","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ninstâœ : I.Boundaryless\nx : M\nhx : Membership.mem f.source x\ns : Set M\nh : Membership.mem (nhds x) s\nâŠ¢ Membership.mem (nhds (â†‘(f.extend I) x)) (Set.image (â†‘(f.extend I)) s)","decl":"theorem extend_image_nhd_mem_nhds_of_boundaryless [I.Boundaryless] {x} (hx : x âˆˆ f.source)\n    {s : Set M} (h : s âˆˆ ð“ x) : (f.extend I) '' s âˆˆ ð“ ((f.extend I) x) := by\n  rw [â† f.map_extend_nhds_of_boundaryless hx, Filter.mem_map]\n  filter_upwards [h] using subset_preimage_image (f.extend I) s\n\n"}
{"name":"PartialHomeomorph.extend_image_nhd_mem_nhds_of_mem_interior_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nx : M\nhx : Membership.mem f.source x\nh'x : Membership.mem (interior (Set.range â†‘I)) (â†‘(f.extend I) x)\ns : Set M\nh : Membership.mem (nhds x) s\nâŠ¢ Membership.mem (nhds (â†‘(f.extend I) x)) (Set.image (â†‘(f.extend I)) s)","decl":"theorem extend_image_nhd_mem_nhds_of_mem_interior_range {x} (hx : x âˆˆ f.source)\n    (h'x : f.extend I x âˆˆ interior (range I)) {s : Set M} (h : s âˆˆ ð“ x) :\n    (f.extend I) '' s âˆˆ ð“ ((f.extend I) x) := by\n  rw [â† f.map_extend_nhds_of_mem_interior_range hx h'x, Filter.mem_map]\n  filter_upwards [h] using subset_preimage_image (f.extend I) s\n\n"}
{"name":"PartialHomeomorph.extend_target_subset_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nâŠ¢ HasSubset.Subset (f.extend I).target (Set.range â†‘I)","decl":"theorem extend_target_subset_range : (f.extend I).target âŠ† range I := by simp only [mfld_simps]\n\n"}
{"name":"PartialHomeomorph.interior_extend_target_subset_interior_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nâŠ¢ HasSubset.Subset (interior (f.extend I).target) (interior (Set.range â†‘I))","decl":"lemma interior_extend_target_subset_interior_range :\n    interior (f.extend I).target âŠ† interior (range I) := by\n  rw [f.extend_target, interior_inter, (f.open_target.preimage I.continuous_symm).interior_eq]\n  exact inter_subset_right\n\n"}
{"name":"PartialHomeomorph.mem_interior_extend_target","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ny : H\nhy : Membership.mem f.target y\nhy' : Membership.mem (interior (Set.range â†‘I)) (â†‘I y)\nâŠ¢ Membership.mem (interior (f.extend I).target) (â†‘I y)","decl":"/-- If `y âˆˆ f.target` and `I y âˆˆ interior (range I)`,\n  then `I y` is an interior point of `(I âˆ˜ f).target`. -/\nlemma mem_interior_extend_target {y : H} (hy : y âˆˆ f.target)\n    (hy' : I y âˆˆ interior (range I)) : I y âˆˆ interior (f.extend I).target := by\n  rw [f.extend_target, interior_inter, (f.open_target.preimage I.continuous_symm).interior_eq,\n    mem_inter_iff, mem_preimage]\n  exact âŸ¨mem_of_eq_of_mem (I.left_inv (y)) hy, hy'âŸ©\n\n"}
{"name":"PartialHomeomorph.nhdsWithin_extend_target_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ny : M\nhy : Membership.mem f.source y\nâŠ¢ Eq (nhdsWithin (â†‘(f.extend I) y) (f.extend I).target) (nhdsWithin (â†‘(f.extend I) y) (Set.range â†‘I))","decl":"theorem nhdsWithin_extend_target_eq {y : M} (hy : y âˆˆ f.source) :\n    ð“[(f.extend I).target] f.extend I y = ð“[range I] f.extend I y :=\n  (nhdsWithin_mono _ (extend_target_subset_range _)).antisymm <|\n    nhdsWithin_le_of_mem (extend_target_mem_nhdsWithin _ hy)\n\n"}
{"name":"PartialHomeomorph.extend_target_eventuallyEq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ny : M\nhy : Membership.mem f.source y\nâŠ¢ (nhds (â†‘(f.extend I) y)).EventuallyEq (f.extend I).target (Set.range â†‘I)","decl":"theorem extend_target_eventuallyEq {y : M} (hy : y âˆˆ f.source) :\n    (f.extend I).target =á¶ [ð“ (f.extend I y)] range I :=\n  nhdsWithin_eq_iff_eventuallyEq.1 (nhdsWithin_extend_target_eq _ hy)\n\n"}
{"name":"PartialHomeomorph.continuousAt_extend_symm'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nx : E\nh : Membership.mem (f.extend I).target x\nâŠ¢ ContinuousAt (â†‘(f.extend I).symm) x","decl":"theorem continuousAt_extend_symm' {x : E} (h : x âˆˆ (f.extend I).target) :\n    ContinuousAt (f.extend I).symm x :=\n  (f.continuousAt_symm h.2).comp I.continuous_symm.continuousAt\n\n"}
{"name":"PartialHomeomorph.continuousAt_extend_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nx : M\nh : Membership.mem f.source x\nâŠ¢ ContinuousAt (â†‘(f.extend I).symm) (â†‘(f.extend I) x)","decl":"theorem continuousAt_extend_symm {x : M} (h : x âˆˆ f.source) :\n    ContinuousAt (f.extend I).symm (f.extend I x) :=\n  continuousAt_extend_symm' f <| (f.extend I).map_source <| by rwa [f.extend_source]\n\n"}
{"name":"PartialHomeomorph.continuousOn_extend_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nâŠ¢ ContinuousOn (â†‘(f.extend I).symm) (f.extend I).target","decl":"theorem continuousOn_extend_symm : ContinuousOn (f.extend I).symm (f.extend I).target := fun _ h =>\n  (continuousAt_extend_symm' _ h).continuousWithinAt\n\n"}
{"name":"PartialHomeomorph.extend_symm_continuousWithinAt_comp_right_iff","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nX : Type u_8\ninstâœ : TopologicalSpace X\ng : M â†’ X\ns : Set M\nx : M\nâŠ¢ Iff (ContinuousWithinAt (Function.comp g â†‘(f.extend I).symm) (Inter.inter (Set.preimage (â†‘(f.extend I).symm) s) (Set.range â†‘I)) (â†‘(f.extend I) x)) (ContinuousWithinAt (Function.comp g â†‘f.symm) (Set.preimage (â†‘f.symm) s) (â†‘f x))","decl":"theorem extend_symm_continuousWithinAt_comp_right_iff {X} [TopologicalSpace X] {g : M â†’ X}\n    {s : Set M} {x : M} :\n    ContinuousWithinAt (g âˆ˜ (f.extend I).symm) ((f.extend I).symm â»Â¹' s âˆ© range I) (f.extend I x) â†”\n      ContinuousWithinAt (g âˆ˜ f.symm) (f.symm â»Â¹' s) (f x) := by\n  rw [â† I.symm_continuousWithinAt_comp_right_iff]; rfl\n\n"}
{"name":"PartialHomeomorph.isOpen_extend_preimage'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ns : Set E\nhs : IsOpen s\nâŠ¢ IsOpen (Inter.inter (f.extend I).source (Set.preimage (â†‘(f.extend I)) s))","decl":"theorem isOpen_extend_preimage' {s : Set E} (hs : IsOpen s) :\n    IsOpen ((f.extend I).source âˆ© f.extend I â»Â¹' s) :=\n  (continuousOn_extend f).isOpen_inter_preimage (isOpen_extend_source _) hs\n\n"}
{"name":"PartialHomeomorph.isOpen_extend_preimage","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ns : Set E\nhs : IsOpen s\nâŠ¢ IsOpen (Inter.inter f.source (Set.preimage (â†‘(f.extend I)) s))","decl":"theorem isOpen_extend_preimage {s : Set E} (hs : IsOpen s) :\n    IsOpen (f.source âˆ© f.extend I â»Â¹' s) := by\n  rw [â† extend_source f (I := I)]; exact isOpen_extend_preimage' f hs\n\n"}
{"name":"PartialHomeomorph.map_extend_nhdsWithin_eq_image","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ns : Set M\ny : M\nhy : Membership.mem f.source y\nâŠ¢ Eq (Filter.map (â†‘(f.extend I)) (nhdsWithin y s)) (nhdsWithin (â†‘(f.extend I) y) (Set.image (â†‘(f.extend I)) (Inter.inter (f.extend I).source s)))","decl":"theorem map_extend_nhdsWithin_eq_image {y : M} (hy : y âˆˆ f.source) :\n    map (f.extend I) (ð“[s] y) = ð“[f.extend I '' ((f.extend I).source âˆ© s)] f.extend I y := by\n  set e := f.extend I\n  calc\n    map e (ð“[s] y) = map e (ð“[e.source âˆ© s] y) :=\n      congr_arg (map e) (nhdsWithin_inter_of_mem (extend_source_mem_nhdsWithin f hy)).symm\n    _ = ð“[e '' (e.source âˆ© s)] e y :=\n      ((f.extend I).leftInvOn.mono inter_subset_left).map_nhdsWithin_eq\n        ((f.extend I).left_inv <| by rwa [f.extend_source])\n        (continuousAt_extend_symm f hy).continuousWithinAt\n        (continuousAt_extend f hy).continuousWithinAt\n\n"}
{"name":"PartialHomeomorph.map_extend_nhdsWithin_eq_image_of_subset","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ns : Set M\ny : M\nhy : Membership.mem f.source y\nhs : HasSubset.Subset s f.source\nâŠ¢ Eq (Filter.map (â†‘(f.extend I)) (nhdsWithin y s)) (nhdsWithin (â†‘(f.extend I) y) (Set.image (â†‘(f.extend I)) s))","decl":"theorem map_extend_nhdsWithin_eq_image_of_subset {y : M} (hy : y âˆˆ f.source) (hs : s âŠ† f.source) :\n    map (f.extend I) (ð“[s] y) = ð“[f.extend I '' s] f.extend I y := by\n  rw [map_extend_nhdsWithin_eq_image _ hy, inter_eq_self_of_subset_right]\n  rwa [extend_source]\n\n"}
{"name":"PartialHomeomorph.map_extend_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ns : Set M\ny : M\nhy : Membership.mem f.source y\nâŠ¢ Eq (Filter.map (â†‘(f.extend I)) (nhdsWithin y s)) (nhdsWithin (â†‘(f.extend I) y) (Inter.inter (Set.preimage (â†‘(f.extend I).symm) s) (Set.range â†‘I)))","decl":"theorem map_extend_nhdsWithin {y : M} (hy : y âˆˆ f.source) :\n    map (f.extend I) (ð“[s] y) = ð“[(f.extend I).symm â»Â¹' s âˆ© range I] f.extend I y := by\n  rw [map_extend_nhdsWithin_eq_image f hy, nhdsWithin_inter, â†\n    nhdsWithin_extend_target_eq _ hy, â† nhdsWithin_inter, (f.extend I).image_source_inter_eq',\n    inter_comm]\n\n"}
{"name":"PartialHomeomorph.map_extend_symm_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ns : Set M\ny : M\nhy : Membership.mem f.source y\nâŠ¢ Eq (Filter.map (â†‘(f.extend I).symm) (nhdsWithin (â†‘(f.extend I) y) (Inter.inter (Set.preimage (â†‘(f.extend I).symm) s) (Set.range â†‘I)))) (nhdsWithin y s)","decl":"theorem map_extend_symm_nhdsWithin {y : M} (hy : y âˆˆ f.source) :\n    map (f.extend I).symm (ð“[(f.extend I).symm â»Â¹' s âˆ© range I] f.extend I y) = ð“[s] y := by\n  rw [â† map_extend_nhdsWithin f hy, map_map, Filter.map_congr, map_id]\n  exact (f.extend I).leftInvOn.eqOn.eventuallyEq_of_mem (extend_source_mem_nhdsWithin _ hy)\n\n"}
{"name":"PartialHomeomorph.map_extend_symm_nhdsWithin_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ny : M\nhy : Membership.mem f.source y\nâŠ¢ Eq (Filter.map (â†‘(f.extend I).symm) (nhdsWithin (â†‘(f.extend I) y) (Set.range â†‘I))) (nhds y)","decl":"theorem map_extend_symm_nhdsWithin_range {y : M} (hy : y âˆˆ f.source) :\n    map (f.extend I).symm (ð“[range I] f.extend I y) = ð“ y := by\n  rw [â† nhdsWithin_univ, â† map_extend_symm_nhdsWithin f (I := I) hy, preimage_univ, univ_inter]\n\n"}
{"name":"PartialHomeomorph.tendsto_extend_comp_iff","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nÎ± : Type u_8\nl : Filter Î±\ng : Î± â†’ M\nhg : Filter.Eventually (fun z => Membership.mem f.source (g z)) l\ny : M\nhy : Membership.mem f.source y\nâŠ¢ Iff (Filter.Tendsto (Function.comp (â†‘(f.extend I)) g) l (nhds (â†‘(f.extend I) y))) (Filter.Tendsto g l (nhds y))","decl":"theorem tendsto_extend_comp_iff {Î± : Type*} {l : Filter Î±} {g : Î± â†’ M}\n    (hg : âˆ€á¶  z in l, g z âˆˆ f.source) {y : M} (hy : y âˆˆ f.source) :\n    Tendsto (f.extend I âˆ˜ g) l (ð“ (f.extend I y)) â†” Tendsto g l (ð“ y) := by\n  refine âŸ¨fun h u hu â†¦ mem_map.2 ?_, (continuousAt_extend _ hy).tendsto.compâŸ©\n  have := (f.continuousAt_extend_symm hy).tendsto.comp h\n  rw [extend_left_inv _ hy] at this\n  filter_upwards [hg, mem_map.1 (this hu)] with z hz hzu\n  simpa only [(Â· âˆ˜ Â·), extend_left_inv _ hz, mem_preimage] using hzu\n\n-- there is no definition `writtenInExtend` but we already use some made-up names in this file\n"}
{"name":"PartialHomeomorph.continuousWithinAt_writtenInExtend_iff","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\nE' : Type u_5\nM' : Type u_6\nH' : Type u_7\ninstâœâ¸ : NontriviallyNormedField ð•œ\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ð•œ E\ninstâœâµ : TopologicalSpace H\ninstâœâ´ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ð•œ E'\ninstâœÂ¹ : TopologicalSpace H'\ninstâœ : TopologicalSpace M'\nI' : ModelWithCorners ð•œ E' H'\ns : Set M\nf' : PartialHomeomorph M' H'\ng : M â†’ M'\ny : M\nhy : Membership.mem f.source y\nhgy : Membership.mem f'.source (g y)\nhmaps : Set.MapsTo g s f'.source\nâŠ¢ Iff (ContinuousWithinAt (Function.comp (â†‘(f'.extend I')) (Function.comp g â†‘(f.extend I).symm)) (Inter.inter (Set.preimage (â†‘(f.extend I).symm) s) (Set.range â†‘I)) (â†‘(f.extend I) y)) (ContinuousWithinAt g s y)","decl":"theorem continuousWithinAt_writtenInExtend_iff {f' : PartialHomeomorph M' H'} {g : M â†’ M'} {y : M}\n    (hy : y âˆˆ f.source) (hgy : g y âˆˆ f'.source) (hmaps : MapsTo g s f'.source) :\n    ContinuousWithinAt (f'.extend I' âˆ˜ g âˆ˜ (f.extend I).symm)\n      ((f.extend I).symm â»Â¹' s âˆ© range I) (f.extend I y) â†” ContinuousWithinAt g s y := by\n  unfold ContinuousWithinAt\n  simp only [comp_apply]\n  rw [extend_left_inv _ hy, f'.tendsto_extend_comp_iff _ hgy,\n    â† f.map_extend_symm_nhdsWithin (I := I) hy, tendsto_map'_iff]\n  rw [â† f.map_extend_nhdsWithin (I := I) hy, eventually_map]\n  filter_upwards [inter_mem_nhdsWithin _ (f.open_source.mem_nhds hy)] with z hz\n  rw [comp_apply, extend_left_inv _ hz.2]\n  exact hmaps hz.1\n\n-- there is no definition `writtenInExtend` but we already use some made-up names in this file\n\n"}
{"name":"PartialHomeomorph.continuousOn_writtenInExtend_iff","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\nE' : Type u_5\nM' : Type u_6\nH' : Type u_7\ninstâœâ¸ : NontriviallyNormedField ð•œ\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ð•œ E\ninstâœâµ : TopologicalSpace H\ninstâœâ´ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ð•œ E'\ninstâœÂ¹ : TopologicalSpace H'\ninstâœ : TopologicalSpace M'\nI' : ModelWithCorners ð•œ E' H'\ns : Set M\nf' : PartialHomeomorph M' H'\ng : M â†’ M'\nhs : HasSubset.Subset s f.source\nhmaps : Set.MapsTo g s f'.source\nâŠ¢ Iff (ContinuousOn (Function.comp (â†‘(f'.extend I')) (Function.comp g â†‘(f.extend I).symm)) (Set.image (â†‘(f.extend I)) s)) (ContinuousOn g s)","decl":"/-- If `s âŠ† f.source` and `g x âˆˆ f'.source` whenever `x âˆˆ s`, then `g` is continuous on `s` if and\nonly if `g` written in charts `f.extend I` and `f'.extend I'` is continuous on `f.extend I '' s`. -/\ntheorem continuousOn_writtenInExtend_iff {f' : PartialHomeomorph M' H'} {g : M â†’ M'}\n    (hs : s âŠ† f.source) (hmaps : MapsTo g s f'.source) :\n    ContinuousOn (f'.extend I' âˆ˜ g âˆ˜ (f.extend I).symm) (f.extend I '' s) â†” ContinuousOn g s := by\n  refine forall_mem_image.trans <| forallâ‚‚_congr fun x hx â†¦ ?_\n  refine (continuousWithinAt_congr_set ?_).trans\n    (continuousWithinAt_writtenInExtend_iff _ (hs hx) (hmaps hx) hmaps)\n  rw [â† nhdsWithin_eq_iff_eventuallyEq, â† map_extend_nhdsWithin_eq_image_of_subset,\n    â† map_extend_nhdsWithin]\n  exacts [hs hx, hs hx, hs]\n\n"}
{"name":"PartialHomeomorph.extend_preimage_mem_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ns t : Set M\nx : M\nh : Membership.mem f.source x\nht : Membership.mem (nhdsWithin x s) t\nâŠ¢ Membership.mem (nhdsWithin (â†‘(f.extend I) x) (Inter.inter (Set.preimage (â†‘(f.extend I).symm) s) (Set.range â†‘I))) (Set.preimage (â†‘(f.extend I).symm) t)","decl":"/-- Technical lemma ensuring that the preimage under an extended chart of a neighborhood of a point\nin the source is a neighborhood of the preimage, within a set. -/\ntheorem extend_preimage_mem_nhdsWithin {x : M} (h : x âˆˆ f.source) (ht : t âˆˆ ð“[s] x) :\n    (f.extend I).symm â»Â¹' t âˆˆ ð“[(f.extend I).symm â»Â¹' s âˆ© range I] f.extend I x := by\n  rwa [â† map_extend_symm_nhdsWithin f (I := I) h, mem_map] at ht\n\n"}
{"name":"PartialHomeomorph.extend_preimage_mem_nhds","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nt : Set M\nx : M\nh : Membership.mem f.source x\nht : Membership.mem (nhds x) t\nâŠ¢ Membership.mem (nhds (â†‘(f.extend I) x)) (Set.preimage (â†‘(f.extend I).symm) t)","decl":"theorem extend_preimage_mem_nhds {x : M} (h : x âˆˆ f.source) (ht : t âˆˆ ð“ x) :\n    (f.extend I).symm â»Â¹' t âˆˆ ð“ (f.extend I x) := by\n  apply (continuousAt_extend_symm f h).preimage_mem_nhds\n  rwa [(f.extend I).left_inv]\n  rwa [f.extend_source]\n\n"}
{"name":"PartialHomeomorph.extend_preimage_inter_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ns t : Set M\nâŠ¢ Eq (Inter.inter (Set.preimage (â†‘(f.extend I).symm) (Inter.inter s t)) (Set.range â†‘I)) (Inter.inter (Inter.inter (Set.preimage (â†‘(f.extend I).symm) s) (Set.range â†‘I)) (Set.preimage (â†‘(f.extend I).symm) t))","decl":"/-- Technical lemma to rewrite suitably the preimage of an intersection under an extended chart, to\nbring it into a convenient form to apply derivative lemmas. -/\ntheorem extend_preimage_inter_eq :\n    (f.extend I).symm â»Â¹' (s âˆ© t) âˆ© range I =\n      (f.extend I).symm â»Â¹' s âˆ© range I âˆ© (f.extend I).symm â»Â¹' t := by\n  mfld_set_tac\n\n-- Porting note: an `aux` lemma that is no longer needed. Delete?\n"}
{"name":"PartialHomeomorph.extend_symm_preimage_inter_range_eventuallyEq_aux","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ns : Set M\nx : M\nhx : Membership.mem f.source x\nâŠ¢ (nhds (â†‘(f.extend I) x)).EventuallyEq (Inter.inter (Set.preimage (â†‘(f.extend I).symm) s) (Set.range â†‘I)) (Inter.inter (f.extend I).target (Set.preimage (â†‘(f.extend I).symm) s))","decl":"theorem extend_symm_preimage_inter_range_eventuallyEq_aux {s : Set M} {x : M} (hx : x âˆˆ f.source) :\n    ((f.extend I).symm â»Â¹' s âˆ© range I : Set _) =á¶ [ð“ (f.extend I x)]\n      ((f.extend I).target âˆ© (f.extend I).symm â»Â¹' s : Set _) := by\n  rw [f.extend_target, inter_assoc, inter_comm (range I)]\n  conv =>\n    congr\n    Â· skip\n    rw [â† univ_inter (_ âˆ© range I)]\n  refine (eventuallyEq_univ.mpr ?_).symm.inter EventuallyEq.rfl\n  refine I.continuousAt_symm.preimage_mem_nhds (f.open_target.mem_nhds ?_)\n  simp_rw [f.extend_coe, Function.comp_apply, I.left_inv, f.mapsTo hx]\n\n"}
{"name":"PartialHomeomorph.extend_symm_preimage_inter_range_eventuallyEq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ns : Set M\nx : M\nhs : HasSubset.Subset s f.source\nhx : Membership.mem f.source x\nâŠ¢ (nhds (â†‘(f.extend I) x)).EventuallyEq (Inter.inter (Set.preimage (â†‘(f.extend I).symm) s) (Set.range â†‘I)) (Set.image (â†‘(f.extend I)) s)","decl":"theorem extend_symm_preimage_inter_range_eventuallyEq {s : Set M} {x : M} (hs : s âŠ† f.source)\n    (hx : x âˆˆ f.source) :\n    ((f.extend I).symm â»Â¹' s âˆ© range I : Set _) =á¶ [ð“ (f.extend I x)] f.extend I '' s := by\n  rw [â† nhdsWithin_eq_iff_eventuallyEq, â† map_extend_nhdsWithin _ hx,\n    map_extend_nhdsWithin_eq_image_of_subset _ hx hs]\n\n"}
{"name":"PartialHomeomorph.extend_coord_change_source","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf f' : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nâŠ¢ Eq ((f.extend I).symm.trans (f'.extend I)).source (Set.image (â†‘I) (f.symm.trans f').source)","decl":"theorem extend_coord_change_source :\n    ((f.extend I).symm â‰« f'.extend I).source = I '' (f.symm â‰«â‚• f').source := by\n  simp_rw [PartialEquiv.trans_source, I.image_eq, extend_source, PartialEquiv.symm_source,\n    extend_target, inter_right_comm _ (range I)]\n  rfl\n\n"}
{"name":"PartialHomeomorph.extend_image_source_inter","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf f' : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nâŠ¢ Eq (Set.image (â†‘(f.extend I)) (Inter.inter f.source f'.source)) ((f.extend I).symm.trans (f'.extend I)).source","decl":"theorem extend_image_source_inter :\n    f.extend I '' (f.source âˆ© f'.source) = ((f.extend I).symm â‰« f'.extend I).source := by\n  simp_rw [f.extend_coord_change_source, f.extend_coe, image_comp I f, trans_source'', symm_symm,\n    symm_target]\n\n"}
{"name":"PartialHomeomorph.extend_coord_change_source_mem_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf f' : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nx : E\nhx : Membership.mem ((f.extend I).symm.trans (f'.extend I)).source x\nâŠ¢ Membership.mem (nhdsWithin x (Set.range â†‘I)) ((f.extend I).symm.trans (f'.extend I)).source","decl":"theorem extend_coord_change_source_mem_nhdsWithin {x : E}\n    (hx : x âˆˆ ((f.extend I).symm â‰« f'.extend I).source) :\n    ((f.extend I).symm â‰« f'.extend I).source âˆˆ ð“[range I] x := by\n  rw [f.extend_coord_change_source] at hx âŠ¢\n  obtain âŸ¨x, hx, rflâŸ© := hx\n  refine I.image_mem_nhdsWithin ?_\n  exact (PartialHomeomorph.open_source _).mem_nhds hx\n\n"}
{"name":"PartialHomeomorph.extend_coord_change_source_mem_nhdsWithin'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ´ : NontriviallyNormedField ð•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ð•œ E\ninstâœÂ¹ : TopologicalSpace H\ninstâœ : TopologicalSpace M\nf f' : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\nx : M\nhxf : Membership.mem f.source x\nhxf' : Membership.mem f'.source x\nâŠ¢ Membership.mem (nhdsWithin (â†‘(f.extend I) x) (Set.range â†‘I)) ((f.extend I).symm.trans (f'.extend I)).source","decl":"theorem extend_coord_change_source_mem_nhdsWithin' {x : M} (hxf : x âˆˆ f.source)\n    (hxf' : x âˆˆ f'.source) :\n    ((f.extend I).symm â‰« f'.extend I).source âˆˆ ð“[range I] f.extend I x := by\n  apply extend_coord_change_source_mem_nhdsWithin\n  rw [â† extend_image_source_inter]\n  exact mem_image_of_mem _ âŸ¨hxf, hxf'âŸ©\n\n"}
{"name":"PartialHomeomorph.contDiffOn_extend_coord_change","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nn : WithTop ENat\nf f' : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nhf : Membership.mem (IsManifold.maximalAtlas I n M) f\nhf' : Membership.mem (IsManifold.maximalAtlas I n M) f'\nâŠ¢ ContDiffOn ð•œ n (Function.comp â†‘(f.extend I) â†‘(f'.extend I).symm) ((f'.extend I).symm.trans (f.extend I)).source","decl":"theorem contDiffOn_extend_coord_change [ChartedSpace H M] (hf : f âˆˆ maximalAtlas I n M)\n    (hf' : f' âˆˆ maximalAtlas I n M) :\n    ContDiffOn ð•œ n (f.extend I âˆ˜ (f'.extend I).symm) ((f'.extend I).symm â‰« f.extend I).source := by\n  rw [extend_coord_change_source, I.image_eq]\n  exact (StructureGroupoid.compatible_of_mem_maximalAtlas hf' hf).1\n\n"}
{"name":"PartialHomeomorph.contDiffWithinAt_extend_coord_change","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nn : WithTop ENat\nf f' : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nhf : Membership.mem (IsManifold.maximalAtlas I n M) f\nhf' : Membership.mem (IsManifold.maximalAtlas I n M) f'\nx : E\nhx : Membership.mem ((f'.extend I).symm.trans (f.extend I)).source x\nâŠ¢ ContDiffWithinAt ð•œ n (Function.comp â†‘(f.extend I) â†‘(f'.extend I).symm) (Set.range â†‘I) x","decl":"theorem contDiffWithinAt_extend_coord_change [ChartedSpace H M] (hf : f âˆˆ maximalAtlas I n M)\n    (hf' : f' âˆˆ maximalAtlas I n M) {x : E} (hx : x âˆˆ ((f'.extend I).symm â‰« f.extend I).source) :\n    ContDiffWithinAt ð•œ n (f.extend I âˆ˜ (f'.extend I).symm) (range I) x := by\n  apply (contDiffOn_extend_coord_change hf hf' x hx).mono_of_mem_nhdsWithin\n  rw [extend_coord_change_source] at hx âŠ¢\n  obtain âŸ¨z, hz, rflâŸ© := hx\n  exact I.image_mem_nhdsWithin ((PartialHomeomorph.open_source _).mem_nhds hz)\n\n"}
{"name":"PartialHomeomorph.contDiffWithinAt_extend_coord_change'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nn : WithTop ENat\nf f' : PartialHomeomorph M H\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nhf : Membership.mem (IsManifold.maximalAtlas I n M) f\nhf' : Membership.mem (IsManifold.maximalAtlas I n M) f'\nx : M\nhxf : Membership.mem f.source x\nhxf' : Membership.mem f'.source x\nâŠ¢ ContDiffWithinAt ð•œ n (Function.comp â†‘(f.extend I) â†‘(f'.extend I).symm) (Set.range â†‘I) (â†‘(f'.extend I) x)","decl":"theorem contDiffWithinAt_extend_coord_change' [ChartedSpace H M] (hf : f âˆˆ maximalAtlas I n M)\n    (hf' : f' âˆˆ maximalAtlas I n M) {x : M} (hxf : x âˆˆ f.source) (hxf' : x âˆˆ f'.source) :\n    ContDiffWithinAt ð•œ n (f.extend I âˆ˜ (f'.extend I).symm) (range I) (f'.extend I x) := by\n  refine contDiffWithinAt_extend_coord_change hf hf' ?_\n  rw [â† extend_image_source_inter]\n  exact mem_image_of_mem _ âŸ¨hxf', hxfâŸ©\n\n"}
{"name":"extChartAt_coe","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ Eq (â†‘(extChartAt I x)) (Function.comp â†‘I â†‘(chartAt H x))","decl":"theorem extChartAt_coe (x : M) : â‡‘(extChartAt I x) = I âˆ˜ chartAt H x :=\n  rfl\n\n"}
{"name":"extChartAt_coe_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ Eq (â†‘(extChartAt I x).symm) (Function.comp â†‘(chartAt H x).symm â†‘I.symm)","decl":"theorem extChartAt_coe_symm (x : M) : â‡‘(extChartAt I x).symm = (chartAt H x).symm âˆ˜ I.symm :=\n  rfl\n\n"}
{"name":"extChartAt_source","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ Eq (extChartAt I x).source (chartAt H x).source","decl":"variable (I) in\ntheorem extChartAt_source (x : M) : (extChartAt I x).source = (chartAt H x).source :=\n  extend_source _\n\n"}
{"name":"isOpen_extChartAt_source","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ IsOpen (extChartAt I x).source","decl":"theorem isOpen_extChartAt_source (x : M) : IsOpen (extChartAt I x).source :=\n  isOpen_extend_source _\n\n"}
{"name":"mem_extChartAt_source","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ Membership.mem (extChartAt I x).source x","decl":"theorem mem_extChartAt_source (x : M) : x âˆˆ (extChartAt I x).source := by\n  simp only [extChartAt_source, mem_chart_source]\n\n"}
{"name":"mem_extChartAt_target","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ Membership.mem (extChartAt I x).target (â†‘(extChartAt I x) x)","decl":"theorem mem_extChartAt_target (x : M) : extChartAt I x x âˆˆ (extChartAt I x).target :=\n  (extChartAt I x).map_source <| mem_extChartAt_source _\n\n"}
{"name":"extChartAt_target","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ Eq (extChartAt I x).target (Inter.inter (Set.preimage (â†‘I.symm) (chartAt H x).target) (Set.range â†‘I))","decl":"variable (I) in\ntheorem extChartAt_target (x : M) :\n    (extChartAt I x).target = I.symm â»Â¹' (chartAt H x).target âˆ© range I :=\n  extend_target _\n\n"}
{"name":"uniqueDiffOn_extChartAt_target","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ UniqueDiffOn ð•œ (extChartAt I x).target","decl":"theorem uniqueDiffOn_extChartAt_target (x : M) : UniqueDiffOn ð•œ (extChartAt I x).target := by\n  rw [extChartAt_target]\n  exact I.uniqueDiffOn_preimage (chartAt H x).open_target\n\n"}
{"name":"uniqueDiffWithinAt_extChartAt_target","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ UniqueDiffWithinAt ð•œ (extChartAt I x).target (â†‘(extChartAt I x) x)","decl":"theorem uniqueDiffWithinAt_extChartAt_target (x : M) :\n    UniqueDiffWithinAt ð•œ (extChartAt I x).target (extChartAt I x x) :=\n  uniqueDiffOn_extChartAt_target x _ <| mem_extChartAt_target x\n\n"}
{"name":"extChartAt_to_inv","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ Eq (â†‘(extChartAt I x).symm (â†‘(extChartAt I x) x)) x","decl":"theorem extChartAt_to_inv (x : M) : (extChartAt I x).symm ((extChartAt I x) x) = x :=\n  (extChartAt I x).left_inv (mem_extChartAt_source x)\n\n"}
{"name":"mapsTo_extChartAt","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ns : Set M\ninstâœ : ChartedSpace H M\nx : M\nhs : HasSubset.Subset s (chartAt H x).source\nâŠ¢ Set.MapsTo (â†‘(extChartAt I x)) s (Inter.inter (Set.preimage (â†‘(extChartAt I x).symm) s) (Set.range â†‘I))","decl":"theorem mapsTo_extChartAt {x : M} (hs : s âŠ† (chartAt H x).source) :\n    MapsTo (extChartAt I x) s ((extChartAt I x).symm â»Â¹' s âˆ© range I) :=\n  mapsTo_extend _ hs\n\n"}
{"name":"extChartAt_source_mem_nhds'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx x' : M\nh : Membership.mem (extChartAt I x).source x'\nâŠ¢ Membership.mem (nhds x') (extChartAt I x).source","decl":"theorem extChartAt_source_mem_nhds' {x x' : M} (h : x' âˆˆ (extChartAt I x).source) :\n    (extChartAt I x).source âˆˆ ð“ x' :=\n  extend_source_mem_nhds _ <| by rwa [â† extChartAt_source I]\n\n"}
{"name":"extChartAt_source_mem_nhds","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ Membership.mem (nhds x) (extChartAt I x).source","decl":"theorem extChartAt_source_mem_nhds (x : M) : (extChartAt I x).source âˆˆ ð“ x :=\n  extChartAt_source_mem_nhds' (mem_extChartAt_source x)\n\n"}
{"name":"extChartAt_source_mem_nhdsWithin'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ns : Set M\ninstâœ : ChartedSpace H M\nx x' : M\nh : Membership.mem (extChartAt I x).source x'\nâŠ¢ Membership.mem (nhdsWithin x' s) (extChartAt I x).source","decl":"theorem extChartAt_source_mem_nhdsWithin' {x x' : M} (h : x' âˆˆ (extChartAt I x).source) :\n    (extChartAt I x).source âˆˆ ð“[s] x' :=\n  mem_nhdsWithin_of_mem_nhds (extChartAt_source_mem_nhds' h)\n\n"}
{"name":"extChartAt_source_mem_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ns : Set M\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ Membership.mem (nhdsWithin x s) (extChartAt I x).source","decl":"theorem extChartAt_source_mem_nhdsWithin (x : M) : (extChartAt I x).source âˆˆ ð“[s] x :=\n  mem_nhdsWithin_of_mem_nhds (extChartAt_source_mem_nhds x)\n\n"}
{"name":"continuousOn_extChartAt","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ ContinuousOn (â†‘(extChartAt I x)) (extChartAt I x).source","decl":"theorem continuousOn_extChartAt (x : M) : ContinuousOn (extChartAt I x) (extChartAt I x).source :=\n  continuousOn_extend _\n\n"}
{"name":"continuousAt_extChartAt'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx x' : M\nh : Membership.mem (extChartAt I x).source x'\nâŠ¢ ContinuousAt (â†‘(extChartAt I x)) x'","decl":"theorem continuousAt_extChartAt' {x x' : M} (h : x' âˆˆ (extChartAt I x).source) :\n    ContinuousAt (extChartAt I x) x' :=\n  continuousAt_extend _ <| by rwa [â† extChartAt_source I]\n\n"}
{"name":"continuousAt_extChartAt","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ ContinuousAt (â†‘(extChartAt I x)) x","decl":"theorem continuousAt_extChartAt (x : M) : ContinuousAt (extChartAt I x) x :=\n  continuousAt_extChartAt' (mem_extChartAt_source x)\n\n"}
{"name":"map_extChartAt_nhds'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx y : M\nhy : Membership.mem (extChartAt I x).source y\nâŠ¢ Eq (Filter.map (â†‘(extChartAt I x)) (nhds y)) (nhdsWithin (â†‘(extChartAt I x) y) (Set.range â†‘I))","decl":"theorem map_extChartAt_nhds' {x y : M} (hy : y âˆˆ (extChartAt I x).source) :\n    map (extChartAt I x) (ð“ y) = ð“[range I] extChartAt I x y :=\n  map_extend_nhds _ <| by rwa [â† extChartAt_source I]\n\n"}
{"name":"map_extChartAt_nhds","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ Eq (Filter.map (â†‘(extChartAt I x)) (nhds x)) (nhdsWithin (â†‘(extChartAt I x) x) (Set.range â†‘I))","decl":"theorem map_extChartAt_nhds (x : M) : map (extChartAt I x) (ð“ x) = ð“[range I] extChartAt I x x :=\n  map_extChartAt_nhds' <| mem_extChartAt_source x\n\n"}
{"name":"map_extChartAt_nhds_of_boundaryless","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ¶ : NontriviallyNormedField ð•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\ninstâœÂ³ : TopologicalSpace H\ninstâœÂ² : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : I.Boundaryless\nx : M\nâŠ¢ Eq (Filter.map (â†‘(extChartAt I x)) (nhds x)) (nhds (â†‘(extChartAt I x) x))","decl":"theorem map_extChartAt_nhds_of_boundaryless [I.Boundaryless] (x : M) :\n    map (extChartAt I x) (ð“ x) = ð“ (extChartAt I x x) := by\n  rw [extChartAt]\n  exact map_extend_nhds_of_boundaryless (chartAt H x) (mem_chart_source H x)\n\n"}
{"name":"extChartAt_image_nhd_mem_nhds_of_mem_interior_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx y : M\nhx : Membership.mem (extChartAt I x).source y\nh'x : Membership.mem (interior (Set.range â†‘I)) (â†‘(extChartAt I x) y)\ns : Set M\nh : Membership.mem (nhds y) s\nâŠ¢ Membership.mem (nhds (â†‘(extChartAt I x) y)) (Set.image (â†‘(extChartAt I x)) s)","decl":"theorem extChartAt_image_nhd_mem_nhds_of_mem_interior_range {x y} (hx : y âˆˆ (extChartAt I x).source)\n    (h'x : extChartAt I x y âˆˆ interior (range I)) {s : Set M} (h : s âˆˆ ð“ y) :\n    (extChartAt I x) '' s âˆˆ ð“ (extChartAt I x y) := by\n  rw [extChartAt]\n  exact extend_image_nhd_mem_nhds_of_mem_interior_range _ (by simpa using hx) h'x h\n\n"}
{"name":"extChartAt_image_nhd_mem_nhds_of_boundaryless","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ¶ : NontriviallyNormedField ð•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\ninstâœÂ³ : TopologicalSpace H\ninstâœÂ² : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ns : Set M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : I.Boundaryless\nx : M\nhx : Membership.mem (nhds x) s\nâŠ¢ Membership.mem (nhds (â†‘(extChartAt I x) x)) (Set.image (â†‘(extChartAt I x)) s)","decl":"variable {x} in\ntheorem extChartAt_image_nhd_mem_nhds_of_boundaryless [I.Boundaryless]\n    {x : M} (hx : s âˆˆ ð“ x) : extChartAt I x '' s âˆˆ ð“ (extChartAt I x x) := by\n  rw [extChartAt]\n  exact extend_image_nhd_mem_nhds_of_boundaryless _ (mem_chart_source H x) hx\n\n"}
{"name":"extChartAt_target_mem_nhdsWithin'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx y : M\nhy : Membership.mem (extChartAt I x).source y\nâŠ¢ Membership.mem (nhdsWithin (â†‘(extChartAt I x) y) (Set.range â†‘I)) (extChartAt I x).target","decl":"theorem extChartAt_target_mem_nhdsWithin' {x y : M} (hy : y âˆˆ (extChartAt I x).source) :\n    (extChartAt I x).target âˆˆ ð“[range I] extChartAt I x y :=\n  extend_target_mem_nhdsWithin _ <| by rwa [â† extChartAt_source I]\n\n"}
{"name":"extChartAt_target_mem_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ Membership.mem (nhdsWithin (â†‘(extChartAt I x) x) (Set.range â†‘I)) (extChartAt I x).target","decl":"theorem extChartAt_target_mem_nhdsWithin (x : M) :\n    (extChartAt I x).target âˆˆ ð“[range I] extChartAt I x x :=\n  extChartAt_target_mem_nhdsWithin' (mem_extChartAt_source x)\n\n"}
{"name":"extChartAt_target_mem_nhdsWithin_of_mem","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\ny : E\nhy : Membership.mem (extChartAt I x).target y\nâŠ¢ Membership.mem (nhdsWithin y (Set.range â†‘I)) (extChartAt I x).target","decl":"theorem extChartAt_target_mem_nhdsWithin_of_mem {x : M} {y : E} (hy : y âˆˆ (extChartAt I x).target) :\n    (extChartAt I x).target âˆˆ ð“[range I] y := by\n  rw [â† (extChartAt I x).right_inv hy]\n  apply extChartAt_target_mem_nhdsWithin'\n  exact (extChartAt I x).map_target hy\n\n"}
{"name":"extChartAt_target_union_compl_range_mem_nhds_of_mem","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\ny : E\nx : M\nhy : Membership.mem (extChartAt I x).target y\nâŠ¢ Membership.mem (nhds y) (Union.union (extChartAt I x).target (HasCompl.compl (Set.range â†‘I)))","decl":"theorem extChartAt_target_union_compl_range_mem_nhds_of_mem {y : E} {x : M}\n    (hy : y âˆˆ (extChartAt I x).target) : (extChartAt I x).target âˆª (range I)á¶œ âˆˆ ð“ y := by\n  rw [â† nhdsWithin_univ, â† union_compl_self (range I), nhdsWithin_union]\n  exact Filter.union_mem_sup (extChartAt_target_mem_nhdsWithin_of_mem hy) self_mem_nhdsWithin\n\n"}
{"name":"extChartAt_target_union_comp_range_mem_nhds_of_mem","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\ny : E\nx : M\nhy : Membership.mem (extChartAt I x).target y\nâŠ¢ Membership.mem (nhds y) (Union.union (extChartAt I x).target (HasCompl.compl (Set.range â†‘I)))","decl":"@[deprecated (since := \"2024-11-27\")] alias\nextChartAt_target_union_comp_range_mem_nhds_of_mem :=\nextChartAt_target_union_compl_range_mem_nhds_of_mem\n\n"}
{"name":"isOpen_extChartAt_target","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ¶ : NontriviallyNormedField ð•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\ninstâœÂ³ : TopologicalSpace H\ninstâœÂ² : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : I.Boundaryless\nx : M\nâŠ¢ IsOpen (extChartAt I x).target","decl":"/-- If we're boundaryless, `extChartAt` has open target -/\ntheorem isOpen_extChartAt_target [I.Boundaryless] (x : M) : IsOpen (extChartAt I x).target := by\n  simp_rw [extChartAt_target, I.range_eq_univ, inter_univ]\n  exact (PartialHomeomorph.open_target _).preimage I.continuous_symm\n\n"}
{"name":"extChartAt_target_mem_nhds","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ¶ : NontriviallyNormedField ð•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\ninstâœÂ³ : TopologicalSpace H\ninstâœÂ² : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : I.Boundaryless\nx : M\nâŠ¢ Membership.mem (nhds (â†‘(extChartAt I x) x)) (extChartAt I x).target","decl":"/-- If we're boundaryless, `(extChartAt I x).target` is a neighborhood of the key point -/\ntheorem extChartAt_target_mem_nhds [I.Boundaryless] (x : M) :\n    (extChartAt I x).target âˆˆ ð“ (extChartAt I x x) := by\n  convert extChartAt_target_mem_nhdsWithin x\n  simp only [I.range_eq_univ, nhdsWithin_univ]\n\n"}
{"name":"extChartAt_target_mem_nhds'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ¶ : NontriviallyNormedField ð•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\ninstâœÂ³ : TopologicalSpace H\ninstâœÂ² : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : I.Boundaryless\nx : M\ny : E\nm : Membership.mem (extChartAt I x).target y\nâŠ¢ Membership.mem (nhds y) (extChartAt I x).target","decl":"/-- If we're boundaryless, `(extChartAt I x).target` is a neighborhood of any of its points -/\ntheorem extChartAt_target_mem_nhds' [I.Boundaryless] {x : M} {y : E}\n    (m : y âˆˆ (extChartAt I x).target) : (extChartAt I x).target âˆˆ ð“ y :=\n  (isOpen_extChartAt_target x).mem_nhds m\n\n"}
{"name":"extChartAt_target_subset_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ HasSubset.Subset (extChartAt I x).target (Set.range â†‘I)","decl":"theorem extChartAt_target_subset_range (x : M) : (extChartAt I x).target âŠ† range I := by\n  simp only [mfld_simps]\n\n"}
{"name":"nhdsWithin_extChartAt_target_eq'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx y : M\nhy : Membership.mem (extChartAt I x).source y\nâŠ¢ Eq (nhdsWithin (â†‘(extChartAt I x) y) (extChartAt I x).target) (nhdsWithin (â†‘(extChartAt I x) y) (Set.range â†‘I))","decl":"/-- Around the image of a point in the source, the neighborhoods are the same\nwithin `(extChartAt I x).target` and within `range I`. -/\ntheorem nhdsWithin_extChartAt_target_eq' {x y : M} (hy : y âˆˆ (extChartAt I x).source) :\n    ð“[(extChartAt I x).target] extChartAt I x y = ð“[range I] extChartAt I x y :=\n  nhdsWithin_extend_target_eq _ <| by rwa [â† extChartAt_source I]\n\n"}
{"name":"nhdsWithin_extChartAt_target_eq_of_mem","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nz : E\nhz : Membership.mem (extChartAt I x).target z\nâŠ¢ Eq (nhdsWithin z (extChartAt I x).target) (nhdsWithin z (Set.range â†‘I))","decl":"/-- Around a point in the target, the neighborhoods are the same within `(extChartAt I x).target`\nand within `range I`. -/\ntheorem nhdsWithin_extChartAt_target_eq_of_mem {x : M} {z : E} (hz : z âˆˆ (extChartAt I x).target) :\n    ð“[(extChartAt I x).target] z = ð“[range I] z := by\n  rw [â† PartialEquiv.right_inv (extChartAt I x) hz]\n  exact nhdsWithin_extChartAt_target_eq' ((extChartAt I x).map_target hz)\n\n"}
{"name":"nhdsWithin_extChartAt_target_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ Eq (nhdsWithin (â†‘(extChartAt I x) x) (extChartAt I x).target) (nhdsWithin (â†‘(extChartAt I x) x) (Set.range â†‘I))","decl":"/-- Around the image of the base point, the neighborhoods are the same\nwithin `(extChartAt I x).target` and within `range I`. -/\ntheorem nhdsWithin_extChartAt_target_eq (x : M) :\n    ð“[(extChartAt I x).target] (extChartAt I x) x = ð“[range I] (extChartAt I x) x :=\n  nhdsWithin_extChartAt_target_eq' (mem_extChartAt_source x)\n\n"}
{"name":"extChartAt_target_eventuallyEq'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx y : M\nhy : Membership.mem (extChartAt I x).source y\nâŠ¢ (nhds (â†‘(extChartAt I x) y)).EventuallyEq (extChartAt I x).target (Set.range â†‘I)","decl":"/-- Around the image of a point in the source, `(extChartAt I x).target` and `range I`\ncoincide locally. -/\ntheorem extChartAt_target_eventuallyEq' {x y : M} (hy : y âˆˆ (extChartAt I x).source) :\n    (extChartAt I x).target =á¶ [ð“ (extChartAt I x y)] range I :=\n  nhdsWithin_eq_iff_eventuallyEq.1 (nhdsWithin_extChartAt_target_eq' hy)\n\n"}
{"name":"extChartAt_target_eventuallyEq_of_mem","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nz : E\nhz : Membership.mem (extChartAt I x).target z\nâŠ¢ (nhds z).EventuallyEq (extChartAt I x).target (Set.range â†‘I)","decl":"/-- Around a point in the target, `(extChartAt I x).target` and `range I` coincide locally. -/\ntheorem extChartAt_target_eventuallyEq_of_mem {x : M} {z : E} (hz : z âˆˆ (extChartAt I x).target) :\n    (extChartAt I x).target =á¶ [ð“ z] range I :=\n  nhdsWithin_eq_iff_eventuallyEq.1 (nhdsWithin_extChartAt_target_eq_of_mem hz)\n\n"}
{"name":"extChartAt_target_eventuallyEq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ (nhds (â†‘(extChartAt I x) x)).EventuallyEq (extChartAt I x).target (Set.range â†‘I)","decl":"/-- Around the image of the base point, `(extChartAt I x).target` and `range I` coincide locally. -/\ntheorem extChartAt_target_eventuallyEq {x : M} :\n    (extChartAt I x).target =á¶ [ð“ (extChartAt I x x)] range I :=\n  nhdsWithin_eq_iff_eventuallyEq.1 (nhdsWithin_extChartAt_target_eq x)\n\n"}
{"name":"continuousAt_extChartAt_symm''","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\ny : E\nh : Membership.mem (extChartAt I x).target y\nâŠ¢ ContinuousAt (â†‘(extChartAt I x).symm) y","decl":"theorem continuousAt_extChartAt_symm'' {x : M} {y : E} (h : y âˆˆ (extChartAt I x).target) :\n    ContinuousAt (extChartAt I x).symm y :=\n  continuousAt_extend_symm' _ h\n\n"}
{"name":"continuousAt_extChartAt_symm'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx x' : M\nh : Membership.mem (extChartAt I x).source x'\nâŠ¢ ContinuousAt (â†‘(extChartAt I x).symm) (â†‘(extChartAt I x) x')","decl":"theorem continuousAt_extChartAt_symm' {x x' : M} (h : x' âˆˆ (extChartAt I x).source) :\n    ContinuousAt (extChartAt I x).symm (extChartAt I x x') :=\n  continuousAt_extChartAt_symm'' <| (extChartAt I x).map_source h\n\n"}
{"name":"continuousAt_extChartAt_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ ContinuousAt (â†‘(extChartAt I x).symm) (â†‘(extChartAt I x) x)","decl":"theorem continuousAt_extChartAt_symm (x : M) :\n    ContinuousAt (extChartAt I x).symm ((extChartAt I x) x) :=\n  continuousAt_extChartAt_symm' (mem_extChartAt_source x)\n\n"}
{"name":"continuousOn_extChartAt_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ ContinuousOn (â†‘(extChartAt I x).symm) (extChartAt I x).target","decl":"theorem continuousOn_extChartAt_symm (x : M) :\n    ContinuousOn (extChartAt I x).symm (extChartAt I x).target :=\n  fun _y hy => (continuousAt_extChartAt_symm'' hy).continuousWithinAt\n\n"}
{"name":"extChartAt_target_subset_closure_interior","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ HasSubset.Subset (extChartAt I x).target (closure (interior (extChartAt I x).target))","decl":"lemma extChartAt_target_subset_closure_interior {x : M} :\n    (extChartAt I x).target âŠ† closure (interior (extChartAt I x).target) := by\n  intro y hy\n  rw [mem_closure_iff_nhds]\n  intro t ht\n  have A : t âˆ© ((extChartAt I x).target âˆª (range I)á¶œ) âˆˆ ð“ y :=\n    inter_mem ht (extChartAt_target_union_compl_range_mem_nhds_of_mem hy)\n  have B : y âˆˆ closure (interior (range I)) := by\n    apply I.range_subset_closure_interior (extChartAt_target_subset_range x hy)\n  obtain âŸ¨z, âŸ¨tz, h'zâŸ©, hzâŸ© :\n      (t âˆ© ((extChartAt I x).target âˆª (range â†‘I)á¶œ) âˆ© interior (range I)).Nonempty :=\n    mem_closure_iff_nhds.1 B _ A\n  refine âŸ¨z, âŸ¨tz, ?_âŸ©âŸ©\n  have h''z : z âˆˆ (extChartAt I x).target := by simpa [interior_subset hz] using h'z\n  exact (extChartAt_target_eventuallyEq_of_mem h''z).symm.mem_interior hz\n\n"}
{"name":"interior_extChartAt_target_nonempty","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ (interior (extChartAt I x).target).Nonempty","decl":"variable (I) in\ntheorem interior_extChartAt_target_nonempty (x : M) :\n    (interior (extChartAt I x).target).Nonempty := by\n  by_contra! H\n  have := extChartAt_target_subset_closure_interior (mem_extChartAt_target (I := I) x)\n  simp only [H, closure_empty, mem_empty_iff_false] at this\n\n"}
{"name":"extChartAt_mem_closure_interior","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ns : Set M\ninstâœ : ChartedSpace H M\nxâ‚€ x : M\nhx : Membership.mem (closure (interior s)) x\nh'x : Membership.mem (extChartAt I xâ‚€).source x\nâŠ¢ Membership.mem (closure (interior (Inter.inter (Set.preimage (â†‘(extChartAt I xâ‚€).symm) s) (extChartAt I xâ‚€).target))) (â†‘(extChartAt I xâ‚€) x)","decl":"lemma extChartAt_mem_closure_interior {xâ‚€ x : M}\n    (hx : x âˆˆ closure (interior s)) (h'x : x âˆˆ (extChartAt I xâ‚€).source) :\n    extChartAt I xâ‚€ x âˆˆ\n      closure (interior ((extChartAt I xâ‚€).symm â»Â¹' s âˆ© (extChartAt I xâ‚€).target)) := by\n  simp_rw [mem_closure_iff, interior_inter, â† inter_assoc]\n  intro o o_open ho\n  obtain âŸ¨y, âŸ¨yo, hyâŸ©, ysâŸ© :\n      ((extChartAt I xâ‚€) â»Â¹' o âˆ© (extChartAt I xâ‚€).source âˆ© interior s).Nonempty := by\n    have : (extChartAt I xâ‚€) â»Â¹' o âˆˆ ð“ x := by\n      apply (continuousAt_extChartAt' h'x).preimage_mem_nhds (o_open.mem_nhds ho)\n    refine (mem_closure_iff_nhds.1 hx) _ (inter_mem this ?_)\n    apply (isOpen_extChartAt_source xâ‚€).mem_nhds h'x\n  have A : interior (â†‘(extChartAt I xâ‚€).symm â»Â¹' s) âˆˆ ð“ (extChartAt I xâ‚€ y) := by\n    simp only [interior_mem_nhds]\n    apply (continuousAt_extChartAt_symm' hy).preimage_mem_nhds\n    simp only [hy, PartialEquiv.left_inv]\n    exact mem_interior_iff_mem_nhds.mp ys\n  have B : (extChartAt I xâ‚€) y âˆˆ closure (interior (extChartAt I xâ‚€).target) := by\n    apply extChartAt_target_subset_closure_interior (x := xâ‚€)\n    exact (extChartAt I xâ‚€).map_source hy\n  exact mem_closure_iff_nhds.1 B _ (inter_mem (o_open.mem_nhds yo) A)\n\n"}
{"name":"isOpen_extChartAt_preimage'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\ns : Set E\nhs : IsOpen s\nâŠ¢ IsOpen (Inter.inter (extChartAt I x).source (Set.preimage (â†‘(extChartAt I x)) s))","decl":"theorem isOpen_extChartAt_preimage' (x : M) {s : Set E} (hs : IsOpen s) :\n    IsOpen ((extChartAt I x).source âˆ© extChartAt I x â»Â¹' s) :=\n  isOpen_extend_preimage' _ hs\n\n"}
{"name":"isOpen_extChartAt_preimage","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\ns : Set E\nhs : IsOpen s\nâŠ¢ IsOpen (Inter.inter (chartAt H x).source (Set.preimage (â†‘(extChartAt I x)) s))","decl":"theorem isOpen_extChartAt_preimage (x : M) {s : Set E} (hs : IsOpen s) :\n    IsOpen ((chartAt H x).source âˆ© extChartAt I x â»Â¹' s) := by\n  rw [â† extChartAt_source I]\n  exact isOpen_extChartAt_preimage' x hs\n\n"}
{"name":"map_extChartAt_nhdsWithin_eq_image'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ns : Set M\ninstâœ : ChartedSpace H M\nx y : M\nhy : Membership.mem (extChartAt I x).source y\nâŠ¢ Eq (Filter.map (â†‘(extChartAt I x)) (nhdsWithin y s)) (nhdsWithin (â†‘(extChartAt I x) y) (Set.image (â†‘(extChartAt I x)) (Inter.inter (extChartAt I x).source s)))","decl":"theorem map_extChartAt_nhdsWithin_eq_image' {x y : M} (hy : y âˆˆ (extChartAt I x).source) :\n    map (extChartAt I x) (ð“[s] y) =\n      ð“[extChartAt I x '' ((extChartAt I x).source âˆ© s)] extChartAt I x y :=\n  map_extend_nhdsWithin_eq_image _ <| by rwa [â† extChartAt_source I]\n\n"}
{"name":"map_extChartAt_nhdsWithin_eq_image","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ns : Set M\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ Eq (Filter.map (â†‘(extChartAt I x)) (nhdsWithin x s)) (nhdsWithin (â†‘(extChartAt I x) x) (Set.image (â†‘(extChartAt I x)) (Inter.inter (extChartAt I x).source s)))","decl":"theorem map_extChartAt_nhdsWithin_eq_image (x : M) :\n    map (extChartAt I x) (ð“[s] x) =\n      ð“[extChartAt I x '' ((extChartAt I x).source âˆ© s)] extChartAt I x x :=\n  map_extChartAt_nhdsWithin_eq_image' (mem_extChartAt_source x)\n\n"}
{"name":"map_extChartAt_nhdsWithin'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ns : Set M\ninstâœ : ChartedSpace H M\nx y : M\nhy : Membership.mem (extChartAt I x).source y\nâŠ¢ Eq (Filter.map (â†‘(extChartAt I x)) (nhdsWithin y s)) (nhdsWithin (â†‘(extChartAt I x) y) (Inter.inter (Set.preimage (â†‘(extChartAt I x).symm) s) (Set.range â†‘I)))","decl":"theorem map_extChartAt_nhdsWithin' {x y : M} (hy : y âˆˆ (extChartAt I x).source) :\n    map (extChartAt I x) (ð“[s] y) = ð“[(extChartAt I x).symm â»Â¹' s âˆ© range I] extChartAt I x y :=\n  map_extend_nhdsWithin _ <| by rwa [â† extChartAt_source I]\n\n"}
{"name":"map_extChartAt_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ns : Set M\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ Eq (Filter.map (â†‘(extChartAt I x)) (nhdsWithin x s)) (nhdsWithin (â†‘(extChartAt I x) x) (Inter.inter (Set.preimage (â†‘(extChartAt I x).symm) s) (Set.range â†‘I)))","decl":"theorem map_extChartAt_nhdsWithin (x : M) :\n    map (extChartAt I x) (ð“[s] x) = ð“[(extChartAt I x).symm â»Â¹' s âˆ© range I] extChartAt I x x :=\n  map_extChartAt_nhdsWithin' (mem_extChartAt_source x)\n\n"}
{"name":"map_extChartAt_symm_nhdsWithin'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ns : Set M\ninstâœ : ChartedSpace H M\nx y : M\nhy : Membership.mem (extChartAt I x).source y\nâŠ¢ Eq (Filter.map (â†‘(extChartAt I x).symm) (nhdsWithin (â†‘(extChartAt I x) y) (Inter.inter (Set.preimage (â†‘(extChartAt I x).symm) s) (Set.range â†‘I)))) (nhdsWithin y s)","decl":"theorem map_extChartAt_symm_nhdsWithin' {x y : M} (hy : y âˆˆ (extChartAt I x).source) :\n    map (extChartAt I x).symm (ð“[(extChartAt I x).symm â»Â¹' s âˆ© range I] extChartAt I x y) =\n      ð“[s] y :=\n  map_extend_symm_nhdsWithin _ <| by rwa [â† extChartAt_source I]\n\n"}
{"name":"map_extChartAt_symm_nhdsWithin_range'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx y : M\nhy : Membership.mem (extChartAt I x).source y\nâŠ¢ Eq (Filter.map (â†‘(extChartAt I x).symm) (nhdsWithin (â†‘(extChartAt I x) y) (Set.range â†‘I))) (nhds y)","decl":"theorem map_extChartAt_symm_nhdsWithin_range' {x y : M} (hy : y âˆˆ (extChartAt I x).source) :\n    map (extChartAt I x).symm (ð“[range I] extChartAt I x y) = ð“ y :=\n  map_extend_symm_nhdsWithin_range _ <| by rwa [â† extChartAt_source I]\n\n"}
{"name":"map_extChartAt_symm_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ns : Set M\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ Eq (Filter.map (â†‘(extChartAt I x).symm) (nhdsWithin (â†‘(extChartAt I x) x) (Inter.inter (Set.preimage (â†‘(extChartAt I x).symm) s) (Set.range â†‘I)))) (nhdsWithin x s)","decl":"theorem map_extChartAt_symm_nhdsWithin (x : M) :\n    map (extChartAt I x).symm (ð“[(extChartAt I x).symm â»Â¹' s âˆ© range I] extChartAt I x x) =\n      ð“[s] x :=\n  map_extChartAt_symm_nhdsWithin' (mem_extChartAt_source x)\n\n"}
{"name":"map_extChartAt_symm_nhdsWithin_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ Eq (Filter.map (â†‘(extChartAt I x).symm) (nhdsWithin (â†‘(extChartAt I x) x) (Set.range â†‘I))) (nhds x)","decl":"theorem map_extChartAt_symm_nhdsWithin_range (x : M) :\n    map (extChartAt I x).symm (ð“[range I] extChartAt I x x) = ð“ x :=\n  map_extChartAt_symm_nhdsWithin_range' (mem_extChartAt_source x)\n\n"}
{"name":"extChartAt_preimage_mem_nhdsWithin'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ns t : Set M\ninstâœ : ChartedSpace H M\nx x' : M\nh : Membership.mem (extChartAt I x).source x'\nht : Membership.mem (nhdsWithin x' s) t\nâŠ¢ Membership.mem (nhdsWithin (â†‘(extChartAt I x) x') (Inter.inter (Set.preimage (â†‘(extChartAt I x).symm) s) (Set.range â†‘I))) (Set.preimage (â†‘(extChartAt I x).symm) t)","decl":"/-- Technical lemma ensuring that the preimage under an extended chart of a neighborhood of a point\nin the source is a neighborhood of the preimage, within a set. -/\ntheorem extChartAt_preimage_mem_nhdsWithin' {x x' : M} (h : x' âˆˆ (extChartAt I x).source)\n    (ht : t âˆˆ ð“[s] x') :\n    (extChartAt I x).symm â»Â¹' t âˆˆ ð“[(extChartAt I x).symm â»Â¹' s âˆ© range I] (extChartAt I x) x' := by\n  rwa [â† map_extChartAt_symm_nhdsWithin' h, mem_map] at ht\n\n"}
{"name":"extChartAt_preimage_mem_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ns t : Set M\ninstâœ : ChartedSpace H M\nx : M\nht : Membership.mem (nhdsWithin x s) t\nâŠ¢ Membership.mem (nhdsWithin (â†‘(extChartAt I x) x) (Inter.inter (Set.preimage (â†‘(extChartAt I x).symm) s) (Set.range â†‘I))) (Set.preimage (â†‘(extChartAt I x).symm) t)","decl":"/-- Technical lemma ensuring that the preimage under an extended chart of a neighborhood of the\nbase point is a neighborhood of the preimage, within a set. -/\ntheorem extChartAt_preimage_mem_nhdsWithin {x : M} (ht : t âˆˆ ð“[s] x) :\n    (extChartAt I x).symm â»Â¹' t âˆˆ ð“[(extChartAt I x).symm â»Â¹' s âˆ© range I] (extChartAt I x) x :=\n  extChartAt_preimage_mem_nhdsWithin' (mem_extChartAt_source x) ht\n\n"}
{"name":"extChartAt_preimage_mem_nhds'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\nt : Set M\ninstâœ : ChartedSpace H M\nx x' : M\nh : Membership.mem (extChartAt I x).source x'\nht : Membership.mem (nhds x') t\nâŠ¢ Membership.mem (nhds (â†‘(extChartAt I x) x')) (Set.preimage (â†‘(extChartAt I x).symm) t)","decl":"theorem extChartAt_preimage_mem_nhds' {x x' : M} (h : x' âˆˆ (extChartAt I x).source)\n    (ht : t âˆˆ ð“ x') : (extChartAt I x).symm â»Â¹' t âˆˆ ð“ (extChartAt I x x') :=\n  extend_preimage_mem_nhds _ (by rwa [â† extChartAt_source I]) ht\n\n"}
{"name":"extChartAt_preimage_mem_nhds","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\nt : Set M\ninstâœ : ChartedSpace H M\nx : M\nht : Membership.mem (nhds x) t\nâŠ¢ Membership.mem (nhds (â†‘(extChartAt I x) x)) (Set.preimage (â†‘(extChartAt I x).symm) t)","decl":"/-- Technical lemma ensuring that the preimage under an extended chart of a neighborhood of a point\nis a neighborhood of the preimage. -/\ntheorem extChartAt_preimage_mem_nhds {x : M} (ht : t âˆˆ ð“ x) :\n    (extChartAt I x).symm â»Â¹' t âˆˆ ð“ ((extChartAt I x) x) := by\n  apply (continuousAt_extChartAt_symm x).preimage_mem_nhds\n  rwa [(extChartAt I x).left_inv (mem_extChartAt_source _)]\n\n"}
{"name":"extChartAt_preimage_inter_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ns t : Set M\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ Eq (Inter.inter (Set.preimage (â†‘(extChartAt I x).symm) (Inter.inter s t)) (Set.range â†‘I)) (Inter.inter (Inter.inter (Set.preimage (â†‘(extChartAt I x).symm) s) (Set.range â†‘I)) (Set.preimage (â†‘(extChartAt I x).symm) t))","decl":"/-- Technical lemma to rewrite suitably the preimage of an intersection under an extended chart, to\nbring it into a convenient form to apply derivative lemmas. -/\ntheorem extChartAt_preimage_inter_eq (x : M) :\n    (extChartAt I x).symm â»Â¹' (s âˆ© t) âˆ© range I =\n      (extChartAt I x).symm â»Â¹' s âˆ© range I âˆ© (extChartAt I x).symm â»Â¹' t := by\n  mfld_set_tac\n\n"}
{"name":"ContinuousWithinAt.nhdsWithin_extChartAt_symm_preimage_inter_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\nE' : Type u_5\nM' : Type u_6\nH' : Type u_7\ninstâœÂ¹â° : NontriviallyNormedField ð•œ\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ð•œ E\ninstâœâ· : TopologicalSpace H\ninstâœâ¶ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœâµ : NormedAddCommGroup E'\ninstâœâ´ : NormedSpace ð•œ E'\ninstâœÂ³ : TopologicalSpace H'\ninstâœÂ² : TopologicalSpace M'\nI' : ModelWithCorners ð•œ E' H'\ns : Set M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\nx : M\nhc : ContinuousWithinAt f s x\nâŠ¢ Eq (nhdsWithin (â†‘(extChartAt I x) x) (Inter.inter (Set.preimage (â†‘(extChartAt I x).symm) s) (Set.range â†‘I))) (nhdsWithin (â†‘(extChartAt I x) x) (Inter.inter (extChartAt I x).target (Set.preimage (â†‘(extChartAt I x).symm) (Inter.inter s (Set.preimage f (extChartAt I' (f x)).source)))))","decl":"theorem ContinuousWithinAt.nhdsWithin_extChartAt_symm_preimage_inter_range\n    {f : M â†’ M'} {x : M} (hc : ContinuousWithinAt f s x) :\n    ð“[(extChartAt I x).symm â»Â¹' s âˆ© range I] (extChartAt I x x) =\n      ð“[(extChartAt I x).target âˆ©\n        (extChartAt I x).symm â»Â¹' (s âˆ© f â»Â¹' (extChartAt I' (f x)).source)] (extChartAt I x x) := by\n  rw [â† (extChartAt I x).image_source_inter_eq', â† map_extChartAt_nhdsWithin_eq_image,\n    â† map_extChartAt_nhdsWithin, nhdsWithin_inter_of_mem']\n  exact hc (extChartAt_source_mem_nhds _)\n\n"}
{"name":"ContinuousWithinAt.extChartAt_symm_preimage_inter_range_eventuallyEq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\nE' : Type u_5\nM' : Type u_6\nH' : Type u_7\ninstâœÂ¹â° : NontriviallyNormedField ð•œ\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ð•œ E\ninstâœâ· : TopologicalSpace H\ninstâœâ¶ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœâµ : NormedAddCommGroup E'\ninstâœâ´ : NormedSpace ð•œ E'\ninstâœÂ³ : TopologicalSpace H'\ninstâœÂ² : TopologicalSpace M'\nI' : ModelWithCorners ð•œ E' H'\ns : Set M\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\nx : M\nhc : ContinuousWithinAt f s x\nâŠ¢ (nhds (â†‘(extChartAt I x) x)).EventuallyEq (Inter.inter (Set.preimage (â†‘(extChartAt I x).symm) s) (Set.range â†‘I)) (Inter.inter (extChartAt I x).target (Set.preimage (â†‘(extChartAt I x).symm) (Inter.inter s (Set.preimage f (extChartAt I' (f x)).source))))","decl":"theorem ContinuousWithinAt.extChartAt_symm_preimage_inter_range_eventuallyEq\n    {f : M â†’ M'} {x : M} (hc : ContinuousWithinAt f s x) :\n    ((extChartAt I x).symm â»Â¹' s âˆ© range I : Set E) =á¶ [ð“ (extChartAt I x x)]\n      ((extChartAt I x).target âˆ©\n        (extChartAt I x).symm â»Â¹' (s âˆ© f â»Â¹' (extChartAt I' (f x)).source) : Set E) := by\n  rw [â† nhdsWithin_eq_iff_eventuallyEq]\n  exact hc.nhdsWithin_extChartAt_symm_preimage_inter_range\n\n"}
{"name":"ext_coord_change_source","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx x' : M\nâŠ¢ Eq ((extChartAt I x').symm.trans (extChartAt I x)).source (Set.image (â†‘I) ((chartAt H x').symm.trans (chartAt H x)).source)","decl":"theorem ext_coord_change_source (x x' : M) :\n    ((extChartAt I x').symm â‰« extChartAt I x).source =\n      I '' ((chartAt H x').symm â‰«â‚• chartAt H x).source :=\n  extend_coord_change_source _ _\n\n"}
{"name":"contDiffOn_ext_coord_change","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ¶ : NontriviallyNormedField ð•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\ninstâœÂ³ : TopologicalSpace H\ninstâœÂ² : TopologicalSpace M\nn : WithTop ENat\nI : ModelWithCorners ð•œ E H\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : IsManifold I n M\nx x' : M\nâŠ¢ ContDiffOn ð•œ n (Function.comp â†‘(extChartAt I x) â†‘(extChartAt I x').symm) ((extChartAt I x').symm.trans (extChartAt I x)).source","decl":"theorem contDiffOn_ext_coord_change [IsManifold I n M] (x x' : M) :\n    ContDiffOn ð•œ n (extChartAt I x âˆ˜ (extChartAt I x').symm)\n      ((extChartAt I x').symm â‰« extChartAt I x).source :=\n  contDiffOn_extend_coord_change (chart_mem_maximalAtlas x) (chart_mem_maximalAtlas x')\n\n"}
{"name":"contDiffWithinAt_ext_coord_change","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâ¶ : NontriviallyNormedField ð•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\ninstâœÂ³ : TopologicalSpace H\ninstâœÂ² : TopologicalSpace M\nn : WithTop ENat\nI : ModelWithCorners ð•œ E H\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : IsManifold I n M\nx x' : M\ny : E\nhy : Membership.mem ((extChartAt I x').symm.trans (extChartAt I x)).source y\nâŠ¢ ContDiffWithinAt ð•œ n (Function.comp â†‘(extChartAt I x) â†‘(extChartAt I x').symm) (Set.range â†‘I) y","decl":"theorem contDiffWithinAt_ext_coord_change [IsManifold I n M] (x x' : M) {y : E}\n    (hy : y âˆˆ ((extChartAt I x').symm â‰« extChartAt I x).source) :\n    ContDiffWithinAt ð•œ n (extChartAt I x âˆ˜ (extChartAt I x').symm) (range I) y :=\n  contDiffWithinAt_extend_coord_change (chart_mem_maximalAtlas x) (chart_mem_maximalAtlas x') hy\n\n"}
{"name":"writtenInExtChartAt_chartAt","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\ny : E\nh : Membership.mem (extChartAt I x).target y\nâŠ¢ Eq (writtenInExtChartAt I I x (â†‘(chartAt H x)) y) y","decl":"theorem writtenInExtChartAt_chartAt {x : M} {y : E} (h : y âˆˆ (extChartAt I x).target) :\n    writtenInExtChartAt I I x (chartAt H x) y = y := by simp_all only [mfld_simps]\n\n"}
{"name":"writtenInExtChartAt_chartAt_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\ny : E\nh : Membership.mem (extChartAt I x).target y\nâŠ¢ Eq (writtenInExtChartAt I I (â†‘(chartAt H x) x) (â†‘(chartAt H x).symm) y) y","decl":"theorem writtenInExtChartAt_chartAt_symm {x : M} {y : E} (h : y âˆˆ (extChartAt I x).target) :\n    writtenInExtChartAt I I (chartAt H x x) (chartAt H x).symm y = y := by\n  simp_all only [mfld_simps]\n\n"}
{"name":"writtenInExtChartAt_extChartAt","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\ny : E\nh : Membership.mem (extChartAt I x).target y\nâŠ¢ Eq (writtenInExtChartAt I (modelWithCornersSelf ð•œ E) x (â†‘(extChartAt I x)) y) y","decl":"theorem writtenInExtChartAt_extChartAt {x : M} {y : E} (h : y âˆˆ (extChartAt I x).target) :\n    writtenInExtChartAt I ð“˜(ð•œ, E) x (extChartAt I x) y = y := by\n  simp_all only [mfld_simps]\n\n"}
{"name":"writtenInExtChartAt_extChartAt_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninstâœâµ : NontriviallyNormedField ð•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\ninstâœÂ² : TopologicalSpace H\ninstâœÂ¹ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœ : ChartedSpace H M\nx : M\ny : E\nh : Membership.mem (extChartAt I x).target y\nâŠ¢ Eq (writtenInExtChartAt (modelWithCornersSelf ð•œ E) I (â†‘(extChartAt I x) x) (â†‘(extChartAt I x).symm) y) y","decl":"theorem writtenInExtChartAt_extChartAt_symm {x : M} {y : E} (h : y âˆˆ (extChartAt I x).target) :\n    writtenInExtChartAt ð“˜(ð•œ, E) I (extChartAt I x x) (extChartAt I x).symm y = y := by\n  simp_all only [mfld_simps]\n\n"}
{"name":"extChartAt_self_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nH : Type u_4\ninstâœÂ³ : NontriviallyNormedField ð•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nx : H\nâŠ¢ Eq â†‘(extChartAt I x) â†‘I","decl":"theorem extChartAt_self_eq {x : H} : â‡‘(extChartAt I x) = I :=\n  rfl\n\n"}
{"name":"extChartAt_self_apply","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nH : Type u_4\ninstâœÂ³ : NontriviallyNormedField ð•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ð•œ E\ninstâœ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nx y : H\nâŠ¢ Eq (â†‘(extChartAt I x) y) (â†‘I y)","decl":"theorem extChartAt_self_apply {x y : H} : extChartAt I x y = I y :=\n  rfl\n\n"}
{"name":"extChartAt_model_space_eq_id","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NontriviallyNormedField ð•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ð•œ E\nx : E\nâŠ¢ Eq (extChartAt (modelWithCornersSelf ð•œ E) x) (PartialEquiv.refl E)","decl":"/-- In the case of the manifold structure on a vector space, the extended charts are just the\nidentity. -/\ntheorem extChartAt_model_space_eq_id (x : E) : extChartAt ð“˜(ð•œ, E) x = PartialEquiv.refl E := by\n  simp only [mfld_simps]\n\n"}
{"name":"ext_chart_model_space_apply","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NontriviallyNormedField ð•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ð•œ E\nx y : E\nâŠ¢ Eq (â†‘(extChartAt (modelWithCornersSelf ð•œ E) x) y) y","decl":"theorem ext_chart_model_space_apply {x y : E} : extChartAt ð“˜(ð•œ, E) x y = y :=\n  rfl\n\n"}
{"name":"extChartAt_prod","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\nE' : Type u_5\nM' : Type u_6\nH' : Type u_7\ninstâœÂ¹â° : NontriviallyNormedField ð•œ\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ð•œ E\ninstâœâ· : TopologicalSpace H\ninstâœâ¶ : TopologicalSpace M\nI : ModelWithCorners ð•œ E H\ninstâœâµ : NormedAddCommGroup E'\ninstâœâ´ : NormedSpace ð•œ E'\ninstâœÂ³ : TopologicalSpace H'\ninstâœÂ² : TopologicalSpace M'\nI' : ModelWithCorners ð•œ E' H'\ninstâœÂ¹ : ChartedSpace H M\ninstâœ : ChartedSpace H' M'\nx : Prod M M'\nâŠ¢ Eq (extChartAt (I.prod I') x) ((extChartAt I x.1).prod (extChartAt I' x.2))","decl":"theorem extChartAt_prod (x : M Ã— M') :\n    extChartAt (I.prod I') x = (extChartAt I x.1).prod (extChartAt I' x.2) := by\n  simp only [mfld_simps]\n  -- Porting note: `simp` can't use `PartialEquiv.prod_trans` here because of a type\n  -- synonym\n  rw [PartialEquiv.prod_trans]\n\n"}
{"name":"extChartAt_comp","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nH : Type u_4\nM' : Type u_6\nH' : Type u_7\ninstâœâ· : NontriviallyNormedField ð•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ð•œ E\ninstâœâ´ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\ninstâœÂ³ : TopologicalSpace H'\ninstâœÂ² : TopologicalSpace M'\ninstâœÂ¹ : ChartedSpace H' M'\ninstâœ : ChartedSpace H H'\nx : M'\nâŠ¢ Eq (extChartAt I x) ((chartAt H' x).trans (extChartAt I (â†‘(chartAt H' x) x)))","decl":"theorem extChartAt_comp [ChartedSpace H H'] (x : M') :\n    (letI := ChartedSpace.comp H H' M'; extChartAt I x) =\n      (chartAt H' x).toPartialEquiv â‰« extChartAt I (chartAt H' x x) :=\n  PartialEquiv.trans_assoc ..\n\n"}
{"name":"writtenInExtChartAt_chartAt_comp","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nH : Type u_4\nM' : Type u_6\nH' : Type u_7\ninstâœâ· : NontriviallyNormedField ð•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ð•œ E\ninstâœâ´ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\ninstâœÂ³ : TopologicalSpace H'\ninstâœÂ² : TopologicalSpace M'\ninstâœÂ¹ : ChartedSpace H' M'\ninstâœ : ChartedSpace H H'\nx : M'\ny : E\nhy : Membership.mem (extChartAt I x).target y\nâŠ¢ Eq (writtenInExtChartAt I I x (â†‘(chartAt H' x)) y) y","decl":"theorem writtenInExtChartAt_chartAt_comp [ChartedSpace H H'] (x : M') {y}\n    (hy : y âˆˆ letI := ChartedSpace.comp H H' M'; (extChartAt I x).target) :\n    (letI := ChartedSpace.comp H H' M'; writtenInExtChartAt I I x (chartAt H' x) y) = y := by\n  letI := ChartedSpace.comp H H' M'\n  simp_all only [mfld_simps, chartAt_comp]\n\n"}
{"name":"writtenInExtChartAt_chartAt_symm_comp","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\nE : Type u_2\nH : Type u_4\nM' : Type u_6\nH' : Type u_7\ninstâœâ· : NontriviallyNormedField ð•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ð•œ E\ninstâœâ´ : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\ninstâœÂ³ : TopologicalSpace H'\ninstâœÂ² : TopologicalSpace M'\ninstâœÂ¹ : ChartedSpace H' M'\ninstâœ : ChartedSpace H H'\nx : M'\ny : E\nhy : Membership.mem (extChartAt I x).target y\nâŠ¢ Eq (writtenInExtChartAt I I (â†‘(chartAt H' x) x) (â†‘(chartAt H' x).symm) y) y","decl":"theorem writtenInExtChartAt_chartAt_symm_comp [ChartedSpace H H'] (x : M') {y}\n    (hy : y âˆˆ letI := ChartedSpace.comp H H' M'; (extChartAt I x).target) :\n    ( letI := ChartedSpace.comp H H' M'\n      writtenInExtChartAt I I (chartAt H' x x) (chartAt H' x).symm y) = y := by\n  letI := ChartedSpace.comp H H' M'\n  simp_all only [mfld_simps, chartAt_comp]\n\n"}
{"name":"Manifold.locallyCompact_of_finiteDimensional","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"E : Type u_1\nð•œ : Type u_2\ninstâœâ· : NontriviallyNormedField ð•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace ð•œ E\nH : Type u_3\ninstâœâ´ : TopologicalSpace H\nM : Type u_4\ninstâœÂ³ : TopologicalSpace M\ninstâœÂ² : ChartedSpace H M\nI : ModelWithCorners ð•œ E H\ninstâœÂ¹ : LocallyCompactSpace ð•œ\ninstâœ : FiniteDimensional ð•œ E\nâŠ¢ LocallyCompactSpace M","decl":"/-- A finite-dimensional manifold modelled on a locally compact field\n  (such as â„, â„‚ or the `p`-adic numbers) is locally compact. -/\nlemma Manifold.locallyCompact_of_finiteDimensional\n    (I : ModelWithCorners ð•œ E H) [LocallyCompactSpace ð•œ] [FiniteDimensional ð•œ E] :\n    LocallyCompactSpace M := by\n  have : ProperSpace E := FiniteDimensional.proper ð•œ E\n  have : LocallyCompactSpace H := I.locallyCompactSpace\n  exact ChartedSpace.locallyCompactSpace H M\n\n"}
{"name":"LocallyCompactSpace.of_locallyCompact_manifold","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"E : Type u_1\nð•œ : Type u_2\ninstâœâ¶ : NontriviallyNormedField ð•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ³ : TopologicalSpace H\nM : Type u_4\ninstâœÂ² : TopologicalSpace M\ninstâœÂ¹ : ChartedSpace H M\nI : ModelWithCorners ð•œ E H\nh : Nonempty M\ninstâœ : LocallyCompactSpace M\nâŠ¢ LocallyCompactSpace E","decl":"/-- A locally compact manifold must be modelled on a locally compact space. -/\nlemma LocallyCompactSpace.of_locallyCompact_manifold (I : ModelWithCorners ð•œ E H)\n    [h : Nonempty M] [LocallyCompactSpace M] :\n    LocallyCompactSpace E := by\n  rcases h with âŸ¨xâŸ©\n  obtain âŸ¨y, hyâŸ© := interior_extChartAt_target_nonempty I x\n  have h'y : y âˆˆ (extChartAt I x).target := interior_subset hy\n  obtain âŸ¨s, hmem, hss, hcomâŸ© :=\n    LocallyCompactSpace.local_compact_nhds ((extChartAt I x).symm y) (extChartAt I x).source\n      ((isOpen_extChartAt_source x).mem_nhds ((extChartAt I x).map_target h'y))\n  have : IsCompact <| (extChartAt I x) '' s :=\n    hcom.image_of_continuousOn <| (continuousOn_extChartAt x).mono hss\n  apply this.locallyCompactSpace_of_mem_nhds_of_addGroup (x := y)\n  rw [â† (extChartAt I x).right_inv h'y]\n  apply extChartAt_image_nhd_mem_nhds_of_mem_interior_range\n    (PartialEquiv.map_target (extChartAt I x) h'y) _ hmem\n  simp only [(extChartAt I x).right_inv h'y]\n  exact interior_mono (extChartAt_target_subset_range x) hy\n\n"}
{"name":"FiniteDimensional.of_locallyCompact_manifold","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"E : Type u_1\nð•œ : Type u_2\ninstâœâ¸ : NontriviallyNormedField ð•œ\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ð•œ E\nH : Type u_3\ninstâœâµ : TopologicalSpace H\nM : Type u_4\ninstâœâ´ : TopologicalSpace M\ninstâœÂ³ : ChartedSpace H M\ninstâœÂ² : CompleteSpace ð•œ\nI : ModelWithCorners ð•œ E H\ninstâœÂ¹ : Nonempty M\ninstâœ : LocallyCompactSpace M\nâŠ¢ FiniteDimensional ð•œ E","decl":"/-- Riesz's theorem applied to manifolds: a locally compact manifolds must be modelled on a\n  finite-dimensional space. This is the converse to\n  `Manifold.locallyCompact_of_finiteDimensional`. -/\ntheorem FiniteDimensional.of_locallyCompact_manifold\n    [CompleteSpace ð•œ] (I : ModelWithCorners ð•œ E H) [Nonempty M] [LocallyCompactSpace M] :\n    FiniteDimensional ð•œ E := by\n  have := LocallyCompactSpace.of_locallyCompact_manifold M I\n  exact FiniteDimensional.of_locallyCompactSpace ð•œ\n\n"}
{"name":"instTopologicalAddGroupTangentSpace","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"ð•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ð•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ð•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ð•œ E H\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ TopologicalAddGroup (TangentSpace I x)","decl":"instance : TopologicalAddGroup (TangentSpace I x) := inferInstanceAs (TopologicalAddGroup E)\n"}
{"name":"instPathConnectedSpaceTangentSpaceReal","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"E : Type u_1\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nH : Type u_2\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nx : M\nâŠ¢ PathConnectedSpace (TangentSpace I x)","decl":"instance : PathConnectedSpace (TangentSpace I x) := inferInstanceAs (PathConnectedSpace E)\n\n"}
