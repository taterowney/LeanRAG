{"name":"ModelWithCorners.continuous_invFun","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nself : ModelWithCorners 𝕜 E H\n⊢ Continuous self.invFun","decl":"/-- A structure containing information on the way a space `H` embeds in a\nmodel vector space `E` over the field `𝕜`. This is all what is needed to\ndefine a `C^n` manifold with model space `H`, and model vector space `E`.\n\nWe require two conditions `uniqueDiffOn'` and `target_subset_closure_interior`, which\nare satisfied in the relevant cases (where `range I = univ` or a half space or a quadrant) and\nuseful for technical reasons. The former makes sure that manifold derivatives are uniquely\ndefined, the latter ensures that for `C^2` maps the second derivatives are symmetric even for points\non the boundary, as these are limit points of interior points where symmetry holds. If further\nconditions turn out to be useful, they can be added here.\n-/\n@[ext]\nstructure ModelWithCorners (𝕜 : Type*) [NontriviallyNormedField 𝕜] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] (H : Type*) [TopologicalSpace H] extends\n    PartialEquiv H E where\n  source_eq : source = univ\n  uniqueDiffOn' : UniqueDiffOn 𝕜 toPartialEquiv.target\n  target_subset_closure_interior : toPartialEquiv.target ⊆ closure (interior toPartialEquiv.target)\n  continuous_toFun : Continuous toFun := by continuity\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"ModelWithCorners.continuous_toFun","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nself : ModelWithCorners 𝕜 E H\n⊢ Continuous ↑self.toPartialEquiv","decl":"/-- A structure containing information on the way a space `H` embeds in a\nmodel vector space `E` over the field `𝕜`. This is all what is needed to\ndefine a `C^n` manifold with model space `H`, and model vector space `E`.\n\nWe require two conditions `uniqueDiffOn'` and `target_subset_closure_interior`, which\nare satisfied in the relevant cases (where `range I = univ` or a half space or a quadrant) and\nuseful for technical reasons. The former makes sure that manifold derivatives are uniquely\ndefined, the latter ensures that for `C^2` maps the second derivatives are symmetric even for points\non the boundary, as these are limit points of interior points where symmetry holds. If further\nconditions turn out to be useful, they can be added here.\n-/\n@[ext]\nstructure ModelWithCorners (𝕜 : Type*) [NontriviallyNormedField 𝕜] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] (H : Type*) [TopologicalSpace H] extends\n    PartialEquiv H E where\n  source_eq : source = univ\n  uniqueDiffOn' : UniqueDiffOn 𝕜 toPartialEquiv.target\n  target_subset_closure_interior : toPartialEquiv.target ⊆ closure (interior toPartialEquiv.target)\n  continuous_toFun : Continuous toFun := by continuity\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"ModelWithCorners.ext_iff","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nx y : ModelWithCorners 𝕜 E H\n⊢ Iff (Eq x y) (And (Eq ↑x.toPartialEquiv ↑y.toPartialEquiv) (And (Eq x.invFun y.invFun) (And (Eq x.source y.source) (Eq x.target y.target))))","decl":"/-- A structure containing information on the way a space `H` embeds in a\nmodel vector space `E` over the field `𝕜`. This is all what is needed to\ndefine a `C^n` manifold with model space `H`, and model vector space `E`.\n\nWe require two conditions `uniqueDiffOn'` and `target_subset_closure_interior`, which\nare satisfied in the relevant cases (where `range I = univ` or a half space or a quadrant) and\nuseful for technical reasons. The former makes sure that manifold derivatives are uniquely\ndefined, the latter ensures that for `C^2` maps the second derivatives are symmetric even for points\non the boundary, as these are limit points of interior points where symmetry holds. If further\nconditions turn out to be useful, they can be added here.\n-/\n@[ext]\nstructure ModelWithCorners (𝕜 : Type*) [NontriviallyNormedField 𝕜] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] (H : Type*) [TopologicalSpace H] extends\n    PartialEquiv H E where\n  source_eq : source = univ\n  uniqueDiffOn' : UniqueDiffOn 𝕜 toPartialEquiv.target\n  target_subset_closure_interior : toPartialEquiv.target ⊆ closure (interior toPartialEquiv.target)\n  continuous_toFun : Continuous toFun := by continuity\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"ModelWithCorners.source_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nself : ModelWithCorners 𝕜 E H\n⊢ Eq self.source Set.univ","decl":"/-- A structure containing information on the way a space `H` embeds in a\nmodel vector space `E` over the field `𝕜`. This is all what is needed to\ndefine a `C^n` manifold with model space `H`, and model vector space `E`.\n\nWe require two conditions `uniqueDiffOn'` and `target_subset_closure_interior`, which\nare satisfied in the relevant cases (where `range I = univ` or a half space or a quadrant) and\nuseful for technical reasons. The former makes sure that manifold derivatives are uniquely\ndefined, the latter ensures that for `C^2` maps the second derivatives are symmetric even for points\non the boundary, as these are limit points of interior points where symmetry holds. If further\nconditions turn out to be useful, they can be added here.\n-/\n@[ext]\nstructure ModelWithCorners (𝕜 : Type*) [NontriviallyNormedField 𝕜] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] (H : Type*) [TopologicalSpace H] extends\n    PartialEquiv H E where\n  source_eq : source = univ\n  uniqueDiffOn' : UniqueDiffOn 𝕜 toPartialEquiv.target\n  target_subset_closure_interior : toPartialEquiv.target ⊆ closure (interior toPartialEquiv.target)\n  continuous_toFun : Continuous toFun := by continuity\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"ModelWithCorners.mk.sizeOf_spec","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝³ : TopologicalSpace H\ninst✝² : SizeOf 𝕜\ninst✝¹ : SizeOf E\ninst✝ : SizeOf H\ntoPartialEquiv : PartialEquiv H E\nsource_eq : Eq toPartialEquiv.source Set.univ\nuniqueDiffOn' : UniqueDiffOn 𝕜 toPartialEquiv.target\ntarget_subset_closure_interior : HasSubset.Subset toPartialEquiv.target (closure (interior toPartialEquiv.target))\ncontinuous_toFun : autoParam (Continuous ↑toPartialEquiv) _auto✝\ncontinuous_invFun : autoParam (Continuous toPartialEquiv.invFun) _auto✝\n⊢ Eq (SizeOf.sizeOf { toPartialEquiv := toPartialEquiv, source_eq := source_eq, uniqueDiffOn' := uniqueDiffOn', target_subset_closure_interior := target_subset_closure_interior, continuous_toFun := continuous_toFun, continuous_invFun := continuous_invFun }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toPartialEquiv)) (SizeOf.sizeOf source_eq)) (SizeOf.sizeOf continuous_toFun)) (SizeOf.sizeOf continuous_invFun))","decl":"/-- A structure containing information on the way a space `H` embeds in a\nmodel vector space `E` over the field `𝕜`. This is all what is needed to\ndefine a `C^n` manifold with model space `H`, and model vector space `E`.\n\nWe require two conditions `uniqueDiffOn'` and `target_subset_closure_interior`, which\nare satisfied in the relevant cases (where `range I = univ` or a half space or a quadrant) and\nuseful for technical reasons. The former makes sure that manifold derivatives are uniquely\ndefined, the latter ensures that for `C^2` maps the second derivatives are symmetric even for points\non the boundary, as these are limit points of interior points where symmetry holds. If further\nconditions turn out to be useful, they can be added here.\n-/\n@[ext]\nstructure ModelWithCorners (𝕜 : Type*) [NontriviallyNormedField 𝕜] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] (H : Type*) [TopologicalSpace H] extends\n    PartialEquiv H E where\n  source_eq : source = univ\n  uniqueDiffOn' : UniqueDiffOn 𝕜 toPartialEquiv.target\n  target_subset_closure_interior : toPartialEquiv.target ⊆ closure (interior toPartialEquiv.target)\n  continuous_toFun : Continuous toFun := by continuity\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"ModelWithCorners.uniqueDiffOn'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nself : ModelWithCorners 𝕜 E H\n⊢ UniqueDiffOn 𝕜 self.target","decl":"/-- A structure containing information on the way a space `H` embeds in a\nmodel vector space `E` over the field `𝕜`. This is all what is needed to\ndefine a `C^n` manifold with model space `H`, and model vector space `E`.\n\nWe require two conditions `uniqueDiffOn'` and `target_subset_closure_interior`, which\nare satisfied in the relevant cases (where `range I = univ` or a half space or a quadrant) and\nuseful for technical reasons. The former makes sure that manifold derivatives are uniquely\ndefined, the latter ensures that for `C^2` maps the second derivatives are symmetric even for points\non the boundary, as these are limit points of interior points where symmetry holds. If further\nconditions turn out to be useful, they can be added here.\n-/\n@[ext]\nstructure ModelWithCorners (𝕜 : Type*) [NontriviallyNormedField 𝕜] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] (H : Type*) [TopologicalSpace H] extends\n    PartialEquiv H E where\n  source_eq : source = univ\n  uniqueDiffOn' : UniqueDiffOn 𝕜 toPartialEquiv.target\n  target_subset_closure_interior : toPartialEquiv.target ⊆ closure (interior toPartialEquiv.target)\n  continuous_toFun : Continuous toFun := by continuity\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"ModelWithCorners.mk.inj","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\ntoPartialEquiv✝ : PartialEquiv H E\nsource_eq✝ : Eq toPartialEquiv✝.source Set.univ\nuniqueDiffOn'✝ : UniqueDiffOn 𝕜 toPartialEquiv✝.target\ntarget_subset_closure_interior✝ : HasSubset.Subset toPartialEquiv✝.target (closure (interior toPartialEquiv✝.target))\ncontinuous_toFun✝ : autoParam (Continuous ↑toPartialEquiv✝) _auto✝\ncontinuous_invFun✝ : autoParam (Continuous toPartialEquiv✝.invFun) _auto✝\ntoPartialEquiv : PartialEquiv H E\nsource_eq : Eq toPartialEquiv.source Set.univ\nuniqueDiffOn' : UniqueDiffOn 𝕜 toPartialEquiv.target\ntarget_subset_closure_interior : HasSubset.Subset toPartialEquiv.target (closure (interior toPartialEquiv.target))\ncontinuous_toFun : autoParam (Continuous ↑toPartialEquiv) _auto✝\ncontinuous_invFun : autoParam (Continuous toPartialEquiv.invFun) _auto✝\nx✝ : Eq { toPartialEquiv := toPartialEquiv✝, source_eq := source_eq✝, uniqueDiffOn' := uniqueDiffOn'✝, target_subset_closure_interior := target_subset_closure_interior✝, continuous_toFun := continuous_toFun✝, continuous_invFun := continuous_invFun✝ } { toPartialEquiv := toPartialEquiv, source_eq := source_eq, uniqueDiffOn' := uniqueDiffOn', target_subset_closure_interior := target_subset_closure_interior, continuous_toFun := continuous_toFun, continuous_invFun := continuous_invFun }\n⊢ Eq toPartialEquiv✝ toPartialEquiv","decl":"/-- A structure containing information on the way a space `H` embeds in a\nmodel vector space `E` over the field `𝕜`. This is all what is needed to\ndefine a `C^n` manifold with model space `H`, and model vector space `E`.\n\nWe require two conditions `uniqueDiffOn'` and `target_subset_closure_interior`, which\nare satisfied in the relevant cases (where `range I = univ` or a half space or a quadrant) and\nuseful for technical reasons. The former makes sure that manifold derivatives are uniquely\ndefined, the latter ensures that for `C^2` maps the second derivatives are symmetric even for points\non the boundary, as these are limit points of interior points where symmetry holds. If further\nconditions turn out to be useful, they can be added here.\n-/\n@[ext]\nstructure ModelWithCorners (𝕜 : Type*) [NontriviallyNormedField 𝕜] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] (H : Type*) [TopologicalSpace H] extends\n    PartialEquiv H E where\n  source_eq : source = univ\n  uniqueDiffOn' : UniqueDiffOn 𝕜 toPartialEquiv.target\n  target_subset_closure_interior : toPartialEquiv.target ⊆ closure (interior toPartialEquiv.target)\n  continuous_toFun : Continuous toFun := by continuity\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"ModelWithCorners.target_subset_closure_interior","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nself : ModelWithCorners 𝕜 E H\n⊢ HasSubset.Subset self.target (closure (interior self.target))","decl":"/-- A structure containing information on the way a space `H` embeds in a\nmodel vector space `E` over the field `𝕜`. This is all what is needed to\ndefine a `C^n` manifold with model space `H`, and model vector space `E`.\n\nWe require two conditions `uniqueDiffOn'` and `target_subset_closure_interior`, which\nare satisfied in the relevant cases (where `range I = univ` or a half space or a quadrant) and\nuseful for technical reasons. The former makes sure that manifold derivatives are uniquely\ndefined, the latter ensures that for `C^2` maps the second derivatives are symmetric even for points\non the boundary, as these are limit points of interior points where symmetry holds. If further\nconditions turn out to be useful, they can be added here.\n-/\n@[ext]\nstructure ModelWithCorners (𝕜 : Type*) [NontriviallyNormedField 𝕜] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] (H : Type*) [TopologicalSpace H] extends\n    PartialEquiv H E where\n  source_eq : source = univ\n  uniqueDiffOn' : UniqueDiffOn 𝕜 toPartialEquiv.target\n  target_subset_closure_interior : toPartialEquiv.target ⊆ closure (interior toPartialEquiv.target)\n  continuous_toFun : Continuous toFun := by continuity\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"ModelWithCorners.ext","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nx y : ModelWithCorners 𝕜 E H\ntoFun : Eq ↑x.toPartialEquiv ↑y.toPartialEquiv\ninvFun : Eq x.invFun y.invFun\nsource : Eq x.source y.source\ntarget : Eq x.target y.target\n⊢ Eq x y","decl":"/-- A structure containing information on the way a space `H` embeds in a\nmodel vector space `E` over the field `𝕜`. This is all what is needed to\ndefine a `C^n` manifold with model space `H`, and model vector space `E`.\n\nWe require two conditions `uniqueDiffOn'` and `target_subset_closure_interior`, which\nare satisfied in the relevant cases (where `range I = univ` or a half space or a quadrant) and\nuseful for technical reasons. The former makes sure that manifold derivatives are uniquely\ndefined, the latter ensures that for `C^2` maps the second derivatives are symmetric even for points\non the boundary, as these are limit points of interior points where symmetry holds. If further\nconditions turn out to be useful, they can be added here.\n-/\n@[ext]\nstructure ModelWithCorners (𝕜 : Type*) [NontriviallyNormedField 𝕜] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] (H : Type*) [TopologicalSpace H] extends\n    PartialEquiv H E where\n  source_eq : source = univ\n  uniqueDiffOn' : UniqueDiffOn 𝕜 toPartialEquiv.target\n  target_subset_closure_interior : toPartialEquiv.target ⊆ closure (interior toPartialEquiv.target)\n  continuous_toFun : Continuous toFun := by continuity\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"ModelWithCorners.mk.injEq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\ntoPartialEquiv✝ : PartialEquiv H E\nsource_eq✝ : Eq toPartialEquiv✝.source Set.univ\nuniqueDiffOn'✝ : UniqueDiffOn 𝕜 toPartialEquiv✝.target\ntarget_subset_closure_interior✝ : HasSubset.Subset toPartialEquiv✝.target (closure (interior toPartialEquiv✝.target))\ncontinuous_toFun✝ : autoParam (Continuous ↑toPartialEquiv✝) _auto✝\ncontinuous_invFun✝ : autoParam (Continuous toPartialEquiv✝.invFun) _auto✝\ntoPartialEquiv : PartialEquiv H E\nsource_eq : Eq toPartialEquiv.source Set.univ\nuniqueDiffOn' : UniqueDiffOn 𝕜 toPartialEquiv.target\ntarget_subset_closure_interior : HasSubset.Subset toPartialEquiv.target (closure (interior toPartialEquiv.target))\ncontinuous_toFun : autoParam (Continuous ↑toPartialEquiv) _auto✝\ncontinuous_invFun : autoParam (Continuous toPartialEquiv.invFun) _auto✝\n⊢ Eq (Eq { toPartialEquiv := toPartialEquiv✝, source_eq := source_eq✝, uniqueDiffOn' := uniqueDiffOn'✝, target_subset_closure_interior := target_subset_closure_interior✝, continuous_toFun := continuous_toFun✝, continuous_invFun := continuous_invFun✝ } { toPartialEquiv := toPartialEquiv, source_eq := source_eq, uniqueDiffOn' := uniqueDiffOn', target_subset_closure_interior := target_subset_closure_interior, continuous_toFun := continuous_toFun, continuous_invFun := continuous_invFun }) (Eq toPartialEquiv✝ toPartialEquiv)","decl":"/-- A structure containing information on the way a space `H` embeds in a\nmodel vector space `E` over the field `𝕜`. This is all what is needed to\ndefine a `C^n` manifold with model space `H`, and model vector space `E`.\n\nWe require two conditions `uniqueDiffOn'` and `target_subset_closure_interior`, which\nare satisfied in the relevant cases (where `range I = univ` or a half space or a quadrant) and\nuseful for technical reasons. The former makes sure that manifold derivatives are uniquely\ndefined, the latter ensures that for `C^2` maps the second derivatives are symmetric even for points\non the boundary, as these are limit points of interior points where symmetry holds. If further\nconditions turn out to be useful, they can be added here.\n-/\n@[ext]\nstructure ModelWithCorners (𝕜 : Type*) [NontriviallyNormedField 𝕜] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] (H : Type*) [TopologicalSpace H] extends\n    PartialEquiv H E where\n  source_eq : source = univ\n  uniqueDiffOn' : UniqueDiffOn 𝕜 toPartialEquiv.target\n  target_subset_closure_interior : toPartialEquiv.target ⊆ closure (interior toPartialEquiv.target)\n  continuous_toFun : Continuous toFun := by continuity\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"ModelWithCorners.toPartialEquiv_coe","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\n⊢ Eq ↑I.toPartialEquiv ↑I","decl":"@[simp, mfld_simps]\ntheorem toPartialEquiv_coe : (I.toPartialEquiv : H → E) = I :=\n  rfl\n\n"}
{"name":"ModelWithCorners.mk_coe","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\ne : PartialEquiv H E\na : Eq e.source Set.univ\nb : UniqueDiffOn 𝕜 e.target\nc : HasSubset.Subset e.target (closure (interior e.target))\nd : Continuous ↑e\nd' : Continuous e.invFun\n⊢ Eq ↑{ toPartialEquiv := e, source_eq := a, uniqueDiffOn' := b, target_subset_closure_interior := c, continuous_toFun := d, continuous_invFun := d' } ↑e","decl":"@[simp, mfld_simps]\ntheorem mk_coe (e : PartialEquiv H E) (a b c d d') :\n    ((ModelWithCorners.mk e a b c d d' : ModelWithCorners 𝕜 E H) : H → E) = (e : H → E) :=\n  rfl\n\n"}
{"name":"ModelWithCorners.toPartialEquiv_coe_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\n⊢ Eq ↑I.symm ↑I.symm","decl":"@[simp, mfld_simps]\ntheorem toPartialEquiv_coe_symm : (I.toPartialEquiv.symm : E → H) = I.symm :=\n  rfl\n\n"}
{"name":"ModelWithCorners.mk_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\ne : PartialEquiv H E\na : Eq e.source Set.univ\nb : UniqueDiffOn 𝕜 e.target\nc : HasSubset.Subset e.target (closure (interior e.target))\nd : Continuous ↑e\nd' : Continuous e.invFun\n⊢ Eq { toPartialEquiv := e, source_eq := a, uniqueDiffOn' := b, target_subset_closure_interior := c, continuous_toFun := d, continuous_invFun := d' }.symm e.symm","decl":"@[simp, mfld_simps]\ntheorem mk_symm (e : PartialEquiv H E) (a b c d d') :\n    (ModelWithCorners.mk e a b c d d' : ModelWithCorners 𝕜 E H).symm = e.symm :=\n  rfl\n\n"}
{"name":"ModelWithCorners.continuous","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\n⊢ Continuous ↑I","decl":"@[continuity]\nprotected theorem continuous : Continuous I :=\n  I.continuous_toFun\n\n"}
{"name":"ModelWithCorners.continuousAt","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nx : H\n⊢ ContinuousAt (↑I) x","decl":"protected theorem continuousAt {x} : ContinuousAt I x :=\n  I.continuous.continuousAt\n\n"}
{"name":"ModelWithCorners.continuousWithinAt","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\ns : Set H\nx : H\n⊢ ContinuousWithinAt (↑I) s x","decl":"protected theorem continuousWithinAt {s x} : ContinuousWithinAt I s x :=\n  I.continuousAt.continuousWithinAt\n\n"}
{"name":"ModelWithCorners.continuous_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\n⊢ Continuous ↑I.symm","decl":"@[continuity]\ntheorem continuous_symm : Continuous I.symm :=\n  I.continuous_invFun\n\n"}
{"name":"ModelWithCorners.continuousAt_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nx : E\n⊢ ContinuousAt (↑I.symm) x","decl":"theorem continuousAt_symm {x} : ContinuousAt I.symm x :=\n  I.continuous_symm.continuousAt\n\n"}
{"name":"ModelWithCorners.continuousWithinAt_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\ns : Set E\nx : E\n⊢ ContinuousWithinAt (↑I.symm) s x","decl":"theorem continuousWithinAt_symm {s x} : ContinuousWithinAt I.symm s x :=\n  I.continuous_symm.continuousWithinAt\n\n"}
{"name":"ModelWithCorners.continuousOn_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\ns : Set E\n⊢ ContinuousOn (↑I.symm) s","decl":"theorem continuousOn_symm {s} : ContinuousOn I.symm s :=\n  I.continuous_symm.continuousOn\n\n"}
{"name":"ModelWithCorners.target_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\n⊢ Eq I.target (Set.range ↑I)","decl":"@[simp, mfld_simps]\ntheorem target_eq : I.target = range (I : H → E) := by\n  rw [← image_univ, ← I.source_eq]\n  exact I.image_source_eq_target.symm\n\n"}
{"name":"ModelWithCorners.uniqueDiffOn","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\n⊢ UniqueDiffOn 𝕜 (Set.range ↑I)","decl":"protected theorem uniqueDiffOn : UniqueDiffOn 𝕜 (range I) :=\n  I.target_eq ▸ I.uniqueDiffOn'\n\n"}
{"name":"ModelWithCorners.unique_diff","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\n⊢ UniqueDiffOn 𝕜 (Set.range ↑I)","decl":"@[deprecated (since := \"2024-09-30\")]\nprotected alias unique_diff := ModelWithCorners.uniqueDiffOn\n\n"}
{"name":"ModelWithCorners.range_subset_closure_interior","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\n⊢ HasSubset.Subset (Set.range ↑I) (closure (interior (Set.range ↑I)))","decl":"theorem range_subset_closure_interior : range I ⊆ closure (interior (range I)) := by\n  rw [← I.target_eq]\n  exact I.target_subset_closure_interior\n\n"}
{"name":"ModelWithCorners.left_inv","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nx : H\n⊢ Eq (↑I.symm (↑I x)) x","decl":"@[simp, mfld_simps]\nprotected theorem left_inv (x : H) : I.symm (I x) = x := by refine I.left_inv' ?_; simp\n\n"}
{"name":"ModelWithCorners.leftInverse","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\n⊢ Function.LeftInverse ↑I.symm ↑I","decl":"protected theorem leftInverse : LeftInverse I.symm I :=\n  I.left_inv\n\n"}
{"name":"ModelWithCorners.injective","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\n⊢ Function.Injective ↑I","decl":"theorem injective : Injective I :=\n  I.leftInverse.injective\n\n"}
{"name":"ModelWithCorners.symm_comp_self","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\n⊢ Eq (Function.comp ↑I.symm ↑I) id","decl":"@[simp, mfld_simps]\ntheorem symm_comp_self : I.symm ∘ I = id :=\n  I.leftInverse.comp_eq_id\n\n"}
{"name":"ModelWithCorners.rightInvOn","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\n⊢ Set.RightInvOn (↑I.symm) (↑I) (Set.range ↑I)","decl":"protected theorem rightInvOn : RightInvOn I.symm I (range I) :=\n  I.leftInverse.rightInvOn_range\n\n"}
{"name":"ModelWithCorners.right_inv","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nx : E\nhx : Membership.mem (Set.range ↑I) x\n⊢ Eq (↑I (↑I.symm x)) x","decl":"@[simp, mfld_simps]\nprotected theorem right_inv {x : E} (hx : x ∈ range I) : I (I.symm x) = x :=\n  I.rightInvOn hx\n\n"}
{"name":"ModelWithCorners.preimage_image","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\ns : Set H\n⊢ Eq (Set.preimage (↑I) (Set.image (↑I) s)) s","decl":"theorem preimage_image (s : Set H) : I ⁻¹' (I '' s) = s :=\n  I.injective.preimage_image s\n\n"}
{"name":"ModelWithCorners.image_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\ns : Set H\n⊢ Eq (Set.image (↑I) s) (Inter.inter (Set.preimage (↑I.symm) s) (Set.range ↑I))","decl":"protected theorem image_eq (s : Set H) : I '' s = I.symm ⁻¹' s ∩ range I := by\n  refine (I.toPartialEquiv.image_eq_target_inter_inv_preimage ?_).trans ?_\n  · rw [I.source_eq]; exact subset_univ _\n  · rw [inter_comm, I.target_eq, I.toPartialEquiv_coe_symm]\n\n"}
{"name":"ModelWithCorners.isClosedEmbedding","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\n⊢ Topology.IsClosedEmbedding ↑I","decl":"theorem isClosedEmbedding : IsClosedEmbedding I :=\n  I.leftInverse.isClosedEmbedding I.continuous_symm I.continuous\n\n"}
{"name":"ModelWithCorners.closedEmbedding","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\n⊢ Topology.IsClosedEmbedding ↑I","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding := isClosedEmbedding\n\n"}
{"name":"ModelWithCorners.isClosed_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\n⊢ IsClosed (Set.range ↑I)","decl":"theorem isClosed_range : IsClosed (range I) :=\n  I.isClosedEmbedding.isClosed_range\n\n\n"}
{"name":"ModelWithCorners.range_eq_closure_interior","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\n⊢ Eq (Set.range ↑I) (closure (interior (Set.range ↑I)))","decl":"theorem range_eq_closure_interior : range I = closure (interior (range I)) :=\n  Subset.antisymm I.range_subset_closure_interior I.isClosed_range.closure_interior_subset\n\n"}
{"name":"ModelWithCorners.map_nhds_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nx : H\n⊢ Eq (Filter.map (↑I) (nhds x)) (nhdsWithin (↑I x) (Set.range ↑I))","decl":"theorem map_nhds_eq (x : H) : map I (𝓝 x) = 𝓝[range I] I x :=\n  I.isClosedEmbedding.isEmbedding.map_nhds_eq x\n\n"}
{"name":"ModelWithCorners.map_nhdsWithin_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\ns : Set H\nx : H\n⊢ Eq (Filter.map (↑I) (nhdsWithin x s)) (nhdsWithin (↑I x) (Set.image (↑I) s))","decl":"theorem map_nhdsWithin_eq (s : Set H) (x : H) : map I (𝓝[s] x) = 𝓝[I '' s] I x :=\n  I.isClosedEmbedding.isEmbedding.map_nhdsWithin_eq s x\n\n"}
{"name":"ModelWithCorners.image_mem_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nx : H\ns : Set H\nhs : Membership.mem (nhds x) s\n⊢ Membership.mem (nhdsWithin (↑I x) (Set.range ↑I)) (Set.image (↑I) s)","decl":"theorem image_mem_nhdsWithin {x : H} {s : Set H} (hs : s ∈ 𝓝 x) : I '' s ∈ 𝓝[range I] I x :=\n  I.map_nhds_eq x ▸ image_mem_map hs\n\n"}
{"name":"ModelWithCorners.symm_map_nhdsWithin_image","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nx : H\ns : Set H\n⊢ Eq (Filter.map (↑I.symm) (nhdsWithin (↑I x) (Set.image (↑I) s))) (nhdsWithin x s)","decl":"theorem symm_map_nhdsWithin_image {x : H} {s : Set H} : map I.symm (𝓝[I '' s] I x) = 𝓝[s] x := by\n  rw [← I.map_nhdsWithin_eq, map_map, I.symm_comp_self, map_id]\n\n"}
{"name":"ModelWithCorners.symm_map_nhdsWithin_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nx : H\n⊢ Eq (Filter.map (↑I.symm) (nhdsWithin (↑I x) (Set.range ↑I))) (nhds x)","decl":"theorem symm_map_nhdsWithin_range (x : H) : map I.symm (𝓝[range I] I x) = 𝓝 x := by\n  rw [← I.map_nhds_eq, map_map, I.symm_comp_self, map_id]\n\n"}
{"name":"ModelWithCorners.uniqueDiffOn_preimage","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\ns : Set H\nhs : IsOpen s\n⊢ UniqueDiffOn 𝕜 (Inter.inter (Set.preimage (↑I.symm) s) (Set.range ↑I))","decl":"theorem uniqueDiffOn_preimage {s : Set H} (hs : IsOpen s) :\n    UniqueDiffOn 𝕜 (I.symm ⁻¹' s ∩ range I) := by\n  rw [inter_comm]\n  exact I.uniqueDiffOn.inter (hs.preimage I.continuous_invFun)\n\n"}
{"name":"ModelWithCorners.unique_diff_preimage","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\ns : Set H\nhs : IsOpen s\n⊢ UniqueDiffOn 𝕜 (Inter.inter (Set.preimage (↑I.symm) s) (Set.range ↑I))","decl":"@[deprecated (since := \"2024-09-30\")]\nalias unique_diff_preimage := uniqueDiffOn_preimage\n\n"}
{"name":"ModelWithCorners.uniqueDiffOn_preimage_source","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nH : Type u_3\ninst✝¹ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nβ : Type u_4\ninst✝ : TopologicalSpace β\ne : PartialHomeomorph H β\n⊢ UniqueDiffOn 𝕜 (Inter.inter (Set.preimage (↑I.symm) e.source) (Set.range ↑I))","decl":"theorem uniqueDiffOn_preimage_source {β : Type*} [TopologicalSpace β] {e : PartialHomeomorph H β} :\n    UniqueDiffOn 𝕜 (I.symm ⁻¹' e.source ∩ range I) :=\n  I.uniqueDiffOn_preimage e.open_source\n\n"}
{"name":"ModelWithCorners.unique_diff_preimage_source","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nH : Type u_3\ninst✝¹ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nβ : Type u_4\ninst✝ : TopologicalSpace β\ne : PartialHomeomorph H β\n⊢ UniqueDiffOn 𝕜 (Inter.inter (Set.preimage (↑I.symm) e.source) (Set.range ↑I))","decl":"@[deprecated (since := \"2024-09-30\")]\nalias unique_diff_preimage_source := uniqueDiffOn_preimage_source\n\n"}
{"name":"ModelWithCorners.uniqueDiffWithinAt_image","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nx : H\n⊢ UniqueDiffWithinAt 𝕜 (Set.range ↑I) (↑I x)","decl":"theorem uniqueDiffWithinAt_image {x : H} : UniqueDiffWithinAt 𝕜 (range I) (I x) :=\n  I.uniqueDiffOn _ (mem_range_self _)\n\n"}
{"name":"ModelWithCorners.unique_diff_at_image","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nx : H\n⊢ UniqueDiffWithinAt 𝕜 (Set.range ↑I) (↑I x)","decl":"@[deprecated (since := \"2024-09-30\")]\nalias unique_diff_at_image := uniqueDiffWithinAt_image\n\n"}
{"name":"ModelWithCorners.symm_continuousWithinAt_comp_right_iff","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nH : Type u_3\ninst✝¹ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nX : Type u_4\ninst✝ : TopologicalSpace X\nf : H → X\ns : Set H\nx : H\n⊢ Iff (ContinuousWithinAt (Function.comp f ↑I.symm) (Inter.inter (Set.preimage (↑I.symm) s) (Set.range ↑I)) (↑I x)) (ContinuousWithinAt f s x)","decl":"theorem symm_continuousWithinAt_comp_right_iff {X} [TopologicalSpace X] {f : H → X} {s : Set H}\n    {x : H} :\n    ContinuousWithinAt (f ∘ I.symm) (I.symm ⁻¹' s ∩ range I) (I x) ↔ ContinuousWithinAt f s x := by\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · have := h.comp I.continuousWithinAt (mapsTo_preimage _ _)\n    simp_rw [preimage_inter, preimage_preimage, I.left_inv, preimage_id', preimage_range,\n      inter_univ] at this\n    rwa [Function.comp_assoc, I.symm_comp_self] at this\n  · rw [← I.left_inv x] at h; exact h.comp I.continuousWithinAt_symm inter_subset_left\n\n"}
{"name":"ModelWithCorners.locallyCompactSpace","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nH : Type u_3\ninst✝¹ : TopologicalSpace H\ninst✝ : LocallyCompactSpace E\nI : ModelWithCorners 𝕜 E H\n⊢ LocallyCompactSpace H","decl":"protected theorem locallyCompactSpace [LocallyCompactSpace E] (I : ModelWithCorners 𝕜 E H) :\n    LocallyCompactSpace H := by\n  have : ∀ x : H, (𝓝 x).HasBasis (fun s => s ∈ 𝓝 (I x) ∧ IsCompact s)\n      fun s => I.symm '' (s ∩ range I) := fun x ↦ by\n    rw [← I.symm_map_nhdsWithin_range]\n    exact ((compact_basis_nhds (I x)).inf_principal _).map _\n  refine .of_hasBasis this ?_\n  rintro x s ⟨-, hsc⟩\n  exact (hsc.inter_right I.isClosed_range).image I.continuous_symm\n\n"}
{"name":"ModelWithCorners.secondCountableTopology","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nH : Type u_3\ninst✝¹ : TopologicalSpace H\ninst✝ : SecondCountableTopology E\nI : ModelWithCorners 𝕜 E H\n⊢ SecondCountableTopology H","decl":"protected theorem secondCountableTopology [SecondCountableTopology E] (I : ModelWithCorners 𝕜 E H) :\n    SecondCountableTopology H :=\n  I.isClosedEmbedding.isEmbedding.secondCountableTopology\n\n"}
{"name":"ModelWithCorners.t1Space","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\n⊢ T1Space M","decl":"include I in\n/-- Every manifold is a Fréchet space (T1 space) -- regardless of whether it is\nHausdorff. -/\nprotected theorem t1Space (M : Type*) [TopologicalSpace M] [ChartedSpace H M] : T1Space M := by\n  have : T2Space H := I.isClosedEmbedding.toIsEmbedding.t2Space\n  exact ChartedSpace.t1Space H M\n\n"}
{"name":"modelWithCornersSelf_partialEquiv","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\n⊢ Eq (modelWithCornersSelf 𝕜 E).toPartialEquiv (PartialEquiv.refl E)","decl":"/-- In the trivial model with corners, the associated `PartialEquiv` is the identity. -/\n@[simp, mfld_simps]\ntheorem modelWithCornersSelf_partialEquiv : 𝓘(𝕜, E).toPartialEquiv = PartialEquiv.refl E :=\n  rfl\n\n"}
{"name":"modelWithCornersSelf_coe","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\n⊢ Eq (↑(modelWithCornersSelf 𝕜 E)) id","decl":"@[simp, mfld_simps]\ntheorem modelWithCornersSelf_coe : (𝓘(𝕜, E) : E → E) = id :=\n  rfl\n\n"}
{"name":"modelWithCornersSelf_coe_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\n⊢ Eq (↑(modelWithCornersSelf 𝕜 E).symm) id","decl":"@[simp, mfld_simps]\ntheorem modelWithCornersSelf_coe_symm : (𝓘(𝕜, E).symm : E → E) = id :=\n  rfl\n\n"}
{"name":"ModelWithCorners.prod_source","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nH : Type w\ninst✝³ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nE' : Type v'\ninst✝² : NormedAddCommGroup E'\ninst✝¹ : NormedSpace 𝕜 E'\nH' : Type w'\ninst✝ : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\n⊢ Eq (I.prod I').source (setOf fun x => And (Membership.mem I.source x.1) (Membership.mem I'.source x.2))","decl":"/-- Given two model_with_corners `I` on `(E, H)` and `I'` on `(E', H')`, we define the model with\ncorners `I.prod I'` on `(E × E', ModelProd H H')`. This appears in particular for the manifold\nstructure on the tangent bundle to a manifold modelled on `(E, H)`: it will be modelled on\n`(E × E, H × E)`. See note [Manifold type tags] for explanation about `ModelProd H H'`\nvs `H × H'`. -/\n@[simps (config := .lemmasOnly)]\ndef ModelWithCorners.prod {𝕜 : Type u} [NontriviallyNormedField 𝕜] {E : Type v}\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] {H : Type w} [TopologicalSpace H]\n    (I : ModelWithCorners 𝕜 E H) {E' : Type v'} [NormedAddCommGroup E'] [NormedSpace 𝕜 E']\n    {H' : Type w'} [TopologicalSpace H'] (I' : ModelWithCorners 𝕜 E' H') :\n    ModelWithCorners 𝕜 (E × E') (ModelProd H H') :=\n  { I.toPartialEquiv.prod I'.toPartialEquiv with\n    toFun := fun x => (I x.1, I' x.2)\n    invFun := fun x => (I.symm x.1, I'.symm x.2)\n    source := { x | x.1 ∈ I.source ∧ x.2 ∈ I'.source }\n    source_eq := by simp only [setOf_true, mfld_simps]\n    uniqueDiffOn' := I.uniqueDiffOn'.prod I'.uniqueDiffOn'\n    target_subset_closure_interior := by\n      simp only [PartialEquiv.prod_target, target_eq, interior_prod_eq, closure_prod_eq]\n      exact Set.prod_mono I.range_subset_closure_interior I'.range_subset_closure_interior\n    continuous_toFun := I.continuous_toFun.prodMap I'.continuous_toFun\n    continuous_invFun := I.continuous_invFun.prodMap I'.continuous_invFun }\n\n"}
{"name":"ModelWithCorners.prod_symm_apply","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nH : Type w\ninst✝³ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nE' : Type v'\ninst✝² : NormedAddCommGroup E'\ninst✝¹ : NormedSpace 𝕜 E'\nH' : Type w'\ninst✝ : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\nx : Prod E E'\n⊢ Eq (↑(I.prod I').symm x) { fst := ↑I.symm x.1, snd := ↑I'.symm x.2 }","decl":"/-- Given two model_with_corners `I` on `(E, H)` and `I'` on `(E', H')`, we define the model with\ncorners `I.prod I'` on `(E × E', ModelProd H H')`. This appears in particular for the manifold\nstructure on the tangent bundle to a manifold modelled on `(E, H)`: it will be modelled on\n`(E × E, H × E)`. See note [Manifold type tags] for explanation about `ModelProd H H'`\nvs `H × H'`. -/\n@[simps (config := .lemmasOnly)]\ndef ModelWithCorners.prod {𝕜 : Type u} [NontriviallyNormedField 𝕜] {E : Type v}\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] {H : Type w} [TopologicalSpace H]\n    (I : ModelWithCorners 𝕜 E H) {E' : Type v'} [NormedAddCommGroup E'] [NormedSpace 𝕜 E']\n    {H' : Type w'} [TopologicalSpace H'] (I' : ModelWithCorners 𝕜 E' H') :\n    ModelWithCorners 𝕜 (E × E') (ModelProd H H') :=\n  { I.toPartialEquiv.prod I'.toPartialEquiv with\n    toFun := fun x => (I x.1, I' x.2)\n    invFun := fun x => (I.symm x.1, I'.symm x.2)\n    source := { x | x.1 ∈ I.source ∧ x.2 ∈ I'.source }\n    source_eq := by simp only [setOf_true, mfld_simps]\n    uniqueDiffOn' := I.uniqueDiffOn'.prod I'.uniqueDiffOn'\n    target_subset_closure_interior := by\n      simp only [PartialEquiv.prod_target, target_eq, interior_prod_eq, closure_prod_eq]\n      exact Set.prod_mono I.range_subset_closure_interior I'.range_subset_closure_interior\n    continuous_toFun := I.continuous_toFun.prodMap I'.continuous_toFun\n    continuous_invFun := I.continuous_invFun.prodMap I'.continuous_invFun }\n\n"}
{"name":"ModelWithCorners.prod_apply","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nH : Type w\ninst✝³ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nE' : Type v'\ninst✝² : NormedAddCommGroup E'\ninst✝¹ : NormedSpace 𝕜 E'\nH' : Type w'\ninst✝ : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\nx : ModelProd H H'\n⊢ Eq (↑(I.prod I') x) { fst := ↑I x.1, snd := ↑I' x.2 }","decl":"/-- Given two model_with_corners `I` on `(E, H)` and `I'` on `(E', H')`, we define the model with\ncorners `I.prod I'` on `(E × E', ModelProd H H')`. This appears in particular for the manifold\nstructure on the tangent bundle to a manifold modelled on `(E, H)`: it will be modelled on\n`(E × E, H × E)`. See note [Manifold type tags] for explanation about `ModelProd H H'`\nvs `H × H'`. -/\n@[simps (config := .lemmasOnly)]\ndef ModelWithCorners.prod {𝕜 : Type u} [NontriviallyNormedField 𝕜] {E : Type v}\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] {H : Type w} [TopologicalSpace H]\n    (I : ModelWithCorners 𝕜 E H) {E' : Type v'} [NormedAddCommGroup E'] [NormedSpace 𝕜 E']\n    {H' : Type w'} [TopologicalSpace H'] (I' : ModelWithCorners 𝕜 E' H') :\n    ModelWithCorners 𝕜 (E × E') (ModelProd H H') :=\n  { I.toPartialEquiv.prod I'.toPartialEquiv with\n    toFun := fun x => (I x.1, I' x.2)\n    invFun := fun x => (I.symm x.1, I'.symm x.2)\n    source := { x | x.1 ∈ I.source ∧ x.2 ∈ I'.source }\n    source_eq := by simp only [setOf_true, mfld_simps]\n    uniqueDiffOn' := I.uniqueDiffOn'.prod I'.uniqueDiffOn'\n    target_subset_closure_interior := by\n      simp only [PartialEquiv.prod_target, target_eq, interior_prod_eq, closure_prod_eq]\n      exact Set.prod_mono I.range_subset_closure_interior I'.range_subset_closure_interior\n    continuous_toFun := I.continuous_toFun.prodMap I'.continuous_toFun\n    continuous_invFun := I.continuous_invFun.prodMap I'.continuous_invFun }\n\n"}
{"name":"ModelWithCorners.prod_target","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nH : Type w\ninst✝³ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nE' : Type v'\ninst✝² : NormedAddCommGroup E'\ninst✝¹ : NormedSpace 𝕜 E'\nH' : Type w'\ninst✝ : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\n⊢ Eq (I.prod I').target (I.prod I'.toPartialEquiv).target","decl":"/-- Given two model_with_corners `I` on `(E, H)` and `I'` on `(E', H')`, we define the model with\ncorners `I.prod I'` on `(E × E', ModelProd H H')`. This appears in particular for the manifold\nstructure on the tangent bundle to a manifold modelled on `(E, H)`: it will be modelled on\n`(E × E, H × E)`. See note [Manifold type tags] for explanation about `ModelProd H H'`\nvs `H × H'`. -/\n@[simps (config := .lemmasOnly)]\ndef ModelWithCorners.prod {𝕜 : Type u} [NontriviallyNormedField 𝕜] {E : Type v}\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] {H : Type w} [TopologicalSpace H]\n    (I : ModelWithCorners 𝕜 E H) {E' : Type v'} [NormedAddCommGroup E'] [NormedSpace 𝕜 E']\n    {H' : Type w'} [TopologicalSpace H'] (I' : ModelWithCorners 𝕜 E' H') :\n    ModelWithCorners 𝕜 (E × E') (ModelProd H H') :=\n  { I.toPartialEquiv.prod I'.toPartialEquiv with\n    toFun := fun x => (I x.1, I' x.2)\n    invFun := fun x => (I.symm x.1, I'.symm x.2)\n    source := { x | x.1 ∈ I.source ∧ x.2 ∈ I'.source }\n    source_eq := by simp only [setOf_true, mfld_simps]\n    uniqueDiffOn' := I.uniqueDiffOn'.prod I'.uniqueDiffOn'\n    target_subset_closure_interior := by\n      simp only [PartialEquiv.prod_target, target_eq, interior_prod_eq, closure_prod_eq]\n      exact Set.prod_mono I.range_subset_closure_interior I'.range_subset_closure_interior\n    continuous_toFun := I.continuous_toFun.prodMap I'.continuous_toFun\n    continuous_invFun := I.continuous_invFun.prodMap I'.continuous_invFun }\n\n"}
{"name":"modelWithCorners_prod_toPartialEquiv","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_4\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nH : Type u_5\ninst✝¹ : TopologicalSpace H\nG : Type u_7\ninst✝ : TopologicalSpace G\nI : ModelWithCorners 𝕜 E H\nJ : ModelWithCorners 𝕜 F G\n⊢ Eq (I.prod J).toPartialEquiv (I.prod J.toPartialEquiv)","decl":"@[simp, mfld_simps]\ntheorem modelWithCorners_prod_toPartialEquiv :\n    (I.prod J).toPartialEquiv = I.toPartialEquiv.prod J.toPartialEquiv :=\n  rfl\n\n"}
{"name":"modelWithCorners_prod_coe","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nE' : Type u_3\ninst✝³ : NormedAddCommGroup E'\ninst✝² : NormedSpace 𝕜 E'\nH : Type u_5\ninst✝¹ : TopologicalSpace H\nH' : Type u_6\ninst✝ : TopologicalSpace H'\nI : ModelWithCorners 𝕜 E H\nI' : ModelWithCorners 𝕜 E' H'\n⊢ Eq (↑(I.prod I')) (Prod.map ↑I ↑I')","decl":"@[simp, mfld_simps]\ntheorem modelWithCorners_prod_coe (I : ModelWithCorners 𝕜 E H) (I' : ModelWithCorners 𝕜 E' H') :\n    (I.prod I' : _ × _ → _ × _) = Prod.map I I' :=\n  rfl\n\n"}
{"name":"modelWithCorners_prod_coe_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nE' : Type u_3\ninst✝³ : NormedAddCommGroup E'\ninst✝² : NormedSpace 𝕜 E'\nH : Type u_5\ninst✝¹ : TopologicalSpace H\nH' : Type u_6\ninst✝ : TopologicalSpace H'\nI : ModelWithCorners 𝕜 E H\nI' : ModelWithCorners 𝕜 E' H'\n⊢ Eq (↑(I.prod I').symm) (Prod.map ↑I.symm ↑I'.symm)","decl":"@[simp, mfld_simps]\ntheorem modelWithCorners_prod_coe_symm (I : ModelWithCorners 𝕜 E H)\n    (I' : ModelWithCorners 𝕜 E' H') :\n    ((I.prod I').symm : _ × _ → _ × _) = Prod.map I.symm I'.symm :=\n  rfl\n\n"}
{"name":"modelWithCornersSelf_prod","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type u_4\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\n⊢ Eq (modelWithCornersSelf 𝕜 (Prod E F)) ((modelWithCornersSelf 𝕜 E).prod (modelWithCornersSelf 𝕜 F))","decl":"/-- This lemma should be erased, or at least burn in hell, as it uses bad defeq: the left model\nwith corners is for `E times F`, the right one for `ModelProd E F`, and there's a good reason\nwe are distinguishing them. -/\ntheorem modelWithCornersSelf_prod : 𝓘(𝕜, E × F) = 𝓘(𝕜, E).prod 𝓘(𝕜, F) := by ext1 <;> simp\n\n"}
{"name":"ModelWithCorners.range_prod","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type u_4\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nH : Type u_5\ninst✝¹ : TopologicalSpace H\nG : Type u_7\ninst✝ : TopologicalSpace G\nI : ModelWithCorners 𝕜 E H\nJ : ModelWithCorners 𝕜 F G\n⊢ Eq (Set.range ↑(I.prod J)) (SProd.sprod (Set.range ↑I) (Set.range ↑J))","decl":"theorem ModelWithCorners.range_prod : range (I.prod J) = range I ×ˢ range J := by\n  simp_rw [← ModelWithCorners.target_eq]; rfl\n\n"}
{"name":"ModelWithCorners.Boundaryless.range_eq_univ","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nself : I.Boundaryless\n⊢ Eq (Set.range ↑I) Set.univ","decl":"/-- Property ensuring that the model with corners `I` defines manifolds without boundary. This\n  differs from the more general `BoundarylessManifold`, which requires every point on the manifold\n  to be an interior point. -/\nclass ModelWithCorners.Boundaryless {𝕜 : Type*} [NontriviallyNormedField 𝕜] {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] {H : Type*} [TopologicalSpace H]\n    (I : ModelWithCorners 𝕜 E H) : Prop where\n  range_eq_univ : range I = univ\n\n"}
{"name":"ModelWithCorners.range_eq_univ","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nH : Type u_3\ninst✝¹ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\ninst✝ : I.Boundaryless\n⊢ Eq (Set.range ↑I) Set.univ","decl":"theorem ModelWithCorners.range_eq_univ {𝕜 : Type*} [NontriviallyNormedField 𝕜] {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] {H : Type*} [TopologicalSpace H]\n    (I : ModelWithCorners 𝕜 E H) [I.Boundaryless] :\n    range I = univ := ModelWithCorners.Boundaryless.range_eq_univ\n\n"}
{"name":"ModelWithCorners.toHomeomorph_symm_apply","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nH : Type u_3\ninst✝¹ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\ninst✝ : I.Boundaryless\na✝ : E\n⊢ Eq (I.toHomeomorph.symm a✝) (↑I.symm a✝)","decl":"/-- If `I` is a `ModelWithCorners.Boundaryless` model, then it is a homeomorphism. -/\n@[simps (config := {simpRhs := true})]\ndef ModelWithCorners.toHomeomorph {𝕜 : Type*} [NontriviallyNormedField 𝕜] {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] {H : Type*} [TopologicalSpace H]\n    (I : ModelWithCorners 𝕜 E H) [I.Boundaryless] : H ≃ₜ E where\n  __ := I\n  left_inv := I.left_inv\n  right_inv _ := I.right_inv <| I.range_eq_univ.symm ▸ mem_univ _\n\n"}
{"name":"ModelWithCorners.toHomeomorph_apply","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nH : Type u_3\ninst✝¹ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\ninst✝ : I.Boundaryless\na✝ : H\n⊢ Eq (I.toHomeomorph a✝) (↑I a✝)","decl":"/-- If `I` is a `ModelWithCorners.Boundaryless` model, then it is a homeomorphism. -/\n@[simps (config := {simpRhs := true})]\ndef ModelWithCorners.toHomeomorph {𝕜 : Type*} [NontriviallyNormedField 𝕜] {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] {H : Type*} [TopologicalSpace H]\n    (I : ModelWithCorners 𝕜 E H) [I.Boundaryless] : H ≃ₜ E where\n  __ := I\n  left_inv := I.left_inv\n  right_inv _ := I.right_inv <| I.range_eq_univ.symm ▸ mem_univ _\n\n"}
{"name":"modelWithCornersSelf_boundaryless","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\n⊢ (modelWithCornersSelf 𝕜 E).Boundaryless","decl":"/-- The trivial model with corners has no boundary -/\ninstance modelWithCornersSelf_boundaryless (𝕜 : Type*) [NontriviallyNormedField 𝕜] (E : Type*)\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] : (modelWithCornersSelf 𝕜 E).Boundaryless :=\n  ⟨by simp⟩\n\n"}
{"name":"ModelWithCorners.range_eq_univ_prod","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type v\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nH : Type w\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\ninst✝⁴ : I.Boundaryless\nE' : Type v'\ninst✝³ : NormedAddCommGroup E'\ninst✝² : NormedSpace 𝕜 E'\nH' : Type w'\ninst✝¹ : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\ninst✝ : I'.Boundaryless\n⊢ (I.prod I').Boundaryless","decl":"/-- If two model with corners are boundaryless, their product also is -/\ninstance ModelWithCorners.range_eq_univ_prod {𝕜 : Type u} [NontriviallyNormedField 𝕜] {E : Type v}\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] {H : Type w} [TopologicalSpace H]\n    (I : ModelWithCorners 𝕜 E H) [I.Boundaryless] {E' : Type v'} [NormedAddCommGroup E']\n    [NormedSpace 𝕜 E'] {H' : Type w'} [TopologicalSpace H'] (I' : ModelWithCorners 𝕜 E' H')\n    [I'.Boundaryless] : (I.prod I').Boundaryless := by\n  constructor\n  dsimp [ModelWithCorners.prod, ModelProd]\n  rw [← prod_range_range_eq, ModelWithCorners.Boundaryless.range_eq_univ,\n    ModelWithCorners.Boundaryless.range_eq_univ, univ_prod_univ]\n\n"}
{"name":"contDiffGroupoid_le","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"m n : WithTop ENat\n𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nh : LE.le m n\n⊢ LE.le (contDiffGroupoid n I) (contDiffGroupoid m I)","decl":"/-- Inclusion of the groupoid of `C^n` local diffeos in the groupoid of `C^m` local diffeos when\n`m ≤ n` -/\ntheorem contDiffGroupoid_le (h : m ≤ n) : contDiffGroupoid n I ≤ contDiffGroupoid m I := by\n  rw [contDiffGroupoid, contDiffGroupoid]\n  apply groupoid_of_pregroupoid_le\n  intro f s hfs\n  exact ContDiffOn.of_le hfs h\n\n"}
{"name":"contDiffGroupoid_zero_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\n⊢ Eq (contDiffGroupoid 0 I) (continuousGroupoid H)","decl":"/-- The groupoid of `0`-times continuously differentiable maps is just the groupoid of all\npartial homeomorphisms -/\ntheorem contDiffGroupoid_zero_eq : contDiffGroupoid 0 I = continuousGroupoid H := by\n  apply le_antisymm le_top\n  intro u _\n  -- we have to check that every partial homeomorphism belongs to `contDiffGroupoid 0 I`,\n  -- by unfolding its definition\n  change u ∈ contDiffGroupoid 0 I\n  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid, contDiffPregroupoid]\n  simp only [contDiffOn_zero]\n  constructor\n  · refine I.continuous.comp_continuousOn (u.continuousOn.comp I.continuousOn_symm ?_)\n    exact (mapsTo_preimage _ _).mono_left inter_subset_left\n  · refine I.continuous.comp_continuousOn (u.symm.continuousOn.comp I.continuousOn_symm ?_)\n    exact (mapsTo_preimage _ _).mono_left inter_subset_left\n\n-- FIXME: does this generalise to other groupoids? The argument is not specific\n-- to C^n functions, but uses something about the groupoid's property that is not easy to abstract.\n"}
{"name":"ContDiffGroupoid.mem_of_source_eq_empty","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"n : WithTop ENat\n𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nf : PartialHomeomorph H H\nhf : Eq f.source EmptyCollection.emptyCollection\n⊢ Membership.mem (contDiffGroupoid n I) f","decl":"/-- Any change of coordinates with empty source belongs to `contDiffGroupoid`. -/\nlemma ContDiffGroupoid.mem_of_source_eq_empty (f : PartialHomeomorph H H)\n    (hf : f.source = ∅) : f ∈ contDiffGroupoid n I := by\n  constructor\n  · intro x ⟨hx, _⟩\n    rw [mem_preimage] at hx\n    simp_all only [mem_empty_iff_false]\n  · intro x ⟨hx, _⟩\n    have : f.target = ∅ := by simp [← f.image_source_eq_target, hf]\n    simp_all [hx]\n\n"}
{"name":"ContinuousGroupoid.mem_of_source_eq_empty","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nf : PartialHomeomorph H H\nhf : Eq f.source EmptyCollection.emptyCollection\n⊢ Membership.mem (continuousGroupoid H) f","decl":"include I in\n/-- Any change of coordinates with empty source belongs to `continuousGroupoid`. -/\nlemma ContinuousGroupoid.mem_of_source_eq_empty (f : PartialHomeomorph H H)\n    (hf : f.source = ∅) : f ∈ continuousGroupoid H := by\n  rw [← contDiffGroupoid_zero_eq (I := I)]\n  exact ContDiffGroupoid.mem_of_source_eq_empty f hf\n\n"}
{"name":"ofSet_mem_contDiffGroupoid","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"n : WithTop ENat\n𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\ns : Set H\nhs : IsOpen s\n⊢ Membership.mem (contDiffGroupoid n I) (PartialHomeomorph.ofSet s hs)","decl":"/-- An identity partial homeomorphism belongs to the `C^n` groupoid. -/\ntheorem ofSet_mem_contDiffGroupoid {s : Set H} (hs : IsOpen s) :\n    PartialHomeomorph.ofSet s hs ∈ contDiffGroupoid n I := by\n  rw [contDiffGroupoid, mem_groupoid_of_pregroupoid]\n  suffices h : ContDiffOn 𝕜 n (I ∘ I.symm) (I.symm ⁻¹' s ∩ range I) by\n    simp [h, contDiffPregroupoid]\n  have : ContDiffOn 𝕜 n id (univ : Set E) := contDiff_id.contDiffOn\n  exact this.congr_mono (fun x hx => I.right_inv hx.2) (subset_univ _)\n\n"}
{"name":"symm_trans_mem_contDiffGroupoid","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"n : WithTop ENat\n𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nH : Type u_3\ninst✝¹ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝ : TopologicalSpace M\ne : PartialHomeomorph M H\n⊢ Membership.mem (contDiffGroupoid n I) (e.symm.trans e)","decl":"/-- The composition of a partial homeomorphism from `H` to `M` and its inverse belongs to\nthe `C^n` groupoid. -/\ntheorem symm_trans_mem_contDiffGroupoid (e : PartialHomeomorph M H) :\n    e.symm.trans e ∈ contDiffGroupoid n I :=\n  haveI : e.symm.trans e ≈ PartialHomeomorph.ofSet e.target e.open_target :=\n    PartialHomeomorph.symm_trans_self _\n  StructureGroupoid.mem_of_eqOnSource _ (ofSet_mem_contDiffGroupoid e.open_target) this\n\n"}
{"name":"contDiffGroupoid_prod","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"n : WithTop ENat\n𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝³ : TopologicalSpace H\nE' : Type u_5\nH' : Type u_6\ninst✝² : NormedAddCommGroup E'\ninst✝¹ : NormedSpace 𝕜 E'\ninst✝ : TopologicalSpace H'\nI : ModelWithCorners 𝕜 E H\nI' : ModelWithCorners 𝕜 E' H'\ne : PartialHomeomorph H H\ne' : PartialHomeomorph H' H'\nhe : Membership.mem (contDiffGroupoid n I) e\nhe' : Membership.mem (contDiffGroupoid n I') e'\n⊢ Membership.mem (contDiffGroupoid n (I.prod I')) (e.prod e')","decl":"/-- The product of two `C^n` partial homeomorphisms is `C^n`. -/\ntheorem contDiffGroupoid_prod {I : ModelWithCorners 𝕜 E H} {I' : ModelWithCorners 𝕜 E' H'}\n    {e : PartialHomeomorph H H} {e' : PartialHomeomorph H' H'} (he : e ∈ contDiffGroupoid n I)\n    (he' : e' ∈ contDiffGroupoid n I') : e.prod e' ∈ contDiffGroupoid n (I.prod I') := by\n  cases' he with he he_symm\n  cases' he' with he' he'_symm\n  simp only at he he_symm he' he'_symm\n  constructor <;> simp only [PartialEquiv.prod_source, PartialHomeomorph.prod_toPartialEquiv,\n    contDiffPregroupoid]\n  · have h3 := ContDiffOn.prod_map he he'\n    rw [← I.image_eq, ← I'.image_eq, prod_image_image_eq] at h3\n    rw [← (I.prod I').image_eq]\n    exact h3\n  · have h3 := ContDiffOn.prod_map he_symm he'_symm\n    rw [← I.image_eq, ← I'.image_eq, prod_image_image_eq] at h3\n    rw [← (I.prod I').image_eq]\n    exact h3\n\n"}
{"name":"instClosedUnderRestrictionContDiffGroupoid","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"n : WithTop ENat\n𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\n⊢ ClosedUnderRestriction (contDiffGroupoid n I)","decl":"/-- The `C^n` groupoid is closed under restriction. -/\ninstance : ClosedUnderRestriction (contDiffGroupoid n I) :=\n  (closedUnderRestriction_iff_id_le _).mpr\n    (by\n      rw [StructureGroupoid.le_iff]\n      rintro e ⟨s, hs, hes⟩\n      apply (contDiffGroupoid n I).mem_of_eqOnSource' _ _ _ hes\n      exact ofSet_mem_contDiffGroupoid hs)\n\n"}
{"name":"IsManifold.toHasGroupoid","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nn : WithTop ENat\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nself : IsManifold I n M\n⊢ HasGroupoid M (contDiffGroupoid n I)","decl":"/-- Typeclass defining manifolds with respect to a model with corners, over a\nfield `𝕜`. This definition includes the model with corners `I` (which might allow boundary, corners,\nor not, so this class covers both manifolds with boundary and manifolds without boundary), and\na smoothness parameter `n : WithTop ℕ∞` (where `n = 0` means topological manifold, `n = ∞` means\nsmooth manifold and `n = ω` means analytic manifold). -/\nclass IsManifold {𝕜 : Type*} [NontriviallyNormedField 𝕜] {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] {H : Type*} [TopologicalSpace H]\n    (I : ModelWithCorners 𝕜 E H) (n : WithTop ℕ∞) (M : Type*)\n    [TopologicalSpace M] [ChartedSpace H M] extends\n    HasGroupoid M (contDiffGroupoid n I) : Prop\n\n"}
{"name":"IsManifold.mk'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nn : WithTop ENat\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\ngr : HasGroupoid M (contDiffGroupoid n I)\n⊢ IsManifold I n M","decl":"/-- Building a `C^n` manifold from a `HasGroupoid` assumption. -/\ntheorem IsManifold.mk' {𝕜 : Type*} [NontriviallyNormedField 𝕜] {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] {H : Type*} [TopologicalSpace H]\n    (I : ModelWithCorners 𝕜 E H) (n : WithTop ℕ∞)\n    (M : Type*) [TopologicalSpace M] [ChartedSpace H M]\n    [gr : HasGroupoid M (contDiffGroupoid n I)] : IsManifold I n M :=\n  { gr with }\n\n"}
{"name":"SmoothManifoldWithCorners.mk'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nn : WithTop ENat\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\ngr : HasGroupoid M (contDiffGroupoid n I)\n⊢ IsManifold I n M","decl":"@[deprecated (since := \"2025-01-09\")] alias SmoothManifoldWithCorners.mk' := IsManifold.mk'\n\n"}
{"name":"isManifold_of_contDiffOn","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nn : WithTop ENat\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nh : ∀ (e e' : PartialHomeomorph M H), Membership.mem (atlas H M) e → Membership.mem (atlas H M) e' → ContDiffOn 𝕜 n (Function.comp (↑I) (Function.comp ↑(e.symm.trans e') ↑I.symm)) (Inter.inter (Set.preimage (↑I.symm) (e.symm.trans e').source) (Set.range ↑I))\n⊢ IsManifold I n M","decl":"theorem isManifold_of_contDiffOn {𝕜 : Type*} [NontriviallyNormedField 𝕜]\n    {E : Type*} [NormedAddCommGroup E] [NormedSpace 𝕜 E] {H : Type*} [TopologicalSpace H]\n    (I : ModelWithCorners 𝕜 E H) (n : WithTop ℕ∞) (M : Type*)\n    [TopologicalSpace M] [ChartedSpace H M]\n    (h : ∀ e e' : PartialHomeomorph M H, e ∈ atlas H M → e' ∈ atlas H M →\n      ContDiffOn 𝕜 n (I ∘ e.symm ≫ₕ e' ∘ I.symm) (I.symm ⁻¹' (e.symm ≫ₕ e').source ∩ range I)) :\n    IsManifold I n M where\n  compatible := by\n    haveI : HasGroupoid M (contDiffGroupoid n I) := hasGroupoid_of_pregroupoid _ (h _ _)\n    apply StructureGroupoid.compatible\n\n"}
{"name":"smoothManifoldWithCorners_of_contDiffOn","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nn : WithTop ENat\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nh : ∀ (e e' : PartialHomeomorph M H), Membership.mem (atlas H M) e → Membership.mem (atlas H M) e' → ContDiffOn 𝕜 n (Function.comp (↑I) (Function.comp ↑(e.symm.trans e') ↑I.symm)) (Inter.inter (Set.preimage (↑I.symm) (e.symm.trans e').source) (Set.range ↑I))\n⊢ IsManifold I n M","decl":"@[deprecated (since := \"2025-01-09\")]\nalias smoothManifoldWithCorners_of_contDiffOn := isManifold_of_contDiffOn\n\n"}
{"name":"intIsManifoldModelSpace","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nn : WithTop ENat\n⊢ IsManifold I n H","decl":"/-- For any model with corners, the model space is a `C^n` manifold -/\ninstance intIsManifoldModelSpace {𝕜 : Type*} [NontriviallyNormedField 𝕜] {E : Type*}\n    [NormedAddCommGroup E] [NormedSpace 𝕜 E] {H : Type*} [TopologicalSpace H]\n    {I : ModelWithCorners 𝕜 E H} {n : WithTop ℕ∞} : IsManifold I n H :=\n  { hasGroupoid_model_space _ _ with }\n\n"}
{"name":"IsManifold.of_le","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝³ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\nm n : WithTop ENat\nhmn : LE.le m n\ninst✝ : IsManifold I n M\n⊢ IsManifold I m M","decl":"protected theorem of_le {m n : WithTop ℕ∞} (hmn : m ≤ n)\n    [IsManifold I n M] : IsManifold I m M := by\n  have : HasGroupoid M (contDiffGroupoid m I) :=\n    hasGroupoid_of_le (G₁ := contDiffGroupoid n I) (by infer_instance)\n      (contDiffGroupoid_le hmn)\n  exact mk' I m M\n\n"}
{"name":"ENat.LEInfty.out","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"m : WithTop ENat\nself : ENat.LEInfty m\n⊢ LE.le m ↑Top.top","decl":"/-- A typeclass registering that a smoothness exponent is smaller than `∞`. Used to deduce that\nsome manifolds are `C^n` when they are `C^∞`. -/\nclass _root_.ENat.LEInfty (m : WithTop ℕ∞) where\n  out : m ≤ ∞\n\n"}
{"name":"IsManifold.instLEInftyCastWithTopENat","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"n : Nat\n⊢ ENat.LEInfty ↑n","decl":"instance (n : ℕ) : LEInfty (n : WithTop ℕ∞) := ⟨mod_cast le_top⟩\n"}
{"name":"IsManifold.instLEInftyOfNatWithTopENat","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ ENat.LEInfty (OfNat.ofNat n)","decl":"instance (n : ℕ) [n.AtLeastTwo] : LEInfty (no_index (OfNat.ofNat n) : WithTop ℕ∞) :=\n  inferInstanceAs (LEInfty (n : WithTop ℕ∞))\n"}
{"name":"IsManifold.instLEInftyOfNatWithTopENat_1","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"⊢ ENat.LEInfty 1","decl":"instance : LEInfty (1 : WithTop ℕ∞) := inferInstanceAs (LEInfty ((1 : ℕ) : WithTop ℕ∞))\n"}
{"name":"IsManifold.instLEInftyOfNatWithTopENat_2","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"⊢ ENat.LEInfty 0","decl":"instance : LEInfty (0 : WithTop ℕ∞) := inferInstanceAs (LEInfty ((0 : ℕ) : WithTop ℕ∞))\n\n"}
{"name":"IsManifold.instOfSomeENatTopOfLEInfty","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝³ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\na : WithTop ENat\ninst✝ : IsManifold I (↑Top.top) M\nh : ENat.LEInfty a\n⊢ IsManifold I a M","decl":"instance {a : WithTop ℕ∞} [IsManifold I ∞ M] [h : LEInfty a] :\n    IsManifold I a M :=\n  IsManifold.of_le h.out\n\n"}
{"name":"IsManifold.instOfTopWithTopENat","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝³ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\na : WithTop ENat\ninst✝ : IsManifold I Top.top M\n⊢ IsManifold I a M","decl":"instance {a : WithTop ℕ∞} [IsManifold I ω M] :\n    IsManifold I a M :=\n  IsManifold.of_le le_top\n\n"}
{"name":"IsManifold.instOfNatWithTopENat","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\n⊢ IsManifold I 0 M","decl":"instance : IsManifold I 0 M := by\n  suffices HasGroupoid M (contDiffGroupoid 0 I) from mk' I 0 M\n  constructor\n  intro e e' he he'\n  rw [contDiffGroupoid_zero_eq]\n  trivial\n\n"}
{"name":"IsManifold.instOfNatWithTopENat_1","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝³ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\ninst✝ : IsManifold I 2 M\n⊢ IsManifold I 1 M","decl":"instance [IsManifold I 2 M] :\n    IsManifold I 1 M :=\n  IsManifold.of_le one_le_two\n\n"}
{"name":"IsManifold.subset_maximalAtlas","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝³ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nn : WithTop ENat\nM : Type u_4\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\ninst✝ : IsManifold I n M\n⊢ HasSubset.Subset (atlas H M) (IsManifold.maximalAtlas I n M)","decl":"theorem subset_maximalAtlas [IsManifold I n M] : atlas H M ⊆ maximalAtlas I n M :=\n  StructureGroupoid.subset_maximalAtlas _\n\n"}
{"name":"IsManifold.chart_mem_maximalAtlas","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝³ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nn : WithTop ENat\nM : Type u_4\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\ninst✝ : IsManifold I n M\nx : M\n⊢ Membership.mem (IsManifold.maximalAtlas I n M) (chartAt H x)","decl":"theorem chart_mem_maximalAtlas [IsManifold I n M] (x : M) :\n    chartAt H x ∈ maximalAtlas I n M :=\n  StructureGroupoid.chart_mem_maximalAtlas _ x\n\n"}
{"name":"IsManifold.compatible_of_mem_maximalAtlas","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nn : WithTop ENat\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\ne e' : PartialHomeomorph M H\nhe : Membership.mem (IsManifold.maximalAtlas I n M) e\nhe' : Membership.mem (IsManifold.maximalAtlas I n M) e'\n⊢ Membership.mem (contDiffGroupoid n I) (e.symm.trans e')","decl":"theorem compatible_of_mem_maximalAtlas {e e' : PartialHomeomorph M H} (he : e ∈ maximalAtlas I n M)\n    (he' : e' ∈ maximalAtlas I n M) : e.symm.trans e' ∈ contDiffGroupoid n I :=\n  StructureGroupoid.compatible_of_mem_maximalAtlas he he'\n\n"}
{"name":"IsManifold.maximalAtlas_subset_of_le","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nm n : WithTop ENat\nh : LE.le m n\n⊢ HasSubset.Subset (IsManifold.maximalAtlas I n M) (IsManifold.maximalAtlas I m M)","decl":"lemma maximalAtlas_subset_of_le {m n : WithTop ℕ∞} (h : m ≤ n) :\n    maximalAtlas I n M ⊆ maximalAtlas I m M :=\n  StructureGroupoid.maximalAtlas_mono (contDiffGroupoid_le h)\n\n"}
{"name":"IsManifold.empty","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝³ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nn : WithTop ENat\nM : Type u_4\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\ninst✝ : IsEmpty M\n⊢ IsManifold I n M","decl":"/-- The empty set is a `C^n` manifold w.r.t. any charted space and model. -/\ninstance empty [IsEmpty M] : IsManifold I n M := by\n  apply isManifold_of_contDiffOn\n  intro e e' _ _ x hx\n  set t := I.symm ⁻¹' (e.symm ≫ₕ e').source ∩ range I\n  -- Since `M` is empty, the condition about compatibility of transition maps is vacuous.\n  have : (e.symm ≫ₕ e').source = ∅ := calc (e.symm ≫ₕ e').source\n    _ = (e.symm.source) ∩ e.symm ⁻¹' e'.source := by rw [← PartialHomeomorph.trans_source]\n    _ = (e.symm.source) ∩ e.symm ⁻¹' ∅ := by rw [eq_empty_of_isEmpty (e'.source)]\n    _ = (e.symm.source) ∩ ∅ := by rw [preimage_empty]\n    _ = ∅ := inter_empty e.symm.source\n  have : t = ∅ := calc t\n    _ = I.symm ⁻¹' (e.symm ≫ₕ e').source ∩ range I := by\n      rw [← Subtype.preimage_val_eq_preimage_val_iff]\n    _ = ∅ ∩ range I := by rw [this, preimage_empty]\n    _ = ∅ := empty_inter (range I)\n  apply (this ▸ hx).elim\n\n"}
{"name":"IsManifold.prod","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"n : WithTop ENat\n𝕜 : Type u_5\ninst✝¹² : NontriviallyNormedField 𝕜\nE : Type u_6\ninst✝¹¹ : NormedAddCommGroup E\ninst✝¹⁰ : NormedSpace 𝕜 E\nE' : Type u_7\ninst✝⁹ : NormedAddCommGroup E'\ninst✝⁸ : NormedSpace 𝕜 E'\nH : Type u_8\ninst✝⁷ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nH' : Type u_9\ninst✝⁶ : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\nM : Type u_10\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : ChartedSpace H M\ninst✝³ : IsManifold I n M\nM' : Type u_11\ninst✝² : TopologicalSpace M'\ninst✝¹ : ChartedSpace H' M'\ninst✝ : IsManifold I' n M'\n⊢ IsManifold (I.prod I') n (Prod M M')","decl":"/-- The product of two `C^n` manifolds is naturally a `C^n` manifold. -/\ninstance prod {𝕜 : Type*} [NontriviallyNormedField 𝕜] {E : Type*} [NormedAddCommGroup E]\n    [NormedSpace 𝕜 E] {E' : Type*} [NormedAddCommGroup E'] [NormedSpace 𝕜 E'] {H : Type*}\n    [TopologicalSpace H] {I : ModelWithCorners 𝕜 E H} {H' : Type*} [TopologicalSpace H']\n    {I' : ModelWithCorners 𝕜 E' H'} (M : Type*) [TopologicalSpace M] [ChartedSpace H M]\n    [IsManifold I n M] (M' : Type*) [TopologicalSpace M'] [ChartedSpace H' M']\n    [IsManifold I' n M'] :\n    IsManifold (I.prod I') n (M × M') where\n  compatible := by\n    rintro f g ⟨f1, hf1, f2, hf2, rfl⟩ ⟨g1, hg1, g2, hg2, rfl⟩\n    rw [PartialHomeomorph.prod_symm, PartialHomeomorph.prod_trans]\n    have h1 := (contDiffGroupoid n I).compatible hf1 hg1\n    have h2 := (contDiffGroupoid n I').compatible hf2 hg2\n    exact contDiffGroupoid_prod h1 h2\n\n"}
{"name":"IsManifold.disjointUnion","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁵ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nn : WithTop ENat\nM : Type u_4\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\nM' : Type u_5\ninst✝² : TopologicalSpace M'\ninst✝¹ : ChartedSpace H M'\ninst✝ : Nonempty H\n⊢ IsManifold I n (Sum M M')","decl":"/-- The disjoint union of two `C^n` manifolds modelled on `(E, H)`\nis a `C^n` manifold modeled on `(E, H)`. -/\ninstance disjointUnion [Nonempty H] : IsManifold I n (M ⊕ M') where\n  compatible {e} e' he he' := by\n    obtain (⟨f, hf, hef⟩ | ⟨f, hf, hef⟩) := ChartedSpace.mem_atlas_sum he\n    · obtain (⟨f', hf', he'f'⟩ | ⟨f', hf', he'f'⟩) := ChartedSpace.mem_atlas_sum he'\n      · rw [hef, he'f', f.lift_openEmbedding_trans f' IsOpenEmbedding.inl]\n        exact hM.compatible hf hf'\n      · rw [hef, he'f']\n        apply ContDiffGroupoid.mem_of_source_eq_empty\n        ext x\n        exact ⟨fun ⟨hx₁, hx₂⟩ ↦ by simp_all [hx₂], fun hx ↦ hx.elim⟩\n    · -- Analogous argument to the first case: is there a way to deduplicate?\n      obtain (⟨f', hf', he'f'⟩ | ⟨f', hf', he'f'⟩) := ChartedSpace.mem_atlas_sum he'\n      · rw [hef, he'f']\n        apply ContDiffGroupoid.mem_of_source_eq_empty\n        ext x\n        exact ⟨fun ⟨hx₁, hx₂⟩ ↦ by simp_all [hx₂], fun hx ↦ hx.elim⟩\n      · rw [hef, he'f', f.lift_openEmbedding_trans f' IsOpenEmbedding.inr]\n        exact hM'.compatible hf hf'\n\n"}
{"name":"PartialHomeomorph.isManifold_singleton","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nH : Type u_3\ninst✝¹ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nn : WithTop ENat\nM : Type u_4\ninst✝ : TopologicalSpace M\ne : PartialHomeomorph M H\nh : Eq e.source Set.univ\n⊢ IsManifold I n M","decl":"theorem PartialHomeomorph.isManifold_singleton\n    {𝕜 : Type*} [NontriviallyNormedField 𝕜] {E : Type*} [NormedAddCommGroup E] [NormedSpace 𝕜 E]\n    {H : Type*} [TopologicalSpace H] {I : ModelWithCorners 𝕜 E H} {n : WithTop ℕ∞}\n    {M : Type*} [TopologicalSpace M] (e : PartialHomeomorph M H) (h : e.source = Set.univ) :\n    @IsManifold 𝕜 _ E _ _ H _ I n M _ (e.singletonChartedSpace h) :=\n  @IsManifold.mk' _ _ _ _ _ _ _ _ _ _ _ (id _) <|\n    e.singleton_hasGroupoid h (contDiffGroupoid n I)\n\n"}
{"name":"PartialHomeomorph.singleton_smoothManifoldWithCorners","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nH : Type u_3\ninst✝¹ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nn : WithTop ENat\nM : Type u_4\ninst✝ : TopologicalSpace M\ne : PartialHomeomorph M H\nh : Eq e.source Set.univ\n⊢ IsManifold I n M","decl":"@[deprecated (since := \"2025-01-09\")]\nalias PartialHomeomorph.singleton_smoothManifoldWithCorners :=\n  PartialHomeomorph.isManifold_singleton\n\n"}
{"name":"Topology.IsOpenEmbedding.isManifold_singleton","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nH : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nn : WithTop ENat\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : Nonempty M\nf : M → H\nh : Topology.IsOpenEmbedding f\n⊢ IsManifold I n M","decl":"theorem Topology.IsOpenEmbedding.isManifold_singleton {𝕜 E H : Type*}\n    [NontriviallyNormedField 𝕜] [NormedAddCommGroup E] [NormedSpace 𝕜 E] [TopologicalSpace H]\n    {I : ModelWithCorners 𝕜 E H} {n : WithTop ℕ∞}\n    {M : Type*} [TopologicalSpace M] [Nonempty M] {f : M → H} (h : IsOpenEmbedding f) :\n    @IsManifold 𝕜 _ E _ _ H _ I n M _ h.singletonChartedSpace :=\n  (h.toPartialHomeomorph f).isManifold_singleton (by simp)\n\n"}
{"name":"Topology.IsOpenEmbedding.singleton_smoothManifoldWithCorners","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nH : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nn : WithTop ENat\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : Nonempty M\nf : M → H\nh : Topology.IsOpenEmbedding f\n⊢ IsManifold I n M","decl":"@[deprecated (since := \"2025-01-09\")]\nalias Topology.IsOpenEmbedding.singleton_smoothManifoldWithCorners :=\n  Topology.IsOpenEmbedding.isManifold_singleton\n\n"}
{"name":"OpenEmbedding.singleton_smoothManifoldWithCorners","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nH : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nn : WithTop ENat\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : Nonempty M\nf : M → H\nh : Topology.IsOpenEmbedding f\n⊢ IsManifold I n M","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.singleton_smoothManifoldWithCorners :=\n  Topology.IsOpenEmbedding.isManifold_singleton\n\n"}
{"name":"TopologicalSpace.Opens.instIsManifoldSubtypeMem","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝³ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nn : WithTop ENat\nM : Type u_4\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\ninst✝ : IsManifold I n M\ns : TopologicalSpace.Opens M\n⊢ IsManifold I n (Subtype fun x => Membership.mem s x)","decl":"instance : IsManifold I n s :=\n  { s.instHasGroupoid (contDiffGroupoid n I) with }\n\n"}
{"name":"PartialHomeomorph.extend_coe","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\n⊢ Eq (↑(f.extend I)) (Function.comp ↑I ↑f)","decl":"theorem extend_coe : ⇑(f.extend I) = I ∘ f :=\n  rfl\n\n"}
{"name":"PartialHomeomorph.extend_coe_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\n⊢ Eq (↑(f.extend I).symm) (Function.comp ↑f.symm ↑I.symm)","decl":"theorem extend_coe_symm : ⇑(f.extend I).symm = f.symm ∘ I.symm :=\n  rfl\n\n"}
{"name":"PartialHomeomorph.extend_source","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\n⊢ Eq (f.extend I).source f.source","decl":"theorem extend_source : (f.extend I).source = f.source := by\n  rw [extend, PartialEquiv.trans_source, I.source_eq, preimage_univ, inter_univ]\n\n"}
{"name":"PartialHomeomorph.isOpen_extend_source","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\n⊢ IsOpen (f.extend I).source","decl":"theorem isOpen_extend_source : IsOpen (f.extend I).source := by\n  rw [extend_source]\n  exact f.open_source\n\n"}
{"name":"PartialHomeomorph.extend_target","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\n⊢ Eq (f.extend I).target (Inter.inter (Set.preimage (↑I.symm) f.target) (Set.range ↑I))","decl":"theorem extend_target : (f.extend I).target = I.symm ⁻¹' f.target ∩ range I := by\n  simp_rw [extend, PartialEquiv.trans_target, I.target_eq, I.toPartialEquiv_coe_symm, inter_comm]\n\n"}
{"name":"PartialHomeomorph.extend_target'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\n⊢ Eq (f.extend I).target (Set.image (↑I) f.target)","decl":"theorem extend_target' : (f.extend I).target = I '' f.target := by\n  rw [extend, PartialEquiv.trans_target'', I.source_eq, univ_inter, I.toPartialEquiv_coe]\n\n"}
{"name":"PartialHomeomorph.isOpen_extend_target","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ninst✝ : I.Boundaryless\n⊢ IsOpen (f.extend I).target","decl":"lemma isOpen_extend_target [I.Boundaryless] : IsOpen (f.extend I).target := by\n  rw [extend_target, I.range_eq_univ, inter_univ]\n  exact I.continuous_symm.isOpen_preimage _ f.open_target\n\n"}
{"name":"PartialHomeomorph.mapsTo_extend","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ns : Set M\nhs : HasSubset.Subset s f.source\n⊢ Set.MapsTo (↑(f.extend I)) s (Inter.inter (Set.preimage (↑(f.extend I).symm) s) (Set.range ↑I))","decl":"theorem mapsTo_extend (hs : s ⊆ f.source) :\n    MapsTo (f.extend I) s ((f.extend I).symm ⁻¹' s ∩ range I) := by\n  rw [mapsTo', extend_coe, extend_coe_symm, preimage_comp, ← I.image_eq, image_comp,\n    f.image_eq_target_inter_inv_preimage hs]\n  exact image_subset _ inter_subset_right\n\n"}
{"name":"PartialHomeomorph.extend_left_inv","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\nx : M\nhxf : Membership.mem f.source x\n⊢ Eq (↑(f.extend I).symm (↑(f.extend I) x)) x","decl":"theorem extend_left_inv {x : M} (hxf : x ∈ f.source) : (f.extend I).symm (f.extend I x) = x :=\n  (f.extend I).left_inv <| by rwa [f.extend_source]\n\n"}
{"name":"PartialHomeomorph.extend_left_inv'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\nt : Set M\nht : HasSubset.Subset t f.source\n⊢ Eq (Set.image (Function.comp ↑(f.extend I).symm ↑(f.extend I)) t) t","decl":"/-- Variant of `f.extend_left_inv I`, stated in terms of images. -/\nlemma extend_left_inv' (ht : t ⊆ f.source) : ((f.extend I).symm ∘ (f.extend I)) '' t = t :=\n  EqOn.image_eq_self (fun _ hx ↦ f.extend_left_inv (ht hx))\n\n"}
{"name":"PartialHomeomorph.extend_source_mem_nhds","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\nx : M\nh : Membership.mem f.source x\n⊢ Membership.mem (nhds x) (f.extend I).source","decl":"theorem extend_source_mem_nhds {x : M} (h : x ∈ f.source) : (f.extend I).source ∈ 𝓝 x :=\n  (isOpen_extend_source f).mem_nhds <| by rwa [f.extend_source]\n\n"}
{"name":"PartialHomeomorph.extend_source_mem_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ns : Set M\nx : M\nh : Membership.mem f.source x\n⊢ Membership.mem (nhdsWithin x s) (f.extend I).source","decl":"theorem extend_source_mem_nhdsWithin {x : M} (h : x ∈ f.source) : (f.extend I).source ∈ 𝓝[s] x :=\n  mem_nhdsWithin_of_mem_nhds <| extend_source_mem_nhds f h\n\n"}
{"name":"PartialHomeomorph.continuousOn_extend","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\n⊢ ContinuousOn (↑(f.extend I)) (f.extend I).source","decl":"theorem continuousOn_extend : ContinuousOn (f.extend I) (f.extend I).source := by\n  refine I.continuous.comp_continuousOn ?_\n  rw [extend_source]\n  exact f.continuousOn\n\n"}
{"name":"PartialHomeomorph.continuousAt_extend","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\nx : M\nh : Membership.mem f.source x\n⊢ ContinuousAt (↑(f.extend I)) x","decl":"theorem continuousAt_extend {x : M} (h : x ∈ f.source) : ContinuousAt (f.extend I) x :=\n  (continuousOn_extend f).continuousAt <| extend_source_mem_nhds f h\n\n"}
{"name":"PartialHomeomorph.map_extend_nhds","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\nx : M\nhy : Membership.mem f.source x\n⊢ Eq (Filter.map (↑(f.extend I)) (nhds x)) (nhdsWithin (↑(f.extend I) x) (Set.range ↑I))","decl":"theorem map_extend_nhds {x : M} (hy : x ∈ f.source) :\n    map (f.extend I) (𝓝 x) = 𝓝[range I] f.extend I x := by\n  rwa [extend_coe, comp_apply, ← I.map_nhds_eq, ← f.map_nhds_eq, map_map]\n\n"}
{"name":"PartialHomeomorph.map_extend_nhds_of_mem_interior_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\nx : M\nhx : Membership.mem f.source x\nh'x : Membership.mem (interior (Set.range ↑I)) (↑(f.extend I) x)\n⊢ Eq (Filter.map (↑(f.extend I)) (nhds x)) (nhds (↑(f.extend I) x))","decl":"theorem map_extend_nhds_of_mem_interior_range {x : M} (hx : x ∈ f.source)\n    (h'x : f.extend I x ∈ interior (range I)) :\n    map (f.extend I) (𝓝 x) = 𝓝 (f.extend I x) := by\n  rw [f.map_extend_nhds hx, nhdsWithin_eq_nhds]\n  exact mem_of_superset (isOpen_interior.mem_nhds h'x) interior_subset\n\n"}
{"name":"PartialHomeomorph.map_extend_nhds_of_boundaryless","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ninst✝ : I.Boundaryless\nx : M\nhx : Membership.mem f.source x\n⊢ Eq (Filter.map (↑(f.extend I)) (nhds x)) (nhds (↑(f.extend I) x))","decl":"theorem map_extend_nhds_of_boundaryless [I.Boundaryless] {x : M} (hx : x ∈ f.source) :\n    map (f.extend I) (𝓝 x) = 𝓝 (f.extend I x) := by\n  rw [f.map_extend_nhds hx, I.range_eq_univ, nhdsWithin_univ]\n\n"}
{"name":"PartialHomeomorph.extend_target_mem_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ny : M\nhy : Membership.mem f.source y\n⊢ Membership.mem (nhdsWithin (↑(f.extend I) y) (Set.range ↑I)) (f.extend I).target","decl":"theorem extend_target_mem_nhdsWithin {y : M} (hy : y ∈ f.source) :\n    (f.extend I).target ∈ 𝓝[range I] f.extend I y := by\n  rw [← PartialEquiv.image_source_eq_target, ← map_extend_nhds f hy]\n  exact image_mem_map (extend_source_mem_nhds _ hy)\n\n"}
{"name":"PartialHomeomorph.extend_image_nhd_mem_nhds_of_boundaryless","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ninst✝ : I.Boundaryless\nx : M\nhx : Membership.mem f.source x\ns : Set M\nh : Membership.mem (nhds x) s\n⊢ Membership.mem (nhds (↑(f.extend I) x)) (Set.image (↑(f.extend I)) s)","decl":"theorem extend_image_nhd_mem_nhds_of_boundaryless [I.Boundaryless] {x} (hx : x ∈ f.source)\n    {s : Set M} (h : s ∈ 𝓝 x) : (f.extend I) '' s ∈ 𝓝 ((f.extend I) x) := by\n  rw [← f.map_extend_nhds_of_boundaryless hx, Filter.mem_map]\n  filter_upwards [h] using subset_preimage_image (f.extend I) s\n\n"}
{"name":"PartialHomeomorph.extend_image_nhd_mem_nhds_of_mem_interior_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\nx : M\nhx : Membership.mem f.source x\nh'x : Membership.mem (interior (Set.range ↑I)) (↑(f.extend I) x)\ns : Set M\nh : Membership.mem (nhds x) s\n⊢ Membership.mem (nhds (↑(f.extend I) x)) (Set.image (↑(f.extend I)) s)","decl":"theorem extend_image_nhd_mem_nhds_of_mem_interior_range {x} (hx : x ∈ f.source)\n    (h'x : f.extend I x ∈ interior (range I)) {s : Set M} (h : s ∈ 𝓝 x) :\n    (f.extend I) '' s ∈ 𝓝 ((f.extend I) x) := by\n  rw [← f.map_extend_nhds_of_mem_interior_range hx h'x, Filter.mem_map]\n  filter_upwards [h] using subset_preimage_image (f.extend I) s\n\n"}
{"name":"PartialHomeomorph.extend_target_subset_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\n⊢ HasSubset.Subset (f.extend I).target (Set.range ↑I)","decl":"theorem extend_target_subset_range : (f.extend I).target ⊆ range I := by simp only [mfld_simps]\n\n"}
{"name":"PartialHomeomorph.interior_extend_target_subset_interior_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\n⊢ HasSubset.Subset (interior (f.extend I).target) (interior (Set.range ↑I))","decl":"lemma interior_extend_target_subset_interior_range :\n    interior (f.extend I).target ⊆ interior (range I) := by\n  rw [f.extend_target, interior_inter, (f.open_target.preimage I.continuous_symm).interior_eq]\n  exact inter_subset_right\n\n"}
{"name":"PartialHomeomorph.mem_interior_extend_target","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ny : H\nhy : Membership.mem f.target y\nhy' : Membership.mem (interior (Set.range ↑I)) (↑I y)\n⊢ Membership.mem (interior (f.extend I).target) (↑I y)","decl":"/-- If `y ∈ f.target` and `I y ∈ interior (range I)`,\n  then `I y` is an interior point of `(I ∘ f).target`. -/\nlemma mem_interior_extend_target {y : H} (hy : y ∈ f.target)\n    (hy' : I y ∈ interior (range I)) : I y ∈ interior (f.extend I).target := by\n  rw [f.extend_target, interior_inter, (f.open_target.preimage I.continuous_symm).interior_eq,\n    mem_inter_iff, mem_preimage]\n  exact ⟨mem_of_eq_of_mem (I.left_inv (y)) hy, hy'⟩\n\n"}
{"name":"PartialHomeomorph.nhdsWithin_extend_target_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ny : M\nhy : Membership.mem f.source y\n⊢ Eq (nhdsWithin (↑(f.extend I) y) (f.extend I).target) (nhdsWithin (↑(f.extend I) y) (Set.range ↑I))","decl":"theorem nhdsWithin_extend_target_eq {y : M} (hy : y ∈ f.source) :\n    𝓝[(f.extend I).target] f.extend I y = 𝓝[range I] f.extend I y :=\n  (nhdsWithin_mono _ (extend_target_subset_range _)).antisymm <|\n    nhdsWithin_le_of_mem (extend_target_mem_nhdsWithin _ hy)\n\n"}
{"name":"PartialHomeomorph.extend_target_eventuallyEq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ny : M\nhy : Membership.mem f.source y\n⊢ (nhds (↑(f.extend I) y)).EventuallyEq (f.extend I).target (Set.range ↑I)","decl":"theorem extend_target_eventuallyEq {y : M} (hy : y ∈ f.source) :\n    (f.extend I).target =ᶠ[𝓝 (f.extend I y)] range I :=\n  nhdsWithin_eq_iff_eventuallyEq.1 (nhdsWithin_extend_target_eq _ hy)\n\n"}
{"name":"PartialHomeomorph.continuousAt_extend_symm'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\nx : E\nh : Membership.mem (f.extend I).target x\n⊢ ContinuousAt (↑(f.extend I).symm) x","decl":"theorem continuousAt_extend_symm' {x : E} (h : x ∈ (f.extend I).target) :\n    ContinuousAt (f.extend I).symm x :=\n  (f.continuousAt_symm h.2).comp I.continuous_symm.continuousAt\n\n"}
{"name":"PartialHomeomorph.continuousAt_extend_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\nx : M\nh : Membership.mem f.source x\n⊢ ContinuousAt (↑(f.extend I).symm) (↑(f.extend I) x)","decl":"theorem continuousAt_extend_symm {x : M} (h : x ∈ f.source) :\n    ContinuousAt (f.extend I).symm (f.extend I x) :=\n  continuousAt_extend_symm' f <| (f.extend I).map_source <| by rwa [f.extend_source]\n\n"}
{"name":"PartialHomeomorph.continuousOn_extend_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\n⊢ ContinuousOn (↑(f.extend I).symm) (f.extend I).target","decl":"theorem continuousOn_extend_symm : ContinuousOn (f.extend I).symm (f.extend I).target := fun _ h =>\n  (continuousAt_extend_symm' _ h).continuousWithinAt\n\n"}
{"name":"PartialHomeomorph.extend_symm_continuousWithinAt_comp_right_iff","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\nX : Type u_8\ninst✝ : TopologicalSpace X\ng : M → X\ns : Set M\nx : M\n⊢ Iff (ContinuousWithinAt (Function.comp g ↑(f.extend I).symm) (Inter.inter (Set.preimage (↑(f.extend I).symm) s) (Set.range ↑I)) (↑(f.extend I) x)) (ContinuousWithinAt (Function.comp g ↑f.symm) (Set.preimage (↑f.symm) s) (↑f x))","decl":"theorem extend_symm_continuousWithinAt_comp_right_iff {X} [TopologicalSpace X] {g : M → X}\n    {s : Set M} {x : M} :\n    ContinuousWithinAt (g ∘ (f.extend I).symm) ((f.extend I).symm ⁻¹' s ∩ range I) (f.extend I x) ↔\n      ContinuousWithinAt (g ∘ f.symm) (f.symm ⁻¹' s) (f x) := by\n  rw [← I.symm_continuousWithinAt_comp_right_iff]; rfl\n\n"}
{"name":"PartialHomeomorph.isOpen_extend_preimage'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ns : Set E\nhs : IsOpen s\n⊢ IsOpen (Inter.inter (f.extend I).source (Set.preimage (↑(f.extend I)) s))","decl":"theorem isOpen_extend_preimage' {s : Set E} (hs : IsOpen s) :\n    IsOpen ((f.extend I).source ∩ f.extend I ⁻¹' s) :=\n  (continuousOn_extend f).isOpen_inter_preimage (isOpen_extend_source _) hs\n\n"}
{"name":"PartialHomeomorph.isOpen_extend_preimage","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ns : Set E\nhs : IsOpen s\n⊢ IsOpen (Inter.inter f.source (Set.preimage (↑(f.extend I)) s))","decl":"theorem isOpen_extend_preimage {s : Set E} (hs : IsOpen s) :\n    IsOpen (f.source ∩ f.extend I ⁻¹' s) := by\n  rw [← extend_source f (I := I)]; exact isOpen_extend_preimage' f hs\n\n"}
{"name":"PartialHomeomorph.map_extend_nhdsWithin_eq_image","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ns : Set M\ny : M\nhy : Membership.mem f.source y\n⊢ Eq (Filter.map (↑(f.extend I)) (nhdsWithin y s)) (nhdsWithin (↑(f.extend I) y) (Set.image (↑(f.extend I)) (Inter.inter (f.extend I).source s)))","decl":"theorem map_extend_nhdsWithin_eq_image {y : M} (hy : y ∈ f.source) :\n    map (f.extend I) (𝓝[s] y) = 𝓝[f.extend I '' ((f.extend I).source ∩ s)] f.extend I y := by\n  set e := f.extend I\n  calc\n    map e (𝓝[s] y) = map e (𝓝[e.source ∩ s] y) :=\n      congr_arg (map e) (nhdsWithin_inter_of_mem (extend_source_mem_nhdsWithin f hy)).symm\n    _ = 𝓝[e '' (e.source ∩ s)] e y :=\n      ((f.extend I).leftInvOn.mono inter_subset_left).map_nhdsWithin_eq\n        ((f.extend I).left_inv <| by rwa [f.extend_source])\n        (continuousAt_extend_symm f hy).continuousWithinAt\n        (continuousAt_extend f hy).continuousWithinAt\n\n"}
{"name":"PartialHomeomorph.map_extend_nhdsWithin_eq_image_of_subset","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ns : Set M\ny : M\nhy : Membership.mem f.source y\nhs : HasSubset.Subset s f.source\n⊢ Eq (Filter.map (↑(f.extend I)) (nhdsWithin y s)) (nhdsWithin (↑(f.extend I) y) (Set.image (↑(f.extend I)) s))","decl":"theorem map_extend_nhdsWithin_eq_image_of_subset {y : M} (hy : y ∈ f.source) (hs : s ⊆ f.source) :\n    map (f.extend I) (𝓝[s] y) = 𝓝[f.extend I '' s] f.extend I y := by\n  rw [map_extend_nhdsWithin_eq_image _ hy, inter_eq_self_of_subset_right]\n  rwa [extend_source]\n\n"}
{"name":"PartialHomeomorph.map_extend_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ns : Set M\ny : M\nhy : Membership.mem f.source y\n⊢ Eq (Filter.map (↑(f.extend I)) (nhdsWithin y s)) (nhdsWithin (↑(f.extend I) y) (Inter.inter (Set.preimage (↑(f.extend I).symm) s) (Set.range ↑I)))","decl":"theorem map_extend_nhdsWithin {y : M} (hy : y ∈ f.source) :\n    map (f.extend I) (𝓝[s] y) = 𝓝[(f.extend I).symm ⁻¹' s ∩ range I] f.extend I y := by\n  rw [map_extend_nhdsWithin_eq_image f hy, nhdsWithin_inter, ←\n    nhdsWithin_extend_target_eq _ hy, ← nhdsWithin_inter, (f.extend I).image_source_inter_eq',\n    inter_comm]\n\n"}
{"name":"PartialHomeomorph.map_extend_symm_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ns : Set M\ny : M\nhy : Membership.mem f.source y\n⊢ Eq (Filter.map (↑(f.extend I).symm) (nhdsWithin (↑(f.extend I) y) (Inter.inter (Set.preimage (↑(f.extend I).symm) s) (Set.range ↑I)))) (nhdsWithin y s)","decl":"theorem map_extend_symm_nhdsWithin {y : M} (hy : y ∈ f.source) :\n    map (f.extend I).symm (𝓝[(f.extend I).symm ⁻¹' s ∩ range I] f.extend I y) = 𝓝[s] y := by\n  rw [← map_extend_nhdsWithin f hy, map_map, Filter.map_congr, map_id]\n  exact (f.extend I).leftInvOn.eqOn.eventuallyEq_of_mem (extend_source_mem_nhdsWithin _ hy)\n\n"}
{"name":"PartialHomeomorph.map_extend_symm_nhdsWithin_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ny : M\nhy : Membership.mem f.source y\n⊢ Eq (Filter.map (↑(f.extend I).symm) (nhdsWithin (↑(f.extend I) y) (Set.range ↑I))) (nhds y)","decl":"theorem map_extend_symm_nhdsWithin_range {y : M} (hy : y ∈ f.source) :\n    map (f.extend I).symm (𝓝[range I] f.extend I y) = 𝓝 y := by\n  rw [← nhdsWithin_univ, ← map_extend_symm_nhdsWithin f (I := I) hy, preimage_univ, univ_inter]\n\n"}
{"name":"PartialHomeomorph.tendsto_extend_comp_iff","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\nα : Type u_8\nl : Filter α\ng : α → M\nhg : Filter.Eventually (fun z => Membership.mem f.source (g z)) l\ny : M\nhy : Membership.mem f.source y\n⊢ Iff (Filter.Tendsto (Function.comp (↑(f.extend I)) g) l (nhds (↑(f.extend I) y))) (Filter.Tendsto g l (nhds y))","decl":"theorem tendsto_extend_comp_iff {α : Type*} {l : Filter α} {g : α → M}\n    (hg : ∀ᶠ z in l, g z ∈ f.source) {y : M} (hy : y ∈ f.source) :\n    Tendsto (f.extend I ∘ g) l (𝓝 (f.extend I y)) ↔ Tendsto g l (𝓝 y) := by\n  refine ⟨fun h u hu ↦ mem_map.2 ?_, (continuousAt_extend _ hy).tendsto.comp⟩\n  have := (f.continuousAt_extend_symm hy).tendsto.comp h\n  rw [extend_left_inv _ hy] at this\n  filter_upwards [hg, mem_map.1 (this hu)] with z hz hzu\n  simpa only [(· ∘ ·), extend_left_inv _ hz, mem_preimage] using hzu\n\n-- there is no definition `writtenInExtend` but we already use some made-up names in this file\n"}
{"name":"PartialHomeomorph.continuousWithinAt_writtenInExtend_iff","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\nE' : Type u_5\nM' : Type u_6\nH' : Type u_7\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : TopologicalSpace H\ninst✝⁴ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ninst✝³ : NormedAddCommGroup E'\ninst✝² : NormedSpace 𝕜 E'\ninst✝¹ : TopologicalSpace H'\ninst✝ : TopologicalSpace M'\nI' : ModelWithCorners 𝕜 E' H'\ns : Set M\nf' : PartialHomeomorph M' H'\ng : M → M'\ny : M\nhy : Membership.mem f.source y\nhgy : Membership.mem f'.source (g y)\nhmaps : Set.MapsTo g s f'.source\n⊢ Iff (ContinuousWithinAt (Function.comp (↑(f'.extend I')) (Function.comp g ↑(f.extend I).symm)) (Inter.inter (Set.preimage (↑(f.extend I).symm) s) (Set.range ↑I)) (↑(f.extend I) y)) (ContinuousWithinAt g s y)","decl":"theorem continuousWithinAt_writtenInExtend_iff {f' : PartialHomeomorph M' H'} {g : M → M'} {y : M}\n    (hy : y ∈ f.source) (hgy : g y ∈ f'.source) (hmaps : MapsTo g s f'.source) :\n    ContinuousWithinAt (f'.extend I' ∘ g ∘ (f.extend I).symm)\n      ((f.extend I).symm ⁻¹' s ∩ range I) (f.extend I y) ↔ ContinuousWithinAt g s y := by\n  unfold ContinuousWithinAt\n  simp only [comp_apply]\n  rw [extend_left_inv _ hy, f'.tendsto_extend_comp_iff _ hgy,\n    ← f.map_extend_symm_nhdsWithin (I := I) hy, tendsto_map'_iff]\n  rw [← f.map_extend_nhdsWithin (I := I) hy, eventually_map]\n  filter_upwards [inter_mem_nhdsWithin _ (f.open_source.mem_nhds hy)] with z hz\n  rw [comp_apply, extend_left_inv _ hz.2]\n  exact hmaps hz.1\n\n-- there is no definition `writtenInExtend` but we already use some made-up names in this file\n\n"}
{"name":"PartialHomeomorph.continuousOn_writtenInExtend_iff","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\nE' : Type u_5\nM' : Type u_6\nH' : Type u_7\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : TopologicalSpace H\ninst✝⁴ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ninst✝³ : NormedAddCommGroup E'\ninst✝² : NormedSpace 𝕜 E'\ninst✝¹ : TopologicalSpace H'\ninst✝ : TopologicalSpace M'\nI' : ModelWithCorners 𝕜 E' H'\ns : Set M\nf' : PartialHomeomorph M' H'\ng : M → M'\nhs : HasSubset.Subset s f.source\nhmaps : Set.MapsTo g s f'.source\n⊢ Iff (ContinuousOn (Function.comp (↑(f'.extend I')) (Function.comp g ↑(f.extend I).symm)) (Set.image (↑(f.extend I)) s)) (ContinuousOn g s)","decl":"/-- If `s ⊆ f.source` and `g x ∈ f'.source` whenever `x ∈ s`, then `g` is continuous on `s` if and\nonly if `g` written in charts `f.extend I` and `f'.extend I'` is continuous on `f.extend I '' s`. -/\ntheorem continuousOn_writtenInExtend_iff {f' : PartialHomeomorph M' H'} {g : M → M'}\n    (hs : s ⊆ f.source) (hmaps : MapsTo g s f'.source) :\n    ContinuousOn (f'.extend I' ∘ g ∘ (f.extend I).symm) (f.extend I '' s) ↔ ContinuousOn g s := by\n  refine forall_mem_image.trans <| forall₂_congr fun x hx ↦ ?_\n  refine (continuousWithinAt_congr_set ?_).trans\n    (continuousWithinAt_writtenInExtend_iff _ (hs hx) (hmaps hx) hmaps)\n  rw [← nhdsWithin_eq_iff_eventuallyEq, ← map_extend_nhdsWithin_eq_image_of_subset,\n    ← map_extend_nhdsWithin]\n  exacts [hs hx, hs hx, hs]\n\n"}
{"name":"PartialHomeomorph.extend_preimage_mem_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ns t : Set M\nx : M\nh : Membership.mem f.source x\nht : Membership.mem (nhdsWithin x s) t\n⊢ Membership.mem (nhdsWithin (↑(f.extend I) x) (Inter.inter (Set.preimage (↑(f.extend I).symm) s) (Set.range ↑I))) (Set.preimage (↑(f.extend I).symm) t)","decl":"/-- Technical lemma ensuring that the preimage under an extended chart of a neighborhood of a point\nin the source is a neighborhood of the preimage, within a set. -/\ntheorem extend_preimage_mem_nhdsWithin {x : M} (h : x ∈ f.source) (ht : t ∈ 𝓝[s] x) :\n    (f.extend I).symm ⁻¹' t ∈ 𝓝[(f.extend I).symm ⁻¹' s ∩ range I] f.extend I x := by\n  rwa [← map_extend_symm_nhdsWithin f (I := I) h, mem_map] at ht\n\n"}
{"name":"PartialHomeomorph.extend_preimage_mem_nhds","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\nt : Set M\nx : M\nh : Membership.mem f.source x\nht : Membership.mem (nhds x) t\n⊢ Membership.mem (nhds (↑(f.extend I) x)) (Set.preimage (↑(f.extend I).symm) t)","decl":"theorem extend_preimage_mem_nhds {x : M} (h : x ∈ f.source) (ht : t ∈ 𝓝 x) :\n    (f.extend I).symm ⁻¹' t ∈ 𝓝 (f.extend I x) := by\n  apply (continuousAt_extend_symm f h).preimage_mem_nhds\n  rwa [(f.extend I).left_inv]\n  rwa [f.extend_source]\n\n"}
{"name":"PartialHomeomorph.extend_preimage_inter_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ns t : Set M\n⊢ Eq (Inter.inter (Set.preimage (↑(f.extend I).symm) (Inter.inter s t)) (Set.range ↑I)) (Inter.inter (Inter.inter (Set.preimage (↑(f.extend I).symm) s) (Set.range ↑I)) (Set.preimage (↑(f.extend I).symm) t))","decl":"/-- Technical lemma to rewrite suitably the preimage of an intersection under an extended chart, to\nbring it into a convenient form to apply derivative lemmas. -/\ntheorem extend_preimage_inter_eq :\n    (f.extend I).symm ⁻¹' (s ∩ t) ∩ range I =\n      (f.extend I).symm ⁻¹' s ∩ range I ∩ (f.extend I).symm ⁻¹' t := by\n  mfld_set_tac\n\n-- Porting note: an `aux` lemma that is no longer needed. Delete?\n"}
{"name":"PartialHomeomorph.extend_symm_preimage_inter_range_eventuallyEq_aux","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ns : Set M\nx : M\nhx : Membership.mem f.source x\n⊢ (nhds (↑(f.extend I) x)).EventuallyEq (Inter.inter (Set.preimage (↑(f.extend I).symm) s) (Set.range ↑I)) (Inter.inter (f.extend I).target (Set.preimage (↑(f.extend I).symm) s))","decl":"theorem extend_symm_preimage_inter_range_eventuallyEq_aux {s : Set M} {x : M} (hx : x ∈ f.source) :\n    ((f.extend I).symm ⁻¹' s ∩ range I : Set _) =ᶠ[𝓝 (f.extend I x)]\n      ((f.extend I).target ∩ (f.extend I).symm ⁻¹' s : Set _) := by\n  rw [f.extend_target, inter_assoc, inter_comm (range I)]\n  conv =>\n    congr\n    · skip\n    rw [← univ_inter (_ ∩ range I)]\n  refine (eventuallyEq_univ.mpr ?_).symm.inter EventuallyEq.rfl\n  refine I.continuousAt_symm.preimage_mem_nhds (f.open_target.mem_nhds ?_)\n  simp_rw [f.extend_coe, Function.comp_apply, I.left_inv, f.mapsTo hx]\n\n"}
{"name":"PartialHomeomorph.extend_symm_preimage_inter_range_eventuallyEq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ns : Set M\nx : M\nhs : HasSubset.Subset s f.source\nhx : Membership.mem f.source x\n⊢ (nhds (↑(f.extend I) x)).EventuallyEq (Inter.inter (Set.preimage (↑(f.extend I).symm) s) (Set.range ↑I)) (Set.image (↑(f.extend I)) s)","decl":"theorem extend_symm_preimage_inter_range_eventuallyEq {s : Set M} {x : M} (hs : s ⊆ f.source)\n    (hx : x ∈ f.source) :\n    ((f.extend I).symm ⁻¹' s ∩ range I : Set _) =ᶠ[𝓝 (f.extend I x)] f.extend I '' s := by\n  rw [← nhdsWithin_eq_iff_eventuallyEq, ← map_extend_nhdsWithin _ hx,\n    map_extend_nhdsWithin_eq_image_of_subset _ hx hs]\n\n"}
{"name":"PartialHomeomorph.extend_coord_change_source","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf f' : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\n⊢ Eq ((f.extend I).symm.trans (f'.extend I)).source (Set.image (↑I) (f.symm.trans f').source)","decl":"theorem extend_coord_change_source :\n    ((f.extend I).symm ≫ f'.extend I).source = I '' (f.symm ≫ₕ f').source := by\n  simp_rw [PartialEquiv.trans_source, I.image_eq, extend_source, PartialEquiv.symm_source,\n    extend_target, inter_right_comm _ (range I)]\n  rfl\n\n"}
{"name":"PartialHomeomorph.extend_image_source_inter","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf f' : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\n⊢ Eq (Set.image (↑(f.extend I)) (Inter.inter f.source f'.source)) ((f.extend I).symm.trans (f'.extend I)).source","decl":"theorem extend_image_source_inter :\n    f.extend I '' (f.source ∩ f'.source) = ((f.extend I).symm ≫ f'.extend I).source := by\n  simp_rw [f.extend_coord_change_source, f.extend_coe, image_comp I f, trans_source'', symm_symm,\n    symm_target]\n\n"}
{"name":"PartialHomeomorph.extend_coord_change_source_mem_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf f' : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\nx : E\nhx : Membership.mem ((f.extend I).symm.trans (f'.extend I)).source x\n⊢ Membership.mem (nhdsWithin x (Set.range ↑I)) ((f.extend I).symm.trans (f'.extend I)).source","decl":"theorem extend_coord_change_source_mem_nhdsWithin {x : E}\n    (hx : x ∈ ((f.extend I).symm ≫ f'.extend I).source) :\n    ((f.extend I).symm ≫ f'.extend I).source ∈ 𝓝[range I] x := by\n  rw [f.extend_coord_change_source] at hx ⊢\n  obtain ⟨x, hx, rfl⟩ := hx\n  refine I.image_mem_nhdsWithin ?_\n  exact (PartialHomeomorph.open_source _).mem_nhds hx\n\n"}
{"name":"PartialHomeomorph.extend_coord_change_source_mem_nhdsWithin'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : TopologicalSpace H\ninst✝ : TopologicalSpace M\nf f' : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\nx : M\nhxf : Membership.mem f.source x\nhxf' : Membership.mem f'.source x\n⊢ Membership.mem (nhdsWithin (↑(f.extend I) x) (Set.range ↑I)) ((f.extend I).symm.trans (f'.extend I)).source","decl":"theorem extend_coord_change_source_mem_nhdsWithin' {x : M} (hxf : x ∈ f.source)\n    (hxf' : x ∈ f'.source) :\n    ((f.extend I).symm ≫ f'.extend I).source ∈ 𝓝[range I] f.extend I x := by\n  apply extend_coord_change_source_mem_nhdsWithin\n  rw [← extend_image_source_inter]\n  exact mem_image_of_mem _ ⟨hxf, hxf'⟩\n\n"}
{"name":"PartialHomeomorph.contDiffOn_extend_coord_change","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nn : WithTop ENat\nf f' : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nhf : Membership.mem (IsManifold.maximalAtlas I n M) f\nhf' : Membership.mem (IsManifold.maximalAtlas I n M) f'\n⊢ ContDiffOn 𝕜 n (Function.comp ↑(f.extend I) ↑(f'.extend I).symm) ((f'.extend I).symm.trans (f.extend I)).source","decl":"theorem contDiffOn_extend_coord_change [ChartedSpace H M] (hf : f ∈ maximalAtlas I n M)\n    (hf' : f' ∈ maximalAtlas I n M) :\n    ContDiffOn 𝕜 n (f.extend I ∘ (f'.extend I).symm) ((f'.extend I).symm ≫ f.extend I).source := by\n  rw [extend_coord_change_source, I.image_eq]\n  exact (StructureGroupoid.compatible_of_mem_maximalAtlas hf' hf).1\n\n"}
{"name":"PartialHomeomorph.contDiffWithinAt_extend_coord_change","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nn : WithTop ENat\nf f' : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nhf : Membership.mem (IsManifold.maximalAtlas I n M) f\nhf' : Membership.mem (IsManifold.maximalAtlas I n M) f'\nx : E\nhx : Membership.mem ((f'.extend I).symm.trans (f.extend I)).source x\n⊢ ContDiffWithinAt 𝕜 n (Function.comp ↑(f.extend I) ↑(f'.extend I).symm) (Set.range ↑I) x","decl":"theorem contDiffWithinAt_extend_coord_change [ChartedSpace H M] (hf : f ∈ maximalAtlas I n M)\n    (hf' : f' ∈ maximalAtlas I n M) {x : E} (hx : x ∈ ((f'.extend I).symm ≫ f.extend I).source) :\n    ContDiffWithinAt 𝕜 n (f.extend I ∘ (f'.extend I).symm) (range I) x := by\n  apply (contDiffOn_extend_coord_change hf hf' x hx).mono_of_mem_nhdsWithin\n  rw [extend_coord_change_source] at hx ⊢\n  obtain ⟨z, hz, rfl⟩ := hx\n  exact I.image_mem_nhdsWithin ((PartialHomeomorph.open_source _).mem_nhds hz)\n\n"}
{"name":"PartialHomeomorph.contDiffWithinAt_extend_coord_change'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nn : WithTop ENat\nf f' : PartialHomeomorph M H\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nhf : Membership.mem (IsManifold.maximalAtlas I n M) f\nhf' : Membership.mem (IsManifold.maximalAtlas I n M) f'\nx : M\nhxf : Membership.mem f.source x\nhxf' : Membership.mem f'.source x\n⊢ ContDiffWithinAt 𝕜 n (Function.comp ↑(f.extend I) ↑(f'.extend I).symm) (Set.range ↑I) (↑(f'.extend I) x)","decl":"theorem contDiffWithinAt_extend_coord_change' [ChartedSpace H M] (hf : f ∈ maximalAtlas I n M)\n    (hf' : f' ∈ maximalAtlas I n M) {x : M} (hxf : x ∈ f.source) (hxf' : x ∈ f'.source) :\n    ContDiffWithinAt 𝕜 n (f.extend I ∘ (f'.extend I).symm) (range I) (f'.extend I x) := by\n  refine contDiffWithinAt_extend_coord_change hf hf' ?_\n  rw [← extend_image_source_inter]\n  exact mem_image_of_mem _ ⟨hxf', hxf⟩\n\n"}
{"name":"extChartAt_coe","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ Eq (↑(extChartAt I x)) (Function.comp ↑I ↑(chartAt H x))","decl":"theorem extChartAt_coe (x : M) : ⇑(extChartAt I x) = I ∘ chartAt H x :=\n  rfl\n\n"}
{"name":"extChartAt_coe_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ Eq (↑(extChartAt I x).symm) (Function.comp ↑(chartAt H x).symm ↑I.symm)","decl":"theorem extChartAt_coe_symm (x : M) : ⇑(extChartAt I x).symm = (chartAt H x).symm ∘ I.symm :=\n  rfl\n\n"}
{"name":"extChartAt_source","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ Eq (extChartAt I x).source (chartAt H x).source","decl":"variable (I) in\ntheorem extChartAt_source (x : M) : (extChartAt I x).source = (chartAt H x).source :=\n  extend_source _\n\n"}
{"name":"isOpen_extChartAt_source","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ IsOpen (extChartAt I x).source","decl":"theorem isOpen_extChartAt_source (x : M) : IsOpen (extChartAt I x).source :=\n  isOpen_extend_source _\n\n"}
{"name":"mem_extChartAt_source","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ Membership.mem (extChartAt I x).source x","decl":"theorem mem_extChartAt_source (x : M) : x ∈ (extChartAt I x).source := by\n  simp only [extChartAt_source, mem_chart_source]\n\n"}
{"name":"mem_extChartAt_target","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ Membership.mem (extChartAt I x).target (↑(extChartAt I x) x)","decl":"theorem mem_extChartAt_target (x : M) : extChartAt I x x ∈ (extChartAt I x).target :=\n  (extChartAt I x).map_source <| mem_extChartAt_source _\n\n"}
{"name":"extChartAt_target","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ Eq (extChartAt I x).target (Inter.inter (Set.preimage (↑I.symm) (chartAt H x).target) (Set.range ↑I))","decl":"variable (I) in\ntheorem extChartAt_target (x : M) :\n    (extChartAt I x).target = I.symm ⁻¹' (chartAt H x).target ∩ range I :=\n  extend_target _\n\n"}
{"name":"uniqueDiffOn_extChartAt_target","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ UniqueDiffOn 𝕜 (extChartAt I x).target","decl":"theorem uniqueDiffOn_extChartAt_target (x : M) : UniqueDiffOn 𝕜 (extChartAt I x).target := by\n  rw [extChartAt_target]\n  exact I.uniqueDiffOn_preimage (chartAt H x).open_target\n\n"}
{"name":"uniqueDiffWithinAt_extChartAt_target","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ UniqueDiffWithinAt 𝕜 (extChartAt I x).target (↑(extChartAt I x) x)","decl":"theorem uniqueDiffWithinAt_extChartAt_target (x : M) :\n    UniqueDiffWithinAt 𝕜 (extChartAt I x).target (extChartAt I x x) :=\n  uniqueDiffOn_extChartAt_target x _ <| mem_extChartAt_target x\n\n"}
{"name":"extChartAt_to_inv","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ Eq (↑(extChartAt I x).symm (↑(extChartAt I x) x)) x","decl":"theorem extChartAt_to_inv (x : M) : (extChartAt I x).symm ((extChartAt I x) x) = x :=\n  (extChartAt I x).left_inv (mem_extChartAt_source x)\n\n"}
{"name":"mapsTo_extChartAt","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ns : Set M\ninst✝ : ChartedSpace H M\nx : M\nhs : HasSubset.Subset s (chartAt H x).source\n⊢ Set.MapsTo (↑(extChartAt I x)) s (Inter.inter (Set.preimage (↑(extChartAt I x).symm) s) (Set.range ↑I))","decl":"theorem mapsTo_extChartAt {x : M} (hs : s ⊆ (chartAt H x).source) :\n    MapsTo (extChartAt I x) s ((extChartAt I x).symm ⁻¹' s ∩ range I) :=\n  mapsTo_extend _ hs\n\n"}
{"name":"extChartAt_source_mem_nhds'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx x' : M\nh : Membership.mem (extChartAt I x).source x'\n⊢ Membership.mem (nhds x') (extChartAt I x).source","decl":"theorem extChartAt_source_mem_nhds' {x x' : M} (h : x' ∈ (extChartAt I x).source) :\n    (extChartAt I x).source ∈ 𝓝 x' :=\n  extend_source_mem_nhds _ <| by rwa [← extChartAt_source I]\n\n"}
{"name":"extChartAt_source_mem_nhds","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ Membership.mem (nhds x) (extChartAt I x).source","decl":"theorem extChartAt_source_mem_nhds (x : M) : (extChartAt I x).source ∈ 𝓝 x :=\n  extChartAt_source_mem_nhds' (mem_extChartAt_source x)\n\n"}
{"name":"extChartAt_source_mem_nhdsWithin'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ns : Set M\ninst✝ : ChartedSpace H M\nx x' : M\nh : Membership.mem (extChartAt I x).source x'\n⊢ Membership.mem (nhdsWithin x' s) (extChartAt I x).source","decl":"theorem extChartAt_source_mem_nhdsWithin' {x x' : M} (h : x' ∈ (extChartAt I x).source) :\n    (extChartAt I x).source ∈ 𝓝[s] x' :=\n  mem_nhdsWithin_of_mem_nhds (extChartAt_source_mem_nhds' h)\n\n"}
{"name":"extChartAt_source_mem_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ns : Set M\ninst✝ : ChartedSpace H M\nx : M\n⊢ Membership.mem (nhdsWithin x s) (extChartAt I x).source","decl":"theorem extChartAt_source_mem_nhdsWithin (x : M) : (extChartAt I x).source ∈ 𝓝[s] x :=\n  mem_nhdsWithin_of_mem_nhds (extChartAt_source_mem_nhds x)\n\n"}
{"name":"continuousOn_extChartAt","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ ContinuousOn (↑(extChartAt I x)) (extChartAt I x).source","decl":"theorem continuousOn_extChartAt (x : M) : ContinuousOn (extChartAt I x) (extChartAt I x).source :=\n  continuousOn_extend _\n\n"}
{"name":"continuousAt_extChartAt'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx x' : M\nh : Membership.mem (extChartAt I x).source x'\n⊢ ContinuousAt (↑(extChartAt I x)) x'","decl":"theorem continuousAt_extChartAt' {x x' : M} (h : x' ∈ (extChartAt I x).source) :\n    ContinuousAt (extChartAt I x) x' :=\n  continuousAt_extend _ <| by rwa [← extChartAt_source I]\n\n"}
{"name":"continuousAt_extChartAt","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ ContinuousAt (↑(extChartAt I x)) x","decl":"theorem continuousAt_extChartAt (x : M) : ContinuousAt (extChartAt I x) x :=\n  continuousAt_extChartAt' (mem_extChartAt_source x)\n\n"}
{"name":"map_extChartAt_nhds'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx y : M\nhy : Membership.mem (extChartAt I x).source y\n⊢ Eq (Filter.map (↑(extChartAt I x)) (nhds y)) (nhdsWithin (↑(extChartAt I x) y) (Set.range ↑I))","decl":"theorem map_extChartAt_nhds' {x y : M} (hy : y ∈ (extChartAt I x).source) :\n    map (extChartAt I x) (𝓝 y) = 𝓝[range I] extChartAt I x y :=\n  map_extend_nhds _ <| by rwa [← extChartAt_source I]\n\n"}
{"name":"map_extChartAt_nhds","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ Eq (Filter.map (↑(extChartAt I x)) (nhds x)) (nhdsWithin (↑(extChartAt I x) x) (Set.range ↑I))","decl":"theorem map_extChartAt_nhds (x : M) : map (extChartAt I x) (𝓝 x) = 𝓝[range I] extChartAt I x x :=\n  map_extChartAt_nhds' <| mem_extChartAt_source x\n\n"}
{"name":"map_extChartAt_nhds_of_boundaryless","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : TopologicalSpace H\ninst✝² : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝¹ : ChartedSpace H M\ninst✝ : I.Boundaryless\nx : M\n⊢ Eq (Filter.map (↑(extChartAt I x)) (nhds x)) (nhds (↑(extChartAt I x) x))","decl":"theorem map_extChartAt_nhds_of_boundaryless [I.Boundaryless] (x : M) :\n    map (extChartAt I x) (𝓝 x) = 𝓝 (extChartAt I x x) := by\n  rw [extChartAt]\n  exact map_extend_nhds_of_boundaryless (chartAt H x) (mem_chart_source H x)\n\n"}
{"name":"extChartAt_image_nhd_mem_nhds_of_mem_interior_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx y : M\nhx : Membership.mem (extChartAt I x).source y\nh'x : Membership.mem (interior (Set.range ↑I)) (↑(extChartAt I x) y)\ns : Set M\nh : Membership.mem (nhds y) s\n⊢ Membership.mem (nhds (↑(extChartAt I x) y)) (Set.image (↑(extChartAt I x)) s)","decl":"theorem extChartAt_image_nhd_mem_nhds_of_mem_interior_range {x y} (hx : y ∈ (extChartAt I x).source)\n    (h'x : extChartAt I x y ∈ interior (range I)) {s : Set M} (h : s ∈ 𝓝 y) :\n    (extChartAt I x) '' s ∈ 𝓝 (extChartAt I x y) := by\n  rw [extChartAt]\n  exact extend_image_nhd_mem_nhds_of_mem_interior_range _ (by simpa using hx) h'x h\n\n"}
{"name":"extChartAt_image_nhd_mem_nhds_of_boundaryless","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : TopologicalSpace H\ninst✝² : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ns : Set M\ninst✝¹ : ChartedSpace H M\ninst✝ : I.Boundaryless\nx : M\nhx : Membership.mem (nhds x) s\n⊢ Membership.mem (nhds (↑(extChartAt I x) x)) (Set.image (↑(extChartAt I x)) s)","decl":"variable {x} in\ntheorem extChartAt_image_nhd_mem_nhds_of_boundaryless [I.Boundaryless]\n    {x : M} (hx : s ∈ 𝓝 x) : extChartAt I x '' s ∈ 𝓝 (extChartAt I x x) := by\n  rw [extChartAt]\n  exact extend_image_nhd_mem_nhds_of_boundaryless _ (mem_chart_source H x) hx\n\n"}
{"name":"extChartAt_target_mem_nhdsWithin'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx y : M\nhy : Membership.mem (extChartAt I x).source y\n⊢ Membership.mem (nhdsWithin (↑(extChartAt I x) y) (Set.range ↑I)) (extChartAt I x).target","decl":"theorem extChartAt_target_mem_nhdsWithin' {x y : M} (hy : y ∈ (extChartAt I x).source) :\n    (extChartAt I x).target ∈ 𝓝[range I] extChartAt I x y :=\n  extend_target_mem_nhdsWithin _ <| by rwa [← extChartAt_source I]\n\n"}
{"name":"extChartAt_target_mem_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ Membership.mem (nhdsWithin (↑(extChartAt I x) x) (Set.range ↑I)) (extChartAt I x).target","decl":"theorem extChartAt_target_mem_nhdsWithin (x : M) :\n    (extChartAt I x).target ∈ 𝓝[range I] extChartAt I x x :=\n  extChartAt_target_mem_nhdsWithin' (mem_extChartAt_source x)\n\n"}
{"name":"extChartAt_target_mem_nhdsWithin_of_mem","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\ny : E\nhy : Membership.mem (extChartAt I x).target y\n⊢ Membership.mem (nhdsWithin y (Set.range ↑I)) (extChartAt I x).target","decl":"theorem extChartAt_target_mem_nhdsWithin_of_mem {x : M} {y : E} (hy : y ∈ (extChartAt I x).target) :\n    (extChartAt I x).target ∈ 𝓝[range I] y := by\n  rw [← (extChartAt I x).right_inv hy]\n  apply extChartAt_target_mem_nhdsWithin'\n  exact (extChartAt I x).map_target hy\n\n"}
{"name":"extChartAt_target_union_compl_range_mem_nhds_of_mem","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\ny : E\nx : M\nhy : Membership.mem (extChartAt I x).target y\n⊢ Membership.mem (nhds y) (Union.union (extChartAt I x).target (HasCompl.compl (Set.range ↑I)))","decl":"theorem extChartAt_target_union_compl_range_mem_nhds_of_mem {y : E} {x : M}\n    (hy : y ∈ (extChartAt I x).target) : (extChartAt I x).target ∪ (range I)ᶜ ∈ 𝓝 y := by\n  rw [← nhdsWithin_univ, ← union_compl_self (range I), nhdsWithin_union]\n  exact Filter.union_mem_sup (extChartAt_target_mem_nhdsWithin_of_mem hy) self_mem_nhdsWithin\n\n"}
{"name":"extChartAt_target_union_comp_range_mem_nhds_of_mem","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\ny : E\nx : M\nhy : Membership.mem (extChartAt I x).target y\n⊢ Membership.mem (nhds y) (Union.union (extChartAt I x).target (HasCompl.compl (Set.range ↑I)))","decl":"@[deprecated (since := \"2024-11-27\")] alias\nextChartAt_target_union_comp_range_mem_nhds_of_mem :=\nextChartAt_target_union_compl_range_mem_nhds_of_mem\n\n"}
{"name":"isOpen_extChartAt_target","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : TopologicalSpace H\ninst✝² : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝¹ : ChartedSpace H M\ninst✝ : I.Boundaryless\nx : M\n⊢ IsOpen (extChartAt I x).target","decl":"/-- If we're boundaryless, `extChartAt` has open target -/\ntheorem isOpen_extChartAt_target [I.Boundaryless] (x : M) : IsOpen (extChartAt I x).target := by\n  simp_rw [extChartAt_target, I.range_eq_univ, inter_univ]\n  exact (PartialHomeomorph.open_target _).preimage I.continuous_symm\n\n"}
{"name":"extChartAt_target_mem_nhds","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : TopologicalSpace H\ninst✝² : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝¹ : ChartedSpace H M\ninst✝ : I.Boundaryless\nx : M\n⊢ Membership.mem (nhds (↑(extChartAt I x) x)) (extChartAt I x).target","decl":"/-- If we're boundaryless, `(extChartAt I x).target` is a neighborhood of the key point -/\ntheorem extChartAt_target_mem_nhds [I.Boundaryless] (x : M) :\n    (extChartAt I x).target ∈ 𝓝 (extChartAt I x x) := by\n  convert extChartAt_target_mem_nhdsWithin x\n  simp only [I.range_eq_univ, nhdsWithin_univ]\n\n"}
{"name":"extChartAt_target_mem_nhds'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : TopologicalSpace H\ninst✝² : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝¹ : ChartedSpace H M\ninst✝ : I.Boundaryless\nx : M\ny : E\nm : Membership.mem (extChartAt I x).target y\n⊢ Membership.mem (nhds y) (extChartAt I x).target","decl":"/-- If we're boundaryless, `(extChartAt I x).target` is a neighborhood of any of its points -/\ntheorem extChartAt_target_mem_nhds' [I.Boundaryless] {x : M} {y : E}\n    (m : y ∈ (extChartAt I x).target) : (extChartAt I x).target ∈ 𝓝 y :=\n  (isOpen_extChartAt_target x).mem_nhds m\n\n"}
{"name":"extChartAt_target_subset_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ HasSubset.Subset (extChartAt I x).target (Set.range ↑I)","decl":"theorem extChartAt_target_subset_range (x : M) : (extChartAt I x).target ⊆ range I := by\n  simp only [mfld_simps]\n\n"}
{"name":"nhdsWithin_extChartAt_target_eq'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx y : M\nhy : Membership.mem (extChartAt I x).source y\n⊢ Eq (nhdsWithin (↑(extChartAt I x) y) (extChartAt I x).target) (nhdsWithin (↑(extChartAt I x) y) (Set.range ↑I))","decl":"/-- Around the image of a point in the source, the neighborhoods are the same\nwithin `(extChartAt I x).target` and within `range I`. -/\ntheorem nhdsWithin_extChartAt_target_eq' {x y : M} (hy : y ∈ (extChartAt I x).source) :\n    𝓝[(extChartAt I x).target] extChartAt I x y = 𝓝[range I] extChartAt I x y :=\n  nhdsWithin_extend_target_eq _ <| by rwa [← extChartAt_source I]\n\n"}
{"name":"nhdsWithin_extChartAt_target_eq_of_mem","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\nz : E\nhz : Membership.mem (extChartAt I x).target z\n⊢ Eq (nhdsWithin z (extChartAt I x).target) (nhdsWithin z (Set.range ↑I))","decl":"/-- Around a point in the target, the neighborhoods are the same within `(extChartAt I x).target`\nand within `range I`. -/\ntheorem nhdsWithin_extChartAt_target_eq_of_mem {x : M} {z : E} (hz : z ∈ (extChartAt I x).target) :\n    𝓝[(extChartAt I x).target] z = 𝓝[range I] z := by\n  rw [← PartialEquiv.right_inv (extChartAt I x) hz]\n  exact nhdsWithin_extChartAt_target_eq' ((extChartAt I x).map_target hz)\n\n"}
{"name":"nhdsWithin_extChartAt_target_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ Eq (nhdsWithin (↑(extChartAt I x) x) (extChartAt I x).target) (nhdsWithin (↑(extChartAt I x) x) (Set.range ↑I))","decl":"/-- Around the image of the base point, the neighborhoods are the same\nwithin `(extChartAt I x).target` and within `range I`. -/\ntheorem nhdsWithin_extChartAt_target_eq (x : M) :\n    𝓝[(extChartAt I x).target] (extChartAt I x) x = 𝓝[range I] (extChartAt I x) x :=\n  nhdsWithin_extChartAt_target_eq' (mem_extChartAt_source x)\n\n"}
{"name":"extChartAt_target_eventuallyEq'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx y : M\nhy : Membership.mem (extChartAt I x).source y\n⊢ (nhds (↑(extChartAt I x) y)).EventuallyEq (extChartAt I x).target (Set.range ↑I)","decl":"/-- Around the image of a point in the source, `(extChartAt I x).target` and `range I`\ncoincide locally. -/\ntheorem extChartAt_target_eventuallyEq' {x y : M} (hy : y ∈ (extChartAt I x).source) :\n    (extChartAt I x).target =ᶠ[𝓝 (extChartAt I x y)] range I :=\n  nhdsWithin_eq_iff_eventuallyEq.1 (nhdsWithin_extChartAt_target_eq' hy)\n\n"}
{"name":"extChartAt_target_eventuallyEq_of_mem","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\nz : E\nhz : Membership.mem (extChartAt I x).target z\n⊢ (nhds z).EventuallyEq (extChartAt I x).target (Set.range ↑I)","decl":"/-- Around a point in the target, `(extChartAt I x).target` and `range I` coincide locally. -/\ntheorem extChartAt_target_eventuallyEq_of_mem {x : M} {z : E} (hz : z ∈ (extChartAt I x).target) :\n    (extChartAt I x).target =ᶠ[𝓝 z] range I :=\n  nhdsWithin_eq_iff_eventuallyEq.1 (nhdsWithin_extChartAt_target_eq_of_mem hz)\n\n"}
{"name":"extChartAt_target_eventuallyEq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ (nhds (↑(extChartAt I x) x)).EventuallyEq (extChartAt I x).target (Set.range ↑I)","decl":"/-- Around the image of the base point, `(extChartAt I x).target` and `range I` coincide locally. -/\ntheorem extChartAt_target_eventuallyEq {x : M} :\n    (extChartAt I x).target =ᶠ[𝓝 (extChartAt I x x)] range I :=\n  nhdsWithin_eq_iff_eventuallyEq.1 (nhdsWithin_extChartAt_target_eq x)\n\n"}
{"name":"continuousAt_extChartAt_symm''","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\ny : E\nh : Membership.mem (extChartAt I x).target y\n⊢ ContinuousAt (↑(extChartAt I x).symm) y","decl":"theorem continuousAt_extChartAt_symm'' {x : M} {y : E} (h : y ∈ (extChartAt I x).target) :\n    ContinuousAt (extChartAt I x).symm y :=\n  continuousAt_extend_symm' _ h\n\n"}
{"name":"continuousAt_extChartAt_symm'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx x' : M\nh : Membership.mem (extChartAt I x).source x'\n⊢ ContinuousAt (↑(extChartAt I x).symm) (↑(extChartAt I x) x')","decl":"theorem continuousAt_extChartAt_symm' {x x' : M} (h : x' ∈ (extChartAt I x).source) :\n    ContinuousAt (extChartAt I x).symm (extChartAt I x x') :=\n  continuousAt_extChartAt_symm'' <| (extChartAt I x).map_source h\n\n"}
{"name":"continuousAt_extChartAt_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ ContinuousAt (↑(extChartAt I x).symm) (↑(extChartAt I x) x)","decl":"theorem continuousAt_extChartAt_symm (x : M) :\n    ContinuousAt (extChartAt I x).symm ((extChartAt I x) x) :=\n  continuousAt_extChartAt_symm' (mem_extChartAt_source x)\n\n"}
{"name":"continuousOn_extChartAt_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ ContinuousOn (↑(extChartAt I x).symm) (extChartAt I x).target","decl":"theorem continuousOn_extChartAt_symm (x : M) :\n    ContinuousOn (extChartAt I x).symm (extChartAt I x).target :=\n  fun _y hy => (continuousAt_extChartAt_symm'' hy).continuousWithinAt\n\n"}
{"name":"extChartAt_target_subset_closure_interior","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ HasSubset.Subset (extChartAt I x).target (closure (interior (extChartAt I x).target))","decl":"lemma extChartAt_target_subset_closure_interior {x : M} :\n    (extChartAt I x).target ⊆ closure (interior (extChartAt I x).target) := by\n  intro y hy\n  rw [mem_closure_iff_nhds]\n  intro t ht\n  have A : t ∩ ((extChartAt I x).target ∪ (range I)ᶜ) ∈ 𝓝 y :=\n    inter_mem ht (extChartAt_target_union_compl_range_mem_nhds_of_mem hy)\n  have B : y ∈ closure (interior (range I)) := by\n    apply I.range_subset_closure_interior (extChartAt_target_subset_range x hy)\n  obtain ⟨z, ⟨tz, h'z⟩, hz⟩ :\n      (t ∩ ((extChartAt I x).target ∪ (range ↑I)ᶜ) ∩ interior (range I)).Nonempty :=\n    mem_closure_iff_nhds.1 B _ A\n  refine ⟨z, ⟨tz, ?_⟩⟩\n  have h''z : z ∈ (extChartAt I x).target := by simpa [interior_subset hz] using h'z\n  exact (extChartAt_target_eventuallyEq_of_mem h''z).symm.mem_interior hz\n\n"}
{"name":"interior_extChartAt_target_nonempty","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ (interior (extChartAt I x).target).Nonempty","decl":"variable (I) in\ntheorem interior_extChartAt_target_nonempty (x : M) :\n    (interior (extChartAt I x).target).Nonempty := by\n  by_contra! H\n  have := extChartAt_target_subset_closure_interior (mem_extChartAt_target (I := I) x)\n  simp only [H, closure_empty, mem_empty_iff_false] at this\n\n"}
{"name":"extChartAt_mem_closure_interior","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ns : Set M\ninst✝ : ChartedSpace H M\nx₀ x : M\nhx : Membership.mem (closure (interior s)) x\nh'x : Membership.mem (extChartAt I x₀).source x\n⊢ Membership.mem (closure (interior (Inter.inter (Set.preimage (↑(extChartAt I x₀).symm) s) (extChartAt I x₀).target))) (↑(extChartAt I x₀) x)","decl":"lemma extChartAt_mem_closure_interior {x₀ x : M}\n    (hx : x ∈ closure (interior s)) (h'x : x ∈ (extChartAt I x₀).source) :\n    extChartAt I x₀ x ∈\n      closure (interior ((extChartAt I x₀).symm ⁻¹' s ∩ (extChartAt I x₀).target)) := by\n  simp_rw [mem_closure_iff, interior_inter, ← inter_assoc]\n  intro o o_open ho\n  obtain ⟨y, ⟨yo, hy⟩, ys⟩ :\n      ((extChartAt I x₀) ⁻¹' o ∩ (extChartAt I x₀).source ∩ interior s).Nonempty := by\n    have : (extChartAt I x₀) ⁻¹' o ∈ 𝓝 x := by\n      apply (continuousAt_extChartAt' h'x).preimage_mem_nhds (o_open.mem_nhds ho)\n    refine (mem_closure_iff_nhds.1 hx) _ (inter_mem this ?_)\n    apply (isOpen_extChartAt_source x₀).mem_nhds h'x\n  have A : interior (↑(extChartAt I x₀).symm ⁻¹' s) ∈ 𝓝 (extChartAt I x₀ y) := by\n    simp only [interior_mem_nhds]\n    apply (continuousAt_extChartAt_symm' hy).preimage_mem_nhds\n    simp only [hy, PartialEquiv.left_inv]\n    exact mem_interior_iff_mem_nhds.mp ys\n  have B : (extChartAt I x₀) y ∈ closure (interior (extChartAt I x₀).target) := by\n    apply extChartAt_target_subset_closure_interior (x := x₀)\n    exact (extChartAt I x₀).map_source hy\n  exact mem_closure_iff_nhds.1 B _ (inter_mem (o_open.mem_nhds yo) A)\n\n"}
{"name":"isOpen_extChartAt_preimage'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\ns : Set E\nhs : IsOpen s\n⊢ IsOpen (Inter.inter (extChartAt I x).source (Set.preimage (↑(extChartAt I x)) s))","decl":"theorem isOpen_extChartAt_preimage' (x : M) {s : Set E} (hs : IsOpen s) :\n    IsOpen ((extChartAt I x).source ∩ extChartAt I x ⁻¹' s) :=\n  isOpen_extend_preimage' _ hs\n\n"}
{"name":"isOpen_extChartAt_preimage","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\ns : Set E\nhs : IsOpen s\n⊢ IsOpen (Inter.inter (chartAt H x).source (Set.preimage (↑(extChartAt I x)) s))","decl":"theorem isOpen_extChartAt_preimage (x : M) {s : Set E} (hs : IsOpen s) :\n    IsOpen ((chartAt H x).source ∩ extChartAt I x ⁻¹' s) := by\n  rw [← extChartAt_source I]\n  exact isOpen_extChartAt_preimage' x hs\n\n"}
{"name":"map_extChartAt_nhdsWithin_eq_image'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ns : Set M\ninst✝ : ChartedSpace H M\nx y : M\nhy : Membership.mem (extChartAt I x).source y\n⊢ Eq (Filter.map (↑(extChartAt I x)) (nhdsWithin y s)) (nhdsWithin (↑(extChartAt I x) y) (Set.image (↑(extChartAt I x)) (Inter.inter (extChartAt I x).source s)))","decl":"theorem map_extChartAt_nhdsWithin_eq_image' {x y : M} (hy : y ∈ (extChartAt I x).source) :\n    map (extChartAt I x) (𝓝[s] y) =\n      𝓝[extChartAt I x '' ((extChartAt I x).source ∩ s)] extChartAt I x y :=\n  map_extend_nhdsWithin_eq_image _ <| by rwa [← extChartAt_source I]\n\n"}
{"name":"map_extChartAt_nhdsWithin_eq_image","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ns : Set M\ninst✝ : ChartedSpace H M\nx : M\n⊢ Eq (Filter.map (↑(extChartAt I x)) (nhdsWithin x s)) (nhdsWithin (↑(extChartAt I x) x) (Set.image (↑(extChartAt I x)) (Inter.inter (extChartAt I x).source s)))","decl":"theorem map_extChartAt_nhdsWithin_eq_image (x : M) :\n    map (extChartAt I x) (𝓝[s] x) =\n      𝓝[extChartAt I x '' ((extChartAt I x).source ∩ s)] extChartAt I x x :=\n  map_extChartAt_nhdsWithin_eq_image' (mem_extChartAt_source x)\n\n"}
{"name":"map_extChartAt_nhdsWithin'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ns : Set M\ninst✝ : ChartedSpace H M\nx y : M\nhy : Membership.mem (extChartAt I x).source y\n⊢ Eq (Filter.map (↑(extChartAt I x)) (nhdsWithin y s)) (nhdsWithin (↑(extChartAt I x) y) (Inter.inter (Set.preimage (↑(extChartAt I x).symm) s) (Set.range ↑I)))","decl":"theorem map_extChartAt_nhdsWithin' {x y : M} (hy : y ∈ (extChartAt I x).source) :\n    map (extChartAt I x) (𝓝[s] y) = 𝓝[(extChartAt I x).symm ⁻¹' s ∩ range I] extChartAt I x y :=\n  map_extend_nhdsWithin _ <| by rwa [← extChartAt_source I]\n\n"}
{"name":"map_extChartAt_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ns : Set M\ninst✝ : ChartedSpace H M\nx : M\n⊢ Eq (Filter.map (↑(extChartAt I x)) (nhdsWithin x s)) (nhdsWithin (↑(extChartAt I x) x) (Inter.inter (Set.preimage (↑(extChartAt I x).symm) s) (Set.range ↑I)))","decl":"theorem map_extChartAt_nhdsWithin (x : M) :\n    map (extChartAt I x) (𝓝[s] x) = 𝓝[(extChartAt I x).symm ⁻¹' s ∩ range I] extChartAt I x x :=\n  map_extChartAt_nhdsWithin' (mem_extChartAt_source x)\n\n"}
{"name":"map_extChartAt_symm_nhdsWithin'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ns : Set M\ninst✝ : ChartedSpace H M\nx y : M\nhy : Membership.mem (extChartAt I x).source y\n⊢ Eq (Filter.map (↑(extChartAt I x).symm) (nhdsWithin (↑(extChartAt I x) y) (Inter.inter (Set.preimage (↑(extChartAt I x).symm) s) (Set.range ↑I)))) (nhdsWithin y s)","decl":"theorem map_extChartAt_symm_nhdsWithin' {x y : M} (hy : y ∈ (extChartAt I x).source) :\n    map (extChartAt I x).symm (𝓝[(extChartAt I x).symm ⁻¹' s ∩ range I] extChartAt I x y) =\n      𝓝[s] y :=\n  map_extend_symm_nhdsWithin _ <| by rwa [← extChartAt_source I]\n\n"}
{"name":"map_extChartAt_symm_nhdsWithin_range'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx y : M\nhy : Membership.mem (extChartAt I x).source y\n⊢ Eq (Filter.map (↑(extChartAt I x).symm) (nhdsWithin (↑(extChartAt I x) y) (Set.range ↑I))) (nhds y)","decl":"theorem map_extChartAt_symm_nhdsWithin_range' {x y : M} (hy : y ∈ (extChartAt I x).source) :\n    map (extChartAt I x).symm (𝓝[range I] extChartAt I x y) = 𝓝 y :=\n  map_extend_symm_nhdsWithin_range _ <| by rwa [← extChartAt_source I]\n\n"}
{"name":"map_extChartAt_symm_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ns : Set M\ninst✝ : ChartedSpace H M\nx : M\n⊢ Eq (Filter.map (↑(extChartAt I x).symm) (nhdsWithin (↑(extChartAt I x) x) (Inter.inter (Set.preimage (↑(extChartAt I x).symm) s) (Set.range ↑I)))) (nhdsWithin x s)","decl":"theorem map_extChartAt_symm_nhdsWithin (x : M) :\n    map (extChartAt I x).symm (𝓝[(extChartAt I x).symm ⁻¹' s ∩ range I] extChartAt I x x) =\n      𝓝[s] x :=\n  map_extChartAt_symm_nhdsWithin' (mem_extChartAt_source x)\n\n"}
{"name":"map_extChartAt_symm_nhdsWithin_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\n⊢ Eq (Filter.map (↑(extChartAt I x).symm) (nhdsWithin (↑(extChartAt I x) x) (Set.range ↑I))) (nhds x)","decl":"theorem map_extChartAt_symm_nhdsWithin_range (x : M) :\n    map (extChartAt I x).symm (𝓝[range I] extChartAt I x x) = 𝓝 x :=\n  map_extChartAt_symm_nhdsWithin_range' (mem_extChartAt_source x)\n\n"}
{"name":"extChartAt_preimage_mem_nhdsWithin'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ns t : Set M\ninst✝ : ChartedSpace H M\nx x' : M\nh : Membership.mem (extChartAt I x).source x'\nht : Membership.mem (nhdsWithin x' s) t\n⊢ Membership.mem (nhdsWithin (↑(extChartAt I x) x') (Inter.inter (Set.preimage (↑(extChartAt I x).symm) s) (Set.range ↑I))) (Set.preimage (↑(extChartAt I x).symm) t)","decl":"/-- Technical lemma ensuring that the preimage under an extended chart of a neighborhood of a point\nin the source is a neighborhood of the preimage, within a set. -/\ntheorem extChartAt_preimage_mem_nhdsWithin' {x x' : M} (h : x' ∈ (extChartAt I x).source)\n    (ht : t ∈ 𝓝[s] x') :\n    (extChartAt I x).symm ⁻¹' t ∈ 𝓝[(extChartAt I x).symm ⁻¹' s ∩ range I] (extChartAt I x) x' := by\n  rwa [← map_extChartAt_symm_nhdsWithin' h, mem_map] at ht\n\n"}
{"name":"extChartAt_preimage_mem_nhdsWithin","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ns t : Set M\ninst✝ : ChartedSpace H M\nx : M\nht : Membership.mem (nhdsWithin x s) t\n⊢ Membership.mem (nhdsWithin (↑(extChartAt I x) x) (Inter.inter (Set.preimage (↑(extChartAt I x).symm) s) (Set.range ↑I))) (Set.preimage (↑(extChartAt I x).symm) t)","decl":"/-- Technical lemma ensuring that the preimage under an extended chart of a neighborhood of the\nbase point is a neighborhood of the preimage, within a set. -/\ntheorem extChartAt_preimage_mem_nhdsWithin {x : M} (ht : t ∈ 𝓝[s] x) :\n    (extChartAt I x).symm ⁻¹' t ∈ 𝓝[(extChartAt I x).symm ⁻¹' s ∩ range I] (extChartAt I x) x :=\n  extChartAt_preimage_mem_nhdsWithin' (mem_extChartAt_source x) ht\n\n"}
{"name":"extChartAt_preimage_mem_nhds'","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\nt : Set M\ninst✝ : ChartedSpace H M\nx x' : M\nh : Membership.mem (extChartAt I x).source x'\nht : Membership.mem (nhds x') t\n⊢ Membership.mem (nhds (↑(extChartAt I x) x')) (Set.preimage (↑(extChartAt I x).symm) t)","decl":"theorem extChartAt_preimage_mem_nhds' {x x' : M} (h : x' ∈ (extChartAt I x).source)\n    (ht : t ∈ 𝓝 x') : (extChartAt I x).symm ⁻¹' t ∈ 𝓝 (extChartAt I x x') :=\n  extend_preimage_mem_nhds _ (by rwa [← extChartAt_source I]) ht\n\n"}
{"name":"extChartAt_preimage_mem_nhds","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\nt : Set M\ninst✝ : ChartedSpace H M\nx : M\nht : Membership.mem (nhds x) t\n⊢ Membership.mem (nhds (↑(extChartAt I x) x)) (Set.preimage (↑(extChartAt I x).symm) t)","decl":"/-- Technical lemma ensuring that the preimage under an extended chart of a neighborhood of a point\nis a neighborhood of the preimage. -/\ntheorem extChartAt_preimage_mem_nhds {x : M} (ht : t ∈ 𝓝 x) :\n    (extChartAt I x).symm ⁻¹' t ∈ 𝓝 ((extChartAt I x) x) := by\n  apply (continuousAt_extChartAt_symm x).preimage_mem_nhds\n  rwa [(extChartAt I x).left_inv (mem_extChartAt_source _)]\n\n"}
{"name":"extChartAt_preimage_inter_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ns t : Set M\ninst✝ : ChartedSpace H M\nx : M\n⊢ Eq (Inter.inter (Set.preimage (↑(extChartAt I x).symm) (Inter.inter s t)) (Set.range ↑I)) (Inter.inter (Inter.inter (Set.preimage (↑(extChartAt I x).symm) s) (Set.range ↑I)) (Set.preimage (↑(extChartAt I x).symm) t))","decl":"/-- Technical lemma to rewrite suitably the preimage of an intersection under an extended chart, to\nbring it into a convenient form to apply derivative lemmas. -/\ntheorem extChartAt_preimage_inter_eq (x : M) :\n    (extChartAt I x).symm ⁻¹' (s ∩ t) ∩ range I =\n      (extChartAt I x).symm ⁻¹' s ∩ range I ∩ (extChartAt I x).symm ⁻¹' t := by\n  mfld_set_tac\n\n"}
{"name":"ContinuousWithinAt.nhdsWithin_extChartAt_symm_preimage_inter_range","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\nE' : Type u_5\nM' : Type u_6\nH' : Type u_7\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : TopologicalSpace H\ninst✝⁶ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝⁵ : NormedAddCommGroup E'\ninst✝⁴ : NormedSpace 𝕜 E'\ninst✝³ : TopologicalSpace H'\ninst✝² : TopologicalSpace M'\nI' : ModelWithCorners 𝕜 E' H'\ns : Set M\ninst✝¹ : ChartedSpace H M\ninst✝ : ChartedSpace H' M'\nf : M → M'\nx : M\nhc : ContinuousWithinAt f s x\n⊢ Eq (nhdsWithin (↑(extChartAt I x) x) (Inter.inter (Set.preimage (↑(extChartAt I x).symm) s) (Set.range ↑I))) (nhdsWithin (↑(extChartAt I x) x) (Inter.inter (extChartAt I x).target (Set.preimage (↑(extChartAt I x).symm) (Inter.inter s (Set.preimage f (extChartAt I' (f x)).source)))))","decl":"theorem ContinuousWithinAt.nhdsWithin_extChartAt_symm_preimage_inter_range\n    {f : M → M'} {x : M} (hc : ContinuousWithinAt f s x) :\n    𝓝[(extChartAt I x).symm ⁻¹' s ∩ range I] (extChartAt I x x) =\n      𝓝[(extChartAt I x).target ∩\n        (extChartAt I x).symm ⁻¹' (s ∩ f ⁻¹' (extChartAt I' (f x)).source)] (extChartAt I x x) := by\n  rw [← (extChartAt I x).image_source_inter_eq', ← map_extChartAt_nhdsWithin_eq_image,\n    ← map_extChartAt_nhdsWithin, nhdsWithin_inter_of_mem']\n  exact hc (extChartAt_source_mem_nhds _)\n\n"}
{"name":"ContinuousWithinAt.extChartAt_symm_preimage_inter_range_eventuallyEq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\nE' : Type u_5\nM' : Type u_6\nH' : Type u_7\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : TopologicalSpace H\ninst✝⁶ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝⁵ : NormedAddCommGroup E'\ninst✝⁴ : NormedSpace 𝕜 E'\ninst✝³ : TopologicalSpace H'\ninst✝² : TopologicalSpace M'\nI' : ModelWithCorners 𝕜 E' H'\ns : Set M\ninst✝¹ : ChartedSpace H M\ninst✝ : ChartedSpace H' M'\nf : M → M'\nx : M\nhc : ContinuousWithinAt f s x\n⊢ (nhds (↑(extChartAt I x) x)).EventuallyEq (Inter.inter (Set.preimage (↑(extChartAt I x).symm) s) (Set.range ↑I)) (Inter.inter (extChartAt I x).target (Set.preimage (↑(extChartAt I x).symm) (Inter.inter s (Set.preimage f (extChartAt I' (f x)).source))))","decl":"theorem ContinuousWithinAt.extChartAt_symm_preimage_inter_range_eventuallyEq\n    {f : M → M'} {x : M} (hc : ContinuousWithinAt f s x) :\n    ((extChartAt I x).symm ⁻¹' s ∩ range I : Set E) =ᶠ[𝓝 (extChartAt I x x)]\n      ((extChartAt I x).target ∩\n        (extChartAt I x).symm ⁻¹' (s ∩ f ⁻¹' (extChartAt I' (f x)).source) : Set E) := by\n  rw [← nhdsWithin_eq_iff_eventuallyEq]\n  exact hc.nhdsWithin_extChartAt_symm_preimage_inter_range\n\n"}
{"name":"ext_coord_change_source","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx x' : M\n⊢ Eq ((extChartAt I x').symm.trans (extChartAt I x)).source (Set.image (↑I) ((chartAt H x').symm.trans (chartAt H x)).source)","decl":"theorem ext_coord_change_source (x x' : M) :\n    ((extChartAt I x').symm ≫ extChartAt I x).source =\n      I '' ((chartAt H x').symm ≫ₕ chartAt H x).source :=\n  extend_coord_change_source _ _\n\n"}
{"name":"contDiffOn_ext_coord_change","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : TopologicalSpace H\ninst✝² : TopologicalSpace M\nn : WithTop ENat\nI : ModelWithCorners 𝕜 E H\ninst✝¹ : ChartedSpace H M\ninst✝ : IsManifold I n M\nx x' : M\n⊢ ContDiffOn 𝕜 n (Function.comp ↑(extChartAt I x) ↑(extChartAt I x').symm) ((extChartAt I x').symm.trans (extChartAt I x)).source","decl":"theorem contDiffOn_ext_coord_change [IsManifold I n M] (x x' : M) :\n    ContDiffOn 𝕜 n (extChartAt I x ∘ (extChartAt I x').symm)\n      ((extChartAt I x').symm ≫ extChartAt I x).source :=\n  contDiffOn_extend_coord_change (chart_mem_maximalAtlas x) (chart_mem_maximalAtlas x')\n\n"}
{"name":"contDiffWithinAt_ext_coord_change","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : TopologicalSpace H\ninst✝² : TopologicalSpace M\nn : WithTop ENat\nI : ModelWithCorners 𝕜 E H\ninst✝¹ : ChartedSpace H M\ninst✝ : IsManifold I n M\nx x' : M\ny : E\nhy : Membership.mem ((extChartAt I x').symm.trans (extChartAt I x)).source y\n⊢ ContDiffWithinAt 𝕜 n (Function.comp ↑(extChartAt I x) ↑(extChartAt I x').symm) (Set.range ↑I) y","decl":"theorem contDiffWithinAt_ext_coord_change [IsManifold I n M] (x x' : M) {y : E}\n    (hy : y ∈ ((extChartAt I x').symm ≫ extChartAt I x).source) :\n    ContDiffWithinAt 𝕜 n (extChartAt I x ∘ (extChartAt I x').symm) (range I) y :=\n  contDiffWithinAt_extend_coord_change (chart_mem_maximalAtlas x) (chart_mem_maximalAtlas x') hy\n\n"}
{"name":"writtenInExtChartAt_chartAt","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\ny : E\nh : Membership.mem (extChartAt I x).target y\n⊢ Eq (writtenInExtChartAt I I x (↑(chartAt H x)) y) y","decl":"theorem writtenInExtChartAt_chartAt {x : M} {y : E} (h : y ∈ (extChartAt I x).target) :\n    writtenInExtChartAt I I x (chartAt H x) y = y := by simp_all only [mfld_simps]\n\n"}
{"name":"writtenInExtChartAt_chartAt_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\ny : E\nh : Membership.mem (extChartAt I x).target y\n⊢ Eq (writtenInExtChartAt I I (↑(chartAt H x) x) (↑(chartAt H x).symm) y) y","decl":"theorem writtenInExtChartAt_chartAt_symm {x : M} {y : E} (h : y ∈ (extChartAt I x).target) :\n    writtenInExtChartAt I I (chartAt H x x) (chartAt H x).symm y = y := by\n  simp_all only [mfld_simps]\n\n"}
{"name":"writtenInExtChartAt_extChartAt","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\ny : E\nh : Membership.mem (extChartAt I x).target y\n⊢ Eq (writtenInExtChartAt I (modelWithCornersSelf 𝕜 E) x (↑(extChartAt I x)) y) y","decl":"theorem writtenInExtChartAt_extChartAt {x : M} {y : E} (h : y ∈ (extChartAt I x).target) :\n    writtenInExtChartAt I 𝓘(𝕜, E) x (extChartAt I x) y = y := by\n  simp_all only [mfld_simps]\n\n"}
{"name":"writtenInExtChartAt_extChartAt_symm","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : TopologicalSpace H\ninst✝¹ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝ : ChartedSpace H M\nx : M\ny : E\nh : Membership.mem (extChartAt I x).target y\n⊢ Eq (writtenInExtChartAt (modelWithCornersSelf 𝕜 E) I (↑(extChartAt I x) x) (↑(extChartAt I x).symm) y) y","decl":"theorem writtenInExtChartAt_extChartAt_symm {x : M} {y : E} (h : y ∈ (extChartAt I x).target) :\n    writtenInExtChartAt 𝓘(𝕜, E) I (extChartAt I x x) (extChartAt I x).symm y = y := by\n  simp_all only [mfld_simps]\n\n"}
{"name":"extChartAt_self_eq","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nH : Type u_4\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nx : H\n⊢ Eq ↑(extChartAt I x) ↑I","decl":"theorem extChartAt_self_eq {x : H} : ⇑(extChartAt I x) = I :=\n  rfl\n\n"}
{"name":"extChartAt_self_apply","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nH : Type u_4\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nx y : H\n⊢ Eq (↑(extChartAt I x) y) (↑I y)","decl":"theorem extChartAt_self_apply {x y : H} : extChartAt I x y = I y :=\n  rfl\n\n"}
{"name":"extChartAt_model_space_eq_id","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\n⊢ Eq (extChartAt (modelWithCornersSelf 𝕜 E) x) (PartialEquiv.refl E)","decl":"/-- In the case of the manifold structure on a vector space, the extended charts are just the\nidentity. -/\ntheorem extChartAt_model_space_eq_id (x : E) : extChartAt 𝓘(𝕜, E) x = PartialEquiv.refl E := by\n  simp only [mfld_simps]\n\n"}
{"name":"ext_chart_model_space_apply","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx y : E\n⊢ Eq (↑(extChartAt (modelWithCornersSelf 𝕜 E) x) y) y","decl":"theorem ext_chart_model_space_apply {x y : E} : extChartAt 𝓘(𝕜, E) x y = y :=\n  rfl\n\n"}
{"name":"extChartAt_prod","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nM : Type u_3\nH : Type u_4\nE' : Type u_5\nM' : Type u_6\nH' : Type u_7\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\ninst✝⁷ : TopologicalSpace H\ninst✝⁶ : TopologicalSpace M\nI : ModelWithCorners 𝕜 E H\ninst✝⁵ : NormedAddCommGroup E'\ninst✝⁴ : NormedSpace 𝕜 E'\ninst✝³ : TopologicalSpace H'\ninst✝² : TopologicalSpace M'\nI' : ModelWithCorners 𝕜 E' H'\ninst✝¹ : ChartedSpace H M\ninst✝ : ChartedSpace H' M'\nx : Prod M M'\n⊢ Eq (extChartAt (I.prod I') x) ((extChartAt I x.1).prod (extChartAt I' x.2))","decl":"theorem extChartAt_prod (x : M × M') :\n    extChartAt (I.prod I') x = (extChartAt I x.1).prod (extChartAt I' x.2) := by\n  simp only [mfld_simps]\n  -- Porting note: `simp` can't use `PartialEquiv.prod_trans` here because of a type\n  -- synonym\n  rw [PartialEquiv.prod_trans]\n\n"}
{"name":"extChartAt_comp","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nH : Type u_4\nM' : Type u_6\nH' : Type u_7\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\ninst✝³ : TopologicalSpace H'\ninst✝² : TopologicalSpace M'\ninst✝¹ : ChartedSpace H' M'\ninst✝ : ChartedSpace H H'\nx : M'\n⊢ Eq (extChartAt I x) ((chartAt H' x).trans (extChartAt I (↑(chartAt H' x) x)))","decl":"theorem extChartAt_comp [ChartedSpace H H'] (x : M') :\n    (letI := ChartedSpace.comp H H' M'; extChartAt I x) =\n      (chartAt H' x).toPartialEquiv ≫ extChartAt I (chartAt H' x x) :=\n  PartialEquiv.trans_assoc ..\n\n"}
{"name":"writtenInExtChartAt_chartAt_comp","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nH : Type u_4\nM' : Type u_6\nH' : Type u_7\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\ninst✝³ : TopologicalSpace H'\ninst✝² : TopologicalSpace M'\ninst✝¹ : ChartedSpace H' M'\ninst✝ : ChartedSpace H H'\nx : M'\ny : E\nhy : Membership.mem (extChartAt I x).target y\n⊢ Eq (writtenInExtChartAt I I x (↑(chartAt H' x)) y) y","decl":"theorem writtenInExtChartAt_chartAt_comp [ChartedSpace H H'] (x : M') {y}\n    (hy : y ∈ letI := ChartedSpace.comp H H' M'; (extChartAt I x).target) :\n    (letI := ChartedSpace.comp H H' M'; writtenInExtChartAt I I x (chartAt H' x) y) = y := by\n  letI := ChartedSpace.comp H H' M'\n  simp_all only [mfld_simps, chartAt_comp]\n\n"}
{"name":"writtenInExtChartAt_chartAt_symm_comp","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nH : Type u_4\nM' : Type u_6\nH' : Type u_7\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\ninst✝³ : TopologicalSpace H'\ninst✝² : TopologicalSpace M'\ninst✝¹ : ChartedSpace H' M'\ninst✝ : ChartedSpace H H'\nx : M'\ny : E\nhy : Membership.mem (extChartAt I x).target y\n⊢ Eq (writtenInExtChartAt I I (↑(chartAt H' x) x) (↑(chartAt H' x).symm) y) y","decl":"theorem writtenInExtChartAt_chartAt_symm_comp [ChartedSpace H H'] (x : M') {y}\n    (hy : y ∈ letI := ChartedSpace.comp H H' M'; (extChartAt I x).target) :\n    ( letI := ChartedSpace.comp H H' M'\n      writtenInExtChartAt I I (chartAt H' x x) (chartAt H' x).symm y) = y := by\n  letI := ChartedSpace.comp H H' M'\n  simp_all only [mfld_simps, chartAt_comp]\n\n"}
{"name":"Manifold.locallyCompact_of_finiteDimensional","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"E : Type u_1\n𝕜 : Type u_2\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁴ : TopologicalSpace H\nM : Type u_4\ninst✝³ : TopologicalSpace M\ninst✝² : ChartedSpace H M\nI : ModelWithCorners 𝕜 E H\ninst✝¹ : LocallyCompactSpace 𝕜\ninst✝ : FiniteDimensional 𝕜 E\n⊢ LocallyCompactSpace M","decl":"/-- A finite-dimensional manifold modelled on a locally compact field\n  (such as ℝ, ℂ or the `p`-adic numbers) is locally compact. -/\nlemma Manifold.locallyCompact_of_finiteDimensional\n    (I : ModelWithCorners 𝕜 E H) [LocallyCompactSpace 𝕜] [FiniteDimensional 𝕜 E] :\n    LocallyCompactSpace M := by\n  have : ProperSpace E := FiniteDimensional.proper 𝕜 E\n  have : LocallyCompactSpace H := I.locallyCompactSpace\n  exact ChartedSpace.locallyCompactSpace H M\n\n"}
{"name":"LocallyCompactSpace.of_locallyCompact_manifold","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"E : Type u_1\n𝕜 : Type u_2\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝³ : TopologicalSpace H\nM : Type u_4\ninst✝² : TopologicalSpace M\ninst✝¹ : ChartedSpace H M\nI : ModelWithCorners 𝕜 E H\nh : Nonempty M\ninst✝ : LocallyCompactSpace M\n⊢ LocallyCompactSpace E","decl":"/-- A locally compact manifold must be modelled on a locally compact space. -/\nlemma LocallyCompactSpace.of_locallyCompact_manifold (I : ModelWithCorners 𝕜 E H)\n    [h : Nonempty M] [LocallyCompactSpace M] :\n    LocallyCompactSpace E := by\n  rcases h with ⟨x⟩\n  obtain ⟨y, hy⟩ := interior_extChartAt_target_nonempty I x\n  have h'y : y ∈ (extChartAt I x).target := interior_subset hy\n  obtain ⟨s, hmem, hss, hcom⟩ :=\n    LocallyCompactSpace.local_compact_nhds ((extChartAt I x).symm y) (extChartAt I x).source\n      ((isOpen_extChartAt_source x).mem_nhds ((extChartAt I x).map_target h'y))\n  have : IsCompact <| (extChartAt I x) '' s :=\n    hcom.image_of_continuousOn <| (continuousOn_extChartAt x).mono hss\n  apply this.locallyCompactSpace_of_mem_nhds_of_addGroup (x := y)\n  rw [← (extChartAt I x).right_inv h'y]\n  apply extChartAt_image_nhd_mem_nhds_of_mem_interior_range\n    (PartialEquiv.map_target (extChartAt I x) h'y) _ hmem\n  simp only [(extChartAt I x).right_inv h'y]\n  exact interior_mono (extChartAt_target_subset_range x) hy\n\n"}
{"name":"FiniteDimensional.of_locallyCompact_manifold","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"E : Type u_1\n𝕜 : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁵ : TopologicalSpace H\nM : Type u_4\ninst✝⁴ : TopologicalSpace M\ninst✝³ : ChartedSpace H M\ninst✝² : CompleteSpace 𝕜\nI : ModelWithCorners 𝕜 E H\ninst✝¹ : Nonempty M\ninst✝ : LocallyCompactSpace M\n⊢ FiniteDimensional 𝕜 E","decl":"/-- Riesz's theorem applied to manifolds: a locally compact manifolds must be modelled on a\n  finite-dimensional space. This is the converse to\n  `Manifold.locallyCompact_of_finiteDimensional`. -/\ntheorem FiniteDimensional.of_locallyCompact_manifold\n    [CompleteSpace 𝕜] (I : ModelWithCorners 𝕜 E H) [Nonempty M] [LocallyCompactSpace M] :\n    FiniteDimensional 𝕜 E := by\n  have := LocallyCompactSpace.of_locallyCompact_manifold M I\n  exact FiniteDimensional.of_locallyCompactSpace 𝕜\n\n"}
{"name":"instTopologicalAddGroupTangentSpace","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nx : M\n⊢ TopologicalAddGroup (TangentSpace I x)","decl":"instance : TopologicalAddGroup (TangentSpace I x) := inferInstanceAs (TopologicalAddGroup E)\n"}
{"name":"instPathConnectedSpaceTangentSpaceReal","module":"Mathlib.Geometry.Manifold.IsManifold.Basic","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\nH : Type u_2\ninst✝² : TopologicalSpace H\nI : ModelWithCorners Real E H\nM : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nx : M\n⊢ PathConnectedSpace (TangentSpace I x)","decl":"instance : PathConnectedSpace (TangentSpace I x) := inferInstanceAs (PathConnectedSpace E)\n\n"}
