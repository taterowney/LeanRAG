{"name":"CategoryTheory.Functor.RightExtension.mk_right_as","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝² : CategoryTheory.Category.{u_6, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_7, u_3} H\ninst✝ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\n⊢ Eq (CategoryTheory.Functor.RightExtension.mk F' α).right.as PUnit.unit","decl":"/-- Constructor for objects of the category `Functor.RightExtension L F`. -/\n@[simps!]\ndef RightExtension.mk (F' : D ⥤ H) {L : C ⥤ D} {F : C ⥤ H} (α : L ⋙ F' ⟶ F) :\n    RightExtension L F :=\n  CostructuredArrow.mk α\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.mk_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝² : CategoryTheory.Category.{u_6, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_7, u_3} H\ninst✝ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\n⊢ Eq (CategoryTheory.Functor.RightExtension.mk F' α).hom α","decl":"/-- Constructor for objects of the category `Functor.RightExtension L F`. -/\n@[simps!]\ndef RightExtension.mk (F' : D ⥤ H) {L : C ⥤ D} {F : C ⥤ H} (α : L ⋙ F' ⟶ F) :\n    RightExtension L F :=\n  CostructuredArrow.mk α\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.mk_left","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝² : CategoryTheory.Category.{u_6, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_7, u_3} H\ninst✝ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\n⊢ Eq (CategoryTheory.Functor.RightExtension.mk F' α).left F'","decl":"/-- Constructor for objects of the category `Functor.RightExtension L F`. -/\n@[simps!]\ndef RightExtension.mk (F' : D ⥤ H) {L : C ⥤ D} {F : C ⥤ H} (α : L ⋙ F' ⟶ F) :\n    RightExtension L F :=\n  CostructuredArrow.mk α\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.mk_right","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝² : CategoryTheory.Category.{u_6, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_7, u_3} H\ninst✝ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\n⊢ Eq (CategoryTheory.Functor.LeftExtension.mk F' α).right F'","decl":"/-- Constructor for objects of the category `Functor.LeftExtension L F`. -/\n@[simps!]\ndef LeftExtension.mk (F' : D ⥤ H) {L : C ⥤ D} {F : C ⥤ H} (α : F ⟶ L ⋙ F') :\n    LeftExtension L F :=\n  StructuredArrow.mk α\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.mk_left_as","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝² : CategoryTheory.Category.{u_6, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_7, u_3} H\ninst✝ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\n⊢ Eq (CategoryTheory.Functor.LeftExtension.mk F' α).left.as PUnit.unit","decl":"/-- Constructor for objects of the category `Functor.LeftExtension L F`. -/\n@[simps!]\ndef LeftExtension.mk (F' : D ⥤ H) {L : C ⥤ D} {F : C ⥤ H} (α : F ⟶ L ⋙ F') :\n    LeftExtension L F :=\n  StructuredArrow.mk α\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.mk_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝² : CategoryTheory.Category.{u_6, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_7, u_3} H\ninst✝ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\n⊢ Eq (CategoryTheory.Functor.LeftExtension.mk F' α).hom α","decl":"/-- Constructor for objects of the category `Functor.LeftExtension L F`. -/\n@[simps!]\ndef LeftExtension.mk (F' : D ⥤ H) {L : C ⥤ D} {F : C ⥤ H} (α : F ⟶ L ⋙ F') :\n    LeftExtension L F :=\n  StructuredArrow.mk α\n\n"}
{"name":"CategoryTheory.Functor.IsRightKanExtension.nonempty_isUniversal","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝² : CategoryTheory.Category.{u_6, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_7, u_3} H\ninst✝ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\nself : F'.IsRightKanExtension α\n⊢ Nonempty (CategoryTheory.CostructuredArrow.IsUniversal (CategoryTheory.Functor.RightExtension.mk F' α))","decl":"/-- Given `α : L ⋙ F' ⟶ F`, the property `F'.IsRightKanExtension α` asserts that\n`(F', α)` is a terminal object in the category `RightExtension L F`, i.e. that `(F', α)`\nis a right Kan extension of `F` along `L`. -/\nclass IsRightKanExtension : Prop where\n  nonempty_isUniversal : Nonempty (RightExtension.mk F' α).IsUniversal\n\n"}
{"name":"CategoryTheory.Functor.liftOfIsRightKanExtension_fac_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\ninst✝ : F'.IsRightKanExtension α\nG : CategoryTheory.Functor D H\nβ : Quiver.Hom (L.comp G) F\nZ : CategoryTheory.Functor C H\nh : Quiver.Hom F Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L (F'.liftOfIsRightKanExtension α G β)) (CategoryTheory.CategoryStruct.comp α h)) (CategoryTheory.CategoryStruct.comp β h)","decl":"@[reassoc (attr := simp)]\nlemma liftOfIsRightKanExtension_fac (G : D ⥤ H) (β : L ⋙ G ⟶ F) :\n    whiskerLeft L (F'.liftOfIsRightKanExtension α G β) ≫ α = β :=\n  (F'.isUniversalOfIsRightKanExtension α).fac (RightExtension.mk G β)\n\n"}
{"name":"CategoryTheory.Functor.liftOfIsRightKanExtension_fac","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\ninst✝ : F'.IsRightKanExtension α\nG : CategoryTheory.Functor D H\nβ : Quiver.Hom (L.comp G) F\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L (F'.liftOfIsRightKanExtension α G β)) α) β","decl":"@[reassoc (attr := simp)]\nlemma liftOfIsRightKanExtension_fac (G : D ⥤ H) (β : L ⋙ G ⟶ F) :\n    whiskerLeft L (F'.liftOfIsRightKanExtension α G β) ≫ α = β :=\n  (F'.isUniversalOfIsRightKanExtension α).fac (RightExtension.mk G β)\n\n"}
{"name":"CategoryTheory.Functor.liftOfIsRightKanExtension_fac_app_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\ninst✝ : F'.IsRightKanExtension α\nG : CategoryTheory.Functor D H\nβ : Quiver.Hom (L.comp G) F\nX : C\nZ : H\nh : Quiver.Hom (F.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F'.liftOfIsRightKanExtension α G β).app (L.obj X)) (CategoryTheory.CategoryStruct.comp (α.app X) h)) (CategoryTheory.CategoryStruct.comp (β.app X) h)","decl":"@[reassoc (attr := simp)]\nlemma liftOfIsRightKanExtension_fac_app (G : D ⥤ H) (β : L ⋙ G ⟶ F) (X : C) :\n    (F'.liftOfIsRightKanExtension α G β).app (L.obj X) ≫ α.app X = β.app X :=\n  NatTrans.congr_app (F'.liftOfIsRightKanExtension_fac α G β) X\n\n"}
{"name":"CategoryTheory.Functor.liftOfIsRightKanExtension_fac_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\ninst✝ : F'.IsRightKanExtension α\nG : CategoryTheory.Functor D H\nβ : Quiver.Hom (L.comp G) F\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F'.liftOfIsRightKanExtension α G β).app (L.obj X)) (α.app X)) (β.app X)","decl":"@[reassoc (attr := simp)]\nlemma liftOfIsRightKanExtension_fac_app (G : D ⥤ H) (β : L ⋙ G ⟶ F) (X : C) :\n    (F'.liftOfIsRightKanExtension α G β).app (L.obj X) ≫ α.app X = β.app X :=\n  NatTrans.congr_app (F'.liftOfIsRightKanExtension_fac α G β) X\n\n"}
{"name":"CategoryTheory.Functor.hom_ext_of_isRightKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\ninst✝ : F'.IsRightKanExtension α\nG : CategoryTheory.Functor D H\nγ₁ γ₂ : Quiver.Hom G F'\nhγ : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L γ₁) α) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L γ₂) α)\n⊢ Eq γ₁ γ₂","decl":"lemma hom_ext_of_isRightKanExtension {G : D ⥤ H} (γ₁ γ₂ : G ⟶ F')\n    (hγ : whiskerLeft L γ₁ ≫ α = whiskerLeft L γ₂ ≫ α) : γ₁ = γ₂ :=\n  (F'.isUniversalOfIsRightKanExtension α).hom_ext hγ\n\n"}
{"name":"CategoryTheory.Functor.isRightKanExtension_of_iso","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\nF' F'' : CategoryTheory.Functor D H\ne : CategoryTheory.Iso F' F''\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\nα' : Quiver.Hom (L.comp F'') F\ncomm : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L e.hom) α') α\ninst✝ : F'.IsRightKanExtension α\n⊢ F''.IsRightKanExtension α'","decl":"lemma isRightKanExtension_of_iso {F' F'' : D ⥤ H} (e : F' ≅ F'') {L : C ⥤ D} {F : C ⥤ H}\n    (α : L ⋙ F' ⟶ F) (α' : L ⋙ F'' ⟶ F) (comm : whiskerLeft L e.hom ≫ α' = α)\n    [F'.IsRightKanExtension α] : F''.IsRightKanExtension α' where\n  nonempty_isUniversal := ⟨IsTerminal.ofIso (F'.isUniversalOfIsRightKanExtension α)\n    (CostructuredArrow.isoMk e comm)⟩\n\n"}
{"name":"CategoryTheory.Functor.isRightKanExtension_iff_of_iso","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝² : CategoryTheory.Category.{u_8, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_7, u_3} H\ninst✝ : CategoryTheory.Category.{u_6, u_4} D\nF' F'' : CategoryTheory.Functor D H\ne : CategoryTheory.Iso F' F''\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\nα' : Quiver.Hom (L.comp F'') F\ncomm : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L e.hom) α') α\n⊢ Iff (F'.IsRightKanExtension α) (F''.IsRightKanExtension α')","decl":"lemma isRightKanExtension_iff_of_iso {F' F'' : D ⥤ H} (e : F' ≅ F'') {L : C ⥤ D} {F : C ⥤ H}\n    (α : L ⋙ F' ⟶ F) (α' : L ⋙ F'' ⟶ F) (comm : whiskerLeft L e.hom ≫ α' = α) :\n    F'.IsRightKanExtension α ↔ F''.IsRightKanExtension α' := by\n  constructor\n  · intro\n    exact isRightKanExtension_of_iso e α α' comm\n  · intro\n    refine isRightKanExtension_of_iso e.symm α' α ?_\n    rw [← comm, ← whiskerLeft_comp_assoc, Iso.symm_hom, e.inv_hom_id, whiskerLeft_id', id_comp]\n\n"}
{"name":"CategoryTheory.Functor.rightKanExtensionUniqueOfIso_inv","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_7, u_3} H\ninst✝² : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\ninst✝¹ : F'.IsRightKanExtension α\nG : CategoryTheory.Functor C H\ni : CategoryTheory.Iso F G\nG' : CategoryTheory.Functor D H\nβ : Quiver.Hom (L.comp G') G\ninst✝ : G'.IsRightKanExtension β\n⊢ Eq (F'.rightKanExtensionUniqueOfIso α i G' β).inv (F'.liftOfIsRightKanExtension α G' (CategoryTheory.CategoryStruct.comp β i.inv))","decl":"/-- Right Kan extensions of isomorphic functors are isomorphic. -/\n@[simps]\nnoncomputable def rightKanExtensionUniqueOfIso {G : C ⥤ H} (i : F ≅ G) (G' : D ⥤ H)\n    (β : L ⋙ G' ⟶ G) [G'.IsRightKanExtension β] : F' ≅ G' where\n  hom := liftOfIsRightKanExtension _ β F' (α ≫ i.hom)\n  inv := liftOfIsRightKanExtension _ α G' (β ≫ i.inv)\n  hom_inv_id := F'.hom_ext_of_isRightKanExtension α _ _ (by simp)\n  inv_hom_id := G'.hom_ext_of_isRightKanExtension β _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Functor.rightKanExtensionUniqueOfIso_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_7, u_3} H\ninst✝² : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\ninst✝¹ : F'.IsRightKanExtension α\nG : CategoryTheory.Functor C H\ni : CategoryTheory.Iso F G\nG' : CategoryTheory.Functor D H\nβ : Quiver.Hom (L.comp G') G\ninst✝ : G'.IsRightKanExtension β\n⊢ Eq (F'.rightKanExtensionUniqueOfIso α i G' β).hom (G'.liftOfIsRightKanExtension β F' (CategoryTheory.CategoryStruct.comp α i.hom))","decl":"/-- Right Kan extensions of isomorphic functors are isomorphic. -/\n@[simps]\nnoncomputable def rightKanExtensionUniqueOfIso {G : C ⥤ H} (i : F ≅ G) (G' : D ⥤ H)\n    (β : L ⋙ G' ⟶ G) [G'.IsRightKanExtension β] : F' ≅ G' where\n  hom := liftOfIsRightKanExtension _ β F' (α ≫ i.hom)\n  inv := liftOfIsRightKanExtension _ α G' (β ≫ i.inv)\n  hom_inv_id := F'.hom_ext_of_isRightKanExtension α _ _ (by simp)\n  inv_hom_id := G'.hom_ext_of_isRightKanExtension β _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Functor.rightKanExtensionUnique_inv","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_7, u_3} H\ninst✝² : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\ninst✝¹ : F'.IsRightKanExtension α\nF'' : CategoryTheory.Functor D H\nα' : Quiver.Hom (L.comp F'') F\ninst✝ : F''.IsRightKanExtension α'\n⊢ Eq (F'.rightKanExtensionUnique α F'' α').inv (F'.liftOfIsRightKanExtension α F'' α')","decl":"/-- Two right Kan extensions are (canonically) isomorphic. -/\n@[simps!]\nnoncomputable def rightKanExtensionUnique\n    (F'' : D ⥤ H) (α' : L ⋙ F'' ⟶ F) [F''.IsRightKanExtension α'] : F' ≅ F'' :=\n  rightKanExtensionUniqueOfIso F' α (Iso.refl _) F'' α'\n\n\n"}
{"name":"CategoryTheory.Functor.rightKanExtensionUnique_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_7, u_3} H\ninst✝² : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\ninst✝¹ : F'.IsRightKanExtension α\nF'' : CategoryTheory.Functor D H\nα' : Quiver.Hom (L.comp F'') F\ninst✝ : F''.IsRightKanExtension α'\n⊢ Eq (F'.rightKanExtensionUnique α F'' α').hom (F''.liftOfIsRightKanExtension α' F' α)","decl":"/-- Two right Kan extensions are (canonically) isomorphic. -/\n@[simps!]\nnoncomputable def rightKanExtensionUnique\n    (F'' : D ⥤ H) (α' : L ⋙ F'' ⟶ F) [F''.IsRightKanExtension α'] : F' ≅ F'' :=\n  rightKanExtensionUniqueOfIso F' α (Iso.refl _) F'' α'\n\n\n"}
{"name":"CategoryTheory.Functor.isRightKanExtension_iff_isIso","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\nF' F'' : CategoryTheory.Functor D H\nφ : Quiver.Hom F'' F'\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\nα' : Quiver.Hom (L.comp F'') F\ncomm : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L φ) α) α'\ninst✝ : F'.IsRightKanExtension α\n⊢ Iff (F''.IsRightKanExtension α') (CategoryTheory.IsIso φ)","decl":"lemma isRightKanExtension_iff_isIso {F' : D ⥤ H} {F'' : D ⥤ H} (φ : F'' ⟶ F')\n    {L : C ⥤ D} {F : C ⥤ H} (α : L ⋙ F' ⟶ F) (α' : L ⋙ F'' ⟶ F)\n    (comm : whiskerLeft L φ ≫ α = α') [F'.IsRightKanExtension α] :\n    F''.IsRightKanExtension α' ↔ IsIso φ := by\n  constructor\n  · intro\n    rw [F'.hom_ext_of_isRightKanExtension α φ (rightKanExtensionUnique _ α' _ α).hom\n      (by simp [comm])]\n    infer_instance\n  · intro\n    rw [isRightKanExtension_iff_of_iso (asIso φ) α' α comm]\n    infer_instance\n"}
{"name":"CategoryTheory.Functor.IsLeftKanExtension.nonempty_isUniversal","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝² : CategoryTheory.Category.{u_6, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_7, u_3} H\ninst✝ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\nself : F'.IsLeftKanExtension α\n⊢ Nonempty (CategoryTheory.StructuredArrow.IsUniversal (CategoryTheory.Functor.LeftExtension.mk F' α))","decl":"/-- Given `α : F ⟶ L ⋙ F'`, the property `F'.IsLeftKanExtension α` asserts that\n`(F', α)` is an initial object in the category `LeftExtension L F`, i.e. that `(F', α)`\nis a left Kan extension of `F` along `L`. -/\nclass IsLeftKanExtension : Prop where\n  nonempty_isUniversal : Nonempty (LeftExtension.mk F' α).IsUniversal\n\n"}
{"name":"CategoryTheory.Functor.descOfIsLeftKanExtension_fac","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\ninst✝ : F'.IsLeftKanExtension α\nG : CategoryTheory.Functor D H\nβ : Quiver.Hom F (L.comp G)\n⊢ Eq (CategoryTheory.CategoryStruct.comp α (CategoryTheory.whiskerLeft L (F'.descOfIsLeftKanExtension α G β))) β","decl":"@[reassoc (attr := simp)]\nlemma descOfIsLeftKanExtension_fac (G : D ⥤ H) (β : F ⟶ L ⋙ G) :\n    α ≫ whiskerLeft L (F'.descOfIsLeftKanExtension α G β) = β :=\n  (F'.isUniversalOfIsLeftKanExtension α).fac (LeftExtension.mk G β)\n\n"}
{"name":"CategoryTheory.Functor.descOfIsLeftKanExtension_fac_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\ninst✝ : F'.IsLeftKanExtension α\nG : CategoryTheory.Functor D H\nβ : Quiver.Hom F (L.comp G)\nZ : CategoryTheory.Functor C H\nh : Quiver.Hom (L.comp G) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp α (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L (F'.descOfIsLeftKanExtension α G β)) h)) (CategoryTheory.CategoryStruct.comp β h)","decl":"@[reassoc (attr := simp)]\nlemma descOfIsLeftKanExtension_fac (G : D ⥤ H) (β : F ⟶ L ⋙ G) :\n    α ≫ whiskerLeft L (F'.descOfIsLeftKanExtension α G β) = β :=\n  (F'.isUniversalOfIsLeftKanExtension α).fac (LeftExtension.mk G β)\n\n"}
{"name":"CategoryTheory.Functor.descOfIsLeftKanExtension_fac_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\ninst✝ : F'.IsLeftKanExtension α\nG : CategoryTheory.Functor D H\nβ : Quiver.Hom F (L.comp G)\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (α.app X) ((F'.descOfIsLeftKanExtension α G β).app (L.obj X))) (β.app X)","decl":"@[reassoc (attr := simp)]\nlemma descOfIsLeftKanExtension_fac_app (G : D ⥤ H) (β : F ⟶ L ⋙ G) (X : C) :\n    α.app X ≫ (F'.descOfIsLeftKanExtension α G β).app (L.obj X) = β.app X :=\n  NatTrans.congr_app (F'.descOfIsLeftKanExtension_fac α G β) X\n\n"}
{"name":"CategoryTheory.Functor.descOfIsLeftKanExtension_fac_app_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\ninst✝ : F'.IsLeftKanExtension α\nG : CategoryTheory.Functor D H\nβ : Quiver.Hom F (L.comp G)\nX : C\nZ : H\nh : Quiver.Hom (G.obj (L.obj X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (α.app X) (CategoryTheory.CategoryStruct.comp ((F'.descOfIsLeftKanExtension α G β).app (L.obj X)) h)) (CategoryTheory.CategoryStruct.comp (β.app X) h)","decl":"@[reassoc (attr := simp)]\nlemma descOfIsLeftKanExtension_fac_app (G : D ⥤ H) (β : F ⟶ L ⋙ G) (X : C) :\n    α.app X ≫ (F'.descOfIsLeftKanExtension α G β).app (L.obj X) = β.app X :=\n  NatTrans.congr_app (F'.descOfIsLeftKanExtension_fac α G β) X\n\n"}
{"name":"CategoryTheory.Functor.hom_ext_of_isLeftKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\ninst✝ : F'.IsLeftKanExtension α\nG : CategoryTheory.Functor D H\nγ₁ γ₂ : Quiver.Hom F' G\nhγ : Eq (CategoryTheory.CategoryStruct.comp α (CategoryTheory.whiskerLeft L γ₁)) (CategoryTheory.CategoryStruct.comp α (CategoryTheory.whiskerLeft L γ₂))\n⊢ Eq γ₁ γ₂","decl":"lemma hom_ext_of_isLeftKanExtension {G : D ⥤ H} (γ₁ γ₂ : F' ⟶ G)\n    (hγ : α ≫ whiskerLeft L γ₁ = α ≫ whiskerLeft L γ₂) : γ₁ = γ₂ :=\n  (F'.isUniversalOfIsLeftKanExtension α).hom_ext hγ\n\n"}
{"name":"CategoryTheory.Functor.isLeftKanExtension_of_iso","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\nF' F'' : CategoryTheory.Functor D H\ne : CategoryTheory.Iso F' F''\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\nα' : Quiver.Hom F (L.comp F'')\ncomm : Eq (CategoryTheory.CategoryStruct.comp α (CategoryTheory.whiskerLeft L e.hom)) α'\ninst✝ : F'.IsLeftKanExtension α\n⊢ F''.IsLeftKanExtension α'","decl":"lemma isLeftKanExtension_of_iso {F' : D ⥤ H} {F'' : D ⥤ H} (e : F' ≅ F'')\n    {L : C ⥤ D} {F : C ⥤ H} (α : F ⟶ L ⋙ F') (α' : F ⟶ L ⋙ F'')\n    (comm : α ≫ whiskerLeft L e.hom = α') [F'.IsLeftKanExtension α] :\n    F''.IsLeftKanExtension α' where\n  nonempty_isUniversal := ⟨IsInitial.ofIso (F'.isUniversalOfIsLeftKanExtension α)\n    (StructuredArrow.isoMk e comm)⟩\n\n"}
{"name":"CategoryTheory.Functor.isLeftKanExtension_iff_of_iso","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝² : CategoryTheory.Category.{u_8, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_7, u_3} H\ninst✝ : CategoryTheory.Category.{u_6, u_4} D\nF' F'' : CategoryTheory.Functor D H\ne : CategoryTheory.Iso F' F''\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\nα' : Quiver.Hom F (L.comp F'')\ncomm : Eq (CategoryTheory.CategoryStruct.comp α (CategoryTheory.whiskerLeft L e.hom)) α'\n⊢ Iff (F'.IsLeftKanExtension α) (F''.IsLeftKanExtension α')","decl":"lemma isLeftKanExtension_iff_of_iso {F' F'' : D ⥤ H} (e : F' ≅ F'')\n    {L : C ⥤ D} {F : C ⥤ H} (α : F ⟶ L ⋙ F') (α' : F ⟶ L ⋙ F'')\n    (comm : α ≫ whiskerLeft L e.hom = α') :\n    F'.IsLeftKanExtension α ↔ F''.IsLeftKanExtension α' := by\n  constructor\n  · intro\n    exact isLeftKanExtension_of_iso e α α' comm\n  · intro\n    refine isLeftKanExtension_of_iso e.symm α' α ?_\n    rw [← comm, assoc, ← whiskerLeft_comp, Iso.symm_hom, e.hom_inv_id, whiskerLeft_id', comp_id]\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtensionUniqueOfIso_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_7, u_3} H\ninst✝² : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\ninst✝¹ : F'.IsLeftKanExtension α\nG : CategoryTheory.Functor C H\ni : CategoryTheory.Iso F G\nG' : CategoryTheory.Functor D H\nβ : Quiver.Hom G (L.comp G')\ninst✝ : G'.IsLeftKanExtension β\n⊢ Eq (F'.leftKanExtensionUniqueOfIso α i G' β).hom (F'.descOfIsLeftKanExtension α G' (CategoryTheory.CategoryStruct.comp i.hom β))","decl":"/-- Left Kan extensions of isomorphic functors are isomorphic. -/\n@[simps]\nnoncomputable def leftKanExtensionUniqueOfIso {G : C ⥤ H} (i : F ≅ G) (G' : D ⥤ H)\n    (β : G ⟶ L ⋙ G') [G'.IsLeftKanExtension β] : F' ≅ G' where\n  hom := descOfIsLeftKanExtension _ α G' (i.hom ≫ β)\n  inv := descOfIsLeftKanExtension _ β F' (i.inv ≫ α)\n  hom_inv_id := F'.hom_ext_of_isLeftKanExtension α _ _ (by simp)\n  inv_hom_id := G'.hom_ext_of_isLeftKanExtension β _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtensionUniqueOfIso_inv","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_7, u_3} H\ninst✝² : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\ninst✝¹ : F'.IsLeftKanExtension α\nG : CategoryTheory.Functor C H\ni : CategoryTheory.Iso F G\nG' : CategoryTheory.Functor D H\nβ : Quiver.Hom G (L.comp G')\ninst✝ : G'.IsLeftKanExtension β\n⊢ Eq (F'.leftKanExtensionUniqueOfIso α i G' β).inv (G'.descOfIsLeftKanExtension β F' (CategoryTheory.CategoryStruct.comp i.inv α))","decl":"/-- Left Kan extensions of isomorphic functors are isomorphic. -/\n@[simps]\nnoncomputable def leftKanExtensionUniqueOfIso {G : C ⥤ H} (i : F ≅ G) (G' : D ⥤ H)\n    (β : G ⟶ L ⋙ G') [G'.IsLeftKanExtension β] : F' ≅ G' where\n  hom := descOfIsLeftKanExtension _ α G' (i.hom ≫ β)\n  inv := descOfIsLeftKanExtension _ β F' (i.inv ≫ α)\n  hom_inv_id := F'.hom_ext_of_isLeftKanExtension α _ _ (by simp)\n  inv_hom_id := G'.hom_ext_of_isLeftKanExtension β _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtensionUnique_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_7, u_3} H\ninst✝² : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\ninst✝¹ : F'.IsLeftKanExtension α\nF'' : CategoryTheory.Functor D H\nα' : Quiver.Hom F (L.comp F'')\ninst✝ : F''.IsLeftKanExtension α'\n⊢ Eq (F'.leftKanExtensionUnique α F'' α').hom (F'.descOfIsLeftKanExtension α F'' α')","decl":"/-- Two left Kan extensions are (canonically) isomorphic. -/\n@[simps!]\nnoncomputable def leftKanExtensionUnique\n    (F'' : D ⥤ H) (α' : F ⟶ L ⋙ F'') [F''.IsLeftKanExtension α'] : F' ≅ F'' :=\n  leftKanExtensionUniqueOfIso F' α (Iso.refl _) F'' α'\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtensionUnique_inv","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_6, u_1} C\ninst✝³ : CategoryTheory.Category.{u_7, u_3} H\ninst✝² : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\ninst✝¹ : F'.IsLeftKanExtension α\nF'' : CategoryTheory.Functor D H\nα' : Quiver.Hom F (L.comp F'')\ninst✝ : F''.IsLeftKanExtension α'\n⊢ Eq (F'.leftKanExtensionUnique α F'' α').inv (F''.descOfIsLeftKanExtension α' F' α)","decl":"/-- Two left Kan extensions are (canonically) isomorphic. -/\n@[simps!]\nnoncomputable def leftKanExtensionUnique\n    (F'' : D ⥤ H) (α' : F ⟶ L ⋙ F'') [F''.IsLeftKanExtension α'] : F' ≅ F'' :=\n  leftKanExtensionUniqueOfIso F' α (Iso.refl _) F'' α'\n\n"}
{"name":"CategoryTheory.Functor.isLeftKanExtension_iff_isIso","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\nF' F'' : CategoryTheory.Functor D H\nφ : Quiver.Hom F' F''\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\nα' : Quiver.Hom F (L.comp F'')\ncomm : Eq (CategoryTheory.CategoryStruct.comp α (CategoryTheory.whiskerLeft L φ)) α'\ninst✝ : F'.IsLeftKanExtension α\n⊢ Iff (F''.IsLeftKanExtension α') (CategoryTheory.IsIso φ)","decl":"lemma isLeftKanExtension_iff_isIso {F' : D ⥤ H} {F'' : D ⥤ H} (φ : F' ⟶ F'')\n    {L : C ⥤ D} {F : C ⥤ H} (α : F ⟶ L ⋙ F') (α' : F ⟶ L ⋙ F'')\n    (comm : α ≫ whiskerLeft L φ = α') [F'.IsLeftKanExtension α] :\n    F''.IsLeftKanExtension α' ↔ IsIso φ := by\n  constructor\n  · intro\n    rw [F'.hom_ext_of_isLeftKanExtension α φ (leftKanExtensionUnique _ α _ α').hom\n      (by simp [comm])]\n    infer_instance\n  · intro\n    exact isLeftKanExtension_of_iso (asIso φ) α α' comm\n\n"}
{"name":"CategoryTheory.Functor.HasRightKanExtension.mk","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\ninst✝ : F'.IsRightKanExtension α\n⊢ L.HasRightKanExtension F","decl":"lemma HasRightKanExtension.mk (F' : D ⥤ H) {L : C ⥤ D} {F : C ⥤ H} (α : L ⋙ F' ⟶ F)\n    [F'.IsRightKanExtension α] : HasRightKanExtension L F :=\n  (F'.isUniversalOfIsRightKanExtension α).hasTerminal\n\n"}
{"name":"CategoryTheory.Functor.HasLeftKanExtension.mk","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\ninst✝ : F'.IsLeftKanExtension α\n⊢ L.HasLeftKanExtension F","decl":"lemma HasLeftKanExtension.mk (F' : D ⥤ H) {L : C ⥤ D} {F : C ⥤ H} (α : F ⟶ L ⋙ F')\n    [F'.IsLeftKanExtension α] : HasLeftKanExtension L F :=\n  (F'.isUniversalOfIsLeftKanExtension α).hasInitial\n\n"}
{"name":"CategoryTheory.Functor.instIsRightKanExtensionRightKanExtensionRightKanExtensionCounit","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst✝ : L.HasRightKanExtension F\n⊢ (L.rightKanExtension F).IsRightKanExtension (L.rightKanExtensionCounit F)","decl":"instance : (L.rightKanExtension F).IsRightKanExtension (L.rightKanExtensionCounit F) where\n  nonempty_isUniversal := ⟨terminalIsTerminal⟩\n\n"}
{"name":"CategoryTheory.Functor.rightKanExtension_hom_ext","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst✝ : L.HasRightKanExtension F\nG : CategoryTheory.Functor D H\nγ₁ γ₂ : Quiver.Hom G (L.rightKanExtension F)\nhγ : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L γ₁) (L.rightKanExtensionCounit F)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L γ₂) (L.rightKanExtensionCounit F))\n⊢ Eq γ₁ γ₂","decl":"@[ext]\nlemma rightKanExtension_hom_ext {G : D ⥤ H} (γ₁ γ₂ : G ⟶ rightKanExtension L F)\n    (hγ : whiskerLeft L γ₁ ≫ rightKanExtensionCounit L F =\n      whiskerLeft L γ₂ ≫ rightKanExtensionCounit L F) :\n    γ₁ = γ₂ :=\n  hom_ext_of_isRightKanExtension _ _ _ _ hγ\n\n"}
{"name":"CategoryTheory.Functor.rightKanExtension_hom_ext_iff","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst✝ : L.HasRightKanExtension F\nG : CategoryTheory.Functor D H\nγ₁ γ₂ : Quiver.Hom G (L.rightKanExtension F)\n⊢ Iff (Eq γ₁ γ₂) (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L γ₁) (L.rightKanExtensionCounit F)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L γ₂) (L.rightKanExtensionCounit F)))","decl":"@[ext]\nlemma rightKanExtension_hom_ext {G : D ⥤ H} (γ₁ γ₂ : G ⟶ rightKanExtension L F)\n    (hγ : whiskerLeft L γ₁ ≫ rightKanExtensionCounit L F =\n      whiskerLeft L γ₂ ≫ rightKanExtensionCounit L F) :\n    γ₁ = γ₂ :=\n  hom_ext_of_isRightKanExtension _ _ _ _ hγ\n\n"}
{"name":"CategoryTheory.Functor.instIsLeftKanExtensionLeftKanExtensionLeftKanExtensionUnit","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst✝ : L.HasLeftKanExtension F\n⊢ (L.leftKanExtension F).IsLeftKanExtension (L.leftKanExtensionUnit F)","decl":"instance : (L.leftKanExtension F).IsLeftKanExtension (L.leftKanExtensionUnit F) where\n  nonempty_isUniversal := ⟨initialIsInitial⟩\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtension_hom_ext_iff","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst✝ : L.HasLeftKanExtension F\nG : CategoryTheory.Functor D H\nγ₁ γ₂ : Quiver.Hom (L.leftKanExtension F) G\n⊢ Iff (Eq γ₁ γ₂) (Eq (CategoryTheory.CategoryStruct.comp (L.leftKanExtensionUnit F) (CategoryTheory.whiskerLeft L γ₁)) (CategoryTheory.CategoryStruct.comp (L.leftKanExtensionUnit F) (CategoryTheory.whiskerLeft L γ₂)))","decl":"@[ext]\nlemma leftKanExtension_hom_ext {G : D ⥤ H} (γ₁ γ₂ : leftKanExtension L F ⟶ G)\n    (hγ : leftKanExtensionUnit L F ≫ whiskerLeft L γ₁ =\n      leftKanExtensionUnit L F ≫ whiskerLeft L γ₂) : γ₁ = γ₂ :=\n  hom_ext_of_isLeftKanExtension _ _ _ _ hγ\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtension_hom_ext","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_6, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst✝ : L.HasLeftKanExtension F\nG : CategoryTheory.Functor D H\nγ₁ γ₂ : Quiver.Hom (L.leftKanExtension F) G\nhγ : Eq (CategoryTheory.CategoryStruct.comp (L.leftKanExtensionUnit F) (CategoryTheory.whiskerLeft L γ₁)) (CategoryTheory.CategoryStruct.comp (L.leftKanExtensionUnit F) (CategoryTheory.whiskerLeft L γ₂))\n⊢ Eq γ₁ γ₂","decl":"@[ext]\nlemma leftKanExtension_hom_ext {G : D ⥤ H} (γ₁ γ₂ : leftKanExtension L F ⟶ G)\n    (hγ : leftKanExtensionUnit L F ≫ whiskerLeft L γ₁ =\n      leftKanExtensionUnit L F ≫ whiskerLeft L γ₂) : γ₁ = γ₂ :=\n  hom_ext_of_isLeftKanExtension _ _ _ _ hγ\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.postcomp₁_map_left","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\ninst✝ : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom L' (L.comp G)\nF : CategoryTheory.Functor C H\nX Y : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D' H).obj L')\nφ : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.Functor.LeftExtension.postcomp₁ G f F).map φ).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `LeftExtension L' F ⥤ LeftExtension L F`\ninduced by a natural transformation `L' ⟶ L ⋙ G'`. -/\n@[simps!]\ndef LeftExtension.postcomp₁ (f : L' ⟶ L ⋙ G) (F : C ⥤ H) :\n    LeftExtension L' F ⥤ LeftExtension L F :=\n  StructuredArrow.map₂ (F := (whiskeringLeft D D' H).obj G) (G := 𝟭 _) (𝟙 _)\n    ((whiskeringLeft C D' H).map f)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.postcomp₁_obj_right_obj","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\ninst✝ : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom L' (L.comp G)\nF : CategoryTheory.Functor C H\nX✝ : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D' H).obj L')\nX : D\n⊢ Eq (((CategoryTheory.Functor.LeftExtension.postcomp₁ G f F).obj X✝).right.obj X) (X✝.right.obj (G.obj X))","decl":"/-- The functor `LeftExtension L' F ⥤ LeftExtension L F`\ninduced by a natural transformation `L' ⟶ L ⋙ G'`. -/\n@[simps!]\ndef LeftExtension.postcomp₁ (f : L' ⟶ L ⋙ G) (F : C ⥤ H) :\n    LeftExtension L' F ⥤ LeftExtension L F :=\n  StructuredArrow.map₂ (F := (whiskeringLeft D D' H).obj G) (G := 𝟭 _) (𝟙 _)\n    ((whiskeringLeft C D' H).map f)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.postcomp₁_obj_right_map","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\ninst✝ : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf✝ : Quiver.Hom L' (L.comp G)\nF : CategoryTheory.Functor C H\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D' H).obj L')\nX✝ Y✝ : D\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.Functor.LeftExtension.postcomp₁ G f✝ F).obj X).right.map f) (X.right.map (G.map f))","decl":"/-- The functor `LeftExtension L' F ⥤ LeftExtension L F`\ninduced by a natural transformation `L' ⟶ L ⋙ G'`. -/\n@[simps!]\ndef LeftExtension.postcomp₁ (f : L' ⟶ L ⋙ G) (F : C ⥤ H) :\n    LeftExtension L' F ⥤ LeftExtension L F :=\n  StructuredArrow.map₂ (F := (whiskeringLeft D D' H).obj G) (G := 𝟭 _) (𝟙 _)\n    ((whiskeringLeft C D' H).map f)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.postcomp₁_obj_left","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\ninst✝ : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom L' (L.comp G)\nF : CategoryTheory.Functor C H\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D' H).obj L')\n⊢ Eq ((CategoryTheory.Functor.LeftExtension.postcomp₁ G f F).obj X).left X.left","decl":"/-- The functor `LeftExtension L' F ⥤ LeftExtension L F`\ninduced by a natural transformation `L' ⟶ L ⋙ G'`. -/\n@[simps!]\ndef LeftExtension.postcomp₁ (f : L' ⟶ L ⋙ G) (F : C ⥤ H) :\n    LeftExtension L' F ⥤ LeftExtension L F :=\n  StructuredArrow.map₂ (F := (whiskeringLeft D D' H).obj G) (G := 𝟭 _) (𝟙 _)\n    ((whiskeringLeft C D' H).map f)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.postcomp₁_map_right_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\ninst✝ : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom L' (L.comp G)\nF : CategoryTheory.Functor C H\nX✝ Y : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D' H).obj L')\nφ : Quiver.Hom X✝ Y\nX : D\n⊢ Eq (((CategoryTheory.Functor.LeftExtension.postcomp₁ G f F).map φ).right.app X) (φ.right.app (G.obj X))","decl":"/-- The functor `LeftExtension L' F ⥤ LeftExtension L F`\ninduced by a natural transformation `L' ⟶ L ⋙ G'`. -/\n@[simps!]\ndef LeftExtension.postcomp₁ (f : L' ⟶ L ⋙ G) (F : C ⥤ H) :\n    LeftExtension L' F ⥤ LeftExtension L F :=\n  StructuredArrow.map₂ (F := (whiskeringLeft D D' H).obj G) (G := 𝟭 _) (𝟙 _)\n    ((whiskeringLeft C D' H).map f)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.postcomp₁_obj_hom_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\ninst✝ : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom L' (L.comp G)\nF : CategoryTheory.Functor C H\nX✝ : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D' H).obj L')\nX : C\n⊢ Eq (((CategoryTheory.Functor.LeftExtension.postcomp₁ G f F).obj X✝).hom.app X) (CategoryTheory.CategoryStruct.comp (X✝.hom.app X) (X✝.right.map (f.app X)))","decl":"/-- The functor `LeftExtension L' F ⥤ LeftExtension L F`\ninduced by a natural transformation `L' ⟶ L ⋙ G'`. -/\n@[simps!]\ndef LeftExtension.postcomp₁ (f : L' ⟶ L ⋙ G) (F : C ⥤ H) :\n    LeftExtension L' F ⥤ LeftExtension L F :=\n  StructuredArrow.map₂ (F := (whiskeringLeft D D' H).obj G) (G := 𝟭 _) (𝟙 _)\n    ((whiskeringLeft C D' H).map f)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.postcomp₁_obj_left_map","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\ninst✝ : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf✝ : Quiver.Hom (L.comp G) L'\nF : CategoryTheory.Functor C H\nX : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D' H).obj L') (CategoryTheory.Functor.fromPUnit F)\nX✝ Y✝ : D\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.Functor.RightExtension.postcomp₁ G f✝ F).obj X).left.map f) (X.left.map (G.map f))","decl":"/-- The functor `RightExtension L' F ⥤ RightExtension L F`\ninduced by a natural transformation `L ⋙ G ⟶ L'`. -/\n@[simps!]\ndef RightExtension.postcomp₁ (f : L ⋙ G ⟶ L') (F : C ⥤ H) :\n    RightExtension L' F ⥤ RightExtension L F :=\n  CostructuredArrow.map₂ (F := (whiskeringLeft D D' H).obj G) (G := 𝟭 _)\n    ((whiskeringLeft C D' H).map f) (𝟙 _)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.postcomp₁_map_right","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\ninst✝ : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom (L.comp G) L'\nF : CategoryTheory.Functor C H\nX Y : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D' H).obj L') (CategoryTheory.Functor.fromPUnit F)\nφ : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.Functor.RightExtension.postcomp₁ G f F).map φ).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `RightExtension L' F ⥤ RightExtension L F`\ninduced by a natural transformation `L ⋙ G ⟶ L'`. -/\n@[simps!]\ndef RightExtension.postcomp₁ (f : L ⋙ G ⟶ L') (F : C ⥤ H) :\n    RightExtension L' F ⥤ RightExtension L F :=\n  CostructuredArrow.map₂ (F := (whiskeringLeft D D' H).obj G) (G := 𝟭 _)\n    ((whiskeringLeft C D' H).map f) (𝟙 _)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.postcomp₁_obj_hom_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\ninst✝ : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom (L.comp G) L'\nF : CategoryTheory.Functor C H\nX✝ : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D' H).obj L') (CategoryTheory.Functor.fromPUnit F)\nX : C\n⊢ Eq (((CategoryTheory.Functor.RightExtension.postcomp₁ G f F).obj X✝).hom.app X) (CategoryTheory.CategoryStruct.comp (X✝.left.map (f.app X)) (X✝.hom.app X))","decl":"/-- The functor `RightExtension L' F ⥤ RightExtension L F`\ninduced by a natural transformation `L ⋙ G ⟶ L'`. -/\n@[simps!]\ndef RightExtension.postcomp₁ (f : L ⋙ G ⟶ L') (F : C ⥤ H) :\n    RightExtension L' F ⥤ RightExtension L F :=\n  CostructuredArrow.map₂ (F := (whiskeringLeft D D' H).obj G) (G := 𝟭 _)\n    ((whiskeringLeft C D' H).map f) (𝟙 _)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.postcomp₁_obj_right","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\ninst✝ : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom (L.comp G) L'\nF : CategoryTheory.Functor C H\nX : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D' H).obj L') (CategoryTheory.Functor.fromPUnit F)\n⊢ Eq ((CategoryTheory.Functor.RightExtension.postcomp₁ G f F).obj X).right X.right","decl":"/-- The functor `RightExtension L' F ⥤ RightExtension L F`\ninduced by a natural transformation `L ⋙ G ⟶ L'`. -/\n@[simps!]\ndef RightExtension.postcomp₁ (f : L ⋙ G ⟶ L') (F : C ⥤ H) :\n    RightExtension L' F ⥤ RightExtension L F :=\n  CostructuredArrow.map₂ (F := (whiskeringLeft D D' H).obj G) (G := 𝟭 _)\n    ((whiskeringLeft C D' H).map f) (𝟙 _)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.postcomp₁_map_left_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\ninst✝ : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom (L.comp G) L'\nF : CategoryTheory.Functor C H\nX✝ Y : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D' H).obj L') (CategoryTheory.Functor.fromPUnit F)\nφ : Quiver.Hom X✝ Y\nX : D\n⊢ Eq (((CategoryTheory.Functor.RightExtension.postcomp₁ G f F).map φ).left.app X) (φ.left.app (G.obj X))","decl":"/-- The functor `RightExtension L' F ⥤ RightExtension L F`\ninduced by a natural transformation `L ⋙ G ⟶ L'`. -/\n@[simps!]\ndef RightExtension.postcomp₁ (f : L ⋙ G ⟶ L') (F : C ⥤ H) :\n    RightExtension L' F ⥤ RightExtension L F :=\n  CostructuredArrow.map₂ (F := (whiskeringLeft D D' H).obj G) (G := 𝟭 _)\n    ((whiskeringLeft C D' H).map f) (𝟙 _)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.postcomp₁_obj_left_obj","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\ninst✝ : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom (L.comp G) L'\nF : CategoryTheory.Functor C H\nX✝ : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D' H).obj L') (CategoryTheory.Functor.fromPUnit F)\nX : D\n⊢ Eq (((CategoryTheory.Functor.RightExtension.postcomp₁ G f F).obj X✝).left.obj X) (X✝.left.obj (G.obj X))","decl":"/-- The functor `RightExtension L' F ⥤ RightExtension L F`\ninduced by a natural transformation `L ⋙ G ⟶ L'`. -/\n@[simps!]\ndef RightExtension.postcomp₁ (f : L ⋙ G ⟶ L') (F : C ⥤ H) :\n    RightExtension L' F ⥤ RightExtension L F :=\n  CostructuredArrow.map₂ (F := (whiskeringLeft D D' H).obj G) (G := 𝟭 _)\n    ((whiskeringLeft C D' H).map f) (𝟙 _)\n\n"}
{"name":"CategoryTheory.Functor.instIsEquivalenceLeftExtensionPostcomp₁OfIsIso","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C\ninst✝³ : CategoryTheory.Category.{u_9, u_3} H\ninst✝² : CategoryTheory.Category.{u_8, u_4} D\ninst✝¹ : CategoryTheory.Category.{u_6, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom L' (L.comp G)\ninst✝ : CategoryTheory.IsIso f\nF : CategoryTheory.Functor C H\n⊢ (CategoryTheory.Functor.LeftExtension.postcomp₁ G f F).IsEquivalence","decl":"noncomputable instance (f : L' ⟶ L ⋙ G) [IsIso f] (F : C ⥤ H) :\n    IsEquivalence (LeftExtension.postcomp₁ G f F) := by\n  apply StructuredArrow.isEquivalenceMap₂\n\n"}
{"name":"CategoryTheory.Functor.instIsEquivalenceRightExtensionPostcomp₁OfIsIso","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C\ninst✝³ : CategoryTheory.Category.{u_9, u_3} H\ninst✝² : CategoryTheory.Category.{u_8, u_4} D\ninst✝¹ : CategoryTheory.Category.{u_6, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom (L.comp G) L'\ninst✝ : CategoryTheory.IsIso f\nF : CategoryTheory.Functor C H\n⊢ (CategoryTheory.Functor.RightExtension.postcomp₁ G f F).IsEquivalence","decl":"noncomputable instance (f : L ⋙ G ⟶ L') [IsIso f] (F : C ⥤ H) :\n    IsEquivalence (RightExtension.postcomp₁ G f F) := by\n  apply CostructuredArrow.isEquivalenceMap₂\n\n"}
{"name":"CategoryTheory.Functor.hasLeftExtension_iff_postcomp₁","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C\ninst✝³ : CategoryTheory.Category.{u_9, u_3} H\ninst✝² : CategoryTheory.Category.{u_8, u_4} D\ninst✝¹ : CategoryTheory.Category.{u_6, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\ninst✝ : G.IsEquivalence\ne : CategoryTheory.Iso (L.comp G) L'\nF : CategoryTheory.Functor C H\n⊢ Iff (L'.HasLeftKanExtension F) (L.HasLeftKanExtension F)","decl":"variable {G} in\nlemma hasLeftExtension_iff_postcomp₁ (e : L ⋙ G ≅ L') (F : C ⥤ H) :\n    HasLeftKanExtension L' F ↔ HasLeftKanExtension L F :=\n  (LeftExtension.postcomp₁ G e.inv F).asEquivalence.hasInitial_iff\n\n"}
{"name":"CategoryTheory.Functor.hasRightExtension_iff_postcomp₁","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C\ninst✝³ : CategoryTheory.Category.{u_9, u_3} H\ninst✝² : CategoryTheory.Category.{u_8, u_4} D\ninst✝¹ : CategoryTheory.Category.{u_6, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\ninst✝ : G.IsEquivalence\ne : CategoryTheory.Iso (L.comp G) L'\nF : CategoryTheory.Functor C H\n⊢ Iff (L'.HasRightKanExtension F) (L.HasRightKanExtension F)","decl":"variable {G} in\nlemma hasRightExtension_iff_postcomp₁ (e : L ⋙ G ≅ L') (F : C ⥤ H) :\n    HasRightKanExtension L' F ↔ HasRightKanExtension L F :=\n  (RightExtension.postcomp₁ G e.hom F).asEquivalence.hasTerminal_iff\n\n"}
{"name":"CategoryTheory.Functor.isLeftKanExtension_iff_postcomp₁","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_3} H\ninst✝² : CategoryTheory.Category.{u_9, u_4} D\ninst✝¹ : CategoryTheory.Category.{u_8, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\ninst✝ : G.IsEquivalence\ne : CategoryTheory.Iso (L.comp G) L'\nF : CategoryTheory.Functor C H\nF' : CategoryTheory.Functor D' H\nα : Quiver.Hom F (L'.comp F')\n⊢ Iff (F'.IsLeftKanExtension α) ((G.comp F').IsLeftKanExtension (CategoryTheory.CategoryStruct.comp α (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight e.inv F') (L.associator G F').hom)))","decl":"lemma isLeftKanExtension_iff_postcomp₁ (α : F ⟶ L' ⋙ F') :\n    F'.IsLeftKanExtension α ↔ (G ⋙ F').IsLeftKanExtension\n      (α ≫ whiskerRight e.inv _ ≫ (Functor.associator _ _ _).hom) := by\n  let eq : (LeftExtension.mk _ α).IsUniversal ≃\n      (LeftExtension.mk _\n        (α ≫ whiskerRight e.inv _ ≫ (Functor.associator _ _ _).hom)).IsUniversal :=\n    (LeftExtension.isUniversalPostcomp₁Equiv G e F _).trans\n    (IsInitial.equivOfIso (StructuredArrow.isoMk (Iso.refl _)))\n  constructor\n  · exact fun _ => ⟨⟨eq (isUniversalOfIsLeftKanExtension _ _)⟩⟩\n  · exact fun _ => ⟨⟨eq.symm (isUniversalOfIsLeftKanExtension _ _)⟩⟩\n\n"}
{"name":"CategoryTheory.Functor.isRightKanExtension_iff_postcomp₁","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_3} H\ninst✝² : CategoryTheory.Category.{u_9, u_4} D\ninst✝¹ : CategoryTheory.Category.{u_8, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\ninst✝ : G.IsEquivalence\ne : CategoryTheory.Iso (L.comp G) L'\nF : CategoryTheory.Functor C H\nF' : CategoryTheory.Functor D' H\nα : Quiver.Hom (L'.comp F') F\n⊢ Iff (F'.IsRightKanExtension α) ((G.comp F').IsRightKanExtension (CategoryTheory.CategoryStruct.comp (L.associator G F').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight e.hom F') α)))","decl":"lemma isRightKanExtension_iff_postcomp₁ (α : L' ⋙ F' ⟶ F) :\n    F'.IsRightKanExtension α ↔ (G ⋙ F').IsRightKanExtension\n      ((Functor.associator _ _ _).inv ≫ whiskerRight e.hom F' ≫ α) := by\n  let eq : (RightExtension.mk _ α).IsUniversal ≃\n    (RightExtension.mk _\n      ((Functor.associator _ _ _).inv ≫ whiskerRight e.hom F' ≫ α)).IsUniversal :=\n  (RightExtension.isUniversalPostcomp₁Equiv G e F _).trans\n    (IsTerminal.equivOfIso (CostructuredArrow.isoMk (Iso.refl _)))\n  constructor\n  · exact fun _ => ⟨⟨eq (isUniversalOfIsRightKanExtension _ _)⟩⟩\n  · exact fun _ => ⟨⟨eq.symm (isUniversalOfIsRightKanExtension _ _)⟩⟩\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.precomp_map_right","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} C'\ninst✝¹ : CategoryTheory.Category.{u_8, u_3} H\ninst✝ : CategoryTheory.Category.{u_9, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\nX Y : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D H).obj L)\nφ : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.Functor.LeftExtension.precomp L F G).map φ).right φ.right","decl":"/-- The functor `LeftExtension L F ⥤ LeftExtension (G ⋙ L) (G ⋙ F)`\nobtained by precomposition. -/\n@[simps!]\ndef LeftExtension.precomp : LeftExtension L F ⥤ LeftExtension (G ⋙ L) (G ⋙ F) :=\n  StructuredArrow.map₂ (F := 𝟭 _) (G := (whiskeringLeft C' C H).obj G) (𝟙 _) (𝟙 _)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.precomp_obj_right","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} C'\ninst✝¹ : CategoryTheory.Category.{u_8, u_3} H\ninst✝ : CategoryTheory.Category.{u_9, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D H).obj L)\n⊢ Eq ((CategoryTheory.Functor.LeftExtension.precomp L F G).obj X).right X.right","decl":"/-- The functor `LeftExtension L F ⥤ LeftExtension (G ⋙ L) (G ⋙ F)`\nobtained by precomposition. -/\n@[simps!]\ndef LeftExtension.precomp : LeftExtension L F ⥤ LeftExtension (G ⋙ L) (G ⋙ F) :=\n  StructuredArrow.map₂ (F := 𝟭 _) (G := (whiskeringLeft C' C H).obj G) (𝟙 _) (𝟙 _)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.precomp_map_left","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} C'\ninst✝¹ : CategoryTheory.Category.{u_8, u_3} H\ninst✝ : CategoryTheory.Category.{u_9, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\nX Y : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D H).obj L)\nφ : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.Functor.LeftExtension.precomp L F G).map φ).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `LeftExtension L F ⥤ LeftExtension (G ⋙ L) (G ⋙ F)`\nobtained by precomposition. -/\n@[simps!]\ndef LeftExtension.precomp : LeftExtension L F ⥤ LeftExtension (G ⋙ L) (G ⋙ F) :=\n  StructuredArrow.map₂ (F := 𝟭 _) (G := (whiskeringLeft C' C H).obj G) (𝟙 _) (𝟙 _)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.precomp_obj_hom_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} C'\ninst✝¹ : CategoryTheory.Category.{u_8, u_3} H\ninst✝ : CategoryTheory.Category.{u_9, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\nX✝ : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D H).obj L)\nX : C'\n⊢ Eq (((CategoryTheory.Functor.LeftExtension.precomp L F G).obj X✝).hom.app X) (X✝.hom.app (G.obj X))","decl":"/-- The functor `LeftExtension L F ⥤ LeftExtension (G ⋙ L) (G ⋙ F)`\nobtained by precomposition. -/\n@[simps!]\ndef LeftExtension.precomp : LeftExtension L F ⥤ LeftExtension (G ⋙ L) (G ⋙ F) :=\n  StructuredArrow.map₂ (F := 𝟭 _) (G := (whiskeringLeft C' C H).obj G) (𝟙 _) (𝟙 _)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.precomp_obj_left","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} C'\ninst✝¹ : CategoryTheory.Category.{u_8, u_3} H\ninst✝ : CategoryTheory.Category.{u_9, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D H).obj L)\n⊢ Eq ((CategoryTheory.Functor.LeftExtension.precomp L F G).obj X).left X.left","decl":"/-- The functor `LeftExtension L F ⥤ LeftExtension (G ⋙ L) (G ⋙ F)`\nobtained by precomposition. -/\n@[simps!]\ndef LeftExtension.precomp : LeftExtension L F ⥤ LeftExtension (G ⋙ L) (G ⋙ F) :=\n  StructuredArrow.map₂ (F := 𝟭 _) (G := (whiskeringLeft C' C H).obj G) (𝟙 _) (𝟙 _)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.precomp_obj_right","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} C'\ninst✝¹ : CategoryTheory.Category.{u_8, u_3} H\ninst✝ : CategoryTheory.Category.{u_9, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\nX : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D H).obj L) (CategoryTheory.Functor.fromPUnit F)\n⊢ Eq ((CategoryTheory.Functor.RightExtension.precomp L F G).obj X).right X.right","decl":"/-- The functor `RightExtension L F ⥤ RightExtension (G ⋙ L) (G ⋙ F)`\nobtained by precomposition. -/\n@[simps!]\ndef RightExtension.precomp : RightExtension L F ⥤ RightExtension (G ⋙ L) (G ⋙ F) :=\n  CostructuredArrow.map₂ (F := 𝟭 _) (G := (whiskeringLeft C' C H).obj G) (𝟙 _) (𝟙 _)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.precomp_map_right","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} C'\ninst✝¹ : CategoryTheory.Category.{u_8, u_3} H\ninst✝ : CategoryTheory.Category.{u_9, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\nX Y : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D H).obj L) (CategoryTheory.Functor.fromPUnit F)\nφ : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.Functor.RightExtension.precomp L F G).map φ).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `RightExtension L F ⥤ RightExtension (G ⋙ L) (G ⋙ F)`\nobtained by precomposition. -/\n@[simps!]\ndef RightExtension.precomp : RightExtension L F ⥤ RightExtension (G ⋙ L) (G ⋙ F) :=\n  CostructuredArrow.map₂ (F := 𝟭 _) (G := (whiskeringLeft C' C H).obj G) (𝟙 _) (𝟙 _)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.precomp_obj_left","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} C'\ninst✝¹ : CategoryTheory.Category.{u_8, u_3} H\ninst✝ : CategoryTheory.Category.{u_9, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\nX : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D H).obj L) (CategoryTheory.Functor.fromPUnit F)\n⊢ Eq ((CategoryTheory.Functor.RightExtension.precomp L F G).obj X).left X.left","decl":"/-- The functor `RightExtension L F ⥤ RightExtension (G ⋙ L) (G ⋙ F)`\nobtained by precomposition. -/\n@[simps!]\ndef RightExtension.precomp : RightExtension L F ⥤ RightExtension (G ⋙ L) (G ⋙ F) :=\n  CostructuredArrow.map₂ (F := 𝟭 _) (G := (whiskeringLeft C' C H).obj G) (𝟙 _) (𝟙 _)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.precomp_obj_hom_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} C'\ninst✝¹ : CategoryTheory.Category.{u_8, u_3} H\ninst✝ : CategoryTheory.Category.{u_9, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\nX✝ : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D H).obj L) (CategoryTheory.Functor.fromPUnit F)\nX : C'\n⊢ Eq (((CategoryTheory.Functor.RightExtension.precomp L F G).obj X✝).hom.app X) (X✝.hom.app (G.obj X))","decl":"/-- The functor `RightExtension L F ⥤ RightExtension (G ⋙ L) (G ⋙ F)`\nobtained by precomposition. -/\n@[simps!]\ndef RightExtension.precomp : RightExtension L F ⥤ RightExtension (G ⋙ L) (G ⋙ F) :=\n  CostructuredArrow.map₂ (F := 𝟭 _) (G := (whiskeringLeft C' C H).obj G) (𝟙 _) (𝟙 _)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.precomp_map_left","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} C'\ninst✝¹ : CategoryTheory.Category.{u_8, u_3} H\ninst✝ : CategoryTheory.Category.{u_9, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\nX Y : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D H).obj L) (CategoryTheory.Functor.fromPUnit F)\nφ : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.Functor.RightExtension.precomp L F G).map φ).left φ.left","decl":"/-- The functor `RightExtension L F ⥤ RightExtension (G ⋙ L) (G ⋙ F)`\nobtained by precomposition. -/\n@[simps!]\ndef RightExtension.precomp : RightExtension L F ⥤ RightExtension (G ⋙ L) (G ⋙ F) :=\n  CostructuredArrow.map₂ (F := 𝟭 _) (G := (whiskeringLeft C' C H).obj G) (𝟙 _) (𝟙 _)\n\n"}
{"name":"CategoryTheory.Functor.instIsEquivalenceLeftExtensionCompPrecomp","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_9, u_2} C'\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} H\ninst✝ : CategoryTheory.Category.{u_7, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\n⊢ (CategoryTheory.Functor.LeftExtension.precomp L F G).IsEquivalence","decl":"noncomputable instance : IsEquivalence (LeftExtension.precomp L F G) := by\n  apply StructuredArrow.isEquivalenceMap₂\n\n"}
{"name":"CategoryTheory.Functor.instIsEquivalenceRightExtensionCompPrecomp","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_8, u_1} C\ninst✝² : CategoryTheory.Category.{u_9, u_2} C'\ninst✝¹ : CategoryTheory.Category.{u_6, u_3} H\ninst✝ : CategoryTheory.Category.{u_7, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\n⊢ (CategoryTheory.Functor.RightExtension.precomp L F G).IsEquivalence","decl":"noncomputable instance : IsEquivalence (RightExtension.precomp L F G) := by\n  apply CostructuredArrow.isEquivalenceMap₂\n\n"}
{"name":"CategoryTheory.Functor.isLeftKanExtension_iff_precomp","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C\ninst✝³ : CategoryTheory.Category.{u_9, u_2} C'\ninst✝² : CategoryTheory.Category.{u_6, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nF' : CategoryTheory.Functor D H\nG : CategoryTheory.Functor C' C\ninst✝ : G.IsEquivalence\nα : Quiver.Hom F (L.comp F')\n⊢ Iff (F'.IsLeftKanExtension α) (F'.IsLeftKanExtension (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft G α) (G.associator L F').inv))","decl":"lemma isLeftKanExtension_iff_precomp (α : F ⟶ L ⋙ F') :\n    F'.IsLeftKanExtension α ↔ F'.IsLeftKanExtension\n      (whiskerLeft G α ≫ (Functor.associator _ _ _).inv) := by\n  let eq : (LeftExtension.mk _ α).IsUniversal ≃ (LeftExtension.mk _\n      (whiskerLeft G α ≫ (Functor.associator _ _ _).inv)).IsUniversal :=\n    (LeftExtension.isUniversalPrecompEquiv L F G _).trans\n    (IsInitial.equivOfIso (StructuredArrow.isoMk (Iso.refl _)))\n  constructor\n  · exact fun _ => ⟨⟨eq (isUniversalOfIsLeftKanExtension _ _)⟩⟩\n  · exact fun _ => ⟨⟨eq.symm (isUniversalOfIsLeftKanExtension _ _)⟩⟩\n\n"}
{"name":"CategoryTheory.Functor.isRightKanExtension_iff_precomp","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C\ninst✝³ : CategoryTheory.Category.{u_9, u_2} C'\ninst✝² : CategoryTheory.Category.{u_6, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nF' : CategoryTheory.Functor D H\nG : CategoryTheory.Functor C' C\ninst✝ : G.IsEquivalence\nα : Quiver.Hom (L.comp F') F\n⊢ Iff (F'.IsRightKanExtension α) (F'.IsRightKanExtension (CategoryTheory.CategoryStruct.comp (G.associator L F').hom (CategoryTheory.whiskerLeft G α)))","decl":"lemma isRightKanExtension_iff_precomp (α : L ⋙ F' ⟶ F) :\n    F'.IsRightKanExtension α ↔\n      F'.IsRightKanExtension ((Functor.associator _ _ _).hom ≫ whiskerLeft G α) := by\n  let eq : (RightExtension.mk _ α).IsUniversal ≃ (RightExtension.mk _\n      ((Functor.associator _ _ _).hom ≫ whiskerLeft G α)).IsUniversal :=\n    (RightExtension.isUniversalPrecompEquiv L F G _).trans\n    (IsTerminal.equivOfIso (CostructuredArrow.isoMk (Iso.refl _)))\n  constructor\n  · exact fun _ => ⟨⟨eq (isUniversalOfIsRightKanExtension _ _)⟩⟩\n  · exact fun _ => ⟨⟨eq.symm (isUniversalOfIsRightKanExtension _ _)⟩⟩\n\n"}
{"name":"CategoryTheory.Functor.hasRightExtension_iff_of_iso₁","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝² : CategoryTheory.Category.{u_6, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_7, u_3} H\ninst✝ : CategoryTheory.Category.{u_8, u_4} D\nL L' : CategoryTheory.Functor C D\niso₁ : CategoryTheory.Iso L L'\nF : CategoryTheory.Functor C H\n⊢ Iff (L.HasRightKanExtension F) (L'.HasRightKanExtension F)","decl":"include iso₁ in\nlemma hasRightExtension_iff_of_iso₁ : HasRightKanExtension L F ↔ HasRightKanExtension L' F :=\n  (rightExtensionEquivalenceOfIso₁ iso₁ F).hasTerminal_iff\n\n"}
{"name":"CategoryTheory.Functor.hasLeftExtension_iff_of_iso₁","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝² : CategoryTheory.Category.{u_6, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_7, u_3} H\ninst✝ : CategoryTheory.Category.{u_8, u_4} D\nL L' : CategoryTheory.Functor C D\niso₁ : CategoryTheory.Iso L L'\nF : CategoryTheory.Functor C H\n⊢ Iff (L.HasLeftKanExtension F) (L'.HasLeftKanExtension F)","decl":"include iso₁ in\nlemma hasLeftExtension_iff_of_iso₁ : HasLeftKanExtension L F ↔ HasLeftKanExtension L' F :=\n  (leftExtensionEquivalenceOfIso₁ iso₁ F).hasInitial_iff\n\n"}
{"name":"CategoryTheory.Functor.hasRightExtension_iff_of_iso₂","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝² : CategoryTheory.Category.{u_6, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_7, u_3} H\ninst✝ : CategoryTheory.Category.{u_8, u_4} D\nL : CategoryTheory.Functor C D\nF F' : CategoryTheory.Functor C H\niso₂ : CategoryTheory.Iso F F'\n⊢ Iff (L.HasRightKanExtension F) (L.HasRightKanExtension F')","decl":"include iso₂ in\nlemma hasRightExtension_iff_of_iso₂ : HasRightKanExtension L F ↔ HasRightKanExtension L F' :=\n  (rightExtensionEquivalenceOfIso₂ L iso₂).hasTerminal_iff\n\n"}
{"name":"CategoryTheory.Functor.hasLeftExtension_iff_of_iso₂","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝² : CategoryTheory.Category.{u_6, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_7, u_3} H\ninst✝ : CategoryTheory.Category.{u_8, u_4} D\nL : CategoryTheory.Functor C D\nF F' : CategoryTheory.Functor C H\niso₂ : CategoryTheory.Iso F F'\n⊢ Iff (L.HasLeftKanExtension F) (L.HasLeftKanExtension F')","decl":"include iso₂ in\nlemma hasLeftExtension_iff_of_iso₂ : HasLeftKanExtension L F ↔ HasLeftKanExtension L F' :=\n  (leftExtensionEquivalenceOfIso₂ L iso₂).hasInitial_iff\n\n"}
{"name":"CategoryTheory.Functor.isLeftKanExtension_iff_of_iso₂","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝² : CategoryTheory.Category.{u_8, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_7, u_3} H\ninst✝ : CategoryTheory.Category.{u_6, u_4} D\nL : CategoryTheory.Functor C D\nF₁ F₂ : CategoryTheory.Functor C H\nF₁' F₂' : CategoryTheory.Functor D H\nα₁ : Quiver.Hom F₁ (L.comp F₁')\nα₂ : Quiver.Hom F₂ (L.comp F₂')\ne : CategoryTheory.Iso F₁ F₂\ne' : CategoryTheory.Iso F₁' F₂'\nh : Eq (CategoryTheory.CategoryStruct.comp α₁ (CategoryTheory.whiskerLeft L e'.hom)) (CategoryTheory.CategoryStruct.comp e.hom α₂)\n⊢ Iff (F₁'.IsLeftKanExtension α₁) (F₂'.IsLeftKanExtension α₂)","decl":"lemma isLeftKanExtension_iff_of_iso₂ {F₁' F₂' : D ⥤ H} (α₁ : F₁ ⟶ L ⋙ F₁') (α₂ : F₂ ⟶ L ⋙ F₂')\n    (e : F₁ ≅ F₂) (e' : F₁' ≅ F₂') (h : α₁ ≫ whiskerLeft L e'.hom = e.hom ≫ α₂) :\n    F₁'.IsLeftKanExtension α₁ ↔ F₂'.IsLeftKanExtension α₂ := by\n  let eq := LeftExtension.isUniversalEquivOfIso₂ (LeftExtension.mk _ α₁)\n    (LeftExtension.mk _ α₂) e e' h\n  constructor\n  · exact fun _ => ⟨⟨eq.1 (isUniversalOfIsLeftKanExtension F₁' α₁)⟩⟩\n  · exact fun _ => ⟨⟨eq.2 (isUniversalOfIsLeftKanExtension F₂' α₂)⟩⟩\n\n"}
{"name":"CategoryTheory.Functor.isRightKanExtension_iff_of_iso₂","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝² : CategoryTheory.Category.{u_8, u_1} C\ninst✝¹ : CategoryTheory.Category.{u_7, u_3} H\ninst✝ : CategoryTheory.Category.{u_6, u_4} D\nL : CategoryTheory.Functor C D\nF₁ F₂ : CategoryTheory.Functor C H\nF₁' F₂' : CategoryTheory.Functor D H\nα₁ : Quiver.Hom (L.comp F₁') F₁\nα₂ : Quiver.Hom (L.comp F₂') F₂\ne : CategoryTheory.Iso F₁ F₂\ne' : CategoryTheory.Iso F₁' F₂'\nh : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L e'.hom) α₂) (CategoryTheory.CategoryStruct.comp α₁ e.hom)\n⊢ Iff (F₁'.IsRightKanExtension α₁) (F₂'.IsRightKanExtension α₂)","decl":"lemma isRightKanExtension_iff_of_iso₂ {F₁' F₂' : D ⥤ H} (α₁ : L ⋙ F₁' ⟶ F₁) (α₂ : L ⋙ F₂' ⟶ F₂)\n    (e : F₁ ≅ F₂) (e' : F₁' ≅ F₂') (h : whiskerLeft L e'.hom ≫ α₂ = α₁ ≫ e.hom) :\n    F₁'.IsRightKanExtension α₁ ↔ F₂'.IsRightKanExtension α₂ := by\n  let eq := RightExtension.isUniversalEquivOfIso₂ (RightExtension.mk _ α₁)\n    (RightExtension.mk _ α₂) e e' h\n  constructor\n  · exact fun _ => ⟨⟨eq.1 (isUniversalOfIsRightKanExtension F₁' α₁)⟩⟩\n  · exact fun _ => ⟨⟨eq.2 (isUniversalOfIsRightKanExtension F₂' α₂)⟩⟩\n\n"}
{"name":"CategoryTheory.Functor.coconeOfIsLeftKanExtension_pt","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\ninst✝ : F'.IsLeftKanExtension α\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq (F'.coconeOfIsLeftKanExtension α c).pt c.pt","decl":"/-- Construct a cocone for a left Kan extension `F' : D ⥤ H` of `F : C ⥤ H` along a functor\n`L : C ⥤ D` given a cocone for `F`. -/\n@[simps]\nnoncomputable def coconeOfIsLeftKanExtension (c : Cocone F) : Cocone F' where\n  pt := c.pt\n  ι := F'.descOfIsLeftKanExtension α _ c.ι\n\n"}
{"name":"CategoryTheory.Functor.coconeOfIsLeftKanExtension_ι","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\ninst✝ : F'.IsLeftKanExtension α\nc : CategoryTheory.Limits.Cocone F\n⊢ Eq (F'.coconeOfIsLeftKanExtension α c).ι (F'.descOfIsLeftKanExtension α ((CategoryTheory.Functor.const D).obj c.pt) c.ι)","decl":"/-- Construct a cocone for a left Kan extension `F' : D ⥤ H` of `F : C ⥤ H` along a functor\n`L : C ⥤ D` given a cocone for `F`. -/\n@[simps]\nnoncomputable def coconeOfIsLeftKanExtension (c : Cocone F) : Cocone F' where\n  pt := c.pt\n  ι := F'.descOfIsLeftKanExtension α _ c.ι\n\n"}
{"name":"CategoryTheory.Functor.isColimitCoconeOfIsLeftKanExtension_desc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\ninst✝ : F'.IsLeftKanExtension α\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\ns : CategoryTheory.Limits.Cocone F'\n⊢ Eq ((F'.isColimitCoconeOfIsLeftKanExtension α hc).desc s) (hc.desc { pt := s.1, ι := CategoryTheory.CategoryStruct.comp α (CategoryTheory.whiskerLeft L s.ι) })","decl":"/-- If `c` is a colimit cocone for a functor `F : C ⥤ H` and `α : F ⟶ L ⋙ F'` is the unit of any\nleft Kan extension `F' : D ⥤ H` of `F` along `L : C ⥤ D`, then `coconeOfIsLeftKanExtension α c` is\na colimit cocone, too. -/\n@[simps]\ndef isColimitCoconeOfIsLeftKanExtension {c : Cocone F} (hc : IsColimit c) :\n    IsColimit (F'.coconeOfIsLeftKanExtension α c) where\n  desc s := hc.desc (Cocone.mk _ (α ≫ whiskerLeft L s.ι))\n  fac s := by\n    have : F'.descOfIsLeftKanExtension α ((const D).obj c.pt) c.ι ≫\n        (Functor.const _).map (hc.desc (Cocone.mk _ (α ≫ whiskerLeft L s.ι))) = s.ι :=\n      F'.hom_ext_of_isLeftKanExtension α _ _ (by aesop_cat)\n    exact congr_app this\n  uniq s m hm := hc.hom_ext (fun j ↦ by\n    have := hm (L.obj j)\n    nth_rw 1 [← F'.descOfIsLeftKanExtension_fac_app α ((const D).obj c.pt)]\n    dsimp at this ⊢\n    rw [assoc, this, IsColimit.fac, NatTrans.comp_app, whiskerLeft_app])\n\n"}
{"name":"CategoryTheory.Functor.ι_colimitIsoOfIsLeftKanExtension_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_6, u_3} H\ninst✝³ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\ninst✝² : F'.IsLeftKanExtension α\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasColimit F'\ni : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (α.app i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F' (L.obj i)) (F'.colimitIsoOfIsLeftKanExtension α).hom)) (CategoryTheory.Limits.colimit.ι F i)","decl":"@[reassoc (attr := simp)]\nlemma ι_colimitIsoOfIsLeftKanExtension_hom (i : C) :\n    α.app i ≫ colimit.ι F' (L.obj i) ≫ (F'.colimitIsoOfIsLeftKanExtension α).hom =\n      colimit.ι F i := by\n  simp [colimitIsoOfIsLeftKanExtension]\n\n"}
{"name":"CategoryTheory.Functor.ι_colimitIsoOfIsLeftKanExtension_hom_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_6, u_3} H\ninst✝³ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\ninst✝² : F'.IsLeftKanExtension α\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasColimit F'\ni : C\nZ : H\nh : Quiver.Hom (CategoryTheory.Limits.colimit F) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (α.app i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F' (L.obj i)) (CategoryTheory.CategoryStruct.comp (F'.colimitIsoOfIsLeftKanExtension α).hom h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F i) h)","decl":"@[reassoc (attr := simp)]\nlemma ι_colimitIsoOfIsLeftKanExtension_hom (i : C) :\n    α.app i ≫ colimit.ι F' (L.obj i) ≫ (F'.colimitIsoOfIsLeftKanExtension α).hom =\n      colimit.ι F i := by\n  simp [colimitIsoOfIsLeftKanExtension]\n\n"}
{"name":"CategoryTheory.Functor.ι_colimitIsoOfIsLeftKanExtension_inv_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_6, u_3} H\ninst✝³ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\ninst✝² : F'.IsLeftKanExtension α\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasColimit F'\ni : C\nZ : H\nh : Quiver.Hom (CategoryTheory.Limits.colimit F') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F i) (CategoryTheory.CategoryStruct.comp (F'.colimitIsoOfIsLeftKanExtension α).inv h)) (CategoryTheory.CategoryStruct.comp (α.app i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F' (L.obj i)) h))","decl":"@[reassoc (attr := simp)]\nlemma ι_colimitIsoOfIsLeftKanExtension_inv (i : C) :\n    colimit.ι F i ≫ (F'.colimitIsoOfIsLeftKanExtension α).inv =\n    α.app i ≫ colimit.ι F' (L.obj i) := by\n  rw [Iso.comp_inv_eq, assoc, ι_colimitIsoOfIsLeftKanExtension_hom]\n\n"}
{"name":"CategoryTheory.Functor.ι_colimitIsoOfIsLeftKanExtension_inv","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_6, u_3} H\ninst✝³ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom F (L.comp F')\ninst✝² : F'.IsLeftKanExtension α\ninst✝¹ : CategoryTheory.Limits.HasColimit F\ninst✝ : CategoryTheory.Limits.HasColimit F'\ni : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F i) (F'.colimitIsoOfIsLeftKanExtension α).inv) (CategoryTheory.CategoryStruct.comp (α.app i) (CategoryTheory.Limits.colimit.ι F' (L.obj i)))","decl":"@[reassoc (attr := simp)]\nlemma ι_colimitIsoOfIsLeftKanExtension_inv (i : C) :\n    colimit.ι F i ≫ (F'.colimitIsoOfIsLeftKanExtension α).inv =\n    α.app i ≫ colimit.ι F' (L.obj i) := by\n  rw [Iso.comp_inv_eq, assoc, ι_colimitIsoOfIsLeftKanExtension_hom]\n\n"}
{"name":"CategoryTheory.Functor.coneOfIsRightKanExtension_π","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\ninst✝ : F'.IsRightKanExtension α\nc : CategoryTheory.Limits.Cone F\n⊢ Eq (F'.coneOfIsRightKanExtension α c).π (F'.liftOfIsRightKanExtension α ((CategoryTheory.Functor.const D).obj c.pt) c.π)","decl":"/-- Construct a cone for a right Kan extension `F' : D ⥤ H` of `F : C ⥤ H` along a functor\n`L : C ⥤ D` given a cone for `F`. -/\n@[simps]\nnoncomputable def coneOfIsRightKanExtension (c : Cone F) : Cone F' where\n  pt := c.pt\n  π := F'.liftOfIsRightKanExtension α _ c.π\n\n"}
{"name":"CategoryTheory.Functor.coneOfIsRightKanExtension_pt","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\ninst✝ : F'.IsRightKanExtension α\nc : CategoryTheory.Limits.Cone F\n⊢ Eq (F'.coneOfIsRightKanExtension α c).pt c.pt","decl":"/-- Construct a cone for a right Kan extension `F' : D ⥤ H` of `F : C ⥤ H` along a functor\n`L : C ⥤ D` given a cone for `F`. -/\n@[simps]\nnoncomputable def coneOfIsRightKanExtension (c : Cone F) : Cone F' where\n  pt := c.pt\n  π := F'.liftOfIsRightKanExtension α _ c.π\n\n"}
{"name":"CategoryTheory.Functor.isLimitConeOfIsRightKanExtension_lift","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_3} H\ninst✝¹ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\ninst✝ : F'.IsRightKanExtension α\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\ns : CategoryTheory.Limits.Cone F'\n⊢ Eq ((F'.isLimitConeOfIsRightKanExtension α hc).lift s) (hc.lift { pt := s.1, π := CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L s.π) α })","decl":"/-- If `c` is a limit cone for a functor `F : C ⥤ H` and `α : L ⋙ F' ⟶ F` is the counit of any\nright Kan extension `F' : D ⥤ H` of `F` along `L : C ⥤ D`, then `coneOfIsRightKanExtension α c` is\na limit cone, too. -/\n@[simps]\ndef isLimitConeOfIsRightKanExtension {c : Cone F} (hc : IsLimit c) :\n    IsLimit (F'.coneOfIsRightKanExtension α c) where\n  lift s := hc.lift (Cone.mk _ (whiskerLeft L s.π ≫ α))\n  fac s := by\n    have : (Functor.const _).map (hc.lift (Cone.mk _ (whiskerLeft L s.π ≫ α))) ≫\n        F'.liftOfIsRightKanExtension α ((const D).obj c.pt) c.π = s.π :=\n      F'.hom_ext_of_isRightKanExtension α _ _ (by aesop_cat)\n    exact congr_app this\n  uniq s m hm := hc.hom_ext (fun j ↦ by\n    have := hm (L.obj j)\n    nth_rw 1 [← F'.liftOfIsRightKanExtension_fac_app α ((const D).obj c.pt)]\n    dsimp at this ⊢\n    rw [← assoc, this, IsLimit.fac, NatTrans.comp_app, whiskerLeft_app])\n\n"}
{"name":"CategoryTheory.Functor.limitIsoOfIsRightKanExtension_inv_π","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_6, u_3} H\ninst✝³ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\ninst✝² : F'.IsRightKanExtension α\ninst✝¹ : CategoryTheory.Limits.HasLimit F\ninst✝ : CategoryTheory.Limits.HasLimit F'\ni : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F'.limitIsoOfIsRightKanExtension α).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F' (L.obj i)) (α.app i))) (CategoryTheory.Limits.limit.π F i)","decl":"@[reassoc (attr := simp)]\nlemma limitIsoOfIsRightKanExtension_inv_π (i : C) :\n    (F'.limitIsoOfIsRightKanExtension α).inv ≫ limit.π F' (L.obj i) ≫ α.app i = limit.π F i := by\n  simp [limitIsoOfIsRightKanExtension]\n\n"}
{"name":"CategoryTheory.Functor.limitIsoOfIsRightKanExtension_inv_π_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝⁵ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_6, u_3} H\ninst✝³ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\ninst✝² : F'.IsRightKanExtension α\ninst✝¹ : CategoryTheory.Limits.HasLimit F\ninst✝ : CategoryTheory.Limits.HasLimit F'\ni : C\nZ : H\nh : Quiver.Hom (F.obj i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F'.limitIsoOfIsRightKanExtension α).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F' (L.obj i)) (CategoryTheory.CategoryStruct.comp (α.app i) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F i) h)","decl":"@[reassoc (attr := simp)]\nlemma limitIsoOfIsRightKanExtension_inv_π (i : C) :\n    (F'.limitIsoOfIsRightKanExtension α).inv ≫ limit.π F' (L.obj i) ≫ α.app i = limit.π F i := by\n  simp [limitIsoOfIsRightKanExtension]\n\n"}
{"name":"CategoryTheory.Functor.limitIsoOfIsRightKanExtension_hom_π_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝⁵ : CategoryTheory.Category.{u_8, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_6, u_3} H\ninst✝³ : CategoryTheory.Category.{u_7, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\ninst✝² : F'.IsRightKanExtension α\ninst✝¹ : CategoryTheory.Limits.HasLimit F\ninst✝ : CategoryTheory.Limits.HasLimit F'\ni : C\nZ : H\nh : Quiver.Hom (F.obj i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F'.limitIsoOfIsRightKanExtension α).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F i) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F' (L.obj i)) (CategoryTheory.CategoryStruct.comp (α.app i) h))","decl":"@[reassoc (attr := simp)]\nlemma limitIsoOfIsRightKanExtension_hom_π (i : C) :\n    (F'.limitIsoOfIsRightKanExtension α).hom ≫ limit.π F i = limit.π F' (L.obj i) ≫ α.app i := by\n  rw [← Iso.eq_inv_comp, limitIsoOfIsRightKanExtension_inv_π]\n\n"}
{"name":"CategoryTheory.Functor.limitIsoOfIsRightKanExtension_hom_π","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst✝⁵ : CategoryTheory.Category.{u_8, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_6, u_3} H\ninst✝³ : CategoryTheory.Category.{u_7, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nα : Quiver.Hom (L.comp F') F\ninst✝² : F'.IsRightKanExtension α\ninst✝¹ : CategoryTheory.Limits.HasLimit F\ninst✝ : CategoryTheory.Limits.HasLimit F'\ni : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F'.limitIsoOfIsRightKanExtension α).hom (CategoryTheory.Limits.limit.π F i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π F' (L.obj i)) (α.app i))","decl":"@[reassoc (attr := simp)]\nlemma limitIsoOfIsRightKanExtension_hom_π (i : C) :\n    (F'.limitIsoOfIsRightKanExtension α).hom ≫ limit.π F i = limit.π F' (L.obj i) ≫ α.app i := by\n  rw [← Iso.eq_inv_comp, limitIsoOfIsRightKanExtension_inv_π]\n\n"}
