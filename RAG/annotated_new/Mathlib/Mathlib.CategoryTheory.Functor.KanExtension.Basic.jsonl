{"name":"CategoryTheory.Functor.RightExtension.mk_right_as","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\n‚ä¢ Eq (CategoryTheory.Functor.RightExtension.mk F' Œ±).right.as PUnit.unit","decl":"/-- Constructor for objects of the category `Functor.RightExtension L F`. -/\n@[simps!]\ndef RightExtension.mk (F' : D ‚•§ H) {L : C ‚•§ D} {F : C ‚•§ H} (Œ± : L ‚ãô F' ‚ü∂ F) :\n    RightExtension L F :=\n  CostructuredArrow.mk Œ±\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.mk_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\n‚ä¢ Eq (CategoryTheory.Functor.RightExtension.mk F' Œ±).hom Œ±","decl":"/-- Constructor for objects of the category `Functor.RightExtension L F`. -/\n@[simps!]\ndef RightExtension.mk (F' : D ‚•§ H) {L : C ‚•§ D} {F : C ‚•§ H} (Œ± : L ‚ãô F' ‚ü∂ F) :\n    RightExtension L F :=\n  CostructuredArrow.mk Œ±\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.mk_left","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\n‚ä¢ Eq (CategoryTheory.Functor.RightExtension.mk F' Œ±).left F'","decl":"/-- Constructor for objects of the category `Functor.RightExtension L F`. -/\n@[simps!]\ndef RightExtension.mk (F' : D ‚•§ H) {L : C ‚•§ D} {F : C ‚•§ H} (Œ± : L ‚ãô F' ‚ü∂ F) :\n    RightExtension L F :=\n  CostructuredArrow.mk Œ±\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.mk_right","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\n‚ä¢ Eq (CategoryTheory.Functor.LeftExtension.mk F' Œ±).right F'","decl":"/-- Constructor for objects of the category `Functor.LeftExtension L F`. -/\n@[simps!]\ndef LeftExtension.mk (F' : D ‚•§ H) {L : C ‚•§ D} {F : C ‚•§ H} (Œ± : F ‚ü∂ L ‚ãô F') :\n    LeftExtension L F :=\n  StructuredArrow.mk Œ±\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.mk_left_as","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\n‚ä¢ Eq (CategoryTheory.Functor.LeftExtension.mk F' Œ±).left.as PUnit.unit","decl":"/-- Constructor for objects of the category `Functor.LeftExtension L F`. -/\n@[simps!]\ndef LeftExtension.mk (F' : D ‚•§ H) {L : C ‚•§ D} {F : C ‚•§ H} (Œ± : F ‚ü∂ L ‚ãô F') :\n    LeftExtension L F :=\n  StructuredArrow.mk Œ±\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.mk_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\n‚ä¢ Eq (CategoryTheory.Functor.LeftExtension.mk F' Œ±).hom Œ±","decl":"/-- Constructor for objects of the category `Functor.LeftExtension L F`. -/\n@[simps!]\ndef LeftExtension.mk (F' : D ‚•§ H) {L : C ‚•§ D} {F : C ‚•§ H} (Œ± : F ‚ü∂ L ‚ãô F') :\n    LeftExtension L F :=\n  StructuredArrow.mk Œ±\n\n"}
{"name":"CategoryTheory.Functor.IsRightKanExtension.nonempty_isUniversal","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\nself : F'.IsRightKanExtension Œ±\n‚ä¢ Nonempty (CategoryTheory.CostructuredArrow.IsUniversal (CategoryTheory.Functor.RightExtension.mk F' Œ±))","decl":"/-- Given `Œ± : L ‚ãô F' ‚ü∂ F`, the property `F'.IsRightKanExtension Œ±` asserts that\n`(F', Œ±)` is a terminal object in the category `RightExtension L F`, i.e. that `(F', Œ±)`\nis a right Kan extension of `F` along `L`. -/\nclass IsRightKanExtension : Prop where\n  nonempty_isUniversal : Nonempty (RightExtension.mk F' Œ±).IsUniversal\n\n"}
{"name":"CategoryTheory.Functor.liftOfIsRightKanExtension_fac_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\ninst‚úù : F'.IsRightKanExtension Œ±\nG : CategoryTheory.Functor D H\nŒ≤ : Quiver.Hom (L.comp G) F\nZ : CategoryTheory.Functor C H\nh : Quiver.Hom F Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L (F'.liftOfIsRightKanExtension Œ± G Œ≤)) (CategoryTheory.CategoryStruct.comp Œ± h)) (CategoryTheory.CategoryStruct.comp Œ≤ h)","decl":"@[reassoc (attr := simp)]\nlemma liftOfIsRightKanExtension_fac (G : D ‚•§ H) (Œ≤ : L ‚ãô G ‚ü∂ F) :\n    whiskerLeft L (F'.liftOfIsRightKanExtension Œ± G Œ≤) ‚â´ Œ± = Œ≤ :=\n  (F'.isUniversalOfIsRightKanExtension Œ±).fac (RightExtension.mk G Œ≤)\n\n"}
{"name":"CategoryTheory.Functor.liftOfIsRightKanExtension_fac","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\ninst‚úù : F'.IsRightKanExtension Œ±\nG : CategoryTheory.Functor D H\nŒ≤ : Quiver.Hom (L.comp G) F\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L (F'.liftOfIsRightKanExtension Œ± G Œ≤)) Œ±) Œ≤","decl":"@[reassoc (attr := simp)]\nlemma liftOfIsRightKanExtension_fac (G : D ‚•§ H) (Œ≤ : L ‚ãô G ‚ü∂ F) :\n    whiskerLeft L (F'.liftOfIsRightKanExtension Œ± G Œ≤) ‚â´ Œ± = Œ≤ :=\n  (F'.isUniversalOfIsRightKanExtension Œ±).fac (RightExtension.mk G Œ≤)\n\n"}
{"name":"CategoryTheory.Functor.liftOfIsRightKanExtension_fac_app_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\ninst‚úù : F'.IsRightKanExtension Œ±\nG : CategoryTheory.Functor D H\nŒ≤ : Quiver.Hom (L.comp G) F\nX : C\nZ : H\nh : Quiver.Hom (F.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F'.liftOfIsRightKanExtension Œ± G Œ≤).app (L.obj X)) (CategoryTheory.CategoryStruct.comp (Œ±.app X) h)) (CategoryTheory.CategoryStruct.comp (Œ≤.app X) h)","decl":"@[reassoc (attr := simp)]\nlemma liftOfIsRightKanExtension_fac_app (G : D ‚•§ H) (Œ≤ : L ‚ãô G ‚ü∂ F) (X : C) :\n    (F'.liftOfIsRightKanExtension Œ± G Œ≤).app (L.obj X) ‚â´ Œ±.app X = Œ≤.app X :=\n  NatTrans.congr_app (F'.liftOfIsRightKanExtension_fac Œ± G Œ≤) X\n\n"}
{"name":"CategoryTheory.Functor.liftOfIsRightKanExtension_fac_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\ninst‚úù : F'.IsRightKanExtension Œ±\nG : CategoryTheory.Functor D H\nŒ≤ : Quiver.Hom (L.comp G) F\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F'.liftOfIsRightKanExtension Œ± G Œ≤).app (L.obj X)) (Œ±.app X)) (Œ≤.app X)","decl":"@[reassoc (attr := simp)]\nlemma liftOfIsRightKanExtension_fac_app (G : D ‚•§ H) (Œ≤ : L ‚ãô G ‚ü∂ F) (X : C) :\n    (F'.liftOfIsRightKanExtension Œ± G Œ≤).app (L.obj X) ‚â´ Œ±.app X = Œ≤.app X :=\n  NatTrans.congr_app (F'.liftOfIsRightKanExtension_fac Œ± G Œ≤) X\n\n"}
{"name":"CategoryTheory.Functor.hom_ext_of_isRightKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\ninst‚úù : F'.IsRightKanExtension Œ±\nG : CategoryTheory.Functor D H\nŒ≥‚ÇÅ Œ≥‚ÇÇ : Quiver.Hom G F'\nhŒ≥ : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L Œ≥‚ÇÅ) Œ±) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L Œ≥‚ÇÇ) Œ±)\n‚ä¢ Eq Œ≥‚ÇÅ Œ≥‚ÇÇ","decl":"lemma hom_ext_of_isRightKanExtension {G : D ‚•§ H} (Œ≥‚ÇÅ Œ≥‚ÇÇ : G ‚ü∂ F')\n    (hŒ≥ : whiskerLeft L Œ≥‚ÇÅ ‚â´ Œ± = whiskerLeft L Œ≥‚ÇÇ ‚â´ Œ±) : Œ≥‚ÇÅ = Œ≥‚ÇÇ :=\n  (F'.isUniversalOfIsRightKanExtension Œ±).hom_ext hŒ≥\n\n"}
{"name":"CategoryTheory.Functor.isRightKanExtension_of_iso","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_4} D\nF' F'' : CategoryTheory.Functor D H\ne : CategoryTheory.Iso F' F''\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\nŒ±' : Quiver.Hom (L.comp F'') F\ncomm : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L e.hom) Œ±') Œ±\ninst‚úù : F'.IsRightKanExtension Œ±\n‚ä¢ F''.IsRightKanExtension Œ±'","decl":"lemma isRightKanExtension_of_iso {F' F'' : D ‚•§ H} (e : F' ‚âÖ F'') {L : C ‚•§ D} {F : C ‚•§ H}\n    (Œ± : L ‚ãô F' ‚ü∂ F) (Œ±' : L ‚ãô F'' ‚ü∂ F) (comm : whiskerLeft L e.hom ‚â´ Œ±' = Œ±)\n    [F'.IsRightKanExtension Œ±] : F''.IsRightKanExtension Œ±' where\n  nonempty_isUniversal := ‚ü®IsTerminal.ofIso (F'.isUniversalOfIsRightKanExtension Œ±)\n    (CostructuredArrow.isoMk e comm)‚ü©\n\n"}
{"name":"CategoryTheory.Functor.isRightKanExtension_iff_of_iso","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù : CategoryTheory.Category.{u_6, u_4} D\nF' F'' : CategoryTheory.Functor D H\ne : CategoryTheory.Iso F' F''\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\nŒ±' : Quiver.Hom (L.comp F'') F\ncomm : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L e.hom) Œ±') Œ±\n‚ä¢ Iff (F'.IsRightKanExtension Œ±) (F''.IsRightKanExtension Œ±')","decl":"lemma isRightKanExtension_iff_of_iso {F' F'' : D ‚•§ H} (e : F' ‚âÖ F'') {L : C ‚•§ D} {F : C ‚•§ H}\n    (Œ± : L ‚ãô F' ‚ü∂ F) (Œ±' : L ‚ãô F'' ‚ü∂ F) (comm : whiskerLeft L e.hom ‚â´ Œ±' = Œ±) :\n    F'.IsRightKanExtension Œ± ‚Üî F''.IsRightKanExtension Œ±' := by\n  constructor\n  ¬∑ intro\n    exact isRightKanExtension_of_iso e Œ± Œ±' comm\n  ¬∑ intro\n    refine isRightKanExtension_of_iso e.symm Œ±' Œ± ?_\n    rw [‚Üê comm, ‚Üê whiskerLeft_comp_assoc, Iso.symm_hom, e.inv_hom_id, whiskerLeft_id', id_comp]\n\n"}
{"name":"CategoryTheory.Functor.rightKanExtensionUniqueOfIso_inv","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\ninst‚úù¬π : F'.IsRightKanExtension Œ±\nG : CategoryTheory.Functor C H\ni : CategoryTheory.Iso F G\nG' : CategoryTheory.Functor D H\nŒ≤ : Quiver.Hom (L.comp G') G\ninst‚úù : G'.IsRightKanExtension Œ≤\n‚ä¢ Eq (F'.rightKanExtensionUniqueOfIso Œ± i G' Œ≤).inv (F'.liftOfIsRightKanExtension Œ± G' (CategoryTheory.CategoryStruct.comp Œ≤ i.inv))","decl":"/-- Right Kan extensions of isomorphic functors are isomorphic. -/\n@[simps]\nnoncomputable def rightKanExtensionUniqueOfIso {G : C ‚•§ H} (i : F ‚âÖ G) (G' : D ‚•§ H)\n    (Œ≤ : L ‚ãô G' ‚ü∂ G) [G'.IsRightKanExtension Œ≤] : F' ‚âÖ G' where\n  hom := liftOfIsRightKanExtension _ Œ≤ F' (Œ± ‚â´ i.hom)\n  inv := liftOfIsRightKanExtension _ Œ± G' (Œ≤ ‚â´ i.inv)\n  hom_inv_id := F'.hom_ext_of_isRightKanExtension Œ± _ _ (by simp)\n  inv_hom_id := G'.hom_ext_of_isRightKanExtension Œ≤ _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Functor.rightKanExtensionUniqueOfIso_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\ninst‚úù¬π : F'.IsRightKanExtension Œ±\nG : CategoryTheory.Functor C H\ni : CategoryTheory.Iso F G\nG' : CategoryTheory.Functor D H\nŒ≤ : Quiver.Hom (L.comp G') G\ninst‚úù : G'.IsRightKanExtension Œ≤\n‚ä¢ Eq (F'.rightKanExtensionUniqueOfIso Œ± i G' Œ≤).hom (G'.liftOfIsRightKanExtension Œ≤ F' (CategoryTheory.CategoryStruct.comp Œ± i.hom))","decl":"/-- Right Kan extensions of isomorphic functors are isomorphic. -/\n@[simps]\nnoncomputable def rightKanExtensionUniqueOfIso {G : C ‚•§ H} (i : F ‚âÖ G) (G' : D ‚•§ H)\n    (Œ≤ : L ‚ãô G' ‚ü∂ G) [G'.IsRightKanExtension Œ≤] : F' ‚âÖ G' where\n  hom := liftOfIsRightKanExtension _ Œ≤ F' (Œ± ‚â´ i.hom)\n  inv := liftOfIsRightKanExtension _ Œ± G' (Œ≤ ‚â´ i.inv)\n  hom_inv_id := F'.hom_ext_of_isRightKanExtension Œ± _ _ (by simp)\n  inv_hom_id := G'.hom_ext_of_isRightKanExtension Œ≤ _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Functor.rightKanExtensionUnique_inv","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\ninst‚úù¬π : F'.IsRightKanExtension Œ±\nF'' : CategoryTheory.Functor D H\nŒ±' : Quiver.Hom (L.comp F'') F\ninst‚úù : F''.IsRightKanExtension Œ±'\n‚ä¢ Eq (F'.rightKanExtensionUnique Œ± F'' Œ±').inv (F'.liftOfIsRightKanExtension Œ± F'' Œ±')","decl":"/-- Two right Kan extensions are (canonically) isomorphic. -/\n@[simps!]\nnoncomputable def rightKanExtensionUnique\n    (F'' : D ‚•§ H) (Œ±' : L ‚ãô F'' ‚ü∂ F) [F''.IsRightKanExtension Œ±'] : F' ‚âÖ F'' :=\n  rightKanExtensionUniqueOfIso F' Œ± (Iso.refl _) F'' Œ±'\n\n\n"}
{"name":"CategoryTheory.Functor.rightKanExtensionUnique_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\ninst‚úù¬π : F'.IsRightKanExtension Œ±\nF'' : CategoryTheory.Functor D H\nŒ±' : Quiver.Hom (L.comp F'') F\ninst‚úù : F''.IsRightKanExtension Œ±'\n‚ä¢ Eq (F'.rightKanExtensionUnique Œ± F'' Œ±').hom (F''.liftOfIsRightKanExtension Œ±' F' Œ±)","decl":"/-- Two right Kan extensions are (canonically) isomorphic. -/\n@[simps!]\nnoncomputable def rightKanExtensionUnique\n    (F'' : D ‚•§ H) (Œ±' : L ‚ãô F'' ‚ü∂ F) [F''.IsRightKanExtension Œ±'] : F' ‚âÖ F'' :=\n  rightKanExtensionUniqueOfIso F' Œ± (Iso.refl _) F'' Œ±'\n\n\n"}
{"name":"CategoryTheory.Functor.isRightKanExtension_iff_isIso","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_4} D\nF' F'' : CategoryTheory.Functor D H\nœÜ : Quiver.Hom F'' F'\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\nŒ±' : Quiver.Hom (L.comp F'') F\ncomm : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L œÜ) Œ±) Œ±'\ninst‚úù : F'.IsRightKanExtension Œ±\n‚ä¢ Iff (F''.IsRightKanExtension Œ±') (CategoryTheory.IsIso œÜ)","decl":"lemma isRightKanExtension_iff_isIso {F' : D ‚•§ H} {F'' : D ‚•§ H} (œÜ : F'' ‚ü∂ F')\n    {L : C ‚•§ D} {F : C ‚•§ H} (Œ± : L ‚ãô F' ‚ü∂ F) (Œ±' : L ‚ãô F'' ‚ü∂ F)\n    (comm : whiskerLeft L œÜ ‚â´ Œ± = Œ±') [F'.IsRightKanExtension Œ±] :\n    F''.IsRightKanExtension Œ±' ‚Üî IsIso œÜ := by\n  constructor\n  ¬∑ intro\n    rw [F'.hom_ext_of_isRightKanExtension Œ± œÜ (rightKanExtensionUnique _ Œ±' _ Œ±).hom\n      (by simp [comm])]\n    infer_instance\n  ¬∑ intro\n    rw [isRightKanExtension_iff_of_iso (asIso œÜ) Œ±' Œ± comm]\n    infer_instance\n"}
{"name":"CategoryTheory.Functor.IsLeftKanExtension.nonempty_isUniversal","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\nself : F'.IsLeftKanExtension Œ±\n‚ä¢ Nonempty (CategoryTheory.StructuredArrow.IsUniversal (CategoryTheory.Functor.LeftExtension.mk F' Œ±))","decl":"/-- Given `Œ± : F ‚ü∂ L ‚ãô F'`, the property `F'.IsLeftKanExtension Œ±` asserts that\n`(F', Œ±)` is an initial object in the category `LeftExtension L F`, i.e. that `(F', Œ±)`\nis a left Kan extension of `F` along `L`. -/\nclass IsLeftKanExtension : Prop where\n  nonempty_isUniversal : Nonempty (LeftExtension.mk F' Œ±).IsUniversal\n\n"}
{"name":"CategoryTheory.Functor.descOfIsLeftKanExtension_fac","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\ninst‚úù : F'.IsLeftKanExtension Œ±\nG : CategoryTheory.Functor D H\nŒ≤ : Quiver.Hom F (L.comp G)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Œ± (CategoryTheory.whiskerLeft L (F'.descOfIsLeftKanExtension Œ± G Œ≤))) Œ≤","decl":"@[reassoc (attr := simp)]\nlemma descOfIsLeftKanExtension_fac (G : D ‚•§ H) (Œ≤ : F ‚ü∂ L ‚ãô G) :\n    Œ± ‚â´ whiskerLeft L (F'.descOfIsLeftKanExtension Œ± G Œ≤) = Œ≤ :=\n  (F'.isUniversalOfIsLeftKanExtension Œ±).fac (LeftExtension.mk G Œ≤)\n\n"}
{"name":"CategoryTheory.Functor.descOfIsLeftKanExtension_fac_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\ninst‚úù : F'.IsLeftKanExtension Œ±\nG : CategoryTheory.Functor D H\nŒ≤ : Quiver.Hom F (L.comp G)\nZ : CategoryTheory.Functor C H\nh : Quiver.Hom (L.comp G) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp Œ± (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L (F'.descOfIsLeftKanExtension Œ± G Œ≤)) h)) (CategoryTheory.CategoryStruct.comp Œ≤ h)","decl":"@[reassoc (attr := simp)]\nlemma descOfIsLeftKanExtension_fac (G : D ‚•§ H) (Œ≤ : F ‚ü∂ L ‚ãô G) :\n    Œ± ‚â´ whiskerLeft L (F'.descOfIsLeftKanExtension Œ± G Œ≤) = Œ≤ :=\n  (F'.isUniversalOfIsLeftKanExtension Œ±).fac (LeftExtension.mk G Œ≤)\n\n"}
{"name":"CategoryTheory.Functor.descOfIsLeftKanExtension_fac_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\ninst‚úù : F'.IsLeftKanExtension Œ±\nG : CategoryTheory.Functor D H\nŒ≤ : Quiver.Hom F (L.comp G)\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Œ±.app X) ((F'.descOfIsLeftKanExtension Œ± G Œ≤).app (L.obj X))) (Œ≤.app X)","decl":"@[reassoc (attr := simp)]\nlemma descOfIsLeftKanExtension_fac_app (G : D ‚•§ H) (Œ≤ : F ‚ü∂ L ‚ãô G) (X : C) :\n    Œ±.app X ‚â´ (F'.descOfIsLeftKanExtension Œ± G Œ≤).app (L.obj X) = Œ≤.app X :=\n  NatTrans.congr_app (F'.descOfIsLeftKanExtension_fac Œ± G Œ≤) X\n\n"}
{"name":"CategoryTheory.Functor.descOfIsLeftKanExtension_fac_app_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\ninst‚úù : F'.IsLeftKanExtension Œ±\nG : CategoryTheory.Functor D H\nŒ≤ : Quiver.Hom F (L.comp G)\nX : C\nZ : H\nh : Quiver.Hom (G.obj (L.obj X)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Œ±.app X) (CategoryTheory.CategoryStruct.comp ((F'.descOfIsLeftKanExtension Œ± G Œ≤).app (L.obj X)) h)) (CategoryTheory.CategoryStruct.comp (Œ≤.app X) h)","decl":"@[reassoc (attr := simp)]\nlemma descOfIsLeftKanExtension_fac_app (G : D ‚•§ H) (Œ≤ : F ‚ü∂ L ‚ãô G) (X : C) :\n    Œ±.app X ‚â´ (F'.descOfIsLeftKanExtension Œ± G Œ≤).app (L.obj X) = Œ≤.app X :=\n  NatTrans.congr_app (F'.descOfIsLeftKanExtension_fac Œ± G Œ≤) X\n\n"}
{"name":"CategoryTheory.Functor.hom_ext_of_isLeftKanExtension","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\ninst‚úù : F'.IsLeftKanExtension Œ±\nG : CategoryTheory.Functor D H\nŒ≥‚ÇÅ Œ≥‚ÇÇ : Quiver.Hom F' G\nhŒ≥ : Eq (CategoryTheory.CategoryStruct.comp Œ± (CategoryTheory.whiskerLeft L Œ≥‚ÇÅ)) (CategoryTheory.CategoryStruct.comp Œ± (CategoryTheory.whiskerLeft L Œ≥‚ÇÇ))\n‚ä¢ Eq Œ≥‚ÇÅ Œ≥‚ÇÇ","decl":"lemma hom_ext_of_isLeftKanExtension {G : D ‚•§ H} (Œ≥‚ÇÅ Œ≥‚ÇÇ : F' ‚ü∂ G)\n    (hŒ≥ : Œ± ‚â´ whiskerLeft L Œ≥‚ÇÅ = Œ± ‚â´ whiskerLeft L Œ≥‚ÇÇ) : Œ≥‚ÇÅ = Œ≥‚ÇÇ :=\n  (F'.isUniversalOfIsLeftKanExtension Œ±).hom_ext hŒ≥\n\n"}
{"name":"CategoryTheory.Functor.isLeftKanExtension_of_iso","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_4} D\nF' F'' : CategoryTheory.Functor D H\ne : CategoryTheory.Iso F' F''\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\nŒ±' : Quiver.Hom F (L.comp F'')\ncomm : Eq (CategoryTheory.CategoryStruct.comp Œ± (CategoryTheory.whiskerLeft L e.hom)) Œ±'\ninst‚úù : F'.IsLeftKanExtension Œ±\n‚ä¢ F''.IsLeftKanExtension Œ±'","decl":"lemma isLeftKanExtension_of_iso {F' : D ‚•§ H} {F'' : D ‚•§ H} (e : F' ‚âÖ F'')\n    {L : C ‚•§ D} {F : C ‚•§ H} (Œ± : F ‚ü∂ L ‚ãô F') (Œ±' : F ‚ü∂ L ‚ãô F'')\n    (comm : Œ± ‚â´ whiskerLeft L e.hom = Œ±') [F'.IsLeftKanExtension Œ±] :\n    F''.IsLeftKanExtension Œ±' where\n  nonempty_isUniversal := ‚ü®IsInitial.ofIso (F'.isUniversalOfIsLeftKanExtension Œ±)\n    (StructuredArrow.isoMk e comm)‚ü©\n\n"}
{"name":"CategoryTheory.Functor.isLeftKanExtension_iff_of_iso","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù : CategoryTheory.Category.{u_6, u_4} D\nF' F'' : CategoryTheory.Functor D H\ne : CategoryTheory.Iso F' F''\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\nŒ±' : Quiver.Hom F (L.comp F'')\ncomm : Eq (CategoryTheory.CategoryStruct.comp Œ± (CategoryTheory.whiskerLeft L e.hom)) Œ±'\n‚ä¢ Iff (F'.IsLeftKanExtension Œ±) (F''.IsLeftKanExtension Œ±')","decl":"lemma isLeftKanExtension_iff_of_iso {F' F'' : D ‚•§ H} (e : F' ‚âÖ F'')\n    {L : C ‚•§ D} {F : C ‚•§ H} (Œ± : F ‚ü∂ L ‚ãô F') (Œ±' : F ‚ü∂ L ‚ãô F'')\n    (comm : Œ± ‚â´ whiskerLeft L e.hom = Œ±') :\n    F'.IsLeftKanExtension Œ± ‚Üî F''.IsLeftKanExtension Œ±' := by\n  constructor\n  ¬∑ intro\n    exact isLeftKanExtension_of_iso e Œ± Œ±' comm\n  ¬∑ intro\n    refine isLeftKanExtension_of_iso e.symm Œ±' Œ± ?_\n    rw [‚Üê comm, assoc, ‚Üê whiskerLeft_comp, Iso.symm_hom, e.hom_inv_id, whiskerLeft_id', comp_id]\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtensionUniqueOfIso_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\ninst‚úù¬π : F'.IsLeftKanExtension Œ±\nG : CategoryTheory.Functor C H\ni : CategoryTheory.Iso F G\nG' : CategoryTheory.Functor D H\nŒ≤ : Quiver.Hom G (L.comp G')\ninst‚úù : G'.IsLeftKanExtension Œ≤\n‚ä¢ Eq (F'.leftKanExtensionUniqueOfIso Œ± i G' Œ≤).hom (F'.descOfIsLeftKanExtension Œ± G' (CategoryTheory.CategoryStruct.comp i.hom Œ≤))","decl":"/-- Left Kan extensions of isomorphic functors are isomorphic. -/\n@[simps]\nnoncomputable def leftKanExtensionUniqueOfIso {G : C ‚•§ H} (i : F ‚âÖ G) (G' : D ‚•§ H)\n    (Œ≤ : G ‚ü∂ L ‚ãô G') [G'.IsLeftKanExtension Œ≤] : F' ‚âÖ G' where\n  hom := descOfIsLeftKanExtension _ Œ± G' (i.hom ‚â´ Œ≤)\n  inv := descOfIsLeftKanExtension _ Œ≤ F' (i.inv ‚â´ Œ±)\n  hom_inv_id := F'.hom_ext_of_isLeftKanExtension Œ± _ _ (by simp)\n  inv_hom_id := G'.hom_ext_of_isLeftKanExtension Œ≤ _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtensionUniqueOfIso_inv","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\ninst‚úù¬π : F'.IsLeftKanExtension Œ±\nG : CategoryTheory.Functor C H\ni : CategoryTheory.Iso F G\nG' : CategoryTheory.Functor D H\nŒ≤ : Quiver.Hom G (L.comp G')\ninst‚úù : G'.IsLeftKanExtension Œ≤\n‚ä¢ Eq (F'.leftKanExtensionUniqueOfIso Œ± i G' Œ≤).inv (G'.descOfIsLeftKanExtension Œ≤ F' (CategoryTheory.CategoryStruct.comp i.inv Œ±))","decl":"/-- Left Kan extensions of isomorphic functors are isomorphic. -/\n@[simps]\nnoncomputable def leftKanExtensionUniqueOfIso {G : C ‚•§ H} (i : F ‚âÖ G) (G' : D ‚•§ H)\n    (Œ≤ : G ‚ü∂ L ‚ãô G') [G'.IsLeftKanExtension Œ≤] : F' ‚âÖ G' where\n  hom := descOfIsLeftKanExtension _ Œ± G' (i.hom ‚â´ Œ≤)\n  inv := descOfIsLeftKanExtension _ Œ≤ F' (i.inv ‚â´ Œ±)\n  hom_inv_id := F'.hom_ext_of_isLeftKanExtension Œ± _ _ (by simp)\n  inv_hom_id := G'.hom_ext_of_isLeftKanExtension Œ≤ _ _ (by simp)\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtensionUnique_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\ninst‚úù¬π : F'.IsLeftKanExtension Œ±\nF'' : CategoryTheory.Functor D H\nŒ±' : Quiver.Hom F (L.comp F'')\ninst‚úù : F''.IsLeftKanExtension Œ±'\n‚ä¢ Eq (F'.leftKanExtensionUnique Œ± F'' Œ±').hom (F'.descOfIsLeftKanExtension Œ± F'' Œ±')","decl":"/-- Two left Kan extensions are (canonically) isomorphic. -/\n@[simps!]\nnoncomputable def leftKanExtensionUnique\n    (F'' : D ‚•§ H) (Œ±' : F ‚ü∂ L ‚ãô F'') [F''.IsLeftKanExtension Œ±'] : F' ‚âÖ F'' :=\n  leftKanExtensionUniqueOfIso F' Œ± (Iso.refl _) F'' Œ±'\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtensionUnique_inv","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\ninst‚úù¬π : F'.IsLeftKanExtension Œ±\nF'' : CategoryTheory.Functor D H\nŒ±' : Quiver.Hom F (L.comp F'')\ninst‚úù : F''.IsLeftKanExtension Œ±'\n‚ä¢ Eq (F'.leftKanExtensionUnique Œ± F'' Œ±').inv (F''.descOfIsLeftKanExtension Œ±' F' Œ±)","decl":"/-- Two left Kan extensions are (canonically) isomorphic. -/\n@[simps!]\nnoncomputable def leftKanExtensionUnique\n    (F'' : D ‚•§ H) (Œ±' : F ‚ü∂ L ‚ãô F'') [F''.IsLeftKanExtension Œ±'] : F' ‚âÖ F'' :=\n  leftKanExtensionUniqueOfIso F' Œ± (Iso.refl _) F'' Œ±'\n\n"}
{"name":"CategoryTheory.Functor.isLeftKanExtension_iff_isIso","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_4} D\nF' F'' : CategoryTheory.Functor D H\nœÜ : Quiver.Hom F' F''\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\nŒ±' : Quiver.Hom F (L.comp F'')\ncomm : Eq (CategoryTheory.CategoryStruct.comp Œ± (CategoryTheory.whiskerLeft L œÜ)) Œ±'\ninst‚úù : F'.IsLeftKanExtension Œ±\n‚ä¢ Iff (F''.IsLeftKanExtension Œ±') (CategoryTheory.IsIso œÜ)","decl":"lemma isLeftKanExtension_iff_isIso {F' : D ‚•§ H} {F'' : D ‚•§ H} (œÜ : F' ‚ü∂ F'')\n    {L : C ‚•§ D} {F : C ‚•§ H} (Œ± : F ‚ü∂ L ‚ãô F') (Œ±' : F ‚ü∂ L ‚ãô F'')\n    (comm : Œ± ‚â´ whiskerLeft L œÜ = Œ±') [F'.IsLeftKanExtension Œ±] :\n    F''.IsLeftKanExtension Œ±' ‚Üî IsIso œÜ := by\n  constructor\n  ¬∑ intro\n    rw [F'.hom_ext_of_isLeftKanExtension Œ± œÜ (leftKanExtensionUnique _ Œ± _ Œ±').hom\n      (by simp [comm])]\n    infer_instance\n  ¬∑ intro\n    exact isLeftKanExtension_of_iso (asIso œÜ) Œ± Œ±' comm\n\n"}
{"name":"CategoryTheory.Functor.HasRightKanExtension.mk","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\ninst‚úù : F'.IsRightKanExtension Œ±\n‚ä¢ L.HasRightKanExtension F","decl":"lemma HasRightKanExtension.mk (F' : D ‚•§ H) {L : C ‚•§ D} {F : C ‚•§ H} (Œ± : L ‚ãô F' ‚ü∂ F)\n    [F'.IsRightKanExtension Œ±] : HasRightKanExtension L F :=\n  (F'.isUniversalOfIsRightKanExtension Œ±).hasTerminal\n\n"}
{"name":"CategoryTheory.Functor.HasLeftKanExtension.mk","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\ninst‚úù : F'.IsLeftKanExtension Œ±\n‚ä¢ L.HasLeftKanExtension F","decl":"lemma HasLeftKanExtension.mk (F' : D ‚•§ H) {L : C ‚•§ D} {F : C ‚•§ H} (Œ± : F ‚ü∂ L ‚ãô F')\n    [F'.IsLeftKanExtension Œ±] : HasLeftKanExtension L F :=\n  (F'.isUniversalOfIsLeftKanExtension Œ±).hasInitial\n\n"}
{"name":"CategoryTheory.Functor.instIsRightKanExtensionRightKanExtensionRightKanExtensionCounit","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasRightKanExtension F\n‚ä¢ (L.rightKanExtension F).IsRightKanExtension (L.rightKanExtensionCounit F)","decl":"instance : (L.rightKanExtension F).IsRightKanExtension (L.rightKanExtensionCounit F) where\n  nonempty_isUniversal := ‚ü®terminalIsTerminal‚ü©\n\n"}
{"name":"CategoryTheory.Functor.rightKanExtension_hom_ext","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasRightKanExtension F\nG : CategoryTheory.Functor D H\nŒ≥‚ÇÅ Œ≥‚ÇÇ : Quiver.Hom G (L.rightKanExtension F)\nhŒ≥ : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L Œ≥‚ÇÅ) (L.rightKanExtensionCounit F)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L Œ≥‚ÇÇ) (L.rightKanExtensionCounit F))\n‚ä¢ Eq Œ≥‚ÇÅ Œ≥‚ÇÇ","decl":"@[ext]\nlemma rightKanExtension_hom_ext {G : D ‚•§ H} (Œ≥‚ÇÅ Œ≥‚ÇÇ : G ‚ü∂ rightKanExtension L F)\n    (hŒ≥ : whiskerLeft L Œ≥‚ÇÅ ‚â´ rightKanExtensionCounit L F =\n      whiskerLeft L Œ≥‚ÇÇ ‚â´ rightKanExtensionCounit L F) :\n    Œ≥‚ÇÅ = Œ≥‚ÇÇ :=\n  hom_ext_of_isRightKanExtension _ _ _ _ hŒ≥\n\n"}
{"name":"CategoryTheory.Functor.rightKanExtension_hom_ext_iff","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasRightKanExtension F\nG : CategoryTheory.Functor D H\nŒ≥‚ÇÅ Œ≥‚ÇÇ : Quiver.Hom G (L.rightKanExtension F)\n‚ä¢ Iff (Eq Œ≥‚ÇÅ Œ≥‚ÇÇ) (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L Œ≥‚ÇÅ) (L.rightKanExtensionCounit F)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L Œ≥‚ÇÇ) (L.rightKanExtensionCounit F)))","decl":"@[ext]\nlemma rightKanExtension_hom_ext {G : D ‚•§ H} (Œ≥‚ÇÅ Œ≥‚ÇÇ : G ‚ü∂ rightKanExtension L F)\n    (hŒ≥ : whiskerLeft L Œ≥‚ÇÅ ‚â´ rightKanExtensionCounit L F =\n      whiskerLeft L Œ≥‚ÇÇ ‚â´ rightKanExtensionCounit L F) :\n    Œ≥‚ÇÅ = Œ≥‚ÇÇ :=\n  hom_ext_of_isRightKanExtension _ _ _ _ hŒ≥\n\n"}
{"name":"CategoryTheory.Functor.instIsLeftKanExtensionLeftKanExtensionLeftKanExtensionUnit","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasLeftKanExtension F\n‚ä¢ (L.leftKanExtension F).IsLeftKanExtension (L.leftKanExtensionUnit F)","decl":"instance : (L.leftKanExtension F).IsLeftKanExtension (L.leftKanExtensionUnit F) where\n  nonempty_isUniversal := ‚ü®initialIsInitial‚ü©\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtension_hom_ext_iff","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasLeftKanExtension F\nG : CategoryTheory.Functor D H\nŒ≥‚ÇÅ Œ≥‚ÇÇ : Quiver.Hom (L.leftKanExtension F) G\n‚ä¢ Iff (Eq Œ≥‚ÇÅ Œ≥‚ÇÇ) (Eq (CategoryTheory.CategoryStruct.comp (L.leftKanExtensionUnit F) (CategoryTheory.whiskerLeft L Œ≥‚ÇÅ)) (CategoryTheory.CategoryStruct.comp (L.leftKanExtensionUnit F) (CategoryTheory.whiskerLeft L Œ≥‚ÇÇ)))","decl":"@[ext]\nlemma leftKanExtension_hom_ext {G : D ‚•§ H} (Œ≥‚ÇÅ Œ≥‚ÇÇ : leftKanExtension L F ‚ü∂ G)\n    (hŒ≥ : leftKanExtensionUnit L F ‚â´ whiskerLeft L Œ≥‚ÇÅ =\n      leftKanExtensionUnit L F ‚â´ whiskerLeft L Œ≥‚ÇÇ) : Œ≥‚ÇÅ = Œ≥‚ÇÇ :=\n  hom_ext_of_isLeftKanExtension _ _ _ _ hŒ≥\n\n"}
{"name":"CategoryTheory.Functor.leftKanExtension_hom_ext","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\ninst‚úù : L.HasLeftKanExtension F\nG : CategoryTheory.Functor D H\nŒ≥‚ÇÅ Œ≥‚ÇÇ : Quiver.Hom (L.leftKanExtension F) G\nhŒ≥ : Eq (CategoryTheory.CategoryStruct.comp (L.leftKanExtensionUnit F) (CategoryTheory.whiskerLeft L Œ≥‚ÇÅ)) (CategoryTheory.CategoryStruct.comp (L.leftKanExtensionUnit F) (CategoryTheory.whiskerLeft L Œ≥‚ÇÇ))\n‚ä¢ Eq Œ≥‚ÇÅ Œ≥‚ÇÇ","decl":"@[ext]\nlemma leftKanExtension_hom_ext {G : D ‚•§ H} (Œ≥‚ÇÅ Œ≥‚ÇÇ : leftKanExtension L F ‚ü∂ G)\n    (hŒ≥ : leftKanExtensionUnit L F ‚â´ whiskerLeft L Œ≥‚ÇÅ =\n      leftKanExtensionUnit L F ‚â´ whiskerLeft L Œ≥‚ÇÇ) : Œ≥‚ÇÅ = Œ≥‚ÇÇ :=\n  hom_ext_of_isLeftKanExtension _ _ _ _ hŒ≥\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.postcomp‚ÇÅ_map_left","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\ninst‚úù : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom L' (L.comp G)\nF : CategoryTheory.Functor C H\nX Y : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D' H).obj L')\nœÜ : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Functor.LeftExtension.postcomp‚ÇÅ G f F).map œÜ).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `LeftExtension L' F ‚•§ LeftExtension L F`\ninduced by a natural transformation `L' ‚ü∂ L ‚ãô G'`. -/\n@[simps!]\ndef LeftExtension.postcomp‚ÇÅ (f : L' ‚ü∂ L ‚ãô G) (F : C ‚•§ H) :\n    LeftExtension L' F ‚•§ LeftExtension L F :=\n  StructuredArrow.map‚ÇÇ (F := (whiskeringLeft D D' H).obj G) (G := ùü≠ _) (ùüô _)\n    ((whiskeringLeft C D' H).map f)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.postcomp‚ÇÅ_obj_right_obj","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\ninst‚úù : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom L' (L.comp G)\nF : CategoryTheory.Functor C H\nX‚úù : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D' H).obj L')\nX : D\n‚ä¢ Eq (((CategoryTheory.Functor.LeftExtension.postcomp‚ÇÅ G f F).obj X‚úù).right.obj X) (X‚úù.right.obj (G.obj X))","decl":"/-- The functor `LeftExtension L' F ‚•§ LeftExtension L F`\ninduced by a natural transformation `L' ‚ü∂ L ‚ãô G'`. -/\n@[simps!]\ndef LeftExtension.postcomp‚ÇÅ (f : L' ‚ü∂ L ‚ãô G) (F : C ‚•§ H) :\n    LeftExtension L' F ‚•§ LeftExtension L F :=\n  StructuredArrow.map‚ÇÇ (F := (whiskeringLeft D D' H).obj G) (G := ùü≠ _) (ùüô _)\n    ((whiskeringLeft C D' H).map f)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.postcomp‚ÇÅ_obj_right_map","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\ninst‚úù : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf‚úù : Quiver.Hom L' (L.comp G)\nF : CategoryTheory.Functor C H\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D' H).obj L')\nX‚úù Y‚úù : D\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((CategoryTheory.Functor.LeftExtension.postcomp‚ÇÅ G f‚úù F).obj X).right.map f) (X.right.map (G.map f))","decl":"/-- The functor `LeftExtension L' F ‚•§ LeftExtension L F`\ninduced by a natural transformation `L' ‚ü∂ L ‚ãô G'`. -/\n@[simps!]\ndef LeftExtension.postcomp‚ÇÅ (f : L' ‚ü∂ L ‚ãô G) (F : C ‚•§ H) :\n    LeftExtension L' F ‚•§ LeftExtension L F :=\n  StructuredArrow.map‚ÇÇ (F := (whiskeringLeft D D' H).obj G) (G := ùü≠ _) (ùüô _)\n    ((whiskeringLeft C D' H).map f)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.postcomp‚ÇÅ_obj_left","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\ninst‚úù : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom L' (L.comp G)\nF : CategoryTheory.Functor C H\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D' H).obj L')\n‚ä¢ Eq ((CategoryTheory.Functor.LeftExtension.postcomp‚ÇÅ G f F).obj X).left X.left","decl":"/-- The functor `LeftExtension L' F ‚•§ LeftExtension L F`\ninduced by a natural transformation `L' ‚ü∂ L ‚ãô G'`. -/\n@[simps!]\ndef LeftExtension.postcomp‚ÇÅ (f : L' ‚ü∂ L ‚ãô G) (F : C ‚•§ H) :\n    LeftExtension L' F ‚•§ LeftExtension L F :=\n  StructuredArrow.map‚ÇÇ (F := (whiskeringLeft D D' H).obj G) (G := ùü≠ _) (ùüô _)\n    ((whiskeringLeft C D' H).map f)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.postcomp‚ÇÅ_map_right_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\ninst‚úù : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom L' (L.comp G)\nF : CategoryTheory.Functor C H\nX‚úù Y : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D' H).obj L')\nœÜ : Quiver.Hom X‚úù Y\nX : D\n‚ä¢ Eq (((CategoryTheory.Functor.LeftExtension.postcomp‚ÇÅ G f F).map œÜ).right.app X) (œÜ.right.app (G.obj X))","decl":"/-- The functor `LeftExtension L' F ‚•§ LeftExtension L F`\ninduced by a natural transformation `L' ‚ü∂ L ‚ãô G'`. -/\n@[simps!]\ndef LeftExtension.postcomp‚ÇÅ (f : L' ‚ü∂ L ‚ãô G) (F : C ‚•§ H) :\n    LeftExtension L' F ‚•§ LeftExtension L F :=\n  StructuredArrow.map‚ÇÇ (F := (whiskeringLeft D D' H).obj G) (G := ùü≠ _) (ùüô _)\n    ((whiskeringLeft C D' H).map f)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.postcomp‚ÇÅ_obj_hom_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\ninst‚úù : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom L' (L.comp G)\nF : CategoryTheory.Functor C H\nX‚úù : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D' H).obj L')\nX : C\n‚ä¢ Eq (((CategoryTheory.Functor.LeftExtension.postcomp‚ÇÅ G f F).obj X‚úù).hom.app X) (CategoryTheory.CategoryStruct.comp (X‚úù.hom.app X) (X‚úù.right.map (f.app X)))","decl":"/-- The functor `LeftExtension L' F ‚•§ LeftExtension L F`\ninduced by a natural transformation `L' ‚ü∂ L ‚ãô G'`. -/\n@[simps!]\ndef LeftExtension.postcomp‚ÇÅ (f : L' ‚ü∂ L ‚ãô G) (F : C ‚•§ H) :\n    LeftExtension L' F ‚•§ LeftExtension L F :=\n  StructuredArrow.map‚ÇÇ (F := (whiskeringLeft D D' H).obj G) (G := ùü≠ _) (ùüô _)\n    ((whiskeringLeft C D' H).map f)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.postcomp‚ÇÅ_obj_left_map","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\ninst‚úù : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf‚úù : Quiver.Hom (L.comp G) L'\nF : CategoryTheory.Functor C H\nX : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D' H).obj L') (CategoryTheory.Functor.fromPUnit F)\nX‚úù Y‚úù : D\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((CategoryTheory.Functor.RightExtension.postcomp‚ÇÅ G f‚úù F).obj X).left.map f) (X.left.map (G.map f))","decl":"/-- The functor `RightExtension L' F ‚•§ RightExtension L F`\ninduced by a natural transformation `L ‚ãô G ‚ü∂ L'`. -/\n@[simps!]\ndef RightExtension.postcomp‚ÇÅ (f : L ‚ãô G ‚ü∂ L') (F : C ‚•§ H) :\n    RightExtension L' F ‚•§ RightExtension L F :=\n  CostructuredArrow.map‚ÇÇ (F := (whiskeringLeft D D' H).obj G) (G := ùü≠ _)\n    ((whiskeringLeft C D' H).map f) (ùüô _)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.postcomp‚ÇÅ_map_right","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\ninst‚úù : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom (L.comp G) L'\nF : CategoryTheory.Functor C H\nX Y : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D' H).obj L') (CategoryTheory.Functor.fromPUnit F)\nœÜ : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Functor.RightExtension.postcomp‚ÇÅ G f F).map œÜ).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `RightExtension L' F ‚•§ RightExtension L F`\ninduced by a natural transformation `L ‚ãô G ‚ü∂ L'`. -/\n@[simps!]\ndef RightExtension.postcomp‚ÇÅ (f : L ‚ãô G ‚ü∂ L') (F : C ‚•§ H) :\n    RightExtension L' F ‚•§ RightExtension L F :=\n  CostructuredArrow.map‚ÇÇ (F := (whiskeringLeft D D' H).obj G) (G := ùü≠ _)\n    ((whiskeringLeft C D' H).map f) (ùüô _)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.postcomp‚ÇÅ_obj_hom_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\ninst‚úù : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom (L.comp G) L'\nF : CategoryTheory.Functor C H\nX‚úù : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D' H).obj L') (CategoryTheory.Functor.fromPUnit F)\nX : C\n‚ä¢ Eq (((CategoryTheory.Functor.RightExtension.postcomp‚ÇÅ G f F).obj X‚úù).hom.app X) (CategoryTheory.CategoryStruct.comp (X‚úù.left.map (f.app X)) (X‚úù.hom.app X))","decl":"/-- The functor `RightExtension L' F ‚•§ RightExtension L F`\ninduced by a natural transformation `L ‚ãô G ‚ü∂ L'`. -/\n@[simps!]\ndef RightExtension.postcomp‚ÇÅ (f : L ‚ãô G ‚ü∂ L') (F : C ‚•§ H) :\n    RightExtension L' F ‚•§ RightExtension L F :=\n  CostructuredArrow.map‚ÇÇ (F := (whiskeringLeft D D' H).obj G) (G := ùü≠ _)\n    ((whiskeringLeft C D' H).map f) (ùüô _)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.postcomp‚ÇÅ_obj_right","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\ninst‚úù : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom (L.comp G) L'\nF : CategoryTheory.Functor C H\nX : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D' H).obj L') (CategoryTheory.Functor.fromPUnit F)\n‚ä¢ Eq ((CategoryTheory.Functor.RightExtension.postcomp‚ÇÅ G f F).obj X).right X.right","decl":"/-- The functor `RightExtension L' F ‚•§ RightExtension L F`\ninduced by a natural transformation `L ‚ãô G ‚ü∂ L'`. -/\n@[simps!]\ndef RightExtension.postcomp‚ÇÅ (f : L ‚ãô G ‚ü∂ L') (F : C ‚•§ H) :\n    RightExtension L' F ‚•§ RightExtension L F :=\n  CostructuredArrow.map‚ÇÇ (F := (whiskeringLeft D D' H).obj G) (G := ùü≠ _)\n    ((whiskeringLeft C D' H).map f) (ùüô _)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.postcomp‚ÇÅ_map_left_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\ninst‚úù : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom (L.comp G) L'\nF : CategoryTheory.Functor C H\nX‚úù Y : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D' H).obj L') (CategoryTheory.Functor.fromPUnit F)\nœÜ : Quiver.Hom X‚úù Y\nX : D\n‚ä¢ Eq (((CategoryTheory.Functor.RightExtension.postcomp‚ÇÅ G f F).map œÜ).left.app X) (œÜ.left.app (G.obj X))","decl":"/-- The functor `RightExtension L' F ‚•§ RightExtension L F`\ninduced by a natural transformation `L ‚ãô G ‚ü∂ L'`. -/\n@[simps!]\ndef RightExtension.postcomp‚ÇÅ (f : L ‚ãô G ‚ü∂ L') (F : C ‚•§ H) :\n    RightExtension L' F ‚•§ RightExtension L F :=\n  CostructuredArrow.map‚ÇÇ (F := (whiskeringLeft D D' H).obj G) (G := ùü≠ _)\n    ((whiskeringLeft C D' H).map f) (ùüô _)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.postcomp‚ÇÅ_obj_left_obj","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\ninst‚úù : CategoryTheory.Category.{u_9, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom (L.comp G) L'\nF : CategoryTheory.Functor C H\nX‚úù : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D' H).obj L') (CategoryTheory.Functor.fromPUnit F)\nX : D\n‚ä¢ Eq (((CategoryTheory.Functor.RightExtension.postcomp‚ÇÅ G f F).obj X‚úù).left.obj X) (X‚úù.left.obj (G.obj X))","decl":"/-- The functor `RightExtension L' F ‚•§ RightExtension L F`\ninduced by a natural transformation `L ‚ãô G ‚ü∂ L'`. -/\n@[simps!]\ndef RightExtension.postcomp‚ÇÅ (f : L ‚ãô G ‚ü∂ L') (F : C ‚•§ H) :\n    RightExtension L' F ‚•§ RightExtension L F :=\n  CostructuredArrow.map‚ÇÇ (F := (whiskeringLeft D D' H).obj G) (G := ùü≠ _)\n    ((whiskeringLeft C D' H).map f) (ùüô _)\n\n"}
{"name":"CategoryTheory.Functor.instIsEquivalenceLeftExtensionPostcomp‚ÇÅOfIsIso","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_7, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_9, u_3} H\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} D\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom L' (L.comp G)\ninst‚úù : CategoryTheory.IsIso f\nF : CategoryTheory.Functor C H\n‚ä¢ (CategoryTheory.Functor.LeftExtension.postcomp‚ÇÅ G f F).IsEquivalence","decl":"noncomputable instance (f : L' ‚ü∂ L ‚ãô G) [IsIso f] (F : C ‚•§ H) :\n    IsEquivalence (LeftExtension.postcomp‚ÇÅ G f F) := by\n  apply StructuredArrow.isEquivalenceMap‚ÇÇ\n\n"}
{"name":"CategoryTheory.Functor.instIsEquivalenceRightExtensionPostcomp‚ÇÅOfIsIso","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_7, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_9, u_3} H\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} D\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\nf : Quiver.Hom (L.comp G) L'\ninst‚úù : CategoryTheory.IsIso f\nF : CategoryTheory.Functor C H\n‚ä¢ (CategoryTheory.Functor.RightExtension.postcomp‚ÇÅ G f F).IsEquivalence","decl":"noncomputable instance (f : L ‚ãô G ‚ü∂ L') [IsIso f] (F : C ‚•§ H) :\n    IsEquivalence (RightExtension.postcomp‚ÇÅ G f F) := by\n  apply CostructuredArrow.isEquivalenceMap‚ÇÇ\n\n"}
{"name":"CategoryTheory.Functor.hasLeftExtension_iff_postcomp‚ÇÅ","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_7, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_9, u_3} H\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} D\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\ninst‚úù : G.IsEquivalence\ne : CategoryTheory.Iso (L.comp G) L'\nF : CategoryTheory.Functor C H\n‚ä¢ Iff (L'.HasLeftKanExtension F) (L.HasLeftKanExtension F)","decl":"variable {G} in\nlemma hasLeftExtension_iff_postcomp‚ÇÅ (e : L ‚ãô G ‚âÖ L') (F : C ‚•§ H) :\n    HasLeftKanExtension L' F ‚Üî HasLeftKanExtension L F :=\n  (LeftExtension.postcomp‚ÇÅ G e.inv F).asEquivalence.hasInitial_iff\n\n"}
{"name":"CategoryTheory.Functor.hasRightExtension_iff_postcomp‚ÇÅ","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_7, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_9, u_3} H\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} D\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\ninst‚úù : G.IsEquivalence\ne : CategoryTheory.Iso (L.comp G) L'\nF : CategoryTheory.Functor C H\n‚ä¢ Iff (L'.HasRightKanExtension F) (L.HasRightKanExtension F)","decl":"variable {G} in\nlemma hasRightExtension_iff_postcomp‚ÇÅ (e : L ‚ãô G ‚âÖ L') (F : C ‚•§ H) :\n    HasRightKanExtension L' F ‚Üî HasRightKanExtension L F :=\n  (RightExtension.postcomp‚ÇÅ G e.hom F).asEquivalence.hasTerminal_iff\n\n"}
{"name":"CategoryTheory.Functor.isLeftKanExtension_iff_postcomp‚ÇÅ","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_7, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_3} H\ninst‚úù¬≤ : CategoryTheory.Category.{u_9, u_4} D\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\ninst‚úù : G.IsEquivalence\ne : CategoryTheory.Iso (L.comp G) L'\nF : CategoryTheory.Functor C H\nF' : CategoryTheory.Functor D' H\nŒ± : Quiver.Hom F (L'.comp F')\n‚ä¢ Iff (F'.IsLeftKanExtension Œ±) ((G.comp F').IsLeftKanExtension (CategoryTheory.CategoryStruct.comp Œ± (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight e.inv F') (L.associator G F').hom)))","decl":"lemma isLeftKanExtension_iff_postcomp‚ÇÅ (Œ± : F ‚ü∂ L' ‚ãô F') :\n    F'.IsLeftKanExtension Œ± ‚Üî (G ‚ãô F').IsLeftKanExtension\n      (Œ± ‚â´ whiskerRight e.inv _ ‚â´ (Functor.associator _ _ _).hom) := by\n  let eq : (LeftExtension.mk _ Œ±).IsUniversal ‚âÉ\n      (LeftExtension.mk _\n        (Œ± ‚â´ whiskerRight e.inv _ ‚â´ (Functor.associator _ _ _).hom)).IsUniversal :=\n    (LeftExtension.isUniversalPostcomp‚ÇÅEquiv G e F _).trans\n    (IsInitial.equivOfIso (StructuredArrow.isoMk (Iso.refl _)))\n  constructor\n  ¬∑ exact fun _ => ‚ü®‚ü®eq (isUniversalOfIsLeftKanExtension _ _)‚ü©‚ü©\n  ¬∑ exact fun _ => ‚ü®‚ü®eq.symm (isUniversalOfIsLeftKanExtension _ _)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Functor.isRightKanExtension_iff_postcomp‚ÇÅ","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\nD' : Type u_5\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_7, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_3} H\ninst‚úù¬≤ : CategoryTheory.Category.{u_9, u_4} D\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_5} D'\nL : CategoryTheory.Functor C D\nL' : CategoryTheory.Functor C D'\nG : CategoryTheory.Functor D D'\ninst‚úù : G.IsEquivalence\ne : CategoryTheory.Iso (L.comp G) L'\nF : CategoryTheory.Functor C H\nF' : CategoryTheory.Functor D' H\nŒ± : Quiver.Hom (L'.comp F') F\n‚ä¢ Iff (F'.IsRightKanExtension Œ±) ((G.comp F').IsRightKanExtension (CategoryTheory.CategoryStruct.comp (L.associator G F').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight e.hom F') Œ±)))","decl":"lemma isRightKanExtension_iff_postcomp‚ÇÅ (Œ± : L' ‚ãô F' ‚ü∂ F) :\n    F'.IsRightKanExtension Œ± ‚Üî (G ‚ãô F').IsRightKanExtension\n      ((Functor.associator _ _ _).inv ‚â´ whiskerRight e.hom F' ‚â´ Œ±) := by\n  let eq : (RightExtension.mk _ Œ±).IsUniversal ‚âÉ\n    (RightExtension.mk _\n      ((Functor.associator _ _ _).inv ‚â´ whiskerRight e.hom F' ‚â´ Œ±)).IsUniversal :=\n  (RightExtension.isUniversalPostcomp‚ÇÅEquiv G e F _).trans\n    (IsTerminal.equivOfIso (CostructuredArrow.isoMk (Iso.refl _)))\n  constructor\n  ¬∑ exact fun _ => ‚ü®‚ü®eq (isUniversalOfIsRightKanExtension _ _)‚ü©‚ü©\n  ¬∑ exact fun _ => ‚ü®‚ü®eq.symm (isUniversalOfIsRightKanExtension _ _)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.precomp_map_right","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_2} C'\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_3} H\ninst‚úù : CategoryTheory.Category.{u_9, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\nX Y : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D H).obj L)\nœÜ : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Functor.LeftExtension.precomp L F G).map œÜ).right œÜ.right","decl":"/-- The functor `LeftExtension L F ‚•§ LeftExtension (G ‚ãô L) (G ‚ãô F)`\nobtained by precomposition. -/\n@[simps!]\ndef LeftExtension.precomp : LeftExtension L F ‚•§ LeftExtension (G ‚ãô L) (G ‚ãô F) :=\n  StructuredArrow.map‚ÇÇ (F := ùü≠ _) (G := (whiskeringLeft C' C H).obj G) (ùüô _) (ùüô _)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.precomp_obj_right","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_2} C'\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_3} H\ninst‚úù : CategoryTheory.Category.{u_9, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D H).obj L)\n‚ä¢ Eq ((CategoryTheory.Functor.LeftExtension.precomp L F G).obj X).right X.right","decl":"/-- The functor `LeftExtension L F ‚•§ LeftExtension (G ‚ãô L) (G ‚ãô F)`\nobtained by precomposition. -/\n@[simps!]\ndef LeftExtension.precomp : LeftExtension L F ‚•§ LeftExtension (G ‚ãô L) (G ‚ãô F) :=\n  StructuredArrow.map‚ÇÇ (F := ùü≠ _) (G := (whiskeringLeft C' C H).obj G) (ùüô _) (ùüô _)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.precomp_map_left","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_2} C'\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_3} H\ninst‚úù : CategoryTheory.Category.{u_9, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\nX Y : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D H).obj L)\nœÜ : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Functor.LeftExtension.precomp L F G).map œÜ).left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The functor `LeftExtension L F ‚•§ LeftExtension (G ‚ãô L) (G ‚ãô F)`\nobtained by precomposition. -/\n@[simps!]\ndef LeftExtension.precomp : LeftExtension L F ‚•§ LeftExtension (G ‚ãô L) (G ‚ãô F) :=\n  StructuredArrow.map‚ÇÇ (F := ùü≠ _) (G := (whiskeringLeft C' C H).obj G) (ùüô _) (ùüô _)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.precomp_obj_hom_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_2} C'\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_3} H\ninst‚úù : CategoryTheory.Category.{u_9, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\nX‚úù : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D H).obj L)\nX : C'\n‚ä¢ Eq (((CategoryTheory.Functor.LeftExtension.precomp L F G).obj X‚úù).hom.app X) (X‚úù.hom.app (G.obj X))","decl":"/-- The functor `LeftExtension L F ‚•§ LeftExtension (G ‚ãô L) (G ‚ãô F)`\nobtained by precomposition. -/\n@[simps!]\ndef LeftExtension.precomp : LeftExtension L F ‚•§ LeftExtension (G ‚ãô L) (G ‚ãô F) :=\n  StructuredArrow.map‚ÇÇ (F := ùü≠ _) (G := (whiskeringLeft C' C H).obj G) (ùüô _) (ùüô _)\n\n"}
{"name":"CategoryTheory.Functor.LeftExtension.precomp_obj_left","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_2} C'\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_3} H\ninst‚úù : CategoryTheory.Category.{u_9, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\nX : CategoryTheory.Comma (CategoryTheory.Functor.fromPUnit F) ((CategoryTheory.whiskeringLeft C D H).obj L)\n‚ä¢ Eq ((CategoryTheory.Functor.LeftExtension.precomp L F G).obj X).left X.left","decl":"/-- The functor `LeftExtension L F ‚•§ LeftExtension (G ‚ãô L) (G ‚ãô F)`\nobtained by precomposition. -/\n@[simps!]\ndef LeftExtension.precomp : LeftExtension L F ‚•§ LeftExtension (G ‚ãô L) (G ‚ãô F) :=\n  StructuredArrow.map‚ÇÇ (F := ùü≠ _) (G := (whiskeringLeft C' C H).obj G) (ùüô _) (ùüô _)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.precomp_obj_right","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_2} C'\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_3} H\ninst‚úù : CategoryTheory.Category.{u_9, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\nX : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D H).obj L) (CategoryTheory.Functor.fromPUnit F)\n‚ä¢ Eq ((CategoryTheory.Functor.RightExtension.precomp L F G).obj X).right X.right","decl":"/-- The functor `RightExtension L F ‚•§ RightExtension (G ‚ãô L) (G ‚ãô F)`\nobtained by precomposition. -/\n@[simps!]\ndef RightExtension.precomp : RightExtension L F ‚•§ RightExtension (G ‚ãô L) (G ‚ãô F) :=\n  CostructuredArrow.map‚ÇÇ (F := ùü≠ _) (G := (whiskeringLeft C' C H).obj G) (ùüô _) (ùüô _)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.precomp_map_right","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_2} C'\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_3} H\ninst‚úù : CategoryTheory.Category.{u_9, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\nX Y : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D H).obj L) (CategoryTheory.Functor.fromPUnit F)\nœÜ : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Functor.RightExtension.precomp L F G).map œÜ).right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The functor `RightExtension L F ‚•§ RightExtension (G ‚ãô L) (G ‚ãô F)`\nobtained by precomposition. -/\n@[simps!]\ndef RightExtension.precomp : RightExtension L F ‚•§ RightExtension (G ‚ãô L) (G ‚ãô F) :=\n  CostructuredArrow.map‚ÇÇ (F := ùü≠ _) (G := (whiskeringLeft C' C H).obj G) (ùüô _) (ùüô _)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.precomp_obj_left","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_2} C'\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_3} H\ninst‚úù : CategoryTheory.Category.{u_9, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\nX : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D H).obj L) (CategoryTheory.Functor.fromPUnit F)\n‚ä¢ Eq ((CategoryTheory.Functor.RightExtension.precomp L F G).obj X).left X.left","decl":"/-- The functor `RightExtension L F ‚•§ RightExtension (G ‚ãô L) (G ‚ãô F)`\nobtained by precomposition. -/\n@[simps!]\ndef RightExtension.precomp : RightExtension L F ‚•§ RightExtension (G ‚ãô L) (G ‚ãô F) :=\n  CostructuredArrow.map‚ÇÇ (F := ùü≠ _) (G := (whiskeringLeft C' C H).obj G) (ùüô _) (ùüô _)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.precomp_obj_hom_app","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_2} C'\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_3} H\ninst‚úù : CategoryTheory.Category.{u_9, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\nX‚úù : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D H).obj L) (CategoryTheory.Functor.fromPUnit F)\nX : C'\n‚ä¢ Eq (((CategoryTheory.Functor.RightExtension.precomp L F G).obj X‚úù).hom.app X) (X‚úù.hom.app (G.obj X))","decl":"/-- The functor `RightExtension L F ‚•§ RightExtension (G ‚ãô L) (G ‚ãô F)`\nobtained by precomposition. -/\n@[simps!]\ndef RightExtension.precomp : RightExtension L F ‚•§ RightExtension (G ‚ãô L) (G ‚ãô F) :=\n  CostructuredArrow.map‚ÇÇ (F := ùü≠ _) (G := (whiskeringLeft C' C H).obj G) (ùüô _) (ùüô _)\n\n"}
{"name":"CategoryTheory.Functor.RightExtension.precomp_map_left","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_2} C'\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_3} H\ninst‚úù : CategoryTheory.Category.{u_9, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\nX Y : CategoryTheory.Comma ((CategoryTheory.whiskeringLeft C D H).obj L) (CategoryTheory.Functor.fromPUnit F)\nœÜ : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Functor.RightExtension.precomp L F G).map œÜ).left œÜ.left","decl":"/-- The functor `RightExtension L F ‚•§ RightExtension (G ‚ãô L) (G ‚ãô F)`\nobtained by precomposition. -/\n@[simps!]\ndef RightExtension.precomp : RightExtension L F ‚•§ RightExtension (G ‚ãô L) (G ‚ãô F) :=\n  CostructuredArrow.map‚ÇÇ (F := ùü≠ _) (G := (whiskeringLeft C' C H).obj G) (ùüô _) (ùüô _)\n\n"}
{"name":"CategoryTheory.Functor.instIsEquivalenceLeftExtensionCompPrecomp","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_9, u_2} C'\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} H\ninst‚úù : CategoryTheory.Category.{u_7, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\n‚ä¢ (CategoryTheory.Functor.LeftExtension.precomp L F G).IsEquivalence","decl":"noncomputable instance : IsEquivalence (LeftExtension.precomp L F G) := by\n  apply StructuredArrow.isEquivalenceMap‚ÇÇ\n\n"}
{"name":"CategoryTheory.Functor.instIsEquivalenceRightExtensionCompPrecomp","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_9, u_2} C'\ninst‚úù¬π : CategoryTheory.Category.{u_6, u_3} H\ninst‚úù : CategoryTheory.Category.{u_7, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nG : CategoryTheory.Functor C' C\n‚ä¢ (CategoryTheory.Functor.RightExtension.precomp L F G).IsEquivalence","decl":"noncomputable instance : IsEquivalence (RightExtension.precomp L F G) := by\n  apply CostructuredArrow.isEquivalenceMap‚ÇÇ\n\n"}
{"name":"CategoryTheory.Functor.isLeftKanExtension_iff_precomp","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_7, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_9, u_2} C'\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nF' : CategoryTheory.Functor D H\nG : CategoryTheory.Functor C' C\ninst‚úù : G.IsEquivalence\nŒ± : Quiver.Hom F (L.comp F')\n‚ä¢ Iff (F'.IsLeftKanExtension Œ±) (F'.IsLeftKanExtension (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft G Œ±) (G.associator L F').inv))","decl":"lemma isLeftKanExtension_iff_precomp (Œ± : F ‚ü∂ L ‚ãô F') :\n    F'.IsLeftKanExtension Œ± ‚Üî F'.IsLeftKanExtension\n      (whiskerLeft G Œ± ‚â´ (Functor.associator _ _ _).inv) := by\n  let eq : (LeftExtension.mk _ Œ±).IsUniversal ‚âÉ (LeftExtension.mk _\n      (whiskerLeft G Œ± ‚â´ (Functor.associator _ _ _).inv)).IsUniversal :=\n    (LeftExtension.isUniversalPrecompEquiv L F G _).trans\n    (IsInitial.equivOfIso (StructuredArrow.isoMk (Iso.refl _)))\n  constructor\n  ¬∑ exact fun _ => ‚ü®‚ü®eq (isUniversalOfIsLeftKanExtension _ _)‚ü©‚ü©\n  ¬∑ exact fun _ => ‚ü®‚ü®eq.symm (isUniversalOfIsLeftKanExtension _ _)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Functor.isRightKanExtension_iff_precomp","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nC' : Type u_2\nH : Type u_3\nD : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_7, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_9, u_2} C'\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nF' : CategoryTheory.Functor D H\nG : CategoryTheory.Functor C' C\ninst‚úù : G.IsEquivalence\nŒ± : Quiver.Hom (L.comp F') F\n‚ä¢ Iff (F'.IsRightKanExtension Œ±) (F'.IsRightKanExtension (CategoryTheory.CategoryStruct.comp (G.associator L F').hom (CategoryTheory.whiskerLeft G Œ±)))","decl":"lemma isRightKanExtension_iff_precomp (Œ± : L ‚ãô F' ‚ü∂ F) :\n    F'.IsRightKanExtension Œ± ‚Üî\n      F'.IsRightKanExtension ((Functor.associator _ _ _).hom ‚â´ whiskerLeft G Œ±) := by\n  let eq : (RightExtension.mk _ Œ±).IsUniversal ‚âÉ (RightExtension.mk _\n      ((Functor.associator _ _ _).hom ‚â´ whiskerLeft G Œ±)).IsUniversal :=\n    (RightExtension.isUniversalPrecompEquiv L F G _).trans\n    (IsTerminal.equivOfIso (CostructuredArrow.isoMk (Iso.refl _)))\n  constructor\n  ¬∑ exact fun _ => ‚ü®‚ü®eq (isUniversalOfIsRightKanExtension _ _)‚ü©‚ü©\n  ¬∑ exact fun _ => ‚ü®‚ü®eq.symm (isUniversalOfIsRightKanExtension _ _)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Functor.hasRightExtension_iff_of_iso‚ÇÅ","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù : CategoryTheory.Category.{u_8, u_4} D\nL L' : CategoryTheory.Functor C D\niso‚ÇÅ : CategoryTheory.Iso L L'\nF : CategoryTheory.Functor C H\n‚ä¢ Iff (L.HasRightKanExtension F) (L'.HasRightKanExtension F)","decl":"include iso‚ÇÅ in\nlemma hasRightExtension_iff_of_iso‚ÇÅ : HasRightKanExtension L F ‚Üî HasRightKanExtension L' F :=\n  (rightExtensionEquivalenceOfIso‚ÇÅ iso‚ÇÅ F).hasTerminal_iff\n\n"}
{"name":"CategoryTheory.Functor.hasLeftExtension_iff_of_iso‚ÇÅ","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù : CategoryTheory.Category.{u_8, u_4} D\nL L' : CategoryTheory.Functor C D\niso‚ÇÅ : CategoryTheory.Iso L L'\nF : CategoryTheory.Functor C H\n‚ä¢ Iff (L.HasLeftKanExtension F) (L'.HasLeftKanExtension F)","decl":"include iso‚ÇÅ in\nlemma hasLeftExtension_iff_of_iso‚ÇÅ : HasLeftKanExtension L F ‚Üî HasLeftKanExtension L' F :=\n  (leftExtensionEquivalenceOfIso‚ÇÅ iso‚ÇÅ F).hasInitial_iff\n\n"}
{"name":"CategoryTheory.Functor.hasRightExtension_iff_of_iso‚ÇÇ","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù : CategoryTheory.Category.{u_8, u_4} D\nL : CategoryTheory.Functor C D\nF F' : CategoryTheory.Functor C H\niso‚ÇÇ : CategoryTheory.Iso F F'\n‚ä¢ Iff (L.HasRightKanExtension F) (L.HasRightKanExtension F')","decl":"include iso‚ÇÇ in\nlemma hasRightExtension_iff_of_iso‚ÇÇ : HasRightKanExtension L F ‚Üî HasRightKanExtension L F' :=\n  (rightExtensionEquivalenceOfIso‚ÇÇ L iso‚ÇÇ).hasTerminal_iff\n\n"}
{"name":"CategoryTheory.Functor.hasLeftExtension_iff_of_iso‚ÇÇ","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù : CategoryTheory.Category.{u_8, u_4} D\nL : CategoryTheory.Functor C D\nF F' : CategoryTheory.Functor C H\niso‚ÇÇ : CategoryTheory.Iso F F'\n‚ä¢ Iff (L.HasLeftKanExtension F) (L.HasLeftKanExtension F')","decl":"include iso‚ÇÇ in\nlemma hasLeftExtension_iff_of_iso‚ÇÇ : HasLeftKanExtension L F ‚Üî HasLeftKanExtension L F' :=\n  (leftExtensionEquivalenceOfIso‚ÇÇ L iso‚ÇÇ).hasInitial_iff\n\n"}
{"name":"CategoryTheory.Functor.isLeftKanExtension_iff_of_iso‚ÇÇ","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù : CategoryTheory.Category.{u_6, u_4} D\nL : CategoryTheory.Functor C D\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor C H\nF‚ÇÅ' F‚ÇÇ' : CategoryTheory.Functor D H\nŒ±‚ÇÅ : Quiver.Hom F‚ÇÅ (L.comp F‚ÇÅ')\nŒ±‚ÇÇ : Quiver.Hom F‚ÇÇ (L.comp F‚ÇÇ')\ne : CategoryTheory.Iso F‚ÇÅ F‚ÇÇ\ne' : CategoryTheory.Iso F‚ÇÅ' F‚ÇÇ'\nh : Eq (CategoryTheory.CategoryStruct.comp Œ±‚ÇÅ (CategoryTheory.whiskerLeft L e'.hom)) (CategoryTheory.CategoryStruct.comp e.hom Œ±‚ÇÇ)\n‚ä¢ Iff (F‚ÇÅ'.IsLeftKanExtension Œ±‚ÇÅ) (F‚ÇÇ'.IsLeftKanExtension Œ±‚ÇÇ)","decl":"lemma isLeftKanExtension_iff_of_iso‚ÇÇ {F‚ÇÅ' F‚ÇÇ' : D ‚•§ H} (Œ±‚ÇÅ : F‚ÇÅ ‚ü∂ L ‚ãô F‚ÇÅ') (Œ±‚ÇÇ : F‚ÇÇ ‚ü∂ L ‚ãô F‚ÇÇ')\n    (e : F‚ÇÅ ‚âÖ F‚ÇÇ) (e' : F‚ÇÅ' ‚âÖ F‚ÇÇ') (h : Œ±‚ÇÅ ‚â´ whiskerLeft L e'.hom = e.hom ‚â´ Œ±‚ÇÇ) :\n    F‚ÇÅ'.IsLeftKanExtension Œ±‚ÇÅ ‚Üî F‚ÇÇ'.IsLeftKanExtension Œ±‚ÇÇ := by\n  let eq := LeftExtension.isUniversalEquivOfIso‚ÇÇ (LeftExtension.mk _ Œ±‚ÇÅ)\n    (LeftExtension.mk _ Œ±‚ÇÇ) e e' h\n  constructor\n  ¬∑ exact fun _ => ‚ü®‚ü®eq.1 (isUniversalOfIsLeftKanExtension F‚ÇÅ' Œ±‚ÇÅ)‚ü©‚ü©\n  ¬∑ exact fun _ => ‚ü®‚ü®eq.2 (isUniversalOfIsLeftKanExtension F‚ÇÇ' Œ±‚ÇÇ)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Functor.isRightKanExtension_iff_of_iso‚ÇÇ","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù : CategoryTheory.Category.{u_6, u_4} D\nL : CategoryTheory.Functor C D\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor C H\nF‚ÇÅ' F‚ÇÇ' : CategoryTheory.Functor D H\nŒ±‚ÇÅ : Quiver.Hom (L.comp F‚ÇÅ') F‚ÇÅ\nŒ±‚ÇÇ : Quiver.Hom (L.comp F‚ÇÇ') F‚ÇÇ\ne : CategoryTheory.Iso F‚ÇÅ F‚ÇÇ\ne' : CategoryTheory.Iso F‚ÇÅ' F‚ÇÇ'\nh : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L e'.hom) Œ±‚ÇÇ) (CategoryTheory.CategoryStruct.comp Œ±‚ÇÅ e.hom)\n‚ä¢ Iff (F‚ÇÅ'.IsRightKanExtension Œ±‚ÇÅ) (F‚ÇÇ'.IsRightKanExtension Œ±‚ÇÇ)","decl":"lemma isRightKanExtension_iff_of_iso‚ÇÇ {F‚ÇÅ' F‚ÇÇ' : D ‚•§ H} (Œ±‚ÇÅ : L ‚ãô F‚ÇÅ' ‚ü∂ F‚ÇÅ) (Œ±‚ÇÇ : L ‚ãô F‚ÇÇ' ‚ü∂ F‚ÇÇ)\n    (e : F‚ÇÅ ‚âÖ F‚ÇÇ) (e' : F‚ÇÅ' ‚âÖ F‚ÇÇ') (h : whiskerLeft L e'.hom ‚â´ Œ±‚ÇÇ = Œ±‚ÇÅ ‚â´ e.hom) :\n    F‚ÇÅ'.IsRightKanExtension Œ±‚ÇÅ ‚Üî F‚ÇÇ'.IsRightKanExtension Œ±‚ÇÇ := by\n  let eq := RightExtension.isUniversalEquivOfIso‚ÇÇ (RightExtension.mk _ Œ±‚ÇÅ)\n    (RightExtension.mk _ Œ±‚ÇÇ) e e' h\n  constructor\n  ¬∑ exact fun _ => ‚ü®‚ü®eq.1 (isUniversalOfIsRightKanExtension F‚ÇÅ' Œ±‚ÇÅ)‚ü©‚ü©\n  ¬∑ exact fun _ => ‚ü®‚ü®eq.2 (isUniversalOfIsRightKanExtension F‚ÇÇ' Œ±‚ÇÇ)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Functor.coconeOfIsLeftKanExtension_pt","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\ninst‚úù : F'.IsLeftKanExtension Œ±\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (F'.coconeOfIsLeftKanExtension Œ± c).pt c.pt","decl":"/-- Construct a cocone for a left Kan extension `F' : D ‚•§ H` of `F : C ‚•§ H` along a functor\n`L : C ‚•§ D` given a cocone for `F`. -/\n@[simps]\nnoncomputable def coconeOfIsLeftKanExtension (c : Cocone F) : Cocone F' where\n  pt := c.pt\n  Œπ := F'.descOfIsLeftKanExtension Œ± _ c.Œπ\n\n"}
{"name":"CategoryTheory.Functor.coconeOfIsLeftKanExtension_Œπ","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\ninst‚úù : F'.IsLeftKanExtension Œ±\nc : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq (F'.coconeOfIsLeftKanExtension Œ± c).Œπ (F'.descOfIsLeftKanExtension Œ± ((CategoryTheory.Functor.const D).obj c.pt) c.Œπ)","decl":"/-- Construct a cocone for a left Kan extension `F' : D ‚•§ H` of `F : C ‚•§ H` along a functor\n`L : C ‚•§ D` given a cocone for `F`. -/\n@[simps]\nnoncomputable def coconeOfIsLeftKanExtension (c : Cocone F) : Cocone F' where\n  pt := c.pt\n  Œπ := F'.descOfIsLeftKanExtension Œ± _ c.Œπ\n\n"}
{"name":"CategoryTheory.Functor.isColimitCoconeOfIsLeftKanExtension_desc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\ninst‚úù : F'.IsLeftKanExtension Œ±\nc : CategoryTheory.Limits.Cocone F\nhc : CategoryTheory.Limits.IsColimit c\ns : CategoryTheory.Limits.Cocone F'\n‚ä¢ Eq ((F'.isColimitCoconeOfIsLeftKanExtension Œ± hc).desc s) (hc.desc { pt := s.1, Œπ := CategoryTheory.CategoryStruct.comp Œ± (CategoryTheory.whiskerLeft L s.Œπ) })","decl":"/-- If `c` is a colimit cocone for a functor `F : C ‚•§ H` and `Œ± : F ‚ü∂ L ‚ãô F'` is the unit of any\nleft Kan extension `F' : D ‚•§ H` of `F` along `L : C ‚•§ D`, then `coconeOfIsLeftKanExtension Œ± c` is\na colimit cocone, too. -/\n@[simps]\ndef isColimitCoconeOfIsLeftKanExtension {c : Cocone F} (hc : IsColimit c) :\n    IsColimit (F'.coconeOfIsLeftKanExtension Œ± c) where\n  desc s := hc.desc (Cocone.mk _ (Œ± ‚â´ whiskerLeft L s.Œπ))\n  fac s := by\n    have : F'.descOfIsLeftKanExtension Œ± ((const D).obj c.pt) c.Œπ ‚â´\n        (Functor.const _).map (hc.desc (Cocone.mk _ (Œ± ‚â´ whiskerLeft L s.Œπ))) = s.Œπ :=\n      F'.hom_ext_of_isLeftKanExtension Œ± _ _ (by aesop_cat)\n    exact congr_app this\n  uniq s m hm := hc.hom_ext (fun j ‚Ü¶ by\n    have := hm (L.obj j)\n    nth_rw 1 [‚Üê F'.descOfIsLeftKanExtension_fac_app Œ± ((const D).obj c.pt)]\n    dsimp at this ‚ä¢\n    rw [assoc, this, IsColimit.fac, NatTrans.comp_app, whiskerLeft_app])\n\n"}
{"name":"CategoryTheory.Functor.Œπ_colimitIsoOfIsLeftKanExtension_hom","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_7, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_3} H\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\ninst‚úù¬≤ : F'.IsLeftKanExtension Œ±\ninst‚úù¬π : CategoryTheory.Limits.HasColimit F\ninst‚úù : CategoryTheory.Limits.HasColimit F'\ni : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Œ±.app i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ F' (L.obj i)) (F'.colimitIsoOfIsLeftKanExtension Œ±).hom)) (CategoryTheory.Limits.colimit.Œπ F i)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_colimitIsoOfIsLeftKanExtension_hom (i : C) :\n    Œ±.app i ‚â´ colimit.Œπ F' (L.obj i) ‚â´ (F'.colimitIsoOfIsLeftKanExtension Œ±).hom =\n      colimit.Œπ F i := by\n  simp [colimitIsoOfIsLeftKanExtension]\n\n"}
{"name":"CategoryTheory.Functor.Œπ_colimitIsoOfIsLeftKanExtension_hom_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_7, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_3} H\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\ninst‚úù¬≤ : F'.IsLeftKanExtension Œ±\ninst‚úù¬π : CategoryTheory.Limits.HasColimit F\ninst‚úù : CategoryTheory.Limits.HasColimit F'\ni : C\nZ : H\nh : Quiver.Hom (CategoryTheory.Limits.colimit F) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Œ±.app i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ F' (L.obj i)) (CategoryTheory.CategoryStruct.comp (F'.colimitIsoOfIsLeftKanExtension Œ±).hom h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ F i) h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_colimitIsoOfIsLeftKanExtension_hom (i : C) :\n    Œ±.app i ‚â´ colimit.Œπ F' (L.obj i) ‚â´ (F'.colimitIsoOfIsLeftKanExtension Œ±).hom =\n      colimit.Œπ F i := by\n  simp [colimitIsoOfIsLeftKanExtension]\n\n"}
{"name":"CategoryTheory.Functor.Œπ_colimitIsoOfIsLeftKanExtension_inv_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_7, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_3} H\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\ninst‚úù¬≤ : F'.IsLeftKanExtension Œ±\ninst‚úù¬π : CategoryTheory.Limits.HasColimit F\ninst‚úù : CategoryTheory.Limits.HasColimit F'\ni : C\nZ : H\nh : Quiver.Hom (CategoryTheory.Limits.colimit F') Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ F i) (CategoryTheory.CategoryStruct.comp (F'.colimitIsoOfIsLeftKanExtension Œ±).inv h)) (CategoryTheory.CategoryStruct.comp (Œ±.app i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ F' (L.obj i)) h))","decl":"@[reassoc (attr := simp)]\nlemma Œπ_colimitIsoOfIsLeftKanExtension_inv (i : C) :\n    colimit.Œπ F i ‚â´ (F'.colimitIsoOfIsLeftKanExtension Œ±).inv =\n    Œ±.app i ‚â´ colimit.Œπ F' (L.obj i) := by\n  rw [Iso.comp_inv_eq, assoc, Œπ_colimitIsoOfIsLeftKanExtension_hom]\n\n"}
{"name":"CategoryTheory.Functor.Œπ_colimitIsoOfIsLeftKanExtension_inv","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_7, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_3} H\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom F (L.comp F')\ninst‚úù¬≤ : F'.IsLeftKanExtension Œ±\ninst‚úù¬π : CategoryTheory.Limits.HasColimit F\ninst‚úù : CategoryTheory.Limits.HasColimit F'\ni : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ F i) (F'.colimitIsoOfIsLeftKanExtension Œ±).inv) (CategoryTheory.CategoryStruct.comp (Œ±.app i) (CategoryTheory.Limits.colimit.Œπ F' (L.obj i)))","decl":"@[reassoc (attr := simp)]\nlemma Œπ_colimitIsoOfIsLeftKanExtension_inv (i : C) :\n    colimit.Œπ F i ‚â´ (F'.colimitIsoOfIsLeftKanExtension Œ±).inv =\n    Œ±.app i ‚â´ colimit.Œπ F' (L.obj i) := by\n  rw [Iso.comp_inv_eq, assoc, Œπ_colimitIsoOfIsLeftKanExtension_hom]\n\n"}
{"name":"CategoryTheory.Functor.coneOfIsRightKanExtension_œÄ","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\ninst‚úù : F'.IsRightKanExtension Œ±\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (F'.coneOfIsRightKanExtension Œ± c).œÄ (F'.liftOfIsRightKanExtension Œ± ((CategoryTheory.Functor.const D).obj c.pt) c.œÄ)","decl":"/-- Construct a cone for a right Kan extension `F' : D ‚•§ H` of `F : C ‚•§ H` along a functor\n`L : C ‚•§ D` given a cone for `F`. -/\n@[simps]\nnoncomputable def coneOfIsRightKanExtension (c : Cone F) : Cone F' where\n  pt := c.pt\n  œÄ := F'.liftOfIsRightKanExtension Œ± _ c.œÄ\n\n"}
{"name":"CategoryTheory.Functor.coneOfIsRightKanExtension_pt","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\ninst‚úù : F'.IsRightKanExtension Œ±\nc : CategoryTheory.Limits.Cone F\n‚ä¢ Eq (F'.coneOfIsRightKanExtension Œ± c).pt c.pt","decl":"/-- Construct a cone for a right Kan extension `F' : D ‚•§ H` of `F : C ‚•§ H` along a functor\n`L : C ‚•§ D` given a cone for `F`. -/\n@[simps]\nnoncomputable def coneOfIsRightKanExtension (c : Cone F) : Cone F' where\n  pt := c.pt\n  œÄ := F'.liftOfIsRightKanExtension Œ± _ c.œÄ\n\n"}
{"name":"CategoryTheory.Functor.isLimitConeOfIsRightKanExtension_lift","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_7, u_3} H\ninst‚úù¬π : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\ninst‚úù : F'.IsRightKanExtension Œ±\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\ns : CategoryTheory.Limits.Cone F'\n‚ä¢ Eq ((F'.isLimitConeOfIsRightKanExtension Œ± hc).lift s) (hc.lift { pt := s.1, œÄ := CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft L s.œÄ) Œ± })","decl":"/-- If `c` is a limit cone for a functor `F : C ‚•§ H` and `Œ± : L ‚ãô F' ‚ü∂ F` is the counit of any\nright Kan extension `F' : D ‚•§ H` of `F` along `L : C ‚•§ D`, then `coneOfIsRightKanExtension Œ± c` is\na limit cone, too. -/\n@[simps]\ndef isLimitConeOfIsRightKanExtension {c : Cone F} (hc : IsLimit c) :\n    IsLimit (F'.coneOfIsRightKanExtension Œ± c) where\n  lift s := hc.lift (Cone.mk _ (whiskerLeft L s.œÄ ‚â´ Œ±))\n  fac s := by\n    have : (Functor.const _).map (hc.lift (Cone.mk _ (whiskerLeft L s.œÄ ‚â´ Œ±))) ‚â´\n        F'.liftOfIsRightKanExtension Œ± ((const D).obj c.pt) c.œÄ = s.œÄ :=\n      F'.hom_ext_of_isRightKanExtension Œ± _ _ (by aesop_cat)\n    exact congr_app this\n  uniq s m hm := hc.hom_ext (fun j ‚Ü¶ by\n    have := hm (L.obj j)\n    nth_rw 1 [‚Üê F'.liftOfIsRightKanExtension_fac_app Œ± ((const D).obj c.pt)]\n    dsimp at this ‚ä¢\n    rw [‚Üê assoc, this, IsLimit.fac, NatTrans.comp_app, whiskerLeft_app])\n\n"}
{"name":"CategoryTheory.Functor.limitIsoOfIsRightKanExtension_inv_œÄ","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_7, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_3} H\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\ninst‚úù¬≤ : F'.IsRightKanExtension Œ±\ninst‚úù¬π : CategoryTheory.Limits.HasLimit F\ninst‚úù : CategoryTheory.Limits.HasLimit F'\ni : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F'.limitIsoOfIsRightKanExtension Œ±).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ F' (L.obj i)) (Œ±.app i))) (CategoryTheory.Limits.limit.œÄ F i)","decl":"@[reassoc (attr := simp)]\nlemma limitIsoOfIsRightKanExtension_inv_œÄ (i : C) :\n    (F'.limitIsoOfIsRightKanExtension Œ±).inv ‚â´ limit.œÄ F' (L.obj i) ‚â´ Œ±.app i = limit.œÄ F i := by\n  simp [limitIsoOfIsRightKanExtension]\n\n"}
{"name":"CategoryTheory.Functor.limitIsoOfIsRightKanExtension_inv_œÄ_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_7, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_3} H\ninst‚úù¬≥ : CategoryTheory.Category.{u_8, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\ninst‚úù¬≤ : F'.IsRightKanExtension Œ±\ninst‚úù¬π : CategoryTheory.Limits.HasLimit F\ninst‚úù : CategoryTheory.Limits.HasLimit F'\ni : C\nZ : H\nh : Quiver.Hom (F.obj i) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F'.limitIsoOfIsRightKanExtension Œ±).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ F' (L.obj i)) (CategoryTheory.CategoryStruct.comp (Œ±.app i) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ F i) h)","decl":"@[reassoc (attr := simp)]\nlemma limitIsoOfIsRightKanExtension_inv_œÄ (i : C) :\n    (F'.limitIsoOfIsRightKanExtension Œ±).inv ‚â´ limit.œÄ F' (L.obj i) ‚â´ Œ±.app i = limit.œÄ F i := by\n  simp [limitIsoOfIsRightKanExtension]\n\n"}
{"name":"CategoryTheory.Functor.limitIsoOfIsRightKanExtension_hom_œÄ_assoc","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_3} H\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\ninst‚úù¬≤ : F'.IsRightKanExtension Œ±\ninst‚úù¬π : CategoryTheory.Limits.HasLimit F\ninst‚úù : CategoryTheory.Limits.HasLimit F'\ni : C\nZ : H\nh : Quiver.Hom (F.obj i) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F'.limitIsoOfIsRightKanExtension Œ±).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ F i) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ F' (L.obj i)) (CategoryTheory.CategoryStruct.comp (Œ±.app i) h))","decl":"@[reassoc (attr := simp)]\nlemma limitIsoOfIsRightKanExtension_hom_œÄ (i : C) :\n    (F'.limitIsoOfIsRightKanExtension Œ±).hom ‚â´ limit.œÄ F i = limit.œÄ F' (L.obj i) ‚â´ Œ±.app i := by\n  rw [‚Üê Iso.eq_inv_comp, limitIsoOfIsRightKanExtension_inv_œÄ]\n\n"}
{"name":"CategoryTheory.Functor.limitIsoOfIsRightKanExtension_hom_œÄ","module":"Mathlib.CategoryTheory.Functor.KanExtension.Basic","initialProofState":"C : Type u_1\nH : Type u_3\nD : Type u_4\ninst‚úù‚Åµ : CategoryTheory.Category.{u_8, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_3} H\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_4} D\nF' : CategoryTheory.Functor D H\nL : CategoryTheory.Functor C D\nF : CategoryTheory.Functor C H\nŒ± : Quiver.Hom (L.comp F') F\ninst‚úù¬≤ : F'.IsRightKanExtension Œ±\ninst‚úù¬π : CategoryTheory.Limits.HasLimit F\ninst‚úù : CategoryTheory.Limits.HasLimit F'\ni : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F'.limitIsoOfIsRightKanExtension Œ±).hom (CategoryTheory.Limits.limit.œÄ F i)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ F' (L.obj i)) (Œ±.app i))","decl":"@[reassoc (attr := simp)]\nlemma limitIsoOfIsRightKanExtension_hom_œÄ (i : C) :\n    (F'.limitIsoOfIsRightKanExtension Œ±).hom ‚â´ limit.œÄ F i = limit.œÄ F' (L.obj i) ‚â´ Œ±.app i := by\n  rw [‚Üê Iso.eq_inv_comp, limitIsoOfIsRightKanExtension_inv_œÄ]\n\n"}
