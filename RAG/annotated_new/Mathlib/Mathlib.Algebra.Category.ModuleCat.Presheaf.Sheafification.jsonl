{"name":"PresheafOfModules.sheafification_map","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafification","initialProofState":"C : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\ninst✝¹ : J.WEqualsLocallyBijective AddCommGrp\ninst✝ : CategoryTheory.HasWeakSheafify J AddCommGrp\nX✝ Y✝ : PresheafOfModules R₀\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((PresheafOfModules.sheafification α).map f) (PresheafOfModules.sheafifyMap α (CategoryTheory.toSheafify J X✝.presheaf) (CategoryTheory.toSheafify J Y✝.presheaf) f ((CategoryTheory.presheafToSheaf J AddCommGrp).map ((PresheafOfModules.toPresheaf R₀).map f)) ⋯)","decl":"/-- Given a locally bijective morphism `α : R₀ ⟶ R.val` where `R₀` is a presheaf of rings\nand `R` a sheaf of rings (i.e. `R` identifies to the sheafification of `R₀`), this is\nthe associated sheaf of modules functor `PresheafOfModules.{v} R₀ ⥤ SheafOfModules.{v} R`. -/\n@[simps! (config := .lemmasOnly) map]\nnoncomputable def sheafification : PresheafOfModules.{v} R₀ ⥤ SheafOfModules.{v} R where\n  obj M₀ := sheafify α (CategoryTheory.toSheafify J M₀.presheaf)\n  map f := sheafifyMap _ _ _ f\n    ((toPresheaf R₀ ⋙ presheafToSheaf J AddCommGrp).map f)\n      (by apply toSheafify_naturality)\n  map_id M₀ := by\n    ext1\n    apply (toPresheaf _).map_injective\n    simp\n    rfl\n  map_comp _ _ := by\n    ext1\n    apply (toPresheaf _).map_injective\n    simp\n    rfl\n\n"}
{"name":"PresheafOfModules.toPresheaf_map_sheafificationHomEquiv_def","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafification","initialProofState":"C : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\ninst✝¹ : J.WEqualsLocallyBijective AddCommGrp\ninst✝ : CategoryTheory.HasWeakSheafify J AddCommGrp\nP : PresheafOfModules R₀\nF : SheafOfModules R\nf : Quiver.Hom ((PresheafOfModules.sheafification α).obj P) F\n⊢ Eq ((PresheafOfModules.toPresheaf R₀).map ((PresheafOfModules.sheafificationHomEquiv α) f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.toSheafify J P.presheaf) ((PresheafOfModules.toPresheaf R.val).map f.val))","decl":"lemma toPresheaf_map_sheafificationHomEquiv_def\n    {P : PresheafOfModules.{v} R₀} {F : SheafOfModules.{v} R}\n    (f : (sheafification α).obj P ⟶ F) :\n    (toPresheaf R₀).map (sheafificationHomEquiv α f) =\n      CategoryTheory.toSheafify J P.presheaf ≫ (toPresheaf R.val).map f.val := rfl\n\n"}
{"name":"PresheafOfModules.toPresheaf_map_sheafificationHomEquiv","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafification","initialProofState":"C : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\ninst✝¹ : J.WEqualsLocallyBijective AddCommGrp\ninst✝ : CategoryTheory.HasWeakSheafify J AddCommGrp\nP : PresheafOfModules R₀\nF : SheafOfModules R\nf : Quiver.Hom ((PresheafOfModules.sheafification α).obj P) F\n⊢ Eq ((PresheafOfModules.toPresheaf R₀).map ((PresheafOfModules.sheafificationHomEquiv α) f)) (((CategoryTheory.sheafificationAdjunction J AddCommGrp).homEquiv P.presheaf ((SheafOfModules.toSheaf R).obj F)) ((SheafOfModules.toSheaf R).map f))","decl":"lemma toPresheaf_map_sheafificationHomEquiv\n    {P : PresheafOfModules.{v} R₀} {F : SheafOfModules.{v} R}\n    (f : (sheafification α).obj P ⟶ F) :\n    (toPresheaf R₀).map (sheafificationHomEquiv α f) =\n      (sheafificationAdjunction J AddCommGrp).homEquiv P.presheaf\n        ((SheafOfModules.toSheaf _).obj F) ((SheafOfModules.toSheaf _).map f) := by\n  rw [toPresheaf_map_sheafificationHomEquiv_def, Adjunction.homEquiv_unit]\n  dsimp\n\n"}
{"name":"PresheafOfModules.toSheaf_map_sheafificationHomEquiv_symm","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafification","initialProofState":"C : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\ninst✝¹ : J.WEqualsLocallyBijective AddCommGrp\ninst✝ : CategoryTheory.HasWeakSheafify J AddCommGrp\nP : PresheafOfModules R₀\nF : SheafOfModules R\ng : Quiver.Hom P ((PresheafOfModules.restrictScalars α).obj ((SheafOfModules.forget R).obj F))\n⊢ Eq ((SheafOfModules.toSheaf R).map ((PresheafOfModules.sheafificationHomEquiv α).symm g)) (((CategoryTheory.sheafificationAdjunction J AddCommGrp).homEquiv P.presheaf ((SheafOfModules.toSheaf R).obj F)).symm ((PresheafOfModules.toPresheaf R₀).map g))","decl":"lemma toSheaf_map_sheafificationHomEquiv_symm\n    {P : PresheafOfModules.{v} R₀} {F : SheafOfModules.{v} R}\n    (g : P ⟶ (restrictScalars α).obj ((SheafOfModules.forget _).obj F)) :\n    (SheafOfModules.toSheaf _).map ((sheafificationHomEquiv α).symm g) =\n      (((sheafificationAdjunction J AddCommGrp).homEquiv\n        P.presheaf ((SheafOfModules.toSheaf R).obj F)).symm ((toPresheaf R₀).map g)) := by\n  obtain ⟨f, rfl⟩ := (sheafificationHomEquiv α).surjective g\n  apply ((sheafificationAdjunction J AddCommGrp).homEquiv _ _).injective\n  rw [Equiv.apply_symm_apply, Adjunction.homEquiv_unit, Equiv.symm_apply_apply]\n  rfl\n\n"}
{"name":"PresheafOfModules.sheafificationAdjunction_homEquiv_apply","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafification","initialProofState":"C : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\ninst✝¹ : J.WEqualsLocallyBijective AddCommGrp\ninst✝ : CategoryTheory.HasWeakSheafify J AddCommGrp\nP : PresheafOfModules R₀\nF : SheafOfModules R\nf : Quiver.Hom ((PresheafOfModules.sheafification α).obj P) F\n⊢ Eq (((PresheafOfModules.sheafificationAdjunction α).homEquiv P F) f) ((PresheafOfModules.sheafificationHomEquiv α) f)","decl":"lemma sheafificationAdjunction_homEquiv_apply {P : PresheafOfModules.{v} R₀}\n    {F : SheafOfModules.{v} R} (f : (sheafification α).obj P ⟶ F) :\n    (sheafificationAdjunction α).homEquiv P F f = sheafificationHomEquiv α f := rfl\n\n"}
{"name":"PresheafOfModules.toPresheaf_map_sheafificationAdjunction_unit_app","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafification","initialProofState":"C : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\ninst✝¹ : J.WEqualsLocallyBijective AddCommGrp\ninst✝ : CategoryTheory.HasWeakSheafify J AddCommGrp\nM₀ : PresheafOfModules R₀\n⊢ Eq ((PresheafOfModules.toPresheaf R₀).map ((PresheafOfModules.sheafificationAdjunction α).unit.app M₀)) (CategoryTheory.toSheafify J M₀.presheaf)","decl":"@[simp]\nlemma toPresheaf_map_sheafificationAdjunction_unit_app (M₀ : PresheafOfModules.{v} R₀) :\n    (toPresheaf _).map ((sheafificationAdjunction α).unit.app M₀) =\n      CategoryTheory.toSheafify J M₀.presheaf := rfl\n\n"}
{"name":"PresheafOfModules.instIsLeftAdjointSheafOfModulesSheafification","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafification","initialProofState":"C : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\ninst✝¹ : J.WEqualsLocallyBijective AddCommGrp\ninst✝ : CategoryTheory.HasWeakSheafify J AddCommGrp\n⊢ (PresheafOfModules.sheafification α).IsLeftAdjoint","decl":"instance : (sheafification.{v} α).IsLeftAdjoint :=\n  (sheafificationAdjunction α).isLeftAdjoint\n\n"}
{"name":"PresheafOfModules.instPreservesFiniteLimitsSheafAddCommGrpCompSheafOfModulesSheafificationToSheaf","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafification","initialProofState":"C : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\ninst✝¹ : J.WEqualsLocallyBijective AddCommGrp\ninst✝ : CategoryTheory.HasSheafify J AddCommGrp\n⊢ CategoryTheory.Limits.PreservesFiniteLimits ((PresheafOfModules.sheafification α).comp (SheafOfModules.toSheaf R))","decl":"noncomputable instance :\n    PreservesFiniteLimits (sheafification.{v} α ⋙ SheafOfModules.toSheaf.{v} R) :=\n  comp_preservesFiniteLimits (toPresheaf.{v} R₀) (presheafToSheaf J AddCommGrp)\n\n"}
{"name":"PresheafOfModules.instReflectsIsomorphismsSheafOfModulesFunctorOppositeAddCommGrpCompSheafToSheafSheafToPresheaf","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafification","initialProofState":"C : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\n⊢ ((SheafOfModules.toSheaf R).comp (CategoryTheory.sheafToPresheaf J AddCommGrp)).ReflectsIsomorphisms","decl":"instance : (SheafOfModules.toSheaf.{v} R ⋙ sheafToPresheaf _ _).ReflectsIsomorphisms :=\n  inferInstanceAs (SheafOfModules.forget.{v} R ⋙ toPresheaf _).ReflectsIsomorphisms\n\n"}
{"name":"PresheafOfModules.instReflectsIsomorphismsSheafOfModulesSheafAddCommGrpToSheaf","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafification","initialProofState":"C : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\n⊢ (SheafOfModules.toSheaf R).ReflectsIsomorphisms","decl":"instance : (SheafOfModules.toSheaf.{v} R).ReflectsIsomorphisms :=\n  reflectsIsomorphisms_of_comp (SheafOfModules.toSheaf.{v} R) (sheafToPresheaf J _)\n\n"}
{"name":"PresheafOfModules.instReflectsFiniteLimitsSheafOfModulesSheafAddCommGrpToSheaf","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafification","initialProofState":"C : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR : CategoryTheory.Sheaf J RingCat\n⊢ CategoryTheory.Limits.ReflectsFiniteLimits (SheafOfModules.toSheaf R)","decl":"noncomputable instance : ReflectsFiniteLimits (SheafOfModules.toSheaf.{v} R) where\n  reflects _ _ _ := inferInstance\n\n"}
{"name":"PresheafOfModules.instPreservesFiniteLimitsSheafOfModulesSheafification","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf.Sheafification","initialProofState":"C : Type u'\ninst✝⁴ : CategoryTheory.Category.{v', u'} C\nJ : CategoryTheory.GrothendieckTopology C\nR₀ : CategoryTheory.Functor (Opposite C) RingCat\nR : CategoryTheory.Sheaf J RingCat\nα : Quiver.Hom R₀ R.val\ninst✝³ : CategoryTheory.Presheaf.IsLocallyInjective J α\ninst✝² : CategoryTheory.Presheaf.IsLocallySurjective J α\ninst✝¹ : J.WEqualsLocallyBijective AddCommGrp\ninst✝ : CategoryTheory.HasSheafify J AddCommGrp\n⊢ CategoryTheory.Limits.PreservesFiniteLimits (PresheafOfModules.sheafification α)","decl":"noncomputable instance : PreservesFiniteLimits (sheafification.{v} α) :=\n  preservesFiniteLimits_of_reflects_of_preserves\n    (sheafification.{v} α) (SheafOfModules.toSheaf.{v} R)\n\n"}
