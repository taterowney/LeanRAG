{"name":"AlgebraicGeometry.isOpenImmersion_SpecMap_iff_of_surjective","module":"Mathlib.AlgebraicGeometry.Morphisms.OpenImmersion","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\nhf : Function.Surjective ⇑(CommRingCat.Hom.hom f)\n⊢ Iff (AlgebraicGeometry.IsOpenImmersion (AlgebraicGeometry.Spec.map f)) (Exists fun e => And (IsIdempotentElem e) (Eq (RingHom.ker (CommRingCat.Hom.hom f)) (Ideal.span (Singleton.singleton e))))","decl":"/-- `Spec (R ⧸ I) ⟶ Spec R` is an open immersion iff `I` is generated by an idempotent. -/\nlemma isOpenImmersion_SpecMap_iff_of_surjective {R S : CommRingCat}\n    (f : R ⟶ S) (hf : Function.Surjective f.hom) :\n    IsOpenImmersion (Spec.map f) ↔\n    ∃ e, IsIdempotentElem e ∧ RingHom.ker f.hom = Ideal.span {e} := by\n  constructor\n  · intro H\n    obtain ⟨e, he, he'⟩ := PrimeSpectrum.isClopen_iff_zeroLocus.mp\n      ⟨PrimeSpectrum.isClosed_range_comap_of_surjective _ _ hf,\n        (Spec.map f).isOpenEmbedding.isOpen_range⟩\n    refine ⟨e, he, ?_⟩\n    let φ : R ⟶ _ := (CommRingCat.ofHom (Ideal.Quotient.mk (.span {e})))\n    have : IsOpenImmersion (Spec.map φ) :=\n      have : IsLocalization.Away (1 - e) (↑R ⧸ Ideal.span {e}) :=\n        IsLocalization.away_of_isIdempotentElem he.one_sub (by simp) Ideal.Quotient.mk_surjective\n      IsOpenImmersion.of_isLocalization (1 - e)\n    have H : Set.range (Spec.map φ).base = Set.range (Spec.map f).base :=\n      ((PrimeSpectrum.range_comap_of_surjective _ _\n        Ideal.Quotient.mk_surjective).trans (by simp [φ])).trans he'.symm\n    let i : S ≅ .of _ := (Scheme.Spec.preimageIso\n      (IsOpenImmersion.isoOfRangeEq (Spec.map φ) (Spec.map f) H)).unop\n    have hi : Function.Injective i.inv.hom := (ConcreteCategory.bijective_of_isIso i.inv).1\n    have : f = φ ≫ i.inv := by apply Spec.map_injective; simp [i, ← Scheme.Spec_map]\n    rw [this, CommRingCat.hom_comp, RingHom.ker_eq_comap_bot, ← Ideal.comap_comap,\n      ← RingHom.ker_eq_comap_bot, (RingHom.injective_iff_ker_eq_bot i.inv.hom).mp hi,\n      ← RingHom.ker_eq_comap_bot]\n    simp [φ]\n  · rintro ⟨e, he, he'⟩\n    letI := f.hom.toAlgebra\n    have : IsLocalization.Away (1 - e) S :=\n      IsLocalization.away_of_isIdempotentElem he.one_sub (by simpa using he') hf\n    exact IsOpenImmersion.of_isLocalization (1 - e)\n\n"}
{"name":"AlgebraicGeometry.isOpenImmersion_iff_stalk","module":"Mathlib.AlgebraicGeometry.Morphisms.OpenImmersion","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n⊢ Iff (AlgebraicGeometry.IsOpenImmersion f) (And (Topology.IsOpenEmbedding ⇑f.base) (∀ (x : ↑↑X.toPresheafedSpace), CategoryTheory.IsIso (AlgebraicGeometry.Scheme.Hom.stalkMap f x)))","decl":"theorem isOpenImmersion_iff_stalk {f : X ⟶ Y} : IsOpenImmersion f ↔\n    IsOpenEmbedding f.base ∧ ∀ x, IsIso (f.stalkMap x) := by\n  constructor\n  · intro h; exact ⟨h.1, inferInstance⟩\n  · rintro ⟨h₁, h₂⟩; exact IsOpenImmersion.of_stalk_iso f h₁\n\n"}
{"name":"AlgebraicGeometry.isOpenImmersion_eq_inf","module":"Mathlib.AlgebraicGeometry.Morphisms.OpenImmersion","initialProofState":"⊢ Eq (@AlgebraicGeometry.IsOpenImmersion) (Min.min (AlgebraicGeometry.topologically fun {α β} [TopologicalSpace α] [TopologicalSpace β] => Topology.IsOpenEmbedding) (AlgebraicGeometry.stalkwise fun {R S} [CommRing R] [CommRing S] f => Function.Bijective ⇑f))","decl":"theorem isOpenImmersion_eq_inf :\n    @IsOpenImmersion = (topologically IsOpenEmbedding) ⊓\n      stalkwise (fun f ↦ Function.Bijective f) := by\n  ext\n  exact isOpenImmersion_iff_stalk.trans\n    (and_congr Iff.rfl (forall_congr' fun x ↦ ConcreteCategory.isIso_iff_bijective _))\n\n"}
{"name":"AlgebraicGeometry.instIsLocalAtTargetStalkwiseBijectiveCoeRingHom","module":"Mathlib.AlgebraicGeometry.Morphisms.OpenImmersion","initialProofState":"⊢ AlgebraicGeometry.IsLocalAtTarget (AlgebraicGeometry.stalkwise fun {R S} [CommRing R] [CommRing S] f => Function.Bijective ⇑f)","decl":"instance : IsLocalAtTarget (stalkwise (fun f ↦ Function.Bijective f)) := by\n  apply stalkwiseIsLocalAtTarget_of_respectsIso\n  rw [RingHom.toMorphismProperty_respectsIso_iff]\n  convert (inferInstanceAs (MorphismProperty.isomorphisms CommRingCat).RespectsIso)\n  ext\n  exact (ConcreteCategory.isIso_iff_bijective _).symm\n\n"}
{"name":"AlgebraicGeometry.isOpenImmersion_isLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.OpenImmersion","initialProofState":"⊢ AlgebraicGeometry.IsLocalAtTarget @AlgebraicGeometry.IsOpenImmersion","decl":"instance isOpenImmersion_isLocalAtTarget : IsLocalAtTarget @IsOpenImmersion :=\n  isOpenImmersion_eq_inf ▸ inferInstance\n\n"}
