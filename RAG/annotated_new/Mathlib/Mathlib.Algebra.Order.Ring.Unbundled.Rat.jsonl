{"name":"Rat.divInt_nonneg_iff_of_pos_right","module":"Mathlib.Algebra.Order.Ring.Unbundled.Rat","initialProofState":"a b : Int\nhb : LT.lt 0 b\n⊢ Iff (LE.le 0 (Rat.divInt a b)) (LE.le 0 a)","decl":"@[simp] lemma divInt_nonneg_iff_of_pos_right {a b : ℤ} (hb : 0 < b) : 0 ≤ a /. b ↔ 0 ≤ a := by\n  cases' hab : a /. b with n d hd hnd\n  rw [mk'_eq_divInt, divInt_eq_iff hb.ne' (mod_cast hd)] at hab\n  rw [← num_nonneg, ← Int.mul_nonneg_iff_of_pos_right hb, ← hab,\n    Int.mul_nonneg_iff_of_pos_right (mod_cast Nat.pos_of_ne_zero hd)]\n\n"}
{"name":"Rat.divInt_nonneg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Rat","initialProofState":"a b : Int\nha : LE.le 0 a\nhb : LE.le 0 b\n⊢ LE.le 0 (Rat.divInt a b)","decl":"@[simp] lemma divInt_nonneg {a b : ℤ} (ha : 0 ≤ a) (hb : 0 ≤ b) : 0 ≤ a /. b := by\n  obtain rfl | hb := hb.eq_or_lt\n  · simp\n    rfl\n  rwa [divInt_nonneg_iff_of_pos_right hb]\n\n"}
{"name":"Rat.mkRat_nonneg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Rat","initialProofState":"a : Int\nha : LE.le 0 a\nb : Nat\n⊢ LE.le 0 (mkRat a b)","decl":"@[simp] lemma mkRat_nonneg {a : ℤ} (ha : 0 ≤ a) (b : ℕ) : 0 ≤ mkRat a b := by\n  simpa using divInt_nonneg ha (Int.natCast_nonneg _)\n\n"}
{"name":"Rat.ofScientific_nonneg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Rat","initialProofState":"m : Nat\ns : Bool\ne : Nat\n⊢ LE.le 0 (Rat.ofScientific m s e)","decl":"theorem ofScientific_nonneg (m : ℕ) (s : Bool) (e : ℕ) :\n    0 ≤ Rat.ofScientific m s e := by\n  rw [Rat.ofScientific]\n  cases s\n  · rw [if_neg (by decide)]\n    refine num_nonneg.mp ?_\n    rw [num_natCast]\n    exact Int.natCast_nonneg _\n  · rw [if_pos rfl, normalize_eq_mkRat]\n    exact Rat.mkRat_nonneg (Int.natCast_nonneg _) _\n\n"}
{"name":"NNRat.cast_ofScientific","module":"Mathlib.Algebra.Order.Ring.Unbundled.Rat","initialProofState":"K : Type u_1\ninst✝ : NNRatCast K\nm : Nat\ns : Bool\ne : Nat\n⊢ Eq (↑(OfScientific.ofScientific m s e)) (OfScientific.ofScientific m s e)","decl":"/-- Casting a scientific literal via `ℚ≥0` is the same as casting directly. -/\n@[simp, norm_cast]\ntheorem _root_.NNRat.cast_ofScientific {K} [NNRatCast K] (m : ℕ) (s : Bool) (e : ℕ) :\n    (OfScientific.ofScientific m s e : ℚ≥0) = (OfScientific.ofScientific m s e : K) :=\n  rfl\n\n"}
{"name":"Rat.add_nonneg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Rat","initialProofState":"a b : Rat\na✝¹ : LE.le 0 a\na✝ : LE.le 0 b\n⊢ LE.le 0 (HAdd.hAdd a b)","decl":"protected lemma add_nonneg : 0 ≤ a → 0 ≤ b → 0 ≤ a + b :=\n  numDenCasesOn' a fun n₁ d₁ h₁ ↦ numDenCasesOn' b fun n₂ d₂ h₂ ↦ by\n    have d₁0 : 0 < (d₁ : ℤ) := mod_cast Nat.pos_of_ne_zero h₁\n    have d₂0 : 0 < (d₂ : ℤ) := mod_cast Nat.pos_of_ne_zero h₂\n    simp only [d₁0, d₂0, h₁, h₂, Int.mul_pos, divInt_nonneg_iff_of_pos_right, divInt_add_divInt, Ne,\n      Nat.cast_eq_zero, not_false_iff]\n    intro n₁0 n₂0\n    apply Int.add_nonneg <;> apply Int.mul_nonneg <;> · first | assumption | apply Int.ofNat_zero_le\n\n"}
{"name":"Rat.mul_nonneg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Rat","initialProofState":"a b : Rat\na✝¹ : LE.le 0 a\na✝ : LE.le 0 b\n⊢ LE.le 0 (HMul.hMul a b)","decl":"protected lemma mul_nonneg : 0 ≤ a → 0 ≤ b → 0 ≤ a * b :=\n  numDenCasesOn' a fun n₁ d₁ h₁ =>\n    numDenCasesOn' b fun n₂ d₂ h₂ => by\n      have d₁0 : 0 < (d₁ : ℤ) := mod_cast Nat.pos_of_ne_zero h₁\n      have d₂0 : 0 < (d₂ : ℤ) := mod_cast Nat.pos_of_ne_zero h₂\n      simp only [d₁0, d₂0, Int.mul_pos, divInt_nonneg_iff_of_pos_right,\n        divInt_mul_divInt _ _ d₁0.ne' d₂0.ne']\n      apply Int.mul_nonneg\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO can this be shortened?\n"}
{"name":"Rat.le_iff_sub_nonneg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Rat","initialProofState":"a b : Rat\n⊢ Iff (LE.le a b) (LE.le 0 (HSub.hSub b a))","decl":"protected theorem le_iff_sub_nonneg (a b : ℚ) : a ≤ b ↔ 0 ≤ b - a :=\n  numDenCasesOn'' a fun na da ha hared =>\n    numDenCasesOn'' b fun nb db hb hbred => by\n      change Rat.blt _ _ = false ↔ _\n      unfold Rat.blt\n      simp only [Bool.and_eq_true, decide_eq_true_eq, Bool.ite_eq_false_distrib,\n        decide_eq_false_iff_not, not_lt, ite_eq_left_iff, not_and, not_le, ← num_nonneg]\n      split_ifs with h h'\n      · rw [Rat.sub_def]\n        simp only [false_iff, not_le, reduceCtorEq]\n        simp only [normalize_eq]\n        apply Int.ediv_neg'\n        · rw [sub_neg]\n          apply lt_of_lt_of_le\n          · apply Int.mul_neg_of_neg_of_pos h.1\n            rwa [Int.natCast_pos, Nat.pos_iff_ne_zero]\n          · apply Int.mul_nonneg h.2 (Int.natCast_nonneg _)\n        · simp only [Int.natCast_pos, Nat.pos_iff_ne_zero]\n          exact Nat.gcd_ne_zero_right (Nat.mul_ne_zero hb ha)\n      · simp [h']\n      · simp only [Rat.sub_def, normalize_eq]\n        refine ⟨fun H => ?_, fun H _ => ?_⟩\n        · refine Int.ediv_nonneg ?_ (Int.natCast_nonneg _)\n          rw [Int.sub_nonneg]\n          obtain hb|hb := Ne.lt_or_lt h'\n          · apply H\n            intro H'\n            exact (hb.trans H').false.elim\n          · obtain ha|ha := le_or_lt na 0\n            · apply le_trans <| Int.mul_nonpos_of_nonpos_of_nonneg ha (Int.natCast_nonneg _)\n              exact Int.mul_nonneg hb.le (Int.natCast_nonneg _)\n            · exact H (fun _ => ha)\n        · rw [← Int.sub_nonneg]\n          contrapose! H\n          apply Int.ediv_neg' H\n          simp only [Int.natCast_pos, Nat.pos_iff_ne_zero]\n          exact Nat.gcd_ne_zero_right (Nat.mul_ne_zero hb ha)\n\n"}
{"name":"Rat.divInt_le_divInt","module":"Mathlib.Algebra.Order.Ring.Unbundled.Rat","initialProofState":"a b c d : Int\nb0 : LT.lt 0 b\nd0 : LT.lt 0 d\n⊢ Iff (LE.le (Rat.divInt a b) (Rat.divInt c d)) (LE.le (HMul.hMul a d) (HMul.hMul c b))","decl":"protected lemma divInt_le_divInt {a b c d : ℤ} (b0 : 0 < b) (d0 : 0 < d) :\n    a /. b ≤ c /. d ↔ a * d ≤ c * b := by\n  rw [Rat.le_iff_sub_nonneg, ← Int.sub_nonneg]\n  simp [sub_eq_add_neg, ne_of_gt b0, ne_of_gt d0, Int.mul_pos d0 b0]\n\n"}
{"name":"Rat.le_total","module":"Mathlib.Algebra.Order.Ring.Unbundled.Rat","initialProofState":"a b : Rat\n⊢ Or (LE.le a b) (LE.le b a)","decl":"protected lemma le_total : a ≤ b ∨ b ≤ a := by\n  simpa only [← Rat.le_iff_sub_nonneg, neg_sub] using Rat.nonneg_total (b - a)\n\n"}
{"name":"Rat.not_le","module":"Mathlib.Algebra.Order.Ring.Unbundled.Rat","initialProofState":"a b : Rat\n⊢ Iff (Not (LE.le a b)) (LT.lt b a)","decl":"protected theorem not_le {a b : ℚ} : ¬a ≤ b ↔ b < a := (Bool.not_eq_false _).to_iff\n\n"}
{"name":"Rat.le_def","module":"Mathlib.Algebra.Order.Ring.Unbundled.Rat","initialProofState":"p q : Rat\n⊢ Iff (LE.le p q) (LE.le (HMul.hMul p.num ↑q.den) (HMul.hMul q.num ↑p.den))","decl":"protected lemma le_def : p ≤ q ↔ p.num * q.den ≤ q.num * p.den := by\n  rw [← num_divInt_den q, ← num_divInt_den p]\n  conv_rhs => simp only [num_divInt_den]\n  exact Rat.divInt_le_divInt (mod_cast p.pos) (mod_cast q.pos)\n\n"}
{"name":"Rat.lt_def","module":"Mathlib.Algebra.Order.Ring.Unbundled.Rat","initialProofState":"p q : Rat\n⊢ Iff (LT.lt p q) (LT.lt (HMul.hMul p.num ↑q.den) (HMul.hMul q.num ↑p.den))","decl":"protected lemma lt_def : p < q ↔ p.num * q.den < q.num * p.den := by\n  rw [lt_iff_le_and_ne, Rat.le_def]\n  suffices p ≠ q ↔ p.num * q.den ≠ q.num * p.den by\n    constructor <;> intro h\n    · exact lt_iff_le_and_ne.mpr ⟨h.left, this.mp h.right⟩\n    · have tmp := lt_iff_le_and_ne.mp h\n      exact ⟨tmp.left, this.mpr tmp.right⟩\n  exact not_iff_not.mpr eq_iff_mul_eq_mul\n\n"}
{"name":"Rat.add_le_add_left","module":"Mathlib.Algebra.Order.Ring.Unbundled.Rat","initialProofState":"a b c : Rat\n⊢ Iff (LE.le (HAdd.hAdd c a) (HAdd.hAdd c b)) (LE.le a b)","decl":"protected theorem add_le_add_left {a b c : ℚ} : c + a ≤ c + b ↔ a ≤ b := by\n  rw [Rat.le_iff_sub_nonneg, add_sub_add_left_eq_sub, ← Rat.le_iff_sub_nonneg]\n\n"}
{"name":"Rat.instAddLeftMono","module":"Mathlib.Algebra.Order.Ring.Unbundled.Rat","initialProofState":"⊢ AddLeftMono Rat","decl":"instance : AddLeftMono ℚ where\n  elim := fun _ _ _ h => Rat.add_le_add_left.2 h\n\n"}
{"name":"Rat.num_nonpos","module":"Mathlib.Algebra.Order.Ring.Unbundled.Rat","initialProofState":"a : Rat\n⊢ Iff (LE.le a.num 0) (LE.le a 0)","decl":"@[simp] lemma num_nonpos {a : ℚ} : a.num ≤ 0 ↔ a ≤ 0 := by\n  simp [Int.le_iff_lt_or_eq, instLE, Rat.blt, Int.not_lt]\n"}
{"name":"Rat.num_pos","module":"Mathlib.Algebra.Order.Ring.Unbundled.Rat","initialProofState":"a : Rat\n⊢ Iff (LT.lt 0 a.num) (LT.lt 0 a)","decl":"@[simp] lemma num_pos {a : ℚ} : 0 < a.num ↔ 0 < a := lt_iff_lt_of_le_iff_le num_nonpos\n"}
{"name":"Rat.num_neg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Rat","initialProofState":"a : Rat\n⊢ Iff (LT.lt a.num 0) (LT.lt a 0)","decl":"@[simp] lemma num_neg {a : ℚ} : a.num < 0 ↔ a < 0 := lt_iff_lt_of_le_iff_le num_nonneg\n\n"}
{"name":"Rat.div_lt_div_iff_mul_lt_mul","module":"Mathlib.Algebra.Order.Ring.Unbundled.Rat","initialProofState":"a b c d : Int\nb_pos : LT.lt 0 b\nd_pos : LT.lt 0 d\n⊢ Iff (LT.lt (HDiv.hDiv ↑a ↑b) (HDiv.hDiv ↑c ↑d)) (LT.lt (HMul.hMul a d) (HMul.hMul c b))","decl":"theorem div_lt_div_iff_mul_lt_mul {a b c d : ℤ} (b_pos : 0 < b) (d_pos : 0 < d) :\n    (a : ℚ) / b < c / d ↔ a * d < c * b := by\n  simp only [lt_iff_le_not_le]\n  apply and_congr\n  · simp [div_def', Rat.divInt_le_divInt b_pos d_pos]\n  · apply not_congr\n    simp [div_def', Rat.divInt_le_divInt d_pos b_pos]\n\n"}
{"name":"Rat.lt_one_iff_num_lt_denom","module":"Mathlib.Algebra.Order.Ring.Unbundled.Rat","initialProofState":"q : Rat\n⊢ Iff (LT.lt q 1) (LT.lt q.num ↑q.den)","decl":"theorem lt_one_iff_num_lt_denom {q : ℚ} : q < 1 ↔ q.num < q.den := by simp [Rat.lt_def]\n\n"}
{"name":"Rat.abs_def","module":"Mathlib.Algebra.Order.Ring.Unbundled.Rat","initialProofState":"q : Rat\n⊢ Eq (abs q) (Rat.divInt ↑q.num.natAbs ↑q.den)","decl":"theorem abs_def (q : ℚ) : |q| = q.num.natAbs /. q.den := by\n  rcases le_total q 0 with hq | hq\n  · rw [abs_of_nonpos hq]\n    rw [← num_divInt_den q, ← zero_divInt, Rat.divInt_le_divInt (mod_cast q.pos) Int.zero_lt_one,\n      mul_one, zero_mul] at hq\n    rw [Int.ofNat_natAbs_of_nonpos hq, ← neg_def]\n  · rw [abs_of_nonneg hq]\n    rw [← num_divInt_den q, ← zero_divInt, Rat.divInt_le_divInt Int.zero_lt_one (mod_cast q.pos),\n      mul_one, zero_mul] at hq\n    rw [Int.natAbs_of_nonneg hq, num_divInt_den]\n\n"}
