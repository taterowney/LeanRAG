{"name":"CategoryTheory.Presheaf.isLimit_iff_isSheafFor","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nP : CategoryTheory.Functor (Opposite C) A\nX : C\nS : CategoryTheory.Sieve X\n‚ä¢ Iff (Nonempty (CategoryTheory.Limits.IsLimit (P.mapCone S.arrows.cocone.op))) (‚àÄ (E : Opposite A), CategoryTheory.Presieve.IsSheafFor (P.comp (CategoryTheory.coyoneda.obj E)) S.arrows)","decl":"/-- Given sieve `S` and presheaf `P : C·µí·µñ ‚•§ A`, their natural associated cone is a limit cone\n    iff `Hom (E, P -)` is a sheaf of types for the sieve `S` and all `E : A`. -/\ntheorem isLimit_iff_isSheafFor :\n    Nonempty (IsLimit (P.mapCone S.arrows.cocone.op)) ‚Üî\n      ‚àÄ E : A·µí·µñ, IsSheafFor (P ‚ãô coyoneda.obj E) S.arrows := by\n  dsimp [IsSheafFor]; simp_rw [compatible_iff_sieveCompatible]\n  rw [((Cone.isLimitEquivIsTerminal _).trans (isTerminalEquivUnique _ _)).nonempty_congr]\n  rw [Classical.nonempty_pi]; constructor\n  ¬∑ intro hu E x hx\n    specialize hu hx.cone\n    rw [(homEquivAmalgamation hx).uniqueCongr.nonempty_congr] at hu\n    exact (unique_subtype_iff_existsUnique _).1 hu\n  ¬∑ rintro h ‚ü®E, œÄ‚ü©\n    let eqv := conesEquivSieveCompatibleFamily P S (op E)\n    rw [‚Üê eqv.left_inv œÄ]\n    erw [(homEquivAmalgamation (eqv œÄ).2).uniqueCongr.nonempty_congr]\n    rw [unique_subtype_iff_existsUnique]\n    exact h _ _ (eqv œÄ).2\n\n"}
{"name":"CategoryTheory.Presheaf.subsingleton_iff_isSeparatedFor","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nP : CategoryTheory.Functor (Opposite C) A\nX : C\nS : CategoryTheory.Sieve X\n‚ä¢ Iff (‚àÄ (c : CategoryTheory.Limits.Cone (S.arrows.diagram.op.comp P)), Subsingleton (Quiver.Hom c (P.mapCone S.arrows.cocone.op))) (‚àÄ (E : Opposite A), CategoryTheory.Presieve.IsSeparatedFor (P.comp (CategoryTheory.coyoneda.obj E)) S.arrows)","decl":"/-- Given sieve `S` and presheaf `P : C·µí·µñ ‚•§ A`, their natural associated cone admits at most one\n    morphism from every cone in the same category (i.e. over the same diagram),\n    iff `Hom (E, P -)`is separated for the sieve `S` and all `E : A`. -/\ntheorem subsingleton_iff_isSeparatedFor :\n    (‚àÄ c, Subsingleton (c ‚ü∂ P.mapCone S.arrows.cocone.op)) ‚Üî\n      ‚àÄ E : A·µí·µñ, IsSeparatedFor (P ‚ãô coyoneda.obj E) S.arrows := by\n  constructor\n  ¬∑ intro hs E x t‚ÇÅ t‚ÇÇ h‚ÇÅ h‚ÇÇ\n    have hx := is_compatible_of_exists_amalgamation x ‚ü®t‚ÇÅ, h‚ÇÅ‚ü©\n    rw [compatible_iff_sieveCompatible] at hx\n    specialize hs hx.cone\n    rcases hs with ‚ü®hs‚ü©\n    simpa only [Subtype.mk.injEq] using (show Subtype.mk t‚ÇÅ h‚ÇÅ = ‚ü®t‚ÇÇ, h‚ÇÇ‚ü© from\n      (homEquivAmalgamation hx).symm.injective (hs _ _))\n  ¬∑ rintro h ‚ü®E, œÄ‚ü©\n    let eqv := conesEquivSieveCompatibleFamily P S (op E)\n    constructor\n    rw [‚Üê eqv.left_inv œÄ]\n    intro f‚ÇÅ f‚ÇÇ\n    let eqv' := homEquivAmalgamation (eqv œÄ).2\n    apply eqv'.injective\n    ext\n    apply h _ (eqv œÄ).1 <;> exact (eqv' _).2\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_iff_isLimit","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\n‚ä¢ Iff (CategoryTheory.Presheaf.IsSheaf J P) (‚àÄ ‚¶ÉX : C‚¶Ñ (S : CategoryTheory.Sieve X), Membership.mem (J X) S ‚Üí Nonempty (CategoryTheory.Limits.IsLimit (P.mapCone S.arrows.cocone.op)))","decl":"/-- A presheaf `P` is a sheaf for the Grothendieck topology `J` iff for every covering sieve\n    `S` of `J`, the natural cone associated to `P` and `S` is a limit cone. -/\ntheorem isSheaf_iff_isLimit :\n    IsSheaf J P ‚Üî\n      ‚àÄ ‚¶ÉX : C‚¶Ñ (S : Sieve X), S ‚àà J X ‚Üí Nonempty (IsLimit (P.mapCone S.arrows.cocone.op)) :=\n  ‚ü®fun h _ S hS => (isLimit_iff_isSheafFor P S).2 fun E => h E.unop S hS, fun h E _ S hS =>\n    (isLimit_iff_isSheafFor P S).1 (h S hS) (op E)‚ü©\n\n"}
{"name":"CategoryTheory.Presheaf.isSeparated_iff_subsingleton","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\n‚ä¢ Iff (‚àÄ (E : A), CategoryTheory.Presieve.IsSeparated J (P.comp (CategoryTheory.coyoneda.obj { unop := E }))) (‚àÄ ‚¶ÉX : C‚¶Ñ (S : CategoryTheory.Sieve X), Membership.mem (J X) S ‚Üí ‚àÄ (c : CategoryTheory.Limits.Cone (S.arrows.diagram.op.comp P)), Subsingleton (Quiver.Hom c (P.mapCone S.arrows.cocone.op)))","decl":"/-- A presheaf `P` is separated for the Grothendieck topology `J` iff for every covering sieve\n    `S` of `J`, the natural cone associated to `P` and `S` admits at most one morphism from every\n    cone in the same category. -/\ntheorem isSeparated_iff_subsingleton :\n    (‚àÄ E : A, Presieve.IsSeparated J (P ‚ãô coyoneda.obj (op E))) ‚Üî\n      ‚àÄ ‚¶ÉX : C‚¶Ñ (S : Sieve X), S ‚àà J X ‚Üí ‚àÄ c, Subsingleton (c ‚ü∂ P.mapCone S.arrows.cocone.op) :=\n  ‚ü®fun h _ S hS => (subsingleton_iff_isSeparatedFor P S).2 fun E => h E.unop S hS, fun h E _ S hS =>\n    (subsingleton_iff_isSeparatedFor P S).1 (h S hS) (op E)‚ü©\n\n"}
{"name":"CategoryTheory.Presheaf.isLimit_iff_isSheafFor_presieve","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nP : CategoryTheory.Functor (Opposite C) A\nX : C\nR : CategoryTheory.Presieve X\n‚ä¢ Iff (Nonempty (CategoryTheory.Limits.IsLimit (P.mapCone (CategoryTheory.Sieve.generate R).arrows.cocone.op))) (‚àÄ (E : Opposite A), CategoryTheory.Presieve.IsSheafFor (P.comp (CategoryTheory.coyoneda.obj E)) R)","decl":"/-- Given presieve `R` and presheaf `P : C·µí·µñ ‚•§ A`, the natural cone associated to `P` and\n    the sieve `Sieve.generate R` generated by `R` is a limit cone iff `Hom (E, P -)` is a\n    sheaf of types for the presieve `R` and all `E : A`. -/\ntheorem isLimit_iff_isSheafFor_presieve :\n    Nonempty (IsLimit (P.mapCone (generate R).arrows.cocone.op)) ‚Üî\n      ‚àÄ E : A·µí·µñ, IsSheafFor (P ‚ãô coyoneda.obj E) R :=\n  (isLimit_iff_isSheafFor P _).trans (forall_congr' fun _ => (isSheafFor_iff_generate _).symm)\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_iff_isLimit_pretopology","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nP : CategoryTheory.Functor (Opposite C) A\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nK : CategoryTheory.Pretopology C\n‚ä¢ Iff (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.Pretopology.toGrothendieck C K) P) (‚àÄ ‚¶ÉX : C‚¶Ñ (R : CategoryTheory.Presieve X), Membership.mem (K.coverings X) R ‚Üí Nonempty (CategoryTheory.Limits.IsLimit (P.mapCone (CategoryTheory.Sieve.generate R).arrows.cocone.op)))","decl":"/-- A presheaf `P` is a sheaf for the Grothendieck topology generated by a pretopology `K`\n    iff for every covering presieve `R` of `K`, the natural cone associated to `P` and\n    `Sieve.generate R` is a limit cone. -/\ntheorem isSheaf_iff_isLimit_pretopology [HasPullbacks C] (K : Pretopology C) :\n    IsSheaf (K.toGrothendieck C) P ‚Üî\n      ‚àÄ ‚¶ÉX : C‚¶Ñ (R : Presieve X),\n        R ‚àà K X ‚Üí Nonempty (IsLimit (P.mapCone (generate R).arrows.cocone.op)) := by\n  dsimp [IsSheaf]\n  simp_rw [isSheaf_pretopology]\n  exact\n    ‚ü®fun h X R hR => (isLimit_iff_isSheafFor_presieve P R).2 fun E => h E.unop R hR,\n      fun h E X R hR => (isLimit_iff_isSheafFor_presieve P R).1 (h R hR) (op E)‚ü©\n\n"}
{"name":"CategoryTheory.Presheaf.IsSheaf.amalgamate_map","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nE : A\nX : C\nP : CategoryTheory.Functor (Opposite C) A\nhP : CategoryTheory.Presheaf.IsSheaf J P\nS : J.Cover X\nx : (I : S.Arrow) ‚Üí Quiver.Hom E (P.obj { unop := I.Y })\nhx : ‚àÄ ‚¶ÉI‚ÇÅ I‚ÇÇ : S.Arrow‚¶Ñ (r : I‚ÇÅ.Relation I‚ÇÇ), Eq (CategoryTheory.CategoryStruct.comp (x I‚ÇÅ) (P.map r.g‚ÇÅ.op)) (CategoryTheory.CategoryStruct.comp (x I‚ÇÇ) (P.map r.g‚ÇÇ.op))\nI : S.Arrow\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hP.amalgamate S x hx) (P.map I.f.op)) (x I)","decl":"@[reassoc (attr := simp)]\ntheorem IsSheaf.amalgamate_map {A : Type u‚ÇÇ} [Category.{v‚ÇÇ} A] {E : A} {X : C} {P : C·µí·µñ ‚•§ A}\n    (hP : Presheaf.IsSheaf J P) (S : J.Cover X) (x : ‚àÄ I : S.Arrow, E ‚ü∂ P.obj (op I.Y))\n    (hx : ‚àÄ ‚¶ÉI‚ÇÅ I‚ÇÇ : S.Arrow‚¶Ñ (r : I‚ÇÅ.Relation I‚ÇÇ),\n       x I‚ÇÅ ‚â´ P.map r.g‚ÇÅ.op = x I‚ÇÇ ‚â´ P.map r.g‚ÇÇ.op)\n    (I : S.Arrow) :\n    hP.amalgamate S x hx ‚â´ P.map I.f.op = x _ := by\n  apply (hP _ _ S.condition).valid_glue\n\n"}
{"name":"CategoryTheory.Presheaf.IsSheaf.amalgamate_map_assoc","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nE : A\nX : C\nP : CategoryTheory.Functor (Opposite C) A\nhP : CategoryTheory.Presheaf.IsSheaf J P\nS : J.Cover X\nx : (I : S.Arrow) ‚Üí Quiver.Hom E (P.obj { unop := I.Y })\nhx : ‚àÄ ‚¶ÉI‚ÇÅ I‚ÇÇ : S.Arrow‚¶Ñ (r : I‚ÇÅ.Relation I‚ÇÇ), Eq (CategoryTheory.CategoryStruct.comp (x I‚ÇÅ) (P.map r.g‚ÇÅ.op)) (CategoryTheory.CategoryStruct.comp (x I‚ÇÇ) (P.map r.g‚ÇÇ.op))\nI : S.Arrow\nZ : A\nh : Quiver.Hom (P.obj { unop := I.Y }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hP.amalgamate S x hx) (CategoryTheory.CategoryStruct.comp (P.map I.f.op) h)) (CategoryTheory.CategoryStruct.comp (x I) h)","decl":"@[reassoc (attr := simp)]\ntheorem IsSheaf.amalgamate_map {A : Type u‚ÇÇ} [Category.{v‚ÇÇ} A] {E : A} {X : C} {P : C·µí·µñ ‚•§ A}\n    (hP : Presheaf.IsSheaf J P) (S : J.Cover X) (x : ‚àÄ I : S.Arrow, E ‚ü∂ P.obj (op I.Y))\n    (hx : ‚àÄ ‚¶ÉI‚ÇÅ I‚ÇÇ : S.Arrow‚¶Ñ (r : I‚ÇÅ.Relation I‚ÇÇ),\n       x I‚ÇÅ ‚â´ P.map r.g‚ÇÅ.op = x I‚ÇÇ ‚â´ P.map r.g‚ÇÇ.op)\n    (I : S.Arrow) :\n    hP.amalgamate S x hx ‚â´ P.map I.f.op = x _ := by\n  apply (hP _ _ S.condition).valid_glue\n\n"}
{"name":"CategoryTheory.Presheaf.IsSheaf.hom_ext","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nE : A\nX : C\nP : CategoryTheory.Functor (Opposite C) A\nhP : CategoryTheory.Presheaf.IsSheaf J P\nS : J.Cover X\ne‚ÇÅ e‚ÇÇ : Quiver.Hom E (P.obj { unop := X })\nh : ‚àÄ (I : S.Arrow), Eq (CategoryTheory.CategoryStruct.comp e‚ÇÅ (P.map I.f.op)) (CategoryTheory.CategoryStruct.comp e‚ÇÇ (P.map I.f.op))\n‚ä¢ Eq e‚ÇÅ e‚ÇÇ","decl":"theorem IsSheaf.hom_ext {A : Type u‚ÇÇ} [Category.{v‚ÇÇ} A] {E : A} {X : C} {P : C·µí·µñ ‚•§ A}\n    (hP : Presheaf.IsSheaf J P) (S : J.Cover X) (e‚ÇÅ e‚ÇÇ : E ‚ü∂ P.obj (op X))\n    (h : ‚àÄ I : S.Arrow, e‚ÇÅ ‚â´ P.map I.f.op = e‚ÇÇ ‚â´ P.map I.f.op) : e‚ÇÅ = e‚ÇÇ :=\n  (hP _ _ S.condition).isSeparatedFor.ext fun Y f hf => h ‚ü®Y, f, hf‚ü©\n\n"}
{"name":"CategoryTheory.Presheaf.IsSheaf.hom_ext_ofArrows","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\nhP : CategoryTheory.Presheaf.IsSheaf J P\nI : Type u_1\nS : C\nX : I ‚Üí C\nf : (i : I) ‚Üí Quiver.Hom (X i) S\nhf : Membership.mem (J S) (CategoryTheory.Sieve.ofArrows X f)\nE : A\nx y : Quiver.Hom E (P.obj { unop := S })\nh : ‚àÄ (i : I), Eq (CategoryTheory.CategoryStruct.comp x (P.map (f i).op)) (CategoryTheory.CategoryStruct.comp y (P.map (f i).op))\n‚ä¢ Eq x y","decl":"lemma IsSheaf.hom_ext_ofArrows\n    {P : C·µí·µñ ‚•§ A} (hP : Presheaf.IsSheaf J P) {I : Type*} {S : C} {X : I ‚Üí C}\n    (f : ‚àÄ i, X i ‚ü∂ S) (hf : Sieve.ofArrows _ f ‚àà J S) {E : A}\n    {x y : E ‚ü∂ P.obj (op S)} (h : ‚àÄ i, x ‚â´ P.map (f i).op = y ‚â´ P.map (f i).op) :\n    x = y := by\n  apply hP.hom_ext ‚ü®_, hf‚ü©\n  rintro ‚ü®Z, _, _, g, _, ‚ü®i‚ü©, rfl‚ü©\n  dsimp\n  rw [P.map_comp, reassoc_of% (h i)]\n\n"}
{"name":"CategoryTheory.Presheaf.IsSheaf.existsUnique_amalgamation_ofArrows","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\nhP : CategoryTheory.Presheaf.IsSheaf J P\nI : Type u_1\nS : C\nX : I ‚Üí C\nf : (i : I) ‚Üí Quiver.Hom (X i) S\nhf : Membership.mem (J S) (CategoryTheory.Sieve.ofArrows X f)\nE : A\nx : (i : I) ‚Üí Quiver.Hom E (P.obj { unop := X i })\nhx : ‚àÄ ‚¶ÉW : C‚¶Ñ ‚¶Éi j : I‚¶Ñ (a : Quiver.Hom W (X i)) (b : Quiver.Hom W (X j)), Eq (CategoryTheory.CategoryStruct.comp a (f i)) (CategoryTheory.CategoryStruct.comp b (f j)) ‚Üí Eq (CategoryTheory.CategoryStruct.comp (x i) (P.map a.op)) (CategoryTheory.CategoryStruct.comp (x j) (P.map b.op))\n‚ä¢ ExistsUnique fun g => ‚àÄ (i : I), Eq (CategoryTheory.CategoryStruct.comp g (P.map (f i).op)) (x i)","decl":"lemma IsSheaf.existsUnique_amalgamation_ofArrows :\n    ‚àÉ! (g : E ‚ü∂ P.obj (op S)), ‚àÄ (i : I), g ‚â´ P.map (f i).op = x i :=\n  (Presieve.isSheafFor_arrows_iff _ _).1\n    ((Presieve.isSheafFor_iff_generate _).2 (hP E _ hf)) x (fun _ _ _ _ _ w => hx _ _ w)\n\n"}
{"name":"CategoryTheory.Presheaf.IsSheaf.exists_unique_amalgamation_ofArrows","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\nhP : CategoryTheory.Presheaf.IsSheaf J P\nI : Type u_1\nS : C\nX : I ‚Üí C\nf : (i : I) ‚Üí Quiver.Hom (X i) S\nhf : Membership.mem (J S) (CategoryTheory.Sieve.ofArrows X f)\nE : A\nx : (i : I) ‚Üí Quiver.Hom E (P.obj { unop := X i })\nhx : ‚àÄ ‚¶ÉW : C‚¶Ñ ‚¶Éi j : I‚¶Ñ (a : Quiver.Hom W (X i)) (b : Quiver.Hom W (X j)), Eq (CategoryTheory.CategoryStruct.comp a (f i)) (CategoryTheory.CategoryStruct.comp b (f j)) ‚Üí Eq (CategoryTheory.CategoryStruct.comp (x i) (P.map a.op)) (CategoryTheory.CategoryStruct.comp (x j) (P.map b.op))\n‚ä¢ ExistsUnique fun g => ‚àÄ (i : I), Eq (CategoryTheory.CategoryStruct.comp g (P.map (f i).op)) (x i)","decl":"@[deprecated (since := \"2024-12-17\")]\nalias IsSheaf.exists_unique_amalgamation_ofArrows := IsSheaf.existsUnique_amalgamation_ofArrows\n\n"}
{"name":"CategoryTheory.Presheaf.IsSheaf.amalgamateOfArrows_map_assoc","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\nhP : CategoryTheory.Presheaf.IsSheaf J P\nI : Type u_1\nS : C\nX : I ‚Üí C\nf : (i : I) ‚Üí Quiver.Hom (X i) S\nhf : Membership.mem (J S) (CategoryTheory.Sieve.ofArrows X f)\nE : A\nx : (i : I) ‚Üí Quiver.Hom E (P.obj { unop := X i })\nhx : ‚àÄ ‚¶ÉW : C‚¶Ñ ‚¶Éi j : I‚¶Ñ (a : Quiver.Hom W (X i)) (b : Quiver.Hom W (X j)), Eq (CategoryTheory.CategoryStruct.comp a (f i)) (CategoryTheory.CategoryStruct.comp b (f j)) ‚Üí Eq (CategoryTheory.CategoryStruct.comp (x i) (P.map a.op)) (CategoryTheory.CategoryStruct.comp (x j) (P.map b.op))\ni : I\nZ : A\nh : Quiver.Hom (P.obj { unop := X i }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hP.amalgamateOfArrows f hf x hx) (CategoryTheory.CategoryStruct.comp (P.map (f i).op) h)) (CategoryTheory.CategoryStruct.comp (x i) h)","decl":"@[reassoc (attr := simp)]\nlemma IsSheaf.amalgamateOfArrows_map (i : I) :\n    hP.amalgamateOfArrows f hf x hx ‚â´ P.map (f i).op = x i :=\n  (hP.existsUnique_amalgamation_ofArrows f hf x hx).choose_spec.1 i\n\n"}
{"name":"CategoryTheory.Presheaf.IsSheaf.amalgamateOfArrows_map","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\nhP : CategoryTheory.Presheaf.IsSheaf J P\nI : Type u_1\nS : C\nX : I ‚Üí C\nf : (i : I) ‚Üí Quiver.Hom (X i) S\nhf : Membership.mem (J S) (CategoryTheory.Sieve.ofArrows X f)\nE : A\nx : (i : I) ‚Üí Quiver.Hom E (P.obj { unop := X i })\nhx : ‚àÄ ‚¶ÉW : C‚¶Ñ ‚¶Éi j : I‚¶Ñ (a : Quiver.Hom W (X i)) (b : Quiver.Hom W (X j)), Eq (CategoryTheory.CategoryStruct.comp a (f i)) (CategoryTheory.CategoryStruct.comp b (f j)) ‚Üí Eq (CategoryTheory.CategoryStruct.comp (x i) (P.map a.op)) (CategoryTheory.CategoryStruct.comp (x j) (P.map b.op))\ni : I\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (hP.amalgamateOfArrows f hf x hx) (P.map (f i).op)) (x i)","decl":"@[reassoc (attr := simp)]\nlemma IsSheaf.amalgamateOfArrows_map (i : I) :\n    hP.amalgamateOfArrows f hf x hx ‚â´ P.map (f i).op = x i :=\n  (hP.existsUnique_amalgamation_ofArrows f hf x hx).choose_spec.1 i\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_of_iso_iff","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\nP P' : CategoryTheory.Functor (Opposite C) A\ne : CategoryTheory.Iso P P'\n‚ä¢ Iff (CategoryTheory.Presheaf.IsSheaf J P) (CategoryTheory.Presheaf.IsSheaf J P')","decl":"theorem isSheaf_of_iso_iff {P P' : C·µí·µñ ‚•§ A} (e : P ‚âÖ P') : IsSheaf J P ‚Üî IsSheaf J P' :=\n  forall_congr' fun _ =>\n    ‚ü®Presieve.isSheaf_iso J (isoWhiskerRight e _),\n      Presieve.isSheaf_iso J (isoWhiskerRight e.symm _)‚ü©\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_of_isTerminal","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\nX : A\nhX : CategoryTheory.Limits.IsTerminal X\n‚ä¢ CategoryTheory.Presheaf.IsSheaf J ((CategoryTheory.Functor.const (Opposite C)).obj X)","decl":"theorem isSheaf_of_isTerminal {X : A} (hX : IsTerminal X) :\n    Presheaf.IsSheaf J ((CategoryTheory.Functor.const _).obj X) := fun _ _ _ _ _ _ =>\n  ‚ü®hX.from _, fun _ _ _ => hX.hom_ext _ _, fun _ _ => hX.hom_ext _ _‚ü©\n\n"}
{"name":"CategoryTheory.Sheaf.cond","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nself : CategoryTheory.Sheaf J A\n‚ä¢ CategoryTheory.Presheaf.IsSheaf J self.val","decl":"/-- The category of sheaves taking values in `A` on a grothendieck topology. -/\nstructure Sheaf where\n  /-- the underlying presheaf -/\n  val : C·µí·µñ ‚•§ A\n  /-- the condition that the presheaf is a sheaf -/\n  cond : Presheaf.IsSheaf J val\n\n"}
{"name":"CategoryTheory.Sheaf.mk.inj","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nval‚úù : CategoryTheory.Functor (Opposite C) A\ncond‚úù : CategoryTheory.Presheaf.IsSheaf J val‚úù\nval : CategoryTheory.Functor (Opposite C) A\ncond : CategoryTheory.Presheaf.IsSheaf J val\nx‚úù : Eq { val := val‚úù, cond := cond‚úù } { val := val, cond := cond }\n‚ä¢ Eq val‚úù val","decl":"/-- The category of sheaves taking values in `A` on a grothendieck topology. -/\nstructure Sheaf where\n  /-- the underlying presheaf -/\n  val : C·µí·µñ ‚•§ A\n  /-- the condition that the presheaf is a sheaf -/\n  cond : Presheaf.IsSheaf J val\n\n"}
{"name":"CategoryTheory.Sheaf.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\ninst‚úù¬π : SizeOf C\ninst‚úù : SizeOf A\nval : CategoryTheory.Functor (Opposite C) A\ncond : CategoryTheory.Presheaf.IsSheaf J val\n‚ä¢ Eq (SizeOf.sizeOf { val := val, cond := cond }) (HAdd.hAdd 1 (SizeOf.sizeOf val))","decl":"/-- The category of sheaves taking values in `A` on a grothendieck topology. -/\nstructure Sheaf where\n  /-- the underlying presheaf -/\n  val : C·µí·µñ ‚•§ A\n  /-- the condition that the presheaf is a sheaf -/\n  cond : Presheaf.IsSheaf J val\n\n"}
{"name":"CategoryTheory.Sheaf.mk.injEq","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nval‚úù : CategoryTheory.Functor (Opposite C) A\ncond‚úù : CategoryTheory.Presheaf.IsSheaf J val‚úù\nval : CategoryTheory.Functor (Opposite C) A\ncond : CategoryTheory.Presheaf.IsSheaf J val\n‚ä¢ Eq (Eq { val := val‚úù, cond := cond‚úù } { val := val, cond := cond }) (Eq val‚úù val)","decl":"/-- The category of sheaves taking values in `A` on a grothendieck topology. -/\nstructure Sheaf where\n  /-- the underlying presheaf -/\n  val : C·µí·µñ ‚•§ A\n  /-- the condition that the presheaf is a sheaf -/\n  cond : Presheaf.IsSheaf J val\n\n"}
{"name":"CategoryTheory.Sheaf.Hom.mk.inj","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nX Y : CategoryTheory.Sheaf J A\nval‚úù val : Quiver.Hom X.val Y.val\nx‚úù : Eq { val := val‚úù } { val := val }\n‚ä¢ Eq val‚úù val","decl":"/-- Morphisms between sheaves are just morphisms of presheaves. -/\n@[ext]\nstructure Hom (X Y : Sheaf J A) where\n  /-- a morphism between the underlying presheaves -/\n  val : X.val ‚ü∂ Y.val\n\n"}
{"name":"CategoryTheory.Sheaf.Hom.ext_iff","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nX Y : CategoryTheory.Sheaf J A\nx y : X.Hom Y\n‚ä¢ Iff (Eq x y) (Eq x.val y.val)","decl":"/-- Morphisms between sheaves are just morphisms of presheaves. -/\n@[ext]\nstructure Hom (X Y : Sheaf J A) where\n  /-- a morphism between the underlying presheaves -/\n  val : X.val ‚ü∂ Y.val\n\n"}
{"name":"CategoryTheory.Sheaf.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nX Y : CategoryTheory.Sheaf J A\nval‚úù val : Quiver.Hom X.val Y.val\n‚ä¢ Eq (Eq { val := val‚úù } { val := val }) (Eq val‚úù val)","decl":"/-- Morphisms between sheaves are just morphisms of presheaves. -/\n@[ext]\nstructure Hom (X Y : Sheaf J A) where\n  /-- a morphism between the underlying presheaves -/\n  val : X.val ‚ü∂ Y.val\n\n"}
{"name":"CategoryTheory.Sheaf.Hom.ext","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nX Y : CategoryTheory.Sheaf J A\nx y : X.Hom Y\nval : Eq x.val y.val\n‚ä¢ Eq x y","decl":"/-- Morphisms between sheaves are just morphisms of presheaves. -/\n@[ext]\nstructure Hom (X Y : Sheaf J A) where\n  /-- a morphism between the underlying presheaves -/\n  val : X.val ‚ü∂ Y.val\n\n"}
{"name":"CategoryTheory.Sheaf.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nX Y : CategoryTheory.Sheaf J A\ninst‚úù¬π : SizeOf C\ninst‚úù : SizeOf A\nval : Quiver.Hom X.val Y.val\n‚ä¢ Eq (SizeOf.sizeOf { val := val }) (HAdd.hAdd 1 (SizeOf.sizeOf val))","decl":"/-- Morphisms between sheaves are just morphisms of presheaves. -/\n@[ext]\nstructure Hom (X Y : Sheaf J A) where\n  /-- a morphism between the underlying presheaves -/\n  val : X.val ‚ü∂ Y.val\n\n"}
{"name":"CategoryTheory.Sheaf.instCategorySheaf_id_val","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nx‚úù : CategoryTheory.Sheaf J A\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id x‚úù).val (CategoryTheory.CategoryStruct.id x‚úù.val)","decl":"@[simps id_val comp_val]\ninstance instCategorySheaf : Category (Sheaf J A) where\n  Hom := Hom\n  id _ := ‚ü®ùüô _‚ü©\n  comp f g := ‚ü®f.val ‚â´ g.val‚ü©\n  id_comp _ := Hom.ext <| id_comp _\n  comp_id _ := Hom.ext <| comp_id _\n  assoc _ _ _ := Hom.ext <| assoc _ _ _\n\n-- Let's make the inhabited linter happy.../sips\n"}
{"name":"CategoryTheory.Sheaf.instCategorySheaf_comp_val","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nX‚úù Y‚úù Z‚úù : CategoryTheory.Sheaf J A\nf : Quiver.Hom X‚úù Y‚úù\ng : Quiver.Hom Y‚úù Z‚úù\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).val (CategoryTheory.CategoryStruct.comp f.val g.val)","decl":"@[simps id_val comp_val]\ninstance instCategorySheaf : Category (Sheaf J A) where\n  Hom := Hom\n  id _ := ‚ü®ùüô _‚ü©\n  comp f g := ‚ü®f.val ‚â´ g.val‚ü©\n  id_comp _ := Hom.ext <| id_comp _\n  comp_id _ := Hom.ext <| comp_id _\n  assoc _ _ _ := Hom.ext <| assoc _ _ _\n\n-- Let's make the inhabited linter happy.../sips\n"}
{"name":"CategoryTheory.Sheaf.hom_ext","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nX Y : CategoryTheory.Sheaf J A\nx y : Quiver.Hom X Y\nh : Eq x.val y.val\n‚ä¢ Eq x y","decl":"@[ext]\nlemma hom_ext {X Y : Sheaf J A} (x y : X ‚ü∂ Y) (h : x.val = y.val) : x = y :=\n  Sheaf.Hom.ext h\n\n"}
{"name":"CategoryTheory.Sheaf.hom_ext_iff","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nX Y : CategoryTheory.Sheaf J A\nx y : Quiver.Hom X Y\n‚ä¢ Iff (Eq x y) (Eq x.val y.val)","decl":"@[ext]\nlemma hom_ext {X Y : Sheaf J A} (x y : X ‚ü∂ Y) (h : x.val = y.val) : x = y :=\n  Sheaf.Hom.ext h\n\n"}
{"name":"CategoryTheory.sheafToPresheaf_map","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nX‚úù Y‚úù : CategoryTheory.Sheaf J A\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.sheafToPresheaf J A).map f) f.val","decl":"/-- The inclusion functor from sheaves to presheaves. -/\n@[simps]\ndef sheafToPresheaf : Sheaf J A ‚•§ C·µí·µñ ‚•§ A where\n  obj := Sheaf.val\n  map f := f.val\n  map_id _ := rfl\n  map_comp _ _ := rfl\n\n"}
{"name":"CategoryTheory.sheafToPresheaf_obj","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nself : CategoryTheory.Sheaf J A\n‚ä¢ Eq ((CategoryTheory.sheafToPresheaf J A).obj self) self.val","decl":"/-- The inclusion functor from sheaves to presheaves. -/\n@[simps]\ndef sheafToPresheaf : Sheaf J A ‚•§ C·µí·µñ ‚•§ A where\n  obj := Sheaf.val\n  map f := f.val\n  map_id _ := rfl\n  map_comp _ _ := rfl\n\n"}
{"name":"CategoryTheory.fullyFaithfulSheafToPresheaf_preimage_val","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nX‚úù Y‚úù : CategoryTheory.Sheaf J A\nf : Quiver.Hom ((CategoryTheory.sheafToPresheaf J A).obj X‚úù) ((CategoryTheory.sheafToPresheaf J A).obj Y‚úù)\n‚ä¢ Eq ((CategoryTheory.fullyFaithfulSheafToPresheaf J A).preimage f).val f","decl":"/-- The functor `Sheaf J A ‚•§ C·µí·µñ ‚•§ A` is fully faithful. -/\n@[simps]\ndef fullyFaithfulSheafToPresheaf : (sheafToPresheaf J A).FullyFaithful where\n  preimage f := ‚ü®f‚ü©\n\n"}
{"name":"CategoryTheory.instFullSheafFunctorOppositeSheafToPresheaf","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\n‚ä¢ (CategoryTheory.sheafToPresheaf J A).Full","decl":"instance : (sheafToPresheaf J A).Full :=\n  (fullyFaithfulSheafToPresheaf J A).full\n\n"}
{"name":"CategoryTheory.instFaithfulSheafFunctorOppositeSheafToPresheaf","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\n‚ä¢ (CategoryTheory.sheafToPresheaf J A).Faithful","decl":"instance : (sheafToPresheaf J A).Faithful :=\n  (fullyFaithfulSheafToPresheaf J A).faithful\n\n"}
{"name":"CategoryTheory.instReflectsIsomorphismsSheafFunctorOppositeSheafToPresheaf","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\n‚ä¢ (CategoryTheory.sheafToPresheaf J A).ReflectsIsomorphisms","decl":"instance : (sheafToPresheaf J A).ReflectsIsomorphisms :=\n  (fullyFaithfulSheafToPresheaf J A).reflectsIsomorphisms\n\n"}
{"name":"CategoryTheory.Sheaf.Hom.mono_of_presheaf_mono","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nF G : CategoryTheory.Sheaf J A\nf : Quiver.Hom F G\nh : CategoryTheory.Mono f.val\n‚ä¢ CategoryTheory.Mono f","decl":"/-- This is stated as a lemma to prevent class search from forming a loop since a sheaf morphism is\nmonic if and only if it is monic as a presheaf morphism (under suitable assumption). -/\ntheorem Sheaf.Hom.mono_of_presheaf_mono {F G : Sheaf J A} (f : F ‚ü∂ G) [h : Mono f.1] : Mono f :=\n  (sheafToPresheaf J A).mono_of_mono_map h\n\n"}
{"name":"CategoryTheory.Sheaf.Hom.epi_of_presheaf_epi","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nF G : CategoryTheory.Sheaf J A\nf : Quiver.Hom F G\nh : CategoryTheory.Epi f.val\n‚ä¢ CategoryTheory.Epi f","decl":"instance Sheaf.Hom.epi_of_presheaf_epi {F G : Sheaf J A} (f : F ‚ü∂ G) [h : Epi f.1] : Epi f :=\n  (sheafToPresheaf J A).epi_of_epi_map h\n\n"}
{"name":"CategoryTheory.isSheaf_iff_isSheaf_of_type","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) (Type w)\n‚ä¢ Iff (CategoryTheory.Presheaf.IsSheaf J P) (CategoryTheory.Presieve.IsSheaf J P)","decl":"theorem isSheaf_iff_isSheaf_of_type (P : C·µí·µñ ‚•§ Type w) :\n    Presheaf.IsSheaf J P ‚Üî Presieve.IsSheaf J P := by\n  constructor\n  ¬∑ intro hP\n    refine Presieve.isSheaf_iso J ?_ (hP PUnit)\n    exact isoWhiskerLeft _ Coyoneda.punitIso ‚â™‚â´ P.rightUnitor\n  ¬∑ intro hP X Y S hS z hz\n    refine ‚ü®fun x => (hP S hS).amalgamate (fun Z f hf => z f hf x) ?_, ?_, ?_‚ü©\n    ¬∑ intro Y‚ÇÅ Y‚ÇÇ Z g‚ÇÅ g‚ÇÇ f‚ÇÅ f‚ÇÇ hf‚ÇÅ hf‚ÇÇ h\n      exact congr_fun (hz g‚ÇÅ g‚ÇÇ hf‚ÇÅ hf‚ÇÇ h) x\n    ¬∑ intro Z f hf\n      funext x\n      apply Presieve.IsSheafFor.valid_glue\n    ¬∑ intro y hy\n      funext x\n      apply (hP S hS).isSeparatedFor.ext\n      intro Y' f hf\n      rw [Presieve.IsSheafFor.valid_glue _ _ _ hf, ‚Üê hy _ hf]\n      rfl\n\n"}
{"name":"CategoryTheory.sheafOver_val","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\n‚Ñ± : CategoryTheory.Sheaf J A\nE : A\n‚ä¢ Eq (CategoryTheory.sheafOver ‚Ñ± E).val (‚Ñ±.val.comp (CategoryTheory.coyoneda.obj { unop := E }))","decl":"/-- The sheaf of sections guaranteed by the sheaf condition. -/\n@[simps]\ndef sheafOver {A : Type u‚ÇÇ} [Category.{v‚ÇÇ} A] {J : GrothendieckTopology C} (‚Ñ± : Sheaf J A) (E : A) :\n    Sheaf J (Type _) where\n  val := ‚Ñ±.val ‚ãô coyoneda.obj (op E)\n  cond := by\n    rw [isSheaf_iff_isSheaf_of_type]\n    exact ‚Ñ±.cond E\n\n"}
{"name":"CategoryTheory.Presheaf.IsSheaf.isSheafFor","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nhP : CategoryTheory.Presheaf.IsSheaf J P\nX : C\nS : CategoryTheory.Sieve X\nhS : Membership.mem (J X) S\n‚ä¢ CategoryTheory.Presieve.IsSheafFor P S.arrows","decl":"variable {J} in\nlemma Presheaf.IsSheaf.isSheafFor {P : C·µí·µñ ‚•§ Type w} (hP : Presheaf.IsSheaf J P)\n    {X : C} (S : Sieve X) (hS : S ‚àà J X) : Presieve.IsSheafFor P S.arrows := by\n  rw [isSheaf_iff_isSheaf_of_type] at hP\n  exact hP S hS\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_bot","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nP : CategoryTheory.Functor (Opposite C) A\n‚ä¢ CategoryTheory.Presheaf.IsSheaf Bot.bot P","decl":"variable {A} in\nlemma Presheaf.isSheaf_bot (P : C·µí·µñ ‚•§ A) : IsSheaf ‚ä• P := fun _ ‚Ü¶ Presieve.isSheaf_bot\n\n"}
{"name":"CategoryTheory.sheafBotEquivalence_functor","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\n‚ä¢ Eq (CategoryTheory.sheafBotEquivalence A).functor (CategoryTheory.sheafToPresheaf Bot.bot A)","decl":"/--\nThe category of sheaves on the bottom (trivial) Grothendieck topology is\nequivalent to the category of presheaves.\n-/\n@[simps]\ndef sheafBotEquivalence : Sheaf (‚ä• : GrothendieckTopology C) A ‚âå C·µí·µñ ‚•§ A where\n  functor := sheafToPresheaf _ _\n  inverse :=\n    { obj := fun P => ‚ü®P, Presheaf.isSheaf_bot P‚ü©\n      map := fun f => ‚ü®f‚ü© }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.sheafBotEquivalence_inverse_map_val","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nX‚úù Y‚úù : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.sheafBotEquivalence A).inverse.map f).val f","decl":"/--\nThe category of sheaves on the bottom (trivial) Grothendieck topology is\nequivalent to the category of presheaves.\n-/\n@[simps]\ndef sheafBotEquivalence : Sheaf (‚ä• : GrothendieckTopology C) A ‚âå C·µí·µñ ‚•§ A where\n  functor := sheafToPresheaf _ _\n  inverse :=\n    { obj := fun P => ‚ü®P, Presheaf.isSheaf_bot P‚ü©\n      map := fun f => ‚ü®f‚ü© }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.sheafBotEquivalence_counitIso","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\n‚ä¢ Eq (CategoryTheory.sheafBotEquivalence A).counitIso (CategoryTheory.Iso.refl ({ obj := fun P => { val := P, cond := ‚ãØ }, map := fun {X Y} f => { val := f }, map_id := ‚ãØ, map_comp := ‚ãØ }.comp (CategoryTheory.sheafToPresheaf Bot.bot A)))","decl":"/--\nThe category of sheaves on the bottom (trivial) Grothendieck topology is\nequivalent to the category of presheaves.\n-/\n@[simps]\ndef sheafBotEquivalence : Sheaf (‚ä• : GrothendieckTopology C) A ‚âå C·µí·µñ ‚•§ A where\n  functor := sheafToPresheaf _ _\n  inverse :=\n    { obj := fun P => ‚ü®P, Presheaf.isSheaf_bot P‚ü©\n      map := fun f => ‚ü®f‚ü© }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.sheafBotEquivalence_inverse_obj_val","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nP : CategoryTheory.Functor (Opposite C) A\n‚ä¢ Eq ((CategoryTheory.sheafBotEquivalence A).inverse.obj P).val P","decl":"/--\nThe category of sheaves on the bottom (trivial) Grothendieck topology is\nequivalent to the category of presheaves.\n-/\n@[simps]\ndef sheafBotEquivalence : Sheaf (‚ä• : GrothendieckTopology C) A ‚âå C·µí·µñ ‚•§ A where\n  functor := sheafToPresheaf _ _\n  inverse :=\n    { obj := fun P => ‚ü®P, Presheaf.isSheaf_bot P‚ü©\n      map := fun f => ‚ü®f‚ü© }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.sheafBotEquivalence_unitIso","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\n‚ä¢ Eq (CategoryTheory.sheafBotEquivalence A).unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (CategoryTheory.Sheaf Bot.bot A)))","decl":"/--\nThe category of sheaves on the bottom (trivial) Grothendieck topology is\nequivalent to the category of presheaves.\n-/\n@[simps]\ndef sheafBotEquivalence : Sheaf (‚ä• : GrothendieckTopology C) A ‚âå C·µí·µñ ‚•§ A where\n  functor := sheafToPresheaf _ _\n  inverse :=\n    { obj := fun P => ‚ü®P, Presheaf.isSheaf_bot P‚ü©\n      map := fun f => ‚ü®f‚ü© }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Sheaf.Hom.add_app","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\ninst‚úù : CategoryTheory.Preadditive A\nP Q : CategoryTheory.Sheaf J A\nf g : Quiver.Hom P Q\nU : Opposite C\n‚ä¢ Eq ((HAdd.hAdd f g).val.app U) (HAdd.hAdd (f.val.app U) (g.val.app U))","decl":"@[simp]\ntheorem Sheaf.Hom.add_app (f g : P ‚ü∂ Q) (U) : (f + g).1.app U = f.1.app U + g.1.app U :=\n  rfl\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_iff_multifork","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\n‚ä¢ Iff (CategoryTheory.Presheaf.IsSheaf J P) (‚àÄ (X : C) (S : J.Cover X), Nonempty (CategoryTheory.Limits.IsLimit (S.multifork P)))","decl":"theorem isSheaf_iff_multifork :\n    IsSheaf J P ‚Üî ‚àÄ (X : C) (S : J.Cover X), Nonempty (IsLimit (S.multifork P)) := by\n  refine ‚ü®fun hP X S => ‚ü®isLimitOfIsSheaf _ _ _ hP‚ü©, ?_‚ü©\n  intro h E X S hS x hx\n  let T : J.Cover X := ‚ü®S, hS‚ü©\n  obtain ‚ü®hh‚ü© := h _ T\n  let K : Multifork (T.index P) := Multifork.ofŒπ _ E (fun I => x I.f I.hf)\n    (fun I => hx _ _ _ _ I.r.w)\n  use hh.lift K\n  dsimp; constructor\n  ¬∑ intro Y f hf\n    apply hh.fac K (WalkingMulticospan.left ‚ü®Y, f, hf‚ü©)\n  ¬∑ intro e he\n    apply hh.uniq K\n    rintro (a | b)\n    ¬∑ apply he\n    ¬∑ rw [‚Üê K.w (WalkingMulticospan.Hom.fst b), ‚Üê\n        (T.multifork P).w (WalkingMulticospan.Hom.fst b), ‚Üê assoc]\n      congr 1\n      apply he\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_iff_multiequalizer","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\ninst‚úù : ‚àÄ (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\n‚ä¢ Iff (CategoryTheory.Presheaf.IsSheaf J P) (‚àÄ (X : C) (S : J.Cover X), CategoryTheory.IsIso (S.toMultiequalizer P))","decl":"theorem isSheaf_iff_multiequalizer [‚àÄ (X : C) (S : J.Cover X), HasMultiequalizer (S.index P)] :\n    IsSheaf J P ‚Üî ‚àÄ (X : C) (S : J.Cover X), IsIso (S.toMultiequalizer P) := by\n  rw [isSheaf_iff_multifork]\n  refine forall‚ÇÇ_congr fun X S => ‚ü®?_, ?_‚ü©\n  ¬∑ rintro ‚ü®h‚ü©\n    let e : P.obj (op X) ‚âÖ multiequalizer (S.index P) :=\n      h.conePointUniqueUpToIso (limit.isLimit _)\n    exact (inferInstance : IsIso e.hom)\n  ¬∑ intro h\n    refine ‚ü®IsLimit.ofIsoLimit (limit.isLimit _) (Cones.ext ?_ ?_)‚ü©\n    ¬∑ apply (@asIso _ _ _ _ _ h).symm\n    ¬∑ intro a\n      symm\n      simp\n\n"}
{"name":"CategoryTheory.Presheaf.w","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nU : C\nR : CategoryTheory.Presieve U\nP : CategoryTheory.Functor (Opposite C) A\ninst‚úù¬π : CategoryTheory.Limits.HasProducts A\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Presheaf.forkMap R P) (CategoryTheory.Presheaf.firstMap R P)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Presheaf.forkMap R P) (CategoryTheory.Presheaf.secondMap R P))","decl":"theorem w : forkMap R P ‚â´ firstMap R P = forkMap R P ‚â´ secondMap R P := by\n  apply limit.hom_ext\n  rintro ‚ü®‚ü®Y, f, hf‚ü©, ‚ü®Z, g, hg‚ü©‚ü©\n  simp only [firstMap, secondMap, forkMap, limit.lift_œÄ, limit.lift_œÄ_assoc, assoc, Fan.mk_œÄ_app,\n    Subtype.coe_mk]\n  rw [‚Üê P.map_comp, ‚Üê op_comp, pullback.condition]\n  simp\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_iff_isSheaf'","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA' : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{max v‚ÇÅ u‚ÇÅ, u‚ÇÇ} A'\nJ : CategoryTheory.GrothendieckTopology C\nP' : CategoryTheory.Functor (Opposite C) A'\ninst‚úù¬π : CategoryTheory.Limits.HasProducts A'\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\n‚ä¢ Iff (CategoryTheory.Presheaf.IsSheaf J P') (CategoryTheory.Presheaf.IsSheaf' J P')","decl":"/-- The equalizer definition of a sheaf given by `isSheaf'` is equivalent to `isSheaf`. -/\ntheorem isSheaf_iff_isSheaf' : IsSheaf J P' ‚Üî IsSheaf' J P' := by\n  constructor\n  ¬∑ intro h U R hR\n    refine ‚ü®?_‚ü©\n    apply coyonedaJointlyReflectsLimits\n    intro X\n    have q : Presieve.IsSheafFor (P' ‚ãô coyoneda.obj X) _ := h X.unop _ hR\n    rw [‚Üê Presieve.isSheafFor_iff_generate] at q\n    rw [Equalizer.Presieve.sheaf_condition] at q\n    replace q := Classical.choice q\n    apply (isSheafForIsSheafFor' _ _ _ _).symm q\n  ¬∑ intro h U X S hS\n    rw [Equalizer.Presieve.sheaf_condition]\n    refine ‚ü®?_‚ü©\n    refine isSheafForIsSheafFor' _ _ _ _ ?_\n    letI := preservesSmallestLimits_of_preservesLimits (coyoneda.obj (op U))\n    apply isLimitOfPreserves\n    apply Classical.choice (h _ S.arrows _)\n    simpa\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_of_isSheaf_comp","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nB : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} B\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\ns : CategoryTheory.Functor A B\ninst‚úù : CategoryTheory.Limits.ReflectsLimitsOfSize.{v‚ÇÅ, max v‚ÇÅ u‚ÇÅ, v‚ÇÇ, v‚ÇÉ, u‚ÇÇ, u‚ÇÉ} s\nh : CategoryTheory.Presheaf.IsSheaf J (P.comp s)\n‚ä¢ CategoryTheory.Presheaf.IsSheaf J P","decl":"theorem isSheaf_of_isSheaf_comp (s : A ‚•§ B) [ReflectsLimitsOfSize.{v‚ÇÅ, max v‚ÇÅ u‚ÇÅ} s]\n    (h : IsSheaf J (P ‚ãô s)) : IsSheaf J P := by\n  rw [isSheaf_iff_isLimit] at h ‚ä¢\n  exact fun X S hS ‚Ü¶ (h S hS).map fun t ‚Ü¶ isLimitOfReflects s t\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_comp_of_isSheaf","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nB : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} B\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\ns : CategoryTheory.Functor A B\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfSize.{v‚ÇÅ, max v‚ÇÅ u‚ÇÅ, v‚ÇÇ, v‚ÇÉ, u‚ÇÇ, u‚ÇÉ} s\nh : CategoryTheory.Presheaf.IsSheaf J P\n‚ä¢ CategoryTheory.Presheaf.IsSheaf J (P.comp s)","decl":"theorem isSheaf_comp_of_isSheaf (s : A ‚•§ B) [PreservesLimitsOfSize.{v‚ÇÅ, max v‚ÇÅ u‚ÇÅ} s]\n    (h : IsSheaf J P) : IsSheaf J (P ‚ãô s) := by\n  rw [isSheaf_iff_isLimit] at h ‚ä¢\n  apply fun X S hS ‚Ü¶ (h S hS).map fun t ‚Ü¶ isLimitOfPreserves s t\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_iff_isSheaf_comp","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nB : Type u‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} B\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\ns : CategoryTheory.Functor A B\ninst‚úù¬≤ : CategoryTheory.Limits.HasLimitsOfSize.{v‚ÇÅ, max v‚ÇÅ u‚ÇÅ, v‚ÇÇ, u‚ÇÇ} A\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimitsOfSize.{v‚ÇÅ, max v‚ÇÅ u‚ÇÅ, v‚ÇÇ, v‚ÇÉ, u‚ÇÇ, u‚ÇÉ} s\ninst‚úù : s.ReflectsIsomorphisms\n‚ä¢ Iff (CategoryTheory.Presheaf.IsSheaf J P) (CategoryTheory.Presheaf.IsSheaf J (P.comp s))","decl":"theorem isSheaf_iff_isSheaf_comp (s : A ‚•§ B) [HasLimitsOfSize.{v‚ÇÅ, max v‚ÇÅ u‚ÇÅ} A]\n    [PreservesLimitsOfSize.{v‚ÇÅ, max v‚ÇÅ u‚ÇÅ} s] [s.ReflectsIsomorphisms] :\n    IsSheaf J P ‚Üî IsSheaf J (P ‚ãô s) := by\n  letI : ReflectsLimitsOfSize s := reflectsLimits_of_reflectsIsomorphisms\n  exact ‚ü®isSheaf_comp_of_isSheaf J P s, isSheaf_of_isSheaf_comp J P s‚ü©\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_iff_isSheaf_forget","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA' : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{max v‚ÇÅ u‚ÇÅ, u‚ÇÇ} A'\nJ : CategoryTheory.GrothendieckTopology C\nP' : CategoryTheory.Functor (Opposite C) A'\ns : CategoryTheory.Functor A' (Type (max v‚ÇÅ u‚ÇÅ))\ninst‚úù¬≤ : CategoryTheory.Limits.HasLimits A'\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimits s\ninst‚úù : s.ReflectsIsomorphisms\n‚ä¢ Iff (CategoryTheory.Presheaf.IsSheaf J P') (CategoryTheory.Presheaf.IsSheaf J (P'.comp s))","decl":"/--\nFor a concrete category `(A, s)` where the forgetful functor `s : A ‚•§ Type v` preserves limits and\nreflects isomorphisms, and `A` has limits, an `A`-valued presheaf `P : C·µí·µñ ‚•§ A` is a sheaf iff its\nunderlying `Type`-valued presheaf `P ‚ãô s : C·µí·µñ ‚•§ Type` is a sheaf.\n\nNote this lemma applies for \"algebraic\" categories, eg groups, abelian groups and rings, but not\nfor the category of topological spaces, topological rings, etc since reflecting isomorphisms doesn't\nhold.\n-/\ntheorem isSheaf_iff_isSheaf_forget (s : A' ‚•§ Type max v‚ÇÅ u‚ÇÅ) [HasLimits A'] [PreservesLimits s]\n    [s.ReflectsIsomorphisms] : IsSheaf J P' ‚Üî IsSheaf J (P' ‚ãô s) := by\n  have : HasLimitsOfSize.{v‚ÇÅ, max v‚ÇÅ u‚ÇÅ} A' := hasLimitsOfSizeShrink.{_, _, u‚ÇÅ, 0} A'\n  have : PreservesLimitsOfSize.{v‚ÇÅ, max v‚ÇÅ u‚ÇÅ} s := preservesLimitsOfSize_shrink.{_, 0, _, u‚ÇÅ} s\n  apply isSheaf_iff_isSheaf_comp\n\n"}
