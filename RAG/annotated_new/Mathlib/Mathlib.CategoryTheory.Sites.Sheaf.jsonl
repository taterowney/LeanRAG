{"name":"CategoryTheory.Presheaf.isLimit_iff_isSheafFor","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nP : CategoryTheory.Functor (Opposite C) A\nX : C\nS : CategoryTheory.Sieve X\n⊢ Iff (Nonempty (CategoryTheory.Limits.IsLimit (P.mapCone S.arrows.cocone.op))) (∀ (E : Opposite A), CategoryTheory.Presieve.IsSheafFor (P.comp (CategoryTheory.coyoneda.obj E)) S.arrows)","decl":"/-- Given sieve `S` and presheaf `P : Cᵒᵖ ⥤ A`, their natural associated cone is a limit cone\n    iff `Hom (E, P -)` is a sheaf of types for the sieve `S` and all `E : A`. -/\ntheorem isLimit_iff_isSheafFor :\n    Nonempty (IsLimit (P.mapCone S.arrows.cocone.op)) ↔\n      ∀ E : Aᵒᵖ, IsSheafFor (P ⋙ coyoneda.obj E) S.arrows := by\n  dsimp [IsSheafFor]; simp_rw [compatible_iff_sieveCompatible]\n  rw [((Cone.isLimitEquivIsTerminal _).trans (isTerminalEquivUnique _ _)).nonempty_congr]\n  rw [Classical.nonempty_pi]; constructor\n  · intro hu E x hx\n    specialize hu hx.cone\n    rw [(homEquivAmalgamation hx).uniqueCongr.nonempty_congr] at hu\n    exact (unique_subtype_iff_existsUnique _).1 hu\n  · rintro h ⟨E, π⟩\n    let eqv := conesEquivSieveCompatibleFamily P S (op E)\n    rw [← eqv.left_inv π]\n    erw [(homEquivAmalgamation (eqv π).2).uniqueCongr.nonempty_congr]\n    rw [unique_subtype_iff_existsUnique]\n    exact h _ _ (eqv π).2\n\n"}
{"name":"CategoryTheory.Presheaf.subsingleton_iff_isSeparatedFor","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nP : CategoryTheory.Functor (Opposite C) A\nX : C\nS : CategoryTheory.Sieve X\n⊢ Iff (∀ (c : CategoryTheory.Limits.Cone (S.arrows.diagram.op.comp P)), Subsingleton (Quiver.Hom c (P.mapCone S.arrows.cocone.op))) (∀ (E : Opposite A), CategoryTheory.Presieve.IsSeparatedFor (P.comp (CategoryTheory.coyoneda.obj E)) S.arrows)","decl":"/-- Given sieve `S` and presheaf `P : Cᵒᵖ ⥤ A`, their natural associated cone admits at most one\n    morphism from every cone in the same category (i.e. over the same diagram),\n    iff `Hom (E, P -)`is separated for the sieve `S` and all `E : A`. -/\ntheorem subsingleton_iff_isSeparatedFor :\n    (∀ c, Subsingleton (c ⟶ P.mapCone S.arrows.cocone.op)) ↔\n      ∀ E : Aᵒᵖ, IsSeparatedFor (P ⋙ coyoneda.obj E) S.arrows := by\n  constructor\n  · intro hs E x t₁ t₂ h₁ h₂\n    have hx := is_compatible_of_exists_amalgamation x ⟨t₁, h₁⟩\n    rw [compatible_iff_sieveCompatible] at hx\n    specialize hs hx.cone\n    rcases hs with ⟨hs⟩\n    simpa only [Subtype.mk.injEq] using (show Subtype.mk t₁ h₁ = ⟨t₂, h₂⟩ from\n      (homEquivAmalgamation hx).symm.injective (hs _ _))\n  · rintro h ⟨E, π⟩\n    let eqv := conesEquivSieveCompatibleFamily P S (op E)\n    constructor\n    rw [← eqv.left_inv π]\n    intro f₁ f₂\n    let eqv' := homEquivAmalgamation (eqv π).2\n    apply eqv'.injective\n    ext\n    apply h _ (eqv π).1 <;> exact (eqv' _).2\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_iff_isLimit","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\n⊢ Iff (CategoryTheory.Presheaf.IsSheaf J P) (∀ ⦃X : C⦄ (S : CategoryTheory.Sieve X), Membership.mem (J X) S → Nonempty (CategoryTheory.Limits.IsLimit (P.mapCone S.arrows.cocone.op)))","decl":"/-- A presheaf `P` is a sheaf for the Grothendieck topology `J` iff for every covering sieve\n    `S` of `J`, the natural cone associated to `P` and `S` is a limit cone. -/\ntheorem isSheaf_iff_isLimit :\n    IsSheaf J P ↔\n      ∀ ⦃X : C⦄ (S : Sieve X), S ∈ J X → Nonempty (IsLimit (P.mapCone S.arrows.cocone.op)) :=\n  ⟨fun h _ S hS => (isLimit_iff_isSheafFor P S).2 fun E => h E.unop S hS, fun h E _ S hS =>\n    (isLimit_iff_isSheafFor P S).1 (h S hS) (op E)⟩\n\n"}
{"name":"CategoryTheory.Presheaf.isSeparated_iff_subsingleton","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\n⊢ Iff (∀ (E : A), CategoryTheory.Presieve.IsSeparated J (P.comp (CategoryTheory.coyoneda.obj { unop := E }))) (∀ ⦃X : C⦄ (S : CategoryTheory.Sieve X), Membership.mem (J X) S → ∀ (c : CategoryTheory.Limits.Cone (S.arrows.diagram.op.comp P)), Subsingleton (Quiver.Hom c (P.mapCone S.arrows.cocone.op)))","decl":"/-- A presheaf `P` is separated for the Grothendieck topology `J` iff for every covering sieve\n    `S` of `J`, the natural cone associated to `P` and `S` admits at most one morphism from every\n    cone in the same category. -/\ntheorem isSeparated_iff_subsingleton :\n    (∀ E : A, Presieve.IsSeparated J (P ⋙ coyoneda.obj (op E))) ↔\n      ∀ ⦃X : C⦄ (S : Sieve X), S ∈ J X → ∀ c, Subsingleton (c ⟶ P.mapCone S.arrows.cocone.op) :=\n  ⟨fun h _ S hS => (subsingleton_iff_isSeparatedFor P S).2 fun E => h E.unop S hS, fun h E _ S hS =>\n    (subsingleton_iff_isSeparatedFor P S).1 (h S hS) (op E)⟩\n\n"}
{"name":"CategoryTheory.Presheaf.isLimit_iff_isSheafFor_presieve","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nP : CategoryTheory.Functor (Opposite C) A\nX : C\nR : CategoryTheory.Presieve X\n⊢ Iff (Nonempty (CategoryTheory.Limits.IsLimit (P.mapCone (CategoryTheory.Sieve.generate R).arrows.cocone.op))) (∀ (E : Opposite A), CategoryTheory.Presieve.IsSheafFor (P.comp (CategoryTheory.coyoneda.obj E)) R)","decl":"/-- Given presieve `R` and presheaf `P : Cᵒᵖ ⥤ A`, the natural cone associated to `P` and\n    the sieve `Sieve.generate R` generated by `R` is a limit cone iff `Hom (E, P -)` is a\n    sheaf of types for the presieve `R` and all `E : A`. -/\ntheorem isLimit_iff_isSheafFor_presieve :\n    Nonempty (IsLimit (P.mapCone (generate R).arrows.cocone.op)) ↔\n      ∀ E : Aᵒᵖ, IsSheafFor (P ⋙ coyoneda.obj E) R :=\n  (isLimit_iff_isSheafFor P _).trans (forall_congr' fun _ => (isSheafFor_iff_generate _).symm)\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_iff_isLimit_pretopology","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} A\nP : CategoryTheory.Functor (Opposite C) A\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nK : CategoryTheory.Pretopology C\n⊢ Iff (CategoryTheory.Presheaf.IsSheaf (CategoryTheory.Pretopology.toGrothendieck C K) P) (∀ ⦃X : C⦄ (R : CategoryTheory.Presieve X), Membership.mem (K.coverings X) R → Nonempty (CategoryTheory.Limits.IsLimit (P.mapCone (CategoryTheory.Sieve.generate R).arrows.cocone.op)))","decl":"/-- A presheaf `P` is a sheaf for the Grothendieck topology generated by a pretopology `K`\n    iff for every covering presieve `R` of `K`, the natural cone associated to `P` and\n    `Sieve.generate R` is a limit cone. -/\ntheorem isSheaf_iff_isLimit_pretopology [HasPullbacks C] (K : Pretopology C) :\n    IsSheaf (K.toGrothendieck C) P ↔\n      ∀ ⦃X : C⦄ (R : Presieve X),\n        R ∈ K X → Nonempty (IsLimit (P.mapCone (generate R).arrows.cocone.op)) := by\n  dsimp [IsSheaf]\n  simp_rw [isSheaf_pretopology]\n  exact\n    ⟨fun h X R hR => (isLimit_iff_isSheafFor_presieve P R).2 fun E => h E.unop R hR,\n      fun h E X R hR => (isLimit_iff_isSheafFor_presieve P R).1 (h R hR) (op E)⟩\n\n"}
{"name":"CategoryTheory.Presheaf.IsSheaf.amalgamate_map","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nE : A\nX : C\nP : CategoryTheory.Functor (Opposite C) A\nhP : CategoryTheory.Presheaf.IsSheaf J P\nS : J.Cover X\nx : (I : S.Arrow) → Quiver.Hom E (P.obj { unop := I.Y })\nhx : ∀ ⦃I₁ I₂ : S.Arrow⦄ (r : I₁.Relation I₂), Eq (CategoryTheory.CategoryStruct.comp (x I₁) (P.map r.g₁.op)) (CategoryTheory.CategoryStruct.comp (x I₂) (P.map r.g₂.op))\nI : S.Arrow\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hP.amalgamate S x hx) (P.map I.f.op)) (x I)","decl":"@[reassoc (attr := simp)]\ntheorem IsSheaf.amalgamate_map {A : Type u₂} [Category.{v₂} A] {E : A} {X : C} {P : Cᵒᵖ ⥤ A}\n    (hP : Presheaf.IsSheaf J P) (S : J.Cover X) (x : ∀ I : S.Arrow, E ⟶ P.obj (op I.Y))\n    (hx : ∀ ⦃I₁ I₂ : S.Arrow⦄ (r : I₁.Relation I₂),\n       x I₁ ≫ P.map r.g₁.op = x I₂ ≫ P.map r.g₂.op)\n    (I : S.Arrow) :\n    hP.amalgamate S x hx ≫ P.map I.f.op = x _ := by\n  apply (hP _ _ S.condition).valid_glue\n\n"}
{"name":"CategoryTheory.Presheaf.IsSheaf.amalgamate_map_assoc","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nE : A\nX : C\nP : CategoryTheory.Functor (Opposite C) A\nhP : CategoryTheory.Presheaf.IsSheaf J P\nS : J.Cover X\nx : (I : S.Arrow) → Quiver.Hom E (P.obj { unop := I.Y })\nhx : ∀ ⦃I₁ I₂ : S.Arrow⦄ (r : I₁.Relation I₂), Eq (CategoryTheory.CategoryStruct.comp (x I₁) (P.map r.g₁.op)) (CategoryTheory.CategoryStruct.comp (x I₂) (P.map r.g₂.op))\nI : S.Arrow\nZ : A\nh : Quiver.Hom (P.obj { unop := I.Y }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hP.amalgamate S x hx) (CategoryTheory.CategoryStruct.comp (P.map I.f.op) h)) (CategoryTheory.CategoryStruct.comp (x I) h)","decl":"@[reassoc (attr := simp)]\ntheorem IsSheaf.amalgamate_map {A : Type u₂} [Category.{v₂} A] {E : A} {X : C} {P : Cᵒᵖ ⥤ A}\n    (hP : Presheaf.IsSheaf J P) (S : J.Cover X) (x : ∀ I : S.Arrow, E ⟶ P.obj (op I.Y))\n    (hx : ∀ ⦃I₁ I₂ : S.Arrow⦄ (r : I₁.Relation I₂),\n       x I₁ ≫ P.map r.g₁.op = x I₂ ≫ P.map r.g₂.op)\n    (I : S.Arrow) :\n    hP.amalgamate S x hx ≫ P.map I.f.op = x _ := by\n  apply (hP _ _ S.condition).valid_glue\n\n"}
{"name":"CategoryTheory.Presheaf.IsSheaf.hom_ext","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nE : A\nX : C\nP : CategoryTheory.Functor (Opposite C) A\nhP : CategoryTheory.Presheaf.IsSheaf J P\nS : J.Cover X\ne₁ e₂ : Quiver.Hom E (P.obj { unop := X })\nh : ∀ (I : S.Arrow), Eq (CategoryTheory.CategoryStruct.comp e₁ (P.map I.f.op)) (CategoryTheory.CategoryStruct.comp e₂ (P.map I.f.op))\n⊢ Eq e₁ e₂","decl":"theorem IsSheaf.hom_ext {A : Type u₂} [Category.{v₂} A] {E : A} {X : C} {P : Cᵒᵖ ⥤ A}\n    (hP : Presheaf.IsSheaf J P) (S : J.Cover X) (e₁ e₂ : E ⟶ P.obj (op X))\n    (h : ∀ I : S.Arrow, e₁ ≫ P.map I.f.op = e₂ ≫ P.map I.f.op) : e₁ = e₂ :=\n  (hP _ _ S.condition).isSeparatedFor.ext fun Y f hf => h ⟨Y, f, hf⟩\n\n"}
{"name":"CategoryTheory.Presheaf.IsSheaf.hom_ext_ofArrows","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\nhP : CategoryTheory.Presheaf.IsSheaf J P\nI : Type u_1\nS : C\nX : I → C\nf : (i : I) → Quiver.Hom (X i) S\nhf : Membership.mem (J S) (CategoryTheory.Sieve.ofArrows X f)\nE : A\nx y : Quiver.Hom E (P.obj { unop := S })\nh : ∀ (i : I), Eq (CategoryTheory.CategoryStruct.comp x (P.map (f i).op)) (CategoryTheory.CategoryStruct.comp y (P.map (f i).op))\n⊢ Eq x y","decl":"lemma IsSheaf.hom_ext_ofArrows\n    {P : Cᵒᵖ ⥤ A} (hP : Presheaf.IsSheaf J P) {I : Type*} {S : C} {X : I → C}\n    (f : ∀ i, X i ⟶ S) (hf : Sieve.ofArrows _ f ∈ J S) {E : A}\n    {x y : E ⟶ P.obj (op S)} (h : ∀ i, x ≫ P.map (f i).op = y ≫ P.map (f i).op) :\n    x = y := by\n  apply hP.hom_ext ⟨_, hf⟩\n  rintro ⟨Z, _, _, g, _, ⟨i⟩, rfl⟩\n  dsimp\n  rw [P.map_comp, reassoc_of% (h i)]\n\n"}
{"name":"CategoryTheory.Presheaf.IsSheaf.existsUnique_amalgamation_ofArrows","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\nhP : CategoryTheory.Presheaf.IsSheaf J P\nI : Type u_1\nS : C\nX : I → C\nf : (i : I) → Quiver.Hom (X i) S\nhf : Membership.mem (J S) (CategoryTheory.Sieve.ofArrows X f)\nE : A\nx : (i : I) → Quiver.Hom E (P.obj { unop := X i })\nhx : ∀ ⦃W : C⦄ ⦃i j : I⦄ (a : Quiver.Hom W (X i)) (b : Quiver.Hom W (X j)), Eq (CategoryTheory.CategoryStruct.comp a (f i)) (CategoryTheory.CategoryStruct.comp b (f j)) → Eq (CategoryTheory.CategoryStruct.comp (x i) (P.map a.op)) (CategoryTheory.CategoryStruct.comp (x j) (P.map b.op))\n⊢ ExistsUnique fun g => ∀ (i : I), Eq (CategoryTheory.CategoryStruct.comp g (P.map (f i).op)) (x i)","decl":"lemma IsSheaf.existsUnique_amalgamation_ofArrows :\n    ∃! (g : E ⟶ P.obj (op S)), ∀ (i : I), g ≫ P.map (f i).op = x i :=\n  (Presieve.isSheafFor_arrows_iff _ _).1\n    ((Presieve.isSheafFor_iff_generate _).2 (hP E _ hf)) x (fun _ _ _ _ _ w => hx _ _ w)\n\n"}
{"name":"CategoryTheory.Presheaf.IsSheaf.exists_unique_amalgamation_ofArrows","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\nhP : CategoryTheory.Presheaf.IsSheaf J P\nI : Type u_1\nS : C\nX : I → C\nf : (i : I) → Quiver.Hom (X i) S\nhf : Membership.mem (J S) (CategoryTheory.Sieve.ofArrows X f)\nE : A\nx : (i : I) → Quiver.Hom E (P.obj { unop := X i })\nhx : ∀ ⦃W : C⦄ ⦃i j : I⦄ (a : Quiver.Hom W (X i)) (b : Quiver.Hom W (X j)), Eq (CategoryTheory.CategoryStruct.comp a (f i)) (CategoryTheory.CategoryStruct.comp b (f j)) → Eq (CategoryTheory.CategoryStruct.comp (x i) (P.map a.op)) (CategoryTheory.CategoryStruct.comp (x j) (P.map b.op))\n⊢ ExistsUnique fun g => ∀ (i : I), Eq (CategoryTheory.CategoryStruct.comp g (P.map (f i).op)) (x i)","decl":"@[deprecated (since := \"2024-12-17\")]\nalias IsSheaf.exists_unique_amalgamation_ofArrows := IsSheaf.existsUnique_amalgamation_ofArrows\n\n"}
{"name":"CategoryTheory.Presheaf.IsSheaf.amalgamateOfArrows_map_assoc","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\nhP : CategoryTheory.Presheaf.IsSheaf J P\nI : Type u_1\nS : C\nX : I → C\nf : (i : I) → Quiver.Hom (X i) S\nhf : Membership.mem (J S) (CategoryTheory.Sieve.ofArrows X f)\nE : A\nx : (i : I) → Quiver.Hom E (P.obj { unop := X i })\nhx : ∀ ⦃W : C⦄ ⦃i j : I⦄ (a : Quiver.Hom W (X i)) (b : Quiver.Hom W (X j)), Eq (CategoryTheory.CategoryStruct.comp a (f i)) (CategoryTheory.CategoryStruct.comp b (f j)) → Eq (CategoryTheory.CategoryStruct.comp (x i) (P.map a.op)) (CategoryTheory.CategoryStruct.comp (x j) (P.map b.op))\ni : I\nZ : A\nh : Quiver.Hom (P.obj { unop := X i }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hP.amalgamateOfArrows f hf x hx) (CategoryTheory.CategoryStruct.comp (P.map (f i).op) h)) (CategoryTheory.CategoryStruct.comp (x i) h)","decl":"@[reassoc (attr := simp)]\nlemma IsSheaf.amalgamateOfArrows_map (i : I) :\n    hP.amalgamateOfArrows f hf x hx ≫ P.map (f i).op = x i :=\n  (hP.existsUnique_amalgamation_ofArrows f hf x hx).choose_spec.1 i\n\n"}
{"name":"CategoryTheory.Presheaf.IsSheaf.amalgamateOfArrows_map","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\nhP : CategoryTheory.Presheaf.IsSheaf J P\nI : Type u_1\nS : C\nX : I → C\nf : (i : I) → Quiver.Hom (X i) S\nhf : Membership.mem (J S) (CategoryTheory.Sieve.ofArrows X f)\nE : A\nx : (i : I) → Quiver.Hom E (P.obj { unop := X i })\nhx : ∀ ⦃W : C⦄ ⦃i j : I⦄ (a : Quiver.Hom W (X i)) (b : Quiver.Hom W (X j)), Eq (CategoryTheory.CategoryStruct.comp a (f i)) (CategoryTheory.CategoryStruct.comp b (f j)) → Eq (CategoryTheory.CategoryStruct.comp (x i) (P.map a.op)) (CategoryTheory.CategoryStruct.comp (x j) (P.map b.op))\ni : I\n⊢ Eq (CategoryTheory.CategoryStruct.comp (hP.amalgamateOfArrows f hf x hx) (P.map (f i).op)) (x i)","decl":"@[reassoc (attr := simp)]\nlemma IsSheaf.amalgamateOfArrows_map (i : I) :\n    hP.amalgamateOfArrows f hf x hx ≫ P.map (f i).op = x i :=\n  (hP.existsUnique_amalgamation_ofArrows f hf x hx).choose_spec.1 i\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_of_iso_iff","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nJ : CategoryTheory.GrothendieckTopology C\nP P' : CategoryTheory.Functor (Opposite C) A\ne : CategoryTheory.Iso P P'\n⊢ Iff (CategoryTheory.Presheaf.IsSheaf J P) (CategoryTheory.Presheaf.IsSheaf J P')","decl":"theorem isSheaf_of_iso_iff {P P' : Cᵒᵖ ⥤ A} (e : P ≅ P') : IsSheaf J P ↔ IsSheaf J P' :=\n  forall_congr' fun _ =>\n    ⟨Presieve.isSheaf_iso J (isoWhiskerRight e _),\n      Presieve.isSheaf_iso J (isoWhiskerRight e.symm _)⟩\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_of_isTerminal","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nJ : CategoryTheory.GrothendieckTopology C\nX : A\nhX : CategoryTheory.Limits.IsTerminal X\n⊢ CategoryTheory.Presheaf.IsSheaf J ((CategoryTheory.Functor.const (Opposite C)).obj X)","decl":"theorem isSheaf_of_isTerminal {X : A} (hX : IsTerminal X) :\n    Presheaf.IsSheaf J ((CategoryTheory.Functor.const _).obj X) := fun _ _ _ _ _ _ =>\n  ⟨hX.from _, fun _ _ _ => hX.hom_ext _ _, fun _ _ => hX.hom_ext _ _⟩\n\n"}
{"name":"CategoryTheory.Sheaf.cond","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nself : CategoryTheory.Sheaf J A\n⊢ CategoryTheory.Presheaf.IsSheaf J self.val","decl":"/-- The category of sheaves taking values in `A` on a grothendieck topology. -/\nstructure Sheaf where\n  /-- the underlying presheaf -/\n  val : Cᵒᵖ ⥤ A\n  /-- the condition that the presheaf is a sheaf -/\n  cond : Presheaf.IsSheaf J val\n\n"}
{"name":"CategoryTheory.Sheaf.mk.inj","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nval✝ : CategoryTheory.Functor (Opposite C) A\ncond✝ : CategoryTheory.Presheaf.IsSheaf J val✝\nval : CategoryTheory.Functor (Opposite C) A\ncond : CategoryTheory.Presheaf.IsSheaf J val\nx✝ : Eq { val := val✝, cond := cond✝ } { val := val, cond := cond }\n⊢ Eq val✝ val","decl":"/-- The category of sheaves taking values in `A` on a grothendieck topology. -/\nstructure Sheaf where\n  /-- the underlying presheaf -/\n  val : Cᵒᵖ ⥤ A\n  /-- the condition that the presheaf is a sheaf -/\n  cond : Presheaf.IsSheaf J val\n\n"}
{"name":"CategoryTheory.Sheaf.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} A\ninst✝¹ : SizeOf C\ninst✝ : SizeOf A\nval : CategoryTheory.Functor (Opposite C) A\ncond : CategoryTheory.Presheaf.IsSheaf J val\n⊢ Eq (SizeOf.sizeOf { val := val, cond := cond }) (HAdd.hAdd 1 (SizeOf.sizeOf val))","decl":"/-- The category of sheaves taking values in `A` on a grothendieck topology. -/\nstructure Sheaf where\n  /-- the underlying presheaf -/\n  val : Cᵒᵖ ⥤ A\n  /-- the condition that the presheaf is a sheaf -/\n  cond : Presheaf.IsSheaf J val\n\n"}
{"name":"CategoryTheory.Sheaf.mk.injEq","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nval✝ : CategoryTheory.Functor (Opposite C) A\ncond✝ : CategoryTheory.Presheaf.IsSheaf J val✝\nval : CategoryTheory.Functor (Opposite C) A\ncond : CategoryTheory.Presheaf.IsSheaf J val\n⊢ Eq (Eq { val := val✝, cond := cond✝ } { val := val, cond := cond }) (Eq val✝ val)","decl":"/-- The category of sheaves taking values in `A` on a grothendieck topology. -/\nstructure Sheaf where\n  /-- the underlying presheaf -/\n  val : Cᵒᵖ ⥤ A\n  /-- the condition that the presheaf is a sheaf -/\n  cond : Presheaf.IsSheaf J val\n\n"}
{"name":"CategoryTheory.Sheaf.Hom.mk.inj","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nX Y : CategoryTheory.Sheaf J A\nval✝ val : Quiver.Hom X.val Y.val\nx✝ : Eq { val := val✝ } { val := val }\n⊢ Eq val✝ val","decl":"/-- Morphisms between sheaves are just morphisms of presheaves. -/\n@[ext]\nstructure Hom (X Y : Sheaf J A) where\n  /-- a morphism between the underlying presheaves -/\n  val : X.val ⟶ Y.val\n\n"}
{"name":"CategoryTheory.Sheaf.Hom.ext_iff","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nX Y : CategoryTheory.Sheaf J A\nx y : X.Hom Y\n⊢ Iff (Eq x y) (Eq x.val y.val)","decl":"/-- Morphisms between sheaves are just morphisms of presheaves. -/\n@[ext]\nstructure Hom (X Y : Sheaf J A) where\n  /-- a morphism between the underlying presheaves -/\n  val : X.val ⟶ Y.val\n\n"}
{"name":"CategoryTheory.Sheaf.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nX Y : CategoryTheory.Sheaf J A\nval✝ val : Quiver.Hom X.val Y.val\n⊢ Eq (Eq { val := val✝ } { val := val }) (Eq val✝ val)","decl":"/-- Morphisms between sheaves are just morphisms of presheaves. -/\n@[ext]\nstructure Hom (X Y : Sheaf J A) where\n  /-- a morphism between the underlying presheaves -/\n  val : X.val ⟶ Y.val\n\n"}
{"name":"CategoryTheory.Sheaf.Hom.ext","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nX Y : CategoryTheory.Sheaf J A\nx y : X.Hom Y\nval : Eq x.val y.val\n⊢ Eq x y","decl":"/-- Morphisms between sheaves are just morphisms of presheaves. -/\n@[ext]\nstructure Hom (X Y : Sheaf J A) where\n  /-- a morphism between the underlying presheaves -/\n  val : X.val ⟶ Y.val\n\n"}
{"name":"CategoryTheory.Sheaf.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} A\nX Y : CategoryTheory.Sheaf J A\ninst✝¹ : SizeOf C\ninst✝ : SizeOf A\nval : Quiver.Hom X.val Y.val\n⊢ Eq (SizeOf.sizeOf { val := val }) (HAdd.hAdd 1 (SizeOf.sizeOf val))","decl":"/-- Morphisms between sheaves are just morphisms of presheaves. -/\n@[ext]\nstructure Hom (X Y : Sheaf J A) where\n  /-- a morphism between the underlying presheaves -/\n  val : X.val ⟶ Y.val\n\n"}
{"name":"CategoryTheory.Sheaf.instCategorySheaf_id_val","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nx✝ : CategoryTheory.Sheaf J A\n⊢ Eq (CategoryTheory.CategoryStruct.id x✝).val (CategoryTheory.CategoryStruct.id x✝.val)","decl":"@[simps id_val comp_val]\ninstance instCategorySheaf : Category (Sheaf J A) where\n  Hom := Hom\n  id _ := ⟨𝟙 _⟩\n  comp f g := ⟨f.val ≫ g.val⟩\n  id_comp _ := Hom.ext <| id_comp _\n  comp_id _ := Hom.ext <| comp_id _\n  assoc _ _ _ := Hom.ext <| assoc _ _ _\n\n-- Let's make the inhabited linter happy.../sips\n"}
{"name":"CategoryTheory.Sheaf.instCategorySheaf_comp_val","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nX✝ Y✝ Z✝ : CategoryTheory.Sheaf J A\nf : Quiver.Hom X✝ Y✝\ng : Quiver.Hom Y✝ Z✝\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).val (CategoryTheory.CategoryStruct.comp f.val g.val)","decl":"@[simps id_val comp_val]\ninstance instCategorySheaf : Category (Sheaf J A) where\n  Hom := Hom\n  id _ := ⟨𝟙 _⟩\n  comp f g := ⟨f.val ≫ g.val⟩\n  id_comp _ := Hom.ext <| id_comp _\n  comp_id _ := Hom.ext <| comp_id _\n  assoc _ _ _ := Hom.ext <| assoc _ _ _\n\n-- Let's make the inhabited linter happy.../sips\n"}
{"name":"CategoryTheory.Sheaf.hom_ext","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nX Y : CategoryTheory.Sheaf J A\nx y : Quiver.Hom X Y\nh : Eq x.val y.val\n⊢ Eq x y","decl":"@[ext]\nlemma hom_ext {X Y : Sheaf J A} (x y : X ⟶ Y) (h : x.val = y.val) : x = y :=\n  Sheaf.Hom.ext h\n\n"}
{"name":"CategoryTheory.Sheaf.hom_ext_iff","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nX Y : CategoryTheory.Sheaf J A\nx y : Quiver.Hom X Y\n⊢ Iff (Eq x y) (Eq x.val y.val)","decl":"@[ext]\nlemma hom_ext {X Y : Sheaf J A} (x y : X ⟶ Y) (h : x.val = y.val) : x = y :=\n  Sheaf.Hom.ext h\n\n"}
{"name":"CategoryTheory.sheafToPresheaf_map","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nX✝ Y✝ : CategoryTheory.Sheaf J A\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.sheafToPresheaf J A).map f) f.val","decl":"/-- The inclusion functor from sheaves to presheaves. -/\n@[simps]\ndef sheafToPresheaf : Sheaf J A ⥤ Cᵒᵖ ⥤ A where\n  obj := Sheaf.val\n  map f := f.val\n  map_id _ := rfl\n  map_comp _ _ := rfl\n\n"}
{"name":"CategoryTheory.sheafToPresheaf_obj","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nself : CategoryTheory.Sheaf J A\n⊢ Eq ((CategoryTheory.sheafToPresheaf J A).obj self) self.val","decl":"/-- The inclusion functor from sheaves to presheaves. -/\n@[simps]\ndef sheafToPresheaf : Sheaf J A ⥤ Cᵒᵖ ⥤ A where\n  obj := Sheaf.val\n  map f := f.val\n  map_id _ := rfl\n  map_comp _ _ := rfl\n\n"}
{"name":"CategoryTheory.fullyFaithfulSheafToPresheaf_preimage_val","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nX✝ Y✝ : CategoryTheory.Sheaf J A\nf : Quiver.Hom ((CategoryTheory.sheafToPresheaf J A).obj X✝) ((CategoryTheory.sheafToPresheaf J A).obj Y✝)\n⊢ Eq ((CategoryTheory.fullyFaithfulSheafToPresheaf J A).preimage f).val f","decl":"/-- The functor `Sheaf J A ⥤ Cᵒᵖ ⥤ A` is fully faithful. -/\n@[simps]\ndef fullyFaithfulSheafToPresheaf : (sheafToPresheaf J A).FullyFaithful where\n  preimage f := ⟨f⟩\n\n"}
{"name":"CategoryTheory.instFullSheafFunctorOppositeSheafToPresheaf","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\n⊢ (CategoryTheory.sheafToPresheaf J A).Full","decl":"instance : (sheafToPresheaf J A).Full :=\n  (fullyFaithfulSheafToPresheaf J A).full\n\n"}
{"name":"CategoryTheory.instFaithfulSheafFunctorOppositeSheafToPresheaf","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\n⊢ (CategoryTheory.sheafToPresheaf J A).Faithful","decl":"instance : (sheafToPresheaf J A).Faithful :=\n  (fullyFaithfulSheafToPresheaf J A).faithful\n\n"}
{"name":"CategoryTheory.instReflectsIsomorphismsSheafFunctorOppositeSheafToPresheaf","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\n⊢ (CategoryTheory.sheafToPresheaf J A).ReflectsIsomorphisms","decl":"instance : (sheafToPresheaf J A).ReflectsIsomorphisms :=\n  (fullyFaithfulSheafToPresheaf J A).reflectsIsomorphisms\n\n"}
{"name":"CategoryTheory.Sheaf.Hom.mono_of_presheaf_mono","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nF G : CategoryTheory.Sheaf J A\nf : Quiver.Hom F G\nh : CategoryTheory.Mono f.val\n⊢ CategoryTheory.Mono f","decl":"/-- This is stated as a lemma to prevent class search from forming a loop since a sheaf morphism is\nmonic if and only if it is monic as a presheaf morphism (under suitable assumption). -/\ntheorem Sheaf.Hom.mono_of_presheaf_mono {F G : Sheaf J A} (f : F ⟶ G) [h : Mono f.1] : Mono f :=\n  (sheafToPresheaf J A).mono_of_mono_map h\n\n"}
{"name":"CategoryTheory.Sheaf.Hom.epi_of_presheaf_epi","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nF G : CategoryTheory.Sheaf J A\nf : Quiver.Hom F G\nh : CategoryTheory.Epi f.val\n⊢ CategoryTheory.Epi f","decl":"instance Sheaf.Hom.epi_of_presheaf_epi {F G : Sheaf J A} (f : F ⟶ G) [h : Epi f.1] : Epi f :=\n  (sheafToPresheaf J A).epi_of_epi_map h\n\n"}
{"name":"CategoryTheory.isSheaf_iff_isSheaf_of_type","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) (Type w)\n⊢ Iff (CategoryTheory.Presheaf.IsSheaf J P) (CategoryTheory.Presieve.IsSheaf J P)","decl":"theorem isSheaf_iff_isSheaf_of_type (P : Cᵒᵖ ⥤ Type w) :\n    Presheaf.IsSheaf J P ↔ Presieve.IsSheaf J P := by\n  constructor\n  · intro hP\n    refine Presieve.isSheaf_iso J ?_ (hP PUnit)\n    exact isoWhiskerLeft _ Coyoneda.punitIso ≪≫ P.rightUnitor\n  · intro hP X Y S hS z hz\n    refine ⟨fun x => (hP S hS).amalgamate (fun Z f hf => z f hf x) ?_, ?_, ?_⟩\n    · intro Y₁ Y₂ Z g₁ g₂ f₁ f₂ hf₁ hf₂ h\n      exact congr_fun (hz g₁ g₂ hf₁ hf₂ h) x\n    · intro Z f hf\n      funext x\n      apply Presieve.IsSheafFor.valid_glue\n    · intro y hy\n      funext x\n      apply (hP S hS).isSeparatedFor.ext\n      intro Y' f hf\n      rw [Presieve.IsSheafFor.valid_glue _ _ _ hf, ← hy _ hf]\n      rfl\n\n"}
{"name":"CategoryTheory.sheafOver_val","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nJ : CategoryTheory.GrothendieckTopology C\nℱ : CategoryTheory.Sheaf J A\nE : A\n⊢ Eq (CategoryTheory.sheafOver ℱ E).val (ℱ.val.comp (CategoryTheory.coyoneda.obj { unop := E }))","decl":"/-- The sheaf of sections guaranteed by the sheaf condition. -/\n@[simps]\ndef sheafOver {A : Type u₂} [Category.{v₂} A] {J : GrothendieckTopology C} (ℱ : Sheaf J A) (E : A) :\n    Sheaf J (Type _) where\n  val := ℱ.val ⋙ coyoneda.obj (op E)\n  cond := by\n    rw [isSheaf_iff_isSheaf_of_type]\n    exact ℱ.cond E\n\n"}
{"name":"CategoryTheory.Presheaf.IsSheaf.isSheafFor","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) (Type w)\nhP : CategoryTheory.Presheaf.IsSheaf J P\nX : C\nS : CategoryTheory.Sieve X\nhS : Membership.mem (J X) S\n⊢ CategoryTheory.Presieve.IsSheafFor P S.arrows","decl":"variable {J} in\nlemma Presheaf.IsSheaf.isSheafFor {P : Cᵒᵖ ⥤ Type w} (hP : Presheaf.IsSheaf J P)\n    {X : C} (S : Sieve X) (hS : S ∈ J X) : Presieve.IsSheafFor P S.arrows := by\n  rw [isSheaf_iff_isSheaf_of_type] at hP\n  exact hP S hS\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_bot","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nP : CategoryTheory.Functor (Opposite C) A\n⊢ CategoryTheory.Presheaf.IsSheaf Bot.bot P","decl":"variable {A} in\nlemma Presheaf.isSheaf_bot (P : Cᵒᵖ ⥤ A) : IsSheaf ⊥ P := fun _ ↦ Presieve.isSheaf_bot\n\n"}
{"name":"CategoryTheory.sheafBotEquivalence_functor","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\n⊢ Eq (CategoryTheory.sheafBotEquivalence A).functor (CategoryTheory.sheafToPresheaf Bot.bot A)","decl":"/--\nThe category of sheaves on the bottom (trivial) Grothendieck topology is\nequivalent to the category of presheaves.\n-/\n@[simps]\ndef sheafBotEquivalence : Sheaf (⊥ : GrothendieckTopology C) A ≌ Cᵒᵖ ⥤ A where\n  functor := sheafToPresheaf _ _\n  inverse :=\n    { obj := fun P => ⟨P, Presheaf.isSheaf_bot P⟩\n      map := fun f => ⟨f⟩ }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.sheafBotEquivalence_inverse_map_val","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nX✝ Y✝ : CategoryTheory.Functor (Opposite C) A\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.sheafBotEquivalence A).inverse.map f).val f","decl":"/--\nThe category of sheaves on the bottom (trivial) Grothendieck topology is\nequivalent to the category of presheaves.\n-/\n@[simps]\ndef sheafBotEquivalence : Sheaf (⊥ : GrothendieckTopology C) A ≌ Cᵒᵖ ⥤ A where\n  functor := sheafToPresheaf _ _\n  inverse :=\n    { obj := fun P => ⟨P, Presheaf.isSheaf_bot P⟩\n      map := fun f => ⟨f⟩ }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.sheafBotEquivalence_counitIso","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\n⊢ Eq (CategoryTheory.sheafBotEquivalence A).counitIso (CategoryTheory.Iso.refl ({ obj := fun P => { val := P, cond := ⋯ }, map := fun {X Y} f => { val := f }, map_id := ⋯, map_comp := ⋯ }.comp (CategoryTheory.sheafToPresheaf Bot.bot A)))","decl":"/--\nThe category of sheaves on the bottom (trivial) Grothendieck topology is\nequivalent to the category of presheaves.\n-/\n@[simps]\ndef sheafBotEquivalence : Sheaf (⊥ : GrothendieckTopology C) A ≌ Cᵒᵖ ⥤ A where\n  functor := sheafToPresheaf _ _\n  inverse :=\n    { obj := fun P => ⟨P, Presheaf.isSheaf_bot P⟩\n      map := fun f => ⟨f⟩ }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.sheafBotEquivalence_inverse_obj_val","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nP : CategoryTheory.Functor (Opposite C) A\n⊢ Eq ((CategoryTheory.sheafBotEquivalence A).inverse.obj P).val P","decl":"/--\nThe category of sheaves on the bottom (trivial) Grothendieck topology is\nequivalent to the category of presheaves.\n-/\n@[simps]\ndef sheafBotEquivalence : Sheaf (⊥ : GrothendieckTopology C) A ≌ Cᵒᵖ ⥤ A where\n  functor := sheafToPresheaf _ _\n  inverse :=\n    { obj := fun P => ⟨P, Presheaf.isSheaf_bot P⟩\n      map := fun f => ⟨f⟩ }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.sheafBotEquivalence_unitIso","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\n⊢ Eq (CategoryTheory.sheafBotEquivalence A).unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (CategoryTheory.Sheaf Bot.bot A)))","decl":"/--\nThe category of sheaves on the bottom (trivial) Grothendieck topology is\nequivalent to the category of presheaves.\n-/\n@[simps]\ndef sheafBotEquivalence : Sheaf (⊥ : GrothendieckTopology C) A ≌ Cᵒᵖ ⥤ A where\n  functor := sheafToPresheaf _ _\n  inverse :=\n    { obj := fun P => ⟨P, Presheaf.isSheaf_bot P⟩\n      map := fun f => ⟨f⟩ }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Sheaf.Hom.add_app","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : CategoryTheory.GrothendieckTopology C\nA : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} A\ninst✝ : CategoryTheory.Preadditive A\nP Q : CategoryTheory.Sheaf J A\nf g : Quiver.Hom P Q\nU : Opposite C\n⊢ Eq ((HAdd.hAdd f g).val.app U) (HAdd.hAdd (f.val.app U) (g.val.app U))","decl":"@[simp]\ntheorem Sheaf.Hom.add_app (f g : P ⟶ Q) (U) : (f + g).1.app U = f.1.app U + g.1.app U :=\n  rfl\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_iff_multifork","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} A\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\n⊢ Iff (CategoryTheory.Presheaf.IsSheaf J P) (∀ (X : C) (S : J.Cover X), Nonempty (CategoryTheory.Limits.IsLimit (S.multifork P)))","decl":"theorem isSheaf_iff_multifork :\n    IsSheaf J P ↔ ∀ (X : C) (S : J.Cover X), Nonempty (IsLimit (S.multifork P)) := by\n  refine ⟨fun hP X S => ⟨isLimitOfIsSheaf _ _ _ hP⟩, ?_⟩\n  intro h E X S hS x hx\n  let T : J.Cover X := ⟨S, hS⟩\n  obtain ⟨hh⟩ := h _ T\n  let K : Multifork (T.index P) := Multifork.ofι _ E (fun I => x I.f I.hf)\n    (fun I => hx _ _ _ _ I.r.w)\n  use hh.lift K\n  dsimp; constructor\n  · intro Y f hf\n    apply hh.fac K (WalkingMulticospan.left ⟨Y, f, hf⟩)\n  · intro e he\n    apply hh.uniq K\n    rintro (a | b)\n    · apply he\n    · rw [← K.w (WalkingMulticospan.Hom.fst b), ←\n        (T.multifork P).w (WalkingMulticospan.Hom.fst b), ← assoc]\n      congr 1\n      apply he\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_iff_multiequalizer","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} A\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\ninst✝ : ∀ (X : C) (S : J.Cover X), CategoryTheory.Limits.HasMultiequalizer (S.index P)\n⊢ Iff (CategoryTheory.Presheaf.IsSheaf J P) (∀ (X : C) (S : J.Cover X), CategoryTheory.IsIso (S.toMultiequalizer P))","decl":"theorem isSheaf_iff_multiequalizer [∀ (X : C) (S : J.Cover X), HasMultiequalizer (S.index P)] :\n    IsSheaf J P ↔ ∀ (X : C) (S : J.Cover X), IsIso (S.toMultiequalizer P) := by\n  rw [isSheaf_iff_multifork]\n  refine forall₂_congr fun X S => ⟨?_, ?_⟩\n  · rintro ⟨h⟩\n    let e : P.obj (op X) ≅ multiequalizer (S.index P) :=\n      h.conePointUniqueUpToIso (limit.isLimit _)\n    exact (inferInstance : IsIso e.hom)\n  · intro h\n    refine ⟨IsLimit.ofIsoLimit (limit.isLimit _) (Cones.ext ?_ ?_)⟩\n    · apply (@asIso _ _ _ _ _ h).symm\n    · intro a\n      symm\n      simp\n\n"}
{"name":"CategoryTheory.Presheaf.w","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} A\nU : C\nR : CategoryTheory.Presieve U\nP : CategoryTheory.Functor (Opposite C) A\ninst✝¹ : CategoryTheory.Limits.HasProducts A\ninst✝ : CategoryTheory.Limits.HasPullbacks C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Presheaf.forkMap R P) (CategoryTheory.Presheaf.firstMap R P)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Presheaf.forkMap R P) (CategoryTheory.Presheaf.secondMap R P))","decl":"theorem w : forkMap R P ≫ firstMap R P = forkMap R P ≫ secondMap R P := by\n  apply limit.hom_ext\n  rintro ⟨⟨Y, f, hf⟩, ⟨Z, g, hg⟩⟩\n  simp only [firstMap, secondMap, forkMap, limit.lift_π, limit.lift_π_assoc, assoc, Fan.mk_π_app,\n    Subtype.coe_mk]\n  rw [← P.map_comp, ← op_comp, pullback.condition]\n  simp\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_iff_isSheaf'","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nA' : Type u₂\ninst✝² : CategoryTheory.Category.{max v₁ u₁, u₂} A'\nJ : CategoryTheory.GrothendieckTopology C\nP' : CategoryTheory.Functor (Opposite C) A'\ninst✝¹ : CategoryTheory.Limits.HasProducts A'\ninst✝ : CategoryTheory.Limits.HasPullbacks C\n⊢ Iff (CategoryTheory.Presheaf.IsSheaf J P') (CategoryTheory.Presheaf.IsSheaf' J P')","decl":"/-- The equalizer definition of a sheaf given by `isSheaf'` is equivalent to `isSheaf`. -/\ntheorem isSheaf_iff_isSheaf' : IsSheaf J P' ↔ IsSheaf' J P' := by\n  constructor\n  · intro h U R hR\n    refine ⟨?_⟩\n    apply coyonedaJointlyReflectsLimits\n    intro X\n    have q : Presieve.IsSheafFor (P' ⋙ coyoneda.obj X) _ := h X.unop _ hR\n    rw [← Presieve.isSheafFor_iff_generate] at q\n    rw [Equalizer.Presieve.sheaf_condition] at q\n    replace q := Classical.choice q\n    apply (isSheafForIsSheafFor' _ _ _ _).symm q\n  · intro h U X S hS\n    rw [Equalizer.Presieve.sheaf_condition]\n    refine ⟨?_⟩\n    refine isSheafForIsSheafFor' _ _ _ _ ?_\n    letI := preservesSmallestLimits_of_preservesLimits (coyoneda.obj (op U))\n    apply isLimitOfPreserves\n    apply Classical.choice (h _ S.arrows _)\n    simpa\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_of_isSheaf_comp","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} A\nB : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} B\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\ns : CategoryTheory.Functor A B\ninst✝ : CategoryTheory.Limits.ReflectsLimitsOfSize.{v₁, max v₁ u₁, v₂, v₃, u₂, u₃} s\nh : CategoryTheory.Presheaf.IsSheaf J (P.comp s)\n⊢ CategoryTheory.Presheaf.IsSheaf J P","decl":"theorem isSheaf_of_isSheaf_comp (s : A ⥤ B) [ReflectsLimitsOfSize.{v₁, max v₁ u₁} s]\n    (h : IsSheaf J (P ⋙ s)) : IsSheaf J P := by\n  rw [isSheaf_iff_isLimit] at h ⊢\n  exact fun X S hS ↦ (h S hS).map fun t ↦ isLimitOfReflects s t\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_comp_of_isSheaf","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} A\nB : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} B\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\ns : CategoryTheory.Functor A B\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfSize.{v₁, max v₁ u₁, v₂, v₃, u₂, u₃} s\nh : CategoryTheory.Presheaf.IsSheaf J P\n⊢ CategoryTheory.Presheaf.IsSheaf J (P.comp s)","decl":"theorem isSheaf_comp_of_isSheaf (s : A ⥤ B) [PreservesLimitsOfSize.{v₁, max v₁ u₁} s]\n    (h : IsSheaf J P) : IsSheaf J (P ⋙ s) := by\n  rw [isSheaf_iff_isLimit] at h ⊢\n  apply fun X S hS ↦ (h S hS).map fun t ↦ isLimitOfPreserves s t\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_iff_isSheaf_comp","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nA : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} A\nB : Type u₃\ninst✝³ : CategoryTheory.Category.{v₃, u₃} B\nJ : CategoryTheory.GrothendieckTopology C\nP : CategoryTheory.Functor (Opposite C) A\ns : CategoryTheory.Functor A B\ninst✝² : CategoryTheory.Limits.HasLimitsOfSize.{v₁, max v₁ u₁, v₂, u₂} A\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfSize.{v₁, max v₁ u₁, v₂, v₃, u₂, u₃} s\ninst✝ : s.ReflectsIsomorphisms\n⊢ Iff (CategoryTheory.Presheaf.IsSheaf J P) (CategoryTheory.Presheaf.IsSheaf J (P.comp s))","decl":"theorem isSheaf_iff_isSheaf_comp (s : A ⥤ B) [HasLimitsOfSize.{v₁, max v₁ u₁} A]\n    [PreservesLimitsOfSize.{v₁, max v₁ u₁} s] [s.ReflectsIsomorphisms] :\n    IsSheaf J P ↔ IsSheaf J (P ⋙ s) := by\n  letI : ReflectsLimitsOfSize s := reflectsLimits_of_reflectsIsomorphisms\n  exact ⟨isSheaf_comp_of_isSheaf J P s, isSheaf_of_isSheaf_comp J P s⟩\n\n"}
{"name":"CategoryTheory.Presheaf.isSheaf_iff_isSheaf_forget","module":"Mathlib.CategoryTheory.Sites.Sheaf","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nA' : Type u₂\ninst✝³ : CategoryTheory.Category.{max v₁ u₁, u₂} A'\nJ : CategoryTheory.GrothendieckTopology C\nP' : CategoryTheory.Functor (Opposite C) A'\ns : CategoryTheory.Functor A' (Type (max v₁ u₁))\ninst✝² : CategoryTheory.Limits.HasLimits A'\ninst✝¹ : CategoryTheory.Limits.PreservesLimits s\ninst✝ : s.ReflectsIsomorphisms\n⊢ Iff (CategoryTheory.Presheaf.IsSheaf J P') (CategoryTheory.Presheaf.IsSheaf J (P'.comp s))","decl":"/--\nFor a concrete category `(A, s)` where the forgetful functor `s : A ⥤ Type v` preserves limits and\nreflects isomorphisms, and `A` has limits, an `A`-valued presheaf `P : Cᵒᵖ ⥤ A` is a sheaf iff its\nunderlying `Type`-valued presheaf `P ⋙ s : Cᵒᵖ ⥤ Type` is a sheaf.\n\nNote this lemma applies for \"algebraic\" categories, eg groups, abelian groups and rings, but not\nfor the category of topological spaces, topological rings, etc since reflecting isomorphisms doesn't\nhold.\n-/\ntheorem isSheaf_iff_isSheaf_forget (s : A' ⥤ Type max v₁ u₁) [HasLimits A'] [PreservesLimits s]\n    [s.ReflectsIsomorphisms] : IsSheaf J P' ↔ IsSheaf J (P' ⋙ s) := by\n  have : HasLimitsOfSize.{v₁, max v₁ u₁} A' := hasLimitsOfSizeShrink.{_, _, u₁, 0} A'\n  have : PreservesLimitsOfSize.{v₁, max v₁ u₁} s := preservesLimitsOfSize_shrink.{_, 0, _, u₁} s\n  apply isSheaf_iff_isSheaf_comp\n\n"}
