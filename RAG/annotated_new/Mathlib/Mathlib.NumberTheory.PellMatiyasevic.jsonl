{"name":"Pell.isPell_norm","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"d : Int\nb : Zsqrtd d\n⊢ Iff (Pell.IsPell b) (Eq (HMul.hMul b (Star.star b)) 1)","decl":"theorem isPell_norm : ∀ {b : ℤ√d}, IsPell b ↔ b * star b = 1\n  | ⟨x, y⟩ => by simp [Zsqrtd.ext_iff, IsPell, mul_comm]; ring_nf\n\n"}
{"name":"Pell.isPell_iff_mem_unitary","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"d : Int\nb : Zsqrtd d\n⊢ Iff (Pell.IsPell b) (Membership.mem (unitary (Zsqrtd d)) b)","decl":"theorem isPell_iff_mem_unitary : ∀ {b : ℤ√d}, IsPell b ↔ b ∈ unitary (ℤ√d)\n  | ⟨x, y⟩ => by rw [unitary.mem_iff, isPell_norm, mul_comm (star _), and_self_iff]\n\n"}
{"name":"Pell.isPell_mul","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"d : Int\nb c : Zsqrtd d\nhb : Pell.IsPell b\nhc : Pell.IsPell c\n⊢ Pell.IsPell (HMul.hMul b c)","decl":"theorem isPell_mul {b c : ℤ√d} (hb : IsPell b) (hc : IsPell c) : IsPell (b * c) :=\n  isPell_norm.2 (by simp [mul_comm, mul_left_comm c, mul_assoc,\n    star_mul, isPell_norm.1 hb, isPell_norm.1 hc])\n\n"}
{"name":"Pell.isPell_star","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"d : Int\nb : Zsqrtd d\n⊢ Iff (Pell.IsPell b) (Pell.IsPell (Star.star b))","decl":"theorem isPell_star : ∀ {b : ℤ√d}, IsPell b ↔ IsPell (star b)\n  | ⟨x, y⟩ => by simp [IsPell, Zsqrtd.star_mk]\n\n"}
{"name":"Pell.d_pos","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\n⊢ LT.lt 0 (Pell.d a1)","decl":"@[simp]\ntheorem d_pos : 0 < d a1 :=\n  tsub_pos_of_lt (mul_lt_mul a1 (le_of_lt a1) (by decide) (Nat.zero_le _) : 1 * 1 < a * a)\n\n-- TODO(lint): Fix double namespace issue\n"}
{"name":"Pell.pell_val","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ Eq (Pell.pell a1 n) { fst := Pell.xn a1 n, snd := Pell.yn a1 n }","decl":"@[simp]\ntheorem pell_val (n : ℕ) : pell a1 n = (xn a1 n, yn a1 n) :=\n  show pell a1 n = ((pell a1 n).1, (pell a1 n).2) from\n    match pell a1 n with\n    | (_, _) => rfl\n\n"}
{"name":"Pell.xn_zero","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\n⊢ Eq (Pell.xn a1 0) 1","decl":"@[simp]\ntheorem xn_zero : xn a1 0 = 1 :=\n  rfl\n\n"}
{"name":"Pell.yn_zero","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\n⊢ Eq (Pell.yn a1 0) 0","decl":"@[simp]\ntheorem yn_zero : yn a1 0 = 0 :=\n  rfl\n\n"}
{"name":"Pell.xn_succ","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ Eq (Pell.xn a1 (HAdd.hAdd n 1)) (HAdd.hAdd (HMul.hMul (Pell.xn a1 n) a) (HMul.hMul (Pell.d a1) (Pell.yn a1 n)))","decl":"@[simp]\ntheorem xn_succ (n : ℕ) : xn a1 (n + 1) = xn a1 n * a + d a1 * yn a1 n :=\n  rfl\n\n"}
{"name":"Pell.yn_succ","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ Eq (Pell.yn a1 (HAdd.hAdd n 1)) (HAdd.hAdd (Pell.xn a1 n) (HMul.hMul (Pell.yn a1 n) a))","decl":"@[simp]\ntheorem yn_succ (n : ℕ) : yn a1 (n + 1) = xn a1 n + yn a1 n * a :=\n  rfl\n\n"}
{"name":"Pell.xn_one","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\n⊢ Eq (Pell.xn a1 1) a","decl":"theorem xn_one : xn a1 1 = a := by simp\n\n"}
{"name":"Pell.yn_one","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\n⊢ Eq (Pell.yn a1 1) 1","decl":"theorem yn_one : yn a1 1 = 1 := by simp\n\n"}
{"name":"Pell.asq_pos","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\n⊢ LT.lt 0 (HMul.hMul a a)","decl":"include a1 in\ntheorem asq_pos : 0 < a * a :=\n  le_trans (le_of_lt a1)\n    (by have := @Nat.mul_le_mul_left 1 a a (le_of_lt a1); rwa [mul_one] at this)\n\n"}
{"name":"Pell.dz_val","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\n⊢ Eq (↑(Pell.d a1)) (HSub.hSub (HMul.hMul (Pell.az a) (Pell.az a)) 1)","decl":"theorem dz_val : ↑(d a1) = az a * az a - 1 :=\n  have : 1 ≤ a * a := asq_pos a1\n  by rw [Pell.d, Int.ofNat_sub this]; rfl\n\n"}
{"name":"Pell.xz_succ","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ Eq (Pell.xz a1 (HAdd.hAdd n 1)) (HAdd.hAdd (HMul.hMul (Pell.xz a1 n) (Pell.az a)) (HMul.hMul (↑(Pell.d a1)) (Pell.yz a1 n)))","decl":"@[simp]\ntheorem xz_succ (n : ℕ) : (xz a1 (n + 1)) = xz a1 n * az a + d a1 * yz a1 n :=\n  rfl\n\n"}
{"name":"Pell.yz_succ","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ Eq (Pell.yz a1 (HAdd.hAdd n 1)) (HAdd.hAdd (Pell.xz a1 n) (HMul.hMul (Pell.yz a1 n) (Pell.az a)))","decl":"@[simp]\ntheorem yz_succ (n : ℕ) : yz a1 (n + 1) = xz a1 n + yz a1 n * az a :=\n  rfl\n\n"}
{"name":"Pell.pellZd_re","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ Eq (Pell.pellZd a1 n).re ↑(Pell.xn a1 n)","decl":"@[simp]\ntheorem pellZd_re (n : ℕ) : (pellZd a1 n).re = xn a1 n :=\n  rfl\n\n"}
{"name":"Pell.pellZd_im","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ Eq (Pell.pellZd a1 n).im ↑(Pell.yn a1 n)","decl":"@[simp]\ntheorem pellZd_im (n : ℕ) : (pellZd a1 n).im = yn a1 n :=\n  rfl\n\n"}
{"name":"Pell.isPell_nat","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nx y : Nat\n⊢ Iff (Pell.IsPell { re := ↑x, im := ↑y }) (Eq (HSub.hSub (HMul.hMul x x) (HMul.hMul (HMul.hMul (Pell.d a1) y) y)) 1)","decl":"theorem isPell_nat {x y : ℕ} : IsPell (⟨x, y⟩ : ℤ√(d a1)) ↔ x * x - d a1 * y * y = 1 :=\n  ⟨fun h =>\n    (Nat.cast_inj (R := ℤ)).1\n      (by rw [Int.ofNat_sub (Int.le_of_ofNat_le_ofNat <| Int.le.intro_sub _ h)]; exact h),\n    fun h =>\n    show ((x * x : ℕ) - (d a1 * y * y : ℕ) : ℤ) = 1 by\n      rw [← Int.ofNat_sub <| le_of_lt <| Nat.lt_of_sub_eq_succ h, h]; rfl⟩\n\n"}
{"name":"Pell.pellZd_succ","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ Eq (Pell.pellZd a1 (HAdd.hAdd n 1)) (HMul.hMul (Pell.pellZd a1 n) { re := ↑a, im := 1 })","decl":"@[simp]\ntheorem pellZd_succ (n : ℕ) : pellZd a1 (n + 1) = pellZd a1 n * ⟨a, 1⟩ := by ext <;> simp\n\n"}
{"name":"Pell.isPell_one","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\n⊢ Pell.IsPell { re := ↑a, im := 1 }","decl":"theorem isPell_one : IsPell (⟨a, 1⟩ : ℤ√(d a1)) :=\n  show az a * az a - d a1 * 1 * 1 = 1 by simp [dz_val]\n\n"}
{"name":"Pell.isPell_pellZd","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ Pell.IsPell (Pell.pellZd a1 n)","decl":"theorem isPell_pellZd : ∀ n : ℕ, IsPell (pellZd a1 n)\n  | 0 => rfl\n  | n + 1 => by\n    let o := isPell_one a1\n    simpa using Pell.isPell_mul (isPell_pellZd n) o\n\n"}
{"name":"Pell.pell_eqz","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ Eq (HSub.hSub (HMul.hMul (Pell.xz a1 n) (Pell.xz a1 n)) (HMul.hMul (HMul.hMul (↑(Pell.d a1)) (Pell.yz a1 n)) (Pell.yz a1 n))) 1","decl":"@[simp]\ntheorem pell_eqz (n : ℕ) : xz a1 n * xz a1 n - d a1 * yz a1 n * yz a1 n = 1 :=\n  isPell_pellZd a1 n\n\n"}
{"name":"Pell.pell_eq","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ Eq (HSub.hSub (HMul.hMul (Pell.xn a1 n) (Pell.xn a1 n)) (HMul.hMul (HMul.hMul (Pell.d a1) (Pell.yn a1 n)) (Pell.yn a1 n))) 1","decl":"@[simp]\ntheorem pell_eq (n : ℕ) : xn a1 n * xn a1 n - d a1 * yn a1 n * yn a1 n = 1 :=\n  let pn := pell_eqz a1 n\n  have h : (↑(xn a1 n * xn a1 n) : ℤ) - ↑(d a1 * yn a1 n * yn a1 n) = 1 := by\n    repeat' rw [Int.ofNat_mul]; exact pn\n  have hl : d a1 * yn a1 n * yn a1 n ≤ xn a1 n * xn a1 n :=\n    Nat.cast_le.1 <| Int.le.intro _ <| add_eq_of_eq_sub' <| Eq.symm h\n  (Nat.cast_inj (R := ℤ)).1 (by rw [Int.ofNat_sub hl]; exact h)\n\n"}
{"name":"Pell.dnsq","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\n⊢ Zsqrtd.Nonsquare (Pell.d a1)","decl":"instance dnsq : Zsqrtd.Nonsquare (d a1) :=\n  ⟨fun n h =>\n    have : n * n + 1 = a * a := by rw [← h]; exact Nat.succ_pred_eq_of_pos (asq_pos a1)\n    have na : n < a := Nat.mul_self_lt_mul_self_iff.1 (by rw [← this]; exact Nat.lt_succ_self _)\n    have : (n + 1) * (n + 1) ≤ n * n + 1 := by rw [this]; exact Nat.mul_self_le_mul_self na\n    have : n + n ≤ 0 :=\n      @Nat.le_of_add_le_add_right _ (n * n + 1) _ (by ring_nf at this ⊢; assumption)\n    Nat.ne_of_gt (d_pos a1) <| by\n      rwa [Nat.eq_zero_of_le_zero ((Nat.le_add_left _ _).trans this)] at h⟩\n\n"}
{"name":"Pell.xn_ge_a_pow","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ LE.le (HPow.hPow a n) (Pell.xn a1 n)","decl":"theorem xn_ge_a_pow : ∀ n : ℕ, a ^ n ≤ xn a1 n\n  | 0 => le_refl 1\n  | n + 1 => by\n    simp only [_root_.pow_succ, xn_succ]\n    exact le_trans (Nat.mul_le_mul_right _ (xn_ge_a_pow n)) (Nat.le_add_right _ _)\n\n"}
{"name":"Pell.n_lt_a_pow","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ LT.lt n (HPow.hPow a n)","decl":"include a1 in\ntheorem n_lt_a_pow : ∀ n : ℕ, n < a ^ n\n  | 0 => Nat.le_refl 1\n  | n + 1 => by\n    have IH := n_lt_a_pow n\n    have : a ^ n + a ^ n ≤ a ^ n * a := by\n      rw [← mul_two]\n      exact Nat.mul_le_mul_left _ a1\n    simp only [_root_.pow_succ, gt_iff_lt]\n    refine lt_of_lt_of_le ?_ this\n    exact add_lt_add_of_lt_of_le IH (lt_of_le_of_lt (Nat.zero_le _) IH)\n\n"}
{"name":"Pell.n_lt_xn","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ LT.lt n (Pell.xn a1 n)","decl":"theorem n_lt_xn (n) : n < xn a1 n :=\n  lt_of_lt_of_le (n_lt_a_pow a1 n) (xn_ge_a_pow a1 n)\n\n"}
{"name":"Pell.x_pos","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ LT.lt 0 (Pell.xn a1 n)","decl":"theorem x_pos (n) : 0 < xn a1 n :=\n  lt_of_le_of_lt (Nat.zero_le n) (n_lt_xn a1 n)\n\n"}
{"name":"Pell.eq_pell_lem","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\nb : Zsqrtd ↑(Pell.d a1)\na✝² : LE.le 1 b\na✝¹ : Pell.IsPell b\na✝ : LE.le b (Pell.pellZd a1 n)\n⊢ Exists fun n => Eq b (Pell.pellZd a1 n)","decl":"theorem eq_pell_lem : ∀ (n) (b : ℤ√(d a1)), 1 ≤ b → IsPell b →\n    b ≤ pellZd a1 n → ∃ n, b = pellZd a1 n\n  | 0, _ => fun h1 _ hl => ⟨0, @Zsqrtd.le_antisymm _ (dnsq a1) _ _ hl h1⟩\n  | n + 1, b => fun h1 hp h =>\n    have a1p : (0 : ℤ√(d a1)) ≤ ⟨a, 1⟩ := trivial\n    have am1p : (0 : ℤ√(d a1)) ≤ ⟨a, -1⟩ := show (_ : Nat) ≤ _ by simp; exact Nat.pred_le _\n    have a1m : (⟨a, 1⟩ * ⟨a, -1⟩ : ℤ√(d a1)) = 1 := isPell_norm.1 (isPell_one a1)\n    if ha : (⟨↑a, 1⟩ : ℤ√(d a1)) ≤ b then\n      let ⟨m, e⟩ :=\n        eq_pell_lem n (b * ⟨a, -1⟩) (by rw [← a1m]; exact mul_le_mul_of_nonneg_right ha am1p)\n          (isPell_mul hp (isPell_star.1 (isPell_one a1)))\n          (by\n            have t := mul_le_mul_of_nonneg_right h am1p\n            rwa [pellZd_succ, mul_assoc, a1m, mul_one] at t)\n      ⟨m + 1, by\n        rw [show b = b * ⟨a, -1⟩ * ⟨a, 1⟩ by rw [mul_assoc, Eq.trans (mul_comm _ _) a1m]; simp,\n          pellZd_succ, e]⟩\n    else\n      suffices ¬1 < b from ⟨0, show b = 1 from (Or.resolve_left (lt_or_eq_of_le h1) this).symm⟩\n      fun h1l => by\n      cases' b with x y\n      exact by\n        have bm : (_ * ⟨_, _⟩ : ℤ√d a1) = 1 := Pell.isPell_norm.1 hp\n        have y0l : (0 : ℤ√d a1) < ⟨x - x, y - -y⟩ :=\n          sub_lt_sub h1l fun hn : (1 : ℤ√d a1) ≤ ⟨x, -y⟩ => by\n            have t := mul_le_mul_of_nonneg_left hn (le_trans zero_le_one h1)\n            rw [bm, mul_one] at t\n            exact h1l t\n        have yl2 : (⟨_, _⟩ : ℤ√_) < ⟨_, _⟩ :=\n          show (⟨x, y⟩ - ⟨x, -y⟩ : ℤ√d a1) < ⟨a, 1⟩ - ⟨a, -1⟩ from\n            sub_lt_sub ha fun hn : (⟨x, -y⟩ : ℤ√d a1) ≤ ⟨a, -1⟩ => by\n              have t := mul_le_mul_of_nonneg_right\n                      (mul_le_mul_of_nonneg_left hn (le_trans zero_le_one h1)) a1p\n              rw [bm, one_mul, mul_assoc, Eq.trans (mul_comm _ _) a1m, mul_one] at t\n              exact ha t\n        simp only [sub_self, sub_neg_eq_add] at y0l; simp only [Zsqrtd.neg_re, add_neg_cancel,\n          Zsqrtd.neg_im, neg_neg] at yl2\n        exact\n          match y, y0l, (yl2 : (⟨_, _⟩ : ℤ√_) < ⟨_, _⟩) with\n          | 0, y0l, _ => y0l (le_refl 0)\n          | (y + 1 : ℕ), _, yl2 =>\n            yl2\n              (Zsqrtd.le_of_le_le (by simp [sub_eq_add_neg])\n                (let t := Int.ofNat_le_ofNat_of_le (Nat.succ_pos y)\n                add_le_add t t))\n          | Int.negSucc _, y0l, _ => y0l trivial\n\n"}
{"name":"Pell.eq_pellZd","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nb : Zsqrtd ↑(Pell.d a1)\nb1 : LE.le 1 b\nhp : Pell.IsPell b\n⊢ Exists fun n => Eq b (Pell.pellZd a1 n)","decl":"theorem eq_pellZd (b : ℤ√(d a1)) (b1 : 1 ≤ b) (hp : IsPell b) : ∃ n, b = pellZd a1 n :=\n  let ⟨n, h⟩ := @Zsqrtd.le_arch (d a1) b\n  eq_pell_lem a1 n b b1 hp <|\n    h.trans <| by\n      rw [Zsqrtd.natCast_val]\n      exact\n        Zsqrtd.le_of_le_le (Int.ofNat_le_ofNat_of_le <| le_of_lt <| n_lt_xn _ _)\n          (Int.ofNat_zero_le _)\n\n"}
{"name":"Pell.eq_pell","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nx y : Nat\nhp : Eq (HSub.hSub (HMul.hMul x x) (HMul.hMul (HMul.hMul (Pell.d a1) y) y)) 1\n⊢ Exists fun n => And (Eq x (Pell.xn a1 n)) (Eq y (Pell.yn a1 n))","decl":"/-- Every solution to **Pell's equation** is recursively obtained from the initial solution\n`(1,0)` using the recursion `pell`. -/\ntheorem eq_pell {x y : ℕ} (hp : x * x - d a1 * y * y = 1) : ∃ n, x = xn a1 n ∧ y = yn a1 n :=\n  have : (1 : ℤ√(d a1)) ≤ ⟨x, y⟩ :=\n    match x, hp with\n    | 0, (hp : 0 - _ = 1) => by rw [zero_tsub] at hp; contradiction\n    | x + 1, _hp =>\n      Zsqrtd.le_of_le_le (Int.ofNat_le_ofNat_of_le <| Nat.succ_pos x) (Int.ofNat_zero_le _)\n  let ⟨m, e⟩ := eq_pellZd a1 ⟨x, y⟩ this ((isPell_nat a1).2 hp)\n  ⟨m,\n    match x, y, e with\n    | _, _, rfl => ⟨rfl, rfl⟩⟩\n\n"}
{"name":"Pell.pellZd_add","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nm n : Nat\n⊢ Eq (Pell.pellZd a1 (HAdd.hAdd m n)) (HMul.hMul (Pell.pellZd a1 m) (Pell.pellZd a1 n))","decl":"theorem pellZd_add (m) : ∀ n, pellZd a1 (m + n) = pellZd a1 m * pellZd a1 n\n  | 0 => (mul_one _).symm\n  | n + 1 => by rw [← add_assoc, pellZd_succ, pellZd_succ, pellZd_add _ n, ← mul_assoc]\n\n"}
{"name":"Pell.xn_add","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nm n : Nat\n⊢ Eq (Pell.xn a1 (HAdd.hAdd m n)) (HAdd.hAdd (HMul.hMul (Pell.xn a1 m) (Pell.xn a1 n)) (HMul.hMul (HMul.hMul (Pell.d a1) (Pell.yn a1 m)) (Pell.yn a1 n)))","decl":"theorem xn_add (m n) : xn a1 (m + n) = xn a1 m * xn a1 n + d a1 * yn a1 m * yn a1 n := by\n  injection pellZd_add a1 m n with h _\n  zify\n  rw [h]\n  simp [pellZd]\n\n"}
{"name":"Pell.yn_add","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nm n : Nat\n⊢ Eq (Pell.yn a1 (HAdd.hAdd m n)) (HAdd.hAdd (HMul.hMul (Pell.xn a1 m) (Pell.yn a1 n)) (HMul.hMul (Pell.yn a1 m) (Pell.xn a1 n)))","decl":"theorem yn_add (m n) : yn a1 (m + n) = xn a1 m * yn a1 n + yn a1 m * xn a1 n := by\n  injection pellZd_add a1 m n with _ h\n  zify\n  rw [h]\n  simp [pellZd]\n\n"}
{"name":"Pell.pellZd_sub","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nm n : Nat\nh : LE.le n m\n⊢ Eq (Pell.pellZd a1 (HSub.hSub m n)) (HMul.hMul (Pell.pellZd a1 m) (Star.star (Pell.pellZd a1 n)))","decl":"theorem pellZd_sub {m n} (h : n ≤ m) : pellZd a1 (m - n) = pellZd a1 m * star (pellZd a1 n) := by\n  let t := pellZd_add a1 n (m - n)\n  rw [add_tsub_cancel_of_le h] at t\n  rw [t, mul_comm (pellZd _ n) _, mul_assoc, isPell_norm.1 (isPell_pellZd _ _), mul_one]\n\n"}
{"name":"Pell.xz_sub","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nm n : Nat\nh : LE.le n m\n⊢ Eq (Pell.xz a1 (HSub.hSub m n)) (HSub.hSub (HMul.hMul (Pell.xz a1 m) (Pell.xz a1 n)) (HMul.hMul (HMul.hMul (↑(Pell.d a1)) (Pell.yz a1 m)) (Pell.yz a1 n)))","decl":"theorem xz_sub {m n} (h : n ≤ m) :\n    xz a1 (m - n) = xz a1 m * xz a1 n - d a1 * yz a1 m * yz a1 n := by\n  rw [sub_eq_add_neg, ← mul_neg]\n  exact congr_arg Zsqrtd.re (pellZd_sub a1 h)\n\n"}
{"name":"Pell.yz_sub","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nm n : Nat\nh : LE.le n m\n⊢ Eq (Pell.yz a1 (HSub.hSub m n)) (HSub.hSub (HMul.hMul (Pell.xz a1 n) (Pell.yz a1 m)) (HMul.hMul (Pell.xz a1 m) (Pell.yz a1 n)))","decl":"theorem yz_sub {m n} (h : n ≤ m) : yz a1 (m - n) = xz a1 n * yz a1 m - xz a1 m * yz a1 n := by\n  rw [sub_eq_add_neg, ← mul_neg, mul_comm, add_comm]\n  exact congr_arg Zsqrtd.im (pellZd_sub a1 h)\n\n"}
{"name":"Pell.xy_coprime","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ (Pell.xn a1 n).Coprime (Pell.yn a1 n)","decl":"theorem xy_coprime (n) : (xn a1 n).Coprime (yn a1 n) :=\n  Nat.coprime_of_dvd' fun k _ kx ky => by\n    let p := pell_eq a1 n\n    rw [← p]\n    exact Nat.dvd_sub (le_of_lt <| Nat.lt_of_sub_eq_succ p) (kx.mul_left _) (ky.mul_left _)\n\n"}
{"name":"Pell.strictMono_y","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\n⊢ StrictMono (Pell.yn a1)","decl":"theorem strictMono_y : StrictMono (yn a1)\n  | _, 0, h => absurd h <| Nat.not_lt_zero _\n  | m, n + 1, h => by\n    have : yn a1 m ≤ yn a1 n :=\n      Or.elim (lt_or_eq_of_le <| Nat.le_of_succ_le_succ h) (fun hl => le_of_lt <| strictMono_y hl)\n        fun e => by rw [e]\n    simp only [yn_succ, gt_iff_lt]; refine lt_of_le_of_lt ?_ (Nat.lt_add_of_pos_left <| x_pos a1 n)\n    rw [← mul_one (yn a1 m)]\n    exact mul_le_mul this (le_of_lt a1) (Nat.zero_le _) (Nat.zero_le _)\n\n"}
{"name":"Pell.strictMono_x","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\n⊢ StrictMono (Pell.xn a1)","decl":"theorem strictMono_x : StrictMono (xn a1)\n  | _, 0, h => absurd h <| Nat.not_lt_zero _\n  | m, n + 1, h => by\n    have : xn a1 m ≤ xn a1 n :=\n      Or.elim (lt_or_eq_of_le <| Nat.le_of_succ_le_succ h) (fun hl => le_of_lt <| strictMono_x hl)\n        fun e => by rw [e]\n    simp only [xn_succ, gt_iff_lt]\n    refine lt_of_lt_of_le (lt_of_le_of_lt this ?_) (Nat.le_add_right _ _)\n    have t := Nat.mul_lt_mul_of_pos_left a1 (x_pos a1 n)\n    rwa [mul_one] at t\n\n"}
{"name":"Pell.yn_ge_n","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ LE.le n (Pell.yn a1 n)","decl":"theorem yn_ge_n : ∀ n, n ≤ yn a1 n\n  | 0 => Nat.zero_le _\n  | n + 1 =>\n    show n < yn a1 (n + 1) from lt_of_le_of_lt (yn_ge_n n) (strictMono_y a1 <| Nat.lt_succ_self n)\n\n"}
{"name":"Pell.y_mul_dvd","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn k : Nat\n⊢ Dvd.dvd (Pell.yn a1 n) (Pell.yn a1 (HMul.hMul n k))","decl":"theorem y_mul_dvd (n) : ∀ k, yn a1 n ∣ yn a1 (n * k)\n  | 0 => dvd_zero _\n  | k + 1 => by\n    rw [Nat.mul_succ, yn_add]; exact dvd_add (dvd_mul_left _ _) ((y_mul_dvd _ k).mul_right _)\n\n"}
{"name":"Pell.y_dvd_iff","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nm n : Nat\n⊢ Iff (Dvd.dvd (Pell.yn a1 m) (Pell.yn a1 n)) (Dvd.dvd m n)","decl":"theorem y_dvd_iff (m n) : yn a1 m ∣ yn a1 n ↔ m ∣ n :=\n  ⟨fun h =>\n    Nat.dvd_of_mod_eq_zero <|\n      (Nat.eq_zero_or_pos _).resolve_right fun hp => by\n        have co : Nat.Coprime (yn a1 m) (xn a1 (m * (n / m))) :=\n          Nat.Coprime.symm <| (xy_coprime a1 _).coprime_dvd_right (y_mul_dvd a1 m (n / m))\n        have m0 : 0 < m :=\n          m.eq_zero_or_pos.resolve_left fun e => by\n            rw [e, Nat.mod_zero] at hp;rw [e] at h\n            exact _root_.ne_of_lt (strictMono_y a1 hp) (eq_zero_of_zero_dvd h).symm\n        rw [← Nat.mod_add_div n m, yn_add] at h\n        exact\n          not_le_of_gt (strictMono_y _ <| Nat.mod_lt n m0)\n            (Nat.le_of_dvd (strictMono_y _ hp) <|\n              co.dvd_of_dvd_mul_right <|\n                (Nat.dvd_add_iff_right <| (y_mul_dvd _ _ _).mul_left _).2 h),\n    fun ⟨k, e⟩ => by rw [e]; apply y_mul_dvd⟩\n\n"}
{"name":"Pell.xy_modEq_yn","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn k : Nat\n⊢ And ((HPow.hPow (Pell.yn a1 n) 2).ModEq (Pell.xn a1 (HMul.hMul n k)) (HPow.hPow (Pell.xn a1 n) k)) ((HPow.hPow (Pell.yn a1 n) 3).ModEq (Pell.yn a1 (HMul.hMul n k)) (HMul.hMul (HMul.hMul k (HPow.hPow (Pell.xn a1 n) (HSub.hSub k 1))) (Pell.yn a1 n)))","decl":"theorem xy_modEq_yn (n) :\n    ∀ k, xn a1 (n * k) ≡ xn a1 n ^ k [MOD yn a1 n ^ 2] ∧ yn a1 (n * k) ≡\n        k * xn a1 n ^ (k - 1) * yn a1 n [MOD yn a1 n ^ 3]\n  | 0 => by constructor <;> simpa using Nat.ModEq.refl _\n  | k + 1 => by\n    let ⟨hx, hy⟩ := xy_modEq_yn n k\n    have L : xn a1 (n * k) * xn a1 n + d a1 * yn a1 (n * k) * yn a1 n ≡\n        xn a1 n ^ k * xn a1 n + 0 [MOD yn a1 n ^ 2] :=\n      (hx.mul_right _).add <|\n        modEq_zero_iff_dvd.2 <| by\n          rw [_root_.pow_succ]\n          exact\n            mul_dvd_mul_right\n              (dvd_mul_of_dvd_right\n                (modEq_zero_iff_dvd.1 <|\n                  (hy.of_dvd <| by simp [_root_.pow_succ]).trans <|\n                    modEq_zero_iff_dvd.2 <| by simp)\n                _) _\n    have R : xn a1 (n * k) * yn a1 n + yn a1 (n * k) * xn a1 n ≡\n        xn a1 n ^ k * yn a1 n + k * xn a1 n ^ k * yn a1 n [MOD yn a1 n ^ 3] :=\n      ModEq.add\n          (by\n            rw [_root_.pow_succ]\n            exact hx.mul_right' _) <| by\n        have : k * xn a1 n ^ (k - 1) * yn a1 n * xn a1 n = k * xn a1 n ^ k * yn a1 n := by\n          cases' k with k <;> simp [_root_.pow_succ]; ring_nf\n        rw [← this]\n        exact hy.mul_right _\n    rw [add_tsub_cancel_right, Nat.mul_succ, xn_add, yn_add, pow_succ (xn _ n), Nat.succ_mul,\n      add_comm (k * xn _ n ^ k) (xn _ n ^ k), right_distrib]\n    exact ⟨L, R⟩\n\n"}
{"name":"Pell.ysq_dvd_yy","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ Dvd.dvd (HMul.hMul (Pell.yn a1 n) (Pell.yn a1 n)) (Pell.yn a1 (HMul.hMul n (Pell.yn a1 n)))","decl":"theorem ysq_dvd_yy (n) : yn a1 n * yn a1 n ∣ yn a1 (n * yn a1 n) :=\n  modEq_zero_iff_dvd.1 <|\n    ((xy_modEq_yn a1 n (yn a1 n)).right.of_dvd <| by simp [_root_.pow_succ]).trans\n      (modEq_zero_iff_dvd.2 <| by simp [mul_dvd_mul_left, mul_assoc])\n\n"}
{"name":"Pell.dvd_of_ysq_dvd","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn t : Nat\nh : Dvd.dvd (HMul.hMul (Pell.yn a1 n) (Pell.yn a1 n)) (Pell.yn a1 t)\n⊢ Dvd.dvd (Pell.yn a1 n) t","decl":"theorem dvd_of_ysq_dvd {n t} (h : yn a1 n * yn a1 n ∣ yn a1 t) : yn a1 n ∣ t :=\n  have nt : n ∣ t := (y_dvd_iff a1 n t).1 <| dvd_of_mul_left_dvd h\n  n.eq_zero_or_pos.elim (fun n0 => by rwa [n0] at nt ⊢) fun n0l : 0 < n => by\n    let ⟨k, ke⟩ := nt\n    have : yn a1 n ∣ k * xn a1 n ^ (k - 1) :=\n      Nat.dvd_of_mul_dvd_mul_right (strictMono_y a1 n0l) <|\n        modEq_zero_iff_dvd.1 <| by\n          have xm := (xy_modEq_yn a1 n k).right; rw [← ke] at xm\n          exact (xm.of_dvd <| by simp [_root_.pow_succ]).symm.trans h.modEq_zero_nat\n    rw [ke]\n    exact dvd_mul_of_dvd_right (((xy_coprime _ _).pow_left _).symm.dvd_of_dvd_mul_right this) _\n\n"}
{"name":"Pell.pellZd_succ_succ","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ Eq (HAdd.hAdd (Pell.pellZd a1 (HAdd.hAdd n 2)) (Pell.pellZd a1 n)) (HMul.hMul (↑(HMul.hMul 2 a)) (Pell.pellZd a1 (HAdd.hAdd n 1)))","decl":"theorem pellZd_succ_succ (n) :\n    pellZd a1 (n + 2) + pellZd a1 n = (2 * a : ℕ) * pellZd a1 (n + 1) := by\n  have : (1 : ℤ√(d a1)) + ⟨a, 1⟩ * ⟨a, 1⟩ = ⟨a, 1⟩ * (2 * a) := by\n    rw [Zsqrtd.natCast_val]\n    change (⟨_, _⟩ : ℤ√(d a1)) = ⟨_, _⟩\n    rw [dz_val]\n    dsimp [az]\n    ext <;> dsimp <;> ring_nf\n  simpa [mul_add, mul_comm, mul_left_comm, add_comm] using congr_arg (· * pellZd a1 n) this\n\n"}
{"name":"Pell.xy_succ_succ","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ And (Eq (HAdd.hAdd (Pell.xn a1 (HAdd.hAdd n 2)) (Pell.xn a1 n)) (HMul.hMul (HMul.hMul 2 a) (Pell.xn a1 (HAdd.hAdd n 1)))) (Eq (HAdd.hAdd (Pell.yn a1 (HAdd.hAdd n 2)) (Pell.yn a1 n)) (HMul.hMul (HMul.hMul 2 a) (Pell.yn a1 (HAdd.hAdd n 1))))","decl":"theorem xy_succ_succ (n) :\n    xn a1 (n + 2) + xn a1 n =\n      2 * a * xn a1 (n + 1) ∧ yn a1 (n + 2) + yn a1 n = 2 * a * yn a1 (n + 1) := by\n  have := pellZd_succ_succ a1 n; unfold pellZd at this\n  erw [Zsqrtd.smul_val (2 * a : ℕ)] at this\n  injection this with h₁ h₂\n  constructor <;> apply Int.ofNat.inj <;> [simpa using h₁; simpa using h₂]\n\n"}
{"name":"Pell.xn_succ_succ","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ Eq (HAdd.hAdd (Pell.xn a1 (HAdd.hAdd n 2)) (Pell.xn a1 n)) (HMul.hMul (HMul.hMul 2 a) (Pell.xn a1 (HAdd.hAdd n 1)))","decl":"theorem xn_succ_succ (n) : xn a1 (n + 2) + xn a1 n = 2 * a * xn a1 (n + 1) :=\n  (xy_succ_succ a1 n).1\n\n"}
{"name":"Pell.yn_succ_succ","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ Eq (HAdd.hAdd (Pell.yn a1 (HAdd.hAdd n 2)) (Pell.yn a1 n)) (HMul.hMul (HMul.hMul 2 a) (Pell.yn a1 (HAdd.hAdd n 1)))","decl":"theorem yn_succ_succ (n) : yn a1 (n + 2) + yn a1 n = 2 * a * yn a1 (n + 1) :=\n  (xy_succ_succ a1 n).2\n\n"}
{"name":"Pell.xz_succ_succ","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ Eq (Pell.xz a1 (HAdd.hAdd n 2)) (HSub.hSub (HMul.hMul (↑(HMul.hMul 2 a)) (Pell.xz a1 (HAdd.hAdd n 1))) (Pell.xz a1 n))","decl":"theorem xz_succ_succ (n) : xz a1 (n + 2) = (2 * a : ℕ) * xz a1 (n + 1) - xz a1 n :=\n  eq_sub_of_add_eq <| by delta xz; rw [← Int.ofNat_add, ← Int.ofNat_mul, xn_succ_succ]\n\n"}
{"name":"Pell.yz_succ_succ","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ Eq (Pell.yz a1 (HAdd.hAdd n 2)) (HSub.hSub (HMul.hMul (↑(HMul.hMul 2 a)) (Pell.yz a1 (HAdd.hAdd n 1))) (Pell.yz a1 n))","decl":"theorem yz_succ_succ (n) : yz a1 (n + 2) = (2 * a : ℕ) * yz a1 (n + 1) - yz a1 n :=\n  eq_sub_of_add_eq <| by delta yz; rw [← Int.ofNat_add, ← Int.ofNat_mul, yn_succ_succ]\n\n"}
{"name":"Pell.yn_modEq_a_sub_one","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ (HSub.hSub a 1).ModEq (Pell.yn a1 n) n","decl":"theorem yn_modEq_a_sub_one : ∀ n, yn a1 n ≡ n [MOD a - 1]\n  | 0 => by simp [Nat.ModEq.refl]\n  | 1 => by simp [Nat.ModEq.refl]\n  | n + 2 =>\n    (yn_modEq_a_sub_one n).add_right_cancel <| by\n      rw [yn_succ_succ, (by ring : n + 2 + n = 2 * (n + 1))]\n      exact ((modEq_sub a1.le).mul_left 2).mul (yn_modEq_a_sub_one (n + 1))\n\n"}
{"name":"Pell.yn_modEq_two","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\n⊢ Nat.ModEq 2 (Pell.yn a1 n) n","decl":"theorem yn_modEq_two : ∀ n, yn a1 n ≡ n [MOD 2]\n  | 0 => by rfl\n  | 1 => by simp; rfl\n  | n + 2 =>\n    (yn_modEq_two n).add_right_cancel <| by\n      rw [yn_succ_succ, mul_assoc, (by ring : n + 2 + n = 2 * (n + 1))]\n      exact (dvd_mul_right 2 _).modEq_zero_nat.trans (dvd_mul_right 2 _).zero_modEq_nat\n\n"}
{"name":"Pell.x_sub_y_dvd_pow_lem","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"y2 y1 y0 yn1 yn0 xn1 xn0 ay a2 : Int\n⊢ Eq (HSub.hSub (HAdd.hAdd (HMul.hMul (HSub.hSub (HMul.hMul a2 yn1) yn0) ay) y2) (HSub.hSub (HMul.hMul a2 xn1) xn0)) (HSub.hSub (HAdd.hAdd (HAdd.hAdd (HSub.hSub y2 (HMul.hMul a2 y1)) y0) (HMul.hMul a2 (HSub.hSub (HAdd.hAdd (HMul.hMul yn1 ay) y1) xn1))) (HSub.hSub (HAdd.hAdd (HMul.hMul yn0 ay) y0) xn0))","decl":"theorem x_sub_y_dvd_pow_lem (y2 y1 y0 yn1 yn0 xn1 xn0 ay a2 : ℤ) :\n    (a2 * yn1 - yn0) * ay + y2 - (a2 * xn1 - xn0) =\n      y2 - a2 * y1 + y0 + a2 * (yn1 * ay + y1 - xn1) - (yn0 * ay + y0 - xn0) := by\n  ring\n\n"}
{"name":"Pell.x_sub_y_dvd_pow","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\ny n : Nat\n⊢ Dvd.dvd (HSub.hSub (HSub.hSub (HMul.hMul (HMul.hMul 2 ↑a) ↑y) (HMul.hMul ↑y ↑y)) 1) (HSub.hSub (HAdd.hAdd (HMul.hMul (Pell.yz a1 n) (HSub.hSub ↑a ↑y)) ↑(HPow.hPow y n)) (Pell.xz a1 n))","decl":"theorem x_sub_y_dvd_pow (y : ℕ) :\n    ∀ n, (2 * a * y - y * y - 1 : ℤ) ∣ yz a1 n * (a - y) + ↑(y ^ n) - xz a1 n\n  | 0 => by simp [xz, yz, Int.ofNat_zero, Int.ofNat_one]\n  | 1 => by simp [xz, yz, Int.ofNat_zero, Int.ofNat_one]\n  | n + 2 => by\n    have : (2 * a * y - y * y - 1 : ℤ) ∣ ↑(y ^ (n + 2)) - ↑(2 * a) * ↑(y ^ (n + 1)) + ↑(y ^ n) :=\n      ⟨-↑(y ^ n), by\n        simp [_root_.pow_succ, mul_add, Int.ofNat_mul, show ((2 : ℕ) : ℤ) = 2 from rfl, mul_comm,\n          mul_left_comm]\n        ring⟩\n    rw [xz_succ_succ, yz_succ_succ, x_sub_y_dvd_pow_lem ↑(y ^ (n + 2)) ↑(y ^ (n + 1)) ↑(y ^ n)]\n    exact _root_.dvd_sub (dvd_add this <| (x_sub_y_dvd_pow _ (n + 1)).mul_left _)\n      (x_sub_y_dvd_pow _ n)\n\n"}
{"name":"Pell.xn_modEq_x2n_add_lem","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn j : Nat\n⊢ Dvd.dvd (Pell.xn a1 n) (HAdd.hAdd (HMul.hMul (HMul.hMul (Pell.d a1) (Pell.yn a1 n)) (HMul.hMul (Pell.yn a1 n) (Pell.xn a1 j))) (Pell.xn a1 j))","decl":"theorem xn_modEq_x2n_add_lem (n j) : xn a1 n ∣ d a1 * yn a1 n * (yn a1 n * xn a1 j) + xn a1 j := by\n  have h1 : d a1 * yn a1 n * (yn a1 n * xn a1 j) + xn a1 j =\n      (d a1 * yn a1 n * yn a1 n + 1) * xn a1 j := by\n    simp [add_mul, mul_assoc]\n  have h2 : d a1 * yn a1 n * yn a1 n + 1 = xn a1 n * xn a1 n := by\n    zify at *\n    apply add_eq_of_eq_sub' (Eq.symm (pell_eqz a1 n))\n  rw [h2] at h1; rw [h1, mul_assoc]; exact dvd_mul_right _ _\n\n"}
{"name":"Pell.xn_modEq_x2n_add","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn j : Nat\n⊢ (Pell.xn a1 n).ModEq (HAdd.hAdd (Pell.xn a1 (HAdd.hAdd (HMul.hMul 2 n) j)) (Pell.xn a1 j)) 0","decl":"theorem xn_modEq_x2n_add (n j) : xn a1 (2 * n + j) + xn a1 j ≡ 0 [MOD xn a1 n] := by\n  rw [two_mul, add_assoc, xn_add, add_assoc, ← zero_add 0]\n  refine (dvd_mul_right (xn a1 n) (xn a1 (n + j))).modEq_zero_nat.add ?_\n  rw [yn_add, left_distrib, add_assoc, ← zero_add 0]\n  exact\n    ((dvd_mul_right _ _).mul_left _).modEq_zero_nat.add (xn_modEq_x2n_add_lem _ _ _).modEq_zero_nat\n\n"}
{"name":"Pell.xn_modEq_x2n_sub_lem","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn j : Nat\nh : LE.le j n\n⊢ (Pell.xn a1 n).ModEq (HAdd.hAdd (Pell.xn a1 (HSub.hSub (HMul.hMul 2 n) j)) (Pell.xn a1 j)) 0","decl":"theorem xn_modEq_x2n_sub_lem {n j} (h : j ≤ n) : xn a1 (2 * n - j) + xn a1 j ≡ 0 [MOD xn a1 n] := by\n  have h1 : xz a1 n ∣ d a1 * yz a1 n * yz a1 (n - j) + xz a1 j := by\n    rw [yz_sub _ h, mul_sub_left_distrib, sub_add_eq_add_sub]\n    exact\n      dvd_sub\n        (by\n          delta xz; delta yz\n          rw [mul_comm (xn _ _ : ℤ)]\n          exact mod_cast (xn_modEq_x2n_add_lem _ n j))\n        ((dvd_mul_right _ _).mul_left _)\n  rw [two_mul, add_tsub_assoc_of_le h, xn_add, add_assoc, ← zero_add 0]\n  exact\n    (dvd_mul_right _ _).modEq_zero_nat.add\n      (Int.natCast_dvd_natCast.1 <| by simpa [xz, yz] using h1).modEq_zero_nat\n\n"}
{"name":"Pell.xn_modEq_x2n_sub","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn j : Nat\nh : LE.le j (HMul.hMul 2 n)\n⊢ (Pell.xn a1 n).ModEq (HAdd.hAdd (Pell.xn a1 (HSub.hSub (HMul.hMul 2 n) j)) (Pell.xn a1 j)) 0","decl":"theorem xn_modEq_x2n_sub {n j} (h : j ≤ 2 * n) : xn a1 (2 * n - j) + xn a1 j ≡ 0 [MOD xn a1 n] :=\n  (le_total j n).elim (xn_modEq_x2n_sub_lem a1) fun jn => by\n    have : 2 * n - j + j ≤ n + j := by\n      rw [tsub_add_cancel_of_le h, two_mul]; exact Nat.add_le_add_left jn _\n    let t := xn_modEq_x2n_sub_lem a1 (Nat.le_of_add_le_add_right this)\n    rwa [tsub_tsub_cancel_of_le h, add_comm] at t\n\n"}
{"name":"Pell.xn_modEq_x4n_add","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn j : Nat\n⊢ (Pell.xn a1 n).ModEq (Pell.xn a1 (HAdd.hAdd (HMul.hMul 4 n) j)) (Pell.xn a1 j)","decl":"theorem xn_modEq_x4n_add (n j) : xn a1 (4 * n + j) ≡ xn a1 j [MOD xn a1 n] :=\n  ModEq.add_right_cancel' (xn a1 (2 * n + j)) <| by\n    refine @ModEq.trans _ _ 0 _ ?_ (by rw [add_comm]; exact (xn_modEq_x2n_add _ _ _).symm)\n    rw [show 4 * n = 2 * n + 2 * n from right_distrib 2 2 n, add_assoc]\n    apply xn_modEq_x2n_add\n\n"}
{"name":"Pell.xn_modEq_x4n_sub","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn j : Nat\nh : LE.le j (HMul.hMul 2 n)\n⊢ (Pell.xn a1 n).ModEq (Pell.xn a1 (HSub.hSub (HMul.hMul 4 n) j)) (Pell.xn a1 j)","decl":"theorem xn_modEq_x4n_sub {n j} (h : j ≤ 2 * n) : xn a1 (4 * n - j) ≡ xn a1 j [MOD xn a1 n] :=\n  have h' : j ≤ 2 * n := le_trans h (by rw [Nat.succ_mul])\n  ModEq.add_right_cancel' (xn a1 (2 * n - j)) <| by\n    refine @ModEq.trans _ _ 0 _ ?_ (by rw [add_comm]; exact (xn_modEq_x2n_sub _ h).symm)\n    rw [show 4 * n = 2 * n + 2 * n from right_distrib 2 2 n, add_tsub_assoc_of_le h']\n    apply xn_modEq_x2n_add\n\n"}
{"name":"Pell.eq_of_xn_modEq_lem1","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\ni n j : Nat\na✝¹ : LT.lt i j\na✝ : LT.lt j n\n⊢ LT.lt (HMod.hMod (Pell.xn a1 i) (Pell.xn a1 n)) (HMod.hMod (Pell.xn a1 j) (Pell.xn a1 n))","decl":"theorem eq_of_xn_modEq_lem1 {i n} : ∀ {j}, i < j → j < n → xn a1 i % xn a1 n < xn a1 j % xn a1 n\n  | 0, ij, _ => absurd ij (Nat.not_lt_zero _)\n  | j + 1, ij, jn => by\n    suffices xn a1 j % xn a1 n < xn a1 (j + 1) % xn a1 n from\n      (lt_or_eq_of_le (Nat.le_of_succ_le_succ ij)).elim\n        (fun h => lt_trans (eq_of_xn_modEq_lem1 h (le_of_lt jn)) this) fun h => by\n        rw [h]; exact this\n    rw [Nat.mod_eq_of_lt (strictMono_x _ (Nat.lt_of_succ_lt jn)),\n        Nat.mod_eq_of_lt (strictMono_x _ jn)]\n    exact strictMono_x _ (Nat.lt_succ_self _)\n\n"}
{"name":"Pell.eq_of_xn_modEq_lem2","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\nn : Nat\nh : Eq (HMul.hMul 2 (Pell.xn a1 n)) (Pell.xn a1 (HAdd.hAdd n 1))\n⊢ And (Eq a 2) (Eq n 0)","decl":"theorem eq_of_xn_modEq_lem2 {n} (h : 2 * xn a1 n = xn a1 (n + 1)) : a = 2 ∧ n = 0 := by\n  rw [xn_succ, mul_comm] at h\n  have : n = 0 :=\n    n.eq_zero_or_pos.resolve_right fun np =>\n      _root_.ne_of_lt\n        (lt_of_le_of_lt (Nat.mul_le_mul_left _ a1)\n          (Nat.lt_add_of_pos_right <| mul_pos (d_pos a1) (strictMono_y a1 np)))\n        h\n  cases this; simp at h; exact ⟨h.symm, rfl⟩\n\n"}
{"name":"Pell.eq_of_xn_modEq_lem3","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\ni n : Nat\nnpos : LT.lt 0 n\nj : Nat\na✝³ : LT.lt i j\na✝² : LE.le j (HMul.hMul 2 n)\na✝¹ : Ne j n\na✝ : Not (And (Eq a 2) (And (Eq n 1) (And (Eq i 0) (Eq j 2))))\n⊢ LT.lt (HMod.hMod (Pell.xn a1 i) (Pell.xn a1 n)) (HMod.hMod (Pell.xn a1 j) (Pell.xn a1 n))","decl":"theorem eq_of_xn_modEq_lem3 {i n} (npos : 0 < n) :\n    ∀ {j}, i < j → j ≤ 2 * n → j ≠ n → ¬(a = 2 ∧ n = 1 ∧ i = 0 ∧ j = 2) →\n        xn a1 i % xn a1 n < xn a1 j % xn a1 n\n  | 0, ij, _, _, _ => absurd ij (Nat.not_lt_zero _)\n  | j + 1, ij, j2n, jnn, ntriv =>\n    have lem2 : ∀ k > n, k ≤ 2 * n → (↑(xn a1 k % xn a1 n) : ℤ) =\n        xn a1 n - xn a1 (2 * n - k) := fun k kn k2n => by\n      let k2nl :=\n        lt_of_add_lt_add_right <|\n          show 2 * n - k + k < n + k by\n            rw [tsub_add_cancel_of_le]\n            · rw [two_mul]\n              exact add_lt_add_left kn n\n            exact k2n\n      have xle : xn a1 (2 * n - k) ≤ xn a1 n := le_of_lt <| strictMono_x a1 k2nl\n      suffices xn a1 k % xn a1 n = xn a1 n - xn a1 (2 * n - k) by rw [this, Int.ofNat_sub xle]\n      rw [← Nat.mod_eq_of_lt (Nat.sub_lt (x_pos a1 n) (x_pos a1 (2 * n - k)))]\n      apply ModEq.add_right_cancel' (xn a1 (2 * n - k))\n      rw [tsub_add_cancel_of_le xle]\n      have t := xn_modEq_x2n_sub_lem a1 k2nl.le\n      rw [tsub_tsub_cancel_of_le k2n] at t\n      exact t.trans dvd_rfl.zero_modEq_nat\n    (lt_trichotomy j n).elim (fun jn : j < n => eq_of_xn_modEq_lem1 _ ij (lt_of_le_of_ne jn jnn))\n      fun o =>\n      o.elim\n        (fun jn : j = n => by\n          cases jn\n          apply Int.lt_of_ofNat_lt_ofNat\n          rw [lem2 (n + 1) (Nat.lt_succ_self _) j2n,\n            show 2 * n - (n + 1) = n - 1 by\n              rw [two_mul, tsub_add_eq_tsub_tsub, add_tsub_cancel_right]]\n          refine lt_sub_left_of_add_lt (Int.ofNat_lt_ofNat_of_lt ?_)\n          rcases lt_or_eq_of_le <| Nat.le_of_succ_le_succ ij with lin | ein\n          · rw [Nat.mod_eq_of_lt (strictMono_x _ lin)]\n            have ll : xn a1 (n - 1) + xn a1 (n - 1) ≤ xn a1 n := by\n              rw [← two_mul, mul_comm,\n                show xn a1 n = xn a1 (n - 1 + 1) by rw [tsub_add_cancel_of_le (succ_le_of_lt npos)],\n                xn_succ]\n              exact le_trans (Nat.mul_le_mul_left _ a1) (Nat.le_add_right _ _)\n            have npm : (n - 1).succ = n := Nat.succ_pred_eq_of_pos npos\n            have il : i ≤ n - 1 := by\n              apply Nat.le_of_succ_le_succ\n              rw [npm]\n              exact lin\n            rcases lt_or_eq_of_le il with ill | ile\n            · exact lt_of_lt_of_le (Nat.add_lt_add_left (strictMono_x a1 ill) _) ll\n            · rw [ile]\n              apply lt_of_le_of_ne ll\n              rw [← two_mul]\n              exact fun e =>\n                ntriv <| by\n                  let ⟨a2, s1⟩ :=\n                    @eq_of_xn_modEq_lem2 _ a1 (n - 1)\n                      (by rwa [tsub_add_cancel_of_le (succ_le_of_lt npos)])\n                  have n1 : n = 1 := le_antisymm (tsub_eq_zero_iff_le.mp s1) npos\n                  rw [ile, a2, n1]; exact ⟨rfl, rfl, rfl, rfl⟩\n          · rw [ein, Nat.mod_self, add_zero]\n            exact strictMono_x _ (Nat.pred_lt npos.ne'))\n        fun jn : j > n =>\n        have lem1 : j ≠ n → xn a1 j % xn a1 n < xn a1 (j + 1) % xn a1 n →\n            xn a1 i % xn a1 n < xn a1 (j + 1) % xn a1 n :=\n          fun jn s =>\n          (lt_or_eq_of_le (Nat.le_of_succ_le_succ ij)).elim\n            (fun h =>\n              lt_trans\n                (eq_of_xn_modEq_lem3 npos h (le_of_lt (Nat.lt_of_succ_le j2n)) jn\n                    fun ⟨_, n1, _, j2⟩ => by\n                      rw [n1, j2] at j2n; exact absurd j2n (by decide))\n                s)\n            fun h => by rw [h]; exact s\n        lem1 (_root_.ne_of_gt jn) <|\n          Int.lt_of_ofNat_lt_ofNat <| by\n            rw [lem2 j jn (le_of_lt j2n), lem2 (j + 1) (Nat.le_succ_of_le jn) j2n]\n            refine sub_lt_sub_left (Int.ofNat_lt_ofNat_of_lt <| strictMono_x _ ?_) _\n            rw [Nat.sub_succ]\n            exact Nat.pred_lt (_root_.ne_of_gt <| tsub_pos_of_lt j2n)\n\n"}
{"name":"Pell.eq_of_xn_modEq_le","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\ni j n : Nat\nij : LE.le i j\nj2n : LE.le j (HMul.hMul 2 n)\nh : (Pell.xn a1 n).ModEq (Pell.xn a1 i) (Pell.xn a1 j)\nntriv : Not (And (Eq a 2) (And (Eq n 1) (And (Eq i 0) (Eq j 2))))\n⊢ Eq i j","decl":"theorem eq_of_xn_modEq_le {i j n} (ij : i ≤ j) (j2n : j ≤ 2 * n)\n    (h : xn a1 i ≡ xn a1 j [MOD xn a1 n])\n    (ntriv : ¬(a = 2 ∧ n = 1 ∧ i = 0 ∧ j = 2)) : i = j :=\n  if npos : n = 0 then by simp_all\n  else\n    (lt_or_eq_of_le ij).resolve_left fun ij' =>\n      if jn : j = n then by\n        refine _root_.ne_of_gt ?_ h\n        rw [jn, Nat.mod_self]\n        have x0 : 0 < xn a1 0 % xn a1 n := by\n          rw [Nat.mod_eq_of_lt (strictMono_x a1 (Nat.pos_of_ne_zero npos))]\n          exact Nat.succ_pos _\n        cases' i with i\n        · exact x0\n        rw [jn] at ij'\n        exact\n          x0.trans\n            (eq_of_xn_modEq_lem3 _ (Nat.pos_of_ne_zero npos) (Nat.succ_pos _) (le_trans ij j2n)\n              (_root_.ne_of_lt ij') fun ⟨_, n1, _, i2⟩ => by\n              rw [n1, i2] at ij'; exact absurd ij' (by decide))\n      else _root_.ne_of_lt (eq_of_xn_modEq_lem3 a1 (Nat.pos_of_ne_zero npos) ij' j2n jn ntriv) h\n\n"}
{"name":"Pell.eq_of_xn_modEq","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\ni j n : Nat\ni2n : LE.le i (HMul.hMul 2 n)\nj2n : LE.le j (HMul.hMul 2 n)\nh : (Pell.xn a1 n).ModEq (Pell.xn a1 i) (Pell.xn a1 j)\nntriv : Eq a 2 → Eq n 1 → And (Eq i 0 → Ne j 2) (Eq i 2 → Ne j 0)\n⊢ Eq i j","decl":"theorem eq_of_xn_modEq {i j n} (i2n : i ≤ 2 * n) (j2n : j ≤ 2 * n)\n    (h : xn a1 i ≡ xn a1 j [MOD xn a1 n])\n    (ntriv : a = 2 → n = 1 → (i = 0 → j ≠ 2) ∧ (i = 2 → j ≠ 0)) : i = j :=\n  (le_total i j).elim\n    (fun ij => eq_of_xn_modEq_le a1 ij j2n h fun ⟨a2, n1, i0, j2⟩ => (ntriv a2 n1).left i0 j2)\n    fun ij =>\n    (eq_of_xn_modEq_le a1 ij i2n h.symm fun ⟨a2, n1, j0, i2⟩ => (ntriv a2 n1).right i2 j0).symm\n\n"}
{"name":"Pell.eq_of_xn_modEq'","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\ni j n : Nat\nipos : LT.lt 0 i\nhin : LE.le i n\nj4n : LE.le j (HMul.hMul 4 n)\nh : (Pell.xn a1 n).ModEq (Pell.xn a1 j) (Pell.xn a1 i)\n⊢ Or (Eq j i) (Eq (HAdd.hAdd j i) (HMul.hMul 4 n))","decl":"theorem eq_of_xn_modEq' {i j n} (ipos : 0 < i) (hin : i ≤ n) (j4n : j ≤ 4 * n)\n    (h : xn a1 j ≡ xn a1 i [MOD xn a1 n]) : j = i ∨ j + i = 4 * n :=\n  have i2n : i ≤ 2 * n := by apply le_trans hin; rw [two_mul]; apply Nat.le_add_left\n  (le_or_gt j (2 * n)).imp\n    (fun j2n : j ≤ 2 * n =>\n      eq_of_xn_modEq a1 j2n i2n h fun _ n1 =>\n        ⟨fun _ i2 => by rw [n1, i2] at hin; exact absurd hin (by decide), fun _ i0 =>\n          _root_.ne_of_gt ipos i0⟩)\n    fun j2n : 2 * n < j =>\n    suffices i = 4 * n - j by rw [this, add_tsub_cancel_of_le j4n]\n    have j42n : 4 * n - j ≤ 2 * n := by omega\n    eq_of_xn_modEq a1 i2n j42n\n      (h.symm.trans <| by\n        let t := xn_modEq_x4n_sub a1 j42n\n        rwa [tsub_tsub_cancel_of_le j4n] at t)\n      (by omega)\n\n"}
{"name":"Pell.modEq_of_xn_modEq","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a : Nat\na1 : LT.lt 1 a\ni j n : Nat\nipos : LT.lt 0 i\nhin : LE.le i n\nh : (Pell.xn a1 n).ModEq (Pell.xn a1 j) (Pell.xn a1 i)\n⊢ Or ((HMul.hMul 4 n).ModEq j i) ((HMul.hMul 4 n).ModEq (HAdd.hAdd j i) 0)","decl":"theorem modEq_of_xn_modEq {i j n} (ipos : 0 < i) (hin : i ≤ n)\n    (h : xn a1 j ≡ xn a1 i [MOD xn a1 n]) :\n    j ≡ i [MOD 4 * n] ∨ j + i ≡ 0 [MOD 4 * n] :=\n  let j' := j % (4 * n)\n  have n4 : 0 < 4 * n := mul_pos (by decide) (ipos.trans_le hin)\n  have jl : j' < 4 * n := Nat.mod_lt _ n4\n  have jj : j ≡ j' [MOD 4 * n] := by delta ModEq; rw [Nat.mod_eq_of_lt jl]\n  have : ∀ j q, xn a1 (j + 4 * n * q) ≡ xn a1 j [MOD xn a1 n] := by\n    intro j q; induction' q with q IH\n    · simp [ModEq.refl]\n    rw [Nat.mul_succ, ← add_assoc, add_comm]\n    exact (xn_modEq_x4n_add _ _ _).trans IH\n  Or.imp (fun ji : j' = i => by rwa [← ji])\n    (fun ji : j' + i = 4 * n =>\n      (jj.add_right _).trans <| by\n        rw [ji]\n        exact dvd_rfl.modEq_zero_nat)\n    (eq_of_xn_modEq' a1 ipos hin jl.le <|\n      (h.symm.trans <| by\n          rw [← Nat.mod_add_div j (4 * n)]\n          exact this j' _).symm)\n\n"}
{"name":"Pell.xy_modEq_of_modEq","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a b c : Nat\na1 : LT.lt 1 a\nb1 : LT.lt 1 b\nh : c.ModEq a b\nn : Nat\n⊢ And (c.ModEq (Pell.xn a1 n) (Pell.xn b1 n)) (c.ModEq (Pell.yn a1 n) (Pell.yn b1 n))","decl":"theorem xy_modEq_of_modEq {a b c} (a1 : 1 < a) (b1 : 1 < b) (h : a ≡ b [MOD c]) :\n    ∀ n, xn a1 n ≡ xn b1 n [MOD c] ∧ yn a1 n ≡ yn b1 n [MOD c]\n  | 0 => by constructor <;> rfl\n  | 1 => by simpa using ⟨h, ModEq.refl 1⟩\n  | n + 2 =>\n    ⟨(xy_modEq_of_modEq a1 b1 h n).left.add_right_cancel <| by\n        rw [xn_succ_succ a1, xn_succ_succ b1]\n        exact (h.mul_left _).mul (xy_modEq_of_modEq _ _ h (n + 1)).left,\n      (xy_modEq_of_modEq a1 b1 h n).right.add_right_cancel <| by\n        rw [yn_succ_succ a1, yn_succ_succ b1]\n        exact (h.mul_left _).mul (xy_modEq_of_modEq _ _ h (n + 1)).right⟩\n\n"}
{"name":"Pell.matiyasevic","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a k x y : Nat\n⊢ Iff (Exists fun a1 => And (Eq (Pell.xn a1 k) x) (Eq (Pell.yn a1 k) y)) (And (LT.lt 1 a) (And (LE.le k y) (Or (And (Eq x 1) (Eq y 0)) (Exists fun u => Exists fun v => Exists fun s => Exists fun t => Exists fun b => And (Eq (HSub.hSub (HMul.hMul x x) (HMul.hMul (HMul.hMul (HSub.hSub (HMul.hMul a a) 1) y) y)) 1) (And (Eq (HSub.hSub (HMul.hMul u u) (HMul.hMul (HMul.hMul (HSub.hSub (HMul.hMul a a) 1) v) v)) 1) (And (Eq (HSub.hSub (HMul.hMul s s) (HMul.hMul (HMul.hMul (HSub.hSub (HMul.hMul b b) 1) t) t)) 1) (And (LT.lt 1 b) (And ((HMul.hMul 4 y).ModEq b 1) (And (u.ModEq b a) (And (LT.lt 0 v) (And (Dvd.dvd (HMul.hMul y y) v) (And (u.ModEq s x) ((HMul.hMul 4 y).ModEq t k)))))))))))))","decl":"theorem matiyasevic {a k x y} :\n    (∃ a1 : 1 < a, xn a1 k = x ∧ yn a1 k = y) ↔\n      1 < a ∧ k ≤ y ∧ (x = 1 ∧ y = 0 ∨\n        ∃ u v s t b : ℕ,\n          x * x - (a * a - 1) * y * y = 1 ∧ u * u - (a * a - 1) * v * v = 1 ∧\n          s * s - (b * b - 1) * t * t = 1 ∧ 1 < b ∧ b ≡ 1 [MOD 4 * y] ∧\n          b ≡ a [MOD u] ∧ 0 < v ∧ y * y ∣ v ∧ s ≡ x [MOD u] ∧ t ≡ k [MOD 4 * y]) :=\n  ⟨fun ⟨a1, hx, hy⟩ => by\n    rw [← hx, ← hy]\n    refine ⟨a1,\n        (Nat.eq_zero_or_pos k).elim (fun k0 => by rw [k0]; exact ⟨le_rfl, Or.inl ⟨rfl, rfl⟩⟩)\n          fun kpos => ?_⟩\n    exact\n      let x := xn a1 k\n      let y := yn a1 k\n      let m := 2 * (k * y)\n      let u := xn a1 m\n      let v := yn a1 m\n      have ky : k ≤ y := yn_ge_n a1 k\n      have yv : y * y ∣ v := (ysq_dvd_yy a1 k).trans <| (y_dvd_iff _ _ _).2 <| dvd_mul_left _ _\n      have uco : Nat.Coprime u (4 * y) :=\n        have : 2 ∣ v :=\n          modEq_zero_iff_dvd.1 <| (yn_modEq_two _ _).trans (dvd_mul_right _ _).modEq_zero_nat\n        have : Nat.Coprime u 2 := (xy_coprime a1 m).coprime_dvd_right this\n        (this.mul_right this).mul_right <|\n          (xy_coprime _ _).coprime_dvd_right (dvd_of_mul_left_dvd yv)\n      let ⟨b, ba, bm1⟩ := chineseRemainder uco a 1\n      have m1 : 1 < m :=\n        have : 0 < k * y := mul_pos kpos (strictMono_y a1 kpos)\n        Nat.mul_le_mul_left 2 this\n      have vp : 0 < v := strictMono_y a1 (lt_trans zero_lt_one m1)\n      have b1 : 1 < b :=\n        have : xn a1 1 < u := strictMono_x a1 m1\n        have : a < u := by simpa using this\n        lt_of_lt_of_le a1 <| by\n          delta ModEq at ba; rw [Nat.mod_eq_of_lt this] at ba; rw [← ba]\n          apply Nat.mod_le\n      let s := xn b1 k\n      let t := yn b1 k\n      have sx : s ≡ x [MOD u] := (xy_modEq_of_modEq b1 a1 ba k).left\n      have tk : t ≡ k [MOD 4 * y] :=\n        have : 4 * y ∣ b - 1 :=\n          Int.natCast_dvd_natCast.1 <| by rw [Int.ofNat_sub (le_of_lt b1)]; exact bm1.symm.dvd\n        (yn_modEq_a_sub_one _ _).of_dvd this\n      ⟨ky,\n        Or.inr\n          ⟨u, v, s, t, b, pell_eq _ _, pell_eq _ _, pell_eq _ _, b1, bm1, ba, vp, yv, sx, tk⟩⟩,\n    fun ⟨a1, ky, o⟩ =>\n    ⟨a1,\n      match o with\n      | Or.inl ⟨x1, y0⟩ => by\n        rw [y0] at ky; rw [Nat.eq_zero_of_le_zero ky, x1, y0]; exact ⟨rfl, rfl⟩\n      | Or.inr ⟨u, v, s, t, b, xy, uv, st, b1, rem⟩ =>\n        match x, y, eq_pell a1 xy, u, v, eq_pell a1 uv, s, t, eq_pell b1 st, rem, ky with\n        | _, _, ⟨i, rfl, rfl⟩, _, _, ⟨n, rfl, rfl⟩, _, _, ⟨j, rfl, rfl⟩,\n          ⟨(bm1 : b ≡ 1 [MOD 4 * yn a1 i]), (ba : b ≡ a [MOD xn a1 n]), (vp : 0 < yn a1 n),\n            (yv : yn a1 i * yn a1 i ∣ yn a1 n), (sx : xn b1 j ≡ xn a1 i [MOD xn a1 n]),\n            (tk : yn b1 j ≡ k [MOD 4 * yn a1 i])⟩,\n          (ky : k ≤ yn a1 i) =>\n          (Nat.eq_zero_or_pos i).elim\n            (fun i0 => by\n              simp only [i0, yn_zero, nonpos_iff_eq_zero] at ky; rw [i0, ky]; exact ⟨rfl, rfl⟩)\n            fun ipos => by\n            suffices i = k by rw [this]; exact ⟨rfl, rfl⟩\n            clear o rem xy uv st\n            have iln : i ≤ n :=\n              le_of_not_gt fun hin =>\n                not_lt_of_ge (Nat.le_of_dvd vp (dvd_of_mul_left_dvd yv)) (strictMono_y a1 hin)\n            have yd : 4 * yn a1 i ∣ 4 * n := mul_dvd_mul_left _ <| dvd_of_ysq_dvd a1 yv\n            have jk : j ≡ k [MOD 4 * yn a1 i] :=\n              have : 4 * yn a1 i ∣ b - 1 :=\n                Int.natCast_dvd_natCast.1 <| by rw [Int.ofNat_sub (le_of_lt b1)]; exact bm1.symm.dvd\n              ((yn_modEq_a_sub_one b1 _).of_dvd this).symm.trans tk\n            have ki : k + i < 4 * yn a1 i :=\n              lt_of_le_of_lt (_root_.add_le_add ky (yn_ge_n a1 i)) <| by\n                rw [← two_mul]\n                exact Nat.mul_lt_mul_of_pos_right (by decide) (strictMono_y a1 ipos)\n            have ji : j ≡ i [MOD 4 * n] :=\n              have : xn a1 j ≡ xn a1 i [MOD xn a1 n] :=\n                (xy_modEq_of_modEq b1 a1 ba j).left.symm.trans sx\n              (modEq_of_xn_modEq a1 ipos iln this).resolve_right\n                fun ji : j + i ≡ 0 [MOD 4 * n] =>\n                not_le_of_gt ki <|\n                  Nat.le_of_dvd (lt_of_lt_of_le ipos <| Nat.le_add_left _ _) <|\n                    modEq_zero_iff_dvd.1 <| (jk.symm.add_right i).trans <| ji.of_dvd yd\n            have : i % (4 * yn a1 i) = k % (4 * yn a1 i) := (ji.of_dvd yd).symm.trans jk\n            rwa [Nat.mod_eq_of_lt (lt_of_le_of_lt (Nat.le_add_left _ _) ki),\n              Nat.mod_eq_of_lt (lt_of_le_of_lt (Nat.le_add_right _ _) ki)] at this⟩⟩\n\n"}
{"name":"Pell.eq_pow_of_pell_lem","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"a y k : Nat\nhy0 : Ne y 0\nhk0 : Ne k 0\nhyk : LT.lt (HPow.hPow y k) a\n⊢ LT.lt (↑(HPow.hPow y k)) (HSub.hSub (HSub.hSub (HMul.hMul (HMul.hMul 2 ↑a) ↑y) (HMul.hMul ↑y ↑y)) 1)","decl":"theorem eq_pow_of_pell_lem {a y k : ℕ} (hy0 : y ≠ 0) (hk0 : k ≠ 0) (hyk : y ^ k < a) :\n    (↑(y ^ k) : ℤ) < 2 * a * y - y * y - 1 :=\n  have hya : y < a := (Nat.le_self_pow hk0 _).trans_lt hyk\n  calc\n    (↑(y ^ k) : ℤ) < a := Nat.cast_lt.2 hyk\n    _ ≤ (a : ℤ) ^ 2 - (a - 1 : ℤ) ^ 2 - 1 := by\n      rw [sub_sq, mul_one, one_pow, sub_add, sub_sub_cancel, two_mul, sub_sub, ← add_sub,\n        le_add_iff_nonneg_right, sub_nonneg, Int.add_one_le_iff]\n      norm_cast\n      exact lt_of_le_of_lt (Nat.succ_le_of_lt (Nat.pos_of_ne_zero hy0)) hya\n    _ ≤ (a : ℤ) ^ 2 - (a - y : ℤ) ^ 2 - 1 := by\n      have := hya.le\n      gcongr <;> norm_cast <;> omega\n    _ = 2 * a * y - y * y - 1 := by ring\n\n"}
{"name":"Pell.eq_pow_of_pell","module":"Mathlib.NumberTheory.PellMatiyasevic","initialProofState":"m n k : Nat\n⊢ Iff (Eq (HPow.hPow n k) m) (Or (And (Eq k 0) (Eq m 1)) (And (LT.lt 0 k) (Or (And (Eq n 0) (Eq m 0)) (And (LT.lt 0 n) (Exists fun w => Exists fun a => Exists fun t => Exists fun z => Exists fun a1 => And (t.ModEq (Pell.xn a1 k) (HAdd.hAdd (HMul.hMul (Pell.yn a1 k) (HSub.hSub a n)) m)) (And (Eq (HMul.hMul (HMul.hMul 2 a) n) (HAdd.hAdd t (HAdd.hAdd (HMul.hMul n n) 1))) (And (LT.lt m t) (And (LE.le n w) (And (LE.le k w) (Eq (HSub.hSub (HMul.hMul a a) (HMul.hMul (HMul.hMul (HSub.hSub (HMul.hMul (HAdd.hAdd w 1) (HAdd.hAdd w 1)) 1) (HMul.hMul w z)) (HMul.hMul w z))) 1))))))))))","decl":"theorem eq_pow_of_pell {m n k} :\n    n ^ k = m ↔ k = 0 ∧ m = 1 ∨0 < k ∧ (n = 0 ∧ m = 0 ∨\n      0 < n ∧ ∃ (w a t z : ℕ) (a1 : 1 < a), xn a1 k ≡ yn a1 k * (a - n) + m [MOD t] ∧\n      2 * a * n = t + (n * n + 1) ∧ m < t ∧\n      n ≤ w ∧ k ≤ w ∧ a * a - ((w + 1) * (w + 1) - 1) * (w * z) * (w * z) = 1) := by\n  constructor\n  · rintro rfl\n    refine k.eq_zero_or_pos.imp (fun k0 : k = 0 => k0.symm ▸ ⟨rfl, rfl⟩) fun hk => ⟨hk, ?_⟩\n    refine n.eq_zero_or_pos.imp (fun n0 : n = 0 ↦ n0.symm ▸ ⟨rfl, zero_pow hk.ne'⟩)\n      fun hn ↦ ⟨hn, ?_⟩\n    set w := max n k\n    have nw : n ≤ w := le_max_left _ _\n    have kw : k ≤ w := le_max_right _ _\n    have wpos : 0 < w := hn.trans_le nw\n    have w1 : 1 < w + 1 := Nat.succ_lt_succ wpos\n    set a := xn w1 w\n    have a1 : 1 < a := strictMono_x w1 wpos\n    have na : n ≤ a := nw.trans (n_lt_xn w1 w).le\n    set x := xn a1 k\n    set y := yn a1 k\n    obtain ⟨z, ze⟩ : w ∣ yn w1 w :=\n      modEq_zero_iff_dvd.1 ((yn_modEq_a_sub_one w1 w).trans dvd_rfl.modEq_zero_nat)\n    have nt : (↑(n ^ k) : ℤ) < 2 * a * n - n * n - 1 := by\n      refine eq_pow_of_pell_lem hn.ne' hk.ne' ?_\n      calc\n        n ^ k ≤ n ^ w := Nat.pow_le_pow_of_le_right hn kw\n        _ < (w + 1) ^ w := Nat.pow_lt_pow_left (Nat.lt_succ_of_le nw) wpos.ne'\n        _ ≤ a := xn_ge_a_pow w1 w\n    lift (2 * a * n - n * n - 1 : ℤ) to ℕ using (Nat.cast_nonneg _).trans nt.le with t te\n    have tm : x ≡ y * (a - n) + n ^ k [MOD t] := by\n      apply modEq_of_dvd\n      rw [Int.ofNat_add, Int.ofNat_mul, Int.ofNat_sub na, te]\n      exact x_sub_y_dvd_pow a1 n k\n    have ta : 2 * a * n = t + (n * n + 1) := by\n      zify\n      omega\n    have zp : a * a - ((w + 1) * (w + 1) - 1) * (w * z) * (w * z) = 1 := ze ▸ pell_eq w1 w\n    exact ⟨w, a, t, z, a1, tm, ta, Nat.cast_lt.1 nt, nw, kw, zp⟩\n  · rintro (⟨rfl, rfl⟩ | ⟨hk0, ⟨rfl, rfl⟩ | ⟨hn0, w, a, t, z, a1, tm, ta, mt, nw, kw, zp⟩⟩)\n    · exact _root_.pow_zero n\n    · exact zero_pow hk0.ne'\n    have hw0 : 0 < w := hn0.trans_le nw\n    have hw1 : 1 < w + 1 := Nat.succ_lt_succ hw0\n    rcases eq_pell hw1 zp with ⟨j, rfl, yj⟩\n    have hj0 : 0 < j := by\n      apply Nat.pos_of_ne_zero\n      rintro rfl\n      exact lt_irrefl 1 a1\n    have wj : w ≤ j :=\n      Nat.le_of_dvd hj0\n        (modEq_zero_iff_dvd.1 <|\n          (yn_modEq_a_sub_one hw1 j).symm.trans <| modEq_zero_iff_dvd.2 ⟨z, yj.symm⟩)\n    have hnka : n ^ k < xn hw1 j := calc\n      n ^ k ≤ n ^ j := Nat.pow_le_pow_of_le_right hn0 (le_trans kw wj)\n      _ < (w + 1) ^ j := Nat.pow_lt_pow_left (Nat.lt_succ_of_le nw) hj0.ne'\n      _ ≤ xn hw1 j := xn_ge_a_pow hw1 j\n    have nt : (↑(n ^ k) : ℤ) < 2 * xn hw1 j * n - n * n - 1 :=\n      eq_pow_of_pell_lem hn0.ne' hk0.ne' hnka\n    have na : n ≤ xn hw1 j := (Nat.le_self_pow hk0.ne' _).trans hnka.le\n    have te : (t : ℤ) = 2 * xn hw1 j * n - n * n - 1 := by\n      rw [sub_sub, eq_sub_iff_add_eq]\n      exact mod_cast ta.symm\n    have : xn a1 k ≡ yn a1 k * (xn hw1 j - n) + n ^ k [MOD t] := by\n      apply modEq_of_dvd\n      rw [te, Nat.cast_add, Nat.cast_mul, Int.ofNat_sub na]\n      exact x_sub_y_dvd_pow a1 n k\n    have : n ^ k % t = m % t := (this.symm.trans tm).add_left_cancel' _\n    rw [← te] at nt\n    rwa [Nat.mod_eq_of_lt (Nat.cast_lt.1 nt), Nat.mod_eq_of_lt mt] at this\n\n"}
