{"name":"Valuation.onQuot_comap_eq","module":"Mathlib.RingTheory.Valuation.Quotient","initialProofState":"R : Type u_1\nΓ₀ : Type u_2\ninst✝¹ : CommRing R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nJ : Ideal R\nhJ : LE.le J v.supp\n⊢ Eq (Valuation.comap (Ideal.Quotient.mk J) (v.onQuot hJ)) v","decl":"@[simp]\ntheorem onQuot_comap_eq {J : Ideal R} (hJ : J ≤ supp v) :\n    (v.onQuot hJ).comap (Ideal.Quotient.mk J) = v :=\n  ext fun _ => rfl\n\n"}
{"name":"Valuation.self_le_supp_comap","module":"Mathlib.RingTheory.Valuation.Quotient","initialProofState":"R : Type u_1\nΓ₀ : Type u_2\ninst✝¹ : CommRing R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nJ : Ideal R\nv : Valuation (HasQuotient.Quotient R J) Γ₀\n⊢ LE.le J (Valuation.comap (Ideal.Quotient.mk J) v).supp","decl":"theorem self_le_supp_comap (J : Ideal R) (v : Valuation (R ⧸ J) Γ₀) :\n    J ≤ (v.comap (Ideal.Quotient.mk J)).supp := by\n  rw [comap_supp, ← Ideal.map_le_iff_le_comap]\n  simp\n\n"}
{"name":"Valuation.comap_onQuot_eq","module":"Mathlib.RingTheory.Valuation.Quotient","initialProofState":"R : Type u_1\nΓ₀ : Type u_2\ninst✝¹ : CommRing R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nJ : Ideal R\nv : Valuation (HasQuotient.Quotient R J) Γ₀\n⊢ Eq ((Valuation.comap (Ideal.Quotient.mk J) v).onQuot ⋯) v","decl":"@[simp]\ntheorem comap_onQuot_eq (J : Ideal R) (v : Valuation (R ⧸ J) Γ₀) :\n    (v.comap (Ideal.Quotient.mk J)).onQuot (v.self_le_supp_comap J) = v :=\n  ext <| by\n    rintro ⟨x⟩\n    rfl\n\n"}
{"name":"Valuation.supp_quot","module":"Mathlib.RingTheory.Valuation.Quotient","initialProofState":"R : Type u_1\nΓ₀ : Type u_2\ninst✝¹ : CommRing R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\nJ : Ideal R\nhJ : LE.le J v.supp\n⊢ Eq (v.onQuot hJ).supp (Ideal.map (Ideal.Quotient.mk J) v.supp)","decl":"/-- The quotient valuation on `R / J` has support `(supp v) / J` if `J ⊆ supp v`. -/\ntheorem supp_quot {J : Ideal R} (hJ : J ≤ supp v) :\n    supp (v.onQuot hJ) = (supp v).map (Ideal.Quotient.mk J) := by\n  apply le_antisymm\n  · rintro ⟨x⟩ hx\n    apply Ideal.subset_span\n    exact ⟨x, hx, rfl⟩\n  · rw [Ideal.map_le_iff_le_comap]\n    intro x hx\n    exact hx\n\n"}
{"name":"Valuation.supp_quot_supp","module":"Mathlib.RingTheory.Valuation.Quotient","initialProofState":"R : Type u_1\nΓ₀ : Type u_2\ninst✝¹ : CommRing R\ninst✝ : LinearOrderedCommMonoidWithZero Γ₀\nv : Valuation R Γ₀\n⊢ Eq (v.onQuot ⋯).supp 0","decl":"theorem supp_quot_supp : supp (v.onQuot le_rfl) = 0 := by\n  rw [supp_quot]\n  exact Ideal.map_quotient_self _\n\n"}
{"name":"AddValuation.onQuot_comap_eq","module":"Mathlib.RingTheory.Valuation.Quotient","initialProofState":"R : Type u_1\nΓ₀ : Type u_2\ninst✝¹ : CommRing R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nJ : Ideal R\nhJ : LE.le J v.supp\n⊢ Eq (AddValuation.comap (Ideal.Quotient.mk J) (v.onQuot hJ)) v","decl":"@[simp]\ntheorem onQuot_comap_eq {J : Ideal R} (hJ : J ≤ supp v) :\n    (v.onQuot hJ).comap (Ideal.Quotient.mk J) = v :=\n  Valuation.onQuot_comap_eq v hJ\n\n"}
{"name":"AddValuation.comap_supp","module":"Mathlib.RingTheory.Valuation.Quotient","initialProofState":"R : Type u_1\nΓ₀ : Type u_2\ninst✝² : CommRing R\ninst✝¹ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nS : Type u_3\ninst✝ : CommRing S\nf : RingHom S R\n⊢ Eq (AddValuation.comap f v).supp (Ideal.comap f v.supp)","decl":"theorem comap_supp {S : Type*} [CommRing S] (f : S →+* R) :\n    supp (v.comap f) = Ideal.comap f v.supp :=\n  Valuation.comap_supp v f\n\n"}
{"name":"AddValuation.self_le_supp_comap","module":"Mathlib.RingTheory.Valuation.Quotient","initialProofState":"R : Type u_1\nΓ₀ : Type u_2\ninst✝¹ : CommRing R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nJ : Ideal R\nv : AddValuation (HasQuotient.Quotient R J) Γ₀\n⊢ LE.le J (AddValuation.comap (Ideal.Quotient.mk J) v).supp","decl":"theorem self_le_supp_comap (J : Ideal R) (v : AddValuation (R ⧸ J) Γ₀) :\n    J ≤ (v.comap (Ideal.Quotient.mk J)).supp :=\n  Valuation.self_le_supp_comap J v\n\n"}
{"name":"AddValuation.comap_onQuot_eq","module":"Mathlib.RingTheory.Valuation.Quotient","initialProofState":"R : Type u_1\nΓ₀ : Type u_2\ninst✝¹ : CommRing R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nJ : Ideal R\nv : AddValuation (HasQuotient.Quotient R J) Γ₀\n⊢ Eq ((AddValuation.comap (Ideal.Quotient.mk J) v).onQuot ⋯) v","decl":"@[simp]\ntheorem comap_onQuot_eq (J : Ideal R) (v : AddValuation (R ⧸ J) Γ₀) :\n    (v.comap (Ideal.Quotient.mk J)).onQuot (v.self_le_supp_comap J) = v :=\n  Valuation.comap_onQuot_eq J v\n\n"}
{"name":"AddValuation.supp_quot","module":"Mathlib.RingTheory.Valuation.Quotient","initialProofState":"R : Type u_1\nΓ₀ : Type u_2\ninst✝¹ : CommRing R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\nJ : Ideal R\nhJ : LE.le J v.supp\n⊢ Eq (v.onQuot hJ).supp (Ideal.map (Ideal.Quotient.mk J) v.supp)","decl":"/-- The quotient valuation on `R / J` has support `(supp v) / J` if `J ⊆ supp v`. -/\ntheorem supp_quot {J : Ideal R} (hJ : J ≤ supp v) :\n    supp (v.onQuot hJ) = (supp v).map (Ideal.Quotient.mk J) :=\n  Valuation.supp_quot v hJ\n\n"}
{"name":"AddValuation.supp_quot_supp","module":"Mathlib.RingTheory.Valuation.Quotient","initialProofState":"R : Type u_1\nΓ₀ : Type u_2\ninst✝¹ : CommRing R\ninst✝ : LinearOrderedAddCommMonoidWithTop Γ₀\nv : AddValuation R Γ₀\n⊢ Eq (AddValuation.supp (Valuation.onQuot v ⋯)) 0","decl":"theorem supp_quot_supp : supp ((Valuation.onQuot v) le_rfl) = 0 :=\n  Valuation.supp_quot_supp v\n\n"}
