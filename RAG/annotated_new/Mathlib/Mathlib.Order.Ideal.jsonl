{"name":"Order.Ideal.nonempty'","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst✝ : LE P\nself : Order.Ideal P\n⊢ self.carrier.Nonempty","decl":"/-- An ideal on an order `P` is a subset of `P` that is\n  - nonempty\n  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)\n  - downward closed (any element less than an element of the ideal is in the ideal). -/\nstructure Ideal (P) [LE P] extends LowerSet P where\n  /-- The ideal is nonempty. -/\n  nonempty' : carrier.Nonempty\n  /-- The ideal is upward directed. -/\n  directed' : DirectedOn (· ≤ ·) carrier\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: remove this configuration and use the default configuration.\n-- We keep this to be consistent with Lean 3.\n"}
{"name":"Order.Ideal.mk.inj","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst✝ : LE P\ntoLowerSet✝ : LowerSet P\nnonempty'✝ : toLowerSet✝.carrier.Nonempty\ndirected'✝ : DirectedOn (fun x1 x2 => LE.le x1 x2) toLowerSet✝.carrier\ntoLowerSet : LowerSet P\nnonempty' : toLowerSet.carrier.Nonempty\ndirected' : DirectedOn (fun x1 x2 => LE.le x1 x2) toLowerSet.carrier\nx✝ : Eq { toLowerSet := toLowerSet✝, nonempty' := nonempty'✝, directed' := directed'✝ } { toLowerSet := toLowerSet, nonempty' := nonempty', directed' := directed' }\n⊢ Eq toLowerSet✝ toLowerSet","decl":"/-- An ideal on an order `P` is a subset of `P` that is\n  - nonempty\n  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)\n  - downward closed (any element less than an element of the ideal is in the ideal). -/\nstructure Ideal (P) [LE P] extends LowerSet P where\n  /-- The ideal is nonempty. -/\n  nonempty' : carrier.Nonempty\n  /-- The ideal is upward directed. -/\n  directed' : DirectedOn (· ≤ ·) carrier\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: remove this configuration and use the default configuration.\n-- We keep this to be consistent with Lean 3.\n"}
{"name":"Order.Ideal.mk.sizeOf_spec","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst✝¹ : LE P\ninst✝ : SizeOf P\ntoLowerSet : LowerSet P\nnonempty' : toLowerSet.carrier.Nonempty\ndirected' : DirectedOn (fun x1 x2 => LE.le x1 x2) toLowerSet.carrier\n⊢ Eq (SizeOf.sizeOf { toLowerSet := toLowerSet, nonempty' := nonempty', directed' := directed' }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toLowerSet)) (SizeOf.sizeOf nonempty'))","decl":"/-- An ideal on an order `P` is a subset of `P` that is\n  - nonempty\n  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)\n  - downward closed (any element less than an element of the ideal is in the ideal). -/\nstructure Ideal (P) [LE P] extends LowerSet P where\n  /-- The ideal is nonempty. -/\n  nonempty' : carrier.Nonempty\n  /-- The ideal is upward directed. -/\n  directed' : DirectedOn (· ≤ ·) carrier\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: remove this configuration and use the default configuration.\n-- We keep this to be consistent with Lean 3.\n"}
{"name":"Order.Ideal.mk.injEq","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst✝ : LE P\ntoLowerSet✝ : LowerSet P\nnonempty'✝ : toLowerSet✝.carrier.Nonempty\ndirected'✝ : DirectedOn (fun x1 x2 => LE.le x1 x2) toLowerSet✝.carrier\ntoLowerSet : LowerSet P\nnonempty' : toLowerSet.carrier.Nonempty\ndirected' : DirectedOn (fun x1 x2 => LE.le x1 x2) toLowerSet.carrier\n⊢ Eq (Eq { toLowerSet := toLowerSet✝, nonempty' := nonempty'✝, directed' := directed'✝ } { toLowerSet := toLowerSet, nonempty' := nonempty', directed' := directed' }) (Eq toLowerSet✝ toLowerSet)","decl":"/-- An ideal on an order `P` is a subset of `P` that is\n  - nonempty\n  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)\n  - downward closed (any element less than an element of the ideal is in the ideal). -/\nstructure Ideal (P) [LE P] extends LowerSet P where\n  /-- The ideal is nonempty. -/\n  nonempty' : carrier.Nonempty\n  /-- The ideal is upward directed. -/\n  directed' : DirectedOn (· ≤ ·) carrier\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: remove this configuration and use the default configuration.\n-- We keep this to be consistent with Lean 3.\n"}
{"name":"Order.Ideal.directed'","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst✝ : LE P\nself : Order.Ideal P\n⊢ DirectedOn (fun x1 x2 => LE.le x1 x2) self.carrier","decl":"/-- An ideal on an order `P` is a subset of `P` that is\n  - nonempty\n  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)\n  - downward closed (any element less than an element of the ideal is in the ideal). -/\nstructure Ideal (P) [LE P] extends LowerSet P where\n  /-- The ideal is nonempty. -/\n  nonempty' : carrier.Nonempty\n  /-- The ideal is upward directed. -/\n  directed' : DirectedOn (· ≤ ·) carrier\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: remove this configuration and use the default configuration.\n-- We keep this to be consistent with Lean 3.\n"}
{"name":"Order.IsIdeal.IsLowerSet","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst✝ : LE P\nI : Set P\nself : Order.IsIdeal I\n⊢ IsLowerSet I","decl":"/-- A subset of a preorder `P` is an ideal if it is\n  - nonempty\n  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)\n  - downward closed (any element less than an element of the ideal is in the ideal). -/\n@[mk_iff]\nstructure IsIdeal {P} [LE P] (I : Set P) : Prop where\n  /-- The ideal is downward closed. -/\n  IsLowerSet : IsLowerSet I\n  /-- The ideal is nonempty. -/\n  Nonempty : I.Nonempty\n  /-- The ideal is upward directed. -/\n  Directed : DirectedOn (· ≤ ·) I\n\n"}
{"name":"Order.IsIdeal.Directed","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst✝ : LE P\nI : Set P\nself : Order.IsIdeal I\n⊢ DirectedOn (fun x1 x2 => LE.le x1 x2) I","decl":"/-- A subset of a preorder `P` is an ideal if it is\n  - nonempty\n  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)\n  - downward closed (any element less than an element of the ideal is in the ideal). -/\n@[mk_iff]\nstructure IsIdeal {P} [LE P] (I : Set P) : Prop where\n  /-- The ideal is downward closed. -/\n  IsLowerSet : IsLowerSet I\n  /-- The ideal is nonempty. -/\n  Nonempty : I.Nonempty\n  /-- The ideal is upward directed. -/\n  Directed : DirectedOn (· ≤ ·) I\n\n"}
{"name":"Order.IsIdeal.Nonempty","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst✝ : LE P\nI : Set P\nself : Order.IsIdeal I\n⊢ I.Nonempty","decl":"/-- A subset of a preorder `P` is an ideal if it is\n  - nonempty\n  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)\n  - downward closed (any element less than an element of the ideal is in the ideal). -/\n@[mk_iff]\nstructure IsIdeal {P} [LE P] (I : Set P) : Prop where\n  /-- The ideal is downward closed. -/\n  IsLowerSet : IsLowerSet I\n  /-- The ideal is nonempty. -/\n  Nonempty : I.Nonempty\n  /-- The ideal is upward directed. -/\n  Directed : DirectedOn (· ≤ ·) I\n\n"}
{"name":"Order.isIdeal_iff","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst✝ : LE P\nI : Set P\n⊢ Iff (Order.IsIdeal I) (And (IsLowerSet I) (And I.Nonempty (DirectedOn (fun x1 x2 => LE.le x1 x2) I)))","decl":"/-- A subset of a preorder `P` is an ideal if it is\n  - nonempty\n  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)\n  - downward closed (any element less than an element of the ideal is in the ideal). -/\n@[mk_iff]\nstructure IsIdeal {P} [LE P] (I : Set P) : Prop where\n  /-- The ideal is downward closed. -/\n  IsLowerSet : IsLowerSet I\n  /-- The ideal is nonempty. -/\n  Nonempty : I.Nonempty\n  /-- The ideal is upward directed. -/\n  Directed : DirectedOn (· ≤ ·) I\n\n"}
{"name":"Order.Ideal.toLowerSet_injective","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : LE P\n⊢ Function.Injective Order.Ideal.toLowerSet","decl":"theorem toLowerSet_injective : Injective (toLowerSet : Ideal P → LowerSet P) := fun s t _ ↦ by\n  cases s\n  cases t\n  congr\n\n"}
{"name":"Order.Ideal.ext","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : LE P\ns t : Order.Ideal P\na✝ : Eq ↑s ↑t\n⊢ Eq s t","decl":"@[ext]\ntheorem ext {s t : Ideal P} : (s : Set P) = t → s = t :=\n  SetLike.ext'\n\n"}
{"name":"Order.Ideal.ext_iff","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : LE P\ns t : Order.Ideal P\n⊢ Iff (Eq s t) (Eq ↑s ↑t)","decl":"@[ext]\ntheorem ext {s t : Ideal P} : (s : Set P) = t → s = t :=\n  SetLike.ext'\n\n"}
{"name":"Order.Ideal.carrier_eq_coe","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : LE P\ns : Order.Ideal P\n⊢ Eq s.carrier ↑s","decl":"@[simp]\ntheorem carrier_eq_coe (s : Ideal P) : s.carrier = s :=\n  rfl\n\n"}
{"name":"Order.Ideal.coe_toLowerSet","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : LE P\ns : Order.Ideal P\n⊢ Eq ↑s.toLowerSet ↑s","decl":"@[simp]\ntheorem coe_toLowerSet (s : Ideal P) : (s.toLowerSet : Set P) = s :=\n  rfl\n\n"}
{"name":"Order.Ideal.lower","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : LE P\ns : Order.Ideal P\n⊢ IsLowerSet ↑s","decl":"protected theorem lower (s : Ideal P) : IsLowerSet (s : Set P) :=\n  s.lower'\n\n"}
{"name":"Order.Ideal.nonempty","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : LE P\ns : Order.Ideal P\n⊢ (↑s).Nonempty","decl":"protected theorem nonempty (s : Ideal P) : (s : Set P).Nonempty :=\n  s.nonempty'\n\n"}
{"name":"Order.Ideal.directed","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : LE P\ns : Order.Ideal P\n⊢ DirectedOn (fun x1 x2 => LE.le x1 x2) ↑s","decl":"protected theorem directed (s : Ideal P) : DirectedOn (· ≤ ·) (s : Set P) :=\n  s.directed'\n\n"}
{"name":"Order.Ideal.isIdeal","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : LE P\ns : Order.Ideal P\n⊢ Order.IsIdeal ↑s","decl":"protected theorem isIdeal (s : Ideal P) : IsIdeal (s : Set P) :=\n  ⟨s.lower, s.nonempty, s.directed⟩\n\n"}
{"name":"Order.Ideal.mem_compl_of_ge","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : LE P\nI : Order.Ideal P\nx y : P\na✝¹ : LE.le x y\na✝ : Membership.mem (HasCompl.compl ↑I) x\n⊢ Membership.mem (HasCompl.compl ↑I) y","decl":"theorem mem_compl_of_ge {x y : P} : x ≤ y → x ∈ (I : Set P)ᶜ → y ∈ (I : Set P)ᶜ := fun h ↦\n  mt <| I.lower h\n\n"}
{"name":"Order.Ideal.coe_subset_coe","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : LE P\ns t : Order.Ideal P\n⊢ Iff (HasSubset.Subset ↑s ↑t) (LE.le s t)","decl":"theorem coe_subset_coe : (s : Set P) ⊆ t ↔ s ≤ t :=\n  Iff.rfl\n\n"}
{"name":"Order.Ideal.coe_ssubset_coe","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : LE P\ns t : Order.Ideal P\n⊢ Iff (HasSSubset.SSubset ↑s ↑t) (LT.lt s t)","decl":"theorem coe_ssubset_coe : (s : Set P) ⊂ t ↔ s < t :=\n  Iff.rfl\n\n"}
{"name":"Order.Ideal.mem_of_mem_of_le","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : LE P\nx : P\nI J : Order.Ideal P\na✝¹ : Membership.mem I x\na✝ : LE.le I J\n⊢ Membership.mem J x","decl":"@[trans]\ntheorem mem_of_mem_of_le {x : P} {I J : Ideal P} : x ∈ I → I ≤ J → x ∈ J :=\n  @Set.mem_of_mem_of_subset P x I J\n\n"}
{"name":"Order.Ideal.isProper_iff","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : LE P\nI : Order.Ideal P\n⊢ Iff I.IsProper (Ne (↑I) Set.univ)","decl":"/-- A proper ideal is one that is not the whole set.\n    Note that the whole set might not be an ideal. -/\n@[mk_iff]\nclass IsProper (I : Ideal P) : Prop where\n  /-- This ideal is not the whole set. -/\n  ne_univ : (I : Set P) ≠ univ\n\n"}
{"name":"Order.Ideal.IsProper.ne_univ","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : LE P\nI : Order.Ideal P\nself : I.IsProper\n⊢ Ne (↑I) Set.univ","decl":"/-- A proper ideal is one that is not the whole set.\n    Note that the whole set might not be an ideal. -/\n@[mk_iff]\nclass IsProper (I : Ideal P) : Prop where\n  /-- This ideal is not the whole set. -/\n  ne_univ : (I : Set P) ≠ univ\n\n"}
{"name":"Order.Ideal.isProper_of_not_mem","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : LE P\nI : Order.Ideal P\np : P\nnmem : Not (Membership.mem I p)\n⊢ I.IsProper","decl":"theorem isProper_of_not_mem {I : Ideal P} {p : P} (nmem : p ∉ I) : IsProper I :=\n  ⟨fun hp ↦ by\n    have := mem_univ p\n    rw [← hp] at this\n    exact nmem this⟩\n\n"}
{"name":"Order.Ideal.IsMaximal.toIsProper","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : LE P\nI : Order.Ideal P\nself : I.IsMaximal\n⊢ I.IsProper","decl":"/-- An ideal is maximal if it is maximal in the collection of proper ideals.\n\nNote that `IsCoatom` is less general because ideals only have a top element when `P` is directed\nand nonempty. -/\n@[mk_iff]\nclass IsMaximal (I : Ideal P) extends IsProper I : Prop where\n  /-- This ideal is maximal in the collection of proper ideals. -/\n  maximal_proper : ∀ ⦃J : Ideal P⦄, I < J → (J : Set P) = univ\n\n"}
{"name":"Order.Ideal.isMaximal_iff","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : LE P\nI : Order.Ideal P\n⊢ Iff I.IsMaximal (And I.IsProper (∀ ⦃J : Order.Ideal P⦄, LT.lt I J → Eq (↑J) Set.univ))","decl":"/-- An ideal is maximal if it is maximal in the collection of proper ideals.\n\nNote that `IsCoatom` is less general because ideals only have a top element when `P` is directed\nand nonempty. -/\n@[mk_iff]\nclass IsMaximal (I : Ideal P) extends IsProper I : Prop where\n  /-- This ideal is maximal in the collection of proper ideals. -/\n  maximal_proper : ∀ ⦃J : Ideal P⦄, I < J → (J : Set P) = univ\n\n"}
{"name":"Order.Ideal.IsMaximal.maximal_proper","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : LE P\nI : Order.Ideal P\nself : I.IsMaximal\nJ : Order.Ideal P\na✝ : LT.lt I J\n⊢ Eq (↑J) Set.univ","decl":"/-- An ideal is maximal if it is maximal in the collection of proper ideals.\n\nNote that `IsCoatom` is less general because ideals only have a top element when `P` is directed\nand nonempty. -/\n@[mk_iff]\nclass IsMaximal (I : Ideal P) extends IsProper I : Prop where\n  /-- This ideal is maximal in the collection of proper ideals. -/\n  maximal_proper : ∀ ⦃J : Ideal P⦄, I < J → (J : Set P) = univ\n\n"}
{"name":"Order.Ideal.inter_nonempty","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝¹ : LE P\ninst✝ : IsDirected P fun x1 x2 => GE.ge x1 x2\nI J : Order.Ideal P\n⊢ (Inter.inter ↑I ↑J).Nonempty","decl":"theorem inter_nonempty [IsDirected P (· ≥ ·)] (I J : Ideal P) : (I ∩ J : Set P).Nonempty := by\n  obtain ⟨a, ha⟩ := I.nonempty\n  obtain ⟨b, hb⟩ := J.nonempty\n  obtain ⟨c, hac, hbc⟩ := exists_le_le a b\n  exact ⟨c, I.lower hac ha, J.lower hbc hb⟩\n\n"}
{"name":"Order.Ideal.top_toLowerSet","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝² : LE P\ninst✝¹ : IsDirected P fun x1 x2 => LE.le x1 x2\ninst✝ : Nonempty P\n⊢ Eq Top.top.toLowerSet Top.top","decl":"@[simp]\ntheorem top_toLowerSet : (⊤ : Ideal P).toLowerSet = ⊤ :=\n  rfl\n\n"}
{"name":"Order.Ideal.coe_top","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝² : LE P\ninst✝¹ : IsDirected P fun x1 x2 => LE.le x1 x2\ninst✝ : Nonempty P\n⊢ Eq (↑Top.top) Set.univ","decl":"@[simp]\ntheorem coe_top : ((⊤ : Ideal P) : Set P) = univ :=\n  rfl\n\n"}
{"name":"Order.Ideal.isProper_of_ne_top","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝² : LE P\ninst✝¹ : IsDirected P fun x1 x2 => LE.le x1 x2\ninst✝ : Nonempty P\nI : Order.Ideal P\nne_top : Ne I Top.top\n⊢ I.IsProper","decl":"theorem isProper_of_ne_top (ne_top : I ≠ ⊤) : IsProper I :=\n  ⟨fun h ↦ ne_top <| ext h⟩\n\n"}
{"name":"Order.Ideal.IsProper.ne_top","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝² : LE P\ninst✝¹ : IsDirected P fun x1 x2 => LE.le x1 x2\ninst✝ : Nonempty P\nI : Order.Ideal P\nx✝ : I.IsProper\n⊢ Ne I Top.top","decl":"theorem IsProper.ne_top (_ : IsProper I) : I ≠ ⊤ :=\n  fun h ↦ IsProper.ne_univ <| congr_arg SetLike.coe h\n\n"}
{"name":"IsCoatom.isProper","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝² : LE P\ninst✝¹ : IsDirected P fun x1 x2 => LE.le x1 x2\ninst✝ : Nonempty P\nI : Order.Ideal P\nhI : IsCoatom I\n⊢ I.IsProper","decl":"theorem _root_.IsCoatom.isProper (hI : IsCoatom I) : IsProper I :=\n  isProper_of_ne_top hI.1\n\n"}
{"name":"Order.Ideal.isProper_iff_ne_top","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝² : LE P\ninst✝¹ : IsDirected P fun x1 x2 => LE.le x1 x2\ninst✝ : Nonempty P\nI : Order.Ideal P\n⊢ Iff I.IsProper (Ne I Top.top)","decl":"theorem isProper_iff_ne_top : IsProper I ↔ I ≠ ⊤ :=\n  ⟨fun h ↦ h.ne_top, fun h ↦ isProper_of_ne_top h⟩\n\n"}
{"name":"Order.Ideal.IsMaximal.isCoatom","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝² : LE P\ninst✝¹ : IsDirected P fun x1 x2 => LE.le x1 x2\ninst✝ : Nonempty P\nI : Order.Ideal P\nx✝ : I.IsMaximal\n⊢ IsCoatom I","decl":"theorem IsMaximal.isCoatom (_ : IsMaximal I) : IsCoatom I :=\n  ⟨IsMaximal.toIsProper.ne_top, fun _ h ↦ ext <| IsMaximal.maximal_proper h⟩\n\n"}
{"name":"Order.Ideal.IsMaximal.isCoatom'","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝³ : LE P\ninst✝² : IsDirected P fun x1 x2 => LE.le x1 x2\ninst✝¹ : Nonempty P\nI : Order.Ideal P\ninst✝ : I.IsMaximal\n⊢ IsCoatom I","decl":"theorem IsMaximal.isCoatom' [IsMaximal I] : IsCoatom I :=\n  IsMaximal.isCoatom ‹_›\n\n"}
{"name":"IsCoatom.isMaximal","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝² : LE P\ninst✝¹ : IsDirected P fun x1 x2 => LE.le x1 x2\ninst✝ : Nonempty P\nI : Order.Ideal P\nhI : IsCoatom I\n⊢ I.IsMaximal","decl":"theorem _root_.IsCoatom.isMaximal (hI : IsCoatom I) : IsMaximal I :=\n  { IsCoatom.isProper hI with maximal_proper := fun _ hJ ↦ by simp [hI.2 _ hJ] }\n\n"}
{"name":"Order.Ideal.isMaximal_iff_isCoatom","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝² : LE P\ninst✝¹ : IsDirected P fun x1 x2 => LE.le x1 x2\ninst✝ : Nonempty P\nI : Order.Ideal P\n⊢ Iff I.IsMaximal (IsCoatom I)","decl":"theorem isMaximal_iff_isCoatom : IsMaximal I ↔ IsCoatom I :=\n  ⟨fun h ↦ h.isCoatom, fun h ↦ IsCoatom.isMaximal h⟩\n\n"}
{"name":"Order.Ideal.bot_mem","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝¹ : LE P\ninst✝ : OrderBot P\ns : Order.Ideal P\n⊢ Membership.mem s Bot.bot","decl":"@[simp]\ntheorem bot_mem (s : Ideal P) : ⊥ ∈ s :=\n  s.lower bot_le s.nonempty'.some_mem\n\n"}
{"name":"Order.Ideal.top_of_top_mem","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝¹ : LE P\ninst✝ : OrderTop P\nI : Order.Ideal P\nh : Membership.mem I Top.top\n⊢ Eq I Top.top","decl":"theorem top_of_top_mem (h : ⊤ ∈ I) : I = ⊤ := by\n  ext\n  exact iff_of_true (I.lower le_top h) trivial\n\n"}
{"name":"Order.Ideal.IsProper.top_not_mem","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝¹ : LE P\ninst✝ : OrderTop P\nI : Order.Ideal P\nhI : I.IsProper\n⊢ Not (Membership.mem I Top.top)","decl":"theorem IsProper.top_not_mem (hI : IsProper I) : ⊤ ∉ I := fun h ↦ hI.ne_top <| top_of_top_mem h\n\n"}
{"name":"Order.Ideal.principal_toLowerSet","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : Preorder P\np : P\n⊢ Eq (Order.Ideal.principal p).toLowerSet (LowerSet.Iic p)","decl":"/-- The smallest ideal containing a given element. -/\n@[simps]\ndef principal (p : P) : Ideal P where\n  toLowerSet := LowerSet.Iic p\n  nonempty' := nonempty_Iic\n  directed' _ hx _ hy := ⟨p, le_rfl, hx, hy⟩\n\n"}
{"name":"Order.Ideal.principal_le_iff","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nI : Order.Ideal P\nx : P\n⊢ Iff (LE.le (Order.Ideal.principal x) I) (Membership.mem I x)","decl":"@[simp]\ntheorem principal_le_iff : principal x ≤ I ↔ x ∈ I :=\n  ⟨fun h ↦ h le_rfl, fun hx _ hy ↦ I.lower hy hx⟩\n\n"}
{"name":"Order.Ideal.mem_principal","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nx y : P\n⊢ Iff (Membership.mem (Order.Ideal.principal y) x) (LE.le x y)","decl":"@[simp]\ntheorem mem_principal : x ∈ principal y ↔ x ≤ y :=\n  Iff.rfl\n\n"}
{"name":"Order.Ideal.mem_principal_self","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nx : P\n⊢ Membership.mem (Order.Ideal.principal x) x","decl":"lemma mem_principal_self : x ∈ principal x :=\n  mem_principal.2 (le_refl x)\n\n"}
{"name":"Order.Ideal.principal_bot","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝¹ : Preorder P\ninst✝ : OrderBot P\n⊢ Eq (Order.Ideal.principal Bot.bot) Bot.bot","decl":"@[simp]\ntheorem principal_bot : principal (⊥ : P) = ⊥ :=\n  rfl\n\n"}
{"name":"Order.Ideal.principal_top","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝¹ : Preorder P\ninst✝ : OrderTop P\n⊢ Eq (Order.Ideal.principal Top.top) Top.top","decl":"@[simp]\ntheorem principal_top : principal (⊤ : P) = ⊤ :=\n  toLowerSet_injective <| LowerSet.Iic_top\n\n"}
{"name":"Order.Ideal.sup_mem","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : SemilatticeSup P\nx y : P\ns : Order.Ideal P\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ Membership.mem s (Max.max x y)","decl":"/-- A specific witness of `I.directed` when `P` has joins. -/\ntheorem sup_mem (hx : x ∈ s) (hy : y ∈ s) : x ⊔ y ∈ s :=\n  let ⟨_, hz, hx, hy⟩ := s.directed x hx y hy\n  s.lower (sup_le hx hy) hz\n\n"}
{"name":"Order.Ideal.sup_mem_iff","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : SemilatticeSup P\nx y : P\nI : Order.Ideal P\n⊢ Iff (Membership.mem I (Max.max x y)) (And (Membership.mem I x) (Membership.mem I y))","decl":"@[simp]\ntheorem sup_mem_iff : x ⊔ y ∈ I ↔ x ∈ I ∧ y ∈ I :=\n  ⟨fun h ↦ ⟨I.lower le_sup_left h, I.lower le_sup_right h⟩, fun h ↦ sup_mem h.1 h.2⟩\n\n"}
{"name":"Order.Ideal.coe_sup","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝¹ : SemilatticeSup P\ninst✝ : IsDirected P fun x1 x2 => GE.ge x1 x2\ns t : Order.Ideal P\n⊢ Eq (↑(Max.max s t)) (setOf fun x => Exists fun a => And (Membership.mem s a) (Exists fun b => And (Membership.mem t b) (LE.le x (Max.max a b))))","decl":"@[simp]\ntheorem coe_sup : ↑(s ⊔ t) = { x | ∃ a ∈ s, ∃ b ∈ t, x ≤ a ⊔ b } :=\n  rfl\n\n-- Porting note: Modified `s ∩ t` to `↑s ∩ ↑t`.\n"}
{"name":"Order.Ideal.coe_inf","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝¹ : SemilatticeSup P\ninst✝ : IsDirected P fun x1 x2 => GE.ge x1 x2\ns t : Order.Ideal P\n⊢ Eq (↑(Min.min s t)) (Inter.inter ↑s ↑t)","decl":"@[simp]\ntheorem coe_inf : (↑(s ⊓ t) : Set P) = ↑s ∩ ↑t :=\n  rfl\n\n"}
{"name":"Order.Ideal.mem_inf","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝¹ : SemilatticeSup P\ninst✝ : IsDirected P fun x1 x2 => GE.ge x1 x2\nx : P\nI J : Order.Ideal P\n⊢ Iff (Membership.mem (Min.min I J) x) (And (Membership.mem I x) (Membership.mem J x))","decl":"@[simp]\ntheorem mem_inf : x ∈ I ⊓ J ↔ x ∈ I ∧ x ∈ J :=\n  Iff.rfl\n\n"}
{"name":"Order.Ideal.mem_sup","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝¹ : SemilatticeSup P\ninst✝ : IsDirected P fun x1 x2 => GE.ge x1 x2\nx : P\nI J : Order.Ideal P\n⊢ Iff (Membership.mem (Max.max I J) x) (Exists fun i => And (Membership.mem I i) (Exists fun j => And (Membership.mem J j) (LE.le x (Max.max i j))))","decl":"@[simp]\ntheorem mem_sup : x ∈ I ⊔ J ↔ ∃ i ∈ I, ∃ j ∈ J, x ≤ i ⊔ j :=\n  Iff.rfl\n\n"}
{"name":"Order.Ideal.lt_sup_principal_of_not_mem","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝¹ : SemilatticeSup P\ninst✝ : IsDirected P fun x1 x2 => GE.ge x1 x2\nx : P\nI : Order.Ideal P\nhx : Not (Membership.mem I x)\n⊢ LT.lt I (Max.max I (Order.Ideal.principal x))","decl":"theorem lt_sup_principal_of_not_mem (hx : x ∉ I) : I < I ⊔ principal x :=\n  le_sup_left.lt_of_ne fun h ↦ hx <| by simpa only [left_eq_sup, principal_le_iff] using h\n\n"}
{"name":"Order.Ideal.coe_sInf","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝¹ : SemilatticeSup P\ninst✝ : OrderBot P\nS : Set (Order.Ideal P)\n⊢ Eq (↑(InfSet.sInf S)) (Set.iInter fun s => Set.iInter fun h => ↑s)","decl":"@[simp]\ntheorem coe_sInf : (↑(sInf S) : Set P) = ⋂ s ∈ S, ↑s :=\n  LowerSet.coe_iInf₂ _\n\n"}
{"name":"Order.Ideal.mem_sInf","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝¹ : SemilatticeSup P\ninst✝ : OrderBot P\nx : P\nS : Set (Order.Ideal P)\n⊢ Iff (Membership.mem (InfSet.sInf S) x) (∀ (s : Order.Ideal P), Membership.mem S s → Membership.mem s x)","decl":"@[simp]\ntheorem mem_sInf : x ∈ sInf S ↔ ∀ s ∈ S, x ∈ s := by\n  simp_rw [← SetLike.mem_coe, coe_sInf, mem_iInter₂]\n\n"}
{"name":"Order.Ideal.eq_sup_of_le_sup","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : DistribLattice P\nI J : Order.Ideal P\nx i j : P\nhi : Membership.mem I i\nhj : Membership.mem J j\nhx : LE.le x (Max.max i j)\n⊢ Exists fun i' => And (Membership.mem I i') (Exists fun j' => And (Membership.mem J j') (Eq x (Max.max i' j')))","decl":"theorem eq_sup_of_le_sup {x i j : P} (hi : i ∈ I) (hj : j ∈ J) (hx : x ≤ i ⊔ j) :\n    ∃ i' ∈ I, ∃ j' ∈ J, x = i' ⊔ j' := by\n  refine ⟨x ⊓ i, I.lower inf_le_right hi, x ⊓ j, J.lower inf_le_right hj, ?_⟩\n  calc\n    x = x ⊓ (i ⊔ j) := left_eq_inf.mpr hx\n    _ = x ⊓ i ⊔ x ⊓ j := inf_sup_left _ _ _\n\n"}
{"name":"Order.Ideal.coe_sup_eq","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : DistribLattice P\nI J : Order.Ideal P\n⊢ Eq (↑(Max.max I J)) (setOf fun x => Exists fun i => And (Membership.mem I i) (Exists fun j => And (Membership.mem J j) (Eq x (Max.max i j))))","decl":"theorem coe_sup_eq : ↑(I ⊔ J) = { x | ∃ i ∈ I, ∃ j ∈ J, x = i ⊔ j } :=\n  Set.ext fun _ ↦\n    ⟨fun ⟨_, _, _, _, _⟩ ↦ eq_sup_of_le_sup ‹_› ‹_› ‹_›, fun ⟨i, _, j, _, _⟩ ↦\n      ⟨i, ‹_›, j, ‹_›, le_of_eq ‹_›⟩⟩\n\n"}
{"name":"Order.Ideal.IsProper.not_mem_of_compl_mem","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : BooleanAlgebra P\nx : P\nI : Order.Ideal P\nhI : I.IsProper\nhxc : Membership.mem I (HasCompl.compl x)\n⊢ Not (Membership.mem I x)","decl":"theorem IsProper.not_mem_of_compl_mem (hI : IsProper I) (hxc : xᶜ ∈ I) : x ∉ I := by\n  intro hx\n  apply hI.top_not_mem\n  have ht : x ⊔ xᶜ ∈ I := sup_mem ‹_› ‹_›\n  rwa [sup_compl_eq_top] at ht\n\n"}
{"name":"Order.Ideal.IsProper.not_mem_or_compl_not_mem","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : BooleanAlgebra P\nx : P\nI : Order.Ideal P\nhI : I.IsProper\n⊢ Or (Not (Membership.mem I x)) (Not (Membership.mem I (HasCompl.compl x)))","decl":"theorem IsProper.not_mem_or_compl_not_mem (hI : IsProper I) : x ∉ I ∨ xᶜ ∉ I := by\n  have h : xᶜ ∈ I → x ∉ I := hI.not_mem_of_compl_mem\n  tauto\n\n"}
{"name":"Order.Cofinal.mk.injEq","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst✝ : Preorder P\ncarrier✝ : Set P\nisCofinal✝ : IsCofinal carrier✝\ncarrier : Set P\nisCofinal : IsCofinal carrier\n⊢ Eq (Eq { carrier := carrier✝, isCofinal := isCofinal✝ } { carrier := carrier, isCofinal := isCofinal }) (Eq carrier✝ carrier)","decl":"/-- For a preorder `P`, `Cofinal P` is the type of subsets of `P`\n  containing arbitrarily large elements. They are the dense sets in\n  the topology whose open sets are terminal segments. -/\nstructure Cofinal (P) [Preorder P] where\n  /-- The carrier of a `Cofinal` is the underlying set. -/\n  carrier : Set P\n  /-- The `Cofinal` contains arbitrarily large elements. -/\n  isCofinal : IsCofinal carrier\n\n"}
{"name":"Order.Cofinal.mk.sizeOf_spec","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst✝¹ : Preorder P\ninst✝ : SizeOf P\ncarrier : Set P\nisCofinal : IsCofinal carrier\n⊢ Eq (SizeOf.sizeOf { carrier := carrier, isCofinal := isCofinal }) 1","decl":"/-- For a preorder `P`, `Cofinal P` is the type of subsets of `P`\n  containing arbitrarily large elements. They are the dense sets in\n  the topology whose open sets are terminal segments. -/\nstructure Cofinal (P) [Preorder P] where\n  /-- The carrier of a `Cofinal` is the underlying set. -/\n  carrier : Set P\n  /-- The `Cofinal` contains arbitrarily large elements. -/\n  isCofinal : IsCofinal carrier\n\n"}
{"name":"Order.Cofinal.mk.inj","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst✝ : Preorder P\ncarrier✝ : Set P\nisCofinal✝ : IsCofinal carrier✝\ncarrier : Set P\nisCofinal : IsCofinal carrier\nx✝ : Eq { carrier := carrier✝, isCofinal := isCofinal✝ } { carrier := carrier, isCofinal := isCofinal }\n⊢ Eq carrier✝ carrier","decl":"/-- For a preorder `P`, `Cofinal P` is the type of subsets of `P`\n  containing arbitrarily large elements. They are the dense sets in\n  the topology whose open sets are terminal segments. -/\nstructure Cofinal (P) [Preorder P] where\n  /-- The carrier of a `Cofinal` is the underlying set. -/\n  carrier : Set P\n  /-- The `Cofinal` contains arbitrarily large elements. -/\n  isCofinal : IsCofinal carrier\n\n"}
{"name":"Order.Cofinal.isCofinal","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst✝ : Preorder P\nself : Order.Cofinal P\n⊢ IsCofinal self.carrier","decl":"/-- For a preorder `P`, `Cofinal P` is the type of subsets of `P`\n  containing arbitrarily large elements. They are the dense sets in\n  the topology whose open sets are terminal segments. -/\nstructure Cofinal (P) [Preorder P] where\n  /-- The carrier of a `Cofinal` is the underlying set. -/\n  carrier : Set P\n  /-- The `Cofinal` contains arbitrarily large elements. -/\n  isCofinal : IsCofinal carrier\n\n"}
{"name":"Order.Cofinal.mem_gt","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst✝ : Preorder P\nself : Order.Cofinal P\n⊢ IsCofinal self.carrier","decl":"@[deprecated Cofinal.isCofinal (since := \"2024-12-02\")]\nalias Cofinal.mem_gt := Cofinal.isCofinal\n\n"}
{"name":"Order.Cofinal.above_mem","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nD : Order.Cofinal P\nx : P\n⊢ Membership.mem D (D.above x)","decl":"theorem above_mem : D.above x ∈ D :=\n  (Classical.choose_spec <| D.isCofinal x).1\n\n"}
{"name":"Order.Cofinal.le_above","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nD : Order.Cofinal P\nx : P\n⊢ LE.le x (D.above x)","decl":"theorem le_above : x ≤ D.above x :=\n  (Classical.choose_spec <| D.isCofinal x).2\n\n"}
{"name":"Order.sequenceOfCofinals.monotone","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝¹ : Preorder P\np : P\nι : Type u_2\ninst✝ : Encodable ι\n𝒟 : ι → Order.Cofinal P\n⊢ Monotone (Order.sequenceOfCofinals p 𝒟)","decl":"theorem sequenceOfCofinals.monotone : Monotone (sequenceOfCofinals p 𝒟) := by\n  apply monotone_nat_of_le_succ\n  intro n\n  dsimp only [sequenceOfCofinals, Nat.add]\n  cases (Encodable.decode n : Option ι)\n  · rfl\n  · apply Cofinal.le_above\n\n"}
{"name":"Order.sequenceOfCofinals.encode_mem","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝¹ : Preorder P\np : P\nι : Type u_2\ninst✝ : Encodable ι\n𝒟 : ι → Order.Cofinal P\ni : ι\n⊢ Membership.mem (𝒟 i) (Order.sequenceOfCofinals p 𝒟 (HAdd.hAdd (Encodable.encode i) 1))","decl":"theorem sequenceOfCofinals.encode_mem (i : ι) :\n    sequenceOfCofinals p 𝒟 (Encodable.encode i + 1) ∈ 𝒟 i := by\n  dsimp only [sequenceOfCofinals, Nat.add]\n  rw [Encodable.encodek]\n  apply Cofinal.above_mem\n\n"}
{"name":"Order.mem_idealOfCofinals","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝¹ : Preorder P\np : P\nι : Type u_2\ninst✝ : Encodable ι\n𝒟 : ι → Order.Cofinal P\n⊢ Membership.mem (Order.idealOfCofinals p 𝒟) p","decl":"theorem mem_idealOfCofinals : p ∈ idealOfCofinals p 𝒟 :=\n  ⟨0, le_rfl⟩\n\n"}
{"name":"Order.cofinal_meets_idealOfCofinals","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝¹ : Preorder P\np : P\nι : Type u_2\ninst✝ : Encodable ι\n𝒟 : ι → Order.Cofinal P\ni : ι\n⊢ Exists fun x => And (Membership.mem (𝒟 i) x) (Membership.mem (Order.idealOfCofinals p 𝒟) x)","decl":"/-- `idealOfCofinals p 𝒟` is `𝒟`-generic. -/\ntheorem cofinal_meets_idealOfCofinals (i : ι) : ∃ x : P, x ∈ 𝒟 i ∧ x ∈ idealOfCofinals p 𝒟 :=\n  ⟨_, sequenceOfCofinals.encode_mem p 𝒟 i, _, le_rfl⟩\n\n"}
{"name":"Order.isIdeal_sUnion_of_directedOn","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nC : Set (Set P)\nhidl : ∀ (I : Set P), Membership.mem C I → Order.IsIdeal I\nhD : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) C\nhNe : C.Nonempty\n⊢ Order.IsIdeal C.sUnion","decl":"/-- A non-empty directed union of ideals of sets in a preorder is an ideal. -/\nlemma isIdeal_sUnion_of_directedOn {C : Set (Set P)} (hidl : ∀ I ∈ C, IsIdeal I)\n    (hD : DirectedOn (· ⊆ ·) C) (hNe : C.Nonempty) : IsIdeal C.sUnion := by\n  refine ⟨isLowerSet_sUnion (fun I hI ↦ (hidl I hI).1), Set.nonempty_sUnion.2 ?_,\n    directedOn_sUnion hD (fun J hJ => (hidl J hJ).3)⟩\n  let ⟨I, hI⟩ := hNe\n  exact ⟨I, ⟨hI, (hidl I hI).2⟩⟩\n\n"}
{"name":"Order.isIdeal_sUnion_of_isChain","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nC : Set (Set P)\nhidl : ∀ (I : Set P), Membership.mem C I → Order.IsIdeal I\nhC : IsChain (fun x1 x2 => HasSubset.Subset x1 x2) C\nhNe : C.Nonempty\n⊢ Order.IsIdeal C.sUnion","decl":"/-- A union of a nonempty chain of ideals of sets is an ideal. -/\nlemma isIdeal_sUnion_of_isChain {C : Set (Set P)} (hidl : ∀ I ∈ C, IsIdeal I)\n    (hC : IsChain (· ⊆ ·) C) (hNe : C.Nonempty) : IsIdeal C.sUnion :=\n  isIdeal_sUnion_of_directedOn hidl hC.directedOn hNe\n\n"}
