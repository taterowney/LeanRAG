{"name":"Order.Ideal.nonempty'","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst‚úù : LE P\nself : Order.Ideal P\n‚ä¢ self.carrier.Nonempty","decl":"/-- An ideal on an order `P` is a subset of `P` that is\n  - nonempty\n  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)\n  - downward closed (any element less than an element of the ideal is in the ideal). -/\nstructure Ideal (P) [LE P] extends LowerSet P where\n  /-- The ideal is nonempty. -/\n  nonempty' : carrier.Nonempty\n  /-- The ideal is upward directed. -/\n  directed' : DirectedOn (¬∑ ‚â§ ¬∑) carrier\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: remove this configuration and use the default configuration.\n-- We keep this to be consistent with Lean 3.\n"}
{"name":"Order.Ideal.mk.inj","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst‚úù : LE P\ntoLowerSet‚úù : LowerSet P\nnonempty'‚úù : toLowerSet‚úù.carrier.Nonempty\ndirected'‚úù : DirectedOn (fun x1 x2 => LE.le x1 x2) toLowerSet‚úù.carrier\ntoLowerSet : LowerSet P\nnonempty' : toLowerSet.carrier.Nonempty\ndirected' : DirectedOn (fun x1 x2 => LE.le x1 x2) toLowerSet.carrier\nx‚úù : Eq { toLowerSet := toLowerSet‚úù, nonempty' := nonempty'‚úù, directed' := directed'‚úù } { toLowerSet := toLowerSet, nonempty' := nonempty', directed' := directed' }\n‚ä¢ Eq toLowerSet‚úù toLowerSet","decl":"/-- An ideal on an order `P` is a subset of `P` that is\n  - nonempty\n  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)\n  - downward closed (any element less than an element of the ideal is in the ideal). -/\nstructure Ideal (P) [LE P] extends LowerSet P where\n  /-- The ideal is nonempty. -/\n  nonempty' : carrier.Nonempty\n  /-- The ideal is upward directed. -/\n  directed' : DirectedOn (¬∑ ‚â§ ¬∑) carrier\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: remove this configuration and use the default configuration.\n-- We keep this to be consistent with Lean 3.\n"}
{"name":"Order.Ideal.mk.sizeOf_spec","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst‚úù¬π : LE P\ninst‚úù : SizeOf P\ntoLowerSet : LowerSet P\nnonempty' : toLowerSet.carrier.Nonempty\ndirected' : DirectedOn (fun x1 x2 => LE.le x1 x2) toLowerSet.carrier\n‚ä¢ Eq (SizeOf.sizeOf { toLowerSet := toLowerSet, nonempty' := nonempty', directed' := directed' }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toLowerSet)) (SizeOf.sizeOf nonempty'))","decl":"/-- An ideal on an order `P` is a subset of `P` that is\n  - nonempty\n  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)\n  - downward closed (any element less than an element of the ideal is in the ideal). -/\nstructure Ideal (P) [LE P] extends LowerSet P where\n  /-- The ideal is nonempty. -/\n  nonempty' : carrier.Nonempty\n  /-- The ideal is upward directed. -/\n  directed' : DirectedOn (¬∑ ‚â§ ¬∑) carrier\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: remove this configuration and use the default configuration.\n-- We keep this to be consistent with Lean 3.\n"}
{"name":"Order.Ideal.mk.injEq","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst‚úù : LE P\ntoLowerSet‚úù : LowerSet P\nnonempty'‚úù : toLowerSet‚úù.carrier.Nonempty\ndirected'‚úù : DirectedOn (fun x1 x2 => LE.le x1 x2) toLowerSet‚úù.carrier\ntoLowerSet : LowerSet P\nnonempty' : toLowerSet.carrier.Nonempty\ndirected' : DirectedOn (fun x1 x2 => LE.le x1 x2) toLowerSet.carrier\n‚ä¢ Eq (Eq { toLowerSet := toLowerSet‚úù, nonempty' := nonempty'‚úù, directed' := directed'‚úù } { toLowerSet := toLowerSet, nonempty' := nonempty', directed' := directed' }) (Eq toLowerSet‚úù toLowerSet)","decl":"/-- An ideal on an order `P` is a subset of `P` that is\n  - nonempty\n  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)\n  - downward closed (any element less than an element of the ideal is in the ideal). -/\nstructure Ideal (P) [LE P] extends LowerSet P where\n  /-- The ideal is nonempty. -/\n  nonempty' : carrier.Nonempty\n  /-- The ideal is upward directed. -/\n  directed' : DirectedOn (¬∑ ‚â§ ¬∑) carrier\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: remove this configuration and use the default configuration.\n-- We keep this to be consistent with Lean 3.\n"}
{"name":"Order.Ideal.directed'","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst‚úù : LE P\nself : Order.Ideal P\n‚ä¢ DirectedOn (fun x1 x2 => LE.le x1 x2) self.carrier","decl":"/-- An ideal on an order `P` is a subset of `P` that is\n  - nonempty\n  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)\n  - downward closed (any element less than an element of the ideal is in the ideal). -/\nstructure Ideal (P) [LE P] extends LowerSet P where\n  /-- The ideal is nonempty. -/\n  nonempty' : carrier.Nonempty\n  /-- The ideal is upward directed. -/\n  directed' : DirectedOn (¬∑ ‚â§ ¬∑) carrier\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: remove this configuration and use the default configuration.\n-- We keep this to be consistent with Lean 3.\n"}
{"name":"Order.IsIdeal.IsLowerSet","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst‚úù : LE P\nI : Set P\nself : Order.IsIdeal I\n‚ä¢ IsLowerSet I","decl":"/-- A subset of a preorder `P` is an ideal if it is\n  - nonempty\n  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)\n  - downward closed (any element less than an element of the ideal is in the ideal). -/\n@[mk_iff]\nstructure IsIdeal {P} [LE P] (I : Set P) : Prop where\n  /-- The ideal is downward closed. -/\n  IsLowerSet : IsLowerSet I\n  /-- The ideal is nonempty. -/\n  Nonempty : I.Nonempty\n  /-- The ideal is upward directed. -/\n  Directed : DirectedOn (¬∑ ‚â§ ¬∑) I\n\n"}
{"name":"Order.IsIdeal.Directed","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst‚úù : LE P\nI : Set P\nself : Order.IsIdeal I\n‚ä¢ DirectedOn (fun x1 x2 => LE.le x1 x2) I","decl":"/-- A subset of a preorder `P` is an ideal if it is\n  - nonempty\n  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)\n  - downward closed (any element less than an element of the ideal is in the ideal). -/\n@[mk_iff]\nstructure IsIdeal {P} [LE P] (I : Set P) : Prop where\n  /-- The ideal is downward closed. -/\n  IsLowerSet : IsLowerSet I\n  /-- The ideal is nonempty. -/\n  Nonempty : I.Nonempty\n  /-- The ideal is upward directed. -/\n  Directed : DirectedOn (¬∑ ‚â§ ¬∑) I\n\n"}
{"name":"Order.IsIdeal.Nonempty","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst‚úù : LE P\nI : Set P\nself : Order.IsIdeal I\n‚ä¢ I.Nonempty","decl":"/-- A subset of a preorder `P` is an ideal if it is\n  - nonempty\n  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)\n  - downward closed (any element less than an element of the ideal is in the ideal). -/\n@[mk_iff]\nstructure IsIdeal {P} [LE P] (I : Set P) : Prop where\n  /-- The ideal is downward closed. -/\n  IsLowerSet : IsLowerSet I\n  /-- The ideal is nonempty. -/\n  Nonempty : I.Nonempty\n  /-- The ideal is upward directed. -/\n  Directed : DirectedOn (¬∑ ‚â§ ¬∑) I\n\n"}
{"name":"Order.isIdeal_iff","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst‚úù : LE P\nI : Set P\n‚ä¢ Iff (Order.IsIdeal I) (And (IsLowerSet I) (And I.Nonempty (DirectedOn (fun x1 x2 => LE.le x1 x2) I)))","decl":"/-- A subset of a preorder `P` is an ideal if it is\n  - nonempty\n  - upward directed (any pair of elements in the ideal has an upper bound in the ideal)\n  - downward closed (any element less than an element of the ideal is in the ideal). -/\n@[mk_iff]\nstructure IsIdeal {P} [LE P] (I : Set P) : Prop where\n  /-- The ideal is downward closed. -/\n  IsLowerSet : IsLowerSet I\n  /-- The ideal is nonempty. -/\n  Nonempty : I.Nonempty\n  /-- The ideal is upward directed. -/\n  Directed : DirectedOn (¬∑ ‚â§ ¬∑) I\n\n"}
{"name":"Order.Ideal.toLowerSet_injective","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : LE P\n‚ä¢ Function.Injective Order.Ideal.toLowerSet","decl":"theorem toLowerSet_injective : Injective (toLowerSet : Ideal P ‚Üí LowerSet P) := fun s t _ ‚Ü¶ by\n  cases s\n  cases t\n  congr\n\n"}
{"name":"Order.Ideal.ext","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : LE P\ns t : Order.Ideal P\na‚úù : Eq ‚Üës ‚Üët\n‚ä¢ Eq s t","decl":"@[ext]\ntheorem ext {s t : Ideal P} : (s : Set P) = t ‚Üí s = t :=\n  SetLike.ext'\n\n"}
{"name":"Order.Ideal.ext_iff","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : LE P\ns t : Order.Ideal P\n‚ä¢ Iff (Eq s t) (Eq ‚Üës ‚Üët)","decl":"@[ext]\ntheorem ext {s t : Ideal P} : (s : Set P) = t ‚Üí s = t :=\n  SetLike.ext'\n\n"}
{"name":"Order.Ideal.carrier_eq_coe","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : LE P\ns : Order.Ideal P\n‚ä¢ Eq s.carrier ‚Üës","decl":"@[simp]\ntheorem carrier_eq_coe (s : Ideal P) : s.carrier = s :=\n  rfl\n\n"}
{"name":"Order.Ideal.coe_toLowerSet","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : LE P\ns : Order.Ideal P\n‚ä¢ Eq ‚Üës.toLowerSet ‚Üës","decl":"@[simp]\ntheorem coe_toLowerSet (s : Ideal P) : (s.toLowerSet : Set P) = s :=\n  rfl\n\n"}
{"name":"Order.Ideal.lower","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : LE P\ns : Order.Ideal P\n‚ä¢ IsLowerSet ‚Üës","decl":"protected theorem lower (s : Ideal P) : IsLowerSet (s : Set P) :=\n  s.lower'\n\n"}
{"name":"Order.Ideal.nonempty","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : LE P\ns : Order.Ideal P\n‚ä¢ (‚Üës).Nonempty","decl":"protected theorem nonempty (s : Ideal P) : (s : Set P).Nonempty :=\n  s.nonempty'\n\n"}
{"name":"Order.Ideal.directed","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : LE P\ns : Order.Ideal P\n‚ä¢ DirectedOn (fun x1 x2 => LE.le x1 x2) ‚Üës","decl":"protected theorem directed (s : Ideal P) : DirectedOn (¬∑ ‚â§ ¬∑) (s : Set P) :=\n  s.directed'\n\n"}
{"name":"Order.Ideal.isIdeal","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : LE P\ns : Order.Ideal P\n‚ä¢ Order.IsIdeal ‚Üës","decl":"protected theorem isIdeal (s : Ideal P) : IsIdeal (s : Set P) :=\n  ‚ü®s.lower, s.nonempty, s.directed‚ü©\n\n"}
{"name":"Order.Ideal.mem_compl_of_ge","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : LE P\nI : Order.Ideal P\nx y : P\na‚úù¬π : LE.le x y\na‚úù : Membership.mem (HasCompl.compl ‚ÜëI) x\n‚ä¢ Membership.mem (HasCompl.compl ‚ÜëI) y","decl":"theorem mem_compl_of_ge {x y : P} : x ‚â§ y ‚Üí x ‚àà (I : Set P)·∂ú ‚Üí y ‚àà (I : Set P)·∂ú := fun h ‚Ü¶\n  mt <| I.lower h\n\n"}
{"name":"Order.Ideal.coe_subset_coe","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : LE P\ns t : Order.Ideal P\n‚ä¢ Iff (HasSubset.Subset ‚Üës ‚Üët) (LE.le s t)","decl":"theorem coe_subset_coe : (s : Set P) ‚äÜ t ‚Üî s ‚â§ t :=\n  Iff.rfl\n\n"}
{"name":"Order.Ideal.coe_ssubset_coe","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : LE P\ns t : Order.Ideal P\n‚ä¢ Iff (HasSSubset.SSubset ‚Üës ‚Üët) (LT.lt s t)","decl":"theorem coe_ssubset_coe : (s : Set P) ‚äÇ t ‚Üî s < t :=\n  Iff.rfl\n\n"}
{"name":"Order.Ideal.mem_of_mem_of_le","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : LE P\nx : P\nI J : Order.Ideal P\na‚úù¬π : Membership.mem I x\na‚úù : LE.le I J\n‚ä¢ Membership.mem J x","decl":"@[trans]\ntheorem mem_of_mem_of_le {x : P} {I J : Ideal P} : x ‚àà I ‚Üí I ‚â§ J ‚Üí x ‚àà J :=\n  @Set.mem_of_mem_of_subset P x I J\n\n"}
{"name":"Order.Ideal.isProper_iff","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : LE P\nI : Order.Ideal P\n‚ä¢ Iff I.IsProper (Ne (‚ÜëI) Set.univ)","decl":"/-- A proper ideal is one that is not the whole set.\n    Note that the whole set might not be an ideal. -/\n@[mk_iff]\nclass IsProper (I : Ideal P) : Prop where\n  /-- This ideal is not the whole set. -/\n  ne_univ : (I : Set P) ‚â† univ\n\n"}
{"name":"Order.Ideal.IsProper.ne_univ","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : LE P\nI : Order.Ideal P\nself : I.IsProper\n‚ä¢ Ne (‚ÜëI) Set.univ","decl":"/-- A proper ideal is one that is not the whole set.\n    Note that the whole set might not be an ideal. -/\n@[mk_iff]\nclass IsProper (I : Ideal P) : Prop where\n  /-- This ideal is not the whole set. -/\n  ne_univ : (I : Set P) ‚â† univ\n\n"}
{"name":"Order.Ideal.isProper_of_not_mem","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : LE P\nI : Order.Ideal P\np : P\nnmem : Not (Membership.mem I p)\n‚ä¢ I.IsProper","decl":"theorem isProper_of_not_mem {I : Ideal P} {p : P} (nmem : p ‚àâ I) : IsProper I :=\n  ‚ü®fun hp ‚Ü¶ by\n    have := mem_univ p\n    rw [‚Üê hp] at this\n    exact nmem this‚ü©\n\n"}
{"name":"Order.Ideal.IsMaximal.toIsProper","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : LE P\nI : Order.Ideal P\nself : I.IsMaximal\n‚ä¢ I.IsProper","decl":"/-- An ideal is maximal if it is maximal in the collection of proper ideals.\n\nNote that `IsCoatom` is less general because ideals only have a top element when `P` is directed\nand nonempty. -/\n@[mk_iff]\nclass IsMaximal (I : Ideal P) extends IsProper I : Prop where\n  /-- This ideal is maximal in the collection of proper ideals. -/\n  maximal_proper : ‚àÄ ‚¶ÉJ : Ideal P‚¶Ñ, I < J ‚Üí (J : Set P) = univ\n\n"}
{"name":"Order.Ideal.isMaximal_iff","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : LE P\nI : Order.Ideal P\n‚ä¢ Iff I.IsMaximal (And I.IsProper (‚àÄ ‚¶ÉJ : Order.Ideal P‚¶Ñ, LT.lt I J ‚Üí Eq (‚ÜëJ) Set.univ))","decl":"/-- An ideal is maximal if it is maximal in the collection of proper ideals.\n\nNote that `IsCoatom` is less general because ideals only have a top element when `P` is directed\nand nonempty. -/\n@[mk_iff]\nclass IsMaximal (I : Ideal P) extends IsProper I : Prop where\n  /-- This ideal is maximal in the collection of proper ideals. -/\n  maximal_proper : ‚àÄ ‚¶ÉJ : Ideal P‚¶Ñ, I < J ‚Üí (J : Set P) = univ\n\n"}
{"name":"Order.Ideal.IsMaximal.maximal_proper","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : LE P\nI : Order.Ideal P\nself : I.IsMaximal\nJ : Order.Ideal P\na‚úù : LT.lt I J\n‚ä¢ Eq (‚ÜëJ) Set.univ","decl":"/-- An ideal is maximal if it is maximal in the collection of proper ideals.\n\nNote that `IsCoatom` is less general because ideals only have a top element when `P` is directed\nand nonempty. -/\n@[mk_iff]\nclass IsMaximal (I : Ideal P) extends IsProper I : Prop where\n  /-- This ideal is maximal in the collection of proper ideals. -/\n  maximal_proper : ‚àÄ ‚¶ÉJ : Ideal P‚¶Ñ, I < J ‚Üí (J : Set P) = univ\n\n"}
{"name":"Order.Ideal.inter_nonempty","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬π : LE P\ninst‚úù : IsDirected P fun x1 x2 => GE.ge x1 x2\nI J : Order.Ideal P\n‚ä¢ (Inter.inter ‚ÜëI ‚ÜëJ).Nonempty","decl":"theorem inter_nonempty [IsDirected P (¬∑ ‚â• ¬∑)] (I J : Ideal P) : (I ‚à© J : Set P).Nonempty := by\n  obtain ‚ü®a, ha‚ü© := I.nonempty\n  obtain ‚ü®b, hb‚ü© := J.nonempty\n  obtain ‚ü®c, hac, hbc‚ü© := exists_le_le a b\n  exact ‚ü®c, I.lower hac ha, J.lower hbc hb‚ü©\n\n"}
{"name":"Order.Ideal.top_toLowerSet","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬≤ : LE P\ninst‚úù¬π : IsDirected P fun x1 x2 => LE.le x1 x2\ninst‚úù : Nonempty P\n‚ä¢ Eq Top.top.toLowerSet Top.top","decl":"@[simp]\ntheorem top_toLowerSet : (‚ä§ : Ideal P).toLowerSet = ‚ä§ :=\n  rfl\n\n"}
{"name":"Order.Ideal.coe_top","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬≤ : LE P\ninst‚úù¬π : IsDirected P fun x1 x2 => LE.le x1 x2\ninst‚úù : Nonempty P\n‚ä¢ Eq (‚ÜëTop.top) Set.univ","decl":"@[simp]\ntheorem coe_top : ((‚ä§ : Ideal P) : Set P) = univ :=\n  rfl\n\n"}
{"name":"Order.Ideal.isProper_of_ne_top","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬≤ : LE P\ninst‚úù¬π : IsDirected P fun x1 x2 => LE.le x1 x2\ninst‚úù : Nonempty P\nI : Order.Ideal P\nne_top : Ne I Top.top\n‚ä¢ I.IsProper","decl":"theorem isProper_of_ne_top (ne_top : I ‚â† ‚ä§) : IsProper I :=\n  ‚ü®fun h ‚Ü¶ ne_top <| ext h‚ü©\n\n"}
{"name":"Order.Ideal.IsProper.ne_top","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬≤ : LE P\ninst‚úù¬π : IsDirected P fun x1 x2 => LE.le x1 x2\ninst‚úù : Nonempty P\nI : Order.Ideal P\nx‚úù : I.IsProper\n‚ä¢ Ne I Top.top","decl":"theorem IsProper.ne_top (_ : IsProper I) : I ‚â† ‚ä§ :=\n  fun h ‚Ü¶ IsProper.ne_univ <| congr_arg SetLike.coe h\n\n"}
{"name":"IsCoatom.isProper","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬≤ : LE P\ninst‚úù¬π : IsDirected P fun x1 x2 => LE.le x1 x2\ninst‚úù : Nonempty P\nI : Order.Ideal P\nhI : IsCoatom I\n‚ä¢ I.IsProper","decl":"theorem _root_.IsCoatom.isProper (hI : IsCoatom I) : IsProper I :=\n  isProper_of_ne_top hI.1\n\n"}
{"name":"Order.Ideal.isProper_iff_ne_top","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬≤ : LE P\ninst‚úù¬π : IsDirected P fun x1 x2 => LE.le x1 x2\ninst‚úù : Nonempty P\nI : Order.Ideal P\n‚ä¢ Iff I.IsProper (Ne I Top.top)","decl":"theorem isProper_iff_ne_top : IsProper I ‚Üî I ‚â† ‚ä§ :=\n  ‚ü®fun h ‚Ü¶ h.ne_top, fun h ‚Ü¶ isProper_of_ne_top h‚ü©\n\n"}
{"name":"Order.Ideal.IsMaximal.isCoatom","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬≤ : LE P\ninst‚úù¬π : IsDirected P fun x1 x2 => LE.le x1 x2\ninst‚úù : Nonempty P\nI : Order.Ideal P\nx‚úù : I.IsMaximal\n‚ä¢ IsCoatom I","decl":"theorem IsMaximal.isCoatom (_ : IsMaximal I) : IsCoatom I :=\n  ‚ü®IsMaximal.toIsProper.ne_top, fun _ h ‚Ü¶ ext <| IsMaximal.maximal_proper h‚ü©\n\n"}
{"name":"Order.Ideal.IsMaximal.isCoatom'","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬≥ : LE P\ninst‚úù¬≤ : IsDirected P fun x1 x2 => LE.le x1 x2\ninst‚úù¬π : Nonempty P\nI : Order.Ideal P\ninst‚úù : I.IsMaximal\n‚ä¢ IsCoatom I","decl":"theorem IsMaximal.isCoatom' [IsMaximal I] : IsCoatom I :=\n  IsMaximal.isCoatom ‚Äπ_‚Ä∫\n\n"}
{"name":"IsCoatom.isMaximal","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬≤ : LE P\ninst‚úù¬π : IsDirected P fun x1 x2 => LE.le x1 x2\ninst‚úù : Nonempty P\nI : Order.Ideal P\nhI : IsCoatom I\n‚ä¢ I.IsMaximal","decl":"theorem _root_.IsCoatom.isMaximal (hI : IsCoatom I) : IsMaximal I :=\n  { IsCoatom.isProper hI with maximal_proper := fun _ hJ ‚Ü¶ by simp [hI.2 _ hJ] }\n\n"}
{"name":"Order.Ideal.isMaximal_iff_isCoatom","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬≤ : LE P\ninst‚úù¬π : IsDirected P fun x1 x2 => LE.le x1 x2\ninst‚úù : Nonempty P\nI : Order.Ideal P\n‚ä¢ Iff I.IsMaximal (IsCoatom I)","decl":"theorem isMaximal_iff_isCoatom : IsMaximal I ‚Üî IsCoatom I :=\n  ‚ü®fun h ‚Ü¶ h.isCoatom, fun h ‚Ü¶ IsCoatom.isMaximal h‚ü©\n\n"}
{"name":"Order.Ideal.bot_mem","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬π : LE P\ninst‚úù : OrderBot P\ns : Order.Ideal P\n‚ä¢ Membership.mem s Bot.bot","decl":"@[simp]\ntheorem bot_mem (s : Ideal P) : ‚ä• ‚àà s :=\n  s.lower bot_le s.nonempty'.some_mem\n\n"}
{"name":"Order.Ideal.top_of_top_mem","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬π : LE P\ninst‚úù : OrderTop P\nI : Order.Ideal P\nh : Membership.mem I Top.top\n‚ä¢ Eq I Top.top","decl":"theorem top_of_top_mem (h : ‚ä§ ‚àà I) : I = ‚ä§ := by\n  ext\n  exact iff_of_true (I.lower le_top h) trivial\n\n"}
{"name":"Order.Ideal.IsProper.top_not_mem","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬π : LE P\ninst‚úù : OrderTop P\nI : Order.Ideal P\nhI : I.IsProper\n‚ä¢ Not (Membership.mem I Top.top)","decl":"theorem IsProper.top_not_mem (hI : IsProper I) : ‚ä§ ‚àâ I := fun h ‚Ü¶ hI.ne_top <| top_of_top_mem h\n\n"}
{"name":"Order.Ideal.principal_toLowerSet","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : Preorder P\np : P\n‚ä¢ Eq (Order.Ideal.principal p).toLowerSet (LowerSet.Iic p)","decl":"/-- The smallest ideal containing a given element. -/\n@[simps]\ndef principal (p : P) : Ideal P where\n  toLowerSet := LowerSet.Iic p\n  nonempty' := nonempty_Iic\n  directed' _ hx _ hy := ‚ü®p, le_rfl, hx, hy‚ü©\n\n"}
{"name":"Order.Ideal.principal_le_iff","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : Preorder P\nI : Order.Ideal P\nx : P\n‚ä¢ Iff (LE.le (Order.Ideal.principal x) I) (Membership.mem I x)","decl":"@[simp]\ntheorem principal_le_iff : principal x ‚â§ I ‚Üî x ‚àà I :=\n  ‚ü®fun h ‚Ü¶ h le_rfl, fun hx _ hy ‚Ü¶ I.lower hy hx‚ü©\n\n"}
{"name":"Order.Ideal.mem_principal","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : Preorder P\nx y : P\n‚ä¢ Iff (Membership.mem (Order.Ideal.principal y) x) (LE.le x y)","decl":"@[simp]\ntheorem mem_principal : x ‚àà principal y ‚Üî x ‚â§ y :=\n  Iff.rfl\n\n"}
{"name":"Order.Ideal.mem_principal_self","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : Preorder P\nx : P\n‚ä¢ Membership.mem (Order.Ideal.principal x) x","decl":"lemma mem_principal_self : x ‚àà principal x :=\n  mem_principal.2 (le_refl x)\n\n"}
{"name":"Order.Ideal.principal_bot","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬π : Preorder P\ninst‚úù : OrderBot P\n‚ä¢ Eq (Order.Ideal.principal Bot.bot) Bot.bot","decl":"@[simp]\ntheorem principal_bot : principal (‚ä• : P) = ‚ä• :=\n  rfl\n\n"}
{"name":"Order.Ideal.principal_top","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬π : Preorder P\ninst‚úù : OrderTop P\n‚ä¢ Eq (Order.Ideal.principal Top.top) Top.top","decl":"@[simp]\ntheorem principal_top : principal (‚ä§ : P) = ‚ä§ :=\n  toLowerSet_injective <| LowerSet.Iic_top\n\n"}
{"name":"Order.Ideal.sup_mem","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : SemilatticeSup P\nx y : P\ns : Order.Ideal P\nhx : Membership.mem s x\nhy : Membership.mem s y\n‚ä¢ Membership.mem s (Max.max x y)","decl":"/-- A specific witness of `I.directed` when `P` has joins. -/\ntheorem sup_mem (hx : x ‚àà s) (hy : y ‚àà s) : x ‚äî y ‚àà s :=\n  let ‚ü®_, hz, hx, hy‚ü© := s.directed x hx y hy\n  s.lower (sup_le hx hy) hz\n\n"}
{"name":"Order.Ideal.sup_mem_iff","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : SemilatticeSup P\nx y : P\nI : Order.Ideal P\n‚ä¢ Iff (Membership.mem I (Max.max x y)) (And (Membership.mem I x) (Membership.mem I y))","decl":"@[simp]\ntheorem sup_mem_iff : x ‚äî y ‚àà I ‚Üî x ‚àà I ‚àß y ‚àà I :=\n  ‚ü®fun h ‚Ü¶ ‚ü®I.lower le_sup_left h, I.lower le_sup_right h‚ü©, fun h ‚Ü¶ sup_mem h.1 h.2‚ü©\n\n"}
{"name":"Order.Ideal.coe_sup","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬π : SemilatticeSup P\ninst‚úù : IsDirected P fun x1 x2 => GE.ge x1 x2\ns t : Order.Ideal P\n‚ä¢ Eq (‚Üë(Max.max s t)) (setOf fun x => Exists fun a => And (Membership.mem s a) (Exists fun b => And (Membership.mem t b) (LE.le x (Max.max a b))))","decl":"@[simp]\ntheorem coe_sup : ‚Üë(s ‚äî t) = { x | ‚àÉ a ‚àà s, ‚àÉ b ‚àà t, x ‚â§ a ‚äî b } :=\n  rfl\n\n-- Porting note: Modified `s ‚à© t` to `‚Üës ‚à© ‚Üët`.\n"}
{"name":"Order.Ideal.coe_inf","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬π : SemilatticeSup P\ninst‚úù : IsDirected P fun x1 x2 => GE.ge x1 x2\ns t : Order.Ideal P\n‚ä¢ Eq (‚Üë(Min.min s t)) (Inter.inter ‚Üës ‚Üët)","decl":"@[simp]\ntheorem coe_inf : (‚Üë(s ‚äì t) : Set P) = ‚Üës ‚à© ‚Üët :=\n  rfl\n\n"}
{"name":"Order.Ideal.mem_inf","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬π : SemilatticeSup P\ninst‚úù : IsDirected P fun x1 x2 => GE.ge x1 x2\nx : P\nI J : Order.Ideal P\n‚ä¢ Iff (Membership.mem (Min.min I J) x) (And (Membership.mem I x) (Membership.mem J x))","decl":"@[simp]\ntheorem mem_inf : x ‚àà I ‚äì J ‚Üî x ‚àà I ‚àß x ‚àà J :=\n  Iff.rfl\n\n"}
{"name":"Order.Ideal.mem_sup","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬π : SemilatticeSup P\ninst‚úù : IsDirected P fun x1 x2 => GE.ge x1 x2\nx : P\nI J : Order.Ideal P\n‚ä¢ Iff (Membership.mem (Max.max I J) x) (Exists fun i => And (Membership.mem I i) (Exists fun j => And (Membership.mem J j) (LE.le x (Max.max i j))))","decl":"@[simp]\ntheorem mem_sup : x ‚àà I ‚äî J ‚Üî ‚àÉ i ‚àà I, ‚àÉ j ‚àà J, x ‚â§ i ‚äî j :=\n  Iff.rfl\n\n"}
{"name":"Order.Ideal.lt_sup_principal_of_not_mem","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬π : SemilatticeSup P\ninst‚úù : IsDirected P fun x1 x2 => GE.ge x1 x2\nx : P\nI : Order.Ideal P\nhx : Not (Membership.mem I x)\n‚ä¢ LT.lt I (Max.max I (Order.Ideal.principal x))","decl":"theorem lt_sup_principal_of_not_mem (hx : x ‚àâ I) : I < I ‚äî principal x :=\n  le_sup_left.lt_of_ne fun h ‚Ü¶ hx <| by simpa only [left_eq_sup, principal_le_iff] using h\n\n"}
{"name":"Order.Ideal.coe_sInf","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬π : SemilatticeSup P\ninst‚úù : OrderBot P\nS : Set (Order.Ideal P)\n‚ä¢ Eq (‚Üë(InfSet.sInf S)) (Set.iInter fun s => Set.iInter fun h => ‚Üës)","decl":"@[simp]\ntheorem coe_sInf : (‚Üë(sInf S) : Set P) = ‚ãÇ s ‚àà S, ‚Üës :=\n  LowerSet.coe_iInf‚ÇÇ _\n\n"}
{"name":"Order.Ideal.mem_sInf","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬π : SemilatticeSup P\ninst‚úù : OrderBot P\nx : P\nS : Set (Order.Ideal P)\n‚ä¢ Iff (Membership.mem (InfSet.sInf S) x) (‚àÄ (s : Order.Ideal P), Membership.mem S s ‚Üí Membership.mem s x)","decl":"@[simp]\ntheorem mem_sInf : x ‚àà sInf S ‚Üî ‚àÄ s ‚àà S, x ‚àà s := by\n  simp_rw [‚Üê SetLike.mem_coe, coe_sInf, mem_iInter‚ÇÇ]\n\n"}
{"name":"Order.Ideal.eq_sup_of_le_sup","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : DistribLattice P\nI J : Order.Ideal P\nx i j : P\nhi : Membership.mem I i\nhj : Membership.mem J j\nhx : LE.le x (Max.max i j)\n‚ä¢ Exists fun i' => And (Membership.mem I i') (Exists fun j' => And (Membership.mem J j') (Eq x (Max.max i' j')))","decl":"theorem eq_sup_of_le_sup {x i j : P} (hi : i ‚àà I) (hj : j ‚àà J) (hx : x ‚â§ i ‚äî j) :\n    ‚àÉ i' ‚àà I, ‚àÉ j' ‚àà J, x = i' ‚äî j' := by\n  refine ‚ü®x ‚äì i, I.lower inf_le_right hi, x ‚äì j, J.lower inf_le_right hj, ?_‚ü©\n  calc\n    x = x ‚äì (i ‚äî j) := left_eq_inf.mpr hx\n    _ = x ‚äì i ‚äî x ‚äì j := inf_sup_left _ _ _\n\n"}
{"name":"Order.Ideal.coe_sup_eq","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : DistribLattice P\nI J : Order.Ideal P\n‚ä¢ Eq (‚Üë(Max.max I J)) (setOf fun x => Exists fun i => And (Membership.mem I i) (Exists fun j => And (Membership.mem J j) (Eq x (Max.max i j))))","decl":"theorem coe_sup_eq : ‚Üë(I ‚äî J) = { x | ‚àÉ i ‚àà I, ‚àÉ j ‚àà J, x = i ‚äî j } :=\n  Set.ext fun _ ‚Ü¶\n    ‚ü®fun ‚ü®_, _, _, _, _‚ü© ‚Ü¶ eq_sup_of_le_sup ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫, fun ‚ü®i, _, j, _, _‚ü© ‚Ü¶\n      ‚ü®i, ‚Äπ_‚Ä∫, j, ‚Äπ_‚Ä∫, le_of_eq ‚Äπ_‚Ä∫‚ü©‚ü©\n\n"}
{"name":"Order.Ideal.IsProper.not_mem_of_compl_mem","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : BooleanAlgebra P\nx : P\nI : Order.Ideal P\nhI : I.IsProper\nhxc : Membership.mem I (HasCompl.compl x)\n‚ä¢ Not (Membership.mem I x)","decl":"theorem IsProper.not_mem_of_compl_mem (hI : IsProper I) (hxc : x·∂ú ‚àà I) : x ‚àâ I := by\n  intro hx\n  apply hI.top_not_mem\n  have ht : x ‚äî x·∂ú ‚àà I := sup_mem ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫\n  rwa [sup_compl_eq_top] at ht\n\n"}
{"name":"Order.Ideal.IsProper.not_mem_or_compl_not_mem","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : BooleanAlgebra P\nx : P\nI : Order.Ideal P\nhI : I.IsProper\n‚ä¢ Or (Not (Membership.mem I x)) (Not (Membership.mem I (HasCompl.compl x)))","decl":"theorem IsProper.not_mem_or_compl_not_mem (hI : IsProper I) : x ‚àâ I ‚à® x·∂ú ‚àâ I := by\n  have h : x·∂ú ‚àà I ‚Üí x ‚àâ I := hI.not_mem_of_compl_mem\n  tauto\n\n"}
{"name":"Order.Cofinal.mk.injEq","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst‚úù : Preorder P\ncarrier‚úù : Set P\nisCofinal‚úù : IsCofinal carrier‚úù\ncarrier : Set P\nisCofinal : IsCofinal carrier\n‚ä¢ Eq (Eq { carrier := carrier‚úù, isCofinal := isCofinal‚úù } { carrier := carrier, isCofinal := isCofinal }) (Eq carrier‚úù carrier)","decl":"/-- For a preorder `P`, `Cofinal P` is the type of subsets of `P`\n  containing arbitrarily large elements. They are the dense sets in\n  the topology whose open sets are terminal segments. -/\nstructure Cofinal (P) [Preorder P] where\n  /-- The carrier of a `Cofinal` is the underlying set. -/\n  carrier : Set P\n  /-- The `Cofinal` contains arbitrarily large elements. -/\n  isCofinal : IsCofinal carrier\n\n"}
{"name":"Order.Cofinal.mk.sizeOf_spec","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst‚úù¬π : Preorder P\ninst‚úù : SizeOf P\ncarrier : Set P\nisCofinal : IsCofinal carrier\n‚ä¢ Eq (SizeOf.sizeOf { carrier := carrier, isCofinal := isCofinal }) 1","decl":"/-- For a preorder `P`, `Cofinal P` is the type of subsets of `P`\n  containing arbitrarily large elements. They are the dense sets in\n  the topology whose open sets are terminal segments. -/\nstructure Cofinal (P) [Preorder P] where\n  /-- The carrier of a `Cofinal` is the underlying set. -/\n  carrier : Set P\n  /-- The `Cofinal` contains arbitrarily large elements. -/\n  isCofinal : IsCofinal carrier\n\n"}
{"name":"Order.Cofinal.mk.inj","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst‚úù : Preorder P\ncarrier‚úù : Set P\nisCofinal‚úù : IsCofinal carrier‚úù\ncarrier : Set P\nisCofinal : IsCofinal carrier\nx‚úù : Eq { carrier := carrier‚úù, isCofinal := isCofinal‚úù } { carrier := carrier, isCofinal := isCofinal }\n‚ä¢ Eq carrier‚úù carrier","decl":"/-- For a preorder `P`, `Cofinal P` is the type of subsets of `P`\n  containing arbitrarily large elements. They are the dense sets in\n  the topology whose open sets are terminal segments. -/\nstructure Cofinal (P) [Preorder P] where\n  /-- The carrier of a `Cofinal` is the underlying set. -/\n  carrier : Set P\n  /-- The `Cofinal` contains arbitrarily large elements. -/\n  isCofinal : IsCofinal carrier\n\n"}
{"name":"Order.Cofinal.isCofinal","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst‚úù : Preorder P\nself : Order.Cofinal P\n‚ä¢ IsCofinal self.carrier","decl":"/-- For a preorder `P`, `Cofinal P` is the type of subsets of `P`\n  containing arbitrarily large elements. They are the dense sets in\n  the topology whose open sets are terminal segments. -/\nstructure Cofinal (P) [Preorder P] where\n  /-- The carrier of a `Cofinal` is the underlying set. -/\n  carrier : Set P\n  /-- The `Cofinal` contains arbitrarily large elements. -/\n  isCofinal : IsCofinal carrier\n\n"}
{"name":"Order.Cofinal.mem_gt","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_2\ninst‚úù : Preorder P\nself : Order.Cofinal P\n‚ä¢ IsCofinal self.carrier","decl":"@[deprecated Cofinal.isCofinal (since := \"2024-12-02\")]\nalias Cofinal.mem_gt := Cofinal.isCofinal\n\n"}
{"name":"Order.Cofinal.above_mem","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : Preorder P\nD : Order.Cofinal P\nx : P\n‚ä¢ Membership.mem D (D.above x)","decl":"theorem above_mem : D.above x ‚àà D :=\n  (Classical.choose_spec <| D.isCofinal x).1\n\n"}
{"name":"Order.Cofinal.le_above","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : Preorder P\nD : Order.Cofinal P\nx : P\n‚ä¢ LE.le x (D.above x)","decl":"theorem le_above : x ‚â§ D.above x :=\n  (Classical.choose_spec <| D.isCofinal x).2\n\n"}
{"name":"Order.sequenceOfCofinals.monotone","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬π : Preorder P\np : P\nŒπ : Type u_2\ninst‚úù : Encodable Œπ\nùíü : Œπ ‚Üí Order.Cofinal P\n‚ä¢ Monotone (Order.sequenceOfCofinals p ùíü)","decl":"theorem sequenceOfCofinals.monotone : Monotone (sequenceOfCofinals p ùíü) := by\n  apply monotone_nat_of_le_succ\n  intro n\n  dsimp only [sequenceOfCofinals, Nat.add]\n  cases (Encodable.decode n : Option Œπ)\n  ¬∑ rfl\n  ¬∑ apply Cofinal.le_above\n\n"}
{"name":"Order.sequenceOfCofinals.encode_mem","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬π : Preorder P\np : P\nŒπ : Type u_2\ninst‚úù : Encodable Œπ\nùíü : Œπ ‚Üí Order.Cofinal P\ni : Œπ\n‚ä¢ Membership.mem (ùíü i) (Order.sequenceOfCofinals p ùíü (HAdd.hAdd (Encodable.encode i) 1))","decl":"theorem sequenceOfCofinals.encode_mem (i : Œπ) :\n    sequenceOfCofinals p ùíü (Encodable.encode i + 1) ‚àà ùíü i := by\n  dsimp only [sequenceOfCofinals, Nat.add]\n  rw [Encodable.encodek]\n  apply Cofinal.above_mem\n\n"}
{"name":"Order.mem_idealOfCofinals","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬π : Preorder P\np : P\nŒπ : Type u_2\ninst‚úù : Encodable Œπ\nùíü : Œπ ‚Üí Order.Cofinal P\n‚ä¢ Membership.mem (Order.idealOfCofinals p ùíü) p","decl":"theorem mem_idealOfCofinals : p ‚àà idealOfCofinals p ùíü :=\n  ‚ü®0, le_rfl‚ü©\n\n"}
{"name":"Order.cofinal_meets_idealOfCofinals","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù¬π : Preorder P\np : P\nŒπ : Type u_2\ninst‚úù : Encodable Œπ\nùíü : Œπ ‚Üí Order.Cofinal P\ni : Œπ\n‚ä¢ Exists fun x => And (Membership.mem (ùíü i) x) (Membership.mem (Order.idealOfCofinals p ùíü) x)","decl":"/-- `idealOfCofinals p ùíü` is `ùíü`-generic. -/\ntheorem cofinal_meets_idealOfCofinals (i : Œπ) : ‚àÉ x : P, x ‚àà ùíü i ‚àß x ‚àà idealOfCofinals p ùíü :=\n  ‚ü®_, sequenceOfCofinals.encode_mem p ùíü i, _, le_rfl‚ü©\n\n"}
{"name":"Order.isIdeal_sUnion_of_directedOn","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : Preorder P\nC : Set (Set P)\nhidl : ‚àÄ (I : Set P), Membership.mem C I ‚Üí Order.IsIdeal I\nhD : DirectedOn (fun x1 x2 => HasSubset.Subset x1 x2) C\nhNe : C.Nonempty\n‚ä¢ Order.IsIdeal C.sUnion","decl":"/-- A non-empty directed union of ideals of sets in a preorder is an ideal. -/\nlemma isIdeal_sUnion_of_directedOn {C : Set (Set P)} (hidl : ‚àÄ I ‚àà C, IsIdeal I)\n    (hD : DirectedOn (¬∑ ‚äÜ ¬∑) C) (hNe : C.Nonempty) : IsIdeal C.sUnion := by\n  refine ‚ü®isLowerSet_sUnion (fun I hI ‚Ü¶ (hidl I hI).1), Set.nonempty_sUnion.2 ?_,\n    directedOn_sUnion hD (fun J hJ => (hidl J hJ).3)‚ü©\n  let ‚ü®I, hI‚ü© := hNe\n  exact ‚ü®I, ‚ü®hI, (hidl I hI).2‚ü©‚ü©\n\n"}
{"name":"Order.isIdeal_sUnion_of_isChain","module":"Mathlib.Order.Ideal","initialProofState":"P : Type u_1\ninst‚úù : Preorder P\nC : Set (Set P)\nhidl : ‚àÄ (I : Set P), Membership.mem C I ‚Üí Order.IsIdeal I\nhC : IsChain (fun x1 x2 => HasSubset.Subset x1 x2) C\nhNe : C.Nonempty\n‚ä¢ Order.IsIdeal C.sUnion","decl":"/-- A union of a nonempty chain of ideals of sets is an ideal. -/\nlemma isIdeal_sUnion_of_isChain {C : Set (Set P)} (hidl : ‚àÄ I ‚àà C, IsIdeal I)\n    (hC : IsChain (¬∑ ‚äÜ ¬∑) C) (hNe : C.Nonempty) : IsIdeal C.sUnion :=\n  isIdeal_sUnion_of_directedOn hidl hC.directedOn hNe\n\n"}
