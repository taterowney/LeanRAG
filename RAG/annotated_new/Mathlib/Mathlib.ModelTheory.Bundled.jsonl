{"name":"Equiv.bundledInduced_α","module":"Mathlib.ModelTheory.Bundled","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nN : Type w'\ng : Equiv M N\n⊢ Eq (↑(Equiv.bundledInduced L g)) N","decl":"/-- A type bundled with the structure induced by an equivalence. -/\n@[simps]\ndef bundledInduced : CategoryTheory.Bundled.{w'} L.Structure :=\n  ⟨N, g.inducedStructure⟩\n\n"}
{"name":"Equiv.bundledInduced_str","module":"Mathlib.ModelTheory.Bundled","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nN : Type w'\ng : Equiv M N\n⊢ Eq (Equiv.bundledInduced L g).str g.inducedStructure","decl":"/-- A type bundled with the structure induced by an equivalence. -/\n@[simps]\ndef bundledInduced : CategoryTheory.Bundled.{w'} L.Structure :=\n  ⟨N, g.inducedStructure⟩\n\n"}
{"name":"FirstOrder.Language.Theory.ModelType.is_model","module":"Mathlib.ModelTheory.Bundled","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nself : T.ModelType\n⊢ FirstOrder.Language.Theory.Model self.Carrier T","decl":"/-- The type of nonempty models of a first-order theory. -/\nstructure ModelType where\n  Carrier : Type w\n  [struc : L.Structure Carrier]\n  [is_model : T.Model Carrier]\n  [nonempty' : Nonempty Carrier]\n\n-- Porting note: In Lean4, other instances precedes `FirstOrder.Language.Theory.ModelType.struc`,\n-- it's issues in `ModelTheory.Satisfiability`. So, we increase these priorities.\n"}
{"name":"FirstOrder.Language.Theory.ModelType.mk.sizeOf_spec","module":"Mathlib.ModelTheory.Bundled","initialProofState":"L : FirstOrder.Language\nT : L.Theory\ninst✝ : (a : L.Sentence) → SizeOf (T a)\nCarrier : Type w\nstruc : L.Structure Carrier\nis_model : FirstOrder.Language.Theory.Model Carrier T\nnonempty' : Nonempty Carrier\n⊢ Eq (SizeOf.sizeOf (FirstOrder.Language.Theory.ModelType.mk Carrier)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf Carrier)) (SizeOf.sizeOf struc)) (SizeOf.sizeOf is_model)) (SizeOf.sizeOf nonempty'))","decl":"/-- The type of nonempty models of a first-order theory. -/\nstructure ModelType where\n  Carrier : Type w\n  [struc : L.Structure Carrier]\n  [is_model : T.Model Carrier]\n  [nonempty' : Nonempty Carrier]\n\n-- Porting note: In Lean4, other instances precedes `FirstOrder.Language.Theory.ModelType.struc`,\n-- it's issues in `ModelTheory.Satisfiability`. So, we increase these priorities.\n"}
{"name":"FirstOrder.Language.Theory.ModelType.mk.inj","module":"Mathlib.ModelTheory.Bundled","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nCarrier✝ : Type w\nstruc✝ : L.Structure Carrier✝\nis_model✝ : FirstOrder.Language.Theory.Model Carrier✝ T\nnonempty'✝ : Nonempty Carrier✝\nCarrier : Type w\nstruc : L.Structure Carrier\nis_model : FirstOrder.Language.Theory.Model Carrier T\nnonempty' : Nonempty Carrier\nx✝ : Eq (FirstOrder.Language.Theory.ModelType.mk Carrier✝) (FirstOrder.Language.Theory.ModelType.mk Carrier)\n⊢ And (Eq Carrier✝ Carrier) (HEq struc✝ struc)","decl":"/-- The type of nonempty models of a first-order theory. -/\nstructure ModelType where\n  Carrier : Type w\n  [struc : L.Structure Carrier]\n  [is_model : T.Model Carrier]\n  [nonempty' : Nonempty Carrier]\n\n-- Porting note: In Lean4, other instances precedes `FirstOrder.Language.Theory.ModelType.struc`,\n-- it's issues in `ModelTheory.Satisfiability`. So, we increase these priorities.\n"}
{"name":"FirstOrder.Language.Theory.ModelType.nonempty'","module":"Mathlib.ModelTheory.Bundled","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nself : T.ModelType\n⊢ Nonempty self.Carrier","decl":"/-- The type of nonempty models of a first-order theory. -/\nstructure ModelType where\n  Carrier : Type w\n  [struc : L.Structure Carrier]\n  [is_model : T.Model Carrier]\n  [nonempty' : Nonempty Carrier]\n\n-- Porting note: In Lean4, other instances precedes `FirstOrder.Language.Theory.ModelType.struc`,\n-- it's issues in `ModelTheory.Satisfiability`. So, we increase these priorities.\n"}
{"name":"FirstOrder.Language.Theory.ModelType.mk.injEq","module":"Mathlib.ModelTheory.Bundled","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nCarrier✝ : Type w\nstruc✝ : L.Structure Carrier✝\nis_model✝ : FirstOrder.Language.Theory.Model Carrier✝ T\nnonempty'✝ : Nonempty Carrier✝\nCarrier : Type w\nstruc : L.Structure Carrier\nis_model : FirstOrder.Language.Theory.Model Carrier T\nnonempty' : Nonempty Carrier\n⊢ Eq (Eq (FirstOrder.Language.Theory.ModelType.mk Carrier✝) (FirstOrder.Language.Theory.ModelType.mk Carrier)) (And (Eq Carrier✝ Carrier) (HEq struc✝ struc))","decl":"/-- The type of nonempty models of a first-order theory. -/\nstructure ModelType where\n  Carrier : Type w\n  [struc : L.Structure Carrier]\n  [is_model : T.Model Carrier]\n  [nonempty' : Nonempty Carrier]\n\n-- Porting note: In Lean4, other instances precedes `FirstOrder.Language.Theory.ModelType.struc`,\n-- it's issues in `ModelTheory.Satisfiability`. So, we increase these priorities.\n"}
{"name":"FirstOrder.Language.Theory.ModelType.coe_of","module":"Mathlib.ModelTheory.Bundled","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nM : Type w\ninst✝² : L.Structure M\ninst✝¹ : FirstOrder.Language.Theory.Model M T\ninst✝ : Nonempty M\n⊢ Eq (↑(FirstOrder.Language.Theory.ModelType.of T M)) M","decl":"@[simp]\ntheorem coe_of (M : Type w) [L.Structure M] [M ⊨ T] [Nonempty M] : (of T M : Type w) = M :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.Theory.ModelType.instNonempty","module":"Mathlib.ModelTheory.Bundled","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nM : T.ModelType\n⊢ Nonempty ↑M","decl":"instance instNonempty (M : T.ModelType) : Nonempty M :=\n  inferInstance\n\n"}
{"name":"FirstOrder.Language.Theory.ModelType.of_small","module":"Mathlib.ModelTheory.Bundled","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nM : Type w\ninst✝² : Nonempty M\ninst✝¹ : L.Structure M\ninst✝ : FirstOrder.Language.Theory.Model M T\nh : Small.{w', w} M\n⊢ Small.{w', w} ↑(FirstOrder.Language.Theory.ModelType.of T M)","decl":"instance of_small (M : Type w) [Nonempty M] [L.Structure M] [M ⊨ T] [h : Small.{w'} M] :\n    Small.{w'} (ModelType.of T M) :=\n  h\n\n"}
{"name":"FirstOrder.Language.Theory.ModelType.reduct_struc","module":"Mathlib.ModelTheory.Bundled","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nL' : FirstOrder.Language\nφ : L.LHom L'\nM : (φ.onTheory T).ModelType\n⊢ Eq (FirstOrder.Language.Theory.ModelType.reduct φ M).struc (φ.reduct ↑M)","decl":"/-- The reduct of any model of `φ.onTheory T` is a model of `T`. -/\n@[simps]\ndef reduct {L' : Language} (φ : L →ᴸ L') (M : (φ.onTheory T).ModelType) : T.ModelType where\n  Carrier := M\n  struc := φ.reduct M\n  nonempty' := M.nonempty'\n  is_model := (@LHom.onTheory_model L L' M (φ.reduct M) _ φ _ T).1 M.is_model\n\n"}
{"name":"FirstOrder.Language.Theory.ModelType.reduct_Carrier","module":"Mathlib.ModelTheory.Bundled","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nL' : FirstOrder.Language\nφ : L.LHom L'\nM : (φ.onTheory T).ModelType\n⊢ Eq ↑(FirstOrder.Language.Theory.ModelType.reduct φ M) ↑M","decl":"/-- The reduct of any model of `φ.onTheory T` is a model of `T`. -/\n@[simps]\ndef reduct {L' : Language} (φ : L →ᴸ L') (M : (φ.onTheory T).ModelType) : T.ModelType where\n  Carrier := M\n  struc := φ.reduct M\n  nonempty' := M.nonempty'\n  is_model := (@LHom.onTheory_model L L' M (φ.reduct M) _ φ _ T).1 M.is_model\n\n"}
{"name":"FirstOrder.Language.Theory.ModelType.defaultExpansion_Carrier","module":"Mathlib.ModelTheory.Bundled","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nL' : FirstOrder.Language\nφ : L.LHom L'\nh : φ.Injective\ninst✝² : (n : Nat) → (f : L'.Functions n) → Decidable (Membership.mem (Set.range fun f => φ.onFunction f) f)\ninst✝¹ : (n : Nat) → (r : L'.Relations n) → Decidable (Membership.mem (Set.range fun r => φ.onRelation r) r)\nM : T.ModelType\ninst✝ : Inhabited ↑M\n⊢ Eq ↑(FirstOrder.Language.Theory.ModelType.defaultExpansion h M) ↑M","decl":"/-- When `φ` is injective, `defaultExpansion` expands a model of `T` to a model of `φ.onTheory T`\n  arbitrarily. -/\n@[simps]\nnoncomputable def defaultExpansion {L' : Language} {φ : L →ᴸ L'} (h : φ.Injective)\n    [∀ (n) (f : L'.Functions n), Decidable (f ∈ Set.range fun f : L.Functions n => φ.onFunction f)]\n    [∀ (n) (r : L'.Relations n), Decidable (r ∈ Set.range fun r : L.Relations n => φ.onRelation r)]\n    (M : T.ModelType) [Inhabited M] : (φ.onTheory T).ModelType where\n  Carrier := M\n  struc := φ.defaultExpansion M\n  nonempty' := M.nonempty'\n  is_model :=\n    (@LHom.onTheory_model L L' M _ (φ.defaultExpansion M) φ (h.isExpansionOn_default M) T).2\n      M.is_model\n\n"}
{"name":"FirstOrder.Language.Theory.ModelType.defaultExpansion_struc","module":"Mathlib.ModelTheory.Bundled","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nL' : FirstOrder.Language\nφ : L.LHom L'\nh : φ.Injective\ninst✝² : (n : Nat) → (f : L'.Functions n) → Decidable (Membership.mem (Set.range fun f => φ.onFunction f) f)\ninst✝¹ : (n : Nat) → (r : L'.Relations n) → Decidable (Membership.mem (Set.range fun r => φ.onRelation r) r)\nM : T.ModelType\ninst✝ : Inhabited ↑M\n⊢ Eq (FirstOrder.Language.Theory.ModelType.defaultExpansion h M).struc (φ.defaultExpansion ↑M)","decl":"/-- When `φ` is injective, `defaultExpansion` expands a model of `T` to a model of `φ.onTheory T`\n  arbitrarily. -/\n@[simps]\nnoncomputable def defaultExpansion {L' : Language} {φ : L →ᴸ L'} (h : φ.Injective)\n    [∀ (n) (f : L'.Functions n), Decidable (f ∈ Set.range fun f : L.Functions n => φ.onFunction f)]\n    [∀ (n) (r : L'.Relations n), Decidable (r ∈ Set.range fun r : L.Relations n => φ.onRelation r)]\n    (M : T.ModelType) [Inhabited M] : (φ.onTheory T).ModelType where\n  Carrier := M\n  struc := φ.defaultExpansion M\n  nonempty' := M.nonempty'\n  is_model :=\n    (@LHom.onTheory_model L L' M _ (φ.defaultExpansion M) φ (h.isExpansionOn_default M) T).2\n      M.is_model\n\n"}
{"name":"FirstOrder.Language.Theory.ModelType.subtheoryModel_Carrier","module":"Mathlib.ModelTheory.Bundled","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nM : T.ModelType\nT' : L.Theory\nh : HasSubset.Subset T' T\n⊢ Eq ↑(M.subtheoryModel h) ↑M","decl":"/-- A model of a theory is also a model of any subtheory. -/\n@[simps]\ndef subtheoryModel (M : T.ModelType) {T' : L.Theory} (h : T' ⊆ T) : T'.ModelType where\n  Carrier := M\n  is_model := ⟨fun _φ hφ => realize_sentence_of_mem T (h hφ)⟩\n\n"}
{"name":"FirstOrder.Language.Theory.ModelType.subtheoryModel_struc","module":"Mathlib.ModelTheory.Bundled","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nM : T.ModelType\nT' : L.Theory\nh : HasSubset.Subset T' T\n⊢ Eq (M.subtheoryModel h).struc M.struc","decl":"/-- A model of a theory is also a model of any subtheory. -/\n@[simps]\ndef subtheoryModel (M : T.ModelType) {T' : L.Theory} (h : T' ⊆ T) : T'.ModelType where\n  Carrier := M\n  is_model := ⟨fun _φ hφ => realize_sentence_of_mem T (h hφ)⟩\n\n"}
{"name":"FirstOrder.Language.Theory.ModelType.subtheoryModel_models","module":"Mathlib.ModelTheory.Bundled","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nM : T.ModelType\nT' : L.Theory\nh : HasSubset.Subset T' T\n⊢ FirstOrder.Language.Theory.Model (↑(M.subtheoryModel h)) T","decl":"instance subtheoryModel_models (M : T.ModelType) {T' : L.Theory} (h : T' ⊆ T) :\n    M.subtheoryModel h ⊨ T :=\n  M.is_model\n\n"}
{"name":"FirstOrder.Language.Theory.coe_of","module":"Mathlib.ModelTheory.Bundled","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nM : Type w\ninst✝¹ : L.Structure M\ninst✝ : Nonempty M\nh : FirstOrder.Language.Theory.Model M T\n⊢ Eq (↑h.bundled) M","decl":"@[simp]\ntheorem coe_of {M : Type w} [L.Structure M] [Nonempty M] (h : M ⊨ T) : (h.bundled : Type w) = M :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.ElementarySubstructure.toModel.instSmall","module":"Mathlib.ModelTheory.Bundled","initialProofState":"L : FirstOrder.Language\nT : L.Theory\nM : T.ModelType\nS : L.ElementarySubstructure ↑M\nh : Small.{w, x} (Subtype fun x => Membership.mem S x)\n⊢ Small.{w, x} ↑(FirstOrder.Language.ElementarySubstructure.toModel T S)","decl":"instance ElementarySubstructure.toModel.instSmall {M : T.ModelType}\n    (S : L.ElementarySubstructure M) [h : Small.{w, x} S] : Small.{w, x} (S.toModel T) :=\n  h\n\n"}
