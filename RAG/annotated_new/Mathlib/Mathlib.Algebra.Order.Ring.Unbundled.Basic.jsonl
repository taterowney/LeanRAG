{"name":"add_one_le_two_mul","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝² : LE α\ninst✝¹ : Semiring α\ninst✝ : AddLeftMono α\na : α\na1 : LE.le 1 a\n⊢ LE.le (HAdd.hAdd a 1) (HMul.hMul 2 a)","decl":"theorem add_one_le_two_mul [LE α] [Semiring α] [AddLeftMono α] {a : α}\n    (a1 : 1 ≤ a) : a + 1 ≤ 2 * a :=\n  calc\n    a + 1 ≤ a + a := add_le_add_left a1 a\n    _ = 2 * a := (two_mul _).symm\n\n"}
{"name":"add_le_mul_two_add","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁴ : Semiring α\ninst✝³ : Preorder α\na b : α\ninst✝² : ZeroLEOneClass α\ninst✝¹ : MulPosMono α\ninst✝ : AddLeftMono α\na2 : LE.le 2 a\nb0 : LE.le 0 b\n⊢ LE.le (HAdd.hAdd a (HAdd.hAdd 2 b)) (HMul.hMul a (HAdd.hAdd 2 b))","decl":"theorem add_le_mul_two_add [ZeroLEOneClass α] [MulPosMono α] [AddLeftMono α]\n    (a2 : 2 ≤ a) (b0 : 0 ≤ b) : a + (2 + b) ≤ a * (2 + b) :=\n  calc\n    a + (2 + b) ≤ a + (a + a * b) :=\n      add_le_add_left (add_le_add a2 <| le_mul_of_one_le_left b0 <| (@one_le_two α).trans a2) a\n    _ ≤ a * (2 + b) := by rw [mul_add, mul_two, add_assoc]\n\n"}
{"name":"mul_le_mul_of_nonpos_left","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : Preorder α\na b c : α\ninst✝³ : ExistsAddOfLE α\ninst✝² : PosMulMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nh : LE.le b a\nhc : LE.le c 0\n⊢ LE.le (HMul.hMul c a) (HMul.hMul c b)","decl":"theorem mul_le_mul_of_nonpos_left [ExistsAddOfLE α] [PosMulMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (h : b ≤ a) (hc : c ≤ 0) : c * a ≤ c * b := by\n  obtain ⟨d, hcd⟩ := exists_add_of_le hc\n  refine le_of_add_le_add_right (a := d * b + d * a) ?_\n  calc\n    _ = d * b := by rw [add_left_comm, ← add_mul, ← hcd, zero_mul, add_zero]\n    _ ≤ d * a := mul_le_mul_of_nonneg_left h <| hcd.trans_le <| add_le_of_nonpos_left hc\n    _ = _ := by rw [← add_assoc, ← add_mul, ← hcd, zero_mul, zero_add]\n\n"}
{"name":"mul_le_mul_of_nonpos_right","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : Preorder α\na b c : α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nh : LE.le b a\nhc : LE.le c 0\n⊢ LE.le (HMul.hMul a c) (HMul.hMul b c)","decl":"theorem mul_le_mul_of_nonpos_right [ExistsAddOfLE α] [MulPosMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (h : b ≤ a) (hc : c ≤ 0) : a * c ≤ b * c := by\n  obtain ⟨d, hcd⟩ := exists_add_of_le hc\n  refine le_of_add_le_add_right (a := b * d + a * d) ?_\n  calc\n    _ = b * d := by rw [add_left_comm, ← mul_add, ← hcd, mul_zero, add_zero]\n    _ ≤ a * d := mul_le_mul_of_nonneg_right h <| hcd.trans_le <| add_le_of_nonpos_left hc\n    _ = _ := by rw [← add_assoc, ← mul_add, ← hcd, mul_zero, zero_add]\n\n"}
{"name":"mul_nonneg_of_nonpos_of_nonpos","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : Preorder α\na b : α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nha : LE.le a 0\nhb : LE.le b 0\n⊢ LE.le 0 (HMul.hMul a b)","decl":"theorem mul_nonneg_of_nonpos_of_nonpos [ExistsAddOfLE α] [MulPosMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (ha : a ≤ 0) (hb : b ≤ 0) : 0 ≤ a * b := by\n  simpa only [zero_mul] using mul_le_mul_of_nonpos_right ha hb\n\n"}
{"name":"mul_le_mul_of_nonneg_of_nonpos","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁶ : Semiring α\ninst✝⁵ : Preorder α\na b c d : α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : MulPosMono α\ninst✝² : PosMulMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nhca : LE.le c a\nhbd : LE.le b d\nhc : LE.le 0 c\nhb : LE.le b 0\n⊢ LE.le (HMul.hMul a b) (HMul.hMul c d)","decl":"theorem mul_le_mul_of_nonneg_of_nonpos [ExistsAddOfLE α] [MulPosMono α] [PosMulMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (hca : c ≤ a) (hbd : b ≤ d) (hc : 0 ≤ c) (hb : b ≤ 0) : a * b ≤ c * d :=\n  (mul_le_mul_of_nonpos_right hca hb).trans <| mul_le_mul_of_nonneg_left hbd hc\n\n"}
{"name":"mul_le_mul_of_nonneg_of_nonpos'","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁶ : Semiring α\ninst✝⁵ : Preorder α\na b c d : α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : PosMulMono α\ninst✝² : MulPosMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nhca : LE.le c a\nhbd : LE.le b d\nha : LE.le 0 a\nhd : LE.le d 0\n⊢ LE.le (HMul.hMul a b) (HMul.hMul c d)","decl":"theorem mul_le_mul_of_nonneg_of_nonpos' [ExistsAddOfLE α] [PosMulMono α] [MulPosMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (hca : c ≤ a) (hbd : b ≤ d) (ha : 0 ≤ a) (hd : d ≤ 0) : a * b ≤ c * d :=\n  (mul_le_mul_of_nonneg_left hbd ha).trans <| mul_le_mul_of_nonpos_right hca hd\n\n"}
{"name":"mul_le_mul_of_nonpos_of_nonneg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁶ : Semiring α\ninst✝⁵ : Preorder α\na b c d : α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : MulPosMono α\ninst✝² : PosMulMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nhac : LE.le a c\nhdb : LE.le d b\nhc : LE.le c 0\nhb : LE.le 0 b\n⊢ LE.le (HMul.hMul a b) (HMul.hMul c d)","decl":"theorem mul_le_mul_of_nonpos_of_nonneg [ExistsAddOfLE α] [MulPosMono α] [PosMulMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (hac : a ≤ c) (hdb : d ≤ b) (hc : c ≤ 0) (hb : 0 ≤ b) : a * b ≤ c * d :=\n  (mul_le_mul_of_nonneg_right hac hb).trans <| mul_le_mul_of_nonpos_left hdb hc\n\n"}
{"name":"mul_le_mul_of_nonpos_of_nonneg'","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁶ : Semiring α\ninst✝⁵ : Preorder α\na b c d : α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : PosMulMono α\ninst✝² : MulPosMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nhca : LE.le c a\nhbd : LE.le b d\nha : LE.le 0 a\nhd : LE.le d 0\n⊢ LE.le (HMul.hMul a b) (HMul.hMul c d)","decl":"theorem mul_le_mul_of_nonpos_of_nonneg' [ExistsAddOfLE α] [PosMulMono α] [MulPosMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (hca : c ≤ a) (hbd : b ≤ d) (ha : 0 ≤ a) (hd : d ≤ 0) : a * b ≤ c * d :=\n  (mul_le_mul_of_nonneg_left hbd ha).trans <| mul_le_mul_of_nonpos_right hca hd\n\n"}
{"name":"mul_le_mul_of_nonpos_of_nonpos","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁶ : Semiring α\ninst✝⁵ : Preorder α\na b c d : α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : MulPosMono α\ninst✝² : PosMulMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nhca : LE.le c a\nhdb : LE.le d b\nhc : LE.le c 0\nhb : LE.le b 0\n⊢ LE.le (HMul.hMul a b) (HMul.hMul c d)","decl":"theorem mul_le_mul_of_nonpos_of_nonpos [ExistsAddOfLE α] [MulPosMono α] [PosMulMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (hca : c ≤ a) (hdb : d ≤ b) (hc : c ≤ 0) (hb : b ≤ 0) : a * b ≤ c * d :=\n  (mul_le_mul_of_nonpos_right hca hb).trans <| mul_le_mul_of_nonpos_left hdb hc\n\n"}
{"name":"mul_le_mul_of_nonpos_of_nonpos'","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁶ : Semiring α\ninst✝⁵ : Preorder α\na b c d : α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : PosMulMono α\ninst✝² : MulPosMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nhca : LE.le c a\nhdb : LE.le d b\nha : LE.le a 0\nhd : LE.le d 0\n⊢ LE.le (HMul.hMul a b) (HMul.hMul c d)","decl":"theorem mul_le_mul_of_nonpos_of_nonpos' [ExistsAddOfLE α] [PosMulMono α] [MulPosMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (hca : c ≤ a) (hdb : d ≤ b) (ha : a ≤ 0) (hd : d ≤ 0) : a * b ≤ c * d :=\n  (mul_le_mul_of_nonpos_left hdb ha).trans <| mul_le_mul_of_nonpos_right hca hd\n\n"}
{"name":"le_mul_of_le_one_left","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : Preorder α\na b : α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nhb : LE.le b 0\nh : LE.le a 1\n⊢ LE.le b (HMul.hMul a b)","decl":"/-- Variant of `mul_le_of_le_one_left` for `b` non-positive instead of non-negative. -/\ntheorem le_mul_of_le_one_left [ExistsAddOfLE α] [MulPosMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (hb : b ≤ 0) (h : a ≤ 1) : b ≤ a * b := by\n  simpa only [one_mul] using mul_le_mul_of_nonpos_right h hb\n\n"}
{"name":"mul_le_of_one_le_left","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : Preorder α\na b : α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nhb : LE.le b 0\nh : LE.le 1 a\n⊢ LE.le (HMul.hMul a b) b","decl":"/-- Variant of `le_mul_of_one_le_left` for `b` non-positive instead of non-negative. -/\ntheorem mul_le_of_one_le_left [ExistsAddOfLE α] [MulPosMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (hb : b ≤ 0) (h : 1 ≤ a) : a * b ≤ b := by\n  simpa only [one_mul] using mul_le_mul_of_nonpos_right h hb\n\n"}
{"name":"le_mul_of_le_one_right","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : Preorder α\na b : α\ninst✝³ : ExistsAddOfLE α\ninst✝² : PosMulMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nha : LE.le a 0\nh : LE.le b 1\n⊢ LE.le a (HMul.hMul a b)","decl":"/-- Variant of `mul_le_of_le_one_right` for `a` non-positive instead of non-negative. -/\ntheorem le_mul_of_le_one_right [ExistsAddOfLE α] [PosMulMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (ha : a ≤ 0) (h : b ≤ 1) : a ≤ a * b := by\n  simpa only [mul_one] using mul_le_mul_of_nonpos_left h ha\n\n"}
{"name":"mul_le_of_one_le_right","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : Preorder α\na b : α\ninst✝³ : ExistsAddOfLE α\ninst✝² : PosMulMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nha : LE.le a 0\nh : LE.le 1 b\n⊢ LE.le (HMul.hMul a b) a","decl":"/-- Variant of `le_mul_of_one_le_right` for `a` non-positive instead of non-negative. -/\ntheorem mul_le_of_one_le_right [ExistsAddOfLE α] [PosMulMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (ha : a ≤ 0) (h : 1 ≤ b) : a * b ≤ a := by\n  simpa only [mul_one] using mul_le_mul_of_nonpos_left h ha\n\n"}
{"name":"antitone_mul_left","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : Preorder α\ninst✝³ : ExistsAddOfLE α\ninst✝² : PosMulMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\na : α\nha : LE.le a 0\n⊢ Antitone fun x => HMul.hMul a x","decl":"theorem antitone_mul_left [ExistsAddOfLE α] [PosMulMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    {a : α} (ha : a ≤ 0) : Antitone (a * ·) := fun _ _ b_le_c =>\n  mul_le_mul_of_nonpos_left b_le_c ha\n\n"}
{"name":"antitone_mul_right","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : Preorder α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\na : α\nha : LE.le a 0\n⊢ Antitone fun x => HMul.hMul x a","decl":"theorem antitone_mul_right [ExistsAddOfLE α] [MulPosMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    {a : α} (ha : a ≤ 0) : Antitone fun x => x * a := fun _ _ b_le_c =>\n  mul_le_mul_of_nonpos_right b_le_c ha\n\n"}
{"name":"Monotone.const_mul_of_nonpos","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\nβ : Type u_1\ninst✝⁶ : Semiring α\ninst✝⁵ : Preorder α\na : α\ninst✝⁴ : Preorder β\nf : β → α\ninst✝³ : ExistsAddOfLE α\ninst✝² : PosMulMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nhf : Monotone f\nha : LE.le a 0\n⊢ Antitone fun x => HMul.hMul a (f x)","decl":"theorem Monotone.const_mul_of_nonpos [ExistsAddOfLE α] [PosMulMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (hf : Monotone f) (ha : a ≤ 0) : Antitone fun x => a * f x :=\n  (antitone_mul_left ha).comp_monotone hf\n\n"}
{"name":"Monotone.mul_const_of_nonpos","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\nβ : Type u_1\ninst✝⁶ : Semiring α\ninst✝⁵ : Preorder α\na : α\ninst✝⁴ : Preorder β\nf : β → α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nhf : Monotone f\nha : LE.le a 0\n⊢ Antitone fun x => HMul.hMul (f x) a","decl":"theorem Monotone.mul_const_of_nonpos [ExistsAddOfLE α] [MulPosMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (hf : Monotone f) (ha : a ≤ 0) : Antitone fun x => f x * a :=\n  (antitone_mul_right ha).comp_monotone hf\n\n"}
{"name":"Antitone.const_mul_of_nonpos","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\nβ : Type u_1\ninst✝⁶ : Semiring α\ninst✝⁵ : Preorder α\na : α\ninst✝⁴ : Preorder β\nf : β → α\ninst✝³ : ExistsAddOfLE α\ninst✝² : PosMulMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nhf : Antitone f\nha : LE.le a 0\n⊢ Monotone fun x => HMul.hMul a (f x)","decl":"theorem Antitone.const_mul_of_nonpos [ExistsAddOfLE α] [PosMulMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (hf : Antitone f) (ha : a ≤ 0) : Monotone fun x => a * f x :=\n  (antitone_mul_left ha).comp hf\n\n"}
{"name":"Antitone.mul_const_of_nonpos","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\nβ : Type u_1\ninst✝⁶ : Semiring α\ninst✝⁵ : Preorder α\na : α\ninst✝⁴ : Preorder β\nf : β → α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nhf : Antitone f\nha : LE.le a 0\n⊢ Monotone fun x => HMul.hMul (f x) a","decl":"theorem Antitone.mul_const_of_nonpos [ExistsAddOfLE α] [MulPosMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (hf : Antitone f) (ha : a ≤ 0) : Monotone fun x => f x * a :=\n  (antitone_mul_right ha).comp hf\n\n"}
{"name":"Antitone.mul_monotone","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\nβ : Type u_1\ninst✝⁷ : Semiring α\ninst✝⁶ : Preorder α\ninst✝⁵ : Preorder β\nf g : β → α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : PosMulMono α\ninst✝² : MulPosMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nhf : Antitone f\nhg : Monotone g\nhf₀ : ∀ (x : β), LE.le (f x) 0\nhg₀ : ∀ (x : β), LE.le 0 (g x)\n⊢ Antitone (HMul.hMul f g)","decl":"theorem Antitone.mul_monotone [ExistsAddOfLE α] [PosMulMono α] [MulPosMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (hf : Antitone f) (hg : Monotone g) (hf₀ : ∀ x, f x ≤ 0)\n    (hg₀ : ∀ x, 0 ≤ g x) : Antitone (f * g) := fun _ _ h =>\n  mul_le_mul_of_nonpos_of_nonneg (hf h) (hg h) (hf₀ _) (hg₀ _)\n\n"}
{"name":"Monotone.mul_antitone","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\nβ : Type u_1\ninst✝⁷ : Semiring α\ninst✝⁶ : Preorder α\ninst✝⁵ : Preorder β\nf g : β → α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : PosMulMono α\ninst✝² : MulPosMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nhf : Monotone f\nhg : Antitone g\nhf₀ : ∀ (x : β), LE.le 0 (f x)\nhg₀ : ∀ (x : β), LE.le (g x) 0\n⊢ Antitone (HMul.hMul f g)","decl":"theorem Monotone.mul_antitone [ExistsAddOfLE α] [PosMulMono α] [MulPosMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (hf : Monotone f) (hg : Antitone g) (hf₀ : ∀ x, 0 ≤ f x)\n    (hg₀ : ∀ x, g x ≤ 0) : Antitone (f * g) := fun _ _ h =>\n  mul_le_mul_of_nonneg_of_nonpos (hf h) (hg h) (hf₀ _) (hg₀ _)\n\n"}
{"name":"Antitone.mul","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\nβ : Type u_1\ninst✝⁷ : Semiring α\ninst✝⁶ : Preorder α\ninst✝⁵ : Preorder β\nf g : β → α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : PosMulMono α\ninst✝² : MulPosMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nhf : Antitone f\nhg : Antitone g\nhf₀ : ∀ (x : β), LE.le (f x) 0\nhg₀ : ∀ (x : β), LE.le (g x) 0\n⊢ Monotone (HMul.hMul f g)","decl":"theorem Antitone.mul [ExistsAddOfLE α] [PosMulMono α] [MulPosMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (hf : Antitone f) (hg : Antitone g) (hf₀ : ∀ x, f x ≤ 0) (hg₀ : ∀ x, g x ≤ 0) :\n    Monotone (f * g) := fun _ _ h => mul_le_mul_of_nonpos_of_nonpos (hf h) (hg h) (hf₀ _) (hg₀ _)\n\n"}
{"name":"lt_two_mul_self","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : PartialOrder α\na : α\ninst✝³ : ZeroLEOneClass α\ninst✝² : MulPosStrictMono α\ninst✝¹ : NeZero 1\ninst✝ : AddLeftStrictMono α\nha : LT.lt 0 a\n⊢ LT.lt a (HMul.hMul 2 a)","decl":"theorem lt_two_mul_self [ZeroLEOneClass α] [MulPosStrictMono α] [NeZero (R := α) 1]\n    [AddLeftStrictMono α] (ha : 0 < a) : a < 2 * a :=\n  lt_mul_of_one_lt_left ha one_lt_two\n\n"}
{"name":"mul_lt_mul_of_neg_left","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : PartialOrder α\na b c : α\ninst✝³ : ExistsAddOfLE α\ninst✝² : PosMulStrictMono α\ninst✝¹ : AddRightStrictMono α\ninst✝ : AddRightReflectLT α\nh : LT.lt b a\nhc : LT.lt c 0\n⊢ LT.lt (HMul.hMul c a) (HMul.hMul c b)","decl":"theorem mul_lt_mul_of_neg_left [ExistsAddOfLE α] [PosMulStrictMono α]\n    [AddRightStrictMono α] [AddRightReflectLT α]\n    (h : b < a) (hc : c < 0) : c * a < c * b := by\n  obtain ⟨d, hcd⟩ := exists_add_of_le hc.le\n  refine (add_lt_add_iff_right (d * b + d * a)).1 ?_\n  calc\n    _ = d * b := by rw [add_left_comm, ← add_mul, ← hcd, zero_mul, add_zero]\n    _ < d * a := mul_lt_mul_of_pos_left h <| hcd.trans_lt <| add_lt_of_neg_left _ hc\n    _ = _ := by rw [← add_assoc, ← add_mul, ← hcd, zero_mul, zero_add]\n\n"}
{"name":"mul_lt_mul_of_neg_right","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : PartialOrder α\na b c : α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddRightStrictMono α\ninst✝ : AddRightReflectLT α\nh : LT.lt b a\nhc : LT.lt c 0\n⊢ LT.lt (HMul.hMul a c) (HMul.hMul b c)","decl":"theorem mul_lt_mul_of_neg_right [ExistsAddOfLE α] [MulPosStrictMono α]\n    [AddRightStrictMono α] [AddRightReflectLT α]\n    (h : b < a) (hc : c < 0) : a * c < b * c := by\n  obtain ⟨d, hcd⟩ := exists_add_of_le hc.le\n  refine (add_lt_add_iff_right (b * d + a * d)).1 ?_\n  calc\n    _ = b * d := by rw [add_left_comm, ← mul_add, ← hcd, mul_zero, add_zero]\n    _ < a * d := mul_lt_mul_of_pos_right h <| hcd.trans_lt <| add_lt_of_neg_left _ hc\n    _ = _ := by rw [← add_assoc, ← mul_add, ← hcd, mul_zero, zero_add]\n\n"}
{"name":"mul_pos_of_neg_of_neg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : PartialOrder α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddRightStrictMono α\ninst✝ : AddRightReflectLT α\na b : α\nha : LT.lt a 0\nhb : LT.lt b 0\n⊢ LT.lt 0 (HMul.hMul a b)","decl":"theorem mul_pos_of_neg_of_neg [ExistsAddOfLE α] [MulPosStrictMono α]\n    [AddRightStrictMono α] [AddRightReflectLT α]\n    {a b : α} (ha : a < 0) (hb : b < 0) : 0 < a * b := by\n  simpa only [zero_mul] using mul_lt_mul_of_neg_right ha hb\n\n"}
{"name":"lt_mul_of_lt_one_left","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : PartialOrder α\na b : α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddRightStrictMono α\ninst✝ : AddRightReflectLT α\nhb : LT.lt b 0\nh : LT.lt a 1\n⊢ LT.lt b (HMul.hMul a b)","decl":"/-- Variant of `mul_lt_of_lt_one_left` for `b` negative instead of positive. -/\ntheorem lt_mul_of_lt_one_left [ExistsAddOfLE α] [MulPosStrictMono α]\n    [AddRightStrictMono α] [AddRightReflectLT α]\n    (hb : b < 0) (h : a < 1) : b < a * b := by\n  simpa only [one_mul] using mul_lt_mul_of_neg_right h hb\n\n"}
{"name":"mul_lt_of_one_lt_left","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : PartialOrder α\na b : α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddRightStrictMono α\ninst✝ : AddRightReflectLT α\nhb : LT.lt b 0\nh : LT.lt 1 a\n⊢ LT.lt (HMul.hMul a b) b","decl":"/-- Variant of `lt_mul_of_one_lt_left` for `b` negative instead of positive. -/\ntheorem mul_lt_of_one_lt_left [ExistsAddOfLE α] [MulPosStrictMono α]\n    [AddRightStrictMono α] [AddRightReflectLT α]\n    (hb : b < 0) (h : 1 < a) : a * b < b := by\n  simpa only [one_mul] using mul_lt_mul_of_neg_right h hb\n\n"}
{"name":"lt_mul_of_lt_one_right","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : PartialOrder α\na b : α\ninst✝³ : ExistsAddOfLE α\ninst✝² : PosMulStrictMono α\ninst✝¹ : AddRightStrictMono α\ninst✝ : AddRightReflectLT α\nha : LT.lt a 0\nh : LT.lt b 1\n⊢ LT.lt a (HMul.hMul a b)","decl":"/-- Variant of `mul_lt_of_lt_one_right` for `a` negative instead of positive. -/\ntheorem lt_mul_of_lt_one_right [ExistsAddOfLE α] [PosMulStrictMono α]\n    [AddRightStrictMono α] [AddRightReflectLT α]\n    (ha : a < 0) (h : b < 1) : a < a * b := by\n  simpa only [mul_one] using mul_lt_mul_of_neg_left h ha\n\n"}
{"name":"mul_lt_of_one_lt_right","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : PartialOrder α\na b : α\ninst✝³ : ExistsAddOfLE α\ninst✝² : PosMulStrictMono α\ninst✝¹ : AddRightStrictMono α\ninst✝ : AddRightReflectLT α\nha : LT.lt a 0\nh : LT.lt 1 b\n⊢ LT.lt (HMul.hMul a b) a","decl":"/-- Variant of `lt_mul_of_lt_one_right` for `a` negative instead of positive. -/\ntheorem mul_lt_of_one_lt_right [ExistsAddOfLE α] [PosMulStrictMono α]\n    [AddRightStrictMono α] [AddRightReflectLT α]\n    (ha : a < 0) (h : 1 < b) : a * b < a := by\n  simpa only [mul_one] using mul_lt_mul_of_neg_left h ha\n\n"}
{"name":"strictAnti_mul_left","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : PartialOrder α\ninst✝³ : ExistsAddOfLE α\ninst✝² : PosMulStrictMono α\ninst✝¹ : AddRightStrictMono α\ninst✝ : AddRightReflectLT α\na : α\nha : LT.lt a 0\n⊢ StrictAnti fun x => HMul.hMul a x","decl":"theorem strictAnti_mul_left [ExistsAddOfLE α] [PosMulStrictMono α]\n    [AddRightStrictMono α] [AddRightReflectLT α]\n    {a : α} (ha : a < 0) : StrictAnti (a * ·) := fun _ _ b_lt_c =>\n  mul_lt_mul_of_neg_left b_lt_c ha\n\n"}
{"name":"strictAnti_mul_right","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : PartialOrder α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddRightStrictMono α\ninst✝ : AddRightReflectLT α\na : α\nha : LT.lt a 0\n⊢ StrictAnti fun x => HMul.hMul x a","decl":"theorem strictAnti_mul_right [ExistsAddOfLE α] [MulPosStrictMono α]\n    [AddRightStrictMono α] [AddRightReflectLT α]\n    {a : α} (ha : a < 0) : StrictAnti fun x => x * a := fun _ _ b_lt_c =>\n  mul_lt_mul_of_neg_right b_lt_c ha\n\n"}
{"name":"StrictMono.const_mul_of_neg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\nβ : Type u_1\ninst✝⁶ : Semiring α\ninst✝⁵ : PartialOrder α\na : α\ninst✝⁴ : Preorder β\nf : β → α\ninst✝³ : ExistsAddOfLE α\ninst✝² : PosMulStrictMono α\ninst✝¹ : AddRightStrictMono α\ninst✝ : AddRightReflectLT α\nhf : StrictMono f\nha : LT.lt a 0\n⊢ StrictAnti fun x => HMul.hMul a (f x)","decl":"theorem StrictMono.const_mul_of_neg [ExistsAddOfLE α] [PosMulStrictMono α]\n    [AddRightStrictMono α] [AddRightReflectLT α]\n    (hf : StrictMono f) (ha : a < 0) : StrictAnti fun x => a * f x :=\n  (strictAnti_mul_left ha).comp_strictMono hf\n\n"}
{"name":"StrictMono.mul_const_of_neg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\nβ : Type u_1\ninst✝⁶ : Semiring α\ninst✝⁵ : PartialOrder α\na : α\ninst✝⁴ : Preorder β\nf : β → α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddRightStrictMono α\ninst✝ : AddRightReflectLT α\nhf : StrictMono f\nha : LT.lt a 0\n⊢ StrictAnti fun x => HMul.hMul (f x) a","decl":"theorem StrictMono.mul_const_of_neg [ExistsAddOfLE α] [MulPosStrictMono α]\n    [AddRightStrictMono α] [AddRightReflectLT α]\n    (hf : StrictMono f) (ha : a < 0) : StrictAnti fun x => f x * a :=\n  (strictAnti_mul_right ha).comp_strictMono hf\n\n"}
{"name":"StrictAnti.const_mul_of_neg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\nβ : Type u_1\ninst✝⁶ : Semiring α\ninst✝⁵ : PartialOrder α\na : α\ninst✝⁴ : Preorder β\nf : β → α\ninst✝³ : ExistsAddOfLE α\ninst✝² : PosMulStrictMono α\ninst✝¹ : AddRightStrictMono α\ninst✝ : AddRightReflectLT α\nhf : StrictAnti f\nha : LT.lt a 0\n⊢ StrictMono fun x => HMul.hMul a (f x)","decl":"theorem StrictAnti.const_mul_of_neg [ExistsAddOfLE α] [PosMulStrictMono α]\n    [AddRightStrictMono α] [AddRightReflectLT α]\n    (hf : StrictAnti f) (ha : a < 0) : StrictMono fun x => a * f x :=\n  (strictAnti_mul_left ha).comp hf\n\n"}
{"name":"StrictAnti.mul_const_of_neg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\nβ : Type u_1\ninst✝⁶ : Semiring α\ninst✝⁵ : PartialOrder α\na : α\ninst✝⁴ : Preorder β\nf : β → α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddRightStrictMono α\ninst✝ : AddRightReflectLT α\nhf : StrictAnti f\nha : LT.lt a 0\n⊢ StrictMono fun x => HMul.hMul (f x) a","decl":"theorem StrictAnti.mul_const_of_neg [ExistsAddOfLE α] [MulPosStrictMono α]\n    [AddRightStrictMono α] [AddRightReflectLT α]\n    (hf : StrictAnti f) (ha : a < 0) : StrictMono fun x => f x * a :=\n  (strictAnti_mul_right ha).comp hf\n\n"}
{"name":"mul_add_mul_le_mul_add_mul","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : PartialOrder α\na b c d : α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosMono α\ninst✝¹ : AddLeftMono α\ninst✝ : AddLeftReflectLE α\nhab : LE.le a b\nhcd : LE.le c d\n⊢ LE.le (HAdd.hAdd (HMul.hMul a d) (HMul.hMul b c)) (HAdd.hAdd (HMul.hMul a c) (HMul.hMul b d))","decl":"/-- Binary **rearrangement inequality**. -/\nlemma mul_add_mul_le_mul_add_mul [ExistsAddOfLE α] [MulPosMono α]\n    [AddLeftMono α] [AddLeftReflectLE α]\n    (hab : a ≤ b) (hcd : c ≤ d) : a * d + b * c ≤ a * c + b * d := by\n  obtain ⟨b, rfl⟩ := exists_add_of_le hab\n  obtain ⟨d, hd, rfl⟩ := exists_nonneg_add_of_le hcd\n  rw [mul_add, add_right_comm, mul_add, ← add_assoc]\n  exact add_le_add_left (mul_le_mul_of_nonneg_right hab hd) _\n\n"}
{"name":"mul_add_mul_le_mul_add_mul'","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : PartialOrder α\na b c d : α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosMono α\ninst✝¹ : AddLeftMono α\ninst✝ : AddLeftReflectLE α\nhba : LE.le b a\nhdc : LE.le d c\n⊢ LE.le (HAdd.hAdd (HMul.hMul a d) (HMul.hMul b c)) (HAdd.hAdd (HMul.hMul a c) (HMul.hMul b d))","decl":"/-- Binary **rearrangement inequality**. -/\nlemma mul_add_mul_le_mul_add_mul' [ExistsAddOfLE α] [MulPosMono α]\n    [AddLeftMono α] [AddLeftReflectLE α]\n    (hba : b ≤ a) (hdc : d ≤ c) : a * d + b * c ≤ a * c + b * d := by\n  rw [add_comm (a * d), add_comm (a * c)]; exact mul_add_mul_le_mul_add_mul hba hdc\n\n"}
{"name":"mul_add_mul_lt_mul_add_mul","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : PartialOrder α\na b c d : α\ninst✝³ : AddLeftReflectLT α\ninst✝² : ExistsAddOfLE α\ninst✝¹ : MulPosStrictMono α\ninst✝ : AddLeftStrictMono α\nhab : LT.lt a b\nhcd : LT.lt c d\n⊢ LT.lt (HAdd.hAdd (HMul.hMul a d) (HMul.hMul b c)) (HAdd.hAdd (HMul.hMul a c) (HMul.hMul b d))","decl":"/-- Binary strict **rearrangement inequality**. -/\nlemma mul_add_mul_lt_mul_add_mul [ExistsAddOfLE α] [MulPosStrictMono α]\n    [AddLeftStrictMono α]\n    (hab : a < b) (hcd : c < d) : a * d + b * c < a * c + b * d := by\n  obtain ⟨b, rfl⟩ := exists_add_of_le hab.le\n  obtain ⟨d, hd, rfl⟩ := exists_pos_add_of_lt' hcd\n  rw [mul_add, add_right_comm, mul_add, ← add_assoc]\n  exact add_lt_add_left (mul_lt_mul_of_pos_right hab hd) _\n\n"}
{"name":"mul_add_mul_lt_mul_add_mul'","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : PartialOrder α\na b c d : α\ninst✝³ : AddLeftReflectLT α\ninst✝² : ExistsAddOfLE α\ninst✝¹ : MulPosStrictMono α\ninst✝ : AddLeftStrictMono α\nhba : LT.lt b a\nhdc : LT.lt d c\n⊢ LT.lt (HAdd.hAdd (HMul.hMul a d) (HMul.hMul b c)) (HAdd.hAdd (HMul.hMul a c) (HMul.hMul b d))","decl":"/-- Binary **rearrangement inequality**. -/\nlemma mul_add_mul_lt_mul_add_mul' [ExistsAddOfLE α] [MulPosStrictMono α]\n    [AddLeftStrictMono α]\n    (hba : b < a) (hdc : d < c) : a * d + b * c < a * c + b * d := by\n  rw [add_comm (a * d), add_comm (a * c)]\n  exact mul_add_mul_lt_mul_add_mul hba hdc\n\n"}
{"name":"nonneg_and_nonneg_or_nonpos_and_nonpos_of_mul_nonneg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝³ : Semiring α\ninst✝² : LinearOrder α\na b : α\ninst✝¹ : MulPosStrictMono α\ninst✝ : PosMulStrictMono α\nhab : LE.le 0 (HMul.hMul a b)\n⊢ Or (And (LE.le 0 a) (LE.le 0 b)) (And (LE.le a 0) (LE.le b 0))","decl":"theorem nonneg_and_nonneg_or_nonpos_and_nonpos_of_mul_nonneg\n    [MulPosStrictMono α] [PosMulStrictMono α]\n    (hab : 0 ≤ a * b) : 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0 := by\n  refine Decidable.or_iff_not_and_not.2 ?_\n  simp only [not_and, not_le]; intro ab nab; apply not_lt_of_le hab _\n  rcases lt_trichotomy 0 a with (ha | rfl | ha)\n  · exact mul_neg_of_pos_of_neg ha (ab ha.le)\n  · exact ((ab le_rfl).asymm (nab le_rfl)).elim\n  · exact mul_neg_of_neg_of_pos ha (nab ha.le)\n\n"}
{"name":"nonneg_of_mul_nonneg_left","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝² : Semiring α\ninst✝¹ : LinearOrder α\na b : α\ninst✝ : MulPosStrictMono α\nh : LE.le 0 (HMul.hMul a b)\nhb : LT.lt 0 b\n⊢ LE.le 0 a","decl":"theorem nonneg_of_mul_nonneg_left [MulPosStrictMono α]\n    (h : 0 ≤ a * b) (hb : 0 < b) : 0 ≤ a :=\n  le_of_not_gt fun ha => (mul_neg_of_neg_of_pos ha hb).not_le h\n\n"}
{"name":"nonneg_of_mul_nonneg_right","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝² : Semiring α\ninst✝¹ : LinearOrder α\na b : α\ninst✝ : PosMulStrictMono α\nh : LE.le 0 (HMul.hMul a b)\nha : LT.lt 0 a\n⊢ LE.le 0 b","decl":"theorem nonneg_of_mul_nonneg_right [PosMulStrictMono α]\n    (h : 0 ≤ a * b) (ha : 0 < a) : 0 ≤ b :=\n  le_of_not_gt fun hb => (mul_neg_of_pos_of_neg ha hb).not_le h\n\n"}
{"name":"nonpos_of_mul_nonpos_left","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝² : Semiring α\ninst✝¹ : LinearOrder α\na b : α\ninst✝ : PosMulStrictMono α\nh : LE.le (HMul.hMul a b) 0\nhb : LT.lt 0 b\n⊢ LE.le a 0","decl":"theorem nonpos_of_mul_nonpos_left [PosMulStrictMono α]\n    (h : a * b ≤ 0) (hb : 0 < b) : a ≤ 0 :=\n  le_of_not_gt fun ha : a > 0 => (mul_pos ha hb).not_le h\n\n"}
{"name":"nonpos_of_mul_nonpos_right","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝² : Semiring α\ninst✝¹ : LinearOrder α\na b : α\ninst✝ : PosMulStrictMono α\nh : LE.le (HMul.hMul a b) 0\nha : LT.lt 0 a\n⊢ LE.le b 0","decl":"theorem nonpos_of_mul_nonpos_right [PosMulStrictMono α]\n    (h : a * b ≤ 0) (ha : 0 < a) : b ≤ 0 :=\n  le_of_not_gt fun hb : b > 0 => (mul_pos ha hb).not_le h\n\n"}
{"name":"mul_nonneg_iff_of_pos_left","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝² : Semiring α\ninst✝¹ : LinearOrder α\nb c : α\ninst✝ : PosMulStrictMono α\nh : LT.lt 0 c\n⊢ Iff (LE.le 0 (HMul.hMul c b)) (LE.le 0 b)","decl":"@[simp]\ntheorem mul_nonneg_iff_of_pos_left [PosMulStrictMono α]\n    (h : 0 < c) : 0 ≤ c * b ↔ 0 ≤ b := by\n  convert mul_le_mul_left h\n  simp\n\n"}
{"name":"mul_nonneg_iff_of_pos_right","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝² : Semiring α\ninst✝¹ : LinearOrder α\nb c : α\ninst✝ : MulPosStrictMono α\nh : LT.lt 0 c\n⊢ Iff (LE.le 0 (HMul.hMul b c)) (LE.le 0 b)","decl":"@[simp]\ntheorem mul_nonneg_iff_of_pos_right [MulPosStrictMono α]\n    (h : 0 < c) : 0 ≤ b * c ↔ 0 ≤ b := by\n  simpa using (mul_le_mul_right h : 0 * c ≤ b * c ↔ 0 ≤ b)\n\n"}
{"name":"add_le_mul_of_left_le_right","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : LinearOrder α\na b : α\ninst✝³ : ZeroLEOneClass α\ninst✝² : NeZero 1\ninst✝¹ : MulPosStrictMono α\ninst✝ : AddLeftMono α\na2 : LE.le 2 a\nab : LE.le a b\n⊢ LE.le (HAdd.hAdd a b) (HMul.hMul a b)","decl":"theorem add_le_mul_of_left_le_right [ZeroLEOneClass α] [NeZero (R := α) 1]\n    [MulPosStrictMono α] [AddLeftMono α]\n    (a2 : 2 ≤ a) (ab : a ≤ b) : a + b ≤ a * b :=\n  have : 0 < b :=\n    calc\n      0 < 2 := zero_lt_two\n      _ ≤ a := a2\n      _ ≤ b := ab\n  calc\n    a + b ≤ b + b := add_le_add_right ab b\n    _ = 2 * b := (two_mul b).symm\n    _ ≤ a * b := (mul_le_mul_right this).mpr a2\n\n-- Porting note: we used to not need the type annotation on `(0 : α)` at the start of the `calc`.\n"}
{"name":"add_le_mul_of_right_le_left","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : LinearOrder α\na b : α\ninst✝³ : ZeroLEOneClass α\ninst✝² : NeZero 1\ninst✝¹ : AddLeftMono α\ninst✝ : PosMulStrictMono α\nb2 : LE.le 2 b\nba : LE.le b a\n⊢ LE.le (HAdd.hAdd a b) (HMul.hMul a b)","decl":"theorem add_le_mul_of_right_le_left [ZeroLEOneClass α] [NeZero (R := α) 1]\n    [AddLeftMono α] [PosMulStrictMono α]\n    (b2 : 2 ≤ b) (ba : b ≤ a) : a + b ≤ a * b :=\n  have : 0 < a :=\n    calc (0 : α)\n      _ < 2 := zero_lt_two\n      _ ≤ b := b2\n      _ ≤ a := ba\n  calc\n    a + b ≤ a + a := add_le_add_left ba a\n    _ = a * 2 := (mul_two a).symm\n    _ ≤ a * b := (mul_le_mul_left this).mpr b2\n\n"}
{"name":"add_le_mul","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁶ : Semiring α\ninst✝⁵ : LinearOrder α\na b : α\ninst✝⁴ : ZeroLEOneClass α\ninst✝³ : NeZero 1\ninst✝² : MulPosStrictMono α\ninst✝¹ : PosMulStrictMono α\ninst✝ : AddLeftMono α\na2 : LE.le 2 a\nb2 : LE.le 2 b\n⊢ LE.le (HAdd.hAdd a b) (HMul.hMul a b)","decl":"theorem add_le_mul [ZeroLEOneClass α] [NeZero (R := α) 1]\n    [MulPosStrictMono α] [PosMulStrictMono α] [AddLeftMono α]\n    (a2 : 2 ≤ a) (b2 : 2 ≤ b) : a + b ≤ a * b :=\n  if hab : a ≤ b then add_le_mul_of_left_le_right a2 hab\n  else add_le_mul_of_right_le_left b2 (le_of_not_le hab)\n\n"}
{"name":"add_le_mul'","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁶ : Semiring α\ninst✝⁵ : LinearOrder α\na b : α\ninst✝⁴ : ZeroLEOneClass α\ninst✝³ : NeZero 1\ninst✝² : MulPosStrictMono α\ninst✝¹ : PosMulStrictMono α\ninst✝ : AddLeftMono α\na2 : LE.le 2 a\nb2 : LE.le 2 b\n⊢ LE.le (HAdd.hAdd a b) (HMul.hMul b a)","decl":"theorem add_le_mul' [ZeroLEOneClass α] [NeZero (R := α) 1]\n    [MulPosStrictMono α] [PosMulStrictMono α] [AddLeftMono α]\n    (a2 : 2 ≤ a) (b2 : 2 ≤ b) : a + b ≤ b * a :=\n  (le_of_eq (add_comm _ _)).trans (add_le_mul b2 a2)\n\n"}
{"name":"mul_nonneg_iff_right_nonneg_of_pos","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝² : Semiring α\ninst✝¹ : LinearOrder α\na b : α\ninst✝ : PosMulStrictMono α\nha : LT.lt 0 a\n⊢ Iff (LE.le 0 (HMul.hMul a b)) (LE.le 0 b)","decl":"theorem mul_nonneg_iff_right_nonneg_of_pos [PosMulStrictMono α]\n    (ha : 0 < a) : 0 ≤ a * b ↔ 0 ≤ b :=\n  ⟨fun h => nonneg_of_mul_nonneg_right h ha, mul_nonneg ha.le⟩\n\n"}
{"name":"mul_nonneg_iff_left_nonneg_of_pos","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝³ : Semiring α\ninst✝² : LinearOrder α\na b : α\ninst✝¹ : PosMulStrictMono α\ninst✝ : MulPosStrictMono α\nhb : LT.lt 0 b\n⊢ Iff (LE.le 0 (HMul.hMul a b)) (LE.le 0 a)","decl":"theorem mul_nonneg_iff_left_nonneg_of_pos [PosMulStrictMono α] [MulPosStrictMono α]\n    (hb : 0 < b) : 0 ≤ a * b ↔ 0 ≤ a :=\n  ⟨fun h => nonneg_of_mul_nonneg_left h hb, fun h => mul_nonneg h hb.le⟩\n\n"}
{"name":"nonpos_of_mul_nonneg_left","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝² : Semiring α\ninst✝¹ : LinearOrder α\na b : α\ninst✝ : PosMulStrictMono α\nh : LE.le 0 (HMul.hMul a b)\nhb : LT.lt b 0\n⊢ LE.le a 0","decl":"theorem nonpos_of_mul_nonneg_left [PosMulStrictMono α]\n    (h : 0 ≤ a * b) (hb : b < 0) : a ≤ 0 :=\n  le_of_not_gt fun ha => absurd h (mul_neg_of_pos_of_neg ha hb).not_le\n\n"}
{"name":"nonpos_of_mul_nonneg_right","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝² : Semiring α\ninst✝¹ : LinearOrder α\na b : α\ninst✝ : MulPosStrictMono α\nh : LE.le 0 (HMul.hMul a b)\nha : LT.lt a 0\n⊢ LE.le b 0","decl":"theorem nonpos_of_mul_nonneg_right [MulPosStrictMono α]\n    (h : 0 ≤ a * b) (ha : a < 0) : b ≤ 0 :=\n  le_of_not_gt fun hb => absurd h (mul_neg_of_neg_of_pos ha hb).not_le\n\n"}
{"name":"Units.inv_pos","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁴ : Semiring α\ninst✝³ : LinearOrder α\ninst✝² : ZeroLEOneClass α\ninst✝¹ : NeZero 1\ninst✝ : PosMulStrictMono α\nu : Units α\n⊢ Iff (LT.lt 0 ↑(Inv.inv u)) (LT.lt 0 ↑u)","decl":"@[simp]\ntheorem Units.inv_pos\n    [ZeroLEOneClass α] [NeZero (R := α) 1] [PosMulStrictMono α]\n    {u : αˣ} : (0 : α) < ↑u⁻¹ ↔ (0 : α) < u :=\n  have : ∀ {u : αˣ}, (0 : α) < u → (0 : α) < ↑u⁻¹ := @fun u h =>\n    (mul_pos_iff_of_pos_left h).mp <| u.mul_inv.symm ▸ zero_lt_one\n  ⟨this, this⟩\n\n"}
{"name":"Units.inv_neg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : LinearOrder α\ninst✝³ : ZeroLEOneClass α\ninst✝² : NeZero 1\ninst✝¹ : MulPosMono α\ninst✝ : PosMulMono α\nu : Units α\n⊢ Iff (LT.lt (↑(Inv.inv u)) 0) (LT.lt (↑u) 0)","decl":"@[simp]\ntheorem Units.inv_neg\n    [ZeroLEOneClass α] [NeZero (R := α) 1] [MulPosMono α] [PosMulMono α]\n    {u : αˣ} : ↑u⁻¹ < (0 : α) ↔ ↑u < (0 : α) :=\n  have : ∀ {u : αˣ}, ↑u < (0 : α) → ↑u⁻¹ < (0 : α) := @fun u h =>\n    neg_of_mul_pos_right (u.mul_inv.symm ▸ zero_lt_one) h.le\n  ⟨this, this⟩\n\n"}
{"name":"cmp_mul_pos_left","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝² : Semiring α\ninst✝¹ : LinearOrder α\na : α\ninst✝ : PosMulStrictMono α\nha : LT.lt 0 a\nb c : α\n⊢ Eq (cmp (HMul.hMul a b) (HMul.hMul a c)) (cmp b c)","decl":"theorem cmp_mul_pos_left [PosMulStrictMono α]\n    (ha : 0 < a) (b c : α) : cmp (a * b) (a * c) = cmp b c :=\n  (strictMono_mul_left_of_pos ha).cmp_map_eq b c\n\n"}
{"name":"cmp_mul_pos_right","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝² : Semiring α\ninst✝¹ : LinearOrder α\na : α\ninst✝ : MulPosStrictMono α\nha : LT.lt 0 a\nb c : α\n⊢ Eq (cmp (HMul.hMul b a) (HMul.hMul c a)) (cmp b c)","decl":"theorem cmp_mul_pos_right [MulPosStrictMono α]\n    (ha : 0 < a) (b c : α) : cmp (b * a) (c * a) = cmp b c :=\n  (strictMono_mul_right_of_pos ha).cmp_map_eq b c\n\n"}
{"name":"mul_max_of_nonneg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝² : Semiring α\ninst✝¹ : LinearOrder α\na : α\ninst✝ : PosMulMono α\nb c : α\nha : LE.le 0 a\n⊢ Eq (HMul.hMul a (Max.max b c)) (Max.max (HMul.hMul a b) (HMul.hMul a c))","decl":"theorem mul_max_of_nonneg [PosMulMono α]\n    (b c : α) (ha : 0 ≤ a) : a * max b c = max (a * b) (a * c) :=\n  (monotone_mul_left_of_nonneg ha).map_max\n\n"}
{"name":"mul_min_of_nonneg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝² : Semiring α\ninst✝¹ : LinearOrder α\na : α\ninst✝ : PosMulMono α\nb c : α\nha : LE.le 0 a\n⊢ Eq (HMul.hMul a (Min.min b c)) (Min.min (HMul.hMul a b) (HMul.hMul a c))","decl":"theorem mul_min_of_nonneg [PosMulMono α]\n    (b c : α) (ha : 0 ≤ a) : a * min b c = min (a * b) (a * c) :=\n  (monotone_mul_left_of_nonneg ha).map_min\n\n"}
{"name":"max_mul_of_nonneg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝² : Semiring α\ninst✝¹ : LinearOrder α\nc : α\ninst✝ : MulPosMono α\na b : α\nhc : LE.le 0 c\n⊢ Eq (HMul.hMul (Max.max a b) c) (Max.max (HMul.hMul a c) (HMul.hMul b c))","decl":"theorem max_mul_of_nonneg [MulPosMono α]\n    (a b : α) (hc : 0 ≤ c) : max a b * c = max (a * c) (b * c) :=\n  (monotone_mul_right_of_nonneg hc).map_max\n\n"}
{"name":"min_mul_of_nonneg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝² : Semiring α\ninst✝¹ : LinearOrder α\nc : α\ninst✝ : MulPosMono α\na b : α\nhc : LE.le 0 c\n⊢ Eq (HMul.hMul (Min.min a b) c) (Min.min (HMul.hMul a c) (HMul.hMul b c))","decl":"theorem min_mul_of_nonneg [MulPosMono α]\n    (a b : α) (hc : 0 ≤ c) : min a b * c = min (a * c) (b * c) :=\n  (monotone_mul_right_of_nonneg hc).map_min\n\n"}
{"name":"le_of_mul_le_of_one_le","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : LinearOrder α\ninst✝³ : ZeroLEOneClass α\ninst✝² : NeZero 1\ninst✝¹ : MulPosStrictMono α\ninst✝ : PosMulMono α\na b c : α\nh : LE.le (HMul.hMul a c) b\nhb : LE.le 0 b\nhc : LE.le 1 c\n⊢ LE.le a b","decl":"theorem le_of_mul_le_of_one_le\n    [ZeroLEOneClass α] [NeZero (R := α) 1] [MulPosStrictMono α] [PosMulMono α]\n    {a b c : α} (h : a * c ≤ b) (hb : 0 ≤ b) (hc : 1 ≤ c) : a ≤ b :=\n  le_of_mul_le_mul_right (h.trans <| le_mul_of_one_le_right hb hc) <| zero_lt_one.trans_le hc\n\n"}
{"name":"nonneg_le_nonneg_of_sq_le_sq","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝³ : Semiring α\ninst✝² : LinearOrder α\ninst✝¹ : PosMulStrictMono α\ninst✝ : MulPosMono α\na b : α\nhb : LE.le 0 b\nh : LE.le (HMul.hMul a a) (HMul.hMul b b)\n⊢ LE.le a b","decl":"theorem nonneg_le_nonneg_of_sq_le_sq [PosMulStrictMono α] [MulPosMono α]\n    {a b : α} (hb : 0 ≤ b) (h : a * a ≤ b * b) : a ≤ b :=\n  le_of_not_gt fun hab => (mul_self_lt_mul_self hb hab).not_le h\n\n"}
{"name":"mul_self_le_mul_self_iff","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝³ : Semiring α\ninst✝² : LinearOrder α\ninst✝¹ : PosMulStrictMono α\ninst✝ : MulPosMono α\na b : α\nh1 : LE.le 0 a\nh2 : LE.le 0 b\n⊢ Iff (LE.le a b) (LE.le (HMul.hMul a a) (HMul.hMul b b))","decl":"theorem mul_self_le_mul_self_iff [PosMulStrictMono α] [MulPosMono α]\n    {a b : α} (h1 : 0 ≤ a) (h2 : 0 ≤ b) : a ≤ b ↔ a * a ≤ b * b :=\n  ⟨mul_self_le_mul_self h1, nonneg_le_nonneg_of_sq_le_sq h2⟩\n\n"}
{"name":"mul_self_lt_mul_self_iff","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝³ : Semiring α\ninst✝² : LinearOrder α\ninst✝¹ : PosMulStrictMono α\ninst✝ : MulPosMono α\na b : α\nh1 : LE.le 0 a\nh2 : LE.le 0 b\n⊢ Iff (LT.lt a b) (LT.lt (HMul.hMul a a) (HMul.hMul b b))","decl":"theorem mul_self_lt_mul_self_iff [PosMulStrictMono α] [MulPosMono α]\n    {a b : α} (h1 : 0 ≤ a) (h2 : 0 ≤ b) : a < b ↔ a * a < b * b :=\n  ((@strictMonoOn_mul_self α _).lt_iff_lt h1 h2).symm\n\n"}
{"name":"mul_self_inj","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝³ : Semiring α\ninst✝² : LinearOrder α\ninst✝¹ : PosMulStrictMono α\ninst✝ : MulPosMono α\na b : α\nh1 : LE.le 0 a\nh2 : LE.le 0 b\n⊢ Iff (Eq (HMul.hMul a a) (HMul.hMul b b)) (Eq a b)","decl":"theorem mul_self_inj [PosMulStrictMono α] [MulPosMono α]\n    {a b : α} (h1 : 0 ≤ a) (h2 : 0 ≤ b) : a * a = b * b ↔ a = b :=\n  (@strictMonoOn_mul_self α _).eq_iff_eq h1 h2\n\n"}
{"name":"sign_cases_of_C_mul_pow_nonneg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝² : Semiring α\ninst✝¹ : LinearOrder α\na b : α\ninst✝ : PosMulStrictMono α\nh : ∀ (n : Nat), LE.le 0 (HMul.hMul a (HPow.hPow b n))\n⊢ Or (Eq a 0) (And (LT.lt 0 a) (LE.le 0 b))","decl":"lemma sign_cases_of_C_mul_pow_nonneg [PosMulStrictMono α]\n    (h : ∀ n, 0 ≤ a * b ^ n) : a = 0 ∨ 0 < a ∧ 0 ≤ b := by\n  have : 0 ≤ a := by simpa only [pow_zero, mul_one] using h 0\n  refine this.eq_or_gt.imp_right fun ha ↦ ⟨ha, nonneg_of_mul_nonneg_right ?_ ha⟩\n  simpa only [pow_one] using h 1\n\n"}
{"name":"mul_pos_iff","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁶ : Semiring α\ninst✝⁵ : LinearOrder α\na b : α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : PosMulStrictMono α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddLeftReflectLT α\n⊢ Iff (LT.lt 0 (HMul.hMul a b)) (Or (And (LT.lt 0 a) (LT.lt 0 b)) (And (LT.lt a 0) (LT.lt b 0)))","decl":"theorem mul_pos_iff [ExistsAddOfLE α] [PosMulStrictMono α] [MulPosStrictMono α]\n    [AddLeftStrictMono α] [AddLeftReflectLT α] :\n    0 < a * b ↔ 0 < a ∧ 0 < b ∨ a < 0 ∧ b < 0 :=\n  ⟨pos_and_pos_or_neg_and_neg_of_mul_pos, fun h =>\n    h.elim (and_imp.2 mul_pos) (and_imp.2 mul_pos_of_neg_of_neg)⟩\n\n"}
{"name":"mul_nonneg_iff","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁶ : Semiring α\ninst✝⁵ : LinearOrder α\na b : α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : MulPosStrictMono α\ninst✝² : PosMulStrictMono α\ninst✝¹ : AddLeftReflectLE α\ninst✝ : AddLeftMono α\n⊢ Iff (LE.le 0 (HMul.hMul a b)) (Or (And (LE.le 0 a) (LE.le 0 b)) (And (LE.le a 0) (LE.le b 0)))","decl":"theorem mul_nonneg_iff [ExistsAddOfLE α] [MulPosStrictMono α] [PosMulStrictMono α]\n    [AddLeftReflectLE α] [AddLeftMono α]:\n    0 ≤ a * b ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0 :=\n  ⟨nonneg_and_nonneg_or_nonpos_and_nonpos_of_mul_nonneg, fun h =>\n    h.elim (and_imp.2 mul_nonneg) (and_imp.2 mul_nonneg_of_nonpos_of_nonpos)⟩\n\n"}
{"name":"mul_nonneg_of_three","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁶ : Semiring α\ninst✝⁵ : LinearOrder α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : MulPosStrictMono α\ninst✝² : PosMulStrictMono α\ninst✝¹ : AddLeftMono α\ninst✝ : AddLeftReflectLE α\na b c : α\n⊢ Or (LE.le 0 (HMul.hMul a b)) (Or (LE.le 0 (HMul.hMul b c)) (LE.le 0 (HMul.hMul c a)))","decl":"/-- Out of three elements of a `LinearOrderedRing`, two must have the same sign. -/\ntheorem mul_nonneg_of_three [ExistsAddOfLE α] [MulPosStrictMono α] [PosMulStrictMono α]\n    [AddLeftMono α] [AddLeftReflectLE α]\n    (a b c : α) : 0 ≤ a * b ∨ 0 ≤ b * c ∨ 0 ≤ c * a := by\n  iterate 3 rw [mul_nonneg_iff]\n  have or_a := le_total 0 a\n  have or_b := le_total 0 b\n  have or_c := le_total 0 c\n  aesop\n\n"}
{"name":"mul_nonneg_iff_pos_imp_nonneg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁶ : Semiring α\ninst✝⁵ : LinearOrder α\na b : α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : PosMulStrictMono α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddLeftMono α\ninst✝ : AddLeftReflectLE α\n⊢ Iff (LE.le 0 (HMul.hMul a b)) (And (LT.lt 0 a → LE.le 0 b) (LT.lt 0 b → LE.le 0 a))","decl":"lemma mul_nonneg_iff_pos_imp_nonneg [ExistsAddOfLE α] [PosMulStrictMono α] [MulPosStrictMono α]\n    [AddLeftMono α] [AddLeftReflectLE α] :\n    0 ≤ a * b ↔ (0 < a → 0 ≤ b) ∧ (0 < b → 0 ≤ a) := by\n  refine mul_nonneg_iff.trans ?_\n  simp_rw [← not_le, ← or_iff_not_imp_left]\n  have := le_total a 0\n  have := le_total b 0\n  tauto\n\n"}
{"name":"mul_le_mul_left_of_neg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : LinearOrder α\ninst✝³ : ExistsAddOfLE α\ninst✝² : PosMulStrictMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\na b c : α\nh : LT.lt c 0\n⊢ Iff (LE.le (HMul.hMul c a) (HMul.hMul c b)) (LE.le b a)","decl":"@[simp]\ntheorem mul_le_mul_left_of_neg [ExistsAddOfLE α] [PosMulStrictMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    {a b c : α} (h : c < 0) : c * a ≤ c * b ↔ b ≤ a :=\n  (strictAnti_mul_left h).le_iff_le\n\n"}
{"name":"mul_le_mul_right_of_neg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : LinearOrder α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\na b c : α\nh : LT.lt c 0\n⊢ Iff (LE.le (HMul.hMul a c) (HMul.hMul b c)) (LE.le b a)","decl":"@[simp]\ntheorem mul_le_mul_right_of_neg [ExistsAddOfLE α] [MulPosStrictMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    {a b c : α} (h : c < 0) : a * c ≤ b * c ↔ b ≤ a :=\n  (strictAnti_mul_right h).le_iff_le\n\n"}
{"name":"mul_lt_mul_left_of_neg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : LinearOrder α\ninst✝³ : ExistsAddOfLE α\ninst✝² : PosMulStrictMono α\ninst✝¹ : AddRightStrictMono α\ninst✝ : AddRightReflectLT α\na b c : α\nh : LT.lt c 0\n⊢ Iff (LT.lt (HMul.hMul c a) (HMul.hMul c b)) (LT.lt b a)","decl":"@[simp]\ntheorem mul_lt_mul_left_of_neg [ExistsAddOfLE α] [PosMulStrictMono α]\n    [AddRightStrictMono α] [AddRightReflectLT α]\n    {a b c : α} (h : c < 0) : c * a < c * b ↔ b < a :=\n  (strictAnti_mul_left h).lt_iff_lt\n\n"}
{"name":"mul_lt_mul_right_of_neg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : LinearOrder α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddRightStrictMono α\ninst✝ : AddRightReflectLT α\na b c : α\nh : LT.lt c 0\n⊢ Iff (LT.lt (HMul.hMul a c) (HMul.hMul b c)) (LT.lt b a)","decl":"@[simp]\ntheorem mul_lt_mul_right_of_neg [ExistsAddOfLE α] [MulPosStrictMono α]\n    [AddRightStrictMono α] [AddRightReflectLT α]\n    {a b c : α} (h : c < 0) : a * c < b * c ↔ b < a :=\n  (strictAnti_mul_right h).lt_iff_lt\n\n"}
{"name":"lt_of_mul_lt_mul_of_nonpos_left","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : LinearOrder α\na b c : α\ninst✝³ : ExistsAddOfLE α\ninst✝² : PosMulMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nh : LT.lt (HMul.hMul c a) (HMul.hMul c b)\nhc : LE.le c 0\n⊢ LT.lt b a","decl":"theorem lt_of_mul_lt_mul_of_nonpos_left [ExistsAddOfLE α] [PosMulMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (h : c * a < c * b) (hc : c ≤ 0) : b < a :=\n  (antitone_mul_left hc).reflect_lt h\n\n"}
{"name":"lt_of_mul_lt_mul_of_nonpos_right","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : LinearOrder α\na b c : α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nh : LT.lt (HMul.hMul a c) (HMul.hMul b c)\nhc : LE.le c 0\n⊢ LT.lt b a","decl":"theorem lt_of_mul_lt_mul_of_nonpos_right [ExistsAddOfLE α] [MulPosMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (h : a * c < b * c) (hc : c ≤ 0) : b < a :=\n  (antitone_mul_right hc).reflect_lt h\n\n"}
{"name":"cmp_mul_neg_left","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : LinearOrder α\ninst✝³ : ExistsAddOfLE α\ninst✝² : PosMulStrictMono α\ninst✝¹ : AddRightReflectLT α\ninst✝ : AddRightStrictMono α\na : α\nha : LT.lt a 0\nb c : α\n⊢ Eq (cmp (HMul.hMul a b) (HMul.hMul a c)) (cmp c b)","decl":"theorem cmp_mul_neg_left [ExistsAddOfLE α] [PosMulStrictMono α]\n    [AddRightReflectLT α] [AddRightStrictMono α]\n    {a : α} (ha : a < 0) (b c : α) : cmp (a * b) (a * c) = cmp c b :=\n  (strictAnti_mul_left ha).cmp_map_eq b c\n\n"}
{"name":"cmp_mul_neg_right","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : LinearOrder α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddRightReflectLT α\ninst✝ : AddRightStrictMono α\na : α\nha : LT.lt a 0\nb c : α\n⊢ Eq (cmp (HMul.hMul b a) (HMul.hMul c a)) (cmp c b)","decl":"theorem cmp_mul_neg_right [ExistsAddOfLE α] [MulPosStrictMono α]\n    [AddRightReflectLT α] [AddRightStrictMono α]\n    {a : α} (ha : a < 0) (b c : α) : cmp (b * a) (c * a) = cmp c b :=\n  (strictAnti_mul_right ha).cmp_map_eq b c\n\n"}
{"name":"mul_self_pos","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁶ : Semiring α\ninst✝⁵ : LinearOrder α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : PosMulStrictMono α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddLeftStrictMono α\ninst✝ : AddLeftReflectLT α\na : α\n⊢ Iff (LT.lt 0 (HMul.hMul a a)) (Ne a 0)","decl":"@[simp]\ntheorem mul_self_pos [ExistsAddOfLE α] [PosMulStrictMono α] [MulPosStrictMono α]\n    [AddLeftStrictMono α] [AddLeftReflectLT α]\n    {a : α} : 0 < a * a ↔ a ≠ 0 := by\n  constructor\n  · rintro h rfl\n    rw [mul_zero] at h\n    exact h.false\n  · intro h\n    rcases h.lt_or_lt with h | h\n    exacts [mul_pos_of_neg_of_neg h h, mul_pos h h]\n\n"}
{"name":"nonneg_of_mul_nonpos_left","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : LinearOrder α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\na b : α\nh : LE.le (HMul.hMul a b) 0\nhb : LT.lt b 0\n⊢ LE.le 0 a","decl":"theorem nonneg_of_mul_nonpos_left [ExistsAddOfLE α] [MulPosStrictMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    {a b : α} (h : a * b ≤ 0) (hb : b < 0) : 0 ≤ a :=\n  le_of_not_gt fun ha => absurd h (mul_pos_of_neg_of_neg ha hb).not_le\n\n"}
{"name":"nonneg_of_mul_nonpos_right","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : LinearOrder α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\na b : α\nh : LE.le (HMul.hMul a b) 0\nha : LT.lt a 0\n⊢ LE.le 0 b","decl":"theorem nonneg_of_mul_nonpos_right [ExistsAddOfLE α] [MulPosStrictMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    {a b : α} (h : a * b ≤ 0) (ha : a < 0) : 0 ≤ b :=\n  le_of_not_gt fun hb => absurd h (mul_pos_of_neg_of_neg ha hb).not_le\n\n"}
{"name":"pos_of_mul_neg_left","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : LinearOrder α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\na b : α\nh : LT.lt (HMul.hMul a b) 0\nhb : LE.le b 0\n⊢ LT.lt 0 a","decl":"theorem pos_of_mul_neg_left [ExistsAddOfLE α] [MulPosMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    {a b : α} (h : a * b < 0) (hb : b ≤ 0) : 0 < a :=\n  lt_of_not_ge fun ha => absurd h (mul_nonneg_of_nonpos_of_nonpos ha hb).not_lt\n\n"}
{"name":"pos_of_mul_neg_right","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Semiring α\ninst✝⁴ : LinearOrder α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\na b : α\nh : LT.lt (HMul.hMul a b) 0\nha : LE.le a 0\n⊢ LT.lt 0 b","decl":"theorem pos_of_mul_neg_right [ExistsAddOfLE α] [MulPosMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    {a b : α} (h : a * b < 0) (ha : a ≤ 0) : 0 < b :=\n  lt_of_not_ge fun hb => absurd h (mul_nonneg_of_nonpos_of_nonpos ha hb).not_lt\n\n"}
{"name":"neg_iff_pos_of_mul_neg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁶ : Semiring α\ninst✝⁵ : LinearOrder α\na b : α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : PosMulMono α\ninst✝² : MulPosMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nhab : LT.lt (HMul.hMul a b) 0\n⊢ Iff (LT.lt a 0) (LT.lt 0 b)","decl":"theorem neg_iff_pos_of_mul_neg [ExistsAddOfLE α] [PosMulMono α] [MulPosMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (hab : a * b < 0) : a < 0 ↔ 0 < b :=\n  ⟨pos_of_mul_neg_right hab ∘ le_of_lt, neg_of_mul_neg_left hab ∘ le_of_lt⟩\n\n"}
{"name":"pos_iff_neg_of_mul_neg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁶ : Semiring α\ninst✝⁵ : LinearOrder α\na b : α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : PosMulMono α\ninst✝² : MulPosMono α\ninst✝¹ : AddRightMono α\ninst✝ : AddRightReflectLE α\nhab : LT.lt (HMul.hMul a b) 0\n⊢ Iff (LT.lt 0 a) (LT.lt b 0)","decl":"theorem pos_iff_neg_of_mul_neg [ExistsAddOfLE α] [PosMulMono α] [MulPosMono α]\n    [AddRightMono α] [AddRightReflectLE α]\n    (hab : a * b < 0) : 0 < a ↔ b < 0 :=\n  ⟨neg_of_mul_neg_right hab ∘ le_of_lt, pos_of_mul_neg_left hab ∘ le_of_lt⟩\n\n"}
{"name":"sq_nonneg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁶ : Semiring α\ninst✝⁵ : LinearOrder α\ninst✝⁴ : IsRightCancelAdd α\ninst✝³ : ZeroLEOneClass α\ninst✝² : ExistsAddOfLE α\ninst✝¹ : PosMulMono α\ninst✝ : AddLeftStrictMono α\na : α\n⊢ LE.le 0 (HPow.hPow a 2)","decl":"lemma sq_nonneg [IsRightCancelAdd α]\n    [ZeroLEOneClass α] [ExistsAddOfLE α] [PosMulMono α] [AddLeftStrictMono α]\n    (a : α) : 0 ≤ a ^ 2 := by\n  obtain ha | ha := le_total 0 a\n  · exact pow_nonneg ha _\n  obtain ⟨b, hab⟩ := exists_add_of_le ha\n  calc\n    0 ≤ b ^ 2 := pow_nonneg (not_lt.1 fun hb ↦ hab.not_gt <| add_neg_of_nonpos_of_neg ha hb) _\n    _ = a ^ 2 := add_left_injective (a * b) ?_\n  calc\n    b ^ 2 + a * b = (a + b) * b := by rw [add_comm, sq, add_mul]\n    _ = a * (a + b) := by simp [← hab]\n    _ = a ^ 2 + a * b := by rw [sq, mul_add]\n\n"}
{"name":"pow_two_nonneg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁶ : Semiring α\ninst✝⁵ : LinearOrder α\ninst✝⁴ : IsRightCancelAdd α\ninst✝³ : ZeroLEOneClass α\ninst✝² : ExistsAddOfLE α\ninst✝¹ : PosMulMono α\ninst✝ : AddLeftStrictMono α\na : α\n⊢ LE.le 0 (HPow.hPow a 2)","decl":"alias pow_two_nonneg := sq_nonneg\n\n"}
{"name":"mul_self_nonneg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁶ : Semiring α\ninst✝⁵ : LinearOrder α\ninst✝⁴ : IsRightCancelAdd α\ninst✝³ : ZeroLEOneClass α\ninst✝² : ExistsAddOfLE α\ninst✝¹ : PosMulMono α\ninst✝ : AddLeftStrictMono α\na : α\n⊢ LE.le 0 (HMul.hMul a a)","decl":"lemma mul_self_nonneg [IsRightCancelAdd α]\n    [ZeroLEOneClass α] [ExistsAddOfLE α] [PosMulMono α] [AddLeftStrictMono α]\n    (a : α) : 0 ≤ a * a := by simpa only [sq] using sq_nonneg a\n\n"}
{"name":"mul_self_add_mul_self_eq_zero","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁸ : Semiring α\ninst✝⁷ : LinearOrder α\na b : α\ninst✝⁶ : IsRightCancelAdd α\ninst✝⁵ : NoZeroDivisors α\ninst✝⁴ : ZeroLEOneClass α\ninst✝³ : ExistsAddOfLE α\ninst✝² : PosMulMono α\ninst✝¹ : AddLeftMono α\ninst✝ : AddLeftStrictMono α\n⊢ Iff (Eq (HAdd.hAdd (HMul.hMul a a) (HMul.hMul b b)) 0) (And (Eq a 0) (Eq b 0))","decl":"/-- The sum of two squares is zero iff both elements are zero. -/\nlemma mul_self_add_mul_self_eq_zero [IsRightCancelAdd α] [NoZeroDivisors α]\n    [ZeroLEOneClass α] [ExistsAddOfLE α] [PosMulMono α]\n    [AddLeftMono α] [AddLeftStrictMono α] :\n    a * a + b * b = 0 ↔ a = 0 ∧ b = 0 := by\n  rw [add_eq_zero_iff_of_nonneg, mul_self_eq_zero (M₀ := α), mul_self_eq_zero (M₀ := α)] <;>\n    apply mul_self_nonneg\n\n"}
{"name":"eq_zero_of_mul_self_add_mul_self_eq_zero","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁸ : Semiring α\ninst✝⁷ : LinearOrder α\na b : α\ninst✝⁶ : IsRightCancelAdd α\ninst✝⁵ : NoZeroDivisors α\ninst✝⁴ : ZeroLEOneClass α\ninst✝³ : ExistsAddOfLE α\ninst✝² : PosMulMono α\ninst✝¹ : AddLeftMono α\ninst✝ : AddLeftStrictMono α\nh : Eq (HAdd.hAdd (HMul.hMul a a) (HMul.hMul b b)) 0\n⊢ Eq a 0","decl":"lemma eq_zero_of_mul_self_add_mul_self_eq_zero [IsRightCancelAdd α] [NoZeroDivisors α]\n    [ZeroLEOneClass α] [ExistsAddOfLE α] [PosMulMono α]\n    [AddLeftMono α] [AddLeftStrictMono α]\n    (h : a * a + b * b = 0) : a = 0 :=\n  (mul_self_add_mul_self_eq_zero.mp h).left\n\n"}
{"name":"max_mul_mul_le_max_mul_max","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝³ : CommSemiring α\ninst✝² : LinearOrder α\na d : α\ninst✝¹ : PosMulMono α\ninst✝ : MulPosMono α\nb c : α\nha : LE.le 0 a\nhd : LE.le 0 d\n⊢ LE.le (Max.max (HMul.hMul a b) (HMul.hMul d c)) (HMul.hMul (Max.max a c) (Max.max d b))","decl":"lemma max_mul_mul_le_max_mul_max [PosMulMono α] [MulPosMono α] (b c : α) (ha : 0 ≤ a) (hd : 0 ≤ d) :\n    max (a * b) (d * c) ≤ max a c * max d b :=\n  have ba : b * a ≤ max d b * max c a :=\n    mul_le_mul (le_max_right d b) (le_max_right c a) ha (le_trans hd (le_max_left d b))\n  have cd : c * d ≤ max a c * max b d :=\n    mul_le_mul (le_max_right a c) (le_max_right b d) hd (le_trans ha (le_max_left a c))\n  max_le (by simpa [mul_comm, max_comm] using ba) (by simpa [mul_comm, max_comm] using cd)\n\n"}
{"name":"two_mul_le_add_sq","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : CommSemiring α\ninst✝⁴ : LinearOrder α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddLeftReflectLE α\ninst✝ : AddLeftMono α\na b : α\n⊢ LE.le (HMul.hMul (HMul.hMul 2 a) b) (HAdd.hAdd (HPow.hPow a 2) (HPow.hPow b 2))","decl":"/-- Binary, squared, and division-free **arithmetic mean-geometric mean inequality**\n(aka AM-GM inequality) for linearly ordered commutative semirings. -/\nlemma two_mul_le_add_sq [ExistsAddOfLE α] [MulPosStrictMono α]\n    [AddLeftReflectLE α] [AddLeftMono α]\n    (a b : α) : 2 * a * b ≤ a ^ 2 + b ^ 2 := by\n  simpa [fn_min_add_fn_max (fun x ↦ x * x), sq, two_mul, add_mul]\n    using mul_add_mul_le_mul_add_mul (@min_le_max _ _ a b) (@min_le_max _ _ a b)\n\n"}
{"name":"two_mul_le_add_pow_two","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : CommSemiring α\ninst✝⁴ : LinearOrder α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddLeftReflectLE α\ninst✝ : AddLeftMono α\na b : α\n⊢ LE.le (HMul.hMul (HMul.hMul 2 a) b) (HAdd.hAdd (HPow.hPow a 2) (HPow.hPow b 2))","decl":"alias two_mul_le_add_pow_two := two_mul_le_add_sq\n\n"}
{"name":"four_mul_le_sq_add","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : CommSemiring α\ninst✝⁴ : LinearOrder α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddLeftReflectLE α\ninst✝ : AddLeftMono α\na b : α\n⊢ LE.le (HMul.hMul (HMul.hMul 4 a) b) (HPow.hPow (HAdd.hAdd a b) 2)","decl":"/-- Binary, squared, and division-free **arithmetic mean-geometric mean inequality**\n(aka AM-GM inequality) for linearly ordered commutative semirings. -/\nlemma four_mul_le_sq_add [ExistsAddOfLE α] [MulPosStrictMono α]\n    [AddLeftReflectLE α] [AddLeftMono α]\n    (a b : α) : 4 * a * b ≤ (a + b) ^ 2 := by\n  calc 4 * a * b\n    _ = 2 * a * b + 2 * a * b := by rw [mul_assoc, two_add_two_eq_four.symm, add_mul, mul_assoc]\n    _ ≤ a ^ 2 + b ^ 2 + 2 * a * b := by gcongr; exact two_mul_le_add_sq _ _\n    _ = a ^ 2 + 2 * a * b + b ^ 2 := by rw [add_right_comm]\n    _ = (a + b) ^ 2 := (add_sq a b).symm\n\n"}
{"name":"four_mul_le_pow_two_add","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : CommSemiring α\ninst✝⁴ : LinearOrder α\ninst✝³ : ExistsAddOfLE α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddLeftReflectLE α\ninst✝ : AddLeftMono α\na b : α\n⊢ LE.le (HMul.hMul (HMul.hMul 4 a) b) (HPow.hPow (HAdd.hAdd a b) 2)","decl":"alias four_mul_le_pow_two_add := four_mul_le_sq_add\n\n"}
{"name":"two_mul_le_add_of_sq_eq_mul","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁶ : CommSemiring α\ninst✝⁵ : LinearOrder α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : MulPosStrictMono α\ninst✝² : PosMulStrictMono α\ninst✝¹ : AddLeftReflectLE α\ninst✝ : AddLeftMono α\na b r : α\nha : LE.le 0 a\nhb : LE.le 0 b\nht : Eq (HPow.hPow r 2) (HMul.hMul a b)\n⊢ LE.le (HMul.hMul 2 r) (HAdd.hAdd a b)","decl":"/-- Binary and division-free **arithmetic mean-geometric mean inequality**\n(aka AM-GM inequality) for linearly ordered commutative semirings. -/\nlemma two_mul_le_add_of_sq_eq_mul [ExistsAddOfLE α] [MulPosStrictMono α] [PosMulStrictMono α]\n    [AddLeftReflectLE α] [AddLeftMono α] {a b r : α}\n    (ha : 0 ≤ a) (hb : 0 ≤ b) (ht : r ^ 2 = a * b) : 2 * r ≤ a + b := by\n  apply nonneg_le_nonneg_of_sq_le_sq (Left.add_nonneg ha hb)\n  conv_rhs => rw [← pow_two]\n  convert four_mul_le_sq_add a b using 1\n  rw [mul_mul_mul_comm, two_mul, two_add_two_eq_four, ← pow_two, ht, mul_assoc]\n\n"}
{"name":"mul_neg_iff","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Ring α\ninst✝⁴ : LinearOrder α\na b : α\ninst✝³ : PosMulStrictMono α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddLeftReflectLT α\ninst✝ : AddLeftStrictMono α\n⊢ Iff (LT.lt (HMul.hMul a b) 0) (Or (And (LT.lt 0 a) (LT.lt b 0)) (And (LT.lt a 0) (LT.lt 0 b)))","decl":"lemma mul_neg_iff [PosMulStrictMono α] [MulPosStrictMono α]\n    [AddLeftReflectLT α] [AddLeftStrictMono α] :\n    a * b < 0 ↔ 0 < a ∧ b < 0 ∨ a < 0 ∧ 0 < b := by\n  rw [← neg_pos, neg_mul_eq_mul_neg, mul_pos_iff (α := α), neg_pos, neg_lt_zero]\n\n"}
{"name":"mul_nonpos_iff","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Ring α\ninst✝⁴ : LinearOrder α\na b : α\ninst✝³ : MulPosStrictMono α\ninst✝² : PosMulStrictMono α\ninst✝¹ : AddLeftReflectLE α\ninst✝ : AddLeftMono α\n⊢ Iff (LE.le (HMul.hMul a b) 0) (Or (And (LE.le 0 a) (LE.le b 0)) (And (LE.le a 0) (LE.le 0 b)))","decl":"lemma mul_nonpos_iff [MulPosStrictMono α] [PosMulStrictMono α]\n    [AddLeftReflectLE α] [AddLeftMono α] :\n    a * b ≤ 0 ↔ 0 ≤ a ∧ b ≤ 0 ∨ a ≤ 0 ∧ 0 ≤ b := by\n  rw [← neg_nonneg, neg_mul_eq_mul_neg, mul_nonneg_iff (α := α), neg_nonneg, neg_nonpos]\n\n"}
{"name":"mul_nonneg_iff_neg_imp_nonpos","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Ring α\ninst✝⁴ : LinearOrder α\na b : α\ninst✝³ : PosMulStrictMono α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddLeftMono α\ninst✝ : AddLeftReflectLE α\n⊢ Iff (LE.le 0 (HMul.hMul a b)) (And (LT.lt a 0 → LE.le b 0) (LT.lt b 0 → LE.le a 0))","decl":"lemma mul_nonneg_iff_neg_imp_nonpos [PosMulStrictMono α] [MulPosStrictMono α]\n    [AddLeftMono α] [AddLeftReflectLE α] :\n    0 ≤ a * b ↔ (a < 0 → b ≤ 0) ∧ (b < 0 → a ≤ 0) := by\n  rw [← neg_mul_neg, mul_nonneg_iff_pos_imp_nonneg (α := α)]; simp only [neg_pos, neg_nonneg]\n\n"}
{"name":"mul_nonpos_iff_pos_imp_nonpos","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Ring α\ninst✝⁴ : LinearOrder α\na b : α\ninst✝³ : PosMulStrictMono α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddLeftMono α\ninst✝ : AddLeftReflectLE α\n⊢ Iff (LE.le (HMul.hMul a b) 0) (And (LT.lt 0 a → LE.le b 0) (LT.lt b 0 → LE.le 0 a))","decl":"lemma mul_nonpos_iff_pos_imp_nonpos [PosMulStrictMono α] [MulPosStrictMono α]\n    [AddLeftMono α] [AddLeftReflectLE α] :\n    a * b ≤ 0 ↔ (0 < a → b ≤ 0) ∧ (b < 0 → 0 ≤ a) := by\n  rw [← neg_nonneg, ← mul_neg, mul_nonneg_iff_pos_imp_nonneg (α := α)]\n  simp only [neg_pos, neg_nonneg]\n\n"}
{"name":"mul_nonpos_iff_neg_imp_nonneg","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁵ : Ring α\ninst✝⁴ : LinearOrder α\na b : α\ninst✝³ : PosMulStrictMono α\ninst✝² : MulPosStrictMono α\ninst✝¹ : AddLeftMono α\ninst✝ : AddLeftReflectLE α\n⊢ Iff (LE.le (HMul.hMul a b) 0) (And (LT.lt a 0 → LE.le 0 b) (LT.lt 0 b → LE.le a 0))","decl":"lemma mul_nonpos_iff_neg_imp_nonneg [PosMulStrictMono α] [MulPosStrictMono α]\n    [AddLeftMono α] [AddLeftReflectLE α] :\n    a * b ≤ 0 ↔ (a < 0 → 0 ≤ b) ∧ (0 < b → a ≤ 0) := by\n  rw [← neg_nonneg, ← neg_mul, mul_nonneg_iff_pos_imp_nonneg (α := α)]\n  simp only [neg_pos, neg_nonneg]\n\n"}
{"name":"neg_one_lt_zero","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁴ : Ring α\ninst✝³ : LinearOrder α\ninst✝² : ZeroLEOneClass α\ninst✝¹ : NeZero 1\ninst✝ : AddLeftStrictMono α\n⊢ LT.lt (-1) 0","decl":"lemma neg_one_lt_zero\n    [ZeroLEOneClass α] [NeZero (R := α) 1] [AddLeftStrictMono α] :\n    -1 < (0 : α) := neg_lt_zero.2 zero_lt_one\n\n"}
{"name":"sub_one_lt","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁴ : Ring α\ninst✝³ : LinearOrder α\ninst✝² : ZeroLEOneClass α\ninst✝¹ : NeZero 1\ninst✝ : AddLeftStrictMono α\na : α\n⊢ LT.lt (HSub.hSub a 1) a","decl":"lemma sub_one_lt [ZeroLEOneClass α] [NeZero (R := α) 1]\n    [AddLeftStrictMono α]\n    (a : α) : a - 1 < a := sub_lt_iff_lt_add.2 <| lt_add_one a\n\n"}
{"name":"mul_self_le_mul_self_of_le_of_neg_le","module":"Mathlib.Algebra.Order.Ring.Unbundled.Basic","initialProofState":"α : Type u\ninst✝⁴ : Ring α\ninst✝³ : LinearOrder α\na b : α\ninst✝² : MulPosMono α\ninst✝¹ : PosMulMono α\ninst✝ : AddLeftMono α\nh₁ : LE.le a b\nh₂ : LE.le (Neg.neg a) b\n⊢ LE.le (HMul.hMul a a) (HMul.hMul b b)","decl":"lemma mul_self_le_mul_self_of_le_of_neg_le\n    [MulPosMono α] [PosMulMono α] [AddLeftMono α]\n    (h₁ : a ≤ b) (h₂ : -a ≤ b) : a * a ≤ b * b :=\n  (le_total 0 a).elim (mul_self_le_mul_self · h₁) fun h ↦\n    (neg_mul_neg a a).symm.trans_le <|\n      mul_le_mul h₂ h₂ (neg_nonneg.2 h) <| (neg_nonneg.2 h).trans h₂\n\n"}
