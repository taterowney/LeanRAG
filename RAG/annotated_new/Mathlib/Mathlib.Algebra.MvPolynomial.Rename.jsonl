{"name":"MvPolynomial.rename_C","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\ninst✝ : CommSemiring R\nf : σ → τ\nr : R\n⊢ Eq ((MvPolynomial.rename f) (MvPolynomial.C r)) (MvPolynomial.C r)","decl":"theorem rename_C (f : σ → τ) (r : R) : rename f (C r) = C r :=\n  eval₂_C _ _ _\n\n"}
{"name":"MvPolynomial.rename_X","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\ninst✝ : CommSemiring R\nf : σ → τ\ni : σ\n⊢ Eq ((MvPolynomial.rename f) (MvPolynomial.X i)) (MvPolynomial.X (f i))","decl":"@[simp]\ntheorem rename_X (f : σ → τ) (i : σ) : rename f (X i : MvPolynomial σ R) = X (f i) :=\n  eval₂_X _ _ _\n\n"}
{"name":"MvPolynomial.map_rename","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\nS : Type u_5\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\ng : σ → τ\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.map f) ((MvPolynomial.rename g) p)) ((MvPolynomial.rename g) ((MvPolynomial.map f) p))","decl":"theorem map_rename (f : R →+* S) (g : σ → τ) (p : MvPolynomial σ R) :\n    map f (rename g p) = rename g (map f p) := by\n  apply MvPolynomial.induction_on p\n    (fun a => by simp only [map_C, rename_C])\n    (fun p q hp hq => by simp only [hp, hq, map_add]) fun p n hp => by\n    simp only [hp, rename_X, map_X, map_mul]\n\n"}
{"name":"MvPolynomial.rename_rename","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nα : Type u_3\nR : Type u_4\ninst✝ : CommSemiring R\nf : σ → τ\ng : τ → α\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.rename g) ((MvPolynomial.rename f) p)) ((MvPolynomial.rename (Function.comp g f)) p)","decl":"@[simp]\ntheorem rename_rename (f : σ → τ) (g : τ → α) (p : MvPolynomial σ R) :\n    rename g (rename f p) = rename (g ∘ f) p :=\n  show rename g (eval₂ C (X ∘ f) p) = _ by\n    simp only [rename, aeval_eq_eval₂Hom]\n    -- Porting note: the Lean 3 proof of this was very fragile and included a nonterminal `simp`.\n    -- Hopefully this is less prone to breaking\n    rw [eval₂_comp_left (eval₂Hom (algebraMap R (MvPolynomial α R)) (X ∘ g)) C (X ∘ f) p]\n    simp only [comp_def, eval₂Hom_X']\n    refine eval₂Hom_congr ?_ rfl rfl\n    ext1; simp only [comp_apply, RingHom.coe_comp, eval₂Hom_C]\n\n"}
{"name":"MvPolynomial.rename_id","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nR : Type u_4\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.rename id) p) p","decl":"@[simp]\ntheorem rename_id (p : MvPolynomial σ R) : rename id p = p :=\n  eval₂_eta p\n\n"}
{"name":"MvPolynomial.rename_monomial","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\ninst✝ : CommSemiring R\nf : σ → τ\nd : Finsupp σ Nat\nr : R\n⊢ Eq ((MvPolynomial.rename f) ((MvPolynomial.monomial d) r)) ((MvPolynomial.monomial (Finsupp.mapDomain f d)) r)","decl":"theorem rename_monomial (f : σ → τ) (d : σ →₀ ℕ) (r : R) :\n    rename f (monomial d r) = monomial (d.mapDomain f) r := by\n  rw [rename, aeval_monomial, monomial_eq (s := Finsupp.mapDomain f d),\n    Finsupp.prod_mapDomain_index]\n  · rfl\n  · exact fun n => pow_zero _\n  · exact fun n i₁ i₂ => pow_add _ _ _\n\n"}
{"name":"MvPolynomial.rename_eq","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\ninst✝ : CommSemiring R\nf : σ → τ\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.rename f) p) (Finsupp.mapDomain (Finsupp.mapDomain f) p)","decl":"theorem rename_eq (f : σ → τ) (p : MvPolynomial σ R) :\n    rename f p = Finsupp.mapDomain (Finsupp.mapDomain f) p := by\n  simp only [rename, aeval_def, eval₂, Finsupp.mapDomain, algebraMap_eq, comp_apply,\n    X_pow_eq_monomial, ← monomial_finsupp_sum_index]\n  rfl\n\n"}
{"name":"MvPolynomial.rename_injective","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\ninst✝ : CommSemiring R\nf : σ → τ\nhf : Function.Injective f\n⊢ Function.Injective ⇑(MvPolynomial.rename f)","decl":"theorem rename_injective (f : σ → τ) (hf : Function.Injective f) :\n    Function.Injective (rename f : MvPolynomial σ R → MvPolynomial τ R) := by\n  have :\n    (rename f : MvPolynomial σ R → MvPolynomial τ R) = Finsupp.mapDomain (Finsupp.mapDomain f) :=\n    funext (rename_eq f)\n  rw [this]\n  exact Finsupp.mapDomain_injective (Finsupp.mapDomain_injective hf)\n\n"}
{"name":"MvPolynomial.killCompl_C","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\ninst✝ : CommSemiring R\nf : σ → τ\nhf : Function.Injective f\nr : R\n⊢ Eq ((MvPolynomial.killCompl hf) (MvPolynomial.C r)) (MvPolynomial.C r)","decl":"theorem killCompl_C (r : R) : killCompl hf (C r) = C r := algHom_C _ _\n\n"}
{"name":"MvPolynomial.killCompl_comp_rename","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\ninst✝ : CommSemiring R\nf : σ → τ\nhf : Function.Injective f\n⊢ Eq ((MvPolynomial.killCompl hf).comp (MvPolynomial.rename f)) (AlgHom.id R (MvPolynomial σ R))","decl":"theorem killCompl_comp_rename : (killCompl hf).comp (rename f) = AlgHom.id R _ :=\n  algHom_ext fun i => by\n    dsimp\n    rw [rename, killCompl, aeval_X, comp_apply, aeval_X, dif_pos, Equiv.ofInjective_symm_apply]\n\n"}
{"name":"MvPolynomial.killCompl_rename_app","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\ninst✝ : CommSemiring R\nf : σ → τ\nhf : Function.Injective f\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.killCompl hf) ((MvPolynomial.rename f) p)) p","decl":"@[simp]\ntheorem killCompl_rename_app (p : MvPolynomial σ R) : killCompl hf (rename f p) = p :=\n  AlgHom.congr_fun (killCompl_comp_rename hf) p\n\n"}
{"name":"MvPolynomial.renameEquiv_apply","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\ninst✝ : CommSemiring R\nf : Equiv σ τ\na : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.renameEquiv R f) a) ((MvPolynomial.rename ⇑f) a)","decl":"/-- `MvPolynomial.rename e` is an equivalence when `e` is. -/\n@[simps apply]\ndef renameEquiv (f : σ ≃ τ) : MvPolynomial σ R ≃ₐ[R] MvPolynomial τ R :=\n  { rename f with\n    toFun := rename f\n    invFun := rename f.symm\n    left_inv := fun p => by rw [rename_rename, f.symm_comp_self, rename_id]\n    right_inv := fun p => by rw [rename_rename, f.self_comp_symm, rename_id] }\n\n"}
{"name":"MvPolynomial.renameEquiv_refl","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nR : Type u_4\ninst✝ : CommSemiring R\n⊢ Eq (MvPolynomial.renameEquiv R (Equiv.refl σ)) AlgEquiv.refl","decl":"@[simp]\ntheorem renameEquiv_refl : renameEquiv R (Equiv.refl σ) = AlgEquiv.refl :=\n  AlgEquiv.ext rename_id\n\n"}
{"name":"MvPolynomial.renameEquiv_symm","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\ninst✝ : CommSemiring R\nf : Equiv σ τ\n⊢ Eq (MvPolynomial.renameEquiv R f).symm (MvPolynomial.renameEquiv R f.symm)","decl":"@[simp]\ntheorem renameEquiv_symm (f : σ ≃ τ) : (renameEquiv R f).symm = renameEquiv R f.symm :=\n  rfl\n\n"}
{"name":"MvPolynomial.renameEquiv_trans","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nα : Type u_3\nR : Type u_4\ninst✝ : CommSemiring R\ne : Equiv σ τ\nf : Equiv τ α\n⊢ Eq ((MvPolynomial.renameEquiv R e).trans (MvPolynomial.renameEquiv R f)) (MvPolynomial.renameEquiv R (e.trans f))","decl":"@[simp]\ntheorem renameEquiv_trans (e : σ ≃ τ) (f : τ ≃ α) :\n    (renameEquiv R e).trans (renameEquiv R f) = renameEquiv R (e.trans f) :=\n  AlgEquiv.ext (rename_rename e f)\n\n"}
{"name":"MvPolynomial.eval₂_rename","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\nS : Type u_5\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\nk : σ → τ\ng : τ → S\np : MvPolynomial σ R\n⊢ Eq (MvPolynomial.eval₂ f g ((MvPolynomial.rename k) p)) (MvPolynomial.eval₂ f (Function.comp g k) p)","decl":"theorem eval₂_rename : (rename k p).eval₂ f g = p.eval₂ f (g ∘ k) := by\n  apply MvPolynomial.induction_on p <;>\n    · intros\n      simp [*]\n\n"}
{"name":"MvPolynomial.eval_rename","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\ninst✝ : CommSemiring R\nk : σ → τ\ng : τ → R\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.eval g) ((MvPolynomial.rename k) p)) ((MvPolynomial.eval (Function.comp g k)) p)","decl":"theorem eval_rename (g : τ → R) (p : MvPolynomial σ R) : eval g (rename k p) = eval (g ∘ k) p :=\n  eval₂_rename _ _ _ _\n\n"}
{"name":"MvPolynomial.eval₂Hom_rename","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\nS : Type u_5\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\nk : σ → τ\ng : τ → S\np : MvPolynomial σ R\n⊢ Eq ((MvPolynomial.eval₂Hom f g) ((MvPolynomial.rename k) p)) ((MvPolynomial.eval₂Hom f (Function.comp g k)) p)","decl":"theorem eval₂Hom_rename : eval₂Hom f g (rename k p) = eval₂Hom f (g ∘ k) p :=\n  eval₂_rename _ _ _ _\n\n"}
{"name":"MvPolynomial.aeval_rename","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\nS : Type u_5\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\nk : σ → τ\ng : τ → S\np : MvPolynomial σ R\ninst✝ : Algebra R S\n⊢ Eq ((MvPolynomial.aeval g) ((MvPolynomial.rename k) p)) ((MvPolynomial.aeval (Function.comp g k)) p)","decl":"theorem aeval_rename [Algebra R S] : aeval g (rename k p) = aeval (g ∘ k) p :=\n  eval₂Hom_rename _ _ _ _\n\n"}
{"name":"MvPolynomial.rename_eval₂","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\ninst✝ : CommSemiring R\nk : σ → τ\np : MvPolynomial σ R\ng : τ → MvPolynomial σ R\n⊢ Eq ((MvPolynomial.rename k) (MvPolynomial.eval₂ MvPolynomial.C (Function.comp g k) p)) (MvPolynomial.eval₂ MvPolynomial.C (Function.comp (⇑(MvPolynomial.rename k)) g) ((MvPolynomial.rename k) p))","decl":"theorem rename_eval₂ (g : τ → MvPolynomial σ R) :\n    rename k (p.eval₂ C (g ∘ k)) = (rename k p).eval₂ C (rename k ∘ g) := by\n  apply MvPolynomial.induction_on p <;>\n    · intros\n      simp [*]\n\n"}
{"name":"MvPolynomial.rename_prod_mk_eval₂","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\ninst✝ : CommSemiring R\np : MvPolynomial σ R\nj : τ\ng : σ → MvPolynomial σ R\n⊢ Eq ((MvPolynomial.rename (Prod.mk j)) (MvPolynomial.eval₂ MvPolynomial.C g p)) (MvPolynomial.eval₂ MvPolynomial.C (fun x => (MvPolynomial.rename (Prod.mk j)) (g x)) p)","decl":"theorem rename_prod_mk_eval₂ (j : τ) (g : σ → MvPolynomial σ R) :\n    rename (Prod.mk j) (p.eval₂ C g) = p.eval₂ C fun x => rename (Prod.mk j) (g x) := by\n  apply MvPolynomial.induction_on p <;>\n    · intros\n      simp [*]\n\n"}
{"name":"MvPolynomial.eval₂_rename_prod_mk","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\nS : Type u_5\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nf : RingHom R S\ng : Prod σ τ → S\ni : σ\np : MvPolynomial τ R\n⊢ Eq (MvPolynomial.eval₂ f g ((MvPolynomial.rename (Prod.mk i)) p)) (MvPolynomial.eval₂ f (fun j => g { fst := i, snd := j }) p)","decl":"theorem eval₂_rename_prod_mk (g : σ × τ → S) (i : σ) (p : MvPolynomial τ R) :\n    (rename (Prod.mk i) p).eval₂ f g = eval₂ f (fun j => g (i, j)) p := by\n  apply MvPolynomial.induction_on p <;>\n    · intros\n      simp [*]\n\n"}
{"name":"MvPolynomial.eval_rename_prod_mk","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\ninst✝ : CommSemiring R\ng : Prod σ τ → R\ni : σ\np : MvPolynomial τ R\n⊢ Eq ((MvPolynomial.eval g) ((MvPolynomial.rename (Prod.mk i)) p)) ((MvPolynomial.eval fun j => g { fst := i, snd := j }) p)","decl":"theorem eval_rename_prod_mk (g : σ × τ → R) (i : σ) (p : MvPolynomial τ R) :\n    eval g (rename (Prod.mk i) p) = eval (fun j => g (i, j)) p :=\n  eval₂_rename_prod_mk (RingHom.id _) _ _ _\n\n"}
{"name":"MvPolynomial.exists_finset_rename","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nR : Type u_4\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ Exists fun s => Exists fun q => Eq p ((MvPolynomial.rename Subtype.val) q)","decl":"/-- Every polynomial is a polynomial in finitely many variables. -/\ntheorem exists_finset_rename (p : MvPolynomial σ R) :\n    ∃ (s : Finset σ) (q : MvPolynomial { x // x ∈ s } R), p = rename (↑) q := by\n  classical\n  apply induction_on p\n  · intro r\n    exact ⟨∅, C r, by rw [rename_C]⟩\n  · rintro p q ⟨s, p, rfl⟩ ⟨t, q, rfl⟩\n    refine ⟨s ∪ t, ⟨?_, ?_⟩⟩\n    · refine rename (Subtype.map id ?_) p + rename (Subtype.map id ?_) q <;>\n        simp +contextual only [id, true_or, or_true,\n          Finset.mem_union, forall_true_iff]\n    · simp only [rename_rename, map_add]\n      rfl\n  · rintro p n ⟨s, p, rfl⟩\n    refine ⟨insert n s, ⟨?_, ?_⟩⟩\n    · refine rename (Subtype.map id ?_) p * X ⟨n, s.mem_insert_self n⟩\n      simp +contextual only [id, or_true, Finset.mem_insert, forall_true_iff]\n    · simp only [rename_rename, rename_X, Subtype.coe_mk, map_mul]\n      rfl\n\n"}
{"name":"MvPolynomial.exists_finset_rename₂","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nR : Type u_4\ninst✝ : CommSemiring R\np₁ p₂ : MvPolynomial σ R\n⊢ Exists fun s => Exists fun q₁ => Exists fun q₂ => And (Eq p₁ ((MvPolynomial.rename Subtype.val) q₁)) (Eq p₂ ((MvPolynomial.rename Subtype.val) q₂))","decl":"/-- `exists_finset_rename` for two polynomials at once: for any two polynomials `p₁`, `p₂` in a\n  polynomial semiring `R[σ]` of possibly infinitely many variables, `exists_finset_rename₂` yields\n  a finite subset `s` of `σ` such that both `p₁` and `p₂` are contained in the polynomial semiring\n  `R[s]` of finitely many variables. -/\ntheorem exists_finset_rename₂ (p₁ p₂ : MvPolynomial σ R) :\n    ∃ (s : Finset σ) (q₁ q₂ : MvPolynomial s R), p₁ = rename (↑) q₁ ∧ p₂ = rename (↑) q₂ := by\n  obtain ⟨s₁, q₁, rfl⟩ := exists_finset_rename p₁\n  obtain ⟨s₂, q₂, rfl⟩ := exists_finset_rename p₂\n  classical\n    use s₁ ∪ s₂\n    use rename (Set.inclusion s₁.subset_union_left) q₁\n    use rename (Set.inclusion s₁.subset_union_right) q₂\n    constructor -- Porting note: was `<;> simp <;> rfl` but Lean couldn't infer the arguments\n    · -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n      erw [rename_rename (Set.inclusion s₁.subset_union_left)]\n      rfl\n    · -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n      erw [rename_rename (Set.inclusion s₁.subset_union_right)]\n      rfl\n\n"}
{"name":"MvPolynomial.exists_fin_rename","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nR : Type u_4\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ Exists fun n => Exists fun f => Exists fun _hf => Exists fun q => Eq p ((MvPolynomial.rename f) q)","decl":"/-- Every polynomial is a polynomial in finitely many variables. -/\ntheorem exists_fin_rename (p : MvPolynomial σ R) :\n    ∃ (n : ℕ) (f : Fin n → σ) (_hf : Injective f) (q : MvPolynomial (Fin n) R), p = rename f q := by\n  obtain ⟨s, q, rfl⟩ := exists_finset_rename p\n  let n := Fintype.card { x // x ∈ s }\n  let e := Fintype.equivFin { x // x ∈ s }\n  refine ⟨n, (↑) ∘ e.symm, Subtype.val_injective.comp e.symm.injective, rename e q, ?_⟩\n  rw [← rename_rename, rename_rename e]\n  simp only [Function.comp_def, Equiv.symm_apply_apply, rename_rename]\n\n"}
{"name":"MvPolynomial.eval₂_cast_comp","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\ninst✝ : CommSemiring R\nf : σ → τ\nc : RingHom Int R\ng : τ → R\np : MvPolynomial σ Int\n⊢ Eq (MvPolynomial.eval₂ c (Function.comp g f) p) (MvPolynomial.eval₂ c g ((MvPolynomial.rename f) p))","decl":"theorem eval₂_cast_comp (f : σ → τ) (c : ℤ →+* R) (g : τ → R) (p : MvPolynomial σ ℤ) :\n    eval₂ c (g ∘ f) p = eval₂ c g (rename f p) := by\n  apply MvPolynomial.induction_on p (fun n => by simp only [eval₂_C, rename_C])\n    (fun p q hp hq => by simp only [hp, hq, rename, eval₂_add, map_add])\n    fun p n hp => by simp only [eval₂_mul, hp, eval₂_X, comp_apply, map_mul, rename_X, eval₂_mul]\n\n"}
{"name":"MvPolynomial.coeff_rename_mapDomain","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\ninst✝ : CommSemiring R\nf : σ → τ\nhf : Function.Injective f\nφ : MvPolynomial σ R\nd : Finsupp σ Nat\n⊢ Eq (MvPolynomial.coeff (Finsupp.mapDomain f d) ((MvPolynomial.rename f) φ)) (MvPolynomial.coeff d φ)","decl":"@[simp]\ntheorem coeff_rename_mapDomain (f : σ → τ) (hf : Injective f) (φ : MvPolynomial σ R) (d : σ →₀ ℕ) :\n    (rename f φ).coeff (d.mapDomain f) = φ.coeff d := by\n  classical\n  apply φ.induction_on' (P := fun ψ => coeff (Finsupp.mapDomain f d) ((rename f) ψ) = coeff d ψ)\n  -- Lean could no longer infer the motive\n  · intro u r\n    rw [rename_monomial, coeff_monomial, coeff_monomial]\n    simp only [(Finsupp.mapDomain_injective hf).eq_iff]\n  · intros\n    simp only [*, map_add, coeff_add]\n\n"}
{"name":"MvPolynomial.coeff_rename_embDomain","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\ninst✝ : CommSemiring R\nf : Function.Embedding σ τ\nφ : MvPolynomial σ R\nd : Finsupp σ Nat\n⊢ Eq (MvPolynomial.coeff (Finsupp.embDomain f d) ((MvPolynomial.rename ⇑f) φ)) (MvPolynomial.coeff d φ)","decl":"@[simp]\ntheorem coeff_rename_embDomain (f : σ ↪ τ) (φ : MvPolynomial σ R) (d : σ →₀ ℕ) :\n    (rename f φ).coeff (d.embDomain f) = φ.coeff d := by\n  rw [Finsupp.embDomain_eq_mapDomain f, coeff_rename_mapDomain f f.injective]\n\n"}
{"name":"MvPolynomial.coeff_rename_eq_zero","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\ninst✝ : CommSemiring R\nf : σ → τ\nφ : MvPolynomial σ R\nd : Finsupp τ Nat\nh : ∀ (u : Finsupp σ Nat), Eq (Finsupp.mapDomain f u) d → Eq (MvPolynomial.coeff u φ) 0\n⊢ Eq (MvPolynomial.coeff d ((MvPolynomial.rename f) φ)) 0","decl":"theorem coeff_rename_eq_zero (f : σ → τ) (φ : MvPolynomial σ R) (d : τ →₀ ℕ)\n    (h : ∀ u : σ →₀ ℕ, u.mapDomain f = d → φ.coeff u = 0) : (rename f φ).coeff d = 0 := by\n  classical\n  rw [rename_eq, ← not_mem_support_iff]\n  intro H\n  replace H := mapDomain_support H\n  rw [Finset.mem_image] at H\n  obtain ⟨u, hu, rfl⟩ := H\n  specialize h u rfl\n  simp? at h hu says simp only [Finsupp.mem_support_iff, ne_eq] at h hu\n  contradiction\n\n"}
{"name":"MvPolynomial.coeff_rename_ne_zero","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\ninst✝ : CommSemiring R\nf : σ → τ\nφ : MvPolynomial σ R\nd : Finsupp τ Nat\nh : Ne (MvPolynomial.coeff d ((MvPolynomial.rename f) φ)) 0\n⊢ Exists fun u => And (Eq (Finsupp.mapDomain f u) d) (Ne (MvPolynomial.coeff u φ) 0)","decl":"theorem coeff_rename_ne_zero (f : σ → τ) (φ : MvPolynomial σ R) (d : τ →₀ ℕ)\n    (h : (rename f φ).coeff d ≠ 0) : ∃ u : σ →₀ ℕ, u.mapDomain f = d ∧ φ.coeff u ≠ 0 := by\n  contrapose! h\n  apply coeff_rename_eq_zero _ _ _ h\n\n"}
{"name":"MvPolynomial.constantCoeff_rename","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nR : Type u_4\ninst✝ : CommSemiring R\nτ : Type u_6\nf : σ → τ\nφ : MvPolynomial σ R\n⊢ Eq (MvPolynomial.constantCoeff ((MvPolynomial.rename f) φ)) (MvPolynomial.constantCoeff φ)","decl":"@[simp]\ntheorem constantCoeff_rename {τ : Type*} (f : σ → τ) (φ : MvPolynomial σ R) :\n    constantCoeff (rename f φ) = constantCoeff φ := by\n  apply φ.induction_on\n  · intro a\n    simp only [constantCoeff_C, rename_C]\n  · intro p q hp hq\n    simp only [hp, hq, map_add]\n  · intro p n hp\n    simp only [hp, rename_X, constantCoeff_X, map_mul]\n\n"}
{"name":"MvPolynomial.support_rename_of_injective","module":"Mathlib.Algebra.MvPolynomial.Rename","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_4\ninst✝¹ : CommSemiring R\np : MvPolynomial σ R\nf : σ → τ\ninst✝ : DecidableEq τ\nh : Function.Injective f\n⊢ Eq ((MvPolynomial.rename f) p).support (Finset.image (Finsupp.mapDomain f) p.support)","decl":"theorem support_rename_of_injective {p : MvPolynomial σ R} {f : σ → τ} [DecidableEq τ]\n    (h : Function.Injective f) :\n    (rename f p).support = Finset.image (Finsupp.mapDomain f) p.support := by\n  rw [rename_eq]\n  exact Finsupp.mapDomain_support_of_injective (mapDomain_injective h) _\n\n"}
