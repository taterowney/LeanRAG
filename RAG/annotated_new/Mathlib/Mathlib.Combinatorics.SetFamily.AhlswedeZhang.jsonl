{"name":"Finset.truncatedSup_of_mem","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ² : SemilatticeSup Î±\ns : Finset Î±\na : Î±\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : OrderTop Î±\nh : Membership.mem (lowerClosure â†‘s) a\nâŠ¢ Eq (s.truncatedSup a) ((Finset.filter (fun b => LE.le a b) s).sup' â‹¯ id)","decl":"lemma truncatedSup_of_mem (h : a âˆˆ lowerClosure s) :\n    truncatedSup s a = {b âˆˆ s | a â‰¤ b}.sup' (sup_aux h) id := dif_pos h\n\n"}
{"name":"Finset.truncatedSup_of_not_mem","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ² : SemilatticeSup Î±\ns : Finset Î±\na : Î±\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : OrderTop Î±\nh : Not (Membership.mem (lowerClosure â†‘s) a)\nâŠ¢ Eq (s.truncatedSup a) Top.top","decl":"lemma truncatedSup_of_not_mem (h : a âˆ‰ lowerClosure s) : truncatedSup s a = âŠ¤ := dif_neg h\n\n"}
{"name":"Finset.truncatedSup_empty","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ² : SemilatticeSup Î±\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : OrderTop Î±\na : Î±\nâŠ¢ Eq (EmptyCollection.emptyCollection.truncatedSup a) Top.top","decl":"@[simp] lemma truncatedSup_empty (a : Î±) : truncatedSup âˆ… a = âŠ¤ := truncatedSup_of_not_mem (by simp)\n\n"}
{"name":"Finset.truncatedSup_singleton","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ² : SemilatticeSup Î±\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : OrderTop Î±\nb a : Î±\nâŠ¢ Eq ((Singleton.singleton b).truncatedSup a) (ite (LE.le a b) b Top.top)","decl":"@[simp] lemma truncatedSup_singleton (b a : Î±) : truncatedSup {b} a = if a â‰¤ b then b else âŠ¤ := by\n  simp [truncatedSup]; split_ifs <;> simp [Finset.filter_true_of_mem, *]\n\n"}
{"name":"Finset.le_truncatedSup","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ² : SemilatticeSup Î±\ns : Finset Î±\na : Î±\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : OrderTop Î±\nâŠ¢ LE.le a (s.truncatedSup a)","decl":"lemma le_truncatedSup : a â‰¤ truncatedSup s a := by\n  rw [truncatedSup]\n  split_ifs with h\n  Â· obtain âŸ¨â„¬, hb, hâŸ© := h\n    exact h.trans <| le_sup' id <| mem_filter.2 âŸ¨hb, hâŸ©\n  Â· exact le_top\n\n"}
{"name":"Finset.map_truncatedSup","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâµ : SemilatticeSup Î±\ninstâœâ´ : SemilatticeSup Î²\ninstâœÂ³ : BoundedOrder Î²\ninstâœÂ² : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœÂ¹ : OrderTop Î±\ninstâœ : DecidableRel fun x1 x2 => LE.le x1 x2\ne : OrderIso Î± Î²\ns : Finset Î±\na : Î±\nâŠ¢ Eq (e (s.truncatedSup a)) ((Finset.map e.toEmbedding s).truncatedSup (e a))","decl":"lemma map_truncatedSup [DecidableRel (Î± := Î²) (Â· â‰¤ Â·)] (e : Î± â‰ƒo Î²) (s : Finset Î±) (a : Î±) :\n    e (truncatedSup s a) = truncatedSup (s.map e.toEquiv.toEmbedding) (e a) := by\n  have : e a âˆˆ lowerClosure (s.map e.toEquiv.toEmbedding : Set Î²) â†” a âˆˆ lowerClosure s := by simp\n  simp_rw [truncatedSup, apply_dite e, map_finset_sup', map_top, this]\n  congr with h\n  simp only [filter_map, Function.comp_def, Equiv.coe_toEmbedding, RelIso.coe_fn_toEquiv,\n    OrderIso.le_iff_le, id, sup'_map]\n\n"}
{"name":"Finset.truncatedSup_of_isAntichain","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ² : SemilatticeSup Î±\ns : Finset Î±\na : Î±\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : OrderTop Î±\nhs : IsAntichain (fun x1 x2 => LE.le x1 x2) â†‘s\nha : Membership.mem s a\nâŠ¢ Eq (s.truncatedSup a) a","decl":"lemma truncatedSup_of_isAntichain (hs : IsAntichain (Â· â‰¤ Â·) (s : Set Î±)) (ha : a âˆˆ s) :\n    truncatedSup s a = a := by\n  refine le_antisymm ?_ le_truncatedSup\n  simp_rw [truncatedSup_of_mem (subset_lowerClosure ha), sup'_le_iff, mem_filter]\n  rintro b âŸ¨hb, habâŸ©\n  exact (hs.eq ha hb hab).ge\n\n"}
{"name":"Finset.truncatedSup_union","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ³ : SemilatticeSup Î±\ns t : Finset Î±\na : Î±\ninstâœÂ² : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœÂ¹ : OrderTop Î±\ninstâœ : DecidableEq Î±\nhs : Membership.mem (lowerClosure â†‘s) a\nht : Membership.mem (lowerClosure â†‘t) a\nâŠ¢ Eq ((Union.union s t).truncatedSup a) (Max.max (s.truncatedSup a) (t.truncatedSup a))","decl":"lemma truncatedSup_union (hs : a âˆˆ lowerClosure s) (ht : a âˆˆ lowerClosure t) :\n    truncatedSup (s âˆª t) a = truncatedSup s a âŠ” truncatedSup t a := by\n  simpa only [truncatedSup_of_mem, hs, ht, lower_aux.2 (Or.inl hs), filter_union] using\n    sup'_union _ _ _\n\n"}
{"name":"Finset.truncatedSup_union_left","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ³ : SemilatticeSup Î±\ns t : Finset Î±\na : Î±\ninstâœÂ² : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœÂ¹ : OrderTop Î±\ninstâœ : DecidableEq Î±\nhs : Membership.mem (lowerClosure â†‘s) a\nht : Not (Membership.mem (lowerClosure â†‘t) a)\nâŠ¢ Eq ((Union.union s t).truncatedSup a) (s.truncatedSup a)","decl":"lemma truncatedSup_union_left (hs : a âˆˆ lowerClosure s) (ht : a âˆ‰ lowerClosure t) :\n    truncatedSup (s âˆª t) a = truncatedSup s a := by\n  simp only [mem_lowerClosure, mem_coe, exists_prop, not_exists, not_and] at ht\n  simp only [truncatedSup_of_mem, hs, filter_union, filter_false_of_mem ht, union_empty,\n    lower_aux.2 (Or.inl hs), ht]\n\n"}
{"name":"Finset.truncatedSup_union_right","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ³ : SemilatticeSup Î±\ns t : Finset Î±\na : Î±\ninstâœÂ² : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœÂ¹ : OrderTop Î±\ninstâœ : DecidableEq Î±\nhs : Not (Membership.mem (lowerClosure â†‘s) a)\nht : Membership.mem (lowerClosure â†‘t) a\nâŠ¢ Eq ((Union.union s t).truncatedSup a) (t.truncatedSup a)","decl":"lemma truncatedSup_union_right (hs : a âˆ‰ lowerClosure s) (ht : a âˆˆ lowerClosure t) :\n    truncatedSup (s âˆª t) a = truncatedSup t a := by rw [union_comm, truncatedSup_union_left ht hs]\n\n"}
{"name":"Finset.truncatedSup_union_of_not_mem","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ³ : SemilatticeSup Î±\ns t : Finset Î±\na : Î±\ninstâœÂ² : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœÂ¹ : OrderTop Î±\ninstâœ : DecidableEq Î±\nhs : Not (Membership.mem (lowerClosure â†‘s) a)\nht : Not (Membership.mem (lowerClosure â†‘t) a)\nâŠ¢ Eq ((Union.union s t).truncatedSup a) Top.top","decl":"lemma truncatedSup_union_of_not_mem (hs : a âˆ‰ lowerClosure s) (ht : a âˆ‰ lowerClosure t) :\n    truncatedSup (s âˆª t) a = âŠ¤ := truncatedSup_of_not_mem fun h â†¦ (lower_aux.1 h).elim hs ht\n\n"}
{"name":"Finset.truncatedInf_of_mem","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ² : SemilatticeInf Î±\ns : Finset Î±\na : Î±\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : BoundedOrder Î±\nh : Membership.mem (upperClosure â†‘s) a\nâŠ¢ Eq (s.truncatedInf a) ((Finset.filter (fun b => LE.le b a) s).inf' â‹¯ id)","decl":"lemma truncatedInf_of_mem (h : a âˆˆ upperClosure s) :\n    truncatedInf s a = {b âˆˆ s | b â‰¤ a}.inf' (inf_aux h) id := dif_pos h\n\n"}
{"name":"Finset.truncatedInf_of_not_mem","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ² : SemilatticeInf Î±\ns : Finset Î±\na : Î±\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : BoundedOrder Î±\nh : Not (Membership.mem (upperClosure â†‘s) a)\nâŠ¢ Eq (s.truncatedInf a) Bot.bot","decl":"lemma truncatedInf_of_not_mem (h : a âˆ‰ upperClosure s) : truncatedInf s a = âŠ¥ := dif_neg h\n\n"}
{"name":"Finset.truncatedInf_le","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ² : SemilatticeInf Î±\ns : Finset Î±\na : Î±\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : BoundedOrder Î±\nâŠ¢ LE.le (s.truncatedInf a) a","decl":"lemma truncatedInf_le : truncatedInf s a â‰¤ a := by\n  unfold truncatedInf\n  split_ifs with h\n  Â· obtain âŸ¨b, hb, hbaâŸ© := h\n    exact hba.trans' <| inf'_le id <| mem_filter.2 âŸ¨hb, â€¹_â€ºâŸ©\n  Â· exact bot_le\n\n"}
{"name":"Finset.truncatedInf_empty","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ² : SemilatticeInf Î±\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : BoundedOrder Î±\na : Î±\nâŠ¢ Eq (EmptyCollection.emptyCollection.truncatedInf a) Bot.bot","decl":"@[simp] lemma truncatedInf_empty (a : Î±) : truncatedInf âˆ… a = âŠ¥ := truncatedInf_of_not_mem (by simp)\n\n"}
{"name":"Finset.truncatedInf_singleton","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ² : SemilatticeInf Î±\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : BoundedOrder Î±\nb a : Î±\nâŠ¢ Eq ((Singleton.singleton b).truncatedInf a) (ite (LE.le b a) b Bot.bot)","decl":"@[simp] lemma truncatedInf_singleton (b a : Î±) : truncatedInf {b} a = if b â‰¤ a then b else âŠ¥ := by\n  simp only [truncatedInf, coe_singleton, upperClosure_singleton, UpperSet.mem_Ici_iff,\n    filter_congr_decidable, id_eq]\n  split_ifs <;> simp [Finset.filter_true_of_mem, *]\n\n"}
{"name":"Finset.map_truncatedInf","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâµ : SemilatticeInf Î±\ninstâœâ´ : SemilatticeInf Î²\ninstâœÂ³ : BoundedOrder Î²\ninstâœÂ² : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : BoundedOrder Î±\ne : OrderIso Î± Î²\ns : Finset Î±\na : Î±\nâŠ¢ Eq (e (s.truncatedInf a)) ((Finset.map e.toEmbedding s).truncatedInf (e a))","decl":"lemma map_truncatedInf (e : Î± â‰ƒo Î²) (s : Finset Î±) (a : Î±) :\n    e (truncatedInf s a) = truncatedInf (s.map e.toEquiv.toEmbedding) (e a) := by\n  have : e a âˆˆ upperClosure (s.map e.toEquiv.toEmbedding) â†” a âˆˆ upperClosure s := by simp\n  simp_rw [truncatedInf, apply_dite e, map_finset_inf', map_bot, this]\n  congr with h\n  simp only [filter_map, Function.comp_def, Equiv.coe_toEmbedding, RelIso.coe_fn_toEquiv,\n    OrderIso.le_iff_le, id, inf'_map]\n\n"}
{"name":"Finset.truncatedInf_of_isAntichain","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ² : SemilatticeInf Î±\ns : Finset Î±\na : Î±\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : BoundedOrder Î±\nhs : IsAntichain (fun x1 x2 => LE.le x1 x2) â†‘s\nha : Membership.mem s a\nâŠ¢ Eq (s.truncatedInf a) a","decl":"lemma truncatedInf_of_isAntichain (hs : IsAntichain (Â· â‰¤ Â·) (s : Set Î±)) (ha : a âˆˆ s) :\n    truncatedInf s a = a := by\n  refine le_antisymm truncatedInf_le ?_\n  simp_rw [truncatedInf_of_mem (subset_upperClosure ha), le_inf'_iff, mem_filter]\n  rintro b âŸ¨hb, hbaâŸ©\n  exact (hs.eq hb ha hba).ge\n\n"}
{"name":"Finset.truncatedInf_union","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ³ : SemilatticeInf Î±\ns t : Finset Î±\na : Î±\ninstâœÂ² : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœÂ¹ : BoundedOrder Î±\ninstâœ : DecidableEq Î±\nhs : Membership.mem (upperClosure â†‘s) a\nht : Membership.mem (upperClosure â†‘t) a\nâŠ¢ Eq ((Union.union s t).truncatedInf a) (Min.min (s.truncatedInf a) (t.truncatedInf a))","decl":"lemma truncatedInf_union (hs : a âˆˆ upperClosure s) (ht : a âˆˆ upperClosure t) :\n    truncatedInf (s âˆª t) a = truncatedInf s a âŠ“ truncatedInf t a := by\n  simpa only [truncatedInf_of_mem, hs, ht, upper_aux.2 (Or.inl hs), filter_union] using\n    inf'_union _ _ _\n\n"}
{"name":"Finset.truncatedInf_union_left","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ³ : SemilatticeInf Î±\ns t : Finset Î±\na : Î±\ninstâœÂ² : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœÂ¹ : BoundedOrder Î±\ninstâœ : DecidableEq Î±\nhs : Membership.mem (upperClosure â†‘s) a\nht : Not (Membership.mem (upperClosure â†‘t) a)\nâŠ¢ Eq ((Union.union s t).truncatedInf a) (s.truncatedInf a)","decl":"lemma truncatedInf_union_left (hs : a âˆˆ upperClosure s) (ht : a âˆ‰ upperClosure t) :\n    truncatedInf (s âˆª t) a = truncatedInf s a := by\n  simp only [mem_upperClosure, mem_coe, exists_prop, not_exists, not_and] at ht\n  simp only [truncatedInf_of_mem, hs, filter_union, filter_false_of_mem ht, union_empty,\n    upper_aux.2 (Or.inl hs), ht]\n\n"}
{"name":"Finset.truncatedInf_union_right","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ³ : SemilatticeInf Î±\ns t : Finset Î±\na : Î±\ninstâœÂ² : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœÂ¹ : BoundedOrder Î±\ninstâœ : DecidableEq Î±\nhs : Not (Membership.mem (upperClosure â†‘s) a)\nht : Membership.mem (upperClosure â†‘t) a\nâŠ¢ Eq ((Union.union s t).truncatedInf a) (t.truncatedInf a)","decl":"lemma truncatedInf_union_right (hs : a âˆ‰ upperClosure s) (ht : a âˆˆ upperClosure t) :\n    truncatedInf (s âˆª t) a = truncatedInf t a := by\n  rw [union_comm, truncatedInf_union_left ht hs]\n\n"}
{"name":"Finset.truncatedInf_union_of_not_mem","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ³ : SemilatticeInf Î±\ns t : Finset Î±\na : Î±\ninstâœÂ² : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœÂ¹ : BoundedOrder Î±\ninstâœ : DecidableEq Î±\nhs : Not (Membership.mem (upperClosure â†‘s) a)\nht : Not (Membership.mem (upperClosure â†‘t) a)\nâŠ¢ Eq ((Union.union s t).truncatedInf a) Bot.bot","decl":"lemma truncatedInf_union_of_not_mem (hs : a âˆ‰ upperClosure s) (ht : a âˆ‰ upperClosure t) :\n    truncatedInf (s âˆª t) a = âŠ¥ :=\n  truncatedInf_of_not_mem <| by rw [coe_union, upperClosure_union]; exact fun h â†¦ h.elim hs ht\n\n"}
{"name":"Finset.truncatedSup_infs","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ³ : DistribLattice Î±\ninstâœÂ² : DecidableEq Î±\ns t : Finset Î±\na : Î±\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : BoundedOrder Î±\nhs : Membership.mem (lowerClosure â†‘s) a\nht : Membership.mem (lowerClosure â†‘t) a\nâŠ¢ Eq ((HasInfs.infs s t).truncatedSup a) (Min.min (s.truncatedSup a) (t.truncatedSup a))","decl":"lemma truncatedSup_infs (hs : a âˆˆ lowerClosure s) (ht : a âˆˆ lowerClosure t) :\n    truncatedSup (s âŠ¼ t) a = truncatedSup s a âŠ“ truncatedSup t a := by\n  simp only [truncatedSup_of_mem, hs, ht, infs_aux.2 âŸ¨hs, htâŸ©, sup'_inf_sup', filter_infs_le]\n  simp_rw [â† image_inf_product]\n  rw [sup'_image]\n  simp [Function.uncurry_def]\n\n"}
{"name":"Finset.truncatedInf_sups","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ³ : DistribLattice Î±\ninstâœÂ² : DecidableEq Î±\ns t : Finset Î±\na : Î±\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : BoundedOrder Î±\nhs : Membership.mem (upperClosure â†‘s) a\nht : Membership.mem (upperClosure â†‘t) a\nâŠ¢ Eq ((HasSups.sups s t).truncatedInf a) (Max.max (s.truncatedInf a) (t.truncatedInf a))","decl":"lemma truncatedInf_sups (hs : a âˆˆ upperClosure s) (ht : a âˆˆ upperClosure t) :\n    truncatedInf (s âŠ» t) a = truncatedInf s a âŠ” truncatedInf t a := by\n  simp only [truncatedInf_of_mem, hs, ht, sups_aux.2 âŸ¨hs, htâŸ©, inf'_sup_inf', filter_sups_le]\n  simp_rw [â† image_sup_product]\n  rw [inf'_image]\n  simp [Function.uncurry_def]\n\n"}
{"name":"Finset.truncatedSup_infs_of_not_mem","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ³ : DistribLattice Î±\ninstâœÂ² : DecidableEq Î±\ns t : Finset Î±\na : Î±\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : BoundedOrder Î±\nha : Not (Membership.mem (Min.min (lowerClosure â†‘s) (lowerClosure â†‘t)) a)\nâŠ¢ Eq ((HasInfs.infs s t).truncatedSup a) Top.top","decl":"lemma truncatedSup_infs_of_not_mem (ha : a âˆ‰ lowerClosure s âŠ“ lowerClosure t) :\n    truncatedSup (s âŠ¼ t) a = âŠ¤ :=\n  truncatedSup_of_not_mem <| by rwa [coe_infs, lowerClosure_infs]\n\n"}
{"name":"Finset.truncatedInf_sups_of_not_mem","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ³ : DistribLattice Î±\ninstâœÂ² : DecidableEq Î±\ns t : Finset Î±\na : Î±\ninstâœÂ¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninstâœ : BoundedOrder Î±\nha : Not (Membership.mem (Max.max (upperClosure â†‘s) (upperClosure â†‘t)) a)\nâŠ¢ Eq ((HasSups.sups s t).truncatedInf a) Bot.bot","decl":"lemma truncatedInf_sups_of_not_mem (ha : a âˆ‰ upperClosure s âŠ” upperClosure t) :\n    truncatedInf (s âŠ» t) a = âŠ¥ :=\n  truncatedInf_of_not_mem <| by rwa [coe_sups, upperClosure_sups]\n\n"}
{"name":"Finset.compl_truncatedSup","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : BooleanAlgebra Î±\ninstâœ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset Î±\na : Î±\nâŠ¢ Eq (HasCompl.compl (s.truncatedSup a)) (s.compls.truncatedInf (HasCompl.compl a))","decl":"@[simp] lemma compl_truncatedSup (s : Finset Î±) (a : Î±) :\n    (truncatedSup s a)á¶œ = truncatedInf sá¶œË¢ aá¶œ := map_truncatedSup (OrderIso.compl Î±) _ _\n\n"}
{"name":"Finset.compl_truncatedInf","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : BooleanAlgebra Î±\ninstâœ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset Î±\na : Î±\nâŠ¢ Eq (HasCompl.compl (s.truncatedInf a)) (s.compls.truncatedSup (HasCompl.compl a))","decl":"@[simp] lemma compl_truncatedInf (s : Finset Î±) (a : Î±) :\n    (truncatedInf s a)á¶œ = truncatedSup sá¶œË¢ aá¶œ := map_truncatedInf (OrderIso.compl Î±) _ _\n\n"}
{"name":"Finset.card_truncatedSup_union_add_card_truncatedSup_infs","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nğ’œ â„¬ : Finset (Finset Î±)\ns : Finset Î±\nâŠ¢ Eq (HAdd.hAdd ((Union.union ğ’œ â„¬).truncatedSup s).card ((HasInfs.infs ğ’œ â„¬).truncatedSup s).card) (HAdd.hAdd (ğ’œ.truncatedSup s).card (â„¬.truncatedSup s).card)","decl":"lemma card_truncatedSup_union_add_card_truncatedSup_infs (ğ’œ â„¬ : Finset (Finset Î±)) (s : Finset Î±) :\n    #(truncatedSup (ğ’œ âˆª â„¬) s) + #(truncatedSup (ğ’œ âŠ¼ â„¬) s) =\n      #(truncatedSup ğ’œ s) + #(truncatedSup â„¬ s) := by\n  by_cases hğ’œ : s âˆˆ lowerClosure (ğ’œ : Set <| Finset Î±) <;>\n    by_cases hâ„¬ : s âˆˆ lowerClosure (â„¬ : Set <| Finset Î±)\n  Â· rw [truncatedSup_union hğ’œ hâ„¬, truncatedSup_infs hğ’œ hâ„¬]\n    exact card_union_add_card_inter _ _\n  Â· rw [truncatedSup_union_left hğ’œ hâ„¬, truncatedSup_of_not_mem hâ„¬,\n      truncatedSup_infs_of_not_mem fun h â†¦ hâ„¬ h.2]\n  Â· rw [truncatedSup_union_right hğ’œ hâ„¬, truncatedSup_of_not_mem hğ’œ,\n      truncatedSup_infs_of_not_mem fun h â†¦ hğ’œ h.1, add_comm]\n  Â· rw [truncatedSup_of_not_mem hğ’œ, truncatedSup_of_not_mem hâ„¬,\n      truncatedSup_union_of_not_mem hğ’œ hâ„¬, truncatedSup_infs_of_not_mem fun h â†¦ hğ’œ h.1]\n\n"}
{"name":"Finset.card_truncatedInf_union_add_card_truncatedInf_sups","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Fintype Î±\nğ’œ â„¬ : Finset (Finset Î±)\ns : Finset Î±\nâŠ¢ Eq (HAdd.hAdd ((Union.union ğ’œ â„¬).truncatedInf s).card ((HasSups.sups ğ’œ â„¬).truncatedInf s).card) (HAdd.hAdd (ğ’œ.truncatedInf s).card (â„¬.truncatedInf s).card)","decl":"lemma card_truncatedInf_union_add_card_truncatedInf_sups (ğ’œ â„¬ : Finset (Finset Î±)) (s : Finset Î±) :\n    #(truncatedInf (ğ’œ âˆª â„¬) s) + #(truncatedInf (ğ’œ âŠ» â„¬) s) =\n      #(truncatedInf ğ’œ s) + #(truncatedInf â„¬ s) := by\n  by_cases hğ’œ : s âˆˆ upperClosure (ğ’œ : Set <| Finset Î±) <;>\n    by_cases hâ„¬ : s âˆˆ upperClosure (â„¬ : Set <| Finset Î±)\n  Â· rw [truncatedInf_union hğ’œ hâ„¬, truncatedInf_sups hğ’œ hâ„¬]\n    exact card_inter_add_card_union _ _\n  Â· rw [truncatedInf_union_left hğ’œ hâ„¬, truncatedInf_of_not_mem hâ„¬,\n      truncatedInf_sups_of_not_mem fun h â†¦ hâ„¬ h.2]\n  Â· rw [truncatedInf_union_right hğ’œ hâ„¬, truncatedInf_of_not_mem hğ’œ,\n      truncatedInf_sups_of_not_mem fun h â†¦ hğ’œ h.1, add_comm]\n  Â· rw [truncatedInf_of_not_mem hğ’œ, truncatedInf_of_not_mem hâ„¬,\n      truncatedInf_union_of_not_mem hğ’œ hâ„¬, truncatedInf_sups_of_not_mem fun h â†¦ hğ’œ h.1]\n\n"}
{"name":"AhlswedeZhang.supSum_union_add_supSum_infs","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : Fintype Î±\ninstâœ : DecidableEq Î±\nğ’œ â„¬ : Finset (Finset Î±)\nâŠ¢ Eq (HAdd.hAdd (AhlswedeZhang.supSum (Union.union ğ’œ â„¬)) (AhlswedeZhang.supSum (HasInfs.infs ğ’œ â„¬))) (HAdd.hAdd (AhlswedeZhang.supSum ğ’œ) (AhlswedeZhang.supSum â„¬))","decl":"lemma supSum_union_add_supSum_infs (ğ’œ â„¬ : Finset (Finset Î±)) :\n    supSum (ğ’œ âˆª â„¬) + supSum (ğ’œ âŠ¼ â„¬) = supSum ğ’œ + supSum â„¬ := by\n  unfold supSum\n  rw [â† sum_add_distrib, â† sum_add_distrib, sum_congr rfl fun s _ â†¦ _]\n  simp_rw [div_add_div_same, â† Nat.cast_add, card_truncatedSup_union_add_card_truncatedSup_infs]\n  simp\n\n"}
{"name":"AhlswedeZhang.infSum_union_add_infSum_sups","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : Fintype Î±\ninstâœ : DecidableEq Î±\nğ’œ â„¬ : Finset (Finset Î±)\nâŠ¢ Eq (HAdd.hAdd (AhlswedeZhang.infSum (Union.union ğ’œ â„¬)) (AhlswedeZhang.infSum (HasSups.sups ğ’œ â„¬))) (HAdd.hAdd (AhlswedeZhang.infSum ğ’œ) (AhlswedeZhang.infSum â„¬))","decl":"lemma infSum_union_add_infSum_sups (ğ’œ â„¬ : Finset (Finset Î±)) :\n    infSum (ğ’œ âˆª â„¬) + infSum (ğ’œ âŠ» â„¬) = infSum ğ’œ + infSum â„¬ := by\n  unfold infSum\n  rw [â† sum_add_distrib, â† sum_add_distrib, sum_congr rfl fun s _ â†¦ _]\n  simp_rw [div_add_div_same, â† Nat.cast_add, card_truncatedInf_union_add_card_truncatedInf_sups]\n  simp\n\n"}
{"name":"AhlswedeZhang.IsAntichain.le_infSum","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : Fintype Î±\ninstâœ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\nhğ’œ : IsAntichain (fun x1 x2 => HasSubset.Subset x1 x2) â†‘ğ’œ\nhğ’œâ‚€ : Not (Membership.mem ğ’œ EmptyCollection.emptyCollection)\nâŠ¢ LE.le (ğ’œ.sum fun s => Inv.inv â†‘((Fintype.card Î±).choose s.card)) (AhlswedeZhang.infSum ğ’œ)","decl":"lemma IsAntichain.le_infSum (hğ’œ : IsAntichain (Â· âŠ† Â·) (ğ’œ : Set (Finset Î±))) (hğ’œâ‚€ : âˆ… âˆ‰ ğ’œ) :\n    âˆ‘ s âˆˆ ğ’œ, ((card Î±).choose #s : â„š)â»Â¹ â‰¤ infSum ğ’œ := by\n  calc\n    _ = âˆ‘ s âˆˆ ğ’œ, #(truncatedInf ğ’œ s) / (#s * (card Î±).choose #s : â„š) := ?_\n    _ â‰¤ _ := sum_le_univ_sum_of_nonneg fun s â†¦ by positivity\n  refine sum_congr rfl fun s hs â†¦ ?_\n  rw [truncatedInf_of_isAntichain hğ’œ hs, div_mul_cancel_leftâ‚€]\n  have := (nonempty_iff_ne_empty.2 <| ne_of_mem_of_not_mem hs hğ’œâ‚€).card_pos\n  positivity\n\n"}
{"name":"AhlswedeZhang.supSum_singleton","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ² : Fintype Î±\ninstâœÂ¹ : DecidableEq Î±\ns : Finset Î±\ninstâœ : Nonempty Î±\nhs : Ne s Finset.univ\nâŠ¢ Eq (AhlswedeZhang.supSum (Singleton.singleton s)) (HMul.hMul (â†‘(Fintype.card Î±)) ((Finset.range (Fintype.card Î±)).sum fun k => Inv.inv â†‘k))","decl":"@[simp] lemma supSum_singleton (hs : s â‰  univ) :\n    supSum ({s} : Finset (Finset Î±)) = card Î± * âˆ‘ k âˆˆ range (card Î±), (k : â„š)â»Â¹ := by\n  have : âˆ€ t : Finset Î±,\n    (card Î± - #(truncatedSup {s} t) : â„š) / ((card Î± - #t) * (card Î±).choose #t) =\n    if t âŠ† s then (card Î± - #s : â„š) / ((card Î± - #t) * (card Î±).choose #t) else 0 := by\n    rintro t\n    simp_rw [truncatedSup_singleton, le_iff_subset]\n    split_ifs <;> simp [card_univ]\n  simp_rw [â† sub_eq_of_eq_add (Fintype.sum_div_mul_card_choose_card Î±), eq_sub_iff_add_eq,\n    â† eq_sub_iff_add_eq', supSum, â† sum_sub_distrib, â† sub_div]\n  rw [sum_congr rfl fun t _ â†¦ this t, sum_ite, sum_const_zero, add_zero, filter_subset_univ,\n    sum_powerset, â† binomial_sum_eq ((card_lt_iff_ne_univ _).2 hs), eq_comm]\n  refine sum_congr rfl fun n _ â†¦ ?_\n  rw [mul_div_assoc, â† nsmul_eq_mul]\n  exact sum_powersetCard n s fun m â†¦ (card Î± - #s : â„š) / ((card Î± - m) * (card Î±).choose m)\n\n"}
{"name":"AhlswedeZhang.infSum_compls_add_supSum","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ² : Fintype Î±\ninstâœÂ¹ : DecidableEq Î±\ninstâœ : Nonempty Î±\nğ’œ : Finset (Finset Î±)\nâŠ¢ Eq (HAdd.hAdd (AhlswedeZhang.infSum ğ’œ.compls) (AhlswedeZhang.supSum ğ’œ)) (HAdd.hAdd (HMul.hMul (â†‘(Fintype.card Î±)) ((Finset.range (Fintype.card Î±)).sum fun k => Inv.inv â†‘k)) 1)","decl":"/-- The **Ahlswede-Zhang Identity**. -/\nlemma infSum_compls_add_supSum (ğ’œ : Finset (Finset Î±)) :\n    infSum ğ’œá¶œË¢ + supSum ğ’œ = card Î± * âˆ‘ k âˆˆ range (card Î±), (k : â„š)â»Â¹ + 1 := by\n  unfold infSum supSum\n  rw [â† @map_univ_of_surjective (Finset Î±) _ _ _ âŸ¨compl, compl_injectiveâŸ© compl_surjective, sum_map]\n  simp only [Function.Embedding.coeFn_mk, univ_map_embedding, â† compl_truncatedSup,\n    â† sum_add_distrib, card_compl, cast_sub (card_le_univ _), choose_symm (card_le_univ _),\n    div_add_div_same, sub_add_cancel, Fintype.sum_div_mul_card_choose_card]\n\n"}
{"name":"AhlswedeZhang.supSum_of_not_univ_mem","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ² : Fintype Î±\ninstâœÂ¹ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ninstâœ : Nonempty Î±\nhğ’œâ‚ : ğ’œ.Nonempty\nhğ’œâ‚‚ : Not (Membership.mem ğ’œ Finset.univ)\nâŠ¢ Eq (AhlswedeZhang.supSum ğ’œ) (HMul.hMul (â†‘(Fintype.card Î±)) ((Finset.range (Fintype.card Î±)).sum fun k => Inv.inv â†‘k))","decl":"lemma supSum_of_not_univ_mem (hğ’œâ‚ : ğ’œ.Nonempty) (hğ’œâ‚‚ : univ âˆ‰ ğ’œ) :\n    supSum ğ’œ = card Î± * âˆ‘ k âˆˆ range (card Î±), (k : â„š)â»Â¹ := by\n  set m := ğ’œ.card with hm\n  clear_value m\n  induction' m using Nat.strong_induction_on with m ih generalizing ğ’œ\n  replace ih := fun ğ’œ hğ’œ hğ’œâ‚ hğ’œâ‚‚ â†¦ @ih _ hğ’œ ğ’œ hğ’œâ‚ hğ’œâ‚‚ rfl\n  obtain âŸ¨a, rflâŸ© | hğ’œâ‚ƒ := hğ’œâ‚.exists_eq_singleton_or_nontrivial\n  Â· refine supSum_singleton ?_\n    simpa [eq_comm] using hğ’œâ‚‚\n  cases m\n  Â· cases hğ’œâ‚.card_pos.ne hm\n  obtain âŸ¨s, ğ’œ, hs, rfl, rflâŸ© := card_eq_succ.1 hm.symm\n  have hğ’œ : ğ’œ.Nonempty := nonempty_iff_ne_empty.2 (by rintro rfl; simp at hğ’œâ‚ƒ)\n  rw [insert_eq, eq_sub_of_add_eq (supSum_union_add_supSum_infs _ _), singleton_infs,\n    supSum_singleton (ne_of_mem_of_not_mem (mem_insert_self _ _) hğ’œâ‚‚), ih, ih, add_sub_cancel_right]\n  Â· exact card_image_le.trans_lt (lt_add_one _)\n  Â· exact hğ’œ.image _\n  Â· simpa using fun _ â†¦ ne_of_mem_of_not_mem (mem_insert_self _ _) hğ’œâ‚‚\n  Â· exact lt_add_one _\n  Â· exact hğ’œ\n  Â· exact fun h â†¦ hğ’œâ‚‚ (mem_insert_of_mem h)\n\n"}
{"name":"AhlswedeZhang.infSum_eq_one","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"Î± : Type u_1\ninstâœÂ² : Fintype Î±\ninstâœÂ¹ : DecidableEq Î±\nğ’œ : Finset (Finset Î±)\ninstâœ : Nonempty Î±\nhğ’œâ‚ : ğ’œ.Nonempty\nhğ’œâ‚€ : Not (Membership.mem ğ’œ EmptyCollection.emptyCollection)\nâŠ¢ Eq (AhlswedeZhang.infSum ğ’œ) 1","decl":"/-- The **Ahlswede-Zhang Identity**. -/\nlemma infSum_eq_one (hğ’œâ‚ : ğ’œ.Nonempty) (hğ’œâ‚€ : âˆ… âˆ‰ ğ’œ) : infSum ğ’œ = 1 := by\n  rw [â† compls_compls ğ’œ, eq_sub_of_add_eq (infSum_compls_add_supSum _),\n    supSum_of_not_univ_mem hğ’œâ‚.compls, add_sub_cancel_left]\n  simpa\n\n"}
