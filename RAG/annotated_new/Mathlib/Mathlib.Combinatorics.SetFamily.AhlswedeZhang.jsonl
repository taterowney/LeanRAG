{"name":"Finset.truncatedSup_of_mem","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝² : SemilatticeSup α\ns : Finset α\na : α\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : OrderTop α\nh : Membership.mem (lowerClosure ↑s) a\n⊢ Eq (s.truncatedSup a) ((Finset.filter (fun b => LE.le a b) s).sup' ⋯ id)","decl":"lemma truncatedSup_of_mem (h : a ∈ lowerClosure s) :\n    truncatedSup s a = {b ∈ s | a ≤ b}.sup' (sup_aux h) id := dif_pos h\n\n"}
{"name":"Finset.truncatedSup_of_not_mem","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝² : SemilatticeSup α\ns : Finset α\na : α\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : OrderTop α\nh : Not (Membership.mem (lowerClosure ↑s) a)\n⊢ Eq (s.truncatedSup a) Top.top","decl":"lemma truncatedSup_of_not_mem (h : a ∉ lowerClosure s) : truncatedSup s a = ⊤ := dif_neg h\n\n"}
{"name":"Finset.truncatedSup_empty","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝² : SemilatticeSup α\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : OrderTop α\na : α\n⊢ Eq (EmptyCollection.emptyCollection.truncatedSup a) Top.top","decl":"@[simp] lemma truncatedSup_empty (a : α) : truncatedSup ∅ a = ⊤ := truncatedSup_of_not_mem (by simp)\n\n"}
{"name":"Finset.truncatedSup_singleton","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝² : SemilatticeSup α\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : OrderTop α\nb a : α\n⊢ Eq ((Singleton.singleton b).truncatedSup a) (ite (LE.le a b) b Top.top)","decl":"@[simp] lemma truncatedSup_singleton (b a : α) : truncatedSup {b} a = if a ≤ b then b else ⊤ := by\n  simp [truncatedSup]; split_ifs <;> simp [Finset.filter_true_of_mem, *]\n\n"}
{"name":"Finset.le_truncatedSup","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝² : SemilatticeSup α\ns : Finset α\na : α\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : OrderTop α\n⊢ LE.le a (s.truncatedSup a)","decl":"lemma le_truncatedSup : a ≤ truncatedSup s a := by\n  rw [truncatedSup]\n  split_ifs with h\n  · obtain ⟨ℬ, hb, h⟩ := h\n    exact h.trans <| le_sup' id <| mem_filter.2 ⟨hb, h⟩\n  · exact le_top\n\n"}
{"name":"Finset.map_truncatedSup","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : SemilatticeSup α\ninst✝⁴ : SemilatticeSup β\ninst✝³ : BoundedOrder β\ninst✝² : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝¹ : OrderTop α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\ne : OrderIso α β\ns : Finset α\na : α\n⊢ Eq (e (s.truncatedSup a)) ((Finset.map e.toEmbedding s).truncatedSup (e a))","decl":"lemma map_truncatedSup [DecidableRel (α := β) (· ≤ ·)] (e : α ≃o β) (s : Finset α) (a : α) :\n    e (truncatedSup s a) = truncatedSup (s.map e.toEquiv.toEmbedding) (e a) := by\n  have : e a ∈ lowerClosure (s.map e.toEquiv.toEmbedding : Set β) ↔ a ∈ lowerClosure s := by simp\n  simp_rw [truncatedSup, apply_dite e, map_finset_sup', map_top, this]\n  congr with h\n  simp only [filter_map, Function.comp_def, Equiv.coe_toEmbedding, RelIso.coe_fn_toEquiv,\n    OrderIso.le_iff_le, id, sup'_map]\n\n"}
{"name":"Finset.truncatedSup_of_isAntichain","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝² : SemilatticeSup α\ns : Finset α\na : α\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : OrderTop α\nhs : IsAntichain (fun x1 x2 => LE.le x1 x2) ↑s\nha : Membership.mem s a\n⊢ Eq (s.truncatedSup a) a","decl":"lemma truncatedSup_of_isAntichain (hs : IsAntichain (· ≤ ·) (s : Set α)) (ha : a ∈ s) :\n    truncatedSup s a = a := by\n  refine le_antisymm ?_ le_truncatedSup\n  simp_rw [truncatedSup_of_mem (subset_lowerClosure ha), sup'_le_iff, mem_filter]\n  rintro b ⟨hb, hab⟩\n  exact (hs.eq ha hb hab).ge\n\n"}
{"name":"Finset.truncatedSup_union","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝³ : SemilatticeSup α\ns t : Finset α\na : α\ninst✝² : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝¹ : OrderTop α\ninst✝ : DecidableEq α\nhs : Membership.mem (lowerClosure ↑s) a\nht : Membership.mem (lowerClosure ↑t) a\n⊢ Eq ((Union.union s t).truncatedSup a) (Max.max (s.truncatedSup a) (t.truncatedSup a))","decl":"lemma truncatedSup_union (hs : a ∈ lowerClosure s) (ht : a ∈ lowerClosure t) :\n    truncatedSup (s ∪ t) a = truncatedSup s a ⊔ truncatedSup t a := by\n  simpa only [truncatedSup_of_mem, hs, ht, lower_aux.2 (Or.inl hs), filter_union] using\n    sup'_union _ _ _\n\n"}
{"name":"Finset.truncatedSup_union_left","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝³ : SemilatticeSup α\ns t : Finset α\na : α\ninst✝² : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝¹ : OrderTop α\ninst✝ : DecidableEq α\nhs : Membership.mem (lowerClosure ↑s) a\nht : Not (Membership.mem (lowerClosure ↑t) a)\n⊢ Eq ((Union.union s t).truncatedSup a) (s.truncatedSup a)","decl":"lemma truncatedSup_union_left (hs : a ∈ lowerClosure s) (ht : a ∉ lowerClosure t) :\n    truncatedSup (s ∪ t) a = truncatedSup s a := by\n  simp only [mem_lowerClosure, mem_coe, exists_prop, not_exists, not_and] at ht\n  simp only [truncatedSup_of_mem, hs, filter_union, filter_false_of_mem ht, union_empty,\n    lower_aux.2 (Or.inl hs), ht]\n\n"}
{"name":"Finset.truncatedSup_union_right","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝³ : SemilatticeSup α\ns t : Finset α\na : α\ninst✝² : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝¹ : OrderTop α\ninst✝ : DecidableEq α\nhs : Not (Membership.mem (lowerClosure ↑s) a)\nht : Membership.mem (lowerClosure ↑t) a\n⊢ Eq ((Union.union s t).truncatedSup a) (t.truncatedSup a)","decl":"lemma truncatedSup_union_right (hs : a ∉ lowerClosure s) (ht : a ∈ lowerClosure t) :\n    truncatedSup (s ∪ t) a = truncatedSup t a := by rw [union_comm, truncatedSup_union_left ht hs]\n\n"}
{"name":"Finset.truncatedSup_union_of_not_mem","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝³ : SemilatticeSup α\ns t : Finset α\na : α\ninst✝² : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝¹ : OrderTop α\ninst✝ : DecidableEq α\nhs : Not (Membership.mem (lowerClosure ↑s) a)\nht : Not (Membership.mem (lowerClosure ↑t) a)\n⊢ Eq ((Union.union s t).truncatedSup a) Top.top","decl":"lemma truncatedSup_union_of_not_mem (hs : a ∉ lowerClosure s) (ht : a ∉ lowerClosure t) :\n    truncatedSup (s ∪ t) a = ⊤ := truncatedSup_of_not_mem fun h ↦ (lower_aux.1 h).elim hs ht\n\n"}
{"name":"Finset.truncatedInf_of_mem","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝² : SemilatticeInf α\ns : Finset α\na : α\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : BoundedOrder α\nh : Membership.mem (upperClosure ↑s) a\n⊢ Eq (s.truncatedInf a) ((Finset.filter (fun b => LE.le b a) s).inf' ⋯ id)","decl":"lemma truncatedInf_of_mem (h : a ∈ upperClosure s) :\n    truncatedInf s a = {b ∈ s | b ≤ a}.inf' (inf_aux h) id := dif_pos h\n\n"}
{"name":"Finset.truncatedInf_of_not_mem","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝² : SemilatticeInf α\ns : Finset α\na : α\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : BoundedOrder α\nh : Not (Membership.mem (upperClosure ↑s) a)\n⊢ Eq (s.truncatedInf a) Bot.bot","decl":"lemma truncatedInf_of_not_mem (h : a ∉ upperClosure s) : truncatedInf s a = ⊥ := dif_neg h\n\n"}
{"name":"Finset.truncatedInf_le","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝² : SemilatticeInf α\ns : Finset α\na : α\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : BoundedOrder α\n⊢ LE.le (s.truncatedInf a) a","decl":"lemma truncatedInf_le : truncatedInf s a ≤ a := by\n  unfold truncatedInf\n  split_ifs with h\n  · obtain ⟨b, hb, hba⟩ := h\n    exact hba.trans' <| inf'_le id <| mem_filter.2 ⟨hb, ‹_›⟩\n  · exact bot_le\n\n"}
{"name":"Finset.truncatedInf_empty","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝² : SemilatticeInf α\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : BoundedOrder α\na : α\n⊢ Eq (EmptyCollection.emptyCollection.truncatedInf a) Bot.bot","decl":"@[simp] lemma truncatedInf_empty (a : α) : truncatedInf ∅ a = ⊥ := truncatedInf_of_not_mem (by simp)\n\n"}
{"name":"Finset.truncatedInf_singleton","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝² : SemilatticeInf α\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : BoundedOrder α\nb a : α\n⊢ Eq ((Singleton.singleton b).truncatedInf a) (ite (LE.le b a) b Bot.bot)","decl":"@[simp] lemma truncatedInf_singleton (b a : α) : truncatedInf {b} a = if b ≤ a then b else ⊥ := by\n  simp only [truncatedInf, coe_singleton, upperClosure_singleton, UpperSet.mem_Ici_iff,\n    filter_congr_decidable, id_eq]\n  split_ifs <;> simp [Finset.filter_true_of_mem, *]\n\n"}
{"name":"Finset.map_truncatedInf","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : SemilatticeInf α\ninst✝⁴ : SemilatticeInf β\ninst✝³ : BoundedOrder β\ninst✝² : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : BoundedOrder α\ne : OrderIso α β\ns : Finset α\na : α\n⊢ Eq (e (s.truncatedInf a)) ((Finset.map e.toEmbedding s).truncatedInf (e a))","decl":"lemma map_truncatedInf (e : α ≃o β) (s : Finset α) (a : α) :\n    e (truncatedInf s a) = truncatedInf (s.map e.toEquiv.toEmbedding) (e a) := by\n  have : e a ∈ upperClosure (s.map e.toEquiv.toEmbedding) ↔ a ∈ upperClosure s := by simp\n  simp_rw [truncatedInf, apply_dite e, map_finset_inf', map_bot, this]\n  congr with h\n  simp only [filter_map, Function.comp_def, Equiv.coe_toEmbedding, RelIso.coe_fn_toEquiv,\n    OrderIso.le_iff_le, id, inf'_map]\n\n"}
{"name":"Finset.truncatedInf_of_isAntichain","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝² : SemilatticeInf α\ns : Finset α\na : α\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : BoundedOrder α\nhs : IsAntichain (fun x1 x2 => LE.le x1 x2) ↑s\nha : Membership.mem s a\n⊢ Eq (s.truncatedInf a) a","decl":"lemma truncatedInf_of_isAntichain (hs : IsAntichain (· ≤ ·) (s : Set α)) (ha : a ∈ s) :\n    truncatedInf s a = a := by\n  refine le_antisymm truncatedInf_le ?_\n  simp_rw [truncatedInf_of_mem (subset_upperClosure ha), le_inf'_iff, mem_filter]\n  rintro b ⟨hb, hba⟩\n  exact (hs.eq hb ha hba).ge\n\n"}
{"name":"Finset.truncatedInf_union","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝³ : SemilatticeInf α\ns t : Finset α\na : α\ninst✝² : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝¹ : BoundedOrder α\ninst✝ : DecidableEq α\nhs : Membership.mem (upperClosure ↑s) a\nht : Membership.mem (upperClosure ↑t) a\n⊢ Eq ((Union.union s t).truncatedInf a) (Min.min (s.truncatedInf a) (t.truncatedInf a))","decl":"lemma truncatedInf_union (hs : a ∈ upperClosure s) (ht : a ∈ upperClosure t) :\n    truncatedInf (s ∪ t) a = truncatedInf s a ⊓ truncatedInf t a := by\n  simpa only [truncatedInf_of_mem, hs, ht, upper_aux.2 (Or.inl hs), filter_union] using\n    inf'_union _ _ _\n\n"}
{"name":"Finset.truncatedInf_union_left","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝³ : SemilatticeInf α\ns t : Finset α\na : α\ninst✝² : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝¹ : BoundedOrder α\ninst✝ : DecidableEq α\nhs : Membership.mem (upperClosure ↑s) a\nht : Not (Membership.mem (upperClosure ↑t) a)\n⊢ Eq ((Union.union s t).truncatedInf a) (s.truncatedInf a)","decl":"lemma truncatedInf_union_left (hs : a ∈ upperClosure s) (ht : a ∉ upperClosure t) :\n    truncatedInf (s ∪ t) a = truncatedInf s a := by\n  simp only [mem_upperClosure, mem_coe, exists_prop, not_exists, not_and] at ht\n  simp only [truncatedInf_of_mem, hs, filter_union, filter_false_of_mem ht, union_empty,\n    upper_aux.2 (Or.inl hs), ht]\n\n"}
{"name":"Finset.truncatedInf_union_right","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝³ : SemilatticeInf α\ns t : Finset α\na : α\ninst✝² : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝¹ : BoundedOrder α\ninst✝ : DecidableEq α\nhs : Not (Membership.mem (upperClosure ↑s) a)\nht : Membership.mem (upperClosure ↑t) a\n⊢ Eq ((Union.union s t).truncatedInf a) (t.truncatedInf a)","decl":"lemma truncatedInf_union_right (hs : a ∉ upperClosure s) (ht : a ∈ upperClosure t) :\n    truncatedInf (s ∪ t) a = truncatedInf t a := by\n  rw [union_comm, truncatedInf_union_left ht hs]\n\n"}
{"name":"Finset.truncatedInf_union_of_not_mem","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝³ : SemilatticeInf α\ns t : Finset α\na : α\ninst✝² : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝¹ : BoundedOrder α\ninst✝ : DecidableEq α\nhs : Not (Membership.mem (upperClosure ↑s) a)\nht : Not (Membership.mem (upperClosure ↑t) a)\n⊢ Eq ((Union.union s t).truncatedInf a) Bot.bot","decl":"lemma truncatedInf_union_of_not_mem (hs : a ∉ upperClosure s) (ht : a ∉ upperClosure t) :\n    truncatedInf (s ∪ t) a = ⊥ :=\n  truncatedInf_of_not_mem <| by rw [coe_union, upperClosure_union]; exact fun h ↦ h.elim hs ht\n\n"}
{"name":"Finset.truncatedSup_infs","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝³ : DistribLattice α\ninst✝² : DecidableEq α\ns t : Finset α\na : α\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : BoundedOrder α\nhs : Membership.mem (lowerClosure ↑s) a\nht : Membership.mem (lowerClosure ↑t) a\n⊢ Eq ((HasInfs.infs s t).truncatedSup a) (Min.min (s.truncatedSup a) (t.truncatedSup a))","decl":"lemma truncatedSup_infs (hs : a ∈ lowerClosure s) (ht : a ∈ lowerClosure t) :\n    truncatedSup (s ⊼ t) a = truncatedSup s a ⊓ truncatedSup t a := by\n  simp only [truncatedSup_of_mem, hs, ht, infs_aux.2 ⟨hs, ht⟩, sup'_inf_sup', filter_infs_le]\n  simp_rw [← image_inf_product]\n  rw [sup'_image]\n  simp [Function.uncurry_def]\n\n"}
{"name":"Finset.truncatedInf_sups","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝³ : DistribLattice α\ninst✝² : DecidableEq α\ns t : Finset α\na : α\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : BoundedOrder α\nhs : Membership.mem (upperClosure ↑s) a\nht : Membership.mem (upperClosure ↑t) a\n⊢ Eq ((HasSups.sups s t).truncatedInf a) (Max.max (s.truncatedInf a) (t.truncatedInf a))","decl":"lemma truncatedInf_sups (hs : a ∈ upperClosure s) (ht : a ∈ upperClosure t) :\n    truncatedInf (s ⊻ t) a = truncatedInf s a ⊔ truncatedInf t a := by\n  simp only [truncatedInf_of_mem, hs, ht, sups_aux.2 ⟨hs, ht⟩, inf'_sup_inf', filter_sups_le]\n  simp_rw [← image_sup_product]\n  rw [inf'_image]\n  simp [Function.uncurry_def]\n\n"}
{"name":"Finset.truncatedSup_infs_of_not_mem","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝³ : DistribLattice α\ninst✝² : DecidableEq α\ns t : Finset α\na : α\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : BoundedOrder α\nha : Not (Membership.mem (Min.min (lowerClosure ↑s) (lowerClosure ↑t)) a)\n⊢ Eq ((HasInfs.infs s t).truncatedSup a) Top.top","decl":"lemma truncatedSup_infs_of_not_mem (ha : a ∉ lowerClosure s ⊓ lowerClosure t) :\n    truncatedSup (s ⊼ t) a = ⊤ :=\n  truncatedSup_of_not_mem <| by rwa [coe_infs, lowerClosure_infs]\n\n"}
{"name":"Finset.truncatedInf_sups_of_not_mem","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝³ : DistribLattice α\ninst✝² : DecidableEq α\ns t : Finset α\na : α\ninst✝¹ : DecidableRel fun x1 x2 => LE.le x1 x2\ninst✝ : BoundedOrder α\nha : Not (Membership.mem (Max.max (upperClosure ↑s) (upperClosure ↑t)) a)\n⊢ Eq ((HasSups.sups s t).truncatedInf a) Bot.bot","decl":"lemma truncatedInf_sups_of_not_mem (ha : a ∉ upperClosure s ⊔ upperClosure t) :\n    truncatedInf (s ⊻ t) a = ⊥ :=\n  truncatedInf_of_not_mem <| by rwa [coe_sups, upperClosure_sups]\n\n"}
{"name":"Finset.compl_truncatedSup","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝¹ : BooleanAlgebra α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset α\na : α\n⊢ Eq (HasCompl.compl (s.truncatedSup a)) (s.compls.truncatedInf (HasCompl.compl a))","decl":"@[simp] lemma compl_truncatedSup (s : Finset α) (a : α) :\n    (truncatedSup s a)ᶜ = truncatedInf sᶜˢ aᶜ := map_truncatedSup (OrderIso.compl α) _ _\n\n"}
{"name":"Finset.compl_truncatedInf","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝¹ : BooleanAlgebra α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\ns : Finset α\na : α\n⊢ Eq (HasCompl.compl (s.truncatedInf a)) (s.compls.truncatedSup (HasCompl.compl a))","decl":"@[simp] lemma compl_truncatedInf (s : Finset α) (a : α) :\n    (truncatedInf s a)ᶜ = truncatedSup sᶜˢ aᶜ := map_truncatedInf (OrderIso.compl α) _ _\n\n"}
{"name":"Finset.card_truncatedSup_union_add_card_truncatedSup_infs","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n𝒜 ℬ : Finset (Finset α)\ns : Finset α\n⊢ Eq (HAdd.hAdd ((Union.union 𝒜 ℬ).truncatedSup s).card ((HasInfs.infs 𝒜 ℬ).truncatedSup s).card) (HAdd.hAdd (𝒜.truncatedSup s).card (ℬ.truncatedSup s).card)","decl":"lemma card_truncatedSup_union_add_card_truncatedSup_infs (𝒜 ℬ : Finset (Finset α)) (s : Finset α) :\n    #(truncatedSup (𝒜 ∪ ℬ) s) + #(truncatedSup (𝒜 ⊼ ℬ) s) =\n      #(truncatedSup 𝒜 s) + #(truncatedSup ℬ s) := by\n  by_cases h𝒜 : s ∈ lowerClosure (𝒜 : Set <| Finset α) <;>\n    by_cases hℬ : s ∈ lowerClosure (ℬ : Set <| Finset α)\n  · rw [truncatedSup_union h𝒜 hℬ, truncatedSup_infs h𝒜 hℬ]\n    exact card_union_add_card_inter _ _\n  · rw [truncatedSup_union_left h𝒜 hℬ, truncatedSup_of_not_mem hℬ,\n      truncatedSup_infs_of_not_mem fun h ↦ hℬ h.2]\n  · rw [truncatedSup_union_right h𝒜 hℬ, truncatedSup_of_not_mem h𝒜,\n      truncatedSup_infs_of_not_mem fun h ↦ h𝒜 h.1, add_comm]\n  · rw [truncatedSup_of_not_mem h𝒜, truncatedSup_of_not_mem hℬ,\n      truncatedSup_union_of_not_mem h𝒜 hℬ, truncatedSup_infs_of_not_mem fun h ↦ h𝒜 h.1]\n\n"}
{"name":"Finset.card_truncatedInf_union_add_card_truncatedInf_sups","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\n𝒜 ℬ : Finset (Finset α)\ns : Finset α\n⊢ Eq (HAdd.hAdd ((Union.union 𝒜 ℬ).truncatedInf s).card ((HasSups.sups 𝒜 ℬ).truncatedInf s).card) (HAdd.hAdd (𝒜.truncatedInf s).card (ℬ.truncatedInf s).card)","decl":"lemma card_truncatedInf_union_add_card_truncatedInf_sups (𝒜 ℬ : Finset (Finset α)) (s : Finset α) :\n    #(truncatedInf (𝒜 ∪ ℬ) s) + #(truncatedInf (𝒜 ⊻ ℬ) s) =\n      #(truncatedInf 𝒜 s) + #(truncatedInf ℬ s) := by\n  by_cases h𝒜 : s ∈ upperClosure (𝒜 : Set <| Finset α) <;>\n    by_cases hℬ : s ∈ upperClosure (ℬ : Set <| Finset α)\n  · rw [truncatedInf_union h𝒜 hℬ, truncatedInf_sups h𝒜 hℬ]\n    exact card_inter_add_card_union _ _\n  · rw [truncatedInf_union_left h𝒜 hℬ, truncatedInf_of_not_mem hℬ,\n      truncatedInf_sups_of_not_mem fun h ↦ hℬ h.2]\n  · rw [truncatedInf_union_right h𝒜 hℬ, truncatedInf_of_not_mem h𝒜,\n      truncatedInf_sups_of_not_mem fun h ↦ h𝒜 h.1, add_comm]\n  · rw [truncatedInf_of_not_mem h𝒜, truncatedInf_of_not_mem hℬ,\n      truncatedInf_union_of_not_mem h𝒜 hℬ, truncatedInf_sups_of_not_mem fun h ↦ h𝒜 h.1]\n\n"}
{"name":"AhlswedeZhang.supSum_union_add_supSum_infs","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\n𝒜 ℬ : Finset (Finset α)\n⊢ Eq (HAdd.hAdd (AhlswedeZhang.supSum (Union.union 𝒜 ℬ)) (AhlswedeZhang.supSum (HasInfs.infs 𝒜 ℬ))) (HAdd.hAdd (AhlswedeZhang.supSum 𝒜) (AhlswedeZhang.supSum ℬ))","decl":"lemma supSum_union_add_supSum_infs (𝒜 ℬ : Finset (Finset α)) :\n    supSum (𝒜 ∪ ℬ) + supSum (𝒜 ⊼ ℬ) = supSum 𝒜 + supSum ℬ := by\n  unfold supSum\n  rw [← sum_add_distrib, ← sum_add_distrib, sum_congr rfl fun s _ ↦ _]\n  simp_rw [div_add_div_same, ← Nat.cast_add, card_truncatedSup_union_add_card_truncatedSup_infs]\n  simp\n\n"}
{"name":"AhlswedeZhang.infSum_union_add_infSum_sups","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\n𝒜 ℬ : Finset (Finset α)\n⊢ Eq (HAdd.hAdd (AhlswedeZhang.infSum (Union.union 𝒜 ℬ)) (AhlswedeZhang.infSum (HasSups.sups 𝒜 ℬ))) (HAdd.hAdd (AhlswedeZhang.infSum 𝒜) (AhlswedeZhang.infSum ℬ))","decl":"lemma infSum_union_add_infSum_sups (𝒜 ℬ : Finset (Finset α)) :\n    infSum (𝒜 ∪ ℬ) + infSum (𝒜 ⊻ ℬ) = infSum 𝒜 + infSum ℬ := by\n  unfold infSum\n  rw [← sum_add_distrib, ← sum_add_distrib, sum_congr rfl fun s _ ↦ _]\n  simp_rw [div_add_div_same, ← Nat.cast_add, card_truncatedInf_union_add_card_truncatedInf_sups]\n  simp\n\n"}
{"name":"AhlswedeZhang.IsAntichain.le_infSum","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\n𝒜 : Finset (Finset α)\nh𝒜 : IsAntichain (fun x1 x2 => HasSubset.Subset x1 x2) ↑𝒜\nh𝒜₀ : Not (Membership.mem 𝒜 EmptyCollection.emptyCollection)\n⊢ LE.le (𝒜.sum fun s => Inv.inv ↑((Fintype.card α).choose s.card)) (AhlswedeZhang.infSum 𝒜)","decl":"lemma IsAntichain.le_infSum (h𝒜 : IsAntichain (· ⊆ ·) (𝒜 : Set (Finset α))) (h𝒜₀ : ∅ ∉ 𝒜) :\n    ∑ s ∈ 𝒜, ((card α).choose #s : ℚ)⁻¹ ≤ infSum 𝒜 := by\n  calc\n    _ = ∑ s ∈ 𝒜, #(truncatedInf 𝒜 s) / (#s * (card α).choose #s : ℚ) := ?_\n    _ ≤ _ := sum_le_univ_sum_of_nonneg fun s ↦ by positivity\n  refine sum_congr rfl fun s hs ↦ ?_\n  rw [truncatedInf_of_isAntichain h𝒜 hs, div_mul_cancel_left₀]\n  have := (nonempty_iff_ne_empty.2 <| ne_of_mem_of_not_mem hs h𝒜₀).card_pos\n  positivity\n\n"}
{"name":"AhlswedeZhang.supSum_singleton","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝² : Fintype α\ninst✝¹ : DecidableEq α\ns : Finset α\ninst✝ : Nonempty α\nhs : Ne s Finset.univ\n⊢ Eq (AhlswedeZhang.supSum (Singleton.singleton s)) (HMul.hMul (↑(Fintype.card α)) ((Finset.range (Fintype.card α)).sum fun k => Inv.inv ↑k))","decl":"@[simp] lemma supSum_singleton (hs : s ≠ univ) :\n    supSum ({s} : Finset (Finset α)) = card α * ∑ k ∈ range (card α), (k : ℚ)⁻¹ := by\n  have : ∀ t : Finset α,\n    (card α - #(truncatedSup {s} t) : ℚ) / ((card α - #t) * (card α).choose #t) =\n    if t ⊆ s then (card α - #s : ℚ) / ((card α - #t) * (card α).choose #t) else 0 := by\n    rintro t\n    simp_rw [truncatedSup_singleton, le_iff_subset]\n    split_ifs <;> simp [card_univ]\n  simp_rw [← sub_eq_of_eq_add (Fintype.sum_div_mul_card_choose_card α), eq_sub_iff_add_eq,\n    ← eq_sub_iff_add_eq', supSum, ← sum_sub_distrib, ← sub_div]\n  rw [sum_congr rfl fun t _ ↦ this t, sum_ite, sum_const_zero, add_zero, filter_subset_univ,\n    sum_powerset, ← binomial_sum_eq ((card_lt_iff_ne_univ _).2 hs), eq_comm]\n  refine sum_congr rfl fun n _ ↦ ?_\n  rw [mul_div_assoc, ← nsmul_eq_mul]\n  exact sum_powersetCard n s fun m ↦ (card α - #s : ℚ) / ((card α - m) * (card α).choose m)\n\n"}
{"name":"AhlswedeZhang.infSum_compls_add_supSum","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝² : Fintype α\ninst✝¹ : DecidableEq α\ninst✝ : Nonempty α\n𝒜 : Finset (Finset α)\n⊢ Eq (HAdd.hAdd (AhlswedeZhang.infSum 𝒜.compls) (AhlswedeZhang.supSum 𝒜)) (HAdd.hAdd (HMul.hMul (↑(Fintype.card α)) ((Finset.range (Fintype.card α)).sum fun k => Inv.inv ↑k)) 1)","decl":"/-- The **Ahlswede-Zhang Identity**. -/\nlemma infSum_compls_add_supSum (𝒜 : Finset (Finset α)) :\n    infSum 𝒜ᶜˢ + supSum 𝒜 = card α * ∑ k ∈ range (card α), (k : ℚ)⁻¹ + 1 := by\n  unfold infSum supSum\n  rw [← @map_univ_of_surjective (Finset α) _ _ _ ⟨compl, compl_injective⟩ compl_surjective, sum_map]\n  simp only [Function.Embedding.coeFn_mk, univ_map_embedding, ← compl_truncatedSup,\n    ← sum_add_distrib, card_compl, cast_sub (card_le_univ _), choose_symm (card_le_univ _),\n    div_add_div_same, sub_add_cancel, Fintype.sum_div_mul_card_choose_card]\n\n"}
{"name":"AhlswedeZhang.supSum_of_not_univ_mem","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝² : Fintype α\ninst✝¹ : DecidableEq α\n𝒜 : Finset (Finset α)\ninst✝ : Nonempty α\nh𝒜₁ : 𝒜.Nonempty\nh𝒜₂ : Not (Membership.mem 𝒜 Finset.univ)\n⊢ Eq (AhlswedeZhang.supSum 𝒜) (HMul.hMul (↑(Fintype.card α)) ((Finset.range (Fintype.card α)).sum fun k => Inv.inv ↑k))","decl":"lemma supSum_of_not_univ_mem (h𝒜₁ : 𝒜.Nonempty) (h𝒜₂ : univ ∉ 𝒜) :\n    supSum 𝒜 = card α * ∑ k ∈ range (card α), (k : ℚ)⁻¹ := by\n  set m := 𝒜.card with hm\n  clear_value m\n  induction' m using Nat.strong_induction_on with m ih generalizing 𝒜\n  replace ih := fun 𝒜 h𝒜 h𝒜₁ h𝒜₂ ↦ @ih _ h𝒜 𝒜 h𝒜₁ h𝒜₂ rfl\n  obtain ⟨a, rfl⟩ | h𝒜₃ := h𝒜₁.exists_eq_singleton_or_nontrivial\n  · refine supSum_singleton ?_\n    simpa [eq_comm] using h𝒜₂\n  cases m\n  · cases h𝒜₁.card_pos.ne hm\n  obtain ⟨s, 𝒜, hs, rfl, rfl⟩ := card_eq_succ.1 hm.symm\n  have h𝒜 : 𝒜.Nonempty := nonempty_iff_ne_empty.2 (by rintro rfl; simp at h𝒜₃)\n  rw [insert_eq, eq_sub_of_add_eq (supSum_union_add_supSum_infs _ _), singleton_infs,\n    supSum_singleton (ne_of_mem_of_not_mem (mem_insert_self _ _) h𝒜₂), ih, ih, add_sub_cancel_right]\n  · exact card_image_le.trans_lt (lt_add_one _)\n  · exact h𝒜.image _\n  · simpa using fun _ ↦ ne_of_mem_of_not_mem (mem_insert_self _ _) h𝒜₂\n  · exact lt_add_one _\n  · exact h𝒜\n  · exact fun h ↦ h𝒜₂ (mem_insert_of_mem h)\n\n"}
{"name":"AhlswedeZhang.infSum_eq_one","module":"Mathlib.Combinatorics.SetFamily.AhlswedeZhang","initialProofState":"α : Type u_1\ninst✝² : Fintype α\ninst✝¹ : DecidableEq α\n𝒜 : Finset (Finset α)\ninst✝ : Nonempty α\nh𝒜₁ : 𝒜.Nonempty\nh𝒜₀ : Not (Membership.mem 𝒜 EmptyCollection.emptyCollection)\n⊢ Eq (AhlswedeZhang.infSum 𝒜) 1","decl":"/-- The **Ahlswede-Zhang Identity**. -/\nlemma infSum_eq_one (h𝒜₁ : 𝒜.Nonempty) (h𝒜₀ : ∅ ∉ 𝒜) : infSum 𝒜 = 1 := by\n  rw [← compls_compls 𝒜, eq_sub_of_add_eq (infSum_compls_add_supSum _),\n    supSum_of_not_univ_mem h𝒜₁.compls, add_sub_cancel_left]\n  simpa\n\n"}
