{"name":"ModuleCat.coe_of","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù¬≤ : Ring R\nX : Type v\ninst‚úù¬π : Ring X\ninst‚úù : Module R X\n‚ä¢ Eq (‚Üë(ModuleCat.of R X)) X","decl":"lemma coe_of (X : Type v) [Ring X] [Module R X] : (of R X : Type v) = X :=\n  rfl\n\n-- Ensure the roundtrips are reducibly defeq (so tactics like `rw` can see through them).\n"}
{"name":"ModuleCat.Hom.ext","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\nx y : M.Hom N\nhom' : Eq x.hom' y.hom'\n‚ä¢ Eq x y","decl":"variable {R} in\n/-- The type of morphisms in `ModuleCat R`. -/\n@[ext]\nstructure Hom (M N : ModuleCat.{v} R) where\n  private mk ::\n  /-- The underlying linear map. -/\n  hom' : M ‚Üí‚Çó[R] N\n\n"}
{"name":"ModuleCat.Hom.ext_iff","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\nx y : M.Hom N\n‚ä¢ Iff (Eq x y) (Eq x.hom' y.hom')","decl":"variable {R} in\n/-- The type of morphisms in `ModuleCat R`. -/\n@[ext]\nstructure Hom (M N : ModuleCat.{v} R) where\n  private mk ::\n  /-- The underlying linear map. -/\n  hom' : M ‚Üí‚Çó[R] N\n\n"}
{"name":"ModuleCat.hom_id","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM : ModuleCat R\n‚ä¢ Eq (ModuleCat.Hom.hom (CategoryTheory.CategoryStruct.id M)) LinearMap.id","decl":"@[simp]\nlemma hom_id {M : ModuleCat.{v} R} : (ùüô M : M ‚ü∂ M).hom = LinearMap.id := rfl\n\n/- Provided for rewriting. -/\n"}
{"name":"ModuleCat.id_apply","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM : ModuleCat R\nx : ‚ÜëM\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.id M)) x) x","decl":"lemma id_apply (M : ModuleCat.{v} R) (x : M) :\n    (ùüô M : M ‚ü∂ M) x = x := by simp\n\n"}
{"name":"ModuleCat.hom_comp","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N O : ModuleCat R\nf : Quiver.Hom M N\ng : Quiver.Hom N O\n‚ä¢ Eq (ModuleCat.Hom.hom (CategoryTheory.CategoryStruct.comp f g)) ((ModuleCat.Hom.hom g).comp (ModuleCat.Hom.hom f))","decl":"@[simp]\nlemma hom_comp {M N O : ModuleCat.{v} R} (f : M ‚ü∂ N) (g : N ‚ü∂ O) :\n    (f ‚â´ g).hom = g.hom.comp f.hom := rfl\n\n/- Provided for rewriting. -/\n"}
{"name":"ModuleCat.comp_apply","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N O : ModuleCat R\nf : Quiver.Hom M N\ng : Quiver.Hom N O\nx : ‚ÜëM\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.CategoryStruct.comp f g)) x) ((CategoryTheory.ConcreteCategory.hom g) ((CategoryTheory.ConcreteCategory.hom f) x))","decl":"lemma comp_apply {M N O : ModuleCat.{v} R} (f : M ‚ü∂ N) (g : N ‚ü∂ O) (x : M) :\n    (f ‚â´ g) x = g (f x) := by simp\n\n"}
{"name":"ModuleCat.hom_ext_iff","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\nf g : Quiver.Hom M N\n‚ä¢ Iff (Eq f g) (Eq (ModuleCat.Hom.hom f) (ModuleCat.Hom.hom g))","decl":"@[ext]\nlemma hom_ext {M N : ModuleCat.{v} R} {f g : M ‚ü∂ N} (hf : f.hom = g.hom) : f = g :=\n  Hom.ext hf\n\n"}
{"name":"ModuleCat.hom_ext","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\nf g : Quiver.Hom M N\nhf : Eq (ModuleCat.Hom.hom f) (ModuleCat.Hom.hom g)\n‚ä¢ Eq f g","decl":"@[ext]\nlemma hom_ext {M N : ModuleCat.{v} R} {f g : M ‚ü∂ N} (hf : f.hom = g.hom) : f = g :=\n  Hom.ext hf\n\n"}
{"name":"ModuleCat.hom_bijective","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\n‚ä¢ Function.Bijective ModuleCat.Hom.hom","decl":"lemma hom_bijective {M N : ModuleCat.{v} R} :\n    Function.Bijective (Hom.hom : (M ‚ü∂ N) ‚Üí (M ‚Üí‚Çó[R] N)) where\n  left f g h := by cases f; cases g; simpa using h\n  right f := ‚ü®‚ü®f‚ü©, rfl‚ü©\n\n"}
{"name":"ModuleCat.hom_injective","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\n‚ä¢ Function.Injective ModuleCat.Hom.hom","decl":"/-- Convenience shortcut for `ModuleCat.hom_bijective.injective`. -/\nlemma hom_injective {M N : ModuleCat.{v} R} :\n    Function.Injective (Hom.hom : (M ‚ü∂ N) ‚Üí (M ‚Üí‚Çó[R] N)) :=\n  hom_bijective.injective\n\n"}
{"name":"ModuleCat.hom_surjective","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\n‚ä¢ Function.Surjective ModuleCat.Hom.hom","decl":"/-- Convenience shortcut for `ModuleCat.hom_bijective.surjective`. -/\nlemma hom_surjective {M N : ModuleCat.{v} R} :\n    Function.Surjective (Hom.hom : (M ‚ü∂ N) ‚Üí (M ‚Üí‚Çó[R] N)) :=\n  hom_bijective.surjective\n\n"}
{"name":"ModuleCat.hom_ofHom","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù‚Å¥ : Ring R\nX Y : Type v\ninst‚úù¬≥ : AddCommGroup X\ninst‚úù¬≤ : Module R X\ninst‚úù¬π : AddCommGroup Y\ninst‚úù : Module R Y\nf : LinearMap (RingHom.id R) X Y\n‚ä¢ Eq (ModuleCat.Hom.hom (ModuleCat.ofHom f)) f","decl":"@[simp]\nlemma hom_ofHom {X Y : Type v} [AddCommGroup X] [Module R X] [AddCommGroup Y]\n    [Module R Y] (f : X ‚Üí‚Çó[R] Y) : (ofHom f).hom = f := rfl\n\n"}
{"name":"ModuleCat.ofHom_hom","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\nf : Quiver.Hom M N\n‚ä¢ Eq (ModuleCat.ofHom (ModuleCat.Hom.hom f)) f","decl":"@[simp]\nlemma ofHom_hom {M N : ModuleCat.{v} R} (f : M ‚ü∂ N) :\n    ofHom (Hom.hom f) = f := rfl\n\n"}
{"name":"ModuleCat.ofHom_id","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù¬≤ : Ring R\nM : Type v\ninst‚úù¬π : AddCommGroup M\ninst‚úù : Module R M\n‚ä¢ Eq (ModuleCat.ofHom LinearMap.id) (CategoryTheory.CategoryStruct.id (ModuleCat.of R M))","decl":"@[simp]\nlemma ofHom_id {M : Type v} [AddCommGroup M] [Module R M] : ofHom LinearMap.id = ùüô (of R M) := rfl\n\n"}
{"name":"ModuleCat.ofHom_comp","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù‚Å∂ : Ring R\nM N O : Type v\ninst‚úù‚Åµ : AddCommGroup M\ninst‚úù‚Å¥ : AddCommGroup N\ninst‚úù¬≥ : AddCommGroup O\ninst‚úù¬≤ : Module R M\ninst‚úù¬π : Module R N\ninst‚úù : Module R O\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N O\n‚ä¢ Eq (ModuleCat.ofHom (g.comp f)) (CategoryTheory.CategoryStruct.comp (ModuleCat.ofHom f) (ModuleCat.ofHom g))","decl":"@[simp]\nlemma ofHom_comp {M N O : Type v} [AddCommGroup M] [AddCommGroup N] [AddCommGroup O] [Module R M]\n    [Module R N] [Module R O] (f : M ‚Üí‚Çó[R] N) (g : N ‚Üí‚Çó[R] O) :\n    ofHom (g.comp f) = ofHom f ‚â´ ofHom g :=\n  rfl\n\n/- Doesn't need to be `@[simp]` since `simp only` can solve this. -/\n"}
{"name":"ModuleCat.ofHom_apply","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù‚Å¥ : Ring R\nM N : Type v\ninst‚úù¬≥ : AddCommGroup M\ninst‚úù¬≤ : AddCommGroup N\ninst‚úù¬π : Module R M\ninst‚úù : Module R N\nf : LinearMap (RingHom.id R) M N\nx : M\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (ModuleCat.ofHom f)) x) (f x)","decl":"lemma ofHom_apply {M N : Type v} [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N]\n    (f : M ‚Üí‚Çó[R] N) (x : M) : ofHom f x = f x := rfl\n\n"}
{"name":"ModuleCat.inv_hom_apply","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\ne : CategoryTheory.Iso M N\nx : ‚ÜëM\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom e.inv) ((CategoryTheory.ConcreteCategory.hom e.hom) x)) x","decl":"@[simp]\nlemma inv_hom_apply {M N : ModuleCat.{v} R} (e : M ‚âÖ N) (x : M) : e.inv (e.hom x) = x := by\n  rw [‚Üê comp_apply]\n  simp\n\n"}
{"name":"ModuleCat.hom_inv_apply","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\ne : CategoryTheory.Iso M N\nx : ‚ÜëN\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom e.hom) ((CategoryTheory.ConcreteCategory.hom e.inv) x)) x","decl":"@[simp]\nlemma hom_inv_apply {M N : ModuleCat.{v} R} (e : M ‚âÖ N) (x : N) : e.hom (e.inv x) = x := by\n  rw [‚Üê comp_apply]\n  simp\n\n"}
{"name":"ModuleCat.forget_obj","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM : ModuleCat R\n‚ä¢ Eq ((CategoryTheory.forget (ModuleCat R)).obj M) ‚ÜëM","decl":"lemma forget_obj {M : ModuleCat.{v} R} : (forget (ModuleCat.{v} R)).obj M = M := rfl\n\n/- Not a `@[simp]` lemma since the LHS is a categorical arrow and the RHS is a plain function. -/\n"}
{"name":"ModuleCat.forget_map","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\nf : Quiver.Hom M N\n‚ä¢ Eq ((CategoryTheory.forget (ModuleCat R)).map f) ‚áë(CategoryTheory.ConcreteCategory.hom f)","decl":"lemma forget_map {M N : ModuleCat.{v} R} (f : M ‚ü∂ N) :\n    (forget (ModuleCat.{v} R)).map f = f :=\n  rfl\n\n-- Porting note:\n-- One might hope these two instances would not be needed,\n-- as we already have `AddCommGroup M` and `Module R M`,\n-- but sometimes we seem to need these when rewriting by lemmas about generic concrete categories.\n"}
{"name":"ModuleCat.forget‚ÇÇ_obj","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nX : ModuleCat R\n‚ä¢ Eq ((CategoryTheory.forget‚ÇÇ (ModuleCat R) AddCommGrp).obj X) (AddCommGrp.of ‚ÜëX)","decl":"@[simp]\ntheorem forget‚ÇÇ_obj (X : ModuleCat R) :\n    (forget‚ÇÇ (ModuleCat R) AddCommGrp).obj X = AddCommGrp.of X :=\n  rfl\n\n-- Porting note: the simpNF linter correctly doesn't like this.\n-- I'm not sure what this is for, actually.\n-- If it is really needed, better might be a simp lemma that says\n-- `AddCommGrp.of (ModuleCat.of R X) = AddCommGrp.of X`.\n-- @[simp 900]\n"}
{"name":"ModuleCat.forget‚ÇÇ_obj_moduleCat_of","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù¬≤ : Ring R\nX : Type v\ninst‚úù¬π : AddCommGroup X\ninst‚úù : Module R X\n‚ä¢ Eq ((CategoryTheory.forget‚ÇÇ (ModuleCat R) AddCommGrp).obj (ModuleCat.of R X)) (AddCommGrp.of X)","decl":"theorem forget‚ÇÇ_obj_moduleCat_of (X : Type v) [AddCommGroup X] [Module R X] :\n    (forget‚ÇÇ (ModuleCat R) AddCommGrp).obj (of R X) = AddCommGrp.of X :=\n  rfl\n\n"}
{"name":"ModuleCat.forget‚ÇÇ_map","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nX Y : ModuleCat R\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.forget‚ÇÇ (ModuleCat R) AddCommGrp).map f) (AddCommGrp.ofHom ‚Üë(ModuleCat.Hom.hom f))","decl":"@[simp]\ntheorem forget‚ÇÇ_map (X Y : ModuleCat R) (f : X ‚ü∂ Y) :\n    (forget‚ÇÇ (ModuleCat R) AddCommGrp).map f = AddCommGrp.ofHom f.hom :=\n  rfl\n\n"}
{"name":"ModuleCat.of_coe","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nX : ModuleCat R\n‚ä¢ Eq (ModuleCat.of R ‚ÜëX) X","decl":"@[simp] theorem of_coe (X : ModuleCat R) : of R X = X := rfl\n\n"}
{"name":"ModuleCat.ofSelfIso_hom","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM : ModuleCat R\n‚ä¢ Eq M.ofSelfIso.hom (CategoryTheory.CategoryStruct.id M)","decl":"/-- Forgetting to the underlying type and then building the bundled object returns the original\nmodule. -/\n@[simps]\ndef ofSelfIso (M : ModuleCat R) : ModuleCat.of R M ‚âÖ M where\n  hom := ùüô M\n  inv := ùüô M\n\n"}
{"name":"ModuleCat.ofSelfIso_inv","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM : ModuleCat R\n‚ä¢ Eq M.ofSelfIso.inv (CategoryTheory.CategoryStruct.id M)","decl":"/-- Forgetting to the underlying type and then building the bundled object returns the original\nmodule. -/\n@[simps]\ndef ofSelfIso (M : ModuleCat R) : ModuleCat.of R M ‚âÖ M where\n  hom := ùüô M\n  inv := ùüô M\n\n"}
{"name":"ModuleCat.isZero_of_subsingleton","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù¬π : Ring R\nM : ModuleCat R\ninst‚úù : Subsingleton ‚ÜëM\n‚ä¢ CategoryTheory.Limits.IsZero M","decl":"theorem isZero_of_subsingleton (M : ModuleCat R) [Subsingleton M] : IsZero M where\n  unique_to X := ‚ü®‚ü®‚ü®ofHom (0 : M ‚Üí‚Çó[R] X)‚ü©, fun f => by\n    ext x\n    rw [Subsingleton.elim x (0 : M)]\n    dsimp\n    simp‚ü©‚ü©\n  unique_from X := ‚ü®‚ü®‚ü®ofHom (0 : X ‚Üí‚Çó[R] M)‚ü©, fun f => by\n    ext x\n    subsingleton‚ü©‚ü©\n\n"}
{"name":"ModuleCat.instHasZeroObject","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\n‚ä¢ CategoryTheory.Limits.HasZeroObject (ModuleCat R)","decl":"instance : HasZeroObject (ModuleCat.{v} R) :=\n  ‚ü®‚ü®of R PUnit, isZero_of_subsingleton _‚ü©‚ü©\n\n"}
{"name":"ModuleCat.asHom_apply","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù‚Å¥ : Ring R\nM N : Type v\ninst‚úù¬≥ : AddCommGroup M\ninst‚úù¬≤ : AddCommGroup N\ninst‚úù¬π : Module R M\ninst‚úù : Module R N\nf : LinearMap (RingHom.id R) M N\nx : M\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (ModuleCat.ofHom f)) x) (f x)","decl":"@[deprecated (since := \"2024-10-06\")] alias ModuleCat.asHom_apply := ModuleCat.ofHom_apply\n\n-- Since `of` and the coercion now roundtrip reducibly, we don't need to distinguish in which place\n-- we need to add `of` when coercing from linear maps to morphisms.\n"}
{"name":"LinearEquiv.toModuleIso_inv","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nX‚ÇÅ X‚ÇÇ : Type v\ng‚ÇÅ : AddCommGroup X‚ÇÅ\ng‚ÇÇ : AddCommGroup X‚ÇÇ\nm‚ÇÅ : Module R X‚ÇÅ\nm‚ÇÇ : Module R X‚ÇÇ\ne : LinearEquiv (RingHom.id R) X‚ÇÅ X‚ÇÇ\n‚ä¢ Eq e.toModuleIso.inv (ModuleCat.ofHom ‚Üëe.symm)","decl":"/-- Build an isomorphism in the category `Module R` from a `LinearEquiv` between `Module`s. -/\n@[simps]\ndef LinearEquiv.toModuleIso {g‚ÇÅ : AddCommGroup X‚ÇÅ} {g‚ÇÇ : AddCommGroup X‚ÇÇ} {m‚ÇÅ : Module R X‚ÇÅ}\n    {m‚ÇÇ : Module R X‚ÇÇ} (e : X‚ÇÅ ‚âÉ‚Çó[R] X‚ÇÇ) : ModuleCat.of R X‚ÇÅ ‚âÖ ModuleCat.of R X‚ÇÇ where\n  hom := ofHom (e : X‚ÇÅ ‚Üí‚Çó[R] X‚ÇÇ)\n  inv := ofHom (e.symm : X‚ÇÇ ‚Üí‚Çó[R] X‚ÇÅ)\n  hom_inv_id := by ext; apply e.left_inv\n  inv_hom_id := by ext; apply e.right_inv\n\n"}
{"name":"LinearEquiv.toModuleIso_hom","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nX‚ÇÅ X‚ÇÇ : Type v\ng‚ÇÅ : AddCommGroup X‚ÇÅ\ng‚ÇÇ : AddCommGroup X‚ÇÇ\nm‚ÇÅ : Module R X‚ÇÅ\nm‚ÇÇ : Module R X‚ÇÇ\ne : LinearEquiv (RingHom.id R) X‚ÇÅ X‚ÇÇ\n‚ä¢ Eq e.toModuleIso.hom (ModuleCat.ofHom ‚Üëe)","decl":"/-- Build an isomorphism in the category `Module R` from a `LinearEquiv` between `Module`s. -/\n@[simps]\ndef LinearEquiv.toModuleIso {g‚ÇÅ : AddCommGroup X‚ÇÅ} {g‚ÇÇ : AddCommGroup X‚ÇÇ} {m‚ÇÅ : Module R X‚ÇÅ}\n    {m‚ÇÇ : Module R X‚ÇÇ} (e : X‚ÇÅ ‚âÉ‚Çó[R] X‚ÇÇ) : ModuleCat.of R X‚ÇÅ ‚âÖ ModuleCat.of R X‚ÇÇ where\n  hom := ofHom (e : X‚ÇÅ ‚Üí‚Çó[R] X‚ÇÇ)\n  inv := ofHom (e.symm : X‚ÇÇ ‚Üí‚Çó[R] X‚ÇÅ)\n  hom_inv_id := by ext; apply e.left_inv\n  inv_hom_id := by ext; apply e.right_inv\n\n"}
{"name":"linearEquivIsoModuleIso_hom","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù‚Å¥ : Ring R\nX Y : Type u\ninst‚úù¬≥ : AddCommGroup X\ninst‚úù¬≤ : AddCommGroup Y\ninst‚úù¬π : Module R X\ninst‚úù : Module R Y\ne : LinearEquiv (RingHom.id R) X Y\n‚ä¢ Eq (linearEquivIsoModuleIso.hom e) e.toModuleIso","decl":"/-- linear equivalences between `Module`s are the same as (isomorphic to) isomorphisms\nin `ModuleCat` -/\n@[simps]\ndef linearEquivIsoModuleIso {X Y : Type u} [AddCommGroup X] [AddCommGroup Y] [Module R X]\n    [Module R Y] : (X ‚âÉ‚Çó[R] Y) ‚âÖ ModuleCat.of R X ‚âÖ ModuleCat.of R Y where\n  hom e := e.toModuleIso\n  inv i := i.toLinearEquiv\n\n"}
{"name":"linearEquivIsoModuleIso_inv","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù‚Å¥ : Ring R\nX Y : Type u\ninst‚úù¬≥ : AddCommGroup X\ninst‚úù¬≤ : AddCommGroup Y\ninst‚úù¬π : Module R X\ninst‚úù : Module R Y\ni : CategoryTheory.Iso (ModuleCat.of R X) (ModuleCat.of R Y)\n‚ä¢ Eq (linearEquivIsoModuleIso.inv i) i.toLinearEquiv","decl":"/-- linear equivalences between `Module`s are the same as (isomorphic to) isomorphisms\nin `ModuleCat` -/\n@[simps]\ndef linearEquivIsoModuleIso {X Y : Type u} [AddCommGroup X] [AddCommGroup Y] [Module R X]\n    [Module R Y] : (X ‚âÉ‚Çó[R] Y) ‚âÖ ModuleCat.of R X ‚âÖ ModuleCat.of R Y where\n  hom e := e.toModuleIso\n  inv i := i.toLinearEquiv\n\n"}
{"name":"ModuleCat.hom_add","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\nf g : Quiver.Hom M N\n‚ä¢ Eq (ModuleCat.Hom.hom (HAdd.hAdd f g)) (HAdd.hAdd (ModuleCat.Hom.hom f) (ModuleCat.Hom.hom g))","decl":"@[simp] lemma hom_add (f g : M ‚ü∂ N) : (f + g).hom = f.hom + g.hom := rfl\n\n"}
{"name":"ModuleCat.hom_zero","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\n‚ä¢ Eq (ModuleCat.Hom.hom 0) 0","decl":"@[simp] lemma hom_zero : (0 : M ‚ü∂ N).hom = 0 := rfl\n\n"}
{"name":"ModuleCat.hom_nsmul","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\nn : Nat\nf : Quiver.Hom M N\n‚ä¢ Eq (ModuleCat.Hom.hom (HSMul.hSMul n f)) (HSMul.hSMul n (ModuleCat.Hom.hom f))","decl":"@[simp] lemma hom_nsmul (n : ‚Ñï) (f : M ‚ü∂ N) : (n ‚Ä¢ f).hom = n ‚Ä¢ f.hom := rfl\n\n"}
{"name":"ModuleCat.hom_neg","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\nf : Quiver.Hom M N\n‚ä¢ Eq (ModuleCat.Hom.hom (Neg.neg f)) (Neg.neg (ModuleCat.Hom.hom f))","decl":"@[simp] lemma hom_neg (f : M ‚ü∂ N) : (-f).hom = -f.hom := rfl\n\n"}
{"name":"ModuleCat.hom_sub","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\nf g : Quiver.Hom M N\n‚ä¢ Eq (ModuleCat.Hom.hom (HSub.hSub f g)) (HSub.hSub (ModuleCat.Hom.hom f) (ModuleCat.Hom.hom g))","decl":"@[simp] lemma hom_sub (f g : M ‚ü∂ N) : (f - g).hom = f.hom - g.hom := rfl\n\n"}
{"name":"ModuleCat.hom_zsmul","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\nn : Nat\nf : Quiver.Hom M N\n‚ä¢ Eq (ModuleCat.Hom.hom (HSMul.hSMul n f)) (HSMul.hSMul n (ModuleCat.Hom.hom f))","decl":"@[simp] lemma hom_zsmul (n : ‚Ñï) (f : M ‚ü∂ N) : (n ‚Ä¢ f).hom = n ‚Ä¢ f.hom := rfl\n\n"}
{"name":"ModuleCat.hom_sum","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\nŒπ : Type u_1\nf : Œπ ‚Üí Quiver.Hom M N\ns : Finset Œπ\n‚ä¢ Eq (ModuleCat.Hom.hom (s.sum fun i => f i)) (s.sum fun i => ModuleCat.Hom.hom (f i))","decl":"@[simp] lemma hom_sum {Œπ : Type*} (f : Œπ ‚Üí (M ‚ü∂ N)) (s : Finset Œπ) :\n    (‚àë i ‚àà s, f i).hom = ‚àë i ‚àà s, (f i).hom :=\n  map_sum ({ toFun := ModuleCat.Hom.hom, map_zero' := ModuleCat.hom_zero, map_add' := hom_add } :\n    (M ‚ü∂ N) ‚Üí+ (M ‚Üí‚Çó[R] N)) _ _\n\n"}
{"name":"ModuleCat.forget‚ÇÇ_addCommGrp_additive","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\n‚ä¢ (CategoryTheory.forget‚ÇÇ (ModuleCat R) AddCommGrp).Additive","decl":"instance forget‚ÇÇ_addCommGrp_additive :\n    (forget‚ÇÇ (ModuleCat.{v} R) AddCommGrp).Additive where\n\n"}
{"name":"ModuleCat.homAddEquiv_apply","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\nf : M.Hom N\n‚ä¢ Eq (ModuleCat.homAddEquiv f) f.hom","decl":"/-- `ModuleCat.Hom.hom` bundled as an additive equivalence. -/\n@[simps!]\ndef homAddEquiv : (M ‚ü∂ N) ‚âÉ+ (M ‚Üí‚Çó[R] N) :=\n  { homEquiv with\n    map_add' := fun _ _ => rfl }\n\n"}
{"name":"ModuleCat.homAddEquiv_symm_apply_hom","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\nf : LinearMap (RingHom.id R) ‚ÜëM ‚ÜëN\n‚ä¢ Eq (ModuleCat.Hom.hom (ModuleCat.homAddEquiv.symm f)) f","decl":"/-- `ModuleCat.Hom.hom` bundled as an additive equivalence. -/\n@[simps!]\ndef homAddEquiv : (M ‚ü∂ N) ‚âÉ+ (M ‚Üí‚Çó[R] N) :=\n  { homEquiv with\n    map_add' := fun _ _ => rfl }\n\n"}
{"name":"ModuleCat.hom_smul","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù¬≥ : Ring R\nM N : ModuleCat R\nS : Type u_1\ninst‚úù¬≤ : Monoid S\ninst‚úù¬π : DistribMulAction S ‚ÜëN\ninst‚úù : SMulCommClass R S ‚ÜëN\ns : S\nf : Quiver.Hom M N\n‚ä¢ Eq (ModuleCat.Hom.hom (HSMul.hSMul s f)) (HSMul.hSMul s (ModuleCat.Hom.hom f))","decl":"@[simp] lemma hom_smul (s : S) (f : M ‚ü∂ N) : (s ‚Ä¢ f).hom = s ‚Ä¢ f.hom := rfl\n\n"}
{"name":"ModuleCat.homLinearEquiv_apply","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù¬≥ : Ring R\nM N : ModuleCat R\nS : Type u_1\ninst‚úù¬≤ : Semiring S\ninst‚úù¬π : Module S ‚ÜëN\ninst‚úù : SMulCommClass R S ‚ÜëN\na‚úù : Quiver.Hom M N\n‚ä¢ Eq (ModuleCat.homLinearEquiv a‚úù) (ModuleCat.homAddEquiv.toFun a‚úù)","decl":"/-- `ModuleCat.Hom.hom` bundled as a linear equivalence. -/\n@[simps]\ndef homLinearEquiv : (M ‚ü∂ N) ‚âÉ‚Çó[S] (M ‚Üí‚Çó[R] N) :=\n  { homAddEquiv with\n    map_smul' := fun _ _ => rfl }\n\n"}
{"name":"ModuleCat.homLinearEquiv_symm_apply","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù¬≥ : Ring R\nM N : ModuleCat R\nS : Type u_1\ninst‚úù¬≤ : Semiring S\ninst‚úù¬π : Module S ‚ÜëN\ninst‚úù : SMulCommClass R S ‚ÜëN\na‚úù : LinearMap (RingHom.id R) ‚ÜëM ‚ÜëN\n‚ä¢ Eq (ModuleCat.homLinearEquiv.symm a‚úù) (ModuleCat.homAddEquiv.invFun a‚úù)","decl":"/-- `ModuleCat.Hom.hom` bundled as a linear equivalence. -/\n@[simps]\ndef homLinearEquiv : (M ‚ü∂ N) ‚âÉ‚Çó[S] (M ‚Üí‚Çó[R] N) :=\n  { homAddEquiv with\n    map_smul' := fun _ _ => rfl }\n\n"}
{"name":"ModuleCat.Iso.homCongr_eq_arrowCongr","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"S : Type u\ninst‚úù : CommRing S\nX Y X' Y' : ModuleCat S\ni : CategoryTheory.Iso X X'\nj : CategoryTheory.Iso Y Y'\nf : Quiver.Hom X Y\n‚ä¢ Eq ((i.homCongr j) f) { hom' := (i.toLinearEquiv.arrowCongr j.toLinearEquiv) (ModuleCat.Hom.hom f) }","decl":"theorem Iso.homCongr_eq_arrowCongr (i : X ‚âÖ X') (j : Y ‚âÖ Y') (f : X ‚ü∂ Y) :\n    Iso.homCongr i j f = ‚ü®LinearEquiv.arrowCongr i.toLinearEquiv j.toLinearEquiv f.hom‚ü© :=\n  rfl\n\n"}
{"name":"ModuleCat.Iso.conj_eq_conj","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"S : Type u\ninst‚úù : CommRing S\nX X' : ModuleCat S\ni : CategoryTheory.Iso X X'\nf : CategoryTheory.End X\n‚ä¢ Eq (i.conj f) { hom' := i.toLinearEquiv.conj (ModuleCat.Hom.hom f) }","decl":"theorem Iso.conj_eq_conj (i : X ‚âÖ X') (f : End X) :\n    Iso.conj i f = ‚ü®LinearEquiv.conj i.toLinearEquiv f.hom‚ü© :=\n  rfl\n\n"}
{"name":"ModuleCat.endRingEquiv_symm_apply_hom","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM : ModuleCat R\nf : LinearMap (RingHom.id R) ‚ÜëM ‚ÜëM\n‚ä¢ Eq (ModuleCat.Hom.hom (M.endRingEquiv.symm f)) f","decl":"/-- `ModuleCat.Hom.hom` as an isomorphism of rings. -/\n@[simps!] def endRingEquiv : End M ‚âÉ+* (M ‚Üí‚Çó[R] M) where\n  toFun := ModuleCat.Hom.hom\n  invFun := ModuleCat.ofHom\n  map_mul' _ _ := rfl\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_add' _ _ := rfl\n\n"}
{"name":"ModuleCat.endRingEquiv_apply","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM : ModuleCat R\nf : M.Hom M\n‚ä¢ Eq (M.endRingEquiv f) f.hom","decl":"/-- `ModuleCat.Hom.hom` as an isomorphism of rings. -/\n@[simps!] def endRingEquiv : End M ‚âÉ+* (M ‚Üí‚Çó[R] M) where\n  toFun := ModuleCat.Hom.hom\n  invFun := ModuleCat.ofHom\n  map_mul' _ _ := rfl\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_add' _ _ := rfl\n\n"}
{"name":"ModuleCat.smul_naturality","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\nf : Quiver.Hom M N\nr : R\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.forget‚ÇÇ (ModuleCat R) AddCommGrp).map f) (N.smul r)) (CategoryTheory.CategoryStruct.comp (M.smul r) ((CategoryTheory.forget‚ÇÇ (ModuleCat R) AddCommGrp).map f))","decl":"lemma smul_naturality {M N : ModuleCat.{v} R} (f : M ‚ü∂ N) (r : R) :\n    (forget‚ÇÇ (ModuleCat R) AddCommGrp).map f ‚â´ N.smul r =\n      M.smul r ‚â´ (forget‚ÇÇ (ModuleCat R) AddCommGrp).map f := by\n  ext x\n  exact (f.hom.map_smul r x).symm\n\n"}
{"name":"ModuleCat.smulNatTrans_apply_app","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nr : R\nM : ModuleCat R\n‚ä¢ Eq (((ModuleCat.smulNatTrans R) r).app M) (M.smul r)","decl":"/-- The scalar multiplication on `ModuleCat R` considered as a morphism of rings\nto the endomorphisms of the forgetful functor to `AddCommGrp)`. -/\n@[simps]\ndef smulNatTrans : R ‚Üí+* End (forget‚ÇÇ (ModuleCat R) AddCommGrp) where\n  toFun r :=\n    { app := fun M => M.smul r\n      naturality := fun _ _ _ => smul_naturality _ r }\n  map_one' := NatTrans.ext (by aesop_cat)\n  map_zero' := NatTrans.ext (by aesop_cat)\n  map_mul' _ _ := NatTrans.ext (by aesop_cat)\n  map_add' _ _ := NatTrans.ext (by aesop_cat)\n\n"}
{"name":"ModuleCat.mkOfSMul'_smul","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nA : AddCommGrp\nœÜ : RingHom R (CategoryTheory.End A)\nr : R\nx : ‚Üë(ModuleCat.mkOfSMul' œÜ)\n‚ä¢ Eq (HSMul.hSMul r x) ((CategoryTheory.ConcreteCategory.hom (letFun (œÜ r) fun this => this)) x)","decl":"@[simp]\nlemma mkOfSMul'_smul (r : R) (x : mkOfSMul' œÜ) :\n    r ‚Ä¢ x = (show A ‚ü∂ A from œÜ r) x := rfl\n\n"}
{"name":"ModuleCat.mkOfSMul_smul","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nA : AddCommGrp\nœÜ : RingHom R (CategoryTheory.End A)\nr : R\n‚ä¢ Eq ((ModuleCat.mkOfSMul œÜ).smul r) (œÜ r)","decl":"@[simp, nolint simpNF]\nlemma mkOfSMul_smul (r : R) : (mkOfSMul œÜ).smul r = œÜ r := rfl\n\n"}
{"name":"ModuleCat.homMk_hom_apply","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\nœÜ : Quiver.Hom ((CategoryTheory.forget‚ÇÇ (ModuleCat R) AddCommGrp).obj M) ((CategoryTheory.forget‚ÇÇ (ModuleCat R) AddCommGrp).obj N)\nhœÜ : ‚àÄ (r : R), Eq (CategoryTheory.CategoryStruct.comp œÜ (N.smul r)) (CategoryTheory.CategoryStruct.comp (M.smul r) œÜ)\na : ‚Üë((CategoryTheory.forget‚ÇÇ (ModuleCat R) AddCommGrp).obj M)\n‚ä¢ Eq ((ModuleCat.Hom.hom (ModuleCat.homMk œÜ hœÜ)) a) ((CategoryTheory.ConcreteCategory.hom œÜ) a)","decl":"/-- Constructor for morphisms in `ModuleCat R` which takes as inputs\na morphism between the underlying objects in `AddCommGrp` and the compatibility\nwith the scalar multiplication. -/\n@[simps]\ndef homMk : M ‚ü∂ N where\n  hom'.toFun := œÜ\n  hom'.map_add' _ _ := œÜ.hom.map_add _ _\n  hom'.map_smul' r x := (congr_hom (hœÜ r) x).symm\n\n"}
{"name":"ModuleCat.forget‚ÇÇ_map_homMk","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\nM N : ModuleCat R\nœÜ : Quiver.Hom ((CategoryTheory.forget‚ÇÇ (ModuleCat R) AddCommGrp).obj M) ((CategoryTheory.forget‚ÇÇ (ModuleCat R) AddCommGrp).obj N)\nhœÜ : ‚àÄ (r : R), Eq (CategoryTheory.CategoryStruct.comp œÜ (N.smul r)) (CategoryTheory.CategoryStruct.comp (M.smul r) œÜ)\n‚ä¢ Eq ((CategoryTheory.forget‚ÇÇ (ModuleCat R) AddCommGrp).map (ModuleCat.homMk œÜ hœÜ)) œÜ","decl":"lemma forget‚ÇÇ_map_homMk :\n    (forget‚ÇÇ (ModuleCat R) AddCommGrp).map (homMk œÜ hœÜ) = œÜ := rfl\n\n"}
{"name":"ModuleCat.instReflectsIsomorphismsForget","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\n‚ä¢ (CategoryTheory.forget (ModuleCat R)).ReflectsIsomorphisms","decl":"instance : (forget (ModuleCat.{v} R)).ReflectsIsomorphisms where\n  reflects f _ :=\n    (inferInstance : IsIso ((LinearEquiv.mk f.hom\n      (asIso ((forget (ModuleCat R)).map f)).toEquiv.invFun\n      (Equiv.left_inv _) (Equiv.right_inv _)).toModuleIso).hom)\n\n"}
{"name":"ModuleCat.instReflectsIsomorphismsAddCommGrpForget‚ÇÇ","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u\ninst‚úù : Ring R\n‚ä¢ (CategoryTheory.forget‚ÇÇ (ModuleCat R) AddCommGrp).ReflectsIsomorphisms","decl":"instance : (forget‚ÇÇ (ModuleCat.{v} R) AddCommGrp.{v}).ReflectsIsomorphisms where\n  reflects f _ := by\n    have : IsIso ((forget _).map f) := by\n      change IsIso ((forget _).map ((forget‚ÇÇ _ AddCommGrp).map f))\n      infer_instance\n    apply isIso_of_reflects_iso _ (forget _)\n\n"}
{"name":"ModuleCat.ofHom‚ÇÇ_hom_apply_hom","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nM N P : ModuleCat R\nf : LinearMap (RingHom.id R) (‚ÜëM) (LinearMap (RingHom.id R) ‚ÜëN ‚ÜëP)\na‚úù : ‚ÜëM\n‚ä¢ Eq (ModuleCat.Hom.hom ((ModuleCat.Hom.hom (ModuleCat.ofHom‚ÇÇ f)) a‚úù)) (f a‚úù)","decl":"/-- Turn a bilinear map into a homomorphism. -/\n@[simps!]\ndef ofHom‚ÇÇ {M N P : ModuleCat.{u} R} (f : M ‚Üí‚Çó[R] N ‚Üí‚Çó[R] P) :\n    M ‚ü∂ of R (N ‚ü∂ P) :=\n  ofHom <| homLinearEquiv.symm.toLinearMap ‚àò‚Çó f\n\n"}
{"name":"ModuleCat.Hom.hom‚ÇÇ_apply","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nM N P : ModuleCat R\nf : M.Hom (ModuleCat.of R (Quiver.Hom N P))\na‚úù : ‚ÜëM\n‚ä¢ Eq (f.hom‚ÇÇ a‚úù) ((ModuleCat.ofHom ‚ÜëModuleCat.homLinearEquiv).hom' (f.hom' a‚úù))","decl":"/-- Turn a homomorphism into a bilinear map. -/\n@[simps!]\ndef Hom.hom‚ÇÇ {M N P : ModuleCat.{u} R}\n    -- We write `Hom` instead of `M ‚ü∂ (of R (N ‚ü∂ P))`, otherwise dot notation breaks\n    -- since it is expecting the type of `f` to be `ModuleCat.Hom`, not `Quiver.Hom`.\n    (f : Hom M (of R (N ‚ü∂ P))) :\n    M ‚Üí‚Çó[R] N ‚Üí‚Çó[R] P :=\n  Hom.hom (by convert (f ‚â´ ofHom homLinearEquiv.toLinearMap))\n\n"}
{"name":"ModuleCat.Hom.hom‚ÇÇ_ofHom‚ÇÇ","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nM N P : ModuleCat R\nf : LinearMap (RingHom.id R) (‚ÜëM) (LinearMap (RingHom.id R) ‚ÜëN ‚ÜëP)\n‚ä¢ Eq (ModuleCat.Hom.hom‚ÇÇ (ModuleCat.ofHom‚ÇÇ f)) f","decl":"@[simp] lemma Hom.hom‚ÇÇ_ofHom‚ÇÇ {M N P : ModuleCat.{u} R} (f : M ‚Üí‚Çó[R] N ‚Üí‚Çó[R] P) :\n    (ofHom‚ÇÇ f).hom‚ÇÇ = f := rfl\n\n"}
{"name":"ModuleCat.ofHom‚ÇÇ_hom‚ÇÇ","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\nM N P : ModuleCat R\nf : Quiver.Hom M (ModuleCat.of R (Quiver.Hom N P))\n‚ä¢ Eq (ModuleCat.ofHom‚ÇÇ (ModuleCat.Hom.hom‚ÇÇ f)) f","decl":"@[simp] lemma ofHom‚ÇÇ_hom‚ÇÇ {M N P : ModuleCat.{u} R} (f : M ‚ü∂ of R (N ‚ü∂ P)) :\n    ofHom‚ÇÇ f.hom‚ÇÇ = f := rfl\n\n"}
{"name":"LinearMap.comp_id_moduleCat","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u_1\ninst‚úù¬≤ : Ring R\nG : ModuleCat R\nH : Type u\ninst‚úù¬π : AddCommGroup H\ninst‚úù : Module R H\nf : LinearMap (RingHom.id R) (‚ÜëG) H\n‚ä¢ Eq (f.comp (ModuleCat.Hom.hom (CategoryTheory.CategoryStruct.id G))) f","decl":"@[simp] theorem LinearMap.comp_id_moduleCat\n    {R} [Ring R] {G : ModuleCat.{u} R} {H : Type u} [AddCommGroup H] [Module R H] (f : G ‚Üí‚Çó[R] H) :\n    f.comp (ùüô G : G ‚ü∂ G).hom = f := by simp\n\n"}
{"name":"LinearMap.id_moduleCat_comp","module":"Mathlib.Algebra.Category.ModuleCat.Basic","initialProofState":"R : Type u_1\ninst‚úù¬≤ : Ring R\nG : Type u\ninst‚úù¬π : AddCommGroup G\ninst‚úù : Module R G\nH : ModuleCat R\nf : LinearMap (RingHom.id R) G ‚ÜëH\n‚ä¢ Eq ((ModuleCat.Hom.hom (CategoryTheory.CategoryStruct.id H)).comp f) f","decl":"@[simp] theorem LinearMap.id_moduleCat_comp\n    {R} [Ring R] {G : Type u} [AddCommGroup G] [Module R G] {H : ModuleCat.{u} R} (f : G ‚Üí‚Çó[R] H) :\n    LinearMap.comp (ùüô H : H ‚ü∂ H).hom f = f := by simp\n"}
