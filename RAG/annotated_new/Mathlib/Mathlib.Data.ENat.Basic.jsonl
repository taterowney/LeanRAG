{"name":"ENat.instCanonicallyOrderedAdd","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ CanonicallyOrderedAdd ENat","decl":"instance : CanonicallyOrderedAdd ℕ∞ := WithTop.canonicallyOrderedAdd\n"}
{"name":"ENat.instOrderedSub","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ OrderedSub ENat","decl":"instance : OrderedSub ℕ∞ := inferInstanceAs (OrderedSub (WithTop ℕ))\n"}
{"name":"ENat.instWellFoundedLT","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ WellFoundedLT ENat","decl":"instance : WellFoundedLT ℕ∞ := inferInstanceAs (WellFoundedLT (WithTop ℕ))\n"}
{"name":"ENat.instCharZero","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ CharZero ENat","decl":"instance : CharZero ℕ∞ := inferInstanceAs (CharZero (WithTop ℕ))\n\n"}
{"name":"ENat.some_eq_coe","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ Eq WithTop.some Nat.cast","decl":"/-- Lemmas about `WithTop` expect (and can output) `WithTop.some` but the normal form for coercion\n`ℕ → ℕ∞` is `Nat.cast`. -/\n@[simp] theorem some_eq_coe : (WithTop.some : ℕ → ℕ∞) = Nat.cast := rfl\n\n"}
{"name":"ENat.coe_inj","module":"Mathlib.Data.ENat.Basic","initialProofState":"a b : Nat\n⊢ Iff (Eq ↑a ↑b) (Eq a b)","decl":"theorem coe_inj {a b : ℕ} : (a : ℕ∞) = b ↔ a = b := WithTop.coe_inj\n\n"}
{"name":"ENat.coe_zero","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ Eq (↑0) 0","decl":"theorem coe_zero : ((0 : ℕ) : ℕ∞) = 0 :=\n  rfl\n\n"}
{"name":"ENat.coe_one","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ Eq (↑1) 1","decl":"theorem coe_one : ((1 : ℕ) : ℕ∞) = 1 :=\n  rfl\n\n"}
{"name":"ENat.coe_add","module":"Mathlib.Data.ENat.Basic","initialProofState":"m n : Nat\n⊢ Eq (↑(HAdd.hAdd m n)) (HAdd.hAdd ↑m ↑n)","decl":"theorem coe_add (m n : ℕ) : ↑(m + n) = (m + n : ℕ∞) :=\n  rfl\n\n"}
{"name":"ENat.coe_sub","module":"Mathlib.Data.ENat.Basic","initialProofState":"m n : Nat\n⊢ Eq (↑(HSub.hSub m n)) (HSub.hSub ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem coe_sub (m n : ℕ) : ↑(m - n) = (m - n : ℕ∞) :=\n  rfl\n\n"}
{"name":"ENat.coe_mul","module":"Mathlib.Data.ENat.Basic","initialProofState":"m n : Nat\n⊢ Eq (↑(HMul.hMul m n)) (HMul.hMul ↑m ↑n)","decl":"@[simp] lemma coe_mul (m n : ℕ) : ↑(m * n) = (m * n : ℕ∞) := rfl\n\n"}
{"name":"ENat.mul_top","module":"Mathlib.Data.ENat.Basic","initialProofState":"m : ENat\nhm : Ne m 0\n⊢ Eq (HMul.hMul m Top.top) Top.top","decl":"@[simp] theorem mul_top (hm : m ≠ 0) : m * ⊤ = ⊤ := WithTop.mul_top hm\n"}
{"name":"ENat.top_mul","module":"Mathlib.Data.ENat.Basic","initialProofState":"m : ENat\nhm : Ne m 0\n⊢ Eq (HMul.hMul Top.top m) Top.top","decl":"@[simp] theorem top_mul (hm : m ≠ 0) : ⊤ * m = ⊤ := WithTop.top_mul hm\n\n"}
{"name":"ENat.top_pow","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : Nat\nn_pos : LT.lt 0 n\n⊢ Eq (HPow.hPow Top.top n) Top.top","decl":"theorem top_pow {n : ℕ} (n_pos : 0 < n) : (⊤ : ℕ∞) ^ n = ⊤ := WithTop.top_pow n_pos\n\n"}
{"name":"ENat.coe_lift","module":"Mathlib.Data.ENat.Basic","initialProofState":"x : ENat\nh : LT.lt x Top.top\n⊢ Eq (↑(x.lift h)) x","decl":"@[simp] theorem coe_lift (x : ℕ∞) (h : x < ⊤) : (lift x h : ℕ∞) = x :=\n  WithTop.coe_untop x (WithTop.lt_top_iff_ne_top.mp h)\n"}
{"name":"ENat.lift_coe","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : Nat\n⊢ Eq ((↑n).lift ⋯) n","decl":"@[simp] theorem lift_coe (n : ℕ) : lift (n : ℕ∞) (WithTop.coe_lt_top n) = n := rfl\n"}
{"name":"ENat.lift_lt_iff","module":"Mathlib.Data.ENat.Basic","initialProofState":"x : ENat\nh : LT.lt x Top.top\nn : Nat\n⊢ Iff (LT.lt (x.lift h) n) (LT.lt x ↑n)","decl":"@[simp] theorem lift_lt_iff {x : ℕ∞} {h} {n : ℕ} : lift x h < n ↔ x < n := WithTop.untop_lt_iff _\n"}
{"name":"ENat.lift_le_iff","module":"Mathlib.Data.ENat.Basic","initialProofState":"x : ENat\nh : LT.lt x Top.top\nn : Nat\n⊢ Iff (LE.le (x.lift h) n) (LE.le x ↑n)","decl":"@[simp] theorem lift_le_iff {x : ℕ∞} {h} {n : ℕ} : lift x h ≤ n ↔ x ≤ n := WithTop.untop_le_iff _\n"}
{"name":"ENat.lt_lift_iff","module":"Mathlib.Data.ENat.Basic","initialProofState":"x : Nat\nn : ENat\nh : LT.lt n Top.top\n⊢ Iff (LT.lt x (n.lift h)) (LT.lt (↑x) n)","decl":"@[simp] theorem lt_lift_iff {x : ℕ} {n : ℕ∞} {h} : x < lift n h ↔ x < n := WithTop.lt_untop_iff _\n"}
{"name":"ENat.le_lift_iff","module":"Mathlib.Data.ENat.Basic","initialProofState":"x : Nat\nn : ENat\nh : LT.lt n Top.top\n⊢ Iff (LE.le x (n.lift h)) (LE.le (↑x) n)","decl":"@[simp] theorem le_lift_iff {x : ℕ} {n : ℕ∞} {h} : x ≤ lift n h ↔ x ≤ n := WithTop.le_untop_iff _\n\n"}
{"name":"ENat.lift_zero","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ Eq (ENat.lift 0 ⋯) 0","decl":"@[simp] theorem lift_zero : lift 0 (WithTop.coe_lt_top 0) = 0 := rfl\n"}
{"name":"ENat.lift_one","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ Eq (ENat.lift 1 ⋯) 1","decl":"@[simp] theorem lift_one : lift 1 (WithTop.coe_lt_top 1) = 1 := rfl\n"}
{"name":"ENat.lift_ofNat","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq ((OfNat.ofNat n).lift ⋯) (OfNat.ofNat n)","decl":"@[simp] theorem lift_ofNat (n : ℕ) [n.AtLeastTwo] :\n    lift ofNat(n) (WithTop.coe_lt_top n) = OfNat.ofNat n := rfl\n\n"}
{"name":"ENat.add_lt_top","module":"Mathlib.Data.ENat.Basic","initialProofState":"a b : ENat\n⊢ Iff (LT.lt (HAdd.hAdd a b) Top.top) (And (LT.lt a Top.top) (LT.lt b Top.top))","decl":"@[simp] theorem add_lt_top {a b : ℕ∞} : a + b < ⊤ ↔ a < ⊤ ∧ b < ⊤ := WithTop.add_lt_top\n\n"}
{"name":"ENat.lift_add","module":"Mathlib.Data.ENat.Basic","initialProofState":"a b : ENat\nh : LT.lt (HAdd.hAdd a b) Top.top\n⊢ Eq ((HAdd.hAdd a b).lift h) (HAdd.hAdd (a.lift ⋯) (b.lift ⋯))","decl":"@[simp] theorem lift_add (a b : ℕ∞) (h : a + b < ⊤) :\n    lift (a + b) h = lift a (add_lt_top.1 h).1 + lift b (add_lt_top.1 h).2 := by\n  apply coe_inj.1\n  simp\n\n"}
{"name":"ENat.canLift","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ CanLift ENat Nat Nat.cast fun x => Ne x Top.top","decl":"instance canLift : CanLift ℕ∞ ℕ (↑) (· ≠ ⊤) := WithTop.canLift\n\n"}
{"name":"ENat.coe_toNatHom","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ Eq (⇑ENat.toNatHom) ENat.toNat","decl":"@[simp, norm_cast] lemma coe_toNatHom : toNatHom = toNat := rfl\n\n"}
{"name":"ENat.toNatHom_apply","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : Nat\n⊢ Eq (ENat.toNatHom ↑n) (↑n).toNat","decl":"lemma toNatHom_apply (n : ℕ) : toNatHom n = toNat n := rfl\n\n"}
{"name":"ENat.toNat_coe","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : Nat\n⊢ Eq (↑n).toNat n","decl":"@[simp]\ntheorem toNat_coe (n : ℕ) : toNat n = n :=\n  rfl\n\n"}
{"name":"ENat.toNat_zero","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ Eq (ENat.toNat 0) 0","decl":"@[simp]\ntheorem toNat_zero : toNat 0 = 0 :=\n  rfl\n\n"}
{"name":"ENat.toNat_one","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ Eq (ENat.toNat 1) 1","decl":"@[simp]\ntheorem toNat_one : toNat 1 = 1 :=\n  rfl\n\n"}
{"name":"ENat.toNat_ofNat","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n).toNat n","decl":"@[simp]\ntheorem toNat_ofNat (n : ℕ) [n.AtLeastTwo] : toNat ofNat(n) = n :=\n  rfl\n\n"}
{"name":"ENat.toNat_top","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ Eq Top.top.toNat 0","decl":"@[simp]\ntheorem toNat_top : toNat ⊤ = 0 :=\n  rfl\n\n"}
{"name":"ENat.toNat_eq_zero","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : ENat\n⊢ Iff (Eq n.toNat 0) (Or (Eq n 0) (Eq n Top.top))","decl":"@[simp] theorem toNat_eq_zero : toNat n = 0 ↔ n = 0 ∨ n = ⊤ := WithTop.untop'_eq_self_iff\n\n"}
{"name":"ENat.recTopCoe_zero","module":"Mathlib.Data.ENat.Basic","initialProofState":"C : ENat → Sort u_1\nd : C Top.top\nf : (a : Nat) → C ↑a\n⊢ Eq (ENat.recTopCoe d f 0) (f 0)","decl":"@[simp]\ntheorem recTopCoe_zero {C : ℕ∞ → Sort*} (d : C ⊤) (f : ∀ a : ℕ, C a) : @recTopCoe C d f 0 = f 0 :=\n  rfl\n\n"}
{"name":"ENat.recTopCoe_one","module":"Mathlib.Data.ENat.Basic","initialProofState":"C : ENat → Sort u_1\nd : C Top.top\nf : (a : Nat) → C ↑a\n⊢ Eq (ENat.recTopCoe d f 1) (f 1)","decl":"@[simp]\ntheorem recTopCoe_one {C : ℕ∞ → Sort*} (d : C ⊤) (f : ∀ a : ℕ, C a) : @recTopCoe C d f 1 = f 1 :=\n  rfl\n\n"}
{"name":"ENat.recTopCoe_ofNat","module":"Mathlib.Data.ENat.Basic","initialProofState":"C : ENat → Sort u_1\nd : C Top.top\nf : (a : Nat) → C ↑a\nx : Nat\ninst✝ : x.AtLeastTwo\n⊢ Eq (ENat.recTopCoe d f (OfNat.ofNat x)) (f (OfNat.ofNat x))","decl":"@[simp]\ntheorem recTopCoe_ofNat {C : ℕ∞ → Sort*} (d : C ⊤) (f : ∀ a : ℕ, C a) (x : ℕ) [x.AtLeastTwo] :\n    @recTopCoe C d f ofNat(x) = f (OfNat.ofNat x) :=\n  rfl\n\n"}
{"name":"ENat.top_ne_coe","module":"Mathlib.Data.ENat.Basic","initialProofState":"a : Nat\n⊢ Ne Top.top ↑a","decl":"@[simp]\ntheorem top_ne_coe (a : ℕ) : ⊤ ≠ (a : ℕ∞) :=\n  nofun\n\n"}
{"name":"ENat.top_ne_ofNat","module":"Mathlib.Data.ENat.Basic","initialProofState":"a : Nat\ninst✝ : a.AtLeastTwo\n⊢ Ne Top.top (OfNat.ofNat a)","decl":"@[simp]\ntheorem top_ne_ofNat (a : ℕ) [a.AtLeastTwo] : ⊤ ≠ (ofNat(a) : ℕ∞) :=\n  nofun\n\n"}
{"name":"ENat.top_ne_zero","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ Ne Top.top 0","decl":"@[simp] lemma top_ne_zero : (⊤ : ℕ∞) ≠ 0 := nofun\n"}
{"name":"ENat.top_ne_one","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ Ne Top.top 1","decl":"@[simp] lemma top_ne_one : (⊤ : ℕ∞) ≠ 1 := nofun\n\n"}
{"name":"ENat.coe_ne_top","module":"Mathlib.Data.ENat.Basic","initialProofState":"a : Nat\n⊢ Ne (↑a) Top.top","decl":"@[simp]\ntheorem coe_ne_top (a : ℕ) : (a : ℕ∞) ≠ ⊤ :=\n  nofun\n\n"}
{"name":"ENat.ofNat_ne_top","module":"Mathlib.Data.ENat.Basic","initialProofState":"a : Nat\ninst✝ : a.AtLeastTwo\n⊢ Ne (OfNat.ofNat a) Top.top","decl":"@[simp]\ntheorem ofNat_ne_top (a : ℕ) [a.AtLeastTwo] : (ofNat(a) : ℕ∞) ≠ ⊤ :=\n  nofun\n\n"}
{"name":"ENat.zero_ne_top","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ Ne 0 Top.top","decl":"@[simp] lemma zero_ne_top : 0 ≠ (⊤ : ℕ∞) := nofun\n"}
{"name":"ENat.one_ne_top","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ Ne 1 Top.top","decl":"@[simp] lemma one_ne_top : 1 ≠ (⊤ : ℕ∞) := nofun\n\n"}
{"name":"ENat.top_sub_coe","module":"Mathlib.Data.ENat.Basic","initialProofState":"a : Nat\n⊢ Eq (HSub.hSub Top.top ↑a) Top.top","decl":"@[simp]\ntheorem top_sub_coe (a : ℕ) : (⊤ : ℕ∞) - a = ⊤ :=\n  WithTop.top_sub_coe\n\n"}
{"name":"ENat.top_sub_one","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ Eq (HSub.hSub Top.top 1) Top.top","decl":"@[simp]\ntheorem top_sub_one : (⊤ : ℕ∞) - 1 = ⊤ :=\n  top_sub_coe 1\n\n"}
{"name":"ENat.top_sub_ofNat","module":"Mathlib.Data.ENat.Basic","initialProofState":"a : Nat\ninst✝ : a.AtLeastTwo\n⊢ Eq (HSub.hSub Top.top (OfNat.ofNat a)) Top.top","decl":"@[simp]\ntheorem top_sub_ofNat (a : ℕ) [a.AtLeastTwo] : (⊤ : ℕ∞) - ofNat(a) = ⊤ :=\n  top_sub_coe a\n\n"}
{"name":"ENat.top_pos","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ LT.lt 0 Top.top","decl":"@[simp]\ntheorem top_pos : (0 : ℕ∞) < ⊤ :=\n  WithTop.top_pos\n\n"}
{"name":"ENat.zero_lt_top","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ LT.lt 0 Top.top","decl":"@[deprecated ENat.top_pos (since := \"2024-10-22\")]\nalias zero_lt_top := top_pos\n\n"}
{"name":"ENat.sub_top","module":"Mathlib.Data.ENat.Basic","initialProofState":"a : ENat\n⊢ Eq (HSub.hSub a Top.top) 0","decl":"theorem sub_top (a : ℕ∞) : a - ⊤ = 0 :=\n  WithTop.sub_top\n\n"}
{"name":"ENat.coe_toNat_eq_self","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : ENat\n⊢ Iff (Eq (↑n.toNat) n) (Ne n Top.top)","decl":"@[simp]\ntheorem coe_toNat_eq_self : ENat.toNat n = n ↔ n ≠ ⊤ :=\n  ENat.recTopCoe (by decide) (fun _ => by simp [toNat_coe]) n\n\n"}
{"name":"ENat.coe_toNat","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : ENat\na✝ : Ne n Top.top\n⊢ Eq (↑n.toNat) n","decl":"alias ⟨_, coe_toNat⟩ := coe_toNat_eq_self\n\n"}
{"name":"ENat.coe_toNat_le_self","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : ENat\n⊢ LE.le (↑n.toNat) n","decl":"theorem coe_toNat_le_self (n : ℕ∞) : ↑(toNat n) ≤ n :=\n  ENat.recTopCoe le_top (fun _ => le_rfl) n\n\n"}
{"name":"ENat.toNat_add","module":"Mathlib.Data.ENat.Basic","initialProofState":"m n : ENat\nhm : Ne m Top.top\nhn : Ne n Top.top\n⊢ Eq (HAdd.hAdd m n).toNat (HAdd.hAdd m.toNat n.toNat)","decl":"theorem toNat_add {m n : ℕ∞} (hm : m ≠ ⊤) (hn : n ≠ ⊤) : toNat (m + n) = toNat m + toNat n := by\n  lift m to ℕ using hm\n  lift n to ℕ using hn\n  rfl\n\n"}
{"name":"ENat.toNat_sub","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : ENat\nhn : Ne n Top.top\nm : ENat\n⊢ Eq (HSub.hSub m n).toNat (HSub.hSub m.toNat n.toNat)","decl":"theorem toNat_sub {n : ℕ∞} (hn : n ≠ ⊤) (m : ℕ∞) : toNat (m - n) = toNat m - toNat n := by\n  lift n to ℕ using hn\n  induction m\n  · rw [top_sub_coe, toNat_top, zero_tsub]\n  · rw [← coe_sub, toNat_coe, toNat_coe, toNat_coe]\n\n"}
{"name":"ENat.toNat_eq_iff","module":"Mathlib.Data.ENat.Basic","initialProofState":"m : ENat\nn : Nat\nhn : Ne n 0\n⊢ Iff (Eq m.toNat n) (Eq m ↑n)","decl":"theorem toNat_eq_iff {m : ℕ∞} {n : ℕ} (hn : n ≠ 0) : toNat m = n ↔ m = n := by\n  induction m <;> simp [hn.symm]\n\n"}
{"name":"ENat.toNat_le_of_le_coe","module":"Mathlib.Data.ENat.Basic","initialProofState":"m : ENat\nn : Nat\nh : LE.le m ↑n\n⊢ LE.le m.toNat n","decl":"lemma toNat_le_of_le_coe {m : ℕ∞} {n : ℕ} (h : m ≤ n) : toNat m ≤ n := by\n  lift m to ℕ using ne_top_of_le_ne_top (coe_ne_top n) h\n  simpa using h\n\n"}
{"name":"ENat.toNat_le_toNat","module":"Mathlib.Data.ENat.Basic","initialProofState":"m n : ENat\nh : LE.le m n\nhn : Ne n Top.top\n⊢ LE.le m.toNat n.toNat","decl":"@[gcongr]\nlemma toNat_le_toNat {m n : ℕ∞} (h : m ≤ n) (hn : n ≠ ⊤) : toNat m ≤ toNat n :=\n  toNat_le_of_le_coe <| h.trans_eq (coe_toNat hn).symm\n\n"}
{"name":"ENat.succ_def","module":"Mathlib.Data.ENat.Basic","initialProofState":"m : ENat\n⊢ Eq (Order.succ m) (HAdd.hAdd m 1)","decl":"@[simp]\ntheorem succ_def (m : ℕ∞) : Order.succ m = m + 1 :=\n  Order.succ_eq_add_one m\n\n"}
{"name":"ENat.add_one_le_of_lt","module":"Mathlib.Data.ENat.Basic","initialProofState":"m n : ENat\nh : LT.lt m n\n⊢ LE.le (HAdd.hAdd m 1) n","decl":"@[deprecated Order.add_one_le_of_lt (since := \"2024-09-04\")]\ntheorem add_one_le_of_lt (h : m < n) : m + 1 ≤ n :=\n  Order.add_one_le_of_lt h\n\n"}
{"name":"ENat.add_one_le_iff","module":"Mathlib.Data.ENat.Basic","initialProofState":"m n : ENat\nhm : Ne m Top.top\n⊢ Iff (LE.le (HAdd.hAdd m 1) n) (LT.lt m n)","decl":"theorem add_one_le_iff (hm : m ≠ ⊤) : m + 1 ≤ n ↔ m < n :=\n  Order.add_one_le_iff_of_not_isMax (not_isMax_iff_ne_top.mpr hm)\n\n"}
{"name":"ENat.one_le_iff_pos","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : ENat\n⊢ Iff (LE.le 1 n) (LT.lt 0 n)","decl":"@[deprecated Order.one_le_iff_pos (since := \"2024-09-04\")]\ntheorem one_le_iff_pos : 1 ≤ n ↔ 0 < n :=\n  Order.one_le_iff_pos\n\n"}
{"name":"ENat.one_le_iff_ne_zero","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : ENat\n⊢ Iff (LE.le 1 n) (Ne n 0)","decl":"theorem one_le_iff_ne_zero : 1 ≤ n ↔ n ≠ 0 :=\n  Order.one_le_iff_pos.trans pos_iff_ne_zero\n\n"}
{"name":"ENat.lt_one_iff_eq_zero","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : ENat\n⊢ Iff (LT.lt n 1) (Eq n 0)","decl":"lemma lt_one_iff_eq_zero : n < 1 ↔ n = 0 :=\n  not_le.symm.trans one_le_iff_ne_zero.not_left\n\n"}
{"name":"ENat.le_of_lt_add_one","module":"Mathlib.Data.ENat.Basic","initialProofState":"m n : ENat\nh : LT.lt m (HAdd.hAdd n 1)\n⊢ LE.le m n","decl":"@[deprecated Order.le_of_lt_add_one (since := \"2024-09-04\")]\ntheorem le_of_lt_add_one (h : m < n + 1) : m ≤ n :=\n  Order.le_of_lt_add_one h\n\n"}
{"name":"ENat.lt_add_one_iff","module":"Mathlib.Data.ENat.Basic","initialProofState":"m n : ENat\nhm : Ne n Top.top\n⊢ Iff (LT.lt m (HAdd.hAdd n 1)) (LE.le m n)","decl":"theorem lt_add_one_iff (hm : n ≠ ⊤) : m < n + 1 ↔ m ≤ n :=\n  Order.lt_add_one_iff_of_not_isMax (not_isMax_iff_ne_top.mpr hm)\n\n"}
{"name":"ENat.le_coe_iff","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : ENat\nk : Nat\n⊢ Iff (LE.le n ↑k) (Exists fun n₀ => And (Eq n ↑n₀) (LE.le n₀ k))","decl":"theorem le_coe_iff {n : ℕ∞} {k : ℕ} : n ≤ ↑k ↔ ∃ (n₀ : ℕ), n = n₀ ∧ n₀ ≤ k :=\n  WithTop.le_coe_iff\n\n"}
{"name":"ENat.not_lt_zero","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : ENat\n⊢ Not (LT.lt n 0)","decl":"@[simp]\nlemma not_lt_zero (n : ℕ∞) : ¬ n < 0 := by\n  cases n <;> simp\n\n"}
{"name":"ENat.coe_lt_top","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : Nat\n⊢ LT.lt (↑n) Top.top","decl":"@[simp]\nlemma coe_lt_top (n : ℕ) : (n : ℕ∞) < ⊤ :=\n  WithTop.coe_lt_top n\n\n"}
{"name":"ENat.coe_lt_coe","module":"Mathlib.Data.ENat.Basic","initialProofState":"n m : Nat\n⊢ Iff (LT.lt ↑n ↑m) (LT.lt n m)","decl":"lemma coe_lt_coe {n m : ℕ} : (n : ℕ∞) < (m : ℕ∞) ↔ n < m := by simp\n\n"}
{"name":"ENat.coe_le_coe","module":"Mathlib.Data.ENat.Basic","initialProofState":"n m : Nat\n⊢ Iff (LE.le ↑n ↑m) (LE.le n m)","decl":"lemma coe_le_coe {n m : ℕ} : (n : ℕ∞) ≤ (m : ℕ∞) ↔ n ≤ m := by simp\n\n"}
{"name":"ENat.nat_induction","module":"Mathlib.Data.ENat.Basic","initialProofState":"P : ENat → Prop\na : ENat\nh0 : P 0\nhsuc : ∀ (n : Nat), P ↑n → P ↑n.succ\nhtop : (∀ (n : Nat), P ↑n) → P Top.top\n⊢ P a","decl":"@[elab_as_elim]\ntheorem nat_induction {P : ℕ∞ → Prop} (a : ℕ∞) (h0 : P 0) (hsuc : ∀ n : ℕ, P n → P n.succ)\n    (htop : (∀ n : ℕ, P n) → P ⊤) : P a := by\n  have A : ∀ n : ℕ, P n := fun n => Nat.recOn n h0 hsuc\n  cases a\n  · exact htop A\n  · exact A _\n\n"}
{"name":"ENat.add_one_pos","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : ENat\n⊢ LT.lt 0 (HAdd.hAdd n 1)","decl":"lemma add_one_pos : 0 < n + 1 :=\n  succ_def n ▸ Order.bot_lt_succ n\n\n"}
{"name":"ENat.add_lt_add_iff_right","module":"Mathlib.Data.ENat.Basic","initialProofState":"m n k : ENat\nh : Ne k Top.top\n⊢ Iff (LT.lt (HAdd.hAdd n k) (HAdd.hAdd m k)) (LT.lt n m)","decl":"lemma add_lt_add_iff_right {k : ℕ∞} (h : k ≠ ⊤) : n + k < m + k ↔ n < m :=\n  WithTop.add_lt_add_iff_right h\n\n"}
{"name":"ENat.add_lt_add_iff_left","module":"Mathlib.Data.ENat.Basic","initialProofState":"m n k : ENat\nh : Ne k Top.top\n⊢ Iff (LT.lt (HAdd.hAdd k n) (HAdd.hAdd k m)) (LT.lt n m)","decl":"lemma add_lt_add_iff_left {k : ℕ∞} (h : k ≠ ⊤) : k + n < k + m ↔ n < m :=\n  WithTop.add_lt_add_iff_left h\n\n"}
{"name":"ENat.exists_nat_gt","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : ENat\nhn : Ne n Top.top\n⊢ Exists fun m => LT.lt n ↑m","decl":"protected lemma exists_nat_gt {n : ℕ∞} (hn : n ≠ ⊤) : ∃ m : ℕ, n < m := by\n  lift n to ℕ using hn\n  obtain ⟨m, hm⟩ := exists_gt n\n  exact ⟨m, Nat.cast_lt.2 hm⟩\n\n"}
{"name":"ENat.ne_top_iff_exists","module":"Mathlib.Data.ENat.Basic","initialProofState":"x : ENat\n⊢ Iff (Ne x Top.top) (Exists fun a => Eq (↑a) x)","decl":"lemma ne_top_iff_exists {x : ℕ∞} : x ≠ ⊤ ↔ ∃ a : ℕ, ↑a = x := WithTop.ne_top_iff_exists\n\n"}
{"name":"ENat.sub_eq_top_iff","module":"Mathlib.Data.ENat.Basic","initialProofState":"a b : ENat\n⊢ Iff (Eq (HSub.hSub a b) Top.top) (And (Eq a Top.top) (Ne b Top.top))","decl":"@[simp] lemma sub_eq_top_iff : a - b = ⊤ ↔ a = ⊤ ∧ b ≠ ⊤ := WithTop.sub_eq_top_iff\n"}
{"name":"ENat.sub_ne_top_iff","module":"Mathlib.Data.ENat.Basic","initialProofState":"a b : ENat\n⊢ Iff (Ne (HSub.hSub a b) Top.top) (Or (Ne a Top.top) (Eq b Top.top))","decl":"lemma sub_ne_top_iff : a - b ≠ ⊤ ↔ a ≠ ⊤ ∨ b = ⊤ := WithTop.sub_ne_top_iff\n\n"}
{"name":"ENat.addLECancellable_of_ne_top","module":"Mathlib.Data.ENat.Basic","initialProofState":"a : ENat\na✝ : Ne a Top.top\n⊢ AddLECancellable a","decl":"lemma addLECancellable_of_ne_top : a ≠ ⊤ → AddLECancellable a := WithTop.addLECancellable_of_ne_top\n"}
{"name":"ENat.addLECancellable_of_lt_top","module":"Mathlib.Data.ENat.Basic","initialProofState":"a : ENat\na✝ : LT.lt a Top.top\n⊢ AddLECancellable a","decl":"lemma addLECancellable_of_lt_top : a < ⊤ → AddLECancellable a := WithTop.addLECancellable_of_lt_top\n"}
{"name":"ENat.addLECancellable_coe","module":"Mathlib.Data.ENat.Basic","initialProofState":"a : Nat\n⊢ AddLECancellable ↑a","decl":"lemma addLECancellable_coe (a : ℕ) : AddLECancellable (a : ℕ∞) := WithTop.addLECancellable_coe _\n\n"}
{"name":"ENat.le_sub_of_add_le_left","module":"Mathlib.Data.ENat.Basic","initialProofState":"a b c : ENat\nha : Ne a Top.top\na✝ : LE.le (HAdd.hAdd a b) c\n⊢ LE.le b (HSub.hSub c a)","decl":"protected lemma le_sub_of_add_le_left (ha : a ≠ ⊤) : a + b ≤ c → b ≤ c - a :=\n  (addLECancellable_of_ne_top ha).le_tsub_of_add_le_left\n\n"}
{"name":"ENat.sub_sub_cancel","module":"Mathlib.Data.ENat.Basic","initialProofState":"a b : ENat\nh : Ne a Top.top\nh2 : LE.le b a\n⊢ Eq (HSub.hSub a (HSub.hSub a b)) b","decl":"protected lemma sub_sub_cancel (h : a ≠ ⊤) (h2 : b ≤ a) : a - (a - b) = b :=\n  (addLECancellable_of_ne_top <| ne_top_of_le_ne_top h tsub_le_self).tsub_tsub_cancel_of_le h2\n\n"}
{"name":"ENat.add_one_natCast_le_withTop_of_lt","module":"Mathlib.Data.ENat.Basic","initialProofState":"m : Nat\nn : WithTop ENat\nh : LT.lt (↑m) n\n⊢ LE.le (↑(HAdd.hAdd m 1)) n","decl":"lemma add_one_natCast_le_withTop_of_lt {m : ℕ} {n : WithTop ℕ∞} (h : m < n) : (m + 1 : ℕ) ≤ n := by\n  match n with\n  | ⊤ => exact le_top\n  | (⊤ : ℕ∞) => exact WithTop.coe_le_coe.2 (OrderTop.le_top _)\n  | (n : ℕ) => simpa only [Nat.cast_le, ge_iff_le, Nat.cast_lt] using h\n\n"}
{"name":"ENat.coe_top_add_one","module":"Mathlib.Data.ENat.Basic","initialProofState":"⊢ Eq (HAdd.hAdd (↑Top.top) 1) ↑Top.top","decl":"@[simp] lemma coe_top_add_one : ((⊤ : ℕ∞) : WithTop ℕ∞) + 1 = (⊤ : ℕ∞) := rfl\n\n"}
{"name":"ENat.add_one_eq_coe_top_iff","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : WithTop ENat\n⊢ Iff (Eq (HAdd.hAdd n 1) ↑Top.top) (Eq n ↑Top.top)","decl":"@[simp] lemma add_one_eq_coe_top_iff {n : WithTop ℕ∞} : n + 1 = (⊤ : ℕ∞) ↔ n = (⊤ : ℕ∞) := by\n  match n with\n  | ⊤ => exact Iff.rfl\n  | (⊤ : ℕ∞) => simp\n  | (n : ℕ) =>\n    norm_cast\n    simp only [coe_ne_top, iff_false, ne_eq]\n\n"}
{"name":"ENat.natCast_ne_coe_top","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : Nat\n⊢ Ne ↑n ↑Top.top","decl":"@[simp] lemma natCast_ne_coe_top (n : ℕ) : (n : WithTop ℕ∞) ≠ (⊤ : ℕ∞) := nofun\n\n"}
{"name":"ENat.nat_ne_coe_top","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : Nat\n⊢ Ne ↑n ↑Top.top","decl":"@[deprecated (since := \"2024-10-22\")]\nalias nat_ne_coe_top := natCast_ne_coe_top\n\n"}
{"name":"ENat.one_le_iff_ne_zero_withTop","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : WithTop ENat\n⊢ Iff (LE.le 1 n) (Ne n 0)","decl":"lemma one_le_iff_ne_zero_withTop {n : WithTop ℕ∞} : 1 ≤ n ↔ n ≠ 0 :=\n  ⟨fun h ↦ (zero_lt_one.trans_le h).ne',\n    fun h ↦ add_one_natCast_le_withTop_of_lt (pos_iff_ne_zero.mpr h)⟩\n\n"}
{"name":"ENat.natCast_le_of_coe_top_le_withTop","module":"Mathlib.Data.ENat.Basic","initialProofState":"N : WithTop ENat\nhN : LE.le (↑Top.top) N\nn : Nat\n⊢ LE.le (↑n) N","decl":"lemma natCast_le_of_coe_top_le_withTop {N : WithTop ℕ∞} (hN : (⊤ : ℕ∞) ≤ N) (n : ℕ) : n ≤ N :=\n  le_trans (mod_cast le_top) hN\n\n"}
{"name":"ENat.natCast_lt_of_coe_top_le_withTop","module":"Mathlib.Data.ENat.Basic","initialProofState":"N : WithTop ENat\nhN : LE.le (↑Top.top) N\nn : Nat\n⊢ LT.lt (↑n) N","decl":"lemma natCast_lt_of_coe_top_le_withTop {N : WithTop ℕ∞} (hN : (⊤ : ℕ∞) ≤ N) (n : ℕ) : n < N :=\n  lt_of_lt_of_le (mod_cast lt_add_one n) (natCast_le_of_coe_top_le_withTop hN (n + 1))\n\n"}
{"name":"ENat.map_top","module":"Mathlib.Data.ENat.Basic","initialProofState":"α : Type u_1\nf : Nat → α\n⊢ Eq (ENat.map f Top.top) Top.top","decl":"@[simp]\ntheorem map_top (f : ℕ → α) : map f ⊤ = ⊤ := rfl\n\n"}
{"name":"ENat.map_coe","module":"Mathlib.Data.ENat.Basic","initialProofState":"α : Type u_1\nf : Nat → α\na : Nat\n⊢ Eq (ENat.map f ↑a) ↑(f a)","decl":"@[simp]\ntheorem map_coe (f : ℕ → α) (a : ℕ) : map f a = f a := rfl\n\n"}
{"name":"ENat.map_zero","module":"Mathlib.Data.ENat.Basic","initialProofState":"α : Type u_1\nf : Nat → α\n⊢ Eq (ENat.map f 0) ↑(f 0)","decl":"@[simp]\ntheorem map_zero (f : ℕ → α) : map f 0 = f 0 := rfl\n\n"}
{"name":"ENat.map_one","module":"Mathlib.Data.ENat.Basic","initialProofState":"α : Type u_1\nf : Nat → α\n⊢ Eq (ENat.map f 1) ↑(f 1)","decl":"@[simp]\ntheorem map_one (f : ℕ → α) : map f 1 = f 1 := rfl\n\n"}
{"name":"ENat.map_ofNat","module":"Mathlib.Data.ENat.Basic","initialProofState":"α : Type u_1\nf : Nat → α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (ENat.map f (OfNat.ofNat n)) ↑(f n)","decl":"@[simp]\ntheorem map_ofNat (f : ℕ → α) (n : ℕ) [n.AtLeastTwo] : map f ofNat(n) = f n := rfl\n\n"}
{"name":"ENat.map_eq_top_iff","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : ENat\nα : Type u_1\nf : Nat → α\n⊢ Iff (Eq (ENat.map f n) Top.top) (Eq n Top.top)","decl":"@[simp]\nlemma map_eq_top_iff {f : ℕ → α} : map f n = ⊤ ↔ n = ⊤ := WithTop.map_eq_top_iff\n\n"}
{"name":"ENat.map_natCast_nonneg","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : ENat\nα : Type u_1\ninst✝³ : AddMonoidWithOne α\ninst✝² : PartialOrder α\ninst✝¹ : AddLeftMono α\ninst✝ : ZeroLEOneClass α\n⊢ LE.le 0 (ENat.map Nat.cast n)","decl":"@[simp]\ntheorem map_natCast_nonneg [AddMonoidWithOne α] [PartialOrder α]\n    [AddLeftMono α] [ZeroLEOneClass α] : 0 ≤ n.map (Nat.cast : ℕ → α) := by\n  cases n <;> simp\n\n"}
{"name":"ENat.strictMono_map_iff","module":"Mathlib.Data.ENat.Basic","initialProofState":"α : Type u_1\nf : Nat → α\ninst✝ : Preorder α\n⊢ Iff (StrictMono (ENat.map f)) (StrictMono f)","decl":"@[simp]\ntheorem strictMono_map_iff {f : ℕ → α} [Preorder α] : StrictMono (ENat.map f) ↔ StrictMono f :=\n  WithTop.strictMono_map_iff\n\n"}
{"name":"ENat.monotone_map_iff","module":"Mathlib.Data.ENat.Basic","initialProofState":"α : Type u_1\nf : Nat → α\ninst✝ : Preorder α\n⊢ Iff (Monotone (ENat.map f)) (Monotone f)","decl":"@[simp]\ntheorem monotone_map_iff {f : ℕ → α} [Preorder α] : Monotone (ENat.map f) ↔ Monotone f :=\n  WithTop.monotone_map_iff\n\n"}
{"name":"ENat.map_add","module":"Mathlib.Data.ENat.Basic","initialProofState":"β : Type u_2\nF : Type u_3\ninst✝² : Add β\ninst✝¹ : FunLike F Nat β\ninst✝ : AddHomClass F Nat β\nf : F\na b : ENat\n⊢ Eq (ENat.map (⇑f) (HAdd.hAdd a b)) (HAdd.hAdd (ENat.map (⇑f) a) (ENat.map (⇑f) b))","decl":"@[simp]\nprotected theorem map_add {β F} [Add β] [FunLike F ℕ β] [AddHomClass F ℕ β]\n    (f : F) (a b : ℕ∞) : (a + b).map f = a.map f + b.map f :=\n  WithTop.map_add f a b\n\n"}
{"name":"AddHom.ENatMap_apply","module":"Mathlib.Data.ENat.Basic","initialProofState":"N : Type u_2\ninst✝ : Add N\nf : AddHom Nat N\n⊢ Eq (⇑f.ENatMap) (ENat.map ⇑f)","decl":"/-- A version of `WithTop.map` for `AddHom`s. -/\n@[simps (config := .asFn)]\nprotected def _root_.AddHom.ENatMap {N : Type*} [Add N] (f : AddHom ℕ N) :\n    AddHom ℕ∞ (WithTop N) where\n  toFun := ENat.map f\n  map_add' := ENat.map_add f\n\n"}
{"name":"AddMonoidHom.ENatMap_apply","module":"Mathlib.Data.ENat.Basic","initialProofState":"N : Type u_2\ninst✝ : AddZeroClass N\nf : AddMonoidHom Nat N\n⊢ Eq (⇑f.ENatMap) (ENat.map ⇑f)","decl":"/-- A version of `WithTop.map` for `AddMonoidHom`s. -/\n@[simps (config := .asFn)]\nprotected def _root_.AddMonoidHom.ENatMap {N : Type*} [AddZeroClass N]\n    (f : ℕ →+ N) : ℕ∞ →+ WithTop N :=\n  { ZeroHom.ENatMap f.toZeroHom, AddHom.ENatMap f.toAddHom with toFun := ENat.map f }\n\n"}
{"name":"MonoidWithZeroHom.ENatMap_apply","module":"Mathlib.Data.ENat.Basic","initialProofState":"S : Type u_2\ninst✝² : MulZeroOneClass S\ninst✝¹ : DecidableEq S\ninst✝ : Nontrivial S\nf : MonoidWithZeroHom Nat S\nhf : Function.Injective ⇑f\n⊢ Eq (⇑(f.ENatMap hf)) (ENat.map ⇑f)","decl":"/-- A version of `ENat.map` for `MonoidWithZeroHom`s. -/\n@[simps (config := .asFn)]\nprotected def _root_.MonoidWithZeroHom.ENatMap {S : Type*} [MulZeroOneClass S] [DecidableEq S]\n    [Nontrivial S] (f : ℕ →*₀ S)\n    (hf : Function.Injective f) : ℕ∞ →*₀ WithTop S :=\n  { f.toZeroHom.ENatMap, f.toMonoidHom.toOneHom.ENatMap with\n    toFun := ENat.map f\n    map_mul' := fun x y => by\n      have : ∀ z, map f z = 0 ↔ z = 0 := fun z =>\n        (Option.map_injective hf).eq_iff' f.toZeroHom.ENatMap.map_zero\n      rcases Decidable.eq_or_ne x 0 with (rfl | hx)\n      · simp\n      rcases Decidable.eq_or_ne y 0 with (rfl | hy)\n      · simp\n      induction' x with x\n      · simp [hy, this]\n      induction' y with y\n      · have : (f x : WithTop S) ≠ 0 := by simpa [hf.eq_iff' (_root_.map_zero f)] using hx\n        simp [mul_top hx, WithTop.mul_top this]\n      · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: `simp [← coe_mul]` times out\n        simp only [map_coe, ← coe_mul, map_mul, WithTop.coe_mul] }\n\n"}
{"name":"RingHom.ENatMap_apply","module":"Mathlib.Data.ENat.Basic","initialProofState":"S : Type u_2\ninst✝³ : OrderedCommSemiring S\ninst✝² : CanonicallyOrderedAdd S\ninst✝¹ : DecidableEq S\ninst✝ : Nontrivial S\nf : RingHom Nat S\nhf : Function.Injective ⇑f\n⊢ Eq (⇑(f.ENatMap hf)) (↑(f.toMonoidWithZeroHom.ENatMap hf)).toFun","decl":"/-- A version of `ENat.map` for `RingHom`s. -/\n@[simps (config := .asFn)]\nprotected def _root_.RingHom.ENatMap {S : Type*} [OrderedCommSemiring S] [CanonicallyOrderedAdd S]\n    [DecidableEq S] [Nontrivial S] (f : ℕ →+* S) (hf : Function.Injective f) : ℕ∞ →+* WithTop S :=\n  {MonoidWithZeroHom.ENatMap f.toMonoidWithZeroHom hf, f.toAddMonoidHom.ENatMap with}\n\n"}
{"name":"WithBot.lt_add_one_iff","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : WithBot ENat\nm : Nat\n⊢ Iff (LT.lt n (HAdd.hAdd (↑m) 1)) (LE.le n ↑m)","decl":"lemma WithBot.lt_add_one_iff {n : WithBot ℕ∞} {m : ℕ} : n < m + 1 ↔ n ≤ m := by\n  rw [← WithBot.coe_one, ← ENat.coe_one, WithBot.coe_natCast, ← Nat.cast_add, ← WithBot.coe_natCast]\n  cases n\n  · simp only [bot_le, iff_true, WithBot.bot_lt_coe]\n  · rw [WithBot.coe_lt_coe, Nat.cast_add, ENat.coe_one, ENat.lt_add_one_iff (ENat.coe_ne_top _),\n      ← WithBot.coe_le_coe, WithBot.coe_natCast]\n\n"}
{"name":"WithBot.add_one_le_iff","module":"Mathlib.Data.ENat.Basic","initialProofState":"n : Nat\nm : WithBot ENat\n⊢ Iff (LE.le (HAdd.hAdd (↑n) 1) m) (LT.lt (↑n) m)","decl":"lemma WithBot.add_one_le_iff {n : ℕ} {m : WithBot ℕ∞} : n + 1 ≤ m ↔ n < m := by\n  rw [← WithBot.coe_one, ← ENat.coe_one, WithBot.coe_natCast, ← Nat.cast_add, ← WithBot.coe_natCast]\n  cases m\n  · simp\n  · rw [WithBot.coe_le_coe, ENat.coe_add, ENat.coe_one, ENat.add_one_le_iff (ENat.coe_ne_top n),\n      ← WithBot.coe_lt_coe, WithBot.coe_natCast]\n"}
