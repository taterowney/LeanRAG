{"name":"cauchySeq_finset_iff_vanishing_norm","module":"Mathlib.Analysis.Normed.Group.InfiniteSum","initialProofState":"Î¹ : Type u_1\nE : Type u_3\ninstâœ : SeminormedAddCommGroup E\nf : Î¹ â†’ E\nâŠ¢ Iff (CauchySeq fun s => s.sum fun i => f i) (âˆ€ (Îµ : Real), GT.gt Îµ 0 â†’ Exists fun s => âˆ€ (t : Finset Î¹), Disjoint t s â†’ LT.lt (Norm.norm (t.sum fun i => f i)) Îµ)","decl":"theorem cauchySeq_finset_iff_vanishing_norm {f : Î¹ â†’ E} :\n    (CauchySeq fun s : Finset Î¹ => âˆ‘ i âˆˆ s, f i) â†”\n      âˆ€ Îµ > (0 : â„), âˆƒ s : Finset Î¹, âˆ€ t, Disjoint t s â†’ â€–âˆ‘ i âˆˆ t, f iâ€– < Îµ := by\n  rw [cauchySeq_finset_iff_sum_vanishing, nhds_basis_ball.forall_iff]\n  Â· simp only [ball_zero_eq, Set.mem_setOf_eq]\n  Â· rintro s t hst âŸ¨s', hs'âŸ©\n    exact âŸ¨s', fun t' ht' => hst <| hs' _ ht'âŸ©\n\n"}
{"name":"summable_iff_vanishing_norm","module":"Mathlib.Analysis.Normed.Group.InfiniteSum","initialProofState":"Î¹ : Type u_1\nE : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : CompleteSpace E\nf : Î¹ â†’ E\nâŠ¢ Iff (Summable f) (âˆ€ (Îµ : Real), GT.gt Îµ 0 â†’ Exists fun s => âˆ€ (t : Finset Î¹), Disjoint t s â†’ LT.lt (Norm.norm (t.sum fun i => f i)) Îµ)","decl":"theorem summable_iff_vanishing_norm [CompleteSpace E] {f : Î¹ â†’ E} :\n    Summable f â†” âˆ€ Îµ > (0 : â„), âˆƒ s : Finset Î¹, âˆ€ t, Disjoint t s â†’ â€–âˆ‘ i âˆˆ t, f iâ€– < Îµ := by\n  rw [summable_iff_cauchySeq_finset, cauchySeq_finset_iff_vanishing_norm]\n\n"}
{"name":"cauchySeq_finset_of_norm_bounded_eventually","module":"Mathlib.Analysis.Normed.Group.InfiniteSum","initialProofState":"Î¹ : Type u_1\nE : Type u_3\ninstâœ : SeminormedAddCommGroup E\nf : Î¹ â†’ E\ng : Î¹ â†’ Real\nhg : Summable g\nh : Filter.Eventually (fun i => LE.le (Norm.norm (f i)) (g i)) Filter.cofinite\nâŠ¢ CauchySeq fun s => s.sum fun i => f i","decl":"theorem cauchySeq_finset_of_norm_bounded_eventually {f : Î¹ â†’ E} {g : Î¹ â†’ â„} (hg : Summable g)\n    (h : âˆ€á¶  i in cofinite, â€–f iâ€– â‰¤ g i) : CauchySeq fun s => âˆ‘ i âˆˆ s, f i := by\n  refine cauchySeq_finset_iff_vanishing_norm.2 fun Îµ hÎµ => ?_\n  rcases summable_iff_vanishing_norm.1 hg Îµ hÎµ with âŸ¨s, hsâŸ©\n  classical\n  refine âŸ¨s âˆª h.toFinset, fun t ht => ?_âŸ©\n  have : âˆ€ i âˆˆ t, â€–f iâ€– â‰¤ g i := by\n    intro i hi\n    simp only [disjoint_left, mem_union, not_or, h.mem_toFinset, Set.mem_compl_iff,\n      Classical.not_not] at ht\n    exact (ht hi).2\n  calc\n    â€–âˆ‘ i âˆˆ t, f iâ€– â‰¤ âˆ‘ i âˆˆ t, g i := norm_sum_le_of_le _ this\n    _ â‰¤ â€–âˆ‘ i âˆˆ t, g iâ€– := le_abs_self _\n    _ < Îµ := hs _ (ht.mono_right le_sup_left)\n\n"}
{"name":"cauchySeq_finset_of_norm_bounded","module":"Mathlib.Analysis.Normed.Group.InfiniteSum","initialProofState":"Î¹ : Type u_1\nE : Type u_3\ninstâœ : SeminormedAddCommGroup E\nf : Î¹ â†’ E\ng : Î¹ â†’ Real\nhg : Summable g\nh : âˆ€ (i : Î¹), LE.le (Norm.norm (f i)) (g i)\nâŠ¢ CauchySeq fun s => s.sum fun i => f i","decl":"theorem cauchySeq_finset_of_norm_bounded {f : Î¹ â†’ E} (g : Î¹ â†’ â„) (hg : Summable g)\n    (h : âˆ€ i, â€–f iâ€– â‰¤ g i) : CauchySeq fun s : Finset Î¹ => âˆ‘ i âˆˆ s, f i :=\n  cauchySeq_finset_of_norm_bounded_eventually hg <| Eventually.of_forall h\n\n"}
{"name":"cauchySeq_range_of_norm_bounded","module":"Mathlib.Analysis.Normed.Group.InfiniteSum","initialProofState":"E : Type u_3\ninstâœ : SeminormedAddCommGroup E\nf : Nat â†’ E\ng : Nat â†’ Real\nhg : CauchySeq fun n => (Finset.range n).sum fun i => g i\nhf : âˆ€ (i : Nat), LE.le (Norm.norm (f i)) (g i)\nâŠ¢ CauchySeq fun n => (Finset.range n).sum fun i => f i","decl":"/-- A version of the **direct comparison test** for conditionally convergent series.\nSee `cauchySeq_finset_of_norm_bounded` for the same statement about absolutely convergent ones. -/\ntheorem cauchySeq_range_of_norm_bounded {f : â„• â†’ E} (g : â„• â†’ â„)\n    (hg : CauchySeq fun n => âˆ‘ i âˆˆ range n, g i) (hf : âˆ€ i, â€–f iâ€– â‰¤ g i) :\n    CauchySeq fun n => âˆ‘ i âˆˆ range n, f i := by\n  refine Metric.cauchySeq_iff'.2 fun Îµ hÎµ => ?_\n  refine (Metric.cauchySeq_iff'.1 hg Îµ hÎµ).imp fun N hg n hn => ?_\n  specialize hg n hn\n  rw [dist_eq_norm, â† sum_Ico_eq_sub _ hn] at hg âŠ¢\n  calc\n    â€–âˆ‘ k âˆˆ Ico N n, f kâ€– â‰¤ âˆ‘ k âˆˆ _, â€–f kâ€– := norm_sum_le _ _\n    _ â‰¤ âˆ‘ k âˆˆ _, g k := sum_le_sum fun x _ => hf x\n    _ â‰¤ â€–âˆ‘ k âˆˆ _, g kâ€– := le_abs_self _\n    _ < Îµ := hg\n\n"}
{"name":"cauchySeq_finset_of_summable_norm","module":"Mathlib.Analysis.Normed.Group.InfiniteSum","initialProofState":"Î¹ : Type u_1\nE : Type u_3\ninstâœ : SeminormedAddCommGroup E\nf : Î¹ â†’ E\nhf : Summable fun a => Norm.norm (f a)\nâŠ¢ CauchySeq fun s => s.sum fun a => f a","decl":"theorem cauchySeq_finset_of_summable_norm {f : Î¹ â†’ E} (hf : Summable fun a => â€–f aâ€–) :\n    CauchySeq fun s : Finset Î¹ => âˆ‘ a âˆˆ s, f a :=\n  cauchySeq_finset_of_norm_bounded _ hf fun _i => le_rfl\n\n"}
{"name":"hasSum_of_subseq_of_summable","module":"Mathlib.Analysis.Normed.Group.InfiniteSum","initialProofState":"Î¹ : Type u_1\nÎ± : Type u_2\nE : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup E\nf : Î¹ â†’ E\nhf : Summable fun a => Norm.norm (f a)\ns : Î± â†’ Finset Î¹\np : Filter Î±\ninstâœ : p.NeBot\nhs : Filter.Tendsto s p Filter.atTop\na : E\nha : Filter.Tendsto (fun b => (s b).sum fun i => f i) p (nhds a)\nâŠ¢ HasSum f a","decl":"/-- If a function `f` is summable in norm, and along some sequence of finsets exhausting the space\nits sum is converging to a limit `a`, then this holds along all finsets, i.e., `f` is summable\nwith sum `a`. -/\ntheorem hasSum_of_subseq_of_summable {f : Î¹ â†’ E} (hf : Summable fun a => â€–f aâ€–) {s : Î± â†’ Finset Î¹}\n    {p : Filter Î±} [NeBot p] (hs : Tendsto s p atTop) {a : E}\n    (ha : Tendsto (fun b => âˆ‘ i âˆˆ s b, f i) p (ğ“ a)) : HasSum f a :=\n  tendsto_nhds_of_cauchySeq_of_subseq (cauchySeq_finset_of_summable_norm hf) hs ha\n\n"}
{"name":"hasSum_iff_tendsto_nat_of_summable_norm","module":"Mathlib.Analysis.Normed.Group.InfiniteSum","initialProofState":"E : Type u_3\ninstâœ : SeminormedAddCommGroup E\nf : Nat â†’ E\na : E\nhf : Summable fun i => Norm.norm (f i)\nâŠ¢ Iff (HasSum f a) (Filter.Tendsto (fun n => (Finset.range n).sum fun i => f i) Filter.atTop (nhds a))","decl":"theorem hasSum_iff_tendsto_nat_of_summable_norm {f : â„• â†’ E} {a : E} (hf : Summable fun i => â€–f iâ€–) :\n    HasSum f a â†” Tendsto (fun n : â„• => âˆ‘ i âˆˆ range n, f i) atTop (ğ“ a) :=\n  âŸ¨fun h => h.tendsto_sum_nat, fun h => hasSum_of_subseq_of_summable hf tendsto_finset_range hâŸ©\n\n"}
{"name":"Summable.of_norm_bounded","module":"Mathlib.Analysis.Normed.Group.InfiniteSum","initialProofState":"Î¹ : Type u_1\nE : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : CompleteSpace E\nf : Î¹ â†’ E\ng : Î¹ â†’ Real\nhg : Summable g\nh : âˆ€ (i : Î¹), LE.le (Norm.norm (f i)) (g i)\nâŠ¢ Summable f","decl":"/-- The direct comparison test for series:  if the norm of `f` is bounded by a real function `g`\nwhich is summable, then `f` is summable. -/\ntheorem Summable.of_norm_bounded [CompleteSpace E] {f : Î¹ â†’ E} (g : Î¹ â†’ â„) (hg : Summable g)\n    (h : âˆ€ i, â€–f iâ€– â‰¤ g i) : Summable f := by\n  rw [summable_iff_cauchySeq_finset]\n  exact cauchySeq_finset_of_norm_bounded g hg h\n\n"}
{"name":"HasSum.norm_le_of_bounded","module":"Mathlib.Analysis.Normed.Group.InfiniteSum","initialProofState":"Î¹ : Type u_1\nE : Type u_3\ninstâœ : SeminormedAddCommGroup E\nf : Î¹ â†’ E\ng : Î¹ â†’ Real\na : E\nb : Real\nhf : HasSum f a\nhg : HasSum g b\nh : âˆ€ (i : Î¹), LE.le (Norm.norm (f i)) (g i)\nâŠ¢ LE.le (Norm.norm a) b","decl":"theorem HasSum.norm_le_of_bounded {f : Î¹ â†’ E} {g : Î¹ â†’ â„} {a : E} {b : â„} (hf : HasSum f a)\n    (hg : HasSum g b) (h : âˆ€ i, â€–f iâ€– â‰¤ g i) : â€–aâ€– â‰¤ b := by\n  classical exact le_of_tendsto_of_tendsto' hf.norm hg fun _s â†¦ norm_sum_le_of_le _ fun i _hi â†¦ h i\n\n"}
{"name":"tsum_of_norm_bounded","module":"Mathlib.Analysis.Normed.Group.InfiniteSum","initialProofState":"Î¹ : Type u_1\nE : Type u_3\ninstâœ : SeminormedAddCommGroup E\nf : Î¹ â†’ E\ng : Î¹ â†’ Real\na : Real\nhg : HasSum g a\nh : âˆ€ (i : Î¹), LE.le (Norm.norm (f i)) (g i)\nâŠ¢ LE.le (Norm.norm (tsum fun i => f i)) a","decl":"/-- Quantitative result associated to the direct comparison test for series:  If `âˆ‘' i, g i` is\nsummable, and for all `i`, `â€–f iâ€– â‰¤ g i`, then `â€–âˆ‘' i, f iâ€– â‰¤ âˆ‘' i, g i`. Note that we do not\nassume that `âˆ‘' i, f i` is summable, and it might not be the case if `Î±` is not a complete space. -/\ntheorem tsum_of_norm_bounded {f : Î¹ â†’ E} {g : Î¹ â†’ â„} {a : â„} (hg : HasSum g a)\n    (h : âˆ€ i, â€–f iâ€– â‰¤ g i) : â€–âˆ‘' i : Î¹, f iâ€– â‰¤ a := by\n  by_cases hf : Summable f\n  Â· exact hf.hasSum.norm_le_of_bounded hg h\n  Â· rw [tsum_eq_zero_of_not_summable hf, norm_zero]\n    classical exact ge_of_tendsto' hg fun s => sum_nonneg fun i _hi => (norm_nonneg _).trans (h i)\n\n"}
{"name":"norm_tsum_le_tsum_norm","module":"Mathlib.Analysis.Normed.Group.InfiniteSum","initialProofState":"Î¹ : Type u_1\nE : Type u_3\ninstâœ : SeminormedAddCommGroup E\nf : Î¹ â†’ E\nhf : Summable fun i => Norm.norm (f i)\nâŠ¢ LE.le (Norm.norm (tsum fun i => f i)) (tsum fun i => Norm.norm (f i))","decl":"/-- If `âˆ‘' i, â€–f iâ€–` is summable, then `â€–âˆ‘' i, f iâ€– â‰¤ (âˆ‘' i, â€–f iâ€–)`. Note that we do not assume\nthat `âˆ‘' i, f i` is summable, and it might not be the case if `Î±` is not a complete space. -/\ntheorem norm_tsum_le_tsum_norm {f : Î¹ â†’ E} (hf : Summable fun i => â€–f iâ€–) :\n    â€–âˆ‘' i, f iâ€– â‰¤ âˆ‘' i, â€–f iâ€– :=\n  tsum_of_norm_bounded hf.hasSum fun _i => le_rfl\n\n"}
{"name":"tsum_of_nnnorm_bounded","module":"Mathlib.Analysis.Normed.Group.InfiniteSum","initialProofState":"Î¹ : Type u_1\nE : Type u_3\ninstâœ : SeminormedAddCommGroup E\nf : Î¹ â†’ E\ng : Î¹ â†’ NNReal\na : NNReal\nhg : HasSum g a\nh : âˆ€ (i : Î¹), LE.le (NNNorm.nnnorm (f i)) (g i)\nâŠ¢ LE.le (NNNorm.nnnorm (tsum fun i => f i)) a","decl":"/-- Quantitative result associated to the direct comparison test for series: If `âˆ‘' i, g i` is\nsummable, and for all `i`, `â€–f iâ€–â‚Š â‰¤ g i`, then `â€–âˆ‘' i, f iâ€–â‚Š â‰¤ âˆ‘' i, g i`. Note that we\ndo not assume that `âˆ‘' i, f i` is summable, and it might not be the case if `Î±` is not a complete\nspace. -/\ntheorem tsum_of_nnnorm_bounded {f : Î¹ â†’ E} {g : Î¹ â†’ â„â‰¥0} {a : â„â‰¥0} (hg : HasSum g a)\n    (h : âˆ€ i, â€–f iâ€–â‚Š â‰¤ g i) : â€–âˆ‘' i : Î¹, f iâ€–â‚Š â‰¤ a := by\n  simp only [â† NNReal.coe_le_coe, â† NNReal.hasSum_coe, coe_nnnorm] at *\n  exact tsum_of_norm_bounded hg h\n\n"}
{"name":"nnnorm_tsum_le","module":"Mathlib.Analysis.Normed.Group.InfiniteSum","initialProofState":"Î¹ : Type u_1\nE : Type u_3\ninstâœ : SeminormedAddCommGroup E\nf : Î¹ â†’ E\nhf : Summable fun i => NNNorm.nnnorm (f i)\nâŠ¢ LE.le (NNNorm.nnnorm (tsum fun i => f i)) (tsum fun i => NNNorm.nnnorm (f i))","decl":"/-- If `âˆ‘' i, â€–f iâ€–â‚Š` is summable, then `â€–âˆ‘' i, f iâ€–â‚Š â‰¤ âˆ‘' i, â€–f iâ€–â‚Š`. Note that\nwe do not assume that `âˆ‘' i, f i` is summable, and it might not be the case if `Î±` is not a complete\nspace. -/\ntheorem nnnorm_tsum_le {f : Î¹ â†’ E} (hf : Summable fun i => â€–f iâ€–â‚Š) : â€–âˆ‘' i, f iâ€–â‚Š â‰¤ âˆ‘' i, â€–f iâ€–â‚Š :=\n  tsum_of_nnnorm_bounded hf.hasSum fun _i => le_rfl\n\n"}
{"name":"Summable.of_norm_bounded_eventually","module":"Mathlib.Analysis.Normed.Group.InfiniteSum","initialProofState":"Î¹ : Type u_1\nE : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : CompleteSpace E\nf : Î¹ â†’ E\ng : Î¹ â†’ Real\nhg : Summable g\nh : Filter.Eventually (fun i => LE.le (Norm.norm (f i)) (g i)) Filter.cofinite\nâŠ¢ Summable f","decl":"/-- Variant of the direct comparison test for series:  if the norm of `f` is eventually bounded by a\nreal function `g` which is summable, then `f` is summable. -/\ntheorem Summable.of_norm_bounded_eventually {f : Î¹ â†’ E} (g : Î¹ â†’ â„) (hg : Summable g)\n    (h : âˆ€á¶  i in cofinite, â€–f iâ€– â‰¤ g i) : Summable f :=\n  summable_iff_cauchySeq_finset.2 <| cauchySeq_finset_of_norm_bounded_eventually hg h\n\n"}
{"name":"Summable.of_norm_bounded_eventually_nat","module":"Mathlib.Analysis.Normed.Group.InfiniteSum","initialProofState":"E : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : CompleteSpace E\nf : Nat â†’ E\ng : Nat â†’ Real\nhg : Summable g\nh : Filter.Eventually (fun i => LE.le (Norm.norm (f i)) (g i)) Filter.atTop\nâŠ¢ Summable f","decl":"/-- Variant of the direct comparison test for series:  if the norm of `f` is eventually bounded by a\nreal function `g` which is summable, then `f` is summable. -/\ntheorem Summable.of_norm_bounded_eventually_nat {f : â„• â†’ E} (g : â„• â†’ â„) (hg : Summable g)\n    (h : âˆ€á¶  i in atTop, â€–f iâ€– â‰¤ g i) : Summable f :=\n  .of_norm_bounded_eventually g hg <| Nat.cofinite_eq_atTop â–¸ h\n\n"}
{"name":"Summable.of_nnnorm_bounded","module":"Mathlib.Analysis.Normed.Group.InfiniteSum","initialProofState":"Î¹ : Type u_1\nE : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : CompleteSpace E\nf : Î¹ â†’ E\ng : Î¹ â†’ NNReal\nhg : Summable g\nh : âˆ€ (i : Î¹), LE.le (NNNorm.nnnorm (f i)) (g i)\nâŠ¢ Summable f","decl":"theorem Summable.of_nnnorm_bounded {f : Î¹ â†’ E} (g : Î¹ â†’ â„â‰¥0) (hg : Summable g)\n    (h : âˆ€ i, â€–f iâ€–â‚Š â‰¤ g i) : Summable f :=\n  .of_norm_bounded (fun i => (g i : â„)) (NNReal.summable_coe.2 hg) h\n\n"}
{"name":"Summable.of_norm","module":"Mathlib.Analysis.Normed.Group.InfiniteSum","initialProofState":"Î¹ : Type u_1\nE : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : CompleteSpace E\nf : Î¹ â†’ E\nhf : Summable fun a => Norm.norm (f a)\nâŠ¢ Summable f","decl":"theorem Summable.of_norm {f : Î¹ â†’ E} (hf : Summable fun a => â€–f aâ€–) : Summable f :=\n  .of_norm_bounded _ hf fun _i => le_rfl\n\n"}
{"name":"Summable.of_nnnorm","module":"Mathlib.Analysis.Normed.Group.InfiniteSum","initialProofState":"Î¹ : Type u_1\nE : Type u_3\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : CompleteSpace E\nf : Î¹ â†’ E\nhf : Summable fun a => NNNorm.nnnorm (f a)\nâŠ¢ Summable f","decl":"theorem Summable.of_nnnorm {f : Î¹ â†’ E} (hf : Summable fun a => â€–f aâ€–â‚Š) : Summable f :=\n  .of_nnnorm_bounded _ hf fun _i => le_rfl\n"}
