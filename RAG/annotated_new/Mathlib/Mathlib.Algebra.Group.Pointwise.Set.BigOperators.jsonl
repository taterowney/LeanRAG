{"name":"Set.image_list_sum","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"α : Type u_2\nβ : Type u_3\nF : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : AddMonoid α\ninst✝¹ : AddMonoid β\ninst✝ : AddMonoidHomClass F α β\nf : F\nl : List (Set α)\n⊢ Eq (Set.image (⇑f) l.sum) (List.map (fun s => Set.image (⇑f) s) l).sum","decl":"@[to_additive]\ntheorem image_list_prod (f : F) :\n    ∀ l : List (Set α), (f : α → β) '' l.prod = (l.map fun s => f '' s).prod\n  | [] => image_one.trans <| congr_arg singleton (map_one f)\n  | a :: as => by rw [List.map_cons, List.prod_cons, List.prod_cons, image_mul, image_list_prod _ _]\n\n"}
{"name":"Set.image_list_prod","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"α : Type u_2\nβ : Type u_3\nF : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : Monoid α\ninst✝¹ : Monoid β\ninst✝ : MonoidHomClass F α β\nf : F\nl : List (Set α)\n⊢ Eq (Set.image (⇑f) l.prod) (List.map (fun s => Set.image (⇑f) s) l).prod","decl":"@[to_additive]\ntheorem image_list_prod (f : F) :\n    ∀ l : List (Set α), (f : α → β) '' l.prod = (l.map fun s => f '' s).prod\n  | [] => image_one.trans <| congr_arg singleton (map_one f)\n  | a :: as => by rw [List.map_cons, List.prod_cons, List.prod_cons, image_mul, image_list_prod _ _]\n\n"}
{"name":"Set.image_multiset_sum","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"α : Type u_2\nβ : Type u_3\nF : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : AddCommMonoid α\ninst✝¹ : AddCommMonoid β\ninst✝ : AddMonoidHomClass F α β\nf : F\nm : Multiset (Set α)\n⊢ Eq (Set.image (⇑f) m.sum) (Multiset.map (fun s => Set.image (⇑f) s) m).sum","decl":"@[to_additive]\ntheorem image_multiset_prod (f : F) :\n    ∀ m : Multiset (Set α), (f : α → β) '' m.prod = (m.map fun s => f '' s).prod :=\n  Quotient.ind <| by\n    simpa only [Multiset.quot_mk_to_coe, Multiset.prod_coe, Multiset.map_coe] using\n      image_list_prod f\n\n"}
{"name":"Set.image_multiset_prod","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"α : Type u_2\nβ : Type u_3\nF : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : CommMonoid α\ninst✝¹ : CommMonoid β\ninst✝ : MonoidHomClass F α β\nf : F\nm : Multiset (Set α)\n⊢ Eq (Set.image (⇑f) m.prod) (Multiset.map (fun s => Set.image (⇑f) s) m).prod","decl":"@[to_additive]\ntheorem image_multiset_prod (f : F) :\n    ∀ m : Multiset (Set α), (f : α → β) '' m.prod = (m.map fun s => f '' s).prod :=\n  Quotient.ind <| by\n    simpa only [Multiset.quot_mk_to_coe, Multiset.prod_coe, Multiset.map_coe] using\n      image_list_prod f\n\n"}
{"name":"Set.image_finset_prod","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\nF : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : CommMonoid α\ninst✝¹ : CommMonoid β\ninst✝ : MonoidHomClass F α β\nf : F\nm : Finset ι\ns : ι → Set α\n⊢ Eq (Set.image (⇑f) (m.prod fun i => s i)) (m.prod fun i => Set.image (⇑f) (s i))","decl":"@[to_additive]\ntheorem image_finset_prod (f : F) (m : Finset ι) (s : ι → Set α) :\n    ((f : α → β) '' ∏ i ∈ m, s i) = ∏ i ∈ m, f '' s i :=\n  (image_multiset_prod f _).trans <| congr_arg Multiset.prod <| Multiset.map_map _ _ _\n\n"}
{"name":"Set.image_finset_sum","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\nβ : Type u_3\nF : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : AddCommMonoid α\ninst✝¹ : AddCommMonoid β\ninst✝ : AddMonoidHomClass F α β\nf : F\nm : Finset ι\ns : ι → Set α\n⊢ Eq (Set.image (⇑f) (m.sum fun i => s i)) (m.sum fun i => Set.image (⇑f) (s i))","decl":"@[to_additive]\ntheorem image_finset_prod (f : F) (m : Finset ι) (s : ι → Set α) :\n    ((f : α → β) '' ∏ i ∈ m, s i) = ∏ i ∈ m, f '' s i :=\n  (image_multiset_prod f _).trans <| congr_arg Multiset.prod <| Multiset.map_map _ _ _\n\n"}
{"name":"Set.mem_finset_sum","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : AddCommMonoid α\nt : Finset ι\nf : ι → Set α\na : α\n⊢ Iff (Membership.mem (t.sum fun i => f i) a) (Exists fun g => Exists fun x => Eq (t.sum fun i => g i) a)","decl":"/-- The n-ary version of `Set.mem_mul`. -/\n@[to_additive \" The n-ary version of `Set.mem_add`. \"]\ntheorem mem_finset_prod (t : Finset ι) (f : ι → Set α) (a : α) :\n    (a ∈ ∏ i ∈ t, f i) ↔ ∃ (g : ι → α) (_ : ∀ {i}, i ∈ t → g i ∈ f i), ∏ i ∈ t, g i = a := by\n  classical\n    induction' t using Finset.induction_on with i is hi ih generalizing a\n    · simp_rw [Finset.prod_empty, Set.mem_one]\n      exact ⟨fun h ↦ ⟨fun _ ↦ a, fun hi ↦ False.elim (Finset.not_mem_empty _ hi), h.symm⟩,\n        fun ⟨_, _, hf⟩ ↦ hf.symm⟩\n    rw [Finset.prod_insert hi, Set.mem_mul]\n    simp_rw [Finset.prod_insert hi]\n    simp_rw [ih]\n    constructor\n    · rintro ⟨x, y, hx, ⟨g, hg, rfl⟩, rfl⟩\n      refine ⟨Function.update g i x, ?_, ?_⟩\n      · intro j hj\n        obtain rfl | hj := Finset.mem_insert.mp hj\n        · rwa [Function.update_self]\n        · rw [update_of_ne (ne_of_mem_of_not_mem hj hi)]\n          exact hg hj\n      · rw [Finset.prod_update_of_not_mem hi, Function.update_self]\n    · rintro ⟨g, hg, rfl⟩\n      exact ⟨g i, hg (is.mem_insert_self _), is.prod g,\n        ⟨⟨g, fun hi ↦ hg (Finset.mem_insert_of_mem hi), rfl⟩, rfl⟩⟩\n\n"}
{"name":"Set.mem_finset_prod","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : CommMonoid α\nt : Finset ι\nf : ι → Set α\na : α\n⊢ Iff (Membership.mem (t.prod fun i => f i) a) (Exists fun g => Exists fun x => Eq (t.prod fun i => g i) a)","decl":"/-- The n-ary version of `Set.mem_mul`. -/\n@[to_additive \" The n-ary version of `Set.mem_add`. \"]\ntheorem mem_finset_prod (t : Finset ι) (f : ι → Set α) (a : α) :\n    (a ∈ ∏ i ∈ t, f i) ↔ ∃ (g : ι → α) (_ : ∀ {i}, i ∈ t → g i ∈ f i), ∏ i ∈ t, g i = a := by\n  classical\n    induction' t using Finset.induction_on with i is hi ih generalizing a\n    · simp_rw [Finset.prod_empty, Set.mem_one]\n      exact ⟨fun h ↦ ⟨fun _ ↦ a, fun hi ↦ False.elim (Finset.not_mem_empty _ hi), h.symm⟩,\n        fun ⟨_, _, hf⟩ ↦ hf.symm⟩\n    rw [Finset.prod_insert hi, Set.mem_mul]\n    simp_rw [Finset.prod_insert hi]\n    simp_rw [ih]\n    constructor\n    · rintro ⟨x, y, hx, ⟨g, hg, rfl⟩, rfl⟩\n      refine ⟨Function.update g i x, ?_, ?_⟩\n      · intro j hj\n        obtain rfl | hj := Finset.mem_insert.mp hj\n        · rwa [Function.update_self]\n        · rw [update_of_ne (ne_of_mem_of_not_mem hj hi)]\n          exact hg hj\n      · rw [Finset.prod_update_of_not_mem hi, Function.update_self]\n    · rintro ⟨g, hg, rfl⟩\n      exact ⟨g i, hg (is.mem_insert_self _), is.prod g,\n        ⟨⟨g, fun hi ↦ hg (Finset.mem_insert_of_mem hi), rfl⟩, rfl⟩⟩\n\n"}
{"name":"Set.mem_pow_iff_prod","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"α : Type u_2\ninst✝ : CommMonoid α\nn : Nat\ns : Set α\na : α\n⊢ Iff (Membership.mem (HPow.hPow s n) a) (Exists fun f => And (∀ (i : Fin n), Membership.mem s (f i)) (Eq (Finset.univ.prod fun i => f i) a))","decl":"@[to_additive]\nlemma mem_pow_iff_prod {n : ℕ} {s : Set α} {a : α} :\n    a ∈ s ^ n ↔ ∃ f : Fin n → α, (∀ i, f i ∈ s) ∧ ∏ i, f i = a := by\n  simpa using mem_finset_prod (t := .univ) (f := fun _ : Fin n ↦ s) _\n\n"}
{"name":"Set.mem_nsmul_iff_sum","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"α : Type u_2\ninst✝ : AddCommMonoid α\nn : Nat\ns : Set α\na : α\n⊢ Iff (Membership.mem (HSMul.hSMul n s) a) (Exists fun f => And (∀ (i : Fin n), Membership.mem s (f i)) (Eq (Finset.univ.sum fun i => f i) a))","decl":"@[to_additive]\nlemma mem_pow_iff_prod {n : ℕ} {s : Set α} {a : α} :\n    a ∈ s ^ n ↔ ∃ f : Fin n → α, (∀ i, f i ∈ s) ∧ ∏ i, f i = a := by\n  simpa using mem_finset_prod (t := .univ) (f := fun _ : Fin n ↦ s) _\n\n"}
{"name":"Set.mem_fintype_sum","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : Fintype ι\nf : ι → Set α\na : α\n⊢ Iff (Membership.mem (Finset.univ.sum fun i => f i) a) (Exists fun g => Exists fun x => Eq (Finset.univ.sum fun i => g i) a)","decl":"/-- A version of `Set.mem_finset_prod` with a simpler RHS for products over a Fintype. -/\n@[to_additive \" A version of `Set.mem_finset_sum` with a simpler RHS for sums over a Fintype. \"]\ntheorem mem_fintype_prod [Fintype ι] (f : ι → Set α) (a : α) :\n    (a ∈ ∏ i, f i) ↔ ∃ (g : ι → α) (_ : ∀ i, g i ∈ f i), ∏ i, g i = a := by\n  rw [mem_finset_prod]\n  simp\n\n"}
{"name":"Set.mem_fintype_prod","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : Fintype ι\nf : ι → Set α\na : α\n⊢ Iff (Membership.mem (Finset.univ.prod fun i => f i) a) (Exists fun g => Exists fun x => Eq (Finset.univ.prod fun i => g i) a)","decl":"/-- A version of `Set.mem_finset_prod` with a simpler RHS for products over a Fintype. -/\n@[to_additive \" A version of `Set.mem_finset_sum` with a simpler RHS for sums over a Fintype. \"]\ntheorem mem_fintype_prod [Fintype ι] (f : ι → Set α) (a : α) :\n    (a ∈ ∏ i, f i) ↔ ∃ (g : ι → α) (_ : ∀ i, g i ∈ f i), ∏ i, g i = a := by\n  rw [mem_finset_prod]\n  simp\n\n"}
{"name":"Set.list_prod_mem_list_prod","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : CommMonoid α\nt : List ι\nf : ι → Set α\ng : ι → α\nhg : ∀ (i : ι), Membership.mem t i → Membership.mem (f i) (g i)\n⊢ Membership.mem (List.map f t).prod (List.map g t).prod","decl":"/-- An n-ary version of `Set.mul_mem_mul`. -/\n@[to_additive \" An n-ary version of `Set.add_mem_add`. \"]\ntheorem list_prod_mem_list_prod (t : List ι) (f : ι → Set α) (g : ι → α) (hg : ∀ i ∈ t, g i ∈ f i) :\n    (t.map g).prod ∈ (t.map f).prod := by\n  induction' t with h tl ih\n  · simp_rw [List.map_nil, List.prod_nil, Set.mem_one]\n  · simp_rw [List.map_cons, List.prod_cons]\n    exact mul_mem_mul (hg h <| List.mem_cons_self _ _)\n      (ih fun i hi ↦ hg i <| List.mem_cons_of_mem _ hi)\n\n"}
{"name":"Set.list_sum_mem_list_sum","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : AddCommMonoid α\nt : List ι\nf : ι → Set α\ng : ι → α\nhg : ∀ (i : ι), Membership.mem t i → Membership.mem (f i) (g i)\n⊢ Membership.mem (List.map f t).sum (List.map g t).sum","decl":"/-- An n-ary version of `Set.mul_mem_mul`. -/\n@[to_additive \" An n-ary version of `Set.add_mem_add`. \"]\ntheorem list_prod_mem_list_prod (t : List ι) (f : ι → Set α) (g : ι → α) (hg : ∀ i ∈ t, g i ∈ f i) :\n    (t.map g).prod ∈ (t.map f).prod := by\n  induction' t with h tl ih\n  · simp_rw [List.map_nil, List.prod_nil, Set.mem_one]\n  · simp_rw [List.map_cons, List.prod_cons]\n    exact mul_mem_mul (hg h <| List.mem_cons_self _ _)\n      (ih fun i hi ↦ hg i <| List.mem_cons_of_mem _ hi)\n\n"}
{"name":"Set.list_prod_subset_list_prod","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : CommMonoid α\nt : List ι\nf₁ f₂ : ι → Set α\nhf : ∀ (i : ι), Membership.mem t i → HasSubset.Subset (f₁ i) (f₂ i)\n⊢ HasSubset.Subset (List.map f₁ t).prod (List.map f₂ t).prod","decl":"/-- An n-ary version of `Set.mul_subset_mul`. -/\n@[to_additive \" An n-ary version of `Set.add_subset_add`. \"]\ntheorem list_prod_subset_list_prod (t : List ι) (f₁ f₂ : ι → Set α) (hf : ∀ i ∈ t, f₁ i ⊆ f₂ i) :\n    (t.map f₁).prod ⊆ (t.map f₂).prod := by\n  induction' t with h tl ih\n  · rfl\n  · simp_rw [List.map_cons, List.prod_cons]\n    exact mul_subset_mul (hf h <| List.mem_cons_self _ _)\n      (ih fun i hi ↦ hf i <| List.mem_cons_of_mem _ hi)\n\n"}
{"name":"Set.list_sum_subset_list_sum","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : AddCommMonoid α\nt : List ι\nf₁ f₂ : ι → Set α\nhf : ∀ (i : ι), Membership.mem t i → HasSubset.Subset (f₁ i) (f₂ i)\n⊢ HasSubset.Subset (List.map f₁ t).sum (List.map f₂ t).sum","decl":"/-- An n-ary version of `Set.mul_subset_mul`. -/\n@[to_additive \" An n-ary version of `Set.add_subset_add`. \"]\ntheorem list_prod_subset_list_prod (t : List ι) (f₁ f₂ : ι → Set α) (hf : ∀ i ∈ t, f₁ i ⊆ f₂ i) :\n    (t.map f₁).prod ⊆ (t.map f₂).prod := by\n  induction' t with h tl ih\n  · rfl\n  · simp_rw [List.map_cons, List.prod_cons]\n    exact mul_subset_mul (hf h <| List.mem_cons_self _ _)\n      (ih fun i hi ↦ hf i <| List.mem_cons_of_mem _ hi)\n\n"}
{"name":"Set.list_prod_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"M : Type u_5\ninst✝ : CommMonoid M\ns : List M\n⊢ Eq (List.map (fun i => Singleton.singleton i) s).prod (Singleton.singleton s.prod)","decl":"@[to_additive]\ntheorem list_prod_singleton {M : Type*} [CommMonoid M] (s : List M) :\n    (s.map fun i ↦ ({i} : Set M)).prod = {s.prod} :=\n  (map_list_prod (singletonMonoidHom : M →* Set M) _).symm\n\n"}
{"name":"Set.list_sum_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"M : Type u_5\ninst✝ : AddCommMonoid M\ns : List M\n⊢ Eq (List.map (fun i => Singleton.singleton i) s).sum (Singleton.singleton s.sum)","decl":"@[to_additive]\ntheorem list_prod_singleton {M : Type*} [CommMonoid M] (s : List M) :\n    (s.map fun i ↦ ({i} : Set M)).prod = {s.prod} :=\n  (map_list_prod (singletonMonoidHom : M →* Set M) _).symm\n\n"}
{"name":"Set.multiset_prod_mem_multiset_prod","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : CommMonoid α\nt : Multiset ι\nf : ι → Set α\ng : ι → α\nhg : ∀ (i : ι), Membership.mem t i → Membership.mem (f i) (g i)\n⊢ Membership.mem (Multiset.map f t).prod (Multiset.map g t).prod","decl":"/-- An n-ary version of `Set.mul_mem_mul`. -/\n@[to_additive \" An n-ary version of `Set.add_mem_add`. \"]\ntheorem multiset_prod_mem_multiset_prod (t : Multiset ι) (f : ι → Set α) (g : ι → α)\n    (hg : ∀ i ∈ t, g i ∈ f i) : (t.map g).prod ∈ (t.map f).prod := by\n  induction t using Quotient.inductionOn\n  simp_rw [Multiset.quot_mk_to_coe, Multiset.map_coe, Multiset.prod_coe]\n  exact list_prod_mem_list_prod _ _ _ hg\n\n"}
{"name":"Set.multiset_sum_mem_multiset_sum","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : AddCommMonoid α\nt : Multiset ι\nf : ι → Set α\ng : ι → α\nhg : ∀ (i : ι), Membership.mem t i → Membership.mem (f i) (g i)\n⊢ Membership.mem (Multiset.map f t).sum (Multiset.map g t).sum","decl":"/-- An n-ary version of `Set.mul_mem_mul`. -/\n@[to_additive \" An n-ary version of `Set.add_mem_add`. \"]\ntheorem multiset_prod_mem_multiset_prod (t : Multiset ι) (f : ι → Set α) (g : ι → α)\n    (hg : ∀ i ∈ t, g i ∈ f i) : (t.map g).prod ∈ (t.map f).prod := by\n  induction t using Quotient.inductionOn\n  simp_rw [Multiset.quot_mk_to_coe, Multiset.map_coe, Multiset.prod_coe]\n  exact list_prod_mem_list_prod _ _ _ hg\n\n"}
{"name":"Set.multiset_sum_subset_multiset_sum","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : AddCommMonoid α\nt : Multiset ι\nf₁ f₂ : ι → Set α\nhf : ∀ (i : ι), Membership.mem t i → HasSubset.Subset (f₁ i) (f₂ i)\n⊢ HasSubset.Subset (Multiset.map f₁ t).sum (Multiset.map f₂ t).sum","decl":"/-- An n-ary version of `Set.mul_subset_mul`. -/\n@[to_additive \" An n-ary version of `Set.add_subset_add`. \"]\ntheorem multiset_prod_subset_multiset_prod (t : Multiset ι) (f₁ f₂ : ι → Set α)\n    (hf : ∀ i ∈ t, f₁ i ⊆ f₂ i) : (t.map f₁).prod ⊆ (t.map f₂).prod := by\n  induction t using Quotient.inductionOn\n  simp_rw [Multiset.quot_mk_to_coe, Multiset.map_coe, Multiset.prod_coe]\n  exact list_prod_subset_list_prod _ _ _ hf\n\n"}
{"name":"Set.multiset_prod_subset_multiset_prod","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : CommMonoid α\nt : Multiset ι\nf₁ f₂ : ι → Set α\nhf : ∀ (i : ι), Membership.mem t i → HasSubset.Subset (f₁ i) (f₂ i)\n⊢ HasSubset.Subset (Multiset.map f₁ t).prod (Multiset.map f₂ t).prod","decl":"/-- An n-ary version of `Set.mul_subset_mul`. -/\n@[to_additive \" An n-ary version of `Set.add_subset_add`. \"]\ntheorem multiset_prod_subset_multiset_prod (t : Multiset ι) (f₁ f₂ : ι → Set α)\n    (hf : ∀ i ∈ t, f₁ i ⊆ f₂ i) : (t.map f₁).prod ⊆ (t.map f₂).prod := by\n  induction t using Quotient.inductionOn\n  simp_rw [Multiset.quot_mk_to_coe, Multiset.map_coe, Multiset.prod_coe]\n  exact list_prod_subset_list_prod _ _ _ hf\n\n"}
{"name":"Set.multiset_prod_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"M : Type u_5\ninst✝ : CommMonoid M\ns : Multiset M\n⊢ Eq (Multiset.map (fun i => Singleton.singleton i) s).prod (Singleton.singleton s.prod)","decl":"@[to_additive]\ntheorem multiset_prod_singleton {M : Type*} [CommMonoid M] (s : Multiset M) :\n    (s.map fun i ↦ ({i} : Set M)).prod = {s.prod} :=\n  (map_multiset_prod (singletonMonoidHom : M →* Set M) _).symm\n\n"}
{"name":"Set.multiset_sum_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"M : Type u_5\ninst✝ : AddCommMonoid M\ns : Multiset M\n⊢ Eq (Multiset.map (fun i => Singleton.singleton i) s).sum (Singleton.singleton s.sum)","decl":"@[to_additive]\ntheorem multiset_prod_singleton {M : Type*} [CommMonoid M] (s : Multiset M) :\n    (s.map fun i ↦ ({i} : Set M)).prod = {s.prod} :=\n  (map_multiset_prod (singletonMonoidHom : M →* Set M) _).symm\n\n"}
{"name":"Set.finset_sum_mem_finset_sum","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : AddCommMonoid α\nt : Finset ι\nf : ι → Set α\ng : ι → α\nhg : ∀ (i : ι), Membership.mem t i → Membership.mem (f i) (g i)\n⊢ Membership.mem (t.sum fun i => f i) (t.sum fun i => g i)","decl":"/-- An n-ary version of `Set.mul_mem_mul`. -/\n@[to_additive \" An n-ary version of `Set.add_mem_add`. \"]\ntheorem finset_prod_mem_finset_prod (t : Finset ι) (f : ι → Set α) (g : ι → α)\n    (hg : ∀ i ∈ t, g i ∈ f i) : (∏ i ∈ t, g i) ∈ ∏ i ∈ t, f i :=\n  multiset_prod_mem_multiset_prod _ _ _ hg\n\n"}
{"name":"Set.finset_prod_mem_finset_prod","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : CommMonoid α\nt : Finset ι\nf : ι → Set α\ng : ι → α\nhg : ∀ (i : ι), Membership.mem t i → Membership.mem (f i) (g i)\n⊢ Membership.mem (t.prod fun i => f i) (t.prod fun i => g i)","decl":"/-- An n-ary version of `Set.mul_mem_mul`. -/\n@[to_additive \" An n-ary version of `Set.add_mem_add`. \"]\ntheorem finset_prod_mem_finset_prod (t : Finset ι) (f : ι → Set α) (g : ι → α)\n    (hg : ∀ i ∈ t, g i ∈ f i) : (∏ i ∈ t, g i) ∈ ∏ i ∈ t, f i :=\n  multiset_prod_mem_multiset_prod _ _ _ hg\n\n"}
{"name":"Set.finset_prod_subset_finset_prod","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : CommMonoid α\nt : Finset ι\nf₁ f₂ : ι → Set α\nhf : ∀ (i : ι), Membership.mem t i → HasSubset.Subset (f₁ i) (f₂ i)\n⊢ HasSubset.Subset (t.prod fun i => f₁ i) (t.prod fun i => f₂ i)","decl":"/-- An n-ary version of `Set.mul_subset_mul`. -/\n@[to_additive \" An n-ary version of `Set.add_subset_add`. \"]\ntheorem finset_prod_subset_finset_prod (t : Finset ι) (f₁ f₂ : ι → Set α)\n    (hf : ∀ i ∈ t, f₁ i ⊆ f₂ i) : ∏ i ∈ t, f₁ i ⊆ ∏ i ∈ t, f₂ i :=\n  multiset_prod_subset_multiset_prod _ _ _ hf\n\n"}
{"name":"Set.finset_sum_subset_finset_sum","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : AddCommMonoid α\nt : Finset ι\nf₁ f₂ : ι → Set α\nhf : ∀ (i : ι), Membership.mem t i → HasSubset.Subset (f₁ i) (f₂ i)\n⊢ HasSubset.Subset (t.sum fun i => f₁ i) (t.sum fun i => f₂ i)","decl":"/-- An n-ary version of `Set.mul_subset_mul`. -/\n@[to_additive \" An n-ary version of `Set.add_subset_add`. \"]\ntheorem finset_prod_subset_finset_prod (t : Finset ι) (f₁ f₂ : ι → Set α)\n    (hf : ∀ i ∈ t, f₁ i ⊆ f₂ i) : ∏ i ∈ t, f₁ i ⊆ ∏ i ∈ t, f₂ i :=\n  multiset_prod_subset_multiset_prod _ _ _ hf\n\n"}
{"name":"Set.finset_prod_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"M : Type u_5\nι : Type u_6\ninst✝ : CommMonoid M\ns : Finset ι\nI : ι → M\n⊢ Eq (s.prod fun i => Singleton.singleton (I i)) (Singleton.singleton (s.prod fun i => I i))","decl":"@[to_additive]\ntheorem finset_prod_singleton {M ι : Type*} [CommMonoid M] (s : Finset ι) (I : ι → M) :\n    ∏ i ∈ s, ({I i} : Set M) = {∏ i ∈ s, I i} :=\n  (map_prod (singletonMonoidHom : M →* Set M) _ _).symm\n\n"}
{"name":"Set.finset_sum_singleton","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"M : Type u_5\nι : Type u_6\ninst✝ : AddCommMonoid M\ns : Finset ι\nI : ι → M\n⊢ Eq (s.sum fun i => Singleton.singleton (I i)) (Singleton.singleton (s.sum fun i => I i))","decl":"@[to_additive]\ntheorem finset_prod_singleton {M ι : Type*} [CommMonoid M] (s : Finset ι) (I : ι → M) :\n    ∏ i ∈ s, ({I i} : Set M) = {∏ i ∈ s, I i} :=\n  (map_prod (singletonMonoidHom : M →* Set M) _ _).symm\n\n"}
{"name":"Set.image_finset_sum_pi","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : AddCommMonoid α\nl : Finset ι\nS : ι → Set α\n⊢ Eq (Set.image (fun f => l.sum fun i => f i) ((↑l).pi S)) (l.sum fun i => S i)","decl":"/-- The n-ary version of `Set.image_mul_prod`. -/\n@[to_additive \"The n-ary version of `Set.add_image_prod`. \"]\ntheorem image_finset_prod_pi (l : Finset ι) (S : ι → Set α) :\n    (fun f : ι → α => ∏ i ∈ l, f i) '' (l : Set ι).pi S = ∏ i ∈ l, S i := by\n  ext\n  simp_rw [mem_finset_prod, mem_image, mem_pi, exists_prop, Finset.mem_coe]\n\n"}
{"name":"Set.image_finset_prod_pi","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : CommMonoid α\nl : Finset ι\nS : ι → Set α\n⊢ Eq (Set.image (fun f => l.prod fun i => f i) ((↑l).pi S)) (l.prod fun i => S i)","decl":"/-- The n-ary version of `Set.image_mul_prod`. -/\n@[to_additive \"The n-ary version of `Set.add_image_prod`. \"]\ntheorem image_finset_prod_pi (l : Finset ι) (S : ι → Set α) :\n    (fun f : ι → α => ∏ i ∈ l, f i) '' (l : Set ι).pi S = ∏ i ∈ l, S i := by\n  ext\n  simp_rw [mem_finset_prod, mem_image, mem_pi, exists_prop, Finset.mem_coe]\n\n"}
{"name":"Set.image_fintype_sum_pi","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : Fintype ι\nS : ι → Set α\n⊢ Eq (Set.image (fun f => Finset.univ.sum fun i => f i) (Set.univ.pi S)) (Finset.univ.sum fun i => S i)","decl":"/-- A special case of `Set.image_finset_prod_pi` for `Finset.univ`. -/\n@[to_additive \"A special case of `Set.image_finset_sum_pi` for `Finset.univ`. \"]\ntheorem image_fintype_prod_pi [Fintype ι] (S : ι → Set α) :\n    (fun f : ι → α => ∏ i, f i) '' univ.pi S = ∏ i, S i := by\n  simpa only [Finset.coe_univ] using image_finset_prod_pi Finset.univ S\n\n"}
{"name":"Set.image_fintype_prod_pi","module":"Mathlib.Algebra.Group.Pointwise.Set.BigOperators","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : Fintype ι\nS : ι → Set α\n⊢ Eq (Set.image (fun f => Finset.univ.prod fun i => f i) (Set.univ.pi S)) (Finset.univ.prod fun i => S i)","decl":"/-- A special case of `Set.image_finset_prod_pi` for `Finset.univ`. -/\n@[to_additive \"A special case of `Set.image_finset_sum_pi` for `Finset.univ`. \"]\ntheorem image_fintype_prod_pi [Fintype ι] (S : ι → Set α) :\n    (fun f : ι → α => ∏ i, f i) '' univ.pi S = ∏ i, S i := by\n  simpa only [Finset.coe_univ] using image_finset_prod_pi Finset.univ S\n\n"}
