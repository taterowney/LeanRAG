{"name":"BoxIntegral.norm_volume_sub_integral_face_upper_sub_lower_smul_le","module":"Mathlib.Analysis.BoxIntegral.DivergenceTheorem","initialProofState":"E : Type u\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Real E\nn : Nat\ninst‚úù : CompleteSpace E\nI : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\ni : Fin (HAdd.hAdd n 1)\nf : (Fin (HAdd.hAdd n 1) ‚Üí Real) ‚Üí E\nf' : ContinuousLinearMap (RingHom.id Real) (Fin (HAdd.hAdd n 1) ‚Üí Real) E\nhfc : ContinuousOn f (BoxIntegral.Box.Icc I)\nx : Fin (HAdd.hAdd n 1) ‚Üí Real\nhxI : Membership.mem (BoxIntegral.Box.Icc I) x\na : E\nŒµ : Real\nh0 : LT.lt 0 Œµ\nhŒµ : ‚àÄ (y : Fin (HAdd.hAdd n 1) ‚Üí Real), Membership.mem (BoxIntegral.Box.Icc I) y ‚Üí LE.le (Norm.norm (HSub.hSub (HSub.hSub (f y) a) (f' (HSub.hSub y x)))) (HMul.hMul Œµ (Norm.norm (HSub.hSub y x)))\nc : NNReal\nhc : LE.le I.distortion c\n‚ä¢ LE.le (Norm.norm (HSub.hSub (HSMul.hSMul (Finset.univ.prod fun j => HSub.hSub (I.upper j) (I.lower j)) (f' (Pi.single i 1))) (HSub.hSub (BoxIntegral.integral (I.face i) Bot.bot (Function.comp f (i.insertNth (I.upper i))) BoxIntegral.BoxAdditiveMap.volume) (BoxIntegral.integral (I.face i) Bot.bot (Function.comp f (i.insertNth (I.lower i))) BoxIntegral.BoxAdditiveMap.volume)))) (HMul.hMul (HMul.hMul (HMul.hMul 2 Œµ) ‚Üëc) (Finset.univ.prod fun j => HSub.hSub (I.upper j) (I.lower j)))","decl":"/-- Auxiliary lemma for the divergence theorem. -/\ntheorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E}\n    {f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) ‚Üí ‚Ñù}\n    (hxI : x ‚àà (Box.Icc I)) {a : E} {Œµ : ‚Ñù} (h0 : 0 < Œµ)\n    (hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñf y - a - f' (y - x)‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ) {c : ‚Ñù‚â•0}\n    (hc : I.distortion ‚â§ c) :\n    ‚Äñ(‚àè j, (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -\n      (integral (I.face i) ‚ä• (f ‚àò i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù) (I.upper i)) BoxAdditiveMap.volume -\n        integral (I.face i) ‚ä• (f ‚àò i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù) (I.lower i))\n          BoxAdditiveMap.volume)‚Äñ ‚â§\n      2 * Œµ * c * ‚àè j, (I.upper j - I.lower j) := by\n  -- Porting note: Lean fails to find `Œ±` in the next line\n  set e : ‚Ñù ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) := i.insertNth (Œ± := fun _ ‚Ü¶ ‚Ñù)\n  /- **Plan of the proof**. The difference of the integrals of the affine function\n    `fun y ‚Ü¶ a + f' (y - x)` over the faces `x i = I.upper i` and `x i = I.lower i` is equal to the\n    volume of `I` multiplied by `f' (Pi.single i 1)`, so it suffices to show that the integral of\n    `f y - a - f' (y - x)` over each of these faces is less than or equal to `Œµ * c * vol I`. We\n    integrate a function of the norm `‚â§ Œµ * diam I.Icc` over a box of volume\n    `‚àè j ‚â† i, (I.upper j - I.lower j)`. Since `diam I.Icc ‚â§ c * (I.upper i - I.lower i)`, we get the\n    required estimate. -/\n  have Hl : I.lower i ‚àà Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)\n  have Hu : I.upper i ‚àà Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)\n  have Hi : ‚àÄ x ‚àà Icc (I.lower i) (I.upper i),\n      Integrable.{0, u, u} (I.face i) ‚ä• (f ‚àò e x) BoxAdditiveMap.volume := fun x hx =>\n    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume\n  /- We start with an estimate: the difference of the values of `f` at the corresponding points\n    of the faces `x i = I.lower i` and `x i = I.upper i` is `(2 * Œµ * diam I.Icc)`-close to the\n    value of `f'` on `Pi.single i (I.upper i - I.lower i) = l·µ¢ ‚Ä¢ e·µ¢`, where\n    `l·µ¢ = I.upper i - I.lower i` is the length of `i`-th edge of `I` and `e·µ¢ = Pi.single i 1` is the\n    `i`-th unit vector. -/\n  have : ‚àÄ y ‚àà Box.Icc (I.face i),\n      ‚Äñf' (Pi.single i (I.upper i - I.lower i)) -\n          (f (e (I.upper i) y) - f (e (I.lower i) y))‚Äñ ‚â§\n        2 * Œµ * diam (Box.Icc I) := fun y hy ‚Ü¶ by\n    set g := fun y => f y - a - f' (y - x) with hg\n    change ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * ‚Äñy - x‚Äñ at hŒµ\n    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]\n    convert_to ‚Äñg (e (I.lower i) y) - g (e (I.upper i) y)‚Äñ ‚â§ _\n    ¬∑ congr 1\n      have := Fin.insertNth_sub_same (Œ± := fun _ ‚Ü¶ ‚Ñù) i (I.upper i) (I.lower i) y\n      simp only [‚Üê this, f'.map_sub]; abel\n    ¬∑ have : ‚àÄ z ‚àà Icc (I.lower i) (I.upper i), e z y ‚àà (Box.Icc I) := fun z hz =>\n        I.mapsTo_insertNth_face_Icc hz hy\n      replace hŒµ : ‚àÄ y ‚àà (Box.Icc I), ‚Äñg y‚Äñ ‚â§ Œµ * diam (Box.Icc I) := by\n        intro y hy\n        refine (hŒµ y hy).trans (mul_le_mul_of_nonneg_left ?_ h0.le)\n        rw [‚Üê dist_eq_norm]\n        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI\n      rw [two_mul, add_mul]\n      exact norm_sub_le_of_le (hŒµ _ (this _ Hl)) (hŒµ _ (this _ Hu))\n  calc\n    ‚Äñ(‚àè j, (I.upper j - I.lower j)) ‚Ä¢ f' (Pi.single i 1) -\n            (integral (I.face i) ‚ä• (f ‚àò e (I.upper i)) BoxAdditiveMap.volume -\n              integral (I.face i) ‚ä• (f ‚àò e (I.lower i)) BoxAdditiveMap.volume)‚Äñ =\n        ‚Äñintegral.{0, u, u} (I.face i) ‚ä•\n            (fun x : Fin n ‚Üí ‚Ñù =>\n              f' (Pi.single i (I.upper i - I.lower i)) -\n                (f (e (I.upper i) x) - f (e (I.lower i) x)))\n            BoxAdditiveMap.volume‚Äñ := by\n      rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl), ‚Üê Box.volume_face_mul i, mul_smul, ‚Üê Box.volume_apply,\n        ‚Üê BoxAdditiveMap.toSMul_apply, ‚Üê integral_const, ‚Üê BoxAdditiveMap.volume,\n        ‚Üê integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]\n      simp only [(¬∑ ‚àò ¬∑), Pi.sub_def, ‚Üê f'.map_smul, ‚Üê Pi.single_smul', smul_eq_mul, mul_one]\n    _ ‚â§ (volume (I.face i : Set (Fin n ‚Üí ‚Ñù))).toReal * (2 * Œµ * c * (I.upper i - I.lower i)) := by\n      -- The hard part of the estimate was done above, here we just replace `diam I.Icc`\n      -- with `c * (I.upper i - I.lower i)`\n      refine norm_integral_le_of_le_const (fun y hy => (this y hy).trans ?_) volume\n      rw [mul_assoc (2 * Œµ)]\n      gcongr\n      exact I.diam_Icc_le_of_distortion_le i hc\n    _ = 2 * Œµ * c * ‚àè j, (I.upper j - I.lower j) := by\n      rw [‚Üê Measure.toBoxAdditive_apply, Box.volume_apply, ‚Üê I.volume_face_mul i]\n      ac_rfl\n\n"}
{"name":"BoxIntegral.hasIntegral_GP_pderiv","module":"Mathlib.Analysis.BoxIntegral.DivergenceTheorem","initialProofState":"E : Type u\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Real E\nn : Nat\ninst‚úù : CompleteSpace E\nI : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\nf : (Fin (HAdd.hAdd n 1) ‚Üí Real) ‚Üí E\nf' : (Fin (HAdd.hAdd n 1) ‚Üí Real) ‚Üí ContinuousLinearMap (RingHom.id Real) (Fin (HAdd.hAdd n 1) ‚Üí Real) E\ns : Set (Fin (HAdd.hAdd n 1) ‚Üí Real)\nhs : s.Countable\nHs : ‚àÄ (x : Fin (HAdd.hAdd n 1) ‚Üí Real), Membership.mem s x ‚Üí ContinuousWithinAt f (BoxIntegral.Box.Icc I) x\nHd : ‚àÄ (x : Fin (HAdd.hAdd n 1) ‚Üí Real), Membership.mem (SDiff.sdiff (BoxIntegral.Box.Icc I) s) x ‚Üí HasFDerivWithinAt f (f' x) (BoxIntegral.Box.Icc I) x\ni : Fin (HAdd.hAdd n 1)\n‚ä¢ BoxIntegral.HasIntegral I BoxIntegral.IntegrationParams.GP (fun x => (f' x) (Pi.single i 1)) BoxIntegral.BoxAdditiveMap.volume (HSub.hSub (BoxIntegral.integral (I.face i) BoxIntegral.IntegrationParams.GP (fun x => f (i.insertNth (I.upper i) x)) BoxIntegral.BoxAdditiveMap.volume) (BoxIntegral.integral (I.face i) BoxIntegral.IntegrationParams.GP (fun x => f (i.insertNth (I.lower i) x)) BoxIntegral.BoxAdditiveMap.volume))","decl":"/-- If `f : ‚Ñù‚Åø‚Å∫¬π ‚Üí E` is differentiable on a closed rectangular box `I` with derivative `f'`, then\nthe partial derivative `fun x ‚Ü¶ f' x (Pi.single i 1)` is Henstock-Kurzweil integrable with integral\nequal to the difference of integrals of `f` over the faces `x i = I.upper i` and `x i = I.lower i`.\n\nMore precisely, we use a non-standard generalization of the Henstock-Kurzweil integral and\nwe allow `f` to be non-differentiable (but still continuous) at a countable set of points.\n\nTODO: If `n > 0`, then the condition at `x ‚àà s` can be replaced by a much weaker estimate but this\nrequires either better integrability theorems, or usage of a filter depending on the countable set\n`s` (we need to ensure that none of the faces of a partition contain a point from `s`). -/\ntheorem hasIntegral_GP_pderiv (f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí E)\n    (f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] E) (s : Set (Fin (n + 1) ‚Üí ‚Ñù))\n    (hs : s.Countable) (Hs : ‚àÄ x ‚àà s, ContinuousWithinAt f (Box.Icc I) x)\n    (Hd : ‚àÄ x ‚àà (Box.Icc I) \\ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x) (i : Fin (n + 1)) :\n    HasIntegral.{0, u, u} I GP (fun x => f' x (Pi.single i 1)) BoxAdditiveMap.volume\n      (integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.upper i) x))\n          BoxAdditiveMap.volume -\n        integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.lower i) x))\n          BoxAdditiveMap.volume) := by\n  /- Note that `f` is continuous on `I.Icc`, hence it is integrable on the faces of all boxes\n    `J ‚â§ I`, thus the difference of integrals over `x i = J.upper i` and `x i = J.lower i` is a\n    box-additive function of `J ‚â§ I`. -/\n  have Hc : ContinuousOn f (Box.Icc I) := fun x hx ‚Ü¶ by\n    by_cases hxs : x ‚àà s\n    exacts [Hs x hxs, (Hd x ‚ü®hx, hxs‚ü©).continuousWithinAt]\n  set fI : ‚Ñù ‚Üí Box (Fin n) ‚Üí E := fun y J =>\n    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume\n  set fb : Icc (I.lower i) (I.upper i) ‚Üí Fin n ‚Üí·µá·µÉ[‚Üë(I.face i)] E := fun x =>\n    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive\n  set F : Fin (n + 1) ‚Üí·µá·µÉ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl\n  -- Thus our statement follows from some local estimates.\n  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)\n  refine HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le ?_ ?_ _ s hs ?_ ?_\n  ¬∑-- We use the volume as an upper estimate.\n    exact (volume : Measure (Fin (n + 1) ‚Üí ‚Ñù)).toBoxAdditive.restrict _ le_top\n  ¬∑ exact fun J => ENNReal.toReal_nonneg\n  ¬∑ intro c x hx Œµ Œµ0\n    /- Near `x ‚àà s` we choose `Œ¥` so that both vectors are small. `volume J ‚Ä¢ e·µ¢` is small because\n        `volume J ‚â§ (2 * Œ¥) ^ (n + 1)` is small, and the difference of the integrals is small\n        because each of the integrals is close to `volume (J.face i) ‚Ä¢ f x`.\n        TODO: there should be a shorter and more readable way to formalize this simple proof. -/\n    have : ‚àÄ·∂† Œ¥ in ùìù[>] (0 : ‚Ñù), Œ¥ ‚àà Ioc (0 : ‚Ñù) (1 / 2) ‚àß\n        (‚àÄ·µâ (y‚ÇÅ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)) (y‚ÇÇ ‚àà closedBall x Œ¥ ‚à© (Box.Icc I)),\n              ‚Äñf y‚ÇÅ - f y‚ÇÇ‚Äñ ‚â§ Œµ / 2) ‚àß (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ ‚â§ Œµ / 2 := by\n      refine .and (Ioc_mem_nhdsGT one_half_pos) (.and ?_ ?_)\n      ¬∑ rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1\n            (Hs x hx.2) _ (half_pos <| half_pos Œµ0) with ‚ü®Œ¥‚ÇÅ, Œ¥‚ÇÅ0, hŒ¥‚ÇÅ‚ü©\n        filter_upwards [Ioc_mem_nhdsGT Œ¥‚ÇÅ0] with Œ¥ hŒ¥ y‚ÇÅ hy‚ÇÅ y‚ÇÇ hy‚ÇÇ\n        have : closedBall x Œ¥ ‚à© (Box.Icc I) ‚äÜ closedBall x Œ¥‚ÇÅ ‚à© (Box.Icc I) := by gcongr; exact hŒ¥.2\n        rw [‚Üê dist_eq_norm]\n        calc\n          dist (f y‚ÇÅ) (f y‚ÇÇ) ‚â§ dist (f y‚ÇÅ) (f x) + dist (f y‚ÇÇ) (f x) := dist_triangle_right _ _ _\n          _ ‚â§ Œµ / 2 / 2 + Œµ / 2 / 2 := add_le_add (hŒ¥‚ÇÅ _ <| this hy‚ÇÅ) (hŒ¥‚ÇÅ _ <| this hy‚ÇÇ)\n          _ = Œµ / 2 := add_halves _\n      ¬∑ have : ContinuousWithinAt (fun Œ¥ : ‚Ñù => (2 * Œ¥) ^ (n + 1) * ‚Äñf' x (Pi.single i 1)‚Äñ)\n            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _\n        refine this.eventually (ge_mem_nhds ?_)\n        simpa using half_pos Œµ0\n    rcases this.exists with ‚ü®Œ¥, ‚ü®hŒ¥0, hŒ¥12‚ü©, hdfŒ¥, hŒ¥‚ü©\n    refine ‚ü®Œ¥, hŒ¥0, fun J hJI hJŒ¥ _ _ => add_halves Œµ ‚ñ∏ ?_‚ü©\n    have Hl : J.lower i ‚àà Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)\n    have Hu : J.upper i ‚àà Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)\n    have Hi : ‚àÄ x ‚àà Icc (J.lower i) (J.upper i),\n        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))\n          BoxAdditiveMap.volume := fun x hx =>\n      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)\n        volume\n    have hJŒ¥' : Box.Icc J ‚äÜ closedBall x Œ¥ ‚à© (Box.Icc I) := subset_inter hJŒ¥ (Box.le_iff_Icc.1 hJI)\n    have Hmaps : ‚àÄ z ‚àà Icc (J.lower i) (J.upper i),\n        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x Œ¥ ‚à© (Box.Icc I)) := fun z hz =>\n      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJŒ¥'\n    simp only [dist_eq_norm]; dsimp [F]\n    rw [‚Üê integral_sub (Hi _ Hu) (Hi _ Hl)]\n    refine (norm_sub_le _ _).trans (add_le_add ?_ ?_)\n    ¬∑ simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]\n      refine (mul_le_mul_of_nonneg_right ?_ <| norm_nonneg _).trans hŒ¥\n      have : ‚àÄ j, |J.upper j - J.lower j| ‚â§ 2 * Œ¥ := fun j ‚Ü¶\n        calc\n          dist (J.upper j) (J.lower j) ‚â§ dist J.upper J.lower := dist_le_pi_dist _ _ _\n          _ ‚â§ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _\n          _ ‚â§ Œ¥ + Œ¥ := add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc)\n          _ = 2 * Œ¥ := (two_mul Œ¥).symm\n      calc\n        ‚àè j, |J.upper j - J.lower j| ‚â§ ‚àè j : Fin (n + 1), 2 * Œ¥ :=\n          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j\n        _ = (2 * Œ¥) ^ (n + 1) := by simp\n    ¬∑ refine (norm_integral_le_of_le_const (fun y hy => hdfŒ¥ _ (Hmaps _ Hu hy) _\n        (Hmaps _ Hl hy)) volume).trans ?_\n      refine (mul_le_mul_of_nonneg_right ?_ (half_pos Œµ0).le).trans_eq (one_mul _)\n      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]\n      refine prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => ?_\n      calc\n        J.upper (i.succAbove j) - J.lower (i.succAbove j) ‚â§\n            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=\n          le_abs_self _\n        _ ‚â§ dist J.upper J.lower := dist_le_pi_dist J.upper J.lower (i.succAbove j)\n        _ ‚â§ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _\n        _ ‚â§ Œ¥ + Œ¥ := add_le_add (hJŒ¥ J.upper_mem_Icc) (hJŒ¥ J.lower_mem_Icc)\n        _ ‚â§ 1 / 2 + 1 / 2 := by gcongr\n        _ = 1 := add_halves 1\n  ¬∑ intro c x hx Œµ Œµ0\n    /- At a point `x ‚àâ s`, we unfold the definition of Fr√©chet differentiability, then use\n        an estimate we proved earlier in this file. -/\n    rcases exists_pos_mul_lt Œµ0 (2 * c) with ‚ü®Œµ', Œµ'0, hlt‚ü©\n    rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1\n      ((Hd x hx).isLittleO.def Œµ'0) with ‚ü®Œ¥, Œ¥0, HŒ¥‚ü©\n    refine ‚ü®Œ¥, Œ¥0, fun J hle hJŒ¥ hxJ hJc => ?_‚ü©\n    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]\n    refine (norm_volume_sub_integral_face_upper_sub_lower_smul_le _\n      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ Œµ'0 (fun y hy => HŒ¥ ?_) (hJc rfl)).trans ?_\n    ¬∑ exact ‚ü®hJŒ¥ hy, Box.le_iff_Icc.1 hle hy‚ü©\n    ¬∑ rw [mul_right_comm (2 : ‚Ñù), ‚Üê Box.volume_apply]\n      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg\n\n"}
{"name":"BoxIntegral.hasIntegral_GP_divergence_of_forall_hasDerivWithinAt","module":"Mathlib.Analysis.BoxIntegral.DivergenceTheorem","initialProofState":"E : Type u\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace Real E\nn : Nat\ninst‚úù : CompleteSpace E\nI : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\nf : (Fin (HAdd.hAdd n 1) ‚Üí Real) ‚Üí Fin (HAdd.hAdd n 1) ‚Üí E\nf' : (Fin (HAdd.hAdd n 1) ‚Üí Real) ‚Üí ContinuousLinearMap (RingHom.id Real) (Fin (HAdd.hAdd n 1) ‚Üí Real) (Fin (HAdd.hAdd n 1) ‚Üí E)\ns : Set (Fin (HAdd.hAdd n 1) ‚Üí Real)\nhs : s.Countable\nHs : ‚àÄ (x : Fin (HAdd.hAdd n 1) ‚Üí Real), Membership.mem s x ‚Üí ContinuousWithinAt f (BoxIntegral.Box.Icc I) x\nHd : ‚àÄ (x : Fin (HAdd.hAdd n 1) ‚Üí Real), Membership.mem (SDiff.sdiff (BoxIntegral.Box.Icc I) s) x ‚Üí HasFDerivWithinAt f (f' x) (BoxIntegral.Box.Icc I) x\n‚ä¢ BoxIntegral.HasIntegral I BoxIntegral.IntegrationParams.GP (fun x => Finset.univ.sum fun i => (f' x) (Pi.single i 1) i) BoxIntegral.BoxAdditiveMap.volume (Finset.univ.sum fun i => HSub.hSub (BoxIntegral.integral (I.face i) BoxIntegral.IntegrationParams.GP (fun x => f (i.insertNth (I.upper i) x) i) BoxIntegral.BoxAdditiveMap.volume) (BoxIntegral.integral (I.face i) BoxIntegral.IntegrationParams.GP (fun x => f (i.insertNth (I.lower i) x) i) BoxIntegral.BoxAdditiveMap.volume))","decl":"/-- Divergence theorem for a Henstock-Kurzweil style integral.\n\nIf `f : ‚Ñù‚Åø‚Å∫¬π ‚Üí E‚Åø‚Å∫¬π` is differentiable on a closed rectangular box `I` with derivative `f'`, then\nthe divergence `‚àë i, f' x (Pi.single i 1) i` is Henstock-Kurzweil integrable with integral equal to\nthe sum of integrals of `f` over the faces of `I` taken with appropriate signs.\n\nMore precisely, we use a non-standard generalization of the Henstock-Kurzweil integral and\nwe allow `f` to be non-differentiable (but still continuous) at a countable set of points. -/\ntheorem hasIntegral_GP_divergence_of_forall_hasDerivWithinAt\n    (f : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí Fin (n + 1) ‚Üí E)\n    (f' : (Fin (n + 1) ‚Üí ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù) ‚ÜíL[‚Ñù] (Fin (n + 1) ‚Üí E))\n    (s : Set (Fin (n + 1) ‚Üí ‚Ñù)) (hs : s.Countable)\n    (Hs : ‚àÄ x ‚àà s, ContinuousWithinAt f (Box.Icc I) x)\n    (Hd : ‚àÄ x ‚àà (Box.Icc I) \\ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x) :\n    HasIntegral.{0, u, u} I GP (fun x => ‚àë i, f' x (Pi.single i 1) i) BoxAdditiveMap.volume\n      (‚àë i,\n        (integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.upper i) x) i)\n            BoxAdditiveMap.volume -\n          integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.lower i) x) i)\n            BoxAdditiveMap.volume)) := by\n  refine HasIntegral.sum fun i _ => ?_\n  simp only [hasFDerivWithinAt_pi', continuousWithinAt_pi] at Hd Hs\n  exact hasIntegral_GP_pderiv I _ _ s hs (fun x hx => Hs x hx i) (fun x hx => Hd x hx i) i\n\n"}
