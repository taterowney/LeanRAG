{"name":"BoxIntegral.norm_volume_sub_integral_face_upper_sub_lower_smul_le","module":"Mathlib.Analysis.BoxIntegral.DivergenceTheorem","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nn : Nat\ninst✝ : CompleteSpace E\nI : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\ni : Fin (HAdd.hAdd n 1)\nf : (Fin (HAdd.hAdd n 1) → Real) → E\nf' : ContinuousLinearMap (RingHom.id Real) (Fin (HAdd.hAdd n 1) → Real) E\nhfc : ContinuousOn f (BoxIntegral.Box.Icc I)\nx : Fin (HAdd.hAdd n 1) → Real\nhxI : Membership.mem (BoxIntegral.Box.Icc I) x\na : E\nε : Real\nh0 : LT.lt 0 ε\nhε : ∀ (y : Fin (HAdd.hAdd n 1) → Real), Membership.mem (BoxIntegral.Box.Icc I) y → LE.le (Norm.norm (HSub.hSub (HSub.hSub (f y) a) (f' (HSub.hSub y x)))) (HMul.hMul ε (Norm.norm (HSub.hSub y x)))\nc : NNReal\nhc : LE.le I.distortion c\n⊢ LE.le (Norm.norm (HSub.hSub (HSMul.hSMul (Finset.univ.prod fun j => HSub.hSub (I.upper j) (I.lower j)) (f' (Pi.single i 1))) (HSub.hSub (BoxIntegral.integral (I.face i) Bot.bot (Function.comp f (i.insertNth (I.upper i))) BoxIntegral.BoxAdditiveMap.volume) (BoxIntegral.integral (I.face i) Bot.bot (Function.comp f (i.insertNth (I.lower i))) BoxIntegral.BoxAdditiveMap.volume)))) (HMul.hMul (HMul.hMul (HMul.hMul 2 ε) ↑c) (Finset.univ.prod fun j => HSub.hSub (I.upper j) (I.lower j)))","decl":"/-- Auxiliary lemma for the divergence theorem. -/\ntheorem norm_volume_sub_integral_face_upper_sub_lower_smul_le {f : (Fin (n + 1) → ℝ) → E}\n    {f' : (Fin (n + 1) → ℝ) →L[ℝ] E} (hfc : ContinuousOn f (Box.Icc I)) {x : Fin (n + 1) → ℝ}\n    (hxI : x ∈ (Box.Icc I)) {a : E} {ε : ℝ} (h0 : 0 < ε)\n    (hε : ∀ y ∈ (Box.Icc I), ‖f y - a - f' (y - x)‖ ≤ ε * ‖y - x‖) {c : ℝ≥0}\n    (hc : I.distortion ≤ c) :\n    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -\n      (integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.upper i)) BoxAdditiveMap.volume -\n        integral (I.face i) ⊥ (f ∘ i.insertNth (α := fun _ ↦ ℝ) (I.lower i))\n          BoxAdditiveMap.volume)‖ ≤\n      2 * ε * c * ∏ j, (I.upper j - I.lower j) := by\n  -- Porting note: Lean fails to find `α` in the next line\n  set e : ℝ → (Fin n → ℝ) → (Fin (n + 1) → ℝ) := i.insertNth (α := fun _ ↦ ℝ)\n  /- **Plan of the proof**. The difference of the integrals of the affine function\n    `fun y ↦ a + f' (y - x)` over the faces `x i = I.upper i` and `x i = I.lower i` is equal to the\n    volume of `I` multiplied by `f' (Pi.single i 1)`, so it suffices to show that the integral of\n    `f y - a - f' (y - x)` over each of these faces is less than or equal to `ε * c * vol I`. We\n    integrate a function of the norm `≤ ε * diam I.Icc` over a box of volume\n    `∏ j ≠ i, (I.upper j - I.lower j)`. Since `diam I.Icc ≤ c * (I.upper i - I.lower i)`, we get the\n    required estimate. -/\n  have Hl : I.lower i ∈ Icc (I.lower i) (I.upper i) := Set.left_mem_Icc.2 (I.lower_le_upper i)\n  have Hu : I.upper i ∈ Icc (I.lower i) (I.upper i) := Set.right_mem_Icc.2 (I.lower_le_upper i)\n  have Hi : ∀ x ∈ Icc (I.lower i) (I.upper i),\n      Integrable.{0, u, u} (I.face i) ⊥ (f ∘ e x) BoxAdditiveMap.volume := fun x hx =>\n    integrable_of_continuousOn _ (Box.continuousOn_face_Icc hfc hx) volume\n  /- We start with an estimate: the difference of the values of `f` at the corresponding points\n    of the faces `x i = I.lower i` and `x i = I.upper i` is `(2 * ε * diam I.Icc)`-close to the\n    value of `f'` on `Pi.single i (I.upper i - I.lower i) = lᵢ • eᵢ`, where\n    `lᵢ = I.upper i - I.lower i` is the length of `i`-th edge of `I` and `eᵢ = Pi.single i 1` is the\n    `i`-th unit vector. -/\n  have : ∀ y ∈ Box.Icc (I.face i),\n      ‖f' (Pi.single i (I.upper i - I.lower i)) -\n          (f (e (I.upper i) y) - f (e (I.lower i) y))‖ ≤\n        2 * ε * diam (Box.Icc I) := fun y hy ↦ by\n    set g := fun y => f y - a - f' (y - x) with hg\n    change ∀ y ∈ (Box.Icc I), ‖g y‖ ≤ ε * ‖y - x‖ at hε\n    clear_value g; obtain rfl : f = fun y => a + f' (y - x) + g y := by simp [hg]\n    convert_to ‖g (e (I.lower i) y) - g (e (I.upper i) y)‖ ≤ _\n    · congr 1\n      have := Fin.insertNth_sub_same (α := fun _ ↦ ℝ) i (I.upper i) (I.lower i) y\n      simp only [← this, f'.map_sub]; abel\n    · have : ∀ z ∈ Icc (I.lower i) (I.upper i), e z y ∈ (Box.Icc I) := fun z hz =>\n        I.mapsTo_insertNth_face_Icc hz hy\n      replace hε : ∀ y ∈ (Box.Icc I), ‖g y‖ ≤ ε * diam (Box.Icc I) := by\n        intro y hy\n        refine (hε y hy).trans (mul_le_mul_of_nonneg_left ?_ h0.le)\n        rw [← dist_eq_norm]\n        exact dist_le_diam_of_mem I.isCompact_Icc.isBounded hy hxI\n      rw [two_mul, add_mul]\n      exact norm_sub_le_of_le (hε _ (this _ Hl)) (hε _ (this _ Hu))\n  calc\n    ‖(∏ j, (I.upper j - I.lower j)) • f' (Pi.single i 1) -\n            (integral (I.face i) ⊥ (f ∘ e (I.upper i)) BoxAdditiveMap.volume -\n              integral (I.face i) ⊥ (f ∘ e (I.lower i)) BoxAdditiveMap.volume)‖ =\n        ‖integral.{0, u, u} (I.face i) ⊥\n            (fun x : Fin n → ℝ =>\n              f' (Pi.single i (I.upper i - I.lower i)) -\n                (f (e (I.upper i) x) - f (e (I.lower i) x)))\n            BoxAdditiveMap.volume‖ := by\n      rw [← integral_sub (Hi _ Hu) (Hi _ Hl), ← Box.volume_face_mul i, mul_smul, ← Box.volume_apply,\n        ← BoxAdditiveMap.toSMul_apply, ← integral_const, ← BoxAdditiveMap.volume,\n        ← integral_sub (integrable_const _) ((Hi _ Hu).sub (Hi _ Hl))]\n      simp only [(· ∘ ·), Pi.sub_def, ← f'.map_smul, ← Pi.single_smul', smul_eq_mul, mul_one]\n    _ ≤ (volume (I.face i : Set (Fin n → ℝ))).toReal * (2 * ε * c * (I.upper i - I.lower i)) := by\n      -- The hard part of the estimate was done above, here we just replace `diam I.Icc`\n      -- with `c * (I.upper i - I.lower i)`\n      refine norm_integral_le_of_le_const (fun y hy => (this y hy).trans ?_) volume\n      rw [mul_assoc (2 * ε)]\n      gcongr\n      exact I.diam_Icc_le_of_distortion_le i hc\n    _ = 2 * ε * c * ∏ j, (I.upper j - I.lower j) := by\n      rw [← Measure.toBoxAdditive_apply, Box.volume_apply, ← I.volume_face_mul i]\n      ac_rfl\n\n"}
{"name":"BoxIntegral.hasIntegral_GP_pderiv","module":"Mathlib.Analysis.BoxIntegral.DivergenceTheorem","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nn : Nat\ninst✝ : CompleteSpace E\nI : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\nf : (Fin (HAdd.hAdd n 1) → Real) → E\nf' : (Fin (HAdd.hAdd n 1) → Real) → ContinuousLinearMap (RingHom.id Real) (Fin (HAdd.hAdd n 1) → Real) E\ns : Set (Fin (HAdd.hAdd n 1) → Real)\nhs : s.Countable\nHs : ∀ (x : Fin (HAdd.hAdd n 1) → Real), Membership.mem s x → ContinuousWithinAt f (BoxIntegral.Box.Icc I) x\nHd : ∀ (x : Fin (HAdd.hAdd n 1) → Real), Membership.mem (SDiff.sdiff (BoxIntegral.Box.Icc I) s) x → HasFDerivWithinAt f (f' x) (BoxIntegral.Box.Icc I) x\ni : Fin (HAdd.hAdd n 1)\n⊢ BoxIntegral.HasIntegral I BoxIntegral.IntegrationParams.GP (fun x => (f' x) (Pi.single i 1)) BoxIntegral.BoxAdditiveMap.volume (HSub.hSub (BoxIntegral.integral (I.face i) BoxIntegral.IntegrationParams.GP (fun x => f (i.insertNth (I.upper i) x)) BoxIntegral.BoxAdditiveMap.volume) (BoxIntegral.integral (I.face i) BoxIntegral.IntegrationParams.GP (fun x => f (i.insertNth (I.lower i) x)) BoxIntegral.BoxAdditiveMap.volume))","decl":"/-- If `f : ℝⁿ⁺¹ → E` is differentiable on a closed rectangular box `I` with derivative `f'`, then\nthe partial derivative `fun x ↦ f' x (Pi.single i 1)` is Henstock-Kurzweil integrable with integral\nequal to the difference of integrals of `f` over the faces `x i = I.upper i` and `x i = I.lower i`.\n\nMore precisely, we use a non-standard generalization of the Henstock-Kurzweil integral and\nwe allow `f` to be non-differentiable (but still continuous) at a countable set of points.\n\nTODO: If `n > 0`, then the condition at `x ∈ s` can be replaced by a much weaker estimate but this\nrequires either better integrability theorems, or usage of a filter depending on the countable set\n`s` (we need to ensure that none of the faces of a partition contain a point from `s`). -/\ntheorem hasIntegral_GP_pderiv (f : (Fin (n + 1) → ℝ) → E)\n    (f' : (Fin (n + 1) → ℝ) → (Fin (n + 1) → ℝ) →L[ℝ] E) (s : Set (Fin (n + 1) → ℝ))\n    (hs : s.Countable) (Hs : ∀ x ∈ s, ContinuousWithinAt f (Box.Icc I) x)\n    (Hd : ∀ x ∈ (Box.Icc I) \\ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x) (i : Fin (n + 1)) :\n    HasIntegral.{0, u, u} I GP (fun x => f' x (Pi.single i 1)) BoxAdditiveMap.volume\n      (integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.upper i) x))\n          BoxAdditiveMap.volume -\n        integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.lower i) x))\n          BoxAdditiveMap.volume) := by\n  /- Note that `f` is continuous on `I.Icc`, hence it is integrable on the faces of all boxes\n    `J ≤ I`, thus the difference of integrals over `x i = J.upper i` and `x i = J.lower i` is a\n    box-additive function of `J ≤ I`. -/\n  have Hc : ContinuousOn f (Box.Icc I) := fun x hx ↦ by\n    by_cases hxs : x ∈ s\n    exacts [Hs x hxs, (Hd x ⟨hx, hxs⟩).continuousWithinAt]\n  set fI : ℝ → Box (Fin n) → E := fun y J =>\n    integral.{0, u, u} J GP (fun x => f (i.insertNth y x)) BoxAdditiveMap.volume\n  set fb : Icc (I.lower i) (I.upper i) → Fin n →ᵇᵃ[↑(I.face i)] E := fun x =>\n    (integrable_of_continuousOn GP (Box.continuousOn_face_Icc Hc x.2) volume).toBoxAdditive\n  set F : Fin (n + 1) →ᵇᵃ[I] E := BoxAdditiveMap.upperSubLower I i fI fb fun x _ J => rfl\n  -- Thus our statement follows from some local estimates.\n  change HasIntegral I GP (fun x => f' x (Pi.single i 1)) _ (F I)\n  refine HasIntegral.of_le_Henstock_of_forall_isLittleO gp_le ?_ ?_ _ s hs ?_ ?_\n  ·-- We use the volume as an upper estimate.\n    exact (volume : Measure (Fin (n + 1) → ℝ)).toBoxAdditive.restrict _ le_top\n  · exact fun J => ENNReal.toReal_nonneg\n  · intro c x hx ε ε0\n    /- Near `x ∈ s` we choose `δ` so that both vectors are small. `volume J • eᵢ` is small because\n        `volume J ≤ (2 * δ) ^ (n + 1)` is small, and the difference of the integrals is small\n        because each of the integrals is close to `volume (J.face i) • f x`.\n        TODO: there should be a shorter and more readable way to formalize this simple proof. -/\n    have : ∀ᶠ δ in 𝓝[>] (0 : ℝ), δ ∈ Ioc (0 : ℝ) (1 / 2) ∧\n        (∀ᵉ (y₁ ∈ closedBall x δ ∩ (Box.Icc I)) (y₂ ∈ closedBall x δ ∩ (Box.Icc I)),\n              ‖f y₁ - f y₂‖ ≤ ε / 2) ∧ (2 * δ) ^ (n + 1) * ‖f' x (Pi.single i 1)‖ ≤ ε / 2 := by\n      refine .and (Ioc_mem_nhdsGT one_half_pos) (.and ?_ ?_)\n      · rcases ((nhdsWithin_hasBasis nhds_basis_closedBall _).tendsto_iff nhds_basis_closedBall).1\n            (Hs x hx.2) _ (half_pos <| half_pos ε0) with ⟨δ₁, δ₁0, hδ₁⟩\n        filter_upwards [Ioc_mem_nhdsGT δ₁0] with δ hδ y₁ hy₁ y₂ hy₂\n        have : closedBall x δ ∩ (Box.Icc I) ⊆ closedBall x δ₁ ∩ (Box.Icc I) := by gcongr; exact hδ.2\n        rw [← dist_eq_norm]\n        calc\n          dist (f y₁) (f y₂) ≤ dist (f y₁) (f x) + dist (f y₂) (f x) := dist_triangle_right _ _ _\n          _ ≤ ε / 2 / 2 + ε / 2 / 2 := add_le_add (hδ₁ _ <| this hy₁) (hδ₁ _ <| this hy₂)\n          _ = ε / 2 := add_halves _\n      · have : ContinuousWithinAt (fun δ : ℝ => (2 * δ) ^ (n + 1) * ‖f' x (Pi.single i 1)‖)\n            (Ioi 0) 0 := ((continuousWithinAt_id.const_mul _).pow _).mul_const _\n        refine this.eventually (ge_mem_nhds ?_)\n        simpa using half_pos ε0\n    rcases this.exists with ⟨δ, ⟨hδ0, hδ12⟩, hdfδ, hδ⟩\n    refine ⟨δ, hδ0, fun J hJI hJδ _ _ => add_halves ε ▸ ?_⟩\n    have Hl : J.lower i ∈ Icc (J.lower i) (J.upper i) := Set.left_mem_Icc.2 (J.lower_le_upper i)\n    have Hu : J.upper i ∈ Icc (J.lower i) (J.upper i) := Set.right_mem_Icc.2 (J.lower_le_upper i)\n    have Hi : ∀ x ∈ Icc (J.lower i) (J.upper i),\n        Integrable.{0, u, u} (J.face i) GP (fun y => f (i.insertNth x y))\n          BoxAdditiveMap.volume := fun x hx =>\n      integrable_of_continuousOn _ (Box.continuousOn_face_Icc (Hc.mono <| Box.le_iff_Icc.1 hJI) hx)\n        volume\n    have hJδ' : Box.Icc J ⊆ closedBall x δ ∩ (Box.Icc I) := subset_inter hJδ (Box.le_iff_Icc.1 hJI)\n    have Hmaps : ∀ z ∈ Icc (J.lower i) (J.upper i),\n        MapsTo (i.insertNth z) (Box.Icc (J.face i)) (closedBall x δ ∩ (Box.Icc I)) := fun z hz =>\n      (J.mapsTo_insertNth_face_Icc hz).mono Subset.rfl hJδ'\n    simp only [dist_eq_norm]; dsimp [F]\n    rw [← integral_sub (Hi _ Hu) (Hi _ Hl)]\n    refine (norm_sub_le _ _).trans (add_le_add ?_ ?_)\n    · simp_rw [BoxAdditiveMap.volume_apply, norm_smul, Real.norm_eq_abs, abs_prod]\n      refine (mul_le_mul_of_nonneg_right ?_ <| norm_nonneg _).trans hδ\n      have : ∀ j, |J.upper j - J.lower j| ≤ 2 * δ := fun j ↦\n        calc\n          dist (J.upper j) (J.lower j) ≤ dist J.upper J.lower := dist_le_pi_dist _ _ _\n          _ ≤ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _\n          _ ≤ δ + δ := add_le_add (hJδ J.upper_mem_Icc) (hJδ J.lower_mem_Icc)\n          _ = 2 * δ := (two_mul δ).symm\n      calc\n        ∏ j, |J.upper j - J.lower j| ≤ ∏ j : Fin (n + 1), 2 * δ :=\n          prod_le_prod (fun _ _ => abs_nonneg _) fun j _ => this j\n        _ = (2 * δ) ^ (n + 1) := by simp\n    · refine (norm_integral_le_of_le_const (fun y hy => hdfδ _ (Hmaps _ Hu hy) _\n        (Hmaps _ Hl hy)) volume).trans ?_\n      refine (mul_le_mul_of_nonneg_right ?_ (half_pos ε0).le).trans_eq (one_mul _)\n      rw [Box.coe_eq_pi, Real.volume_pi_Ioc_toReal (Box.lower_le_upper _)]\n      refine prod_le_one (fun _ _ => sub_nonneg.2 <| Box.lower_le_upper _ _) fun j _ => ?_\n      calc\n        J.upper (i.succAbove j) - J.lower (i.succAbove j) ≤\n            dist (J.upper (i.succAbove j)) (J.lower (i.succAbove j)) :=\n          le_abs_self _\n        _ ≤ dist J.upper J.lower := dist_le_pi_dist J.upper J.lower (i.succAbove j)\n        _ ≤ dist J.upper x + dist J.lower x := dist_triangle_right _ _ _\n        _ ≤ δ + δ := add_le_add (hJδ J.upper_mem_Icc) (hJδ J.lower_mem_Icc)\n        _ ≤ 1 / 2 + 1 / 2 := by gcongr\n        _ = 1 := add_halves 1\n  · intro c x hx ε ε0\n    /- At a point `x ∉ s`, we unfold the definition of Fréchet differentiability, then use\n        an estimate we proved earlier in this file. -/\n    rcases exists_pos_mul_lt ε0 (2 * c) with ⟨ε', ε'0, hlt⟩\n    rcases (nhdsWithin_hasBasis nhds_basis_closedBall _).mem_iff.1\n      ((Hd x hx).isLittleO.def ε'0) with ⟨δ, δ0, Hδ⟩\n    refine ⟨δ, δ0, fun J hle hJδ hxJ hJc => ?_⟩\n    simp only [BoxAdditiveMap.volume_apply, Box.volume_apply, dist_eq_norm]\n    refine (norm_volume_sub_integral_face_upper_sub_lower_smul_le _\n      (Hc.mono <| Box.le_iff_Icc.1 hle) hxJ ε'0 (fun y hy => Hδ ?_) (hJc rfl)).trans ?_\n    · exact ⟨hJδ hy, Box.le_iff_Icc.1 hle hy⟩\n    · rw [mul_right_comm (2 : ℝ), ← Box.volume_apply]\n      exact mul_le_mul_of_nonneg_right hlt.le ENNReal.toReal_nonneg\n\n"}
{"name":"BoxIntegral.hasIntegral_GP_divergence_of_forall_hasDerivWithinAt","module":"Mathlib.Analysis.BoxIntegral.DivergenceTheorem","initialProofState":"E : Type u\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nn : Nat\ninst✝ : CompleteSpace E\nI : BoxIntegral.Box (Fin (HAdd.hAdd n 1))\nf : (Fin (HAdd.hAdd n 1) → Real) → Fin (HAdd.hAdd n 1) → E\nf' : (Fin (HAdd.hAdd n 1) → Real) → ContinuousLinearMap (RingHom.id Real) (Fin (HAdd.hAdd n 1) → Real) (Fin (HAdd.hAdd n 1) → E)\ns : Set (Fin (HAdd.hAdd n 1) → Real)\nhs : s.Countable\nHs : ∀ (x : Fin (HAdd.hAdd n 1) → Real), Membership.mem s x → ContinuousWithinAt f (BoxIntegral.Box.Icc I) x\nHd : ∀ (x : Fin (HAdd.hAdd n 1) → Real), Membership.mem (SDiff.sdiff (BoxIntegral.Box.Icc I) s) x → HasFDerivWithinAt f (f' x) (BoxIntegral.Box.Icc I) x\n⊢ BoxIntegral.HasIntegral I BoxIntegral.IntegrationParams.GP (fun x => Finset.univ.sum fun i => (f' x) (Pi.single i 1) i) BoxIntegral.BoxAdditiveMap.volume (Finset.univ.sum fun i => HSub.hSub (BoxIntegral.integral (I.face i) BoxIntegral.IntegrationParams.GP (fun x => f (i.insertNth (I.upper i) x) i) BoxIntegral.BoxAdditiveMap.volume) (BoxIntegral.integral (I.face i) BoxIntegral.IntegrationParams.GP (fun x => f (i.insertNth (I.lower i) x) i) BoxIntegral.BoxAdditiveMap.volume))","decl":"/-- Divergence theorem for a Henstock-Kurzweil style integral.\n\nIf `f : ℝⁿ⁺¹ → Eⁿ⁺¹` is differentiable on a closed rectangular box `I` with derivative `f'`, then\nthe divergence `∑ i, f' x (Pi.single i 1) i` is Henstock-Kurzweil integrable with integral equal to\nthe sum of integrals of `f` over the faces of `I` taken with appropriate signs.\n\nMore precisely, we use a non-standard generalization of the Henstock-Kurzweil integral and\nwe allow `f` to be non-differentiable (but still continuous) at a countable set of points. -/\ntheorem hasIntegral_GP_divergence_of_forall_hasDerivWithinAt\n    (f : (Fin (n + 1) → ℝ) → Fin (n + 1) → E)\n    (f' : (Fin (n + 1) → ℝ) → (Fin (n + 1) → ℝ) →L[ℝ] (Fin (n + 1) → E))\n    (s : Set (Fin (n + 1) → ℝ)) (hs : s.Countable)\n    (Hs : ∀ x ∈ s, ContinuousWithinAt f (Box.Icc I) x)\n    (Hd : ∀ x ∈ (Box.Icc I) \\ s, HasFDerivWithinAt f (f' x) (Box.Icc I) x) :\n    HasIntegral.{0, u, u} I GP (fun x => ∑ i, f' x (Pi.single i 1) i) BoxAdditiveMap.volume\n      (∑ i,\n        (integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.upper i) x) i)\n            BoxAdditiveMap.volume -\n          integral.{0, u, u} (I.face i) GP (fun x => f (i.insertNth (I.lower i) x) i)\n            BoxAdditiveMap.volume)) := by\n  refine HasIntegral.sum fun i _ => ?_\n  simp only [hasFDerivWithinAt_pi', continuousWithinAt_pi] at Hd Hs\n  exact hasIntegral_GP_pderiv I _ _ s hs (fun x hx => Hs x hx i) (fun x hx => Hd x hx i) i\n\n"}
