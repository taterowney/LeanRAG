{"name":"TopCat.Presheaf.stalkFunctor_obj","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\n‚Ñ± : TopCat.Presheaf C X\nx : ‚ÜëX\n‚ä¢ Eq ((TopCat.Presheaf.stalkFunctor C x).obj ‚Ñ±) (‚Ñ±.stalk x)","decl":"@[simp]\ntheorem stalkFunctor_obj (‚Ñ± : X.Presheaf C) (x : X) : (stalkFunctor C x).obj ‚Ñ± = ‚Ñ±.stalk x :=\n  rfl\n\n"}
{"name":"TopCat.Presheaf.germ_res_assoc","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF : TopCat.Presheaf C X\nU V : TopologicalSpace.Opens ‚ÜëX\ni : Quiver.Hom U V\nx : ‚ÜëX\nhx : Membership.mem U x\nZ : C\nh : Quiver.Hom (F.stalk x) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map i.op) (CategoryTheory.CategoryStruct.comp (F.germ U x hx) h)) (CategoryTheory.CategoryStruct.comp (F.germ V x ‚ãØ) h)","decl":"@[reassoc]\ntheorem germ_res (F : X.Presheaf C) {U V : Opens X} (i : U ‚ü∂ V) (x : X) (hx : x ‚àà U) :\n    F.map i.op ‚â´ F.germ U x hx = F.germ V x (i.le hx) :=\n  let i' : (‚ü®U, hx‚ü© : OpenNhds x) ‚ü∂ ‚ü®V, i.le hx‚ü© := i\n  colimit.w ((OpenNhds.inclusion x).op ‚ãô F) i'.op\n\n"}
{"name":"TopCat.Presheaf.germ_res","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF : TopCat.Presheaf C X\nU V : TopologicalSpace.Opens ‚ÜëX\ni : Quiver.Hom U V\nx : ‚ÜëX\nhx : Membership.mem U x\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map i.op) (F.germ U x hx)) (F.germ V x ‚ãØ)","decl":"@[reassoc]\ntheorem germ_res (F : X.Presheaf C) {U V : Opens X} (i : U ‚ü∂ V) (x : X) (hx : x ‚àà U) :\n    F.map i.op ‚â´ F.germ U x hx = F.germ V x (i.le hx) :=\n  let i' : (‚ü®U, hx‚ü© : OpenNhds x) ‚ü∂ ‚ü®V, i.le hx‚ü© := i\n  colimit.w ((OpenNhds.inclusion x).op ‚ãô F) i'.op\n\n"}
{"name":"TopCat.Presheaf.germ_res'_assoc","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF : TopCat.Presheaf C X\nU V : TopologicalSpace.Opens ‚ÜëX\ni : Quiver.Hom { unop := V } { unop := U }\nx : ‚ÜëX\nhx : Membership.mem U x\nZ : C\nh : Quiver.Hom (F.stalk x) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map i) (CategoryTheory.CategoryStruct.comp (F.germ U x hx) h)) (CategoryTheory.CategoryStruct.comp (F.germ V x ‚ãØ) h)","decl":"/-- A variant of `germ_res` with `op V ‚ü∂ op U`\nso that the LHS is more general and simp fires more easier. -/\n@[reassoc (attr := simp)]\ntheorem germ_res' (F : X.Presheaf C) {U V : Opens X} (i : op V ‚ü∂ op U) (x : X) (hx : x ‚àà U) :\n    F.map i ‚â´ F.germ U x hx = F.germ V x (i.unop.le hx) :=\n  let i' : (‚ü®U, hx‚ü© : OpenNhds x) ‚ü∂ ‚ü®V, i.unop.le hx‚ü© := i.unop\n  colimit.w ((OpenNhds.inclusion x).op ‚ãô F) i'.op\n\n"}
{"name":"TopCat.Presheaf.germ_res'","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF : TopCat.Presheaf C X\nU V : TopologicalSpace.Opens ‚ÜëX\ni : Quiver.Hom { unop := V } { unop := U }\nx : ‚ÜëX\nhx : Membership.mem U x\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map i) (F.germ U x hx)) (F.germ V x ‚ãØ)","decl":"/-- A variant of `germ_res` with `op V ‚ü∂ op U`\nso that the LHS is more general and simp fires more easier. -/\n@[reassoc (attr := simp)]\ntheorem germ_res' (F : X.Presheaf C) {U V : Opens X} (i : op V ‚ü∂ op U) (x : X) (hx : x ‚àà U) :\n    F.map i ‚â´ F.germ U x hx = F.germ V x (i.unop.le hx) :=\n  let i' : (‚ü®U, hx‚ü© : OpenNhds x) ‚ü∂ ‚ü®V, i.unop.le hx‚ü© := i.unop\n  colimit.w ((OpenNhds.inclusion x).op ‚ãô F) i'.op\n\n"}
{"name":"TopCat.Presheaf.map_germ_eq_Œìgerm","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF : TopCat.Presheaf C X\nU : TopologicalSpace.Opens ‚ÜëX\ni : Quiver.Hom U Top.top\nx : ‚ÜëX\nhx : Membership.mem U x\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map i.op) (F.germ U x hx)) (F.Œìgerm x)","decl":"@[reassoc]\nlemma map_germ_eq_Œìgerm (F : X.Presheaf C) {U : Opens X} {i : U ‚ü∂ ‚ä§} (x : X) (hx : x ‚àà U) :\n    F.map i.op ‚â´ F.germ U x hx = F.Œìgerm x :=\n  germ_res F i x hx\n\n"}
{"name":"TopCat.Presheaf.map_germ_eq_Œìgerm_assoc","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF : TopCat.Presheaf C X\nU : TopologicalSpace.Opens ‚ÜëX\ni : Quiver.Hom U Top.top\nx : ‚ÜëX\nhx : Membership.mem U x\nZ : C\nh : Quiver.Hom (F.stalk x) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map i.op) (CategoryTheory.CategoryStruct.comp (F.germ U x hx) h)) (CategoryTheory.CategoryStruct.comp (F.Œìgerm x) h)","decl":"@[reassoc]\nlemma map_germ_eq_Œìgerm (F : X.Presheaf C) {U : Opens X} {i : U ‚ü∂ ‚ä§} (x : X) (hx : x ‚àà U) :\n    F.map i.op ‚â´ F.germ U x hx = F.Œìgerm x :=\n  germ_res F i x hx\n\n"}
{"name":"TopCat.Presheaf.germ_res_apply","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF : TopCat.Presheaf C X\nU V : TopologicalSpace.Opens ‚ÜëX\ni : Quiver.Hom U V\nx : ‚ÜëX\nhx : Membership.mem U x\ninst‚úù : CategoryTheory.HasForget C\ns : (CategoryTheory.forget C).obj (F.obj { unop := V })\n‚ä¢ Eq ((F.germ U x hx) ((F.map i.op) s)) ((F.germ V x ‚ãØ) s)","decl":"attribute [local instance] HasForget.instFunLike in\ntheorem germ_res_apply (F : X.Presheaf C)\n    {U V : Opens X} (i : U ‚ü∂ V) (x : X) (hx : x ‚àà U) [HasForget C] (s) :\n    F.germ U x hx (F.map i.op s) = F.germ V x (i.le hx) s := by\n  rw [‚Üê CategoryTheory.comp_apply, germ_res]\n\n"}
{"name":"TopCat.Presheaf.germ_res_apply'","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF : TopCat.Presheaf C X\nU V : TopologicalSpace.Opens ‚ÜëX\ni : Quiver.Hom { unop := V } { unop := U }\nx : ‚ÜëX\nhx : Membership.mem U x\ninst‚úù : CategoryTheory.HasForget C\ns : (CategoryTheory.forget C).obj (F.obj { unop := V })\n‚ä¢ Eq ((F.germ U x hx) ((F.map i) s)) ((F.germ V x ‚ãØ) s)","decl":"attribute [local instance] HasForget.instFunLike in\ntheorem germ_res_apply' (F : X.Presheaf C)\n    {U V : Opens X} (i : op V ‚ü∂ op U) (x : X) (hx : x ‚àà U) [HasForget C] (s) :\n    F.germ U x hx (F.map i s) = F.germ V x (i.unop.le hx) s := by\n  rw [‚Üê CategoryTheory.comp_apply, germ_res']\n\n"}
{"name":"TopCat.Presheaf.Œìgerm_res_apply","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF : TopCat.Presheaf C X\nU : TopologicalSpace.Opens ‚ÜëX\ni : Quiver.Hom U Top.top\nx : ‚ÜëX\nhx : Membership.mem U x\ninst‚úù : CategoryTheory.HasForget C\ns : (CategoryTheory.forget C).obj (F.obj { unop := Top.top })\n‚ä¢ Eq ((F.germ U x hx) ((F.map i.op) s)) ((F.Œìgerm x) s)","decl":"attribute [local instance] HasForget.instFunLike in\nlemma Œìgerm_res_apply (F : X.Presheaf C)\n    {U : Opens X} {i : U ‚ü∂ ‚ä§} (x : X) (hx : x ‚àà U) [HasForget C] (s) :\n  F.germ U x hx (F.map i.op s) = F.Œìgerm x s := F.germ_res_apply i x hx s\n\n"}
{"name":"TopCat.Presheaf.stalk_hom_ext_iff","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF : TopCat.Presheaf C X\nx : ‚ÜëX\nY : C\nf‚ÇÅ f‚ÇÇ : Quiver.Hom (F.stalk x) Y\n‚ä¢ Iff (Eq f‚ÇÅ f‚ÇÇ) (‚àÄ (U : TopologicalSpace.Opens ‚ÜëX) (hxU : Membership.mem U x), Eq (CategoryTheory.CategoryStruct.comp (F.germ U x hxU) f‚ÇÅ) (CategoryTheory.CategoryStruct.comp (F.germ U x hxU) f‚ÇÇ))","decl":"/-- A morphism from the stalk of `F` at `x` to some object `Y` is completely determined by its\ncomposition with the `germ` morphisms.\n-/\n@[ext]\ntheorem stalk_hom_ext (F : X.Presheaf C) {x} {Y : C} {f‚ÇÅ f‚ÇÇ : F.stalk x ‚ü∂ Y}\n    (ih : ‚àÄ (U : Opens X) (hxU : x ‚àà U), F.germ U x hxU ‚â´ f‚ÇÅ = F.germ U x hxU ‚â´ f‚ÇÇ) : f‚ÇÅ = f‚ÇÇ :=\n  colimit.hom_ext fun U => by\n    induction' U using Opposite.rec with U; cases' U with U hxU; exact ih U hxU\n\n"}
{"name":"TopCat.Presheaf.stalk_hom_ext","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF : TopCat.Presheaf C X\nx : ‚ÜëX\nY : C\nf‚ÇÅ f‚ÇÇ : Quiver.Hom (F.stalk x) Y\nih : ‚àÄ (U : TopologicalSpace.Opens ‚ÜëX) (hxU : Membership.mem U x), Eq (CategoryTheory.CategoryStruct.comp (F.germ U x hxU) f‚ÇÅ) (CategoryTheory.CategoryStruct.comp (F.germ U x hxU) f‚ÇÇ)\n‚ä¢ Eq f‚ÇÅ f‚ÇÇ","decl":"/-- A morphism from the stalk of `F` at `x` to some object `Y` is completely determined by its\ncomposition with the `germ` morphisms.\n-/\n@[ext]\ntheorem stalk_hom_ext (F : X.Presheaf C) {x} {Y : C} {f‚ÇÅ f‚ÇÇ : F.stalk x ‚ü∂ Y}\n    (ih : ‚àÄ (U : Opens X) (hxU : x ‚àà U), F.germ U x hxU ‚â´ f‚ÇÅ = F.germ U x hxU ‚â´ f‚ÇÇ) : f‚ÇÅ = f‚ÇÇ :=\n  colimit.hom_ext fun U => by\n    induction' U using Opposite.rec with U; cases' U with U hxU; exact ih U hxU\n\n"}
{"name":"TopCat.Presheaf.stalkFunctor_map_germ_assoc","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF G : TopCat.Presheaf C X\nU : TopologicalSpace.Opens ‚ÜëX\nx : ‚ÜëX\nhx : Membership.mem U x\nf : Quiver.Hom F G\nZ : C\nh : Quiver.Hom ((TopCat.Presheaf.stalkFunctor C x).obj G) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.germ U x hx) (CategoryTheory.CategoryStruct.comp ((TopCat.Presheaf.stalkFunctor C x).map f) h)) (CategoryTheory.CategoryStruct.comp (f.app { unop := U }) (CategoryTheory.CategoryStruct.comp (G.germ U x hx) h))","decl":"@[reassoc (attr := simp)]\ntheorem stalkFunctor_map_germ {F G : X.Presheaf C} (U : Opens X) (x : X) (hx : x ‚àà U) (f : F ‚ü∂ G) :\n    F.germ U x hx ‚â´ (stalkFunctor C x).map f = f.app (op U) ‚â´ G.germ U x hx :=\n  colimit.Œπ_map (whiskerLeft (OpenNhds.inclusion x).op f) (op ‚ü®U, hx‚ü©)\n\n"}
{"name":"TopCat.Presheaf.stalkFunctor_map_germ","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF G : TopCat.Presheaf C X\nU : TopologicalSpace.Opens ‚ÜëX\nx : ‚ÜëX\nhx : Membership.mem U x\nf : Quiver.Hom F G\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.germ U x hx) ((TopCat.Presheaf.stalkFunctor C x).map f)) (CategoryTheory.CategoryStruct.comp (f.app { unop := U }) (G.germ U x hx))","decl":"@[reassoc (attr := simp)]\ntheorem stalkFunctor_map_germ {F G : X.Presheaf C} (U : Opens X) (x : X) (hx : x ‚àà U) (f : F ‚ü∂ G) :\n    F.germ U x hx ‚â´ (stalkFunctor C x).map f = f.app (op U) ‚â´ G.germ U x hx :=\n  colimit.Œπ_map (whiskerLeft (OpenNhds.inclusion x).op f) (op ‚ü®U, hx‚ü©)\n\n"}
{"name":"TopCat.Presheaf.stalkFunctor_map_germ_apply","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasColimits C\nX : TopCat\ninst‚úù : CategoryTheory.HasForget C\nF G : TopCat.Presheaf C X\nU : TopologicalSpace.Opens ‚ÜëX\nx : ‚ÜëX\nhx : Membership.mem U x\nf : Quiver.Hom F G\ns : (CategoryTheory.forget C).obj (F.obj { unop := U })\n‚ä¢ Eq (((TopCat.Presheaf.stalkFunctor C x).map f) ((F.germ U x hx) s)) ((G.germ U x hx) ((f.app { unop := U }) s))","decl":"attribute [local instance] HasForget.instFunLike in\ntheorem stalkFunctor_map_germ_apply [HasForget C]\n    {F G : X.Presheaf C} (U : Opens X) (x : X) (hx : x ‚àà U) (f : F ‚ü∂ G) (s) :\n    (stalkFunctor C x).map f (F.germ U x hx s) = G.germ U x hx (f.app (op U) s) := by\n  rw [‚Üê CategoryTheory.comp_apply, ‚Üê stalkFunctor_map_germ]\n  exact (CategoryTheory.comp_apply _ _ _).symm\n\n-- a variant of `stalkFunctor_map_germ_apply` that makes simpNF happy.\n"}
{"name":"TopCat.Presheaf.stalkFunctor_map_germ_apply'","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasColimits C\nX : TopCat\ninst‚úù : CategoryTheory.HasForget C\nF G : TopCat.Presheaf C X\nU : TopologicalSpace.Opens ‚ÜëX\nx : ‚ÜëX\nhx : Membership.mem U x\nf : Quiver.Hom F G\ns : (CategoryTheory.forget C).obj (F.obj { unop := U })\n‚ä¢ Eq (((TopCat.Presheaf.stalkFunctor C x).map f) ((F.germ U x hx) s)) ((G.germ U x hx) ((f.app { unop := U }) s))","decl":"attribute [local instance] HasForget.instFunLike in\n@[simp]\ntheorem stalkFunctor_map_germ_apply' [HasForget C]\n    {F G : X.Presheaf C} (U : Opens X) (x : X) (hx : x ‚àà U) (f : F ‚ü∂ G) (s) :\n    DFunLike.coe (F := F.stalk x ‚ü∂ G.stalk x) ((stalkFunctor C x).map f) (F.germ U x hx s) =\n      G.germ U x hx (f.app (op U) s) :=\n  stalkFunctor_map_germ_apply U x hx f s\n\n"}
{"name":"TopCat.Presheaf.stalkPushforward_germ","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y : TopCat\nf : Quiver.Hom X Y\nF : TopCat.Presheaf C X\nU : TopologicalSpace.Opens ‚ÜëY\nx : ‚ÜëX\nhx : Membership.mem U (f x)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pushforward C f).obj F).germ U (f x) hx) (TopCat.Presheaf.stalkPushforward C f F x)) (F.germ ((TopologicalSpace.Opens.map f).obj U) x hx)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem stalkPushforward_germ (f : X ‚ü∂ Y) (F : X.Presheaf C) (U : Opens Y)\n    (x : X) (hx : f x ‚àà U) :\n      (f _* F).germ U (f x) hx ‚â´ F.stalkPushforward C f x = F.germ ((Opens.map f).obj U) x hx := by\n  simp [germ, stalkPushforward]\n\n-- Here are two other potential solutions, suggested by @fpvandoorn at\n-- <https://github.com/leanprover-community/mathlib/pull/1018#discussion_r283978240>\n-- However, I can't get the subsequent two proofs to work with either one.\n-- def stalkPushforward'' (f : X ‚ü∂ Y) (‚Ñ± : X.Presheaf C) (x : X) :\n--   (f _* ‚Ñ±).stalk (f x) ‚ü∂ ‚Ñ±.stalk x :=\n-- colim.map ((Functor.associator _ _ _).inv ‚â´\n--   whiskerRight (NatTrans.op (OpenNhds.inclusionMapIso f x).inv) ‚Ñ±) ‚â´\n-- colimit.pre ((OpenNhds.inclusion x).op ‚ãô ‚Ñ±) (OpenNhds.map f x).op\n-- def stalkPushforward''' (f : X ‚ü∂ Y) (‚Ñ± : X.Presheaf C) (x : X) :\n--   (f _* ‚Ñ±).stalk (f x) ‚ü∂ ‚Ñ±.stalk x :=\n-- (colim.map (whiskerRight (NatTrans.op (OpenNhds.inclusionMapIso f x).inv) ‚Ñ±) :\n--   colim.obj ((OpenNhds.inclusion (f x) ‚ãô Opens.map f).op ‚ãô ‚Ñ±) ‚ü∂ _) ‚â´\n-- colimit.pre ((OpenNhds.inclusion x).op ‚ãô ‚Ñ±) (OpenNhds.map f x).op\n\n"}
{"name":"TopCat.Presheaf.stalkPushforward_germ_apply","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y : TopCat\nf : Quiver.Hom X Y\nF : TopCat.Presheaf C X\nU : TopologicalSpace.Opens ‚ÜëY\nx‚úù : ‚ÜëX\nhx : Membership.mem U (f x‚úù)\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (((TopCat.Presheaf.pushforward C f).obj F).obj { unop := U })\n‚ä¢ Eq ((TopCat.Presheaf.stalkPushforward C f F x‚úù) ((((TopCat.Presheaf.pushforward C f).obj F).germ U (f x‚úù) hx) x)) ((F.germ ((TopologicalSpace.Opens.map f).obj U) x‚úù hx) x)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem stalkPushforward_germ (f : X ‚ü∂ Y) (F : X.Presheaf C) (U : Opens Y)\n    (x : X) (hx : f x ‚àà U) :\n      (f _* F).germ U (f x) hx ‚â´ F.stalkPushforward C f x = F.germ ((Opens.map f).obj U) x hx := by\n  simp [germ, stalkPushforward]\n\n-- Here are two other potential solutions, suggested by @fpvandoorn at\n-- <https://github.com/leanprover-community/mathlib/pull/1018#discussion_r283978240>\n-- However, I can't get the subsequent two proofs to work with either one.\n-- def stalkPushforward'' (f : X ‚ü∂ Y) (‚Ñ± : X.Presheaf C) (x : X) :\n--   (f _* ‚Ñ±).stalk (f x) ‚ü∂ ‚Ñ±.stalk x :=\n-- colim.map ((Functor.associator _ _ _).inv ‚â´\n--   whiskerRight (NatTrans.op (OpenNhds.inclusionMapIso f x).inv) ‚Ñ±) ‚â´\n-- colimit.pre ((OpenNhds.inclusion x).op ‚ãô ‚Ñ±) (OpenNhds.map f x).op\n-- def stalkPushforward''' (f : X ‚ü∂ Y) (‚Ñ± : X.Presheaf C) (x : X) :\n--   (f _* ‚Ñ±).stalk (f x) ‚ü∂ ‚Ñ±.stalk x :=\n-- (colim.map (whiskerRight (NatTrans.op (OpenNhds.inclusionMapIso f x).inv) ‚Ñ±) :\n--   colim.obj ((OpenNhds.inclusion (f x) ‚ãô Opens.map f).op ‚ãô ‚Ñ±) ‚ü∂ _) ‚â´\n-- colimit.pre ((OpenNhds.inclusion x).op ‚ãô ‚Ñ±) (OpenNhds.map f x).op\n\n"}
{"name":"TopCat.Presheaf.stalkPushforward_germ_assoc","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y : TopCat\nf : Quiver.Hom X Y\nF : TopCat.Presheaf C X\nU : TopologicalSpace.Opens ‚ÜëY\nx : ‚ÜëX\nhx : Membership.mem U (f x)\nZ : C\nh : Quiver.Hom (F.stalk x) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pushforward C f).obj F).germ U (f x) hx) (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.stalkPushforward C f F x) h)) (CategoryTheory.CategoryStruct.comp (F.germ ((TopologicalSpace.Opens.map f).obj U) x hx) h)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem stalkPushforward_germ (f : X ‚ü∂ Y) (F : X.Presheaf C) (U : Opens Y)\n    (x : X) (hx : f x ‚àà U) :\n      (f _* F).germ U (f x) hx ‚â´ F.stalkPushforward C f x = F.germ ((Opens.map f).obj U) x hx := by\n  simp [germ, stalkPushforward]\n\n-- Here are two other potential solutions, suggested by @fpvandoorn at\n-- <https://github.com/leanprover-community/mathlib/pull/1018#discussion_r283978240>\n-- However, I can't get the subsequent two proofs to work with either one.\n-- def stalkPushforward'' (f : X ‚ü∂ Y) (‚Ñ± : X.Presheaf C) (x : X) :\n--   (f _* ‚Ñ±).stalk (f x) ‚ü∂ ‚Ñ±.stalk x :=\n-- colim.map ((Functor.associator _ _ _).inv ‚â´\n--   whiskerRight (NatTrans.op (OpenNhds.inclusionMapIso f x).inv) ‚Ñ±) ‚â´\n-- colimit.pre ((OpenNhds.inclusion x).op ‚ãô ‚Ñ±) (OpenNhds.map f x).op\n-- def stalkPushforward''' (f : X ‚ü∂ Y) (‚Ñ± : X.Presheaf C) (x : X) :\n--   (f _* ‚Ñ±).stalk (f x) ‚ü∂ ‚Ñ±.stalk x :=\n-- (colim.map (whiskerRight (NatTrans.op (OpenNhds.inclusionMapIso f x).inv) ‚Ñ±) :\n--   colim.obj ((OpenNhds.inclusion (f x) ‚ãô Opens.map f).op ‚ãô ‚Ñ±) ‚ü∂ _) ‚â´\n-- colimit.pre ((OpenNhds.inclusion x).op ‚ãô ‚Ñ±) (OpenNhds.map f x).op\n\n"}
{"name":"TopCat.Presheaf.stalkPushforward.id","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\n‚Ñ± : TopCat.Presheaf C X\nx : ‚ÜëX\n‚ä¢ Eq (TopCat.Presheaf.stalkPushforward C (CategoryTheory.CategoryStruct.id X) ‚Ñ± x) ((TopCat.Presheaf.stalkFunctor C x).map (TopCat.Presheaf.Pushforward.id ‚Ñ±).hom)","decl":"@[simp]\ntheorem id (‚Ñ± : X.Presheaf C) (x : X) :\n    ‚Ñ±.stalkPushforward C (ùüô X) x = (stalkFunctor C x).map (Pushforward.id ‚Ñ±).hom := by\n  ext\n  simp only [stalkPushforward, germ, colim_map, Œπ_colimMap_assoc, whiskerRight_app]\n  erw [CategoryTheory.Functor.map_id]\n  simp [stalkFunctor]\n\n"}
{"name":"TopCat.Presheaf.stalkPushforward.comp","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y Z : TopCat\n‚Ñ± : TopCat.Presheaf C X\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nx : ‚ÜëX\n‚ä¢ Eq (TopCat.Presheaf.stalkPushforward C (CategoryTheory.CategoryStruct.comp f g) ‚Ñ± x) (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.stalkPushforward C g ((TopCat.Presheaf.pushforward C f).obj ‚Ñ±) (f x)) (TopCat.Presheaf.stalkPushforward C f ‚Ñ± x))","decl":"@[simp]\ntheorem comp (‚Ñ± : X.Presheaf C) (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : X) :\n    ‚Ñ±.stalkPushforward C (f ‚â´ g) x =\n      (f _* ‚Ñ±).stalkPushforward C g (f x) ‚â´ ‚Ñ±.stalkPushforward C f x := by\n  ext\n  simp [germ, stalkPushforward]\n\n"}
{"name":"TopCat.Presheaf.stalkPushforward.stalkPushforward_iso_of_isInducing","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y : TopCat\nf : Quiver.Hom X Y\nhf : Topology.IsInducing ‚áëf\nF : TopCat.Presheaf C X\nx : ‚ÜëX\n‚ä¢ CategoryTheory.IsIso (TopCat.Presheaf.stalkPushforward C f F x)","decl":"theorem stalkPushforward_iso_of_isInducing {f : X ‚ü∂ Y} (hf : IsInducing f)\n    (F : X.Presheaf C) (x : X) : IsIso (F.stalkPushforward _ f x) := by\n  haveI := Functor.initial_of_adjunction (hf.adjunctionNhds x)\n  convert (Functor.Final.colimitIso (OpenNhds.map f x).op ((OpenNhds.inclusion x).op ‚ãô F)).isIso_hom\n  refine stalk_hom_ext _ fun U hU ‚Ü¶ (stalkPushforward_germ _ f F _ x hU).trans ?_\n  symm\n  exact colimit.Œπ_pre ((OpenNhds.inclusion x).op ‚ãô F) (OpenNhds.map f x).op _\n\n"}
{"name":"TopCat.Presheaf.stalkPushforward.stalkPushforward_iso_of_isOpenEmbedding","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y : TopCat\nf : Quiver.Hom X Y\nhf : Topology.IsInducing ‚áëf\nF : TopCat.Presheaf C X\nx : ‚ÜëX\n‚ä¢ CategoryTheory.IsIso (TopCat.Presheaf.stalkPushforward C f F x)","decl":"@[deprecated (since := \"2024-10-27\")]\nalias stalkPushforward_iso_of_isOpenEmbedding := stalkPushforward_iso_of_isInducing\n"}
{"name":"TopCat.Presheaf.stalkPushforward.stalkPushforward_iso_of_openEmbedding","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y : TopCat\nf : Quiver.Hom X Y\nhf : Topology.IsInducing ‚áëf\nF : TopCat.Presheaf C X\nx : ‚ÜëX\n‚ä¢ CategoryTheory.IsIso (TopCat.Presheaf.stalkPushforward C f F x)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias stalkPushforward_iso_of_openEmbedding := stalkPushforward_iso_of_isInducing\n\n"}
{"name":"TopCat.Presheaf.germ_stalkPullbackHom_assoc","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y : TopCat\nf : Quiver.Hom X Y\nF : TopCat.Presheaf C Y\nx : ‚ÜëX\nU : TopologicalSpace.Opens ‚ÜëY\nhU : Membership.mem U (f x)\nZ : C\nh : Quiver.Hom (((TopCat.Presheaf.pullback C f).obj F).stalk x) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.germ U (f x) hU) (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.stalkPullbackHom C f F x) h)) (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pushforwardPullbackAdjunction C f).unit.app F).app { unop := U }) (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pullback C f).obj F).germ ((TopologicalSpace.Opens.map f).obj U) x hU) h))","decl":"@[reassoc (attr := simp)]\nlemma germ_stalkPullbackHom\n    (f : X ‚ü∂ Y) (F : Y.Presheaf C) (x : X) (U : Opens Y) (hU : f x ‚àà U) :\n    F.germ U (f x) hU ‚â´ stalkPullbackHom C f F x =\n      ((pushforwardPullbackAdjunction C f).unit.app F).app _ ‚â´\n        ((pullback C f).obj F).germ ((Opens.map f).obj U) x hU := by\n  simp [stalkPullbackHom, germ, stalkFunctor, stalkPushforward]\n\n"}
{"name":"TopCat.Presheaf.germ_stalkPullbackHom","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y : TopCat\nf : Quiver.Hom X Y\nF : TopCat.Presheaf C Y\nx : ‚ÜëX\nU : TopologicalSpace.Opens ‚ÜëY\nhU : Membership.mem U (f x)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.germ U (f x) hU) (TopCat.Presheaf.stalkPullbackHom C f F x)) (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pushforwardPullbackAdjunction C f).unit.app F).app { unop := U }) (((TopCat.Presheaf.pullback C f).obj F).germ ((TopologicalSpace.Opens.map f).obj U) x hU))","decl":"@[reassoc (attr := simp)]\nlemma germ_stalkPullbackHom\n    (f : X ‚ü∂ Y) (F : Y.Presheaf C) (x : X) (U : Opens Y) (hU : f x ‚àà U) :\n    F.germ U (f x) hU ‚â´ stalkPullbackHom C f F x =\n      ((pushforwardPullbackAdjunction C f).unit.app F).app _ ‚â´\n        ((pullback C f).obj F).germ ((Opens.map f).obj U) x hU := by\n  simp [stalkPullbackHom, germ, stalkFunctor, stalkPushforward]\n\n"}
{"name":"TopCat.Presheaf.pullback_obj_obj_ext","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y : TopCat\nZ : C\nf : Quiver.Hom X Y\nF : TopCat.Presheaf C Y\nU : Opposite (TopologicalSpace.Opens ‚ÜëX)\nœÜ œà : Quiver.Hom (((TopCat.Presheaf.pullback C f).obj F).obj U) Z\nh : ‚àÄ (V : TopologicalSpace.Opens ‚ÜëY) (hV : LE.le (Opposite.unop U) ((TopologicalSpace.Opens.map f).obj V)), Eq (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pushforwardPullbackAdjunction C f).unit.app F).app { unop := V }) (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pullback C f).obj F).map (CategoryTheory.homOfLE hV).op) œÜ)) (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pushforwardPullbackAdjunction C f).unit.app F).app { unop := V }) (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pullback C f).obj F).map (CategoryTheory.homOfLE hV).op) œà))\n‚ä¢ Eq œÜ œà","decl":"variable {C} in\n@[ext]\nlemma pullback_obj_obj_ext {Z : C} {f : X ‚ü∂ Y} {F : Y.Presheaf C} (U : (Opens X)·µí·µñ)\n    {œÜ œà : ((pullback C f).obj F).obj U ‚ü∂ Z}\n    (h : ‚àÄ (V : Opens Y) (hV : U.unop ‚â§ (Opens.map f).obj V),\n      ((pushforwardPullbackAdjunction C f).unit.app F).app (op V) ‚â´\n        ((pullback C f).obj F).map (homOfLE hV).op ‚â´ œÜ =\n      ((pushforwardPullbackAdjunction C f).unit.app F).app (op V) ‚â´\n        ((pullback C f).obj F).map (homOfLE hV).op ‚â´ œà) : œÜ = œà := by\n  obtain ‚ü®U‚ü© := U\n  apply ((Opens.map f).op.isPointwiseLeftKanExtensionLeftKanExtensionUnit F _).hom_ext\n  rintro ‚ü®‚ü®V‚ü©, ‚ü®‚ü©, ‚ü®b‚ü©‚ü©\n  simpa [pushforwardPullbackAdjunction, Functor.lanAdjunction_unit]\n    using h V (leOfHom b)\n\n"}
{"name":"TopCat.Presheaf.pullback_obj_obj_ext_iff","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y : TopCat\nZ : C\nf : Quiver.Hom X Y\nF : TopCat.Presheaf C Y\nU : Opposite (TopologicalSpace.Opens ‚ÜëX)\nœÜ œà : Quiver.Hom (((TopCat.Presheaf.pullback C f).obj F).obj U) Z\n‚ä¢ Iff (Eq œÜ œà) (‚àÄ (V : TopologicalSpace.Opens ‚ÜëY) (hV : LE.le (Opposite.unop U) ((TopologicalSpace.Opens.map f).obj V)), Eq (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pushforwardPullbackAdjunction C f).unit.app F).app { unop := V }) (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pullback C f).obj F).map (CategoryTheory.homOfLE hV).op) œÜ)) (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pushforwardPullbackAdjunction C f).unit.app F).app { unop := V }) (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pullback C f).obj F).map (CategoryTheory.homOfLE hV).op) œà)))","decl":"variable {C} in\n@[ext]\nlemma pullback_obj_obj_ext {Z : C} {f : X ‚ü∂ Y} {F : Y.Presheaf C} (U : (Opens X)·µí·µñ)\n    {œÜ œà : ((pullback C f).obj F).obj U ‚ü∂ Z}\n    (h : ‚àÄ (V : Opens Y) (hV : U.unop ‚â§ (Opens.map f).obj V),\n      ((pushforwardPullbackAdjunction C f).unit.app F).app (op V) ‚â´\n        ((pullback C f).obj F).map (homOfLE hV).op ‚â´ œÜ =\n      ((pushforwardPullbackAdjunction C f).unit.app F).app (op V) ‚â´\n        ((pullback C f).obj F).map (homOfLE hV).op ‚â´ œà) : œÜ = œà := by\n  obtain ‚ü®U‚ü© := U\n  apply ((Opens.map f).op.isPointwiseLeftKanExtensionLeftKanExtensionUnit F _).hom_ext\n  rintro ‚ü®‚ü®V‚ü©, ‚ü®‚ü©, ‚ü®b‚ü©‚ü©\n  simpa [pushforwardPullbackAdjunction, Functor.lanAdjunction_unit]\n    using h V (leOfHom b)\n\n"}
{"name":"TopCat.Presheaf.pushforwardPullbackAdjunction_unit_pullback_map_germToPullbackStalk_assoc","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y : TopCat\nf : Quiver.Hom X Y\nF : TopCat.Presheaf C Y\nU : TopologicalSpace.Opens ‚ÜëX\nx : ‚ÜëX\nhx : Membership.mem U x\nV : TopologicalSpace.Opens ‚ÜëY\nhV : LE.le U ((TopologicalSpace.Opens.map f).obj V)\nZ : C\nh : Quiver.Hom (F.stalk (f x)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pushforwardPullbackAdjunction C f).unit.app F).app { unop := V }) (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pullback C f).obj F).map (CategoryTheory.homOfLE hV).op) (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.germToPullbackStalk C f F U x hx) h))) (CategoryTheory.CategoryStruct.comp (F.germ V (f x) ‚ãØ) h)","decl":"@[reassoc (attr := simp)]\nlemma pushforwardPullbackAdjunction_unit_pullback_map_germToPullbackStalk\n    (f : X ‚ü∂ Y) (F : Y.Presheaf C) (U : Opens X) (x : X) (hx : x ‚àà U) (V : Opens Y)\n    (hV : U ‚â§ (Opens.map f).obj V) :\n    ((pushforwardPullbackAdjunction C f).unit.app F).app (op V) ‚â´\n      ((pullback C f).obj F).map (homOfLE hV).op ‚â´ germToPullbackStalk C f F U x hx  =\n        F.germ _ (f x) (hV hx) := by\n  simpa [pushforwardPullbackAdjunction] using\n    ((Opens.map f).op.isPointwiseLeftKanExtensionLeftKanExtensionUnit F (op U)).fac _\n      (CostructuredArrow.mk (homOfLE hV).op)\n\n"}
{"name":"TopCat.Presheaf.pushforwardPullbackAdjunction_unit_pullback_map_germToPullbackStalk","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y : TopCat\nf : Quiver.Hom X Y\nF : TopCat.Presheaf C Y\nU : TopologicalSpace.Opens ‚ÜëX\nx : ‚ÜëX\nhx : Membership.mem U x\nV : TopologicalSpace.Opens ‚ÜëY\nhV : LE.le U ((TopologicalSpace.Opens.map f).obj V)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pushforwardPullbackAdjunction C f).unit.app F).app { unop := V }) (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pullback C f).obj F).map (CategoryTheory.homOfLE hV).op) (TopCat.Presheaf.germToPullbackStalk C f F U x hx))) (F.germ V (f x) ‚ãØ)","decl":"@[reassoc (attr := simp)]\nlemma pushforwardPullbackAdjunction_unit_pullback_map_germToPullbackStalk\n    (f : X ‚ü∂ Y) (F : Y.Presheaf C) (U : Opens X) (x : X) (hx : x ‚àà U) (V : Opens Y)\n    (hV : U ‚â§ (Opens.map f).obj V) :\n    ((pushforwardPullbackAdjunction C f).unit.app F).app (op V) ‚â´\n      ((pullback C f).obj F).map (homOfLE hV).op ‚â´ germToPullbackStalk C f F U x hx  =\n        F.germ _ (f x) (hV hx) := by\n  simpa [pushforwardPullbackAdjunction] using\n    ((Opens.map f).op.isPointwiseLeftKanExtensionLeftKanExtensionUnit F (op U)).fac _\n      (CostructuredArrow.mk (homOfLE hV).op)\n\n"}
{"name":"TopCat.Presheaf.germToPullbackStalk_stalkPullbackHom_assoc","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y : TopCat\nf : Quiver.Hom X Y\nF : TopCat.Presheaf C Y\nU : TopologicalSpace.Opens ‚ÜëX\nx : ‚ÜëX\nhx : Membership.mem U x\nZ : C\nh : Quiver.Hom (((TopCat.Presheaf.pullback C f).obj F).stalk x) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.germToPullbackStalk C f F U x hx) (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.stalkPullbackHom C f F x) h)) (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pullback C f).obj F).germ U x hx) h)","decl":"@[reassoc (attr := simp)]\nlemma germToPullbackStalk_stalkPullbackHom\n    (f : X ‚ü∂ Y) (F : Y.Presheaf C) (U : Opens X) (x : X) (hx : x ‚àà U) :\n    germToPullbackStalk C f F U x hx ‚â´ stalkPullbackHom C f F x =\n      ((pullback C f).obj F).germ _ x hx := by\n  ext V hV\n  dsimp\n  simp only [pushforwardPullbackAdjunction_unit_pullback_map_germToPullbackStalk_assoc,\n    germ_stalkPullbackHom, germ_res]\n\n"}
{"name":"TopCat.Presheaf.germToPullbackStalk_stalkPullbackHom","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y : TopCat\nf : Quiver.Hom X Y\nF : TopCat.Presheaf C Y\nU : TopologicalSpace.Opens ‚ÜëX\nx : ‚ÜëX\nhx : Membership.mem U x\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.germToPullbackStalk C f F U x hx) (TopCat.Presheaf.stalkPullbackHom C f F x)) (((TopCat.Presheaf.pullback C f).obj F).germ U x hx)","decl":"@[reassoc (attr := simp)]\nlemma germToPullbackStalk_stalkPullbackHom\n    (f : X ‚ü∂ Y) (F : Y.Presheaf C) (U : Opens X) (x : X) (hx : x ‚àà U) :\n    germToPullbackStalk C f F U x hx ‚â´ stalkPullbackHom C f F x =\n      ((pullback C f).obj F).germ _ x hx := by\n  ext V hV\n  dsimp\n  simp only [pushforwardPullbackAdjunction_unit_pullback_map_germToPullbackStalk_assoc,\n    germ_stalkPullbackHom, germ_res]\n\n"}
{"name":"TopCat.Presheaf.pushforwardPullbackAdjunction_unit_app_app_germToPullbackStalk_assoc","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y : TopCat\nf : Quiver.Hom X Y\nF : TopCat.Presheaf C Y\nV : Opposite (TopologicalSpace.Opens ‚ÜëY)\nx : ‚ÜëX\nhx : Membership.mem (Opposite.unop V) (f x)\nZ : C\nh : Quiver.Hom (F.stalk (f x)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pushforwardPullbackAdjunction C f).unit.app F).app V) (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.germToPullbackStalk C f F ((TopologicalSpace.Opens.map f).obj (Opposite.unop V)) x hx) h)) (CategoryTheory.CategoryStruct.comp (F.germ (Opposite.unop V) (f x) hx) h)","decl":"@[reassoc (attr := simp)]\nlemma pushforwardPullbackAdjunction_unit_app_app_germToPullbackStalk\n    (f : X ‚ü∂ Y) (F : Y.Presheaf C) (V : (Opens Y)·µí·µñ) (x : X) (hx : f x ‚àà V.unop) :\n    ((pushforwardPullbackAdjunction C f).unit.app F).app V ‚â´ germToPullbackStalk C f F _ x hx =\n      F.germ _ (f x) hx := by\n  simpa using pushforwardPullbackAdjunction_unit_pullback_map_germToPullbackStalk\n    C f F ((Opens.map f).obj V.unop) x hx V.unop (by rfl)\n\n"}
{"name":"TopCat.Presheaf.pushforwardPullbackAdjunction_unit_app_app_germToPullbackStalk","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y : TopCat\nf : Quiver.Hom X Y\nF : TopCat.Presheaf C Y\nV : Opposite (TopologicalSpace.Opens ‚ÜëY)\nx : ‚ÜëX\nhx : Membership.mem (Opposite.unop V) (f x)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pushforwardPullbackAdjunction C f).unit.app F).app V) (TopCat.Presheaf.germToPullbackStalk C f F ((TopologicalSpace.Opens.map f).obj (Opposite.unop V)) x hx)) (F.germ (Opposite.unop V) (f x) hx)","decl":"@[reassoc (attr := simp)]\nlemma pushforwardPullbackAdjunction_unit_app_app_germToPullbackStalk\n    (f : X ‚ü∂ Y) (F : Y.Presheaf C) (V : (Opens Y)·µí·µñ) (x : X) (hx : f x ‚àà V.unop) :\n    ((pushforwardPullbackAdjunction C f).unit.app F).app V ‚â´ germToPullbackStalk C f F _ x hx =\n      F.germ _ (f x) hx := by\n  simpa using pushforwardPullbackAdjunction_unit_pullback_map_germToPullbackStalk\n    C f F ((Opens.map f).obj V.unop) x hx V.unop (by rfl)\n\n"}
{"name":"TopCat.Presheaf.germ_stalkPullbackInv","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y : TopCat\nf : Quiver.Hom X Y\nF : TopCat.Presheaf C Y\nx : ‚ÜëX\nV : TopologicalSpace.Opens ‚ÜëX\nhV : Membership.mem V x\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pullback C f).obj F).germ V x hV) (TopCat.Presheaf.stalkPullbackInv C f F x)) (TopCat.Presheaf.germToPullbackStalk C f F V x hV)","decl":"@[reassoc (attr := simp)]\nlemma germ_stalkPullbackInv (f : X ‚ü∂ Y) (F : Y.Presheaf C) (x : X) (V : Opens X) (hV : x ‚àà V) :\n    ((pullback C f).obj F).germ _ x hV ‚â´ stalkPullbackInv C f F x =\n    F.germToPullbackStalk _ f V x hV := by\n  apply colimit.Œπ_desc\n\n"}
{"name":"TopCat.Presheaf.germ_stalkPullbackInv_assoc","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y : TopCat\nf : Quiver.Hom X Y\nF : TopCat.Presheaf C Y\nx : ‚ÜëX\nV : TopologicalSpace.Opens ‚ÜëX\nhV : Membership.mem V x\nZ : C\nh : Quiver.Hom (F.stalk (f x)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pullback C f).obj F).germ V x hV) (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.stalkPullbackInv C f F x) h)) (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.germToPullbackStalk C f F V x hV) h)","decl":"@[reassoc (attr := simp)]\nlemma germ_stalkPullbackInv (f : X ‚ü∂ Y) (F : Y.Presheaf C) (x : X) (V : Opens X) (hV : x ‚àà V) :\n    ((pullback C f).obj F).germ _ x hV ‚â´ stalkPullbackInv C f F x =\n    F.germToPullbackStalk _ f V x hV := by\n  apply colimit.Œπ_desc\n\n"}
{"name":"TopCat.Presheaf.germ_stalkSpecializes_assoc","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF : TopCat.Presheaf C X\nU : TopologicalSpace.Opens ‚ÜëX\ny : ‚ÜëX\nhy : Membership.mem U y\nx : ‚ÜëX\nh‚úù : Specializes x y\nZ : C\nh : Quiver.Hom (F.stalk x) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.germ U y hy) (CategoryTheory.CategoryStruct.comp (F.stalkSpecializes h‚úù) h)) (CategoryTheory.CategoryStruct.comp (F.germ U x ‚ãØ) h)","decl":"@[reassoc (attr := simp), elementwise nosimp]\ntheorem germ_stalkSpecializes (F : X.Presheaf C)\n    {U : Opens X} {y : X} (hy : y ‚àà U) {x : X} (h : x ‚§≥ y) :\n    F.germ U y hy ‚â´ F.stalkSpecializes h = F.germ U x (h.mem_open U.isOpen hy) :=\n  colimit.Œπ_desc _ _\n\n"}
{"name":"TopCat.Presheaf.germ_stalkSpecializes","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF : TopCat.Presheaf C X\nU : TopologicalSpace.Opens ‚ÜëX\ny : ‚ÜëX\nhy : Membership.mem U y\nx : ‚ÜëX\nh : Specializes x y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.germ U y hy) (F.stalkSpecializes h)) (F.germ U x ‚ãØ)","decl":"@[reassoc (attr := simp), elementwise nosimp]\ntheorem germ_stalkSpecializes (F : X.Presheaf C)\n    {U : Opens X} {y : X} (hy : y ‚àà U) {x : X} (h : x ‚§≥ y) :\n    F.germ U y hy ‚â´ F.stalkSpecializes h = F.germ U x (h.mem_open U.isOpen hy) :=\n  colimit.Œπ_desc _ _\n\n"}
{"name":"TopCat.Presheaf.germ_stalkSpecializes_apply","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF : TopCat.Presheaf C X\nU : TopologicalSpace.Opens ‚ÜëX\ny : ‚ÜëX\nhy : Membership.mem U y\nx‚úù : ‚ÜëX\nh : Specializes x‚úù y\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (F.obj { unop := U })\n‚ä¢ Eq ((F.stalkSpecializes h) ((F.germ U y hy) x)) ((F.germ U x‚úù ‚ãØ) x)","decl":"@[reassoc (attr := simp), elementwise nosimp]\ntheorem germ_stalkSpecializes (F : X.Presheaf C)\n    {U : Opens X} {y : X} (hy : y ‚àà U) {x : X} (h : x ‚§≥ y) :\n    F.germ U y hy ‚â´ F.stalkSpecializes h = F.germ U x (h.mem_open U.isOpen hy) :=\n  colimit.Œπ_desc _ _\n\n"}
{"name":"TopCat.Presheaf.stalkSpecializes_refl","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF : TopCat.Presheaf C X\nx : ‚ÜëX\n‚ä¢ Eq (F.stalkSpecializes ‚ãØ) (CategoryTheory.CategoryStruct.id (F.stalk x))","decl":"@[simp]\ntheorem stalkSpecializes_refl {C : Type*} [Category C] [Limits.HasColimits C] {X : TopCat}\n    (F : X.Presheaf C) (x : X) : F.stalkSpecializes (specializes_refl x) = ùüô _ := by\n  ext\n  simp\n\n"}
{"name":"TopCat.Presheaf.stalkSpecializes_comp_assoc","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF : TopCat.Presheaf C X\nx y z : ‚ÜëX\nh‚úù : Specializes x y\nh' : Specializes y z\nZ : C\nh : Quiver.Hom (F.stalk x) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.stalkSpecializes h') (CategoryTheory.CategoryStruct.comp (F.stalkSpecializes h‚úù) h)) (CategoryTheory.CategoryStruct.comp (F.stalkSpecializes ‚ãØ) h)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem stalkSpecializes_comp {C : Type*} [Category C] [Limits.HasColimits C] {X : TopCat}\n    (F : X.Presheaf C) {x y z : X} (h : x ‚§≥ y) (h' : y ‚§≥ z) :\n    F.stalkSpecializes h' ‚â´ F.stalkSpecializes h = F.stalkSpecializes (h.trans h') := by\n  ext\n  simp\n\n"}
{"name":"TopCat.Presheaf.stalkSpecializes_comp_apply","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF : TopCat.Presheaf C X\nx‚úù y z : ‚ÜëX\nh : Specializes x‚úù y\nh' : Specializes y z\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (F.stalk z)\n‚ä¢ Eq ((F.stalkSpecializes h) ((F.stalkSpecializes h') x)) ((F.stalkSpecializes ‚ãØ) x)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem stalkSpecializes_comp {C : Type*} [Category C] [Limits.HasColimits C] {X : TopCat}\n    (F : X.Presheaf C) {x y z : X} (h : x ‚§≥ y) (h' : y ‚§≥ z) :\n    F.stalkSpecializes h' ‚â´ F.stalkSpecializes h = F.stalkSpecializes (h.trans h') := by\n  ext\n  simp\n\n"}
{"name":"TopCat.Presheaf.stalkSpecializes_comp","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF : TopCat.Presheaf C X\nx y z : ‚ÜëX\nh : Specializes x y\nh' : Specializes y z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.stalkSpecializes h') (F.stalkSpecializes h)) (F.stalkSpecializes ‚ãØ)","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem stalkSpecializes_comp {C : Type*} [Category C] [Limits.HasColimits C] {X : TopCat}\n    (F : X.Presheaf C) {x y z : X} (h : x ‚§≥ y) (h' : y ‚§≥ z) :\n    F.stalkSpecializes h' ‚â´ F.stalkSpecializes h = F.stalkSpecializes (h.trans h') := by\n  ext\n  simp\n\n"}
{"name":"TopCat.Presheaf.stalkSpecializes_stalkFunctor_map_assoc","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF G : TopCat.Presheaf C X\nf : Quiver.Hom F G\nx y : ‚ÜëX\nh‚úù : Specializes x y\nZ : C\nh : Quiver.Hom ((TopCat.Presheaf.stalkFunctor C x).obj G) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.stalkSpecializes h‚úù) (CategoryTheory.CategoryStruct.comp ((TopCat.Presheaf.stalkFunctor C x).map f) h)) (CategoryTheory.CategoryStruct.comp ((TopCat.Presheaf.stalkFunctor C y).map f) (CategoryTheory.CategoryStruct.comp (G.stalkSpecializes h‚úù) h))","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem stalkSpecializes_stalkFunctor_map {F G : X.Presheaf C} (f : F ‚ü∂ G) {x y : X} (h : x ‚§≥ y) :\n    F.stalkSpecializes h ‚â´ (stalkFunctor C x).map f =\n      (stalkFunctor C y).map f ‚â´ G.stalkSpecializes h := by\n  change (_ : colimit _ ‚ü∂ _) = (_ : colimit _ ‚ü∂ _)\n  ext; delta stalkFunctor; simpa [stalkSpecializes] using by rfl\n\n-- See https://github.com/leanprover-community/batteries/issues/365 for the simpNF issue.\n"}
{"name":"TopCat.Presheaf.stalkSpecializes_stalkFunctor_map","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF G : TopCat.Presheaf C X\nf : Quiver.Hom F G\nx y : ‚ÜëX\nh : Specializes x y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.stalkSpecializes h) ((TopCat.Presheaf.stalkFunctor C x).map f)) (CategoryTheory.CategoryStruct.comp ((TopCat.Presheaf.stalkFunctor C y).map f) (G.stalkSpecializes h))","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem stalkSpecializes_stalkFunctor_map {F G : X.Presheaf C} (f : F ‚ü∂ G) {x y : X} (h : x ‚§≥ y) :\n    F.stalkSpecializes h ‚â´ (stalkFunctor C x).map f =\n      (stalkFunctor C y).map f ‚â´ G.stalkSpecializes h := by\n  change (_ : colimit _ ‚ü∂ _) = (_ : colimit _ ‚ü∂ _)\n  ext; delta stalkFunctor; simpa [stalkSpecializes] using by rfl\n\n-- See https://github.com/leanprover-community/batteries/issues/365 for the simpNF issue.\n"}
{"name":"TopCat.Presheaf.stalkSpecializes_stalkFunctor_map_apply","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX : TopCat\nF G : TopCat.Presheaf C X\nf : Quiver.Hom F G\nx‚úù y : ‚ÜëX\nh : Specializes x‚úù y\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (F.stalk y)\n‚ä¢ Eq (((TopCat.Presheaf.stalkFunctor C x‚úù).map f) ((F.stalkSpecializes h) x)) ((G.stalkSpecializes h) (((TopCat.Presheaf.stalkFunctor C y).map f) x))","decl":"@[reassoc (attr := simp), elementwise (attr := simp)]\ntheorem stalkSpecializes_stalkFunctor_map {F G : X.Presheaf C} (f : F ‚ü∂ G) {x y : X} (h : x ‚§≥ y) :\n    F.stalkSpecializes h ‚â´ (stalkFunctor C x).map f =\n      (stalkFunctor C y).map f ‚â´ G.stalkSpecializes h := by\n  change (_ : colimit _ ‚ü∂ _) = (_ : colimit _ ‚ü∂ _)\n  ext; delta stalkFunctor; simpa [stalkSpecializes] using by rfl\n\n-- See https://github.com/leanprover-community/batteries/issues/365 for the simpNF issue.\n"}
{"name":"TopCat.Presheaf.stalkSpecializes_stalkPushforward","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y : TopCat\nf : Quiver.Hom X Y\nF : TopCat.Presheaf C X\nx y : ‚ÜëX\nh : Specializes x y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pushforward C f).obj F).stalkSpecializes ‚ãØ) (TopCat.Presheaf.stalkPushforward C f F x)) (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.stalkPushforward C f F y) (F.stalkSpecializes h))","decl":"@[reassoc, elementwise, simp, nolint simpNF]\ntheorem stalkSpecializes_stalkPushforward (f : X ‚ü∂ Y) (F : X.Presheaf C) {x y : X} (h : x ‚§≥ y) :\n    (f _* F).stalkSpecializes (f.map_specializes h) ‚â´ F.stalkPushforward _ f x =\n      F.stalkPushforward _ f y ‚â´ F.stalkSpecializes h := by\n  change (_ : colimit _ ‚ü∂ _) = (_ : colimit _ ‚ü∂ _)\n  ext; delta stalkPushforward\n  simp only [stalkSpecializes, colimit.Œπ_desc_assoc, colimit.Œπ_map_assoc, colimit.Œπ_pre,\n    Category.assoc, colimit.pre_desc, colimit.Œπ_desc]\n  rfl\n\n"}
{"name":"TopCat.Presheaf.stalkSpecializes_stalkPushforward_assoc","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y : TopCat\nf : Quiver.Hom X Y\nF : TopCat.Presheaf C X\nx y : ‚ÜëX\nh‚úù : Specializes x y\nZ : C\nh : Quiver.Hom (F.stalk x) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (((TopCat.Presheaf.pushforward C f).obj F).stalkSpecializes ‚ãØ) (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.stalkPushforward C f F x) h)) (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.stalkPushforward C f F y) (CategoryTheory.CategoryStruct.comp (F.stalkSpecializes h‚úù) h))","decl":"@[reassoc, elementwise, simp, nolint simpNF]\ntheorem stalkSpecializes_stalkPushforward (f : X ‚ü∂ Y) (F : X.Presheaf C) {x y : X} (h : x ‚§≥ y) :\n    (f _* F).stalkSpecializes (f.map_specializes h) ‚â´ F.stalkPushforward _ f x =\n      F.stalkPushforward _ f y ‚â´ F.stalkSpecializes h := by\n  change (_ : colimit _ ‚ü∂ _) = (_ : colimit _ ‚ü∂ _)\n  ext; delta stalkPushforward\n  simp only [stalkSpecializes, colimit.Œπ_desc_assoc, colimit.Œπ_map_assoc, colimit.Œπ_pre,\n    Category.assoc, colimit.pre_desc, colimit.Œπ_desc]\n  rfl\n\n"}
{"name":"TopCat.Presheaf.stalkSpecializes_stalkPushforward_apply","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nX Y : TopCat\nf : Quiver.Hom X Y\nF : TopCat.Presheaf C X\nx‚úù y : ‚ÜëX\nh : Specializes x‚úù y\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (((TopCat.Presheaf.pushforward C f).obj F).stalk (f y))\n‚ä¢ Eq ((TopCat.Presheaf.stalkPushforward C f F x‚úù) ((((TopCat.Presheaf.pushforward C f).obj F).stalkSpecializes ‚ãØ) x)) ((F.stalkSpecializes h) ((TopCat.Presheaf.stalkPushforward C f F y) x))","decl":"@[reassoc, elementwise, simp, nolint simpNF]\ntheorem stalkSpecializes_stalkPushforward (f : X ‚ü∂ Y) (F : X.Presheaf C) {x y : X} (h : x ‚§≥ y) :\n    (f _* F).stalkSpecializes (f.map_specializes h) ‚â´ F.stalkPushforward _ f x =\n      F.stalkPushforward _ f y ‚â´ F.stalkSpecializes h := by\n  change (_ : colimit _ ‚ü∂ _) = (_ : colimit _ ‚ü∂ _)\n  ext; delta stalkPushforward\n  simp only [stalkSpecializes, colimit.Œπ_desc_assoc, colimit.Œπ_map_assoc, colimit.Œπ_pre,\n    Category.assoc, colimit.pre_desc, colimit.Œπ_desc]\n  rfl\n\n"}
{"name":"TopCat.Presheaf.stalkCongr_inv","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"X : TopCat\nC : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nF : TopCat.Presheaf C X\nx y : ‚ÜëX\ne : Inseparable x y\n‚ä¢ Eq (F.stalkCongr e).inv (F.stalkSpecializes ‚ãØ)","decl":"/-- The stalks are isomorphic on inseparable points -/\n@[simps]\ndef stalkCongr {X : TopCat} {C : Type*} [Category C] [HasColimits C] (F : X.Presheaf C) {x y : X}\n    (e : Inseparable x y) : F.stalk x ‚âÖ F.stalk y :=\n  ‚ü®F.stalkSpecializes e.ge, F.stalkSpecializes e.le, by simp, by simp‚ü©\n\n"}
{"name":"TopCat.Presheaf.stalkCongr_hom","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"X : TopCat\nC : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\nF : TopCat.Presheaf C X\nx y : ‚ÜëX\ne : Inseparable x y\n‚ä¢ Eq (F.stalkCongr e).hom (F.stalkSpecializes ‚ãØ)","decl":"/-- The stalks are isomorphic on inseparable points -/\n@[simps]\ndef stalkCongr {X : TopCat} {C : Type*} [Category C] [HasColimits C] (F : X.Presheaf C) {x y : X}\n    (e : Inseparable x y) : F.stalk x ‚âÖ F.stalk y :=\n  ‚ü®F.stalkSpecializes e.ge, F.stalkSpecializes e.le, by simp, by simp‚ü©\n\n"}
{"name":"TopCat.Presheaf.germ_ext","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasColimits C\nX : TopCat\ninst‚úù : CategoryTheory.HasForget C\nF : TopCat.Presheaf C X\nU V : TopologicalSpace.Opens ‚ÜëX\nx : ‚ÜëX\nhxU : Membership.mem U x\nhxV : Membership.mem V x\nW : TopologicalSpace.Opens ‚ÜëX\nhxW : Membership.mem W x\niWU : Quiver.Hom W U\niWV : Quiver.Hom W V\nsU : (CategoryTheory.forget C).obj (F.obj { unop := U })\nsV : (CategoryTheory.forget C).obj (F.obj { unop := V })\nih : Eq ((F.map iWU.op) sU) ((F.map iWV.op) sV)\n‚ä¢ Eq ((F.germ U x hxU) sU) ((F.germ V x hxV) sV)","decl":"theorem germ_ext (F : X.Presheaf C) {U V : Opens X} {x : X} {hxU : x ‚àà U} {hxV : x ‚àà V}\n    (W : Opens X) (hxW : x ‚àà W) (iWU : W ‚ü∂ U) (iWV : W ‚ü∂ V) {sU : F.obj (op U)} {sV : F.obj (op V)}\n    (ih : F.map iWU.op sU = F.map iWV.op sV) :\n      F.germ _ x hxU sU = F.germ _ x hxV sV := by\n  rw [‚Üê F.germ_res iWU x hxW, ‚Üê F.germ_res iWV x hxW, CategoryTheory.comp_apply,\n    CategoryTheory.comp_apply, ih]\n\n"}
{"name":"TopCat.Presheaf.germ_exist","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasColimits C\nX : TopCat\ninst‚úù¬π : CategoryTheory.HasForget C\ninst‚úù : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)\nF : TopCat.Presheaf C X\nx : ‚ÜëX\nt : (CategoryTheory.forget C).obj (F.stalk x)\n‚ä¢ Exists fun U => Exists fun m => Exists fun s => Eq ((F.germ U x m) s) t","decl":"/--\nFor presheaves valued in a concrete category whose forgetful functor preserves filtered colimits,\nevery element of the stalk is the germ of a section.\n-/\ntheorem germ_exist (F : X.Presheaf C) (x : X) (t : (stalk.{v, u} F x : Type v)) :\n    ‚àÉ (U : Opens X) (m : x ‚àà U) (s : F.obj (op U)), F.germ _ x m s = t := by\n  obtain ‚ü®U, s, e‚ü© :=\n    Types.jointly_surjective.{v, v} _ (isColimitOfPreserves (forget C) (colimit.isColimit _)) t\n  revert s e\n  induction U with | h U => ?_\n  cases' U with V m\n  intro s e\n  exact ‚ü®V, m, s, e‚ü©\n\n"}
{"name":"TopCat.Presheaf.germ_eq","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasColimits C\nX : TopCat\ninst‚úù¬π : CategoryTheory.HasForget C\ninst‚úù : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)\nF : TopCat.Presheaf C X\nU V : TopologicalSpace.Opens ‚ÜëX\nx : ‚ÜëX\nmU : Membership.mem U x\nmV : Membership.mem V x\ns : (CategoryTheory.forget C).obj (F.obj { unop := U })\nt : (CategoryTheory.forget C).obj (F.obj { unop := V })\nh : Eq ((F.germ U x mU) s) ((F.germ V x mV) t)\n‚ä¢ Exists fun W => Exists fun _m => Exists fun iU => Exists fun iV => Eq ((F.map iU.op) s) ((F.map iV.op) t)","decl":"theorem germ_eq (F : X.Presheaf C) {U V : Opens X} (x : X) (mU : x ‚àà U) (mV : x ‚àà V)\n    (s : F.obj (op U)) (t : F.obj (op V)) (h : F.germ U x mU s = F.germ V x mV t) :\n    ‚àÉ (W : Opens X) (_m : x ‚àà W) (iU : W ‚ü∂ U) (iV : W ‚ü∂ V), F.map iU.op s = F.map iV.op t := by\n  obtain ‚ü®W, iU, iV, e‚ü© :=\n    (Types.FilteredColimit.isColimit_eq_iff.{v, v} _\n          (isColimitOfPreserves _ (colimit.isColimit ((OpenNhds.inclusion x).op ‚ãô F)))).mp h\n  exact ‚ü®(unop W).1, (unop W).2, iU.unop, iV.unop, e‚ü©\n\n"}
{"name":"TopCat.Presheaf.stalkFunctor_map_injective_of_app_injective","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.Limits.HasColimits C\nX : TopCat\ninst‚úù¬π : CategoryTheory.HasForget C\ninst‚úù : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)\nF G : TopCat.Presheaf C X\nf : Quiver.Hom F G\nh : ‚àÄ (U : TopologicalSpace.Opens ‚ÜëX), Function.Injective ‚áë(f.app { unop := U })\nx : ‚ÜëX\n‚ä¢ Function.Injective ‚áë((TopCat.Presheaf.stalkFunctor C x).map f)","decl":"theorem stalkFunctor_map_injective_of_app_injective {F G : Presheaf C X} (f : F ‚ü∂ G)\n    (h : ‚àÄ U : Opens X, Function.Injective (f.app (op U))) (x : X) :\n    Function.Injective ((stalkFunctor C x).map f) := fun s t hst => by\n  rcases germ_exist F x s with ‚ü®U‚ÇÅ, hxU‚ÇÅ, s, rfl‚ü©\n  rcases germ_exist F x t with ‚ü®U‚ÇÇ, hxU‚ÇÇ, t, rfl‚ü©\n  rw [stalkFunctor_map_germ_apply, stalkFunctor_map_germ_apply] at hst\n  obtain ‚ü®W, hxW, iWU‚ÇÅ, iWU‚ÇÇ, heq‚ü© := G.germ_eq x hxU‚ÇÅ hxU‚ÇÇ _ _ hst\n  rw [‚Üê CategoryTheory.comp_apply, ‚Üê CategoryTheory.comp_apply, ‚Üê f.naturality, ‚Üê f.naturality,\n    CategoryTheory.comp_apply, CategoryTheory.comp_apply] at heq\n  replace heq := h W heq\n  convert congr_arg (F.germ _ x hxW) heq using 1\n  exacts [(F.germ_res_apply iWU‚ÇÅ x hxW s).symm, (F.germ_res_apply iWU‚ÇÇ x hxW t).symm]\n\n"}
{"name":"TopCat.Presheaf.section_ext","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasColimits C\nX : TopCat\ninst‚úù‚Å¥ : CategoryTheory.HasForget C\ninst‚úù¬≥ : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)\ninst‚úù¬≤ : CategoryTheory.Limits.HasLimits C\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)\ninst‚úù : (CategoryTheory.forget C).ReflectsIsomorphisms\nF : TopCat.Sheaf C X\nU : TopologicalSpace.Opens ‚ÜëX\ns t : (CategoryTheory.forget C).obj (F.val.obj { unop := U })\nh : ‚àÄ (x : ‚ÜëX) (hx : Membership.mem U x), Eq ((F.presheaf.germ U x hx) s) ((F.presheaf.germ U x hx) t)\n‚ä¢ Eq s t","decl":"/-- Let `F` be a sheaf valued in a concrete category, whose forgetful functor reflects isomorphisms,\npreserves limits and filtered colimits. Then two sections who agree on every stalk must be equal.\n-/\ntheorem section_ext (F : Sheaf C X) (U : Opens X) (s t : F.1.obj (op U))\n    (h : ‚àÄ (x : X) (hx : x ‚àà U), F.presheaf.germ U x hx s = F.presheaf.germ U x hx t) : s = t := by\n  -- We use `germ_eq` and the axiom of choice, to pick for every point `x` a neighbourhood\n  -- `V x`, such that the restrictions of `s` and `t` to `V x` coincide.\n  choose V m i‚ÇÅ i‚ÇÇ heq using fun x : U => F.presheaf.germ_eq x.1 x.2 x.2 s t (h x.1 x.2)\n  -- Since `F` is a sheaf, we can prove the equality locally, if we can show that these\n  -- neighborhoods form a cover of `U`.\n  apply F.eq_of_locally_eq' V U i‚ÇÅ\n  ¬∑ intro x hxU\n    simp only [Opens.coe_iSup, Set.mem_iUnion, SetLike.mem_coe]\n    exact ‚ü®‚ü®x, hxU‚ü©, m ‚ü®x, hxU‚ü©‚ü©\n  ¬∑ intro x\n    rw [heq, Subsingleton.elim (i‚ÇÅ x) (i‚ÇÇ x)]\n\n/-\nNote that the analogous statement for surjectivity is false: Surjectivity on stalks does not\nimply surjectivity of the components of a sheaf morphism. However it does imply that the morphism\nis an epi, but this fact is not yet formalized.\n-/\n"}
{"name":"TopCat.Presheaf.app_injective_of_stalkFunctor_map_injective","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasColimits C\nX : TopCat\ninst‚úù‚Å¥ : CategoryTheory.HasForget C\ninst‚úù¬≥ : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)\ninst‚úù¬≤ : CategoryTheory.Limits.HasLimits C\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)\ninst‚úù : (CategoryTheory.forget C).ReflectsIsomorphisms\nF : TopCat.Sheaf C X\nG : TopCat.Presheaf C X\nf : Quiver.Hom F.val G\nU : TopologicalSpace.Opens ‚ÜëX\nh : ‚àÄ (x : ‚ÜëX), Membership.mem U x ‚Üí Function.Injective ‚áë((TopCat.Presheaf.stalkFunctor C x).map f)\n‚ä¢ Function.Injective ‚áë(f.app { unop := U })","decl":"theorem app_injective_of_stalkFunctor_map_injective {F : Sheaf C X} {G : Presheaf C X} (f : F.1 ‚ü∂ G)\n    (U : Opens X) (h : ‚àÄ x ‚àà U, Function.Injective ((stalkFunctor C x).map f)) :\n    Function.Injective (f.app (op U)) := fun s t hst =>\n  section_ext F _ _ _ fun x hx =>\n    h x hx <| by rw [stalkFunctor_map_germ_apply, stalkFunctor_map_germ_apply, hst]\n\n"}
{"name":"TopCat.Presheaf.app_injective_iff_stalkFunctor_map_injective","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasColimits C\nX : TopCat\ninst‚úù‚Å¥ : CategoryTheory.HasForget C\ninst‚úù¬≥ : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)\ninst‚úù¬≤ : CategoryTheory.Limits.HasLimits C\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)\ninst‚úù : (CategoryTheory.forget C).ReflectsIsomorphisms\nF : TopCat.Sheaf C X\nG : TopCat.Presheaf C X\nf : Quiver.Hom F.val G\n‚ä¢ Iff (‚àÄ (x : ‚ÜëX), Function.Injective ‚áë((TopCat.Presheaf.stalkFunctor C x).map f)) (‚àÄ (U : TopologicalSpace.Opens ‚ÜëX), Function.Injective ‚áë(f.app { unop := U }))","decl":"theorem app_injective_iff_stalkFunctor_map_injective {F : Sheaf C X} {G : Presheaf C X}\n    (f : F.1 ‚ü∂ G) :\n    (‚àÄ x : X, Function.Injective ((stalkFunctor C x).map f)) ‚Üî\n      ‚àÄ U : Opens X, Function.Injective (f.app (op U)) :=\n  ‚ü®fun h U => app_injective_of_stalkFunctor_map_injective f U fun x _ => h x,\n    stalkFunctor_map_injective_of_app_injective f‚ü©\n\n"}
{"name":"TopCat.Presheaf.stalkFunctor_preserves_mono","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasColimits C\nX : TopCat\ninst‚úù‚Å¥ : CategoryTheory.HasForget C\ninst‚úù¬≥ : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)\ninst‚úù¬≤ : CategoryTheory.Limits.HasLimits C\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)\ninst‚úù : (CategoryTheory.forget C).ReflectsIsomorphisms\nx : ‚ÜëX\n‚ä¢ ((TopCat.Sheaf.forget C X).comp (TopCat.Presheaf.stalkFunctor C x)).PreservesMonomorphisms","decl":"instance stalkFunctor_preserves_mono (x : X) :\n    Functor.PreservesMonomorphisms (Sheaf.forget C X ‚ãô stalkFunctor C x) :=\n  ‚ü®@fun _ùìê _ùìë f _ =>\n    ConcreteCategory.mono_of_injective _ <|\n      (app_injective_iff_stalkFunctor_map_injective f.1).mpr\n        (fun c =>\n          (ConcreteCategory.mono_iff_injective_of_preservesPullback (f.1.app (op c))).mp\n            ((NatTrans.mono_iff_mono_app f.1).mp\n                (CategoryTheory.presheaf_mono_of_mono ..) <|\n              op c))\n        x‚ü©\n\n"}
{"name":"TopCat.Presheaf.stalk_mono_of_mono","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Å∂ : CategoryTheory.Limits.HasColimits C\nX : TopCat\ninst‚úù‚Åµ : CategoryTheory.HasForget C\ninst‚úù‚Å¥ : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)\ninst‚úù¬≥ : CategoryTheory.Limits.HasLimits C\ninst‚úù¬≤ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)\ninst‚úù¬π : (CategoryTheory.forget C).ReflectsIsomorphisms\nF G : TopCat.Sheaf C X\nf : Quiver.Hom F G\ninst‚úù : CategoryTheory.Mono f\nx : ‚ÜëX\n‚ä¢ CategoryTheory.Mono ((TopCat.Presheaf.stalkFunctor C x).map f.val)","decl":"theorem stalk_mono_of_mono {F G : Sheaf C X} (f : F ‚ü∂ G) [Mono f] :\n    ‚àÄ x, Mono <| (stalkFunctor C x).map f.1 :=\n  fun x => Functor.map_mono (Sheaf.forget.{v} C X ‚ãô stalkFunctor C x) f\n\n"}
{"name":"TopCat.Presheaf.mono_of_stalk_mono","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Å∂ : CategoryTheory.Limits.HasColimits C\nX : TopCat\ninst‚úù‚Åµ : CategoryTheory.HasForget C\ninst‚úù‚Å¥ : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)\ninst‚úù¬≥ : CategoryTheory.Limits.HasLimits C\ninst‚úù¬≤ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)\ninst‚úù¬π : (CategoryTheory.forget C).ReflectsIsomorphisms\nF G : TopCat.Sheaf C X\nf : Quiver.Hom F G\ninst‚úù : ‚àÄ (x : ‚ÜëX), CategoryTheory.Mono ((TopCat.Presheaf.stalkFunctor C x).map f.val)\n‚ä¢ CategoryTheory.Mono f","decl":"theorem mono_of_stalk_mono {F G : Sheaf C X} (f : F ‚ü∂ G) [‚àÄ x, Mono <| (stalkFunctor C x).map f.1] :\n    Mono f :=\n  (Sheaf.Hom.mono_iff_presheaf_mono _ _ _).mpr <|\n    (NatTrans.mono_iff_mono_app _).mpr fun U =>\n      (ConcreteCategory.mono_iff_injective_of_preservesPullback _).mpr <|\n        app_injective_of_stalkFunctor_map_injective f.1 U.unop fun _x _hx =>\n          (ConcreteCategory.mono_iff_injective_of_preservesPullback _).mp <| inferInstance\n\n"}
{"name":"TopCat.Presheaf.mono_iff_stalk_mono","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasColimits C\nX : TopCat\ninst‚úù‚Å¥ : CategoryTheory.HasForget C\ninst‚úù¬≥ : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)\ninst‚úù¬≤ : CategoryTheory.Limits.HasLimits C\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)\ninst‚úù : (CategoryTheory.forget C).ReflectsIsomorphisms\nF G : TopCat.Sheaf C X\nf : Quiver.Hom F G\n‚ä¢ Iff (CategoryTheory.Mono f) (‚àÄ (x : ‚ÜëX), CategoryTheory.Mono ((TopCat.Presheaf.stalkFunctor C x).map f.val))","decl":"theorem mono_iff_stalk_mono {F G : Sheaf C X} (f : F ‚ü∂ G) :\n    Mono f ‚Üî ‚àÄ x, Mono ((stalkFunctor C x).map f.1) :=\n  ‚ü®fun _ => stalk_mono_of_mono _, fun _ => mono_of_stalk_mono _‚ü©\n\n"}
{"name":"TopCat.Presheaf.app_surjective_of_injective_of_locally_surjective","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasColimits C\nX : TopCat\ninst‚úù‚Å¥ : CategoryTheory.HasForget C\ninst‚úù¬≥ : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)\ninst‚úù¬≤ : CategoryTheory.Limits.HasLimits C\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)\ninst‚úù : (CategoryTheory.forget C).ReflectsIsomorphisms\nF G : TopCat.Sheaf C X\nf : Quiver.Hom F G\nU : TopologicalSpace.Opens ‚ÜëX\nhinj : ‚àÄ (x : ‚ÜëX), Membership.mem U x ‚Üí Function.Injective ‚áë((TopCat.Presheaf.stalkFunctor C x).map f.val)\nhsurj : ‚àÄ (t : (CategoryTheory.forget C).obj (G.val.obj { unop := U })) (x : ‚ÜëX), Membership.mem U x ‚Üí Exists fun V => Exists fun x => Exists fun iVU => Exists fun s => Eq ((f.val.app { unop := V }) s) ((G.val.map iVU.op) t)\n‚ä¢ Function.Surjective ‚áë(f.val.app { unop := U })","decl":"/-- For surjectivity, we are given an arbitrary section `t` and need to find a preimage for it.\nWe claim that it suffices to find preimages *locally*. That is, for each `x : U` we construct\na neighborhood `V ‚â§ U` and a section `s : F.obj (op V))` such that `f.app (op V) s` and `t`\nagree on `V`. -/\ntheorem app_surjective_of_injective_of_locally_surjective {F G : Sheaf C X} (f : F ‚ü∂ G)\n    (U : Opens X) (hinj : ‚àÄ x ‚àà U, Function.Injective ((stalkFunctor C x).map f.1))\n    (hsurj : ‚àÄ (t x) (_ : x ‚àà U), ‚àÉ (V : Opens X) (_ : x ‚àà V) (iVU : V ‚ü∂ U) (s : F.1.obj (op V)),\n          f.1.app (op V) s = G.1.map iVU.op t) :\n    Function.Surjective (f.1.app (op U)) := by\n  conv at hsurj =>\n    enter [t]\n    rw [Subtype.forall' (p := (¬∑ ‚àà U))]\n  intro t\n  -- We use the axiom of choice to pick around each point `x` an open neighborhood `V` and a\n  -- preimage under `f` on `V`.\n  choose V mV iVU sf heq using hsurj t\n  -- These neighborhoods clearly cover all of `U`.\n  have V_cover : U ‚â§ iSup V := by\n    intro x hxU\n    simp only [Opens.coe_iSup, Set.mem_iUnion, SetLike.mem_coe]\n    exact ‚ü®‚ü®x, hxU‚ü©, mV ‚ü®x, hxU‚ü©‚ü©\n  suffices IsCompatible F.val V sf by\n    -- Since `F` is a sheaf, we can glue all the local preimages together to get a global preimage.\n    obtain ‚ü®s, s_spec, -‚ü© := F.existsUnique_gluing' V U iVU V_cover sf this\n    ¬∑ use s\n      apply G.eq_of_locally_eq' V U iVU V_cover\n      intro x\n      rw [‚Üê CategoryTheory.comp_apply, ‚Üê f.1.naturality, CategoryTheory.comp_apply, s_spec, heq]\n  intro x y\n  -- What's left to show here is that the sections `sf` are compatible, i.e. they agree on\n  -- the intersections `V x ‚äì V y`. We prove this by showing that all germs are equal.\n  apply section_ext\n  intro z hz\n  -- Here, we need to use injectivity of the stalk maps.\n  apply hinj z ((iVU x).le ((inf_le_left : V x ‚äì V y ‚â§ V x) hz))\n  dsimp only\n  rw [stalkFunctor_map_germ_apply, stalkFunctor_map_germ_apply]\n  simp_rw [‚Üê CategoryTheory.comp_apply, f.1.naturality, CategoryTheory.comp_apply, heq,\n    ‚Üê CategoryTheory.comp_apply, ‚Üê G.1.map_comp]\n  rfl\n\n"}
{"name":"TopCat.Presheaf.app_surjective_of_stalkFunctor_map_bijective","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasColimits C\nX : TopCat\ninst‚úù‚Å¥ : CategoryTheory.HasForget C\ninst‚úù¬≥ : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)\ninst‚úù¬≤ : CategoryTheory.Limits.HasLimits C\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)\ninst‚úù : (CategoryTheory.forget C).ReflectsIsomorphisms\nF G : TopCat.Sheaf C X\nf : Quiver.Hom F G\nU : TopologicalSpace.Opens ‚ÜëX\nh : ‚àÄ (x : ‚ÜëX), Membership.mem U x ‚Üí Function.Bijective ‚áë((TopCat.Presheaf.stalkFunctor C x).map f.val)\n‚ä¢ Function.Surjective ‚áë(f.val.app { unop := U })","decl":"theorem app_surjective_of_stalkFunctor_map_bijective {F G : Sheaf C X} (f : F ‚ü∂ G) (U : Opens X)\n    (h : ‚àÄ x ‚àà U, Function.Bijective ((stalkFunctor C x).map f.1)) :\n    Function.Surjective (f.1.app (op U)) := by\n  refine app_surjective_of_injective_of_locally_surjective f U (And.left <| h ¬∑ ¬∑) fun t x hx => ?_\n  -- Now we need to prove our initial claim: That we can find preimages of `t` locally.\n  -- Since `f` is surjective on stalks, we can find a preimage `s‚ÇÄ` of the germ of `t` at `x`\n  obtain ‚ü®s‚ÇÄ, hs‚ÇÄ‚ü© := (h x hx).2 (G.presheaf.germ U x hx t)\n  -- ... and this preimage must come from some section `s‚ÇÅ` defined on some open neighborhood `V‚ÇÅ`\n  obtain ‚ü®V‚ÇÅ, hxV‚ÇÅ, s‚ÇÅ, hs‚ÇÅ‚ü© := F.presheaf.germ_exist x s‚ÇÄ\n  subst hs‚ÇÅ; rename' hs‚ÇÄ => hs‚ÇÅ\n  rw [stalkFunctor_map_germ_apply V‚ÇÅ x hxV‚ÇÅ f.1 s‚ÇÅ] at hs‚ÇÅ\n  -- Now, the germ of `f.app (op V‚ÇÅ) s‚ÇÅ` equals the germ of `t`, hence they must coincide on\n  -- some open neighborhood `V‚ÇÇ`.\n  obtain ‚ü®V‚ÇÇ, hxV‚ÇÇ, iV‚ÇÇV‚ÇÅ, iV‚ÇÇU, heq‚ü© := G.presheaf.germ_eq x hxV‚ÇÅ hx _ _ hs‚ÇÅ\n  -- The restriction of `s‚ÇÅ` to that neighborhood is our desired local preimage.\n  use V‚ÇÇ, hxV‚ÇÇ, iV‚ÇÇU, F.1.map iV‚ÇÇV‚ÇÅ.op s‚ÇÅ\n  rw [‚Üê CategoryTheory.comp_apply, f.1.naturality, CategoryTheory.comp_apply, heq]\n\n"}
{"name":"TopCat.Presheaf.app_bijective_of_stalkFunctor_map_bijective","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasColimits C\nX : TopCat\ninst‚úù‚Å¥ : CategoryTheory.HasForget C\ninst‚úù¬≥ : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)\ninst‚úù¬≤ : CategoryTheory.Limits.HasLimits C\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)\ninst‚úù : (CategoryTheory.forget C).ReflectsIsomorphisms\nF G : TopCat.Sheaf C X\nf : Quiver.Hom F G\nU : TopologicalSpace.Opens ‚ÜëX\nh : ‚àÄ (x : ‚ÜëX), Membership.mem U x ‚Üí Function.Bijective ‚áë((TopCat.Presheaf.stalkFunctor C x).map f.val)\n‚ä¢ Function.Bijective ‚áë(f.val.app { unop := U })","decl":"theorem app_bijective_of_stalkFunctor_map_bijective {F G : Sheaf C X} (f : F ‚ü∂ G) (U : Opens X)\n    (h : ‚àÄ x ‚àà U, Function.Bijective ((stalkFunctor C x).map f.1)) :\n    Function.Bijective (f.1.app (op U)) :=\n  ‚ü®app_injective_of_stalkFunctor_map_injective f.1 U fun x hx => (h x hx).1,\n    app_surjective_of_stalkFunctor_map_bijective f U h‚ü©\n\n"}
{"name":"TopCat.Presheaf.app_isIso_of_stalkFunctor_map_iso","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Å∂ : CategoryTheory.Limits.HasColimits C\nX : TopCat\ninst‚úù‚Åµ : CategoryTheory.HasForget C\ninst‚úù‚Å¥ : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)\ninst‚úù¬≥ : CategoryTheory.Limits.HasLimits C\ninst‚úù¬≤ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)\ninst‚úù¬π : (CategoryTheory.forget C).ReflectsIsomorphisms\nF G : TopCat.Sheaf C X\nf : Quiver.Hom F G\nU : TopologicalSpace.Opens ‚ÜëX\ninst‚úù : ‚àÄ (x : Subtype fun x => Membership.mem U x), CategoryTheory.IsIso ((TopCat.Presheaf.stalkFunctor C ‚Üëx).map f.val)\n‚ä¢ CategoryTheory.IsIso (f.val.app { unop := U })","decl":"theorem app_isIso_of_stalkFunctor_map_iso {F G : Sheaf C X} (f : F ‚ü∂ G) (U : Opens X)\n    [‚àÄ x : U, IsIso ((stalkFunctor C x.val).map f.1)] : IsIso (f.1.app (op U)) := by\n  -- Since the forgetful functor of `C` reflects isomorphisms, it suffices to see that the\n  -- underlying map between types is an isomorphism, i.e. bijective.\n  suffices IsIso ((forget C).map (f.1.app (op U))) by\n    exact isIso_of_reflects_iso (f.1.app (op U)) (forget C)\n  rw [isIso_iff_bijective]\n  apply app_bijective_of_stalkFunctor_map_bijective\n  intro x hx\n  apply (isIso_iff_bijective _).mp\n  exact Functor.map_isIso (forget C) ((stalkFunctor C (‚ü®x, hx‚ü© : U).1).map f.1)\n\n-- Making this an instance would cause a loop in typeclass resolution with `Functor.map_isIso`\n"}
{"name":"TopCat.Presheaf.isIso_of_stalkFunctor_map_iso","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù‚Å∑ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Å∂ : CategoryTheory.Limits.HasColimits C\nX : TopCat\ninst‚úù‚Åµ : CategoryTheory.HasForget C\ninst‚úù‚Å¥ : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)\ninst‚úù¬≥ : CategoryTheory.Limits.HasLimits C\ninst‚úù¬≤ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)\ninst‚úù¬π : (CategoryTheory.forget C).ReflectsIsomorphisms\nF G : TopCat.Sheaf C X\nf : Quiver.Hom F G\ninst‚úù : ‚àÄ (x : ‚ÜëX), CategoryTheory.IsIso ((TopCat.Presheaf.stalkFunctor C x).map f.val)\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- Let `F` and `G` be sheaves valued in a concrete category, whose forgetful functor reflects\nisomorphisms, preserves limits and filtered colimits. Then if the stalk maps of a morphism\n`f : F ‚ü∂ G` are all isomorphisms, `f` must be an isomorphism.\n-/\ntheorem isIso_of_stalkFunctor_map_iso {F G : Sheaf C X} (f : F ‚ü∂ G)\n    [‚àÄ x : X, IsIso ((stalkFunctor C x).map f.1)] : IsIso f := by\n  -- Since the inclusion functor from sheaves to presheaves is fully faithful, it suffices to\n  -- show that `f`, as a morphism between _presheaves_, is an isomorphism.\n  suffices IsIso ((Sheaf.forget C X).map f) by exact isIso_of_fully_faithful (Sheaf.forget C X) f\n  -- We show that all components of `f` are isomorphisms.\n  suffices ‚àÄ U : (Opens X)·µí·µñ, IsIso (f.1.app U) by\n    exact @NatIso.isIso_of_isIso_app _ _ _ _ F.1 G.1 f.1 this\n  intro U; induction U\n  apply app_isIso_of_stalkFunctor_map_iso\n\n"}
{"name":"TopCat.Presheaf.isIso_iff_stalkFunctor_map_iso","module":"Mathlib.Topology.Sheaves.Stalks","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\ninst‚úù‚Åµ : CategoryTheory.Limits.HasColimits C\nX : TopCat\ninst‚úù‚Å¥ : CategoryTheory.HasForget C\ninst‚úù¬≥ : CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget C)\ninst‚úù¬≤ : CategoryTheory.Limits.HasLimits C\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)\ninst‚úù : (CategoryTheory.forget C).ReflectsIsomorphisms\nF G : TopCat.Sheaf C X\nf : Quiver.Hom F G\n‚ä¢ Iff (CategoryTheory.IsIso f) (‚àÄ (x : ‚ÜëX), CategoryTheory.IsIso ((TopCat.Presheaf.stalkFunctor C x).map f.val))","decl":"/-- Let `F` and `G` be sheaves valued in a concrete category, whose forgetful functor reflects\nisomorphisms, preserves limits and filtered colimits. Then a morphism `f : F ‚ü∂ G` is an\nisomorphism if and only if all of its stalk maps are isomorphisms.\n-/\ntheorem isIso_iff_stalkFunctor_map_iso {F G : Sheaf C X} (f : F ‚ü∂ G) :\n    IsIso f ‚Üî ‚àÄ x : X, IsIso ((stalkFunctor C x).map f.1) :=\n  ‚ü®fun _ x =>\n    @Functor.map_isIso _ _ _ _ _ _ (stalkFunctor C x) f.1 ((Sheaf.forget C X).map_isIso f),\n   fun _ => isIso_of_stalkFunctor_map_iso f‚ü©\n\n"}
