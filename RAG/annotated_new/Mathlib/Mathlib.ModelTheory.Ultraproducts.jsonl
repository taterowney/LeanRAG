{"name":"FirstOrder.Language.Ultraproduct.funMap_cast","module":"Mathlib.ModelTheory.Ultraproducts","initialProofState":"α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : FirstOrder.Language\ninst✝ : (a : α) → L.Structure (M a)\nn : Nat\nf : L.Functions n\nx : Fin n → (a : α) → M a\n⊢ Eq (FirstOrder.Language.Structure.funMap f fun i => Quotient.mk' (x i)) (Quotient.mk' fun a => FirstOrder.Language.Structure.funMap f fun i => x i a)","decl":"theorem funMap_cast {n : ℕ} (f : L.Functions n) (x : Fin n → ∀ a, M a) :\n    (funMap f fun i => (x i : (u : Filter α).Product M)) =\n      (fun a => funMap f fun i => x i a : (u : Filter α).Product M) := by\n  apply funMap_quotient_mk'\n\n"}
{"name":"FirstOrder.Language.Ultraproduct.term_realize_cast","module":"Mathlib.ModelTheory.Ultraproducts","initialProofState":"α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : FirstOrder.Language\ninst✝ : (a : α) → L.Structure (M a)\nβ : Type u_3\nx : β → (a : α) → M a\nt : L.Term β\n⊢ Eq (FirstOrder.Language.Term.realize (fun i => Quotient.mk' (x i)) t) (Quotient.mk' fun a => FirstOrder.Language.Term.realize (fun i => x i a) t)","decl":"theorem term_realize_cast {β : Type*} (x : β → ∀ a, M a) (t : L.Term β) :\n    (t.realize fun i => (x i : (u : Filter α).Product M)) =\n      (fun a => t.realize fun i => x i a : (u : Filter α).Product M) := by\n  convert @Term.realize_quotient_mk' L _ ((u : Filter α).productSetoid M)\n      (Ultraproduct.setoidPrestructure M u) _ t x using 2\n  ext a\n  induction t with\n  | var => rfl\n  | func _ _ t_ih => simp only [Term.realize, t_ih]; rfl\n\n"}
{"name":"FirstOrder.Language.Ultraproduct.boundedFormula_realize_cast","module":"Mathlib.ModelTheory.Ultraproducts","initialProofState":"α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : FirstOrder.Language\ninst✝¹ : (a : α) → L.Structure (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_3\nn : Nat\nφ : L.BoundedFormula β n\nx : β → (a : α) → M a\nv : Fin n → (a : α) → M a\n⊢ Iff (φ.Realize (fun i => Quotient.mk' (x i)) fun i => Quotient.mk' (v i)) (Filter.Eventually (fun a => φ.Realize (fun i => x i a) fun i => v i a) ↑u)","decl":"theorem boundedFormula_realize_cast {β : Type*} {n : ℕ} (φ : L.BoundedFormula β n)\n    (x : β → ∀ a, M a) (v : Fin n → ∀ a, M a) :\n    (φ.Realize (fun i : β => (x i : (u : Filter α).Product M))\n        (fun i => (v i : (u : Filter α).Product M))) ↔\n      ∀ᶠ a : α in u, φ.Realize (fun i : β => x i a) fun i => v i a := by\n  letI := (u : Filter α).productSetoid M\n  induction φ with\n  | falsum => simp only [BoundedFormula.Realize, eventually_const]\n  | equal =>\n    have h2 : ∀ a : α, (Sum.elim (fun i : β => x i a) fun i => v i a) = fun i => Sum.elim x v i a :=\n      fun a => funext fun i => Sum.casesOn i (fun i => rfl) fun i => rfl\n    simp only [BoundedFormula.Realize, h2, term_realize_cast]\n    erw [(Sum.comp_elim ((↑) : (∀ a, M a) → (u : Filter α).Product M) x v).symm,\n      term_realize_cast, term_realize_cast]\n    exact Quotient.eq''\n  | rel =>\n    have h2 : ∀ a : α, (Sum.elim (fun i : β => x i a) fun i => v i a) = fun i => Sum.elim x v i a :=\n      fun a => funext fun i => Sum.casesOn i (fun i => rfl) fun i => rfl\n    simp only [BoundedFormula.Realize, h2]\n    erw [(Sum.comp_elim ((↑) : (∀ a, M a) → (u : Filter α).Product M) x v).symm]\n    conv_lhs => enter [2, i]; erw [term_realize_cast]\n    apply relMap_quotient_mk'\n  | imp _ _ ih ih' =>\n    simp only [BoundedFormula.Realize, ih v, ih' v]\n    rw [Ultrafilter.eventually_imp]\n  | @all k φ ih =>\n    simp only [BoundedFormula.Realize]\n    apply Iff.trans (b := ∀ m : ∀ a : α, M a,\n      φ.Realize (fun i : β => (x i : (u : Filter α).Product M))\n        (Fin.snoc (((↑) : (∀ a, M a) → (u : Filter α).Product M) ∘ v)\n          (m : (u : Filter α).Product M)))\n    · exact Quotient.forall\n    have h' :\n      ∀ (m : ∀ a, M a) (a : α),\n        (fun i : Fin (k + 1) => (Fin.snoc v m : _ → ∀ a, M a) i a) =\n          Fin.snoc (fun i : Fin k => v i a) (m a) := by\n      refine fun m a => funext (Fin.reverseInduction ?_ fun i _ => ?_)\n      · simp only [Fin.snoc_last]\n      · simp only [Fin.snoc_castSucc]\n    simp only [← Fin.comp_snoc]\n    simp only [Function.comp_def, ih, h']\n    refine ⟨fun h => ?_, fun h m => ?_⟩\n    · contrapose! h\n      simp_rw [← Ultrafilter.eventually_not, not_forall] at h\n      refine\n        ⟨fun a : α =>\n          Classical.epsilon fun m : M a =>\n            ¬φ.Realize (fun i => x i a) (Fin.snoc (fun i => v i a) m),\n          ?_⟩\n      rw [← Ultrafilter.eventually_not]\n      exact Filter.mem_of_superset h fun a ha => Classical.epsilon_spec ha\n    · rw [Filter.eventually_iff] at *\n      exact Filter.mem_of_superset h fun a ha => ha (m a)\n\n"}
{"name":"FirstOrder.Language.Ultraproduct.realize_formula_cast","module":"Mathlib.ModelTheory.Ultraproducts","initialProofState":"α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : FirstOrder.Language\ninst✝¹ : (a : α) → L.Structure (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nβ : Type u_3\nφ : L.Formula β\nx : β → (a : α) → M a\n⊢ Iff (φ.Realize fun i => Quotient.mk' (x i)) (Filter.Eventually (fun a => φ.Realize fun i => x i a) ↑u)","decl":"theorem realize_formula_cast {β : Type*} (φ : L.Formula β) (x : β → ∀ a, M a) :\n    (φ.Realize fun i => (x i : (u : Filter α).Product M)) ↔\n      ∀ᶠ a : α in u, φ.Realize fun i => x i a := by\n  simp_rw [Formula.Realize, ← boundedFormula_realize_cast φ x, iff_eq_eq]\n  exact congr rfl (Subsingleton.elim _ _)\n\n"}
{"name":"FirstOrder.Language.Ultraproduct.sentence_realize","module":"Mathlib.ModelTheory.Ultraproducts","initialProofState":"α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\nL : FirstOrder.Language\ninst✝¹ : (a : α) → L.Structure (M a)\ninst✝ : ∀ (a : α), Nonempty (M a)\nφ : L.Sentence\n⊢ Iff (FirstOrder.Language.Sentence.Realize ((↑u).Product M) φ) (Filter.Eventually (fun a => FirstOrder.Language.Sentence.Realize (M a) φ) ↑u)","decl":"/-- **Łoś's Theorem**: A sentence is true in an ultraproduct if and only if the set of structures\nit is true in is in the ultrafilter. -/\ntheorem sentence_realize (φ : L.Sentence) :\n    (u : Filter α).Product M ⊨ φ ↔ ∀ᶠ a : α in u, M a ⊨ φ := by\n  simp_rw [Sentence.Realize]\n  rw [← realize_formula_cast φ, iff_eq_eq]\n  exact congr rfl (Subsingleton.elim _ _)\n\n"}
{"name":"FirstOrder.Language.Ultraproduct.Product.instNonempty","module":"Mathlib.ModelTheory.Ultraproducts","initialProofState":"α : Type u_1\nM : α → Type u_2\nu : Ultrafilter α\ninst✝ : ∀ (a : α), Nonempty (M a)\n⊢ Nonempty ((↑u).Product M)","decl":"nonrec instance Product.instNonempty : Nonempty ((u : Filter α).Product M) :=\n  letI : ∀ a, Inhabited (M a) := fun _ => Classical.inhabited_of_nonempty'\n  inferInstance\n\n"}
