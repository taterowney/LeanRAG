{"name":"Profinite.IndexFunctor.surjective_π_app","module":"Mathlib.Topology.Category.Profinite.Product","initialProofState":"ι : Type u\nX : ι → Type\ninst✝ : (i : ι) → TopologicalSpace (X i)\nC : Set ((i : ι) → X i)\nJ : ι → Prop\n⊢ Function.Surjective ⇑(Profinite.IndexFunctor.π_app C J)","decl":"theorem surjective_π_app :\n    Function.Surjective (π_app C J) := by\n  intro x\n  obtain ⟨y, hy⟩ := x.prop\n  exact ⟨⟨y, hy.1⟩, Subtype.ext hy.2⟩\n\n"}
{"name":"Profinite.IndexFunctor.map_comp_π_app","module":"Mathlib.Topology.Category.Profinite.Product","initialProofState":"ι : Type u\nX : ι → Type\ninst✝ : (i : ι) → TopologicalSpace (X i)\nC : Set ((i : ι) → X i)\nJ K : ι → Prop\nh : ∀ (i : ι), J i → K i\n⊢ Eq (Function.comp ⇑(Profinite.IndexFunctor.map C h) ⇑(Profinite.IndexFunctor.π_app C K)) ⇑(Profinite.IndexFunctor.π_app C J)","decl":"theorem map_comp_π_app (h : ∀ i, J i → K i) : map C h ∘ π_app C K = π_app C J := rfl\n\n"}
{"name":"Profinite.IndexFunctor.eq_of_forall_π_app_eq","module":"Mathlib.Topology.Category.Profinite.Product","initialProofState":"ι : Type u\nX : ι → Type\ninst✝ : (i : ι) → TopologicalSpace (X i)\nC : Set ((i : ι) → X i)\na b : ↑C\nh : ∀ (J : Finset ι), Eq ((Profinite.IndexFunctor.π_app C fun x => Membership.mem J x) a) ((Profinite.IndexFunctor.π_app C fun x => Membership.mem J x) b)\n⊢ Eq a b","decl":"theorem eq_of_forall_π_app_eq (a b : C)\n    (h : ∀ (J : Finset ι), π_app C (· ∈ J) a = π_app C (· ∈ J) b) : a = b := by\n  ext i\n  specialize h ({i} : Finset ι)\n  rw [Subtype.ext_iff] at h\n  simp only [π_app, ContinuousMap.precomp, ContinuousMap.coe_mk,\n    Set.MapsTo.val_restrict_apply] at h\n  exact congr_fun h ⟨i, Finset.mem_singleton.mpr rfl⟩\n\n"}
{"name":"Profinite.isIso_indexCone_lift","module":"Mathlib.Topology.Category.Profinite.Product","initialProofState":"ι : Type u\nX : ι → Type\ninst✝² : (i : ι) → TopologicalSpace (X i)\nC : Set ((i : ι) → X i)\ninst✝¹ : ∀ (i : ι), T2Space (X i)\ninst✝ : ∀ (i : ι), TotallyDisconnectedSpace (X i)\nhC : IsCompact C\n⊢ CategoryTheory.IsIso ((Profinite.limitConeIsLimit (Profinite.indexFunctor hC)).lift (Profinite.indexCone hC))","decl":"instance isIso_indexCone_lift :\n    IsIso ((limitConeIsLimit.{u, u} (indexFunctor hC)).lift (indexCone hC)) :=\n  haveI : CompactSpace C := by rwa [← isCompact_iff_compactSpace]\n  CompHausLike.isIso_of_bijective _\n    (by\n      refine ⟨fun a b h ↦ ?_, fun a ↦ ?_⟩\n      · refine eq_of_forall_π_app_eq a b (fun J ↦ ?_)\n        apply_fun fun f : (limitCone.{u, u} (indexFunctor hC)).pt => f.val (op J) at h\n        exact h\n      · rsuffices ⟨b, hb⟩ : ∃ (x : C), ∀ (J : Finset ι), π_app C (· ∈ J) x = a.val (op J)\n        · use b\n          apply Subtype.ext\n          apply funext\n          intro J\n          exact hb (unop J)\n        have hc : ∀ (J : Finset ι) s, IsClosed ((π_app C (· ∈ J)) ⁻¹' {s}) := by\n          intro J s\n          refine IsClosed.preimage (π_app C (· ∈ J)).continuous ?_\n          exact T1Space.t1 s\n        have H₁ : ∀ (Q₁ Q₂ : Finset ι), Q₁ ≤ Q₂ →\n            π_app C (· ∈ Q₁) ⁻¹' {a.val (op Q₁)} ⊇\n            π_app C (· ∈ Q₂) ⁻¹' {a.val (op Q₂)} := by\n          intro J K h x hx\n          simp only [Set.mem_preimage, Set.mem_singleton_iff] at hx ⊢\n          rw [← map_comp_π_app C h, Function.comp_apply,\n            hx, ← a.prop (homOfLE h).op]\n          rfl\n        obtain ⟨x, hx⟩ :\n            Set.Nonempty (⋂ (J : Finset ι), π_app C (· ∈ J) ⁻¹' {a.val (op J)}) :=\n          IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed\n            (fun J : Finset ι => π_app C (· ∈ J) ⁻¹' {a.val (op J)}) (directed_of_isDirected_le H₁)\n            (fun J => (Set.singleton_nonempty _).preimage (surjective_π_app _))\n            (fun J => (hc J (a.val (op J))).isCompact) fun J => hc J (a.val (op J))\n        exact ⟨x, Set.mem_iInter.1 hx⟩)\n\n"}
