{"name":"Set.iUnionLift_mk","module":"Mathlib.Data.Set.UnionLift","initialProofState":"α : Type u_1\nι : Sort u_3\nβ : Sort u_2\nS : ι → Set α\nf : (i : ι) → ↑(S i) → β\nhf : ∀ (i j : ι) (x : α) (hxi : Membership.mem (S i) x) (hxj : Membership.mem (S j) x), Eq (f i ⟨x, hxi⟩) (f j ⟨x, hxj⟩)\nT : Set α\nhT : HasSubset.Subset T (Set.iUnion S)\ni : ι\nx : ↑(S i)\nhx : Membership.mem T ↑x\n⊢ Eq (Set.iUnionLift S f hf T hT ⟨↑x, hx⟩) (f i x)","decl":"@[simp]\ntheorem iUnionLift_mk {i : ι} (x : S i) (hx : (x : α) ∈ T) :\n    iUnionLift S f hf T hT ⟨x, hx⟩ = f i x := hf _ i x _ _\n\n"}
{"name":"Set.iUnionLift_inclusion","module":"Mathlib.Data.Set.UnionLift","initialProofState":"α : Type u_1\nι : Sort u_3\nβ : Sort u_2\nS : ι → Set α\nf : (i : ι) → ↑(S i) → β\nhf : ∀ (i j : ι) (x : α) (hxi : Membership.mem (S i) x) (hxj : Membership.mem (S j) x), Eq (f i ⟨x, hxi⟩) (f j ⟨x, hxj⟩)\nT : Set α\nhT : HasSubset.Subset T (Set.iUnion S)\ni : ι\nx : ↑(S i)\nh : HasSubset.Subset (S i) T\n⊢ Eq (Set.iUnionLift S f hf T hT (Set.inclusion h x)) (f i x)","decl":"theorem iUnionLift_inclusion {i : ι} (x : S i) (h : S i ⊆ T) :\n    iUnionLift S f hf T hT (Set.inclusion h x) = f i x :=\n  iUnionLift_mk x _\n\n"}
{"name":"Set.iUnionLift_of_mem","module":"Mathlib.Data.Set.UnionLift","initialProofState":"α : Type u_1\nι : Sort u_3\nβ : Sort u_2\nS : ι → Set α\nf : (i : ι) → ↑(S i) → β\nhf : ∀ (i j : ι) (x : α) (hxi : Membership.mem (S i) x) (hxj : Membership.mem (S j) x), Eq (f i ⟨x, hxi⟩) (f j ⟨x, hxj⟩)\nT : Set α\nhT : HasSubset.Subset T (Set.iUnion S)\nx : ↑T\ni : ι\nhx : Membership.mem (S i) ↑x\n⊢ Eq (Set.iUnionLift S f hf T hT x) (f i ⟨↑x, hx⟩)","decl":"theorem iUnionLift_of_mem (x : T) {i : ι} (hx : (x : α) ∈ S i) :\n    iUnionLift S f hf T hT x = f i ⟨x, hx⟩ := by cases' x with x hx; exact hf _ _ _ _ _\n\n"}
{"name":"Set.preimage_iUnionLift","module":"Mathlib.Data.Set.UnionLift","initialProofState":"α : Type u_1\nι : Sort u_3\nβ : Type u_2\nS : ι → Set α\nf : (i : ι) → ↑(S i) → β\nhf : ∀ (i j : ι) (x : α) (hxi : Membership.mem (S i) x) (hxj : Membership.mem (S j) x), Eq (f i ⟨x, hxi⟩) (f j ⟨x, hxj⟩)\nT : Set α\nhT : HasSubset.Subset T (Set.iUnion S)\nt : Set β\n⊢ Eq (Set.preimage (Set.iUnionLift S f hf T hT) t) (Set.preimage (Set.inclusion hT) (Set.iUnion fun i => Set.image (Set.inclusion ⋯) (Set.preimage (f i) t)))","decl":"theorem preimage_iUnionLift (t : Set β) :\n    iUnionLift S f hf T hT ⁻¹' t =\n      inclusion hT ⁻¹' (⋃ i, inclusion (subset_iUnion S i) '' (f i ⁻¹' t)) := by\n  ext x\n  simp only [mem_preimage, mem_iUnion, mem_image]\n  constructor\n  · rcases mem_iUnion.1 (hT x.prop) with ⟨i, hi⟩\n    refine fun h => ⟨i, ⟨x, hi⟩, ?_, rfl⟩\n    rwa [iUnionLift_of_mem x hi] at h\n  · rintro ⟨i, ⟨y, hi⟩, h, hxy⟩\n    obtain rfl : y = x := congr_arg Subtype.val hxy\n    rwa [iUnionLift_of_mem x hi]\n\n"}
{"name":"Set.iUnionLift_const","module":"Mathlib.Data.Set.UnionLift","initialProofState":"α : Type u_1\nι : Sort u_3\nβ : Sort u_2\nS : ι → Set α\nf : (i : ι) → ↑(S i) → β\nhf : ∀ (i j : ι) (x : α) (hxi : Membership.mem (S i) x) (hxj : Membership.mem (S j) x), Eq (f i ⟨x, hxi⟩) (f j ⟨x, hxj⟩)\nT : Set α\nhT : HasSubset.Subset T (Set.iUnion S)\nc : ↑T\nci : (i : ι) → ↑(S i)\nhci : ∀ (i : ι), Eq ↑(ci i) ↑c\ncβ : β\nh : ∀ (i : ι), Eq (f i (ci i)) cβ\n⊢ Eq (Set.iUnionLift S f hf T hT c) cβ","decl":"/-- `iUnionLift_const` is useful for proving that `iUnionLift` is a homomorphism\n  of algebraic structures when defined on the Union of algebraic subobjects.\n  For example, it could be used to prove that the lift of a collection\n  of group homomorphisms on a union of subgroups preserves `1`. -/\ntheorem iUnionLift_const (c : T) (ci : ∀ i, S i) (hci : ∀ i, (ci i : α) = c) (cβ : β)\n    (h : ∀ i, f i (ci i) = cβ) : iUnionLift S f hf T hT c = cβ := by\n  let ⟨i, hi⟩ := Set.mem_iUnion.1 (hT c.prop)\n  have : ci i = ⟨c, hi⟩ := Subtype.ext (hci i)\n  rw [iUnionLift_of_mem _ hi, ← this, h]\n\n"}
{"name":"Set.iUnionLift_unary","module":"Mathlib.Data.Set.UnionLift","initialProofState":"α : Type u_1\nι : Sort u_2\nβ : Sort u_3\nS : ι → Set α\nf : (i : ι) → ↑(S i) → β\nhf : ∀ (i j : ι) (x : α) (hxi : Membership.mem (S i) x) (hxj : Membership.mem (S j) x), Eq (f i ⟨x, hxi⟩) (f j ⟨x, hxj⟩)\nT : Set α\nhT' : Eq T (Set.iUnion S)\nu : ↑T → ↑T\nui : (i : ι) → ↑(S i) → ↑(S i)\nhui : ∀ (i : ι) (x : ↑(S i)), Eq (u (Set.inclusion ⋯ x)) (Set.inclusion ⋯ (ui i x))\nuβ : β → β\nh : ∀ (i : ι) (x : ↑(S i)), Eq (f i (ui i x)) (uβ (f i x))\nx : ↑T\n⊢ Eq (Set.iUnionLift S f hf T ⋯ (u x)) (uβ (Set.iUnionLift S f hf T ⋯ x))","decl":"/-- `iUnionLift_unary` is useful for proving that `iUnionLift` is a homomorphism\n  of algebraic structures when defined on the Union of algebraic subobjects.\n  For example, it could be used to prove that the lift of a collection\n  of linear_maps on a union of submodules preserves scalar multiplication. -/\ntheorem iUnionLift_unary (u : T → T) (ui : ∀ i, S i → S i)\n    (hui :\n      ∀ (i) (x : S i),\n        u (Set.inclusion (show S i ⊆ T from hT'.symm ▸ Set.subset_iUnion S i) x) =\n          Set.inclusion (show S i ⊆ T from hT'.symm ▸ Set.subset_iUnion S i) (ui i x))\n    (uβ : β → β) (h : ∀ (i) (x : S i), f i (ui i x) = uβ (f i x)) (x : T) :\n    iUnionLift S f hf T (le_of_eq hT') (u x) = uβ (iUnionLift S f hf T (le_of_eq hT') x) := by\n  subst hT'\n  cases' Set.mem_iUnion.1 x.prop with i hi\n  rw [iUnionLift_of_mem x hi, ← h i]\n  have : x = Set.inclusion (Set.subset_iUnion S i) ⟨x, hi⟩ := by\n    cases x\n    rfl\n  conv_lhs => rw [this, hui, iUnionLift_inclusion]\n\n"}
{"name":"Set.iUnionLift_binary","module":"Mathlib.Data.Set.UnionLift","initialProofState":"α : Type u_1\nι : Sort u_2\nβ : Sort u_3\nS : ι → Set α\nf : (i : ι) → ↑(S i) → β\nhf : ∀ (i j : ι) (x : α) (hxi : Membership.mem (S i) x) (hxj : Membership.mem (S j) x), Eq (f i ⟨x, hxi⟩) (f j ⟨x, hxj⟩)\nT : Set α\nhT' : Eq T (Set.iUnion S)\ndir : Directed (fun x1 x2 => LE.le x1 x2) S\nop : ↑T → ↑T → ↑T\nopi : (i : ι) → ↑(S i) → ↑(S i) → ↑(S i)\nhopi : ∀ (i : ι) (x y : ↑(S i)), Eq (Set.inclusion ⋯ (opi i x y)) (op (Set.inclusion ⋯ x) (Set.inclusion ⋯ y))\nopβ : β → β → β\nh : ∀ (i : ι) (x y : ↑(S i)), Eq (f i (opi i x y)) (opβ (f i x) (f i y))\nx y : ↑T\n⊢ Eq (Set.iUnionLift S f hf T ⋯ (op x y)) (opβ (Set.iUnionLift S f hf T ⋯ x) (Set.iUnionLift S f hf T ⋯ y))","decl":"/-- `iUnionLift_binary` is useful for proving that `iUnionLift` is a homomorphism\n  of algebraic structures when defined on the Union of algebraic subobjects.\n  For example, it could be used to prove that the lift of a collection\n  of group homomorphisms on a union of subgroups preserves `*`. -/\ntheorem iUnionLift_binary (dir : Directed (· ≤ ·) S) (op : T → T → T) (opi : ∀ i, S i → S i → S i)\n    (hopi :\n      ∀ i x y,\n        Set.inclusion (show S i ⊆ T from hT'.symm ▸ Set.subset_iUnion S i) (opi i x y) =\n          op (Set.inclusion (show S i ⊆ T from hT'.symm ▸ Set.subset_iUnion S i) x)\n            (Set.inclusion (show S i ⊆ T from hT'.symm ▸ Set.subset_iUnion S i) y))\n    (opβ : β → β → β) (h : ∀ (i) (x y : S i), f i (opi i x y) = opβ (f i x) (f i y)) (x y : T) :\n    iUnionLift S f hf T (le_of_eq hT') (op x y) =\n      opβ (iUnionLift S f hf T (le_of_eq hT') x) (iUnionLift S f hf T (le_of_eq hT') y) := by\n  subst hT'\n  cases' Set.mem_iUnion.1 x.prop with i hi\n  cases' Set.mem_iUnion.1 y.prop with j hj\n  rcases dir i j with ⟨k, hik, hjk⟩\n  rw [iUnionLift_of_mem x (hik hi), iUnionLift_of_mem y (hjk hj), ← h k]\n  have hx : x = Set.inclusion (Set.subset_iUnion S k) ⟨x, hik hi⟩ := by\n    cases x\n    rfl\n  have hy : y = Set.inclusion (Set.subset_iUnion S k) ⟨y, hjk hj⟩ := by\n    cases y\n    rfl\n  have hxy : (Set.inclusion (Set.subset_iUnion S k) (opi k ⟨x, hik hi⟩ ⟨y, hjk hj⟩) : α) ∈ S k :=\n    (opi k ⟨x, hik hi⟩ ⟨y, hjk hj⟩).prop\n  conv_lhs => rw [hx, hy, ← hopi, iUnionLift_of_mem _ hxy]\n\n"}
{"name":"Set.liftCover_coe","module":"Mathlib.Data.Set.UnionLift","initialProofState":"α : Type u_1\nι : Sort u_3\nβ : Sort u_2\nS : ι → Set α\nf : (i : ι) → ↑(S i) → β\nhf : ∀ (i j : ι) (x : α) (hxi : Membership.mem (S i) x) (hxj : Membership.mem (S j) x), Eq (f i ⟨x, hxi⟩) (f j ⟨x, hxj⟩)\nhS : Eq (Set.iUnion S) Set.univ\ni : ι\nx : ↑(S i)\n⊢ Eq (Set.liftCover S f hf hS ↑x) (f i x)","decl":"@[simp]\ntheorem liftCover_coe {i : ι} (x : S i) : liftCover S f hf hS x = f i x :=\n  iUnionLift_mk x _\n\n"}
{"name":"Set.liftCover_of_mem","module":"Mathlib.Data.Set.UnionLift","initialProofState":"α : Type u_1\nι : Sort u_3\nβ : Sort u_2\nS : ι → Set α\nf : (i : ι) → ↑(S i) → β\nhf : ∀ (i j : ι) (x : α) (hxi : Membership.mem (S i) x) (hxj : Membership.mem (S j) x), Eq (f i ⟨x, hxi⟩) (f j ⟨x, hxj⟩)\nhS : Eq (Set.iUnion S) Set.univ\ni : ι\nx : α\nhx : Membership.mem (S i) x\n⊢ Eq (Set.liftCover S f hf hS x) (f i ⟨x, hx⟩)","decl":"theorem liftCover_of_mem {i : ι} {x : α} (hx : (x : α) ∈ S i) :\n    liftCover S f hf hS x = f i ⟨x, hx⟩ :=\n  iUnionLift_of_mem (⟨x, trivial⟩ : {_z // True}) hx\n\n"}
{"name":"Set.preimage_liftCover","module":"Mathlib.Data.Set.UnionLift","initialProofState":"α : Type u_1\nι : Sort u_3\nβ : Type u_2\nS : ι → Set α\nf : (i : ι) → ↑(S i) → β\nhf : ∀ (i j : ι) (x : α) (hxi : Membership.mem (S i) x) (hxj : Membership.mem (S j) x), Eq (f i ⟨x, hxi⟩) (f j ⟨x, hxj⟩)\nhS : Eq (Set.iUnion S) Set.univ\nt : Set β\n⊢ Eq (Set.preimage (Set.liftCover S f hf hS) t) (Set.iUnion fun i => Set.image Subtype.val (Set.preimage (f i) t))","decl":"theorem preimage_liftCover (t : Set β) : liftCover S f hf hS ⁻¹' t = ⋃ i, (↑) '' (f i ⁻¹' t) := by\n  change (iUnionLift S f hf univ hS.symm.subset ∘ fun a => ⟨a, mem_univ a⟩) ⁻¹' t = _\n  rw [preimage_comp, preimage_iUnionLift]\n  ext; simp\n\n"}
