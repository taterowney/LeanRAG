{"name":"CommRingCat.Under.instPreservesLimitUnderDiscreteFunctorTensorProdOfFinite","module":"Mathlib.Algebra.Category.Ring.Under.Limits","initialProofState":"R S : CommRingCat\ninst✝¹ : Algebra ↑R ↑S\nJ : Type u\ninst✝ : Finite J\nf : J → CategoryTheory.Under R\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Discrete.functor f) (R.tensorProd S)","decl":"instance (J : Type u) [Finite J] (f : J → Under R) :\n    PreservesLimit (Discrete.functor f) (tensorProd R S) :=\n  let c : Fan _ := Under.piFan f\n  have hc : IsLimit c := Under.piFanIsLimit f\n  preservesLimit_of_preserves_limit_cone hc (piFanTensorProductIsLimit f)\n\n"}
{"name":"CommRingCat.Under.instPreservesLimitsOfShapeUnderDiscreteTensorProdOfFinite","module":"Mathlib.Algebra.Category.Ring.Under.Limits","initialProofState":"R S : CommRingCat\ninst✝¹ : Algebra ↑R ↑S\nJ : Type\ninst✝ : Finite J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete J) (R.tensorProd S)","decl":"instance (J : Type) [Finite J] :\n    PreservesLimitsOfShape (Discrete J) (tensorProd R S) :=\n  let J' : Type u := ULift.{u} J\n  have : PreservesLimitsOfShape (Discrete J') (tensorProd R S) :=\n    preservesLimitsOfShape_of_discrete (tensorProd R S)\n  let e : Discrete J' ≌ Discrete J := Discrete.equivalence Equiv.ulift\n  preservesLimitsOfShape_of_equiv e (R.tensorProd S)\n\n"}
{"name":"CommRingCat.Under.instPreservesFiniteProductsUnderTensorProd","module":"Mathlib.Algebra.Category.Ring.Under.Limits","initialProofState":"R S : CommRingCat\ninst✝ : Algebra ↑R ↑S\n⊢ CategoryTheory.Limits.PreservesFiniteProducts (R.tensorProd S)","decl":"instance : PreservesFiniteProducts (tensorProd R S) where\n  preserves J := { }\n\n"}
{"name":"CommRingCat.Under.equalizer_comp","module":"Mathlib.Algebra.Category.Ring.Under.Limits","initialProofState":"R : CommRingCat\nA B : CategoryTheory.Under R\nf g : Quiver.Hom A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgHom.equalizer (CommRingCat.toAlgHom f) (CommRingCat.toAlgHom g)).val.toUnder f) (CategoryTheory.CategoryStruct.comp (AlgHom.equalizer (CommRingCat.toAlgHom f) (CommRingCat.toAlgHom g)).val.toUnder g)","decl":"lemma equalizer_comp {A B : Under R} (f g : A ⟶ B) :\n    (AlgHom.equalizer (toAlgHom f) (toAlgHom g)).val.toUnder ≫ f =\n    (AlgHom.equalizer (toAlgHom f) (toAlgHom g)).val.toUnder ≫ g := by\n  ext (a : AlgHom.equalizer (toAlgHom f) (toAlgHom g))\n  exact a.property\n\n"}
{"name":"CommRingCat.Under.equalizerFork_ι","module":"Mathlib.Algebra.Category.Ring.Under.Limits","initialProofState":"R : CommRingCat\nA B : CategoryTheory.Under R\nf g : Quiver.Hom A B\n⊢ Eq (CommRingCat.Under.equalizerFork f g).ι (AlgHom.equalizer (CommRingCat.toAlgHom f) (CommRingCat.toAlgHom g)).val.toUnder","decl":"@[simp]\nlemma equalizerFork_ι {A B : Under R} (f g : A ⟶ B) :\n    (Under.equalizerFork f g).ι = (AlgHom.equalizer (toAlgHom f) (toAlgHom g)).val.toUnder := rfl\n\n"}
{"name":"CommRingCat.Under.equalizerFork'_ι","module":"Mathlib.Algebra.Category.Ring.Under.Limits","initialProofState":"R : CommRingCat\nA B : Type u\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra (↑R) A\ninst✝ : Algebra (↑R) B\nf g : AlgHom (↑R) A B\n⊢ Eq (CommRingCat.Under.equalizerFork' f g).ι (AlgHom.equalizer f g).val.toUnder","decl":"@[simp]\nlemma equalizerFork'_ι {A B : Type u} [CommRing A] [CommRing B] [Algebra R A] [Algebra R B]\n    (f g : A →ₐ[R] B) :\n    (Under.equalizerFork' f g).ι = (AlgHom.equalizer f g).val.toUnder := rfl\n\n"}
{"name":"CommRingCat.Under.tensorProdEqualizer_ι","module":"Mathlib.Algebra.Category.Ring.Under.Limits","initialProofState":"R S : CommRingCat\ninst✝ : Algebra ↑R ↑S\nA B : CategoryTheory.Under R\nf g : Quiver.Hom A B\n⊢ Eq (CommRingCat.Under.tensorProdEqualizer f g).ι ((R.tensorProd S).map (AlgHom.equalizer (CommRingCat.toAlgHom f) (CommRingCat.toAlgHom g)).val.toUnder)","decl":"@[simp]\nlemma tensorProdEqualizer_ι {A B : Under R} (f g : A ⟶ B) :\n    (tensorProdEqualizer f g).ι = (tensorProd R S).map\n      ((AlgHom.equalizer (toAlgHom f) (toAlgHom g)).val.toUnder) :=\n  rfl\n\n"}
{"name":"CommRingCat.Under.instPreservesLimitUnderWalkingParallelPairParallelPairTensorProdOfFlatCarrier","module":"Mathlib.Algebra.Category.Ring.Under.Limits","initialProofState":"R S : CommRingCat\ninst✝¹ : Algebra ↑R ↑S\ninst✝ : Module.Flat ↑R ↑S\nA B : CategoryTheory.Under R\nf g : Quiver.Hom A B\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f g) (R.tensorProd S)","decl":"instance [Module.Flat R S] {A B : Under R} (f g : A ⟶ B) :\n    PreservesLimit (parallelPair f g) (tensorProd R S) :=\n  let c : Fork f g := Under.equalizerFork f g\n  let hc : IsLimit c := Under.equalizerForkIsLimit f g\n  let hc' : IsLimit ((tensorProd R S).mapCone c) :=\n    tensorProdMapEqualizerForkIsLimit f g\n  preservesLimit_of_preserves_limit_cone hc hc'\n\n"}
{"name":"CommRingCat.Under.instPreservesLimitsOfShapeUnderWalkingParallelPairTensorProdOfFlatCarrier","module":"Mathlib.Algebra.Category.Ring.Under.Limits","initialProofState":"R S : CommRingCat\ninst✝¹ : Algebra ↑R ↑S\ninst✝ : Module.Flat ↑R ↑S\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair (R.tensorProd S)","decl":"instance [Module.Flat R S] : PreservesLimitsOfShape WalkingParallelPair (tensorProd R S) where\n  preservesLimit {K} :=\n    preservesLimit_of_iso_diagram _ (diagramIsoParallelPair K).symm\n\n"}
{"name":"CommRingCat.Under.instPreservesFiniteLimitsUnderTensorProdOfFlatCarrier","module":"Mathlib.Algebra.Category.Ring.Under.Limits","initialProofState":"R S : CommRingCat\ninst✝¹ : Algebra ↑R ↑S\ninst✝ : Module.Flat ↑R ↑S\n⊢ CategoryTheory.Limits.PreservesFiniteLimits (R.tensorProd S)","decl":"instance [Module.Flat R S] : PreservesFiniteLimits (tensorProd R S) :=\n  preservesFiniteLimits_of_preservesEqualizers_and_finiteProducts (tensorProd R S)\n\n"}
{"name":"CommRingCat.Under.instPreservesFiniteProductsUnderPushout","module":"Mathlib.Algebra.Category.Ring.Under.Limits","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\n⊢ CategoryTheory.Limits.PreservesFiniteProducts (CategoryTheory.Under.pushout f)","decl":"/-- `Under.pushout f` preserves finite products. -/\ninstance : PreservesFiniteProducts (Under.pushout f) where\n  preserves _ :=\n    letI : Algebra R S := f.hom.toAlgebra\n    preservesLimitsOfShape_of_natIso (tensorProdIsoPushout R S)\n\n"}
{"name":"CommRingCat.Under.preservesFiniteLimits_of_flat","module":"Mathlib.Algebra.Category.Ring.Under.Limits","initialProofState":"R S : CommRingCat\nf : Quiver.Hom R S\nhf : (CommRingCat.Hom.hom f).Flat\n⊢ CategoryTheory.Limits.PreservesFiniteLimits (CategoryTheory.Under.pushout f)","decl":"/-- `Under.pushout f` preserves finite limits if `f` is flat. -/\nlemma preservesFiniteLimits_of_flat (hf : RingHom.Flat f.hom) :\n    PreservesFiniteLimits (Under.pushout f) where\n  preservesFiniteLimits _ :=\n    letI : Algebra R S := f.hom.toAlgebra\n    haveI : Module.Flat R S := hf\n    preservesLimitsOfShape_of_natIso (tensorProdIsoPushout R S)\n\n"}
