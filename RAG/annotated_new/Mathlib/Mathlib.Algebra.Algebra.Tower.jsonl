{"name":"Algebra.lsmul_coe","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nA : Type w\nB : Type u₁\nM : Type v₁\ninst✝¹¹ : CommSemiring R\ninst✝¹⁰ : Semiring A\ninst✝⁹ : Semiring B\ninst✝⁸ : Algebra R A\ninst✝⁷ : Algebra R B\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : Module A M\ninst✝³ : Module B M\ninst✝² : IsScalarTower R A M\ninst✝¹ : IsScalarTower R B M\ninst✝ : SMulCommClass A B M\na : A\n⊢ Eq ⇑((Algebra.lsmul R B M) a) fun x => HSMul.hSMul a x","decl":"@[simp]\ntheorem lsmul_coe (a : A) : (lsmul R B M a : M → M) = (a • ·) := rfl\n\n"}
{"name":"IsScalarTower.algebraMap_smul","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nA : Type w\nM : Type v₁\ninst✝⁵ : CommSemiring R\ninst✝⁴ : Semiring A\ninst✝³ : Algebra R A\ninst✝² : MulAction A M\ninst✝¹ : SMul R M\ninst✝ : IsScalarTower R A M\nr : R\nx : M\n⊢ Eq (HSMul.hSMul ((algebraMap R A) r) x) (HSMul.hSMul r x)","decl":"theorem algebraMap_smul [SMul R M] [IsScalarTower R A M] (r : R) (x : M) :\n    algebraMap R A r • x = r • x := by\n  rw [Algebra.algebraMap_eq_smul_one, smul_assoc, one_smul]\n\n"}
{"name":"IsScalarTower.of_algebraMap_smul","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nA : Type w\nM : Type v₁\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : MulAction A M\ninst✝ : SMul R M\nh : ∀ (r : R) (x : M), Eq (HSMul.hSMul ((algebraMap R A) r) x) (HSMul.hSMul r x)\n⊢ IsScalarTower R A M","decl":"variable {A} in\ntheorem of_algebraMap_smul [SMul R M] (h : ∀ (r : R) (x : M), algebraMap R A r • x = r • x) :\n    IsScalarTower R A M where\n  smul_assoc r a x := by rw [Algebra.smul_def, mul_smul, h]\n\n"}
{"name":"IsScalarTower.of_compHom","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nA : Type w\nM : Type v₁\ninst✝³ : CommSemiring R\ninst✝² : Semiring A\ninst✝¹ : Algebra R A\ninst✝ : MulAction A M\n⊢ IsScalarTower R A M","decl":"variable (R M) in\ntheorem of_compHom : letI := MulAction.compHom M (algebraMap R A : R →* A); IsScalarTower R A M :=\n  letI := MulAction.compHom M (algebraMap R A : R →* A); of_algebraMap_smul fun _ _ ↦ rfl\n\n"}
{"name":"IsScalarTower.of_algebraMap_eq","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\nA : Type w\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring S\ninst✝³ : Semiring A\ninst✝² : Algebra R S\ninst✝¹ : Algebra S A\ninst✝ : Algebra R A\nh : ∀ (x : R), Eq ((algebraMap R A) x) ((algebraMap S A) ((algebraMap R S) x))\n⊢ IsScalarTower R S A","decl":"theorem of_algebraMap_eq [Algebra R A]\n    (h : ∀ x, algebraMap R A x = algebraMap S A (algebraMap R S x)) : IsScalarTower R S A :=\n  ⟨fun x y z => by simp_rw [Algebra.smul_def, RingHom.map_mul, mul_assoc, h]⟩\n\n"}
{"name":"IsScalarTower.of_algebraMap_eq'","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\nA : Type w\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring S\ninst✝³ : Semiring A\ninst✝² : Algebra R S\ninst✝¹ : Algebra S A\ninst✝ : Algebra R A\nh : Eq (algebraMap R A) ((algebraMap S A).comp (algebraMap R S))\n⊢ IsScalarTower R S A","decl":"/-- See note [partially-applied ext lemmas]. -/\ntheorem of_algebraMap_eq' [Algebra R A]\n    (h : algebraMap R A = (algebraMap S A).comp (algebraMap R S)) : IsScalarTower R S A :=\n  of_algebraMap_eq <| RingHom.ext_iff.1 h\n\n"}
{"name":"IsScalarTower.algebraMap_eq","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\nA : Type w\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Semiring A\ninst✝³ : Algebra R S\ninst✝² : Algebra S A\ninst✝¹ : Algebra R A\ninst✝ : IsScalarTower R S A\n⊢ Eq (algebraMap R A) ((algebraMap S A).comp (algebraMap R S))","decl":"theorem algebraMap_eq : algebraMap R A = (algebraMap S A).comp (algebraMap R S) :=\n  RingHom.ext fun x => by\n    simp_rw [RingHom.comp_apply, Algebra.algebraMap_eq_smul_one, smul_assoc, one_smul]\n\n"}
{"name":"IsScalarTower.algebraMap_apply","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\nA : Type w\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Semiring A\ninst✝³ : Algebra R S\ninst✝² : Algebra S A\ninst✝¹ : Algebra R A\ninst✝ : IsScalarTower R S A\nx : R\n⊢ Eq ((algebraMap R A) x) ((algebraMap S A) ((algebraMap R S) x))","decl":"theorem algebraMap_apply (x : R) : algebraMap R A x = algebraMap S A (algebraMap R S x) := by\n  rw [algebraMap_eq R S A, RingHom.comp_apply]\n\n"}
{"name":"IsScalarTower.Algebra.ext","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"S : Type u\nA : Type v\ninst✝¹ : CommSemiring S\ninst✝ : Semiring A\nh1 h2 : Algebra S A\nh : ∀ (r : S) (x : A), Eq (letFun h1 fun I => HSMul.hSMul r x) (HSMul.hSMul r x)\n⊢ Eq h1 h2","decl":"@[ext]\ntheorem Algebra.ext {S : Type u} {A : Type v} [CommSemiring S] [Semiring A] (h1 h2 : Algebra S A)\n    (h : ∀ (r : S) (x : A), (by have I := h1; exact r • x) = r • x) : h1 = h2 :=\n  Algebra.algebra_ext _ _ fun r => by\n    simpa only [@Algebra.smul_def _ _ _ _ h1, @Algebra.smul_def _ _ _ _ h2, mul_one] using h r 1\n\n"}
{"name":"IsScalarTower.Algebra.ext_iff","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"S : Type u\nA : Type v\ninst✝¹ : CommSemiring S\ninst✝ : Semiring A\nh1 h2 : Algebra S A\n⊢ Iff (Eq h1 h2) (∀ (r : S) (x : A), Eq (letFun h1 fun I => HSMul.hSMul r x) (HSMul.hSMul r x))","decl":"@[ext]\ntheorem Algebra.ext {S : Type u} {A : Type v} [CommSemiring S] [Semiring A] (h1 h2 : Algebra S A)\n    (h : ∀ (r : S) (x : A), (by have I := h1; exact r • x) = r • x) : h1 = h2 :=\n  Algebra.algebra_ext _ _ fun r => by\n    simpa only [@Algebra.smul_def _ _ _ _ h1, @Algebra.smul_def _ _ _ _ h2, mul_one] using h r 1\n\n"}
{"name":"IsScalarTower.toAlgHom_apply","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\nA : Type w\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Semiring A\ninst✝³ : Algebra R S\ninst✝² : Algebra S A\ninst✝¹ : Algebra R A\ninst✝ : IsScalarTower R S A\ny : S\n⊢ Eq ((IsScalarTower.toAlgHom R S A) y) ((algebraMap S A) y)","decl":"theorem toAlgHom_apply (y : S) : toAlgHom R S A y = algebraMap S A y := rfl\n\n"}
{"name":"IsScalarTower.coe_toAlgHom","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\nA : Type w\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Semiring A\ninst✝³ : Algebra R S\ninst✝² : Algebra S A\ninst✝¹ : Algebra R A\ninst✝ : IsScalarTower R S A\n⊢ Eq (↑(IsScalarTower.toAlgHom R S A)) (algebraMap S A)","decl":"@[simp]\ntheorem coe_toAlgHom : ↑(toAlgHom R S A) = algebraMap S A :=\n  RingHom.ext fun _ => rfl\n\n"}
{"name":"IsScalarTower.coe_toAlgHom'","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\nA : Type w\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Semiring A\ninst✝³ : Algebra R S\ninst✝² : Algebra S A\ninst✝¹ : Algebra R A\ninst✝ : IsScalarTower R S A\n⊢ Eq ⇑(IsScalarTower.toAlgHom R S A) ⇑(algebraMap S A)","decl":"@[simp]\ntheorem coe_toAlgHom' : (toAlgHom R S A : S → A) = algebraMap S A := rfl\n\n"}
{"name":"AlgHom.map_algebraMap","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\nA : Type w\nB : Type u₁\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Semiring A\ninst✝⁷ : Semiring B\ninst✝⁶ : Algebra R S\ninst✝⁵ : Algebra S A\ninst✝⁴ : Algebra S B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\ninst✝¹ : IsScalarTower R S A\ninst✝ : IsScalarTower R S B\nf : AlgHom S A B\nr : R\n⊢ Eq (f ((algebraMap R A) r)) ((algebraMap R B) r)","decl":"@[simp]\ntheorem _root_.AlgHom.map_algebraMap (f : A →ₐ[S] B) (r : R) :\n    f (algebraMap R A r) = algebraMap R B r := by\n  rw [algebraMap_apply R S A r, f.commutes, ← algebraMap_apply R S B]\n\n"}
{"name":"AlgHom.comp_algebraMap_of_tower","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\nA : Type w\nB : Type u₁\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Semiring A\ninst✝⁷ : Semiring B\ninst✝⁶ : Algebra R S\ninst✝⁵ : Algebra S A\ninst✝⁴ : Algebra S B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\ninst✝¹ : IsScalarTower R S A\ninst✝ : IsScalarTower R S B\nf : AlgHom S A B\n⊢ Eq ((↑f).comp (algebraMap R A)) (algebraMap R B)","decl":"@[simp]\ntheorem _root_.AlgHom.comp_algebraMap_of_tower (f : A →ₐ[S] B) :\n    (f : A →+* B).comp (algebraMap R A) = algebraMap R B :=\n  RingHom.ext (AlgHom.map_algebraMap f)\n\n-- conflicts with IsScalarTower.Subalgebra\n"}
{"name":"IsScalarTower.subsemiring","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"S : Type v\nA : Type w\ninst✝² : CommSemiring S\ninst✝¹ : Semiring A\ninst✝ : Algebra S A\nU : Subsemiring S\n⊢ IsScalarTower (Subtype fun x => Membership.mem U x) S A","decl":"instance (priority := 999) subsemiring (U : Subsemiring S) : IsScalarTower U S A :=\n  of_algebraMap_eq fun _x => rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/12096): removed @[nolint instance_priority], linter not ported yet\n"}
{"name":"IsScalarTower.of_algHom","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring A\ninst✝² : CommSemiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgHom R A B\n⊢ IsScalarTower R A B","decl":"instance (priority := 999) of_algHom {R A B : Type*} [CommSemiring R] [CommSemiring A]\n    [CommSemiring B] [Algebra R A] [Algebra R B] (f : A →ₐ[R] B) :\n    @IsScalarTower R A B _ f.toRingHom.toAlgebra.toSMul _ :=\n  letI := (f : A →+* B).toAlgebra\n  of_algebraMap_eq fun x => (f.commutes x).symm\n\n"}
{"name":"AlgHom.restrictScalars_apply","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\nA : Type w\nB : Type u₁\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Semiring A\ninst✝⁷ : Semiring B\ninst✝⁶ : Algebra R S\ninst✝⁵ : Algebra S A\ninst✝⁴ : Algebra S B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\ninst✝¹ : IsScalarTower R S A\ninst✝ : IsScalarTower R S B\nf : AlgHom S A B\nx : A\n⊢ Eq ((AlgHom.restrictScalars R f) x) (f x)","decl":"theorem restrictScalars_apply (f : A →ₐ[S] B) (x : A) : f.restrictScalars R x = f x := rfl\n\n"}
{"name":"AlgHom.coe_restrictScalars","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\nA : Type w\nB : Type u₁\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Semiring A\ninst✝⁷ : Semiring B\ninst✝⁶ : Algebra R S\ninst✝⁵ : Algebra S A\ninst✝⁴ : Algebra S B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\ninst✝¹ : IsScalarTower R S A\ninst✝ : IsScalarTower R S B\nf : AlgHom S A B\n⊢ Eq ↑(AlgHom.restrictScalars R f) ↑f","decl":"@[simp]\ntheorem coe_restrictScalars (f : A →ₐ[S] B) : (f.restrictScalars R : A →+* B) = f := rfl\n\n"}
{"name":"AlgHom.coe_restrictScalars'","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\nA : Type w\nB : Type u₁\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Semiring A\ninst✝⁷ : Semiring B\ninst✝⁶ : Algebra R S\ninst✝⁵ : Algebra S A\ninst✝⁴ : Algebra S B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\ninst✝¹ : IsScalarTower R S A\ninst✝ : IsScalarTower R S B\nf : AlgHom S A B\n⊢ Eq ⇑(AlgHom.restrictScalars R f) ⇑f","decl":"@[simp]\ntheorem coe_restrictScalars' (f : A →ₐ[S] B) : (restrictScalars R f : A → B) = f := rfl\n\n"}
{"name":"AlgHom.restrictScalars_injective","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\nA : Type w\nB : Type u₁\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Semiring A\ninst✝⁷ : Semiring B\ninst✝⁶ : Algebra R S\ninst✝⁵ : Algebra S A\ninst✝⁴ : Algebra S B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\ninst✝¹ : IsScalarTower R S A\ninst✝ : IsScalarTower R S B\n⊢ Function.Injective (AlgHom.restrictScalars R)","decl":"theorem restrictScalars_injective :\n    Function.Injective (restrictScalars R : (A →ₐ[S] B) → A →ₐ[R] B) := fun _ _ h =>\n  AlgHom.ext (AlgHom.congr_fun h :)\n\n"}
{"name":"AlgEquiv.restrictScalars_apply","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\nA : Type w\nB : Type u₁\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Semiring A\ninst✝⁷ : Semiring B\ninst✝⁶ : Algebra R S\ninst✝⁵ : Algebra S A\ninst✝⁴ : Algebra S B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\ninst✝¹ : IsScalarTower R S A\ninst✝ : IsScalarTower R S B\nf : AlgEquiv S A B\nx : A\n⊢ Eq ((AlgEquiv.restrictScalars R f) x) (f x)","decl":"theorem restrictScalars_apply (f : A ≃ₐ[S] B) (x : A) : f.restrictScalars R x = f x := rfl\n\n"}
{"name":"AlgEquiv.coe_restrictScalars","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\nA : Type w\nB : Type u₁\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Semiring A\ninst✝⁷ : Semiring B\ninst✝⁶ : Algebra R S\ninst✝⁵ : Algebra S A\ninst✝⁴ : Algebra S B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\ninst✝¹ : IsScalarTower R S A\ninst✝ : IsScalarTower R S B\nf : AlgEquiv S A B\n⊢ Eq ↑(AlgEquiv.restrictScalars R f) ↑f","decl":"@[simp]\ntheorem coe_restrictScalars (f : A ≃ₐ[S] B) : (f.restrictScalars R : A ≃+* B) = f := rfl\n\n"}
{"name":"AlgEquiv.coe_restrictScalars'","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\nA : Type w\nB : Type u₁\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Semiring A\ninst✝⁷ : Semiring B\ninst✝⁶ : Algebra R S\ninst✝⁵ : Algebra S A\ninst✝⁴ : Algebra S B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\ninst✝¹ : IsScalarTower R S A\ninst✝ : IsScalarTower R S B\nf : AlgEquiv S A B\n⊢ Eq ⇑(AlgEquiv.restrictScalars R f) ⇑f","decl":"@[simp]\ntheorem coe_restrictScalars' (f : A ≃ₐ[S] B) : (restrictScalars R f : A → B) = f := rfl\n\n"}
{"name":"AlgEquiv.restrictScalars_injective","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\nA : Type w\nB : Type u₁\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Semiring A\ninst✝⁷ : Semiring B\ninst✝⁶ : Algebra R S\ninst✝⁵ : Algebra S A\ninst✝⁴ : Algebra S B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\ninst✝¹ : IsScalarTower R S A\ninst✝ : IsScalarTower R S B\n⊢ Function.Injective (AlgEquiv.restrictScalars R)","decl":"theorem restrictScalars_injective :\n    Function.Injective (restrictScalars R : (A ≃ₐ[S] B) → A ≃ₐ[R] B) := fun _ _ h =>\n  AlgEquiv.ext (AlgEquiv.congr_fun h :)\n\n"}
{"name":"Submodule.restrictScalars_span","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nA : Type w\nM : Type v₁\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nhsur : Function.Surjective ⇑(algebraMap R A)\nX : Set M\n⊢ Eq (Submodule.restrictScalars R (Submodule.span A X)) (Submodule.span R X)","decl":"/-- If `A` is an `R`-algebra such that the induced morphism `R →+* A` is surjective, then the\n`R`-module generated by a set `X` equals the `A`-module generated by `X`. -/\ntheorem restrictScalars_span (hsur : Function.Surjective (algebraMap R A)) (X : Set M) :\n    restrictScalars R (span A X) = span R X := by\n  refine ((span_le_restrictScalars R A X).antisymm fun m hm => ?_).symm\n  refine span_induction subset_span (zero_mem _) (fun _ _ _ _ => add_mem) (fun a m _ hm => ?_) hm\n  obtain ⟨r, rfl⟩ := hsur a\n  simpa [algebraMap_smul] using smul_mem _ r hm\n\n"}
{"name":"Submodule.coe_span_eq_span_of_surjective","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nA : Type w\nM : Type v₁\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nh : Function.Surjective ⇑(algebraMap R A)\ns : Set M\n⊢ Eq ↑(Submodule.span A s) ↑(Submodule.span R s)","decl":"theorem coe_span_eq_span_of_surjective (h : Function.Surjective (algebraMap R A)) (s : Set M) :\n    (Submodule.span A s : Set M) = Submodule.span R s :=\n  congr_arg ((↑) : Submodule R M → Set M) (Submodule.restrictScalars_span R A h s)\n\n"}
{"name":"Submodule.smul_mem_span_smul_of_mem","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\nA : Type w\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid A\ninst✝³ : Module R S\ninst✝² : Module S A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R S A\ns : Set S\nt : Set A\nk : S\nhks : Membership.mem (Submodule.span R s) k\nx : A\nhx : Membership.mem t x\n⊢ Membership.mem (Submodule.span R (HSMul.hSMul s t)) (HSMul.hSMul k x)","decl":"theorem smul_mem_span_smul_of_mem {s : Set S} {t : Set A} {k : S} (hks : k ∈ span R s) {x : A}\n    (hx : x ∈ t) : k • x ∈ span R (s • t) :=\n  span_induction (fun _ hc => subset_span <| Set.smul_mem_smul hc hx)\n    (by rw [zero_smul]; exact zero_mem _)\n    (fun c₁ c₂ _ _ ih₁ ih₂ => by rw [add_smul]; exact add_mem ih₁ ih₂)\n    (fun b c _ hc => by rw [IsScalarTower.smul_assoc]; exact smul_mem _ _ hc) hks\n\n"}
{"name":"Submodule.span_smul_of_span_eq_top","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\nA : Type w\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid A\ninst✝³ : Module R S\ninst✝² : Module S A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R S A\ns : Set S\nhs : Eq (Submodule.span R s) Top.top\nt : Set A\n⊢ Eq (Submodule.span R (HSMul.hSMul s t)) (Submodule.restrictScalars R (Submodule.span S t))","decl":"theorem span_smul_of_span_eq_top {s : Set S} (hs : span R s = ⊤) (t : Set A) :\n    span R (s • t) = (span S t).restrictScalars R :=\n  le_antisymm\n    (span_le.2 fun _x ⟨p, _hps, _q, hqt, hpqx⟩ ↦ hpqx ▸ (span S t).smul_mem p (subset_span hqt))\n    fun _ hp ↦ closure_induction (hx := hp) (zero_mem _) (fun _ _ _ _ ↦ add_mem) fun s0 y hy ↦ by\n      refine span_induction (fun x hx ↦ subset_span <| by exact ⟨x, hx, y, hy, rfl⟩) ?_ ?_ ?_\n        (hs ▸ mem_top : s0 ∈ span R s)\n      · rw [zero_smul]; apply zero_mem\n      · intro _ _ _ _; rw [add_smul]; apply add_mem\n      · intro r s0 _ hy; rw [IsScalarTower.smul_assoc]; exact smul_mem _ r hy\n\n-- The following two lemmas were originally used to prove `span_smul_of_span_eq_top`\n-- but are now not needed.\n"}
{"name":"Submodule.smul_mem_span_smul'","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\nA : Type w\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid A\ninst✝³ : Module R S\ninst✝² : Module S A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R S A\ns : Set S\nhs : Eq (Submodule.span R s) Top.top\nt : Set A\nk : S\nx : A\nhx : Membership.mem (Submodule.span R (HSMul.hSMul s t)) x\n⊢ Membership.mem (Submodule.span R (HSMul.hSMul s t)) (HSMul.hSMul k x)","decl":"theorem smul_mem_span_smul' {s : Set S} (hs : span R s = ⊤) {t : Set A} {k : S} {x : A}\n    (hx : x ∈ span R (s • t)) : k • x ∈ span R (s • t) := by\n  rw [span_smul_of_span_eq_top hs] at hx ⊢; exact (span S t).smul_mem k hx\n\n"}
{"name":"Submodule.smul_mem_span_smul","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\nA : Type w\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid A\ninst✝³ : Module R S\ninst✝² : Module S A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R S A\ns : Set S\nhs : Eq (Submodule.span R s) Top.top\nt : Set A\nk : S\nx : A\nhx : Membership.mem (Submodule.span R t) x\n⊢ Membership.mem (Submodule.span R (HSMul.hSMul s t)) (HSMul.hSMul k x)","decl":"theorem smul_mem_span_smul {s : Set S} (hs : span R s = ⊤) {t : Set A} {k : S} {x : A}\n    (hx : x ∈ span R t) : k • x ∈ span R (s • t) := by\n  rw [span_smul_of_span_eq_top hs]\n  exact (span S t).smul_mem k (span_le_restrictScalars R S t hx)\n\n"}
{"name":"Submodule.span_algebraMap_image","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\na : Set R\n⊢ Eq (Submodule.span R (Set.image (⇑(algebraMap R S)) a)) (Submodule.map (Algebra.linearMap R S) (Submodule.span R a))","decl":"/-- A variant of `Submodule.span_image` for `algebraMap`. -/\ntheorem span_algebraMap_image (a : Set R) :\n    Submodule.span R (algebraMap R S '' a) = (Submodule.span R a).map (Algebra.linearMap R S) :=\n  (Submodule.span_image <| Algebra.linearMap R S).trans rfl\n\n"}
{"name":"Submodule.span_algebraMap_image_of_tower","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\ninst✝⁶ : CommSemiring R\nS : Type u_1\nT : Type u_2\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Semiring T\ninst✝³ : Module R S\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\na : Set S\n⊢ Eq (Submodule.span R (Set.image (⇑(algebraMap S T)) a)) (Submodule.map (↑R (Algebra.linearMap S T)) (Submodule.span R a))","decl":"theorem span_algebraMap_image_of_tower {S T : Type*} [CommSemiring S] [Semiring T] [Module R S]\n    [Algebra R T] [Algebra S T] [IsScalarTower R S T] (a : Set S) :\n    Submodule.span R (algebraMap S T '' a) =\n      (Submodule.span R a).map ((Algebra.linearMap S T).restrictScalars R) :=\n  (Submodule.span_image <| (Algebra.linearMap S T).restrictScalars R).trans rfl\n\n"}
{"name":"Submodule.map_mem_span_algebraMap_image","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\ninst✝⁶ : CommSemiring R\nS : Type u_1\nT : Type u_2\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Semiring T\ninst✝³ : Algebra R S\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nx : S\na : Set S\nhx : Membership.mem (Submodule.span R a) x\n⊢ Membership.mem (Submodule.span R (Set.image (⇑(algebraMap S T)) a)) ((algebraMap S T) x)","decl":"theorem map_mem_span_algebraMap_image {S T : Type*} [CommSemiring S] [Semiring T] [Algebra R S]\n    [Algebra R T] [Algebra S T] [IsScalarTower R S T] (x : S) (a : Set S)\n    (hx : x ∈ Submodule.span R a) : algebraMap S T x ∈ Submodule.span R (algebraMap S T '' a) := by\n  rw [span_algebraMap_image_of_tower, mem_map]\n  exact ⟨x, hx, rfl⟩\n\n"}
{"name":"Algebra.lsmul_injective","module":"Mathlib.Algebra.Algebra.Tower","initialProofState":"R : Type u\nA : Type w\nB : Type u₁\nM : Type v₁\ninst✝¹² : CommSemiring R\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Semiring B\ninst✝⁹ : Algebra R A\ninst✝⁸ : Algebra R B\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : Module A M\ninst✝⁴ : Module B M\ninst✝³ : IsScalarTower R A M\ninst✝² : IsScalarTower R B M\ninst✝¹ : SMulCommClass A B M\ninst✝ : NoZeroSMulDivisors A M\nx : A\nhx : Ne x 0\n⊢ Function.Injective ⇑((Algebra.lsmul R B M) x)","decl":"theorem lsmul_injective [NoZeroSMulDivisors A M] {x : A} (hx : x ≠ 0) :\n    Function.Injective (lsmul R B M x) :=\n  smul_right_injective M hx\n\n"}
