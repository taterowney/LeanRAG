{"name":"Field.Emb.Cardinal.adjoin_basis_eq_top","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (IntermediateField.adjoin F (Set.range ⇑(Field.Emb.Cardinal.wellOrderedBasis F E))) Top.top","decl":"theorem adjoin_basis_eq_top : adjoin F (range b) = ⊤ :=\n  toSubalgebra_injective <| Subalgebra.toSubmodule_injective <| top_unique <|\n    (Basis.span_eq b).ge.trans <| (Algebra.span_le_adjoin F _).trans <| algebra_adjoin_le_adjoin _ _\n\n"}
{"name":"Field.Emb.Cardinal.noMaxOrder_rank_toType","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nrank_inf : Fact (LE.le Cardinal.aleph0 (Module.rank F E))\n⊢ NoMaxOrder (Module.rank F E).ord.toType","decl":"lemma noMaxOrder_rank_toType : NoMaxOrder ι := Cardinal.noMaxOrder Fact.out\n"}
{"name":"Field.Emb.Cardinal.isLeast_leastExt","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nrank_inf : Fact (LE.le Cardinal.aleph0 (Module.rank F E))\ninst✝ : Algebra.IsAlgebraic F E\ni : (Module.rank F E).ord.toType\n⊢ IsLeast (setOf fun k => Not (Membership.mem (IntermediateField.adjoin F (Set.image (Function.comp (⇑(Field.Emb.Cardinal.wellOrderedBasis F E)) (Field.Emb.Cardinal.leastExt F E)) (Set.Iio i))) ((Field.Emb.Cardinal.wellOrderedBasis F E) k))) (Field.Emb.Cardinal.leastExt F E i)","decl":"theorem isLeast_leastExt (i : ι) : IsLeast {k | b k ∉ E⟮<i⟯} (φ i) := by\n  rw [image_eq_range, leastExt, wellFounded_lt.fix_eq]\n  exact ⟨wellFounded_lt.min_mem _ _, fun _ ↦ (wellFounded_lt.min_le ·)⟩\n\n"}
{"name":"Field.Emb.Cardinal.strictMono_leastExt","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nrank_inf : Fact (LE.le Cardinal.aleph0 (Module.rank F E))\ninst✝ : Algebra.IsAlgebraic F E\n⊢ StrictMono (Field.Emb.Cardinal.leastExt F E)","decl":"theorem strictMono_leastExt : StrictMono φ := fun i j h ↦ by\n  have least := isLeast_leastExt (F := F) (E := E)\n  by_contra!\n  obtain eq | lt := this.eq_or_lt\n  · exact (least j).1 (subset_adjoin _ _ ⟨i, h, congr_arg b eq.symm⟩)\n  · refine ((least i).2 <| mt (adjoin.mono _ _ _ (image_mono ?_) ·) (least j).1).not_lt lt\n    exact fun k (hk : k < i) ↦ hk.trans h\n\n"}
{"name":"Field.Emb.Cardinal.adjoin_image_leastExt","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nrank_inf : Fact (LE.le Cardinal.aleph0 (Module.rank F E))\ninst✝ : Algebra.IsAlgebraic F E\ni : (Module.rank F E).ord.toType\n⊢ Eq (IntermediateField.adjoin F (Set.image (Function.comp (⇑(Field.Emb.Cardinal.wellOrderedBasis F E)) (Field.Emb.Cardinal.leastExt F E)) (Set.Iio i))) (IntermediateField.adjoin F (Set.image (⇑(Field.Emb.Cardinal.wellOrderedBasis F E)) (Set.Iio (Field.Emb.Cardinal.leastExt F E i))))","decl":"theorem adjoin_image_leastExt (i : ι) : E⟮<i⟯ = adjoin F (b '' Iio (φ i)) := by\n  refine le_antisymm (adjoin.mono _ _ _ ?_) (adjoin_le_iff.mpr ?_)\n  · rw [image_comp]; apply image_mono; rintro _ ⟨j, hj, rfl⟩; exact strictMono_leastExt hj\n  · rintro _ ⟨j, hj, rfl⟩; contrapose! hj; exact ((isLeast_leastExt i).2 hj).not_lt\n\n"}
{"name":"Field.Emb.Cardinal.iSup_adjoin_eq_top","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nrank_inf : Fact (LE.le Cardinal.aleph0 (Module.rank F E))\ninst✝ : Algebra.IsAlgebraic F E\n⊢ Eq (iSup fun i => IntermediateField.adjoin F (Set.image (Function.comp (⇑(Field.Emb.Cardinal.wellOrderedBasis F E)) (Field.Emb.Cardinal.leastExt F E)) (Set.Iio i))) Top.top","decl":"theorem iSup_adjoin_eq_top : ⨆ i : ι, E⟮<i⟯ = ⊤ := by\n  simp_rw [adjoin_image_leastExt, eq_top_iff, ← adjoin_basis_eq_top, adjoin_le_iff]\n  rintro _ ⟨i, rfl⟩\n  refine le_iSup (α := IntermediateField F E) _ (i⁺) (subset_adjoin _ _ ⟨i, ?_, rfl⟩)\n  exact (lt_succ i).trans_le strictMono_leastExt.le_apply\n\n"}
{"name":"Field.Emb.Cardinal.strictMono_filtration","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nrank_inf : Fact (LE.le Cardinal.aleph0 (Module.rank F E))\ninst✝ : Algebra.IsAlgebraic F E\n⊢ StrictMono fun x => IntermediateField.adjoin F (Set.image (Function.comp (⇑(Field.Emb.Cardinal.wellOrderedBasis F E)) (Field.Emb.Cardinal.leastExt F E)) (Set.Iio x))","decl":"theorem strictMono_filtration : StrictMono (E⟮<·⟯) :=\n  fun i _ h ↦ ⟨adjoin.mono _ _ _ (image_mono <| Iio_subset_Iio h.le),\n    fun incl ↦ (isLeast_leastExt i).1 (incl <| subset_adjoin _ _ ⟨i, h, rfl⟩)⟩\n\n"}
{"name":"Field.Emb.Cardinal.filtration_succ","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nrank_inf : Fact (LE.le Cardinal.aleph0 (Module.rank F E))\ninst✝ : Algebra.IsAlgebraic F E\ni : (Module.rank F E).ord.toType\n⊢ Eq (IntermediateField.adjoin F (Set.image (Function.comp (⇑(Field.Emb.Cardinal.wellOrderedBasis F E)) (Field.Emb.Cardinal.leastExt F E)) (Set.Iio (Order.succ i)))) (IntermediateField.restrictScalars F (IntermediateField.adjoin (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Set.image (Function.comp (⇑(Field.Emb.Cardinal.wellOrderedBasis F E)) (Field.Emb.Cardinal.leastExt F E)) (Set.Iio i))) x) (Singleton.singleton ((Field.Emb.Cardinal.wellOrderedBasis F E) (Field.Emb.Cardinal.leastExt F E i)))))","decl":"theorem filtration_succ (i : ι) : E⟮<i⁺⟯ = E⟮<i⟯⟮b (φ i)⟯.restrictScalars F := by\n  rw [Iio_succ, ← Iio_insert, image_insert_eq, ← union_singleton, adjoin_adjoin_left]; rfl\n\n"}
{"name":"Field.Emb.Cardinal.succEquiv_coherence","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nrank_inf : Fact (LE.le Cardinal.aleph0 (Module.rank F E))\ninst✝ : Algebra.IsAlgebraic F E\ni : (Module.rank F E).ord.toType\nf : AlgHom F (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Set.image (Function.comp (⇑(Field.Emb.Cardinal.wellOrderedBasis F E)) (Field.Emb.Cardinal.leastExt F E)) (Set.Iio (Order.succ i)))) x) (AlgebraicClosure E)\n⊢ Eq ((Field.Emb.Cardinal.succEquiv i) f).1 (f.comp (Subalgebra.inclusion ⋯))","decl":"theorem succEquiv_coherence (i : ι) (f) : (succEquiv i f).1 =\n    f.comp (Subalgebra.inclusion <| strictMono_filtration.monotone <| le_succ i) := by\n  ext; simp [succEquiv]; rfl -- slow rfl (type checking took 11.9s)\n\n"}
{"name":"Field.Emb.Cardinal.instFiniteDimensionalSubtypeMemIntermediateFieldAdjoinImageToTypeOrdRankCompCoeBasisWellOrderedBasisLeastExtIioSingletonSet","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsAlgebraic F E\ni : (Module.rank F E).ord.toType\n⊢ FiniteDimensional (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Set.image (Function.comp (⇑(Field.Emb.Cardinal.wellOrderedBasis F E)) (Field.Emb.Cardinal.leastExt F E)) (Set.Iio i))) x) (Subtype fun x => Membership.mem (IntermediateField.adjoin (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Set.image (Function.comp (⇑(Field.Emb.Cardinal.wellOrderedBasis F E)) (Field.Emb.Cardinal.leastExt F E)) (Set.Iio i))) x) (Singleton.singleton ((Field.Emb.Cardinal.wellOrderedBasis F E) (Field.Emb.Cardinal.leastExt F E i)))) x)","decl":"instance (i : ι) : FiniteDimensional (E⟮<i⟯) (E⟮<i⟯⟮b (φ i)⟯) :=\n  adjoin.finiteDimensional ((Algebra.IsAlgebraic.tower_top (K := F) _).isAlgebraic _).isIntegral\n\n"}
{"name":"Field.Emb.Cardinal.deg_lt_aleph0","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nrank_inf : Fact (LE.le Cardinal.aleph0 (Module.rank F E))\ninst✝ : Algebra.IsAlgebraic F E\ni : (Module.rank F E).ord.toType\n⊢ LT.lt (Cardinal.mk (Field.Emb (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Set.image (Function.comp (⇑(Field.Emb.Cardinal.wellOrderedBasis F E)) (Field.Emb.Cardinal.leastExt F E)) (Set.Iio i))) x) (Subtype fun x => Membership.mem (IntermediateField.adjoin (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Set.image (Function.comp (⇑(Field.Emb.Cardinal.wellOrderedBasis F E)) (Field.Emb.Cardinal.leastExt F E)) (Set.Iio i))) x) (Singleton.singleton ((Field.Emb.Cardinal.wellOrderedBasis F E) (Field.Emb.Cardinal.leastExt F E i)))) x))) Cardinal.aleph0","decl":"theorem deg_lt_aleph0 (i : ι) : #(X i) < ℵ₀ :=\n  (toNat_ne_zero.mp (Field.instNeZeroFinSepDegree (E⟮<i⟯) <| E⟮<i⟯⟮b (φ i)⟯).out).2\n\n"}
{"name":"Field.Emb.Cardinal.filtration_apply","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\ni : WithTop (Module.rank F E).ord.toType\n⊢ Eq (Field.Emb.Cardinal.filtration i) (WithTop.recTopCoe Top.top (fun x => IntermediateField.adjoin F (Set.image (fun a => (Field.Emb.Cardinal.wellOrderedBasis F E) (Field.Emb.Cardinal.leastExt F E a)) (Set.Iio x))) i)","decl":"open WithTop in\n/-- Extend the family `E⟮<i⟯, i : ι` by adjoining a top element. -/\n@[simps!] def filtration : WithTop ι ↪o IntermediateField F E :=\n  .ofStrictMono (fun i ↦ i.recTopCoe ⊤ (E⟮<·⟯)) fun i j h ↦ by\n    cases j\n    · obtain ⟨i, rfl⟩ := ne_top_iff_exists.mp h.ne\n      exact ⟨le_top, fun incl ↦ (isLeast_leastExt i).1 (incl trivial)⟩\n    · obtain ⟨i, rfl⟩ := ne_top_iff_exists.mp (h.trans <| coe_lt_top _).ne\n      exact strictMono_filtration (coe_lt_coe.mp h)\n\n"}
{"name":"Field.Emb.Cardinal.instIsSeparableSubtypeMemIntermediateFieldAdjoinImageToTypeOrdRankCompCoeBasisWellOrderedBasisLeastExtIioSingletonSet","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsSeparable F E\ni : (Module.rank F E).ord.toType\n⊢ Algebra.IsSeparable (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Set.image (Function.comp (⇑(Field.Emb.Cardinal.wellOrderedBasis F E)) (Field.Emb.Cardinal.leastExt F E)) (Set.Iio i))) x) (Subtype fun x => Membership.mem (IntermediateField.adjoin (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Set.image (Function.comp (⇑(Field.Emb.Cardinal.wellOrderedBasis F E)) (Field.Emb.Cardinal.leastExt F E)) (Set.Iio i))) x) (Singleton.singleton ((Field.Emb.Cardinal.wellOrderedBasis F E) (Field.Emb.Cardinal.leastExt F E i)))) x)","decl":"instance (i : ι) : Algebra.IsSeparable (E⟮<i⟯) (E⟮<i⟯⟮b (φ i)⟯) :=\n  have := Algebra.isSeparable_tower_top_of_isSeparable F (E⟮<i⟯) E\n  have : IsScalarTower (E⟮<i⟯) (E⟮<i⟯⟮b (φ i)⟯) E := .of_algebraMap_eq' rfl\n  Algebra.isSeparable_tower_bot_of_isSeparable _ _ E\n\n"}
{"name":"Field.Emb.Cardinal.two_le_deg","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nrank_inf : Fact (LE.le Cardinal.aleph0 (Module.rank F E))\ninst✝¹ : Algebra.IsAlgebraic F E\ninst✝ : Algebra.IsSeparable F E\ni : (Module.rank F E).ord.toType\n⊢ LE.le 2 (Cardinal.mk (Field.Emb (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Set.image (Function.comp (⇑(Field.Emb.Cardinal.wellOrderedBasis F E)) (Field.Emb.Cardinal.leastExt F E)) (Set.Iio i))) x) (Subtype fun x => Membership.mem (IntermediateField.adjoin (Subtype fun x => Membership.mem (IntermediateField.adjoin F (Set.image (Function.comp (⇑(Field.Emb.Cardinal.wellOrderedBasis F E)) (Field.Emb.Cardinal.leastExt F E)) (Set.Iio i))) x) (Singleton.singleton ((Field.Emb.Cardinal.wellOrderedBasis F E) (Field.Emb.Cardinal.leastExt F E i)))) x)))","decl":"open Field in\ntheorem two_le_deg (i : ι) : 2 ≤ #(X i) := by\n  rw [← Nat.cast_ofNat, ← toNat_le_iff_le_of_lt_aleph0 (nat_lt_aleph0 _) (deg_lt_aleph0 i),\n    toNat_natCast, ← Nat.card, ← finSepDegree, finSepDegree_eq_finrank_of_isSeparable, Nat.succ_le]\n  by_contra!\n  obtain ⟨x, hx⟩ := finrank_adjoin_simple_eq_one_iff.mp (this.antisymm Module.finrank_pos)\n  refine (isLeast_leastExt i).1 (hx ▸ ?_)\n  exact x.2\n\n"}
{"name":"Field.Emb.Cardinal.instInverseSystemWithTopToTypeOrdRankAlgHomSubtypeMemIntermediateFieldCoeOrderEmbeddingFiltrationAlgebraicClosureEmbFunctor","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ InverseSystem (Field.Emb.Cardinal.embFunctor F E)","decl":"instance : InverseSystem (embFunctor F E) where\n  map_self _ _ := rfl\n  map_map _ _ _ _ _ _ := rfl\n\n"}
{"name":"Field.Emb.Cardinal.equivSucc_coherence","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nrank_inf : Fact (LE.le Cardinal.aleph0 (Module.rank F E))\ninst✝ : Algebra.IsAlgebraic F E\ni : WithTop (Module.rank F E).ord.toType\nf : AlgHom F (Subtype fun x => Membership.mem (Field.Emb.Cardinal.filtration (Order.succ i)) x) (AlgebraicClosure E)\n⊢ Eq ((Field.Emb.Cardinal.equivSucc i) f).1 (Field.Emb.Cardinal.embFunctor F E ⋯ f)","decl":"theorem equivSucc_coherence (i f) : (equivSucc i f).1 = embFunctor F E (le_succ i) f := by\n  cases i; exacts [rfl, succEquiv_coherence _ f]\n\n"}
{"name":"Field.Emb.Cardinal.directed_filtration","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nrank_inf : Fact (LE.le Cardinal.aleph0 (Module.rank F E))\ninst✝ : Algebra.IsAlgebraic F E\ni : WithTop (Module.rank F E).ord.toType\n⊢ Directed (fun x1 x2 => LE.le x1 x2) fun j => Field.Emb.Cardinal.filtration ↑j","decl":"theorem directed_filtration : Directed (· ≤ ·) fun j : Iio i ↦ filtration j.1 :=\n  (filtration.monotone.comp <| Subtype.mono_coe _).directed_le\n\n"}
{"name":"Field.Emb.Cardinal.iSup_filtration","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nrank_inf : Fact (LE.le Cardinal.aleph0 (Module.rank F E))\ninst✝ : Algebra.IsAlgebraic F E\ni : WithTop (Module.rank F E).ord.toType\nhi : Order.IsSuccPrelimit i\n⊢ Eq (iSup fun j => Field.Emb.Cardinal.filtration ↑j) (Field.Emb.Cardinal.filtration i)","decl":"open WithTop in\ntheorem iSup_filtration : ⨆ j : Iio i, filtration j = filtration i := by\n  cases i\n  · rw [← range_coe, iSup_range']; exact iSup_adjoin_eq_top\n  refine (iSup_le fun j ↦ filtration.monotone (mem_Iio.1 j.2).le).antisymm (adjoin_le_iff.2 ?_)\n  rintro _ ⟨j, hj, rfl⟩\n  refine le_iSup (α := IntermediateField F E) _ ⟨j⁺, ?_⟩ (subset_adjoin F _ ?_)\n  exacts [⟨j, lt_succ j, rfl⟩, hi.succ_lt (coe_lt_coe.mpr hj)]\n\n"}
{"name":"Field.Emb.Cardinal.eq_bot_of_not_nonempty","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nrank_inf : Fact (LE.le Cardinal.aleph0 (Module.rank F E))\ninst✝ : Algebra.IsAlgebraic F E\ni : WithTop (Module.rank F E).ord.toType\nhi✝ : Order.IsSuccPrelimit i\nhi : Not (Nonempty ↑(Set.Iio i))\n⊢ Eq (Field.Emb.Cardinal.filtration i) Bot.bot","decl":"lemma eq_bot_of_not_nonempty (hi : ¬ Nonempty (Iio i)) : filtration i = ⊥ := by\n  cases i\n  · have := mk_ne_zero_iff.mp (rank_pos.trans_eq (mk_ord_toType <| Module.rank F E).symm).ne'\n    rw [← range_coe] at hi; exact (hi inferInstance).elim\n  · exact bot_unique <| adjoin_le_iff.mpr fun _ ⟨j, hj, _⟩ ↦ (hi ⟨j, coe_lt_coe.mpr hj⟩).elim\n\n"}
{"name":"Field.Emb.Cardinal.equivLim_coherence","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nrank_inf : Fact (LE.le Cardinal.aleph0 (Module.rank F E))\ninst✝ : Algebra.IsAlgebraic F E\ni : WithTop (Module.rank F E).ord.toType\nhi : Order.IsSuccPrelimit i\nx : AlgHom F (Subtype fun x => Membership.mem (Field.Emb.Cardinal.filtration i) x) (AlgebraicClosure E)\nl : ↑(Set.Iio i)\n⊢ Eq (↑((Field.Emb.Cardinal.equivLim hi) x) l) (Field.Emb.Cardinal.embFunctor F E ⋯ x)","decl":"theorem equivLim_coherence (x l) : (equivLim hi x).1 l = embFunctor F E (mem_Iio.mp l.2).le x :=\n  rfl\n\n"}
{"name":"Field.Emb.cardinal_eq_two_pow_rank","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsSeparable F E\nrank_inf : LE.le Cardinal.aleph0 (Module.rank F E)\n⊢ Eq (Cardinal.mk (Field.Emb F E)) (HPow.hPow 2 (Module.rank F E))","decl":"theorem cardinal_eq_two_pow_rank [Algebra.IsSeparable F E]\n    (rank_inf : ℵ₀ ≤ Module.rank F E) : #(Field.Emb F E) = 2 ^ Module.rank F E := by\n  haveI := Fact.mk rank_inf\n  rw [Emb.Cardinal.embEquivPi.cardinal_eq, mk_pi]\n  apply le_antisymm\n  · rw [← power_eq_two_power rank_inf (nat_lt_aleph0 2).le rank_inf]\n    conv_rhs => rw [← mk_ord_toType (Module.rank F E), ← prod_const']\n    exact prod_le_prod _ _ fun i ↦ (Emb.Cardinal.deg_lt_aleph0 _).le\n  · conv_lhs => rw [← mk_ord_toType (Module.rank F E), ← prod_const']\n    exact prod_le_prod _ _ Emb.Cardinal.two_le_deg\n\n"}
{"name":"Field.Emb.cardinal_eq_of_isSeparable","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsSeparable F E\n⊢ Eq (Cardinal.mk (Field.Emb F E)) ((fun c => ite (LE.le Cardinal.aleph0 c) (HPow.hPow 2 c) c) (Module.rank F E))","decl":"theorem cardinal_eq_of_isSeparable [Algebra.IsSeparable F E] :\n    #(Field.Emb F E) = (fun c ↦ if ℵ₀ ≤ c then 2 ^ c else c) (Module.rank F E) := by\n  dsimp only; split_ifs with h\n  · exact cardinal_eq_two_pow_rank h\n  rw [not_le, ← IsNoetherian.iff_rank_lt_aleph0] at h\n  rw [← Module.finrank_eq_rank, ← toNat_eq_iff Module.finrank_pos.ne',\n    ← Nat.card, ← finSepDegree, finSepDegree_eq_finrank_of_isSeparable]\n\n"}
{"name":"Field.Emb.cardinal_eq_two_pow_sepDegree","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsAlgebraic F E\nrank_inf : LE.le Cardinal.aleph0 (Field.sepDegree F E)\n⊢ Eq (Cardinal.mk (Field.Emb F E)) (HPow.hPow 2 (Field.sepDegree F E))","decl":"theorem cardinal_eq_two_pow_sepDegree [Algebra.IsAlgebraic F E]\n    (rank_inf : ℵ₀ ≤ sepDegree F E) : #(Field.Emb F E) = 2 ^ sepDegree F E := by\n  rw [← cardinal_separableClosure, cardinal_eq_two_pow_rank rank_inf]\n  rfl\n\n"}
{"name":"Field.Emb.cardinal_eq","module":"Mathlib.FieldTheory.CardinalEmb","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsAlgebraic F E\n⊢ Eq (Cardinal.mk (Field.Emb F E)) ((fun c => ite (LE.le Cardinal.aleph0 c) (HPow.hPow 2 c) c) (Field.sepDegree F E))","decl":"theorem cardinal_eq [Algebra.IsAlgebraic F E] :\n    #(Field.Emb F E) = (fun c ↦ if ℵ₀ ≤ c then 2 ^ c else c) (sepDegree F E) := by\n  rw [← cardinal_separableClosure, cardinal_eq_of_isSeparable]; rfl\n\n"}
