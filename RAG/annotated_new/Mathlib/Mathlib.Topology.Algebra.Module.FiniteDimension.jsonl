{"name":"instFiniteDimensionalContinuousLinearMapId","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ¹Â¹ : Field ğ•œ\ninstâœÂ¹â° : TopologicalSpace ğ•œ\ninstâœâ¹ : AddCommGroup E\ninstâœâ¸ : Module ğ•œ E\ninstâœâ· : TopologicalSpace E\ninstâœâ¶ : AddCommGroup F\ninstâœâµ : Module ğ•œ F\ninstâœâ´ : TopologicalSpace F\ninstâœÂ³ : TopologicalAddGroup F\ninstâœÂ² : ContinuousSMul ğ•œ F\ninstâœÂ¹ : FiniteDimensional ğ•œ E\ninstâœ : FiniteDimensional ğ•œ F\nâŠ¢ FiniteDimensional ğ•œ (ContinuousLinearMap (RingHom.id ğ•œ) E F)","decl":"/-- The space of continuous linear maps between finite-dimensional spaces is finite-dimensional. -/\ninstance [FiniteDimensional ğ•œ E] [FiniteDimensional ğ•œ F] : FiniteDimensional ğ•œ (E â†’L[ğ•œ] F) :=\n  FiniteDimensional.of_injective (ContinuousLinearMap.coeLM ğ•œ : (E â†’L[ğ•œ] F) â†’â‚—[ğ•œ] E â†’â‚—[ğ•œ] F)\n    ContinuousLinearMap.coe_injective\n\n"}
{"name":"unique_topology_of_t2","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nt : TopologicalSpace ğ•œ\nhâ‚ : TopologicalAddGroup ğ•œ\nhâ‚‚ : ContinuousSMul ğ•œ ğ•œ\nhâ‚ƒ : T2Space ğ•œ\nâŠ¢ Eq t UniformSpace.toTopologicalSpace","decl":"/-- If `ğ•œ` is a nontrivially normed field, any T2 topology on `ğ•œ` which makes it a topological\nvector space over itself (with the norm topology) is *equal* to the norm topology. -/\ntheorem unique_topology_of_t2 {t : TopologicalSpace ğ•œ} (hâ‚ : @TopologicalAddGroup ğ•œ t _)\n    (hâ‚‚ : @ContinuousSMul ğ•œ ğ•œ _ hnorm.toUniformSpace.toTopologicalSpace t) (hâ‚ƒ : @T2Space ğ•œ t) :\n    t = hnorm.toUniformSpace.toTopologicalSpace := by\n  -- Let `ğ“£â‚€` denote the topology on `ğ•œ` induced by the norm, and `ğ“£` be any T2 vector\n  -- topology on `ğ•œ`. To show that `ğ“£â‚€ = ğ“£`, it suffices to show that they have the same\n  -- neighborhoods of 0.\n  refine TopologicalAddGroup.ext hâ‚ inferInstance (le_antisymm ?_ ?_)\n  Â· -- To show `ğ“£ â‰¤ ğ“£â‚€`, we have to show that closed balls are `ğ“£`-neighborhoods of 0.\n    rw [Metric.nhds_basis_closedBall.ge_iff]\n    -- Let `Îµ > 0`. Since `ğ•œ` is nontrivially normed, we have `0 < â€–Î¾â‚€â€– < Îµ` for some `Î¾â‚€ : ğ•œ`.\n    intro Îµ hÎµ\n    rcases NormedField.exists_norm_lt ğ•œ hÎµ with âŸ¨Î¾â‚€, hÎ¾â‚€, hÎ¾â‚€ÎµâŸ©\n    -- Since `Î¾â‚€ â‰  0` and `ğ“£` is T2, we know that `{Î¾â‚€}á¶œ` is a `ğ“£`-neighborhood of 0.\n    -- Porting note: added `mem_compl_singleton_iff.mpr`\n    have : {Î¾â‚€}á¶œ âˆˆ @nhds ğ•œ t 0 := IsOpen.mem_nhds isOpen_compl_singleton <|\n      mem_compl_singleton_iff.mpr <| Ne.symm <| norm_ne_zero_iff.mp hÎ¾â‚€.ne.symm\n    -- Thus, its balanced core `ğ“‘` is too. Let's show that the closed ball of radius `Îµ` contains\n    -- `ğ“‘`, which will imply that the closed ball is indeed a `ğ“£`-neighborhood of 0.\n    have : balancedCore ğ•œ {Î¾â‚€}á¶œ âˆˆ @nhds ğ•œ t 0 := balancedCore_mem_nhds_zero this\n    refine mem_of_superset this fun Î¾ hÎ¾ => ?_\n    -- Let `Î¾ âˆˆ ğ“‘`. We want to show `â€–Î¾â€– < Îµ`. If `Î¾ = 0`, this is trivial.\n    by_cases hÎ¾0 : Î¾ = 0\n    Â· rw [hÎ¾0]\n      exact Metric.mem_closedBall_self hÎµ.le\n    Â· rw [mem_closedBall_zero_iff]\n      -- Now suppose `Î¾ â‰  0`. By contradiction, let's assume `Îµ < â€–Î¾â€–`, and show that\n      -- `Î¾â‚€ âˆˆ ğ“‘ âŠ† {Î¾â‚€}á¶œ`, which is a contradiction.\n      by_contra! h\n      suffices (Î¾â‚€ * Î¾â»Â¹) â€¢ Î¾ âˆˆ balancedCore ğ•œ {Î¾â‚€}á¶œ by\n        rw [smul_eq_mul ğ•œ, mul_assoc, inv_mul_cancelâ‚€ hÎ¾0, mul_one] at this\n        exact not_mem_compl_iff.mpr (mem_singleton Î¾â‚€) ((balancedCore_subset _) this)\n      -- For that, we use that `ğ“‘` is balanced : since `â€–Î¾â‚€â€– < Îµ < â€–Î¾â€–`, we have `â€–Î¾â‚€ / Î¾â€– â‰¤ 1`,\n      -- hence `Î¾â‚€ = (Î¾â‚€ / Î¾) â€¢ Î¾ âˆˆ ğ“‘` because `Î¾ âˆˆ ğ“‘`.\n      refine (balancedCore_balanced _).smul_mem ?_ hÎ¾\n      rw [norm_mul, norm_inv, mul_inv_le_iffâ‚€ (norm_pos_iff.mpr hÎ¾0), one_mul]\n      exact (hÎ¾â‚€Îµ.trans h).le\n  Â· -- Finally, to show `ğ“£â‚€ â‰¤ ğ“£`, we simply argue that `id = (fun x â†¦ x â€¢ 1)` is continuous from\n    -- `(ğ•œ, ğ“£â‚€)` to `(ğ•œ, ğ“£)` because `(â€¢) : (ğ•œ, ğ“£â‚€) Ã— (ğ•œ, ğ“£) â†’ (ğ•œ, ğ“£)` is continuous.\n    calc\n      @nhds ğ•œ hnorm.toUniformSpace.toTopologicalSpace 0 =\n          map id (@nhds ğ•œ hnorm.toUniformSpace.toTopologicalSpace 0) :=\n        map_id.symm\n      _ = map (fun x => id x â€¢ (1 : ğ•œ)) (@nhds ğ•œ hnorm.toUniformSpace.toTopologicalSpace 0) := by\n        conv_rhs =>\n          congr\n          ext\n          rw [smul_eq_mul, mul_one]\n      _ â‰¤ @nhds ğ•œ t ((0 : ğ•œ) â€¢ (1 : ğ•œ)) :=\n        (@Tendsto.smul_const _ _ _ hnorm.toUniformSpace.toTopologicalSpace t _ _ _ _ _\n          tendsto_id (1 : ğ•œ))\n      _ = @nhds ğ•œ t 0 := by rw [zero_smul]\n\n"}
{"name":"LinearMap.continuous_of_isClosed_ker","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousSMul ğ•œ E\nl : LinearMap (RingHom.id ğ•œ) E ğ•œ\nhl : IsClosed â†‘(LinearMap.ker l)\nâŠ¢ Continuous â‡‘l","decl":"/-- Any linear form on a topological vector space over a nontrivially normed field is continuous if\n    its kernel is closed. -/\ntheorem LinearMap.continuous_of_isClosed_ker (l : E â†’â‚—[ğ•œ] ğ•œ)\n    (hl : IsClosed (LinearMap.ker l : Set E)) :\n    Continuous l := by\n  -- `l` is either constant or surjective. If it is constant, the result is trivial.\n  by_cases H : finrank ğ•œ (LinearMap.range l) = 0\n  Â· rw [Submodule.finrank_eq_zero, LinearMap.range_eq_bot] at H\n    rw [H]\n    exact continuous_zero\n  Â· -- In the case where `l` is surjective, we factor it as `Ï† : (E â§¸ l.ker) â‰ƒâ‚—[ğ•œ] ğ•œ`. Note that\n    -- `E â§¸ l.ker` is T2 since `l.ker` is closed.\n    have : finrank ğ•œ (LinearMap.range l) = 1 :=\n      le_antisymm (finrank_self ğ•œ â–¸ l.range.finrank_le) (zero_lt_iff.mpr H)\n    have hi : Function.Injective ((LinearMap.ker l).liftQ l (le_refl _)) := by\n      rw [â† LinearMap.ker_eq_bot]\n      exact Submodule.ker_liftQ_eq_bot _ _ _ (le_refl _)\n    have hs : Function.Surjective ((LinearMap.ker l).liftQ l (le_refl _)) := by\n      rw [â† LinearMap.range_eq_top, Submodule.range_liftQ]\n      exact Submodule.eq_top_of_finrank_eq ((finrank_self ğ•œ).symm â–¸ this)\n    let Ï† : (E â§¸ LinearMap.ker l) â‰ƒâ‚—[ğ•œ] ğ•œ :=\n      LinearEquiv.ofBijective ((LinearMap.ker l).liftQ l (le_refl _)) âŸ¨hi, hsâŸ©\n    have hlÏ† : (l : E â†’ ğ•œ) = Ï† âˆ˜ (LinearMap.ker l).mkQ := by ext; rfl\n    -- Since the quotient map `E â†’â‚—[ğ•œ] (E â§¸ l.ker)` is continuous, the continuity of `l` will follow\n    -- form the continuity of `Ï†`.\n    suffices Continuous Ï†.toEquiv by\n      rw [hlÏ†]\n      exact this.comp continuous_quot_mk\n    -- The pullback by `Ï†.symm` of the quotient topology is a T2 topology on `ğ•œ`, because `Ï†.symm`\n    -- is injective. Since `Ï†.symm` is linear, it is also a vector space topology.\n    -- Hence, we know that it is equal to the topology induced by the norm.\n    have : induced Ï†.toEquiv.symm inferInstance = hnorm.toUniformSpace.toTopologicalSpace := by\n      refine unique_topology_of_t2 (topologicalAddGroup_induced Ï†.symm.toLinearMap)\n        (continuousSMul_induced Ï†.symm.toMulActionHom) ?_\n      -- Porting note: was `rw [t2Space_iff]`\n      refine (@t2Space_iff ğ•œ (induced (â†‘(LinearEquiv.toEquiv Ï†).symm) inferInstance)).mpr ?_\n      exact fun x y hxy =>\n        @separated_by_continuous _ _ (induced _ _) _ _ _ continuous_induced_dom _ _\n          (Ï†.toEquiv.symm.injective.ne hxy)\n    -- Finally, the pullback by `Ï†.symm` is exactly the pushforward by `Ï†`, so we have to prove\n    -- that `Ï†` is continuous when `ğ•œ` is endowed with the pushforward by `Ï†` of the quotient\n    -- topology, which is trivial by definition of the pushforward.\n    rw [this.symm, Equiv.induced_symm]\n    exact continuous_coinduced_rng\n\n"}
{"name":"LinearMap.continuous_iff_isClosed_ker","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousSMul ğ•œ E\nl : LinearMap (RingHom.id ğ•œ) E ğ•œ\nâŠ¢ Iff (Continuous â‡‘l) (IsClosed â†‘(LinearMap.ker l))","decl":"/-- Any linear form on a topological vector space over a nontrivially normed field is continuous if\n    and only if its kernel is closed. -/\ntheorem LinearMap.continuous_iff_isClosed_ker (l : E â†’â‚—[ğ•œ] ğ•œ) :\n    Continuous l â†” IsClosed (LinearMap.ker l : Set E) :=\n  âŸ¨fun h => isClosed_singleton.preimage h, l.continuous_of_isClosed_kerâŸ©\n\n"}
{"name":"LinearMap.continuous_of_nonzero_on_open","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousSMul ğ•œ E\nl : LinearMap (RingHom.id ğ•œ) E ğ•œ\ns : Set E\nhsâ‚ : IsOpen s\nhsâ‚‚ : s.Nonempty\nhsâ‚ƒ : âˆ€ (x : E), Membership.mem s x â†’ Ne (l x) 0\nâŠ¢ Continuous â‡‘l","decl":"/-- Over a nontrivially normed field, any linear form which is nonzero on a nonempty open set is\n    automatically continuous. -/\ntheorem LinearMap.continuous_of_nonzero_on_open (l : E â†’â‚—[ğ•œ] ğ•œ) (s : Set E) (hsâ‚ : IsOpen s)\n    (hsâ‚‚ : s.Nonempty) (hsâ‚ƒ : âˆ€ x âˆˆ s, l x â‰  0) : Continuous l := by\n  refine l.continuous_of_isClosed_ker (l.isClosed_or_dense_ker.resolve_right fun hl => ?_)\n  rcases hsâ‚‚ with âŸ¨x, hxâŸ©\n  have : x âˆˆ interior (LinearMap.ker l : Set E)á¶œ := by\n    rw [mem_interior_iff_mem_nhds]\n    exact mem_of_superset (hsâ‚.mem_nhds hx) hsâ‚ƒ\n  rwa [hl.interior_compl] at this\n\n"}
{"name":"LinearMap.continuous_of_finiteDimensional","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹Â² : AddCommGroup E\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : TopologicalSpace E\ninstâœâ¹ : TopologicalAddGroup E\ninstâœâ¸ : ContinuousSMul ğ•œ E\nF' : Type x\ninstâœâ· : AddCommGroup F'\ninstâœâ¶ : Module ğ•œ F'\ninstâœâµ : TopologicalSpace F'\ninstâœâ´ : TopologicalAddGroup F'\ninstâœÂ³ : ContinuousSMul ğ•œ F'\ninstâœÂ² : CompleteSpace ğ•œ\ninstâœÂ¹ : T2Space E\ninstâœ : FiniteDimensional ğ•œ E\nf : LinearMap (RingHom.id ğ•œ) E F'\nâŠ¢ Continuous â‡‘f","decl":"/-- Any linear map on a finite dimensional space over a complete field is continuous. -/\ntheorem LinearMap.continuous_of_finiteDimensional [T2Space E] [FiniteDimensional ğ•œ E]\n    (f : E â†’â‚—[ğ•œ] F') : Continuous f := by\n  -- for the proof, go to a model vector space `b â†’ ğ•œ` thanks to `continuous_equivFun_basis`, and\n  -- argue that all linear maps there are continuous.\n  let b := Basis.ofVectorSpace ğ•œ E\n  have A : Continuous b.equivFun := continuous_equivFun_basis_aux b\n  have B : Continuous (f.comp (b.equivFun.symm : (Basis.ofVectorSpaceIndex ğ•œ E â†’ ğ•œ) â†’â‚—[ğ•œ] E)) :=\n    LinearMap.continuous_on_pi _\n  have :\n    Continuous\n      (f.comp (b.equivFun.symm : (Basis.ofVectorSpaceIndex ğ•œ E â†’ ğ•œ) â†’â‚—[ğ•œ] E) âˆ˜ b.equivFun) :=\n    B.comp A\n  convert this\n  ext x\n  dsimp\n  rw [Basis.equivFun_symm_apply, Basis.sum_repr]\n\n"}
{"name":"LinearMap.continuousLinearMapClassOfFiniteDimensional","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹Â² : AddCommGroup E\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : TopologicalSpace E\ninstâœâ¹ : TopologicalAddGroup E\ninstâœâ¸ : ContinuousSMul ğ•œ E\nF' : Type x\ninstâœâ· : AddCommGroup F'\ninstâœâ¶ : Module ğ•œ F'\ninstâœâµ : TopologicalSpace F'\ninstâœâ´ : TopologicalAddGroup F'\ninstâœÂ³ : ContinuousSMul ğ•œ F'\ninstâœÂ² : CompleteSpace ğ•œ\ninstâœÂ¹ : T2Space E\ninstâœ : FiniteDimensional ğ•œ E\nâŠ¢ ContinuousLinearMapClass (LinearMap (RingHom.id ğ•œ) E F') ğ•œ E F'","decl":"instance LinearMap.continuousLinearMapClassOfFiniteDimensional [T2Space E] [FiniteDimensional ğ•œ E] :\n    ContinuousLinearMapClass (E â†’â‚—[ğ•œ] F') ğ•œ E F' :=\n  { LinearMap.semilinearMapClass with map_continuous := fun f => f.continuous_of_finiteDimensional }\n\n"}
{"name":"continuous_equivFun_basis","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâ· : AddCommGroup E\ninstâœâ¶ : Module ğ•œ E\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : TopologicalAddGroup E\ninstâœÂ³ : ContinuousSMul ğ•œ E\ninstâœÂ² : CompleteSpace ğ•œ\ninstâœÂ¹ : T2Space E\nÎ¹ : Type u_1\ninstâœ : Finite Î¹\nÎ¾ : Basis Î¹ ğ•œ E\nâŠ¢ Continuous â‡‘Î¾.equivFun","decl":"/-- In finite dimensions over a non-discrete complete normed field, the canonical identification\n(in terms of a basis) with `ğ•œ^n` (endowed with the product topology) is continuous.\nThis is the key fact which makes all linear maps from a T2 finite dimensional TVS over such a field\ncontinuous (see `LinearMap.continuous_of_finiteDimensional`), which in turn implies that all\nnorms are equivalent in finite dimensions. -/\ntheorem continuous_equivFun_basis [T2Space E] {Î¹ : Type*} [Finite Î¹] (Î¾ : Basis Î¹ ğ•œ E) :\n    Continuous Î¾.equivFun :=\n  haveI : FiniteDimensional ğ•œ E := .of_fintype_basis Î¾\n  Î¾.equivFun.toLinearMap.continuous_of_finiteDimensional\n\n"}
{"name":"LinearMap.coe_toContinuousLinearMap'","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹Â² : AddCommGroup E\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : TopologicalSpace E\ninstâœâ¹ : TopologicalAddGroup E\ninstâœâ¸ : ContinuousSMul ğ•œ E\nF' : Type x\ninstâœâ· : AddCommGroup F'\ninstâœâ¶ : Module ğ•œ F'\ninstâœâµ : TopologicalSpace F'\ninstâœâ´ : TopologicalAddGroup F'\ninstâœÂ³ : ContinuousSMul ğ•œ F'\ninstâœÂ² : CompleteSpace ğ•œ\ninstâœÂ¹ : T2Space E\ninstâœ : FiniteDimensional ğ•œ E\nf : LinearMap (RingHom.id ğ•œ) E F'\nâŠ¢ Eq â‡‘(LinearMap.toContinuousLinearMap f) â‡‘f","decl":"@[simp]\ntheorem coe_toContinuousLinearMap' (f : E â†’â‚—[ğ•œ] F') : â‡‘(LinearMap.toContinuousLinearMap f) = f :=\n  rfl\n\n"}
{"name":"LinearMap.coe_toContinuousLinearMap","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹Â² : AddCommGroup E\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : TopologicalSpace E\ninstâœâ¹ : TopologicalAddGroup E\ninstâœâ¸ : ContinuousSMul ğ•œ E\nF' : Type x\ninstâœâ· : AddCommGroup F'\ninstâœâ¶ : Module ğ•œ F'\ninstâœâµ : TopologicalSpace F'\ninstâœâ´ : TopologicalAddGroup F'\ninstâœÂ³ : ContinuousSMul ğ•œ F'\ninstâœÂ² : CompleteSpace ğ•œ\ninstâœÂ¹ : T2Space E\ninstâœ : FiniteDimensional ğ•œ E\nf : LinearMap (RingHom.id ğ•œ) E F'\nâŠ¢ Eq (â†‘(LinearMap.toContinuousLinearMap f)) f","decl":"@[simp]\ntheorem coe_toContinuousLinearMap (f : E â†’â‚—[ğ•œ] F') :\n    ((LinearMap.toContinuousLinearMap f) : E â†’â‚—[ğ•œ] F') = f :=\n  rfl\n\n"}
{"name":"LinearMap.coe_toContinuousLinearMap_symm","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹Â² : AddCommGroup E\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : TopologicalSpace E\ninstâœâ¹ : TopologicalAddGroup E\ninstâœâ¸ : ContinuousSMul ğ•œ E\nF' : Type x\ninstâœâ· : AddCommGroup F'\ninstâœâ¶ : Module ğ•œ F'\ninstâœâµ : TopologicalSpace F'\ninstâœâ´ : TopologicalAddGroup F'\ninstâœÂ³ : ContinuousSMul ğ•œ F'\ninstâœÂ² : CompleteSpace ğ•œ\ninstâœÂ¹ : T2Space E\ninstâœ : FiniteDimensional ğ•œ E\nâŠ¢ Eq (â‡‘LinearMap.toContinuousLinearMap.symm) ContinuousLinearMap.toLinearMap","decl":"@[simp]\ntheorem coe_toContinuousLinearMap_symm :\n    â‡‘(toContinuousLinearMap : (E â†’â‚—[ğ•œ] F') â‰ƒâ‚—[ğ•œ] E â†’L[ğ•œ] F').symm =\n      ((â†‘) : (E â†’L[ğ•œ] F') â†’ E â†’â‚—[ğ•œ] F') :=\n  rfl\n\n"}
{"name":"LinearMap.det_toContinuousLinearMap","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâ· : AddCommGroup E\ninstâœâ¶ : Module ğ•œ E\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : TopologicalAddGroup E\ninstâœÂ³ : ContinuousSMul ğ•œ E\ninstâœÂ² : CompleteSpace ğ•œ\ninstâœÂ¹ : T2Space E\ninstâœ : FiniteDimensional ğ•œ E\nf : LinearMap (RingHom.id ğ•œ) E E\nâŠ¢ Eq (LinearMap.toContinuousLinearMap f).det (LinearMap.det f)","decl":"@[simp]\ntheorem det_toContinuousLinearMap (f : E â†’â‚—[ğ•œ] E) :\n    (LinearMap.toContinuousLinearMap f).det = LinearMap.det f :=\n  rfl\n\n"}
{"name":"LinearMap.ker_toContinuousLinearMap","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹Â² : AddCommGroup E\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : TopologicalSpace E\ninstâœâ¹ : TopologicalAddGroup E\ninstâœâ¸ : ContinuousSMul ğ•œ E\nF' : Type x\ninstâœâ· : AddCommGroup F'\ninstâœâ¶ : Module ğ•œ F'\ninstâœâµ : TopologicalSpace F'\ninstâœâ´ : TopologicalAddGroup F'\ninstâœÂ³ : ContinuousSMul ğ•œ F'\ninstâœÂ² : CompleteSpace ğ•œ\ninstâœÂ¹ : T2Space E\ninstâœ : FiniteDimensional ğ•œ E\nf : LinearMap (RingHom.id ğ•œ) E F'\nâŠ¢ Eq (LinearMap.ker (LinearMap.toContinuousLinearMap f)) (LinearMap.ker f)","decl":"@[simp]\ntheorem ker_toContinuousLinearMap (f : E â†’â‚—[ğ•œ] F') :\n    ker (LinearMap.toContinuousLinearMap f) = ker f :=\n  rfl\n\n"}
{"name":"LinearMap.range_toContinuousLinearMap","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹Â² : AddCommGroup E\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : TopologicalSpace E\ninstâœâ¹ : TopologicalAddGroup E\ninstâœâ¸ : ContinuousSMul ğ•œ E\nF' : Type x\ninstâœâ· : AddCommGroup F'\ninstâœâ¶ : Module ğ•œ F'\ninstâœâµ : TopologicalSpace F'\ninstâœâ´ : TopologicalAddGroup F'\ninstâœÂ³ : ContinuousSMul ğ•œ F'\ninstâœÂ² : CompleteSpace ğ•œ\ninstâœÂ¹ : T2Space E\ninstâœ : FiniteDimensional ğ•œ E\nf : LinearMap (RingHom.id ğ•œ) E F'\nâŠ¢ Eq (LinearMap.range (LinearMap.toContinuousLinearMap f)) (LinearMap.range f)","decl":"@[simp]\ntheorem range_toContinuousLinearMap (f : E â†’â‚—[ğ•œ] F') :\n    range (LinearMap.toContinuousLinearMap f) = range f :=\n  rfl\n\n"}
{"name":"LinearMap.isOpenMap_of_finiteDimensional","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹Â² : AddCommGroup E\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : TopologicalSpace E\ninstâœâ¹ : TopologicalAddGroup E\ninstâœâ¸ : ContinuousSMul ğ•œ E\nF : Type w\ninstâœâ· : AddCommGroup F\ninstâœâ¶ : Module ğ•œ F\ninstâœâµ : TopologicalSpace F\ninstâœâ´ : TopologicalAddGroup F\ninstâœÂ³ : ContinuousSMul ğ•œ F\ninstâœÂ² : CompleteSpace ğ•œ\ninstâœÂ¹ : T2Space E\ninstâœ : FiniteDimensional ğ•œ E\nf : LinearMap (RingHom.id ğ•œ) F E\nhf : Function.Surjective â‡‘f\nâŠ¢ IsOpenMap â‡‘f","decl":"/-- A surjective linear map `f` with finite dimensional codomain is an open map. -/\ntheorem isOpenMap_of_finiteDimensional (f : F â†’â‚—[ğ•œ] E) (hf : Function.Surjective f) :\n    IsOpenMap f := by\n  obtain âŸ¨g, hgâŸ© := f.exists_rightInverse_of_surjective (LinearMap.range_eq_top.2 hf)\n  refine IsOpenMap.of_sections fun x => âŸ¨fun y => g (y - f x) + x, ?_, ?_, fun y => ?_âŸ©\n  Â· exact\n      ((g.continuous_of_finiteDimensional.comp <| continuous_id.sub continuous_const).add\n          continuous_const).continuousAt\n  Â· simp only\n    rw [sub_self, map_zero, zero_add]\n  Â· simp only [map_sub, map_add, â† comp_apply f g, hg, id_apply, sub_add_cancel]\n\n"}
{"name":"LinearMap.canLiftContinuousLinearMap","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹Â² : AddCommGroup E\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : TopologicalSpace E\ninstâœâ¹ : TopologicalAddGroup E\ninstâœâ¸ : ContinuousSMul ğ•œ E\nF : Type w\ninstâœâ· : AddCommGroup F\ninstâœâ¶ : Module ğ•œ F\ninstâœâµ : TopologicalSpace F\ninstâœâ´ : TopologicalAddGroup F\ninstâœÂ³ : ContinuousSMul ğ•œ F\ninstâœÂ² : CompleteSpace ğ•œ\ninstâœÂ¹ : T2Space E\ninstâœ : FiniteDimensional ğ•œ E\nâŠ¢ CanLift (LinearMap (RingHom.id ğ•œ) E F) (ContinuousLinearMap (RingHom.id ğ•œ) E F) ContinuousLinearMap.toLinearMap fun x => True","decl":"instance canLiftContinuousLinearMap : CanLift (E â†’â‚—[ğ•œ] F) (E â†’L[ğ•œ] F) (â†‘) fun _ => True :=\n  âŸ¨fun f _ => âŸ¨LinearMap.toContinuousLinearMap f, rflâŸ©âŸ©\n\n"}
{"name":"LinearEquiv.coe_toContinuousLinearEquiv","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹Â³ : AddCommGroup E\ninstâœÂ¹Â² : Module ğ•œ E\ninstâœÂ¹Â¹ : TopologicalSpace E\ninstâœÂ¹â° : TopologicalAddGroup E\ninstâœâ¹ : ContinuousSMul ğ•œ E\nF : Type w\ninstâœâ¸ : AddCommGroup F\ninstâœâ· : Module ğ•œ F\ninstâœâ¶ : TopologicalSpace F\ninstâœâµ : TopologicalAddGroup F\ninstâœâ´ : ContinuousSMul ğ•œ F\ninstâœÂ³ : CompleteSpace ğ•œ\ninstâœÂ² : T2Space E\ninstâœÂ¹ : T2Space F\ninstâœ : FiniteDimensional ğ•œ E\ne : LinearEquiv (RingHom.id ğ•œ) E F\nâŠ¢ Eq â†‘â†‘e.toContinuousLinearEquiv â†‘e","decl":"@[simp]\ntheorem coe_toContinuousLinearEquiv (e : E â‰ƒâ‚—[ğ•œ] F) : (e.toContinuousLinearEquiv : E â†’â‚—[ğ•œ] F) = e :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_toContinuousLinearEquiv'","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹Â³ : AddCommGroup E\ninstâœÂ¹Â² : Module ğ•œ E\ninstâœÂ¹Â¹ : TopologicalSpace E\ninstâœÂ¹â° : TopologicalAddGroup E\ninstâœâ¹ : ContinuousSMul ğ•œ E\nF : Type w\ninstâœâ¸ : AddCommGroup F\ninstâœâ· : Module ğ•œ F\ninstâœâ¶ : TopologicalSpace F\ninstâœâµ : TopologicalAddGroup F\ninstâœâ´ : ContinuousSMul ğ•œ F\ninstâœÂ³ : CompleteSpace ğ•œ\ninstâœÂ² : T2Space E\ninstâœÂ¹ : T2Space F\ninstâœ : FiniteDimensional ğ•œ E\ne : LinearEquiv (RingHom.id ğ•œ) E F\nâŠ¢ Eq â‡‘e.toContinuousLinearEquiv â‡‘e","decl":"@[simp]\ntheorem coe_toContinuousLinearEquiv' (e : E â‰ƒâ‚—[ğ•œ] F) : (e.toContinuousLinearEquiv : E â†’ F) = e :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_toContinuousLinearEquiv_symm","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹Â³ : AddCommGroup E\ninstâœÂ¹Â² : Module ğ•œ E\ninstâœÂ¹Â¹ : TopologicalSpace E\ninstâœÂ¹â° : TopologicalAddGroup E\ninstâœâ¹ : ContinuousSMul ğ•œ E\nF : Type w\ninstâœâ¸ : AddCommGroup F\ninstâœâ· : Module ğ•œ F\ninstâœâ¶ : TopologicalSpace F\ninstâœâµ : TopologicalAddGroup F\ninstâœâ´ : ContinuousSMul ğ•œ F\ninstâœÂ³ : CompleteSpace ğ•œ\ninstâœÂ² : T2Space E\ninstâœÂ¹ : T2Space F\ninstâœ : FiniteDimensional ğ•œ E\ne : LinearEquiv (RingHom.id ğ•œ) E F\nâŠ¢ Eq â†‘â†‘e.toContinuousLinearEquiv.symm â†‘e.symm","decl":"@[simp]\ntheorem coe_toContinuousLinearEquiv_symm (e : E â‰ƒâ‚—[ğ•œ] F) :\n    (e.toContinuousLinearEquiv.symm : F â†’â‚—[ğ•œ] E) = e.symm :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_toContinuousLinearEquiv_symm'","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹Â³ : AddCommGroup E\ninstâœÂ¹Â² : Module ğ•œ E\ninstâœÂ¹Â¹ : TopologicalSpace E\ninstâœÂ¹â° : TopologicalAddGroup E\ninstâœâ¹ : ContinuousSMul ğ•œ E\nF : Type w\ninstâœâ¸ : AddCommGroup F\ninstâœâ· : Module ğ•œ F\ninstâœâ¶ : TopologicalSpace F\ninstâœâµ : TopologicalAddGroup F\ninstâœâ´ : ContinuousSMul ğ•œ F\ninstâœÂ³ : CompleteSpace ğ•œ\ninstâœÂ² : T2Space E\ninstâœÂ¹ : T2Space F\ninstâœ : FiniteDimensional ğ•œ E\ne : LinearEquiv (RingHom.id ğ•œ) E F\nâŠ¢ Eq â‡‘e.toContinuousLinearEquiv.symm â‡‘e.symm","decl":"@[simp]\ntheorem coe_toContinuousLinearEquiv_symm' (e : E â‰ƒâ‚—[ğ•œ] F) :\n    (e.toContinuousLinearEquiv.symm : F â†’ E) = e.symm :=\n  rfl\n\n"}
{"name":"LinearEquiv.toLinearEquiv_toContinuousLinearEquiv","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹Â³ : AddCommGroup E\ninstâœÂ¹Â² : Module ğ•œ E\ninstâœÂ¹Â¹ : TopologicalSpace E\ninstâœÂ¹â° : TopologicalAddGroup E\ninstâœâ¹ : ContinuousSMul ğ•œ E\nF : Type w\ninstâœâ¸ : AddCommGroup F\ninstâœâ· : Module ğ•œ F\ninstâœâ¶ : TopologicalSpace F\ninstâœâµ : TopologicalAddGroup F\ninstâœâ´ : ContinuousSMul ğ•œ F\ninstâœÂ³ : CompleteSpace ğ•œ\ninstâœÂ² : T2Space E\ninstâœÂ¹ : T2Space F\ninstâœ : FiniteDimensional ğ•œ E\ne : LinearEquiv (RingHom.id ğ•œ) E F\nâŠ¢ Eq e.toContinuousLinearEquiv.toLinearEquiv e","decl":"@[simp]\ntheorem toLinearEquiv_toContinuousLinearEquiv (e : E â‰ƒâ‚—[ğ•œ] F) :\n    e.toContinuousLinearEquiv.toLinearEquiv = e := by\n  ext x\n  rfl\n\n"}
{"name":"LinearEquiv.toLinearEquiv_toContinuousLinearEquiv_symm","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹Â³ : AddCommGroup E\ninstâœÂ¹Â² : Module ğ•œ E\ninstâœÂ¹Â¹ : TopologicalSpace E\ninstâœÂ¹â° : TopologicalAddGroup E\ninstâœâ¹ : ContinuousSMul ğ•œ E\nF : Type w\ninstâœâ¸ : AddCommGroup F\ninstâœâ· : Module ğ•œ F\ninstâœâ¶ : TopologicalSpace F\ninstâœâµ : TopologicalAddGroup F\ninstâœâ´ : ContinuousSMul ğ•œ F\ninstâœÂ³ : CompleteSpace ğ•œ\ninstâœÂ² : T2Space E\ninstâœÂ¹ : T2Space F\ninstâœ : FiniteDimensional ğ•œ E\ne : LinearEquiv (RingHom.id ğ•œ) E F\nâŠ¢ Eq e.toContinuousLinearEquiv.symm.toLinearEquiv e.symm","decl":"theorem toLinearEquiv_toContinuousLinearEquiv_symm (e : E â‰ƒâ‚—[ğ•œ] F) :\n    e.toContinuousLinearEquiv.symm.toLinearEquiv = e.symm := by\n  ext x\n  rfl\n\n"}
{"name":"LinearEquiv.canLiftContinuousLinearEquiv","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹Â³ : AddCommGroup E\ninstâœÂ¹Â² : Module ğ•œ E\ninstâœÂ¹Â¹ : TopologicalSpace E\ninstâœÂ¹â° : TopologicalAddGroup E\ninstâœâ¹ : ContinuousSMul ğ•œ E\nF : Type w\ninstâœâ¸ : AddCommGroup F\ninstâœâ· : Module ğ•œ F\ninstâœâ¶ : TopologicalSpace F\ninstâœâµ : TopologicalAddGroup F\ninstâœâ´ : ContinuousSMul ğ•œ F\ninstâœÂ³ : CompleteSpace ğ•œ\ninstâœÂ² : T2Space E\ninstâœÂ¹ : T2Space F\ninstâœ : FiniteDimensional ğ•œ E\nâŠ¢ CanLift (LinearEquiv (RingHom.id ğ•œ) E F) (ContinuousLinearEquiv (RingHom.id ğ•œ) E F) ContinuousLinearEquiv.toLinearEquiv fun x => True","decl":"instance canLiftContinuousLinearEquiv :\n    CanLift (E â‰ƒâ‚—[ğ•œ] F) (E â‰ƒL[ğ•œ] F) ContinuousLinearEquiv.toLinearEquiv fun _ => True :=\n  âŸ¨fun f _ => âŸ¨_, f.toLinearEquiv_toContinuousLinearEquivâŸ©âŸ©\n\n"}
{"name":"FiniteDimensional.nonempty_continuousLinearEquiv_of_finrank_eq","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹â´ : AddCommGroup E\ninstâœÂ¹Â³ : Module ğ•œ E\ninstâœÂ¹Â² : TopologicalSpace E\ninstâœÂ¹Â¹ : TopologicalAddGroup E\ninstâœÂ¹â° : ContinuousSMul ğ•œ E\nF : Type w\ninstâœâ¹ : AddCommGroup F\ninstâœâ¸ : Module ğ•œ F\ninstâœâ· : TopologicalSpace F\ninstâœâ¶ : TopologicalAddGroup F\ninstâœâµ : ContinuousSMul ğ•œ F\ninstâœâ´ : CompleteSpace ğ•œ\ninstâœÂ³ : T2Space E\ninstâœÂ² : T2Space F\ninstâœÂ¹ : FiniteDimensional ğ•œ E\ninstâœ : FiniteDimensional ğ•œ F\ncond : Eq (Module.finrank ğ•œ E) (Module.finrank ğ•œ F)\nâŠ¢ Nonempty (ContinuousLinearEquiv (RingHom.id ğ•œ) E F)","decl":"/-- Two finite-dimensional topological vector spaces over a complete normed field are continuously\nlinearly equivalent if they have the same (finite) dimension. -/\ntheorem FiniteDimensional.nonempty_continuousLinearEquiv_of_finrank_eq\n    (cond : finrank ğ•œ E = finrank ğ•œ F) : Nonempty (E â‰ƒL[ğ•œ] F) :=\n  (nonempty_linearEquiv_of_finrank_eq cond).map LinearEquiv.toContinuousLinearEquiv\n\n"}
{"name":"FiniteDimensional.nonempty_continuousLinearEquiv_iff_finrank_eq","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹â´ : AddCommGroup E\ninstâœÂ¹Â³ : Module ğ•œ E\ninstâœÂ¹Â² : TopologicalSpace E\ninstâœÂ¹Â¹ : TopologicalAddGroup E\ninstâœÂ¹â° : ContinuousSMul ğ•œ E\nF : Type w\ninstâœâ¹ : AddCommGroup F\ninstâœâ¸ : Module ğ•œ F\ninstâœâ· : TopologicalSpace F\ninstâœâ¶ : TopologicalAddGroup F\ninstâœâµ : ContinuousSMul ğ•œ F\ninstâœâ´ : CompleteSpace ğ•œ\ninstâœÂ³ : T2Space E\ninstâœÂ² : T2Space F\ninstâœÂ¹ : FiniteDimensional ğ•œ E\ninstâœ : FiniteDimensional ğ•œ F\nâŠ¢ Iff (Nonempty (ContinuousLinearEquiv (RingHom.id ğ•œ) E F)) (Eq (Module.finrank ğ•œ E) (Module.finrank ğ•œ F))","decl":"/-- Two finite-dimensional topological vector spaces over a complete normed field are continuously\nlinearly equivalent if and only if they have the same (finite) dimension. -/\ntheorem FiniteDimensional.nonempty_continuousLinearEquiv_iff_finrank_eq :\n    Nonempty (E â‰ƒL[ğ•œ] F) â†” finrank ğ•œ E = finrank ğ•œ F :=\n  âŸ¨fun âŸ¨hâŸ© => h.toLinearEquiv.finrank_eq, fun h =>\n    FiniteDimensional.nonempty_continuousLinearEquiv_of_finrank_eq hâŸ©\n\n"}
{"name":"Basis.coe_constrL","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹Â² : AddCommGroup E\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : TopologicalSpace E\ninstâœâ¹ : TopologicalAddGroup E\ninstâœâ¸ : ContinuousSMul ğ•œ E\nF : Type w\ninstâœâ· : AddCommGroup F\ninstâœâ¶ : Module ğ•œ F\ninstâœâµ : TopologicalSpace F\ninstâœâ´ : TopologicalAddGroup F\ninstâœÂ³ : ContinuousSMul ğ•œ F\ninstâœÂ² : CompleteSpace ğ•œ\nÎ¹ : Type u_1\ninstâœÂ¹ : Finite Î¹\ninstâœ : T2Space E\nv : Basis Î¹ ğ•œ E\nf : Î¹ â†’ F\nâŠ¢ Eq (â†‘(v.constrL f)) ((v.constr ğ•œ) f)","decl":"@[simp] -- Porting note: removed `norm_cast`\ntheorem coe_constrL (v : Basis Î¹ ğ•œ E) (f : Î¹ â†’ F) : (v.constrL f : E â†’â‚—[ğ•œ] F) = v.constr ğ•œ f :=\n  rfl\n\n"}
{"name":"Basis.equivFunL_apply","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâ· : AddCommGroup E\ninstâœâ¶ : Module ğ•œ E\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : TopologicalAddGroup E\ninstâœÂ³ : ContinuousSMul ğ•œ E\ninstâœÂ² : CompleteSpace ğ•œ\nÎ¹ : Type u_1\ninstâœÂ¹ : Finite Î¹\ninstâœ : T2Space E\nv : Basis Î¹ ğ•œ E\naâœÂ¹ : E\naâœ : Î¹\nâŠ¢ Eq (v.equivFunL aâœÂ¹ aâœ) ((v.repr aâœÂ¹) aâœ)","decl":"/-- The continuous linear equivalence between a vector space over `ğ•œ` with a finite basis and\nfunctions from its basis indexing type to `ğ•œ`. -/\n@[simps! apply]\ndef equivFunL (v : Basis Î¹ ğ•œ E) : E â‰ƒL[ğ•œ] Î¹ â†’ ğ•œ :=\n  { v.equivFun with\n    continuous_toFun :=\n      haveI : FiniteDimensional ğ•œ E := FiniteDimensional.of_fintype_basis v\n      v.equivFun.toLinearMap.continuous_of_finiteDimensional\n    continuous_invFun := by\n      change Continuous v.equivFun.symm.toFun\n      exact v.equivFun.symm.toLinearMap.continuous_of_finiteDimensional }\n\n"}
{"name":"Basis.equivFunL_symm_apply_repr","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâ· : AddCommGroup E\ninstâœâ¶ : Module ğ•œ E\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : TopologicalAddGroup E\ninstâœÂ³ : ContinuousSMul ğ•œ E\ninstâœÂ² : CompleteSpace ğ•œ\nÎ¹ : Type u_1\ninstâœÂ¹ : Finite Î¹\ninstâœ : T2Space E\nv : Basis Î¹ ğ•œ E\nx : E\nâŠ¢ Eq (v.equivFunL.symm â‡‘(v.repr x)) x","decl":"@[simp]\nlemma equivFunL_symm_apply_repr (v : Basis Î¹ ğ•œ E) (x : E) :\n    v.equivFunL.symm (v.repr x) = x :=\n  v.equivFunL.symm_apply_apply x\n\n"}
{"name":"Basis.constrL_apply","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹Â² : AddCommGroup E\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : TopologicalSpace E\ninstâœâ¹ : TopologicalAddGroup E\ninstâœâ¸ : ContinuousSMul ğ•œ E\nF : Type w\ninstâœâ· : AddCommGroup F\ninstâœâ¶ : Module ğ•œ F\ninstâœâµ : TopologicalSpace F\ninstâœâ´ : TopologicalAddGroup F\ninstâœÂ³ : ContinuousSMul ğ•œ F\ninstâœÂ² : CompleteSpace ğ•œ\ninstâœÂ¹ : T2Space E\nÎ¹ : Type u_2\ninstâœ : Fintype Î¹\nv : Basis Î¹ ğ•œ E\nf : Î¹ â†’ F\ne : E\nâŠ¢ Eq ((v.constrL f) e) (Finset.univ.sum fun i => HSMul.hSMul (v.equivFun e i) (f i))","decl":"@[simp]\ntheorem constrL_apply {Î¹ : Type*} [Fintype Î¹] (v : Basis Î¹ ğ•œ E) (f : Î¹ â†’ F) (e : E) :\n    v.constrL f e = âˆ‘ i, v.equivFun e i â€¢ f i :=\n  v.constr_apply_fintype ğ•œ _ _\n\n"}
{"name":"Basis.constrL_basis","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœÂ¹Â² : AddCommGroup E\ninstâœÂ¹Â¹ : Module ğ•œ E\ninstâœÂ¹â° : TopologicalSpace E\ninstâœâ¹ : TopologicalAddGroup E\ninstâœâ¸ : ContinuousSMul ğ•œ E\nF : Type w\ninstâœâ· : AddCommGroup F\ninstâœâ¶ : Module ğ•œ F\ninstâœâµ : TopologicalSpace F\ninstâœâ´ : TopologicalAddGroup F\ninstâœÂ³ : ContinuousSMul ğ•œ F\ninstâœÂ² : CompleteSpace ğ•œ\nÎ¹ : Type u_1\ninstâœÂ¹ : Finite Î¹\ninstâœ : T2Space E\nv : Basis Î¹ ğ•œ E\nf : Î¹ â†’ F\ni : Î¹\nâŠ¢ Eq ((v.constrL f) (v i)) (f i)","decl":"@[simp 1100]\ntheorem constrL_basis (v : Basis Î¹ ğ•œ E) (f : Î¹ â†’ F) (i : Î¹) : v.constrL f (v i) = f i :=\n  v.constr_basis ğ•œ _ _\n\n"}
{"name":"ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâ· : AddCommGroup E\ninstâœâ¶ : Module ğ•œ E\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : TopologicalAddGroup E\ninstâœÂ³ : ContinuousSMul ğ•œ E\ninstâœÂ² : CompleteSpace ğ•œ\ninstâœÂ¹ : T2Space E\ninstâœ : FiniteDimensional ğ•œ E\nf : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhf : Ne f.det 0\nâŠ¢ Eq (â†‘(f.toContinuousLinearEquivOfDetNeZero hf)) f","decl":"@[simp]\ntheorem coe_toContinuousLinearEquivOfDetNeZero (f : E â†’L[ğ•œ] E) (hf : f.det â‰  0) :\n    (f.toContinuousLinearEquivOfDetNeZero hf : E â†’L[ğ•œ] E) = f := by\n  ext x\n  rfl\n\n"}
{"name":"ContinuousLinearMap.toContinuousLinearEquivOfDetNeZero_apply","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\nE : Type v\ninstâœâ· : AddCommGroup E\ninstâœâ¶ : Module ğ•œ E\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : TopologicalAddGroup E\ninstâœÂ³ : ContinuousSMul ğ•œ E\ninstâœÂ² : CompleteSpace ğ•œ\ninstâœÂ¹ : T2Space E\ninstâœ : FiniteDimensional ğ•œ E\nf : ContinuousLinearMap (RingHom.id ğ•œ) E E\nhf : Ne f.det 0\nx : E\nâŠ¢ Eq ((f.toContinuousLinearEquivOfDetNeZero hf) x) (f x)","decl":"@[simp]\ntheorem toContinuousLinearEquivOfDetNeZero_apply (f : E â†’L[ğ•œ] E) (hf : f.det â‰  0) (x : E) :\n    f.toContinuousLinearEquivOfDetNeZero hf x = f x :=\n  rfl\n\n"}
{"name":"Matrix.toLin_finTwoProd_toContinuousLinearMap","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u\nhnorm : NontriviallyNormedField ğ•œ\ninstâœ : CompleteSpace ğ•œ\na b c d : ğ•œ\nâŠ¢ Eq (LinearMap.toContinuousLinearMap ((Matrix.toLin (Basis.finTwoProd ğ•œ) (Basis.finTwoProd ğ•œ)) (Matrix.of (Matrix.vecCons (Matrix.vecCons a (Matrix.vecCons b Matrix.vecEmpty)) (Matrix.vecCons (Matrix.vecCons c (Matrix.vecCons d Matrix.vecEmpty)) Matrix.vecEmpty))))) ((HAdd.hAdd (HSMul.hSMul a (ContinuousLinearMap.fst ğ•œ ğ•œ ğ•œ)) (HSMul.hSMul b (ContinuousLinearMap.snd ğ•œ ğ•œ ğ•œ))).prod (HAdd.hAdd (HSMul.hSMul c (ContinuousLinearMap.fst ğ•œ ğ•œ ğ•œ)) (HSMul.hSMul d (ContinuousLinearMap.snd ğ•œ ğ•œ ğ•œ))))","decl":"theorem _root_.Matrix.toLin_finTwoProd_toContinuousLinearMap (a b c d : ğ•œ) :\n    LinearMap.toContinuousLinearMap\n      (Matrix.toLin (Basis.finTwoProd ğ•œ) (Basis.finTwoProd ğ•œ) !![a, b; c, d]) =\n      (a â€¢ ContinuousLinearMap.fst ğ•œ ğ•œ ğ•œ + b â€¢ ContinuousLinearMap.snd ğ•œ ğ•œ ğ•œ).prod\n        (c â€¢ ContinuousLinearMap.fst ğ•œ ğ•œ ğ•œ + d â€¢ ContinuousLinearMap.snd ğ•œ ğ•œ ğ•œ) :=\n  ContinuousLinearMap.ext <| Matrix.toLin_finTwoProd_apply _ _ _ _\n\n"}
{"name":"FiniteDimensional.complete","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : CompleteSpace ğ•œ\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : UniformSpace E\ninstâœâ´ : T2Space E\ninstâœÂ³ : UniformAddGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : FiniteDimensional ğ•œ E\nâŠ¢ CompleteSpace E","decl":"include ğ•œ in\ntheorem FiniteDimensional.complete [FiniteDimensional ğ•œ E] : CompleteSpace E := by\n  set e := ContinuousLinearEquiv.ofFinrankEq (@finrank_fin_fun ğ•œ _ _ (finrank ğ•œ E)).symm\n  have : IsUniformEmbedding e.toEquiv.symm := e.symm.isUniformEmbedding\n  exact (completeSpace_congr this).1 inferInstance\n\n"}
{"name":"Submodule.complete_of_finiteDimensional","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : CompleteSpace ğ•œ\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : UniformSpace E\ninstâœâ´ : T2Space E\ninstâœÂ³ : UniformAddGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ns : Submodule ğ•œ E\ninstâœ : FiniteDimensional ğ•œ (Subtype fun x => Membership.mem s x)\nâŠ¢ IsComplete â†‘s","decl":"/-- A finite-dimensional subspace is complete. -/\ntheorem Submodule.complete_of_finiteDimensional (s : Submodule ğ•œ E) [FiniteDimensional ğ•œ s] :\n    IsComplete (s : Set E) :=\n  haveI : UniformAddGroup s := s.toAddSubgroup.uniformAddGroup\n  completeSpace_coe_iff_isComplete.1 (FiniteDimensional.complete ğ•œ s)\n\n"}
{"name":"Submodule.closed_of_finiteDimensional","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : CompleteSpace ğ•œ\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : TopologicalAddGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : ContinuousSMul ğ•œ E\ninstâœÂ¹ : T2Space E\ns : Submodule ğ•œ E\ninstâœ : FiniteDimensional ğ•œ (Subtype fun x => Membership.mem s x)\nâŠ¢ IsClosed â†‘s","decl":"/-- A finite-dimensional subspace is closed. -/\ntheorem Submodule.closed_of_finiteDimensional\n    [T2Space E] (s : Submodule ğ•œ E) [FiniteDimensional ğ•œ s] :\n    IsClosed (s : Set E) :=\n  letI := TopologicalAddGroup.toUniformSpace E\n  haveI : UniformAddGroup E := comm_topologicalAddGroup_is_uniform\n  s.complete_of_finiteDimensional.isClosed\n\n"}
{"name":"LinearMap.isClosedEmbedding_of_injective","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ¹â´ : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â³ : CompleteSpace ğ•œ\ninstâœÂ¹Â² : AddCommGroup E\ninstâœÂ¹Â¹ : TopologicalSpace E\ninstâœÂ¹â° : TopologicalAddGroup E\ninstâœâ¹ : Module ğ•œ E\ninstâœâ¸ : ContinuousSMul ğ•œ E\ninstâœâ· : AddCommGroup F\ninstâœâ¶ : TopologicalSpace F\ninstâœâµ : T2Space F\ninstâœâ´ : TopologicalAddGroup F\ninstâœÂ³ : Module ğ•œ F\ninstâœÂ² : ContinuousSMul ğ•œ F\ninstâœÂ¹ : T2Space E\ninstâœ : FiniteDimensional ğ•œ E\nf : LinearMap (RingHom.id ğ•œ) E F\nhf : Eq (LinearMap.ker f) Bot.bot\nâŠ¢ Topology.IsClosedEmbedding â‡‘f","decl":"/-- An injective linear map with finite-dimensional domain is a closed embedding. -/\ntheorem LinearMap.isClosedEmbedding_of_injective [T2Space E] [FiniteDimensional ğ•œ E] {f : E â†’â‚—[ğ•œ] F}\n    (hf : LinearMap.ker f = âŠ¥) : IsClosedEmbedding f :=\n  let g := LinearEquiv.ofInjective f (LinearMap.ker_eq_bot.mp hf)\n  { IsEmbedding.subtypeVal.comp g.toContinuousLinearEquiv.toHomeomorph.isEmbedding with\n    isClosed_range := by\n      haveI := f.finiteDimensional_range\n      simpa [LinearMap.range_coe f] using f.range.closed_of_finiteDimensional }\n\n"}
{"name":"LinearMap.closedEmbedding_of_injective","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ¹â´ : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â³ : CompleteSpace ğ•œ\ninstâœÂ¹Â² : AddCommGroup E\ninstâœÂ¹Â¹ : TopologicalSpace E\ninstâœÂ¹â° : TopologicalAddGroup E\ninstâœâ¹ : Module ğ•œ E\ninstâœâ¸ : ContinuousSMul ğ•œ E\ninstâœâ· : AddCommGroup F\ninstâœâ¶ : TopologicalSpace F\ninstâœâµ : T2Space F\ninstâœâ´ : TopologicalAddGroup F\ninstâœÂ³ : Module ğ•œ F\ninstâœÂ² : ContinuousSMul ğ•œ F\ninstâœÂ¹ : T2Space E\ninstâœ : FiniteDimensional ğ•œ E\nf : LinearMap (RingHom.id ğ•œ) E F\nhf : Eq (LinearMap.ker f) Bot.bot\nâŠ¢ Topology.IsClosedEmbedding â‡‘f","decl":"@[deprecated (since := \"2024-10-20\")]\nalias LinearMap.closedEmbedding_of_injective := LinearMap.isClosedEmbedding_of_injective\n\n"}
{"name":"isClosedEmbedding_smul_left","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : CompleteSpace ğ•œ\ninstâœâµ : AddCommGroup E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : TopologicalAddGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : T2Space E\nc : E\nhc : Ne c 0\nâŠ¢ Topology.IsClosedEmbedding fun x => HSMul.hSMul x c","decl":"theorem isClosedEmbedding_smul_left [T2Space E] {c : E} (hc : c â‰  0) :\n    IsClosedEmbedding fun x : ğ•œ => x â€¢ c :=\n  LinearMap.isClosedEmbedding_of_injective (LinearMap.ker_toSpanSingleton ğ•œ E hc)\n\n"}
{"name":"closedEmbedding_smul_left","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : CompleteSpace ğ•œ\ninstâœâµ : AddCommGroup E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : TopologicalAddGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : T2Space E\nc : E\nhc : Ne c 0\nâŠ¢ Topology.IsClosedEmbedding fun x => HSMul.hSMul x c","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_smul_left := isClosedEmbedding_smul_left\n\n-- `smul` is a closed map in the first argument.\n"}
{"name":"isClosedMap_smul_left","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : CompleteSpace ğ•œ\ninstâœâµ : AddCommGroup E\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : TopologicalAddGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : T2Space E\nc : E\nâŠ¢ IsClosedMap fun x => HSMul.hSMul x c","decl":"theorem isClosedMap_smul_left [T2Space E] (c : E) : IsClosedMap fun x : ğ•œ => x â€¢ c := by\n  by_cases hc : c = 0\n  Â· simp_rw [hc, smul_zero]\n    exact isClosedMap_const\n  Â· exact (isClosedEmbedding_smul_left hc).isClosedMap\n\n"}
{"name":"ContinuousLinearMap.exists_right_inverse_of_surjective","module":"Mathlib.Topology.Algebra.Module.FiniteDimension","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ¹Â³ : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â² : CompleteSpace ğ•œ\ninstâœÂ¹Â¹ : AddCommGroup E\ninstâœÂ¹â° : TopologicalSpace E\ninstâœâ¹ : TopologicalAddGroup E\ninstâœâ¸ : Module ğ•œ E\ninstâœâ· : ContinuousSMul ğ•œ E\ninstâœâ¶ : AddCommGroup F\ninstâœâµ : TopologicalSpace F\ninstâœâ´ : T2Space F\ninstâœÂ³ : TopologicalAddGroup F\ninstâœÂ² : Module ğ•œ F\ninstâœÂ¹ : ContinuousSMul ğ•œ F\ninstâœ : FiniteDimensional ğ•œ F\nf : ContinuousLinearMap (RingHom.id ğ•œ) E F\nhf : Eq (LinearMap.range f) Top.top\nâŠ¢ Exists fun g => Eq (f.comp g) (ContinuousLinearMap.id ğ•œ F)","decl":"theorem ContinuousLinearMap.exists_right_inverse_of_surjective [FiniteDimensional ğ•œ F]\n    (f : E â†’L[ğ•œ] F) (hf : LinearMap.range f = âŠ¤) :\n    âˆƒ g : F â†’L[ğ•œ] E, f.comp g = ContinuousLinearMap.id ğ•œ F :=\n  let âŸ¨g, hgâŸ© := (f : E â†’â‚—[ğ•œ] F).exists_rightInverse_of_surjective hf\n  âŸ¨LinearMap.toContinuousLinearMap g, ContinuousLinearMap.coe_inj.1 hgâŸ©\n"}
