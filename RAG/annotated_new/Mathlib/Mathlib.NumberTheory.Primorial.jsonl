{"name":"primorial_pos","module":"Mathlib.NumberTheory.Primorial","initialProofState":"n : Nat\n⊢ LT.lt 0 (primorial n)","decl":"theorem primorial_pos (n : ℕ) : 0 < n# :=\n  prod_pos fun _p hp ↦ (mem_filter.1 hp).2.pos\n\n"}
{"name":"primorial_succ","module":"Mathlib.NumberTheory.Primorial","initialProofState":"n : Nat\nhn1 : Ne n 1\nhn : Odd n\n⊢ Eq (primorial (HAdd.hAdd n 1)) (primorial n)","decl":"theorem primorial_succ {n : ℕ} (hn1 : n ≠ 1) (hn : Odd n) : (n + 1)# = n# := by\n  refine prod_congr ?_ fun _ _ ↦ rfl\n  rw [range_succ, filter_insert, if_neg fun h ↦ not_even_iff_odd.2 hn _]\n  exact fun h ↦ h.even_sub_one <| mt succ.inj hn1\n\n"}
{"name":"primorial_add","module":"Mathlib.NumberTheory.Primorial","initialProofState":"m n : Nat\n⊢ Eq (primorial (HAdd.hAdd m n)) (HMul.hMul (primorial m) ((Finset.filter (fun p => Nat.Prime p) (Finset.Ico (HAdd.hAdd m 1) (HAdd.hAdd (HAdd.hAdd m n) 1))).prod fun p => p))","decl":"theorem primorial_add (m n : ℕ) :\n    (m + n)# = m# * ∏ p ∈ Ico (m + 1) (m + n + 1) with p.Prime, p := by\n  rw [primorial, primorial, ← Ico_zero_eq_range, ← prod_union, ← filter_union, Ico_union_Ico_eq_Ico]\n  exacts [Nat.zero_le _, add_le_add_right (Nat.le_add_right _ _) _,\n    disjoint_filter_filter <| Ico_disjoint_Ico_consecutive _ _ _]\n\n"}
{"name":"primorial_add_dvd","module":"Mathlib.NumberTheory.Primorial","initialProofState":"m n : Nat\nh : LE.le n m\n⊢ Dvd.dvd (primorial (HAdd.hAdd m n)) (HMul.hMul (primorial m) ((HAdd.hAdd m n).choose m))","decl":"theorem primorial_add_dvd {m n : ℕ} (h : n ≤ m) : (m + n)# ∣ m# * choose (m + n) m :=\n  calc\n    (m + n)# = m# * ∏ p ∈ Ico (m + 1) (m + n + 1) with p.Prime, p := primorial_add _ _\n    _ ∣ m# * choose (m + n) m :=\n      mul_dvd_mul_left _ <|\n        prod_primes_dvd _ (fun _ hk ↦ (mem_filter.1 hk).2.prime) fun p hp ↦ by\n          rw [mem_filter, mem_Ico] at hp\n          exact hp.2.dvd_choose_add hp.1.1 (h.trans_lt (m.lt_succ_self.trans_le hp.1.1))\n              (Nat.lt_succ_iff.1 hp.1.2)\n\n"}
{"name":"primorial_add_le","module":"Mathlib.NumberTheory.Primorial","initialProofState":"m n : Nat\nh : LE.le n m\n⊢ LE.le (primorial (HAdd.hAdd m n)) (HMul.hMul (primorial m) ((HAdd.hAdd m n).choose m))","decl":"theorem primorial_add_le {m n : ℕ} (h : n ≤ m) : (m + n)# ≤ m# * choose (m + n) m :=\n  le_of_dvd (mul_pos (primorial_pos _) (choose_pos <| Nat.le_add_right _ _)) (primorial_add_dvd h)\n\n"}
{"name":"primorial_le_4_pow","module":"Mathlib.NumberTheory.Primorial","initialProofState":"n : Nat\n⊢ LE.le (primorial n) (HPow.hPow 4 n)","decl":"theorem primorial_le_4_pow (n : ℕ) : n# ≤ 4 ^ n := by\n  induction' n using Nat.strong_induction_on with n ihn\n  cases' n with n; · rfl\n  rcases n.even_or_odd with (⟨m, rfl⟩ | ho)\n  · rcases m.eq_zero_or_pos with (rfl | hm)\n    · decide\n    calc\n      (m + m + 1)# = (m + 1 + m)# := by rw [add_right_comm]\n      _ ≤ (m + 1)# * choose (m + 1 + m) (m + 1) := primorial_add_le m.le_succ\n      _ = (m + 1)# * choose (2 * m + 1) m := by rw [choose_symm_add, two_mul, add_right_comm]\n      _ ≤ 4 ^ (m + 1) * 4 ^ m :=\n        mul_le_mul' (ihn _ <| succ_lt_succ <| (lt_add_iff_pos_left _).2 hm) (choose_middle_le_pow _)\n      _ ≤ 4 ^ (m + m + 1) := by rw [← pow_add, add_right_comm]\n  · rcases Decidable.eq_or_ne n 1 with (rfl | hn)\n    · decide\n    · calc\n        (n + 1)# = n# := primorial_succ hn ho\n        _ ≤ 4 ^ n := ihn n n.lt_succ_self\n        _ ≤ 4 ^ (n + 1) := pow_le_pow_of_le_right four_pos n.le_succ\n"}
