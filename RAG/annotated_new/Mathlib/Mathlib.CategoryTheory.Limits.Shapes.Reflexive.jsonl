{"name":"CategoryTheory.IsReflexivePair.common_section'","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\nself : CategoryTheory.IsReflexivePair f g\n⊢ Exists fun s => And (Eq (CategoryTheory.CategoryStruct.comp s f) (CategoryTheory.CategoryStruct.id B)) (Eq (CategoryTheory.CategoryStruct.comp s g) (CategoryTheory.CategoryStruct.id B))","decl":"/-- The pair `f g : A ⟶ B` is reflexive if there is a morphism `B ⟶ A` which is a section for both.\n-/\nclass IsReflexivePair (f g : A ⟶ B) : Prop where\n  common_section' : ∃ s : B ⟶ A, s ≫ f = 𝟙 B ∧ s ≫ g = 𝟙 B\n\n"}
{"name":"CategoryTheory.IsReflexivePair.common_section","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsReflexivePair f g\n⊢ Exists fun s => And (Eq (CategoryTheory.CategoryStruct.comp s f) (CategoryTheory.CategoryStruct.id B)) (Eq (CategoryTheory.CategoryStruct.comp s g) (CategoryTheory.CategoryStruct.id B))","decl":"theorem IsReflexivePair.common_section (f g : A ⟶ B) [IsReflexivePair f g] :\n    ∃ s : B ⟶ A, s ≫ f = 𝟙 B ∧ s ≫ g = 𝟙 B := IsReflexivePair.common_section'\n\n"}
{"name":"CategoryTheory.IsCoreflexivePair.common_retraction'","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\nself : CategoryTheory.IsCoreflexivePair f g\n⊢ Exists fun s => And (Eq (CategoryTheory.CategoryStruct.comp f s) (CategoryTheory.CategoryStruct.id A)) (Eq (CategoryTheory.CategoryStruct.comp g s) (CategoryTheory.CategoryStruct.id A))","decl":"/--\nThe pair `f g : A ⟶ B` is coreflexive if there is a morphism `B ⟶ A` which is a retraction for both.\n-/\nclass IsCoreflexivePair (f g : A ⟶ B) : Prop where\n  common_retraction' : ∃ s : B ⟶ A, f ≫ s = 𝟙 A ∧ g ≫ s = 𝟙 A\n\n"}
{"name":"CategoryTheory.IsCoreflexivePair.common_retraction","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsCoreflexivePair f g\n⊢ Exists fun s => And (Eq (CategoryTheory.CategoryStruct.comp f s) (CategoryTheory.CategoryStruct.id A)) (Eq (CategoryTheory.CategoryStruct.comp g s) (CategoryTheory.CategoryStruct.id A))","decl":"theorem IsCoreflexivePair.common_retraction (f g : A ⟶ B) [IsCoreflexivePair f g] :\n    ∃ s : B ⟶ A, f ≫ s = 𝟙 A ∧ g ≫ s = 𝟙 A := IsCoreflexivePair.common_retraction'\n\n"}
{"name":"CategoryTheory.IsReflexivePair.mk'","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ns : Quiver.Hom B A\nsf : Eq (CategoryTheory.CategoryStruct.comp s f) (CategoryTheory.CategoryStruct.id B)\nsg : Eq (CategoryTheory.CategoryStruct.comp s g) (CategoryTheory.CategoryStruct.id B)\n⊢ CategoryTheory.IsReflexivePair f g","decl":"theorem IsReflexivePair.mk' (s : B ⟶ A) (sf : s ≫ f = 𝟙 B) (sg : s ≫ g = 𝟙 B) :\n    IsReflexivePair f g :=\n  ⟨⟨s, sf, sg⟩⟩\n\n"}
{"name":"CategoryTheory.IsCoreflexivePair.mk'","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ns : Quiver.Hom B A\nfs : Eq (CategoryTheory.CategoryStruct.comp f s) (CategoryTheory.CategoryStruct.id A)\ngs : Eq (CategoryTheory.CategoryStruct.comp g s) (CategoryTheory.CategoryStruct.id A)\n⊢ CategoryTheory.IsCoreflexivePair f g","decl":"theorem IsCoreflexivePair.mk' (s : B ⟶ A) (fs : f ≫ s = 𝟙 A) (gs : g ≫ s = 𝟙 A) :\n    IsCoreflexivePair f g :=\n  ⟨⟨s, fs, gs⟩⟩\n\n"}
{"name":"CategoryTheory.section_comp_left_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsReflexivePair f g\nZ : C\nh : Quiver.Hom B Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.commonSection f g) (CategoryTheory.CategoryStruct.comp f h)) h","decl":"@[reassoc (attr := simp)]\ntheorem section_comp_left (f g : A ⟶ B) [IsReflexivePair f g] : commonSection f g ≫ f = 𝟙 B :=\n  (IsReflexivePair.common_section f g).choose_spec.1\n\n"}
{"name":"CategoryTheory.section_comp_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsReflexivePair f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.commonSection f g) f) (CategoryTheory.CategoryStruct.id B)","decl":"@[reassoc (attr := simp)]\ntheorem section_comp_left (f g : A ⟶ B) [IsReflexivePair f g] : commonSection f g ≫ f = 𝟙 B :=\n  (IsReflexivePair.common_section f g).choose_spec.1\n\n"}
{"name":"CategoryTheory.section_comp_right_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsReflexivePair f g\nZ : C\nh : Quiver.Hom B Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.commonSection f g) (CategoryTheory.CategoryStruct.comp g h)) h","decl":"@[reassoc (attr := simp)]\ntheorem section_comp_right (f g : A ⟶ B) [IsReflexivePair f g] : commonSection f g ≫ g = 𝟙 B :=\n  (IsReflexivePair.common_section f g).choose_spec.2\n\n"}
{"name":"CategoryTheory.section_comp_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsReflexivePair f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.commonSection f g) g) (CategoryTheory.CategoryStruct.id B)","decl":"@[reassoc (attr := simp)]\ntheorem section_comp_right (f g : A ⟶ B) [IsReflexivePair f g] : commonSection f g ≫ g = 𝟙 B :=\n  (IsReflexivePair.common_section f g).choose_spec.2\n\n"}
{"name":"CategoryTheory.left_comp_retraction","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsCoreflexivePair f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.commonRetraction f g)) (CategoryTheory.CategoryStruct.id A)","decl":"@[reassoc (attr := simp)]\ntheorem left_comp_retraction (f g : A ⟶ B) [IsCoreflexivePair f g] :\n    f ≫ commonRetraction f g = 𝟙 A :=\n  (IsCoreflexivePair.common_retraction f g).choose_spec.1\n\n"}
{"name":"CategoryTheory.left_comp_retraction_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsCoreflexivePair f g\nZ : C\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.commonRetraction f g) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem left_comp_retraction (f g : A ⟶ B) [IsCoreflexivePair f g] :\n    f ≫ commonRetraction f g = 𝟙 A :=\n  (IsCoreflexivePair.common_retraction f g).choose_spec.1\n\n"}
{"name":"CategoryTheory.right_comp_retraction","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsCoreflexivePair f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.commonRetraction f g)) (CategoryTheory.CategoryStruct.id A)","decl":"@[reassoc (attr := simp)]\ntheorem right_comp_retraction (f g : A ⟶ B) [IsCoreflexivePair f g] :\n    g ≫ commonRetraction f g = 𝟙 A :=\n  (IsCoreflexivePair.common_retraction f g).choose_spec.2\n\n"}
{"name":"CategoryTheory.right_comp_retraction_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsCoreflexivePair f g\nZ : C\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp (CategoryTheory.commonRetraction f g) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem right_comp_retraction (f g : A ⟶ B) [IsCoreflexivePair f g] :\n    g ≫ commonRetraction f g = 𝟙 A :=\n  (IsCoreflexivePair.common_retraction f g).choose_spec.2\n\n"}
{"name":"CategoryTheory.IsKernelPair.isReflexivePair","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA B R : C\nf g : Quiver.Hom R A\nq : Quiver.Hom A B\nh : CategoryTheory.IsKernelPair q f g\n⊢ CategoryTheory.IsReflexivePair f g","decl":"/-- If `f,g` is a kernel pair for some morphism `q`, then it is reflexive. -/\ntheorem IsKernelPair.isReflexivePair {R : C} {f g : R ⟶ A} {q : A ⟶ B} (h : IsKernelPair q f g) :\n    IsReflexivePair f g :=\n  IsReflexivePair.mk' _ (h.lift' _ _ rfl).2.1 (h.lift' _ _ _).2.2\n\n-- This shouldn't be an instance as it would instantly loop.\n"}
{"name":"CategoryTheory.IsReflexivePair.swap","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsReflexivePair f g\n⊢ CategoryTheory.IsReflexivePair g f","decl":"/-- If `f,g` is reflexive, then `g,f` is reflexive. -/\ntheorem IsReflexivePair.swap [IsReflexivePair f g] : IsReflexivePair g f :=\n  IsReflexivePair.mk' _ (section_comp_right f g) (section_comp_left f g)\n\n-- This shouldn't be an instance as it would instantly loop.\n"}
{"name":"CategoryTheory.IsCoreflexivePair.swap","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsCoreflexivePair f g\n⊢ CategoryTheory.IsCoreflexivePair g f","decl":"/-- If `f,g` is coreflexive, then `g,f` is coreflexive. -/\ntheorem IsCoreflexivePair.swap [IsCoreflexivePair f g] : IsCoreflexivePair g f :=\n  IsCoreflexivePair.mk' _ (right_comp_retraction f g) (left_comp_retraction f g)\n\n"}
{"name":"CategoryTheory.instIsReflexivePairMapAppCounitObj","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nB : D\n⊢ CategoryTheory.IsReflexivePair (F.map (G.map (adj.counit.app B))) (adj.counit.app (F.obj (G.obj B)))","decl":"/-- For an adjunction `F ⊣ G` with counit `ε`, the pair `(FGε_B, ε_FGB)` is reflexive. -/\ninstance (B : D) :\n    IsReflexivePair (F.map (G.map (adj.counit.app B))) (adj.counit.app (F.obj (G.obj B))) :=\n  IsReflexivePair.mk' (F.map (adj.unit.app (G.obj B)))\n    (by\n      rw [← F.map_comp, adj.right_triangle_components]\n      apply F.map_id)\n    (adj.left_triangle_components _)\n\n"}
{"name":"CategoryTheory.Limits.HasReflexiveCoequalizers.has_coeq","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasReflexiveCoequalizers C\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsReflexivePair f g\n⊢ CategoryTheory.Limits.HasCoequalizer f g","decl":"/-- `C` has reflexive coequalizers if it has coequalizers for every reflexive pair. -/\nclass HasReflexiveCoequalizers : Prop where\n  has_coeq : ∀ ⦃A B : C⦄ (f g : A ⟶ B) [IsReflexivePair f g], HasCoequalizer f g\n\n"}
{"name":"CategoryTheory.Limits.HasCoreflexiveEqualizers.has_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasCoreflexiveEqualizers C\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsCoreflexivePair f g\n⊢ CategoryTheory.Limits.HasEqualizer f g","decl":"/-- `C` has coreflexive equalizers if it has equalizers for every coreflexive pair. -/\nclass HasCoreflexiveEqualizers : Prop where\n  has_eq : ∀ ⦃A B : C⦄ (f g : A ⟶ B) [IsCoreflexivePair f g], HasEqualizer f g\n\n"}
{"name":"CategoryTheory.Limits.hasCoequalizer_of_common_section","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasReflexiveCoequalizers C\nA B : C\nf g : Quiver.Hom A B\nr : Quiver.Hom B A\nrf : Eq (CategoryTheory.CategoryStruct.comp r f) (CategoryTheory.CategoryStruct.id B)\nrg : Eq (CategoryTheory.CategoryStruct.comp r g) (CategoryTheory.CategoryStruct.id B)\n⊢ CategoryTheory.Limits.HasCoequalizer f g","decl":"theorem hasCoequalizer_of_common_section [HasReflexiveCoequalizers C] {A B : C} {f g : A ⟶ B}\n    (r : B ⟶ A) (rf : r ≫ f = 𝟙 _) (rg : r ≫ g = 𝟙 _) : HasCoequalizer f g := by\n  letI := IsReflexivePair.mk' r rf rg\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.hasEqualizer_of_common_retraction","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasCoreflexiveEqualizers C\nA B : C\nf g : Quiver.Hom A B\nr : Quiver.Hom B A\nfr : Eq (CategoryTheory.CategoryStruct.comp f r) (CategoryTheory.CategoryStruct.id A)\ngr : Eq (CategoryTheory.CategoryStruct.comp g r) (CategoryTheory.CategoryStruct.id A)\n⊢ CategoryTheory.Limits.HasEqualizer f g","decl":"theorem hasEqualizer_of_common_retraction [HasCoreflexiveEqualizers C] {A B : C} {f g : A ⟶ B}\n    (r : B ⟶ A) (fr : f ≫ r = 𝟙 _) (gr : g ≫ r = 𝟙 _) : HasEqualizer f g := by\n  letI := IsCoreflexivePair.mk' r fr gr\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.hasReflexiveCoequalizers_of_hasCoequalizers","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasCoequalizers C\n⊢ CategoryTheory.Limits.HasReflexiveCoequalizers C","decl":"/-- If `C` has coequalizers, then it has reflexive coequalizers. -/\ninstance (priority := 100) hasReflexiveCoequalizers_of_hasCoequalizers [HasCoequalizers C] :\n    HasReflexiveCoequalizers C where has_coeq A B f g _ := by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.hasCoreflexiveEqualizers_of_hasEqualizers","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasEqualizers C\n⊢ CategoryTheory.Limits.HasCoreflexiveEqualizers C","decl":"/-- If `C` has equalizers, then it has coreflexive equalizers. -/\ninstance (priority := 100) hasCoreflexiveEqualizers_of_hasEqualizers [HasEqualizers C] :\n    HasCoreflexiveEqualizers C where has_eq A B f g _ := by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.zero.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"⊢ Eq (SizeOf.sizeOf CategoryTheory.Limits.WalkingReflexivePair.zero) 1","decl":"/-- The type of objects for the diagram indexing reflexive (co)equalizers -/\ninductive WalkingReflexivePair : Type where\n  | zero\n  | one\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.one.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"⊢ Eq (SizeOf.sizeOf CategoryTheory.Limits.WalkingReflexivePair.one) 1","decl":"/-- The type of objects for the diagram indexing reflexive (co)equalizers -/\ninductive WalkingReflexivePair : Type where\n  | zero\n  | one\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.ofNat_toCtorIdx","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"x : CategoryTheory.Limits.WalkingReflexivePair\n⊢ Eq (CategoryTheory.Limits.WalkingReflexivePair.ofNat x.toCtorIdx) x","decl":"/-- The type of objects for the diagram indexing reflexive (co)equalizers -/\ninductive WalkingReflexivePair : Type where\n  | zero\n  | one\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.Hom.id_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"X : CategoryTheory.Limits.WalkingReflexivePair\n⊢ Eq (CategoryTheory.Limits.WalkingReflexivePair.Hom.id X) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\nlemma Hom.id_eq (X : WalkingReflexivePair) :\n    Hom.id X = 𝟙 X := by rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.reflexion_comp_left_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"Z : CategoryTheory.Limits.WalkingReflexivePair\nh : Quiver.Hom CategoryTheory.Limits.WalkingReflexivePair.zero Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.WalkingReflexivePair.Hom.left h)) h","decl":"@[reassoc (attr := simp)]\nlemma reflexion_comp_left : reflexion ≫ left = 𝟙 zero := rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.reflexion_comp_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (CategoryTheory.CategoryStruct.id CategoryTheory.Limits.WalkingReflexivePair.zero)","decl":"@[reassoc (attr := simp)]\nlemma reflexion_comp_left : reflexion ≫ left = 𝟙 zero := rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.reflexion_comp_right_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"Z : CategoryTheory.Limits.WalkingReflexivePair\nh : Quiver.Hom CategoryTheory.Limits.WalkingReflexivePair.zero Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.WalkingReflexivePair.Hom.right h)) h","decl":"@[reassoc (attr := simp)]\nlemma reflexion_comp_right : reflexion ≫ right = 𝟙 zero := rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.reflexion_comp_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"⊢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion CategoryTheory.Limits.WalkingReflexivePair.Hom.right) (CategoryTheory.CategoryStruct.id CategoryTheory.Limits.WalkingReflexivePair.zero)","decl":"@[reassoc (attr := simp)]\nlemma reflexion_comp_right : reflexion ≫ right = 𝟙 zero := rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.leftCompReflexion_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"⊢ Eq CategoryTheory.Limits.WalkingReflexivePair.Hom.leftCompReflexion (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.WalkingReflexivePair.Hom.left CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion)","decl":"@[simp]\nlemma leftCompReflexion_eq : leftCompReflexion = (left ≫ reflexion : one ⟶ one) := rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.rightCompReflexion_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"⊢ Eq CategoryTheory.Limits.WalkingReflexivePair.Hom.rightCompReflexion (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.WalkingReflexivePair.Hom.right CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion)","decl":"@[simp]\nlemma rightCompReflexion_eq : rightCompReflexion = (right ≫ reflexion : one ⟶ one) := rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.map_reflexion_comp_map_left_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nZ : C\nh : Quiver.Hom (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_reflexion_comp_map_left (F : WalkingReflexivePair ⥤ C) :\n    F.map reflexion ≫ F.map left = 𝟙 (F.obj zero) := by\n  rw [← F.map_comp, reflexion_comp_left, F.map_id]\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.map_reflexion_comp_map_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left)) (CategoryTheory.CategoryStruct.id (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero))","decl":"@[reassoc (attr := simp)]\nlemma map_reflexion_comp_map_left (F : WalkingReflexivePair ⥤ C) :\n    F.map reflexion ≫ F.map left = 𝟙 (F.obj zero) := by\n  rw [← F.map_comp, reflexion_comp_left, F.map_id]\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.map_reflexion_comp_map_right_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nZ : C\nh : Quiver.Hom (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_reflexion_comp_map_right (F : WalkingReflexivePair ⥤ C) :\n    F.map reflexion ≫ F.map right = 𝟙 (F.obj zero) := by\n  rw [← F.map_comp, reflexion_comp_right, F.map_id]\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.map_reflexion_comp_map_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)) (CategoryTheory.CategoryStruct.id (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero))","decl":"@[reassoc (attr := simp)]\nlemma map_reflexion_comp_map_right (F : WalkingReflexivePair ⥤ C) :\n    F.map reflexion ≫ F.map right = 𝟙 (F.obj zero) := by\n  rw [← F.map_comp, reflexion_comp_right, F.map_id]\n\n"}
{"name":"CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"X✝ Y✝ : CategoryTheory.Limits.WalkingParallelPair\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair.map f) (CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair.match_2 (fun Y X f => Quiver.Hom (CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair.match_1 (fun x => CategoryTheory.Limits.WalkingReflexivePair) X (fun _ => CategoryTheory.Limits.WalkingReflexivePair.zero) fun _ => CategoryTheory.Limits.WalkingReflexivePair.one) (CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair.match_1 (fun x => CategoryTheory.Limits.WalkingReflexivePair) Y (fun _ => CategoryTheory.Limits.WalkingReflexivePair.zero) fun _ => CategoryTheory.Limits.WalkingReflexivePair.one)) Y✝ X✝ f (fun _ => CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (fun _ => CategoryTheory.Limits.WalkingReflexivePair.Hom.right) fun x => CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair.match_1 (fun x => CategoryTheory.Limits.WalkingReflexivePair) x (fun _ => CategoryTheory.Limits.WalkingReflexivePair.zero) fun _ => CategoryTheory.Limits.WalkingReflexivePair.one))","decl":"/-- The inclusion functor forgetting the common section -/\n@[simps!]\ndef inclusionWalkingReflexivePair : WalkingParallelPair ⥤ WalkingReflexivePair where\n  obj := fun x => match x with\n    | one => WalkingReflexivePair.zero\n    | zero => WalkingReflexivePair.one\n  map := fun f => match f with\n    | .left => WalkingReflexivePair.Hom.left\n    | .right => WalkingReflexivePair.Hom.right\n    | .id _ => WalkingReflexivePair.Hom.id _\n  map_comp := by\n    intro _ _ _ f g; cases f <;> cases g <;> rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"x : CategoryTheory.Limits.WalkingParallelPair\n⊢ Eq (CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair.obj x) (CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair.match_1 (fun x => CategoryTheory.Limits.WalkingReflexivePair) x (fun _ => CategoryTheory.Limits.WalkingReflexivePair.zero) fun _ => CategoryTheory.Limits.WalkingReflexivePair.one)","decl":"/-- The inclusion functor forgetting the common section -/\n@[simps!]\ndef inclusionWalkingReflexivePair : WalkingParallelPair ⥤ WalkingReflexivePair where\n  obj := fun x => match x with\n    | one => WalkingReflexivePair.zero\n    | zero => WalkingReflexivePair.one\n  map := fun f => match f with\n    | .left => WalkingReflexivePair.Hom.left\n    | .right => WalkingReflexivePair.Hom.right\n    | .id _ => WalkingReflexivePair.Hom.id _\n  map_comp := by\n    intro _ _ _ f g; cases f <;> cases g <;> rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingParallelPair.instNonemptyStructuredArrowWalkingReflexivePairInclusionWalkingReflexivePair","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"X : CategoryTheory.Limits.WalkingReflexivePair\n⊢ Nonempty (CategoryTheory.StructuredArrow X CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair)","decl":"instance (X : WalkingReflexivePair) :\n    Nonempty (StructuredArrow X inclusionWalkingReflexivePair) := by\n  cases X with\n  | zero => exact ⟨StructuredArrow.mk (Y := one) (𝟙 _)⟩\n  | one => exact ⟨StructuredArrow.mk (Y := zero) (𝟙 _)⟩\n\n"}
{"name":"CategoryTheory.Limits.WalkingParallelPair.instIsConnectedStructuredArrowWalkingReflexivePairInclusionWalkingReflexivePair","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"X : CategoryTheory.Limits.WalkingReflexivePair\n⊢ CategoryTheory.IsConnected (CategoryTheory.StructuredArrow X CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair)","decl":"open WalkingReflexivePair.Hom in\ninstance (X : WalkingReflexivePair) :\n    IsConnected (StructuredArrow X inclusionWalkingReflexivePair) := by\n  cases X with\n  | zero =>\n      refine IsConnected.of_induct  (j₀ := StructuredArrow.mk (Y := one) (𝟙 _)) ?_\n      rintro p h₁ h₂ ⟨⟨⟨⟩⟩, (_ | _), ⟨_⟩⟩\n      · exact (h₂ (StructuredArrow.homMk .left)).2 h₁\n      · exact h₁\n  | one =>\n      refine IsConnected.of_induct  (j₀ := StructuredArrow.mk (Y := zero) (𝟙 _))\n        (fun p h₁ h₂ ↦ ?_)\n      have hₗ : StructuredArrow.mk left ∈ p := (h₂ (StructuredArrow.homMk .left)).1 h₁\n      have hᵣ : StructuredArrow.mk right ∈ p := (h₂ (StructuredArrow.homMk .right)).1 h₁\n      rintro ⟨⟨⟨⟩⟩, (_ | _), ⟨_⟩⟩\n      · exact (h₂ (StructuredArrow.homMk .left)).2 hₗ\n      · exact (h₂ (StructuredArrow.homMk .right)).2 hᵣ\n      all_goals assumption\n\n"}
{"name":"CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair_final","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"⊢ CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair.Final","decl":"/-- The inclusion functor is a final functor -/\ninstance inclusionWalkingReflexivePair_final : Functor.Final inclusionWalkingReflexivePair where\n  out := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair_obj_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ns : Quiver.Hom B A\nsl : Eq (CategoryTheory.CategoryStruct.comp s f) (CategoryTheory.CategoryStruct.id B)\nsr : Eq (CategoryTheory.CategoryStruct.comp s g) (CategoryTheory.CategoryStruct.id B)\n⊢ Eq ((CategoryTheory.Limits.reflexivePair f g s sl sr).obj CategoryTheory.Limits.WalkingReflexivePair.zero) B","decl":"@[simp] lemma reflexivePair_obj_zero : (reflexivePair f g s sl sr).obj zero = B := rfl\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair_obj_one","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ns : Quiver.Hom B A\nsl : Eq (CategoryTheory.CategoryStruct.comp s f) (CategoryTheory.CategoryStruct.id B)\nsr : Eq (CategoryTheory.CategoryStruct.comp s g) (CategoryTheory.CategoryStruct.id B)\n⊢ Eq ((CategoryTheory.Limits.reflexivePair f g s sl sr).obj CategoryTheory.Limits.WalkingReflexivePair.one) A","decl":"@[simp] lemma reflexivePair_obj_one : (reflexivePair f g s sl sr).obj one = A := rfl\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair_map_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ns : Quiver.Hom B A\nsl : Eq (CategoryTheory.CategoryStruct.comp s f) (CategoryTheory.CategoryStruct.id B)\nsr : Eq (CategoryTheory.CategoryStruct.comp s g) (CategoryTheory.CategoryStruct.id B)\n⊢ Eq ((CategoryTheory.Limits.reflexivePair f g s sl sr).map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) f","decl":"@[simp] lemma reflexivePair_map_right : (reflexivePair f g s sl sr).map .left = f := rfl\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair_map_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ns : Quiver.Hom B A\nsl : Eq (CategoryTheory.CategoryStruct.comp s f) (CategoryTheory.CategoryStruct.id B)\nsr : Eq (CategoryTheory.CategoryStruct.comp s g) (CategoryTheory.CategoryStruct.id B)\n⊢ Eq ((CategoryTheory.Limits.reflexivePair f g s sl sr).map CategoryTheory.Limits.WalkingReflexivePair.Hom.right) g","decl":"@[simp] lemma reflexivePair_map_left : (reflexivePair f g s sl sr).map .right = g := rfl\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair_map_reflexion","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ns : Quiver.Hom B A\nsl : Eq (CategoryTheory.CategoryStruct.comp s f) (CategoryTheory.CategoryStruct.id B)\nsr : Eq (CategoryTheory.CategoryStruct.comp s g) (CategoryTheory.CategoryStruct.id B)\n⊢ Eq ((CategoryTheory.Limits.reflexivePair f g s sl sr).map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion) s","decl":"@[simp] lemma reflexivePair_map_reflexion : (reflexivePair f g s sl sr).map .reflexion = s := rfl\n\n"}
{"name":"CategoryTheory.Limits.ofIsReflexivePair_map_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsReflexivePair f g\n⊢ Eq ((CategoryTheory.Limits.ofIsReflexivePair f g).map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) f","decl":"@[simp]\nlemma ofIsReflexivePair_map_left (f g : A ⟶ B) [IsReflexivePair f g] :\n    (ofIsReflexivePair f g).map .left = f := rfl\n\n"}
{"name":"CategoryTheory.Limits.ofIsReflexivePair_map_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsReflexivePair f g\n⊢ Eq ((CategoryTheory.Limits.ofIsReflexivePair f g).map CategoryTheory.Limits.WalkingReflexivePair.Hom.right) g","decl":"@[simp]\nlemma ofIsReflexivePair_map_right (f g : A ⟶ B) [IsReflexivePair f g] :\n    (ofIsReflexivePair f g).map .right = g := rfl\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair.mkNatTrans_app_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\ne₀ : Quiver.Hom (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero) (G.obj CategoryTheory.Limits.WalkingReflexivePair.zero)\n⊢ Eq (sorryAx (Unit → Quiver.Hom (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero) (G.obj CategoryTheory.Limits.WalkingReflexivePair.zero)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 421).num 28).num 421).num 64).num 28).num 64).str \"_sorry\").str \"_@\").str \"_hyg\").num 4226))) e₀","decl":"@[simp]\nlemma mkNatTrans_app_zero : (mkNatTrans e₀ e₁ h₁ h₂ h₃).app zero = e₀ := rfl\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair.mkNatTrans_app_one","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\ne₁ : Quiver.Hom (F.obj CategoryTheory.Limits.WalkingReflexivePair.one) (G.obj CategoryTheory.Limits.WalkingReflexivePair.one)\n⊢ Eq (sorryAx (Unit → Quiver.Hom (F.obj CategoryTheory.Limits.WalkingReflexivePair.one) (G.obj CategoryTheory.Limits.WalkingReflexivePair.one)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 424).num 27).num 424).num 62).num 27).num 62).str \"_sorry\").str \"_@\").str \"_hyg\").num 4368))) e₁","decl":"@[simp]\nlemma mkNatTrans_app_one : (mkNatTrans e₀ e₁ h₁ h₂ h₃).app one = e₁ := rfl\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair.mkNatIso_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\ne₀ : CategoryTheory.Iso (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero) (G.obj CategoryTheory.Limits.WalkingReflexivePair.zero)\ne₁ : CategoryTheory.Iso (F.obj CategoryTheory.Limits.WalkingReflexivePair.one) (G.obj CategoryTheory.Limits.WalkingReflexivePair.one)\nh₁ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) e₀.hom) (CategoryTheory.CategoryStruct.comp e₁.hom (G.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left))) _auto✝\nh₂ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right) e₀.hom) (CategoryTheory.CategoryStruct.comp e₁.hom (G.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right))) _auto✝\nh₃ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion) e₁.hom) (CategoryTheory.CategoryStruct.comp e₀.hom (G.map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion))) _auto✝\nx : CategoryTheory.Limits.WalkingReflexivePair\n⊢ Eq ((CategoryTheory.Limits.reflexivePair.mkNatIso e₀ e₁ h₁ h₂ h₃).hom.app x) (CategoryTheory.Limits.reflexivePair.match_1 (fun x => Quiver.Hom (F.obj x) (G.obj x)) x (fun _ => e₀.hom) fun _ => e₁.hom)","decl":"/-- Constructor for natural isomorphisms between functors out of `WalkingReflexivePair`. -/\n@[simps!]\ndef mkNatIso (e₀ : F.obj zero ≅ G.obj zero) (e₁ : F.obj one ≅ G.obj one)\n    (h₁ : F.map left ≫ e₀.hom = e₁.hom ≫ G.map left := by aesop_cat)\n    (h₂ : F.map right ≫ e₀.hom = e₁.hom ≫ G.map right := by aesop_cat)\n    (h₃ : F.map reflexion ≫ e₁.hom = e₀.hom ≫ G.map reflexion := by aesop_cat) :\n    F ≅ G where\n  hom := mkNatTrans e₀.hom e₁.hom\n  inv := mkNatTrans e₀.inv e₁.inv\n        (by rw [← cancel_epi e₁.hom, e₁.hom_inv_id_assoc, ← reassoc_of% h₁, e₀.hom_inv_id,\n            Category.comp_id])\n        (by rw [← cancel_epi e₁.hom, e₁.hom_inv_id_assoc, ← reassoc_of% h₂, e₀.hom_inv_id,\n            Category.comp_id])\n        (by rw [← cancel_epi e₀.hom, e₀.hom_inv_id_assoc, ← reassoc_of% h₃, e₁.hom_inv_id,\n            Category.comp_id])\n  hom_inv_id := by ext x; cases x <;> simp\n  inv_hom_id := by ext x; cases x <;> simp\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair.mkNatIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\ne₀ : CategoryTheory.Iso (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero) (G.obj CategoryTheory.Limits.WalkingReflexivePair.zero)\ne₁ : CategoryTheory.Iso (F.obj CategoryTheory.Limits.WalkingReflexivePair.one) (G.obj CategoryTheory.Limits.WalkingReflexivePair.one)\nh₁ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) e₀.hom) (CategoryTheory.CategoryStruct.comp e₁.hom (G.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left))) _auto✝\nh₂ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right) e₀.hom) (CategoryTheory.CategoryStruct.comp e₁.hom (G.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right))) _auto✝\nh₃ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion) e₁.hom) (CategoryTheory.CategoryStruct.comp e₀.hom (G.map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion))) _auto✝\n⊢ Eq (CategoryTheory.Limits.reflexivePair.mkNatIso e₀ e₁ h₁ h₂ h₃).inv (sorryAx (Unit → Quiver.Hom G F) Bool.true Unit.unit)","decl":"/-- Constructor for natural isomorphisms between functors out of `WalkingReflexivePair`. -/\n@[simps!]\ndef mkNatIso (e₀ : F.obj zero ≅ G.obj zero) (e₁ : F.obj one ≅ G.obj one)\n    (h₁ : F.map left ≫ e₀.hom = e₁.hom ≫ G.map left := by aesop_cat)\n    (h₂ : F.map right ≫ e₀.hom = e₁.hom ≫ G.map right := by aesop_cat)\n    (h₃ : F.map reflexion ≫ e₁.hom = e₀.hom ≫ G.map reflexion := by aesop_cat) :\n    F ≅ G where\n  hom := mkNatTrans e₀.hom e₁.hom\n  inv := mkNatTrans e₀.inv e₁.inv\n        (by rw [← cancel_epi e₁.hom, e₁.hom_inv_id_assoc, ← reassoc_of% h₁, e₀.hom_inv_id,\n            Category.comp_id])\n        (by rw [← cancel_epi e₁.hom, e₁.hom_inv_id_assoc, ← reassoc_of% h₂, e₀.hom_inv_id,\n            Category.comp_id])\n        (by rw [← cancel_epi e₀.hom, e₀.hom_inv_id_assoc, ← reassoc_of% h₃, e₁.hom_inv_id,\n            Category.comp_id])\n  hom_inv_id := by ext x; cases x <;> simp\n  inv_hom_id := by ext x; cases x <;> simp\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair.diagramIsoReflexivePair_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\n⊢ Eq (CategoryTheory.Limits.reflexivePair.diagramIsoReflexivePair F).inv (sorryAx (Unit → Quiver.Hom (CategoryTheory.Limits.reflexivePair (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion) ⋯ ⋯) F) Bool.true Unit.unit)","decl":"/-- Every functor out of `WalkingReflexivePair` is isomorphic to the `reflexivePair` given by\nits components -/\n@[simps!]\ndef diagramIsoReflexivePair :\n    F ≅ reflexivePair (F.map left) (F.map right) (F.map reflexion) :=\n  mkNatIso (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair.diagramIsoReflexivePair_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nx : CategoryTheory.Limits.WalkingReflexivePair\n⊢ Eq ((CategoryTheory.Limits.reflexivePair.diagramIsoReflexivePair F).hom.app x) (CategoryTheory.Limits.reflexivePair.match_1 (fun x => Quiver.Hom (F.obj x) ((CategoryTheory.Limits.reflexivePair (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion) ⋯ ⋯).obj x)) x (fun _ => CategoryTheory.CategoryStruct.id (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero)) fun _ => CategoryTheory.CategoryStruct.id (F.obj CategoryTheory.Limits.WalkingReflexivePair.one))","decl":"/-- Every functor out of `WalkingReflexivePair` is isomorphic to the `reflexivePair` given by\nits components -/\n@[simps!]\ndef diagramIsoReflexivePair :\n    F ≅ reflexivePair (F.map left) (F.map right) (F.map reflexion) :=\n  mkNatIso (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair.compRightIso_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nA B : C\nf g : Quiver.Hom A B\ns : Quiver.Hom B A\nsl : Eq (CategoryTheory.CategoryStruct.comp s f) (CategoryTheory.CategoryStruct.id B)\nsr : Eq (CategoryTheory.CategoryStruct.comp s g) (CategoryTheory.CategoryStruct.id B)\nF : CategoryTheory.Functor C D\nx : CategoryTheory.Limits.WalkingReflexivePair\n⊢ Eq ((CategoryTheory.Limits.reflexivePair.compRightIso f g s sl sr F).hom.app x) (CategoryTheory.Limits.reflexivePair.match_1 (fun x => Quiver.Hom (F.obj ((CategoryTheory.Limits.reflexivePair f g s sl sr).obj x)) ((CategoryTheory.Limits.reflexivePair (F.map f) (F.map g) (F.map s) ⋯ ⋯).obj x)) x (fun _ => CategoryTheory.CategoryStruct.id (F.obj B)) fun _ => CategoryTheory.CategoryStruct.id (F.obj A))","decl":"/-- A `reflexivePair` composed with a functor is isomorphic to the `reflexivePair` obtained by\napplying the functor at each map. -/\n@[simps!]\ndef compRightIso {D : Type u₂} [Category.{v₂} D] {A B : C}\n    (f g : A ⟶ B) (s : B ⟶ A) (sl : s ≫ f = 𝟙 B) (sr : s ≫ g = 𝟙 B) (F : C ⥤ D) :\n    (reflexivePair f g s sl sr) ⋙ F ≅ reflexivePair (F.map f) (F.map g) (F.map s)\n      (by simp only [← Functor.map_comp, sl, Functor.map_id])\n      (by simp only [← Functor.map_comp, sr, Functor.map_id]) :=\n  mkNatIso (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair.compRightIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nA B : C\nf g : Quiver.Hom A B\ns : Quiver.Hom B A\nsl : Eq (CategoryTheory.CategoryStruct.comp s f) (CategoryTheory.CategoryStruct.id B)\nsr : Eq (CategoryTheory.CategoryStruct.comp s g) (CategoryTheory.CategoryStruct.id B)\nF : CategoryTheory.Functor C D\n⊢ Eq (CategoryTheory.Limits.reflexivePair.compRightIso f g s sl sr F).inv (sorryAx (Unit → Quiver.Hom (CategoryTheory.Limits.reflexivePair (F.map f) (F.map g) (F.map s) ⋯ ⋯) ((CategoryTheory.Limits.reflexivePair f g s sl sr).comp F)) Bool.true Unit.unit)","decl":"/-- A `reflexivePair` composed with a functor is isomorphic to the `reflexivePair` obtained by\napplying the functor at each map. -/\n@[simps!]\ndef compRightIso {D : Type u₂} [Category.{v₂} D] {A B : C}\n    (f g : A ⟶ B) (s : B ⟶ A) (sl : s ≫ f = 𝟙 B) (sr : s ≫ g = 𝟙 B) (F : C ⥤ D) :\n    (reflexivePair f g s sl sr) ⋙ F ≅ reflexivePair (F.map f) (F.map g) (F.map s)\n      (by simp only [← Functor.map_comp, sl, Functor.map_id])\n      (by simp only [← Functor.map_comp, sr, Functor.map_id]) :=\n  mkNatIso (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair.to_isReflexivePair","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\n⊢ CategoryTheory.IsReflexivePair (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)","decl":"/-- Any functor out of the WalkingReflexivePair yields a reflexive pair -/\ninstance to_isReflexivePair {F : WalkingReflexivePair ⥤ C} :\n    IsReflexivePair (F.map .left) (F.map .right) :=\n  ⟨F.map .reflexion, map_reflexion_comp_map_left F, map_reflexion_comp_map_right F⟩\n\n"}
{"name":"CategoryTheory.Limits.ReflexiveCofork.mk_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nX : C\nπ : Quiver.Hom (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero) X\nh : Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) π) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right) π)\n⊢ Eq (CategoryTheory.Limits.ReflexiveCofork.mk π h).pt X","decl":"/-- Constructor for `ReflexiveCofork` -/\n@[simps pt]\ndef mk {X : C} (π : F.obj zero ⟶ X) (h : F.map left ≫ π = F.map right ≫ π) :\n    ReflexiveCofork F where\n  pt := X\n  ι := reflexivePair.mkNatTrans π (F.map left ≫ π)\n\n"}
{"name":"CategoryTheory.Limits.ReflexiveCofork.mk_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nX : C\nπ : Quiver.Hom (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero) X\nh : Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) π) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right) π)\n⊢ Eq (CategoryTheory.Limits.ReflexiveCofork.mk π h).π π","decl":"@[simp]\nlemma mk_π {X : C} (π : F.obj zero ⟶ X) (h : F.map left ≫ π = F.map right ≫ π) :\n    (mk π h).π = π := rfl\n\n"}
{"name":"CategoryTheory.Limits.ReflexiveCofork.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nG : CategoryTheory.Limits.ReflexiveCofork F\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) G.π) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right) G.π)","decl":"lemma condition (G : ReflexiveCofork F) : F.map left ≫ G.π = F.map right ≫ G.π := by\n  rw [Cocone.w G left, Cocone.w G right]\n\n"}
{"name":"CategoryTheory.Limits.ReflexiveCofork.app_one_eq_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nG : CategoryTheory.Limits.ReflexiveCofork F\n⊢ Eq (G.ι.app CategoryTheory.Limits.WalkingReflexivePair.zero) G.π","decl":"@[simp]\nlemma app_one_eq_π (G : ReflexiveCofork F) : G.ι.app zero = G.π := rfl\n\n"}
{"name":"CategoryTheory.Limits.reflexiveCoforkEquivCofork_inverse_obj_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nX : CategoryTheory.Limits.Cofork (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)\n⊢ Eq ((CategoryTheory.Limits.reflexiveCoforkEquivCofork F).inverse.obj X).pt X.pt","decl":"/-- Forgetting the reflexion yields an equivalence between cocones over a bundled reflexive pair and\ncoforks on the underlying parallel pair. -/\n@[simps! functor_obj_pt inverse_obj_pt]\ndef reflexiveCoforkEquivCofork :\n    ReflexiveCofork F ≌ Cofork (F.map left) (F.map right) :=\n  (Functor.Final.coconesEquiv _ F).symm.trans (Cocones.precomposeEquivalence\n    (diagramIsoParallelPair (WalkingParallelPair.inclusionWalkingReflexivePair ⋙ F))).symm\n\n"}
{"name":"CategoryTheory.Limits.reflexiveCoforkEquivCofork_functor_obj_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nX : CategoryTheory.Limits.Cocone F\n⊢ Eq ((CategoryTheory.Limits.reflexiveCoforkEquivCofork F).functor.obj X).pt X.pt","decl":"/-- Forgetting the reflexion yields an equivalence between cocones over a bundled reflexive pair and\ncoforks on the underlying parallel pair. -/\n@[simps! functor_obj_pt inverse_obj_pt]\ndef reflexiveCoforkEquivCofork :\n    ReflexiveCofork F ≌ Cofork (F.map left) (F.map right) :=\n  (Functor.Final.coconesEquiv _ F).symm.trans (Cocones.precomposeEquivalence\n    (diagramIsoParallelPair (WalkingParallelPair.inclusionWalkingReflexivePair ⋙ F))).symm\n\n"}
{"name":"CategoryTheory.Limits.reflexiveCoforkEquivCofork_functor_obj_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nG : CategoryTheory.Limits.ReflexiveCofork F\n⊢ Eq ((CategoryTheory.Limits.reflexiveCoforkEquivCofork F).functor.obj G).π G.π","decl":"@[simp]\nlemma reflexiveCoforkEquivCofork_functor_obj_π (G : ReflexiveCofork F) :\n    ((reflexiveCoforkEquivCofork F).functor.obj G).π = G.π := by\n  dsimp [reflexiveCoforkEquivCofork]\n  rw [ReflexiveCofork.π, Cofork.π]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.reflexiveCoforkEquivCofork_inverse_obj_π","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nG : CategoryTheory.Limits.Cofork (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)\n⊢ Eq ((CategoryTheory.Limits.reflexiveCoforkEquivCofork F).inverse.obj G).π G.π","decl":"@[simp]\nlemma reflexiveCoforkEquivCofork_inverse_obj_π\n    (G : Cofork (F.map left) (F.map right)) :\n    ((reflexiveCoforkEquivCofork F).inverse.obj G).π = G.π := by\n  dsimp only [reflexiveCoforkEquivCofork, Equivalence.symm, Equivalence.trans,\n    ReflexiveCofork.π, Cocones.precomposeEquivalence, Cocones.precompose,\n    Functor.comp, Functor.Final.coconesEquiv]\n  rw [Functor.Final.extendCocone_obj_ι_app' (Y := .one) (f := 𝟙 zero)]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.hasReflexiveCoequalizer_iff_hasCoequalizer","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\n⊢ Iff (CategoryTheory.Limits.HasColimit F) (CategoryTheory.Limits.HasCoequalizer (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right))","decl":"lemma hasReflexiveCoequalizer_iff_hasCoequalizer :\n    HasColimit F ↔ HasCoequalizer (F.map left) (F.map right) := by\n  simpa only [hasColimit_iff_hasInitial_cocone]\n    using Equivalence.hasInitial_iff (reflexiveCoforkEquivCofork F)\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair_hasColimit_of_hasCoequalizer","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nh : CategoryTheory.Limits.HasCoequalizer (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)\n⊢ CategoryTheory.Limits.HasColimit F","decl":"instance reflexivePair_hasColimit_of_hasCoequalizer\n    [h : HasCoequalizer (F.map left) (F.map right)] : HasColimit F :=\n  hasReflexiveCoequalizer_iff_hasCoequalizer _|>.mpr h\n\n"}
{"name":"CategoryTheory.Limits.ι_reflexiveCoequalizerIsoCoequalizer_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\ninst✝ : CategoryTheory.Limits.HasCoequalizer (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F CategoryTheory.Limits.WalkingReflexivePair.zero) (CategoryTheory.Limits.reflexiveCoequalizerIsoCoequalizer F).hom) (CategoryTheory.Limits.coequalizer.π (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right))","decl":"@[reassoc (attr := simp)]\nlemma ι_reflexiveCoequalizerIsoCoequalizer_hom :\n    colimit.ι F zero ≫ (reflexiveCoequalizerIsoCoequalizer F).hom =\n      coequalizer.π (F.map left) (F.map right) :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom\n    ((ReflexiveCofork.isColimitEquiv F _).symm _) _ WalkingParallelPair.one\n\n"}
{"name":"CategoryTheory.Limits.ι_reflexiveCoequalizerIsoCoequalizer_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\ninst✝ : CategoryTheory.Limits.HasCoequalizer (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coequalizer (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F CategoryTheory.Limits.WalkingReflexivePair.zero) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.reflexiveCoequalizerIsoCoequalizer F).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.π (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)) h)","decl":"@[reassoc (attr := simp)]\nlemma ι_reflexiveCoequalizerIsoCoequalizer_hom :\n    colimit.ι F zero ≫ (reflexiveCoequalizerIsoCoequalizer F).hom =\n      coequalizer.π (F.map left) (F.map right) :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom\n    ((ReflexiveCofork.isColimitEquiv F _).symm _) _ WalkingParallelPair.one\n\n"}
{"name":"CategoryTheory.Limits.π_reflexiveCoequalizerIsoCoequalizer_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\ninst✝ : CategoryTheory.Limits.HasCoequalizer (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit F) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.π (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.reflexiveCoequalizerIsoCoequalizer F).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι F CategoryTheory.Limits.WalkingReflexivePair.zero) h)","decl":"@[reassoc (attr := simp)]\nlemma π_reflexiveCoequalizerIsoCoequalizer_inv :\n    coequalizer.π _ _ ≫ (reflexiveCoequalizerIsoCoequalizer F).inv = colimit.ι F _ := by\n  rw [reflexiveCoequalizerIsoCoequalizer]\n  simp only [colimit.comp_coconePointUniqueUpToIso_inv, Cofork.ofπ_pt, colimit.cocone_x,\n    Cofork.ofπ_ι_app, colimit.cocone_ι]\n\n"}
{"name":"CategoryTheory.Limits.π_reflexiveCoequalizerIsoCoequalizer_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\ninst✝ : CategoryTheory.Limits.HasCoequalizer (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.π (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)) (CategoryTheory.Limits.reflexiveCoequalizerIsoCoequalizer F).inv) (CategoryTheory.Limits.colimit.ι F CategoryTheory.Limits.WalkingReflexivePair.zero)","decl":"@[reassoc (attr := simp)]\nlemma π_reflexiveCoequalizerIsoCoequalizer_inv :\n    coequalizer.π _ _ ≫ (reflexiveCoequalizerIsoCoequalizer F).inv = colimit.ι F _ := by\n  rw [reflexiveCoequalizerIsoCoequalizer]\n  simp only [colimit.comp_coconePointUniqueUpToIso_inv, Cofork.ofπ_pt, colimit.cocone_x,\n    Cofork.ofπ_ι_app, colimit.cocone_ι]\n\n"}
{"name":"CategoryTheory.Limits.ofIsReflexivePair_hasColimit_of_hasCoequalizer","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsReflexivePair f g\nh : CategoryTheory.Limits.HasCoequalizer f g\n⊢ CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.ofIsReflexivePair f g)","decl":"instance ofIsReflexivePair_hasColimit_of_hasCoequalizer :\n    HasColimit (ofIsReflexivePair f g) :=\n  hasReflexiveCoequalizer_iff_hasCoequalizer _|>.mpr h\n\n"}
{"name":"CategoryTheory.Limits.ι_colimitOfIsReflexivePairIsoCoequalizer_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsReflexivePair f g\nh✝ : CategoryTheory.Limits.HasCoequalizer f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coequalizer f g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (CategoryTheory.Limits.ofIsReflexivePair f g) CategoryTheory.Limits.WalkingReflexivePair.zero) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.colimitOfIsReflexivePairIsoCoequalizer.hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.π f g) h)","decl":"@[reassoc (attr := simp)]\nlemma ι_colimitOfIsReflexivePairIsoCoequalizer_hom :\n    colimit.ι (ofIsReflexivePair f g) zero ≫ colimitOfIsReflexivePairIsoCoequalizer.hom =\n      coequalizer.π f g := @ι_reflexiveCoequalizerIsoCoequalizer_hom _ _ _ h\n\n"}
{"name":"CategoryTheory.Limits.ι_colimitOfIsReflexivePairIsoCoequalizer_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsReflexivePair f g\nh : CategoryTheory.Limits.HasCoequalizer f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (CategoryTheory.Limits.ofIsReflexivePair f g) CategoryTheory.Limits.WalkingReflexivePair.zero) CategoryTheory.Limits.colimitOfIsReflexivePairIsoCoequalizer.hom) (CategoryTheory.Limits.coequalizer.π f g)","decl":"@[reassoc (attr := simp)]\nlemma ι_colimitOfIsReflexivePairIsoCoequalizer_hom :\n    colimit.ι (ofIsReflexivePair f g) zero ≫ colimitOfIsReflexivePairIsoCoequalizer.hom =\n      coequalizer.π f g := @ι_reflexiveCoequalizerIsoCoequalizer_hom _ _ _ h\n\n"}
{"name":"CategoryTheory.Limits.π_colimitOfIsReflexivePairIsoCoequalizer_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsReflexivePair f g\nh✝ : CategoryTheory.Limits.HasCoequalizer f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit (CategoryTheory.Limits.ofIsReflexivePair f g)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.π f g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.colimitOfIsReflexivePairIsoCoequalizer.inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (CategoryTheory.Limits.ofIsReflexivePair f g) CategoryTheory.Limits.WalkingReflexivePair.zero) h)","decl":"@[reassoc (attr := simp)]\nlemma π_colimitOfIsReflexivePairIsoCoequalizer_inv :\n    coequalizer.π f g ≫ colimitOfIsReflexivePairIsoCoequalizer.inv =\n      colimit.ι (ofIsReflexivePair f g) zero :=\n  @π_reflexiveCoequalizerIsoCoequalizer_inv _ _ (ofIsReflexivePair f g) h\n\n"}
{"name":"CategoryTheory.Limits.π_colimitOfIsReflexivePairIsoCoequalizer_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsReflexivePair f g\nh : CategoryTheory.Limits.HasCoequalizer f g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.π f g) CategoryTheory.Limits.colimitOfIsReflexivePairIsoCoequalizer.inv) (CategoryTheory.Limits.colimit.ι (CategoryTheory.Limits.ofIsReflexivePair f g) CategoryTheory.Limits.WalkingReflexivePair.zero)","decl":"@[reassoc (attr := simp)]\nlemma π_colimitOfIsReflexivePairIsoCoequalizer_inv :\n    coequalizer.π f g ≫ colimitOfIsReflexivePairIsoCoequalizer.inv =\n      colimit.ι (ofIsReflexivePair f g) zero :=\n  @π_reflexiveCoequalizerIsoCoequalizer_inv _ _ (ofIsReflexivePair f g) h\n\n"}
{"name":"CategoryTheory.Limits.hasReflexiveCoequalizers_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Iff (CategoryTheory.Limits.HasColimitsOfShape CategoryTheory.Limits.WalkingReflexivePair C) (CategoryTheory.Limits.HasReflexiveCoequalizers C)","decl":"/-- A category has coequalizers of reflexive pairs if and only if it has all colimits indexed by the\nwalking reflexive pair. -/\ntheorem hasReflexiveCoequalizers_iff :\n    HasColimitsOfShape WalkingReflexivePair C ↔ HasReflexiveCoequalizers C :=\n  ⟨fun _ ↦ ⟨fun _ _ f g _ ↦ (hasReflexiveCoequalizer_iff_hasCoequalizer\n      (reflexivePair f g (commonSection f g))).1 inferInstance⟩,\n    fun _ ↦ ⟨inferInstance⟩⟩\n\n"}
