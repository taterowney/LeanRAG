{"name":"CategoryTheory.IsReflexivePair.common_section'","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\nself : CategoryTheory.IsReflexivePair f g\n‚ä¢ Exists fun s => And (Eq (CategoryTheory.CategoryStruct.comp s f) (CategoryTheory.CategoryStruct.id B)) (Eq (CategoryTheory.CategoryStruct.comp s g) (CategoryTheory.CategoryStruct.id B))","decl":"/-- The pair `f g : A ‚ü∂ B` is reflexive if there is a morphism `B ‚ü∂ A` which is a section for both.\n-/\nclass IsReflexivePair (f g : A ‚ü∂ B) : Prop where\n  common_section' : ‚àÉ s : B ‚ü∂ A, s ‚â´ f = ùüô B ‚àß s ‚â´ g = ùüô B\n\n"}
{"name":"CategoryTheory.IsReflexivePair.common_section","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsReflexivePair f g\n‚ä¢ Exists fun s => And (Eq (CategoryTheory.CategoryStruct.comp s f) (CategoryTheory.CategoryStruct.id B)) (Eq (CategoryTheory.CategoryStruct.comp s g) (CategoryTheory.CategoryStruct.id B))","decl":"theorem IsReflexivePair.common_section (f g : A ‚ü∂ B) [IsReflexivePair f g] :\n    ‚àÉ s : B ‚ü∂ A, s ‚â´ f = ùüô B ‚àß s ‚â´ g = ùüô B := IsReflexivePair.common_section'\n\n"}
{"name":"CategoryTheory.IsCoreflexivePair.common_retraction'","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\nself : CategoryTheory.IsCoreflexivePair f g\n‚ä¢ Exists fun s => And (Eq (CategoryTheory.CategoryStruct.comp f s) (CategoryTheory.CategoryStruct.id A)) (Eq (CategoryTheory.CategoryStruct.comp g s) (CategoryTheory.CategoryStruct.id A))","decl":"/--\nThe pair `f g : A ‚ü∂ B` is coreflexive if there is a morphism `B ‚ü∂ A` which is a retraction for both.\n-/\nclass IsCoreflexivePair (f g : A ‚ü∂ B) : Prop where\n  common_retraction' : ‚àÉ s : B ‚ü∂ A, f ‚â´ s = ùüô A ‚àß g ‚â´ s = ùüô A\n\n"}
{"name":"CategoryTheory.IsCoreflexivePair.common_retraction","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsCoreflexivePair f g\n‚ä¢ Exists fun s => And (Eq (CategoryTheory.CategoryStruct.comp f s) (CategoryTheory.CategoryStruct.id A)) (Eq (CategoryTheory.CategoryStruct.comp g s) (CategoryTheory.CategoryStruct.id A))","decl":"theorem IsCoreflexivePair.common_retraction (f g : A ‚ü∂ B) [IsCoreflexivePair f g] :\n    ‚àÉ s : B ‚ü∂ A, f ‚â´ s = ùüô A ‚àß g ‚â´ s = ùüô A := IsCoreflexivePair.common_retraction'\n\n"}
{"name":"CategoryTheory.IsReflexivePair.mk'","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ns : Quiver.Hom B A\nsf : Eq (CategoryTheory.CategoryStruct.comp s f) (CategoryTheory.CategoryStruct.id B)\nsg : Eq (CategoryTheory.CategoryStruct.comp s g) (CategoryTheory.CategoryStruct.id B)\n‚ä¢ CategoryTheory.IsReflexivePair f g","decl":"theorem IsReflexivePair.mk' (s : B ‚ü∂ A) (sf : s ‚â´ f = ùüô B) (sg : s ‚â´ g = ùüô B) :\n    IsReflexivePair f g :=\n  ‚ü®‚ü®s, sf, sg‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.IsCoreflexivePair.mk'","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ns : Quiver.Hom B A\nfs : Eq (CategoryTheory.CategoryStruct.comp f s) (CategoryTheory.CategoryStruct.id A)\ngs : Eq (CategoryTheory.CategoryStruct.comp g s) (CategoryTheory.CategoryStruct.id A)\n‚ä¢ CategoryTheory.IsCoreflexivePair f g","decl":"theorem IsCoreflexivePair.mk' (s : B ‚ü∂ A) (fs : f ‚â´ s = ùüô A) (gs : g ‚â´ s = ùüô A) :\n    IsCoreflexivePair f g :=\n  ‚ü®‚ü®s, fs, gs‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.section_comp_left_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsReflexivePair f g\nZ : C\nh : Quiver.Hom B Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.commonSection f g) (CategoryTheory.CategoryStruct.comp f h)) h","decl":"@[reassoc (attr := simp)]\ntheorem section_comp_left (f g : A ‚ü∂ B) [IsReflexivePair f g] : commonSection f g ‚â´ f = ùüô B :=\n  (IsReflexivePair.common_section f g).choose_spec.1\n\n"}
{"name":"CategoryTheory.section_comp_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsReflexivePair f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.commonSection f g) f) (CategoryTheory.CategoryStruct.id B)","decl":"@[reassoc (attr := simp)]\ntheorem section_comp_left (f g : A ‚ü∂ B) [IsReflexivePair f g] : commonSection f g ‚â´ f = ùüô B :=\n  (IsReflexivePair.common_section f g).choose_spec.1\n\n"}
{"name":"CategoryTheory.section_comp_right_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsReflexivePair f g\nZ : C\nh : Quiver.Hom B Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.commonSection f g) (CategoryTheory.CategoryStruct.comp g h)) h","decl":"@[reassoc (attr := simp)]\ntheorem section_comp_right (f g : A ‚ü∂ B) [IsReflexivePair f g] : commonSection f g ‚â´ g = ùüô B :=\n  (IsReflexivePair.common_section f g).choose_spec.2\n\n"}
{"name":"CategoryTheory.section_comp_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsReflexivePair f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.commonSection f g) g) (CategoryTheory.CategoryStruct.id B)","decl":"@[reassoc (attr := simp)]\ntheorem section_comp_right (f g : A ‚ü∂ B) [IsReflexivePair f g] : commonSection f g ‚â´ g = ùüô B :=\n  (IsReflexivePair.common_section f g).choose_spec.2\n\n"}
{"name":"CategoryTheory.left_comp_retraction","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsCoreflexivePair f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.commonRetraction f g)) (CategoryTheory.CategoryStruct.id A)","decl":"@[reassoc (attr := simp)]\ntheorem left_comp_retraction (f g : A ‚ü∂ B) [IsCoreflexivePair f g] :\n    f ‚â´ commonRetraction f g = ùüô A :=\n  (IsCoreflexivePair.common_retraction f g).choose_spec.1\n\n"}
{"name":"CategoryTheory.left_comp_retraction_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsCoreflexivePair f g\nZ : C\nh : Quiver.Hom A Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.commonRetraction f g) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem left_comp_retraction (f g : A ‚ü∂ B) [IsCoreflexivePair f g] :\n    f ‚â´ commonRetraction f g = ùüô A :=\n  (IsCoreflexivePair.common_retraction f g).choose_spec.1\n\n"}
{"name":"CategoryTheory.right_comp_retraction","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsCoreflexivePair f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.commonRetraction f g)) (CategoryTheory.CategoryStruct.id A)","decl":"@[reassoc (attr := simp)]\ntheorem right_comp_retraction (f g : A ‚ü∂ B) [IsCoreflexivePair f g] :\n    g ‚â´ commonRetraction f g = ùüô A :=\n  (IsCoreflexivePair.common_retraction f g).choose_spec.2\n\n"}
{"name":"CategoryTheory.right_comp_retraction_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsCoreflexivePair f g\nZ : C\nh : Quiver.Hom A Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp (CategoryTheory.commonRetraction f g) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem right_comp_retraction (f g : A ‚ü∂ B) [IsCoreflexivePair f g] :\n    g ‚â´ commonRetraction f g = ùüô A :=\n  (IsCoreflexivePair.common_retraction f g).choose_spec.2\n\n"}
{"name":"CategoryTheory.IsKernelPair.isReflexivePair","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA B R : C\nf g : Quiver.Hom R A\nq : Quiver.Hom A B\nh : CategoryTheory.IsKernelPair q f g\n‚ä¢ CategoryTheory.IsReflexivePair f g","decl":"/-- If `f,g` is a kernel pair for some morphism `q`, then it is reflexive. -/\ntheorem IsKernelPair.isReflexivePair {R : C} {f g : R ‚ü∂ A} {q : A ‚ü∂ B} (h : IsKernelPair q f g) :\n    IsReflexivePair f g :=\n  IsReflexivePair.mk' _ (h.lift' _ _ rfl).2.1 (h.lift' _ _ _).2.2\n\n-- This shouldn't be an instance as it would instantly loop.\n"}
{"name":"CategoryTheory.IsReflexivePair.swap","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsReflexivePair f g\n‚ä¢ CategoryTheory.IsReflexivePair g f","decl":"/-- If `f,g` is reflexive, then `g,f` is reflexive. -/\ntheorem IsReflexivePair.swap [IsReflexivePair f g] : IsReflexivePair g f :=\n  IsReflexivePair.mk' _ (section_comp_right f g) (section_comp_left f g)\n\n-- This shouldn't be an instance as it would instantly loop.\n"}
{"name":"CategoryTheory.IsCoreflexivePair.swap","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsCoreflexivePair f g\n‚ä¢ CategoryTheory.IsCoreflexivePair g f","decl":"/-- If `f,g` is coreflexive, then `g,f` is coreflexive. -/\ntheorem IsCoreflexivePair.swap [IsCoreflexivePair f g] : IsCoreflexivePair g f :=\n  IsCoreflexivePair.mk' _ (right_comp_retraction f g) (left_comp_retraction f g)\n\n"}
{"name":"CategoryTheory.instIsReflexivePairMapAppCounitObj","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nB : D\n‚ä¢ CategoryTheory.IsReflexivePair (F.map (G.map (adj.counit.app B))) (adj.counit.app (F.obj (G.obj B)))","decl":"/-- For an adjunction `F ‚ä£ G` with counit `Œµ`, the pair `(FGŒµ_B, Œµ_FGB)` is reflexive. -/\ninstance (B : D) :\n    IsReflexivePair (F.map (G.map (adj.counit.app B))) (adj.counit.app (F.obj (G.obj B))) :=\n  IsReflexivePair.mk' (F.map (adj.unit.app (G.obj B)))\n    (by\n      rw [‚Üê F.map_comp, adj.right_triangle_components]\n      apply F.map_id)\n    (adj.left_triangle_components _)\n\n"}
{"name":"CategoryTheory.Limits.HasReflexiveCoequalizers.has_coeq","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasReflexiveCoequalizers C\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsReflexivePair f g\n‚ä¢ CategoryTheory.Limits.HasCoequalizer f g","decl":"/-- `C` has reflexive coequalizers if it has coequalizers for every reflexive pair. -/\nclass HasReflexiveCoequalizers : Prop where\n  has_coeq : ‚àÄ ‚¶ÉA B : C‚¶Ñ (f g : A ‚ü∂ B) [IsReflexivePair f g], HasCoequalizer f g\n\n"}
{"name":"CategoryTheory.Limits.HasCoreflexiveEqualizers.has_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasCoreflexiveEqualizers C\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsCoreflexivePair f g\n‚ä¢ CategoryTheory.Limits.HasEqualizer f g","decl":"/-- `C` has coreflexive equalizers if it has equalizers for every coreflexive pair. -/\nclass HasCoreflexiveEqualizers : Prop where\n  has_eq : ‚àÄ ‚¶ÉA B : C‚¶Ñ (f g : A ‚ü∂ B) [IsCoreflexivePair f g], HasEqualizer f g\n\n"}
{"name":"CategoryTheory.Limits.hasCoequalizer_of_common_section","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasReflexiveCoequalizers C\nA B : C\nf g : Quiver.Hom A B\nr : Quiver.Hom B A\nrf : Eq (CategoryTheory.CategoryStruct.comp r f) (CategoryTheory.CategoryStruct.id B)\nrg : Eq (CategoryTheory.CategoryStruct.comp r g) (CategoryTheory.CategoryStruct.id B)\n‚ä¢ CategoryTheory.Limits.HasCoequalizer f g","decl":"theorem hasCoequalizer_of_common_section [HasReflexiveCoequalizers C] {A B : C} {f g : A ‚ü∂ B}\n    (r : B ‚ü∂ A) (rf : r ‚â´ f = ùüô _) (rg : r ‚â´ g = ùüô _) : HasCoequalizer f g := by\n  letI := IsReflexivePair.mk' r rf rg\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.hasEqualizer_of_common_retraction","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasCoreflexiveEqualizers C\nA B : C\nf g : Quiver.Hom A B\nr : Quiver.Hom B A\nfr : Eq (CategoryTheory.CategoryStruct.comp f r) (CategoryTheory.CategoryStruct.id A)\ngr : Eq (CategoryTheory.CategoryStruct.comp g r) (CategoryTheory.CategoryStruct.id A)\n‚ä¢ CategoryTheory.Limits.HasEqualizer f g","decl":"theorem hasEqualizer_of_common_retraction [HasCoreflexiveEqualizers C] {A B : C} {f g : A ‚ü∂ B}\n    (r : B ‚ü∂ A) (fr : f ‚â´ r = ùüô _) (gr : g ‚â´ r = ùüô _) : HasEqualizer f g := by\n  letI := IsCoreflexivePair.mk' r fr gr\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.hasReflexiveCoequalizers_of_hasCoequalizers","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasCoequalizers C\n‚ä¢ CategoryTheory.Limits.HasReflexiveCoequalizers C","decl":"/-- If `C` has coequalizers, then it has reflexive coequalizers. -/\ninstance (priority := 100) hasReflexiveCoequalizers_of_hasCoequalizers [HasCoequalizers C] :\n    HasReflexiveCoequalizers C where has_coeq A B f g _ := by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.hasCoreflexiveEqualizers_of_hasEqualizers","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasEqualizers C\n‚ä¢ CategoryTheory.Limits.HasCoreflexiveEqualizers C","decl":"/-- If `C` has equalizers, then it has coreflexive equalizers. -/\ninstance (priority := 100) hasCoreflexiveEqualizers_of_hasEqualizers [HasEqualizers C] :\n    HasCoreflexiveEqualizers C where has_eq A B f g _ := by infer_instance\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.zero.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"‚ä¢ Eq (SizeOf.sizeOf CategoryTheory.Limits.WalkingReflexivePair.zero) 1","decl":"/-- The type of objects for the diagram indexing reflexive (co)equalizers -/\ninductive WalkingReflexivePair : Type where\n  | zero\n  | one\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.one.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"‚ä¢ Eq (SizeOf.sizeOf CategoryTheory.Limits.WalkingReflexivePair.one) 1","decl":"/-- The type of objects for the diagram indexing reflexive (co)equalizers -/\ninductive WalkingReflexivePair : Type where\n  | zero\n  | one\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.ofNat_toCtorIdx","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"x : CategoryTheory.Limits.WalkingReflexivePair\n‚ä¢ Eq (CategoryTheory.Limits.WalkingReflexivePair.ofNat x.toCtorIdx) x","decl":"/-- The type of objects for the diagram indexing reflexive (co)equalizers -/\ninductive WalkingReflexivePair : Type where\n  | zero\n  | one\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.Hom.id_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"X : CategoryTheory.Limits.WalkingReflexivePair\n‚ä¢ Eq (CategoryTheory.Limits.WalkingReflexivePair.Hom.id X) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\nlemma Hom.id_eq (X : WalkingReflexivePair) :\n    Hom.id X = ùüô X := by rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.reflexion_comp_left_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"Z : CategoryTheory.Limits.WalkingReflexivePair\nh : Quiver.Hom CategoryTheory.Limits.WalkingReflexivePair.zero Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.WalkingReflexivePair.Hom.left h)) h","decl":"@[reassoc (attr := simp)]\nlemma reflexion_comp_left : reflexion ‚â´ left = ùüô zero := rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.reflexion_comp_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (CategoryTheory.CategoryStruct.id CategoryTheory.Limits.WalkingReflexivePair.zero)","decl":"@[reassoc (attr := simp)]\nlemma reflexion_comp_left : reflexion ‚â´ left = ùüô zero := rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.reflexion_comp_right_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"Z : CategoryTheory.Limits.WalkingReflexivePair\nh : Quiver.Hom CategoryTheory.Limits.WalkingReflexivePair.zero Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.WalkingReflexivePair.Hom.right h)) h","decl":"@[reassoc (attr := simp)]\nlemma reflexion_comp_right : reflexion ‚â´ right = ùüô zero := rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.reflexion_comp_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"‚ä¢ Eq (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion CategoryTheory.Limits.WalkingReflexivePair.Hom.right) (CategoryTheory.CategoryStruct.id CategoryTheory.Limits.WalkingReflexivePair.zero)","decl":"@[reassoc (attr := simp)]\nlemma reflexion_comp_right : reflexion ‚â´ right = ùüô zero := rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.leftCompReflexion_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"‚ä¢ Eq CategoryTheory.Limits.WalkingReflexivePair.Hom.leftCompReflexion (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.WalkingReflexivePair.Hom.left CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion)","decl":"@[simp]\nlemma leftCompReflexion_eq : leftCompReflexion = (left ‚â´ reflexion : one ‚ü∂ one) := rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.rightCompReflexion_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"‚ä¢ Eq CategoryTheory.Limits.WalkingReflexivePair.Hom.rightCompReflexion (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.WalkingReflexivePair.Hom.right CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion)","decl":"@[simp]\nlemma rightCompReflexion_eq : rightCompReflexion = (right ‚â´ reflexion : one ‚ü∂ one) := rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.map_reflexion_comp_map_left_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nZ : C\nh : Quiver.Hom (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_reflexion_comp_map_left (F : WalkingReflexivePair ‚•§ C) :\n    F.map reflexion ‚â´ F.map left = ùüô (F.obj zero) := by\n  rw [‚Üê F.map_comp, reflexion_comp_left, F.map_id]\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.map_reflexion_comp_map_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left)) (CategoryTheory.CategoryStruct.id (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero))","decl":"@[reassoc (attr := simp)]\nlemma map_reflexion_comp_map_left (F : WalkingReflexivePair ‚•§ C) :\n    F.map reflexion ‚â´ F.map left = ùüô (F.obj zero) := by\n  rw [‚Üê F.map_comp, reflexion_comp_left, F.map_id]\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.map_reflexion_comp_map_right_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nZ : C\nh : Quiver.Hom (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_reflexion_comp_map_right (F : WalkingReflexivePair ‚•§ C) :\n    F.map reflexion ‚â´ F.map right = ùüô (F.obj zero) := by\n  rw [‚Üê F.map_comp, reflexion_comp_right, F.map_id]\n\n"}
{"name":"CategoryTheory.Limits.WalkingReflexivePair.map_reflexion_comp_map_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)) (CategoryTheory.CategoryStruct.id (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero))","decl":"@[reassoc (attr := simp)]\nlemma map_reflexion_comp_map_right (F : WalkingReflexivePair ‚•§ C) :\n    F.map reflexion ‚â´ F.map right = ùüô (F.obj zero) := by\n  rw [‚Üê F.map_comp, reflexion_comp_right, F.map_id]\n\n"}
{"name":"CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair_map","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"X‚úù Y‚úù : CategoryTheory.Limits.WalkingParallelPair\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair.map f) (CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair.match_2 (fun Y X f => Quiver.Hom (CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair.match_1 (fun x => CategoryTheory.Limits.WalkingReflexivePair) X (fun _ => CategoryTheory.Limits.WalkingReflexivePair.zero) fun _ => CategoryTheory.Limits.WalkingReflexivePair.one) (CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair.match_1 (fun x => CategoryTheory.Limits.WalkingReflexivePair) Y (fun _ => CategoryTheory.Limits.WalkingReflexivePair.zero) fun _ => CategoryTheory.Limits.WalkingReflexivePair.one)) Y‚úù X‚úù f (fun _ => CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (fun _ => CategoryTheory.Limits.WalkingReflexivePair.Hom.right) fun x => CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair.match_1 (fun x => CategoryTheory.Limits.WalkingReflexivePair) x (fun _ => CategoryTheory.Limits.WalkingReflexivePair.zero) fun _ => CategoryTheory.Limits.WalkingReflexivePair.one))","decl":"/-- The inclusion functor forgetting the common section -/\n@[simps!]\ndef inclusionWalkingReflexivePair : WalkingParallelPair ‚•§ WalkingReflexivePair where\n  obj := fun x => match x with\n    | one => WalkingReflexivePair.zero\n    | zero => WalkingReflexivePair.one\n  map := fun f => match f with\n    | .left => WalkingReflexivePair.Hom.left\n    | .right => WalkingReflexivePair.Hom.right\n    | .id _ => WalkingReflexivePair.Hom.id _\n  map_comp := by\n    intro _ _ _ f g; cases f <;> cases g <;> rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair_obj","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"x : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq (CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair.obj x) (CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair.match_1 (fun x => CategoryTheory.Limits.WalkingReflexivePair) x (fun _ => CategoryTheory.Limits.WalkingReflexivePair.zero) fun _ => CategoryTheory.Limits.WalkingReflexivePair.one)","decl":"/-- The inclusion functor forgetting the common section -/\n@[simps!]\ndef inclusionWalkingReflexivePair : WalkingParallelPair ‚•§ WalkingReflexivePair where\n  obj := fun x => match x with\n    | one => WalkingReflexivePair.zero\n    | zero => WalkingReflexivePair.one\n  map := fun f => match f with\n    | .left => WalkingReflexivePair.Hom.left\n    | .right => WalkingReflexivePair.Hom.right\n    | .id _ => WalkingReflexivePair.Hom.id _\n  map_comp := by\n    intro _ _ _ f g; cases f <;> cases g <;> rfl\n\n"}
{"name":"CategoryTheory.Limits.WalkingParallelPair.instNonemptyStructuredArrowWalkingReflexivePairInclusionWalkingReflexivePair","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"X : CategoryTheory.Limits.WalkingReflexivePair\n‚ä¢ Nonempty (CategoryTheory.StructuredArrow X CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair)","decl":"instance (X : WalkingReflexivePair) :\n    Nonempty (StructuredArrow X inclusionWalkingReflexivePair) := by\n  cases X with\n  | zero => exact ‚ü®StructuredArrow.mk (Y := one) (ùüô _)‚ü©\n  | one => exact ‚ü®StructuredArrow.mk (Y := zero) (ùüô _)‚ü©\n\n"}
{"name":"CategoryTheory.Limits.WalkingParallelPair.instIsConnectedStructuredArrowWalkingReflexivePairInclusionWalkingReflexivePair","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"X : CategoryTheory.Limits.WalkingReflexivePair\n‚ä¢ CategoryTheory.IsConnected (CategoryTheory.StructuredArrow X CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair)","decl":"open WalkingReflexivePair.Hom in\ninstance (X : WalkingReflexivePair) :\n    IsConnected (StructuredArrow X inclusionWalkingReflexivePair) := by\n  cases X with\n  | zero =>\n      refine IsConnected.of_induct  (j‚ÇÄ := StructuredArrow.mk (Y := one) (ùüô _)) ?_\n      rintro p h‚ÇÅ h‚ÇÇ ‚ü®‚ü®‚ü®‚ü©‚ü©, (_ | _), ‚ü®_‚ü©‚ü©\n      ¬∑ exact (h‚ÇÇ (StructuredArrow.homMk .left)).2 h‚ÇÅ\n      ¬∑ exact h‚ÇÅ\n  | one =>\n      refine IsConnected.of_induct  (j‚ÇÄ := StructuredArrow.mk (Y := zero) (ùüô _))\n        (fun p h‚ÇÅ h‚ÇÇ ‚Ü¶ ?_)\n      have h‚Çó : StructuredArrow.mk left ‚àà p := (h‚ÇÇ (StructuredArrow.homMk .left)).1 h‚ÇÅ\n      have h·µ£ : StructuredArrow.mk right ‚àà p := (h‚ÇÇ (StructuredArrow.homMk .right)).1 h‚ÇÅ\n      rintro ‚ü®‚ü®‚ü®‚ü©‚ü©, (_ | _), ‚ü®_‚ü©‚ü©\n      ¬∑ exact (h‚ÇÇ (StructuredArrow.homMk .left)).2 h‚Çó\n      ¬∑ exact (h‚ÇÇ (StructuredArrow.homMk .right)).2 h·µ£\n      all_goals assumption\n\n"}
{"name":"CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair_final","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"‚ä¢ CategoryTheory.Limits.WalkingParallelPair.inclusionWalkingReflexivePair.Final","decl":"/-- The inclusion functor is a final functor -/\ninstance inclusionWalkingReflexivePair_final : Functor.Final inclusionWalkingReflexivePair where\n  out := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair_obj_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ns : Quiver.Hom B A\nsl : Eq (CategoryTheory.CategoryStruct.comp s f) (CategoryTheory.CategoryStruct.id B)\nsr : Eq (CategoryTheory.CategoryStruct.comp s g) (CategoryTheory.CategoryStruct.id B)\n‚ä¢ Eq ((CategoryTheory.Limits.reflexivePair f g s sl sr).obj CategoryTheory.Limits.WalkingReflexivePair.zero) B","decl":"@[simp] lemma reflexivePair_obj_zero : (reflexivePair f g s sl sr).obj zero = B := rfl\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair_obj_one","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ns : Quiver.Hom B A\nsl : Eq (CategoryTheory.CategoryStruct.comp s f) (CategoryTheory.CategoryStruct.id B)\nsr : Eq (CategoryTheory.CategoryStruct.comp s g) (CategoryTheory.CategoryStruct.id B)\n‚ä¢ Eq ((CategoryTheory.Limits.reflexivePair f g s sl sr).obj CategoryTheory.Limits.WalkingReflexivePair.one) A","decl":"@[simp] lemma reflexivePair_obj_one : (reflexivePair f g s sl sr).obj one = A := rfl\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair_map_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ns : Quiver.Hom B A\nsl : Eq (CategoryTheory.CategoryStruct.comp s f) (CategoryTheory.CategoryStruct.id B)\nsr : Eq (CategoryTheory.CategoryStruct.comp s g) (CategoryTheory.CategoryStruct.id B)\n‚ä¢ Eq ((CategoryTheory.Limits.reflexivePair f g s sl sr).map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) f","decl":"@[simp] lemma reflexivePair_map_right : (reflexivePair f g s sl sr).map .left = f := rfl\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair_map_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ns : Quiver.Hom B A\nsl : Eq (CategoryTheory.CategoryStruct.comp s f) (CategoryTheory.CategoryStruct.id B)\nsr : Eq (CategoryTheory.CategoryStruct.comp s g) (CategoryTheory.CategoryStruct.id B)\n‚ä¢ Eq ((CategoryTheory.Limits.reflexivePair f g s sl sr).map CategoryTheory.Limits.WalkingReflexivePair.Hom.right) g","decl":"@[simp] lemma reflexivePair_map_left : (reflexivePair f g s sl sr).map .right = g := rfl\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair_map_reflexion","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ns : Quiver.Hom B A\nsl : Eq (CategoryTheory.CategoryStruct.comp s f) (CategoryTheory.CategoryStruct.id B)\nsr : Eq (CategoryTheory.CategoryStruct.comp s g) (CategoryTheory.CategoryStruct.id B)\n‚ä¢ Eq ((CategoryTheory.Limits.reflexivePair f g s sl sr).map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion) s","decl":"@[simp] lemma reflexivePair_map_reflexion : (reflexivePair f g s sl sr).map .reflexion = s := rfl\n\n"}
{"name":"CategoryTheory.Limits.ofIsReflexivePair_map_left","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsReflexivePair f g\n‚ä¢ Eq ((CategoryTheory.Limits.ofIsReflexivePair f g).map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) f","decl":"@[simp]\nlemma ofIsReflexivePair_map_left (f g : A ‚ü∂ B) [IsReflexivePair f g] :\n    (ofIsReflexivePair f g).map .left = f := rfl\n\n"}
{"name":"CategoryTheory.Limits.ofIsReflexivePair_map_right","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsReflexivePair f g\n‚ä¢ Eq ((CategoryTheory.Limits.ofIsReflexivePair f g).map CategoryTheory.Limits.WalkingReflexivePair.Hom.right) g","decl":"@[simp]\nlemma ofIsReflexivePair_map_right (f g : A ‚ü∂ B) [IsReflexivePair f g] :\n    (ofIsReflexivePair f g).map .right = g := rfl\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair.mkNatTrans_app_zero","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\ne‚ÇÄ : Quiver.Hom (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero) (G.obj CategoryTheory.Limits.WalkingReflexivePair.zero)\n‚ä¢ Eq (sorryAx (Unit ‚Üí Quiver.Hom (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero) (G.obj CategoryTheory.Limits.WalkingReflexivePair.zero)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 421).num 28).num 421).num 64).num 28).num 64).str \"_sorry\").str \"_@\").str \"_hyg\").num 4226))) e‚ÇÄ","decl":"@[simp]\nlemma mkNatTrans_app_zero : (mkNatTrans e‚ÇÄ e‚ÇÅ h‚ÇÅ h‚ÇÇ h‚ÇÉ).app zero = e‚ÇÄ := rfl\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair.mkNatTrans_app_one","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\ne‚ÇÅ : Quiver.Hom (F.obj CategoryTheory.Limits.WalkingReflexivePair.one) (G.obj CategoryTheory.Limits.WalkingReflexivePair.one)\n‚ä¢ Eq (sorryAx (Unit ‚Üí Quiver.Hom (F.obj CategoryTheory.Limits.WalkingReflexivePair.one) (G.obj CategoryTheory.Limits.WalkingReflexivePair.one)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 424).num 27).num 424).num 62).num 27).num 62).str \"_sorry\").str \"_@\").str \"_hyg\").num 4368))) e‚ÇÅ","decl":"@[simp]\nlemma mkNatTrans_app_one : (mkNatTrans e‚ÇÄ e‚ÇÅ h‚ÇÅ h‚ÇÇ h‚ÇÉ).app one = e‚ÇÅ := rfl\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair.mkNatIso_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\ne‚ÇÄ : CategoryTheory.Iso (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero) (G.obj CategoryTheory.Limits.WalkingReflexivePair.zero)\ne‚ÇÅ : CategoryTheory.Iso (F.obj CategoryTheory.Limits.WalkingReflexivePair.one) (G.obj CategoryTheory.Limits.WalkingReflexivePair.one)\nh‚ÇÅ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) e‚ÇÄ.hom) (CategoryTheory.CategoryStruct.comp e‚ÇÅ.hom (G.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left))) _auto‚úù\nh‚ÇÇ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right) e‚ÇÄ.hom) (CategoryTheory.CategoryStruct.comp e‚ÇÅ.hom (G.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right))) _auto‚úù\nh‚ÇÉ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion) e‚ÇÅ.hom) (CategoryTheory.CategoryStruct.comp e‚ÇÄ.hom (G.map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion))) _auto‚úù\nx : CategoryTheory.Limits.WalkingReflexivePair\n‚ä¢ Eq ((CategoryTheory.Limits.reflexivePair.mkNatIso e‚ÇÄ e‚ÇÅ h‚ÇÅ h‚ÇÇ h‚ÇÉ).hom.app x) (CategoryTheory.Limits.reflexivePair.match_1 (fun x => Quiver.Hom (F.obj x) (G.obj x)) x (fun _ => e‚ÇÄ.hom) fun _ => e‚ÇÅ.hom)","decl":"/-- Constructor for natural isomorphisms between functors out of `WalkingReflexivePair`. -/\n@[simps!]\ndef mkNatIso (e‚ÇÄ : F.obj zero ‚âÖ G.obj zero) (e‚ÇÅ : F.obj one ‚âÖ G.obj one)\n    (h‚ÇÅ : F.map left ‚â´ e‚ÇÄ.hom = e‚ÇÅ.hom ‚â´ G.map left := by aesop_cat)\n    (h‚ÇÇ : F.map right ‚â´ e‚ÇÄ.hom = e‚ÇÅ.hom ‚â´ G.map right := by aesop_cat)\n    (h‚ÇÉ : F.map reflexion ‚â´ e‚ÇÅ.hom = e‚ÇÄ.hom ‚â´ G.map reflexion := by aesop_cat) :\n    F ‚âÖ G where\n  hom := mkNatTrans e‚ÇÄ.hom e‚ÇÅ.hom\n  inv := mkNatTrans e‚ÇÄ.inv e‚ÇÅ.inv\n        (by rw [‚Üê cancel_epi e‚ÇÅ.hom, e‚ÇÅ.hom_inv_id_assoc, ‚Üê reassoc_of% h‚ÇÅ, e‚ÇÄ.hom_inv_id,\n            Category.comp_id])\n        (by rw [‚Üê cancel_epi e‚ÇÅ.hom, e‚ÇÅ.hom_inv_id_assoc, ‚Üê reassoc_of% h‚ÇÇ, e‚ÇÄ.hom_inv_id,\n            Category.comp_id])\n        (by rw [‚Üê cancel_epi e‚ÇÄ.hom, e‚ÇÄ.hom_inv_id_assoc, ‚Üê reassoc_of% h‚ÇÉ, e‚ÇÅ.hom_inv_id,\n            Category.comp_id])\n  hom_inv_id := by ext x; cases x <;> simp\n  inv_hom_id := by ext x; cases x <;> simp\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair.mkNatIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\ne‚ÇÄ : CategoryTheory.Iso (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero) (G.obj CategoryTheory.Limits.WalkingReflexivePair.zero)\ne‚ÇÅ : CategoryTheory.Iso (F.obj CategoryTheory.Limits.WalkingReflexivePair.one) (G.obj CategoryTheory.Limits.WalkingReflexivePair.one)\nh‚ÇÅ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) e‚ÇÄ.hom) (CategoryTheory.CategoryStruct.comp e‚ÇÅ.hom (G.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left))) _auto‚úù\nh‚ÇÇ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right) e‚ÇÄ.hom) (CategoryTheory.CategoryStruct.comp e‚ÇÅ.hom (G.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right))) _auto‚úù\nh‚ÇÉ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion) e‚ÇÅ.hom) (CategoryTheory.CategoryStruct.comp e‚ÇÄ.hom (G.map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion))) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Limits.reflexivePair.mkNatIso e‚ÇÄ e‚ÇÅ h‚ÇÅ h‚ÇÇ h‚ÇÉ).inv (sorryAx (Unit ‚Üí Quiver.Hom G F) Bool.true Unit.unit)","decl":"/-- Constructor for natural isomorphisms between functors out of `WalkingReflexivePair`. -/\n@[simps!]\ndef mkNatIso (e‚ÇÄ : F.obj zero ‚âÖ G.obj zero) (e‚ÇÅ : F.obj one ‚âÖ G.obj one)\n    (h‚ÇÅ : F.map left ‚â´ e‚ÇÄ.hom = e‚ÇÅ.hom ‚â´ G.map left := by aesop_cat)\n    (h‚ÇÇ : F.map right ‚â´ e‚ÇÄ.hom = e‚ÇÅ.hom ‚â´ G.map right := by aesop_cat)\n    (h‚ÇÉ : F.map reflexion ‚â´ e‚ÇÅ.hom = e‚ÇÄ.hom ‚â´ G.map reflexion := by aesop_cat) :\n    F ‚âÖ G where\n  hom := mkNatTrans e‚ÇÄ.hom e‚ÇÅ.hom\n  inv := mkNatTrans e‚ÇÄ.inv e‚ÇÅ.inv\n        (by rw [‚Üê cancel_epi e‚ÇÅ.hom, e‚ÇÅ.hom_inv_id_assoc, ‚Üê reassoc_of% h‚ÇÅ, e‚ÇÄ.hom_inv_id,\n            Category.comp_id])\n        (by rw [‚Üê cancel_epi e‚ÇÅ.hom, e‚ÇÅ.hom_inv_id_assoc, ‚Üê reassoc_of% h‚ÇÇ, e‚ÇÄ.hom_inv_id,\n            Category.comp_id])\n        (by rw [‚Üê cancel_epi e‚ÇÄ.hom, e‚ÇÄ.hom_inv_id_assoc, ‚Üê reassoc_of% h‚ÇÉ, e‚ÇÅ.hom_inv_id,\n            Category.comp_id])\n  hom_inv_id := by ext x; cases x <;> simp\n  inv_hom_id := by ext x; cases x <;> simp\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair.diagramIsoReflexivePair_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\n‚ä¢ Eq (CategoryTheory.Limits.reflexivePair.diagramIsoReflexivePair F).inv (sorryAx (Unit ‚Üí Quiver.Hom (CategoryTheory.Limits.reflexivePair (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion) ‚ãØ ‚ãØ) F) Bool.true Unit.unit)","decl":"/-- Every functor out of `WalkingReflexivePair` is isomorphic to the `reflexivePair` given by\nits components -/\n@[simps!]\ndef diagramIsoReflexivePair :\n    F ‚âÖ reflexivePair (F.map left) (F.map right) (F.map reflexion) :=\n  mkNatIso (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair.diagramIsoReflexivePair_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nx : CategoryTheory.Limits.WalkingReflexivePair\n‚ä¢ Eq ((CategoryTheory.Limits.reflexivePair.diagramIsoReflexivePair F).hom.app x) (CategoryTheory.Limits.reflexivePair.match_1 (fun x => Quiver.Hom (F.obj x) ((CategoryTheory.Limits.reflexivePair (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.reflexion) ‚ãØ ‚ãØ).obj x)) x (fun _ => CategoryTheory.CategoryStruct.id (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero)) fun _ => CategoryTheory.CategoryStruct.id (F.obj CategoryTheory.Limits.WalkingReflexivePair.one))","decl":"/-- Every functor out of `WalkingReflexivePair` is isomorphic to the `reflexivePair` given by\nits components -/\n@[simps!]\ndef diagramIsoReflexivePair :\n    F ‚âÖ reflexivePair (F.map left) (F.map right) (F.map reflexion) :=\n  mkNatIso (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair.compRightIso_hom_app","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nA B : C\nf g : Quiver.Hom A B\ns : Quiver.Hom B A\nsl : Eq (CategoryTheory.CategoryStruct.comp s f) (CategoryTheory.CategoryStruct.id B)\nsr : Eq (CategoryTheory.CategoryStruct.comp s g) (CategoryTheory.CategoryStruct.id B)\nF : CategoryTheory.Functor C D\nx : CategoryTheory.Limits.WalkingReflexivePair\n‚ä¢ Eq ((CategoryTheory.Limits.reflexivePair.compRightIso f g s sl sr F).hom.app x) (CategoryTheory.Limits.reflexivePair.match_1 (fun x => Quiver.Hom (F.obj ((CategoryTheory.Limits.reflexivePair f g s sl sr).obj x)) ((CategoryTheory.Limits.reflexivePair (F.map f) (F.map g) (F.map s) ‚ãØ ‚ãØ).obj x)) x (fun _ => CategoryTheory.CategoryStruct.id (F.obj B)) fun _ => CategoryTheory.CategoryStruct.id (F.obj A))","decl":"/-- A `reflexivePair` composed with a functor is isomorphic to the `reflexivePair` obtained by\napplying the functor at each map. -/\n@[simps!]\ndef compRightIso {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D] {A B : C}\n    (f g : A ‚ü∂ B) (s : B ‚ü∂ A) (sl : s ‚â´ f = ùüô B) (sr : s ‚â´ g = ùüô B) (F : C ‚•§ D) :\n    (reflexivePair f g s sl sr) ‚ãô F ‚âÖ reflexivePair (F.map f) (F.map g) (F.map s)\n      (by simp only [‚Üê Functor.map_comp, sl, Functor.map_id])\n      (by simp only [‚Üê Functor.map_comp, sr, Functor.map_id]) :=\n  mkNatIso (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair.compRightIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nA B : C\nf g : Quiver.Hom A B\ns : Quiver.Hom B A\nsl : Eq (CategoryTheory.CategoryStruct.comp s f) (CategoryTheory.CategoryStruct.id B)\nsr : Eq (CategoryTheory.CategoryStruct.comp s g) (CategoryTheory.CategoryStruct.id B)\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (CategoryTheory.Limits.reflexivePair.compRightIso f g s sl sr F).inv (sorryAx (Unit ‚Üí Quiver.Hom (CategoryTheory.Limits.reflexivePair (F.map f) (F.map g) (F.map s) ‚ãØ ‚ãØ) ((CategoryTheory.Limits.reflexivePair f g s sl sr).comp F)) Bool.true Unit.unit)","decl":"/-- A `reflexivePair` composed with a functor is isomorphic to the `reflexivePair` obtained by\napplying the functor at each map. -/\n@[simps!]\ndef compRightIso {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D] {A B : C}\n    (f g : A ‚ü∂ B) (s : B ‚ü∂ A) (sl : s ‚â´ f = ùüô B) (sr : s ‚â´ g = ùüô B) (F : C ‚•§ D) :\n    (reflexivePair f g s sl sr) ‚ãô F ‚âÖ reflexivePair (F.map f) (F.map g) (F.map s)\n      (by simp only [‚Üê Functor.map_comp, sl, Functor.map_id])\n      (by simp only [‚Üê Functor.map_comp, sr, Functor.map_id]) :=\n  mkNatIso (Iso.refl _) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair.to_isReflexivePair","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\n‚ä¢ CategoryTheory.IsReflexivePair (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)","decl":"/-- Any functor out of the WalkingReflexivePair yields a reflexive pair -/\ninstance to_isReflexivePair {F : WalkingReflexivePair ‚•§ C} :\n    IsReflexivePair (F.map .left) (F.map .right) :=\n  ‚ü®F.map .reflexion, map_reflexion_comp_map_left F, map_reflexion_comp_map_right F‚ü©\n\n"}
{"name":"CategoryTheory.Limits.ReflexiveCofork.mk_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nX : C\nœÄ : Quiver.Hom (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero) X\nh : Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) œÄ) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right) œÄ)\n‚ä¢ Eq (CategoryTheory.Limits.ReflexiveCofork.mk œÄ h).pt X","decl":"/-- Constructor for `ReflexiveCofork` -/\n@[simps pt]\ndef mk {X : C} (œÄ : F.obj zero ‚ü∂ X) (h : F.map left ‚â´ œÄ = F.map right ‚â´ œÄ) :\n    ReflexiveCofork F where\n  pt := X\n  Œπ := reflexivePair.mkNatTrans œÄ (F.map left ‚â´ œÄ)\n\n"}
{"name":"CategoryTheory.Limits.ReflexiveCofork.mk_œÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nX : C\nœÄ : Quiver.Hom (F.obj CategoryTheory.Limits.WalkingReflexivePair.zero) X\nh : Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) œÄ) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right) œÄ)\n‚ä¢ Eq (CategoryTheory.Limits.ReflexiveCofork.mk œÄ h).œÄ œÄ","decl":"@[simp]\nlemma mk_œÄ {X : C} (œÄ : F.obj zero ‚ü∂ X) (h : F.map left ‚â´ œÄ = F.map right ‚â´ œÄ) :\n    (mk œÄ h).œÄ = œÄ := rfl\n\n"}
{"name":"CategoryTheory.Limits.ReflexiveCofork.condition","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nG : CategoryTheory.Limits.ReflexiveCofork F\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) G.œÄ) (CategoryTheory.CategoryStruct.comp (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right) G.œÄ)","decl":"lemma condition (G : ReflexiveCofork F) : F.map left ‚â´ G.œÄ = F.map right ‚â´ G.œÄ := by\n  rw [Cocone.w G left, Cocone.w G right]\n\n"}
{"name":"CategoryTheory.Limits.ReflexiveCofork.app_one_eq_œÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nG : CategoryTheory.Limits.ReflexiveCofork F\n‚ä¢ Eq (G.Œπ.app CategoryTheory.Limits.WalkingReflexivePair.zero) G.œÄ","decl":"@[simp]\nlemma app_one_eq_œÄ (G : ReflexiveCofork F) : G.Œπ.app zero = G.œÄ := rfl\n\n"}
{"name":"CategoryTheory.Limits.reflexiveCoforkEquivCofork_inverse_obj_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nX : CategoryTheory.Limits.Cofork (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)\n‚ä¢ Eq ((CategoryTheory.Limits.reflexiveCoforkEquivCofork F).inverse.obj X).pt X.pt","decl":"/-- Forgetting the reflexion yields an equivalence between cocones over a bundled reflexive pair and\ncoforks on the underlying parallel pair. -/\n@[simps! functor_obj_pt inverse_obj_pt]\ndef reflexiveCoforkEquivCofork :\n    ReflexiveCofork F ‚âå Cofork (F.map left) (F.map right) :=\n  (Functor.Final.coconesEquiv _ F).symm.trans (Cocones.precomposeEquivalence\n    (diagramIsoParallelPair (WalkingParallelPair.inclusionWalkingReflexivePair ‚ãô F))).symm\n\n"}
{"name":"CategoryTheory.Limits.reflexiveCoforkEquivCofork_functor_obj_pt","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nX : CategoryTheory.Limits.Cocone F\n‚ä¢ Eq ((CategoryTheory.Limits.reflexiveCoforkEquivCofork F).functor.obj X).pt X.pt","decl":"/-- Forgetting the reflexion yields an equivalence between cocones over a bundled reflexive pair and\ncoforks on the underlying parallel pair. -/\n@[simps! functor_obj_pt inverse_obj_pt]\ndef reflexiveCoforkEquivCofork :\n    ReflexiveCofork F ‚âå Cofork (F.map left) (F.map right) :=\n  (Functor.Final.coconesEquiv _ F).symm.trans (Cocones.precomposeEquivalence\n    (diagramIsoParallelPair (WalkingParallelPair.inclusionWalkingReflexivePair ‚ãô F))).symm\n\n"}
{"name":"CategoryTheory.Limits.reflexiveCoforkEquivCofork_functor_obj_œÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nG : CategoryTheory.Limits.ReflexiveCofork F\n‚ä¢ Eq ((CategoryTheory.Limits.reflexiveCoforkEquivCofork F).functor.obj G).œÄ G.œÄ","decl":"@[simp]\nlemma reflexiveCoforkEquivCofork_functor_obj_œÄ (G : ReflexiveCofork F) :\n    ((reflexiveCoforkEquivCofork F).functor.obj G).œÄ = G.œÄ := by\n  dsimp [reflexiveCoforkEquivCofork]\n  rw [ReflexiveCofork.œÄ, Cofork.œÄ]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.reflexiveCoforkEquivCofork_inverse_obj_œÄ","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nG : CategoryTheory.Limits.Cofork (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)\n‚ä¢ Eq ((CategoryTheory.Limits.reflexiveCoforkEquivCofork F).inverse.obj G).œÄ G.œÄ","decl":"@[simp]\nlemma reflexiveCoforkEquivCofork_inverse_obj_œÄ\n    (G : Cofork (F.map left) (F.map right)) :\n    ((reflexiveCoforkEquivCofork F).inverse.obj G).œÄ = G.œÄ := by\n  dsimp only [reflexiveCoforkEquivCofork, Equivalence.symm, Equivalence.trans,\n    ReflexiveCofork.œÄ, Cocones.precomposeEquivalence, Cocones.precompose,\n    Functor.comp, Functor.Final.coconesEquiv]\n  rw [Functor.Final.extendCocone_obj_Œπ_app' (Y := .one) (f := ùüô zero)]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.hasReflexiveCoequalizer_iff_hasCoequalizer","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\n‚ä¢ Iff (CategoryTheory.Limits.HasColimit F) (CategoryTheory.Limits.HasCoequalizer (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right))","decl":"lemma hasReflexiveCoequalizer_iff_hasCoequalizer :\n    HasColimit F ‚Üî HasCoequalizer (F.map left) (F.map right) := by\n  simpa only [hasColimit_iff_hasInitial_cocone]\n    using Equivalence.hasInitial_iff (reflexiveCoforkEquivCofork F)\n\n"}
{"name":"CategoryTheory.Limits.reflexivePair_hasColimit_of_hasCoequalizer","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\nh : CategoryTheory.Limits.HasCoequalizer (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)\n‚ä¢ CategoryTheory.Limits.HasColimit F","decl":"instance reflexivePair_hasColimit_of_hasCoequalizer\n    [h : HasCoequalizer (F.map left) (F.map right)] : HasColimit F :=\n  hasReflexiveCoequalizer_iff_hasCoequalizer _|>.mpr h\n\n"}
{"name":"CategoryTheory.Limits.Œπ_reflexiveCoequalizerIsoCoequalizer_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\ninst‚úù : CategoryTheory.Limits.HasCoequalizer (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ F CategoryTheory.Limits.WalkingReflexivePair.zero) (CategoryTheory.Limits.reflexiveCoequalizerIsoCoequalizer F).hom) (CategoryTheory.Limits.coequalizer.œÄ (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right))","decl":"@[reassoc (attr := simp)]\nlemma Œπ_reflexiveCoequalizerIsoCoequalizer_hom :\n    colimit.Œπ F zero ‚â´ (reflexiveCoequalizerIsoCoequalizer F).hom =\n      coequalizer.œÄ (F.map left) (F.map right) :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom\n    ((ReflexiveCofork.isColimitEquiv F _).symm _) _ WalkingParallelPair.one\n\n"}
{"name":"CategoryTheory.Limits.Œπ_reflexiveCoequalizerIsoCoequalizer_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\ninst‚úù : CategoryTheory.Limits.HasCoequalizer (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coequalizer (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ F CategoryTheory.Limits.WalkingReflexivePair.zero) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.reflexiveCoequalizerIsoCoequalizer F).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.œÄ (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)) h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_reflexiveCoequalizerIsoCoequalizer_hom :\n    colimit.Œπ F zero ‚â´ (reflexiveCoequalizerIsoCoequalizer F).hom =\n      coequalizer.œÄ (F.map left) (F.map right) :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom\n    ((ReflexiveCofork.isColimitEquiv F _).symm _) _ WalkingParallelPair.one\n\n"}
{"name":"CategoryTheory.Limits.œÄ_reflexiveCoequalizerIsoCoequalizer_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\ninst‚úù : CategoryTheory.Limits.HasCoequalizer (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit F) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.œÄ (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.reflexiveCoequalizerIsoCoequalizer F).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ F CategoryTheory.Limits.WalkingReflexivePair.zero) h)","decl":"@[reassoc (attr := simp)]\nlemma œÄ_reflexiveCoequalizerIsoCoequalizer_inv :\n    coequalizer.œÄ _ _ ‚â´ (reflexiveCoequalizerIsoCoequalizer F).inv = colimit.Œπ F _ := by\n  rw [reflexiveCoequalizerIsoCoequalizer]\n  simp only [colimit.comp_coconePointUniqueUpToIso_inv, Cofork.ofœÄ_pt, colimit.cocone_x,\n    Cofork.ofœÄ_Œπ_app, colimit.cocone_Œπ]\n\n"}
{"name":"CategoryTheory.Limits.œÄ_reflexiveCoequalizerIsoCoequalizer_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor CategoryTheory.Limits.WalkingReflexivePair C\ninst‚úù : CategoryTheory.Limits.HasCoequalizer (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.œÄ (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.left) (F.map CategoryTheory.Limits.WalkingReflexivePair.Hom.right)) (CategoryTheory.Limits.reflexiveCoequalizerIsoCoequalizer F).inv) (CategoryTheory.Limits.colimit.Œπ F CategoryTheory.Limits.WalkingReflexivePair.zero)","decl":"@[reassoc (attr := simp)]\nlemma œÄ_reflexiveCoequalizerIsoCoequalizer_inv :\n    coequalizer.œÄ _ _ ‚â´ (reflexiveCoequalizerIsoCoequalizer F).inv = colimit.Œπ F _ := by\n  rw [reflexiveCoequalizerIsoCoequalizer]\n  simp only [colimit.comp_coconePointUniqueUpToIso_inv, Cofork.ofœÄ_pt, colimit.cocone_x,\n    Cofork.ofœÄ_Œπ_app, colimit.cocone_Œπ]\n\n"}
{"name":"CategoryTheory.Limits.ofIsReflexivePair_hasColimit_of_hasCoequalizer","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsReflexivePair f g\nh : CategoryTheory.Limits.HasCoequalizer f g\n‚ä¢ CategoryTheory.Limits.HasColimit (CategoryTheory.Limits.ofIsReflexivePair f g)","decl":"instance ofIsReflexivePair_hasColimit_of_hasCoequalizer :\n    HasColimit (ofIsReflexivePair f g) :=\n  hasReflexiveCoequalizer_iff_hasCoequalizer _|>.mpr h\n\n"}
{"name":"CategoryTheory.Limits.Œπ_colimitOfIsReflexivePairIsoCoequalizer_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsReflexivePair f g\nh‚úù : CategoryTheory.Limits.HasCoequalizer f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.coequalizer f g) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ (CategoryTheory.Limits.ofIsReflexivePair f g) CategoryTheory.Limits.WalkingReflexivePair.zero) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.colimitOfIsReflexivePairIsoCoequalizer.hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.œÄ f g) h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_colimitOfIsReflexivePairIsoCoequalizer_hom :\n    colimit.Œπ (ofIsReflexivePair f g) zero ‚â´ colimitOfIsReflexivePairIsoCoequalizer.hom =\n      coequalizer.œÄ f g := @Œπ_reflexiveCoequalizerIsoCoequalizer_hom _ _ _ h\n\n"}
{"name":"CategoryTheory.Limits.Œπ_colimitOfIsReflexivePairIsoCoequalizer_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsReflexivePair f g\nh : CategoryTheory.Limits.HasCoequalizer f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ (CategoryTheory.Limits.ofIsReflexivePair f g) CategoryTheory.Limits.WalkingReflexivePair.zero) CategoryTheory.Limits.colimitOfIsReflexivePairIsoCoequalizer.hom) (CategoryTheory.Limits.coequalizer.œÄ f g)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_colimitOfIsReflexivePairIsoCoequalizer_hom :\n    colimit.Œπ (ofIsReflexivePair f g) zero ‚â´ colimitOfIsReflexivePairIsoCoequalizer.hom =\n      coequalizer.œÄ f g := @Œπ_reflexiveCoequalizerIsoCoequalizer_hom _ _ _ h\n\n"}
{"name":"CategoryTheory.Limits.œÄ_colimitOfIsReflexivePairIsoCoequalizer_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsReflexivePair f g\nh‚úù : CategoryTheory.Limits.HasCoequalizer f g\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit (CategoryTheory.Limits.ofIsReflexivePair f g)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.œÄ f g) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.colimitOfIsReflexivePairIsoCoequalizer.inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ (CategoryTheory.Limits.ofIsReflexivePair f g) CategoryTheory.Limits.WalkingReflexivePair.zero) h)","decl":"@[reassoc (attr := simp)]\nlemma œÄ_colimitOfIsReflexivePairIsoCoequalizer_inv :\n    coequalizer.œÄ f g ‚â´ colimitOfIsReflexivePairIsoCoequalizer.inv =\n      colimit.Œπ (ofIsReflexivePair f g) zero :=\n  @œÄ_reflexiveCoequalizerIsoCoequalizer_inv _ _ (ofIsReflexivePair f g) h\n\n"}
{"name":"CategoryTheory.Limits.œÄ_colimitOfIsReflexivePairIsoCoequalizer_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsReflexivePair f g\nh : CategoryTheory.Limits.HasCoequalizer f g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.coequalizer.œÄ f g) CategoryTheory.Limits.colimitOfIsReflexivePairIsoCoequalizer.inv) (CategoryTheory.Limits.colimit.Œπ (CategoryTheory.Limits.ofIsReflexivePair f g) CategoryTheory.Limits.WalkingReflexivePair.zero)","decl":"@[reassoc (attr := simp)]\nlemma œÄ_colimitOfIsReflexivePairIsoCoequalizer_inv :\n    coequalizer.œÄ f g ‚â´ colimitOfIsReflexivePairIsoCoequalizer.inv =\n      colimit.Œπ (ofIsReflexivePair f g) zero :=\n  @œÄ_reflexiveCoequalizerIsoCoequalizer_inv _ _ (ofIsReflexivePair f g) h\n\n"}
{"name":"CategoryTheory.Limits.hasReflexiveCoequalizers_iff","module":"Mathlib.CategoryTheory.Limits.Shapes.Reflexive","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Iff (CategoryTheory.Limits.HasColimitsOfShape CategoryTheory.Limits.WalkingReflexivePair C) (CategoryTheory.Limits.HasReflexiveCoequalizers C)","decl":"/-- A category has coequalizers of reflexive pairs if and only if it has all colimits indexed by the\nwalking reflexive pair. -/\ntheorem hasReflexiveCoequalizers_iff :\n    HasColimitsOfShape WalkingReflexivePair C ‚Üî HasReflexiveCoequalizers C :=\n  ‚ü®fun _ ‚Ü¶ ‚ü®fun _ _ f g _ ‚Ü¶ (hasReflexiveCoequalizer_iff_hasCoequalizer\n      (reflexivePair f g (commonSection f g))).1 inferInstance‚ü©,\n    fun _ ‚Ü¶ ‚ü®inferInstance‚ü©‚ü©\n\n"}
