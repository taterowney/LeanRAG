{"name":"ultrafilterBasis_is_basis","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\n‚ä¢ TopologicalSpace.IsTopologicalBasis (ultrafilterBasis Œ±)","decl":"theorem ultrafilterBasis_is_basis : TopologicalSpace.IsTopologicalBasis (ultrafilterBasis Œ±) :=\n  ‚ü®by\n    rintro _ ‚ü®a, rfl‚ü© _ ‚ü®b, rfl‚ü© u ‚ü®ua, ub‚ü©\n    refine ‚ü®_, ‚ü®a ‚à© b, rfl‚ü©, inter_mem ua ub, fun v hv ‚Ü¶ ‚ü®?_, ?_‚ü©‚ü© <;> apply mem_of_superset hv <;>\n      simp [inter_subset_right],\n    eq_univ_of_univ_subset <| subset_sUnion_of_mem <| ‚ü®univ, eq_univ_of_forall fun _ ‚Ü¶ univ_mem‚ü©,\n    rfl‚ü©\n\n"}
{"name":"ultrafilter_isOpen_basic","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\ns : Set Œ±\n‚ä¢ IsOpen (setOf fun u => Membership.mem u s)","decl":"/-- The basic open sets for the topology on ultrafilters are open. -/\ntheorem ultrafilter_isOpen_basic (s : Set Œ±) : IsOpen { u : Ultrafilter Œ± | s ‚àà u } :=\n  ultrafilterBasis_is_basis.isOpen ‚ü®s, rfl‚ü©\n\n"}
{"name":"ultrafilter_isClosed_basic","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\ns : Set Œ±\n‚ä¢ IsClosed (setOf fun u => Membership.mem u s)","decl":"/-- The basic open sets for the topology on ultrafilters are also closed. -/\ntheorem ultrafilter_isClosed_basic (s : Set Œ±) : IsClosed { u : Ultrafilter Œ± | s ‚àà u } := by\n  rw [‚Üê isOpen_compl_iff]\n  convert ultrafilter_isOpen_basic s·∂ú using 1\n  ext u\n  exact Ultrafilter.compl_mem_iff_not_mem.symm\n\n"}
{"name":"ultrafilter_converges_iff","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\nu : Ultrafilter (Ultrafilter Œ±)\nx : Ultrafilter Œ±\n‚ä¢ Iff (LE.le (‚Üëu) (nhds x)) (Eq x (joinM u))","decl":"/-- Every ultrafilter `u` on `Ultrafilter Œ±` converges to a unique\n  point of `Ultrafilter Œ±`, namely `joinM u`. -/\ntheorem ultrafilter_converges_iff {u : Ultrafilter (Ultrafilter Œ±)} {x : Ultrafilter Œ±} :\n    ‚Üëu ‚â§ ùìù x ‚Üî x = joinM u := by\n  rw [eq_comm, ‚Üê Ultrafilter.coe_le_coe]\n  change ‚Üëu ‚â§ ùìù x ‚Üî ‚àÄ s ‚àà x, { v : Ultrafilter Œ± | s ‚àà v } ‚àà u\n  simp only [TopologicalSpace.nhds_generateFrom, le_iInf_iff, ultrafilterBasis, le_principal_iff,\n    mem_setOf_eq]\n  constructor\n  ¬∑ intro h a ha\n    exact h _ ‚ü®ha, a, rfl‚ü©\n  ¬∑ rintro h a ‚ü®xi, a, rfl‚ü©\n    exact h _ xi\n\n"}
{"name":"ultrafilter_compact","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\n‚ä¢ CompactSpace (Ultrafilter Œ±)","decl":"instance ultrafilter_compact : CompactSpace (Ultrafilter Œ±) :=\n  ‚ü®isCompact_iff_ultrafilter_le_nhds.mpr fun f _ ‚Ü¶\n      ‚ü®joinM f, trivial, ultrafilter_converges_iff.mpr rfl‚ü©‚ü©\n\n"}
{"name":"Ultrafilter.t2Space","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\n‚ä¢ T2Space (Ultrafilter Œ±)","decl":"instance Ultrafilter.t2Space : T2Space (Ultrafilter Œ±) :=\n  t2_iff_ultrafilter.mpr fun {x y} f fx fy ‚Ü¶\n    have hx : x = joinM f := ultrafilter_converges_iff.mp fx\n    have hy : y = joinM f := ultrafilter_converges_iff.mp fy\n    hx.trans hy.symm\n\n"}
{"name":"instTotallyDisconnectedSpaceUltrafilter","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\n‚ä¢ TotallyDisconnectedSpace (Ultrafilter Œ±)","decl":"instance : TotallyDisconnectedSpace (Ultrafilter Œ±) := by\n  rw [totallyDisconnectedSpace_iff_connectedComponent_singleton]\n  intro A\n  simp only [Set.eq_singleton_iff_unique_mem, mem_connectedComponent, true_and]\n  intro B hB\n  rw [‚Üê Ultrafilter.coe_le_coe]\n  intro s hs\n  rw [connectedComponent_eq_iInter_isClopen, Set.mem_iInter] at hB\n  let Z := { F : Ultrafilter Œ± | s ‚àà F }\n  have hZ : IsClopen Z := ‚ü®ultrafilter_isClosed_basic s, ultrafilter_isOpen_basic s‚ü©\n  exact hB ‚ü®Z, hZ, hs‚ü©\n\n"}
{"name":"Ultrafilter.tendsto_pure_self","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\nb : Ultrafilter Œ±\n‚ä¢ Filter.Tendsto Pure.pure (‚Üëb) (nhds b)","decl":"@[simp] theorem Ultrafilter.tendsto_pure_self (b : Ultrafilter Œ±) : Tendsto pure b (ùìù b) := by\n  rw [Tendsto, ‚Üê coe_map, ultrafilter_converges_iff]\n  ext s\n  change s ‚àà b ‚Üî {t | s ‚àà t} ‚àà map pure b\n  simp_rw [mem_map, preimage_setOf_eq, mem_pure, setOf_mem_eq]\n\n"}
{"name":"ultrafilter_comap_pure_nhds","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\nb : Ultrafilter Œ±\n‚ä¢ LE.le (Filter.comap Pure.pure (nhds b)) ‚Üëb","decl":"theorem ultrafilter_comap_pure_nhds (b : Ultrafilter Œ±) : comap pure (ùìù b) ‚â§ b := by\n  rw [TopologicalSpace.nhds_generateFrom]\n  simp only [comap_iInf, comap_principal]\n  intro s hs\n  rw [‚Üê le_principal_iff]\n  refine iInf_le_of_le { u | s ‚àà u } ?_\n  refine iInf_le_of_le ‚ü®hs, ‚ü®s, rfl‚ü©‚ü© ?_\n  exact principal_mono.2 fun _ ‚Ü¶ id\n\n"}
{"name":"ultrafilter_pure_injective","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\n‚ä¢ Function.Injective Pure.pure","decl":"theorem ultrafilter_pure_injective : Function.Injective (pure : Œ± ‚Üí Ultrafilter Œ±) := by\n  intro x y h\n  have : {x} ‚àà (pure x : Ultrafilter Œ±) := singleton_mem_pure\n  rw [h] at this\n  exact (mem_singleton_iff.mp (mem_pure.mp this)).symm\n\n"}
{"name":"denseRange_pure","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\n‚ä¢ DenseRange Pure.pure","decl":"/-- The range of `pure : Œ± ‚Üí Ultrafilter Œ±` is dense in `Ultrafilter Œ±`. -/\ntheorem denseRange_pure : DenseRange (pure : Œ± ‚Üí Ultrafilter Œ±) :=\n  fun x ‚Ü¶ mem_closure_iff_ultrafilter.mpr\n    ‚ü®x.map pure, range_mem_map, ultrafilter_converges_iff.mpr (bind_pure x).symm‚ü©\n\n"}
{"name":"induced_topology_pure","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\n‚ä¢ Eq (TopologicalSpace.induced Pure.pure Ultrafilter.topologicalSpace) Bot.bot","decl":"/-- The map `pure : Œ± ‚Üí Ultrafilter Œ±` induces on `Œ±` the discrete topology. -/\ntheorem induced_topology_pure :\n    TopologicalSpace.induced (pure : Œ± ‚Üí Ultrafilter Œ±) Ultrafilter.topologicalSpace = ‚ä• := by\n  apply eq_bot_of_singletons_open\n  intro x\n  use { u : Ultrafilter Œ± | {x} ‚àà u }, ultrafilter_isOpen_basic _\n  simp\n\n"}
{"name":"isDenseInducing_pure","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\n‚ä¢ IsDenseInducing Pure.pure","decl":"/-- `pure : Œ± ‚Üí Ultrafilter Œ±` defines a dense inducing of `Œ±` in `Ultrafilter Œ±`. -/\ntheorem isDenseInducing_pure : @IsDenseInducing _ _ ‚ä• _ (pure : Œ± ‚Üí Ultrafilter Œ±) :=\n  letI : TopologicalSpace Œ± := ‚ä•\n  ‚ü®‚ü®induced_topology_pure.symm‚ü©, denseRange_pure‚ü©\n\n-- The following refined version will never be used\n"}
{"name":"isDenseEmbedding_pure","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\n‚ä¢ IsDenseEmbedding Pure.pure","decl":"/-- `pure : Œ± ‚Üí Ultrafilter Œ±` defines a dense embedding of `Œ±` in `Ultrafilter Œ±`. -/\ntheorem isDenseEmbedding_pure : @IsDenseEmbedding _ _ ‚ä• _ (pure : Œ± ‚Üí Ultrafilter Œ±) :=\n  letI : TopologicalSpace Œ± := ‚ä•\n  { isDenseInducing_pure with injective := ultrafilter_pure_injective }\n\n"}
{"name":"denseEmbedding_pure","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\n‚ä¢ IsDenseEmbedding Pure.pure","decl":"@[deprecated (since := \"2024-09-30\")]\nalias denseEmbedding_pure := isDenseEmbedding_pure\n\n"}
{"name":"ultrafilter_extend_extends","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\nŒ≥ : Type u_1\ninst‚úù¬π : TopologicalSpace Œ≥\ninst‚úù : T2Space Œ≥\nf : Œ± ‚Üí Œ≥\n‚ä¢ Eq (Function.comp (Ultrafilter.extend f) Pure.pure) f","decl":"theorem ultrafilter_extend_extends (f : Œ± ‚Üí Œ≥) : Ultrafilter.extend f ‚àò pure = f := by\n  letI : TopologicalSpace Œ± := ‚ä•\n  haveI : DiscreteTopology Œ± := ‚ü®rfl‚ü©\n  exact funext (isDenseInducing_pure.extend_eq continuous_of_discreteTopology)\n\n"}
{"name":"continuous_ultrafilter_extend","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\nŒ≥ : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ≥\ninst‚úù¬π : T2Space Œ≥\ninst‚úù : CompactSpace Œ≥\nf : Œ± ‚Üí Œ≥\n‚ä¢ Continuous (Ultrafilter.extend f)","decl":"theorem continuous_ultrafilter_extend (f : Œ± ‚Üí Œ≥) : Continuous (Ultrafilter.extend f) := by\n  have h (b : Ultrafilter Œ±) : ‚àÉ c, Tendsto f (comap pure (ùìù b)) (ùìù c) :=\n    -- b.map f is an ultrafilter on Œ≥, which is compact, so it converges to some c in Œ≥.\n    let ‚ü®c, _, h'‚ü© :=\n      isCompact_univ.ultrafilter_le_nhds (b.map f) (by rw [le_principal_iff]; exact univ_mem)\n    ‚ü®c, le_trans (map_mono (ultrafilter_comap_pure_nhds _)) h'‚ü©\n  let _ : TopologicalSpace Œ± := ‚ä•\n  exact isDenseInducing_pure.continuous_extend h\n\n"}
{"name":"ultrafilter_extend_eq_iff","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\nŒ≥ : Type u_1\ninst‚úù¬≤ : TopologicalSpace Œ≥\ninst‚úù¬π : T2Space Œ≥\ninst‚úù : CompactSpace Œ≥\nf : Œ± ‚Üí Œ≥\nb : Ultrafilter Œ±\nc : Œ≥\n‚ä¢ Iff (Eq (Ultrafilter.extend f b) c) (LE.le (‚Üë(Ultrafilter.map f b)) (nhds c))","decl":"/-- The value of `Ultrafilter.extend f` on an ultrafilter `b` is the\n  unique limit of the ultrafilter `b.map f` in `Œ≥`. -/\ntheorem ultrafilter_extend_eq_iff {f : Œ± ‚Üí Œ≥} {b : Ultrafilter Œ±} {c : Œ≥} :\n    Ultrafilter.extend f b = c ‚Üî ‚Üë(b.map f) ‚â§ ùìù c :=\n  ‚ü®fun h ‚Ü¶ by\n     -- Write b as an ultrafilter limit of pure ultrafilters, and use\n     -- the facts that ultrafilter.extend is a continuous extension of f.\n     let b' : Ultrafilter (Ultrafilter Œ±) := b.map pure\n     have t : ‚Üëb' ‚â§ ùìù b := ultrafilter_converges_iff.mpr (bind_pure _).symm\n     rw [‚Üê h]\n     have := (continuous_ultrafilter_extend f).tendsto b\n     refine le_trans ?_ (le_trans (map_mono t) this)\n     change _ ‚â§ map (Ultrafilter.extend f ‚àò pure) ‚Üëb\n     rw [ultrafilter_extend_extends]\n     exact le_rfl,\n   fun h ‚Ü¶\n    let _ : TopologicalSpace Œ± := ‚ä•\n    isDenseInducing_pure.extend_eq_of_tendsto\n      (le_trans (map_mono (ultrafilter_comap_pure_nhds _)) h)‚ü©\n\n"}
{"name":"instCompactSpacePreStoneCech","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ CompactSpace (PreStoneCech Œ±)","decl":"instance : CompactSpace (PreStoneCech Œ±) :=\n  Quot.compactSpace\n\n"}
{"name":"continuous_preStoneCechUnit","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ Continuous preStoneCechUnit","decl":"theorem continuous_preStoneCechUnit : Continuous (preStoneCechUnit : Œ± ‚Üí PreStoneCech Œ±) :=\n  continuous_iff_ultrafilter.mpr fun x g gx ‚Ü¶ by\n    have : (g.map pure).toFilter ‚â§ ùìù g := by\n      rw [ultrafilter_converges_iff, ‚Üê bind_pure g]\n      rfl\n    have : (map preStoneCechUnit g : Filter (PreStoneCech Œ±)) ‚â§ ùìù (Quot.mk _ g) :=\n      (map_mono this).trans (continuous_quot_mk.tendsto _)\n    convert this\n    exact Quot.sound ‚ü®x, pure_le_nhds x, gx‚ü©\n\n"}
{"name":"denseRange_preStoneCechUnit","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ DenseRange preStoneCechUnit","decl":"theorem denseRange_preStoneCechUnit : DenseRange (preStoneCechUnit : Œ± ‚Üí PreStoneCech Œ±) :=\n  Quot.mk_surjective.denseRange.comp denseRange_pure continuous_coinduced_rng\n\n\n"}
{"name":"preStoneCech_hom_ext","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\nŒ≤ : Type v\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : T2Space Œ≤\ng‚ÇÅ g‚ÇÇ : PreStoneCech Œ± ‚Üí Œ≤\nh‚ÇÅ : Continuous g‚ÇÅ\nh‚ÇÇ : Continuous g‚ÇÇ\nh : Eq (Function.comp g‚ÇÅ preStoneCechUnit) (Function.comp g‚ÇÇ preStoneCechUnit)\n‚ä¢ Eq g‚ÇÅ g‚ÇÇ","decl":"theorem preStoneCech_hom_ext {g‚ÇÅ g‚ÇÇ : PreStoneCech Œ± ‚Üí Œ≤} (h‚ÇÅ : Continuous g‚ÇÅ) (h‚ÇÇ : Continuous g‚ÇÇ)\n    (h : g‚ÇÅ ‚àò preStoneCechUnit = g‚ÇÇ ‚àò preStoneCechUnit) : g‚ÇÅ = g‚ÇÇ := by\n  apply Continuous.ext_on denseRange_preStoneCechUnit h‚ÇÅ h‚ÇÇ\n  rintro x ‚ü®x, rfl‚ü©\n  apply congr_fun h x\n\n"}
{"name":"preStoneCechCompat","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : T2Space Œ≤\ninst‚úù : CompactSpace Œ≤\ng : Œ± ‚Üí Œ≤\nhg : Continuous g\nF G : Ultrafilter Œ±\nx : Œ±\nhF : LE.le (‚ÜëF) (nhds x)\nhG : LE.le (‚ÜëG) (nhds x)\n‚ä¢ Eq (Ultrafilter.extend g F) (Ultrafilter.extend g G)","decl":"lemma preStoneCechCompat {F G : Ultrafilter Œ±} {x : Œ±} (hF : ‚ÜëF ‚â§ ùìù x) (hG : ‚ÜëG ‚â§ ùìù x) :\n    Ultrafilter.extend g F = Ultrafilter.extend g G := by\n  replace hF := (map_mono hF).trans hg.continuousAt\n  replace hG := (map_mono hG).trans hg.continuousAt\n  rwa [show Ultrafilter.extend g G = g x by rwa [ultrafilter_extend_eq_iff, G.coe_map],\n       ultrafilter_extend_eq_iff, F.coe_map]\n\n"}
{"name":"preStoneCechExtend_extends","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : T2Space Œ≤\ninst‚úù : CompactSpace Œ≤\ng : Œ± ‚Üí Œ≤\nhg : Continuous g\n‚ä¢ Eq (Function.comp (preStoneCechExtend hg) preStoneCechUnit) g","decl":"theorem preStoneCechExtend_extends : preStoneCechExtend hg ‚àò preStoneCechUnit = g :=\n  ultrafilter_extend_extends g\n\n"}
{"name":"eq_if_preStoneCechUnit_eq","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : T2Space Œ≤\ninst‚úù : CompactSpace Œ≤\ng : Œ± ‚Üí Œ≤\nhg : Continuous g\na b : Œ±\nh : Eq (preStoneCechUnit a) (preStoneCechUnit b)\n‚ä¢ Eq (g a) (g b)","decl":"lemma eq_if_preStoneCechUnit_eq {a b : Œ±} (h : preStoneCechUnit a = preStoneCechUnit b) :\n    g a = g b := by\n  have e := ultrafilter_extend_extends g\n  rw [‚Üê congrFun e a, ‚Üê congrFun e b, Function.comp_apply, Function.comp_apply]\n  rw [preStoneCechUnit, preStoneCechUnit, Quot.eq] at h\n  generalize (pure a : Ultrafilter Œ±) = F at h\n  generalize (pure b : Ultrafilter Œ±) = G at h\n  induction h with\n  | rel x y a => exact let ‚ü®a, hx, hy‚ü© := a; preStoneCechCompat hg hx hy\n  | refl x => rfl\n  | symm x y _ h => rw [h]\n  | trans x y z _ _ h h' => exact h.trans h'\n\n"}
{"name":"continuous_preStoneCechExtend","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : T2Space Œ≤\ninst‚úù : CompactSpace Œ≤\ng : Œ± ‚Üí Œ≤\nhg : Continuous g\n‚ä¢ Continuous (preStoneCechExtend hg)","decl":"theorem continuous_preStoneCechExtend : Continuous (preStoneCechExtend hg) :=\n  continuous_quot_lift _ (continuous_ultrafilter_extend g)\n\n"}
{"name":"instT2SpaceStoneCech","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ T2Space (StoneCech Œ±)","decl":"instance : T2Space (StoneCech Œ±) :=\n  inferInstanceAs <| T2Space <| t2Quotient _\n\n"}
{"name":"instCompactSpaceStoneCech","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ CompactSpace (StoneCech Œ±)","decl":"instance : CompactSpace (StoneCech Œ±) :=\n  Quot.compactSpace\n\n"}
{"name":"continuous_stoneCechUnit","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ Continuous stoneCechUnit","decl":"theorem continuous_stoneCechUnit : Continuous (stoneCechUnit : Œ± ‚Üí StoneCech Œ±) :=\n  (t2Quotient.continuous_mk _).comp continuous_preStoneCechUnit\n\n"}
{"name":"denseRange_stoneCechUnit","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ DenseRange stoneCechUnit","decl":"/-- The image of `stoneCechUnit` is dense. (But `stoneCechUnit` need\n  not be an embedding, for example if the original space is not Hausdorff.) -/\ntheorem denseRange_stoneCechUnit : DenseRange (stoneCechUnit : Œ± ‚Üí StoneCech Œ±) := by\n  unfold stoneCechUnit t2Quotient.mk\n  have : Function.Surjective (t2Quotient.mk : PreStoneCech Œ± ‚Üí StoneCech Œ±) := by\n    exact Quot.mk_surjective\n  exact this.denseRange.comp denseRange_preStoneCechUnit continuous_coinduced_rng\n\n"}
{"name":"stoneCech_hom_ext","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\ninst‚úù¬≤ : TopologicalSpace Œ±\nŒ≤ : Type v\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : T2Space Œ≤\ng‚ÇÅ g‚ÇÇ : StoneCech Œ± ‚Üí Œ≤\nh‚ÇÅ : Continuous g‚ÇÅ\nh‚ÇÇ : Continuous g‚ÇÇ\nh : Eq (Function.comp g‚ÇÅ stoneCechUnit) (Function.comp g‚ÇÇ stoneCechUnit)\n‚ä¢ Eq g‚ÇÅ g‚ÇÇ","decl":"theorem stoneCech_hom_ext {g‚ÇÅ g‚ÇÇ : StoneCech Œ± ‚Üí Œ≤} (h‚ÇÅ : Continuous g‚ÇÅ) (h‚ÇÇ : Continuous g‚ÇÇ)\n    (h : g‚ÇÅ ‚àò stoneCechUnit = g‚ÇÇ ‚àò stoneCechUnit) : g‚ÇÅ = g‚ÇÇ := by\n  apply h‚ÇÅ.ext_on denseRange_stoneCechUnit h‚ÇÇ\n  rintro _ ‚ü®x, rfl‚ü©\n  exact congr_fun h x\n\n"}
{"name":"stoneCechExtend_extends","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : T2Space Œ≤\ng : Œ± ‚Üí Œ≤\nhg : Continuous g\ninst‚úù : CompactSpace Œ≤\n‚ä¢ Eq (Function.comp (stoneCechExtend hg) stoneCechUnit) g","decl":"theorem stoneCechExtend_extends : stoneCechExtend hg ‚àò stoneCechUnit = g := by\n  ext x\n  rw [stoneCechExtend, Function.comp_apply, stoneCechUnit, t2Quotient.lift_mk]\n  apply congrFun (preStoneCechExtend_extends hg)\n\n"}
{"name":"continuous_stoneCechExtend","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : T2Space Œ≤\ng : Œ± ‚Üí Œ≤\nhg : Continuous g\ninst‚úù : CompactSpace Œ≤\n‚ä¢ Continuous (stoneCechExtend hg)","decl":"theorem continuous_stoneCechExtend : Continuous (stoneCechExtend hg) :=\n  continuous_coinduced_dom.mpr (continuous_preStoneCechExtend hg)\n\n"}
{"name":"eq_if_stoneCechUnit_eq","module":"Mathlib.Topology.StoneCech","initialProofState":"Œ± : Type u\ninst‚úù¬≥ : TopologicalSpace Œ±\nŒ≤ : Type v\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : T2Space Œ≤\ninst‚úù : CompactSpace Œ≤\na b : Œ±\nf : Œ± ‚Üí Œ≤\nhcf : Continuous f\nh : Eq (stoneCechUnit a) (stoneCechUnit b)\n‚ä¢ Eq (f a) (f b)","decl":"lemma eq_if_stoneCechUnit_eq {a b : Œ±} {f : Œ± ‚Üí Œ≤} (hcf : Continuous f)\n    (h : stoneCechUnit a = stoneCechUnit b) : f a = f b := by\n  rw [‚Üê congrFun (stoneCechExtend_extends hcf), ‚Üê congrFun (stoneCechExtend_extends hcf)]\n  exact congrArg (stoneCechExtend hcf) h\n\n"}
