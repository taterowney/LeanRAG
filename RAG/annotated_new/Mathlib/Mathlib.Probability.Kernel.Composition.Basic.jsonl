{"name":"ProbabilityTheory.Kernel.compProdFun_empty","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel (Prod α β) γ\na : α\n⊢ Eq (κ.compProdFun η a EmptyCollection.emptyCollection) 0","decl":"theorem compProdFun_empty (κ : Kernel α β) (η : Kernel (α × β) γ) (a : α) :\n    compProdFun κ η a ∅ = 0 := by\n  simp only [compProdFun, Set.mem_empty_iff_false, Set.setOf_false, measure_empty,\n    MeasureTheory.lintegral_const, zero_mul]\n\n"}
{"name":"ProbabilityTheory.Kernel.compProdFun_iUnion","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\nf : Nat → Set (Prod β γ)\nhf_meas : ∀ (i : Nat), MeasurableSet (f i)\nhf_disj : Pairwise (Function.onFun Disjoint f)\n⊢ Eq (κ.compProdFun η a (Set.iUnion fun i => f i)) (tsum fun i => κ.compProdFun η a (f i))","decl":"theorem compProdFun_iUnion (κ : Kernel α β) (η : Kernel (α × β) γ) [IsSFiniteKernel η] (a : α)\n    (f : ℕ → Set (β × γ)) (hf_meas : ∀ i, MeasurableSet (f i))\n    (hf_disj : Pairwise (Disjoint on f)) :\n    compProdFun κ η a (⋃ i, f i) = ∑' i, compProdFun κ η a (f i) := by\n  have h_Union : (fun b ↦ η (a, b) {c : γ | (b, c) ∈ ⋃ i, f i})\n      = fun b ↦ η (a, b) (⋃ i, {c : γ | (b, c) ∈ f i}) := by\n    ext1 b\n    congr with c\n    simp only [Set.mem_iUnion, Set.iSup_eq_iUnion, Set.mem_setOf_eq]\n  rw [compProdFun, h_Union]\n  have h_tsum : (fun b ↦ η (a, b) (⋃ i, {c : γ | (b, c) ∈ f i}))\n      = fun b ↦ ∑' i, η (a, b) {c : γ | (b, c) ∈ f i} := by\n    ext1 b\n    rw [measure_iUnion]\n    · intro i j hij s hsi hsj c hcs\n      have hbci : {(b, c)} ⊆ f i := by rw [Set.singleton_subset_iff]; exact hsi hcs\n      have hbcj : {(b, c)} ⊆ f j := by rw [Set.singleton_subset_iff]; exact hsj hcs\n      simpa only [Set.bot_eq_empty, Set.le_eq_subset, Set.singleton_subset_iff,\n        Set.mem_empty_iff_false] using hf_disj hij hbci hbcj\n    · exact fun i ↦ measurable_prod_mk_left (hf_meas i)\n  rw [h_tsum, lintegral_tsum]\n  · simp [compProdFun]\n  · intro i\n    have hm : MeasurableSet {p : (α × β) × γ | (p.1.2, p.2) ∈ f i} :=\n      measurable_fst.snd.prod_mk measurable_snd (hf_meas i)\n    exact ((measurable_kernel_prod_mk_left hm).comp measurable_prod_mk_left).aemeasurable\n\n"}
{"name":"ProbabilityTheory.Kernel.compProdFun_tsum_right","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ns : Set (Prod β γ)\nκ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\nhs : MeasurableSet s\n⊢ Eq (κ.compProdFun η a s) (tsum fun n => κ.compProdFun (η.seq n) a s)","decl":"theorem compProdFun_tsum_right (κ : Kernel α β) (η : Kernel (α × β) γ) [IsSFiniteKernel η] (a : α)\n    (hs : MeasurableSet s) : compProdFun κ η a s = ∑' n, compProdFun κ (seq η n) a s := by\n  simp_rw [compProdFun, (measure_sum_seq η _).symm]\n  have : ∫⁻ b, Measure.sum (fun n => seq η n (a, b)) {c : γ | (b, c) ∈ s} ∂κ a\n      = ∫⁻ b, ∑' n, seq η n (a, b) {c : γ | (b, c) ∈ s} ∂κ a := by\n    congr with b\n    rw [Measure.sum_apply]\n    exact measurable_prod_mk_left hs\n  rw [this, lintegral_tsum]\n  exact fun n ↦ ((measurable_kernel_prod_mk_left (κ := (seq η n))\n    ((measurable_fst.snd.prod_mk measurable_snd) hs)).comp measurable_prod_mk_left).aemeasurable\n\n"}
{"name":"ProbabilityTheory.Kernel.compProdFun_tsum_left","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\na : α\ns : Set (Prod β γ)\n⊢ Eq (κ.compProdFun η a s) (tsum fun n => (κ.seq n).compProdFun η a s)","decl":"theorem compProdFun_tsum_left (κ : Kernel α β) (η : Kernel (α × β) γ) [IsSFiniteKernel κ] (a : α)\n    (s : Set (β × γ)) : compProdFun κ η a s = ∑' n, compProdFun (seq κ n) η a s := by\n  simp_rw [compProdFun, (measure_sum_seq κ _).symm, lintegral_sum_measure]\n\n"}
{"name":"ProbabilityTheory.Kernel.compProdFun_eq_tsum","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ns : Set (Prod β γ)\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\nhs : MeasurableSet s\n⊢ Eq (κ.compProdFun η a s) (tsum fun n => tsum fun m => (κ.seq n).compProdFun (η.seq m) a s)","decl":"theorem compProdFun_eq_tsum (κ : Kernel α β) [IsSFiniteKernel κ] (η : Kernel (α × β) γ)\n    [IsSFiniteKernel η] (a : α) (hs : MeasurableSet s) :\n    compProdFun κ η a s = ∑' (n) (m), compProdFun (seq κ n) (seq η m) a s := by\n  simp_rw [compProdFun_tsum_left κ η a s, compProdFun_tsum_right _ η a hs]\n\n"}
{"name":"ProbabilityTheory.Kernel.measurable_compProdFun","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ns : Set (Prod β γ)\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\nhs : MeasurableSet s\n⊢ Measurable fun a => κ.compProdFun η a s","decl":"theorem measurable_compProdFun (κ : Kernel α β) [IsSFiniteKernel κ] (η : Kernel (α × β) γ)\n    [IsSFiniteKernel η] (hs : MeasurableSet s) :\n    Measurable fun a ↦ compProdFun κ η a s := by\n  simp only [compProdFun]\n  have h_meas : Measurable (Function.uncurry fun a b => η (a, b) {c : γ | (b, c) ∈ s}) := by\n    have : (Function.uncurry fun a b => η (a, b) {c : γ | (b, c) ∈ s})\n        = fun p ↦ η p {c : γ | (p.2, c) ∈ s} := by\n      ext1 p\n      rw [Function.uncurry_apply_pair]\n    rw [this]\n    exact measurable_kernel_prod_mk_left (measurable_fst.snd.prod_mk measurable_snd hs)\n  exact h_meas.lintegral_kernel_prod_right\n\n"}
{"name":"ProbabilityTheory.Kernel.measurable_compProdFun_of_finite","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ns : Set (Prod β γ)\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\nhs : MeasurableSet s\n⊢ Measurable fun a => κ.compProdFun η a s","decl":"@[deprecated (since := \"2024-08-30\")]\nalias measurable_compProdFun_of_finite := measurable_compProdFun\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_apply_eq_compProdFun","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ns : Set (Prod β γ)\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\nhs : MeasurableSet s\n⊢ Eq (((κ.compProd η) a) s) (κ.compProdFun η a s)","decl":"theorem compProd_apply_eq_compProdFun (κ : Kernel α β) [IsSFiniteKernel κ] (η : Kernel (α × β) γ)\n    [IsSFiniteKernel η] (a : α) (hs : MeasurableSet s) :\n    (κ ⊗ₖ η) a s = compProdFun κ η a s := by\n  rw [compProd, dif_pos]\n  swap\n  · constructor <;> infer_instance\n  change\n    Measure.ofMeasurable (fun s _ => compProdFun κ η a s) (compProdFun_empty κ η a)\n        (compProdFun_iUnion κ η a) s =\n      ∫⁻ b, η (a, b) {c | (b, c) ∈ s} ∂κ a\n  rw [Measure.ofMeasurable_apply _ hs]\n  rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_of_not_isSFiniteKernel_left","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel (Prod α β) γ\nh : Not (ProbabilityTheory.IsSFiniteKernel κ)\n⊢ Eq (κ.compProd η) 0","decl":"theorem compProd_of_not_isSFiniteKernel_left (κ : Kernel α β) (η : Kernel (α × β) γ)\n    (h : ¬ IsSFiniteKernel κ) :\n    κ ⊗ₖ η = 0 := by\n  rw [compProd, dif_neg]\n  simp [h]\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_of_not_isSFiniteKernel_right","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel (Prod α β) γ\nh : Not (ProbabilityTheory.IsSFiniteKernel η)\n⊢ Eq (κ.compProd η) 0","decl":"theorem compProd_of_not_isSFiniteKernel_right (κ : Kernel α β) (η : Kernel (α × β) γ)\n    (h : ¬ IsSFiniteKernel η) :\n    κ ⊗ₖ η = 0 := by\n  rw [compProd, dif_neg]\n  simp [h]\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_apply","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ns : Set (Prod β γ)\nhs : MeasurableSet s\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\n⊢ Eq (((κ.compProd η) a) s) (MeasureTheory.lintegral (κ a) fun b => (η { fst := a, snd := b }) (setOf fun c => Membership.mem s { fst := b, snd := c }))","decl":"theorem compProd_apply (hs : MeasurableSet s) (κ : Kernel α β) [IsSFiniteKernel κ]\n    (η : Kernel (α × β) γ) [IsSFiniteKernel η] (a : α) :\n    (κ ⊗ₖ η) a s = ∫⁻ b, η (a, b) {c | (b, c) ∈ s} ∂κ a :=\n  compProd_apply_eq_compProdFun κ η a hs\n\n"}
{"name":"ProbabilityTheory.Kernel.le_compProd_apply","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\ns : Set (Prod β γ)\n⊢ LE.le (MeasureTheory.lintegral (κ a) fun b => (η { fst := a, snd := b }) (setOf fun c => Membership.mem s { fst := b, snd := c })) (((κ.compProd η) a) s)","decl":"theorem le_compProd_apply (κ : Kernel α β) [IsSFiniteKernel κ] (η : Kernel (α × β) γ)\n    [IsSFiniteKernel η] (a : α) (s : Set (β × γ)) :\n    ∫⁻ b, η (a, b) {c | (b, c) ∈ s} ∂κ a ≤ (κ ⊗ₖ η) a s :=\n  calc\n    ∫⁻ b, η (a, b) {c | (b, c) ∈ s} ∂κ a ≤\n        ∫⁻ b, η (a, b) {c | (b, c) ∈ toMeasurable ((κ ⊗ₖ η) a) s} ∂κ a :=\n      lintegral_mono fun _ => measure_mono fun _ h_mem => subset_toMeasurable _ _ h_mem\n    _ = (κ ⊗ₖ η) a (toMeasurable ((κ ⊗ₖ η) a) s) :=\n      (Kernel.compProd_apply_eq_compProdFun κ η a (measurableSet_toMeasurable _ _)).symm\n    _ = (κ ⊗ₖ η) a s := measure_toMeasurable s\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_zero_left","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\n⊢ Eq (ProbabilityTheory.Kernel.compProd 0 κ) 0","decl":"@[simp]\nlemma compProd_zero_left (κ : Kernel (α × β) γ) :\n    (0 : Kernel α β) ⊗ₖ κ = 0 := by\n  by_cases h : IsSFiniteKernel κ\n  · ext a s hs\n    rw [Kernel.compProd_apply hs]\n    simp\n  · rw [Kernel.compProd_of_not_isSFiniteKernel_right _ _ h]\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_zero_right","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nγ : Type u_4\nmγ : MeasurableSpace γ\n⊢ Eq (κ.compProd 0) 0","decl":"@[simp]\nlemma compProd_zero_right (κ : Kernel α β) (γ : Type*) {mγ : MeasurableSpace γ} :\n    κ ⊗ₖ (0 : Kernel (α × β) γ) = 0 := by\n  by_cases h : IsSFiniteKernel κ\n  · ext a s hs\n    rw [Kernel.compProd_apply hs]\n    simp\n  · rw [Kernel.compProd_of_not_isSFiniteKernel_left _ _ h]\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_preimage_fst","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ns : Set β\nhs : MeasurableSet s\nκ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\ninst✝ : ProbabilityTheory.IsMarkovKernel η\nx : α\n⊢ Eq (((κ.compProd η) x) (Set.preimage Prod.fst s)) ((κ x) s)","decl":"lemma compProd_preimage_fst {s : Set β} (hs : MeasurableSet s) (κ : Kernel α β)\n    (η : Kernel (α × β) γ) [IsSFiniteKernel κ] [IsMarkovKernel η] (x : α) :\n    (κ ⊗ₖ η) x (Prod.fst ⁻¹' s) = κ x s := by\n  rw [compProd_apply (measurable_fst hs)]\n  simp only [Set.mem_preimage]\n  classical\n  have : ∀ b : β, η (x, b) {_c | b ∈ s} = s.indicator (fun _ ↦ 1) b := by\n    intro b\n    by_cases hb : b ∈ s <;> simp [hb]\n  simp_rw [this]\n  rw [lintegral_indicator_const hs, one_mul]\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_deterministic_apply","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ninst✝¹ : MeasurableSingletonClass γ\nf : Prod α β → γ\nhf : Measurable f\ns : Set (Prod β γ)\nhs : MeasurableSet s\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nx : α\n⊢ Eq (((κ.compProd (ProbabilityTheory.Kernel.deterministic f hf)) x) s) ((κ x) (setOf fun b => Membership.mem s { fst := b, snd := f { fst := x, snd := b } }))","decl":"lemma compProd_deterministic_apply [MeasurableSingletonClass γ] {f : α × β → γ} (hf : Measurable f)\n    {s : Set (β × γ)} (hs : MeasurableSet s) (κ : Kernel α β) [IsSFiniteKernel κ] (x : α) :\n    (κ ⊗ₖ deterministic f hf) x s = κ x {b | (b, f (x, b)) ∈ s} := by\n  classical\n  simp only [deterministic_apply, measurableSet_setOf, Set.mem_setOf_eq, Measure.dirac_apply,\n    Set.mem_setOf_eq, Set.indicator_apply, Pi.one_apply, compProd_apply hs]\n  let t := {b | (b, f (x, b)) ∈ s}\n  have ht : MeasurableSet t := (measurable_id.prod_mk (hf.comp measurable_prod_mk_left)) hs\n  rw [← lintegral_add_compl _ ht]\n  convert add_zero _\n  · suffices ∀ b ∈ tᶜ, (if (b, f (x, b)) ∈ s then (1 : ℝ≥0∞) else 0) = 0 by\n      rw [setLIntegral_congr_fun ht.compl (ae_of_all _ this), lintegral_zero]\n    intro b hb\n    simp only [t, Set.mem_compl_iff, Set.mem_setOf_eq] at hb\n    simp [hb]\n  · suffices ∀ b ∈ t, (if (b, f (x, b)) ∈ s then (1 : ℝ≥0∞) else 0) = 1 by\n      rw [setLIntegral_congr_fun ht (ae_of_all _ this), setLIntegral_one]\n    intro b hb\n    simp only [t, Set.mem_setOf_eq] at hb\n    simp [hb]\n\n"}
{"name":"ProbabilityTheory.Kernel.ae_kernel_lt_top","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ns : Set (Prod β γ)\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\nh2s : Ne (((κ.compProd η) a) s) Top.top\n⊢ Filter.Eventually (fun b => LT.lt ((η { fst := a, snd := b }) (Set.preimage (Prod.mk b) s)) Top.top) (MeasureTheory.ae (κ a))","decl":"theorem ae_kernel_lt_top (a : α) (h2s : (κ ⊗ₖ η) a s ≠ ∞) :\n    ∀ᵐ b ∂κ a, η (a, b) (Prod.mk b ⁻¹' s) < ∞ := by\n  let t := toMeasurable ((κ ⊗ₖ η) a) s\n  have : ∀ b : β, η (a, b) (Prod.mk b ⁻¹' s) ≤ η (a, b) (Prod.mk b ⁻¹' t) := fun b =>\n    measure_mono (Set.preimage_mono (subset_toMeasurable _ _))\n  have ht : MeasurableSet t := measurableSet_toMeasurable _ _\n  have h2t : (κ ⊗ₖ η) a t ≠ ∞ := by rwa [measure_toMeasurable]\n  have ht_lt_top : ∀ᵐ b ∂κ a, η (a, b) (Prod.mk b ⁻¹' t) < ∞ := by\n    rw [Kernel.compProd_apply ht] at h2t\n    exact ae_lt_top (Kernel.measurable_kernel_prod_mk_left' ht a) h2t\n  filter_upwards [ht_lt_top] with b hb\n  exact (this b).trans_lt hb\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_null","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ns : Set (Prod β γ)\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\nhs : MeasurableSet s\n⊢ Iff (Eq (((κ.compProd η) a) s) 0) ((MeasureTheory.ae (κ a)).EventuallyEq (fun b => (η { fst := a, snd := b }) (Set.preimage (Prod.mk b) s)) 0)","decl":"theorem compProd_null (a : α) (hs : MeasurableSet s) :\n    (κ ⊗ₖ η) a s = 0 ↔ (fun b => η (a, b) (Prod.mk b ⁻¹' s)) =ᵐ[κ a] 0 := by\n  rw [Kernel.compProd_apply hs, lintegral_eq_zero_iff]\n  · rfl\n  · exact Kernel.measurable_kernel_prod_mk_left' hs a\n\n"}
{"name":"ProbabilityTheory.Kernel.ae_null_of_compProd_null","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ns : Set (Prod β γ)\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\nh : Eq (((κ.compProd η) a) s) 0\n⊢ (MeasureTheory.ae (κ a)).EventuallyEq (fun b => (η { fst := a, snd := b }) (Set.preimage (Prod.mk b) s)) 0","decl":"theorem ae_null_of_compProd_null (h : (κ ⊗ₖ η) a s = 0) :\n    (fun b => η (a, b) (Prod.mk b ⁻¹' s)) =ᵐ[κ a] 0 := by\n  obtain ⟨t, hst, mt, ht⟩ := exists_measurable_superset_of_null h\n  simp_rw [compProd_null a mt] at ht\n  rw [Filter.eventuallyLE_antisymm_iff]\n  exact\n    ⟨Filter.EventuallyLE.trans_eq\n        (Filter.Eventually.of_forall fun x => measure_mono (Set.preimage_mono hst)) ht,\n      Filter.Eventually.of_forall fun x => zero_le _⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.ae_ae_of_ae_compProd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\np : Prod β γ → Prop\nh : Filter.Eventually (fun bc => p bc) (MeasureTheory.ae ((κ.compProd η) a))\n⊢ Filter.Eventually (fun b => Filter.Eventually (fun c => p { fst := b, snd := c }) (MeasureTheory.ae (η { fst := a, snd := b }))) (MeasureTheory.ae (κ a))","decl":"theorem ae_ae_of_ae_compProd {p : β × γ → Prop} (h : ∀ᵐ bc ∂(κ ⊗ₖ η) a, p bc) :\n    ∀ᵐ b ∂κ a, ∀ᵐ c ∂η (a, b), p (b, c) :=\n  ae_null_of_compProd_null h\n\n"}
{"name":"ProbabilityTheory.Kernel.ae_compProd_of_ae_ae","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\na : α\nκ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel (Prod α β) γ\np : Prod β γ → Prop\nhp : MeasurableSet (setOf fun x => p x)\nh : Filter.Eventually (fun b => Filter.Eventually (fun c => p { fst := b, snd := c }) (MeasureTheory.ae (η { fst := a, snd := b }))) (MeasureTheory.ae (κ a))\n⊢ Filter.Eventually (fun bc => p bc) (MeasureTheory.ae ((κ.compProd η) a))","decl":"lemma ae_compProd_of_ae_ae {κ : Kernel α β} {η : Kernel (α × β) γ}\n    {p : β × γ → Prop} (hp : MeasurableSet {x | p x})\n    (h : ∀ᵐ b ∂κ a, ∀ᵐ c ∂η (a, b), p (b, c)) :\n    ∀ᵐ bc ∂(κ ⊗ₖ η) a, p bc := by\n  by_cases hκ : IsSFiniteKernel κ\n  swap; · simp [compProd_of_not_isSFiniteKernel_left _ _ hκ]\n  by_cases hη : IsSFiniteKernel η\n  swap; · simp [compProd_of_not_isSFiniteKernel_right _ _ hη]\n  simp_rw [ae_iff] at h ⊢\n  rw [compProd_null]\n  · exact h\n  · exact hp.compl\n\n"}
{"name":"ProbabilityTheory.Kernel.ae_compProd_iff","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\np : Prod β γ → Prop\nhp : MeasurableSet (setOf fun x => p x)\n⊢ Iff (Filter.Eventually (fun bc => p bc) (MeasureTheory.ae ((κ.compProd η) a))) (Filter.Eventually (fun b => Filter.Eventually (fun c => p { fst := b, snd := c }) (MeasureTheory.ae (η { fst := a, snd := b }))) (MeasureTheory.ae (κ a)))","decl":"lemma ae_compProd_iff {p : β × γ → Prop} (hp : MeasurableSet {x | p x}) :\n    (∀ᵐ bc ∂(κ ⊗ₖ η) a, p bc) ↔ ∀ᵐ b ∂κ a, ∀ᵐ c ∂η (a, b), p (b, c) :=\n  ⟨fun h ↦ ae_ae_of_ae_compProd h, fun h ↦ ae_compProd_of_ae_ae hp h⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_restrict","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\ns : Set β\nt : Set γ\nhs : MeasurableSet s\nht : MeasurableSet t\n⊢ Eq ((κ.restrict hs).compProd (η.restrict ht)) ((κ.compProd η).restrict ⋯)","decl":"theorem compProd_restrict {s : Set β} {t : Set γ} (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    Kernel.restrict κ hs ⊗ₖ Kernel.restrict η ht = Kernel.restrict (κ ⊗ₖ η) (hs.prod ht) := by\n  ext a u hu\n  rw [compProd_apply hu, restrict_apply' _ _ _ hu,\n    compProd_apply (hu.inter (hs.prod ht))]\n  simp only [Kernel.restrict_apply, Measure.restrict_apply' ht, Set.mem_inter_iff,\n    Set.prod_mk_mem_set_prod_eq]\n  have :\n    ∀ b,\n      η (a, b) {c : γ | (b, c) ∈ u ∧ b ∈ s ∧ c ∈ t} =\n        s.indicator (fun b => η (a, b) ({c : γ | (b, c) ∈ u} ∩ t)) b := by\n    intro b\n    classical\n    rw [Set.indicator_apply]\n    split_ifs with h\n    · simp only [h, true_and, Set.inter_def, Set.mem_setOf]\n    · simp only [h, false_and, and_false, Set.setOf_false, measure_empty]\n  simp_rw [this]\n  rw [lintegral_indicator hs]\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_restrict_left","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\ns : Set β\nhs : MeasurableSet s\n⊢ Eq ((κ.restrict hs).compProd η) ((κ.compProd η).restrict ⋯)","decl":"theorem compProd_restrict_left {s : Set β} (hs : MeasurableSet s) :\n    Kernel.restrict κ hs ⊗ₖ η = Kernel.restrict (κ ⊗ₖ η) (hs.prod MeasurableSet.univ) := by\n  rw [← compProd_restrict]\n  · congr; exact Kernel.restrict_univ.symm\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_restrict_right","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\nt : Set γ\nht : MeasurableSet t\n⊢ Eq (κ.compProd (η.restrict ht)) ((κ.compProd η).restrict ⋯)","decl":"theorem compProd_restrict_right {t : Set γ} (ht : MeasurableSet t) :\n    κ ⊗ₖ Kernel.restrict η ht = Kernel.restrict (κ ⊗ₖ η) (MeasurableSet.univ.prod ht) := by\n  rw [← compProd_restrict]\n  · congr; exact Kernel.restrict_univ.symm\n\n"}
{"name":"ProbabilityTheory.Kernel.lintegral_compProd'","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\nf : β → γ → ENNReal\nhf : Measurable (Function.uncurry f)\n⊢ Eq (MeasureTheory.lintegral ((κ.compProd η) a) fun bc => f bc.1 bc.2) (MeasureTheory.lintegral (κ a) fun b => MeasureTheory.lintegral (η { fst := a, snd := b }) fun c => f b c)","decl":"/-- Lebesgue integral against the composition-product of two kernels. -/\ntheorem lintegral_compProd' (κ : Kernel α β) [IsSFiniteKernel κ] (η : Kernel (α × β) γ)\n    [IsSFiniteKernel η] (a : α) {f : β → γ → ℝ≥0∞} (hf : Measurable (Function.uncurry f)) :\n    ∫⁻ bc, f bc.1 bc.2 ∂(κ ⊗ₖ η) a = ∫⁻ b, ∫⁻ c, f b c ∂η (a, b) ∂κ a := by\n  let F : ℕ → SimpleFunc (β × γ) ℝ≥0∞ := SimpleFunc.eapprox (Function.uncurry f)\n  have h : ∀ a, ⨆ n, F n a = Function.uncurry f a := SimpleFunc.iSup_eapprox_apply hf\n  simp only [Prod.forall, Function.uncurry_apply_pair] at h\n  simp_rw [← h]\n  have h_mono : Monotone F := fun i j hij b =>\n    SimpleFunc.monotone_eapprox (Function.uncurry f) hij _\n  rw [lintegral_iSup (fun n => (F n).measurable) h_mono]\n  have : ∀ b, ∫⁻ c, ⨆ n, F n (b, c) ∂η (a, b) = ⨆ n, ∫⁻ c, F n (b, c) ∂η (a, b) := by\n    intro a\n    rw [lintegral_iSup]\n    · exact fun n => (F n).measurable.comp measurable_prod_mk_left\n    · exact fun i j hij b => h_mono hij _\n  simp_rw [this]\n  have h_some_meas_integral :\n    ∀ f' : SimpleFunc (β × γ) ℝ≥0∞, Measurable fun b => ∫⁻ c, f' (b, c) ∂η (a, b) := by\n    intro f'\n    have :\n      (fun b => ∫⁻ c, f' (b, c) ∂η (a, b)) =\n        (fun ab => ∫⁻ c, f' (ab.2, c) ∂η ab) ∘ fun b => (a, b) := by\n      ext1 ab; rfl\n    rw [this]\n    apply Measurable.comp _ (measurable_prod_mk_left (m := mα))\n    exact Measurable.lintegral_kernel_prod_right\n      ((SimpleFunc.measurable _).comp (measurable_fst.snd.prod_mk measurable_snd))\n  rw [lintegral_iSup]\n  rotate_left\n  · exact fun n => h_some_meas_integral (F n)\n  · exact fun i j hij b => lintegral_mono fun c => h_mono hij _\n  congr\n  ext1 n\n  refine SimpleFunc.induction ?_ ?_ (F n)\n  · intro c s hs\n    classical -- Porting note: Added `classical` for `Set.piecewise_eq_indicator`\n    simp (config := { unfoldPartialApp := true }) only [SimpleFunc.const_zero,\n      SimpleFunc.coe_piecewise, SimpleFunc.coe_const, SimpleFunc.coe_zero,\n      Set.piecewise_eq_indicator, Function.const, lintegral_indicator_const hs]\n    rw [compProd_apply hs, ← lintegral_const_mul c _]\n    swap\n    · exact (measurable_kernel_prod_mk_left ((measurable_fst.snd.prod_mk measurable_snd) hs)).comp\n        measurable_prod_mk_left\n    congr\n    ext1 b\n    rw [lintegral_indicator_const_comp measurable_prod_mk_left hs]\n    rfl\n  · intro f f' _ hf_eq hf'_eq\n    simp_rw [SimpleFunc.coe_add, Pi.add_apply]\n    change\n      ∫⁻ x, (f : β × γ → ℝ≥0∞) x + f' x ∂(κ ⊗ₖ η) a =\n        ∫⁻ b, ∫⁻ c : γ, f (b, c) + f' (b, c) ∂η (a, b) ∂κ a\n    rw [lintegral_add_left (SimpleFunc.measurable _), hf_eq, hf'_eq, ← lintegral_add_left]\n    swap\n    · exact h_some_meas_integral f\n    congr with b\n    rw [lintegral_add_left]\n    exact (SimpleFunc.measurable _).comp measurable_prod_mk_left\n\n"}
{"name":"ProbabilityTheory.Kernel.lintegral_compProd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\nf : Prod β γ → ENNReal\nhf : Measurable f\n⊢ Eq (MeasureTheory.lintegral ((κ.compProd η) a) fun bc => f bc) (MeasureTheory.lintegral (κ a) fun b => MeasureTheory.lintegral (η { fst := a, snd := b }) fun c => f { fst := b, snd := c })","decl":"/-- Lebesgue integral against the composition-product of two kernels. -/\ntheorem lintegral_compProd (κ : Kernel α β) [IsSFiniteKernel κ] (η : Kernel (α × β) γ)\n    [IsSFiniteKernel η] (a : α) {f : β × γ → ℝ≥0∞} (hf : Measurable f) :\n    ∫⁻ bc, f bc ∂(κ ⊗ₖ η) a = ∫⁻ b, ∫⁻ c, f (b, c) ∂η (a, b) ∂κ a := by\n  let g := Function.curry f\n  change ∫⁻ bc, f bc ∂(κ ⊗ₖ η) a = ∫⁻ b, ∫⁻ c, g b c ∂η (a, b) ∂κ a\n  rw [← lintegral_compProd']\n  · simp_rw [g, Function.curry_apply]\n  · simp_rw [g, Function.uncurry_curry]; exact hf\n\n"}
{"name":"ProbabilityTheory.Kernel.lintegral_compProd₀","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\nf : Prod β γ → ENNReal\nhf : AEMeasurable f ((κ.compProd η) a)\n⊢ Eq (MeasureTheory.lintegral ((κ.compProd η) a) fun z => f z) (MeasureTheory.lintegral (κ a) fun x => MeasureTheory.lintegral (η { fst := a, snd := x }) fun y => f { fst := x, snd := y })","decl":"/-- Lebesgue integral against the composition-product of two kernels. -/\ntheorem lintegral_compProd₀ (κ : Kernel α β) [IsSFiniteKernel κ] (η : Kernel (α × β) γ)\n    [IsSFiniteKernel η] (a : α) {f : β × γ → ℝ≥0∞} (hf : AEMeasurable f ((κ ⊗ₖ η) a)) :\n    ∫⁻ z, f z ∂(κ ⊗ₖ η) a = ∫⁻ x, ∫⁻ y, f (x, y) ∂η (a, x) ∂κ a := by\n  have A : ∫⁻ z, f z ∂(κ ⊗ₖ η) a = ∫⁻ z, hf.mk f z ∂(κ ⊗ₖ η) a := lintegral_congr_ae hf.ae_eq_mk\n  have B : ∫⁻ x, ∫⁻ y, f (x, y) ∂η (a, x) ∂κ a = ∫⁻ x, ∫⁻ y, hf.mk f (x, y) ∂η (a, x) ∂κ a := by\n    apply lintegral_congr_ae\n    filter_upwards [ae_ae_of_ae_compProd hf.ae_eq_mk] with _ ha using lintegral_congr_ae ha\n  rw [A, B, lintegral_compProd]\n  exact hf.measurable_mk\n\n"}
{"name":"ProbabilityTheory.Kernel.setLIntegral_compProd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\nf : Prod β γ → ENNReal\nhf : Measurable f\ns : Set β\nt : Set γ\nhs : MeasurableSet s\nht : MeasurableSet t\n⊢ Eq (MeasureTheory.lintegral (((κ.compProd η) a).restrict (SProd.sprod s t)) fun z => f z) (MeasureTheory.lintegral ((κ a).restrict s) fun x => MeasureTheory.lintegral ((η { fst := a, snd := x }).restrict t) fun y => f { fst := x, snd := y })","decl":"theorem setLIntegral_compProd (κ : Kernel α β) [IsSFiniteKernel κ] (η : Kernel (α × β) γ)\n    [IsSFiniteKernel η] (a : α) {f : β × γ → ℝ≥0∞} (hf : Measurable f) {s : Set β} {t : Set γ}\n    (hs : MeasurableSet s) (ht : MeasurableSet t) :\n    ∫⁻ z in s ×ˢ t, f z ∂(κ ⊗ₖ η) a = ∫⁻ x in s, ∫⁻ y in t, f (x, y) ∂η (a, x) ∂κ a := by\n  simp_rw [← Kernel.restrict_apply (κ ⊗ₖ η) (hs.prod ht), ← compProd_restrict hs ht,\n    lintegral_compProd _ _ _ hf, Kernel.restrict_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.setLIntegral_compProd_univ_right","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\nf : Prod β γ → ENNReal\nhf : Measurable f\ns : Set β\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.lintegral (((κ.compProd η) a).restrict (SProd.sprod s Set.univ)) fun z => f z) (MeasureTheory.lintegral ((κ a).restrict s) fun x => MeasureTheory.lintegral (η { fst := a, snd := x }) fun y => f { fst := x, snd := y })","decl":"theorem setLIntegral_compProd_univ_right (κ : Kernel α β) [IsSFiniteKernel κ]\n    (η : Kernel (α × β) γ) [IsSFiniteKernel η] (a : α) {f : β × γ → ℝ≥0∞} (hf : Measurable f)\n    {s : Set β} (hs : MeasurableSet s) :\n    ∫⁻ z in s ×ˢ Set.univ, f z ∂(κ ⊗ₖ η) a = ∫⁻ x in s, ∫⁻ y, f (x, y) ∂η (a, x) ∂κ a := by\n  simp_rw [setLIntegral_compProd κ η a hf hs MeasurableSet.univ, Measure.restrict_univ]\n\n"}
{"name":"ProbabilityTheory.Kernel.setLIntegral_compProd_univ_left","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\nf : Prod β γ → ENNReal\nhf : Measurable f\nt : Set γ\nht : MeasurableSet t\n⊢ Eq (MeasureTheory.lintegral (((κ.compProd η) a).restrict (SProd.sprod Set.univ t)) fun z => f z) (MeasureTheory.lintegral (κ a) fun x => MeasureTheory.lintegral ((η { fst := a, snd := x }).restrict t) fun y => f { fst := x, snd := y })","decl":"theorem setLIntegral_compProd_univ_left (κ : Kernel α β) [IsSFiniteKernel κ] (η : Kernel (α × β) γ)\n    [IsSFiniteKernel η] (a : α) {f : β × γ → ℝ≥0∞} (hf : Measurable f) {t : Set γ}\n    (ht : MeasurableSet t) :\n    ∫⁻ z in Set.univ ×ˢ t, f z ∂(κ ⊗ₖ η) a = ∫⁻ x, ∫⁻ y in t, f (x, y) ∂η (a, x) ∂κ a := by\n  simp_rw [setLIntegral_compProd κ η a hf MeasurableSet.univ ht, Measure.restrict_univ]\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_eq_tsum_compProd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ns : Set (Prod β γ)\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\nhs : MeasurableSet s\n⊢ Eq (((κ.compProd η) a) s) (tsum fun n => tsum fun m => (((κ.seq n).compProd (η.seq m)) a) s)","decl":"theorem compProd_eq_tsum_compProd (κ : Kernel α β) [IsSFiniteKernel κ] (η : Kernel (α × β) γ)\n    [IsSFiniteKernel η] (a : α) (hs : MeasurableSet s) :\n    (κ ⊗ₖ η) a s = ∑' (n : ℕ) (m : ℕ), (seq κ n ⊗ₖ seq η m) a s := by\n  simp_rw [compProd_apply_eq_compProdFun _ _ _ hs]; exact compProdFun_eq_tsum κ η a hs\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_eq_sum_compProd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\n⊢ Eq (κ.compProd η) (ProbabilityTheory.Kernel.sum fun n => ProbabilityTheory.Kernel.sum fun m => (κ.seq n).compProd (η.seq m))","decl":"theorem compProd_eq_sum_compProd (κ : Kernel α β) [IsSFiniteKernel κ] (η : Kernel (α × β) γ)\n    [IsSFiniteKernel η] : κ ⊗ₖ η = Kernel.sum fun n => Kernel.sum fun m => seq κ n ⊗ₖ seq η m := by\n  ext a s hs; simp_rw [Kernel.sum_apply' _ a hs]; rw [compProd_eq_tsum_compProd κ η a hs]\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_eq_sum_compProd_left","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\n⊢ Eq (κ.compProd η) (ProbabilityTheory.Kernel.sum fun n => (κ.seq n).compProd η)","decl":"theorem compProd_eq_sum_compProd_left (κ : Kernel α β) [IsSFiniteKernel κ] (η : Kernel (α × β) γ) :\n    κ ⊗ₖ η = Kernel.sum fun n => seq κ n ⊗ₖ η := by\n  by_cases h : IsSFiniteKernel η\n  swap\n  · simp_rw [compProd_of_not_isSFiniteKernel_right _ _ h]\n    simp\n  rw [compProd_eq_sum_compProd]\n  congr with n a s hs\n  simp_rw [Kernel.sum_apply' _ _ hs, compProd_apply_eq_compProdFun _ _ _ hs,\n    compProdFun_tsum_right _ η a hs]\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_eq_sum_compProd_right","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\n⊢ Eq (κ.compProd η) (ProbabilityTheory.Kernel.sum fun n => κ.compProd (η.seq n))","decl":"theorem compProd_eq_sum_compProd_right (κ : Kernel α β) (η : Kernel (α × β) γ)\n    [IsSFiniteKernel η] : κ ⊗ₖ η = Kernel.sum fun n => κ ⊗ₖ seq η n := by\n  by_cases hκ : IsSFiniteKernel κ\n  swap\n  · simp_rw [compProd_of_not_isSFiniteKernel_left _ _ hκ]\n    simp\n  rw [compProd_eq_sum_compProd]\n  simp_rw [compProd_eq_sum_compProd_left κ _]\n  rw [Kernel.sum_comm]\n\n"}
{"name":"ProbabilityTheory.Kernel.IsMarkovKernel.compProd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsMarkovKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsMarkovKernel η\n⊢ ProbabilityTheory.IsMarkovKernel (κ.compProd η)","decl":"instance IsMarkovKernel.compProd (κ : Kernel α β) [IsMarkovKernel κ] (η : Kernel (α × β) γ)\n    [IsMarkovKernel η] : IsMarkovKernel (κ ⊗ₖ η) where\n  isProbabilityMeasure a := ⟨by simp [compProd_apply]⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_apply_univ_le","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsFiniteKernel η\na : α\n⊢ LE.le (((κ.compProd η) a) Set.univ) (HMul.hMul ((κ a) Set.univ) (ProbabilityTheory.IsFiniteKernel.bound η))","decl":"theorem compProd_apply_univ_le (κ : Kernel α β) (η : Kernel (α × β) γ) [IsFiniteKernel η] (a : α) :\n    (κ ⊗ₖ η) a Set.univ ≤ κ a Set.univ * IsFiniteKernel.bound η := by\n  by_cases hκ : IsSFiniteKernel κ\n  swap\n  · rw [compProd_of_not_isSFiniteKernel_left _ _ hκ]\n    simp\n  rw [compProd_apply .univ]\n  simp only [Set.mem_univ, Set.setOf_true]\n  let Cη := IsFiniteKernel.bound η\n  calc\n    ∫⁻ b, η (a, b) Set.univ ∂κ a ≤ ∫⁻ _, Cη ∂κ a :=\n      lintegral_mono fun b => measure_le_bound η (a, b) Set.univ\n    _ = Cη * κ a Set.univ := MeasureTheory.lintegral_const Cη\n    _ = κ a Set.univ * Cη := mul_comm _ _\n\n"}
{"name":"ProbabilityTheory.Kernel.IsFiniteKernel.compProd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsFiniteKernel η\n⊢ ProbabilityTheory.IsFiniteKernel (κ.compProd η)","decl":"instance IsFiniteKernel.compProd (κ : Kernel α β) [IsFiniteKernel κ] (η : Kernel (α × β) γ)\n    [IsFiniteKernel η] : IsFiniteKernel (κ ⊗ₖ η) :=\n  ⟨⟨IsFiniteKernel.bound κ * IsFiniteKernel.bound η,\n      ENNReal.mul_lt_top (IsFiniteKernel.bound_lt_top κ) (IsFiniteKernel.bound_lt_top η), fun a =>\n      calc\n        (κ ⊗ₖ η) a Set.univ ≤ κ a Set.univ * IsFiniteKernel.bound η := compProd_apply_univ_le κ η a\n        _ ≤ IsFiniteKernel.bound κ * IsFiniteKernel.bound η :=\n          mul_le_mul (measure_le_bound κ a Set.univ) le_rfl (zero_le _) (zero_le _)⟩⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.IsSFiniteKernel.compProd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel (Prod α β) γ\n⊢ ProbabilityTheory.IsSFiniteKernel (κ.compProd η)","decl":"instance IsSFiniteKernel.compProd (κ : Kernel α β) (η : Kernel (α × β) γ) :\n    IsSFiniteKernel (κ ⊗ₖ η) := by\n  by_cases h : IsSFiniteKernel κ\n  swap\n  · rw [compProd_of_not_isSFiniteKernel_left _ _ h]\n    infer_instance\n  by_cases h : IsSFiniteKernel η\n  swap\n  · rw [compProd_of_not_isSFiniteKernel_right _ _ h]\n    infer_instance\n  rw [compProd_eq_sum_compProd]\n  exact Kernel.isSFiniteKernel_sum fun n => Kernel.isSFiniteKernel_sum inferInstance\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_add_left","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nμ κ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝² : ProbabilityTheory.IsSFiniteKernel μ\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\n⊢ Eq ((HAdd.hAdd μ κ).compProd η) (HAdd.hAdd (μ.compProd η) (κ.compProd η))","decl":"lemma compProd_add_left (μ κ : Kernel α β) (η : Kernel (α × β) γ)\n    [IsSFiniteKernel μ] [IsSFiniteKernel κ] [IsSFiniteKernel η] :\n    (μ + κ) ⊗ₖ η = μ ⊗ₖ η + κ ⊗ₖ η := by ext _ _ hs; simp [compProd_apply hs]\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_add_right","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nμ : ProbabilityTheory.Kernel α β\nκ η : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝² : ProbabilityTheory.IsSFiniteKernel μ\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\n⊢ Eq (μ.compProd (HAdd.hAdd κ η)) (HAdd.hAdd (μ.compProd κ) (μ.compProd η))","decl":"lemma compProd_add_right (μ : Kernel α β) (κ η : Kernel (α × β) γ)\n    [IsSFiniteKernel μ] [IsSFiniteKernel κ] [IsSFiniteKernel η] :\n    μ ⊗ₖ (κ + η) = μ ⊗ₖ κ + μ ⊗ₖ η := by\n  ext a s hs\n  simp only [compProd_apply hs, coe_add, Pi.add_apply, Measure.coe_add]\n  rw [lintegral_add_left]\n  exact measurable_kernel_prod_mk_left' hs a\n\n"}
{"name":"ProbabilityTheory.Kernel.comapRight_compProd_id_prod","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nδ : Type u_4\nmδ : MeasurableSpace δ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\nf : δ → γ\nhf : MeasurableEmbedding f\n⊢ Eq ((κ.compProd η).comapRight ⋯) (κ.compProd (η.comapRight hf))","decl":"lemma comapRight_compProd_id_prod {δ : Type*} {mδ : MeasurableSpace δ}\n    (κ : Kernel α β) [IsSFiniteKernel κ] (η : Kernel (α × β) γ) [IsSFiniteKernel η]\n    {f : δ → γ} (hf : MeasurableEmbedding f) :\n    comapRight (κ ⊗ₖ η) (MeasurableEmbedding.id.prodMap hf) = κ ⊗ₖ (comapRight η hf) := by\n  ext a t ht\n  rw [comapRight_apply' _ _ _ ht, compProd_apply, compProd_apply ht]\n  · refine lintegral_congr fun b ↦ ?_\n    rw [comapRight_apply']\n    · congr with x\n      aesop\n    · exact measurable_prod_mk_left ht\n  · exact (MeasurableEmbedding.id.prodMap hf).measurableSet_image.mpr ht\n\n"}
{"name":"ProbabilityTheory.Kernel.map_of_not_measurable","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nf : β → γ\nhf : Not (Measurable f)\n⊢ Eq (κ.map f) 0","decl":"theorem map_of_not_measurable (κ : Kernel α β) {f : β → γ} (hf : ¬(Measurable f)) :\n    map κ f = 0 := by\n  simp [map, hf]\n\n"}
{"name":"ProbabilityTheory.Kernel.mapOfMeasurable_eq_map","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nf : β → γ\nhf : Measurable f\n⊢ Eq (κ.mapOfMeasurable f hf) (κ.map f)","decl":"@[simp] theorem mapOfMeasurable_eq_map (κ : Kernel α β) {f : β → γ} (hf : Measurable f) :\n    mapOfMeasurable κ f hf = map κ f := by\n  simp [map, hf]\n\n"}
{"name":"ProbabilityTheory.Kernel.map_apply","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nf : β → γ\nκ : ProbabilityTheory.Kernel α β\nhf : Measurable f\na : α\n⊢ Eq ((κ.map f) a) (MeasureTheory.Measure.map f (κ a))","decl":"theorem map_apply (κ : Kernel α β) (hf : Measurable f) (a : α) : map κ f a = (κ a).map f := by\n  simp only [map, hf, ↓reduceDIte, mapOfMeasurable, coe_mk]\n\n"}
{"name":"ProbabilityTheory.Kernel.map_apply'","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nf : β → γ\nκ : ProbabilityTheory.Kernel α β\nhf : Measurable f\na : α\ns : Set γ\nhs : MeasurableSet s\n⊢ Eq (((κ.map f) a) s) ((κ a) (Set.preimage f s))","decl":"theorem map_apply' (κ : Kernel α β) (hf : Measurable f) (a : α) {s : Set γ} (hs : MeasurableSet s) :\n    map κ f a s = κ a (f ⁻¹' s) := by rw [map_apply _ hf, Measure.map_apply hf hs]\n\n"}
{"name":"ProbabilityTheory.Kernel.map_zero","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nf : β → γ\n⊢ Eq (ProbabilityTheory.Kernel.map 0 f) 0","decl":"@[simp]\nlemma map_zero : Kernel.map (0 : Kernel α β) f = 0 := by\n  ext\n  by_cases hf : Measurable f\n  · simp [map_apply, hf]\n  · simp [map_of_not_measurable _ hf, map_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.map_id","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\n⊢ Eq (κ.map id) κ","decl":"@[simp]\nlemma map_id (κ : Kernel α β) : map κ id = κ := by\n  ext a\n  simp [map_apply, measurable_id]\n\n"}
{"name":"ProbabilityTheory.Kernel.map_id'","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\n⊢ Eq (κ.map fun a => a) κ","decl":"@[simp]\nlemma map_id' (κ : Kernel α β) : map κ (fun a ↦ a) = κ := map_id κ\n\n"}
{"name":"ProbabilityTheory.Kernel.lintegral_map","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nf : β → γ\nκ : ProbabilityTheory.Kernel α β\nhf : Measurable f\na : α\ng' : γ → ENNReal\nhg : Measurable g'\n⊢ Eq (MeasureTheory.lintegral ((κ.map f) a) fun b => g' b) (MeasureTheory.lintegral (κ a) fun a => g' (f a))","decl":"nonrec theorem lintegral_map (κ : Kernel α β) (hf : Measurable f) (a : α) {g' : γ → ℝ≥0∞}\n    (hg : Measurable g') : ∫⁻ b, g' b ∂map κ f a = ∫⁻ a, g' (f a) ∂κ a := by\n  rw [map_apply _ hf, lintegral_map hg hf]\n\n"}
{"name":"ProbabilityTheory.Kernel.sum_map_seq","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nf : β → γ\n⊢ Eq (ProbabilityTheory.Kernel.sum fun n => (κ.seq n).map f) (κ.map f)","decl":"theorem sum_map_seq (κ : Kernel α β) [IsSFiniteKernel κ] (f : β → γ) :\n    (Kernel.sum fun n => map (seq κ n) f) = map κ f := by\n  by_cases hf : Measurable f\n  · ext a s hs\n    rw [Kernel.sum_apply, map_apply' κ hf a hs, Measure.sum_apply _ hs, ← measure_sum_seq κ,\n      Measure.sum_apply _ (hf hs)]\n    simp_rw [map_apply' _ hf _ hs]\n  · simp [map_of_not_measurable _ hf]\n\n"}
{"name":"ProbabilityTheory.Kernel.IsMarkovKernel.map","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nf : β → γ\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsMarkovKernel κ\nhf : Measurable f\n⊢ ProbabilityTheory.IsMarkovKernel (κ.map f)","decl":"lemma IsMarkovKernel.map (κ : Kernel α β) [IsMarkovKernel κ] (hf : Measurable f) :\n    IsMarkovKernel (map κ f) :=\n  ⟨fun a => ⟨by rw [map_apply' κ hf a MeasurableSet.univ, Set.preimage_univ, measure_univ]⟩⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.IsZeroOrMarkovKernel.map","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\nf : β → γ\n⊢ ProbabilityTheory.IsZeroOrMarkovKernel (κ.map f)","decl":"instance IsZeroOrMarkovKernel.map (κ : Kernel α β) [IsZeroOrMarkovKernel κ] (f : β → γ) :\n    IsZeroOrMarkovKernel (map κ f) := by\n  by_cases hf : Measurable f\n  · rcases eq_zero_or_isMarkovKernel κ with rfl | h\n    · simp only [map_zero]; infer_instance\n    · have := IsMarkovKernel.map κ hf; infer_instance\n  · simp only [map_of_not_measurable _ hf]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsFiniteKernel.map","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\nf : β → γ\n⊢ ProbabilityTheory.IsFiniteKernel (κ.map f)","decl":"instance IsFiniteKernel.map (κ : Kernel α β) [IsFiniteKernel κ] (f : β → γ) :\n    IsFiniteKernel (map κ f) := by\n  refine ⟨⟨IsFiniteKernel.bound κ, IsFiniteKernel.bound_lt_top κ, fun a => ?_⟩⟩\n  by_cases hf : Measurable f\n  · rw [map_apply' κ hf a MeasurableSet.univ]\n    exact measure_le_bound κ a _\n  · simp [map_of_not_measurable _ hf]\n\n"}
{"name":"ProbabilityTheory.Kernel.IsSFiniteKernel.map","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nf : β → γ\n⊢ ProbabilityTheory.IsSFiniteKernel (κ.map f)","decl":"instance IsSFiniteKernel.map (κ : Kernel α β) [IsSFiniteKernel κ] (f : β → γ) :\n    IsSFiniteKernel (map κ f) :=\n  ⟨⟨fun n => Kernel.map (seq κ n) f, inferInstance, (sum_map_seq κ f).symm⟩⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.map_const","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nμ : MeasureTheory.Measure α\nf : α → β\nhf : Measurable f\n⊢ Eq ((ProbabilityTheory.Kernel.const γ μ).map f) (ProbabilityTheory.Kernel.const γ (MeasureTheory.Measure.map f μ))","decl":"@[simp]\nlemma map_const (μ : Measure α) {f : α → β} (hf : Measurable f) :\n    map (const γ μ) f = const γ (μ.map f) := by\n  ext x s hs\n  rw [map_apply' _ hf _ hs, const_apply, const_apply, Measure.map_apply hf hs]\n\n"}
{"name":"ProbabilityTheory.Kernel.coe_comap","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ng : γ → α\nhg : Measurable g\n⊢ Eq (⇑(κ.comap g hg)) (Function.comp (⇑κ) g)","decl":"@[simp, norm_cast]\nlemma coe_comap (κ : Kernel α β) (g : γ → α) (hg : Measurable g) : κ.comap g hg = κ ∘ g := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.comap_apply","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ng : γ → α\nκ : ProbabilityTheory.Kernel α β\nhg : Measurable g\nc : γ\n⊢ Eq ((κ.comap g hg) c) (κ (g c))","decl":"theorem comap_apply (κ : Kernel α β) (hg : Measurable g) (c : γ) : comap κ g hg c = κ (g c) :=\n  rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.comap_apply'","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ng : γ → α\nκ : ProbabilityTheory.Kernel α β\nhg : Measurable g\nc : γ\ns : Set β\n⊢ Eq (((κ.comap g hg) c) s) ((κ (g c)) s)","decl":"theorem comap_apply' (κ : Kernel α β) (hg : Measurable g) (c : γ) (s : Set β) :\n    comap κ g hg c s = κ (g c) s :=\n  rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.comap_zero","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ng : γ → α\nhg : Measurable g\n⊢ Eq (ProbabilityTheory.Kernel.comap 0 g hg) 0","decl":"@[simp]\nlemma comap_zero (hg : Measurable g) : Kernel.comap (0 : Kernel α β) g hg = 0 := by\n  ext; rw [Kernel.comap_apply]; simp\n\n"}
{"name":"ProbabilityTheory.Kernel.comap_id","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\n⊢ Eq (κ.comap id ⋯) κ","decl":"@[simp]\nlemma comap_id (κ : Kernel α β) : comap κ id measurable_id = κ := by ext a; rw [comap_apply]; simp\n\n"}
{"name":"ProbabilityTheory.Kernel.comap_id'","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\n⊢ Eq (κ.comap (fun a => a) ⋯) κ","decl":"@[simp]\nlemma comap_id' (κ : Kernel α β) : comap κ (fun a ↦ a) measurable_id = κ := comap_id κ\n\n"}
{"name":"ProbabilityTheory.Kernel.lintegral_comap","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ng : γ → α\nκ : ProbabilityTheory.Kernel α β\nhg : Measurable g\nc : γ\ng' : β → ENNReal\n⊢ Eq (MeasureTheory.lintegral ((κ.comap g hg) c) fun b => g' b) (MeasureTheory.lintegral (κ (g c)) fun b => g' b)","decl":"theorem lintegral_comap (κ : Kernel α β) (hg : Measurable g) (c : γ) (g' : β → ℝ≥0∞) :\n    ∫⁻ b, g' b ∂comap κ g hg c = ∫⁻ b, g' b ∂κ (g c) :=\n  rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.sum_comap_seq","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ng : γ → α\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nhg : Measurable g\n⊢ Eq (ProbabilityTheory.Kernel.sum fun n => (κ.seq n).comap g hg) (κ.comap g hg)","decl":"theorem sum_comap_seq (κ : Kernel α β) [IsSFiniteKernel κ] (hg : Measurable g) :\n    (Kernel.sum fun n => comap (seq κ n) g hg) = comap κ g hg := by\n  ext a s hs\n  rw [Kernel.sum_apply, comap_apply' κ hg a s, Measure.sum_apply _ hs, ← measure_sum_seq κ,\n    Measure.sum_apply _ hs]\n  simp_rw [comap_apply' _ hg _ s]\n\n"}
{"name":"ProbabilityTheory.Kernel.IsMarkovKernel.comap","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ng : γ → α\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsMarkovKernel κ\nhg : Measurable g\n⊢ ProbabilityTheory.IsMarkovKernel (κ.comap g hg)","decl":"instance IsMarkovKernel.comap (κ : Kernel α β) [IsMarkovKernel κ] (hg : Measurable g) :\n    IsMarkovKernel (comap κ g hg) :=\n  ⟨fun a => ⟨by rw [comap_apply' κ hg a Set.univ, measure_univ]⟩⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.IsZeroOrMarkovKernel.comap","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ng : γ → α\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\nhg : Measurable g\n⊢ ProbabilityTheory.IsZeroOrMarkovKernel (κ.comap g hg)","decl":"instance IsZeroOrMarkovKernel.comap (κ : Kernel α β) [IsZeroOrMarkovKernel κ] (hg : Measurable g) :\n    IsZeroOrMarkovKernel (comap κ g hg) := by\n  rcases eq_zero_or_isMarkovKernel κ with rfl | h\n  · simp only [comap_zero]; infer_instance\n  · have := IsMarkovKernel.comap κ hg; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsFiniteKernel.comap","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ng : γ → α\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\nhg : Measurable g\n⊢ ProbabilityTheory.IsFiniteKernel (κ.comap g hg)","decl":"instance IsFiniteKernel.comap (κ : Kernel α β) [IsFiniteKernel κ] (hg : Measurable g) :\n    IsFiniteKernel (comap κ g hg) := by\n  refine ⟨⟨IsFiniteKernel.bound κ, IsFiniteKernel.bound_lt_top κ, fun a => ?_⟩⟩\n  rw [comap_apply' κ hg a Set.univ]\n  exact measure_le_bound κ _ _\n\n"}
{"name":"ProbabilityTheory.Kernel.IsSFiniteKernel.comap","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ng : γ → α\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nhg : Measurable g\n⊢ ProbabilityTheory.IsSFiniteKernel (κ.comap g hg)","decl":"instance IsSFiniteKernel.comap (κ : Kernel α β) [IsSFiniteKernel κ] (hg : Measurable g) :\n    IsSFiniteKernel (comap κ g hg) :=\n  ⟨⟨fun n => Kernel.comap (seq κ n) g hg, inferInstance, (sum_comap_seq κ hg).symm⟩⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.comap_map_comm","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nδ : Type u_4\nmγ : MeasurableSpace γ\nmδ : MeasurableSpace δ\nκ : ProbabilityTheory.Kernel β γ\nf : α → β\ng : γ → δ\nhf : Measurable f\nhg : Measurable g\n⊢ Eq ((κ.map g).comap f hf) ((κ.comap f hf).map g)","decl":"lemma comap_map_comm (κ : Kernel β γ) {f : α → β} {g : γ → δ}\n    (hf : Measurable f) (hg : Measurable g) :\n    comap (map κ g) f hf = map (comap κ f hf) g := by\n  ext x s _\n  rw [comap_apply, map_apply _ hg, map_apply _ hg, comap_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.prodMkLeft_apply","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nca : Prod γ α\n⊢ Eq ((ProbabilityTheory.Kernel.prodMkLeft γ κ) ca) (κ ca.2)","decl":"@[simp]\ntheorem prodMkLeft_apply (κ : Kernel α β) (ca : γ × α) : prodMkLeft γ κ ca = κ ca.snd :=\n  rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.prodMkRight_apply","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nca : Prod α γ\n⊢ Eq ((ProbabilityTheory.Kernel.prodMkRight γ κ) ca) (κ ca.1)","decl":"@[simp]\ntheorem prodMkRight_apply (κ : Kernel α β) (ca : α × γ) : prodMkRight γ κ ca = κ ca.fst := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.prodMkLeft_apply'","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nca : Prod γ α\ns : Set β\n⊢ Eq (((ProbabilityTheory.Kernel.prodMkLeft γ κ) ca) s) ((κ ca.2) s)","decl":"theorem prodMkLeft_apply' (κ : Kernel α β) (ca : γ × α) (s : Set β) :\n    prodMkLeft γ κ ca s = κ ca.snd s :=\n  rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.prodMkRight_apply'","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nca : Prod α γ\ns : Set β\n⊢ Eq (((ProbabilityTheory.Kernel.prodMkRight γ κ) ca) s) ((κ ca.1) s)","decl":"theorem prodMkRight_apply' (κ : Kernel α β) (ca : α × γ) (s : Set β) :\n    prodMkRight γ κ ca s = κ ca.fst s := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.prodMkLeft_zero","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\n⊢ Eq (ProbabilityTheory.Kernel.prodMkLeft α 0) 0","decl":"@[simp]\nlemma prodMkLeft_zero : Kernel.prodMkLeft α (0 : Kernel β γ) = 0 := by\n  ext x s _; simp\n\n"}
{"name":"ProbabilityTheory.Kernel.prodMkRight_zero","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\n⊢ Eq (ProbabilityTheory.Kernel.prodMkRight α 0) 0","decl":"@[simp]\nlemma prodMkRight_zero : Kernel.prodMkRight α (0 : Kernel β γ) = 0 := by\n  ext x s _; simp\n\n"}
{"name":"ProbabilityTheory.Kernel.prodMkLeft_add","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ η : ProbabilityTheory.Kernel α β\n⊢ Eq (ProbabilityTheory.Kernel.prodMkLeft γ (HAdd.hAdd κ η)) (HAdd.hAdd (ProbabilityTheory.Kernel.prodMkLeft γ κ) (ProbabilityTheory.Kernel.prodMkLeft γ η))","decl":"@[simp]\nlemma prodMkLeft_add (κ η : Kernel α β) :\n    prodMkLeft γ (κ + η) = prodMkLeft γ κ + prodMkLeft γ η := by ext; simp\n\n"}
{"name":"ProbabilityTheory.Kernel.prodMkRight_add","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ η : ProbabilityTheory.Kernel α β\n⊢ Eq (ProbabilityTheory.Kernel.prodMkRight γ (HAdd.hAdd κ η)) (HAdd.hAdd (ProbabilityTheory.Kernel.prodMkRight γ κ) (ProbabilityTheory.Kernel.prodMkRight γ η))","decl":"@[simp]\nlemma prodMkRight_add (κ η : Kernel α β) :\n    prodMkRight γ (κ + η) = prodMkRight γ κ + prodMkRight γ η := by ext; simp\n\n"}
{"name":"ProbabilityTheory.Kernel.lintegral_prodMkLeft","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nca : Prod γ α\ng : β → ENNReal\n⊢ Eq (MeasureTheory.lintegral ((ProbabilityTheory.Kernel.prodMkLeft γ κ) ca) fun b => g b) (MeasureTheory.lintegral (κ ca.2) fun b => g b)","decl":"theorem lintegral_prodMkLeft (κ : Kernel α β) (ca : γ × α) (g : β → ℝ≥0∞) :\n    ∫⁻ b, g b ∂prodMkLeft γ κ ca = ∫⁻ b, g b ∂κ ca.snd := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.lintegral_prodMkRight","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nca : Prod α γ\ng : β → ENNReal\n⊢ Eq (MeasureTheory.lintegral ((ProbabilityTheory.Kernel.prodMkRight γ κ) ca) fun b => g b) (MeasureTheory.lintegral (κ ca.1) fun b => g b)","decl":"theorem lintegral_prodMkRight (κ : Kernel α β) (ca : α × γ) (g : β → ℝ≥0∞) :\n    ∫⁻ b, g b ∂prodMkRight γ κ ca = ∫⁻ b, g b ∂κ ca.fst := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.IsMarkovKernel.prodMkLeft","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsMarkovKernel κ\n⊢ ProbabilityTheory.IsMarkovKernel (ProbabilityTheory.Kernel.prodMkLeft γ κ)","decl":"instance IsMarkovKernel.prodMkLeft (κ : Kernel α β) [IsMarkovKernel κ] :\n    IsMarkovKernel (prodMkLeft γ κ) := by rw [Kernel.prodMkLeft]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsMarkovKernel.prodMkRight","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsMarkovKernel κ\n⊢ ProbabilityTheory.IsMarkovKernel (ProbabilityTheory.Kernel.prodMkRight γ κ)","decl":"instance IsMarkovKernel.prodMkRight (κ : Kernel α β) [IsMarkovKernel κ] :\n    IsMarkovKernel (prodMkRight γ κ) := by rw [Kernel.prodMkRight]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsZeroOrMarkovKernel.prodMkLeft","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\n⊢ ProbabilityTheory.IsZeroOrMarkovKernel (ProbabilityTheory.Kernel.prodMkLeft γ κ)","decl":"instance IsZeroOrMarkovKernel.prodMkLeft (κ : Kernel α β) [IsZeroOrMarkovKernel κ] :\n    IsZeroOrMarkovKernel (prodMkLeft γ κ) := by rw [Kernel.prodMkLeft]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsZeroOrMarkovKernel.prodMkRight","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\n⊢ ProbabilityTheory.IsZeroOrMarkovKernel (ProbabilityTheory.Kernel.prodMkRight γ κ)","decl":"instance IsZeroOrMarkovKernel.prodMkRight (κ : Kernel α β) [IsZeroOrMarkovKernel κ] :\n    IsZeroOrMarkovKernel (prodMkRight γ κ) := by rw [Kernel.prodMkRight]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsFiniteKernel.prodMkLeft","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ ProbabilityTheory.IsFiniteKernel (ProbabilityTheory.Kernel.prodMkLeft γ κ)","decl":"instance IsFiniteKernel.prodMkLeft (κ : Kernel α β) [IsFiniteKernel κ] :\n    IsFiniteKernel (prodMkLeft γ κ) := by rw [Kernel.prodMkLeft]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsFiniteKernel.prodMkRight","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ ProbabilityTheory.IsFiniteKernel (ProbabilityTheory.Kernel.prodMkRight γ κ)","decl":"instance IsFiniteKernel.prodMkRight (κ : Kernel α β) [IsFiniteKernel κ] :\n    IsFiniteKernel (prodMkRight γ κ) := by rw [Kernel.prodMkRight]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsSFiniteKernel.prodMkLeft","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\n⊢ ProbabilityTheory.IsSFiniteKernel (ProbabilityTheory.Kernel.prodMkLeft γ κ)","decl":"instance IsSFiniteKernel.prodMkLeft (κ : Kernel α β) [IsSFiniteKernel κ] :\n    IsSFiniteKernel (prodMkLeft γ κ) := by rw [Kernel.prodMkLeft]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsSFiniteKernel.prodMkRight","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\n⊢ ProbabilityTheory.IsSFiniteKernel (ProbabilityTheory.Kernel.prodMkRight γ κ)","decl":"instance IsSFiniteKernel.prodMkRight (κ : Kernel α β) [IsSFiniteKernel κ] :\n    IsSFiniteKernel (prodMkRight γ κ) := by rw [Kernel.prodMkRight]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.isSFiniteKernel_prodMkLeft_unit","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\n⊢ Iff (ProbabilityTheory.IsSFiniteKernel (ProbabilityTheory.Kernel.prodMkLeft Unit κ)) (ProbabilityTheory.IsSFiniteKernel κ)","decl":"lemma isSFiniteKernel_prodMkLeft_unit {κ : Kernel α β} :\n    IsSFiniteKernel (prodMkLeft Unit κ) ↔ IsSFiniteKernel κ := by\n  refine ⟨fun _ ↦ ?_, fun _ ↦ inferInstance⟩\n  change IsSFiniteKernel ((prodMkLeft Unit κ).comap (fun a ↦ ((), a)) (by fun_prop))\n  infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.isSFiniteKernel_prodMkRight_unit","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\n⊢ Iff (ProbabilityTheory.IsSFiniteKernel (ProbabilityTheory.Kernel.prodMkRight Unit κ)) (ProbabilityTheory.IsSFiniteKernel κ)","decl":"lemma isSFiniteKernel_prodMkRight_unit {κ : Kernel α β} :\n    IsSFiniteKernel (prodMkRight Unit κ) ↔ IsSFiniteKernel κ := by\n  refine ⟨fun _ ↦ ?_, fun _ ↦ inferInstance⟩\n  change IsSFiniteKernel ((prodMkRight Unit κ).comap (fun a ↦ (a, ())) (by fun_prop))\n  infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.map_prodMkLeft","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nδ : Type u_3\nmδ : MeasurableSpace δ\nγ : Type u_5\ninst✝ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nf : β → δ\n⊢ Eq ((ProbabilityTheory.Kernel.prodMkLeft γ κ).map f) (ProbabilityTheory.Kernel.prodMkLeft γ (κ.map f))","decl":"lemma map_prodMkLeft (γ : Type*) [MeasurableSpace γ] (κ : Kernel α β) (f : β → δ) :\n    map (prodMkLeft γ κ) f = prodMkLeft γ (map κ f) := by\n  by_cases hf : Measurable f\n  · simp only [map, hf, ↓reduceDIte]\n    rfl\n  · simp [map_of_not_measurable _ hf]\n\n"}
{"name":"ProbabilityTheory.Kernel.map_prodMkRight","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nδ : Type u_3\nmδ : MeasurableSpace δ\nκ : ProbabilityTheory.Kernel α β\nγ : Type u_5\nmγ : MeasurableSpace γ\nf : β → δ\n⊢ Eq ((ProbabilityTheory.Kernel.prodMkRight γ κ).map f) (ProbabilityTheory.Kernel.prodMkRight γ (κ.map f))","decl":"lemma map_prodMkRight (κ : Kernel α β) (γ : Type*) {mγ : MeasurableSpace γ} (f : β → δ) :\n    map (prodMkRight γ κ) f = prodMkRight γ (map κ f) := by\n  by_cases hf : Measurable f\n  · simp only [map, hf, ↓reduceDIte]\n    rfl\n  · simp [map_of_not_measurable _ hf]\n\n"}
{"name":"ProbabilityTheory.Kernel.swapLeft_apply","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\na : Prod β α\n⊢ Eq (κ.swapLeft a) (κ a.swap)","decl":"@[simp]\ntheorem swapLeft_apply (κ : Kernel (α × β) γ) (a : β × α) : swapLeft κ a = κ a.swap := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.swapLeft_apply'","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\na : Prod β α\ns : Set γ\n⊢ Eq ((κ.swapLeft a) s) ((κ a.swap) s)","decl":"theorem swapLeft_apply' (κ : Kernel (α × β) γ) (a : β × α) (s : Set γ) :\n    swapLeft κ a s = κ a.swap s := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.lintegral_swapLeft","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\na : Prod β α\ng : γ → ENNReal\n⊢ Eq (MeasureTheory.lintegral (κ.swapLeft a) fun c => g c) (MeasureTheory.lintegral (κ a.swap) fun c => g c)","decl":"theorem lintegral_swapLeft (κ : Kernel (α × β) γ) (a : β × α) (g : γ → ℝ≥0∞) :\n    ∫⁻ c, g c ∂swapLeft κ a = ∫⁻ c, g c ∂κ a.swap := by\n  rw [swapLeft_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.IsMarkovKernel.swapLeft","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsMarkovKernel κ\n⊢ ProbabilityTheory.IsMarkovKernel κ.swapLeft","decl":"instance IsMarkovKernel.swapLeft (κ : Kernel (α × β) γ) [IsMarkovKernel κ] :\n    IsMarkovKernel (swapLeft κ) := by rw [Kernel.swapLeft]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsFiniteKernel.swapLeft","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ ProbabilityTheory.IsFiniteKernel κ.swapLeft","decl":"instance IsFiniteKernel.swapLeft (κ : Kernel (α × β) γ) [IsFiniteKernel κ] :\n    IsFiniteKernel (swapLeft κ) := by rw [Kernel.swapLeft]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsSFiniteKernel.swapLeft","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\n⊢ ProbabilityTheory.IsSFiniteKernel κ.swapLeft","decl":"instance IsSFiniteKernel.swapLeft (κ : Kernel (α × β) γ) [IsSFiniteKernel κ] :\n    IsSFiniteKernel (swapLeft κ) := by rw [Kernel.swapLeft]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.swapLeft_prodMkLeft","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nγ : Type u_5\nx✝ : MeasurableSpace γ\n⊢ Eq (ProbabilityTheory.Kernel.prodMkLeft γ κ).swapLeft (ProbabilityTheory.Kernel.prodMkRight γ κ)","decl":"@[simp] lemma swapLeft_prodMkLeft (κ : Kernel α β) (γ : Type*) {_ : MeasurableSpace γ} :\n    swapLeft (prodMkLeft γ κ) = prodMkRight γ κ := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.swapLeft_prodMkRight","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nγ : Type u_5\nx✝ : MeasurableSpace γ\n⊢ Eq (ProbabilityTheory.Kernel.prodMkRight γ κ).swapLeft (ProbabilityTheory.Kernel.prodMkLeft γ κ)","decl":"@[simp] lemma swapLeft_prodMkRight (κ : Kernel α β) (γ : Type*) {_ : MeasurableSpace γ} :\n    swapLeft (prodMkRight γ κ) = prodMkLeft γ κ := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.swapRight_eq","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\n⊢ Eq κ.swapRight (κ.map Prod.swap)","decl":"lemma swapRight_eq (κ : Kernel α (β × γ)) : swapRight κ = map κ Prod.swap := by\n  simp [swapRight]\n\n"}
{"name":"ProbabilityTheory.Kernel.swapRight_apply","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\na : α\n⊢ Eq (κ.swapRight a) (MeasureTheory.Measure.map Prod.swap (κ a))","decl":"theorem swapRight_apply (κ : Kernel α (β × γ)) (a : α) : swapRight κ a = (κ a).map Prod.swap :=\n  rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.swapRight_apply'","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\na : α\ns : Set (Prod γ β)\nhs : MeasurableSet s\n⊢ Eq ((κ.swapRight a) s) ((κ a) (setOf fun p => Membership.mem s p.swap))","decl":"theorem swapRight_apply' (κ : Kernel α (β × γ)) (a : α) {s : Set (γ × β)} (hs : MeasurableSet s) :\n    swapRight κ a s = κ a {p | p.swap ∈ s} := by\n  rw [swapRight_apply, Measure.map_apply measurable_swap hs]; rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.lintegral_swapRight","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\na : α\ng : Prod γ β → ENNReal\nhg : Measurable g\n⊢ Eq (MeasureTheory.lintegral (κ.swapRight a) fun c => g c) (MeasureTheory.lintegral (κ a) fun bc => g bc.swap)","decl":"theorem lintegral_swapRight (κ : Kernel α (β × γ)) (a : α) {g : γ × β → ℝ≥0∞} (hg : Measurable g) :\n    ∫⁻ c, g c ∂swapRight κ a = ∫⁻ bc : β × γ, g bc.swap ∂κ a := by\n  rw [swapRight_eq, lintegral_map _ measurable_swap a hg]\n\n"}
{"name":"ProbabilityTheory.Kernel.IsMarkovKernel.swapRight","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\ninst✝ : ProbabilityTheory.IsMarkovKernel κ\n⊢ ProbabilityTheory.IsMarkovKernel κ.swapRight","decl":"instance IsMarkovKernel.swapRight (κ : Kernel α (β × γ)) [IsMarkovKernel κ] :\n    IsMarkovKernel (swapRight κ) := by\n  rw [Kernel.swapRight_eq]; exact IsMarkovKernel.map _ measurable_swap\n\n"}
{"name":"ProbabilityTheory.Kernel.IsZeroOrMarkovKernel.swapRight","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\n⊢ ProbabilityTheory.IsZeroOrMarkovKernel κ.swapRight","decl":"instance IsZeroOrMarkovKernel.swapRight (κ : Kernel α (β × γ)) [IsZeroOrMarkovKernel κ] :\n    IsZeroOrMarkovKernel (swapRight κ) := by rw [Kernel.swapRight_eq]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsFiniteKernel.swapRight","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ ProbabilityTheory.IsFiniteKernel κ.swapRight","decl":"instance IsFiniteKernel.swapRight (κ : Kernel α (β × γ)) [IsFiniteKernel κ] :\n    IsFiniteKernel (swapRight κ) := by rw [Kernel.swapRight_eq]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsSFiniteKernel.swapRight","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\n⊢ ProbabilityTheory.IsSFiniteKernel κ.swapRight","decl":"instance IsSFiniteKernel.swapRight (κ : Kernel α (β × γ)) [IsSFiniteKernel κ] :\n    IsSFiniteKernel (swapRight κ) := by rw [Kernel.swapRight_eq]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.fst_eq","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\n⊢ Eq κ.fst (κ.map Prod.fst)","decl":"theorem fst_eq (κ : Kernel α (β × γ)) : fst κ = map κ Prod.fst := by simp [fst]\n\n"}
{"name":"ProbabilityTheory.Kernel.fst_apply","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\na : α\n⊢ Eq (κ.fst a) (MeasureTheory.Measure.map Prod.fst (κ a))","decl":"theorem fst_apply (κ : Kernel α (β × γ)) (a : α) : fst κ a = (κ a).map Prod.fst :=\n  rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.fst_apply'","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\na : α\ns : Set β\nhs : MeasurableSet s\n⊢ Eq ((κ.fst a) s) ((κ a) (setOf fun p => Membership.mem s p.1))","decl":"theorem fst_apply' (κ : Kernel α (β × γ)) (a : α) {s : Set β} (hs : MeasurableSet s) :\n    fst κ a s = κ a {p | p.1 ∈ s} := by rw [fst_apply, Measure.map_apply measurable_fst hs]; rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.fst_zero","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\n⊢ Eq (ProbabilityTheory.Kernel.fst 0) 0","decl":"@[simp]\nlemma fst_zero : fst (0 : Kernel α (β × γ)) = 0 := by simp [fst]\n\n"}
{"name":"ProbabilityTheory.Kernel.lintegral_fst","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\na : α\ng : β → ENNReal\nhg : Measurable g\n⊢ Eq (MeasureTheory.lintegral (κ.fst a) fun c => g c) (MeasureTheory.lintegral (κ a) fun bc => g bc.1)","decl":"theorem lintegral_fst (κ : Kernel α (β × γ)) (a : α) {g : β → ℝ≥0∞} (hg : Measurable g) :\n    ∫⁻ c, g c ∂fst κ a = ∫⁻ bc : β × γ, g bc.fst ∂κ a := by\n  rw [fst_eq, lintegral_map _ measurable_fst a hg]\n\n"}
{"name":"ProbabilityTheory.Kernel.IsMarkovKernel.fst","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\ninst✝ : ProbabilityTheory.IsMarkovKernel κ\n⊢ ProbabilityTheory.IsMarkovKernel κ.fst","decl":"instance IsMarkovKernel.fst (κ : Kernel α (β × γ)) [IsMarkovKernel κ] : IsMarkovKernel (fst κ) := by\n  rw [Kernel.fst_eq]; exact IsMarkovKernel.map _ measurable_fst\n\n"}
{"name":"ProbabilityTheory.Kernel.IsZeroOrMarkovKernel.fst","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\n⊢ ProbabilityTheory.IsZeroOrMarkovKernel κ.fst","decl":"instance IsZeroOrMarkovKernel.fst (κ : Kernel α (β × γ)) [IsZeroOrMarkovKernel κ] :\n    IsZeroOrMarkovKernel (fst κ) := by\n  rw [Kernel.fst_eq]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsFiniteKernel.fst","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ ProbabilityTheory.IsFiniteKernel κ.fst","decl":"instance IsFiniteKernel.fst (κ : Kernel α (β × γ)) [IsFiniteKernel κ] : IsFiniteKernel (fst κ) := by\n  rw [Kernel.fst_eq]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsSFiniteKernel.fst","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\n⊢ ProbabilityTheory.IsSFiniteKernel κ.fst","decl":"instance IsSFiniteKernel.fst (κ : Kernel α (β × γ)) [IsSFiniteKernel κ] :\n    IsSFiniteKernel (fst κ) := by rw [Kernel.fst_eq]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.isFiniteKernel_of_isFiniteKernel_fst","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\nh : ProbabilityTheory.IsFiniteKernel κ.fst\n⊢ ProbabilityTheory.IsFiniteKernel κ","decl":"instance (priority := 100) isFiniteKernel_of_isFiniteKernel_fst {κ : Kernel α (β × γ)}\n    [h : IsFiniteKernel (fst κ)] :\n    IsFiniteKernel κ := by\n  refine ⟨h.bound, h.bound_lt_top, fun a ↦ le_trans ?_ (measure_le_bound (fst κ) a Set.univ)⟩\n  rw [fst_apply' _ _ MeasurableSet.univ]\n  simp\n\n"}
{"name":"ProbabilityTheory.Kernel.fst_map_prod","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nδ : Type u_3\nmδ : MeasurableSpace δ\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nf : β → γ\ng : β → δ\nhg : Measurable g\n⊢ Eq (κ.map fun x => { fst := f x, snd := g x }).fst (κ.map f)","decl":"lemma fst_map_prod (κ : Kernel α β) {f : β → γ} {g : β → δ} (hg : Measurable g) :\n    fst (map κ (fun x ↦ (f x, g x))) = map κ f := by\n  by_cases hf : Measurable f\n  · ext x s hs\n    rw [fst_apply' _ _ hs, map_apply' _ (hf.prod hg) _, map_apply' _ hf _ hs]\n    · simp only [Set.preimage, Set.mem_setOf]\n    · exact measurable_fst hs\n  · have : ¬ Measurable (fun x ↦ (f x, g x)) := by\n      contrapose! hf; exact hf.fst\n    simp [map_of_not_measurable _ hf, map_of_not_measurable _ this]\n\n"}
{"name":"ProbabilityTheory.Kernel.fst_map_id_prod","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nγ : Type u_5\nmγ : MeasurableSpace γ\nf : β → γ\nhf : Measurable f\n⊢ Eq (κ.map fun a => { fst := a, snd := f a }).fst κ","decl":"lemma fst_map_id_prod (κ : Kernel α β) {γ : Type*} {mγ : MeasurableSpace γ}\n    {f : β → γ} (hf : Measurable f) :\n    fst (map κ (fun a ↦ (a, f a))) = κ := by\n  rw [fst_map_prod _ hf, Kernel.map_id']\n\n"}
{"name":"ProbabilityTheory.Kernel.fst_compProd_apply","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\nx : α\ns : Set β\nhs : MeasurableSet s\n⊢ Eq (((κ.compProd η).fst x) s) (MeasureTheory.lintegral (κ x) fun b => s.indicator (fun b => (η { fst := x, snd := b }) Set.univ) b)","decl":"/-- If `η` is a Markov kernel, use instead `fst_compProd` to get `(κ ⊗ₖ η).fst = κ`. -/\nlemma fst_compProd_apply (κ : Kernel α β) (η : Kernel (α × β) γ)\n    [IsSFiniteKernel κ] [IsSFiniteKernel η] (x : α) {s : Set β} (hs : MeasurableSet s) :\n    (κ ⊗ₖ η).fst x s = ∫⁻ b, s.indicator (fun b ↦ η (x, b) Set.univ) b ∂(κ x) := by\n  rw [Kernel.fst_apply' _ _ hs, Kernel.compProd_apply]\n  swap; · exact measurable_fst hs\n  have h_eq b : η (x, b) {c | b ∈ s} = s.indicator (fun b ↦ η (x, b) Set.univ) b := by\n    by_cases hb : b ∈ s <;> simp [hb]\n  simp_rw [Set.mem_setOf_eq, h_eq]\n\n"}
{"name":"ProbabilityTheory.Kernel.fst_compProd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\ninst✝ : ProbabilityTheory.IsMarkovKernel η\n⊢ Eq (κ.compProd η).fst κ","decl":"@[simp]\nlemma fst_compProd (κ : Kernel α β) (η : Kernel (α × β) γ) [IsSFiniteKernel κ] [IsMarkovKernel η] :\n    fst (κ ⊗ₖ η) = κ := by\n  ext x s hs; simp [fst_compProd_apply, hs]\n\n"}
{"name":"ProbabilityTheory.Kernel.fst_prodMkLeft","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nδ : Type u_5\ninst✝ : MeasurableSpace δ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\n⊢ Eq (ProbabilityTheory.Kernel.prodMkLeft δ κ).fst (ProbabilityTheory.Kernel.prodMkLeft δ κ.fst)","decl":"lemma fst_prodMkLeft (δ : Type*) [MeasurableSpace δ] (κ : Kernel α (β × γ)) :\n    fst (prodMkLeft δ κ) = prodMkLeft δ (fst κ) := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.fst_prodMkRight","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\nδ : Type u_5\ninst✝ : MeasurableSpace δ\n⊢ Eq (ProbabilityTheory.Kernel.prodMkRight δ κ).fst (ProbabilityTheory.Kernel.prodMkRight δ κ.fst)","decl":"lemma fst_prodMkRight (κ : Kernel α (β × γ)) (δ : Type*) [MeasurableSpace δ] :\n    fst (prodMkRight δ κ) = prodMkRight δ (fst κ) := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.snd_eq","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\n⊢ Eq κ.snd (κ.map Prod.snd)","decl":"theorem snd_eq (κ : Kernel α (β × γ)) : snd κ = map κ Prod.snd := by simp [snd]\n\n"}
{"name":"ProbabilityTheory.Kernel.snd_apply","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\na : α\n⊢ Eq (κ.snd a) (MeasureTheory.Measure.map Prod.snd (κ a))","decl":"theorem snd_apply (κ : Kernel α (β × γ)) (a : α) : snd κ a = (κ a).map Prod.snd :=\n  rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.snd_apply'","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\na : α\ns : Set γ\nhs : MeasurableSet s\n⊢ Eq ((κ.snd a) s) ((κ a) (setOf fun p => Membership.mem s p.2))","decl":"theorem snd_apply' (κ : Kernel α (β × γ)) (a : α) {s : Set γ} (hs : MeasurableSet s) :\n    snd κ a s = κ a {p | p.2 ∈ s} := by rw [snd_apply, Measure.map_apply measurable_snd hs]; rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.snd_zero","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\n⊢ Eq (ProbabilityTheory.Kernel.snd 0) 0","decl":"@[simp]\nlemma snd_zero : snd (0 : Kernel α (β × γ)) = 0 := by simp [snd]\n\n"}
{"name":"ProbabilityTheory.Kernel.lintegral_snd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\na : α\ng : γ → ENNReal\nhg : Measurable g\n⊢ Eq (MeasureTheory.lintegral (κ.snd a) fun c => g c) (MeasureTheory.lintegral (κ a) fun bc => g bc.2)","decl":"theorem lintegral_snd (κ : Kernel α (β × γ)) (a : α) {g : γ → ℝ≥0∞} (hg : Measurable g) :\n    ∫⁻ c, g c ∂snd κ a = ∫⁻ bc : β × γ, g bc.snd ∂κ a := by\n  rw [snd_eq, lintegral_map _ measurable_snd a hg]\n\n"}
{"name":"ProbabilityTheory.Kernel.IsMarkovKernel.snd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\ninst✝ : ProbabilityTheory.IsMarkovKernel κ\n⊢ ProbabilityTheory.IsMarkovKernel κ.snd","decl":"instance IsMarkovKernel.snd (κ : Kernel α (β × γ)) [IsMarkovKernel κ] : IsMarkovKernel (snd κ) := by\n  rw [Kernel.snd_eq]; exact IsMarkovKernel.map _ measurable_snd\n\n"}
{"name":"ProbabilityTheory.Kernel.IsZeroOrMarkovKernel.snd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\n⊢ ProbabilityTheory.IsZeroOrMarkovKernel κ.snd","decl":"instance IsZeroOrMarkovKernel.snd (κ : Kernel α (β × γ)) [IsZeroOrMarkovKernel κ] :\n    IsZeroOrMarkovKernel (snd κ) := by\n  rw [Kernel.snd_eq]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsFiniteKernel.snd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ ProbabilityTheory.IsFiniteKernel κ.snd","decl":"instance IsFiniteKernel.snd (κ : Kernel α (β × γ)) [IsFiniteKernel κ] : IsFiniteKernel (snd κ) := by\n  rw [Kernel.snd_eq]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsSFiniteKernel.snd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\n⊢ ProbabilityTheory.IsSFiniteKernel κ.snd","decl":"instance IsSFiniteKernel.snd (κ : Kernel α (β × γ)) [IsSFiniteKernel κ] :\n    IsSFiniteKernel (snd κ) := by rw [Kernel.snd_eq]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.isFiniteKernel_of_isFiniteKernel_snd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\nh : ProbabilityTheory.IsFiniteKernel κ.snd\n⊢ ProbabilityTheory.IsFiniteKernel κ","decl":"instance (priority := 100) isFiniteKernel_of_isFiniteKernel_snd {κ : Kernel α (β × γ)}\n    [h : IsFiniteKernel (snd κ)] :\n    IsFiniteKernel κ := by\n  refine ⟨h.bound, h.bound_lt_top, fun a ↦ le_trans ?_ (measure_le_bound (snd κ) a Set.univ)⟩\n  rw [snd_apply' _ _ MeasurableSet.univ]\n  simp\n\n"}
{"name":"ProbabilityTheory.Kernel.snd_map_prod","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nδ : Type u_3\nmδ : MeasurableSpace δ\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nf : β → γ\ng : β → δ\nhf : Measurable f\n⊢ Eq (κ.map fun x => { fst := f x, snd := g x }).snd (κ.map g)","decl":"lemma snd_map_prod (κ : Kernel α β) {f : β → γ} {g : β → δ} (hf : Measurable f) :\n    snd (map κ (fun x ↦ (f x, g x))) = map κ g := by\n  by_cases hg : Measurable g\n  · ext x s hs\n    rw [snd_apply' _ _ hs, map_apply' _ (hf.prod hg), map_apply' _ hg _ hs]\n    · simp only [Set.preimage, Set.mem_setOf]\n    · exact measurable_snd hs\n  · have : ¬ Measurable (fun x ↦ (f x, g x)) := by\n      contrapose! hg; exact hg.snd\n    simp [map_of_not_measurable _ hg, map_of_not_measurable _ this]\n\n"}
{"name":"ProbabilityTheory.Kernel.snd_map_prod_id","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nγ : Type u_5\nmγ : MeasurableSpace γ\nf : β → γ\nhf : Measurable f\n⊢ Eq (κ.map fun a => { fst := f a, snd := a }).snd κ","decl":"lemma snd_map_prod_id (κ : Kernel α β) {γ : Type*} {mγ : MeasurableSpace γ}\n    {f : β → γ} (hf : Measurable f) :\n    snd (map κ (fun a ↦ (f a, a))) = κ := by\n  rw [snd_map_prod _ hf, Kernel.map_id']\n\n"}
{"name":"ProbabilityTheory.Kernel.snd_prodMkLeft","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nδ : Type u_5\ninst✝ : MeasurableSpace δ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\n⊢ Eq (ProbabilityTheory.Kernel.prodMkLeft δ κ).snd (ProbabilityTheory.Kernel.prodMkLeft δ κ.snd)","decl":"lemma snd_prodMkLeft (δ : Type*) [MeasurableSpace δ] (κ : Kernel α (β × γ)) :\n    snd (prodMkLeft δ κ) = prodMkLeft δ (snd κ) := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.snd_prodMkRight","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\nδ : Type u_5\ninst✝ : MeasurableSpace δ\n⊢ Eq (ProbabilityTheory.Kernel.prodMkRight δ κ).snd (ProbabilityTheory.Kernel.prodMkRight δ κ.snd)","decl":"lemma snd_prodMkRight (κ : Kernel α (β × γ)) (δ : Type*) [MeasurableSpace δ] :\n    snd (prodMkRight δ κ) = prodMkRight δ (snd κ) := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.fst_swapRight","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\n⊢ Eq κ.swapRight.fst κ.snd","decl":"@[simp]\nlemma fst_swapRight (κ : Kernel α (β × γ)) : fst (swapRight κ) = snd κ := by\n  ext a s hs\n  rw [fst_apply' _ _ hs, swapRight_apply', snd_apply' _ _ hs]\n  · rfl\n  · exact measurable_fst hs\n\n"}
{"name":"ProbabilityTheory.Kernel.snd_swapRight","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_4\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\n⊢ Eq κ.swapRight.snd κ.fst","decl":"@[simp]\nlemma snd_swapRight (κ : Kernel α (β × γ)) : snd (swapRight κ) = fst κ := by\n  ext a s hs\n  rw [snd_apply' _ _ hs, swapRight_apply', fst_apply' _ _ hs]\n  · rfl\n  · exact measurable_snd hs\n\n"}
{"name":"ProbabilityTheory.Kernel.sectL_apply","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\nb : β\na : α\n⊢ Eq ((κ.sectL b) a) (κ { fst := a, snd := b })","decl":"@[simp] theorem sectL_apply (κ : Kernel (α × β) γ) (b : β) (a : α) : sectL κ b a = κ (a, b) := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.sectL_zero","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nb : β\n⊢ Eq (ProbabilityTheory.Kernel.sectL 0 b) 0","decl":"@[simp] lemma sectL_zero (b : β) : sectL (0 : Kernel (α × β) γ) b = 0 := by simp [sectL]\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsMarkovKernelSectLOfProd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\nb : β\ninst✝ : ProbabilityTheory.IsMarkovKernel κ\n⊢ ProbabilityTheory.IsMarkovKernel (κ.sectL b)","decl":"instance (κ : Kernel (α × β) γ) (b : β) [IsMarkovKernel κ] : IsMarkovKernel (sectL κ b) := by\n  rw [sectL]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsZeroOrMarkovKernelSectLOfProd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\nb : β\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\n⊢ ProbabilityTheory.IsZeroOrMarkovKernel (κ.sectL b)","decl":"instance (κ : Kernel (α × β) γ) (b : β) [IsZeroOrMarkovKernel κ] :\n    IsZeroOrMarkovKernel (sectL κ b) := by\n  rw [sectL]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsFiniteKernelSectLOfProd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\nb : β\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ ProbabilityTheory.IsFiniteKernel (κ.sectL b)","decl":"instance (κ : Kernel (α × β) γ) (b : β) [IsFiniteKernel κ] : IsFiniteKernel (sectL κ b) := by\n  rw [sectL]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsSFiniteKernelSectLOfProd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\nb : β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\n⊢ ProbabilityTheory.IsSFiniteKernel (κ.sectL b)","decl":"instance (κ : Kernel (α × β) γ) (b : β) [IsSFiniteKernel κ] : IsSFiniteKernel (sectL κ b) := by\n  rw [sectL]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.instNeZeroMeasureCoeSectLOfProdMk","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\na : α\nb : β\ninst✝ : NeZero (κ { fst := a, snd := b })\n⊢ NeZero ((κ.sectL b) a)","decl":"instance (κ : Kernel (α × β) γ) (a : α) (b : β) [NeZero (κ (a, b))] : NeZero ((sectL κ b) a) := by\n  rw [sectL_apply]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsMarkovKernelProdOfSectL","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ∀ (b : β), ProbabilityTheory.IsMarkovKernel (κ.sectL b)\n⊢ ProbabilityTheory.IsMarkovKernel κ","decl":"instance (priority := 100) {κ : Kernel (α × β) γ} [∀ b, IsMarkovKernel (sectL κ b)] :\n    IsMarkovKernel κ := by\n  refine ⟨fun _ ↦ ⟨?_⟩⟩\n  rw [← sectL_apply, measure_univ]\n\n--I'm not sure this lemma is actually useful\n"}
{"name":"ProbabilityTheory.Kernel.comap_sectL","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nδ : Type u_4\nmγ : MeasurableSpace γ\nmδ : MeasurableSpace δ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\nb : β\nf : δ → α\nhf : Measurable f\n⊢ Eq ((κ.sectL b).comap f hf) (κ.comap (fun d => { fst := f d, snd := b }) ⋯)","decl":"lemma comap_sectL (κ : Kernel (α × β) γ) (b : β) {f : δ → α} (hf : Measurable f) :\n    comap (sectL κ b) f hf = comap κ (fun d ↦ (f d, b)) (hf.prod_mk measurable_const) := by\n  ext d s\n  rw [comap_apply, sectL_apply, comap_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.sectL_prodMkLeft","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"β : Type u_2\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nα : Type u_5\ninst✝ : MeasurableSpace α\nκ : ProbabilityTheory.Kernel β γ\na : α\nb : β\n⊢ Eq (((ProbabilityTheory.Kernel.prodMkLeft α κ).sectL b) a) (κ b)","decl":"@[simp]\nlemma sectL_prodMkLeft (α : Type*) [MeasurableSpace α] (κ : Kernel β γ) (a : α) {b : β} :\n    sectL (prodMkLeft α κ) b a = κ b := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.sectL_prodMkRight","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nγ : Type u_3\nmγ : MeasurableSpace γ\nβ : Type u_5\ninst✝ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α γ\nb : β\n⊢ Eq ((ProbabilityTheory.Kernel.prodMkRight β κ).sectL b) κ","decl":"@[simp]\nlemma sectL_prodMkRight (β : Type*) [MeasurableSpace β] (κ : Kernel α γ) (b : β) :\n    sectL (prodMkRight β κ) b = κ := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.sectR_apply","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\nb : β\na : α\n⊢ Eq ((κ.sectR a) b) (κ { fst := a, snd := b })","decl":"@[simp] theorem sectR_apply (κ : Kernel (α × β) γ) (b : β) (a : α) : sectR κ a b = κ (a, b) := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.sectR_zero","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\na : α\n⊢ Eq (ProbabilityTheory.Kernel.sectR 0 a) 0","decl":"@[simp] lemma sectR_zero (a : α) : sectR (0 : Kernel (α × β) γ) a = 0 := by simp [sectR]\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsMarkovKernelSectROfProd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\na : α\ninst✝ : ProbabilityTheory.IsMarkovKernel κ\n⊢ ProbabilityTheory.IsMarkovKernel (κ.sectR a)","decl":"instance (κ : Kernel (α × β) γ) (a : α) [IsMarkovKernel κ] : IsMarkovKernel (sectR κ a) := by\n  rw [sectR]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsZeroOrMarkovKernelSectROfProd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\na : α\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\n⊢ ProbabilityTheory.IsZeroOrMarkovKernel (κ.sectR a)","decl":"instance (κ : Kernel (α × β) γ) (a : α) [IsZeroOrMarkovKernel κ] :\n    IsZeroOrMarkovKernel (sectR κ a) := by\n  rw [sectR]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsFiniteKernelSectROfProd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\na : α\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ ProbabilityTheory.IsFiniteKernel (κ.sectR a)","decl":"instance (κ : Kernel (α × β) γ) (a : α) [IsFiniteKernel κ] : IsFiniteKernel (sectR κ a) := by\n  rw [sectR]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsSFiniteKernelSectROfProd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\na : α\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\n⊢ ProbabilityTheory.IsSFiniteKernel (κ.sectR a)","decl":"instance (κ : Kernel (α × β) γ) (a : α) [IsSFiniteKernel κ] : IsSFiniteKernel (sectR κ a) := by\n  rw [sectR]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.instNeZeroMeasureCoeSectROfProdMk","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\na : α\nb : β\ninst✝ : NeZero (κ { fst := a, snd := b })\n⊢ NeZero ((κ.sectR a) b)","decl":"instance (κ : Kernel (α × β) γ) (a : α) (b : β) [NeZero (κ (a, b))] : NeZero ((sectR κ a) b) := by\n  rw [sectR_apply]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.instIsMarkovKernelProdOfSectR","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ∀ (b : α), ProbabilityTheory.IsMarkovKernel (κ.sectR b)\n⊢ ProbabilityTheory.IsMarkovKernel κ","decl":"instance (priority := 100) {κ : Kernel (α × β) γ} [∀ b, IsMarkovKernel (sectR κ b)] :\n    IsMarkovKernel κ := by\n  refine ⟨fun _ ↦ ⟨?_⟩⟩\n  rw [← sectR_apply, measure_univ]\n\n--I'm not sure this lemma is actually useful\n"}
{"name":"ProbabilityTheory.Kernel.comap_sectR","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nδ : Type u_4\nmγ : MeasurableSpace γ\nmδ : MeasurableSpace δ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\na : α\nf : δ → β\nhf : Measurable f\n⊢ Eq ((κ.sectR a).comap f hf) (κ.comap (fun d => { fst := a, snd := f d }) ⋯)","decl":"lemma comap_sectR (κ : Kernel (α × β) γ) (a : α) {f : δ → β} (hf : Measurable f) :\n    comap (sectR κ a) f hf = comap κ (fun d ↦ (a, f d)) (measurable_const.prod_mk hf) := by\n  ext d s\n  rw [comap_apply, sectR_apply, comap_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.sectR_prodMkLeft","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"β : Type u_2\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nα : Type u_5\ninst✝ : MeasurableSpace α\nκ : ProbabilityTheory.Kernel β γ\na : α\n⊢ Eq ((ProbabilityTheory.Kernel.prodMkLeft α κ).sectR a) κ","decl":"@[simp]\nlemma sectR_prodMkLeft (α : Type*) [MeasurableSpace α] (κ : Kernel β γ) (a : α) :\n    sectR (prodMkLeft α κ) a = κ := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.sectR_prodMkRight","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nγ : Type u_3\nmγ : MeasurableSpace γ\nβ : Type u_5\ninst✝ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α γ\nb : β\na : α\n⊢ Eq (((ProbabilityTheory.Kernel.prodMkRight β κ).sectR a) b) (κ a)","decl":"@[simp]\nlemma sectR_prodMkRight (β : Type*) [MeasurableSpace β] (κ : Kernel α γ) (b : β) {a : α} :\n    sectR (prodMkRight β κ) a b = κ a := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.sectL_swapRight","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\n⊢ Eq κ.swapLeft.sectL κ.sectR","decl":"@[simp] lemma sectL_swapRight (κ : Kernel (α × β) γ) : sectL (swapLeft κ) = sectR κ := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.sectR_swapRight","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel (Prod α β) γ\n⊢ Eq κ.swapLeft.sectR κ.sectL","decl":"@[simp] lemma sectR_swapRight (κ : Kernel (α × β) γ) : sectR (swapLeft κ) = sectL κ := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.comp_apply","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nη : ProbabilityTheory.Kernel β γ\nκ : ProbabilityTheory.Kernel α β\na : α\n⊢ Eq ((η.comp κ) a) ((κ a).bind ⇑η)","decl":"theorem comp_apply (η : Kernel β γ) (κ : Kernel α β) (a : α) : (η ∘ₖ κ) a = (κ a).bind η :=\n  rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.comp_apply'","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nη : ProbabilityTheory.Kernel β γ\nκ : ProbabilityTheory.Kernel α β\na : α\ns : Set γ\nhs : MeasurableSet s\n⊢ Eq (((η.comp κ) a) s) (MeasureTheory.lintegral (κ a) fun b => (η b) s)","decl":"theorem comp_apply' (η : Kernel β γ) (κ : Kernel α β) (a : α) {s : Set γ} (hs : MeasurableSet s) :\n    (η ∘ₖ κ) a s = ∫⁻ b, η b s ∂κ a := by\n  rw [comp_apply, Measure.bind_apply hs (Kernel.measurable _)]\n\n"}
{"name":"ProbabilityTheory.Kernel.zero_comp","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\n⊢ Eq (ProbabilityTheory.Kernel.comp 0 κ) 0","decl":"@[simp] lemma zero_comp (κ : Kernel α β) : (0 : Kernel β γ) ∘ₖ κ = 0 := by ext; simp [comp_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.comp_zero","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel β γ\n⊢ Eq (κ.comp 0) 0","decl":"@[simp] lemma comp_zero (κ : Kernel β γ) : κ ∘ₖ (0 : Kernel α β) = 0 := by ext; simp [comp_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.comp_eq_snd_compProd","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nη : ProbabilityTheory.Kernel β γ\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel η\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\n⊢ Eq (η.comp κ) (κ.compProd (ProbabilityTheory.Kernel.prodMkLeft α η)).snd","decl":"theorem comp_eq_snd_compProd (η : Kernel β γ) [IsSFiniteKernel η] (κ : Kernel α β)\n    [IsSFiniteKernel κ] : η ∘ₖ κ = snd (κ ⊗ₖ prodMkLeft α η) := by\n  ext a s hs\n  rw [comp_apply' _ _ _ hs, snd_apply' _ _ hs, compProd_apply]\n  swap\n  · exact measurable_snd hs\n  simp only [Set.mem_setOf_eq, Set.setOf_mem_eq, prodMkLeft_apply' _ _ s]\n\n"}
{"name":"ProbabilityTheory.Kernel.lintegral_comp","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nη : ProbabilityTheory.Kernel β γ\nκ : ProbabilityTheory.Kernel α β\na : α\ng : γ → ENNReal\nhg : Measurable g\n⊢ Eq (MeasureTheory.lintegral ((η.comp κ) a) fun c => g c) (MeasureTheory.lintegral (κ a) fun b => MeasureTheory.lintegral (η b) fun c => g c)","decl":"theorem lintegral_comp (η : Kernel β γ) (κ : Kernel α β) (a : α) {g : γ → ℝ≥0∞}\n    (hg : Measurable g) : ∫⁻ c, g c ∂(η ∘ₖ κ) a = ∫⁻ b, ∫⁻ c, g c ∂η b ∂κ a := by\n  rw [comp_apply, Measure.lintegral_bind (Kernel.measurable _) hg]\n\n"}
{"name":"ProbabilityTheory.Kernel.IsMarkovKernel.comp","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nη : ProbabilityTheory.Kernel β γ\ninst✝¹ : ProbabilityTheory.IsMarkovKernel η\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsMarkovKernel κ\n⊢ ProbabilityTheory.IsMarkovKernel (η.comp κ)","decl":"instance IsMarkovKernel.comp (η : Kernel β γ) [IsMarkovKernel η] (κ : Kernel α β)\n    [IsMarkovKernel κ] : IsMarkovKernel (η ∘ₖ κ) := by rw [comp_eq_snd_compProd]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsFiniteKernel.comp","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nη : ProbabilityTheory.Kernel β γ\ninst✝¹ : ProbabilityTheory.IsFiniteKernel η\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ ProbabilityTheory.IsFiniteKernel (η.comp κ)","decl":"instance IsFiniteKernel.comp (η : Kernel β γ) [IsFiniteKernel η] (κ : Kernel α β)\n    [IsFiniteKernel κ] : IsFiniteKernel (η ∘ₖ κ) := by rw [comp_eq_snd_compProd]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsSFiniteKernel.comp","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nη : ProbabilityTheory.Kernel β γ\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel η\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\n⊢ ProbabilityTheory.IsSFiniteKernel (η.comp κ)","decl":"instance IsSFiniteKernel.comp (η : Kernel β γ) [IsSFiniteKernel η] (κ : Kernel α β)\n    [IsSFiniteKernel κ] : IsSFiniteKernel (η ∘ₖ κ) := by rw [comp_eq_snd_compProd]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.comp_assoc","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nδ : Type u_5\nmδ : MeasurableSpace δ\nξ : ProbabilityTheory.Kernel γ δ\ninst✝ : ProbabilityTheory.IsSFiniteKernel ξ\nη : ProbabilityTheory.Kernel β γ\nκ : ProbabilityTheory.Kernel α β\n⊢ Eq ((ξ.comp η).comp κ) (ξ.comp (η.comp κ))","decl":"/-- Composition of kernels is associative. -/\ntheorem comp_assoc {δ : Type*} {mδ : MeasurableSpace δ} (ξ : Kernel γ δ) [IsSFiniteKernel ξ]\n    (η : Kernel β γ) (κ : Kernel α β) : ξ ∘ₖ η ∘ₖ κ = ξ ∘ₖ (η ∘ₖ κ) := by\n  refine ext_fun fun a f hf => ?_\n  simp_rw [lintegral_comp _ _ _ hf, lintegral_comp _ _ _ hf.lintegral_kernel]\n\n"}
{"name":"ProbabilityTheory.Kernel.deterministic_comp_eq_map","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nf : β → γ\nhf : Measurable f\nκ : ProbabilityTheory.Kernel α β\n⊢ Eq ((ProbabilityTheory.Kernel.deterministic f hf).comp κ) (κ.map f)","decl":"theorem deterministic_comp_eq_map (hf : Measurable f) (κ : Kernel α β) :\n    deterministic f hf ∘ₖ κ = map κ f := by\n  ext a s hs\n  simp_rw [map_apply' _ hf _ hs, comp_apply' _ _ _ hs, deterministic_apply' hf _ hs,\n    lintegral_indicator_const_comp hf hs, one_mul]\n\n"}
{"name":"ProbabilityTheory.Kernel.comp_deterministic_eq_comap","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\ng : γ → α\nκ : ProbabilityTheory.Kernel α β\nhg : Measurable g\n⊢ Eq (κ.comp (ProbabilityTheory.Kernel.deterministic g hg)) (κ.comap g hg)","decl":"theorem comp_deterministic_eq_comap (κ : Kernel α β) (hg : Measurable g) :\n    κ ∘ₖ deterministic g hg = comap κ g hg := by\n  ext a s hs\n  simp_rw [comap_apply' _ _ _ s, comp_apply' _ _ _ hs, deterministic_apply hg a,\n    lintegral_dirac' _ (Kernel.measurable_coe κ hs)]\n\n"}
{"name":"ProbabilityTheory.Kernel.deterministic_comp_deterministic","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nf : β → γ\ng : γ → α\nhf : Measurable f\nhg : Measurable g\n⊢ Eq ((ProbabilityTheory.Kernel.deterministic g hg).comp (ProbabilityTheory.Kernel.deterministic f hf)) (ProbabilityTheory.Kernel.deterministic (Function.comp g f) ⋯)","decl":"lemma deterministic_comp_deterministic (hf : Measurable f) (hg : Measurable g) :\n    (deterministic g hg) ∘ₖ (deterministic f hf) = deterministic (g ∘ f) (hg.comp hf) := by\n  ext; simp [comp_deterministic_eq_comap, comap_apply, deterministic_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.comp_id","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\n⊢ Eq (κ.comp ProbabilityTheory.Kernel.id) κ","decl":"@[simp]\nlemma comp_id (κ : Kernel α β) : κ ∘ₖ Kernel.id = κ := by\n  rw [Kernel.id, comp_deterministic_eq_comap, comap_id]\n\n"}
{"name":"ProbabilityTheory.Kernel.id_comp","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\n⊢ Eq (ProbabilityTheory.Kernel.id.comp κ) κ","decl":"@[simp]\nlemma id_comp (κ : Kernel α β) : Kernel.id ∘ₖ κ = κ := by\n  rw [Kernel.id, deterministic_comp_eq_map, map_id]\n\n"}
{"name":"ProbabilityTheory.Kernel.comp_discard","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsMarkovKernel κ\n⊢ Eq ((ProbabilityTheory.Kernel.discard β).comp κ) (ProbabilityTheory.Kernel.discard α)","decl":"@[simp]\nlemma comp_discard (κ : Kernel α β) [IsMarkovKernel κ] : discard β ∘ₖ κ = discard α := by\n  ext a s hs; simp [comp_apply' _ _ _ hs]\n\n"}
{"name":"ProbabilityTheory.Kernel.swap_copy","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\n⊢ Eq ((ProbabilityTheory.Kernel.swap α α).comp (ProbabilityTheory.Kernel.copy α)) (ProbabilityTheory.Kernel.copy α)","decl":"@[simp]\nlemma swap_copy : (swap α α) ∘ₖ (copy α) = copy α := by\n  ext a s hs\n  rw [comp_apply, copy_apply, Measure.dirac_bind (Kernel.measurable _), swap_apply' _ hs,\n    Measure.dirac_apply' _ hs]\n  congr\n\n"}
{"name":"ProbabilityTheory.Kernel.swap_swap","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\n⊢ Eq ((ProbabilityTheory.Kernel.swap α β).comp (ProbabilityTheory.Kernel.swap β α)) ProbabilityTheory.Kernel.id","decl":"@[simp]\nlemma swap_swap : (swap α β) ∘ₖ (swap β α) = Kernel.id := by\n  simp_rw [swap, Kernel.deterministic_comp_deterministic, Prod.swap_swap_eq, Kernel.id]\n\n"}
{"name":"ProbabilityTheory.Kernel.swap_comp_eq_map","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α (Prod β γ)\n⊢ Eq ((ProbabilityTheory.Kernel.swap β γ).comp κ) (κ.map Prod.swap)","decl":"lemma swap_comp_eq_map {κ : Kernel α (β × γ)} : (swap β γ) ∘ₖ κ = κ.map Prod.swap := by\n  rw [swap, deterministic_comp_eq_map]\n\n"}
{"name":"ProbabilityTheory.Kernel.const_comp","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nμ : MeasureTheory.Measure γ\nκ : ProbabilityTheory.Kernel α β\n⊢ Eq ⇑((ProbabilityTheory.Kernel.const β μ).comp κ) fun a => HSMul.hSMul ((κ a) Set.univ) μ","decl":"lemma const_comp (μ : Measure γ) (κ : Kernel α β) :\n    const β μ ∘ₖ κ = fun a ↦ (κ a) Set.univ • μ := by\n  ext _ _ hs\n  simp_rw [comp_apply' _ _ _ hs, const_apply, MeasureTheory.lintegral_const, Measure.smul_apply,\n    smul_eq_mul, mul_comm]\n\n"}
{"name":"ProbabilityTheory.Kernel.const_comp'","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nμ : MeasureTheory.Measure γ\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsMarkovKernel κ\n⊢ Eq ((ProbabilityTheory.Kernel.const β μ).comp κ) (ProbabilityTheory.Kernel.const α μ)","decl":"@[simp]\nlemma const_comp' (μ : Measure γ) (κ : Kernel α β) [IsMarkovKernel κ] :\n    const β μ ∘ₖ κ = const α μ := by\n  ext; simp_rw [const_comp, measure_univ, one_smul, const_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.map_comp","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nδ : Type u_4\nmγ : MeasurableSpace γ\nmδ : MeasurableSpace δ\nκ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel β γ\nf : γ → δ\n⊢ Eq ((η.comp κ).map f) ((η.map f).comp κ)","decl":"lemma map_comp (κ : Kernel α β) (η : Kernel β γ) (f : γ → δ) :\n    (η ∘ₖ κ).map f = (η.map f) ∘ₖ κ := by\n  by_cases hf : Measurable f\n  · ext a s hs\n    rw [map_apply' _ hf _ hs, comp_apply', comp_apply' _ _ _ hs]\n    · simp_rw [map_apply' _ hf _ hs]\n    · exact hf hs\n  · simp [map_of_not_measurable _ hf]\n\n"}
{"name":"ProbabilityTheory.Kernel.fst_comp","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nδ : Type u_4\nmγ : MeasurableSpace γ\nmδ : MeasurableSpace δ\nκ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel β (Prod γ δ)\n⊢ Eq (η.comp κ).fst (η.fst.comp κ)","decl":"lemma fst_comp (κ : Kernel α β) (η : Kernel β (γ × δ)) : (η ∘ₖ κ).fst = η.fst ∘ₖ κ := by\n  simp [fst_eq, map_comp κ η _]\n\n"}
{"name":"ProbabilityTheory.Kernel.snd_comp","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nδ : Type u_4\nmγ : MeasurableSpace γ\nmδ : MeasurableSpace δ\nκ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel β (Prod γ δ)\n⊢ Eq (η.comp κ).snd (η.snd.comp κ)","decl":"lemma snd_comp (κ : Kernel α β) (η : Kernel β (γ × δ)) : (η ∘ₖ κ).snd = η.snd ∘ₖ κ := by\n  simp_rw [snd_eq, map_comp κ η _]\n\n"}
{"name":"ProbabilityTheory.Kernel.snd_compProd_prodMkLeft","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel β γ\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\n⊢ Eq (κ.compProd (ProbabilityTheory.Kernel.prodMkLeft α η)).snd (η.comp κ)","decl":"@[simp] lemma snd_compProd_prodMkLeft\n    (κ : Kernel α β) (η : Kernel β γ) [IsSFiniteKernel κ] [IsSFiniteKernel η] :\n    snd (κ ⊗ₖ prodMkLeft α η) = η ∘ₖ κ := by\n  ext a s hs\n  rw [snd_apply' _ _ hs, compProd_apply, comp_apply' _ _ _ hs]\n  · rfl\n  · exact measurable_snd hs\n\n"}
{"name":"ProbabilityTheory.Kernel.prod_apply'","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel α γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\ns : Set (Prod β γ)\nhs : MeasurableSet s\n⊢ Eq (((κ.prod η) a) s) (MeasureTheory.lintegral (κ a) fun b => (η a) (setOf fun c => Membership.mem s { fst := b, snd := c }))","decl":"theorem prod_apply' (κ : Kernel α β) [IsSFiniteKernel κ] (η : Kernel α γ) [IsSFiniteKernel η]\n    (a : α) {s : Set (β × γ)} (hs : MeasurableSet s) :\n    (κ ×ₖ η) a s = ∫⁻ b : β, (η a) {c : γ | (b, c) ∈ s} ∂κ a := by\n  simp_rw [prod, compProd_apply hs, swapLeft_apply _ _, prodMkLeft_apply, Prod.swap_prod_mk]\n\n"}
{"name":"ProbabilityTheory.Kernel.prod_apply","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel α γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\n⊢ Eq ((κ.prod η) a) ((κ a).prod (η a))","decl":"lemma prod_apply (κ : Kernel α β) [IsSFiniteKernel κ] (η : Kernel α γ) [IsSFiniteKernel η]\n    (a : α) :\n    (κ ×ₖ η) a = (κ a).prod (η a) := by\n  ext s hs\n  rw [prod_apply' _ _ _ hs, Measure.prod_apply hs]\n  rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.prod_const","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nμ : MeasureTheory.Measure β\ninst✝¹ : MeasureTheory.SFinite μ\nν : MeasureTheory.Measure γ\ninst✝ : MeasureTheory.SFinite ν\n⊢ Eq ((ProbabilityTheory.Kernel.const α μ).prod (ProbabilityTheory.Kernel.const α ν)) (ProbabilityTheory.Kernel.const α (μ.prod ν))","decl":"lemma prod_const (μ : Measure β) [SFinite μ] (ν : Measure γ) [SFinite ν] :\n    const α μ ×ₖ const α ν = const α (μ.prod ν) := by\n  ext x\n  rw [const_apply, prod_apply, const_apply, const_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.lintegral_prod","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel α γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\na : α\ng : Prod β γ → ENNReal\nhg : Measurable g\n⊢ Eq (MeasureTheory.lintegral ((κ.prod η) a) fun c => g c) (MeasureTheory.lintegral (κ a) fun b => MeasureTheory.lintegral (η a) fun c => g { fst := b, snd := c })","decl":"theorem lintegral_prod (κ : Kernel α β) [IsSFiniteKernel κ] (η : Kernel α γ) [IsSFiniteKernel η]\n    (a : α) {g : β × γ → ℝ≥0∞} (hg : Measurable g) :\n    ∫⁻ c, g c ∂(κ ×ₖ η) a = ∫⁻ b, ∫⁻ c, g (b, c) ∂η a ∂κ a := by\n  simp_rw [prod, lintegral_compProd _ _ _ hg, swapLeft_apply, prodMkLeft_apply, Prod.swap_prod_mk]\n\n"}
{"name":"ProbabilityTheory.Kernel.IsMarkovKernel.prod","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsMarkovKernel κ\nη : ProbabilityTheory.Kernel α γ\ninst✝ : ProbabilityTheory.IsMarkovKernel η\n⊢ ProbabilityTheory.IsMarkovKernel (κ.prod η)","decl":"instance IsMarkovKernel.prod (κ : Kernel α β) [IsMarkovKernel κ] (η : Kernel α γ)\n    [IsMarkovKernel η] : IsMarkovKernel (κ ×ₖ η) := by rw [Kernel.prod]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsZeroOrMarkovKernel.prod","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nh : ProbabilityTheory.IsZeroOrMarkovKernel κ\nη : ProbabilityTheory.Kernel α γ\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel η\n⊢ ProbabilityTheory.IsZeroOrMarkovKernel (κ.prod η)","decl":"nonrec instance IsZeroOrMarkovKernel.prod (κ : Kernel α β) [h : IsZeroOrMarkovKernel κ]\n    (η : Kernel α γ) [IsZeroOrMarkovKernel η] : IsZeroOrMarkovKernel (κ ×ₖ η) := by\n  rcases eq_zero_or_isMarkovKernel κ with rfl | h\n  · simp only [prod, swapLeft_prodMkLeft, compProd_zero_left]; infer_instance\n  rcases eq_zero_or_isMarkovKernel η with rfl | h'\n  · simp only [prod, swapLeft, prodMkLeft_zero, comap_zero, compProd_zero_right]; infer_instance\n  infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsFiniteKernel.prod","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsFiniteKernel κ\nη : ProbabilityTheory.Kernel α γ\ninst✝ : ProbabilityTheory.IsFiniteKernel η\n⊢ ProbabilityTheory.IsFiniteKernel (κ.prod η)","decl":"instance IsFiniteKernel.prod (κ : Kernel α β) [IsFiniteKernel κ] (η : Kernel α γ)\n    [IsFiniteKernel η] : IsFiniteKernel (κ ×ₖ η) := by rw [Kernel.prod]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.IsSFiniteKernel.prod","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel α γ\n⊢ ProbabilityTheory.IsSFiniteKernel (κ.prod η)","decl":"instance IsSFiniteKernel.prod (κ : Kernel α β) (η : Kernel α γ) :\n    IsSFiniteKernel (κ ×ₖ η) := by rw [Kernel.prod]; infer_instance\n\n"}
{"name":"ProbabilityTheory.Kernel.fst_prod","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel α γ\ninst✝ : ProbabilityTheory.IsMarkovKernel η\n⊢ Eq (κ.prod η).fst κ","decl":"@[simp] lemma fst_prod (κ : Kernel α β) [IsSFiniteKernel κ] (η : Kernel α γ) [IsMarkovKernel η] :\n    fst (κ ×ₖ η) = κ := by\n  rw [prod]; simp\n\n"}
{"name":"ProbabilityTheory.Kernel.snd_prod","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsMarkovKernel κ\nη : ProbabilityTheory.Kernel α γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\n⊢ Eq (κ.prod η).snd η","decl":"@[simp] lemma snd_prod (κ : Kernel α β) [IsMarkovKernel κ] (η : Kernel α γ) [IsSFiniteKernel η] :\n    snd (κ ×ₖ η) = η := by\n  ext x; simp [snd_apply, prod_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.comap_prod_swap","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nδ : Type u_4\nmγ : MeasurableSpace γ\nmδ : MeasurableSpace δ\nκ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel γ δ\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\n⊢ Eq (((ProbabilityTheory.Kernel.prodMkRight α η).prod (ProbabilityTheory.Kernel.prodMkLeft γ κ)).comap Prod.swap ⋯) (((ProbabilityTheory.Kernel.prodMkRight γ κ).prod (ProbabilityTheory.Kernel.prodMkLeft α η)).map Prod.swap)","decl":"lemma comap_prod_swap (κ : Kernel α β) (η : Kernel γ δ) [IsSFiniteKernel κ] [IsSFiniteKernel η] :\n    comap (prodMkRight α η ×ₖ prodMkLeft γ κ) Prod.swap measurable_swap\n      = map (prodMkRight γ κ ×ₖ prodMkLeft α η) Prod.swap := by\n  rw [ext_fun_iff]\n  intro x f hf\n  rw [lintegral_comap, lintegral_map _ measurable_swap _ hf, lintegral_prod _ _ _ hf,\n    lintegral_prod]\n  swap; · exact hf.comp measurable_swap\n  simp only [prodMkRight_apply, Prod.fst_swap, Prod.swap_prod_mk, lintegral_prodMkLeft,\n    Prod.snd_swap]\n  refine (lintegral_lintegral_swap ?_).symm\n  exact (hf.comp measurable_swap).aemeasurable\n\n"}
{"name":"ProbabilityTheory.Kernel.map_prod_swap","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\nη : ProbabilityTheory.Kernel α γ\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\n⊢ Eq ((κ.prod η).map Prod.swap) (η.prod κ)","decl":"lemma map_prod_swap (κ : Kernel α β) (η : Kernel α γ) [IsSFiniteKernel κ] [IsSFiniteKernel η] :\n    map (κ ×ₖ η) Prod.swap = η ×ₖ κ := by\n  rw [ext_fun_iff]\n  intro x f hf\n  rw [lintegral_map _ measurable_swap _ hf, lintegral_prod, lintegral_prod _ _ _ hf]\n  swap; · exact hf.comp measurable_swap\n  refine (lintegral_lintegral_swap ?_).symm\n  exact hf.aemeasurable\n\n"}
{"name":"ProbabilityTheory.Kernel.swap_prod","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel α γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\n⊢ Eq ((ProbabilityTheory.Kernel.swap β γ).comp (κ.prod η)) (η.prod κ)","decl":"@[simp]\nlemma swap_prod {κ : Kernel α β} [IsSFiniteKernel κ] {η : Kernel α γ} [IsSFiniteKernel η] :\n    (swap β γ) ∘ₖ (κ ×ₖ η) = (η ×ₖ κ) := by\n  rw [swap_comp_eq_map, map_prod_swap]\n\n"}
{"name":"ProbabilityTheory.Kernel.deterministic_prod_deterministic","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nf : α → β\ng : α → γ\nhf : Measurable f\nhg : Measurable g\n⊢ Eq ((ProbabilityTheory.Kernel.deterministic f hf).prod (ProbabilityTheory.Kernel.deterministic g hg)) (ProbabilityTheory.Kernel.deterministic (fun a => { fst := f a, snd := g a }) ⋯)","decl":"lemma deterministic_prod_deterministic {f : α → β} {g : α → γ}\n    (hf : Measurable f) (hg : Measurable g) :\n    deterministic f hf ×ₖ deterministic g hg\n      = deterministic (fun a ↦ (f a, g a)) (hf.prod_mk hg) := by\n  ext; simp_rw [prod_apply, deterministic_apply, Measure.dirac_prod_dirac]\n\n"}
{"name":"ProbabilityTheory.Kernel.compProd_prodMkLeft_eq_comp","module":"Mathlib.Probability.Kernel.Composition.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nγ : Type u_3\nmγ : MeasurableSpace γ\nκ : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\nη : ProbabilityTheory.Kernel β γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\n⊢ Eq (κ.compProd (ProbabilityTheory.Kernel.prodMkLeft α η)) ((ProbabilityTheory.Kernel.id.prod η).comp κ)","decl":"lemma compProd_prodMkLeft_eq_comp\n    (κ : Kernel α β) [IsSFiniteKernel κ] (η : Kernel β γ) [IsSFiniteKernel η] :\n    κ ⊗ₖ (prodMkLeft α η) = (Kernel.id ×ₖ η) ∘ₖ κ := by\n  ext a s hs\n  rw [comp_eq_snd_compProd, compProd_apply hs, snd_apply' _ _ hs, compProd_apply]\n  swap; · exact measurable_snd hs\n  simp only [prodMkLeft_apply, Set.mem_setOf_eq, Set.setOf_mem_eq, prod_apply' _ _ _ hs,\n    id_apply, id_eq]\n  congr with b\n  rw [lintegral_dirac']\n  exact measurable_measure_prod_mk_left hs\n\n"}
