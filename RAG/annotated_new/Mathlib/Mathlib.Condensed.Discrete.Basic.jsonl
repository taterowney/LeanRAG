{"name":"Condensed.discrete_obj","module":"Mathlib.Condensed.Discrete.Basic","initialProofState":"C : Type w\ninst✝¹ : CategoryTheory.Category.{u + 1, w} C\ninst✝ : CategoryTheory.HasWeakSheafify (CategoryTheory.coherentTopology CompHaus) C\nX : C\n⊢ Eq ((Condensed.discrete C).obj X) ((CategoryTheory.presheafToSheaf (CategoryTheory.coherentTopology CompHaus) C).obj ((CategoryTheory.Functor.const (Opposite CompHaus)).obj X))","decl":"/--\nThe discrete condensed object associated to an object of `C` is the constant sheaf at that object.\n-/\n@[simps!]\nnoncomputable def discrete : C ⥤ Condensed.{u} C := constantSheaf _ C\n\n"}
{"name":"Condensed.discrete_map","module":"Mathlib.Condensed.Discrete.Basic","initialProofState":"C : Type w\ninst✝¹ : CategoryTheory.Category.{u + 1, w} C\ninst✝ : CategoryTheory.HasWeakSheafify (CategoryTheory.coherentTopology CompHaus) C\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((Condensed.discrete C).map f) ((CategoryTheory.presheafToSheaf (CategoryTheory.coherentTopology CompHaus) C).map ((CategoryTheory.Functor.const (Opposite CompHaus)).map f))","decl":"/--\nThe discrete condensed object associated to an object of `C` is the constant sheaf at that object.\n-/\n@[simps!]\nnoncomputable def discrete : C ⥤ Condensed.{u} C := constantSheaf _ C\n\n"}
{"name":"Condensed.underlying_obj","module":"Mathlib.Condensed.Discrete.Basic","initialProofState":"C : Type w\ninst✝ : CategoryTheory.Category.{u + 1, w} C\nj : CategoryTheory.Sheaf (CategoryTheory.coherentTopology CompHaus) C\n⊢ Eq ((Condensed.underlying C).obj j) (j.val.obj { unop := CompHaus.of PUnit.{u + 1} })","decl":"/--\nThe underlying object of a condensed object in `C` is the condensed object evaluated at a point.\nThis can be viewed as a sort of forgetful functor from `Condensed C` to `C`\n-/\n@[simps!]\nnoncomputable def underlying : Condensed.{u} C ⥤ C :=\n  (sheafSections _ _).obj ⟨CompHaus.of PUnit.{u+1}⟩\n\n"}
{"name":"Condensed.underlying_map","module":"Mathlib.Condensed.Discrete.Basic","initialProofState":"C : Type w\ninst✝ : CategoryTheory.Category.{u + 1, w} C\nX✝ Y✝ : CategoryTheory.Sheaf (CategoryTheory.coherentTopology CompHaus) C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((Condensed.underlying C).map f) (f.val.app { unop := CompHaus.of PUnit.{u + 1} })","decl":"/--\nThe underlying object of a condensed object in `C` is the condensed object evaluated at a point.\nThis can be viewed as a sort of forgetful functor from `Condensed C` to `C`\n-/\n@[simps!]\nnoncomputable def underlying : Condensed.{u} C ⥤ C :=\n  (sheafSections _ _).obj ⟨CompHaus.of PUnit.{u+1}⟩\n\n"}
{"name":"LightCondensed.discrete_map","module":"Mathlib.Condensed.Discrete.Basic","initialProofState":"C : Type w\ninst✝¹ : CategoryTheory.Category.{u, w} C\ninst✝ : CategoryTheory.HasSheafify (CategoryTheory.coherentTopology LightProfinite) C\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((LightCondensed.discrete C).map f) ((CategoryTheory.presheafToSheaf (CategoryTheory.coherentTopology LightProfinite) C).map ((CategoryTheory.Functor.const (Opposite LightProfinite)).map f))","decl":"/--\nThe discrete light condensed object associated to an object of `C` is the constant sheaf at that\nobject.\n-/\n@[simps!]\nnoncomputable def discrete : C ⥤ LightCondensed.{u} C := constantSheaf _ C\n\n"}
{"name":"LightCondensed.discrete_obj","module":"Mathlib.Condensed.Discrete.Basic","initialProofState":"C : Type w\ninst✝¹ : CategoryTheory.Category.{u, w} C\ninst✝ : CategoryTheory.HasSheafify (CategoryTheory.coherentTopology LightProfinite) C\nX : C\n⊢ Eq ((LightCondensed.discrete C).obj X) ((CategoryTheory.presheafToSheaf (CategoryTheory.coherentTopology LightProfinite) C).obj ((CategoryTheory.Functor.const (Opposite LightProfinite)).obj X))","decl":"/--\nThe discrete light condensed object associated to an object of `C` is the constant sheaf at that\nobject.\n-/\n@[simps!]\nnoncomputable def discrete : C ⥤ LightCondensed.{u} C := constantSheaf _ C\n\n"}
{"name":"LightCondensed.underlying_obj","module":"Mathlib.Condensed.Discrete.Basic","initialProofState":"C : Type w\ninst✝ : CategoryTheory.Category.{u, w} C\nj : CategoryTheory.Sheaf (CategoryTheory.coherentTopology LightProfinite) C\n⊢ Eq ((LightCondensed.underlying C).obj j) (j.val.obj { unop := LightProfinite.of PUnit.{u + 1} })","decl":"/--\nThe underlying object of a condensed object in `C` is the light condensed object evaluated at a\npoint. This can be viewed as a sort of forgetful functor from `LightCondensed C` to `C`\n-/\n@[simps!]\nnoncomputable def underlying : LightCondensed.{u} C ⥤ C :=\n  (sheafSections _ _).obj (op (LightProfinite.of PUnit))\n\n"}
{"name":"LightCondensed.underlying_map","module":"Mathlib.Condensed.Discrete.Basic","initialProofState":"C : Type w\ninst✝ : CategoryTheory.Category.{u, w} C\nX✝ Y✝ : CategoryTheory.Sheaf (CategoryTheory.coherentTopology LightProfinite) C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((LightCondensed.underlying C).map f) (f.val.app { unop := LightProfinite.of PUnit.{u + 1} })","decl":"/--\nThe underlying object of a condensed object in `C` is the light condensed object evaluated at a\npoint. This can be viewed as a sort of forgetful functor from `LightCondensed C` to `C`\n-/\n@[simps!]\nnoncomputable def underlying : LightCondensed.{u} C ⥤ C :=\n  (sheafSections _ _).obj (op (LightProfinite.of PUnit))\n\n"}
