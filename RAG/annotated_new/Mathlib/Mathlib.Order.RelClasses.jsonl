{"name":"of_eq","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsRefl α r\na b : α\na✝ : Eq a b\n⊢ r a b","decl":"theorem of_eq [IsRefl α r] : ∀ {a b}, a = b → r a b\n  | _, _, .refl _ => refl _\n\n"}
{"name":"comm","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsSymm α r\na b : α\n⊢ Iff (r a b) (r b a)","decl":"theorem comm [IsSymm α r] {a b : α} : r a b ↔ r b a :=\n  ⟨symm, symm⟩\n\n"}
{"name":"antisymm'","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsAntisymm α r\na b : α\na✝¹ : r a b\na✝ : r b a\n⊢ Eq b a","decl":"theorem antisymm' [IsAntisymm α r] {a b : α} : r a b → r b a → b = a := fun h h' => antisymm h' h\n\n"}
{"name":"antisymm_iff","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝¹ : IsRefl α r\ninst✝ : IsAntisymm α r\na b : α\n⊢ Iff (And (r a b) (r b a)) (Eq a b)","decl":"theorem antisymm_iff [IsRefl α r] [IsAntisymm α r] {a b : α} : r a b ∧ r b a ↔ a = b :=\n  ⟨fun h => antisymm h.1 h.2, by\n    rintro rfl\n    exact ⟨refl _, refl _⟩⟩\n\n"}
{"name":"antisymm_of","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsAntisymm α r\na b : α\na✝¹ : r a b\na✝ : r b a\n⊢ Eq a b","decl":"/-- A version of `antisymm` with `r` explicit.\n\nThis lemma matches the lemmas from lean core in `Init.Algebra.Classes`, but is missing there. -/\n@[elab_without_expected_type]\ntheorem antisymm_of (r : α → α → Prop) [IsAntisymm α r] {a b : α} : r a b → r b a → a = b :=\n  antisymm\n\n"}
{"name":"antisymm_of'","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsAntisymm α r\na b : α\na✝¹ : r a b\na✝ : r b a\n⊢ Eq b a","decl":"/-- A version of `antisymm'` with `r` explicit.\n\nThis lemma matches the lemmas from lean core in `Init.Algebra.Classes`, but is missing there. -/\n@[elab_without_expected_type]\ntheorem antisymm_of' (r : α → α → Prop) [IsAntisymm α r] {a b : α} : r a b → r b a → b = a :=\n  antisymm'\n\n"}
{"name":"comm_of","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsSymm α r\na b : α\n⊢ Iff (r a b) (r b a)","decl":"/-- A version of `comm` with `r` explicit.\n\nThis lemma matches the lemmas from lean core in `Init.Algebra.Classes`, but is missing there. -/\ntheorem comm_of (r : α → α → Prop) [IsSymm α r] {a b : α} : r a b ↔ r b a :=\n  comm\n\n"}
{"name":"IsRefl.swap","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsRefl α r\n⊢ IsRefl α (Function.swap r)","decl":"theorem IsRefl.swap (r) [IsRefl α r] : IsRefl α (swap r) :=\n  ⟨refl_of r⟩\n\n"}
{"name":"IsIrrefl.swap","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsIrrefl α r\n⊢ IsIrrefl α (Function.swap r)","decl":"theorem IsIrrefl.swap (r) [IsIrrefl α r] : IsIrrefl α (swap r) :=\n  ⟨irrefl_of r⟩\n\n"}
{"name":"IsTrans.swap","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsTrans α r\n⊢ IsTrans α (Function.swap r)","decl":"theorem IsTrans.swap (r) [IsTrans α r] : IsTrans α (swap r) :=\n  ⟨fun _ _ _ h₁ h₂ => trans_of r h₂ h₁⟩\n\n"}
{"name":"IsAntisymm.swap","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsAntisymm α r\n⊢ IsAntisymm α (Function.swap r)","decl":"theorem IsAntisymm.swap (r) [IsAntisymm α r] : IsAntisymm α (swap r) :=\n  ⟨fun _ _ h₁ h₂ => _root_.antisymm h₂ h₁⟩\n\n"}
{"name":"IsAsymm.swap","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsAsymm α r\n⊢ IsAsymm α (Function.swap r)","decl":"theorem IsAsymm.swap (r) [IsAsymm α r] : IsAsymm α (swap r) :=\n  ⟨fun _ _ h₁ h₂ => asymm_of r h₂ h₁⟩\n\n"}
{"name":"IsTotal.swap","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsTotal α r\n⊢ IsTotal α (Function.swap r)","decl":"theorem IsTotal.swap (r) [IsTotal α r] : IsTotal α (swap r) :=\n  ⟨fun a b => (total_of r a b).symm⟩\n\n"}
{"name":"IsTrichotomous.swap","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsTrichotomous α r\n⊢ IsTrichotomous α (Function.swap r)","decl":"theorem IsTrichotomous.swap (r) [IsTrichotomous α r] : IsTrichotomous α (swap r) :=\n  ⟨fun a b => by simpa [Function.swap, or_comm, or_left_comm] using trichotomous_of r a b⟩\n\n"}
{"name":"IsPreorder.swap","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsPreorder α r\n⊢ IsPreorder α (Function.swap r)","decl":"theorem IsPreorder.swap (r) [IsPreorder α r] : IsPreorder α (swap r) :=\n  { @IsRefl.swap α r _, @IsTrans.swap α r _ with }\n\n"}
{"name":"IsStrictOrder.swap","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\n⊢ IsStrictOrder α (Function.swap r)","decl":"theorem IsStrictOrder.swap (r) [IsStrictOrder α r] : IsStrictOrder α (swap r) :=\n  { @IsIrrefl.swap α r _, @IsTrans.swap α r _ with }\n\n"}
{"name":"IsPartialOrder.swap","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsPartialOrder α r\n⊢ IsPartialOrder α (Function.swap r)","decl":"theorem IsPartialOrder.swap (r) [IsPartialOrder α r] : IsPartialOrder α (swap r) :=\n  { @IsPreorder.swap α r _, @IsAntisymm.swap α r _ with }\n\n"}
{"name":"IsAsymm.isAntisymm","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsAsymm α r\n⊢ IsAntisymm α r","decl":"protected theorem IsAsymm.isAntisymm (r) [IsAsymm α r] : IsAntisymm α r :=\n  ⟨fun _ _ h₁ h₂ => (_root_.asymm h₁ h₂).elim⟩\n\n"}
{"name":"IsAsymm.isIrrefl","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsAsymm α r\n⊢ IsIrrefl α r","decl":"protected theorem IsAsymm.isIrrefl [IsAsymm α r] : IsIrrefl α r :=\n  ⟨fun _ h => _root_.asymm h h⟩\n\n"}
{"name":"IsTotal.isTrichotomous","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsTotal α r\n⊢ IsTrichotomous α r","decl":"protected theorem IsTotal.isTrichotomous (r) [IsTotal α r] : IsTrichotomous α r :=\n  ⟨fun a b => or_left_comm.1 (Or.inr <| total_of r a b)⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"IsTotal.to_isRefl","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsTotal α r\n⊢ IsRefl α r","decl":"instance (priority := 100) IsTotal.to_isRefl (r) [IsTotal α r] : IsRefl α r :=\n  ⟨fun a => or_self_iff.1 <| total_of r a a⟩\n\n"}
{"name":"ne_of_irrefl","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsIrrefl α r\nx y : α\na✝ : r x y\n⊢ Ne x y","decl":"theorem ne_of_irrefl {r} [IsIrrefl α r] : ∀ {x y : α}, r x y → x ≠ y\n  | _, _, h, rfl => irrefl _ h\n\n"}
{"name":"ne_of_irrefl'","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsIrrefl α r\nx y : α\na✝ : r x y\n⊢ Ne y x","decl":"theorem ne_of_irrefl' {r} [IsIrrefl α r] : ∀ {x y : α}, r x y → y ≠ x\n  | _, _, h, rfl => irrefl _ h\n\n"}
{"name":"not_rel_of_subsingleton","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝¹ : IsIrrefl α r\ninst✝ : Subsingleton α\nx y : α\n⊢ Not (r x y)","decl":"theorem not_rel_of_subsingleton (r) [IsIrrefl α r] [Subsingleton α] (x y) : ¬r x y :=\n  Subsingleton.elim x y ▸ irrefl x\n\n"}
{"name":"rel_of_subsingleton","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝¹ : IsRefl α r\ninst✝ : Subsingleton α\nx y : α\n⊢ r x y","decl":"theorem rel_of_subsingleton (r) [IsRefl α r] [Subsingleton α] (x y) : r x y :=\n  Subsingleton.elim x y ▸ refl x\n\n"}
{"name":"empty_relation_apply","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\na b : α\n⊢ Iff (EmptyRelation a b) False","decl":"@[simp]\ntheorem empty_relation_apply (a b : α) : EmptyRelation a b ↔ False :=\n  Iff.rfl\n\n"}
{"name":"eq_empty_relation","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝¹ : IsIrrefl α r\ninst✝ : Subsingleton α\n⊢ Eq r EmptyRelation","decl":"theorem eq_empty_relation (r) [IsIrrefl α r] [Subsingleton α] : r = EmptyRelation :=\n  funext₂ <| by simpa using not_rel_of_subsingleton r\n\n"}
{"name":"instIsIrreflEmptyRelation","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\n⊢ IsIrrefl α EmptyRelation","decl":"instance : IsIrrefl α EmptyRelation :=\n  ⟨fun _ => id⟩\n\n"}
{"name":"trans_trichotomous_left","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝¹ : IsTrans α r\ninst✝ : IsTrichotomous α r\na b c : α\nh₁ : Not (r b a)\nh₂ : r b c\n⊢ r a c","decl":"theorem trans_trichotomous_left [IsTrans α r] [IsTrichotomous α r] {a b c : α}\n    (h₁ : ¬r b a) (h₂ : r b c) : r a c := by\n  rcases trichotomous_of r a b with (h₃ | rfl | h₃)\n  exacts [_root_.trans h₃ h₂, h₂, absurd h₃ h₁]\n\n"}
{"name":"trans_trichotomous_right","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝¹ : IsTrans α r\ninst✝ : IsTrichotomous α r\na b c : α\nh₁ : r a b\nh₂ : Not (r c b)\n⊢ r a c","decl":"theorem trans_trichotomous_right [IsTrans α r] [IsTrichotomous α r] {a b c : α}\n    (h₁ : r a b) (h₂ : ¬r c b) : r a c := by\n  rcases trichotomous_of r b c with (h₃ | rfl | h₃)\n  exacts [_root_.trans h₁ h₃, h₁, absurd h₃ h₂]\n\n"}
{"name":"transitive_of_trans","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsTrans α r\n⊢ Transitive r","decl":"theorem transitive_of_trans (r : α → α → Prop) [IsTrans α r] : Transitive r := IsTrans.trans\n\n"}
{"name":"rel_congr_left","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝¹ : IsSymm α r\ninst✝ : IsTrans α r\na b c : α\nh : r a b\n⊢ Iff (r a c) (r b c)","decl":"theorem rel_congr_left [IsSymm α r] [IsTrans α r] {a b c : α} (h : r a b) : r a c ↔ r b c :=\n  ⟨trans_of r (symm_of r h), trans_of r h⟩\n\n"}
{"name":"rel_congr_right","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝¹ : IsSymm α r\ninst✝ : IsTrans α r\na b c : α\nh : r b c\n⊢ Iff (r a b) (r a c)","decl":"theorem rel_congr_right [IsSymm α r] [IsTrans α r] {a b c : α} (h : r b c) : r a b ↔ r a c :=\n  ⟨(trans_of r · h), (trans_of r · (symm_of r h))⟩\n\n"}
{"name":"rel_congr","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝¹ : IsSymm α r\ninst✝ : IsTrans α r\na b c d : α\nh₁ : r a b\nh₂ : r c d\n⊢ Iff (r a c) (r b d)","decl":"theorem rel_congr [IsSymm α r] [IsTrans α r] {a b c d : α} (h₁ : r a b) (h₂ : r c d) :\n    r a c ↔ r b d := by\n  rw [rel_congr_left h₁, rel_congr_right h₂]\n\n"}
{"name":"extensional_of_trichotomous_of_irrefl","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝¹ : IsTrichotomous α r\ninst✝ : IsIrrefl α r\na b : α\nH : ∀ (x : α), Iff (r x a) (r x b)\n⊢ Eq a b","decl":"/-- In a trichotomous irreflexive order, every element is determined by the set of predecessors. -/\ntheorem extensional_of_trichotomous_of_irrefl (r : α → α → Prop) [IsTrichotomous α r] [IsIrrefl α r]\n    {a b : α} (H : ∀ x, r x a ↔ r x b) : a = b :=\n  ((@trichotomous _ r _ a b).resolve_left <| mt (H _).2 <| irrefl a).resolve_right <| mt (H _).1\n    <| irrefl b\n\n"}
{"name":"IsStrictTotalOrder.swap","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsStrictTotalOrder α r\n⊢ IsStrictTotalOrder α (Function.swap r)","decl":"theorem IsStrictTotalOrder.swap (r) [IsStrictTotalOrder α r] : IsStrictTotalOrder α (swap r) :=\n  { IsTrichotomous.swap r, IsStrictOrder.swap r with }\n\n"}
{"name":"IsOrderConnected.conn","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nlt : α → α → Prop\nself : IsOrderConnected α lt\na b c : α\na✝ : lt a c\n⊢ Or (lt a b) (lt b c)","decl":"/-- A connected order is one satisfying the condition `a < c → a < b ∨ b < c`.\n  This is recognizable as an intuitionistic substitute for `a ≤ b ∨ b ≤ a` on\n  the constructive reals, and is also known as negative transitivity,\n  since the contrapositive asserts transitivity of the relation `¬ a < b`. -/\nclass IsOrderConnected (α : Type u) (lt : α → α → Prop) : Prop where\n  /-- A connected order is one satisfying the condition `a < c → a < b ∨ b < c`. -/\n  conn : ∀ a b c, lt a c → lt a b ∨ lt b c\n\n"}
{"name":"IsOrderConnected.neg_trans","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsOrderConnected α r\na b c : α\nh₁ : Not (r a b)\nh₂ : Not (r b c)\n⊢ Not (r a c)","decl":"theorem IsOrderConnected.neg_trans {r : α → α → Prop} [IsOrderConnected α r] {a b c}\n    (h₁ : ¬r a b) (h₂ : ¬r b c) : ¬r a c :=\n  mt (IsOrderConnected.conn a b c) <| by simp [h₁, h₂]\n\n"}
{"name":"isStrictWeakOrder_of_isOrderConnected","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝¹ : IsAsymm α r\ninst✝ : IsOrderConnected α r\n⊢ IsStrictWeakOrder α r","decl":"theorem isStrictWeakOrder_of_isOrderConnected [IsAsymm α r] [IsOrderConnected α r] :\n    IsStrictWeakOrder α r :=\n  { @IsAsymm.isIrrefl α r _ with\n    trans := fun _ _ c h₁ h₂ => (IsOrderConnected.conn _ c _ h₁).resolve_right (asymm h₂),\n    incomp_trans := fun _ _ _ ⟨h₁, h₂⟩ ⟨h₃, h₄⟩ =>\n      ⟨IsOrderConnected.neg_trans h₁ h₃, IsOrderConnected.neg_trans h₄ h₂⟩ }\n\n-- see Note [lower instance priority]\n"}
{"name":"isStrictOrderConnected_of_isStrictTotalOrder","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsStrictTotalOrder α r\n⊢ IsOrderConnected α r","decl":"instance (priority := 100) isStrictOrderConnected_of_isStrictTotalOrder [IsStrictTotalOrder α r] :\n    IsOrderConnected α r :=\n  ⟨fun _ _ _ h ↦ (trichotomous _ _).imp_right\n    fun o ↦ o.elim (fun e ↦ e ▸ h) fun h' ↦ _root_.trans h' h⟩\n\n"}
{"name":"IsWellFounded.wf","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\nself : IsWellFounded α r\n⊢ WellFounded r","decl":"/-- A well-founded relation. Not to be confused with `IsWellOrder`. -/\n@[mk_iff] class IsWellFounded (α : Type u) (r : α → α → Prop) : Prop where\n  /-- The relation is `WellFounded`, as a proposition. -/\n  wf : WellFounded r\n\n"}
{"name":"isWellFounded_iff","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\n⊢ Iff (IsWellFounded α r) (WellFounded r)","decl":"/-- A well-founded relation. Not to be confused with `IsWellOrder`. -/\n@[mk_iff] class IsWellFounded (α : Type u) (r : α → α → Prop) : Prop where\n  /-- The relation is `WellFounded`, as a proposition. -/\n  wf : WellFounded r\n\n"}
{"name":"WellFoundedRelation.isWellFounded","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nh : WellFoundedRelation α\n⊢ IsWellFounded α WellFoundedRelation.rel","decl":"instance WellFoundedRelation.isWellFounded [h : WellFoundedRelation α] :\n    IsWellFounded α WellFoundedRelation.rel :=\n  { h with }\n\n"}
{"name":"WellFoundedRelation.asymmetric","module":"Mathlib.Order.RelClasses","initialProofState":"α : Sort u_1\ninst✝ : WellFoundedRelation α\na b : α\na✝ : WellFoundedRelation.rel a b\n⊢ Not (WellFoundedRelation.rel b a)","decl":"theorem WellFoundedRelation.asymmetric {α : Sort*} [WellFoundedRelation α] {a b : α} :\n    WellFoundedRelation.rel a b → ¬ WellFoundedRelation.rel b a :=\n  fun hab hba => WellFoundedRelation.asymmetric hba hab\ntermination_by a\n\n"}
{"name":"WellFoundedRelation.asymmetric₃","module":"Mathlib.Order.RelClasses","initialProofState":"α : Sort u_1\ninst✝ : WellFoundedRelation α\na b c : α\na✝¹ : WellFoundedRelation.rel a b\na✝ : WellFoundedRelation.rel b c\n⊢ Not (WellFoundedRelation.rel c a)","decl":"theorem WellFoundedRelation.asymmetric₃ {α : Sort*} [WellFoundedRelation α] {a b c : α} :\n    WellFoundedRelation.rel a b → WellFoundedRelation.rel b c → ¬ WellFoundedRelation.rel c a :=\n  fun hab hbc hca => WellFoundedRelation.asymmetric₃ hca hab hbc\ntermination_by a\n\n"}
{"name":"WellFounded.prod_lex","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nβ : Type v\nra : α → α → Prop\nrb : β → β → Prop\nha : WellFounded ra\nhb : WellFounded rb\n⊢ WellFounded (Prod.Lex ra rb)","decl":"lemma WellFounded.prod_lex {ra : α → α → Prop} {rb : β → β → Prop} (ha : WellFounded ra)\n    (hb : WellFounded rb) : WellFounded (Prod.Lex ra rb) :=\n  (Prod.lex ⟨_, ha⟩ ⟨_, hb⟩).wf\n\n"}
{"name":"WellFounded.psigma_lex","module":"Mathlib.Order.RelClasses","initialProofState":"α : Sort u_1\nβ : α → Sort u_2\nr : α → α → Prop\ns : (a : α) → β a → β a → Prop\nha : WellFounded r\nhb : ∀ (x : α), WellFounded (s x)\n⊢ WellFounded (PSigma.Lex r s)","decl":"/-- The lexicographical order of well-founded relations is well-founded. -/\ntheorem WellFounded.psigma_lex\n    {α : Sort*} {β : α → Sort*} {r : α → α → Prop} {s : ∀ a : α, β a → β a → Prop}\n    (ha : WellFounded r) (hb : ∀ x, WellFounded (s x)) : WellFounded (Lex r s) :=\n  WellFounded.intro fun ⟨a, b⟩ => lexAccessible (WellFounded.apply ha a) hb b\n\n"}
{"name":"WellFounded.psigma_revLex","module":"Mathlib.Order.RelClasses","initialProofState":"α : Sort u_1\nβ : Sort u_2\nr : α → α → Prop\ns : β → β → Prop\nha : WellFounded r\nhb : WellFounded s\n⊢ WellFounded (PSigma.RevLex r s)","decl":"theorem WellFounded.psigma_revLex\n    {α : Sort*} {β : Sort*} {r : α → α → Prop} {s : β → β → Prop}\n    (ha : WellFounded r) (hb : WellFounded s) : WellFounded (RevLex r s) :=\n  WellFounded.intro fun ⟨a, b⟩ => revLexAccessible (apply hb b) (WellFounded.apply ha) a\n\n"}
{"name":"WellFounded.psigma_skipLeft","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nβ : Type v\ns : β → β → Prop\nhb : WellFounded s\n⊢ WellFounded (PSigma.SkipLeft α s)","decl":"theorem WellFounded.psigma_skipLeft (α : Type u) {β : Type v} {s : β → β → Prop}\n    (hb : WellFounded s) : WellFounded (SkipLeft α s) :=\n  psigma_revLex emptyWf.wf hb\n\n"}
{"name":"IsWellFounded.induction","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellFounded α r\nC : α → Prop\na : α\nind : ∀ (x : α), (∀ (y : α), r y x → C y) → C x\n⊢ C a","decl":"/-- Induction on a well-founded relation. -/\ntheorem induction {C : α → Prop} (a : α) (ind : ∀ x, (∀ y, r y x → C y) → C x) : C a :=\n  wf.induction _ ind\n\n"}
{"name":"IsWellFounded.apply","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellFounded α r\na : α\n⊢ Acc r a","decl":"/-- All values are accessible under the well-founded relation. -/\ntheorem apply : ∀ a, Acc r a :=\n  wf.apply\n\n"}
{"name":"IsWellFounded.fix_eq","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellFounded α r\nC : α → Sort u_1\nF : (x : α) → ((y : α) → r y x → C y) → C x\nx : α\n⊢ Eq (IsWellFounded.fix r F x) (F x fun y x => IsWellFounded.fix r F y)","decl":"/-- The value from `IsWellFounded.fix` is built from the previous ones as specified. -/\ntheorem fix_eq {C : α → Sort*} (F : ∀ x : α, (∀ y : α, r y x → C y) → C x) :\n    ∀ x, fix r F x = F x fun y _ => fix r F y :=\n  wf.fix_eq F\n\n"}
{"name":"WellFounded.asymmetric","module":"Mathlib.Order.RelClasses","initialProofState":"α : Sort u_1\nr : α → α → Prop\nh : WellFounded r\na b : α\na✝ : r a b\n⊢ Not (r b a)","decl":"theorem WellFounded.asymmetric {α : Sort*} {r : α → α → Prop} (h : WellFounded r) (a b) :\n    r a b → ¬r b a :=\n  @WellFoundedRelation.asymmetric _ ⟨_, h⟩ _ _\n\n"}
{"name":"WellFounded.asymmetric₃","module":"Mathlib.Order.RelClasses","initialProofState":"α : Sort u_1\nr : α → α → Prop\nh : WellFounded r\na b c : α\na✝¹ : r a b\na✝ : r b c\n⊢ Not (r c a)","decl":"theorem WellFounded.asymmetric₃ {α : Sort*} {r : α → α → Prop} (h : WellFounded r) (a b c) :\n    r a b → r b c → ¬r c a :=\n  @WellFoundedRelation.asymmetric₃ _ ⟨_, h⟩ _ _ _\n\n-- see Note [lower instance priority]\n"}
{"name":"instIsAsymmOfIsWellFounded","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellFounded α r\n⊢ IsAsymm α r","decl":"instance (priority := 100) (r : α → α → Prop) [IsWellFounded α r] : IsAsymm α r :=\n  ⟨IsWellFounded.wf.asymmetric⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"instIsIrreflOfIsWellFounded","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellFounded α r\n⊢ IsIrrefl α r","decl":"instance (priority := 100) (r : α → α → Prop) [IsWellFounded α r] : IsIrrefl α r :=\n  IsAsymm.isIrrefl\n\n"}
{"name":"instIsWellFoundedTransGen","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ni : IsWellFounded α r\n⊢ IsWellFounded α (Relation.TransGen r)","decl":"instance (r : α → α → Prop) [i : IsWellFounded α r] : IsWellFounded α (Relation.TransGen r) :=\n  ⟨i.wf.transGen⟩\n\n"}
{"name":"wellFounded_lt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : LT α\ninst✝ : WellFoundedLT α\n⊢ WellFounded fun x1 x2 => LT.lt x1 x2","decl":"lemma wellFounded_lt [LT α] [WellFoundedLT α] : @WellFounded α (· < ·) := IsWellFounded.wf\n"}
{"name":"wellFounded_gt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : LT α\ninst✝ : WellFoundedGT α\n⊢ WellFounded fun x1 x2 => GT.gt x1 x2","decl":"lemma wellFounded_gt [LT α] [WellFoundedGT α] : @WellFounded α (· > ·) := IsWellFounded.wf\n\n-- See note [lower instance priority]\n"}
{"name":"instWellFoundedGTOrderDualOfWellFoundedLT","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u_1\ninst✝ : LT α\nh : WellFoundedLT α\n⊢ WellFoundedGT (OrderDual α)","decl":"instance (priority := 100) (α : Type*) [LT α] [h : WellFoundedLT α] : WellFoundedGT αᵒᵈ :=\n  h\n\n-- See note [lower instance priority]\n"}
{"name":"instWellFoundedLTOrderDualOfWellFoundedGT","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u_1\ninst✝ : LT α\nh : WellFoundedGT α\n⊢ WellFoundedLT (OrderDual α)","decl":"instance (priority := 100) (α : Type*) [LT α] [h : WellFoundedGT α] : WellFoundedLT αᵒᵈ :=\n  h\n\n"}
{"name":"wellFoundedGT_dual_iff","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u_1\ninst✝ : LT α\n⊢ Iff (WellFoundedGT (OrderDual α)) (WellFoundedLT α)","decl":"theorem wellFoundedGT_dual_iff (α : Type*) [LT α] : WellFoundedGT αᵒᵈ ↔ WellFoundedLT α :=\n  ⟨fun h => ⟨h.wf⟩, fun h => ⟨h.wf⟩⟩\n\n"}
{"name":"wellFoundedLT_dual_iff","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u_1\ninst✝ : LT α\n⊢ Iff (WellFoundedLT (OrderDual α)) (WellFoundedGT α)","decl":"theorem wellFoundedLT_dual_iff (α : Type*) [LT α] : WellFoundedLT αᵒᵈ ↔ WellFoundedGT α :=\n  ⟨fun h => ⟨h.wf⟩, fun h => ⟨h.wf⟩⟩\n\n"}
{"name":"IsWellOrder.toIsWellFounded","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\nself : IsWellOrder α r\n⊢ IsWellFounded α r","decl":"/-- A well order is a well-founded linear order. -/\nclass IsWellOrder (α : Type u) (r : α → α → Prop) extends\n  IsTrichotomous α r, IsTrans α r, IsWellFounded α r : Prop\n\n-- see Note [lower instance priority]\n"}
{"name":"IsWellOrder.toIsTrichotomous","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\nself : IsWellOrder α r\n⊢ IsTrichotomous α r","decl":"/-- A well order is a well-founded linear order. -/\nclass IsWellOrder (α : Type u) (r : α → α → Prop) extends\n  IsTrichotomous α r, IsTrans α r, IsWellFounded α r : Prop\n\n-- see Note [lower instance priority]\n"}
{"name":"IsWellOrder.toIsTrans","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\nself : IsWellOrder α r\n⊢ IsTrans α r","decl":"/-- A well order is a well-founded linear order. -/\nclass IsWellOrder (α : Type u) (r : α → α → Prop) extends\n  IsTrichotomous α r, IsTrans α r, IsWellFounded α r : Prop\n\n-- see Note [lower instance priority]\n"}
{"name":"instIsStrictTotalOrderOfIsWellOrder","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsWellOrder α r\n⊢ IsStrictTotalOrder α r","decl":"instance (priority := 100) {α} (r : α → α → Prop) [IsWellOrder α r] :\n    IsStrictTotalOrder α r where\n\n-- see Note [lower instance priority]\n"}
{"name":"instIsTrichotomousOfIsWellOrder","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsWellOrder α r\n⊢ IsTrichotomous α r","decl":"instance (priority := 100) {α} (r : α → α → Prop) [IsWellOrder α r] : IsTrichotomous α r := by\n  infer_instance\n\n-- see Note [lower instance priority]\n"}
{"name":"instIsTransOfIsWellOrder","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsWellOrder α r\n⊢ IsTrans α r","decl":"instance (priority := 100) {α} (r : α → α → Prop) [IsWellOrder α r] : IsTrans α r := by\n  infer_instance\n\n-- see Note [lower instance priority]\n"}
{"name":"instIsIrreflOfIsWellOrder","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsWellOrder α r\n⊢ IsIrrefl α r","decl":"instance (priority := 100) {α} (r : α → α → Prop) [IsWellOrder α r] : IsIrrefl α r := by\n  infer_instance\n\n-- see Note [lower instance priority]\n"}
{"name":"instIsAsymmOfIsWellOrder","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsWellOrder α r\n⊢ IsAsymm α r","decl":"instance (priority := 100) {α} (r : α → α → Prop) [IsWellOrder α r] : IsAsymm α r := by\n  infer_instance\n\n"}
{"name":"WellFoundedLT.induction","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : LT α\ninst✝ : WellFoundedLT α\nC : α → Prop\na : α\nind : ∀ (x : α), (∀ (y : α), LT.lt y x → C y) → C x\n⊢ C a","decl":"/-- Inducts on a well-founded `<` relation. -/\ntheorem induction {C : α → Prop} (a : α) (ind : ∀ x, (∀ y, y < x → C y) → C x) : C a :=\n  IsWellFounded.induction _ _ ind\n\n"}
{"name":"WellFoundedLT.apply","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : LT α\ninst✝ : WellFoundedLT α\na : α\n⊢ Acc (fun x1 x2 => LT.lt x1 x2) a","decl":"/-- All values are accessible under the well-founded `<`. -/\ntheorem apply : ∀ a : α, Acc (· < ·) a :=\n  IsWellFounded.apply _\n\n"}
{"name":"WellFoundedLT.fix_eq","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : LT α\ninst✝ : WellFoundedLT α\nC : α → Sort u_1\nF : (x : α) → ((y : α) → LT.lt y x → C y) → C x\nx : α\n⊢ Eq (WellFoundedLT.fix F x) (F x fun y x => WellFoundedLT.fix F y)","decl":"/-- The value from `WellFoundedLT.fix` is built from the previous ones as specified. -/\ntheorem fix_eq {C : α → Sort*} (F : ∀ x : α, (∀ y : α, y < x → C y) → C x) :\n    ∀ x, fix F x = F x fun y _ => fix F y :=\n  IsWellFounded.fix_eq _ F\n\n"}
{"name":"WellFoundedGT.induction","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : LT α\ninst✝ : WellFoundedGT α\nC : α → Prop\na : α\nind : ∀ (x : α), (∀ (y : α), LT.lt x y → C y) → C x\n⊢ C a","decl":"/-- Inducts on a well-founded `>` relation. -/\ntheorem induction {C : α → Prop} (a : α) (ind : ∀ x, (∀ y, x < y → C y) → C x) : C a :=\n  IsWellFounded.induction _ _ ind\n\n"}
{"name":"WellFoundedGT.apply","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : LT α\ninst✝ : WellFoundedGT α\na : α\n⊢ Acc (fun x1 x2 => GT.gt x1 x2) a","decl":"/-- All values are accessible under the well-founded `>`. -/\ntheorem apply : ∀ a : α, Acc (· > ·) a :=\n  IsWellFounded.apply _\n\n"}
{"name":"WellFoundedGT.fix_eq","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : LT α\ninst✝ : WellFoundedGT α\nC : α → Sort u_1\nF : (x : α) → ((y : α) → LT.lt x y → C y) → C x\nx : α\n⊢ Eq (WellFoundedGT.fix F x) (F x fun y x => WellFoundedGT.fix F y)","decl":"/-- The value from `WellFoundedGT.fix` is built from the successive ones as specified. -/\ntheorem fix_eq {C : α → Sort*} (F : ∀ x : α, (∀ y : α, x < y → C y) → C x) :\n    ∀ x, fix F x = F x fun y _ => fix F y :=\n  IsWellFounded.fix_eq _ F\n\n"}
{"name":"Subsingleton.isWellOrder","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Subsingleton α\nr : α → α → Prop\nhr : IsIrrefl α r\n⊢ IsWellOrder α r","decl":"theorem Subsingleton.isWellOrder [Subsingleton α] (r : α → α → Prop) [hr : IsIrrefl α r] :\n    IsWellOrder α r :=\n  { hr with\n    trichotomous := fun a b => Or.inr <| Or.inl <| Subsingleton.elim a b,\n    trans := fun a b _ h => (not_rel_of_subsingleton r a b h).elim,\n    wf := ⟨fun a => ⟨_, fun y h => (not_rel_of_subsingleton r y a h).elim⟩⟩ }\n\n"}
{"name":"instIsWellOrderEmptyRelationOfSubsingleton","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Subsingleton α\n⊢ IsWellOrder α EmptyRelation","decl":"instance [Subsingleton α] : IsWellOrder α EmptyRelation :=\n  Subsingleton.isWellOrder _\n\n"}
{"name":"instIsWellOrderOfIsEmpty","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : IsEmpty α\nr : α → α → Prop\n⊢ IsWellOrder α r","decl":"instance (priority := 100) [IsEmpty α] (r : α → α → Prop) : IsWellOrder α r where\n  trichotomous := isEmptyElim\n  trans := isEmptyElim\n  wf := wellFounded_of_isEmpty r\n\n"}
{"name":"Prod.Lex.instIsWellFounded","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellFounded α r\ninst✝ : IsWellFounded β s\n⊢ IsWellFounded (Prod α β) (Prod.Lex r s)","decl":"instance Prod.Lex.instIsWellFounded [IsWellFounded α r] [IsWellFounded β s] :\n    IsWellFounded (α × β) (Prod.Lex r s) :=\n  ⟨IsWellFounded.wf.prod_lex IsWellFounded.wf⟩\n\n"}
{"name":"instIsWellOrderProdLex","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\ns : β → β → Prop\ninst✝¹ : IsWellOrder α r\ninst✝ : IsWellOrder β s\n⊢ IsWellOrder (Prod α β) (Prod.Lex r s)","decl":"instance [IsWellOrder α r] [IsWellOrder β s] : IsWellOrder (α × β) (Prod.Lex r s) where\n  trichotomous := fun ⟨a₁, a₂⟩ ⟨b₁, b₂⟩ =>\n    match @trichotomous _ r _ a₁ b₁ with\n    | Or.inl h₁ => Or.inl <| Prod.Lex.left _ _ h₁\n    | Or.inr (Or.inr h₁) => Or.inr <| Or.inr <| Prod.Lex.left _ _ h₁\n    | Or.inr (Or.inl (.refl _)) =>\n        match @trichotomous _ s _ a₂ b₂ with\n        | Or.inl h => Or.inl <| Prod.Lex.right _ h\n        | Or.inr (Or.inr h) => Or.inr <| Or.inr <| Prod.Lex.right _ h\n        | Or.inr (Or.inl (.refl _)) => Or.inr <| Or.inl rfl\n  trans a b c h₁ h₂ := by\n    rcases h₁ with ⟨a₂, b₂, ab⟩ | ⟨a₁, ab⟩ <;> rcases h₂ with ⟨c₁, c₂, bc⟩ | ⟨c₂, bc⟩\n    exacts [.left _ _ (_root_.trans ab bc), .left _ _ ab, .left _ _ bc,\n      .right _ (_root_.trans ab bc)]\n\n"}
{"name":"instIsWellFoundedInvImage","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\ninst✝ : IsWellFounded α r\nf : β → α\n⊢ IsWellFounded β (InvImage r f)","decl":"instance (r : α → α → Prop) [IsWellFounded α r] (f : β → α) : IsWellFounded _ (InvImage r f) :=\n  ⟨InvImage.wf f IsWellFounded.wf⟩\n\n"}
{"name":"instIsWellFoundedInvImageNatLt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nf : α → Nat\n⊢ IsWellFounded α (InvImage (fun x1 x2 => LT.lt x1 x2) f)","decl":"instance (f : α → ℕ) : IsWellFounded _ (InvImage (· < ·) f) :=\n  ⟨(measure f).wf⟩\n\n"}
{"name":"Subrelation.isWellFounded","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ninst✝ : IsWellFounded α r\ns : α → α → Prop\nh : Subrelation s r\n⊢ IsWellFounded α s","decl":"theorem Subrelation.isWellFounded (r : α → α → Prop) [IsWellFounded α r] {s : α → α → Prop}\n    (h : Subrelation s r) : IsWellFounded α s :=\n  ⟨h.wf IsWellFounded.wf⟩\n\n"}
{"name":"Prod.wellFoundedLT'","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : PartialOrder α\ninst✝² : WellFoundedLT α\ninst✝¹ : Preorder β\ninst✝ : WellFoundedLT β\n⊢ WellFoundedLT (Prod α β)","decl":"/-- See `Prod.wellFoundedLT` for a version that only requires `Preorder α`. -/\ntheorem Prod.wellFoundedLT' [PartialOrder α] [WellFoundedLT α] [Preorder β] [WellFoundedLT β] :\n    WellFoundedLT (α × β) :=\n  Subrelation.isWellFounded (Prod.Lex (· < ·) (· < ·))\n    fun {x y} h ↦ (Prod.lt_iff.mp h).elim (fun h ↦ .left _ _ h.1)\n    fun h ↦ h.1.lt_or_eq.elim (.left _ _) <| by cases x; cases y; rintro rfl; exact .right _ h.2\n\n"}
{"name":"Prod.wellFoundedGT'","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : PartialOrder α\ninst✝² : WellFoundedGT α\ninst✝¹ : Preorder β\ninst✝ : WellFoundedGT β\n⊢ WellFoundedGT (Prod α β)","decl":"/-- See `Prod.wellFoundedGT` for a version that only requires `Preorder α`. -/\ntheorem Prod.wellFoundedGT' [PartialOrder α] [WellFoundedGT α] [Preorder β] [WellFoundedGT β] :\n    WellFoundedGT (α × β) :=\n  @Prod.wellFoundedLT' αᵒᵈ βᵒᵈ _ _ _ _\n\n"}
{"name":"Set.not_bounded_iff","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ns : Set α\n⊢ Iff (Not (Set.Bounded r s)) (Set.Unbounded r s)","decl":"@[simp]\ntheorem not_bounded_iff {r : α → α → Prop} (s : Set α) : ¬Bounded r s ↔ Unbounded r s := by\n  simp only [Bounded, Unbounded, not_forall, not_exists, exists_prop, not_and, not_not]\n\n"}
{"name":"Set.not_unbounded_iff","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr : α → α → Prop\ns : Set α\n⊢ Iff (Not (Set.Unbounded r s)) (Set.Bounded r s)","decl":"@[simp]\ntheorem not_unbounded_iff {r : α → α → Prop} (s : Set α) : ¬Unbounded r s ↔ Bounded r s := by\n  rw [not_iff_comm, not_bounded_iff]\n\n"}
{"name":"Set.unbounded_of_isEmpty","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : IsEmpty α\nr : α → α → Prop\ns : Set α\n⊢ Set.Unbounded r s","decl":"theorem unbounded_of_isEmpty [IsEmpty α] {r : α → α → Prop} (s : Set α) : Unbounded r s :=\n  isEmptyElim\n\n"}
{"name":"Order.Preimage.instIsRefl","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\ninst✝ : IsRefl α r\nf : β → α\n⊢ IsRefl β (Order.Preimage f r)","decl":"instance instIsRefl {r : α → α → Prop} [IsRefl α r] {f : β → α} : IsRefl β (f ⁻¹'o r) :=\n  ⟨fun a => refl_of r (f a)⟩\n\n"}
{"name":"Order.Preimage.instIsTrans","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nβ : Type v\nr : α → α → Prop\ninst✝ : IsTrans α r\nf : β → α\n⊢ IsTrans β (Order.Preimage f r)","decl":"instance instIsTrans {r : α → α → Prop} [IsTrans α r] {f : β → α} : IsTrans β (f ⁻¹'o r) :=\n  ⟨fun _ _ _ => trans_of r⟩\n\n"}
{"name":"IsNonstrictStrictOrder.right_iff_left_not_left","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u_1\nr : semiOutParam (α → α → Prop)\ns : α → α → Prop\nself : IsNonstrictStrictOrder α r s\na b : α\n⊢ Iff (s a b) (And (r a b) (Not (r b a)))","decl":"/-- An unbundled relation class stating that `r` is the nonstrict relation corresponding to the\nstrict relation `s`. Compare `Preorder.lt_iff_le_not_le`. This is mostly meant to provide dot\nnotation on `(⊆)` and `(⊂)`. -/\nclass IsNonstrictStrictOrder (α : Type*) (r : semiOutParam (α → α → Prop)) (s : α → α → Prop) :\n    Prop where\n  /-- The relation `r` is the nonstrict relation corresponding to the strict relation `s`. -/\n  right_iff_left_not_left (a b : α) : s a b ↔ r a b ∧ ¬r b a\n\n"}
{"name":"right_iff_left_not_left","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr s : α → α → Prop\ninst✝ : IsNonstrictStrictOrder α r s\na b : α\n⊢ Iff (s a b) (And (r a b) (Not (r b a)))","decl":"theorem right_iff_left_not_left {r s : α → α → Prop} [IsNonstrictStrictOrder α r s] {a b : α} :\n    s a b ↔ r a b ∧ ¬r b a :=\n  IsNonstrictStrictOrder.right_iff_left_not_left _ _\n\n"}
{"name":"right_iff_left_not_left_of","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr s : α → α → Prop\ninst✝ : IsNonstrictStrictOrder α r s\na b : α\n⊢ Iff (s a b) (And (r a b) (Not (r b a)))","decl":"/-- A version of `right_iff_left_not_left` with explicit `r` and `s`. -/\ntheorem right_iff_left_not_left_of (r s : α → α → Prop) [IsNonstrictStrictOrder α r s] {a b : α} :\n    s a b ↔ r a b ∧ ¬r b a :=\n  right_iff_left_not_left\n\n"}
{"name":"instIsIrreflOfIsNonstrictStrictOrder","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\nr s : α → α → Prop\ninst✝ : IsNonstrictStrictOrder α r s\n⊢ IsIrrefl α s","decl":"instance {s : α → α → Prop} [IsNonstrictStrictOrder α r s] : IsIrrefl α s :=\n  ⟨fun _ h => ((right_iff_left_not_left_of r s).1 h).2 ((right_iff_left_not_left_of r s).1 h).1⟩\n\n"}
{"name":"subset_of_eq_of_subset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : HasSubset α\na b c : α\nhab : Eq a b\nhbc : HasSubset.Subset b c\n⊢ HasSubset.Subset a c","decl":"lemma subset_of_eq_of_subset (hab : a = b) (hbc : b ⊆ c) : a ⊆ c := by rwa [hab]\n\n"}
{"name":"subset_of_subset_of_eq","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : HasSubset α\na b c : α\nhab : HasSubset.Subset a b\nhbc : Eq b c\n⊢ HasSubset.Subset a c","decl":"lemma subset_of_subset_of_eq (hab : a ⊆ b) (hbc : b = c) : a ⊆ c := by rwa [← hbc]\n\n"}
{"name":"subset_refl","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSubset α\ninst✝ : IsRefl α fun x1 x2 => HasSubset.Subset x1 x2\na : α\n⊢ HasSubset.Subset a a","decl":"@[refl, simp]\nlemma subset_refl [IsRefl α (· ⊆ ·)] (a : α) : a ⊆ a := refl _\n\n"}
{"name":"subset_rfl","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSubset α\na : α\ninst✝ : IsRefl α fun x1 x2 => HasSubset.Subset x1 x2\n⊢ HasSubset.Subset a a","decl":"lemma subset_rfl [IsRefl α (· ⊆ ·)] : a ⊆ a := refl _\n\n"}
{"name":"subset_of_eq","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSubset α\na b : α\ninst✝ : IsRefl α fun x1 x2 => HasSubset.Subset x1 x2\na✝ : Eq a b\n⊢ HasSubset.Subset a b","decl":"lemma subset_of_eq [IsRefl α (· ⊆ ·)] : a = b → a ⊆ b := fun h => h ▸ subset_rfl\n\n"}
{"name":"superset_of_eq","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSubset α\na b : α\ninst✝ : IsRefl α fun x1 x2 => HasSubset.Subset x1 x2\na✝ : Eq a b\n⊢ HasSubset.Subset b a","decl":"lemma superset_of_eq [IsRefl α (· ⊆ ·)] : a = b → b ⊆ a := fun h => h ▸ subset_rfl\n\n"}
{"name":"ne_of_not_subset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSubset α\na b : α\ninst✝ : IsRefl α fun x1 x2 => HasSubset.Subset x1 x2\na✝ : Not (HasSubset.Subset a b)\n⊢ Ne a b","decl":"lemma ne_of_not_subset [IsRefl α (· ⊆ ·)] : ¬a ⊆ b → a ≠ b := mt subset_of_eq\n\n"}
{"name":"ne_of_not_superset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSubset α\na b : α\ninst✝ : IsRefl α fun x1 x2 => HasSubset.Subset x1 x2\na✝ : Not (HasSubset.Subset a b)\n⊢ Ne b a","decl":"lemma ne_of_not_superset [IsRefl α (· ⊆ ·)] : ¬a ⊆ b → b ≠ a := mt superset_of_eq\n\n"}
{"name":"subset_trans","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSubset α\ninst✝ : IsTrans α fun x1 x2 => HasSubset.Subset x1 x2\na b c : α\na✝¹ : HasSubset.Subset a b\na✝ : HasSubset.Subset b c\n⊢ HasSubset.Subset a c","decl":"@[trans]\nlemma subset_trans [IsTrans α (· ⊆ ·)] {a b c : α} : a ⊆ b → b ⊆ c → a ⊆ c := _root_.trans\n\n"}
{"name":"subset_antisymm","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSubset α\na b : α\ninst✝ : IsAntisymm α fun x1 x2 => HasSubset.Subset x1 x2\na✝¹ : HasSubset.Subset a b\na✝ : HasSubset.Subset b a\n⊢ Eq a b","decl":"lemma subset_antisymm [IsAntisymm α (· ⊆ ·)] : a ⊆ b → b ⊆ a → a = b := antisymm\n\n"}
{"name":"superset_antisymm","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSubset α\na b : α\ninst✝ : IsAntisymm α fun x1 x2 => HasSubset.Subset x1 x2\na✝¹ : HasSubset.Subset a b\na✝ : HasSubset.Subset b a\n⊢ Eq b a","decl":"lemma superset_antisymm [IsAntisymm α (· ⊆ ·)] : a ⊆ b → b ⊆ a → b = a := antisymm'\n\n"}
{"name":"Eq.trans_subset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : HasSubset α\na b c : α\nhab : Eq a b\nhbc : HasSubset.Subset b c\n⊢ HasSubset.Subset a c","decl":"alias Eq.trans_subset := subset_of_eq_of_subset\n\n"}
{"name":"HasSubset.subset.trans_eq","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : HasSubset α\na b c : α\nhab : HasSubset.Subset a b\nhbc : Eq b c\n⊢ HasSubset.Subset a c","decl":"alias HasSubset.subset.trans_eq := subset_of_subset_of_eq\n\n"}
{"name":"Eq.subset'","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSubset α\na b : α\ninst✝ : IsRefl α fun x1 x2 => HasSubset.Subset x1 x2\na✝ : Eq a b\n⊢ HasSubset.Subset a b","decl":"alias Eq.subset' := subset_of_eq --TODO: Fix it and kill `Eq.subset`\n\n"}
{"name":"Eq.superset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSubset α\na b : α\ninst✝ : IsRefl α fun x1 x2 => HasSubset.Subset x1 x2\na✝ : Eq a b\n⊢ HasSubset.Subset b a","decl":"alias Eq.superset := superset_of_eq\n\n"}
{"name":"HasSubset.Subset.trans","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSubset α\ninst✝ : IsTrans α fun x1 x2 => HasSubset.Subset x1 x2\na b c : α\na✝¹ : HasSubset.Subset a b\na✝ : HasSubset.Subset b c\n⊢ HasSubset.Subset a c","decl":"alias HasSubset.Subset.trans := subset_trans\n\n"}
{"name":"HasSubset.Subset.antisymm","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSubset α\na b : α\ninst✝ : IsAntisymm α fun x1 x2 => HasSubset.Subset x1 x2\na✝¹ : HasSubset.Subset a b\na✝ : HasSubset.Subset b a\n⊢ Eq a b","decl":"alias HasSubset.Subset.antisymm := subset_antisymm\n\n"}
{"name":"HasSubset.Subset.antisymm'","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSubset α\na b : α\ninst✝ : IsAntisymm α fun x1 x2 => HasSubset.Subset x1 x2\na✝¹ : HasSubset.Subset a b\na✝ : HasSubset.Subset b a\n⊢ Eq b a","decl":"alias HasSubset.Subset.antisymm' := superset_antisymm\n\n"}
{"name":"subset_antisymm_iff","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝² : HasSubset α\na b : α\ninst✝¹ : IsRefl α fun x1 x2 => HasSubset.Subset x1 x2\ninst✝ : IsAntisymm α fun x1 x2 => HasSubset.Subset x1 x2\n⊢ Iff (Eq a b) (And (HasSubset.Subset a b) (HasSubset.Subset b a))","decl":"theorem subset_antisymm_iff [IsRefl α (· ⊆ ·)] [IsAntisymm α (· ⊆ ·)] : a = b ↔ a ⊆ b ∧ b ⊆ a :=\n  ⟨fun h => ⟨h.subset', h.superset⟩, fun h => h.1.antisymm h.2⟩\n\n"}
{"name":"superset_antisymm_iff","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝² : HasSubset α\na b : α\ninst✝¹ : IsRefl α fun x1 x2 => HasSubset.Subset x1 x2\ninst✝ : IsAntisymm α fun x1 x2 => HasSubset.Subset x1 x2\n⊢ Iff (Eq a b) (And (HasSubset.Subset b a) (HasSubset.Subset a b))","decl":"theorem superset_antisymm_iff [IsRefl α (· ⊆ ·)] [IsAntisymm α (· ⊆ ·)] : a = b ↔ b ⊆ a ∧ a ⊆ b :=\n  ⟨fun h => ⟨h.superset, h.subset'⟩, fun h => h.1.antisymm' h.2⟩\n\n"}
{"name":"ssubset_of_eq_of_ssubset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : HasSSubset α\na b c : α\nhab : Eq a b\nhbc : HasSSubset.SSubset b c\n⊢ HasSSubset.SSubset a c","decl":"lemma ssubset_of_eq_of_ssubset (hab : a = b) (hbc : b ⊂ c) : a ⊂ c := by rwa [hab]\n\n"}
{"name":"ssubset_of_ssubset_of_eq","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : HasSSubset α\na b c : α\nhab : HasSSubset.SSubset a b\nhbc : Eq b c\n⊢ HasSSubset.SSubset a c","decl":"lemma ssubset_of_ssubset_of_eq (hab : a ⊂ b) (hbc : b = c) : a ⊂ c := by rwa [← hbc]\n\n"}
{"name":"ssubset_irrefl","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSSubset α\ninst✝ : IsIrrefl α fun x1 x2 => HasSSubset.SSubset x1 x2\na : α\n⊢ Not (HasSSubset.SSubset a a)","decl":"lemma ssubset_irrefl [IsIrrefl α (· ⊂ ·)] (a : α) : ¬a ⊂ a := irrefl _\n\n"}
{"name":"ssubset_irrfl","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSSubset α\ninst✝ : IsIrrefl α fun x1 x2 => HasSSubset.SSubset x1 x2\na : α\n⊢ Not (HasSSubset.SSubset a a)","decl":"lemma ssubset_irrfl [IsIrrefl α (· ⊂ ·)] {a : α} : ¬a ⊂ a := irrefl _\n\n"}
{"name":"ne_of_ssubset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSSubset α\ninst✝ : IsIrrefl α fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\na✝ : HasSSubset.SSubset a b\n⊢ Ne a b","decl":"lemma ne_of_ssubset [IsIrrefl α (· ⊂ ·)] {a b : α} : a ⊂ b → a ≠ b := ne_of_irrefl\n\n"}
{"name":"ne_of_ssuperset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSSubset α\ninst✝ : IsIrrefl α fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\na✝ : HasSSubset.SSubset a b\n⊢ Ne b a","decl":"lemma ne_of_ssuperset [IsIrrefl α (· ⊂ ·)] {a b : α} : a ⊂ b → b ≠ a := ne_of_irrefl'\n\n"}
{"name":"ssubset_trans","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSSubset α\ninst✝ : IsTrans α fun x1 x2 => HasSSubset.SSubset x1 x2\na b c : α\na✝¹ : HasSSubset.SSubset a b\na✝ : HasSSubset.SSubset b c\n⊢ HasSSubset.SSubset a c","decl":"@[trans]\nlemma ssubset_trans [IsTrans α (· ⊂ ·)] {a b c : α} : a ⊂ b → b ⊂ c → a ⊂ c := _root_.trans\n\n"}
{"name":"ssubset_asymm","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSSubset α\ninst✝ : IsAsymm α fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\na✝ : HasSSubset.SSubset a b\n⊢ Not (HasSSubset.SSubset b a)","decl":"lemma ssubset_asymm [IsAsymm α (· ⊂ ·)] {a b : α} : a ⊂ b → ¬b ⊂ a := asymm\n\n"}
{"name":"Eq.trans_ssubset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : HasSSubset α\na b c : α\nhab : Eq a b\nhbc : HasSSubset.SSubset b c\n⊢ HasSSubset.SSubset a c","decl":"alias Eq.trans_ssubset := ssubset_of_eq_of_ssubset\n\n"}
{"name":"HasSSubset.SSubset.trans_eq","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : HasSSubset α\na b c : α\nhab : HasSSubset.SSubset a b\nhbc : Eq b c\n⊢ HasSSubset.SSubset a c","decl":"alias HasSSubset.SSubset.trans_eq := ssubset_of_ssubset_of_eq\n\n"}
{"name":"HasSSubset.SSubset.false","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSSubset α\ninst✝ : IsIrrefl α fun x1 x2 => HasSSubset.SSubset x1 x2\na : α\n⊢ Not (HasSSubset.SSubset a a)","decl":"alias HasSSubset.SSubset.false := ssubset_irrfl\n\n"}
{"name":"HasSSubset.SSubset.ne","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSSubset α\ninst✝ : IsIrrefl α fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\na✝ : HasSSubset.SSubset a b\n⊢ Ne a b","decl":"alias HasSSubset.SSubset.ne := ne_of_ssubset\n\n"}
{"name":"HasSSubset.SSubset.ne'","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSSubset α\ninst✝ : IsIrrefl α fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\na✝ : HasSSubset.SSubset a b\n⊢ Ne b a","decl":"alias HasSSubset.SSubset.ne' := ne_of_ssuperset\n\n"}
{"name":"HasSSubset.SSubset.trans","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSSubset α\ninst✝ : IsTrans α fun x1 x2 => HasSSubset.SSubset x1 x2\na b c : α\na✝¹ : HasSSubset.SSubset a b\na✝ : HasSSubset.SSubset b c\n⊢ HasSSubset.SSubset a c","decl":"alias HasSSubset.SSubset.trans := ssubset_trans\n\n"}
{"name":"HasSSubset.SSubset.asymm","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : HasSSubset α\ninst✝ : IsAsymm α fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\na✝ : HasSSubset.SSubset a b\n⊢ Not (HasSSubset.SSubset b a)","decl":"alias HasSSubset.SSubset.asymm := ssubset_asymm\n\n"}
{"name":"ssubset_iff_subset_not_subset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝² : HasSubset α\ninst✝¹ : HasSSubset α\ninst✝ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\n⊢ Iff (HasSSubset.SSubset a b) (And (HasSubset.Subset a b) (Not (HasSubset.Subset b a)))","decl":"theorem ssubset_iff_subset_not_subset : a ⊂ b ↔ a ⊆ b ∧ ¬b ⊆ a :=\n  right_iff_left_not_left\n\n"}
{"name":"subset_of_ssubset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝² : HasSubset α\ninst✝¹ : HasSSubset α\ninst✝ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\nh : HasSSubset.SSubset a b\n⊢ HasSubset.Subset a b","decl":"theorem subset_of_ssubset (h : a ⊂ b) : a ⊆ b :=\n  (ssubset_iff_subset_not_subset.1 h).1\n\n"}
{"name":"not_subset_of_ssubset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝² : HasSubset α\ninst✝¹ : HasSSubset α\ninst✝ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\nh : HasSSubset.SSubset a b\n⊢ Not (HasSubset.Subset b a)","decl":"theorem not_subset_of_ssubset (h : a ⊂ b) : ¬b ⊆ a :=\n  (ssubset_iff_subset_not_subset.1 h).2\n\n"}
{"name":"not_ssubset_of_subset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝² : HasSubset α\ninst✝¹ : HasSSubset α\ninst✝ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\nh : HasSubset.Subset a b\n⊢ Not (HasSSubset.SSubset b a)","decl":"theorem not_ssubset_of_subset (h : a ⊆ b) : ¬b ⊂ a := fun h' => not_subset_of_ssubset h' h\n\n"}
{"name":"ssubset_of_subset_not_subset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝² : HasSubset α\ninst✝¹ : HasSSubset α\ninst✝ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\nh₁ : HasSubset.Subset a b\nh₂ : Not (HasSubset.Subset b a)\n⊢ HasSSubset.SSubset a b","decl":"theorem ssubset_of_subset_not_subset (h₁ : a ⊆ b) (h₂ : ¬b ⊆ a) : a ⊂ b :=\n  ssubset_iff_subset_not_subset.2 ⟨h₁, h₂⟩\n\n"}
{"name":"HasSSubset.SSubset.subset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝² : HasSubset α\ninst✝¹ : HasSSubset α\ninst✝ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\nh : HasSSubset.SSubset a b\n⊢ HasSubset.Subset a b","decl":"alias HasSSubset.SSubset.subset := subset_of_ssubset\n\n"}
{"name":"HasSSubset.SSubset.not_subset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝² : HasSubset α\ninst✝¹ : HasSSubset α\ninst✝ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\nh : HasSSubset.SSubset a b\n⊢ Not (HasSubset.Subset b a)","decl":"alias HasSSubset.SSubset.not_subset := not_subset_of_ssubset\n\n"}
{"name":"HasSubset.Subset.not_ssubset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝² : HasSubset α\ninst✝¹ : HasSSubset α\ninst✝ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\nh : HasSubset.Subset a b\n⊢ Not (HasSSubset.SSubset b a)","decl":"alias HasSubset.Subset.not_ssubset := not_ssubset_of_subset\n\n"}
{"name":"HasSubset.Subset.ssubset_of_not_subset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝² : HasSubset α\ninst✝¹ : HasSSubset α\ninst✝ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\nh₁ : HasSubset.Subset a b\nh₂ : Not (HasSubset.Subset b a)\n⊢ HasSSubset.SSubset a b","decl":"alias HasSubset.Subset.ssubset_of_not_subset := ssubset_of_subset_not_subset\n\n"}
{"name":"ssubset_of_subset_of_ssubset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝³ : HasSubset α\ninst✝² : HasSSubset α\ninst✝¹ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b c : α\ninst✝ : IsTrans α fun x1 x2 => HasSubset.Subset x1 x2\nh₁ : HasSubset.Subset a b\nh₂ : HasSSubset.SSubset b c\n⊢ HasSSubset.SSubset a c","decl":"theorem ssubset_of_subset_of_ssubset [IsTrans α (· ⊆ ·)] (h₁ : a ⊆ b) (h₂ : b ⊂ c) : a ⊂ c :=\n  (h₁.trans h₂.subset).ssubset_of_not_subset fun h => h₂.not_subset <| h.trans h₁\n\n"}
{"name":"ssubset_of_ssubset_of_subset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝³ : HasSubset α\ninst✝² : HasSSubset α\ninst✝¹ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b c : α\ninst✝ : IsTrans α fun x1 x2 => HasSubset.Subset x1 x2\nh₁ : HasSSubset.SSubset a b\nh₂ : HasSubset.Subset b c\n⊢ HasSSubset.SSubset a c","decl":"theorem ssubset_of_ssubset_of_subset [IsTrans α (· ⊆ ·)] (h₁ : a ⊂ b) (h₂ : b ⊆ c) : a ⊂ c :=\n  (h₁.subset.trans h₂).ssubset_of_not_subset fun h => h₁.not_subset <| h₂.trans h\n\n"}
{"name":"ssubset_of_subset_of_ne","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝³ : HasSubset α\ninst✝² : HasSSubset α\ninst✝¹ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\ninst✝ : IsAntisymm α fun x1 x2 => HasSubset.Subset x1 x2\nh₁ : HasSubset.Subset a b\nh₂ : Ne a b\n⊢ HasSSubset.SSubset a b","decl":"theorem ssubset_of_subset_of_ne [IsAntisymm α (· ⊆ ·)] (h₁ : a ⊆ b) (h₂ : a ≠ b) : a ⊂ b :=\n  h₁.ssubset_of_not_subset <| mt h₁.antisymm h₂\n\n"}
{"name":"ssubset_of_ne_of_subset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝³ : HasSubset α\ninst✝² : HasSSubset α\ninst✝¹ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\ninst✝ : IsAntisymm α fun x1 x2 => HasSubset.Subset x1 x2\nh₁ : Ne a b\nh₂ : HasSubset.Subset a b\n⊢ HasSSubset.SSubset a b","decl":"theorem ssubset_of_ne_of_subset [IsAntisymm α (· ⊆ ·)] (h₁ : a ≠ b) (h₂ : a ⊆ b) : a ⊂ b :=\n  ssubset_of_subset_of_ne h₂ h₁\n\n"}
{"name":"eq_or_ssubset_of_subset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝³ : HasSubset α\ninst✝² : HasSSubset α\ninst✝¹ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\ninst✝ : IsAntisymm α fun x1 x2 => HasSubset.Subset x1 x2\nh : HasSubset.Subset a b\n⊢ Or (Eq a b) (HasSSubset.SSubset a b)","decl":"theorem eq_or_ssubset_of_subset [IsAntisymm α (· ⊆ ·)] (h : a ⊆ b) : a = b ∨ a ⊂ b :=\n  (em (b ⊆ a)).imp h.antisymm h.ssubset_of_not_subset\n\n"}
{"name":"ssubset_or_eq_of_subset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝³ : HasSubset α\ninst✝² : HasSSubset α\ninst✝¹ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\ninst✝ : IsAntisymm α fun x1 x2 => HasSubset.Subset x1 x2\nh : HasSubset.Subset a b\n⊢ Or (HasSSubset.SSubset a b) (Eq a b)","decl":"theorem ssubset_or_eq_of_subset [IsAntisymm α (· ⊆ ·)] (h : a ⊆ b) : a ⊂ b ∨ a = b :=\n  (eq_or_ssubset_of_subset h).symm\n\n"}
{"name":"eq_of_subset_of_not_ssubset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝³ : HasSubset α\ninst✝² : HasSSubset α\ninst✝¹ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\ninst✝ : IsAntisymm α fun x1 x2 => HasSubset.Subset x1 x2\nhab : HasSubset.Subset a b\nhba : Not (HasSSubset.SSubset a b)\n⊢ Eq a b","decl":"lemma eq_of_subset_of_not_ssubset [IsAntisymm α (· ⊆ ·)] (hab : a ⊆ b) (hba : ¬ a ⊂ b) : a = b :=\n  (eq_or_ssubset_of_subset hab).resolve_right hba\n\n"}
{"name":"eq_of_superset_of_not_ssuperset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝³ : HasSubset α\ninst✝² : HasSSubset α\ninst✝¹ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\ninst✝ : IsAntisymm α fun x1 x2 => HasSubset.Subset x1 x2\nhab : HasSubset.Subset a b\nhba : Not (HasSSubset.SSubset a b)\n⊢ Eq b a","decl":"lemma eq_of_superset_of_not_ssuperset [IsAntisymm α (· ⊆ ·)] (hab : a ⊆ b) (hba : ¬ a ⊂ b) :\n    b = a := ((eq_or_ssubset_of_subset hab).resolve_right hba).symm\n\n"}
{"name":"HasSubset.Subset.trans_ssubset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝³ : HasSubset α\ninst✝² : HasSSubset α\ninst✝¹ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b c : α\ninst✝ : IsTrans α fun x1 x2 => HasSubset.Subset x1 x2\nh₁ : HasSubset.Subset a b\nh₂ : HasSSubset.SSubset b c\n⊢ HasSSubset.SSubset a c","decl":"alias HasSubset.Subset.trans_ssubset := ssubset_of_subset_of_ssubset\n\n"}
{"name":"HasSSubset.SSubset.trans_subset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝³ : HasSubset α\ninst✝² : HasSSubset α\ninst✝¹ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b c : α\ninst✝ : IsTrans α fun x1 x2 => HasSubset.Subset x1 x2\nh₁ : HasSSubset.SSubset a b\nh₂ : HasSubset.Subset b c\n⊢ HasSSubset.SSubset a c","decl":"alias HasSSubset.SSubset.trans_subset := ssubset_of_ssubset_of_subset\n\n"}
{"name":"HasSubset.Subset.ssubset_of_ne","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝³ : HasSubset α\ninst✝² : HasSSubset α\ninst✝¹ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\ninst✝ : IsAntisymm α fun x1 x2 => HasSubset.Subset x1 x2\nh₁ : HasSubset.Subset a b\nh₂ : Ne a b\n⊢ HasSSubset.SSubset a b","decl":"alias HasSubset.Subset.ssubset_of_ne := ssubset_of_subset_of_ne\n\n"}
{"name":"Ne.ssubset_of_subset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝³ : HasSubset α\ninst✝² : HasSSubset α\ninst✝¹ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\ninst✝ : IsAntisymm α fun x1 x2 => HasSubset.Subset x1 x2\nh₁ : Ne a b\nh₂ : HasSubset.Subset a b\n⊢ HasSSubset.SSubset a b","decl":"alias Ne.ssubset_of_subset := ssubset_of_ne_of_subset\n\n"}
{"name":"HasSubset.Subset.eq_or_ssubset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝³ : HasSubset α\ninst✝² : HasSSubset α\ninst✝¹ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\ninst✝ : IsAntisymm α fun x1 x2 => HasSubset.Subset x1 x2\nh : HasSubset.Subset a b\n⊢ Or (Eq a b) (HasSSubset.SSubset a b)","decl":"alias HasSubset.Subset.eq_or_ssubset := eq_or_ssubset_of_subset\n\n"}
{"name":"HasSubset.Subset.ssubset_or_eq","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝³ : HasSubset α\ninst✝² : HasSSubset α\ninst✝¹ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\ninst✝ : IsAntisymm α fun x1 x2 => HasSubset.Subset x1 x2\nh : HasSubset.Subset a b\n⊢ Or (HasSSubset.SSubset a b) (Eq a b)","decl":"alias HasSubset.Subset.ssubset_or_eq := ssubset_or_eq_of_subset\n\n"}
{"name":"HasSubset.Subset.eq_of_not_ssubset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝³ : HasSubset α\ninst✝² : HasSSubset α\ninst✝¹ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\ninst✝ : IsAntisymm α fun x1 x2 => HasSubset.Subset x1 x2\nhab : HasSubset.Subset a b\nhba : Not (HasSSubset.SSubset a b)\n⊢ Eq a b","decl":"alias HasSubset.Subset.eq_of_not_ssubset := eq_of_subset_of_not_ssubset\n"}
{"name":"HasSubset.Subset.eq_of_not_ssuperset","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝³ : HasSubset α\ninst✝² : HasSSubset α\ninst✝¹ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\ninst✝ : IsAntisymm α fun x1 x2 => HasSubset.Subset x1 x2\nhab : HasSubset.Subset a b\nhba : Not (HasSSubset.SSubset a b)\n⊢ Eq b a","decl":"alias HasSubset.Subset.eq_of_not_ssuperset := eq_of_superset_of_not_ssuperset\n\n"}
{"name":"ssubset_iff_subset_ne","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝³ : HasSubset α\ninst✝² : HasSSubset α\ninst✝¹ : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\ninst✝ : IsAntisymm α fun x1 x2 => HasSubset.Subset x1 x2\n⊢ Iff (HasSSubset.SSubset a b) (And (HasSubset.Subset a b) (Ne a b))","decl":"theorem ssubset_iff_subset_ne [IsAntisymm α (· ⊆ ·)] : a ⊂ b ↔ a ⊆ b ∧ a ≠ b :=\n  ⟨fun h => ⟨h.subset, h.ne⟩, fun h => h.1.ssubset_of_ne h.2⟩\n\n"}
{"name":"subset_iff_ssubset_or_eq","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝⁴ : HasSubset α\ninst✝³ : HasSSubset α\ninst✝² : IsNonstrictStrictOrder α (fun x1 x2 => HasSubset.Subset x1 x2) fun x1 x2 => HasSSubset.SSubset x1 x2\na b : α\ninst✝¹ : IsRefl α fun x1 x2 => HasSubset.Subset x1 x2\ninst✝ : IsAntisymm α fun x1 x2 => HasSubset.Subset x1 x2\n⊢ Iff (HasSubset.Subset a b) (Or (HasSSubset.SSubset a b) (Eq a b))","decl":"theorem subset_iff_ssubset_or_eq [IsRefl α (· ⊆ ·)] [IsAntisymm α (· ⊆ ·)] :\n    a ⊆ b ↔ a ⊂ b ∨ a = b :=\n  ⟨fun h => h.ssubset_or_eq, fun h => h.elim subset_of_ssubset subset_of_eq⟩\n\n"}
{"name":"instIsReflLe","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ IsRefl α fun x1 x2 => LE.le x1 x2","decl":"instance [Preorder α] : IsRefl α (· ≤ ·) :=\n  ⟨le_refl⟩\n\n"}
{"name":"instIsReflGe","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ IsRefl α fun x1 x2 => GE.ge x1 x2","decl":"instance [Preorder α] : IsRefl α (· ≥ ·) :=\n  IsRefl.swap _\n\n"}
{"name":"instIsTransLe","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ IsTrans α fun x1 x2 => LE.le x1 x2","decl":"instance [Preorder α] : IsTrans α (· ≤ ·) :=\n  ⟨@le_trans _ _⟩\n\n"}
{"name":"instIsTransGe","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ IsTrans α fun x1 x2 => GE.ge x1 x2","decl":"instance [Preorder α] : IsTrans α (· ≥ ·) :=\n  IsTrans.swap _\n\n"}
{"name":"instIsPreorderLe","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ IsPreorder α fun x1 x2 => LE.le x1 x2","decl":"instance [Preorder α] : IsPreorder α (· ≤ ·) where\n\n"}
{"name":"instIsPreorderGe","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ IsPreorder α fun x1 x2 => GE.ge x1 x2","decl":"instance [Preorder α] : IsPreorder α (· ≥ ·) where\n\n"}
{"name":"instIsIrreflLt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ IsIrrefl α fun x1 x2 => LT.lt x1 x2","decl":"instance [Preorder α] : IsIrrefl α (· < ·) :=\n  ⟨lt_irrefl⟩\n\n"}
{"name":"instIsIrreflGt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ IsIrrefl α fun x1 x2 => GT.gt x1 x2","decl":"instance [Preorder α] : IsIrrefl α (· > ·) :=\n  IsIrrefl.swap _\n\n"}
{"name":"instIsTransLt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ IsTrans α fun x1 x2 => LT.lt x1 x2","decl":"instance [Preorder α] : IsTrans α (· < ·) :=\n  ⟨@lt_trans _ _⟩\n\n"}
{"name":"instIsTransGt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ IsTrans α fun x1 x2 => GT.gt x1 x2","decl":"instance [Preorder α] : IsTrans α (· > ·) :=\n  IsTrans.swap _\n\n"}
{"name":"instIsAsymmLt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ IsAsymm α fun x1 x2 => LT.lt x1 x2","decl":"instance [Preorder α] : IsAsymm α (· < ·) :=\n  ⟨@lt_asymm _ _⟩\n\n"}
{"name":"instIsAsymmGt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ IsAsymm α fun x1 x2 => GT.gt x1 x2","decl":"instance [Preorder α] : IsAsymm α (· > ·) :=\n  IsAsymm.swap _\n\n"}
{"name":"instIsAntisymmLt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ IsAntisymm α fun x1 x2 => LT.lt x1 x2","decl":"instance [Preorder α] : IsAntisymm α (· < ·) :=\n  IsAsymm.isAntisymm _\n\n"}
{"name":"instIsAntisymmGt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ IsAntisymm α fun x1 x2 => GT.gt x1 x2","decl":"instance [Preorder α] : IsAntisymm α (· > ·) :=\n  IsAsymm.isAntisymm _\n\n"}
{"name":"instIsStrictOrderLt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ IsStrictOrder α fun x1 x2 => LT.lt x1 x2","decl":"instance [Preorder α] : IsStrictOrder α (· < ·) where\n\n"}
{"name":"instIsStrictOrderGt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ IsStrictOrder α fun x1 x2 => GT.gt x1 x2","decl":"instance [Preorder α] : IsStrictOrder α (· > ·) where\n\n"}
{"name":"instIsNonstrictStrictOrderLeLt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ IsNonstrictStrictOrder α (fun x1 x2 => LE.le x1 x2) fun x1 x2 => LT.lt x1 x2","decl":"instance [Preorder α] : IsNonstrictStrictOrder α (· ≤ ·) (· < ·) :=\n  ⟨@lt_iff_le_not_le _ _⟩\n\n"}
{"name":"instIsAntisymmLe","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : PartialOrder α\n⊢ IsAntisymm α fun x1 x2 => LE.le x1 x2","decl":"instance [PartialOrder α] : IsAntisymm α (· ≤ ·) :=\n  ⟨@le_antisymm _ _⟩\n\n"}
{"name":"instIsAntisymmGe","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : PartialOrder α\n⊢ IsAntisymm α fun x1 x2 => GE.ge x1 x2","decl":"instance [PartialOrder α] : IsAntisymm α (· ≥ ·) :=\n  IsAntisymm.swap _\n\n"}
{"name":"instIsPartialOrderLe","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : PartialOrder α\n⊢ IsPartialOrder α fun x1 x2 => LE.le x1 x2","decl":"instance [PartialOrder α] : IsPartialOrder α (· ≤ ·) where\n\n"}
{"name":"instIsPartialOrderGe","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : PartialOrder α\n⊢ IsPartialOrder α fun x1 x2 => GE.ge x1 x2","decl":"instance [PartialOrder α] : IsPartialOrder α (· ≥ ·) where\n\n"}
{"name":"LE.isTotal","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : LinearOrder α\n⊢ IsTotal α fun x1 x2 => LE.le x1 x2","decl":"instance LE.isTotal [LinearOrder α] : IsTotal α (· ≤ ·) :=\n  ⟨le_total⟩\n\n"}
{"name":"instIsTotalGe","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : LinearOrder α\n⊢ IsTotal α fun x1 x2 => GE.ge x1 x2","decl":"instance [LinearOrder α] : IsTotal α (· ≥ ·) :=\n  IsTotal.swap _\n\n"}
{"name":"instIsLinearOrderLe","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : LinearOrder α\n⊢ IsLinearOrder α fun x1 x2 => LE.le x1 x2","decl":"instance [LinearOrder α] : IsLinearOrder α (· ≤ ·) where\n\n"}
{"name":"instIsLinearOrderGe","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : LinearOrder α\n⊢ IsLinearOrder α fun x1 x2 => GE.ge x1 x2","decl":"instance [LinearOrder α] : IsLinearOrder α (· ≥ ·) where\n\n"}
{"name":"instIsTrichotomousLt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : LinearOrder α\n⊢ IsTrichotomous α fun x1 x2 => LT.lt x1 x2","decl":"instance [LinearOrder α] : IsTrichotomous α (· < ·) :=\n  ⟨lt_trichotomy⟩\n\n"}
{"name":"instIsTrichotomousGt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : LinearOrder α\n⊢ IsTrichotomous α fun x1 x2 => GT.gt x1 x2","decl":"instance [LinearOrder α] : IsTrichotomous α (· > ·) :=\n  IsTrichotomous.swap _\n\n"}
{"name":"instIsTrichotomousLe","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : LinearOrder α\n⊢ IsTrichotomous α fun x1 x2 => LE.le x1 x2","decl":"instance [LinearOrder α] : IsTrichotomous α (· ≤ ·) :=\n  IsTotal.isTrichotomous _\n\n"}
{"name":"instIsTrichotomousGe","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : LinearOrder α\n⊢ IsTrichotomous α fun x1 x2 => GE.ge x1 x2","decl":"instance [LinearOrder α] : IsTrichotomous α (· ≥ ·) :=\n  IsTotal.isTrichotomous _\n\n"}
{"name":"instIsStrictTotalOrderLt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : LinearOrder α\n⊢ IsStrictTotalOrder α fun x1 x2 => LT.lt x1 x2","decl":"instance [LinearOrder α] : IsStrictTotalOrder α (· < ·) where\n\n"}
{"name":"instIsOrderConnectedLt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : LinearOrder α\n⊢ IsOrderConnected α fun x1 x2 => LT.lt x1 x2","decl":"instance [LinearOrder α] : IsOrderConnected α (· < ·) := by infer_instance\n\n"}
{"name":"transitive_le","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ Transitive LE.le","decl":"theorem transitive_le [Preorder α] : Transitive (@LE.le α _) :=\n  transitive_of_trans _\n\n"}
{"name":"transitive_lt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ Transitive LT.lt","decl":"theorem transitive_lt [Preorder α] : Transitive (@LT.lt α _) :=\n  transitive_of_trans _\n\n"}
{"name":"transitive_ge","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ Transitive GE.ge","decl":"theorem transitive_ge [Preorder α] : Transitive (@GE.ge α _) :=\n  transitive_of_trans _\n\n"}
{"name":"transitive_gt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : Preorder α\n⊢ Transitive GT.gt","decl":"theorem transitive_gt [Preorder α] : Transitive (@GT.gt α _) :=\n  transitive_of_trans _\n\n"}
{"name":"OrderDual.isTotal_le","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝ : LE α\nh : IsTotal α fun x1 x2 => LE.le x1 x2\n⊢ IsTotal (OrderDual α) fun x1 x2 => LE.le x1 x2","decl":"instance OrderDual.isTotal_le [LE α] [h : IsTotal α (· ≤ ·)] : IsTotal αᵒᵈ (· ≤ ·) :=\n  @IsTotal.swap α _ h\n\n"}
{"name":"instWellFoundedLTNat","module":"Mathlib.Order.RelClasses","initialProofState":"⊢ WellFoundedLT Nat","decl":"instance : WellFoundedLT ℕ :=\n  ⟨Nat.lt_wfRel.wf⟩\n\n"}
{"name":"isWellOrder_lt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : LinearOrder α\ninst✝ : WellFoundedLT α\n⊢ IsWellOrder α fun x1 x2 => LT.lt x1 x2","decl":"instance (priority := 100) isWellOrder_lt [LinearOrder α] [WellFoundedLT α] :\n    IsWellOrder α (· < ·) where\n\n"}
{"name":"isWellOrder_gt","module":"Mathlib.Order.RelClasses","initialProofState":"α : Type u\ninst✝¹ : LinearOrder α\ninst✝ : WellFoundedGT α\n⊢ IsWellOrder α fun x1 x2 => GT.gt x1 x2","decl":"instance (priority := 100) isWellOrder_gt [LinearOrder α] [WellFoundedGT α] :\n    IsWellOrder α (· > ·) where\n"}
