{"name":"Ordnode.not_le_delta","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"s : Nat\nH : LE.le 1 s\n⊢ Not (LE.le s (HMul.hMul Ordnode.delta 0))","decl":"theorem not_le_delta {s} (H : 1 ≤ s) : ¬s ≤ delta * 0 :=\n  not_le_of_gt H\n\n"}
{"name":"Ordnode.delta_lt_false","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"a b : Nat\nh₁ : LT.lt (HMul.hMul Ordnode.delta a) b\nh₂ : LT.lt (HMul.hMul Ordnode.delta b) a\n⊢ False","decl":"theorem delta_lt_false {a b : ℕ} (h₁ : delta * a < b) (h₂ : delta * b < a) : False :=\n  not_le_of_lt (lt_trans ((mul_lt_mul_left (by decide)).2 h₁) h₂) <| by\n    simpa [mul_assoc] using Nat.mul_le_mul_right a (by decide : 1 ≤ delta * delta)\n\n"}
{"name":"Ordnode.Sized.node'","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nr : Ordnode α\nhl : l.Sized\nhr : r.Sized\n⊢ (l.node' x r).Sized","decl":"theorem Sized.node' {l x r} (hl : @Sized α l) (hr : Sized r) : Sized (node' l x r) :=\n  ⟨rfl, hl, hr⟩\n\n"}
{"name":"Ordnode.Sized.eq_node'","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ns : Nat\nl : Ordnode α\nx : α\nr : Ordnode α\nh : (Ordnode.node s l x r).Sized\n⊢ Eq (Ordnode.node s l x r) (l.node' x r)","decl":"theorem Sized.eq_node' {s l x r} (h : @Sized α (node s l x r)) : node s l x r = .node' l x r := by\n  rw [h.1]\n\n"}
{"name":"Ordnode.Sized.size_eq","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ns : Nat\nl : Ordnode α\nx : α\nr : Ordnode α\nH : (Ordnode.node s l x r).Sized\n⊢ Eq (Ordnode.node s l x r).size (HAdd.hAdd (HAdd.hAdd l.size r.size) 1)","decl":"theorem Sized.size_eq {s l x r} (H : Sized (@node α s l x r)) :\n    size (@node α s l x r) = size l + size r + 1 :=\n  H.1\n\n"}
{"name":"Ordnode.Sized.induction","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nt : Ordnode α\nhl : t.Sized\nC : Ordnode α → Prop\nH0 : C Ordnode.nil\nH1 : ∀ (l : Ordnode α) (x : α) (r : Ordnode α), C l → C r → C (l.node' x r)\n⊢ C t","decl":"@[elab_as_elim]\ntheorem Sized.induction {t} (hl : @Sized α t) {C : Ordnode α → Prop} (H0 : C nil)\n    (H1 : ∀ l x r, C l → C r → C (.node' l x r)) : C t := by\n  induction t with\n  | nil => exact H0\n  | node _ _ _ _ t_ih_l t_ih_r =>\n    rw [hl.eq_node']\n    exact H1 _ _ _ (t_ih_l hl.2.1) (t_ih_r hl.2.2)\n\n"}
{"name":"Ordnode.size_eq_realSize","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nt : Ordnode α\na✝ : t.Sized\n⊢ Eq t.size t.realSize","decl":"theorem size_eq_realSize : ∀ {t : Ordnode α}, Sized t → size t = realSize t\n  | nil, _ => rfl\n  | node s l x r, ⟨h₁, h₂, h₃⟩ => by\n    rw [size, h₁, size_eq_realSize h₂, size_eq_realSize h₃]; rfl\n\n"}
{"name":"Ordnode.Sized.size_eq_zero","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nt : Ordnode α\nht : t.Sized\n⊢ Iff (Eq t.size 0) (Eq t Ordnode.nil)","decl":"@[simp]\ntheorem Sized.size_eq_zero {t : Ordnode α} (ht : Sized t) : size t = 0 ↔ t = nil := by\n  cases t <;> [simp;simp [ht.1]]\n\n"}
{"name":"Ordnode.Sized.pos","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ns : Nat\nl : Ordnode α\nx : α\nr : Ordnode α\nh : (Ordnode.node s l x r).Sized\n⊢ LT.lt 0 s","decl":"theorem Sized.pos {s l x r} (h : Sized (@node α s l x r)) : 0 < s := by\n  rw [h.1]; apply Nat.le_add_left\n\n"}
{"name":"Ordnode.dual_dual","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nt : Ordnode α\n⊢ Eq t.dual.dual t","decl":"theorem dual_dual : ∀ t : Ordnode α, dual (dual t) = t\n  | nil => rfl\n  | node s l x r => by rw [dual, dual, dual_dual l, dual_dual r]\n\n"}
{"name":"Ordnode.size_dual","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nt : Ordnode α\n⊢ Eq t.dual.size t.size","decl":"@[simp]\ntheorem size_dual (t : Ordnode α) : size (dual t) = size t := by cases t <;> rfl\n\n"}
{"name":"Ordnode.Balanced.eq_def","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nx✝ : Ordnode α\n⊢ Eq x✝.Balanced (Ordnode.realSize.match_1 (fun x => Prop) x✝ (fun _ => True) fun size l x r => And (Ordnode.BalancedSz l.size r.size) (And l.Balanced r.Balanced))","decl":"instance Balanced.dec : DecidablePred (@Balanced α)\n  | nil => by\n    unfold Balanced\n    infer_instance\n  | node _ l _ r => by\n    unfold Balanced\n    haveI := Balanced.dec l\n    haveI := Balanced.dec r\n    infer_instance\n\n"}
{"name":"Ordnode.BalancedSz.symm","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"l r : Nat\na✝ : Ordnode.BalancedSz l r\n⊢ Ordnode.BalancedSz r l","decl":"@[symm]\ntheorem BalancedSz.symm {l r : ℕ} : BalancedSz l r → BalancedSz r l :=\n  Or.imp (by rw [add_comm]; exact id) And.symm\n\n"}
{"name":"Ordnode.balancedSz_zero","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"l : Nat\n⊢ Iff (Ordnode.BalancedSz l 0) (LE.le l 1)","decl":"theorem balancedSz_zero {l : ℕ} : BalancedSz l 0 ↔ l ≤ 1 := by\n  simp +contextual [BalancedSz]\n\n"}
{"name":"Ordnode.balancedSz_up","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"l r₁ r₂ : Nat\nh₁ : LE.le r₁ r₂\nh₂ : Or (LE.le (HAdd.hAdd l r₂) 1) (LE.le r₂ (HMul.hMul Ordnode.delta l))\nH : Ordnode.BalancedSz l r₁\n⊢ Ordnode.BalancedSz l r₂","decl":"theorem balancedSz_up {l r₁ r₂ : ℕ} (h₁ : r₁ ≤ r₂) (h₂ : l + r₂ ≤ 1 ∨ r₂ ≤ delta * l)\n    (H : BalancedSz l r₁) : BalancedSz l r₂ := by\n  refine or_iff_not_imp_left.2 fun h => ?_\n  refine ⟨?_, h₂.resolve_left h⟩\n  cases H with\n  | inl H =>\n    cases r₂\n    · cases h (le_trans (Nat.add_le_add_left (Nat.zero_le _) _) H)\n    · exact le_trans (le_trans (Nat.le_add_right _ _) H) (Nat.le_add_left 1 _)\n  | inr H =>\n    exact le_trans H.1 (Nat.mul_le_mul_left _ h₁)\n\n"}
{"name":"Ordnode.balancedSz_down","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"l r₁ r₂ : Nat\nh₁ : LE.le r₁ r₂\nh₂ : Or (LE.le (HAdd.hAdd l r₂) 1) (LE.le l (HMul.hMul Ordnode.delta r₁))\nH : Ordnode.BalancedSz l r₂\n⊢ Ordnode.BalancedSz l r₁","decl":"theorem balancedSz_down {l r₁ r₂ : ℕ} (h₁ : r₁ ≤ r₂) (h₂ : l + r₂ ≤ 1 ∨ l ≤ delta * r₁)\n    (H : BalancedSz l r₂) : BalancedSz l r₁ :=\n  have : l + r₂ ≤ 1 → BalancedSz l r₁ := fun H => Or.inl (le_trans (Nat.add_le_add_left h₁ _) H)\n  Or.casesOn H this fun H => Or.casesOn h₂ this fun h₂ => Or.inr ⟨h₂, le_trans h₁ H.2⟩\n\n"}
{"name":"Ordnode.Balanced.dual","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nt : Ordnode α\na✝ : t.Balanced\n⊢ t.dual.Balanced","decl":"theorem Balanced.dual : ∀ {t : Ordnode α}, Balanced t → Balanced (dual t)\n  | nil, _ => ⟨⟩\n  | node _ l _ r, ⟨b, bl, br⟩ => ⟨by rw [size_dual, size_dual]; exact b.symm, br.dual, bl.dual⟩\n\n"}
{"name":"Ordnode.rotateL_node","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nsz : Nat\nm : Ordnode α\ny : α\nr : Ordnode α\n⊢ Eq (l.rotateL x (Ordnode.node sz m y r)) (ite (LT.lt m.size (HMul.hMul Ordnode.ratio r.size)) (l.node3L x m y r) (l.node4L x m y r))","decl":"theorem rotateL_node (l : Ordnode α) (x : α) (sz : ℕ) (m : Ordnode α) (y : α) (r : Ordnode α) :\n    rotateL l x (node sz m y r) =\n      if size m < ratio * size r then node3L l x m y r else node4L l x m y r :=\n  rfl\n\n"}
{"name":"Ordnode.rotateL_nil","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\n⊢ Eq (l.rotateL x Ordnode.nil) (l.node' x Ordnode.nil)","decl":"theorem rotateL_nil (l : Ordnode α) (x : α) : rotateL l x nil = node' l x nil :=\n  rfl\n\n-- should not happen\n"}
{"name":"Ordnode.rotateR_node","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nsz : Nat\nl : Ordnode α\nx : α\nm : Ordnode α\ny : α\nr : Ordnode α\n⊢ Eq ((Ordnode.node sz l x m).rotateR y r) (ite (LT.lt m.size (HMul.hMul Ordnode.ratio l.size)) (l.node3R x m y r) (l.node4R x m y r))","decl":"theorem rotateR_node (sz : ℕ) (l : Ordnode α) (x : α) (m : Ordnode α) (y : α) (r : Ordnode α) :\n    rotateR (node sz l x m) y r =\n      if size m < ratio * size l then node3R l x m y r else node4R l x m y r :=\n  rfl\n\n"}
{"name":"Ordnode.rotateR_nil","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ny : α\nr : Ordnode α\n⊢ Eq (Ordnode.nil.rotateR y r) (Ordnode.nil.node' y r)","decl":"theorem rotateR_nil (y : α) (r : Ordnode α) : rotateR nil y r = node' nil y r :=\n  rfl\n\n-- should not happen\n"}
{"name":"Ordnode.dual_node'","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nr : Ordnode α\n⊢ Eq (l.node' x r).dual (r.dual.node' x l.dual)","decl":"theorem dual_node' (l : Ordnode α) (x : α) (r : Ordnode α) :\n    dual (node' l x r) = node' (dual r) x (dual l) := by simp [node', add_comm]\n\n"}
{"name":"Ordnode.dual_node3L","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nm : Ordnode α\ny : α\nr : Ordnode α\n⊢ Eq (l.node3L x m y r).dual (r.dual.node3R y m.dual x l.dual)","decl":"theorem dual_node3L (l : Ordnode α) (x : α) (m : Ordnode α) (y : α) (r : Ordnode α) :\n    dual (node3L l x m y r) = node3R (dual r) y (dual m) x (dual l) := by\n  simp [node3L, node3R, dual_node', add_comm]\n\n"}
{"name":"Ordnode.dual_node3R","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nm : Ordnode α\ny : α\nr : Ordnode α\n⊢ Eq (l.node3R x m y r).dual (r.dual.node3L y m.dual x l.dual)","decl":"theorem dual_node3R (l : Ordnode α) (x : α) (m : Ordnode α) (y : α) (r : Ordnode α) :\n    dual (node3R l x m y r) = node3L (dual r) y (dual m) x (dual l) := by\n  simp [node3L, node3R, dual_node', add_comm]\n\n"}
{"name":"Ordnode.dual_node4L","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nm : Ordnode α\ny : α\nr : Ordnode α\n⊢ Eq (l.node4L x m y r).dual (r.dual.node4R y m.dual x l.dual)","decl":"theorem dual_node4L (l : Ordnode α) (x : α) (m : Ordnode α) (y : α) (r : Ordnode α) :\n    dual (node4L l x m y r) = node4R (dual r) y (dual m) x (dual l) := by\n  cases m <;> simp [node4L, node4R, node3R, dual_node3L, dual_node', add_comm]\n\n"}
{"name":"Ordnode.dual_node4R","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nm : Ordnode α\ny : α\nr : Ordnode α\n⊢ Eq (l.node4R x m y r).dual (r.dual.node4L y m.dual x l.dual)","decl":"theorem dual_node4R (l : Ordnode α) (x : α) (m : Ordnode α) (y : α) (r : Ordnode α) :\n    dual (node4R l x m y r) = node4L (dual r) y (dual m) x (dual l) := by\n  cases m <;> simp [node4L, node4R, node3L, dual_node3R, dual_node', add_comm]\n\n"}
{"name":"Ordnode.dual_rotateL","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nr : Ordnode α\n⊢ Eq (l.rotateL x r).dual (r.dual.rotateR x l.dual)","decl":"theorem dual_rotateL (l : Ordnode α) (x : α) (r : Ordnode α) :\n    dual (rotateL l x r) = rotateR (dual r) x (dual l) := by\n  cases r <;> simp [rotateL, rotateR, dual_node']; split_ifs <;>\n    simp [dual_node3L, dual_node4L, node3R, add_comm]\n\n"}
{"name":"Ordnode.dual_rotateR","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nr : Ordnode α\n⊢ Eq (l.rotateR x r).dual (r.dual.rotateL x l.dual)","decl":"theorem dual_rotateR (l : Ordnode α) (x : α) (r : Ordnode α) :\n    dual (rotateR l x r) = rotateL (dual r) x (dual l) := by\n  rw [← dual_dual (rotateL _ _ _), dual_rotateL, dual_dual, dual_dual]\n\n"}
{"name":"Ordnode.dual_balance'","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nr : Ordnode α\n⊢ Eq (l.balance' x r).dual (r.dual.balance' x l.dual)","decl":"theorem dual_balance' (l : Ordnode α) (x : α) (r : Ordnode α) :\n    dual (balance' l x r) = balance' (dual r) x (dual l) := by\n  simp [balance', add_comm]; split_ifs with h h_1 h_2 <;>\n    simp [dual_node', dual_rotateL, dual_rotateR, add_comm]\n  cases delta_lt_false h_1 h_2\n\n"}
{"name":"Ordnode.dual_balanceL","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nr : Ordnode α\n⊢ Eq (l.balanceL x r).dual (r.dual.balanceR x l.dual)","decl":"theorem dual_balanceL (l : Ordnode α) (x : α) (r : Ordnode α) :\n    dual (balanceL l x r) = balanceR (dual r) x (dual l) := by\n  unfold balanceL balanceR\n  cases' r with rs rl rx rr\n  · cases' l with ls ll lx lr; · rfl\n    cases' ll with lls lll llx llr <;> cases' lr with lrs lrl lrx lrr <;> dsimp only [dual, id] <;>\n      try rfl\n    split_ifs with h <;> repeat simp [h, add_comm]\n  · cases' l with ls ll lx lr; · rfl\n    dsimp only [dual, id]\n    split_ifs; swap; · simp [add_comm]\n    cases' ll with lls lll llx llr <;> cases' lr with lrs lrl lrx lrr <;> try rfl\n    dsimp only [dual, id]\n    split_ifs with h <;> simp [h, add_comm]\n\n"}
{"name":"Ordnode.dual_balanceR","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nr : Ordnode α\n⊢ Eq (l.balanceR x r).dual (r.dual.balanceL x l.dual)","decl":"theorem dual_balanceR (l : Ordnode α) (x : α) (r : Ordnode α) :\n    dual (balanceR l x r) = balanceL (dual r) x (dual l) := by\n  rw [← dual_dual (balanceL _ _ _), dual_balanceL, dual_dual, dual_dual]\n\n"}
{"name":"Ordnode.Sized.node3L","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nm : Ordnode α\ny : α\nr : Ordnode α\nhl : l.Sized\nhm : m.Sized\nhr : r.Sized\n⊢ (l.node3L x m y r).Sized","decl":"theorem Sized.node3L {l x m y r} (hl : @Sized α l) (hm : Sized m) (hr : Sized r) :\n    Sized (node3L l x m y r) :=\n  (hl.node' hm).node' hr\n\n"}
{"name":"Ordnode.Sized.node3R","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nm : Ordnode α\ny : α\nr : Ordnode α\nhl : l.Sized\nhm : m.Sized\nhr : r.Sized\n⊢ (l.node3R x m y r).Sized","decl":"theorem Sized.node3R {l x m y r} (hl : @Sized α l) (hm : Sized m) (hr : Sized r) :\n    Sized (node3R l x m y r) :=\n  hl.node' (hm.node' hr)\n\n"}
{"name":"Ordnode.Sized.node4L","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nm : Ordnode α\ny : α\nr : Ordnode α\nhl : l.Sized\nhm : m.Sized\nhr : r.Sized\n⊢ (l.node4L x m y r).Sized","decl":"theorem Sized.node4L {l x m y r} (hl : @Sized α l) (hm : Sized m) (hr : Sized r) :\n    Sized (node4L l x m y r) := by\n  cases m <;> [exact (hl.node' hm).node' hr; exact (hl.node' hm.2.1).node' (hm.2.2.node' hr)]\n\n"}
{"name":"Ordnode.node3L_size","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nm : Ordnode α\ny : α\nr : Ordnode α\n⊢ Eq (l.node3L x m y r).size (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd l.size m.size) r.size) 2)","decl":"theorem node3L_size {l x m y r} : size (@node3L α l x m y r) = size l + size m + size r + 2 := by\n  dsimp [node3L, node', size]; rw [add_right_comm _ 1]\n\n"}
{"name":"Ordnode.node3R_size","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nm : Ordnode α\ny : α\nr : Ordnode α\n⊢ Eq (l.node3R x m y r).size (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd l.size m.size) r.size) 2)","decl":"theorem node3R_size {l x m y r} : size (@node3R α l x m y r) = size l + size m + size r + 2 := by\n  dsimp [node3R, node', size]; rw [← add_assoc, ← add_assoc]\n\n"}
{"name":"Ordnode.node4L_size","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nm : Ordnode α\ny : α\nr : Ordnode α\nhm : m.Sized\n⊢ Eq (l.node4L x m y r).size (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd l.size m.size) r.size) 2)","decl":"theorem node4L_size {l x m y r} (hm : Sized m) :\n    size (@node4L α l x m y r) = size l + size m + size r + 2 := by\n  cases m <;> simp [node4L, node3L, node'] <;> [abel; (simp [size, hm.1]; abel)]\n\n"}
{"name":"Ordnode.Sized.dual","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nt : Ordnode α\na✝ : t.Sized\n⊢ t.dual.Sized","decl":"theorem Sized.dual : ∀ {t : Ordnode α}, Sized t → Sized (dual t)\n  | nil, _ => ⟨⟩\n  | node _ l _ r, ⟨rfl, sl, sr⟩ => ⟨by simp [size_dual, add_comm], Sized.dual sr, Sized.dual sl⟩\n\n"}
{"name":"Ordnode.Sized.dual_iff","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nt : Ordnode α\n⊢ Iff t.dual.Sized t.Sized","decl":"theorem Sized.dual_iff {t : Ordnode α} : Sized (.dual t) ↔ Sized t :=\n  ⟨fun h => by rw [← dual_dual t]; exact h.dual, Sized.dual⟩\n\n"}
{"name":"Ordnode.Sized.rotateL","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nr : Ordnode α\nhl : l.Sized\nhr : r.Sized\n⊢ (l.rotateL x r).Sized","decl":"theorem Sized.rotateL {l x r} (hl : @Sized α l) (hr : Sized r) : Sized (rotateL l x r) := by\n  cases r; · exact hl.node' hr\n  rw [Ordnode.rotateL_node]; split_ifs\n  · exact hl.node3L hr.2.1 hr.2.2\n  · exact hl.node4L hr.2.1 hr.2.2\n\n"}
{"name":"Ordnode.Sized.rotateR","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nr : Ordnode α\nhl : l.Sized\nhr : r.Sized\n⊢ (l.rotateR x r).Sized","decl":"theorem Sized.rotateR {l x r} (hl : @Sized α l) (hr : Sized r) : Sized (rotateR l x r) :=\n  Sized.dual_iff.1 <| by rw [dual_rotateR]; exact hr.dual.rotateL hl.dual\n\n"}
{"name":"Ordnode.Sized.rotateL_size","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nr : Ordnode α\nhm : r.Sized\n⊢ Eq (l.rotateL x r).size (HAdd.hAdd (HAdd.hAdd l.size r.size) 1)","decl":"theorem Sized.rotateL_size {l x r} (hm : Sized r) :\n    size (@Ordnode.rotateL α l x r) = size l + size r + 1 := by\n  cases r <;> simp [Ordnode.rotateL]\n  simp only [hm.1]\n  split_ifs <;> simp [node3L_size, node4L_size hm.2.1] <;> abel\n\n"}
{"name":"Ordnode.Sized.rotateR_size","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nr : Ordnode α\nhl : l.Sized\n⊢ Eq (l.rotateR x r).size (HAdd.hAdd (HAdd.hAdd l.size r.size) 1)","decl":"theorem Sized.rotateR_size {l x r} (hl : Sized l) :\n    size (@Ordnode.rotateR α l x r) = size l + size r + 1 := by\n  rw [← size_dual, dual_rotateR, hl.dual.rotateL_size, size_dual, size_dual, add_comm (size l)]\n\n"}
{"name":"Ordnode.Sized.balance'","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nr : Ordnode α\nhl : l.Sized\nhr : r.Sized\n⊢ (l.balance' x r).Sized","decl":"theorem Sized.balance' {l x r} (hl : @Sized α l) (hr : Sized r) : Sized (balance' l x r) := by\n  unfold Ordnode.balance'; split_ifs\n  · exact hl.node' hr\n  · exact hl.rotateL hr\n  · exact hl.rotateR hr\n  · exact hl.node' hr\n\n"}
{"name":"Ordnode.size_balance'","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nr : Ordnode α\nhl : l.Sized\nhr : r.Sized\n⊢ Eq (l.balance' x r).size (HAdd.hAdd (HAdd.hAdd l.size r.size) 1)","decl":"theorem size_balance' {l x r} (hl : @Sized α l) (hr : Sized r) :\n    size (@balance' α l x r) = size l + size r + 1 := by\n  unfold balance'; split_ifs\n  · rfl\n  · exact hr.rotateL_size\n  · exact hl.rotateR_size\n  · rfl\n\n"}
{"name":"Ordnode.All.imp","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nP Q : α → Prop\nH : ∀ (a : α), P a → Q a\nt : Ordnode α\na✝ : Ordnode.All P t\n⊢ Ordnode.All Q t","decl":"theorem All.imp {P Q : α → Prop} (H : ∀ a, P a → Q a) : ∀ {t}, All P t → All Q t\n  | nil, _ => ⟨⟩\n  | node _ _ _ _, ⟨h₁, h₂, h₃⟩ => ⟨h₁.imp H, H _ h₂, h₃.imp H⟩\n\n"}
{"name":"Ordnode.Any.imp","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nP Q : α → Prop\nH : ∀ (a : α), P a → Q a\nt : Ordnode α\na✝ : Ordnode.Any P t\n⊢ Ordnode.Any Q t","decl":"theorem Any.imp {P Q : α → Prop} (H : ∀ a, P a → Q a) : ∀ {t}, Any P t → Any Q t\n  | nil => id\n  | node _ _ _ _ => Or.imp (Any.imp H) <| Or.imp (H _) (Any.imp H)\n\n"}
{"name":"Ordnode.all_singleton","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\n⊢ Iff (Ordnode.All P (Singleton.singleton x)) (P x)","decl":"theorem all_singleton {P : α → Prop} {x : α} : All P (singleton x) ↔ P x :=\n  ⟨fun h => h.2.1, fun h => ⟨⟨⟩, h, ⟨⟩⟩⟩\n\n"}
{"name":"Ordnode.any_singleton","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\n⊢ Iff (Ordnode.Any P (Singleton.singleton x)) (P x)","decl":"theorem any_singleton {P : α → Prop} {x : α} : Any P (singleton x) ↔ P x :=\n  ⟨by rintro (⟨⟨⟩⟩ | h | ⟨⟨⟩⟩); exact h, fun h => Or.inr (Or.inl h)⟩\n\n"}
{"name":"Ordnode.all_dual","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nP : α → Prop\nt : Ordnode α\n⊢ Iff (Ordnode.All P t.dual) (Ordnode.All P t)","decl":"theorem all_dual {P : α → Prop} : ∀ {t : Ordnode α}, All P (dual t) ↔ All P t\n  | nil => Iff.rfl\n  | node _ _l _x _r =>\n    ⟨fun ⟨hr, hx, hl⟩ => ⟨all_dual.1 hl, hx, all_dual.1 hr⟩, fun ⟨hl, hx, hr⟩ =>\n      ⟨all_dual.2 hr, hx, all_dual.2 hl⟩⟩\n\n"}
{"name":"Ordnode.all_iff_forall","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nP : α → Prop\nt : Ordnode α\n⊢ Iff (Ordnode.All P t) (∀ (x : α), Ordnode.Emem x t → P x)","decl":"theorem all_iff_forall {P : α → Prop} : ∀ {t}, All P t ↔ ∀ x, Emem x t → P x\n  | nil => (iff_true_intro <| by rintro _ ⟨⟩).symm\n  | node _ l x r => by simp [All, Emem, all_iff_forall, Any, or_imp, forall_and]\n\n"}
{"name":"Ordnode.any_iff_exists","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nP : α → Prop\nt : Ordnode α\n⊢ Iff (Ordnode.Any P t) (Exists fun x => And (Ordnode.Emem x t) (P x))","decl":"theorem any_iff_exists {P : α → Prop} : ∀ {t}, Any P t ↔ ∃ x, Emem x t ∧ P x\n  | nil => ⟨by rintro ⟨⟩, by rintro ⟨_, ⟨⟩, _⟩⟩\n  | node _ l x r => by simp only [Emem]; simp [Any, any_iff_exists, or_and_right, exists_or]\n\n"}
{"name":"Ordnode.emem_iff_all","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nx : α\nt : Ordnode α\n⊢ Iff (Ordnode.Emem x t) (∀ (P : α → Prop), Ordnode.All P t → P x)","decl":"theorem emem_iff_all {x : α} {t} : Emem x t ↔ ∀ P, All P t → P x :=\n  ⟨fun h _ al => all_iff_forall.1 al _ h, fun H => H _ <| all_iff_forall.2 fun _ => id⟩\n\n"}
{"name":"Ordnode.all_node'","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nP : α → Prop\nl : Ordnode α\nx : α\nr : Ordnode α\n⊢ Iff (Ordnode.All P (l.node' x r)) (And (Ordnode.All P l) (And (P x) (Ordnode.All P r)))","decl":"theorem all_node' {P l x r} : @All α P (node' l x r) ↔ All P l ∧ P x ∧ All P r :=\n  Iff.rfl\n\n"}
{"name":"Ordnode.all_node3L","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nP : α → Prop\nl : Ordnode α\nx : α\nm : Ordnode α\ny : α\nr : Ordnode α\n⊢ Iff (Ordnode.All P (l.node3L x m y r)) (And (Ordnode.All P l) (And (P x) (And (Ordnode.All P m) (And (P y) (Ordnode.All P r)))))","decl":"theorem all_node3L {P l x m y r} :\n    @All α P (node3L l x m y r) ↔ All P l ∧ P x ∧ All P m ∧ P y ∧ All P r := by\n  simp [node3L, all_node', and_assoc]\n\n"}
{"name":"Ordnode.all_node3R","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nP : α → Prop\nl : Ordnode α\nx : α\nm : Ordnode α\ny : α\nr : Ordnode α\n⊢ Iff (Ordnode.All P (l.node3R x m y r)) (And (Ordnode.All P l) (And (P x) (And (Ordnode.All P m) (And (P y) (Ordnode.All P r)))))","decl":"theorem all_node3R {P l x m y r} :\n    @All α P (node3R l x m y r) ↔ All P l ∧ P x ∧ All P m ∧ P y ∧ All P r :=\n  Iff.rfl\n\n"}
{"name":"Ordnode.all_node4L","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nP : α → Prop\nl : Ordnode α\nx : α\nm : Ordnode α\ny : α\nr : Ordnode α\n⊢ Iff (Ordnode.All P (l.node4L x m y r)) (And (Ordnode.All P l) (And (P x) (And (Ordnode.All P m) (And (P y) (Ordnode.All P r)))))","decl":"theorem all_node4L {P l x m y r} :\n    @All α P (node4L l x m y r) ↔ All P l ∧ P x ∧ All P m ∧ P y ∧ All P r := by\n  cases m <;> simp [node4L, all_node', All, all_node3L, and_assoc]\n\n"}
{"name":"Ordnode.all_node4R","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nP : α → Prop\nl : Ordnode α\nx : α\nm : Ordnode α\ny : α\nr : Ordnode α\n⊢ Iff (Ordnode.All P (l.node4R x m y r)) (And (Ordnode.All P l) (And (P x) (And (Ordnode.All P m) (And (P y) (Ordnode.All P r)))))","decl":"theorem all_node4R {P l x m y r} :\n    @All α P (node4R l x m y r) ↔ All P l ∧ P x ∧ All P m ∧ P y ∧ All P r := by\n  cases m <;> simp [node4R, all_node', All, all_node3R, and_assoc]\n\n"}
{"name":"Ordnode.all_rotateL","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nP : α → Prop\nl : Ordnode α\nx : α\nr : Ordnode α\n⊢ Iff (Ordnode.All P (l.rotateL x r)) (And (Ordnode.All P l) (And (P x) (Ordnode.All P r)))","decl":"theorem all_rotateL {P l x r} : @All α P (rotateL l x r) ↔ All P l ∧ P x ∧ All P r := by\n  cases r <;> simp [rotateL, all_node']; split_ifs <;>\n    simp [all_node3L, all_node4L, All, and_assoc]\n\n"}
{"name":"Ordnode.all_rotateR","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nP : α → Prop\nl : Ordnode α\nx : α\nr : Ordnode α\n⊢ Iff (Ordnode.All P (l.rotateR x r)) (And (Ordnode.All P l) (And (P x) (Ordnode.All P r)))","decl":"theorem all_rotateR {P l x r} : @All α P (rotateR l x r) ↔ All P l ∧ P x ∧ All P r := by\n  rw [← all_dual, dual_rotateR, all_rotateL]; simp [all_dual, and_comm, and_left_comm, and_assoc]\n\n"}
{"name":"Ordnode.all_balance'","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nP : α → Prop\nl : Ordnode α\nx : α\nr : Ordnode α\n⊢ Iff (Ordnode.All P (l.balance' x r)) (And (Ordnode.All P l) (And (P x) (Ordnode.All P r)))","decl":"theorem all_balance' {P l x r} : @All α P (balance' l x r) ↔ All P l ∧ P x ∧ All P r := by\n  rw [balance']; split_ifs <;> simp [all_node', all_rotateL, all_rotateR]\n\n"}
{"name":"Ordnode.foldr_cons_eq_toList","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nt : Ordnode α\nr : List α\n⊢ Eq (Ordnode.foldr List.cons t r) (HAppend.hAppend t.toList r)","decl":"theorem foldr_cons_eq_toList : ∀ (t : Ordnode α) (r : List α), t.foldr List.cons r = toList t ++ r\n  | nil, _ => rfl\n  | node _ l x r, r' => by\n    rw [foldr, foldr_cons_eq_toList l, foldr_cons_eq_toList r, ← List.cons_append,\n        ← List.append_assoc, ← foldr_cons_eq_toList l]; rfl\n\n"}
{"name":"Ordnode.toList_nil","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\n⊢ Eq Ordnode.nil.toList List.nil","decl":"@[simp]\ntheorem toList_nil : toList (@nil α) = [] :=\n  rfl\n\n"}
{"name":"Ordnode.toList_node","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ns : Nat\nl : Ordnode α\nx : α\nr : Ordnode α\n⊢ Eq (Ordnode.node s l x r).toList (HAppend.hAppend l.toList (List.cons x r.toList))","decl":"@[simp]\ntheorem toList_node (s l x r) : toList (@node α s l x r) = toList l ++ x :: toList r := by\n  rw [toList, foldr, foldr_cons_eq_toList]; rfl\n\n"}
{"name":"Ordnode.emem_iff_mem_toList","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nx : α\nt : Ordnode α\n⊢ Iff (Ordnode.Emem x t) (Membership.mem t.toList x)","decl":"theorem emem_iff_mem_toList {x : α} {t} : Emem x t ↔ x ∈ toList t := by\n  unfold Emem; induction t <;> simp [Any, *, or_assoc]\n\n"}
{"name":"Ordnode.length_toList'","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nt : Ordnode α\n⊢ Eq t.toList.length t.realSize","decl":"theorem length_toList' : ∀ t : Ordnode α, (toList t).length = t.realSize\n  | nil => rfl\n  | node _ l _ r => by\n    rw [toList_node, List.length_append, List.length_cons, length_toList' l,\n        length_toList' r]; rfl\n\n"}
{"name":"Ordnode.length_toList","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nt : Ordnode α\nh : t.Sized\n⊢ Eq t.toList.length t.size","decl":"theorem length_toList {t : Ordnode α} (h : Sized t) : (toList t).length = t.size := by\n  rw [length_toList', size_eq_realSize h]\n\n"}
{"name":"Ordnode.equiv_iff","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nt₁ t₂ : Ordnode α\nh₁ : t₁.Sized\nh₂ : t₂.Sized\n⊢ Iff (t₁.Equiv t₂) (Eq t₁.toList t₂.toList)","decl":"theorem equiv_iff {t₁ t₂ : Ordnode α} (h₁ : Sized t₁) (h₂ : Sized t₂) :\n    Equiv t₁ t₂ ↔ toList t₁ = toList t₂ :=\n  and_iff_right_of_imp fun h => by rw [← length_toList h₁, h, length_toList h₂]\n\n"}
{"name":"Ordnode.pos_size_of_mem","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝¹ : LE α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nx : α\nt : Ordnode α\nh : t.Sized\nh_mem : Membership.mem t x\n⊢ LT.lt 0 t.size","decl":"theorem pos_size_of_mem [LE α] [DecidableRel (α := α) (· ≤ ·)] {x : α} {t : Ordnode α} (h : Sized t)\n    (h_mem : x ∈ t) : 0 < size t := by cases t; · { contradiction }; · { simp [h.1] }\n\n"}
{"name":"Ordnode.findMin'_dual","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nt : Ordnode α\nx : α\n⊢ Eq (t.dual.findMin' x) (Ordnode.findMax' x t)","decl":"theorem findMin'_dual : ∀ (t) (x : α), findMin' (dual t) x = findMax' x t\n  | nil, _ => rfl\n  | node _ _ x r, _ => findMin'_dual r x\n\n"}
{"name":"Ordnode.findMax'_dual","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nt : Ordnode α\nx : α\n⊢ Eq (Ordnode.findMax' x t.dual) (t.findMin' x)","decl":"theorem findMax'_dual (t) (x : α) : findMax' x (dual t) = findMin' t x := by\n  rw [← findMin'_dual, dual_dual]\n\n"}
{"name":"Ordnode.findMin_dual","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nt : Ordnode α\n⊢ Eq t.dual.findMin t.findMax","decl":"theorem findMin_dual : ∀ t : Ordnode α, findMin (dual t) = findMax t\n  | nil => rfl\n  | node _ _ _ _ => congr_arg some <| findMin'_dual _ _\n\n"}
{"name":"Ordnode.findMax_dual","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nt : Ordnode α\n⊢ Eq t.dual.findMax t.findMin","decl":"theorem findMax_dual (t : Ordnode α) : findMax (dual t) = findMin t := by\n  rw [← findMin_dual, dual_dual]\n\n"}
{"name":"Ordnode.dual_eraseMin","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nt : Ordnode α\n⊢ Eq t.eraseMin.dual t.dual.eraseMax","decl":"theorem dual_eraseMin : ∀ t : Ordnode α, dual (eraseMin t) = eraseMax (dual t)\n  | nil => rfl\n  | node _ nil _ _ => rfl\n  | node _ (node sz l' y r') x r => by\n    rw [eraseMin, dual_balanceR, dual_eraseMin (node sz l' y r'), dual, dual, dual, eraseMax]\n\n"}
{"name":"Ordnode.dual_eraseMax","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nt : Ordnode α\n⊢ Eq t.eraseMax.dual t.dual.eraseMin","decl":"theorem dual_eraseMax (t : Ordnode α) : dual (eraseMax t) = eraseMin (dual t) := by\n  rw [← dual_dual (eraseMin _), dual_eraseMin, dual_dual]\n\n"}
{"name":"Ordnode.splitMin_eq","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ns : Nat\nl : Ordnode α\nx : α\nr : Ordnode α\n⊢ Eq (l.splitMin' x r) { fst := l.findMin' x, snd := (Ordnode.node s l x r).eraseMin }","decl":"theorem splitMin_eq :\n    ∀ (s l) (x : α) (r), splitMin' l x r = (findMin' l x, eraseMin (node s l x r))\n  | _, nil, _, _ => rfl\n  | _, node ls ll lx lr, x, r => by rw [splitMin', splitMin_eq ls ll lx lr, findMin', eraseMin]\n\n"}
{"name":"Ordnode.splitMax_eq","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ns : Nat\nl : Ordnode α\nx : α\nr : Ordnode α\n⊢ Eq (l.splitMax' x r) { fst := (Ordnode.node s l x r).eraseMax, snd := Ordnode.findMax' x r }","decl":"theorem splitMax_eq :\n    ∀ (s l) (x : α) (r), splitMax' l x r = (eraseMax (node s l x r), findMax' x r)\n  | _, _, _, nil => rfl\n  | _, l, x, node ls ll lx lr => by rw [splitMax', splitMax_eq ls ll lx lr, findMax', eraseMax]\n\n"}
{"name":"Ordnode.findMin'_all","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nP : α → Prop\nt : Ordnode α\nx : α\na✝¹ : Ordnode.All P t\na✝ : P x\n⊢ P (t.findMin' x)","decl":"@[elab_as_elim]\ntheorem findMin'_all {P : α → Prop} : ∀ (t) (x : α), All P t → P x → P (findMin' t x)\n  | nil, _x, _, hx => hx\n  | node _ ll lx _, _, ⟨h₁, h₂, _⟩, _ => findMin'_all ll lx h₁ h₂\n\n"}
{"name":"Ordnode.findMax'_all","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nP : α → Prop\nx : α\nt : Ordnode α\na✝¹ : P x\na✝ : Ordnode.All P t\n⊢ P (Ordnode.findMax' x t)","decl":"@[elab_as_elim]\ntheorem findMax'_all {P : α → Prop} : ∀ (x : α) (t), P x → All P t → P (findMax' x t)\n  | _x, nil, hx, _ => hx\n  | _, node _ _ lx lr, _, ⟨_, h₂, h₃⟩ => findMax'_all lx lr h₂ h₃\n\n"}
{"name":"Ordnode.merge_nil_left","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nt : Ordnode α\n⊢ Eq (t.merge Ordnode.nil) t","decl":"@[simp]\ntheorem merge_nil_left (t : Ordnode α) : merge t nil = t := by cases t <;> rfl\n\n"}
{"name":"Ordnode.merge_nil_right","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nt : Ordnode α\n⊢ Eq (Ordnode.nil.merge t) t","decl":"@[simp]\ntheorem merge_nil_right (t : Ordnode α) : merge nil t = t :=\n  rfl\n\n"}
{"name":"Ordnode.merge_node","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nls : Nat\nll : Ordnode α\nlx : α\nlr : Ordnode α\nrs : Nat\nrl : Ordnode α\nrx : α\nrr : Ordnode α\n⊢ Eq ((Ordnode.node ls ll lx lr).merge (Ordnode.node rs rl rx rr)) (ite (LT.lt (HMul.hMul Ordnode.delta ls) rs) (((Ordnode.node ls ll lx lr).merge rl).balanceL rx rr) (ite (LT.lt (HMul.hMul Ordnode.delta rs) ls) (ll.balanceR lx (lr.merge (Ordnode.node rs rl rx rr))) ((Ordnode.node ls ll lx lr).glue (Ordnode.node rs rl rx rr))))","decl":"@[simp]\ntheorem merge_node {ls ll lx lr rs rl rx rr} :\n    merge (@node α ls ll lx lr) (node rs rl rx rr) =\n      if delta * ls < rs then balanceL (merge (node ls ll lx lr) rl) rx rr\n      else if delta * rs < ls then balanceR ll lx (merge lr (node rs rl rx rr))\n      else glue (node ls ll lx lr) (node rs rl rx rr) :=\n  rfl\n\n"}
{"name":"Ordnode.dual_insert","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : IsTotal α fun x1 x2 => LE.le x1 x2\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nx : α\nt : Ordnode α\n⊢ Eq (Ordnode.insert x t).dual (Ordnode.insert x t.dual)","decl":"theorem dual_insert [Preorder α] [IsTotal α (· ≤ ·)] [DecidableRel (α := α) (· ≤ ·)] (x : α) :\n    ∀ t : Ordnode α, dual (Ordnode.insert x t) = @Ordnode.insert αᵒᵈ _ _ x (dual t)\n  | nil => rfl\n  | node _ l y r => by\n    have : @cmpLE αᵒᵈ _ _ x y = cmpLE y x := rfl\n    rw [Ordnode.insert, dual, Ordnode.insert, this, ← cmpLE_swap x y]\n    cases cmpLE x y <;>\n      simp [Ordering.swap, Ordnode.insert, dual_balanceL, dual_balanceR, dual_insert]\n\n"}
{"name":"Ordnode.balance_eq_balance'","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nr : Ordnode α\nhl : l.Balanced\nhr : r.Balanced\nsl : l.Sized\nsr : r.Sized\n⊢ Eq (l.balance x r) (l.balance' x r)","decl":"theorem balance_eq_balance' {l x r} (hl : Balanced l) (hr : Balanced r) (sl : Sized l)\n    (sr : Sized r) : @balance α l x r = balance' l x r := by\n  cases' l with ls ll lx lr\n  · cases' r with rs rl rx rr\n    · rfl\n    · rw [sr.eq_node'] at hr ⊢\n      cases' rl with rls rll rlx rlr <;> cases' rr with rrs rrl rrx rrr <;>\n        dsimp [balance, balance']\n      · rfl\n      · have : size rrl = 0 ∧ size rrr = 0 := by\n          have := balancedSz_zero.1 hr.1.symm\n          rwa [size, sr.2.2.1, Nat.succ_le_succ_iff, Nat.le_zero, add_eq_zero] at this\n        cases sr.2.2.2.1.size_eq_zero.1 this.1\n        cases sr.2.2.2.2.size_eq_zero.1 this.2\n        obtain rfl : rrs = 1 := sr.2.2.1\n        rw [if_neg, if_pos, rotateL_node, if_pos]; · rfl\n        all_goals dsimp only [size]; decide\n      · have : size rll = 0 ∧ size rlr = 0 := by\n          have := balancedSz_zero.1 hr.1\n          rwa [size, sr.2.1.1, Nat.succ_le_succ_iff, Nat.le_zero, add_eq_zero] at this\n        cases sr.2.1.2.1.size_eq_zero.1 this.1\n        cases sr.2.1.2.2.size_eq_zero.1 this.2\n        obtain rfl : rls = 1 := sr.2.1.1\n        rw [if_neg, if_pos, rotateL_node, if_neg]; · rfl\n        all_goals dsimp only [size]; decide\n      · symm; rw [zero_add, if_neg, if_pos, rotateL]\n        · dsimp only [size_node]; split_ifs\n          · simp [node3L, node']; abel\n          · simp [node4L, node', sr.2.1.1]; abel\n        · apply Nat.zero_lt_succ\n        · exact not_le_of_gt (Nat.succ_lt_succ (add_pos sr.2.1.pos sr.2.2.pos))\n  · cases' r with rs rl rx rr\n    · rw [sl.eq_node'] at hl ⊢\n      cases' ll with lls lll llx llr <;> cases' lr with lrs lrl lrx lrr <;>\n        dsimp [balance, balance']\n      · rfl\n      · have : size lrl = 0 ∧ size lrr = 0 := by\n          have := balancedSz_zero.1 hl.1.symm\n          rwa [size, sl.2.2.1, Nat.succ_le_succ_iff, Nat.le_zero, add_eq_zero] at this\n        cases sl.2.2.2.1.size_eq_zero.1 this.1\n        cases sl.2.2.2.2.size_eq_zero.1 this.2\n        obtain rfl : lrs = 1 := sl.2.2.1\n        rw [if_neg, if_pos, rotateR_node, if_neg]; · rfl\n        all_goals dsimp only [size]; decide\n      · have : size lll = 0 ∧ size llr = 0 := by\n          have := balancedSz_zero.1 hl.1\n          rwa [size, sl.2.1.1, Nat.succ_le_succ_iff, Nat.le_zero, add_eq_zero] at this\n        cases sl.2.1.2.1.size_eq_zero.1 this.1\n        cases sl.2.1.2.2.size_eq_zero.1 this.2\n        obtain rfl : lls = 1 := sl.2.1.1\n        rw [if_neg, if_pos, rotateR_node, if_pos]; · rfl\n        all_goals dsimp only [size]; decide\n      · symm; rw [if_neg, if_pos, rotateR]\n        · dsimp only [size_node]; split_ifs\n          · simp [node3R, node']; abel\n          · simp [node4R, node', sl.2.2.1]; abel\n        · apply Nat.zero_lt_succ\n        · exact not_le_of_gt (Nat.succ_lt_succ (add_pos sl.2.1.pos sl.2.2.pos))\n    · simp [balance, balance']\n      symm; rw [if_neg]\n      · split_ifs with h h_1\n        · have rd : delta ≤ size rl + size rr := by\n            have := lt_of_le_of_lt (Nat.mul_le_mul_left _ sl.pos) h\n            rwa [sr.1, Nat.lt_succ_iff] at this\n          cases' rl with rls rll rlx rlr\n          · rw [size, zero_add] at rd\n            exact absurd (le_trans rd (balancedSz_zero.1 hr.1.symm)) (by decide)\n          cases' rr with rrs rrl rrx rrr\n          · exact absurd (le_trans rd (balancedSz_zero.1 hr.1)) (by decide)\n          dsimp [rotateL]; split_ifs\n          · simp [node3L, node', sr.1]; abel\n          · simp [node4L, node', sr.1, sr.2.1.1]; abel\n        · have ld : delta ≤ size ll + size lr := by\n            have := lt_of_le_of_lt (Nat.mul_le_mul_left _ sr.pos) h_1\n            rwa [sl.1, Nat.lt_succ_iff] at this\n          cases' ll with lls lll llx llr\n          · rw [size, zero_add] at ld\n            exact absurd (le_trans ld (balancedSz_zero.1 hl.1.symm)) (by decide)\n          cases' lr with lrs lrl lrx lrr\n          · exact absurd (le_trans ld (balancedSz_zero.1 hl.1)) (by decide)\n          dsimp [rotateR]; split_ifs\n          · simp [node3R, node', sl.1]; abel\n          · simp [node4R, node', sl.1, sl.2.2.1]; abel\n        · simp [node']\n      · exact not_le_of_gt (add_le_add (Nat.succ_le_of_lt sl.pos) (Nat.succ_le_of_lt sr.pos))\n\n"}
{"name":"Ordnode.balanceL_eq_balance","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nr : Ordnode α\nsl : l.Sized\nsr : r.Sized\nH1 : Eq l.size 0 → LE.le r.size 1\nH2 : LE.le 1 l.size → LE.le 1 r.size → LE.le r.size (HMul.hMul Ordnode.delta l.size)\n⊢ Eq (l.balanceL x r) (l.balance x r)","decl":"theorem balanceL_eq_balance {l x r} (sl : Sized l) (sr : Sized r) (H1 : size l = 0 → size r ≤ 1)\n    (H2 : 1 ≤ size l → 1 ≤ size r → size r ≤ delta * size l) :\n    @balanceL α l x r = balance l x r := by\n  cases' r with rs rl rx rr\n  · rfl\n  · cases' l with ls ll lx lr\n    · have : size rl = 0 ∧ size rr = 0 := by\n        have := H1 rfl\n        rwa [size, sr.1, Nat.succ_le_succ_iff, Nat.le_zero, add_eq_zero] at this\n      cases sr.2.1.size_eq_zero.1 this.1\n      cases sr.2.2.size_eq_zero.1 this.2\n      rw [sr.eq_node']; rfl\n    · replace H2 : ¬rs > delta * ls := not_lt_of_le (H2 sl.pos sr.pos)\n      simp [balanceL, balance, H2]; split_ifs <;> simp [add_comm]\n\n"}
{"name":"Ordnode.raised_iff","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"n m : Nat\n⊢ Iff (Ordnode.Raised n m) (And (LE.le n m) (LE.le m (HAdd.hAdd n 1)))","decl":"theorem raised_iff {n m} : Raised n m ↔ n ≤ m ∧ m ≤ n + 1 := by\n  constructor\n  · rintro (rfl | rfl)\n    · exact ⟨le_rfl, Nat.le_succ _⟩\n    · exact ⟨Nat.le_succ _, le_rfl⟩\n  · rintro ⟨h₁, h₂⟩\n    rcases eq_or_lt_of_le h₁ with (rfl | h₁)\n    · exact Or.inl rfl\n    · exact Or.inr (le_antisymm h₂ h₁)\n\n"}
{"name":"Ordnode.Raised.dist_le","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"n m : Nat\nH : Ordnode.Raised n m\n⊢ LE.le (n.dist m) 1","decl":"theorem Raised.dist_le {n m} (H : Raised n m) : Nat.dist n m ≤ 1 := by\n  cases' raised_iff.1 H with H1 H2; rwa [Nat.dist_eq_sub_of_le H1, tsub_le_iff_left]\n\n"}
{"name":"Ordnode.Raised.dist_le'","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"n m : Nat\nH : Ordnode.Raised n m\n⊢ LE.le (m.dist n) 1","decl":"theorem Raised.dist_le' {n m} (H : Raised n m) : Nat.dist m n ≤ 1 := by\n  rw [Nat.dist_comm]; exact H.dist_le\n\n"}
{"name":"Ordnode.Raised.add_left","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"k n m : Nat\nH : Ordnode.Raised n m\n⊢ Ordnode.Raised (HAdd.hAdd k n) (HAdd.hAdd k m)","decl":"theorem Raised.add_left (k) {n m} (H : Raised n m) : Raised (k + n) (k + m) := by\n  rcases H with (rfl | rfl)\n  · exact Or.inl rfl\n  · exact Or.inr rfl\n\n"}
{"name":"Ordnode.Raised.add_right","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"k n m : Nat\nH : Ordnode.Raised n m\n⊢ Ordnode.Raised (HAdd.hAdd n k) (HAdd.hAdd m k)","decl":"theorem Raised.add_right (k) {n m} (H : Raised n m) : Raised (n + k) (m + k) := by\n  rw [add_comm, add_comm m]; exact H.add_left _\n\n"}
{"name":"Ordnode.Raised.right","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx₁ x₂ : α\nr₁ r₂ : Ordnode α\nH : Ordnode.Raised r₁.size r₂.size\n⊢ Ordnode.Raised (l.node' x₁ r₁).size (l.node' x₂ r₂).size","decl":"theorem Raised.right {l x₁ x₂ r₁ r₂} (H : Raised (size r₁) (size r₂)) :\n    Raised (size (@node' α l x₁ r₁)) (size (@node' α l x₂ r₂)) := by\n  rw [node', size_node, size_node]; generalize size r₂ = m at H ⊢\n  rcases H with (rfl | rfl)\n  · exact Or.inl rfl\n  · exact Or.inr rfl\n\n"}
{"name":"Ordnode.balanceL_eq_balance'","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nr : Ordnode α\nhl : l.Balanced\nhr : r.Balanced\nsl : l.Sized\nsr : r.Sized\nH : Or (Exists fun l' => And (Ordnode.Raised l' l.size) (Ordnode.BalancedSz l' r.size)) (Exists fun r' => And (Ordnode.Raised r.size r') (Ordnode.BalancedSz l.size r'))\n⊢ Eq (l.balanceL x r) (l.balance' x r)","decl":"theorem balanceL_eq_balance' {l x r} (hl : Balanced l) (hr : Balanced r) (sl : Sized l)\n    (sr : Sized r)\n    (H :\n      (∃ l', Raised l' (size l) ∧ BalancedSz l' (size r)) ∨\n        ∃ r', Raised (size r) r' ∧ BalancedSz (size l) r') :\n    @balanceL α l x r = balance' l x r := by\n  rw [← balance_eq_balance' hl hr sl sr, balanceL_eq_balance sl sr]\n  · intro l0; rw [l0] at H\n    rcases H with (⟨_, ⟨⟨⟩⟩ | ⟨⟨⟩⟩, H⟩ | ⟨r', e, H⟩)\n    · exact balancedSz_zero.1 H.symm\n    exact le_trans (raised_iff.1 e).1 (balancedSz_zero.1 H.symm)\n  · intro l1 _\n    rcases H with (⟨l', e, H | ⟨_, H₂⟩⟩ | ⟨r', e, H | ⟨_, H₂⟩⟩)\n    · exact le_trans (le_trans (Nat.le_add_left _ _) H) (mul_pos (by decide) l1 : (0 : ℕ) < _)\n    · exact le_trans H₂ (Nat.mul_le_mul_left _ (raised_iff.1 e).1)\n    · cases raised_iff.1 e; unfold delta; omega\n    · exact le_trans (raised_iff.1 e).1 H₂\n\n"}
{"name":"Ordnode.balance_sz_dual","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl r : Ordnode α\nH : Or (Exists fun l' => And (Ordnode.Raised l.size l') (Ordnode.BalancedSz l' r.size)) (Exists fun r' => And (Ordnode.Raised r' r.size) (Ordnode.BalancedSz l.size r'))\n⊢ Or (Exists fun l' => And (Ordnode.Raised l' r.dual.size) (Ordnode.BalancedSz l' l.dual.size)) (Exists fun r' => And (Ordnode.Raised l.dual.size r') (Ordnode.BalancedSz r.dual.size r'))","decl":"theorem balance_sz_dual {l r}\n    (H : (∃ l', Raised (@size α l) l' ∧ BalancedSz l' (@size α r)) ∨\n        ∃ r', Raised r' (size r) ∧ BalancedSz (size l) r') :\n    (∃ l', Raised l' (size (dual r)) ∧ BalancedSz l' (size (dual l))) ∨\n      ∃ r', Raised (size (dual l)) r' ∧ BalancedSz (size (dual r)) r' := by\n  rw [size_dual, size_dual]\n  exact\n    H.symm.imp (Exists.imp fun _ => And.imp_right BalancedSz.symm)\n      (Exists.imp fun _ => And.imp_right BalancedSz.symm)\n\n"}
{"name":"Ordnode.size_balanceL","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nr : Ordnode α\nhl : l.Balanced\nhr : r.Balanced\nsl : l.Sized\nsr : r.Sized\nH : Or (Exists fun l' => And (Ordnode.Raised l' l.size) (Ordnode.BalancedSz l' r.size)) (Exists fun r' => And (Ordnode.Raised r.size r') (Ordnode.BalancedSz l.size r'))\n⊢ Eq (l.balanceL x r).size (HAdd.hAdd (HAdd.hAdd l.size r.size) 1)","decl":"theorem size_balanceL {l x r} (hl : Balanced l) (hr : Balanced r) (sl : Sized l) (sr : Sized r)\n    (H : (∃ l', Raised l' (size l) ∧ BalancedSz l' (size r)) ∨\n        ∃ r', Raised (size r) r' ∧ BalancedSz (size l) r') :\n    size (@balanceL α l x r) = size l + size r + 1 := by\n  rw [balanceL_eq_balance' hl hr sl sr H, size_balance' sl sr]\n\n"}
{"name":"Ordnode.all_balanceL","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nP : α → Prop\nl : Ordnode α\nx : α\nr : Ordnode α\nhl : l.Balanced\nhr : r.Balanced\nsl : l.Sized\nsr : r.Sized\nH : Or (Exists fun l' => And (Ordnode.Raised l' l.size) (Ordnode.BalancedSz l' r.size)) (Exists fun r' => And (Ordnode.Raised r.size r') (Ordnode.BalancedSz l.size r'))\n⊢ Iff (Ordnode.All P (l.balanceL x r)) (And (Ordnode.All P l) (And (P x) (Ordnode.All P r)))","decl":"theorem all_balanceL {P l x r} (hl : Balanced l) (hr : Balanced r) (sl : Sized l) (sr : Sized r)\n    (H :\n      (∃ l', Raised l' (size l) ∧ BalancedSz l' (size r)) ∨\n        ∃ r', Raised (size r) r' ∧ BalancedSz (size l) r') :\n    All P (@balanceL α l x r) ↔ All P l ∧ P x ∧ All P r := by\n  rw [balanceL_eq_balance' hl hr sl sr H, all_balance']\n\n"}
{"name":"Ordnode.balanceR_eq_balance'","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nr : Ordnode α\nhl : l.Balanced\nhr : r.Balanced\nsl : l.Sized\nsr : r.Sized\nH : Or (Exists fun l' => And (Ordnode.Raised l.size l') (Ordnode.BalancedSz l' r.size)) (Exists fun r' => And (Ordnode.Raised r' r.size) (Ordnode.BalancedSz l.size r'))\n⊢ Eq (l.balanceR x r) (l.balance' x r)","decl":"theorem balanceR_eq_balance' {l x r} (hl : Balanced l) (hr : Balanced r) (sl : Sized l)\n    (sr : Sized r)\n    (H : (∃ l', Raised (size l) l' ∧ BalancedSz l' (size r)) ∨\n        ∃ r', Raised r' (size r) ∧ BalancedSz (size l) r') :\n    @balanceR α l x r = balance' l x r := by\n  rw [← dual_dual (balanceR l x r), dual_balanceR,\n    balanceL_eq_balance' hr.dual hl.dual sr.dual sl.dual (balance_sz_dual H), ← dual_balance',\n    dual_dual]\n\n"}
{"name":"Ordnode.size_balanceR","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nl : Ordnode α\nx : α\nr : Ordnode α\nhl : l.Balanced\nhr : r.Balanced\nsl : l.Sized\nsr : r.Sized\nH : Or (Exists fun l' => And (Ordnode.Raised l.size l') (Ordnode.BalancedSz l' r.size)) (Exists fun r' => And (Ordnode.Raised r' r.size) (Ordnode.BalancedSz l.size r'))\n⊢ Eq (l.balanceR x r).size (HAdd.hAdd (HAdd.hAdd l.size r.size) 1)","decl":"theorem size_balanceR {l x r} (hl : Balanced l) (hr : Balanced r) (sl : Sized l) (sr : Sized r)\n    (H : (∃ l', Raised (size l) l' ∧ BalancedSz l' (size r)) ∨\n        ∃ r', Raised r' (size r) ∧ BalancedSz (size l) r') :\n    size (@balanceR α l x r) = size l + size r + 1 := by\n  rw [balanceR_eq_balance' hl hr sl sr H, size_balance' sl sr]\n\n"}
{"name":"Ordnode.all_balanceR","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\nP : α → Prop\nl : Ordnode α\nx : α\nr : Ordnode α\nhl : l.Balanced\nhr : r.Balanced\nsl : l.Sized\nsr : r.Sized\nH : Or (Exists fun l' => And (Ordnode.Raised l.size l') (Ordnode.BalancedSz l' r.size)) (Exists fun r' => And (Ordnode.Raised r' r.size) (Ordnode.BalancedSz l.size r'))\n⊢ Iff (Ordnode.All P (l.balanceR x r)) (And (Ordnode.All P l) (And (P x) (Ordnode.All P r)))","decl":"theorem all_balanceR {P l x r} (hl : Balanced l) (hr : Balanced r) (sl : Sized l) (sr : Sized r)\n    (H :\n      (∃ l', Raised (size l) l' ∧ BalancedSz l' (size r)) ∨\n        ∃ r', Raised r' (size r) ∧ BalancedSz (size l) r') :\n    All P (@balanceR α l x r) ↔ All P l ∧ P x ∧ All P r := by\n  rw [balanceR_eq_balance' hl hr sl sr H, all_balance']\n\n"}
{"name":"Ordnode.Bounded.dual","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\na✝ : t.Bounded o₁ o₂\n⊢ t.dual.Bounded o₂ o₁","decl":"theorem Bounded.dual :\n    ∀ {t : Ordnode α} {o₁ o₂}, Bounded t o₁ o₂ → @Bounded αᵒᵈ _ (dual t) o₂ o₁\n  | nil, o₁, o₂, h => by cases o₁ <;> cases o₂ <;> trivial\n  | node _ _ _ _, _, _, ⟨ol, Or⟩ => ⟨Or.dual, ol.dual⟩\n\n"}
{"name":"Ordnode.Bounded.dual_iff","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\n⊢ Iff (t.Bounded o₁ o₂) (t.dual.Bounded o₂ o₁)","decl":"theorem Bounded.dual_iff {t : Ordnode α} {o₁ o₂} :\n    Bounded t o₁ o₂ ↔ @Bounded αᵒᵈ _ (.dual t) o₂ o₁ :=\n  ⟨Bounded.dual, fun h => by\n    have := Bounded.dual h; rwa [dual_dual, OrderDual.Preorder.dual_dual] at this⟩\n\n"}
{"name":"Ordnode.Bounded.weak_left","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\na✝ : t.Bounded o₁ o₂\n⊢ t.Bounded Bot.bot o₂","decl":"theorem Bounded.weak_left : ∀ {t : Ordnode α} {o₁ o₂}, Bounded t o₁ o₂ → Bounded t ⊥ o₂\n  | nil, o₁, o₂, h => by cases o₂ <;> trivial\n  | node _ _ _ _, _, _, ⟨ol, Or⟩ => ⟨ol.weak_left, Or⟩\n\n"}
{"name":"Ordnode.Bounded.weak_right","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\na✝ : t.Bounded o₁ o₂\n⊢ t.Bounded o₁ Top.top","decl":"theorem Bounded.weak_right : ∀ {t : Ordnode α} {o₁ o₂}, Bounded t o₁ o₂ → Bounded t o₁ ⊤\n  | nil, o₁, o₂, h => by cases o₁ <;> trivial\n  | node _ _ _ _, _, _, ⟨ol, Or⟩ => ⟨ol, Or.weak_right⟩\n\n"}
{"name":"Ordnode.Bounded.weak","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nh : t.Bounded o₁ o₂\n⊢ t.Bounded Bot.bot Top.top","decl":"theorem Bounded.weak {t : Ordnode α} {o₁ o₂} (h : Bounded t o₁ o₂) : Bounded t ⊥ ⊤ :=\n  h.weak_left.weak_right\n\n"}
{"name":"Ordnode.Bounded.mono_left","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx y : α\nxy : LE.le x y\nt : Ordnode α\no : WithTop α\na✝ : t.Bounded (↑y) o\n⊢ t.Bounded (↑x) o","decl":"theorem Bounded.mono_left {x y : α} (xy : x ≤ y) :\n    ∀ {t : Ordnode α} {o}, Bounded t y o → Bounded t x o\n  | nil, none, _ => ⟨⟩\n  | nil, some _, h => lt_of_le_of_lt xy h\n  | node _ _ _ _, _o, ⟨ol, or⟩ => ⟨ol.mono_left xy, or⟩\n\n"}
{"name":"Ordnode.Bounded.mono_right","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx y : α\nxy : LE.le x y\nt : Ordnode α\no : WithBot α\na✝ : t.Bounded o ↑x\n⊢ t.Bounded o ↑y","decl":"theorem Bounded.mono_right {x y : α} (xy : x ≤ y) :\n    ∀ {t : Ordnode α} {o}, Bounded t o x → Bounded t o y\n  | nil, none, _ => ⟨⟩\n  | nil, some _, h => lt_of_lt_of_le h xy\n  | node _ _ _ _, _o, ⟨ol, or⟩ => ⟨ol, or.mono_right xy⟩\n\n"}
{"name":"Ordnode.Bounded.to_lt","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt : Ordnode α\nx y : α\na✝ : t.Bounded ↑x ↑y\n⊢ LT.lt x y","decl":"theorem Bounded.to_lt : ∀ {t : Ordnode α} {x y : α}, Bounded t x y → x < y\n  | nil, _, _, h => h\n  | node _ _ _ _, _, _, ⟨h₁, h₂⟩ => lt_trans h₁.to_lt h₂.to_lt\n\n"}
{"name":"Ordnode.Bounded.to_nil","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\na✝ : t.Bounded o₁ o₂\n⊢ Ordnode.nil.Bounded o₁ o₂","decl":"theorem Bounded.to_nil {t : Ordnode α} : ∀ {o₁ o₂}, Bounded t o₁ o₂ → Bounded nil o₁ o₂\n  | none, _, _ => ⟨⟩\n  | some _, none, _ => ⟨⟩\n  | some _, some _, h => h.to_lt\n\n"}
{"name":"Ordnode.Bounded.trans_left","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt₁ t₂ : Ordnode α\nx : α\no₁ : WithBot α\no₂ : WithTop α\na✝¹ : t₁.Bounded o₁ ↑x\na✝ : t₂.Bounded (↑x) o₂\n⊢ t₂.Bounded o₁ o₂","decl":"theorem Bounded.trans_left {t₁ t₂ : Ordnode α} {x : α} :\n    ∀ {o₁ o₂}, Bounded t₁ o₁ x → Bounded t₂ x o₂ → Bounded t₂ o₁ o₂\n  | none, _, _, h₂ => h₂.weak_left\n  | some _, _, h₁, h₂ => h₂.mono_left (le_of_lt h₁.to_lt)\n\n"}
{"name":"Ordnode.Bounded.trans_right","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt₁ t₂ : Ordnode α\nx : α\no₁ : WithBot α\no₂ : WithTop α\na✝¹ : t₁.Bounded o₁ ↑x\na✝ : t₂.Bounded (↑x) o₂\n⊢ t₁.Bounded o₁ o₂","decl":"theorem Bounded.trans_right {t₁ t₂ : Ordnode α} {x : α} :\n    ∀ {o₁ o₂}, Bounded t₁ o₁ x → Bounded t₂ x o₂ → Bounded t₁ o₁ o₂\n  | _, none, h₁, _ => h₁.weak_right\n  | _, some _, h₁, h₂ => h₁.mono_right (le_of_lt h₂.to_lt)\n\n"}
{"name":"Ordnode.Bounded.mem_lt","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt : Ordnode α\no : WithBot α\nx : α\na✝ : t.Bounded o ↑x\n⊢ Ordnode.All (fun x_1 => LT.lt x_1 x) t","decl":"theorem Bounded.mem_lt : ∀ {t o} {x : α}, Bounded t o x → All (· < x) t\n  | nil, _, _, _ => ⟨⟩\n  | node _ _ _ _, _, _, ⟨h₁, h₂⟩ =>\n    ⟨h₁.mem_lt.imp fun _ h => lt_trans h h₂.to_lt, h₂.to_lt, h₂.mem_lt⟩\n\n"}
{"name":"Ordnode.Bounded.mem_gt","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt : Ordnode α\no : WithTop α\nx : α\na✝ : t.Bounded (↑x) o\n⊢ Ordnode.All (fun x_1 => GT.gt x_1 x) t","decl":"theorem Bounded.mem_gt : ∀ {t o} {x : α}, Bounded t x o → All (· > x) t\n  | nil, _, _, _ => ⟨⟩\n  | node _ _ _ _, _, _, ⟨h₁, h₂⟩ => ⟨h₁.mem_gt, h₁.to_lt, h₂.mem_gt.imp fun _ => lt_trans h₁.to_lt⟩\n\n"}
{"name":"Ordnode.Bounded.of_lt","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nx : α\na✝² : t.Bounded o₁ o₂\na✝¹ : Ordnode.nil.Bounded o₁ ↑x\na✝ : Ordnode.All (fun x_1 => LT.lt x_1 x) t\n⊢ t.Bounded o₁ ↑x","decl":"theorem Bounded.of_lt :\n    ∀ {t o₁ o₂} {x : α}, Bounded t o₁ o₂ → Bounded nil o₁ x → All (· < x) t → Bounded t o₁ x\n  | nil, _, _, _, _, hn, _ => hn\n  | node _ _ _ _, _, _, _, ⟨h₁, h₂⟩, _, ⟨_, al₂, al₃⟩ => ⟨h₁, h₂.of_lt al₂ al₃⟩\n\n"}
{"name":"Ordnode.Bounded.of_gt","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nx : α\na✝² : t.Bounded o₁ o₂\na✝¹ : Ordnode.nil.Bounded (↑x) o₂\na✝ : Ordnode.All (fun x_1 => GT.gt x_1 x) t\n⊢ t.Bounded (↑x) o₂","decl":"theorem Bounded.of_gt :\n    ∀ {t o₁ o₂} {x : α}, Bounded t o₁ o₂ → Bounded nil x o₂ → All (· > x) t → Bounded t x o₂\n  | nil, _, _, _, _, hn, _ => hn\n  | node _ _ _ _, _, _, _, ⟨h₁, h₂⟩, _, ⟨al₁, al₂, _⟩ => ⟨h₁.of_gt al₂ al₁, h₂⟩\n\n"}
{"name":"Ordnode.Bounded.to_sep","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt₁ t₂ : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nx : α\nh₁ : t₁.Bounded o₁ ↑x\nh₂ : t₂.Bounded (↑x) o₂\n⊢ Ordnode.All (fun y => Ordnode.All (fun z => LT.lt y z) t₂) t₁","decl":"theorem Bounded.to_sep {t₁ t₂ o₁ o₂} {x : α}\n    (h₁ : Bounded t₁ o₁ (x : WithTop α)) (h₂ : Bounded t₂ (x : WithBot α) o₂) :\n    t₁.All fun y => t₂.All fun z : α => y < z := by\n  refine h₁.mem_lt.imp fun y yx => ?_\n  exact h₂.mem_gt.imp fun z xz => lt_trans yx xz\n\n"}
{"name":"Ordnode.Valid'.ord","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nlo : WithBot α\nt : Ordnode α\nhi : WithTop α\nself : Ordnode.Valid' lo t hi\n⊢ t.Bounded lo hi","decl":"/-- The validity predicate for an `Ordnode` subtree. This asserts that the `size` fields are\ncorrect, the tree is balanced, and the elements of the tree are organized according to the\nordering. This version of `Valid` also puts all elements in the tree in the interval `(lo, hi)`. -/\nstructure Valid' (lo : WithBot α) (t : Ordnode α) (hi : WithTop α) : Prop where\n  ord : t.Bounded lo hi\n  sz : t.Sized\n  bal : t.Balanced\n\n"}
{"name":"Ordnode.Valid'.bal","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nlo : WithBot α\nt : Ordnode α\nhi : WithTop α\nself : Ordnode.Valid' lo t hi\n⊢ t.Balanced","decl":"/-- The validity predicate for an `Ordnode` subtree. This asserts that the `size` fields are\ncorrect, the tree is balanced, and the elements of the tree are organized according to the\nordering. This version of `Valid` also puts all elements in the tree in the interval `(lo, hi)`. -/\nstructure Valid' (lo : WithBot α) (t : Ordnode α) (hi : WithTop α) : Prop where\n  ord : t.Bounded lo hi\n  sz : t.Sized\n  bal : t.Balanced\n\n"}
{"name":"Ordnode.Valid'.sz","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nlo : WithBot α\nt : Ordnode α\nhi : WithTop α\nself : Ordnode.Valid' lo t hi\n⊢ t.Sized","decl":"/-- The validity predicate for an `Ordnode` subtree. This asserts that the `size` fields are\ncorrect, the tree is balanced, and the elements of the tree are organized according to the\nordering. This version of `Valid` also puts all elements in the tree in the interval `(lo, hi)`. -/\nstructure Valid' (lo : WithBot α) (t : Ordnode α) (hi : WithTop α) : Prop where\n  ord : t.Bounded lo hi\n  sz : t.Sized\n  bal : t.Balanced\n\n"}
{"name":"Ordnode.Valid'.mono_left","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx y : α\nxy : LE.le x y\nt : Ordnode α\no : WithTop α\nh : Ordnode.Valid' (↑y) t o\n⊢ Ordnode.Valid' (↑x) t o","decl":"theorem Valid'.mono_left {x y : α} (xy : x ≤ y) {t : Ordnode α} {o} (h : Valid' y t o) :\n    Valid' x t o :=\n  ⟨h.1.mono_left xy, h.2, h.3⟩\n\n"}
{"name":"Ordnode.Valid'.mono_right","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx y : α\nxy : LE.le x y\nt : Ordnode α\no : WithBot α\nh : Ordnode.Valid' o t ↑x\n⊢ Ordnode.Valid' o t ↑y","decl":"theorem Valid'.mono_right {x y : α} (xy : x ≤ y) {t : Ordnode α} {o} (h : Valid' o t x) :\n    Valid' o t y :=\n  ⟨h.1.mono_right xy, h.2, h.3⟩\n\n"}
{"name":"Ordnode.Valid'.trans_left","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt₁ t₂ : Ordnode α\nx : α\no₁ : WithBot α\no₂ : WithTop α\nh : t₁.Bounded o₁ ↑x\nH : Ordnode.Valid' (↑x) t₂ o₂\n⊢ Ordnode.Valid' o₁ t₂ o₂","decl":"theorem Valid'.trans_left {t₁ t₂ : Ordnode α} {x : α} {o₁ o₂} (h : Bounded t₁ o₁ x)\n    (H : Valid' x t₂ o₂) : Valid' o₁ t₂ o₂ :=\n  ⟨h.trans_left H.1, H.2, H.3⟩\n\n"}
{"name":"Ordnode.Valid'.trans_right","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt₁ t₂ : Ordnode α\nx : α\no₁ : WithBot α\no₂ : WithTop α\nH : Ordnode.Valid' o₁ t₁ ↑x\nh : t₂.Bounded (↑x) o₂\n⊢ Ordnode.Valid' o₁ t₁ o₂","decl":"theorem Valid'.trans_right {t₁ t₂ : Ordnode α} {x : α} {o₁ o₂} (H : Valid' o₁ t₁ x)\n    (h : Bounded t₂ x o₂) : Valid' o₁ t₁ o₂ :=\n  ⟨H.1.trans_right h, H.2, H.3⟩\n\n"}
{"name":"Ordnode.Valid'.of_lt","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt : Ordnode α\nx : α\no₁ : WithBot α\no₂ : WithTop α\nH : Ordnode.Valid' o₁ t o₂\nh₁ : Ordnode.nil.Bounded o₁ ↑x\nh₂ : Ordnode.All (fun x_1 => LT.lt x_1 x) t\n⊢ Ordnode.Valid' o₁ t ↑x","decl":"theorem Valid'.of_lt {t : Ordnode α} {x : α} {o₁ o₂} (H : Valid' o₁ t o₂) (h₁ : Bounded nil o₁ x)\n    (h₂ : All (· < x) t) : Valid' o₁ t x :=\n  ⟨H.1.of_lt h₁ h₂, H.2, H.3⟩\n\n"}
{"name":"Ordnode.Valid'.of_gt","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt : Ordnode α\nx : α\no₁ : WithBot α\no₂ : WithTop α\nH : Ordnode.Valid' o₁ t o₂\nh₁ : Ordnode.nil.Bounded (↑x) o₂\nh₂ : Ordnode.All (fun x_1 => GT.gt x_1 x) t\n⊢ Ordnode.Valid' (↑x) t o₂","decl":"theorem Valid'.of_gt {t : Ordnode α} {x : α} {o₁ o₂} (H : Valid' o₁ t o₂) (h₁ : Bounded nil x o₂)\n    (h₂ : All (· > x) t) : Valid' x t o₂ :=\n  ⟨H.1.of_gt h₁ h₂, H.2, H.3⟩\n\n"}
{"name":"Ordnode.Valid'.valid","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nh : Ordnode.Valid' o₁ t o₂\n⊢ t.Valid","decl":"theorem Valid'.valid {t o₁ o₂} (h : @Valid' α _ o₁ t o₂) : Valid t :=\n  ⟨h.1.weak, h.2, h.3⟩\n\n"}
{"name":"Ordnode.valid'_nil","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\no₁ : WithBot α\no₂ : WithTop α\nh : Ordnode.nil.Bounded o₁ o₂\n⊢ Ordnode.Valid' o₁ Ordnode.nil o₂","decl":"theorem valid'_nil {o₁ o₂} (h : Bounded nil o₁ o₂) : Valid' o₁ (@nil α) o₂ :=\n  ⟨h, ⟨⟩, ⟨⟩⟩\n\n"}
{"name":"Ordnode.valid_nil","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Ordnode.nil.Valid","decl":"theorem valid_nil : Valid (@nil α) :=\n  valid'_nil ⟨⟩\n\n"}
{"name":"Ordnode.Valid'.node","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Nat\nl : Ordnode α\nx : α\nr : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nhl : Ordnode.Valid' o₁ l ↑x\nhr : Ordnode.Valid' (↑x) r o₂\nH : Ordnode.BalancedSz l.size r.size\nhs : Eq s (HAdd.hAdd (HAdd.hAdd l.size r.size) 1)\n⊢ Ordnode.Valid' o₁ (Ordnode.node s l x r) o₂","decl":"theorem Valid'.node {s l} {x : α} {r o₁ o₂} (hl : Valid' o₁ l x) (hr : Valid' x r o₂)\n    (H : BalancedSz (size l) (size r)) (hs : s = size l + size r + 1) :\n    Valid' o₁ (@node α s l x r) o₂ :=\n  ⟨⟨hl.1, hr.1⟩, ⟨hs, hl.2, hr.2⟩, ⟨H, hl.3, hr.3⟩⟩\n\n"}
{"name":"Ordnode.Valid'.dual","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\na✝ : Ordnode.Valid' o₁ t o₂\n⊢ Ordnode.Valid' o₂ t.dual o₁","decl":"theorem Valid'.dual : ∀ {t : Ordnode α} {o₁ o₂}, Valid' o₁ t o₂ → @Valid' αᵒᵈ _ o₂ (dual t) o₁\n  | .nil, _, _, h => valid'_nil h.1.dual\n  | .node _ l _ r, _, _, ⟨⟨ol, Or⟩, ⟨rfl, sl, sr⟩, ⟨b, bl, br⟩⟩ =>\n    let ⟨ol', sl', bl'⟩ := Valid'.dual ⟨ol, sl, bl⟩\n    let ⟨or', sr', br'⟩ := Valid'.dual ⟨Or, sr, br⟩\n    ⟨⟨or', ol'⟩, ⟨by simp [size_dual, add_comm], sr', sl'⟩,\n      ⟨by rw [size_dual, size_dual]; exact b.symm, br', bl'⟩⟩\n\n"}
{"name":"Ordnode.Valid'.dual_iff","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\n⊢ Iff (Ordnode.Valid' o₁ t o₂) (Ordnode.Valid' o₂ t.dual o₁)","decl":"theorem Valid'.dual_iff {t : Ordnode α} {o₁ o₂} : Valid' o₁ t o₂ ↔ @Valid' αᵒᵈ _ o₂ (.dual t) o₁ :=\n  ⟨Valid'.dual, fun h => by\n    have := Valid'.dual h; rwa [dual_dual, OrderDual.Preorder.dual_dual] at this⟩\n\n"}
{"name":"Ordnode.Valid.dual","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt : Ordnode α\na✝ : t.Valid\n⊢ t.dual.Valid","decl":"theorem Valid.dual {t : Ordnode α} : Valid t → @Valid αᵒᵈ _ (.dual t) :=\n  Valid'.dual\n\n"}
{"name":"Ordnode.Valid.dual_iff","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt : Ordnode α\n⊢ Iff t.Valid t.dual.Valid","decl":"theorem Valid.dual_iff {t : Ordnode α} : Valid t ↔ @Valid αᵒᵈ _ (.dual t) :=\n  Valid'.dual_iff\n\n"}
{"name":"Ordnode.Valid'.left","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Nat\nl : Ordnode α\nx : α\nr : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nH : Ordnode.Valid' o₁ (Ordnode.node s l x r) o₂\n⊢ Ordnode.Valid' o₁ l ↑x","decl":"theorem Valid'.left {s l x r o₁ o₂} (H : Valid' o₁ (@Ordnode.node α s l x r) o₂) : Valid' o₁ l x :=\n  ⟨H.1.1, H.2.2.1, H.3.2.1⟩\n\n"}
{"name":"Ordnode.Valid'.right","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Nat\nl : Ordnode α\nx : α\nr : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nH : Ordnode.Valid' o₁ (Ordnode.node s l x r) o₂\n⊢ Ordnode.Valid' (↑x) r o₂","decl":"theorem Valid'.right {s l x r o₁ o₂} (H : Valid' o₁ (@Ordnode.node α s l x r) o₂) : Valid' x r o₂ :=\n  ⟨H.1.2, H.2.2.2, H.3.2.2⟩\n\n"}
{"name":"Ordnode.Valid.left","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Nat\nl : Ordnode α\nx : α\nr : Ordnode α\nH : (Ordnode.node s l x r).Valid\n⊢ l.Valid","decl":"nonrec theorem Valid.left {s l x r} (H : Valid (@node α s l x r)) : Valid l :=\n  H.left.valid\n\n"}
{"name":"Ordnode.Valid.right","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Nat\nl : Ordnode α\nx : α\nr : Ordnode α\nH : (Ordnode.node s l x r).Valid\n⊢ r.Valid","decl":"nonrec theorem Valid.right {s l x r} (H : Valid (@node α s l x r)) : Valid r :=\n  H.right.valid\n\n"}
{"name":"Ordnode.Valid.size_eq","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Nat\nl : Ordnode α\nx : α\nr : Ordnode α\nH : (Ordnode.node s l x r).Valid\n⊢ Eq (Ordnode.node s l x r).size (HAdd.hAdd (HAdd.hAdd l.size r.size) 1)","decl":"theorem Valid.size_eq {s l x r} (H : Valid (@node α s l x r)) :\n    size (@node α s l x r) = size l + size r + 1 :=\n  H.2.1\n\n"}
{"name":"Ordnode.Valid'.node'","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nl : Ordnode α\nx : α\nr : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nhl : Ordnode.Valid' o₁ l ↑x\nhr : Ordnode.Valid' (↑x) r o₂\nH : Ordnode.BalancedSz l.size r.size\n⊢ Ordnode.Valid' o₁ (l.node' x r) o₂","decl":"theorem Valid'.node' {l} {x : α} {r o₁ o₂} (hl : Valid' o₁ l x) (hr : Valid' x r o₂)\n    (H : BalancedSz (size l) (size r)) : Valid' o₁ (@node' α l x r) o₂ :=\n  hl.node hr H rfl\n\n"}
{"name":"Ordnode.valid'_singleton","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\no₁ : WithBot α\no₂ : WithTop α\nh₁ : Ordnode.nil.Bounded o₁ ↑x\nh₂ : Ordnode.nil.Bounded (↑x) o₂\n⊢ Ordnode.Valid' o₁ (Singleton.singleton x) o₂","decl":"theorem valid'_singleton {x : α} {o₁ o₂} (h₁ : Bounded nil o₁ x) (h₂ : Bounded nil x o₂) :\n    Valid' o₁ (singleton x : Ordnode α) o₂ :=\n  (valid'_nil h₁).node (valid'_nil h₂) (Or.inl zero_le_one) rfl\n\n"}
{"name":"Ordnode.valid_singleton","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\n⊢ (Singleton.singleton x).Valid","decl":"theorem valid_singleton {x : α} : Valid (singleton x : Ordnode α) :=\n  valid'_singleton ⟨⟩ ⟨⟩\n\n"}
{"name":"Ordnode.Valid'.node3L","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nl : Ordnode α\nx : α\nm : Ordnode α\ny : α\nr : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nhl : Ordnode.Valid' o₁ l ↑x\nhm : Ordnode.Valid' (↑x) m ↑y\nhr : Ordnode.Valid' (↑y) r o₂\nH1 : Ordnode.BalancedSz l.size m.size\nH2 : Ordnode.BalancedSz (HAdd.hAdd (HAdd.hAdd l.size m.size) 1) r.size\n⊢ Ordnode.Valid' o₁ (l.node3L x m y r) o₂","decl":"theorem Valid'.node3L {l} {x : α} {m} {y : α} {r o₁ o₂} (hl : Valid' o₁ l x) (hm : Valid' x m y)\n    (hr : Valid' y r o₂) (H1 : BalancedSz (size l) (size m))\n    (H2 : BalancedSz (size l + size m + 1) (size r)) : Valid' o₁ (@node3L α l x m y r) o₂ :=\n  (hl.node' hm H1).node' hr H2\n\n"}
{"name":"Ordnode.Valid'.node3R","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nl : Ordnode α\nx : α\nm : Ordnode α\ny : α\nr : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nhl : Ordnode.Valid' o₁ l ↑x\nhm : Ordnode.Valid' (↑x) m ↑y\nhr : Ordnode.Valid' (↑y) r o₂\nH1 : Ordnode.BalancedSz l.size (HAdd.hAdd (HAdd.hAdd m.size r.size) 1)\nH2 : Ordnode.BalancedSz m.size r.size\n⊢ Ordnode.Valid' o₁ (l.node3R x m y r) o₂","decl":"theorem Valid'.node3R {l} {x : α} {m} {y : α} {r o₁ o₂} (hl : Valid' o₁ l x) (hm : Valid' x m y)\n    (hr : Valid' y r o₂) (H1 : BalancedSz (size l) (size m + size r + 1))\n    (H2 : BalancedSz (size m) (size r)) : Valid' o₁ (@node3R α l x m y r) o₂ :=\n  hl.node' (hm.node' hr H2) H1\n\n"}
{"name":"Ordnode.Valid'.node4L_lemma₁","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"a b c d : Nat\nlr₂ : LE.le (HMul.hMul 3 (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd b c) 1) d)) (HAdd.hAdd (HMul.hMul 16 a) 9)\nmr₂ : LE.le (HAdd.hAdd (HAdd.hAdd b c) 1) (HMul.hMul 3 d)\nmm₁ : LE.le b (HMul.hMul 3 c)\n⊢ LT.lt b (HAdd.hAdd (HMul.hMul 3 a) 1)","decl":"theorem Valid'.node4L_lemma₁ {a b c d : ℕ} (lr₂ : 3 * (b + c + 1 + d) ≤ 16 * a + 9)\n    (mr₂ : b + c + 1 ≤ 3 * d) (mm₁ : b ≤ 3 * c) : b < 3 * a + 1 := by omega\n\n"}
{"name":"Ordnode.Valid'.node4L_lemma₂","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"b c d : Nat\nmr₂ : LE.le (HAdd.hAdd (HAdd.hAdd b c) 1) (HMul.hMul 3 d)\n⊢ LE.le c (HMul.hMul 3 d)","decl":"theorem Valid'.node4L_lemma₂ {b c d : ℕ} (mr₂ : b + c + 1 ≤ 3 * d) : c ≤ 3 * d := by omega\n\n"}
{"name":"Ordnode.Valid'.node4L_lemma₃","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"b c d : Nat\nmr₁ : LE.le (HMul.hMul 2 d) (HAdd.hAdd (HAdd.hAdd b c) 1)\nmm₁ : LE.le b (HMul.hMul 3 c)\n⊢ LE.le d (HMul.hMul 3 c)","decl":"theorem Valid'.node4L_lemma₃ {b c d : ℕ} (mr₁ : 2 * d ≤ b + c + 1) (mm₁ : b ≤ 3 * c) :\n    d ≤ 3 * c := by omega\n\n"}
{"name":"Ordnode.Valid'.node4L_lemma₄","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"a b c d : Nat\nlr₁ : LE.le (HMul.hMul 3 a) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd b c) 1) d)\nmr₂ : LE.le (HAdd.hAdd (HAdd.hAdd b c) 1) (HMul.hMul 3 d)\nmm₁ : LE.le b (HMul.hMul 3 c)\n⊢ LE.le (HAdd.hAdd (HAdd.hAdd a b) 1) (HMul.hMul 3 (HAdd.hAdd (HAdd.hAdd c d) 1))","decl":"theorem Valid'.node4L_lemma₄ {a b c d : ℕ} (lr₁ : 3 * a ≤ b + c + 1 + d) (mr₂ : b + c + 1 ≤ 3 * d)\n    (mm₁ : b ≤ 3 * c) : a + b + 1 ≤ 3 * (c + d + 1) := by omega\n\n"}
{"name":"Ordnode.Valid'.node4L_lemma₅","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"a b c d : Nat\nlr₂ : LE.le (HMul.hMul 3 (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd b c) 1) d)) (HAdd.hAdd (HMul.hMul 16 a) 9)\nmr₁ : LE.le (HMul.hMul 2 d) (HAdd.hAdd (HAdd.hAdd b c) 1)\nmm₂ : LE.le c (HMul.hMul 3 b)\n⊢ LE.le (HAdd.hAdd (HAdd.hAdd c d) 1) (HMul.hMul 3 (HAdd.hAdd (HAdd.hAdd a b) 1))","decl":"theorem Valid'.node4L_lemma₅ {a b c d : ℕ} (lr₂ : 3 * (b + c + 1 + d) ≤ 16 * a + 9)\n    (mr₁ : 2 * d ≤ b + c + 1) (mm₂ : c ≤ 3 * b) : c + d + 1 ≤ 3 * (a + b + 1) := by omega\n\n"}
{"name":"Ordnode.Valid'.node4L","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nl : Ordnode α\nx : α\nm : Ordnode α\ny : α\nr : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nhl : Ordnode.Valid' o₁ l ↑x\nhm : Ordnode.Valid' (↑x) m ↑y\nhr : Ordnode.Valid' (↑y) r o₂\nHm : LT.lt 0 m.size\nH : Or (And (Eq l.size 0) (And (Eq m.size 1) (LE.le r.size 1))) (And (LT.lt 0 l.size) (And (LE.le (HMul.hMul Ordnode.ratio r.size) m.size) (And (LE.le (HMul.hMul Ordnode.delta l.size) (HAdd.hAdd m.size r.size)) (And (LE.le (HMul.hMul 3 (HAdd.hAdd m.size r.size)) (HAdd.hAdd (HMul.hMul 16 l.size) 9)) (LE.le m.size (HMul.hMul Ordnode.delta r.size))))))\n⊢ Ordnode.Valid' o₁ (l.node4L x m y r) o₂","decl":"theorem Valid'.node4L {l} {x : α} {m} {y : α} {r o₁ o₂} (hl : Valid' o₁ l x) (hm : Valid' x m y)\n    (hr : Valid' (↑y) r o₂) (Hm : 0 < size m)\n    (H : size l = 0 ∧ size m = 1 ∧ size r ≤ 1 ∨\n        0 < size l ∧\n          ratio * size r ≤ size m ∧\n            delta * size l ≤ size m + size r ∧\n              3 * (size m + size r) ≤ 16 * size l + 9 ∧ size m ≤ delta * size r) :\n    Valid' o₁ (@node4L α l x m y r) o₂ := by\n  cases' m with s ml z mr; · cases Hm\n  suffices\n    BalancedSz (size l) (size ml) ∧\n      BalancedSz (size mr) (size r) ∧ BalancedSz (size l + size ml + 1) (size mr + size r + 1) from\n    Valid'.node' (hl.node' hm.left this.1) (hm.right.node' hr this.2.1) this.2.2\n  rcases H with (⟨l0, m1, r0⟩ | ⟨l0, mr₁, lr₁, lr₂, mr₂⟩)\n  · rw [hm.2.size_eq, Nat.succ_inj', add_eq_zero] at m1\n    rw [l0, m1.1, m1.2]; revert r0; rcases size r with (_ | _ | _) <;>\n      [decide; decide; (intro r0; unfold BalancedSz delta; omega)]\n  · rcases Nat.eq_zero_or_pos (size r) with r0 | r0\n    · rw [r0] at mr₂; cases not_le_of_lt Hm mr₂\n    rw [hm.2.size_eq] at lr₁ lr₂ mr₁ mr₂\n    by_cases mm : size ml + size mr ≤ 1\n    · have r1 :=\n        le_antisymm\n          ((mul_le_mul_left (by decide)).1 (le_trans mr₁ (Nat.succ_le_succ mm) : _ ≤ ratio * 1)) r0\n      rw [r1, add_assoc] at lr₁\n      have l1 :=\n        le_antisymm\n          ((mul_le_mul_left (by decide)).1 (le_trans lr₁ (add_le_add_right mm 2) : _ ≤ delta * 1))\n          l0\n      rw [l1, r1]\n      revert mm; cases size ml <;> cases size mr <;> intro mm\n      · decide\n      · rw [zero_add] at mm; rcases mm with (_ | ⟨⟨⟩⟩)\n        decide\n      · rcases mm with (_ | ⟨⟨⟩⟩); decide\n      · rw [Nat.succ_add] at mm; rcases mm with (_ | ⟨⟨⟩⟩)\n    rcases hm.3.1.resolve_left mm with ⟨mm₁, mm₂⟩\n    rcases Nat.eq_zero_or_pos (size ml) with ml0 | ml0\n    · rw [ml0, mul_zero, Nat.le_zero] at mm₂\n      rw [ml0, mm₂] at mm; cases mm (by decide)\n    have : 2 * size l ≤ size ml + size mr + 1 := by\n      have := Nat.mul_le_mul_left ratio lr₁\n      rw [mul_left_comm, mul_add] at this\n      have := le_trans this (add_le_add_left mr₁ _)\n      rw [← Nat.succ_mul] at this\n      exact (mul_le_mul_left (by decide)).1 this\n    refine ⟨Or.inr ⟨?_, ?_⟩, Or.inr ⟨?_, ?_⟩, Or.inr ⟨?_, ?_⟩⟩\n    · refine (mul_le_mul_left (by decide)).1 (le_trans this ?_)\n      rw [two_mul, Nat.succ_le_iff]\n      refine add_lt_add_of_lt_of_le ?_ mm₂\n      simpa using (mul_lt_mul_right ml0).2 (by decide : 1 < 3)\n    · exact Nat.le_of_lt_succ (Valid'.node4L_lemma₁ lr₂ mr₂ mm₁)\n    · exact Valid'.node4L_lemma₂ mr₂\n    · exact Valid'.node4L_lemma₃ mr₁ mm₁\n    · exact Valid'.node4L_lemma₄ lr₁ mr₂ mm₁\n    · exact Valid'.node4L_lemma₅ lr₂ mr₁ mm₂\n\n"}
{"name":"Ordnode.Valid'.rotateL_lemma₁","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"a b c : Nat\nH2 : LE.le (HMul.hMul 3 a) (HAdd.hAdd b c)\nhb₂ : LE.le c (HMul.hMul 3 b)\n⊢ LE.le a (HMul.hMul 3 b)","decl":"theorem Valid'.rotateL_lemma₁ {a b c : ℕ} (H2 : 3 * a ≤ b + c) (hb₂ : c ≤ 3 * b) : a ≤ 3 * b := by\n  omega\n\n"}
{"name":"Ordnode.Valid'.rotateL_lemma₂","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"a b c : Nat\nH3 : LE.le (HMul.hMul 2 (HAdd.hAdd b c)) (HAdd.hAdd (HMul.hMul 9 a) 3)\nh : LT.lt b (HMul.hMul 2 c)\n⊢ LT.lt b (HAdd.hAdd (HMul.hMul 3 a) 1)","decl":"theorem Valid'.rotateL_lemma₂ {a b c : ℕ} (H3 : 2 * (b + c) ≤ 9 * a + 3) (h : b < 2 * c) :\n    b < 3 * a + 1 := by omega\n\n"}
{"name":"Ordnode.Valid'.rotateL_lemma₃","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"a b c : Nat\nH2 : LE.le (HMul.hMul 3 a) (HAdd.hAdd b c)\nh : LT.lt b (HMul.hMul 2 c)\n⊢ LT.lt (HAdd.hAdd a b) (HMul.hMul 3 c)","decl":"theorem Valid'.rotateL_lemma₃ {a b c : ℕ} (H2 : 3 * a ≤ b + c) (h : b < 2 * c) : a + b < 3 * c := by\n  omega\n\n"}
{"name":"Ordnode.Valid'.rotateL_lemma₄","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"a b : Nat\nH3 : LE.le (HMul.hMul 2 b) (HAdd.hAdd (HMul.hMul 9 a) 3)\n⊢ LE.le (HMul.hMul 3 b) (HAdd.hAdd (HMul.hMul 16 a) 9)","decl":"theorem Valid'.rotateL_lemma₄ {a b : ℕ} (H3 : 2 * b ≤ 9 * a + 3) : 3 * b ≤ 16 * a + 9 := by\n  omega\n\n"}
{"name":"Ordnode.Valid'.rotateL","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nl : Ordnode α\nx : α\nr : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nhl : Ordnode.Valid' o₁ l ↑x\nhr : Ordnode.Valid' (↑x) r o₂\nH1 : Not (LE.le (HAdd.hAdd l.size r.size) 1)\nH2 : LT.lt (HMul.hMul Ordnode.delta l.size) r.size\nH3 : Or (LE.le (HMul.hMul 2 r.size) (HAdd.hAdd (HMul.hMul 9 l.size) 5)) (LE.le r.size 3)\n⊢ Ordnode.Valid' o₁ (l.rotateL x r) o₂","decl":"theorem Valid'.rotateL {l} {x : α} {r o₁ o₂} (hl : Valid' o₁ l x) (hr : Valid' x r o₂)\n    (H1 : ¬size l + size r ≤ 1) (H2 : delta * size l < size r)\n    (H3 : 2 * size r ≤ 9 * size l + 5 ∨ size r ≤ 3) : Valid' o₁ (@rotateL α l x r) o₂ := by\n  cases' r with rs rl rx rr; · cases H2\n  rw [hr.2.size_eq, Nat.lt_succ_iff] at H2\n  rw [hr.2.size_eq] at H3\n  replace H3 : 2 * (size rl + size rr) ≤ 9 * size l + 3 ∨ size rl + size rr ≤ 2 :=\n    H3.imp (@Nat.le_of_add_le_add_right _ 2 _) Nat.le_of_succ_le_succ\n  have H3_0 : size l = 0 → size rl + size rr ≤ 2 := by\n    intro l0; rw [l0] at H3\n    exact\n      (or_iff_right_of_imp fun h => (mul_le_mul_left (by decide)).1 (le_trans h (by decide))).1 H3\n  have H3p : size l > 0 → 2 * (size rl + size rr) ≤ 9 * size l + 3 := fun l0 : 1 ≤ size l =>\n    (or_iff_left_of_imp <| by omega).1 H3\n  have ablem : ∀ {a b : ℕ}, 1 ≤ a → a + b ≤ 2 → b ≤ 1 := by omega\n  have hlp : size l > 0 → ¬size rl + size rr ≤ 1 := fun l0 hb =>\n    absurd (le_trans (le_trans (Nat.mul_le_mul_left _ l0) H2) hb) (by decide)\n  rw [Ordnode.rotateL_node]; split_ifs with h\n  · have rr0 : size rr > 0 :=\n      (mul_lt_mul_left (by decide)).1 (lt_of_le_of_lt (Nat.zero_le _) h : ratio * 0 < _)\n    suffices BalancedSz (size l) (size rl) ∧ BalancedSz (size l + size rl + 1) (size rr) by\n      exact hl.node3L hr.left hr.right this.1 this.2\n    rcases Nat.eq_zero_or_pos (size l) with l0 | l0\n    · rw [l0]; replace H3 := H3_0 l0\n      have := hr.3.1\n      rcases Nat.eq_zero_or_pos (size rl) with rl0 | rl0\n      · rw [rl0] at this ⊢\n        rw [le_antisymm (balancedSz_zero.1 this.symm) rr0]\n        decide\n      have rr1 : size rr = 1 := le_antisymm (ablem rl0 H3) rr0\n      rw [add_comm] at H3\n      rw [rr1, show size rl = 1 from le_antisymm (ablem rr0 H3) rl0]\n      decide\n    replace H3 := H3p l0\n    rcases hr.3.1.resolve_left (hlp l0) with ⟨_, hb₂⟩\n    refine ⟨Or.inr ⟨?_, ?_⟩, Or.inr ⟨?_, ?_⟩⟩\n    · exact Valid'.rotateL_lemma₁ H2 hb₂\n    · exact Nat.le_of_lt_succ (Valid'.rotateL_lemma₂ H3 h)\n    · exact Valid'.rotateL_lemma₃ H2 h\n    · exact\n        le_trans hb₂\n          (Nat.mul_le_mul_left _ <| le_trans (Nat.le_add_left _ _) (Nat.le_add_right _ _))\n  · rcases Nat.eq_zero_or_pos (size rl) with rl0 | rl0\n    · rw [rl0, not_lt, Nat.le_zero, Nat.mul_eq_zero] at h\n      replace h := h.resolve_left (by decide)\n      rw [rl0, h, Nat.le_zero, Nat.mul_eq_zero] at H2\n      rw [hr.2.size_eq, rl0, h, H2.resolve_left (by decide)] at H1\n      cases H1 (by decide)\n    refine hl.node4L hr.left hr.right rl0 ?_\n    rcases Nat.eq_zero_or_pos (size l) with l0 | l0\n    · replace H3 := H3_0 l0\n      rcases Nat.eq_zero_or_pos (size rr) with rr0 | rr0\n      · have := hr.3.1\n        rw [rr0] at this\n        exact Or.inl ⟨l0, le_antisymm (balancedSz_zero.1 this) rl0, rr0.symm ▸ zero_le_one⟩\n      exact Or.inl ⟨l0, le_antisymm (ablem rr0 <| by rwa [add_comm]) rl0, ablem rl0 H3⟩\n    exact\n      Or.inr ⟨l0, not_lt.1 h, H2, Valid'.rotateL_lemma₄ (H3p l0), (hr.3.1.resolve_left (hlp l0)).1⟩\n\n"}
{"name":"Ordnode.Valid'.rotateR","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nl : Ordnode α\nx : α\nr : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nhl : Ordnode.Valid' o₁ l ↑x\nhr : Ordnode.Valid' (↑x) r o₂\nH1 : Not (LE.le (HAdd.hAdd l.size r.size) 1)\nH2 : LT.lt (HMul.hMul Ordnode.delta r.size) l.size\nH3 : Or (LE.le (HMul.hMul 2 l.size) (HAdd.hAdd (HMul.hMul 9 r.size) 5)) (LE.le l.size 3)\n⊢ Ordnode.Valid' o₁ (l.rotateR x r) o₂","decl":"theorem Valid'.rotateR {l} {x : α} {r o₁ o₂} (hl : Valid' o₁ l x) (hr : Valid' x r o₂)\n    (H1 : ¬size l + size r ≤ 1) (H2 : delta * size r < size l)\n    (H3 : 2 * size l ≤ 9 * size r + 5 ∨ size l ≤ 3) : Valid' o₁ (@rotateR α l x r) o₂ := by\n  refine Valid'.dual_iff.2 ?_\n  rw [dual_rotateR]\n  refine hr.dual.rotateL hl.dual ?_ ?_ ?_\n  · rwa [size_dual, size_dual, add_comm]\n  · rwa [size_dual, size_dual]\n  · rwa [size_dual, size_dual]\n\n"}
{"name":"Ordnode.Valid'.balance'_aux","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nl : Ordnode α\nx : α\nr : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nhl : Ordnode.Valid' o₁ l ↑x\nhr : Ordnode.Valid' (↑x) r o₂\nH₁ : Or (LE.le (HMul.hMul 2 r.size) (HAdd.hAdd (HMul.hMul 9 l.size) 5)) (LE.le r.size 3)\nH₂ : Or (LE.le (HMul.hMul 2 l.size) (HAdd.hAdd (HMul.hMul 9 r.size) 5)) (LE.le l.size 3)\n⊢ Ordnode.Valid' o₁ (l.balance' x r) o₂","decl":"theorem Valid'.balance'_aux {l} {x : α} {r o₁ o₂} (hl : Valid' o₁ l x) (hr : Valid' x r o₂)\n    (H₁ : 2 * @size α r ≤ 9 * size l + 5 ∨ size r ≤ 3)\n    (H₂ : 2 * @size α l ≤ 9 * size r + 5 ∨ size l ≤ 3) : Valid' o₁ (@balance' α l x r) o₂ := by\n  rw [balance']; split_ifs with h h_1 h_2\n  · exact hl.node' hr (Or.inl h)\n  · exact hl.rotateL hr h h_1 H₁\n  · exact hl.rotateR hr h h_2 H₂\n  · exact hl.node' hr (Or.inr ⟨not_lt.1 h_2, not_lt.1 h_1⟩)\n\n"}
{"name":"Ordnode.Valid'.balance'_lemma","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_2\nl : Ordnode α\nl' : Nat\nr : Ordnode α\nr' : Nat\nH1 : Ordnode.BalancedSz l' r'\nH2 : Or (And (LE.le (l.size.dist l') 1) (Eq r.size r')) (And (LE.le (r.size.dist r') 1) (Eq l.size l'))\n⊢ Or (LE.le (HMul.hMul 2 r.size) (HAdd.hAdd (HMul.hMul 9 l.size) 5)) (LE.le r.size 3)","decl":"theorem Valid'.balance'_lemma {α l l' r r'} (H1 : BalancedSz l' r')\n    (H2 : Nat.dist (@size α l) l' ≤ 1 ∧ size r = r' ∨ Nat.dist (size r) r' ≤ 1 ∧ size l = l') :\n    2 * @size α r ≤ 9 * size l + 5 ∨ size r ≤ 3 := by\n  suffices @size α r ≤ 3 * (size l + 1) by omega\n  rcases H2 with (⟨hl, rfl⟩ | ⟨hr, rfl⟩) <;> rcases H1 with (h | ⟨_, h₂⟩)\n  · exact le_trans (Nat.le_add_left _ _) (le_trans h (Nat.le_add_left _ _))\n  · exact\n      le_trans h₂\n        (Nat.mul_le_mul_left _ <| le_trans (Nat.dist_tri_right _ _) (Nat.add_le_add_left hl _))\n  · exact\n      le_trans (Nat.dist_tri_left' _ _)\n        (le_trans (add_le_add hr (le_trans (Nat.le_add_left _ _) h)) (by omega))\n  · rw [Nat.mul_succ]\n    exact le_trans (Nat.dist_tri_right' _ _) (add_le_add h₂ (le_trans hr (by decide)))\n\n"}
{"name":"Ordnode.Valid'.balance'","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nl : Ordnode α\nx : α\nr : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nhl : Ordnode.Valid' o₁ l ↑x\nhr : Ordnode.Valid' (↑x) r o₂\nH : Exists fun l' => Exists fun r' => And (Ordnode.BalancedSz l' r') (Or (And (LE.le (l.size.dist l') 1) (Eq r.size r')) (And (LE.le (r.size.dist r') 1) (Eq l.size l')))\n⊢ Ordnode.Valid' o₁ (l.balance' x r) o₂","decl":"theorem Valid'.balance' {l} {x : α} {r o₁ o₂} (hl : Valid' o₁ l x) (hr : Valid' x r o₂)\n    (H : ∃ l' r', BalancedSz l' r' ∧\n          (Nat.dist (size l) l' ≤ 1 ∧ size r = r' ∨ Nat.dist (size r) r' ≤ 1 ∧ size l = l')) :\n    Valid' o₁ (@balance' α l x r) o₂ :=\n  let ⟨_, _, H1, H2⟩ := H\n  Valid'.balance'_aux hl hr (Valid'.balance'_lemma H1 H2) (Valid'.balance'_lemma H1.symm H2.symm)\n\n"}
{"name":"Ordnode.Valid'.balance","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nl : Ordnode α\nx : α\nr : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nhl : Ordnode.Valid' o₁ l ↑x\nhr : Ordnode.Valid' (↑x) r o₂\nH : Exists fun l' => Exists fun r' => And (Ordnode.BalancedSz l' r') (Or (And (LE.le (l.size.dist l') 1) (Eq r.size r')) (And (LE.le (r.size.dist r') 1) (Eq l.size l')))\n⊢ Ordnode.Valid' o₁ (l.balance x r) o₂","decl":"theorem Valid'.balance {l} {x : α} {r o₁ o₂} (hl : Valid' o₁ l x) (hr : Valid' x r o₂)\n    (H : ∃ l' r', BalancedSz l' r' ∧\n          (Nat.dist (size l) l' ≤ 1 ∧ size r = r' ∨ Nat.dist (size r) r' ≤ 1 ∧ size l = l')) :\n    Valid' o₁ (@balance α l x r) o₂ := by\n  rw [balance_eq_balance' hl.3 hr.3 hl.2 hr.2]; exact hl.balance' hr H\n\n"}
{"name":"Ordnode.Valid'.balanceL_aux","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nl : Ordnode α\nx : α\nr : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nhl : Ordnode.Valid' o₁ l ↑x\nhr : Ordnode.Valid' (↑x) r o₂\nH₁ : Eq l.size 0 → LE.le r.size 1\nH₂ : LE.le 1 l.size → LE.le 1 r.size → LE.le r.size (HMul.hMul Ordnode.delta l.size)\nH₃ : Or (LE.le (HMul.hMul 2 l.size) (HAdd.hAdd (HMul.hMul 9 r.size) 5)) (LE.le l.size 3)\n⊢ Ordnode.Valid' o₁ (l.balanceL x r) o₂","decl":"theorem Valid'.balanceL_aux {l} {x : α} {r o₁ o₂} (hl : Valid' o₁ l x) (hr : Valid' x r o₂)\n    (H₁ : size l = 0 → size r ≤ 1) (H₂ : 1 ≤ size l → 1 ≤ size r → size r ≤ delta * size l)\n    (H₃ : 2 * @size α l ≤ 9 * size r + 5 ∨ size l ≤ 3) : Valid' o₁ (@balanceL α l x r) o₂ := by\n  rw [balanceL_eq_balance hl.2 hr.2 H₁ H₂, balance_eq_balance' hl.3 hr.3 hl.2 hr.2]\n  refine hl.balance'_aux hr (Or.inl ?_) H₃\n  rcases Nat.eq_zero_or_pos (size r) with r0 | r0\n  · rw [r0]; exact Nat.zero_le _\n  rcases Nat.eq_zero_or_pos (size l) with l0 | l0\n  · rw [l0]; exact le_trans (Nat.mul_le_mul_left _ (H₁ l0)) (by decide)\n  replace H₂ : _ ≤ 3 * _ := H₂ l0 r0; omega\n\n"}
{"name":"Ordnode.Valid'.balanceL","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nl : Ordnode α\nx : α\nr : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nhl : Ordnode.Valid' o₁ l ↑x\nhr : Ordnode.Valid' (↑x) r o₂\nH : Or (Exists fun l' => And (Ordnode.Raised l' l.size) (Ordnode.BalancedSz l' r.size)) (Exists fun r' => And (Ordnode.Raised r.size r') (Ordnode.BalancedSz l.size r'))\n⊢ Ordnode.Valid' o₁ (l.balanceL x r) o₂","decl":"theorem Valid'.balanceL {l} {x : α} {r o₁ o₂} (hl : Valid' o₁ l x) (hr : Valid' x r o₂)\n    (H : (∃ l', Raised l' (size l) ∧ BalancedSz l' (size r)) ∨\n        ∃ r', Raised (size r) r' ∧ BalancedSz (size l) r') :\n    Valid' o₁ (@balanceL α l x r) o₂ := by\n  rw [balanceL_eq_balance' hl.3 hr.3 hl.2 hr.2 H]\n  refine hl.balance' hr ?_\n  rcases H with (⟨l', e, H⟩ | ⟨r', e, H⟩)\n  · exact ⟨_, _, H, Or.inl ⟨e.dist_le', rfl⟩⟩\n  · exact ⟨_, _, H, Or.inr ⟨e.dist_le, rfl⟩⟩\n\n"}
{"name":"Ordnode.Valid'.balanceR_aux","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nl : Ordnode α\nx : α\nr : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nhl : Ordnode.Valid' o₁ l ↑x\nhr : Ordnode.Valid' (↑x) r o₂\nH₁ : Eq r.size 0 → LE.le l.size 1\nH₂ : LE.le 1 r.size → LE.le 1 l.size → LE.le l.size (HMul.hMul Ordnode.delta r.size)\nH₃ : Or (LE.le (HMul.hMul 2 r.size) (HAdd.hAdd (HMul.hMul 9 l.size) 5)) (LE.le r.size 3)\n⊢ Ordnode.Valid' o₁ (l.balanceR x r) o₂","decl":"theorem Valid'.balanceR_aux {l} {x : α} {r o₁ o₂} (hl : Valid' o₁ l x) (hr : Valid' x r o₂)\n    (H₁ : size r = 0 → size l ≤ 1) (H₂ : 1 ≤ size r → 1 ≤ size l → size l ≤ delta * size r)\n    (H₃ : 2 * @size α r ≤ 9 * size l + 5 ∨ size r ≤ 3) : Valid' o₁ (@balanceR α l x r) o₂ := by\n  rw [Valid'.dual_iff, dual_balanceR]\n  have := hr.dual.balanceL_aux hl.dual\n  rw [size_dual, size_dual] at this\n  exact this H₁ H₂ H₃\n\n"}
{"name":"Ordnode.Valid'.balanceR","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nl : Ordnode α\nx : α\nr : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nhl : Ordnode.Valid' o₁ l ↑x\nhr : Ordnode.Valid' (↑x) r o₂\nH : Or (Exists fun l' => And (Ordnode.Raised l.size l') (Ordnode.BalancedSz l' r.size)) (Exists fun r' => And (Ordnode.Raised r' r.size) (Ordnode.BalancedSz l.size r'))\n⊢ Ordnode.Valid' o₁ (l.balanceR x r) o₂","decl":"theorem Valid'.balanceR {l} {x : α} {r o₁ o₂} (hl : Valid' o₁ l x) (hr : Valid' x r o₂)\n    (H : (∃ l', Raised (size l) l' ∧ BalancedSz l' (size r)) ∨\n        ∃ r', Raised r' (size r) ∧ BalancedSz (size l) r') :\n    Valid' o₁ (@balanceR α l x r) o₂ := by\n  rw [Valid'.dual_iff, dual_balanceR]; exact hr.dual.balanceL hl.dual (balance_sz_dual H)\n\n"}
{"name":"Ordnode.Valid'.eraseMax_aux","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Nat\nl : Ordnode α\nx : α\nr : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nH : Ordnode.Valid' o₁ (Ordnode.node s l x r) o₂\n⊢ And (Ordnode.Valid' o₁ (l.node' x r).eraseMax ↑(Ordnode.findMax' x r)) (Eq (l.node' x r).size (HAdd.hAdd (l.node' x r).eraseMax.size 1))","decl":"theorem Valid'.eraseMax_aux {s l x r o₁ o₂} (H : Valid' o₁ (.node s l x r) o₂) :\n    Valid' o₁ (@eraseMax α (.node' l x r)) ↑(findMax' x r) ∧\n      size (.node' l x r) = size (eraseMax (.node' l x r)) + 1 := by\n  have := H.2.eq_node'; rw [this] at H; clear this\n  induction' r with rs rl rx rr _ IHrr generalizing l x o₁\n  · exact ⟨H.left, rfl⟩\n  have := H.2.2.2.eq_node'; rw [this] at H ⊢\n  rcases IHrr H.right with ⟨h, e⟩\n  refine ⟨Valid'.balanceL H.left h (Or.inr ⟨_, Or.inr e, H.3.1⟩), ?_⟩\n  rw [eraseMax, size_balanceL H.3.2.1 h.3 H.2.2.1 h.2 (Or.inr ⟨_, Or.inr e, H.3.1⟩)]\n  rw [size_node, e]; rfl\n\n"}
{"name":"Ordnode.Valid'.eraseMin_aux","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Nat\nl : Ordnode α\nx : α\nr : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nH : Ordnode.Valid' o₁ (Ordnode.node s l x r) o₂\n⊢ And (Ordnode.Valid' (↑(l.findMin' x)) (l.node' x r).eraseMin o₂) (Eq (l.node' x r).size (HAdd.hAdd (l.node' x r).eraseMin.size 1))","decl":"theorem Valid'.eraseMin_aux {s l} {x : α} {r o₁ o₂} (H : Valid' o₁ (.node s l x r) o₂) :\n    Valid' ↑(findMin' l x) (@eraseMin α (.node' l x r)) o₂ ∧\n      size (.node' l x r) = size (eraseMin (.node' l x r)) + 1 := by\n  have := H.dual.eraseMax_aux\n  rwa [← dual_node', size_dual, ← dual_eraseMin, size_dual, ← Valid'.dual_iff, findMax'_dual]\n    at this\n\n"}
{"name":"Ordnode.eraseMin.valid","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt : Ordnode α\na✝ : t.Valid\n⊢ t.eraseMin.Valid","decl":"theorem eraseMin.valid : ∀ {t}, @Valid α _ t → Valid (eraseMin t)\n  | nil, _ => valid_nil\n  | node _ l x r, h => by rw [h.2.eq_node']; exact h.eraseMin_aux.1.valid\n\n"}
{"name":"Ordnode.eraseMax.valid","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nt : Ordnode α\nh : t.Valid\n⊢ t.eraseMax.Valid","decl":"theorem eraseMax.valid {t} (h : @Valid α _ t) : Valid (eraseMax t) := by\n  rw [Valid.dual_iff, dual_eraseMax]; exact eraseMin.valid h.dual\n\n"}
{"name":"Ordnode.Valid'.glue_aux","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nl r : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nhl : Ordnode.Valid' o₁ l o₂\nhr : Ordnode.Valid' o₁ r o₂\nsep : Ordnode.All (fun x => Ordnode.All (fun y => LT.lt x y) r) l\nbal : Ordnode.BalancedSz l.size r.size\n⊢ And (Ordnode.Valid' o₁ (l.glue r) o₂) (Eq (l.glue r).size (HAdd.hAdd l.size r.size))","decl":"theorem Valid'.glue_aux {l r o₁ o₂} (hl : Valid' o₁ l o₂) (hr : Valid' o₁ r o₂)\n    (sep : l.All fun x => r.All fun y => x < y) (bal : BalancedSz (size l) (size r)) :\n    Valid' o₁ (@glue α l r) o₂ ∧ size (glue l r) = size l + size r := by\n  cases' l with ls ll lx lr; · exact ⟨hr, (zero_add _).symm⟩\n  cases' r with rs rl rx rr; · exact ⟨hl, rfl⟩\n  dsimp [glue]; split_ifs\n  · rw [splitMax_eq]\n    · cases' Valid'.eraseMax_aux hl with v e\n      suffices H : _ by\n        refine ⟨Valid'.balanceR v (hr.of_gt ?_ ?_) H, ?_⟩\n        · refine findMax'_all (P := fun a : α => Bounded nil (a : WithTop α) o₂)\n            lx lr hl.1.2.to_nil (sep.2.2.imp ?_)\n          exact fun x h => hr.1.2.to_nil.mono_left (le_of_lt h.2.1)\n        · exact @findMax'_all _ (fun a => All (· > a) (.node rs rl rx rr)) lx lr sep.2.1 sep.2.2\n        · rw [size_balanceR v.3 hr.3 v.2 hr.2 H, add_right_comm, ← e, hl.2.1]; rfl\n      refine Or.inl ⟨_, Or.inr e, ?_⟩\n      rwa [hl.2.eq_node'] at bal\n  · rw [splitMin_eq]\n    · cases' Valid'.eraseMin_aux hr with v e\n      suffices H : _ by\n        refine ⟨Valid'.balanceL (hl.of_lt ?_ ?_) v H, ?_⟩\n        · refine @findMin'_all (P := fun a : α => Bounded nil o₁ (a : WithBot α))\n            _ rl rx (sep.2.1.1.imp ?_) hr.1.1.to_nil\n          exact fun y h => hl.1.1.to_nil.mono_right (le_of_lt h)\n        · exact\n            @findMin'_all _ (fun a => All (· < a) (.node ls ll lx lr)) rl rx\n              (all_iff_forall.2 fun x hx => sep.imp fun y hy => all_iff_forall.1 hy.1 _ hx)\n              (sep.imp fun y hy => hy.2.1)\n        · rw [size_balanceL hl.3 v.3 hl.2 v.2 H, add_assoc, ← e, hr.2.1]; rfl\n      refine Or.inr ⟨_, Or.inr e, ?_⟩\n      rwa [hr.2.eq_node'] at bal\n\n"}
{"name":"Ordnode.Valid'.glue","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nl : Ordnode α\nx : α\nr : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nhl : Ordnode.Valid' o₁ l ↑x\nhr : Ordnode.Valid' (↑x) r o₂\na✝ : Ordnode.BalancedSz l.size r.size\n⊢ And (Ordnode.Valid' o₁ (l.glue r) o₂) (Eq (l.glue r).size (HAdd.hAdd l.size r.size))","decl":"theorem Valid'.glue {l} {x : α} {r o₁ o₂} (hl : Valid' o₁ l x) (hr : Valid' x r o₂) :\n    BalancedSz (size l) (size r) →\n      Valid' o₁ (@glue α l r) o₂ ∧ size (@glue α l r) = size l + size r :=\n  Valid'.glue_aux (hl.trans_right hr.1) (hr.trans_left hl.1) (hl.1.to_sep hr.1)\n\n"}
{"name":"Ordnode.Valid'.merge_lemma","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"a b c : Nat\nh₁ : LT.lt (HMul.hMul 3 a) (HAdd.hAdd (HAdd.hAdd b c) 1)\nh₂ : LE.le b (HMul.hMul 3 c)\n⊢ LE.le (HMul.hMul 2 (HAdd.hAdd a b)) (HAdd.hAdd (HMul.hMul 9 c) 5)","decl":"theorem Valid'.merge_lemma {a b c : ℕ} (h₁ : 3 * a < b + c + 1) (h₂ : b ≤ 3 * c) :\n    2 * (a + b) ≤ 9 * c + 5 := by omega\n\n"}
{"name":"Ordnode.Valid'.merge_aux₁","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\no₁ : WithBot α\no₂ : WithTop α\nls : Nat\nll : Ordnode α\nlx : α\nlr : Ordnode α\nrs : Nat\nrl : Ordnode α\nrx : α\nrr t : Ordnode α\nhl : Ordnode.Valid' o₁ (Ordnode.node ls ll lx lr) o₂\nhr : Ordnode.Valid' o₁ (Ordnode.node rs rl rx rr) o₂\nh : LT.lt (HMul.hMul Ordnode.delta ls) rs\nv : Ordnode.Valid' o₁ t ↑rx\ne : Eq t.size (HAdd.hAdd ls rl.size)\n⊢ And (Ordnode.Valid' o₁ (t.balanceL rx rr) o₂) (Eq (t.balanceL rx rr).size (HAdd.hAdd ls rs))","decl":"theorem Valid'.merge_aux₁ {o₁ o₂ ls ll lx lr rs rl rx rr t}\n    (hl : Valid' o₁ (@Ordnode.node α ls ll lx lr) o₂) (hr : Valid' o₁ (.node rs rl rx rr) o₂)\n    (h : delta * ls < rs) (v : Valid' o₁ t rx) (e : size t = ls + size rl) :\n    Valid' o₁ (.balanceL t rx rr) o₂ ∧ size (.balanceL t rx rr) = ls + rs := by\n  rw [hl.2.1] at e\n  rw [hl.2.1, hr.2.1, delta] at h\n  rcases hr.3.1 with (H | ⟨hr₁, hr₂⟩); · omega\n  suffices H₂ : _ by\n    suffices H₁ : _ by\n      refine ⟨Valid'.balanceL_aux v hr.right H₁ H₂ ?_, ?_⟩\n      · rw [e]; exact Or.inl (Valid'.merge_lemma h hr₁)\n      · rw [balanceL_eq_balance v.2 hr.2.2.2 H₁ H₂, balance_eq_balance' v.3 hr.3.2.2 v.2 hr.2.2.2,\n          size_balance' v.2 hr.2.2.2, e, hl.2.1, hr.2.1]\n        abel\n    · rw [e, add_right_comm]; rintro ⟨⟩\n  intro _ _; rw [e]; unfold delta at hr₂ ⊢; omega\n\n"}
{"name":"Ordnode.Valid'.merge_aux","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nl r : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\nhl : Ordnode.Valid' o₁ l o₂\nhr : Ordnode.Valid' o₁ r o₂\nsep : Ordnode.All (fun x => Ordnode.All (fun y => LT.lt x y) r) l\n⊢ And (Ordnode.Valid' o₁ (l.merge r) o₂) (Eq (l.merge r).size (HAdd.hAdd l.size r.size))","decl":"theorem Valid'.merge_aux {l r o₁ o₂} (hl : Valid' o₁ l o₂) (hr : Valid' o₁ r o₂)\n    (sep : l.All fun x => r.All fun y => x < y) :\n    Valid' o₁ (@merge α l r) o₂ ∧ size (merge l r) = size l + size r := by\n  induction' l with ls ll lx lr _ IHlr generalizing o₁ o₂ r\n  · exact ⟨hr, (zero_add _).symm⟩\n  induction' r with rs rl rx rr IHrl _ generalizing o₁ o₂\n  · exact ⟨hl, rfl⟩\n  rw [merge_node]; split_ifs with h h_1\n  · cases'\n      IHrl (hl.of_lt hr.1.1.to_nil <| sep.imp fun x h => h.2.1) hr.left\n        (sep.imp fun x h => h.1) with\n      v e\n    exact Valid'.merge_aux₁ hl hr h v e\n  · cases' IHlr hl.right (hr.of_gt hl.1.2.to_nil sep.2.1) sep.2.2 with v e\n    have := Valid'.merge_aux₁ hr.dual hl.dual h_1 v.dual\n    rw [size_dual, add_comm, size_dual, ← dual_balanceR, ← Valid'.dual_iff, size_dual,\n      add_comm rs] at this\n    exact this e\n  · refine Valid'.glue_aux hl hr sep (Or.inr ⟨not_lt.1 h_1, not_lt.1 h⟩)\n\n"}
{"name":"Ordnode.Valid.merge","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nl r : Ordnode α\nhl : l.Valid\nhr : r.Valid\nsep : Ordnode.All (fun x => Ordnode.All (fun y => LT.lt x y) r) l\n⊢ (l.merge r).Valid","decl":"theorem Valid.merge {l r} (hl : Valid l) (hr : Valid r)\n    (sep : l.All fun x => r.All fun y => x < y) : Valid (@merge α l r) :=\n  (Valid'.merge_aux hl hr sep).1\n\n"}
{"name":"Ordnode.insertWith.valid_aux","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : IsTotal α fun x1 x2 => LE.le x1 x2\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nf : α → α\nx : α\nhf : ∀ (y : α), And (LE.le x y) (LE.le y x) → And (LE.le x (f y)) (LE.le (f y) x)\nt : Ordnode α\no₁ : WithBot α\no₂ : WithTop α\na✝² : Ordnode.Valid' o₁ t o₂\na✝¹ : Ordnode.nil.Bounded o₁ ↑x\na✝ : Ordnode.nil.Bounded (↑x) o₂\n⊢ And (Ordnode.Valid' o₁ (Ordnode.insertWith f x t) o₂) (Ordnode.Raised t.size (Ordnode.insertWith f x t).size)","decl":"theorem insertWith.valid_aux [IsTotal α (· ≤ ·)] [DecidableRel (α := α) (· ≤ ·)] (f : α → α) (x : α)\n    (hf : ∀ y, x ≤ y ∧ y ≤ x → x ≤ f y ∧ f y ≤ x) :\n    ∀ {t o₁ o₂},\n      Valid' o₁ t o₂ →\n        Bounded nil o₁ x →\n          Bounded nil x o₂ →\n            Valid' o₁ (insertWith f x t) o₂ ∧ Raised (size t) (size (insertWith f x t))\n  | nil, _, _, _, bl, br => ⟨valid'_singleton bl br, Or.inr rfl⟩\n  | node sz l y r, o₁, o₂, h, bl, br => by\n    rw [insertWith, cmpLE]\n    split_ifs with h_1 h_2 <;> dsimp only\n    · rcases h with ⟨⟨lx, xr⟩, hs, hb⟩\n      rcases hf _ ⟨h_1, h_2⟩ with ⟨xf, fx⟩\n      refine\n        ⟨⟨⟨lx.mono_right (le_trans h_2 xf), xr.mono_left (le_trans fx h_1)⟩, hs, hb⟩, Or.inl rfl⟩\n    · rcases insertWith.valid_aux f x hf h.left bl (lt_of_le_not_le h_1 h_2) with ⟨vl, e⟩\n      suffices H : _ by\n        refine ⟨vl.balanceL h.right H, ?_⟩\n        rw [size_balanceL vl.3 h.3.2.2 vl.2 h.2.2.2 H, h.2.size_eq]\n        exact (e.add_right _).add_right _\n      exact Or.inl ⟨_, e, h.3.1⟩\n    · have : y < x := lt_of_le_not_le ((total_of (· ≤ ·) _ _).resolve_left h_1) h_1\n      rcases insertWith.valid_aux f x hf h.right this br with ⟨vr, e⟩\n      suffices H : _ by\n        refine ⟨h.left.balanceR vr H, ?_⟩\n        rw [size_balanceR h.3.2.1 vr.3 h.2.2.1 vr.2 H, h.2.size_eq]\n        exact (e.add_left _).add_right _\n      exact Or.inr ⟨_, e, h.3.1⟩\n\n"}
{"name":"Ordnode.insertWith.valid","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : IsTotal α fun x1 x2 => LE.le x1 x2\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nf : α → α\nx : α\nhf : ∀ (y : α), And (LE.le x y) (LE.le y x) → And (LE.le x (f y)) (LE.le (f y) x)\nt : Ordnode α\nh : t.Valid\n⊢ (Ordnode.insertWith f x t).Valid","decl":"theorem insertWith.valid [IsTotal α (· ≤ ·)] [DecidableRel (α := α) (· ≤ ·)] (f : α → α) (x : α)\n    (hf : ∀ y, x ≤ y ∧ y ≤ x → x ≤ f y ∧ f y ≤ x) {t} (h : Valid t) : Valid (insertWith f x t) :=\n  (insertWith.valid_aux _ _ hf h ⟨⟩ ⟨⟩).1\n\n"}
{"name":"Ordnode.insert_eq_insertWith","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nx : α\nt : Ordnode α\n⊢ Eq (Ordnode.insert x t) (Ordnode.insertWith (fun x_1 => x) x t)","decl":"theorem insert_eq_insertWith [DecidableRel (α := α) (· ≤ ·)] (x : α) :\n    ∀ t, Ordnode.insert x t = insertWith (fun _ => x) x t\n  | nil => rfl\n  | node _ l y r => by\n    unfold Ordnode.insert insertWith; cases cmpLE x y <;> simp [insert_eq_insertWith]\n\n"}
{"name":"Ordnode.insert.valid","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : IsTotal α fun x1 x2 => LE.le x1 x2\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nx : α\nt : Ordnode α\nh : t.Valid\n⊢ (Ordnode.insert x t).Valid","decl":"theorem insert.valid [IsTotal α (· ≤ ·)] [DecidableRel (α := α) (· ≤ ·)] (x : α) {t} (h : Valid t) :\n    Valid (Ordnode.insert x t) := by\n  rw [insert_eq_insertWith]; exact insertWith.valid _ _ (fun _ _ => ⟨le_rfl, le_rfl⟩) h\n\n"}
{"name":"Ordnode.insert'_eq_insertWith","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nx : α\nt : Ordnode α\n⊢ Eq (Ordnode.insert' x t) (Ordnode.insertWith id x t)","decl":"theorem insert'_eq_insertWith [DecidableRel (α := α) (· ≤ ·)] (x : α) :\n    ∀ t, insert' x t = insertWith id x t\n  | nil => rfl\n  | node _ l y r => by\n    unfold insert' insertWith; cases cmpLE x y <;> simp [insert'_eq_insertWith]\n\n"}
{"name":"Ordnode.insert'.valid","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : IsTotal α fun x1 x2 => LE.le x1 x2\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nx : α\nt : Ordnode α\nh : t.Valid\n⊢ (Ordnode.insert' x t).Valid","decl":"theorem insert'.valid [IsTotal α (· ≤ ·)] [DecidableRel (α := α) (· ≤ ·)]\n    (x : α) {t} (h : Valid t) : Valid (insert' x t) := by\n  rw [insert'_eq_insertWith]; exact insertWith.valid _ _ (fun _ => id) h\n\n"}
{"name":"Ordnode.Valid'.map_aux","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\nf : α → β\nf_strict_mono : StrictMono f\nt : Ordnode α\na₁ : WithBot α\na₂ : WithTop α\nh : Ordnode.Valid' a₁ t a₂\n⊢ And (Ordnode.Valid' (Option.map f a₁) (Ordnode.map f t) (Option.map f a₂)) (Eq (Ordnode.map f t).size t.size)","decl":"theorem Valid'.map_aux {β} [Preorder β] {f : α → β} (f_strict_mono : StrictMono f) {t a₁ a₂}\n    (h : Valid' a₁ t a₂) :\n    Valid' (Option.map f a₁) (map f t) (Option.map f a₂) ∧ (map f t).size = t.size := by\n  induction t generalizing a₁ a₂ with\n  | nil =>\n    simp only [map, size_nil, and_true]; apply valid'_nil\n    cases a₁; · trivial\n    cases a₂; · trivial\n    simp only [Option.map, Bounded]\n    exact f_strict_mono h.ord\n  | node _ _ _ _ t_ih_l t_ih_r =>\n    have t_ih_l' := t_ih_l h.left\n    have t_ih_r' := t_ih_r h.right\n    clear t_ih_l t_ih_r\n    cases' t_ih_l' with t_l_valid t_l_size\n    cases' t_ih_r' with t_r_valid t_r_size\n    simp only [map, size_node, and_true]\n    constructor\n    · exact And.intro t_l_valid.ord t_r_valid.ord\n    · constructor\n      · rw [t_l_size, t_r_size]; exact h.sz.1\n      · constructor\n        · exact t_l_valid.sz\n        · exact t_r_valid.sz\n    · constructor\n      · rw [t_l_size, t_r_size]; exact h.bal.1\n      · constructor\n        · exact t_l_valid.bal\n        · exact t_r_valid.bal\n\n"}
{"name":"Ordnode.map.valid","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\nβ : Type u_2\ninst✝ : Preorder β\nf : α → β\nf_strict_mono : StrictMono f\nt : Ordnode α\nh : t.Valid\n⊢ (Ordnode.map f t).Valid","decl":"theorem map.valid {β} [Preorder β] {f : α → β} (f_strict_mono : StrictMono f) {t} (h : Valid t) :\n    Valid (map f t) :=\n  (Valid'.map_aux f_strict_mono h).1\n\n"}
{"name":"Ordnode.Valid'.erase_aux","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nx : α\nt : Ordnode α\na₁ : WithBot α\na₂ : WithTop α\nh : Ordnode.Valid' a₁ t a₂\n⊢ And (Ordnode.Valid' a₁ (Ordnode.erase x t) a₂) (Ordnode.Raised (Ordnode.erase x t).size t.size)","decl":"theorem Valid'.erase_aux [DecidableRel (α := α) (· ≤ ·)] (x : α) {t a₁ a₂} (h : Valid' a₁ t a₂) :\n    Valid' a₁ (erase x t) a₂ ∧ Raised (erase x t).size t.size := by\n  induction t generalizing a₁ a₂ with\n  | nil =>\n    simpa [erase, Raised]\n  | node _ t_l t_x t_r t_ih_l t_ih_r =>\n    simp only [erase, size_node]\n    have t_ih_l' := t_ih_l h.left\n    have t_ih_r' := t_ih_r h.right\n    clear t_ih_l t_ih_r\n    cases' t_ih_l' with t_l_valid t_l_size\n    cases' t_ih_r' with t_r_valid t_r_size\n    cases cmpLE x t_x <;> rw [h.sz.1]\n    · suffices h_balanceable : _ by\n        constructor\n        · exact Valid'.balanceR t_l_valid h.right h_balanceable\n        · rw [size_balanceR t_l_valid.bal h.right.bal t_l_valid.sz h.right.sz h_balanceable]\n          repeat apply Raised.add_right\n          exact t_l_size\n      left; exists t_l.size; exact And.intro t_l_size h.bal.1\n    · have h_glue := Valid'.glue h.left h.right h.bal.1\n      cases' h_glue with h_glue_valid h_glue_sized\n      constructor\n      · exact h_glue_valid\n      · right; rw [h_glue_sized]\n    · suffices h_balanceable : _ by\n        constructor\n        · exact Valid'.balanceL h.left t_r_valid h_balanceable\n        · rw [size_balanceL h.left.bal t_r_valid.bal h.left.sz t_r_valid.sz h_balanceable]\n          apply Raised.add_right\n          apply Raised.add_left\n          exact t_r_size\n      right; exists t_r.size; exact And.intro t_r_size h.bal.1\n\n"}
{"name":"Ordnode.erase.valid","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nx : α\nt : Ordnode α\nh : t.Valid\n⊢ (Ordnode.erase x t).Valid","decl":"theorem erase.valid [DecidableRel (α := α) (· ≤ ·)] (x : α) {t} (h : Valid t) : Valid (erase x t) :=\n  (Valid'.erase_aux x h).1\n\n"}
{"name":"Ordnode.size_erase_of_mem","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nx : α\nt : Ordnode α\na₁ : WithBot α\na₂ : WithTop α\nh : Ordnode.Valid' a₁ t a₂\nh_mem : Membership.mem t x\n⊢ Eq (Ordnode.erase x t).size (HSub.hSub t.size 1)","decl":"theorem size_erase_of_mem [DecidableRel (α := α) (· ≤ ·)] {x : α} {t a₁ a₂} (h : Valid' a₁ t a₂)\n    (h_mem : x ∈ t) : size (erase x t) = size t - 1 := by\n  induction t generalizing a₁ a₂ with\n  | nil =>\n    contradiction\n  | node _ t_l t_x t_r t_ih_l t_ih_r =>\n    have t_ih_l' := t_ih_l h.left\n    have t_ih_r' := t_ih_r h.right\n    clear t_ih_l t_ih_r\n    dsimp only [Membership.mem, mem] at h_mem\n    unfold erase\n    revert h_mem; cases cmpLE x t_x <;> intro h_mem <;> dsimp only at h_mem ⊢\n    · have t_ih_l := t_ih_l' h_mem\n      clear t_ih_l' t_ih_r'\n      have t_l_h := Valid'.erase_aux x h.left\n      cases' t_l_h with t_l_valid t_l_size\n      rw [size_balanceR t_l_valid.bal h.right.bal t_l_valid.sz h.right.sz\n          (Or.inl (Exists.intro t_l.size (And.intro t_l_size h.bal.1)))]\n      rw [t_ih_l, h.sz.1]\n      have h_pos_t_l_size := pos_size_of_mem h.left.sz h_mem\n      revert h_pos_t_l_size; cases' t_l.size with t_l_size <;> intro h_pos_t_l_size\n      · cases h_pos_t_l_size\n      · simp [Nat.add_right_comm]\n    · rw [(Valid'.glue h.left h.right h.bal.1).2, h.sz.1]; rfl\n    · have t_ih_r := t_ih_r' h_mem\n      clear t_ih_l' t_ih_r'\n      have t_r_h := Valid'.erase_aux x h.right\n      cases' t_r_h with t_r_valid t_r_size\n      rw [size_balanceL h.left.bal t_r_valid.bal h.left.sz t_r_valid.sz\n          (Or.inr (Exists.intro t_r.size (And.intro t_r_size h.bal.1)))]\n      rw [t_ih_r, h.sz.1]\n      have h_pos_t_r_size := pos_size_of_mem h.right.sz h_mem\n      revert h_pos_t_r_size; cases' t_r.size with t_r_size <;> intro h_pos_t_r_size\n      · cases h_pos_t_r_size\n      · simp [Nat.add_assoc]\n\n"}
{"name":"Ordset.empty_iff","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Ordset α\n⊢ Iff (Eq s EmptyCollection.emptyCollection) (Eq (↑s).empty Bool.true)","decl":"theorem empty_iff {s : Ordset α} : s = ∅ ↔ s.1.empty :=\n  ⟨fun h => by cases h; exact rfl,\n    fun h => by cases s with | mk s_val _ => cases s_val <;> [rfl; cases h]⟩\n\n"}
{"name":"Ordset.pos_size_of_mem","module":"Mathlib.Data.Ordmap.Ordset","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DecidableRel fun x1 x2 => LE.le x1 x2\nx : α\nt : Ordset α\nh_mem : Membership.mem t x\n⊢ LT.lt 0 t.size","decl":"theorem pos_size_of_mem {x : α} {t : Ordset α} (h_mem : x ∈ t) : 0 < size t := by\n  simp? [Membership.mem, mem] at h_mem says\n    simp only [Membership.mem, mem, Bool.decide_eq_true] at h_mem\n  apply Ordnode.pos_size_of_mem t.property.sz h_mem\n\n"}
