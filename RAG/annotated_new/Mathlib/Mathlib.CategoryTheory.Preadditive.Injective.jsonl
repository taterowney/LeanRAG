{"name":"CategoryTheory.Injective.factors","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : C\nself : CategoryTheory.Injective J\nX Y : C\ng : Quiver.Hom X J\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\n⊢ Exists fun h => Eq (CategoryTheory.CategoryStruct.comp f h) g","decl":"/--\nAn object `J` is injective iff every morphism into `J` can be obtained by extending a monomorphism.\n-/\nclass Injective (J : C) : Prop where\n  factors : ∀ {X Y : C} (g : X ⟶ J) (f : X ⟶ Y) [Mono f], ∃ h : Y ⟶ J, f ≫ h = g\n\n"}
{"name":"CategoryTheory.Limits.IsZero.injective","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nh : CategoryTheory.Limits.IsZero X\n⊢ CategoryTheory.Injective X","decl":"lemma Limits.IsZero.injective {X : C} (h : IsZero X) : Injective X where\n  factors _ _ _ := ⟨h.from_ _, h.eq_of_tgt _ _⟩\n\n"}
{"name":"CategoryTheory.InjectivePresentation.injective","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nself : CategoryTheory.InjectivePresentation X\n⊢ CategoryTheory.Injective self.J","decl":"/-- An injective presentation of an object `X` consists of a monomorphism `f : X ⟶ J`\nto some injective object `J`.\n-/\nstructure InjectivePresentation (X : C) where\n  J : C\n  injective : Injective J := by infer_instance\n  f : X ⟶ J\n  mono : Mono f := by infer_instance\n\n"}
{"name":"CategoryTheory.InjectivePresentation.mk.inj","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX J✝ : C\ninjective✝ : autoParam (CategoryTheory.Injective J✝) _auto✝\nf✝ : Quiver.Hom X J✝\nmono✝ : autoParam (CategoryTheory.Mono f✝) _auto✝\nJ : C\ninjective : autoParam (CategoryTheory.Injective J) _auto✝\nf : Quiver.Hom X J\nmono : autoParam (CategoryTheory.Mono f) _auto✝\nx✝ : Eq { J := J✝, injective := injective✝, f := f✝, mono := mono✝ } { J := J, injective := injective, f := f, mono := mono }\n⊢ And (Eq J✝ J) (HEq f✝ f)","decl":"/-- An injective presentation of an object `X` consists of a monomorphism `f : X ⟶ J`\nto some injective object `J`.\n-/\nstructure InjectivePresentation (X : C) where\n  J : C\n  injective : Injective J := by infer_instance\n  f : X ⟶ J\n  mono : Mono f := by infer_instance\n\n"}
{"name":"CategoryTheory.InjectivePresentation.mono","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nself : CategoryTheory.InjectivePresentation X\n⊢ CategoryTheory.Mono self.f","decl":"/-- An injective presentation of an object `X` consists of a monomorphism `f : X ⟶ J`\nto some injective object `J`.\n-/\nstructure InjectivePresentation (X : C) where\n  J : C\n  injective : Injective J := by infer_instance\n  f : X ⟶ J\n  mono : Mono f := by infer_instance\n\n"}
{"name":"CategoryTheory.InjectivePresentation.mk.injEq","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX J✝ : C\ninjective✝ : autoParam (CategoryTheory.Injective J✝) _auto✝\nf✝ : Quiver.Hom X J✝\nmono✝ : autoParam (CategoryTheory.Mono f✝) _auto✝\nJ : C\ninjective : autoParam (CategoryTheory.Injective J) _auto✝\nf : Quiver.Hom X J\nmono : autoParam (CategoryTheory.Mono f) _auto✝\n⊢ Eq (Eq { J := J✝, injective := injective✝, f := f✝, mono := mono✝ } { J := J, injective := injective, f := f, mono := mono }) (And (Eq J✝ J) (HEq f✝ f))","decl":"/-- An injective presentation of an object `X` consists of a monomorphism `f : X ⟶ J`\nto some injective object `J`.\n-/\nstructure InjectivePresentation (X : C) where\n  J : C\n  injective : Injective J := by infer_instance\n  f : X ⟶ J\n  mono : Mono f := by infer_instance\n\n"}
{"name":"CategoryTheory.InjectivePresentation.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX : C\ninst✝ : SizeOf C\nJ : C\ninjective : autoParam (CategoryTheory.Injective J) _auto✝\nf : Quiver.Hom X J\nmono : autoParam (CategoryTheory.Mono f) _auto✝\n⊢ Eq (SizeOf.sizeOf { J := J, injective := injective, f := f, mono := mono }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf J)) (SizeOf.sizeOf injective)) (SizeOf.sizeOf f)) (SizeOf.sizeOf mono))","decl":"/-- An injective presentation of an object `X` consists of a monomorphism `f : X ⟶ J`\nto some injective object `J`.\n-/\nstructure InjectivePresentation (X : C) where\n  J : C\n  injective : Injective J := by infer_instance\n  f : X ⟶ J\n  mono : Mono f := by infer_instance\n\n"}
{"name":"CategoryTheory.EnoughInjectives.presentation","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nself : CategoryTheory.EnoughInjectives C\nX : C\n⊢ Nonempty (CategoryTheory.InjectivePresentation X)","decl":"/-- A category \"has enough injectives\" if every object has an injective presentation,\ni.e. if for every object `X` there is an injective object `J` and a monomorphism `X ↪ J`. -/\nclass EnoughInjectives : Prop where\n  presentation : ∀ X : C, Nonempty (InjectivePresentation X)\n\n"}
{"name":"CategoryTheory.Injective.comp_factorThru","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ X Y : C\ninst✝¹ : CategoryTheory.Injective J\ng : Quiver.Hom X J\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Injective.factorThru g f)) g","decl":"@[simp]\ntheorem comp_factorThru {J X Y : C} [Injective J] (g : X ⟶ J) (f : X ⟶ Y) [Mono f] :\n    f ≫ factorThru g f = g :=\n  (Injective.factors g f).choose_spec\n\n"}
{"name":"CategoryTheory.Injective.zero_injective","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\n⊢ CategoryTheory.Injective 0","decl":"instance zero_injective [HasZeroObject C] : Injective (0 : C) :=\n  (isZero_zero C).injective\n\n"}
{"name":"CategoryTheory.Injective.of_iso","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP Q : C\ni : CategoryTheory.Iso P Q\nhP : CategoryTheory.Injective P\n⊢ CategoryTheory.Injective Q","decl":"theorem of_iso {P Q : C} (i : P ≅ Q) (hP : Injective P) : Injective Q :=\n  {\n    factors := fun g f mono => by\n      obtain ⟨h, h_eq⟩ := @Injective.factors C _ P _ _ _ (g ≫ i.inv) f mono\n      refine ⟨h ≫ i.hom, ?_⟩\n      rw [← Category.assoc, h_eq, Category.assoc, Iso.inv_hom_id, Category.comp_id] }\n\n"}
{"name":"CategoryTheory.Injective.iso_iff","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP Q : C\ni : CategoryTheory.Iso P Q\n⊢ Iff (CategoryTheory.Injective P) (CategoryTheory.Injective Q)","decl":"theorem iso_iff {P Q : C} (i : P ≅ Q) : Injective P ↔ Injective Q :=\n  ⟨of_iso i, of_iso i.symm⟩\n\n"}
{"name":"CategoryTheory.Injective.instOfNonempty","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"X : Type u₁\ninst✝ : Nonempty X\n⊢ CategoryTheory.Injective X","decl":"/-- The axiom of choice says that every nonempty type is an injective object in `Type`. -/\ninstance (X : Type u₁) [Nonempty X] : Injective X where\n  factors g f mono :=\n    ⟨fun z => by\n      classical\n      exact\n          if h : z ∈ Set.range f then g (Classical.choose h) else Nonempty.some inferInstance, by\n      ext y\n      classical\n      change dite (f y ∈ Set.range f) (fun h => g (Classical.choose h)) _ = _\n      split_ifs <;> rename_i h\n      · rw [mono_iff_injective] at mono\n        rw [mono (Classical.choose_spec h)]\n      · exact False.elim (h ⟨y, rfl⟩)⟩\n\n"}
{"name":"CategoryTheory.Injective.Type.enoughInjectives","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"⊢ CategoryTheory.EnoughInjectives (Type u₁)","decl":"instance Type.enoughInjectives : EnoughInjectives (Type u₁) where\n  presentation X :=\n    Nonempty.intro\n      { J := WithBot X\n        injective := inferInstance\n        f := Option.some\n        mono := by\n          rw [mono_iff_injective]\n          exact Option.some_injective X }\n\n"}
{"name":"CategoryTheory.Injective.instProd","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nP Q : C\ninst✝² : CategoryTheory.Limits.HasBinaryProduct P Q\ninst✝¹ : CategoryTheory.Injective P\ninst✝ : CategoryTheory.Injective Q\n⊢ CategoryTheory.Injective (CategoryTheory.Limits.prod P Q)","decl":"instance {P Q : C} [HasBinaryProduct P Q] [Injective P] [Injective Q] : Injective (P ⨯ Q) where\n  factors g f mono := by\n    use Limits.prod.lift (factorThru (g ≫ Limits.prod.fst) f) (factorThru (g ≫ Limits.prod.snd) f)\n    simp only [prod.comp_lift, comp_factorThru]\n    ext\n    · simp only [prod.lift_fst]\n    · simp only [prod.lift_snd]\n\n"}
{"name":"CategoryTheory.Injective.instPiObj","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nβ : Type v\nc : β → C\ninst✝¹ : CategoryTheory.Limits.HasProduct c\ninst✝ : ∀ (b : β), CategoryTheory.Injective (c b)\n⊢ CategoryTheory.Injective (CategoryTheory.Limits.piObj c)","decl":"instance {β : Type v} (c : β → C) [HasProduct c] [∀ b, Injective (c b)] : Injective (∏ᶜ c) where\n  factors g f mono := by\n    refine ⟨Pi.lift fun b => factorThru (g ≫ Pi.π c _) f, ?_⟩\n    ext b\n    simp only [Category.assoc, limit.lift_π, Fan.mk_π_app, comp_factorThru]\n\n"}
{"name":"CategoryTheory.Injective.instBiprod","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nP Q : C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasBinaryBiproduct P Q\ninst✝¹ : CategoryTheory.Injective P\ninst✝ : CategoryTheory.Injective Q\n⊢ CategoryTheory.Injective (CategoryTheory.Limits.biprod P Q)","decl":"instance {P Q : C} [HasZeroMorphisms C] [HasBinaryBiproduct P Q] [Injective P] [Injective Q] :\n    Injective (P ⊞ Q) where\n  factors g f mono := by\n    refine ⟨biprod.lift (factorThru (g ≫ biprod.fst) f) (factorThru (g ≫ biprod.snd) f), ?_⟩\n    ext\n    · simp only [Category.assoc, biprod.lift_fst, comp_factorThru]\n    · simp only [Category.assoc, biprod.lift_snd, comp_factorThru]\n\n"}
{"name":"CategoryTheory.Injective.instBiproduct","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nβ : Type v\nc : β → C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct c\ninst✝ : ∀ (b : β), CategoryTheory.Injective (c b)\n⊢ CategoryTheory.Injective (CategoryTheory.Limits.biproduct c)","decl":"instance {β : Type v} (c : β → C) [HasZeroMorphisms C] [HasBiproduct c] [∀ b, Injective (c b)] :\n    Injective (⨁ c) where\n  factors g f mono := by\n    refine ⟨biproduct.lift fun b => factorThru (g ≫ biproduct.π _ _) f, ?_⟩\n    ext\n    simp only [Category.assoc, biproduct.lift_π, comp_factorThru]\n\n"}
{"name":"CategoryTheory.Injective.instUnopOfProjectiveOpposite","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nP : Opposite C\ninst✝ : CategoryTheory.Projective P\n⊢ CategoryTheory.Injective (Opposite.unop P)","decl":"instance {P : Cᵒᵖ} [Projective P] : Injective no_index (unop P) where\n  factors g f mono :=\n    ⟨(@Projective.factorThru Cᵒᵖ _ P _ _ _ g.op f.op _).unop, Quiver.Hom.op_inj (by simp)⟩\n\n"}
{"name":"CategoryTheory.Injective.instProjectiveUnopOfOpposite","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Opposite C\ninst✝ : CategoryTheory.Injective J\n⊢ CategoryTheory.Projective (Opposite.unop J)","decl":"instance {J : Cᵒᵖ} [Injective J] : Projective no_index (unop J) where\n  factors f e he :=\n    ⟨(@factorThru Cᵒᵖ _ J _ _ _ f.op e.op _).unop, Quiver.Hom.op_inj (by simp)⟩\n\n"}
{"name":"CategoryTheory.Injective.instProjectiveOppositeOp","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : C\ninst✝ : CategoryTheory.Injective J\n⊢ CategoryTheory.Projective { unop := J }","decl":"instance {J : C} [Injective J] : Projective (op J) where\n  factors f e epi :=\n    ⟨(@factorThru C _ J _ _ _ f.unop e.unop _).op, Quiver.Hom.unop_inj (by simp)⟩\n\n"}
{"name":"CategoryTheory.Injective.instOppositeOpOfProjective","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nP : C\ninst✝ : CategoryTheory.Projective P\n⊢ CategoryTheory.Injective { unop := P }","decl":"instance {P : C} [Projective P] : Injective (op P) where\n  factors g f mono :=\n    ⟨(@Projective.factorThru C _ P _ _ _ g.unop f.unop _).op, Quiver.Hom.unop_inj (by simp)⟩\n\n"}
{"name":"CategoryTheory.Injective.injective_iff_projective_op","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nJ : C\n⊢ Iff (CategoryTheory.Injective J) (CategoryTheory.Projective { unop := J })","decl":"theorem injective_iff_projective_op {J : C} : Injective J ↔ Projective (op J) :=\n  ⟨fun _ => inferInstance, fun _ => show Injective (unop (op J)) from inferInstance⟩\n\n"}
{"name":"CategoryTheory.Injective.projective_iff_injective_op","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nP : C\n⊢ Iff (CategoryTheory.Projective P) (CategoryTheory.Injective { unop := P })","decl":"theorem projective_iff_injective_op {P : C} : Projective P ↔ Injective (op P) :=\n  ⟨fun _ => inferInstance, fun _ => show Projective (unop (op P)) from inferInstance⟩\n\n"}
{"name":"CategoryTheory.Injective.injective_iff_preservesEpimorphisms_yoneda_obj","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nJ : C\n⊢ Iff (CategoryTheory.Injective J) (CategoryTheory.yoneda.obj J).PreservesEpimorphisms","decl":"theorem injective_iff_preservesEpimorphisms_yoneda_obj (J : C) :\n    Injective J ↔ (yoneda.obj J).PreservesEpimorphisms := by\n  rw [injective_iff_projective_op, Projective.projective_iff_preservesEpimorphisms_coyoneda_obj]\n  exact Functor.preservesEpimorphisms.iso_iff (Coyoneda.objOpOp _)\n\n"}
{"name":"CategoryTheory.Injective.injective_of_adjoint","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\ninst✝¹ : L.PreservesMonomorphisms\nadj : CategoryTheory.Adjunction L R\nJ : D\ninst✝ : CategoryTheory.Injective J\n⊢ CategoryTheory.Injective (R.obj J)","decl":"theorem injective_of_adjoint (adj : L ⊣ R) (J : D) [Injective J] : Injective <| R.obj J :=\n  ⟨fun {A} {_} g f im =>\n    ⟨adj.homEquiv _ _ (factorThru ((adj.homEquiv A J).symm g) (L.map f)),\n      (adj.homEquiv _ _).symm.injective\n        (by simp [Adjunction.homEquiv_unit, Adjunction.homEquiv_counit])⟩⟩\n\n"}
{"name":"CategoryTheory.Injective.injective_under","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.EnoughInjectives C\nX : C\n⊢ CategoryTheory.Injective (CategoryTheory.Injective.under X)","decl":"instance injective_under (X : C) : Injective (under X) :=\n  (EnoughInjectives.presentation X).some.injective\n\n"}
{"name":"CategoryTheory.Injective.ι_mono","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.EnoughInjectives C\nX : C\n⊢ CategoryTheory.Mono (CategoryTheory.Injective.ι X)","decl":"instance ι_mono (X : C) : Mono (ι X) :=\n  (EnoughInjectives.presentation X).some.mono\n\n"}
{"name":"CategoryTheory.Injective.instSyzygies","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.EnoughInjectives C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasCokernel f\n⊢ CategoryTheory.Injective (CategoryTheory.Injective.syzygies f)","decl":"instance : Injective <| syzygies f := injective_under (cokernel f)\n\n"}
{"name":"CategoryTheory.Injective.instEnoughProjectivesOppositeOfEnoughInjectives","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.EnoughInjectives C\n⊢ CategoryTheory.EnoughProjectives (Opposite C)","decl":"instance [EnoughInjectives C] : EnoughProjectives Cᵒᵖ :=\n  ⟨fun X => ⟨{ p := _, f := (Injective.ι (unop X)).op}⟩⟩\n\n"}
{"name":"CategoryTheory.Injective.instEnoughInjectivesOppositeOfEnoughProjectives","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.EnoughProjectives C\n⊢ CategoryTheory.EnoughInjectives (Opposite C)","decl":"instance [EnoughProjectives C] : EnoughInjectives Cᵒᵖ :=\n  ⟨fun X => ⟨⟨_, inferInstance, (Projective.π (unop X)).op, inferInstance⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Injective.enoughProjectives_of_enoughInjectives_op","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.EnoughInjectives (Opposite C)\n⊢ CategoryTheory.EnoughProjectives C","decl":"theorem enoughProjectives_of_enoughInjectives_op [EnoughInjectives Cᵒᵖ] : EnoughProjectives C :=\n  ⟨fun X => ⟨{ p := _, f := (Injective.ι (op X)).unop} ⟩⟩\n\n"}
{"name":"CategoryTheory.Injective.enoughInjectives_of_enoughProjectives_op","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.EnoughProjectives (Opposite C)\n⊢ CategoryTheory.EnoughInjectives C","decl":"theorem enoughInjectives_of_enoughProjectives_op [EnoughProjectives Cᵒᵖ] : EnoughInjectives C :=\n  ⟨fun X => ⟨⟨_, inferInstance, (Projective.π (op X)).unop, inferInstance⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Adjunction.map_injective","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : F.PreservesMonomorphisms\nI : D\nhI : CategoryTheory.Injective I\n⊢ CategoryTheory.Injective (G.obj I)","decl":"theorem map_injective (adj : F ⊣ G) [F.PreservesMonomorphisms] (I : D) (hI : Injective I) :\n    Injective (G.obj I) :=\n  ⟨fun {X} {Y} f g => by\n    intro\n    rcases hI.factors (F.map f ≫ adj.counit.app _) (F.map g) with ⟨w,h⟩\n    use adj.unit.app Y ≫ G.map w\n    rw [← unit_naturality_assoc, ← G.map_comp, h]\n    simp⟩\n\n"}
{"name":"CategoryTheory.Adjunction.injective_of_map_injective","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝¹ : G.Full\ninst✝ : G.Faithful\nI : D\nhI : CategoryTheory.Injective (G.obj I)\n⊢ CategoryTheory.Injective I","decl":"theorem injective_of_map_injective (adj : F ⊣ G) [G.Full] [G.Faithful] (I : D)\n    (hI : Injective (G.obj I)) : Injective I :=\n  ⟨fun {X} {Y} f g => by\n    intro\n    haveI : PreservesLimitsOfSize.{0, 0} G := adj.rightAdjoint_preservesLimits\n    rcases hI.factors (G.map f) (G.map g) with ⟨w,h⟩\n    use inv (adj.counit.app _) ≫ F.map w ≫ adj.counit.app _\n    exact G.map_injective (by simpa)⟩\n\n"}
{"name":"CategoryTheory.EnoughInjectives.of_adjunction","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nR : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction L R\ninst✝² : L.PreservesMonomorphisms\ninst✝¹ : L.ReflectsMonomorphisms\ninst✝ : CategoryTheory.EnoughInjectives D\n⊢ CategoryTheory.EnoughInjectives C","decl":"/--\n[Lemma 3.8](https://ncatlab.org/nlab/show/injective+object#preservation_of_injective_objects)\n-/\nlemma EnoughInjectives.of_adjunction {C : Type u₁} {D : Type u₂}\n    [Category.{v₁} C] [Category.{v₂} D]\n    {L : C ⥤ D} {R : D ⥤ C} (adj : L ⊣ R) [L.PreservesMonomorphisms] [L.ReflectsMonomorphisms]\n    [EnoughInjectives D] : EnoughInjectives C where\n  presentation _ :=\n    ⟨adj.injectivePresentationOfMap _ (EnoughInjectives.presentation _).some⟩\n\n"}
{"name":"CategoryTheory.EnoughInjectives.of_equivalence","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Functor C D\ninst✝¹ : e.IsEquivalence\ninst✝ : CategoryTheory.EnoughInjectives D\n⊢ CategoryTheory.EnoughInjectives C","decl":"/-- An equivalence of categories transfers enough injectives. -/\nlemma EnoughInjectives.of_equivalence {C : Type u₁} {D : Type u₂}\n    [Category.{v₁} C] [Category.{v₂} D]\n    (e : C ⥤ D) [e.IsEquivalence] [EnoughInjectives D] : EnoughInjectives C :=\n  EnoughInjectives.of_adjunction (adj := e.asEquivalence.toAdjunction)\n\n"}
{"name":"CategoryTheory.Equivalence.map_injective_iff","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nF : CategoryTheory.Equivalence C D\nP : C\n⊢ Iff (CategoryTheory.Injective (F.functor.obj P)) (CategoryTheory.Injective P)","decl":"theorem map_injective_iff (P : C) : Injective (F.functor.obj P) ↔ Injective P :=\n  ⟨F.symm.toAdjunction.injective_of_map_injective P, F.symm.toAdjunction.map_injective P⟩\n\n"}
{"name":"CategoryTheory.Equivalence.enoughInjectives_iff","module":"Mathlib.CategoryTheory.Preadditive.Injective","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nF : CategoryTheory.Equivalence C D\n⊢ Iff (CategoryTheory.EnoughInjectives C) (CategoryTheory.EnoughInjectives D)","decl":"theorem enoughInjectives_iff (F : C ≌ D) : EnoughInjectives C ↔ EnoughInjectives D :=\n  ⟨fun h => h.of_adjunction F.symm.toAdjunction, fun h => h.of_adjunction F.toAdjunction⟩\n\n"}
