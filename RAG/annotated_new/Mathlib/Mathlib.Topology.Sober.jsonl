{"name":"isGenericPoint_def","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nx : α\nS : Set α\n⊢ Iff (IsGenericPoint x S) (Eq (closure (Singleton.singleton x)) S)","decl":"theorem isGenericPoint_def {x : α} {S : Set α} : IsGenericPoint x S ↔ closure ({x} : Set α) = S :=\n  Iff.rfl\n\n"}
{"name":"IsGenericPoint.def","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nx : α\nS : Set α\nh : IsGenericPoint x S\n⊢ Eq (closure (Singleton.singleton x)) S","decl":"theorem IsGenericPoint.def {x : α} {S : Set α} (h : IsGenericPoint x S) :\n    closure ({x} : Set α) = S :=\n  h\n\n"}
{"name":"isGenericPoint_closure","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nx : α\n⊢ IsGenericPoint x (closure (Singleton.singleton x))","decl":"theorem isGenericPoint_closure {x : α} : IsGenericPoint x (closure ({x} : Set α)) :=\n  refl _\n\n"}
{"name":"isGenericPoint_iff_specializes","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nx : α\nS : Set α\n⊢ Iff (IsGenericPoint x S) (∀ (y : α), Iff (Specializes x y) (Membership.mem S y))","decl":"theorem isGenericPoint_iff_specializes : IsGenericPoint x S ↔ ∀ y, x ⤳ y ↔ y ∈ S := by\n  simp only [specializes_iff_mem_closure, IsGenericPoint, Set.ext_iff]\n\n"}
{"name":"IsGenericPoint.specializes_iff_mem","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nx y : α\nS : Set α\nh : IsGenericPoint x S\n⊢ Iff (Specializes x y) (Membership.mem S y)","decl":"theorem specializes_iff_mem (h : IsGenericPoint x S) : x ⤳ y ↔ y ∈ S :=\n  isGenericPoint_iff_specializes.1 h y\n\n"}
{"name":"IsGenericPoint.specializes","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nx y : α\nS : Set α\nh : IsGenericPoint x S\nh' : Membership.mem S y\n⊢ Specializes x y","decl":"protected theorem specializes (h : IsGenericPoint x S) (h' : y ∈ S) : x ⤳ y :=\n  h.specializes_iff_mem.2 h'\n\n"}
{"name":"IsGenericPoint.mem","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nx : α\nS : Set α\nh : IsGenericPoint x S\n⊢ Membership.mem S x","decl":"protected theorem mem (h : IsGenericPoint x S) : x ∈ S :=\n  h.specializes_iff_mem.1 specializes_rfl\n\n"}
{"name":"IsGenericPoint.isClosed","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nx : α\nS : Set α\nh : IsGenericPoint x S\n⊢ IsClosed S","decl":"protected theorem isClosed (h : IsGenericPoint x S) : IsClosed S :=\n  h.def ▸ isClosed_closure\n\n"}
{"name":"IsGenericPoint.isIrreducible","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nx : α\nS : Set α\nh : IsGenericPoint x S\n⊢ IsIrreducible S","decl":"protected theorem isIrreducible (h : IsGenericPoint x S) : IsIrreducible S :=\n  h.def ▸ isIrreducible_singleton.closure\n\n"}
{"name":"IsGenericPoint.inseparable","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nx y : α\nS : Set α\nh : IsGenericPoint x S\nh' : IsGenericPoint y S\n⊢ Inseparable x y","decl":"protected theorem inseparable (h : IsGenericPoint x S) (h' : IsGenericPoint y S) :\n    Inseparable x y :=\n  (h.specializes h'.mem).antisymm (h'.specializes h.mem)\n\n"}
{"name":"IsGenericPoint.eq","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\nx y : α\nS : Set α\ninst✝ : T0Space α\nh : IsGenericPoint x S\nh' : IsGenericPoint y S\n⊢ Eq x y","decl":"/-- In a T₀ space, each set has at most one generic point. -/\nprotected theorem eq [T0Space α] (h : IsGenericPoint x S) (h' : IsGenericPoint y S) : x = y :=\n  (h.inseparable h').eq\n\n"}
{"name":"IsGenericPoint.mem_open_set_iff","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nx : α\nS U : Set α\nh : IsGenericPoint x S\nhU : IsOpen U\n⊢ Iff (Membership.mem U x) (Inter.inter S U).Nonempty","decl":"theorem mem_open_set_iff (h : IsGenericPoint x S) (hU : IsOpen U) : x ∈ U ↔ (S ∩ U).Nonempty :=\n  ⟨fun h' => ⟨x, h.mem, h'⟩, fun ⟨_y, hyS, hyU⟩ => (h.specializes hyS).mem_open hU hyU⟩\n\n"}
{"name":"IsGenericPoint.disjoint_iff","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nx : α\nS U : Set α\nh : IsGenericPoint x S\nhU : IsOpen U\n⊢ Iff (Disjoint S U) (Not (Membership.mem U x))","decl":"theorem disjoint_iff (h : IsGenericPoint x S) (hU : IsOpen U) : Disjoint S U ↔ x ∉ U := by\n  rw [h.mem_open_set_iff hU, ← not_disjoint_iff_nonempty_inter, Classical.not_not]\n\n"}
{"name":"IsGenericPoint.mem_closed_set_iff","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nx : α\nS Z : Set α\nh : IsGenericPoint x S\nhZ : IsClosed Z\n⊢ Iff (Membership.mem Z x) (HasSubset.Subset S Z)","decl":"theorem mem_closed_set_iff (h : IsGenericPoint x S) (hZ : IsClosed Z) : x ∈ Z ↔ S ⊆ Z := by\n  rw [← h.def, hZ.closure_subset_iff, singleton_subset_iff]\n\n"}
{"name":"IsGenericPoint.image","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nx : α\nS : Set α\nh : IsGenericPoint x S\nf : α → β\nhf : Continuous f\n⊢ IsGenericPoint (f x) (closure (Set.image f S))","decl":"protected theorem image (h : IsGenericPoint x S) {f : α → β} (hf : Continuous f) :\n    IsGenericPoint (f x) (closure (f '' S)) := by\n  rw [isGenericPoint_def, ← h.def, ← image_singleton, closure_image_closure hf]\n\n"}
{"name":"isGenericPoint_iff_forall_closed","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nx : α\nS : Set α\nhS : IsClosed S\nhxS : Membership.mem S x\n⊢ Iff (IsGenericPoint x S) (∀ (Z : Set α), IsClosed Z → Membership.mem Z x → HasSubset.Subset S Z)","decl":"theorem isGenericPoint_iff_forall_closed (hS : IsClosed S) (hxS : x ∈ S) :\n    IsGenericPoint x S ↔ ∀ Z : Set α, IsClosed Z → x ∈ Z → S ⊆ Z := by\n  have : closure {x} ⊆ S := closure_minimal (singleton_subset_iff.2 hxS) hS\n  simp_rw [IsGenericPoint, subset_antisymm_iff, this, true_and, closure, subset_sInter_iff,\n    mem_setOf_eq, and_imp, singleton_subset_iff]\n\n"}
{"name":"quasiSober_iff","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_3\ninst✝ : TopologicalSpace α\n⊢ Iff (QuasiSober α) (∀ {S : Set α}, IsIrreducible S → IsClosed S → Exists fun x => IsGenericPoint x S)","decl":"/-- A space is sober if every irreducible closed subset has a generic point. -/\n@[mk_iff]\nclass QuasiSober (α : Type*) [TopologicalSpace α] : Prop where\n  sober : ∀ {S : Set α}, IsIrreducible S → IsClosed S → ∃ x, IsGenericPoint x S\n\n"}
{"name":"QuasiSober.sober","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_3\ninst✝ : TopologicalSpace α\nself : QuasiSober α\nS : Set α\na✝¹ : IsIrreducible S\na✝ : IsClosed S\n⊢ Exists fun x => IsGenericPoint x S","decl":"/-- A space is sober if every irreducible closed subset has a generic point. -/\n@[mk_iff]\nclass QuasiSober (α : Type*) [TopologicalSpace α] : Prop where\n  sober : ∀ {S : Set α}, IsIrreducible S → IsClosed S → ∃ x, IsGenericPoint x S\n\n"}
{"name":"IsIrreducible.isGenericPoint_genericPoint_closure","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : QuasiSober α\nS : Set α\nhS : IsIrreducible S\n⊢ IsGenericPoint hS.genericPoint (closure S)","decl":"theorem IsIrreducible.isGenericPoint_genericPoint_closure\n    [QuasiSober α] {S : Set α} (hS : IsIrreducible S) :\n    IsGenericPoint hS.genericPoint (closure S) :=\n  (QuasiSober.sober hS.closure isClosed_closure).choose_spec\n\n"}
{"name":"IsIrreducible.isGenericPoint_genericPoint","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : QuasiSober α\nS : Set α\nhS : IsIrreducible S\nhS' : IsClosed S\n⊢ IsGenericPoint hS.genericPoint S","decl":"theorem IsIrreducible.isGenericPoint_genericPoint [QuasiSober α] {S : Set α}\n    (hS : IsIrreducible S) (hS' : IsClosed S) :\n    IsGenericPoint hS.genericPoint S := by\n  convert hS.isGenericPoint_genericPoint_closure; exact hS'.closure_eq.symm\n\n"}
{"name":"IsIrreducible.genericPoint_closure_eq","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : QuasiSober α\nS : Set α\nhS : IsIrreducible S\n⊢ Eq (closure (Singleton.singleton hS.genericPoint)) (closure S)","decl":"@[simp]\ntheorem IsIrreducible.genericPoint_closure_eq [QuasiSober α] {S : Set α} (hS : IsIrreducible S) :\n    closure ({hS.genericPoint} : Set α) = closure S :=\n  hS.isGenericPoint_genericPoint_closure\n\n"}
{"name":"IsIrreducible.closure_genericPoint","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : QuasiSober α\nS : Set α\nhS : IsIrreducible S\nhS' : IsClosed S\n⊢ Eq (closure (Singleton.singleton hS.genericPoint)) S","decl":"theorem IsIrreducible.closure_genericPoint [QuasiSober α] {S : Set α}\n    (hS : IsIrreducible S) (hS' : IsClosed S) :\n    closure ({hS.genericPoint} : Set α) = S :=\n  hS.isGenericPoint_genericPoint_closure.trans hS'.closure_eq\n\n"}
{"name":"IsIrreducible.genericPoint_spec","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : QuasiSober α\nS : Set α\nhS : IsIrreducible S\n⊢ IsGenericPoint hS.genericPoint (closure S)","decl":"@[deprecated (since := \"2024-10-03\")]\nalias IsIrreducible.genericPoint_spec := IsIrreducible.isGenericPoint_genericPoint_closure\n\n"}
{"name":"genericPoint_spec","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : QuasiSober α\ninst✝ : IrreducibleSpace α\n⊢ IsGenericPoint (genericPoint α) Set.univ","decl":"theorem genericPoint_spec [QuasiSober α] [IrreducibleSpace α] :\n    IsGenericPoint (genericPoint α) univ := by\n  simpa using (IrreducibleSpace.isIrreducible_univ α).isGenericPoint_genericPoint_closure\n\n"}
{"name":"genericPoint_closure","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : QuasiSober α\ninst✝ : IrreducibleSpace α\n⊢ Eq (closure (Singleton.singleton (genericPoint α))) Set.univ","decl":"@[simp]\ntheorem genericPoint_closure [QuasiSober α] [IrreducibleSpace α] :\n    closure ({genericPoint α} : Set α) = univ :=\n  genericPoint_spec α\n\n"}
{"name":"genericPoint_specializes","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : QuasiSober α\ninst✝ : IrreducibleSpace α\nx : α\n⊢ Specializes (genericPoint α) x","decl":"theorem genericPoint_specializes [QuasiSober α] [IrreducibleSpace α] (x : α) : genericPoint α ⤳ x :=\n  (IsIrreducible.isGenericPoint_genericPoint_closure _).specializes (by simp)\n\n"}
{"name":"Topology.IsClosedEmbedding.quasiSober","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\nf : α → β\nhf : Topology.IsClosedEmbedding f\ninst✝ : QuasiSober β\n⊢ QuasiSober α","decl":"lemma Topology.IsClosedEmbedding.quasiSober {f : α → β} (hf : IsClosedEmbedding f) [QuasiSober β] :\n    QuasiSober α where\n  sober hS hS' := by\n    have hS'' := hS.image f hf.continuous.continuousOn\n    obtain ⟨x, hx⟩ := QuasiSober.sober hS'' (hf.isClosedMap _ hS')\n    obtain ⟨y, -, rfl⟩ := hx.mem\n    use y\n    apply image_injective.mpr hf.injective\n    rw [← hx.def, ← hf.closure_image_eq, image_singleton]\n\n"}
{"name":"ClosedEmbedding.quasiSober","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\nf : α → β\nhf : Topology.IsClosedEmbedding f\ninst✝ : QuasiSober β\n⊢ QuasiSober α","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ClosedEmbedding.quasiSober := Topology.IsClosedEmbedding.quasiSober\n\n"}
{"name":"Topology.IsOpenEmbedding.quasiSober","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\nf : α → β\nhf : Topology.IsOpenEmbedding f\ninst✝ : QuasiSober β\n⊢ QuasiSober α","decl":"theorem Topology.IsOpenEmbedding.quasiSober {f : α → β} (hf : IsOpenEmbedding f) [QuasiSober β] :\n    QuasiSober α where\n  sober hS hS' := by\n    have hS'' := hS.image f hf.continuous.continuousOn\n    obtain ⟨x, hx⟩ := QuasiSober.sober hS''.closure isClosed_closure\n    obtain ⟨T, hT, rfl⟩ := hf.isInducing.isClosed_iff.mp hS'\n    rw [image_preimage_eq_inter_range] at hx hS''\n    have hxT : x ∈ T := by\n      rw [← hT.closure_eq]\n      exact closure_mono inter_subset_left hx.mem\n    obtain ⟨y, rfl⟩ : x ∈ range f := by\n      rw [hx.mem_open_set_iff hf.isOpen_range]\n      refine Nonempty.mono ?_ hS''.1\n      simpa using subset_closure\n    use y\n    change _ = _\n    rw [hf.isEmbedding.closure_eq_preimage_closure_image, image_singleton, show _ = _ from hx]\n    apply image_injective.mpr hf.injective\n    ext z\n    simp only [image_preimage_eq_inter_range, mem_inter_iff, and_congr_left_iff]\n    exact fun hy => ⟨fun h => hT.closure_eq ▸ closure_mono inter_subset_left h,\n      fun h => subset_closure ⟨h, hy⟩⟩\n\n"}
{"name":"OpenEmbedding.quasiSober","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\nf : α → β\nhf : Topology.IsOpenEmbedding f\ninst✝ : QuasiSober β\n⊢ QuasiSober α","decl":"@[deprecated (since := \"2024-10-18\")]\nalias OpenEmbedding.quasiSober := Topology.IsOpenEmbedding.quasiSober\n\n"}
{"name":"quasiSober_of_open_cover","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nS : Set (Set α)\nhS : ∀ (s : ↑S), IsOpen ↑s\nhS' : ∀ (s : ↑S), QuasiSober ↑↑s\nhS'' : Eq S.sUnion Top.top\n⊢ QuasiSober α","decl":"/-- A space is quasi sober if it can be covered by open quasi sober subsets. -/\ntheorem quasiSober_of_open_cover (S : Set (Set α)) (hS : ∀ s : S, IsOpen (s : Set α))\n    [hS' : ∀ s : S, QuasiSober s] (hS'' : ⋃₀ S = ⊤) : QuasiSober α := by\n  rw [quasiSober_iff]\n  intro t h h'\n  obtain ⟨x, hx⟩ := h.1\n  obtain ⟨U, hU, hU'⟩ : x ∈ ⋃₀ S := by\n    rw [hS'']\n    trivial\n  haveI : QuasiSober U := hS' ⟨U, hU⟩\n  have H : IsPreirreducible ((↑) ⁻¹' t : Set U) :=\n    h.2.preimage (hS ⟨U, hU⟩).isOpenEmbedding_subtypeVal\n  replace H : IsIrreducible ((↑) ⁻¹' t : Set U) := ⟨⟨⟨x, hU'⟩, by simpa using hx⟩, H⟩\n  use H.genericPoint\n  have := continuous_subtype_val.closure_preimage_subset _ H.isGenericPoint_genericPoint_closure.mem\n  rw [h'.closure_eq] at this\n  apply le_antisymm\n  · apply h'.closure_subset_iff.mpr\n    simpa using this\n  rw [← image_singleton, ← closure_image_closure continuous_subtype_val,\n    H.isGenericPoint_genericPoint_closure.def]\n  refine (subset_closure_inter_of_isPreirreducible_of_isOpen h.2 (hS ⟨U, hU⟩) ⟨x, hx, hU'⟩).trans\n    (closure_mono ?_)\n  rw [inter_comm t, ← Subtype.image_preimage_coe]\n  exact Set.image_subset _ subset_closure\n\n"}
{"name":"T2Space.quasiSober","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : T2Space α\n⊢ QuasiSober α","decl":"/-- Any Hausdorff space is a quasi-sober space because any irreducible set is a singleton. -/\ninstance (priority := 100) T2Space.quasiSober [T2Space α] : QuasiSober α where\n  sober h _ := by\n    obtain ⟨x, rfl⟩ := isIrreducible_iff_singleton.mp h\n    exact ⟨x, closure_singleton⟩\n\n"}
{"name":"genericPoints.isGenericPoint","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nx : ↑(genericPoints α)\n⊢ IsGenericPoint ↑x ↑(genericPoints.component x)","decl":"lemma isGenericPoint (x : genericPoints α) : IsGenericPoint x.1 (component x).1 := rfl\n\n"}
{"name":"genericPoints.component_injective","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : T0Space α\n⊢ Function.Injective genericPoints.component","decl":"lemma component_injective [T0Space α] : Function.Injective (component (α := α)) :=\n  fun x y e ↦ Subtype.ext ((isGenericPoint x).eq (e ▸ isGenericPoint y))\n\n"}
{"name":"genericPoints.isGenericPoint_ofComponent","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : QuasiSober α\nx : ↑(irreducibleComponents α)\n⊢ IsGenericPoint ↑(genericPoints.ofComponent x) ↑x","decl":"lemma isGenericPoint_ofComponent [QuasiSober α] (x : irreducibleComponents α) :\n    IsGenericPoint (ofComponent x).1 x :=\n    x.2.1.isGenericPoint_genericPoint (isClosed_of_mem_irreducibleComponents x.1 x.2)\n\n"}
{"name":"genericPoints.component_ofComponent","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : QuasiSober α\nx : ↑(irreducibleComponents α)\n⊢ Eq (genericPoints.component (genericPoints.ofComponent x)) x","decl":"@[simp]\nlemma component_ofComponent [QuasiSober α] (x : irreducibleComponents α) :\n    component (ofComponent x) = x :=\n  Subtype.ext (isGenericPoint_ofComponent x)\n\n"}
{"name":"genericPoints.ofComponent_component","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : T0Space α\ninst✝ : QuasiSober α\nx : ↑(genericPoints α)\n⊢ Eq (genericPoints.ofComponent (genericPoints.component x)) x","decl":"@[simp]\nlemma ofComponent_component [T0Space α] [QuasiSober α] (x : genericPoints α) :\n    ofComponent (component x) = x :=\n  component_injective (component_ofComponent _)\n\n"}
{"name":"genericPoints.component_surjective","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : QuasiSober α\n⊢ Function.Surjective genericPoints.component","decl":"lemma component_surjective [QuasiSober α] : Function.Surjective (component (α := α)) :=\n  Function.HasRightInverse.surjective ⟨ofComponent, component_ofComponent⟩\n\n"}
{"name":"genericPoints.finite","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : T0Space α\nh : (irreducibleComponents α).Finite\n⊢ (genericPoints α).Finite","decl":"lemma finite [T0Space α] (h : (irreducibleComponents α).Finite) : (genericPoints α).Finite :=\n  @Finite.of_injective _ _ h _ component_injective\n\n"}
{"name":"genericPoints.equiv_symm_apply","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : T0Space α\ninst✝ : QuasiSober α\nx : ↑(irreducibleComponents α)\n⊢ Eq (genericPoints.equiv.symm x) (genericPoints.ofComponent x)","decl":"/-- In a sober space, the generic points corresponds bijectively to irreducible components -/\n@[simps]\nnoncomputable\ndef equiv [T0Space α] [QuasiSober α] : genericPoints α ≃ irreducibleComponents α :=\n  ⟨component, ofComponent, ofComponent_component, component_ofComponent⟩\n\n"}
{"name":"genericPoints.equiv_apply","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : T0Space α\ninst✝ : QuasiSober α\nx : ↑(genericPoints α)\n⊢ Eq (genericPoints.equiv x) (genericPoints.component x)","decl":"/-- In a sober space, the generic points corresponds bijectively to irreducible components -/\n@[simps]\nnoncomputable\ndef equiv [T0Space α] [QuasiSober α] : genericPoints α ≃ irreducibleComponents α :=\n  ⟨component, ofComponent, ofComponent_component, component_ofComponent⟩\n\n"}
{"name":"genericPoints.closure","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : QuasiSober α\n⊢ Eq (closure (genericPoints α)) Set.univ","decl":"lemma closure [QuasiSober α] : closure (genericPoints α) = Set.univ := by\n  refine Set.eq_univ_iff_forall.mpr fun x ↦ Set.subset_def.mp ?_ x mem_irreducibleComponent\n  refine (isGenericPoint_ofComponent\n    ⟨_, irreducibleComponent_mem_irreducibleComponents x⟩).symm.trans_subset (closure_mono ?_)\n  exact Set.singleton_subset_iff.mpr (ofComponent _).2\n\n"}
{"name":"genericPoints_eq_singleton","module":"Mathlib.Topology.Sober","initialProofState":"α : Type u_1\ninst✝³ : TopologicalSpace α\ninst✝² : QuasiSober α\ninst✝¹ : IrreducibleSpace α\ninst✝ : T0Space α\n⊢ Eq (genericPoints α) (Singleton.singleton (genericPoint α))","decl":"lemma genericPoints_eq_singleton [QuasiSober α] [IrreducibleSpace α] [T0Space α] :\n    genericPoints α = {genericPoint α} := by\n  ext x\n  rw [genericPoints, irreducibleComponents_eq_singleton]\n  exact ⟨((genericPoint_spec α).eq · |>.symm), (· ▸ genericPoint_spec α)⟩\n\n"}
