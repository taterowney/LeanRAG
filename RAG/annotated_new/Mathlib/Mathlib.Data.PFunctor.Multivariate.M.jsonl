{"name":"MvPFunctor.M.Path.child.sizeOf_spec","module":"Mathlib.Data.PFunctor.Multivariate.M","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nx : P.last.M\na : P.A\nf : P.last.B a → P.last.M\nh : Eq x.dest ⟨a, f⟩\nj : P.last.B a\ni : Fin2 n\nc : MvPFunctor.M.Path P (f j) i\n⊢ Eq (SizeOf.sizeOf (MvPFunctor.M.Path.child x a f h j i c)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf x)) (SizeOf.sizeOf a)) (SizeOf.sizeOf h)) (SizeOf.sizeOf j)) (SizeOf.sizeOf i)) (SizeOf.sizeOf c))","decl":"/-- A path from the root of a tree to one of its node -/\ninductive M.Path : P.last.M → Fin2 n → Type u\n  | root (x : P.last.M)\n          (a : P.A)\n          (f : P.last.B a → P.last.M)\n          (h : PFunctor.M.dest x = ⟨a, f⟩)\n          (i : Fin2 n)\n          (c : P.drop.B a i) : M.Path x i\n  | child (x : P.last.M)\n          (a : P.A)\n          (f : P.last.B a → P.last.M)\n          (h : PFunctor.M.dest x = ⟨a, f⟩)\n          (j : P.last.B a)\n          (i : Fin2 n)\n          (c : M.Path (f j) i) : M.Path x i\n\n"}
{"name":"MvPFunctor.M.Path.root.injEq","module":"Mathlib.Data.PFunctor.Multivariate.M","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nx : P.last.M\na✝ : P.A\nf✝ : P.last.B a✝ → P.last.M\nh✝ : Eq x.dest ⟨a✝, f✝⟩\ni : Fin2 n\nc✝ : P.drop.B a✝ i\na : P.A\nf : P.last.B a → P.last.M\nh : Eq x.dest ⟨a, f⟩\nc : P.drop.B a i\n⊢ Eq (Eq (MvPFunctor.M.Path.root x a✝ f✝ h✝ i c✝) (MvPFunctor.M.Path.root x a f h i c)) (And (Eq a✝ a) (And (HEq f✝ f) (HEq c✝ c)))","decl":"/-- A path from the root of a tree to one of its node -/\ninductive M.Path : P.last.M → Fin2 n → Type u\n  | root (x : P.last.M)\n          (a : P.A)\n          (f : P.last.B a → P.last.M)\n          (h : PFunctor.M.dest x = ⟨a, f⟩)\n          (i : Fin2 n)\n          (c : P.drop.B a i) : M.Path x i\n  | child (x : P.last.M)\n          (a : P.A)\n          (f : P.last.B a → P.last.M)\n          (h : PFunctor.M.dest x = ⟨a, f⟩)\n          (j : P.last.B a)\n          (i : Fin2 n)\n          (c : M.Path (f j) i) : M.Path x i\n\n"}
{"name":"MvPFunctor.M.Path.child.injEq","module":"Mathlib.Data.PFunctor.Multivariate.M","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nx : P.last.M\na✝ : P.A\nf✝ : P.last.B a✝ → P.last.M\nh✝ : Eq x.dest ⟨a✝, f✝⟩\nj✝ : P.last.B a✝\ni : Fin2 n\nc✝ : MvPFunctor.M.Path P (f✝ j✝) i\na : P.A\nf : P.last.B a → P.last.M\nh : Eq x.dest ⟨a, f⟩\nj : P.last.B a\nc : MvPFunctor.M.Path P (f j) i\n⊢ Eq (Eq (MvPFunctor.M.Path.child x a✝ f✝ h✝ j✝ i c✝) (MvPFunctor.M.Path.child x a f h j i c)) (And (Eq a✝ a) (And (HEq f✝ f) (And (HEq j✝ j) (HEq c✝ c))))","decl":"/-- A path from the root of a tree to one of its node -/\ninductive M.Path : P.last.M → Fin2 n → Type u\n  | root (x : P.last.M)\n          (a : P.A)\n          (f : P.last.B a → P.last.M)\n          (h : PFunctor.M.dest x = ⟨a, f⟩)\n          (i : Fin2 n)\n          (c : P.drop.B a i) : M.Path x i\n  | child (x : P.last.M)\n          (a : P.A)\n          (f : P.last.B a → P.last.M)\n          (h : PFunctor.M.dest x = ⟨a, f⟩)\n          (j : P.last.B a)\n          (i : Fin2 n)\n          (c : M.Path (f j) i) : M.Path x i\n\n"}
{"name":"MvPFunctor.M.Path.root.inj","module":"Mathlib.Data.PFunctor.Multivariate.M","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nx : P.last.M\na✝ : P.A\nf✝ : P.last.B a✝ → P.last.M\nh✝ : Eq x.dest ⟨a✝, f✝⟩\ni : Fin2 n\nc✝ : P.drop.B a✝ i\na : P.A\nf : P.last.B a → P.last.M\nh : Eq x.dest ⟨a, f⟩\nc : P.drop.B a i\nx✝ : Eq (MvPFunctor.M.Path.root x a✝ f✝ h✝ i c✝) (MvPFunctor.M.Path.root x a f h i c)\n⊢ And (Eq a✝ a) (And (HEq f✝ f) (HEq c✝ c))","decl":"/-- A path from the root of a tree to one of its node -/\ninductive M.Path : P.last.M → Fin2 n → Type u\n  | root (x : P.last.M)\n          (a : P.A)\n          (f : P.last.B a → P.last.M)\n          (h : PFunctor.M.dest x = ⟨a, f⟩)\n          (i : Fin2 n)\n          (c : P.drop.B a i) : M.Path x i\n  | child (x : P.last.M)\n          (a : P.A)\n          (f : P.last.B a → P.last.M)\n          (h : PFunctor.M.dest x = ⟨a, f⟩)\n          (j : P.last.B a)\n          (i : Fin2 n)\n          (c : M.Path (f j) i) : M.Path x i\n\n"}
{"name":"MvPFunctor.M.Path.child.inj","module":"Mathlib.Data.PFunctor.Multivariate.M","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nx : P.last.M\na✝ : P.A\nf✝ : P.last.B a✝ → P.last.M\nh✝ : Eq x.dest ⟨a✝, f✝⟩\nj✝ : P.last.B a✝\ni : Fin2 n\nc✝ : MvPFunctor.M.Path P (f✝ j✝) i\na : P.A\nf : P.last.B a → P.last.M\nh : Eq x.dest ⟨a, f⟩\nj : P.last.B a\nc : MvPFunctor.M.Path P (f j) i\nx✝ : Eq (MvPFunctor.M.Path.child x a✝ f✝ h✝ j✝ i c✝) (MvPFunctor.M.Path.child x a f h j i c)\n⊢ And (Eq a✝ a) (And (HEq f✝ f) (And (HEq j✝ j) (HEq c✝ c)))","decl":"/-- A path from the root of a tree to one of its node -/\ninductive M.Path : P.last.M → Fin2 n → Type u\n  | root (x : P.last.M)\n          (a : P.A)\n          (f : P.last.B a → P.last.M)\n          (h : PFunctor.M.dest x = ⟨a, f⟩)\n          (i : Fin2 n)\n          (c : P.drop.B a i) : M.Path x i\n  | child (x : P.last.M)\n          (a : P.A)\n          (f : P.last.B a → P.last.M)\n          (h : PFunctor.M.dest x = ⟨a, f⟩)\n          (j : P.last.B a)\n          (i : Fin2 n)\n          (c : M.Path (f j) i) : M.Path x i\n\n"}
{"name":"MvPFunctor.M.Path.root.sizeOf_spec","module":"Mathlib.Data.PFunctor.Multivariate.M","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nx : P.last.M\na : P.A\nf : P.last.B a → P.last.M\nh : Eq x.dest ⟨a, f⟩\ni : Fin2 n\nc : P.drop.B a i\n⊢ Eq (SizeOf.sizeOf (MvPFunctor.M.Path.root x a f h i c)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf x)) (SizeOf.sizeOf a)) (SizeOf.sizeOf h)) (SizeOf.sizeOf i)) (SizeOf.sizeOf c))","decl":"/-- A path from the root of a tree to one of its node -/\ninductive M.Path : P.last.M → Fin2 n → Type u\n  | root (x : P.last.M)\n          (a : P.A)\n          (f : P.last.B a → P.last.M)\n          (h : PFunctor.M.dest x = ⟨a, f⟩)\n          (i : Fin2 n)\n          (c : P.drop.B a i) : M.Path x i\n  | child (x : P.last.M)\n          (a : P.A)\n          (f : P.last.B a → P.last.M)\n          (h : PFunctor.M.dest x = ⟨a, f⟩)\n          (j : P.last.B a)\n          (i : Fin2 n)\n          (c : M.Path (f j) i) : M.Path x i\n\n"}
{"name":"MvPFunctor.M.dest'_eq_dest'","module":"Mathlib.Data.PFunctor.Multivariate.M","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα : TypeVec.{u} n\nx : P.last.M\na₁ : P.A\nf₁ : P.last.B a₁ → P.last.M\nh₁ : Eq x.dest ⟨a₁, f₁⟩\na₂ : P.A\nf₂ : P.last.B a₂ → P.last.M\nh₂ : Eq x.dest ⟨a₂, f₂⟩\nf' : TypeVec.Arrow (MvPFunctor.M.Path P x) α\n⊢ Eq (MvPFunctor.M.dest' P h₁ f') (MvPFunctor.M.dest' P h₂ f')","decl":"theorem M.dest'_eq_dest' {α : TypeVec n} {x : P.last.M} {a₁ : P.A}\n    {f₁ : P.last.B a₁ → P.last.M} (h₁ : PFunctor.M.dest x = ⟨a₁, f₁⟩) {a₂ : P.A}\n    {f₂ : P.last.B a₂ → P.last.M} (h₂ : PFunctor.M.dest x = ⟨a₂, f₂⟩) (f' : M.Path P x ⟹ α) :\n    M.dest' P h₁ f' = M.dest' P h₂ f' := by cases h₁.symm.trans h₂; rfl\n\n"}
{"name":"MvPFunctor.M.dest_eq_dest'","module":"Mathlib.Data.PFunctor.Multivariate.M","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα : TypeVec.{u} n\nx : P.last.M\na : P.A\nf : P.last.B a → P.last.M\nh : Eq x.dest ⟨a, f⟩\nf' : TypeVec.Arrow (MvPFunctor.M.Path P x) α\n⊢ Eq (MvPFunctor.M.dest P ⟨x, f'⟩) (MvPFunctor.M.dest' P h f')","decl":"theorem M.dest_eq_dest' {α : TypeVec n} {x : P.last.M} {a : P.A}\n    {f : P.last.B a → P.last.M} (h : PFunctor.M.dest x = ⟨a, f⟩) (f' : M.Path P x ⟹ α) :\n    M.dest P ⟨x, f'⟩ = M.dest' P h f' :=\n  M.dest'_eq_dest' _ _ _ _\n\n"}
{"name":"MvPFunctor.M.dest_corec'","module":"Mathlib.Data.PFunctor.Multivariate.M","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα : TypeVec.{u} n\nβ : Type u\ng₀ : β → P.A\ng₁ : (b : β) → (P.drop.B (g₀ b)).Arrow α\ng₂ : (b : β) → P.last.B (g₀ b) → β\nx : β\n⊢ Eq (MvPFunctor.M.dest P (MvPFunctor.M.corec' P g₀ g₁ g₂ x)) ⟨g₀ x, TypeVec.splitFun (g₁ x) (Function.comp (MvPFunctor.M.corec' P g₀ g₁ g₂) (g₂ x))⟩","decl":"theorem M.dest_corec' {α : TypeVec.{u} n} {β : Type u} (g₀ : β → P.A)\n    (g₁ : ∀ b : β, P.drop.B (g₀ b) ⟹ α) (g₂ : ∀ b : β, P.last.B (g₀ b) → β) (x : β) :\n    M.dest P (M.corec' P g₀ g₁ g₂ x) = ⟨g₀ x, splitFun (g₁ x) (M.corec' P g₀ g₁ g₂ ∘ g₂ x)⟩ :=\n  rfl\n\n"}
{"name":"MvPFunctor.M.dest_corec","module":"Mathlib.Data.PFunctor.Multivariate.M","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα : TypeVec.{u} n\nβ : Type u\ng : β → ↑P (α.append1 β)\nx : β\n⊢ Eq (MvPFunctor.M.dest P (MvPFunctor.M.corec P g x)) (MvFunctor.map (TypeVec.appendFun TypeVec.id (MvPFunctor.M.corec P g)) (g x))","decl":"theorem M.dest_corec {α : TypeVec n} {β : Type u} (g : β → P (α.append1 β)) (x : β) :\n    M.dest P (M.corec P g x) = appendFun id (M.corec P g) <$$> g x := by\n  trans\n  · apply M.dest_corec'\n  cases' g x with a f; dsimp\n  rw [MvPFunctor.map_eq]; congr\n  conv_rhs => rw [← split_dropFun_lastFun f, appendFun_comp_splitFun]\n  rfl\n\n"}
{"name":"MvPFunctor.M.bisim_lemma","module":"Mathlib.Data.PFunctor.Multivariate.M","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα : TypeVec.{u} n\na₁ : P.mp.A\nf₁ : (P.mp.B a₁).Arrow α\na' : P.A\nf' : (P.B a').drop.Arrow α\nf₁' : (P.B a').last → P.M α\ne₁ : Eq (MvPFunctor.M.dest P ⟨a₁, f₁⟩) ⟨a', TypeVec.splitFun f' f₁'⟩\n⊢ Exists fun g₁' => Exists fun e₁' => And (Eq f' (MvPFunctor.M.pathDestLeft P e₁' f₁)) (Eq f₁' fun x => ⟨g₁' x, MvPFunctor.M.pathDestRight P e₁' f₁ x⟩)","decl":"theorem M.bisim_lemma {α : TypeVec n} {a₁ : (mp P).A} {f₁ : (mp P).B a₁ ⟹ α} {a' : P.A}\n    {f' : (P.B a').drop ⟹ α} {f₁' : (P.B a').last → M P α}\n    (e₁ : M.dest P ⟨a₁, f₁⟩ = ⟨a', splitFun f' f₁'⟩) :\n    ∃ (g₁' : _)(e₁' : PFunctor.M.dest a₁ = ⟨a', g₁'⟩),\n      f' = M.pathDestLeft P e₁' f₁ ∧\n        f₁' = fun x : (last P).B a' => ⟨g₁' x, M.pathDestRight P e₁' f₁ x⟩ := by\n  generalize ef : @splitFun n _ (append1 α (M P α)) f' f₁' = ff at e₁\n  let he₁' := PFunctor.M.dest a₁\n  rcases e₁' : he₁' with ⟨a₁', g₁'⟩\n  rw [M.dest_eq_dest' _ e₁'] at e₁\n  cases e₁; exact ⟨_, e₁', splitFun_inj ef⟩\n\n"}
{"name":"MvPFunctor.M.bisim","module":"Mathlib.Data.PFunctor.Multivariate.M","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα : TypeVec.{u} n\nR : P.M α → P.M α → Prop\nh : ∀ (x y : P.M α), R x y → Exists fun a => Exists fun f => Exists fun f₁ => Exists fun f₂ => And (Eq (MvPFunctor.M.dest P x) ⟨a, TypeVec.splitFun f f₁⟩) (And (Eq (MvPFunctor.M.dest P y) ⟨a, TypeVec.splitFun f f₂⟩) (∀ (i : (P.B a).last), R (f₁ i) (f₂ i)))\nx y : P.M α\nr : R x y\n⊢ Eq x y","decl":"theorem M.bisim {α : TypeVec n} (R : P.M α → P.M α → Prop)\n    (h :\n      ∀ x y,\n        R x y →\n          ∃ a f f₁ f₂,\n            M.dest P x = ⟨a, splitFun f f₁⟩ ∧\n              M.dest P y = ⟨a, splitFun f f₂⟩ ∧ ∀ i, R (f₁ i) (f₂ i))\n    (x y) (r : R x y) : x = y := by\n  cases' x with a₁ f₁\n  cases' y with a₂ f₂\n  dsimp [mp] at *\n  have : a₁ = a₂ := by\n    refine\n      PFunctor.M.bisim (fun a₁ a₂ => ∃ x y, R x y ∧ x.1 = a₁ ∧ y.1 = a₂) ?_ _ _\n        ⟨⟨a₁, f₁⟩, ⟨a₂, f₂⟩, r, rfl, rfl⟩\n    rintro _ _ ⟨⟨a₁, f₁⟩, ⟨a₂, f₂⟩, r, rfl, rfl⟩\n    rcases h _ _ r with ⟨a', f', f₁', f₂', e₁, e₂, h'⟩\n    rcases M.bisim_lemma P e₁ with ⟨g₁', e₁', rfl, rfl⟩\n    rcases M.bisim_lemma P e₂ with ⟨g₂', e₂', _, rfl⟩\n    rw [e₁', e₂']\n    exact ⟨_, _, _, rfl, rfl, fun b => ⟨_, _, h' b, rfl, rfl⟩⟩\n  subst this\n  congr with (i p)\n  induction' p with x a f h' i c x a f h' i c p IH <;>\n    try\n      rcases h _ _ r with ⟨a', f', f₁', f₂', e₁, e₂, h''⟩\n      rcases M.bisim_lemma P e₁ with ⟨g₁', e₁', rfl, rfl⟩\n      rcases M.bisim_lemma P e₂ with ⟨g₂', e₂', e₃, rfl⟩\n      cases h'.symm.trans e₁'\n      cases h'.symm.trans e₂'\n  · exact (congr_fun (congr_fun e₃ i) c :)\n  · exact IH _ _ (h'' _)\n\n"}
{"name":"MvPFunctor.M.bisim₀","module":"Mathlib.Data.PFunctor.Multivariate.M","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα : TypeVec.{u} n\nR : P.M α → P.M α → Prop\nh₀ : Equivalence R\nh : ∀ (x y : P.M α), R x y → Eq (MvFunctor.map (TypeVec.appendFun TypeVec.id (Quot.mk R)) (MvPFunctor.M.dest P x)) (MvFunctor.map (TypeVec.appendFun TypeVec.id (Quot.mk R)) (MvPFunctor.M.dest P y))\nx y : P.M α\nr : R x y\n⊢ Eq x y","decl":"theorem M.bisim₀ {α : TypeVec n} (R : P.M α → P.M α → Prop) (h₀ : Equivalence R)\n    (h : ∀ x y, R x y → (id ::: Quot.mk R) <$$> M.dest _ x = (id ::: Quot.mk R) <$$> M.dest _ y)\n    (x y) (r : R x y) : x = y := by\n  apply M.bisim P R _ _ _ r\n  clear r x y\n  introv Hr\n  specialize h _ _ Hr\n  clear Hr\n\n  revert h\n  rcases M.dest P x with ⟨ax, fx⟩\n  rcases M.dest P y with ⟨ay, fy⟩\n  intro h\n\n  rw [map_eq, map_eq] at h\n  injection h with h₀ h₁\n  subst ay\n  simp? at h₁ says simp only [heq_eq_eq] at h₁\n  have Hdrop : dropFun fx = dropFun fy := by\n    replace h₁ := congr_arg dropFun h₁\n    simpa using h₁\n  exists ax, dropFun fx, lastFun fx, lastFun fy\n  rw [split_dropFun_lastFun, Hdrop, split_dropFun_lastFun]\n  simp only [true_and]\n  intro i\n  replace h₁ := congr_fun (congr_fun h₁ Fin2.fz) i\n  simp only [TypeVec.comp, appendFun, splitFun] at h₁\n  replace h₁ := Quot.eqvGen_exact h₁\n  rw [h₀.eqvGen_iff] at h₁\n  exact h₁\n\n"}
{"name":"MvPFunctor.M.bisim'","module":"Mathlib.Data.PFunctor.Multivariate.M","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα : TypeVec.{u} n\nR : P.M α → P.M α → Prop\nh : ∀ (x y : P.M α), R x y → Eq (MvFunctor.map (TypeVec.appendFun TypeVec.id (Quot.mk R)) (MvPFunctor.M.dest P x)) (MvFunctor.map (TypeVec.appendFun TypeVec.id (Quot.mk R)) (MvPFunctor.M.dest P y))\nx y : P.M α\nr : R x y\n⊢ Eq x y","decl":"theorem M.bisim' {α : TypeVec n} (R : P.M α → P.M α → Prop)\n    (h : ∀ x y, R x y → (id ::: Quot.mk R) <$$> M.dest _ x = (id ::: Quot.mk R) <$$> M.dest _ y)\n    (x y) (r : R x y) : x = y := by\n  have := M.bisim₀ P (Relation.EqvGen R) ?_ ?_\n  · solve_by_elim [Relation.EqvGen.rel]\n  · apply Relation.EqvGen.is_equivalence\n  · clear r x y\n    introv Hr\n    have : ∀ x y, R x y → Relation.EqvGen R x y := @Relation.EqvGen.rel _ R\n    induction Hr\n    · rw [← Quot.factor_mk_eq R (Relation.EqvGen R) this]\n      rwa [appendFun_comp_id, ← MvFunctor.map_map, ← MvFunctor.map_map, h]\n    all_goals simp_all\n\n"}
{"name":"MvPFunctor.M.dest_map","module":"Mathlib.Data.PFunctor.Multivariate.M","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα β : TypeVec.{u} n\ng : α.Arrow β\nx : P.M α\n⊢ Eq (MvPFunctor.M.dest P (MvFunctor.map g x)) (MvFunctor.map (TypeVec.appendFun g fun x => MvFunctor.map g x) (MvPFunctor.M.dest P x))","decl":"theorem M.dest_map {α β : TypeVec n} (g : α ⟹ β) (x : P.M α) :\n    M.dest P (g <$$> x) = (appendFun g fun x => g <$$> x) <$$> M.dest P x := by\n  cases' x with a f\n  rw [map_eq]\n  conv =>\n    rhs\n    rw [M.dest, M.dest', map_eq, appendFun_comp_splitFun]\n  rfl\n\n"}
{"name":"MvPFunctor.M.map_dest","module":"Mathlib.Data.PFunctor.Multivariate.M","initialProofState":"n : Nat\nP : MvPFunctor.{u} (HAdd.hAdd n 1)\nα β : TypeVec.{u} n\ng : (α.append1 (P.M α)).Arrow (β.append1 (P.M β))\nx : P.M α\nh : ∀ (x : P.M α), Eq (TypeVec.lastFun g x) (MvFunctor.map (TypeVec.dropFun g) x)\n⊢ Eq (MvFunctor.map g (MvPFunctor.M.dest P x)) (MvPFunctor.M.dest P (MvFunctor.map (TypeVec.dropFun g) x))","decl":"theorem M.map_dest {α β : TypeVec n} (g : (α ::: P.M α) ⟹ (β ::: P.M β)) (x : P.M α)\n    (h : ∀ x : P.M α, lastFun g x = (dropFun g <$$> x : P.M β)) :\n    g <$$> M.dest P x = M.dest P (dropFun g <$$> x) := by\n  rw [M.dest_map]; congr\n  apply eq_of_drop_last_eq (by simp)\n  simp only [lastFun_appendFun]\n  ext1; apply h\n\n"}
