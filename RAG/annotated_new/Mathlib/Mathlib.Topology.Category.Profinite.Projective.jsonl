{"name":"Profinite.projective_ultrafilter","module":"Mathlib.Topology.Category.Profinite.Projective","initialProofState":"X : Type u\n⊢ CategoryTheory.Projective (Profinite.of (Ultrafilter X))","decl":"instance projective_ultrafilter (X : Type u) : Projective (of <| Ultrafilter X) where\n  factors {Y Z} f g hg := by\n    rw [epi_iff_surjective] at hg\n    obtain ⟨g', hg'⟩ := hg.hasRightInverse\n    let t : X → Y := g' ∘ f ∘ (pure : X → Ultrafilter X)\n    let h : Ultrafilter X → Y := Ultrafilter.extend t\n    have hh : Continuous h := continuous_ultrafilter_extend _\n    use ⟨h, hh⟩\n    apply (forget Profinite).map_injective\n    simp only [h, ContinuousMap.coe_mk, coe_comp]\n    convert denseRange_pure.equalizer (g.continuous.comp hh) f.continuous _\n     -- Porting note: same fix as in `Topology.Category.CompHaus.Projective`\n    let g'' : ContinuousMap Y Z := g\n    have : g'' ∘ g' = id := hg'.comp_eq_id\n    -- This used to be `rw`, but we need `rw; rfl` after https://github.com/leanprover/lean4/pull/2644\n    rw [comp_assoc, ultrafilter_extend_extends, ← comp_assoc, this, id_comp]\n    rfl\n\n"}
{"name":"Profinite.instEnoughProjectives","module":"Mathlib.Topology.Category.Profinite.Projective","initialProofState":"⊢ CategoryTheory.EnoughProjectives Profinite","decl":"instance : EnoughProjectives Profinite.{u} where presentation X := ⟨projectivePresentation X⟩\n\n"}
