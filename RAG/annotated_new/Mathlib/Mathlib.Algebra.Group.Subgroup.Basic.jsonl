{"name":"div_mem_comm_iff","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝² : Group G\nS : Type u_6\nH : S\ninst✝¹ : SetLike S G\ninst✝ : SubgroupClass S G\na b : G\n⊢ Iff (Membership.mem H (HDiv.hDiv a b)) (Membership.mem H (HDiv.hDiv b a))","decl":"@[to_additive]\ntheorem div_mem_comm_iff {a b : G} : a / b ∈ H ↔ b / a ∈ H :=\n  inv_div b a ▸ inv_mem_iff\n\n"}
{"name":"sub_mem_comm_iff","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nS : Type u_6\nH : S\ninst✝¹ : SetLike S G\ninst✝ : AddSubgroupClass S G\na b : G\n⊢ Iff (Membership.mem H (HSub.hSub a b)) (Membership.mem H (HSub.hSub b a))","decl":"@[to_additive]\ntheorem div_mem_comm_iff {a b : G} : a / b ∈ H ↔ b / a ∈ H :=\n  inv_div b a ▸ inv_mem_iff\n\n"}
{"name":"Subgroup.div_mem_comm_iff","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\na b : G\n⊢ Iff (Membership.mem H (HDiv.hDiv a b)) (Membership.mem H (HDiv.hDiv b a))","decl":"@[to_additive]\nprotected theorem div_mem_comm_iff {a b : G} : a / b ∈ H ↔ b / a ∈ H :=\n  div_mem_comm_iff\n\n"}
{"name":"AddSubgroup.sub_mem_comm_iff","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\na b : G\n⊢ Iff (Membership.mem H (HSub.hSub a b)) (Membership.mem H (HSub.hSub b a))","decl":"@[to_additive]\nprotected theorem div_mem_comm_iff {a b : G} : a / b ∈ H ↔ b / a ∈ H :=\n  div_mem_comm_iff\n\n"}
{"name":"Subgroup.coe_prod","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH : Subgroup G\nK : Subgroup N\n⊢ Eq (↑(H.prod K)) (SProd.sprod ↑H ↑K)","decl":"@[to_additive coe_prod]\ntheorem coe_prod (H : Subgroup G) (K : Subgroup N) :\n    (H.prod K : Set (G × N)) = (H : Set G) ×ˢ (K : Set N) :=\n  rfl\n\n"}
{"name":"AddSubgroup.coe_prod","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH : AddSubgroup G\nK : AddSubgroup N\n⊢ Eq (↑(H.prod K)) (SProd.sprod ↑H ↑K)","decl":"@[to_additive coe_prod]\ntheorem coe_prod (H : Subgroup G) (K : Subgroup N) :\n    (H.prod K : Set (G × N)) = (H : Set G) ×ˢ (K : Set N) :=\n  rfl\n\n"}
{"name":"Subgroup.mem_prod","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH : Subgroup G\nK : Subgroup N\np : Prod G N\n⊢ Iff (Membership.mem (H.prod K) p) (And (Membership.mem H p.1) (Membership.mem K p.2))","decl":"@[to_additive mem_prod]\ntheorem mem_prod {H : Subgroup G} {K : Subgroup N} {p : G × N} : p ∈ H.prod K ↔ p.1 ∈ H ∧ p.2 ∈ K :=\n  Iff.rfl\n\n"}
{"name":"AddSubgroup.mem_prod","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH : AddSubgroup G\nK : AddSubgroup N\np : Prod G N\n⊢ Iff (Membership.mem (H.prod K) p) (And (Membership.mem H p.1) (Membership.mem K p.2))","decl":"@[to_additive mem_prod]\ntheorem mem_prod {H : Subgroup G} {K : Subgroup N} {p : G × N} : p ∈ H.prod K ↔ p.1 ∈ H ∧ p.2 ∈ K :=\n  Iff.rfl\n\n"}
{"name":"Subgroup.prod_mono","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\n⊢ Relator.LiftFun (fun x1 x2 => LE.le x1 x2) (Relator.LiftFun (fun x1 x2 => LE.le x1 x2) fun x1 x2 => LE.le x1 x2) Subgroup.prod Subgroup.prod","decl":"@[to_additive prod_mono]\ntheorem prod_mono : ((· ≤ ·) ⇒ (· ≤ ·) ⇒ (· ≤ ·)) (@prod G _ N _) (@prod G _ N _) :=\n  fun _s _s' hs _t _t' ht => Set.prod_mono hs ht\n\n"}
{"name":"AddSubgroup.prod_mono","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\n⊢ Relator.LiftFun (fun x1 x2 => LE.le x1 x2) (Relator.LiftFun (fun x1 x2 => LE.le x1 x2) fun x1 x2 => LE.le x1 x2) AddSubgroup.prod AddSubgroup.prod","decl":"@[to_additive prod_mono]\ntheorem prod_mono : ((· ≤ ·) ⇒ (· ≤ ·) ⇒ (· ≤ ·)) (@prod G _ N _) (@prod G _ N _) :=\n  fun _s _s' hs _t _t' ht => Set.prod_mono hs ht\n\n"}
{"name":"AddSubgroup.prod_mono_right","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nK : AddSubgroup G\n⊢ Monotone fun t => K.prod t","decl":"@[to_additive prod_mono_right]\ntheorem prod_mono_right (K : Subgroup G) : Monotone fun t : Subgroup N => K.prod t :=\n  prod_mono (le_refl K)\n\n"}
{"name":"Subgroup.prod_mono_right","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nK : Subgroup G\n⊢ Monotone fun t => K.prod t","decl":"@[to_additive prod_mono_right]\ntheorem prod_mono_right (K : Subgroup G) : Monotone fun t : Subgroup N => K.prod t :=\n  prod_mono (le_refl K)\n\n"}
{"name":"AddSubgroup.prod_mono_left","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH : AddSubgroup N\n⊢ Monotone fun K => K.prod H","decl":"@[to_additive prod_mono_left]\ntheorem prod_mono_left (H : Subgroup N) : Monotone fun K : Subgroup G => K.prod H := fun _ _ hs =>\n  prod_mono hs (le_refl H)\n\n"}
{"name":"Subgroup.prod_mono_left","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH : Subgroup N\n⊢ Monotone fun K => K.prod H","decl":"@[to_additive prod_mono_left]\ntheorem prod_mono_left (H : Subgroup N) : Monotone fun K : Subgroup G => K.prod H := fun _ _ hs =>\n  prod_mono hs (le_refl H)\n\n"}
{"name":"AddSubgroup.prod_top","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nK : AddSubgroup G\n⊢ Eq (K.prod Top.top) (AddSubgroup.comap (AddMonoidHom.fst G N) K)","decl":"@[to_additive prod_top]\ntheorem prod_top (K : Subgroup G) : K.prod (⊤ : Subgroup N) = K.comap (MonoidHom.fst G N) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_fst]\n\n"}
{"name":"Subgroup.prod_top","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nK : Subgroup G\n⊢ Eq (K.prod Top.top) (Subgroup.comap (MonoidHom.fst G N) K)","decl":"@[to_additive prod_top]\ntheorem prod_top (K : Subgroup G) : K.prod (⊤ : Subgroup N) = K.comap (MonoidHom.fst G N) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_fst]\n\n"}
{"name":"Subgroup.top_prod","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH : Subgroup N\n⊢ Eq (Top.top.prod H) (Subgroup.comap (MonoidHom.snd G N) H)","decl":"@[to_additive top_prod]\ntheorem top_prod (H : Subgroup N) : (⊤ : Subgroup G).prod H = H.comap (MonoidHom.snd G N) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_snd]\n\n"}
{"name":"AddSubgroup.top_prod","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH : AddSubgroup N\n⊢ Eq (Top.top.prod H) (AddSubgroup.comap (AddMonoidHom.snd G N) H)","decl":"@[to_additive top_prod]\ntheorem top_prod (H : Subgroup N) : (⊤ : Subgroup G).prod H = H.comap (MonoidHom.snd G N) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_snd]\n\n"}
{"name":"Subgroup.top_prod_top","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\n⊢ Eq (Top.top.prod Top.top) Top.top","decl":"@[to_additive (attr := simp) top_prod_top]\ntheorem top_prod_top : (⊤ : Subgroup G).prod (⊤ : Subgroup N) = ⊤ :=\n  (top_prod _).trans <| comap_top _\n\n"}
{"name":"AddSubgroup.top_prod_top","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\n⊢ Eq (Top.top.prod Top.top) Top.top","decl":"@[to_additive (attr := simp) top_prod_top]\ntheorem top_prod_top : (⊤ : Subgroup G).prod (⊤ : Subgroup N) = ⊤ :=\n  (top_prod _).trans <| comap_top _\n\n"}
{"name":"AddSubgroup.bot_sum_bot","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\n⊢ Eq (Bot.bot.prod Bot.bot) Bot.bot","decl":"@[to_additive]\ntheorem bot_prod_bot : (⊥ : Subgroup G).prod (⊥ : Subgroup N) = ⊥ :=\n  SetLike.coe_injective <| by simp [coe_prod]\n\n"}
{"name":"Subgroup.bot_prod_bot","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\n⊢ Eq (Bot.bot.prod Bot.bot) Bot.bot","decl":"@[to_additive]\ntheorem bot_prod_bot : (⊥ : Subgroup G).prod (⊥ : Subgroup N) = ⊥ :=\n  SetLike.coe_injective <| by simp [coe_prod]\n\n"}
{"name":"AddSubgroup.le_prod_iff","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH : AddSubgroup G\nK : AddSubgroup N\nJ : AddSubgroup (Prod G N)\n⊢ Iff (LE.le J (H.prod K)) (And (LE.le (AddSubgroup.map (AddMonoidHom.fst G N) J) H) (LE.le (AddSubgroup.map (AddMonoidHom.snd G N) J) K))","decl":"@[to_additive le_prod_iff]\ntheorem le_prod_iff {H : Subgroup G} {K : Subgroup N} {J : Subgroup (G × N)} :\n    J ≤ H.prod K ↔ map (MonoidHom.fst G N) J ≤ H ∧ map (MonoidHom.snd G N) J ≤ K := by\n  simpa only [← Subgroup.toSubmonoid_le] using Submonoid.le_prod_iff\n\n"}
{"name":"Subgroup.le_prod_iff","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH : Subgroup G\nK : Subgroup N\nJ : Subgroup (Prod G N)\n⊢ Iff (LE.le J (H.prod K)) (And (LE.le (Subgroup.map (MonoidHom.fst G N) J) H) (LE.le (Subgroup.map (MonoidHom.snd G N) J) K))","decl":"@[to_additive le_prod_iff]\ntheorem le_prod_iff {H : Subgroup G} {K : Subgroup N} {J : Subgroup (G × N)} :\n    J ≤ H.prod K ↔ map (MonoidHom.fst G N) J ≤ H ∧ map (MonoidHom.snd G N) J ≤ K := by\n  simpa only [← Subgroup.toSubmonoid_le] using Submonoid.le_prod_iff\n\n"}
{"name":"AddSubgroup.prod_le_iff","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH : AddSubgroup G\nK : AddSubgroup N\nJ : AddSubgroup (Prod G N)\n⊢ Iff (LE.le (H.prod K) J) (And (LE.le (AddSubgroup.map (AddMonoidHom.inl G N) H) J) (LE.le (AddSubgroup.map (AddMonoidHom.inr G N) K) J))","decl":"@[to_additive prod_le_iff]\ntheorem prod_le_iff {H : Subgroup G} {K : Subgroup N} {J : Subgroup (G × N)} :\n    H.prod K ≤ J ↔ map (MonoidHom.inl G N) H ≤ J ∧ map (MonoidHom.inr G N) K ≤ J := by\n  simpa only [← Subgroup.toSubmonoid_le] using Submonoid.prod_le_iff\n\n"}
{"name":"Subgroup.prod_le_iff","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH : Subgroup G\nK : Subgroup N\nJ : Subgroup (Prod G N)\n⊢ Iff (LE.le (H.prod K) J) (And (LE.le (Subgroup.map (MonoidHom.inl G N) H) J) (LE.le (Subgroup.map (MonoidHom.inr G N) K) J))","decl":"@[to_additive prod_le_iff]\ntheorem prod_le_iff {H : Subgroup G} {K : Subgroup N} {J : Subgroup (G × N)} :\n    H.prod K ≤ J ↔ map (MonoidHom.inl G N) H ≤ J ∧ map (MonoidHom.inr G N) K ≤ J := by\n  simpa only [← Subgroup.toSubmonoid_le] using Submonoid.prod_le_iff\n\n"}
{"name":"Subgroup.prod_eq_bot_iff","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH : Subgroup G\nK : Subgroup N\n⊢ Iff (Eq (H.prod K) Bot.bot) (And (Eq H Bot.bot) (Eq K Bot.bot))","decl":"@[to_additive (attr := simp) prod_eq_bot_iff]\ntheorem prod_eq_bot_iff {H : Subgroup G} {K : Subgroup N} : H.prod K = ⊥ ↔ H = ⊥ ∧ K = ⊥ := by\n  simpa only [← Subgroup.toSubmonoid_inj] using Submonoid.prod_eq_bot_iff\n\n"}
{"name":"AddSubgroup.prod_eq_bot_iff","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH : AddSubgroup G\nK : AddSubgroup N\n⊢ Iff (Eq (H.prod K) Bot.bot) (And (Eq H Bot.bot) (Eq K Bot.bot))","decl":"@[to_additive (attr := simp) prod_eq_bot_iff]\ntheorem prod_eq_bot_iff {H : Subgroup G} {K : Subgroup N} : H.prod K = ⊥ ↔ H = ⊥ ∧ K = ⊥ := by\n  simpa only [← Subgroup.toSubmonoid_inj] using Submonoid.prod_eq_bot_iff\n\n"}
{"name":"Subgroup.closure_prod","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\ns : Set G\nt : Set N\nhs : Membership.mem s 1\nht : Membership.mem t 1\n⊢ Eq (Subgroup.closure (SProd.sprod s t)) ((Subgroup.closure s).prod (Subgroup.closure t))","decl":"@[to_additive closure_prod]\ntheorem closure_prod {s : Set G} {t : Set N} (hs : 1 ∈ s) (ht : 1 ∈ t) :\n    closure (s ×ˢ t) = (closure s).prod (closure t) :=\n  le_antisymm\n    (closure_le _ |>.2 <| Set.prod_subset_prod_iff.2 <| .inl ⟨subset_closure, subset_closure⟩)\n    (prod_le_iff.2 ⟨\n      map_le_iff_le_comap.2 <| closure_le _ |>.2 fun _x hx => subset_closure ⟨hx, ht⟩,\n      map_le_iff_le_comap.2 <| closure_le _ |>.2 fun _y hy => subset_closure ⟨hs, hy⟩⟩)\n\n"}
{"name":"AddSubgroup.closure_prod","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\ns : Set G\nt : Set N\nhs : Membership.mem s 0\nht : Membership.mem t 0\n⊢ Eq (AddSubgroup.closure (SProd.sprod s t)) ((AddSubgroup.closure s).prod (AddSubgroup.closure t))","decl":"@[to_additive closure_prod]\ntheorem closure_prod {s : Set G} {t : Set N} (hs : 1 ∈ s) (ht : 1 ∈ t) :\n    closure (s ×ˢ t) = (closure s).prod (closure t) :=\n  le_antisymm\n    (closure_le _ |>.2 <| Set.prod_subset_prod_iff.2 <| .inl ⟨subset_closure, subset_closure⟩)\n    (prod_le_iff.2 ⟨\n      map_le_iff_le_comap.2 <| closure_le _ |>.2 fun _x hx => subset_closure ⟨hx, ht⟩,\n      map_le_iff_le_comap.2 <| closure_le _ |>.2 fun _y hy => subset_closure ⟨hs, hy⟩⟩)\n\n"}
{"name":"Subgroup.coe_pi","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"η : Type u_7\nf : η → Type u_8\ninst✝ : (i : η) → Group (f i)\nI : Set η\nH : (i : η) → Subgroup (f i)\n⊢ Eq (↑(Subgroup.pi I H)) (I.pi fun i => ↑(H i))","decl":"@[to_additive]\ntheorem coe_pi (I : Set η) (H : ∀ i, Subgroup (f i)) :\n    (pi I H : Set (∀ i, f i)) = Set.pi I fun i => (H i : Set (f i)) :=\n  rfl\n\n"}
{"name":"AddSubgroup.coe_pi","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"η : Type u_7\nf : η → Type u_8\ninst✝ : (i : η) → AddGroup (f i)\nI : Set η\nH : (i : η) → AddSubgroup (f i)\n⊢ Eq (↑(AddSubgroup.pi I H)) (I.pi fun i => ↑(H i))","decl":"@[to_additive]\ntheorem coe_pi (I : Set η) (H : ∀ i, Subgroup (f i)) :\n    (pi I H : Set (∀ i, f i)) = Set.pi I fun i => (H i : Set (f i)) :=\n  rfl\n\n"}
{"name":"Subgroup.mem_pi","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"η : Type u_7\nf : η → Type u_8\ninst✝ : (i : η) → Group (f i)\nI : Set η\nH : (i : η) → Subgroup (f i)\np : (i : η) → f i\n⊢ Iff (Membership.mem (Subgroup.pi I H) p) (∀ (i : η), Membership.mem I i → Membership.mem (H i) (p i))","decl":"@[to_additive]\ntheorem mem_pi (I : Set η) {H : ∀ i, Subgroup (f i)} {p : ∀ i, f i} :\n    p ∈ pi I H ↔ ∀ i : η, i ∈ I → p i ∈ H i :=\n  Iff.rfl\n\n"}
{"name":"AddSubgroup.mem_pi","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"η : Type u_7\nf : η → Type u_8\ninst✝ : (i : η) → AddGroup (f i)\nI : Set η\nH : (i : η) → AddSubgroup (f i)\np : (i : η) → f i\n⊢ Iff (Membership.mem (AddSubgroup.pi I H) p) (∀ (i : η), Membership.mem I i → Membership.mem (H i) (p i))","decl":"@[to_additive]\ntheorem mem_pi (I : Set η) {H : ∀ i, Subgroup (f i)} {p : ∀ i, f i} :\n    p ∈ pi I H ↔ ∀ i : η, i ∈ I → p i ∈ H i :=\n  Iff.rfl\n\n"}
{"name":"AddSubgroup.pi_top","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"η : Type u_7\nf : η → Type u_8\ninst✝ : (i : η) → AddGroup (f i)\nI : Set η\n⊢ Eq (AddSubgroup.pi I fun i => Top.top) Top.top","decl":"@[to_additive]\ntheorem pi_top (I : Set η) : (pi I fun i => (⊤ : Subgroup (f i))) = ⊤ :=\n  ext fun x => by simp [mem_pi]\n\n"}
{"name":"Subgroup.pi_top","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"η : Type u_7\nf : η → Type u_8\ninst✝ : (i : η) → Group (f i)\nI : Set η\n⊢ Eq (Subgroup.pi I fun i => Top.top) Top.top","decl":"@[to_additive]\ntheorem pi_top (I : Set η) : (pi I fun i => (⊤ : Subgroup (f i))) = ⊤ :=\n  ext fun x => by simp [mem_pi]\n\n"}
{"name":"AddSubgroup.pi_empty","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"η : Type u_7\nf : η → Type u_8\ninst✝ : (i : η) → AddGroup (f i)\nH : (i : η) → AddSubgroup (f i)\n⊢ Eq (AddSubgroup.pi EmptyCollection.emptyCollection H) Top.top","decl":"@[to_additive]\ntheorem pi_empty (H : ∀ i, Subgroup (f i)) : pi ∅ H = ⊤ :=\n  ext fun x => by simp [mem_pi]\n\n"}
{"name":"Subgroup.pi_empty","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"η : Type u_7\nf : η → Type u_8\ninst✝ : (i : η) → Group (f i)\nH : (i : η) → Subgroup (f i)\n⊢ Eq (Subgroup.pi EmptyCollection.emptyCollection H) Top.top","decl":"@[to_additive]\ntheorem pi_empty (H : ∀ i, Subgroup (f i)) : pi ∅ H = ⊤ :=\n  ext fun x => by simp [mem_pi]\n\n"}
{"name":"Subgroup.pi_bot","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"η : Type u_7\nf : η → Type u_8\ninst✝ : (i : η) → Group (f i)\n⊢ Eq (Subgroup.pi Set.univ fun i => Bot.bot) Bot.bot","decl":"@[to_additive]\ntheorem pi_bot : (pi Set.univ fun i => (⊥ : Subgroup (f i))) = ⊥ :=\n  (eq_bot_iff_forall _).mpr fun p hp => by\n    simp only [mem_pi, mem_bot] at *\n    ext j\n    exact hp j trivial\n\n"}
{"name":"AddSubgroup.pi_bot","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"η : Type u_7\nf : η → Type u_8\ninst✝ : (i : η) → AddGroup (f i)\n⊢ Eq (AddSubgroup.pi Set.univ fun i => Bot.bot) Bot.bot","decl":"@[to_additive]\ntheorem pi_bot : (pi Set.univ fun i => (⊥ : Subgroup (f i))) = ⊥ :=\n  (eq_bot_iff_forall _).mpr fun p hp => by\n    simp only [mem_pi, mem_bot] at *\n    ext j\n    exact hp j trivial\n\n"}
{"name":"Subgroup.le_pi_iff","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"η : Type u_7\nf : η → Type u_8\ninst✝ : (i : η) → Group (f i)\nI : Set η\nH : (i : η) → Subgroup (f i)\nJ : Subgroup ((i : η) → f i)\n⊢ Iff (LE.le J (Subgroup.pi I H)) (∀ (i : η), Membership.mem I i → LE.le (Subgroup.map (Pi.evalMonoidHom f i) J) (H i))","decl":"@[to_additive]\ntheorem le_pi_iff {I : Set η} {H : ∀ i, Subgroup (f i)} {J : Subgroup (∀ i, f i)} :\n    J ≤ pi I H ↔ ∀ i : η, i ∈ I → map (Pi.evalMonoidHom f i) J ≤ H i := by\n  constructor\n  · intro h i hi\n    rintro _ ⟨x, hx, rfl⟩\n    exact (h hx) _ hi\n  · intro h x hx i hi\n    exact h i hi ⟨_, hx, rfl⟩\n\n"}
{"name":"AddSubgroup.le_pi_iff","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"η : Type u_7\nf : η → Type u_8\ninst✝ : (i : η) → AddGroup (f i)\nI : Set η\nH : (i : η) → AddSubgroup (f i)\nJ : AddSubgroup ((i : η) → f i)\n⊢ Iff (LE.le J (AddSubgroup.pi I H)) (∀ (i : η), Membership.mem I i → LE.le (AddSubgroup.map (Pi.evalAddMonoidHom f i) J) (H i))","decl":"@[to_additive]\ntheorem le_pi_iff {I : Set η} {H : ∀ i, Subgroup (f i)} {J : Subgroup (∀ i, f i)} :\n    J ≤ pi I H ↔ ∀ i : η, i ∈ I → map (Pi.evalMonoidHom f i) J ≤ H i := by\n  constructor\n  · intro h i hi\n    rintro _ ⟨x, hx, rfl⟩\n    exact (h hx) _ hi\n  · intro h x hx i hi\n    exact h i hi ⟨_, hx, rfl⟩\n\n"}
{"name":"Subgroup.mulSingle_mem_pi","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"η : Type u_7\nf : η → Type u_8\ninst✝¹ : (i : η) → Group (f i)\ninst✝ : DecidableEq η\nI : Set η\nH : (i : η) → Subgroup (f i)\ni : η\nx : f i\n⊢ Iff (Membership.mem (Subgroup.pi I H) (Pi.mulSingle i x)) (Membership.mem I i → Membership.mem (H i) x)","decl":"@[to_additive (attr := simp)]\ntheorem mulSingle_mem_pi [DecidableEq η] {I : Set η} {H : ∀ i, Subgroup (f i)} (i : η) (x : f i) :\n    Pi.mulSingle i x ∈ pi I H ↔ i ∈ I → x ∈ H i := by\n  constructor\n  · intro h hi\n    simpa using h i hi\n  · intro h j hj\n    by_cases heq : j = i\n    · subst heq\n      simpa using h hj\n    · simp [heq, one_mem]\n\n"}
{"name":"AddSubgroup.single_mem_pi","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"η : Type u_7\nf : η → Type u_8\ninst✝¹ : (i : η) → AddGroup (f i)\ninst✝ : DecidableEq η\nI : Set η\nH : (i : η) → AddSubgroup (f i)\ni : η\nx : f i\n⊢ Iff (Membership.mem (AddSubgroup.pi I H) (Pi.single i x)) (Membership.mem I i → Membership.mem (H i) x)","decl":"@[to_additive (attr := simp)]\ntheorem mulSingle_mem_pi [DecidableEq η] {I : Set η} {H : ∀ i, Subgroup (f i)} (i : η) (x : f i) :\n    Pi.mulSingle i x ∈ pi I H ↔ i ∈ I → x ∈ H i := by\n  constructor\n  · intro h hi\n    simpa using h i hi\n  · intro h j hj\n    by_cases heq : j = i\n    · subst heq\n      simpa using h hj\n    · simp [heq, one_mem]\n\n"}
{"name":"AddSubgroup.pi_eq_bot_iff","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"η : Type u_7\nf : η → Type u_8\ninst✝ : (i : η) → AddGroup (f i)\nH : (i : η) → AddSubgroup (f i)\n⊢ Iff (Eq (AddSubgroup.pi Set.univ H) Bot.bot) (∀ (i : η), Eq (H i) Bot.bot)","decl":"@[to_additive]\ntheorem pi_eq_bot_iff (H : ∀ i, Subgroup (f i)) : pi Set.univ H = ⊥ ↔ ∀ i, H i = ⊥ := by\n  classical\n    simp only [eq_bot_iff_forall]\n    constructor\n    · intro h i x hx\n      have : MonoidHom.mulSingle f i x = 1 :=\n        h (MonoidHom.mulSingle f i x) ((mulSingle_mem_pi i x).mpr fun _ => hx)\n      simpa using congr_fun this i\n    · exact fun h x hx => funext fun i => h _ _ (hx i trivial)\n\n"}
{"name":"Subgroup.pi_eq_bot_iff","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"η : Type u_7\nf : η → Type u_8\ninst✝ : (i : η) → Group (f i)\nH : (i : η) → Subgroup (f i)\n⊢ Iff (Eq (Subgroup.pi Set.univ H) Bot.bot) (∀ (i : η), Eq (H i) Bot.bot)","decl":"@[to_additive]\ntheorem pi_eq_bot_iff (H : ∀ i, Subgroup (f i)) : pi Set.univ H = ⊥ ↔ ∀ i, H i = ⊥ := by\n  classical\n    simp only [eq_bot_iff_forall]\n    constructor\n    · intro h i x hx\n      have : MonoidHom.mulSingle f i x = 1 :=\n        h (MonoidHom.mulSingle f i x) ((mulSingle_mem_pi i x).mpr fun _ => hx)\n      simpa using congr_fun this i\n    · exact fun h x hx => funext fun i => h _ _ (hx i trivial)\n\n"}
{"name":"Subgroup.Characteristic.fixed","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nself : H.Characteristic\nϕ : MulEquiv G G\n⊢ Eq (Subgroup.comap ϕ.toMonoidHom H) H","decl":"/-- A subgroup is characteristic if it is fixed by all automorphisms.\n  Several equivalent conditions are provided by lemmas of the form `Characteristic.iff...` -/\nstructure Characteristic : Prop where\n  /-- `H` is fixed by all automorphisms -/\n  fixed : ∀ ϕ : G ≃* G, H.comap ϕ.toMonoidHom = H\n\n"}
{"name":"Subgroup.normal_of_characteristic","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nh : H.Characteristic\n⊢ H.Normal","decl":"instance (priority := 100) normal_of_characteristic [h : H.Characteristic] : H.Normal :=\n  ⟨fun a ha b => (SetLike.ext_iff.mp (h.fixed (MulAut.conj b)) a).mpr ha⟩\n\n"}
{"name":"AddSubgroup.Characteristic.fixed","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"A : Type u_4\ninst✝ : AddGroup A\nH : AddSubgroup A\nself : H.Characteristic\nϕ : AddEquiv A A\n⊢ Eq (AddSubgroup.comap ϕ.toAddMonoidHom H) H","decl":"/-- An `AddSubgroup` is characteristic if it is fixed by all automorphisms.\n  Several equivalent conditions are provided by lemmas of the form `Characteristic.iff...` -/\nstructure Characteristic : Prop where\n  /-- `H` is fixed by all automorphisms -/\n  fixed : ∀ ϕ : A ≃+ A, H.comap ϕ.toAddMonoidHom = H\n\n"}
{"name":"AddSubgroup.normal_of_characteristic","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"A : Type u_4\ninst✝ : AddGroup A\nH : AddSubgroup A\nh : H.Characteristic\n⊢ H.Normal","decl":"instance (priority := 100) normal_of_characteristic [h : H.Characteristic] : H.Normal :=\n  ⟨fun a ha b => (SetLike.ext_iff.mp (h.fixed (AddAut.conj b)) a).mpr ha⟩\n\n"}
{"name":"AddSubgroup.characteristic_iff_comap_eq","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff H.Characteristic (∀ (ϕ : AddEquiv G G), Eq (AddSubgroup.comap ϕ.toAddMonoidHom H) H)","decl":"@[to_additive]\ntheorem characteristic_iff_comap_eq : H.Characteristic ↔ ∀ ϕ : G ≃* G, H.comap ϕ.toMonoidHom = H :=\n  ⟨Characteristic.fixed, Characteristic.mk⟩\n\n"}
{"name":"Subgroup.characteristic_iff_comap_eq","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff H.Characteristic (∀ (ϕ : MulEquiv G G), Eq (Subgroup.comap ϕ.toMonoidHom H) H)","decl":"@[to_additive]\ntheorem characteristic_iff_comap_eq : H.Characteristic ↔ ∀ ϕ : G ≃* G, H.comap ϕ.toMonoidHom = H :=\n  ⟨Characteristic.fixed, Characteristic.mk⟩\n\n"}
{"name":"AddSubgroup.characteristic_iff_comap_le","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff H.Characteristic (∀ (ϕ : AddEquiv G G), LE.le (AddSubgroup.comap ϕ.toAddMonoidHom H) H)","decl":"@[to_additive]\ntheorem characteristic_iff_comap_le : H.Characteristic ↔ ∀ ϕ : G ≃* G, H.comap ϕ.toMonoidHom ≤ H :=\n  characteristic_iff_comap_eq.trans\n    ⟨fun h ϕ => le_of_eq (h ϕ), fun h ϕ =>\n      le_antisymm (h ϕ) fun g hg => h ϕ.symm ((congr_arg (· ∈ H) (ϕ.symm_apply_apply g)).mpr hg)⟩\n\n"}
{"name":"Subgroup.characteristic_iff_comap_le","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff H.Characteristic (∀ (ϕ : MulEquiv G G), LE.le (Subgroup.comap ϕ.toMonoidHom H) H)","decl":"@[to_additive]\ntheorem characteristic_iff_comap_le : H.Characteristic ↔ ∀ ϕ : G ≃* G, H.comap ϕ.toMonoidHom ≤ H :=\n  characteristic_iff_comap_eq.trans\n    ⟨fun h ϕ => le_of_eq (h ϕ), fun h ϕ =>\n      le_antisymm (h ϕ) fun g hg => h ϕ.symm ((congr_arg (· ∈ H) (ϕ.symm_apply_apply g)).mpr hg)⟩\n\n"}
{"name":"AddSubgroup.characteristic_iff_le_comap","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff H.Characteristic (∀ (ϕ : AddEquiv G G), LE.le H (AddSubgroup.comap ϕ.toAddMonoidHom H))","decl":"@[to_additive]\ntheorem characteristic_iff_le_comap : H.Characteristic ↔ ∀ ϕ : G ≃* G, H ≤ H.comap ϕ.toMonoidHom :=\n  characteristic_iff_comap_eq.trans\n    ⟨fun h ϕ => ge_of_eq (h ϕ), fun h ϕ =>\n      le_antisymm (fun g hg => (congr_arg (· ∈ H) (ϕ.symm_apply_apply g)).mp (h ϕ.symm hg)) (h ϕ)⟩\n\n"}
{"name":"Subgroup.characteristic_iff_le_comap","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff H.Characteristic (∀ (ϕ : MulEquiv G G), LE.le H (Subgroup.comap ϕ.toMonoidHom H))","decl":"@[to_additive]\ntheorem characteristic_iff_le_comap : H.Characteristic ↔ ∀ ϕ : G ≃* G, H ≤ H.comap ϕ.toMonoidHom :=\n  characteristic_iff_comap_eq.trans\n    ⟨fun h ϕ => ge_of_eq (h ϕ), fun h ϕ =>\n      le_antisymm (fun g hg => (congr_arg (· ∈ H) (ϕ.symm_apply_apply g)).mp (h ϕ.symm hg)) (h ϕ)⟩\n\n"}
{"name":"Subgroup.characteristic_iff_map_eq","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff H.Characteristic (∀ (ϕ : MulEquiv G G), Eq (Subgroup.map ϕ.toMonoidHom H) H)","decl":"@[to_additive]\ntheorem characteristic_iff_map_eq : H.Characteristic ↔ ∀ ϕ : G ≃* G, H.map ϕ.toMonoidHom = H := by\n  simp_rw [map_equiv_eq_comap_symm']\n  exact characteristic_iff_comap_eq.trans ⟨fun h ϕ => h ϕ.symm, fun h ϕ => h ϕ.symm⟩\n\n"}
{"name":"AddSubgroup.characteristic_iff_map_eq","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff H.Characteristic (∀ (ϕ : AddEquiv G G), Eq (AddSubgroup.map ϕ.toAddMonoidHom H) H)","decl":"@[to_additive]\ntheorem characteristic_iff_map_eq : H.Characteristic ↔ ∀ ϕ : G ≃* G, H.map ϕ.toMonoidHom = H := by\n  simp_rw [map_equiv_eq_comap_symm']\n  exact characteristic_iff_comap_eq.trans ⟨fun h ϕ => h ϕ.symm, fun h ϕ => h ϕ.symm⟩\n\n"}
{"name":"Subgroup.characteristic_iff_map_le","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff H.Characteristic (∀ (ϕ : MulEquiv G G), LE.le (Subgroup.map ϕ.toMonoidHom H) H)","decl":"@[to_additive]\ntheorem characteristic_iff_map_le : H.Characteristic ↔ ∀ ϕ : G ≃* G, H.map ϕ.toMonoidHom ≤ H := by\n  simp_rw [map_equiv_eq_comap_symm']\n  exact characteristic_iff_comap_le.trans ⟨fun h ϕ => h ϕ.symm, fun h ϕ => h ϕ.symm⟩\n\n"}
{"name":"AddSubgroup.characteristic_iff_map_le","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff H.Characteristic (∀ (ϕ : AddEquiv G G), LE.le (AddSubgroup.map ϕ.toAddMonoidHom H) H)","decl":"@[to_additive]\ntheorem characteristic_iff_map_le : H.Characteristic ↔ ∀ ϕ : G ≃* G, H.map ϕ.toMonoidHom ≤ H := by\n  simp_rw [map_equiv_eq_comap_symm']\n  exact characteristic_iff_comap_le.trans ⟨fun h ϕ => h ϕ.symm, fun h ϕ => h ϕ.symm⟩\n\n"}
{"name":"AddSubgroup.characteristic_iff_le_map","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff H.Characteristic (∀ (ϕ : AddEquiv G G), LE.le H (AddSubgroup.map ϕ.toAddMonoidHom H))","decl":"@[to_additive]\ntheorem characteristic_iff_le_map : H.Characteristic ↔ ∀ ϕ : G ≃* G, H ≤ H.map ϕ.toMonoidHom := by\n  simp_rw [map_equiv_eq_comap_symm']\n  exact characteristic_iff_le_comap.trans ⟨fun h ϕ => h ϕ.symm, fun h ϕ => h ϕ.symm⟩\n\n"}
{"name":"Subgroup.characteristic_iff_le_map","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff H.Characteristic (∀ (ϕ : MulEquiv G G), LE.le H (Subgroup.map ϕ.toMonoidHom H))","decl":"@[to_additive]\ntheorem characteristic_iff_le_map : H.Characteristic ↔ ∀ ϕ : G ≃* G, H ≤ H.map ϕ.toMonoidHom := by\n  simp_rw [map_equiv_eq_comap_symm']\n  exact characteristic_iff_le_comap.trans ⟨fun h ϕ => h ϕ.symm, fun h ϕ => h ϕ.symm⟩\n\n"}
{"name":"Subgroup.botCharacteristic","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Bot.bot.Characteristic","decl":"@[to_additive]\ninstance botCharacteristic : Characteristic (⊥ : Subgroup G) :=\n  characteristic_iff_le_map.mpr fun _ϕ => bot_le\n\n"}
{"name":"AddSubgroup.botCharacteristic","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Bot.bot.Characteristic","decl":"@[to_additive]\ninstance botCharacteristic : Characteristic (⊥ : Subgroup G) :=\n  characteristic_iff_le_map.mpr fun _ϕ => bot_le\n\n"}
{"name":"AddSubgroup.topCharacteristic","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Top.top.Characteristic","decl":"@[to_additive]\ninstance topCharacteristic : Characteristic (⊤ : Subgroup G) :=\n  characteristic_iff_map_le.mpr fun _ϕ => le_top\n\n\n"}
{"name":"Subgroup.topCharacteristic","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Top.top.Characteristic","decl":"@[to_additive]\ninstance topCharacteristic : Characteristic (⊤ : Subgroup G) :=\n  characteristic_iff_map_le.mpr fun _ϕ => le_top\n\n\n"}
{"name":"AddSubgroup.normal_in_normalizer","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ (H.addSubgroupOf H.normalizer).Normal","decl":"@[to_additive]\ninstance (priority := 100) normal_in_normalizer : (H.subgroupOf H.normalizer).Normal :=\n  ⟨fun x xH g => by simpa only [mem_subgroupOf] using (g.2 x.1).1 xH⟩\n\n"}
{"name":"Subgroup.normal_in_normalizer","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ (H.subgroupOf H.normalizer).Normal","decl":"@[to_additive]\ninstance (priority := 100) normal_in_normalizer : (H.subgroupOf H.normalizer).Normal :=\n  ⟨fun x xH g => by simpa only [mem_subgroupOf] using (g.2 x.1).1 xH⟩\n\n"}
{"name":"AddSubgroup.normalizer_eq_top_iff","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\n⊢ Iff (Eq H.normalizer Top.top) H.Normal","decl":"@[to_additive]\ntheorem normalizer_eq_top_iff : H.normalizer = ⊤ ↔ H.Normal :=\n  eq_top_iff.trans\n    ⟨fun h => ⟨fun a ha b => (h (mem_top b) a).mp ha⟩, fun h a _ha b =>\n      ⟨fun hb => h.conj_mem b hb a, fun hb => by rwa [h.mem_comm_iff, inv_mul_cancel_left] at hb⟩⟩\n\n"}
{"name":"Subgroup.normalizer_eq_top_iff","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Iff (Eq H.normalizer Top.top) H.Normal","decl":"@[to_additive]\ntheorem normalizer_eq_top_iff : H.normalizer = ⊤ ↔ H.Normal :=\n  eq_top_iff.trans\n    ⟨fun h => ⟨fun a ha b => (h (mem_top b) a).mp ha⟩, fun h a _ha b =>\n      ⟨fun hb => h.conj_mem b hb a, fun hb => by rwa [h.mem_comm_iff, inv_mul_cancel_left] at hb⟩⟩\n\n"}
{"name":"AddSubgroup.normalizer_eq_top","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nh : H.Normal\n⊢ Eq H.normalizer Top.top","decl":"variable (H) in\n@[to_additive]\ntheorem normalizer_eq_top [h : H.Normal] : H.normalizer = ⊤ :=\n  normalizer_eq_top_iff.mpr h\n\n"}
{"name":"Subgroup.normalizer_eq_top","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nh : H.Normal\n⊢ Eq H.normalizer Top.top","decl":"variable (H) in\n@[to_additive]\ntheorem normalizer_eq_top [h : H.Normal] : H.normalizer = ⊤ :=\n  normalizer_eq_top_iff.mpr h\n\n"}
{"name":"AddSubgroup.le_normalizer_of_normal","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nhK : (H.addSubgroupOf K).Normal\nHK : LE.le H K\n⊢ LE.le K H.normalizer","decl":"@[to_additive]\ntheorem le_normalizer_of_normal [hK : (H.subgroupOf K).Normal] (HK : H ≤ K) : K ≤ H.normalizer :=\n  fun x hx y =>\n  ⟨fun yH => hK.conj_mem ⟨y, HK yH⟩ yH ⟨x, hx⟩, fun yH => by\n    simpa [mem_subgroupOf, mul_assoc] using\n      hK.conj_mem ⟨x * y * x⁻¹, HK yH⟩ yH ⟨x⁻¹, K.inv_mem hx⟩⟩\n\n"}
{"name":"Subgroup.le_normalizer_of_normal","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nhK : (H.subgroupOf K).Normal\nHK : LE.le H K\n⊢ LE.le K H.normalizer","decl":"@[to_additive]\ntheorem le_normalizer_of_normal [hK : (H.subgroupOf K).Normal] (HK : H ≤ K) : K ≤ H.normalizer :=\n  fun x hx y =>\n  ⟨fun yH => hK.conj_mem ⟨y, HK yH⟩ yH ⟨x, hx⟩, fun yH => by\n    simpa [mem_subgroupOf, mul_assoc] using\n      hK.conj_mem ⟨x * y * x⁻¹, HK yH⟩ yH ⟨x⁻¹, K.inv_mem hx⟩⟩\n\n"}
{"name":"Subgroup.le_normalizer_comap","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom N G\n⊢ LE.le (Subgroup.comap f H.normalizer) (Subgroup.comap f H).normalizer","decl":"/-- The preimage of the normalizer is contained in the normalizer of the preimage. -/\n@[to_additive \"The preimage of the normalizer is contained in the normalizer of the preimage.\"]\ntheorem le_normalizer_comap (f : N →* G) :\n    H.normalizer.comap f ≤ (H.comap f).normalizer := fun x => by\n  simp only [mem_normalizer_iff, mem_comap]\n  intro h n\n  simp [h (f n)]\n\n"}
{"name":"AddSubgroup.le_normalizer_comap","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH : AddSubgroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom N G\n⊢ LE.le (AddSubgroup.comap f H.normalizer) (AddSubgroup.comap f H).normalizer","decl":"/-- The preimage of the normalizer is contained in the normalizer of the preimage. -/\n@[to_additive \"The preimage of the normalizer is contained in the normalizer of the preimage.\"]\ntheorem le_normalizer_comap (f : N →* G) :\n    H.normalizer.comap f ≤ (H.comap f).normalizer := fun x => by\n  simp only [mem_normalizer_iff, mem_comap]\n  intro h n\n  simp [h (f n)]\n\n"}
{"name":"AddSubgroup.le_normalizer_map","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH : AddSubgroup G\nN : Type u_5\ninst✝ : AddGroup N\nf : AddMonoidHom G N\n⊢ LE.le (AddSubgroup.map f H.normalizer) (AddSubgroup.map f H).normalizer","decl":"/-- The image of the normalizer is contained in the normalizer of the image. -/\n@[to_additive \"The image of the normalizer is contained in the normalizer of the image.\"]\ntheorem le_normalizer_map (f : G →* N) : H.normalizer.map f ≤ (H.map f).normalizer := fun _ => by\n  simp only [and_imp, exists_prop, mem_map, exists_imp, mem_normalizer_iff]\n  rintro x hx rfl n\n  constructor\n  · rintro ⟨y, hy, rfl⟩\n    use x * y * x⁻¹, (hx y).1 hy\n    simp\n  · rintro ⟨y, hyH, hy⟩\n    use x⁻¹ * y * x\n    rw [hx]\n    simp [hy, hyH, mul_assoc]\n\n"}
{"name":"Subgroup.le_normalizer_map","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\nN : Type u_5\ninst✝ : Group N\nf : MonoidHom G N\n⊢ LE.le (Subgroup.map f H.normalizer) (Subgroup.map f H).normalizer","decl":"/-- The image of the normalizer is contained in the normalizer of the image. -/\n@[to_additive \"The image of the normalizer is contained in the normalizer of the image.\"]\ntheorem le_normalizer_map (f : G →* N) : H.normalizer.map f ≤ (H.map f).normalizer := fun _ => by\n  simp only [and_imp, exists_prop, mem_map, exists_imp, mem_normalizer_iff]\n  rintro x hx rfl n\n  constructor\n  · rintro ⟨y, hy, rfl⟩\n    use x * y * x⁻¹, (hx y).1 hy\n    simp\n  · rintro ⟨y, hyH, hy⟩\n    use x⁻¹ * y * x\n    rw [hx]\n    simp [hy, hyH, mul_assoc]\n\n"}
{"name":"normalizerCondition_iff_only_full_group_self_normalizing","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\n⊢ Iff (NormalizerCondition G) (∀ (H : Subgroup G), Eq H.normalizer H → Eq H Top.top)","decl":"/-- Alternative phrasing of the normalizer condition: Only the full group is self-normalizing.\nThis may be easier to work with, as it avoids inequalities and negations. -/\ntheorem _root_.normalizerCondition_iff_only_full_group_self_normalizing :\n    NormalizerCondition G ↔ ∀ H : Subgroup G, H.normalizer = H → H = ⊤ := by\n  apply forall_congr'; intro H\n  simp only [lt_iff_le_and_ne, le_normalizer, le_top, Ne]\n  tauto\n\n"}
{"name":"Group.mem_conjugatesOfSet_iff","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ns : Set G\nx : G\n⊢ Iff (Membership.mem (Group.conjugatesOfSet s) x) (Exists fun a => And (Membership.mem s a) (IsConj a x))","decl":"theorem mem_conjugatesOfSet_iff {x : G} : x ∈ conjugatesOfSet s ↔ ∃ a ∈ s, IsConj a x := by\n  rw [conjugatesOfSet, Set.mem_iUnion₂]\n  simp only [conjugatesOf, isConj_iff, Set.mem_setOf_eq, exists_prop]\n\n"}
{"name":"Group.subset_conjugatesOfSet","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ns : Set G\n⊢ HasSubset.Subset s (Group.conjugatesOfSet s)","decl":"theorem subset_conjugatesOfSet : s ⊆ conjugatesOfSet s := fun (x : G) (h : x ∈ s) =>\n  mem_conjugatesOfSet_iff.2 ⟨x, h, IsConj.refl _⟩\n\n"}
{"name":"Group.conjugatesOfSet_mono","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ns t : Set G\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (Group.conjugatesOfSet s) (Group.conjugatesOfSet t)","decl":"theorem conjugatesOfSet_mono {s t : Set G} (h : s ⊆ t) : conjugatesOfSet s ⊆ conjugatesOfSet t :=\n  Set.biUnion_subset_biUnion_left h\n\n"}
{"name":"Group.conjugates_subset_normal","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nN : Subgroup G\ntn : N.Normal\na : G\nh : Membership.mem N a\n⊢ HasSubset.Subset (conjugatesOf a) ↑N","decl":"theorem conjugates_subset_normal {N : Subgroup G} [tn : N.Normal] {a : G} (h : a ∈ N) :\n    conjugatesOf a ⊆ N := by\n  rintro a hc\n  obtain ⟨c, rfl⟩ := isConj_iff.1 hc\n  exact tn.conj_mem a h c\n\n"}
{"name":"Group.conjugatesOfSet_subset","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ns : Set G\nN : Subgroup G\ninst✝ : N.Normal\nh : HasSubset.Subset s ↑N\n⊢ HasSubset.Subset (Group.conjugatesOfSet s) ↑N","decl":"theorem conjugatesOfSet_subset {s : Set G} {N : Subgroup G} [N.Normal] (h : s ⊆ N) :\n    conjugatesOfSet s ⊆ N :=\n  Set.iUnion₂_subset fun _x H => conjugates_subset_normal (h H)\n\n"}
{"name":"Group.conj_mem_conjugatesOfSet","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ns : Set G\nx c : G\na✝ : Membership.mem (Group.conjugatesOfSet s) x\n⊢ Membership.mem (Group.conjugatesOfSet s) (HMul.hMul (HMul.hMul c x) (Inv.inv c))","decl":"/-- The set of conjugates of `s` is closed under conjugation. -/\ntheorem conj_mem_conjugatesOfSet {x c : G} :\n    x ∈ conjugatesOfSet s → c * x * c⁻¹ ∈ conjugatesOfSet s := fun H => by\n  rcases mem_conjugatesOfSet_iff.1 H with ⟨a, h₁, h₂⟩\n  exact mem_conjugatesOfSet_iff.2 ⟨a, h₁, h₂.trans (isConj_iff.2 ⟨c, rfl⟩)⟩\n\n"}
{"name":"Subgroup.conjugatesOfSet_subset_normalClosure","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ns : Set G\n⊢ HasSubset.Subset (Group.conjugatesOfSet s) ↑(Subgroup.normalClosure s)","decl":"theorem conjugatesOfSet_subset_normalClosure : conjugatesOfSet s ⊆ normalClosure s :=\n  subset_closure\n\n"}
{"name":"Subgroup.subset_normalClosure","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ns : Set G\n⊢ HasSubset.Subset s ↑(Subgroup.normalClosure s)","decl":"theorem subset_normalClosure : s ⊆ normalClosure s :=\n  Set.Subset.trans subset_conjugatesOfSet conjugatesOfSet_subset_normalClosure\n\n"}
{"name":"Subgroup.le_normalClosure","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ LE.le H (Subgroup.normalClosure ↑H)","decl":"theorem le_normalClosure {H : Subgroup G} : H ≤ normalClosure ↑H := fun _ h =>\n  subset_normalClosure h\n\n"}
{"name":"Subgroup.normalClosure_normal","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ns : Set G\n⊢ (Subgroup.normalClosure s).Normal","decl":"/-- The normal closure of `s` is a normal subgroup. -/\ninstance normalClosure_normal : (normalClosure s).Normal :=\n  ⟨fun n h g => by\n    refine Subgroup.closure_induction (fun x hx => ?_) ?_ (fun x y _ _ ihx ihy => ?_)\n      (fun x _ ihx => ?_) h\n    · exact conjugatesOfSet_subset_normalClosure (conj_mem_conjugatesOfSet hx)\n    · simpa using (normalClosure s).one_mem\n    · rw [← conj_mul]\n      exact mul_mem ihx ihy\n    · rw [← conj_inv]\n      exact inv_mem ihx⟩\n\n"}
{"name":"Subgroup.normalClosure_le_normal","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ns : Set G\nN : Subgroup G\ninst✝ : N.Normal\nh : HasSubset.Subset s ↑N\n⊢ LE.le (Subgroup.normalClosure s) N","decl":"/-- The normal closure of `s` is the smallest normal subgroup containing `s`. -/\ntheorem normalClosure_le_normal {N : Subgroup G} [N.Normal] (h : s ⊆ N) : normalClosure s ≤ N := by\n  intro a w\n  refine closure_induction (fun x hx => ?_) ?_ (fun x y _ _ ihx ihy => ?_) (fun x _ ihx => ?_) w\n  · exact conjugatesOfSet_subset h hx\n  · exact one_mem _\n  · exact mul_mem ihx ihy\n  · exact inv_mem ihx\n\n"}
{"name":"Subgroup.normalClosure_subset_iff","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ns : Set G\nN : Subgroup G\ninst✝ : N.Normal\n⊢ Iff (HasSubset.Subset s ↑N) (LE.le (Subgroup.normalClosure s) N)","decl":"theorem normalClosure_subset_iff {N : Subgroup G} [N.Normal] : s ⊆ N ↔ normalClosure s ≤ N :=\n  ⟨normalClosure_le_normal, Set.Subset.trans subset_normalClosure⟩\n\n"}
{"name":"Subgroup.normalClosure_mono","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ns t : Set G\nh : HasSubset.Subset s t\n⊢ LE.le (Subgroup.normalClosure s) (Subgroup.normalClosure t)","decl":"@[gcongr]\ntheorem normalClosure_mono {s t : Set G} (h : s ⊆ t) : normalClosure s ≤ normalClosure t :=\n  normalClosure_le_normal (Set.Subset.trans h subset_normalClosure)\n\n"}
{"name":"Subgroup.normalClosure_eq_iInf","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ns : Set G\n⊢ Eq (Subgroup.normalClosure s) (iInf fun N => iInf fun x => iInf fun x => N)","decl":"theorem normalClosure_eq_iInf :\n    normalClosure s = ⨅ (N : Subgroup G) (_ : Normal N) (_ : s ⊆ N), N :=\n  le_antisymm (le_iInf fun _ => le_iInf fun _ => le_iInf normalClosure_le_normal)\n    (iInf_le_of_le (normalClosure s)\n      (iInf_le_of_le (by infer_instance) (iInf_le_of_le subset_normalClosure le_rfl)))\n\n"}
{"name":"Subgroup.normalClosure_eq_self","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : H.Normal\n⊢ Eq (Subgroup.normalClosure ↑H) H","decl":"@[simp]\ntheorem normalClosure_eq_self (H : Subgroup G) [H.Normal] : normalClosure ↑H = H :=\n  le_antisymm (normalClosure_le_normal rfl.subset) le_normalClosure\n\n"}
{"name":"Subgroup.normalClosure_idempotent","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ns : Set G\n⊢ Eq (Subgroup.normalClosure ↑(Subgroup.normalClosure s)) (Subgroup.normalClosure s)","decl":"theorem normalClosure_idempotent : normalClosure ↑(normalClosure s) = normalClosure s :=\n  normalClosure_eq_self _\n\n"}
{"name":"Subgroup.closure_le_normalClosure","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ns : Set G\n⊢ LE.le (Subgroup.closure s) (Subgroup.normalClosure s)","decl":"theorem closure_le_normalClosure {s : Set G} : closure s ≤ normalClosure s := by\n  simp only [subset_normalClosure, closure_le]\n\n"}
{"name":"Subgroup.normalClosure_closure_eq_normalClosure","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\ns : Set G\n⊢ Eq (Subgroup.normalClosure ↑(Subgroup.closure s)) (Subgroup.normalClosure s)","decl":"@[simp]\ntheorem normalClosure_closure_eq_normalClosure {s : Set G} :\n    normalClosure ↑(closure s) = normalClosure s :=\n  le_antisymm (normalClosure_le_normal closure_le_normalClosure) (normalClosure_mono subset_closure)\n\n"}
{"name":"Subgroup.normalCore_le","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ LE.le H.normalCore H","decl":"theorem normalCore_le (H : Subgroup G) : H.normalCore ≤ H := fun a h => by\n  rw [← mul_one a, ← inv_one, ← one_mul a]\n  exact h 1\n\n"}
{"name":"Subgroup.normalCore_normal","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ H.normalCore.Normal","decl":"instance normalCore_normal (H : Subgroup G) : H.normalCore.Normal :=\n  ⟨fun a h b c => by\n    rw [mul_assoc, mul_assoc, ← mul_inv_rev, ← mul_assoc, ← mul_assoc]; exact h (c * b)⟩\n\n"}
{"name":"Subgroup.normal_le_normalCore","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH N : Subgroup G\nhN : N.Normal\n⊢ Iff (LE.le N H.normalCore) (LE.le N H)","decl":"theorem normal_le_normalCore {H : Subgroup G} {N : Subgroup G} [hN : N.Normal] :\n    N ≤ H.normalCore ↔ N ≤ H :=\n  ⟨ge_trans H.normalCore_le, fun h_le n hn g => h_le (hN.conj_mem n hn g)⟩\n\n"}
{"name":"Subgroup.normalCore_mono","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nh : LE.le H K\n⊢ LE.le H.normalCore K.normalCore","decl":"theorem normalCore_mono {H K : Subgroup G} (h : H ≤ K) : H.normalCore ≤ K.normalCore :=\n  normal_le_normalCore.mpr (H.normalCore_le.trans h)\n\n"}
{"name":"Subgroup.normalCore_eq_iSup","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq H.normalCore (iSup fun N => iSup fun x => iSup fun x => N)","decl":"theorem normalCore_eq_iSup (H : Subgroup G) :\n    H.normalCore = ⨆ (N : Subgroup G) (_ : Normal N) (_ : N ≤ H), N :=\n  le_antisymm\n    (le_iSup_of_le H.normalCore\n      (le_iSup_of_le H.normalCore_normal (le_iSup_of_le H.normalCore_le le_rfl)))\n    (iSup_le fun _ => iSup_le fun _ => iSup_le normal_le_normalCore.mpr)\n\n"}
{"name":"Subgroup.normalCore_eq_self","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Subgroup G\ninst✝ : H.Normal\n⊢ Eq H.normalCore H","decl":"@[simp]\ntheorem normalCore_eq_self (H : Subgroup G) [H.Normal] : H.normalCore = H :=\n  le_antisymm H.normalCore_le (normal_le_normalCore.mpr le_rfl)\n\n"}
{"name":"Subgroup.normalCore_idempotent","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\n⊢ Eq H.normalCore.normalCore H.normalCore","decl":"theorem normalCore_idempotent (H : Subgroup G) : H.normalCore.normalCore = H.normalCore :=\n  H.normalCore.normalCore_eq_self\n\n"}
{"name":"AddMonoidHom.sumMap_comap_sum","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\nN : Type u_5\ninst✝² : AddGroup N\nG' : Type u_8\nN' : Type u_9\ninst✝¹ : AddGroup G'\ninst✝ : AddGroup N'\nf : AddMonoidHom G N\ng : AddMonoidHom G' N'\nS : AddSubgroup N\nS' : AddSubgroup N'\n⊢ Eq (AddSubgroup.comap (f.prodMap g) (S.prod S')) ((AddSubgroup.comap f S).prod (AddSubgroup.comap g S'))","decl":"@[to_additive]\ntheorem prodMap_comap_prod {G' : Type*} {N' : Type*} [Group G'] [Group N'] (f : G →* N)\n    (g : G' →* N') (S : Subgroup N) (S' : Subgroup N') :\n    (S.prod S').comap (prodMap f g) = (S.comap f).prod (S'.comap g) :=\n  SetLike.coe_injective <| Set.preimage_prod_map_prod f g _ _\n\n"}
{"name":"MonoidHom.prodMap_comap_prod","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝³ : Group G\nN : Type u_5\ninst✝² : Group N\nG' : Type u_8\nN' : Type u_9\ninst✝¹ : Group G'\ninst✝ : Group N'\nf : MonoidHom G N\ng : MonoidHom G' N'\nS : Subgroup N\nS' : Subgroup N'\n⊢ Eq (Subgroup.comap (f.prodMap g) (S.prod S')) ((Subgroup.comap f S).prod (Subgroup.comap g S'))","decl":"@[to_additive]\ntheorem prodMap_comap_prod {G' : Type*} {N' : Type*} [Group G'] [Group N'] (f : G →* N)\n    (g : G' →* N') (S : Subgroup N) (S' : Subgroup N') :\n    (S.prod S').comap (prodMap f g) = (S.comap f).prod (S'.comap g) :=\n  SetLike.coe_injective <| Set.preimage_prod_map_prod f g _ _\n\n"}
{"name":"AddMonoidHom.ker_sumMap","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\nN : Type u_5\ninst✝² : AddGroup N\nG' : Type u_8\nN' : Type u_9\ninst✝¹ : AddGroup G'\ninst✝ : AddGroup N'\nf : AddMonoidHom G N\ng : AddMonoidHom G' N'\n⊢ Eq (f.prodMap g).ker (f.ker.prod g.ker)","decl":"@[to_additive]\ntheorem ker_prodMap {G' : Type*} {N' : Type*} [Group G'] [Group N'] (f : G →* N) (g : G' →* N') :\n    (prodMap f g).ker = f.ker.prod g.ker := by\n  rw [← comap_bot, ← comap_bot, ← comap_bot, ← prodMap_comap_prod, bot_prod_bot]\n\n"}
{"name":"MonoidHom.ker_prodMap","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝³ : Group G\nN : Type u_5\ninst✝² : Group N\nG' : Type u_8\nN' : Type u_9\ninst✝¹ : Group G'\ninst✝ : Group N'\nf : MonoidHom G N\ng : MonoidHom G' N'\n⊢ Eq (f.prodMap g).ker (f.ker.prod g.ker)","decl":"@[to_additive]\ntheorem ker_prodMap {G' : Type*} {N' : Type*} [Group G'] [Group N'] (f : G →* N) (g : G' →* N') :\n    (prodMap f g).ker = f.ker.prod g.ker := by\n  rw [← comap_bot, ← comap_bot, ← comap_bot, ← prodMap_comap_prod, bot_prod_bot]\n\n"}
{"name":"MonoidHom.ker_fst","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\n⊢ Eq (MonoidHom.fst G G').ker (Bot.bot.prod Top.top)","decl":"@[to_additive (attr := simp)]\nlemma ker_fst : ker (fst G G') = .prod ⊥ ⊤ := SetLike.ext fun _ => (iff_of_eq (and_true _)).symm\n\n"}
{"name":"AddMonoidHom.ker_fst","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\n⊢ Eq (AddMonoidHom.fst G G').ker (Bot.bot.prod Top.top)","decl":"@[to_additive (attr := simp)]\nlemma ker_fst : ker (fst G G') = .prod ⊥ ⊤ := SetLike.ext fun _ => (iff_of_eq (and_true _)).symm\n\n"}
{"name":"MonoidHom.ker_snd","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : Group G\ninst✝ : Group G'\n⊢ Eq (MonoidHom.snd G G').ker (Top.top.prod Bot.bot)","decl":"@[to_additive (attr := simp)]\nlemma ker_snd : ker (snd G G') = .prod ⊤ ⊥ := SetLike.ext fun _ => (iff_of_eq (true_and _)).symm\n\n"}
{"name":"AddMonoidHom.ker_snd","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup G'\n⊢ Eq (AddMonoidHom.snd G G').ker (Top.top.prod Bot.bot)","decl":"@[to_additive (attr := simp)]\nlemma ker_snd : ker (snd G G') = .prod ⊤ ⊥ := SetLike.ext fun _ => (iff_of_eq (true_and _)).symm\n\n"}
{"name":"AddSubgroup.Normal.map","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH : AddSubgroup G\nh : H.Normal\nf : AddMonoidHom G N\nhf : Function.Surjective ⇑f\n⊢ (AddSubgroup.map f H).Normal","decl":"@[to_additive]\ntheorem Normal.map {H : Subgroup G} (h : H.Normal) (f : G →* N) (hf : Function.Surjective f) :\n    (H.map f).Normal := by\n  rw [← normalizer_eq_top_iff, ← top_le_iff, ← f.range_eq_top_of_surjective hf, f.range_eq_map,\n    ← H.normalizer_eq_top]\n  exact le_normalizer_map _\n\n"}
{"name":"Subgroup.Normal.map","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH : Subgroup G\nh : H.Normal\nf : MonoidHom G N\nhf : Function.Surjective ⇑f\n⊢ (Subgroup.map f H).Normal","decl":"@[to_additive]\ntheorem Normal.map {H : Subgroup G} (h : H.Normal) (f : G →* N) (hf : Function.Surjective f) :\n    (H.map f).Normal := by\n  rw [← normalizer_eq_top_iff, ← top_le_iff, ← f.range_eq_top_of_surjective hf, f.range_eq_map,\n    ← H.normalizer_eq_top]\n  exact le_normalizer_map _\n\n"}
{"name":"AddSubgroup.comap_normalizer_eq_of_surjective","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH : AddSubgroup G\nf : AddMonoidHom N G\nhf : Function.Surjective ⇑f\n⊢ Eq (AddSubgroup.comap f H.normalizer) (AddSubgroup.comap f H).normalizer","decl":"/-- The preimage of the normalizer is equal to the normalizer of the preimage of a surjective\n  function. -/\n@[to_additive\n      \"The preimage of the normalizer is equal to the normalizer of the preimage of\n      a surjective function.\"]\ntheorem comap_normalizer_eq_of_surjective (H : Subgroup G) {f : N →* G}\n    (hf : Function.Surjective f) : H.normalizer.comap f = (H.comap f).normalizer :=\n  le_antisymm (le_normalizer_comap f)\n    (by\n      intro x hx\n      simp only [mem_comap, mem_normalizer_iff] at *\n      intro n\n      rcases hf n with ⟨y, rfl⟩\n      simp [hx y])\n\n"}
{"name":"Subgroup.comap_normalizer_eq_of_surjective","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH : Subgroup G\nf : MonoidHom N G\nhf : Function.Surjective ⇑f\n⊢ Eq (Subgroup.comap f H.normalizer) (Subgroup.comap f H).normalizer","decl":"/-- The preimage of the normalizer is equal to the normalizer of the preimage of a surjective\n  function. -/\n@[to_additive\n      \"The preimage of the normalizer is equal to the normalizer of the preimage of\n      a surjective function.\"]\ntheorem comap_normalizer_eq_of_surjective (H : Subgroup G) {f : N →* G}\n    (hf : Function.Surjective f) : H.normalizer.comap f = (H.comap f).normalizer :=\n  le_antisymm (le_normalizer_comap f)\n    (by\n      intro x hx\n      simp only [mem_comap, mem_normalizer_iff] at *\n      intro n\n      rcases hf n with ⟨y, rfl⟩\n      simp [hx y])\n\n"}
{"name":"AddSubgroup.comap_normalizer_eq_of_injective_of_le_range","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_6\ninst✝ : AddGroup N\nH : AddSubgroup G\nf : AddMonoidHom N G\nhf : Function.Injective ⇑f\nh : LE.le H.normalizer f.range\n⊢ Eq (AddSubgroup.comap f H.normalizer) (AddSubgroup.comap f H).normalizer","decl":"@[to_additive]\ntheorem comap_normalizer_eq_of_injective_of_le_range {N : Type*} [Group N] (H : Subgroup G)\n    {f : N →* G} (hf : Function.Injective f) (h : H.normalizer ≤ f.range) :\n    comap f H.normalizer = (comap f H).normalizer := by\n  apply Subgroup.map_injective hf\n  rw [map_comap_eq_self h]\n  apply le_antisymm\n  · refine le_trans (le_of_eq ?_) (map_mono (le_normalizer_comap _))\n    rw [map_comap_eq_self h]\n  · refine le_trans (le_normalizer_map f) (le_of_eq ?_)\n    rw [map_comap_eq_self (le_trans le_normalizer h)]\n\n"}
{"name":"Subgroup.comap_normalizer_eq_of_injective_of_le_range","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_6\ninst✝ : Group N\nH : Subgroup G\nf : MonoidHom N G\nhf : Function.Injective ⇑f\nh : LE.le H.normalizer f.range\n⊢ Eq (Subgroup.comap f H.normalizer) (Subgroup.comap f H).normalizer","decl":"@[to_additive]\ntheorem comap_normalizer_eq_of_injective_of_le_range {N : Type*} [Group N] (H : Subgroup G)\n    {f : N →* G} (hf : Function.Injective f) (h : H.normalizer ≤ f.range) :\n    comap f H.normalizer = (comap f H).normalizer := by\n  apply Subgroup.map_injective hf\n  rw [map_comap_eq_self h]\n  apply le_antisymm\n  · refine le_trans (le_of_eq ?_) (map_mono (le_normalizer_comap _))\n    rw [map_comap_eq_self h]\n  · refine le_trans (le_normalizer_map f) (le_of_eq ?_)\n    rw [map_comap_eq_self (le_trans le_normalizer h)]\n\n"}
{"name":"AddSubgroup.addSubgroupOf_normalizer_eq","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH N : AddSubgroup G\nh : LE.le H.normalizer N\n⊢ Eq (H.normalizer.addSubgroupOf N) (H.addSubgroupOf N).normalizer","decl":"@[to_additive]\ntheorem subgroupOf_normalizer_eq {H N : Subgroup G} (h : H.normalizer ≤ N) :\n    H.normalizer.subgroupOf N = (H.subgroupOf N).normalizer := by\n  apply comap_normalizer_eq_of_injective_of_le_range\n  · exact Subtype.coe_injective\n  simpa\n\n"}
{"name":"Subgroup.subgroupOf_normalizer_eq","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH N : Subgroup G\nh : LE.le H.normalizer N\n⊢ Eq (H.normalizer.subgroupOf N) (H.subgroupOf N).normalizer","decl":"@[to_additive]\ntheorem subgroupOf_normalizer_eq {H N : Subgroup G} (h : H.normalizer ≤ N) :\n    H.normalizer.subgroupOf N = (H.subgroupOf N).normalizer := by\n  apply comap_normalizer_eq_of_injective_of_le_range\n  · exact Subtype.coe_injective\n  simpa\n\n"}
{"name":"AddSubgroup.map_equiv_normalizer_eq","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH : AddSubgroup G\nf : AddEquiv G N\n⊢ Eq (AddSubgroup.map f.toAddMonoidHom H.normalizer) (AddSubgroup.map f.toAddMonoidHom H).normalizer","decl":"/-- The image of the normalizer is equal to the normalizer of the image of an isomorphism. -/\n@[to_additive\n      \"The image of the normalizer is equal to the normalizer of the image of an\n      isomorphism.\"]\ntheorem map_equiv_normalizer_eq (H : Subgroup G) (f : G ≃* N) :\n    H.normalizer.map f.toMonoidHom = (H.map f.toMonoidHom).normalizer := by\n  ext x\n  simp only [mem_normalizer_iff, mem_map_equiv]\n  rw [f.toEquiv.forall_congr]\n  intro\n  simp\n\n"}
{"name":"Subgroup.map_equiv_normalizer_eq","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH : Subgroup G\nf : MulEquiv G N\n⊢ Eq (Subgroup.map f.toMonoidHom H.normalizer) (Subgroup.map f.toMonoidHom H).normalizer","decl":"/-- The image of the normalizer is equal to the normalizer of the image of an isomorphism. -/\n@[to_additive\n      \"The image of the normalizer is equal to the normalizer of the image of an\n      isomorphism.\"]\ntheorem map_equiv_normalizer_eq (H : Subgroup G) (f : G ≃* N) :\n    H.normalizer.map f.toMonoidHom = (H.map f.toMonoidHom).normalizer := by\n  ext x\n  simp only [mem_normalizer_iff, mem_map_equiv]\n  rw [f.toEquiv.forall_congr]\n  intro\n  simp\n\n"}
{"name":"Subgroup.map_normalizer_eq_of_bijective","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH : Subgroup G\nf : MonoidHom G N\nhf : Function.Bijective ⇑f\n⊢ Eq (Subgroup.map f H.normalizer) (Subgroup.map f H).normalizer","decl":"/-- The image of the normalizer is equal to the normalizer of the image of a bijective\n  function. -/\n@[to_additive\n      \"The image of the normalizer is equal to the normalizer of the image of a bijective\n        function.\"]\ntheorem map_normalizer_eq_of_bijective (H : Subgroup G) {f : G →* N} (hf : Function.Bijective f) :\n    H.normalizer.map f = (H.map f).normalizer :=\n  map_equiv_normalizer_eq H (MulEquiv.ofBijective f hf)\n\n"}
{"name":"AddSubgroup.map_normalizer_eq_of_bijective","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH : AddSubgroup G\nf : AddMonoidHom G N\nhf : Function.Bijective ⇑f\n⊢ Eq (AddSubgroup.map f H.normalizer) (AddSubgroup.map f H).normalizer","decl":"/-- The image of the normalizer is equal to the normalizer of the image of a bijective\n  function. -/\n@[to_additive\n      \"The image of the normalizer is equal to the normalizer of the image of a bijective\n        function.\"]\ntheorem map_normalizer_eq_of_bijective (H : Subgroup G) {f : G →* N} (hf : Function.Bijective f) :\n    H.normalizer.map f = (H.map f).normalizer :=\n  map_equiv_normalizer_eq H (MulEquiv.ofBijective f hf)\n\n"}
{"name":"MonoidHom.liftOfRightInverseAux_comp_apply","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G₁ : Type u_5\nG₂ : Type u_6\nG₃ : Type u_7\ninst✝² : Group G₁\ninst✝¹ : Group G₂\ninst✝ : Group G₃\nf : MonoidHom G₁ G₂\nf_inv : G₂ → G₁\nhf : Function.RightInverse f_inv ⇑f\ng : MonoidHom G₁ G₃\nhg : LE.le f.ker g.ker\nx : G₁\n⊢ Eq ((f.liftOfRightInverseAux f_inv hf g hg) (f x)) (g x)","decl":"@[to_additive (attr := simp)]\ntheorem liftOfRightInverseAux_comp_apply (hf : Function.RightInverse f_inv f) (g : G₁ →* G₃)\n    (hg : f.ker ≤ g.ker) (x : G₁) : (f.liftOfRightInverseAux f_inv hf g hg) (f x) = g x := by\n  dsimp [liftOfRightInverseAux]\n  rw [← mul_inv_eq_one, ← g.map_inv, ← g.map_mul, ← g.mem_ker]\n  apply hg\n  rw [f.mem_ker, f.map_mul, f.map_inv, mul_inv_eq_one]\n  simp only [hf _]\n\n"}
{"name":"AddMonoidHom.liftOfRightInverseAux_comp_apply","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G₁ : Type u_5\nG₂ : Type u_6\nG₃ : Type u_7\ninst✝² : AddGroup G₁\ninst✝¹ : AddGroup G₂\ninst✝ : AddGroup G₃\nf : AddMonoidHom G₁ G₂\nf_inv : G₂ → G₁\nhf : Function.RightInverse f_inv ⇑f\ng : AddMonoidHom G₁ G₃\nhg : LE.le f.ker g.ker\nx : G₁\n⊢ Eq ((f.liftOfRightInverseAux f_inv hf g hg) (f x)) (g x)","decl":"@[to_additive (attr := simp)]\ntheorem liftOfRightInverseAux_comp_apply (hf : Function.RightInverse f_inv f) (g : G₁ →* G₃)\n    (hg : f.ker ≤ g.ker) (x : G₁) : (f.liftOfRightInverseAux f_inv hf g hg) (f x) = g x := by\n  dsimp [liftOfRightInverseAux]\n  rw [← mul_inv_eq_one, ← g.map_inv, ← g.map_mul, ← g.mem_ker]\n  apply hg\n  rw [f.mem_ker, f.map_mul, f.map_inv, mul_inv_eq_one]\n  simp only [hf _]\n\n"}
{"name":"MonoidHom.liftOfRightInverse_comp_apply","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G₁ : Type u_5\nG₂ : Type u_6\nG₃ : Type u_7\ninst✝² : Group G₁\ninst✝¹ : Group G₂\ninst✝ : Group G₃\nf : MonoidHom G₁ G₂\nf_inv : G₂ → G₁\nhf : Function.RightInverse f_inv ⇑f\ng : Subtype fun g => LE.le f.ker g.ker\nx : G₁\n⊢ Eq (((f.liftOfRightInverse f_inv hf) g) (f x)) (↑g x)","decl":"@[to_additive (attr := simp)]\ntheorem liftOfRightInverse_comp_apply (hf : Function.RightInverse f_inv f)\n    (g : { g : G₁ →* G₃ // f.ker ≤ g.ker }) (x : G₁) :\n    (f.liftOfRightInverse f_inv hf g) (f x) = g.1 x :=\n  f.liftOfRightInverseAux_comp_apply f_inv hf g.1 g.2 x\n\n"}
{"name":"AddMonoidHom.liftOfRightInverse_comp_apply","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G₁ : Type u_5\nG₂ : Type u_6\nG₃ : Type u_7\ninst✝² : AddGroup G₁\ninst✝¹ : AddGroup G₂\ninst✝ : AddGroup G₃\nf : AddMonoidHom G₁ G₂\nf_inv : G₂ → G₁\nhf : Function.RightInverse f_inv ⇑f\ng : Subtype fun g => LE.le f.ker g.ker\nx : G₁\n⊢ Eq (((f.liftOfRightInverse f_inv hf) g) (f x)) (↑g x)","decl":"@[to_additive (attr := simp)]\ntheorem liftOfRightInverse_comp_apply (hf : Function.RightInverse f_inv f)\n    (g : { g : G₁ →* G₃ // f.ker ≤ g.ker }) (x : G₁) :\n    (f.liftOfRightInverse f_inv hf g) (f x) = g.1 x :=\n  f.liftOfRightInverseAux_comp_apply f_inv hf g.1 g.2 x\n\n"}
{"name":"AddMonoidHom.liftOfRightInverse_comp","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G₁ : Type u_5\nG₂ : Type u_6\nG₃ : Type u_7\ninst✝² : AddGroup G₁\ninst✝¹ : AddGroup G₂\ninst✝ : AddGroup G₃\nf : AddMonoidHom G₁ G₂\nf_inv : G₂ → G₁\nhf : Function.RightInverse f_inv ⇑f\ng : Subtype fun g => LE.le f.ker g.ker\n⊢ Eq (((f.liftOfRightInverse f_inv hf) g).comp f) ↑g","decl":"@[to_additive (attr := simp)]\ntheorem liftOfRightInverse_comp (hf : Function.RightInverse f_inv f)\n    (g : { g : G₁ →* G₃ // f.ker ≤ g.ker }) : (f.liftOfRightInverse f_inv hf g).comp f = g :=\n  MonoidHom.ext <| f.liftOfRightInverse_comp_apply f_inv hf g\n\n"}
{"name":"MonoidHom.liftOfRightInverse_comp","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G₁ : Type u_5\nG₂ : Type u_6\nG₃ : Type u_7\ninst✝² : Group G₁\ninst✝¹ : Group G₂\ninst✝ : Group G₃\nf : MonoidHom G₁ G₂\nf_inv : G₂ → G₁\nhf : Function.RightInverse f_inv ⇑f\ng : Subtype fun g => LE.le f.ker g.ker\n⊢ Eq (((f.liftOfRightInverse f_inv hf) g).comp f) ↑g","decl":"@[to_additive (attr := simp)]\ntheorem liftOfRightInverse_comp (hf : Function.RightInverse f_inv f)\n    (g : { g : G₁ →* G₃ // f.ker ≤ g.ker }) : (f.liftOfRightInverse f_inv hf g).comp f = g :=\n  MonoidHom.ext <| f.liftOfRightInverse_comp_apply f_inv hf g\n\n"}
{"name":"AddMonoidHom.eq_liftOfRightInverse","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G₁ : Type u_5\nG₂ : Type u_6\nG₃ : Type u_7\ninst✝² : AddGroup G₁\ninst✝¹ : AddGroup G₂\ninst✝ : AddGroup G₃\nf : AddMonoidHom G₁ G₂\nf_inv : G₂ → G₁\nhf : Function.RightInverse f_inv ⇑f\ng : AddMonoidHom G₁ G₃\nhg : LE.le f.ker g.ker\nh : AddMonoidHom G₂ G₃\nhh : Eq (h.comp f) g\n⊢ Eq h ((f.liftOfRightInverse f_inv hf) ⟨g, hg⟩)","decl":"@[to_additive]\ntheorem eq_liftOfRightInverse (hf : Function.RightInverse f_inv f) (g : G₁ →* G₃)\n    (hg : f.ker ≤ g.ker) (h : G₂ →* G₃) (hh : h.comp f = g) :\n    h = f.liftOfRightInverse f_inv hf ⟨g, hg⟩ := by\n  simp_rw [← hh]\n  exact ((f.liftOfRightInverse f_inv hf).apply_symm_apply _).symm\n\n"}
{"name":"MonoidHom.eq_liftOfRightInverse","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G₁ : Type u_5\nG₂ : Type u_6\nG₃ : Type u_7\ninst✝² : Group G₁\ninst✝¹ : Group G₂\ninst✝ : Group G₃\nf : MonoidHom G₁ G₂\nf_inv : G₂ → G₁\nhf : Function.RightInverse f_inv ⇑f\ng : MonoidHom G₁ G₃\nhg : LE.le f.ker g.ker\nh : MonoidHom G₂ G₃\nhh : Eq (h.comp f) g\n⊢ Eq h ((f.liftOfRightInverse f_inv hf) ⟨g, hg⟩)","decl":"@[to_additive]\ntheorem eq_liftOfRightInverse (hf : Function.RightInverse f_inv f) (g : G₁ →* G₃)\n    (hg : f.ker ≤ g.ker) (h : G₂ →* G₃) (hh : h.comp f = g) :\n    h = f.liftOfRightInverse f_inv hf ⟨g, hg⟩ := by\n  simp_rw [← hh]\n  exact ((f.liftOfRightInverse f_inv hf).apply_symm_apply _).symm\n\n"}
{"name":"Subgroup.Normal.comap","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH : Subgroup N\nhH : H.Normal\nf : MonoidHom G N\n⊢ (Subgroup.comap f H).Normal","decl":"@[to_additive]\ntheorem Normal.comap {H : Subgroup N} (hH : H.Normal) (f : G →* N) : (H.comap f).Normal :=\n  ⟨fun _ => by simp +contextual [Subgroup.mem_comap, hH.conj_mem]⟩\n\n"}
{"name":"AddSubgroup.Normal.comap","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH : AddSubgroup N\nhH : H.Normal\nf : AddMonoidHom G N\n⊢ (AddSubgroup.comap f H).Normal","decl":"@[to_additive]\ntheorem Normal.comap {H : Subgroup N} (hH : H.Normal) (f : G →* N) : (H.comap f).Normal :=\n  ⟨fun _ => by simp +contextual [Subgroup.mem_comap, hH.conj_mem]⟩\n\n"}
{"name":"Subgroup.normal_comap","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH : Subgroup N\nnH : H.Normal\nf : MonoidHom G N\n⊢ (Subgroup.comap f H).Normal","decl":"@[to_additive]\ninstance (priority := 100) normal_comap {H : Subgroup N} [nH : H.Normal] (f : G →* N) :\n    (H.comap f).Normal :=\n  nH.comap _\n\n-- Here `H.Normal` is an explicit argument so we can use dot notation with `subgroupOf`.\n"}
{"name":"AddSubgroup.normal_comap","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH : AddSubgroup N\nnH : H.Normal\nf : AddMonoidHom G N\n⊢ (AddSubgroup.comap f H).Normal","decl":"@[to_additive]\ninstance (priority := 100) normal_comap {H : Subgroup N} [nH : H.Normal] (f : G →* N) :\n    (H.comap f).Normal :=\n  nH.comap _\n\n-- Here `H.Normal` is an explicit argument so we can use dot notation with `subgroupOf`.\n"}
{"name":"Subgroup.Normal.subgroupOf","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nhH : H.Normal\nK : Subgroup G\n⊢ (H.subgroupOf K).Normal","decl":"@[to_additive]\ntheorem Normal.subgroupOf {H : Subgroup G} (hH : H.Normal) (K : Subgroup G) :\n    (H.subgroupOf K).Normal :=\n  hH.comap _\n\n"}
{"name":"AddSubgroup.Normal.addSubgroupOf","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH : AddSubgroup G\nhH : H.Normal\nK : AddSubgroup G\n⊢ (H.addSubgroupOf K).Normal","decl":"@[to_additive]\ntheorem Normal.subgroupOf {H : Subgroup G} (hH : H.Normal) (K : Subgroup G) :\n    (H.subgroupOf K).Normal :=\n  hH.comap _\n\n"}
{"name":"Subgroup.normal_subgroupOf","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH N : Subgroup G\ninst✝ : N.Normal\n⊢ (N.subgroupOf H).Normal","decl":"@[to_additive]\ninstance (priority := 100) normal_subgroupOf {H N : Subgroup G} [N.Normal] :\n    (N.subgroupOf H).Normal :=\n  Subgroup.normal_comap _\n\n"}
{"name":"AddSubgroup.normal_addSubgroupOf","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nH N : AddSubgroup G\ninst✝ : N.Normal\n⊢ (N.addSubgroupOf H).Normal","decl":"@[to_additive]\ninstance (priority := 100) normal_subgroupOf {H N : Subgroup G} [N.Normal] :\n    (N.subgroupOf H).Normal :=\n  Subgroup.normal_comap _\n\n"}
{"name":"Subgroup.map_normalClosure","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\ns : Set G\nf : MonoidHom G N\nhf : Function.Surjective ⇑f\n⊢ Eq (Subgroup.map f (Subgroup.normalClosure s)) (Subgroup.normalClosure (Set.image (⇑f) s))","decl":"theorem map_normalClosure (s : Set G) (f : G →* N) (hf : Surjective f) :\n    (normalClosure s).map f = normalClosure (f '' s) := by\n  have : Normal (map f (normalClosure s)) := Normal.map inferInstance f hf\n  apply le_antisymm\n  · simp [map_le_iff_le_comap, normalClosure_le_normal, coe_comap,\n      ← Set.image_subset_iff, subset_normalClosure]\n  · exact normalClosure_le_normal (Set.image_subset f subset_normalClosure)\n\n"}
{"name":"Subgroup.comap_normalClosure","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\ns : Set N\nf : MulEquiv G N\n⊢ Eq (Subgroup.normalClosure (Set.preimage (⇑f) s)) (Subgroup.comap (↑f) (Subgroup.normalClosure s))","decl":"theorem comap_normalClosure (s : Set N) (f : G ≃* N) :\n    normalClosure (f ⁻¹' s) = (normalClosure s).comap f := by\n  have := Set.preimage_equiv_eq_image_symm s f.toEquiv\n  simp_all [comap_equiv_eq_map_symm, map_normalClosure s (f.symm : N →* G) f.symm.surjective]\n\n"}
{"name":"Subgroup.Normal.of_map_injective","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_6\nH : Type u_7\ninst✝¹ : Group G\ninst✝ : Group H\nφ : MonoidHom G H\nhφ : Function.Injective ⇑φ\nL : Subgroup G\nn : (Subgroup.map φ L).Normal\n⊢ L.Normal","decl":"lemma Normal.of_map_injective {G H : Type*} [Group G] [Group H] {φ : G →* H}\n    (hφ : Function.Injective φ) {L : Subgroup G} (n : (L.map φ).Normal) : L.Normal :=\n  L.comap_map_eq_self_of_injective hφ ▸ n.comap φ\n\n"}
{"name":"Subgroup.Normal.of_map_subtype","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Subgroup G\nL : Subgroup (Subtype fun x => Membership.mem K x)\nn : (Subgroup.map K.subtype L).Normal\n⊢ L.Normal","decl":"theorem Normal.of_map_subtype {K : Subgroup G} {L : Subgroup K}\n    (n : (Subgroup.map K.subtype L).Normal) : L.Normal :=\n  n.of_map_injective K.subtype_injective\n\n"}
{"name":"Subgroup.normal_subgroupOf_iff","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nhHK : LE.le H K\n⊢ Iff (H.subgroupOf K).Normal (∀ (h k : G), Membership.mem H h → Membership.mem K k → Membership.mem H (HMul.hMul (HMul.hMul k h) (Inv.inv k)))","decl":"@[to_additive]\ntheorem normal_subgroupOf_iff {H K : Subgroup G} (hHK : H ≤ K) :\n    (H.subgroupOf K).Normal ↔ ∀ h k, h ∈ H → k ∈ K → k * h * k⁻¹ ∈ H :=\n  ⟨fun hN h k hH hK => hN.conj_mem ⟨h, hHK hH⟩ hH ⟨k, hK⟩, fun hN =>\n    { conj_mem := fun h hm k => hN h.1 k.1 hm k.2 }⟩\n\n"}
{"name":"AddSubgroup.normal_addSubgroupOf_iff","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nhHK : LE.le H K\n⊢ Iff (H.addSubgroupOf K).Normal (∀ (h k : G), Membership.mem H h → Membership.mem K k → Membership.mem H (HAdd.hAdd (HAdd.hAdd k h) (Neg.neg k)))","decl":"@[to_additive]\ntheorem normal_subgroupOf_iff {H K : Subgroup G} (hHK : H ≤ K) :\n    (H.subgroupOf K).Normal ↔ ∀ h k, h ∈ H → k ∈ K → k * h * k⁻¹ ∈ H :=\n  ⟨fun hN h k hH hK => hN.conj_mem ⟨h, hHK hH⟩ hH ⟨k, hK⟩, fun hN =>\n    { conj_mem := fun h hm k => hN h.1 k.1 hm k.2 }⟩\n\n"}
{"name":"Subgroup.prod_subgroupOf_prod_normal","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH₁ K₁ : Subgroup G\nH₂ K₂ : Subgroup N\nh₁ : (H₁.subgroupOf K₁).Normal\nh₂ : (H₂.subgroupOf K₂).Normal\n⊢ ((H₁.prod H₂).subgroupOf (K₁.prod K₂)).Normal","decl":"@[to_additive]\ninstance prod_subgroupOf_prod_normal {H₁ K₁ : Subgroup G} {H₂ K₂ : Subgroup N}\n    [h₁ : (H₁.subgroupOf K₁).Normal] [h₂ : (H₂.subgroupOf K₂).Normal] :\n    ((H₁.prod H₂).subgroupOf (K₁.prod K₂)).Normal where\n  conj_mem n hgHK g :=\n    ⟨h₁.conj_mem ⟨(n : G × N).fst, (mem_prod.mp n.2).1⟩ hgHK.1\n        ⟨(g : G × N).fst, (mem_prod.mp g.2).1⟩,\n      h₂.conj_mem ⟨(n : G × N).snd, (mem_prod.mp n.2).2⟩ hgHK.2\n        ⟨(g : G × N).snd, (mem_prod.mp g.2).2⟩⟩\n\n"}
{"name":"AddSubgroup.sum_addSubgroupOf_sum_normal","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH₁ K₁ : AddSubgroup G\nH₂ K₂ : AddSubgroup N\nh₁ : (H₁.addSubgroupOf K₁).Normal\nh₂ : (H₂.addSubgroupOf K₂).Normal\n⊢ ((H₁.prod H₂).addSubgroupOf (K₁.prod K₂)).Normal","decl":"@[to_additive]\ninstance prod_subgroupOf_prod_normal {H₁ K₁ : Subgroup G} {H₂ K₂ : Subgroup N}\n    [h₁ : (H₁.subgroupOf K₁).Normal] [h₂ : (H₂.subgroupOf K₂).Normal] :\n    ((H₁.prod H₂).subgroupOf (K₁.prod K₂)).Normal where\n  conj_mem n hgHK g :=\n    ⟨h₁.conj_mem ⟨(n : G × N).fst, (mem_prod.mp n.2).1⟩ hgHK.1\n        ⟨(g : G × N).fst, (mem_prod.mp g.2).1⟩,\n      h₂.conj_mem ⟨(n : G × N).snd, (mem_prod.mp n.2).2⟩ hgHK.2\n        ⟨(g : G × N).snd, (mem_prod.mp g.2).2⟩⟩\n\n"}
{"name":"Subgroup.prod_normal","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nN : Type u_5\ninst✝ : Group N\nH : Subgroup G\nK : Subgroup N\nhH : H.Normal\nhK : K.Normal\n⊢ (H.prod K).Normal","decl":"@[to_additive]\ninstance prod_normal (H : Subgroup G) (K : Subgroup N) [hH : H.Normal] [hK : K.Normal] :\n    (H.prod K).Normal where\n  conj_mem n hg g :=\n    ⟨hH.conj_mem n.fst (Subgroup.mem_prod.mp hg).1 g.fst,\n      hK.conj_mem n.snd (Subgroup.mem_prod.mp hg).2 g.snd⟩\n\n"}
{"name":"AddSubgroup.sum_normal","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nN : Type u_5\ninst✝ : AddGroup N\nH : AddSubgroup G\nK : AddSubgroup N\nhH : H.Normal\nhK : K.Normal\n⊢ (H.prod K).Normal","decl":"@[to_additive]\ninstance prod_normal (H : Subgroup G) (K : Subgroup N) [hH : H.Normal] [hK : K.Normal] :\n    (H.prod K).Normal where\n  conj_mem n hg g :=\n    ⟨hH.conj_mem n.fst (Subgroup.mem_prod.mp hg).1 g.fst,\n      hK.conj_mem n.snd (Subgroup.mem_prod.mp hg).2 g.snd⟩\n\n"}
{"name":"AddSubgroup.inf_addSubgroupOf_inf_normal_of_right","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nA B' B : AddSubgroup G\nhB : LE.le B' B\nhN : (B'.addSubgroupOf B).Normal\n⊢ ((Min.min A B').addSubgroupOf (Min.min A B)).Normal","decl":"@[to_additive]\ntheorem inf_subgroupOf_inf_normal_of_right (A B' B : Subgroup G) (hB : B' ≤ B)\n    [hN : (B'.subgroupOf B).Normal] : ((A ⊓ B').subgroupOf (A ⊓ B)).Normal :=\n  { conj_mem := fun {n} hn g =>\n      ⟨mul_mem (mul_mem (mem_inf.1 g.2).1 (mem_inf.1 n.2).1) <|\n        show ↑g⁻¹ ∈ A from (inv_mem (mem_inf.1 g.2).1),\n        (normal_subgroupOf_iff hB).mp hN n g hn.2 (mem_inf.mp g.2).2⟩ }\n\n"}
{"name":"Subgroup.inf_subgroupOf_inf_normal_of_right","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B' B : Subgroup G\nhB : LE.le B' B\nhN : (B'.subgroupOf B).Normal\n⊢ ((Min.min A B').subgroupOf (Min.min A B)).Normal","decl":"@[to_additive]\ntheorem inf_subgroupOf_inf_normal_of_right (A B' B : Subgroup G) (hB : B' ≤ B)\n    [hN : (B'.subgroupOf B).Normal] : ((A ⊓ B').subgroupOf (A ⊓ B)).Normal :=\n  { conj_mem := fun {n} hn g =>\n      ⟨mul_mem (mul_mem (mem_inf.1 g.2).1 (mem_inf.1 n.2).1) <|\n        show ↑g⁻¹ ∈ A from (inv_mem (mem_inf.1 g.2).1),\n        (normal_subgroupOf_iff hB).mp hN n g hn.2 (mem_inf.mp g.2).2⟩ }\n\n"}
{"name":"Subgroup.inf_subgroupOf_inf_normal_of_left","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nA' A B : Subgroup G\nhA : LE.le A' A\nhN : (A'.subgroupOf A).Normal\n⊢ ((Min.min A' B).subgroupOf (Min.min A B)).Normal","decl":"@[to_additive]\ntheorem inf_subgroupOf_inf_normal_of_left {A' A : Subgroup G} (B : Subgroup G) (hA : A' ≤ A)\n    [hN : (A'.subgroupOf A).Normal] : ((A' ⊓ B).subgroupOf (A ⊓ B)).Normal :=\n  { conj_mem := fun n hn g =>\n      ⟨(normal_subgroupOf_iff hA).mp hN n g hn.1 (mem_inf.mp g.2).1,\n        mul_mem (mul_mem (mem_inf.1 g.2).2 (mem_inf.1 n.2).2) <|\n        show ↑g⁻¹ ∈ B from (inv_mem (mem_inf.1 g.2).2)⟩ }\n\n"}
{"name":"AddSubgroup.inf_addSubgroupOf_inf_normal_of_left","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nA' A B : AddSubgroup G\nhA : LE.le A' A\nhN : (A'.addSubgroupOf A).Normal\n⊢ ((Min.min A' B).addSubgroupOf (Min.min A B)).Normal","decl":"@[to_additive]\ntheorem inf_subgroupOf_inf_normal_of_left {A' A : Subgroup G} (B : Subgroup G) (hA : A' ≤ A)\n    [hN : (A'.subgroupOf A).Normal] : ((A' ⊓ B).subgroupOf (A ⊓ B)).Normal :=\n  { conj_mem := fun n hn g =>\n      ⟨(normal_subgroupOf_iff hA).mp hN n g hn.1 (mem_inf.mp g.2).1,\n        mul_mem (mul_mem (mem_inf.1 g.2).2 (mem_inf.1 n.2).2) <|\n        show ↑g⁻¹ ∈ B from (inv_mem (mem_inf.1 g.2).2)⟩ }\n\n"}
{"name":"Subgroup.normal_inf_normal","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nhH : H.Normal\nhK : K.Normal\n⊢ (Min.min H K).Normal","decl":"@[to_additive]\ninstance normal_inf_normal (H K : Subgroup G) [hH : H.Normal] [hK : K.Normal] : (H ⊓ K).Normal :=\n  ⟨fun n hmem g => ⟨hH.conj_mem n hmem.1 g, hK.conj_mem n hmem.2 g⟩⟩\n\n"}
{"name":"AddSubgroup.normal_inf_normal","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nhH : H.Normal\nhK : K.Normal\n⊢ (Min.min H K).Normal","decl":"@[to_additive]\ninstance normal_inf_normal (H K : Subgroup G) [hH : H.Normal] [hK : K.Normal] : (H ⊓ K).Normal :=\n  ⟨fun n hmem g => ⟨hH.conj_mem n hmem.1 g, hK.conj_mem n hmem.2 g⟩⟩\n\n"}
{"name":"Subgroup.normal_iInf_normal","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nι : Type u_6\na : ι → Subgroup G\nnorm : ∀ (i : ι), (a i).Normal\n⊢ (iInf a).Normal","decl":"@[to_additive]\ntheorem normal_iInf_normal {ι : Type*} {a : ι → Subgroup G}\n    (norm : ∀ i : ι , (a i).Normal) : (iInf a).Normal := by\n  constructor\n  intro g g_in_iInf h\n  rw [Subgroup.mem_iInf] at g_in_iInf ⊢\n  intro i\n  exact (norm i).conj_mem g (g_in_iInf i) h\n\n"}
{"name":"AddSubgroup.normal_iInf_normal","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nι : Type u_6\na : ι → AddSubgroup G\nnorm : ∀ (i : ι), (a i).Normal\n⊢ (iInf a).Normal","decl":"@[to_additive]\ntheorem normal_iInf_normal {ι : Type*} {a : ι → Subgroup G}\n    (norm : ∀ i : ι , (a i).Normal) : (iInf a).Normal := by\n  constructor\n  intro g g_in_iInf h\n  rw [Subgroup.mem_iInf] at g_in_iInf ⊢\n  intro i\n  exact (norm i).conj_mem g (g_in_iInf i) h\n\n"}
{"name":"AddSubgroup.SubgroupNormal.mem_comm","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH K : AddSubgroup G\nhK : LE.le H K\nhN : (H.addSubgroupOf K).Normal\na b : G\nhb : Membership.mem K b\nh : Membership.mem H (HAdd.hAdd a b)\n⊢ Membership.mem H (HAdd.hAdd b a)","decl":"@[to_additive]\ntheorem SubgroupNormal.mem_comm {H K : Subgroup G} (hK : H ≤ K) [hN : (H.subgroupOf K).Normal]\n    {a b : G} (hb : b ∈ K) (h : a * b ∈ H) : b * a ∈ H := by\n  have := (normal_subgroupOf_iff hK).mp hN (a * b) b h hb\n  rwa [mul_assoc, mul_assoc, mul_inv_cancel, mul_one] at this\n\n"}
{"name":"Subgroup.SubgroupNormal.mem_comm","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH K : Subgroup G\nhK : LE.le H K\nhN : (H.subgroupOf K).Normal\na b : G\nhb : Membership.mem K b\nh : Membership.mem H (HMul.hMul a b)\n⊢ Membership.mem H (HMul.hMul b a)","decl":"@[to_additive]\ntheorem SubgroupNormal.mem_comm {H K : Subgroup G} (hK : H ≤ K) [hN : (H.subgroupOf K).Normal]\n    {a b : G} (hb : b ∈ K) (h : a * b ∈ H) : b * a ∈ H := by\n  have := (normal_subgroupOf_iff hK).mp hN (a * b) b h hb\n  rwa [mul_assoc, mul_assoc, mul_inv_cancel, mul_one] at this\n\n"}
{"name":"AddSubgroup.addCommute_of_normal_of_disjoint","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nH₁ H₂ : AddSubgroup G\nhH₁ : H₁.Normal\nhH₂ : H₂.Normal\nhdis : Disjoint H₁ H₂\nx y : G\nhx : Membership.mem H₁ x\nhy : Membership.mem H₂ y\n⊢ AddCommute x y","decl":"/-- Elements of disjoint, normal subgroups commute. -/\n@[to_additive \"Elements of disjoint, normal subgroups commute.\"]\ntheorem commute_of_normal_of_disjoint (H₁ H₂ : Subgroup G) (hH₁ : H₁.Normal) (hH₂ : H₂.Normal)\n    (hdis : Disjoint H₁ H₂) (x y : G) (hx : x ∈ H₁) (hy : y ∈ H₂) : Commute x y := by\n  suffices x * y * x⁻¹ * y⁻¹ = 1 by\n    show x * y = y * x\n    · rw [mul_assoc, mul_eq_one_iff_eq_inv] at this\n      -- Porting note: Previous code was:\n      -- simpa\n      simp only [this, mul_inv_rev, inv_inv]\n  apply hdis.le_bot\n  constructor\n  · suffices x * (y * x⁻¹ * y⁻¹) ∈ H₁ by simpa [mul_assoc]\n    exact H₁.mul_mem hx (hH₁.conj_mem _ (H₁.inv_mem hx) _)\n  · show x * y * x⁻¹ * y⁻¹ ∈ H₂\n    apply H₂.mul_mem _ (H₂.inv_mem hy)\n    apply hH₂.conj_mem _ hy\n\n"}
{"name":"Subgroup.commute_of_normal_of_disjoint","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nH₁ H₂ : Subgroup G\nhH₁ : H₁.Normal\nhH₂ : H₂.Normal\nhdis : Disjoint H₁ H₂\nx y : G\nhx : Membership.mem H₁ x\nhy : Membership.mem H₂ y\n⊢ Commute x y","decl":"/-- Elements of disjoint, normal subgroups commute. -/\n@[to_additive \"Elements of disjoint, normal subgroups commute.\"]\ntheorem commute_of_normal_of_disjoint (H₁ H₂ : Subgroup G) (hH₁ : H₁.Normal) (hH₂ : H₂.Normal)\n    (hdis : Disjoint H₁ H₂) (x y : G) (hx : x ∈ H₁) (hy : y ∈ H₂) : Commute x y := by\n  suffices x * y * x⁻¹ * y⁻¹ = 1 by\n    show x * y = y * x\n    · rw [mul_assoc, mul_eq_one_iff_eq_inv] at this\n      -- Porting note: Previous code was:\n      -- simpa\n      simp only [this, mul_inv_rev, inv_inv]\n  apply hdis.le_bot\n  constructor\n  · suffices x * (y * x⁻¹ * y⁻¹) ∈ H₁ by simpa [mul_assoc]\n    exact H₁.mul_mem hx (hH₁.conj_mem _ (H₁.inv_mem hx) _)\n  · show x * y * x⁻¹ * y⁻¹ ∈ H₂\n    apply H₂.mul_mem _ (H₂.inv_mem hy)\n    apply hH₂.conj_mem _ hy\n\n"}
{"name":"IsConj.normalClosure_eq_top_of","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_1\ninst✝ : Group G\nN : Subgroup G\nhn : N.Normal\ng g' : G\nhg : Membership.mem N g\nhg' : Membership.mem N g'\nhc : IsConj g g'\nht : Eq (Subgroup.normalClosure (Singleton.singleton ⟨g, hg⟩)) Top.top\n⊢ Eq (Subgroup.normalClosure (Singleton.singleton ⟨g', hg'⟩)) Top.top","decl":"theorem normalClosure_eq_top_of {N : Subgroup G} [hn : N.Normal] {g g' : G} {hg : g ∈ N}\n    {hg' : g' ∈ N} (hc : IsConj g g') (ht : normalClosure ({⟨g, hg⟩} : Set N) = ⊤) :\n    normalClosure ({⟨g', hg'⟩} : Set N) = ⊤ := by\n  obtain ⟨c, rfl⟩ := isConj_iff.1 hc\n  have h : ∀ x : N, (MulAut.conj c) x ∈ N := by\n    rintro ⟨x, hx⟩\n    exact hn.conj_mem _ hx c\n  have hs : Function.Surjective (((MulAut.conj c).toMonoidHom.restrict N).codRestrict _ h) := by\n    rintro ⟨x, hx⟩\n    refine ⟨⟨c⁻¹ * x * c, ?_⟩, ?_⟩\n    · have h := hn.conj_mem _ hx c⁻¹\n      rwa [inv_inv] at h\n    simp only [MonoidHom.codRestrict_apply, MulEquiv.coe_toMonoidHom, MulAut.conj_apply, coe_mk,\n      MonoidHom.restrict_apply, Subtype.mk_eq_mk, ← mul_assoc, mul_inv_cancel, one_mul]\n    rw [mul_assoc, mul_inv_cancel, mul_one]\n  rw [eq_top_iff, ← MonoidHom.range_eq_top.2 hs, MonoidHom.range_eq_map]\n  refine le_trans (map_mono (eq_top_iff.1 ht)) (map_le_iff_le_comap.2 (normalClosure_le_normal ?_))\n  rw [Set.singleton_subset_iff, SetLike.mem_coe]\n  simp only [MonoidHom.codRestrict_apply, MulEquiv.coe_toMonoidHom, MulAut.conj_apply, coe_mk,\n    MonoidHom.restrict_apply, mem_comap]\n  exact subset_normalClosure (Set.mem_singleton _)\n\n"}
{"name":"ConjClasses.mem_noncenter","module":"Mathlib.Algebra.Group.Subgroup.Basic","initialProofState":"G : Type u_6\ninst✝ : Monoid G\ng : ConjClasses G\n⊢ Iff (Membership.mem (ConjClasses.noncenter G) g) g.carrier.Nontrivial","decl":"@[simp] lemma mem_noncenter {G} [Monoid G] (g : ConjClasses G) :\n  g ∈ noncenter G ↔ g.carrier.Nontrivial := Iff.rfl\n\n"}
