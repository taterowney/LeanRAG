{"name":"List.Nodup.getBijectionOfForallMemList_coe","module":"Mathlib.Data.List.NodupEquivFin","initialProofState":"α : Type u_1\nl : List α\nnd : l.Nodup\nh : ∀ (x : α), Membership.mem l x\ni : Fin l.length\n⊢ Eq (↑(List.Nodup.getBijectionOfForallMemList l nd h) i) (l.get i)","decl":"/-- If `l` lists all the elements of `α` without duplicates, then `List.get` defines\na bijection `Fin l.length → α`.  See `List.Nodup.getEquivOfForallMemList`\nfor a version giving an equivalence when there is decidable equality. -/\n@[simps]\ndef getBijectionOfForallMemList (l : List α) (nd : l.Nodup) (h : ∀ x : α, x ∈ l) :\n    { f : Fin l.length → α // Function.Bijective f } :=\n  ⟨fun i => l.get i, fun _ _ h => nd.get_inj_iff.1 h,\n   fun x =>\n    let ⟨i, hl⟩ := List.mem_iff_get.1 (h x)\n    ⟨i, hl⟩⟩\n\n"}
{"name":"List.Nodup.getEquiv_apply_coe","module":"Mathlib.Data.List.NodupEquivFin","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nH : l.Nodup\ni : Fin l.length\n⊢ Eq (↑((List.Nodup.getEquiv l H) i)) (l.get i)","decl":"/-- If `l` has no duplicates, then `List.get` defines an equivalence between `Fin (length l)` and\nthe set of elements of `l`. -/\n@[simps]\ndef getEquiv (l : List α) (H : Nodup l) : Fin (length l) ≃ { x // x ∈ l } where\n  toFun i := ⟨get l i, get_mem _ _⟩\n  invFun x := ⟨indexOf (↑x) l, indexOf_lt_length_iff.2 x.2⟩\n  left_inv i := by simp only [List.get_indexOf, eq_self_iff_true, Fin.eta, Subtype.coe_mk, H]\n  right_inv x := by simp\n\n"}
{"name":"List.Nodup.getEquiv_symm_apply_val","module":"Mathlib.Data.List.NodupEquivFin","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nH : l.Nodup\nx : Subtype fun x => Membership.mem l x\n⊢ Eq (↑((List.Nodup.getEquiv l H).symm x)) (List.indexOf (↑x) l)","decl":"/-- If `l` has no duplicates, then `List.get` defines an equivalence between `Fin (length l)` and\nthe set of elements of `l`. -/\n@[simps]\ndef getEquiv (l : List α) (H : Nodup l) : Fin (length l) ≃ { x // x ∈ l } where\n  toFun i := ⟨get l i, get_mem _ _⟩\n  invFun x := ⟨indexOf (↑x) l, indexOf_lt_length_iff.2 x.2⟩\n  left_inv i := by simp only [List.get_indexOf, eq_self_iff_true, Fin.eta, Subtype.coe_mk, H]\n  right_inv x := by simp\n\n"}
{"name":"List.Nodup.getEquivOfForallMemList_apply","module":"Mathlib.Data.List.NodupEquivFin","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nnd : l.Nodup\nh : ∀ (x : α), Membership.mem l x\ni : Fin l.length\n⊢ Eq ((List.Nodup.getEquivOfForallMemList l nd h) i) (l.get i)","decl":"/-- If `l` lists all the elements of `α` without duplicates, then `List.get` defines\nan equivalence between `Fin l.length` and `α`.\n\nSee `List.Nodup.getBijectionOfForallMemList` for a version without\ndecidable equality. -/\n@[simps]\ndef getEquivOfForallMemList (l : List α) (nd : l.Nodup) (h : ∀ x : α, x ∈ l) :\n    Fin l.length ≃ α where\n  toFun i := l.get i\n  invFun a := ⟨_, indexOf_lt_length_iff.2 (h a)⟩\n  left_inv i := by simp [List.indexOf_getElem, nd]\n  right_inv a := by simp\n\n"}
{"name":"List.Nodup.getEquivOfForallMemList_symm_apply_val","module":"Mathlib.Data.List.NodupEquivFin","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nnd : l.Nodup\nh : ∀ (x : α), Membership.mem l x\na : α\n⊢ Eq (↑((List.Nodup.getEquivOfForallMemList l nd h).symm a)) (List.indexOf a l)","decl":"/-- If `l` lists all the elements of `α` without duplicates, then `List.get` defines\nan equivalence between `Fin l.length` and `α`.\n\nSee `List.Nodup.getBijectionOfForallMemList` for a version without\ndecidable equality. -/\n@[simps]\ndef getEquivOfForallMemList (l : List α) (nd : l.Nodup) (h : ∀ x : α, x ∈ l) :\n    Fin l.length ≃ α where\n  toFun i := l.get i\n  invFun a := ⟨_, indexOf_lt_length_iff.2 (h a)⟩\n  left_inv i := by simp [List.indexOf_getElem, nd]\n  right_inv a := by simp\n\n"}
{"name":"List.Sorted.get_mono","module":"Mathlib.Data.List.NodupEquivFin","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nl : List α\nh : List.Sorted (fun x1 x2 => LE.le x1 x2) l\n⊢ Monotone l.get","decl":"theorem get_mono (h : l.Sorted (· ≤ ·)) : Monotone l.get := fun _ _ => h.rel_get_of_le\n\n"}
{"name":"List.Sorted.get_strictMono","module":"Mathlib.Data.List.NodupEquivFin","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nl : List α\nh : List.Sorted (fun x1 x2 => LT.lt x1 x2) l\n⊢ StrictMono l.get","decl":"theorem get_strictMono (h : l.Sorted (· < ·)) : StrictMono l.get := fun _ _ => h.rel_get_of_lt\n\n"}
{"name":"List.Sorted.coe_getIso_apply","module":"Mathlib.Data.List.NodupEquivFin","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\nl : List α\ninst✝ : DecidableEq α\nH : List.Sorted (fun x1 x2 => LT.lt x1 x2) l\ni : Fin l.length\n⊢ Eq (↑((List.Sorted.getIso l H) i)) (l.get i)","decl":"@[simp]\ntheorem coe_getIso_apply : (H.getIso l i : α) = get l i :=\n  rfl\n\n"}
{"name":"List.Sorted.coe_getIso_symm_apply","module":"Mathlib.Data.List.NodupEquivFin","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\nl : List α\ninst✝ : DecidableEq α\nH : List.Sorted (fun x1 x2 => LT.lt x1 x2) l\nx : Subtype fun x => Membership.mem l x\n⊢ Eq (↑((List.Sorted.getIso l H).symm x)) (List.indexOf (↑x) l)","decl":"@[simp]\ntheorem coe_getIso_symm_apply : ((H.getIso l).symm x : ℕ) = indexOf (↑x) l :=\n  rfl\n\n"}
{"name":"List.sublist_of_orderEmbedding_get?_eq","module":"Mathlib.Data.List.NodupEquivFin","initialProofState":"α : Type u_1\nl l' : List α\nf : OrderEmbedding Nat Nat\nhf : ∀ (ix : Nat), Eq (l.get? ix) (l'.get? (f ix))\n⊢ l.Sublist l'","decl":"/-- If there is `f`, an order-preserving embedding of `ℕ` into `ℕ` such that\nany element of `l` found at index `ix` can be found at index `f ix` in `l'`,\nthen `Sublist l l'`.\n-/\ntheorem sublist_of_orderEmbedding_get?_eq {l l' : List α} (f : ℕ ↪o ℕ)\n    (hf : ∀ ix : ℕ, l.get? ix = l'.get? (f ix)) : l <+ l' := by\n  induction' l with hd tl IH generalizing l' f\n  · simp\n  have : some hd = _ := hf 0\n  rw [eq_comm, List.get?_eq_some_iff] at this\n  obtain ⟨w, h⟩ := this\n  let f' : ℕ ↪o ℕ :=\n    OrderEmbedding.ofMapLEIff (fun i => f (i + 1) - (f 0 + 1)) fun a b => by\n      dsimp only\n      rw [Nat.sub_le_sub_iff_right, OrderEmbedding.le_iff_le, Nat.succ_le_succ_iff]\n      rw [Nat.succ_le_iff, OrderEmbedding.lt_iff_lt]\n      exact b.succ_pos\n  simp only [get_eq_getElem] at h\n  simp only [get?_eq_getElem?] at hf IH\n  have : ∀ ix, tl[ix]? = (l'.drop (f 0 + 1))[f' ix]? := by\n    intro ix\n    rw [List.getElem?_drop, OrderEmbedding.coe_ofMapLEIff, Nat.add_sub_cancel', ← hf]\n    simp only [getElem?_cons_succ]\n    rw [Nat.succ_le_iff, OrderEmbedding.lt_iff_lt]\n    exact ix.succ_pos\n  rw [← List.take_append_drop (f 0 + 1) l', ← List.singleton_append]\n  apply List.Sublist.append _ (IH _ this)\n  rw [List.singleton_sublist, ← h, l'.getElem_take' _ (Nat.lt_succ_self _)]\n  exact List.getElem_mem _\n\n"}
{"name":"List.sublist_iff_exists_orderEmbedding_get?_eq","module":"Mathlib.Data.List.NodupEquivFin","initialProofState":"α : Type u_1\nl l' : List α\n⊢ Iff (l.Sublist l') (Exists fun f => ∀ (ix : Nat), Eq (l.get? ix) (l'.get? (f ix)))","decl":"/-- A `l : List α` is `Sublist l l'` for `l' : List α` iff\nthere is `f`, an order-preserving embedding of `ℕ` into `ℕ` such that\nany element of `l` found at index `ix` can be found at index `f ix` in `l'`.\n-/\ntheorem sublist_iff_exists_orderEmbedding_get?_eq {l l' : List α} :\n    l <+ l' ↔ ∃ f : ℕ ↪o ℕ, ∀ ix : ℕ, l.get? ix = l'.get? (f ix) := by\n  constructor\n  · intro H\n    induction H with\n    | slnil => simp\n    | cons _ _ IH =>\n      obtain ⟨f, hf⟩ := IH\n      refine ⟨f.trans (OrderEmbedding.ofStrictMono (· + 1) fun _ => by simp), ?_⟩\n      simpa using hf\n    | cons₂ _ _ IH =>\n      obtain ⟨f, hf⟩ := IH\n      refine\n        ⟨OrderEmbedding.ofMapLEIff (fun ix : ℕ => if ix = 0 then 0 else (f ix.pred).succ) ?_, ?_⟩\n      · rintro ⟨_ | a⟩ ⟨_ | b⟩ <;> simp [Nat.succ_le_succ_iff]\n      · rintro ⟨_ | i⟩\n        · simp\n        · simpa using hf _\n  · rintro ⟨f, hf⟩\n    exact sublist_of_orderEmbedding_get?_eq f hf\n\n"}
{"name":"List.sublist_iff_exists_fin_orderEmbedding_get_eq","module":"Mathlib.Data.List.NodupEquivFin","initialProofState":"α : Type u_1\nl l' : List α\n⊢ Iff (l.Sublist l') (Exists fun f => ∀ (ix : Fin l.length), Eq (l.get ix) (l'.get (f ix)))","decl":"/-- A `l : List α` is `Sublist l l'` for `l' : List α` iff\nthere is `f`, an order-preserving embedding of `Fin l.length` into `Fin l'.length` such that\nany element of `l` found at index `ix` can be found at index `f ix` in `l'`.\n-/\ntheorem sublist_iff_exists_fin_orderEmbedding_get_eq {l l' : List α} :\n    l <+ l' ↔\n      ∃ f : Fin l.length ↪o Fin l'.length,\n        ∀ ix : Fin l.length, l.get ix = l'.get (f ix) := by\n  rw [sublist_iff_exists_orderEmbedding_get?_eq]\n  constructor\n  · rintro ⟨f, hf⟩\n    have h : ∀ {i : ℕ}, i < l.length → f i < l'.length := by\n      intro i hi\n      specialize hf i\n      rw [get?_eq_get hi, eq_comm, get?_eq_some_iff] at hf\n      obtain ⟨h, -⟩ := hf\n      exact h\n    refine ⟨OrderEmbedding.ofMapLEIff (fun ix => ⟨f ix, h ix.is_lt⟩) ?_, ?_⟩\n    · simp\n    · intro i\n      apply Option.some_injective\n      simpa [getElem?_eq_getElem i.2, getElem?_eq_getElem (h i.2)] using hf i\n  · rintro ⟨f, hf⟩\n    refine\n      ⟨OrderEmbedding.ofStrictMono (fun i => if hi : i < l.length then f ⟨i, hi⟩ else i + l'.length)\n          ?_,\n        ?_⟩\n    · intro i j h\n      dsimp only\n      split_ifs with hi hj hj\n      · rwa [Fin.val_fin_lt, f.lt_iff_lt]\n      · omega\n      · exact absurd (h.trans hj) hi\n      · simpa using h\n    · intro i\n      simp only [OrderEmbedding.coe_ofStrictMono]\n      split_ifs with hi\n      · rw [get?_eq_get hi, get?_eq_get, ← hf]\n      · rw [get?_eq_none_iff.mpr, get?_eq_none_iff.mpr]\n        · simp\n        · simpa using hi\n\n"}
{"name":"List.duplicate_iff_exists_distinct_get","module":"Mathlib.Data.List.NodupEquivFin","initialProofState":"α : Type u_1\nl : List α\nx : α\n⊢ Iff (List.Duplicate x l) (Exists fun n => Exists fun m => Exists fun x_1 => And (Eq x (l.get n)) (Eq x (l.get m)))","decl":"/-- An element `x : α` of `l : List α` is a duplicate iff it can be found\nat two distinct indices `n m : ℕ` inside the list `l`.\n-/\ntheorem duplicate_iff_exists_distinct_get {l : List α} {x : α} :\n    l.Duplicate x ↔\n      ∃ (n m : Fin l.length) (_ : n < m),\n        x = l.get n ∧ x = l.get m := by\n  classical\n    rw [duplicate_iff_two_le_count, le_count_iff_replicate_sublist,\n      sublist_iff_exists_fin_orderEmbedding_get_eq]\n    constructor\n    · rintro ⟨f, hf⟩\n      refine ⟨f ⟨0, by simp⟩, f ⟨1, by simp⟩, f.lt_iff_lt.2 (Nat.zero_lt_one), ?_⟩\n      rw [← hf, ← hf]; simp\n    · rintro ⟨n, m, hnm, h, h'⟩\n      refine ⟨OrderEmbedding.ofStrictMono (fun i => if (i : ℕ) = 0 then n else m) ?_, ?_⟩\n      · rintro ⟨⟨_ | i⟩, hi⟩ ⟨⟨_ | j⟩, hj⟩\n        · simp\n        · simp [hnm]\n        · simp\n        · simp only [Nat.lt_succ_iff, Nat.succ_le_succ_iff, replicate, length, Nat.le_zero] at hi hj\n          simp [hi, hj]\n      · rintro ⟨⟨_ | i⟩, hi⟩\n        · simpa using h\n        · simpa using h'\n\n"}
