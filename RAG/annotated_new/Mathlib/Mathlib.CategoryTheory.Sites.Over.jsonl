{"name":"CategoryTheory.Sieve.overEquiv_top","module":"Mathlib.CategoryTheory.Sites.Over","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nY : CategoryTheory.Over X\n‚ä¢ Eq ((CategoryTheory.Sieve.overEquiv Y) Top.top) Top.top","decl":"@[simp]\nlemma overEquiv_top {X : C} (Y : Over X) :\n    overEquiv Y ‚ä§ = ‚ä§ := by\n  ext Z g\n  simp only [top_apply, iff_true]\n  dsimp [overEquiv, Presieve.functorPushforward]\n  exact ‚ü®Y, ùüô Y, g, by simp, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.overEquiv_symm_top","module":"Mathlib.CategoryTheory.Sites.Over","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nY : CategoryTheory.Over X\n‚ä¢ Eq ((CategoryTheory.Sieve.overEquiv Y).symm Top.top) Top.top","decl":"@[simp]\nlemma overEquiv_symm_top {X : C} (Y : Over X) :\n    (overEquiv Y).symm ‚ä§ = ‚ä§ :=\n  (overEquiv Y).injective (by simp)\n\n"}
{"name":"CategoryTheory.Sieve.overEquiv_le_overEquiv_iff","module":"Mathlib.CategoryTheory.Sites.Over","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nY : CategoryTheory.Over X\nR‚ÇÅ R‚ÇÇ : CategoryTheory.Sieve Y\n‚ä¢ Iff (LE.le ((CategoryTheory.Sieve.overEquiv Y) R‚ÇÅ) ((CategoryTheory.Sieve.overEquiv Y) R‚ÇÇ)) (LE.le R‚ÇÅ R‚ÇÇ)","decl":"lemma overEquiv_le_overEquiv_iff {X : C} {Y : Over X} (R‚ÇÅ R‚ÇÇ : Sieve Y) :\n    R‚ÇÅ.overEquiv Y ‚â§ R‚ÇÇ.overEquiv Y ‚Üî R‚ÇÅ ‚â§ R‚ÇÇ := by\n  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ Sieve.functorPushforward_monotone _ _ h‚ü©\n  replace h : (overEquiv Y).symm (R‚ÇÅ.overEquiv Y) ‚â§ (overEquiv Y).symm (R‚ÇÇ.overEquiv Y) :=\n    Sieve.functorPullback_monotone _ _ h\n  simpa using h\n\n"}
{"name":"CategoryTheory.Sieve.overEquiv_pullback","module":"Mathlib.CategoryTheory.Sites.Over","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nY‚ÇÅ Y‚ÇÇ : CategoryTheory.Over X\nf : Quiver.Hom Y‚ÇÅ Y‚ÇÇ\nS : CategoryTheory.Sieve Y‚ÇÇ\n‚ä¢ Eq ((CategoryTheory.Sieve.overEquiv Y‚ÇÅ) (CategoryTheory.Sieve.pullback f S)) (CategoryTheory.Sieve.pullback f.left ((CategoryTheory.Sieve.overEquiv Y‚ÇÇ) S))","decl":"lemma overEquiv_pullback {X : C} {Y‚ÇÅ Y‚ÇÇ : Over X} (f : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) (S : Sieve Y‚ÇÇ) :\n    overEquiv _ (S.pullback f) = (overEquiv _ S).pullback f.left := by\n  ext Z g\n  dsimp [overEquiv, Presieve.functorPushforward]\n  constructor\n  ¬∑ rintro ‚ü®W, a, b, h, rfl‚ü©\n    exact ‚ü®W, a ‚â´ f, b, h, by simp‚ü©\n  ¬∑ rintro ‚ü®W, a, b, h, w‚ü©\n    let T := Over.mk (b ‚â´ W.hom)\n    let c : T ‚ü∂ Y‚ÇÅ := Over.homMk g (by dsimp [T]; rw [‚Üê Over.w a, ‚Üê reassoc_of% w, Over.w f])\n    let d : T ‚ü∂ W := Over.homMk b\n    refine ‚ü®T, c, ùüô Z, ?_, by simp [T, c]‚ü©\n    rw [show c ‚â´ f = d ‚â´ a by ext; exact w]\n    exact S.downward_closed h _\n\n"}
{"name":"CategoryTheory.Sieve.overEquiv_symm_iff","module":"Mathlib.CategoryTheory.Sites.Over","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nY : CategoryTheory.Over X\nS : CategoryTheory.Sieve Y.left\nZ : CategoryTheory.Over X\nf : Quiver.Hom Z Y\n‚ä¢ Iff (((CategoryTheory.Sieve.overEquiv Y).symm S).arrows f) (S.arrows f.left)","decl":"@[simp]\nlemma overEquiv_symm_iff {X : C} {Y : Over X} (S : Sieve Y.left) {Z : Over X} (f : Z ‚ü∂ Y) :\n    (overEquiv Y).symm S f ‚Üî S f.left := by\n  rfl\n\n"}
{"name":"CategoryTheory.Sieve.overEquiv_iff","module":"Mathlib.CategoryTheory.Sites.Over","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nY : CategoryTheory.Over X\nS : CategoryTheory.Sieve Y\nZ : C\nf : Quiver.Hom Z Y.left\n‚ä¢ Iff (((CategoryTheory.Sieve.overEquiv Y) S).arrows f) (S.arrows (CategoryTheory.Over.homMk f ‚ãØ))","decl":"lemma overEquiv_iff {X : C} {Y : Over X} (S : Sieve Y) {Z : C} (f : Z ‚ü∂ Y.left) :\n    overEquiv Y S f ‚Üî S (Over.homMk f : Over.mk (f ‚â´ Y.hom) ‚ü∂ Y) := by\n  obtain ‚ü®S, rfl‚ü© := (overEquiv Y).symm.surjective S\n  simp\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_over_map","module":"Mathlib.CategoryTheory.Sites.Over","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nZ : CategoryTheory.Over X\nS : CategoryTheory.Sieve Z.left\n‚ä¢ Eq (CategoryTheory.Sieve.functorPushforward (CategoryTheory.Over.map f) ((CategoryTheory.Sieve.overEquiv Z).symm S)) ((CategoryTheory.Sieve.overEquiv ((CategoryTheory.Over.map f).obj Z)).symm S)","decl":"@[simp]\nlemma functorPushforward_over_map {X Y : C} (f : X ‚ü∂ Y) (Z : Over X) (S : Sieve Z.left) :\n    Sieve.functorPushforward (Over.map f) ((Sieve.overEquiv Z).symm S) =\n      (Sieve.overEquiv ((Over.map f).obj Z)).symm S := by\n  ext W g\n  constructor\n  ¬∑ rintro ‚ü®T, a, b, ha, rfl‚ü©\n    exact S.downward_closed ha _\n  ¬∑ intro hg\n    exact ‚ü®Over.mk (g.left ‚â´ Z.hom), Over.homMk g.left,\n      Over.homMk (ùüô _) (by simpa using Over.w g), hg, by aesop_cat‚ü©\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.mem_over_iff","module":"Mathlib.CategoryTheory.Sites.Over","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nY : CategoryTheory.Over X\nS : CategoryTheory.Sieve Y\n‚ä¢ Iff (Membership.mem ((J.over X) Y) S) (Membership.mem (J Y.left) ((CategoryTheory.Sieve.overEquiv Y) S))","decl":"lemma mem_over_iff {X : C} {Y : Over X} (S : Sieve Y) :\n    S ‚àà (J.over X) Y ‚Üî Sieve.overEquiv _ S ‚àà J Y.left := by\n  rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.overEquiv_symm_mem_over","module":"Mathlib.CategoryTheory.Sites.Over","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\nY : CategoryTheory.Over X\nS : CategoryTheory.Sieve Y.left\nhS : Membership.mem (J Y.left) S\n‚ä¢ Membership.mem ((J.over X) Y) ((CategoryTheory.Sieve.overEquiv Y).symm S)","decl":"lemma overEquiv_symm_mem_over {X : C} (Y : Over X) (S : Sieve Y.left) (hS : S ‚àà J Y.left) :\n    (Sieve.overEquiv Y).symm S ‚àà (J.over X) Y := by\n  simpa only [mem_over_iff, Equiv.apply_symm_apply] using hS\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.over_forget_coverPreserving","module":"Mathlib.CategoryTheory.Sites.Over","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\n‚ä¢ CategoryTheory.CoverPreserving (J.over X) J (CategoryTheory.Over.forget X)","decl":"lemma over_forget_coverPreserving (X : C) :\n    CoverPreserving (J.over X) J (Over.forget X) where\n  cover_preserve hS := hS\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.over_forget_compatiblePreserving","module":"Mathlib.CategoryTheory.Sites.Over","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\n‚ä¢ CategoryTheory.CompatiblePreserving J (CategoryTheory.Over.forget X)","decl":"lemma over_forget_compatiblePreserving (X : C) :\n    CompatiblePreserving J (Over.forget X) where\n  compatible {_ Z _ _ hx Y‚ÇÅ Y‚ÇÇ W f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ hg‚ÇÅ hg‚ÇÇ h} := by\n    let W' : Over X := Over.mk (f‚ÇÅ ‚â´ Y‚ÇÅ.hom)\n    let g‚ÇÅ' : W' ‚ü∂ Y‚ÇÅ := Over.homMk f‚ÇÅ\n    let g‚ÇÇ' : W' ‚ü∂ Y‚ÇÇ := Over.homMk f‚ÇÇ (by simpa using h.symm =‚â´ Z.hom)\n    exact hx g‚ÇÅ' g‚ÇÇ' hg‚ÇÅ hg‚ÇÇ (by ext; exact h)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.instIsCocontinuousOverForgetOver","module":"Mathlib.CategoryTheory.Sites.Over","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\n‚ä¢ (CategoryTheory.Over.forget X).IsCocontinuous (J.over X) J","decl":"instance (X : C) : (Over.forget X).IsCocontinuous (J.over X) J where\n  cover_lift hS := J.overEquiv_symm_mem_over _ _ hS\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.instIsContinuousOverForgetOver","module":"Mathlib.CategoryTheory.Sites.Over","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX : C\n‚ä¢ (CategoryTheory.Over.forget X).IsContinuous (J.over X) J","decl":"instance (X : C) : (Over.forget X).IsContinuous (J.over X) J :=\n  Functor.isContinuous_of_coverPreserving\n    (over_forget_compatiblePreserving J X)\n    (over_forget_coverPreserving J X)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.over_map_coverPreserving","module":"Mathlib.CategoryTheory.Sites.Over","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.CoverPreserving (J.over X) (J.over Y) (CategoryTheory.Over.map f)","decl":"lemma over_map_coverPreserving {X Y : C} (f : X ‚ü∂ Y) :\n    CoverPreserving (J.over X) (J.over Y) (Over.map f) where\n  cover_preserve {U S} hS := by\n    obtain ‚ü®S, rfl‚ü© := (Sieve.overEquiv U).symm.surjective S\n    rw [Sieve.functorPushforward_over_map]\n    apply overEquiv_symm_mem_over\n    simpa [mem_over_iff] using hS\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.over_map_compatiblePreserving","module":"Mathlib.CategoryTheory.Sites.Over","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.CompatiblePreserving (J.over Y) (CategoryTheory.Over.map f)","decl":"lemma over_map_compatiblePreserving {X Y : C} (f : X ‚ü∂ Y) :\n    CompatiblePreserving (J.over Y) (Over.map f) where\n  compatible {F Z _ x hx Y‚ÇÅ Y‚ÇÇ W f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ hg‚ÇÅ hg‚ÇÇ h} := by\n    let W' : Over X := Over.mk (f‚ÇÅ.left ‚â´ Y‚ÇÅ.hom)\n    let g‚ÇÅ' : W' ‚ü∂ Y‚ÇÅ := Over.homMk f‚ÇÅ.left\n    let g‚ÇÇ' : W' ‚ü∂ Y‚ÇÇ := Over.homMk f‚ÇÇ.left\n      (by simpa using (Over.forget _).congr_map h.symm =‚â´ Z.hom)\n    let e : (Over.map f).obj W' ‚âÖ W := Over.isoMk (Iso.refl _)\n      (by simpa [W'] using (Over.w f‚ÇÅ).symm)\n    convert congr_arg (F.val.map e.inv.op)\n      (hx g‚ÇÅ' g‚ÇÇ' hg‚ÇÅ hg‚ÇÇ (by ext; exact (Over.forget _).congr_map h)) using 1\n    all_goals\n      dsimp [e, W', g‚ÇÅ', g‚ÇÇ']\n      rw [‚Üê FunctorToTypes.map_comp_apply]\n      apply congr_fun\n      congr 1\n      rw [‚Üê op_comp]\n      congr 1\n      ext\n      simp\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.instIsContinuousOverMapOver","module":"Mathlib.CategoryTheory.Sites.Over","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nJ : CategoryTheory.GrothendieckTopology C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ (CategoryTheory.Over.map f).IsContinuous (J.over X) (J.over Y)","decl":"instance {X Y : C} (f : X ‚ü∂ Y) : (Over.map f).IsContinuous (J.over X) (J.over Y) :=\n  Functor.isContinuous_of_coverPreserving\n    (over_map_compatiblePreserving J f)\n    (over_map_coverPreserving J f)\n\n"}
