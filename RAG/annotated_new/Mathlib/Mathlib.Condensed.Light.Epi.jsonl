{"name":"LightCondensed.isLocallySurjective_iff_locallySurjective_on_lightProfinite","module":"Mathlib.Condensed.Light.Epi","initialProofState":"A : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} A\ninst✝¹ : CategoryTheory.HasForget A\ninst✝ : CategoryTheory.Limits.PreservesFiniteProducts (CategoryTheory.forget A)\nX Y : LightCondensed A\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.Sheaf.IsLocallySurjective f) (∀ (S : LightProfinite) (y : (CategoryTheory.forget A).obj (Y.val.obj { unop := S })), Exists fun S' => Exists fun φ => Exists fun x => Exists fun x => Eq ((f.val.app { unop := S' }) x) ((Y.val.map { unop := φ }) y))","decl":"lemma isLocallySurjective_iff_locallySurjective_on_lightProfinite : IsLocallySurjective f ↔\n    ∀ (S : LightProfinite) (y : Y.val.obj ⟨S⟩),\n      (∃ (S' : LightProfinite) (φ : S' ⟶ S) (_ : Function.Surjective φ) (x : X.val.obj ⟨S'⟩),\n        f.val.app ⟨S'⟩ x = Y.val.map ⟨φ⟩ y) := by\n  rw [coherentTopology.isLocallySurjective_iff,\n    regularTopology.isLocallySurjective_iff]\n  simp_rw [LightProfinite.effectiveEpi_iff_surjective]\n\n"}
{"name":"LightCondSet.epi_iff_locallySurjective_on_lightProfinite","module":"Mathlib.Condensed.Light.Epi","initialProofState":"X Y : LightCondSet\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.Epi f) (∀ (S : LightProfinite) (y : Y.val.obj { unop := S }), Exists fun S' => Exists fun φ => Exists fun x => Exists fun x => Eq (f.val.app { unop := S' } x) (Y.val.map { unop := φ } y))","decl":"lemma epi_iff_locallySurjective_on_lightProfinite : Epi f ↔\n    ∀ (S : LightProfinite) (y : Y.val.obj ⟨S⟩),\n      (∃ (S' : LightProfinite) (φ : S' ⟶ S) (_ : Function.Surjective φ) (x : X.val.obj ⟨S'⟩),\n        f.val.app ⟨S'⟩ x = Y.val.map ⟨φ⟩ y) := by\n  rw [← isLocallySurjective_iff_epi']\n  exact LightCondensed.isLocallySurjective_iff_locallySurjective_on_lightProfinite _ f\n\n"}
{"name":"LightCondMod.epi_iff_locallySurjective_on_lightProfinite","module":"Mathlib.Condensed.Light.Epi","initialProofState":"R : Type u\ninst✝ : Ring R\nX Y : LightCondMod R\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.Epi f) (∀ (S : LightProfinite) (y : ↑(Y.val.obj { unop := S })), Exists fun S' => Exists fun φ => Exists fun x => Exists fun x => Eq ((CategoryTheory.ConcreteCategory.hom (f.val.app { unop := S' })) x) ((CategoryTheory.ConcreteCategory.hom (Y.val.map { unop := φ })) y))","decl":"lemma epi_iff_locallySurjective_on_lightProfinite : Epi f ↔\n    ∀ (S : LightProfinite) (y : Y.val.obj ⟨S⟩),\n      (∃ (S' : LightProfinite) (φ : S' ⟶ S) (_ : Function.Surjective φ) (x : X.val.obj ⟨S'⟩),\n        f.val.app ⟨S'⟩ x = Y.val.map ⟨φ⟩ y) := by\n  rw [← isLocallySurjective_iff_epi']\n  exact LightCondensed.isLocallySurjective_iff_locallySurjective_on_lightProfinite _ f\n\n"}
{"name":"LightCondMod.instReflectsEpimorphismsLightCondSetForget","module":"Mathlib.Condensed.Light.Epi","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ (LightCondensed.forget R).ReflectsEpimorphisms","decl":"instance : (LightCondensed.forget R).ReflectsEpimorphisms where\n  reflects f hf := by\n    rw [← Sheaf.isLocallySurjective_iff_epi'] at hf ⊢\n    exact (Presheaf.isLocallySurjective_iff_whisker_forget _ f.val).mpr hf\n\n"}
{"name":"LightCondMod.instPreservesEpimorphismsLightCondSetForget","module":"Mathlib.Condensed.Light.Epi","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ (LightCondensed.forget R).PreservesEpimorphisms","decl":"instance : (LightCondensed.forget R).PreservesEpimorphisms where\n  preserves f hf := by\n    rw [← Sheaf.isLocallySurjective_iff_epi'] at hf ⊢\n    exact (Presheaf.isLocallySurjective_iff_whisker_forget _ f.val).mp hf\n\n"}
{"name":"LightCondensed.epi_π_app_zero_of_epi","module":"Mathlib.Condensed.Light.Epi","initialProofState":"R : Type u_1\ninst✝ : Ring R\nF : CategoryTheory.Functor (Opposite Nat) (LightCondMod R)\nc : CategoryTheory.Limits.Cone F\nhc : CategoryTheory.Limits.IsLimit c\nhF : ∀ (n : Nat), CategoryTheory.Epi (F.map (CategoryTheory.homOfLE ⋯).op)\n⊢ CategoryTheory.Epi (c.π.app { unop := 0 })","decl":"include hc hF in\nlemma epi_π_app_zero_of_epi : Epi (c.π.app ⟨0⟩) := by\n  apply Functor.epi_of_epi_map (forget R)\n  change Epi (((forget R).mapCone c).π.app ⟨0⟩)\n  apply coherentTopology.epi_π_app_zero_of_epi\n  · simp only [LightProfinite.effectiveEpi_iff_surjective]\n    exact fun _ h ↦ Concrete.surjective_π_app_zero_of_surjective_map (limit.isLimit _) h\n  · have := (freeForgetAdjunction R).isRightAdjoint\n    exact isLimitOfPreserves _ hc\n  · exact fun _ ↦ (forget R).map_epi _\n\n"}
{"name":"LightCondensed.instEpiLightCondModMapNat","module":"Mathlib.Condensed.Light.Epi","initialProofState":"R : Type u\ninst✝ : Ring R\nM N : Nat → LightCondMod R\nf : (n : Nat) → Quiver.Hom (M n) (N n)\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.Pi.map f)","decl":"instance : Epi (Limits.Pi.map f) := by\n  have : Limits.Pi.map f = (cone f).π.app ⟨0⟩ := rfl\n  rw [this]\n  exact epi_π_app_zero_of_epi R (isLimit f) (fun n ↦ by simp; infer_instance)\n\n"}
{"name":"LightCondensed.instPreservesEpimorphismsFunctorDiscreteNatLightCondModLim","module":"Mathlib.Condensed.Light.Epi","initialProofState":"R : Type u\ninst✝ : Ring R\n⊢ CategoryTheory.Limits.lim.PreservesEpimorphisms","decl":"instance : (lim (J := Discrete ℕ) (C := LightCondMod R)).PreservesEpimorphisms where\n  preserves f _ := by\n    have : lim.map f = (Pi.isoLimit _).inv ≫ Limits.Pi.map (f.app ⟨·⟩) ≫ (Pi.isoLimit _).hom := by\n      apply limit.hom_ext\n      intro ⟨n⟩\n      simp only [lim_obj, lim_map, limMap, IsLimit.map, limit.isLimit_lift, limit.lift_π,\n        Cones.postcompose_obj_pt, limit.cone_x, Cones.postcompose_obj_π, NatTrans.comp_app,\n        Functor.const_obj_obj, limit.cone_π, Pi.isoLimit, Limits.Pi.map, Category.assoc,\n        limit.conePointUniqueUpToIso_hom_comp, Pi.cone_pt, Pi.cone_π, Discrete.natTrans_app,\n        Discrete.functor_obj_eq_as]\n      erw [IsLimit.conePointUniqueUpToIso_inv_comp_assoc]\n      rfl\n    rw [this]\n    infer_instance\n\n"}
