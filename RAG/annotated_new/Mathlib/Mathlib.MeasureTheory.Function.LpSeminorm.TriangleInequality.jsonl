{"name":"MeasureTheory.eLpNorm'_add_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.TriangleInequality","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nq : Real\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí E\nhf : MeasureTheory.AEStronglyMeasurable f Œº\nhg : MeasureTheory.AEStronglyMeasurable g Œº\nhq1 : LE.le 1 q\n‚ä¢ LE.le (MeasureTheory.eLpNorm' (HAdd.hAdd f g) q Œº) (HAdd.hAdd (MeasureTheory.eLpNorm' f q Œº) (MeasureTheory.eLpNorm' g q Œº))","decl":"theorem eLpNorm'_add_le (hf : AEStronglyMeasurable f Œº) (hg : AEStronglyMeasurable g Œº)\n    (hq1 : 1 ‚â§ q) : eLpNorm' (f + g) q Œº ‚â§ eLpNorm' f q Œº + eLpNorm' g q Œº :=\n  calc\n    (‚à´‚Åª a, (‚Äñ(f + g) a‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ q ‚àÇŒº) ^ (1 / q) ‚â§\n        (‚à´‚Åª a, ((fun a => (‚Äñf a‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) + fun a => (‚Äñg a‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) a ^ q ‚àÇŒº) ^ (1 / q) := by\n      gcongr with a\n      simp only [Pi.add_apply, ‚Üê ENNReal.coe_add, ENNReal.coe_le_coe, nnnorm_add_le]\n    _ ‚â§ eLpNorm' f q Œº + eLpNorm' g q Œº := ENNReal.lintegral_Lp_add_le hf.enorm hg.enorm hq1\n\n"}
{"name":"MeasureTheory.eLpNorm'_add_le_of_le_one","module":"Mathlib.MeasureTheory.Function.LpSeminorm.TriangleInequality","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nq : Real\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí E\nhf : MeasureTheory.AEStronglyMeasurable f Œº\nhq0 : LE.le 0 q\nhq1 : LE.le q 1\n‚ä¢ LE.le (MeasureTheory.eLpNorm' (HAdd.hAdd f g) q Œº) (HMul.hMul (HPow.hPow 2 (HSub.hSub (HDiv.hDiv 1 q) 1)) (HAdd.hAdd (MeasureTheory.eLpNorm' f q Œº) (MeasureTheory.eLpNorm' g q Œº)))","decl":"theorem eLpNorm'_add_le_of_le_one (hf : AEStronglyMeasurable f Œº) (hq0 : 0 ‚â§ q) (hq1 : q ‚â§ 1) :\n    eLpNorm' (f + g) q Œº ‚â§ (2 : ‚Ñù‚â•0‚àû) ^ (1 / q - 1) * (eLpNorm' f q Œº + eLpNorm' g q Œº) :=\n  calc\n    (‚à´‚Åª a, (‚Äñ(f + g) a‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ q ‚àÇŒº) ^ (1 / q) ‚â§\n        (‚à´‚Åª a, ((fun a => (‚Äñf a‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) + fun a => (‚Äñg a‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) a ^ q ‚àÇŒº) ^ (1 / q) := by\n      gcongr with a\n      simp only [Pi.add_apply, ‚Üê ENNReal.coe_add, ENNReal.coe_le_coe, nnnorm_add_le]\n    _ ‚â§ (2 : ‚Ñù‚â•0‚àû) ^ (1 / q - 1) * (eLpNorm' f q Œº + eLpNorm' g q Œº) :=\n      ENNReal.lintegral_Lp_add_le_of_le_one hf.enorm hq0 hq1\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_add_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.TriangleInequality","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí E\n‚ä¢ LE.le (MeasureTheory.eLpNormEssSup (HAdd.hAdd f g) Œº) (HAdd.hAdd (MeasureTheory.eLpNormEssSup f Œº) (MeasureTheory.eLpNormEssSup g Œº))","decl":"theorem eLpNormEssSup_add_le {f g : Œ± ‚Üí E} :\n    eLpNormEssSup (f + g) Œº ‚â§ eLpNormEssSup f Œº + eLpNormEssSup g Œº := by\n  refine le_trans (essSup_mono_ae (Eventually.of_forall fun x => ?_)) (ENNReal.essSup_add_le _ _)\n  simp_rw [Pi.add_apply, enorm_eq_nnnorm, ‚Üê ENNReal.coe_add, ENNReal.coe_le_coe]\n  exact nnnorm_add_le _ _\n\n"}
{"name":"MeasureTheory.eLpNorm_add_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.TriangleInequality","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí E\nhf : MeasureTheory.AEStronglyMeasurable f Œº\nhg : MeasureTheory.AEStronglyMeasurable g Œº\nhp1 : LE.le 1 p\n‚ä¢ LE.le (MeasureTheory.eLpNorm (HAdd.hAdd f g) p Œº) (HAdd.hAdd (MeasureTheory.eLpNorm f p Œº) (MeasureTheory.eLpNorm g p Œº))","decl":"theorem eLpNorm_add_le {f g : Œ± ‚Üí E} (hf : AEStronglyMeasurable f Œº) (hg : AEStronglyMeasurable g Œº)\n    (hp1 : 1 ‚â§ p) : eLpNorm (f + g) p Œº ‚â§ eLpNorm f p Œº + eLpNorm g p Œº := by\n  by_cases hp0 : p = 0\n  ¬∑ simp [hp0]\n  by_cases hp_top : p = ‚àû\n  ¬∑ simp [hp_top, eLpNormEssSup_add_le]\n  have hp1_real : 1 ‚â§ p.toReal := by\n    rwa [‚Üê ENNReal.one_toReal, ENNReal.toReal_le_toReal ENNReal.one_ne_top hp_top]\n  repeat rw [eLpNorm_eq_eLpNorm' hp0 hp_top]\n  exact eLpNorm'_add_le hf hg hp1_real\n\n"}
{"name":"MeasureTheory.LpAddConst_of_one_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.TriangleInequality","initialProofState":"p : ENNReal\nhp : LE.le 1 p\n‚ä¢ Eq (MeasureTheory.LpAddConst p) 1","decl":"theorem LpAddConst_of_one_le {p : ‚Ñù‚â•0‚àû} (hp : 1 ‚â§ p) : LpAddConst p = 1 := by\n  rw [LpAddConst, if_neg]\n  intro h\n  exact lt_irrefl _ (h.2.trans_le hp)\n\n"}
{"name":"MeasureTheory.LpAddConst_zero","module":"Mathlib.MeasureTheory.Function.LpSeminorm.TriangleInequality","initialProofState":"‚ä¢ Eq (MeasureTheory.LpAddConst 0) 1","decl":"theorem LpAddConst_zero : LpAddConst 0 = 1 := by\n  rw [LpAddConst, if_neg]\n  intro h\n  exact lt_irrefl _ h.1\n\n"}
{"name":"MeasureTheory.LpAddConst_lt_top","module":"Mathlib.MeasureTheory.Function.LpSeminorm.TriangleInequality","initialProofState":"p : ENNReal\n‚ä¢ LT.lt (MeasureTheory.LpAddConst p) Top.top","decl":"theorem LpAddConst_lt_top (p : ‚Ñù‚â•0‚àû) : LpAddConst p < ‚àû := by\n  rw [LpAddConst]\n  split_ifs with h\n  ¬∑ apply ENNReal.rpow_lt_top_of_nonneg _ ENNReal.ofNat_ne_top\n    rw [one_div, sub_nonneg, ‚Üê ENNReal.toReal_inv, ‚Üê ENNReal.one_toReal]\n    exact ENNReal.toReal_mono (by simpa using h.1.ne') (ENNReal.one_le_inv.2 h.2.le)\n  ¬∑ exact ENNReal.one_lt_top\n\n"}
{"name":"MeasureTheory.eLpNorm_add_le'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.TriangleInequality","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí E\nhf : MeasureTheory.AEStronglyMeasurable f Œº\nhg : MeasureTheory.AEStronglyMeasurable g Œº\np : ENNReal\n‚ä¢ LE.le (MeasureTheory.eLpNorm (HAdd.hAdd f g) p Œº) (HMul.hMul (MeasureTheory.LpAddConst p) (HAdd.hAdd (MeasureTheory.eLpNorm f p Œº) (MeasureTheory.eLpNorm g p Œº)))","decl":"theorem eLpNorm_add_le' (hf : AEStronglyMeasurable f Œº) (hg : AEStronglyMeasurable g Œº)\n    (p : ‚Ñù‚â•0‚àû) : eLpNorm (f + g) p Œº ‚â§ LpAddConst p * (eLpNorm f p Œº + eLpNorm g p Œº) := by\n  rcases eq_or_ne p 0 with (rfl | hp)\n  ¬∑ simp only [eLpNorm_exponent_zero, add_zero, mul_zero, le_zero_iff]\n  rcases lt_or_le p 1 with (h'p | h'p)\n  ¬∑ simp only [eLpNorm_eq_eLpNorm' hp (h'p.trans ENNReal.one_lt_top).ne]\n    convert eLpNorm'_add_le_of_le_one hf ENNReal.toReal_nonneg _\n    ¬∑ have : p ‚àà Set.Ioo (0 : ‚Ñù‚â•0‚àû) 1 := ‚ü®hp.bot_lt, h'p‚ü©\n      simp only [LpAddConst, if_pos this]\n    ¬∑ simpa using ENNReal.toReal_mono ENNReal.one_ne_top h'p.le\n  ¬∑ simpa [LpAddConst_of_one_le h'p] using eLpNorm_add_le hf hg h'p\n\n"}
{"name":"MeasureTheory.exists_Lp_half","module":"Mathlib.MeasureTheory.Function.LpSeminorm.TriangleInequality","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\np Œ¥ : ENNReal\nhŒ¥ : Ne Œ¥ 0\n‚ä¢ Exists fun Œ∑ => And (LT.lt 0 Œ∑) (‚àÄ (f g : Œ± ‚Üí E), MeasureTheory.AEStronglyMeasurable f Œº ‚Üí MeasureTheory.AEStronglyMeasurable g Œº ‚Üí LE.le (MeasureTheory.eLpNorm f p Œº) Œ∑ ‚Üí LE.le (MeasureTheory.eLpNorm g p Œº) Œ∑ ‚Üí LT.lt (MeasureTheory.eLpNorm (HAdd.hAdd f g) p Œº) Œ¥)","decl":"/-- Technical lemma to control the addition of functions in `L^p` even for `p < 1`: Given `Œ¥ > 0`,\nthere exists `Œ∑` such that two functions bounded by `Œ∑` in `L^p` have a sum bounded by `Œ¥`. One\ncould take `Œ∑ = Œ¥ / 2` for `p ‚â• 1`, but the point of the lemma is that it works also for `p < 1`.\n-/\ntheorem exists_Lp_half (p : ‚Ñù‚â•0‚àû) {Œ¥ : ‚Ñù‚â•0‚àû} (hŒ¥ : Œ¥ ‚â† 0) :\n    ‚àÉ Œ∑ : ‚Ñù‚â•0‚àû,\n      0 < Œ∑ ‚àß\n        ‚àÄ (f g : Œ± ‚Üí E), AEStronglyMeasurable f Œº ‚Üí AEStronglyMeasurable g Œº ‚Üí\n          eLpNorm f p Œº ‚â§ Œ∑ ‚Üí eLpNorm g p Œº ‚â§ Œ∑ ‚Üí eLpNorm (f + g) p Œº < Œ¥ := by\n  have :\n    Tendsto (fun Œ∑ : ‚Ñù‚â•0‚àû => LpAddConst p * (Œ∑ + Œ∑)) (ùìù[>] 0) (ùìù (LpAddConst p * (0 + 0))) :=\n    (ENNReal.Tendsto.const_mul (tendsto_id.add tendsto_id)\n          (Or.inr (LpAddConst_lt_top p).ne)).mono_left\n      nhdsWithin_le_nhds\n  simp only [add_zero, mul_zero] at this\n  rcases (((tendsto_order.1 this).2 Œ¥ hŒ¥.bot_lt).and self_mem_nhdsWithin).exists with ‚ü®Œ∑, hŒ∑, Œ∑pos‚ü©\n  refine ‚ü®Œ∑, Œ∑pos, fun f g hf hg Hf Hg => ?_‚ü©\n  calc\n    eLpNorm (f + g) p Œº ‚â§ LpAddConst p * (eLpNorm f p Œº + eLpNorm g p Œº) := eLpNorm_add_le' hf hg p\n    _ ‚â§ LpAddConst p * (Œ∑ + Œ∑) := by gcongr\n    _ < Œ¥ := hŒ∑\n\n"}
{"name":"MeasureTheory.eLpNorm_sub_le'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.TriangleInequality","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí E\nhf : MeasureTheory.AEStronglyMeasurable f Œº\nhg : MeasureTheory.AEStronglyMeasurable g Œº\np : ENNReal\n‚ä¢ LE.le (MeasureTheory.eLpNorm (HSub.hSub f g) p Œº) (HMul.hMul (MeasureTheory.LpAddConst p) (HAdd.hAdd (MeasureTheory.eLpNorm f p Œº) (MeasureTheory.eLpNorm g p Œº)))","decl":"theorem eLpNorm_sub_le' (hf : AEStronglyMeasurable f Œº) (hg : AEStronglyMeasurable g Œº)\n    (p : ‚Ñù‚â•0‚àû) : eLpNorm (f - g) p Œº ‚â§ LpAddConst p * (eLpNorm f p Œº + eLpNorm g p Œº) := by\n  simpa only [sub_eq_add_neg, eLpNorm_neg] using eLpNorm_add_le' hf hg.neg p\n\n"}
{"name":"MeasureTheory.eLpNorm_sub_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.TriangleInequality","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí E\nhf : MeasureTheory.AEStronglyMeasurable f Œº\nhg : MeasureTheory.AEStronglyMeasurable g Œº\nhp : LE.le 1 p\n‚ä¢ LE.le (MeasureTheory.eLpNorm (HSub.hSub f g) p Œº) (HAdd.hAdd (MeasureTheory.eLpNorm f p Œº) (MeasureTheory.eLpNorm g p Œº))","decl":"theorem eLpNorm_sub_le {f g : Œ± ‚Üí E} (hf : AEStronglyMeasurable f Œº) (hg : AEStronglyMeasurable g Œº)\n    (hp : 1 ‚â§ p) : eLpNorm (f - g) p Œº ‚â§ eLpNorm f p Œº + eLpNorm g p Œº := by\n  simpa [LpAddConst_of_one_le hp] using eLpNorm_sub_le' hf hg p\n\n"}
{"name":"MeasureTheory.eLpNorm_add_lt_top","module":"Mathlib.MeasureTheory.Function.LpSeminorm.TriangleInequality","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nhg : MeasureTheory.Mem‚Ñíp g p Œº\n‚ä¢ LT.lt (MeasureTheory.eLpNorm (HAdd.hAdd f g) p Œº) Top.top","decl":"theorem eLpNorm_add_lt_top {f g : Œ± ‚Üí E} (hf : Mem‚Ñíp f p Œº) (hg : Mem‚Ñíp g p Œº) :\n    eLpNorm (f + g) p Œº < ‚àû :=\n  calc\n    eLpNorm (f + g) p Œº ‚â§ LpAddConst p * (eLpNorm f p Œº + eLpNorm g p Œº) :=\n      eLpNorm_add_le' hf.aestronglyMeasurable hg.aestronglyMeasurable p\n    _ < ‚àû := by\n      apply ENNReal.mul_lt_top (LpAddConst_lt_top p)\n      exact ENNReal.add_lt_top.2 ‚ü®hf.2, hg.2‚ü©\n\n"}
{"name":"MeasureTheory.eLpNorm'_sum_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.TriangleInequality","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\nq : Real\nŒº : MeasureTheory.Measure Œ±\nŒπ : Type u_3\nf : Œπ ‚Üí Œ± ‚Üí E\ns : Finset Œπ\nhfs : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí MeasureTheory.AEStronglyMeasurable (f i) Œº\nhq1 : LE.le 1 q\n‚ä¢ LE.le (MeasureTheory.eLpNorm' (s.sum fun i => f i) q Œº) (s.sum fun i => MeasureTheory.eLpNorm' (f i) q Œº)","decl":"theorem eLpNorm'_sum_le {Œπ} {f : Œπ ‚Üí Œ± ‚Üí E} {s : Finset Œπ}\n    (hfs : ‚àÄ i, i ‚àà s ‚Üí AEStronglyMeasurable (f i) Œº) (hq1 : 1 ‚â§ q) :\n    eLpNorm' (‚àë i ‚àà s, f i) q Œº ‚â§ ‚àë i ‚àà s, eLpNorm' (f i) q Œº :=\n  Finset.le_sum_of_subadditive_on_pred (fun f : Œ± ‚Üí E => eLpNorm' f q Œº)\n    (fun f => AEStronglyMeasurable f Œº) (eLpNorm'_zero (zero_lt_one.trans_le hq1))\n    (fun _f _g hf hg => eLpNorm'_add_le hf hg hq1) (fun _f _g hf hg => hf.add hg) _ hfs\n\n"}
{"name":"MeasureTheory.eLpNorm_sum_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.TriangleInequality","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nŒπ : Type u_3\nf : Œπ ‚Üí Œ± ‚Üí E\ns : Finset Œπ\nhfs : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí MeasureTheory.AEStronglyMeasurable (f i) Œº\nhp1 : LE.le 1 p\n‚ä¢ LE.le (MeasureTheory.eLpNorm (s.sum fun i => f i) p Œº) (s.sum fun i => MeasureTheory.eLpNorm (f i) p Œº)","decl":"theorem eLpNorm_sum_le {Œπ} {f : Œπ ‚Üí Œ± ‚Üí E} {s : Finset Œπ}\n    (hfs : ‚àÄ i, i ‚àà s ‚Üí AEStronglyMeasurable (f i) Œº) (hp1 : 1 ‚â§ p) :\n    eLpNorm (‚àë i ‚àà s, f i) p Œº ‚â§ ‚àë i ‚àà s, eLpNorm (f i) p Œº :=\n  Finset.le_sum_of_subadditive_on_pred (fun f : Œ± ‚Üí E => eLpNorm f p Œº)\n    (fun f => AEStronglyMeasurable f Œº) eLpNorm_zero (fun _f _g hf hg => eLpNorm_add_le hf hg hp1)\n    (fun _f _g hf hg => hf.add hg) _ hfs\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.add","module":"Mathlib.MeasureTheory.Function.LpSeminorm.TriangleInequality","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nhg : MeasureTheory.Mem‚Ñíp g p Œº\n‚ä¢ MeasureTheory.Mem‚Ñíp (HAdd.hAdd f g) p Œº","decl":"theorem Mem‚Ñíp.add {f g : Œ± ‚Üí E} (hf : Mem‚Ñíp f p Œº) (hg : Mem‚Ñíp g p Œº) : Mem‚Ñíp (f + g) p Œº :=\n  ‚ü®AEStronglyMeasurable.add hf.1 hg.1, eLpNorm_add_lt_top hf hg‚ü©\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.sub","module":"Mathlib.MeasureTheory.Function.LpSeminorm.TriangleInequality","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí E\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nhg : MeasureTheory.Mem‚Ñíp g p Œº\n‚ä¢ MeasureTheory.Mem‚Ñíp (HSub.hSub f g) p Œº","decl":"theorem Mem‚Ñíp.sub {f g : Œ± ‚Üí E} (hf : Mem‚Ñíp f p Œº) (hg : Mem‚Ñíp g p Œº) : Mem‚Ñíp (f - g) p Œº := by\n  rw [sub_eq_add_neg]\n  exact hf.add hg.neg\n\n"}
{"name":"MeasureTheory.mem‚Ñíp_finset_sum","module":"Mathlib.MeasureTheory.Function.LpSeminorm.TriangleInequality","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nŒπ : Type u_3\ns : Finset Œπ\nf : Œπ ‚Üí Œ± ‚Üí E\nhf : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí MeasureTheory.Mem‚Ñíp (f i) p Œº\n‚ä¢ MeasureTheory.Mem‚Ñíp (fun a => s.sum fun i => f i a) p Œº","decl":"theorem mem‚Ñíp_finset_sum {Œπ} (s : Finset Œπ) {f : Œπ ‚Üí Œ± ‚Üí E} (hf : ‚àÄ i ‚àà s, Mem‚Ñíp (f i) p Œº) :\n    Mem‚Ñíp (fun a => ‚àë i ‚àà s, f i a) p Œº := by\n  haveI : DecidableEq Œπ := Classical.decEq _\n  revert hf\n  refine Finset.induction_on s ?_ ?_\n  ¬∑ simp only [Mem‚Ñíp.zero', Finset.sum_empty, imp_true_iff]\n  ¬∑ intro i s his ih hf\n    simp only [his, Finset.sum_insert, not_false_iff]\n    exact (hf i (s.mem_insert_self i)).add (ih fun j hj => hf j (Finset.mem_insert_of_mem hj))\n\n"}
{"name":"MeasureTheory.mem‚Ñíp_finset_sum'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.TriangleInequality","initialProofState":"Œ± : Type u_1\nE : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup E\np : ENNReal\nŒº : MeasureTheory.Measure Œ±\nŒπ : Type u_3\ns : Finset Œπ\nf : Œπ ‚Üí Œ± ‚Üí E\nhf : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí MeasureTheory.Mem‚Ñíp (f i) p Œº\n‚ä¢ MeasureTheory.Mem‚Ñíp (s.sum fun i => f i) p Œº","decl":"theorem mem‚Ñíp_finset_sum' {Œπ} (s : Finset Œπ) {f : Œπ ‚Üí Œ± ‚Üí E} (hf : ‚àÄ i ‚àà s, Mem‚Ñíp (f i) p Œº) :\n    Mem‚Ñíp (‚àë i ‚àà s, f i) p Œº := by\n  convert mem‚Ñíp_finset_sum s hf using 1\n  ext x\n  simp\n\n"}
