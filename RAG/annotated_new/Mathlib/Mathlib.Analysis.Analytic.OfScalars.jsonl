{"name":"FormalMultilinearSeries.ofScalars_eq_zero","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : Field ğ•œ\ninstâœâ´ : Ring E\ninstâœÂ³ : Algebra ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalRing E\nc : Nat â†’ ğ•œ\ninstâœ : Nontrivial E\nn : Nat\nâŠ¢ Iff (Eq (FormalMultilinearSeries.ofScalars E c n) 0) (Eq (c n) 0)","decl":"@[simp]\ntheorem ofScalars_eq_zero [Nontrivial E] (n : â„•) : ofScalars E c n = 0 â†” c n = 0 := by\n  rw [ofScalars, smul_eq_zero (c := c n) (x := ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ n E)]\n  refine or_iff_left (ContinuousMultilinearMap.ext_iff.1.mt <| not_forall_of_exists_not ?_)\n  use fun _ â†¦ 1\n  simp\n\n"}
{"name":"FormalMultilinearSeries.ofScalars_eq_zero_of_scalar_zero","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : Field ğ•œ\ninstâœÂ³ : Ring E\ninstâœÂ² : Algebra ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : TopologicalRing E\nc : Nat â†’ ğ•œ\nn : Nat\nhc : Eq (c n) 0\nâŠ¢ Eq (FormalMultilinearSeries.ofScalars E c n) 0","decl":"@[simp]\ntheorem ofScalars_eq_zero_of_scalar_zero {n : â„•} (hc : c n = 0) : ofScalars E c n = 0 := by\n  rw [ofScalars, hc, zero_smul ğ•œ (ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ n E)]\n\n"}
{"name":"FormalMultilinearSeries.ofScalars_series_eq_zero","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : Field ğ•œ\ninstâœâ´ : Ring E\ninstâœÂ³ : Algebra ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalRing E\nc : Nat â†’ ğ•œ\ninstâœ : Nontrivial E\nâŠ¢ Iff (Eq (FormalMultilinearSeries.ofScalars E c) 0) (Eq c 0)","decl":"@[simp]\ntheorem ofScalars_series_eq_zero [Nontrivial E] : ofScalars E c = 0 â†” c = 0 := by\n  simp [FormalMultilinearSeries.ext_iff, funext_iff]\n\n"}
{"name":"FormalMultilinearSeries.ofScalars_series_eq_zero_of_scalar_zero","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : Field ğ•œ\ninstâœÂ³ : Ring E\ninstâœÂ² : Algebra ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : TopologicalRing E\nâŠ¢ Eq (FormalMultilinearSeries.ofScalars E 0) 0","decl":"variable (ğ•œ) in\n@[simp]\ntheorem ofScalars_series_eq_zero_of_scalar_zero : ofScalars E (0 : â„• â†’ ğ•œ) = 0 := by\n  simp [FormalMultilinearSeries.ext_iff]\n\n"}
{"name":"FormalMultilinearSeries.ofScalars_series_of_subsingleton","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : Field ğ•œ\ninstâœâ´ : Ring E\ninstâœÂ³ : Algebra ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalRing E\nc : Nat â†’ ğ•œ\ninstâœ : Subsingleton E\nâŠ¢ Eq (FormalMultilinearSeries.ofScalars E c) 0","decl":"@[simp]\ntheorem ofScalars_series_of_subsingleton [Subsingleton E] : ofScalars E c = 0 := by\n  simp_rw [FormalMultilinearSeries.ext_iff, ofScalars, ContinuousMultilinearMap.ext_iff]\n  exact fun _ _ â†¦ Subsingleton.allEq _ _\n\n"}
{"name":"FormalMultilinearSeries.ofScalars_series_injective","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : Field ğ•œ\ninstâœâ´ : Ring E\ninstâœÂ³ : Algebra ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalRing E\ninstâœ : Nontrivial E\nâŠ¢ Function.Injective (FormalMultilinearSeries.ofScalars E)","decl":"variable (ğ•œ) in\ntheorem ofScalars_series_injective [Nontrivial E] : Function.Injective (ofScalars E (ğ•œ := ğ•œ)) := by\n  intro _ _\n  refine Function.mtr fun h â†¦ ?_\n  simp_rw [FormalMultilinearSeries.ext_iff, ofScalars, ContinuousMultilinearMap.ext_iff,\n    ContinuousMultilinearMap.smul_apply]\n  push_neg\n  obtain âŸ¨n, hnâŸ© := Function.ne_iff.1 h\n  refine âŸ¨n, fun _ â†¦ 1, ?_âŸ©\n  simp only [mkPiAlgebraFin_apply, List.ofFn_const, List.prod_replicate, one_pow, ne_eq]\n  exact (smul_left_injective ğ•œ one_ne_zero).ne hn\n\n"}
{"name":"FormalMultilinearSeries.ofScalars_series_eq_iff","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : Field ğ•œ\ninstâœâ´ : Ring E\ninstâœÂ³ : Algebra ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalRing E\nc : Nat â†’ ğ•œ\ninstâœ : Nontrivial E\nc' : Nat â†’ ğ•œ\nâŠ¢ Iff (Eq (FormalMultilinearSeries.ofScalars E c) (FormalMultilinearSeries.ofScalars E c')) (Eq c c')","decl":"@[simp]\ntheorem ofScalars_series_eq_iff [Nontrivial E] (c' : â„• â†’ ğ•œ) :\n    ofScalars E c = ofScalars E c' â†” c = c' :=\n  âŸ¨fun e => ofScalars_series_injective ğ•œ E e, _root_.congrArg _âŸ©\n\n"}
{"name":"FormalMultilinearSeries.ofScalars_apply_zero","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : Field ğ•œ\ninstâœÂ³ : Ring E\ninstâœÂ² : Algebra ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : TopologicalRing E\nc : Nat â†’ ğ•œ\nn : Nat\nâŠ¢ Eq ((FormalMultilinearSeries.ofScalars E c n) fun x => 0) (Pi.single 0 (HSMul.hSMul (c 0) 1) n)","decl":"theorem ofScalars_apply_zero (n : â„•) :\n    (ofScalars E c n fun _ => 0) = Pi.single (f := fun _ => E) 0 (c 0 â€¢ 1) n := by\n  rw [ofScalars]\n  cases n <;> simp\n\n"}
{"name":"FormalMultilinearSeries.coeff_ofScalars","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_3\ninstâœ : NontriviallyNormedField ğ•œ\np : Nat â†’ ğ•œ\nn : Nat\nâŠ¢ Eq ((FormalMultilinearSeries.ofScalars ğ•œ p).coeff n) (p n)","decl":"@[simp]\nlemma coeff_ofScalars {ğ•œ : Type*} [NontriviallyNormedField ğ•œ] {p : â„• â†’ ğ•œ} {n : â„•} :\n    (FormalMultilinearSeries.ofScalars ğ•œ p).coeff n = p n := by\n  simp [FormalMultilinearSeries.coeff, FormalMultilinearSeries.ofScalars, List.prod_ofFn]\n\n"}
{"name":"FormalMultilinearSeries.ofScalars_add","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : Field ğ•œ\ninstâœÂ³ : Ring E\ninstâœÂ² : Algebra ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : TopologicalRing E\nc c' : Nat â†’ ğ•œ\nâŠ¢ Eq (FormalMultilinearSeries.ofScalars E (HAdd.hAdd c c')) (HAdd.hAdd (FormalMultilinearSeries.ofScalars E c) (FormalMultilinearSeries.ofScalars E c'))","decl":"theorem ofScalars_add (c' : â„• â†’ ğ•œ) : ofScalars E (c + c') = ofScalars E c + ofScalars E c' := by\n  unfold ofScalars\n  simp_rw [Pi.add_apply, Pi.add_def _ _]\n  exact funext fun n â†¦ Module.add_smul (c n) (c' n) (ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ n E)\n\n"}
{"name":"FormalMultilinearSeries.ofScalars_smul","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : Field ğ•œ\ninstâœÂ³ : Ring E\ninstâœÂ² : Algebra ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : TopologicalRing E\nc : Nat â†’ ğ•œ\nx : ğ•œ\nâŠ¢ Eq (FormalMultilinearSeries.ofScalars E (HSMul.hSMul x c)) (HSMul.hSMul x (FormalMultilinearSeries.ofScalars E c))","decl":"theorem ofScalars_smul (x : ğ•œ) : ofScalars E (x â€¢ c) = x â€¢ ofScalars E c := by\n  unfold ofScalars\n  simp [Pi.smul_def x _, smul_smul]\n\n"}
{"name":"FormalMultilinearSeries.ofScalars_apply_eq","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : Field ğ•œ\ninstâœÂ³ : Ring E\ninstâœÂ² : Algebra ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : TopologicalRing E\nc : Nat â†’ ğ•œ\nx : E\nn : Nat\nâŠ¢ Eq ((FormalMultilinearSeries.ofScalars E c n) fun x_1 => x) (HSMul.hSMul (c n) (HPow.hPow x n))","decl":"theorem ofScalars_apply_eq (x : E) (n : â„•) :\n    ofScalars E c n (fun _ â†¦ x) = c n â€¢ x ^ n := by\n  simp [ofScalars]\n\n"}
{"name":"FormalMultilinearSeries.ofScalars_apply_eq'","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : Field ğ•œ\ninstâœÂ³ : Ring E\ninstâœÂ² : Algebra ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : TopologicalRing E\nc : Nat â†’ ğ•œ\nx : E\nâŠ¢ Eq (fun n => (FormalMultilinearSeries.ofScalars E c n) fun x_1 => x) fun n => HSMul.hSMul (c n) (HPow.hPow x n)","decl":"/-- This naming follows the convention of `NormedSpace.expSeries_apply_eq'`. -/\ntheorem ofScalars_apply_eq' (x : E) :\n    (fun n â†¦ ofScalars E c n (fun _ â†¦ x)) = fun n â†¦ c n â€¢ x ^ n := by\n  simp [ofScalars]\n\n"}
{"name":"FormalMultilinearSeries.ofScalars_sum_eq","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : Field ğ•œ\ninstâœÂ³ : Ring E\ninstâœÂ² : Algebra ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : TopologicalRing E\nc : Nat â†’ ğ•œ\nx : E\nâŠ¢ Eq (FormalMultilinearSeries.ofScalarsSum c x) (tsum fun n => HSMul.hSMul (c n) (HPow.hPow x n))","decl":"theorem ofScalars_sum_eq (x : E) : ofScalarsSum c x =\n    âˆ‘' n, c n â€¢ x ^ n := tsum_congr fun n => ofScalars_apply_eq c x n\n\n"}
{"name":"FormalMultilinearSeries.ofScalarsSum_eq_tsum","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : Field ğ•œ\ninstâœÂ³ : Ring E\ninstâœÂ² : Algebra ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : TopologicalRing E\nc : Nat â†’ ğ•œ\nâŠ¢ Eq (FormalMultilinearSeries.ofScalarsSum c) fun x => tsum fun n => HSMul.hSMul (c n) (HPow.hPow x n)","decl":"theorem ofScalarsSum_eq_tsum : ofScalarsSum c =\n    fun (x : E) => âˆ‘' n : â„•, c n â€¢ x ^ n := funext (ofScalars_sum_eq c)\n\n"}
{"name":"FormalMultilinearSeries.ofScalarsSum_zero","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ´ : Field ğ•œ\ninstâœÂ³ : Ring E\ninstâœÂ² : Algebra ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : TopologicalRing E\nc : Nat â†’ ğ•œ\nâŠ¢ Eq (FormalMultilinearSeries.ofScalarsSum c 0) (HSMul.hSMul (c 0) 1)","decl":"@[simp]\ntheorem ofScalarsSum_zero : ofScalarsSum c (0 : E) = c 0 â€¢ 1 := by\n  simp [ofScalarsSum_eq_tsum, â† ofScalars_apply_eq, ofScalars_apply_zero]\n\n"}
{"name":"FormalMultilinearSeries.ofScalarsSum_of_subsingleton","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : Field ğ•œ\ninstâœâ´ : Ring E\ninstâœÂ³ : Algebra ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalRing E\nc : Nat â†’ ğ•œ\ninstâœ : Subsingleton E\nx : E\nâŠ¢ Eq (FormalMultilinearSeries.ofScalarsSum c x) 0","decl":"@[simp]\ntheorem ofScalarsSum_of_subsingleton [Subsingleton E] {x : E} : ofScalarsSum c x = 0 := by\n  simp [Subsingleton.eq_zero x, Subsingleton.eq_zero (1 : E)]\n\n"}
{"name":"FormalMultilinearSeries.ofScalarsSum_op","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : Field ğ•œ\ninstâœâ´ : Ring E\ninstâœÂ³ : Algebra ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalRing E\nc : Nat â†’ ğ•œ\ninstâœ : T2Space E\nx : E\nâŠ¢ Eq (FormalMultilinearSeries.ofScalarsSum c (MulOpposite.op x)) (MulOpposite.op (FormalMultilinearSeries.ofScalarsSum c x))","decl":"@[simp]\ntheorem ofScalarsSum_op [T2Space E] (x : E) :\n    ofScalarsSum c (MulOpposite.op x) = MulOpposite.op (ofScalarsSum c x) := by\n  simp [ofScalars, ofScalars_sum_eq, â† MulOpposite.op_pow, â† MulOpposite.op_smul, tsum_op]\n\n"}
{"name":"FormalMultilinearSeries.ofScalarsSum_unop","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : Field ğ•œ\ninstâœâ´ : Ring E\ninstâœÂ³ : Algebra ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalRing E\nc : Nat â†’ ğ•œ\ninstâœ : T2Space E\nx : MulOpposite E\nâŠ¢ Eq (FormalMultilinearSeries.ofScalarsSum c (MulOpposite.unop x)) (MulOpposite.unop (FormalMultilinearSeries.ofScalarsSum c x))","decl":"@[simp]\ntheorem ofScalarsSum_unop [T2Space E] (x : Eáµáµ’áµ–) :\n    ofScalarsSum c (MulOpposite.unop x) = MulOpposite.unop (ofScalarsSum c x) := by\n  simp [ofScalars, ofScalars_sum_eq, â† MulOpposite.unop_pow, â† MulOpposite.unop_smul, tsum_unop]\n\n"}
{"name":"FormalMultilinearSeries.ofScalars_norm_eq_mul","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : SeminormedRing E\ninstâœ : NormedAlgebra ğ•œ E\nc : Nat â†’ ğ•œ\nn : Nat\nâŠ¢ Eq (Norm.norm (FormalMultilinearSeries.ofScalars E c n)) (HMul.hMul (Norm.norm (c n)) (Norm.norm (ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ n E)))","decl":"set_option maxSynthPendingDepth 2 in\ntheorem ofScalars_norm_eq_mul :\n    â€–ofScalars E c nâ€– = â€–c nâ€– * â€–ContinuousMultilinearMap.mkPiAlgebraFin ğ•œ n Eâ€– := by\n  set_option maxSynthPendingDepth 2 in\n  rw [ofScalars, norm_smul]\n\n"}
{"name":"FormalMultilinearSeries.ofScalars_norm_le","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : SeminormedRing E\ninstâœ : NormedAlgebra ğ•œ E\nc : Nat â†’ ğ•œ\nn : Nat\nhn : GT.gt n 0\nâŠ¢ LE.le (Norm.norm (FormalMultilinearSeries.ofScalars E c n)) (Norm.norm (c n))","decl":"theorem ofScalars_norm_le (hn : n > 0) : â€–ofScalars E c nâ€– â‰¤ â€–c nâ€– := by\n  simp only [ofScalars_norm_eq_mul]\n  exact (mul_le_of_le_one_right (norm_nonneg _)\n    (ContinuousMultilinearMap.norm_mkPiAlgebraFin_le_of_pos hn))\n\n"}
{"name":"FormalMultilinearSeries.ofScalars_norm","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : SeminormedRing E\ninstâœÂ¹ : NormedAlgebra ğ•œ E\nc : Nat â†’ ğ•œ\nn : Nat\ninstâœ : NormOneClass E\nâŠ¢ Eq (Norm.norm (FormalMultilinearSeries.ofScalars E c n)) (Norm.norm (c n))","decl":"@[simp]\ntheorem ofScalars_norm [NormOneClass E] : â€–ofScalars E c nâ€– = â€–c nâ€– := by\n  simp [ofScalars_norm_eq_mul]\n\n"}
{"name":"FormalMultilinearSeries.ofScalars_radius_ge_inv_of_tendsto","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedRing E\ninstâœ : NormedAlgebra ğ•œ E\nc : Nat â†’ ğ•œ\nr : NNReal\nhr : Ne r 0\nhc : Filter.Tendsto (fun n => HDiv.hDiv (Norm.norm (c n.succ)) (Norm.norm (c n))) Filter.atTop (nhds â†‘r)\nâŠ¢ GE.ge (FormalMultilinearSeries.ofScalars E c).radius â†‘(Inv.inv r)","decl":"theorem ofScalars_radius_ge_inv_of_tendsto {r : â„â‰¥0} (hr : r â‰  0)\n    (hc : Tendsto (fun n â†¦ â€–c n.succâ€– / â€–c nâ€–) atTop (ğ“ r)) :\n      (ofScalars E c).radius â‰¥ ofNNReal râ»Â¹ := by\n  refine le_of_forall_nnreal_lt (fun r' hr' â†¦ ?_)\n  rw [coe_lt_coe, NNReal.lt_inv_iff_mul_lt hr] at hr'\n  by_cases hrz : r' = 0\n  Â· simp [hrz]\n  apply FormalMultilinearSeries.le_radius_of_summable_norm\n  refine Summable.of_norm_bounded_eventually (fun n â†¦ â€–â€–c nâ€– * r' ^ nâ€–) ?_ ?_\n  Â· refine summable_of_ratio_test_tendsto_lt_one hr' ?_ ?_\n    Â· refine (hc.eventually_ne (NNReal.coe_ne_zero.mpr hr)).mp (Eventually.of_forall ?_)\n      aesop\n    Â· simp_rw [norm_norm]\n      exact tendsto_succ_norm_div_norm c hrz hc\n  Â· filter_upwards [eventually_cofinite_ne 0] with n hn\n    simp only [norm_mul, norm_norm, norm_pow, NNReal.norm_eq]\n    gcongr\n    exact ofScalars_norm_le E c n (Nat.pos_iff_ne_zero.mpr hn)\n\n"}
{"name":"FormalMultilinearSeries.ofScalars_radius_eq_inv_of_tendsto","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedRing E\ninstâœÂ¹ : NormedAlgebra ğ•œ E\nc : Nat â†’ ğ•œ\ninstâœ : NormOneClass E\nr : NNReal\nhr : Ne r 0\nhc : Filter.Tendsto (fun n => HDiv.hDiv (Norm.norm (c n.succ)) (Norm.norm (c n))) Filter.atTop (nhds â†‘r)\nâŠ¢ Eq (FormalMultilinearSeries.ofScalars E c).radius â†‘(Inv.inv r)","decl":"/-- The radius of convergence of a scalar series is the inverse of the non-zero limit\n`fun n â†¦ â€–c n.succâ€– / â€–c nâ€–`. -/\ntheorem ofScalars_radius_eq_inv_of_tendsto [NormOneClass E] {r : â„â‰¥0} (hr : r â‰  0)\n    (hc : Tendsto (fun n â†¦ â€–c n.succâ€– / â€–c nâ€–) atTop (ğ“ r)) :\n      (ofScalars E c).radius = ofNNReal râ»Â¹ := by\n  refine le_antisymm ?_ (ofScalars_radius_ge_inv_of_tendsto E c hr hc)\n  refine le_of_forall_nnreal_lt (fun r' hr' â†¦ ?_)\n  rw [coe_le_coe, NNReal.le_inv_iff_mul_le hr]\n  have := FormalMultilinearSeries.summable_norm_mul_pow _ hr'\n  contrapose! this\n  apply not_summable_of_ratio_test_tendsto_gt_one this\n  simp_rw [ofScalars_norm]\n  exact tendsto_succ_norm_div_norm c (by aesop) hc\n\n"}
{"name":"FormalMultilinearSeries.ofScalars_radius_eq_of_tendsto","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedRing E\ninstâœÂ¹ : NormedAlgebra ğ•œ E\nc : Nat â†’ ğ•œ\ninstâœ : NormOneClass E\nr : NNReal\nhr : Ne r 0\nhc : Filter.Tendsto (fun n => HDiv.hDiv (Norm.norm (c n)) (Norm.norm (c n.succ))) Filter.atTop (nhds â†‘r)\nâŠ¢ Eq (FormalMultilinearSeries.ofScalars E c).radius â†‘r","decl":"/-- A convenience lemma restating the result of `ofScalars_radius_eq_inv_of_tendsto` under\nthe inverse ratio. -/\ntheorem ofScalars_radius_eq_of_tendsto [NormOneClass E] {r : NNReal} (hr : r â‰  0)\n    (hc : Tendsto (fun n â†¦ â€–c nâ€– / â€–c n.succâ€–) atTop (ğ“ r)) :\n      (ofScalars E c).radius = ofNNReal r := by\n  suffices Tendsto (fun n â†¦ â€–c n.succâ€– / â€–c nâ€–) atTop (ğ“ râ»Â¹) by\n    convert ofScalars_radius_eq_inv_of_tendsto E c (inv_ne_zero hr) this\n    simp\n  convert hc.invâ‚€ (NNReal.coe_ne_zero.mpr hr) using 1\n  simp\n\n"}
{"name":"FormalMultilinearSeries.ofScalars_radius_eq_top_of_tendsto","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedRing E\ninstâœ : NormedAlgebra ğ•œ E\nc : Nat â†’ ğ•œ\nhc : Filter.Eventually (fun n => Ne (c n) 0) Filter.atTop\nhc' : Filter.Tendsto (fun n => HDiv.hDiv (Norm.norm (c n.succ)) (Norm.norm (c n))) Filter.atTop (nhds 0)\nâŠ¢ Eq (FormalMultilinearSeries.ofScalars E c).radius Top.top","decl":"/-- The ratio test stating that if `â€–c n.succâ€– / â€–c nâ€–` tends to zero, the radius is unbounded.\nThis requires that the coefficients are eventually non-zero as\n`â€–c n.succâ€– / 0 = 0` by convention. -/\ntheorem ofScalars_radius_eq_top_of_tendsto (hc : âˆ€á¶  n in atTop, c n â‰  0)\n    (hc' : Tendsto (fun n â†¦ â€–c n.succâ€– / â€–c nâ€–) atTop (ğ“ 0)) : (ofScalars E c).radius = âŠ¤ := by\n  refine radius_eq_top_of_summable_norm _ fun r' â†¦ ?_\n  by_cases hrz : r' = 0\n  Â· apply Summable.comp_nat_add (k := 1)\n    simp [hrz]\n    exact (summable_const_iff 0).mpr rfl\n  Â· refine Summable.of_norm_bounded_eventually (fun n â†¦ â€–â€–c nâ€– * r' ^ nâ€–) ?_ ?_\n    Â· apply summable_of_ratio_test_tendsto_lt_one zero_lt_one (hc.mp (Eventually.of_forall ?_))\n      Â· simp only [norm_norm]\n        exact mul_zero (_ : â„) â–¸ tendsto_succ_norm_div_norm _ hrz (NNReal.coe_zero â–¸ hc')\n      Â· aesop\n    Â· filter_upwards [eventually_cofinite_ne 0] with n hn\n      simp only [norm_mul, norm_norm, norm_pow, NNReal.norm_eq]\n      gcongr\n      exact ofScalars_norm_le E c n (Nat.pos_iff_ne_zero.mpr hn)\n\n"}
{"name":"FormalMultilinearSeries.ofScalars_radius_eq_zero_of_tendsto","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedRing E\ninstâœÂ¹ : NormedAlgebra ğ•œ E\nc : Nat â†’ ğ•œ\ninstâœ : NormOneClass E\nhc : Filter.Tendsto (fun n => HDiv.hDiv (Norm.norm (c n.succ)) (Norm.norm (c n))) Filter.atTop Filter.atTop\nâŠ¢ Eq (FormalMultilinearSeries.ofScalars E c).radius 0","decl":"/-- If `â€–c n.succâ€– / â€–c nâ€–` is unbounded, then the radius of convergence is zero. -/\ntheorem ofScalars_radius_eq_zero_of_tendsto [NormOneClass E]\n    (hc : Tendsto (fun n â†¦ â€–c n.succâ€– / â€–c nâ€–) atTop atTop) : (ofScalars E c).radius = 0 := by\n  suffices (ofScalars E c).radius â‰¤ 0 by aesop\n  refine le_of_forall_nnreal_lt (fun r hr â†¦ ?_)\n  rw [â† coe_zero, coe_le_coe]\n  have := FormalMultilinearSeries.summable_norm_mul_pow _ hr\n  contrapose! this\n  apply not_summable_of_ratio_norm_eventually_ge one_lt_two\n  Â· contrapose! hc\n    apply not_tendsto_atTop_of_tendsto_nhds (a:=0)\n    rw [not_frequently] at hc\n    apply Tendsto.congr' ?_ tendsto_const_nhds\n    filter_upwards [hc] with n hc'\n    rw [ofScalars_norm, norm_mul, norm_norm, not_ne_iff, mul_eq_zero] at hc'\n    cases hc' <;> aesop\n  Â· filter_upwards [hc.eventually_ge_atTop (2*râ»Â¹), eventually_ne_atTop 0] with n hc hn\n    simp only [ofScalars_norm, norm_mul, norm_norm, norm_pow, NNReal.norm_eq]\n    rw [mul_comm â€–c nâ€–, â† mul_assoc, â† div_le_div_iffâ‚€, mul_div_assoc]\n    Â· convert hc\n      rw [pow_succ, div_mul_cancel_leftâ‚€, NNReal.coe_inv]\n      aesop\n    Â· aesop\n    Â· refine Ne.lt_of_le (fun hr' â†¦ Not.elim ?_ hc) (norm_nonneg _)\n      rw [â† hr']\n      simp [this]\n\n"}
{"name":"FormalMultilinearSeries.ofScalars_radius_eq_inv_of_tendsto_ENNReal","module":"Mathlib.Analysis.Analytic.OfScalars","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedRing E\ninstâœÂ¹ : NormedAlgebra ğ•œ E\nc : Nat â†’ ğ•œ\ninstâœ : NormOneClass E\nr : ENNReal\nhc' : Filter.Tendsto (fun n => HDiv.hDiv (ENNReal.ofReal (Norm.norm (c n.succ))) (ENNReal.ofReal (Norm.norm (c n)))) Filter.atTop (nhds r)\nâŠ¢ Eq (FormalMultilinearSeries.ofScalars E c).radius (Inv.inv r)","decl":"/-- This theorem combines the results of the special cases above, using `ENNReal` division to remove\nthe requirement that the ratio is eventually non-zero. -/\ntheorem ofScalars_radius_eq_inv_of_tendsto_ENNReal [NormOneClass E] {r : â„â‰¥0âˆ}\n    (hc' : Tendsto (fun n â†¦ ENNReal.ofReal â€–c n.succâ€– / ENNReal.ofReal â€–c nâ€–) atTop (ğ“ r)) :\n      (ofScalars E c).radius = râ»Â¹ := by\n  rcases ENNReal.trichotomy r with (hr | hr | hr)\n  Â· simp_rw [hr, inv_zero] at hc' âŠ¢\n    by_cases h : (âˆ€á¶  (n : â„•) in atTop, c n â‰  0)\n    Â· apply ofScalars_radius_eq_top_of_tendsto E c h ?_\n      refine Tendsto.congr' ?_ <| (tendsto_toReal zero_ne_top).comp hc'\n      filter_upwards [h]\n      simp\n    Â· apply (ofScalars E c).radius_eq_top_of_eventually_eq_zero\n      simp only [eventually_atTop, not_exists, not_forall, Classical.not_imp, not_not] at h âŠ¢\n      obtain âŸ¨ti, htiâŸ© := eventually_atTop.mp (hc'.eventually_ne zero_ne_top)\n      obtain âŸ¨zi, hzi, zâŸ© := h ti\n      refine âŸ¨zi, Nat.le_induction (ofScalars_eq_zero_of_scalar_zero E z) fun n hmn a â†¦ ?_âŸ©\n      nontriviality E\n      simp only [ofScalars_eq_zero] at a âŠ¢\n      contrapose! hti\n      exact âŸ¨n, hzi.trans hmn, ENNReal.div_eq_top.mpr (by simp [a, hti])âŸ©\n  Â· simp_rw [hr, inv_top] at hc' âŠ¢\n    apply ofScalars_radius_eq_zero_of_tendsto E c ((tendsto_add_atTop_iff_nat 1).mp ?_)\n    refine tendsto_ofReal_nhds_top.mp (Tendsto.congr' ?_ ((tendsto_add_atTop_iff_nat 1).mpr hc'))\n    filter_upwards [hc'.eventually_ne top_ne_zero] with n hn\n    apply (ofReal_div_of_pos (Ne.lt_of_le (Ne.symm ?_) (norm_nonneg _))).symm\n    aesop\n  Â· have hr' := toReal_ne_zero.mp hr.ne.symm\n    have hr'' := toNNReal_ne_zero.mpr hr' -- this result could go in ENNReal\n    convert ofScalars_radius_eq_inv_of_tendsto E c hr'' ?_\n    Â· simp [ENNReal.coe_inv hr'', ENNReal.coe_toNNReal (toReal_ne_zero.mp hr.ne.symm).2]\n    Â· simp_rw [ENNReal.coe_toNNReal_eq_toReal]\n      refine Tendsto.congr' ?_ <| (tendsto_toReal hr'.2).comp hc'\n      filter_upwards [hc'.eventually_ne hr'.1, hc'.eventually_ne hr'.2]\n      simp\n\n"}
