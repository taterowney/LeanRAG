{"name":"CategoryTheory.whiskerLeft_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG H : CategoryTheory.Functor D E\nα : Quiver.Hom G H\nX : C\n⊢ Eq ((CategoryTheory.whiskerLeft F α).app X) (α.app (F.obj X))","decl":"/-- If `α : G ⟶ H` then\n`whiskerLeft F α : (F ⋙ G) ⟶ (F ⋙ H)` has components `α.app (F.obj X)`.\n-/\n@[simps]\ndef whiskerLeft (F : C ⥤ D) {G H : D ⥤ E} (α : G ⟶ H) :\n    F ⋙ G ⟶ F ⋙ H where\n  app X := α.app (F.obj X)\n  naturality X Y f := by rw [Functor.comp_map, Functor.comp_map, α.naturality]\n\n"}
{"name":"CategoryTheory.whiskerRight_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG H : CategoryTheory.Functor C D\nα : Quiver.Hom G H\nF : CategoryTheory.Functor D E\nX : C\n⊢ Eq ((CategoryTheory.whiskerRight α F).app X) (F.map (α.app X))","decl":"/-- If `α : G ⟶ H` then\n`whisker_right α F : (G ⋙ F) ⟶ (G ⋙ F)` has components `F.map (α.app X)`.\n-/\n@[simps]\ndef whiskerRight {G H : C ⥤ D} (α : G ⟶ H) (F : D ⥤ E) :\n    G ⋙ F ⟶ H ⋙ F where\n  app X := F.map (α.app X)\n  naturality X Y f := by\n    rw [Functor.comp_map, Functor.comp_map, ← F.map_comp, ← F.map_comp, α.naturality]\n\n"}
{"name":"CategoryTheory.whiskeringLeft_obj_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\n⊢ Eq (((CategoryTheory.whiskeringLeft C D E).obj F).obj G) (F.comp G)","decl":"/-- Left-composition gives a functor `(C ⥤ D) ⥤ ((D ⥤ E) ⥤ (C ⥤ E))`.\n\n`(whiskeringLeft.obj F).obj G` is `F ⋙ G`, and\n`(whiskeringLeft.obj F).map α` is `whiskerLeft F α`.\n-/\n@[simps]\ndef whiskeringLeft : (C ⥤ D) ⥤ (D ⥤ E) ⥤ C ⥤ E where\n  obj F :=\n    { obj := fun G => F ⋙ G\n      map := fun α => whiskerLeft F α }\n  map τ :=\n    { app := fun H =>\n        { app := fun c => H.map (τ.app c)\n          naturality := fun X Y f => by dsimp; rw [← H.map_comp, ← H.map_comp, ← τ.naturality] }\n      naturality := fun X Y f => by ext; dsimp; rw [f.naturality] }\n\n"}
{"name":"CategoryTheory.whiskeringLeft_map_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nX✝ Y✝ : CategoryTheory.Functor C D\nτ : Quiver.Hom X✝ Y✝\nH : CategoryTheory.Functor D E\nc : C\n⊢ Eq ((((CategoryTheory.whiskeringLeft C D E).map τ).app H).app c) (H.map (τ.app c))","decl":"/-- Left-composition gives a functor `(C ⥤ D) ⥤ ((D ⥤ E) ⥤ (C ⥤ E))`.\n\n`(whiskeringLeft.obj F).obj G` is `F ⋙ G`, and\n`(whiskeringLeft.obj F).map α` is `whiskerLeft F α`.\n-/\n@[simps]\ndef whiskeringLeft : (C ⥤ D) ⥤ (D ⥤ E) ⥤ C ⥤ E where\n  obj F :=\n    { obj := fun G => F ⋙ G\n      map := fun α => whiskerLeft F α }\n  map τ :=\n    { app := fun H =>\n        { app := fun c => H.map (τ.app c)\n          naturality := fun X Y f => by dsimp; rw [← H.map_comp, ← H.map_comp, ← τ.naturality] }\n      naturality := fun X Y f => by ext; dsimp; rw [f.naturality] }\n\n"}
{"name":"CategoryTheory.whiskeringLeft_obj_map","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nX✝ Y✝ : CategoryTheory.Functor D E\nα : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.whiskeringLeft C D E).obj F).map α) (CategoryTheory.whiskerLeft F α)","decl":"/-- Left-composition gives a functor `(C ⥤ D) ⥤ ((D ⥤ E) ⥤ (C ⥤ E))`.\n\n`(whiskeringLeft.obj F).obj G` is `F ⋙ G`, and\n`(whiskeringLeft.obj F).map α` is `whiskerLeft F α`.\n-/\n@[simps]\ndef whiskeringLeft : (C ⥤ D) ⥤ (D ⥤ E) ⥤ C ⥤ E where\n  obj F :=\n    { obj := fun G => F ⋙ G\n      map := fun α => whiskerLeft F α }\n  map τ :=\n    { app := fun H =>\n        { app := fun c => H.map (τ.app c)\n          naturality := fun X Y f => by dsimp; rw [← H.map_comp, ← H.map_comp, ← τ.naturality] }\n      naturality := fun X Y f => by ext; dsimp; rw [f.naturality] }\n\n"}
{"name":"CategoryTheory.whiskeringRight_map_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nX✝ Y✝ : CategoryTheory.Functor D E\nτ : Quiver.Hom X✝ Y✝\nF : CategoryTheory.Functor C D\nc : C\n⊢ Eq ((((CategoryTheory.whiskeringRight C D E).map τ).app F).app c) (τ.app (F.obj c))","decl":"/-- Right-composition gives a functor `(D ⥤ E) ⥤ ((C ⥤ D) ⥤ (C ⥤ E))`.\n\n`(whiskeringRight.obj H).obj F` is `F ⋙ H`, and\n`(whiskeringRight.obj H).map α` is `whiskerRight α H`.\n-/\n@[simps]\ndef whiskeringRight : (D ⥤ E) ⥤ (C ⥤ D) ⥤ C ⥤ E where\n  obj H :=\n    { obj := fun F => F ⋙ H\n      map := fun α => whiskerRight α H }\n  map τ :=\n    { app := fun F =>\n        { app := fun c => τ.app (F.obj c)\n          naturality := fun X Y f => by dsimp; rw [τ.naturality] }\n      naturality := fun X Y f => by ext; dsimp; rw [← NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.whiskeringRight_obj_map","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nH : CategoryTheory.Functor D E\nX✝ Y✝ : CategoryTheory.Functor C D\nα : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.whiskeringRight C D E).obj H).map α) (CategoryTheory.whiskerRight α H)","decl":"/-- Right-composition gives a functor `(D ⥤ E) ⥤ ((C ⥤ D) ⥤ (C ⥤ E))`.\n\n`(whiskeringRight.obj H).obj F` is `F ⋙ H`, and\n`(whiskeringRight.obj H).map α` is `whiskerRight α H`.\n-/\n@[simps]\ndef whiskeringRight : (D ⥤ E) ⥤ (C ⥤ D) ⥤ C ⥤ E where\n  obj H :=\n    { obj := fun F => F ⋙ H\n      map := fun α => whiskerRight α H }\n  map τ :=\n    { app := fun F =>\n        { app := fun c => τ.app (F.obj c)\n          naturality := fun X Y f => by dsimp; rw [τ.naturality] }\n      naturality := fun X Y f => by ext; dsimp; rw [← NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.whiskeringRight_obj_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nH : CategoryTheory.Functor D E\nF : CategoryTheory.Functor C D\n⊢ Eq (((CategoryTheory.whiskeringRight C D E).obj H).obj F) (F.comp H)","decl":"/-- Right-composition gives a functor `(D ⥤ E) ⥤ ((C ⥤ D) ⥤ (C ⥤ E))`.\n\n`(whiskeringRight.obj H).obj F` is `F ⋙ H`, and\n`(whiskeringRight.obj H).map α` is `whiskerRight α H`.\n-/\n@[simps]\ndef whiskeringRight : (D ⥤ E) ⥤ (C ⥤ D) ⥤ C ⥤ E where\n  obj H :=\n    { obj := fun F => F ⋙ H\n      map := fun α => whiskerRight α H }\n  map τ :=\n    { app := fun F =>\n        { app := fun c => τ.app (F.obj c)\n          naturality := fun X Y f => by dsimp; rw [τ.naturality] }\n      naturality := fun X Y f => by ext; dsimp; rw [← NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.faithful_whiskeringRight_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor D E\ninst✝ : F.Faithful\n⊢ ((CategoryTheory.whiskeringRight C D E).obj F).Faithful","decl":"instance faithful_whiskeringRight_obj {F : D ⥤ E} [F.Faithful] :\n    ((whiskeringRight C D E).obj F).Faithful where\n  map_injective hαβ := by\n    ext X\n    exact F.map_injective <| congr_fun (congr_arg NatTrans.app hαβ) X\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.whiskeringRight_preimage_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"D : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor D E\nhF : F.FullyFaithful\nC : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX✝ Y✝ : CategoryTheory.Functor C D\nf : Quiver.Hom (((CategoryTheory.whiskeringRight C D E).obj F).obj X✝) (((CategoryTheory.whiskeringRight C D E).obj F).obj Y✝)\nX : C\n⊢ Eq (((hF.whiskeringRight C).preimage f).app X) (hF.preimage (f.app X))","decl":"/-- If `F : D ⥤ E` is fully faithful, then so is\n`(whiskeringRight C D E).obj F : (C ⥤ D) ⥤ C ⥤ E`. -/\n@[simps]\ndef Functor.FullyFaithful.whiskeringRight {F : D ⥤ E} (hF : F.FullyFaithful)\n    (C : Type*) [Category C] :\n    ((whiskeringRight C D E).obj F).FullyFaithful where\n  preimage f :=\n    { app := fun X => hF.preimage (f.app X)\n      naturality := fun _ _ g => by\n        apply hF.map_injective\n        dsimp\n        simp only [map_comp, map_preimage]\n        apply f.naturality }\n\n"}
{"name":"CategoryTheory.whiskeringLeft_obj_id","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\n⊢ Eq ((CategoryTheory.whiskeringLeft C C E).obj (CategoryTheory.Functor.id C)) (CategoryTheory.Functor.id (CategoryTheory.Functor C E))","decl":"theorem whiskeringLeft_obj_id : (whiskeringLeft C C E).obj (𝟭 _) = 𝟭 _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskeringLeft_obj_comp","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D D'\n⊢ Eq ((CategoryTheory.whiskeringLeft C D' E).obj (F.comp G)) (((CategoryTheory.whiskeringLeft D D' E).obj G).comp ((CategoryTheory.whiskeringLeft C D E).obj F))","decl":"theorem whiskeringLeft_obj_comp {D' : Type u₄} [Category.{v₄} D'] (F : C ⥤ D) (G : D ⥤ D') :\n    (whiskeringLeft C D' E).obj (F ⋙ G) =\n    (whiskeringLeft D D' E).obj G ⋙ (whiskeringLeft C D E).obj F :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskeringRight_obj_id","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\n⊢ Eq ((CategoryTheory.whiskeringRight E C C).obj (CategoryTheory.Functor.id C)) (CategoryTheory.Functor.id (CategoryTheory.Functor E C))","decl":"theorem whiskeringRight_obj_id : (whiskeringRight E C C).obj (𝟭 _) = 𝟭 _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskeringRight_obj_comp","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nD' : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D D'\n⊢ Eq (((CategoryTheory.whiskeringRight E C D).obj F).comp ((CategoryTheory.whiskeringRight E D D').obj G)) ((CategoryTheory.whiskeringRight E C D').obj (F.comp G))","decl":"theorem whiskeringRight_obj_comp {D' : Type u₄} [Category.{v₄} D'] (F : C ⥤ D) (G : D ⥤ D') :\n    (whiskeringRight E C D).obj F ⋙ (whiskeringRight E D D').obj G =\n    (whiskeringRight E C D').obj (F ⋙ G) :=\n  rfl\n\n"}
{"name":"CategoryTheory.full_whiskeringRight_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor D E\ninst✝¹ : F.Faithful\ninst✝ : F.Full\n⊢ ((CategoryTheory.whiskeringRight C D E).obj F).Full","decl":"instance full_whiskeringRight_obj {F : D ⥤ E} [F.Faithful] [F.Full] :\n    ((whiskeringRight C D E).obj F).Full :=\n  ((Functor.FullyFaithful.ofFullyFaithful F).whiskeringRight C).full\n\n"}
{"name":"CategoryTheory.whiskerLeft_id","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\n⊢ Eq (CategoryTheory.whiskerLeft F (CategoryTheory.NatTrans.id G)) (CategoryTheory.NatTrans.id (F.comp G))","decl":"@[simp]\ntheorem whiskerLeft_id (F : C ⥤ D) {G : D ⥤ E} :\n    whiskerLeft F (NatTrans.id G) = NatTrans.id (F.comp G) :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskerLeft_id'","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\n⊢ Eq (CategoryTheory.whiskerLeft F (CategoryTheory.CategoryStruct.id G)) (CategoryTheory.CategoryStruct.id (F.comp G))","decl":"@[simp]\ntheorem whiskerLeft_id' (F : C ⥤ D) {G : D ⥤ E} : whiskerLeft F (𝟙 G) = 𝟙 (F.comp G) :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskerRight_id","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor C D\nF : CategoryTheory.Functor D E\n⊢ Eq (CategoryTheory.whiskerRight (CategoryTheory.NatTrans.id G) F) (CategoryTheory.NatTrans.id (G.comp F))","decl":"@[simp]\ntheorem whiskerRight_id {G : C ⥤ D} (F : D ⥤ E) :\n    whiskerRight (NatTrans.id G) F = NatTrans.id (G.comp F) :=\n  ((whiskeringRight C D E).obj F).map_id _\n\n"}
{"name":"CategoryTheory.whiskerRight_id'","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor C D\nF : CategoryTheory.Functor D E\n⊢ Eq (CategoryTheory.whiskerRight (CategoryTheory.CategoryStruct.id G) F) (CategoryTheory.CategoryStruct.id (G.comp F))","decl":"@[simp]\ntheorem whiskerRight_id' {G : C ⥤ D} (F : D ⥤ E) : whiskerRight (𝟙 G) F = 𝟙 (G.comp F) :=\n  ((whiskeringRight C D E).obj F).map_id _\n\n"}
{"name":"CategoryTheory.whiskerLeft_comp","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG H K : CategoryTheory.Functor D E\nα : Quiver.Hom G H\nβ : Quiver.Hom H K\n⊢ Eq (CategoryTheory.whiskerLeft F (CategoryTheory.CategoryStruct.comp α β)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft F α) (CategoryTheory.whiskerLeft F β))","decl":"@[simp, reassoc]\ntheorem whiskerLeft_comp (F : C ⥤ D) {G H K : D ⥤ E} (α : G ⟶ H) (β : H ⟶ K) :\n    whiskerLeft F (α ≫ β) = whiskerLeft F α ≫ whiskerLeft F β :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskerLeft_comp_assoc","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG H K : CategoryTheory.Functor D E\nα : Quiver.Hom G H\nβ : Quiver.Hom H K\nZ : CategoryTheory.Functor C E\nh : Quiver.Hom (F.comp K) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft F (CategoryTheory.CategoryStruct.comp α β)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft F α) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft F β) h))","decl":"@[simp, reassoc]\ntheorem whiskerLeft_comp (F : C ⥤ D) {G H K : D ⥤ E} (α : G ⟶ H) (β : H ⟶ K) :\n    whiskerLeft F (α ≫ β) = whiskerLeft F α ≫ whiskerLeft F β :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskerRight_comp_assoc","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG H K : CategoryTheory.Functor C D\nα : Quiver.Hom G H\nβ : Quiver.Hom H K\nF : CategoryTheory.Functor D E\nZ : CategoryTheory.Functor C E\nh : Quiver.Hom (K.comp F) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.CategoryStruct.comp α β) F) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight α F) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight β F) h))","decl":"@[simp, reassoc]\ntheorem whiskerRight_comp {G H K : C ⥤ D} (α : G ⟶ H) (β : H ⟶ K) (F : D ⥤ E) :\n    whiskerRight (α ≫ β) F = whiskerRight α F ≫ whiskerRight β F :=\n  ((whiskeringRight C D E).obj F).map_comp α β\n\n"}
{"name":"CategoryTheory.whiskerRight_comp","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG H K : CategoryTheory.Functor C D\nα : Quiver.Hom G H\nβ : Quiver.Hom H K\nF : CategoryTheory.Functor D E\n⊢ Eq (CategoryTheory.whiskerRight (CategoryTheory.CategoryStruct.comp α β) F) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight α F) (CategoryTheory.whiskerRight β F))","decl":"@[simp, reassoc]\ntheorem whiskerRight_comp {G H K : C ⥤ D} (α : G ⟶ H) (β : H ⟶ K) (F : D ⥤ E) :\n    whiskerRight (α ≫ β) F = whiskerRight α F ≫ whiskerRight β F :=\n  ((whiskeringRight C D E).obj F).map_comp α β\n\n"}
{"name":"CategoryTheory.isoWhiskerLeft_hom","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG H : CategoryTheory.Functor D E\nα : CategoryTheory.Iso G H\n⊢ Eq (CategoryTheory.isoWhiskerLeft F α).hom (CategoryTheory.whiskerLeft F α.hom)","decl":"@[simp]\ntheorem isoWhiskerLeft_hom (F : C ⥤ D) {G H : D ⥤ E} (α : G ≅ H) :\n    (isoWhiskerLeft F α).hom = whiskerLeft F α.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.isoWhiskerLeft_inv","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG H : CategoryTheory.Functor D E\nα : CategoryTheory.Iso G H\n⊢ Eq (CategoryTheory.isoWhiskerLeft F α).inv (CategoryTheory.whiskerLeft F α.inv)","decl":"@[simp]\ntheorem isoWhiskerLeft_inv (F : C ⥤ D) {G H : D ⥤ E} (α : G ≅ H) :\n    (isoWhiskerLeft F α).inv = whiskerLeft F α.inv :=\n  rfl\n\n"}
{"name":"CategoryTheory.isoWhiskerRight_hom","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG H : CategoryTheory.Functor C D\nα : CategoryTheory.Iso G H\nF : CategoryTheory.Functor D E\n⊢ Eq (CategoryTheory.isoWhiskerRight α F).hom (CategoryTheory.whiskerRight α.hom F)","decl":"@[simp]\ntheorem isoWhiskerRight_hom {G H : C ⥤ D} (α : G ≅ H) (F : D ⥤ E) :\n    (isoWhiskerRight α F).hom = whiskerRight α.hom F :=\n  rfl\n\n"}
{"name":"CategoryTheory.isoWhiskerRight_inv","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG H : CategoryTheory.Functor C D\nα : CategoryTheory.Iso G H\nF : CategoryTheory.Functor D E\n⊢ Eq (CategoryTheory.isoWhiskerRight α F).inv (CategoryTheory.whiskerRight α.inv F)","decl":"@[simp]\ntheorem isoWhiskerRight_inv {G H : C ⥤ D} (α : G ≅ H) (F : D ⥤ E) :\n    (isoWhiskerRight α F).inv = whiskerRight α.inv F :=\n  rfl\n\n"}
{"name":"CategoryTheory.isIso_whiskerLeft","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nF : CategoryTheory.Functor C D\nG H : CategoryTheory.Functor D E\nα : Quiver.Hom G H\ninst✝ : CategoryTheory.IsIso α\n⊢ CategoryTheory.IsIso (CategoryTheory.whiskerLeft F α)","decl":"instance isIso_whiskerLeft (F : C ⥤ D) {G H : D ⥤ E} (α : G ⟶ H) [IsIso α] :\n    IsIso (whiskerLeft F α) :=\n  (isoWhiskerLeft F (asIso α)).isIso_hom\n\n"}
{"name":"CategoryTheory.isIso_whiskerRight","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nG H : CategoryTheory.Functor C D\nα : Quiver.Hom G H\nF : CategoryTheory.Functor D E\ninst✝ : CategoryTheory.IsIso α\n⊢ CategoryTheory.IsIso (CategoryTheory.whiskerRight α F)","decl":"instance isIso_whiskerRight {G H : C ⥤ D} (α : G ⟶ H) (F : D ⥤ E) [IsIso α] :\n    IsIso (whiskerRight α F) :=\n  (isoWhiskerRight (asIso α) F).isIso_hom\n\n"}
{"name":"CategoryTheory.whiskerLeft_twice","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nH K : CategoryTheory.Functor D E\nα : Quiver.Hom H K\n⊢ Eq (CategoryTheory.whiskerLeft F (CategoryTheory.whiskerLeft G α)) (CategoryTheory.whiskerLeft (F.comp G) α)","decl":"@[simp]\ntheorem whiskerLeft_twice (F : B ⥤ C) (G : C ⥤ D) {H K : D ⥤ E} (α : H ⟶ K) :\n    whiskerLeft F (whiskerLeft G α) = whiskerLeft (F ⋙ G) α :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskerRight_twice","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nH K : CategoryTheory.Functor B C\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nα : Quiver.Hom H K\n⊢ Eq (CategoryTheory.whiskerRight (CategoryTheory.whiskerRight α F) G) (CategoryTheory.whiskerRight α (F.comp G))","decl":"@[simp]\ntheorem whiskerRight_twice {H K : B ⥤ C} (F : C ⥤ D) (G : D ⥤ E) (α : H ⟶ K) :\n    whiskerRight (whiskerRight α F) G = whiskerRight α (F ⋙ G) :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskerRight_left","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} E\nB : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} B\nF : CategoryTheory.Functor B C\nG H : CategoryTheory.Functor C D\nα : Quiver.Hom G H\nK : CategoryTheory.Functor D E\n⊢ Eq (CategoryTheory.whiskerRight (CategoryTheory.whiskerLeft F α) K) (CategoryTheory.whiskerLeft F (CategoryTheory.whiskerRight α K))","decl":"theorem whiskerRight_left (F : B ⥤ C) {G H : C ⥤ D} (α : G ⟶ H) (K : D ⥤ E) :\n    whiskerRight (whiskerLeft F α) K = whiskerLeft F (whiskerRight α K) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.leftUnitor_hom_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nF : CategoryTheory.Functor A B\nX : A\n⊢ Eq (F.leftUnitor.hom.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The left unitor, a natural isomorphism `((𝟭 _) ⋙ F) ≅ F`.\n-/\n@[simps]\ndef leftUnitor (F : A ⥤ B) :\n    𝟭 A ⋙ F ≅ F where\n  hom := { app := fun X => 𝟙 (F.obj X) }\n  inv := { app := fun X => 𝟙 (F.obj X) }\n\n"}
{"name":"CategoryTheory.Functor.leftUnitor_inv_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nF : CategoryTheory.Functor A B\nX : A\n⊢ Eq (F.leftUnitor.inv.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The left unitor, a natural isomorphism `((𝟭 _) ⋙ F) ≅ F`.\n-/\n@[simps]\ndef leftUnitor (F : A ⥤ B) :\n    𝟭 A ⋙ F ≅ F where\n  hom := { app := fun X => 𝟙 (F.obj X) }\n  inv := { app := fun X => 𝟙 (F.obj X) }\n\n"}
{"name":"CategoryTheory.Functor.rightUnitor_hom_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nF : CategoryTheory.Functor A B\nX : A\n⊢ Eq (F.rightUnitor.hom.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The right unitor, a natural isomorphism `(F ⋙ (𝟭 B)) ≅ F`.\n-/\n@[simps]\ndef rightUnitor (F : A ⥤ B) :\n    F ⋙ 𝟭 B ≅ F where\n  hom := { app := fun X => 𝟙 (F.obj X) }\n  inv := { app := fun X => 𝟙 (F.obj X) }\n\n"}
{"name":"CategoryTheory.Functor.rightUnitor_inv_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"A : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} B\nF : CategoryTheory.Functor A B\nX : A\n⊢ Eq (F.rightUnitor.inv.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The right unitor, a natural isomorphism `(F ⋙ (𝟭 B)) ≅ F`.\n-/\n@[simps]\ndef rightUnitor (F : A ⥤ B) :\n    F ⋙ 𝟭 B ≅ F where\n  hom := { app := fun X => 𝟙 (F.obj X) }\n  inv := { app := fun X => 𝟙 (F.obj X) }\n\n"}
{"name":"CategoryTheory.Functor.associator_inv_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor B C\nH : CategoryTheory.Functor C D\nx✝ : A\n⊢ Eq ((F.associator G H).inv.app x✝) (CategoryTheory.CategoryStruct.id ((F.comp (G.comp H)).obj x✝))","decl":"/-- The associator for functors, a natural isomorphism `((F ⋙ G) ⋙ H) ≅ (F ⋙ (G ⋙ H))`.\n\n(In fact, `iso.refl _` will work here, but it tends to make Lean slow later,\nand it's usually best to insert explicit associators.)\n-/\n@[simps]\ndef associator (F : A ⥤ B) (G : B ⥤ C) (H : C ⥤ D) :\n    (F ⋙ G) ⋙ H ≅ F ⋙ G ⋙ H where\n  hom := { app := fun _ => 𝟙 _ }\n  inv := { app := fun _ => 𝟙 _ }\n\n"}
{"name":"CategoryTheory.Functor.associator_hom_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor B C\nH : CategoryTheory.Functor C D\nx✝ : A\n⊢ Eq ((F.associator G H).hom.app x✝) (CategoryTheory.CategoryStruct.id (((F.comp G).comp H).obj x✝))","decl":"/-- The associator for functors, a natural isomorphism `((F ⋙ G) ⋙ H) ≅ (F ⋙ (G ⋙ H))`.\n\n(In fact, `iso.refl _` will work here, but it tends to make Lean slow later,\nand it's usually best to insert explicit associators.)\n-/\n@[simps]\ndef associator (F : A ⥤ B) (G : B ⥤ C) (H : C ⥤ D) :\n    (F ⋙ G) ⋙ H ≅ F ⋙ G ⋙ H where\n  hom := { app := fun _ => 𝟙 _ }\n  inv := { app := fun _ => 𝟙 _ }\n\n"}
{"name":"CategoryTheory.Functor.assoc","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} B\nC : Type u₃\ninst✝¹ : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝ : CategoryTheory.Category.{v₄, u₄} D\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor B C\nH : CategoryTheory.Functor C D\n⊢ Eq ((F.comp G).comp H) (F.comp (G.comp H))","decl":"protected theorem assoc (F : A ⥤ B) (G : B ⥤ C) (H : C ⥤ D) : (F ⋙ G) ⋙ H = F ⋙ G ⋙ H :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.triangle","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} B\nC : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} C\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor B C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.associator (CategoryTheory.Functor.id B) G).hom (CategoryTheory.whiskerLeft F G.leftUnitor.hom)) (CategoryTheory.whiskerRight F.rightUnitor.hom G)","decl":"theorem triangle (F : A ⥤ B) (G : B ⥤ C) :\n    (associator F (𝟭 B) G).hom ≫ whiskerLeft F (leftUnitor G).hom =\n      whiskerRight (rightUnitor F).hom G := by aesop_cat\n\n-- See note [dsimp, simp].\n"}
{"name":"CategoryTheory.Functor.pentagon","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"A : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} B\nC : Type u₃\ninst✝² : CategoryTheory.Category.{v₃, u₃} C\nD : Type u₄\ninst✝¹ : CategoryTheory.Category.{v₄, u₄} D\nE : Type u₅\ninst✝ : CategoryTheory.Category.{v₅, u₅} E\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor B C\nH : CategoryTheory.Functor C D\nK : CategoryTheory.Functor D E\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (F.associator G H).hom K) (CategoryTheory.CategoryStruct.comp (F.associator (G.comp H) K).hom (CategoryTheory.whiskerLeft F (G.associator H K).hom))) (CategoryTheory.CategoryStruct.comp ((F.comp G).associator H K).hom (F.associator G (H.comp K)).hom)","decl":"theorem pentagon :\n    whiskerRight (associator F G H).hom K ≫\n        (associator F (G ⋙ H) K).hom ≫ whiskerLeft F (associator G H K).hom =\n      (associator (F ⋙ G) H K).hom ≫ (associator F G (H ⋙ K)).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.whiskeringLeft₂_map_app_app_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₁ : Type u_4\nD₂ : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_10, u_4} D₁\ninst✝¹ : CategoryTheory.Category.{u_11, u_5} D₂\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_12, u_7} E\nX✝¹ Y✝ : CategoryTheory.Functor C₁ D₁\nψ : Quiver.Hom X✝¹ Y✝\nF₂ : CategoryTheory.Functor C₂ D₂\nX✝ : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ E)\nc : C₁\nX : C₂\n⊢ Eq ((((((CategoryTheory.whiskeringLeft₂ E).map ψ).app F₂).app X✝).app c).app X) ((X✝.map (ψ.app c)).app (F₂.obj X))","decl":"/-- The obvious functor `(C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (D₁ ⥤ D₂ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ E)`. -/\n@[simps!]\ndef whiskeringLeft₂ :\n    (C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (D₁ ⥤ D₂ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ E) where\n  obj F₁ :=\n    { obj := fun F₂ ↦\n        (whiskeringRight D₁ (D₂ ⥤ E) (C₂ ⥤ E)).obj ((whiskeringLeft C₂ D₂ E).obj F₂) ⋙\n          (whiskeringLeft C₁ D₁ (C₂ ⥤ E)).obj F₁\n      map := fun φ ↦ whiskerRight\n        ((whiskeringRight D₁ (D₂ ⥤ E) (C₂ ⥤ E)).map ((whiskeringLeft C₂ D₂ E).map φ)) _ }\n  map ψ :=\n    { app := fun F₂ ↦ whiskerLeft _ ((whiskeringLeft C₁ D₁ (C₂ ⥤ E)).map ψ) }\n\n"}
{"name":"CategoryTheory.whiskeringLeft₂_obj_obj_obj_map_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₁ : Type u_4\nD₂ : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_10, u_4} D₁\ninst✝¹ : CategoryTheory.Category.{u_11, u_5} D₂\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_12, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nF₂ : CategoryTheory.Functor C₂ D₂\nX✝¹ : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ E)\nX✝ Y✝ : C₁\nf : Quiver.Hom X✝ Y✝\nX : C₂\n⊢ Eq ((((((CategoryTheory.whiskeringLeft₂ E).obj F₁).obj F₂).obj X✝¹).map f).app X) ((X✝¹.map (F₁.map f)).app (F₂.obj X))","decl":"/-- The obvious functor `(C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (D₁ ⥤ D₂ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ E)`. -/\n@[simps!]\ndef whiskeringLeft₂ :\n    (C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (D₁ ⥤ D₂ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ E) where\n  obj F₁ :=\n    { obj := fun F₂ ↦\n        (whiskeringRight D₁ (D₂ ⥤ E) (C₂ ⥤ E)).obj ((whiskeringLeft C₂ D₂ E).obj F₂) ⋙\n          (whiskeringLeft C₁ D₁ (C₂ ⥤ E)).obj F₁\n      map := fun φ ↦ whiskerRight\n        ((whiskeringRight D₁ (D₂ ⥤ E) (C₂ ⥤ E)).map ((whiskeringLeft C₂ D₂ E).map φ)) _ }\n  map ψ :=\n    { app := fun F₂ ↦ whiskerLeft _ ((whiskeringLeft C₁ D₁ (C₂ ⥤ E)).map ψ) }\n\n"}
{"name":"CategoryTheory.whiskeringLeft₂_obj_obj_map_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₁ : Type u_4\nD₂ : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_10, u_4} D₁\ninst✝¹ : CategoryTheory.Category.{u_11, u_5} D₂\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_12, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nF₂ : CategoryTheory.Functor C₂ D₂\nX✝¹ Y✝ : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ E)\nf : Quiver.Hom X✝¹ Y✝\nX✝ : C₁\nX : C₂\n⊢ Eq ((((((CategoryTheory.whiskeringLeft₂ E).obj F₁).obj F₂).map f).app X✝).app X) ((f.app (F₁.obj X✝)).app (F₂.obj X))","decl":"/-- The obvious functor `(C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (D₁ ⥤ D₂ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ E)`. -/\n@[simps!]\ndef whiskeringLeft₂ :\n    (C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (D₁ ⥤ D₂ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ E) where\n  obj F₁ :=\n    { obj := fun F₂ ↦\n        (whiskeringRight D₁ (D₂ ⥤ E) (C₂ ⥤ E)).obj ((whiskeringLeft C₂ D₂ E).obj F₂) ⋙\n          (whiskeringLeft C₁ D₁ (C₂ ⥤ E)).obj F₁\n      map := fun φ ↦ whiskerRight\n        ((whiskeringRight D₁ (D₂ ⥤ E) (C₂ ⥤ E)).map ((whiskeringLeft C₂ D₂ E).map φ)) _ }\n  map ψ :=\n    { app := fun F₂ ↦ whiskerLeft _ ((whiskeringLeft C₁ D₁ (C₂ ⥤ E)).map ψ) }\n\n"}
{"name":"CategoryTheory.whiskeringLeft₂_obj_obj_obj_obj_map","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₁ : Type u_4\nD₂ : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_10, u_4} D₁\ninst✝¹ : CategoryTheory.Category.{u_11, u_5} D₂\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_12, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nF₂ : CategoryTheory.Functor C₂ D₂\nX✝¹ : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ E)\nX : C₁\nX✝ Y✝ : C₂\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((((((CategoryTheory.whiskeringLeft₂ E).obj F₁).obj F₂).obj X✝¹).obj X).map f) ((X✝¹.obj (F₁.obj X)).map (F₂.map f))","decl":"/-- The obvious functor `(C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (D₁ ⥤ D₂ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ E)`. -/\n@[simps!]\ndef whiskeringLeft₂ :\n    (C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (D₁ ⥤ D₂ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ E) where\n  obj F₁ :=\n    { obj := fun F₂ ↦\n        (whiskeringRight D₁ (D₂ ⥤ E) (C₂ ⥤ E)).obj ((whiskeringLeft C₂ D₂ E).obj F₂) ⋙\n          (whiskeringLeft C₁ D₁ (C₂ ⥤ E)).obj F₁\n      map := fun φ ↦ whiskerRight\n        ((whiskeringRight D₁ (D₂ ⥤ E) (C₂ ⥤ E)).map ((whiskeringLeft C₂ D₂ E).map φ)) _ }\n  map ψ :=\n    { app := fun F₂ ↦ whiskerLeft _ ((whiskeringLeft C₁ D₁ (C₂ ⥤ E)).map ψ) }\n\n"}
{"name":"CategoryTheory.whiskeringLeft₂_obj_obj_obj_obj_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₁ : Type u_4\nD₂ : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_10, u_4} D₁\ninst✝¹ : CategoryTheory.Category.{u_11, u_5} D₂\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_12, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nF₂ : CategoryTheory.Functor C₂ D₂\nX✝¹ : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ E)\nX✝ : C₁\nX : C₂\n⊢ Eq ((((((CategoryTheory.whiskeringLeft₂ E).obj F₁).obj F₂).obj X✝¹).obj X✝).obj X) ((X✝¹.obj (F₁.obj X✝)).obj (F₂.obj X))","decl":"/-- The obvious functor `(C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (D₁ ⥤ D₂ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ E)`. -/\n@[simps!]\ndef whiskeringLeft₂ :\n    (C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (D₁ ⥤ D₂ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ E) where\n  obj F₁ :=\n    { obj := fun F₂ ↦\n        (whiskeringRight D₁ (D₂ ⥤ E) (C₂ ⥤ E)).obj ((whiskeringLeft C₂ D₂ E).obj F₂) ⋙\n          (whiskeringLeft C₁ D₁ (C₂ ⥤ E)).obj F₁\n      map := fun φ ↦ whiskerRight\n        ((whiskeringRight D₁ (D₂ ⥤ E) (C₂ ⥤ E)).map ((whiskeringLeft C₂ D₂ E).map φ)) _ }\n  map ψ :=\n    { app := fun F₂ ↦ whiskerLeft _ ((whiskeringLeft C₁ D₁ (C₂ ⥤ E)).map ψ) }\n\n"}
{"name":"CategoryTheory.whiskeringLeft₂_obj_map_app_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₁ : Type u_4\nD₂ : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_10, u_4} D₁\ninst✝¹ : CategoryTheory.Category.{u_11, u_5} D₂\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_12, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nX✝¹ Y✝ : CategoryTheory.Functor C₂ D₂\nφ : Quiver.Hom X✝¹ Y✝\nX✝ : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ E)\nX : C₁\nc : C₂\n⊢ Eq ((((((CategoryTheory.whiskeringLeft₂ E).obj F₁).map φ).app X✝).app X).app c) ((X✝.obj (F₁.obj X)).map (φ.app c))","decl":"/-- The obvious functor `(C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (D₁ ⥤ D₂ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ E)`. -/\n@[simps!]\ndef whiskeringLeft₂ :\n    (C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (D₁ ⥤ D₂ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ E) where\n  obj F₁ :=\n    { obj := fun F₂ ↦\n        (whiskeringRight D₁ (D₂ ⥤ E) (C₂ ⥤ E)).obj ((whiskeringLeft C₂ D₂ E).obj F₂) ⋙\n          (whiskeringLeft C₁ D₁ (C₂ ⥤ E)).obj F₁\n      map := fun φ ↦ whiskerRight\n        ((whiskeringRight D₁ (D₂ ⥤ E) (C₂ ⥤ E)).map ((whiskeringLeft C₂ D₂ E).map φ)) _ }\n  map ψ :=\n    { app := fun F₂ ↦ whiskerLeft _ ((whiskeringLeft C₁ D₁ (C₂ ⥤ E)).map ψ) }\n\n"}
{"name":"CategoryTheory.whiskeringLeft₃ObjObjObj_map_app_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} D₁\ninst✝² : CategoryTheory.Category.{u_12, u_5} D₂\ninst✝¹ : CategoryTheory.Category.{u_13, u_6} D₃\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_14, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nF₂ : CategoryTheory.Functor C₂ D₂\nF₃ : CategoryTheory.Functor C₃ D₃\nX✝² Y✝ : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ (CategoryTheory.Functor D₃ E))\nf : Quiver.Hom X✝² Y✝\nX✝¹ : C₁\nX✝ : C₂\nX : C₃\n⊢ Eq (((((CategoryTheory.whiskeringLeft₃ObjObjObj E F₁ F₂ F₃).map f).app X✝¹).app X✝).app X) (((f.app (F₁.obj X✝¹)).app (F₂.obj X✝)).app (F₃.obj X))","decl":"/-- Auxiliary definition for `whiskeringLeft₃`. -/\n@[simps!]\ndef whiskeringLeft₃ObjObjObj (F₁ : C₁ ⥤ D₁) (F₂ : C₂ ⥤ D₂) (F₃ : C₃ ⥤ D₃) :\n    (D₁ ⥤ D₂ ⥤ D₃ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ E :=\n  (whiskeringRight _ _ _).obj (((whiskeringLeft₂ E).obj F₂).obj F₃) ⋙\n    (whiskeringLeft C₁ D₁ _).obj F₁\n\n"}
{"name":"CategoryTheory.whiskeringLeft₃ObjObjObj_obj_obj_obj_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} D₁\ninst✝² : CategoryTheory.Category.{u_12, u_5} D₂\ninst✝¹ : CategoryTheory.Category.{u_13, u_6} D₃\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_14, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nF₂ : CategoryTheory.Functor C₂ D₂\nF₃ : CategoryTheory.Functor C₃ D₃\nX✝² : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ (CategoryTheory.Functor D₃ E))\nX✝¹ : C₁\nX✝ : C₂\nX : C₃\n⊢ Eq (((((CategoryTheory.whiskeringLeft₃ObjObjObj E F₁ F₂ F₃).obj X✝²).obj X✝¹).obj X✝).obj X) (((X✝².obj (F₁.obj X✝¹)).obj (F₂.obj X✝)).obj (F₃.obj X))","decl":"/-- Auxiliary definition for `whiskeringLeft₃`. -/\n@[simps!]\ndef whiskeringLeft₃ObjObjObj (F₁ : C₁ ⥤ D₁) (F₂ : C₂ ⥤ D₂) (F₃ : C₃ ⥤ D₃) :\n    (D₁ ⥤ D₂ ⥤ D₃ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ E :=\n  (whiskeringRight _ _ _).obj (((whiskeringLeft₂ E).obj F₂).obj F₃) ⋙\n    (whiskeringLeft C₁ D₁ _).obj F₁\n\n"}
{"name":"CategoryTheory.whiskeringLeft₃ObjObjObj_obj_obj_map_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} D₁\ninst✝² : CategoryTheory.Category.{u_12, u_5} D₂\ninst✝¹ : CategoryTheory.Category.{u_13, u_6} D₃\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_14, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nF₂ : CategoryTheory.Functor C₂ D₂\nF₃ : CategoryTheory.Functor C₃ D₃\nX✝² : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ (CategoryTheory.Functor D₃ E))\nX✝¹ : C₁\nX✝ Y✝ : C₂\nf : Quiver.Hom X✝ Y✝\nX : C₃\n⊢ Eq (((((CategoryTheory.whiskeringLeft₃ObjObjObj E F₁ F₂ F₃).obj X✝²).obj X✝¹).map f).app X) (((X✝².obj (F₁.obj X✝¹)).map (F₂.map f)).app (F₃.obj X))","decl":"/-- Auxiliary definition for `whiskeringLeft₃`. -/\n@[simps!]\ndef whiskeringLeft₃ObjObjObj (F₁ : C₁ ⥤ D₁) (F₂ : C₂ ⥤ D₂) (F₃ : C₃ ⥤ D₃) :\n    (D₁ ⥤ D₂ ⥤ D₃ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ E :=\n  (whiskeringRight _ _ _).obj (((whiskeringLeft₂ E).obj F₂).obj F₃) ⋙\n    (whiskeringLeft C₁ D₁ _).obj F₁\n\n"}
{"name":"CategoryTheory.whiskeringLeft₃ObjObjObj_obj_obj_obj_map","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} D₁\ninst✝² : CategoryTheory.Category.{u_12, u_5} D₂\ninst✝¹ : CategoryTheory.Category.{u_13, u_6} D₃\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_14, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nF₂ : CategoryTheory.Functor C₂ D₂\nF₃ : CategoryTheory.Functor C₃ D₃\nX✝² : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ (CategoryTheory.Functor D₃ E))\nX✝¹ : C₁\nX : C₂\nX✝ Y✝ : C₃\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (((((CategoryTheory.whiskeringLeft₃ObjObjObj E F₁ F₂ F₃).obj X✝²).obj X✝¹).obj X).map f) (((X✝².obj (F₁.obj X✝¹)).obj (F₂.obj X)).map (F₃.map f))","decl":"/-- Auxiliary definition for `whiskeringLeft₃`. -/\n@[simps!]\ndef whiskeringLeft₃ObjObjObj (F₁ : C₁ ⥤ D₁) (F₂ : C₂ ⥤ D₂) (F₃ : C₃ ⥤ D₃) :\n    (D₁ ⥤ D₂ ⥤ D₃ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ E :=\n  (whiskeringRight _ _ _).obj (((whiskeringLeft₂ E).obj F₂).obj F₃) ⋙\n    (whiskeringLeft C₁ D₁ _).obj F₁\n\n"}
{"name":"CategoryTheory.whiskeringLeft₃ObjObjObj_obj_map_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} D₁\ninst✝² : CategoryTheory.Category.{u_12, u_5} D₂\ninst✝¹ : CategoryTheory.Category.{u_13, u_6} D₃\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_14, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nF₂ : CategoryTheory.Functor C₂ D₂\nF₃ : CategoryTheory.Functor C₃ D₃\nX✝² : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ (CategoryTheory.Functor D₃ E))\nX✝¹ Y✝ : C₁\nf : Quiver.Hom X✝¹ Y✝\nX✝ : C₂\nX : C₃\n⊢ Eq (((((CategoryTheory.whiskeringLeft₃ObjObjObj E F₁ F₂ F₃).obj X✝²).map f).app X✝).app X) (((X✝².map (F₁.map f)).app (F₂.obj X✝)).app (F₃.obj X))","decl":"/-- Auxiliary definition for `whiskeringLeft₃`. -/\n@[simps!]\ndef whiskeringLeft₃ObjObjObj (F₁ : C₁ ⥤ D₁) (F₂ : C₂ ⥤ D₂) (F₃ : C₃ ⥤ D₃) :\n    (D₁ ⥤ D₂ ⥤ D₃ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ E :=\n  (whiskeringRight _ _ _).obj (((whiskeringLeft₂ E).obj F₂).obj F₃) ⋙\n    (whiskeringLeft C₁ D₁ _).obj F₁\n\n"}
{"name":"CategoryTheory.whiskeringLeft₃ObjObjMap_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} D₁\ninst✝² : CategoryTheory.Category.{u_12, u_5} D₂\ninst✝¹ : CategoryTheory.Category.{u_13, u_6} D₃\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_14, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nF₂ : CategoryTheory.Functor C₂ D₂\nF₃ F₃' : CategoryTheory.Functor C₃ D₃\nτ₃ : Quiver.Hom F₃ F₃'\nF : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ (CategoryTheory.Functor D₃ E))\n⊢ Eq ((CategoryTheory.whiskeringLeft₃ObjObjMap E F₁ F₂ τ₃).app F) (CategoryTheory.whiskerLeft F₁ (CategoryTheory.whiskerLeft F (((CategoryTheory.whiskeringLeft₂ E).obj F₂).map τ₃)))","decl":"/-- Auxiliary definition for `whiskeringLeft₃`. -/\n@[simps]\ndef whiskeringLeft₃ObjObjMap (F₁ : C₁ ⥤ D₁) (F₂ : C₂ ⥤ D₂) {F₃ F₃' : C₃ ⥤ D₃} (τ₃ : F₃ ⟶ F₃') :\n    whiskeringLeft₃ObjObjObj E F₁ F₂ F₃ ⟶\n      whiskeringLeft₃ObjObjObj E F₁ F₂ F₃' where\n  app F := whiskerLeft _ (whiskerLeft _ (((whiskeringLeft₂ E).obj F₂).map τ₃))\n\n"}
{"name":"CategoryTheory.whiskeringLeft₃ObjObj_map","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} D₁\ninst✝² : CategoryTheory.Category.{u_12, u_5} D₂\ninst✝¹ : CategoryTheory.Category.{u_13, u_6} D₃\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_14, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nF₂ : CategoryTheory.Functor C₂ D₂\nX✝ Y✝ : CategoryTheory.Functor C₃ D₃\nτ₃ : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.whiskeringLeft₃ObjObj C₃ D₃ E F₁ F₂).map τ₃) (CategoryTheory.whiskeringLeft₃ObjObjMap E F₁ F₂ τ₃)","decl":"variable (C₃ D₃) in\n/-- Auxiliary definition for `whiskeringLeft₃`. -/\n@[simps]\ndef whiskeringLeft₃ObjObj (F₁ : C₁ ⥤ D₁) (F₂ : C₂ ⥤ D₂) :\n    (C₃ ⥤ D₃) ⥤ (D₁ ⥤ D₂ ⥤ D₃ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) where\n  obj F₃ := whiskeringLeft₃ObjObjObj E F₁ F₂ F₃\n  map τ₃ := whiskeringLeft₃ObjObjMap E F₁ F₂ τ₃\n\n"}
{"name":"CategoryTheory.whiskeringLeft₃ObjObj_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} D₁\ninst✝² : CategoryTheory.Category.{u_12, u_5} D₂\ninst✝¹ : CategoryTheory.Category.{u_13, u_6} D₃\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_14, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nF₂ : CategoryTheory.Functor C₂ D₂\nF₃ : CategoryTheory.Functor C₃ D₃\n⊢ Eq ((CategoryTheory.whiskeringLeft₃ObjObj C₃ D₃ E F₁ F₂).obj F₃) (CategoryTheory.whiskeringLeft₃ObjObjObj E F₁ F₂ F₃)","decl":"variable (C₃ D₃) in\n/-- Auxiliary definition for `whiskeringLeft₃`. -/\n@[simps]\ndef whiskeringLeft₃ObjObj (F₁ : C₁ ⥤ D₁) (F₂ : C₂ ⥤ D₂) :\n    (C₃ ⥤ D₃) ⥤ (D₁ ⥤ D₂ ⥤ D₃ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) where\n  obj F₃ := whiskeringLeft₃ObjObjObj E F₁ F₂ F₃\n  map τ₃ := whiskeringLeft₃ObjObjMap E F₁ F₂ τ₃\n\n"}
{"name":"CategoryTheory.whiskeringLeft₃ObjMap_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} D₁\ninst✝² : CategoryTheory.Category.{u_12, u_5} D₂\ninst✝¹ : CategoryTheory.Category.{u_13, u_6} D₃\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_14, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nF₂ F₂' : CategoryTheory.Functor C₂ D₂\nτ₂ : Quiver.Hom F₂ F₂'\nF₃ : CategoryTheory.Functor C₃ D₃\n⊢ Eq ((CategoryTheory.whiskeringLeft₃ObjMap C₃ D₃ E F₁ τ₂).app F₃) (CategoryTheory.whiskerRight ((CategoryTheory.whiskeringRight D₁ (CategoryTheory.Functor D₂ (CategoryTheory.Functor D₃ E)) (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ E))).map (((CategoryTheory.whiskeringLeft₂ E).map τ₂).app F₃)) ((CategoryTheory.whiskeringLeft C₁ D₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ E))).obj F₁))","decl":"variable (C₃ D₃) in\n/-- Auxiliary definition for `whiskeringLeft₃`. -/\n@[simps]\ndef whiskeringLeft₃ObjMap (F₁ : C₁ ⥤ D₁) {F₂ F₂' : C₂ ⥤ D₂} (τ₂ : F₂ ⟶ F₂') :\n    whiskeringLeft₃ObjObj C₃ D₃ E F₁ F₂ ⟶ whiskeringLeft₃ObjObj C₃ D₃ E F₁ F₂' where\n  app F₃ := whiskerRight ((whiskeringRight _ _ _).map (((whiskeringLeft₂ E).map τ₂).app F₃)) _\n\n"}
{"name":"CategoryTheory.whiskeringLeft₃Obj_map","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} D₁\ninst✝² : CategoryTheory.Category.{u_12, u_5} D₂\ninst✝¹ : CategoryTheory.Category.{u_13, u_6} D₃\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_14, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nX✝ Y✝ : CategoryTheory.Functor C₂ D₂\nτ₂ : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.whiskeringLeft₃Obj C₂ C₃ D₂ D₃ E F₁).map τ₂) (CategoryTheory.whiskeringLeft₃ObjMap C₃ D₃ E F₁ τ₂)","decl":"variable (C₂ C₃ D₂ D₃) in\n/-- Auxiliary definition for `whiskeringLeft₃`. -/\n@[simps]\ndef whiskeringLeft₃Obj (F₁ : C₁ ⥤ D₁) :\n    (C₂ ⥤ D₂) ⥤ (C₃ ⥤ D₃) ⥤ (D₁ ⥤ D₂ ⥤ D₃ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) where\n  obj F₂ := whiskeringLeft₃ObjObj C₃ D₃ E F₁ F₂\n  map τ₂ := whiskeringLeft₃ObjMap C₃ D₃ E F₁ τ₂\n\n"}
{"name":"CategoryTheory.whiskeringLeft₃Obj_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} D₁\ninst✝² : CategoryTheory.Category.{u_12, u_5} D₂\ninst✝¹ : CategoryTheory.Category.{u_13, u_6} D₃\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_14, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nF₂ : CategoryTheory.Functor C₂ D₂\n⊢ Eq ((CategoryTheory.whiskeringLeft₃Obj C₂ C₃ D₂ D₃ E F₁).obj F₂) (CategoryTheory.whiskeringLeft₃ObjObj C₃ D₃ E F₁ F₂)","decl":"variable (C₂ C₃ D₂ D₃) in\n/-- Auxiliary definition for `whiskeringLeft₃`. -/\n@[simps]\ndef whiskeringLeft₃Obj (F₁ : C₁ ⥤ D₁) :\n    (C₂ ⥤ D₂) ⥤ (C₃ ⥤ D₃) ⥤ (D₁ ⥤ D₂ ⥤ D₃ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) where\n  obj F₂ := whiskeringLeft₃ObjObj C₃ D₃ E F₁ F₂\n  map τ₂ := whiskeringLeft₃ObjMap C₃ D₃ E F₁ τ₂\n\n"}
{"name":"CategoryTheory.whiskeringLeft₃Map_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} D₁\ninst✝² : CategoryTheory.Category.{u_12, u_5} D₂\ninst✝¹ : CategoryTheory.Category.{u_13, u_6} D₃\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_14, u_7} E\nF₁ F₁' : CategoryTheory.Functor C₁ D₁\nτ₁ : Quiver.Hom F₁ F₁'\nF₂ : CategoryTheory.Functor C₂ D₂\nF₃ : CategoryTheory.Functor C₃ D₃\n⊢ Eq (((CategoryTheory.whiskeringLeft₃Map C₂ C₃ D₂ D₃ E τ₁).app F₂).app F₃) (CategoryTheory.whiskerLeft ((CategoryTheory.whiskeringRight D₁ (CategoryTheory.Functor D₂ (CategoryTheory.Functor D₃ E)) (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ E))).obj (((CategoryTheory.whiskeringLeft₂ E).obj F₂).obj F₃)) ((CategoryTheory.whiskeringLeft C₁ D₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ E))).map τ₁))","decl":"variable (C₂ C₃ D₂ D₃) in\n/-- Auxiliary definition for `whiskeringLeft₃`. -/\n@[simps]\ndef whiskeringLeft₃Map {F₁ F₁' : C₁ ⥤ D₁} (τ₁ : F₁ ⟶ F₁') :\n    whiskeringLeft₃Obj C₂ C₃ D₂ D₃ E F₁ ⟶ whiskeringLeft₃Obj C₂ C₃ D₂ D₃ E F₁' where\n  app F₂ := { app F₃ := whiskerLeft _ ((whiskeringLeft _ _ _).map τ₁) }\n\n"}
{"name":"CategoryTheory.whiskeringLeft₃_obj_obj_obj_obj_obj_obj_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} D₁\ninst✝² : CategoryTheory.Category.{u_12, u_5} D₂\ninst✝¹ : CategoryTheory.Category.{u_13, u_6} D₃\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_14, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nF₂ : CategoryTheory.Functor C₂ D₂\nF₃ : CategoryTheory.Functor C₃ D₃\nX✝² : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ (CategoryTheory.Functor D₃ E))\nX✝¹ : C₁\nX✝ : C₂\nX : C₃\n⊢ Eq ((((((((CategoryTheory.whiskeringLeft₃ E).obj F₁).obj F₂).obj F₃).obj X✝²).obj X✝¹).obj X✝).obj X) (((X✝².obj (F₁.obj X✝¹)).obj (F₂.obj X✝)).obj (F₃.obj X))","decl":"/-- The obvious functor `(C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (D₁ ⥤ D₂ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ E)`. -/\n@[simps!]\ndef whiskeringLeft₃ :\n    (C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (C₃ ⥤ D₃) ⥤ (D₁ ⥤ D₂ ⥤ D₃ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) where\n  obj F₁ := whiskeringLeft₃Obj C₂ C₃ D₂ D₃ E F₁\n  map τ₁ := whiskeringLeft₃Map C₂ C₃ D₂ D₃ E τ₁\n\n"}
{"name":"CategoryTheory.whiskeringLeft₃_map_app_app_app_app_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} D₁\ninst✝² : CategoryTheory.Category.{u_12, u_5} D₂\ninst✝¹ : CategoryTheory.Category.{u_13, u_6} D₃\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_14, u_7} E\nX✝² Y✝ : CategoryTheory.Functor C₁ D₁\nτ₁ : Quiver.Hom X✝² Y✝\nF₂ : CategoryTheory.Functor C₂ D₂\nF₃ : CategoryTheory.Functor C₃ D₃\nX✝¹ : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ (CategoryTheory.Functor D₃ E))\nc : C₁\nX✝ : C₂\nX : C₃\n⊢ Eq ((((((((CategoryTheory.whiskeringLeft₃ E).map τ₁).app F₂).app F₃).app X✝¹).app c).app X✝).app X) (((X✝¹.map (τ₁.app c)).app (F₂.obj X✝)).app (F₃.obj X))","decl":"/-- The obvious functor `(C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (D₁ ⥤ D₂ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ E)`. -/\n@[simps!]\ndef whiskeringLeft₃ :\n    (C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (C₃ ⥤ D₃) ⥤ (D₁ ⥤ D₂ ⥤ D₃ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) where\n  obj F₁ := whiskeringLeft₃Obj C₂ C₃ D₂ D₃ E F₁\n  map τ₁ := whiskeringLeft₃Map C₂ C₃ D₂ D₃ E τ₁\n\n"}
{"name":"CategoryTheory.whiskeringLeft₃_obj_map_app_app_app_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} D₁\ninst✝² : CategoryTheory.Category.{u_12, u_5} D₂\ninst✝¹ : CategoryTheory.Category.{u_13, u_6} D₃\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_14, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nX✝² Y✝ : CategoryTheory.Functor C₂ D₂\nτ₂ : Quiver.Hom X✝² Y✝\nF₃ : CategoryTheory.Functor C₃ D₃\nX✝¹ : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ (CategoryTheory.Functor D₃ E))\nX✝ : C₁\nc : C₂\nX : C₃\n⊢ Eq ((((((((CategoryTheory.whiskeringLeft₃ E).obj F₁).map τ₂).app F₃).app X✝¹).app X✝).app c).app X) (((X✝¹.obj (F₁.obj X✝)).map (τ₂.app c)).app (F₃.obj X))","decl":"/-- The obvious functor `(C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (D₁ ⥤ D₂ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ E)`. -/\n@[simps!]\ndef whiskeringLeft₃ :\n    (C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (C₃ ⥤ D₃) ⥤ (D₁ ⥤ D₂ ⥤ D₃ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) where\n  obj F₁ := whiskeringLeft₃Obj C₂ C₃ D₂ D₃ E F₁\n  map τ₁ := whiskeringLeft₃Map C₂ C₃ D₂ D₃ E τ₁\n\n"}
{"name":"CategoryTheory.whiskeringLeft₃_obj_obj_obj_map_app_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} D₁\ninst✝² : CategoryTheory.Category.{u_12, u_5} D₂\ninst✝¹ : CategoryTheory.Category.{u_13, u_6} D₃\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_14, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nF₂ : CategoryTheory.Functor C₂ D₂\nF₃ : CategoryTheory.Functor C₃ D₃\nX✝² Y✝ : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ (CategoryTheory.Functor D₃ E))\nf : Quiver.Hom X✝² Y✝\nX✝¹ : C₁\nX✝ : C₂\nX : C₃\n⊢ Eq ((((((((CategoryTheory.whiskeringLeft₃ E).obj F₁).obj F₂).obj F₃).map f).app X✝¹).app X✝).app X) (((f.app (F₁.obj X✝¹)).app (F₂.obj X✝)).app (F₃.obj X))","decl":"/-- The obvious functor `(C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (D₁ ⥤ D₂ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ E)`. -/\n@[simps!]\ndef whiskeringLeft₃ :\n    (C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (C₃ ⥤ D₃) ⥤ (D₁ ⥤ D₂ ⥤ D₃ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) where\n  obj F₁ := whiskeringLeft₃Obj C₂ C₃ D₂ D₃ E F₁\n  map τ₁ := whiskeringLeft₃Map C₂ C₃ D₂ D₃ E τ₁\n\n"}
{"name":"CategoryTheory.whiskeringLeft₃_obj_obj_map_app_app_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} D₁\ninst✝² : CategoryTheory.Category.{u_12, u_5} D₂\ninst✝¹ : CategoryTheory.Category.{u_13, u_6} D₃\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_14, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nF₂ : CategoryTheory.Functor C₂ D₂\nX✝¹ Y✝ : CategoryTheory.Functor C₃ D₃\nτ₃ : Quiver.Hom X✝¹ Y✝\nF : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ (CategoryTheory.Functor D₃ E))\nX✝ : C₁\nX : C₂\nc : C₃\n⊢ Eq ((((((((CategoryTheory.whiskeringLeft₃ E).obj F₁).obj F₂).map τ₃).app F).app X✝).app X).app c) (((F.obj (F₁.obj X✝)).obj (F₂.obj X)).map (τ₃.app c))","decl":"/-- The obvious functor `(C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (D₁ ⥤ D₂ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ E)`. -/\n@[simps!]\ndef whiskeringLeft₃ :\n    (C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (C₃ ⥤ D₃) ⥤ (D₁ ⥤ D₂ ⥤ D₃ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) where\n  obj F₁ := whiskeringLeft₃Obj C₂ C₃ D₂ D₃ E F₁\n  map τ₁ := whiskeringLeft₃Map C₂ C₃ D₂ D₃ E τ₁\n\n"}
{"name":"CategoryTheory.whiskeringLeft₃_obj_obj_obj_obj_obj_map_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} D₁\ninst✝² : CategoryTheory.Category.{u_12, u_5} D₂\ninst✝¹ : CategoryTheory.Category.{u_13, u_6} D₃\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_14, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nF₂ : CategoryTheory.Functor C₂ D₂\nF₃ : CategoryTheory.Functor C₃ D₃\nX✝² : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ (CategoryTheory.Functor D₃ E))\nX✝¹ : C₁\nX✝ Y✝ : C₂\nf : Quiver.Hom X✝ Y✝\nX : C₃\n⊢ Eq ((((((((CategoryTheory.whiskeringLeft₃ E).obj F₁).obj F₂).obj F₃).obj X✝²).obj X✝¹).map f).app X) (((X✝².obj (F₁.obj X✝¹)).map (F₂.map f)).app (F₃.obj X))","decl":"/-- The obvious functor `(C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (D₁ ⥤ D₂ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ E)`. -/\n@[simps!]\ndef whiskeringLeft₃ :\n    (C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (C₃ ⥤ D₃) ⥤ (D₁ ⥤ D₂ ⥤ D₃ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) where\n  obj F₁ := whiskeringLeft₃Obj C₂ C₃ D₂ D₃ E F₁\n  map τ₁ := whiskeringLeft₃Map C₂ C₃ D₂ D₃ E τ₁\n\n"}
{"name":"CategoryTheory.whiskeringLeft₃_obj_obj_obj_obj_map_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} D₁\ninst✝² : CategoryTheory.Category.{u_12, u_5} D₂\ninst✝¹ : CategoryTheory.Category.{u_13, u_6} D₃\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_14, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nF₂ : CategoryTheory.Functor C₂ D₂\nF₃ : CategoryTheory.Functor C₃ D₃\nX✝² : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ (CategoryTheory.Functor D₃ E))\nX✝¹ Y✝ : C₁\nf : Quiver.Hom X✝¹ Y✝\nX✝ : C₂\nX : C₃\n⊢ Eq ((((((((CategoryTheory.whiskeringLeft₃ E).obj F₁).obj F₂).obj F₃).obj X✝²).map f).app X✝).app X) (((X✝².map (F₁.map f)).app (F₂.obj X✝)).app (F₃.obj X))","decl":"/-- The obvious functor `(C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (D₁ ⥤ D₂ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ E)`. -/\n@[simps!]\ndef whiskeringLeft₃ :\n    (C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (C₃ ⥤ D₃) ⥤ (D₁ ⥤ D₂ ⥤ D₃ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) where\n  obj F₁ := whiskeringLeft₃Obj C₂ C₃ D₂ D₃ E F₁\n  map τ₁ := whiskeringLeft₃Map C₂ C₃ D₂ D₃ E τ₁\n\n"}
{"name":"CategoryTheory.whiskeringLeft₃_obj_obj_obj_obj_obj_obj_map","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nD₁ : Type u_4\nD₂ : Type u_5\nD₃ : Type u_6\ninst✝⁶ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁴ : CategoryTheory.Category.{u_10, u_3} C₃\ninst✝³ : CategoryTheory.Category.{u_11, u_4} D₁\ninst✝² : CategoryTheory.Category.{u_12, u_5} D₂\ninst✝¹ : CategoryTheory.Category.{u_13, u_6} D₃\nE : Type u_7\ninst✝ : CategoryTheory.Category.{u_14, u_7} E\nF₁ : CategoryTheory.Functor C₁ D₁\nF₂ : CategoryTheory.Functor C₂ D₂\nF₃ : CategoryTheory.Functor C₃ D₃\nX✝² : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ (CategoryTheory.Functor D₃ E))\nX✝¹ : C₁\nX : C₂\nX✝ Y✝ : C₃\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((((((((CategoryTheory.whiskeringLeft₃ E).obj F₁).obj F₂).obj F₃).obj X✝²).obj X✝¹).obj X).map f) (((X✝².obj (F₁.obj X✝¹)).obj (F₂.obj X)).map (F₃.map f))","decl":"/-- The obvious functor `(C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (D₁ ⥤ D₂ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ E)`. -/\n@[simps!]\ndef whiskeringLeft₃ :\n    (C₁ ⥤ D₁) ⥤ (C₂ ⥤ D₂) ⥤ (C₃ ⥤ D₃) ⥤ (D₁ ⥤ D₂ ⥤ D₃ ⥤ E) ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) where\n  obj F₁ := whiskeringLeft₃Obj C₂ C₃ D₂ D₃ E F₁\n  map τ₁ := whiskeringLeft₃Map C₂ C₃ D₂ D₃ E τ₁\n\n"}
{"name":"CategoryTheory.Functor.postcompose₂_obj_obj_obj_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝³ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_10, u_2} C₂\nE : Type u_7\ninst✝¹ : CategoryTheory.Category.{u_11, u_7} E\nE' : Type u_8\ninst✝ : CategoryTheory.Category.{u_12, u_8} E'\nX✝¹ : CategoryTheory.Functor E E'\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ E)\nX✝ : C₁\nX : C₂\n⊢ Eq ((((CategoryTheory.Functor.postcompose₂.obj X✝¹).obj F).obj X✝).obj X) (X✝¹.obj ((F.obj X✝).obj X))","decl":"/-- The \"postcomposition\" with a functor `E ⥤ E'` gives a functor\n`(E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ E'`. -/\n@[simps!]\ndef Functor.postcompose₂ {E' : Type*} [Category E'] :\n    (E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ E' :=\n  whiskeringRight C₂ _ _ ⋙ whiskeringRight C₁ _ _\n\n"}
{"name":"CategoryTheory.Functor.postcompose₂_map_app_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝³ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_10, u_2} C₂\nE : Type u_7\ninst✝¹ : CategoryTheory.Category.{u_11, u_7} E\nE' : Type u_8\ninst✝ : CategoryTheory.Category.{u_12, u_8} E'\nX✝ Y✝ : CategoryTheory.Functor E E'\nf : Quiver.Hom X✝ Y✝\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ E)\nc✝ : C₁\nc : C₂\n⊢ Eq ((((CategoryTheory.Functor.postcompose₂.map f).app F).app c✝).app c) (f.app ((F.obj c✝).obj c))","decl":"/-- The \"postcomposition\" with a functor `E ⥤ E'` gives a functor\n`(E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ E'`. -/\n@[simps!]\ndef Functor.postcompose₂ {E' : Type*} [Category E'] :\n    (E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ E' :=\n  whiskeringRight C₂ _ _ ⋙ whiskeringRight C₁ _ _\n\n"}
{"name":"CategoryTheory.Functor.postcompose₂_obj_map_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝³ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_10, u_2} C₂\nE : Type u_7\ninst✝¹ : CategoryTheory.Category.{u_11, u_7} E\nE' : Type u_8\ninst✝ : CategoryTheory.Category.{u_12, u_8} E'\nX✝² : CategoryTheory.Functor E E'\nX✝¹ Y✝ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ E)\nα : Quiver.Hom X✝¹ Y✝\nX✝ : C₁\nX : C₂\n⊢ Eq ((((CategoryTheory.Functor.postcompose₂.obj X✝²).map α).app X✝).app X) (X✝².map ((α.app X✝).app X))","decl":"/-- The \"postcomposition\" with a functor `E ⥤ E'` gives a functor\n`(E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ E'`. -/\n@[simps!]\ndef Functor.postcompose₂ {E' : Type*} [Category E'] :\n    (E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ E' :=\n  whiskeringRight C₂ _ _ ⋙ whiskeringRight C₁ _ _\n\n"}
{"name":"CategoryTheory.Functor.postcompose₂_obj_obj_map_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝³ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_10, u_2} C₂\nE : Type u_7\ninst✝¹ : CategoryTheory.Category.{u_11, u_7} E\nE' : Type u_8\ninst✝ : CategoryTheory.Category.{u_12, u_8} E'\nX✝¹ : CategoryTheory.Functor E E'\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ E)\nX✝ Y✝ : C₁\nf : Quiver.Hom X✝ Y✝\nX : C₂\n⊢ Eq ((((CategoryTheory.Functor.postcompose₂.obj X✝¹).obj F).map f).app X) (X✝¹.map ((F.map f).app X))","decl":"/-- The \"postcomposition\" with a functor `E ⥤ E'` gives a functor\n`(E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ E'`. -/\n@[simps!]\ndef Functor.postcompose₂ {E' : Type*} [Category E'] :\n    (E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ E' :=\n  whiskeringRight C₂ _ _ ⋙ whiskeringRight C₁ _ _\n\n"}
{"name":"CategoryTheory.Functor.postcompose₂_obj_obj_obj_map","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\ninst✝³ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝² : CategoryTheory.Category.{u_10, u_2} C₂\nE : Type u_7\ninst✝¹ : CategoryTheory.Category.{u_11, u_7} E\nE' : Type u_8\ninst✝ : CategoryTheory.Category.{u_12, u_8} E'\nX✝¹ : CategoryTheory.Functor E E'\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ E)\nX : C₁\nX✝ Y✝ : C₂\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((((CategoryTheory.Functor.postcompose₂.obj X✝¹).obj F).obj X).map f) (X✝¹.map ((F.obj X).map f))","decl":"/-- The \"postcomposition\" with a functor `E ⥤ E'` gives a functor\n`(E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ E'`. -/\n@[simps!]\ndef Functor.postcompose₂ {E' : Type*} [Category E'] :\n    (E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ E' :=\n  whiskeringRight C₂ _ _ ⋙ whiskeringRight C₁ _ _\n\n"}
{"name":"CategoryTheory.Functor.postcompose₃_obj_obj_map_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_10, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_11, u_3} C₃\nE : Type u_7\ninst✝¹ : CategoryTheory.Category.{u_12, u_7} E\nE' : Type u_8\ninst✝ : CategoryTheory.Category.{u_13, u_8} E'\nX✝² : CategoryTheory.Functor E E'\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ E))\nX✝¹ Y✝ : C₁\nf : Quiver.Hom X✝¹ Y✝\nX✝ : C₂\nX : C₃\n⊢ Eq (((((CategoryTheory.Functor.postcompose₃.obj X✝²).obj F).map f).app X✝).app X) (X✝².map (((F.map f).app X✝).app X))","decl":"/-- The \"postcomposition\" with a functor `E ⥤ E'` gives a functor\n`(E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ E'`. -/\n@[simps!]\ndef Functor.postcompose₃ {E' : Type*} [Category E'] :\n    (E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ E' :=\n  whiskeringRight C₃ _ _ ⋙ whiskeringRight C₂ _ _ ⋙ whiskeringRight C₁ _ _\n\n"}
{"name":"CategoryTheory.Functor.postcompose₃_obj_obj_obj_map_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_10, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_11, u_3} C₃\nE : Type u_7\ninst✝¹ : CategoryTheory.Category.{u_12, u_7} E\nE' : Type u_8\ninst✝ : CategoryTheory.Category.{u_13, u_8} E'\nX✝² : CategoryTheory.Functor E E'\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ E))\nX✝¹ : C₁\nX✝ Y✝ : C₂\nf : Quiver.Hom X✝ Y✝\nX : C₃\n⊢ Eq (((((CategoryTheory.Functor.postcompose₃.obj X✝²).obj F).obj X✝¹).map f).app X) (X✝².map (((F.obj X✝¹).map f).app X))","decl":"/-- The \"postcomposition\" with a functor `E ⥤ E'` gives a functor\n`(E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ E'`. -/\n@[simps!]\ndef Functor.postcompose₃ {E' : Type*} [Category E'] :\n    (E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ E' :=\n  whiskeringRight C₃ _ _ ⋙ whiskeringRight C₂ _ _ ⋙ whiskeringRight C₁ _ _\n\n"}
{"name":"CategoryTheory.Functor.postcompose₃_obj_map_app_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_10, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_11, u_3} C₃\nE : Type u_7\ninst✝¹ : CategoryTheory.Category.{u_12, u_7} E\nE' : Type u_8\ninst✝ : CategoryTheory.Category.{u_13, u_8} E'\nX✝³ : CategoryTheory.Functor E E'\nX✝² Y✝ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ E))\nα : Quiver.Hom X✝² Y✝\nX✝¹ : C₁\nX✝ : C₂\nX : C₃\n⊢ Eq (((((CategoryTheory.Functor.postcompose₃.obj X✝³).map α).app X✝¹).app X✝).app X) (X✝³.map (((α.app X✝¹).app X✝).app X))","decl":"/-- The \"postcomposition\" with a functor `E ⥤ E'` gives a functor\n`(E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ E'`. -/\n@[simps!]\ndef Functor.postcompose₃ {E' : Type*} [Category E'] :\n    (E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ E' :=\n  whiskeringRight C₃ _ _ ⋙ whiskeringRight C₂ _ _ ⋙ whiskeringRight C₁ _ _\n\n"}
{"name":"CategoryTheory.Functor.postcompose₃_obj_obj_obj_obj_map","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_10, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_11, u_3} C₃\nE : Type u_7\ninst✝¹ : CategoryTheory.Category.{u_12, u_7} E\nE' : Type u_8\ninst✝ : CategoryTheory.Category.{u_13, u_8} E'\nX✝² : CategoryTheory.Functor E E'\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ E))\nX✝¹ : C₁\nX : C₂\nX✝ Y✝ : C₃\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (((((CategoryTheory.Functor.postcompose₃.obj X✝²).obj F).obj X✝¹).obj X).map f) (X✝².map (((F.obj X✝¹).obj X).map f))","decl":"/-- The \"postcomposition\" with a functor `E ⥤ E'` gives a functor\n`(E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ E'`. -/\n@[simps!]\ndef Functor.postcompose₃ {E' : Type*} [Category E'] :\n    (E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ E' :=\n  whiskeringRight C₃ _ _ ⋙ whiskeringRight C₂ _ _ ⋙ whiskeringRight C₁ _ _\n\n"}
{"name":"CategoryTheory.Functor.postcompose₃_map_app_app_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_10, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_11, u_3} C₃\nE : Type u_7\ninst✝¹ : CategoryTheory.Category.{u_12, u_7} E\nE' : Type u_8\ninst✝ : CategoryTheory.Category.{u_13, u_8} E'\nX✝ Y✝ : CategoryTheory.Functor E E'\nf : Quiver.Hom X✝ Y✝\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ E))\nc✝¹ : C₁\nc✝ : C₂\nc : C₃\n⊢ Eq (((((CategoryTheory.Functor.postcompose₃.map f).app F).app c✝¹).app c✝).app c) (f.app (((F.obj c✝¹).obj c✝).obj c))","decl":"/-- The \"postcomposition\" with a functor `E ⥤ E'` gives a functor\n`(E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ E'`. -/\n@[simps!]\ndef Functor.postcompose₃ {E' : Type*} [Category E'] :\n    (E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ E' :=\n  whiskeringRight C₃ _ _ ⋙ whiskeringRight C₂ _ _ ⋙ whiskeringRight C₁ _ _\n\n"}
{"name":"CategoryTheory.Functor.postcompose₃_obj_obj_obj_obj_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_10, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_11, u_3} C₃\nE : Type u_7\ninst✝¹ : CategoryTheory.Category.{u_12, u_7} E\nE' : Type u_8\ninst✝ : CategoryTheory.Category.{u_13, u_8} E'\nX✝² : CategoryTheory.Functor E E'\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ E))\nX✝¹ : C₁\nX✝ : C₂\nX : C₃\n⊢ Eq (((((CategoryTheory.Functor.postcompose₃.obj X✝²).obj F).obj X✝¹).obj X✝).obj X) (X✝².obj (((F.obj X✝¹).obj X✝).obj X))","decl":"/-- The \"postcomposition\" with a functor `E ⥤ E'` gives a functor\n`(E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ E'`. -/\n@[simps!]\ndef Functor.postcompose₃ {E' : Type*} [Category E'] :\n    (E ⥤ E') ⥤ (C₁ ⥤ C₂ ⥤ C₃ ⥤ E) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ E' :=\n  whiskeringRight C₃ _ _ ⋙ whiskeringRight C₂ _ _ ⋙ whiskeringRight C₁ _ _\n\n"}
