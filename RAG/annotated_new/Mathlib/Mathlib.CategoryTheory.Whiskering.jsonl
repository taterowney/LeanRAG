{"name":"CategoryTheory.whiskerLeft_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG H : CategoryTheory.Functor D E\nŒ± : Quiver.Hom G H\nX : C\n‚ä¢ Eq ((CategoryTheory.whiskerLeft F Œ±).app X) (Œ±.app (F.obj X))","decl":"/-- If `Œ± : G ‚ü∂ H` then\n`whiskerLeft F Œ± : (F ‚ãô G) ‚ü∂ (F ‚ãô H)` has components `Œ±.app (F.obj X)`.\n-/\n@[simps]\ndef whiskerLeft (F : C ‚•§ D) {G H : D ‚•§ E} (Œ± : G ‚ü∂ H) :\n    F ‚ãô G ‚ü∂ F ‚ãô H where\n  app X := Œ±.app (F.obj X)\n  naturality X Y f := by rw [Functor.comp_map, Functor.comp_map, Œ±.naturality]\n\n"}
{"name":"CategoryTheory.whiskerRight_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nG H : CategoryTheory.Functor C D\nŒ± : Quiver.Hom G H\nF : CategoryTheory.Functor D E\nX : C\n‚ä¢ Eq ((CategoryTheory.whiskerRight Œ± F).app X) (F.map (Œ±.app X))","decl":"/-- If `Œ± : G ‚ü∂ H` then\n`whisker_right Œ± F : (G ‚ãô F) ‚ü∂ (G ‚ãô F)` has components `F.map (Œ±.app X)`.\n-/\n@[simps]\ndef whiskerRight {G H : C ‚•§ D} (Œ± : G ‚ü∂ H) (F : D ‚•§ E) :\n    G ‚ãô F ‚ü∂ H ‚ãô F where\n  app X := F.map (Œ±.app X)\n  naturality X Y f := by\n    rw [Functor.comp_map, Functor.comp_map, ‚Üê F.map_comp, ‚Üê F.map_comp, Œ±.naturality]\n\n"}
{"name":"CategoryTheory.whiskeringLeft_obj_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\n‚ä¢ Eq (((CategoryTheory.whiskeringLeft C D E).obj F).obj G) (F.comp G)","decl":"/-- Left-composition gives a functor `(C ‚•§ D) ‚•§ ((D ‚•§ E) ‚•§ (C ‚•§ E))`.\n\n`(whiskeringLeft.obj F).obj G` is `F ‚ãô G`, and\n`(whiskeringLeft.obj F).map Œ±` is `whiskerLeft F Œ±`.\n-/\n@[simps]\ndef whiskeringLeft : (C ‚•§ D) ‚•§ (D ‚•§ E) ‚•§ C ‚•§ E where\n  obj F :=\n    { obj := fun G => F ‚ãô G\n      map := fun Œ± => whiskerLeft F Œ± }\n  map œÑ :=\n    { app := fun H =>\n        { app := fun c => H.map (œÑ.app c)\n          naturality := fun X Y f => by dsimp; rw [‚Üê H.map_comp, ‚Üê H.map_comp, ‚Üê œÑ.naturality] }\n      naturality := fun X Y f => by ext; dsimp; rw [f.naturality] }\n\n"}
{"name":"CategoryTheory.whiskeringLeft_map_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nX‚úù Y‚úù : CategoryTheory.Functor C D\nœÑ : Quiver.Hom X‚úù Y‚úù\nH : CategoryTheory.Functor D E\nc : C\n‚ä¢ Eq ((((CategoryTheory.whiskeringLeft C D E).map œÑ).app H).app c) (H.map (œÑ.app c))","decl":"/-- Left-composition gives a functor `(C ‚•§ D) ‚•§ ((D ‚•§ E) ‚•§ (C ‚•§ E))`.\n\n`(whiskeringLeft.obj F).obj G` is `F ‚ãô G`, and\n`(whiskeringLeft.obj F).map Œ±` is `whiskerLeft F Œ±`.\n-/\n@[simps]\ndef whiskeringLeft : (C ‚•§ D) ‚•§ (D ‚•§ E) ‚•§ C ‚•§ E where\n  obj F :=\n    { obj := fun G => F ‚ãô G\n      map := fun Œ± => whiskerLeft F Œ± }\n  map œÑ :=\n    { app := fun H =>\n        { app := fun c => H.map (œÑ.app c)\n          naturality := fun X Y f => by dsimp; rw [‚Üê H.map_comp, ‚Üê H.map_comp, ‚Üê œÑ.naturality] }\n      naturality := fun X Y f => by ext; dsimp; rw [f.naturality] }\n\n"}
{"name":"CategoryTheory.whiskeringLeft_obj_map","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nX‚úù Y‚úù : CategoryTheory.Functor D E\nŒ± : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((CategoryTheory.whiskeringLeft C D E).obj F).map Œ±) (CategoryTheory.whiskerLeft F Œ±)","decl":"/-- Left-composition gives a functor `(C ‚•§ D) ‚•§ ((D ‚•§ E) ‚•§ (C ‚•§ E))`.\n\n`(whiskeringLeft.obj F).obj G` is `F ‚ãô G`, and\n`(whiskeringLeft.obj F).map Œ±` is `whiskerLeft F Œ±`.\n-/\n@[simps]\ndef whiskeringLeft : (C ‚•§ D) ‚•§ (D ‚•§ E) ‚•§ C ‚•§ E where\n  obj F :=\n    { obj := fun G => F ‚ãô G\n      map := fun Œ± => whiskerLeft F Œ± }\n  map œÑ :=\n    { app := fun H =>\n        { app := fun c => H.map (œÑ.app c)\n          naturality := fun X Y f => by dsimp; rw [‚Üê H.map_comp, ‚Üê H.map_comp, ‚Üê œÑ.naturality] }\n      naturality := fun X Y f => by ext; dsimp; rw [f.naturality] }\n\n"}
{"name":"CategoryTheory.whiskeringRight_map_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nX‚úù Y‚úù : CategoryTheory.Functor D E\nœÑ : Quiver.Hom X‚úù Y‚úù\nF : CategoryTheory.Functor C D\nc : C\n‚ä¢ Eq ((((CategoryTheory.whiskeringRight C D E).map œÑ).app F).app c) (œÑ.app (F.obj c))","decl":"/-- Right-composition gives a functor `(D ‚•§ E) ‚•§ ((C ‚•§ D) ‚•§ (C ‚•§ E))`.\n\n`(whiskeringRight.obj H).obj F` is `F ‚ãô H`, and\n`(whiskeringRight.obj H).map Œ±` is `whiskerRight Œ± H`.\n-/\n@[simps]\ndef whiskeringRight : (D ‚•§ E) ‚•§ (C ‚•§ D) ‚•§ C ‚•§ E where\n  obj H :=\n    { obj := fun F => F ‚ãô H\n      map := fun Œ± => whiskerRight Œ± H }\n  map œÑ :=\n    { app := fun F =>\n        { app := fun c => œÑ.app (F.obj c)\n          naturality := fun X Y f => by dsimp; rw [œÑ.naturality] }\n      naturality := fun X Y f => by ext; dsimp; rw [‚Üê NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.whiskeringRight_obj_map","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nH : CategoryTheory.Functor D E\nX‚úù Y‚úù : CategoryTheory.Functor C D\nŒ± : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((CategoryTheory.whiskeringRight C D E).obj H).map Œ±) (CategoryTheory.whiskerRight Œ± H)","decl":"/-- Right-composition gives a functor `(D ‚•§ E) ‚•§ ((C ‚•§ D) ‚•§ (C ‚•§ E))`.\n\n`(whiskeringRight.obj H).obj F` is `F ‚ãô H`, and\n`(whiskeringRight.obj H).map Œ±` is `whiskerRight Œ± H`.\n-/\n@[simps]\ndef whiskeringRight : (D ‚•§ E) ‚•§ (C ‚•§ D) ‚•§ C ‚•§ E where\n  obj H :=\n    { obj := fun F => F ‚ãô H\n      map := fun Œ± => whiskerRight Œ± H }\n  map œÑ :=\n    { app := fun F =>\n        { app := fun c => œÑ.app (F.obj c)\n          naturality := fun X Y f => by dsimp; rw [œÑ.naturality] }\n      naturality := fun X Y f => by ext; dsimp; rw [‚Üê NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.whiskeringRight_obj_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nH : CategoryTheory.Functor D E\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (((CategoryTheory.whiskeringRight C D E).obj H).obj F) (F.comp H)","decl":"/-- Right-composition gives a functor `(D ‚•§ E) ‚•§ ((C ‚•§ D) ‚•§ (C ‚•§ E))`.\n\n`(whiskeringRight.obj H).obj F` is `F ‚ãô H`, and\n`(whiskeringRight.obj H).map Œ±` is `whiskerRight Œ± H`.\n-/\n@[simps]\ndef whiskeringRight : (D ‚•§ E) ‚•§ (C ‚•§ D) ‚•§ C ‚•§ E where\n  obj H :=\n    { obj := fun F => F ‚ãô H\n      map := fun Œ± => whiskerRight Œ± H }\n  map œÑ :=\n    { app := fun F =>\n        { app := fun c => œÑ.app (F.obj c)\n          naturality := fun X Y f => by dsimp; rw [œÑ.naturality] }\n      naturality := fun X Y f => by ext; dsimp; rw [‚Üê NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.faithful_whiskeringRight_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor D E\ninst‚úù : F.Faithful\n‚ä¢ ((CategoryTheory.whiskeringRight C D E).obj F).Faithful","decl":"instance faithful_whiskeringRight_obj {F : D ‚•§ E} [F.Faithful] :\n    ((whiskeringRight C D E).obj F).Faithful where\n  map_injective hŒ±Œ≤ := by\n    ext X\n    exact F.map_injective <| congr_fun (congr_arg NatTrans.app hŒ±Œ≤) X\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.whiskeringRight_preimage_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"D : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor D E\nhF : F.FullyFaithful\nC : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX‚úù Y‚úù : CategoryTheory.Functor C D\nf : Quiver.Hom (((CategoryTheory.whiskeringRight C D E).obj F).obj X‚úù) (((CategoryTheory.whiskeringRight C D E).obj F).obj Y‚úù)\nX : C\n‚ä¢ Eq (((hF.whiskeringRight C).preimage f).app X) (hF.preimage (f.app X))","decl":"/-- If `F : D ‚•§ E` is fully faithful, then so is\n`(whiskeringRight C D E).obj F : (C ‚•§ D) ‚•§ C ‚•§ E`. -/\n@[simps]\ndef Functor.FullyFaithful.whiskeringRight {F : D ‚•§ E} (hF : F.FullyFaithful)\n    (C : Type*) [Category C] :\n    ((whiskeringRight C D E).obj F).FullyFaithful where\n  preimage f :=\n    { app := fun X => hF.preimage (f.app X)\n      naturality := fun _ _ g => by\n        apply hF.map_injective\n        dsimp\n        simp only [map_comp, map_preimage]\n        apply f.naturality }\n\n"}
{"name":"CategoryTheory.whiskeringLeft_obj_id","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\n‚ä¢ Eq ((CategoryTheory.whiskeringLeft C C E).obj (CategoryTheory.Functor.id C)) (CategoryTheory.Functor.id (CategoryTheory.Functor C E))","decl":"theorem whiskeringLeft_obj_id : (whiskeringLeft C C E).obj (ùü≠ _) = ùü≠ _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskeringLeft_obj_comp","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D D'\n‚ä¢ Eq ((CategoryTheory.whiskeringLeft C D' E).obj (F.comp G)) (((CategoryTheory.whiskeringLeft D D' E).obj G).comp ((CategoryTheory.whiskeringLeft C D E).obj F))","decl":"theorem whiskeringLeft_obj_comp {D' : Type u‚ÇÑ} [Category.{v‚ÇÑ} D'] (F : C ‚•§ D) (G : D ‚•§ D') :\n    (whiskeringLeft C D' E).obj (F ‚ãô G) =\n    (whiskeringLeft D D' E).obj G ‚ãô (whiskeringLeft C D E).obj F :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskeringRight_obj_id","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\n‚ä¢ Eq ((CategoryTheory.whiskeringRight E C C).obj (CategoryTheory.Functor.id C)) (CategoryTheory.Functor.id (CategoryTheory.Functor E C))","decl":"theorem whiskeringRight_obj_id : (whiskeringRight E C C).obj (ùü≠ _) = ùü≠ _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskeringRight_obj_comp","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nD' : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D'\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D D'\n‚ä¢ Eq (((CategoryTheory.whiskeringRight E C D).obj F).comp ((CategoryTheory.whiskeringRight E D D').obj G)) ((CategoryTheory.whiskeringRight E C D').obj (F.comp G))","decl":"theorem whiskeringRight_obj_comp {D' : Type u‚ÇÑ} [Category.{v‚ÇÑ} D'] (F : C ‚•§ D) (G : D ‚•§ D') :\n    (whiskeringRight E C D).obj F ‚ãô (whiskeringRight E D D').obj G =\n    (whiskeringRight E C D').obj (F ‚ãô G) :=\n  rfl\n\n"}
{"name":"CategoryTheory.full_whiskeringRight_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor D E\ninst‚úù¬π : F.Faithful\ninst‚úù : F.Full\n‚ä¢ ((CategoryTheory.whiskeringRight C D E).obj F).Full","decl":"instance full_whiskeringRight_obj {F : D ‚•§ E} [F.Faithful] [F.Full] :\n    ((whiskeringRight C D E).obj F).Full :=\n  ((Functor.FullyFaithful.ofFullyFaithful F).whiskeringRight C).full\n\n"}
{"name":"CategoryTheory.whiskerLeft_id","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\n‚ä¢ Eq (CategoryTheory.whiskerLeft F (CategoryTheory.NatTrans.id G)) (CategoryTheory.NatTrans.id (F.comp G))","decl":"@[simp]\ntheorem whiskerLeft_id (F : C ‚•§ D) {G : D ‚•§ E} :\n    whiskerLeft F (NatTrans.id G) = NatTrans.id (F.comp G) :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskerLeft_id'","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\n‚ä¢ Eq (CategoryTheory.whiskerLeft F (CategoryTheory.CategoryStruct.id G)) (CategoryTheory.CategoryStruct.id (F.comp G))","decl":"@[simp]\ntheorem whiskerLeft_id' (F : C ‚•§ D) {G : D ‚•§ E} : whiskerLeft F (ùüô G) = ùüô (F.comp G) :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskerRight_id","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nG : CategoryTheory.Functor C D\nF : CategoryTheory.Functor D E\n‚ä¢ Eq (CategoryTheory.whiskerRight (CategoryTheory.NatTrans.id G) F) (CategoryTheory.NatTrans.id (G.comp F))","decl":"@[simp]\ntheorem whiskerRight_id {G : C ‚•§ D} (F : D ‚•§ E) :\n    whiskerRight (NatTrans.id G) F = NatTrans.id (G.comp F) :=\n  ((whiskeringRight C D E).obj F).map_id _\n\n"}
{"name":"CategoryTheory.whiskerRight_id'","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nG : CategoryTheory.Functor C D\nF : CategoryTheory.Functor D E\n‚ä¢ Eq (CategoryTheory.whiskerRight (CategoryTheory.CategoryStruct.id G) F) (CategoryTheory.CategoryStruct.id (G.comp F))","decl":"@[simp]\ntheorem whiskerRight_id' {G : C ‚•§ D} (F : D ‚•§ E) : whiskerRight (ùüô G) F = ùüô (G.comp F) :=\n  ((whiskeringRight C D E).obj F).map_id _\n\n"}
{"name":"CategoryTheory.whiskerLeft_comp","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG H K : CategoryTheory.Functor D E\nŒ± : Quiver.Hom G H\nŒ≤ : Quiver.Hom H K\n‚ä¢ Eq (CategoryTheory.whiskerLeft F (CategoryTheory.CategoryStruct.comp Œ± Œ≤)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft F Œ±) (CategoryTheory.whiskerLeft F Œ≤))","decl":"@[simp, reassoc]\ntheorem whiskerLeft_comp (F : C ‚•§ D) {G H K : D ‚•§ E} (Œ± : G ‚ü∂ H) (Œ≤ : H ‚ü∂ K) :\n    whiskerLeft F (Œ± ‚â´ Œ≤) = whiskerLeft F Œ± ‚â´ whiskerLeft F Œ≤ :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskerLeft_comp_assoc","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG H K : CategoryTheory.Functor D E\nŒ± : Quiver.Hom G H\nŒ≤ : Quiver.Hom H K\nZ : CategoryTheory.Functor C E\nh : Quiver.Hom (F.comp K) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft F (CategoryTheory.CategoryStruct.comp Œ± Œ≤)) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft F Œ±) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft F Œ≤) h))","decl":"@[simp, reassoc]\ntheorem whiskerLeft_comp (F : C ‚•§ D) {G H K : D ‚•§ E} (Œ± : G ‚ü∂ H) (Œ≤ : H ‚ü∂ K) :\n    whiskerLeft F (Œ± ‚â´ Œ≤) = whiskerLeft F Œ± ‚â´ whiskerLeft F Œ≤ :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskerRight_comp_assoc","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nG H K : CategoryTheory.Functor C D\nŒ± : Quiver.Hom G H\nŒ≤ : Quiver.Hom H K\nF : CategoryTheory.Functor D E\nZ : CategoryTheory.Functor C E\nh : Quiver.Hom (K.comp F) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.CategoryStruct.comp Œ± Œ≤) F) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight Œ± F) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight Œ≤ F) h))","decl":"@[simp, reassoc]\ntheorem whiskerRight_comp {G H K : C ‚•§ D} (Œ± : G ‚ü∂ H) (Œ≤ : H ‚ü∂ K) (F : D ‚•§ E) :\n    whiskerRight (Œ± ‚â´ Œ≤) F = whiskerRight Œ± F ‚â´ whiskerRight Œ≤ F :=\n  ((whiskeringRight C D E).obj F).map_comp Œ± Œ≤\n\n"}
{"name":"CategoryTheory.whiskerRight_comp","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nG H K : CategoryTheory.Functor C D\nŒ± : Quiver.Hom G H\nŒ≤ : Quiver.Hom H K\nF : CategoryTheory.Functor D E\n‚ä¢ Eq (CategoryTheory.whiskerRight (CategoryTheory.CategoryStruct.comp Œ± Œ≤) F) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight Œ± F) (CategoryTheory.whiskerRight Œ≤ F))","decl":"@[simp, reassoc]\ntheorem whiskerRight_comp {G H K : C ‚•§ D} (Œ± : G ‚ü∂ H) (Œ≤ : H ‚ü∂ K) (F : D ‚•§ E) :\n    whiskerRight (Œ± ‚â´ Œ≤) F = whiskerRight Œ± F ‚â´ whiskerRight Œ≤ F :=\n  ((whiskeringRight C D E).obj F).map_comp Œ± Œ≤\n\n"}
{"name":"CategoryTheory.isoWhiskerLeft_hom","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG H : CategoryTheory.Functor D E\nŒ± : CategoryTheory.Iso G H\n‚ä¢ Eq (CategoryTheory.isoWhiskerLeft F Œ±).hom (CategoryTheory.whiskerLeft F Œ±.hom)","decl":"@[simp]\ntheorem isoWhiskerLeft_hom (F : C ‚•§ D) {G H : D ‚•§ E} (Œ± : G ‚âÖ H) :\n    (isoWhiskerLeft F Œ±).hom = whiskerLeft F Œ±.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.isoWhiskerLeft_inv","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG H : CategoryTheory.Functor D E\nŒ± : CategoryTheory.Iso G H\n‚ä¢ Eq (CategoryTheory.isoWhiskerLeft F Œ±).inv (CategoryTheory.whiskerLeft F Œ±.inv)","decl":"@[simp]\ntheorem isoWhiskerLeft_inv (F : C ‚•§ D) {G H : D ‚•§ E} (Œ± : G ‚âÖ H) :\n    (isoWhiskerLeft F Œ±).inv = whiskerLeft F Œ±.inv :=\n  rfl\n\n"}
{"name":"CategoryTheory.isoWhiskerRight_hom","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nG H : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso G H\nF : CategoryTheory.Functor D E\n‚ä¢ Eq (CategoryTheory.isoWhiskerRight Œ± F).hom (CategoryTheory.whiskerRight Œ±.hom F)","decl":"@[simp]\ntheorem isoWhiskerRight_hom {G H : C ‚•§ D} (Œ± : G ‚âÖ H) (F : D ‚•§ E) :\n    (isoWhiskerRight Œ± F).hom = whiskerRight Œ±.hom F :=\n  rfl\n\n"}
{"name":"CategoryTheory.isoWhiskerRight_inv","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nG H : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso G H\nF : CategoryTheory.Functor D E\n‚ä¢ Eq (CategoryTheory.isoWhiskerRight Œ± F).inv (CategoryTheory.whiskerRight Œ±.inv F)","decl":"@[simp]\ntheorem isoWhiskerRight_inv {G H : C ‚•§ D} (Œ± : G ‚âÖ H) (F : D ‚•§ E) :\n    (isoWhiskerRight Œ± F).inv = whiskerRight Œ±.inv F :=\n  rfl\n\n"}
{"name":"CategoryTheory.isIso_whiskerLeft","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG H : CategoryTheory.Functor D E\nŒ± : Quiver.Hom G H\ninst‚úù : CategoryTheory.IsIso Œ±\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.whiskerLeft F Œ±)","decl":"instance isIso_whiskerLeft (F : C ‚•§ D) {G H : D ‚•§ E} (Œ± : G ‚ü∂ H) [IsIso Œ±] :\n    IsIso (whiskerLeft F Œ±) :=\n  (isoWhiskerLeft F (asIso Œ±)).isIso_hom\n\n"}
{"name":"CategoryTheory.isIso_whiskerRight","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nG H : CategoryTheory.Functor C D\nŒ± : Quiver.Hom G H\nF : CategoryTheory.Functor D E\ninst‚úù : CategoryTheory.IsIso Œ±\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.whiskerRight Œ± F)","decl":"instance isIso_whiskerRight {G H : C ‚•§ D} (Œ± : G ‚ü∂ H) (F : D ‚•§ E) [IsIso Œ±] :\n    IsIso (whiskerRight Œ± F) :=\n  (isoWhiskerRight (asIso Œ±) F).isIso_hom\n\n"}
{"name":"CategoryTheory.whiskerLeft_twice","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nF : CategoryTheory.Functor B C\nG : CategoryTheory.Functor C D\nH K : CategoryTheory.Functor D E\nŒ± : Quiver.Hom H K\n‚ä¢ Eq (CategoryTheory.whiskerLeft F (CategoryTheory.whiskerLeft G Œ±)) (CategoryTheory.whiskerLeft (F.comp G) Œ±)","decl":"@[simp]\ntheorem whiskerLeft_twice (F : B ‚•§ C) (G : C ‚•§ D) {H K : D ‚•§ E} (Œ± : H ‚ü∂ K) :\n    whiskerLeft F (whiskerLeft G Œ±) = whiskerLeft (F ‚ãô G) Œ± :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskerRight_twice","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nH K : CategoryTheory.Functor B C\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\nŒ± : Quiver.Hom H K\n‚ä¢ Eq (CategoryTheory.whiskerRight (CategoryTheory.whiskerRight Œ± F) G) (CategoryTheory.whiskerRight Œ± (F.comp G))","decl":"@[simp]\ntheorem whiskerRight_twice {H K : B ‚•§ C} (F : C ‚•§ D) (G : D ‚•§ E) (Œ± : H ‚ü∂ K) :\n    whiskerRight (whiskerRight Œ± F) G = whiskerRight Œ± (F ‚ãô G) :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskerRight_left","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nB : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} B\nF : CategoryTheory.Functor B C\nG H : CategoryTheory.Functor C D\nŒ± : Quiver.Hom G H\nK : CategoryTheory.Functor D E\n‚ä¢ Eq (CategoryTheory.whiskerRight (CategoryTheory.whiskerLeft F Œ±) K) (CategoryTheory.whiskerLeft F (CategoryTheory.whiskerRight Œ± K))","decl":"theorem whiskerRight_left (F : B ‚•§ C) {G H : C ‚•§ D} (Œ± : G ‚ü∂ H) (K : D ‚•§ E) :\n    whiskerRight (whiskerLeft F Œ±) K = whiskerLeft F (whiskerRight Œ± K) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.leftUnitor_hom_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nF : CategoryTheory.Functor A B\nX : A\n‚ä¢ Eq (F.leftUnitor.hom.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The left unitor, a natural isomorphism `((ùü≠ _) ‚ãô F) ‚âÖ F`.\n-/\n@[simps]\ndef leftUnitor (F : A ‚•§ B) :\n    ùü≠ A ‚ãô F ‚âÖ F where\n  hom := { app := fun X => ùüô (F.obj X) }\n  inv := { app := fun X => ùüô (F.obj X) }\n\n"}
{"name":"CategoryTheory.Functor.leftUnitor_inv_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nF : CategoryTheory.Functor A B\nX : A\n‚ä¢ Eq (F.leftUnitor.inv.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The left unitor, a natural isomorphism `((ùü≠ _) ‚ãô F) ‚âÖ F`.\n-/\n@[simps]\ndef leftUnitor (F : A ‚•§ B) :\n    ùü≠ A ‚ãô F ‚âÖ F where\n  hom := { app := fun X => ùüô (F.obj X) }\n  inv := { app := fun X => ùüô (F.obj X) }\n\n"}
{"name":"CategoryTheory.Functor.rightUnitor_hom_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nF : CategoryTheory.Functor A B\nX : A\n‚ä¢ Eq (F.rightUnitor.hom.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The right unitor, a natural isomorphism `(F ‚ãô (ùü≠ B)) ‚âÖ F`.\n-/\n@[simps]\ndef rightUnitor (F : A ‚•§ B) :\n    F ‚ãô ùü≠ B ‚âÖ F where\n  hom := { app := fun X => ùüô (F.obj X) }\n  inv := { app := fun X => ùüô (F.obj X) }\n\n"}
{"name":"CategoryTheory.Functor.rightUnitor_inv_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nF : CategoryTheory.Functor A B\nX : A\n‚ä¢ Eq (F.rightUnitor.inv.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The right unitor, a natural isomorphism `(F ‚ãô (ùü≠ B)) ‚âÖ F`.\n-/\n@[simps]\ndef rightUnitor (F : A ‚•§ B) :\n    F ‚ãô ùü≠ B ‚âÖ F where\n  hom := { app := fun X => ùüô (F.obj X) }\n  inv := { app := fun X => ùüô (F.obj X) }\n\n"}
{"name":"CategoryTheory.Functor.associator_inv_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor B C\nH : CategoryTheory.Functor C D\nx‚úù : A\n‚ä¢ Eq ((F.associator G H).inv.app x‚úù) (CategoryTheory.CategoryStruct.id ((F.comp (G.comp H)).obj x‚úù))","decl":"/-- The associator for functors, a natural isomorphism `((F ‚ãô G) ‚ãô H) ‚âÖ (F ‚ãô (G ‚ãô H))`.\n\n(In fact, `iso.refl _` will work here, but it tends to make Lean slow later,\nand it's usually best to insert explicit associators.)\n-/\n@[simps]\ndef associator (F : A ‚•§ B) (G : B ‚•§ C) (H : C ‚•§ D) :\n    (F ‚ãô G) ‚ãô H ‚âÖ F ‚ãô G ‚ãô H where\n  hom := { app := fun _ => ùüô _ }\n  inv := { app := fun _ => ùüô _ }\n\n"}
{"name":"CategoryTheory.Functor.associator_hom_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor B C\nH : CategoryTheory.Functor C D\nx‚úù : A\n‚ä¢ Eq ((F.associator G H).hom.app x‚úù) (CategoryTheory.CategoryStruct.id (((F.comp G).comp H).obj x‚úù))","decl":"/-- The associator for functors, a natural isomorphism `((F ‚ãô G) ‚ãô H) ‚âÖ (F ‚ãô (G ‚ãô H))`.\n\n(In fact, `iso.refl _` will work here, but it tends to make Lean slow later,\nand it's usually best to insert explicit associators.)\n-/\n@[simps]\ndef associator (F : A ‚•§ B) (G : B ‚•§ C) (H : C ‚•§ D) :\n    (F ‚ãô G) ‚ãô H ‚âÖ F ‚ãô G ‚ãô H where\n  hom := { app := fun _ => ùüô _ }\n  inv := { app := fun _ => ùüô _ }\n\n"}
{"name":"CategoryTheory.Functor.assoc","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor B C\nH : CategoryTheory.Functor C D\n‚ä¢ Eq ((F.comp G).comp H) (F.comp (G.comp H))","decl":"protected theorem assoc (F : A ‚•§ B) (G : B ‚•§ C) (H : C ‚•§ D) : (F ‚ãô G) ‚ãô H = F ‚ãô G ‚ãô H :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.triangle","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor B C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.associator (CategoryTheory.Functor.id B) G).hom (CategoryTheory.whiskerLeft F G.leftUnitor.hom)) (CategoryTheory.whiskerRight F.rightUnitor.hom G)","decl":"theorem triangle (F : A ‚•§ B) (G : B ‚•§ C) :\n    (associator F (ùü≠ B) G).hom ‚â´ whiskerLeft F (leftUnitor G).hom =\n      whiskerRight (rightUnitor F).hom G := by aesop_cat\n\n-- See note [dsimp, simp].\n"}
{"name":"CategoryTheory.Functor.pentagon","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"A : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nE : Type u‚ÇÖ\ninst‚úù : CategoryTheory.Category.{v‚ÇÖ, u‚ÇÖ} E\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor B C\nH : CategoryTheory.Functor C D\nK : CategoryTheory.Functor D E\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (F.associator G H).hom K) (CategoryTheory.CategoryStruct.comp (F.associator (G.comp H) K).hom (CategoryTheory.whiskerLeft F (G.associator H K).hom))) (CategoryTheory.CategoryStruct.comp ((F.comp G).associator H K).hom (F.associator G (H.comp K)).hom)","decl":"theorem pentagon :\n    whiskerRight (associator F G H).hom K ‚â´\n        (associator F (G ‚ãô H) K).hom ‚â´ whiskerLeft F (associator G H K).hom =\n      (associator (F ‚ãô G) H K).hom ‚â´ (associator F G (H ‚ãô K)).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÇ_map_app_app_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_10, u_4} D‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u_11, u_5} D‚ÇÇ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_12, u_7} E\nX‚úù¬π Y‚úù : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nœà : Quiver.Hom X‚úù¬π Y‚úù\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nX‚úù : CategoryTheory.Functor D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ E)\nc : C‚ÇÅ\nX : C‚ÇÇ\n‚ä¢ Eq ((((((CategoryTheory.whiskeringLeft‚ÇÇ E).map œà).app F‚ÇÇ).app X‚úù).app c).app X) ((X‚úù.map (œà.app c)).app (F‚ÇÇ.obj X))","decl":"/-- The obvious functor `(C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E)`. -/\n@[simps!]\ndef whiskeringLeft‚ÇÇ :\n    (C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E) where\n  obj F‚ÇÅ :=\n    { obj := fun F‚ÇÇ ‚Ü¶\n        (whiskeringRight D‚ÇÅ (D‚ÇÇ ‚•§ E) (C‚ÇÇ ‚•§ E)).obj ((whiskeringLeft C‚ÇÇ D‚ÇÇ E).obj F‚ÇÇ) ‚ãô\n          (whiskeringLeft C‚ÇÅ D‚ÇÅ (C‚ÇÇ ‚•§ E)).obj F‚ÇÅ\n      map := fun œÜ ‚Ü¶ whiskerRight\n        ((whiskeringRight D‚ÇÅ (D‚ÇÇ ‚•§ E) (C‚ÇÇ ‚•§ E)).map ((whiskeringLeft C‚ÇÇ D‚ÇÇ E).map œÜ)) _ }\n  map œà :=\n    { app := fun F‚ÇÇ ‚Ü¶ whiskerLeft _ ((whiskeringLeft C‚ÇÅ D‚ÇÅ (C‚ÇÇ ‚•§ E)).map œà) }\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÇ_obj_obj_obj_map_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_10, u_4} D‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u_11, u_5} D‚ÇÇ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_12, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nX‚úù¬π : CategoryTheory.Functor D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ E)\nX‚úù Y‚úù : C‚ÇÅ\nf : Quiver.Hom X‚úù Y‚úù\nX : C‚ÇÇ\n‚ä¢ Eq ((((((CategoryTheory.whiskeringLeft‚ÇÇ E).obj F‚ÇÅ).obj F‚ÇÇ).obj X‚úù¬π).map f).app X) ((X‚úù¬π.map (F‚ÇÅ.map f)).app (F‚ÇÇ.obj X))","decl":"/-- The obvious functor `(C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E)`. -/\n@[simps!]\ndef whiskeringLeft‚ÇÇ :\n    (C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E) where\n  obj F‚ÇÅ :=\n    { obj := fun F‚ÇÇ ‚Ü¶\n        (whiskeringRight D‚ÇÅ (D‚ÇÇ ‚•§ E) (C‚ÇÇ ‚•§ E)).obj ((whiskeringLeft C‚ÇÇ D‚ÇÇ E).obj F‚ÇÇ) ‚ãô\n          (whiskeringLeft C‚ÇÅ D‚ÇÅ (C‚ÇÇ ‚•§ E)).obj F‚ÇÅ\n      map := fun œÜ ‚Ü¶ whiskerRight\n        ((whiskeringRight D‚ÇÅ (D‚ÇÇ ‚•§ E) (C‚ÇÇ ‚•§ E)).map ((whiskeringLeft C‚ÇÇ D‚ÇÇ E).map œÜ)) _ }\n  map œà :=\n    { app := fun F‚ÇÇ ‚Ü¶ whiskerLeft _ ((whiskeringLeft C‚ÇÅ D‚ÇÅ (C‚ÇÇ ‚•§ E)).map œà) }\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÇ_obj_obj_map_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_10, u_4} D‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u_11, u_5} D‚ÇÇ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_12, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nX‚úù¬π Y‚úù : CategoryTheory.Functor D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ E)\nf : Quiver.Hom X‚úù¬π Y‚úù\nX‚úù : C‚ÇÅ\nX : C‚ÇÇ\n‚ä¢ Eq ((((((CategoryTheory.whiskeringLeft‚ÇÇ E).obj F‚ÇÅ).obj F‚ÇÇ).map f).app X‚úù).app X) ((f.app (F‚ÇÅ.obj X‚úù)).app (F‚ÇÇ.obj X))","decl":"/-- The obvious functor `(C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E)`. -/\n@[simps!]\ndef whiskeringLeft‚ÇÇ :\n    (C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E) where\n  obj F‚ÇÅ :=\n    { obj := fun F‚ÇÇ ‚Ü¶\n        (whiskeringRight D‚ÇÅ (D‚ÇÇ ‚•§ E) (C‚ÇÇ ‚•§ E)).obj ((whiskeringLeft C‚ÇÇ D‚ÇÇ E).obj F‚ÇÇ) ‚ãô\n          (whiskeringLeft C‚ÇÅ D‚ÇÅ (C‚ÇÇ ‚•§ E)).obj F‚ÇÅ\n      map := fun œÜ ‚Ü¶ whiskerRight\n        ((whiskeringRight D‚ÇÅ (D‚ÇÇ ‚•§ E) (C‚ÇÇ ‚•§ E)).map ((whiskeringLeft C‚ÇÇ D‚ÇÇ E).map œÜ)) _ }\n  map œà :=\n    { app := fun F‚ÇÇ ‚Ü¶ whiskerLeft _ ((whiskeringLeft C‚ÇÅ D‚ÇÅ (C‚ÇÇ ‚•§ E)).map œà) }\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÇ_obj_obj_obj_obj_map","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_10, u_4} D‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u_11, u_5} D‚ÇÇ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_12, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nX‚úù¬π : CategoryTheory.Functor D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ E)\nX : C‚ÇÅ\nX‚úù Y‚úù : C‚ÇÇ\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((((((CategoryTheory.whiskeringLeft‚ÇÇ E).obj F‚ÇÅ).obj F‚ÇÇ).obj X‚úù¬π).obj X).map f) ((X‚úù¬π.obj (F‚ÇÅ.obj X)).map (F‚ÇÇ.map f))","decl":"/-- The obvious functor `(C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E)`. -/\n@[simps!]\ndef whiskeringLeft‚ÇÇ :\n    (C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E) where\n  obj F‚ÇÅ :=\n    { obj := fun F‚ÇÇ ‚Ü¶\n        (whiskeringRight D‚ÇÅ (D‚ÇÇ ‚•§ E) (C‚ÇÇ ‚•§ E)).obj ((whiskeringLeft C‚ÇÇ D‚ÇÇ E).obj F‚ÇÇ) ‚ãô\n          (whiskeringLeft C‚ÇÅ D‚ÇÅ (C‚ÇÇ ‚•§ E)).obj F‚ÇÅ\n      map := fun œÜ ‚Ü¶ whiskerRight\n        ((whiskeringRight D‚ÇÅ (D‚ÇÇ ‚•§ E) (C‚ÇÇ ‚•§ E)).map ((whiskeringLeft C‚ÇÇ D‚ÇÇ E).map œÜ)) _ }\n  map œà :=\n    { app := fun F‚ÇÇ ‚Ü¶ whiskerLeft _ ((whiskeringLeft C‚ÇÅ D‚ÇÅ (C‚ÇÇ ‚•§ E)).map œà) }\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÇ_obj_obj_obj_obj_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_10, u_4} D‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u_11, u_5} D‚ÇÇ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_12, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nX‚úù¬π : CategoryTheory.Functor D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ E)\nX‚úù : C‚ÇÅ\nX : C‚ÇÇ\n‚ä¢ Eq ((((((CategoryTheory.whiskeringLeft‚ÇÇ E).obj F‚ÇÅ).obj F‚ÇÇ).obj X‚úù¬π).obj X‚úù).obj X) ((X‚úù¬π.obj (F‚ÇÅ.obj X‚úù)).obj (F‚ÇÇ.obj X))","decl":"/-- The obvious functor `(C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E)`. -/\n@[simps!]\ndef whiskeringLeft‚ÇÇ :\n    (C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E) where\n  obj F‚ÇÅ :=\n    { obj := fun F‚ÇÇ ‚Ü¶\n        (whiskeringRight D‚ÇÅ (D‚ÇÇ ‚•§ E) (C‚ÇÇ ‚•§ E)).obj ((whiskeringLeft C‚ÇÇ D‚ÇÇ E).obj F‚ÇÇ) ‚ãô\n          (whiskeringLeft C‚ÇÅ D‚ÇÅ (C‚ÇÇ ‚•§ E)).obj F‚ÇÅ\n      map := fun œÜ ‚Ü¶ whiskerRight\n        ((whiskeringRight D‚ÇÅ (D‚ÇÇ ‚•§ E) (C‚ÇÇ ‚•§ E)).map ((whiskeringLeft C‚ÇÇ D‚ÇÇ E).map œÜ)) _ }\n  map œà :=\n    { app := fun F‚ÇÇ ‚Ü¶ whiskerLeft _ ((whiskeringLeft C‚ÇÅ D‚ÇÅ (C‚ÇÇ ‚•§ E)).map œà) }\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÇ_obj_map_app_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_10, u_4} D‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{u_11, u_5} D‚ÇÇ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_12, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nX‚úù¬π Y‚úù : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nœÜ : Quiver.Hom X‚úù¬π Y‚úù\nX‚úù : CategoryTheory.Functor D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ E)\nX : C‚ÇÅ\nc : C‚ÇÇ\n‚ä¢ Eq ((((((CategoryTheory.whiskeringLeft‚ÇÇ E).obj F‚ÇÅ).map œÜ).app X‚úù).app X).app c) ((X‚úù.obj (F‚ÇÅ.obj X)).map (œÜ.app c))","decl":"/-- The obvious functor `(C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E)`. -/\n@[simps!]\ndef whiskeringLeft‚ÇÇ :\n    (C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E) where\n  obj F‚ÇÅ :=\n    { obj := fun F‚ÇÇ ‚Ü¶\n        (whiskeringRight D‚ÇÅ (D‚ÇÇ ‚•§ E) (C‚ÇÇ ‚•§ E)).obj ((whiskeringLeft C‚ÇÇ D‚ÇÇ E).obj F‚ÇÇ) ‚ãô\n          (whiskeringLeft C‚ÇÅ D‚ÇÅ (C‚ÇÇ ‚•§ E)).obj F‚ÇÅ\n      map := fun œÜ ‚Ü¶ whiskerRight\n        ((whiskeringRight D‚ÇÅ (D‚ÇÇ ‚•§ E) (C‚ÇÇ ‚•§ E)).map ((whiskeringLeft C‚ÇÇ D‚ÇÇ E).map œÜ)) _ }\n  map œà :=\n    { app := fun F‚ÇÇ ‚Ü¶ whiskerLeft _ ((whiskeringLeft C‚ÇÅ D‚ÇÅ (C‚ÇÇ ‚•§ E)).map œà) }\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÉObjObjObj_map_app_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\nD‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_5} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_6} D‚ÇÉ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_14, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nF‚ÇÉ : CategoryTheory.Functor C‚ÇÉ D‚ÇÉ\nX‚úù¬≤ Y‚úù : CategoryTheory.Functor D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ (CategoryTheory.Functor D‚ÇÉ E))\nf : Quiver.Hom X‚úù¬≤ Y‚úù\nX‚úù¬π : C‚ÇÅ\nX‚úù : C‚ÇÇ\nX : C‚ÇÉ\n‚ä¢ Eq (((((CategoryTheory.whiskeringLeft‚ÇÉObjObjObj E F‚ÇÅ F‚ÇÇ F‚ÇÉ).map f).app X‚úù¬π).app X‚úù).app X) (((f.app (F‚ÇÅ.obj X‚úù¬π)).app (F‚ÇÇ.obj X‚úù)).app (F‚ÇÉ.obj X))","decl":"/-- Auxiliary definition for `whiskeringLeft‚ÇÉ`. -/\n@[simps!]\ndef whiskeringLeft‚ÇÉObjObjObj (F‚ÇÅ : C‚ÇÅ ‚•§ D‚ÇÅ) (F‚ÇÇ : C‚ÇÇ ‚•§ D‚ÇÇ) (F‚ÇÉ : C‚ÇÉ ‚•§ D‚ÇÉ) :\n    (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ D‚ÇÉ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E :=\n  (whiskeringRight _ _ _).obj (((whiskeringLeft‚ÇÇ E).obj F‚ÇÇ).obj F‚ÇÉ) ‚ãô\n    (whiskeringLeft C‚ÇÅ D‚ÇÅ _).obj F‚ÇÅ\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÉObjObjObj_obj_obj_obj_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\nD‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_5} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_6} D‚ÇÉ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_14, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nF‚ÇÉ : CategoryTheory.Functor C‚ÇÉ D‚ÇÉ\nX‚úù¬≤ : CategoryTheory.Functor D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ (CategoryTheory.Functor D‚ÇÉ E))\nX‚úù¬π : C‚ÇÅ\nX‚úù : C‚ÇÇ\nX : C‚ÇÉ\n‚ä¢ Eq (((((CategoryTheory.whiskeringLeft‚ÇÉObjObjObj E F‚ÇÅ F‚ÇÇ F‚ÇÉ).obj X‚úù¬≤).obj X‚úù¬π).obj X‚úù).obj X) (((X‚úù¬≤.obj (F‚ÇÅ.obj X‚úù¬π)).obj (F‚ÇÇ.obj X‚úù)).obj (F‚ÇÉ.obj X))","decl":"/-- Auxiliary definition for `whiskeringLeft‚ÇÉ`. -/\n@[simps!]\ndef whiskeringLeft‚ÇÉObjObjObj (F‚ÇÅ : C‚ÇÅ ‚•§ D‚ÇÅ) (F‚ÇÇ : C‚ÇÇ ‚•§ D‚ÇÇ) (F‚ÇÉ : C‚ÇÉ ‚•§ D‚ÇÉ) :\n    (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ D‚ÇÉ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E :=\n  (whiskeringRight _ _ _).obj (((whiskeringLeft‚ÇÇ E).obj F‚ÇÇ).obj F‚ÇÉ) ‚ãô\n    (whiskeringLeft C‚ÇÅ D‚ÇÅ _).obj F‚ÇÅ\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÉObjObjObj_obj_obj_map_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\nD‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_5} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_6} D‚ÇÉ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_14, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nF‚ÇÉ : CategoryTheory.Functor C‚ÇÉ D‚ÇÉ\nX‚úù¬≤ : CategoryTheory.Functor D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ (CategoryTheory.Functor D‚ÇÉ E))\nX‚úù¬π : C‚ÇÅ\nX‚úù Y‚úù : C‚ÇÇ\nf : Quiver.Hom X‚úù Y‚úù\nX : C‚ÇÉ\n‚ä¢ Eq (((((CategoryTheory.whiskeringLeft‚ÇÉObjObjObj E F‚ÇÅ F‚ÇÇ F‚ÇÉ).obj X‚úù¬≤).obj X‚úù¬π).map f).app X) (((X‚úù¬≤.obj (F‚ÇÅ.obj X‚úù¬π)).map (F‚ÇÇ.map f)).app (F‚ÇÉ.obj X))","decl":"/-- Auxiliary definition for `whiskeringLeft‚ÇÉ`. -/\n@[simps!]\ndef whiskeringLeft‚ÇÉObjObjObj (F‚ÇÅ : C‚ÇÅ ‚•§ D‚ÇÅ) (F‚ÇÇ : C‚ÇÇ ‚•§ D‚ÇÇ) (F‚ÇÉ : C‚ÇÉ ‚•§ D‚ÇÉ) :\n    (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ D‚ÇÉ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E :=\n  (whiskeringRight _ _ _).obj (((whiskeringLeft‚ÇÇ E).obj F‚ÇÇ).obj F‚ÇÉ) ‚ãô\n    (whiskeringLeft C‚ÇÅ D‚ÇÅ _).obj F‚ÇÅ\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÉObjObjObj_obj_obj_obj_map","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\nD‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_5} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_6} D‚ÇÉ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_14, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nF‚ÇÉ : CategoryTheory.Functor C‚ÇÉ D‚ÇÉ\nX‚úù¬≤ : CategoryTheory.Functor D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ (CategoryTheory.Functor D‚ÇÉ E))\nX‚úù¬π : C‚ÇÅ\nX : C‚ÇÇ\nX‚úù Y‚úù : C‚ÇÉ\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((((CategoryTheory.whiskeringLeft‚ÇÉObjObjObj E F‚ÇÅ F‚ÇÇ F‚ÇÉ).obj X‚úù¬≤).obj X‚úù¬π).obj X).map f) (((X‚úù¬≤.obj (F‚ÇÅ.obj X‚úù¬π)).obj (F‚ÇÇ.obj X)).map (F‚ÇÉ.map f))","decl":"/-- Auxiliary definition for `whiskeringLeft‚ÇÉ`. -/\n@[simps!]\ndef whiskeringLeft‚ÇÉObjObjObj (F‚ÇÅ : C‚ÇÅ ‚•§ D‚ÇÅ) (F‚ÇÇ : C‚ÇÇ ‚•§ D‚ÇÇ) (F‚ÇÉ : C‚ÇÉ ‚•§ D‚ÇÉ) :\n    (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ D‚ÇÉ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E :=\n  (whiskeringRight _ _ _).obj (((whiskeringLeft‚ÇÇ E).obj F‚ÇÇ).obj F‚ÇÉ) ‚ãô\n    (whiskeringLeft C‚ÇÅ D‚ÇÅ _).obj F‚ÇÅ\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÉObjObjObj_obj_map_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\nD‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_5} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_6} D‚ÇÉ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_14, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nF‚ÇÉ : CategoryTheory.Functor C‚ÇÉ D‚ÇÉ\nX‚úù¬≤ : CategoryTheory.Functor D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ (CategoryTheory.Functor D‚ÇÉ E))\nX‚úù¬π Y‚úù : C‚ÇÅ\nf : Quiver.Hom X‚úù¬π Y‚úù\nX‚úù : C‚ÇÇ\nX : C‚ÇÉ\n‚ä¢ Eq (((((CategoryTheory.whiskeringLeft‚ÇÉObjObjObj E F‚ÇÅ F‚ÇÇ F‚ÇÉ).obj X‚úù¬≤).map f).app X‚úù).app X) (((X‚úù¬≤.map (F‚ÇÅ.map f)).app (F‚ÇÇ.obj X‚úù)).app (F‚ÇÉ.obj X))","decl":"/-- Auxiliary definition for `whiskeringLeft‚ÇÉ`. -/\n@[simps!]\ndef whiskeringLeft‚ÇÉObjObjObj (F‚ÇÅ : C‚ÇÅ ‚•§ D‚ÇÅ) (F‚ÇÇ : C‚ÇÇ ‚•§ D‚ÇÇ) (F‚ÇÉ : C‚ÇÉ ‚•§ D‚ÇÉ) :\n    (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ D‚ÇÉ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E :=\n  (whiskeringRight _ _ _).obj (((whiskeringLeft‚ÇÇ E).obj F‚ÇÇ).obj F‚ÇÉ) ‚ãô\n    (whiskeringLeft C‚ÇÅ D‚ÇÅ _).obj F‚ÇÅ\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÉObjObjMap_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\nD‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_5} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_6} D‚ÇÉ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_14, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nF‚ÇÉ F‚ÇÉ' : CategoryTheory.Functor C‚ÇÉ D‚ÇÉ\nœÑ‚ÇÉ : Quiver.Hom F‚ÇÉ F‚ÇÉ'\nF : CategoryTheory.Functor D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ (CategoryTheory.Functor D‚ÇÉ E))\n‚ä¢ Eq ((CategoryTheory.whiskeringLeft‚ÇÉObjObjMap E F‚ÇÅ F‚ÇÇ œÑ‚ÇÉ).app F) (CategoryTheory.whiskerLeft F‚ÇÅ (CategoryTheory.whiskerLeft F (((CategoryTheory.whiskeringLeft‚ÇÇ E).obj F‚ÇÇ).map œÑ‚ÇÉ)))","decl":"/-- Auxiliary definition for `whiskeringLeft‚ÇÉ`. -/\n@[simps]\ndef whiskeringLeft‚ÇÉObjObjMap (F‚ÇÅ : C‚ÇÅ ‚•§ D‚ÇÅ) (F‚ÇÇ : C‚ÇÇ ‚•§ D‚ÇÇ) {F‚ÇÉ F‚ÇÉ' : C‚ÇÉ ‚•§ D‚ÇÉ} (œÑ‚ÇÉ : F‚ÇÉ ‚ü∂ F‚ÇÉ') :\n    whiskeringLeft‚ÇÉObjObjObj E F‚ÇÅ F‚ÇÇ F‚ÇÉ ‚ü∂\n      whiskeringLeft‚ÇÉObjObjObj E F‚ÇÅ F‚ÇÇ F‚ÇÉ' where\n  app F := whiskerLeft _ (whiskerLeft _ (((whiskeringLeft‚ÇÇ E).obj F‚ÇÇ).map œÑ‚ÇÉ))\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÉObjObj_map","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\nD‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_5} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_6} D‚ÇÉ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_14, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nX‚úù Y‚úù : CategoryTheory.Functor C‚ÇÉ D‚ÇÉ\nœÑ‚ÇÉ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.whiskeringLeft‚ÇÉObjObj C‚ÇÉ D‚ÇÉ E F‚ÇÅ F‚ÇÇ).map œÑ‚ÇÉ) (CategoryTheory.whiskeringLeft‚ÇÉObjObjMap E F‚ÇÅ F‚ÇÇ œÑ‚ÇÉ)","decl":"variable (C‚ÇÉ D‚ÇÉ) in\n/-- Auxiliary definition for `whiskeringLeft‚ÇÉ`. -/\n@[simps]\ndef whiskeringLeft‚ÇÉObjObj (F‚ÇÅ : C‚ÇÅ ‚•§ D‚ÇÅ) (F‚ÇÇ : C‚ÇÇ ‚•§ D‚ÇÇ) :\n    (C‚ÇÉ ‚•§ D‚ÇÉ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ D‚ÇÉ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) where\n  obj F‚ÇÉ := whiskeringLeft‚ÇÉObjObjObj E F‚ÇÅ F‚ÇÇ F‚ÇÉ\n  map œÑ‚ÇÉ := whiskeringLeft‚ÇÉObjObjMap E F‚ÇÅ F‚ÇÇ œÑ‚ÇÉ\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÉObjObj_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\nD‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_5} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_6} D‚ÇÉ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_14, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nF‚ÇÉ : CategoryTheory.Functor C‚ÇÉ D‚ÇÉ\n‚ä¢ Eq ((CategoryTheory.whiskeringLeft‚ÇÉObjObj C‚ÇÉ D‚ÇÉ E F‚ÇÅ F‚ÇÇ).obj F‚ÇÉ) (CategoryTheory.whiskeringLeft‚ÇÉObjObjObj E F‚ÇÅ F‚ÇÇ F‚ÇÉ)","decl":"variable (C‚ÇÉ D‚ÇÉ) in\n/-- Auxiliary definition for `whiskeringLeft‚ÇÉ`. -/\n@[simps]\ndef whiskeringLeft‚ÇÉObjObj (F‚ÇÅ : C‚ÇÅ ‚•§ D‚ÇÅ) (F‚ÇÇ : C‚ÇÇ ‚•§ D‚ÇÇ) :\n    (C‚ÇÉ ‚•§ D‚ÇÉ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ D‚ÇÉ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) where\n  obj F‚ÇÉ := whiskeringLeft‚ÇÉObjObjObj E F‚ÇÅ F‚ÇÇ F‚ÇÉ\n  map œÑ‚ÇÉ := whiskeringLeft‚ÇÉObjObjMap E F‚ÇÅ F‚ÇÇ œÑ‚ÇÉ\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÉObjMap_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\nD‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_5} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_6} D‚ÇÉ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_14, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ F‚ÇÇ' : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nœÑ‚ÇÇ : Quiver.Hom F‚ÇÇ F‚ÇÇ'\nF‚ÇÉ : CategoryTheory.Functor C‚ÇÉ D‚ÇÉ\n‚ä¢ Eq ((CategoryTheory.whiskeringLeft‚ÇÉObjMap C‚ÇÉ D‚ÇÉ E F‚ÇÅ œÑ‚ÇÇ).app F‚ÇÉ) (CategoryTheory.whiskerRight ((CategoryTheory.whiskeringRight D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ (CategoryTheory.Functor D‚ÇÉ E)) (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ E))).map (((CategoryTheory.whiskeringLeft‚ÇÇ E).map œÑ‚ÇÇ).app F‚ÇÉ)) ((CategoryTheory.whiskeringLeft C‚ÇÅ D‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ E))).obj F‚ÇÅ))","decl":"variable (C‚ÇÉ D‚ÇÉ) in\n/-- Auxiliary definition for `whiskeringLeft‚ÇÉ`. -/\n@[simps]\ndef whiskeringLeft‚ÇÉObjMap (F‚ÇÅ : C‚ÇÅ ‚•§ D‚ÇÅ) {F‚ÇÇ F‚ÇÇ' : C‚ÇÇ ‚•§ D‚ÇÇ} (œÑ‚ÇÇ : F‚ÇÇ ‚ü∂ F‚ÇÇ') :\n    whiskeringLeft‚ÇÉObjObj C‚ÇÉ D‚ÇÉ E F‚ÇÅ F‚ÇÇ ‚ü∂ whiskeringLeft‚ÇÉObjObj C‚ÇÉ D‚ÇÉ E F‚ÇÅ F‚ÇÇ' where\n  app F‚ÇÉ := whiskerRight ((whiskeringRight _ _ _).map (((whiskeringLeft‚ÇÇ E).map œÑ‚ÇÇ).app F‚ÇÉ)) _\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÉObj_map","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\nD‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_5} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_6} D‚ÇÉ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_14, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nX‚úù Y‚úù : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nœÑ‚ÇÇ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.whiskeringLeft‚ÇÉObj C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ E F‚ÇÅ).map œÑ‚ÇÇ) (CategoryTheory.whiskeringLeft‚ÇÉObjMap C‚ÇÉ D‚ÇÉ E F‚ÇÅ œÑ‚ÇÇ)","decl":"variable (C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ) in\n/-- Auxiliary definition for `whiskeringLeft‚ÇÉ`. -/\n@[simps]\ndef whiskeringLeft‚ÇÉObj (F‚ÇÅ : C‚ÇÅ ‚•§ D‚ÇÅ) :\n    (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (C‚ÇÉ ‚•§ D‚ÇÉ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ D‚ÇÉ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) where\n  obj F‚ÇÇ := whiskeringLeft‚ÇÉObjObj C‚ÇÉ D‚ÇÉ E F‚ÇÅ F‚ÇÇ\n  map œÑ‚ÇÇ := whiskeringLeft‚ÇÉObjMap C‚ÇÉ D‚ÇÉ E F‚ÇÅ œÑ‚ÇÇ\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÉObj_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\nD‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_5} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_6} D‚ÇÉ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_14, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\n‚ä¢ Eq ((CategoryTheory.whiskeringLeft‚ÇÉObj C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ E F‚ÇÅ).obj F‚ÇÇ) (CategoryTheory.whiskeringLeft‚ÇÉObjObj C‚ÇÉ D‚ÇÉ E F‚ÇÅ F‚ÇÇ)","decl":"variable (C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ) in\n/-- Auxiliary definition for `whiskeringLeft‚ÇÉ`. -/\n@[simps]\ndef whiskeringLeft‚ÇÉObj (F‚ÇÅ : C‚ÇÅ ‚•§ D‚ÇÅ) :\n    (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (C‚ÇÉ ‚•§ D‚ÇÉ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ D‚ÇÉ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) where\n  obj F‚ÇÇ := whiskeringLeft‚ÇÉObjObj C‚ÇÉ D‚ÇÉ E F‚ÇÅ F‚ÇÇ\n  map œÑ‚ÇÇ := whiskeringLeft‚ÇÉObjMap C‚ÇÉ D‚ÇÉ E F‚ÇÅ œÑ‚ÇÇ\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÉMap_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\nD‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_5} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_6} D‚ÇÉ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_14, u_7} E\nF‚ÇÅ F‚ÇÅ' : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nœÑ‚ÇÅ : Quiver.Hom F‚ÇÅ F‚ÇÅ'\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nF‚ÇÉ : CategoryTheory.Functor C‚ÇÉ D‚ÇÉ\n‚ä¢ Eq (((CategoryTheory.whiskeringLeft‚ÇÉMap C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ E œÑ‚ÇÅ).app F‚ÇÇ).app F‚ÇÉ) (CategoryTheory.whiskerLeft ((CategoryTheory.whiskeringRight D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ (CategoryTheory.Functor D‚ÇÉ E)) (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ E))).obj (((CategoryTheory.whiskeringLeft‚ÇÇ E).obj F‚ÇÇ).obj F‚ÇÉ)) ((CategoryTheory.whiskeringLeft C‚ÇÅ D‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ E))).map œÑ‚ÇÅ))","decl":"variable (C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ) in\n/-- Auxiliary definition for `whiskeringLeft‚ÇÉ`. -/\n@[simps]\ndef whiskeringLeft‚ÇÉMap {F‚ÇÅ F‚ÇÅ' : C‚ÇÅ ‚•§ D‚ÇÅ} (œÑ‚ÇÅ : F‚ÇÅ ‚ü∂ F‚ÇÅ') :\n    whiskeringLeft‚ÇÉObj C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ E F‚ÇÅ ‚ü∂ whiskeringLeft‚ÇÉObj C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ E F‚ÇÅ' where\n  app F‚ÇÇ := { app F‚ÇÉ := whiskerLeft _ ((whiskeringLeft _ _ _).map œÑ‚ÇÅ) }\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÉ_obj_obj_obj_obj_obj_obj_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\nD‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_5} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_6} D‚ÇÉ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_14, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nF‚ÇÉ : CategoryTheory.Functor C‚ÇÉ D‚ÇÉ\nX‚úù¬≤ : CategoryTheory.Functor D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ (CategoryTheory.Functor D‚ÇÉ E))\nX‚úù¬π : C‚ÇÅ\nX‚úù : C‚ÇÇ\nX : C‚ÇÉ\n‚ä¢ Eq ((((((((CategoryTheory.whiskeringLeft‚ÇÉ E).obj F‚ÇÅ).obj F‚ÇÇ).obj F‚ÇÉ).obj X‚úù¬≤).obj X‚úù¬π).obj X‚úù).obj X) (((X‚úù¬≤.obj (F‚ÇÅ.obj X‚úù¬π)).obj (F‚ÇÇ.obj X‚úù)).obj (F‚ÇÉ.obj X))","decl":"/-- The obvious functor `(C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E)`. -/\n@[simps!]\ndef whiskeringLeft‚ÇÉ :\n    (C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (C‚ÇÉ ‚•§ D‚ÇÉ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ D‚ÇÉ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) where\n  obj F‚ÇÅ := whiskeringLeft‚ÇÉObj C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ E F‚ÇÅ\n  map œÑ‚ÇÅ := whiskeringLeft‚ÇÉMap C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ E œÑ‚ÇÅ\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÉ_map_app_app_app_app_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\nD‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_5} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_6} D‚ÇÉ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_14, u_7} E\nX‚úù¬≤ Y‚úù : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nœÑ‚ÇÅ : Quiver.Hom X‚úù¬≤ Y‚úù\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nF‚ÇÉ : CategoryTheory.Functor C‚ÇÉ D‚ÇÉ\nX‚úù¬π : CategoryTheory.Functor D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ (CategoryTheory.Functor D‚ÇÉ E))\nc : C‚ÇÅ\nX‚úù : C‚ÇÇ\nX : C‚ÇÉ\n‚ä¢ Eq ((((((((CategoryTheory.whiskeringLeft‚ÇÉ E).map œÑ‚ÇÅ).app F‚ÇÇ).app F‚ÇÉ).app X‚úù¬π).app c).app X‚úù).app X) (((X‚úù¬π.map (œÑ‚ÇÅ.app c)).app (F‚ÇÇ.obj X‚úù)).app (F‚ÇÉ.obj X))","decl":"/-- The obvious functor `(C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E)`. -/\n@[simps!]\ndef whiskeringLeft‚ÇÉ :\n    (C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (C‚ÇÉ ‚•§ D‚ÇÉ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ D‚ÇÉ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) where\n  obj F‚ÇÅ := whiskeringLeft‚ÇÉObj C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ E F‚ÇÅ\n  map œÑ‚ÇÅ := whiskeringLeft‚ÇÉMap C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ E œÑ‚ÇÅ\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÉ_obj_map_app_app_app_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\nD‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_5} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_6} D‚ÇÉ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_14, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nX‚úù¬≤ Y‚úù : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nœÑ‚ÇÇ : Quiver.Hom X‚úù¬≤ Y‚úù\nF‚ÇÉ : CategoryTheory.Functor C‚ÇÉ D‚ÇÉ\nX‚úù¬π : CategoryTheory.Functor D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ (CategoryTheory.Functor D‚ÇÉ E))\nX‚úù : C‚ÇÅ\nc : C‚ÇÇ\nX : C‚ÇÉ\n‚ä¢ Eq ((((((((CategoryTheory.whiskeringLeft‚ÇÉ E).obj F‚ÇÅ).map œÑ‚ÇÇ).app F‚ÇÉ).app X‚úù¬π).app X‚úù).app c).app X) (((X‚úù¬π.obj (F‚ÇÅ.obj X‚úù)).map (œÑ‚ÇÇ.app c)).app (F‚ÇÉ.obj X))","decl":"/-- The obvious functor `(C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E)`. -/\n@[simps!]\ndef whiskeringLeft‚ÇÉ :\n    (C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (C‚ÇÉ ‚•§ D‚ÇÉ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ D‚ÇÉ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) where\n  obj F‚ÇÅ := whiskeringLeft‚ÇÉObj C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ E F‚ÇÅ\n  map œÑ‚ÇÅ := whiskeringLeft‚ÇÉMap C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ E œÑ‚ÇÅ\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÉ_obj_obj_obj_map_app_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\nD‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_5} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_6} D‚ÇÉ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_14, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nF‚ÇÉ : CategoryTheory.Functor C‚ÇÉ D‚ÇÉ\nX‚úù¬≤ Y‚úù : CategoryTheory.Functor D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ (CategoryTheory.Functor D‚ÇÉ E))\nf : Quiver.Hom X‚úù¬≤ Y‚úù\nX‚úù¬π : C‚ÇÅ\nX‚úù : C‚ÇÇ\nX : C‚ÇÉ\n‚ä¢ Eq ((((((((CategoryTheory.whiskeringLeft‚ÇÉ E).obj F‚ÇÅ).obj F‚ÇÇ).obj F‚ÇÉ).map f).app X‚úù¬π).app X‚úù).app X) (((f.app (F‚ÇÅ.obj X‚úù¬π)).app (F‚ÇÇ.obj X‚úù)).app (F‚ÇÉ.obj X))","decl":"/-- The obvious functor `(C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E)`. -/\n@[simps!]\ndef whiskeringLeft‚ÇÉ :\n    (C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (C‚ÇÉ ‚•§ D‚ÇÉ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ D‚ÇÉ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) where\n  obj F‚ÇÅ := whiskeringLeft‚ÇÉObj C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ E F‚ÇÅ\n  map œÑ‚ÇÅ := whiskeringLeft‚ÇÉMap C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ E œÑ‚ÇÅ\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÉ_obj_obj_map_app_app_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\nD‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_5} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_6} D‚ÇÉ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_14, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nX‚úù¬π Y‚úù : CategoryTheory.Functor C‚ÇÉ D‚ÇÉ\nœÑ‚ÇÉ : Quiver.Hom X‚úù¬π Y‚úù\nF : CategoryTheory.Functor D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ (CategoryTheory.Functor D‚ÇÉ E))\nX‚úù : C‚ÇÅ\nX : C‚ÇÇ\nc : C‚ÇÉ\n‚ä¢ Eq ((((((((CategoryTheory.whiskeringLeft‚ÇÉ E).obj F‚ÇÅ).obj F‚ÇÇ).map œÑ‚ÇÉ).app F).app X‚úù).app X).app c) (((F.obj (F‚ÇÅ.obj X‚úù)).obj (F‚ÇÇ.obj X)).map (œÑ‚ÇÉ.app c))","decl":"/-- The obvious functor `(C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E)`. -/\n@[simps!]\ndef whiskeringLeft‚ÇÉ :\n    (C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (C‚ÇÉ ‚•§ D‚ÇÉ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ D‚ÇÉ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) where\n  obj F‚ÇÅ := whiskeringLeft‚ÇÉObj C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ E F‚ÇÅ\n  map œÑ‚ÇÅ := whiskeringLeft‚ÇÉMap C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ E œÑ‚ÇÅ\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÉ_obj_obj_obj_obj_obj_map_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\nD‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_5} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_6} D‚ÇÉ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_14, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nF‚ÇÉ : CategoryTheory.Functor C‚ÇÉ D‚ÇÉ\nX‚úù¬≤ : CategoryTheory.Functor D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ (CategoryTheory.Functor D‚ÇÉ E))\nX‚úù¬π : C‚ÇÅ\nX‚úù Y‚úù : C‚ÇÇ\nf : Quiver.Hom X‚úù Y‚úù\nX : C‚ÇÉ\n‚ä¢ Eq ((((((((CategoryTheory.whiskeringLeft‚ÇÉ E).obj F‚ÇÅ).obj F‚ÇÇ).obj F‚ÇÉ).obj X‚úù¬≤).obj X‚úù¬π).map f).app X) (((X‚úù¬≤.obj (F‚ÇÅ.obj X‚úù¬π)).map (F‚ÇÇ.map f)).app (F‚ÇÉ.obj X))","decl":"/-- The obvious functor `(C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E)`. -/\n@[simps!]\ndef whiskeringLeft‚ÇÉ :\n    (C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (C‚ÇÉ ‚•§ D‚ÇÉ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ D‚ÇÉ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) where\n  obj F‚ÇÅ := whiskeringLeft‚ÇÉObj C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ E F‚ÇÅ\n  map œÑ‚ÇÅ := whiskeringLeft‚ÇÉMap C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ E œÑ‚ÇÅ\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÉ_obj_obj_obj_obj_map_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\nD‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_5} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_6} D‚ÇÉ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_14, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nF‚ÇÉ : CategoryTheory.Functor C‚ÇÉ D‚ÇÉ\nX‚úù¬≤ : CategoryTheory.Functor D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ (CategoryTheory.Functor D‚ÇÉ E))\nX‚úù¬π Y‚úù : C‚ÇÅ\nf : Quiver.Hom X‚úù¬π Y‚úù\nX‚úù : C‚ÇÇ\nX : C‚ÇÉ\n‚ä¢ Eq ((((((((CategoryTheory.whiskeringLeft‚ÇÉ E).obj F‚ÇÅ).obj F‚ÇÇ).obj F‚ÇÉ).obj X‚úù¬≤).map f).app X‚úù).app X) (((X‚úù¬≤.map (F‚ÇÅ.map f)).app (F‚ÇÇ.obj X‚úù)).app (F‚ÇÉ.obj X))","decl":"/-- The obvious functor `(C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E)`. -/\n@[simps!]\ndef whiskeringLeft‚ÇÉ :\n    (C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (C‚ÇÉ ‚•§ D‚ÇÉ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ D‚ÇÉ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) where\n  obj F‚ÇÅ := whiskeringLeft‚ÇÉObj C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ E F‚ÇÅ\n  map œÑ‚ÇÅ := whiskeringLeft‚ÇÉMap C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ E œÑ‚ÇÅ\n\n"}
{"name":"CategoryTheory.whiskeringLeft‚ÇÉ_obj_obj_obj_obj_obj_obj_map","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\nD‚ÇÅ : Type u_4\nD‚ÇÇ : Type u_5\nD‚ÇÉ : Type u_6\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_8, u_1} C‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{u_9, u_2} C‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_10, u_3} C‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{u_11, u_4} D‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_12, u_5} D‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{u_13, u_6} D‚ÇÉ\nE : Type u_7\ninst‚úù : CategoryTheory.Category.{u_14, u_7} E\nF‚ÇÅ : CategoryTheory.Functor C‚ÇÅ D‚ÇÅ\nF‚ÇÇ : CategoryTheory.Functor C‚ÇÇ D‚ÇÇ\nF‚ÇÉ : CategoryTheory.Functor C‚ÇÉ D‚ÇÉ\nX‚úù¬≤ : CategoryTheory.Functor D‚ÇÅ (CategoryTheory.Functor D‚ÇÇ (CategoryTheory.Functor D‚ÇÉ E))\nX‚úù¬π : C‚ÇÅ\nX : C‚ÇÇ\nX‚úù Y‚úù : C‚ÇÉ\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((((((((CategoryTheory.whiskeringLeft‚ÇÉ E).obj F‚ÇÅ).obj F‚ÇÇ).obj F‚ÇÉ).obj X‚úù¬≤).obj X‚úù¬π).obj X).map f) (((X‚úù¬≤.obj (F‚ÇÅ.obj X‚úù¬π)).obj (F‚ÇÇ.obj X)).map (F‚ÇÉ.map f))","decl":"/-- The obvious functor `(C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E)`. -/\n@[simps!]\ndef whiskeringLeft‚ÇÉ :\n    (C‚ÇÅ ‚•§ D‚ÇÅ) ‚•§ (C‚ÇÇ ‚•§ D‚ÇÇ) ‚•§ (C‚ÇÉ ‚•§ D‚ÇÉ) ‚•§ (D‚ÇÅ ‚•§ D‚ÇÇ ‚•§ D‚ÇÉ ‚•§ E) ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) where\n  obj F‚ÇÅ := whiskeringLeft‚ÇÉObj C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ E F‚ÇÅ\n  map œÑ‚ÇÅ := whiskeringLeft‚ÇÉMap C‚ÇÇ C‚ÇÉ D‚ÇÇ D‚ÇÉ E œÑ‚ÇÅ\n\n"}
{"name":"CategoryTheory.Functor.postcompose‚ÇÇ_obj_obj_obj_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_9, u_1} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_10, u_2} C‚ÇÇ\nE : Type u_7\ninst‚úù¬π : CategoryTheory.Category.{u_11, u_7} E\nE' : Type u_8\ninst‚úù : CategoryTheory.Category.{u_12, u_8} E'\nX‚úù¬π : CategoryTheory.Functor E E'\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ E)\nX‚úù : C‚ÇÅ\nX : C‚ÇÇ\n‚ä¢ Eq ((((CategoryTheory.Functor.postcompose‚ÇÇ.obj X‚úù¬π).obj F).obj X‚úù).obj X) (X‚úù¬π.obj ((F.obj X‚úù).obj X))","decl":"/-- The \"postcomposition\" with a functor `E ‚•§ E'` gives a functor\n`(E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E'`. -/\n@[simps!]\ndef Functor.postcompose‚ÇÇ {E' : Type*} [Category E'] :\n    (E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E' :=\n  whiskeringRight C‚ÇÇ _ _ ‚ãô whiskeringRight C‚ÇÅ _ _\n\n"}
{"name":"CategoryTheory.Functor.postcompose‚ÇÇ_map_app_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_9, u_1} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_10, u_2} C‚ÇÇ\nE : Type u_7\ninst‚úù¬π : CategoryTheory.Category.{u_11, u_7} E\nE' : Type u_8\ninst‚úù : CategoryTheory.Category.{u_12, u_8} E'\nX‚úù Y‚úù : CategoryTheory.Functor E E'\nf : Quiver.Hom X‚úù Y‚úù\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ E)\nc‚úù : C‚ÇÅ\nc : C‚ÇÇ\n‚ä¢ Eq ((((CategoryTheory.Functor.postcompose‚ÇÇ.map f).app F).app c‚úù).app c) (f.app ((F.obj c‚úù).obj c))","decl":"/-- The \"postcomposition\" with a functor `E ‚•§ E'` gives a functor\n`(E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E'`. -/\n@[simps!]\ndef Functor.postcompose‚ÇÇ {E' : Type*} [Category E'] :\n    (E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E' :=\n  whiskeringRight C‚ÇÇ _ _ ‚ãô whiskeringRight C‚ÇÅ _ _\n\n"}
{"name":"CategoryTheory.Functor.postcompose‚ÇÇ_obj_map_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_9, u_1} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_10, u_2} C‚ÇÇ\nE : Type u_7\ninst‚úù¬π : CategoryTheory.Category.{u_11, u_7} E\nE' : Type u_8\ninst‚úù : CategoryTheory.Category.{u_12, u_8} E'\nX‚úù¬≤ : CategoryTheory.Functor E E'\nX‚úù¬π Y‚úù : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ E)\nŒ± : Quiver.Hom X‚úù¬π Y‚úù\nX‚úù : C‚ÇÅ\nX : C‚ÇÇ\n‚ä¢ Eq ((((CategoryTheory.Functor.postcompose‚ÇÇ.obj X‚úù¬≤).map Œ±).app X‚úù).app X) (X‚úù¬≤.map ((Œ±.app X‚úù).app X))","decl":"/-- The \"postcomposition\" with a functor `E ‚•§ E'` gives a functor\n`(E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E'`. -/\n@[simps!]\ndef Functor.postcompose‚ÇÇ {E' : Type*} [Category E'] :\n    (E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E' :=\n  whiskeringRight C‚ÇÇ _ _ ‚ãô whiskeringRight C‚ÇÅ _ _\n\n"}
{"name":"CategoryTheory.Functor.postcompose‚ÇÇ_obj_obj_map_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_9, u_1} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_10, u_2} C‚ÇÇ\nE : Type u_7\ninst‚úù¬π : CategoryTheory.Category.{u_11, u_7} E\nE' : Type u_8\ninst‚úù : CategoryTheory.Category.{u_12, u_8} E'\nX‚úù¬π : CategoryTheory.Functor E E'\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ E)\nX‚úù Y‚úù : C‚ÇÅ\nf : Quiver.Hom X‚úù Y‚úù\nX : C‚ÇÇ\n‚ä¢ Eq ((((CategoryTheory.Functor.postcompose‚ÇÇ.obj X‚úù¬π).obj F).map f).app X) (X‚úù¬π.map ((F.map f).app X))","decl":"/-- The \"postcomposition\" with a functor `E ‚•§ E'` gives a functor\n`(E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E'`. -/\n@[simps!]\ndef Functor.postcompose‚ÇÇ {E' : Type*} [Category E'] :\n    (E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E' :=\n  whiskeringRight C‚ÇÇ _ _ ‚ãô whiskeringRight C‚ÇÅ _ _\n\n"}
{"name":"CategoryTheory.Functor.postcompose‚ÇÇ_obj_obj_obj_map","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_9, u_1} C‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{u_10, u_2} C‚ÇÇ\nE : Type u_7\ninst‚úù¬π : CategoryTheory.Category.{u_11, u_7} E\nE' : Type u_8\ninst‚úù : CategoryTheory.Category.{u_12, u_8} E'\nX‚úù¬π : CategoryTheory.Functor E E'\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ E)\nX : C‚ÇÅ\nX‚úù Y‚úù : C‚ÇÇ\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((((CategoryTheory.Functor.postcompose‚ÇÇ.obj X‚úù¬π).obj F).obj X).map f) (X‚úù¬π.map ((F.obj X).map f))","decl":"/-- The \"postcomposition\" with a functor `E ‚•§ E'` gives a functor\n`(E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E'`. -/\n@[simps!]\ndef Functor.postcompose‚ÇÇ {E' : Type*} [Category E'] :\n    (E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ E' :=\n  whiskeringRight C‚ÇÇ _ _ ‚ãô whiskeringRight C‚ÇÅ _ _\n\n"}
{"name":"CategoryTheory.Functor.postcompose‚ÇÉ_obj_obj_map_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_9, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_10, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_11, u_3} C‚ÇÉ\nE : Type u_7\ninst‚úù¬π : CategoryTheory.Category.{u_12, u_7} E\nE' : Type u_8\ninst‚úù : CategoryTheory.Category.{u_13, u_8} E'\nX‚úù¬≤ : CategoryTheory.Functor E E'\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ E))\nX‚úù¬π Y‚úù : C‚ÇÅ\nf : Quiver.Hom X‚úù¬π Y‚úù\nX‚úù : C‚ÇÇ\nX : C‚ÇÉ\n‚ä¢ Eq (((((CategoryTheory.Functor.postcompose‚ÇÉ.obj X‚úù¬≤).obj F).map f).app X‚úù).app X) (X‚úù¬≤.map (((F.map f).app X‚úù).app X))","decl":"/-- The \"postcomposition\" with a functor `E ‚•§ E'` gives a functor\n`(E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E'`. -/\n@[simps!]\ndef Functor.postcompose‚ÇÉ {E' : Type*} [Category E'] :\n    (E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E' :=\n  whiskeringRight C‚ÇÉ _ _ ‚ãô whiskeringRight C‚ÇÇ _ _ ‚ãô whiskeringRight C‚ÇÅ _ _\n\n"}
{"name":"CategoryTheory.Functor.postcompose‚ÇÉ_obj_obj_obj_map_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_9, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_10, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_11, u_3} C‚ÇÉ\nE : Type u_7\ninst‚úù¬π : CategoryTheory.Category.{u_12, u_7} E\nE' : Type u_8\ninst‚úù : CategoryTheory.Category.{u_13, u_8} E'\nX‚úù¬≤ : CategoryTheory.Functor E E'\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ E))\nX‚úù¬π : C‚ÇÅ\nX‚úù Y‚úù : C‚ÇÇ\nf : Quiver.Hom X‚úù Y‚úù\nX : C‚ÇÉ\n‚ä¢ Eq (((((CategoryTheory.Functor.postcompose‚ÇÉ.obj X‚úù¬≤).obj F).obj X‚úù¬π).map f).app X) (X‚úù¬≤.map (((F.obj X‚úù¬π).map f).app X))","decl":"/-- The \"postcomposition\" with a functor `E ‚•§ E'` gives a functor\n`(E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E'`. -/\n@[simps!]\ndef Functor.postcompose‚ÇÉ {E' : Type*} [Category E'] :\n    (E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E' :=\n  whiskeringRight C‚ÇÉ _ _ ‚ãô whiskeringRight C‚ÇÇ _ _ ‚ãô whiskeringRight C‚ÇÅ _ _\n\n"}
{"name":"CategoryTheory.Functor.postcompose‚ÇÉ_obj_map_app_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_9, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_10, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_11, u_3} C‚ÇÉ\nE : Type u_7\ninst‚úù¬π : CategoryTheory.Category.{u_12, u_7} E\nE' : Type u_8\ninst‚úù : CategoryTheory.Category.{u_13, u_8} E'\nX‚úù¬≥ : CategoryTheory.Functor E E'\nX‚úù¬≤ Y‚úù : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ E))\nŒ± : Quiver.Hom X‚úù¬≤ Y‚úù\nX‚úù¬π : C‚ÇÅ\nX‚úù : C‚ÇÇ\nX : C‚ÇÉ\n‚ä¢ Eq (((((CategoryTheory.Functor.postcompose‚ÇÉ.obj X‚úù¬≥).map Œ±).app X‚úù¬π).app X‚úù).app X) (X‚úù¬≥.map (((Œ±.app X‚úù¬π).app X‚úù).app X))","decl":"/-- The \"postcomposition\" with a functor `E ‚•§ E'` gives a functor\n`(E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E'`. -/\n@[simps!]\ndef Functor.postcompose‚ÇÉ {E' : Type*} [Category E'] :\n    (E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E' :=\n  whiskeringRight C‚ÇÉ _ _ ‚ãô whiskeringRight C‚ÇÇ _ _ ‚ãô whiskeringRight C‚ÇÅ _ _\n\n"}
{"name":"CategoryTheory.Functor.postcompose‚ÇÉ_obj_obj_obj_obj_map","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_9, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_10, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_11, u_3} C‚ÇÉ\nE : Type u_7\ninst‚úù¬π : CategoryTheory.Category.{u_12, u_7} E\nE' : Type u_8\ninst‚úù : CategoryTheory.Category.{u_13, u_8} E'\nX‚úù¬≤ : CategoryTheory.Functor E E'\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ E))\nX‚úù¬π : C‚ÇÅ\nX : C‚ÇÇ\nX‚úù Y‚úù : C‚ÇÉ\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((((CategoryTheory.Functor.postcompose‚ÇÉ.obj X‚úù¬≤).obj F).obj X‚úù¬π).obj X).map f) (X‚úù¬≤.map (((F.obj X‚úù¬π).obj X).map f))","decl":"/-- The \"postcomposition\" with a functor `E ‚•§ E'` gives a functor\n`(E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E'`. -/\n@[simps!]\ndef Functor.postcompose‚ÇÉ {E' : Type*} [Category E'] :\n    (E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E' :=\n  whiskeringRight C‚ÇÉ _ _ ‚ãô whiskeringRight C‚ÇÇ _ _ ‚ãô whiskeringRight C‚ÇÅ _ _\n\n"}
{"name":"CategoryTheory.Functor.postcompose‚ÇÉ_map_app_app_app_app","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_9, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_10, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_11, u_3} C‚ÇÉ\nE : Type u_7\ninst‚úù¬π : CategoryTheory.Category.{u_12, u_7} E\nE' : Type u_8\ninst‚úù : CategoryTheory.Category.{u_13, u_8} E'\nX‚úù Y‚úù : CategoryTheory.Functor E E'\nf : Quiver.Hom X‚úù Y‚úù\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ E))\nc‚úù¬π : C‚ÇÅ\nc‚úù : C‚ÇÇ\nc : C‚ÇÉ\n‚ä¢ Eq (((((CategoryTheory.Functor.postcompose‚ÇÉ.map f).app F).app c‚úù¬π).app c‚úù).app c) (f.app (((F.obj c‚úù¬π).obj c‚úù).obj c))","decl":"/-- The \"postcomposition\" with a functor `E ‚•§ E'` gives a functor\n`(E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E'`. -/\n@[simps!]\ndef Functor.postcompose‚ÇÉ {E' : Type*} [Category E'] :\n    (E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E' :=\n  whiskeringRight C‚ÇÉ _ _ ‚ãô whiskeringRight C‚ÇÇ _ _ ‚ãô whiskeringRight C‚ÇÅ _ _\n\n"}
{"name":"CategoryTheory.Functor.postcompose‚ÇÉ_obj_obj_obj_obj_obj","module":"Mathlib.CategoryTheory.Whiskering","initialProofState":"C‚ÇÅ : Type u_1\nC‚ÇÇ : Type u_2\nC‚ÇÉ : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_9, u_1} C‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{u_10, u_2} C‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u_11, u_3} C‚ÇÉ\nE : Type u_7\ninst‚úù¬π : CategoryTheory.Category.{u_12, u_7} E\nE' : Type u_8\ninst‚úù : CategoryTheory.Category.{u_13, u_8} E'\nX‚úù¬≤ : CategoryTheory.Functor E E'\nF : CategoryTheory.Functor C‚ÇÅ (CategoryTheory.Functor C‚ÇÇ (CategoryTheory.Functor C‚ÇÉ E))\nX‚úù¬π : C‚ÇÅ\nX‚úù : C‚ÇÇ\nX : C‚ÇÉ\n‚ä¢ Eq (((((CategoryTheory.Functor.postcompose‚ÇÉ.obj X‚úù¬≤).obj F).obj X‚úù¬π).obj X‚úù).obj X) (X‚úù¬≤.obj (((F.obj X‚úù¬π).obj X‚úù).obj X))","decl":"/-- The \"postcomposition\" with a functor `E ‚•§ E'` gives a functor\n`(E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E'`. -/\n@[simps!]\ndef Functor.postcompose‚ÇÉ {E' : Type*} [Category E'] :\n    (E ‚•§ E') ‚•§ (C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E) ‚•§ C‚ÇÅ ‚•§ C‚ÇÇ ‚•§ C‚ÇÉ ‚•§ E' :=\n  whiskeringRight C‚ÇÉ _ _ ‚ãô whiskeringRight C‚ÇÇ _ _ ‚ãô whiskeringRight C‚ÇÅ _ _\n\n"}
