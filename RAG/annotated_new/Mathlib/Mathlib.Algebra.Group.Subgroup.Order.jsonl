{"name":"abs_mem_iff","module":"Mathlib.Algebra.Group.Subgroup.Order","initialProofState":"S : Type u_1\nG : Type u_2\ninst✝² : AddGroup G\ninst✝¹ : LinearOrder G\nx✝ : SetLike S G\ninst✝ : NegMemClass S G\nH : S\nx : G\n⊢ Iff (Membership.mem H (abs x)) (Membership.mem H x)","decl":"@[to_additive (attr := simp)]\ntheorem mabs_mem_iff {S G} [Group G] [LinearOrder G] {_ : SetLike S G}\n    [InvMemClass S G] {H : S} {x : G} : |x|ₘ ∈ H ↔ x ∈ H := by\n  cases mabs_choice x <;> simp [*]\n\n"}
{"name":"mabs_mem_iff","module":"Mathlib.Algebra.Group.Subgroup.Order","initialProofState":"S : Type u_1\nG : Type u_2\ninst✝² : Group G\ninst✝¹ : LinearOrder G\nx✝ : SetLike S G\ninst✝ : InvMemClass S G\nH : S\nx : G\n⊢ Iff (Membership.mem H (mabs x)) (Membership.mem H x)","decl":"@[to_additive (attr := simp)]\ntheorem mabs_mem_iff {S G} [Group G] [LinearOrder G] {_ : SetLike S G}\n    [InvMemClass S G] {H : S} {x : G} : |x|ₘ ∈ H ↔ x ∈ H := by\n  cases mabs_choice x <;> simp [*]\n\n"}
{"name":"instIsModularLatticeSubgroup","module":"Mathlib.Algebra.Group.Subgroup.Order","initialProofState":"C : Type u_1\ninst✝ : CommGroup C\n⊢ IsModularLattice (Subgroup C)","decl":"@[to_additive]\ninstance : IsModularLattice (Subgroup C) :=\n  ⟨fun {x} y z xz a ha => by\n    rw [mem_inf, mem_sup] at ha\n    rcases ha with ⟨⟨b, hb, c, hc, rfl⟩, haz⟩\n    rw [mem_sup]\n    exact ⟨b, hb, c, mem_inf.2 ⟨hc, (mul_mem_cancel_left (xz hb)).1 haz⟩, rfl⟩⟩\n\n"}
{"name":"instIsModularLatticeAddSubgroup","module":"Mathlib.Algebra.Group.Subgroup.Order","initialProofState":"C : Type u_1\ninst✝ : AddCommGroup C\n⊢ IsModularLattice (AddSubgroup C)","decl":"@[to_additive]\ninstance : IsModularLattice (Subgroup C) :=\n  ⟨fun {x} y z xz a ha => by\n    rw [mem_inf, mem_sup] at ha\n    rcases ha with ⟨⟨b, hb, c, hc, rfl⟩, haz⟩\n    rw [mem_sup]\n    exact ⟨b, hb, c, mem_inf.2 ⟨hc, (mul_mem_cancel_left (xz hb)).1 haz⟩, rfl⟩⟩\n\n"}
{"name":"Subgroup.NormalizerCondition.normal_of_coatom","module":"Mathlib.Algebra.Group.Subgroup.Order","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nhnc : NormalizerCondition G\nhmax : IsCoatom H\n⊢ H.Normal","decl":"/-- In a group that satisfies the normalizer condition, every maximal subgroup is normal -/\ntheorem NormalizerCondition.normal_of_coatom (hnc : NormalizerCondition G) (hmax : IsCoatom H) :\n    H.Normal :=\n  normalizer_eq_top_iff.mp (hmax.2 _ (hnc H (lt_top_iff_ne_top.mpr hmax.1)))\n\n"}
{"name":"Subgroup.isCoatom_comap","module":"Mathlib.Algebra.Group.Subgroup.Order","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Type u_2\ninst✝ : Group H\nf : MulEquiv G H\nK : Subgroup H\n⊢ Iff (IsCoatom (Subgroup.comap (↑f) K)) (IsCoatom K)","decl":"@[simp]\ntheorem isCoatom_comap {H : Type*} [Group H] (f : G ≃* H) {K : Subgroup H} :\n    IsCoatom (Subgroup.comap (f : G →* H) K) ↔ IsCoatom K :=\n  OrderIso.isCoatom_iff (f.comapSubgroup) K\n\n"}
{"name":"Subgroup.isCoatom_map","module":"Mathlib.Algebra.Group.Subgroup.Order","initialProofState":"G : Type u_1\ninst✝ : Group G\nH : Subgroup G\nf : MulEquiv G (Subtype fun x => Membership.mem H x)\nK : Subgroup G\n⊢ Iff (IsCoatom (Subgroup.map (↑f) K)) (IsCoatom K)","decl":"@[simp]\ntheorem isCoatom_map (f : G ≃* H) {K : Subgroup G} :\n    IsCoatom (Subgroup.map (f : G →* H) K) ↔ IsCoatom K :=\n  OrderIso.isCoatom_iff (f.mapSubgroup) K\n\n"}
{"name":"Subgroup.isCoatom_comap_of_surjective","module":"Mathlib.Algebra.Group.Subgroup.Order","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nH : Type u_2\ninst✝ : Group H\nφ : MonoidHom G H\nhφ : Function.Surjective ⇑φ\nM : Subgroup H\nhM : IsCoatom M\n⊢ IsCoatom (Subgroup.comap φ M)","decl":"lemma isCoatom_comap_of_surjective\n    {H : Type*} [Group H] {φ : G →* H} (hφ : Function.Surjective φ)\n    {M : Subgroup H} (hM : IsCoatom M) : IsCoatom (M.comap φ) := by\n  refine And.imp (fun hM ↦ ?_) (fun hM ↦ ?_) hM\n  · rwa [← (comap_injective hφ).ne_iff, comap_top] at hM\n  · intro K hK\n    specialize hM (K.map φ)\n    rw [← comap_lt_comap_of_surjective hφ, ← (comap_injective hφ).eq_iff] at hM\n    rw [comap_map_eq_self ((M.ker_le_comap φ).trans hK.le), comap_top] at hM\n    exact hM hK\n\n"}
{"name":"AddSubsemigroup.strictMono_topEquiv","module":"Mathlib.Algebra.Group.Subgroup.Order","initialProofState":"G : Type u_1\ninst✝ : OrderedAddCommMonoid G\n⊢ StrictMono ⇑AddSubsemigroup.topEquiv","decl":"@[to_additive]\nlemma Subsemigroup.strictMono_topEquiv {G : Type*} [OrderedCommMonoid G] :\n    StrictMono (topEquiv (M := G)) := fun _ _ ↦ id\n\n"}
{"name":"Subsemigroup.strictMono_topEquiv","module":"Mathlib.Algebra.Group.Subgroup.Order","initialProofState":"G : Type u_1\ninst✝ : OrderedCommMonoid G\n⊢ StrictMono ⇑Subsemigroup.topEquiv","decl":"@[to_additive]\nlemma Subsemigroup.strictMono_topEquiv {G : Type*} [OrderedCommMonoid G] :\n    StrictMono (topEquiv (M := G)) := fun _ _ ↦ id\n\n"}
{"name":"AddEquiv.strictMono_subsemigroupCongr","module":"Mathlib.Algebra.Group.Subgroup.Order","initialProofState":"G : Type u_1\ninst✝ : OrderedAddCommMonoid G\nS T : AddSubsemigroup G\nh : Eq S T\n⊢ StrictMono ⇑(AddEquiv.subsemigroupCongr h)","decl":"@[to_additive]\nlemma MulEquiv.strictMono_subsemigroupCongr {G : Type*} [OrderedCommMonoid G] {S T : Subsemigroup G}\n    (h : S = T) : StrictMono (subsemigroupCongr h) := fun _ _ ↦ id\n\n"}
{"name":"MulEquiv.strictMono_subsemigroupCongr","module":"Mathlib.Algebra.Group.Subgroup.Order","initialProofState":"G : Type u_1\ninst✝ : OrderedCommMonoid G\nS T : Subsemigroup G\nh : Eq S T\n⊢ StrictMono ⇑(MulEquiv.subsemigroupCongr h)","decl":"@[to_additive]\nlemma MulEquiv.strictMono_subsemigroupCongr {G : Type*} [OrderedCommMonoid G] {S T : Subsemigroup G}\n    (h : S = T) : StrictMono (subsemigroupCongr h) := fun _ _ ↦ id\n\n"}
{"name":"MulEquiv.strictMono_symm","module":"Mathlib.Algebra.Group.Subgroup.Order","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : LinearOrderedCommMonoid G\ninst✝ : LinearOrderedCommMonoid G'\ne : MulEquiv G G'\nhe : StrictMono ⇑e\n⊢ StrictMono ⇑e.symm","decl":"@[to_additive]\nlemma MulEquiv.strictMono_symm {G G' : Type*} [LinearOrderedCommMonoid G]\n    [LinearOrderedCommMonoid G'] {e : G ≃* G'} (he : StrictMono e) : StrictMono e.symm := by\n  intro\n  simp [← he.lt_iff_lt]\n"}
{"name":"AddEquiv.strictMono_symm","module":"Mathlib.Algebra.Group.Subgroup.Order","initialProofState":"G : Type u_1\nG' : Type u_2\ninst✝¹ : LinearOrderedAddCommMonoid G\ninst✝ : LinearOrderedAddCommMonoid G'\ne : AddEquiv G G'\nhe : StrictMono ⇑e\n⊢ StrictMono ⇑e.symm","decl":"@[to_additive]\nlemma MulEquiv.strictMono_symm {G G' : Type*} [LinearOrderedCommMonoid G]\n    [LinearOrderedCommMonoid G'] {e : G ≃* G'} (he : StrictMono e) : StrictMono e.symm := by\n  intro\n  simp [← he.lt_iff_lt]\n"}
