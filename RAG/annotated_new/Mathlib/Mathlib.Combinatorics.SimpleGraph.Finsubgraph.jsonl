{"name":"SimpleGraph.Finsubgraph.coe_bot","module":"Mathlib.Combinatorics.SimpleGraph.Finsubgraph","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Eq (↑Bot.bot) Bot.bot","decl":"@[simp, norm_cast] lemma coe_bot : (⊥ : G.Finsubgraph) = (⊥ : G.Subgraph) := rfl\n\n"}
{"name":"SimpleGraph.Finsubgraph.coe_sup","module":"Mathlib.Combinatorics.SimpleGraph.Finsubgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG₁ G₂ : G.Finsubgraph\n⊢ Eq (↑(Max.max G₁ G₂)) (Max.max ↑G₁ ↑G₂)","decl":"@[simp, norm_cast]\nlemma coe_sup (G₁ G₂ : G.Finsubgraph) : ↑(G₁ ⊔ G₂) = (G₁ ⊔ G₂ : G.Subgraph) := rfl\n\n"}
{"name":"SimpleGraph.Finsubgraph.coe_inf","module":"Mathlib.Combinatorics.SimpleGraph.Finsubgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG₁ G₂ : G.Finsubgraph\n⊢ Eq (↑(Min.min G₁ G₂)) (Min.min ↑G₁ ↑G₂)","decl":"@[simp, norm_cast]\nlemma coe_inf (G₁ G₂ : G.Finsubgraph) : ↑(G₁ ⊓ G₂) = (G₁ ⊓ G₂ : G.Subgraph) := rfl\n\n"}
{"name":"SimpleGraph.Finsubgraph.coe_sdiff","module":"Mathlib.Combinatorics.SimpleGraph.Finsubgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nG₁ G₂ : G.Finsubgraph\n⊢ Eq (↑(SDiff.sdiff G₁ G₂)) (SDiff.sdiff ↑G₁ ↑G₂)","decl":"@[simp, norm_cast]\nlemma coe_sdiff (G₁ G₂ : G.Finsubgraph) : ↑(G₁ \\ G₂) = (G₁ \\ G₂ : G.Subgraph) := rfl\n\n"}
{"name":"SimpleGraph.Finsubgraph.coe_top","module":"Mathlib.Combinatorics.SimpleGraph.Finsubgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : Finite V\n⊢ Eq (↑Top.top) Top.top","decl":"@[simp, norm_cast] lemma coe_top : (⊤ : G.Finsubgraph) = (⊤ : G.Subgraph) := rfl\n"}
{"name":"SimpleGraph.Finsubgraph.coe_compl","module":"Mathlib.Combinatorics.SimpleGraph.Finsubgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : Finite V\nG' : G.Finsubgraph\n⊢ Eq (↑(HasCompl.compl G')) (HasCompl.compl ↑G')","decl":"@[simp, norm_cast] lemma coe_compl (G' : G.Finsubgraph) : ↑(G'ᶜ) = (G'ᶜ : G.Subgraph) := rfl\n"}
{"name":"SimpleGraph.Finsubgraph.coe_hnot","module":"Mathlib.Combinatorics.SimpleGraph.Finsubgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : Finite V\nG' : G.Finsubgraph\n⊢ Eq (↑(HNot.hnot G')) (HNot.hnot ↑G')","decl":"@[simp, norm_cast] lemma coe_hnot (G' : G.Finsubgraph) : ↑(￢G') = (￢G' : G.Subgraph) := rfl\n\n"}
{"name":"SimpleGraph.Finsubgraph.coe_himp","module":"Mathlib.Combinatorics.SimpleGraph.Finsubgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : Finite V\nG₁ G₂ : G.Finsubgraph\n⊢ Eq (↑(HImp.himp G₁ G₂)) (HImp.himp ↑G₁ ↑G₂)","decl":"@[simp, norm_cast]\nlemma coe_himp (G₁ G₂ : G.Finsubgraph) : ↑(G₁ ⇨ G₂) = (G₁ ⇨ G₂ : G.Subgraph) := rfl\n\n"}
{"name":"SimpleGraph.Finsubgraph.coe_sSup","module":"Mathlib.Combinatorics.SimpleGraph.Finsubgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : Finite V\ns : Set G.Finsubgraph\n⊢ Eq (↑(SupSet.sSup s)) (iSup fun G_1 => iSup fun h => ↑G_1)","decl":"@[simp, norm_cast]\nlemma coe_sSup (s : Set G.Finsubgraph) : sSup s = (⨆ G ∈ s, G : G.Subgraph) := rfl\n\n"}
{"name":"SimpleGraph.Finsubgraph.coe_sInf","module":"Mathlib.Combinatorics.SimpleGraph.Finsubgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : Finite V\ns : Set G.Finsubgraph\n⊢ Eq (↑(InfSet.sInf s)) (iInf fun G_1 => iInf fun h => ↑G_1)","decl":"@[simp, norm_cast]\nlemma coe_sInf (s : Set G.Finsubgraph) : sInf s = (⨅ G ∈ s, G : G.Subgraph) := rfl\n\n"}
{"name":"SimpleGraph.Finsubgraph.coe_iSup","module":"Mathlib.Combinatorics.SimpleGraph.Finsubgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : Finite V\nι : Sort u_1\nf : ι → G.Finsubgraph\n⊢ Eq (↑(iSup fun i => f i)) (iSup fun i => ↑(f i))","decl":"@[simp, norm_cast]\nlemma coe_iSup {ι : Sort*} (f : ι → G.Finsubgraph) : ⨆ i, f i = (⨆ i, f i : G.Subgraph) := by\n  rw [iSup, coe_sSup, iSup_range]\n\n"}
{"name":"SimpleGraph.Finsubgraph.coe_iInf","module":"Mathlib.Combinatorics.SimpleGraph.Finsubgraph","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : Finite V\nι : Sort u_1\nf : ι → G.Finsubgraph\n⊢ Eq (↑(iInf fun i => f i)) (iInf fun i => ↑(f i))","decl":"@[simp, norm_cast]\nlemma coe_iInf {ι : Sort*} (f : ι → G.Finsubgraph) : ⨅ i, f i = (⨅ i, f i : G.Subgraph) := by\n  rw [iInf, coe_sInf, iInf_range]\n\n"}
{"name":"SimpleGraph.singletonFinsubgraph_le_adj_left","module":"Mathlib.Combinatorics.SimpleGraph.Finsubgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\ne : G.Adj u v\n⊢ LE.le (SimpleGraph.singletonFinsubgraph u) (SimpleGraph.finsubgraphOfAdj e)","decl":"theorem singletonFinsubgraph_le_adj_left {u v : V} {e : G.Adj u v} :\n    singletonFinsubgraph u ≤ finsubgraphOfAdj e := by\n  simp [singletonFinsubgraph, finsubgraphOfAdj]\n\n"}
{"name":"SimpleGraph.singletonFinsubgraph_le_adj_right","module":"Mathlib.Combinatorics.SimpleGraph.Finsubgraph","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\ne : G.Adj u v\n⊢ LE.le (SimpleGraph.singletonFinsubgraph v) (SimpleGraph.finsubgraphOfAdj e)","decl":"theorem singletonFinsubgraph_le_adj_right {u v : V} {e : G.Adj u v} :\n    singletonFinsubgraph v ≤ finsubgraphOfAdj e := by\n  simp [singletonFinsubgraph, finsubgraphOfAdj]\n\n"}
{"name":"SimpleGraph.nonempty_hom_of_forall_finite_subgraph_hom","module":"Mathlib.Combinatorics.SimpleGraph.Finsubgraph","initialProofState":"V : Type u\nW : Type v\nG : SimpleGraph V\nF : SimpleGraph W\ninst✝ : Finite W\nh : (G' : G.Subgraph) → G'.verts.Finite → G'.coe.Hom F\n⊢ Nonempty (G.Hom F)","decl":"/-- If every finite subgraph of a graph `G` has a homomorphism to a finite graph `F`, then there is\na homomorphism from the whole of `G` to `F`. -/\ntheorem nonempty_hom_of_forall_finite_subgraph_hom [Finite W]\n    (h : ∀ G' : G.Subgraph, G'.verts.Finite → G'.coe →g F) : Nonempty (G →g F) := by\n  -- Obtain a `Fintype` instance for `W`.\n  cases nonempty_fintype W\n  -- Establish the required interface instances.\n  haveI : ∀ G' : G.Finsubgraphᵒᵖ, Nonempty ((finsubgraphHomFunctor G F).obj G') := fun G' =>\n    ⟨h G'.unop G'.unop.property⟩\n  haveI : ∀ G' : G.Finsubgraphᵒᵖ, Fintype ((finsubgraphHomFunctor G F).obj G') := by\n    intro G'\n    haveI : Fintype (G'.unop.val.verts : Type u) := G'.unop.property.fintype\n    haveI : Fintype (↥G'.unop.val.verts → W) := by classical exact Pi.instFintype\n    exact Fintype.ofInjective (fun f => f.toFun) RelHom.coe_fn_injective\n  -- Use compactness to obtain a section.\n  obtain ⟨u, hu⟩ := nonempty_sections_of_finite_inverse_system (finsubgraphHomFunctor G F)\n  refine ⟨⟨fun v => ?_, ?_⟩⟩\n  · -- Map each vertex using the homomorphism provided for its singleton subgraph.\n    exact\n      (u (Opposite.op (singletonFinsubgraph v))).toFun\n        ⟨v, by\n          unfold singletonFinsubgraph\n          simp⟩\n  · -- Prove that the above mapping preserves adjacency.\n    intro v v' e\n    simp only\n    /- The homomorphism for each edge's singleton subgraph agrees with those for its source and\n        target vertices. -/\n    have hv : Opposite.op (finsubgraphOfAdj e) ⟶ Opposite.op (singletonFinsubgraph v) :=\n      Quiver.Hom.op (CategoryTheory.homOfLE singletonFinsubgraph_le_adj_left)\n    have hv' : Opposite.op (finsubgraphOfAdj e) ⟶ Opposite.op (singletonFinsubgraph v') :=\n      Quiver.Hom.op (CategoryTheory.homOfLE singletonFinsubgraph_le_adj_right)\n    rw [← hu hv, ← hu hv']\n    -- Porting note: was `apply Hom.map_adj`\n    refine Hom.map_adj (u (Opposite.op (finsubgraphOfAdj e))) ?_\n    -- `v` and `v'` are definitionally adjacent in `finsubgraphOfAdj e`\n    simp [finsubgraphOfAdj]\n\n"}
