{"name":"IsLocalRing.map_mkQ_eq","module":"Mathlib.RingTheory.LocalRing.Module","initialProofState":"R : Type u_1\ninstâœÂ³ : CommRing R\nM : Type u_2\ninstâœÂ² : AddCommGroup M\ninstâœÂ¹ : Module R M\ninstâœ : IsLocalRing R\nNâ‚ Nâ‚‚ : Submodule R M\nh : LE.le Nâ‚ Nâ‚‚\nh' : Nâ‚‚.FG\nâŠ¢ Iff (Eq (Submodule.map (HSMul.hSMul (IsLocalRing.maximalIdeal R) Nâ‚‚).mkQ Nâ‚) (Submodule.map (HSMul.hSMul (IsLocalRing.maximalIdeal R) Nâ‚‚).mkQ Nâ‚‚)) (Eq Nâ‚ Nâ‚‚)","decl":"theorem map_mkQ_eq {Nâ‚ Nâ‚‚ : Submodule R M} (h : Nâ‚ â‰¤ Nâ‚‚) (h' : Nâ‚‚.FG) :\n    Nâ‚.map (Submodule.mkQ (ğ”ª â€¢ Nâ‚‚)) = Nâ‚‚.map (Submodule.mkQ (ğ”ª â€¢ Nâ‚‚)) â†” Nâ‚ = Nâ‚‚ := by\n  constructor\n  Â· intro hN\n    have : Nâ‚‚ â‰¤ ğ”ª â€¢ Nâ‚‚ âŠ” Nâ‚ := by\n      simpa using Submodule.comap_mono (f := Submodule.mkQ (ğ”ª â€¢ Nâ‚‚)) hN.ge\n    rw [sup_comm] at this\n    exact h.antisymm (Submodule.le_of_le_smul_of_le_jacobson_bot h'\n      (by rw [jacobson_eq_maximalIdeal]; exact bot_ne_top) this)\n  Â· rintro rfl; simp\n\n"}
{"name":"IsLocalRing.map_mkQ_eq_top","module":"Mathlib.RingTheory.LocalRing.Module","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : IsLocalRing R\nN : Submodule R M\ninstâœ : Module.Finite R M\nâŠ¢ Iff (Eq (Submodule.map (HSMul.hSMul (IsLocalRing.maximalIdeal R) Top.top).mkQ N) Top.top) (Eq N Top.top)","decl":"theorem map_mkQ_eq_top {N : Submodule R M} [Module.Finite R M] :\n    N.map (Submodule.mkQ (ğ”ª â€¢ âŠ¤)) = âŠ¤ â†” N = âŠ¤ := by\n  rw [â† map_mkQ_eq (Nâ‚ := N) le_top Module.Finite.fg_top, Submodule.map_top, Submodule.range_mkQ]\n\n"}
{"name":"IsLocalRing.map_tensorProduct_mk_eq_top","module":"Mathlib.RingTheory.LocalRing.Module","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : IsLocalRing R\nN : Submodule R M\ninstâœ : Module.Finite R M\nâŠ¢ Iff (Eq (Submodule.map ((TensorProduct.mk R (IsLocalRing.ResidueField R) M) 1) N) Top.top) (Eq N Top.top)","decl":"theorem map_tensorProduct_mk_eq_top {N : Submodule R M} [Module.Finite R M] :\n    N.map (TensorProduct.mk R k M 1) = âŠ¤ â†” N = âŠ¤ := by\n  constructor\n  Â· intro hN\n    letI : Module k (M â§¸ (ğ”ª â€¢ âŠ¤ : Submodule R M)) :=\n      inferInstanceAs (Module (R â§¸ ğ”ª) (M â§¸ ğ”ª â€¢ (âŠ¤ : Submodule R M)))\n    letI : IsScalarTower R k (M â§¸ (ğ”ª â€¢ âŠ¤ : Submodule R M)) :=\n      inferInstanceAs (IsScalarTower R (R â§¸ ğ”ª) (M â§¸ ğ”ª â€¢ (âŠ¤ : Submodule R M)))\n    let f := AlgebraTensorModule.lift (((LinearMap.ringLmapEquivSelf k k _).symm\n      (Submodule.mkQ (ğ”ª â€¢ âŠ¤ : Submodule R M))).restrictScalars R)\n    have : f.comp (TensorProduct.mk R k M 1) = Submodule.mkQ (ğ”ª â€¢ âŠ¤) := by ext; simp [f]\n    have hf : Function.Surjective f := by\n      intro x; obtain âŸ¨x, rflâŸ© := Submodule.mkQ_surjective _ x\n      rw [â† this, LinearMap.comp_apply]; exact âŸ¨_, rflâŸ©\n    apply_fun Submodule.map f at hN\n    rwa [â† Submodule.map_comp, this, Submodule.map_top, LinearMap.range_eq_top.2 hf,\n      map_mkQ_eq_top] at hN\n  Â· rintro rfl; rw [Submodule.map_top, LinearMap.range_eq_top]\n    exact TensorProduct.mk_surjective R M k Ideal.Quotient.mk_surjective\n\n"}
{"name":"IsLocalRing.subsingleton_tensorProduct","module":"Mathlib.RingTheory.LocalRing.Module","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : IsLocalRing R\ninstâœ : Module.Finite R M\nâŠ¢ Iff (Subsingleton (TensorProduct R (IsLocalRing.ResidueField R) M)) (Subsingleton M)","decl":"theorem subsingleton_tensorProduct [Module.Finite R M] :\n    Subsingleton (k âŠ—[R] M) â†” Subsingleton M := by\n  rw [â† Submodule.subsingleton_iff R, â† subsingleton_iff_bot_eq_top,\n    â† Submodule.subsingleton_iff R, â† subsingleton_iff_bot_eq_top,\n    â† map_tensorProduct_mk_eq_top (M := M), Submodule.map_bot]\n\n"}
{"name":"IsLocalRing.span_eq_top_of_tmul_eq_basis","module":"Mathlib.RingTheory.LocalRing.Module","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : IsLocalRing R\ninstâœ : Module.Finite R M\nÎ¹ : Type u_3\nf : Î¹ â†’ M\nb : Basis Î¹ (IsLocalRing.ResidueField R) (TensorProduct R (IsLocalRing.ResidueField R) M)\nhb : âˆ€ (i : Î¹), Eq (TensorProduct.tmul R 1 (f i)) (b i)\nâŠ¢ Eq (Submodule.span R (Set.range f)) Top.top","decl":"theorem span_eq_top_of_tmul_eq_basis [Module.Finite R M] {Î¹}\n    (f : Î¹ â†’ M) (b : Basis Î¹ k (k âŠ—[R] M))\n    (hb : âˆ€ i, 1 âŠ—â‚œ f i = b i) : Submodule.span R (Set.range f) = âŠ¤ := by\n  rw [â† map_tensorProduct_mk_eq_top, Submodule.map_span, â† Submodule.restrictScalars_span R k\n    Ideal.Quotient.mk_surjective, Submodule.restrictScalars_eq_top_iff,\n    â† b.span_eq, â† Set.range_comp]\n  simp only [Function.comp_def, mk_apply, hb, Basis.span_eq]\n\n"}
{"name":"LocalRing.map_mkQ_eq","module":"Mathlib.RingTheory.LocalRing.Module","initialProofState":"R : Type u_1\ninstâœÂ³ : CommRing R\nM : Type u_2\ninstâœÂ² : AddCommGroup M\ninstâœÂ¹ : Module R M\ninstâœ : IsLocalRing R\nNâ‚ Nâ‚‚ : Submodule R M\nh : LE.le Nâ‚ Nâ‚‚\nh' : Nâ‚‚.FG\nâŠ¢ Iff (Eq (Submodule.map (HSMul.hSMul (IsLocalRing.maximalIdeal R) Nâ‚‚).mkQ Nâ‚) (Submodule.map (HSMul.hSMul (IsLocalRing.maximalIdeal R) Nâ‚‚).mkQ Nâ‚‚)) (Eq Nâ‚ Nâ‚‚)","decl":"@[deprecated (since := \"2024-11-11\")]\nalias LocalRing.map_mkQ_eq := IsLocalRing.map_mkQ_eq\n\n"}
{"name":"LocalRing.map_mkQ_eq_top","module":"Mathlib.RingTheory.LocalRing.Module","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : IsLocalRing R\nN : Submodule R M\ninstâœ : Module.Finite R M\nâŠ¢ Iff (Eq (Submodule.map (HSMul.hSMul (IsLocalRing.maximalIdeal R) Top.top).mkQ N) Top.top) (Eq N Top.top)","decl":"@[deprecated (since := \"2024-11-11\")]\nalias LocalRing.map_mkQ_eq_top := IsLocalRing.map_mkQ_eq_top\n\n"}
{"name":"LocalRing.map_tensorProduct_mk_eq_top","module":"Mathlib.RingTheory.LocalRing.Module","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : IsLocalRing R\nN : Submodule R M\ninstâœ : Module.Finite R M\nâŠ¢ Iff (Eq (Submodule.map ((TensorProduct.mk R (IsLocalRing.ResidueField R) M) 1) N) Top.top) (Eq N Top.top)","decl":"@[deprecated (since := \"2024-11-11\")]\nalias LocalRing.map_tensorProduct_mk_eq_top := IsLocalRing.map_tensorProduct_mk_eq_top\n\n"}
{"name":"LocalRing.subsingleton_tensorProduct","module":"Mathlib.RingTheory.LocalRing.Module","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : IsLocalRing R\ninstâœ : Module.Finite R M\nâŠ¢ Iff (Subsingleton (TensorProduct R (IsLocalRing.ResidueField R) M)) (Subsingleton M)","decl":"@[deprecated (since := \"2024-11-11\")]\nalias LocalRing.subsingleton_tensorProduct := IsLocalRing.subsingleton_tensorProduct\n\n"}
{"name":"LocalRing.span_eq_top_of_tmul_eq_basis","module":"Mathlib.RingTheory.LocalRing.Module","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : IsLocalRing R\ninstâœ : Module.Finite R M\nÎ¹ : Type u_3\nf : Î¹ â†’ M\nb : Basis Î¹ (IsLocalRing.ResidueField R) (TensorProduct R (IsLocalRing.ResidueField R) M)\nhb : âˆ€ (i : Î¹), Eq (TensorProduct.tmul R 1 (f i)) (b i)\nâŠ¢ Eq (Submodule.span R (Set.range f)) Top.top","decl":"@[deprecated (since := \"2024-11-11\")]\nalias LocalRing.span_eq_top_of_tmul_eq_basis := IsLocalRing.span_eq_top_of_tmul_eq_basis\n\n"}
{"name":"lTensor_injective_of_exact_of_exact_of_rTensor_injective","module":"Mathlib.RingTheory.LocalRing.Module","initialProofState":"R : Type u_7\ninstâœÂ¹Â² : CommRing R\nMâ‚ : Type u_1\nMâ‚‚ : Type u_2\nMâ‚ƒ : Type u_3\nNâ‚ : Type u_4\nNâ‚‚ : Type u_5\nNâ‚ƒ : Type u_6\ninstâœÂ¹Â¹ : AddCommGroup Mâ‚\ninstâœÂ¹â° : Module R Mâ‚\ninstâœâ¹ : AddCommGroup Mâ‚‚\ninstâœâ¸ : Module R Mâ‚‚\ninstâœâ· : AddCommGroup Mâ‚ƒ\ninstâœâ¶ : Module R Mâ‚ƒ\ninstâœâµ : AddCommGroup Nâ‚\ninstâœâ´ : Module R Nâ‚\ninstâœÂ³ : AddCommGroup Nâ‚‚\ninstâœÂ² : Module R Nâ‚‚\ninstâœÂ¹ : AddCommGroup Nâ‚ƒ\ninstâœ : Module R Nâ‚ƒ\nfâ‚ : LinearMap (RingHom.id R) Mâ‚ Mâ‚‚\nfâ‚‚ : LinearMap (RingHom.id R) Mâ‚‚ Mâ‚ƒ\ngâ‚ : LinearMap (RingHom.id R) Nâ‚ Nâ‚‚\ngâ‚‚ : LinearMap (RingHom.id R) Nâ‚‚ Nâ‚ƒ\nhfexact : Function.Exact â‡‘fâ‚ â‡‘fâ‚‚\nhfsurj : Function.Surjective â‡‘fâ‚‚\nhgexact : Function.Exact â‡‘gâ‚ â‡‘gâ‚‚\nhgsurj : Function.Surjective â‡‘gâ‚‚\nhfinj : Function.Injective â‡‘(LinearMap.rTensor Nâ‚ƒ fâ‚)\nhginj : Function.Injective â‡‘(LinearMap.lTensor Mâ‚‚ gâ‚)\nâŠ¢ Function.Injective â‡‘(LinearMap.lTensor Mâ‚ƒ gâ‚)","decl":"open Function in\n/--\nGiven `Mâ‚ â†’ Mâ‚‚ â†’ Mâ‚ƒ â†’ 0` and `Nâ‚ â†’ Nâ‚‚ â†’ Nâ‚ƒ â†’ 0`,\nif `Mâ‚ âŠ— Nâ‚ƒ â†’ Mâ‚‚ âŠ— Nâ‚ƒ` and `Mâ‚‚ âŠ— Nâ‚ â†’ Mâ‚‚ âŠ— Nâ‚‚` are both injective,\nthen `Mâ‚ƒ âŠ— Nâ‚ â†’ Mâ‚ƒ âŠ— Nâ‚‚` is also injective.\n-/\ntheorem lTensor_injective_of_exact_of_exact_of_rTensor_injective\n    {Mâ‚ Mâ‚‚ Mâ‚ƒ Nâ‚ Nâ‚‚ Nâ‚ƒ}\n    [AddCommGroup Mâ‚] [Module R Mâ‚] [AddCommGroup Mâ‚‚] [Module R Mâ‚‚] [AddCommGroup Mâ‚ƒ] [Module R Mâ‚ƒ]\n    [AddCommGroup Nâ‚] [Module R Nâ‚] [AddCommGroup Nâ‚‚] [Module R Nâ‚‚] [AddCommGroup Nâ‚ƒ] [Module R Nâ‚ƒ]\n    {fâ‚ : Mâ‚ â†’â‚—[R] Mâ‚‚} {fâ‚‚ : Mâ‚‚ â†’â‚—[R] Mâ‚ƒ} {gâ‚ : Nâ‚ â†’â‚—[R] Nâ‚‚} {gâ‚‚ : Nâ‚‚ â†’â‚—[R] Nâ‚ƒ}\n    (hfexact : Exact fâ‚ fâ‚‚) (hfsurj : Surjective fâ‚‚)\n    (hgexact : Exact gâ‚ gâ‚‚) (hgsurj : Surjective gâ‚‚)\n    (hfinj : Injective (fâ‚.rTensor Nâ‚ƒ)) (hginj : Injective (gâ‚.lTensor Mâ‚‚)) :\n    Injective (gâ‚.lTensor Mâ‚ƒ) := by\n  rw [injective_iff_map_eq_zero]\n  intro x hx\n  obtain âŸ¨x, rflâŸ© := fâ‚‚.rTensor_surjective Nâ‚ hfsurj x\n  have : fâ‚‚.rTensor Nâ‚‚ (gâ‚.lTensor Mâ‚‚ x) = 0 := by\n    rw [â† hx, â† LinearMap.comp_apply, â† LinearMap.comp_apply, LinearMap.rTensor_comp_lTensor,\n      LinearMap.lTensor_comp_rTensor]\n  obtain âŸ¨y, hyâŸ© := (rTensor_exact Nâ‚‚ hfexact hfsurj _).mp this\n  have : gâ‚‚.lTensor Mâ‚ y = 0 := by\n    apply hfinj\n    trans gâ‚‚.lTensor Mâ‚‚ (gâ‚.lTensor Mâ‚‚ x)\n    Â· rw [â† hy, â† LinearMap.comp_apply, â† LinearMap.comp_apply, LinearMap.rTensor_comp_lTensor,\n        LinearMap.lTensor_comp_rTensor]\n    rw [â† LinearMap.comp_apply, â† LinearMap.lTensor_comp, hgexact.linearMap_comp_eq_zero]\n    simp\n  obtain âŸ¨z, rflâŸ© := (lTensor_exact _ hgexact hgsurj _).mp this\n  obtain rfl : fâ‚.rTensor Nâ‚ z = x := by\n    apply hginj\n    simp only [â† hy, â† LinearMap.comp_apply, â† LinearMap.comp_apply, LinearMap.lTensor_comp_rTensor,\n      LinearMap.rTensor_comp_lTensor]\n  rw [â† LinearMap.comp_apply, â† LinearMap.rTensor_comp, hfexact.linearMap_comp_eq_zero]\n  simp\n\n"}
{"name":"Module.exists_basis_of_basis_baseChange","module":"Mathlib.RingTheory.LocalRing.Module","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : IsLocalRing R\ninstâœ : Module.FinitePresentation R M\nÎ¹ : Type u\nv : Î¹ â†’ M\nhli : LinearIndependent (IsLocalRing.ResidueField R) (Function.comp (â‡‘((TensorProduct.mk R (IsLocalRing.ResidueField R) M) 1)) v)\nhsp : Eq (Submodule.span (IsLocalRing.ResidueField R) (Set.range (Function.comp (â‡‘((TensorProduct.mk R (IsLocalRing.ResidueField R) M) 1)) v))) Top.top\nH : Function.Injective â‡‘(LinearMap.rTensor M (Submodule.subtype (IsLocalRing.maximalIdeal R)))\nâŠ¢ Exists fun b => âˆ€ (i : Î¹), Eq (b i) (v i)","decl":"/-- If `M` is of finite presentation over a local ring `(R, ğ”ª, k)` such that\n`ğ”ª âŠ— M â†’ M` is injective, then every family of elements that is a `k`-basis of\n`k âŠ— M` is an `R`-basis of `M`. -/\nlemma exists_basis_of_basis_baseChange [Module.FinitePresentation R M]\n    {Î¹ : Type u} (v : Î¹ â†’ M) (hli : LinearIndependent k (TensorProduct.mk R k M 1 âˆ˜ v))\n    (hsp : Submodule.span k (Set.range (TensorProduct.mk R k M 1 âˆ˜ v)) = âŠ¤)\n    (H : Function.Injective ((ğ”ª).subtype.rTensor M)) :\n    âˆƒ (b : Basis Î¹ R M), âˆ€ i, b i = v i := by\n  let bk : Basis Î¹ k (k âŠ—[R] M) := Basis.mk hli (by rw [hsp])\n  haveI : Finite Î¹ := Module.Finite.finite_basis bk\n  letI : Fintype Î¹ := Fintype.ofFinite Î¹\n  letI : IsNoetherian k (k âŠ—[R] (Î¹ â†’â‚€ R)) :=\n    isNoetherian_of_isNoetherianRing_of_finite k (k âŠ—[R] (Î¹ â†’â‚€ R))\n  let i := Finsupp.linearCombination R v\n  have hi : Surjective i := by\n    rw [â† LinearMap.range_eq_top, Finsupp.range_linearCombination]\n    refine IsLocalRing.span_eq_top_of_tmul_eq_basis (R := R) (f := v) bk\n      (fun _ â†¦ by simp [bk])\n  have : Module.Finite R (LinearMap.ker i) := by\n    constructor\n    exact (Submodule.fg_top _).mpr (Module.FinitePresentation.fg_ker i hi)\n  -- We claim that `i` is actually a bijection,\n  -- hence `v` induces an isomorphism `M â‰ƒ[R] Rá´µ` showing that `v` is a basis.\n  let iequiv : (Î¹ â†’â‚€ R) â‰ƒâ‚—[R] M := by\n    refine LinearEquiv.ofBijective i âŸ¨?_, hiâŸ©\n    -- By Nakayama's lemma, it suffices to show that `k âŠ— ker(i) = 0`.\n    rw [â† LinearMap.ker_eq_bot, â† Submodule.subsingleton_iff_eq_bot,\n      â† IsLocalRing.subsingleton_tensorProduct (R := R), subsingleton_iff_forall_eq 0]\n    have : Function.Surjective (i.baseChange k) := i.lTensor_surjective _ hi\n    -- By construction, `k âŠ— i : ká´µ â†’ k âŠ— M` is bijective.\n    have hi' : Function.Bijective (i.baseChange k) := by\n      refine âŸ¨?_, thisâŸ©\n      rw [â† LinearMap.ker_eq_bot (M := k âŠ—[R] (Î¹ â†’â‚€ R)) (f := i.baseChange k),\n        â† Submodule.finrank_eq_zero (R := k) (M := k âŠ—[R] (Î¹ â†’â‚€ R)),\n        â† Nat.add_right_inj (n := Module.finrank k (LinearMap.range <| i.baseChange k)),\n        LinearMap.finrank_range_add_finrank_ker (V := k âŠ—[R] (Î¹ â†’â‚€ R)),\n        LinearMap.range_eq_top.mpr this, finrank_top]\n      simp only [Module.finrank_tensorProduct, Module.finrank_self,\n        Module.finrank_finsupp_self, one_mul, add_zero]\n      rw [Module.finrank_eq_card_basis bk]\n    -- On the other hand, `m âŠ— M â†’ M` injective => `Torâ‚(k, M) = 0` => `k âŠ— ker(i) â†’ ká´µ` injective.\n    intro x\n    refine lTensor_injective_of_exact_of_exact_of_rTensor_injective\n      (Nâ‚ := LinearMap.ker i) (Nâ‚‚ := Î¹ â†’â‚€ R) (Nâ‚ƒ := M)\n      (fâ‚ := (ğ”ª).subtype) (fâ‚‚ := Submodule.mkQ ğ”ª)\n      (gâ‚ := (LinearMap.ker i).subtype) (gâ‚‚ := i) (LinearMap.exact_subtype_mkQ ğ”ª)\n      (Submodule.mkQ_surjective _) (LinearMap.exact_subtype_ker_map i) hi H ?_ ?_\n    Â· apply Module.Flat.lTensor_preserves_injective_linearMap\n      exact Subtype.val_injective\n    Â· apply hi'.injective\n      rw [LinearMap.baseChange_eq_ltensor]\n      erw [â† LinearMap.comp_apply (i.lTensor k), â† LinearMap.lTensor_comp]\n      rw [(LinearMap.exact_subtype_ker_map i).linearMap_comp_eq_zero]\n      simp only [LinearMap.lTensor_zero, LinearMap.zero_apply, map_zero]\n  use Basis.ofRepr iequiv.symm\n  intro j\n  simp [iequiv, i]\n\n"}
{"name":"Module.exists_basis_of_span_of_maximalIdeal_rTensor_injective","module":"Mathlib.RingTheory.LocalRing.Module","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : IsLocalRing R\ninstâœ : Module.FinitePresentation R M\nH : Function.Injective â‡‘(LinearMap.rTensor M (Submodule.subtype (IsLocalRing.maximalIdeal R)))\nÎ¹ : Type u\nv : Î¹ â†’ M\nhv : Eq (Submodule.span R (Set.range v)) Top.top\nâŠ¢ Exists fun Îº => Exists fun a => Exists fun b => âˆ€ (i : Îº), Eq (b i) (v (a i))","decl":"/--\nIf `M` is a finitely presented module over a local ring `(R, ğ”ª)` such that `m âŠ— M â†’ M` is\ninjective, then every generating family contains a basis.\n-/\nlemma exists_basis_of_span_of_maximalIdeal_rTensor_injective [Module.FinitePresentation R M]\n    (H : Function.Injective ((ğ”ª).subtype.rTensor M))\n    {Î¹ : Type u} (v : Î¹ â†’ M) (hv : Submodule.span R (Set.range v) = âŠ¤) :\n    âˆƒ (Îº : Type u) (a : Îº â†’ Î¹) (b : Basis Îº R M), âˆ€ i, b i = v (a i) := by\n  have := (map_tensorProduct_mk_eq_top (N := Submodule.span R (Set.range v))).mpr hv\n  rw [â† Submodule.span_image, â† Set.range_comp, eq_top_iff, â† SetLike.coe_subset_coe,\n    Submodule.top_coe] at this\n  have : Submodule.span k (Set.range (TensorProduct.mk R k M 1 âˆ˜ v)) = âŠ¤ := by\n    rw [eq_top_iff]\n    exact Set.Subset.trans this (Submodule.span_subset_span _ _ _)\n  obtain âŸ¨Îº, a, ha, hsp, hliâŸ© := exists_linearIndependent' k (TensorProduct.mk R k M 1 âˆ˜ v)\n  rw [this] at hsp\n  obtain âŸ¨b, hbâŸ© := exists_basis_of_basis_baseChange (v âˆ˜ a) hli hsp H\n  use Îº, a, b, hb\n\n"}
{"name":"Module.exists_basis_of_span_of_flat","module":"Mathlib.RingTheory.LocalRing.Module","initialProofState":"R : Type u_1\ninstâœâµ : CommRing R\nM : Type u_2\ninstâœâ´ : AddCommGroup M\ninstâœÂ³ : Module R M\ninstâœÂ² : IsLocalRing R\ninstâœÂ¹ : Module.FinitePresentation R M\ninstâœ : Module.Flat R M\nÎ¹ : Type u\nv : Î¹ â†’ M\nhv : Eq (Submodule.span R (Set.range v)) Top.top\nâŠ¢ Exists fun Îº => Exists fun a => Exists fun b => âˆ€ (i : Îº), Eq (b i) (v (a i))","decl":"lemma exists_basis_of_span_of_flat [Module.FinitePresentation R M] [Module.Flat R M]\n    {Î¹ : Type u} (v : Î¹ â†’ M) (hv : Submodule.span R (Set.range v) = âŠ¤) :\n    âˆƒ (Îº : Type u) (a : Îº â†’ Î¹) (b : Basis Îº R M), âˆ€ i, b i = v (a i) :=\n  exists_basis_of_span_of_maximalIdeal_rTensor_injective\n    (Module.Flat.rTensor_preserves_injective_linearMap (ğ”ª).subtype Subtype.val_injective) v hv\n\n"}
{"name":"Module.free_of_maximalIdeal_rTensor_injective","module":"Mathlib.RingTheory.LocalRing.Module","initialProofState":"R : Type u_1\ninstâœâ´ : CommRing R\nM : Type u_2\ninstâœÂ³ : AddCommGroup M\ninstâœÂ² : Module R M\ninstâœÂ¹ : IsLocalRing R\ninstâœ : Module.FinitePresentation R M\nH : Function.Injective â‡‘(LinearMap.rTensor M (Submodule.subtype (IsLocalRing.maximalIdeal R)))\nâŠ¢ Module.Free R M","decl":"/--\nIf `M` is a finitely presented module over a local ring `(R, ğ”ª)` such that `m âŠ— M â†’ M` is\ninjective, then `M` is free.\n-/\ntheorem free_of_maximalIdeal_rTensor_injective [Module.FinitePresentation R M]\n    (H : Function.Injective ((ğ”ª).subtype.rTensor M)) :\n    Module.Free R M := by\n  obtain âŸ¨_, _, b, _âŸ© := exists_basis_of_span_of_maximalIdeal_rTensor_injective H id (by simp)\n  exact Free.of_basis b\n\n-- TODO: Generalise this to finite free modules.\n"}
{"name":"Module.free_of_flat_of_isLocalRing","module":"Mathlib.RingTheory.LocalRing.Module","initialProofState":"R : Type u_1\ninstâœâµ : CommRing R\nP : Type u_2\ninstâœâ´ : AddCommGroup P\ninstâœÂ³ : Module R P\ninstâœÂ² : IsLocalRing R\ninstâœÂ¹ : Module.FinitePresentation R P\ninstâœ : Module.Flat R P\nâŠ¢ Module.Free R P","decl":"theorem free_of_flat_of_isLocalRing [Module.FinitePresentation R P] [Module.Flat R P] :\n    Module.Free R P :=\n  free_of_maximalIdeal_rTensor_injective\n    (Module.Flat.rTensor_preserves_injective_linearMap _ Subtype.val_injective)\n\n"}
{"name":"Module.free_of_flat_of_localRing","module":"Mathlib.RingTheory.LocalRing.Module","initialProofState":"R : Type u_1\ninstâœâµ : CommRing R\nP : Type u_2\ninstâœâ´ : AddCommGroup P\ninstâœÂ³ : Module R P\ninstâœÂ² : IsLocalRing R\ninstâœÂ¹ : Module.FinitePresentation R P\ninstâœ : Module.Flat R P\nâŠ¢ Module.Free R P","decl":"@[deprecated (since := \"2024-11-12\")] alias free_of_flat_of_localRing := free_of_flat_of_isLocalRing\n\n"}
{"name":"Module.free_of_lTensor_residueField_injective","module":"Mathlib.RingTheory.LocalRing.Module","initialProofState":"R : Type u_3\ninstâœÂ¹â° : CommRing R\nM : Type u_4\nN : Type u_1\ninstâœâ¹ : AddCommGroup M\ninstâœâ¸ : AddCommGroup N\ninstâœâ· : Module R M\ninstâœâ¶ : Module R N\nP : Type u_2\ninstâœâµ : AddCommGroup P\ninstâœâ´ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\ninstâœÂ³ : IsLocalRing R\nhg : Function.Surjective â‡‘g\nh : Function.Exact â‡‘f â‡‘g\ninstâœÂ² : Module.Finite R M\ninstâœÂ¹ : Module.Finite R N\ninstâœ : Module.Free R N\nhf : Function.Injective â‡‘(LinearMap.lTensor (IsLocalRing.ResidueField R) f)\nâŠ¢ Module.Free R P","decl":"/--\nIf `M â†’ N â†’ P â†’ 0` is a presentation of `P` over a local ring `(R, ğ”ª, k)` with\n`M` finite and `N` finite free, then injectivity of `k âŠ— M â†’ k âŠ— N` implies that `P` is free.\n-/\ntheorem free_of_lTensor_residueField_injective (hg : Surjective g) (h : Exact f g)\n    [Module.Finite R M] [Module.Finite R N] [Module.Free R N]\n    (hf : Function.Injective (f.lTensor k)) :\n    Module.Free R P := by\n  have := Module.finitePresentation_of_free_of_surjective g hg\n    (by rw [h.linearMap_ker_eq, LinearMap.range_eq_map]; exact (Module.Finite.fg_top).map f)\n  apply free_of_maximalIdeal_rTensor_injective\n  rw [â† LinearMap.lTensor_inj_iff_rTensor_inj]\n  apply lTensor_injective_of_exact_of_exact_of_rTensor_injective\n    h hg (LinearMap.exact_subtype_mkQ ğ”ª) (Submodule.mkQ_surjective _)\n    ((LinearMap.lTensor_inj_iff_rTensor_inj _ _).mp hf)\n    (Module.Flat.lTensor_preserves_injective_linearMap _ Subtype.val_injective)\n\n"}
{"name":"IsLocalRing.split_injective_iff_lTensor_residueField_injective","module":"Mathlib.RingTheory.LocalRing.Module","initialProofState":"R : Type u_1\ninstâœâ¸ : CommRing R\nM : Type u_2\nN : Type u_3\ninstâœâ· : AddCommGroup M\ninstâœâ¶ : AddCommGroup N\ninstâœâµ : Module R M\ninstâœâ´ : Module R N\ninstâœÂ³ : IsLocalRing R\ninstâœÂ² : Module.Finite R M\ninstâœÂ¹ : Module.Finite R N\ninstâœ : Module.Free R N\nl : LinearMap (RingHom.id R) M N\nâŠ¢ Iff (Exists fun l' => Eq (l'.comp l) LinearMap.id) (Function.Injective â‡‘(LinearMap.lTensor (IsLocalRing.ResidueField R) l))","decl":"/--\nGiven a linear map `l : M â†’ N` over a local ring `(R, ğ”ª, k)`\nwith `M` finite and `N` finite free,\n`l` is a split injection if and only if `k âŠ— l` is a (split) injection.\n-/\ntheorem IsLocalRing.split_injective_iff_lTensor_residueField_injective [IsLocalRing R]\n    [Module.Finite R M] [Module.Finite R N] [Module.Free R N] (l : M â†’â‚—[R] N) :\n    (âˆƒ l', l' âˆ˜â‚— l = LinearMap.id) â†” Function.Injective (l.lTensor (ResidueField R)) := by\n  constructor\n  Â· intro âŸ¨l', hlâŸ©\n    have : l'.lTensor (ResidueField R) âˆ˜â‚— l.lTensor (ResidueField R) = .id := by\n      rw [â† LinearMap.lTensor_comp, hl, LinearMap.lTensor_id]\n    exact Function.HasLeftInverse.injective âŸ¨_, LinearMap.congr_fun thisâŸ©\n  Â· intro h\n    -- By `Module.free_of_lTensor_residueField_injective`, `k âŠ— l` injective => `N â§¸ l(M)` free.\n    have := Module.free_of_lTensor_residueField_injective l (LinearMap.range l).mkQ\n      (Submodule.mkQ_surjective _) l.exact_map_mkQ_range h\n    -- Hence `l(M)` is projective because `0 â†’ l(M) â†’ N â†’ N â§¸ l(M) â†’ 0` splits.\n    have : Module.Projective R (LinearMap.range l) := by\n      have := (Exact.split_tfae (LinearMap.exact_subtype_mkQ (LinearMap.range l))\n        Subtype.val_injective (Submodule.mkQ_surjective _)).out 0 1\n      obtain âŸ¨l', hl'âŸ© := this.mp\n         (Module.projective_lifting_property _ _ (Submodule.mkQ_surjective _))\n      exact Module.Projective.of_split _ _ hl'\n    -- Then `0 â†’ ker l â†’ M â†’ l(M) â†’ 0` splits.\n    obtain âŸ¨l', hl'âŸ© : âˆƒ l', l' âˆ˜â‚— (LinearMap.ker l).subtype = LinearMap.id := by\n      have : Function.Exact (LinearMap.ker l).subtype\n          (l.codRestrict (LinearMap.range l) (LinearMap.mem_range_self l)) := by\n        rw [LinearMap.exact_iff, LinearMap.ker_rangeRestrict, Submodule.range_subtype]\n      have := (Exact.split_tfae this\n        Subtype.val_injective (fun âŸ¨x, y, eâŸ© â†¦ âŸ¨y, Subtype.ext eâŸ©)).out 0 1\n      exact this.mp (Module.projective_lifting_property _ _ (fun âŸ¨x, y, eâŸ© â†¦ âŸ¨y, Subtype.ext eâŸ©))\n    have : Module.Finite R (LinearMap.ker l) := by\n      refine Module.Finite.of_surjective l' ?_\n      exact Function.HasRightInverse.surjective âŸ¨_, DFunLike.congr_fun hl'âŸ©\n    -- And tensoring with `k` preserves the injectivity of the first arrow.\n    -- That is, `k âŠ— ker l â†’ k âŠ— M` is also injective.\n    have H : Function.Injective ((LinearMap.ker l).subtype.lTensor k) := by\n      apply_fun (LinearMap.lTensor k) at hl'\n      rw [LinearMap.lTensor_comp, LinearMap.lTensor_id] at hl'\n      exact Function.HasLeftInverse.injective âŸ¨l'.lTensor k, DFunLike.congr_fun hl'âŸ©\n    -- But by assumption `k âŠ— M â†’ k âŠ— l(M)` is already injective, so `k âŠ— ker l = 0`.\n    have : Subsingleton (k âŠ—[R] LinearMap.ker l) := by\n      refine (subsingleton_iff_forall_eq 0).mpr fun y â†¦ H (h ?_)\n      rw [map_zero, map_zero, â† LinearMap.comp_apply, â† LinearMap.lTensor_comp,\n        l.exact_subtype_ker_map.linearMap_comp_eq_zero, LinearMap.lTensor_zero,\n        LinearMap.zero_apply]\n    -- By Nakayama's lemma, `l` is injective.\n    have : Function.Injective l := by\n      rwa [â† LinearMap.ker_eq_bot, â† Submodule.subsingleton_iff_eq_bot,\n        â† IsLocalRing.subsingleton_tensorProduct (R := R)]\n    -- Whence `M â‰ƒ l(M)` is projective and the result follows.\n    have := (Exact.split_tfae l.exact_map_mkQ_range this (Submodule.mkQ_surjective _)).out 0 1\n    rw [â† this]\n    exact Module.projective_lifting_property _ _ (Submodule.mkQ_surjective _)\n\n"}
{"name":"LocalRing.split_injective_iff_lTensor_residueField_injective","module":"Mathlib.RingTheory.LocalRing.Module","initialProofState":"R : Type u_1\ninstâœâ¸ : CommRing R\nM : Type u_2\nN : Type u_3\ninstâœâ· : AddCommGroup M\ninstâœâ¶ : AddCommGroup N\ninstâœâµ : Module R M\ninstâœâ´ : Module R N\ninstâœÂ³ : IsLocalRing R\ninstâœÂ² : Module.Finite R M\ninstâœÂ¹ : Module.Finite R N\ninstâœ : Module.Free R N\nl : LinearMap (RingHom.id R) M N\nâŠ¢ Iff (Exists fun l' => Eq (l'.comp l) LinearMap.id) (Function.Injective â‡‘(LinearMap.lTensor (IsLocalRing.ResidueField R) l))","decl":"@[deprecated (since := \"2024-11-09\")]\nalias LocalRing.split_injective_iff_lTensor_residueField_injective :=\n  IsLocalRing.split_injective_iff_lTensor_residueField_injective\n\n"}
