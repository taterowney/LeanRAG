{"name":"CategoryTheory.Comonad.ComonadicityInternal.main_pair_coreflexive","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : adj.toComonad.Coalgebra\n‚ä¢ CategoryTheory.IsCoreflexivePair (G.map A.a) (adj.unit.app (G.obj A.A))","decl":"/-- The \"main pair\" for a coalgebra `(A, Œ±)` is the pair of morphisms `(G Œ±, Œ∑_GA)`. It is always a\ncoreflexive pair, and will be used to construct the left adjoint to the comparison functor and show\nit is an equivalence.\n-/\ninstance main_pair_coreflexive (A : adj.toComonad.Coalgebra) :\n    IsCoreflexivePair (G.map A.a) (adj.unit.app (G.obj A.A)) := by\n  apply IsCoreflexivePair.mk' (G.map (adj.counit.app _)) _ _\n  ¬∑ rw [‚Üê G.map_comp, ‚Üê G.map_id]\n    exact congr_arg G.map A.counit\n  ¬∑ rw [adj.right_triangle_components]\n    rfl\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.main_pair_F_cosplit","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : adj.toComonad.Coalgebra\n‚ä¢ F.IsCosplitPair (G.map A.a) (adj.unit.app (G.obj A.A))","decl":"/-- The \"main pair\" for a coalgebra `(A, Œ±)` is the pair of morphisms `(G Œ±, Œ∑_GA)`. It is always a\n`G`-cosplit pair, and will be used to construct the right adjoint to the comparison functor and show\nit is an equivalence.\n-/\ninstance main_pair_F_cosplit (A : adj.toComonad.Coalgebra) :\n    F.IsCosplitPair (G.map A.a)\n      (adj.unit.app (G.obj A.A)) where\n  splittable := ‚ü®_, _, ‚ü®beckSplitEqualizer A‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.comparisonRightAdjointHomEquiv_symm_apply_f","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : adj.toComonad.Coalgebra\nB : C\ninst‚úù : CategoryTheory.Limits.HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))\nf : Quiver.Hom B (CategoryTheory.Comonad.ComonadicityInternal.comparisonRightAdjointObj adj A)\n‚ä¢ Eq ((CategoryTheory.Comonad.ComonadicityInternal.comparisonRightAdjointHomEquiv adj A B).symm f).f ((adj.homEquiv B A.A).symm (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.equalizer.Œπ (G.map A.a) (adj.unit.app (G.toPrefunctor.1 A.A)))))","decl":"/--\nWe have a bijection of homsets which will be used to construct the right adjoint to the comparison\nfunctor.\n-/\n@[simps!]\ndef comparisonRightAdjointHomEquiv (A : adj.toComonad.Coalgebra) (B : C)\n    [HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))] :\n    ((comparison adj).obj B ‚ü∂ A) ‚âÉ (B ‚ü∂ comparisonRightAdjointObj adj A) where\n      toFun f := by\n        refine equalizer.lift (adj.homEquiv _ _ f.f) ?_\n        simp only [Adjunction.toComonad_coe, Functor.comp_obj, Adjunction.homEquiv_unit,\n          Functor.id_obj, Category.assoc, ‚Üê G.map_comp, ‚Üê f.h, comparison_obj_A, comparison_obj_a]\n        rw [Functor.comp_map, Functor.map_comp, Adjunction.unit_naturality_assoc,\n          Adjunction.unit_naturality]\n      invFun f := by\n        refine ‚ü®(adj.homEquiv _ _).symm (f ‚â´ (equalizer.Œπ _ _)), (adj.homEquiv _ _).injective ?_‚ü©\n        simp only [Adjunction.toComonad_coe, Functor.comp_obj, comparison_obj_A, comparison_obj_a,\n          Adjunction.homEquiv_counit, Functor.id_obj, Functor.map_comp, Category.assoc,\n          Functor.comp_map, Adjunction.homEquiv_unit, Adjunction.unit_naturality_assoc,\n          Adjunction.unit_naturality, Adjunction.right_triangle_components_assoc]\n        congr 1\n        exact (equalizer.condition _ _).symm\n      left_inv f := by aesop\n      right_inv f := by apply equalizer.hom_ext; simp\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.comparisonRightAdjointHomEquiv_apply","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : adj.toComonad.Coalgebra\nB : C\ninst‚úù : CategoryTheory.Limits.HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))\nf : Quiver.Hom ((CategoryTheory.Comonad.comparison adj).obj B) A\n‚ä¢ Eq ((CategoryTheory.Comonad.ComonadicityInternal.comparisonRightAdjointHomEquiv adj A B) f) (CategoryTheory.Limits.equalizer.lift ((adj.homEquiv B A.A) f.f) ‚ãØ)","decl":"/--\nWe have a bijection of homsets which will be used to construct the right adjoint to the comparison\nfunctor.\n-/\n@[simps!]\ndef comparisonRightAdjointHomEquiv (A : adj.toComonad.Coalgebra) (B : C)\n    [HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))] :\n    ((comparison adj).obj B ‚ü∂ A) ‚âÉ (B ‚ü∂ comparisonRightAdjointObj adj A) where\n      toFun f := by\n        refine equalizer.lift (adj.homEquiv _ _ f.f) ?_\n        simp only [Adjunction.toComonad_coe, Functor.comp_obj, Adjunction.homEquiv_unit,\n          Functor.id_obj, Category.assoc, ‚Üê G.map_comp, ‚Üê f.h, comparison_obj_A, comparison_obj_a]\n        rw [Functor.comp_map, Functor.map_comp, Adjunction.unit_naturality_assoc,\n          Adjunction.unit_naturality]\n      invFun f := by\n        refine ‚ü®(adj.homEquiv _ _).symm (f ‚â´ (equalizer.Œπ _ _)), (adj.homEquiv _ _).injective ?_‚ü©\n        simp only [Adjunction.toComonad_coe, Functor.comp_obj, comparison_obj_A, comparison_obj_a,\n          Adjunction.homEquiv_counit, Functor.id_obj, Functor.map_comp, Category.assoc,\n          Functor.comp_map, Adjunction.homEquiv_unit, Adjunction.unit_naturality_assoc,\n          Adjunction.unit_naturality, Adjunction.right_triangle_components_assoc]\n        congr 1\n        exact (equalizer.condition _ _).symm\n      left_inv f := by aesop\n      right_inv f := by apply equalizer.hom_ext; simp\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.comparisonAdjunction_counit","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst‚úù : ‚àÄ (A : adj.toComonad.Coalgebra), CategoryTheory.Limits.HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))\n‚ä¢ Eq (CategoryTheory.Comonad.ComonadicityInternal.comparisonAdjunction adj).counit { app := fun Y => (CategoryTheory.Comonad.ComonadicityInternal.comparisonRightAdjointHomEquiv adj Y (CategoryTheory.Comonad.ComonadicityInternal.comparisonRightAdjointObj adj Y)).symm (CategoryTheory.CategoryStruct.id (CategoryTheory.Comonad.ComonadicityInternal.comparisonRightAdjointObj adj Y)), naturality := ‚ãØ }","decl":"/-- Provided we have the appropriate equalizers, we have an adjunction to the comparison functor.\n-/\n@[simps! counit]\ndef comparisonAdjunction\n    [‚àÄ A : adj.toComonad.Coalgebra, HasEqualizer (G.map A.a)\n      (adj.unit.app (G.obj A.A))] :\n    comparison adj ‚ä£ rightAdjointComparison adj :=\n  Adjunction.adjunctionOfEquivRight _ _\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.comparisonAdjunction_counit_f_aux","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst‚úù : ‚àÄ (A : adj.toComonad.Coalgebra), CategoryTheory.Limits.HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))\nA : adj.toComonad.Coalgebra\n‚ä¢ Eq ((CategoryTheory.Comonad.ComonadicityInternal.comparisonAdjunction adj).counit.app A).f ((adj.homEquiv (CategoryTheory.Limits.equalizer (G.map A.a) (adj.unit.app (G.obj A.A))) A.A).symm (CategoryTheory.Limits.equalizer.Œπ (G.map A.a) (adj.unit.app (G.obj A.A))))","decl":"theorem comparisonAdjunction_counit_f_aux\n    [‚àÄ A : adj.toComonad.Coalgebra, HasEqualizer (G.map A.a)\n      (adj.unit.app (G.obj A.A))]\n    (A : adj.toComonad.Coalgebra) :\n    ((comparisonAdjunction adj).counit.app A).f =\n      (adj.homEquiv _ A.A).symm (equalizer.Œπ (G.map A.a) (adj.unit.app (G.obj A.A))) :=\n  congr_arg (adj.homEquiv _ _).symm (Category.id_comp _)\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.counitFork_pt","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : adj.toComonad.Coalgebra\ninst‚úù : CategoryTheory.Limits.HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))\n‚ä¢ Eq (CategoryTheory.Comonad.ComonadicityInternal.counitFork A).pt (F.obj (CategoryTheory.Limits.equalizer (G.map A.a) (adj.unit.app (G.obj A.A))))","decl":"/-- This is a fork which is helpful for establishing comonadicity: the morphism from this fork to\nthe Beck equalizer is the counit for the adjunction on the comparison functor.\n-/\n@[simps! pt]\ndef counitFork (A : adj.toComonad.Coalgebra)\n    [HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))] :\n    Fork (F.map (G.map A.a)) (F.map (adj.unit.app (G.obj A.A))) :=\n  Fork.ofŒπ (F.map (equalizer.Œπ (G.map A.a) (adj.unit.app (G.obj A.A))))\n    (by rw [‚Üê F.map_comp, equalizer.condition, F.map_comp])\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.unitFork_Œπ","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : adj.toComonad.Coalgebra\ninst‚úù : CategoryTheory.Limits.HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))\n‚ä¢ Eq (CategoryTheory.Comonad.ComonadicityInternal.counitFork A).Œπ (F.map (CategoryTheory.Limits.equalizer.Œπ (G.map A.a) (adj.unit.app (G.obj A.A))))","decl":"@[simp]\ntheorem unitFork_Œπ (A : adj.toComonad.Coalgebra)\n    [HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))] :\n    (counitFork A).Œπ = F.map (equalizer.Œπ (G.map A.a) (adj.unit.app (G.obj A.A))) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.comparisonAdjunction_counit_f","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst‚úù : ‚àÄ (A : adj.toComonad.Coalgebra), CategoryTheory.Limits.HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))\nA : adj.toComonad.Coalgebra\n‚ä¢ Eq ((CategoryTheory.Comonad.ComonadicityInternal.comparisonAdjunction adj).counit.app A).f ((CategoryTheory.Comonad.beckEqualizer A).lift (CategoryTheory.Comonad.ComonadicityInternal.counitFork A))","decl":"theorem comparisonAdjunction_counit_f\n    [‚àÄ A : adj.toComonad.Coalgebra, HasEqualizer (G.map A.a)\n      (adj.unit.app (G.obj A.A))]\n    (A : adj.toComonad.Coalgebra) :\n    ((comparisonAdjunction adj).counit.app A).f = (beckEqualizer A).lift (counitFork A) := by\n  simp [Adjunction.homEquiv_counit]\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.unitFork_pt","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nB : C\n‚ä¢ Eq (CategoryTheory.Comonad.ComonadicityInternal.unitFork adj B).pt B","decl":"/-- The fork which describes the unit of the adjunction: the morphism from this fork to the\nthe equalizer of this pair is the unit.\n-/\n@[simps!]\ndef unitFork (B : C) :\n    Fork (G.map (F.map (adj.unit.app B)))\n      (adj.unit.app (G.obj (F.obj B))) :=\n  Fork.ofŒπ (adj.unit.app B) (adj.unit_naturality _)\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.unitFork_œÄ_app","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nB : C\nX : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq ((CategoryTheory.Comonad.ComonadicityInternal.unitFork adj B).œÄ.app X) (CategoryTheory.Limits.WalkingParallelPair.rec (motive := fun t => Eq X t ‚Üí Quiver.Hom B ((CategoryTheory.Limits.parallelPair (G.map (F.map (adj.unit.app B))) (adj.unit.app (G.obj (F.obj B)))).obj X)) (fun h => Eq.rec (adj.unit.app B) ‚ãØ) (fun h => Eq.rec (CategoryTheory.CategoryStruct.comp (adj.unit.app B) (adj.unit.app (G.obj (F.obj B)))) ‚ãØ) X ‚ãØ)","decl":"/-- The fork which describes the unit of the adjunction: the morphism from this fork to the\nthe equalizer of this pair is the unit.\n-/\n@[simps!]\ndef unitFork (B : C) :\n    Fork (G.map (F.map (adj.unit.app B)))\n      (adj.unit.app (G.obj (F.obj B))) :=\n  Fork.ofŒπ (adj.unit.app B) (adj.unit_naturality _)\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.instHasLimitWalkingParallelPairParallelPairMapAppUnitObjOfHasEqualizerAA","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst‚úù : ‚àÄ (A : adj.toComonad.Coalgebra), CategoryTheory.Limits.HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))\nB : C\n‚ä¢ CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair (G.map (F.map (adj.unit.app B))) (adj.unit.app (G.obj (F.obj B))))","decl":"instance\n    [‚àÄ A : adj.toComonad.Coalgebra, HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))]\n    (B : C) : HasLimit (parallelPair\n      (G.map (F.map (NatTrans.app adj.unit B)))\n      (NatTrans.app adj.unit (G.obj (F.obj B)))) :=\n  inferInstanceAs <| HasEqualizer\n    (G.map ((comparison adj).obj B).a)\n    (adj.unit.app (G.obj ((comparison adj).obj B).A))\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.comparisonAdjunction_unit_app","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst‚úù : ‚àÄ (A : adj.toComonad.Coalgebra), CategoryTheory.Limits.HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))\nB : C\n‚ä¢ Eq ((CategoryTheory.Comonad.ComonadicityInternal.comparisonAdjunction adj).unit.app B) (CategoryTheory.Limits.limit.lift (CategoryTheory.Limits.parallelPair (G.map (F.map (adj.unit.app B))) (adj.unit.app (G.obj (F.obj B)))) (CategoryTheory.Comonad.ComonadicityInternal.unitFork adj B))","decl":"theorem comparisonAdjunction_unit_app\n    [‚àÄ A : adj.toComonad.Coalgebra, HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))] (B : C) :\n    (comparisonAdjunction adj).unit.app B = limit.lift _ (unitFork adj B) := by\n  apply equalizer.hom_ext\n  change\n    equalizer.lift ((adj.homEquiv B _) (ùüô _)) _ ‚â´ equalizer.Œπ _ _ =\n      equalizer.lift _ _ ‚â´ equalizer.Œπ _ _\n  simp [Adjunction.homEquiv_unit]\n\n"}
{"name":"CategoryTheory.Comonad.HasEqualizerOfIsCosplitPair.out","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Comonad.HasEqualizerOfIsCosplitPair F\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : F.IsCosplitPair f g\n‚ä¢ CategoryTheory.Limits.HasEqualizer f g","decl":"/-- Dual to `Monad.HasCoequalizerOfIsSplitPair`. -/\nclass HasEqualizerOfIsCosplitPair (F : C ‚•§ D) : Prop where\n  /-- If `f, g` is an `F`-cosplit pair, then they have an equalizer. -/\n  out : ‚àÄ {A B} (f g : A ‚ü∂ B) [F.IsCosplitPair f g], HasEqualizer f g\n\n"}
{"name":"CategoryTheory.Comonad.instHasEqualizerMapAAppUnitObjAOfHasEqualizerOfIsCosplitPair","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst‚úù : CategoryTheory.Comonad.HasEqualizerOfIsCosplitPair F\nA : adj.toComonad.Coalgebra\n‚ä¢ CategoryTheory.Limits.HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))","decl":"instance [HasEqualizerOfIsCosplitPair F] : ‚àÄ (A : Coalgebra adj.toComonad),\n    HasEqualizer (G.map A.a)\n      (adj.unit.app (G.obj A.A)) :=\n  fun _ => HasEqualizerOfIsCosplitPair.out F _ _\n\n"}
{"name":"CategoryTheory.Comonad.PreservesLimitOfIsCosplitPair.out","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Comonad.PreservesLimitOfIsCosplitPair F\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : F.IsCosplitPair f g\n‚ä¢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f g) F","decl":"/-- Dual to `Monad.PreservesColimitOfIsSplitPair`. -/\nclass PreservesLimitOfIsCosplitPair (F : C ‚•§ D) where\n  /-- If `f, g` is an `F`-cosplit pair, then `F` preserves limits of `parallelPair f g`. -/\n  out : ‚àÄ {A B} (f g : A ‚ü∂ B) [F.IsCosplitPair f g], PreservesLimit (parallelPair f g) F\n\n"}
{"name":"CategoryTheory.Comonad.instPreservesLimitWalkingParallelPairParallelPairOfIsCosplitPairOfPreservesLimitOfIsCosplitPair","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA B : C\nf g : Quiver.Hom A B\ninst‚úù¬π : F.IsCosplitPair f g\ninst‚úù : CategoryTheory.Comonad.PreservesLimitOfIsCosplitPair F\n‚ä¢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f g) F","decl":"instance {A B} (f g : A ‚ü∂ B) [F.IsCosplitPair f g] [PreservesLimitOfIsCosplitPair F] :\n    PreservesLimit (parallelPair f g) F := PreservesLimitOfIsCosplitPair.out f g\n\n"}
{"name":"CategoryTheory.Comonad.instPreservesLimitWalkingParallelPairParallelPairMapAAppUnitObjAOfPreservesLimitOfIsCosplitPair","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst‚úù : CategoryTheory.Comonad.PreservesLimitOfIsCosplitPair F\nA : adj.toComonad.Coalgebra\n‚ä¢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair (G.map A.a) (adj.unit.app (G.obj A.A))) F","decl":"instance [PreservesLimitOfIsCosplitPair F] : ‚àÄ (A : Coalgebra adj.toComonad),\n   PreservesLimit (parallelPair (G.map A.a)\n      (NatTrans.app adj.unit (G.obj A.A))) F :=\n  fun _ => PreservesLimitOfIsCosplitPair.out _ _\n\n"}
{"name":"CategoryTheory.Comonad.ReflectsLimitOfIsCosplitPair.out","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Comonad.ReflectsLimitOfIsCosplitPair F\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : F.IsCosplitPair f g\n‚ä¢ CategoryTheory.Limits.ReflectsLimit (CategoryTheory.Limits.parallelPair f g) F","decl":"/-- Dual to `Monad.ReflectsColimitOfIsSplitPair`. -/\nclass ReflectsLimitOfIsCosplitPair (F : C ‚•§ D) where\n  /-- If `f, g` is an `F`-cosplit pair, then `F` reflects limits for `parallelPair f g`. -/\n  out : ‚àÄ {A B} (f g : A ‚ü∂ B) [F.IsCosplitPair f g], ReflectsLimit (parallelPair f g) F\n\n"}
{"name":"CategoryTheory.Comonad.instReflectsLimitWalkingParallelPairParallelPairOfIsCosplitPairOfReflectsLimitOfIsCosplitPair","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA B : C\nf g : Quiver.Hom A B\ninst‚úù¬π : F.IsCosplitPair f g\ninst‚úù : CategoryTheory.Comonad.ReflectsLimitOfIsCosplitPair F\n‚ä¢ CategoryTheory.Limits.ReflectsLimit (CategoryTheory.Limits.parallelPair f g) F","decl":"instance {A B} (f g : A ‚ü∂ B) [F.IsCosplitPair f g] [ReflectsLimitOfIsCosplitPair F] :\n    ReflectsLimit (parallelPair f g) F := ReflectsLimitOfIsCosplitPair.out f g\n\n"}
{"name":"CategoryTheory.Comonad.instReflectsLimitWalkingParallelPairParallelPairMapAAppUnitObjAOfReflectsLimitOfIsCosplitPair","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst‚úù : CategoryTheory.Comonad.ReflectsLimitOfIsCosplitPair F\nA : adj.toComonad.Coalgebra\n‚ä¢ CategoryTheory.Limits.ReflectsLimit (CategoryTheory.Limits.parallelPair (G.map A.a) (adj.unit.app (G.obj A.A))) F","decl":"instance [ReflectsLimitOfIsCosplitPair F] : ‚àÄ (A : Coalgebra adj.toComonad),\n    ReflectsLimit (parallelPair (G.map A.a)\n      (NatTrans.app adj.unit (G.obj A.A))) F :=\n  fun _ => ReflectsLimitOfIsCosplitPair.out _ _\n\n"}
{"name":"CategoryTheory.Comonad.PreservesLimitOfIsCoreflexivePair.out","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Comonad.PreservesLimitOfIsCoreflexivePair F\nA B : C\nf g : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsCoreflexivePair f g\n‚ä¢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f g) F","decl":"/-- Dual to `Monad.PreservesColimitOfIsReflexivePair`. -/\nclass PreservesLimitOfIsCoreflexivePair (F : C ‚•§ D) where\n  /-- `f, g` is a coreflexive pair, then `F` preserves limits of `parallelPair f g`. -/\n  out : ‚àÄ ‚¶ÉA B‚¶Ñ (f g : A ‚ü∂ B) [IsCoreflexivePair f g], PreservesLimit (parallelPair f g) F\n\n"}
{"name":"CategoryTheory.Comonad.instPreservesLimitWalkingParallelPairParallelPairOfIsCoreflexivePairOfPreservesLimitOfIsCoreflexivePair","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nA B : C\nf g : Quiver.Hom A B\ninst‚úù¬π : CategoryTheory.IsCoreflexivePair f g\ninst‚úù : CategoryTheory.Comonad.PreservesLimitOfIsCoreflexivePair F\n‚ä¢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f g) F","decl":"instance {A B} (f g : A ‚ü∂ B) [IsCoreflexivePair f g] [PreservesLimitOfIsCoreflexivePair F] :\n  PreservesLimit (parallelPair f g) F := PreservesLimitOfIsCoreflexivePair.out f g\n\n"}
{"name":"CategoryTheory.Comonad.instPreservesLimitWalkingParallelPairParallelPairMapAAppUnitObjAOfPreservesLimitOfIsCoreflexivePair","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst‚úù : CategoryTheory.Comonad.PreservesLimitOfIsCoreflexivePair F\nX : adj.toComonad.Coalgebra\n‚ä¢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair (G.map X.a) (adj.unit.app (G.obj X.A))) F","decl":"instance [PreservesLimitOfIsCoreflexivePair F] : ‚àÄ X : Coalgebra adj.toComonad,\n    PreservesLimit (parallelPair (G.map X.a)\n      (NatTrans.app adj.unit (G.obj X.A))) F :=\n fun _ => PreservesLimitOfIsCoreflexivePair.out _ _\n\n"}
