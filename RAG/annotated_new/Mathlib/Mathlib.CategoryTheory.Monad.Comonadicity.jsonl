{"name":"CategoryTheory.Comonad.ComonadicityInternal.main_pair_coreflexive","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : adj.toComonad.Coalgebra\n⊢ CategoryTheory.IsCoreflexivePair (G.map A.a) (adj.unit.app (G.obj A.A))","decl":"/-- The \"main pair\" for a coalgebra `(A, α)` is the pair of morphisms `(G α, η_GA)`. It is always a\ncoreflexive pair, and will be used to construct the left adjoint to the comparison functor and show\nit is an equivalence.\n-/\ninstance main_pair_coreflexive (A : adj.toComonad.Coalgebra) :\n    IsCoreflexivePair (G.map A.a) (adj.unit.app (G.obj A.A)) := by\n  apply IsCoreflexivePair.mk' (G.map (adj.counit.app _)) _ _\n  · rw [← G.map_comp, ← G.map_id]\n    exact congr_arg G.map A.counit\n  · rw [adj.right_triangle_components]\n    rfl\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.main_pair_F_cosplit","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : adj.toComonad.Coalgebra\n⊢ F.IsCosplitPair (G.map A.a) (adj.unit.app (G.obj A.A))","decl":"/-- The \"main pair\" for a coalgebra `(A, α)` is the pair of morphisms `(G α, η_GA)`. It is always a\n`G`-cosplit pair, and will be used to construct the right adjoint to the comparison functor and show\nit is an equivalence.\n-/\ninstance main_pair_F_cosplit (A : adj.toComonad.Coalgebra) :\n    F.IsCosplitPair (G.map A.a)\n      (adj.unit.app (G.obj A.A)) where\n  splittable := ⟨_, _, ⟨beckSplitEqualizer A⟩⟩\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.comparisonRightAdjointHomEquiv_symm_apply_f","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : adj.toComonad.Coalgebra\nB : C\ninst✝ : CategoryTheory.Limits.HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))\nf : Quiver.Hom B (CategoryTheory.Comonad.ComonadicityInternal.comparisonRightAdjointObj adj A)\n⊢ Eq ((CategoryTheory.Comonad.ComonadicityInternal.comparisonRightAdjointHomEquiv adj A B).symm f).f ((adj.homEquiv B A.A).symm (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.equalizer.ι (G.map A.a) (adj.unit.app (G.toPrefunctor.1 A.A)))))","decl":"/--\nWe have a bijection of homsets which will be used to construct the right adjoint to the comparison\nfunctor.\n-/\n@[simps!]\ndef comparisonRightAdjointHomEquiv (A : adj.toComonad.Coalgebra) (B : C)\n    [HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))] :\n    ((comparison adj).obj B ⟶ A) ≃ (B ⟶ comparisonRightAdjointObj adj A) where\n      toFun f := by\n        refine equalizer.lift (adj.homEquiv _ _ f.f) ?_\n        simp only [Adjunction.toComonad_coe, Functor.comp_obj, Adjunction.homEquiv_unit,\n          Functor.id_obj, Category.assoc, ← G.map_comp, ← f.h, comparison_obj_A, comparison_obj_a]\n        rw [Functor.comp_map, Functor.map_comp, Adjunction.unit_naturality_assoc,\n          Adjunction.unit_naturality]\n      invFun f := by\n        refine ⟨(adj.homEquiv _ _).symm (f ≫ (equalizer.ι _ _)), (adj.homEquiv _ _).injective ?_⟩\n        simp only [Adjunction.toComonad_coe, Functor.comp_obj, comparison_obj_A, comparison_obj_a,\n          Adjunction.homEquiv_counit, Functor.id_obj, Functor.map_comp, Category.assoc,\n          Functor.comp_map, Adjunction.homEquiv_unit, Adjunction.unit_naturality_assoc,\n          Adjunction.unit_naturality, Adjunction.right_triangle_components_assoc]\n        congr 1\n        exact (equalizer.condition _ _).symm\n      left_inv f := by aesop\n      right_inv f := by apply equalizer.hom_ext; simp\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.comparisonRightAdjointHomEquiv_apply","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : adj.toComonad.Coalgebra\nB : C\ninst✝ : CategoryTheory.Limits.HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))\nf : Quiver.Hom ((CategoryTheory.Comonad.comparison adj).obj B) A\n⊢ Eq ((CategoryTheory.Comonad.ComonadicityInternal.comparisonRightAdjointHomEquiv adj A B) f) (CategoryTheory.Limits.equalizer.lift ((adj.homEquiv B A.A) f.f) ⋯)","decl":"/--\nWe have a bijection of homsets which will be used to construct the right adjoint to the comparison\nfunctor.\n-/\n@[simps!]\ndef comparisonRightAdjointHomEquiv (A : adj.toComonad.Coalgebra) (B : C)\n    [HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))] :\n    ((comparison adj).obj B ⟶ A) ≃ (B ⟶ comparisonRightAdjointObj adj A) where\n      toFun f := by\n        refine equalizer.lift (adj.homEquiv _ _ f.f) ?_\n        simp only [Adjunction.toComonad_coe, Functor.comp_obj, Adjunction.homEquiv_unit,\n          Functor.id_obj, Category.assoc, ← G.map_comp, ← f.h, comparison_obj_A, comparison_obj_a]\n        rw [Functor.comp_map, Functor.map_comp, Adjunction.unit_naturality_assoc,\n          Adjunction.unit_naturality]\n      invFun f := by\n        refine ⟨(adj.homEquiv _ _).symm (f ≫ (equalizer.ι _ _)), (adj.homEquiv _ _).injective ?_⟩\n        simp only [Adjunction.toComonad_coe, Functor.comp_obj, comparison_obj_A, comparison_obj_a,\n          Adjunction.homEquiv_counit, Functor.id_obj, Functor.map_comp, Category.assoc,\n          Functor.comp_map, Adjunction.homEquiv_unit, Adjunction.unit_naturality_assoc,\n          Adjunction.unit_naturality, Adjunction.right_triangle_components_assoc]\n        congr 1\n        exact (equalizer.condition _ _).symm\n      left_inv f := by aesop\n      right_inv f := by apply equalizer.hom_ext; simp\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.comparisonAdjunction_counit","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : ∀ (A : adj.toComonad.Coalgebra), CategoryTheory.Limits.HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))\n⊢ Eq (CategoryTheory.Comonad.ComonadicityInternal.comparisonAdjunction adj).counit { app := fun Y => (CategoryTheory.Comonad.ComonadicityInternal.comparisonRightAdjointHomEquiv adj Y (CategoryTheory.Comonad.ComonadicityInternal.comparisonRightAdjointObj adj Y)).symm (CategoryTheory.CategoryStruct.id (CategoryTheory.Comonad.ComonadicityInternal.comparisonRightAdjointObj adj Y)), naturality := ⋯ }","decl":"/-- Provided we have the appropriate equalizers, we have an adjunction to the comparison functor.\n-/\n@[simps! counit]\ndef comparisonAdjunction\n    [∀ A : adj.toComonad.Coalgebra, HasEqualizer (G.map A.a)\n      (adj.unit.app (G.obj A.A))] :\n    comparison adj ⊣ rightAdjointComparison adj :=\n  Adjunction.adjunctionOfEquivRight _ _\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.comparisonAdjunction_counit_f_aux","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : ∀ (A : adj.toComonad.Coalgebra), CategoryTheory.Limits.HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))\nA : adj.toComonad.Coalgebra\n⊢ Eq ((CategoryTheory.Comonad.ComonadicityInternal.comparisonAdjunction adj).counit.app A).f ((adj.homEquiv (CategoryTheory.Limits.equalizer (G.map A.a) (adj.unit.app (G.obj A.A))) A.A).symm (CategoryTheory.Limits.equalizer.ι (G.map A.a) (adj.unit.app (G.obj A.A))))","decl":"theorem comparisonAdjunction_counit_f_aux\n    [∀ A : adj.toComonad.Coalgebra, HasEqualizer (G.map A.a)\n      (adj.unit.app (G.obj A.A))]\n    (A : adj.toComonad.Coalgebra) :\n    ((comparisonAdjunction adj).counit.app A).f =\n      (adj.homEquiv _ A.A).symm (equalizer.ι (G.map A.a) (adj.unit.app (G.obj A.A))) :=\n  congr_arg (adj.homEquiv _ _).symm (Category.id_comp _)\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.counitFork_pt","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : adj.toComonad.Coalgebra\ninst✝ : CategoryTheory.Limits.HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))\n⊢ Eq (CategoryTheory.Comonad.ComonadicityInternal.counitFork A).pt (F.obj (CategoryTheory.Limits.equalizer (G.map A.a) (adj.unit.app (G.obj A.A))))","decl":"/-- This is a fork which is helpful for establishing comonadicity: the morphism from this fork to\nthe Beck equalizer is the counit for the adjunction on the comparison functor.\n-/\n@[simps! pt]\ndef counitFork (A : adj.toComonad.Coalgebra)\n    [HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))] :\n    Fork (F.map (G.map A.a)) (F.map (adj.unit.app (G.obj A.A))) :=\n  Fork.ofι (F.map (equalizer.ι (G.map A.a) (adj.unit.app (G.obj A.A))))\n    (by rw [← F.map_comp, equalizer.condition, F.map_comp])\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.unitFork_ι","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nA : adj.toComonad.Coalgebra\ninst✝ : CategoryTheory.Limits.HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))\n⊢ Eq (CategoryTheory.Comonad.ComonadicityInternal.counitFork A).ι (F.map (CategoryTheory.Limits.equalizer.ι (G.map A.a) (adj.unit.app (G.obj A.A))))","decl":"@[simp]\ntheorem unitFork_ι (A : adj.toComonad.Coalgebra)\n    [HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))] :\n    (counitFork A).ι = F.map (equalizer.ι (G.map A.a) (adj.unit.app (G.obj A.A))) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.comparisonAdjunction_counit_f","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : ∀ (A : adj.toComonad.Coalgebra), CategoryTheory.Limits.HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))\nA : adj.toComonad.Coalgebra\n⊢ Eq ((CategoryTheory.Comonad.ComonadicityInternal.comparisonAdjunction adj).counit.app A).f ((CategoryTheory.Comonad.beckEqualizer A).lift (CategoryTheory.Comonad.ComonadicityInternal.counitFork A))","decl":"theorem comparisonAdjunction_counit_f\n    [∀ A : adj.toComonad.Coalgebra, HasEqualizer (G.map A.a)\n      (adj.unit.app (G.obj A.A))]\n    (A : adj.toComonad.Coalgebra) :\n    ((comparisonAdjunction adj).counit.app A).f = (beckEqualizer A).lift (counitFork A) := by\n  simp [Adjunction.homEquiv_counit]\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.unitFork_pt","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nB : C\n⊢ Eq (CategoryTheory.Comonad.ComonadicityInternal.unitFork adj B).pt B","decl":"/-- The fork which describes the unit of the adjunction: the morphism from this fork to the\nthe equalizer of this pair is the unit.\n-/\n@[simps!]\ndef unitFork (B : C) :\n    Fork (G.map (F.map (adj.unit.app B)))\n      (adj.unit.app (G.obj (F.obj B))) :=\n  Fork.ofι (adj.unit.app B) (adj.unit_naturality _)\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.unitFork_π_app","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\nB : C\nX : CategoryTheory.Limits.WalkingParallelPair\n⊢ Eq ((CategoryTheory.Comonad.ComonadicityInternal.unitFork adj B).π.app X) (CategoryTheory.Limits.WalkingParallelPair.rec (motive := fun t => Eq X t → Quiver.Hom B ((CategoryTheory.Limits.parallelPair (G.map (F.map (adj.unit.app B))) (adj.unit.app (G.obj (F.obj B)))).obj X)) (fun h => Eq.rec (adj.unit.app B) ⋯) (fun h => Eq.rec (CategoryTheory.CategoryStruct.comp (adj.unit.app B) (adj.unit.app (G.obj (F.obj B)))) ⋯) X ⋯)","decl":"/-- The fork which describes the unit of the adjunction: the morphism from this fork to the\nthe equalizer of this pair is the unit.\n-/\n@[simps!]\ndef unitFork (B : C) :\n    Fork (G.map (F.map (adj.unit.app B)))\n      (adj.unit.app (G.obj (F.obj B))) :=\n  Fork.ofι (adj.unit.app B) (adj.unit_naturality _)\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.instHasLimitWalkingParallelPairParallelPairMapAppUnitObjOfHasEqualizerAA","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : ∀ (A : adj.toComonad.Coalgebra), CategoryTheory.Limits.HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))\nB : C\n⊢ CategoryTheory.Limits.HasLimit (CategoryTheory.Limits.parallelPair (G.map (F.map (adj.unit.app B))) (adj.unit.app (G.obj (F.obj B))))","decl":"instance\n    [∀ A : adj.toComonad.Coalgebra, HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))]\n    (B : C) : HasLimit (parallelPair\n      (G.map (F.map (NatTrans.app adj.unit B)))\n      (NatTrans.app adj.unit (G.obj (F.obj B)))) :=\n  inferInstanceAs <| HasEqualizer\n    (G.map ((comparison adj).obj B).a)\n    (adj.unit.app (G.obj ((comparison adj).obj B).A))\n\n"}
{"name":"CategoryTheory.Comonad.ComonadicityInternal.comparisonAdjunction_unit_app","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : ∀ (A : adj.toComonad.Coalgebra), CategoryTheory.Limits.HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))\nB : C\n⊢ Eq ((CategoryTheory.Comonad.ComonadicityInternal.comparisonAdjunction adj).unit.app B) (CategoryTheory.Limits.limit.lift (CategoryTheory.Limits.parallelPair (G.map (F.map (adj.unit.app B))) (adj.unit.app (G.obj (F.obj B)))) (CategoryTheory.Comonad.ComonadicityInternal.unitFork adj B))","decl":"theorem comparisonAdjunction_unit_app\n    [∀ A : adj.toComonad.Coalgebra, HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))] (B : C) :\n    (comparisonAdjunction adj).unit.app B = limit.lift _ (unitFork adj B) := by\n  apply equalizer.hom_ext\n  change\n    equalizer.lift ((adj.homEquiv B _) (𝟙 _)) _ ≫ equalizer.ι _ _ =\n      equalizer.lift _ _ ≫ equalizer.ι _ _\n  simp [Adjunction.homEquiv_unit]\n\n"}
{"name":"CategoryTheory.Comonad.HasEqualizerOfIsCosplitPair.out","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Comonad.HasEqualizerOfIsCosplitPair F\nA B : C\nf g : Quiver.Hom A B\ninst✝ : F.IsCosplitPair f g\n⊢ CategoryTheory.Limits.HasEqualizer f g","decl":"/-- Dual to `Monad.HasCoequalizerOfIsSplitPair`. -/\nclass HasEqualizerOfIsCosplitPair (F : C ⥤ D) : Prop where\n  /-- If `f, g` is an `F`-cosplit pair, then they have an equalizer. -/\n  out : ∀ {A B} (f g : A ⟶ B) [F.IsCosplitPair f g], HasEqualizer f g\n\n"}
{"name":"CategoryTheory.Comonad.instHasEqualizerMapAAppUnitObjAOfHasEqualizerOfIsCosplitPair","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : CategoryTheory.Comonad.HasEqualizerOfIsCosplitPair F\nA : adj.toComonad.Coalgebra\n⊢ CategoryTheory.Limits.HasEqualizer (G.map A.a) (adj.unit.app (G.obj A.A))","decl":"instance [HasEqualizerOfIsCosplitPair F] : ∀ (A : Coalgebra adj.toComonad),\n    HasEqualizer (G.map A.a)\n      (adj.unit.app (G.obj A.A)) :=\n  fun _ => HasEqualizerOfIsCosplitPair.out F _ _\n\n"}
{"name":"CategoryTheory.Comonad.PreservesLimitOfIsCosplitPair.out","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Comonad.PreservesLimitOfIsCosplitPair F\nA B : C\nf g : Quiver.Hom A B\ninst✝ : F.IsCosplitPair f g\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f g) F","decl":"/-- Dual to `Monad.PreservesColimitOfIsSplitPair`. -/\nclass PreservesLimitOfIsCosplitPair (F : C ⥤ D) where\n  /-- If `f, g` is an `F`-cosplit pair, then `F` preserves limits of `parallelPair f g`. -/\n  out : ∀ {A B} (f g : A ⟶ B) [F.IsCosplitPair f g], PreservesLimit (parallelPair f g) F\n\n"}
{"name":"CategoryTheory.Comonad.instPreservesLimitWalkingParallelPairParallelPairOfIsCosplitPairOfPreservesLimitOfIsCosplitPair","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nA B : C\nf g : Quiver.Hom A B\ninst✝¹ : F.IsCosplitPair f g\ninst✝ : CategoryTheory.Comonad.PreservesLimitOfIsCosplitPair F\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f g) F","decl":"instance {A B} (f g : A ⟶ B) [F.IsCosplitPair f g] [PreservesLimitOfIsCosplitPair F] :\n    PreservesLimit (parallelPair f g) F := PreservesLimitOfIsCosplitPair.out f g\n\n"}
{"name":"CategoryTheory.Comonad.instPreservesLimitWalkingParallelPairParallelPairMapAAppUnitObjAOfPreservesLimitOfIsCosplitPair","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : CategoryTheory.Comonad.PreservesLimitOfIsCosplitPair F\nA : adj.toComonad.Coalgebra\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair (G.map A.a) (adj.unit.app (G.obj A.A))) F","decl":"instance [PreservesLimitOfIsCosplitPair F] : ∀ (A : Coalgebra adj.toComonad),\n   PreservesLimit (parallelPair (G.map A.a)\n      (NatTrans.app adj.unit (G.obj A.A))) F :=\n  fun _ => PreservesLimitOfIsCosplitPair.out _ _\n\n"}
{"name":"CategoryTheory.Comonad.ReflectsLimitOfIsCosplitPair.out","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Comonad.ReflectsLimitOfIsCosplitPair F\nA B : C\nf g : Quiver.Hom A B\ninst✝ : F.IsCosplitPair f g\n⊢ CategoryTheory.Limits.ReflectsLimit (CategoryTheory.Limits.parallelPair f g) F","decl":"/-- Dual to `Monad.ReflectsColimitOfIsSplitPair`. -/\nclass ReflectsLimitOfIsCosplitPair (F : C ⥤ D) where\n  /-- If `f, g` is an `F`-cosplit pair, then `F` reflects limits for `parallelPair f g`. -/\n  out : ∀ {A B} (f g : A ⟶ B) [F.IsCosplitPair f g], ReflectsLimit (parallelPair f g) F\n\n"}
{"name":"CategoryTheory.Comonad.instReflectsLimitWalkingParallelPairParallelPairOfIsCosplitPairOfReflectsLimitOfIsCosplitPair","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nA B : C\nf g : Quiver.Hom A B\ninst✝¹ : F.IsCosplitPair f g\ninst✝ : CategoryTheory.Comonad.ReflectsLimitOfIsCosplitPair F\n⊢ CategoryTheory.Limits.ReflectsLimit (CategoryTheory.Limits.parallelPair f g) F","decl":"instance {A B} (f g : A ⟶ B) [F.IsCosplitPair f g] [ReflectsLimitOfIsCosplitPair F] :\n    ReflectsLimit (parallelPair f g) F := ReflectsLimitOfIsCosplitPair.out f g\n\n"}
{"name":"CategoryTheory.Comonad.instReflectsLimitWalkingParallelPairParallelPairMapAAppUnitObjAOfReflectsLimitOfIsCosplitPair","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : CategoryTheory.Comonad.ReflectsLimitOfIsCosplitPair F\nA : adj.toComonad.Coalgebra\n⊢ CategoryTheory.Limits.ReflectsLimit (CategoryTheory.Limits.parallelPair (G.map A.a) (adj.unit.app (G.obj A.A))) F","decl":"instance [ReflectsLimitOfIsCosplitPair F] : ∀ (A : Coalgebra adj.toComonad),\n    ReflectsLimit (parallelPair (G.map A.a)\n      (NatTrans.app adj.unit (G.obj A.A))) F :=\n  fun _ => ReflectsLimitOfIsCosplitPair.out _ _\n\n"}
{"name":"CategoryTheory.Comonad.PreservesLimitOfIsCoreflexivePair.out","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Comonad.PreservesLimitOfIsCoreflexivePair F\nA B : C\nf g : Quiver.Hom A B\ninst✝ : CategoryTheory.IsCoreflexivePair f g\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f g) F","decl":"/-- Dual to `Monad.PreservesColimitOfIsReflexivePair`. -/\nclass PreservesLimitOfIsCoreflexivePair (F : C ⥤ D) where\n  /-- `f, g` is a coreflexive pair, then `F` preserves limits of `parallelPair f g`. -/\n  out : ∀ ⦃A B⦄ (f g : A ⟶ B) [IsCoreflexivePair f g], PreservesLimit (parallelPair f g) F\n\n"}
{"name":"CategoryTheory.Comonad.instPreservesLimitWalkingParallelPairParallelPairOfIsCoreflexivePairOfPreservesLimitOfIsCoreflexivePair","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nA B : C\nf g : Quiver.Hom A B\ninst✝¹ : CategoryTheory.IsCoreflexivePair f g\ninst✝ : CategoryTheory.Comonad.PreservesLimitOfIsCoreflexivePair F\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f g) F","decl":"instance {A B} (f g : A ⟶ B) [IsCoreflexivePair f g] [PreservesLimitOfIsCoreflexivePair F] :\n  PreservesLimit (parallelPair f g) F := PreservesLimitOfIsCoreflexivePair.out f g\n\n"}
{"name":"CategoryTheory.Comonad.instPreservesLimitWalkingParallelPairParallelPairMapAAppUnitObjAOfPreservesLimitOfIsCoreflexivePair","module":"Mathlib.CategoryTheory.Monad.Comonadicity","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.Category.{v₁, u₂} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : CategoryTheory.Comonad.PreservesLimitOfIsCoreflexivePair F\nX : adj.toComonad.Coalgebra\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair (G.map X.a) (adj.unit.app (G.obj X.A))) F","decl":"instance [PreservesLimitOfIsCoreflexivePair F] : ∀ X : Coalgebra adj.toComonad,\n    PreservesLimit (parallelPair (G.map X.a)\n      (NatTrans.app adj.unit (G.obj X.A))) F :=\n fun _ => PreservesLimitOfIsCoreflexivePair.out _ _\n\n"}
