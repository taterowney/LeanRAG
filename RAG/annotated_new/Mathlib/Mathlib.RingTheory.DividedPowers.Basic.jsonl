{"name":"DividedPowers.dpow_comp","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\nself : DividedPowers I\nm n : Nat\nx : A\nx✝¹ : Ne n 0\nx✝ : Membership.mem I x\n⊢ Eq (self.dpow m (self.dpow n x)) (HMul.hMul (↑(m.uniformBell n)) (self.dpow (HMul.hMul m n) x))","decl":"/-- The divided power structure on an ideal I of a commutative ring A -/\nstructure DividedPowers where\n  /-- The divided power function underlying a divided power structure -/\n  dpow : ℕ → A → A\n  dpow_null : ∀ {n x} (_ : x ∉ I), dpow n x = 0\n  dpow_zero : ∀ {x} (_ : x ∈ I), dpow 0 x = 1\n  dpow_one : ∀ {x} (_ : x ∈ I), dpow 1 x = x\n  dpow_mem : ∀ {n x} (_ : n ≠ 0) (_ : x ∈ I), dpow n x ∈ I\n  dpow_add : ∀ (n) {x y} (_ : x ∈ I) (_ : y ∈ I),\n    dpow n (x + y) = (antidiagonal n).sum fun k ↦ dpow k.1 x * dpow k.2 y\n  dpow_mul : ∀ (n) {a : A} {x} (_ : x ∈ I),\n    dpow n (a * x) = a ^ n * dpow n x\n  mul_dpow : ∀ (m n) {x} (_ : x ∈ I),\n    dpow m x * dpow n x = choose (m + n) m * dpow (m + n) x\n  dpow_comp : ∀ (m) {n x} (_ : n ≠ 0) (_ : x ∈ I),\n    dpow m (dpow n x) = uniformBell m n * dpow (m * n) x\n\n"}
{"name":"DividedPowers.mk.sizeOf_spec","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝¹ : CommSemiring A\nI : Ideal A\ninst✝ : SizeOf A\ndpow : Nat → A → A\ndpow_null : ∀ {n : Nat} {x : A}, Not (Membership.mem I x) → Eq (dpow n x) 0\ndpow_zero : ∀ {x : A}, Membership.mem I x → Eq (dpow 0 x) 1\ndpow_one : ∀ {x : A}, Membership.mem I x → Eq (dpow 1 x) x\ndpow_mem : ∀ {n : Nat} {x : A}, Ne n 0 → Membership.mem I x → Membership.mem I (dpow n x)\ndpow_add : ∀ (n : Nat) {x y : A}, Membership.mem I x → Membership.mem I y → Eq (dpow n (HAdd.hAdd x y)) ((Finset.HasAntidiagonal.antidiagonal n).sum fun k => HMul.hMul (dpow k.1 x) (dpow k.2 y))\ndpow_mul : ∀ (n : Nat) {a x : A}, Membership.mem I x → Eq (dpow n (HMul.hMul a x)) (HMul.hMul (HPow.hPow a n) (dpow n x))\nmul_dpow : ∀ (m n : Nat) {x : A}, Membership.mem I x → Eq (HMul.hMul (dpow m x) (dpow n x)) (HMul.hMul (↑((HAdd.hAdd m n).choose m)) (dpow (HAdd.hAdd m n) x))\ndpow_comp : ∀ (m : Nat) {n : Nat} {x : A}, Ne n 0 → Membership.mem I x → Eq (dpow m (dpow n x)) (HMul.hMul (↑(m.uniformBell n)) (dpow (HMul.hMul m n) x))\n⊢ Eq (SizeOf.sizeOf { dpow := dpow, dpow_null := dpow_null, dpow_zero := dpow_zero, dpow_one := dpow_one, dpow_mem := dpow_mem, dpow_add := dpow_add, dpow_mul := dpow_mul, mul_dpow := mul_dpow, dpow_comp := dpow_comp }) 1","decl":"/-- The divided power structure on an ideal I of a commutative ring A -/\nstructure DividedPowers where\n  /-- The divided power function underlying a divided power structure -/\n  dpow : ℕ → A → A\n  dpow_null : ∀ {n x} (_ : x ∉ I), dpow n x = 0\n  dpow_zero : ∀ {x} (_ : x ∈ I), dpow 0 x = 1\n  dpow_one : ∀ {x} (_ : x ∈ I), dpow 1 x = x\n  dpow_mem : ∀ {n x} (_ : n ≠ 0) (_ : x ∈ I), dpow n x ∈ I\n  dpow_add : ∀ (n) {x y} (_ : x ∈ I) (_ : y ∈ I),\n    dpow n (x + y) = (antidiagonal n).sum fun k ↦ dpow k.1 x * dpow k.2 y\n  dpow_mul : ∀ (n) {a : A} {x} (_ : x ∈ I),\n    dpow n (a * x) = a ^ n * dpow n x\n  mul_dpow : ∀ (m n) {x} (_ : x ∈ I),\n    dpow m x * dpow n x = choose (m + n) m * dpow (m + n) x\n  dpow_comp : ∀ (m) {n x} (_ : n ≠ 0) (_ : x ∈ I),\n    dpow m (dpow n x) = uniformBell m n * dpow (m * n) x\n\n"}
{"name":"DividedPowers.dpow_add","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\nself : DividedPowers I\nn : Nat\nx y : A\nx✝¹ : Membership.mem I x\nx✝ : Membership.mem I y\n⊢ Eq (self.dpow n (HAdd.hAdd x y)) ((Finset.HasAntidiagonal.antidiagonal n).sum fun k => HMul.hMul (self.dpow k.1 x) (self.dpow k.2 y))","decl":"/-- The divided power structure on an ideal I of a commutative ring A -/\nstructure DividedPowers where\n  /-- The divided power function underlying a divided power structure -/\n  dpow : ℕ → A → A\n  dpow_null : ∀ {n x} (_ : x ∉ I), dpow n x = 0\n  dpow_zero : ∀ {x} (_ : x ∈ I), dpow 0 x = 1\n  dpow_one : ∀ {x} (_ : x ∈ I), dpow 1 x = x\n  dpow_mem : ∀ {n x} (_ : n ≠ 0) (_ : x ∈ I), dpow n x ∈ I\n  dpow_add : ∀ (n) {x y} (_ : x ∈ I) (_ : y ∈ I),\n    dpow n (x + y) = (antidiagonal n).sum fun k ↦ dpow k.1 x * dpow k.2 y\n  dpow_mul : ∀ (n) {a : A} {x} (_ : x ∈ I),\n    dpow n (a * x) = a ^ n * dpow n x\n  mul_dpow : ∀ (m n) {x} (_ : x ∈ I),\n    dpow m x * dpow n x = choose (m + n) m * dpow (m + n) x\n  dpow_comp : ∀ (m) {n x} (_ : n ≠ 0) (_ : x ∈ I),\n    dpow m (dpow n x) = uniformBell m n * dpow (m * n) x\n\n"}
{"name":"DividedPowers.dpow_one","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\nself : DividedPowers I\nx : A\nx✝ : Membership.mem I x\n⊢ Eq (self.dpow 1 x) x","decl":"/-- The divided power structure on an ideal I of a commutative ring A -/\nstructure DividedPowers where\n  /-- The divided power function underlying a divided power structure -/\n  dpow : ℕ → A → A\n  dpow_null : ∀ {n x} (_ : x ∉ I), dpow n x = 0\n  dpow_zero : ∀ {x} (_ : x ∈ I), dpow 0 x = 1\n  dpow_one : ∀ {x} (_ : x ∈ I), dpow 1 x = x\n  dpow_mem : ∀ {n x} (_ : n ≠ 0) (_ : x ∈ I), dpow n x ∈ I\n  dpow_add : ∀ (n) {x y} (_ : x ∈ I) (_ : y ∈ I),\n    dpow n (x + y) = (antidiagonal n).sum fun k ↦ dpow k.1 x * dpow k.2 y\n  dpow_mul : ∀ (n) {a : A} {x} (_ : x ∈ I),\n    dpow n (a * x) = a ^ n * dpow n x\n  mul_dpow : ∀ (m n) {x} (_ : x ∈ I),\n    dpow m x * dpow n x = choose (m + n) m * dpow (m + n) x\n  dpow_comp : ∀ (m) {n x} (_ : n ≠ 0) (_ : x ∈ I),\n    dpow m (dpow n x) = uniformBell m n * dpow (m * n) x\n\n"}
{"name":"DividedPowers.mk.inj","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\ndpow✝ : Nat → A → A\ndpow_null✝ : ∀ {n : Nat} {x : A}, Not (Membership.mem I x) → Eq (dpow✝ n x) 0\ndpow_zero✝ : ∀ {x : A}, Membership.mem I x → Eq (dpow✝ 0 x) 1\ndpow_one✝ : ∀ {x : A}, Membership.mem I x → Eq (dpow✝ 1 x) x\ndpow_mem✝ : ∀ {n : Nat} {x : A}, Ne n 0 → Membership.mem I x → Membership.mem I (dpow✝ n x)\ndpow_add✝ : ∀ (n : Nat) {x y : A}, Membership.mem I x → Membership.mem I y → Eq (dpow✝ n (HAdd.hAdd x y)) ((Finset.HasAntidiagonal.antidiagonal n).sum fun k => HMul.hMul (dpow✝ k.1 x) (dpow✝ k.2 y))\ndpow_mul✝ : ∀ (n : Nat) {a x : A}, Membership.mem I x → Eq (dpow✝ n (HMul.hMul a x)) (HMul.hMul (HPow.hPow a n) (dpow✝ n x))\nmul_dpow✝ : ∀ (m n : Nat) {x : A}, Membership.mem I x → Eq (HMul.hMul (dpow✝ m x) (dpow✝ n x)) (HMul.hMul (↑((HAdd.hAdd m n).choose m)) (dpow✝ (HAdd.hAdd m n) x))\ndpow_comp✝ : ∀ (m : Nat) {n : Nat} {x : A}, Ne n 0 → Membership.mem I x → Eq (dpow✝ m (dpow✝ n x)) (HMul.hMul (↑(m.uniformBell n)) (dpow✝ (HMul.hMul m n) x))\ndpow : Nat → A → A\ndpow_null : ∀ {n : Nat} {x : A}, Not (Membership.mem I x) → Eq (dpow n x) 0\ndpow_zero : ∀ {x : A}, Membership.mem I x → Eq (dpow 0 x) 1\ndpow_one : ∀ {x : A}, Membership.mem I x → Eq (dpow 1 x) x\ndpow_mem : ∀ {n : Nat} {x : A}, Ne n 0 → Membership.mem I x → Membership.mem I (dpow n x)\ndpow_add : ∀ (n : Nat) {x y : A}, Membership.mem I x → Membership.mem I y → Eq (dpow n (HAdd.hAdd x y)) ((Finset.HasAntidiagonal.antidiagonal n).sum fun k => HMul.hMul (dpow k.1 x) (dpow k.2 y))\ndpow_mul : ∀ (n : Nat) {a x : A}, Membership.mem I x → Eq (dpow n (HMul.hMul a x)) (HMul.hMul (HPow.hPow a n) (dpow n x))\nmul_dpow : ∀ (m n : Nat) {x : A}, Membership.mem I x → Eq (HMul.hMul (dpow m x) (dpow n x)) (HMul.hMul (↑((HAdd.hAdd m n).choose m)) (dpow (HAdd.hAdd m n) x))\ndpow_comp : ∀ (m : Nat) {n : Nat} {x : A}, Ne n 0 → Membership.mem I x → Eq (dpow m (dpow n x)) (HMul.hMul (↑(m.uniformBell n)) (dpow (HMul.hMul m n) x))\nx✝ : Eq { dpow := dpow✝, dpow_null := dpow_null✝, dpow_zero := dpow_zero✝, dpow_one := dpow_one✝, dpow_mem := dpow_mem✝, dpow_add := dpow_add✝, dpow_mul := dpow_mul✝, mul_dpow := mul_dpow✝, dpow_comp := dpow_comp✝ } { dpow := dpow, dpow_null := dpow_null, dpow_zero := dpow_zero, dpow_one := dpow_one, dpow_mem := dpow_mem, dpow_add := dpow_add, dpow_mul := dpow_mul, mul_dpow := mul_dpow, dpow_comp := dpow_comp }\n⊢ Eq dpow✝ dpow","decl":"/-- The divided power structure on an ideal I of a commutative ring A -/\nstructure DividedPowers where\n  /-- The divided power function underlying a divided power structure -/\n  dpow : ℕ → A → A\n  dpow_null : ∀ {n x} (_ : x ∉ I), dpow n x = 0\n  dpow_zero : ∀ {x} (_ : x ∈ I), dpow 0 x = 1\n  dpow_one : ∀ {x} (_ : x ∈ I), dpow 1 x = x\n  dpow_mem : ∀ {n x} (_ : n ≠ 0) (_ : x ∈ I), dpow n x ∈ I\n  dpow_add : ∀ (n) {x y} (_ : x ∈ I) (_ : y ∈ I),\n    dpow n (x + y) = (antidiagonal n).sum fun k ↦ dpow k.1 x * dpow k.2 y\n  dpow_mul : ∀ (n) {a : A} {x} (_ : x ∈ I),\n    dpow n (a * x) = a ^ n * dpow n x\n  mul_dpow : ∀ (m n) {x} (_ : x ∈ I),\n    dpow m x * dpow n x = choose (m + n) m * dpow (m + n) x\n  dpow_comp : ∀ (m) {n x} (_ : n ≠ 0) (_ : x ∈ I),\n    dpow m (dpow n x) = uniformBell m n * dpow (m * n) x\n\n"}
{"name":"DividedPowers.dpow_zero","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\nself : DividedPowers I\nx : A\nx✝ : Membership.mem I x\n⊢ Eq (self.dpow 0 x) 1","decl":"/-- The divided power structure on an ideal I of a commutative ring A -/\nstructure DividedPowers where\n  /-- The divided power function underlying a divided power structure -/\n  dpow : ℕ → A → A\n  dpow_null : ∀ {n x} (_ : x ∉ I), dpow n x = 0\n  dpow_zero : ∀ {x} (_ : x ∈ I), dpow 0 x = 1\n  dpow_one : ∀ {x} (_ : x ∈ I), dpow 1 x = x\n  dpow_mem : ∀ {n x} (_ : n ≠ 0) (_ : x ∈ I), dpow n x ∈ I\n  dpow_add : ∀ (n) {x y} (_ : x ∈ I) (_ : y ∈ I),\n    dpow n (x + y) = (antidiagonal n).sum fun k ↦ dpow k.1 x * dpow k.2 y\n  dpow_mul : ∀ (n) {a : A} {x} (_ : x ∈ I),\n    dpow n (a * x) = a ^ n * dpow n x\n  mul_dpow : ∀ (m n) {x} (_ : x ∈ I),\n    dpow m x * dpow n x = choose (m + n) m * dpow (m + n) x\n  dpow_comp : ∀ (m) {n x} (_ : n ≠ 0) (_ : x ∈ I),\n    dpow m (dpow n x) = uniformBell m n * dpow (m * n) x\n\n"}
{"name":"DividedPowers.dpow_mem","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\nself : DividedPowers I\nn : Nat\nx : A\nx✝¹ : Ne n 0\nx✝ : Membership.mem I x\n⊢ Membership.mem I (self.dpow n x)","decl":"/-- The divided power structure on an ideal I of a commutative ring A -/\nstructure DividedPowers where\n  /-- The divided power function underlying a divided power structure -/\n  dpow : ℕ → A → A\n  dpow_null : ∀ {n x} (_ : x ∉ I), dpow n x = 0\n  dpow_zero : ∀ {x} (_ : x ∈ I), dpow 0 x = 1\n  dpow_one : ∀ {x} (_ : x ∈ I), dpow 1 x = x\n  dpow_mem : ∀ {n x} (_ : n ≠ 0) (_ : x ∈ I), dpow n x ∈ I\n  dpow_add : ∀ (n) {x y} (_ : x ∈ I) (_ : y ∈ I),\n    dpow n (x + y) = (antidiagonal n).sum fun k ↦ dpow k.1 x * dpow k.2 y\n  dpow_mul : ∀ (n) {a : A} {x} (_ : x ∈ I),\n    dpow n (a * x) = a ^ n * dpow n x\n  mul_dpow : ∀ (m n) {x} (_ : x ∈ I),\n    dpow m x * dpow n x = choose (m + n) m * dpow (m + n) x\n  dpow_comp : ∀ (m) {n x} (_ : n ≠ 0) (_ : x ∈ I),\n    dpow m (dpow n x) = uniformBell m n * dpow (m * n) x\n\n"}
{"name":"DividedPowers.mk.injEq","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\ndpow✝ : Nat → A → A\ndpow_null✝ : ∀ {n : Nat} {x : A}, Not (Membership.mem I x) → Eq (dpow✝ n x) 0\ndpow_zero✝ : ∀ {x : A}, Membership.mem I x → Eq (dpow✝ 0 x) 1\ndpow_one✝ : ∀ {x : A}, Membership.mem I x → Eq (dpow✝ 1 x) x\ndpow_mem✝ : ∀ {n : Nat} {x : A}, Ne n 0 → Membership.mem I x → Membership.mem I (dpow✝ n x)\ndpow_add✝ : ∀ (n : Nat) {x y : A}, Membership.mem I x → Membership.mem I y → Eq (dpow✝ n (HAdd.hAdd x y)) ((Finset.HasAntidiagonal.antidiagonal n).sum fun k => HMul.hMul (dpow✝ k.1 x) (dpow✝ k.2 y))\ndpow_mul✝ : ∀ (n : Nat) {a x : A}, Membership.mem I x → Eq (dpow✝ n (HMul.hMul a x)) (HMul.hMul (HPow.hPow a n) (dpow✝ n x))\nmul_dpow✝ : ∀ (m n : Nat) {x : A}, Membership.mem I x → Eq (HMul.hMul (dpow✝ m x) (dpow✝ n x)) (HMul.hMul (↑((HAdd.hAdd m n).choose m)) (dpow✝ (HAdd.hAdd m n) x))\ndpow_comp✝ : ∀ (m : Nat) {n : Nat} {x : A}, Ne n 0 → Membership.mem I x → Eq (dpow✝ m (dpow✝ n x)) (HMul.hMul (↑(m.uniformBell n)) (dpow✝ (HMul.hMul m n) x))\ndpow : Nat → A → A\ndpow_null : ∀ {n : Nat} {x : A}, Not (Membership.mem I x) → Eq (dpow n x) 0\ndpow_zero : ∀ {x : A}, Membership.mem I x → Eq (dpow 0 x) 1\ndpow_one : ∀ {x : A}, Membership.mem I x → Eq (dpow 1 x) x\ndpow_mem : ∀ {n : Nat} {x : A}, Ne n 0 → Membership.mem I x → Membership.mem I (dpow n x)\ndpow_add : ∀ (n : Nat) {x y : A}, Membership.mem I x → Membership.mem I y → Eq (dpow n (HAdd.hAdd x y)) ((Finset.HasAntidiagonal.antidiagonal n).sum fun k => HMul.hMul (dpow k.1 x) (dpow k.2 y))\ndpow_mul : ∀ (n : Nat) {a x : A}, Membership.mem I x → Eq (dpow n (HMul.hMul a x)) (HMul.hMul (HPow.hPow a n) (dpow n x))\nmul_dpow : ∀ (m n : Nat) {x : A}, Membership.mem I x → Eq (HMul.hMul (dpow m x) (dpow n x)) (HMul.hMul (↑((HAdd.hAdd m n).choose m)) (dpow (HAdd.hAdd m n) x))\ndpow_comp : ∀ (m : Nat) {n : Nat} {x : A}, Ne n 0 → Membership.mem I x → Eq (dpow m (dpow n x)) (HMul.hMul (↑(m.uniformBell n)) (dpow (HMul.hMul m n) x))\n⊢ Eq (Eq { dpow := dpow✝, dpow_null := dpow_null✝, dpow_zero := dpow_zero✝, dpow_one := dpow_one✝, dpow_mem := dpow_mem✝, dpow_add := dpow_add✝, dpow_mul := dpow_mul✝, mul_dpow := mul_dpow✝, dpow_comp := dpow_comp✝ } { dpow := dpow, dpow_null := dpow_null, dpow_zero := dpow_zero, dpow_one := dpow_one, dpow_mem := dpow_mem, dpow_add := dpow_add, dpow_mul := dpow_mul, mul_dpow := mul_dpow, dpow_comp := dpow_comp }) (Eq dpow✝ dpow)","decl":"/-- The divided power structure on an ideal I of a commutative ring A -/\nstructure DividedPowers where\n  /-- The divided power function underlying a divided power structure -/\n  dpow : ℕ → A → A\n  dpow_null : ∀ {n x} (_ : x ∉ I), dpow n x = 0\n  dpow_zero : ∀ {x} (_ : x ∈ I), dpow 0 x = 1\n  dpow_one : ∀ {x} (_ : x ∈ I), dpow 1 x = x\n  dpow_mem : ∀ {n x} (_ : n ≠ 0) (_ : x ∈ I), dpow n x ∈ I\n  dpow_add : ∀ (n) {x y} (_ : x ∈ I) (_ : y ∈ I),\n    dpow n (x + y) = (antidiagonal n).sum fun k ↦ dpow k.1 x * dpow k.2 y\n  dpow_mul : ∀ (n) {a : A} {x} (_ : x ∈ I),\n    dpow n (a * x) = a ^ n * dpow n x\n  mul_dpow : ∀ (m n) {x} (_ : x ∈ I),\n    dpow m x * dpow n x = choose (m + n) m * dpow (m + n) x\n  dpow_comp : ∀ (m) {n x} (_ : n ≠ 0) (_ : x ∈ I),\n    dpow m (dpow n x) = uniformBell m n * dpow (m * n) x\n\n"}
{"name":"DividedPowers.dpow_mul","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\nself : DividedPowers I\nn : Nat\na x : A\nx✝ : Membership.mem I x\n⊢ Eq (self.dpow n (HMul.hMul a x)) (HMul.hMul (HPow.hPow a n) (self.dpow n x))","decl":"/-- The divided power structure on an ideal I of a commutative ring A -/\nstructure DividedPowers where\n  /-- The divided power function underlying a divided power structure -/\n  dpow : ℕ → A → A\n  dpow_null : ∀ {n x} (_ : x ∉ I), dpow n x = 0\n  dpow_zero : ∀ {x} (_ : x ∈ I), dpow 0 x = 1\n  dpow_one : ∀ {x} (_ : x ∈ I), dpow 1 x = x\n  dpow_mem : ∀ {n x} (_ : n ≠ 0) (_ : x ∈ I), dpow n x ∈ I\n  dpow_add : ∀ (n) {x y} (_ : x ∈ I) (_ : y ∈ I),\n    dpow n (x + y) = (antidiagonal n).sum fun k ↦ dpow k.1 x * dpow k.2 y\n  dpow_mul : ∀ (n) {a : A} {x} (_ : x ∈ I),\n    dpow n (a * x) = a ^ n * dpow n x\n  mul_dpow : ∀ (m n) {x} (_ : x ∈ I),\n    dpow m x * dpow n x = choose (m + n) m * dpow (m + n) x\n  dpow_comp : ∀ (m) {n x} (_ : n ≠ 0) (_ : x ∈ I),\n    dpow m (dpow n x) = uniformBell m n * dpow (m * n) x\n\n"}
{"name":"DividedPowers.mul_dpow","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\nself : DividedPowers I\nm n : Nat\nx : A\nx✝ : Membership.mem I x\n⊢ Eq (HMul.hMul (self.dpow m x) (self.dpow n x)) (HMul.hMul (↑((HAdd.hAdd m n).choose m)) (self.dpow (HAdd.hAdd m n) x))","decl":"/-- The divided power structure on an ideal I of a commutative ring A -/\nstructure DividedPowers where\n  /-- The divided power function underlying a divided power structure -/\n  dpow : ℕ → A → A\n  dpow_null : ∀ {n x} (_ : x ∉ I), dpow n x = 0\n  dpow_zero : ∀ {x} (_ : x ∈ I), dpow 0 x = 1\n  dpow_one : ∀ {x} (_ : x ∈ I), dpow 1 x = x\n  dpow_mem : ∀ {n x} (_ : n ≠ 0) (_ : x ∈ I), dpow n x ∈ I\n  dpow_add : ∀ (n) {x y} (_ : x ∈ I) (_ : y ∈ I),\n    dpow n (x + y) = (antidiagonal n).sum fun k ↦ dpow k.1 x * dpow k.2 y\n  dpow_mul : ∀ (n) {a : A} {x} (_ : x ∈ I),\n    dpow n (a * x) = a ^ n * dpow n x\n  mul_dpow : ∀ (m n) {x} (_ : x ∈ I),\n    dpow m x * dpow n x = choose (m + n) m * dpow (m + n) x\n  dpow_comp : ∀ (m) {n x} (_ : n ≠ 0) (_ : x ∈ I),\n    dpow m (dpow n x) = uniformBell m n * dpow (m * n) x\n\n"}
{"name":"DividedPowers.dpow_null","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\nself : DividedPowers I\nn : Nat\nx : A\nx✝ : Not (Membership.mem I x)\n⊢ Eq (self.dpow n x) 0","decl":"/-- The divided power structure on an ideal I of a commutative ring A -/\nstructure DividedPowers where\n  /-- The divided power function underlying a divided power structure -/\n  dpow : ℕ → A → A\n  dpow_null : ∀ {n x} (_ : x ∉ I), dpow n x = 0\n  dpow_zero : ∀ {x} (_ : x ∈ I), dpow 0 x = 1\n  dpow_one : ∀ {x} (_ : x ∈ I), dpow 1 x = x\n  dpow_mem : ∀ {n x} (_ : n ≠ 0) (_ : x ∈ I), dpow n x ∈ I\n  dpow_add : ∀ (n) {x y} (_ : x ∈ I) (_ : y ∈ I),\n    dpow n (x + y) = (antidiagonal n).sum fun k ↦ dpow k.1 x * dpow k.2 y\n  dpow_mul : ∀ (n) {a : A} {x} (_ : x ∈ I),\n    dpow n (a * x) = a ^ n * dpow n x\n  mul_dpow : ∀ (m n) {x} (_ : x ∈ I),\n    dpow m x * dpow n x = choose (m + n) m * dpow (m + n) x\n  dpow_comp : ∀ (m) {n x} (_ : n ≠ 0) (_ : x ∈ I),\n    dpow m (dpow n x) = uniformBell m n * dpow (m * n) x\n\n"}
{"name":"DividedPowers.ext_iff","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\nhI hI' : DividedPowers I\n⊢ Iff (Eq hI hI') (∀ (n : Nat) {x : A}, Membership.mem I x → Eq (hI.dpow n x) (hI'.dpow n x))","decl":"variable {I} in\n@[ext]\ntheorem DividedPowers.ext (hI : DividedPowers I) (hI' : DividedPowers I)\n    (h_eq : ∀ (n : ℕ) {x : A} (_ : x ∈ I), hI.dpow n x = hI'.dpow n x) :\n    hI = hI' := by\n  obtain ⟨hI, h₀, _⟩ := hI\n  obtain ⟨hI', h₀', _⟩ := hI'\n  simp only [mk.injEq]\n  ext n x\n  by_cases hx : x ∈ I\n  · exact h_eq n hx\n  · rw [h₀ hx, h₀' hx]\n\n"}
{"name":"DividedPowers.ext","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\nhI hI' : DividedPowers I\nh_eq : ∀ (n : Nat) {x : A}, Membership.mem I x → Eq (hI.dpow n x) (hI'.dpow n x)\n⊢ Eq hI hI'","decl":"variable {I} in\n@[ext]\ntheorem DividedPowers.ext (hI : DividedPowers I) (hI' : DividedPowers I)\n    (h_eq : ∀ (n : ℕ) {x : A} (_ : x ∈ I), hI.dpow n x = hI'.dpow n x) :\n    hI = hI' := by\n  obtain ⟨hI, h₀, _⟩ := hI\n  obtain ⟨hI', h₀', _⟩ := hI'\n  simp only [mk.injEq]\n  ext n x\n  by_cases hx : x ∈ I\n  · exact h_eq n hx\n  · rw [h₀ hx, h₀' hx]\n\n"}
{"name":"DividedPowers.coe_injective","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\n⊢ Function.Injective fun h => h.dpow","decl":"theorem DividedPowers.coe_injective :\n    Function.Injective (fun (h : DividedPowers I) ↦ (h : ℕ → A → A)) := fun hI hI' h ↦ by\n  ext n x\n  exact congr_fun (congr_fun h n) x\n\n"}
{"name":"DividedPowers.dpow_add'","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\na b : A\nhI : DividedPowers I\nn : Nat\nha : Membership.mem I a\nhb : Membership.mem I b\n⊢ Eq (hI.dpow n (HAdd.hAdd a b)) ((Finset.range (HAdd.hAdd n 1)).sum fun k => HMul.hMul (hI.dpow k a) (hI.dpow (HSub.hSub n k) b))","decl":"/-- Variant of `DividedPowers.dpow_add` with a sum on `range (n + 1)` -/\ntheorem dpow_add' (hI : DividedPowers I) (n : ℕ) (ha : a ∈ I) (hb : b ∈ I) :\n    hI.dpow n (a + b) = (range (n + 1)).sum fun k ↦ hI.dpow k a * hI.dpow (n - k) b := by\n  rw [hI.dpow_add n ha hb, sum_antidiagonal_eq_sum_range_succ_mk]\n\n"}
{"name":"DividedPowers.exp_add'","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\na b : A\ndp : Nat → A → A\ndp_add : ∀ (n : Nat), Eq (dp n (HAdd.hAdd a b)) ((Finset.HasAntidiagonal.antidiagonal n).sum fun k => HMul.hMul (dp k.1 a) (dp k.2 b))\n⊢ Eq (PowerSeries.mk fun n => dp n (HAdd.hAdd a b)) (HMul.hMul (PowerSeries.mk fun n => dp n a) (PowerSeries.mk fun n => dp n b))","decl":"/-- A more general of `DividedPowers.exp_add` -/\ntheorem exp_add' (dp : ℕ → A → A)\n    (dp_add : ∀ n, dp n (a + b) = (antidiagonal n).sum fun k ↦ dp k.1 a * dp k.2 b) :\n    PowerSeries.mk (fun n ↦ dp n (a + b)) =\n      (PowerSeries.mk fun n ↦ dp n a) * (PowerSeries.mk fun n ↦ dp n b) := by\n  ext n\n  simp only [exp, PowerSeries.coeff_mk, PowerSeries.coeff_mul, dp_add n,\n    sum_antidiagonal_eq_sum_range_succ_mk]\n\n"}
{"name":"DividedPowers.exp_add","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\na b : A\nhI : DividedPowers I\nha : Membership.mem I a\nhb : Membership.mem I b\n⊢ Eq (hI.exp (HAdd.hAdd a b)) (HMul.hMul (hI.exp a) (hI.exp b))","decl":"theorem exp_add (hI : DividedPowers I) (ha : a ∈ I) (hb : b ∈ I) :\n    hI.exp (a + b) = hI.exp a * hI.exp b :=\n  exp_add' _ (fun n ↦ hI.dpow_add n ha hb)\n\n"}
{"name":"DividedPowers.dpow_smul","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\na b : A\nhI : DividedPowers I\nn : Nat\nha : Membership.mem I a\n⊢ Eq (hI.dpow n (HSMul.hSMul b a)) (HSMul.hSMul (HPow.hPow b n) (hI.dpow n a))","decl":"theorem dpow_smul (n : ℕ) (ha : a ∈ I) :\n    hI.dpow n (b • a) = b ^ n • hI.dpow n a := by\n  simp only [smul_eq_mul, hI.dpow_mul, ha]\n\n"}
{"name":"DividedPowers.dpow_mul_right","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\na b : A\nhI : DividedPowers I\nn : Nat\nha : Membership.mem I a\n⊢ Eq (hI.dpow n (HMul.hMul a b)) (HMul.hMul (hI.dpow n a) (HPow.hPow b n))","decl":"theorem dpow_mul_right (n : ℕ) (ha : a ∈ I) :\n    hI.dpow n (a * b) = hI.dpow n a * b ^ n := by\n  rw [mul_comm, hI.dpow_mul n ha, mul_comm]\n\n"}
{"name":"DividedPowers.dpow_smul_right","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\na b : A\nhI : DividedPowers I\nn : Nat\nha : Membership.mem I a\n⊢ Eq (hI.dpow n (HSMul.hSMul a b)) (HSMul.hSMul (hI.dpow n a) (HPow.hPow b n))","decl":"theorem dpow_smul_right (n : ℕ) (ha : a ∈ I) :\n    hI.dpow n (a • b) = hI.dpow n a • b ^ n := by\n  rw [smul_eq_mul, hI.dpow_mul_right n ha, smul_eq_mul]\n\n"}
{"name":"DividedPowers.factorial_mul_dpow_eq_pow","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\na : A\nhI : DividedPowers I\nn : Nat\nha : Membership.mem I a\n⊢ Eq (HMul.hMul (↑n.factorial) (hI.dpow n a)) (HPow.hPow a n)","decl":"theorem factorial_mul_dpow_eq_pow (n : ℕ) (ha : a ∈ I) :\n    (n ! : A) * hI.dpow n a = a ^ n := by\n  induction n with\n  | zero => rw [factorial_zero, cast_one, one_mul, pow_zero, hI.dpow_zero ha]\n  | succ n ih =>\n    rw [factorial_succ, mul_comm (n + 1)]\n    nth_rewrite 1 [← (n + 1).choose_one_right]\n    rw [← choose_symm_add, cast_mul, mul_assoc,\n      ← hI.mul_dpow n 1 ha, ← mul_assoc, ih, hI.dpow_one ha, pow_succ, mul_comm]\n\n"}
{"name":"DividedPowers.dpow_eval_zero","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\nhI : DividedPowers I\nn : Nat\nhn : Ne n 0\n⊢ Eq (hI.dpow n 0) 0","decl":"theorem dpow_eval_zero {n : ℕ} (hn : n ≠ 0) : hI.dpow n 0 = 0 := by\n  rw [← MulZeroClass.mul_zero (0 : A), hI.dpow_mul n I.zero_mem,\n    zero_pow hn, zero_mul, zero_mul]\n\n"}
{"name":"DividedPowers.nilpotent_of_mem_dpIdeal","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\na : A\nn : Nat\nhn : Ne n 0\nhnI : ∀ {y : A}, Membership.mem I y → Eq (HSMul.hSMul n y) 0\nhI : DividedPowers I\nha : Membership.mem I a\n⊢ Eq (HPow.hPow a n) 0","decl":"/-- If an element of a divided power ideal is killed by multiplication\nby some nonzero integer `n`, then its `n`th power is zero.\n\nProposition 1.2.7 of [Berthelot-1974], part (i). -/\ntheorem nilpotent_of_mem_dpIdeal {n : ℕ} (hn : n ≠ 0) (hnI : ∀ {y} (_ : y ∈ I), n • y = 0)\n    (hI : DividedPowers I) (ha : a ∈ I) : a ^ n = 0 := by\n  have h_fac : (n ! : A) * hI.dpow n a =\n    n • ((n - 1)! : A) * hI.dpow n a := by\n    rw [nsmul_eq_mul, ← cast_mul, mul_factorial_pred (Nat.pos_of_ne_zero hn)]\n  rw [← hI.factorial_mul_dpow_eq_pow n ha, h_fac, smul_mul_assoc]\n  exact hnI (I.mul_mem_left ((n - 1)! : A) (hI.dpow_mem hn ha))\n\n"}
{"name":"DividedPowers.coincide_on_smul","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\na : A\nhI : DividedPowers I\nJ : Ideal A\nhJ : DividedPowers J\nn : Nat\nha : Membership.mem (HSMul.hSMul I J) a\n⊢ Eq (hI.dpow n a) (hJ.dpow n a)","decl":"/-- If J is another ideal of A with divided powers,\nthen the divided powers of I and J coincide on I • J\n\n[Berthelot-1974], 1.6.1 (ii) -/\ntheorem coincide_on_smul {J : Ideal A} (hJ : DividedPowers J) {n : ℕ} (ha : a ∈ I • J) :\n    hI.dpow n a = hJ.dpow n a := by\n  induction ha using Submodule.smul_induction_on' generalizing n with\n  | smul a ha b hb =>\n    rw [Algebra.id.smul_eq_mul, hJ.dpow_mul n hb, mul_comm a b, hI.dpow_mul n ha, ←\n      hJ.factorial_mul_dpow_eq_pow n hb, ← hI.factorial_mul_dpow_eq_pow n ha]\n    ring\n  | add x hx y hy hx' hy' =>\n    rw [hI.dpow_add n (mul_le_right hx) (mul_le_right hy),\n      hJ.dpow_add n (mul_le_left hx) (mul_le_left hy)]\n    apply sum_congr rfl\n    intro k _\n    rw [hx', hy']\n\n"}
{"name":"DividedPowers.prod_dpow","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝ : CommSemiring A\nI : Ideal A\na : A\nhI : DividedPowers I\nι : Type u_2\ns : Finset ι\nn : ι → Nat\nha : Membership.mem I a\n⊢ Eq (s.prod fun i => hI.dpow (n i) a) (HMul.hMul (↑(Nat.multinomial s n)) (hI.dpow (s.sum n) a))","decl":"/-- A product of divided powers is a multinomial coefficient times the divided power\n\n[Roby-1965], formula (III') -/\ntheorem prod_dpow {ι : Type*} {s : Finset ι} (n : ι → ℕ) (ha : a ∈ I) :\n    (s.prod fun i ↦ hI.dpow (n i) a) = multinomial s n * hI.dpow (s.sum n) a := by\n  classical\n  induction s using Finset.induction with\n  | empty =>\n    simp only [prod_empty, multinomial_empty, cast_one, sum_empty, one_mul]\n    rw [hI.dpow_zero ha]\n  | insert hi hrec =>\n    rw [prod_insert hi, hrec, ← mul_assoc, mul_comm (hI.dpow (n _) a),\n      mul_assoc, mul_dpow _ _ _ ha, ← sum_insert hi, ← mul_assoc]\n    apply congr_arg₂ _ _ rfl\n    rw [multinomial_insert hi, mul_comm, cast_mul, sum_insert hi]\n\n-- TODO : can probably be simplified using `DividedPowers.exp`\n\n"}
{"name":"DividedPowers.dpow_sum'","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝² : CommSemiring A\nM : Type u_2\ninst✝¹ : AddCommMonoid M\nI : AddSubmonoid M\ndpow : Nat → M → A\ndpow_zero : ∀ {x : M}, Membership.mem I x → Eq (dpow 0 x) 1\ndpow_add : ∀ (n : Nat) {x y : M}, Membership.mem I x → Membership.mem I y → Eq (dpow n (HAdd.hAdd x y)) ((Finset.HasAntidiagonal.antidiagonal n).sum fun k => HMul.hMul (dpow k.1 x) (dpow k.2 y))\ndpow_eval_zero : ∀ {n : Nat}, Ne n 0 → Eq (dpow n 0) 0\nι : Type u_3\ninst✝ : DecidableEq ι\ns : Finset ι\nx : ι → M\nhx : ∀ (i : ι), Membership.mem s i → Membership.mem I (x i)\nn : Nat\n⊢ Eq (dpow n (s.sum x)) ((s.sym n).sum fun k => s.prod fun i => dpow (Multiset.count i ↑k) (x i))","decl":"/-- Lemma towards `dpow_sum` when we only have partial information on a divided power ideal -/\ntheorem dpow_sum' {M : Type*} [AddCommMonoid M] {I : AddSubmonoid M} (dpow : ℕ → M → A)\n    (dpow_zero : ∀ {x} (_ : x ∈ I), dpow 0 x = 1)\n    (dpow_add : ∀ (n) {x y} (_ : x ∈ I) (_ : y ∈ I),\n      dpow n (x + y) = (antidiagonal n).sum fun k ↦ dpow k.1 x * dpow k.2 y)\n    (dpow_eval_zero : ∀ {n : ℕ} (_ : n ≠ 0), dpow n 0 = 0)\n    {ι : Type*} [DecidableEq ι] {s : Finset ι} {x : ι → M} (hx : ∀ i ∈ s, x i ∈ I) (n : ℕ) :\n    dpow n (s.sum x) = (s.sym n).sum fun k ↦ s.prod fun i ↦ dpow (Multiset.count i k) (x i) := by\n  simp only [sum_antidiagonal_eq_sum_range_succ_mk] at dpow_add\n  induction s using Finset.induction generalizing n with\n  | empty =>\n    simp only [sum_empty, prod_empty, sum_const, nsmul_eq_mul, mul_one]\n    by_cases hn : n = 0\n    · rw [hn]\n      rw [dpow_zero I.zero_mem]\n      simp only [sym_zero, card_singleton, cast_one]\n    · rw [dpow_eval_zero hn, eq_comm, ← cast_zero]\n      apply congr_arg\n      rw [card_eq_zero, sym_eq_empty]\n      exact ⟨hn, rfl⟩\n  | @insert a s ha ih =>\n    -- This should be golfable using `Finset.symInsertEquiv`\n    have hx' : ∀ i, i ∈ s → x i ∈ I := fun i hi ↦ hx i (mem_insert_of_mem hi)\n    simp_rw [sum_insert ha,\n      dpow_add n (hx a (mem_insert_self a s)) (I.sum_mem fun i ↦ hx' i),\n      sum_range, ih hx', mul_sum, sum_sigma', eq_comm]\n    apply sum_bij'\n      (fun m _ ↦ m.filterNe a)\n      (fun m _ ↦ m.2.fill a m.1)\n      (fun m hm ↦ mem_sigma.2 ⟨mem_univ _, _⟩)\n      (fun m hm ↦ by\n        simp only [succ_eq_add_one, mem_sym_iff, mem_insert, Sym.mem_fill_iff]\n        simp only [mem_sigma, mem_univ, mem_sym_iff, true_and] at hm\n        intro b\n        apply Or.imp (fun h ↦ h.2) (fun h ↦ hm b h))\n      (fun m _ ↦ m.fill_filterNe a)\n    · intro m hm\n      simp only [mem_sigma, mem_univ, mem_sym_iff, true_and] at hm\n      exact Sym.filter_ne_fill a m fun a_1 ↦ ha (hm a a_1)\n    · intro m hm\n      simp only [mem_sym_iff, mem_insert] at hm\n      rw [prod_insert ha]\n      apply congr_arg₂ _ rfl\n      apply prod_congr rfl\n      intro i hi\n      apply congr_arg₂ _ _ rfl\n      conv_lhs => rw [← m.fill_filterNe a]\n      exact Sym.count_coe_fill_of_ne (ne_of_mem_of_not_mem hi ha)\n    · intro m hm\n      convert sym_filterNe_mem a hm\n      rw [erase_insert ha]\n\n"}
{"name":"DividedPowers.dpow_sum","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\ninst✝¹ : CommSemiring A\nI : Ideal A\nhI : DividedPowers I\nι : Type u_2\ninst✝ : DecidableEq ι\ns : Finset ι\nx : ι → A\nhx : ∀ (i : ι), Membership.mem s i → Membership.mem I (x i)\nn : Nat\n⊢ Eq (hI.dpow n (s.sum x)) ((s.sym n).sum fun k => s.prod fun i => hI.dpow (Multiset.count i ↑k) (x i))","decl":"/-- A “multinomial” theorem for divided powers — without multinomial coefficients -/\ntheorem dpow_sum {ι : Type*} [DecidableEq ι] {s : Finset ι} {x : ι → A}\n    (hx : ∀ i ∈ s, x i ∈ I) (n : ℕ) :\n    hI.dpow n (s.sum x) =\n      (s.sym n).sum fun k ↦ s.prod fun i ↦ hI.dpow (Multiset.count i k) (x i) :=\n  dpow_sum' hI.dpow hI.dpow_zero hI.dpow_add hI.dpow_eval_zero hx n\n\n"}
{"name":"DividedPowers.ofRingEquiv_dpow","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : CommSemiring A\nI : Ideal A\ninst✝ : CommSemiring B\ne : RingEquiv A B\nhI : DividedPowers I\nn : Nat\nb : B\n⊢ Eq (sorryAx (Unit → B) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 394).num 4).num 394).num 31).num 4).num 31).str \"_sorry\").str \"_@\").str \"_hyg\").num 1605))) (e (hI.dpow n (e.symm b)))","decl":"@[simp]\ntheorem ofRingEquiv_dpow (hI : DividedPowers I) (n : ℕ) (b : B) :\n    (ofRingEquiv h hI).dpow n b = e (hI.dpow n (e.symm b)) := rfl\n\n"}
{"name":"DividedPowers.ofRingEquiv_dpow_apply","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : CommSemiring A\nI : Ideal A\ninst✝ : CommSemiring B\ne : RingEquiv A B\nhI : DividedPowers I\nn : Nat\na : A\n⊢ Eq (sorryAx (Unit → B) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 397).num 4).num 397).num 35).num 4).num 35).str \"_sorry\").str \"_@\").str \"_hyg\").num 1662))) (e (hI.dpow n a))","decl":"theorem ofRingEquiv_dpow_apply (hI : DividedPowers I) (n : ℕ) (a : A) :\n    (ofRingEquiv h hI).dpow n (e a) = e (hI.dpow n a) := by\n  simp\n\n"}
{"name":"DividedPowers.equiv_apply","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : CommSemiring A\nI : Ideal A\ninst✝ : CommSemiring B\ne : RingEquiv A B\nhI : DividedPowers I\nn : Nat\nb : B\n⊢ Eq (sorryAx (Unit → B) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 408).num 4).num 408).num 25).num 4).num 25).str \"_sorry\").str \"_@\").str \"_hyg\").num 1793))) (e (hI.dpow n (e.symm b)))","decl":"theorem equiv_apply (hI : DividedPowers I) (n : ℕ) (b : B) :\n    (equiv h hI).dpow n b = e (hI.dpow n (e.symm b)) := rfl\n\n"}
{"name":"DividedPowers.equiv_apply'","module":"Mathlib.RingTheory.DividedPowers.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : CommSemiring A\nI : Ideal A\ninst✝ : CommSemiring B\ne : RingEquiv A B\nhI : DividedPowers I\nn : Nat\na : A\n⊢ Eq (sorryAx (Unit → B) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 412).num 4).num 412).num 29).num 4).num 29).str \"_sorry\").str \"_@\").str \"_hyg\").num 1851))) (e (hI.dpow n a))","decl":"/-- Variant of `DividedPowers.equiv_apply` -/\ntheorem equiv_apply' (hI : DividedPowers I) (n : ℕ) (a : A) :\n    (equiv h hI).dpow n (e a) = e (hI.dpow n a) :=\n  ofRingEquiv_dpow_apply h hI n a\n\n"}
