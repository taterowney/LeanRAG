{"name":"PresheafOfModules.map_id","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nself : PresheafOfModules R\nX : Opposite C\n‚ä¢ Eq (self.map (CategoryTheory.CategoryStruct.id X)) ((ModuleCat.restrictScalarsId' (RingCat.Hom.hom (R.map (CategoryTheory.CategoryStruct.id X))) ‚ãØ).inv.app (self.obj X))","decl":"variable (R) in\n/-- A presheaf of modules over `R : C·µí·µñ ‚•§ RingCat` consists of family of\nobjects `obj X : ModuleCat (R.obj X)` for all `X : C·µí·µñ` together with\nfunctorial maps `obj X ‚ü∂ (ModuleCat.restrictScalars (R.map f)).obj (obj Y)`\nfor all `f : X ‚ü∂ Y` in `C·µí·µñ`. -/\nstructure PresheafOfModules where\n  /-- a family of modules over `R.obj X` for all `X` -/\n  obj (X : C·µí·µñ) : ModuleCat.{v} (R.obj X)\n  /-- the restriction maps of a presheaf of modules -/\n  map {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : obj X ‚ü∂ (ModuleCat.restrictScalars (R.map f).hom).obj (obj Y)\n  map_id (X : C·µí·µñ) :\n    map (ùüô X) = (ModuleCat.restrictScalarsId' (R.map (ùüô X)).hom\n      (congrArg RingCat.Hom.hom (R.map_id X))).inv.app _ := by\n        aesop_cat\n  map_comp {X Y Z : C·µí·µñ} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    map (f ‚â´ g) = map f ‚â´ (ModuleCat.restrictScalars _).map (map g) ‚â´\n      (ModuleCat.restrictScalarsComp' (R.map f).hom (R.map g).hom (R.map (f ‚â´ g)).hom\n        (congrArg RingCat.Hom.hom <| R.map_comp f g)).inv.app _ := by aesop_cat\n\n"}
{"name":"PresheafOfModules.mk.inj","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nobj‚úù : (X : Opposite C) ‚Üí ModuleCat ‚Üë(R.obj X)\nmap‚úù : {X Y : Opposite C} ‚Üí (f : Quiver.Hom X Y) ‚Üí Quiver.Hom (obj‚úù X) ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).obj (obj‚úù Y))\nmap_id‚úù : autoParam (‚àÄ (X : Opposite C), Eq (map‚úù (CategoryTheory.CategoryStruct.id X)) ((ModuleCat.restrictScalarsId' (RingCat.Hom.hom (R.map (CategoryTheory.CategoryStruct.id X))) ‚ãØ).inv.app (obj‚úù X))) _auto‚úù\nmap_comp‚úù : autoParam (‚àÄ {X Y Z : Opposite C} (f : Quiver.Hom X Y) (g : Quiver.Hom Y Z), Eq (map‚úù (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (map‚úù f) (CategoryTheory.CategoryStruct.comp ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).map (map‚úù g)) ((ModuleCat.restrictScalarsComp' (RingCat.Hom.hom (R.map f)) (RingCat.Hom.hom (R.map g)) (RingCat.Hom.hom (R.map (CategoryTheory.CategoryStruct.comp f g))) ‚ãØ).inv.app (obj‚úù Z))))) _auto‚úù\nobj : (X : Opposite C) ‚Üí ModuleCat ‚Üë(R.obj X)\nmap : {X Y : Opposite C} ‚Üí (f : Quiver.Hom X Y) ‚Üí Quiver.Hom (obj X) ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).obj (obj Y))\nmap_id : autoParam (‚àÄ (X : Opposite C), Eq (map (CategoryTheory.CategoryStruct.id X)) ((ModuleCat.restrictScalarsId' (RingCat.Hom.hom (R.map (CategoryTheory.CategoryStruct.id X))) ‚ãØ).inv.app (obj X))) _auto‚úù\nmap_comp : autoParam (‚àÄ {X Y Z : Opposite C} (f : Quiver.Hom X Y) (g : Quiver.Hom Y Z), Eq (map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (map f) (CategoryTheory.CategoryStruct.comp ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).map (map g)) ((ModuleCat.restrictScalarsComp' (RingCat.Hom.hom (R.map f)) (RingCat.Hom.hom (R.map g)) (RingCat.Hom.hom (R.map (CategoryTheory.CategoryStruct.comp f g))) ‚ãØ).inv.app (obj Z))))) _auto‚úù\nx‚úù : Eq { obj := obj‚úù, map := map‚úù, map_id := map_id‚úù, map_comp := map_comp‚úù } { obj := obj, map := map, map_id := map_id, map_comp := map_comp }\n‚ä¢ And (Eq obj‚úù obj) (HEq map‚úù map)","decl":"variable (R) in\n/-- A presheaf of modules over `R : C·µí·µñ ‚•§ RingCat` consists of family of\nobjects `obj X : ModuleCat (R.obj X)` for all `X : C·µí·µñ` together with\nfunctorial maps `obj X ‚ü∂ (ModuleCat.restrictScalars (R.map f)).obj (obj Y)`\nfor all `f : X ‚ü∂ Y` in `C·µí·µñ`. -/\nstructure PresheafOfModules where\n  /-- a family of modules over `R.obj X` for all `X` -/\n  obj (X : C·µí·µñ) : ModuleCat.{v} (R.obj X)\n  /-- the restriction maps of a presheaf of modules -/\n  map {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : obj X ‚ü∂ (ModuleCat.restrictScalars (R.map f).hom).obj (obj Y)\n  map_id (X : C·µí·µñ) :\n    map (ùüô X) = (ModuleCat.restrictScalarsId' (R.map (ùüô X)).hom\n      (congrArg RingCat.Hom.hom (R.map_id X))).inv.app _ := by\n        aesop_cat\n  map_comp {X Y Z : C·µí·µñ} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    map (f ‚â´ g) = map f ‚â´ (ModuleCat.restrictScalars _).map (map g) ‚â´\n      (ModuleCat.restrictScalarsComp' (R.map f).hom (R.map g).hom (R.map (f ‚â´ g)).hom\n        (congrArg RingCat.Hom.hom <| R.map_comp f g)).inv.app _ := by aesop_cat\n\n"}
{"name":"PresheafOfModules.mk.sizeOf_spec","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\ninst‚úù : SizeOf C\nobj : (X : Opposite C) ‚Üí ModuleCat ‚Üë(R.obj X)\nmap : {X Y : Opposite C} ‚Üí (f : Quiver.Hom X Y) ‚Üí Quiver.Hom (obj X) ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).obj (obj Y))\nmap_id : autoParam (‚àÄ (X : Opposite C), Eq (map (CategoryTheory.CategoryStruct.id X)) ((ModuleCat.restrictScalarsId' (RingCat.Hom.hom (R.map (CategoryTheory.CategoryStruct.id X))) ‚ãØ).inv.app (obj X))) _auto‚úù\nmap_comp : autoParam (‚àÄ {X Y Z : Opposite C} (f : Quiver.Hom X Y) (g : Quiver.Hom Y Z), Eq (map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (map f) (CategoryTheory.CategoryStruct.comp ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).map (map g)) ((ModuleCat.restrictScalarsComp' (RingCat.Hom.hom (R.map f)) (RingCat.Hom.hom (R.map g)) (RingCat.Hom.hom (R.map (CategoryTheory.CategoryStruct.comp f g))) ‚ãØ).inv.app (obj Z))))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { obj := obj, map := map, map_id := map_id, map_comp := map_comp }) 1","decl":"variable (R) in\n/-- A presheaf of modules over `R : C·µí·µñ ‚•§ RingCat` consists of family of\nobjects `obj X : ModuleCat (R.obj X)` for all `X : C·µí·µñ` together with\nfunctorial maps `obj X ‚ü∂ (ModuleCat.restrictScalars (R.map f)).obj (obj Y)`\nfor all `f : X ‚ü∂ Y` in `C·µí·µñ`. -/\nstructure PresheafOfModules where\n  /-- a family of modules over `R.obj X` for all `X` -/\n  obj (X : C·µí·µñ) : ModuleCat.{v} (R.obj X)\n  /-- the restriction maps of a presheaf of modules -/\n  map {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : obj X ‚ü∂ (ModuleCat.restrictScalars (R.map f).hom).obj (obj Y)\n  map_id (X : C·µí·µñ) :\n    map (ùüô X) = (ModuleCat.restrictScalarsId' (R.map (ùüô X)).hom\n      (congrArg RingCat.Hom.hom (R.map_id X))).inv.app _ := by\n        aesop_cat\n  map_comp {X Y Z : C·µí·µñ} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    map (f ‚â´ g) = map f ‚â´ (ModuleCat.restrictScalars _).map (map g) ‚â´\n      (ModuleCat.restrictScalarsComp' (R.map f).hom (R.map g).hom (R.map (f ‚â´ g)).hom\n        (congrArg RingCat.Hom.hom <| R.map_comp f g)).inv.app _ := by aesop_cat\n\n"}
{"name":"PresheafOfModules.map_comp","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nself : PresheafOfModules R\nX Y Z : Opposite C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (self.map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (self.map f) (CategoryTheory.CategoryStruct.comp ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).map (self.map g)) ((ModuleCat.restrictScalarsComp' (RingCat.Hom.hom (R.map f)) (RingCat.Hom.hom (R.map g)) (RingCat.Hom.hom (R.map (CategoryTheory.CategoryStruct.comp f g))) ‚ãØ).inv.app (self.obj Z))))","decl":"variable (R) in\n/-- A presheaf of modules over `R : C·µí·µñ ‚•§ RingCat` consists of family of\nobjects `obj X : ModuleCat (R.obj X)` for all `X : C·µí·µñ` together with\nfunctorial maps `obj X ‚ü∂ (ModuleCat.restrictScalars (R.map f)).obj (obj Y)`\nfor all `f : X ‚ü∂ Y` in `C·µí·µñ`. -/\nstructure PresheafOfModules where\n  /-- a family of modules over `R.obj X` for all `X` -/\n  obj (X : C·µí·µñ) : ModuleCat.{v} (R.obj X)\n  /-- the restriction maps of a presheaf of modules -/\n  map {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : obj X ‚ü∂ (ModuleCat.restrictScalars (R.map f).hom).obj (obj Y)\n  map_id (X : C·µí·µñ) :\n    map (ùüô X) = (ModuleCat.restrictScalarsId' (R.map (ùüô X)).hom\n      (congrArg RingCat.Hom.hom (R.map_id X))).inv.app _ := by\n        aesop_cat\n  map_comp {X Y Z : C·µí·µñ} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    map (f ‚â´ g) = map f ‚â´ (ModuleCat.restrictScalars _).map (map g) ‚â´\n      (ModuleCat.restrictScalarsComp' (R.map f).hom (R.map g).hom (R.map (f ‚â´ g)).hom\n        (congrArg RingCat.Hom.hom <| R.map_comp f g)).inv.app _ := by aesop_cat\n\n"}
{"name":"PresheafOfModules.mk.injEq","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nobj‚úù : (X : Opposite C) ‚Üí ModuleCat ‚Üë(R.obj X)\nmap‚úù : {X Y : Opposite C} ‚Üí (f : Quiver.Hom X Y) ‚Üí Quiver.Hom (obj‚úù X) ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).obj (obj‚úù Y))\nmap_id‚úù : autoParam (‚àÄ (X : Opposite C), Eq (map‚úù (CategoryTheory.CategoryStruct.id X)) ((ModuleCat.restrictScalarsId' (RingCat.Hom.hom (R.map (CategoryTheory.CategoryStruct.id X))) ‚ãØ).inv.app (obj‚úù X))) _auto‚úù\nmap_comp‚úù : autoParam (‚àÄ {X Y Z : Opposite C} (f : Quiver.Hom X Y) (g : Quiver.Hom Y Z), Eq (map‚úù (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (map‚úù f) (CategoryTheory.CategoryStruct.comp ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).map (map‚úù g)) ((ModuleCat.restrictScalarsComp' (RingCat.Hom.hom (R.map f)) (RingCat.Hom.hom (R.map g)) (RingCat.Hom.hom (R.map (CategoryTheory.CategoryStruct.comp f g))) ‚ãØ).inv.app (obj‚úù Z))))) _auto‚úù\nobj : (X : Opposite C) ‚Üí ModuleCat ‚Üë(R.obj X)\nmap : {X Y : Opposite C} ‚Üí (f : Quiver.Hom X Y) ‚Üí Quiver.Hom (obj X) ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).obj (obj Y))\nmap_id : autoParam (‚àÄ (X : Opposite C), Eq (map (CategoryTheory.CategoryStruct.id X)) ((ModuleCat.restrictScalarsId' (RingCat.Hom.hom (R.map (CategoryTheory.CategoryStruct.id X))) ‚ãØ).inv.app (obj X))) _auto‚úù\nmap_comp : autoParam (‚àÄ {X Y Z : Opposite C} (f : Quiver.Hom X Y) (g : Quiver.Hom Y Z), Eq (map (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (map f) (CategoryTheory.CategoryStruct.comp ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).map (map g)) ((ModuleCat.restrictScalarsComp' (RingCat.Hom.hom (R.map f)) (RingCat.Hom.hom (R.map g)) (RingCat.Hom.hom (R.map (CategoryTheory.CategoryStruct.comp f g))) ‚ãØ).inv.app (obj Z))))) _auto‚úù\n‚ä¢ Eq (Eq { obj := obj‚úù, map := map‚úù, map_id := map_id‚úù, map_comp := map_comp‚úù } { obj := obj, map := map, map_id := map_id, map_comp := map_comp }) (And (Eq obj‚úù obj) (HEq map‚úù map))","decl":"variable (R) in\n/-- A presheaf of modules over `R : C·µí·µñ ‚•§ RingCat` consists of family of\nobjects `obj X : ModuleCat (R.obj X)` for all `X : C·µí·µñ` together with\nfunctorial maps `obj X ‚ü∂ (ModuleCat.restrictScalars (R.map f)).obj (obj Y)`\nfor all `f : X ‚ü∂ Y` in `C·µí·µñ`. -/\nstructure PresheafOfModules where\n  /-- a family of modules over `R.obj X` for all `X` -/\n  obj (X : C·µí·µñ) : ModuleCat.{v} (R.obj X)\n  /-- the restriction maps of a presheaf of modules -/\n  map {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : obj X ‚ü∂ (ModuleCat.restrictScalars (R.map f).hom).obj (obj Y)\n  map_id (X : C·µí·µñ) :\n    map (ùüô X) = (ModuleCat.restrictScalarsId' (R.map (ùüô X)).hom\n      (congrArg RingCat.Hom.hom (R.map_id X))).inv.app _ := by\n        aesop_cat\n  map_comp {X Y Z : C·µí·µñ} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) :\n    map (f ‚â´ g) = map f ‚â´ (ModuleCat.restrictScalars _).map (map g) ‚â´\n      (ModuleCat.restrictScalarsComp' (R.map f).hom (R.map g).hom (R.map (f ‚â´ g)).hom\n        (congrArg RingCat.Hom.hom <| R.map_comp f g)).inv.app _ := by aesop_cat\n\n"}
{"name":"PresheafOfModules.map_comp_assoc","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nself : PresheafOfModules R\nX Y Z‚úù : Opposite C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z‚úù\nZ : ModuleCat ‚Üë(R.obj X)\nh : Quiver.Hom ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map (CategoryTheory.CategoryStruct.comp f g)))).obj (self.obj Z‚úù)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.map (CategoryTheory.CategoryStruct.comp f g)) h) (CategoryTheory.CategoryStruct.comp (self.map f) (CategoryTheory.CategoryStruct.comp ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).map (self.map g)) (CategoryTheory.CategoryStruct.comp ((ModuleCat.restrictScalarsComp' (RingCat.Hom.hom (R.map f)) (RingCat.Hom.hom (R.map g)) (RingCat.Hom.hom (R.map (CategoryTheory.CategoryStruct.comp f g))) ‚ãØ).inv.app (self.obj Z‚úù)) h)))","decl":"attribute [reassoc] map_comp\n\n"}
{"name":"PresheafOfModules.map_smul","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM : PresheafOfModules R\nX Y : Opposite C\nf : Quiver.Hom X Y\nr : ‚Üë(R.obj X)\nm : ‚Üë(M.obj X)\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (M.map f)) (HSMul.hSMul r m)) (HSMul.hSMul ((CategoryTheory.ConcreteCategory.hom (R.map f)) r) ((CategoryTheory.ConcreteCategory.hom (M.map f)) m))","decl":"lemma map_smul {X Y : C·µí·µñ} (f : X ‚ü∂ Y) (r : R.obj X) (m : M.obj X) :\n    M.map f (r ‚Ä¢ m) = R.map f r ‚Ä¢ M.map f m := by simp\n\n"}
{"name":"PresheafOfModules.congr_map_apply","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM : PresheafOfModules R\nX Y : Opposite C\nf g : Quiver.Hom X Y\nh : Eq f g\nm : ‚Üë(M.obj X)\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (M.map f)) m) ((CategoryTheory.ConcreteCategory.hom (M.map g)) m)","decl":"lemma congr_map_apply {X Y : C·µí·µñ} {f g : X ‚ü∂ Y} (h : f = g) (m : M.obj X) :\n    M.map f m = M.map g m := by rw [h]\n\n"}
{"name":"PresheafOfModules.Hom.naturality","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ : PresheafOfModules R\nself : M‚ÇÅ.Hom M‚ÇÇ\nX Y : Opposite C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (M‚ÇÅ.map f) ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).map (self.app Y))) (CategoryTheory.CategoryStruct.comp (self.app X) (M‚ÇÇ.map f))","decl":"/-- A morphism of presheaves of modules consists of a family of linear maps which\nsatisfy the naturality condition. -/\n@[ext]\nstructure Hom where\n  /-- a family of linear maps `M‚ÇÅ.obj X ‚ü∂ M‚ÇÇ.obj X` for all `X`. -/\n  app (X : C·µí·µñ) : M‚ÇÅ.obj X ‚ü∂ M‚ÇÇ.obj X\n  naturality {X Y : C·µí·µñ} (f : X ‚ü∂ Y) :\n      M‚ÇÅ.map f ‚â´ (ModuleCat.restrictScalars (R.map f).hom).map (app Y) =\n        app X ‚â´ M‚ÇÇ.map f := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Hom.mk.inj","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ : PresheafOfModules R\napp‚úù : (X : Opposite C) ‚Üí Quiver.Hom (M‚ÇÅ.obj X) (M‚ÇÇ.obj X)\nnaturality‚úù : autoParam (‚àÄ {X Y : Opposite C} (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (M‚ÇÅ.map f) ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).map (app‚úù Y))) (CategoryTheory.CategoryStruct.comp (app‚úù X) (M‚ÇÇ.map f))) _auto‚úù\napp : (X : Opposite C) ‚Üí Quiver.Hom (M‚ÇÅ.obj X) (M‚ÇÇ.obj X)\nnaturality : autoParam (‚àÄ {X Y : Opposite C} (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (M‚ÇÅ.map f) ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).map (app Y))) (CategoryTheory.CategoryStruct.comp (app X) (M‚ÇÇ.map f))) _auto‚úù\nx‚úù : Eq { app := app‚úù, naturality := naturality‚úù } { app := app, naturality := naturality }\n‚ä¢ Eq app‚úù app","decl":"/-- A morphism of presheaves of modules consists of a family of linear maps which\nsatisfy the naturality condition. -/\n@[ext]\nstructure Hom where\n  /-- a family of linear maps `M‚ÇÅ.obj X ‚ü∂ M‚ÇÇ.obj X` for all `X`. -/\n  app (X : C·µí·µñ) : M‚ÇÅ.obj X ‚ü∂ M‚ÇÇ.obj X\n  naturality {X Y : C·µí·µñ} (f : X ‚ü∂ Y) :\n      M‚ÇÅ.map f ‚â´ (ModuleCat.restrictScalars (R.map f).hom).map (app Y) =\n        app X ‚â´ M‚ÇÇ.map f := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Hom.mk.sizeOf_spec","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ : PresheafOfModules R\ninst‚úù : SizeOf C\napp : (X : Opposite C) ‚Üí Quiver.Hom (M‚ÇÅ.obj X) (M‚ÇÇ.obj X)\nnaturality : autoParam (‚àÄ {X Y : Opposite C} (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (M‚ÇÅ.map f) ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).map (app Y))) (CategoryTheory.CategoryStruct.comp (app X) (M‚ÇÇ.map f))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { app := app, naturality := naturality }) 1","decl":"/-- A morphism of presheaves of modules consists of a family of linear maps which\nsatisfy the naturality condition. -/\n@[ext]\nstructure Hom where\n  /-- a family of linear maps `M‚ÇÅ.obj X ‚ü∂ M‚ÇÇ.obj X` for all `X`. -/\n  app (X : C·µí·µñ) : M‚ÇÅ.obj X ‚ü∂ M‚ÇÇ.obj X\n  naturality {X Y : C·µí·µñ} (f : X ‚ü∂ Y) :\n      M‚ÇÅ.map f ‚â´ (ModuleCat.restrictScalars (R.map f).hom).map (app Y) =\n        app X ‚â´ M‚ÇÇ.map f := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Hom.mk.injEq","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ : PresheafOfModules R\napp‚úù : (X : Opposite C) ‚Üí Quiver.Hom (M‚ÇÅ.obj X) (M‚ÇÇ.obj X)\nnaturality‚úù : autoParam (‚àÄ {X Y : Opposite C} (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (M‚ÇÅ.map f) ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).map (app‚úù Y))) (CategoryTheory.CategoryStruct.comp (app‚úù X) (M‚ÇÇ.map f))) _auto‚úù\napp : (X : Opposite C) ‚Üí Quiver.Hom (M‚ÇÅ.obj X) (M‚ÇÇ.obj X)\nnaturality : autoParam (‚àÄ {X Y : Opposite C} (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (M‚ÇÅ.map f) ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).map (app Y))) (CategoryTheory.CategoryStruct.comp (app X) (M‚ÇÇ.map f))) _auto‚úù\n‚ä¢ Eq (Eq { app := app‚úù, naturality := naturality‚úù } { app := app, naturality := naturality }) (Eq app‚úù app)","decl":"/-- A morphism of presheaves of modules consists of a family of linear maps which\nsatisfy the naturality condition. -/\n@[ext]\nstructure Hom where\n  /-- a family of linear maps `M‚ÇÅ.obj X ‚ü∂ M‚ÇÇ.obj X` for all `X`. -/\n  app (X : C·µí·µñ) : M‚ÇÅ.obj X ‚ü∂ M‚ÇÇ.obj X\n  naturality {X Y : C·µí·µñ} (f : X ‚ü∂ Y) :\n      M‚ÇÅ.map f ‚â´ (ModuleCat.restrictScalars (R.map f).hom).map (app Y) =\n        app X ‚â´ M‚ÇÇ.map f := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Hom.ext_iff","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ : PresheafOfModules R\nx y : M‚ÇÅ.Hom M‚ÇÇ\n‚ä¢ Iff (Eq x y) (Eq x.app y.app)","decl":"/-- A morphism of presheaves of modules consists of a family of linear maps which\nsatisfy the naturality condition. -/\n@[ext]\nstructure Hom where\n  /-- a family of linear maps `M‚ÇÅ.obj X ‚ü∂ M‚ÇÇ.obj X` for all `X`. -/\n  app (X : C·µí·µñ) : M‚ÇÅ.obj X ‚ü∂ M‚ÇÇ.obj X\n  naturality {X Y : C·µí·µñ} (f : X ‚ü∂ Y) :\n      M‚ÇÅ.map f ‚â´ (ModuleCat.restrictScalars (R.map f).hom).map (app Y) =\n        app X ‚â´ M‚ÇÇ.map f := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Hom.ext","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ : PresheafOfModules R\nx y : M‚ÇÅ.Hom M‚ÇÇ\napp : Eq x.app y.app\n‚ä¢ Eq x y","decl":"/-- A morphism of presheaves of modules consists of a family of linear maps which\nsatisfy the naturality condition. -/\n@[ext]\nstructure Hom where\n  /-- a family of linear maps `M‚ÇÅ.obj X ‚ü∂ M‚ÇÇ.obj X` for all `X`. -/\n  app (X : C·µí·µñ) : M‚ÇÅ.obj X ‚ü∂ M‚ÇÇ.obj X\n  naturality {X Y : C·µí·µñ} (f : X ‚ü∂ Y) :\n      M‚ÇÅ.map f ‚â´ (ModuleCat.restrictScalars (R.map f).hom).map (app Y) =\n        app X ‚â´ M‚ÇÇ.map f := by aesop_cat\n\n"}
{"name":"PresheafOfModules.Hom.naturality_assoc","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ : PresheafOfModules R\nself : M‚ÇÅ.Hom M‚ÇÇ\nX Y : Opposite C\nf : Quiver.Hom X Y\nZ : ModuleCat ‚Üë(R.obj X)\nh : Quiver.Hom ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).obj (M‚ÇÇ.obj Y)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (M‚ÇÅ.map f) (CategoryTheory.CategoryStruct.comp ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).map (self.app Y)) h)) (CategoryTheory.CategoryStruct.comp (self.app X) (CategoryTheory.CategoryStruct.comp (M‚ÇÇ.map f) h))","decl":"attribute [reassoc (attr := simp)] Hom.naturality\n\n"}
{"name":"PresheafOfModules.hom_ext","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ : PresheafOfModules R\nf g : Quiver.Hom M‚ÇÅ M‚ÇÇ\nh : ‚àÄ (X : Opposite C), Eq (f.app X) (g.app X)\n‚ä¢ Eq f g","decl":"@[ext]\nlemma hom_ext {f g : M‚ÇÅ ‚ü∂ M‚ÇÇ} (h : ‚àÄ (X : C·µí·µñ), f.app X = g.app X) :\n    f = g := Hom.ext (by ext1; apply h)\n\n"}
{"name":"PresheafOfModules.hom_ext_iff","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ : PresheafOfModules R\nf g : Quiver.Hom M‚ÇÅ M‚ÇÇ\n‚ä¢ Iff (Eq f g) (‚àÄ (X : Opposite C), Eq (f.app X) (g.app X))","decl":"@[ext]\nlemma hom_ext {f g : M‚ÇÅ ‚ü∂ M‚ÇÇ} (h : ‚àÄ (X : C·µí·µñ), f.app X = g.app X) :\n    f = g := Hom.ext (by ext1; apply h)\n\n"}
{"name":"PresheafOfModules.id_app","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM : PresheafOfModules R\nX : Opposite C\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.id M).app X) (CategoryTheory.CategoryStruct.id (M.obj X))","decl":"@[simp]\nlemma id_app (M : PresheafOfModules R) (X : C·µí·µñ) : Hom.app (ùüô M) X = ùüô _ := by\n  rfl\n\n"}
{"name":"PresheafOfModules.comp_app","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ M‚ÇÉ : PresheafOfModules R\nf : Quiver.Hom M‚ÇÅ M‚ÇÇ\ng : Quiver.Hom M‚ÇÇ M‚ÇÉ\nX : Opposite C\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.comp f g).app X) (CategoryTheory.CategoryStruct.comp (f.app X) (g.app X))","decl":"@[simp]\nlemma comp_app {M‚ÇÅ M‚ÇÇ M‚ÇÉ : PresheafOfModules R} (f : M‚ÇÅ ‚ü∂ M‚ÇÇ) (g : M‚ÇÇ ‚ü∂ M‚ÇÉ) (X : C·µí·µñ) :\n    (f ‚â´ g).app X = f.app X ‚â´ g.app X := by\n  rfl\n\n"}
{"name":"PresheafOfModules.naturality_apply","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ : PresheafOfModules R\nf : Quiver.Hom M‚ÇÅ M‚ÇÇ\nX Y : Opposite C\ng : Quiver.Hom X Y\nx : ‚Üë(M‚ÇÅ.obj X)\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (f.app Y)) ((CategoryTheory.ConcreteCategory.hom (M‚ÇÅ.map g)) x)) ((CategoryTheory.ConcreteCategory.hom (M‚ÇÇ.map g)) ((CategoryTheory.ConcreteCategory.hom (f.app X)) x))","decl":"lemma naturality_apply (f : M‚ÇÅ ‚ü∂ M‚ÇÇ) {X Y : C·µí·µñ} (g : X ‚ü∂ Y) (x : M‚ÇÅ.obj X) :\n    Hom.app f Y (M‚ÇÅ.map g x) = M‚ÇÇ.map g (Hom.app f X x) :=\n  congr_fun ((forget _).congr_map (Hom.naturality f g)) x\n\n"}
{"name":"PresheafOfModules.isoMk_inv_app","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ : PresheafOfModules R\napp : (X : Opposite C) ‚Üí CategoryTheory.Iso (M‚ÇÅ.obj X) (M‚ÇÇ.obj X)\nnaturality : autoParam (‚àÄ ‚¶ÉX Y : Opposite C‚¶Ñ (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (M‚ÇÅ.map f) ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).map (app Y).hom)) (CategoryTheory.CategoryStruct.comp (app X).hom (M‚ÇÇ.map f))) _auto‚úù\nX : Opposite C\n‚ä¢ Eq ((PresheafOfModules.isoMk app naturality).inv.app X) (app X).inv","decl":"/-- Constructor for isomorphisms in the category of presheaves of modules. -/\n@[simps!]\ndef isoMk (app : ‚àÄ (X : C·µí·µñ), M‚ÇÅ.obj X ‚âÖ M‚ÇÇ.obj X)\n    (naturality : ‚àÄ ‚¶ÉX Y : C·µí·µñ‚¶Ñ (f : X ‚ü∂ Y),\n      M‚ÇÅ.map f ‚â´ (ModuleCat.restrictScalars (R.map f).hom).map (app Y).hom =\n        (app X).hom ‚â´ M‚ÇÇ.map f := by aesop_cat) : M‚ÇÅ ‚âÖ M‚ÇÇ where\n  hom := { app := fun X ‚Ü¶ (app X).hom }\n  inv :=\n    { app := fun X ‚Ü¶ (app X).inv\n      naturality := fun {X Y} f ‚Ü¶ by\n        rw [‚Üê cancel_epi (app X).hom, ‚Üê reassoc_of% (naturality f), Iso.map_hom_inv_id,\n          Category.comp_id, Iso.hom_inv_id_assoc]}\n\n"}
{"name":"PresheafOfModules.isoMk_hom_app","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ : PresheafOfModules R\napp : (X : Opposite C) ‚Üí CategoryTheory.Iso (M‚ÇÅ.obj X) (M‚ÇÇ.obj X)\nnaturality : autoParam (‚àÄ ‚¶ÉX Y : Opposite C‚¶Ñ (f : Quiver.Hom X Y), Eq (CategoryTheory.CategoryStruct.comp (M‚ÇÅ.map f) ((ModuleCat.restrictScalars (RingCat.Hom.hom (R.map f))).map (app Y).hom)) (CategoryTheory.CategoryStruct.comp (app X).hom (M‚ÇÇ.map f))) _auto‚úù\nX : Opposite C\n‚ä¢ Eq ((PresheafOfModules.isoMk app naturality).hom.app X) (app X).hom","decl":"/-- Constructor for isomorphisms in the category of presheaves of modules. -/\n@[simps!]\ndef isoMk (app : ‚àÄ (X : C·µí·µñ), M‚ÇÅ.obj X ‚âÖ M‚ÇÇ.obj X)\n    (naturality : ‚àÄ ‚¶ÉX Y : C·µí·µñ‚¶Ñ (f : X ‚ü∂ Y),\n      M‚ÇÅ.map f ‚â´ (ModuleCat.restrictScalars (R.map f).hom).map (app Y).hom =\n        (app X).hom ‚â´ M‚ÇÇ.map f := by aesop_cat) : M‚ÇÅ ‚âÖ M‚ÇÇ where\n  hom := { app := fun X ‚Ü¶ (app X).hom }\n  inv :=\n    { app := fun X ‚Ü¶ (app X).inv\n      naturality := fun {X Y} f ‚Ü¶ by\n        rw [‚Üê cancel_epi (app X).hom, ‚Üê reassoc_of% (naturality f), Iso.map_hom_inv_id,\n          Category.comp_id, Iso.hom_inv_id_assoc]}\n\n"}
{"name":"PresheafOfModules.presheaf_obj_coe","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM : PresheafOfModules R\nX : Opposite C\n‚ä¢ Eq ‚Üë(M.presheaf.obj X) ‚Üë(M.obj X)","decl":"@[simp]\nlemma presheaf_obj_coe (X : C·µí·µñ) :\n    (M.presheaf.obj X : Type _) = M.obj X := rfl\n\n"}
{"name":"PresheafOfModules.presheaf_map_apply_coe","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM : PresheafOfModules R\nX Y : Opposite C\nf : Quiver.Hom X Y\nx : ‚Üë(M.obj X)\n‚ä¢ Eq ((AddCommGrp.Hom.hom (M.presheaf.map f)) x) ((CategoryTheory.ConcreteCategory.hom (M.map f)) x)","decl":"@[simp]\nlemma presheaf_map_apply_coe {X Y : C·µí·µñ} (f : X ‚ü∂ Y) (x : M.obj X) :\n    DFunLike.coe (Œ± := M.obj X) (Œ≤ := fun _ ‚Ü¶ M.obj Y) (M.presheaf.map f).hom x = M.map f x := rfl\n\n"}
{"name":"PresheafOfModules.toPresheaf_obj_coe","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM : PresheafOfModules R\nX : Opposite C\n‚ä¢ Eq ‚Üë(((PresheafOfModules.toPresheaf R).obj M).obj X) ‚Üë(M.obj X)","decl":"@[simp]\nlemma toPresheaf_obj_coe (X : C·µí·µñ) :\n    (((toPresheaf R).obj M).obj X : Type _) = M.obj X := rfl\n\n"}
{"name":"PresheafOfModules.toPresheaf_map_app_apply","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ : PresheafOfModules R\nf : Quiver.Hom M‚ÇÅ M‚ÇÇ\nX : Opposite C\nx : ‚Üë(M‚ÇÅ.obj X)\n‚ä¢ Eq ((AddCommGrp.Hom.hom (((PresheafOfModules.toPresheaf R).map f).app X)) x) ((CategoryTheory.ConcreteCategory.hom (f.app X)) x)","decl":"@[simp]\nlemma toPresheaf_map_app_apply (f : M‚ÇÅ ‚ü∂ M‚ÇÇ) (X : C·µí·µñ) (x : M‚ÇÅ.obj X) :\n    DFunLike.coe (Œ± := M‚ÇÅ.obj X) (Œ≤ := fun _ ‚Ü¶ M‚ÇÇ.obj X)\n      (((toPresheaf R).map f).app X).hom x = f.app X x := rfl\n\n"}
{"name":"PresheafOfModules.instFaithfulFunctorOppositeAbToPresheaf","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\n‚ä¢ (PresheafOfModules.toPresheaf R).Faithful","decl":"instance : (toPresheaf R).Faithful where\n  map_injective {_ _ f g} h := by\n    ext X x\n    exact congr_fun (((evaluation _ _).obj X ‚ãô forget _).congr_map h) x\n\n"}
{"name":"PresheafOfModules.ofPresheaf_obj_carrier","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM : CategoryTheory.Functor (Opposite C) Ab\ninst‚úù : (X : Opposite C) ‚Üí Module ‚Üë(R.obj X) ‚Üë(M.obj X)\nmap_smul : ‚àÄ ‚¶ÉX Y : Opposite C‚¶Ñ (f : Quiver.Hom X Y) (r : ‚Üë(R.obj X)) (m : ‚Üë(M.obj X)), Eq ((CategoryTheory.ConcreteCategory.hom (M.map f)) (HSMul.hSMul r m)) (HSMul.hSMul ((CategoryTheory.ConcreteCategory.hom (R.map f)) r) ((CategoryTheory.ConcreteCategory.hom (M.map f)) m))\nX : Opposite C\n‚ä¢ Eq ‚Üë((PresheafOfModules.ofPresheaf M map_smul).obj X) ‚Üë(M.obj X)","decl":"/-- The object in `PresheafOfModules R` that is obtained from `M : C·µí·µñ ‚•§ Ab.{v}` such\nthat for all `X : C·µí·µñ`, `M.obj X` is a `R.obj X` module, in such a way that the\nrestriction maps are semilinear. (This constructor should be used only in cases\nwhen the preferred constructor `PresheafOfModules.mk` is not as convenient as this one.) -/\n@[simps]\ndef ofPresheaf : PresheafOfModules.{v} R where\n  obj X := ModuleCat.of _ (M.obj X)\n  -- TODO: after https://github.com/leanprover-community/mathlib4/pull/19511 we need to hint `(Y := ...)`.\n  -- This suggests `restrictScalars` needs to be redesigned.\n  map {X Y} f := ModuleCat.ofHom\n      (Y := (ModuleCat.restrictScalars (R.map f).hom).obj (ModuleCat.of _ (M.obj Y)))\n    { toFun := fun x ‚Ü¶ M.map f x\n      map_add' := by simp\n      map_smul' := fun r m ‚Ü¶ map_smul f r m }\n\n"}
{"name":"PresheafOfModules.ofPresheaf_obj_isModule","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM : CategoryTheory.Functor (Opposite C) Ab\ninst‚úù : (X : Opposite C) ‚Üí Module ‚Üë(R.obj X) ‚Üë(M.obj X)\nmap_smul : ‚àÄ ‚¶ÉX Y : Opposite C‚¶Ñ (f : Quiver.Hom X Y) (r : ‚Üë(R.obj X)) (m : ‚Üë(M.obj X)), Eq ((CategoryTheory.ConcreteCategory.hom (M.map f)) (HSMul.hSMul r m)) (HSMul.hSMul ((CategoryTheory.ConcreteCategory.hom (R.map f)) r) ((CategoryTheory.ConcreteCategory.hom (M.map f)) m))\nX : Opposite C\n‚ä¢ Eq ((PresheafOfModules.ofPresheaf M map_smul).obj X).isModule (inst‚úù X)","decl":"/-- The object in `PresheafOfModules R` that is obtained from `M : C·µí·µñ ‚•§ Ab.{v}` such\nthat for all `X : C·µí·µñ`, `M.obj X` is a `R.obj X` module, in such a way that the\nrestriction maps are semilinear. (This constructor should be used only in cases\nwhen the preferred constructor `PresheafOfModules.mk` is not as convenient as this one.) -/\n@[simps]\ndef ofPresheaf : PresheafOfModules.{v} R where\n  obj X := ModuleCat.of _ (M.obj X)\n  -- TODO: after https://github.com/leanprover-community/mathlib4/pull/19511 we need to hint `(Y := ...)`.\n  -- This suggests `restrictScalars` needs to be redesigned.\n  map {X Y} f := ModuleCat.ofHom\n      (Y := (ModuleCat.restrictScalars (R.map f).hom).obj (ModuleCat.of _ (M.obj Y)))\n    { toFun := fun x ‚Ü¶ M.map f x\n      map_add' := by simp\n      map_smul' := fun r m ‚Ü¶ map_smul f r m }\n\n"}
{"name":"PresheafOfModules.ofPresheaf_obj_isAddCommGroup","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM : CategoryTheory.Functor (Opposite C) Ab\ninst‚úù : (X : Opposite C) ‚Üí Module ‚Üë(R.obj X) ‚Üë(M.obj X)\nmap_smul : ‚àÄ ‚¶ÉX Y : Opposite C‚¶Ñ (f : Quiver.Hom X Y) (r : ‚Üë(R.obj X)) (m : ‚Üë(M.obj X)), Eq ((CategoryTheory.ConcreteCategory.hom (M.map f)) (HSMul.hSMul r m)) (HSMul.hSMul ((CategoryTheory.ConcreteCategory.hom (R.map f)) r) ((CategoryTheory.ConcreteCategory.hom (M.map f)) m))\nX : Opposite C\n‚ä¢ Eq ((PresheafOfModules.ofPresheaf M map_smul).obj X).isAddCommGroup (M.obj X).str","decl":"/-- The object in `PresheafOfModules R` that is obtained from `M : C·µí·µñ ‚•§ Ab.{v}` such\nthat for all `X : C·µí·µñ`, `M.obj X` is a `R.obj X` module, in such a way that the\nrestriction maps are semilinear. (This constructor should be used only in cases\nwhen the preferred constructor `PresheafOfModules.mk` is not as convenient as this one.) -/\n@[simps]\ndef ofPresheaf : PresheafOfModules.{v} R where\n  obj X := ModuleCat.of _ (M.obj X)\n  -- TODO: after https://github.com/leanprover-community/mathlib4/pull/19511 we need to hint `(Y := ...)`.\n  -- This suggests `restrictScalars` needs to be redesigned.\n  map {X Y} f := ModuleCat.ofHom\n      (Y := (ModuleCat.restrictScalars (R.map f).hom).obj (ModuleCat.of _ (M.obj Y)))\n    { toFun := fun x ‚Ü¶ M.map f x\n      map_add' := by simp\n      map_smul' := fun r m ‚Ü¶ map_smul f r m }\n\n"}
{"name":"PresheafOfModules.ofPresheaf_map","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM : CategoryTheory.Functor (Opposite C) Ab\ninst‚úù : (X : Opposite C) ‚Üí Module ‚Üë(R.obj X) ‚Üë(M.obj X)\nmap_smul : ‚àÄ ‚¶ÉX Y : Opposite C‚¶Ñ (f : Quiver.Hom X Y) (r : ‚Üë(R.obj X)) (m : ‚Üë(M.obj X)), Eq ((CategoryTheory.ConcreteCategory.hom (M.map f)) (HSMul.hSMul r m)) (HSMul.hSMul ((CategoryTheory.ConcreteCategory.hom (R.map f)) r) ((CategoryTheory.ConcreteCategory.hom (M.map f)) m))\nX Y : Opposite C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((PresheafOfModules.ofPresheaf M map_smul).map f) (ModuleCat.ofHom { toFun := fun x => (CategoryTheory.ConcreteCategory.hom (M.map f)) x, map_add' := ‚ãØ, map_smul' := ‚ãØ })","decl":"/-- The object in `PresheafOfModules R` that is obtained from `M : C·µí·µñ ‚•§ Ab.{v}` such\nthat for all `X : C·µí·µñ`, `M.obj X` is a `R.obj X` module, in such a way that the\nrestriction maps are semilinear. (This constructor should be used only in cases\nwhen the preferred constructor `PresheafOfModules.mk` is not as convenient as this one.) -/\n@[simps]\ndef ofPresheaf : PresheafOfModules.{v} R where\n  obj X := ModuleCat.of _ (M.obj X)\n  -- TODO: after https://github.com/leanprover-community/mathlib4/pull/19511 we need to hint `(Y := ...)`.\n  -- This suggests `restrictScalars` needs to be redesigned.\n  map {X Y} f := ModuleCat.ofHom\n      (Y := (ModuleCat.restrictScalars (R.map f).hom).obj (ModuleCat.of _ (M.obj Y)))\n    { toFun := fun x ‚Ü¶ M.map f x\n      map_add' := by simp\n      map_smul' := fun r m ‚Ü¶ map_smul f r m }\n\n"}
{"name":"PresheafOfModules.ofPresheaf_presheaf","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM : CategoryTheory.Functor (Opposite C) Ab\ninst‚úù : (X : Opposite C) ‚Üí Module ‚Üë(R.obj X) ‚Üë(M.obj X)\nmap_smul : ‚àÄ ‚¶ÉX Y : Opposite C‚¶Ñ (f : Quiver.Hom X Y) (r : ‚Üë(R.obj X)) (m : ‚Üë(M.obj X)), Eq ((CategoryTheory.ConcreteCategory.hom (M.map f)) (HSMul.hSMul r m)) (HSMul.hSMul ((CategoryTheory.ConcreteCategory.hom (R.map f)) r) ((CategoryTheory.ConcreteCategory.hom (M.map f)) m))\n‚ä¢ Eq (PresheafOfModules.ofPresheaf M map_smul).presheaf M","decl":"@[simp]\nlemma ofPresheaf_presheaf : (ofPresheaf M map_smul).presheaf = M := rfl\n\n"}
{"name":"PresheafOfModules.homMk_app","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ : PresheafOfModules R\nœÜ : Quiver.Hom M‚ÇÅ.presheaf M‚ÇÇ.presheaf\nhœÜ : ‚àÄ (X : Opposite C) (r : ‚Üë(R.obj X)) (m : ‚Üë(M‚ÇÅ.obj X)), Eq ((CategoryTheory.ConcreteCategory.hom (œÜ.app X)) (HSMul.hSMul r m)) (HSMul.hSMul r ((CategoryTheory.ConcreteCategory.hom (œÜ.app X)) m))\nX : Opposite C\n‚ä¢ Eq ((PresheafOfModules.homMk œÜ hœÜ).app X) (ModuleCat.ofHom { toFun := ‚áë(CategoryTheory.ConcreteCategory.hom (œÜ.app X)), map_add' := ‚ãØ, map_smul' := ‚ãØ })","decl":"/-- The morphism of presheaves of modules `M‚ÇÅ ‚ü∂ M‚ÇÇ` given by a morphism\nof abelian presheaves `M‚ÇÅ.presheaf ‚ü∂ M‚ÇÇ.presheaf`\nwhich satisfy a suitable linearity condition. -/\n@[simps]\ndef homMk (œÜ : M‚ÇÅ.presheaf ‚ü∂ M‚ÇÇ.presheaf)\n    (hœÜ : ‚àÄ (X : C·µí·µñ) (r : R.obj X) (m : M‚ÇÅ.obj X), œÜ.app X (r ‚Ä¢ m) = r ‚Ä¢ œÜ.app X m) :\n    M‚ÇÅ ‚ü∂ M‚ÇÇ where\n  app X := ModuleCat.ofHom\n    { toFun := œÜ.app X\n      map_add' := by simp\n      map_smul' := hœÜ X }\n  naturality := fun f ‚Ü¶ by\n    ext x\n    exact congr_fun ((forget _).congr_map (œÜ.naturality f)) x\n\n"}
{"name":"PresheafOfModules.zero_app","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ : PresheafOfModules R\nX : Opposite C\n‚ä¢ Eq (PresheafOfModules.Hom.app 0 X) 0","decl":"variable (M‚ÇÅ M‚ÇÇ) in\n@[simp] lemma zero_app (X : C·µí·µñ) : (0 : M‚ÇÅ ‚ü∂ M‚ÇÇ).app X = 0 := rfl\n\n"}
{"name":"PresheafOfModules.neg_app","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ : PresheafOfModules R\nf : Quiver.Hom M‚ÇÅ M‚ÇÇ\nX : Opposite C\n‚ä¢ Eq ((Neg.neg f).app X) (Neg.neg (f.app X))","decl":"@[simp] lemma neg_app (f : M‚ÇÅ ‚ü∂ M‚ÇÇ) (X : C·µí·µñ) : (-f).app X = -f.app X := rfl\n"}
{"name":"PresheafOfModules.add_app","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ : PresheafOfModules R\nf g : Quiver.Hom M‚ÇÅ M‚ÇÇ\nX : Opposite C\n‚ä¢ Eq ((HAdd.hAdd f g).app X) (HAdd.hAdd (f.app X) (g.app X))","decl":"@[simp] lemma add_app (f g : M‚ÇÅ ‚ü∂ M‚ÇÇ) (X : C·µí·µñ) : (f + g).app X = f.app X + g.app X := rfl\n"}
{"name":"PresheafOfModules.sub_app","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ : PresheafOfModules R\nf g : Quiver.Hom M‚ÇÅ M‚ÇÇ\nX : Opposite C\n‚ä¢ Eq ((HSub.hSub f g).app X) (HSub.hSub (f.app X) (g.app X))","decl":"@[simp] lemma sub_app (f g : M‚ÇÅ ‚ü∂ M‚ÇÇ) (X : C·µí·µñ) : (f - g).app X = f.app X - g.app X := rfl\n\n"}
{"name":"PresheafOfModules.instAdditiveFunctorOppositeAbToPresheaf","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\n‚ä¢ (PresheafOfModules.toPresheaf R).Additive","decl":"instance : (toPresheaf R).Additive where\n\n"}
{"name":"PresheafOfModules.zsmul_app","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM‚ÇÅ M‚ÇÇ : PresheafOfModules R\nn : Int\nf : Quiver.Hom M‚ÇÅ M‚ÇÇ\nX : Opposite C\n‚ä¢ Eq ((HSMul.hSMul n f).app X) (HSMul.hSMul n (f.app X))","decl":"lemma zsmul_app (n : ‚Ñ§) (f : M‚ÇÅ ‚ü∂ M‚ÇÇ) (X : C·µí·µñ) : (n ‚Ä¢ f).app X = n ‚Ä¢ f.app X := by\n  ext x\n  change (toPresheaf R ‚ãô (evaluation _ _).obj X).map (n ‚Ä¢ f) x = _\n  rw [Functor.map_zsmul]\n  rfl\n\n"}
{"name":"PresheafOfModules.evaluation_map","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nX : Opposite C\nX‚úù Y‚úù : PresheafOfModules R\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((PresheafOfModules.evaluation R X).map f) (f.app X)","decl":"/-- Evaluation on an object `X` gives a functor\n`PresheafOfModules R ‚•§ ModuleCat (R.obj X)`. -/\n@[simps]\ndef evaluation (X : C·µí·µñ) : PresheafOfModules.{v} R ‚•§ ModuleCat (R.obj X) where\n  obj M := M.obj X\n  map f := f.app X\n\n"}
{"name":"PresheafOfModules.evaluation_obj","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nX : Opposite C\nM : PresheafOfModules R\n‚ä¢ Eq ((PresheafOfModules.evaluation R X).obj M) (M.obj X)","decl":"/-- Evaluation on an object `X` gives a functor\n`PresheafOfModules R ‚•§ ModuleCat (R.obj X)`. -/\n@[simps]\ndef evaluation (X : C·µí·µñ) : PresheafOfModules.{v} R ‚•§ ModuleCat (R.obj X) where\n  obj M := M.obj X\n  map f := f.app X\n\n"}
{"name":"PresheafOfModules.instAdditiveModuleCatCarrierObjOppositeRingCatEvaluation","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nX : Opposite C\n‚ä¢ (PresheafOfModules.evaluation R X).Additive","decl":"instance (X : C·µí·µñ) : (evaluation.{v} R X).Additive where\n\n"}
{"name":"PresheafOfModules.restriction_app","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nX Y : Opposite C\nf : Quiver.Hom X Y\nM : PresheafOfModules R\n‚ä¢ Eq ((PresheafOfModules.restriction R f).app M) (M.map f)","decl":"/-- The restriction natural transformation on presheaves of modules, considered as linear maps\nto restriction of scalars. -/\n@[simps]\nnoncomputable def restriction {X Y : C·µí·µñ} (f : X ‚ü∂ Y) :\n    evaluation R X ‚ü∂ evaluation R Y ‚ãô ModuleCat.restrictScalars (R.map f).hom where\n  app M := M.map f\n\n"}
{"name":"PresheafOfModules.unit_map_one","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nX Y : Opposite C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom ((PresheafOfModules.unit R).map f)) 1) 1","decl":"lemma unit_map_one {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : (unit R).map f (1 : R.obj X) = (1 : R.obj Y) :=\n  (R.map f).hom.map_one\n\n"}
{"name":"PresheafOfModules.sections_property","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM : PresheafOfModules R\ns : M.sections\nX Y : Opposite C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.ConcreteCategory.hom (M.map f)) (‚Üës X)) (‚Üës Y)","decl":"@[simp]\nlemma sections_property {M : PresheafOfModules.{v} R} (s : M.sections)\n    {X Y : C·µí·µñ} (f : X ‚ü∂ Y) : M.map f (s.1 X) = s.1 Y := s.2 f\n\n"}
{"name":"PresheafOfModules.sectionsMk_coe","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM : PresheafOfModules R\ns : (X : Opposite C) ‚Üí ‚Üë(M.obj X)\nhs : ‚àÄ ‚¶ÉX Y : Opposite C‚¶Ñ (f : Quiver.Hom X Y), Eq ((CategoryTheory.ConcreteCategory.hom (M.map f)) (s X)) (s Y)\nX : Opposite C\n‚ä¢ Eq (‚Üë(PresheafOfModules.sectionsMk s hs) X) (s X)","decl":"/-- Constructor for sections of a presheaf of modules. -/\n@[simps]\ndef sectionsMk {M : PresheafOfModules.{v} R} (s : ‚àÄ X, M.obj X)\n    (hs : ‚àÄ ‚¶ÉX Y : C·µí·µñ‚¶Ñ (f : X ‚ü∂ Y), M.map f (s X) = s Y) : M.sections where\n  val := s\n  property f := hs f\n\n"}
{"name":"PresheafOfModules.sections_ext_iff","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM : PresheafOfModules R\ns t : M.sections\n‚ä¢ Iff (Eq s t) (‚àÄ (X : Opposite C), Eq (‚Üës X) (‚Üët X))","decl":"@[ext]\nlemma sections_ext {M : PresheafOfModules.{v} R} (s t : M.sections)\n    (h : ‚àÄ (X : C·µí·µñ), s.val X = t.val X) : s = t :=\n  Subtype.ext (by ext; apply h)\n\n"}
{"name":"PresheafOfModules.sections_ext","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM : PresheafOfModules R\ns t : M.sections\nh : ‚àÄ (X : Opposite C), Eq (‚Üës X) (‚Üët X)\n‚ä¢ Eq s t","decl":"@[ext]\nlemma sections_ext {M : PresheafOfModules.{v} R} (s t : M.sections)\n    (h : ‚àÄ (X : C·µí·µñ), s.val X = t.val X) : s = t :=\n  Subtype.ext (by ext; apply h)\n\n"}
{"name":"PresheafOfModules.sectionsMap_coe","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM N : PresheafOfModules R\nf : Quiver.Hom M N\ns : M.sections\nX : Opposite C\n‚ä¢ Eq (‚Üë(PresheafOfModules.sectionsMap f s) X) ((CategoryTheory.ConcreteCategory.hom (f.app X)) (‚Üës X))","decl":"/-- The map `M.sections ‚Üí N.sections` induced by a morphisms `M ‚ü∂ N` of presheaves of modules. -/\n@[simps!]\ndef sectionsMap {M N : PresheafOfModules.{v} R} (f : M ‚ü∂ N) (s : M.sections) : N.sections :=\n  N.sectionsMk (fun X ‚Ü¶ f.app X (s.1 _))\n    (fun X Y g ‚Ü¶ by rw [‚Üê naturality_apply, sections_property])\n\n"}
{"name":"PresheafOfModules.sectionsMap_comp","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM N P : PresheafOfModules R\nf : Quiver.Hom M N\ng : Quiver.Hom N P\ns : M.sections\n‚ä¢ Eq (PresheafOfModules.sectionsMap (CategoryTheory.CategoryStruct.comp f g) s) (PresheafOfModules.sectionsMap g (PresheafOfModules.sectionsMap f s))","decl":"@[simp]\nlemma sectionsMap_comp {M N P : PresheafOfModules.{v} R} (f : M ‚ü∂ N) (g : N ‚ü∂ P) (s : M.sections) :\n    sectionsMap (f ‚â´ g) s = sectionsMap g (sectionsMap f s) := rfl\n\n"}
{"name":"PresheafOfModules.sectionsMap_id","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM : PresheafOfModules R\ns : M.sections\n‚ä¢ Eq (PresheafOfModules.sectionsMap (CategoryTheory.CategoryStruct.id M) s) s","decl":"@[simp]\nlemma sectionsMap_id {M : PresheafOfModules.{v} R} (s : M.sections) :\n    sectionsMap (ùüô M) s = s := rfl\n\n"}
{"name":"PresheafOfModules.unitHomEquiv_apply_coe","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nM : PresheafOfModules R\nf : Quiver.Hom (PresheafOfModules.unit R) M\nX : Opposite C\n‚ä¢ Eq (‚Üë(M.unitHomEquiv f) X) ((CategoryTheory.ConcreteCategory.hom (f.app X)) 1)","decl":"/-- The bijection `(unit R ‚ü∂ M) ‚âÉ M.sections` for `M : PresheafOfModules R`. -/\n@[simps! apply_coe]\ndef unitHomEquiv (M : PresheafOfModules R) :\n    (unit R ‚ü∂ M) ‚âÉ M.sections where\n  toFun f := sectionsMk (fun X ‚Ü¶ Hom.app f X (1 : R.obj X))\n    (by intros; rw [‚Üê naturality_apply, unit_map_one])\n  invFun s :=\n    { app := fun X ‚Ü¶ ModuleCat.ofHom\n        ((LinearMap.ringLmapEquivSelf (R.obj X) ‚Ñ§ (M.obj X)).symm (s.val X))\n      naturality := fun {X Y} f ‚Ü¶ by\n        ext\n        dsimp\n        change R.map f 1 ‚Ä¢ s.eval Y = M.map f (1 ‚Ä¢ s.eval X)\n        simp }\n  left_inv f := by\n    ext X : 2\n    exact (LinearMap.ringLmapEquivSelf (R.obj X) ‚Ñ§ (M.obj X)).symm_apply_apply (f.app X).hom\n  right_inv s := by\n    ext X\n    exact (LinearMap.ringLmapEquivSelf (R.obj X) ‚Ñ§ (M.obj X)).apply_symm_apply (s.val X)\n\n"}
{"name":"PresheafOfModules.forgetToPresheafModuleCatObjObj_coe","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nX : Opposite C\nhX : CategoryTheory.Limits.IsInitial X\nM : PresheafOfModules R\nY : Opposite C\n‚ä¢ Eq ‚Üë(PresheafOfModules.forgetToPresheafModuleCatObjObj X hX M Y) ‚Üë(M.obj Y)","decl":"lemma forgetToPresheafModuleCatObjObj_coe (Y : C·µí·µñ) :\n    (forgetToPresheafModuleCatObjObj X hX M Y : Type _) = M.obj Y := rfl\n\n"}
{"name":"PresheafOfModules.forgetToPresheafModuleCatObjMap_apply","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nX : Opposite C\nhX : CategoryTheory.Limits.IsInitial X\nM : PresheafOfModules R\nY Z : Opposite C\nf : Quiver.Hom Y Z\nm : ‚Üë(M.obj Y)\n‚ä¢ Eq ((ModuleCat.Hom.hom (PresheafOfModules.forgetToPresheafModuleCatObjMap X hX M f)) m) ((CategoryTheory.ConcreteCategory.hom (M.map f)) m)","decl":"@[simp]\nlemma forgetToPresheafModuleCatObjMap_apply {Y Z : C·µí·µñ} (f : Y ‚ü∂ Z) (m : M.obj Y) :\n  (forgetToPresheafModuleCatObjMap X hX M f).hom m = M.map f m := rfl\n\n"}
{"name":"PresheafOfModules.forgetToPresheafModuleCatObj_obj","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nX : Opposite C\nhX : CategoryTheory.Limits.IsInitial X\nM : PresheafOfModules R\nY : Opposite C\n‚ä¢ Eq ((PresheafOfModules.forgetToPresheafModuleCatObj X hX M).obj Y) (PresheafOfModules.forgetToPresheafModuleCatObjObj X hX M Y)","decl":"/--\nImplementation of the functor `PresheafOfModules R ‚•§ C·µí·µñ ‚•§ ModuleCat (R.obj X)`\nwhen `X` is initial.\n\nThe functor is implemented as, on object level `M ‚Ü¶ (c ‚Ü¶ M(c))` where the `R(X)`-module structure\non `M(c)` is given by restriction of scalars along the unique morphism `R(c) ‚ü∂ R(X)`; and on\nmorphism level `(f : M ‚ü∂ N) ‚Ü¶ (c ‚Ü¶ f(c))`.\n-/\n@[simps]\nnoncomputable def forgetToPresheafModuleCatObj\n    (X : C·µí·µñ) (hX : Limits.IsInitial X) (M : PresheafOfModules.{v} R) :\n    C·µí·µñ ‚•§ ModuleCat (R.obj X) where\n  obj Y := forgetToPresheafModuleCatObjObj X hX M Y\n  map f := forgetToPresheafModuleCatObjMap X hX M f\n\n"}
{"name":"PresheafOfModules.forgetToPresheafModuleCatObj_map","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nX : Opposite C\nhX : CategoryTheory.Limits.IsInitial X\nM : PresheafOfModules R\nX‚úù Y‚úù : Opposite C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((PresheafOfModules.forgetToPresheafModuleCatObj X hX M).map f) (PresheafOfModules.forgetToPresheafModuleCatObjMap X hX M f)","decl":"/--\nImplementation of the functor `PresheafOfModules R ‚•§ C·µí·µñ ‚•§ ModuleCat (R.obj X)`\nwhen `X` is initial.\n\nThe functor is implemented as, on object level `M ‚Ü¶ (c ‚Ü¶ M(c))` where the `R(X)`-module structure\non `M(c)` is given by restriction of scalars along the unique morphism `R(c) ‚ü∂ R(X)`; and on\nmorphism level `(f : M ‚ü∂ N) ‚Ü¶ (c ‚Ü¶ f(c))`.\n-/\n@[simps]\nnoncomputable def forgetToPresheafModuleCatObj\n    (X : C·µí·µñ) (hX : Limits.IsInitial X) (M : PresheafOfModules.{v} R) :\n    C·µí·µñ ‚•§ ModuleCat (R.obj X) where\n  obj Y := forgetToPresheafModuleCatObjObj X hX M Y\n  map f := forgetToPresheafModuleCatObjMap X hX M f\n\n"}
{"name":"PresheafOfModules.forgetToPresheafModuleCat_obj","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nX : Opposite C\nhX : CategoryTheory.Limits.IsInitial X\nM : PresheafOfModules R\n‚ä¢ Eq ((PresheafOfModules.forgetToPresheafModuleCat X hX).obj M) (PresheafOfModules.forgetToPresheafModuleCatObj X hX M)","decl":"/--\nThe forgetful functor from presheaves of modules over a presheaf of rings `R` to presheaves of\n`R(X)`-modules where `X` is an initial object.\n\nThe functor is implemented as, on object level `M ‚Ü¶ (c ‚Ü¶ M(c))` where the `R(X)`-module structure\non `M(c)` is given by restriction of scalars along the unique morphism `R(c) ‚ü∂ R(X)`; and on\nmorphism level `(f : M ‚ü∂ N) ‚Ü¶ (c ‚Ü¶ f(c))`.\n-/\n@[simps]\nnoncomputable def forgetToPresheafModuleCat (X : C·µí·µñ) (hX : Limits.IsInitial X) :\n    PresheafOfModules.{v} R ‚•§ C·µí·µñ ‚•§ ModuleCat (R.obj X) where\n  obj M := forgetToPresheafModuleCatObj X hX M\n  map f := forgetToPresheafModuleCatMap X hX f\n\n"}
{"name":"PresheafOfModules.forgetToPresheafModuleCat_map","module":"Mathlib.Algebra.Category.ModuleCat.Presheaf","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nR : CategoryTheory.Functor (Opposite C) RingCat\nX : Opposite C\nhX : CategoryTheory.Limits.IsInitial X\nX‚úù Y‚úù : PresheafOfModules R\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((PresheafOfModules.forgetToPresheafModuleCat X hX).map f) (PresheafOfModules.forgetToPresheafModuleCatMap X hX f)","decl":"/--\nThe forgetful functor from presheaves of modules over a presheaf of rings `R` to presheaves of\n`R(X)`-modules where `X` is an initial object.\n\nThe functor is implemented as, on object level `M ‚Ü¶ (c ‚Ü¶ M(c))` where the `R(X)`-module structure\non `M(c)` is given by restriction of scalars along the unique morphism `R(c) ‚ü∂ R(X)`; and on\nmorphism level `(f : M ‚ü∂ N) ‚Ü¶ (c ‚Ü¶ f(c))`.\n-/\n@[simps]\nnoncomputable def forgetToPresheafModuleCat (X : C·µí·µñ) (hX : Limits.IsInitial X) :\n    PresheafOfModules.{v} R ‚•§ C·µí·µñ ‚•§ ModuleCat (R.obj X) where\n  obj M := forgetToPresheafModuleCatObj X hX M\n  map f := forgetToPresheafModuleCatMap X hX f\n\n"}
