{"name":"CategoryTheory.prod_id_snd","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : Prod C D\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X).2 (CategoryTheory.CategoryStruct.id X.2)","decl":"/-- `prod C D` gives the cartesian product of two categories. -/\n@[simps (config := { notRecursive := [] }) Hom id_fst id_snd comp_fst comp_snd, stacks 001K]\ninstance prod : Category.{max v‚ÇÅ v‚ÇÇ} (C √ó D) where\n  Hom X Y := (X.1 ‚ü∂ Y.1) √ó (X.2 ‚ü∂ Y.2)\n  id X := ‚ü®ùüô X.1, ùüô X.2‚ü©\n  comp f g := (f.1 ‚â´ g.1, f.2 ‚â´ g.2)\n\n"}
{"name":"CategoryTheory.prod_comp_fst","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù Y‚úù Z‚úù : Prod C D\nf : Quiver.Hom X‚úù Y‚úù\ng : Quiver.Hom Y‚úù Z‚úù\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).1 (CategoryTheory.CategoryStruct.comp f.1 g.1)","decl":"/-- `prod C D` gives the cartesian product of two categories. -/\n@[simps (config := { notRecursive := [] }) Hom id_fst id_snd comp_fst comp_snd, stacks 001K]\ninstance prod : Category.{max v‚ÇÅ v‚ÇÇ} (C √ó D) where\n  Hom X Y := (X.1 ‚ü∂ Y.1) √ó (X.2 ‚ü∂ Y.2)\n  id X := ‚ü®ùüô X.1, ùüô X.2‚ü©\n  comp f g := (f.1 ‚â´ g.1, f.2 ‚â´ g.2)\n\n"}
{"name":"CategoryTheory.prod_id_fst","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : Prod C D\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X).1 (CategoryTheory.CategoryStruct.id X.1)","decl":"/-- `prod C D` gives the cartesian product of two categories. -/\n@[simps (config := { notRecursive := [] }) Hom id_fst id_snd comp_fst comp_snd, stacks 001K]\ninstance prod : Category.{max v‚ÇÅ v‚ÇÇ} (C √ó D) where\n  Hom X Y := (X.1 ‚ü∂ Y.1) √ó (X.2 ‚ü∂ Y.2)\n  id X := ‚ü®ùüô X.1, ùüô X.2‚ü©\n  comp f g := (f.1 ‚â´ g.1, f.2 ‚â´ g.2)\n\n"}
{"name":"CategoryTheory.prod_Hom","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX Y : Prod C D\n‚ä¢ Eq (Quiver.Hom X Y) (Prod (Quiver.Hom X.1 Y.1) (Quiver.Hom X.2 Y.2))","decl":"/-- `prod C D` gives the cartesian product of two categories. -/\n@[simps (config := { notRecursive := [] }) Hom id_fst id_snd comp_fst comp_snd, stacks 001K]\ninstance prod : Category.{max v‚ÇÅ v‚ÇÇ} (C √ó D) where\n  Hom X Y := (X.1 ‚ü∂ Y.1) √ó (X.2 ‚ü∂ Y.2)\n  id X := ‚ü®ùüô X.1, ùüô X.2‚ü©\n  comp f g := (f.1 ‚â´ g.1, f.2 ‚â´ g.2)\n\n"}
{"name":"CategoryTheory.prod_comp_snd","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù Y‚úù Z‚úù : Prod C D\nf : Quiver.Hom X‚úù Y‚úù\ng : Quiver.Hom Y‚úù Z‚úù\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).2 (CategoryTheory.CategoryStruct.comp f.2 g.2)","decl":"/-- `prod C D` gives the cartesian product of two categories. -/\n@[simps (config := { notRecursive := [] }) Hom id_fst id_snd comp_fst comp_snd, stacks 001K]\ninstance prod : Category.{max v‚ÇÅ v‚ÇÇ} (C √ó D) where\n  Hom X Y := (X.1 ‚ü∂ Y.1) √ó (X.2 ‚ü∂ Y.2)\n  id X := ‚ü®ùüô X.1, ùüô X.2‚ü©\n  comp f g := (f.1 ‚â´ g.1, f.2 ‚â´ g.2)\n\n"}
{"name":"CategoryTheory.prod.hom_ext","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX Y : Prod C D\nf g : Quiver.Hom X Y\nh‚ÇÅ : Eq f.1 g.1\nh‚ÇÇ : Eq f.2 g.2\n‚ä¢ Eq f g","decl":"@[ext]\nlemma prod.hom_ext {X Y : C √ó D} {f g : X ‚ü∂ Y} (h‚ÇÅ : f.1 = g.1) (h‚ÇÇ : f.2 = g.2) : f = g := by\n  dsimp\n  ext <;> assumption\n\n"}
{"name":"CategoryTheory.prod.hom_ext_iff","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX Y : Prod C D\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (And (Eq f.1 g.1) (Eq f.2 g.2))","decl":"@[ext]\nlemma prod.hom_ext {X Y : C √ó D} {f g : X ‚ü∂ Y} (h‚ÇÅ : f.1 = g.1) (h‚ÇÇ : f.2 = g.2) : f = g := by\n  dsimp\n  ext <;> assumption\n\n"}
{"name":"CategoryTheory.prod_id","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : C\nY : D\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id { fst := X, snd := Y }) { fst := CategoryTheory.CategoryStruct.id X, snd := CategoryTheory.CategoryStruct.id Y }","decl":"/-- Two rfl lemmas that cannot be generated by `@[simps]`. -/\n@[simp]\ntheorem prod_id (X : C) (Y : D) : ùüô (X, Y) = (ùüô X, ùüô Y) :=\n  rfl\n\n"}
{"name":"CategoryTheory.prod_comp","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nP Q R : C\nS T U : D\nf : Quiver.Hom { fst := P, snd := S } { fst := Q, snd := T }\ng : Quiver.Hom { fst := Q, snd := T } { fst := R, snd := U }\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g) { fst := CategoryTheory.CategoryStruct.comp f.1 g.1, snd := CategoryTheory.CategoryStruct.comp f.2 g.2 }","decl":"@[simp]\ntheorem prod_comp {P Q R : C} {S T U : D} (f : (P, S) ‚ü∂ (Q, T)) (g : (Q, T) ‚ü∂ (R, U)) :\n    f ‚â´ g = (f.1 ‚â´ g.1, f.2 ‚â´ g.2) :=\n  rfl\n\n"}
{"name":"CategoryTheory.isIso_prod_iff","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nP Q : C\nS T : D\nf : Quiver.Hom { fst := P, snd := S } { fst := Q, snd := T }\n‚ä¢ Iff (CategoryTheory.IsIso f) (And (CategoryTheory.IsIso f.1) (CategoryTheory.IsIso f.2))","decl":"theorem isIso_prod_iff {P Q : C} {S T : D} {f : (P, S) ‚ü∂ (Q, T)} :\n    IsIso f ‚Üî IsIso f.1 ‚àß IsIso f.2 := by\n  constructor\n  ¬∑ rintro ‚ü®g, hfg, hgf‚ü©\n    simp? at hfg hgf says simp only [prod_Hom, prod_comp, prod_id, Prod.mk.injEq] at hfg hgf\n    rcases hfg with ‚ü®hfg‚ÇÅ, hfg‚ÇÇ‚ü©\n    rcases hgf with ‚ü®hgf‚ÇÅ, hgf‚ÇÇ‚ü©\n    exact ‚ü®‚ü®‚ü®g.1, hfg‚ÇÅ, hgf‚ÇÅ‚ü©‚ü©, ‚ü®‚ü®g.2, hfg‚ÇÇ, hgf‚ÇÇ‚ü©‚ü©‚ü©\n  ¬∑ rintro ‚ü®‚ü®g‚ÇÅ, hfg‚ÇÅ, hgf‚ÇÅ‚ü©, ‚ü®g‚ÇÇ, hfg‚ÇÇ, hgf‚ÇÇ‚ü©‚ü©\n    dsimp at hfg‚ÇÅ hgf‚ÇÅ hfg‚ÇÇ hgf‚ÇÇ\n    refine ‚ü®‚ü®(g‚ÇÅ, g‚ÇÇ), ?_, ?_‚ü©‚ü©\n    repeat { simp; constructor; assumption; assumption }\n\n"}
{"name":"CategoryTheory.prod.etaIso_hom","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : Prod C D\n‚ä¢ Eq (CategoryTheory.prod.etaIso X).hom { fst := CategoryTheory.CategoryStruct.id { fst := X.1, snd := X.2 }.1, snd := CategoryTheory.CategoryStruct.id { fst := X.1, snd := X.2 }.2 }","decl":"/-- The isomorphism between `(X.1, X.2)` and `X`. -/\n@[simps]\ndef prod.etaIso (X : C √ó D) : (X.1, X.2) ‚âÖ X where\n  hom := (ùüô _, ùüô _)\n  inv := (ùüô _, ùüô _)\n\n"}
{"name":"CategoryTheory.prod.etaIso_inv","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : Prod C D\n‚ä¢ Eq (CategoryTheory.prod.etaIso X).inv { fst := CategoryTheory.CategoryStruct.id X.1, snd := CategoryTheory.CategoryStruct.id X.2 }","decl":"/-- The isomorphism between `(X.1, X.2)` and `X`. -/\n@[simps]\ndef prod.etaIso (X : C √ó D) : (X.1, X.2) ‚âÖ X where\n  hom := (ùüô _, ùüô _)\n  inv := (ùüô _, ùüô _)\n\n"}
{"name":"CategoryTheory.Iso.prod_hom","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nP Q : C\nS T : D\nf : CategoryTheory.Iso P Q\ng : CategoryTheory.Iso S T\n‚ä¢ Eq (f.prod g).hom { fst := f.hom, snd := g.hom }","decl":"/-- Construct an isomorphism in `C √ó D` out of two isomorphisms in `C` and `D`. -/\n@[simps]\ndef Iso.prod {P Q : C} {S T : D} (f : P ‚âÖ Q) (g : S ‚âÖ T) : (P, S) ‚âÖ (Q, T) where\n  hom := (f.hom, g.hom)\n  inv := (f.inv, g.inv)\n\n"}
{"name":"CategoryTheory.Iso.prod_inv","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nP Q : C\nS T : D\nf : CategoryTheory.Iso P Q\ng : CategoryTheory.Iso S T\n‚ä¢ Eq (f.prod g).inv { fst := f.inv, snd := g.inv }","decl":"/-- Construct an isomorphism in `C √ó D` out of two isomorphisms in `C` and `D`. -/\n@[simps]\ndef Iso.prod {P Q : C} {S T : D} (f : P ‚âÖ Q) (g : S ‚âÖ T) : (P, S) ‚âÖ (Q, T) where\n  hom := (f.hom, g.hom)\n  inv := (f.inv, g.inv)\n\n"}
{"name":"CategoryTheory.Prod.sectL_map","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nZ : D\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Prod.sectL C Z).map f) { fst := f, snd := CategoryTheory.CategoryStruct.id Z }","decl":"/-- `sectL C Z` is the functor `C ‚•§ C √ó D` given by `X ‚Ü¶ (X, Z)`. -/\n@[simps]\ndef sectL (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D] (Z : D) : C ‚•§ C √ó D where\n  obj X := (X, Z)\n  map f := (f, ùüô Z)\n\n"}
{"name":"CategoryTheory.Prod.sectL_obj","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nZ : D\nX : C\n‚ä¢ Eq ((CategoryTheory.Prod.sectL C Z).obj X) { fst := X, snd := Z }","decl":"/-- `sectL C Z` is the functor `C ‚•§ C √ó D` given by `X ‚Ü¶ (X, Z)`. -/\n@[simps]\ndef sectL (C : Type u‚ÇÅ) [Category.{v‚ÇÅ} C] {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D] (Z : D) : C ‚•§ C √ó D where\n  obj X := (X, Z)\n  map f := (f, ùüô Z)\n\n"}
{"name":"CategoryTheory.Prod.sectR_obj","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nZ : C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : D\n‚ä¢ Eq ((CategoryTheory.Prod.sectR Z D).obj X) { fst := Z, snd := X }","decl":"/-- `sectR Z D` is the functor `D ‚•§ C √ó D` given by `Y ‚Ü¶ (Z, Y)` . -/\n@[simps]\ndef sectR {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] (Z : C) (D : Type u‚ÇÇ) [Category.{v‚ÇÇ} D] : D ‚•§ C √ó D where\n  obj X := (Z, X)\n  map f := (ùüô Z, f)\n\n"}
{"name":"CategoryTheory.Prod.sectR_map","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nZ : C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù Y‚úù : D\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Prod.sectR Z D).map f) { fst := CategoryTheory.CategoryStruct.id Z, snd := f }","decl":"/-- `sectR Z D` is the functor `D ‚•§ C √ó D` given by `Y ‚Ü¶ (Z, Y)` . -/\n@[simps]\ndef sectR {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] (Z : C) (D : Type u‚ÇÇ) [Category.{v‚ÇÇ} D] : D ‚•§ C √ó D where\n  obj X := (Z, X)\n  map f := (ùüô Z, f)\n\n"}
{"name":"CategoryTheory.Prod.sectl_obj","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nZ : D\nX : C\n‚ä¢ Eq ((CategoryTheory.Prod.sectL C Z).obj X) { fst := X, snd := Z }","decl":"@[deprecated (since := \"2024-11-12\")] alias sectl_obj := sectL_obj\n"}
{"name":"CategoryTheory.Prod.sectr_obj","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nZ : C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : D\n‚ä¢ Eq ((CategoryTheory.Prod.sectR Z D).obj X) { fst := Z, snd := X }","decl":"@[deprecated (since := \"2024-11-12\")] alias sectr_obj := sectR_obj\n"}
{"name":"CategoryTheory.Prod.sectl_map","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nZ : D\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Prod.sectL C Z).map f) { fst := f, snd := CategoryTheory.CategoryStruct.id Z }","decl":"@[deprecated (since := \"2024-11-12\")] alias sectl_map := sectL_map\n"}
{"name":"CategoryTheory.Prod.sectr_map","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nZ : C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù Y‚úù : D\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Prod.sectR Z D).map f) { fst := CategoryTheory.CategoryStruct.id Z, snd := f }","decl":"@[deprecated (since := \"2024-11-12\")] alias sectr_map := sectR_map\n\n"}
{"name":"CategoryTheory.Prod.fst_obj","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : Prod C D\n‚ä¢ Eq ((CategoryTheory.Prod.fst C D).obj X) X.1","decl":"/-- `fst` is the functor `(X, Y) ‚Ü¶ X`. -/\n@[simps]\ndef fst : C √ó D ‚•§ C where\n  obj X := X.1\n  map f := f.1\n\n"}
{"name":"CategoryTheory.Prod.fst_map","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù Y‚úù : Prod C D\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Prod.fst C D).map f) f.1","decl":"/-- `fst` is the functor `(X, Y) ‚Ü¶ X`. -/\n@[simps]\ndef fst : C √ó D ‚•§ C where\n  obj X := X.1\n  map f := f.1\n\n"}
{"name":"CategoryTheory.Prod.snd_obj","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : Prod C D\n‚ä¢ Eq ((CategoryTheory.Prod.snd C D).obj X) X.2","decl":"/-- `snd` is the functor `(X, Y) ‚Ü¶ Y`. -/\n@[simps]\ndef snd : C √ó D ‚•§ D where\n  obj X := X.2\n  map f := f.2\n\n"}
{"name":"CategoryTheory.Prod.snd_map","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù Y‚úù : Prod C D\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Prod.snd C D).map f) f.2","decl":"/-- `snd` is the functor `(X, Y) ‚Ü¶ Y`. -/\n@[simps]\ndef snd : C √ó D ‚•§ D where\n  obj X := X.2\n  map f := f.2\n\n"}
{"name":"CategoryTheory.Prod.swap_map","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù Y‚úù : Prod C D\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Prod.swap C D).map f) { fst := f.2, snd := f.1 }","decl":"/-- The functor swapping the factors of a cartesian product of categories, `C √ó D ‚•§ D √ó C`. -/\n@[simps]\ndef swap : C √ó D ‚•§ D √ó C where\n  obj X := (X.2, X.1)\n  map f := (f.2, f.1)\n\n"}
{"name":"CategoryTheory.Prod.swap_obj","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : Prod C D\n‚ä¢ Eq ((CategoryTheory.Prod.swap C D).obj X) { fst := X.2, snd := X.1 }","decl":"/-- The functor swapping the factors of a cartesian product of categories, `C √ó D ‚•§ D √ó C`. -/\n@[simps]\ndef swap : C √ó D ‚•§ D √ó C where\n  obj X := (X.2, X.1)\n  map f := (f.2, f.1)\n\n"}
{"name":"CategoryTheory.Prod.symmetry_inv_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : Prod C D\n‚ä¢ Eq ((CategoryTheory.Prod.symmetry C D).inv.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- Swapping the factors of a cartesian product of categories twice is naturally isomorphic\nto the identity functor.\n-/\n@[simps]\ndef symmetry : swap C D ‚ãô swap D C ‚âÖ ùü≠ (C √ó D) where\n  hom := { app := fun X => ùüô X }\n  inv := { app := fun X => ùüô X }\n\n"}
{"name":"CategoryTheory.Prod.symmetry_hom_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : Prod C D\n‚ä¢ Eq ((CategoryTheory.Prod.symmetry C D).hom.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- Swapping the factors of a cartesian product of categories twice is naturally isomorphic\nto the identity functor.\n-/\n@[simps]\ndef symmetry : swap C D ‚ãô swap D C ‚âÖ ùü≠ (C √ó D) where\n  hom := { app := fun X => ùüô X }\n  inv := { app := fun X => ùüô X }\n\n"}
{"name":"CategoryTheory.Prod.braiding_inverse","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\n‚ä¢ Eq (CategoryTheory.Prod.braiding C D).inverse (CategoryTheory.Prod.swap D C)","decl":"/-- The equivalence, given by swapping factors, between `C √ó D` and `D √ó C`.\n-/\n@[simps]\ndef braiding : C √ó D ‚âå D √ó C where\n  functor := swap C D\n  inverse := swap D C\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Prod.braiding_counitIso","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\n‚ä¢ Eq (CategoryTheory.Prod.braiding C D).counitIso (CategoryTheory.Iso.refl ((CategoryTheory.Prod.swap D C).comp (CategoryTheory.Prod.swap C D)))","decl":"/-- The equivalence, given by swapping factors, between `C √ó D` and `D √ó C`.\n-/\n@[simps]\ndef braiding : C √ó D ‚âå D √ó C where\n  functor := swap C D\n  inverse := swap D C\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Prod.braiding_functor","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\n‚ä¢ Eq (CategoryTheory.Prod.braiding C D).functor (CategoryTheory.Prod.swap C D)","decl":"/-- The equivalence, given by swapping factors, between `C √ó D` and `D √ó C`.\n-/\n@[simps]\ndef braiding : C √ó D ‚âå D √ó C where\n  functor := swap C D\n  inverse := swap D C\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Prod.braiding_unitIso","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\n‚ä¢ Eq (CategoryTheory.Prod.braiding C D).unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (Prod C D)))","decl":"/-- The equivalence, given by swapping factors, between `C √ó D` and `D √ó C`.\n-/\n@[simps]\ndef braiding : C √ó D ‚âå D √ó C where\n  functor := swap C D\n  inverse := swap D C\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.Prod.swapIsEquivalence","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\n‚ä¢ (CategoryTheory.Prod.swap C D).IsEquivalence","decl":"instance swapIsEquivalence : (swap C D).IsEquivalence :=\n  (by infer_instance : (braiding C D).functor.IsEquivalence)\n\n"}
{"name":"CategoryTheory.evaluation_obj_obj","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : C\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (((CategoryTheory.evaluation C D).obj X).obj F) (F.obj X)","decl":"/-- The \"evaluation at `X`\" functor, such that\n`(evaluation.obj X).obj F = F.obj X`,\nwhich is functorial in both `X` and `F`.\n-/\n@[simps]\ndef evaluation : C ‚•§ (C ‚•§ D) ‚•§ D where\n  obj X :=\n    { obj := fun F => F.obj X\n      map := fun Œ± => Œ±.app X }\n  map {_} {_} f :=\n    { app := fun F => F.map f\n      naturality := fun {_} {_} Œ± => Eq.symm (Œ±.naturality f) }\n\n"}
{"name":"CategoryTheory.evaluation_obj_map","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : C\nX‚úù Y‚úù : CategoryTheory.Functor C D\nŒ± : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((CategoryTheory.evaluation C D).obj X).map Œ±) (Œ±.app X)","decl":"/-- The \"evaluation at `X`\" functor, such that\n`(evaluation.obj X).obj F = F.obj X`,\nwhich is functorial in both `X` and `F`.\n-/\n@[simps]\ndef evaluation : C ‚•§ (C ‚•§ D) ‚•§ D where\n  obj X :=\n    { obj := fun F => F.obj X\n      map := fun Œ± => Œ±.app X }\n  map {_} {_} f :=\n    { app := fun F => F.map f\n      naturality := fun {_} {_} Œ± => Eq.symm (Œ±.naturality f) }\n\n"}
{"name":"CategoryTheory.evaluation_map_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nx‚úù¬π x‚úù : C\nf : Quiver.Hom x‚úù¬π x‚úù\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (((CategoryTheory.evaluation C D).map f).app F) (F.map f)","decl":"/-- The \"evaluation at `X`\" functor, such that\n`(evaluation.obj X).obj F = F.obj X`,\nwhich is functorial in both `X` and `F`.\n-/\n@[simps]\ndef evaluation : C ‚•§ (C ‚•§ D) ‚•§ D where\n  obj X :=\n    { obj := fun F => F.obj X\n      map := fun Œ± => Œ±.app X }\n  map {_} {_} f :=\n    { app := fun F => F.map f\n      naturality := fun {_} {_} Œ± => Eq.symm (Œ±.naturality f) }\n\n"}
{"name":"CategoryTheory.evaluationUncurried_map","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nx y : Prod C (CategoryTheory.Functor C D)\nf : Quiver.Hom x y\n‚ä¢ Eq ((CategoryTheory.evaluationUncurried C D).map f) (CategoryTheory.CategoryStruct.comp (x.2.map f.1) (f.2.app y.1))","decl":"/-- The \"evaluation of `F` at `X`\" functor,\nas a functor `C √ó (C ‚•§ D) ‚•§ D`.\n-/\n@[simps]\ndef evaluationUncurried : C √ó (C ‚•§ D) ‚•§ D where\n  obj p := p.2.obj p.1\n  map := fun {x} {y} f => x.2.map f.1 ‚â´ f.2.app y.1\n  map_comp := fun {X} {Y} {Z} f g => by\n    cases g; cases f; cases Z; cases Y; cases X\n    simp only [prod_comp, NatTrans.comp_app, Functor.map_comp, Category.assoc]\n    rw [‚Üê NatTrans.comp_app, NatTrans.naturality, NatTrans.comp_app, Category.assoc,\n      NatTrans.naturality]\n\n"}
{"name":"CategoryTheory.evaluationUncurried_obj","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\np : Prod C (CategoryTheory.Functor C D)\n‚ä¢ Eq ((CategoryTheory.evaluationUncurried C D).obj p) (p.2.obj p.1)","decl":"/-- The \"evaluation of `F` at `X`\" functor,\nas a functor `C √ó (C ‚•§ D) ‚•§ D`.\n-/\n@[simps]\ndef evaluationUncurried : C √ó (C ‚•§ D) ‚•§ D where\n  obj p := p.2.obj p.1\n  map := fun {x} {y} f => x.2.map f.1 ‚â´ f.2.app y.1\n  map_comp := fun {X} {Y} {Z} f g => by\n    cases g; cases f; cases Z; cases Y; cases X\n    simp only [prod_comp, NatTrans.comp_app, Functor.map_comp, Category.assoc]\n    rw [‚Üê NatTrans.comp_app, NatTrans.naturality, NatTrans.comp_app, Category.assoc,\n      NatTrans.naturality]\n\n"}
{"name":"CategoryTheory.Functor.constCompEvaluationObj_inv_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : C\nX : D\n‚ä¢ Eq ((CategoryTheory.Functor.constCompEvaluationObj D X‚úù).inv.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The constant functor followed by the evaluation functor is just the identity. -/\n@[simps!]\ndef Functor.constCompEvaluationObj (X : C) : Functor.const C ‚ãô (evaluation C D).obj X ‚âÖ ùü≠ D :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.constCompEvaluationObj_hom_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX‚úù : C\nX : D\n‚ä¢ Eq ((CategoryTheory.Functor.constCompEvaluationObj D X‚úù).hom.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The constant functor followed by the evaluation functor is just the identity. -/\n@[simps!]\ndef Functor.constCompEvaluationObj (X : C) : Functor.const C ‚ãô (evaluation C D).obj X ‚âÖ ùü≠ D :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.prod_map","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor C D\nX‚úù Y‚úù : Prod A C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((F.prod G).map f) { fst := F.map f.1, snd := G.map f.2 }","decl":"/-- The cartesian product of two functors. -/\n@[simps]\ndef prod (F : A ‚•§ B) (G : C ‚•§ D) : A √ó C ‚•§ B √ó D where\n  obj X := (F.obj X.1, G.obj X.2)\n  map f := (F.map f.1, G.map f.2)\n\n/- Because of limitations in Lean 3's handling of notations, we do not setup a notation `F √ó G`.\n   You can use `F.prod G` as a \"poor man's infix\", or just write `functor.prod F G`. -/\n"}
{"name":"CategoryTheory.Functor.prod_obj","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor C D\nX : Prod A C\n‚ä¢ Eq ((F.prod G).obj X) { fst := F.obj X.1, snd := G.obj X.2 }","decl":"/-- The cartesian product of two functors. -/\n@[simps]\ndef prod (F : A ‚•§ B) (G : C ‚•§ D) : A √ó C ‚•§ B √ó D where\n  obj X := (F.obj X.1, G.obj X.2)\n  map f := (F.map f.1, G.map f.2)\n\n/- Because of limitations in Lean 3's handling of notations, we do not setup a notation `F √ó G`.\n   You can use `F.prod G` as a \"poor man's infix\", or just write `functor.prod F G`. -/\n"}
{"name":"CategoryTheory.Functor.prod'_obj","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor A C\na : A\n‚ä¢ Eq ((F.prod' G).obj a) { fst := F.obj a, snd := G.obj a }","decl":"/-- Similar to `prod`, but both functors start from the same category `A` -/\n@[simps]\ndef prod' (F : A ‚•§ B) (G : A ‚•§ C) : A ‚•§ B √ó C where\n  obj a := (F.obj a, G.obj a)\n  map f := (F.map f, G.map f)\n\n"}
{"name":"CategoryTheory.Functor.prod'_map","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor A C\nX‚úù Y‚úù : A\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((F.prod' G).map f) { fst := F.map f, snd := G.map f }","decl":"/-- Similar to `prod`, but both functors start from the same category `A` -/\n@[simps]\ndef prod' (F : A ‚•§ B) (G : A ‚•§ C) : A ‚•§ B √ó C where\n  obj a := (F.obj a, G.obj a)\n  map f := (F.map f, G.map f)\n\n"}
{"name":"CategoryTheory.Functor.prod'CompFst_hom_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor A C\nX : A\n‚ä¢ Eq ((F.prod'CompFst G).hom.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The product `F.prod' G` followed by projection on the first component is isomorphic to `F` -/\n@[simps!]\ndef prod'CompFst (F : A ‚•§ B) (G : A ‚•§ C) : F.prod' G ‚ãô CategoryTheory.Prod.fst B C ‚âÖ F :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.prod'CompFst_inv_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor A C\nX : A\n‚ä¢ Eq ((F.prod'CompFst G).inv.app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"/-- The product `F.prod' G` followed by projection on the first component is isomorphic to `F` -/\n@[simps!]\ndef prod'CompFst (F : A ‚•§ B) (G : A ‚•§ C) : F.prod' G ‚ãô CategoryTheory.Prod.fst B C ‚âÖ F :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.prod'CompSnd_inv_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor A C\nX : A\n‚ä¢ Eq ((F.prod'CompSnd G).inv.app X) (CategoryTheory.CategoryStruct.id (G.obj X))","decl":"/-- The product `F.prod' G` followed by projection on the second component is isomorphic to `G` -/\n@[simps!]\ndef prod'CompSnd (F : A ‚•§ B) (G : A ‚•§ C) : F.prod' G ‚ãô CategoryTheory.Prod.snd B C ‚âÖ G :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.prod'CompSnd_hom_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor A C\nX : A\n‚ä¢ Eq ((F.prod'CompSnd G).hom.app X) (CategoryTheory.CategoryStruct.id (G.obj X))","decl":"/-- The product `F.prod' G` followed by projection on the second component is isomorphic to `G` -/\n@[simps!]\ndef prod'CompSnd (F : A ‚•§ B) (G : A ‚•§ C) : F.prod' G ‚ãô CategoryTheory.Prod.snd B C ‚âÖ G :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.diag_obj","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nX : C\n‚ä¢ Eq ((CategoryTheory.Functor.diag C).obj X) { fst := X, snd := X }","decl":"@[simp]\ntheorem diag_obj (X : C) : (diag C).obj X = (X, X) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.diag_map","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.Functor.diag C).map f) { fst := f, snd := f }","decl":"@[simp]\ntheorem diag_map {X Y : C} (f : X ‚ü∂ Y) : (diag C).map f = (f, f) :=\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.prod_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF G : CategoryTheory.Functor A B\nH I : CategoryTheory.Functor C D\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom H I\nX : Prod A C\n‚ä¢ Eq ((CategoryTheory.NatTrans.prod Œ± Œ≤).app X) { fst := Œ±.app X.1, snd := Œ≤.app X.2 }","decl":"/-- The cartesian product of two natural transformations. -/\n@[simps]\ndef prod {F G : A ‚•§ B} {H I : C ‚•§ D} (Œ± : F ‚ü∂ G) (Œ≤ : H ‚ü∂ I) : F.prod H ‚ü∂ G.prod I where\n  app X := (Œ±.app X.1, Œ≤.app X.2)\n  naturality {X} {Y} f := by\n    cases X; cases Y\n    simp only [Functor.prod_map, prod_comp]\n    rw [Prod.mk.inj_iff]\n    constructor\n    repeat {rw [naturality]}\n\n/- Again, it is inadvisable in Lean 3 to setup a notation `Œ± √ó Œ≤`;\n   use instead `Œ±.prod Œ≤` or `NatTrans.prod Œ± Œ≤`. -/\n\n"}
{"name":"CategoryTheory.NatTrans.prod'_app_fst","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF G : CategoryTheory.Functor A C\nH K : CategoryTheory.Functor A D\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom H K\nX : A\n‚ä¢ Eq ((CategoryTheory.NatTrans.prod' Œ± Œ≤).app X).1 (Œ±.app X)","decl":"@[simp] lemma prod'_app_fst (X : A) : ((prod' Œ± Œ≤).app X).1 = Œ±.app X := rfl\n"}
{"name":"CategoryTheory.NatTrans.prod'_app_snd","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF G : CategoryTheory.Functor A C\nH K : CategoryTheory.Functor A D\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom H K\nX : A\n‚ä¢ Eq ((CategoryTheory.NatTrans.prod' Œ± Œ≤).app X).2 (Œ≤.app X)","decl":"@[simp] lemma prod'_app_snd (X : A) : ((prod' Œ± Œ≤).app X).2 = Œ≤.app X := rfl\n\n"}
{"name":"CategoryTheory.prodFunctor_map","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nX‚úù Y‚úù : Prod (CategoryTheory.Functor A B) (CategoryTheory.Functor C D)\nnm : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.prodFunctor.map nm) (CategoryTheory.NatTrans.prod nm.1 nm.2)","decl":"/-- The cartesian product functor between functor categories -/\n@[simps]\ndef prodFunctor : (A ‚•§ B) √ó (C ‚•§ D) ‚•§ A √ó C ‚•§ B √ó D where\n  obj FG := FG.1.prod FG.2\n  map nm := NatTrans.prod nm.1 nm.2\n\n"}
{"name":"CategoryTheory.prodFunctor_obj","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nFG : Prod (CategoryTheory.Functor A B) (CategoryTheory.Functor C D)\n‚ä¢ Eq (CategoryTheory.prodFunctor.obj FG) (FG.1.prod FG.2)","decl":"/-- The cartesian product functor between functor categories -/\n@[simps]\ndef prodFunctor : (A ‚•§ B) √ó (C ‚•§ D) ‚•§ A √ó C ‚•§ B √ó D where\n  obj FG := FG.1.prod FG.2\n  map nm := NatTrans.prod nm.1 nm.2\n\n"}
{"name":"CategoryTheory.NatIso.prod_hom","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF F' : CategoryTheory.Functor A B\nG G' : CategoryTheory.Functor C D\ne‚ÇÅ : CategoryTheory.Iso F F'\ne‚ÇÇ : CategoryTheory.Iso G G'\n‚ä¢ Eq (CategoryTheory.NatIso.prod e‚ÇÅ e‚ÇÇ).hom (CategoryTheory.NatTrans.prod e‚ÇÅ.hom e‚ÇÇ.hom)","decl":"/-- The cartesian product of two natural isomorphisms. -/\n@[simps]\ndef prod {F F' : A ‚•§ B} {G G' : C ‚•§ D} (e‚ÇÅ : F ‚âÖ F') (e‚ÇÇ : G ‚âÖ G') :\n    F.prod G ‚âÖ F'.prod G' where\n  hom := NatTrans.prod e‚ÇÅ.hom e‚ÇÇ.hom\n  inv := NatTrans.prod e‚ÇÅ.inv e‚ÇÇ.inv\n\n"}
{"name":"CategoryTheory.NatIso.prod_inv","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nF F' : CategoryTheory.Functor A B\nG G' : CategoryTheory.Functor C D\ne‚ÇÅ : CategoryTheory.Iso F F'\ne‚ÇÇ : CategoryTheory.Iso G G'\n‚ä¢ Eq (CategoryTheory.NatIso.prod e‚ÇÅ e‚ÇÇ).inv (CategoryTheory.NatTrans.prod e‚ÇÅ.inv e‚ÇÇ.inv)","decl":"/-- The cartesian product of two natural isomorphisms. -/\n@[simps]\ndef prod {F F' : A ‚•§ B} {G G' : C ‚•§ D} (e‚ÇÅ : F ‚âÖ F') (e‚ÇÇ : G ‚âÖ G') :\n    F.prod G ‚âÖ F'.prod G' where\n  hom := NatTrans.prod e‚ÇÅ.hom e‚ÇÇ.hom\n  inv := NatTrans.prod e‚ÇÅ.inv e‚ÇÇ.inv\n\n"}
{"name":"CategoryTheory.Equivalence.prod_functor","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nE‚ÇÅ : CategoryTheory.Equivalence A B\nE‚ÇÇ : CategoryTheory.Equivalence C D\n‚ä¢ Eq (E‚ÇÅ.prod E‚ÇÇ).functor (E‚ÇÅ.functor.prod E‚ÇÇ.functor)","decl":"/-- The cartesian product of two equivalences of categories. -/\n@[simps]\ndef prod (E‚ÇÅ : A ‚âå B) (E‚ÇÇ : C ‚âå D) : A √ó C ‚âå B √ó D where\n  functor := E‚ÇÅ.functor.prod E‚ÇÇ.functor\n  inverse := E‚ÇÅ.inverse.prod E‚ÇÇ.inverse\n  unitIso := NatIso.prod E‚ÇÅ.unitIso E‚ÇÇ.unitIso\n  counitIso := NatIso.prod E‚ÇÅ.counitIso E‚ÇÇ.counitIso\n\n"}
{"name":"CategoryTheory.Equivalence.prod_inverse","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nE‚ÇÅ : CategoryTheory.Equivalence A B\nE‚ÇÇ : CategoryTheory.Equivalence C D\n‚ä¢ Eq (E‚ÇÅ.prod E‚ÇÇ).inverse (E‚ÇÅ.inverse.prod E‚ÇÇ.inverse)","decl":"/-- The cartesian product of two equivalences of categories. -/\n@[simps]\ndef prod (E‚ÇÅ : A ‚âå B) (E‚ÇÇ : C ‚âå D) : A √ó C ‚âå B √ó D where\n  functor := E‚ÇÅ.functor.prod E‚ÇÇ.functor\n  inverse := E‚ÇÅ.inverse.prod E‚ÇÇ.inverse\n  unitIso := NatIso.prod E‚ÇÅ.unitIso E‚ÇÇ.unitIso\n  counitIso := NatIso.prod E‚ÇÅ.counitIso E‚ÇÇ.counitIso\n\n"}
{"name":"CategoryTheory.Equivalence.prod_counitIso","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nE‚ÇÅ : CategoryTheory.Equivalence A B\nE‚ÇÇ : CategoryTheory.Equivalence C D\n‚ä¢ Eq (E‚ÇÅ.prod E‚ÇÇ).counitIso (CategoryTheory.NatIso.prod E‚ÇÅ.counitIso E‚ÇÇ.counitIso)","decl":"/-- The cartesian product of two equivalences of categories. -/\n@[simps]\ndef prod (E‚ÇÅ : A ‚âå B) (E‚ÇÇ : C ‚âå D) : A √ó C ‚âå B √ó D where\n  functor := E‚ÇÅ.functor.prod E‚ÇÇ.functor\n  inverse := E‚ÇÅ.inverse.prod E‚ÇÇ.inverse\n  unitIso := NatIso.prod E‚ÇÅ.unitIso E‚ÇÇ.unitIso\n  counitIso := NatIso.prod E‚ÇÅ.counitIso E‚ÇÇ.counitIso\n\n"}
{"name":"CategoryTheory.Equivalence.prod_unitIso","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nE‚ÇÅ : CategoryTheory.Equivalence A B\nE‚ÇÇ : CategoryTheory.Equivalence C D\n‚ä¢ Eq (E‚ÇÅ.prod E‚ÇÇ).unitIso (CategoryTheory.NatIso.prod E‚ÇÅ.unitIso E‚ÇÇ.unitIso)","decl":"/-- The cartesian product of two equivalences of categories. -/\n@[simps]\ndef prod (E‚ÇÅ : A ‚âå B) (E‚ÇÇ : C ‚âå D) : A √ó C ‚âå B √ó D where\n  functor := E‚ÇÅ.functor.prod E‚ÇÇ.functor\n  inverse := E‚ÇÅ.inverse.prod E‚ÇÇ.inverse\n  unitIso := NatIso.prod E‚ÇÅ.unitIso E‚ÇÇ.unitIso\n  counitIso := NatIso.prod E‚ÇÅ.counitIso E‚ÇÇ.counitIso\n\n"}
{"name":"CategoryTheory.flipCompEvaluation_hom_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor A (CategoryTheory.Functor B C)\na : A\nX : B\n‚ä¢ Eq ((CategoryTheory.flipCompEvaluation F a).hom.app X) (CategoryTheory.CategoryStruct.id ((F.obj a).obj X))","decl":"/-- `F.flip` composed with evaluation is the same as evaluating `F`. -/\n@[simps!]\ndef flipCompEvaluation (F : A ‚•§ B ‚•§ C) (a) : F.flip ‚ãô (evaluation _ _).obj a ‚âÖ F.obj a :=\n  NatIso.ofComponents fun b => Iso.refl _\n\n"}
{"name":"CategoryTheory.flipCompEvaluation_inv_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor A (CategoryTheory.Functor B C)\na : A\nX : B\n‚ä¢ Eq ((CategoryTheory.flipCompEvaluation F a).inv.app X) (CategoryTheory.CategoryStruct.id ((F.obj a).obj X))","decl":"/-- `F.flip` composed with evaluation is the same as evaluating `F`. -/\n@[simps!]\ndef flipCompEvaluation (F : A ‚•§ B ‚•§ C) (a) : F.flip ‚ãô (evaluation _ _).obj a ‚âÖ F.obj a :=\n  NatIso.ofComponents fun b => Iso.refl _\n\n"}
{"name":"CategoryTheory.flip_comp_evaluation","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor A (CategoryTheory.Functor B C)\na : A\n‚ä¢ Eq (F.flip.comp ((CategoryTheory.evaluation A C).obj a)) (F.obj a)","decl":"theorem flip_comp_evaluation (F : A ‚•§ B ‚•§ C) (a) : F.flip ‚ãô (evaluation _ _).obj a = F.obj a :=\n  rfl\n\n"}
{"name":"CategoryTheory.compEvaluation_inv_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor A (CategoryTheory.Functor B C)\nb : B\nX : A\n‚ä¢ Eq ((CategoryTheory.compEvaluation F b).inv.app X) (CategoryTheory.CategoryStruct.id ((F.obj X).obj b))","decl":"/-- `F` composed with evaluation is the same as evaluating `F.flip`. -/\n@[simps!]\ndef compEvaluation (F : A ‚•§ B ‚•§ C) (b) : F ‚ãô (evaluation _ _).obj b ‚âÖ F.flip.obj b :=\n  NatIso.ofComponents fun a => Iso.refl _\n\n"}
{"name":"CategoryTheory.compEvaluation_hom_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor A (CategoryTheory.Functor B C)\nb : B\nX : A\n‚ä¢ Eq ((CategoryTheory.compEvaluation F b).hom.app X) (CategoryTheory.CategoryStruct.id ((F.obj X).obj b))","decl":"/-- `F` composed with evaluation is the same as evaluating `F.flip`. -/\n@[simps!]\ndef compEvaluation (F : A ‚•§ B ‚•§ C) (b) : F ‚ãô (evaluation _ _).obj b ‚âÖ F.flip.obj b :=\n  NatIso.ofComponents fun a => Iso.refl _\n\n"}
{"name":"CategoryTheory.comp_evaluation","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor A (CategoryTheory.Functor B C)\nb : B\n‚ä¢ Eq (F.comp ((CategoryTheory.evaluation B C).obj b)) (F.flip.obj b)","decl":"theorem comp_evaluation (F : A ‚•§ B ‚•§ C) (b) : F ‚ãô (evaluation _ _).obj b = F.flip.obj b :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskeringLeftCompEvaluation_hom_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor A B\na : A\nX : CategoryTheory.Functor B C\n‚ä¢ Eq ((CategoryTheory.whiskeringLeftCompEvaluation F a).hom.app X) (CategoryTheory.CategoryStruct.id (X.obj (F.obj a)))","decl":"/-- Whiskering by `F` and then evaluating at `a` is the same as evaluating at `F.obj a`. -/\n@[simps!]\ndef whiskeringLeftCompEvaluation (F : A ‚•§ B) (a : A) :\n    (whiskeringLeft A B C).obj F ‚ãô (evaluation A C).obj a ‚âÖ (evaluation B C).obj (F.obj a) :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.whiskeringLeftCompEvaluation_inv_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor A B\na : A\nX : CategoryTheory.Functor B C\n‚ä¢ Eq ((CategoryTheory.whiskeringLeftCompEvaluation F a).inv.app X) (CategoryTheory.CategoryStruct.id (X.obj (F.obj a)))","decl":"/-- Whiskering by `F` and then evaluating at `a` is the same as evaluating at `F.obj a`. -/\n@[simps!]\ndef whiskeringLeftCompEvaluation (F : A ‚•§ B) (a : A) :\n    (whiskeringLeft A B C).obj F ‚ãô (evaluation A C).obj a ‚âÖ (evaluation B C).obj (F.obj a) :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.whiskeringLeft_comp_evaluation","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor A B\na : A\n‚ä¢ Eq (((CategoryTheory.whiskeringLeft A B C).obj F).comp ((CategoryTheory.evaluation A C).obj a)) ((CategoryTheory.evaluation B C).obj (F.obj a))","decl":"/-- Whiskering by `F` and then evaluating at `a` is the same as evaluating at `F.obj a`. -/\n@[simp]\ntheorem whiskeringLeft_comp_evaluation (F : A ‚•§ B) (a : A) :\n    (whiskeringLeft A B C).obj F ‚ãô (evaluation A C).obj a = (evaluation B C).obj (F.obj a) :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskeringRightCompEvaluation_inv_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor B C\na : A\nX : CategoryTheory.Functor A B\n‚ä¢ Eq ((CategoryTheory.whiskeringRightCompEvaluation F a).inv.app X) (CategoryTheory.CategoryStruct.id (F.obj (X.obj a)))","decl":"/-- Whiskering by `F` and then evaluating at `a` is the same as evaluating at `F` and then\napplying `F`. -/\n@[simps!]\ndef whiskeringRightCompEvaluation (F : B ‚•§ C) (a : A) :\n    (whiskeringRight A B C).obj F ‚ãô (evaluation _ _).obj a ‚âÖ (evaluation _ _).obj a ‚ãô F :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.whiskeringRightCompEvaluation_hom_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor B C\na : A\nX : CategoryTheory.Functor A B\n‚ä¢ Eq ((CategoryTheory.whiskeringRightCompEvaluation F a).hom.app X) (CategoryTheory.CategoryStruct.id (F.obj (X.obj a)))","decl":"/-- Whiskering by `F` and then evaluating at `a` is the same as evaluating at `F` and then\napplying `F`. -/\n@[simps!]\ndef whiskeringRightCompEvaluation (F : B ‚•§ C) (a : A) :\n    (whiskeringRight A B C).obj F ‚ãô (evaluation _ _).obj a ‚âÖ (evaluation _ _).obj a ‚ãô F :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.whiskeringRight_comp_evaluation","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor B C\na : A\n‚ä¢ Eq (((CategoryTheory.whiskeringRight A B C).obj F).comp ((CategoryTheory.evaluation A C).obj a)) (((CategoryTheory.evaluation A B).obj a).comp F)","decl":"/-- Whiskering by `F` and then evaluating at `a` is the same as evaluating at `F` and then\napplying `F`. -/\n@[simp]\ntheorem whiskeringRight_comp_evaluation (F : B ‚•§ C) (a : A) :\n    (whiskeringRight A B C).obj F ‚ãô (evaluation _ _).obj a = (evaluation _ _).obj a ‚ãô F :=\n  rfl\n\n"}
{"name":"CategoryTheory.prodFunctorToFunctorProd_obj","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : Prod (CategoryTheory.Functor A B) (CategoryTheory.Functor A C)\n‚ä¢ Eq ((CategoryTheory.prodFunctorToFunctorProd A B C).obj F) (F.1.prod' F.2)","decl":"/-- The forward direction for `functorProdFunctorEquiv` -/\n@[simps]\ndef prodFunctorToFunctorProd : (A ‚•§ B) √ó (A ‚•§ C) ‚•§ A ‚•§ B √ó C where\n  obj F := F.1.prod' F.2\n  map f := { app := fun X => (f.1.app X, f.2.app X) }\n\n"}
{"name":"CategoryTheory.prodFunctorToFunctorProd_map_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nX‚úù Y‚úù : Prod (CategoryTheory.Functor A B) (CategoryTheory.Functor A C)\nf : Quiver.Hom X‚úù Y‚úù\nX : A\n‚ä¢ Eq (((CategoryTheory.prodFunctorToFunctorProd A B C).map f).app X) { fst := f.1.app X, snd := f.2.app X }","decl":"/-- The forward direction for `functorProdFunctorEquiv` -/\n@[simps]\ndef prodFunctorToFunctorProd : (A ‚•§ B) √ó (A ‚•§ C) ‚•§ A ‚•§ B √ó C where\n  obj F := F.1.prod' F.2\n  map f := { app := fun X => (f.1.app X, f.2.app X) }\n\n"}
{"name":"CategoryTheory.functorProdToProdFunctor_map","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nX‚úù Y‚úù : CategoryTheory.Functor A (Prod B C)\nŒ± : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.functorProdToProdFunctor A B C).map Œ±) { fst := { app := fun X => (Œ±.app X).1, naturality := ‚ãØ }, snd := { app := fun X => (Œ±.app X).2, naturality := ‚ãØ } }","decl":"/-- The backward direction for `functorProdFunctorEquiv` -/\n@[simps]\ndef functorProdToProdFunctor : (A ‚•§ B √ó C) ‚•§ (A ‚•§ B) √ó (A ‚•§ C) where\n  obj F := ‚ü®F ‚ãô CategoryTheory.Prod.fst B C, F ‚ãô CategoryTheory.Prod.snd B C‚ü©\n  map Œ± :=\n    ‚ü®{  app := fun X => (Œ±.app X).1\n        naturality := fun X Y f => by\n          simp only [Functor.comp_map, Prod.fst_map, ‚Üê prod_comp_fst, Œ±.naturality] },\n      { app := fun X => (Œ±.app X).2\n        naturality := fun X Y f => by\n          simp only [Functor.comp_map, Prod.snd_map, ‚Üê prod_comp_snd, Œ±.naturality] }‚ü©\n\n"}
{"name":"CategoryTheory.functorProdToProdFunctor_obj","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nF : CategoryTheory.Functor A (Prod B C)\n‚ä¢ Eq ((CategoryTheory.functorProdToProdFunctor A B C).obj F) { fst := F.comp (CategoryTheory.Prod.fst B C), snd := F.comp (CategoryTheory.Prod.snd B C) }","decl":"/-- The backward direction for `functorProdFunctorEquiv` -/\n@[simps]\ndef functorProdToProdFunctor : (A ‚•§ B √ó C) ‚•§ (A ‚•§ B) √ó (A ‚•§ C) where\n  obj F := ‚ü®F ‚ãô CategoryTheory.Prod.fst B C, F ‚ãô CategoryTheory.Prod.snd B C‚ü©\n  map Œ± :=\n    ‚ü®{  app := fun X => (Œ±.app X).1\n        naturality := fun X Y f => by\n          simp only [Functor.comp_map, Prod.fst_map, ‚Üê prod_comp_fst, Œ±.naturality] },\n      { app := fun X => (Œ±.app X).2\n        naturality := fun X Y f => by\n          simp only [Functor.comp_map, Prod.snd_map, ‚Üê prod_comp_snd, Œ±.naturality] }‚ü©\n\n"}
{"name":"CategoryTheory.functorProdFunctorEquivUnitIso_inv_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nX : Prod (CategoryTheory.Functor A B) (CategoryTheory.Functor A C)\n‚ä¢ Eq ((CategoryTheory.functorProdFunctorEquivUnitIso A B C).inv.app X) { fst := (X.1.prod'CompFst X.2).hom, snd := (X.1.prod'CompSnd X.2).hom }","decl":"/-- The unit isomorphism for `functorProdFunctorEquiv` -/\n@[simps!]\ndef functorProdFunctorEquivUnitIso :\n    ùü≠ _ ‚âÖ prodFunctorToFunctorProd A B C ‚ãô functorProdToProdFunctor A B C :=\n  NatIso.ofComponents fun F =>\n    (((Functor.prod'CompFst F.fst F.snd).prod (Functor.prod'CompSnd F.fst F.snd)).trans\n      (prod.etaIso F)).symm\n\n"}
{"name":"CategoryTheory.functorProdFunctorEquivUnitIso_hom_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nX : Prod (CategoryTheory.Functor A B) (CategoryTheory.Functor A C)\n‚ä¢ Eq ((CategoryTheory.functorProdFunctorEquivUnitIso A B C).hom.app X) { fst := (X.1.prod'CompFst X.2).inv, snd := (X.1.prod'CompSnd X.2).inv }","decl":"/-- The unit isomorphism for `functorProdFunctorEquiv` -/\n@[simps!]\ndef functorProdFunctorEquivUnitIso :\n    ùü≠ _ ‚âÖ prodFunctorToFunctorProd A B C ‚ãô functorProdToProdFunctor A B C :=\n  NatIso.ofComponents fun F =>\n    (((Functor.prod'CompFst F.fst F.snd).prod (Functor.prod'CompSnd F.fst F.snd)).trans\n      (prod.etaIso F)).symm\n\n"}
{"name":"CategoryTheory.functorProdFunctorEquivCounitIso_hom_app_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nX‚úù : CategoryTheory.Functor A (Prod B C)\nX : A\n‚ä¢ Eq (((CategoryTheory.functorProdFunctorEquivCounitIso A B C).hom.app X‚úù).app X) { fst := CategoryTheory.CategoryStruct.id (X‚úù.obj X).1, snd := CategoryTheory.CategoryStruct.id (X‚úù.obj X).2 }","decl":"/-- The counit isomorphism for `functorProdFunctorEquiv` -/\n@[simps!]\ndef functorProdFunctorEquivCounitIso :\n    functorProdToProdFunctor A B C ‚ãô prodFunctorToFunctorProd A B C ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents fun F => NatIso.ofComponents fun X => prod.etaIso (F.obj X)\n\n"}
{"name":"CategoryTheory.functorProdFunctorEquivCounitIso_inv_app_app","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nX‚úù : CategoryTheory.Functor A (Prod B C)\nX : A\n‚ä¢ Eq (((CategoryTheory.functorProdFunctorEquivCounitIso A B C).inv.app X‚úù).app X) { fst := CategoryTheory.CategoryStruct.id (X‚úù.obj X).1, snd := CategoryTheory.CategoryStruct.id (X‚úù.obj X).2 }","decl":"/-- The counit isomorphism for `functorProdFunctorEquiv` -/\n@[simps!]\ndef functorProdFunctorEquivCounitIso :\n    functorProdToProdFunctor A B C ‚ãô prodFunctorToFunctorProd A B C ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents fun F => NatIso.ofComponents fun X => prod.etaIso (F.obj X)\n\n"}
{"name":"CategoryTheory.functorProdFunctorEquiv_unitIso","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\n‚ä¢ Eq (CategoryTheory.functorProdFunctorEquiv A B C).unitIso (CategoryTheory.functorProdFunctorEquivUnitIso A B C)","decl":"/-- The equivalence of categories between `(A ‚•§ B) √ó (A ‚•§ C)` and `A ‚•§ (B √ó C)` -/\n@[simps]\ndef functorProdFunctorEquiv : (A ‚•§ B) √ó (A ‚•§ C) ‚âå A ‚•§ B √ó C :=\n  { functor := prodFunctorToFunctorProd A B C,\n    inverse := functorProdToProdFunctor A B C,\n    unitIso := functorProdFunctorEquivUnitIso A B C,\n    counitIso := functorProdFunctorEquivCounitIso A B C, }\n\n"}
{"name":"CategoryTheory.functorProdFunctorEquiv_functor","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\n‚ä¢ Eq (CategoryTheory.functorProdFunctorEquiv A B C).functor (CategoryTheory.prodFunctorToFunctorProd A B C)","decl":"/-- The equivalence of categories between `(A ‚•§ B) √ó (A ‚•§ C)` and `A ‚•§ (B √ó C)` -/\n@[simps]\ndef functorProdFunctorEquiv : (A ‚•§ B) √ó (A ‚•§ C) ‚âå A ‚•§ B √ó C :=\n  { functor := prodFunctorToFunctorProd A B C,\n    inverse := functorProdToProdFunctor A B C,\n    unitIso := functorProdFunctorEquivUnitIso A B C,\n    counitIso := functorProdFunctorEquivCounitIso A B C, }\n\n"}
{"name":"CategoryTheory.functorProdFunctorEquiv_inverse","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\n‚ä¢ Eq (CategoryTheory.functorProdFunctorEquiv A B C).inverse (CategoryTheory.functorProdToProdFunctor A B C)","decl":"/-- The equivalence of categories between `(A ‚•§ B) √ó (A ‚•§ C)` and `A ‚•§ (B √ó C)` -/\n@[simps]\ndef functorProdFunctorEquiv : (A ‚•§ B) √ó (A ‚•§ C) ‚âå A ‚•§ B √ó C :=\n  { functor := prodFunctorToFunctorProd A B C,\n    inverse := functorProdToProdFunctor A B C,\n    unitIso := functorProdFunctorEquivUnitIso A B C,\n    counitIso := functorProdFunctorEquivCounitIso A B C, }\n\n"}
{"name":"CategoryTheory.functorProdFunctorEquiv_counitIso","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"A : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} A\nB : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} B\nC : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\n‚ä¢ Eq (CategoryTheory.functorProdFunctorEquiv A B C).counitIso (CategoryTheory.functorProdFunctorEquivCounitIso A B C)","decl":"/-- The equivalence of categories between `(A ‚•§ B) √ó (A ‚•§ C)` and `A ‚•§ (B √ó C)` -/\n@[simps]\ndef functorProdFunctorEquiv : (A ‚•§ B) √ó (A ‚•§ C) ‚âå A ‚•§ B √ó C :=\n  { functor := prodFunctorToFunctorProd A B C,\n    inverse := functorProdToProdFunctor A B C,\n    unitIso := functorProdFunctorEquivUnitIso A B C,\n    counitIso := functorProdFunctorEquivCounitIso A B C, }\n\n"}
{"name":"CategoryTheory.prodOpEquiv_functor_obj","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nX : Opposite (Prod C D)\n‚ä¢ Eq ((CategoryTheory.prodOpEquiv C).functor.obj X) { fst := { unop := (Opposite.unop X).1 }, snd := { unop := (Opposite.unop X).2 } }","decl":"/-- The equivalence between the opposite of a product and the product of the opposites. -/\n@[simps]\ndef prodOpEquiv : (C √ó D)·µí·µñ ‚âå C·µí·µñ √ó D·µí·µñ where\n  functor :=\n    { obj := fun X ‚Ü¶ ‚ü®op X.unop.1, op X.unop.2‚ü©,\n      map := fun f ‚Ü¶ ‚ü®f.unop.1.op, f.unop.2.op‚ü© }\n  inverse :=\n    { obj := fun ‚ü®X,Y‚ü© ‚Ü¶ op ‚ü®X.unop, Y.unop‚ü©,\n      map := fun ‚ü®f,g‚ü© ‚Ü¶ op ‚ü®f.unop, g.unop‚ü© }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n  functor_unitIso_comp := fun ‚ü®X, Y‚ü© => by\n    dsimp\n    ext <;> apply Category.id_comp\n\n"}
{"name":"CategoryTheory.prodOpEquiv_inverse_obj","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nx‚úù : Prod (Opposite C) (Opposite D)\n‚ä¢ Eq ((CategoryTheory.prodOpEquiv C).inverse.obj x‚úù) (CategoryTheory.prodOpEquiv.match_1 C (fun x => Opposite (Prod C D)) x‚úù fun X Y => { unop := { fst := Opposite.unop X, snd := Opposite.unop Y } })","decl":"/-- The equivalence between the opposite of a product and the product of the opposites. -/\n@[simps]\ndef prodOpEquiv : (C √ó D)·µí·µñ ‚âå C·µí·µñ √ó D·µí·µñ where\n  functor :=\n    { obj := fun X ‚Ü¶ ‚ü®op X.unop.1, op X.unop.2‚ü©,\n      map := fun f ‚Ü¶ ‚ü®f.unop.1.op, f.unop.2.op‚ü© }\n  inverse :=\n    { obj := fun ‚ü®X,Y‚ü© ‚Ü¶ op ‚ü®X.unop, Y.unop‚ü©,\n      map := fun ‚ü®f,g‚ü© ‚Ü¶ op ‚ü®f.unop, g.unop‚ü© }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n  functor_unitIso_comp := fun ‚ü®X, Y‚ü© => by\n    dsimp\n    ext <;> apply Category.id_comp\n\n"}
{"name":"CategoryTheory.prodOpEquiv_counitIso","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\n‚ä¢ Eq (CategoryTheory.prodOpEquiv C).counitIso (CategoryTheory.Iso.refl ({ obj := fun x => CategoryTheory.prodOpEquiv.match_1 C (fun x => Opposite (Prod C D)) x fun X Y => { unop := { fst := Opposite.unop X, snd := Opposite.unop Y } }, map := fun {X Y} x => CategoryTheory.prodOpEquiv.match_2 C (fun x => Quiver.Hom ((fun x => CategoryTheory.prodOpEquiv.match_1 C (fun x => Opposite (Prod C D)) x fun X Y => { unop := { fst := Opposite.unop X, snd := Opposite.unop Y } }) X) ((fun x => CategoryTheory.prodOpEquiv.match_1 C (fun x => Opposite (Prod C D)) x fun X Y => { unop := { fst := Opposite.unop X, snd := Opposite.unop Y } }) Y)) x fun f g => { unop := { fst := f.unop, snd := g.unop } }, map_id := ‚ãØ, map_comp := ‚ãØ }.comp { obj := fun X => { fst := { unop := (Opposite.unop X).1 }, snd := { unop := (Opposite.unop X).2 } }, map := fun {X Y} f => { fst := f.unop.1.op, snd := f.unop.2.op }, map_id := ‚ãØ, map_comp := ‚ãØ }))","decl":"/-- The equivalence between the opposite of a product and the product of the opposites. -/\n@[simps]\ndef prodOpEquiv : (C √ó D)·µí·µñ ‚âå C·µí·µñ √ó D·µí·µñ where\n  functor :=\n    { obj := fun X ‚Ü¶ ‚ü®op X.unop.1, op X.unop.2‚ü©,\n      map := fun f ‚Ü¶ ‚ü®f.unop.1.op, f.unop.2.op‚ü© }\n  inverse :=\n    { obj := fun ‚ü®X,Y‚ü© ‚Ü¶ op ‚ü®X.unop, Y.unop‚ü©,\n      map := fun ‚ü®f,g‚ü© ‚Ü¶ op ‚ü®f.unop, g.unop‚ü© }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n  functor_unitIso_comp := fun ‚ü®X, Y‚ü© => by\n    dsimp\n    ext <;> apply Category.id_comp\n\n"}
{"name":"CategoryTheory.prodOpEquiv_functor_map","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nX‚úù Y‚úù : Opposite (Prod C D)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.prodOpEquiv C).functor.map f) { fst := f.unop.1.op, snd := f.unop.2.op }","decl":"/-- The equivalence between the opposite of a product and the product of the opposites. -/\n@[simps]\ndef prodOpEquiv : (C √ó D)·µí·µñ ‚âå C·µí·µñ √ó D·µí·µñ where\n  functor :=\n    { obj := fun X ‚Ü¶ ‚ü®op X.unop.1, op X.unop.2‚ü©,\n      map := fun f ‚Ü¶ ‚ü®f.unop.1.op, f.unop.2.op‚ü© }\n  inverse :=\n    { obj := fun ‚ü®X,Y‚ü© ‚Ü¶ op ‚ü®X.unop, Y.unop‚ü©,\n      map := fun ‚ü®f,g‚ü© ‚Ü¶ op ‚ü®f.unop, g.unop‚ü© }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n  functor_unitIso_comp := fun ‚ü®X, Y‚ü© => by\n    dsimp\n    ext <;> apply Category.id_comp\n\n"}
{"name":"CategoryTheory.prodOpEquiv_unitIso","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\n‚ä¢ Eq (CategoryTheory.prodOpEquiv C).unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id (Opposite (Prod C D))))","decl":"/-- The equivalence between the opposite of a product and the product of the opposites. -/\n@[simps]\ndef prodOpEquiv : (C √ó D)·µí·µñ ‚âå C·µí·µñ √ó D·µí·µñ where\n  functor :=\n    { obj := fun X ‚Ü¶ ‚ü®op X.unop.1, op X.unop.2‚ü©,\n      map := fun f ‚Ü¶ ‚ü®f.unop.1.op, f.unop.2.op‚ü© }\n  inverse :=\n    { obj := fun ‚ü®X,Y‚ü© ‚Ü¶ op ‚ü®X.unop, Y.unop‚ü©,\n      map := fun ‚ü®f,g‚ü© ‚Ü¶ op ‚ü®f.unop, g.unop‚ü© }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n  functor_unitIso_comp := fun ‚ü®X, Y‚ü© => by\n    dsimp\n    ext <;> apply Category.id_comp\n\n"}
{"name":"CategoryTheory.prodOpEquiv_inverse_map","module":"Mathlib.CategoryTheory.Products.Basic","initialProofState":"C : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} C\nD : Type u‚ÇÑ\ninst‚úù : CategoryTheory.Category.{v‚ÇÑ, u‚ÇÑ} D\nX‚úù Y‚úù : Prod (Opposite C) (Opposite D)\nx‚úù : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.prodOpEquiv C).inverse.map x‚úù) (CategoryTheory.prodOpEquiv.match_2 C (fun x => Quiver.Hom ((fun x => CategoryTheory.prodOpEquiv.match_1 C (fun x => Opposite (Prod C D)) x fun X Y => { unop := { fst := Opposite.unop X, snd := Opposite.unop Y } }) X‚úù) ((fun x => CategoryTheory.prodOpEquiv.match_1 C (fun x => Opposite (Prod C D)) x fun X Y => { unop := { fst := Opposite.unop X, snd := Opposite.unop Y } }) Y‚úù)) x‚úù fun f g => { unop := { fst := f.unop, snd := g.unop } })","decl":"/-- The equivalence between the opposite of a product and the product of the opposites. -/\n@[simps]\ndef prodOpEquiv : (C √ó D)·µí·µñ ‚âå C·µí·µñ √ó D·µí·µñ where\n  functor :=\n    { obj := fun X ‚Ü¶ ‚ü®op X.unop.1, op X.unop.2‚ü©,\n      map := fun f ‚Ü¶ ‚ü®f.unop.1.op, f.unop.2.op‚ü© }\n  inverse :=\n    { obj := fun ‚ü®X,Y‚ü© ‚Ü¶ op ‚ü®X.unop, Y.unop‚ü©,\n      map := fun ‚ü®f,g‚ü© ‚Ü¶ op ‚ü®f.unop, g.unop‚ü© }\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n  functor_unitIso_comp := fun ‚ü®X, Y‚ü© => by\n    dsimp\n    ext <;> apply Category.id_comp\n\n"}
