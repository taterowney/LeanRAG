{"name":"Finset.filter_val","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Finset α\n⊢ Eq (Finset.filter p s).val (Multiset.filter p s.val)","decl":"@[simp]\ntheorem filter_val (s : Finset α) : (filter p s).1 = s.1.filter p :=\n  rfl\n\n"}
{"name":"Finset.filter_subset","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Finset α\n⊢ HasSubset.Subset (Finset.filter p s) s","decl":"@[simp]\ntheorem filter_subset (s : Finset α) : s.filter p ⊆ s :=\n  Multiset.filter_subset _ _\n\n"}
{"name":"Finset.mem_filter","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Finset α\na : α\n⊢ Iff (Membership.mem (Finset.filter p s) a) (And (Membership.mem s a) (p a))","decl":"@[simp]\ntheorem mem_filter {s : Finset α} {a : α} : a ∈ s.filter p ↔ a ∈ s ∧ p a :=\n  Multiset.mem_filter\n\n"}
{"name":"Finset.mem_of_mem_filter","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Finset α\nx : α\nh : Membership.mem (Finset.filter p s) x\n⊢ Membership.mem s x","decl":"theorem mem_of_mem_filter {s : Finset α} (x : α) (h : x ∈ s.filter p) : x ∈ s :=\n  Multiset.mem_of_mem_filter h\n\n"}
{"name":"Finset.filter_ssubset","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Finset α\n⊢ Iff (HasSSubset.SSubset (Finset.filter p s) s) (Exists fun x => And (Membership.mem s x) (Not (p x)))","decl":"theorem filter_ssubset {s : Finset α} : s.filter p ⊂ s ↔ ∃ x ∈ s, ¬p x :=\n  ⟨fun h =>\n    let ⟨x, hs, hp⟩ := Set.exists_of_ssubset h\n    ⟨x, hs, mt (fun hp => mem_filter.2 ⟨hs, hp⟩) hp⟩,\n    fun ⟨_, hs, hp⟩ => ⟨s.filter_subset _, fun h => hp (mem_filter.1 (h hs)).2⟩⟩\n\n"}
{"name":"Finset.filter_filter","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\ns : Finset α\n⊢ Eq (Finset.filter q (Finset.filter p s)) (Finset.filter (fun a => And (p a) (q a)) s)","decl":"theorem filter_filter (s : Finset α) : (s.filter p).filter q = s.filter fun a => p a ∧ q a :=\n  ext fun a => by\n    simp only [mem_filter, and_assoc, Bool.decide_and, Bool.decide_coe, Bool.and_eq_true]\n\n"}
{"name":"Finset.filter_comm","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\ns : Finset α\n⊢ Eq (Finset.filter q (Finset.filter p s)) (Finset.filter p (Finset.filter q s))","decl":"theorem filter_comm (s : Finset α) : (s.filter p).filter q = (s.filter q).filter p := by\n  simp_rw [filter_filter, and_comm]\n\n-- We can replace an application of filter where the decidability is inferred in \"the wrong way\".\n"}
{"name":"Finset.filter_congr_decidable","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\ns : Finset α\np : α → Prop\nh inst✝ : DecidablePred p\n⊢ Eq (Finset.filter p s) (Finset.filter p s)","decl":"theorem filter_congr_decidable (s : Finset α) (p : α → Prop) (h : DecidablePred p)\n    [DecidablePred p] : @filter α p h s = s.filter p := by congr\n\n"}
{"name":"Finset.filter_True","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\nh : DecidablePred fun x => True\ns : Finset α\n⊢ Eq (Finset.filter (fun x => True) s) s","decl":"@[simp]\ntheorem filter_True {h} (s : Finset α) : @filter _ (fun _ => True) h s = s := by ext; simp\n\n"}
{"name":"Finset.filter_False","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\nh : DecidablePred fun x => False\ns : Finset α\n⊢ Eq (Finset.filter (fun x => False) s) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem filter_False {h} (s : Finset α) : @filter _ (fun _ => False) h s = ∅ := by ext; simp\n\n"}
{"name":"Finset.filter_eq_self","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Finset α\n⊢ Iff (Eq (Finset.filter p s) s) (∀ (x : α), Membership.mem s x → p x)","decl":"lemma filter_eq_self : s.filter p = s ↔ ∀ x ∈ s, p x := by simp [Finset.ext_iff]\n\n"}
{"name":"Finset.filter_eq_empty_iff","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Finset α\n⊢ Iff (Eq (Finset.filter p s) EmptyCollection.emptyCollection) (∀ ⦃x : α⦄, Membership.mem s x → Not (p x))","decl":"theorem filter_eq_empty_iff : s.filter p = ∅ ↔ ∀ ⦃x⦄, x ∈ s → ¬p x := by simp [Finset.ext_iff]\n\n"}
{"name":"Finset.filter_nonempty_iff","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Finset α\n⊢ Iff (Finset.filter p s).Nonempty (Exists fun a => And (Membership.mem s a) (p a))","decl":"theorem filter_nonempty_iff : (s.filter p).Nonempty ↔ ∃ a ∈ s, p a := by\n  simp only [nonempty_iff_ne_empty, Ne, filter_eq_empty_iff, Classical.not_not, not_forall,\n    exists_prop]\n\n"}
{"name":"Finset.filter_true_of_mem","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Finset α\nh : ∀ (x : α), Membership.mem s x → p x\n⊢ Eq (Finset.filter p s) s","decl":"/-- If all elements of a `Finset` satisfy the predicate `p`, `s.filter p` is `s`. -/\ntheorem filter_true_of_mem (h : ∀ x ∈ s, p x) : s.filter p = s := filter_eq_self.2 h\n\n"}
{"name":"Finset.filter_false_of_mem","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Finset α\nh : ∀ (x : α), Membership.mem s x → Not (p x)\n⊢ Eq (Finset.filter p s) EmptyCollection.emptyCollection","decl":"/-- If all elements of a `Finset` fail to satisfy the predicate `p`, `s.filter p` is `∅`. -/\ntheorem filter_false_of_mem (h : ∀ x ∈ s, ¬p x) : s.filter p = ∅ := filter_eq_empty_iff.2 h\n\n"}
{"name":"Finset.filter_const","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np : Prop\ninst✝ : Decidable p\ns : Finset α\n⊢ Eq (Finset.filter (fun _a => p) s) (ite p s EmptyCollection.emptyCollection)","decl":"@[simp]\ntheorem filter_const (p : Prop) [Decidable p] (s : Finset α) :\n    (s.filter fun _a => p) = if p then s else ∅ := by split_ifs <;> simp [*]\n\n"}
{"name":"Finset.filter_congr","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\ns : Finset α\nH : ∀ (x : α), Membership.mem s x → Iff (p x) (q x)\n⊢ Eq (Finset.filter p s) (Finset.filter q s)","decl":"theorem filter_congr {s : Finset α} (H : ∀ x ∈ s, p x ↔ q x) : filter p s = filter q s :=\n  eq_of_veq <| Multiset.filter_congr H\n\n"}
{"name":"Finset.filter_empty","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Finset.filter p EmptyCollection.emptyCollection) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem filter_empty : filter p ∅ = ∅ :=\n  subset_empty.1 <| filter_subset _ _\n\n"}
{"name":"Finset.filter_subset_filter","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns t : Finset α\nh : HasSubset.Subset s t\n⊢ HasSubset.Subset (Finset.filter p s) (Finset.filter p t)","decl":"@[gcongr]\ntheorem filter_subset_filter {s t : Finset α} (h : s ⊆ t) : s.filter p ⊆ t.filter p := fun _a ha =>\n  mem_filter.2 ⟨h (mem_filter.1 ha).1, (mem_filter.1 ha).2⟩\n\n"}
{"name":"Finset.monotone_filter_left","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Monotone (Finset.filter p)","decl":"theorem monotone_filter_left : Monotone (filter p) := fun _ _ => filter_subset_filter p\n\n"}
{"name":"Finset.monotone_filter_right","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\ns : Finset α\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\nh : LE.le p q\n⊢ HasSubset.Subset (Finset.filter p s) (Finset.filter q s)","decl":"@[gcongr]\ntheorem monotone_filter_right (s : Finset α) ⦃p q : α → Prop⦄ [DecidablePred p] [DecidablePred q]\n    (h : p ≤ q) : s.filter p ⊆ s.filter q :=\n  Multiset.subset_of_le (Multiset.monotone_filter_right s.val h)\n\n"}
{"name":"Finset.coe_filter","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Finset α\n⊢ Eq (↑(Finset.filter p s)) (setOf fun x => And (Membership.mem s x) (p x))","decl":"@[simp, norm_cast]\ntheorem coe_filter (s : Finset α) : ↑(s.filter p) = ({ x ∈ ↑s | p x } : Set α) :=\n  Set.ext fun _ => mem_filter\n\n"}
{"name":"Finset.subset_coe_filter_of_subset_forall","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns : Finset α\nt : Set α\nh₁ : HasSubset.Subset t ↑s\nh₂ : ∀ (x : α), Membership.mem t x → p x\n⊢ HasSubset.Subset t ↑(Finset.filter p s)","decl":"theorem subset_coe_filter_of_subset_forall (s : Finset α) {t : Set α} (h₁ : t ⊆ s)\n    (h₂ : ∀ x ∈ t, p x) : t ⊆ s.filter p := fun x hx => (s.coe_filter p).symm ▸ ⟨h₁ hx, h₂ x hx⟩\n\n"}
{"name":"Finset.disjoint_filter_filter","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\ns t : Finset α\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\na✝ : Disjoint s t\n⊢ Disjoint (Finset.filter p s) (Finset.filter q t)","decl":"theorem disjoint_filter_filter {s t : Finset α}\n    {p q : α → Prop} [DecidablePred p] [DecidablePred q] :\n    Disjoint s t → Disjoint (s.filter p) (t.filter q) :=\n  Disjoint.mono (filter_subset _ _) (filter_subset _ _)\n\n"}
{"name":"Set.pairwiseDisjoint_filter","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : DecidableEq β\nf : α → β\ns : Set β\nt : Finset α\n⊢ s.PairwiseDisjoint fun x => Finset.filter (fun x_1 => Eq (f x_1) x) t","decl":"lemma _root_.Set.pairwiseDisjoint_filter [DecidableEq β] (f : α → β) (s : Set β) (t : Finset α) :\n    s.PairwiseDisjoint fun x ↦ t.filter (f · = x) := by\n  rintro i - j - h u hi hj x hx\n  obtain ⟨-, rfl⟩ : x ∈ t ∧ f x = i := by simpa using hi hx\n  obtain ⟨-, rfl⟩ : x ∈ t ∧ f x = j := by simpa using hj hx\n  contradiction\n\n"}
{"name":"Finset.disjoint_filter_and_not_filter","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\ns : Finset α\n⊢ Disjoint (Finset.filter (fun x => And (p x) (Not (q x))) s) (Finset.filter (fun x => And (q x) (Not (p x))) s)","decl":"theorem disjoint_filter_and_not_filter :\n    Disjoint (s.filter (fun x ↦ p x ∧ ¬q x)) (s.filter (fun x ↦ q x ∧ ¬p x)) := by\n  intro _ htp htq\n  simp [bot_eq_empty, le_eq_subset, subset_empty]\n  by_contra hn\n  rw [← not_nonempty_iff_eq_empty, not_not] at hn\n  obtain ⟨_, hx⟩ := hn\n  exact (mem_filter.mp (htq hx)).2.2 (mem_filter.mp (htp hx)).2.1\n\n"}
{"name":"Finset.filter_inj","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np : α → Prop\ninst✝ : DecidablePred p\ns t : Finset α\n⊢ Iff (Eq (Finset.filter p s) (Finset.filter p t)) (∀ ⦃a : α⦄, p a → Iff (Membership.mem s a) (Membership.mem t a))","decl":"lemma filter_inj : s.filter p = t.filter p ↔ ∀ ⦃a⦄, p a → (a ∈ s ↔ a ∈ t) := by\n  simp [Finset.ext_iff]\n\n"}
{"name":"Finset.filter_inj'","module":"Mathlib.Data.Finset.Filter","initialProofState":"α : Type u_1\np q : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : DecidablePred q\ns : Finset α\n⊢ Iff (Eq (Finset.filter p s) (Finset.filter q s)) (∀ ⦃a : α⦄, Membership.mem s a → Iff (p a) (q a))","decl":"lemma filter_inj' : s.filter p = s.filter q ↔ ∀ ⦃a⦄, a ∈ s → (p a ↔ q a) := by\n  simp [Finset.ext_iff]\n\n"}
