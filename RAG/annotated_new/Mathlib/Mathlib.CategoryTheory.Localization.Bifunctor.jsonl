{"name":"CategoryTheory.Localization.lift₂_iso_hom_app_app₁","module":"Mathlib.CategoryTheory.Localization.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₁ : Type u_3\nD₂ : Type u_4\nE : Type u_5\ninst✝⁸ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝⁷ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁶ : CategoryTheory.Category.{u_10, u_3} D₁\ninst✝⁵ : CategoryTheory.Category.{u_11, u_4} D₂\ninst✝⁴ : CategoryTheory.Category.{u_7, u_5} E\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ E)\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nhF : W₁.IsInvertedBy₂ W₂ F\nL₁ : CategoryTheory.Functor C₁ D₁\nL₂ : CategoryTheory.Functor C₂ D₂\ninst✝³ : L₁.IsLocalization W₁\ninst✝² : L₂.IsLocalization W₂\ninst✝¹ : W₁.ContainsIdentities\ninst✝ : W₂.ContainsIdentities\nX₁ : C₁\nX₂ : C₂\n⊢ Eq (((CategoryTheory.Localization.Lifting₂.iso L₁ L₂ W₁ W₂ F (CategoryTheory.Localization.lift₂ F hF L₁ L₂)).hom.app X₁).app X₂) ((CategoryTheory.Localization.Lifting.iso L₂ W₂ (F.obj X₁) ((CategoryTheory.Localization.lift₂ F hF L₁ L₂).obj (L₁.obj X₁))).hom.app X₂)","decl":"lemma lift₂_iso_hom_app_app₁ (X₁ : C₁) (X₂ : C₂) :\n    ((Lifting₂.iso L₁ L₂ W₁ W₂ F (lift₂ F hF L₁ L₂)).hom.app X₁).app X₂ =\n      (Lifting.iso L₂ W₂ (F.obj X₁) ((lift₂ F hF L₁ L₂).obj (L₁.obj X₁))).hom.app X₂ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Localization.lift₂_iso_hom_app_app₂","module":"Mathlib.CategoryTheory.Localization.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₁ : Type u_3\nD₂ : Type u_4\nE : Type u_5\ninst✝⁸ : CategoryTheory.Category.{u_9, u_1} C₁\ninst✝⁷ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝⁶ : CategoryTheory.Category.{u_10, u_3} D₁\ninst✝⁵ : CategoryTheory.Category.{u_11, u_4} D₂\ninst✝⁴ : CategoryTheory.Category.{u_7, u_5} E\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ E)\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\nhF : W₁.IsInvertedBy₂ W₂ F\nL₁ : CategoryTheory.Functor C₁ D₁\nL₂ : CategoryTheory.Functor C₂ D₂\ninst✝³ : L₁.IsLocalization W₁\ninst✝² : L₂.IsLocalization W₂\ninst✝¹ : W₁.ContainsIdentities\ninst✝ : W₂.ContainsIdentities\nX₁ : C₁\nX₂ : C₂\n⊢ Eq (((CategoryTheory.Localization.Lifting₂.iso L₁ L₂ W₁ W₂ F (CategoryTheory.Localization.lift₂ F hF L₁ L₂)).hom.app X₁).app X₂) ((CategoryTheory.Localization.Lifting.iso L₁ W₁ (F.flip.obj X₂) ((CategoryTheory.Localization.lift₂ F hF L₁ L₂).flip.obj (L₂.obj X₂))).hom.app X₁)","decl":"lemma lift₂_iso_hom_app_app₂ (X₁ : C₁) (X₂ : C₂) :\n    ((Lifting₂.iso L₁ L₂ W₁ W₂ F (lift₂ F hF L₁ L₂)).hom.app X₁).app X₂ =\n      (Lifting.iso L₁ W₁ (F.flip.obj X₂) ((lift₂ F hF L₁ L₂).flip.obj (L₂.obj X₂))).hom.app X₁ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Localization.lift₂NatTrans_app_app","module":"Mathlib.CategoryTheory.Localization.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₁ : Type u_3\nD₂ : Type u_4\nE : Type u_5\ninst✝¹⁰ : CategoryTheory.Category.{u_8, u_1} C₁\ninst✝⁹ : CategoryTheory.Category.{u_9, u_2} C₂\ninst✝⁸ : CategoryTheory.Category.{u_11, u_3} D₁\ninst✝⁷ : CategoryTheory.Category.{u_10, u_4} D₂\ninst✝⁶ : CategoryTheory.Category.{u_7, u_5} E\nL₁ : CategoryTheory.Functor C₁ D₁\nL₂ : CategoryTheory.Functor C₂ D₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\ninst✝⁵ : L₁.IsLocalization W₁\ninst✝⁴ : L₂.IsLocalization W₂\ninst✝³ : W₁.ContainsIdentities\ninst✝² : W₂.ContainsIdentities\nF₁ F₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ E)\nF₁' F₂' : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ E)\ninst✝¹ : CategoryTheory.Localization.Lifting₂ L₁ L₂ W₁ W₂ F₁ F₁'\ninst✝ : CategoryTheory.Localization.Lifting₂ L₁ L₂ W₁ W₂ F₂ F₂'\nτ : Quiver.Hom F₁ F₂\nX₁ : C₁\nX₂ : C₂\n⊢ Eq (((CategoryTheory.Localization.lift₂NatTrans L₁ L₂ W₁ W₂ F₁ F₂ F₁' F₂' τ).app (L₁.obj X₁)).app (L₂.obj X₂)) (CategoryTheory.CategoryStruct.comp (((CategoryTheory.Localization.Lifting₂.iso L₁ L₂ W₁ W₂ F₁ F₁').hom.app X₁).app X₂) (CategoryTheory.CategoryStruct.comp ((τ.app X₁).app X₂) (((CategoryTheory.Localization.Lifting₂.iso L₁ L₂ W₁ W₂ F₂ F₂').inv.app X₁).app X₂)))","decl":"@[simp]\ntheorem lift₂NatTrans_app_app (τ : F₁ ⟶ F₂) (X₁ : C₁) (X₂ : C₂) :\n    ((lift₂NatTrans L₁ L₂ W₁ W₂ F₁ F₂ F₁' F₂' τ).app (L₁.obj X₁)).app (L₂.obj X₂) =\n      ((Lifting₂.iso L₁ L₂ W₁ W₂ F₁ F₁').hom.app X₁).app X₂ ≫ (τ.app X₁).app X₂ ≫\n        ((Lifting₂.iso L₁ L₂ W₁ W₂ F₂ F₂').inv.app X₁).app X₂ := by\n  dsimp [lift₂NatTrans, fullyFaithfulUncurry, Equivalence.fullyFaithfulFunctor]\n  simp only [currying_unitIso_hom_app_app_app, currying_unitIso_inv_app_app_app, comp_id, id_comp]\n  exact liftNatTrans_app _ _ _ _ (uncurry.obj F₁') (uncurry.obj F₂') (uncurry.map τ) ⟨X₁, X₂⟩\n\n"}
{"name":"CategoryTheory.Localization.natTrans₂_ext","module":"Mathlib.CategoryTheory.Localization.Bifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nD₁ : Type u_3\nD₂ : Type u_4\nE : Type u_5\ninst✝⁸ : CategoryTheory.Category.{u_10, u_1} C₁\ninst✝⁷ : CategoryTheory.Category.{u_11, u_2} C₂\ninst✝⁶ : CategoryTheory.Category.{u_8, u_3} D₁\ninst✝⁵ : CategoryTheory.Category.{u_9, u_4} D₂\ninst✝⁴ : CategoryTheory.Category.{u_7, u_5} E\nL₁ : CategoryTheory.Functor C₁ D₁\nL₂ : CategoryTheory.Functor C₂ D₂\nW₁ : CategoryTheory.MorphismProperty C₁\nW₂ : CategoryTheory.MorphismProperty C₂\ninst✝³ : L₁.IsLocalization W₁\ninst✝² : L₂.IsLocalization W₂\ninst✝¹ : W₁.ContainsIdentities\ninst✝ : W₂.ContainsIdentities\nF₁' F₂' : CategoryTheory.Functor D₁ (CategoryTheory.Functor D₂ E)\nτ τ' : Quiver.Hom F₁' F₂'\nh : ∀ (X₁ : C₁) (X₂ : C₂), Eq ((τ.app (L₁.obj X₁)).app (L₂.obj X₂)) ((τ'.app (L₁.obj X₁)).app (L₂.obj X₂))\n⊢ Eq τ τ'","decl":"variable {F₁' F₂'} in\ninclude W₁ W₂ in\ntheorem natTrans₂_ext {τ τ' : F₁' ⟶ F₂'}\n    (h : ∀ (X₁ : C₁) (X₂ : C₂), (τ.app (L₁.obj X₁)).app (L₂.obj X₂) =\n      (τ'.app (L₁.obj X₁)).app (L₂.obj X₂)) : τ = τ' :=\n  uncurry.map_injective (natTrans_ext (L₁.prod L₂) (W₁.prod W₂) (fun _ ↦ h _ _))\n\n"}
