{"name":"CategoryTheory.ShiftedHom.comp_assoc","module":"Mathlib.CategoryTheory.Shift.ShiftedHom","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nM : Type u_4\ninst‚úù¬π : AddMonoid M\ninst‚úù : CategoryTheory.HasShift C M\nX Y Z T : C\na‚ÇÅ a‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ a‚ÇÇ‚ÇÉ a : M\nŒ± : CategoryTheory.ShiftedHom X Y a‚ÇÅ\nŒ≤ : CategoryTheory.ShiftedHom Y Z a‚ÇÇ\nŒ≥ : CategoryTheory.ShiftedHom Z T a‚ÇÉ\nh‚ÇÅ‚ÇÇ : Eq (HAdd.hAdd a‚ÇÇ a‚ÇÅ) a‚ÇÅ‚ÇÇ\nh‚ÇÇ‚ÇÉ : Eq (HAdd.hAdd a‚ÇÉ a‚ÇÇ) a‚ÇÇ‚ÇÉ\nh : Eq (HAdd.hAdd (HAdd.hAdd a‚ÇÉ a‚ÇÇ) a‚ÇÅ) a\n‚ä¢ Eq ((Œ±.comp Œ≤ h‚ÇÅ‚ÇÇ).comp Œ≥ ‚ãØ) (Œ±.comp (Œ≤.comp Œ≥ h‚ÇÇ‚ÇÉ) ‚ãØ)","decl":"lemma comp_assoc {a‚ÇÅ a‚ÇÇ a‚ÇÉ a‚ÇÅ‚ÇÇ a‚ÇÇ‚ÇÉ a : M}\n    (Œ± : ShiftedHom X Y a‚ÇÅ) (Œ≤ : ShiftedHom Y Z a‚ÇÇ) (Œ≥ : ShiftedHom Z T a‚ÇÉ)\n    (h‚ÇÅ‚ÇÇ : a‚ÇÇ + a‚ÇÅ = a‚ÇÅ‚ÇÇ) (h‚ÇÇ‚ÇÉ : a‚ÇÉ + a‚ÇÇ = a‚ÇÇ‚ÇÉ) (h : a‚ÇÉ + a‚ÇÇ + a‚ÇÅ = a) :\n    (Œ±.comp Œ≤ h‚ÇÅ‚ÇÇ).comp Œ≥ (show a‚ÇÉ + a‚ÇÅ‚ÇÇ = a by rw [‚Üê h‚ÇÅ‚ÇÇ, ‚Üê add_assoc, h]) =\n      Œ±.comp (Œ≤.comp Œ≥ h‚ÇÇ‚ÇÉ) (by rw [‚Üê h‚ÇÇ‚ÇÉ, h]) := by\n  simp only [comp, assoc, Functor.map_comp,\n    shiftFunctorAdd'_assoc_inv_app a‚ÇÉ a‚ÇÇ a‚ÇÅ a‚ÇÇ‚ÇÉ a‚ÇÅ‚ÇÇ a h‚ÇÇ‚ÇÉ h‚ÇÅ‚ÇÇ h,\n    ‚Üê NatTrans.naturality_assoc, Functor.comp_map]\n\n"}
{"name":"CategoryTheory.ShiftedHom.homEquiv_apply","module":"Mathlib.CategoryTheory.Shift.ShiftedHom","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nM : Type u_4\ninst‚úù¬π : AddMonoid M\ninst‚úù : CategoryTheory.HasShift C M\nX Y : C\nm‚ÇÄ : M\nhm‚ÇÄ : Eq m‚ÇÄ 0\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.ShiftedHom.homEquiv m‚ÇÄ hm‚ÇÄ) f) (CategoryTheory.ShiftedHom.mk‚ÇÄ m‚ÇÄ hm‚ÇÄ f)","decl":"/-- The bijection `(X ‚ü∂ Y) ‚âÉ ShiftedHom X Y m‚ÇÄ` when `m‚ÇÄ = 0`. -/\n@[simps apply]\nnoncomputable def homEquiv (m‚ÇÄ : M) (hm‚ÇÄ : m‚ÇÄ = 0) : (X ‚ü∂ Y) ‚âÉ ShiftedHom X Y m‚ÇÄ where\n  toFun f := mk‚ÇÄ m‚ÇÄ hm‚ÇÄ f\n  invFun g := g ‚â´ (shiftFunctorZero' C m‚ÇÄ hm‚ÇÄ).hom.app Y\n  left_inv f := by simp [mk‚ÇÄ]\n  right_inv g := by simp [mk‚ÇÄ]\n\n"}
{"name":"CategoryTheory.ShiftedHom.mk‚ÇÄ_comp","module":"Mathlib.CategoryTheory.Shift.ShiftedHom","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nM : Type u_4\ninst‚úù¬π : AddMonoid M\ninst‚úù : CategoryTheory.HasShift C M\nX Y Z : C\nm‚ÇÄ : M\nhm‚ÇÄ : Eq m‚ÇÄ 0\nf : Quiver.Hom X Y\na : M\ng : CategoryTheory.ShiftedHom Y Z a\n‚ä¢ Eq ((CategoryTheory.ShiftedHom.mk‚ÇÄ m‚ÇÄ hm‚ÇÄ f).comp g ‚ãØ) (CategoryTheory.CategoryStruct.comp f g)","decl":"lemma mk‚ÇÄ_comp (m‚ÇÄ : M) (hm‚ÇÄ : m‚ÇÄ = 0) (f : X ‚ü∂ Y) {a : M} (g : ShiftedHom Y Z a) :\n    (mk‚ÇÄ m‚ÇÄ hm‚ÇÄ f).comp g (by rw [hm‚ÇÄ, add_zero]) = f ‚â´ g := by\n  subst hm‚ÇÄ\n  simp [comp, mk‚ÇÄ, shiftFunctorAdd'_add_zero_inv_app, shiftFunctorZero']\n\n"}
{"name":"CategoryTheory.ShiftedHom.mk‚ÇÄ_id_comp","module":"Mathlib.CategoryTheory.Shift.ShiftedHom","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nM : Type u_4\ninst‚úù¬π : AddMonoid M\ninst‚úù : CategoryTheory.HasShift C M\nX Y : C\nm‚ÇÄ : M\nhm‚ÇÄ : Eq m‚ÇÄ 0\na : M\nf : CategoryTheory.ShiftedHom X Y a\n‚ä¢ Eq ((CategoryTheory.ShiftedHom.mk‚ÇÄ m‚ÇÄ hm‚ÇÄ (CategoryTheory.CategoryStruct.id X)).comp f ‚ãØ) f","decl":"@[simp]\nlemma mk‚ÇÄ_id_comp (m‚ÇÄ : M) (hm‚ÇÄ : m‚ÇÄ = 0) {a : M} (f : ShiftedHom X Y a) :\n    (mk‚ÇÄ m‚ÇÄ hm‚ÇÄ (ùüô X)).comp f (by rw [hm‚ÇÄ, add_zero]) = f := by\n  simp [mk‚ÇÄ_comp]\n\n"}
{"name":"CategoryTheory.ShiftedHom.comp_mk‚ÇÄ","module":"Mathlib.CategoryTheory.Shift.ShiftedHom","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nM : Type u_4\ninst‚úù¬π : AddMonoid M\ninst‚úù : CategoryTheory.HasShift C M\nX Y Z : C\na : M\nf : CategoryTheory.ShiftedHom X Y a\nm‚ÇÄ : M\nhm‚ÇÄ : Eq m‚ÇÄ 0\ng : Quiver.Hom Y Z\n‚ä¢ Eq (f.comp (CategoryTheory.ShiftedHom.mk‚ÇÄ m‚ÇÄ hm‚ÇÄ g) ‚ãØ) (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.shiftFunctor C a).map g))","decl":"lemma comp_mk‚ÇÄ {a : M} (f : ShiftedHom X Y a) (m‚ÇÄ : M) (hm‚ÇÄ : m‚ÇÄ = 0) (g : Y ‚ü∂ Z) :\n    f.comp (mk‚ÇÄ m‚ÇÄ hm‚ÇÄ g) (by rw [hm‚ÇÄ, zero_add]) = f ‚â´ g‚ü¶a‚üß' := by\n  subst hm‚ÇÄ\n  simp only [comp, shiftFunctorAdd'_zero_add_inv_app, mk‚ÇÄ, shiftFunctorZero',\n    eqToIso_refl, Iso.refl_trans, ‚Üê Functor.map_comp, assoc, Iso.inv_hom_id_app,\n    Functor.id_obj, comp_id]\n\n"}
{"name":"CategoryTheory.ShiftedHom.comp_mk‚ÇÄ_id","module":"Mathlib.CategoryTheory.Shift.ShiftedHom","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nM : Type u_4\ninst‚úù¬π : AddMonoid M\ninst‚úù : CategoryTheory.HasShift C M\nX Y : C\na : M\nf : CategoryTheory.ShiftedHom X Y a\nm‚ÇÄ : M\nhm‚ÇÄ : Eq m‚ÇÄ 0\n‚ä¢ Eq (f.comp (CategoryTheory.ShiftedHom.mk‚ÇÄ m‚ÇÄ hm‚ÇÄ (CategoryTheory.CategoryStruct.id Y)) ‚ãØ) f","decl":"@[simp]\nlemma comp_mk‚ÇÄ_id {a : M} (f : ShiftedHom X Y a) (m‚ÇÄ : M) (hm‚ÇÄ : m‚ÇÄ = 0) :\n    f.comp (mk‚ÇÄ m‚ÇÄ hm‚ÇÄ (ùüô Y)) (by rw [hm‚ÇÄ, zero_add]) = f := by\n  simp [comp_mk‚ÇÄ]\n\n"}
{"name":"CategoryTheory.ShiftedHom.mk‚ÇÄ_comp_mk‚ÇÄ","module":"Mathlib.CategoryTheory.Shift.ShiftedHom","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nM : Type u_4\ninst‚úù¬π : AddMonoid M\ninst‚úù : CategoryTheory.HasShift C M\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\na b c : M\nh : Eq (HAdd.hAdd b a) c\nha : Eq a 0\nhb : Eq b 0\n‚ä¢ Eq ((CategoryTheory.ShiftedHom.mk‚ÇÄ a ha f).comp (CategoryTheory.ShiftedHom.mk‚ÇÄ b hb g) h) (CategoryTheory.ShiftedHom.mk‚ÇÄ c ‚ãØ (CategoryTheory.CategoryStruct.comp f g))","decl":"@[simp]\nlemma mk‚ÇÄ_comp_mk‚ÇÄ (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) {a b c : M} (h : b + a = c)\n    (ha : a = 0) (hb : b = 0) :\n    (mk‚ÇÄ a ha f).comp (mk‚ÇÄ b hb g) h = mk‚ÇÄ c (by rw [‚Üê h, ha, hb, add_zero]) (f ‚â´ g) := by\n  subst ha hb\n  obtain rfl : c = 0 := by rw [‚Üê h, zero_add]\n  rw [mk‚ÇÄ_comp, mk‚ÇÄ, mk‚ÇÄ, assoc]\n\n"}
{"name":"CategoryTheory.ShiftedHom.mk‚ÇÄ_comp_mk‚ÇÄ_assoc","module":"Mathlib.CategoryTheory.Shift.ShiftedHom","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nM : Type u_4\ninst‚úù¬π : AddMonoid M\ninst‚úù : CategoryTheory.HasShift C M\nX Y Z T : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\na : M\nha : Eq a 0\nd : M\nh : CategoryTheory.ShiftedHom Z T d\n‚ä¢ Eq ((CategoryTheory.ShiftedHom.mk‚ÇÄ a ha f).comp ((CategoryTheory.ShiftedHom.mk‚ÇÄ a ha g).comp h ‚ãØ) ‚ãØ) ((CategoryTheory.ShiftedHom.mk‚ÇÄ a ha (CategoryTheory.CategoryStruct.comp f g)).comp h ‚ãØ)","decl":"@[simp]\nlemma mk‚ÇÄ_comp_mk‚ÇÄ_assoc (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) {a : M}\n    (ha : a = 0) {d : M} (h : ShiftedHom Z T d) :\n    (mk‚ÇÄ a ha f).comp ((mk‚ÇÄ a ha g).comp h\n        (show _ = d by rw [ha, add_zero])) (show _ = d by rw [ha, add_zero]) =\n      (mk‚ÇÄ a ha (f ‚â´ g)).comp h (by rw [ha, add_zero]) := by\n  subst ha\n  rw [‚Üê comp_assoc, mk‚ÇÄ_comp_mk‚ÇÄ]\n  all_goals simp\n\n"}
{"name":"CategoryTheory.ShiftedHom.mk‚ÇÄ_zero","module":"Mathlib.CategoryTheory.Shift.ShiftedHom","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_1} C\nM : Type u_4\ninst‚úù¬≤ : AddMonoid M\ninst‚úù¬π : CategoryTheory.HasShift C M\nX Y : C\ninst‚úù : CategoryTheory.Preadditive C\nm‚ÇÄ : M\nhm‚ÇÄ : Eq m‚ÇÄ 0\n‚ä¢ Eq (CategoryTheory.ShiftedHom.mk‚ÇÄ m‚ÇÄ hm‚ÇÄ 0) 0","decl":"variable (X Y) in\n@[simp]\nlemma mk‚ÇÄ_zero (m‚ÇÄ : M) (hm‚ÇÄ : m‚ÇÄ = 0) : mk‚ÇÄ m‚ÇÄ hm‚ÇÄ (0 : X ‚ü∂ Y) = 0 := by simp [mk‚ÇÄ]\n\n"}
{"name":"CategoryTheory.ShiftedHom.comp_add","module":"Mathlib.CategoryTheory.Shift.ShiftedHom","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_1} C\nM : Type u_4\ninst‚úù¬≥ : AddMonoid M\ninst‚úù¬≤ : CategoryTheory.HasShift C M\nX Y Z : C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : ‚àÄ (a : M), (CategoryTheory.shiftFunctor C a).Additive\na b c : M\nŒ± : CategoryTheory.ShiftedHom X Y a\nŒ≤‚ÇÅ Œ≤‚ÇÇ : CategoryTheory.ShiftedHom Y Z b\nh : Eq (HAdd.hAdd b a) c\n‚ä¢ Eq (Œ±.comp (HAdd.hAdd Œ≤‚ÇÅ Œ≤‚ÇÇ) h) (HAdd.hAdd (Œ±.comp Œ≤‚ÇÅ h) (Œ±.comp Œ≤‚ÇÇ h))","decl":"@[simp]\nlemma comp_add [‚àÄ (a : M), (shiftFunctor C a).Additive]\n    {a b c : M} (Œ± : ShiftedHom X Y a) (Œ≤‚ÇÅ Œ≤‚ÇÇ : ShiftedHom Y Z b) (h : b + a = c) :\n    Œ±.comp (Œ≤‚ÇÅ + Œ≤‚ÇÇ) h = Œ±.comp Œ≤‚ÇÅ h + Œ±.comp Œ≤‚ÇÇ h := by\n  rw [comp, comp, comp, Functor.map_add, Preadditive.add_comp, Preadditive.comp_add]\n\n"}
{"name":"CategoryTheory.ShiftedHom.add_comp","module":"Mathlib.CategoryTheory.Shift.ShiftedHom","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_1} C\nM : Type u_4\ninst‚úù¬≤ : AddMonoid M\ninst‚úù¬π : CategoryTheory.HasShift C M\nX Y Z : C\ninst‚úù : CategoryTheory.Preadditive C\na b c : M\nŒ±‚ÇÅ Œ±‚ÇÇ : CategoryTheory.ShiftedHom X Y a\nŒ≤ : CategoryTheory.ShiftedHom Y Z b\nh : Eq (HAdd.hAdd b a) c\n‚ä¢ Eq ((HAdd.hAdd Œ±‚ÇÅ Œ±‚ÇÇ).comp Œ≤ h) (HAdd.hAdd (Œ±‚ÇÅ.comp Œ≤ h) (Œ±‚ÇÇ.comp Œ≤ h))","decl":"@[simp]\nlemma add_comp\n    {a b c : M} (Œ±‚ÇÅ Œ±‚ÇÇ : ShiftedHom X Y a) (Œ≤ : ShiftedHom Y Z b) (h : b + a = c) :\n    (Œ±‚ÇÅ + Œ±‚ÇÇ).comp Œ≤ h = Œ±‚ÇÅ.comp Œ≤ h + Œ±‚ÇÇ.comp Œ≤ h := by\n  rw [comp, comp, comp, Preadditive.add_comp]\n\n"}
{"name":"CategoryTheory.ShiftedHom.comp_neg","module":"Mathlib.CategoryTheory.Shift.ShiftedHom","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_1} C\nM : Type u_4\ninst‚úù¬≥ : AddMonoid M\ninst‚úù¬≤ : CategoryTheory.HasShift C M\nX Y Z : C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : ‚àÄ (a : M), (CategoryTheory.shiftFunctor C a).Additive\na b c : M\nŒ± : CategoryTheory.ShiftedHom X Y a\nŒ≤ : CategoryTheory.ShiftedHom Y Z b\nh : Eq (HAdd.hAdd b a) c\n‚ä¢ Eq (Œ±.comp (Neg.neg Œ≤) h) (Neg.neg (Œ±.comp Œ≤ h))","decl":"@[simp]\nlemma comp_neg [‚àÄ (a : M), (shiftFunctor C a).Additive]\n    {a b c : M} (Œ± : ShiftedHom X Y a) (Œ≤ : ShiftedHom Y Z b) (h : b + a = c) :\n    Œ±.comp (-Œ≤) h = -Œ±.comp Œ≤ h := by\n  rw [comp, comp, Functor.map_neg, Preadditive.neg_comp, Preadditive.comp_neg]\n\n"}
{"name":"CategoryTheory.ShiftedHom.neg_comp","module":"Mathlib.CategoryTheory.Shift.ShiftedHom","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_1} C\nM : Type u_4\ninst‚úù¬≤ : AddMonoid M\ninst‚úù¬π : CategoryTheory.HasShift C M\nX Y Z : C\ninst‚úù : CategoryTheory.Preadditive C\na b c : M\nŒ± : CategoryTheory.ShiftedHom X Y a\nŒ≤ : CategoryTheory.ShiftedHom Y Z b\nh : Eq (HAdd.hAdd b a) c\n‚ä¢ Eq ((Neg.neg Œ±).comp Œ≤ h) (Neg.neg (Œ±.comp Œ≤ h))","decl":"@[simp]\nlemma neg_comp\n    {a b c : M} (Œ± : ShiftedHom X Y a) (Œ≤ : ShiftedHom Y Z b) (h : b + a = c) :\n    (-Œ±).comp Œ≤ h = -Œ±.comp Œ≤ h := by\n  rw [comp, comp, Preadditive.neg_comp]\n\n"}
{"name":"CategoryTheory.ShiftedHom.comp_zero","module":"Mathlib.CategoryTheory.Shift.ShiftedHom","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_1} C\nM : Type u_4\ninst‚úù¬≥ : AddMonoid M\ninst‚úù¬≤ : CategoryTheory.HasShift C M\nX Y Z : C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : ‚àÄ (a : M), (CategoryTheory.shiftFunctor C a).PreservesZeroMorphisms\na : M\nŒ≤ : CategoryTheory.ShiftedHom X Y a\nb c : M\nh : Eq (HAdd.hAdd b a) c\n‚ä¢ Eq (Œ≤.comp 0 h) 0","decl":"variable (Z) in\n@[simp]\nlemma comp_zero [‚àÄ (a : M), (shiftFunctor C a).PreservesZeroMorphisms]\n    {a : M} (Œ≤ : ShiftedHom X Y a) {b c : M} (h : b + a = c) :\n    Œ≤.comp (0 : ShiftedHom Y Z b) h = 0 := by\n  rw [comp, Functor.map_zero, Limits.zero_comp, Limits.comp_zero]\n\n"}
{"name":"CategoryTheory.ShiftedHom.zero_comp","module":"Mathlib.CategoryTheory.Shift.ShiftedHom","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_1} C\nM : Type u_4\ninst‚úù¬≤ : AddMonoid M\ninst‚úù¬π : CategoryTheory.HasShift C M\nX Y Z : C\ninst‚úù : CategoryTheory.Preadditive C\na b c : M\nŒ≤ : CategoryTheory.ShiftedHom Y Z b\nh : Eq (HAdd.hAdd b a) c\n‚ä¢ Eq (CategoryTheory.ShiftedHom.comp 0 Œ≤ h) 0","decl":"variable (X) in\n@[simp]\nlemma zero_comp (a : M) {b c : M} (Œ≤ : ShiftedHom Y Z b) (h : b + a = c) :\n    (0 : ShiftedHom X Y a).comp Œ≤ h = 0 := by\n  rw [comp, Limits.zero_comp]\n\n"}
{"name":"CategoryTheory.ShiftedHom.id_map","module":"Mathlib.CategoryTheory.Shift.ShiftedHom","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\nM : Type u_4\ninst‚úù¬π : AddMonoid M\ninst‚úù : CategoryTheory.HasShift C M\nX Y : C\na : M\nf : CategoryTheory.ShiftedHom X Y a\n‚ä¢ Eq (f.map (CategoryTheory.Functor.id C)) f","decl":"@[simp]\nlemma id_map {a : M} (f : ShiftedHom X Y a) : f.map (ùü≠ C) = f := by\n  simp [map, Functor.commShiftIso, Functor.CommShift.iso]\n\n"}
{"name":"CategoryTheory.ShiftedHom.comp_map","module":"Mathlib.CategoryTheory.Shift.ShiftedHom","initialProofState":"C : Type u_1\ninst‚úù‚Å∏ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_6, u_2} D\nE : Type u_3\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_7, u_3} E\nM : Type u_4\ninst‚úù‚Åµ : AddMonoid M\ninst‚úù‚Å¥ : CategoryTheory.HasShift C M\ninst‚úù¬≥ : CategoryTheory.HasShift D M\ninst‚úù¬≤ : CategoryTheory.HasShift E M\nX Y : C\na : M\nf : CategoryTheory.ShiftedHom X Y a\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.CommShift M\nG : CategoryTheory.Functor D E\ninst‚úù : G.CommShift M\n‚ä¢ Eq (f.map (F.comp G)) ((f.map F).map G)","decl":"lemma comp_map {a : M} (f : ShiftedHom X Y a) (F : C ‚•§ D) [F.CommShift M]\n    (G : D ‚•§ E) [G.CommShift M] : f.map (F ‚ãô G) = (f.map F).map G := by\n  simp [map, Functor.commShiftIso_comp_hom_app]\n\n"}
{"name":"CategoryTheory.ShiftedHom.map_comp","module":"Mathlib.CategoryTheory.Shift.ShiftedHom","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_2} D\nM : Type u_4\ninst‚úù¬≥ : AddMonoid M\ninst‚úù¬≤ : CategoryTheory.HasShift C M\ninst‚úù¬π : CategoryTheory.HasShift D M\nX Y Z : C\na b c : M\nf : CategoryTheory.ShiftedHom X Y a\ng : CategoryTheory.ShiftedHom Y Z b\nh : Eq (HAdd.hAdd b a) c\nF : CategoryTheory.Functor C D\ninst‚úù : F.CommShift M\n‚ä¢ Eq ((f.comp g h).map F) ((f.map F).comp (g.map F) h)","decl":"lemma map_comp {a b c : M} (f : ShiftedHom X Y a) (g : ShiftedHom Y Z b)\n    (h : b + a = c) (F : C ‚•§ D) [F.CommShift M] :\n    (f.comp g h).map F = (f.map F).comp (g.map F) h := by\n  dsimp [comp, map]\n  simp only [Functor.map_comp, assoc]\n  erw [‚Üê NatTrans.naturality_assoc]\n  simp only [Functor.comp_map, F.commShiftIso_add' h, Functor.CommShift.isoAdd'_hom_app,\n    ‚Üê Functor.map_comp_assoc, Iso.inv_hom_id_app, Functor.comp_obj, comp_id, assoc]\n\n"}
