{"name":"Nat.totient_zero","module":"Mathlib.Data.Nat.Totient","initialProofState":"⊢ Eq (Nat.totient 0) 0","decl":"@[simp]\ntheorem totient_zero : φ 0 = 0 :=\n  rfl\n\n"}
{"name":"Nat.totient_one","module":"Mathlib.Data.Nat.Totient","initialProofState":"⊢ Eq (Nat.totient 1) 1","decl":"@[simp]\ntheorem totient_one : φ 1 = 1 := rfl\n\n"}
{"name":"Nat.totient_eq_card_coprime","module":"Mathlib.Data.Nat.Totient","initialProofState":"n : Nat\n⊢ Eq n.totient (Finset.filter (fun a => n.Coprime a) (Finset.range n)).card","decl":"theorem totient_eq_card_coprime (n : ℕ) : φ n = #{a ∈ range n | n.Coprime a} := rfl\n\n"}
{"name":"Nat.totient_eq_card_lt_and_coprime","module":"Mathlib.Data.Nat.Totient","initialProofState":"n : Nat\n⊢ Eq n.totient (Nat.card ↑(setOf fun m => And (LT.lt m n) (n.Coprime m)))","decl":"/-- A characterisation of `Nat.totient` that avoids `Finset`. -/\ntheorem totient_eq_card_lt_and_coprime (n : ℕ) : φ n = Nat.card { m | m < n ∧ n.Coprime m } := by\n  let e : { m | m < n ∧ n.Coprime m } ≃ {x ∈ range n | n.Coprime x} :=\n    { toFun := fun m => ⟨m, by simpa only [Finset.mem_filter, Finset.mem_range] using m.property⟩\n      invFun := fun m => ⟨m, by simpa only [Finset.mem_filter, Finset.mem_range] using m.property⟩\n      left_inv := fun m => by simp only [Subtype.coe_mk, Subtype.coe_eta]\n      right_inv := fun m => by simp only [Subtype.coe_mk, Subtype.coe_eta] }\n  rw [totient_eq_card_coprime, card_congr e, card_eq_fintype_card, Fintype.card_coe]\n\n"}
{"name":"Nat.totient_le","module":"Mathlib.Data.Nat.Totient","initialProofState":"n : Nat\n⊢ LE.le n.totient n","decl":"theorem totient_le (n : ℕ) : φ n ≤ n :=\n  ((range n).card_filter_le _).trans_eq (card_range n)\n\n"}
{"name":"Nat.totient_lt","module":"Mathlib.Data.Nat.Totient","initialProofState":"n : Nat\nhn : LT.lt 1 n\n⊢ LT.lt n.totient n","decl":"theorem totient_lt (n : ℕ) (hn : 1 < n) : φ n < n :=\n  (card_lt_card (filter_ssubset.2 ⟨0, by simp [hn.ne', pos_of_gt hn]⟩)).trans_eq (card_range n)\n\n"}
{"name":"Nat.totient_eq_zero","module":"Mathlib.Data.Nat.Totient","initialProofState":"n : Nat\n⊢ Iff (Eq n.totient 0) (Eq n 0)","decl":"@[simp]\ntheorem totient_eq_zero : ∀ {n : ℕ}, φ n = 0 ↔ n = 0\n  | 0 => by decide\n  | n + 1 =>\n    suffices ∃ x < n + 1, (n + 1).gcd x = 1 by simpa [totient, filter_eq_empty_iff]\n    ⟨1 % (n + 1), mod_lt _ n.succ_pos, by rw [gcd_comm, ← gcd_rec, gcd_one_right]⟩\n\n"}
{"name":"Nat.totient_pos","module":"Mathlib.Data.Nat.Totient","initialProofState":"n : Nat\n⊢ Iff (LT.lt 0 n.totient) (LT.lt 0 n)","decl":"@[simp] theorem totient_pos {n : ℕ} : 0 < φ n ↔ 0 < n := by simp [pos_iff_ne_zero]\n\n"}
{"name":"Nat.neZero_totient","module":"Mathlib.Data.Nat.Totient","initialProofState":"n : Nat\ninst✝ : NeZero n\n⊢ NeZero n.totient","decl":"instance neZero_totient {n : ℕ} [NeZero n] : NeZero n.totient :=\n  ⟨(totient_pos.mpr <| NeZero.pos n).ne'⟩\n\n"}
{"name":"Nat.filter_coprime_Ico_eq_totient","module":"Mathlib.Data.Nat.Totient","initialProofState":"a n : Nat\n⊢ Eq (Finset.filter (fun x => a.Coprime x) (Finset.Ico n (HAdd.hAdd n a))).card a.totient","decl":"theorem filter_coprime_Ico_eq_totient (a n : ℕ) :\n    #{x ∈ Ico n (n + a) | a.Coprime x} = totient a := by\n  rw [totient, filter_Ico_card_eq_of_periodic, count_eq_card_filter_range]\n  exact periodic_coprime a\n\n"}
{"name":"Nat.Ico_filter_coprime_le","module":"Mathlib.Data.Nat.Totient","initialProofState":"a k n : Nat\na_pos : LT.lt 0 a\n⊢ LE.le (Finset.filter (fun x => a.Coprime x) (Finset.Ico k (HAdd.hAdd k n))).card (HMul.hMul a.totient (HAdd.hAdd (HDiv.hDiv n a) 1))","decl":"theorem Ico_filter_coprime_le {a : ℕ} (k n : ℕ) (a_pos : 0 < a) :\n    #{x ∈ Ico k (k + n) | a.Coprime x} ≤ totient a * (n / a + 1) := by\n  conv_lhs => rw [← Nat.mod_add_div n a]\n  induction' n / a with i ih\n  · rw [← filter_coprime_Ico_eq_totient a k]\n    simp only [add_zero, mul_one, mul_zero, le_of_lt (mod_lt n a_pos),\n      zero_add]\n    gcongr\n    exact Ico_subset_Ico rfl.le (add_le_add_left (le_of_lt (mod_lt n a_pos)) k)\n  simp only [mul_succ]\n  simp_rw [← add_assoc] at ih ⊢\n  calc\n    #{x ∈ Ico k (k + n % a + a * i + a) | a.Coprime x}\n      = #{x ∈ Ico k (k + n % a + a * i) ∪\n        Ico (k + n % a + a * i) (k + n % a + a * i + a) | a.Coprime x} := by\n      congr\n      rw [Ico_union_Ico_eq_Ico]\n      · rw [add_assoc]\n        exact le_self_add\n      exact le_self_add\n    _ ≤ #{x ∈ Ico k (k + n % a + a * i) | a.Coprime x} + a.totient := by\n      rw [filter_union, ← filter_coprime_Ico_eq_totient a (k + n % a + a * i)]\n      apply card_union_le\n    _ ≤ a.totient * i + a.totient + a.totient := add_le_add_right ih (totient a)\n\n"}
{"name":"ZMod.card_units_eq_totient","module":"Mathlib.Data.Nat.Totient","initialProofState":"n : Nat\ninst✝¹ : NeZero n\ninst✝ : Fintype (Units (ZMod n))\n⊢ Eq (Fintype.card (Units (ZMod n))) n.totient","decl":"/-- Note this takes an explicit `Fintype ((ZMod n)ˣ)` argument to avoid trouble with instance\ndiamonds. -/\n@[simp]\ntheorem _root_.ZMod.card_units_eq_totient (n : ℕ) [NeZero n] [Fintype (ZMod n)ˣ] :\n    Fintype.card (ZMod n)ˣ = φ n :=\n  calc\n    Fintype.card (ZMod n)ˣ = Fintype.card { x : ZMod n // x.val.Coprime n } :=\n      Fintype.card_congr ZMod.unitsEquivCoprime\n    _ = φ n := by\n      obtain ⟨m, rfl⟩ : ∃ m, n = m + 1 := exists_eq_succ_of_ne_zero NeZero.out\n      simp only [totient, Finset.card_eq_sum_ones, Fintype.card_subtype, Finset.sum_filter, ←\n        Fin.sum_univ_eq_sum_range, @Nat.coprime_comm (m + 1)]\n      rfl\n\n"}
{"name":"Nat.totient_even","module":"Mathlib.Data.Nat.Totient","initialProofState":"n : Nat\nhn : LT.lt 2 n\n⊢ Even n.totient","decl":"theorem totient_even {n : ℕ} (hn : 2 < n) : Even n.totient := by\n  haveI : Fact (1 < n) := ⟨one_lt_two.trans hn⟩\n  haveI : NeZero n := NeZero.of_gt hn\n  suffices 2 = orderOf (-1 : (ZMod n)ˣ) by\n    rw [← ZMod.card_units_eq_totient, even_iff_two_dvd, this]\n    exact orderOf_dvd_card\n  rw [← orderOf_units, Units.coe_neg_one, orderOf_neg_one, ringChar.eq (ZMod n) n, if_neg hn.ne']\n\n"}
{"name":"Nat.totient_mul","module":"Mathlib.Data.Nat.Totient","initialProofState":"m n : Nat\nh : m.Coprime n\n⊢ Eq (HMul.hMul m n).totient (HMul.hMul m.totient n.totient)","decl":"theorem totient_mul {m n : ℕ} (h : m.Coprime n) : φ (m * n) = φ m * φ n :=\n  if hmn0 : m * n = 0 then by\n    cases' Nat.mul_eq_zero.1 hmn0 with h h <;>\n      simp only [totient_zero, mul_zero, zero_mul, h]\n  else by\n    haveI : NeZero (m * n) := ⟨hmn0⟩\n    haveI : NeZero m := ⟨left_ne_zero_of_mul hmn0⟩\n    haveI : NeZero n := ⟨right_ne_zero_of_mul hmn0⟩\n    simp only [← ZMod.card_units_eq_totient]\n    rw [Fintype.card_congr (Units.mapEquiv (ZMod.chineseRemainder h).toMulEquiv).toEquiv,\n      Fintype.card_congr (@MulEquiv.prodUnits (ZMod m) (ZMod n) _ _).toEquiv, Fintype.card_prod]\n\n"}
{"name":"Nat.totient_div_of_dvd","module":"Mathlib.Data.Nat.Totient","initialProofState":"n d : Nat\nhnd : Dvd.dvd d n\n⊢ Eq (HDiv.hDiv n d).totient (Finset.filter (fun k => Eq (n.gcd k) d) (Finset.range n)).card","decl":"/-- For `d ∣ n`, the totient of `n/d` equals the number of values `k < n` such that `gcd n k = d` -/\ntheorem totient_div_of_dvd {n d : ℕ} (hnd : d ∣ n) :\n    φ (n / d) = #{k ∈ range n | n.gcd k = d} := by\n  rcases d.eq_zero_or_pos with (rfl | hd0); · simp [eq_zero_of_zero_dvd hnd]\n  rcases hnd with ⟨x, rfl⟩\n  rw [Nat.mul_div_cancel_left x hd0]\n  apply Finset.card_bij fun k _ => d * k\n  · simp only [mem_filter, mem_range, and_imp, Coprime]\n    refine fun a ha1 ha2 => ⟨(mul_lt_mul_left hd0).2 ha1, ?_⟩\n    rw [gcd_mul_left, ha2, mul_one]\n  · simp [hd0.ne']\n  · simp only [mem_filter, mem_range, exists_prop, and_imp]\n    refine fun b hb1 hb2 => ?_\n    have : d ∣ b := by\n      rw [← hb2]\n      apply gcd_dvd_right\n    rcases this with ⟨q, rfl⟩\n    refine ⟨q, ⟨⟨(mul_lt_mul_left hd0).1 hb1, ?_⟩, rfl⟩⟩\n    rwa [gcd_mul_left, mul_right_eq_self_iff hd0] at hb2\n\n"}
{"name":"Nat.sum_totient","module":"Mathlib.Data.Nat.Totient","initialProofState":"n : Nat\n⊢ Eq (n.divisors.sum Nat.totient) n","decl":"theorem sum_totient (n : ℕ) : n.divisors.sum φ = n := by\n  rcases n.eq_zero_or_pos with (rfl | hn)\n  · simp\n  rw [← sum_div_divisors n φ]\n  have : n = ∑ d ∈ n.divisors, #{k ∈ range n | n.gcd k = d} := by\n    nth_rw 1 [← card_range n]\n    refine card_eq_sum_card_fiberwise fun x _ => mem_divisors.2 ⟨?_, hn.ne'⟩\n    apply gcd_dvd_left\n  nth_rw 3 [this]\n  exact sum_congr rfl fun x hx => totient_div_of_dvd (dvd_of_mem_divisors hx)\n\n"}
{"name":"Nat.sum_totient'","module":"Mathlib.Data.Nat.Totient","initialProofState":"n : Nat\n⊢ Eq ((Finset.filter (fun m => Dvd.dvd m n) (Finset.range n.succ)).sum fun m => m.totient) n","decl":"theorem sum_totient' (n : ℕ) : ∑ m ∈ range n.succ with m ∣ n, φ m = n := by\n  convert sum_totient _ using 1\n  simp only [Nat.divisors, sum_filter, range_eq_Ico]\n  rw [sum_eq_sum_Ico_succ_bot] <;> simp\n\n"}
{"name":"Nat.totient_prime_pow_succ","module":"Mathlib.Data.Nat.Totient","initialProofState":"p : Nat\nhp : Nat.Prime p\nn : Nat\n⊢ Eq (HPow.hPow p (HAdd.hAdd n 1)).totient (HMul.hMul (HPow.hPow p n) (HSub.hSub p 1))","decl":"/-- When `p` is prime, then the totient of `p ^ (n + 1)` is `p ^ n * (p - 1)` -/\ntheorem totient_prime_pow_succ {p : ℕ} (hp : p.Prime) (n : ℕ) : φ (p ^ (n + 1)) = p ^ n * (p - 1) :=\n  calc\n    φ (p ^ (n + 1)) = #{a ∈ range (p ^ (n + 1)) | (p ^ (n + 1)).Coprime a} :=\n      totient_eq_card_coprime _\n    _ = #(range (p ^ (n + 1)) \\ (range (p ^ n)).image (· * p)) :=\n      congr_arg card\n        (by\n          rw [sdiff_eq_filter]\n          apply filter_congr\n          simp only [mem_range, mem_filter, coprime_pow_left_iff n.succ_pos, mem_image, not_exists,\n            hp.coprime_iff_not_dvd]\n          intro a ha\n          constructor\n          · intro hap b h; rcases h with ⟨_, rfl⟩\n            exact hap (dvd_mul_left _ _)\n          · rintro h ⟨b, rfl⟩\n            rw [pow_succ'] at ha\n            exact h b ⟨lt_of_mul_lt_mul_left ha (zero_le _), mul_comm _ _⟩)\n    _ = _ := by\n      have h1 : Function.Injective (· * p) := mul_left_injective₀ hp.ne_zero\n      have h2 : (range (p ^ n)).image (· * p) ⊆ range (p ^ (n + 1)) := fun a => by\n        simp only [mem_image, mem_range, exists_imp]\n        rintro b ⟨h, rfl⟩\n        rw [Nat.pow_succ]\n        exact (mul_lt_mul_right hp.pos).2 h\n      rw [card_sdiff h2, Finset.card_image_of_injective _ h1, card_range, card_range, ←\n        one_mul (p ^ n), pow_succ', ← tsub_mul, one_mul, mul_comm]\n\n"}
{"name":"Nat.totient_prime_pow","module":"Mathlib.Data.Nat.Totient","initialProofState":"p : Nat\nhp : Nat.Prime p\nn : Nat\nhn : LT.lt 0 n\n⊢ Eq (HPow.hPow p n).totient (HMul.hMul (HPow.hPow p (HSub.hSub n 1)) (HSub.hSub p 1))","decl":"/-- When `p` is prime, then the totient of `p ^ n` is `p ^ (n - 1) * (p - 1)` -/\ntheorem totient_prime_pow {p : ℕ} (hp : p.Prime) {n : ℕ} (hn : 0 < n) :\n    φ (p ^ n) = p ^ (n - 1) * (p - 1) := by\n  rcases exists_eq_succ_of_ne_zero (pos_iff_ne_zero.1 hn) with ⟨m, rfl⟩\n  exact totient_prime_pow_succ hp _\n\n"}
{"name":"Nat.totient_prime","module":"Mathlib.Data.Nat.Totient","initialProofState":"p : Nat\nhp : Nat.Prime p\n⊢ Eq p.totient (HSub.hSub p 1)","decl":"theorem totient_prime {p : ℕ} (hp : p.Prime) : φ p = p - 1 := by\n  rw [← pow_one p, totient_prime_pow hp] <;> simp\n\n"}
{"name":"Nat.totient_eq_iff_prime","module":"Mathlib.Data.Nat.Totient","initialProofState":"p : Nat\nhp : LT.lt 0 p\n⊢ Iff (Eq p.totient (HSub.hSub p 1)) (Nat.Prime p)","decl":"theorem totient_eq_iff_prime {p : ℕ} (hp : 0 < p) : p.totient = p - 1 ↔ p.Prime := by\n  refine ⟨fun h => ?_, totient_prime⟩\n  replace hp : 1 < p := by\n    apply lt_of_le_of_ne\n    · rwa [succ_le_iff]\n    · rintro rfl\n      rw [totient_one, tsub_self] at h\n      exact one_ne_zero h\n  rw [totient_eq_card_coprime, range_eq_Ico, ← Ico_insert_succ_left hp.le, Finset.filter_insert,\n    if_neg (not_coprime_of_dvd_of_dvd hp (dvd_refl p) (dvd_zero p)), ← Nat.card_Ico 1 p] at h\n  refine\n    p.prime_of_coprime hp fun n hn hnz => Finset.filter_card_eq h n <| Finset.mem_Ico.mpr ⟨?_, hn⟩\n  rwa [succ_le_iff, pos_iff_ne_zero]\n\n"}
{"name":"Nat.card_units_zmod_lt_sub_one","module":"Mathlib.Data.Nat.Totient","initialProofState":"p : Nat\nhp : LT.lt 1 p\ninst✝ : Fintype (Units (ZMod p))\n⊢ LE.le (Fintype.card (Units (ZMod p))) (HSub.hSub p 1)","decl":"theorem card_units_zmod_lt_sub_one {p : ℕ} (hp : 1 < p) [Fintype (ZMod p)ˣ] :\n    Fintype.card (ZMod p)ˣ ≤ p - 1 := by\n  haveI : NeZero p := ⟨(pos_of_gt hp).ne'⟩\n  rw [ZMod.card_units_eq_totient p]\n  exact Nat.le_sub_one_of_lt (Nat.totient_lt p hp)\n\n"}
{"name":"Nat.prime_iff_card_units","module":"Mathlib.Data.Nat.Totient","initialProofState":"p : Nat\ninst✝ : Fintype (Units (ZMod p))\n⊢ Iff (Nat.Prime p) (Eq (Fintype.card (Units (ZMod p))) (HSub.hSub p 1))","decl":"theorem prime_iff_card_units (p : ℕ) [Fintype (ZMod p)ˣ] :\n    p.Prime ↔ Fintype.card (ZMod p)ˣ = p - 1 := by\n  cases' eq_zero_or_neZero p with hp hp\n  · subst hp\n    simp only [ZMod, not_prime_zero, false_iff, zero_tsub]\n    -- the subst created a non-defeq but subsingleton instance diamond; resolve it\n    suffices Fintype.card ℤˣ ≠ 0 by convert this\n    simp\n  rw [ZMod.card_units_eq_totient, Nat.totient_eq_iff_prime <| NeZero.pos p]\n\n"}
{"name":"Nat.totient_two","module":"Mathlib.Data.Nat.Totient","initialProofState":"⊢ Eq (Nat.totient 2) 1","decl":"@[simp]\ntheorem totient_two : φ 2 = 1 :=\n  (totient_prime prime_two).trans rfl\n\n"}
{"name":"Nat.totient_eq_one_iff","module":"Mathlib.Data.Nat.Totient","initialProofState":"n : Nat\n⊢ Iff (Eq n.totient 1) (Or (Eq n 1) (Eq n 2))","decl":"theorem totient_eq_one_iff : ∀ {n : ℕ}, n.totient = 1 ↔ n = 1 ∨ n = 2\n  | 0 => by simp\n  | 1 => by simp\n  | 2 => by simp\n  | n + 3 => by\n    have : 3 ≤ n + 3 := le_add_self\n    simp only [succ_succ_ne_one, false_or]\n    exact ⟨fun h => not_even_one.elim <| h ▸ totient_even this, by rintro ⟨⟩⟩\n\n"}
{"name":"Nat.dvd_two_of_totient_le_one","module":"Mathlib.Data.Nat.Totient","initialProofState":"a : Nat\nhan : LT.lt 0 a\nha : LE.le a.totient 1\n⊢ Dvd.dvd a 2","decl":"theorem dvd_two_of_totient_le_one {a : ℕ} (han : 0 < a) (ha : a.totient ≤ 1) : a ∣ 2 := by\n  rcases totient_eq_one_iff.mp <| le_antisymm ha <| totient_pos.2 han with rfl | rfl <;> norm_num\n\n"}
{"name":"Nat.totient_eq_prod_factorization","module":"Mathlib.Data.Nat.Totient","initialProofState":"n : Nat\nhn : Ne n 0\n⊢ Eq n.totient (n.factorization.prod fun p k => HMul.hMul (HPow.hPow p (HSub.hSub k 1)) (HSub.hSub p 1))","decl":"/-- Euler's product formula for the totient function. -/\ntheorem totient_eq_prod_factorization {n : ℕ} (hn : n ≠ 0) :\n    φ n = n.factorization.prod fun p k => p ^ (k - 1) * (p - 1) := by\n  rw [multiplicative_factorization φ (@totient_mul) totient_one hn]\n  apply Finsupp.prod_congr _\n  intro p hp\n  have h := zero_lt_iff.mpr (Finsupp.mem_support_iff.mp hp)\n  rw [totient_prime_pow (prime_of_mem_primeFactors hp) h]\n\n"}
{"name":"Nat.totient_mul_prod_primeFactors","module":"Mathlib.Data.Nat.Totient","initialProofState":"n : Nat\n⊢ Eq (HMul.hMul n.totient (n.primeFactors.prod fun p => p)) (HMul.hMul n (n.primeFactors.prod fun p => HSub.hSub p 1))","decl":"/-- Euler's product formula for the totient function. -/\ntheorem totient_mul_prod_primeFactors (n : ℕ) :\n    (φ n * ∏ p ∈ n.primeFactors, p) = n * ∏ p ∈ n.primeFactors, (p - 1) := by\n  by_cases hn : n = 0; · simp [hn]\n  rw [totient_eq_prod_factorization hn]\n  nth_rw 3 [← factorization_prod_pow_eq_self hn]\n  simp only [prod_primeFactors_prod_factorization, ← Finsupp.prod_mul]\n  refine Finsupp.prod_congr (M := ℕ) (N := ℕ) fun p hp => ?_\n  rw [Finsupp.mem_support_iff, ← zero_lt_iff] at hp\n  rw [mul_comm, ← mul_assoc, ← pow_succ', Nat.sub_one, Nat.succ_pred_eq_of_pos hp]\n\n"}
{"name":"Nat.totient_eq_div_primeFactors_mul","module":"Mathlib.Data.Nat.Totient","initialProofState":"n : Nat\n⊢ Eq n.totient (HMul.hMul (HDiv.hDiv n (n.primeFactors.prod fun p => p)) (n.primeFactors.prod fun p => HSub.hSub p 1))","decl":"/-- Euler's product formula for the totient function. -/\ntheorem totient_eq_div_primeFactors_mul (n : ℕ) :\n    φ n = (n / ∏ p ∈ n.primeFactors, p) * ∏ p ∈ n.primeFactors, (p - 1) := by\n  rw [← mul_div_left n.totient, totient_mul_prod_primeFactors, mul_comm,\n    Nat.mul_div_assoc _ (prod_primeFactors_dvd n), mul_comm]\n  exact prod_pos (fun p => pos_of_mem_primeFactors)\n\n"}
{"name":"Nat.totient_eq_mul_prod_factors","module":"Mathlib.Data.Nat.Totient","initialProofState":"n : Nat\n⊢ Eq (↑n.totient) (HMul.hMul (↑n) (n.primeFactors.prod fun p => HSub.hSub 1 (Inv.inv ↑p)))","decl":"/-- Euler's product formula for the totient function. -/\ntheorem totient_eq_mul_prod_factors (n : ℕ) :\n    (φ n : ℚ) = n * ∏ p ∈ n.primeFactors, (1 - (p : ℚ)⁻¹) := by\n  by_cases hn : n = 0\n  · simp [hn]\n  have hn' : (n : ℚ) ≠ 0 := by simp [hn]\n  have hpQ : (∏ p ∈ n.primeFactors, (p : ℚ)) ≠ 0 := by\n    rw [← cast_prod, cast_ne_zero, ← zero_lt_iff, prod_primeFactors_prod_factorization]\n    exact prod_pos fun p hp => pos_of_mem_primeFactors hp\n  simp only [totient_eq_div_primeFactors_mul n, prod_primeFactors_dvd n, cast_mul, cast_prod,\n    cast_div_charZero, mul_comm_div, mul_right_inj' hn', div_eq_iff hpQ, ← prod_mul_distrib]\n  refine prod_congr rfl fun p hp => ?_\n  have hp := pos_of_mem_primeFactorsList (List.mem_toFinset.mp hp)\n  have hp' : (p : ℚ) ≠ 0 := cast_ne_zero.mpr hp.ne.symm\n  rw [sub_mul, one_mul, mul_comm, mul_inv_cancel₀ hp', cast_pred hp]\n\n"}
{"name":"Nat.totient_gcd_mul_totient_mul","module":"Mathlib.Data.Nat.Totient","initialProofState":"a b : Nat\n⊢ Eq (HMul.hMul (a.gcd b).totient (HMul.hMul a b).totient) (HMul.hMul (HMul.hMul a.totient b.totient) (a.gcd b))","decl":"theorem totient_gcd_mul_totient_mul (a b : ℕ) : φ (a.gcd b) * φ (a * b) = φ a * φ b * a.gcd b := by\n  have shuffle :\n    ∀ a1 a2 b1 b2 c1 c2 : ℕ,\n      b1 ∣ a1 → b2 ∣ a2 → a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2) := by\n    intro a1 a2 b1 b2 c1 c2 h1 h2\n    calc\n      a1 / b1 * c1 * (a2 / b2 * c2) = a1 / b1 * (a2 / b2) * (c1 * c2) := by apply mul_mul_mul_comm\n      _ = a1 * a2 / (b1 * b2) * (c1 * c2) := by\n        congr 1\n        exact div_mul_div_comm h1 h2\n  simp only [totient_eq_div_primeFactors_mul]\n  rw [shuffle, shuffle]\n  rotate_left\n  repeat' apply prod_primeFactors_dvd\n  simp only [prod_primeFactors_gcd_mul_prod_primeFactors_mul]\n  rw [eq_comm, mul_comm, ← mul_assoc, ← Nat.mul_div_assoc]\n  exact mul_dvd_mul (prod_primeFactors_dvd a) (prod_primeFactors_dvd b)\n\n"}
{"name":"Nat.totient_super_multiplicative","module":"Mathlib.Data.Nat.Totient","initialProofState":"a b : Nat\n⊢ LE.le (HMul.hMul a.totient b.totient) (HMul.hMul a b).totient","decl":"theorem totient_super_multiplicative (a b : ℕ) : φ a * φ b ≤ φ (a * b) := by\n  let d := a.gcd b\n  rcases (zero_le a).eq_or_lt with (rfl | ha0)\n  · simp\n  have hd0 : 0 < d := Nat.gcd_pos_of_pos_left _ ha0\n  apply le_of_mul_le_mul_right _ hd0\n  rw [← totient_gcd_mul_totient_mul a b, mul_comm]\n  apply mul_le_mul_left' (Nat.totient_le d)\n\n"}
{"name":"Nat.totient_dvd_of_dvd","module":"Mathlib.Data.Nat.Totient","initialProofState":"a b : Nat\nh : Dvd.dvd a b\n⊢ Dvd.dvd a.totient b.totient","decl":"theorem totient_dvd_of_dvd {a b : ℕ} (h : a ∣ b) : φ a ∣ φ b := by\n  rcases eq_or_ne a 0 with (rfl | ha0)\n  · simp [zero_dvd_iff.1 h]\n  rcases eq_or_ne b 0 with (rfl | hb0)\n  · simp\n  have hab' := primeFactors_mono h hb0\n  rw [totient_eq_prod_factorization ha0, totient_eq_prod_factorization hb0]\n  refine Finsupp.prod_dvd_prod_of_subset_of_dvd hab' fun p _ => mul_dvd_mul ?_ dvd_rfl\n  exact pow_dvd_pow p (tsub_le_tsub_right ((factorization_le_iff_dvd ha0 hb0).2 h p) 1)\n\n"}
{"name":"Nat.totient_mul_of_prime_of_dvd","module":"Mathlib.Data.Nat.Totient","initialProofState":"p n : Nat\nhp : Nat.Prime p\nh : Dvd.dvd p n\n⊢ Eq (HMul.hMul p n).totient (HMul.hMul p n.totient)","decl":"theorem totient_mul_of_prime_of_dvd {p n : ℕ} (hp : p.Prime) (h : p ∣ n) :\n    (p * n).totient = p * n.totient := by\n  have h1 := totient_gcd_mul_totient_mul p n\n  rw [gcd_eq_left h, mul_assoc] at h1\n  simpa [(totient_pos.2 hp.pos).ne', mul_comm] using h1\n\n"}
{"name":"Nat.totient_mul_of_prime_of_not_dvd","module":"Mathlib.Data.Nat.Totient","initialProofState":"p n : Nat\nhp : Nat.Prime p\nh : Not (Dvd.dvd p n)\n⊢ Eq (HMul.hMul p n).totient (HMul.hMul (HSub.hSub p 1) n.totient)","decl":"theorem totient_mul_of_prime_of_not_dvd {p n : ℕ} (hp : p.Prime) (h : ¬p ∣ n) :\n    (p * n).totient = (p - 1) * n.totient := by\n  rw [totient_mul _, totient_prime hp]\n  simpa [h] using coprime_or_dvd_of_prime hp n\n\n"}
