{"name":"LinearMap.baseChange_tmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\nN : Type u_5\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\na : A\nx : M\n⊢ Eq ((LinearMap.baseChange A f) (TensorProduct.tmul R a x)) (TensorProduct.tmul R a (f x))","decl":"@[simp]\ntheorem baseChange_tmul (a : A) (x : M) : f.baseChange A (a ⊗ₜ x) = a ⊗ₜ f x :=\n  rfl\n\n"}
{"name":"LinearMap.baseChange_eq_ltensor","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\nN : Type u_5\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\n⊢ Eq ⇑(LinearMap.baseChange A f) ⇑(LinearMap.lTensor A f)","decl":"theorem baseChange_eq_ltensor : (f.baseChange A : A ⊗ M → A ⊗ N) = f.lTensor A :=\n  rfl\n\n"}
{"name":"LinearMap.baseChange_add","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\nN : Type u_5\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf g : LinearMap (RingHom.id R) M N\n⊢ Eq (LinearMap.baseChange A (HAdd.hAdd f g)) (HAdd.hAdd (LinearMap.baseChange A f) (LinearMap.baseChange A g))","decl":"@[simp]\ntheorem baseChange_add : (f + g).baseChange A = f.baseChange A + g.baseChange A := by\n  ext\n  -- Porting note: added `-baseChange_tmul`\n  simp [baseChange_eq_ltensor, -baseChange_tmul]\n\n"}
{"name":"LinearMap.baseChange_zero","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\nN : Type u_5\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\n⊢ Eq (LinearMap.baseChange A 0) 0","decl":"@[simp]\ntheorem baseChange_zero : baseChange A (0 : M →ₗ[R] N) = 0 := by\n  ext\n  simp [baseChange_eq_ltensor]\n\n"}
{"name":"LinearMap.baseChange_smul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\nN : Type u_5\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nr : R\nf : LinearMap (RingHom.id R) M N\n⊢ Eq (LinearMap.baseChange A (HSMul.hSMul r f)) (HSMul.hSMul r (LinearMap.baseChange A f))","decl":"@[simp]\ntheorem baseChange_smul : (r • f).baseChange A = r • f.baseChange A := by\n  ext\n  simp [baseChange_tmul]\n\n"}
{"name":"LinearMap.baseChange_id","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (LinearMap.baseChange A LinearMap.id) LinearMap.id","decl":"@[simp]\nlemma baseChange_id : (.id : M →ₗ[R] M).baseChange A = .id := by\n  ext; simp\n\n"}
{"name":"LinearMap.baseChange_comp","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\nN : Type u_5\nP : Type u_6\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\n⊢ Eq (LinearMap.baseChange A (g.comp f)) ((LinearMap.baseChange A g).comp (LinearMap.baseChange A f))","decl":"lemma baseChange_comp (g : N →ₗ[R] P) :\n    (g ∘ₗ f).baseChange A = g.baseChange A ∘ₗ f.baseChange A := by\n  ext; simp\n\n"}
{"name":"LinearMap.baseChange_one","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (LinearMap.baseChange A 1) 1","decl":"variable (R M) in\n@[simp]\nlemma baseChange_one : (1 : Module.End R M).baseChange A = 1 := baseChange_id\n\n"}
{"name":"LinearMap.baseChange_mul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf g : Module.End R M\n⊢ Eq (LinearMap.baseChange A (HMul.hMul f g)) (HMul.hMul (LinearMap.baseChange A f) (LinearMap.baseChange A g))","decl":"lemma baseChange_mul (f g : Module.End R M) :\n    (f * g).baseChange A = f.baseChange A * g.baseChange A := by\n  ext; simp\n\n"}
{"name":"LinearMap.baseChangeHom_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\nN : Type u_5\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\n⊢ Eq ((LinearMap.baseChangeHom R A M N) f) (LinearMap.baseChange A f)","decl":"/-- `baseChange` as a linear map.\n\nWhen `M = N`, this is true more strongly as `Module.End.baseChangeHom`. -/\n@[simps]\ndef baseChangeHom : (M →ₗ[R] N) →ₗ[R] A ⊗[R] M →ₗ[A] A ⊗[R] N where\n  toFun := baseChange A\n  map_add' := baseChange_add\n  map_smul' := baseChange_smul\n\n"}
{"name":"Module.End.baseChangeHom_apply_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : Module.End R M\na✝ : TensorProduct R A M\n⊢ Eq (((Module.End.baseChangeHom R A M) a) a✝) ((TensorProduct.liftAux ((↑R { toFun := fun h => h.comp a, map_add' := ⋯, map_smul' := ⋯ }).comp (↑R (TensorProduct.AlgebraTensorModule.mk R A A M)))) a✝)","decl":"/-- `baseChange` as an `AlgHom`. -/\n@[simps!]\ndef _root_.Module.End.baseChangeHom : Module.End R M →ₐ[R] Module.End A (A ⊗[R] M) :=\n  .ofLinearMap (LinearMap.baseChangeHom _ _ _ _) (baseChange_one _ _) baseChange_mul\n\n"}
{"name":"LinearMap.baseChange_pow","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.End R M\nn : Nat\n⊢ Eq (LinearMap.baseChange A (HPow.hPow f n)) (HPow.hPow (LinearMap.baseChange A f) n)","decl":"lemma baseChange_pow (f : Module.End R M) (n : ℕ) :\n    (f ^ n).baseChange A = f.baseChange A ^ n :=\n  map_pow (Module.End.baseChangeHom _ _ _) f n\n\n"}
{"name":"LinearMap.baseChange_sub","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\nN : Type u_5\ninst✝⁶ : CommRing R\ninst✝⁵ : Ring A\ninst✝⁴ : Algebra R A\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf g : LinearMap (RingHom.id R) M N\n⊢ Eq (LinearMap.baseChange A (HSub.hSub f g)) (HSub.hSub (LinearMap.baseChange A f) (LinearMap.baseChange A g))","decl":"@[simp]\ntheorem baseChange_sub : (f - g).baseChange A = f.baseChange A - g.baseChange A := by\n  ext\n  -- Porting note: `tmul_sub` wasn't needed in mathlib3\n  simp [baseChange_eq_ltensor, tmul_sub]\n\n"}
{"name":"LinearMap.baseChange_neg","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_4\nN : Type u_5\ninst✝⁶ : CommRing R\ninst✝⁵ : Ring A\ninst✝⁴ : Algebra R A\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\n⊢ Eq (LinearMap.baseChange A (Neg.neg f)) (Neg.neg (LinearMap.baseChange A f))","decl":"@[simp]\ntheorem baseChange_neg : (-f).baseChange A = -f.baseChange A := by\n  ext\n  -- Porting note: `tmul_neg` wasn't needed in mathlib3\n  simp [baseChange_eq_ltensor, tmul_neg]\n\n"}
{"name":"LinearMap.liftBaseChange_tmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nA : Type u_4\ninst✝⁸ : CommSemiring R\ninst✝⁷ : CommSemiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module A N\ninst✝ : IsScalarTower R A N\nl : LinearMap (RingHom.id R) M N\nx : A\ny : M\n⊢ Eq ((LinearMap.liftBaseChange A l) (TensorProduct.tmul R x y)) (HSMul.hSMul x (l y))","decl":"@[simp]\nlemma liftBaseChange_tmul (l : M →ₗ[R] N) (x y) : l.liftBaseChange A (x ⊗ₜ y) = x • l y := rfl\n\n"}
{"name":"LinearMap.liftBaseChange_one_tmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nA : Type u_4\ninst✝⁸ : CommSemiring R\ninst✝⁷ : CommSemiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module A N\ninst✝ : IsScalarTower R A N\nl : LinearMap (RingHom.id R) M N\ny : M\n⊢ Eq ((LinearMap.liftBaseChange A l) (TensorProduct.tmul R 1 y)) (l y)","decl":"lemma liftBaseChange_one_tmul (l : M →ₗ[R] N) (y) : l.liftBaseChange A (1 ⊗ₜ y) = l y := by simp\n\n"}
{"name":"LinearMap.liftBaseChangeEquiv_symm_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_4\nM : Type u_2\nN : Type u_3\nA : Type u_1\ninst✝⁸ : CommSemiring R\ninst✝⁷ : CommSemiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module A N\ninst✝ : IsScalarTower R A N\nl : LinearMap (RingHom.id A) (TensorProduct R A M) N\nx : M\n⊢ Eq (((LinearMap.liftBaseChangeEquiv A).symm l) x) (l (TensorProduct.tmul R 1 x))","decl":"@[simp]\nlemma liftBaseChangeEquiv_symm_apply (l : A ⊗[R] M →ₗ[A] N) (x) :\n    (liftBaseChangeEquiv A).symm l x = l (1 ⊗ₜ x) := rfl\n\n"}
{"name":"LinearMap.liftBaseChange_comp","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\nA : Type u_2\ninst✝¹² : CommSemiring R\ninst✝¹¹ : CommSemiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid N\ninst✝⁷ : Module R M\ninst✝⁶ : Module R N\ninst✝⁵ : Module A N\ninst✝⁴ : IsScalarTower R A N\nP : Type u_1\ninst✝³ : AddCommMonoid P\ninst✝² : Module A P\ninst✝¹ : Module R P\ninst✝ : IsScalarTower R A P\nl : LinearMap (RingHom.id R) M N\nl' : LinearMap (RingHom.id A) N P\n⊢ Eq (l'.comp (LinearMap.liftBaseChange A l)) (LinearMap.liftBaseChange A ((↑R l').comp l))","decl":"lemma liftBaseChange_comp {P} [AddCommMonoid P] [Module A P] [Module R P] [IsScalarTower R A P]\n    (l : M →ₗ[R] N) (l' : N →ₗ[A] P) :\n      l' ∘ₗ l.liftBaseChange A = (l'.restrictScalars R ∘ₗ l).liftBaseChange A := by\n  ext\n  simp\n\n"}
{"name":"LinearMap.range_liftBaseChange","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nA : Type u_4\ninst✝⁸ : CommSemiring R\ninst✝⁷ : CommSemiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module A N\ninst✝ : IsScalarTower R A N\nl : LinearMap (RingHom.id R) M N\n⊢ Eq (LinearMap.range (LinearMap.liftBaseChange A l)) (Submodule.span A ↑(LinearMap.range l))","decl":"@[simp]\nlemma range_liftBaseChange (l : M →ₗ[R] N) :\n    LinearMap.range (l.liftBaseChange A) = Submodule.span A (LinearMap.range l) := by\n  apply le_antisymm\n  · rintro _ ⟨x, rfl⟩\n    induction x using TensorProduct.induction_on\n    · simp\n    · rw [LinearMap.liftBaseChange_tmul]\n      exact Submodule.smul_mem _ _ (Submodule.subset_span ⟨_, rfl⟩)\n    · rw [map_add]\n      exact add_mem ‹_› ‹_›\n  · rw [Submodule.span_le]\n    rintro _ ⟨x, rfl⟩\n    exact ⟨1 ⊗ₜ x, by simp⟩\n\n"}
{"name":"Algebra.TensorProduct.one_def","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoidWithOne A\ninst✝² : Module R A\ninst✝¹ : AddCommMonoidWithOne B\ninst✝ : Module R B\n⊢ Eq 1 (TensorProduct.tmul R 1 1)","decl":"theorem one_def : (1 : A ⊗[R] B) = (1 : A) ⊗ₜ (1 : B) :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.natCast_def","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoidWithOne A\ninst✝² : Module R A\ninst✝¹ : AddCommMonoidWithOne B\ninst✝ : Module R B\nn : Nat\n⊢ Eq (↑n) (TensorProduct.tmul R (↑n) 1)","decl":"theorem natCast_def (n : ℕ) : (n : A ⊗[R] B) = (n : A) ⊗ₜ (1 : B) := rfl\n\n"}
{"name":"Algebra.TensorProduct.natCast_def'","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoidWithOne A\ninst✝² : Module R A\ninst✝¹ : AddCommMonoidWithOne B\ninst✝ : Module R B\nn : Nat\n⊢ Eq (↑n) (TensorProduct.tmul R 1 ↑n)","decl":"theorem natCast_def' (n : ℕ) : (n : A ⊗[R] B) = (1 : A) ⊗ₜ (n : B) := by\n  rw [natCast_def, ← nsmul_one, smul_tmul, nsmul_one]\n\n"}
{"name":"Algebra.TensorProduct.mul_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁸ : CommSemiring R\ninst✝⁷ : NonUnitalNonAssocSemiring A\ninst✝⁶ : Module R A\ninst✝⁵ : SMulCommClass R A A\ninst✝⁴ : IsScalarTower R A A\ninst✝³ : NonUnitalNonAssocSemiring B\ninst✝² : Module R B\ninst✝¹ : SMulCommClass R B B\ninst✝ : IsScalarTower R B B\na₁ a₂ : A\nb₁ b₂ : B\n⊢ Eq ((Algebra.TensorProduct.mul (TensorProduct.tmul R a₁ b₁)) (TensorProduct.tmul R a₂ b₂)) (TensorProduct.tmul R (HMul.hMul a₁ a₂) (HMul.hMul b₁ b₂))","decl":"unseal mul in\n@[simp]\ntheorem mul_apply (a₁ a₂ : A) (b₁ b₂ : B) :\n    mul (a₁ ⊗ₜ[R] b₁) (a₂ ⊗ₜ[R] b₂) = (a₁ * a₂) ⊗ₜ[R] (b₁ * b₂) :=\n  rfl\n\n-- providing this instance separately makes some downstream code substantially faster\n"}
{"name":"Algebra.TensorProduct.tmul_mul_tmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁸ : CommSemiring R\ninst✝⁷ : NonUnitalNonAssocSemiring A\ninst✝⁶ : Module R A\ninst✝⁵ : SMulCommClass R A A\ninst✝⁴ : IsScalarTower R A A\ninst✝³ : NonUnitalNonAssocSemiring B\ninst✝² : Module R B\ninst✝¹ : SMulCommClass R B B\ninst✝ : IsScalarTower R B B\na₁ a₂ : A\nb₁ b₂ : B\n⊢ Eq (HMul.hMul (TensorProduct.tmul R a₁ b₁) (TensorProduct.tmul R a₂ b₂)) (TensorProduct.tmul R (HMul.hMul a₁ a₂) (HMul.hMul b₁ b₂))","decl":"unseal mul in\n@[simp]\ntheorem tmul_mul_tmul (a₁ a₂ : A) (b₁ b₂ : B) :\n    a₁ ⊗ₜ[R] b₁ * a₂ ⊗ₜ[R] b₂ = (a₁ * a₂) ⊗ₜ[R] (b₁ * b₂) :=\n  rfl\n\n"}
{"name":"SemiconjBy.tmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁸ : CommSemiring R\ninst✝⁷ : NonUnitalNonAssocSemiring A\ninst✝⁶ : Module R A\ninst✝⁵ : SMulCommClass R A A\ninst✝⁴ : IsScalarTower R A A\ninst✝³ : NonUnitalNonAssocSemiring B\ninst✝² : Module R B\ninst✝¹ : SMulCommClass R B B\ninst✝ : IsScalarTower R B B\na₁ a₂ a₃ : A\nb₁ b₂ b₃ : B\nha : SemiconjBy a₁ a₂ a₃\nhb : SemiconjBy b₁ b₂ b₃\n⊢ SemiconjBy (TensorProduct.tmul R a₁ b₁) (TensorProduct.tmul R a₂ b₂) (TensorProduct.tmul R a₃ b₃)","decl":"unseal mul in\ntheorem _root_.SemiconjBy.tmul {a₁ a₂ a₃ : A} {b₁ b₂ b₃ : B}\n    (ha : SemiconjBy a₁ a₂ a₃) (hb : SemiconjBy b₁ b₂ b₃) :\n    SemiconjBy (a₁ ⊗ₜ[R] b₁) (a₂ ⊗ₜ[R] b₂) (a₃ ⊗ₜ[R] b₃) :=\n  congr_arg₂ (· ⊗ₜ[R] ·) ha.eq hb.eq\n\n"}
{"name":"Commute.tmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁸ : CommSemiring R\ninst✝⁷ : NonUnitalNonAssocSemiring A\ninst✝⁶ : Module R A\ninst✝⁵ : SMulCommClass R A A\ninst✝⁴ : IsScalarTower R A A\ninst✝³ : NonUnitalNonAssocSemiring B\ninst✝² : Module R B\ninst✝¹ : SMulCommClass R B B\ninst✝ : IsScalarTower R B B\na₁ a₂ : A\nb₁ b₂ : B\nha : Commute a₁ a₂\nhb : Commute b₁ b₂\n⊢ Commute (TensorProduct.tmul R a₁ b₁) (TensorProduct.tmul R a₂ b₂)","decl":"nonrec theorem _root_.Commute.tmul {a₁ a₂ : A} {b₁ b₂ : B}\n    (ha : Commute a₁ a₂) (hb : Commute b₁ b₂) :\n    Commute (a₁ ⊗ₜ[R] b₁) (a₂ ⊗ₜ[R] b₂) :=\n  ha.tmul hb\n\n"}
{"name":"Algebra.TensorProduct.isScalarTower_right","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst✝¹² : CommSemiring R\ninst✝¹¹ : NonUnitalNonAssocSemiring A\ninst✝¹⁰ : Module R A\ninst✝⁹ : SMulCommClass R A A\ninst✝⁸ : IsScalarTower R A A\ninst✝⁷ : NonUnitalNonAssocSemiring B\ninst✝⁶ : Module R B\ninst✝⁵ : SMulCommClass R B B\ninst✝⁴ : IsScalarTower R B B\ninst✝³ : Monoid S\ninst✝² : DistribMulAction S A\ninst✝¹ : IsScalarTower S A A\ninst✝ : SMulCommClass R S A\n⊢ IsScalarTower S (TensorProduct R A B) (TensorProduct R A B)","decl":"instance (priority := 100) isScalarTower_right [Monoid S] [DistribMulAction S A]\n    [IsScalarTower S A A] [SMulCommClass R S A] : IsScalarTower S (A ⊗[R] B) (A ⊗[R] B) where\n  smul_assoc r x y := by\n    change r • x * y = r • (x * y)\n    induction y with\n    | zero => simp [smul_zero]\n    | tmul a b => induction x with\n      | zero => simp [smul_zero]\n      | tmul a' b' =>\n        dsimp\n        rw [TensorProduct.smul_tmul', TensorProduct.smul_tmul', tmul_mul_tmul, smul_mul_assoc]\n      | add x y hx hy => simp [smul_add, add_mul _, *]\n    | add x y hx hy => simp [smul_add, mul_add _, *]\n\n-- we want `Algebra.to_smulCommClass` to take priority since it's better for unification elsewhere\n"}
{"name":"Algebra.TensorProduct.sMulCommClass_right","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst✝¹² : CommSemiring R\ninst✝¹¹ : NonUnitalNonAssocSemiring A\ninst✝¹⁰ : Module R A\ninst✝⁹ : SMulCommClass R A A\ninst✝⁸ : IsScalarTower R A A\ninst✝⁷ : NonUnitalNonAssocSemiring B\ninst✝⁶ : Module R B\ninst✝⁵ : SMulCommClass R B B\ninst✝⁴ : IsScalarTower R B B\ninst✝³ : Monoid S\ninst✝² : DistribMulAction S A\ninst✝¹ : SMulCommClass S A A\ninst✝ : SMulCommClass R S A\n⊢ SMulCommClass S (TensorProduct R A B) (TensorProduct R A B)","decl":"instance (priority := 100) sMulCommClass_right [Monoid S] [DistribMulAction S A]\n    [SMulCommClass S A A] [SMulCommClass R S A] : SMulCommClass S (A ⊗[R] B) (A ⊗[R] B) where\n  smul_comm r x y := by\n    change r • (x * y) = x * r • y\n    induction y with\n    | zero => simp [smul_zero]\n    | tmul a b => induction x with\n      | zero => simp [smul_zero]\n      | tmul a' b' =>\n        dsimp\n        rw [TensorProduct.smul_tmul', TensorProduct.smul_tmul', tmul_mul_tmul, mul_smul_comm]\n      | add x y hx hy => simp [smul_add, add_mul _, *]\n    | add x y hx hy => simp [smul_add, mul_add _, *]\n\n"}
{"name":"Algebra.TensorProduct.one_mul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁸ : CommSemiring R\ninst✝⁷ : NonAssocSemiring A\ninst✝⁶ : Module R A\ninst✝⁵ : SMulCommClass R A A\ninst✝⁴ : IsScalarTower R A A\ninst✝³ : NonAssocSemiring B\ninst✝² : Module R B\ninst✝¹ : SMulCommClass R B B\ninst✝ : IsScalarTower R B B\nx : TensorProduct R A B\n⊢ Eq ((Algebra.TensorProduct.mul (TensorProduct.tmul R 1 1)) x) x","decl":"protected theorem one_mul (x : A ⊗[R] B) : mul (1 ⊗ₜ 1) x = x := by\n  refine TensorProduct.induction_on x ?_ ?_ ?_ <;> simp +contextual\n\n"}
{"name":"Algebra.TensorProduct.mul_one","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁸ : CommSemiring R\ninst✝⁷ : NonAssocSemiring A\ninst✝⁶ : Module R A\ninst✝⁵ : SMulCommClass R A A\ninst✝⁴ : IsScalarTower R A A\ninst✝³ : NonAssocSemiring B\ninst✝² : Module R B\ninst✝¹ : SMulCommClass R B B\ninst✝ : IsScalarTower R B B\nx : TensorProduct R A B\n⊢ Eq ((Algebra.TensorProduct.mul x) (TensorProduct.tmul R 1 1)) x","decl":"protected theorem mul_one (x : A ⊗[R] B) : mul x (1 ⊗ₜ 1) = x := by\n  refine TensorProduct.induction_on x ?_ ?_ ?_ <;> simp +contextual\n\n"}
{"name":"Algebra.TensorProduct.mul_assoc","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁸ : CommSemiring R\ninst✝⁷ : NonUnitalSemiring A\ninst✝⁶ : Module R A\ninst✝⁵ : SMulCommClass R A A\ninst✝⁴ : IsScalarTower R A A\ninst✝³ : NonUnitalSemiring B\ninst✝² : Module R B\ninst✝¹ : SMulCommClass R B B\ninst✝ : IsScalarTower R B B\nx y z : TensorProduct R A B\n⊢ Eq ((Algebra.TensorProduct.mul ((Algebra.TensorProduct.mul x) y)) z) ((Algebra.TensorProduct.mul x) ((Algebra.TensorProduct.mul y) z))","decl":"unseal mul in\nprotected theorem mul_assoc (x y z : A ⊗[R] B) : mul (mul x y) z = mul x (mul y z) := by\n  -- restate as an equality of morphisms so that we can use `ext`\n  suffices LinearMap.llcomp R _ _ _ mul ∘ₗ mul =\n      (LinearMap.llcomp R _ _ _ LinearMap.lflip <| LinearMap.llcomp R _ _ _ mul.flip ∘ₗ mul).flip by\n    exact DFunLike.congr_fun (DFunLike.congr_fun (DFunLike.congr_fun this x) y) z\n  ext xa xb ya yb za zb\n  exact congr_arg₂ (· ⊗ₜ ·) (mul_assoc xa ya za) (mul_assoc xb yb zb)\n\n"}
{"name":"Algebra.TensorProduct.tmul_pow","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\na : A\nb : B\nk : Nat\n⊢ Eq (HPow.hPow (TensorProduct.tmul R a b) k) (TensorProduct.tmul R (HPow.hPow a k) (HPow.hPow b k))","decl":"@[simp]\ntheorem tmul_pow (a : A) (b : B) (k : ℕ) : a ⊗ₜ[R] b ^ k = (a ^ k) ⊗ₜ[R] (b ^ k) := by\n  induction' k with k ih\n  · simp [one_def]\n  · simp [pow_succ, ih]\n\n"}
{"name":"Algebra.TensorProduct.includeLeftRingHom_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\na : A\n⊢ Eq (Algebra.TensorProduct.includeLeftRingHom a) (TensorProduct.tmul R a 1)","decl":"/-- The ring morphism `A →+* A ⊗[R] B` sending `a` to `a ⊗ₜ 1`. -/\n@[simps]\ndef includeLeftRingHom : A →+* A ⊗[R] B where\n  toFun a := a ⊗ₜ 1\n  map_zero' := by simp\n  map_add' := by simp [add_tmul]\n  map_one' := rfl\n  map_mul' := by simp\n\n"}
{"name":"Algebra.TensorProduct.algebraMap_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst✝⁷ : CommSemiring R\ninst✝⁶ : Semiring A\ninst✝⁵ : Algebra R A\ninst✝⁴ : Semiring B\ninst✝³ : Algebra R B\ninst✝² : CommSemiring S\ninst✝¹ : Algebra S A\ninst✝ : SMulCommClass R S A\nr : S\n⊢ Eq ((algebraMap S (TensorProduct R A B)) r) (TensorProduct.tmul R ((algebraMap S A) r) 1)","decl":"@[simp]\ntheorem algebraMap_apply [SMulCommClass R S A] (r : S) :\n    algebraMap S (A ⊗[R] B) r = (algebraMap S A) r ⊗ₜ 1 :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.algebraMap_apply'","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\nr : R\n⊢ Eq ((algebraMap R (TensorProduct R A B)) r) (TensorProduct.tmul R 1 ((algebraMap R B) r))","decl":"theorem algebraMap_apply' (r : R) :\n    algebraMap R (A ⊗[R] B) r = 1 ⊗ₜ algebraMap R B r := by\n  rw [algebraMap_apply, Algebra.algebraMap_eq_smul_one, Algebra.algebraMap_eq_smul_one, smul_tmul]\n\n"}
{"name":"Algebra.TensorProduct.includeLeft_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst✝⁷ : CommSemiring R\ninst✝⁶ : Semiring A\ninst✝⁵ : Algebra R A\ninst✝⁴ : Semiring B\ninst✝³ : Algebra R B\ninst✝² : CommSemiring S\ninst✝¹ : Algebra S A\ninst✝ : SMulCommClass R S A\na : A\n⊢ Eq (Algebra.TensorProduct.includeLeft a) (TensorProduct.tmul R a 1)","decl":"@[simp]\ntheorem includeLeft_apply [SMulCommClass R S A] (a : A) :\n    (includeLeft : A →ₐ[S] A ⊗[R] B) a = a ⊗ₜ 1 :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.includeRight_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\nb : B\n⊢ Eq (Algebra.TensorProduct.includeRight b) (TensorProduct.tmul R 1 b)","decl":"@[simp]\ntheorem includeRight_apply (b : B) : (includeRight : B →ₐ[R] A ⊗[R] B) b = 1 ⊗ₜ b :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.includeLeftRingHom_comp_algebraMap","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\n⊢ Eq (Algebra.TensorProduct.includeLeftRingHom.comp (algebraMap R A)) (Algebra.TensorProduct.includeRight.comp (algebraMap R B))","decl":"theorem includeLeftRingHom_comp_algebraMap :\n    (includeLeftRingHom.comp (algebraMap R A) : R →+* A ⊗[R] B) =\n      includeRight.toRingHom.comp (algebraMap R B) := by\n  ext\n  simp\n\n"}
{"name":"Algebra.TensorProduct.ext","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\ninst✝¹² : CommSemiring R\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : Semiring B\ninst✝⁸ : Algebra R B\ninst✝⁷ : Semiring C\ninst✝⁶ : Algebra R C\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra S A\ninst✝³ : Algebra R S\ninst✝² : Algebra S C\ninst✝¹ : IsScalarTower R S A\ninst✝ : IsScalarTower R S C\nf g : AlgHom S (TensorProduct R A B) C\nha : Eq (f.comp Algebra.TensorProduct.includeLeft) (g.comp Algebra.TensorProduct.includeLeft)\nhb : Eq ((AlgHom.restrictScalars R f).comp Algebra.TensorProduct.includeRight) ((AlgHom.restrictScalars R g).comp Algebra.TensorProduct.includeRight)\n⊢ Eq f g","decl":"/-- A version of `TensorProduct.ext` for `AlgHom`.\n\nUsing this as the `@[ext]` lemma instead of `Algebra.TensorProduct.ext'` allows `ext` to apply\nlemmas specific to `A →ₐ[S] _` and `B →ₐ[R] _`; notably this allows recursion into nested tensor\nproducts of algebras.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem ext ⦃f g : (A ⊗[R] B) →ₐ[S] C⦄\n    (ha : f.comp includeLeft = g.comp includeLeft)\n    (hb : (f.restrictScalars R).comp includeRight = (g.restrictScalars R).comp includeRight) :\n    f = g := by\n  apply AlgHom.toLinearMap_injective\n  ext a b\n  have := congr_arg₂ HMul.hMul (AlgHom.congr_fun ha a) (AlgHom.congr_fun hb b)\n  dsimp at *\n  rwa [← map_mul, ← map_mul, tmul_mul_tmul, one_mul, mul_one] at this\n\n"}
{"name":"Algebra.TensorProduct.ext_iff","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\ninst✝¹² : CommSemiring R\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : Semiring B\ninst✝⁸ : Algebra R B\ninst✝⁷ : Semiring C\ninst✝⁶ : Algebra R C\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra S A\ninst✝³ : Algebra R S\ninst✝² : Algebra S C\ninst✝¹ : IsScalarTower R S A\ninst✝ : IsScalarTower R S C\nf g : AlgHom S (TensorProduct R A B) C\n⊢ Iff (Eq f g) (And (Eq (f.comp Algebra.TensorProduct.includeLeft) (g.comp Algebra.TensorProduct.includeLeft)) (Eq ((AlgHom.restrictScalars R f).comp Algebra.TensorProduct.includeRight) ((AlgHom.restrictScalars R g).comp Algebra.TensorProduct.includeRight)))","decl":"/-- A version of `TensorProduct.ext` for `AlgHom`.\n\nUsing this as the `@[ext]` lemma instead of `Algebra.TensorProduct.ext'` allows `ext` to apply\nlemmas specific to `A →ₐ[S] _` and `B →ₐ[R] _`; notably this allows recursion into nested tensor\nproducts of algebras.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem ext ⦃f g : (A ⊗[R] B) →ₐ[S] C⦄\n    (ha : f.comp includeLeft = g.comp includeLeft)\n    (hb : (f.restrictScalars R).comp includeRight = (g.restrictScalars R).comp includeRight) :\n    f = g := by\n  apply AlgHom.toLinearMap_injective\n  ext a b\n  have := congr_arg₂ HMul.hMul (AlgHom.congr_fun ha a) (AlgHom.congr_fun hb b)\n  dsimp at *\n  rwa [← map_mul, ← map_mul, tmul_mul_tmul, one_mul, mul_one] at this\n\n"}
{"name":"Algebra.TensorProduct.ext'","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\ninst✝¹² : CommSemiring R\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : Semiring B\ninst✝⁸ : Algebra R B\ninst✝⁷ : Semiring C\ninst✝⁶ : Algebra R C\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra S A\ninst✝³ : Algebra R S\ninst✝² : Algebra S C\ninst✝¹ : IsScalarTower R S A\ninst✝ : IsScalarTower R S C\ng h : AlgHom S (TensorProduct R A B) C\nH : ∀ (a : A) (b : B), Eq (g (TensorProduct.tmul R a b)) (h (TensorProduct.tmul R a b))\n⊢ Eq g h","decl":"theorem ext' {g h : A ⊗[R] B →ₐ[S] C} (H : ∀ a b, g (a ⊗ₜ b) = h (a ⊗ₜ b)) : g = h :=\n  ext (AlgHom.ext fun _ => H _ _) (AlgHom.ext fun _ => H _ _)\n\n"}
{"name":"Algebra.TensorProduct.intCast_def","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommGroupWithOne A\ninst✝² : Module R A\ninst✝¹ : AddCommGroupWithOne B\ninst✝ : Module R B\nz : Int\n⊢ Eq (↑z) (TensorProduct.tmul R (↑z) 1)","decl":"theorem intCast_def (z : ℤ) : (z : A ⊗[R] B) = (z : A) ⊗ₜ (1 : B) := rfl\n\n"}
{"name":"Algebra.TensorProduct.intCast_def'","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommRing R\ninst✝³ : Ring A\ninst✝² : Algebra R A\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nz : Int\n⊢ Eq (↑z) (TensorProduct.tmul R 1 ↑z)","decl":"theorem intCast_def' (z : ℤ) : (z : A ⊗[R] B) = (1 : A) ⊗ₜ (z : B) := by\n  rw [intCast_def, ← zsmul_one, smul_tmul, zsmul_one]\n\n-- verify there are no diamonds\n"}
{"name":"Algebra.TensorProduct.right_isScalarTower","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : CommSemiring B\ninst✝ : Algebra R B\n⊢ IsScalarTower R B (TensorProduct R A B)","decl":"instance right_isScalarTower : IsScalarTower R B (A ⊗[R] B) :=\n  IsScalarTower.of_algebraMap_eq fun r => (Algebra.TensorProduct.includeRight.commutes r).symm\n\n"}
{"name":"Algebra.TensorProduct.algHomOfLinearMapTensorProduct_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Algebra R S\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : Algebra S A\ninst✝⁴ : IsScalarTower R S A\ninst✝³ : Semiring B\ninst✝² : Algebra R B\ninst✝¹ : Semiring C\ninst✝ : Algebra S C\nf : LinearMap (RingHom.id S) (TensorProduct R A B) C\nh_mul : ∀ (a₁ a₂ : A) (b₁ b₂ : B), Eq (f (TensorProduct.tmul R (HMul.hMul a₁ a₂) (HMul.hMul b₁ b₂))) (HMul.hMul (f (TensorProduct.tmul R a₁ b₁)) (f (TensorProduct.tmul R a₂ b₂)))\nh_one : Eq (f (TensorProduct.tmul R 1 1)) 1\nx : TensorProduct R A B\n⊢ Eq ((Algebra.TensorProduct.algHomOfLinearMapTensorProduct f h_mul h_one) x) (f x)","decl":"@[simp]\ntheorem algHomOfLinearMapTensorProduct_apply (f h_mul h_one x) :\n    (algHomOfLinearMapTensorProduct f h_mul h_one : A ⊗[R] B →ₐ[S] C) x = f x :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.algEquivOfLinearEquivTensorProduct_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Algebra R S\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : Algebra S A\ninst✝⁴ : IsScalarTower R S A\ninst✝³ : Semiring B\ninst✝² : Algebra R B\ninst✝¹ : Semiring C\ninst✝ : Algebra S C\nf : LinearEquiv (RingHom.id S) (TensorProduct R A B) C\nh_mul : ∀ (a₁ a₂ : A) (b₁ b₂ : B), Eq (f (TensorProduct.tmul R (HMul.hMul a₁ a₂) (HMul.hMul b₁ b₂))) (HMul.hMul (f (TensorProduct.tmul R a₁ b₁)) (f (TensorProduct.tmul R a₂ b₂)))\nh_one : Eq (f (TensorProduct.tmul R 1 1)) 1\nx : TensorProduct R A B\n⊢ Eq ((Algebra.TensorProduct.algEquivOfLinearEquivTensorProduct f h_mul h_one) x) (f x)","decl":"@[simp]\ntheorem algEquivOfLinearEquivTensorProduct_apply (f h_mul h_one x) :\n    (algEquivOfLinearEquivTensorProduct f h_mul h_one : A ⊗[R] B ≃ₐ[S] C) x = f x :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.algEquivOfLinearEquivTripleTensorProduct_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Semiring C\ninst✝² : Semiring D\ninst✝¹ : Algebra R D\ninst✝ : Algebra R C\nf : LinearEquiv (RingHom.id R) (TensorProduct R (TensorProduct R A B) C) D\nh_mul : ∀ (a₁ a₂ : A) (b₁ b₂ : B) (c₁ c₂ : C), Eq (f (TensorProduct.tmul R (TensorProduct.tmul R (HMul.hMul a₁ a₂) (HMul.hMul b₁ b₂)) (HMul.hMul c₁ c₂))) (HMul.hMul (f (TensorProduct.tmul R (TensorProduct.tmul R a₁ b₁) c₁)) (f (TensorProduct.tmul R (TensorProduct.tmul R a₂ b₂) c₂)))\nh_one : Eq (f (TensorProduct.tmul R (TensorProduct.tmul R 1 1) 1)) 1\nx : TensorProduct R (TensorProduct R A B) C\n⊢ Eq ((Algebra.TensorProduct.algEquivOfLinearEquivTripleTensorProduct f h_mul h_one) x) (f x)","decl":"@[simp]\ntheorem algEquivOfLinearEquivTripleTensorProduct_apply (f h_mul h_one x) :\n    (algEquivOfLinearEquivTripleTensorProduct f h_mul h_one : (A ⊗[R] B) ⊗[R] C ≃ₐ[R] D) x = f x :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.lift_tmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\ninst✝¹² : CommSemiring R\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Algebra R S\ninst✝⁹ : Semiring A\ninst✝⁸ : Algebra R A\ninst✝⁷ : Algebra S A\ninst✝⁶ : IsScalarTower R S A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Semiring C\ninst✝² : Algebra S C\ninst✝¹ : Algebra R C\ninst✝ : IsScalarTower R S C\nf : AlgHom S A C\ng : AlgHom R B C\nhfg : ∀ (x : A) (y : B), Commute (f x) (g y)\na : A\nb : B\n⊢ Eq ((Algebra.TensorProduct.lift f g hfg) (TensorProduct.tmul R a b)) (HMul.hMul (f a) (g b))","decl":"@[simp]\ntheorem lift_tmul (f : A →ₐ[S] C) (g : B →ₐ[R] C) (hfg : ∀ x y, Commute (f x) (g y))\n    (a : A) (b : B) :\n    lift f g hfg (a ⊗ₜ b) = f a * g b :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.lift_includeLeft_includeRight","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst✝⁸ : CommSemiring R\ninst✝⁷ : CommSemiring S\ninst✝⁶ : Algebra R S\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra S A\ninst✝² : IsScalarTower R S A\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\n⊢ Eq (Algebra.TensorProduct.lift Algebra.TensorProduct.includeLeft Algebra.TensorProduct.includeRight ⋯) (AlgHom.id S (TensorProduct R A B))","decl":"@[simp]\ntheorem lift_includeLeft_includeRight :\n    lift includeLeft includeRight (fun _ _ => (Commute.one_right _).tmul (Commute.one_left _)) =\n      .id S (A ⊗[R] B) := by\n  ext <;> simp\n\n"}
{"name":"Algebra.TensorProduct.lift_comp_includeLeft","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\ninst✝¹² : CommSemiring R\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Algebra R S\ninst✝⁹ : Semiring A\ninst✝⁸ : Algebra R A\ninst✝⁷ : Algebra S A\ninst✝⁶ : IsScalarTower R S A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Semiring C\ninst✝² : Algebra S C\ninst✝¹ : Algebra R C\ninst✝ : IsScalarTower R S C\nf : AlgHom S A C\ng : AlgHom R B C\nhfg : ∀ (x : A) (y : B), Commute (f x) (g y)\n⊢ Eq ((Algebra.TensorProduct.lift f g hfg).comp Algebra.TensorProduct.includeLeft) f","decl":"@[simp]\ntheorem lift_comp_includeLeft (f : A →ₐ[S] C) (g : B →ₐ[R] C) (hfg : ∀ x y, Commute (f x) (g y)) :\n    (lift f g hfg).comp includeLeft = f :=\n  AlgHom.ext <| by simp\n\n"}
{"name":"Algebra.TensorProduct.lift_comp_includeRight","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\ninst✝¹² : CommSemiring R\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Algebra R S\ninst✝⁹ : Semiring A\ninst✝⁸ : Algebra R A\ninst✝⁷ : Algebra S A\ninst✝⁶ : IsScalarTower R S A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Semiring C\ninst✝² : Algebra S C\ninst✝¹ : Algebra R C\ninst✝ : IsScalarTower R S C\nf : AlgHom S A C\ng : AlgHom R B C\nhfg : ∀ (x : A) (y : B), Commute (f x) (g y)\n⊢ Eq ((AlgHom.restrictScalars R (Algebra.TensorProduct.lift f g hfg)).comp Algebra.TensorProduct.includeRight) g","decl":"@[simp]\ntheorem lift_comp_includeRight (f : A →ₐ[S] C) (g : B →ₐ[R] C) (hfg : ∀ x y, Commute (f x) (g y)) :\n    ((lift f g hfg).restrictScalars R).comp includeRight = g :=\n  AlgHom.ext <| by simp\n\n"}
{"name":"Algebra.TensorProduct.liftEquiv_symm_apply_coe","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\ninst✝¹² : CommSemiring R\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Algebra R S\ninst✝⁹ : Semiring A\ninst✝⁸ : Algebra R A\ninst✝⁷ : Algebra S A\ninst✝⁶ : IsScalarTower R S A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Semiring C\ninst✝² : Algebra S C\ninst✝¹ : Algebra R C\ninst✝ : IsScalarTower R S C\nf' : AlgHom S (TensorProduct R A B) C\n⊢ Eq ↑(Algebra.TensorProduct.liftEquiv.symm f') { fst := f'.comp Algebra.TensorProduct.includeLeft, snd := (AlgHom.restrictScalars R f').comp Algebra.TensorProduct.includeRight }","decl":"/-- The universal property of the tensor product of algebras.\n\nPairs of algebra morphisms that commute are equivalent to algebra morphisms from the tensor product.\n\nThis is `Algebra.TensorProduct.lift` as an equivalence.\n\nSee also `GradedTensorProduct.liftEquiv` for an alternative commutativity requirement for graded\nalgebra. -/\n@[simps]\ndef liftEquiv : {fg : (A →ₐ[S] C) × (B →ₐ[R] C) // ∀ x y, Commute (fg.1 x) (fg.2 y)}\n    ≃ ((A ⊗[R] B) →ₐ[S] C) where\n  toFun fg := lift fg.val.1 fg.val.2 fg.prop\n  invFun f' := ⟨(f'.comp includeLeft, (f'.restrictScalars R).comp includeRight), fun _ _ =>\n    ((Commute.one_right _).tmul (Commute.one_left _)).map f'⟩\n  left_inv fg := by ext <;> simp\n  right_inv f' := by ext <;> simp\n\n"}
{"name":"Algebra.TensorProduct.liftEquiv_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\ninst✝¹² : CommSemiring R\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Algebra R S\ninst✝⁹ : Semiring A\ninst✝⁸ : Algebra R A\ninst✝⁷ : Algebra S A\ninst✝⁶ : IsScalarTower R S A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Semiring C\ninst✝² : Algebra S C\ninst✝¹ : Algebra R C\ninst✝ : IsScalarTower R S C\nfg : Subtype fun fg => ∀ (x : A) (y : B), Commute (fg.1 x) (fg.2 y)\n⊢ Eq (Algebra.TensorProduct.liftEquiv fg) (Algebra.TensorProduct.lift (↑fg).1 (↑fg).2 ⋯)","decl":"/-- The universal property of the tensor product of algebras.\n\nPairs of algebra morphisms that commute are equivalent to algebra morphisms from the tensor product.\n\nThis is `Algebra.TensorProduct.lift` as an equivalence.\n\nSee also `GradedTensorProduct.liftEquiv` for an alternative commutativity requirement for graded\nalgebra. -/\n@[simps]\ndef liftEquiv : {fg : (A →ₐ[S] C) × (B →ₐ[R] C) // ∀ x y, Commute (fg.1 x) (fg.2 y)}\n    ≃ ((A ⊗[R] B) →ₐ[S] C) where\n  toFun fg := lift fg.val.1 fg.val.2 fg.prop\n  invFun f' := ⟨(f'.comp includeLeft, (f'.restrictScalars R).comp includeRight), fun _ _ =>\n    ((Commute.one_right _).tmul (Commute.one_left _)).map f'⟩\n  left_inv fg := by ext <;> simp\n  right_inv f' := by ext <;> simp\n\n"}
{"name":"Algebra.TensorProduct.lid_toLinearEquiv","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ Eq (Algebra.TensorProduct.lid R A).toLinearEquiv (TensorProduct.lid R A)","decl":"@[simp] theorem lid_toLinearEquiv :\n    (TensorProduct.lid R A).toLinearEquiv = _root_.TensorProduct.lid R A := rfl\n\n"}
{"name":"Algebra.TensorProduct.lid_tmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nr : R\na : A\n⊢ Eq ((Algebra.TensorProduct.lid R A) (TensorProduct.tmul R r a)) (HSMul.hSMul r a)","decl":"variable {R} {A} in\n@[simp]\ntheorem lid_tmul (r : R) (a : A) : TensorProduct.lid R A (r ⊗ₜ a) = r • a := rfl\n\n"}
{"name":"Algebra.TensorProduct.lid_symm_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\na : A\n⊢ Eq ((Algebra.TensorProduct.lid R A).symm a) (TensorProduct.tmul R 1 a)","decl":"variable {A} in\n@[simp]\ntheorem lid_symm_apply (a : A) : (TensorProduct.lid R A).symm a = 1 ⊗ₜ a := rfl\n\n"}
{"name":"Algebra.TensorProduct.rid_toLinearEquiv","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : Algebra S A\ninst✝ : IsScalarTower R S A\n⊢ Eq (Algebra.TensorProduct.rid R S A).toLinearEquiv (TensorProduct.AlgebraTensorModule.rid R S A)","decl":"@[simp] theorem rid_toLinearEquiv :\n    (TensorProduct.rid R S A).toLinearEquiv = AlgebraTensorModule.rid R S A := rfl\n\n"}
{"name":"Algebra.TensorProduct.rid_tmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : Algebra S A\ninst✝ : IsScalarTower R S A\nr : R\na : A\n⊢ Eq ((Algebra.TensorProduct.rid R S A) (TensorProduct.tmul R a r)) (HSMul.hSMul r a)","decl":"variable {R A} in\n@[simp]\ntheorem rid_tmul (r : R) (a : A) : TensorProduct.rid R S A (a ⊗ₜ r) = r • a := rfl\n\n"}
{"name":"Algebra.TensorProduct.rid_symm_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : Algebra S A\ninst✝ : IsScalarTower R S A\na : A\n⊢ Eq ((Algebra.TensorProduct.rid R S A).symm a) (TensorProduct.tmul R a 1)","decl":"variable {A} in\n@[simp]\ntheorem rid_symm_apply (a : A) : (TensorProduct.rid R S A).symm a = a ⊗ₜ 1 := rfl\n\n"}
{"name":"Algebra.TensorProduct.mapOfCompatibleSMul_tmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : CommSemiring R\ninst✝⁸ : CommSemiring S\ninst✝⁷ : Semiring A\ninst✝⁶ : Semiring B\ninst✝⁵ : Algebra R A\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra S A\ninst✝² : Algebra S B\ninst✝¹ : SMulCommClass R S A\ninst✝ : TensorProduct.CompatibleSMul R S A B\nm : A\nn : B\n⊢ Eq ((Algebra.TensorProduct.mapOfCompatibleSMul R S A B) (TensorProduct.tmul S m n)) (TensorProduct.tmul R m n)","decl":"@[simp] theorem mapOfCompatibleSMul_tmul (m n) : mapOfCompatibleSMul R S A B (m ⊗ₜ n) = m ⊗ₜ n :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.mapOfCompatibleSMul_surjective","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nB : Type u_4\ninst✝⁹ : CommSemiring R\ninst✝⁸ : CommSemiring S\ninst✝⁷ : Semiring A\ninst✝⁶ : Semiring B\ninst✝⁵ : Algebra R A\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra S A\ninst✝² : Algebra S B\ninst✝¹ : SMulCommClass R S A\ninst✝ : TensorProduct.CompatibleSMul R S A B\n⊢ Function.Surjective ⇑(Algebra.TensorProduct.mapOfCompatibleSMul R S A B)","decl":"theorem mapOfCompatibleSMul_surjective : Function.Surjective (mapOfCompatibleSMul R S A B) :=\n  _root_.TensorProduct.mapOfCompatibleSMul_surjective R S A B\n\n"}
{"name":"Algebra.TensorProduct.lidOfCompatibleSMul_tmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁷ : CommSemiring R\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra S A\ninst✝² : Algebra R S\ninst✝¹ : TensorProduct.CompatibleSMul R S S A\ninst✝ : TensorProduct.CompatibleSMul S R S A\ns : S\na : A\n⊢ Eq ((Algebra.TensorProduct.lidOfCompatibleSMul R S A) (TensorProduct.tmul R s a)) (HSMul.hSMul s a)","decl":"theorem lidOfCompatibleSMul_tmul (s a) : lidOfCompatibleSMul R S A (s ⊗ₜ[R] a) = s • a := rfl\n\n"}
{"name":"Algebra.TensorProduct.comm_toLinearEquiv","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\n⊢ Eq (Algebra.TensorProduct.comm R A B).toLinearEquiv (TensorProduct.comm R A B)","decl":"@[simp] theorem comm_toLinearEquiv :\n    (Algebra.TensorProduct.comm R A B).toLinearEquiv = _root_.TensorProduct.comm R A B := rfl\n\n"}
{"name":"Algebra.TensorProduct.comm_tmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\na : A\nb : B\n⊢ Eq ((Algebra.TensorProduct.comm R A B) (TensorProduct.tmul R a b)) (TensorProduct.tmul R b a)","decl":"variable {A B} in\n@[simp]\ntheorem comm_tmul (a : A) (b : B) :\n    TensorProduct.comm R A B (a ⊗ₜ b) = b ⊗ₜ a :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.comm_symm_tmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\na : A\nb : B\n⊢ Eq ((Algebra.TensorProduct.comm R A B).symm (TensorProduct.tmul R b a)) (TensorProduct.tmul R a b)","decl":"variable {A B} in\n@[simp]\ntheorem comm_symm_tmul (a : A) (b : B) :\n    (TensorProduct.comm R A B).symm (b ⊗ₜ a) = a ⊗ₜ b :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.comm_symm","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\n⊢ Eq (Algebra.TensorProduct.comm R A B).symm (Algebra.TensorProduct.comm R B A)","decl":"theorem comm_symm :\n    (TensorProduct.comm R A B).symm = TensorProduct.comm R B A := by\n  ext; rfl\n\n"}
{"name":"Algebra.TensorProduct.comm_comp_includeLeft","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\n⊢ Eq ((↑(Algebra.TensorProduct.comm R A B)).comp Algebra.TensorProduct.includeLeft) Algebra.TensorProduct.includeRight","decl":"@[simp]\nlemma comm_comp_includeLeft :\n    (TensorProduct.comm R A B : A ⊗[R] B →ₐ[R] B ⊗[R] A).comp includeLeft = includeRight := rfl\n\n"}
{"name":"Algebra.TensorProduct.comm_comp_includeRight","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\n⊢ Eq ((↑(Algebra.TensorProduct.comm R A B)).comp Algebra.TensorProduct.includeRight) Algebra.TensorProduct.includeLeft","decl":"@[simp]\nlemma comm_comp_includeRight :\n    (TensorProduct.comm R A B : A ⊗[R] B →ₐ[R] B ⊗[R] A).comp includeRight = includeLeft := rfl\n\n"}
{"name":"Algebra.TensorProduct.adjoin_tmul_eq_top","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Algebra R A\ninst✝¹ : Semiring B\ninst✝ : Algebra R B\n⊢ Eq (Algebra.adjoin R (setOf fun t => Exists fun a => Exists fun b => Eq (TensorProduct.tmul R a b) t)) Top.top","decl":"theorem adjoin_tmul_eq_top : adjoin R { t : A ⊗[R] B | ∃ a b, a ⊗ₜ[R] b = t } = ⊤ :=\n  top_le_iff.mp <| (top_le_iff.mpr <| span_tmul_eq_top R A B).trans (span_le_adjoin R _)\n\n"}
{"name":"Algebra.TensorProduct.assoc_aux_1","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nC : Type uC\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Semiring B\ninst✝² : Algebra R B\ninst✝¹ : Semiring C\ninst✝ : Algebra R C\na₁ a₂ : A\nb₁ b₂ : B\nc₁ c₂ : C\n⊢ Eq ((TensorProduct.assoc R A B C) (TensorProduct.tmul R (TensorProduct.tmul R (HMul.hMul a₁ a₂) (HMul.hMul b₁ b₂)) (HMul.hMul c₁ c₂))) (HMul.hMul ((TensorProduct.assoc R A B C) (TensorProduct.tmul R (TensorProduct.tmul R a₁ b₁) c₁)) ((TensorProduct.assoc R A B C) (TensorProduct.tmul R (TensorProduct.tmul R a₂ b₂) c₂)))","decl":"unseal mul in\ntheorem assoc_aux_1 (a₁ a₂ : A) (b₁ b₂ : B) (c₁ c₂ : C) :\n    (TensorProduct.assoc R A B C) (((a₁ * a₂) ⊗ₜ[R] (b₁ * b₂)) ⊗ₜ[R] (c₁ * c₂)) =\n      (TensorProduct.assoc R A B C) ((a₁ ⊗ₜ[R] b₁) ⊗ₜ[R] c₁) *\n        (TensorProduct.assoc R A B C) ((a₂ ⊗ₜ[R] b₂) ⊗ₜ[R] c₂) :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.assoc_aux_2","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nC : Type uC\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Semiring B\ninst✝² : Algebra R B\ninst✝¹ : Semiring C\ninst✝ : Algebra R C\n⊢ Eq ((TensorProduct.assoc R A B C) (TensorProduct.tmul R (TensorProduct.tmul R 1 1) 1)) 1","decl":"theorem assoc_aux_2 : (TensorProduct.assoc R A B C) ((1 ⊗ₜ[R] 1) ⊗ₜ[R] 1) = 1 :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.assoc_toLinearEquiv","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nC : Type uC\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Semiring B\ninst✝² : Algebra R B\ninst✝¹ : Semiring C\ninst✝ : Algebra R C\n⊢ Eq (Algebra.TensorProduct.assoc R A B C).toLinearEquiv (TensorProduct.assoc R A B C)","decl":"@[simp] theorem assoc_toLinearEquiv :\n  (Algebra.TensorProduct.assoc R A B C).toLinearEquiv = _root_.TensorProduct.assoc R A B C := rfl\n\n"}
{"name":"Algebra.TensorProduct.assoc_tmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nC : Type uC\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Semiring B\ninst✝² : Algebra R B\ninst✝¹ : Semiring C\ninst✝ : Algebra R C\na : A\nb : B\nc : C\n⊢ Eq ((Algebra.TensorProduct.assoc R A B C) (TensorProduct.tmul R (TensorProduct.tmul R a b) c)) (TensorProduct.tmul R a (TensorProduct.tmul R b c))","decl":"@[simp]\ntheorem assoc_tmul (a : A) (b : B) (c : C) :\n    Algebra.TensorProduct.assoc R A B C ((a ⊗ₜ b) ⊗ₜ c) = a ⊗ₜ (b ⊗ₜ c) :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.assoc_symm_tmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nC : Type uC\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Semiring B\ninst✝² : Algebra R B\ninst✝¹ : Semiring C\ninst✝ : Algebra R C\na : A\nb : B\nc : C\n⊢ Eq ((Algebra.TensorProduct.assoc R A B C).symm (TensorProduct.tmul R a (TensorProduct.tmul R b c))) (TensorProduct.tmul R (TensorProduct.tmul R a b) c)","decl":"@[simp]\ntheorem assoc_symm_tmul (a : A) (b : B) (c : C) :\n    (Algebra.TensorProduct.assoc R A B C).symm (a ⊗ₜ (b ⊗ₜ c)) = (a ⊗ₜ b) ⊗ₜ c :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.map_tmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\ninst✝¹⁴ : CommSemiring R\ninst✝¹³ : CommSemiring S\ninst✝¹² : Algebra R S\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : Algebra S A\ninst✝⁸ : IsScalarTower R S A\ninst✝⁷ : Semiring B\ninst✝⁶ : Algebra R B\ninst✝⁵ : Algebra S B\ninst✝⁴ : IsScalarTower R S B\ninst✝³ : Semiring C\ninst✝² : Algebra R C\ninst✝¹ : Semiring D\ninst✝ : Algebra R D\nf : AlgHom S A B\ng : AlgHom R C D\na : A\nc : C\n⊢ Eq ((Algebra.TensorProduct.map f g) (TensorProduct.tmul R a c)) (TensorProduct.tmul R (f a) (g c))","decl":"@[simp]\ntheorem map_tmul (f : A →ₐ[S] B) (g : C →ₐ[R] D) (a : A) (c : C) : map f g (a ⊗ₜ c) = f a ⊗ₜ g c :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.map_id","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nC : Type uC\ninst✝⁸ : CommSemiring R\ninst✝⁷ : CommSemiring S\ninst✝⁶ : Algebra R S\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra S A\ninst✝² : IsScalarTower R S A\ninst✝¹ : Semiring C\ninst✝ : Algebra R C\n⊢ Eq (Algebra.TensorProduct.map (AlgHom.id S A) (AlgHom.id R C)) (AlgHom.id S (TensorProduct R A C))","decl":"@[simp]\ntheorem map_id : map (.id S A) (.id R C) = .id S _ :=\n  ext (AlgHom.ext fun _ => rfl) (AlgHom.ext fun _ => rfl)\n\n"}
{"name":"Algebra.TensorProduct.map_comp","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\nE : Type uE\nF : Type uF\ninst✝²⁰ : CommSemiring R\ninst✝¹⁹ : CommSemiring S\ninst✝¹⁸ : Algebra R S\ninst✝¹⁷ : Semiring A\ninst✝¹⁶ : Algebra R A\ninst✝¹⁵ : Algebra S A\ninst✝¹⁴ : IsScalarTower R S A\ninst✝¹³ : Semiring B\ninst✝¹² : Algebra R B\ninst✝¹¹ : Algebra S B\ninst✝¹⁰ : IsScalarTower R S B\ninst✝⁹ : Semiring C\ninst✝⁸ : Algebra R C\ninst✝⁷ : Semiring D\ninst✝⁶ : Algebra R D\ninst✝⁵ : Semiring E\ninst✝⁴ : Algebra R E\ninst✝³ : Semiring F\ninst✝² : Algebra R F\ninst✝¹ : Algebra S C\ninst✝ : IsScalarTower R S C\nf₂ : AlgHom S B C\nf₁ : AlgHom S A B\ng₂ : AlgHom R E F\ng₁ : AlgHom R D E\n⊢ Eq (Algebra.TensorProduct.map (f₂.comp f₁) (g₂.comp g₁)) ((Algebra.TensorProduct.map f₂ g₂).comp (Algebra.TensorProduct.map f₁ g₁))","decl":"theorem map_comp [Algebra S C] [IsScalarTower R S C]\n    (f₂ : B →ₐ[S] C) (f₁ : A →ₐ[S] B) (g₂ : E →ₐ[R] F) (g₁ : D →ₐ[R] E) :\n    map (f₂.comp f₁) (g₂.comp g₁) = (map f₂ g₂).comp (map f₁ g₁) :=\n  ext (AlgHom.ext fun _ => rfl) (AlgHom.ext fun _ => rfl)\n\n"}
{"name":"Algebra.TensorProduct.map_id_comp","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nD : Type uD\nE : Type uE\nF : Type uF\ninst✝¹² : CommSemiring R\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Algebra R S\ninst✝⁹ : Semiring A\ninst✝⁸ : Algebra R A\ninst✝⁷ : Algebra S A\ninst✝⁶ : IsScalarTower R S A\ninst✝⁵ : Semiring D\ninst✝⁴ : Algebra R D\ninst✝³ : Semiring E\ninst✝² : Algebra R E\ninst✝¹ : Semiring F\ninst✝ : Algebra R F\ng₂ : AlgHom R E F\ng₁ : AlgHom R D E\n⊢ Eq (Algebra.TensorProduct.map (AlgHom.id S A) (g₂.comp g₁)) ((Algebra.TensorProduct.map (AlgHom.id S A) g₂).comp (Algebra.TensorProduct.map (AlgHom.id S A) g₁))","decl":"lemma map_id_comp (g₂ : E →ₐ[R] F) (g₁ : D →ₐ[R] E) :\n    map (AlgHom.id S A) (g₂.comp g₁) = (map (AlgHom.id S A) g₂).comp (map (AlgHom.id S A) g₁) :=\n  ext (AlgHom.ext fun _ => rfl) (AlgHom.ext fun _ => rfl)\n\n"}
{"name":"Algebra.TensorProduct.map_comp_id","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\nE : Type uE\ninst✝¹⁶ : CommSemiring R\ninst✝¹⁵ : CommSemiring S\ninst✝¹⁴ : Algebra R S\ninst✝¹³ : Semiring A\ninst✝¹² : Algebra R A\ninst✝¹¹ : Algebra S A\ninst✝¹⁰ : IsScalarTower R S A\ninst✝⁹ : Semiring B\ninst✝⁸ : Algebra R B\ninst✝⁷ : Algebra S B\ninst✝⁶ : IsScalarTower R S B\ninst✝⁵ : Semiring C\ninst✝⁴ : Algebra R C\ninst✝³ : Semiring E\ninst✝² : Algebra R E\ninst✝¹ : Algebra S C\ninst✝ : IsScalarTower R S C\nf₂ : AlgHom S B C\nf₁ : AlgHom S A B\n⊢ Eq (Algebra.TensorProduct.map (f₂.comp f₁) (AlgHom.id R E)) ((Algebra.TensorProduct.map f₂ (AlgHom.id R E)).comp (Algebra.TensorProduct.map f₁ (AlgHom.id R E)))","decl":"lemma map_comp_id [Algebra S C] [IsScalarTower R S C]\n    (f₂ : B →ₐ[S] C) (f₁ : A →ₐ[S] B) :\n    map (f₂.comp f₁) (AlgHom.id R E) = (map f₂ (AlgHom.id R E)).comp (map f₁ (AlgHom.id R E)) :=\n  ext (AlgHom.ext fun _ => rfl) (AlgHom.ext fun _ => rfl)\n\n"}
{"name":"Algebra.TensorProduct.map_comp_includeLeft","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\ninst✝¹⁴ : CommSemiring R\ninst✝¹³ : CommSemiring S\ninst✝¹² : Algebra R S\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : Algebra S A\ninst✝⁸ : IsScalarTower R S A\ninst✝⁷ : Semiring B\ninst✝⁶ : Algebra R B\ninst✝⁵ : Algebra S B\ninst✝⁴ : IsScalarTower R S B\ninst✝³ : Semiring C\ninst✝² : Algebra R C\ninst✝¹ : Semiring D\ninst✝ : Algebra R D\nf : AlgHom S A B\ng : AlgHom R C D\n⊢ Eq ((Algebra.TensorProduct.map f g).comp Algebra.TensorProduct.includeLeft) (Algebra.TensorProduct.includeLeft.comp f)","decl":"@[simp]\ntheorem map_comp_includeLeft (f : A →ₐ[S] B) (g : C →ₐ[R] D) :\n    (map f g).comp includeLeft = includeLeft.comp f :=\n  AlgHom.ext <| by simp\n\n"}
{"name":"Algebra.TensorProduct.map_restrictScalars_comp_includeRight","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\ninst✝¹⁴ : CommSemiring R\ninst✝¹³ : CommSemiring S\ninst✝¹² : Algebra R S\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : Algebra S A\ninst✝⁸ : IsScalarTower R S A\ninst✝⁷ : Semiring B\ninst✝⁶ : Algebra R B\ninst✝⁵ : Algebra S B\ninst✝⁴ : IsScalarTower R S B\ninst✝³ : Semiring C\ninst✝² : Algebra R C\ninst✝¹ : Semiring D\ninst✝ : Algebra R D\nf : AlgHom S A B\ng : AlgHom R C D\n⊢ Eq ((AlgHom.restrictScalars R (Algebra.TensorProduct.map f g)).comp Algebra.TensorProduct.includeRight) (Algebra.TensorProduct.includeRight.comp g)","decl":"@[simp]\ntheorem map_restrictScalars_comp_includeRight (f : A →ₐ[S] B) (g : C →ₐ[R] D) :\n    ((map f g).restrictScalars R).comp includeRight = includeRight.comp g :=\n  AlgHom.ext <| by simp\n\n"}
{"name":"Algebra.TensorProduct.map_comp_includeRight","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Semiring C\ninst✝² : Algebra R C\ninst✝¹ : Semiring D\ninst✝ : Algebra R D\nf : AlgHom R A B\ng : AlgHom R C D\n⊢ Eq ((Algebra.TensorProduct.map f g).comp Algebra.TensorProduct.includeRight) (Algebra.TensorProduct.includeRight.comp g)","decl":"@[simp]\ntheorem map_comp_includeRight (f : A →ₐ[R] B) (g : C →ₐ[R] D) :\n    (map f g).comp includeRight = includeRight.comp g :=\n  map_restrictScalars_comp_includeRight f g\n\n"}
{"name":"Algebra.TensorProduct.map_range","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Semiring C\ninst✝² : Algebra R C\ninst✝¹ : Semiring D\ninst✝ : Algebra R D\nf : AlgHom R A B\ng : AlgHom R C D\n⊢ Eq (Algebra.TensorProduct.map f g).range (Max.max (Algebra.TensorProduct.includeLeft.comp f).range (Algebra.TensorProduct.includeRight.comp g).range)","decl":"theorem map_range (f : A →ₐ[R] B) (g : C →ₐ[R] D) :\n    (map f g).range = (includeLeft.comp f).range ⊔ (includeRight.comp g).range := by\n  apply le_antisymm\n  · rw [← map_top, ← adjoin_tmul_eq_top, ← adjoin_image, adjoin_le_iff]\n    rintro _ ⟨_, ⟨a, b, rfl⟩, rfl⟩\n    rw [map_tmul, ← mul_one (f a), ← one_mul (g b), ← tmul_mul_tmul]\n    exact mul_mem_sup (AlgHom.mem_range_self _ a) (AlgHom.mem_range_self _ b)\n  · rw [← map_comp_includeLeft f g, ← map_comp_includeRight f g]\n    exact sup_le (AlgHom.range_comp_le_range _ _) (AlgHom.range_comp_le_range _ _)\n\n"}
{"name":"Algebra.TensorProduct.comm_comp_map","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Semiring C\ninst✝² : Algebra R C\ninst✝¹ : Semiring D\ninst✝ : Algebra R D\nf : AlgHom R A C\ng : AlgHom R B D\n⊢ Eq ((↑(Algebra.TensorProduct.comm R C D)).comp (Algebra.TensorProduct.map f g)) ((Algebra.TensorProduct.map g f).comp ↑(Algebra.TensorProduct.comm R A B))","decl":"lemma comm_comp_map (f : A →ₐ[R] C) (g : B →ₐ[R] D) :\n    (TensorProduct.comm R C D : C ⊗[R] D →ₐ[R] D ⊗[R] C).comp (Algebra.TensorProduct.map f g) =\n    (Algebra.TensorProduct.map g f).comp (TensorProduct.comm R A B).toAlgHom := by\n  ext <;> rfl\n\n"}
{"name":"Algebra.TensorProduct.comm_comp_map_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Semiring C\ninst✝² : Algebra R C\ninst✝¹ : Semiring D\ninst✝ : Algebra R D\nf : AlgHom R A C\ng : AlgHom R B D\nx : TensorProduct R A B\n⊢ Eq ((Algebra.TensorProduct.comm R C D) ((Algebra.TensorProduct.map f g) x)) ((Algebra.TensorProduct.map g f) ((Algebra.TensorProduct.comm R A B) x))","decl":"lemma comm_comp_map_apply (f : A →ₐ[R] C) (g : B →ₐ[R] D) (x) :\n    TensorProduct.comm R C D (Algebra.TensorProduct.map f g x) =\n    (Algebra.TensorProduct.map g f) (TensorProduct.comm R A B x) :=\n  congr($(comm_comp_map f g) x)\n\n"}
{"name":"Algebra.TensorProduct.congr_toLinearEquiv","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\ninst✝¹⁴ : CommSemiring R\ninst✝¹³ : CommSemiring S\ninst✝¹² : Algebra R S\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : Algebra S A\ninst✝⁸ : IsScalarTower R S A\ninst✝⁷ : Semiring B\ninst✝⁶ : Algebra R B\ninst✝⁵ : Algebra S B\ninst✝⁴ : IsScalarTower R S B\ninst✝³ : Semiring C\ninst✝² : Algebra R C\ninst✝¹ : Semiring D\ninst✝ : Algebra R D\nf : AlgEquiv S A B\ng : AlgEquiv R C D\n⊢ Eq (Algebra.TensorProduct.congr f g).toLinearEquiv (TensorProduct.AlgebraTensorModule.congr f.toLinearEquiv g.toLinearEquiv)","decl":"@[simp] theorem congr_toLinearEquiv (f : A ≃ₐ[S] B) (g : C ≃ₐ[R] D) :\n    (Algebra.TensorProduct.congr f g).toLinearEquiv =\n      TensorProduct.AlgebraTensorModule.congr f.toLinearEquiv g.toLinearEquiv := rfl\n\n"}
{"name":"Algebra.TensorProduct.congr_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\ninst✝¹⁴ : CommSemiring R\ninst✝¹³ : CommSemiring S\ninst✝¹² : Algebra R S\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : Algebra S A\ninst✝⁸ : IsScalarTower R S A\ninst✝⁷ : Semiring B\ninst✝⁶ : Algebra R B\ninst✝⁵ : Algebra S B\ninst✝⁴ : IsScalarTower R S B\ninst✝³ : Semiring C\ninst✝² : Algebra R C\ninst✝¹ : Semiring D\ninst✝ : Algebra R D\nf : AlgEquiv S A B\ng : AlgEquiv R C D\nx : TensorProduct R A C\n⊢ Eq ((Algebra.TensorProduct.congr f g) x) ((Algebra.TensorProduct.map ↑f ↑g) x)","decl":"@[simp]\ntheorem congr_apply (f : A ≃ₐ[S] B) (g : C ≃ₐ[R] D) (x) :\n    congr f g x = (map (f : A →ₐ[S] B) (g : C →ₐ[R] D)) x :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.congr_symm_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\ninst✝¹⁴ : CommSemiring R\ninst✝¹³ : CommSemiring S\ninst✝¹² : Algebra R S\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : Algebra S A\ninst✝⁸ : IsScalarTower R S A\ninst✝⁷ : Semiring B\ninst✝⁶ : Algebra R B\ninst✝⁵ : Algebra S B\ninst✝⁴ : IsScalarTower R S B\ninst✝³ : Semiring C\ninst✝² : Algebra R C\ninst✝¹ : Semiring D\ninst✝ : Algebra R D\nf : AlgEquiv S A B\ng : AlgEquiv R C D\nx : TensorProduct R B D\n⊢ Eq ((Algebra.TensorProduct.congr f g).symm x) ((Algebra.TensorProduct.map ↑f.symm ↑g.symm) x)","decl":"@[simp]\ntheorem congr_symm_apply (f : A ≃ₐ[S] B) (g : C ≃ₐ[R] D) (x) :\n    (congr f g).symm x = (map (f.symm : B →ₐ[S] A) (g.symm : D →ₐ[R] C)) x :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.congr_refl","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nC : Type uC\ninst✝⁸ : CommSemiring R\ninst✝⁷ : CommSemiring S\ninst✝⁶ : Algebra R S\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra S A\ninst✝² : IsScalarTower R S A\ninst✝¹ : Semiring C\ninst✝ : Algebra R C\n⊢ Eq (Algebra.TensorProduct.congr AlgEquiv.refl AlgEquiv.refl) AlgEquiv.refl","decl":"@[simp]\ntheorem congr_refl : congr (.refl : A ≃ₐ[S] A) (.refl : C ≃ₐ[R] C) = .refl :=\n  AlgEquiv.coe_algHom_injective <| map_id\n\n"}
{"name":"Algebra.TensorProduct.congr_trans","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\nE : Type uE\nF : Type uF\ninst✝²⁰ : CommSemiring R\ninst✝¹⁹ : CommSemiring S\ninst✝¹⁸ : Algebra R S\ninst✝¹⁷ : Semiring A\ninst✝¹⁶ : Algebra R A\ninst✝¹⁵ : Algebra S A\ninst✝¹⁴ : IsScalarTower R S A\ninst✝¹³ : Semiring B\ninst✝¹² : Algebra R B\ninst✝¹¹ : Algebra S B\ninst✝¹⁰ : IsScalarTower R S B\ninst✝⁹ : Semiring C\ninst✝⁸ : Algebra R C\ninst✝⁷ : Semiring D\ninst✝⁶ : Algebra R D\ninst✝⁵ : Semiring E\ninst✝⁴ : Algebra R E\ninst✝³ : Semiring F\ninst✝² : Algebra R F\ninst✝¹ : Algebra S C\ninst✝ : IsScalarTower R S C\nf₁ : AlgEquiv S A B\nf₂ : AlgEquiv S B C\ng₁ : AlgEquiv R D E\ng₂ : AlgEquiv R E F\n⊢ Eq (Algebra.TensorProduct.congr (f₁.trans f₂) (g₁.trans g₂)) ((Algebra.TensorProduct.congr f₁ g₁).trans (Algebra.TensorProduct.congr f₂ g₂))","decl":"theorem congr_trans [Algebra S C] [IsScalarTower R S C]\n    (f₁ : A ≃ₐ[S] B) (f₂ : B ≃ₐ[S] C) (g₁ : D ≃ₐ[R] E) (g₂ : E ≃ₐ[R] F) :\n    congr (f₁.trans f₂) (g₁.trans g₂) = (congr f₁ g₁).trans (congr f₂ g₂) :=\n  AlgEquiv.coe_algHom_injective <| map_comp f₂.toAlgHom f₁.toAlgHom g₂.toAlgHom g₁.toAlgHom\n\n"}
{"name":"Algebra.TensorProduct.congr_symm","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\ninst✝¹⁴ : CommSemiring R\ninst✝¹³ : CommSemiring S\ninst✝¹² : Algebra R S\ninst✝¹¹ : Semiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : Algebra S A\ninst✝⁸ : IsScalarTower R S A\ninst✝⁷ : Semiring B\ninst✝⁶ : Algebra R B\ninst✝⁵ : Algebra S B\ninst✝⁴ : IsScalarTower R S B\ninst✝³ : Semiring C\ninst✝² : Algebra R C\ninst✝¹ : Semiring D\ninst✝ : Algebra R D\nf : AlgEquiv S A B\ng : AlgEquiv R C D\n⊢ Eq (Algebra.TensorProduct.congr f.symm g.symm) (Algebra.TensorProduct.congr f g).symm","decl":"theorem congr_symm (f : A ≃ₐ[S] B) (g : C ≃ₐ[R] D) : congr f.symm g.symm = (congr f g).symm := rfl\n\n"}
{"name":"Algebra.TensorProduct.leftComm_tmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nC : Type uC\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Semiring B\ninst✝² : Algebra R B\ninst✝¹ : Semiring C\ninst✝ : Algebra R C\nm : A\nn : B\np : C\n⊢ Eq ((Algebra.TensorProduct.leftComm R A B C) (TensorProduct.tmul R m (TensorProduct.tmul R n p))) (TensorProduct.tmul R n (TensorProduct.tmul R m p))","decl":"@[simp]\ntheorem leftComm_tmul (m : A) (n : B) (p : C) :\n    leftComm R A B C (m ⊗ₜ (n ⊗ₜ p)) = n ⊗ₜ (m ⊗ₜ p) :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.leftComm_symm_tmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nC : Type uC\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Semiring B\ninst✝² : Algebra R B\ninst✝¹ : Semiring C\ninst✝ : Algebra R C\nm : A\nn : B\np : C\n⊢ Eq ((Algebra.TensorProduct.leftComm R A B C).symm (TensorProduct.tmul R n (TensorProduct.tmul R m p))) (TensorProduct.tmul R m (TensorProduct.tmul R n p))","decl":"@[simp]\ntheorem leftComm_symm_tmul (m : A) (n : B) (p : C) :\n    (leftComm R A B C).symm (n ⊗ₜ (m ⊗ₜ p)) = m ⊗ₜ (n ⊗ₜ p) :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.leftComm_toLinearEquiv","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nC : Type uC\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Semiring B\ninst✝² : Algebra R B\ninst✝¹ : Semiring C\ninst✝ : Algebra R C\n⊢ Eq (↑(Algebra.TensorProduct.leftComm R A B C)) (TensorProduct.leftComm R A B C)","decl":"@[simp]\ntheorem leftComm_toLinearEquiv :\n    (leftComm R A B C : _ ≃ₗ[R] _) = _root_.TensorProduct.leftComm R A B C := rfl\n\n"}
{"name":"Algebra.TensorProduct.tensorTensorTensorComm_tmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Semiring C\ninst✝² : Algebra R C\ninst✝¹ : Semiring D\ninst✝ : Algebra R D\nm : A\nn : B\np : C\nq : D\n⊢ Eq ((Algebra.TensorProduct.tensorTensorTensorComm R A B C D) (TensorProduct.tmul R (TensorProduct.tmul R m n) (TensorProduct.tmul R p q))) (TensorProduct.tmul R (TensorProduct.tmul R m p) (TensorProduct.tmul R n q))","decl":"@[simp]\ntheorem tensorTensorTensorComm_tmul (m : A) (n : B) (p : C) (q : D) :\n    tensorTensorTensorComm R A B C D (m ⊗ₜ n ⊗ₜ (p ⊗ₜ q)) = m ⊗ₜ p ⊗ₜ (n ⊗ₜ q) :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.tensorTensorTensorComm_symm","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Semiring C\ninst✝² : Algebra R C\ninst✝¹ : Semiring D\ninst✝ : Algebra R D\n⊢ Eq (Algebra.TensorProduct.tensorTensorTensorComm R A B C D).symm (Algebra.TensorProduct.tensorTensorTensorComm R A C B D)","decl":"@[simp]\ntheorem tensorTensorTensorComm_symm :\n    (tensorTensorTensorComm R A B C D).symm = tensorTensorTensorComm R A C B D := by\n  ext; rfl\n\n"}
{"name":"Algebra.TensorProduct.tensorTensorTensorComm_toLinearEquiv","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nA : Type uA\nB : Type uB\nC : Type uC\nD : Type uD\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : Semiring B\ninst✝⁴ : Algebra R B\ninst✝³ : Semiring C\ninst✝² : Algebra R C\ninst✝¹ : Semiring D\ninst✝ : Algebra R D\n⊢ Eq (↑(Algebra.TensorProduct.tensorTensorTensorComm R A B C D)) (TensorProduct.tensorTensorTensorComm R A B C D)","decl":"@[simp]\ntheorem tensorTensorTensorComm_toLinearEquiv :\n    (tensorTensorTensorComm R A B C D : _ ≃ₗ[R] _) =\n      _root_.TensorProduct.tensorTensorTensorComm R A B C D := rfl\n\n"}
{"name":"Algebra.TensorProduct.lmul''_eq_lid_comp_mapOfCompatibleSMul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\n⊢ Eq (Algebra.TensorProduct.lmul'' R) ((↑(Algebra.TensorProduct.lid S S)).comp (Algebra.TensorProduct.mapOfCompatibleSMul' S R S S))","decl":"theorem lmul''_eq_lid_comp_mapOfCompatibleSMul :\n    lmul'' R = (TensorProduct.lid S S).toAlgHom.comp (mapOfCompatibleSMul' _ _ _ _) := by\n  ext; rfl\n\n"}
{"name":"Algebra.TensorProduct.lmul'_toLinearMap","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\n⊢ Eq (Algebra.TensorProduct.lmul' R).toLinearMap (LinearMap.mul' R S)","decl":"theorem lmul'_toLinearMap : (lmul' R : _ →ₐ[R] S).toLinearMap = LinearMap.mul' R S :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.lmul'_apply_tmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\na b : S\n⊢ Eq ((Algebra.TensorProduct.lmul' R) (TensorProduct.tmul R a b)) (HMul.hMul a b)","decl":"@[simp]\ntheorem lmul'_apply_tmul (a b : S) : lmul' (S := S) R (a ⊗ₜ[R] b) = a * b :=\n  rfl\n\n"}
{"name":"Algebra.TensorProduct.lmul'_comp_includeLeft","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\n⊢ Eq ((Algebra.TensorProduct.lmul' R).comp Algebra.TensorProduct.includeLeft) (AlgHom.id R S)","decl":"@[simp]\ntheorem lmul'_comp_includeLeft : (lmul' R : _ →ₐ[R] S).comp includeLeft = AlgHom.id R S :=\n  AlgHom.ext <| mul_one\n\n"}
{"name":"Algebra.TensorProduct.lmul'_comp_includeRight","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\n⊢ Eq ((Algebra.TensorProduct.lmul' R).comp Algebra.TensorProduct.includeRight) (AlgHom.id R S)","decl":"@[simp]\ntheorem lmul'_comp_includeRight : (lmul' R : _ →ₐ[R] S).comp includeRight = AlgHom.id R S :=\n  AlgHom.ext <| one_mul\n\n"}
{"name":"Algebra.TensorProduct.lmulEquiv_eq_lidOfCompatibleSMul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\ninst✝³ : CommSemiring R\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : TensorProduct.CompatibleSMul R S S S\n⊢ Eq (Algebra.TensorProduct.lmulEquiv R S) (Algebra.TensorProduct.lidOfCompatibleSMul R S S)","decl":"theorem lmulEquiv_eq_lidOfCompatibleSMul [CompatibleSMul R S S S] :\n    lmulEquiv R S = lidOfCompatibleSMul R S S :=\n  AlgEquiv.coe_algHom_injective <| by ext; rfl\n\n"}
{"name":"Algebra.TensorProduct.productMap_eq_comp_map","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Semiring B\ninst✝³ : CommSemiring S\ninst✝² : Algebra R A\ninst✝¹ : Algebra R B\ninst✝ : Algebra R S\nf : AlgHom R A S\ng : AlgHom R B S\n⊢ Eq (Algebra.TensorProduct.productMap f g) ((Algebra.TensorProduct.lmul' R).comp (Algebra.TensorProduct.map f g))","decl":"theorem productMap_eq_comp_map : productMap f g = (lmul' R).comp (TensorProduct.map f g) := by\n  ext <;> rfl\n\n"}
{"name":"Algebra.TensorProduct.productMap_apply_tmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Semiring B\ninst✝³ : CommSemiring S\ninst✝² : Algebra R A\ninst✝¹ : Algebra R B\ninst✝ : Algebra R S\nf : AlgHom R A S\ng : AlgHom R B S\na : A\nb : B\n⊢ Eq ((Algebra.TensorProduct.productMap f g) (TensorProduct.tmul R a b)) (HMul.hMul (f a) (g b))","decl":"@[simp]\ntheorem productMap_apply_tmul (a : A) (b : B) : productMap f g (a ⊗ₜ b) = f a * g b := rfl\n\n"}
{"name":"Algebra.TensorProduct.productMap_left_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Semiring B\ninst✝³ : CommSemiring S\ninst✝² : Algebra R A\ninst✝¹ : Algebra R B\ninst✝ : Algebra R S\nf : AlgHom R A S\ng : AlgHom R B S\na : A\n⊢ Eq ((Algebra.TensorProduct.productMap f g) (TensorProduct.tmul R a 1)) (f a)","decl":"theorem productMap_left_apply (a : A) : productMap f g (a ⊗ₜ 1) = f a := by\n  simp\n\n"}
{"name":"Algebra.TensorProduct.productMap_left","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Semiring B\ninst✝³ : CommSemiring S\ninst✝² : Algebra R A\ninst✝¹ : Algebra R B\ninst✝ : Algebra R S\nf : AlgHom R A S\ng : AlgHom R B S\n⊢ Eq ((Algebra.TensorProduct.productMap f g).comp Algebra.TensorProduct.includeLeft) f","decl":"@[simp]\ntheorem productMap_left : (productMap f g).comp includeLeft = f :=\n  lift_comp_includeLeft _ _ (fun _ _ => Commute.all _ _)\n\n"}
{"name":"Algebra.TensorProduct.productMap_right_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Semiring B\ninst✝³ : CommSemiring S\ninst✝² : Algebra R A\ninst✝¹ : Algebra R B\ninst✝ : Algebra R S\nf : AlgHom R A S\ng : AlgHom R B S\nb : B\n⊢ Eq ((Algebra.TensorProduct.productMap f g) (TensorProduct.tmul R 1 b)) (g b)","decl":"theorem productMap_right_apply (b : B) :\n    productMap f g (1 ⊗ₜ b) = g b := by simp\n\n"}
{"name":"Algebra.TensorProduct.productMap_right","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Semiring B\ninst✝³ : CommSemiring S\ninst✝² : Algebra R A\ninst✝¹ : Algebra R B\ninst✝ : Algebra R S\nf : AlgHom R A S\ng : AlgHom R B S\n⊢ Eq ((Algebra.TensorProduct.productMap f g).comp Algebra.TensorProduct.includeRight) g","decl":"@[simp]\ntheorem productMap_right : (productMap f g).comp includeRight = g :=\n  lift_comp_includeRight _ _ (fun _ _ => Commute.all _ _)\n\n"}
{"name":"Algebra.TensorProduct.productMap_range","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type uR\nS : Type uS\nA : Type uA\nB : Type uB\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Semiring B\ninst✝³ : CommSemiring S\ninst✝² : Algebra R A\ninst✝¹ : Algebra R B\ninst✝ : Algebra R S\nf : AlgHom R A S\ng : AlgHom R B S\n⊢ Eq (Algebra.TensorProduct.productMap f g).range (Max.max f.range g.range)","decl":"theorem productMap_range : (productMap f g).range = f.range ⊔ g.range := by\n  rw [productMap_eq_comp_map, AlgHom.range_comp, map_range, map_sup, ← AlgHom.range_comp,\n    ← AlgHom.range_comp,\n    ← AlgHom.comp_assoc, ← AlgHom.comp_assoc, lmul'_comp_includeLeft, lmul'_comp_includeRight,\n    AlgHom.id_comp, AlgHom.id_comp]\n\n"}
{"name":"Algebra.baseChange_lmul","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nB : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring B\ninst✝² : Algebra R B\nA : Type u_3\ninst✝¹ : CommSemiring A\ninst✝ : Algebra R A\nf : B\n⊢ Eq (LinearMap.baseChange A ((Algebra.lmul R B) f)) ((Algebra.lmul A (TensorProduct R A B)) (TensorProduct.tmul R 1 f))","decl":"lemma Algebra.baseChange_lmul {R B : Type*} [CommSemiring R] [Semiring B] [Algebra R B]\n    {A : Type*} [CommSemiring A] [Algebra R A] (f : B) :\n    (Algebra.lmul R B f).baseChange A = Algebra.lmul A (A ⊗[R] B) (1 ⊗ₜ f) := by\n  ext i\n  simp\n\n"}
{"name":"LinearMap.tensorProduct_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring A\ninst✝⁴ : Algebra R A\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\na✝ : TensorProduct R A (LinearMap (RingHom.id R) M N)\n⊢ Eq ((LinearMap.tensorProduct R A M N) a✝) ((TensorProduct.liftAux (↑R { toFun := fun a => HSMul.hSMul a (LinearMap.baseChangeHom R A M N), map_add' := ⋯, map_smul' := ⋯ })) a✝)","decl":"/-- The natural linear map $A ⊗ \\text{Hom}_R(M, N) → \\text{Hom}_A (M_A, N_A)$,\nwhere $M_A$ and $N_A$ are the respective modules over $A$ obtained by extension of scalars.\n\nSee `LinearMap.tensorProductEnd` for this map specialized to endomorphisms,\nand bundled as `A`-algebra homomorphism. -/\n@[simps!]\nnoncomputable\ndef tensorProduct : A ⊗[R] (M →ₗ[R] N) →ₗ[A] (A ⊗[R] M) →ₗ[A] (A ⊗[R] N) :=\n  TensorProduct.AlgebraTensorModule.lift <|\n  { toFun := fun a ↦ a • baseChangeHom R A M N\n    map_add' := by simp only [add_smul, forall_true_iff]\n    map_smul' := by simp only [smul_assoc, RingHom.id_apply, forall_true_iff] }\n\n"}
{"name":"LinearMap.tensorProductEnd_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nM : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring A\ninst✝² : Algebra R A\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : TensorProduct R A (Module.End R M)\n⊢ Eq ((LinearMap.tensorProductEnd R A M) a) ((TensorProduct.liftAux (↑R { toFun := fun a => HSMul.hSMul a (LinearMap.baseChangeHom R A M M), map_add' := ⋯, map_smul' := ⋯ })) a)","decl":"/-- The natural `A`-algebra homomorphism $A ⊗ (\\text{End}_R M) → \\text{End}_A (A ⊗ M)$,\nwhere `M` is an `R`-module, and `A` an `R`-algebra. -/\n@[simps!]\nnoncomputable\ndef tensorProductEnd : A ⊗[R] (End R M) →ₐ[A] End A (A ⊗[R] M) :=\n  Algebra.TensorProduct.algHomOfLinearMapTensorProduct\n    (LinearMap.tensorProduct R A M M)\n    (fun a b f g ↦ by\n      apply LinearMap.ext\n      intro x\n      simp only [tensorProduct, mul_comm a b, mul_eq_comp,\n        TensorProduct.AlgebraTensorModule.lift_apply, TensorProduct.lift.tmul, coe_restrictScalars,\n        coe_mk, AddHom.coe_mk, mul_smul, smul_apply, baseChangeHom_apply, baseChange_comp,\n        comp_apply, Algebra.mul_smul_comm, Algebra.smul_mul_assoc])\n    (by\n      apply LinearMap.ext\n      intro x\n      simp only [tensorProduct, TensorProduct.AlgebraTensorModule.lift_apply,\n        TensorProduct.lift.tmul, coe_restrictScalars, coe_mk, AddHom.coe_mk, one_smul,\n        baseChangeHom_apply, baseChange_eq_ltensor, one_apply, one_eq_id, lTensor_id,\n        LinearMap.id_apply])\n\n"}
{"name":"Module.endTensorEndAlgHom_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝¹⁴ : CommSemiring R\ninst✝¹³ : CommSemiring S\ninst✝¹² : Semiring A\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : AddCommMonoid N\ninst✝⁹ : Algebra R S\ninst✝⁸ : Algebra S A\ninst✝⁷ : Algebra R A\ninst✝⁶ : Module R M\ninst✝⁵ : Module S M\ninst✝⁴ : Module A M\ninst✝³ : Module R N\ninst✝² : IsScalarTower R A M\ninst✝¹ : IsScalarTower S A M\ninst✝ : IsScalarTower R S M\nf : Module.End A M\ng : Module.End R N\n⊢ Eq (Module.endTensorEndAlgHom (TensorProduct.tmul R f g)) (TensorProduct.AlgebraTensorModule.map f g)","decl":"theorem endTensorEndAlgHom_apply (f : End A M) (g : End R N) :\n    endTensorEndAlgHom (R := R) (S := S) (A := A) (M := M) (N := N) (f ⊗ₜ[R] g)\n      = AlgebraTensorModule.map f g :=\n  rfl\n\n"}
{"name":"TensorProduct.Algebra.moduleAux_apply","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nM : Type u_4\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\ninst✝⁷ : Semiring A\ninst✝⁶ : Semiring B\ninst✝⁵ : Module A M\ninst✝⁴ : Module B M\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\ninst✝¹ : IsScalarTower R A M\ninst✝ : IsScalarTower R B M\na : A\nb : B\nm : M\n⊢ Eq ((TensorProduct.Algebra.moduleAux (TensorProduct.tmul R a b)) m) (HSMul.hSMul a (HSMul.hSMul b m))","decl":"theorem moduleAux_apply (a : A) (b : B) (m : M) : moduleAux (a ⊗ₜ[R] b) m = a • b • m :=\n  rfl\n\n"}
{"name":"TensorProduct.Algebra.smul_def","module":"Mathlib.RingTheory.TensorProduct.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nM : Type u_4\ninst✝¹¹ : CommSemiring R\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : Module R M\ninst✝⁸ : Semiring A\ninst✝⁷ : Semiring B\ninst✝⁶ : Module A M\ninst✝⁵ : Module B M\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\ninst✝² : IsScalarTower R A M\ninst✝¹ : IsScalarTower R B M\ninst✝ : SMulCommClass A B M\na : A\nb : B\nm : M\n⊢ Eq (HSMul.hSMul (TensorProduct.tmul R a b) m) (HSMul.hSMul a (HSMul.hSMul b m))","decl":"theorem smul_def (a : A) (b : B) (m : M) : a ⊗ₜ[R] b • m = a • b • m :=\n  rfl\n\n"}
