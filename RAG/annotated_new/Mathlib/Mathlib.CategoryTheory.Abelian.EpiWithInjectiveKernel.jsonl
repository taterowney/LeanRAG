{"name":"CategoryTheory.Abelian.epiWithInjectiveKernel_iff","module":"Mathlib.CategoryTheory.Abelian.EpiWithInjectiveKernel","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\nX Y : C\ng : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.Abelian.epiWithInjectiveKernel g) (Exists fun I => Exists fun x => Exists fun f => Exists fun w => Nonempty (CategoryTheory.ShortComplex.mk f g w).Splitting)","decl":"/-- A morphism `g : X ⟶ Y` is epi with an injective kernel iff there exists a morphism\n`f : I ⟶ X` with `I` injective such that `f ≫ g = 0` and\nthe short complex `I ⟶ X ⟶ Y` has a splitting. -/\nlemma epiWithInjectiveKernel_iff {X Y : C} (g : X ⟶ Y) :\n    epiWithInjectiveKernel g ↔ ∃ (I : C) (_ : Injective I) (f : I ⟶ X) (w : f ≫ g = 0),\n      Nonempty (ShortComplex.mk f g w).Splitting := by\n  constructor\n  · rintro ⟨_, _⟩\n    let S := ShortComplex.mk (kernel.ι g) g (by simp)\n    exact ⟨_, inferInstance, _, S.zero,\n      ⟨ShortComplex.Splitting.ofExactOfRetraction S\n        (S.exact_of_f_is_kernel (kernelIsKernel g)) (Injective.factorThru (𝟙 _) (kernel.ι g))\n        (by simp [S]) inferInstance⟩⟩\n  · rintro ⟨I, _,  f, w, ⟨σ⟩⟩\n    have : IsSplitEpi g := ⟨σ.s, σ.s_g⟩\n    let e : I ≅ kernel g :=\n      IsLimit.conePointUniqueUpToIso σ.shortExact.fIsKernel (limit.isLimit _)\n    exact ⟨inferInstance, Injective.of_iso e inferInstance⟩\n\n"}
{"name":"CategoryTheory.Abelian.epiWithInjectiveKernel_of_iso","module":"Mathlib.CategoryTheory.Abelian.EpiWithInjectiveKernel","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\n⊢ CategoryTheory.Abelian.epiWithInjectiveKernel f","decl":"lemma epiWithInjectiveKernel_of_iso {X Y : C} (f : X ⟶ Y) [IsIso f] :\n    epiWithInjectiveKernel f := by\n  rw [epiWithInjectiveKernel_iff]\n  exact ⟨0, inferInstance, 0, by simp,\n    ⟨ShortComplex.Splitting.ofIsZeroOfIsIso _ (isZero_zero C) (by dsimp; infer_instance)⟩⟩\n\n"}
{"name":"CategoryTheory.Abelian.instIsMultiplicativeEpiWithInjectiveKernel","module":"Mathlib.CategoryTheory.Abelian.EpiWithInjectiveKernel","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Abelian C\n⊢ CategoryTheory.Abelian.epiWithInjectiveKernel.IsMultiplicative","decl":"instance : (epiWithInjectiveKernel : MorphismProperty C).IsMultiplicative where\n  id_mem _ := epiWithInjectiveKernel_of_iso _\n  comp_mem {X Y Z} g₁ g₂ hg₁ hg₂ := by\n    rw [epiWithInjectiveKernel_iff] at hg₁ hg₂ ⊢\n    obtain ⟨I₁, _, f₁, w₁, ⟨σ₁⟩⟩ := hg₁\n    obtain ⟨I₂, _, f₂, w₂, ⟨σ₂⟩⟩ := hg₂\n    refine ⟨I₁ ⊞ I₂, inferInstance, biprod.fst ≫ f₁ + biprod.snd ≫ f₂ ≫ σ₁.s, ?_, ⟨?_⟩⟩\n    · ext\n      · simp [reassoc_of% w₁]\n      · simp [reassoc_of% σ₁.s_g, w₂]\n    · exact\n        { r := σ₁.r ≫ biprod.inl + g₁ ≫ σ₂.r ≫ biprod.inr\n          s := σ₂.s ≫ σ₁.s\n          f_r := by\n            ext\n            · simp [σ₁.f_r]\n            · simp [reassoc_of% w₁]\n            · simp\n            · simp [reassoc_of% σ₁.s_g, σ₂.f_r]\n          s_g := by simp [reassoc_of% σ₁.s_g, σ₂.s_g]\n          id := by\n            dsimp\n            have h := g₁ ≫= σ₂.id =≫ σ₁.s\n            simp only [add_comp, assoc, comp_add, id_comp] at h\n            rw [← σ₁.id, ← h]\n            simp only [comp_add, add_comp, assoc, BinaryBicone.inl_fst_assoc,\n              BinaryBicone.inr_fst_assoc, zero_comp, comp_zero, add_zero,\n              BinaryBicone.inl_snd_assoc, BinaryBicone.inr_snd_assoc, zero_add]\n            abel }\n\n"}
