{"name":"CategoryTheory.Abelian.epiWithInjectiveKernel_iff","module":"Mathlib.CategoryTheory.Abelian.EpiWithInjectiveKernel","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Abelian C\nX Y : C\ng : Quiver.Hom X Y\nâŠ¢ Iff (CategoryTheory.Abelian.epiWithInjectiveKernel g) (Exists fun I => Exists fun x => Exists fun f => Exists fun w => Nonempty (CategoryTheory.ShortComplex.mk f g w).Splitting)","decl":"/-- A morphism `g : X âŸ¶ Y` is epi with an injective kernel iff there exists a morphism\n`f : I âŸ¶ X` with `I` injective such that `f â‰« g = 0` and\nthe short complex `I âŸ¶ X âŸ¶ Y` has a splitting. -/\nlemma epiWithInjectiveKernel_iff {X Y : C} (g : X âŸ¶ Y) :\n    epiWithInjectiveKernel g â†” âˆƒ (I : C) (_ : Injective I) (f : I âŸ¶ X) (w : f â‰« g = 0),\n      Nonempty (ShortComplex.mk f g w).Splitting := by\n  constructor\n  Â· rintro âŸ¨_, _âŸ©\n    let S := ShortComplex.mk (kernel.Î¹ g) g (by simp)\n    exact âŸ¨_, inferInstance, _, S.zero,\n      âŸ¨ShortComplex.Splitting.ofExactOfRetraction S\n        (S.exact_of_f_is_kernel (kernelIsKernel g)) (Injective.factorThru (ğŸ™ _) (kernel.Î¹ g))\n        (by simp [S]) inferInstanceâŸ©âŸ©\n  Â· rintro âŸ¨I, _,  f, w, âŸ¨ÏƒâŸ©âŸ©\n    have : IsSplitEpi g := âŸ¨Ïƒ.s, Ïƒ.s_gâŸ©\n    let e : I â‰… kernel g :=\n      IsLimit.conePointUniqueUpToIso Ïƒ.shortExact.fIsKernel (limit.isLimit _)\n    exact âŸ¨inferInstance, Injective.of_iso e inferInstanceâŸ©\n\n"}
{"name":"CategoryTheory.Abelian.epiWithInjectiveKernel_of_iso","module":"Mathlib.CategoryTheory.Abelian.EpiWithInjectiveKernel","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsIso f\nâŠ¢ CategoryTheory.Abelian.epiWithInjectiveKernel f","decl":"lemma epiWithInjectiveKernel_of_iso {X Y : C} (f : X âŸ¶ Y) [IsIso f] :\n    epiWithInjectiveKernel f := by\n  rw [epiWithInjectiveKernel_iff]\n  exact âŸ¨0, inferInstance, 0, by simp,\n    âŸ¨ShortComplex.Splitting.ofIsZeroOfIsIso _ (isZero_zero C) (by dsimp; infer_instance)âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Abelian.instIsMultiplicativeEpiWithInjectiveKernel","module":"Mathlib.CategoryTheory.Abelian.EpiWithInjectiveKernel","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Abelian C\nâŠ¢ CategoryTheory.Abelian.epiWithInjectiveKernel.IsMultiplicative","decl":"instance : (epiWithInjectiveKernel : MorphismProperty C).IsMultiplicative where\n  id_mem _ := epiWithInjectiveKernel_of_iso _\n  comp_mem {X Y Z} gâ‚ gâ‚‚ hgâ‚ hgâ‚‚ := by\n    rw [epiWithInjectiveKernel_iff] at hgâ‚ hgâ‚‚ âŠ¢\n    obtain âŸ¨Iâ‚, _, fâ‚, wâ‚, âŸ¨Ïƒâ‚âŸ©âŸ© := hgâ‚\n    obtain âŸ¨Iâ‚‚, _, fâ‚‚, wâ‚‚, âŸ¨Ïƒâ‚‚âŸ©âŸ© := hgâ‚‚\n    refine âŸ¨Iâ‚ âŠ Iâ‚‚, inferInstance, biprod.fst â‰« fâ‚ + biprod.snd â‰« fâ‚‚ â‰« Ïƒâ‚.s, ?_, âŸ¨?_âŸ©âŸ©\n    Â· ext\n      Â· simp [reassoc_of% wâ‚]\n      Â· simp [reassoc_of% Ïƒâ‚.s_g, wâ‚‚]\n    Â· exact\n        { r := Ïƒâ‚.r â‰« biprod.inl + gâ‚ â‰« Ïƒâ‚‚.r â‰« biprod.inr\n          s := Ïƒâ‚‚.s â‰« Ïƒâ‚.s\n          f_r := by\n            ext\n            Â· simp [Ïƒâ‚.f_r]\n            Â· simp [reassoc_of% wâ‚]\n            Â· simp\n            Â· simp [reassoc_of% Ïƒâ‚.s_g, Ïƒâ‚‚.f_r]\n          s_g := by simp [reassoc_of% Ïƒâ‚.s_g, Ïƒâ‚‚.s_g]\n          id := by\n            dsimp\n            have h := gâ‚ â‰«= Ïƒâ‚‚.id =â‰« Ïƒâ‚.s\n            simp only [add_comp, assoc, comp_add, id_comp] at h\n            rw [â† Ïƒâ‚.id, â† h]\n            simp only [comp_add, add_comp, assoc, BinaryBicone.inl_fst_assoc,\n              BinaryBicone.inr_fst_assoc, zero_comp, comp_zero, add_zero,\n              BinaryBicone.inl_snd_assoc, BinaryBicone.inr_snd_assoc, zero_add]\n            abel }\n\n"}
