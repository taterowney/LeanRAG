{"name":"TopCat.Presheaf.isGluing_iff_pairwise","module":"Mathlib.Topology.Sheaves.SheafCondition.UniqueGluing","initialProofState":"X : TopCat\nF : TopCat.Presheaf (Type u) X\nι : Type x\nU : ι → TopologicalSpace.Opens ↑X\nsf : (i : ι) → (CategoryTheory.forget (Type u)).obj (F.obj { unop := U i })\ns : (CategoryTheory.forget (Type u)).obj (F.obj { unop := iSup U })\n⊢ Iff (F.IsGluing U sf s) (∀ (i : Opposite (CategoryTheory.Pairwise ι)), Eq ((CategoryTheory.Functor.mapCone F (CategoryTheory.Pairwise.cocone U).op).π.app i s) (TopCat.Presheaf.objPairwiseOfFamily sf i))","decl":"theorem isGluing_iff_pairwise {sf s} : IsGluing F U sf s ↔\n    ∀ i, (F.mapCone (Pairwise.cocone U).op).π.app i s = objPairwiseOfFamily sf i := by\n  refine ⟨fun h ↦ ?_, fun h i ↦ h (op <| Pairwise.single i)⟩\n  rintro (i|⟨i,j⟩)\n  · exact h i\n  · rw [← (F.mapCone (Pairwise.cocone U).op).w (op <| Pairwise.Hom.left i j)]\n    exact congr_arg _ (h i)\n\n"}
{"name":"TopCat.Presheaf.isSheaf_iff_isSheafUniqueGluing_types","module":"Mathlib.Topology.Sheaves.SheafCondition.UniqueGluing","initialProofState":"X : TopCat\nF : TopCat.Presheaf (Type u) X\n⊢ Iff F.IsSheaf F.IsSheafUniqueGluing","decl":"/-- For type-valued presheaves, the sheaf condition in terms of unique gluings is equivalent to the\nusual sheaf condition.\n-/\ntheorem isSheaf_iff_isSheafUniqueGluing_types : F.IsSheaf ↔ F.IsSheafUniqueGluing := by\n  simp_rw [isSheaf_iff_isSheafPairwiseIntersections, IsSheafPairwiseIntersections,\n    Types.isLimit_iff, IsSheafUniqueGluing, isGluing_iff_pairwise]\n  refine forall₂_congr fun ι U ↦ ⟨fun h sf cpt ↦ ?_, fun h s hs ↦ ?_⟩\n  · exact h _ cpt.sectionPairwise.prop\n  · specialize h (fun i ↦ s <| op <| Pairwise.single i) fun i j ↦\n      (hs <| op <| Pairwise.Hom.left i j).trans (hs <| op <| Pairwise.Hom.right i j).symm\n    convert h; ext (i|⟨i,j⟩)\n    · rfl\n    · exact (hs <| op <| Pairwise.Hom.left i j).symm\n\n"}
{"name":"TopCat.Presheaf.isSheaf_of_isSheafUniqueGluing_types","module":"Mathlib.Topology.Sheaves.SheafCondition.UniqueGluing","initialProofState":"X : TopCat\nF : TopCat.Presheaf (Type u) X\nFsh : F.IsSheafUniqueGluing\n⊢ F.IsSheaf","decl":"/-- The usual sheaf condition can be obtained from the sheaf condition\nin terms of unique gluings.\n-/\ntheorem isSheaf_of_isSheafUniqueGluing_types (Fsh : F.IsSheafUniqueGluing) : F.IsSheaf :=\n  (isSheaf_iff_isSheafUniqueGluing_types F).mpr Fsh\n\n"}
{"name":"TopCat.Presheaf.isSheaf_iff_isSheafUniqueGluing","module":"Mathlib.Topology.Sheaves.SheafCondition.UniqueGluing","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.HasForget C\ninst✝² : CategoryTheory.Limits.HasLimits C\ninst✝¹ : (CategoryTheory.forget C).ReflectsIsomorphisms\ninst✝ : CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget C)\nX : TopCat\nF : TopCat.Presheaf C X\n⊢ Iff F.IsSheaf F.IsSheafUniqueGluing","decl":"/-- For presheaves valued in a concrete category, whose forgetful functor reflects isomorphisms and\npreserves limits, the sheaf condition in terms of unique gluings is equivalent to the usual one.\n-/\ntheorem isSheaf_iff_isSheafUniqueGluing : F.IsSheaf ↔ F.IsSheafUniqueGluing :=\n  Iff.trans (isSheaf_iff_isSheaf_comp (forget C) F)\n    (isSheaf_iff_isSheafUniqueGluing_types (F ⋙ forget C))\n\n"}
{"name":"TopCat.Sheaf.existsUnique_gluing","module":"Mathlib.Topology.Sheaves.SheafCondition.UniqueGluing","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.HasForget C\ninst✝² : CategoryTheory.Limits.HasLimits C\ninst✝¹ : CategoryTheory.HasForget.forget.ReflectsIsomorphisms\ninst✝ : CategoryTheory.Limits.PreservesLimits CategoryTheory.HasForget.forget\nX : TopCat\nF : TopCat.Sheaf C X\nι : Type v\nU : ι → TopologicalSpace.Opens ↑X\nsf : (i : ι) → (CategoryTheory.forget C).obj (F.val.obj { unop := U i })\nh : TopCat.Presheaf.IsCompatible F.val U sf\n⊢ ExistsUnique fun s => TopCat.Presheaf.IsGluing F.val U sf s","decl":"/-- A more convenient way of obtaining a unique gluing of sections for a sheaf.\n-/\ntheorem existsUnique_gluing (sf : ∀ i : ι, F.1.obj (op (U i))) (h : IsCompatible F.1 U sf) :\n    ∃! s : F.1.obj (op (iSup U)), IsGluing F.1 U sf s :=\n  (isSheaf_iff_isSheafUniqueGluing F.1).mp F.cond U sf h\n\n"}
{"name":"TopCat.Sheaf.existsUnique_gluing'","module":"Mathlib.Topology.Sheaves.SheafCondition.UniqueGluing","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.HasForget C\ninst✝² : CategoryTheory.Limits.HasLimits C\ninst✝¹ : CategoryTheory.HasForget.forget.ReflectsIsomorphisms\ninst✝ : CategoryTheory.Limits.PreservesLimits CategoryTheory.HasForget.forget\nX : TopCat\nF : TopCat.Sheaf C X\nι : Type v\nU : ι → TopologicalSpace.Opens ↑X\nV : TopologicalSpace.Opens ↑X\niUV : (i : ι) → Quiver.Hom (U i) V\nhcover : LE.le V (iSup U)\nsf : (i : ι) → (CategoryTheory.forget C).obj (F.val.obj { unop := U i })\nh : TopCat.Presheaf.IsCompatible F.val U sf\n⊢ ExistsUnique fun s => ∀ (i : ι), Eq ((F.val.map (iUV i).op) s) (sf i)","decl":"/-- In this version of the lemma, the inclusion homs `iUV` can be specified directly by the user,\nwhich can be more convenient in practice.\n-/\ntheorem existsUnique_gluing' (V : Opens X) (iUV : ∀ i : ι, U i ⟶ V) (hcover : V ≤ iSup U)\n    (sf : ∀ i : ι, F.1.obj (op (U i))) (h : IsCompatible F.1 U sf) :\n    ∃! s : F.1.obj (op V), ∀ i : ι, F.1.map (iUV i).op s = sf i := by\n  have V_eq_supr_U : V = iSup U := le_antisymm hcover (iSup_le fun i => (iUV i).le)\n  obtain ⟨gl, gl_spec, gl_uniq⟩ := F.existsUnique_gluing U sf h\n  refine ⟨F.1.map (eqToHom V_eq_supr_U).op gl, ?_, ?_⟩\n  · intro i\n    rw [← CategoryTheory.comp_apply, ← F.1.map_comp]\n    exact gl_spec i\n  · intro gl' gl'_spec\n    convert congr_arg _ (gl_uniq (F.1.map (eqToHom V_eq_supr_U.symm).op gl') fun i => _) <;>\n      rw [← CategoryTheory.comp_apply, ← F.1.map_comp]\n    · rw [eqToHom_op, eqToHom_op, eqToHom_trans, eqToHom_refl, F.1.map_id, CategoryTheory.id_apply]\n    · convert gl'_spec i\n\n"}
{"name":"TopCat.Sheaf.eq_of_locally_eq","module":"Mathlib.Topology.Sheaves.SheafCondition.UniqueGluing","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.HasForget C\ninst✝² : CategoryTheory.Limits.HasLimits C\ninst✝¹ : CategoryTheory.HasForget.forget.ReflectsIsomorphisms\ninst✝ : CategoryTheory.Limits.PreservesLimits CategoryTheory.HasForget.forget\nX : TopCat\nF : TopCat.Sheaf C X\nι : Type v\nU : ι → TopologicalSpace.Opens ↑X\ns t : (CategoryTheory.forget C).obj (F.val.obj { unop := iSup U })\nh : ∀ (i : ι), Eq ((F.val.map (TopologicalSpace.Opens.leSupr U i).op) s) ((F.val.map (TopologicalSpace.Opens.leSupr U i).op) t)\n⊢ Eq s t","decl":"@[ext]\ntheorem eq_of_locally_eq (s t : F.1.obj (op (iSup U)))\n    (h : ∀ i, F.1.map (Opens.leSupr U i).op s = F.1.map (Opens.leSupr U i).op t) : s = t := by\n  let sf : ∀ i : ι, F.1.obj (op (U i)) := fun i => F.1.map (Opens.leSupr U i).op s\n  have sf_compatible : IsCompatible _ U sf := by\n    intro i j\n    simp_rw [sf, ← CategoryTheory.comp_apply, ← F.1.map_comp]\n    rfl\n  obtain ⟨gl, -, gl_uniq⟩ := F.existsUnique_gluing U sf sf_compatible\n  trans gl\n  · apply gl_uniq\n    intro i\n    rfl\n  · symm\n    apply gl_uniq\n    intro i\n    rw [← h]\n\n"}
{"name":"TopCat.Sheaf.eq_of_locally_eq_iff","module":"Mathlib.Topology.Sheaves.SheafCondition.UniqueGluing","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.HasForget C\ninst✝² : CategoryTheory.Limits.HasLimits C\ninst✝¹ : CategoryTheory.HasForget.forget.ReflectsIsomorphisms\ninst✝ : CategoryTheory.Limits.PreservesLimits CategoryTheory.HasForget.forget\nX : TopCat\nF : TopCat.Sheaf C X\nι : Type v\nU : ι → TopologicalSpace.Opens ↑X\ns t : (CategoryTheory.forget C).obj (F.val.obj { unop := iSup U })\n⊢ Iff (Eq s t) (∀ (i : ι), Eq ((F.val.map (TopologicalSpace.Opens.leSupr U i).op) s) ((F.val.map (TopologicalSpace.Opens.leSupr U i).op) t))","decl":"@[ext]\ntheorem eq_of_locally_eq (s t : F.1.obj (op (iSup U)))\n    (h : ∀ i, F.1.map (Opens.leSupr U i).op s = F.1.map (Opens.leSupr U i).op t) : s = t := by\n  let sf : ∀ i : ι, F.1.obj (op (U i)) := fun i => F.1.map (Opens.leSupr U i).op s\n  have sf_compatible : IsCompatible _ U sf := by\n    intro i j\n    simp_rw [sf, ← CategoryTheory.comp_apply, ← F.1.map_comp]\n    rfl\n  obtain ⟨gl, -, gl_uniq⟩ := F.existsUnique_gluing U sf sf_compatible\n  trans gl\n  · apply gl_uniq\n    intro i\n    rfl\n  · symm\n    apply gl_uniq\n    intro i\n    rw [← h]\n\n"}
{"name":"TopCat.Sheaf.eq_of_locally_eq'","module":"Mathlib.Topology.Sheaves.SheafCondition.UniqueGluing","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.HasForget C\ninst✝² : CategoryTheory.Limits.HasLimits C\ninst✝¹ : CategoryTheory.HasForget.forget.ReflectsIsomorphisms\ninst✝ : CategoryTheory.Limits.PreservesLimits CategoryTheory.HasForget.forget\nX : TopCat\nF : TopCat.Sheaf C X\nι : Type v\nU : ι → TopologicalSpace.Opens ↑X\nV : TopologicalSpace.Opens ↑X\niUV : (i : ι) → Quiver.Hom (U i) V\nhcover : LE.le V (iSup U)\ns t : (CategoryTheory.forget C).obj (F.val.obj { unop := V })\nh : ∀ (i : ι), Eq ((F.val.map (iUV i).op) s) ((F.val.map (iUV i).op) t)\n⊢ Eq s t","decl":"/-- In this version of the lemma, the inclusion homs `iUV` can be specified directly by the user,\nwhich can be more convenient in practice.\n-/\ntheorem eq_of_locally_eq' (V : Opens X) (iUV : ∀ i : ι, U i ⟶ V) (hcover : V ≤ iSup U)\n    (s t : F.1.obj (op V)) (h : ∀ i, F.1.map (iUV i).op s = F.1.map (iUV i).op t) : s = t := by\n  have V_eq_supr_U : V = iSup U := le_antisymm hcover (iSup_le fun i => (iUV i).le)\n  suffices F.1.map (eqToHom V_eq_supr_U.symm).op s = F.1.map (eqToHom V_eq_supr_U.symm).op t by\n    convert congr_arg (F.1.map (eqToHom V_eq_supr_U).op) this <;>\n    rw [← CategoryTheory.comp_apply, ← F.1.map_comp, eqToHom_op, eqToHom_op, eqToHom_trans,\n      eqToHom_refl, F.1.map_id, CategoryTheory.id_apply]\n  apply eq_of_locally_eq\n  intro i\n  rw [← CategoryTheory.comp_apply, ← CategoryTheory.comp_apply, ← F.1.map_comp]\n  convert h i\n\n"}
{"name":"TopCat.Sheaf.eq_of_locally_eq₂","module":"Mathlib.Topology.Sheaves.SheafCondition.UniqueGluing","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.HasForget C\ninst✝² : CategoryTheory.Limits.HasLimits C\ninst✝¹ : CategoryTheory.HasForget.forget.ReflectsIsomorphisms\ninst✝ : CategoryTheory.Limits.PreservesLimits CategoryTheory.HasForget.forget\nX : TopCat\nF : TopCat.Sheaf C X\nU₁ U₂ V : TopologicalSpace.Opens ↑X\ni₁ : Quiver.Hom U₁ V\ni₂ : Quiver.Hom U₂ V\nhcover : LE.le V (Max.max U₁ U₂)\ns t : (CategoryTheory.forget C).obj (F.val.obj { unop := V })\nh₁ : Eq ((F.val.map i₁.op) s) ((F.val.map i₁.op) t)\nh₂ : Eq ((F.val.map i₂.op) s) ((F.val.map i₂.op) t)\n⊢ Eq s t","decl":"theorem eq_of_locally_eq₂ {U₁ U₂ V : Opens X} (i₁ : U₁ ⟶ V) (i₂ : U₂ ⟶ V) (hcover : V ≤ U₁ ⊔ U₂)\n    (s t : F.1.obj (op V)) (h₁ : F.1.map i₁.op s = F.1.map i₁.op t)\n    (h₂ : F.1.map i₂.op s = F.1.map i₂.op t) : s = t := by\n  classical\n    fapply F.eq_of_locally_eq' fun t : ULift Bool => if t.1 then U₁ else U₂\n    · exact fun i => if h : i.1 then eqToHom (if_pos h) ≫ i₁ else eqToHom (if_neg h) ≫ i₂\n    · refine le_trans hcover ?_\n      rw [sup_le_iff]\n      constructor\n      · convert le_iSup (fun t : ULift Bool => if t.1 then U₁ else U₂) (ULift.up true)\n      · convert le_iSup (fun t : ULift Bool => if t.1 then U₁ else U₂) (ULift.up false)\n    · rintro ⟨_ | _⟩\n      any_goals exact h₁\n      any_goals exact h₂\n\n"}
