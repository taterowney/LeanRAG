{"name":"blimsup_cthickening_ae_le_of_eventually_mul_le_aux","module":"Mathlib.MeasureTheory.Covering.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù‚Åµ : PseudoMetricSpace Œ±\ninst‚úù‚Å¥ : SecondCountableTopology Œ±\ninst‚úù¬≥ : MeasurableSpace Œ±\ninst‚úù¬≤ : BorelSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.IsLocallyFiniteMeasure Œº\ninst‚úù : IsUnifLocDoublingMeasure Œº\np : Nat ‚Üí Prop\ns : Nat ‚Üí Set Œ±\nhs : ‚àÄ (i : Nat), IsClosed (s i)\nr‚ÇÅ r‚ÇÇ : Nat ‚Üí Real\nhr : Filter.Tendsto r‚ÇÅ Filter.atTop (nhdsWithin 0 (Set.Ioi 0))\nhrp : LE.le 0 r‚ÇÅ\nM : Real\nhM : LT.lt 0 M\nhM' : LT.lt M 1\nhMr : Filter.Eventually (fun i => LE.le (HMul.hMul M (r‚ÇÅ i)) (r‚ÇÇ i)) Filter.atTop\n‚ä¢ (MeasureTheory.ae Œº).EventuallyLE (Filter.blimsup (fun i => Metric.cthickening (r‚ÇÅ i) (s i)) Filter.atTop p) (Filter.blimsup (fun i => Metric.cthickening (r‚ÇÇ i) (s i)) Filter.atTop p)","decl":"/-- This is really an auxiliary result en route to `blimsup_cthickening_ae_le_of_eventually_mul_le`\n(which is itself an auxiliary result en route to `blimsup_cthickening_mul_ae_eq`).\n\nNB: The `: Set Œ±` type ascription is present because of\nhttps://github.com/leanprover-community/mathlib/issues/16932. -/\ntheorem blimsup_cthickening_ae_le_of_eventually_mul_le_aux (p : ‚Ñï ‚Üí Prop) {s : ‚Ñï ‚Üí Set Œ±}\n    (hs : ‚àÄ i, IsClosed (s i)) {r‚ÇÅ r‚ÇÇ : ‚Ñï ‚Üí ‚Ñù} (hr : Tendsto r‚ÇÅ atTop (ùìù[>] 0)) (hrp : 0 ‚â§ r‚ÇÅ)\n    {M : ‚Ñù} (hM : 0 < M) (hM' : M < 1) (hMr : ‚àÄ·∂† i in atTop, M * r‚ÇÅ i ‚â§ r‚ÇÇ i) :\n    (blimsup (fun i => cthickening (r‚ÇÅ i) (s i)) atTop p : Set Œ±) ‚â§·µê[Œº]\n      (blimsup (fun i => cthickening (r‚ÇÇ i) (s i)) atTop p : Set Œ±) := by\n  /- Sketch of proof:\n\n  Assume that `p` is identically true for simplicity. Let `Y‚ÇÅ i = cthickening (r‚ÇÅ i) (s i)`, define\n  `Y‚ÇÇ` similarly except using `r‚ÇÇ`, and let `(Z i) = ‚ãÉ_{j ‚â• i} (Y‚ÇÇ j)`. Our goal is equivalent to\n  showing that `Œº ((limsup Y‚ÇÅ) \\ (Z i)) = 0` for all `i`.\n\n  Assume for contradiction that `Œº ((limsup Y‚ÇÅ) \\ (Z i)) ‚â† 0` for some `i` and let\n  `W = (limsup Y‚ÇÅ) \\ (Z i)`. Apply Lebesgue's density theorem to obtain a point `d` in `W` of\n  density `1`. Since `d ‚àà limsup Y‚ÇÅ`, there is a subsequence of `j ‚Ü¶ Y‚ÇÅ j`, indexed by\n  `f 0 < f 1 < ...`, such that `d ‚àà Y‚ÇÅ (f j)` for all `j`. For each `j`, we may thus choose\n  `w j ‚àà s (f j)` such that `d ‚àà B j`, where `B j = closedBall (w j) (r‚ÇÅ (f j))`. Note that\n  since `d` has density one, `Œº (W ‚à© (B j)) / Œº (B j) ‚Üí 1`.\n\n  We obtain our contradiction by showing that there exists `Œ∑ < 1` such that\n  `Œº (W ‚à© (B j)) / Œº (B j) ‚â§ Œ∑` for sufficiently large `j`. In fact we claim that `Œ∑ = 1 - C‚Åª¬π`\n  is such a value where `C` is the scaling constant of `M‚Åª¬π` for the uniformly locally doubling\n  measure `Œº`.\n\n  To prove the claim, let `b j = closedBall (w j) (M * r‚ÇÅ (f j))` and for given `j` consider the\n  sets `b j` and `W ‚à© (B j)`. These are both subsets of `B j` and are disjoint for large enough `j`\n  since `M * r‚ÇÅ j ‚â§ r‚ÇÇ j` and thus `b j ‚äÜ Z i ‚äÜ W·∂ú`. We thus have:\n  `Œº (b j) + Œº (W ‚à© (B j)) ‚â§ Œº (B j)`. Combining this with `Œº (B j) ‚â§ C * Œº (b j)` we obtain\n  the required inequality. -/\n  set Y‚ÇÅ : ‚Ñï ‚Üí Set Œ± := fun i => cthickening (r‚ÇÅ i) (s i)\n  set Y‚ÇÇ : ‚Ñï ‚Üí Set Œ± := fun i => cthickening (r‚ÇÇ i) (s i)\n  let Z : ‚Ñï ‚Üí Set Œ± := fun i => ‚ãÉ (j) (_ : p j ‚àß i ‚â§ j), Y‚ÇÇ j\n  suffices ‚àÄ i, Œº (atTop.blimsup Y‚ÇÅ p \\ Z i) = 0 by\n    rwa [ae_le_set, @blimsup_eq_iInf_biSup_of_nat _ _ _ Y‚ÇÇ, iInf_eq_iInter, diff_iInter,\n      measure_iUnion_null_iff]\n  intros i\n  set W := atTop.blimsup Y‚ÇÅ p \\ Z i\n  by_contra contra\n  obtain ‚ü®d, hd, hd'‚ü© : ‚àÉ d, d ‚àà W ‚àß ‚àÄ {Œπ : Type _} {l : Filter Œπ} (w : Œπ ‚Üí Œ±) (Œ¥ : Œπ ‚Üí ‚Ñù),\n      Tendsto Œ¥ l (ùìù[>] 0) ‚Üí (‚àÄ·∂† j in l, d ‚àà closedBall (w j) (2 * Œ¥ j)) ‚Üí\n        Tendsto (fun j => Œº (W ‚à© closedBall (w j) (Œ¥ j)) / Œº (closedBall (w j) (Œ¥ j))) l (ùìù 1) :=\n    Measure.exists_mem_of_measure_ne_zero_of_ae contra\n      (IsUnifLocDoublingMeasure.ae_tendsto_measure_inter_div Œº W 2)\n  replace hd : d ‚àà blimsup Y‚ÇÅ atTop p := ((mem_diff _).mp hd).1\n  obtain ‚ü®f : ‚Ñï ‚Üí ‚Ñï, hf‚ü© := exists_forall_mem_of_hasBasis_mem_blimsup' atTop_basis hd\n  simp only [forall_and] at hf\n  obtain ‚ü®hf‚ÇÄ : ‚àÄ j, d ‚àà cthickening (r‚ÇÅ (f j)) (s (f j)), hf‚ÇÅ, hf‚ÇÇ : ‚àÄ j, j ‚â§ f j‚ü© := hf\n  have hf‚ÇÉ : Tendsto f atTop atTop :=\n    tendsto_atTop_atTop.mpr fun j => ‚ü®f j, fun i hi => (hf‚ÇÇ j).trans (hi.trans <| hf‚ÇÇ i)‚ü©\n  replace hr : Tendsto (r‚ÇÅ ‚àò f) atTop (ùìù[>] 0) := hr.comp hf‚ÇÉ\n  replace hMr : ‚àÄ·∂† j in atTop, M * r‚ÇÅ (f j) ‚â§ r‚ÇÇ (f j) := hf‚ÇÉ.eventually hMr\n  replace hf‚ÇÄ : ‚àÄ j, ‚àÉ w ‚àà s (f j), d ‚àà closedBall w (2 * r‚ÇÅ (f j)) := by\n    intro j\n    specialize hrp (f j)\n    rw [Pi.zero_apply] at hrp\n    rcases eq_or_lt_of_le hrp with (hr0 | hrp')\n    ¬∑ specialize hf‚ÇÄ j\n      rw [‚Üê hr0, cthickening_zero, (hs (f j)).closure_eq] at hf‚ÇÄ\n      exact ‚ü®d, hf‚ÇÄ, by simp [‚Üê hr0]‚ü©\n    ¬∑ simpa using mem_iUnion‚ÇÇ.mp (cthickening_subset_iUnion_closedBall_of_lt (s (f j))\n        (by positivity) (lt_two_mul_self hrp') (hf‚ÇÄ j))\n  choose w hw hw' using hf‚ÇÄ\n  let C := IsUnifLocDoublingMeasure.scalingConstantOf Œº M‚Åª¬π\n  have hC : 0 < C :=\n    lt_of_lt_of_le zero_lt_one (IsUnifLocDoublingMeasure.one_le_scalingConstantOf Œº M‚Åª¬π)\n  suffices ‚àÉ Œ∑ < (1 : ‚Ñù‚â•0),\n      ‚àÄ·∂† j in atTop, Œº (W ‚à© closedBall (w j) (r‚ÇÅ (f j))) / Œº (closedBall (w j) (r‚ÇÅ (f j))) ‚â§ Œ∑ by\n    obtain ‚ü®Œ∑, hŒ∑, hŒ∑'‚ü© := this\n    replace hŒ∑' : 1 ‚â§ Œ∑ := by\n      simpa only [ENNReal.one_le_coe_iff] using\n        le_of_tendsto (hd' w (fun j => r‚ÇÅ (f j)) hr <| Eventually.of_forall hw') hŒ∑'\n    exact (lt_self_iff_false _).mp (lt_of_lt_of_le hŒ∑ hŒ∑')\n  refine ‚ü®1 - C‚Åª¬π, tsub_lt_self zero_lt_one (inv_pos.mpr hC), ?_‚ü©\n  replace hC : C ‚â† 0 := ne_of_gt hC\n  let b : ‚Ñï ‚Üí Set Œ± := fun j => closedBall (w j) (M * r‚ÇÅ (f j))\n  let B : ‚Ñï ‚Üí Set Œ± := fun j => closedBall (w j) (r‚ÇÅ (f j))\n  have h‚ÇÅ : ‚àÄ j, b j ‚äÜ B j := fun j =>\n    closedBall_subset_closedBall (mul_le_of_le_one_left (hrp (f j)) hM'.le)\n  have h‚ÇÇ : ‚àÄ j, W ‚à© B j ‚äÜ B j := fun j => inter_subset_right\n  have h‚ÇÉ : ‚àÄ·∂† j in atTop, Disjoint (b j) (W ‚à© B j) := by\n    apply hMr.mp\n    rw [eventually_atTop]\n    refine\n      ‚ü®i, fun j hj hj' => Disjoint.inf_right (B j) <| Disjoint.inf_right' (blimsup Y‚ÇÅ atTop p) ?_‚ü©\n    change Disjoint (b j) (Z i)·∂ú\n    rw [disjoint_compl_right_iff_subset]\n    refine (closedBall_subset_cthickening (hw j) (M * r‚ÇÅ (f j))).trans\n      ((cthickening_mono hj' _).trans fun a ha => ?_)\n    simp only [Z, mem_iUnion, exists_prop]\n    exact ‚ü®f j, ‚ü®hf‚ÇÅ j, hj.le.trans (hf‚ÇÇ j)‚ü©, ha‚ü©\n  have h‚ÇÑ : ‚àÄ·∂† j in atTop, Œº (B j) ‚â§ C * Œº (b j) :=\n    (hr.eventually (IsUnifLocDoublingMeasure.eventually_measure_le_scaling_constant_mul'\n      Œº M hM)).mono fun j hj => hj (w j)\n  refine (h‚ÇÉ.and h‚ÇÑ).mono fun j hj‚ÇÄ => ?_\n  change Œº (W ‚à© B j) / Œº (B j) ‚â§ ‚Üë(1 - C‚Åª¬π)\n  rcases eq_or_ne (Œº (B j)) ‚àû with (hB | hB); ¬∑ simp [hB]\n  apply ENNReal.div_le_of_le_mul\n  rw [ENNReal.coe_sub, ENNReal.coe_one, ENNReal.sub_mul fun _ _ => hB, one_mul]\n  replace hB : ‚ÜëC‚Åª¬π * Œº (B j) ‚â† ‚àû := by\n    refine ENNReal.mul_ne_top ?_ hB\n    rwa [ENNReal.coe_inv hC, Ne, ENNReal.inv_eq_top, ENNReal.coe_eq_zero]\n  obtain ‚ü®hj‚ÇÅ : Disjoint (b j) (W ‚à© B j), hj‚ÇÇ : Œº (B j) ‚â§ C * Œº (b j)‚ü© := hj‚ÇÄ\n  replace hj‚ÇÇ : ‚ÜëC‚Åª¬π * Œº (B j) ‚â§ Œº (b j) := by\n    rw [ENNReal.coe_inv hC, ‚Üê ENNReal.div_eq_inv_mul]\n    exact ENNReal.div_le_of_le_mul' hj‚ÇÇ\n  have hj‚ÇÉ : ‚ÜëC‚Åª¬π * Œº (B j) + Œº (W ‚à© B j) ‚â§ Œº (B j) := by\n    refine le_trans (add_le_add_right hj‚ÇÇ _) ?_\n    rw [‚Üê measure_union' hj‚ÇÅ measurableSet_closedBall]\n    exact measure_mono (union_subset (h‚ÇÅ j) (h‚ÇÇ j))\n  replace hj‚ÇÉ := tsub_le_tsub_right hj‚ÇÉ (‚ÜëC‚Åª¬π * Œº (B j))\n  rwa [ENNReal.add_sub_cancel_left hB] at hj‚ÇÉ\n\n"}
{"name":"blimsup_cthickening_ae_le_of_eventually_mul_le","module":"Mathlib.MeasureTheory.Covering.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù‚Åµ : PseudoMetricSpace Œ±\ninst‚úù‚Å¥ : SecondCountableTopology Œ±\ninst‚úù¬≥ : MeasurableSpace Œ±\ninst‚úù¬≤ : BorelSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.IsLocallyFiniteMeasure Œº\ninst‚úù : IsUnifLocDoublingMeasure Œº\np : Nat ‚Üí Prop\ns : Nat ‚Üí Set Œ±\nM : Real\nhM : LT.lt 0 M\nr‚ÇÅ r‚ÇÇ : Nat ‚Üí Real\nhr : Filter.Tendsto r‚ÇÅ Filter.atTop (nhdsWithin 0 (Set.Ioi 0))\nhMr : Filter.Eventually (fun i => LE.le (HMul.hMul M (r‚ÇÅ i)) (r‚ÇÇ i)) Filter.atTop\n‚ä¢ (MeasureTheory.ae Œº).EventuallyLE (Filter.blimsup (fun i => Metric.cthickening (r‚ÇÅ i) (s i)) Filter.atTop p) (Filter.blimsup (fun i => Metric.cthickening (r‚ÇÇ i) (s i)) Filter.atTop p)","decl":"/-- This is really an auxiliary result en route to `blimsup_cthickening_mul_ae_eq`.\n\nNB: The `: Set Œ±` type ascription is present because of\nhttps://github.com/leanprover-community/mathlib/issues/16932. -/\ntheorem blimsup_cthickening_ae_le_of_eventually_mul_le (p : ‚Ñï ‚Üí Prop) {s : ‚Ñï ‚Üí Set Œ±} {M : ‚Ñù}\n    (hM : 0 < M) {r‚ÇÅ r‚ÇÇ : ‚Ñï ‚Üí ‚Ñù} (hr : Tendsto r‚ÇÅ atTop (ùìù[>] 0))\n    (hMr : ‚àÄ·∂† i in atTop, M * r‚ÇÅ i ‚â§ r‚ÇÇ i) :\n    (blimsup (fun i => cthickening (r‚ÇÅ i) (s i)) atTop p : Set Œ±) ‚â§·µê[Œº]\n      (blimsup (fun i => cthickening (r‚ÇÇ i) (s i)) atTop p : Set Œ±) := by\n  let R‚ÇÅ i := max 0 (r‚ÇÅ i)\n  let R‚ÇÇ i := max 0 (r‚ÇÇ i)\n  have hRp : 0 ‚â§ R‚ÇÅ := fun i => le_max_left 0 (r‚ÇÅ i)\n  replace hMr : ‚àÄ·∂† i in atTop, M * R‚ÇÅ i ‚â§ R‚ÇÇ i := by\n    refine hMr.mono fun i hi ‚Ü¶ ?_\n    rw [mul_max_of_nonneg _ _ hM.le, mul_zero]\n    exact max_le_max (le_refl 0) hi\n  simp_rw [‚Üê cthickening_max_zero (r‚ÇÅ _), ‚Üê cthickening_max_zero (r‚ÇÇ _)]\n  rcases le_or_lt 1 M with hM' | hM'\n  ¬∑ apply HasSubset.Subset.eventuallyLE\n    change _ ‚â§ _\n    refine mono_blimsup' (hMr.mono fun i hi _ => cthickening_mono ?_ (s i))\n    exact (le_mul_of_one_le_left (hRp i) hM').trans hi\n  ¬∑ simp only [‚Üê @cthickening_closure _ _ _ (s _)]\n    have hs : ‚àÄ i, IsClosed (closure (s i)) := fun i => isClosed_closure\n    exact blimsup_cthickening_ae_le_of_eventually_mul_le_aux Œº p hs\n      (tendsto_nhds_max_right hr) hRp hM hM' hMr\n\n"}
{"name":"blimsup_cthickening_mul_ae_eq","module":"Mathlib.MeasureTheory.Covering.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù‚Åµ : PseudoMetricSpace Œ±\ninst‚úù‚Å¥ : SecondCountableTopology Œ±\ninst‚úù¬≥ : MeasurableSpace Œ±\ninst‚úù¬≤ : BorelSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.IsLocallyFiniteMeasure Œº\ninst‚úù : IsUnifLocDoublingMeasure Œº\np : Nat ‚Üí Prop\ns : Nat ‚Üí Set Œ±\nM : Real\nhM : LT.lt 0 M\nr : Nat ‚Üí Real\nhr : Filter.Tendsto r Filter.atTop (nhds 0)\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (Filter.blimsup (fun i => Metric.cthickening (HMul.hMul M (r i)) (s i)) Filter.atTop p) (Filter.blimsup (fun i => Metric.cthickening (r i) (s i)) Filter.atTop p)","decl":"/-- Given a sequence of subsets `s·µ¢` of a metric space, together with a sequence of radii `r·µ¢`\nsuch that `r·µ¢ ‚Üí 0`, the set of points which belong to infinitely many of the closed\n`r·µ¢`-thickenings of `s·µ¢` is unchanged almost everywhere for a uniformly locally doubling measure if\nthe `r·µ¢` are all scaled by a positive constant.\n\nThis lemma is a generalisation of Lemma 9 appearing on page 217 of\n[J.W.S. Cassels, *Some metrical theorems in Diophantine approximation. I*](cassels1950).\n\nSee also `blimsup_thickening_mul_ae_eq`.\n\nNB: The `: Set Œ±` type ascription is present because of\nhttps://github.com/leanprover-community/mathlib/issues/16932. -/\ntheorem blimsup_cthickening_mul_ae_eq (p : ‚Ñï ‚Üí Prop) (s : ‚Ñï ‚Üí Set Œ±) {M : ‚Ñù} (hM : 0 < M)\n    (r : ‚Ñï ‚Üí ‚Ñù) (hr : Tendsto r atTop (ùìù 0)) :\n    (blimsup (fun i => cthickening (M * r i) (s i)) atTop p : Set Œ±) =·µê[Œº]\n      (blimsup (fun i => cthickening (r i) (s i)) atTop p : Set Œ±) := by\n  have : ‚àÄ (p : ‚Ñï ‚Üí Prop) {r : ‚Ñï ‚Üí ‚Ñù} (_ : Tendsto r atTop (ùìù[>] 0)),\n      (blimsup (fun i => cthickening (M * r i) (s i)) atTop p : Set Œ±) =·µê[Œº]\n        (blimsup (fun i => cthickening (r i) (s i)) atTop p : Set Œ±) := by\n    clear p hr r; intro p r hr\n    have hr' : Tendsto (fun i => M * r i) atTop (ùìù[>] 0) := by\n      convert TendstoNhdsWithinIoi.const_mul hM hr <;> simp only [mul_zero]\n    refine eventuallyLE_antisymm_iff.mpr ‚ü®?_, ?_‚ü©\n    ¬∑ exact blimsup_cthickening_ae_le_of_eventually_mul_le Œº p (inv_pos.mpr hM) hr'\n        (Eventually.of_forall fun i => by rw [inv_mul_cancel_left‚ÇÄ hM.ne' (r i)])\n    ¬∑ exact blimsup_cthickening_ae_le_of_eventually_mul_le Œº p hM hr\n        (Eventually.of_forall fun i => le_refl _)\n  let r' : ‚Ñï ‚Üí ‚Ñù := fun i => if 0 < r i then r i else 1 / ((i : ‚Ñù) + 1)\n  have hr' : Tendsto r' atTop (ùìù[>] 0) := by\n    refine tendsto_nhdsWithin_iff.mpr\n      ‚ü®Tendsto.if' hr tendsto_one_div_add_atTop_nhds_zero_nat, Eventually.of_forall fun i => ?_‚ü©\n    by_cases hi : 0 < r i\n    ¬∑ simp [r', hi]\n    ¬∑ simp only [r', hi, one_div, mem_Ioi, if_false, inv_pos]; positivity\n  have h‚ÇÄ : ‚àÄ i, p i ‚àß 0 < r i ‚Üí cthickening (r i) (s i) = cthickening (r' i) (s i) := by\n    rintro i ‚ü®-, hi‚ü©; congr! 1; change r i = ite (0 < r i) (r i) _; simp [hi]\n  have h‚ÇÅ : ‚àÄ i, p i ‚àß 0 < r i ‚Üí cthickening (M * r i) (s i) = cthickening (M * r' i) (s i) := by\n    rintro i ‚ü®-, hi‚ü©; simp only [r', hi, mul_ite, if_true]\n  have h‚ÇÇ : ‚àÄ i, p i ‚àß r i ‚â§ 0 ‚Üí cthickening (M * r i) (s i) = cthickening (r i) (s i) := by\n    rintro i ‚ü®-, hi‚ü©\n    have hi' : M * r i ‚â§ 0 := mul_nonpos_of_nonneg_of_nonpos hM.le hi\n    rw [cthickening_of_nonpos hi, cthickening_of_nonpos hi']\n  have hp : p = fun i => p i ‚àß 0 < r i ‚à® p i ‚àß r i ‚â§ 0 := by\n    ext i; simp [‚Üê and_or_left, lt_or_le 0 (r i)]\n  rw [hp, blimsup_or_eq_sup, blimsup_or_eq_sup]\n  simp only [sup_eq_union]\n  rw [blimsup_congr (Eventually.of_forall h‚ÇÄ), blimsup_congr (Eventually.of_forall h‚ÇÅ),\n    blimsup_congr (Eventually.of_forall h‚ÇÇ)]\n  exact ae_eq_set_union (this (fun i => p i ‚àß 0 < r i) hr') (ae_eq_refl _)\n\n"}
{"name":"blimsup_cthickening_ae_eq_blimsup_thickening","module":"Mathlib.MeasureTheory.Covering.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù‚Åµ : PseudoMetricSpace Œ±\ninst‚úù‚Å¥ : SecondCountableTopology Œ±\ninst‚úù¬≥ : MeasurableSpace Œ±\ninst‚úù¬≤ : BorelSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.IsLocallyFiniteMeasure Œº\ninst‚úù : IsUnifLocDoublingMeasure Œº\np : Nat ‚Üí Prop\ns : Nat ‚Üí Set Œ±\nr : Nat ‚Üí Real\nhr : Filter.Tendsto r Filter.atTop (nhds 0)\nhr' : Filter.Eventually (fun i => p i ‚Üí LT.lt 0 (r i)) Filter.atTop\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (Filter.blimsup (fun i => Metric.cthickening (r i) (s i)) Filter.atTop p) (Filter.blimsup (fun i => Metric.thickening (r i) (s i)) Filter.atTop p)","decl":"theorem blimsup_cthickening_ae_eq_blimsup_thickening {p : ‚Ñï ‚Üí Prop} {s : ‚Ñï ‚Üí Set Œ±} {r : ‚Ñï ‚Üí ‚Ñù}\n    (hr : Tendsto r atTop (ùìù 0)) (hr' : ‚àÄ·∂† i in atTop, p i ‚Üí 0 < r i) :\n    (blimsup (fun i => cthickening (r i) (s i)) atTop p : Set Œ±) =·µê[Œº]\n      (blimsup (fun i => thickening (r i) (s i)) atTop p : Set Œ±) := by\n  refine eventuallyLE_antisymm_iff.mpr ‚ü®?_, HasSubset.Subset.eventuallyLE (?_ : _ ‚â§ _)‚ü©\n  ¬∑ rw [eventuallyLE_congr (blimsup_cthickening_mul_ae_eq Œº p s (@one_half_pos ‚Ñù _) r hr).symm\n      EventuallyEq.rfl]\n    apply HasSubset.Subset.eventuallyLE\n    change _ ‚â§ _\n    refine mono_blimsup' (hr'.mono fun i hi pi => cthickening_subset_thickening' (hi pi) ?_ (s i))\n    nlinarith [hi pi]\n  ¬∑ exact mono_blimsup fun i _ => thickening_subset_cthickening _ _\n\n"}
{"name":"blimsup_thickening_mul_ae_eq_aux","module":"Mathlib.MeasureTheory.Covering.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù‚Åµ : PseudoMetricSpace Œ±\ninst‚úù‚Å¥ : SecondCountableTopology Œ±\ninst‚úù¬≥ : MeasurableSpace Œ±\ninst‚úù¬≤ : BorelSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.IsLocallyFiniteMeasure Œº\ninst‚úù : IsUnifLocDoublingMeasure Œº\np : Nat ‚Üí Prop\ns : Nat ‚Üí Set Œ±\nM : Real\nhM : LT.lt 0 M\nr : Nat ‚Üí Real\nhr : Filter.Tendsto r Filter.atTop (nhds 0)\nhr' : Filter.Eventually (fun i => p i ‚Üí LT.lt 0 (r i)) Filter.atTop\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (Filter.blimsup (fun i => Metric.thickening (HMul.hMul M (r i)) (s i)) Filter.atTop p) (Filter.blimsup (fun i => Metric.thickening (r i) (s i)) Filter.atTop p)","decl":"/-- An auxiliary result en route to `blimsup_thickening_mul_ae_eq`. -/\ntheorem blimsup_thickening_mul_ae_eq_aux (p : ‚Ñï ‚Üí Prop) (s : ‚Ñï ‚Üí Set Œ±) {M : ‚Ñù} (hM : 0 < M)\n    (r : ‚Ñï ‚Üí ‚Ñù) (hr : Tendsto r atTop (ùìù 0)) (hr' : ‚àÄ·∂† i in atTop, p i ‚Üí 0 < r i) :\n    (blimsup (fun i => thickening (M * r i) (s i)) atTop p : Set Œ±) =·µê[Œº]\n      (blimsup (fun i => thickening (r i) (s i)) atTop p : Set Œ±) := by\n  have h‚ÇÅ := blimsup_cthickening_ae_eq_blimsup_thickening (s := s) Œº hr hr'\n  have h‚ÇÇ := blimsup_cthickening_mul_ae_eq Œº p s hM r hr\n  replace hr : Tendsto (fun i => M * r i) atTop (ùìù 0) := by convert hr.const_mul M; simp\n  replace hr' : ‚àÄ·∂† i in atTop, p i ‚Üí 0 < M * r i := hr'.mono fun i hi hip ‚Ü¶ mul_pos hM (hi hip)\n  have h‚ÇÉ := blimsup_cthickening_ae_eq_blimsup_thickening (s := s) Œº hr hr'\n  exact h‚ÇÉ.symm.trans (h‚ÇÇ.trans h‚ÇÅ)\n\n"}
{"name":"blimsup_thickening_mul_ae_eq","module":"Mathlib.MeasureTheory.Covering.LiminfLimsup","initialProofState":"Œ± : Type u_1\ninst‚úù‚Åµ : PseudoMetricSpace Œ±\ninst‚úù‚Å¥ : SecondCountableTopology Œ±\ninst‚úù¬≥ : MeasurableSpace Œ±\ninst‚úù¬≤ : BorelSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasureTheory.IsLocallyFiniteMeasure Œº\ninst‚úù : IsUnifLocDoublingMeasure Œº\np : Nat ‚Üí Prop\ns : Nat ‚Üí Set Œ±\nM : Real\nhM : LT.lt 0 M\nr : Nat ‚Üí Real\nhr : Filter.Tendsto r Filter.atTop (nhds 0)\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq (Filter.blimsup (fun i => Metric.thickening (HMul.hMul M (r i)) (s i)) Filter.atTop p) (Filter.blimsup (fun i => Metric.thickening (r i) (s i)) Filter.atTop p)","decl":"/-- Given a sequence of subsets `s·µ¢` of a metric space, together with a sequence of radii `r·µ¢`\nsuch that `r·µ¢ ‚Üí 0`, the set of points which belong to infinitely many of the\n`r·µ¢`-thickenings of `s·µ¢` is unchanged almost everywhere for a uniformly locally doubling measure if\nthe `r·µ¢` are all scaled by a positive constant.\n\nThis lemma is a generalisation of Lemma 9 appearing on page 217 of\n[J.W.S. Cassels, *Some metrical theorems in Diophantine approximation. I*](cassels1950).\n\nSee also `blimsup_cthickening_mul_ae_eq`.\n\nNB: The `: Set Œ±` type ascription is present because of\nhttps://github.com/leanprover-community/mathlib/issues/16932. -/\ntheorem blimsup_thickening_mul_ae_eq (p : ‚Ñï ‚Üí Prop) (s : ‚Ñï ‚Üí Set Œ±) {M : ‚Ñù} (hM : 0 < M) (r : ‚Ñï ‚Üí ‚Ñù)\n    (hr : Tendsto r atTop (ùìù 0)) :\n    (blimsup (fun i => thickening (M * r i) (s i)) atTop p : Set Œ±) =·µê[Œº]\n      (blimsup (fun i => thickening (r i) (s i)) atTop p : Set Œ±) := by\n  let q : ‚Ñï ‚Üí Prop := fun i => p i ‚àß 0 < r i\n  have h‚ÇÅ : blimsup (fun i => thickening (r i) (s i)) atTop p =\n      blimsup (fun i => thickening (r i) (s i)) atTop q := by\n    refine blimsup_congr' (Eventually.of_forall fun i h => ?_)\n    replace hi : 0 < r i := by contrapose! h; apply thickening_of_nonpos h\n    simp only [q, hi, iff_self_and, imp_true_iff]\n  have h‚ÇÇ : blimsup (fun i => thickening (M * r i) (s i)) atTop p =\n      blimsup (fun i => thickening (M * r i) (s i)) atTop q := by\n    refine blimsup_congr' (Eventually.of_forall fun i h ‚Ü¶ ?_)\n    replace h : 0 < r i := by\n      rw [‚Üê mul_pos_iff_of_pos_left hM]; contrapose! h; apply thickening_of_nonpos h\n    simp only [q, h, iff_self_and, imp_true_iff]\n  rw [h‚ÇÅ, h‚ÇÇ]\n  exact blimsup_thickening_mul_ae_eq_aux Œº q s hM r hr (Eventually.of_forall fun i hi => hi.2)\n"}
