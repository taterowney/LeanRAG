{"name":"CategoryTheory.GrothendieckTopology.HasSheafCompose.isSheaf","module":"Mathlib.CategoryTheory.Sites.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nB : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} B\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor A B\nself : J.HasSheafCompose F\nP : CategoryTheory.Functor (Opposite C) A\nhP : CategoryTheory.Presheaf.IsSheaf J P\n‚ä¢ CategoryTheory.Presheaf.IsSheaf J (P.comp F)","decl":"/-- Describes the property of a functor to \"preserve sheaves\". -/\nclass GrothendieckTopology.HasSheafCompose : Prop where\n  /-- For every sheaf `P`, `P ‚ãô F` is a sheaf. -/\n  isSheaf (P : C·µí·µñ ‚•§ A) (hP : Presheaf.IsSheaf J P) : Presheaf.IsSheaf J (P ‚ãô F)\n\n"}
{"name":"CategoryTheory.sheafCompose_map_val","module":"Mathlib.CategoryTheory.Sites.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nB : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} B\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor A B\ninst‚úù : J.HasSheafCompose F\nX‚úù Y‚úù : CategoryTheory.Sheaf J A\nŒ∑ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.sheafCompose J F).map Œ∑).val (CategoryTheory.whiskerRight Œ∑.val F)","decl":"/-- Composing a functor which `HasSheafCompose`, yields a functor between sheaf categories. -/\n@[simps]\ndef sheafCompose : Sheaf J A ‚•§ Sheaf J B where\n  obj G := ‚ü®G.val ‚ãô F, GrothendieckTopology.HasSheafCompose.isSheaf G.val G.2‚ü©\n  map Œ∑ := ‚ü®whiskerRight Œ∑.val _‚ü©\n  map_id _ := Sheaf.Hom.ext <| whiskerRight_id _\n  map_comp _ _ := Sheaf.Hom.ext <| whiskerRight_comp _ _ _\n\n"}
{"name":"CategoryTheory.sheafCompose_obj_val","module":"Mathlib.CategoryTheory.Sites.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nB : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} B\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor A B\ninst‚úù : J.HasSheafCompose F\nG : CategoryTheory.Sheaf J A\n‚ä¢ Eq ((CategoryTheory.sheafCompose J F).obj G).val (G.val.comp F)","decl":"/-- Composing a functor which `HasSheafCompose`, yields a functor between sheaf categories. -/\n@[simps]\ndef sheafCompose : Sheaf J A ‚•§ Sheaf J B where\n  obj G := ‚ü®G.val ‚ãô F, GrothendieckTopology.HasSheafCompose.isSheaf G.val G.2‚ü©\n  map Œ∑ := ‚ü®whiskerRight Œ∑.val _‚ü©\n  map_id _ := Sheaf.Hom.ext <| whiskerRight_id _\n  map_comp _ _ := Sheaf.Hom.ext <| whiskerRight_comp _ _ _\n\n"}
{"name":"CategoryTheory.instFaithfulSheafFunctorOppositeCompSheafComposeSheafToPresheaf","module":"Mathlib.CategoryTheory.Sites.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nB : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} B\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor A B\ninst‚úù¬π : J.HasSheafCompose F\ninst‚úù : F.Faithful\n‚ä¢ ((CategoryTheory.sheafCompose J F).comp (CategoryTheory.sheafToPresheaf J B)).Faithful","decl":"instance [F.Faithful] : (sheafCompose J F ‚ãô sheafToPresheaf _ _).Faithful :=\n  show (sheafToPresheaf _ _ ‚ãô (whiskeringRight C·µí·µñ A B).obj F).Faithful from inferInstance\n\n"}
{"name":"CategoryTheory.instFullSheafFunctorOppositeCompSheafComposeSheafToPresheafOfFaithful","module":"Mathlib.CategoryTheory.Sites.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nB : Type u‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} B\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor A B\ninst‚úù¬≤ : J.HasSheafCompose F\ninst‚úù¬π : F.Faithful\ninst‚úù : F.Full\n‚ä¢ ((CategoryTheory.sheafCompose J F).comp (CategoryTheory.sheafToPresheaf J B)).Full","decl":"instance [F.Faithful] [F.Full] : (sheafCompose J F ‚ãô sheafToPresheaf _ _).Full :=\n  show (sheafToPresheaf _ _ ‚ãô (whiskeringRight C·µí·µñ A B).obj F).Full from inferInstance\n\n"}
{"name":"CategoryTheory.instFaithfulSheafSheafCompose","module":"Mathlib.CategoryTheory.Sites.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nB : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} B\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor A B\ninst‚úù¬π : J.HasSheafCompose F\ninst‚úù : F.Faithful\n‚ä¢ (CategoryTheory.sheafCompose J F).Faithful","decl":"instance [F.Faithful] : (sheafCompose J F).Faithful :=\n  Functor.Faithful.of_comp (sheafCompose J F) (sheafToPresheaf _ _)\n\n"}
{"name":"CategoryTheory.instFullSheafSheafComposeOfFaithful","module":"Mathlib.CategoryTheory.Sites.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nB : Type u‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} B\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor A B\ninst‚úù¬≤ : J.HasSheafCompose F\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\n‚ä¢ (CategoryTheory.sheafCompose J F).Full","decl":"instance [F.Full] [F.Faithful] : (sheafCompose J F).Full :=\n  Functor.Full.of_comp_faithful (sheafCompose J F) (sheafToPresheaf _ _)\n\n"}
{"name":"CategoryTheory.instReflectsIsomorphismsSheafSheafCompose","module":"Mathlib.CategoryTheory.Sites.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nB : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} B\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor A B\ninst‚úù¬π : J.HasSheafCompose F\ninst‚úù : F.ReflectsIsomorphisms\n‚ä¢ (CategoryTheory.sheafCompose J F).ReflectsIsomorphisms","decl":"instance [F.ReflectsIsomorphisms] : (sheafCompose J F).ReflectsIsomorphisms where\n  reflects {G‚ÇÅ G‚ÇÇ} f _ := by\n    rw [‚Üê isIso_iff_of_reflects_iso _ (sheafToPresheaf _ _),\n      ‚Üê isIso_iff_of_reflects_iso _ ((whiskeringRight C·µí·µñ A B).obj F)]\n    change IsIso ((sheafToPresheaf _ _).map ((sheafCompose J F).map f))\n    infer_instance\n\n"}
{"name":"CategoryTheory.sheafCompose_id","module":"Mathlib.CategoryTheory.Sites.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nB : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} B\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor A B\ninst‚úù : J.HasSheafCompose F\n‚ä¢ Eq (CategoryTheory.sheafCompose_map J (CategoryTheory.CategoryStruct.id F)) (CategoryTheory.CategoryStruct.id (CategoryTheory.sheafCompose J F))","decl":"@[simp]\nlemma sheafCompose_id : sheafCompose_map (F := F) J (ùüô _) = ùüô _ := rfl\n\n"}
{"name":"CategoryTheory.sheafCompose_comp","module":"Mathlib.CategoryTheory.Sites.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nB : Type u‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} B\nJ : CategoryTheory.GrothendieckTopology C\nF G H : CategoryTheory.Functor A B\nŒ∑ : Quiver.Hom F G\nŒ≥ : Quiver.Hom G H\ninst‚úù¬≤ : J.HasSheafCompose F\ninst‚úù¬π : J.HasSheafCompose G\ninst‚úù : J.HasSheafCompose H\n‚ä¢ Eq (CategoryTheory.sheafCompose_map J (CategoryTheory.CategoryStruct.comp Œ∑ Œ≥)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.sheafCompose_map J Œ∑) (CategoryTheory.sheafCompose_map J Œ≥))","decl":"@[simp]\nlemma sheafCompose_comp :\n    sheafCompose_map J (Œ∑ ‚â´ Œ≥) = sheafCompose_map J Œ∑ ‚â´ sheafCompose_map J Œ≥ := rfl\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.multicospanComp_hom_app","module":"Mathlib.CategoryTheory.Sites.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nB : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} B\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor A B\nP : CategoryTheory.Functor (Opposite C) A\nX‚úù : C\nS : J.Cover X‚úù\nX : CategoryTheory.Limits.WalkingMulticospan (S.index (P.comp F)).fstTo (S.index (P.comp F)).sndTo\n‚ä¢ Eq ((CategoryTheory.GrothendieckTopology.Cover.multicospanComp F P S).hom.app X) (CategoryTheory.GrothendieckTopology.Cover.multicospanComp.match_1 F P S (fun t => CategoryTheory.Iso (CategoryTheory.Limits.MulticospanIndex.multicospan.match_1 (S.index (P.comp F)) (fun x => B) t (fun a => F.obj (P.obj { unop := a.Y })) fun b => F.obj (P.obj { unop := b.r.Z })) (F.obj (CategoryTheory.Limits.MulticospanIndex.multicospan.match_1 (S.index P) (fun x => A) t (fun a => P.obj { unop := a.Y }) fun b => P.obj { unop := b.r.Z }))) X (fun a => CategoryTheory.Iso.refl (F.obj (P.obj { unop := a.Y }))) fun a => CategoryTheory.Iso.refl (F.obj (P.obj { unop := a.r.Z }))).hom","decl":"/-- The multicospan associated to a cover `S : J.Cover X` and a presheaf of the form `P ‚ãô F`\nis isomorphic to the composition of the multicospan associated to `S` and `P`,\ncomposed with `F`. -/\n@[simps!]\ndef multicospanComp : (S.index (P ‚ãô F)).multicospan ‚âÖ (S.index P).multicospan ‚ãô F :=\n  NatIso.ofComponents\n    (fun t =>\n      match t with\n      | WalkingMulticospan.left _ => Iso.refl _\n      | WalkingMulticospan.right _ => Iso.refl _)\n    (by\n      rintro (a | b) (a | b) (f | f | f)\n      all_goals aesop_cat)\n\n"}
{"name":"CategoryTheory.GrothendieckTopology.Cover.multicospanComp_inv_app","module":"Mathlib.CategoryTheory.Sites.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nB : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} B\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor A B\nP : CategoryTheory.Functor (Opposite C) A\nX‚úù : C\nS : J.Cover X‚úù\nX : CategoryTheory.Limits.WalkingMulticospan (S.index (P.comp F)).fstTo (S.index (P.comp F)).sndTo\n‚ä¢ Eq ((CategoryTheory.GrothendieckTopology.Cover.multicospanComp F P S).inv.app X) (CategoryTheory.GrothendieckTopology.Cover.multicospanComp.match_1 F P S (fun t => CategoryTheory.Iso (CategoryTheory.Limits.MulticospanIndex.multicospan.match_1 (S.index (P.comp F)) (fun x => B) t (fun a => F.obj (P.obj { unop := a.Y })) fun b => F.obj (P.obj { unop := b.r.Z })) (F.obj (CategoryTheory.Limits.MulticospanIndex.multicospan.match_1 (S.index P) (fun x => A) t (fun a => P.obj { unop := a.Y }) fun b => P.obj { unop := b.r.Z }))) X (fun a => CategoryTheory.Iso.refl (F.obj (P.obj { unop := a.Y }))) fun a => CategoryTheory.Iso.refl (F.obj (P.obj { unop := a.r.Z }))).inv","decl":"/-- The multicospan associated to a cover `S : J.Cover X` and a presheaf of the form `P ‚ãô F`\nis isomorphic to the composition of the multicospan associated to `S` and `P`,\ncomposed with `F`. -/\n@[simps!]\ndef multicospanComp : (S.index (P ‚ãô F)).multicospan ‚âÖ (S.index P).multicospan ‚ãô F :=\n  NatIso.ofComponents\n    (fun t =>\n      match t with\n      | WalkingMulticospan.left _ => Iso.refl _\n      | WalkingMulticospan.right _ => Iso.refl _)\n    (by\n      rintro (a | b) (a | b) (f | f | f)\n      all_goals aesop_cat)\n\n"}
{"name":"CategoryTheory.hasSheafCompose_of_preservesMulticospan","module":"Mathlib.CategoryTheory.Sites.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nB : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} B\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor A B\ninst‚úù : ‚àÄ (X : C) (S : J.Cover X) (P : CategoryTheory.Functor (Opposite C) A), CategoryTheory.Limits.PreservesLimit (S.index P).multicospan F\n‚ä¢ J.HasSheafCompose F","decl":"/--\nComposing a sheaf with a functor preserving the limit of `(S.index P).multicospan` yields a functor\nbetween sheaf categories.\n-/\ninstance hasSheafCompose_of_preservesMulticospan (F : A ‚•§ B)\n    [‚àÄ (X : C) (S : J.Cover X) (P : C·µí·µñ ‚•§ A), PreservesLimit (S.index P).multicospan F] :\n    J.HasSheafCompose F where\n  isSheaf P hP := by\n    rw [Presheaf.isSheaf_iff_multifork] at hP ‚ä¢\n    intro X S\n    obtain ‚ü®h‚ü© := hP X S\n    replace h := isLimitOfPreserves F h\n    replace h := Limits.IsLimit.ofIsoLimit h (S.mapMultifork F P)\n    exact ‚ü®Limits.IsLimit.postcomposeHomEquiv (S.multicospanComp F P) _ h‚ü©\n\n"}
{"name":"CategoryTheory.hasSheafCompose_of_preservesLimitsOfSize","module":"Mathlib.CategoryTheory.Sites.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nB : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} B\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor A B\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfSize.{v‚ÇÅ, max u‚ÇÅ v‚ÇÅ, v‚ÇÇ, v‚ÇÉ, u‚ÇÇ, u‚ÇÉ} F\n‚ä¢ J.HasSheafCompose F","decl":"/--\nComposing a sheaf with a functor preserving limits of the same size as the hom sets in `C` yields a\nfunctor between sheaf categories.\n\nNote: the size of the limit that `F` is required to preserve in\n`hasSheafCompose_of_preservesMulticospan` is in general larger than this.\n-/\ninstance hasSheafCompose_of_preservesLimitsOfSize [PreservesLimitsOfSize.{v‚ÇÅ, max u‚ÇÅ v‚ÇÅ} F] :\n    J.HasSheafCompose F where\n  isSheaf _ hP := Presheaf.isSheaf_comp_of_isSheaf J _ F hP\n\n"}
{"name":"CategoryTheory.Sheaf.isSeparated","module":"Mathlib.CategoryTheory.Sites.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\ninst‚úù¬π : CategoryTheory.HasForget A\ninst‚úù : J.HasSheafCompose (CategoryTheory.forget A)\nF : CategoryTheory.Sheaf J A\n‚ä¢ CategoryTheory.Presheaf.IsSeparated J F.val","decl":"lemma Sheaf.isSeparated [HasForget A] [J.HasSheafCompose (forget A)]\n    (F : Sheaf J A) : Presheaf.IsSeparated J F.val := by\n  rintro X S hS x y h\n  exact (Presieve.isSeparated_of_isSheaf _ _ ((isSheaf_iff_isSheaf_of_type _ _).1\n    ((sheafCompose J (forget A)).obj F).2) S hS).ext (fun _ _ hf => h _ _ hf)\n\n"}
{"name":"CategoryTheory.Presheaf.IsSheaf.isSeparated","module":"Mathlib.CategoryTheory.Sites.Whiskering","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nA : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} A\nJ : CategoryTheory.GrothendieckTopology C\nF : CategoryTheory.Functor (Opposite C) A\ninst‚úù¬π : CategoryTheory.HasForget A\ninst‚úù : J.HasSheafCompose (CategoryTheory.forget A)\nhF : CategoryTheory.Presheaf.IsSheaf J F\n‚ä¢ CategoryTheory.Presheaf.IsSeparated J F","decl":"lemma Presheaf.IsSheaf.isSeparated {F : C·µí·µñ ‚•§ A} [HasForget A]\n    [J.HasSheafCompose (forget A)] (hF : Presheaf.IsSheaf J F) :\n    Presheaf.IsSeparated J F :=\n  Sheaf.isSeparated ‚ü®F, hF‚ü©\n\n"}
