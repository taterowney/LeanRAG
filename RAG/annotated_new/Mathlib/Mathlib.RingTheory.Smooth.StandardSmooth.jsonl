{"name":"Algebra.PreSubmersivePresentation.relations_finite","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nself : Algebra.PreSubmersivePresentation R S\n⊢ Finite self.rels","decl":"/--\nA `PreSubmersivePresentation` of an `R`-algebra `S` is a `Presentation`\nwith finitely-many relations equipped with an injective `map : relations → vars`.\n\nThis map determines how the differential of `P` is constructed. See\n`PreSubmersivePresentation.differential` for details.\n-/\n@[nolint checkUnivs]\nstructure PreSubmersivePresentation extends Algebra.Presentation.{t, w} R S where\n  /-- A map from the relations type to the variables type. Used to compute the differential. -/\n  map : rels → vars\n  map_inj : Function.Injective map\n  relations_finite : Finite rels\n\n"}
{"name":"Algebra.PreSubmersivePresentation.mk.inj","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\ntoPresentation✝ : Algebra.Presentation R S\nmap✝ : toPresentation✝.rels → toPresentation✝.vars\nmap_inj✝ : Function.Injective map✝\nrelations_finite✝ : Finite toPresentation✝.rels\ntoPresentation : Algebra.Presentation R S\nmap : toPresentation.rels → toPresentation.vars\nmap_inj : Function.Injective map\nrelations_finite : Finite toPresentation.rels\nx✝ : Eq { toPresentation := toPresentation✝, map := map✝, map_inj := map_inj✝, relations_finite := relations_finite✝ } { toPresentation := toPresentation, map := map, map_inj := map_inj, relations_finite := relations_finite }\n⊢ And (Eq toPresentation✝ toPresentation) (HEq map✝ map)","decl":"/--\nA `PreSubmersivePresentation` of an `R`-algebra `S` is a `Presentation`\nwith finitely-many relations equipped with an injective `map : relations → vars`.\n\nThis map determines how the differential of `P` is constructed. See\n`PreSubmersivePresentation.differential` for details.\n-/\n@[nolint checkUnivs]\nstructure PreSubmersivePresentation extends Algebra.Presentation.{t, w} R S where\n  /-- A map from the relations type to the variables type. Used to compute the differential. -/\n  map : rels → vars\n  map_inj : Function.Injective map\n  relations_finite : Finite rels\n\n"}
{"name":"Algebra.PreSubmersivePresentation.map_inj","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nself : Algebra.PreSubmersivePresentation R S\n⊢ Function.Injective self.map","decl":"/--\nA `PreSubmersivePresentation` of an `R`-algebra `S` is a `Presentation`\nwith finitely-many relations equipped with an injective `map : relations → vars`.\n\nThis map determines how the differential of `P` is constructed. See\n`PreSubmersivePresentation.differential` for details.\n-/\n@[nolint checkUnivs]\nstructure PreSubmersivePresentation extends Algebra.Presentation.{t, w} R S where\n  /-- A map from the relations type to the variables type. Used to compute the differential. -/\n  map : rels → vars\n  map_inj : Function.Injective map\n  relations_finite : Finite rels\n\n"}
{"name":"Algebra.PreSubmersivePresentation.mk.injEq","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\ntoPresentation✝ : Algebra.Presentation R S\nmap✝ : toPresentation✝.rels → toPresentation✝.vars\nmap_inj✝ : Function.Injective map✝\nrelations_finite✝ : Finite toPresentation✝.rels\ntoPresentation : Algebra.Presentation R S\nmap : toPresentation.rels → toPresentation.vars\nmap_inj : Function.Injective map\nrelations_finite : Finite toPresentation.rels\n⊢ Eq (Eq { toPresentation := toPresentation✝, map := map✝, map_inj := map_inj✝, relations_finite := relations_finite✝ } { toPresentation := toPresentation, map := map, map_inj := map_inj, relations_finite := relations_finite }) (And (Eq toPresentation✝ toPresentation) (HEq map✝ map))","decl":"/--\nA `PreSubmersivePresentation` of an `R`-algebra `S` is a `Presentation`\nwith finitely-many relations equipped with an injective `map : relations → vars`.\n\nThis map determines how the differential of `P` is constructed. See\n`PreSubmersivePresentation.differential` for details.\n-/\n@[nolint checkUnivs]\nstructure PreSubmersivePresentation extends Algebra.Presentation.{t, w} R S where\n  /-- A map from the relations type to the variables type. Used to compute the differential. -/\n  map : rels → vars\n  map_inj : Function.Injective map\n  relations_finite : Finite rels\n\n"}
{"name":"Algebra.PreSubmersivePresentation.mk.sizeOf_spec","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : SizeOf R\ninst✝ : SizeOf S\ntoPresentation : Algebra.Presentation R S\nmap : toPresentation.rels → toPresentation.vars\nmap_inj : Function.Injective map\nrelations_finite : Finite toPresentation.rels\n⊢ Eq (SizeOf.sizeOf { toPresentation := toPresentation, map := map, map_inj := map_inj, relations_finite := relations_finite }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toPresentation)) (SizeOf.sizeOf relations_finite))","decl":"/--\nA `PreSubmersivePresentation` of an `R`-algebra `S` is a `Presentation`\nwith finitely-many relations equipped with an injective `map : relations → vars`.\n\nThis map determines how the differential of `P` is constructed. See\n`PreSubmersivePresentation.differential` for details.\n-/\n@[nolint checkUnivs]\nstructure PreSubmersivePresentation extends Algebra.Presentation.{t, w} R S where\n  /-- A map from the relations type to the variables type. Used to compute the differential. -/\n  map : rels → vars\n  map_inj : Function.Injective map\n  relations_finite : Finite rels\n\n"}
{"name":"Algebra.PreSubmersivePresentation.card_relations_le_card_vars_of_isFinite","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nP : Algebra.PreSubmersivePresentation R S\ninst✝ : P.IsFinite\n⊢ LE.le (Nat.card P.rels) (Nat.card P.vars)","decl":"lemma card_relations_le_card_vars_of_isFinite [P.IsFinite] :\n    Nat.card P.rels ≤ Nat.card P.vars :=\n  Nat.card_le_card_of_injective P.map P.map_inj\n\n"}
{"name":"Algebra.PreSubmersivePresentation.aevalDifferential_single","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nP : Algebra.PreSubmersivePresentation R S\ninst✝ : DecidableEq P.rels\ni j : P.rels\n⊢ Eq (P.aevalDifferential (Pi.single i 1) j) ((MvPolynomial.aeval P.val) ((MvPolynomial.pderiv (P.map j)) (P.relation i)))","decl":"@[simp]\nlemma aevalDifferential_single [DecidableEq P.rels] (i j : P.rels) :\n    P.aevalDifferential (Pi.single i 1) j = aeval P.val (pderiv (P.map j) (P.relation i)) := by\n  dsimp only [aevalDifferential]\n  rw [← Pi.basisFun_apply, Basis.constr_basis]\n\n"}
{"name":"Algebra.PreSubmersivePresentation.jacobian_eq_jacobiMatrix_det","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nP : Algebra.PreSubmersivePresentation R S\ninst✝¹ : Fintype P.rels\ninst✝ : DecidableEq P.rels\n⊢ Eq P.jacobian ((algebraMap P.Ring S) P.jacobiMatrix.det)","decl":"lemma jacobian_eq_jacobiMatrix_det : P.jacobian = algebraMap P.Ring S P.jacobiMatrix.det := by\n   simp [jacobiMatrix, jacobian]\n\n"}
{"name":"Algebra.PreSubmersivePresentation.jacobiMatrix_apply","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nP : Algebra.PreSubmersivePresentation R S\ninst✝¹ : Fintype P.rels\ninst✝ : DecidableEq P.rels\ni j : P.rels\n⊢ Eq (P.jacobiMatrix i j) ((MvPolynomial.pderiv (P.map i)) (P.relation j))","decl":"lemma jacobiMatrix_apply (i j : P.rels) :\n    P.jacobiMatrix i j = MvPolynomial.pderiv (P.map i) (P.relation j) := by\n  simp [jacobiMatrix, LinearMap.toMatrix, differential, basis]\n\n"}
{"name":"Algebra.PreSubmersivePresentation.aevalDifferential_toMatrix'_eq_mapMatrix_jacobiMatrix","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nP : Algebra.PreSubmersivePresentation R S\ninst✝¹ : Fintype P.rels\ninst✝ : DecidableEq P.rels\n⊢ Eq (LinearMap.toMatrix' P.aevalDifferential) ((MvPolynomial.aeval P.val).mapMatrix P.jacobiMatrix)","decl":"lemma aevalDifferential_toMatrix'_eq_mapMatrix_jacobiMatrix :\n    P.aevalDifferential.toMatrix' = (aeval P.val).mapMatrix P.jacobiMatrix := by\n  ext i j : 1\n  rw [← LinearMap.toMatrix_eq_toMatrix']\n  rw [LinearMap.toMatrix_apply]\n  simp [jacobiMatrix_apply]\n\n"}
{"name":"Algebra.PreSubmersivePresentation.ofBijectiveAlgebraMap_jacobian","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nh : Function.Bijective ⇑(algebraMap R S)\n⊢ Eq (Algebra.PreSubmersivePresentation.ofBijectiveAlgebraMap h).jacobian 1","decl":"@[simp]\nlemma ofBijectiveAlgebraMap_jacobian (h : Function.Bijective (algebraMap R S)) :\n    (ofBijectiveAlgebraMap h).jacobian = 1 := by\n  classical\n  have : (algebraMap (ofBijectiveAlgebraMap h).Ring S).mapMatrix\n      (ofBijectiveAlgebraMap h).jacobiMatrix = 1 := by\n    ext (i j : PEmpty)\n    contradiction\n  rw [jacobian_eq_jacobiMatrix_det, RingHom.map_det, this, Matrix.det_one]\n\n"}
{"name":"Algebra.PreSubmersivePresentation.localizationAway_map","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nr : R\ninst✝ : IsLocalization.Away r S\nx✝ : (Algebra.Presentation.localizationAway S r).rels\n⊢ Eq ((Algebra.PreSubmersivePresentation.localizationAway S r).map x✝) Unit.unit","decl":"variable (S) in\n/-- If `S` is the localization of `R` at `r`, this is the canonical submersive presentation\nof `S` as `R`-algebra. -/\n@[simps map]\nnoncomputable def localizationAway : PreSubmersivePresentation R S where\n  __ := Presentation.localizationAway S r\n  map _ := ()\n  map_inj _ _ h := h\n  relations_finite := inferInstanceAs <| Finite Unit\n\n"}
{"name":"Algebra.PreSubmersivePresentation.localizationAway_jacobiMatrix","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nr : R\ninst✝ : IsLocalization.Away r S\n⊢ Eq (Algebra.PreSubmersivePresentation.localizationAway S r).jacobiMatrix (Matrix.diagonal fun x => MvPolynomial.C r)","decl":"@[simp]\nlemma localizationAway_jacobiMatrix :\n    (localizationAway S r).jacobiMatrix = Matrix.diagonal (fun () ↦ MvPolynomial.C r) := by\n  have h : (pderiv ()) (C r * X () - 1) = C r := by simp\n  ext (i : Unit) (j : Unit) : 1\n  rwa [jacobiMatrix_apply]\n\n"}
{"name":"Algebra.PreSubmersivePresentation.localizationAway_jacobian","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nr : R\ninst✝ : IsLocalization.Away r S\n⊢ Eq (Algebra.PreSubmersivePresentation.localizationAway S r).jacobian ((algebraMap R S) r)","decl":"@[simp]\nlemma localizationAway_jacobian : (localizationAway S r).jacobian = algebraMap R S r := by\n  rw [jacobian_eq_jacobiMatrix_det, localizationAway_jacobiMatrix]\n  simp [show Fintype.card (localizationAway r (S := S)).rels = 1 from rfl]\n\n"}
{"name":"Algebra.PreSubmersivePresentation.comp_map","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type u_1\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.PreSubmersivePresentation S T\nP : Algebra.PreSubmersivePresentation R S\na✝ : Sum Q.rels P.rels\n⊢ Eq ((Q.comp P).map a✝) (Sum.elim (fun rq => Sum.inl (Q.map rq)) (fun rp => Sum.inr (P.map rp)) a✝)","decl":"/-- Given an `R`-algebra `S` and an `S`-algebra `T` with pre-submersive presentations,\nthis is the canonical pre-submersive presentation of `T` as an `R`-algebra. -/\n@[simps map]\nnoncomputable def comp : PreSubmersivePresentation R T where\n  __ := Q.toPresentation.comp P.toPresentation\n  map := Sum.elim (fun rq ↦ Sum.inl <| Q.map rq) (fun rp ↦ Sum.inr <| P.map rp)\n  map_inj := Function.Injective.sum_elim ((Sum.inl_injective).comp (Q.map_inj))\n    ((Sum.inr_injective).comp (P.map_inj)) <| by simp\n  relations_finite := inferInstanceAs <| Finite (Q.rels ⊕ P.rels)\n\n"}
{"name":"Algebra.PreSubmersivePresentation.dimension_comp_eq_dimension_add_dimension","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : Algebra R S\nT : Type u_3\ninst✝⁵ : CommRing T\ninst✝⁴ : Algebra R T\ninst✝³ : Algebra S T\ninst✝² : IsScalarTower R S T\nQ : Algebra.PreSubmersivePresentation S T\nP : Algebra.PreSubmersivePresentation R S\ninst✝¹ : Q.IsFinite\ninst✝ : P.IsFinite\n⊢ Eq (Q.comp P).dimension (HAdd.hAdd Q.dimension P.dimension)","decl":"/-- The dimension of the composition of two finite submersive presentations is\nthe sum of the dimensions. -/\nlemma dimension_comp_eq_dimension_add_dimension [Q.IsFinite] [P.IsFinite] :\n    (Q.comp P).dimension = Q.dimension + P.dimension := by\n  simp only [Presentation.dimension]\n  erw [Presentation.comp_rels, Generators.comp_vars]\n  have : Nat.card P.rels ≤ Nat.card P.vars :=\n    card_relations_le_card_vars_of_isFinite P\n  have : Nat.card Q.rels ≤ Nat.card Q.vars :=\n    card_relations_le_card_vars_of_isFinite Q\n  simp only [Nat.card_sum]\n  omega\n\n"}
{"name":"Algebra.PreSubmersivePresentation.comp_jacobian_eq_jacobian_smul_jacobian","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type u_1\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.PreSubmersivePresentation S T\nP : Algebra.PreSubmersivePresentation R S\n⊢ Eq (Q.comp P).jacobian (HSMul.hSMul P.jacobian Q.jacobian)","decl":"/-- The jacobian of the composition of presentations is the product of the jacobians. -/\n@[simp]\nlemma comp_jacobian_eq_jacobian_smul_jacobian : (Q.comp P).jacobian = P.jacobian • Q.jacobian := by\n  classical\n  cases nonempty_fintype Q.rels\n  cases nonempty_fintype P.rels\n  letI : Fintype (Q.comp P).rels := inferInstanceAs <| Fintype (Q.rels ⊕ P.rels)\n  rw [jacobian_eq_jacobiMatrix_det, ← Matrix.fromBlocks_toBlocks ((Q.comp P).jacobiMatrix),\n    jacobiMatrix_comp_₁₂]\n  convert_to\n    (aeval (Q.comp P).val) (Q.comp P).jacobiMatrix.toBlocks₁₁.det *\n    (aeval (Q.comp P).val) (Q.comp P).jacobiMatrix.toBlocks₂₂.det = P.jacobian • Q.jacobian\n  · simp only [Generators.algebraMap_apply, ← map_mul]\n    congr\n    convert Matrix.det_fromBlocks_zero₁₂ (Q.comp P).jacobiMatrix.toBlocks₁₁\n      (Q.comp P).jacobiMatrix.toBlocks₂₁ (Q.comp P).jacobiMatrix.toBlocks₂₂\n  · rw [jacobiMatrix_comp_₁₁_det, jacobiMatrix_comp_₂₂_det, mul_comm, Algebra.smul_def]\n\n"}
{"name":"Algebra.PreSubmersivePresentation.baseChange_jacobian","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nT : Type u_1\ninst✝¹ : CommRing T\ninst✝ : Algebra R T\nP : Algebra.PreSubmersivePresentation R S\n⊢ Eq (Algebra.PreSubmersivePresentation.baseChange T P).jacobian (TensorProduct.tmul R 1 P.jacobian)","decl":"@[simp]\nlemma baseChange_jacobian : (P.baseChange T).jacobian = 1 ⊗ₜ P.jacobian := by\n  classical\n  cases nonempty_fintype P.rels\n  letI : Fintype (P.baseChange T).rels := inferInstanceAs <| Fintype P.rels\n  simp_rw [jacobian_eq_jacobiMatrix_det]\n  have h : (baseChange T P).jacobiMatrix =\n      (MvPolynomial.map (algebraMap R T)).mapMatrix P.jacobiMatrix := by\n    ext i j : 1\n    simp only [baseChange, jacobiMatrix_apply, Presentation.baseChange_relation,\n      RingHom.mapMatrix_apply, Matrix.map_apply]\n    erw [MvPolynomial.pderiv_map]\n    rfl\n  rw [h]\n  erw [← RingHom.map_det, aeval_map_algebraMap]\n  rw [P.algebraMap_apply]\n  apply aeval_one_tmul\n\n"}
{"name":"Algebra.SubmersivePresentation.mk.sizeOf_spec","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : SizeOf R\ninst✝ : SizeOf S\ntoPreSubmersivePresentation : Algebra.PreSubmersivePresentation R S\njacobian_isUnit : IsUnit toPreSubmersivePresentation.jacobian\nisFinite : autoParam toPreSubmersivePresentation.IsFinite _auto✝\n⊢ Eq (SizeOf.sizeOf { toPreSubmersivePresentation := toPreSubmersivePresentation, jacobian_isUnit := jacobian_isUnit, isFinite := isFinite }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toPreSubmersivePresentation)) (SizeOf.sizeOf jacobian_isUnit)) (SizeOf.sizeOf isFinite))","decl":"/--\nA `PreSubmersivePresentation` is submersive if its jacobian is a unit in `S`\nand the presentation is finite.\n-/\n@[nolint checkUnivs]\nstructure SubmersivePresentation extends PreSubmersivePresentation.{t, w} R S where\n  jacobian_isUnit : IsUnit toPreSubmersivePresentation.jacobian\n  isFinite : toPreSubmersivePresentation.IsFinite := by infer_instance\n\n"}
{"name":"Algebra.SubmersivePresentation.jacobian_isUnit","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nself : Algebra.SubmersivePresentation R S\n⊢ IsUnit self.jacobian","decl":"/--\nA `PreSubmersivePresentation` is submersive if its jacobian is a unit in `S`\nand the presentation is finite.\n-/\n@[nolint checkUnivs]\nstructure SubmersivePresentation extends PreSubmersivePresentation.{t, w} R S where\n  jacobian_isUnit : IsUnit toPreSubmersivePresentation.jacobian\n  isFinite : toPreSubmersivePresentation.IsFinite := by infer_instance\n\n"}
{"name":"Algebra.SubmersivePresentation.mk.injEq","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\ntoPreSubmersivePresentation✝ : Algebra.PreSubmersivePresentation R S\njacobian_isUnit✝ : IsUnit toPreSubmersivePresentation✝.jacobian\nisFinite✝ : autoParam toPreSubmersivePresentation✝.IsFinite _auto✝\ntoPreSubmersivePresentation : Algebra.PreSubmersivePresentation R S\njacobian_isUnit : IsUnit toPreSubmersivePresentation.jacobian\nisFinite : autoParam toPreSubmersivePresentation.IsFinite _auto✝\n⊢ Eq (Eq { toPreSubmersivePresentation := toPreSubmersivePresentation✝, jacobian_isUnit := jacobian_isUnit✝, isFinite := isFinite✝ } { toPreSubmersivePresentation := toPreSubmersivePresentation, jacobian_isUnit := jacobian_isUnit, isFinite := isFinite }) (Eq toPreSubmersivePresentation✝ toPreSubmersivePresentation)","decl":"/--\nA `PreSubmersivePresentation` is submersive if its jacobian is a unit in `S`\nand the presentation is finite.\n-/\n@[nolint checkUnivs]\nstructure SubmersivePresentation extends PreSubmersivePresentation.{t, w} R S where\n  jacobian_isUnit : IsUnit toPreSubmersivePresentation.jacobian\n  isFinite : toPreSubmersivePresentation.IsFinite := by infer_instance\n\n"}
{"name":"Algebra.SubmersivePresentation.isFinite","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nself : Algebra.SubmersivePresentation R S\n⊢ self.IsFinite","decl":"/--\nA `PreSubmersivePresentation` is submersive if its jacobian is a unit in `S`\nand the presentation is finite.\n-/\n@[nolint checkUnivs]\nstructure SubmersivePresentation extends PreSubmersivePresentation.{t, w} R S where\n  jacobian_isUnit : IsUnit toPreSubmersivePresentation.jacobian\n  isFinite : toPreSubmersivePresentation.IsFinite := by infer_instance\n\n"}
{"name":"Algebra.SubmersivePresentation.mk.inj","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\ntoPreSubmersivePresentation✝ : Algebra.PreSubmersivePresentation R S\njacobian_isUnit✝ : IsUnit toPreSubmersivePresentation✝.jacobian\nisFinite✝ : autoParam toPreSubmersivePresentation✝.IsFinite _auto✝\ntoPreSubmersivePresentation : Algebra.PreSubmersivePresentation R S\njacobian_isUnit : IsUnit toPreSubmersivePresentation.jacobian\nisFinite : autoParam toPreSubmersivePresentation.IsFinite _auto✝\nx✝ : Eq { toPreSubmersivePresentation := toPreSubmersivePresentation✝, jacobian_isUnit := jacobian_isUnit✝, isFinite := isFinite✝ } { toPreSubmersivePresentation := toPreSubmersivePresentation, jacobian_isUnit := jacobian_isUnit, isFinite := isFinite }\n⊢ Eq toPreSubmersivePresentation✝ toPreSubmersivePresentation","decl":"/--\nA `PreSubmersivePresentation` is submersive if its jacobian is a unit in `S`\nand the presentation is finite.\n-/\n@[nolint checkUnivs]\nstructure SubmersivePresentation extends PreSubmersivePresentation.{t, w} R S where\n  jacobian_isUnit : IsUnit toPreSubmersivePresentation.jacobian\n  isFinite : toPreSubmersivePresentation.IsFinite := by infer_instance\n\n"}
{"name":"Algebra.SubmersivePresentation.aevalDifferentialEquiv_apply","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.SubmersivePresentation R S\nx : P.rels → S\n⊢ Eq (P.aevalDifferentialEquiv x) (P.aevalDifferential x)","decl":"@[simp]\nlemma aevalDifferentialEquiv_apply (x : P.rels → S) :\n    P.aevalDifferentialEquiv x = P.aevalDifferential x :=\n  rfl\n\n"}
{"name":"Algebra.SubmersivePresentation.basisDeriv_apply","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.SubmersivePresentation R S\ni j : P.rels\n⊢ Eq (P.basisDeriv i j) ((MvPolynomial.aeval P.val) ((MvPolynomial.pderiv (P.map j)) (P.relation i)))","decl":"@[simp]\nlemma basisDeriv_apply (i j : P.rels) :\n    P.basisDeriv i j = (aeval P.val) (pderiv (P.map j) (P.relation i)) := by\n  classical\n  simp [basisDeriv]\n\n"}
{"name":"Algebra.SubmersivePresentation.linearIndependent_aeval_val_pderiv_relation","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.SubmersivePresentation R S\n⊢ LinearIndependent S fun i j => (MvPolynomial.aeval P.val) ((MvPolynomial.pderiv (P.map j)) (P.relation i))","decl":"lemma linearIndependent_aeval_val_pderiv_relation :\n    LinearIndependent S (fun i j ↦ (aeval P.val) (pderiv (P.map j) (P.relation i))) := by\n  simp_rw [← SubmersivePresentation.basisDeriv_apply]\n  exact P.basisDeriv.linearIndependent\n\n"}
{"name":"Algebra.IsStandardSmooth.out","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nself : Algebra.IsStandardSmooth R S\n⊢ Nonempty (Algebra.SubmersivePresentation R S)","decl":"/--\nAn `R`-algebra `S` is called standard smooth, if there\nexists a submersive presentation.\n-/\nclass IsStandardSmooth : Prop where\n  out : Nonempty (SubmersivePresentation.{t, w} R S)\n\n"}
{"name":"Algebra.IsStandardSmoothOfRelativeDimension.out","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"n : Nat\nR : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nself : Algebra.IsStandardSmoothOfRelativeDimension n R S\n⊢ Exists fun P => Eq P.dimension n","decl":"/--\nAn `R`-algebra `S` is called standard smooth of relative dimension `n`, if there exists\na submersive presentation of dimension `n`.\n-/\nclass IsStandardSmoothOfRelativeDimension : Prop where\n  out : ∃ P : SubmersivePresentation.{t, w} R S, P.dimension = n\n\n"}
{"name":"Algebra.IsStandardSmoothOfRelativeDimension.isStandardSmooth","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"n : Nat\nR : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : Algebra.IsStandardSmoothOfRelativeDimension n R S\n⊢ Algebra.IsStandardSmooth R S","decl":"lemma IsStandardSmoothOfRelativeDimension.isStandardSmooth\n    [IsStandardSmoothOfRelativeDimension.{t, w} n R S] :\n    IsStandardSmooth.{t, w} R S :=\n  ⟨‹IsStandardSmoothOfRelativeDimension n R S›.out.nonempty⟩\n\n"}
{"name":"Algebra.IsStandardSmoothOfRelativeDimension.of_algebraMap_bijective","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nh : Function.Bijective ⇑(algebraMap R S)\n⊢ Algebra.IsStandardSmoothOfRelativeDimension 0 R S","decl":"lemma IsStandardSmoothOfRelativeDimension.of_algebraMap_bijective\n    (h : Function.Bijective (algebraMap R S)) :\n    IsStandardSmoothOfRelativeDimension.{t, w} 0 R S :=\n  ⟨SubmersivePresentation.ofBijectiveAlgebraMap h, Presentation.ofBijectiveAlgebraMap_dimension h⟩\n\n"}
{"name":"Algebra.IsStandardSmoothOfRelativeDimension.id","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\ninst✝ : CommRing R\n⊢ Algebra.IsStandardSmoothOfRelativeDimension 0 R R","decl":"variable (R) in\ninstance IsStandardSmoothOfRelativeDimension.id :\n    IsStandardSmoothOfRelativeDimension.{t, w} 0 R R :=\n  IsStandardSmoothOfRelativeDimension.of_algebraMap_bijective Function.bijective_id\n\n"}
{"name":"Algebra.IsStandardSmooth.finitePresentation","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : Algebra.IsStandardSmooth R S\n⊢ Algebra.FinitePresentation R S","decl":"instance (priority := 100) IsStandardSmooth.finitePresentation [IsStandardSmooth R S] :\n    FinitePresentation R S := by\n  obtain ⟨⟨P⟩⟩ := ‹IsStandardSmooth R S›\n  exact P.finitePresentation_of_isFinite\n\n"}
{"name":"Algebra.IsStandardSmooth.trans","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : Algebra R S\nT : Type u_1\ninst✝⁵ : CommRing T\ninst✝⁴ : Algebra R T\ninst✝³ : Algebra S T\ninst✝² : IsScalarTower R S T\ninst✝¹ : Algebra.IsStandardSmooth R S\ninst✝ : Algebra.IsStandardSmooth S T\n⊢ Algebra.IsStandardSmooth R T","decl":"lemma IsStandardSmooth.trans [IsStandardSmooth.{t, w} R S] [IsStandardSmooth.{t', w'} S T] :\n    IsStandardSmooth.{max t t', max w w'} R T where\n  out := by\n    obtain ⟨⟨P⟩⟩ := ‹IsStandardSmooth R S›\n    obtain ⟨⟨Q⟩⟩ := ‹IsStandardSmooth S T›\n    exact ⟨Q.comp P⟩\n\n"}
{"name":"Algebra.IsStandardSmoothOfRelativeDimension.trans","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"n m : Nat\nR : Type u\nS : Type v\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : Algebra R S\nT : Type u_1\ninst✝⁵ : CommRing T\ninst✝⁴ : Algebra R T\ninst✝³ : Algebra S T\ninst✝² : IsScalarTower R S T\ninst✝¹ : Algebra.IsStandardSmoothOfRelativeDimension n R S\ninst✝ : Algebra.IsStandardSmoothOfRelativeDimension m S T\n⊢ Algebra.IsStandardSmoothOfRelativeDimension (HAdd.hAdd m n) R T","decl":"lemma IsStandardSmoothOfRelativeDimension.trans [IsStandardSmoothOfRelativeDimension.{t, w} n R S]\n    [IsStandardSmoothOfRelativeDimension.{t', w'} m S T] :\n    IsStandardSmoothOfRelativeDimension.{max t t', max w w'} (m + n) R T where\n  out := by\n    obtain ⟨P, hP⟩ := ‹IsStandardSmoothOfRelativeDimension n R S›\n    obtain ⟨Q, hQ⟩ := ‹IsStandardSmoothOfRelativeDimension m S T›\n    refine ⟨Q.comp P, hP ▸ hQ ▸ ?_⟩\n    apply PreSubmersivePresentation.dimension_comp_eq_dimension_add_dimension\n\n"}
{"name":"Algebra.IsStandardSmooth.localization_away","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nr : R\ninst✝ : IsLocalization.Away r S\n⊢ Algebra.IsStandardSmooth R S","decl":"lemma IsStandardSmooth.localization_away (r : R) [IsLocalization.Away r S] :\n    IsStandardSmooth.{0, 0} R S where\n  out := ⟨SubmersivePresentation.localizationAway S r⟩\n\n"}
{"name":"Algebra.IsStandardSmoothOfRelativeDimension.localization_away","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nr : R\ninst✝ : IsLocalization.Away r S\n⊢ Algebra.IsStandardSmoothOfRelativeDimension 0 R S","decl":"lemma IsStandardSmoothOfRelativeDimension.localization_away (r : R) [IsLocalization.Away r S] :\n    IsStandardSmoothOfRelativeDimension.{0, 0} 0 R S where\n  out := ⟨SubmersivePresentation.localizationAway S r,\n    Presentation.localizationAway_dimension_zero r⟩\n\n"}
{"name":"Algebra.IsStandardSmooth.baseChange","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"R : Type u\nS : Type v\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\nT : Type u_1\ninst✝² : CommRing T\ninst✝¹ : Algebra R T\ninst✝ : Algebra.IsStandardSmooth R S\n⊢ Algebra.IsStandardSmooth T (TensorProduct R T S)","decl":"instance IsStandardSmooth.baseChange [IsStandardSmooth.{t, w} R S] :\n    IsStandardSmooth.{t, w} T (T ⊗[R] S) where\n  out := by\n    obtain ⟨⟨P⟩⟩ := ‹IsStandardSmooth R S›\n    exact ⟨P.baseChange R S T⟩\n\n"}
{"name":"Algebra.IsStandardSmoothOfRelativeDimension.baseChange","module":"Mathlib.RingTheory.Smooth.StandardSmooth","initialProofState":"n : Nat\nR : Type u\nS : Type v\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\nT : Type u_1\ninst✝² : CommRing T\ninst✝¹ : Algebra R T\ninst✝ : Algebra.IsStandardSmoothOfRelativeDimension n R S\n⊢ Algebra.IsStandardSmoothOfRelativeDimension n T (TensorProduct R T S)","decl":"instance IsStandardSmoothOfRelativeDimension.baseChange\n    [IsStandardSmoothOfRelativeDimension.{t, w} n R S] :\n    IsStandardSmoothOfRelativeDimension.{t, w} n T (T ⊗[R] S) where\n  out := by\n    obtain ⟨P, hP⟩ := ‹IsStandardSmoothOfRelativeDimension n R S›\n    exact ⟨P.baseChange R S T, hP⟩\n\n"}
