{"name":"summable_riemannZetaSummand","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n‚ä¢ Summable fun n => Norm.norm ((riemannZetaSummandHom ‚ãØ) n)","decl":"/-- When `s.re > 1`, the map `n ‚Ü¶ n^(-s)` is norm-summable. -/\nlemma summable_riemannZetaSummand (hs : 1 < s.re) :\n    Summable (fun n ‚Ü¶ ‚ÄñriemannZetaSummandHom (ne_zero_of_one_lt_re hs) n‚Äñ) := by\n  simp only [riemannZetaSummandHom, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk]\n  convert Real.summable_nat_rpow_inv.mpr hs with n\n  rw [‚Üê ofReal_natCast, Complex.norm_eq_abs,\n    abs_cpow_eq_rpow_re_of_nonneg (Nat.cast_nonneg n) <| re_neg_ne_zero_of_one_lt_re hs,\n    neg_re, Real.rpow_neg <| Nat.cast_nonneg n]\n\n"}
{"name":"tsum_riemannZetaSummand","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n‚ä¢ Eq (tsum fun n => (riemannZetaSummandHom ‚ãØ) n) (riemannZeta s)","decl":"lemma tsum_riemannZetaSummand (hs : 1 < s.re) :\n    ‚àë' (n : ‚Ñï), riemannZetaSummandHom (ne_zero_of_one_lt_re hs) n = riemannZeta s := by\n  have hsum := summable_riemannZetaSummand hs\n  rw [zeta_eq_tsum_one_div_nat_add_one_cpow hs, tsum_eq_zero_add hsum.of_norm, map_zero, zero_add]\n  simp only [riemannZetaSummandHom, cpow_neg, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk,\n    Nat.cast_add, Nat.cast_one, one_div]\n\n"}
{"name":"summable_dirichletSummand","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nN : Nat\nœá : DirichletCharacter Complex N\nhs : LT.lt 1 s.re\n‚ä¢ Summable fun n => Norm.norm ((dirichletSummandHom œá ‚ãØ) n)","decl":"/-- When `s.re > 1`, the map `n ‚Ü¶ œá(n) * n^(-s)` is norm-summable. -/\nlemma summable_dirichletSummand {N : ‚Ñï} (œá : DirichletCharacter ‚ÑÇ N) (hs : 1 < s.re) :\n    Summable (fun n ‚Ü¶ ‚ÄñdirichletSummandHom œá (ne_zero_of_one_lt_re hs) n‚Äñ) := by\n  simp only [dirichletSummandHom, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk, norm_mul]\n  exact (summable_riemannZetaSummand hs).of_nonneg_of_le (fun _ ‚Ü¶ by positivity)\n    (fun n ‚Ü¶ mul_le_of_le_one_left (norm_nonneg _) <| œá.norm_le_one n)\n\n"}
{"name":"tsum_dirichletSummand","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nN : Nat\nœá : DirichletCharacter Complex N\nhs : LT.lt 1 s.re\n‚ä¢ Eq (tsum fun n => (dirichletSummandHom œá ‚ãØ) n) (LSeries (fun n => œá ‚Üën) s)","decl":"open scoped LSeries.notation in\nlemma tsum_dirichletSummand {N : ‚Ñï} (œá : DirichletCharacter ‚ÑÇ N) (hs : 1 < s.re) :\n    ‚àë' (n : ‚Ñï), dirichletSummandHom œá (ne_zero_of_one_lt_re hs) n = L ‚Üóœá s := by\n  simp only [dirichletSummandHom, cpow_neg, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk, LSeries,\n    LSeries.term_of_ne_zero' (ne_zero_of_one_lt_re hs), div_eq_mul_inv]\n\n"}
{"name":"riemannZeta_eulerProduct_hasProd","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n‚ä¢ HasProd (fun p => Inv.inv (HSub.hSub 1 (HPow.hPow (‚Üë‚Üëp) (Neg.neg s)))) (riemannZeta s)","decl":"/-- The Euler product for the Riemann Œ∂ function, valid for `s.re > 1`.\nThis version is stated in terms of `HasProd`. -/\ntheorem riemannZeta_eulerProduct_hasProd (hs : 1 < s.re) :\n    HasProd (fun p : Primes ‚Ü¶ (1 - (p : ‚ÑÇ) ^ (-s))‚Åª¬π) (riemannZeta s) := by\n  rw [‚Üê tsum_riemannZetaSummand hs]\n  apply eulerProduct_completely_multiplicative_hasProd <| summable_riemannZetaSummand hs\n\n"}
{"name":"riemannZeta_eulerProduct_tprod","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n‚ä¢ Eq (tprod fun p => Inv.inv (HSub.hSub 1 (HPow.hPow (‚Üë‚Üëp) (Neg.neg s)))) (riemannZeta s)","decl":"/-- The Euler product for the Riemann Œ∂ function, valid for `s.re > 1`.\nThis version is stated in terms of `tprod`. -/\ntheorem riemannZeta_eulerProduct_tprod (hs : 1 < s.re) :\n    ‚àè' p : Primes, (1 - (p : ‚ÑÇ) ^ (-s))‚Åª¬π = riemannZeta s :=\n  (riemannZeta_eulerProduct_hasProd hs).tprod_eq\n\n"}
{"name":"riemannZeta_eulerProduct","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n‚ä¢ Filter.Tendsto (fun n => n.primesBelow.prod fun p => Inv.inv (HSub.hSub 1 (HPow.hPow (‚Üëp) (Neg.neg s)))) Filter.atTop (nhds (riemannZeta s))","decl":"/-- The Euler product for the Riemann Œ∂ function, valid for `s.re > 1`.\nThis version is stated in the form of convergence of finite partial products. -/\ntheorem riemannZeta_eulerProduct (hs : 1 < s.re) :\n    Tendsto (fun n : ‚Ñï ‚Ü¶ ‚àè p ‚àà primesBelow n, (1 - (p : ‚ÑÇ) ^ (-s))‚Åª¬π) atTop\n      (ùìù (riemannZeta s)) := by\n  rw [‚Üê tsum_riemannZetaSummand hs]\n  apply eulerProduct_completely_multiplicative <| summable_riemannZetaSummand hs\n\n"}
{"name":"DirichletCharacter.LSeries_eulerProduct_hasProd","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nN : Nat\nœá : DirichletCharacter Complex N\nhs : LT.lt 1 s.re\n‚ä¢ HasProd (fun p => Inv.inv (HSub.hSub 1 (HMul.hMul (œá ‚Üë‚Üëp) (HPow.hPow (‚Üë‚Üëp) (Neg.neg s))))) (LSeries (fun n => œá ‚Üën) s)","decl":"/-- The Euler product for Dirichlet L-series, valid for `s.re > 1`.\nThis version is stated in terms of `HasProd`. -/\ntheorem DirichletCharacter.LSeries_eulerProduct_hasProd {N : ‚Ñï} (œá : DirichletCharacter ‚ÑÇ N)\n    (hs : 1 < s.re) :\n    HasProd (fun p : Primes ‚Ü¶ (1 - œá p * (p : ‚ÑÇ) ^ (-s))‚Åª¬π) (L ‚Üóœá s) := by\n  rw [‚Üê tsum_dirichletSummand œá hs]\n  convert eulerProduct_completely_multiplicative_hasProd <| summable_dirichletSummand œá hs\n\n"}
{"name":"dirichletLSeries_eulerProduct_hasProd","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nN : Nat\nœá : DirichletCharacter Complex N\nhs : LT.lt 1 s.re\n‚ä¢ HasProd (fun p => Inv.inv (HSub.hSub 1 (HMul.hMul (œá ‚Üë‚Üëp) (HPow.hPow (‚Üë‚Üëp) (Neg.neg s))))) (LSeries (fun n => œá ‚Üën) s)","decl":"@[deprecated (since := \"2024-11-14\")] alias\n  dirichletLSeries_eulerProduct_hasProd := DirichletCharacter.LSeries_eulerProduct_hasProd\n\n"}
{"name":"DirichletCharacter.LSeries_eulerProduct_tprod","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nN : Nat\nœá : DirichletCharacter Complex N\nhs : LT.lt 1 s.re\n‚ä¢ Eq (tprod fun p => Inv.inv (HSub.hSub 1 (HMul.hMul (œá ‚Üë‚Üëp) (HPow.hPow (‚Üë‚Üëp) (Neg.neg s))))) (LSeries (fun n => œá ‚Üën) s)","decl":"/-- The Euler product for Dirichlet L-series, valid for `s.re > 1`.\nThis version is stated in terms of `tprod`. -/\ntheorem DirichletCharacter.LSeries_eulerProduct_tprod {N : ‚Ñï} (œá : DirichletCharacter ‚ÑÇ N)\n    (hs : 1 < s.re) :\n    ‚àè' p : Primes, (1 - œá p * (p : ‚ÑÇ) ^ (-s))‚Åª¬π = L ‚Üóœá s :=\n  (DirichletCharacter.LSeries_eulerProduct_hasProd œá hs).tprod_eq\n\n"}
{"name":"dirichlet_LSeries_eulerProduct_tprod","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nN : Nat\nœá : DirichletCharacter Complex N\nhs : LT.lt 1 s.re\n‚ä¢ Eq (tprod fun p => Inv.inv (HSub.hSub 1 (HMul.hMul (œá ‚Üë‚Üëp) (HPow.hPow (‚Üë‚Üëp) (Neg.neg s))))) (LSeries (fun n => œá ‚Üën) s)","decl":"@[deprecated (since := \"2024-11-14\")] alias\n  dirichlet_LSeries_eulerProduct_tprod := DirichletCharacter.LSeries_eulerProduct_tprod\n\n"}
{"name":"DirichletCharacter.LSeries_eulerProduct","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nN : Nat\nœá : DirichletCharacter Complex N\nhs : LT.lt 1 s.re\n‚ä¢ Filter.Tendsto (fun n => n.primesBelow.prod fun p => Inv.inv (HSub.hSub 1 (HMul.hMul (œá ‚Üëp) (HPow.hPow (‚Üëp) (Neg.neg s))))) Filter.atTop (nhds (LSeries (fun n => œá ‚Üën) s))","decl":"/-- The Euler product for Dirichlet L-series, valid for `s.re > 1`.\nThis version is stated in the form of convergence of finite partial products. -/\ntheorem DirichletCharacter.LSeries_eulerProduct {N : ‚Ñï} (œá : DirichletCharacter ‚ÑÇ N)\n    (hs : 1 < s.re) :\n    Tendsto (fun n : ‚Ñï ‚Ü¶ ‚àè p ‚àà primesBelow n, (1 - œá p * (p : ‚ÑÇ) ^ (-s))‚Åª¬π) atTop\n      (ùìù (L ‚Üóœá s)) := by\n  rw [‚Üê tsum_dirichletSummand œá hs]\n  apply eulerProduct_completely_multiplicative <| summable_dirichletSummand œá hs\n\n"}
{"name":"dirichletLSeries_eulerProduct","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nN : Nat\nœá : DirichletCharacter Complex N\nhs : LT.lt 1 s.re\n‚ä¢ Filter.Tendsto (fun n => n.primesBelow.prod fun p => Inv.inv (HSub.hSub 1 (HMul.hMul (œá ‚Üëp) (HPow.hPow (‚Üëp) (Neg.neg s))))) Filter.atTop (nhds (LSeries (fun n => œá ‚Üën) s))","decl":"@[deprecated (since := \"2024-11-14\")] alias\n  dirichletLSeries_eulerProduct := DirichletCharacter.LSeries_eulerProduct\n\n"}
{"name":"DirichletCharacter.LSeries_eulerProduct_exp_log","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"N : Nat\nœá : DirichletCharacter Complex N\ns : Complex\nhs : LT.lt 1 s.re\n‚ä¢ Eq (Complex.exp (tsum fun p => Neg.neg (Complex.log (HSub.hSub 1 (HMul.hMul (œá ‚Üë‚Üëp) (HPow.hPow (‚Üë‚Üëp) (Neg.neg s))))))) (LSeries (fun n => œá ‚Üën) s)","decl":"/-- A variant of the Euler product for Dirichlet L-series. -/\ntheorem DirichletCharacter.LSeries_eulerProduct_exp_log {N : ‚Ñï} (œá : DirichletCharacter ‚ÑÇ N)\n    {s : ‚ÑÇ} (hs : 1 < s.re) :\n    exp (‚àë' p : Nat.Primes, -log (1 - œá p * p ^ (-s))) = L ‚Üóœá s := by\n  let f := dirichletSummandHom œá <| ne_zero_of_one_lt_re hs\n  have h n : term ‚Üóœá s n = f n := by\n    rcases eq_or_ne n 0 with rfl | hn\n    ¬∑ simp only [term_zero, map_zero]\n    ¬∑ simp only [ne_eq, hn, not_false_eq_true, term_of_ne_zero, div_eq_mul_inv,\n        dirichletSummandHom, cpow_neg, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk, f]\n  simpa only [LSeries, h]\n    using exp_tsum_primes_log_eq_tsum (f := f) <| summable_dirichletSummand œá hs\n\n"}
{"name":"ArithmeticFunction.LSeries_zeta_eulerProduct_exp_log","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n‚ä¢ Eq (Complex.exp (tsum fun p => Neg.neg (Complex.log (HSub.hSub 1 (HPow.hPow (‚Üë‚Üëp) (Neg.neg s)))))) (LSeries 1 s)","decl":"/-- A variant of the Euler product for the L-series of `Œ∂`. -/\ntheorem ArithmeticFunction.LSeries_zeta_eulerProduct_exp_log {s : ‚ÑÇ} (hs : 1 < s.re) :\n    exp (‚àë' p : Nat.Primes, -Complex.log (1 - p ^ (-s))) = L 1 s := by\n  convert modOne_eq_one (R := ‚ÑÇ) ‚ñ∏\n    DirichletCharacter.LSeries_eulerProduct_exp_log (1 : DirichletCharacter ‚ÑÇ 1) hs using 7\n  rw [MulChar.one_apply <| isUnit_of_subsingleton _, one_mul]\n\n"}
{"name":"riemannZeta_eulerProduct_exp_log","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n‚ä¢ Eq (Complex.exp (tsum fun p => Neg.neg (Complex.log (HSub.hSub 1 (HPow.hPow (‚Üë‚Üëp) (Neg.neg s)))))) (riemannZeta s)","decl":"/-- A variant of the Euler product for the Riemann zeta function. -/\ntheorem riemannZeta_eulerProduct_exp_log {s : ‚ÑÇ} (hs : 1 < s.re) :\n    exp (‚àë' p : Nat.Primes, -Complex.log (1 - p ^ (-s))) = riemannZeta s :=\n  LSeries_one_eq_riemannZeta hs ‚ñ∏ ArithmeticFunction.LSeries_zeta_eulerProduct_exp_log hs\n\n"}
{"name":"DirichletCharacter.LSeries_changeLevel","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"M N : Nat\ninst‚úù : NeZero N\nhMN : Dvd.dvd M N\nœá : DirichletCharacter Complex M\ns : Complex\nhs : LT.lt 1 s.re\n‚ä¢ Eq (LSeries (fun n => ((DirichletCharacter.changeLevel hMN) œá) ‚Üën) s) (HMul.hMul (LSeries (fun n => œá ‚Üën) s) (N.primeFactors.prod fun p => HSub.hSub 1 (HMul.hMul (œá ‚Üëp) (HPow.hPow (‚Üëp) (Neg.neg s)))))","decl":"/-- If `œá` is a Dirichlet character and its level `M` divides `N`, then we obtain the L-series\nof `œá` considered as a Dirichlet character of level `N` from the L-series of `œá` by multiplying\nwith `‚àè p ‚àà N.primeFactors, (1 - œá p * p ^ (-s))`. -/\nlemma DirichletCharacter.LSeries_changeLevel {M N : ‚Ñï} [NeZero N]\n    (hMN : M ‚à£ N) (œá : DirichletCharacter ‚ÑÇ M) {s : ‚ÑÇ} (hs : 1 < s.re) :\n    LSeries ‚Üó(changeLevel hMN œá) s =\n      LSeries ‚Üóœá s * ‚àè p ‚àà N.primeFactors, (1 - œá p * p ^ (-s)) := by\n  rw [prod_eq_tprod_mulIndicator, ‚Üê DirichletCharacter.LSeries_eulerProduct_tprod _ hs,\n    ‚Üê DirichletCharacter.LSeries_eulerProduct_tprod _ hs]\n  -- convert to a form suitable for `tprod_subtype`\n  have (f : Primes ‚Üí ‚ÑÇ) : ‚àè' (p : Primes), f p = ‚àè' (p : ‚Üë{p : ‚Ñï | p.Prime}), f p := rfl\n  rw [this, tprod_subtype _ fun p : ‚Ñï ‚Ü¶ (1 - (changeLevel hMN œá) p * p ^ (-s))‚Åª¬π,\n    this, tprod_subtype _ fun p : ‚Ñï ‚Ü¶ (1 - œá p * p ^ (-s))‚Åª¬π, ‚Üê tprod_mul]\n  rotate_left -- deal with convergence goals first\n  ¬∑ exact multipliable_subtype_iff_mulIndicator.mp\n      (DirichletCharacter.LSeries_eulerProduct_hasProd œá hs).multipliable\n  ¬∑ exact multipliable_subtype_iff_mulIndicator.mp Multipliable.of_finite\n  ¬∑ congr 1 with p\n    simp only [Set.mulIndicator_apply, Set.mem_setOf_eq, Finset.mem_coe, Nat.mem_primeFactors,\n      ne_eq, mul_ite, ite_mul, one_mul, mul_one]\n    by_cases h : p.Prime; swap\n    ¬∑ simp only [h, false_and, if_false]\n    simp only [h, true_and, if_true]\n    by_cases hp' : p ‚à£ N; swap\n    ¬∑ simp only [hp', false_and, ‚ÜìreduceIte, inv_inj, sub_right_inj, mul_eq_mul_right_iff,\n        cpow_eq_zero_iff, Nat.cast_eq_zero, h.ne_zero, ne_eq, neg_eq_zero, or_false]\n      have hq : IsUnit (p : ZMod N) := (ZMod.isUnit_prime_iff_not_dvd h).mpr hp'\n      simp only [hq.unit_spec ‚ñ∏ DirichletCharacter.changeLevel_eq_cast_of_dvd œá hMN hq.unit,\n        ZMod.cast_natCast hMN]\n    ¬∑ simp only [hp', NeZero.ne N, not_false_eq_true, and_self, ‚ÜìreduceIte]\n      have : ¬¨IsUnit (p : ZMod N) := by rwa [ZMod.isUnit_prime_iff_not_dvd h, not_not]\n      rw [MulChar.map_nonunit _ this, zero_mul, sub_zero, inv_one]\n      refine (inv_mul_cancel‚ÇÄ ?_).symm\n      rw [sub_ne_zero, ne_comm]\n      -- Remains to show `œá p * p ^ (-s) ‚â† 1`. We show its norm is strictly `< 1`.\n      apply_fun (‚Äñ¬∑‚Äñ)\n      simp only [norm_mul, norm_one]\n      have ha : ‚Äñœá p‚Äñ ‚â§ 1 := œá.norm_le_one p\n      have hb : ‚Äñ(p : ‚ÑÇ) ^ (-s)‚Äñ ‚â§ 1 / 2 := norm_prime_cpow_le_one_half ‚ü®p, h‚ü© hs\n      exact ((mul_le_mul ha hb (norm_nonneg _) zero_le_one).trans_lt (by norm_num)).ne\n"}
