{"name":"summable_riemannZetaSummand","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n⊢ Summable fun n => Norm.norm ((riemannZetaSummandHom ⋯) n)","decl":"/-- When `s.re > 1`, the map `n ↦ n^(-s)` is norm-summable. -/\nlemma summable_riemannZetaSummand (hs : 1 < s.re) :\n    Summable (fun n ↦ ‖riemannZetaSummandHom (ne_zero_of_one_lt_re hs) n‖) := by\n  simp only [riemannZetaSummandHom, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk]\n  convert Real.summable_nat_rpow_inv.mpr hs with n\n  rw [← ofReal_natCast, Complex.norm_eq_abs,\n    abs_cpow_eq_rpow_re_of_nonneg (Nat.cast_nonneg n) <| re_neg_ne_zero_of_one_lt_re hs,\n    neg_re, Real.rpow_neg <| Nat.cast_nonneg n]\n\n"}
{"name":"tsum_riemannZetaSummand","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n⊢ Eq (tsum fun n => (riemannZetaSummandHom ⋯) n) (riemannZeta s)","decl":"lemma tsum_riemannZetaSummand (hs : 1 < s.re) :\n    ∑' (n : ℕ), riemannZetaSummandHom (ne_zero_of_one_lt_re hs) n = riemannZeta s := by\n  have hsum := summable_riemannZetaSummand hs\n  rw [zeta_eq_tsum_one_div_nat_add_one_cpow hs, tsum_eq_zero_add hsum.of_norm, map_zero, zero_add]\n  simp only [riemannZetaSummandHom, cpow_neg, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk,\n    Nat.cast_add, Nat.cast_one, one_div]\n\n"}
{"name":"summable_dirichletSummand","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nN : Nat\nχ : DirichletCharacter Complex N\nhs : LT.lt 1 s.re\n⊢ Summable fun n => Norm.norm ((dirichletSummandHom χ ⋯) n)","decl":"/-- When `s.re > 1`, the map `n ↦ χ(n) * n^(-s)` is norm-summable. -/\nlemma summable_dirichletSummand {N : ℕ} (χ : DirichletCharacter ℂ N) (hs : 1 < s.re) :\n    Summable (fun n ↦ ‖dirichletSummandHom χ (ne_zero_of_one_lt_re hs) n‖) := by\n  simp only [dirichletSummandHom, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk, norm_mul]\n  exact (summable_riemannZetaSummand hs).of_nonneg_of_le (fun _ ↦ by positivity)\n    (fun n ↦ mul_le_of_le_one_left (norm_nonneg _) <| χ.norm_le_one n)\n\n"}
{"name":"tsum_dirichletSummand","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nN : Nat\nχ : DirichletCharacter Complex N\nhs : LT.lt 1 s.re\n⊢ Eq (tsum fun n => (dirichletSummandHom χ ⋯) n) (LSeries (fun n => χ ↑n) s)","decl":"open scoped LSeries.notation in\nlemma tsum_dirichletSummand {N : ℕ} (χ : DirichletCharacter ℂ N) (hs : 1 < s.re) :\n    ∑' (n : ℕ), dirichletSummandHom χ (ne_zero_of_one_lt_re hs) n = L ↗χ s := by\n  simp only [dirichletSummandHom, cpow_neg, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk, LSeries,\n    LSeries.term_of_ne_zero' (ne_zero_of_one_lt_re hs), div_eq_mul_inv]\n\n"}
{"name":"riemannZeta_eulerProduct_hasProd","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n⊢ HasProd (fun p => Inv.inv (HSub.hSub 1 (HPow.hPow (↑↑p) (Neg.neg s)))) (riemannZeta s)","decl":"/-- The Euler product for the Riemann ζ function, valid for `s.re > 1`.\nThis version is stated in terms of `HasProd`. -/\ntheorem riemannZeta_eulerProduct_hasProd (hs : 1 < s.re) :\n    HasProd (fun p : Primes ↦ (1 - (p : ℂ) ^ (-s))⁻¹) (riemannZeta s) := by\n  rw [← tsum_riemannZetaSummand hs]\n  apply eulerProduct_completely_multiplicative_hasProd <| summable_riemannZetaSummand hs\n\n"}
{"name":"riemannZeta_eulerProduct_tprod","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n⊢ Eq (tprod fun p => Inv.inv (HSub.hSub 1 (HPow.hPow (↑↑p) (Neg.neg s)))) (riemannZeta s)","decl":"/-- The Euler product for the Riemann ζ function, valid for `s.re > 1`.\nThis version is stated in terms of `tprod`. -/\ntheorem riemannZeta_eulerProduct_tprod (hs : 1 < s.re) :\n    ∏' p : Primes, (1 - (p : ℂ) ^ (-s))⁻¹ = riemannZeta s :=\n  (riemannZeta_eulerProduct_hasProd hs).tprod_eq\n\n"}
{"name":"riemannZeta_eulerProduct","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n⊢ Filter.Tendsto (fun n => n.primesBelow.prod fun p => Inv.inv (HSub.hSub 1 (HPow.hPow (↑p) (Neg.neg s)))) Filter.atTop (nhds (riemannZeta s))","decl":"/-- The Euler product for the Riemann ζ function, valid for `s.re > 1`.\nThis version is stated in the form of convergence of finite partial products. -/\ntheorem riemannZeta_eulerProduct (hs : 1 < s.re) :\n    Tendsto (fun n : ℕ ↦ ∏ p ∈ primesBelow n, (1 - (p : ℂ) ^ (-s))⁻¹) atTop\n      (𝓝 (riemannZeta s)) := by\n  rw [← tsum_riemannZetaSummand hs]\n  apply eulerProduct_completely_multiplicative <| summable_riemannZetaSummand hs\n\n"}
{"name":"DirichletCharacter.LSeries_eulerProduct_hasProd","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nN : Nat\nχ : DirichletCharacter Complex N\nhs : LT.lt 1 s.re\n⊢ HasProd (fun p => Inv.inv (HSub.hSub 1 (HMul.hMul (χ ↑↑p) (HPow.hPow (↑↑p) (Neg.neg s))))) (LSeries (fun n => χ ↑n) s)","decl":"/-- The Euler product for Dirichlet L-series, valid for `s.re > 1`.\nThis version is stated in terms of `HasProd`. -/\ntheorem DirichletCharacter.LSeries_eulerProduct_hasProd {N : ℕ} (χ : DirichletCharacter ℂ N)\n    (hs : 1 < s.re) :\n    HasProd (fun p : Primes ↦ (1 - χ p * (p : ℂ) ^ (-s))⁻¹) (L ↗χ s) := by\n  rw [← tsum_dirichletSummand χ hs]\n  convert eulerProduct_completely_multiplicative_hasProd <| summable_dirichletSummand χ hs\n\n"}
{"name":"dirichletLSeries_eulerProduct_hasProd","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nN : Nat\nχ : DirichletCharacter Complex N\nhs : LT.lt 1 s.re\n⊢ HasProd (fun p => Inv.inv (HSub.hSub 1 (HMul.hMul (χ ↑↑p) (HPow.hPow (↑↑p) (Neg.neg s))))) (LSeries (fun n => χ ↑n) s)","decl":"@[deprecated (since := \"2024-11-14\")] alias\n  dirichletLSeries_eulerProduct_hasProd := DirichletCharacter.LSeries_eulerProduct_hasProd\n\n"}
{"name":"DirichletCharacter.LSeries_eulerProduct_tprod","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nN : Nat\nχ : DirichletCharacter Complex N\nhs : LT.lt 1 s.re\n⊢ Eq (tprod fun p => Inv.inv (HSub.hSub 1 (HMul.hMul (χ ↑↑p) (HPow.hPow (↑↑p) (Neg.neg s))))) (LSeries (fun n => χ ↑n) s)","decl":"/-- The Euler product for Dirichlet L-series, valid for `s.re > 1`.\nThis version is stated in terms of `tprod`. -/\ntheorem DirichletCharacter.LSeries_eulerProduct_tprod {N : ℕ} (χ : DirichletCharacter ℂ N)\n    (hs : 1 < s.re) :\n    ∏' p : Primes, (1 - χ p * (p : ℂ) ^ (-s))⁻¹ = L ↗χ s :=\n  (DirichletCharacter.LSeries_eulerProduct_hasProd χ hs).tprod_eq\n\n"}
{"name":"dirichlet_LSeries_eulerProduct_tprod","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nN : Nat\nχ : DirichletCharacter Complex N\nhs : LT.lt 1 s.re\n⊢ Eq (tprod fun p => Inv.inv (HSub.hSub 1 (HMul.hMul (χ ↑↑p) (HPow.hPow (↑↑p) (Neg.neg s))))) (LSeries (fun n => χ ↑n) s)","decl":"@[deprecated (since := \"2024-11-14\")] alias\n  dirichlet_LSeries_eulerProduct_tprod := DirichletCharacter.LSeries_eulerProduct_tprod\n\n"}
{"name":"DirichletCharacter.LSeries_eulerProduct","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nN : Nat\nχ : DirichletCharacter Complex N\nhs : LT.lt 1 s.re\n⊢ Filter.Tendsto (fun n => n.primesBelow.prod fun p => Inv.inv (HSub.hSub 1 (HMul.hMul (χ ↑p) (HPow.hPow (↑p) (Neg.neg s))))) Filter.atTop (nhds (LSeries (fun n => χ ↑n) s))","decl":"/-- The Euler product for Dirichlet L-series, valid for `s.re > 1`.\nThis version is stated in the form of convergence of finite partial products. -/\ntheorem DirichletCharacter.LSeries_eulerProduct {N : ℕ} (χ : DirichletCharacter ℂ N)\n    (hs : 1 < s.re) :\n    Tendsto (fun n : ℕ ↦ ∏ p ∈ primesBelow n, (1 - χ p * (p : ℂ) ^ (-s))⁻¹) atTop\n      (𝓝 (L ↗χ s)) := by\n  rw [← tsum_dirichletSummand χ hs]\n  apply eulerProduct_completely_multiplicative <| summable_dirichletSummand χ hs\n\n"}
{"name":"dirichletLSeries_eulerProduct","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nN : Nat\nχ : DirichletCharacter Complex N\nhs : LT.lt 1 s.re\n⊢ Filter.Tendsto (fun n => n.primesBelow.prod fun p => Inv.inv (HSub.hSub 1 (HMul.hMul (χ ↑p) (HPow.hPow (↑p) (Neg.neg s))))) Filter.atTop (nhds (LSeries (fun n => χ ↑n) s))","decl":"@[deprecated (since := \"2024-11-14\")] alias\n  dirichletLSeries_eulerProduct := DirichletCharacter.LSeries_eulerProduct\n\n"}
{"name":"DirichletCharacter.LSeries_eulerProduct_exp_log","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"N : Nat\nχ : DirichletCharacter Complex N\ns : Complex\nhs : LT.lt 1 s.re\n⊢ Eq (Complex.exp (tsum fun p => Neg.neg (Complex.log (HSub.hSub 1 (HMul.hMul (χ ↑↑p) (HPow.hPow (↑↑p) (Neg.neg s))))))) (LSeries (fun n => χ ↑n) s)","decl":"/-- A variant of the Euler product for Dirichlet L-series. -/\ntheorem DirichletCharacter.LSeries_eulerProduct_exp_log {N : ℕ} (χ : DirichletCharacter ℂ N)\n    {s : ℂ} (hs : 1 < s.re) :\n    exp (∑' p : Nat.Primes, -log (1 - χ p * p ^ (-s))) = L ↗χ s := by\n  let f := dirichletSummandHom χ <| ne_zero_of_one_lt_re hs\n  have h n : term ↗χ s n = f n := by\n    rcases eq_or_ne n 0 with rfl | hn\n    · simp only [term_zero, map_zero]\n    · simp only [ne_eq, hn, not_false_eq_true, term_of_ne_zero, div_eq_mul_inv,\n        dirichletSummandHom, cpow_neg, MonoidWithZeroHom.coe_mk, ZeroHom.coe_mk, f]\n  simpa only [LSeries, h]\n    using exp_tsum_primes_log_eq_tsum (f := f) <| summable_dirichletSummand χ hs\n\n"}
{"name":"ArithmeticFunction.LSeries_zeta_eulerProduct_exp_log","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n⊢ Eq (Complex.exp (tsum fun p => Neg.neg (Complex.log (HSub.hSub 1 (HPow.hPow (↑↑p) (Neg.neg s)))))) (LSeries 1 s)","decl":"/-- A variant of the Euler product for the L-series of `ζ`. -/\ntheorem ArithmeticFunction.LSeries_zeta_eulerProduct_exp_log {s : ℂ} (hs : 1 < s.re) :\n    exp (∑' p : Nat.Primes, -Complex.log (1 - p ^ (-s))) = L 1 s := by\n  convert modOne_eq_one (R := ℂ) ▸\n    DirichletCharacter.LSeries_eulerProduct_exp_log (1 : DirichletCharacter ℂ 1) hs using 7\n  rw [MulChar.one_apply <| isUnit_of_subsingleton _, one_mul]\n\n"}
{"name":"riemannZeta_eulerProduct_exp_log","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"s : Complex\nhs : LT.lt 1 s.re\n⊢ Eq (Complex.exp (tsum fun p => Neg.neg (Complex.log (HSub.hSub 1 (HPow.hPow (↑↑p) (Neg.neg s)))))) (riemannZeta s)","decl":"/-- A variant of the Euler product for the Riemann zeta function. -/\ntheorem riemannZeta_eulerProduct_exp_log {s : ℂ} (hs : 1 < s.re) :\n    exp (∑' p : Nat.Primes, -Complex.log (1 - p ^ (-s))) = riemannZeta s :=\n  LSeries_one_eq_riemannZeta hs ▸ ArithmeticFunction.LSeries_zeta_eulerProduct_exp_log hs\n\n"}
{"name":"DirichletCharacter.LSeries_changeLevel","module":"Mathlib.NumberTheory.EulerProduct.DirichletLSeries","initialProofState":"M N : Nat\ninst✝ : NeZero N\nhMN : Dvd.dvd M N\nχ : DirichletCharacter Complex M\ns : Complex\nhs : LT.lt 1 s.re\n⊢ Eq (LSeries (fun n => ((DirichletCharacter.changeLevel hMN) χ) ↑n) s) (HMul.hMul (LSeries (fun n => χ ↑n) s) (N.primeFactors.prod fun p => HSub.hSub 1 (HMul.hMul (χ ↑p) (HPow.hPow (↑p) (Neg.neg s)))))","decl":"/-- If `χ` is a Dirichlet character and its level `M` divides `N`, then we obtain the L-series\nof `χ` considered as a Dirichlet character of level `N` from the L-series of `χ` by multiplying\nwith `∏ p ∈ N.primeFactors, (1 - χ p * p ^ (-s))`. -/\nlemma DirichletCharacter.LSeries_changeLevel {M N : ℕ} [NeZero N]\n    (hMN : M ∣ N) (χ : DirichletCharacter ℂ M) {s : ℂ} (hs : 1 < s.re) :\n    LSeries ↗(changeLevel hMN χ) s =\n      LSeries ↗χ s * ∏ p ∈ N.primeFactors, (1 - χ p * p ^ (-s)) := by\n  rw [prod_eq_tprod_mulIndicator, ← DirichletCharacter.LSeries_eulerProduct_tprod _ hs,\n    ← DirichletCharacter.LSeries_eulerProduct_tprod _ hs]\n  -- convert to a form suitable for `tprod_subtype`\n  have (f : Primes → ℂ) : ∏' (p : Primes), f p = ∏' (p : ↑{p : ℕ | p.Prime}), f p := rfl\n  rw [this, tprod_subtype _ fun p : ℕ ↦ (1 - (changeLevel hMN χ) p * p ^ (-s))⁻¹,\n    this, tprod_subtype _ fun p : ℕ ↦ (1 - χ p * p ^ (-s))⁻¹, ← tprod_mul]\n  rotate_left -- deal with convergence goals first\n  · exact multipliable_subtype_iff_mulIndicator.mp\n      (DirichletCharacter.LSeries_eulerProduct_hasProd χ hs).multipliable\n  · exact multipliable_subtype_iff_mulIndicator.mp Multipliable.of_finite\n  · congr 1 with p\n    simp only [Set.mulIndicator_apply, Set.mem_setOf_eq, Finset.mem_coe, Nat.mem_primeFactors,\n      ne_eq, mul_ite, ite_mul, one_mul, mul_one]\n    by_cases h : p.Prime; swap\n    · simp only [h, false_and, if_false]\n    simp only [h, true_and, if_true]\n    by_cases hp' : p ∣ N; swap\n    · simp only [hp', false_and, ↓reduceIte, inv_inj, sub_right_inj, mul_eq_mul_right_iff,\n        cpow_eq_zero_iff, Nat.cast_eq_zero, h.ne_zero, ne_eq, neg_eq_zero, or_false]\n      have hq : IsUnit (p : ZMod N) := (ZMod.isUnit_prime_iff_not_dvd h).mpr hp'\n      simp only [hq.unit_spec ▸ DirichletCharacter.changeLevel_eq_cast_of_dvd χ hMN hq.unit,\n        ZMod.cast_natCast hMN]\n    · simp only [hp', NeZero.ne N, not_false_eq_true, and_self, ↓reduceIte]\n      have : ¬IsUnit (p : ZMod N) := by rwa [ZMod.isUnit_prime_iff_not_dvd h, not_not]\n      rw [MulChar.map_nonunit _ this, zero_mul, sub_zero, inv_one]\n      refine (inv_mul_cancel₀ ?_).symm\n      rw [sub_ne_zero, ne_comm]\n      -- Remains to show `χ p * p ^ (-s) ≠ 1`. We show its norm is strictly `< 1`.\n      apply_fun (‖·‖)\n      simp only [norm_mul, norm_one]\n      have ha : ‖χ p‖ ≤ 1 := χ.norm_le_one p\n      have hb : ‖(p : ℂ) ^ (-s)‖ ≤ 1 / 2 := norm_prime_cpow_le_one_half ⟨p, h⟩ hs\n      exact ((mul_le_mul ha hb (norm_nonneg _) zero_le_one).trans_lt (by norm_num)).ne\n"}
