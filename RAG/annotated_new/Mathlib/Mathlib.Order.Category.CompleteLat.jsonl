{"name":"CompleteLat.coe_of","module":"Mathlib.Order.Category.CompleteLat","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\n⊢ Eq (↑(CompleteLat.of α)) α","decl":"@[simp]\ntheorem coe_of (α : Type*) [CompleteLattice α] : ↥(of α) = α :=\n  rfl\n\n"}
{"name":"CompleteLat.Iso.mk_inv_toFun","module":"Mathlib.Order.Category.CompleteLat","initialProofState":"α β : CompleteLat\ne : OrderIso ↑α ↑β\na : ↑β\n⊢ Eq ((CompleteLat.Iso.mk e).inv.toFun a) (e.symm a)","decl":"/-- Constructs an isomorphism of complete lattices from an order isomorphism between them. -/\n@[simps]\ndef Iso.mk {α β : CompleteLat.{u}} (e : α ≃o β) : α ≅ β where\n  hom := (e : CompleteLatticeHom _ _) -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO, wrong?\n  inv := (e.symm : CompleteLatticeHom _ _)\n  hom_inv_id := by ext; exact e.symm_apply_apply _\n  inv_hom_id := by ext; exact e.apply_symm_apply _\n\n"}
{"name":"CompleteLat.Iso.mk_hom_toFun","module":"Mathlib.Order.Category.CompleteLat","initialProofState":"α β : CompleteLat\ne : OrderIso ↑α ↑β\na : ↑α\n⊢ Eq ((CompleteLat.Iso.mk e).hom.toFun a) (e a)","decl":"/-- Constructs an isomorphism of complete lattices from an order isomorphism between them. -/\n@[simps]\ndef Iso.mk {α β : CompleteLat.{u}} (e : α ≃o β) : α ≅ β where\n  hom := (e : CompleteLatticeHom _ _) -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO, wrong?\n  inv := (e.symm : CompleteLatticeHom _ _)\n  hom_inv_id := by ext; exact e.symm_apply_apply _\n  inv_hom_id := by ext; exact e.apply_symm_apply _\n\n"}
{"name":"CompleteLat.dual_obj","module":"Mathlib.Order.Category.CompleteLat","initialProofState":"X : CompleteLat\n⊢ Eq (CompleteLat.dual.obj X) (CompleteLat.of (OrderDual ↑X))","decl":"/-- `OrderDual` as a functor. -/\n@[simps]\ndef dual : CompleteLat ⥤ CompleteLat where\n  obj X := of Xᵒᵈ\n  map {_ _} := CompleteLatticeHom.dual\n\n"}
{"name":"CompleteLat.dual_map","module":"Mathlib.Order.Category.CompleteLat","initialProofState":"x✝¹ x✝ : CompleteLat\na : CompleteLatticeHom ↑x✝¹ ↑x✝\n⊢ Eq (CompleteLat.dual.map a) (CompleteLatticeHom.dual a)","decl":"/-- `OrderDual` as a functor. -/\n@[simps]\ndef dual : CompleteLat ⥤ CompleteLat where\n  obj X := of Xᵒᵈ\n  map {_ _} := CompleteLatticeHom.dual\n\n"}
{"name":"CompleteLat.dualEquiv_inverse","module":"Mathlib.Order.Category.CompleteLat","initialProofState":"⊢ Eq CompleteLat.dualEquiv.inverse CompleteLat.dual","decl":"/-- The equivalence between `CompleteLat` and itself induced by `OrderDual` both ways. -/\n@[simps functor inverse]\ndef dualEquiv : CompleteLat ≌ CompleteLat where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n\n"}
{"name":"CompleteLat.dualEquiv_functor","module":"Mathlib.Order.Category.CompleteLat","initialProofState":"⊢ Eq CompleteLat.dualEquiv.functor CompleteLat.dual","decl":"/-- The equivalence between `CompleteLat` and itself induced by `OrderDual` both ways. -/\n@[simps functor inverse]\ndef dualEquiv : CompleteLat ≌ CompleteLat where\n  functor := dual\n  inverse := dual\n  unitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n  counitIso := NatIso.ofComponents fun X => Iso.mk <| OrderIso.dualDual X\n\n"}
{"name":"completeLat_dual_comp_forget_to_bddLat","module":"Mathlib.Order.Category.CompleteLat","initialProofState":"⊢ Eq (CompleteLat.dual.comp (CategoryTheory.forget₂ CompleteLat BddLat)) ((CategoryTheory.forget₂ CompleteLat BddLat).comp BddLat.dual)","decl":"theorem completeLat_dual_comp_forget_to_bddLat :\n    CompleteLat.dual ⋙ forget₂ CompleteLat BddLat =\n    forget₂ CompleteLat BddLat ⋙ BddLat.dual :=\n  rfl\n"}
