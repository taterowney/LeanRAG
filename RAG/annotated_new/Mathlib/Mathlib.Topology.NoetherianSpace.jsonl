{"name":"TopologicalSpace.noetherianSpace_iff_opens","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\n⊢ Iff (TopologicalSpace.NoetherianSpace α) (∀ (s : TopologicalSpace.Opens α), IsCompact ↑s)","decl":"theorem noetherianSpace_iff_opens : NoetherianSpace α ↔ ∀ s : Opens α, IsCompact (s : Set α) := by\n  rw [NoetherianSpace, CompleteLattice.wellFoundedGT_iff_isSupFiniteCompact,\n    CompleteLattice.isSupFiniteCompact_iff_all_elements_compact]\n  exact forall_congr' Opens.isCompactElement_iff\n\n"}
{"name":"TopologicalSpace.NoetherianSpace.compactSpace","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nh : TopologicalSpace.NoetherianSpace α\n⊢ CompactSpace α","decl":"instance (priority := 100) NoetherianSpace.compactSpace [h : NoetherianSpace α] : CompactSpace α :=\n  ⟨(noetherianSpace_iff_opens α).mp h ⊤⟩\n\n"}
{"name":"TopologicalSpace.NoetherianSpace.isCompact","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace.NoetherianSpace α\ns : Set α\n⊢ IsCompact s","decl":"/-- In a Noetherian space, all sets are compact. -/\nprotected theorem NoetherianSpace.isCompact [NoetherianSpace α] (s : Set α) : IsCompact s := by\n  refine isCompact_iff_finite_subcover.2 fun U hUo hs => ?_\n  rcases ((noetherianSpace_iff_opens α).mp ‹_› ⟨⋃ i, U i, isOpen_iUnion hUo⟩).elim_finite_subcover U\n    hUo Set.Subset.rfl with ⟨t, ht⟩\n  exact ⟨t, hs.trans ht⟩\n\n"}
{"name":"Topology.IsInducing.noetherianSpace","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace.NoetherianSpace α\ni : β → α\nhi : Topology.IsInducing i\n⊢ TopologicalSpace.NoetherianSpace β","decl":"protected theorem _root_.Topology.IsInducing.noetherianSpace [NoetherianSpace α] {i : β → α}\n    (hi : IsInducing i) : NoetherianSpace β :=\n  (noetherianSpace_iff_opens _).2 fun _ => hi.isCompact_iff.2 (NoetherianSpace.isCompact _)\n\n"}
{"name":"Inducing.noetherianSpace","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace.NoetherianSpace α\ni : β → α\nhi : Topology.IsInducing i\n⊢ TopologicalSpace.NoetherianSpace β","decl":"@[deprecated (since := \"2024-10-28\")]\nalias _root_.Inducing.noetherianSpace := IsInducing.noetherianSpace\n\n"}
{"name":"TopologicalSpace.NoetherianSpace.set","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace.NoetherianSpace α\ns : Set α\n⊢ TopologicalSpace.NoetherianSpace ↑s","decl":"@[stacks 0052 \"(1)\"]\ninstance NoetherianSpace.set [NoetherianSpace α] (s : Set α) : NoetherianSpace s :=\n  IsInducing.subtypeVal.noetherianSpace\n\n"}
{"name":"TopologicalSpace.noetherianSpace_TFAE","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\n⊢ (List.cons (TopologicalSpace.NoetherianSpace α) (List.cons (WellFoundedLT (TopologicalSpace.Closeds α)) (List.cons (∀ (s : Set α), IsCompact s) (List.cons (∀ (s : TopologicalSpace.Opens α), IsCompact ↑s) List.nil)))).TFAE","decl":"open List in\ntheorem noetherianSpace_TFAE :\n    TFAE [NoetherianSpace α,\n      WellFoundedLT (Closeds α),\n      ∀ s : Set α, IsCompact s,\n      ∀ s : Opens α, IsCompact (s : Set α)] := by\n  tfae_have 1 ↔ 2 := by\n    simp_rw [isWellFounded_iff]\n    exact Opens.compl_bijective.2.wellFounded_iff (@OrderIso.compl (Set α)).lt_iff_lt.symm\n  tfae_have 1 ↔ 4 := noetherianSpace_iff_opens α\n  tfae_have 1 → 3 := @NoetherianSpace.isCompact α _\n  tfae_have 3 → 4 := fun h s => h s\n  tfae_finish\n\n"}
{"name":"TopologicalSpace.noetherianSpace_iff_isCompact","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\n⊢ Iff (TopologicalSpace.NoetherianSpace α) (∀ (s : Set α), IsCompact s)","decl":"theorem noetherianSpace_iff_isCompact : NoetherianSpace α ↔ ∀ s : Set α, IsCompact s :=\n  (noetherianSpace_TFAE α).out 0 2\n\n"}
{"name":"TopologicalSpace.instWellFoundedLTClosedsOfNoetherianSpace","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace.NoetherianSpace α\n⊢ WellFoundedLT (TopologicalSpace.Closeds α)","decl":"instance [NoetherianSpace α] : WellFoundedLT (Closeds α) :=\n  Iff.mp ((noetherianSpace_TFAE α).out 0 1) ‹_›\n\n"}
{"name":"TopologicalSpace.NoetherianSpace.wellFounded_closeds","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace.NoetherianSpace α\n⊢ WellFounded fun s t => LT.lt s t","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-10-07\")]\ntheorem NoetherianSpace.wellFounded_closeds [NoetherianSpace α] :\n    WellFounded fun s t : Closeds α => s < t :=\n  wellFounded_lt\n\n"}
{"name":"TopologicalSpace.instNoetherianSpaceCofiniteTopology","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_3\n⊢ TopologicalSpace.NoetherianSpace (CofiniteTopology α)","decl":"instance {α} : NoetherianSpace (CofiniteTopology α) := by\n  simp only [noetherianSpace_iff_isCompact, isCompact_iff_ultrafilter_le_nhds,\n    CofiniteTopology.nhds_eq, Ultrafilter.le_sup_iff, Filter.le_principal_iff]\n  intro s f hs\n  rcases f.le_cofinite_or_eq_pure with (hf | ⟨a, rfl⟩)\n  · rcases Filter.nonempty_of_mem hs with ⟨a, ha⟩\n    exact ⟨a, ha, Or.inr hf⟩\n  · exact ⟨a, hs, Or.inl le_rfl⟩\n\n"}
{"name":"TopologicalSpace.noetherianSpace_of_surjective","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace.NoetherianSpace α\nf : α → β\nhf : Continuous f\nhf' : Function.Surjective f\n⊢ TopologicalSpace.NoetherianSpace β","decl":"theorem noetherianSpace_of_surjective [NoetherianSpace α] (f : α → β) (hf : Continuous f)\n    (hf' : Function.Surjective f) : NoetherianSpace β :=\n  noetherianSpace_iff_isCompact.2 <| (Set.image_surjective.mpr hf').forall.2 fun s =>\n    (NoetherianSpace.isCompact s).image hf\n\n"}
{"name":"TopologicalSpace.noetherianSpace_iff_of_homeomorph","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace β\nf : Homeomorph α β\n⊢ Iff (TopologicalSpace.NoetherianSpace α) (TopologicalSpace.NoetherianSpace β)","decl":"theorem noetherianSpace_iff_of_homeomorph (f : α ≃ₜ β) : NoetherianSpace α ↔ NoetherianSpace β :=\n  ⟨fun _ => noetherianSpace_of_surjective f f.continuous f.surjective,\n    fun _ => noetherianSpace_of_surjective f.symm f.symm.continuous f.symm.surjective⟩\n\n"}
{"name":"TopologicalSpace.NoetherianSpace.range","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace β\ninst✝ : TopologicalSpace.NoetherianSpace α\nf : α → β\nhf : Continuous f\n⊢ TopologicalSpace.NoetherianSpace ↑(Set.range f)","decl":"theorem NoetherianSpace.range [NoetherianSpace α] (f : α → β) (hf : Continuous f) :\n    NoetherianSpace (Set.range f) :=\n  noetherianSpace_of_surjective (Set.rangeFactorization f) (hf.subtype_mk _)\n    Set.surjective_onto_range\n\n"}
{"name":"TopologicalSpace.noetherianSpace_set_iff","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\ns : Set α\n⊢ Iff (TopologicalSpace.NoetherianSpace ↑s) (∀ (t : Set α), HasSubset.Subset t s → IsCompact t)","decl":"theorem noetherianSpace_set_iff (s : Set α) :\n    NoetherianSpace s ↔ ∀ t, t ⊆ s → IsCompact t := by\n  simp only [noetherianSpace_iff_isCompact, IsEmbedding.subtypeVal.isCompact_iff,\n    Subtype.forall_set_subtype]\n\n"}
{"name":"TopologicalSpace.noetherian_univ_iff","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\n⊢ Iff (TopologicalSpace.NoetherianSpace ↑Set.univ) (TopologicalSpace.NoetherianSpace α)","decl":"@[simp]\ntheorem noetherian_univ_iff : NoetherianSpace (Set.univ : Set α) ↔ NoetherianSpace α :=\n  noetherianSpace_iff_of_homeomorph (Homeomorph.Set.univ α)\n\n"}
{"name":"TopologicalSpace.NoetherianSpace.iUnion","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\nι : Type u_3\nf : ι → Set α\ninst✝ : Finite ι\nhf : ∀ (i : ι), TopologicalSpace.NoetherianSpace ↑(f i)\n⊢ TopologicalSpace.NoetherianSpace ↑(Set.iUnion fun i => f i)","decl":"theorem NoetherianSpace.iUnion {ι : Type*} (f : ι → Set α) [Finite ι]\n    [hf : ∀ i, NoetherianSpace (f i)] : NoetherianSpace (⋃ i, f i) := by\n  simp_rw [noetherianSpace_set_iff] at hf ⊢\n  intro t ht\n  rw [← Set.inter_eq_left.mpr ht, Set.inter_iUnion]\n  exact isCompact_iUnion fun i => hf i _ Set.inter_subset_right\n\n-- This is not an instance since it makes a loop with `t2_space_discrete`.\n"}
{"name":"TopologicalSpace.NoetherianSpace.discrete","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace.NoetherianSpace α\ninst✝ : T2Space α\n⊢ DiscreteTopology α","decl":"theorem NoetherianSpace.discrete [NoetherianSpace α] [T2Space α] : DiscreteTopology α :=\n  ⟨eq_bot_iff.mpr fun _ _ => isClosed_compl_iff.mp (NoetherianSpace.isCompact _).isClosed⟩\n\n"}
{"name":"TopologicalSpace.NoetherianSpace.finite","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : TopologicalSpace.NoetherianSpace α\ninst✝ : T2Space α\n⊢ Finite α","decl":"/-- Spaces that are both Noetherian and Hausdorff are finite. -/\ntheorem NoetherianSpace.finite [NoetherianSpace α] [T2Space α] : Finite α :=\n  Finite.of_finite_univ (NoetherianSpace.isCompact Set.univ).finite_of_discrete\n\n"}
{"name":"TopologicalSpace.Finite.to_noetherianSpace","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : Finite α\n⊢ TopologicalSpace.NoetherianSpace α","decl":"instance (priority := 100) Finite.to_noetherianSpace [Finite α] : NoetherianSpace α :=\n  ⟨Finite.wellFounded_of_trans_of_irrefl _⟩\n\n"}
{"name":"TopologicalSpace.NoetherianSpace.exists_finite_set_closeds_irreducible","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace.NoetherianSpace α\ns : TopologicalSpace.Closeds α\n⊢ Exists fun S => And S.Finite (And (∀ (t : TopologicalSpace.Closeds α), Membership.mem S t → IsIrreducible ↑t) (Eq s (SupSet.sSup S)))","decl":"/-- In a Noetherian space, every closed set is a finite union of irreducible closed sets. -/\ntheorem NoetherianSpace.exists_finite_set_closeds_irreducible [NoetherianSpace α] (s : Closeds α) :\n    ∃ S : Set (Closeds α), S.Finite ∧ (∀ t ∈ S, IsIrreducible (t : Set α)) ∧ s = sSup S := by\n  apply wellFounded_lt.induction s; clear s\n  intro s H\n  rcases eq_or_ne s ⊥ with rfl | h₀\n  · use ∅; simp\n  · by_cases h₁ : IsPreirreducible (s : Set α)\n    · replace h₁ : IsIrreducible (s : Set α) := ⟨Closeds.coe_nonempty.2 h₀, h₁⟩\n      use {s}; simp [h₁]\n    · simp only [isPreirreducible_iff_isClosed_union_isClosed, not_forall, not_or] at h₁\n      obtain ⟨z₁, z₂, hz₁, hz₂, h, hz₁', hz₂'⟩ := h₁\n      lift z₁ to Closeds α using hz₁\n      lift z₂ to Closeds α using hz₂\n      rcases H (s ⊓ z₁) (inf_lt_left.2 hz₁') with ⟨S₁, hSf₁, hS₁, h₁⟩\n      rcases H (s ⊓ z₂) (inf_lt_left.2 hz₂') with ⟨S₂, hSf₂, hS₂, h₂⟩\n      refine ⟨S₁ ∪ S₂, hSf₁.union hSf₂, Set.union_subset_iff.2 ⟨hS₁, hS₂⟩, ?_⟩\n      rwa [sSup_union, ← h₁, ← h₂, ← inf_sup_left, left_eq_inf]\n\n"}
{"name":"TopologicalSpace.NoetherianSpace.exists_finite_set_isClosed_irreducible","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace.NoetherianSpace α\ns : Set α\nhs : IsClosed s\n⊢ Exists fun S => And S.Finite (And (∀ (t : Set α), Membership.mem S t → IsClosed t) (And (∀ (t : Set α), Membership.mem S t → IsIrreducible t) (Eq s S.sUnion)))","decl":"/-- In a Noetherian space, every closed set is a finite union of irreducible closed sets. -/\ntheorem NoetherianSpace.exists_finite_set_isClosed_irreducible [NoetherianSpace α]\n    {s : Set α} (hs : IsClosed s) : ∃ S : Set (Set α), S.Finite ∧\n      (∀ t ∈ S, IsClosed t) ∧ (∀ t ∈ S, IsIrreducible t) ∧ s = ⋃₀ S := by\n  lift s to Closeds α using hs\n  rcases NoetherianSpace.exists_finite_set_closeds_irreducible s with ⟨S, hSf, hS, rfl⟩\n  refine ⟨(↑) '' S, hSf.image _, Set.forall_mem_image.2 fun S _ ↦ S.2, Set.forall_mem_image.2 hS,\n    ?_⟩\n  lift S to Finset (Closeds α) using hSf\n  simp [← Finset.sup_id_eq_sSup, Closeds.coe_finset_sup]\n\n"}
{"name":"TopologicalSpace.NoetherianSpace.exists_finset_irreducible","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace.NoetherianSpace α\ns : TopologicalSpace.Closeds α\n⊢ Exists fun S => And (∀ (k : Subtype fun x => Membership.mem S x), IsIrreducible ↑↑k) (Eq s (S.sup id))","decl":"/-- In a Noetherian space, every closed set is a finite union of irreducible closed sets. -/\ntheorem NoetherianSpace.exists_finset_irreducible [NoetherianSpace α] (s : Closeds α) :\n    ∃ S : Finset (Closeds α), (∀ k : S, IsIrreducible (k : Set α)) ∧ s = S.sup id := by\n  simpa [Set.exists_finite_iff_finset, Finset.sup_id_eq_sSup]\n    using NoetherianSpace.exists_finite_set_closeds_irreducible s\n\n"}
{"name":"TopologicalSpace.NoetherianSpace.finite_irreducibleComponents","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace.NoetherianSpace α\n⊢ (irreducibleComponents α).Finite","decl":"@[stacks 0052 \"(2)\"]\ntheorem NoetherianSpace.finite_irreducibleComponents [NoetherianSpace α] :\n    (irreducibleComponents α).Finite := by\n  obtain ⟨S : Set (Set α), hSf, hSc, hSi, hSU⟩ :=\n    NoetherianSpace.exists_finite_set_isClosed_irreducible isClosed_univ (α := α)\n  refine hSf.subset fun s hs => ?_\n  lift S to Finset (Set α) using hSf\n  rcases isIrreducible_iff_sUnion_isClosed.1 hs.1 S hSc (hSU ▸ Set.subset_univ _) with ⟨t, htS, ht⟩\n  rwa [ht.antisymm (hs.2 (hSi _ htS) ht)]\n\n"}
{"name":"TopologicalSpace.NoetherianSpace.exists_open_ne_empty_le_irreducibleComponent","module":"Mathlib.Topology.NoetherianSpace","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : TopologicalSpace.NoetherianSpace α\nZ : Set α\nH : Membership.mem (irreducibleComponents α) Z\n⊢ Exists fun o => And (IsOpen o) (And (Ne o EmptyCollection.emptyCollection) (LE.le o Z))","decl":"@[stacks 0052 \"(3)\"]\ntheorem NoetherianSpace.exists_open_ne_empty_le_irreducibleComponent [NoetherianSpace α]\n    (Z : Set α) (H : Z ∈ irreducibleComponents α) :\n    ∃ o : Set α, IsOpen o ∧ o ≠ ∅ ∧ o ≤ Z := by\n  classical\n\n  let ι : Set (Set α) := irreducibleComponents α \\ {Z}\n  have hι : ι.Finite := NoetherianSpace.finite_irreducibleComponents.subset Set.diff_subset\n  have hι' : Finite ι := by rwa [Set.finite_coe_iff]\n\n  let U := Z \\ ⋃ (x : ι), x\n  have hU0 : U ≠ ∅ := fun r ↦ by\n    obtain ⟨Z', hZ'⟩ := isIrreducible_iff_sUnion_isClosed.mp H.1 hι.toFinset\n      (fun z hz ↦ by\n        simp only [Set.Finite.mem_toFinset, Set.mem_diff, Set.mem_singleton_iff] at hz\n        exact isClosed_of_mem_irreducibleComponents _ hz.1)\n      (by\n        rw [Set.Finite.coe_toFinset, Set.sUnion_eq_iUnion]\n        rw [Set.diff_eq_empty] at r\n        exact r)\n    simp only [Set.Finite.mem_toFinset, Set.mem_diff, Set.mem_singleton_iff] at hZ'\n    exact hZ'.1.2 <| le_antisymm (H.2 hZ'.1.1.1 hZ'.2) hZ'.2\n\n  have hU1 : U = (⋃ (x : ι), x.1) ᶜ := by\n    rw [Set.compl_eq_univ_diff]\n    refine le_antisymm (Set.diff_subset_diff le_top <| subset_refl _) ?_\n    rw [← Set.compl_eq_univ_diff]\n    refine Set.compl_subset_iff_union.mpr (le_antisymm le_top ?_)\n    rw [Set.union_comm, ← Set.sUnion_eq_iUnion, ← Set.sUnion_insert]\n    rintro a -\n    by_cases h : a ∈ U\n    · exact ⟨U, Set.mem_insert _ _, h⟩\n    · rw [Set.mem_diff, Decidable.not_and_iff_or_not_not, not_not, Set.mem_iUnion] at h\n      rcases h with (h|⟨i, hi⟩)\n      · refine ⟨irreducibleComponent a, Or.inr ?_, mem_irreducibleComponent⟩\n        simp only [ι, Set.mem_diff, Set.mem_singleton_iff]\n        refine ⟨irreducibleComponent_mem_irreducibleComponents _, ?_⟩\n        rintro rfl\n        exact h mem_irreducibleComponent\n      · exact ⟨i, Or.inr i.2, hi⟩\n\n  refine ⟨U, hU1 ▸ isOpen_compl_iff.mpr ?_, hU0, sdiff_le⟩\n  exact isClosed_iUnion_of_finite fun i ↦ isClosed_of_mem_irreducibleComponents i.1 i.2.1\n\n"}
