{"name":"List.forall₂_iff","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\na✝¹ : List α\na✝ : List β\n⊢ Iff (List.Forall₂ R a✝¹ a✝) (Or (And (Eq a✝¹ List.nil) (Eq a✝ List.nil)) (Exists fun a => Exists fun b => Exists fun l₁ => Exists fun l₂ => And (R a b) (And (List.Forall₂ R l₁ l₂) (And (Eq a✝¹ (List.cons a l₁)) (Eq a✝ (List.cons b l₂))))))","decl":"mk_iff_of_inductive_prop List.Forall₂ List.forall₂_iff\n\n"}
{"name":"List.Forall₂.imp","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR S : α → β → Prop\nH : ∀ (a : α) (b : β), R a b → S a b\nl₁ : List α\nl₂ : List β\nh : List.Forall₂ R l₁ l₂\n⊢ List.Forall₂ S l₁ l₂","decl":"theorem Forall₂.imp (H : ∀ a b, R a b → S a b) {l₁ l₂} (h : Forall₂ R l₁ l₂) : Forall₂ S l₁ l₂ := by\n  induction h <;> constructor <;> solve_by_elim\n\n"}
{"name":"List.Forall₂.mp","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR S Q : α → β → Prop\nh : ∀ (a : α) (b : β), Q a b → R a b → S a b\nl₁ : List α\nl₂ : List β\na✝¹ : List.Forall₂ Q l₁ l₂\na✝ : List.Forall₂ R l₁ l₂\n⊢ List.Forall₂ S l₁ l₂","decl":"theorem Forall₂.mp {Q : α → β → Prop} (h : ∀ a b, Q a b → R a b → S a b) :\n    ∀ {l₁ l₂}, Forall₂ Q l₁ l₂ → Forall₂ R l₁ l₂ → Forall₂ S l₁ l₂\n  | [], [], Forall₂.nil, Forall₂.nil => Forall₂.nil\n  | a :: _, b :: _, Forall₂.cons hr hrs, Forall₂.cons hq hqs =>\n    Forall₂.cons (h a b hr hq) (Forall₂.mp h hrs hqs)\n\n"}
{"name":"List.Forall₂.flip","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\na : List α\nb : List β\na✝ : List.Forall₂ (flip R) b a\n⊢ List.Forall₂ R a b","decl":"theorem Forall₂.flip : ∀ {a b}, Forall₂ (flip R) b a → Forall₂ R a b\n  | _, _, Forall₂.nil => Forall₂.nil\n  | _ :: _, _ :: _, Forall₂.cons h₁ h₂ => Forall₂.cons h₁ h₂.flip\n\n"}
{"name":"List.forall₂_same","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nRₐ : α → α → Prop\nl : List α\n⊢ Iff (List.Forall₂ Rₐ l l) (∀ (x : α), Membership.mem l x → Rₐ x x)","decl":"@[simp]\ntheorem forall₂_same : ∀ {l : List α}, Forall₂ Rₐ l l ↔ ∀ x ∈ l, Rₐ x x\n  | [] => by simp\n  | a :: l => by simp [@forall₂_same l]\n\n"}
{"name":"List.forall₂_refl","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nRₐ : α → α → Prop\ninst✝ : IsRefl α Rₐ\nl : List α\n⊢ List.Forall₂ Rₐ l l","decl":"theorem forall₂_refl [IsRefl α Rₐ] (l : List α) : Forall₂ Rₐ l l :=\n  forall₂_same.2 fun _ _ => refl _\n\n"}
{"name":"List.forall₂_eq_eq_eq","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\n⊢ Eq (List.Forall₂ fun x1 x2 => Eq x1 x2) Eq","decl":"@[simp]\ntheorem forall₂_eq_eq_eq : Forall₂ ((· = ·) : α → α → Prop) = Eq := by\n  funext a b; apply propext\n  constructor\n  · intro h\n    induction h\n    · rfl\n    simp only [*]\n  · rintro rfl\n    exact forall₂_refl _\n\n"}
{"name":"List.forall₂_nil_left_iff","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nl : List β\n⊢ Iff (List.Forall₂ R List.nil l) (Eq l List.nil)","decl":"@[simp]\ntheorem forall₂_nil_left_iff {l} : Forall₂ R nil l ↔ l = nil :=\n  ⟨fun H => by cases H; rfl, by rintro rfl; exact Forall₂.nil⟩\n\n"}
{"name":"List.forall₂_nil_right_iff","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nl : List α\n⊢ Iff (List.Forall₂ R l List.nil) (Eq l List.nil)","decl":"@[simp]\ntheorem forall₂_nil_right_iff {l} : Forall₂ R l nil ↔ l = nil :=\n  ⟨fun H => by cases H; rfl, by rintro rfl; exact Forall₂.nil⟩\n\n"}
{"name":"List.forall₂_cons_left_iff","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\na : α\nl : List α\nu : List β\n⊢ Iff (List.Forall₂ R (List.cons a l) u) (Exists fun b => Exists fun u' => And (R a b) (And (List.Forall₂ R l u') (Eq u (List.cons b u'))))","decl":"theorem forall₂_cons_left_iff {a l u} :\n    Forall₂ R (a :: l) u ↔ ∃ b u', R a b ∧ Forall₂ R l u' ∧ u = b :: u' :=\n  Iff.intro\n    (fun h =>\n      match u, h with\n      | b :: u', Forall₂.cons h₁ h₂ => ⟨b, u', h₁, h₂, rfl⟩)\n    fun h =>\n    match u, h with\n    | _, ⟨_, _, h₁, h₂, rfl⟩ => Forall₂.cons h₁ h₂\n\n"}
{"name":"List.forall₂_cons_right_iff","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nb : β\nl : List β\nu : List α\n⊢ Iff (List.Forall₂ R u (List.cons b l)) (Exists fun a => Exists fun u' => And (R a b) (And (List.Forall₂ R u' l) (Eq u (List.cons a u'))))","decl":"theorem forall₂_cons_right_iff {b l u} :\n    Forall₂ R u (b :: l) ↔ ∃ a u', R a b ∧ Forall₂ R u' l ∧ u = a :: u' :=\n  Iff.intro\n    (fun h =>\n      match u, h with\n      | b :: u', Forall₂.cons h₁ h₂ => ⟨b, u', h₁, h₂, rfl⟩)\n    fun h =>\n    match u, h with\n    | _, ⟨_, _, h₁, h₂, rfl⟩ => Forall₂.cons h₁ h₂\n\n"}
{"name":"List.forall₂_and_left","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\np : α → Prop\nl : List α\nu : List β\n⊢ Iff (List.Forall₂ (fun a b => And (p a) (R a b)) l u) (And (∀ (a : α), Membership.mem l a → p a) (List.Forall₂ R l u))","decl":"theorem forall₂_and_left {p : α → Prop} :\n    ∀ l u, Forall₂ (fun a b => p a ∧ R a b) l u ↔ (∀ a ∈ l, p a) ∧ Forall₂ R l u\n  | [], u => by\n    simp only [forall₂_nil_left_iff, forall_prop_of_false (not_mem_nil _), imp_true_iff, true_and]\n  | a :: l, u => by\n    simp only [forall₂_and_left l, forall₂_cons_left_iff, forall_mem_cons, and_assoc,\n      @and_comm _ (p a), @and_left_comm _ (p a), exists_and_left]\n    simp only [and_comm, and_assoc, and_left_comm, ← exists_and_right]\n\n"}
{"name":"List.forall₂_map_left_iff","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nR : α → β → Prop\nf : γ → α\nl : List γ\nu : List β\n⊢ Iff (List.Forall₂ R (List.map f l) u) (List.Forall₂ (fun c b => R (f c) b) l u)","decl":"@[simp]\ntheorem forall₂_map_left_iff {f : γ → α} :\n    ∀ {l u}, Forall₂ R (map f l) u ↔ Forall₂ (fun c b => R (f c) b) l u\n  | [], _ => by simp only [map, forall₂_nil_left_iff]\n  | a :: l, _ => by simp only [map, forall₂_cons_left_iff, forall₂_map_left_iff]\n\n"}
{"name":"List.forall₂_map_right_iff","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nR : α → β → Prop\nf : γ → β\nl : List α\nu : List γ\n⊢ Iff (List.Forall₂ R l (List.map f u)) (List.Forall₂ (fun a c => R a (f c)) l u)","decl":"@[simp]\ntheorem forall₂_map_right_iff {f : γ → β} :\n    ∀ {l u}, Forall₂ R l (map f u) ↔ Forall₂ (fun a c => R a (f c)) l u\n  | _, [] => by simp only [map, forall₂_nil_right_iff]\n  | _, b :: u => by simp only [map, forall₂_cons_right_iff, forall₂_map_right_iff]\n\n"}
{"name":"List.left_unique_forall₂'","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nhr : Relator.LeftUnique R\na b : List α\nc : List β\na✝¹ : List.Forall₂ R a c\na✝ : List.Forall₂ R b c\n⊢ Eq a b","decl":"theorem left_unique_forall₂' (hr : LeftUnique R) : ∀ {a b c}, Forall₂ R a c → Forall₂ R b c → a = b\n  | _, _, _, Forall₂.nil, Forall₂.nil => rfl\n  | _, _, _, Forall₂.cons ha₀ h₀, Forall₂.cons ha₁ h₁ =>\n    hr ha₀ ha₁ ▸ left_unique_forall₂' hr h₀ h₁ ▸ rfl\n\n"}
{"name":"Relator.LeftUnique.forall₂","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nhr : Relator.LeftUnique R\n⊢ Relator.LeftUnique (List.Forall₂ R)","decl":"theorem _root_.Relator.LeftUnique.forall₂ (hr : LeftUnique R) : LeftUnique (Forall₂ R) :=\n  @left_unique_forall₂' _ _ _ hr\n\n"}
{"name":"List.right_unique_forall₂'","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nhr : Relator.RightUnique R\na : List α\nb c : List β\na✝¹ : List.Forall₂ R a b\na✝ : List.Forall₂ R a c\n⊢ Eq b c","decl":"theorem right_unique_forall₂' (hr : RightUnique R) :\n    ∀ {a b c}, Forall₂ R a b → Forall₂ R a c → b = c\n  | _, _, _, Forall₂.nil, Forall₂.nil => rfl\n  | _, _, _, Forall₂.cons ha₀ h₀, Forall₂.cons ha₁ h₁ =>\n    hr ha₀ ha₁ ▸ right_unique_forall₂' hr h₀ h₁ ▸ rfl\n\n"}
{"name":"Relator.RightUnique.forall₂","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nhr : Relator.RightUnique R\n⊢ Relator.RightUnique (List.Forall₂ R)","decl":"theorem _root_.Relator.RightUnique.forall₂ (hr : RightUnique R) : RightUnique (Forall₂ R) :=\n  @right_unique_forall₂' _ _ _ hr\n\n"}
{"name":"Relator.BiUnique.forall₂","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nhr : Relator.BiUnique R\n⊢ Relator.BiUnique (List.Forall₂ R)","decl":"theorem _root_.Relator.BiUnique.forall₂ (hr : BiUnique R) : BiUnique (Forall₂ R) :=\n  ⟨hr.left.forall₂, hr.right.forall₂⟩\n\n"}
{"name":"List.Forall₂.length_eq","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nl₁ : List α\nl₂ : List β\na✝ : List.Forall₂ R l₁ l₂\n⊢ Eq l₁.length l₂.length","decl":"theorem Forall₂.length_eq : ∀ {l₁ l₂}, Forall₂ R l₁ l₂ → length l₁ = length l₂\n  | _, _, Forall₂.nil => rfl\n  | _, _, Forall₂.cons _ h₂ => congr_arg succ (Forall₂.length_eq h₂)\n\n"}
{"name":"List.Forall₂.get","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nx : List α\ny : List β\na✝ : List.Forall₂ R x y\ni : Nat\nhx : LT.lt i x.length\nhy : LT.lt i y.length\n⊢ R (x.get ⟨i, hx⟩) (y.get ⟨i, hy⟩)","decl":"theorem Forall₂.get :\n    ∀ {x : List α} {y : List β}, Forall₂ R x y →\n      ∀ ⦃i : ℕ⦄ (hx : i < x.length) (hy : i < y.length), R (x.get ⟨i, hx⟩) (y.get ⟨i, hy⟩)\n  | _, _, Forall₂.cons ha _, 0, _, _ => ha\n  | _, _, Forall₂.cons _ hl, succ _, _, _ => hl.get _ _\n\n"}
{"name":"List.forall₂_of_length_eq_of_get","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nx : List α\ny : List β\na✝¹ : Eq x.length y.length\na✝ : ∀ (i : Nat) (h₁ : LT.lt i x.length) (h₂ : LT.lt i y.length), R (x.get ⟨i, h₁⟩) (y.get ⟨i, h₂⟩)\n⊢ List.Forall₂ R x y","decl":"theorem forall₂_of_length_eq_of_get :\n    ∀ {x : List α} {y : List β},\n      x.length = y.length → (∀ i h₁ h₂, R (x.get ⟨i, h₁⟩) (y.get ⟨i, h₂⟩)) → Forall₂ R x y\n  | [], [], _, _ => Forall₂.nil\n  | _ :: _, _ :: _, hl, h =>\n    Forall₂.cons (h 0 (Nat.zero_lt_succ _) (Nat.zero_lt_succ _))\n      (forall₂_of_length_eq_of_get (succ.inj hl) fun i h₁ h₂ =>\n        h i.succ (succ_lt_succ h₁) (succ_lt_succ h₂))\n\n"}
{"name":"List.forall₂_iff_get","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nl₁ : List α\nl₂ : List β\n⊢ Iff (List.Forall₂ R l₁ l₂) (And (Eq l₁.length l₂.length) (∀ (i : Nat) (h₁ : LT.lt i l₁.length) (h₂ : LT.lt i l₂.length), R (l₁.get ⟨i, h₁⟩) (l₂.get ⟨i, h₂⟩)))","decl":"theorem forall₂_iff_get {l₁ : List α} {l₂ : List β} :\n    Forall₂ R l₁ l₂ ↔ l₁.length = l₂.length ∧ ∀ i h₁ h₂, R (l₁.get ⟨i, h₁⟩) (l₂.get ⟨i, h₂⟩) :=\n  ⟨fun h => ⟨h.length_eq, h.get⟩, fun h => forall₂_of_length_eq_of_get h.1 h.2⟩\n\n"}
{"name":"List.forall₂_zip","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nl₁ : List α\nl₂ : List β\na✝¹ : List.Forall₂ R l₁ l₂\na : α\nb : β\na✝ : Membership.mem (l₁.zip l₂) { fst := a, snd := b }\n⊢ R a b","decl":"theorem forall₂_zip : ∀ {l₁ l₂}, Forall₂ R l₁ l₂ → ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b\n  | _, _, Forall₂.cons h₁ h₂, x, y, hx => by\n    rw [zip, zipWith, mem_cons] at hx\n    match hx with\n    | Or.inl rfl => exact h₁\n    | Or.inr h₃ => exact forall₂_zip h₂ h₃\n\n"}
{"name":"List.forall₂_iff_zip","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nl₁ : List α\nl₂ : List β\n⊢ Iff (List.Forall₂ R l₁ l₂) (And (Eq l₁.length l₂.length) (∀ {a : α} {b : β}, Membership.mem (l₁.zip l₂) { fst := a, snd := b } → R a b))","decl":"theorem forall₂_iff_zip {l₁ l₂} :\n    Forall₂ R l₁ l₂ ↔ length l₁ = length l₂ ∧ ∀ {a b}, (a, b) ∈ zip l₁ l₂ → R a b :=\n  ⟨fun h => ⟨Forall₂.length_eq h, @forall₂_zip _ _ _ _ _ h⟩, fun h => by\n    cases' h with h₁ h₂\n    induction' l₁ with a l₁ IH generalizing l₂\n    · cases length_eq_zero.1 h₁.symm\n      constructor\n    · cases' l₂ with b l₂\n      · simp at h₁\n      · simp only [length_cons, succ.injEq] at h₁\n        exact Forall₂.cons (h₂ <| by simp [zip])\n          (IH h₁ fun h => h₂ <| by\n            simp only [zip, zipWith, find?, mem_cons, Prod.mk.injEq]; right\n            simpa [zip] using h)⟩\n\n"}
{"name":"List.forall₂_take","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nn : Nat\nl₁ : List α\nl₂ : List β\na✝ : List.Forall₂ R l₁ l₂\n⊢ List.Forall₂ R (List.take n l₁) (List.take n l₂)","decl":"theorem forall₂_take : ∀ (n) {l₁ l₂}, Forall₂ R l₁ l₂ → Forall₂ R (take n l₁) (take n l₂)\n  | 0, _, _, _ => by simp only [Forall₂.nil, take]\n  | _ + 1, _, _, Forall₂.nil => by simp only [Forall₂.nil, take]\n  | n + 1, _, _, Forall₂.cons h₁ h₂ => by simp [And.intro h₁ h₂, forall₂_take n]\n\n"}
{"name":"List.forall₂_drop","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nn : Nat\nl₁ : List α\nl₂ : List β\na✝ : List.Forall₂ R l₁ l₂\n⊢ List.Forall₂ R (List.drop n l₁) (List.drop n l₂)","decl":"theorem forall₂_drop : ∀ (n) {l₁ l₂}, Forall₂ R l₁ l₂ → Forall₂ R (drop n l₁) (drop n l₂)\n  | 0, _, _, h => by simp only [drop, h]\n  | _ + 1, _, _, Forall₂.nil => by simp only [Forall₂.nil, drop]\n  | n + 1, _, _, Forall₂.cons h₁ h₂ => by simp [And.intro h₁ h₂, forall₂_drop n]\n\n"}
{"name":"List.forall₂_take_append","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nl : List α\nl₁ l₂ : List β\nh : List.Forall₂ R l (HAppend.hAppend l₁ l₂)\n⊢ List.Forall₂ R (List.take l₁.length l) l₁","decl":"theorem forall₂_take_append (l : List α) (l₁ : List β) (l₂ : List β) (h : Forall₂ R l (l₁ ++ l₂)) :\n    Forall₂ R (List.take (length l₁) l) l₁ := by\n  have h' : Forall₂ R (take (length l₁) l) (take (length l₁) (l₁ ++ l₂)) :=\n    forall₂_take (length l₁) h\n  rwa [take_left] at h'\n\n"}
{"name":"List.forall₂_drop_append","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nl : List α\nl₁ l₂ : List β\nh : List.Forall₂ R l (HAppend.hAppend l₁ l₂)\n⊢ List.Forall₂ R (List.drop l₁.length l) l₂","decl":"theorem forall₂_drop_append (l : List α) (l₁ : List β) (l₂ : List β) (h : Forall₂ R l (l₁ ++ l₂)) :\n    Forall₂ R (List.drop (length l₁) l) l₂ := by\n  have h' : Forall₂ R (drop (length l₁) l) (drop (length l₁) (l₁ ++ l₂)) :=\n    forall₂_drop (length l₁) h\n  rwa [drop_left] at h'\n\n"}
{"name":"List.rel_mem","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nhr : Relator.BiUnique R\n⊢ Relator.LiftFun R (Relator.LiftFun (List.Forall₂ R) Iff) (fun x1 x2 => Membership.mem x2 x1) fun x1 x2 => Membership.mem x2 x1","decl":"theorem rel_mem (hr : BiUnique R) : (R ⇒ Forall₂ R ⇒ Iff) (· ∈ ·) (· ∈ ·)\n  | a, b, _, [], [], Forall₂.nil => by simp only [not_mem_nil]\n  | a, b, h, a' :: as, b' :: bs, Forall₂.cons h₁ h₂ => by\n    simp only [mem_cons]\n    exact rel_or (rel_eq hr h h₁) (rel_mem hr h h₂)\n\n"}
{"name":"List.rel_map","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nR : α → β → Prop\nP : γ → δ → Prop\n⊢ Relator.LiftFun (Relator.LiftFun R P) (Relator.LiftFun (List.Forall₂ R) (List.Forall₂ P)) List.map List.map","decl":"theorem rel_map : ((R ⇒ P) ⇒ Forall₂ R ⇒ Forall₂ P) map map\n  | _, _, _, [], [], Forall₂.nil => Forall₂.nil\n  | _, _, h, _ :: _, _ :: _, Forall₂.cons h₁ h₂ => Forall₂.cons (h h₁) (rel_map (@h) h₂)\n\n"}
{"name":"List.rel_append","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\n⊢ Relator.LiftFun (List.Forall₂ R) (Relator.LiftFun (List.Forall₂ R) (List.Forall₂ R)) (fun x1 x2 => HAppend.hAppend x1 x2) fun x1 x2 => HAppend.hAppend x1 x2","decl":"theorem rel_append : (Forall₂ R ⇒ Forall₂ R ⇒ Forall₂ R) (· ++ ·) (· ++ ·)\n  | [], [], _, _, _, hl => hl\n  | _, _, Forall₂.cons h₁ h₂, _, _, hl => Forall₂.cons h₁ (rel_append h₂ hl)\n\n"}
{"name":"List.rel_reverse","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\n⊢ Relator.LiftFun (List.Forall₂ R) (List.Forall₂ R) List.reverse List.reverse","decl":"theorem rel_reverse : (Forall₂ R ⇒ Forall₂ R) reverse reverse\n  | [], [], Forall₂.nil => Forall₂.nil\n  | _, _, Forall₂.cons h₁ h₂ => by\n    simp only [reverse_cons]\n    exact rel_append (rel_reverse h₂) (Forall₂.cons h₁ Forall₂.nil)\n\n"}
{"name":"List.forall₂_reverse_iff","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nl₁ : List α\nl₂ : List β\n⊢ Iff (List.Forall₂ R l₁.reverse l₂.reverse) (List.Forall₂ R l₁ l₂)","decl":"@[simp]\ntheorem forall₂_reverse_iff {l₁ l₂} : Forall₂ R (reverse l₁) (reverse l₂) ↔ Forall₂ R l₁ l₂ :=\n  Iff.intro\n    (fun h => by\n      rw [← reverse_reverse l₁, ← reverse_reverse l₂]\n      exact rel_reverse h)\n    fun h => rel_reverse h\n\n"}
{"name":"List.rel_flatten","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\n⊢ Relator.LiftFun (List.Forall₂ (List.Forall₂ R)) (List.Forall₂ R) List.flatten List.flatten","decl":"theorem rel_flatten : (Forall₂ (Forall₂ R) ⇒ Forall₂ R) flatten flatten\n  | [], [], Forall₂.nil => Forall₂.nil\n  | _, _, Forall₂.cons h₁ h₂ => rel_append h₁ (rel_flatten h₂)\n\n"}
{"name":"List.rel_join","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\n⊢ Relator.LiftFun (List.Forall₂ (List.Forall₂ R)) (List.Forall₂ R) List.flatten List.flatten","decl":"@[deprecated (since := \"2025-10-15\")] alias rel_join := rel_flatten\n\n"}
{"name":"List.rel_flatMap","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nR : α → β → Prop\nP : γ → δ → Prop\n⊢ Relator.LiftFun (List.Forall₂ R) (Relator.LiftFun (Relator.LiftFun R (List.Forall₂ P)) (List.Forall₂ P)) List.flatMap List.flatMap","decl":"theorem rel_flatMap : (Forall₂ R ⇒ (R ⇒ Forall₂ P) ⇒ Forall₂ P) List.flatMap List.flatMap :=\n  fun _ _ h₁ _ _ h₂ => rel_flatten (rel_map (@h₂) h₁)\n\n"}
{"name":"List.rel_bind","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nR : α → β → Prop\nP : γ → δ → Prop\n⊢ Relator.LiftFun (List.Forall₂ R) (Relator.LiftFun (Relator.LiftFun R (List.Forall₂ P)) (List.Forall₂ P)) List.flatMap List.flatMap","decl":"@[deprecated (since := \"2025-10-16\")] alias rel_bind := rel_flatMap\n\n"}
{"name":"List.rel_foldl","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nR : α → β → Prop\nP : γ → δ → Prop\n⊢ Relator.LiftFun (Relator.LiftFun P (Relator.LiftFun R P)) (Relator.LiftFun P (Relator.LiftFun (List.Forall₂ R) P)) List.foldl List.foldl","decl":"theorem rel_foldl : ((P ⇒ R ⇒ P) ⇒ P ⇒ Forall₂ R ⇒ P) foldl foldl\n  | _, _, _, _, _, h, _, _, Forall₂.nil => h\n  | _, _, hfg, _, _, hxy, _, _, Forall₂.cons hab hs => rel_foldl (@hfg) (hfg hxy hab) hs\n\n"}
{"name":"List.rel_foldr","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nR : α → β → Prop\nP : γ → δ → Prop\n⊢ Relator.LiftFun (Relator.LiftFun R (Relator.LiftFun P P)) (Relator.LiftFun P (Relator.LiftFun (List.Forall₂ R) P)) List.foldr List.foldr","decl":"theorem rel_foldr : ((R ⇒ P ⇒ P) ⇒ P ⇒ Forall₂ R ⇒ P) foldr foldr\n  | _, _, _, _, _, h, _, _, Forall₂.nil => h\n  | _, _, hfg, _, _, hxy, _, _, Forall₂.cons hab hs => hfg hab (rel_foldr (@hfg) hxy hs)\n\n"}
{"name":"List.rel_filter","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\np : α → Bool\nq : β → Bool\nhpq : Relator.LiftFun R (fun x1 x2 => Iff x1 x2) (fun x => Eq (p x) Bool.true) fun x => Eq (q x) Bool.true\n⊢ Relator.LiftFun (List.Forall₂ R) (List.Forall₂ R) (List.filter p) (List.filter q)","decl":"theorem rel_filter {p : α → Bool} {q : β → Bool}\n    (hpq : (R ⇒ (· ↔ ·)) (fun x => p x) (fun x => q x)) :\n    (Forall₂ R ⇒ Forall₂ R) (filter p) (filter q)\n  | _, _, Forall₂.nil => Forall₂.nil\n  | a :: as, b :: bs, Forall₂.cons h₁ h₂ => by\n    dsimp [LiftFun] at hpq\n    by_cases h : p a\n    · have : q b := by rwa [← hpq h₁]\n      simp only [filter_cons_of_pos h, filter_cons_of_pos this, forall₂_cons, h₁, true_and,\n        rel_filter hpq h₂]\n    · have : ¬q b := by rwa [← hpq h₁]\n      simp only [filter_cons_of_neg h, filter_cons_of_neg this, rel_filter hpq h₂]\n\n"}
{"name":"List.rel_filterMap","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nR : α → β → Prop\nP : γ → δ → Prop\n⊢ Relator.LiftFun (Relator.LiftFun R (Option.Rel P)) (Relator.LiftFun (List.Forall₂ R) (List.Forall₂ P)) List.filterMap List.filterMap","decl":"theorem rel_filterMap : ((R ⇒ Option.Rel P) ⇒ Forall₂ R ⇒ Forall₂ P) filterMap filterMap\n  | _, _, _, _, _, Forall₂.nil => Forall₂.nil\n  | f, g, hfg, a :: as, b :: bs, Forall₂.cons h₁ h₂ => by\n    rw [filterMap_cons, filterMap_cons]\n    exact\n      match f a, g b, hfg h₁ with\n      | _, _, Option.Rel.none => rel_filterMap (@hfg) h₂\n      | _, _, Option.Rel.some h => Forall₂.cons h (rel_filterMap (@hfg) h₂)\n\n"}
{"name":"List.SublistForall₂.brecOn","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nmotive✝ : (a : List α) → (a_1 : List β) → List.SublistForall₂ R a a_1 → Prop\na✝¹ : List α\na✝ : List β\nx✝ : List.SublistForall₂ R a✝¹ a✝\nih✝ : ∀ (a : List α) (a_1 : List β) (x : List.SublistForall₂ R a a_1), x.below → motive✝ a a_1 x\n⊢ motive✝ a✝¹ a✝ x✝","decl":"/-- Given a relation `R`, `sublist_forall₂ r l₁ l₂` indicates that there is a sublist of `l₂` such\n  that `forall₂ r l₁ l₂`. -/\ninductive SublistForall₂ (R : α → β → Prop) : List α → List β → Prop\n  | nil {l} : SublistForall₂ R [] l\n  | cons {a₁ a₂ l₁ l₂} : R a₁ a₂ → SublistForall₂ R l₁ l₂ → SublistForall₂ R (a₁ :: l₁) (a₂ :: l₂)\n  | cons_right {a l₁ l₂} : SublistForall₂ R l₁ l₂ → SublistForall₂ R l₁ (a :: l₂)\n\n"}
{"name":"List.sublistForall₂_iff","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nR : α → β → Prop\nl₁ : List α\nl₂ : List β\n⊢ Iff (List.SublistForall₂ R l₁ l₂) (Exists fun l => And (List.Forall₂ R l₁ l) (l.Sublist l₂))","decl":"theorem sublistForall₂_iff {l₁ : List α} {l₂ : List β} :\n    SublistForall₂ R l₁ l₂ ↔ ∃ l, Forall₂ R l₁ l ∧ l <+ l₂ := by\n  constructor <;> intro h\n  · induction h with\n    | nil => exact ⟨nil, Forall₂.nil, nil_sublist _⟩\n    | @cons a b l1 l2 rab _ ih =>\n      obtain ⟨l, hl1, hl2⟩ := ih\n      exact ⟨b :: l, Forall₂.cons rab hl1, hl2.cons_cons b⟩\n    | cons_right _ ih =>\n      obtain ⟨l, hl1, hl2⟩ := ih\n      exact ⟨l, hl1, hl2.trans (Sublist.cons _ (Sublist.refl _))⟩\n  · obtain ⟨l, hl1, hl2⟩ := h\n    revert l₁\n    induction hl2 with\n    | slnil =>\n      intro l₁ hl1\n      rw [forall₂_nil_right_iff.1 hl1]\n      exact SublistForall₂.nil\n    | cons _ _ ih => intro l₁ hl1; exact SublistForall₂.cons_right (ih hl1)\n    | cons₂ _ _ ih =>\n      intro l₁ hl1\n      cases' hl1 with _ _ _ _ hr hl _\n      exact SublistForall₂.cons hr (ih hl)\n\n"}
{"name":"List.SublistForall₂.is_refl","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nRₐ : α → α → Prop\ninst✝ : IsRefl α Rₐ\n⊢ IsRefl (List α) (List.SublistForall₂ Rₐ)","decl":"instance SublistForall₂.is_refl [IsRefl α Rₐ] : IsRefl (List α) (SublistForall₂ Rₐ) :=\n  ⟨fun l => sublistForall₂_iff.2 ⟨l, forall₂_refl l, Sublist.refl l⟩⟩\n\n"}
{"name":"List.SublistForall₂.is_trans","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nRₐ : α → α → Prop\ninst✝ : IsTrans α Rₐ\n⊢ IsTrans (List α) (List.SublistForall₂ Rₐ)","decl":"instance SublistForall₂.is_trans [IsTrans α Rₐ] : IsTrans (List α) (SublistForall₂ Rₐ) :=\n  ⟨fun a b c => by\n    revert a b\n    induction c with\n    | nil =>\n      rintro _ _ h1 h2\n      cases h2\n      exact h1\n    | cons _ _ ih =>\n      rintro a b h1 h2\n      cases' h2 with _ _ _ _ _ hbc tbc _ _ y1 btc\n      · cases h1\n        exact SublistForall₂.nil\n      · cases' h1 with _ _ _ _ _ hab tab _ _ _ atb\n        · exact SublistForall₂.nil\n        · exact SublistForall₂.cons (_root_.trans hab hbc) (ih _ _ tab tbc)\n        · exact SublistForall₂.cons_right (ih _ _ atb tbc)\n      · exact SublistForall₂.cons_right (ih _ _ h1 btc)⟩\n\n"}
{"name":"List.Sublist.sublistForall₂","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nRₐ : α → α → Prop\nl₁ l₂ : List α\nh : l₁.Sublist l₂\ninst✝ : IsRefl α Rₐ\n⊢ List.SublistForall₂ Rₐ l₁ l₂","decl":"theorem Sublist.sublistForall₂ {l₁ l₂ : List α} (h : l₁ <+ l₂) [IsRefl α Rₐ] :\n    SublistForall₂ Rₐ l₁ l₂ :=\n  sublistForall₂_iff.2 ⟨l₁, forall₂_refl l₁, h⟩\n\n"}
{"name":"List.tail_sublistForall₂_self","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nRₐ : α → α → Prop\ninst✝ : IsRefl α Rₐ\nl : List α\n⊢ List.SublistForall₂ Rₐ l.tail l","decl":"theorem tail_sublistForall₂_self [IsRefl α Rₐ] (l : List α) : SublistForall₂ Rₐ l.tail l :=\n  l.tail_sublist.sublistForall₂\n\n"}
{"name":"List.sublistForall₂_map_left_iff","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nR : α → β → Prop\nf : γ → α\nl₁ : List γ\nl₂ : List β\n⊢ Iff (List.SublistForall₂ R (List.map f l₁) l₂) (List.SublistForall₂ (fun c b => R (f c) b) l₁ l₂)","decl":"@[simp]\ntheorem sublistForall₂_map_left_iff {f : γ → α} {l₁ : List γ} {l₂ : List β} :\n    SublistForall₂ R (map f l₁) l₂ ↔ SublistForall₂ (fun c b => R (f c) b) l₁ l₂ := by\n  simp [sublistForall₂_iff]\n\n"}
{"name":"List.sublistForall₂_map_right_iff","module":"Mathlib.Data.List.Forall2","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nR : α → β → Prop\nf : γ → β\nl₁ : List α\nl₂ : List γ\n⊢ Iff (List.SublistForall₂ R l₁ (List.map f l₂)) (List.SublistForall₂ (fun a c => R a (f c)) l₁ l₂)","decl":"@[simp]\ntheorem sublistForall₂_map_right_iff {f : γ → β} {l₁ : List α} {l₂ : List γ} :\n    SublistForall₂ R l₁ (map f l₂) ↔ SublistForall₂ (fun a c => R a (f c)) l₁ l₂ := by\n  simp only [sublistForall₂_iff]\n  constructor\n  · rintro ⟨l1, h1, h2⟩\n    obtain ⟨l', hl1, rfl⟩ := sublist_map_iff.mp h2\n    use l'\n    simpa [hl1] using h1\n  · rintro ⟨l1, h1, h2⟩\n    use l1.map f\n    simp [h1, h2.map]\n\n"}
