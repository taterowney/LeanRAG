{"name":"ENat.instOrderTopology","module":"Mathlib.Topology.Instances.ENat","initialProofState":"âŠ¢ OrderTopology ENat","decl":"instance : OrderTopology â„•âˆ := âŸ¨rflâŸ©\n\n"}
{"name":"ENat.range_natCast","module":"Mathlib.Topology.Instances.ENat","initialProofState":"âŠ¢ Eq (Set.range Nat.cast) (Set.Iio Top.top)","decl":"@[simp] theorem range_natCast : range ((â†‘) : â„• â†’ â„•âˆ) = Iio âŠ¤ :=\n  WithTop.range_coe\n\n"}
{"name":"ENat.isEmbedding_natCast","module":"Mathlib.Topology.Instances.ENat","initialProofState":"âŠ¢ Topology.IsEmbedding Nat.cast","decl":"theorem isEmbedding_natCast : IsEmbedding ((â†‘) : â„• â†’ â„•âˆ) :=\n  Nat.strictMono_cast.isEmbedding_of_ordConnected <| range_natCast â–¸ ordConnected_Iio\n\n"}
{"name":"ENat.embedding_natCast","module":"Mathlib.Topology.Instances.ENat","initialProofState":"âŠ¢ Topology.IsEmbedding Nat.cast","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_natCast := isEmbedding_natCast\n\n"}
{"name":"ENat.isOpenEmbedding_natCast","module":"Mathlib.Topology.Instances.ENat","initialProofState":"âŠ¢ Topology.IsOpenEmbedding Nat.cast","decl":"theorem isOpenEmbedding_natCast : IsOpenEmbedding ((â†‘) : â„• â†’ â„•âˆ) :=\n  âŸ¨isEmbedding_natCast, range_natCast â–¸ isOpen_IioâŸ©\n\n"}
{"name":"ENat.openEmbedding_natCast","module":"Mathlib.Topology.Instances.ENat","initialProofState":"âŠ¢ Topology.IsOpenEmbedding Nat.cast","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_natCast := isOpenEmbedding_natCast\n\n"}
{"name":"ENat.nhds_natCast","module":"Mathlib.Topology.Instances.ENat","initialProofState":"n : Nat\nâŠ¢ Eq (nhds â†‘n) (Pure.pure â†‘n)","decl":"theorem nhds_natCast (n : â„•) : ğ“ (n : â„•âˆ) = pure (n : â„•âˆ) := by\n  simp [â† isOpenEmbedding_natCast.map_nhds_eq]\n\n"}
{"name":"ENat.nhds_eq_pure","module":"Mathlib.Topology.Instances.ENat","initialProofState":"n : ENat\nh : Ne n Top.top\nâŠ¢ Eq (nhds n) (Pure.pure n)","decl":"@[simp]\nprotected theorem nhds_eq_pure {n : â„•âˆ} (h : n â‰  âŠ¤) : ğ“ n = pure n := by\n  lift n to â„• using h\n  simp [nhds_natCast]\n\n"}
{"name":"ENat.isOpen_singleton","module":"Mathlib.Topology.Instances.ENat","initialProofState":"x : ENat\nhx : Ne x Top.top\nâŠ¢ IsOpen (Singleton.singleton x)","decl":"theorem isOpen_singleton {x : â„•âˆ} (hx : x â‰  âŠ¤) : IsOpen {x} := by\n  rw [isOpen_singleton_iff_nhds_eq_pure, ENat.nhds_eq_pure hx]\n\n"}
{"name":"ENat.mem_nhds_iff","module":"Mathlib.Topology.Instances.ENat","initialProofState":"x : ENat\ns : Set ENat\nhx : Ne x Top.top\nâŠ¢ Iff (Membership.mem (nhds x) s) (Membership.mem s x)","decl":"theorem mem_nhds_iff {x : â„•âˆ} {s : Set â„•âˆ} (hx : x â‰  âŠ¤) : s âˆˆ ğ“ x â†” x âˆˆ s := by\n  simp [hx]\n\n"}
{"name":"ENat.mem_nhds_natCast_iff","module":"Mathlib.Topology.Instances.ENat","initialProofState":"n : Nat\ns : Set ENat\nâŠ¢ Iff (Membership.mem (nhds â†‘n) s) (Membership.mem s â†‘n)","decl":"theorem mem_nhds_natCast_iff (n : â„•) {s : Set â„•âˆ} : s âˆˆ ğ“ (n : â„•âˆ) â†” (n : â„•âˆ) âˆˆ s :=\n  mem_nhds_iff (coe_ne_top _)\n\n"}
{"name":"ENat.tendsto_nhds_top_iff_natCast_lt","module":"Mathlib.Topology.Instances.ENat","initialProofState":"Î± : Type u_1\nl : Filter Î±\nf : Î± â†’ ENat\nâŠ¢ Iff (Filter.Tendsto f l (nhds Top.top)) (âˆ€ (n : Nat), Filter.Eventually (fun a => LT.lt (â†‘n) (f a)) l)","decl":"theorem tendsto_nhds_top_iff_natCast_lt {Î± : Type*} {l : Filter Î±} {f : Î± â†’ â„•âˆ} :\n    Tendsto f l (ğ“ âŠ¤) â†” âˆ€ n : â„•, âˆ€á¶  a in l, n < f a := by\n  simp_rw [nhds_top_order, lt_top_iff_ne_top, tendsto_iInf, tendsto_principal]\n  exact Option.ball_ne_none\n\n"}
{"name":"ENat.instContinuousAdd","module":"Mathlib.Topology.Instances.ENat","initialProofState":"âŠ¢ ContinuousAdd ENat","decl":"instance : ContinuousAdd â„•âˆ := by\n  refine âŸ¨continuous_iff_continuousAt.2 fun (a, b) â†¦ ?_âŸ©\n  match a, b with\n  | âŠ¤, _ => exact tendsto_nhds_top_mono' continuousAt_fst fun p â†¦ le_add_right le_rfl\n  | (a : â„•), âŠ¤ => exact tendsto_nhds_top_mono' continuousAt_snd fun p â†¦ le_add_left le_rfl\n  | (a : â„•), (b : â„•) => simp [ContinuousAt, nhds_prod_eq, tendsto_pure_nhds]\n\n"}
{"name":"ENat.instContinuousMul","module":"Mathlib.Topology.Instances.ENat","initialProofState":"âŠ¢ ContinuousMul ENat","decl":"instance : ContinuousMul â„•âˆ where\n  continuous_mul :=\n    have key (a : â„•âˆ) : ContinuousAt (Â· * Â·).uncurry (a, âŠ¤) := by\n      rcases (zero_le a).eq_or_gt with rfl | ha\n      Â· simp [ContinuousAt, nhds_prod_eq]\n      Â· simp only [ContinuousAt, Function.uncurry, mul_top ha.ne']\n        refine tendsto_nhds_top_mono continuousAt_snd ?_\n        filter_upwards [continuousAt_fst (lt_mem_nhds ha)] with (x, y) (hx : 0 < x)\n        exact le_mul_of_one_le_left (zero_le y) (Order.one_le_iff_pos.2 hx)\n    continuous_iff_continuousAt.2 <| Prod.forall.2 fun\n      | (a : â„•âˆ), âŠ¤ => key a\n      | âŠ¤, (b : â„•âˆ) =>\n        ((key b).comp_of_eq (continuous_swap.tendsto (âŠ¤, b)) rfl).congr <|\n          .of_forall fun _ â†¦ mul_comm ..\n      | (a : â„•), (b : â„•) => by\n        simp [ContinuousAt, nhds_prod_eq, tendsto_pure_nhds]\n\n"}
{"name":"ENat.continuousAt_sub","module":"Mathlib.Topology.Instances.ENat","initialProofState":"a b : ENat\nh : Or (Ne a Top.top) (Ne b Top.top)\nâŠ¢ ContinuousAt (Function.uncurry fun x1 x2 => HSub.hSub x1 x2) { fst := a, snd := b }","decl":"protected theorem continuousAt_sub {a b : â„•âˆ} (h : a â‰  âŠ¤ âˆ¨ b â‰  âŠ¤) :\n    ContinuousAt (Â· - Â·).uncurry (a, b) := by\n  match a, b, h with\n  | (a : â„•), (b : â„•), _ => simp [ContinuousAt, nhds_prod_eq]\n  | (a : â„•), âŠ¤, _ =>\n    suffices âˆ€á¶  b in ğ“ âŠ¤, (a - b : â„•âˆ) = 0 by\n      simpa [ContinuousAt, nhds_prod_eq, tsub_eq_zero_of_le]\n    filter_upwards [le_mem_nhds (WithTop.coe_lt_top a)] with b using tsub_eq_zero_of_le\n  | âŠ¤, (b : â„•), _ =>\n    suffices âˆ€ n : â„•, âˆ€á¶  a : â„•âˆ in ğ“ âŠ¤, b + n < a by\n      simpa [ContinuousAt, nhds_prod_eq, (Â· âˆ˜ Â·), lt_tsub_iff_left, tendsto_nhds_top_iff_natCast_lt]\n    exact fun n â†¦ lt_mem_nhds <| WithTop.coe_lt_top (b + n)\n\n"}
{"name":"Filter.Tendsto.enatSub","module":"Mathlib.Topology.Instances.ENat","initialProofState":"Î± : Type u_1\nl : Filter Î±\nf g : Î± â†’ ENat\na b : ENat\nhf : Filter.Tendsto f l (nhds a)\nhg : Filter.Tendsto g l (nhds b)\nh : Or (Ne a Top.top) (Ne b Top.top)\nâŠ¢ Filter.Tendsto (fun x => HSub.hSub (f x) (g x)) l (nhds (HSub.hSub a b))","decl":"theorem Filter.Tendsto.enatSub {Î± : Type*} {l : Filter Î±} {f g : Î± â†’ â„•âˆ} {a b : â„•âˆ}\n    (hf : Tendsto f l (ğ“ a)) (hg : Tendsto g l (ğ“ b)) (h : a â‰  âŠ¤ âˆ¨ b â‰  âŠ¤) :\n    Tendsto (fun x â†¦ f x - g x) l (ğ“ (a - b)) :=\n  (ENat.continuousAt_sub h).tendsto.comp (hf.prod_mk_nhds hg)\n\n"}
{"name":"ContinuousWithinAt.enatSub","module":"Mathlib.Topology.Instances.ENat","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nf g : X â†’ ENat\ns : Set X\nx : X\nhf : ContinuousWithinAt f s x\nhg : ContinuousWithinAt g s x\nh : Or (Ne (f x) Top.top) (Ne (g x) Top.top)\nâŠ¢ ContinuousWithinAt (fun x => HSub.hSub (f x) (g x)) s x","decl":"nonrec theorem ContinuousWithinAt.enatSub\n    (hf : ContinuousWithinAt f s x) (hg : ContinuousWithinAt g s x) (h : f x â‰  âŠ¤ âˆ¨ g x â‰  âŠ¤) :\n    ContinuousWithinAt (fun x â†¦ f x - g x) s x :=\n  hf.enatSub hg h\n\n"}
{"name":"ContinuousAt.enatSub","module":"Mathlib.Topology.Instances.ENat","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nf g : X â†’ ENat\nx : X\nhf : ContinuousAt f x\nhg : ContinuousAt g x\nh : Or (Ne (f x) Top.top) (Ne (g x) Top.top)\nâŠ¢ ContinuousAt (fun x => HSub.hSub (f x) (g x)) x","decl":"nonrec theorem ContinuousAt.enatSub\n    (hf : ContinuousAt f x) (hg : ContinuousAt g x) (h : f x â‰  âŠ¤ âˆ¨ g x â‰  âŠ¤) :\n    ContinuousAt (fun x â†¦ f x - g x) x :=\n  hf.enatSub hg h\n\n"}
{"name":"ContinuousOn.enatSub","module":"Mathlib.Topology.Instances.ENat","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nf g : X â†’ ENat\ns : Set X\nhf : ContinuousOn f s\nhg : ContinuousOn g s\nh : âˆ€ (x : X), Membership.mem s x â†’ Or (Ne (f x) Top.top) (Ne (g x) Top.top)\nâŠ¢ ContinuousOn (fun x => HSub.hSub (f x) (g x)) s","decl":"nonrec theorem ContinuousOn.enatSub\n    (hf : ContinuousOn f s) (hg : ContinuousOn g s) (h : âˆ€ x âˆˆ s, f x â‰  âŠ¤ âˆ¨ g x â‰  âŠ¤) :\n    ContinuousOn (fun x â†¦ f x - g x) s := fun x hx â†¦\n  (hf x hx).enatSub (hg x hx) (h x hx)\n\n"}
{"name":"Continuous.enatSub","module":"Mathlib.Topology.Instances.ENat","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nf g : X â†’ ENat\nhf : Continuous f\nhg : Continuous g\nh : âˆ€ (x : X), Or (Ne (f x) Top.top) (Ne (g x) Top.top)\nâŠ¢ Continuous fun x => HSub.hSub (f x) (g x)","decl":"nonrec theorem Continuous.enatSub\n    (hf : Continuous f) (hg : Continuous g) (h : âˆ€ x, f x â‰  âŠ¤ âˆ¨ g x â‰  âŠ¤) :\n    Continuous (fun x â†¦ f x - g x) :=\n  continuous_iff_continuousAt.2 fun x â†¦ hf.continuousAt.enatSub hg.continuousAt (h x)\n"}
