{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.mk.sizeOf_spec","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : SizeOf C\ntoGlueData : CategoryTheory.GlueData (AlgebraicGeometry.PresheafedSpace C)\nf_open : ‚àÄ (i j : toGlueData.J), AlgebraicGeometry.PresheafedSpace.IsOpenImmersion (toGlueData.f i j)\n‚ä¢ Eq (SizeOf.sizeOf { toGlueData := toGlueData, f_open := f_open }) (HAdd.hAdd 1 (SizeOf.sizeOf toGlueData))","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A presheafed space `U i` for each `i : J`.\n3. A presheafed space `V i j` for each `i j : J`.\n  (Note that this is `J √ó J ‚Üí PresheafedSpace C` rather than `J ‚Üí J ‚Üí PresheafedSpace C` to\n  connect to the limits library easier.)\n4. An open immersion `f i j : V i j ‚ü∂ U i` for each `i j : Œπ`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n9. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n\nWe can then glue the spaces `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subspaces of the glued space.\n-/\nstructure GlueData extends CategoryTheory.GlueData (PresheafedSpace.{u, v, v} C) where\n  f_open : ‚àÄ i j, IsOpenImmersion (f i j)\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.f_open","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : AlgebraicGeometry.PresheafedSpace.GlueData C\ni j : self.J\n‚ä¢ AlgebraicGeometry.PresheafedSpace.IsOpenImmersion (self.f i j)","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A presheafed space `U i` for each `i : J`.\n3. A presheafed space `V i j` for each `i j : J`.\n  (Note that this is `J √ó J ‚Üí PresheafedSpace C` rather than `J ‚Üí J ‚Üí PresheafedSpace C` to\n  connect to the limits library easier.)\n4. An open immersion `f i j : V i j ‚ü∂ U i` for each `i j : Œπ`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n9. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n\nWe can then glue the spaces `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subspaces of the glued space.\n-/\nstructure GlueData extends CategoryTheory.GlueData (PresheafedSpace.{u, v, v} C) where\n  f_open : ‚àÄ i j, IsOpenImmersion (f i j)\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.mk.inj","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\ntoGlueData‚úù : CategoryTheory.GlueData (AlgebraicGeometry.PresheafedSpace C)\nf_open‚úù : ‚àÄ (i j : toGlueData‚úù.J), AlgebraicGeometry.PresheafedSpace.IsOpenImmersion (toGlueData‚úù.f i j)\ntoGlueData : CategoryTheory.GlueData (AlgebraicGeometry.PresheafedSpace C)\nf_open : ‚àÄ (i j : toGlueData.J), AlgebraicGeometry.PresheafedSpace.IsOpenImmersion (toGlueData.f i j)\nx‚úù : Eq { toGlueData := toGlueData‚úù, f_open := f_open‚úù } { toGlueData := toGlueData, f_open := f_open }\n‚ä¢ Eq toGlueData‚úù toGlueData","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A presheafed space `U i` for each `i : J`.\n3. A presheafed space `V i j` for each `i j : J`.\n  (Note that this is `J √ó J ‚Üí PresheafedSpace C` rather than `J ‚Üí J ‚Üí PresheafedSpace C` to\n  connect to the limits library easier.)\n4. An open immersion `f i j : V i j ‚ü∂ U i` for each `i j : Œπ`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n9. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n\nWe can then glue the spaces `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subspaces of the glued space.\n-/\nstructure GlueData extends CategoryTheory.GlueData (PresheafedSpace.{u, v, v} C) where\n  f_open : ‚àÄ i j, IsOpenImmersion (f i j)\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.mk.injEq","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\ntoGlueData‚úù : CategoryTheory.GlueData (AlgebraicGeometry.PresheafedSpace C)\nf_open‚úù : ‚àÄ (i j : toGlueData‚úù.J), AlgebraicGeometry.PresheafedSpace.IsOpenImmersion (toGlueData‚úù.f i j)\ntoGlueData : CategoryTheory.GlueData (AlgebraicGeometry.PresheafedSpace C)\nf_open : ‚àÄ (i j : toGlueData.J), AlgebraicGeometry.PresheafedSpace.IsOpenImmersion (toGlueData.f i j)\n‚ä¢ Eq (Eq { toGlueData := toGlueData‚úù, f_open := f_open‚úù } { toGlueData := toGlueData, f_open := f_open }) (Eq toGlueData‚úù toGlueData)","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A presheafed space `U i` for each `i : J`.\n3. A presheafed space `V i j` for each `i j : J`.\n  (Note that this is `J √ó J ‚Üí PresheafedSpace C` rather than `J ‚Üí J ‚Üí PresheafedSpace C` to\n  connect to the limits library easier.)\n4. An open immersion `f i j : V i j ‚ü∂ U i` for each `i j : Œπ`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n9. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n\nWe can then glue the spaces `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subspaces of the glued space.\n-/\nstructure GlueData extends CategoryTheory.GlueData (PresheafedSpace.{u, v, v} C) where\n  f_open : ‚àÄ i j, IsOpenImmersion (f i j)\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.Œπ_isOpenEmbedding","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : AlgebraicGeometry.PresheafedSpace.GlueData C\ninst‚úù : CategoryTheory.Limits.HasLimits C\ni : D.J\n‚ä¢ Topology.IsOpenEmbedding ‚áë(D.Œπ i).base","decl":"theorem Œπ_isOpenEmbedding [HasLimits C] (i : D.J) : IsOpenEmbedding (ùñ£.Œπ i).base := by\n  rw [‚Üê show _ = (ùñ£.Œπ i).base from ùñ£.Œπ_gluedIso_inv (PresheafedSpace.forget _) _]\n  -- Porting note: added this erewrite\n  erw [coe_comp]\n  exact (TopCat.homeoOfIso (ùñ£.gluedIso (PresheafedSpace.forget _)).symm).isOpenEmbedding.comp\n      (D.toTopGlueData.Œπ_isOpenEmbedding i)\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.Œπ_openEmbedding","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : AlgebraicGeometry.PresheafedSpace.GlueData C\ninst‚úù : CategoryTheory.Limits.HasLimits C\ni : D.J\n‚ä¢ Topology.IsOpenEmbedding ‚áë(D.Œπ i).base","decl":"@[deprecated (since := \"2024-10-18\")]\nalias Œπ_openEmbedding := Œπ_isOpenEmbedding\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.pullback_base","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nD : AlgebraicGeometry.PresheafedSpace.GlueData C\ni j k : D.J\nS : Set ‚Üë‚Üë(D.V { fst := i, snd := j })\n‚ä¢ Eq (Set.image (‚áë(CategoryTheory.Limits.pullback.snd (D.f i j) (D.f i k)).base) (Set.preimage (‚áë(CategoryTheory.Limits.pullback.fst (D.f i j) (D.f i k)).base) S)) (Set.preimage (‚áë(D.f i k).base) (Set.image (‚áë(D.f i j).base) S))","decl":"theorem pullback_base (i j k : D.J) (S : Set (D.V (i, j)).carrier) :\n    (œÄ‚ÇÇ i, j, k) '' ((œÄ‚ÇÅ i, j, k) ‚Åª¬π' S) = D.f i k ‚Åª¬π' (D.f i j '' S) := by\n  have eq‚ÇÅ : _ = (œÄ‚ÇÅ i, j, k).base := PreservesPullback.iso_hom_fst (forget C) _ _\n  have eq‚ÇÇ : _ = (œÄ‚ÇÇ i, j, k).base := PreservesPullback.iso_hom_snd (forget C) _ _\n  rw [‚Üê eq‚ÇÅ, ‚Üê eq‚ÇÇ]\n  -- Porting note: `rw` to `erw` on `coe_comp`\n  erw [coe_comp]\n  rw [Set.image_comp]\n  -- Porting note: `rw` to `erw` on `coe_comp`\n  erw [coe_comp]\n  rw [Set.preimage_comp, Set.image_preimage_eq, TopCat.pullback_snd_image_fst_preimage]\n  ¬∑ rfl\n  rw [‚Üê TopCat.epi_iff_surjective]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.f_invApp_f_app_assoc","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nD : AlgebraicGeometry.PresheafedSpace.GlueData C\ni j k : D.J\nU : TopologicalSpace.Opens ‚Üë‚Üë(D.V { fst := i, snd := j })\nZ : C\nh : Quiver.Hom (((TopCat.Presheaf.pushforward C (D.f i k).base).obj (D.V { fst := i, snd := k }).presheaf).obj { unop := (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.opensFunctor (D.f i j)).obj U }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.invApp (D.f i j) U) (CategoryTheory.CategoryStruct.comp ((D.f i k).c.app { unop := (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.opensFunctor (D.f i j)).obj U }) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.pullback.fst (D.f i j) (D.f i k)).c.app { unop := U }) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.invApp (CategoryTheory.Limits.pullback.snd (D.f i j) (D.f i k)) ((TopologicalSpace.Opens.map (CategoryTheory.Limits.pullback.fst (D.f i j) (D.f i k)).base).toPrefunctor.1 U)) (CategoryTheory.CategoryStruct.comp ((D.V { fst := i, snd := k }).presheaf.map (CategoryTheory.eqToHom ‚ãØ)) h)))","decl":"/-- The red and the blue arrows in ![this diagram](https://i.imgur.com/0GiBUh6.png) commute. -/\n@[simp, reassoc]\ntheorem f_invApp_f_app (i j k : D.J) (U : Opens (D.V (i, j)).carrier) :\n    (D.f_open i j).invApp _ U ‚â´ (D.f i k).c.app _ =\n      (œÄ‚ÇÅ i, j, k).c.app (op U) ‚â´\n        (œÄ‚ÇÇ‚Åª¬π i, j, k) (unop _) ‚â´\n          (D.V _).presheaf.map\n            (eqToHom\n              (by\n                delta IsOpenImmersion.opensFunctor\n                dsimp only [Functor.op, IsOpenMap.functor, Opens.map, unop_op]\n                congr\n                apply pullback_base)) := by\n  have := PresheafedSpace.congr_app (@pullback.condition _ _ _ _ _ (D.f i j) (D.f i k) _)\n  dsimp only [comp_c_app] at this\n  rw [‚Üê cancel_epi (inv ((D.f_open i j).invApp _ U)), IsIso.inv_hom_id_assoc,\n    IsOpenImmersion.inv_invApp]\n  simp_rw [Category.assoc]\n  erw [(œÄ‚ÇÅ i, j, k).c.naturality_assoc, reassoc_of% this, ‚Üê Functor.map_comp_assoc,\n    IsOpenImmersion.inv_naturality_assoc, IsOpenImmersion.app_invApp_assoc, ‚Üê\n    (D.V (i, k)).presheaf.map_comp, ‚Üê (D.V (i, k)).presheaf.map_comp]\n  -- Porting note: need to provide an explicit argument, otherwise Lean does not know which\n  -- category we are talking about\n  convert (Category.comp_id ((f D.toGlueData i k).c.app _)).symm\n  erw [(D.V (i, k)).presheaf.map_id]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.f_invApp_f_app","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nD : AlgebraicGeometry.PresheafedSpace.GlueData C\ni j k : D.J\nU : TopologicalSpace.Opens ‚Üë‚Üë(D.V { fst := i, snd := j })\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.invApp (D.f i j) U) ((D.f i k).c.app { unop := (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.opensFunctor (D.f i j)).obj U })) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.pullback.fst (D.f i j) (D.f i k)).c.app { unop := U }) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.invApp (CategoryTheory.Limits.pullback.snd (D.f i j) (D.f i k)) (Opposite.unop { unop := (TopologicalSpace.Opens.map (CategoryTheory.Limits.pullback.fst (D.f i j) (D.f i k)).base).toPrefunctor.1 (Opposite.unop { unop := U }) })) ((D.V { fst := i, snd := k }).presheaf.map (CategoryTheory.eqToHom ‚ãØ))))","decl":"/-- The red and the blue arrows in ![this diagram](https://i.imgur.com/0GiBUh6.png) commute. -/\n@[simp, reassoc]\ntheorem f_invApp_f_app (i j k : D.J) (U : Opens (D.V (i, j)).carrier) :\n    (D.f_open i j).invApp _ U ‚â´ (D.f i k).c.app _ =\n      (œÄ‚ÇÅ i, j, k).c.app (op U) ‚â´\n        (œÄ‚ÇÇ‚Åª¬π i, j, k) (unop _) ‚â´\n          (D.V _).presheaf.map\n            (eqToHom\n              (by\n                delta IsOpenImmersion.opensFunctor\n                dsimp only [Functor.op, IsOpenMap.functor, Opens.map, unop_op]\n                congr\n                apply pullback_base)) := by\n  have := PresheafedSpace.congr_app (@pullback.condition _ _ _ _ _ (D.f i j) (D.f i k) _)\n  dsimp only [comp_c_app] at this\n  rw [‚Üê cancel_epi (inv ((D.f_open i j).invApp _ U)), IsIso.inv_hom_id_assoc,\n    IsOpenImmersion.inv_invApp]\n  simp_rw [Category.assoc]\n  erw [(œÄ‚ÇÅ i, j, k).c.naturality_assoc, reassoc_of% this, ‚Üê Functor.map_comp_assoc,\n    IsOpenImmersion.inv_naturality_assoc, IsOpenImmersion.app_invApp_assoc, ‚Üê\n    (D.V (i, k)).presheaf.map_comp, ‚Üê (D.V (i, k)).presheaf.map_comp]\n  -- Porting note: need to provide an explicit argument, otherwise Lean does not know which\n  -- category we are talking about\n  convert (Category.comp_id ((f D.toGlueData i k).c.app _)).symm\n  erw [(D.V (i, k)).presheaf.map_id]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.snd_invApp_t_app'","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nD : AlgebraicGeometry.PresheafedSpace.GlueData C\ni j k : D.J\nU : TopologicalSpace.Opens ‚Üë‚Üë(CategoryTheory.Limits.pullback (D.f i j) (D.f i k))\n‚ä¢ Exists fun eq => Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.invApp (CategoryTheory.Limits.pullback.snd (D.f i j) (D.f i k)) U) (CategoryTheory.CategoryStruct.comp ((D.t k i).c.app { unop := (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.opensFunctor (CategoryTheory.Limits.pullback.snd (D.f i j) (D.f i k))).obj U }) ((D.V { fst := k, snd := i }).presheaf.map (CategoryTheory.eqToHom eq)))) (CategoryTheory.CategoryStruct.comp ((D.t' k i j).c.app { unop := U }) (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.invApp (CategoryTheory.Limits.pullback.fst (D.f k i) (D.f k j)) (Opposite.unop { unop := (TopologicalSpace.Opens.map (D.t' k i j).base).toPrefunctor.1 (Opposite.unop { unop := U }) })))","decl":"/-- We can prove the `eq` along with the lemma. Thus this is bundled together here, and the\nlemma itself is separated below.\n-/\ntheorem snd_invApp_t_app' (i j k : D.J) (U : Opens (pullback (D.f i j) (D.f i k)).carrier) :\n    ‚àÉ eq,\n      (œÄ‚ÇÇ‚Åª¬π i, j, k) U ‚â´ (D.t k i).c.app _ ‚â´ (D.V (k, i)).presheaf.map (eqToHom eq) =\n        (D.t' k i j).c.app _ ‚â´ (œÄ‚ÇÅ‚Åª¬π k, j, i) (unop _) := by\n  fconstructor\n  -- Porting note: I don't know what the magic was in Lean3 proof, it just skipped the proof of `eq`\n  ¬∑ delta IsOpenImmersion.opensFunctor\n    dsimp only [Functor.op, Opens.map, IsOpenMap.functor, unop_op, Opens.coe_mk]\n    congr\n    have := (ùñ£.t_fac k i j).symm\n    rw [‚Üê IsIso.inv_comp_eq] at this\n    replace this := (congr_arg ((PresheafedSpace.Hom.base ¬∑)) this).symm\n    replace this := congr_arg (ContinuousMap.toFun ¬∑) this\n    dsimp at this\n    rw [coe_comp, coe_comp] at this\n    rw [this, Set.image_comp, Set.image_comp, Set.preimage_image_eq]\n    swap\n    ¬∑ refine Function.HasLeftInverse.injective ‚ü®(D.t i k).base, fun x => ?_‚ü©\n      rw [‚Üê CategoryTheory.comp_apply, ‚Üê comp_base, D.t_inv, id_base, CategoryTheory.id_apply]\n    refine congr_arg (_ '' ¬∑) ?_\n    refine congr_fun ?_ _\n    refine Set.image_eq_preimage_of_inverse ?_ ?_\n    ¬∑ intro x\n      rw [‚Üê CategoryTheory.comp_apply, ‚Üê comp_base, IsIso.inv_hom_id, id_base,\n        CategoryTheory.id_apply]\n    ¬∑ intro x\n      rw [‚Üê CategoryTheory.comp_apply, ‚Üê comp_base, IsIso.hom_inv_id, id_base,\n        CategoryTheory.id_apply]\n  ¬∑ rw [‚Üê IsIso.eq_inv_comp, IsOpenImmersion.inv_invApp, Category.assoc,\n      (D.t' k i j).c.naturality_assoc]\n    simp_rw [‚Üê Category.assoc]\n    dsimp\n    rw [‚Üê comp_c_app, congr_app (D.t_fac k i j), comp_c_app]\n    dsimp\n    simp_rw [Category.assoc]\n    rw [IsOpenImmersion.inv_naturality, IsOpenImmersion.inv_naturality_assoc,\n      IsOpenImmersion.app_inv_app'_assoc]\n    ¬∑ simp_rw [‚Üê (ùñ£.V (k, i)).presheaf.map_comp]; rfl\n    rintro x ‚ü®y, -, eq‚ü©\n    replace eq := ConcreteCategory.congr_arg (ùñ£.t i k).base eq\n    change ((œÄ‚ÇÇ i, j, k) ‚â´ D.t i k).base y = (D.t k i ‚â´ D.t i k).base x at eq\n    rw [ùñ£.t_inv, id_base, TopCat.id_app] at eq\n    subst eq\n    use (inv (D.t' k i j)).base y\n    change (inv (D.t' k i j) ‚â´ œÄ‚ÇÅ k, i, j).base y = _\n    congr 2\n    rw [IsIso.inv_comp_eq, ùñ£.t_fac_assoc, ùñ£.t_inv, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.snd_invApp_t_app","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nD : AlgebraicGeometry.PresheafedSpace.GlueData C\ni j k : D.J\nU : TopologicalSpace.Opens ‚Üë‚Üë(CategoryTheory.Limits.pullback (D.f i j) (D.f i k))\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.invApp (CategoryTheory.Limits.pullback.snd (D.f i j) (D.f i k)) U) ((D.t k i).c.app { unop := (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.opensFunctor (CategoryTheory.Limits.pullback.snd (D.f i j) (D.f i k))).obj U })) (CategoryTheory.CategoryStruct.comp ((D.t' k i j).c.app { unop := U }) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.invApp (CategoryTheory.Limits.pullback.fst (D.f k i) (D.f k j)) (Opposite.unop { unop := (TopologicalSpace.Opens.map (D.t' k i j).base).toPrefunctor.1 (Opposite.unop { unop := U }) })) ((D.V { fst := k, snd := i }).presheaf.map (CategoryTheory.eqToHom ‚ãØ))))","decl":"/-- The red and the blue arrows in ![this diagram](https://i.imgur.com/q6X1GJ9.png) commute. -/\n@[simp, reassoc]\ntheorem snd_invApp_t_app (i j k : D.J) (U : Opens (pullback (D.f i j) (D.f i k)).carrier) :\n    (œÄ‚ÇÇ‚Åª¬π i, j, k) U ‚â´ (D.t k i).c.app _ =\n      (D.t' k i j).c.app _ ‚â´\n        (œÄ‚ÇÅ‚Åª¬π k, j, i) (unop _) ‚â´\n          (D.V (k, i)).presheaf.map (eqToHom (D.snd_invApp_t_app' i j k U).choose.symm) := by\n  have e := (D.snd_invApp_t_app' i j k U).choose_spec\n  replace e := reassoc_of% e\n  rw [‚Üê e]\n  simp [eqToHom_map]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.snd_invApp_t_app_assoc","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nD : AlgebraicGeometry.PresheafedSpace.GlueData C\ni j k : D.J\nU : TopologicalSpace.Opens ‚Üë‚Üë(CategoryTheory.Limits.pullback (D.f i j) (D.f i k))\nZ : C\nh : Quiver.Hom (((TopCat.Presheaf.pushforward C (D.t k i).base).obj (D.V { fst := k, snd := i }).presheaf).obj { unop := (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.opensFunctor (CategoryTheory.Limits.pullback.snd (D.f i j) (D.f i k))).obj U }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.invApp (CategoryTheory.Limits.pullback.snd (D.f i j) (D.f i k)) U) (CategoryTheory.CategoryStruct.comp ((D.t k i).c.app { unop := (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.opensFunctor (CategoryTheory.Limits.pullback.snd (D.f i j) (D.f i k))).obj U }) h)) (CategoryTheory.CategoryStruct.comp ((D.t' k i j).c.app { unop := U }) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.invApp (CategoryTheory.Limits.pullback.fst (D.f k i) (D.f k j)) ((TopologicalSpace.Opens.map (D.t' k i j).base).toPrefunctor.1 U)) (CategoryTheory.CategoryStruct.comp ((D.V { fst := k, snd := i }).presheaf.map (CategoryTheory.eqToHom ‚ãØ)) h)))","decl":"/-- The red and the blue arrows in ![this diagram](https://i.imgur.com/q6X1GJ9.png) commute. -/\n@[simp, reassoc]\ntheorem snd_invApp_t_app (i j k : D.J) (U : Opens (pullback (D.f i j) (D.f i k)).carrier) :\n    (œÄ‚ÇÇ‚Åª¬π i, j, k) U ‚â´ (D.t k i).c.app _ =\n      (D.t' k i j).c.app _ ‚â´\n        (œÄ‚ÇÅ‚Åª¬π k, j, i) (unop _) ‚â´\n          (D.V (k, i)).presheaf.map (eqToHom (D.snd_invApp_t_app' i j k U).choose.symm) := by\n  have e := (D.snd_invApp_t_app' i j k U).choose_spec\n  replace e := reassoc_of% e\n  rw [‚Üê e]\n  simp [eqToHom_map]\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.Œπ_image_preimage_eq","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : AlgebraicGeometry.PresheafedSpace.GlueData C\ninst‚úù : CategoryTheory.Limits.HasLimits C\ni j : D.J\nU : TopologicalSpace.Opens ‚Üë‚Üë(D.U i)\n‚ä¢ Eq ((TopologicalSpace.Opens.map (D.Œπ j).base).obj (‚ãØ.functor.obj U)) ((AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.opensFunctor (D.f j i)).obj ((TopologicalSpace.Opens.map (D.t j i).base).obj ((TopologicalSpace.Opens.map (D.f i j).base).obj U)))","decl":"theorem Œπ_image_preimage_eq (i j : D.J) (U : Opens (D.U i).carrier) :\n    (Opens.map (ùñ£.Œπ j).base).obj ((D.Œπ_isOpenEmbedding i).isOpenMap.functor.obj U) =\n      (opensFunctor (D.f j i)).obj\n        ((Opens.map (ùñ£.t j i).base).obj ((Opens.map (ùñ£.f i j).base).obj U)) := by\n  ext1\n  dsimp only [Opens.map_coe, IsOpenMap.coe_functor_obj]\n  rw [‚Üê show _ = (ùñ£.Œπ i).base from ùñ£.Œπ_gluedIso_inv (PresheafedSpace.forget _) i, ‚Üê\n    show _ = (ùñ£.Œπ j).base from ùñ£.Œπ_gluedIso_inv (PresheafedSpace.forget _) j]\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11224): change `rw` to `erw` on `coe_comp`\n  erw [coe_comp, coe_comp, coe_comp]\n  rw [Set.image_comp, Set.preimage_comp]\n  erw [Set.preimage_image_eq]\n  ¬∑ refine Eq.trans (D.toTopGlueData.preimage_image_eq_image' _ _ _) ?_\n    dsimp\n    rw [Set.image_comp]\n    refine congr_arg (_ '' ¬∑) ?_\n    rw [Set.eq_preimage_iff_image_eq, ‚Üê Set.image_comp]\n    swap\n    ¬∑ exact CategoryTheory.ConcreteCategory.bijective_of_isIso (C := TopCat) _\n    change (D.t i j ‚â´ D.t j i).base '' _ = _\n    rw [ùñ£.t_inv]\n    simp\n  ¬∑ rw [‚Üê coe_comp, ‚Üê TopCat.mono_iff_injective]\n    infer_instance\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.opensImagePreimageMap_app'","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : AlgebraicGeometry.PresheafedSpace.GlueData C\ninst‚úù : CategoryTheory.Limits.HasLimits C\ni j k : D.J\nU : TopologicalSpace.Opens ‚Üë‚Üë(D.U i)\n‚ä¢ Exists fun eq => Eq (CategoryTheory.CategoryStruct.comp (D.opensImagePreimageMap i j U) ((D.f j k).c.app { unop := (TopologicalSpace.Opens.map (D.Œπ j).base).obj (‚ãØ.functor.obj U) })) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (D.f j i) (D.f j k)) (CategoryTheory.CategoryStruct.comp (D.t j i) (D.f i j))).c.app { unop := U }) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.invApp (CategoryTheory.Limits.pullback.snd (D.f j i) (D.f j k)) (Opposite.unop { unop := (TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (D.f j i) (D.f j k)) (CategoryTheory.CategoryStruct.comp (D.t j i) (D.f i j))).base).toPrefunctor.1 (Opposite.unop { unop := U }) })) ((D.V { fst := j, snd := k }).presheaf.map (CategoryTheory.eqToHom eq))))","decl":"theorem opensImagePreimageMap_app' (i j k : D.J) (U : Opens (D.U i).carrier) :\n    ‚àÉ eq,\n      D.opensImagePreimageMap i j U ‚â´ (D.f j k).c.app _ =\n        ((œÄ‚ÇÅ j, i, k) ‚â´ D.t j i ‚â´ D.f i j).c.app (op U) ‚â´\n          (œÄ‚ÇÇ‚Åª¬π j, i, k) (unop _) ‚â´ (D.V (j, k)).presheaf.map (eqToHom eq) := by\n  constructor\n  ¬∑ delta opensImagePreimageMap\n    simp_rw [Category.assoc]\n    rw [(D.f j k).c.naturality, f_invApp_f_app_assoc]\n    ¬∑ erw [‚Üê (D.V (j, k)).presheaf.map_comp]\n      ¬∑ simp_rw [‚Üê Category.assoc]\n        erw [‚Üê comp_c_app, ‚Üê comp_c_app]\n        ¬∑ simp_rw [Category.assoc]\n          dsimp only [Functor.op, unop_op, Quiver.Hom.unop_op]\n          rw [eqToHom_map (Opens.map _), eqToHom_op, eqToHom_trans]\n          congr\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.opensImagePreimageMap_app","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : AlgebraicGeometry.PresheafedSpace.GlueData C\ninst‚úù : CategoryTheory.Limits.HasLimits C\ni j k : D.J\nU : TopologicalSpace.Opens ‚Üë‚Üë(D.U i)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (D.opensImagePreimageMap i j U) ((D.f j k).c.app { unop := (TopologicalSpace.Opens.map (D.Œπ j).base).obj (‚ãØ.functor.obj U) })) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (D.f j i) (D.f j k)) (CategoryTheory.CategoryStruct.comp (D.t j i) (D.f i j))).c.app { unop := U }) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.invApp (CategoryTheory.Limits.pullback.snd (D.f j i) (D.f j k)) (Opposite.unop { unop := (TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (D.f j i) (D.f j k)) (CategoryTheory.CategoryStruct.comp (D.t j i) (D.f i j))).base).toPrefunctor.1 (Opposite.unop { unop := U }) })) ((D.V { fst := j, snd := k }).presheaf.map (CategoryTheory.eqToHom ‚ãØ))))","decl":"/-- The red and the blue arrows in ![this diagram](https://i.imgur.com/mBzV1Rx.png) commute. -/\ntheorem opensImagePreimageMap_app (i j k : D.J) (U : Opens (D.U i).carrier) :\n    D.opensImagePreimageMap i j U ‚â´ (D.f j k).c.app _ =\n      ((œÄ‚ÇÅ j, i, k) ‚â´ D.t j i ‚â´ D.f i j).c.app (op U) ‚â´\n        (œÄ‚ÇÇ‚Åª¬π j, i, k) (unop _) ‚â´\n          (D.V (j, k)).presheaf.map (eqToHom (opensImagePreimageMap_app' D i j k U).choose) :=\n  (opensImagePreimageMap_app' D i j k U).choose_spec\n\n-- This is proved separately since `reassoc` somehow timeouts.\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.opensImagePreimageMap_app_assoc","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : AlgebraicGeometry.PresheafedSpace.GlueData C\ninst‚úù : CategoryTheory.Limits.HasLimits C\ni j k : D.J\nU : TopologicalSpace.Opens ‚Üë‚Üë(D.U i)\nX' : C\nf' : Quiver.Hom (((TopCat.Presheaf.pushforward C (D.f j k).base).obj (D.V { fst := j, snd := k }).presheaf).obj { unop := (TopologicalSpace.Opens.map (D.Œπ j).base).obj (‚ãØ.functor.obj U) }) X'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (D.opensImagePreimageMap i j U) (CategoryTheory.CategoryStruct.comp ((D.f j k).c.app { unop := (TopologicalSpace.Opens.map (D.Œπ j).base).obj (‚ãØ.functor.obj U) }) f')) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (D.f j i) (D.f j k)) (CategoryTheory.CategoryStruct.comp (D.t j i) (D.f i j))).c.app { unop := U }) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.PresheafedSpace.IsOpenImmersion.invApp (CategoryTheory.Limits.pullback.snd (D.f j i) (D.f j k)) (Opposite.unop { unop := (TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (D.f j i) (D.f j k)) (CategoryTheory.CategoryStruct.comp (D.t j i) (D.f i j))).base).toPrefunctor.1 (Opposite.unop { unop := U }) })) (CategoryTheory.CategoryStruct.comp ((D.V { fst := j, snd := k }).presheaf.map (CategoryTheory.eqToHom ‚ãØ)) f')))","decl":"theorem opensImagePreimageMap_app_assoc (i j k : D.J) (U : Opens (D.U i).carrier) {X' : C}\n    (f' : _ ‚ü∂ X') :\n    D.opensImagePreimageMap i j U ‚â´ (D.f j k).c.app _ ‚â´ f' =\n      ((œÄ‚ÇÅ j, i, k) ‚â´ D.t j i ‚â´ D.f i j).c.app (op U) ‚â´\n        (œÄ‚ÇÇ‚Åª¬π j, i, k) (unop _) ‚â´\n          (D.V (j, k)).presheaf.map\n            (eqToHom (opensImagePreimageMap_app' D i j k U).choose) ‚â´ f' := by\n  simpa only [Category.assoc] using congr_arg (¬∑ ‚â´ f') (opensImagePreimageMap_app D i j k U)\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.ŒπInvApp_œÄ","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : AlgebraicGeometry.PresheafedSpace.GlueData C\ninst‚úù : CategoryTheory.Limits.HasLimits C\ni : D.J\nU : TopologicalSpace.Opens ‚Üë‚Üë(D.U i)\n‚ä¢ Exists fun eq => Eq (CategoryTheory.CategoryStruct.comp (D.ŒπInvApp U) (D.diagramOverOpenœÄ U i)) ((D.U i).presheaf.map (CategoryTheory.eqToHom eq))","decl":"/-- `ŒπInvApp` is the left inverse of `D.Œπ i` on `U`. -/\ntheorem ŒπInvApp_œÄ {i : D.J} (U : Opens (D.U i).carrier) :\n    ‚àÉ eq, D.ŒπInvApp U ‚â´ D.diagramOverOpenœÄ U i = (D.U i).presheaf.map (eqToHom eq) := by\n  fconstructor\n  -- Porting note: I don't know what the magic was in Lean3 proof, it just skipped the proof of `eq`\n  ¬∑ congr; ext1; change _ = _ ‚Åª¬π' (_ '' _); ext1 x\n    simp only [SetLike.mem_coe, diagram_l, diagram_r, unop_op, Set.mem_preimage, Set.mem_image]\n    refine ‚ü®fun h => ‚ü®_, h, rfl‚ü©, ?_‚ü©\n    rintro ‚ü®y, h1, h2‚ü©\n    convert h1 using 1\n    delta Œπ Multicoequalizer.œÄ at h2\n    apply_fun (D.Œπ _).base\n    ¬∑ exact h2.symm\n    ¬∑ have := D.Œπ_gluedIso_inv (PresheafedSpace.forget _) i\n      dsimp at this\n      rw [‚Üê this, coe_comp]\n      refine Function.Injective.comp ?_ (TopCat.GlueData.Œπ_injective D.toTopGlueData i)\n      rw [‚Üê TopCat.mono_iff_injective]\n      infer_instance\n  delta ŒπInvApp\n  rw [limit.lift_œÄ]\n  change D.opensImagePreimageMap i i U = _\n  dsimp [opensImagePreimageMap]\n  rw [congr_app (D.t_id _), id_c_app, ‚Üê Functor.map_comp]\n  erw [IsOpenImmersion.inv_naturality_assoc, IsOpenImmersion.app_inv_app'_assoc]\n  ¬∑ simp only [eqToHom_op, eqToHom_trans, eqToHom_map (Functor.op _), ‚Üê Functor.map_comp]\n    rfl\n  ¬∑ rw [Set.range_eq_univ.mpr _]\n    ¬∑ simp\n    ¬∑ rw [‚Üê TopCat.epi_iff_surjective]\n      infer_instance\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.œÄ_ŒπInvApp_œÄ","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : AlgebraicGeometry.PresheafedSpace.GlueData C\ninst‚úù : CategoryTheory.Limits.HasLimits C\ni j : D.J\nU : TopologicalSpace.Opens ‚Üë‚Üë(D.U i)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (D.diagramOverOpenœÄ U i) (CategoryTheory.CategoryStruct.comp (D.ŒπInvAppœÄEqMap U) (CategoryTheory.CategoryStruct.comp (D.ŒπInvApp U) (D.diagramOverOpenœÄ U j)))) (D.diagramOverOpenœÄ U j)","decl":"/-- `ŒπInvApp` is the right inverse of `D.Œπ i` on `U`. -/\ntheorem œÄ_ŒπInvApp_œÄ (i j : D.J) (U : Opens (D.U i).carrier) :\n    D.diagramOverOpenœÄ U i ‚â´ D.ŒπInvAppœÄEqMap U ‚â´ D.ŒπInvApp U ‚â´ D.diagramOverOpenœÄ U j =\n      D.diagramOverOpenœÄ U j := by\n  rw [‚Üê @cancel_mono\n          (f := (componentwiseDiagram ùñ£.diagram.multispan _).map\n            (Quiver.Hom.op (WalkingMultispan.Hom.snd (i, j))) ‚â´ ùüô _) ..]\n  ¬∑ simp_rw [Category.assoc]\n    rw [limit.w_assoc]\n    erw [limit.lift_œÄ_assoc]\n    rw [Category.comp_id, Category.comp_id]\n    change _ ‚â´ _ ‚â´ (_ ‚â´ _) ‚â´ _ = _\n    rw [congr_app (D.t_id _), id_c_app]\n    simp_rw [Category.assoc]\n    rw [‚Üê Functor.map_comp_assoc]\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11224): change `rw` to `erw`\n    erw [IsOpenImmersion.inv_naturality_assoc]\n    erw [IsOpenImmersion.app_invApp_assoc]\n    iterate 3 rw [‚Üê Functor.map_comp_assoc]\n    rw [NatTrans.naturality_assoc]\n    erw [‚Üê (D.V (i, j)).presheaf.map_comp]\n    convert\n      limit.w (componentwiseDiagram ùñ£.diagram.multispan _)\n        (Quiver.Hom.op (WalkingMultispan.Hom.fst (i, j)))\n  ¬∑ rw [Category.comp_id]\n    apply (config := { allowSynthFailures := true }) mono_comp\n    change Mono ((_ ‚â´ D.f j i).c.app _)\n    rw [comp_c_app]\n    apply (config := { allowSynthFailures := true }) mono_comp\n    ¬∑ erw [D.Œπ_image_preimage_eq i j U]\n      infer_instance\n    ¬∑ have : IsIso (D.t i j).c := by apply c_isIso_of_iso\n      infer_instance\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.œÄ_ŒπInvApp_eq_id","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : AlgebraicGeometry.PresheafedSpace.GlueData C\ninst‚úù : CategoryTheory.Limits.HasLimits C\ni : D.J\nU : TopologicalSpace.Opens ‚Üë‚Üë(D.U i)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (D.diagramOverOpenœÄ U i) (CategoryTheory.CategoryStruct.comp (D.ŒπInvAppœÄEqMap U) (D.ŒπInvApp U))) (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.limit (D.diagramOverOpen U)))","decl":"/-- `ŒπInvApp` is the inverse of `D.Œπ i` on `U`. -/\ntheorem œÄ_ŒπInvApp_eq_id (i : D.J) (U : Opens (D.U i).carrier) :\n    D.diagramOverOpenœÄ U i ‚â´ D.ŒπInvAppœÄEqMap U ‚â´ D.ŒπInvApp U = ùüô _ := by\n  ext j\n  induction j using Opposite.rec' with | h j => ?_\n  rcases j with (‚ü®j, k‚ü© | ‚ü®j‚ü©)\n  ¬∑ rw [‚Üê limit.w (componentwiseDiagram ùñ£.diagram.multispan _)\n        (Quiver.Hom.op (WalkingMultispan.Hom.fst (j, k))),\n      ‚Üê Category.assoc, Category.id_comp]\n    congr 1\n    simp_rw [Category.assoc]\n    apply œÄ_ŒπInvApp_œÄ\n  ¬∑ simp_rw [Category.assoc]\n    rw [Category.id_comp]\n    apply œÄ_ŒπInvApp_œÄ\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.componentwise_diagram_œÄ_isIso","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : AlgebraicGeometry.PresheafedSpace.GlueData C\ninst‚úù : CategoryTheory.Limits.HasLimits C\ni : D.J\nU : TopologicalSpace.Opens ‚Üë‚Üë(D.U i)\n‚ä¢ CategoryTheory.IsIso (D.diagramOverOpenœÄ U i)","decl":"instance componentwise_diagram_œÄ_isIso (i : D.J) (U : Opens (D.U i).carrier) :\n    IsIso (D.diagramOverOpenœÄ U i) := by\n  use D.ŒπInvAppœÄEqMap U ‚â´ D.ŒπInvApp U\n  constructor\n  ¬∑ apply œÄ_ŒπInvApp_eq_id\n  ¬∑ rw [Category.assoc, (D.ŒπInvApp_œÄ _).choose_spec]\n    exact Iso.inv_hom_id ((D.U i).presheaf.mapIso (eqToIso _))\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.ŒπIsOpenImmersion","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : AlgebraicGeometry.PresheafedSpace.GlueData C\ninst‚úù : CategoryTheory.Limits.HasLimits C\ni : D.J\n‚ä¢ AlgebraicGeometry.PresheafedSpace.IsOpenImmersion (D.Œπ i)","decl":"instance ŒπIsOpenImmersion (i : D.J) : IsOpenImmersion (ùñ£.Œπ i) where\n  base_open := D.Œπ_isOpenEmbedding i\n  c_iso U := by erw [‚Üê colimitPresheafObjIsoComponentwiseLimit_hom_œÄ]; infer_instance\n\n"}
{"name":"AlgebraicGeometry.PresheafedSpace.GlueData.Œπ_jointly_surjective","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : AlgebraicGeometry.PresheafedSpace.GlueData C\ninst‚úù : CategoryTheory.Limits.HasLimits C\nx : ‚Üë‚ÜëD.glued\n‚ä¢ Exists fun i => Exists fun y => Eq ((D.Œπ i).base y) x","decl":"theorem Œπ_jointly_surjective (x : ùñ£.glued) : ‚àÉ (i : D.J) (y : D.U i), (ùñ£.Œπ i).base y = x :=\n  ùñ£.Œπ_jointly_surjective (PresheafedSpace.forget _ ‚ãô CategoryTheory.forget TopCat) x\n\n"}
{"name":"AlgebraicGeometry.SheafedSpace.GlueData.mk.sizeOf_spec","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : SizeOf C\ntoGlueData : CategoryTheory.GlueData (AlgebraicGeometry.SheafedSpace C)\nf_open : ‚àÄ (i j : toGlueData.J), AlgebraicGeometry.SheafedSpace.IsOpenImmersion (toGlueData.f i j)\n‚ä¢ Eq (SizeOf.sizeOf { toGlueData := toGlueData, f_open := f_open }) (HAdd.hAdd 1 (SizeOf.sizeOf toGlueData))","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A sheafed space `U i` for each `i : J`.\n3. A sheafed space `V i j` for each `i j : J`.\n  (Note that this is `J √ó J ‚Üí SheafedSpace C` rather than `J ‚Üí J ‚Üí SheafedSpace C` to\n  connect to the limits library easier.)\n4. An open immersion `f i j : V i j ‚ü∂ U i` for each `i j : Œπ`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n9. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n\nWe can then glue the spaces `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subspaces of the glued space.\n-/\nstructure GlueData extends CategoryTheory.GlueData (SheafedSpace.{u, v, v} C) where\n  f_open : ‚àÄ i j, SheafedSpace.IsOpenImmersion (f i j)\n\n"}
{"name":"AlgebraicGeometry.SheafedSpace.GlueData.mk.inj","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\ntoGlueData‚úù : CategoryTheory.GlueData (AlgebraicGeometry.SheafedSpace C)\nf_open‚úù : ‚àÄ (i j : toGlueData‚úù.J), AlgebraicGeometry.SheafedSpace.IsOpenImmersion (toGlueData‚úù.f i j)\ntoGlueData : CategoryTheory.GlueData (AlgebraicGeometry.SheafedSpace C)\nf_open : ‚àÄ (i j : toGlueData.J), AlgebraicGeometry.SheafedSpace.IsOpenImmersion (toGlueData.f i j)\nx‚úù : Eq { toGlueData := toGlueData‚úù, f_open := f_open‚úù } { toGlueData := toGlueData, f_open := f_open }\n‚ä¢ Eq toGlueData‚úù toGlueData","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A sheafed space `U i` for each `i : J`.\n3. A sheafed space `V i j` for each `i j : J`.\n  (Note that this is `J √ó J ‚Üí SheafedSpace C` rather than `J ‚Üí J ‚Üí SheafedSpace C` to\n  connect to the limits library easier.)\n4. An open immersion `f i j : V i j ‚ü∂ U i` for each `i j : Œπ`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n9. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n\nWe can then glue the spaces `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subspaces of the glued space.\n-/\nstructure GlueData extends CategoryTheory.GlueData (SheafedSpace.{u, v, v} C) where\n  f_open : ‚àÄ i j, SheafedSpace.IsOpenImmersion (f i j)\n\n"}
{"name":"AlgebraicGeometry.SheafedSpace.GlueData.mk.injEq","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\ntoGlueData‚úù : CategoryTheory.GlueData (AlgebraicGeometry.SheafedSpace C)\nf_open‚úù : ‚àÄ (i j : toGlueData‚úù.J), AlgebraicGeometry.SheafedSpace.IsOpenImmersion (toGlueData‚úù.f i j)\ntoGlueData : CategoryTheory.GlueData (AlgebraicGeometry.SheafedSpace C)\nf_open : ‚àÄ (i j : toGlueData.J), AlgebraicGeometry.SheafedSpace.IsOpenImmersion (toGlueData.f i j)\n‚ä¢ Eq (Eq { toGlueData := toGlueData‚úù, f_open := f_open‚úù } { toGlueData := toGlueData, f_open := f_open }) (Eq toGlueData‚úù toGlueData)","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A sheafed space `U i` for each `i : J`.\n3. A sheafed space `V i j` for each `i j : J`.\n  (Note that this is `J √ó J ‚Üí SheafedSpace C` rather than `J ‚Üí J ‚Üí SheafedSpace C` to\n  connect to the limits library easier.)\n4. An open immersion `f i j : V i j ‚ü∂ U i` for each `i j : Œπ`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n9. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n\nWe can then glue the spaces `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subspaces of the glued space.\n-/\nstructure GlueData extends CategoryTheory.GlueData (SheafedSpace.{u, v, v} C) where\n  f_open : ‚àÄ i j, SheafedSpace.IsOpenImmersion (f i j)\n\n"}
{"name":"AlgebraicGeometry.SheafedSpace.GlueData.f_open","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : AlgebraicGeometry.SheafedSpace.GlueData C\ni j : self.J\n‚ä¢ AlgebraicGeometry.SheafedSpace.IsOpenImmersion (self.f i j)","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A sheafed space `U i` for each `i : J`.\n3. A sheafed space `V i j` for each `i j : J`.\n  (Note that this is `J √ó J ‚Üí SheafedSpace C` rather than `J ‚Üí J ‚Üí SheafedSpace C` to\n  connect to the limits library easier.)\n4. An open immersion `f i j : V i j ‚ü∂ U i` for each `i j : Œπ`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n9. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n\nWe can then glue the spaces `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subspaces of the glued space.\n-/\nstructure GlueData extends CategoryTheory.GlueData (SheafedSpace.{u, v, v} C) where\n  f_open : ‚àÄ i j, SheafedSpace.IsOpenImmersion (f i j)\n\n"}
{"name":"AlgebraicGeometry.SheafedSpace.GlueData.Œπ_isoPresheafedSpace_inv","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : AlgebraicGeometry.SheafedSpace.GlueData C\ninst‚úù : CategoryTheory.Limits.HasLimits C\ni : D.J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (D.toPresheafedSpaceGlueData.Œπ i) D.isoPresheafedSpace.inv) (D.Œπ i)","decl":"theorem Œπ_isoPresheafedSpace_inv (i : D.J) :\n    D.toPresheafedSpaceGlueData.toGlueData.Œπ i ‚â´ D.isoPresheafedSpace.inv = ùñ£.Œπ i :=\n  ùñ£.Œπ_gluedIso_inv _ _\n\n"}
{"name":"AlgebraicGeometry.SheafedSpace.GlueData.ŒπIsOpenImmersion","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : AlgebraicGeometry.SheafedSpace.GlueData C\ninst‚úù : CategoryTheory.Limits.HasLimits C\ni : D.J\n‚ä¢ AlgebraicGeometry.SheafedSpace.IsOpenImmersion (D.Œπ i)","decl":"instance ŒπIsOpenImmersion (i : D.J) : IsOpenImmersion (ùñ£.Œπ i) := by\n  rw [‚Üê D.Œπ_isoPresheafedSpace_inv]\n  have := D.toPresheafedSpaceGlueData.ŒπIsOpenImmersion i\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.SheafedSpace.GlueData.Œπ_jointly_surjective","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : AlgebraicGeometry.SheafedSpace.GlueData C\ninst‚úù : CategoryTheory.Limits.HasLimits C\nx : ‚Üë‚ÜëD.glued.toPresheafedSpace\n‚ä¢ Exists fun i => Exists fun y => Eq ((D.Œπ i).base y) x","decl":"theorem Œπ_jointly_surjective (x : ùñ£.glued) : ‚àÉ (i : D.J) (y : D.U i), (ùñ£.Œπ i).base y = x :=\n  ùñ£.Œπ_jointly_surjective (SheafedSpace.forget _ ‚ãô CategoryTheory.forget TopCat) x\n\n"}
{"name":"AlgebraicGeometry.LocallyRingedSpace.GlueData.mk.inj","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"toGlueData‚úù : CategoryTheory.GlueData AlgebraicGeometry.LocallyRingedSpace\nf_open‚úù : ‚àÄ (i j : toGlueData‚úù.J), AlgebraicGeometry.LocallyRingedSpace.IsOpenImmersion (toGlueData‚úù.f i j)\ntoGlueData : CategoryTheory.GlueData AlgebraicGeometry.LocallyRingedSpace\nf_open : ‚àÄ (i j : toGlueData.J), AlgebraicGeometry.LocallyRingedSpace.IsOpenImmersion (toGlueData.f i j)\nx‚úù : Eq { toGlueData := toGlueData‚úù, f_open := f_open‚úù } { toGlueData := toGlueData, f_open := f_open }\n‚ä¢ Eq toGlueData‚úù toGlueData","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A locally ringed space `U i` for each `i : J`.\n3. A locally ringed space `V i j` for each `i j : J`.\n  (Note that this is `J √ó J ‚Üí LocallyRingedSpace` rather than `J ‚Üí J ‚Üí LocallyRingedSpace` to\n  connect to the limits library easier.)\n4. An open immersion `f i j : V i j ‚ü∂ U i` for each `i j : Œπ`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n9. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n\nWe can then glue the spaces `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subspaces of the glued space.\n-/\nstructure GlueData extends CategoryTheory.GlueData LocallyRingedSpace where\n  f_open : ‚àÄ i j, LocallyRingedSpace.IsOpenImmersion (f i j)\n\n"}
{"name":"AlgebraicGeometry.LocallyRingedSpace.GlueData.mk.sizeOf_spec","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"toGlueData : CategoryTheory.GlueData AlgebraicGeometry.LocallyRingedSpace\nf_open : ‚àÄ (i j : toGlueData.J), AlgebraicGeometry.LocallyRingedSpace.IsOpenImmersion (toGlueData.f i j)\n‚ä¢ Eq (SizeOf.sizeOf { toGlueData := toGlueData, f_open := f_open }) (HAdd.hAdd 1 (SizeOf.sizeOf toGlueData))","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A locally ringed space `U i` for each `i : J`.\n3. A locally ringed space `V i j` for each `i j : J`.\n  (Note that this is `J √ó J ‚Üí LocallyRingedSpace` rather than `J ‚Üí J ‚Üí LocallyRingedSpace` to\n  connect to the limits library easier.)\n4. An open immersion `f i j : V i j ‚ü∂ U i` for each `i j : Œπ`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n9. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n\nWe can then glue the spaces `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subspaces of the glued space.\n-/\nstructure GlueData extends CategoryTheory.GlueData LocallyRingedSpace where\n  f_open : ‚àÄ i j, LocallyRingedSpace.IsOpenImmersion (f i j)\n\n"}
{"name":"AlgebraicGeometry.LocallyRingedSpace.GlueData.mk.injEq","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"toGlueData‚úù : CategoryTheory.GlueData AlgebraicGeometry.LocallyRingedSpace\nf_open‚úù : ‚àÄ (i j : toGlueData‚úù.J), AlgebraicGeometry.LocallyRingedSpace.IsOpenImmersion (toGlueData‚úù.f i j)\ntoGlueData : CategoryTheory.GlueData AlgebraicGeometry.LocallyRingedSpace\nf_open : ‚àÄ (i j : toGlueData.J), AlgebraicGeometry.LocallyRingedSpace.IsOpenImmersion (toGlueData.f i j)\n‚ä¢ Eq (Eq { toGlueData := toGlueData‚úù, f_open := f_open‚úù } { toGlueData := toGlueData, f_open := f_open }) (Eq toGlueData‚úù toGlueData)","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A locally ringed space `U i` for each `i : J`.\n3. A locally ringed space `V i j` for each `i j : J`.\n  (Note that this is `J √ó J ‚Üí LocallyRingedSpace` rather than `J ‚Üí J ‚Üí LocallyRingedSpace` to\n  connect to the limits library easier.)\n4. An open immersion `f i j : V i j ‚ü∂ U i` for each `i j : Œπ`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n9. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n\nWe can then glue the spaces `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subspaces of the glued space.\n-/\nstructure GlueData extends CategoryTheory.GlueData LocallyRingedSpace where\n  f_open : ‚àÄ i j, LocallyRingedSpace.IsOpenImmersion (f i j)\n\n"}
{"name":"AlgebraicGeometry.LocallyRingedSpace.GlueData.f_open","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"self : AlgebraicGeometry.LocallyRingedSpace.GlueData\ni j : self.J\n‚ä¢ AlgebraicGeometry.LocallyRingedSpace.IsOpenImmersion (self.f i j)","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A locally ringed space `U i` for each `i : J`.\n3. A locally ringed space `V i j` for each `i j : J`.\n  (Note that this is `J √ó J ‚Üí LocallyRingedSpace` rather than `J ‚Üí J ‚Üí LocallyRingedSpace` to\n  connect to the limits library easier.)\n4. An open immersion `f i j : V i j ‚ü∂ U i` for each `i j : Œπ`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n9. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n\nWe can then glue the spaces `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subspaces of the glued space.\n-/\nstructure GlueData extends CategoryTheory.GlueData LocallyRingedSpace where\n  f_open : ‚àÄ i j, LocallyRingedSpace.IsOpenImmersion (f i j)\n\n"}
{"name":"AlgebraicGeometry.LocallyRingedSpace.GlueData.Œπ_isoSheafedSpace_inv","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"D : AlgebraicGeometry.LocallyRingedSpace.GlueData\ni : D.J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (D.toSheafedSpaceGlueData.Œπ i) D.isoSheafedSpace.inv) (D.Œπ i).toHom","decl":"theorem Œπ_isoSheafedSpace_inv (i : D.J) :\n    D.toSheafedSpaceGlueData.toGlueData.Œπ i ‚â´ D.isoSheafedSpace.inv = (ùñ£.Œπ i).1 :=\n  ùñ£.Œπ_gluedIso_inv forgetToSheafedSpace i\n\n"}
{"name":"AlgebraicGeometry.LocallyRingedSpace.GlueData.Œπ_isOpenImmersion","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"D : AlgebraicGeometry.LocallyRingedSpace.GlueData\ni : D.J\n‚ä¢ AlgebraicGeometry.LocallyRingedSpace.IsOpenImmersion (D.Œπ i)","decl":"instance Œπ_isOpenImmersion (i : D.J) : IsOpenImmersion (ùñ£.Œπ i) := by\n  delta IsOpenImmersion; rw [‚Üê D.Œπ_isoSheafedSpace_inv]\n  apply (config := { allowSynthFailures := true }) PresheafedSpace.IsOpenImmersion.comp\n  -- Porting note: this was automatic\n  exact (D.toSheafedSpaceGlueData).ŒπIsOpenImmersion i\n\n"}
{"name":"AlgebraicGeometry.LocallyRingedSpace.GlueData.instPreservesLimitSheafedSpaceCommRingCatWalkingCospanCospanFForgetToSheafedSpace","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"D : AlgebraicGeometry.LocallyRingedSpace.GlueData\ni j k : D.J\n‚ä¢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan (D.f i j) (D.f i k)) AlgebraicGeometry.LocallyRingedSpace.forgetToSheafedSpace","decl":"instance (i j k : D.J) : PreservesLimit (cospan (ùñ£.f i j) (ùñ£.f i k)) forgetToSheafedSpace :=\n  inferInstance\n\n"}
{"name":"AlgebraicGeometry.LocallyRingedSpace.GlueData.Œπ_jointly_surjective","module":"Mathlib.Geometry.RingedSpace.PresheafedSpace.Gluing","initialProofState":"D : AlgebraicGeometry.LocallyRingedSpace.GlueData\nx : ‚ÜëD.glued.toTopCat\n‚ä¢ Exists fun i => Exists fun y => Eq ((D.Œπ i).base y) x","decl":"theorem Œπ_jointly_surjective (x : ùñ£.glued) : ‚àÉ (i : D.J) (y : D.U i), (ùñ£.Œπ i).base y = x :=\n  ùñ£.Œπ_jointly_surjective\n    ((LocallyRingedSpace.forgetToSheafedSpace.{u} ‚ãô SheafedSpace.forget CommRingCatMax.{u, u}) ‚ãô\n      forget TopCat.{u}) x\n\n"}
