{"name":"AccPt.nhds_inter","module":"Mathlib.Topology.Perfect","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nC : Set Œ±\nx : Œ±\nU : Set Œ±\nh_acc : AccPt x (Filter.principal C)\nhU : Membership.mem (nhds x) U\n‚ä¢ AccPt x (Filter.principal (Inter.inter U C))","decl":"/-- If `x` is an accumulation point of a set `C` and `U` is a neighborhood of `x`,\nthen `x` is an accumulation point of `U ‚à© C`. -/\ntheorem AccPt.nhds_inter {x : Œ±} {U : Set Œ±} (h_acc : AccPt x (ùìü C)) (hU : U ‚àà ùìù x) :\n    AccPt x (ùìü (U ‚à© C)) := by\n  have : ùìù[‚â†] x ‚â§ ùìü U := by\n    rw [le_principal_iff]\n    exact mem_nhdsWithin_of_mem_nhds hU\n  rw [AccPt, ‚Üê inf_principal, ‚Üê inf_assoc, inf_of_le_left this]\n  exact h_acc\n\n"}
{"name":"perfect_def","module":"Mathlib.Topology.Perfect","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nC : Set Œ±\n‚ä¢ Iff (Perfect C) (And (IsClosed C) (Preperfect C))","decl":"/-- A set `C` is called perfect if it is closed and all of its\npoints are accumulation points of itself.\nNote that we do not require `C` to be nonempty. -/\n@[mk_iff perfect_def]\nstructure Perfect (C : Set Œ±) : Prop where\n  closed : IsClosed C\n  acc : Preperfect C\n\n"}
{"name":"Perfect.acc","module":"Mathlib.Topology.Perfect","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nC : Set Œ±\nself : Perfect C\n‚ä¢ Preperfect C","decl":"/-- A set `C` is called perfect if it is closed and all of its\npoints are accumulation points of itself.\nNote that we do not require `C` to be nonempty. -/\n@[mk_iff perfect_def]\nstructure Perfect (C : Set Œ±) : Prop where\n  closed : IsClosed C\n  acc : Preperfect C\n\n"}
{"name":"Perfect.closed","module":"Mathlib.Topology.Perfect","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nC : Set Œ±\nself : Perfect C\n‚ä¢ IsClosed C","decl":"/-- A set `C` is called perfect if it is closed and all of its\npoints are accumulation points of itself.\nNote that we do not require `C` to be nonempty. -/\n@[mk_iff perfect_def]\nstructure Perfect (C : Set Œ±) : Prop where\n  closed : IsClosed C\n  acc : Preperfect C\n\n"}
{"name":"preperfect_iff_nhds","module":"Mathlib.Topology.Perfect","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nC : Set Œ±\n‚ä¢ Iff (Preperfect C) (‚àÄ (x : Œ±), Membership.mem C x ‚Üí ‚àÄ (U : Set Œ±), Membership.mem (nhds x) U ‚Üí Exists fun y => And (Membership.mem (Inter.inter U C) y) (Ne y x))","decl":"theorem preperfect_iff_nhds : Preperfect C ‚Üî ‚àÄ x ‚àà C, ‚àÄ U ‚àà ùìù x, ‚àÉ y ‚àà U ‚à© C, y ‚â† x := by\n  simp only [Preperfect, accPt_iff_nhds]\n\n"}
{"name":"perfectSpace_def","module":"Mathlib.Topology.Perfect","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\n‚ä¢ Iff (PerfectSpace Œ±) (Preperfect Set.univ)","decl":"/--\nA topological space `X` is said to be perfect if its universe is a perfect set.\nEquivalently, this means that `ùìù[‚â†] x ‚â† ‚ä•` for every point `x : X`.\n-/\n@[mk_iff perfectSpace_def]\nclass PerfectSpace : Prop where\n  univ_preperfect : Preperfect (Set.univ : Set Œ±)\n\n"}
{"name":"PerfectSpace.univ_preperfect","module":"Mathlib.Topology.Perfect","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nself : PerfectSpace Œ±\n‚ä¢ Preperfect Set.univ","decl":"/--\nA topological space `X` is said to be perfect if its universe is a perfect set.\nEquivalently, this means that `ùìù[‚â†] x ‚â† ‚ä•` for every point `x : X`.\n-/\n@[mk_iff perfectSpace_def]\nclass PerfectSpace : Prop where\n  univ_preperfect : Preperfect (Set.univ : Set Œ±)\n\n"}
{"name":"PerfectSpace.univ_perfect","module":"Mathlib.Topology.Perfect","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : PerfectSpace Œ±\n‚ä¢ Perfect Set.univ","decl":"theorem PerfectSpace.univ_perfect [PerfectSpace Œ±] : Perfect (Set.univ : Set Œ±) :=\n  ‚ü®isClosed_univ, PerfectSpace.univ_preperfect‚ü©\n\n"}
{"name":"Preperfect.open_inter","module":"Mathlib.Topology.Perfect","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nC U : Set Œ±\nhC : Preperfect C\nhU : IsOpen U\n‚ä¢ Preperfect (Inter.inter U C)","decl":"/-- The intersection of a preperfect set and an open set is preperfect. -/\ntheorem Preperfect.open_inter {U : Set Œ±} (hC : Preperfect C) (hU : IsOpen U) :\n    Preperfect (U ‚à© C) := by\n  rintro x ‚ü®xU, xC‚ü©\n  apply (hC _ xC).nhds_inter\n  exact hU.mem_nhds xU\n\n"}
{"name":"Preperfect.perfect_closure","module":"Mathlib.Topology.Perfect","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nC : Set Œ±\nhC : Preperfect C\n‚ä¢ Perfect (closure C)","decl":"/-- The closure of a preperfect set is perfect.\nFor a converse, see `preperfect_iff_perfect_closure`. -/\ntheorem Preperfect.perfect_closure (hC : Preperfect C) : Perfect (closure C) := by\n  constructor; ¬∑ exact isClosed_closure\n  intro x hx\n  by_cases h : x ‚àà C <;> apply AccPt.mono _ (principal_mono.mpr subset_closure)\n  ¬∑ exact hC _ h\n  have : {x}·∂ú ‚à© C = C := by simp [h]\n  rw [AccPt, nhdsWithin, inf_assoc, inf_principal, this]\n  rw [closure_eq_cluster_pts] at hx\n  exact hx\n\n"}
{"name":"preperfect_iff_perfect_closure","module":"Mathlib.Topology.Perfect","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\nC : Set Œ±\ninst‚úù : T1Space Œ±\n‚ä¢ Iff (Preperfect C) (Perfect (closure C))","decl":"/-- In a T1 space, being preperfect is equivalent to having perfect closure. -/\ntheorem preperfect_iff_perfect_closure [T1Space Œ±] : Preperfect C ‚Üî Perfect (closure C) := by\n  constructor <;> intro h\n  ¬∑ exact h.perfect_closure\n  intro x xC\n  have H : AccPt x (ùìü (closure C)) := h.acc _ (subset_closure xC)\n  rw [accPt_iff_frequently] at *\n  have : ‚àÄ y, y ‚â† x ‚àß y ‚àà closure C ‚Üí ‚àÉ·∂† z in ùìù y, z ‚â† x ‚àß z ‚àà C := by\n    rintro y ‚ü®hyx, yC‚ü©\n    simp only [‚Üê mem_compl_singleton_iff, and_comm, ‚Üê frequently_nhdsWithin_iff,\n      hyx.nhdsWithin_compl_singleton, ‚Üê mem_closure_iff_frequently]\n    exact yC\n  rw [‚Üê frequently_frequently_nhds]\n  exact H.mono this\n\n"}
{"name":"Perfect.closure_nhds_inter","module":"Mathlib.Topology.Perfect","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nC U : Set Œ±\nhC : Perfect C\nx : Œ±\nxC : Membership.mem C x\nxU : Membership.mem U x\nUop : IsOpen U\n‚ä¢ And (Perfect (closure (Inter.inter U C))) (closure (Inter.inter U C)).Nonempty","decl":"theorem Perfect.closure_nhds_inter {U : Set Œ±} (hC : Perfect C) (x : Œ±) (xC : x ‚àà C) (xU : x ‚àà U)\n    (Uop : IsOpen U) : Perfect (closure (U ‚à© C)) ‚àß (closure (U ‚à© C)).Nonempty := by\n  constructor\n  ¬∑ apply Preperfect.perfect_closure\n    exact hC.acc.open_inter Uop\n  apply Nonempty.closure\n  exact ‚ü®x, ‚ü®xU, xC‚ü©‚ü©\n\n"}
{"name":"Perfect.splitting","module":"Mathlib.Topology.Perfect","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\nC : Set Œ±\ninst‚úù : T25Space Œ±\nhC : Perfect C\nhnonempty : C.Nonempty\n‚ä¢ Exists fun C‚ÇÄ => Exists fun C‚ÇÅ => And (And (Perfect C‚ÇÄ) (And C‚ÇÄ.Nonempty (HasSubset.Subset C‚ÇÄ C))) (And (And (Perfect C‚ÇÅ) (And C‚ÇÅ.Nonempty (HasSubset.Subset C‚ÇÅ C))) (Disjoint C‚ÇÄ C‚ÇÅ))","decl":"/-- Given a perfect nonempty set in a T2.5 space, we can find two disjoint perfect subsets.\nThis is the main inductive step in the proof of the Cantor-Bendixson Theorem. -/\ntheorem Perfect.splitting [T25Space Œ±] (hC : Perfect C) (hnonempty : C.Nonempty) :\n    ‚àÉ C‚ÇÄ C‚ÇÅ : Set Œ±,\n    (Perfect C‚ÇÄ ‚àß C‚ÇÄ.Nonempty ‚àß C‚ÇÄ ‚äÜ C) ‚àß (Perfect C‚ÇÅ ‚àß C‚ÇÅ.Nonempty ‚àß C‚ÇÅ ‚äÜ C) ‚àß Disjoint C‚ÇÄ C‚ÇÅ := by\n  cases' hnonempty with y yC\n  obtain ‚ü®x, xC, hxy‚ü© : ‚àÉ x ‚àà C, x ‚â† y := by\n    have := hC.acc _ yC\n    rw [accPt_iff_nhds] at this\n    rcases this univ univ_mem with ‚ü®x, xC, hxy‚ü©\n    exact ‚ü®x, xC.2, hxy‚ü©\n  obtain ‚ü®U, xU, Uop, V, yV, Vop, hUV‚ü© := exists_open_nhds_disjoint_closure hxy\n  use closure (U ‚à© C), closure (V ‚à© C)\n  constructor <;> rw [‚Üê and_assoc]\n  ¬∑ refine ‚ü®hC.closure_nhds_inter x xC xU Uop, ?_‚ü©\n    rw [hC.closed.closure_subset_iff]\n    exact inter_subset_right\n  constructor\n  ¬∑ refine ‚ü®hC.closure_nhds_inter y yC yV Vop, ?_‚ü©\n    rw [hC.closed.closure_subset_iff]\n    exact inter_subset_right\n  apply Disjoint.mono _ _ hUV <;> apply closure_mono <;> exact inter_subset_left\n\n"}
{"name":"IsPreconnected.preperfect_of_nontrivial","module":"Mathlib.Topology.Perfect","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : T1Space Œ±\nU : Set Œ±\nhu : U.Nontrivial\nh : IsPreconnected U\n‚ä¢ Preperfect U","decl":"lemma IsPreconnected.preperfect_of_nontrivial [T1Space Œ±] {U : Set Œ±} (hu : U.Nontrivial)\n    (h : IsPreconnected U) : Preperfect U := by\n  intro x hx\n  rw [isPreconnected_closed_iff] at h\n  specialize h {x} (closure (U \\ {x})) isClosed_singleton isClosed_closure ?_ ?_ ?_\n  ¬∑ trans {x} ‚à™ (U \\ {x})\n    ¬∑ simp\n    apply Set.union_subset_union_right\n    exact subset_closure\n  ¬∑ exact Set.inter_singleton_nonempty.mpr hx\n  ¬∑ obtain ‚ü®y, hy‚ü© := Set.Nontrivial.exists_ne hu x\n    use y\n    simp only [Set.mem_inter_iff, hy, true_and]\n    apply subset_closure\n    simp [hy]\n  ¬∑ apply Set.Nonempty.right at h\n    rw [Set.singleton_inter_nonempty, mem_closure_iff_clusterPt, ‚Üê acc_principal_iff_cluster] at h\n    exact h\n\n"}
{"name":"exists_countable_union_perfect_of_isClosed","module":"Mathlib.Topology.Perfect","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\nC : Set Œ±\ninst‚úù : SecondCountableTopology Œ±\nhclosed : IsClosed C\n‚ä¢ Exists fun V => Exists fun D => And V.Countable (And (Perfect D) (Eq C (Union.union V D)))","decl":"/-- The **Cantor-Bendixson Theorem**: Any closed subset of a second countable space\ncan be written as the union of a countable set and a perfect set. -/\ntheorem exists_countable_union_perfect_of_isClosed [SecondCountableTopology Œ±]\n    (hclosed : IsClosed C) : ‚àÉ V D : Set Œ±, V.Countable ‚àß Perfect D ‚àß C = V ‚à™ D := by\n  obtain ‚ü®b, bct, _, bbasis‚ü© := TopologicalSpace.exists_countable_basis Œ±\n  let v := { U ‚àà b | (U ‚à© C).Countable }\n  let V := ‚ãÉ U ‚àà v, U\n  let D := C \\ V\n  have Vct : (V ‚à© C).Countable := by\n    simp only [V, iUnion_inter, mem_sep_iff]\n    apply Countable.biUnion\n    ¬∑ exact Countable.mono inter_subset_left bct\n    ¬∑ exact inter_subset_right\n  refine ‚ü®V ‚à© C, D, Vct, ‚ü®?_, ?_‚ü©, ?_‚ü©\n  ¬∑ refine hclosed.sdiff (isOpen_biUnion fun _ ‚Ü¶ ?_)\n    exact fun ‚ü®Ub, _‚ü© ‚Ü¶ IsTopologicalBasis.isOpen bbasis Ub\n  ¬∑ rw [preperfect_iff_nhds]\n    intro x xD E xE\n    have : ¬¨(E ‚à© D).Countable := by\n      intro h\n      obtain ‚ü®U, hUb, xU, hU‚ü© : ‚àÉ U ‚àà b, x ‚àà U ‚àß U ‚äÜ E :=\n        (IsTopologicalBasis.mem_nhds_iff bbasis).mp xE\n      have hU_cnt : (U ‚à© C).Countable := by\n        apply @Countable.mono _ _ (E ‚à© D ‚à™ V ‚à© C)\n        ¬∑ rintro y ‚ü®yU, yC‚ü©\n          by_cases h : y ‚àà V\n          ¬∑ exact mem_union_right _ (mem_inter h yC)\n          ¬∑ exact mem_union_left _ (mem_inter (hU yU) ‚ü®yC, h‚ü©)\n        exact Countable.union h Vct\n      have : U ‚àà v := ‚ü®hUb, hU_cnt‚ü©\n      apply xD.2\n      exact mem_biUnion this xU\n    by_contra! h\n    exact absurd (Countable.mono h (Set.countable_singleton _)) this\n  ¬∑ rw [inter_comm, inter_union_diff]\n\n"}
{"name":"exists_perfect_nonempty_of_isClosed_of_not_countable","module":"Mathlib.Topology.Perfect","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : TopologicalSpace Œ±\nC : Set Œ±\ninst‚úù : SecondCountableTopology Œ±\nhclosed : IsClosed C\nhunc : Not C.Countable\n‚ä¢ Exists fun D => And (Perfect D) (And D.Nonempty (HasSubset.Subset D C))","decl":"/-- Any uncountable closed set in a second countable space contains a nonempty perfect subset. -/\ntheorem exists_perfect_nonempty_of_isClosed_of_not_countable [SecondCountableTopology Œ±]\n    (hclosed : IsClosed C) (hunc : ¬¨C.Countable) : ‚àÉ D : Set Œ±, Perfect D ‚àß D.Nonempty ‚àß D ‚äÜ C := by\n  rcases exists_countable_union_perfect_of_isClosed hclosed with ‚ü®V, D, Vct, Dperf, VD‚ü©\n  refine ‚ü®D, ‚ü®Dperf, ?_‚ü©‚ü©\n  constructor\n  ¬∑ rw [nonempty_iff_ne_empty]\n    by_contra h\n    rw [h, union_empty] at VD\n    rw [VD] at hunc\n    contradiction\n  rw [VD]\n  exact subset_union_right\n\n"}
{"name":"perfectSpace_iff_forall_not_isolated","module":"Mathlib.Topology.Perfect","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (PerfectSpace X) (‚àÄ (x : X), (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).NeBot)","decl":"theorem perfectSpace_iff_forall_not_isolated : PerfectSpace X ‚Üî ‚àÄ x : X, Filter.NeBot (ùìù[‚â†] x) := by\n  simp [perfectSpace_def, Preperfect, AccPt]\n\n"}
{"name":"PerfectSpace.not_isolated","module":"Mathlib.Topology.Perfect","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : PerfectSpace X\nx : X\n‚ä¢ (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).NeBot","decl":"instance PerfectSpace.not_isolated [PerfectSpace X] (x : X) : Filter.NeBot (ùìù[‚â†] x) :=\n  perfectSpace_iff_forall_not_isolated.mp ‚Äπ_‚Ä∫ x\n\n"}
