{"name":"Basis.tensorProduct_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nN : Type u_4\nι : Type u_5\nκ : Type u_6\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring S\ninst✝⁶ : Algebra R S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module S M\ninst✝² : IsScalarTower R S M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nb : Basis ι S M\nc : Basis κ R N\ni : ι\nj : κ\n⊢ Eq ((b.tensorProduct c) { fst := i, snd := j }) (TensorProduct.tmul R (b i) (c j))","decl":"@[simp]\ntheorem Basis.tensorProduct_apply (b : Basis ι S M) (c : Basis κ R N) (i : ι) (j : κ) :\n    Basis.tensorProduct b c (i, j) = b i ⊗ₜ c j := by\n  simp [Basis.tensorProduct]\n\n"}
{"name":"Basis.tensorProduct_apply'","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nN : Type u_4\nι : Type u_5\nκ : Type u_6\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring S\ninst✝⁶ : Algebra R S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module S M\ninst✝² : IsScalarTower R S M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nb : Basis ι S M\nc : Basis κ R N\ni : Prod ι κ\n⊢ Eq ((b.tensorProduct c) i) (TensorProduct.tmul R (b i.1) (c i.2))","decl":"theorem Basis.tensorProduct_apply' (b : Basis ι S M) (c : Basis κ R N) (i : ι × κ) :\n    Basis.tensorProduct b c i = b i.1 ⊗ₜ c i.2 := by\n  simp [Basis.tensorProduct]\n\n"}
{"name":"Basis.tensorProduct_repr_tmul_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nN : Type u_4\nι : Type u_5\nκ : Type u_6\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring S\ninst✝⁶ : Algebra R S\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module S M\ninst✝² : IsScalarTower R S M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nb : Basis ι S M\nc : Basis κ R N\nm : M\nn : N\ni : ι\nj : κ\n⊢ Eq (((b.tensorProduct c).repr (TensorProduct.tmul R m n)) { fst := i, snd := j }) (HSMul.hSMul ((c.repr n) j) ((b.repr m) i))","decl":"@[simp]\ntheorem Basis.tensorProduct_repr_tmul_apply (b : Basis ι S M) (c : Basis κ R N) (m : M) (n : N)\n    (i : ι) (j : κ) :\n    (Basis.tensorProduct b c).repr (m ⊗ₜ n) (i, j) = c.repr n j • b.repr m i := by\n  simp [Basis.tensorProduct, mul_comm]\n\n"}
{"name":"Basis.baseChange_repr_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nι : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nS : Type u_7\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nb : Basis ι R M\nx : S\ny : M\ni : ι\n⊢ Eq (((Basis.baseChange S b).repr (TensorProduct.tmul R x y)) i) (HSMul.hSMul ((b.repr y) i) x)","decl":"@[simp]\nlemma Basis.baseChange_repr_tmul (b : Basis ι R M) (x y i) :\n    (b.baseChange S).repr (x ⊗ₜ y) i = b.repr y i • x := by\n  simp [Basis.baseChange, Basis.tensorProduct]\n\n"}
{"name":"Basis.baseChange_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nι : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nS : Type u_7\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nb : Basis ι R M\ni : ι\n⊢ Eq ((Basis.baseChange S b) i) (TensorProduct.tmul R 1 (b i))","decl":"@[simp]\nlemma Basis.baseChange_apply (b : Basis ι R M) (i) :\n    b.baseChange S i = 1 ⊗ₜ b i := by\n  simp [Basis.baseChange, Basis.tensorProduct]\n\n"}
{"name":"TensorProduct.equivFinsuppOfBasisRight_apply_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nκ : Type u_6\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : DecidableEq κ\n𝒞 : Basis κ R N\nm : M\nn : N\n⊢ Eq ((TensorProduct.equivFinsuppOfBasisRight 𝒞) (TensorProduct.tmul R m n)) (Finsupp.mapRange (fun x => HSMul.hSMul x m) ⋯ (𝒞.repr n))","decl":"@[simp]\nlemma TensorProduct.equivFinsuppOfBasisRight_apply_tmul (m : M) (n : N) :\n    (TensorProduct.equivFinsuppOfBasisRight 𝒞) (m ⊗ₜ n) =\n    (𝒞.repr n).mapRange (· • m) (zero_smul _ _) := by\n  ext; simp [equivFinsuppOfBasisRight]\n\n"}
{"name":"TensorProduct.equivFinsuppOfBasisRight_apply_tmul_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nκ : Type u_6\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : DecidableEq κ\n𝒞 : Basis κ R N\nm : M\nn : N\ni : κ\n⊢ Eq (((TensorProduct.equivFinsuppOfBasisRight 𝒞) (TensorProduct.tmul R m n)) i) (HSMul.hSMul ((𝒞.repr n) i) m)","decl":"lemma TensorProduct.equivFinsuppOfBasisRight_apply_tmul_apply\n    (m : M) (n : N) (i : κ) :\n    (TensorProduct.equivFinsuppOfBasisRight 𝒞) (m ⊗ₜ n) i =\n    𝒞.repr n i • m := by\n  simp only [equivFinsuppOfBasisRight_apply_tmul, Finsupp.mapRange_apply]\n\n"}
{"name":"TensorProduct.equivFinsuppOfBasisRight_symm","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nκ : Type u_6\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : DecidableEq κ\n𝒞 : Basis κ R N\n⊢ Eq (↑(TensorProduct.equivFinsuppOfBasisRight 𝒞).symm) ((Finsupp.lsum R) fun i => (TensorProduct.mk R M N).flip (𝒞 i))","decl":"lemma TensorProduct.equivFinsuppOfBasisRight_symm :\n    (TensorProduct.equivFinsuppOfBasisRight 𝒞).symm.toLinearMap =\n    Finsupp.lsum R fun i ↦ (TensorProduct.mk R M N).flip (𝒞 i) := by\n  ext; simp [equivFinsuppOfBasisRight]\n\n"}
{"name":"TensorProduct.equivFinsuppOfBasisRight_symm_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nκ : Type u_6\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : DecidableEq κ\n𝒞 : Basis κ R N\nb : Finsupp κ M\n⊢ Eq ((TensorProduct.equivFinsuppOfBasisRight 𝒞).symm b) (b.sum fun i m => TensorProduct.tmul R m (𝒞 i))","decl":"@[simp]\nlemma TensorProduct.equivFinsuppOfBasisRight_symm_apply (b : κ →₀ M) :\n    (TensorProduct.equivFinsuppOfBasisRight 𝒞).symm b = b.sum fun i m ↦ m ⊗ₜ 𝒞 i :=\n  congr($(TensorProduct.equivFinsuppOfBasisRight_symm 𝒞) b)\n\n"}
{"name":"TensorProduct.sum_tmul_basis_right_injective","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nκ : Type u_6\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\n𝒞 : Basis κ R N\n⊢ Function.Injective ⇑((Finsupp.lsum R) fun i => (TensorProduct.mk R M N).flip (𝒞 i))","decl":"omit [DecidableEq κ] in\nlemma TensorProduct.sum_tmul_basis_right_injective :\n    Function.Injective (Finsupp.lsum R fun i ↦ (TensorProduct.mk R M N).flip (𝒞 i)) :=\n  have := Classical.decEq κ\n  (equivFinsuppOfBasisRight_symm (M := M) 𝒞).symm ▸\n    (TensorProduct.equivFinsuppOfBasisRight 𝒞).symm.injective\n\n"}
{"name":"TensorProduct.sum_tmul_basis_right_eq_zero","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nκ : Type u_6\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\n𝒞 : Basis κ R N\nb : Finsupp κ M\nh : Eq (b.sum fun i m => TensorProduct.tmul R m (𝒞 i)) 0\n⊢ Eq b 0","decl":"omit [DecidableEq κ] in\nlemma TensorProduct.sum_tmul_basis_right_eq_zero\n    (b : κ →₀ M) (h : (b.sum fun i m ↦ m ⊗ₜ[R] 𝒞 i) = 0) : b = 0 :=\n  have := Classical.decEq κ\n  (TensorProduct.equivFinsuppOfBasisRight 𝒞).symm.injective (a₂ := 0) <| by simpa\n\n"}
{"name":"TensorProduct.equivFinsuppOfBasisLeft_apply_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nι : Type u_5\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : DecidableEq ι\nℬ : Basis ι R M\nm : M\nn : N\n⊢ Eq ((TensorProduct.equivFinsuppOfBasisLeft ℬ) (TensorProduct.tmul R m n)) (Finsupp.mapRange (fun x => HSMul.hSMul x n) ⋯ (ℬ.repr m))","decl":"@[simp]\nlemma TensorProduct.equivFinsuppOfBasisLeft_apply_tmul (m : M) (n : N) :\n    (TensorProduct.equivFinsuppOfBasisLeft ℬ) (m ⊗ₜ n) =\n    (ℬ.repr m).mapRange (· • n) (zero_smul _ _) := by\n  ext; simp [equivFinsuppOfBasisLeft]\n\n"}
{"name":"TensorProduct.equivFinsuppOfBasisLeft_apply_tmul_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nι : Type u_5\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : DecidableEq ι\nℬ : Basis ι R M\nm : M\nn : N\ni : ι\n⊢ Eq (((TensorProduct.equivFinsuppOfBasisLeft ℬ) (TensorProduct.tmul R m n)) i) (HSMul.hSMul ((ℬ.repr m) i) n)","decl":"lemma TensorProduct.equivFinsuppOfBasisLeft_apply_tmul_apply\n    (m : M) (n : N) (i : ι) :\n    (TensorProduct.equivFinsuppOfBasisLeft ℬ) (m ⊗ₜ n) i =\n    ℬ.repr m i • n := by\n  simp only [equivFinsuppOfBasisLeft_apply_tmul, Finsupp.mapRange_apply]\n\n"}
{"name":"TensorProduct.equivFinsuppOfBasisLeft_symm","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nι : Type u_5\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : DecidableEq ι\nℬ : Basis ι R M\n⊢ Eq (↑(TensorProduct.equivFinsuppOfBasisLeft ℬ).symm) ((Finsupp.lsum R) fun i => (TensorProduct.mk R M N) (ℬ i))","decl":"lemma TensorProduct.equivFinsuppOfBasisLeft_symm :\n    (TensorProduct.equivFinsuppOfBasisLeft ℬ).symm.toLinearMap =\n    Finsupp.lsum R fun i ↦ (TensorProduct.mk R M N) (ℬ i) := by\n  ext; simp [equivFinsuppOfBasisLeft]\n\n"}
{"name":"TensorProduct.equivFinsuppOfBasisLeft_symm_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nι : Type u_5\ninst✝⁵ : CommSemiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : DecidableEq ι\nℬ : Basis ι R M\nb : Finsupp ι N\n⊢ Eq ((TensorProduct.equivFinsuppOfBasisLeft ℬ).symm b) (b.sum fun i n => TensorProduct.tmul R (ℬ i) n)","decl":"@[simp]\nlemma TensorProduct.equivFinsuppOfBasisLeft_symm_apply (b : ι →₀ N) :\n    (TensorProduct.equivFinsuppOfBasisLeft ℬ).symm b = b.sum fun i n ↦ ℬ i ⊗ₜ n :=\n  congr($(TensorProduct.equivFinsuppOfBasisLeft_symm ℬ) b)\n\n"}
{"name":"TensorProduct.eq_repr_basis_right","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nκ : Type u_6\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\n𝒞 : Basis κ R N\nx : TensorProduct R M N\n⊢ Exists fun b => Eq (b.sum fun i m => TensorProduct.tmul R m (𝒞 i)) x","decl":"omit [DecidableEq κ] in\n/-- Elements in `M ⊗ N` can be represented by sum of elements in `M` tensor elements of basis of\n`N`. -/\nlemma TensorProduct.eq_repr_basis_right :\n    ∃ b : κ →₀ M, b.sum (fun i m ↦ m ⊗ₜ 𝒞 i) = x := by\n  classical simpa using (TensorProduct.equivFinsuppOfBasisRight 𝒞).symm.surjective x\n\n"}
{"name":"TensorProduct.eq_repr_basis_left","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nι : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nℬ : Basis ι R M\nx : TensorProduct R M N\n⊢ Exists fun c => Eq (c.sum fun i n => TensorProduct.tmul R (ℬ i) n) x","decl":"omit [DecidableEq ι] in\n/-- Elements in `M ⊗ N` can be represented by sum of elements of basis of `M` tensor elements of\n  `N`.-/\nlemma TensorProduct.eq_repr_basis_left :\n    ∃ (c : ι →₀ N), (c.sum fun i n ↦ ℬ i ⊗ₜ n) = x := by\n  classical obtain ⟨c, rfl⟩ := (TensorProduct.equivFinsuppOfBasisLeft ℬ).symm.surjective x\n  exact ⟨c, (TensorProduct.comm R M N).injective <| by simp [Finsupp.sum]⟩\n\n"}
{"name":"TensorProduct.sum_tmul_basis_left_injective","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nι : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nℬ : Basis ι R M\n⊢ Function.Injective ⇑((Finsupp.lsum R) fun i => (TensorProduct.mk R M N) (ℬ i))","decl":"omit [DecidableEq ι] in\nlemma TensorProduct.sum_tmul_basis_left_injective :\n    Function.Injective (Finsupp.lsum R fun i ↦ (TensorProduct.mk R M N) (ℬ i)) :=\n  have := Classical.decEq ι\n  (equivFinsuppOfBasisLeft_symm (N := N) ℬ).symm ▸\n    (TensorProduct.equivFinsuppOfBasisLeft ℬ).symm.injective\n\n"}
{"name":"TensorProduct.sum_tmul_basis_left_eq_zero","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nι : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nℬ : Basis ι R M\nb : Finsupp ι N\nh : Eq (b.sum fun i n => TensorProduct.tmul R (ℬ i) n) 0\n⊢ Eq b 0","decl":"omit [DecidableEq ι] in\nlemma TensorProduct.sum_tmul_basis_left_eq_zero\n    (b : ι →₀ N) (h : (b.sum fun i n ↦ ℬ i ⊗ₜ[R] n) = 0) : b = 0 :=\n  have := Classical.decEq ι\n  (TensorProduct.equivFinsuppOfBasisLeft ℬ).symm.injective (a₂ := 0) <| by simpa\n\n"}
