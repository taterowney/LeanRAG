{"name":"Basis.tensorProduct_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nN : Type u_4\nÎ¹ : Type u_5\nÎº : Type u_6\ninstâœâ¸ : CommSemiring R\ninstâœâ· : Semiring S\ninstâœâ¶ : Algebra R S\ninstâœâµ : AddCommMonoid M\ninstâœâ´ : Module R M\ninstâœÂ³ : Module S M\ninstâœÂ² : IsScalarTower R S M\ninstâœÂ¹ : AddCommMonoid N\ninstâœ : Module R N\nb : Basis Î¹ S M\nc : Basis Îº R N\ni : Î¹\nj : Îº\nâŠ¢ Eq ((b.tensorProduct c) { fst := i, snd := j }) (TensorProduct.tmul R (b i) (c j))","decl":"@[simp]\ntheorem Basis.tensorProduct_apply (b : Basis Î¹ S M) (c : Basis Îº R N) (i : Î¹) (j : Îº) :\n    Basis.tensorProduct b c (i, j) = b i âŠ—â‚œ c j := by\n  simp [Basis.tensorProduct]\n\n"}
{"name":"Basis.tensorProduct_apply'","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nN : Type u_4\nÎ¹ : Type u_5\nÎº : Type u_6\ninstâœâ¸ : CommSemiring R\ninstâœâ· : Semiring S\ninstâœâ¶ : Algebra R S\ninstâœâµ : AddCommMonoid M\ninstâœâ´ : Module R M\ninstâœÂ³ : Module S M\ninstâœÂ² : IsScalarTower R S M\ninstâœÂ¹ : AddCommMonoid N\ninstâœ : Module R N\nb : Basis Î¹ S M\nc : Basis Îº R N\ni : Prod Î¹ Îº\nâŠ¢ Eq ((b.tensorProduct c) i) (TensorProduct.tmul R (b i.1) (c i.2))","decl":"theorem Basis.tensorProduct_apply' (b : Basis Î¹ S M) (c : Basis Îº R N) (i : Î¹ Ã— Îº) :\n    Basis.tensorProduct b c i = b i.1 âŠ—â‚œ c i.2 := by\n  simp [Basis.tensorProduct]\n\n"}
{"name":"Basis.tensorProduct_repr_tmul_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nN : Type u_4\nÎ¹ : Type u_5\nÎº : Type u_6\ninstâœâ¸ : CommSemiring R\ninstâœâ· : Semiring S\ninstâœâ¶ : Algebra R S\ninstâœâµ : AddCommMonoid M\ninstâœâ´ : Module R M\ninstâœÂ³ : Module S M\ninstâœÂ² : IsScalarTower R S M\ninstâœÂ¹ : AddCommMonoid N\ninstâœ : Module R N\nb : Basis Î¹ S M\nc : Basis Îº R N\nm : M\nn : N\ni : Î¹\nj : Îº\nâŠ¢ Eq (((b.tensorProduct c).repr (TensorProduct.tmul R m n)) { fst := i, snd := j }) (HSMul.hSMul ((c.repr n) j) ((b.repr m) i))","decl":"@[simp]\ntheorem Basis.tensorProduct_repr_tmul_apply (b : Basis Î¹ S M) (c : Basis Îº R N) (m : M) (n : N)\n    (i : Î¹) (j : Îº) :\n    (Basis.tensorProduct b c).repr (m âŠ—â‚œ n) (i, j) = c.repr n j â€¢ b.repr m i := by\n  simp [Basis.tensorProduct, mul_comm]\n\n"}
{"name":"Basis.baseChange_repr_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nÎ¹ : Type u_5\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\nS : Type u_7\ninstâœÂ¹ : Semiring S\ninstâœ : Algebra R S\nb : Basis Î¹ R M\nx : S\ny : M\ni : Î¹\nâŠ¢ Eq (((Basis.baseChange S b).repr (TensorProduct.tmul R x y)) i) (HSMul.hSMul ((b.repr y) i) x)","decl":"@[simp]\nlemma Basis.baseChange_repr_tmul (b : Basis Î¹ R M) (x y i) :\n    (b.baseChange S).repr (x âŠ—â‚œ y) i = b.repr y i â€¢ x := by\n  simp [Basis.baseChange, Basis.tensorProduct]\n\n"}
{"name":"Basis.baseChange_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nÎ¹ : Type u_5\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\nS : Type u_7\ninstâœÂ¹ : Semiring S\ninstâœ : Algebra R S\nb : Basis Î¹ R M\ni : Î¹\nâŠ¢ Eq ((Basis.baseChange S b) i) (TensorProduct.tmul R 1 (b i))","decl":"@[simp]\nlemma Basis.baseChange_apply (b : Basis Î¹ R M) (i) :\n    b.baseChange S i = 1 âŠ—â‚œ b i := by\n  simp [Basis.baseChange, Basis.tensorProduct]\n\n"}
{"name":"TensorProduct.equivFinsuppOfBasisRight_apply_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nÎº : Type u_6\ninstâœâµ : CommSemiring R\ninstâœâ´ : AddCommMonoid M\ninstâœÂ³ : Module R M\ninstâœÂ² : AddCommMonoid N\ninstâœÂ¹ : Module R N\ninstâœ : DecidableEq Îº\nğ’ : Basis Îº R N\nm : M\nn : N\nâŠ¢ Eq ((TensorProduct.equivFinsuppOfBasisRight ğ’) (TensorProduct.tmul R m n)) (Finsupp.mapRange (fun x => HSMul.hSMul x m) â‹¯ (ğ’.repr n))","decl":"@[simp]\nlemma TensorProduct.equivFinsuppOfBasisRight_apply_tmul (m : M) (n : N) :\n    (TensorProduct.equivFinsuppOfBasisRight ğ’) (m âŠ—â‚œ n) =\n    (ğ’.repr n).mapRange (Â· â€¢ m) (zero_smul _ _) := by\n  ext; simp [equivFinsuppOfBasisRight]\n\n"}
{"name":"TensorProduct.equivFinsuppOfBasisRight_apply_tmul_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nÎº : Type u_6\ninstâœâµ : CommSemiring R\ninstâœâ´ : AddCommMonoid M\ninstâœÂ³ : Module R M\ninstâœÂ² : AddCommMonoid N\ninstâœÂ¹ : Module R N\ninstâœ : DecidableEq Îº\nğ’ : Basis Îº R N\nm : M\nn : N\ni : Îº\nâŠ¢ Eq (((TensorProduct.equivFinsuppOfBasisRight ğ’) (TensorProduct.tmul R m n)) i) (HSMul.hSMul ((ğ’.repr n) i) m)","decl":"lemma TensorProduct.equivFinsuppOfBasisRight_apply_tmul_apply\n    (m : M) (n : N) (i : Îº) :\n    (TensorProduct.equivFinsuppOfBasisRight ğ’) (m âŠ—â‚œ n) i =\n    ğ’.repr n i â€¢ m := by\n  simp only [equivFinsuppOfBasisRight_apply_tmul, Finsupp.mapRange_apply]\n\n"}
{"name":"TensorProduct.equivFinsuppOfBasisRight_symm","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nÎº : Type u_6\ninstâœâµ : CommSemiring R\ninstâœâ´ : AddCommMonoid M\ninstâœÂ³ : Module R M\ninstâœÂ² : AddCommMonoid N\ninstâœÂ¹ : Module R N\ninstâœ : DecidableEq Îº\nğ’ : Basis Îº R N\nâŠ¢ Eq (â†‘(TensorProduct.equivFinsuppOfBasisRight ğ’).symm) ((Finsupp.lsum R) fun i => (TensorProduct.mk R M N).flip (ğ’ i))","decl":"lemma TensorProduct.equivFinsuppOfBasisRight_symm :\n    (TensorProduct.equivFinsuppOfBasisRight ğ’).symm.toLinearMap =\n    Finsupp.lsum R fun i â†¦ (TensorProduct.mk R M N).flip (ğ’ i) := by\n  ext; simp [equivFinsuppOfBasisRight]\n\n"}
{"name":"TensorProduct.equivFinsuppOfBasisRight_symm_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nÎº : Type u_6\ninstâœâµ : CommSemiring R\ninstâœâ´ : AddCommMonoid M\ninstâœÂ³ : Module R M\ninstâœÂ² : AddCommMonoid N\ninstâœÂ¹ : Module R N\ninstâœ : DecidableEq Îº\nğ’ : Basis Îº R N\nb : Finsupp Îº M\nâŠ¢ Eq ((TensorProduct.equivFinsuppOfBasisRight ğ’).symm b) (b.sum fun i m => TensorProduct.tmul R m (ğ’ i))","decl":"@[simp]\nlemma TensorProduct.equivFinsuppOfBasisRight_symm_apply (b : Îº â†’â‚€ M) :\n    (TensorProduct.equivFinsuppOfBasisRight ğ’).symm b = b.sum fun i m â†¦ m âŠ—â‚œ ğ’ i :=\n  congr($(TensorProduct.equivFinsuppOfBasisRight_symm ğ’) b)\n\n"}
{"name":"TensorProduct.sum_tmul_basis_right_injective","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nÎº : Type u_6\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\ninstâœÂ¹ : AddCommMonoid N\ninstâœ : Module R N\nğ’ : Basis Îº R N\nâŠ¢ Function.Injective â‡‘((Finsupp.lsum R) fun i => (TensorProduct.mk R M N).flip (ğ’ i))","decl":"omit [DecidableEq Îº] in\nlemma TensorProduct.sum_tmul_basis_right_injective :\n    Function.Injective (Finsupp.lsum R fun i â†¦ (TensorProduct.mk R M N).flip (ğ’ i)) :=\n  have := Classical.decEq Îº\n  (equivFinsuppOfBasisRight_symm (M := M) ğ’).symm â–¸\n    (TensorProduct.equivFinsuppOfBasisRight ğ’).symm.injective\n\n"}
{"name":"TensorProduct.sum_tmul_basis_right_eq_zero","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nÎº : Type u_6\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\ninstâœÂ¹ : AddCommMonoid N\ninstâœ : Module R N\nğ’ : Basis Îº R N\nb : Finsupp Îº M\nh : Eq (b.sum fun i m => TensorProduct.tmul R m (ğ’ i)) 0\nâŠ¢ Eq b 0","decl":"omit [DecidableEq Îº] in\nlemma TensorProduct.sum_tmul_basis_right_eq_zero\n    (b : Îº â†’â‚€ M) (h : (b.sum fun i m â†¦ m âŠ—â‚œ[R] ğ’ i) = 0) : b = 0 :=\n  have := Classical.decEq Îº\n  (TensorProduct.equivFinsuppOfBasisRight ğ’).symm.injective (aâ‚‚ := 0) <| by simpa\n\n"}
{"name":"TensorProduct.equivFinsuppOfBasisLeft_apply_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nÎ¹ : Type u_5\ninstâœâµ : CommSemiring R\ninstâœâ´ : AddCommMonoid M\ninstâœÂ³ : Module R M\ninstâœÂ² : AddCommMonoid N\ninstâœÂ¹ : Module R N\ninstâœ : DecidableEq Î¹\nâ„¬ : Basis Î¹ R M\nm : M\nn : N\nâŠ¢ Eq ((TensorProduct.equivFinsuppOfBasisLeft â„¬) (TensorProduct.tmul R m n)) (Finsupp.mapRange (fun x => HSMul.hSMul x n) â‹¯ (â„¬.repr m))","decl":"@[simp]\nlemma TensorProduct.equivFinsuppOfBasisLeft_apply_tmul (m : M) (n : N) :\n    (TensorProduct.equivFinsuppOfBasisLeft â„¬) (m âŠ—â‚œ n) =\n    (â„¬.repr m).mapRange (Â· â€¢ n) (zero_smul _ _) := by\n  ext; simp [equivFinsuppOfBasisLeft]\n\n"}
{"name":"TensorProduct.equivFinsuppOfBasisLeft_apply_tmul_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nÎ¹ : Type u_5\ninstâœâµ : CommSemiring R\ninstâœâ´ : AddCommMonoid M\ninstâœÂ³ : Module R M\ninstâœÂ² : AddCommMonoid N\ninstâœÂ¹ : Module R N\ninstâœ : DecidableEq Î¹\nâ„¬ : Basis Î¹ R M\nm : M\nn : N\ni : Î¹\nâŠ¢ Eq (((TensorProduct.equivFinsuppOfBasisLeft â„¬) (TensorProduct.tmul R m n)) i) (HSMul.hSMul ((â„¬.repr m) i) n)","decl":"lemma TensorProduct.equivFinsuppOfBasisLeft_apply_tmul_apply\n    (m : M) (n : N) (i : Î¹) :\n    (TensorProduct.equivFinsuppOfBasisLeft â„¬) (m âŠ—â‚œ n) i =\n    â„¬.repr m i â€¢ n := by\n  simp only [equivFinsuppOfBasisLeft_apply_tmul, Finsupp.mapRange_apply]\n\n"}
{"name":"TensorProduct.equivFinsuppOfBasisLeft_symm","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nÎ¹ : Type u_5\ninstâœâµ : CommSemiring R\ninstâœâ´ : AddCommMonoid M\ninstâœÂ³ : Module R M\ninstâœÂ² : AddCommMonoid N\ninstâœÂ¹ : Module R N\ninstâœ : DecidableEq Î¹\nâ„¬ : Basis Î¹ R M\nâŠ¢ Eq (â†‘(TensorProduct.equivFinsuppOfBasisLeft â„¬).symm) ((Finsupp.lsum R) fun i => (TensorProduct.mk R M N) (â„¬ i))","decl":"lemma TensorProduct.equivFinsuppOfBasisLeft_symm :\n    (TensorProduct.equivFinsuppOfBasisLeft â„¬).symm.toLinearMap =\n    Finsupp.lsum R fun i â†¦ (TensorProduct.mk R M N) (â„¬ i) := by\n  ext; simp [equivFinsuppOfBasisLeft]\n\n"}
{"name":"TensorProduct.equivFinsuppOfBasisLeft_symm_apply","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nÎ¹ : Type u_5\ninstâœâµ : CommSemiring R\ninstâœâ´ : AddCommMonoid M\ninstâœÂ³ : Module R M\ninstâœÂ² : AddCommMonoid N\ninstâœÂ¹ : Module R N\ninstâœ : DecidableEq Î¹\nâ„¬ : Basis Î¹ R M\nb : Finsupp Î¹ N\nâŠ¢ Eq ((TensorProduct.equivFinsuppOfBasisLeft â„¬).symm b) (b.sum fun i n => TensorProduct.tmul R (â„¬ i) n)","decl":"@[simp]\nlemma TensorProduct.equivFinsuppOfBasisLeft_symm_apply (b : Î¹ â†’â‚€ N) :\n    (TensorProduct.equivFinsuppOfBasisLeft â„¬).symm b = b.sum fun i n â†¦ â„¬ i âŠ—â‚œ n :=\n  congr($(TensorProduct.equivFinsuppOfBasisLeft_symm â„¬) b)\n\n"}
{"name":"TensorProduct.eq_repr_basis_right","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nÎº : Type u_6\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\ninstâœÂ¹ : AddCommMonoid N\ninstâœ : Module R N\nğ’ : Basis Îº R N\nx : TensorProduct R M N\nâŠ¢ Exists fun b => Eq (b.sum fun i m => TensorProduct.tmul R m (ğ’ i)) x","decl":"omit [DecidableEq Îº] in\n/-- Elements in `M âŠ— N` can be represented by sum of elements in `M` tensor elements of basis of\n`N`. -/\nlemma TensorProduct.eq_repr_basis_right :\n    âˆƒ b : Îº â†’â‚€ M, b.sum (fun i m â†¦ m âŠ—â‚œ ğ’ i) = x := by\n  classical simpa using (TensorProduct.equivFinsuppOfBasisRight ğ’).symm.surjective x\n\n"}
{"name":"TensorProduct.eq_repr_basis_left","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nÎ¹ : Type u_5\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\ninstâœÂ¹ : AddCommMonoid N\ninstâœ : Module R N\nâ„¬ : Basis Î¹ R M\nx : TensorProduct R M N\nâŠ¢ Exists fun c => Eq (c.sum fun i n => TensorProduct.tmul R (â„¬ i) n) x","decl":"omit [DecidableEq Î¹] in\n/-- Elements in `M âŠ— N` can be represented by sum of elements of basis of `M` tensor elements of\n  `N`.-/\nlemma TensorProduct.eq_repr_basis_left :\n    âˆƒ (c : Î¹ â†’â‚€ N), (c.sum fun i n â†¦ â„¬ i âŠ—â‚œ n) = x := by\n  classical obtain âŸ¨c, rflâŸ© := (TensorProduct.equivFinsuppOfBasisLeft â„¬).symm.surjective x\n  exact âŸ¨c, (TensorProduct.comm R M N).injective <| by simp [Finsupp.sum]âŸ©\n\n"}
{"name":"TensorProduct.sum_tmul_basis_left_injective","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nÎ¹ : Type u_5\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\ninstâœÂ¹ : AddCommMonoid N\ninstâœ : Module R N\nâ„¬ : Basis Î¹ R M\nâŠ¢ Function.Injective â‡‘((Finsupp.lsum R) fun i => (TensorProduct.mk R M N) (â„¬ i))","decl":"omit [DecidableEq Î¹] in\nlemma TensorProduct.sum_tmul_basis_left_injective :\n    Function.Injective (Finsupp.lsum R fun i â†¦ (TensorProduct.mk R M N) (â„¬ i)) :=\n  have := Classical.decEq Î¹\n  (equivFinsuppOfBasisLeft_symm (N := N) â„¬).symm â–¸\n    (TensorProduct.equivFinsuppOfBasisLeft â„¬).symm.injective\n\n"}
{"name":"TensorProduct.sum_tmul_basis_left_eq_zero","module":"Mathlib.LinearAlgebra.TensorProduct.Basis","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_4\nÎ¹ : Type u_5\ninstâœâ´ : CommSemiring R\ninstâœÂ³ : AddCommMonoid M\ninstâœÂ² : Module R M\ninstâœÂ¹ : AddCommMonoid N\ninstâœ : Module R N\nâ„¬ : Basis Î¹ R M\nb : Finsupp Î¹ N\nh : Eq (b.sum fun i n => TensorProduct.tmul R (â„¬ i) n) 0\nâŠ¢ Eq b 0","decl":"omit [DecidableEq Î¹] in\nlemma TensorProduct.sum_tmul_basis_left_eq_zero\n    (b : Î¹ â†’â‚€ N) (h : (b.sum fun i n â†¦ â„¬ i âŠ—â‚œ[R] n) = 0) : b = 0 :=\n  have := Classical.decEq Î¹\n  (TensorProduct.equivFinsuppOfBasisLeft â„¬).symm.injective (aâ‚‚ := 0) <| by simpa\n\n"}
