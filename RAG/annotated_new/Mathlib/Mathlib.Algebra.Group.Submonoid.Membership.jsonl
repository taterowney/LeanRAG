{"name":"AddSubmonoid.mem_iSup_of_directed","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nι : Sort u_4\nhι : Nonempty ι\nS : ι → AddSubmonoid M\nhS : Directed (fun x1 x2 => LE.le x1 x2) S\nx : M\n⊢ Iff (Membership.mem (iSup fun i => S i) x) (Exists fun i => Membership.mem (S i) x)","decl":"@[to_additive]\ntheorem mem_iSup_of_directed {ι} [hι : Nonempty ι] {S : ι → Submonoid M} (hS : Directed (· ≤ ·) S)\n    {x : M} : (x ∈ ⨆ i, S i) ↔ ∃ i, x ∈ S i := by\n  refine ⟨?_, fun ⟨i, hi⟩ ↦ le_iSup S i hi⟩\n  suffices x ∈ closure (⋃ i, (S i : Set M)) → ∃ i, x ∈ S i by\n    simpa only [closure_iUnion, closure_eq (S _)] using this\n  refine closure_induction (fun _ ↦ mem_iUnion.1) ?_ ?_\n  · exact hι.elim fun i ↦ ⟨i, (S i).one_mem⟩\n  · rintro x y - - ⟨i, hi⟩ ⟨j, hj⟩\n    rcases hS i j with ⟨k, hki, hkj⟩\n    exact ⟨k, (S k).mul_mem (hki hi) (hkj hj)⟩\n\n"}
{"name":"Submonoid.mem_iSup_of_directed","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nι : Sort u_4\nhι : Nonempty ι\nS : ι → Submonoid M\nhS : Directed (fun x1 x2 => LE.le x1 x2) S\nx : M\n⊢ Iff (Membership.mem (iSup fun i => S i) x) (Exists fun i => Membership.mem (S i) x)","decl":"@[to_additive]\ntheorem mem_iSup_of_directed {ι} [hι : Nonempty ι] {S : ι → Submonoid M} (hS : Directed (· ≤ ·) S)\n    {x : M} : (x ∈ ⨆ i, S i) ↔ ∃ i, x ∈ S i := by\n  refine ⟨?_, fun ⟨i, hi⟩ ↦ le_iSup S i hi⟩\n  suffices x ∈ closure (⋃ i, (S i : Set M)) → ∃ i, x ∈ S i by\n    simpa only [closure_iUnion, closure_eq (S _)] using this\n  refine closure_induction (fun _ ↦ mem_iUnion.1) ?_ ?_\n  · exact hι.elim fun i ↦ ⟨i, (S i).one_mem⟩\n  · rintro x y - - ⟨i, hi⟩ ⟨j, hj⟩\n    rcases hS i j with ⟨k, hki, hkj⟩\n    exact ⟨k, (S k).mul_mem (hki hi) (hkj hj)⟩\n\n"}
{"name":"AddSubmonoid.coe_iSup_of_directed","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝¹ : AddZeroClass M\nι : Sort u_4\ninst✝ : Nonempty ι\nS : ι → AddSubmonoid M\nhS : Directed (fun x1 x2 => LE.le x1 x2) S\n⊢ Eq (↑(iSup fun i => S i)) (Set.iUnion fun i => ↑(S i))","decl":"@[to_additive]\ntheorem coe_iSup_of_directed {ι} [Nonempty ι] {S : ι → Submonoid M} (hS : Directed (· ≤ ·) S) :\n    ((⨆ i, S i : Submonoid M) : Set M) = ⋃ i, S i :=\n  Set.ext fun x ↦ by simp [mem_iSup_of_directed hS]\n\n"}
{"name":"Submonoid.coe_iSup_of_directed","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝¹ : MulOneClass M\nι : Sort u_4\ninst✝ : Nonempty ι\nS : ι → Submonoid M\nhS : Directed (fun x1 x2 => LE.le x1 x2) S\n⊢ Eq (↑(iSup fun i => S i)) (Set.iUnion fun i => ↑(S i))","decl":"@[to_additive]\ntheorem coe_iSup_of_directed {ι} [Nonempty ι] {S : ι → Submonoid M} (hS : Directed (· ≤ ·) S) :\n    ((⨆ i, S i : Submonoid M) : Set M) = ⋃ i, S i :=\n  Set.ext fun x ↦ by simp [mem_iSup_of_directed hS]\n\n"}
{"name":"Submonoid.mem_sSup_of_directedOn","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS : Set (Submonoid M)\nSne : S.Nonempty\nhS : DirectedOn (fun x1 x2 => LE.le x1 x2) S\nx : M\n⊢ Iff (Membership.mem (SupSet.sSup S) x) (Exists fun s => And (Membership.mem S s) (Membership.mem s x))","decl":"@[to_additive]\ntheorem mem_sSup_of_directedOn {S : Set (Submonoid M)} (Sne : S.Nonempty)\n    (hS : DirectedOn (· ≤ ·) S) {x : M} : x ∈ sSup S ↔ ∃ s ∈ S, x ∈ s := by\n  haveI : Nonempty S := Sne.to_subtype\n  simp [sSup_eq_iSup', mem_iSup_of_directed hS.directed_val, SetCoe.exists, Subtype.coe_mk]\n\n"}
{"name":"AddSubmonoid.mem_sSup_of_directedOn","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nS : Set (AddSubmonoid M)\nSne : S.Nonempty\nhS : DirectedOn (fun x1 x2 => LE.le x1 x2) S\nx : M\n⊢ Iff (Membership.mem (SupSet.sSup S) x) (Exists fun s => And (Membership.mem S s) (Membership.mem s x))","decl":"@[to_additive]\ntheorem mem_sSup_of_directedOn {S : Set (Submonoid M)} (Sne : S.Nonempty)\n    (hS : DirectedOn (· ≤ ·) S) {x : M} : x ∈ sSup S ↔ ∃ s ∈ S, x ∈ s := by\n  haveI : Nonempty S := Sne.to_subtype\n  simp [sSup_eq_iSup', mem_iSup_of_directed hS.directed_val, SetCoe.exists, Subtype.coe_mk]\n\n"}
{"name":"Submonoid.coe_sSup_of_directedOn","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS : Set (Submonoid M)\nSne : S.Nonempty\nhS : DirectedOn (fun x1 x2 => LE.le x1 x2) S\n⊢ Eq (↑(SupSet.sSup S)) (Set.iUnion fun s => Set.iUnion fun h => ↑s)","decl":"@[to_additive]\ntheorem coe_sSup_of_directedOn {S : Set (Submonoid M)} (Sne : S.Nonempty)\n    (hS : DirectedOn (· ≤ ·) S) : (↑(sSup S) : Set M) = ⋃ s ∈ S, ↑s :=\n  Set.ext fun x => by simp [mem_sSup_of_directedOn Sne hS]\n\n"}
{"name":"AddSubmonoid.coe_sSup_of_directedOn","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nS : Set (AddSubmonoid M)\nSne : S.Nonempty\nhS : DirectedOn (fun x1 x2 => LE.le x1 x2) S\n⊢ Eq (↑(SupSet.sSup S)) (Set.iUnion fun s => Set.iUnion fun h => ↑s)","decl":"@[to_additive]\ntheorem coe_sSup_of_directedOn {S : Set (Submonoid M)} (Sne : S.Nonempty)\n    (hS : DirectedOn (· ≤ ·) S) : (↑(sSup S) : Set M) = ⋃ s ∈ S, ↑s :=\n  Set.ext fun x => by simp [mem_sSup_of_directedOn Sne hS]\n\n"}
{"name":"AddSubmonoid.mem_sup_left","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nS T : AddSubmonoid M\nx : M\na✝ : Membership.mem S x\n⊢ Membership.mem (Max.max S T) x","decl":"@[to_additive]\ntheorem mem_sup_left {S T : Submonoid M} : ∀ {x : M}, x ∈ S → x ∈ S ⊔ T := by\n  rw [← SetLike.le_def]\n  exact le_sup_left\n\n"}
{"name":"Submonoid.mem_sup_left","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS T : Submonoid M\nx : M\na✝ : Membership.mem S x\n⊢ Membership.mem (Max.max S T) x","decl":"@[to_additive]\ntheorem mem_sup_left {S T : Submonoid M} : ∀ {x : M}, x ∈ S → x ∈ S ⊔ T := by\n  rw [← SetLike.le_def]\n  exact le_sup_left\n\n"}
{"name":"AddSubmonoid.mem_sup_right","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nS T : AddSubmonoid M\nx : M\na✝ : Membership.mem T x\n⊢ Membership.mem (Max.max S T) x","decl":"@[to_additive]\ntheorem mem_sup_right {S T : Submonoid M} : ∀ {x : M}, x ∈ T → x ∈ S ⊔ T := by\n  rw [← SetLike.le_def]\n  exact le_sup_right\n\n"}
{"name":"Submonoid.mem_sup_right","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS T : Submonoid M\nx : M\na✝ : Membership.mem T x\n⊢ Membership.mem (Max.max S T) x","decl":"@[to_additive]\ntheorem mem_sup_right {S T : Submonoid M} : ∀ {x : M}, x ∈ T → x ∈ S ⊔ T := by\n  rw [← SetLike.le_def]\n  exact le_sup_right\n\n"}
{"name":"AddSubmonoid.add_mem_sup","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nS T : AddSubmonoid M\nx y : M\nhx : Membership.mem S x\nhy : Membership.mem T y\n⊢ Membership.mem (Max.max S T) (HAdd.hAdd x y)","decl":"@[to_additive]\ntheorem mul_mem_sup {S T : Submonoid M} {x y : M} (hx : x ∈ S) (hy : y ∈ T) : x * y ∈ S ⊔ T :=\n  (S ⊔ T).mul_mem (mem_sup_left hx) (mem_sup_right hy)\n\n"}
{"name":"Submonoid.mul_mem_sup","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS T : Submonoid M\nx y : M\nhx : Membership.mem S x\nhy : Membership.mem T y\n⊢ Membership.mem (Max.max S T) (HMul.hMul x y)","decl":"@[to_additive]\ntheorem mul_mem_sup {S T : Submonoid M} {x y : M} (hx : x ∈ S) (hy : y ∈ T) : x * y ∈ S ⊔ T :=\n  (S ⊔ T).mul_mem (mem_sup_left hx) (mem_sup_right hy)\n\n"}
{"name":"AddSubmonoid.mem_iSup_of_mem","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nι : Sort u_4\nS : ι → AddSubmonoid M\ni : ι\nx : M\na✝ : Membership.mem (S i) x\n⊢ Membership.mem (iSup S) x","decl":"@[to_additive]\ntheorem mem_iSup_of_mem {ι : Sort*} {S : ι → Submonoid M} (i : ι) :\n    ∀ {x : M}, x ∈ S i → x ∈ iSup S := by\n  rw [← SetLike.le_def]\n  exact le_iSup _ _\n\n"}
{"name":"Submonoid.mem_iSup_of_mem","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nι : Sort u_4\nS : ι → Submonoid M\ni : ι\nx : M\na✝ : Membership.mem (S i) x\n⊢ Membership.mem (iSup S) x","decl":"@[to_additive]\ntheorem mem_iSup_of_mem {ι : Sort*} {S : ι → Submonoid M} (i : ι) :\n    ∀ {x : M}, x ∈ S i → x ∈ iSup S := by\n  rw [← SetLike.le_def]\n  exact le_iSup _ _\n\n"}
{"name":"Submonoid.mem_sSup_of_mem","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nS : Set (Submonoid M)\ns : Submonoid M\nhs : Membership.mem S s\nx : M\na✝ : Membership.mem s x\n⊢ Membership.mem (SupSet.sSup S) x","decl":"@[to_additive]\ntheorem mem_sSup_of_mem {S : Set (Submonoid M)} {s : Submonoid M} (hs : s ∈ S) :\n    ∀ {x : M}, x ∈ s → x ∈ sSup S := by\n  rw [← SetLike.le_def]\n  exact le_sSup hs\n\n"}
{"name":"AddSubmonoid.mem_sSup_of_mem","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nS : Set (AddSubmonoid M)\ns : AddSubmonoid M\nhs : Membership.mem S s\nx : M\na✝ : Membership.mem s x\n⊢ Membership.mem (SupSet.sSup S) x","decl":"@[to_additive]\ntheorem mem_sSup_of_mem {S : Set (Submonoid M)} {s : Submonoid M} (hs : s ∈ S) :\n    ∀ {x : M}, x ∈ s → x ∈ sSup S := by\n  rw [← SetLike.le_def]\n  exact le_sSup hs\n\n"}
{"name":"AddSubmonoid.iSup_induction","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nι : Sort u_4\nS : ι → AddSubmonoid M\nC : M → Prop\nx : M\nhx : Membership.mem (iSup fun i => S i) x\nmem : ∀ (i : ι) (x : M), Membership.mem (S i) x → C x\none : C 0\nmul : ∀ (x y : M), C x → C y → C (HAdd.hAdd x y)\n⊢ C x","decl":"/-- An induction principle for elements of `⨆ i, S i`.\nIf `C` holds for `1` and all elements of `S i` for all `i`, and is preserved under multiplication,\nthen it holds for all elements of the supremum of `S`. -/\n@[to_additive (attr := elab_as_elim)\n      \" An induction principle for elements of `⨆ i, S i`.\n      If `C` holds for `0` and all elements of `S i` for all `i`, and is preserved under addition,\n      then it holds for all elements of the supremum of `S`. \"]\ntheorem iSup_induction {ι : Sort*} (S : ι → Submonoid M) {C : M → Prop} {x : M} (hx : x ∈ ⨆ i, S i)\n    (mem : ∀ (i), ∀ x ∈ S i, C x) (one : C 1) (mul : ∀ x y, C x → C y → C (x * y)) : C x := by\n  rw [iSup_eq_closure] at hx\n  refine closure_induction (fun x hx => ?_) one (fun _ _ _ _ ↦ mul _ _) hx\n  obtain ⟨i, hi⟩ := Set.mem_iUnion.mp hx\n  exact mem _ _ hi\n\n"}
{"name":"Submonoid.iSup_induction","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nι : Sort u_4\nS : ι → Submonoid M\nC : M → Prop\nx : M\nhx : Membership.mem (iSup fun i => S i) x\nmem : ∀ (i : ι) (x : M), Membership.mem (S i) x → C x\none : C 1\nmul : ∀ (x y : M), C x → C y → C (HMul.hMul x y)\n⊢ C x","decl":"/-- An induction principle for elements of `⨆ i, S i`.\nIf `C` holds for `1` and all elements of `S i` for all `i`, and is preserved under multiplication,\nthen it holds for all elements of the supremum of `S`. -/\n@[to_additive (attr := elab_as_elim)\n      \" An induction principle for elements of `⨆ i, S i`.\n      If `C` holds for `0` and all elements of `S i` for all `i`, and is preserved under addition,\n      then it holds for all elements of the supremum of `S`. \"]\ntheorem iSup_induction {ι : Sort*} (S : ι → Submonoid M) {C : M → Prop} {x : M} (hx : x ∈ ⨆ i, S i)\n    (mem : ∀ (i), ∀ x ∈ S i, C x) (one : C 1) (mul : ∀ x y, C x → C y → C (x * y)) : C x := by\n  rw [iSup_eq_closure] at hx\n  refine closure_induction (fun x hx => ?_) one (fun _ _ _ _ ↦ mul _ _) hx\n  obtain ⟨i, hi⟩ := Set.mem_iUnion.mp hx\n  exact mem _ _ hi\n\n"}
{"name":"AddSubmonoid.iSup_induction'","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddZeroClass M\nι : Sort u_4\nS : ι → AddSubmonoid M\nC : (x : M) → Membership.mem (iSup fun i => S i) x → Prop\nmem : ∀ (i : ι) (x : M) (hxS : Membership.mem (S i) x), C x ⋯\none : C 0 ⋯\nmul : ∀ (x y : M) (hx : Membership.mem (iSup fun i => S i) x) (hy : Membership.mem (iSup fun i => S i) y), C x hx → C y hy → C (HAdd.hAdd x y) ⋯\nx : M\nhx : Membership.mem (iSup fun i => S i) x\n⊢ C x hx","decl":"/-- A dependent version of `Submonoid.iSup_induction`. -/\n@[to_additive (attr := elab_as_elim) \"A dependent version of `AddSubmonoid.iSup_induction`. \"]\ntheorem iSup_induction' {ι : Sort*} (S : ι → Submonoid M) {C : ∀ x, (x ∈ ⨆ i, S i) → Prop}\n    (mem : ∀ (i), ∀ (x) (hxS : x ∈ S i), C x (mem_iSup_of_mem i hxS)) (one : C 1 (one_mem _))\n    (mul : ∀ x y hx hy, C x hx → C y hy → C (x * y) (mul_mem ‹_› ‹_›)) {x : M}\n    (hx : x ∈ ⨆ i, S i) : C x hx := by\n  refine Exists.elim (?_ : ∃ Hx, C x Hx) fun (hx : x ∈ ⨆ i, S i) (hc : C x hx) => hc\n  refine @iSup_induction _ _ ι S (fun m => ∃ hm, C m hm) _ hx (fun i x hx => ?_) ?_ fun x y => ?_\n  · exact ⟨_, mem _ _ hx⟩\n  · exact ⟨_, one⟩\n  · rintro ⟨_, Cx⟩ ⟨_, Cy⟩\n    exact ⟨_, mul _ _ _ _ Cx Cy⟩\n\n"}
{"name":"Submonoid.iSup_induction'","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : MulOneClass M\nι : Sort u_4\nS : ι → Submonoid M\nC : (x : M) → Membership.mem (iSup fun i => S i) x → Prop\nmem : ∀ (i : ι) (x : M) (hxS : Membership.mem (S i) x), C x ⋯\none : C 1 ⋯\nmul : ∀ (x y : M) (hx : Membership.mem (iSup fun i => S i) x) (hy : Membership.mem (iSup fun i => S i) y), C x hx → C y hy → C (HMul.hMul x y) ⋯\nx : M\nhx : Membership.mem (iSup fun i => S i) x\n⊢ C x hx","decl":"/-- A dependent version of `Submonoid.iSup_induction`. -/\n@[to_additive (attr := elab_as_elim) \"A dependent version of `AddSubmonoid.iSup_induction`. \"]\ntheorem iSup_induction' {ι : Sort*} (S : ι → Submonoid M) {C : ∀ x, (x ∈ ⨆ i, S i) → Prop}\n    (mem : ∀ (i), ∀ (x) (hxS : x ∈ S i), C x (mem_iSup_of_mem i hxS)) (one : C 1 (one_mem _))\n    (mul : ∀ x y hx hy, C x hx → C y hy → C (x * y) (mul_mem ‹_› ‹_›)) {x : M}\n    (hx : x ∈ ⨆ i, S i) : C x hx := by\n  refine Exists.elim (?_ : ∃ Hx, C x Hx) fun (hx : x ∈ ⨆ i, S i) (hc : C x hx) => hc\n  refine @iSup_induction _ _ ι S (fun m => ∃ hm, C m hm) _ hx (fun i x hx => ?_) ?_ fun x y => ?_\n  · exact ⟨_, mem _ _ hx⟩\n  · exact ⟨_, one⟩\n  · rintro ⟨_, Cx⟩ ⟨_, Cy⟩\n    exact ⟨_, mul _ _ _ _ Cx Cy⟩\n\n"}
{"name":"FreeMonoid.closure_range_of","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"α : Type u_4\n⊢ Eq (Submonoid.closure (Set.range FreeMonoid.of)) Top.top","decl":"@[to_additive]\ntheorem closure_range_of : closure (Set.range <| @of α) = ⊤ :=\n  eq_top_iff.2 fun x _ =>\n    FreeMonoid.recOn x (one_mem _) fun _x _xs hxs =>\n      mul_mem (subset_closure <| Set.mem_range_self _) hxs\n\n"}
{"name":"FreeAddMonoid.closure_range_of","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"α : Type u_4\n⊢ Eq (AddSubmonoid.closure (Set.range FreeAddMonoid.of)) Top.top","decl":"@[to_additive]\ntheorem closure_range_of : closure (Set.range <| @of α) = ⊤ :=\n  eq_top_iff.2 fun x _ =>\n    FreeMonoid.recOn x (one_mem _) fun _x _xs hxs =>\n      mul_mem (subset_closure <| Set.mem_range_self _) hxs\n\n"}
{"name":"Submonoid.closure_singleton_eq","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nx : M\n⊢ Eq (Submonoid.closure (Singleton.singleton x)) (MonoidHom.mrange ((powersHom M) x))","decl":"theorem closure_singleton_eq (x : M) : closure ({x} : Set M) = mrange (powersHom M x) :=\n  closure_eq_of_le (Set.singleton_subset_iff.2 ⟨Multiplicative.ofAdd 1, pow_one x⟩) fun _ ⟨_, hn⟩ =>\n    hn ▸ pow_mem (subset_closure <| Set.mem_singleton _) _\n\n"}
{"name":"Submonoid.mem_closure_singleton","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nx y : M\n⊢ Iff (Membership.mem (Submonoid.closure (Singleton.singleton x)) y) (Exists fun n => Eq (HPow.hPow x n) y)","decl":"/-- The submonoid generated by an element of a monoid equals the set of natural number powers of\n    the element. -/\ntheorem mem_closure_singleton {x y : M} : y ∈ closure ({x} : Set M) ↔ ∃ n : ℕ, x ^ n = y := by\n  rw [closure_singleton_eq, mem_mrange]; rfl\n\n"}
{"name":"Submonoid.mem_closure_singleton_self","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\ny : M\n⊢ Membership.mem (Submonoid.closure (Singleton.singleton y)) y","decl":"theorem mem_closure_singleton_self {y : M} : y ∈ closure ({y} : Set M) :=\n  mem_closure_singleton.2 ⟨1, pow_one y⟩\n\n"}
{"name":"Submonoid.closure_singleton_one","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Eq (Submonoid.closure (Singleton.singleton 1)) Bot.bot","decl":"theorem closure_singleton_one : closure ({1} : Set M) = ⊥ := by\n  simp [eq_bot_iff_forall, mem_closure_singleton]\n\n"}
{"name":"AddSubmonoid.card_bot","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nx✝ : Fintype (Subtype fun x => Membership.mem Bot.bot x)\n⊢ Eq (Fintype.card (Subtype fun x => Membership.mem Bot.bot x)) 1","decl":"@[to_additive]\ntheorem card_bot {_ : Fintype (⊥ : Submonoid M)} : card (⊥ : Submonoid M) = 1 :=\n  card_eq_one_iff.2\n    ⟨⟨(1 : M), Set.mem_singleton 1⟩, fun ⟨_y, hy⟩ => Subtype.eq <| mem_bot.1 hy⟩\n\n"}
{"name":"Submonoid.card_bot","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nx✝ : Fintype (Subtype fun x => Membership.mem Bot.bot x)\n⊢ Eq (Fintype.card (Subtype fun x => Membership.mem Bot.bot x)) 1","decl":"@[to_additive]\ntheorem card_bot {_ : Fintype (⊥ : Submonoid M)} : card (⊥ : Submonoid M) = 1 :=\n  card_eq_one_iff.2\n    ⟨⟨(1 : M), Set.mem_singleton 1⟩, fun ⟨_y, hy⟩ => Subtype.eq <| mem_bot.1 hy⟩\n\n"}
{"name":"AddSubmonoid.eq_bot_of_card_le","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝¹ : AddMonoid M\nS : AddSubmonoid M\ninst✝ : Fintype (Subtype fun x => Membership.mem S x)\nh : LE.le (Fintype.card (Subtype fun x => Membership.mem S x)) 1\n⊢ Eq S Bot.bot","decl":"@[to_additive]\ntheorem eq_bot_of_card_le (h : card S ≤ 1) : S = ⊥ :=\n  let _ := card_le_one_iff_subsingleton.mp h\n  eq_bot_of_subsingleton S\n\n"}
{"name":"Submonoid.eq_bot_of_card_le","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝¹ : Monoid M\nS : Submonoid M\ninst✝ : Fintype (Subtype fun x => Membership.mem S x)\nh : LE.le (Fintype.card (Subtype fun x => Membership.mem S x)) 1\n⊢ Eq S Bot.bot","decl":"@[to_additive]\ntheorem eq_bot_of_card_le (h : card S ≤ 1) : S = ⊥ :=\n  let _ := card_le_one_iff_subsingleton.mp h\n  eq_bot_of_subsingleton S\n\n"}
{"name":"AddSubmonoid.eq_bot_of_card_eq","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝¹ : AddMonoid M\nS : AddSubmonoid M\ninst✝ : Fintype (Subtype fun x => Membership.mem S x)\nh : Eq (Fintype.card (Subtype fun x => Membership.mem S x)) 1\n⊢ Eq S Bot.bot","decl":"@[to_additive]\ntheorem eq_bot_of_card_eq (h : card S = 1) : S = ⊥ :=\n  S.eq_bot_of_card_le (le_of_eq h)\n\n"}
{"name":"Submonoid.eq_bot_of_card_eq","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝¹ : Monoid M\nS : Submonoid M\ninst✝ : Fintype (Subtype fun x => Membership.mem S x)\nh : Eq (Fintype.card (Subtype fun x => Membership.mem S x)) 1\n⊢ Eq S Bot.bot","decl":"@[to_additive]\ntheorem eq_bot_of_card_eq (h : card S = 1) : S = ⊥ :=\n  S.eq_bot_of_card_le (le_of_eq h)\n\n"}
{"name":"Submonoid.card_le_one_iff_eq_bot","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝¹ : Monoid M\nS : Submonoid M\ninst✝ : Fintype (Subtype fun x => Membership.mem S x)\n⊢ Iff (LE.le (Fintype.card (Subtype fun x => Membership.mem S x)) 1) (Eq S Bot.bot)","decl":"@[to_additive card_le_one_iff_eq_bot]\ntheorem card_le_one_iff_eq_bot : card S ≤ 1 ↔ S = ⊥ :=\n  ⟨fun h =>\n    (eq_bot_iff_forall _).2 fun x hx => by\n      simpa [Subtype.ext_iff] using card_le_one_iff.1 h ⟨x, hx⟩ 1,\n    fun h => by simp [h]⟩\n\n"}
{"name":"AddSubmonoid.card_le_one_iff_eq_bot","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝¹ : AddMonoid M\nS : AddSubmonoid M\ninst✝ : Fintype (Subtype fun x => Membership.mem S x)\n⊢ Iff (LE.le (Fintype.card (Subtype fun x => Membership.mem S x)) 1) (Eq S Bot.bot)","decl":"@[to_additive card_le_one_iff_eq_bot]\ntheorem card_le_one_iff_eq_bot : card S ≤ 1 ↔ S = ⊥ :=\n  ⟨fun h =>\n    (eq_bot_iff_forall _).2 fun x hx => by\n      simpa [Subtype.ext_iff] using card_le_one_iff.1 h ⟨x, hx⟩ 1,\n    fun h => by simp [h]⟩\n\n"}
{"name":"Submonoid.eq_bot_iff_card","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝¹ : Monoid M\nS : Submonoid M\ninst✝ : Fintype (Subtype fun x => Membership.mem S x)\n⊢ Iff (Eq S Bot.bot) (Eq (Fintype.card (Subtype fun x => Membership.mem S x)) 1)","decl":"@[to_additive]\nlemma eq_bot_iff_card : S = ⊥ ↔ card S = 1 :=\n  ⟨by rintro rfl; exact card_bot, eq_bot_of_card_eq⟩\n\n"}
{"name":"AddSubmonoid.eq_bot_iff_card","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝¹ : AddMonoid M\nS : AddSubmonoid M\ninst✝ : Fintype (Subtype fun x => Membership.mem S x)\n⊢ Iff (Eq S Bot.bot) (Eq (Fintype.card (Subtype fun x => Membership.mem S x)) 1)","decl":"@[to_additive]\nlemma eq_bot_iff_card : S = ⊥ ↔ card S = 1 :=\n  ⟨by rintro rfl; exact card_bot, eq_bot_of_card_eq⟩\n\n"}
{"name":"FreeAddMonoid.mrange_lift","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nα : Type u_4\nf : α → M\n⊢ Eq (AddMonoidHom.mrange (FreeAddMonoid.lift f)) (AddSubmonoid.closure (Set.range f))","decl":"@[to_additive]\ntheorem _root_.FreeMonoid.mrange_lift {α} (f : α → M) :\n    mrange (FreeMonoid.lift f) = closure (Set.range f) := by\n  rw [mrange_eq_map, ← FreeMonoid.closure_range_of, map_mclosure, ← Set.range_comp,\n    FreeMonoid.lift_comp_of]\n\n"}
{"name":"FreeMonoid.mrange_lift","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nα : Type u_4\nf : α → M\n⊢ Eq (MonoidHom.mrange (FreeMonoid.lift f)) (Submonoid.closure (Set.range f))","decl":"@[to_additive]\ntheorem _root_.FreeMonoid.mrange_lift {α} (f : α → M) :\n    mrange (FreeMonoid.lift f) = closure (Set.range f) := by\n  rw [mrange_eq_map, ← FreeMonoid.closure_range_of, map_mclosure, ← Set.range_comp,\n    FreeMonoid.lift_comp_of]\n\n"}
{"name":"Submonoid.closure_eq_mrange","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\ns : Set M\n⊢ Eq (Submonoid.closure s) (MonoidHom.mrange (FreeMonoid.lift Subtype.val))","decl":"@[to_additive]\ntheorem closure_eq_mrange (s : Set M) : closure s = mrange (FreeMonoid.lift ((↑) : s → M)) := by\n  rw [FreeMonoid.mrange_lift, Subtype.range_coe]\n\n"}
{"name":"AddSubmonoid.closure_eq_mrange","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\ns : Set M\n⊢ Eq (AddSubmonoid.closure s) (AddMonoidHom.mrange (FreeAddMonoid.lift Subtype.val))","decl":"@[to_additive]\ntheorem closure_eq_mrange (s : Set M) : closure s = mrange (FreeMonoid.lift ((↑) : s → M)) := by\n  rw [FreeMonoid.mrange_lift, Subtype.range_coe]\n\n"}
{"name":"Submonoid.closure_eq_image_prod","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\ns : Set M\n⊢ Eq (↑(Submonoid.closure s)) (Set.image List.prod (setOf fun l => ∀ (x : M), Membership.mem l x → Membership.mem s x))","decl":"@[to_additive]\ntheorem closure_eq_image_prod (s : Set M) :\n    (closure s : Set M) = List.prod '' { l : List M | ∀ x ∈ l, x ∈ s } := by\n  rw [closure_eq_mrange, coe_mrange, ← Set.range_list_map_coe, ← Set.range_comp]\n  exact congrArg _ (funext <| FreeMonoid.lift_apply _)\n\n"}
{"name":"AddSubmonoid.closure_eq_image_sum","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\ns : Set M\n⊢ Eq (↑(AddSubmonoid.closure s)) (Set.image List.sum (setOf fun l => ∀ (x : M), Membership.mem l x → Membership.mem s x))","decl":"@[to_additive]\ntheorem closure_eq_image_prod (s : Set M) :\n    (closure s : Set M) = List.prod '' { l : List M | ∀ x ∈ l, x ∈ s } := by\n  rw [closure_eq_mrange, coe_mrange, ← Set.range_list_map_coe, ← Set.range_comp]\n  exact congrArg _ (funext <| FreeMonoid.lift_apply _)\n\n"}
{"name":"Submonoid.exists_list_of_mem_closure","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\ns : Set M\nx : M\nhx : Membership.mem (Submonoid.closure s) x\n⊢ Exists fun l => And (∀ (y : M), Membership.mem l y → Membership.mem s y) (Eq l.prod x)","decl":"@[to_additive]\ntheorem exists_list_of_mem_closure {s : Set M} {x : M} (hx : x ∈ closure s) :\n    ∃ l : List M, (∀ y ∈ l, y ∈ s) ∧ l.prod = x := by\n  rwa [← SetLike.mem_coe, closure_eq_image_prod, Set.mem_image] at hx\n\n"}
{"name":"AddSubmonoid.exists_list_of_mem_closure","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\ns : Set M\nx : M\nhx : Membership.mem (AddSubmonoid.closure s) x\n⊢ Exists fun l => And (∀ (y : M), Membership.mem l y → Membership.mem s y) (Eq l.sum x)","decl":"@[to_additive]\ntheorem exists_list_of_mem_closure {s : Set M} {x : M} (hx : x ∈ closure s) :\n    ∃ l : List M, (∀ y ∈ l, y ∈ s) ∧ l.prod = x := by\n  rwa [← SetLike.mem_coe, closure_eq_image_prod, Set.mem_image] at hx\n\n"}
{"name":"Submonoid.exists_multiset_of_mem_closure","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_4\ninst✝ : CommMonoid M\ns : Set M\nx : M\nhx : Membership.mem (Submonoid.closure s) x\n⊢ Exists fun l => And (∀ (y : M), Membership.mem l y → Membership.mem s y) (Eq l.prod x)","decl":"@[to_additive]\ntheorem exists_multiset_of_mem_closure {M : Type*} [CommMonoid M] {s : Set M} {x : M}\n    (hx : x ∈ closure s) : ∃ l : Multiset M, (∀ y ∈ l, y ∈ s) ∧ l.prod = x := by\n  obtain ⟨l, h1, h2⟩ := exists_list_of_mem_closure hx\n  exact ⟨l, h1, (Multiset.prod_coe l).trans h2⟩\n\n"}
{"name":"AddSubmonoid.exists_multiset_of_mem_closure","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_4\ninst✝ : AddCommMonoid M\ns : Set M\nx : M\nhx : Membership.mem (AddSubmonoid.closure s) x\n⊢ Exists fun l => And (∀ (y : M), Membership.mem l y → Membership.mem s y) (Eq l.sum x)","decl":"@[to_additive]\ntheorem exists_multiset_of_mem_closure {M : Type*} [CommMonoid M] {s : Set M} {x : M}\n    (hx : x ∈ closure s) : ∃ l : Multiset M, (∀ y ∈ l, y ∈ s) ∧ l.prod = x := by\n  obtain ⟨l, h1, h2⟩ := exists_list_of_mem_closure hx\n  exact ⟨l, h1, (Multiset.prod_coe l).trans h2⟩\n\n"}
{"name":"Submonoid.closure_induction_left","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\ns : Set M\np : (m : M) → Membership.mem (Submonoid.closure s) m → Prop\none : p 1 ⋯\nmul_left : ∀ (x : M) (hx : Membership.mem s x) (y : M) (hy : Membership.mem (Submonoid.closure s) y), p y hy → p (HMul.hMul x y) ⋯\nx : M\nh : Membership.mem (Submonoid.closure s) x\n⊢ p x h","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem closure_induction_left {s : Set M} {p : (m : M) → m ∈ closure s → Prop}\n    (one : p 1 (one_mem _))\n    (mul_left : ∀ x (hx : x ∈ s), ∀ (y) hy, p y hy → p (x * y) (mul_mem (subset_closure hx) hy))\n    {x : M} (h : x ∈ closure s) :\n    p x h := by\n  simp_rw [closure_eq_mrange] at h\n  obtain ⟨l, rfl⟩ := h\n  induction l using FreeMonoid.inductionOn' with\n  | one => exact one\n  | mul_of x y ih =>\n    simp only [map_mul, FreeMonoid.lift_eval_of]\n    refine mul_left _ x.prop (FreeMonoid.lift Subtype.val y) _ (ih ?_)\n    simp only [closure_eq_mrange, mem_mrange, exists_apply_eq_apply]\n\n"}
{"name":"AddSubmonoid.closure_induction_left","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\ns : Set M\np : (m : M) → Membership.mem (AddSubmonoid.closure s) m → Prop\none : p 0 ⋯\nmul_left : ∀ (x : M) (hx : Membership.mem s x) (y : M) (hy : Membership.mem (AddSubmonoid.closure s) y), p y hy → p (HAdd.hAdd x y) ⋯\nx : M\nh : Membership.mem (AddSubmonoid.closure s) x\n⊢ p x h","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem closure_induction_left {s : Set M} {p : (m : M) → m ∈ closure s → Prop}\n    (one : p 1 (one_mem _))\n    (mul_left : ∀ x (hx : x ∈ s), ∀ (y) hy, p y hy → p (x * y) (mul_mem (subset_closure hx) hy))\n    {x : M} (h : x ∈ closure s) :\n    p x h := by\n  simp_rw [closure_eq_mrange] at h\n  obtain ⟨l, rfl⟩ := h\n  induction l using FreeMonoid.inductionOn' with\n  | one => exact one\n  | mul_of x y ih =>\n    simp only [map_mul, FreeMonoid.lift_eval_of]\n    refine mul_left _ x.prop (FreeMonoid.lift Subtype.val y) _ (ih ?_)\n    simp only [closure_eq_mrange, mem_mrange, exists_apply_eq_apply]\n\n"}
{"name":"AddSubmonoid.induction_of_closure_eq_top_left","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\ns : Set M\np : M → Prop\nhs : Eq (AddSubmonoid.closure s) Top.top\nx : M\none : p 0\nmul : ∀ (x : M), Membership.mem s x → ∀ (y : M), p y → p (HAdd.hAdd x y)\n⊢ p x","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem induction_of_closure_eq_top_left {s : Set M} {p : M → Prop} (hs : closure s = ⊤) (x : M)\n    (one : p 1) (mul : ∀ x ∈ s, ∀ (y), p y → p (x * y)) : p x := by\n  have : x ∈ closure s := by simp [hs]\n  induction this using closure_induction_left with\n  | one => exact one\n  | mul_left x hx y _ ih => exact mul x hx y ih\n\n"}
{"name":"Submonoid.induction_of_closure_eq_top_left","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\ns : Set M\np : M → Prop\nhs : Eq (Submonoid.closure s) Top.top\nx : M\none : p 1\nmul : ∀ (x : M), Membership.mem s x → ∀ (y : M), p y → p (HMul.hMul x y)\n⊢ p x","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem induction_of_closure_eq_top_left {s : Set M} {p : M → Prop} (hs : closure s = ⊤) (x : M)\n    (one : p 1) (mul : ∀ x ∈ s, ∀ (y), p y → p (x * y)) : p x := by\n  have : x ∈ closure s := by simp [hs]\n  induction this using closure_induction_left with\n  | one => exact one\n  | mul_left x hx y _ ih => exact mul x hx y ih\n\n"}
{"name":"Submonoid.closure_induction_right","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\ns : Set M\np : (m : M) → Membership.mem (Submonoid.closure s) m → Prop\none : p 1 ⋯\nmul_right : ∀ (x : M) (hx : Membership.mem (Submonoid.closure s) x) (y : M) (hy : Membership.mem s y), p x hx → p (HMul.hMul x y) ⋯\nx : M\nh : Membership.mem (Submonoid.closure s) x\n⊢ p x h","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem closure_induction_right {s : Set M} {p : (m : M) → m ∈ closure s → Prop}\n    (one : p 1 (one_mem _))\n    (mul_right : ∀ x hx, ∀ (y) (hy : y ∈ s), p x hx → p (x * y) (mul_mem hx (subset_closure hy)))\n    {x : M} (h : x ∈ closure s) : p x h :=\n  closure_induction_left (s := MulOpposite.unop ⁻¹' s)\n    (p := fun m hm => p m.unop <| by rwa [← op_closure] at hm)\n    one\n    (fun _x hx _y _ => mul_right _ _ _ hx)\n    (by rwa [← op_closure])\n\n"}
{"name":"AddSubmonoid.closure_induction_right","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\ns : Set M\np : (m : M) → Membership.mem (AddSubmonoid.closure s) m → Prop\none : p 0 ⋯\nmul_right : ∀ (x : M) (hx : Membership.mem (AddSubmonoid.closure s) x) (y : M) (hy : Membership.mem s y), p x hx → p (HAdd.hAdd x y) ⋯\nx : M\nh : Membership.mem (AddSubmonoid.closure s) x\n⊢ p x h","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem closure_induction_right {s : Set M} {p : (m : M) → m ∈ closure s → Prop}\n    (one : p 1 (one_mem _))\n    (mul_right : ∀ x hx, ∀ (y) (hy : y ∈ s), p x hx → p (x * y) (mul_mem hx (subset_closure hy)))\n    {x : M} (h : x ∈ closure s) : p x h :=\n  closure_induction_left (s := MulOpposite.unop ⁻¹' s)\n    (p := fun m hm => p m.unop <| by rwa [← op_closure] at hm)\n    one\n    (fun _x hx _y _ => mul_right _ _ _ hx)\n    (by rwa [← op_closure])\n\n"}
{"name":"AddSubmonoid.induction_of_closure_eq_top_right","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\ns : Set M\np : M → Prop\nhs : Eq (AddSubmonoid.closure s) Top.top\nx : M\nH1 : p 0\nHmul : ∀ (x y : M), Membership.mem s y → p x → p (HAdd.hAdd x y)\n⊢ p x","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem induction_of_closure_eq_top_right {s : Set M} {p : M → Prop} (hs : closure s = ⊤) (x : M)\n    (H1 : p 1) (Hmul : ∀ (x), ∀ y ∈ s, p x → p (x * y)) : p x := by\n  have : x ∈ closure s := by simp [hs]\n  induction this using closure_induction_right with\n  | one => exact H1\n  | mul_right x _ y hy ih => exact Hmul x y hy ih\n\n"}
{"name":"Submonoid.induction_of_closure_eq_top_right","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\ns : Set M\np : M → Prop\nhs : Eq (Submonoid.closure s) Top.top\nx : M\nH1 : p 1\nHmul : ∀ (x y : M), Membership.mem s y → p x → p (HMul.hMul x y)\n⊢ p x","decl":"@[to_additive (attr := elab_as_elim)]\ntheorem induction_of_closure_eq_top_right {s : Set M} {p : M → Prop} (hs : closure s = ⊤) (x : M)\n    (H1 : p 1) (Hmul : ∀ (x), ∀ y ∈ s, p x → p (x * y)) : p x := by\n  have : x ∈ closure s := by simp [hs]\n  induction this using closure_induction_right with\n  | one => exact H1\n  | mul_right x _ y hy ih => exact Hmul x y hy ih\n\n"}
{"name":"Submonoid.mem_powers","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nn : M\n⊢ Membership.mem (Submonoid.powers n) n","decl":"theorem mem_powers (n : M) : n ∈ powers n :=\n  ⟨1, pow_one _⟩\n\n"}
{"name":"Submonoid.coe_powers","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nx : M\n⊢ Eq (↑(Submonoid.powers x)) (Set.range fun n => HPow.hPow x n)","decl":"theorem coe_powers (x : M) : ↑(powers x) = Set.range fun n : ℕ => x ^ n :=\n  rfl\n\n"}
{"name":"Submonoid.mem_powers_iff","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nx z : M\n⊢ Iff (Membership.mem (Submonoid.powers z) x) (Exists fun n => Eq (HPow.hPow z n) x)","decl":"theorem mem_powers_iff (x z : M) : x ∈ powers z ↔ ∃ n : ℕ, z ^ n = x :=\n  Iff.rfl\n\n"}
{"name":"Submonoid.powers_eq_closure","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nn : M\n⊢ Eq (Submonoid.powers n) (Submonoid.closure (Singleton.singleton n))","decl":"theorem powers_eq_closure (n : M) : powers n = closure {n} := by\n  ext\n  exact mem_closure_singleton.symm\n\n"}
{"name":"Submonoid.powers_le","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nn : M\nP : Submonoid M\n⊢ Iff (LE.le (Submonoid.powers n) P) (Membership.mem P n)","decl":"lemma powers_le {n : M} {P : Submonoid M} : powers n ≤ P ↔ n ∈ P := by simp [powers_eq_closure]\n\n"}
{"name":"Submonoid.powers_one","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\n⊢ Eq (Submonoid.powers 1) Bot.bot","decl":"lemma powers_one : powers (1 : M) = ⊥ := bot_unique <| powers_le.2 <| one_mem _\n\n"}
{"name":"IsIdempotentElem.coe_powers","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : M\nha : IsIdempotentElem a\n⊢ Eq (↑(Submonoid.powers a)) (Insert.insert 1 (Singleton.singleton a))","decl":"theorem _root_.IsIdempotentElem.coe_powers {a : M} (ha : IsIdempotentElem a) :\n    (Submonoid.powers a : Set M) = {1, a} :=\n  let S : Submonoid M :=\n  { carrier := {1, a},\n    mul_mem' := by\n      rintro _ _ (rfl|rfl) (rfl|rfl)\n      · rw [one_mul]; exact .inl rfl\n      · rw [one_mul]; exact .inr rfl\n      · rw [mul_one]; exact .inr rfl\n      · rw [ha]; exact .inr rfl\n    one_mem' := .inl rfl }\n  suffices Submonoid.powers a = S from congr_arg _ this\n  le_antisymm (Submonoid.powers_le.mpr <| .inr rfl)\n    (by rintro _ (rfl|rfl); exacts [one_mem _, Submonoid.mem_powers _])\n\n"}
{"name":"Submonoid.pow_coe","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nn : M\nm : Nat\n⊢ Eq (↑(Submonoid.pow n m)) (HPow.hPow n m)","decl":"/-- Exponentiation map from natural numbers to powers. -/\n@[simps!]\ndef pow (n : M) (m : ℕ) : powers n :=\n  (powersHom M n).mrangeRestrict (Multiplicative.ofAdd m)\n\n"}
{"name":"Submonoid.pow_apply","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nn : M\nm : Nat\n⊢ Eq (Submonoid.pow n m) ⟨HPow.hPow n m, ⋯⟩","decl":"theorem pow_apply (n : M) (m : ℕ) : Submonoid.pow n m = ⟨n ^ m, m, rfl⟩ :=\n  rfl\n\n"}
{"name":"Submonoid.pow_log_eq_self","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝¹ : Monoid M\ninst✝ : DecidableEq M\nn : M\np : Subtype fun x => Membership.mem (Submonoid.powers n) x\n⊢ Eq (Submonoid.pow n (Submonoid.log p)) p","decl":"@[simp]\ntheorem pow_log_eq_self [DecidableEq M] {n : M} (p : powers n) : pow n (log p) = p :=\n  Subtype.ext <| Nat.find_spec p.prop\n\n"}
{"name":"Submonoid.pow_right_injective_iff_pow_injective","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nn : M\n⊢ Iff (Function.Injective fun m => HPow.hPow n m) (Function.Injective (Submonoid.pow n))","decl":"theorem pow_right_injective_iff_pow_injective {n : M} :\n    (Function.Injective fun m : ℕ => n ^ m) ↔ Function.Injective (pow n) :=\n  Subtype.coe_injective.of_comp_iff (pow n)\n\n"}
{"name":"Submonoid.log_pow_eq_self","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝¹ : Monoid M\ninst✝ : DecidableEq M\nn : M\nh : Function.Injective fun m => HPow.hPow n m\nm : Nat\n⊢ Eq (Submonoid.log (Submonoid.pow n m)) m","decl":"@[simp]\ntheorem log_pow_eq_self [DecidableEq M] {n : M} (h : Function.Injective fun m : ℕ => n ^ m)\n    (m : ℕ) : log (pow n m) = m :=\n  pow_right_injective_iff_pow_injective.mp h <| pow_log_eq_self _\n\n"}
{"name":"Submonoid.powLogEquiv_apply","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝¹ : Monoid M\ninst✝ : DecidableEq M\nn : M\nh : Function.Injective fun m => HPow.hPow n m\nm : Multiplicative Nat\n⊢ Eq ((Submonoid.powLogEquiv h) m) (Submonoid.pow n (Multiplicative.toAdd m))","decl":"/-- The exponentiation map is an isomorphism from the additive monoid on natural numbers to powers\nwhen it is injective. The inverse is given by the logarithms. -/\n@[simps]\ndef powLogEquiv [DecidableEq M] {n : M} (h : Function.Injective fun m : ℕ => n ^ m) :\n    Multiplicative ℕ ≃* powers n where\n  toFun m := pow n m.toAdd\n  invFun m := Multiplicative.ofAdd (log m)\n  left_inv := log_pow_eq_self h\n  right_inv := pow_log_eq_self\n  map_mul' _ _ := by simp only [pow, map_mul, ofAdd_add, toAdd_mul]\n\n"}
{"name":"Submonoid.powLogEquiv_symm_apply","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝¹ : Monoid M\ninst✝ : DecidableEq M\nn : M\nh : Function.Injective fun m => HPow.hPow n m\nm : Subtype fun x => Membership.mem (Submonoid.powers n) x\n⊢ Eq ((Submonoid.powLogEquiv h).symm m) (Multiplicative.ofAdd (Submonoid.log m))","decl":"/-- The exponentiation map is an isomorphism from the additive monoid on natural numbers to powers\nwhen it is injective. The inverse is given by the logarithms. -/\n@[simps]\ndef powLogEquiv [DecidableEq M] {n : M} (h : Function.Injective fun m : ℕ => n ^ m) :\n    Multiplicative ℕ ≃* powers n where\n  toFun m := pow n m.toAdd\n  invFun m := Multiplicative.ofAdd (log m)\n  left_inv := log_pow_eq_self h\n  right_inv := pow_log_eq_self\n  map_mul' _ _ := by simp only [pow, map_mul, ofAdd_add, toAdd_mul]\n\n"}
{"name":"Submonoid.log_mul","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝¹ : Monoid M\ninst✝ : DecidableEq M\nn : M\nh : Function.Injective fun m => HPow.hPow n m\nx y : Subtype fun x => Membership.mem (Submonoid.powers n) x\n⊢ Eq (Submonoid.log (HMul.hMul x y)) (HAdd.hAdd (Submonoid.log x) (Submonoid.log y))","decl":"theorem log_mul [DecidableEq M] {n : M} (h : Function.Injective fun m : ℕ => n ^ m)\n    (x y : powers (n : M)) : log (x * y) = log x + log y :=\n  map_mul (powLogEquiv h).symm x y\n\n"}
{"name":"Submonoid.log_pow_int_eq_self","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"x : Int\nh : LT.lt 1 x.natAbs\nm : Nat\n⊢ Eq (Submonoid.log (Submonoid.pow x m)) m","decl":"theorem log_pow_int_eq_self {x : ℤ} (h : 1 < x.natAbs) (m : ℕ) : log (pow x m) = m :=\n  (powLogEquiv (Int.pow_right_injective h)).symm_apply_apply _\n\n"}
{"name":"Submonoid.map_powers","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝³ : Monoid M\nN : Type u_4\nF : Type u_5\ninst✝² : Monoid N\ninst✝¹ : FunLike F M N\ninst✝ : MonoidHomClass F M N\nf : F\nm : M\n⊢ Eq (Submonoid.map f (Submonoid.powers m)) (Submonoid.powers (f m))","decl":"@[simp]\ntheorem map_powers {N : Type*} {F : Type*} [Monoid N] [FunLike F M N] [MonoidHomClass F M N]\n    (f : F) (m : M) :\n    (powers m).map f = powers (f m) := by\n  simp only [powers_eq_closure, map_mclosure f, Set.image_singleton]\n\n"}
{"name":"VAddAssocClass.of_mclosure_eq_top","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\nN : Type u_4\nα : Type u_5\ninst✝³ : AddMonoid M\ninst✝² : AddAction M N\ninst✝¹ : VAdd N α\ninst✝ : AddAction M α\ns : Set M\nhtop : Eq (AddSubmonoid.closure s) Top.top\nhs : ∀ (x : M), Membership.mem s x → ∀ (y : N) (z : α), Eq (HVAdd.hVAdd (HVAdd.hVAdd x y) z) (HVAdd.hVAdd x (HVAdd.hVAdd y z))\n⊢ VAddAssocClass M N α","decl":"@[to_additive]\ntheorem IsScalarTower.of_mclosure_eq_top {N α} [Monoid M] [MulAction M N] [SMul N α] [MulAction M α]\n    {s : Set M} (htop : Submonoid.closure s = ⊤)\n    (hs : ∀ x ∈ s, ∀ (y : N) (z : α), (x • y) • z = x • y • z) : IsScalarTower M N α := by\n  refine ⟨fun x => Submonoid.induction_of_closure_eq_top_left htop x ?_ ?_⟩\n  · intro y z\n    rw [one_smul, one_smul]\n  · clear x\n    intro x hx x' hx' y z\n    rw [mul_smul, mul_smul, hs x hx, hx']\n\n"}
{"name":"IsScalarTower.of_mclosure_eq_top","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\nN : Type u_4\nα : Type u_5\ninst✝³ : Monoid M\ninst✝² : MulAction M N\ninst✝¹ : SMul N α\ninst✝ : MulAction M α\ns : Set M\nhtop : Eq (Submonoid.closure s) Top.top\nhs : ∀ (x : M), Membership.mem s x → ∀ (y : N) (z : α), Eq (HSMul.hSMul (HSMul.hSMul x y) z) (HSMul.hSMul x (HSMul.hSMul y z))\n⊢ IsScalarTower M N α","decl":"@[to_additive]\ntheorem IsScalarTower.of_mclosure_eq_top {N α} [Monoid M] [MulAction M N] [SMul N α] [MulAction M α]\n    {s : Set M} (htop : Submonoid.closure s = ⊤)\n    (hs : ∀ x ∈ s, ∀ (y : N) (z : α), (x • y) • z = x • y • z) : IsScalarTower M N α := by\n  refine ⟨fun x => Submonoid.induction_of_closure_eq_top_left htop x ?_ ?_⟩\n  · intro y z\n    rw [one_smul, one_smul]\n  · clear x\n    intro x hx x' hx' y z\n    rw [mul_smul, mul_smul, hs x hx, hx']\n\n"}
{"name":"VAddCommClass.of_mclosure_eq_top","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\nN : Type u_4\nα : Type u_5\ninst✝² : AddMonoid M\ninst✝¹ : VAdd N α\ninst✝ : AddAction M α\ns : Set M\nhtop : Eq (AddSubmonoid.closure s) Top.top\nhs : ∀ (x : M), Membership.mem s x → ∀ (y : N) (z : α), Eq (HVAdd.hVAdd x (HVAdd.hVAdd y z)) (HVAdd.hVAdd y (HVAdd.hVAdd x z))\n⊢ VAddCommClass M N α","decl":"@[to_additive]\ntheorem SMulCommClass.of_mclosure_eq_top {N α} [Monoid M] [SMul N α] [MulAction M α] {s : Set M}\n    (htop : Submonoid.closure s = ⊤) (hs : ∀ x ∈ s, ∀ (y : N) (z : α), x • y • z = y • x • z) :\n    SMulCommClass M N α := by\n  refine ⟨fun x => Submonoid.induction_of_closure_eq_top_left htop x ?_ ?_⟩\n  · intro y z\n    rw [one_smul, one_smul]\n  · clear x\n    intro x hx x' hx' y z\n    rw [mul_smul, mul_smul, hx', hs x hx]\n\n"}
{"name":"SMulCommClass.of_mclosure_eq_top","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\nN : Type u_4\nα : Type u_5\ninst✝² : Monoid M\ninst✝¹ : SMul N α\ninst✝ : MulAction M α\ns : Set M\nhtop : Eq (Submonoid.closure s) Top.top\nhs : ∀ (x : M), Membership.mem s x → ∀ (y : N) (z : α), Eq (HSMul.hSMul x (HSMul.hSMul y z)) (HSMul.hSMul y (HSMul.hSMul x z))\n⊢ SMulCommClass M N α","decl":"@[to_additive]\ntheorem SMulCommClass.of_mclosure_eq_top {N α} [Monoid M] [SMul N α] [MulAction M α] {s : Set M}\n    (htop : Submonoid.closure s = ⊤) (hs : ∀ x ∈ s, ∀ (y : N) (z : α), x • y • z = y • x • z) :\n    SMulCommClass M N α := by\n  refine ⟨fun x => Submonoid.induction_of_closure_eq_top_left htop x ?_ ?_⟩\n  · intro y z\n    rw [one_smul, one_smul]\n  · clear x\n    intro x hx x' hx' y z\n    rw [mul_smul, mul_smul, hx', hs x hx]\n\n"}
{"name":"AddSubmonoid.sup_eq_range","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"N : Type u_4\ninst✝ : AddCommMonoid N\ns t : AddSubmonoid N\n⊢ Eq (Max.max s t) (AddMonoidHom.mrange (s.subtype.coprod t.subtype))","decl":"@[to_additive]\ntheorem sup_eq_range (s t : Submonoid N) : s ⊔ t = mrange (s.subtype.coprod t.subtype) := by\n  rw [mrange_eq_map, ← mrange_inl_sup_mrange_inr, map_sup, map_mrange, coprod_comp_inl, map_mrange,\n    coprod_comp_inr, mrange_subtype, mrange_subtype]\n\n"}
{"name":"Submonoid.sup_eq_range","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"N : Type u_4\ninst✝ : CommMonoid N\ns t : Submonoid N\n⊢ Eq (Max.max s t) (MonoidHom.mrange (s.subtype.coprod t.subtype))","decl":"@[to_additive]\ntheorem sup_eq_range (s t : Submonoid N) : s ⊔ t = mrange (s.subtype.coprod t.subtype) := by\n  rw [mrange_eq_map, ← mrange_inl_sup_mrange_inr, map_sup, map_mrange, coprod_comp_inl, map_mrange,\n    coprod_comp_inr, mrange_subtype, mrange_subtype]\n\n"}
{"name":"Submonoid.mem_sup","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"N : Type u_4\ninst✝ : CommMonoid N\ns t : Submonoid N\nx : N\n⊢ Iff (Membership.mem (Max.max s t) x) (Exists fun y => And (Membership.mem s y) (Exists fun z => And (Membership.mem t z) (Eq (HMul.hMul y z) x)))","decl":"@[to_additive]\ntheorem mem_sup {s t : Submonoid N} {x : N} : x ∈ s ⊔ t ↔ ∃ y ∈ s, ∃ z ∈ t, y * z = x := by\n  simp only [sup_eq_range, mem_mrange, coprod_apply, coe_subtype, Prod.exists,\n    Subtype.exists, exists_prop]\n\n"}
{"name":"AddSubmonoid.mem_sup","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"N : Type u_4\ninst✝ : AddCommMonoid N\ns t : AddSubmonoid N\nx : N\n⊢ Iff (Membership.mem (Max.max s t) x) (Exists fun y => And (Membership.mem s y) (Exists fun z => And (Membership.mem t z) (Eq (HAdd.hAdd y z) x)))","decl":"@[to_additive]\ntheorem mem_sup {s t : Submonoid N} {x : N} : x ∈ s ⊔ t ↔ ∃ y ∈ s, ∃ z ∈ t, y * z = x := by\n  simp only [sup_eq_range, mem_mrange, coprod_apply, coe_subtype, Prod.exists,\n    Subtype.exists, exists_prop]\n\n"}
{"name":"AddSubmonoid.closure_singleton_eq","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"A : Type u_2\ninst✝ : AddMonoid A\nx : A\n⊢ Eq (AddSubmonoid.closure (Singleton.singleton x)) (AddMonoidHom.mrange ((multiplesHom A) x))","decl":"theorem closure_singleton_eq (x : A) :\n    closure ({x} : Set A) = AddMonoidHom.mrange (multiplesHom A x) :=\n  closure_eq_of_le (Set.singleton_subset_iff.2 ⟨1, one_nsmul x⟩) fun _ ⟨_n, hn⟩ =>\n    hn ▸ nsmul_mem (subset_closure <| Set.mem_singleton _) _\n\n"}
{"name":"AddSubmonoid.mem_closure_singleton","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"A : Type u_2\ninst✝ : AddMonoid A\nx y : A\n⊢ Iff (Membership.mem (AddSubmonoid.closure (Singleton.singleton x)) y) (Exists fun n => Eq (HSMul.hSMul n x) y)","decl":"/-- The `AddSubmonoid` generated by an element of an `AddMonoid` equals the set of\nnatural number multiples of the element. -/\ntheorem mem_closure_singleton {x y : A} : y ∈ closure ({x} : Set A) ↔ ∃ n : ℕ, n • x = y := by\n  rw [closure_singleton_eq, AddMonoidHom.mem_mrange]; rfl\n\n"}
{"name":"AddSubmonoid.closure_singleton_zero","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"A : Type u_2\ninst✝ : AddMonoid A\n⊢ Eq (AddSubmonoid.closure (Singleton.singleton 0)) Bot.bot","decl":"theorem closure_singleton_zero : closure ({0} : Set A) = ⊥ := by\n  simp [eq_bot_iff_forall, mem_closure_singleton, nsmul_zero]\n\n"}
{"name":"AddSubmonoid.mem_multiples","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nn : M\n⊢ Membership.mem (AddSubmonoid.multiples n) n","decl":"attribute [to_additive (attr := simp)] Submonoid.mem_powers\n\n"}
{"name":"AddSubmonoid.coe_multiples","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nx : M\n⊢ Eq (↑(AddSubmonoid.multiples x)) (Set.range fun n => HSMul.hSMul n x)","decl":"attribute [to_additive (attr := norm_cast)] Submonoid.coe_powers\n\n"}
{"name":"AddSubmonoid.mem_multiples_iff","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nx z : M\n⊢ Iff (Membership.mem (AddSubmonoid.multiples z) x) (Exists fun n => Eq (HSMul.hSMul n z) x)","decl":"attribute [to_additive] Submonoid.mem_powers_iff\n\n"}
{"name":"AddSubmonoid.multiples_eq_closure","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nn : M\n⊢ Eq (AddSubmonoid.multiples n) (AddSubmonoid.closure (Singleton.singleton n))","decl":"attribute [to_additive] Submonoid.powers_eq_closure\n\n"}
{"name":"AddSubmonoid.multiples_le","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\nn : M\nP : AddSubmonoid M\n⊢ Iff (LE.le (AddSubmonoid.multiples n) P) (Membership.mem P n)","decl":"attribute [to_additive] Submonoid.powers_le\n\n"}
{"name":"AddSubmonoid.multiples_zero","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : AddMonoid M\n⊢ Eq (AddSubmonoid.multiples 0) Bot.bot","decl":"attribute [to_additive (attr := simp)] Submonoid.powers_one\n\n"}
{"name":"AddSubmonoid.mem_closure_pair","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"A : Type u_4\ninst✝ : AddCommMonoid A\na b c : A\n⊢ Iff (Membership.mem (AddSubmonoid.closure (Insert.insert a (Singleton.singleton b))) c) (Exists fun m => Exists fun n => Eq (HAdd.hAdd (HSMul.hSMul m a) (HSMul.hSMul n b)) c)","decl":"/-- An element is in the closure of a two-element set if it is a linear combination of those two\nelements. -/\n@[to_additive\n      \"An element is in the closure of a two-element set if it is a linear combination of\n      those two elements.\"]\ntheorem mem_closure_pair {A : Type*} [CommMonoid A] (a b c : A) :\n    c ∈ Submonoid.closure ({a, b} : Set A) ↔ ∃ m n : ℕ, a ^ m * b ^ n = c := by\n  rw [← Set.singleton_union, Submonoid.closure_union, mem_sup]\n  simp_rw [mem_closure_singleton, exists_exists_eq_and]\n\n"}
{"name":"Submonoid.mem_closure_pair","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"A : Type u_4\ninst✝ : CommMonoid A\na b c : A\n⊢ Iff (Membership.mem (Submonoid.closure (Insert.insert a (Singleton.singleton b))) c) (Exists fun m => Exists fun n => Eq (HMul.hMul (HPow.hPow a m) (HPow.hPow b n)) c)","decl":"/-- An element is in the closure of a two-element set if it is a linear combination of those two\nelements. -/\n@[to_additive\n      \"An element is in the closure of a two-element set if it is a linear combination of\n      those two elements.\"]\ntheorem mem_closure_pair {A : Type*} [CommMonoid A] (a b c : A) :\n    c ∈ Submonoid.closure ({a, b} : Set A) ↔ ∃ m n : ℕ, a ^ m * b ^ n = c := by\n  rw [← Set.singleton_union, Submonoid.closure_union, mem_sup]\n  simp_rw [mem_closure_singleton, exists_exists_eq_and]\n\n"}
{"name":"ofMul_image_powers_eq_multiples_ofMul","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"M : Type u_1\ninst✝ : Monoid M\nx : M\n⊢ Eq (Set.image ⇑Additive.ofMul ↑(Submonoid.powers x)) ↑(AddSubmonoid.multiples (Additive.ofMul x))","decl":"theorem ofMul_image_powers_eq_multiples_ofMul [Monoid M] {x : M} :\n    Additive.ofMul '' (Submonoid.powers x : Set M) = AddSubmonoid.multiples (Additive.ofMul x) := by\n  ext\n  constructor\n  · rintro ⟨y, ⟨n, hy1⟩, hy2⟩\n    use n\n    simpa [← ofMul_pow, hy1]\n  · rintro ⟨n, hn⟩\n    refine ⟨x ^ n, ⟨n, rfl⟩, ?_⟩\n    rwa [ofMul_pow]\n\n"}
{"name":"ofAdd_image_multiples_eq_powers_ofAdd","module":"Mathlib.Algebra.Group.Submonoid.Membership","initialProofState":"A : Type u_2\ninst✝ : AddMonoid A\nx : A\n⊢ Eq (Set.image ⇑Multiplicative.ofAdd ↑(AddSubmonoid.multiples x)) ↑(Submonoid.powers (Multiplicative.ofAdd x))","decl":"theorem ofAdd_image_multiples_eq_powers_ofAdd [AddMonoid A] {x : A} :\n    Multiplicative.ofAdd '' (AddSubmonoid.multiples x : Set A) =\n      Submonoid.powers (Multiplicative.ofAdd x) := by\n  symm\n  rw [Equiv.eq_image_iff_symm_image_eq]\n  exact ofMul_image_powers_eq_multiples_ofMul\n\n"}
