{"name":"NormalizationMonoid.normUnit_coe_units","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_2\ninst✝ : CancelCommMonoidWithZero α\nself : NormalizationMonoid α\nu : Units α\n⊢ Eq (NormalizationMonoid.normUnit ↑u) (Inv.inv u)","decl":"/-- Normalization monoid: multiplying with `normUnit` gives a normal form for associated\nelements. -/\nclass NormalizationMonoid (α : Type*) [CancelCommMonoidWithZero α] where\n  /-- `normUnit` assigns to each element of the monoid a unit of the monoid. -/\n  normUnit : α → αˣ\n  /-- The proposition that `normUnit` maps `0` to the identity. -/\n  normUnit_zero : normUnit 0 = 1\n  /-- The proposition that `normUnit` respects multiplication of non-zero elements. -/\n  normUnit_mul : ∀ {a b}, a ≠ 0 → b ≠ 0 → normUnit (a * b) = normUnit a * normUnit b\n  /-- The proposition that `normUnit` maps units to their inverses. -/\n  normUnit_coe_units : ∀ u : αˣ, normUnit u = u⁻¹\n\n"}
{"name":"NormalizationMonoid.normUnit_mul","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_2\ninst✝ : CancelCommMonoidWithZero α\nself : NormalizationMonoid α\na b : α\na✝¹ : Ne a 0\na✝ : Ne b 0\n⊢ Eq (NormalizationMonoid.normUnit (HMul.hMul a b)) (HMul.hMul (NormalizationMonoid.normUnit a) (NormalizationMonoid.normUnit b))","decl":"/-- Normalization monoid: multiplying with `normUnit` gives a normal form for associated\nelements. -/\nclass NormalizationMonoid (α : Type*) [CancelCommMonoidWithZero α] where\n  /-- `normUnit` assigns to each element of the monoid a unit of the monoid. -/\n  normUnit : α → αˣ\n  /-- The proposition that `normUnit` maps `0` to the identity. -/\n  normUnit_zero : normUnit 0 = 1\n  /-- The proposition that `normUnit` respects multiplication of non-zero elements. -/\n  normUnit_mul : ∀ {a b}, a ≠ 0 → b ≠ 0 → normUnit (a * b) = normUnit a * normUnit b\n  /-- The proposition that `normUnit` maps units to their inverses. -/\n  normUnit_coe_units : ∀ u : αˣ, normUnit u = u⁻¹\n\n"}
{"name":"NormalizationMonoid.normUnit_zero","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_2\ninst✝ : CancelCommMonoidWithZero α\nself : NormalizationMonoid α\n⊢ Eq (NormalizationMonoid.normUnit 0) 1","decl":"/-- Normalization monoid: multiplying with `normUnit` gives a normal form for associated\nelements. -/\nclass NormalizationMonoid (α : Type*) [CancelCommMonoidWithZero α] where\n  /-- `normUnit` assigns to each element of the monoid a unit of the monoid. -/\n  normUnit : α → αˣ\n  /-- The proposition that `normUnit` maps `0` to the identity. -/\n  normUnit_zero : normUnit 0 = 1\n  /-- The proposition that `normUnit` respects multiplication of non-zero elements. -/\n  normUnit_mul : ∀ {a b}, a ≠ 0 → b ≠ 0 → normUnit (a * b) = normUnit a * normUnit b\n  /-- The proposition that `normUnit` maps units to their inverses. -/\n  normUnit_coe_units : ∀ u : αˣ, normUnit u = u⁻¹\n\n"}
{"name":"normUnit_one","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\n⊢ Eq (NormalizationMonoid.normUnit 1) 1","decl":"@[simp]\ntheorem normUnit_one : normUnit (1 : α) = 1 :=\n  normUnit_coe_units 1\n\n"}
{"name":"associated_normalize","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\nx : α\n⊢ Associated x (normalize x)","decl":"theorem associated_normalize (x : α) : Associated x (normalize x) :=\n  ⟨_, rfl⟩\n\n"}
{"name":"normalize_associated","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\nx : α\n⊢ Associated (normalize x) x","decl":"theorem normalize_associated (x : α) : Associated (normalize x) x :=\n  (associated_normalize _).symm\n\n"}
{"name":"associated_normalize_iff","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\nx y : α\n⊢ Iff (Associated x (normalize y)) (Associated x y)","decl":"theorem associated_normalize_iff {x y : α} : Associated x (normalize y) ↔ Associated x y :=\n  ⟨fun h => h.trans (normalize_associated y), fun h => h.trans (associated_normalize y)⟩\n\n"}
{"name":"normalize_associated_iff","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\nx y : α\n⊢ Iff (Associated (normalize x) y) (Associated x y)","decl":"theorem normalize_associated_iff {x y : α} : Associated (normalize x) y ↔ Associated x y :=\n  ⟨fun h => (associated_normalize _).trans h, fun h => (normalize_associated _).trans h⟩\n\n"}
{"name":"Associates.mk_normalize","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\nx : α\n⊢ Eq (Associates.mk (normalize x)) (Associates.mk x)","decl":"theorem Associates.mk_normalize (x : α) : Associates.mk (normalize x) = Associates.mk x :=\n  Associates.mk_eq_mk_iff_associated.2 (normalize_associated _)\n\n"}
{"name":"normalize_apply","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\nx : α\n⊢ Eq (normalize x) (HMul.hMul x ↑(NormalizationMonoid.normUnit x))","decl":"theorem normalize_apply (x : α) : normalize x = x * normUnit x :=\n  rfl\n\n"}
{"name":"normalize_zero","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\n⊢ Eq (normalize 0) 0","decl":"theorem normalize_zero : normalize (0 : α) = 0 :=\n  normalize.map_zero\n\n"}
{"name":"normalize_one","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\n⊢ Eq (normalize 1) 1","decl":"theorem normalize_one : normalize (1 : α) = 1 :=\n  normalize.map_one\n\n"}
{"name":"normalize_coe_units","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\nu : Units α\n⊢ Eq (normalize ↑u) 1","decl":"theorem normalize_coe_units (u : αˣ) : normalize (u : α) = 1 := by simp [normalize_apply]\n\n"}
{"name":"normalize_eq_zero","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\nx : α\n⊢ Iff (Eq (normalize x) 0) (Eq x 0)","decl":"theorem normalize_eq_zero {x : α} : normalize x = 0 ↔ x = 0 :=\n  ⟨fun hx => (associated_zero_iff_eq_zero x).1 <| hx ▸ associated_normalize _, by\n    rintro rfl; exact normalize_zero⟩\n\n"}
{"name":"normalize_eq_one","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\nx : α\n⊢ Iff (Eq (normalize x) 1) (IsUnit x)","decl":"theorem normalize_eq_one {x : α} : normalize x = 1 ↔ IsUnit x :=\n  ⟨fun hx => isUnit_iff_exists_inv.2 ⟨_, hx⟩, fun ⟨u, hu⟩ => hu ▸ normalize_coe_units u⟩\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11083): quite slow. Improve performance?\n"}
{"name":"normUnit_mul_normUnit","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\na : α\n⊢ Eq (NormalizationMonoid.normUnit (HMul.hMul a ↑(NormalizationMonoid.normUnit a))) 1","decl":"@[simp]\ntheorem normUnit_mul_normUnit (a : α) : normUnit (a * normUnit a) = 1 := by\n  nontriviality α using Subsingleton.elim a 0\n  obtain rfl | h := eq_or_ne a 0\n  · rw [normUnit_zero, zero_mul, normUnit_zero]\n  · rw [normUnit_mul h (Units.ne_zero _), normUnit_coe_units, mul_inv_eq_one]\n\n"}
{"name":"normalize_idem","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\nx : α\n⊢ Eq (normalize (normalize x)) (normalize x)","decl":"@[simp]\ntheorem normalize_idem (x : α) : normalize (normalize x) = normalize x := by simp [normalize_apply]\n\n"}
{"name":"normalize_eq_normalize","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\na b : α\nhab : Dvd.dvd a b\nhba : Dvd.dvd b a\n⊢ Eq (normalize a) (normalize b)","decl":"theorem normalize_eq_normalize {a b : α} (hab : a ∣ b) (hba : b ∣ a) :\n    normalize a = normalize b := by\n  nontriviality α\n  rcases associated_of_dvd_dvd hab hba with ⟨u, rfl⟩\n  refine by_cases (by rintro rfl; simp only [zero_mul]) fun ha : a ≠ 0 => ?_\n  suffices a * ↑(normUnit a) = a * ↑u * ↑(normUnit a) * ↑u⁻¹ by\n    simpa only [normalize_apply, mul_assoc, normUnit_mul ha u.ne_zero, normUnit_coe_units]\n  calc\n    a * ↑(normUnit a) = a * ↑(normUnit a) * ↑u * ↑u⁻¹ := (Units.mul_inv_cancel_right _ _).symm\n    _ = a * ↑u * ↑(normUnit a) * ↑u⁻¹ := by rw [mul_right_comm a]\n\n"}
{"name":"normalize_eq_normalize_iff","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\nx y : α\n⊢ Iff (Eq (normalize x) (normalize y)) (And (Dvd.dvd x y) (Dvd.dvd y x))","decl":"theorem normalize_eq_normalize_iff {x y : α} : normalize x = normalize y ↔ x ∣ y ∧ y ∣ x :=\n  ⟨fun h => ⟨Units.dvd_mul_right.1 ⟨_, h.symm⟩, Units.dvd_mul_right.1 ⟨_, h⟩⟩, fun ⟨hxy, hyx⟩ =>\n    normalize_eq_normalize hxy hyx⟩\n\n"}
{"name":"dvd_antisymm_of_normalize_eq","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\na b : α\nha : Eq (normalize a) a\nhb : Eq (normalize b) b\nhab : Dvd.dvd a b\nhba : Dvd.dvd b a\n⊢ Eq a b","decl":"theorem dvd_antisymm_of_normalize_eq {a b : α} (ha : normalize a = a) (hb : normalize b = b)\n    (hab : a ∣ b) (hba : b ∣ a) : a = b :=\n  ha ▸ hb ▸ normalize_eq_normalize hab hba\n\n"}
{"name":"Associated.eq_of_normalized","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\na b : α\nh : Associated a b\nha : Eq (normalize a) a\nhb : Eq (normalize b) b\n⊢ Eq a b","decl":"theorem Associated.eq_of_normalized\n    {a b : α} (h : Associated a b) (ha : normalize a = a) (hb : normalize b = b) :\n    a = b :=\n  dvd_antisymm_of_normalize_eq ha hb h.dvd h.dvd'\n\n"}
{"name":"dvd_normalize_iff","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\na b : α\n⊢ Iff (Dvd.dvd a (normalize b)) (Dvd.dvd a b)","decl":"@[simp]\ntheorem dvd_normalize_iff {a b : α} : a ∣ normalize b ↔ a ∣ b :=\n  Units.dvd_mul_right\n\n"}
{"name":"normalize_dvd_iff","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\na b : α\n⊢ Iff (Dvd.dvd (normalize a) b) (Dvd.dvd a b)","decl":"@[simp]\ntheorem normalize_dvd_iff {a b : α} : normalize a ∣ b ↔ a ∣ b :=\n  Units.mul_right_dvd\n\n"}
{"name":"Associates.out_mk","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\na : α\n⊢ Eq (Associates.mk a).out (normalize a)","decl":"@[simp]\ntheorem out_mk (a : α) : (Associates.mk a).out = normalize a :=\n  rfl\n\n"}
{"name":"Associates.out_one","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\n⊢ Eq (Associates.out 1) 1","decl":"@[simp]\ntheorem out_one : (1 : Associates α).out = 1 :=\n  normalize_one\n\n"}
{"name":"Associates.out_mul","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\na b : Associates α\n⊢ Eq (HMul.hMul a b).out (HMul.hMul a.out b.out)","decl":"theorem out_mul (a b : Associates α) : (a * b).out = a.out * b.out :=\n  Quotient.inductionOn₂ a b fun _ _ => by\n    simp only [Associates.quotient_mk_eq_mk, out_mk, mk_mul_mk, normalize.map_mul]\n\n"}
{"name":"Associates.dvd_out_iff","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\na : α\nb : Associates α\n⊢ Iff (Dvd.dvd a b.out) (LE.le (Associates.mk a) b)","decl":"theorem dvd_out_iff (a : α) (b : Associates α) : a ∣ b.out ↔ Associates.mk a ≤ b :=\n  Quotient.inductionOn b <| by\n    simp [Associates.out_mk, Associates.quotient_mk_eq_mk, mk_le_mk_iff_dvd]\n\n"}
{"name":"Associates.out_dvd_iff","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\na : α\nb : Associates α\n⊢ Iff (Dvd.dvd b.out a) (LE.le b (Associates.mk a))","decl":"theorem out_dvd_iff (a : α) (b : Associates α) : b.out ∣ a ↔ b ≤ Associates.mk a :=\n  Quotient.inductionOn b <| by\n    simp [Associates.out_mk, Associates.quotient_mk_eq_mk, mk_le_mk_iff_dvd]\n\n"}
{"name":"Associates.out_top","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\n⊢ Eq Top.top.out 0","decl":"@[simp]\ntheorem out_top : (⊤ : Associates α).out = 0 :=\n  normalize_zero\n\n"}
{"name":"Associates.normalize_out","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\na : Associates α\n⊢ Eq (normalize a.out) a.out","decl":"@[simp]\ntheorem normalize_out (a : Associates α) : normalize a.out = a.out :=\n  Quotient.inductionOn a normalize_idem\n\n"}
{"name":"Associates.mk_out","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\na : Associates α\n⊢ Eq (Associates.mk a.out) a","decl":"@[simp]\ntheorem mk_out (a : Associates α) : Associates.mk a.out = a :=\n  Quotient.inductionOn a mk_normalize\n\n"}
{"name":"Associates.out_injective","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\n⊢ Function.Injective Associates.out","decl":"theorem out_injective : Function.Injective (Associates.out : _ → α) :=\n  Function.LeftInverse.injective mk_out\n\n"}
{"name":"GCDMonoid.dvd_gcd","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_2\ninst✝ : CancelCommMonoidWithZero α\nself : GCDMonoid α\na b c : α\na✝¹ : Dvd.dvd a c\na✝ : Dvd.dvd a b\n⊢ Dvd.dvd a (GCDMonoid.gcd c b)","decl":"/-- GCD monoid: a `CancelCommMonoidWithZero` with `gcd` (greatest common divisor) and\n`lcm` (least common multiple) operations, determined up to a unit. The type class focuses on `gcd`\nand we derive the corresponding `lcm` facts from `gcd`.\n-/\nclass GCDMonoid (α : Type*) [CancelCommMonoidWithZero α] where\n  /-- The greatest common divisor between two elements. -/\n  gcd : α → α → α\n  /-- The least common multiple between two elements. -/\n  lcm : α → α → α\n  /-- The GCD is a divisor of the first element. -/\n  gcd_dvd_left : ∀ a b, gcd a b ∣ a\n  /-- The GCD is a divisor of the second element. -/\n  gcd_dvd_right : ∀ a b, gcd a b ∣ b\n  /-- Any common divisor of both elements is a divisor of the GCD. -/\n  dvd_gcd : ∀ {a b c}, a ∣ c → a ∣ b → a ∣ gcd c b\n  /-- The product of two elements is `Associated` with the product of their GCD and LCM. -/\n  gcd_mul_lcm : ∀ a b, Associated (gcd a b * lcm a b) (a * b)\n  /-- `0` is left-absorbing. -/\n  lcm_zero_left : ∀ a, lcm 0 a = 0\n  /-- `0` is right-absorbing. -/\n  lcm_zero_right : ∀ a, lcm a 0 = 0\n\n"}
{"name":"GCDMonoid.lcm_zero_left","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_2\ninst✝ : CancelCommMonoidWithZero α\nself : GCDMonoid α\na : α\n⊢ Eq (GCDMonoid.lcm 0 a) 0","decl":"/-- GCD monoid: a `CancelCommMonoidWithZero` with `gcd` (greatest common divisor) and\n`lcm` (least common multiple) operations, determined up to a unit. The type class focuses on `gcd`\nand we derive the corresponding `lcm` facts from `gcd`.\n-/\nclass GCDMonoid (α : Type*) [CancelCommMonoidWithZero α] where\n  /-- The greatest common divisor between two elements. -/\n  gcd : α → α → α\n  /-- The least common multiple between two elements. -/\n  lcm : α → α → α\n  /-- The GCD is a divisor of the first element. -/\n  gcd_dvd_left : ∀ a b, gcd a b ∣ a\n  /-- The GCD is a divisor of the second element. -/\n  gcd_dvd_right : ∀ a b, gcd a b ∣ b\n  /-- Any common divisor of both elements is a divisor of the GCD. -/\n  dvd_gcd : ∀ {a b c}, a ∣ c → a ∣ b → a ∣ gcd c b\n  /-- The product of two elements is `Associated` with the product of their GCD and LCM. -/\n  gcd_mul_lcm : ∀ a b, Associated (gcd a b * lcm a b) (a * b)\n  /-- `0` is left-absorbing. -/\n  lcm_zero_left : ∀ a, lcm 0 a = 0\n  /-- `0` is right-absorbing. -/\n  lcm_zero_right : ∀ a, lcm a 0 = 0\n\n"}
{"name":"GCDMonoid.gcd_mul_lcm","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_2\ninst✝ : CancelCommMonoidWithZero α\nself : GCDMonoid α\na b : α\n⊢ Associated (HMul.hMul (GCDMonoid.gcd a b) (GCDMonoid.lcm a b)) (HMul.hMul a b)","decl":"/-- GCD monoid: a `CancelCommMonoidWithZero` with `gcd` (greatest common divisor) and\n`lcm` (least common multiple) operations, determined up to a unit. The type class focuses on `gcd`\nand we derive the corresponding `lcm` facts from `gcd`.\n-/\nclass GCDMonoid (α : Type*) [CancelCommMonoidWithZero α] where\n  /-- The greatest common divisor between two elements. -/\n  gcd : α → α → α\n  /-- The least common multiple between two elements. -/\n  lcm : α → α → α\n  /-- The GCD is a divisor of the first element. -/\n  gcd_dvd_left : ∀ a b, gcd a b ∣ a\n  /-- The GCD is a divisor of the second element. -/\n  gcd_dvd_right : ∀ a b, gcd a b ∣ b\n  /-- Any common divisor of both elements is a divisor of the GCD. -/\n  dvd_gcd : ∀ {a b c}, a ∣ c → a ∣ b → a ∣ gcd c b\n  /-- The product of two elements is `Associated` with the product of their GCD and LCM. -/\n  gcd_mul_lcm : ∀ a b, Associated (gcd a b * lcm a b) (a * b)\n  /-- `0` is left-absorbing. -/\n  lcm_zero_left : ∀ a, lcm 0 a = 0\n  /-- `0` is right-absorbing. -/\n  lcm_zero_right : ∀ a, lcm a 0 = 0\n\n"}
{"name":"GCDMonoid.gcd_dvd_right","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_2\ninst✝ : CancelCommMonoidWithZero α\nself : GCDMonoid α\na b : α\n⊢ Dvd.dvd (GCDMonoid.gcd a b) b","decl":"/-- GCD monoid: a `CancelCommMonoidWithZero` with `gcd` (greatest common divisor) and\n`lcm` (least common multiple) operations, determined up to a unit. The type class focuses on `gcd`\nand we derive the corresponding `lcm` facts from `gcd`.\n-/\nclass GCDMonoid (α : Type*) [CancelCommMonoidWithZero α] where\n  /-- The greatest common divisor between two elements. -/\n  gcd : α → α → α\n  /-- The least common multiple between two elements. -/\n  lcm : α → α → α\n  /-- The GCD is a divisor of the first element. -/\n  gcd_dvd_left : ∀ a b, gcd a b ∣ a\n  /-- The GCD is a divisor of the second element. -/\n  gcd_dvd_right : ∀ a b, gcd a b ∣ b\n  /-- Any common divisor of both elements is a divisor of the GCD. -/\n  dvd_gcd : ∀ {a b c}, a ∣ c → a ∣ b → a ∣ gcd c b\n  /-- The product of two elements is `Associated` with the product of their GCD and LCM. -/\n  gcd_mul_lcm : ∀ a b, Associated (gcd a b * lcm a b) (a * b)\n  /-- `0` is left-absorbing. -/\n  lcm_zero_left : ∀ a, lcm 0 a = 0\n  /-- `0` is right-absorbing. -/\n  lcm_zero_right : ∀ a, lcm a 0 = 0\n\n"}
{"name":"GCDMonoid.gcd_dvd_left","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_2\ninst✝ : CancelCommMonoidWithZero α\nself : GCDMonoid α\na b : α\n⊢ Dvd.dvd (GCDMonoid.gcd a b) a","decl":"/-- GCD monoid: a `CancelCommMonoidWithZero` with `gcd` (greatest common divisor) and\n`lcm` (least common multiple) operations, determined up to a unit. The type class focuses on `gcd`\nand we derive the corresponding `lcm` facts from `gcd`.\n-/\nclass GCDMonoid (α : Type*) [CancelCommMonoidWithZero α] where\n  /-- The greatest common divisor between two elements. -/\n  gcd : α → α → α\n  /-- The least common multiple between two elements. -/\n  lcm : α → α → α\n  /-- The GCD is a divisor of the first element. -/\n  gcd_dvd_left : ∀ a b, gcd a b ∣ a\n  /-- The GCD is a divisor of the second element. -/\n  gcd_dvd_right : ∀ a b, gcd a b ∣ b\n  /-- Any common divisor of both elements is a divisor of the GCD. -/\n  dvd_gcd : ∀ {a b c}, a ∣ c → a ∣ b → a ∣ gcd c b\n  /-- The product of two elements is `Associated` with the product of their GCD and LCM. -/\n  gcd_mul_lcm : ∀ a b, Associated (gcd a b * lcm a b) (a * b)\n  /-- `0` is left-absorbing. -/\n  lcm_zero_left : ∀ a, lcm 0 a = 0\n  /-- `0` is right-absorbing. -/\n  lcm_zero_right : ∀ a, lcm a 0 = 0\n\n"}
{"name":"GCDMonoid.lcm_zero_right","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_2\ninst✝ : CancelCommMonoidWithZero α\nself : GCDMonoid α\na : α\n⊢ Eq (GCDMonoid.lcm a 0) 0","decl":"/-- GCD monoid: a `CancelCommMonoidWithZero` with `gcd` (greatest common divisor) and\n`lcm` (least common multiple) operations, determined up to a unit. The type class focuses on `gcd`\nand we derive the corresponding `lcm` facts from `gcd`.\n-/\nclass GCDMonoid (α : Type*) [CancelCommMonoidWithZero α] where\n  /-- The greatest common divisor between two elements. -/\n  gcd : α → α → α\n  /-- The least common multiple between two elements. -/\n  lcm : α → α → α\n  /-- The GCD is a divisor of the first element. -/\n  gcd_dvd_left : ∀ a b, gcd a b ∣ a\n  /-- The GCD is a divisor of the second element. -/\n  gcd_dvd_right : ∀ a b, gcd a b ∣ b\n  /-- Any common divisor of both elements is a divisor of the GCD. -/\n  dvd_gcd : ∀ {a b c}, a ∣ c → a ∣ b → a ∣ gcd c b\n  /-- The product of two elements is `Associated` with the product of their GCD and LCM. -/\n  gcd_mul_lcm : ∀ a b, Associated (gcd a b * lcm a b) (a * b)\n  /-- `0` is left-absorbing. -/\n  lcm_zero_left : ∀ a, lcm 0 a = 0\n  /-- `0` is right-absorbing. -/\n  lcm_zero_right : ∀ a, lcm a 0 = 0\n\n"}
{"name":"NormalizedGCDMonoid.normalize_gcd","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_2\ninst✝ : CancelCommMonoidWithZero α\nself : NormalizedGCDMonoid α\na b : α\n⊢ Eq (normalize (GCDMonoid.gcd a b)) (GCDMonoid.gcd a b)","decl":"/-- Normalized GCD monoid: a `CancelCommMonoidWithZero` with normalization and `gcd`\n(greatest common divisor) and `lcm` (least common multiple) operations. In this setting `gcd` and\n`lcm` form a bounded lattice on the associated elements where `gcd` is the infimum, `lcm` is the\nsupremum, `1` is bottom, and `0` is top. The type class focuses on `gcd` and we derive the\ncorresponding `lcm` facts from `gcd`.\n-/\nclass NormalizedGCDMonoid (α : Type*) [CancelCommMonoidWithZero α] extends NormalizationMonoid α,\n  GCDMonoid α where\n  /-- The GCD is normalized to itself. -/\n  normalize_gcd : ∀ a b, normalize (gcd a b) = gcd a b\n  /-- The LCM is normalized to itself. -/\n  normalize_lcm : ∀ a b, normalize (lcm a b) = lcm a b\n\n"}
{"name":"NormalizedGCDMonoid.normalize_lcm","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_2\ninst✝ : CancelCommMonoidWithZero α\nself : NormalizedGCDMonoid α\na b : α\n⊢ Eq (normalize (GCDMonoid.lcm a b)) (GCDMonoid.lcm a b)","decl":"/-- Normalized GCD monoid: a `CancelCommMonoidWithZero` with normalization and `gcd`\n(greatest common divisor) and `lcm` (least common multiple) operations. In this setting `gcd` and\n`lcm` form a bounded lattice on the associated elements where `gcd` is the infimum, `lcm` is the\nsupremum, `1` is bottom, and `0` is top. The type class focuses on `gcd` and we derive the\ncorresponding `lcm` facts from `gcd`.\n-/\nclass NormalizedGCDMonoid (α : Type*) [CancelCommMonoidWithZero α] extends NormalizationMonoid α,\n  GCDMonoid α where\n  /-- The GCD is normalized to itself. -/\n  normalize_gcd : ∀ a b, normalize (gcd a b) = gcd a b\n  /-- The LCM is normalized to itself. -/\n  normalize_lcm : ∀ a b, normalize (lcm a b) = lcm a b\n\n"}
{"name":"instNonemptyNormalizationMonoid","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizationMonoid α\n⊢ Nonempty (NormalizationMonoid α)","decl":"instance [NormalizationMonoid α] : Nonempty (NormalizationMonoid α) := ⟨‹_›⟩\n"}
{"name":"instNonemptyGCDMonoid","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\n⊢ Nonempty (GCDMonoid α)","decl":"instance [GCDMonoid α] : Nonempty (GCDMonoid α) := ⟨‹_›⟩\n"}
{"name":"instNonemptyNormalizedGCDMonoid","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\n⊢ Nonempty (NormalizedGCDMonoid α)","decl":"instance [NormalizedGCDMonoid α] : Nonempty (NormalizedGCDMonoid α) := ⟨‹_›⟩\n"}
{"name":"instNonemptyNormalizationMonoidOfNormalizedGCDMonoid","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\nh : Nonempty (NormalizedGCDMonoid α)\n⊢ Nonempty (NormalizationMonoid α)","decl":"instance [h : Nonempty (NormalizedGCDMonoid α)] : Nonempty (NormalizationMonoid α) :=\n  h.elim fun _ ↦ inferInstance\n"}
{"name":"instNonemptyGCDMonoidOfNormalizedGCDMonoid","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\nh : Nonempty (NormalizedGCDMonoid α)\n⊢ Nonempty (GCDMonoid α)","decl":"instance [h : Nonempty (NormalizedGCDMonoid α)] : Nonempty (GCDMonoid α) :=\n  h.elim fun _ ↦ inferInstance\n\n"}
{"name":"gcd_isUnit_iff_isRelPrime","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b : α\n⊢ Iff (IsUnit (GCDMonoid.gcd a b)) (IsRelPrime a b)","decl":"theorem gcd_isUnit_iff_isRelPrime [GCDMonoid α] {a b : α} :\n    IsUnit (gcd a b) ↔ IsRelPrime a b :=\n  ⟨fun h _ ha hb ↦ isUnit_of_dvd_unit (dvd_gcd ha hb) h, (· (gcd_dvd_left a b) (gcd_dvd_right a b))⟩\n\n"}
{"name":"normalize_gcd","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na b : α\n⊢ Eq (normalize (GCDMonoid.gcd a b)) (GCDMonoid.gcd a b)","decl":"@[simp]\ntheorem normalize_gcd [NormalizedGCDMonoid α] : ∀ a b : α, normalize (gcd a b) = gcd a b :=\n  NormalizedGCDMonoid.normalize_gcd\n\n"}
{"name":"gcd_mul_lcm","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b : α\n⊢ Associated (HMul.hMul (GCDMonoid.gcd a b) (GCDMonoid.lcm a b)) (HMul.hMul a b)","decl":"theorem gcd_mul_lcm [GCDMonoid α] : ∀ a b : α, Associated (gcd a b * lcm a b) (a * b) :=\n  GCDMonoid.gcd_mul_lcm\n\n"}
{"name":"dvd_gcd_iff","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b c : α\n⊢ Iff (Dvd.dvd a (GCDMonoid.gcd b c)) (And (Dvd.dvd a b) (Dvd.dvd a c))","decl":"theorem dvd_gcd_iff [GCDMonoid α] (a b c : α) : a ∣ gcd b c ↔ a ∣ b ∧ a ∣ c :=\n  Iff.intro (fun h => ⟨h.trans (gcd_dvd_left _ _), h.trans (gcd_dvd_right _ _)⟩) fun ⟨hab, hac⟩ =>\n    dvd_gcd hab hac\n\n"}
{"name":"gcd_comm","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na b : α\n⊢ Eq (GCDMonoid.gcd a b) (GCDMonoid.gcd b a)","decl":"theorem gcd_comm [NormalizedGCDMonoid α] (a b : α) : gcd a b = gcd b a :=\n  dvd_antisymm_of_normalize_eq (normalize_gcd _ _) (normalize_gcd _ _)\n    (dvd_gcd (gcd_dvd_right _ _) (gcd_dvd_left _ _))\n    (dvd_gcd (gcd_dvd_right _ _) (gcd_dvd_left _ _))\n\n"}
{"name":"gcd_comm'","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b : α\n⊢ Associated (GCDMonoid.gcd a b) (GCDMonoid.gcd b a)","decl":"theorem gcd_comm' [GCDMonoid α] (a b : α) : Associated (gcd a b) (gcd b a) :=\n  associated_of_dvd_dvd (dvd_gcd (gcd_dvd_right _ _) (gcd_dvd_left _ _))\n    (dvd_gcd (gcd_dvd_right _ _) (gcd_dvd_left _ _))\n\n"}
{"name":"gcd_assoc","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\nm n k : α\n⊢ Eq (GCDMonoid.gcd (GCDMonoid.gcd m n) k) (GCDMonoid.gcd m (GCDMonoid.gcd n k))","decl":"theorem gcd_assoc [NormalizedGCDMonoid α] (m n k : α) : gcd (gcd m n) k = gcd m (gcd n k) :=\n  dvd_antisymm_of_normalize_eq (normalize_gcd _ _) (normalize_gcd _ _)\n    (dvd_gcd ((gcd_dvd_left (gcd m n) k).trans (gcd_dvd_left m n))\n      (dvd_gcd ((gcd_dvd_left (gcd m n) k).trans (gcd_dvd_right m n)) (gcd_dvd_right (gcd m n) k)))\n    (dvd_gcd\n      (dvd_gcd (gcd_dvd_left m (gcd n k)) ((gcd_dvd_right m (gcd n k)).trans (gcd_dvd_left n k)))\n      ((gcd_dvd_right m (gcd n k)).trans (gcd_dvd_right n k)))\n\n"}
{"name":"gcd_assoc'","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\nm n k : α\n⊢ Associated (GCDMonoid.gcd (GCDMonoid.gcd m n) k) (GCDMonoid.gcd m (GCDMonoid.gcd n k))","decl":"theorem gcd_assoc' [GCDMonoid α] (m n k : α) : Associated (gcd (gcd m n) k) (gcd m (gcd n k)) :=\n  associated_of_dvd_dvd\n    (dvd_gcd ((gcd_dvd_left (gcd m n) k).trans (gcd_dvd_left m n))\n      (dvd_gcd ((gcd_dvd_left (gcd m n) k).trans (gcd_dvd_right m n)) (gcd_dvd_right (gcd m n) k)))\n    (dvd_gcd\n      (dvd_gcd (gcd_dvd_left m (gcd n k)) ((gcd_dvd_right m (gcd n k)).trans (gcd_dvd_left n k)))\n      ((gcd_dvd_right m (gcd n k)).trans (gcd_dvd_right n k)))\n\n"}
{"name":"instCommutativeGcd","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\n⊢ Std.Commutative GCDMonoid.gcd","decl":"instance [NormalizedGCDMonoid α] : Std.Commutative (α := α) gcd where\n  comm := gcd_comm\n\n"}
{"name":"instAssociativeGcd","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\n⊢ Std.Associative GCDMonoid.gcd","decl":"instance [NormalizedGCDMonoid α] : Std.Associative (α := α) gcd where\n  assoc := gcd_assoc\n\n"}
{"name":"gcd_eq_normalize","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na b c : α\nhabc : Dvd.dvd (GCDMonoid.gcd a b) c\nhcab : Dvd.dvd c (GCDMonoid.gcd a b)\n⊢ Eq (GCDMonoid.gcd a b) (normalize c)","decl":"theorem gcd_eq_normalize [NormalizedGCDMonoid α] {a b c : α} (habc : gcd a b ∣ c)\n    (hcab : c ∣ gcd a b) : gcd a b = normalize c :=\n  normalize_gcd a b ▸ normalize_eq_normalize habc hcab\n\n"}
{"name":"gcd_zero_left","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na : α\n⊢ Eq (GCDMonoid.gcd 0 a) (normalize a)","decl":"@[simp]\ntheorem gcd_zero_left [NormalizedGCDMonoid α] (a : α) : gcd 0 a = normalize a :=\n  gcd_eq_normalize (gcd_dvd_right 0 a) (dvd_gcd (dvd_zero _) (dvd_refl a))\n\n"}
{"name":"gcd_zero_left'","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na : α\n⊢ Associated (GCDMonoid.gcd 0 a) a","decl":"theorem gcd_zero_left' [GCDMonoid α] (a : α) : Associated (gcd 0 a) a :=\n  associated_of_dvd_dvd (gcd_dvd_right 0 a) (dvd_gcd (dvd_zero _) (dvd_refl a))\n\n"}
{"name":"gcd_zero_right","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na : α\n⊢ Eq (GCDMonoid.gcd a 0) (normalize a)","decl":"@[simp]\ntheorem gcd_zero_right [NormalizedGCDMonoid α] (a : α) : gcd a 0 = normalize a :=\n  gcd_eq_normalize (gcd_dvd_left a 0) (dvd_gcd (dvd_refl a) (dvd_zero _))\n\n"}
{"name":"gcd_zero_right'","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na : α\n⊢ Associated (GCDMonoid.gcd a 0) a","decl":"theorem gcd_zero_right' [GCDMonoid α] (a : α) : Associated (gcd a 0) a :=\n  associated_of_dvd_dvd (gcd_dvd_left a 0) (dvd_gcd (dvd_refl a) (dvd_zero _))\n\n"}
{"name":"gcd_eq_zero_iff","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b : α\n⊢ Iff (Eq (GCDMonoid.gcd a b) 0) (And (Eq a 0) (Eq b 0))","decl":"@[simp]\ntheorem gcd_eq_zero_iff [GCDMonoid α] (a b : α) : gcd a b = 0 ↔ a = 0 ∧ b = 0 :=\n  Iff.intro\n    (fun h => by\n      let ⟨ca, ha⟩ := gcd_dvd_left a b\n      let ⟨cb, hb⟩ := gcd_dvd_right a b\n      rw [h, zero_mul] at ha hb\n      exact ⟨ha, hb⟩)\n    fun ⟨ha, hb⟩ => by\n    rw [ha, hb, ← zero_dvd_iff]\n    apply dvd_gcd <;> rfl\n\n"}
{"name":"gcd_one_left","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na : α\n⊢ Eq (GCDMonoid.gcd 1 a) 1","decl":"@[simp]\ntheorem gcd_one_left [NormalizedGCDMonoid α] (a : α) : gcd 1 a = 1 :=\n  dvd_antisymm_of_normalize_eq (normalize_gcd _ _) normalize_one (gcd_dvd_left _ _) (one_dvd _)\n\n"}
{"name":"isUnit_gcd_one_left","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na : α\n⊢ IsUnit (GCDMonoid.gcd 1 a)","decl":"@[simp]\ntheorem isUnit_gcd_one_left [GCDMonoid α] (a : α) : IsUnit (gcd 1 a) :=\n  isUnit_of_dvd_one (gcd_dvd_left _ _)\n\n"}
{"name":"gcd_one_left'","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na : α\n⊢ Associated (GCDMonoid.gcd 1 a) 1","decl":"theorem gcd_one_left' [GCDMonoid α] (a : α) : Associated (gcd 1 a) 1 := by simp\n\n"}
{"name":"gcd_one_right","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na : α\n⊢ Eq (GCDMonoid.gcd a 1) 1","decl":"@[simp]\ntheorem gcd_one_right [NormalizedGCDMonoid α] (a : α) : gcd a 1 = 1 :=\n  dvd_antisymm_of_normalize_eq (normalize_gcd _ _) normalize_one (gcd_dvd_right _ _) (one_dvd _)\n\n"}
{"name":"isUnit_gcd_one_right","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na : α\n⊢ IsUnit (GCDMonoid.gcd a 1)","decl":"@[simp]\ntheorem isUnit_gcd_one_right [GCDMonoid α] (a : α) : IsUnit (gcd a 1) :=\n  isUnit_of_dvd_one (gcd_dvd_right _ _)\n\n"}
{"name":"gcd_one_right'","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na : α\n⊢ Associated (GCDMonoid.gcd a 1) 1","decl":"theorem gcd_one_right' [GCDMonoid α] (a : α) : Associated (gcd a 1) 1 := by simp\n\n"}
{"name":"gcd_dvd_gcd","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b c d : α\nhab : Dvd.dvd a b\nhcd : Dvd.dvd c d\n⊢ Dvd.dvd (GCDMonoid.gcd a c) (GCDMonoid.gcd b d)","decl":"theorem gcd_dvd_gcd [GCDMonoid α] {a b c d : α} (hab : a ∣ b) (hcd : c ∣ d) : gcd a c ∣ gcd b d :=\n  dvd_gcd ((gcd_dvd_left _ _).trans hab) ((gcd_dvd_right _ _).trans hcd)\n\n"}
{"name":"Associated.gcd","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na₁ a₂ b₁ b₂ : α\nha : Associated a₁ a₂\nhb : Associated b₁ b₂\n⊢ Associated (GCDMonoid.gcd a₁ b₁) (GCDMonoid.gcd a₂ b₂)","decl":"protected theorem Associated.gcd [GCDMonoid α]\n    {a₁ a₂ b₁ b₂ : α} (ha : Associated a₁ a₂) (hb : Associated b₁ b₂) :\n    Associated (gcd a₁ b₁) (gcd a₂ b₂) :=\n  associated_of_dvd_dvd (gcd_dvd_gcd ha.dvd hb.dvd) (gcd_dvd_gcd ha.dvd' hb.dvd')\n\n"}
{"name":"gcd_same","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na : α\n⊢ Eq (GCDMonoid.gcd a a) (normalize a)","decl":"@[simp]\ntheorem gcd_same [NormalizedGCDMonoid α] (a : α) : gcd a a = normalize a :=\n  gcd_eq_normalize (gcd_dvd_left _ _) (dvd_gcd (dvd_refl a) (dvd_refl a))\n\n"}
{"name":"gcd_mul_left","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na b c : α\n⊢ Eq (GCDMonoid.gcd (HMul.hMul a b) (HMul.hMul a c)) (HMul.hMul (normalize a) (GCDMonoid.gcd b c))","decl":"@[simp]\ntheorem gcd_mul_left [NormalizedGCDMonoid α] (a b c : α) :\n    gcd (a * b) (a * c) = normalize a * gcd b c :=\n  (by_cases (by rintro rfl; simp only [zero_mul, gcd_zero_left, normalize_zero]))\n    fun ha : a ≠ 0 =>\n    suffices gcd (a * b) (a * c) = normalize (a * gcd b c) by simpa\n    let ⟨d, eq⟩ := dvd_gcd (dvd_mul_right a b) (dvd_mul_right a c)\n    gcd_eq_normalize\n      (eq.symm ▸ mul_dvd_mul_left a\n        (show d ∣ gcd b c from\n          dvd_gcd ((mul_dvd_mul_iff_left ha).1 <| eq ▸ gcd_dvd_left _ _)\n            ((mul_dvd_mul_iff_left ha).1 <| eq ▸ gcd_dvd_right _ _)))\n      (dvd_gcd (mul_dvd_mul_left a <| gcd_dvd_left _ _) (mul_dvd_mul_left a <| gcd_dvd_right _ _))\n\n"}
{"name":"gcd_mul_left'","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b c : α\n⊢ Associated (GCDMonoid.gcd (HMul.hMul a b) (HMul.hMul a c)) (HMul.hMul a (GCDMonoid.gcd b c))","decl":"theorem gcd_mul_left' [GCDMonoid α] (a b c : α) :\n    Associated (gcd (a * b) (a * c)) (a * gcd b c) := by\n  obtain rfl | ha := eq_or_ne a 0\n  · simp only [zero_mul, gcd_zero_left']\n  obtain ⟨d, eq⟩ := dvd_gcd (dvd_mul_right a b) (dvd_mul_right a c)\n  apply associated_of_dvd_dvd\n  · rw [eq]\n    apply mul_dvd_mul_left\n    exact\n      dvd_gcd ((mul_dvd_mul_iff_left ha).1 <| eq ▸ gcd_dvd_left _ _)\n        ((mul_dvd_mul_iff_left ha).1 <| eq ▸ gcd_dvd_right _ _)\n  · exact dvd_gcd (mul_dvd_mul_left a <| gcd_dvd_left _ _) (mul_dvd_mul_left a <| gcd_dvd_right _ _)\n\n"}
{"name":"gcd_mul_right","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na b c : α\n⊢ Eq (GCDMonoid.gcd (HMul.hMul b a) (HMul.hMul c a)) (HMul.hMul (GCDMonoid.gcd b c) (normalize a))","decl":"@[simp]\ntheorem gcd_mul_right [NormalizedGCDMonoid α] (a b c : α) :\n    gcd (b * a) (c * a) = gcd b c * normalize a := by simp only [mul_comm, gcd_mul_left]\n\n"}
{"name":"gcd_mul_right'","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b c : α\n⊢ Associated (GCDMonoid.gcd (HMul.hMul b a) (HMul.hMul c a)) (HMul.hMul (GCDMonoid.gcd b c) a)","decl":"@[simp]\ntheorem gcd_mul_right' [GCDMonoid α] (a b c : α) :\n    Associated (gcd (b * a) (c * a)) (gcd b c * a) := by\n  simp only [mul_comm, gcd_mul_left']\n\n"}
{"name":"gcd_eq_left_iff","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na b : α\nh : Eq (normalize a) a\n⊢ Iff (Eq (GCDMonoid.gcd a b) a) (Dvd.dvd a b)","decl":"theorem gcd_eq_left_iff [NormalizedGCDMonoid α] (a b : α) (h : normalize a = a) :\n    gcd a b = a ↔ a ∣ b :=\n  (Iff.intro fun eq => eq ▸ gcd_dvd_right _ _) fun hab =>\n    dvd_antisymm_of_normalize_eq (normalize_gcd _ _) h (gcd_dvd_left _ _) (dvd_gcd (dvd_refl a) hab)\n\n"}
{"name":"gcd_eq_right_iff","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na b : α\nh : Eq (normalize b) b\n⊢ Iff (Eq (GCDMonoid.gcd a b) b) (Dvd.dvd b a)","decl":"theorem gcd_eq_right_iff [NormalizedGCDMonoid α] (a b : α) (h : normalize b = b) :\n    gcd a b = b ↔ b ∣ a := by simpa only [gcd_comm a b] using gcd_eq_left_iff b a h\n\n"}
{"name":"gcd_dvd_gcd_mul_left","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\nm n k : α\n⊢ Dvd.dvd (GCDMonoid.gcd m n) (GCDMonoid.gcd (HMul.hMul k m) n)","decl":"theorem gcd_dvd_gcd_mul_left [GCDMonoid α] (m n k : α) : gcd m n ∣ gcd (k * m) n :=\n  gcd_dvd_gcd (dvd_mul_left _ _) dvd_rfl\n\n"}
{"name":"gcd_dvd_gcd_mul_right","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\nm n k : α\n⊢ Dvd.dvd (GCDMonoid.gcd m n) (GCDMonoid.gcd (HMul.hMul m k) n)","decl":"theorem gcd_dvd_gcd_mul_right [GCDMonoid α] (m n k : α) : gcd m n ∣ gcd (m * k) n :=\n  gcd_dvd_gcd (dvd_mul_right _ _) dvd_rfl\n\n"}
{"name":"gcd_dvd_gcd_mul_left_right","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\nm n k : α\n⊢ Dvd.dvd (GCDMonoid.gcd m n) (GCDMonoid.gcd m (HMul.hMul k n))","decl":"theorem gcd_dvd_gcd_mul_left_right [GCDMonoid α] (m n k : α) : gcd m n ∣ gcd m (k * n) :=\n  gcd_dvd_gcd dvd_rfl (dvd_mul_left _ _)\n\n"}
{"name":"gcd_dvd_gcd_mul_right_right","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\nm n k : α\n⊢ Dvd.dvd (GCDMonoid.gcd m n) (GCDMonoid.gcd m (HMul.hMul n k))","decl":"theorem gcd_dvd_gcd_mul_right_right [GCDMonoid α] (m n k : α) : gcd m n ∣ gcd m (n * k) :=\n  gcd_dvd_gcd dvd_rfl (dvd_mul_right _ _)\n\n"}
{"name":"Associated.gcd_eq_left","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\nm n : α\nh : Associated m n\nk : α\n⊢ Eq (GCDMonoid.gcd m k) (GCDMonoid.gcd n k)","decl":"theorem Associated.gcd_eq_left [NormalizedGCDMonoid α] {m n : α} (h : Associated m n) (k : α) :\n    gcd m k = gcd n k :=\n  dvd_antisymm_of_normalize_eq (normalize_gcd _ _) (normalize_gcd _ _) (gcd_dvd_gcd h.dvd dvd_rfl)\n    (gcd_dvd_gcd h.symm.dvd dvd_rfl)\n\n"}
{"name":"Associated.gcd_eq_right","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\nm n : α\nh : Associated m n\nk : α\n⊢ Eq (GCDMonoid.gcd k m) (GCDMonoid.gcd k n)","decl":"theorem Associated.gcd_eq_right [NormalizedGCDMonoid α] {m n : α} (h : Associated m n) (k : α) :\n    gcd k m = gcd k n :=\n  dvd_antisymm_of_normalize_eq (normalize_gcd _ _) (normalize_gcd _ _) (gcd_dvd_gcd dvd_rfl h.dvd)\n    (gcd_dvd_gcd dvd_rfl h.symm.dvd)\n\n"}
{"name":"dvd_gcd_mul_of_dvd_mul","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\nm n k : α\nH : Dvd.dvd k (HMul.hMul m n)\n⊢ Dvd.dvd k (HMul.hMul (GCDMonoid.gcd k m) n)","decl":"theorem dvd_gcd_mul_of_dvd_mul [GCDMonoid α] {m n k : α} (H : k ∣ m * n) : k ∣ gcd k m * n :=\n  (dvd_gcd (dvd_mul_right _ n) H).trans (gcd_mul_right' n k m).dvd\n\n"}
{"name":"dvd_gcd_mul_iff_dvd_mul","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\nm n k : α\n⊢ Iff (Dvd.dvd k (HMul.hMul (GCDMonoid.gcd k m) n)) (Dvd.dvd k (HMul.hMul m n))","decl":"theorem dvd_gcd_mul_iff_dvd_mul [GCDMonoid α] {m n k : α} : k ∣ gcd k m * n ↔ k ∣ m * n :=\n  ⟨fun h => h.trans (mul_dvd_mul (gcd_dvd_right k m) dvd_rfl), dvd_gcd_mul_of_dvd_mul⟩\n\n"}
{"name":"dvd_mul_gcd_of_dvd_mul","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\nm n k : α\nH : Dvd.dvd k (HMul.hMul m n)\n⊢ Dvd.dvd k (HMul.hMul m (GCDMonoid.gcd k n))","decl":"theorem dvd_mul_gcd_of_dvd_mul [GCDMonoid α] {m n k : α} (H : k ∣ m * n) : k ∣ m * gcd k n := by\n  rw [mul_comm] at H ⊢\n  exact dvd_gcd_mul_of_dvd_mul H\n\n"}
{"name":"dvd_mul_gcd_iff_dvd_mul","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\nm n k : α\n⊢ Iff (Dvd.dvd k (HMul.hMul m (GCDMonoid.gcd k n))) (Dvd.dvd k (HMul.hMul m n))","decl":"theorem dvd_mul_gcd_iff_dvd_mul [GCDMonoid α] {m n k : α} : k ∣ m * gcd k n ↔ k ∣ m * n :=\n  ⟨fun h => h.trans (mul_dvd_mul dvd_rfl (gcd_dvd_right k n)), dvd_mul_gcd_of_dvd_mul⟩\n\n"}
{"name":"instDecompositionMonoidOfNonemptyGCDMonoid","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\nh : Nonempty (GCDMonoid α)\n⊢ DecompositionMonoid α","decl":"/-- Represent a divisor of `m * n` as a product of a divisor of `m` and a divisor of `n`.\n\nNote: In general, this representation is highly non-unique.\n\nSee `Nat.prodDvdAndDvdOfDvdProd` for a constructive version on `ℕ`. -/\ninstance [h : Nonempty (GCDMonoid α)] : DecompositionMonoid α where\n  primal k m n H := by\n    cases h\n    by_cases h0 : gcd k m = 0\n    · rw [gcd_eq_zero_iff] at h0\n      rcases h0 with ⟨rfl, rfl⟩\n      exact ⟨0, n, dvd_refl 0, dvd_refl n, by simp⟩\n    · obtain ⟨a, ha⟩ := gcd_dvd_left k m\n      refine ⟨gcd k m, a, gcd_dvd_right _ _, ?_, ha⟩\n      rw [← mul_dvd_mul_iff_left h0, ← ha]\n      exact dvd_gcd_mul_of_dvd_mul H\n\n"}
{"name":"gcd_mul_dvd_mul_gcd","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\nk m n : α\n⊢ Dvd.dvd (GCDMonoid.gcd k (HMul.hMul m n)) (HMul.hMul (GCDMonoid.gcd k m) (GCDMonoid.gcd k n))","decl":"theorem gcd_mul_dvd_mul_gcd [GCDMonoid α] (k m n : α) : gcd k (m * n) ∣ gcd k m * gcd k n := by\n  obtain ⟨m', n', hm', hn', h⟩ := exists_dvd_and_dvd_of_dvd_mul (gcd_dvd_right k (m * n))\n  replace h : gcd k (m * n) = m' * n' := h\n  rw [h]\n  have hm'n' : m' * n' ∣ k := h ▸ gcd_dvd_left _ _\n  apply mul_dvd_mul\n  · have hm'k : m' ∣ k := (dvd_mul_right m' n').trans hm'n'\n    exact dvd_gcd hm'k hm'\n  · have hn'k : n' ∣ k := (dvd_mul_left n' m').trans hm'n'\n    exact dvd_gcd hn'k hn'\n\n"}
{"name":"gcd_pow_right_dvd_pow_gcd","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b : α\nk : Nat\n⊢ Dvd.dvd (GCDMonoid.gcd a (HPow.hPow b k)) (HPow.hPow (GCDMonoid.gcd a b) k)","decl":"theorem gcd_pow_right_dvd_pow_gcd [GCDMonoid α] {a b : α} {k : ℕ} :\n    gcd a (b ^ k) ∣ gcd a b ^ k := by\n  by_cases hg : gcd a b = 0\n  · rw [gcd_eq_zero_iff] at hg\n    rcases hg with ⟨rfl, rfl⟩\n    exact\n      (gcd_zero_left' (0 ^ k : α)).dvd.trans\n        (pow_dvd_pow_of_dvd (gcd_zero_left' (0 : α)).symm.dvd _)\n  · induction k with\n    | zero => rw [pow_zero, pow_zero]; exact (gcd_one_right' a).dvd\n    | succ k hk =>\n      rw [pow_succ', pow_succ']\n      trans gcd a b * gcd a (b ^ k)\n      · exact gcd_mul_dvd_mul_gcd a b (b ^ k)\n      · exact (mul_dvd_mul_iff_left hg).mpr hk\n\n"}
{"name":"gcd_pow_left_dvd_pow_gcd","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b : α\nk : Nat\n⊢ Dvd.dvd (GCDMonoid.gcd (HPow.hPow a k) b) (HPow.hPow (GCDMonoid.gcd a b) k)","decl":"theorem gcd_pow_left_dvd_pow_gcd [GCDMonoid α] {a b : α} {k : ℕ} : gcd (a ^ k) b ∣ gcd a b ^ k :=\n  calc\n    gcd (a ^ k) b ∣ gcd b (a ^ k) := (gcd_comm' _ _).dvd\n    _ ∣ gcd b a ^ k := gcd_pow_right_dvd_pow_gcd\n    _ ∣ gcd a b ^ k := pow_dvd_pow_of_dvd (gcd_comm' _ _).dvd _\n\n"}
{"name":"pow_dvd_of_mul_eq_pow","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b c d₁ d₂ : α\nha : Ne a 0\nhab : IsUnit (GCDMonoid.gcd a b)\nk : Nat\nh : Eq (HMul.hMul a b) (HPow.hPow c k)\nhc : Eq c (HMul.hMul d₁ d₂)\nhd₁ : Dvd.dvd d₁ a\n⊢ And (Ne (HPow.hPow d₁ k) 0) (Dvd.dvd (HPow.hPow d₁ k) a)","decl":"theorem pow_dvd_of_mul_eq_pow [GCDMonoid α] {a b c d₁ d₂ : α} (ha : a ≠ 0) (hab : IsUnit (gcd a b))\n    {k : ℕ} (h : a * b = c ^ k) (hc : c = d₁ * d₂) (hd₁ : d₁ ∣ a) : d₁ ^ k ≠ 0 ∧ d₁ ^ k ∣ a := by\n  have h1 : IsUnit (gcd (d₁ ^ k) b) := by\n    apply isUnit_of_dvd_one\n    trans gcd d₁ b ^ k\n    · exact gcd_pow_left_dvd_pow_gcd\n    · apply IsUnit.dvd\n      apply IsUnit.pow\n      apply isUnit_of_dvd_one\n      apply dvd_trans _ hab.dvd\n      apply gcd_dvd_gcd hd₁ (dvd_refl b)\n  have h2 : d₁ ^ k ∣ a * b := by\n    use d₂ ^ k\n    rw [h, hc]\n    exact mul_pow d₁ d₂ k\n  rw [mul_comm] at h2\n  have h3 : d₁ ^ k ∣ a := by\n    apply (dvd_gcd_mul_of_dvd_mul h2).trans\n    rw [h1.mul_left_dvd]\n  have h4 : d₁ ^ k ≠ 0 := by\n    intro hdk\n    rw [hdk] at h3\n    apply absurd (zero_dvd_iff.mp h3) ha\n  exact ⟨h4, h3⟩\n\n"}
{"name":"exists_associated_pow_of_mul_eq_pow","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b c : α\nhab : IsUnit (GCDMonoid.gcd a b)\nk : Nat\nh : Eq (HMul.hMul a b) (HPow.hPow c k)\n⊢ Exists fun d => Associated (HPow.hPow d k) a","decl":"theorem exists_associated_pow_of_mul_eq_pow [GCDMonoid α] {a b c : α} (hab : IsUnit (gcd a b))\n    {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, Associated (d ^ k) a := by\n  cases subsingleton_or_nontrivial α\n  · use 0\n    rw [Subsingleton.elim a (0 ^ k)]\n  by_cases ha : a = 0\n  · use 0\n    obtain rfl | hk := eq_or_ne k 0\n    · simp [ha] at h\n    · rw [ha, zero_pow hk]\n  by_cases hb : b = 0\n  · use 1\n    rw [one_pow]\n    apply (associated_one_iff_isUnit.mpr hab).symm.trans\n    rw [hb]\n    exact gcd_zero_right' a\n  obtain rfl | hk := k.eq_zero_or_pos\n  · use 1\n    rw [pow_zero] at h ⊢\n    use Units.mkOfMulEqOne _ _ h\n    rw [Units.val_mkOfMulEqOne, one_mul]\n  have hc : c ∣ a * b := by\n    rw [h]\n    exact dvd_pow_self _ hk.ne'\n  obtain ⟨d₁, d₂, hd₁, hd₂, hc⟩ := exists_dvd_and_dvd_of_dvd_mul hc\n  use d₁\n  obtain ⟨h0₁, ⟨a', ha'⟩⟩ := pow_dvd_of_mul_eq_pow ha hab h hc hd₁\n  rw [mul_comm] at h hc\n  rw [(gcd_comm' a b).isUnit_iff] at hab\n  obtain ⟨h0₂, ⟨b', hb'⟩⟩ := pow_dvd_of_mul_eq_pow hb hab h hc hd₂\n  rw [ha', hb', hc, mul_pow] at h\n  have h' : a' * b' = 1 := by\n    apply (mul_right_inj' h0₁).mp\n    rw [mul_one]\n    apply (mul_right_inj' h0₂).mp\n    rw [← h]\n    rw [mul_assoc, mul_comm a', ← mul_assoc _ b', ← mul_assoc b', mul_comm b']\n  use Units.mkOfMulEqOne _ _ h'\n  rw [Units.val_mkOfMulEqOne, ha']\n\n"}
{"name":"exists_eq_pow_of_mul_eq_pow","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : GCDMonoid α\ninst✝ : Subsingleton (Units α)\na b c : α\nhab : IsUnit (GCDMonoid.gcd a b)\nk : Nat\nh : Eq (HMul.hMul a b) (HPow.hPow c k)\n⊢ Exists fun d => Eq a (HPow.hPow d k)","decl":"theorem exists_eq_pow_of_mul_eq_pow [GCDMonoid α] [Subsingleton αˣ]\n    {a b c : α} (hab : IsUnit (gcd a b)) {k : ℕ} (h : a * b = c ^ k) : ∃ d : α, a = d ^ k :=\n  let ⟨d, hd⟩ := exists_associated_pow_of_mul_eq_pow hab h\n  ⟨d, (associated_iff_eq.mp hd).symm⟩\n\n"}
{"name":"gcd_greatest","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na b d : α\nhda : Dvd.dvd d a\nhdb : Dvd.dvd d b\nhd : ∀ (e : α), Dvd.dvd e a → Dvd.dvd e b → Dvd.dvd e d\n⊢ Eq (GCDMonoid.gcd a b) (normalize d)","decl":"theorem gcd_greatest {α : Type*} [CancelCommMonoidWithZero α] [NormalizedGCDMonoid α] {a b d : α}\n    (hda : d ∣ a) (hdb : d ∣ b) (hd : ∀ e : α, e ∣ a → e ∣ b → e ∣ d) :\n    GCDMonoid.gcd a b = normalize d :=\n  haveI h := hd _ (GCDMonoid.gcd_dvd_left a b) (GCDMonoid.gcd_dvd_right a b)\n  gcd_eq_normalize h (GCDMonoid.dvd_gcd hda hdb)\n\n"}
{"name":"gcd_greatest_associated","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b d : α\nhda : Dvd.dvd d a\nhdb : Dvd.dvd d b\nhd : ∀ (e : α), Dvd.dvd e a → Dvd.dvd e b → Dvd.dvd e d\n⊢ Associated d (GCDMonoid.gcd a b)","decl":"theorem gcd_greatest_associated {α : Type*} [CancelCommMonoidWithZero α] [GCDMonoid α] {a b d : α}\n    (hda : d ∣ a) (hdb : d ∣ b) (hd : ∀ e : α, e ∣ a → e ∣ b → e ∣ d) :\n    Associated d (GCDMonoid.gcd a b) :=\n  haveI h := hd _ (GCDMonoid.gcd_dvd_left a b) (GCDMonoid.gcd_dvd_right a b)\n  associated_of_dvd_dvd (GCDMonoid.dvd_gcd hda hdb) h\n\n"}
{"name":"isUnit_gcd_of_eq_mul_gcd","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\nx y x' y' : α\nex : Eq x (HMul.hMul (GCDMonoid.gcd x y) x')\ney : Eq y (HMul.hMul (GCDMonoid.gcd x y) y')\nh : Ne (GCDMonoid.gcd x y) 0\n⊢ IsUnit (GCDMonoid.gcd x' y')","decl":"theorem isUnit_gcd_of_eq_mul_gcd {α : Type*} [CancelCommMonoidWithZero α] [GCDMonoid α]\n    {x y x' y' : α} (ex : x = gcd x y * x') (ey : y = gcd x y * y') (h : gcd x y ≠ 0) :\n    IsUnit (gcd x' y') := by\n  rw [← associated_one_iff_isUnit]\n  refine Associated.of_mul_left ?_ (Associated.refl <| gcd x y) h\n  convert (gcd_mul_left' (gcd x y) x' y').symm using 1\n  rw [← ex, ← ey, mul_one]\n\n"}
{"name":"extract_gcd","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_2\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\nx y : α\n⊢ Exists fun x' => Exists fun y' => And (Eq x (HMul.hMul (GCDMonoid.gcd x y) x')) (And (Eq y (HMul.hMul (GCDMonoid.gcd x y) y')) (IsUnit (GCDMonoid.gcd x' y')))","decl":"theorem extract_gcd {α : Type*} [CancelCommMonoidWithZero α] [GCDMonoid α] (x y : α) :\n    ∃ x' y', x = gcd x y * x' ∧ y = gcd x y * y' ∧ IsUnit (gcd x' y') := by\n  by_cases h : gcd x y = 0\n  · obtain ⟨rfl, rfl⟩ := (gcd_eq_zero_iff x y).1 h\n    simp_rw [← associated_one_iff_isUnit]\n    exact ⟨1, 1, by rw [h, zero_mul], by rw [h, zero_mul], gcd_one_left' 1⟩\n  obtain ⟨x', ex⟩ := gcd_dvd_left x y\n  obtain ⟨y', ey⟩ := gcd_dvd_right x y\n  exact ⟨x', y', ex, ey, isUnit_gcd_of_eq_mul_gcd ex ey h⟩\n\n"}
{"name":"associated_gcd_left_iff","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\nx y : α\n⊢ Iff (Associated x (GCDMonoid.gcd x y)) (Dvd.dvd x y)","decl":"theorem associated_gcd_left_iff [GCDMonoid α] {x y : α} : Associated x (gcd x y) ↔ x ∣ y :=\n  ⟨fun hx => hx.dvd.trans (gcd_dvd_right x y),\n    fun hxy => associated_of_dvd_dvd (dvd_gcd dvd_rfl hxy) (gcd_dvd_left x y)⟩\n\n"}
{"name":"associated_gcd_right_iff","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\nx y : α\n⊢ Iff (Associated y (GCDMonoid.gcd x y)) (Dvd.dvd y x)","decl":"theorem associated_gcd_right_iff [GCDMonoid α] {x y : α} : Associated y (gcd x y) ↔ y ∣ x :=\n  ⟨fun hx => hx.dvd.trans (gcd_dvd_left x y),\n    fun hxy => associated_of_dvd_dvd (dvd_gcd hxy dvd_rfl) (gcd_dvd_right x y)⟩\n\n"}
{"name":"Irreducible.isUnit_gcd_iff","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\nx y : α\nhx : Irreducible x\n⊢ Iff (IsUnit (GCDMonoid.gcd x y)) (Not (Dvd.dvd x y))","decl":"theorem Irreducible.isUnit_gcd_iff [GCDMonoid α] {x y : α} (hx : Irreducible x) :\n    IsUnit (gcd x y) ↔ ¬(x ∣ y) := by\n  rw [hx.isUnit_iff_not_associated_of_dvd (gcd_dvd_left x y), not_iff_not, associated_gcd_left_iff]\n\n"}
{"name":"Irreducible.gcd_eq_one_iff","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\nx y : α\nhx : Irreducible x\n⊢ Iff (Eq (GCDMonoid.gcd x y) 1) (Not (Dvd.dvd x y))","decl":"theorem Irreducible.gcd_eq_one_iff [NormalizedGCDMonoid α] {x y : α} (hx : Irreducible x) :\n    gcd x y = 1 ↔ ¬(x ∣ y) := by\n  rw [← hx.isUnit_gcd_iff, ← normalize_eq_one, NormalizedGCDMonoid.normalize_gcd]\n\n"}
{"name":"gcd_neg'","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : HasDistribNeg α\ninst✝ : GCDMonoid α\na b : α\n⊢ Associated (GCDMonoid.gcd a (Neg.neg b)) (GCDMonoid.gcd a b)","decl":"lemma gcd_neg' [GCDMonoid α] {a b : α} : Associated (gcd a (-b)) (gcd a b) :=\n  Associated.gcd .rfl (.neg_left .rfl)\n\n"}
{"name":"gcd_neg","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : HasDistribNeg α\ninst✝ : NormalizedGCDMonoid α\na b : α\n⊢ Eq (GCDMonoid.gcd a (Neg.neg b)) (GCDMonoid.gcd a b)","decl":"lemma gcd_neg [NormalizedGCDMonoid α] {a b : α} : gcd a (-b) = gcd a b :=\n  gcd_neg'.eq_of_normalized (normalize_gcd _ _) (normalize_gcd _ _)\n\n"}
{"name":"neg_gcd'","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : HasDistribNeg α\ninst✝ : GCDMonoid α\na b : α\n⊢ Associated (GCDMonoid.gcd (Neg.neg a) b) (GCDMonoid.gcd a b)","decl":"lemma neg_gcd' [GCDMonoid α] {a b : α} : Associated (gcd (-a) b) (gcd a b) :=\n  Associated.gcd (.neg_left .rfl) .rfl\n\n"}
{"name":"neg_gcd","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : HasDistribNeg α\ninst✝ : NormalizedGCDMonoid α\na b : α\n⊢ Eq (GCDMonoid.gcd (Neg.neg a) b) (GCDMonoid.gcd a b)","decl":"lemma neg_gcd [NormalizedGCDMonoid α] {a b : α} : gcd (-a) b = gcd a b :=\n  neg_gcd'.eq_of_normalized (normalize_gcd _ _) (normalize_gcd _ _)\n\n"}
{"name":"lcm_dvd_iff","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b c : α\n⊢ Iff (Dvd.dvd (GCDMonoid.lcm a b) c) (And (Dvd.dvd a c) (Dvd.dvd b c))","decl":"theorem lcm_dvd_iff [GCDMonoid α] {a b c : α} : lcm a b ∣ c ↔ a ∣ c ∧ b ∣ c := by\n  by_cases h : a = 0 ∨ b = 0\n  · rcases h with (rfl | rfl) <;>\n      simp +contextual only [iff_def, lcm_zero_left, lcm_zero_right,\n        zero_dvd_iff, dvd_zero, eq_self_iff_true, and_true, imp_true_iff]\n  · obtain ⟨h1, h2⟩ := not_or.1 h\n    have h : gcd a b ≠ 0 := fun H => h1 ((gcd_eq_zero_iff _ _).1 H).1\n    rw [← mul_dvd_mul_iff_left h, (gcd_mul_lcm a b).dvd_iff_dvd_left, ←\n      (gcd_mul_right' c a b).dvd_iff_dvd_right, dvd_gcd_iff, mul_comm b c, mul_dvd_mul_iff_left h1,\n      mul_dvd_mul_iff_right h2, and_comm]\n\n"}
{"name":"dvd_lcm_left","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b : α\n⊢ Dvd.dvd a (GCDMonoid.lcm a b)","decl":"theorem dvd_lcm_left [GCDMonoid α] (a b : α) : a ∣ lcm a b :=\n  (lcm_dvd_iff.1 (dvd_refl (lcm a b))).1\n\n"}
{"name":"dvd_lcm_right","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b : α\n⊢ Dvd.dvd b (GCDMonoid.lcm a b)","decl":"theorem dvd_lcm_right [GCDMonoid α] (a b : α) : b ∣ lcm a b :=\n  (lcm_dvd_iff.1 (dvd_refl (lcm a b))).2\n\n"}
{"name":"lcm_dvd","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b c : α\nhab : Dvd.dvd a b\nhcb : Dvd.dvd c b\n⊢ Dvd.dvd (GCDMonoid.lcm a c) b","decl":"theorem lcm_dvd [GCDMonoid α] {a b c : α} (hab : a ∣ b) (hcb : c ∣ b) : lcm a c ∣ b :=\n  lcm_dvd_iff.2 ⟨hab, hcb⟩\n\n"}
{"name":"lcm_eq_zero_iff","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b : α\n⊢ Iff (Eq (GCDMonoid.lcm a b) 0) (Or (Eq a 0) (Eq b 0))","decl":"@[simp]\ntheorem lcm_eq_zero_iff [GCDMonoid α] (a b : α) : lcm a b = 0 ↔ a = 0 ∨ b = 0 :=\n  Iff.intro\n    (fun h : lcm a b = 0 => by\n      have : Associated (a * b) 0 := (gcd_mul_lcm a b).symm.trans <| by rw [h, mul_zero]\n      rwa [← mul_eq_zero, ← associated_zero_iff_eq_zero])\n    (by rintro (rfl | rfl) <;> [apply lcm_zero_left; apply lcm_zero_right])\n\n"}
{"name":"normalize_lcm","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na b : α\n⊢ Eq (normalize (GCDMonoid.lcm a b)) (GCDMonoid.lcm a b)","decl":"@[simp]\ntheorem normalize_lcm [NormalizedGCDMonoid α] (a b : α) : normalize (lcm a b) = lcm a b :=\n  NormalizedGCDMonoid.normalize_lcm a b\n\n"}
{"name":"lcm_comm","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na b : α\n⊢ Eq (GCDMonoid.lcm a b) (GCDMonoid.lcm b a)","decl":"theorem lcm_comm [NormalizedGCDMonoid α] (a b : α) : lcm a b = lcm b a :=\n  dvd_antisymm_of_normalize_eq (normalize_lcm _ _) (normalize_lcm _ _)\n    (lcm_dvd (dvd_lcm_right _ _) (dvd_lcm_left _ _))\n    (lcm_dvd (dvd_lcm_right _ _) (dvd_lcm_left _ _))\n\n"}
{"name":"lcm_comm'","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b : α\n⊢ Associated (GCDMonoid.lcm a b) (GCDMonoid.lcm b a)","decl":"theorem lcm_comm' [GCDMonoid α] (a b : α) : Associated (lcm a b) (lcm b a) :=\n  associated_of_dvd_dvd (lcm_dvd (dvd_lcm_right _ _) (dvd_lcm_left _ _))\n    (lcm_dvd (dvd_lcm_right _ _) (dvd_lcm_left _ _))\n\n"}
{"name":"lcm_assoc","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\nm n k : α\n⊢ Eq (GCDMonoid.lcm (GCDMonoid.lcm m n) k) (GCDMonoid.lcm m (GCDMonoid.lcm n k))","decl":"theorem lcm_assoc [NormalizedGCDMonoid α] (m n k : α) : lcm (lcm m n) k = lcm m (lcm n k) :=\n  dvd_antisymm_of_normalize_eq (normalize_lcm _ _) (normalize_lcm _ _)\n    (lcm_dvd (lcm_dvd (dvd_lcm_left _ _) ((dvd_lcm_left _ _).trans (dvd_lcm_right _ _)))\n      ((dvd_lcm_right _ _).trans (dvd_lcm_right _ _)))\n    (lcm_dvd ((dvd_lcm_left _ _).trans (dvd_lcm_left _ _))\n      (lcm_dvd ((dvd_lcm_right _ _).trans (dvd_lcm_left _ _)) (dvd_lcm_right _ _)))\n\n"}
{"name":"lcm_assoc'","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\nm n k : α\n⊢ Associated (GCDMonoid.lcm (GCDMonoid.lcm m n) k) (GCDMonoid.lcm m (GCDMonoid.lcm n k))","decl":"theorem lcm_assoc' [GCDMonoid α] (m n k : α) : Associated (lcm (lcm m n) k) (lcm m (lcm n k)) :=\n  associated_of_dvd_dvd\n    (lcm_dvd (lcm_dvd (dvd_lcm_left _ _) ((dvd_lcm_left _ _).trans (dvd_lcm_right _ _)))\n      ((dvd_lcm_right _ _).trans (dvd_lcm_right _ _)))\n    (lcm_dvd ((dvd_lcm_left _ _).trans (dvd_lcm_left _ _))\n      (lcm_dvd ((dvd_lcm_right _ _).trans (dvd_lcm_left _ _)) (dvd_lcm_right _ _)))\n\n"}
{"name":"instCommutativeLcm","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\n⊢ Std.Commutative GCDMonoid.lcm","decl":"instance [NormalizedGCDMonoid α] : Std.Commutative (α := α) lcm where\n  comm := lcm_comm\n\n"}
{"name":"instAssociativeLcm","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\n⊢ Std.Associative GCDMonoid.lcm","decl":"instance [NormalizedGCDMonoid α] : Std.Associative (α := α) lcm where\n  assoc := lcm_assoc\n\n"}
{"name":"lcm_eq_normalize","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na b c : α\nhabc : Dvd.dvd (GCDMonoid.lcm a b) c\nhcab : Dvd.dvd c (GCDMonoid.lcm a b)\n⊢ Eq (GCDMonoid.lcm a b) (normalize c)","decl":"theorem lcm_eq_normalize [NormalizedGCDMonoid α] {a b c : α} (habc : lcm a b ∣ c)\n    (hcab : c ∣ lcm a b) : lcm a b = normalize c :=\n  normalize_lcm a b ▸ normalize_eq_normalize habc hcab\n\n"}
{"name":"lcm_dvd_lcm","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b c d : α\nhab : Dvd.dvd a b\nhcd : Dvd.dvd c d\n⊢ Dvd.dvd (GCDMonoid.lcm a c) (GCDMonoid.lcm b d)","decl":"theorem lcm_dvd_lcm [GCDMonoid α] {a b c d : α} (hab : a ∣ b) (hcd : c ∣ d) : lcm a c ∣ lcm b d :=\n  lcm_dvd (hab.trans (dvd_lcm_left _ _)) (hcd.trans (dvd_lcm_right _ _))\n\n"}
{"name":"Associated.lcm","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na₁ a₂ b₁ b₂ : α\nha : Associated a₁ a₂\nhb : Associated b₁ b₂\n⊢ Associated (GCDMonoid.lcm a₁ b₁) (GCDMonoid.lcm a₂ b₂)","decl":"protected theorem Associated.lcm [GCDMonoid α]\n    {a₁ a₂ b₁ b₂ : α} (ha : Associated a₁ a₂) (hb : Associated b₁ b₂) :\n    Associated (lcm a₁ b₁) (lcm a₂ b₂) :=\n  associated_of_dvd_dvd (lcm_dvd_lcm ha.dvd hb.dvd) (lcm_dvd_lcm ha.dvd' hb.dvd')\n\n"}
{"name":"lcm_units_coe_left","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\nu : Units α\na : α\n⊢ Eq (GCDMonoid.lcm (↑u) a) (normalize a)","decl":"@[simp]\ntheorem lcm_units_coe_left [NormalizedGCDMonoid α] (u : αˣ) (a : α) : lcm (↑u) a = normalize a :=\n  lcm_eq_normalize (lcm_dvd Units.coe_dvd dvd_rfl) (dvd_lcm_right _ _)\n\n"}
{"name":"lcm_units_coe_right","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na : α\nu : Units α\n⊢ Eq (GCDMonoid.lcm a ↑u) (normalize a)","decl":"@[simp]\ntheorem lcm_units_coe_right [NormalizedGCDMonoid α] (a : α) (u : αˣ) : lcm a ↑u = normalize a :=\n  (lcm_comm a u).trans <| lcm_units_coe_left _ _\n\n"}
{"name":"lcm_one_left","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na : α\n⊢ Eq (GCDMonoid.lcm 1 a) (normalize a)","decl":"@[simp]\ntheorem lcm_one_left [NormalizedGCDMonoid α] (a : α) : lcm 1 a = normalize a :=\n  lcm_units_coe_left 1 a\n\n"}
{"name":"lcm_one_right","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na : α\n⊢ Eq (GCDMonoid.lcm a 1) (normalize a)","decl":"@[simp]\ntheorem lcm_one_right [NormalizedGCDMonoid α] (a : α) : lcm a 1 = normalize a :=\n  lcm_units_coe_right a 1\n\n"}
{"name":"lcm_same","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na : α\n⊢ Eq (GCDMonoid.lcm a a) (normalize a)","decl":"@[simp]\ntheorem lcm_same [NormalizedGCDMonoid α] (a : α) : lcm a a = normalize a :=\n  lcm_eq_normalize (lcm_dvd dvd_rfl dvd_rfl) (dvd_lcm_left _ _)\n\n"}
{"name":"lcm_eq_one_iff","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na b : α\n⊢ Iff (Eq (GCDMonoid.lcm a b) 1) (And (Dvd.dvd a 1) (Dvd.dvd b 1))","decl":"@[simp]\ntheorem lcm_eq_one_iff [NormalizedGCDMonoid α] (a b : α) : lcm a b = 1 ↔ a ∣ 1 ∧ b ∣ 1 :=\n  Iff.intro (fun eq => eq ▸ ⟨dvd_lcm_left _ _, dvd_lcm_right _ _⟩) fun ⟨⟨c, hc⟩, ⟨d, hd⟩⟩ =>\n    show lcm (Units.mkOfMulEqOne a c hc.symm : α) (Units.mkOfMulEqOne b d hd.symm) = 1 by\n      rw [lcm_units_coe_left, normalize_coe_units]\n\n"}
{"name":"lcm_mul_left","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na b c : α\n⊢ Eq (GCDMonoid.lcm (HMul.hMul a b) (HMul.hMul a c)) (HMul.hMul (normalize a) (GCDMonoid.lcm b c))","decl":"@[simp]\ntheorem lcm_mul_left [NormalizedGCDMonoid α] (a b c : α) :\n    lcm (a * b) (a * c) = normalize a * lcm b c :=\n  (by_cases (by rintro rfl; simp only [zero_mul, lcm_zero_left, normalize_zero]))\n    fun ha : a ≠ 0 =>\n    suffices lcm (a * b) (a * c) = normalize (a * lcm b c) by simpa\n    have : a ∣ lcm (a * b) (a * c) := (dvd_mul_right _ _).trans (dvd_lcm_left _ _)\n    let ⟨_, eq⟩ := this\n    lcm_eq_normalize\n      (lcm_dvd (mul_dvd_mul_left a (dvd_lcm_left _ _)) (mul_dvd_mul_left a (dvd_lcm_right _ _)))\n      (eq.symm ▸\n        (mul_dvd_mul_left a <|\n          lcm_dvd ((mul_dvd_mul_iff_left ha).1 <| eq ▸ dvd_lcm_left _ _)\n            ((mul_dvd_mul_iff_left ha).1 <| eq ▸ dvd_lcm_right _ _)))\n\n"}
{"name":"lcm_mul_right","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na b c : α\n⊢ Eq (GCDMonoid.lcm (HMul.hMul b a) (HMul.hMul c a)) (HMul.hMul (GCDMonoid.lcm b c) (normalize a))","decl":"@[simp]\ntheorem lcm_mul_right [NormalizedGCDMonoid α] (a b c : α) :\n    lcm (b * a) (c * a) = lcm b c * normalize a := by simp only [mul_comm, lcm_mul_left]\n\n"}
{"name":"lcm_eq_left_iff","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na b : α\nh : Eq (normalize a) a\n⊢ Iff (Eq (GCDMonoid.lcm a b) a) (Dvd.dvd b a)","decl":"theorem lcm_eq_left_iff [NormalizedGCDMonoid α] (a b : α) (h : normalize a = a) :\n    lcm a b = a ↔ b ∣ a :=\n  (Iff.intro fun eq => eq ▸ dvd_lcm_right _ _) fun hab =>\n    dvd_antisymm_of_normalize_eq (normalize_lcm _ _) h (lcm_dvd (dvd_refl a) hab) (dvd_lcm_left _ _)\n\n"}
{"name":"lcm_eq_right_iff","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\na b : α\nh : Eq (normalize b) b\n⊢ Iff (Eq (GCDMonoid.lcm a b) b) (Dvd.dvd a b)","decl":"theorem lcm_eq_right_iff [NormalizedGCDMonoid α] (a b : α) (h : normalize b = b) :\n    lcm a b = b ↔ a ∣ b := by simpa only [lcm_comm b a] using lcm_eq_left_iff b a h\n\n"}
{"name":"lcm_dvd_lcm_mul_left","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\nm n k : α\n⊢ Dvd.dvd (GCDMonoid.lcm m n) (GCDMonoid.lcm (HMul.hMul k m) n)","decl":"theorem lcm_dvd_lcm_mul_left [GCDMonoid α] (m n k : α) : lcm m n ∣ lcm (k * m) n :=\n  lcm_dvd_lcm (dvd_mul_left _ _) dvd_rfl\n\n"}
{"name":"lcm_dvd_lcm_mul_right","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\nm n k : α\n⊢ Dvd.dvd (GCDMonoid.lcm m n) (GCDMonoid.lcm (HMul.hMul m k) n)","decl":"theorem lcm_dvd_lcm_mul_right [GCDMonoid α] (m n k : α) : lcm m n ∣ lcm (m * k) n :=\n  lcm_dvd_lcm (dvd_mul_right _ _) dvd_rfl\n\n"}
{"name":"lcm_dvd_lcm_mul_left_right","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\nm n k : α\n⊢ Dvd.dvd (GCDMonoid.lcm m n) (GCDMonoid.lcm m (HMul.hMul k n))","decl":"theorem lcm_dvd_lcm_mul_left_right [GCDMonoid α] (m n k : α) : lcm m n ∣ lcm m (k * n) :=\n  lcm_dvd_lcm dvd_rfl (dvd_mul_left _ _)\n\n"}
{"name":"lcm_dvd_lcm_mul_right_right","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\nm n k : α\n⊢ Dvd.dvd (GCDMonoid.lcm m n) (GCDMonoid.lcm m (HMul.hMul n k))","decl":"theorem lcm_dvd_lcm_mul_right_right [GCDMonoid α] (m n k : α) : lcm m n ∣ lcm m (n * k) :=\n  lcm_dvd_lcm dvd_rfl (dvd_mul_right _ _)\n\n"}
{"name":"lcm_eq_of_associated_left","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\nm n : α\nh : Associated m n\nk : α\n⊢ Eq (GCDMonoid.lcm m k) (GCDMonoid.lcm n k)","decl":"theorem lcm_eq_of_associated_left [NormalizedGCDMonoid α] {m n : α} (h : Associated m n) (k : α) :\n    lcm m k = lcm n k :=\n  dvd_antisymm_of_normalize_eq (normalize_lcm _ _) (normalize_lcm _ _) (lcm_dvd_lcm h.dvd dvd_rfl)\n    (lcm_dvd_lcm h.symm.dvd dvd_rfl)\n\n"}
{"name":"lcm_eq_of_associated_right","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NormalizedGCDMonoid α\nm n : α\nh : Associated m n\nk : α\n⊢ Eq (GCDMonoid.lcm k m) (GCDMonoid.lcm k n)","decl":"theorem lcm_eq_of_associated_right [NormalizedGCDMonoid α] {m n : α} (h : Associated m n) (k : α) :\n    lcm k m = lcm k n :=\n  dvd_antisymm_of_normalize_eq (normalize_lcm _ _) (normalize_lcm _ _) (lcm_dvd_lcm dvd_rfl h.dvd)\n    (lcm_dvd_lcm dvd_rfl h.symm.dvd)\n\n"}
{"name":"subsingleton_gcdMonoid_of_unique_units","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\n⊢ Subsingleton (GCDMonoid α)","decl":"instance subsingleton_gcdMonoid_of_unique_units : Subsingleton (GCDMonoid α) :=\n  ⟨fun g₁ g₂ => by\n    have hgcd : g₁.gcd = g₂.gcd := by\n      ext a b\n      refine associated_iff_eq.mp (associated_of_dvd_dvd ?_ ?_)\n      -- Porting note: Lean4 seems to need help specifying `g₁` and `g₂`\n      · exact dvd_gcd (@gcd_dvd_left _ _ g₁ _ _) (@gcd_dvd_right _ _ g₁ _ _)\n      · exact @dvd_gcd _ _ g₁ _ _ _ (@gcd_dvd_left _ _ g₂ _ _) (@gcd_dvd_right _ _ g₂ _ _)\n    have hlcm : g₁.lcm = g₂.lcm := by\n      ext a b\n      -- Porting note: Lean4 seems to need help specifying `g₁` and `g₂`\n      refine associated_iff_eq.mp (associated_of_dvd_dvd ?_ ?_)\n      · exact (@lcm_dvd_iff _ _ g₁ ..).mpr ⟨@dvd_lcm_left _ _ g₂ _ _, @dvd_lcm_right _ _ g₂ _ _⟩\n      · exact lcm_dvd_iff.mpr ⟨@dvd_lcm_left _ _ g₁ _ _, @dvd_lcm_right _ _ g₁ _ _⟩\n    cases g₁\n    cases g₂\n    dsimp only at hgcd hlcm\n    simp only [hgcd, hlcm]⟩\n\n"}
{"name":"subsingleton_normalizedGCDMonoid_of_unique_units","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝ : CancelCommMonoidWithZero α\n⊢ Subsingleton (NormalizedGCDMonoid α)","decl":"instance subsingleton_normalizedGCDMonoid_of_unique_units : Subsingleton (NormalizedGCDMonoid α) :=\n  ⟨by\n    intro a b\n    cases a; rename_i a_norm a_gcd _ _\n    cases b; rename_i b_norm b_gcd _ _\n    have := Subsingleton.elim a_gcd b_gcd\n    subst this\n    have := Subsingleton.elim a_norm b_norm\n    subst this\n    rfl⟩\n\n"}
{"name":"normUnit_eq_one","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : Subsingleton (Units α)\nx : α\n⊢ Eq (NormalizationMonoid.normUnit x) 1","decl":"@[simp]\ntheorem normUnit_eq_one (x : α) : normUnit x = 1 :=\n  rfl\n\n"}
{"name":"normalize_eq","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : Subsingleton (Units α)\nx : α\n⊢ Eq (normalize x) x","decl":"@[simp]\ntheorem normalize_eq (x : α) : normalize x = x :=\n  mul_one x\n\n"}
{"name":"associatesEquivOfUniqueUnits_apply","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : Subsingleton (Units α)\na✝ : Associates α\n⊢ Eq (associatesEquivOfUniqueUnits a✝) a✝.out","decl":"/-- If a monoid's only unit is `1`, then it is isomorphic to its associates. -/\n@[simps]\ndef associatesEquivOfUniqueUnits : Associates α ≃* α where\n  toFun := Associates.out\n  invFun := Associates.mk\n  left_inv := Associates.mk_out\n  right_inv _ := (Associates.out_mk _).trans <| normalize_eq _\n  map_mul' := Associates.out_mul\n\n"}
{"name":"associatesEquivOfUniqueUnits_symm_apply","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : Subsingleton (Units α)\na : α\n⊢ Eq (associatesEquivOfUniqueUnits.symm a) (Associates.mk a)","decl":"/-- If a monoid's only unit is `1`, then it is isomorphic to its associates. -/\n@[simps]\ndef associatesEquivOfUniqueUnits : Associates α ≃* α where\n  toFun := Associates.out\n  invFun := Associates.mk\n  left_inv := Associates.mk_out\n  right_inv _ := (Associates.out_mk _).trans <| normalize_eq _\n  map_mul' := Associates.out_mul\n\n"}
{"name":"gcd_eq_of_dvd_sub_right","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝² : CommRing α\ninst✝¹ : IsDomain α\ninst✝ : NormalizedGCDMonoid α\na b c : α\nh : Dvd.dvd a (HSub.hSub b c)\n⊢ Eq (GCDMonoid.gcd a b) (GCDMonoid.gcd a c)","decl":"theorem gcd_eq_of_dvd_sub_right {a b c : α} (h : a ∣ b - c) : gcd a b = gcd a c := by\n  apply dvd_antisymm_of_normalize_eq (normalize_gcd _ _) (normalize_gcd _ _) <;>\n    rw [dvd_gcd_iff] <;>\n    refine ⟨gcd_dvd_left _ _, ?_⟩\n  · rcases h with ⟨d, hd⟩\n    rcases gcd_dvd_right a b with ⟨e, he⟩\n    rcases gcd_dvd_left a b with ⟨f, hf⟩\n    use e - f * d\n    rw [mul_sub, ← he, ← mul_assoc, ← hf, ← hd, sub_sub_cancel]\n  · rcases h with ⟨d, hd⟩\n    rcases gcd_dvd_right a c with ⟨e, he⟩\n    rcases gcd_dvd_left a c with ⟨f, hf⟩\n    use e + f * d\n    rw [mul_add, ← he, ← mul_assoc, ← hf, ← hd, ← add_sub_assoc, add_comm c b, add_sub_cancel_right]\n\n"}
{"name":"gcd_eq_of_dvd_sub_left","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝² : CommRing α\ninst✝¹ : IsDomain α\ninst✝ : NormalizedGCDMonoid α\na b c : α\nh : Dvd.dvd a (HSub.hSub b c)\n⊢ Eq (GCDMonoid.gcd b a) (GCDMonoid.gcd c a)","decl":"theorem gcd_eq_of_dvd_sub_left {a b c : α} (h : a ∣ b - c) : gcd b a = gcd c a := by\n  rw [gcd_comm _ a, gcd_comm _ a, gcd_eq_of_dvd_sub_right h]\n\n"}
{"name":"CommGroupWithZero.coe_normUnit","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"G₀ : Type u_2\ninst✝¹ : CommGroupWithZero G₀\ninst✝ : DecidableEq G₀\na : G₀\nh0 : Ne a 0\n⊢ Eq (↑(NormalizationMonoid.normUnit a)) (Inv.inv a)","decl":"@[simp]\ntheorem coe_normUnit {a : G₀} (h0 : a ≠ 0) : (↑(normUnit a) : G₀) = a⁻¹ := by simp [normUnit, h0]\n\n"}
{"name":"CommGroupWithZero.normalize_eq_one","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"G₀ : Type u_2\ninst✝¹ : CommGroupWithZero G₀\ninst✝ : DecidableEq G₀\na : G₀\nh0 : Ne a 0\n⊢ Eq (normalize a) 1","decl":"theorem normalize_eq_one {a : G₀} (h0 : a ≠ 0) : normalize a = 1 := by simp [normalize_apply, h0]\n\n"}
{"name":"Associates.gcd_mk_mk","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b : α\n⊢ Eq (GCDMonoid.gcd (Associates.mk a) (Associates.mk b)) (Associates.mk (GCDMonoid.gcd a b))","decl":"theorem gcd_mk_mk {a b : α} : gcd (Associates.mk a) (Associates.mk b) = Associates.mk (gcd a b) :=\n  rfl\n"}
{"name":"Associates.lcm_mk_mk","module":"Mathlib.Algebra.GCDMonoid.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : GCDMonoid α\na b : α\n⊢ Eq (GCDMonoid.lcm (Associates.mk a) (Associates.mk b)) (Associates.mk (GCDMonoid.lcm a b))","decl":"theorem lcm_mk_mk {a b : α} : lcm (Associates.mk a) (Associates.mk b) = Associates.mk (lcm a b) :=\n  rfl\n\n"}
