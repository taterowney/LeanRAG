{"name":"Basis.SmithNormalForm.toAddSubgroup_index_eq_pow_mul_prod","module":"Mathlib.LinearAlgebra.FreeModule.Int","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nn : Nat\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Fintype ι\ninst✝ : Module R M\nN : Submodule R M\nsnf : Basis.SmithNormalForm N ι n\n⊢ Eq N.toAddSubgroup.index (HMul.hMul (HPow.hPow (Nat.card R) (HSub.hSub (Fintype.card ι) n)) (Finset.univ.prod fun i => (Submodule.toAddSubgroup (Ideal.span (Singleton.singleton (snf.a i)))).index))","decl":"/-- Given a submodule `N` in Smith normal form of a free `R`-module, its index as an additive\nsubgroup is an appropriate power of the cardinality of `R` multiplied by the product of the\nindexes of the ideals generated by each basis vector. -/\nlemma toAddSubgroup_index_eq_pow_mul_prod [Module R M] {N : Submodule R M}\n    (snf : Basis.SmithNormalForm N ι n) :\n    N.toAddSubgroup.index = Nat.card R ^ (Fintype.card ι - n) *\n      ∏ i : Fin n, (Ideal.span {snf.a i}).toAddSubgroup.index := by\n  classical\n  rcases snf with ⟨bM, bN, f, a, snf⟩\n  dsimp only\n  set N' : Submodule R (ι → R) := N.map bM.equivFun with hN'\n  let bN' : Basis (Fin n) R N' := bN.map (bM.equivFun.submoduleMap N)\n  have snf' : ∀ i, (bN' i : ι → R) = Pi.single (f i) (a i) := by\n    intro i\n    simp only [map_apply, bN']\n    erw [LinearEquiv.submoduleMap_apply]\n    simp only [equivFun_apply, snf, map_smul, repr_self, Finsupp.single_eq_pi_single]\n    ext j\n    simp [Pi.single_apply]\n  have hNN' : N.toAddSubgroup.index = N'.toAddSubgroup.index := by\n    set e : (ι → R) ≃+ M := ↑bM.equivFun.symm with he\n    let e' : (ι → R) →+ M := e\n    have he' : Function.Surjective e' := e.surjective\n    convert (AddSubgroup.index_comap_of_surjective N.toAddSubgroup he').symm using 2\n    rw [AddSubgroup.comap_equiv_eq_map_symm, he, hN', LinearEquiv.coe_toAddEquiv_symm,\n    AddEquiv.symm_symm]\n    exact Submodule.map_toAddSubgroup ..\n  rw [hNN']\n  have hN' : N'.toAddSubgroup = AddSubgroup.pi Set.univ\n      (fun i ↦ (Ideal.span {if h : ∃ j, f j = i then a h.choose else 0}).toAddSubgroup) := by\n    ext g\n    simp only [Submodule.mem_toAddSubgroup, bN'.mem_submodule_iff', snf', AddSubgroup.mem_pi,\n      Set.mem_univ, true_implies, Ideal.mem_span_singleton]\n    refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n    · rcases h with ⟨c, rfl⟩\n      intro i\n      simp only [Finset.sum_apply, Pi.smul_apply, Pi.single_apply]\n      split_ifs with h\n      · convert dvd_mul_left (a h.choose) (c h.choose)\n        calc ∑ x : Fin n, _ = c h.choose * if i = f h.choose then a h.choose else 0 := by\n              refine Finset.sum_eq_single h.choose ?_ (by simp)\n              rintro j - hj\n              have hinj := f.injective.ne hj\n              rw [h.choose_spec] at hinj\n              simp [hinj.symm]\n          _ = c h.choose * a h.choose := by simp [h.choose_spec]\n      · convert dvd_refl (0 : R)\n        convert Finset.sum_const_zero with j\n        rw [not_exists] at h\n        specialize h j\n        rw [eq_comm] at h\n        simp [h]\n    · refine ⟨fun j ↦ (h (f j)).choose, ?_⟩\n      ext i\n      simp only [EmbeddingLike.apply_eq_iff_eq, exists_eq, ↓reduceDIte, Classical.choose_eq,\n        Finset.sum_apply, Pi.smul_apply, Pi.single_apply, smul_ite, smul_zero]\n      rw [eq_comm]\n      by_cases hj : ∃ j, f j = i\n      · calc ∑ x : Fin n, _ =\n            if i = f hj.choose then (h (f hj.choose)).choose * a hj.choose else 0 := by\n              convert Finset.sum_eq_single (β := R) hj.choose ?_ ?_\n              · simp [hj]\n              · rintro j - h\n                have hinj := f.injective.ne h\n                rw [hj.choose_spec] at hinj\n                simp [hinj.symm]\n              · simp\n          _ = g i := by\n              simp only [hj.choose_spec, ↓reduceIte]\n              rw [mul_comm]\n              conv_rhs =>\n                rw [← hj.choose_spec, (h (f hj.choose)).choose_spec]\n              simp only [EmbeddingLike.apply_eq_iff_eq, exists_eq, ↓reduceDIte, Classical.choose_eq]\n              congr!\n              · exact hj.choose_spec.symm\n              · simp [hj]\n      · convert Finset.sum_const_zero with x\n        · rw [not_exists] at hj\n          specialize hj x\n          rw [eq_comm] at hj\n          simp [hj]\n        · rw [← zero_dvd_iff]\n          convert h i\n          simp [hj]\n  simp only [hN', AddSubgroup.index_pi, apply_dite, Finset.prod_dite, Set.singleton_zero,\n    Ideal.span_zero, Submodule.bot_toAddSubgroup, AddSubgroup.index_pi, AddSubgroup.index_bot,\n    Finset.prod_const, Finset.univ_eq_attach, Finset.card_attach]\n  rw [mul_comm]\n  congr\n  · convert Finset.card_compl {x | ∃ j, f j = x} using 2\n    · exact (Finset.compl_filter _).symm\n    · convert (Finset.card_image_of_injective Finset.univ f.injective).symm <;> simp\n  · rw [Finset.attach_eq_univ]\n    let f' : Fin n → { x // x ∈ Finset.filter (fun x ↦ ∃ j, f j = x) Finset.univ } :=\n      fun i ↦ ⟨f i, by simp⟩\n    have hf' : Function.Injective f' := fun i j hij ↦ by\n      rw [Subtype.ext_iff] at hij\n      exact f.injective hij\n    let f'' : Fin n ↪ { x // x ∈ Finset.filter (fun x ↦ ∃ j, f j = x) Finset.univ } :=\n      ⟨f', hf'⟩\n    have hu : (Finset.univ : Finset { x // x ∈ Finset.filter (fun x ↦ ∃ j, f j = x) Finset.univ }) =\n      Finset.univ.map f'' := by\n      ext x\n      simp only [Finset.univ_eq_attach, Finset.mem_attach, Finset.mem_map, Finset.mem_univ,\n        true_and, true_iff]\n      have hx := x.property\n      simp only [Finset.univ_filter_exists, Finset.mem_image, Finset.mem_univ, true_and] at hx\n      rcases hx with ⟨i, hi⟩\n      refine ⟨i, ?_⟩\n      rw [Subtype.ext_iff]\n      exact hi\n    rw [hu, Finset.prod_map]\n    congr! with i\n    rw [← f.injective.eq_iff]\n    generalize_proofs h\n    rw [h.choose_spec]\n    rfl\n\n"}
{"name":"Basis.SmithNormalForm.toAddSubgroup_index_eq_ite","module":"Mathlib.LinearAlgebra.FreeModule.Int","initialProofState":"ι : Type u_1\nR : Type u_2\nM : Type u_3\nn : Nat\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Fintype ι\ninst✝¹ : Infinite R\ninst✝ : Module R M\nN : Submodule R M\nsnf : Basis.SmithNormalForm N ι n\n⊢ Eq N.toAddSubgroup.index (ite (Eq n (Fintype.card ι)) (Finset.univ.prod fun i => (Submodule.toAddSubgroup (Ideal.span (Singleton.singleton (snf.a i)))).index) 0)","decl":"/-- Given a submodule `N` in Smith normal form of a free `R`-module, its index as an additive\nsubgroup is infinite (represented as zero) if the submodule basis has fewer vectors than the basis\nfor the module, and otherwise equals the product of the indexes of the ideals generated by each\nbasis vector. -/\nlemma toAddSubgroup_index_eq_ite [Infinite R] [Module R M] {N : Submodule R M}\n    (snf : Basis.SmithNormalForm N ι n) : N.toAddSubgroup.index = (if n = Fintype.card ι then\n      ∏ i : Fin n, (Ideal.span {snf.a i}).toAddSubgroup.index else 0) := by\n  rw [snf.toAddSubgroup_index_eq_pow_mul_prod]\n  split_ifs with h\n  · simp [h]\n  · have hlt : n < Fintype.card ι :=\n      Ne.lt_of_le h (by simpa using Fintype.card_le_of_embedding snf.f)\n    simp [hlt]\n\n"}
{"name":"Basis.SmithNormalForm.toAddSubgroup_index_ne_zero_iff","module":"Mathlib.LinearAlgebra.FreeModule.Int","initialProofState":"ι : Type u_1\nM : Type u_3\nn : Nat\ninst✝¹ : AddCommGroup M\ninst✝ : Fintype ι\nN : Submodule Int M\nsnf : Basis.SmithNormalForm N ι n\n⊢ Iff (Ne N.toAddSubgroup.index 0) (Eq n (Fintype.card ι))","decl":"/-- Given a submodule `N` in Smith normal form of a free ℤ-module, it has finite index as an\nadditive subgroup (i.e., `N.toAddSubgroup.index ≠ 0`) if and only if the submodule basis has as\nmany vectors as the basis for the module. -/\nlemma toAddSubgroup_index_ne_zero_iff {N : Submodule ℤ M} (snf : Basis.SmithNormalForm N ι n) :\n    N.toAddSubgroup.index ≠ 0 ↔ n = Fintype.card ι := by\n  rw [snf.toAddSubgroup_index_eq_ite]\n  rcases snf with ⟨bM, bN, f, a, snf⟩\n  simp only [ne_eq, ite_eq_right_iff, Classical.not_imp, and_iff_left_iff_imp]\n  have ha : ∀ i, a i ≠ 0 := by\n    intro i hi\n    apply Basis.ne_zero bN i\n    specialize snf i\n    simpa [hi] using snf\n  intro h\n  simpa [Ideal.span_singleton_toAddSubgroup_eq_zmultiples, Int.index_zmultiples,\n    Finset.prod_eq_zero_iff] using ha\n\n"}
{"name":"Int.submodule_toAddSubgroup_index_ne_zero_iff","module":"Mathlib.LinearAlgebra.FreeModule.Int","initialProofState":"ι : Type u_1\ninst✝ : Finite ι\nN : Submodule Int (ι → Int)\n⊢ Iff (Ne N.toAddSubgroup.index 0) (Nonempty (LinearEquiv (RingHom.id Int) (Subtype fun x => Membership.mem N x) (ι → Int)))","decl":"lemma submodule_toAddSubgroup_index_ne_zero_iff {N : Submodule ℤ (ι → ℤ)} :\n    N.toAddSubgroup.index ≠ 0 ↔ Nonempty (N ≃ₗ[ℤ] (ι → ℤ)) := by\n  obtain ⟨n, snf⟩ := N.smithNormalForm <| Basis.ofEquivFun <| LinearEquiv.refl _ _\n  have := Fintype.ofFinite ι\n  rw [snf.toAddSubgroup_index_ne_zero_iff]\n  rcases snf with ⟨-, bN, -, -, -⟩\n  refine ⟨fun h ↦ ?_, fun ⟨e⟩ ↦ ?_⟩\n  · subst h\n    exact ⟨(bN.reindex (Fintype.equivFin _).symm).equivFun⟩\n  · have hc := card_eq_of_linearEquiv ℤ <| bN.equivFun.symm.trans e\n    simpa using hc\n\n"}
{"name":"Int.addSubgroup_index_ne_zero_iff","module":"Mathlib.LinearAlgebra.FreeModule.Int","initialProofState":"ι : Type u_1\ninst✝ : Finite ι\nH : AddSubgroup (ι → Int)\n⊢ Iff (Ne H.index 0) (Nonempty (AddEquiv (Subtype fun x => Membership.mem H x) (ι → Int)))","decl":"lemma addSubgroup_index_ne_zero_iff {H : AddSubgroup (ι → ℤ)} :\n    H.index ≠ 0 ↔ Nonempty (H ≃+ (ι → ℤ)) := by\n  convert submodule_toAddSubgroup_index_ne_zero_iff (N := AddSubgroup.toIntSubmodule H) using 1\n  exact ⟨fun ⟨e⟩ ↦ ⟨e.toIntLinearEquiv⟩, fun ⟨e⟩ ↦ ⟨e.toAddEquiv⟩⟩\n\n"}
{"name":"Int.subgroup_index_ne_zero_iff","module":"Mathlib.LinearAlgebra.FreeModule.Int","initialProofState":"ι : Type u_1\ninst✝ : Finite ι\nH : Subgroup (ι → Multiplicative Int)\n⊢ Iff (Ne H.index 0) (Nonempty (MulEquiv (Subtype fun x => Membership.mem H x) (ι → Multiplicative Int)))","decl":"lemma subgroup_index_ne_zero_iff {H : Subgroup (ι → Multiplicative ℤ)} :\n    H.index ≠ 0 ↔ Nonempty (H ≃* (ι → Multiplicative ℤ)) := by\n  let em : Multiplicative (ι → ℤ) ≃* (ι → Multiplicative ℤ) :=\n    MulEquiv.funMultiplicative _ _\n  let H' : Subgroup (Multiplicative (ι → ℤ)) := H.comap em\n  let eH' : H' ≃* H := (MulEquiv.subgroupCongr <| Subgroup.comap_equiv_eq_map_symm em H).trans\n    (MulEquiv.subgroupMap em.symm _).symm\n  have h : H'.index = H.index := Subgroup.index_comap_of_surjective _ em.surjective\n  rw [← h, ← Subgroup.index_toAddSubgroup, addSubgroup_index_ne_zero_iff]\n  exact ⟨fun ⟨e⟩ ↦ ⟨(eH'.symm.trans (AddEquiv.toMultiplicative e)).trans em⟩,\n    fun ⟨e⟩ ↦ ⟨(MulEquiv.toAdditive ((eH'.trans e).trans em.symm)).trans\n      (AddEquiv.additiveMultiplicative _)⟩⟩\n\n"}
