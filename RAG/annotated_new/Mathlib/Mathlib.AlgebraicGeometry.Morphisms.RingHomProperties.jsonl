{"name":"RingHom.IsStableUnderBaseChange.pullback_fst_appTop","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\nhP : RingHom.IsStableUnderBaseChange fun {R S} [CommRing R] [CommRing S] => P\nhP' : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nX Y S : AlgebraicGeometry.Scheme\ninst‚úù¬≤ : AlgebraicGeometry.IsAffine X\ninst‚úù¬π : AlgebraicGeometry.IsAffine Y\ninst‚úù : AlgebraicGeometry.IsAffine S\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH : P (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appTop g))\n‚ä¢ P (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appTop (CategoryTheory.Limits.pullback.fst f g)))","decl":"theorem IsStableUnderBaseChange.pullback_fst_appTop\n    (hP : IsStableUnderBaseChange P) (hP' : RespectsIso P)\n    {X Y S : Scheme} [IsAffine X] [IsAffine Y] [IsAffine S] (f : X ‚ü∂ S) (g : Y ‚ü∂ S)\n    (H : P g.appTop.hom) : P (pullback.fst f g).appTop.hom := by\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11224): change `rw` to `erw`\n  erw [‚Üê PreservesPullback.iso_inv_fst AffineScheme.forgetToScheme (AffineScheme.ofHom f)\n      (AffineScheme.ofHom g)]\n  rw [Scheme.comp_appTop, CommRingCat.hom_comp, hP'.cancel_right_isIso,\n    AffineScheme.forgetToScheme_map]\n  have := congr_arg Quiver.Hom.unop\n      (PreservesPullback.iso_hom_fst AffineScheme.Œì.rightOp (AffineScheme.ofHom f)\n        (AffineScheme.ofHom g))\n  simp only [AffineScheme.Œì, Functor.rightOp_obj, Functor.comp_obj, Functor.op_obj, unop_comp,\n    AffineScheme.forgetToScheme_obj, Scheme.Œì_obj, Functor.rightOp_map, Functor.comp_map,\n    Functor.op_map, Quiver.Hom.unop_op, AffineScheme.forgetToScheme_map, Scheme.Œì_map] at this\n  rw [‚Üê this, CommRingCat.hom_comp, hP'.cancel_right_isIso, ‚Üê pushoutIsoUnopPullback_inl_hom,\n    CommRingCat.hom_comp, hP'.cancel_right_isIso]\n  exact hP.pushout_inl _ hP' _ _ H\n\n"}
{"name":"RingHom.IsStableUnderBaseChange.pullback_fst_app_top","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\nhP : RingHom.IsStableUnderBaseChange fun {R S} [CommRing R] [CommRing S] => P\nhP' : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nX Y S : AlgebraicGeometry.Scheme\ninst‚úù¬≤ : AlgebraicGeometry.IsAffine X\ninst‚úù¬π : AlgebraicGeometry.IsAffine Y\ninst‚úù : AlgebraicGeometry.IsAffine S\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH : P (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appTop g))\n‚ä¢ P (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appTop (CategoryTheory.Limits.pullback.fst f g)))","decl":"@[deprecated (since := \"2024-11-23\")]\nalias IsStableUnderBaseChange.pullback_fst_app_top :=\nIsStableUnderBaseChange.pullback_fst_appTop\n\n"}
{"name":"AlgebraicGeometry.sourceAffineLocally_respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\nh‚ÇÅ : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\n‚ä¢ (AlgebraicGeometry.sourceAffineLocally fun {R S} [CommRing R] [CommRing S] => P).toProperty.RespectsIso","decl":"theorem sourceAffineLocally_respectsIso (h‚ÇÅ : RingHom.RespectsIso P) :\n    (sourceAffineLocally P).toProperty.RespectsIso := by\n  apply AffineTargetMorphismProperty.respectsIso_mk\n  ¬∑ introv H U\n    have : IsIso (e.hom.appLE (e.hom ''·µÅ U) U.1 (e.hom.preimage_image_eq _).ge) :=\n      inferInstanceAs (IsIso (e.hom.app _ ‚â´\n        X.presheaf.map (eqToHom (e.hom.preimage_image_eq _).symm).op))\n    rw [‚Üê Scheme.appLE_comp_appLE _ _ ‚ä§ (e.hom ''·µÅ U) U.1 le_top (e.hom.preimage_image_eq _).ge,\n      CommRingCat.hom_comp, h‚ÇÅ.cancel_right_isIso]\n    exact H ‚ü®_, U.prop.image_of_isOpenImmersion e.hom‚ü©\n  ¬∑ introv H U\n    rw [Scheme.comp_appLE, CommRingCat.hom_comp, h‚ÇÅ.cancel_left_isIso]\n    exact H U\n\n"}
{"name":"AlgebraicGeometry.affineLocally_respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\nh : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\n‚ä¢ (AlgebraicGeometry.affineLocally fun {R S} [CommRing R] [CommRing S] => P).RespectsIso","decl":"theorem affineLocally_respectsIso (h : RingHom.RespectsIso P) : (affineLocally P).RespectsIso :=\n  letI := sourceAffineLocally_respectsIso P h\n  inferInstance\n\n"}
{"name":"AlgebraicGeometry.sourceAffineLocally_morphismRestrict","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\n‚ä¢ Iff (AlgebraicGeometry.sourceAffineLocally (fun {R S} [CommRing R] [CommRing S] => P) (AlgebraicGeometry.morphismRestrict f U)) (‚àÄ (V : ‚ÜëX.affineOpens) (e : LE.le (‚ÜëV) ((TopologicalSpace.Opens.map f.base).obj U)), P (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f U (‚ÜëV) e)))","decl":"open Scheme in\ntheorem sourceAffineLocally_morphismRestrict {X Y : Scheme.{u}} (f : X ‚ü∂ Y)\n    (U : Y.Opens) (hU : IsAffineOpen U) :\n    @sourceAffineLocally P _ _ (f ‚à£_ U) hU ‚Üî\n      ‚àÄ (V : X.affineOpens) (e : V.1 ‚â§ f ‚Åª¬π·µÅ U), P (f.appLE U V e).hom := by\n  dsimp only [sourceAffineLocally]\n  simp only [morphismRestrict_appLE]\n  rw [(affineOpensRestrict (f ‚Åª¬π·µÅ U)).forall_congr_left, Subtype.forall]\n  refine forall‚ÇÇ_congr fun V h ‚Ü¶ ?_\n  have := (affineOpensRestrict (f ‚Åª¬π·µÅ U)).apply_symm_apply ‚ü®V, h‚ü©\n  exact f.appLE_congr _ (Opens.Œπ_image_top _) congr($(this).1.1) (fun f => P f.hom)\n\n"}
{"name":"AlgebraicGeometry.affineLocally_iff_affineOpens_le","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n‚ä¢ Iff (AlgebraicGeometry.affineLocally (fun {R S} [CommRing R] [CommRing S] => P) f) (‚àÄ (U : ‚ÜëY.affineOpens) (V : ‚ÜëX.affineOpens) (e : LE.le (‚ÜëV) ((TopologicalSpace.Opens.map f.base).obj ‚ÜëU)), P (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (‚ÜëU) (‚ÜëV) e)))","decl":"theorem affineLocally_iff_affineOpens_le {X Y : Scheme.{u}} (f : X ‚ü∂ Y) :\n    affineLocally.{u} P f ‚Üî\n      ‚àÄ (U : Y.affineOpens) (V : X.affineOpens) (e : V.1 ‚â§ f ‚Åª¬π·µÅ U.1), P (f.appLE U V e).hom :=\n  forall_congr' fun U ‚Ü¶ sourceAffineLocally_morphismRestrict P f U U.2\n\n"}
{"name":"AlgebraicGeometry.sourceAffineLocally_isLocal","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\nh‚ÇÅ : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nh‚ÇÇ : RingHom.LocalizationAwayPreserves fun {R S} [CommRing R] [CommRing S] => P\nh‚ÇÉ : RingHom.OfLocalizationSpan fun {R S} [CommRing R] [CommRing S] => P\n‚ä¢ (AlgebraicGeometry.sourceAffineLocally fun {R S} [CommRing R] [CommRing S] => P).IsLocal","decl":"theorem sourceAffineLocally_isLocal (h‚ÇÅ : RingHom.RespectsIso P)\n    (h‚ÇÇ : RingHom.LocalizationAwayPreserves P) (h‚ÇÉ : RingHom.OfLocalizationSpan P) :\n    (sourceAffineLocally P).IsLocal := by\n  constructor\n  ¬∑ exact sourceAffineLocally_respectsIso P h‚ÇÅ\n  ¬∑ intro X Y _ f r H\n    rw [sourceAffineLocally_morphismRestrict]\n    intro U hU\n    have : X.basicOpen (f.appLE ‚ä§ U (by simp) r) = U := by\n      simp only [Scheme.Hom.appLE, Opens.map_top, CommRingCat.comp_apply, RingHom.coe_comp,\n        Function.comp_apply]\n      rw [Scheme.basicOpen_res]\n      simpa using hU\n    rw [‚Üê f.appLE_congr _ rfl this (fun f => P f.hom),\n      IsAffineOpen.appLE_eq_away_map f (isAffineOpen_top Y) U.2 _ r]\n    simp only [CommRingCat.hom_ofHom]\n    apply (config := { allowSynthFailures := true }) h‚ÇÇ\n    exact H U\n  ¬∑ introv hs hs' U\n    apply h‚ÇÉ _ _ hs\n    intro r\n    simp_rw [sourceAffineLocally_morphismRestrict] at hs'\n    have := hs' r ‚ü®X.basicOpen (f.appLE ‚ä§ U le_top r.1), U.2.basicOpen (f.appLE ‚ä§ U le_top r.1)‚ü©\n      (by simp [Scheme.Hom.appLE])\n    rwa [IsAffineOpen.appLE_eq_away_map f (isAffineOpen_top Y) U.2, CommRingCat.hom_ofHom,\n      ‚Üê h‚ÇÅ.is_localization_away_iff] at this\n\n"}
{"name":"AlgebraicGeometry.affineLocally_le","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P Q : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\nhPQ : ‚àÄ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] {f : RingHom R S}, P f ‚Üí Q f\n‚ä¢ LE.le (AlgebraicGeometry.affineLocally fun {R S} [CommRing R] [CommRing S] => P) (AlgebraicGeometry.affineLocally fun {R S} [CommRing R] [CommRing S] => Q)","decl":"lemma affineLocally_le {Q : ‚àÄ {R S : Type u} [CommRing R] [CommRing S], (R ‚Üí+* S) ‚Üí Prop}\n    (hPQ : ‚àÄ {R S : Type u} [CommRing R] [CommRing S] {f : R ‚Üí+* S}, P f ‚Üí Q f) :\n    affineLocally P ‚â§ affineLocally Q :=\n  fun _ _ _ hf U V ‚Ü¶ hPQ (hf U V)\n\n"}
{"name":"AlgebraicGeometry.exists_basicOpen_le_appLE_of_appLE_of_isAffine","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhPa : RingHom.StableUnderCompositionWithLocalizationAwayTarget fun {R S} [CommRing R] [CommRing S] => P\nhPl : RingHom.LocalizationAwayPreserves fun {R S} [CommRing R] [CommRing S] => P\nx : ‚Üë‚ÜëX.toPresheafedSpace\nU‚ÇÅ U‚ÇÇ : ‚ÜëY.affineOpens\nV‚ÇÅ V‚ÇÇ : ‚ÜëX.affineOpens\nhx‚ÇÅ : Membership.mem (‚ÜëV‚ÇÅ) x\nhx‚ÇÇ : Membership.mem (‚ÜëV‚ÇÇ) x\ne‚ÇÇ : LE.le (‚ÜëV‚ÇÇ) ((TopologicalSpace.Opens.map f.base).obj ‚ÜëU‚ÇÇ)\nh‚ÇÇ : P (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (‚ÜëU‚ÇÇ) (‚ÜëV‚ÇÇ) e‚ÇÇ))\nhfx‚ÇÅ : Membership.mem (‚ÜëU‚ÇÅ) (f.base x)\n‚ä¢ Exists fun r => Exists fun s => Exists fun x => Exists fun e => P (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (Y.basicOpen r) (X.basicOpen s) e))","decl":"/-- If `P` holds for `f` over affine opens `U‚ÇÇ` of `Y` and `V‚ÇÇ` of `X` and `U‚ÇÅ` (resp. `V‚ÇÅ`) are\nopen affine neighborhoods of `x` (resp. `f.base x`), then `P` also holds for `f`\nover some basic open of `U‚ÇÅ` (resp. `V‚ÇÅ`). -/\nlemma exists_basicOpen_le_appLE_of_appLE_of_isAffine\n    (hPa : StableUnderCompositionWithLocalizationAwayTarget P) (hPl : LocalizationAwayPreserves P)\n    (x : X) (U‚ÇÅ : Y.affineOpens) (U‚ÇÇ : Y.affineOpens) (V‚ÇÅ : X.affineOpens) (V‚ÇÇ : X.affineOpens)\n    (hx‚ÇÅ : x ‚àà V‚ÇÅ.1) (hx‚ÇÇ : x ‚àà V‚ÇÇ.1) (e‚ÇÇ : V‚ÇÇ.1 ‚â§ f ‚Åª¬π·µÅ U‚ÇÇ.1) (h‚ÇÇ : P (f.appLE U‚ÇÇ V‚ÇÇ e‚ÇÇ).hom)\n    (hfx‚ÇÅ : f.base x ‚àà U‚ÇÅ.1) :\n    ‚àÉ (r : Œì(Y, U‚ÇÅ)) (s : Œì(X, V‚ÇÅ)) (_ : x ‚àà X.basicOpen s)\n      (e : X.basicOpen s ‚â§ f ‚Åª¬π·µÅ Y.basicOpen r),\n        P (f.appLE (Y.basicOpen r) (X.basicOpen s) e).hom := by\n  obtain ‚ü®r, r', hBrr', hBfx‚ü© := exists_basicOpen_le_affine_inter U‚ÇÅ.2 U‚ÇÇ.2 (f.base x)\n    ‚ü®hfx‚ÇÅ, e‚ÇÇ hx‚ÇÇ‚ü©\n  have ha : IsAffineOpen (X.basicOpen (f.appLE U‚ÇÇ V‚ÇÇ e‚ÇÇ r')) := V‚ÇÇ.2.basicOpen _\n  have hxa : x ‚àà X.basicOpen (f.appLE U‚ÇÇ V‚ÇÇ e‚ÇÇ r') := by\n    simpa [Scheme.Hom.appLE, ‚Üê Scheme.preimage_basicOpen] using And.intro hx‚ÇÇ (hBrr' ‚ñ∏ hBfx)\n  obtain ‚ü®s, s', hBss', hBx‚ü© := exists_basicOpen_le_affine_inter V‚ÇÅ.2 ha x ‚ü®hx‚ÇÅ, hxa‚ü©\n  haveI := V‚ÇÇ.2.isLocalization_basicOpen (f.appLE U‚ÇÇ V‚ÇÇ e‚ÇÇ r')\n  haveI := U‚ÇÇ.2.isLocalization_basicOpen r'\n  haveI := ha.isLocalization_basicOpen s'\n  have ers : X.basicOpen s ‚â§ f ‚Åª¬π·µÅ Y.basicOpen r := by\n    rw [hBss', hBrr']\n    apply le_trans (X.basicOpen_le _)\n    simp [Scheme.Hom.appLE]\n  have heq : f.appLE (Y.basicOpen r') (X.basicOpen s') (hBrr' ‚ñ∏ hBss' ‚ñ∏ ers) =\n      f.appLE (Y.basicOpen r') (X.basicOpen (f.appLE U‚ÇÇ V‚ÇÇ e‚ÇÇ r')) (by simp [Scheme.Hom.appLE]) ‚â´\n        CommRingCat.ofHom (algebraMap _ _) := by\n    simp only [Scheme.Hom.appLE, homOfLE_leOfHom, CommRingCat.comp_apply, Category.assoc]\n    congr\n    apply X.presheaf.map_comp\n  refine ‚ü®r, s, hBx, ers, ?_‚ü©\n  ¬∑ rw [f.appLE_congr _ hBrr' hBss' (fun f => P f.hom), heq]\n    apply hPa _ s' _\n    rw [U‚ÇÇ.2.appLE_eq_away_map f V‚ÇÇ.2]\n    exact hPl _ _ _ _ h‚ÇÇ\n\n"}
{"name":"AlgebraicGeometry.exists_affineOpens_le_appLE_of_appLE","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhPa : RingHom.StableUnderCompositionWithLocalizationAwayTarget fun {R S} [CommRing R] [CommRing S] => P\nhPl : RingHom.LocalizationAwayPreserves fun {R S} [CommRing R] [CommRing S] => P\nx : ‚Üë‚ÜëX.toPresheafedSpace\nU‚ÇÅ : Y.Opens\nU‚ÇÇ : ‚ÜëY.affineOpens\nV‚ÇÅ : X.Opens\nV‚ÇÇ : ‚ÜëX.affineOpens\nhx‚ÇÅ : Membership.mem V‚ÇÅ x\nhx‚ÇÇ : Membership.mem (‚ÜëV‚ÇÇ) x\ne‚ÇÇ : LE.le (‚ÜëV‚ÇÇ) ((TopologicalSpace.Opens.map f.base).obj ‚ÜëU‚ÇÇ)\nh‚ÇÇ : P (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (‚ÜëU‚ÇÇ) (‚ÜëV‚ÇÇ) e‚ÇÇ))\nhfx‚ÇÅ : Membership.mem U‚ÇÅ.carrier (f.base x)\n‚ä¢ Exists fun U' => Exists fun V' => Exists fun x_1 => Exists fun x_2 => Exists fun x => Exists fun e => P (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (‚ÜëU') (‚ÜëV') e))","decl":"/-- If `P` holds for `f` over affine opens `U‚ÇÇ` of `Y` and `V‚ÇÇ` of `X` and `U‚ÇÅ` (resp. `V‚ÇÅ`) are\nopen neighborhoods of `x` (resp. `f.base x`), then `P` also holds for `f` over some affine open\n`U'` of `Y` (resp. `V'` of `X`) that is contained in `U‚ÇÅ` (resp. `V‚ÇÅ`). -/\nlemma exists_affineOpens_le_appLE_of_appLE\n    (hPa : StableUnderCompositionWithLocalizationAwayTarget P) (hPl : LocalizationAwayPreserves P)\n    (x : X) (U‚ÇÅ : Y.Opens) (U‚ÇÇ : Y.affineOpens) (V‚ÇÅ : X.Opens) (V‚ÇÇ : X.affineOpens)\n    (hx‚ÇÅ : x ‚àà V‚ÇÅ) (hx‚ÇÇ : x ‚àà V‚ÇÇ.1) (e‚ÇÇ : V‚ÇÇ.1 ‚â§ f ‚Åª¬π·µÅ U‚ÇÇ.1) (h‚ÇÇ : P (f.appLE U‚ÇÇ V‚ÇÇ e‚ÇÇ).hom)\n    (hfx‚ÇÅ : f.base x ‚àà U‚ÇÅ.1) :\n    ‚àÉ (U' : Y.affineOpens) (V' : X.affineOpens) (_ : U'.1 ‚â§ U‚ÇÅ) (_ : V'.1 ‚â§ V‚ÇÅ) (_ : x ‚àà V'.1)\n      (e : V'.1 ‚â§ f‚Åª¬π·µÅ U'.1), P (f.appLE U' V' e).hom := by\n  obtain ‚ü®r, hBr, hBfx‚ü© := U‚ÇÇ.2.exists_basicOpen_le ‚ü®f.base x, hfx‚ÇÅ‚ü© (e‚ÇÇ hx‚ÇÇ)\n  obtain ‚ü®s, hBs, hBx‚ü© := V‚ÇÇ.2.exists_basicOpen_le ‚ü®x, hx‚ÇÅ‚ü© hx‚ÇÇ\n  obtain ‚ü®r', s', hBx', e', hf'‚ü© := exists_basicOpen_le_appLE_of_appLE_of_isAffine hPa hPl x\n    ‚ü®Y.basicOpen r, U‚ÇÇ.2.basicOpen _‚ü© U‚ÇÇ ‚ü®X.basicOpen s, V‚ÇÇ.2.basicOpen _‚ü© V‚ÇÇ hBx hx‚ÇÇ e‚ÇÇ h‚ÇÇ hBfx\n  exact ‚ü®‚ü®Y.basicOpen r', (U‚ÇÇ.2.basicOpen _).basicOpen _‚ü©,\n    ‚ü®X.basicOpen s', (V‚ÇÇ.2.basicOpen _).basicOpen _‚ü©, le_trans (Y.basicOpen_le _) hBr,\n    le_trans (X.basicOpen_le _) hBs, hBx', e', hf'‚ü©\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.isLocal_ringHomProperty","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : outParam ({R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop)\nself : AlgebraicGeometry.HasRingHomProperty P Q\n‚ä¢ RingHom.PropertyIsLocal fun {R S} [CommRing R] [CommRing S] => Q","decl":"/--\n`HasRingHomProperty P Q` is a type class asserting that `P` is local at the target and the source,\nand for `f : Spec B ‚ü∂ Spec A`, it is equivalent to the ring hom property `Q`.\nTo make the proofs easier, we state it instead as\n1. `Q` is local (See `RingHom.PropertyIsLocal`)\n2. `P f` if and only if `Q` holds for every `Œì(Y, U) ‚ü∂ Œì(X, V)` for all affine `U`, `V`.\nSee `HasRingHomProperty.iff_appLE`.\n-/\nclass HasRingHomProperty (P : MorphismProperty Scheme.{u})\n    (Q : outParam (‚àÄ {R S : Type u} [CommRing R] [CommRing S], (R ‚Üí+* S) ‚Üí Prop)) : Prop where\n  isLocal_ringHomProperty : RingHom.PropertyIsLocal Q\n  eq_affineLocally' : P = affineLocally Q\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.eq_affineLocally'","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : outParam ({R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop)\nself : AlgebraicGeometry.HasRingHomProperty P Q\n‚ä¢ Eq P (AlgebraicGeometry.affineLocally fun {R S} [CommRing R] [CommRing S] => Q)","decl":"/--\n`HasRingHomProperty P Q` is a type class asserting that `P` is local at the target and the source,\nand for `f : Spec B ‚ü∂ Spec A`, it is equivalent to the ring hom property `Q`.\nTo make the proofs easier, we state it instead as\n1. `Q` is local (See `RingHom.PropertyIsLocal`)\n2. `P f` if and only if `Q` holds for every `Œì(Y, U) ‚ü∂ Œì(X, V)` for all affine `U`, `V`.\nSee `HasRingHomProperty.iff_appLE`.\n-/\nclass HasRingHomProperty (P : MorphismProperty Scheme.{u})\n    (Q : outParam (‚àÄ {R S : Type u} [CommRing R] [CommRing S], (R ‚Üí+* S) ‚Üí Prop)) : Prop where\n  isLocal_ringHomProperty : RingHom.PropertyIsLocal Q\n  eq_affineLocally' : P = affineLocally Q\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.copy","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù : AlgebraicGeometry.HasRingHomProperty P Q\nP' : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ' : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ne : Eq P P'\ne' : ‚àÄ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (f : RingHom R S), Iff (Q f) (Q' f)\n‚ä¢ AlgebraicGeometry.HasRingHomProperty P' fun {R S} [CommRing R] [CommRing S] => Q'","decl":"lemma copy {P' : MorphismProperty Scheme.{u}}\n    {Q' : ‚àÄ {R S : Type u} [CommRing R] [CommRing S], (R ‚Üí+* S) ‚Üí Prop}\n    (e : P = P') (e' : ‚àÄ {R S : Type u} [CommRing R] [CommRing S] (f : R ‚Üí+* S), Q f ‚Üî Q' f) :\n    HasRingHomProperty P' Q' := by\n  subst e\n  have heq : @Q = @Q' := by\n    ext R S _ _ f\n    exact (e' f)\n  rw [‚Üê heq]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.eq_affineLocally","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù : AlgebraicGeometry.HasRingHomProperty P Q\n‚ä¢ Eq P (AlgebraicGeometry.affineLocally fun {R S} [CommRing R] [CommRing S] => Q)","decl":"lemma eq_affineLocally : P = affineLocally Q := eq_affineLocally'\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.HasAffineProperty","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù : AlgebraicGeometry.HasRingHomProperty P Q\n‚ä¢ AlgebraicGeometry.HasAffineProperty P (AlgebraicGeometry.sourceAffineLocally fun {R S} [CommRing R] [CommRing S] => Q)","decl":"@[local instance]\nlemma HasAffineProperty : HasAffineProperty P (sourceAffineLocally Q) where\n  isLocal_affineProperty := sourceAffineLocally_isLocal _\n    (isLocal_ringHomProperty P).respectsIso\n    (isLocal_ringHomProperty P).localizationAwayPreserves\n    (isLocal_ringHomProperty P).ofLocalizationSpan\n  eq_targetAffineLocally' := eq_affineLocally P\n\n/- This is only `inferInstance` because of the `@[local instance]` on `HasAffineProperty` above. -/\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.instIsLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù : AlgebraicGeometry.HasRingHomProperty P Q\n‚ä¢ AlgebraicGeometry.IsLocalAtTarget P","decl":"instance (priority := 900) : IsLocalAtTarget P := inferInstance\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.appLE","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nH : P f\nU : ‚ÜëY.affineOpens\nV : ‚ÜëX.affineOpens\ne : LE.le (‚ÜëV) ((TopologicalSpace.Opens.map f.base).obj ‚ÜëU)\n‚ä¢ Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (‚ÜëU) (‚ÜëV) e))","decl":"theorem appLE (H : P f) (U : Y.affineOpens) (V : X.affineOpens) (e) : Q (f.appLE U V e).hom := by\n  rw [eq_affineLocally P, affineLocally_iff_affineOpens_le] at H\n  exact H _ _ _\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.appTop","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù¬≤ : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nH : P f\ninst‚úù¬π : AlgebraicGeometry.IsAffine X\ninst‚úù : AlgebraicGeometry.IsAffine Y\n‚ä¢ Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appTop f))","decl":"theorem appTop (H : P f) [IsAffine X] [IsAffine Y] : Q f.appTop.hom := by\n  rw [Scheme.Hom.appTop, Scheme.Hom.app_eq_appLE]\n  exact appLE P f H ‚ü®_, isAffineOpen_top _‚ü© ‚ü®_, isAffineOpen_top _‚ü© _\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.app_top","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù¬≤ : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nH : P f\ninst‚úù¬π : AlgebraicGeometry.IsAffine X\ninst‚úù : AlgebraicGeometry.IsAffine Y\n‚ä¢ Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appTop f))","decl":"@[deprecated (since := \"2024-11-23\")] alias app_top := appTop\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.comp_of_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù¬π : AlgebraicGeometry.HasRingHomProperty P Q\nX Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù : AlgebraicGeometry.IsOpenImmersion f\nH : P g\n‚ä¢ P (CategoryTheory.CategoryStruct.comp f g)","decl":"include Q in\ntheorem comp_of_isOpenImmersion [IsOpenImmersion f] (H : P g) :\n    P (f ‚â´ g) := by\n  rw [eq_affineLocally P, affineLocally_iff_affineOpens_le] at H ‚ä¢\n  intro U V e\n  have : IsIso (f.appLE (f ''·µÅ V) V.1 (f.preimage_image_eq _).ge) :=\n    inferInstanceAs (IsIso (f.app _ ‚â´\n      X.presheaf.map (eqToHom (f.preimage_image_eq _).symm).op))\n  rw [‚Üê Scheme.appLE_comp_appLE _ _ _ (f ''·µÅ V) V.1\n    (Set.image_subset_iff.mpr e) (f.preimage_image_eq _).ge,\n    CommRingCat.hom_comp,\n    (isLocal_ringHomProperty P).respectsIso.cancel_right_isIso]\n  exact H _ ‚ü®_, V.2.image_of_isOpenImmersion _‚ü© _\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.iff_appLE","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n‚ä¢ Iff (P f) (‚àÄ (U : ‚ÜëY.affineOpens) (V : ‚ÜëX.affineOpens) (e : LE.le (‚ÜëV) ((TopologicalSpace.Opens.map f.base).obj ‚ÜëU)), Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (‚ÜëU) (‚ÜëV) e)))","decl":"lemma iff_appLE : P f ‚Üî ‚àÄ (U : Y.affineOpens) (V : X.affineOpens) (e), Q (f.appLE U V e).hom := by\n  rw [eq_affineLocally P, affineLocally_iff_affineOpens_le]\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.of_source_openCover","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù¬≤ : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù¬π : AlgebraicGeometry.IsAffine Y\nùí∞ : X.OpenCover\ninst‚úù : ‚àÄ (i : ùí∞.J), AlgebraicGeometry.IsAffine (ùí∞.obj i)\nH : ‚àÄ (i : ùí∞.J), Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appTop (CategoryTheory.CategoryStruct.comp (ùí∞.map i) f)))\n‚ä¢ P f","decl":"theorem of_source_openCover [IsAffine Y]\n    (ùí∞ : X.OpenCover) [‚àÄ i, IsAffine (ùí∞.obj i)] (H : ‚àÄ i, Q ((ùí∞.map i ‚â´ f).appTop.hom)) :\n    P f := by\n  rw [HasAffineProperty.iff_of_isAffine (P := P)]\n  intro U\n  let S i : X.affineOpens := ‚ü®_, isAffineOpen_opensRange (ùí∞.map i)‚ü©\n  induction U using of_affine_open_cover S ùí∞.iSup_opensRange with\n  | basicOpen U r H =>\n    simp_rw [Scheme.affineBasicOpen_coe,\n      ‚Üê f.appLE_map (U := ‚ä§) le_top (homOfLE (X.basicOpen_le r)).op]\n    have := U.2.isLocalization_basicOpen r\n    exact (isLocal_ringHomProperty P).StableUnderCompositionWithLocalizationAwayTarget _ r _ H\n  | openCover U s hs H =>\n    apply (isLocal_ringHomProperty P).ofLocalizationSpanTarget.ofIsLocalization\n      (isLocal_ringHomProperty P).respectsIso _ _ hs\n    rintro r\n    refine ‚ü®_, _, _, IsAffineOpen.isLocalization_basicOpen U.2 r, ?_‚ü©\n    rw [RingHom.algebraMap_toAlgebra, ‚Üê CommRingCat.hom_comp, Scheme.Hom.appLE_map]\n    exact H r\n  | hU i =>\n    specialize H i\n    rw [‚Üê (isLocal_ringHomProperty P).respectsIso.cancel_right_isIso _\n      ((IsOpenImmersion.isoOfRangeEq (ùí∞.map i) (S i).1.Œπ\n      Subtype.range_coe.symm).inv.app _), ‚Üê CommRingCat.hom_comp, ‚Üê Scheme.comp_appTop,\n      IsOpenImmersion.isoOfRangeEq_inv_fac_assoc, Scheme.comp_appTop,\n      Scheme.Opens.Œπ_appTop, Scheme.Hom.appTop, Scheme.Hom.app_eq_appLE, Scheme.Hom.appLE_map] at H\n    exact (f.appLE_congr _ rfl (by simp) (fun f => Q f.hom)).mp H\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.iff_of_source_openCover","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù¬≤ : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù¬π : AlgebraicGeometry.IsAffine Y\nùí∞ : X.OpenCover\ninst‚úù : ‚àÄ (i : ùí∞.J), AlgebraicGeometry.IsAffine (ùí∞.obj i)\n‚ä¢ Iff (P f) (‚àÄ (i : ùí∞.J), Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appTop (CategoryTheory.CategoryStruct.comp (ùí∞.map i) f))))","decl":"theorem iff_of_source_openCover [IsAffine Y] (ùí∞ : X.OpenCover) [‚àÄ i, IsAffine (ùí∞.obj i)] :\n    P f ‚Üî ‚àÄ i, Q ((ùí∞.map i ‚â´ f).appTop).hom :=\n  ‚ü®fun H i ‚Ü¶ appTop P _ (comp_of_isOpenImmersion P (ùí∞.map i) f H), of_source_openCover ùí∞‚ü©\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.iff_of_isAffine","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù¬≤ : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù¬π : AlgebraicGeometry.IsAffine X\ninst‚úù : AlgebraicGeometry.IsAffine Y\n‚ä¢ Iff (P f) (Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appTop f)))","decl":"theorem iff_of_isAffine [IsAffine X] [IsAffine Y] :\n    P f ‚Üî Q (f.appTop).hom := by\n  rw [iff_of_source_openCover (P := P) (Scheme.coverOfIsIso.{u} (ùüô _))]\n  simp\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.Spec_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù : AlgebraicGeometry.HasRingHomProperty P Q\nR S : CommRingCat\nœÜ : Quiver.Hom R S\n‚ä¢ Iff (P (AlgebraicGeometry.Spec.map œÜ)) (Q (CommRingCat.Hom.hom œÜ))","decl":"theorem Spec_iff {R S : CommRingCat.{u}} {œÜ : R ‚ü∂ S} :\n    P (Spec.map œÜ) ‚Üî Q œÜ.hom := by\n  have H := (isLocal_ringHomProperty P).respectsIso\n  rw [iff_of_isAffine (P := P), ‚Üê H.cancel_right_isIso _ (Scheme.ŒìSpecIso _).hom,\n    ‚Üê CommRingCat.hom_comp, Scheme.ŒìSpecIso_naturality, CommRingCat.hom_comp, H.cancel_left_isIso]\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.of_iSup_eq_top","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù¬π : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : AlgebraicGeometry.IsAffine Y\nŒπ : Type u_1\nU : Œπ ‚Üí ‚ÜëX.affineOpens\nhU : Eq (iSup fun i => ‚Üë(U i)) Top.top\nH : ‚àÄ (i : Œπ), Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f Top.top ‚Üë(U i) ‚ãØ))\n‚ä¢ P f","decl":"theorem of_iSup_eq_top [IsAffine Y] {Œπ : Type*}\n    (U : Œπ ‚Üí X.affineOpens) (hU : ‚®Ü i, (U i : Opens X) = ‚ä§)\n    (H : ‚àÄ i, Q (f.appLE ‚ä§ (U i).1 le_top).hom) :\n    P f := by\n  have (i) : IsAffine ((X.openCoverOfISupEqTop _ hU).obj i) := (U i).2\n  refine of_source_openCover (X.openCoverOfISupEqTop _ hU) fun i ‚Ü¶ ?_\n  simpa [Scheme.Hom.app_eq_appLE] using (f.appLE_congr _ rfl (by simp) (fun f => Q f.hom)).mp (H i)\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.iff_of_iSup_eq_top","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù¬π : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : AlgebraicGeometry.IsAffine Y\nŒπ : Type u_1\nU : Œπ ‚Üí ‚ÜëX.affineOpens\nhU : Eq (iSup fun i => ‚Üë(U i)) Top.top\n‚ä¢ Iff (P f) (‚àÄ (i : Œπ), Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f Top.top ‚Üë(U i) ‚ãØ)))","decl":"theorem iff_of_iSup_eq_top [IsAffine Y] {Œπ : Type*}\n    (U : Œπ ‚Üí X.affineOpens) (hU : ‚®Ü i, (U i : Opens X) = ‚ä§) :\n    P f ‚Üî ‚àÄ i, Q (f.appLE ‚ä§ (U i).1 le_top).hom :=\n  ‚ü®fun H _ ‚Ü¶ appLE P f H ‚ü®_, isAffineOpen_top _‚ü© _ le_top, of_iSup_eq_top U hU‚ü©\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.instIsLocalAtSource","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\n‚ä¢ AlgebraicGeometry.IsLocalAtSource P","decl":"instance : IsLocalAtSource P := by\n  apply HasAffineProperty.isLocalAtSource\n  intros X Y f _ ùí∞\n  simp_rw [‚Üê HasAffineProperty.iff_of_isAffine (P := P),\n    iff_of_source_openCover ùí∞.affineRefinement.openCover,\n    fun i ‚Ü¶ iff_of_source_openCover (P := P) (f := ùí∞.map i ‚â´ f) (ùí∞.obj i).affineCover]\n  simp [Scheme.OpenCover.affineRefinement, Sigma.forall]\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.containsIdentities","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù : AlgebraicGeometry.HasRingHomProperty P Q\nhP : RingHom.ContainsIdentities fun {R S} [CommRing R] [CommRing S] => Q\n‚ä¢ P.ContainsIdentities","decl":"lemma containsIdentities (hP : RingHom.ContainsIdentities Q) : P.ContainsIdentities where\n  id_mem X := by\n    rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := P) _ (iSup_affineOpens_eq_top _)]\n    intro U\n    have : IsAffine (ùüô X ‚Åª¬π·µÅ U.1) := U.2\n    rw [morphismRestrict_id, iff_of_isAffine (P := P), Scheme.id_appTop]\n    apply hP\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.isLocal_ringHomProperty_of_isLocalAtSource_of_isLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst‚úù¬π : AlgebraicGeometry.IsLocalAtTarget P\ninst‚úù : AlgebraicGeometry.IsLocalAtSource P\n‚ä¢ RingHom.PropertyIsLocal fun {R S} [CommRing R] [CommRing S] f => P (AlgebraicGeometry.Spec.map (CommRingCat.ofHom f))","decl":"variable (P) in\nopen _root_.PrimeSpectrum in\nlemma isLocal_ringHomProperty_of_isLocalAtSource_of_isLocalAtTarget\n    [IsLocalAtTarget P] [IsLocalAtSource P] :\n    RingHom.PropertyIsLocal fun f ‚Ü¶ P (Spec.map (CommRingCat.ofHom f)) := by\n  have hP : RingHom.RespectsIso (fun f ‚Ü¶ P (Spec.map (CommRingCat.ofHom f))) :=\n    RingHom.toMorphismProperty_respectsIso_iff.mpr\n      (inferInstanceAs (P.inverseImage Scheme.Spec).unop.RespectsIso)\n  constructor\n  ¬∑ intro R S _ _ f r R' S' _ _ _ _ _ _ H\n    refine (RingHom.RespectsIso.is_localization_away_iff hP ..).mp ?_\n    exact (MorphismProperty.arrow_mk_iso_iff P (SpecMapRestrictBasicOpenIso\n      (CommRingCat.ofHom f) r)).mp (IsLocalAtTarget.restrict H (basicOpen r))\n  ¬∑ intros R S _ _ f s hs H\n    apply IsLocalAtSource.of_openCover (Scheme.affineOpenCoverOfSpanRangeEqTop\n      (fun i : s ‚Ü¶ (i : S)) (by simpa)).openCover\n    intro i\n    simp only [CommRingCat.coe_of, Set.setOf_mem_eq, id_eq, eq_mpr_eq_cast,\n      Scheme.AffineOpenCover.openCover_obj, Scheme.affineOpenCoverOfSpanRangeEqTop_obj_carrier,\n      Scheme.AffineOpenCover.openCover_map, Scheme.affineOpenCoverOfSpanRangeEqTop_map,\n      ‚Üê Spec.map_comp]\n    exact H i\n  ¬∑ intro R S _ _  f s hs H\n    apply IsLocalAtTarget.of_iSup_eq_top _ (PrimeSpectrum.iSup_basicOpen_eq_top_iff\n      (f := fun i : s ‚Ü¶ (i : R)).mpr (by simpa))\n    intro i\n    exact (MorphismProperty.arrow_mk_iso_iff P (SpecMapRestrictBasicOpenIso\n      (CommRingCat.ofHom f) i.1)).mpr (H i)\n  ¬∑ intro R S T _ _ _ _ r _ f hf\n    have := AlgebraicGeometry.IsOpenImmersion.of_isLocalization (S := T) r\n    show P (Spec.map (CommRingCat.ofHom f ‚â´ CommRingCat.ofHom (algebraMap _ _)))\n    rw [Spec.map_comp]\n    exact IsLocalAtSource.comp hf ..\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.of_isLocalAtSource_of_isLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst‚úù¬π : AlgebraicGeometry.IsLocalAtTarget P\ninst‚úù : AlgebraicGeometry.IsLocalAtSource P\n‚ä¢ AlgebraicGeometry.HasRingHomProperty P fun {R S} [CommRing R] [CommRing S] f => P (AlgebraicGeometry.Spec.map (CommRingCat.ofHom f))","decl":"open _root_.PrimeSpectrum in\nvariable (P) in\nlemma of_isLocalAtSource_of_isLocalAtTarget [IsLocalAtTarget P] [IsLocalAtSource P] :\n    HasRingHomProperty P (fun f ‚Ü¶ P (Spec.map (CommRingCat.ofHom f))) where\n  isLocal_ringHomProperty :=\n    isLocal_ringHomProperty_of_isLocalAtSource_of_isLocalAtTarget P\n  eq_affineLocally' := by\n    let Q := affineLocally (fun f ‚Ü¶ P (Spec.map (CommRingCat.ofHom f)))\n    have : HasRingHomProperty Q (fun f ‚Ü¶ P (Spec.map (CommRingCat.ofHom f))) :=\n      ‚ü®isLocal_ringHomProperty_of_isLocalAtSource_of_isLocalAtTarget P, rfl‚ü©\n    show P = Q\n    ext X Y f\n    wlog hY : ‚àÉ R, Y = Spec R generalizing X Y\n    ¬∑ rw [IsLocalAtTarget.iff_of_openCover (P := P) Y.affineCover,\n        IsLocalAtTarget.iff_of_openCover (P := Q) Y.affineCover]\n      refine forall_congr' fun _ ‚Ü¶ this _ ‚ü®_, rfl‚ü©\n    obtain ‚ü®S, rfl‚ü© := hY\n    wlog hX : ‚àÉ R, X = Spec R generalizing X\n    ¬∑ rw [IsLocalAtSource.iff_of_openCover (P := P) X.affineCover,\n        IsLocalAtSource.iff_of_openCover (P := Q) X.affineCover]\n      refine forall_congr' fun _ ‚Ü¶ this _ ‚ü®_, rfl‚ü©\n    obtain ‚ü®R, rfl‚ü© := hX\n    obtain ‚ü®œÜ, rfl‚ü© : ‚àÉ œÜ, Spec.map œÜ = f := ‚ü®_, Spec.map_preimage _‚ü©\n    rw [HasRingHomProperty.Spec_iff (P := Q)]\n    rfl\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.stalkwise","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : {R S : Type u_1} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\nhP : RingHom.RespectsIso P\n‚ä¢ AlgebraicGeometry.HasRingHomProperty (AlgebraicGeometry.stalkwise fun {R S} [CommRing R] [CommRing S] => P) fun {x S} {x_1} {x_2} œÜ => ‚àÄ (p : Ideal S) (x_3 : p.IsPrime), P (Localization.localRingHom (Ideal.comap œÜ p) p œÜ ‚ãØ)","decl":"lemma stalkwise {P} (hP : RingHom.RespectsIso P) :\n    HasRingHomProperty (stalkwise P) fun {_ S _ _} œÜ ‚Ü¶\n      ‚àÄ (p : Ideal S) (_ : p.IsPrime), P (Localization.localRingHom _ p œÜ rfl) := by\n  have := stalkwiseIsLocalAtTarget_of_respectsIso hP\n  have := stalkwise_isLocalAtSource_of_respectsIso hP\n  convert of_isLocalAtSource_of_isLocalAtTarget (P := AlgebraicGeometry.stalkwise P) with R S _ _ œÜ\n  exact (stalkwise_Spec_map_iff hP (CommRingCat.ofHom œÜ)).symm\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.stableUnderComposition","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù : AlgebraicGeometry.HasRingHomProperty P Q\nhP : RingHom.StableUnderComposition fun {R S} [CommRing R] [CommRing S] => Q\n‚ä¢ P.IsStableUnderComposition","decl":"lemma stableUnderComposition (hP : RingHom.StableUnderComposition Q) :\n    P.IsStableUnderComposition where\n  comp_mem {X Y Z} f g hf hg := by\n    wlog hZ : IsAffine Z generalizing X Y Z\n    ¬∑ rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := P) _ (iSup_affineOpens_eq_top _)]\n      intro U\n      rw [morphismRestrict_comp]\n      exact this _ _ (IsLocalAtTarget.restrict hf _) (IsLocalAtTarget.restrict hg _) U.2\n    wlog hY : IsAffine Y generalizing X Y\n    ¬∑ rw [IsLocalAtSource.iff_of_openCover (P := P) (Y.affineCover.pullbackCover f)]\n      intro i\n      rw [‚Üê Scheme.Cover.pullbackHom_map_assoc]\n      exact this _ _ (IsLocalAtTarget.of_isPullback (.of_hasPullback _ _) hf)\n        (comp_of_isOpenImmersion _ _ _ hg) inferInstance\n    wlog hX : IsAffine X generalizing X\n    ¬∑ rw [IsLocalAtSource.iff_of_openCover (P := P) X.affineCover]\n      intro i\n      rw [‚Üê Category.assoc]\n      exact this _ (comp_of_isOpenImmersion _ _ _ hf) inferInstance\n    rw [iff_of_isAffine (P := P)] at hf hg ‚ä¢\n    exact hP _ _ hg hf\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.of_comp","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù : AlgebraicGeometry.HasRingHomProperty P Q\nH : ‚àÄ {R S T : Type u} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : CommRing T] (f : RingHom R S) (g : RingHom S T), Q (g.comp f) ‚Üí Q g\nX Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nh : P (CategoryTheory.CategoryStruct.comp f g)\n‚ä¢ P f","decl":"theorem of_comp\n    (H : ‚àÄ {R S T : Type u} [CommRing R] [CommRing S] [CommRing T],\n      ‚àÄ (f : R ‚Üí+* S) (g : S ‚Üí+* T), Q (g.comp f) ‚Üí Q g)\n    {X Y Z : Scheme.{u}} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} (h : P (f ‚â´ g)) : P f := by\n  wlog hZ : IsAffine Z generalizing X Y Z\n  ¬∑ rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := P) _\n      (g.preimage_iSup_eq_top (iSup_affineOpens_eq_top Z))]\n    intro U\n    have H := IsLocalAtTarget.restrict h U.1\n    rw [morphismRestrict_comp] at H\n    exact this H inferInstance\n  wlog hY : IsAffine Y generalizing X Y\n  ¬∑ rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := P) _ (iSup_affineOpens_eq_top Y)]\n    intro U\n    have H := comp_of_isOpenImmersion P (f ‚Åª¬π·µÅ U.1).Œπ (f ‚â´ g) h\n    rw [‚Üê morphismRestrict_Œπ_assoc] at H\n    exact this H inferInstance\n  wlog hY : IsAffine X generalizing X\n  ¬∑ rw [IsLocalAtSource.iff_of_iSup_eq_top (P := P) _ (iSup_affineOpens_eq_top X)]\n    intro U\n    have H := comp_of_isOpenImmersion P U.1.Œπ (f ‚â´ g) h\n    rw [‚Üê Category.assoc] at H\n    exact this H inferInstance\n  rw [iff_of_isAffine (P := P)] at h ‚ä¢\n  exact H _ _ h\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.isMultiplicative","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù : AlgebraicGeometry.HasRingHomProperty P Q\nhPc : RingHom.StableUnderComposition fun {R S} [CommRing R] [CommRing S] => Q\nhPi : RingHom.ContainsIdentities fun {R S} [CommRing R] [CommRing S] => Q\n‚ä¢ P.IsMultiplicative","decl":"lemma isMultiplicative (hPc : RingHom.StableUnderComposition Q)\n    (hPi : RingHom.ContainsIdentities Q) :\n    P.IsMultiplicative where\n  comp_mem := (stableUnderComposition hPc).comp_mem\n  id_mem := (containsIdentities hPi).id_mem\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.of_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù¬π : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhP : RingHom.ContainsIdentities fun {R S} [CommRing R] [CommRing S] => Q\ninst‚úù : AlgebraicGeometry.IsOpenImmersion f\n‚ä¢ P f","decl":"include Q in\nlemma of_isOpenImmersion (hP : RingHom.ContainsIdentities Q) [IsOpenImmersion f] : P f :=\n  haveI : P.ContainsIdentities := containsIdentities hP\n  IsLocalAtSource.of_isOpenImmersion f\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.isStableUnderBaseChange","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù : AlgebraicGeometry.HasRingHomProperty P Q\nhP : RingHom.IsStableUnderBaseChange fun {R S} [CommRing R] [CommRing S] => Q\n‚ä¢ P.IsStableUnderBaseChange","decl":"lemma isStableUnderBaseChange (hP : RingHom.IsStableUnderBaseChange Q) :\n    P.IsStableUnderBaseChange := by\n  apply HasAffineProperty.isStableUnderBaseChange\n  letI := HasAffineProperty.isLocal_affineProperty P\n  apply AffineTargetMorphismProperty.IsStableUnderBaseChange.mk\n  intros X Y S _ _ f g H\n  rw [‚Üê HasAffineProperty.iff_of_isAffine (P := P)] at H ‚ä¢\n  wlog hX : IsAffine Y generalizing Y\n  ¬∑ rw [IsLocalAtSource.iff_of_openCover (P := P)\n      (Scheme.Pullback.openCoverOfRight Y.affineCover f g)]\n    intro i\n    simp only [Scheme.Pullback.openCoverOfRight_obj, Scheme.Pullback.openCoverOfRight_map,\n      limit.lift_œÄ, PullbackCone.mk_pt, PullbackCone.mk_œÄ_app, Category.comp_id]\n    apply this _ (comp_of_isOpenImmersion _ _ _ H) inferInstance\n  rw [iff_of_isAffine (P := P)] at H ‚ä¢\n  exact hP.pullback_fst_appTop _ (isLocal_ringHomProperty P).respectsIso _ _ H\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.respects_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù : AlgebraicGeometry.HasRingHomProperty P Q\nhQ : RingHom.StableUnderCompositionWithLocalizationAwaySource fun {R S} [CommRing R] [CommRing S] => Q\n‚ä¢ P.Respects @AlgebraicGeometry.IsOpenImmersion","decl":"/-- Any property of scheme morphisms induced by a property of ring homomorphisms is stable\nunder composition with open immersions. -/\nlemma respects_isOpenImmersion (hQ : RingHom.StableUnderCompositionWithLocalizationAwaySource Q) :\n    P.Respects @IsOpenImmersion where\n  postcomp {X Y Z} i hi f hf := by\n    wlog hZ : IsAffine Z generalizing X Y Z\n    ¬∑ rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := P) _ (iSup_affineOpens_eq_top _)]\n      intro U\n      rw [morphismRestrict_comp]\n      exact this _ inferInstance _ (IsLocalAtTarget.restrict hf _) U.2\n    let e : Y ‚âÖ i.opensRange.toScheme := IsOpenImmersion.isoOfRangeEq i i.opensRange.Œπ (by simp)\n    rw [show f ‚â´ i = f ‚â´ e.hom ‚â´ i.opensRange.Œπ by simp [e], ‚Üê Category.assoc]\n    exact respects_isOpenImmersion_aux hQ _ (by rwa [P.cancel_right_of_respectsIso])\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.iff_exists_appLE_locally","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhQ : RingHom.StableUnderCompositionWithLocalizationAwaySource fun {R S} [CommRing R] [CommRing S] => Q\nhQi : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => Q\ninst‚úù : AlgebraicGeometry.HasRingHomProperty P fun {R S} [CommRing R] [CommRing S] => RingHom.Locally fun {R S} [CommRing R] [CommRing S] => Q\n‚ä¢ Iff (P f) (‚àÄ (x : ‚Üë‚ÜëX.toPresheafedSpace), Exists fun U => Exists fun V => Exists fun x => Exists fun e => Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (‚ÜëU) (‚ÜëV) e)))","decl":"omit [HasRingHomProperty P Q] in\n/-- If `P` is induced by `Locally Q`, it suffices to check `Q` on affine open sets locally around\npoints of the source. -/\nlemma iff_exists_appLE_locally\n    (hQ : RingHom.StableUnderCompositionWithLocalizationAwaySource Q)\n    (hQi : RespectsIso Q) [HasRingHomProperty P (Locally Q)] :\n    P f ‚Üî ‚àÄ (x : X), ‚àÉ (U : Y.affineOpens) (V : X.affineOpens) (_ : x ‚àà V.1) (e : V.1 ‚â§ f ‚Åª¬π·µÅ U.1),\n      Q (f.appLE U V e).hom := by\n  have := respects_isOpenImmersion (P := P)\n    (RingHom.locally_StableUnderCompositionWithLocalizationAwaySource hQ)\n  refine ‚ü®fun hf x ‚Ü¶ ?_, fun hf ‚Ü¶ (IsLocalAtSource.iff_exists_resLE (P := P)).mpr <| fun x ‚Ü¶ ?_‚ü©\n  ¬∑ obtain ‚ü®U, hU, hfx, _‚ü© := Opens.isBasis_iff_nbhd.mp (isBasis_affine_open Y)\n      (Opens.mem_top <| f.base x)\n    obtain ‚ü®V, hV, hx, e‚ü© := Opens.isBasis_iff_nbhd.mp (isBasis_affine_open X)\n      (show x ‚àà f ‚Åª¬π·µÅ U from hfx)\n    simp_rw [HasRingHomProperty.iff_appLE (P := P), locally_iff_isLocalization hQi] at hf\n    obtain ‚ü®s, hs, hfs‚ü© := hf ‚ü®U, hU‚ü© ‚ü®V, hV‚ü© e\n    apply iSup_basicOpen_of_span_eq_top at hs\n    have : x ‚àà (‚®Ü i ‚àà s, X.basicOpen i) := hs.symm ‚ñ∏ hx\n    have : ‚àÉ r ‚àà s, x ‚àà X.basicOpen r := by simpa using this\n    obtain ‚ü®r, hr, hrs‚ü© := this\n    refine ‚ü®‚ü®U, hU‚ü©, ‚ü®X.basicOpen r, hV.basicOpen r‚ü©, hrs, (X.basicOpen_le r).trans e, ?_‚ü©\n    rw [‚Üê f.appLE_map e (homOfLE (X.basicOpen_le r)).op]\n    haveI : IsLocalization.Away r Œì(X, X.basicOpen r) := hV.isLocalization_basicOpen r\n    exact hfs r hr _\n  ¬∑ obtain ‚ü®U, V, hxV, e, hf‚ü© := hf x\n    use U, V, hxV, e\n    simp only [iff_of_isAffine (P := P), Scheme.Hom.appLE, homOfLE_leOfHom] at hf ‚ä¢\n    haveI : (toMorphismProperty (Locally Q)).RespectsIso := toMorphismProperty_respectsIso_iff.mp <|\n      (isLocal_ringHomProperty P).respectsIso\n    exact (MorphismProperty.arrow_mk_iso_iff (toMorphismProperty (Locally Q))\n      (arrowResLEAppIso f U V e)).mpr (locally_of hQi _ hf)\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.iff_exists_appLE","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhQ : RingHom.StableUnderCompositionWithLocalizationAwaySource fun {R S} [CommRing R] [CommRing S] => Q\n‚ä¢ Iff (P f) (‚àÄ (x : ‚Üë‚ÜëX.toPresheafedSpace), Exists fun U => Exists fun V => Exists fun x => Exists fun e => Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (‚ÜëU) (‚ÜëV) e)))","decl":"/-- `P` can be checked locally around points of the source. -/\nlemma iff_exists_appLE\n    (hQ : StableUnderCompositionWithLocalizationAwaySource Q) : P f ‚Üî\n    ‚àÄ (x : X), ‚àÉ (U : Y.affineOpens) (V : X.affineOpens) (_ : x ‚àà V.1) (e : V.1 ‚â§ f ‚Åª¬π·µÅ U.1),\n      Q (f.appLE U V e).hom := by\n  haveI inst : HasRingHomProperty P Q := inferInstance\n  haveI : HasRingHomProperty P (Locally Q) := by\n    apply @copy (P' := P) (Q := Q) (Q' := Locally Q)\n    ¬∑ infer_instance\n    ¬∑ rfl\n    ¬∑ intro R S _ _ f\n      exact (locally_iff_of_localizationSpanTarget (isLocal_ringHomProperty P).respectsIso\n        (isLocal_ringHomProperty P).ofLocalizationSpanTarget _).symm\n  rw [iff_exists_appLE_locally (P := P) hQ]\n  haveI : HasRingHomProperty P Q := inst\n  apply (isLocal_ringHomProperty P (Q := Q)).respectsIso\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.locally_of_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\nhQl : RingHom.LocalizationAwayPreserves fun {R S} [CommRing R] [CommRing S] => Q\nhQa : RingHom.StableUnderCompositionWithLocalizationAway fun {R S} [CommRing R] [CommRing S] => Q\nh : ‚àÄ {X Y : AlgebraicGeometry.Scheme} (f : Quiver.Hom X Y), Iff (P f) (‚àÄ (x : ‚Üë‚ÜëX.toPresheafedSpace), Exists fun U => Exists fun V => Exists fun x => Exists fun e => Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (‚ÜëU) (‚ÜëV) e)))\n‚ä¢ AlgebraicGeometry.HasRingHomProperty P fun {R S} [CommRing R] [CommRing S] => RingHom.Locally fun {R S} [CommRing R] [CommRing S] => Q","decl":"omit [HasRingHomProperty P Q] in\nlemma locally_of_iff (hQl : LocalizationAwayPreserves Q)\n    (hQa : StableUnderCompositionWithLocalizationAway Q)\n    (h : ‚àÄ {X Y : Scheme.{u}} (f : X ‚ü∂ Y), P f ‚Üî\n      ‚àÄ (x : X), ‚àÉ (U : Y.affineOpens) (V : X.affineOpens) (_ : x ‚àà V.1) (e : V.1 ‚â§ f ‚Åª¬π·µÅ U.1),\n      Q (f.appLE U V e).hom) : HasRingHomProperty P (Locally Q) where\n  isLocal_ringHomProperty := locally_propertyIsLocal hQl hQa\n  eq_affineLocally' := by\n    haveI : HasRingHomProperty (affineLocally (Locally Q)) (Locally Q) :=\n      ‚ü®locally_propertyIsLocal hQl hQa, rfl‚ü©\n    ext X Y f\n    rw [h, iff_exists_appLE_locally (P := affineLocally (Locally Q)) hQa.left hQa.respectsIso]\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.of_stalkMap","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhQ : RingHom.OfLocalizationPrime fun {R S} [CommRing R] [CommRing S] => Q\nH : ‚àÄ (x : ‚Üë‚ÜëX.toPresheafedSpace), Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.stalkMap f x))\n‚ä¢ P f","decl":"/-- If `Q` is a property of ring maps that can be checked on prime ideals, the\nassociated property of scheme morphisms can be checked on stalks. -/\nlemma of_stalkMap (hQ : OfLocalizationPrime Q) (H : ‚àÄ x, Q (f.stalkMap x).hom) : P f := by\n  have hQi := (HasRingHomProperty.isLocal_ringHomProperty P).respectsIso\n  wlog hY : IsAffine Y generalizing X Y f\n  ¬∑ rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := P) _ (iSup_affineOpens_eq_top _)]\n    intro U\n    refine this (fun x ‚Ü¶ ?_) U.2\n    exact (hQi.arrow_mk_iso_iff (AlgebraicGeometry.morphismRestrictStalkMap f U x)).mpr (H x.val)\n  wlog hX : IsAffine X generalizing X f\n  ¬∑ rw [IsLocalAtSource.iff_of_iSup_eq_top (P := P) _ (iSup_affineOpens_eq_top _)]\n    intro U\n    refine this ?_ U.2\n    intro x\n    rw [Scheme.stalkMap_comp, CommRingCat.hom_comp, hQi.cancel_right_isIso]\n    exact H x.val\n  wlog hXY : ‚àÉ R S, Y = Spec R ‚àß X = Spec S generalizing X Y\n  ¬∑ rw [‚Üê P.cancel_right_of_respectsIso (g := Y.isoSpec.hom)]\n    rw [‚Üê P.cancel_left_of_respectsIso (f := X.isoSpec.inv)]\n    refine this inferInstance (fun x ‚Ü¶ ?_) inferInstance ?_\n    ¬∑ rw [Scheme.stalkMap_comp, Scheme.stalkMap_comp, CommRingCat.hom_comp,\n        hQi.cancel_right_isIso, CommRingCat.hom_comp, hQi.cancel_left_isIso]\n      apply H\n    ¬∑ use Œì(Y, ‚ä§), Œì(X, ‚ä§)\n  obtain ‚ü®R, S, rfl, rfl‚ü© := hXY\n  obtain ‚ü®œÜ, rfl‚ü© := Spec.map_surjective f\n  rw [Spec_iff (P := P)]\n  apply hQ\n  intro P hP\n  specialize H ‚ü®P, hP‚ü©\n  rwa [hQi.arrow_mk_iso_iff (Scheme.arrowStalkMapSpecIso œÜ _)] at H\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.stalkMap","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} ‚Üí [inst : CommRing R] ‚Üí [inst_1 : CommRing S] ‚Üí RingHom R S ‚Üí Prop\ninst‚úù : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhQ : ‚àÄ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (f : RingHom R S), Q f ‚Üí ‚àÄ (J : Ideal S) (x : J.IsPrime), Q (Localization.localRingHom (Ideal.comap f J) J f ‚ãØ)\nhf : P f\nx : ‚Üë‚ÜëX.toPresheafedSpace\n‚ä¢ Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.stalkMap f x))","decl":"/-- Let `Q` be a property of ring maps that is stable under localization.\nThen if the associated property of scheme morphisms holds for `f`, `Q` holds on all stalks. -/\nlemma stalkMap\n      (hQ : ‚àÄ {R S : Type u} [CommRing R] [CommRing S] (f : R ‚Üí+* S) (_ : Q f)\n        (J : Ideal S) (_ : J.IsPrime), Q (Localization.localRingHom _ J f rfl))\n      (hf : P f) (x : X) : Q (f.stalkMap x).hom := by\n  have hQi := (HasRingHomProperty.isLocal_ringHomProperty P).respectsIso\n  wlog h : IsAffine X ‚àß IsAffine Y generalizing X Y f\n  ¬∑ obtain ‚ü®U, hU, hfx, _‚ü© := Opens.isBasis_iff_nbhd.mp (isBasis_affine_open Y)\n      (Opens.mem_top <| f.base x)\n    obtain ‚ü®V, hV, hx, e‚ü© := Opens.isBasis_iff_nbhd.mp (isBasis_affine_open X)\n      (show x ‚àà f ‚Åª¬π·µÅ U from hfx)\n    rw [‚Üê hQi.arrow_mk_iso_iff (Scheme.Hom.resLEStalkMap f e ‚ü®x, hx‚ü©)]\n    exact this (IsLocalAtSource.resLE _ hf) _ ‚ü®hV, hU‚ü©\n  obtain ‚ü®hX, hY‚ü© := h\n  wlog hXY : ‚àÉ R S, Y = Spec R ‚àß X = Spec S generalizing X Y\n  ¬∑ have : Q ((X.isoSpec.inv ‚â´ f ‚â´ Y.isoSpec.hom).stalkMap (X.isoSpec.hom.base x)).hom := by\n      refine this ?_ (X.isoSpec.hom.base x) inferInstance inferInstance ?_\n      ¬∑ rwa [P.cancel_left_of_respectsIso, P.cancel_right_of_respectsIso]\n      ¬∑ use Œì(Y, ‚ä§), Œì(X, ‚ä§)\n    rw [Scheme.stalkMap_comp, Scheme.stalkMap_comp, CommRingCat.hom_comp,\n      hQi.cancel_right_isIso, CommRingCat.hom_comp, hQi.cancel_left_isIso] at this\n    have heq : (X.isoSpec.inv.base (X.isoSpec.hom.base x)) = x := by simp\n    rwa [hQi.arrow_mk_iso_iff\n      (Scheme.arrowStalkMapIsoOfEq f heq)] at this\n  obtain ‚ü®R, S, rfl, rfl‚ü© := hXY\n  obtain ‚ü®œÜ, rfl‚ü© := Spec.map_surjective f\n  rw [hQi.arrow_mk_iso_iff (Scheme.arrowStalkMapSpecIso œÜ _)]\n  rw [Spec_iff (P := P)] at hf\n  apply hQ _ hf\n\n"}
