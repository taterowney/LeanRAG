{"name":"RingHom.IsStableUnderBaseChange.pullback_fst_appTop","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.IsStableUnderBaseChange fun {R S} [CommRing R] [CommRing S] => P\nhP' : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nX Y S : AlgebraicGeometry.Scheme\ninst✝² : AlgebraicGeometry.IsAffine X\ninst✝¹ : AlgebraicGeometry.IsAffine Y\ninst✝ : AlgebraicGeometry.IsAffine S\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH : P (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appTop g))\n⊢ P (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appTop (CategoryTheory.Limits.pullback.fst f g)))","decl":"theorem IsStableUnderBaseChange.pullback_fst_appTop\n    (hP : IsStableUnderBaseChange P) (hP' : RespectsIso P)\n    {X Y S : Scheme} [IsAffine X] [IsAffine Y] [IsAffine S] (f : X ⟶ S) (g : Y ⟶ S)\n    (H : P g.appTop.hom) : P (pullback.fst f g).appTop.hom := by\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11224): change `rw` to `erw`\n  erw [← PreservesPullback.iso_inv_fst AffineScheme.forgetToScheme (AffineScheme.ofHom f)\n      (AffineScheme.ofHom g)]\n  rw [Scheme.comp_appTop, CommRingCat.hom_comp, hP'.cancel_right_isIso,\n    AffineScheme.forgetToScheme_map]\n  have := congr_arg Quiver.Hom.unop\n      (PreservesPullback.iso_hom_fst AffineScheme.Γ.rightOp (AffineScheme.ofHom f)\n        (AffineScheme.ofHom g))\n  simp only [AffineScheme.Γ, Functor.rightOp_obj, Functor.comp_obj, Functor.op_obj, unop_comp,\n    AffineScheme.forgetToScheme_obj, Scheme.Γ_obj, Functor.rightOp_map, Functor.comp_map,\n    Functor.op_map, Quiver.Hom.unop_op, AffineScheme.forgetToScheme_map, Scheme.Γ_map] at this\n  rw [← this, CommRingCat.hom_comp, hP'.cancel_right_isIso, ← pushoutIsoUnopPullback_inl_hom,\n    CommRingCat.hom_comp, hP'.cancel_right_isIso]\n  exact hP.pushout_inl _ hP' _ _ H\n\n"}
{"name":"RingHom.IsStableUnderBaseChange.pullback_fst_app_top","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.IsStableUnderBaseChange fun {R S} [CommRing R] [CommRing S] => P\nhP' : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nX Y S : AlgebraicGeometry.Scheme\ninst✝² : AlgebraicGeometry.IsAffine X\ninst✝¹ : AlgebraicGeometry.IsAffine Y\ninst✝ : AlgebraicGeometry.IsAffine S\nf : Quiver.Hom X S\ng : Quiver.Hom Y S\nH : P (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appTop g))\n⊢ P (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appTop (CategoryTheory.Limits.pullback.fst f g)))","decl":"@[deprecated (since := \"2024-11-23\")]\nalias IsStableUnderBaseChange.pullback_fst_app_top :=\nIsStableUnderBaseChange.pullback_fst_appTop\n\n"}
{"name":"AlgebraicGeometry.sourceAffineLocally_respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nh₁ : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\n⊢ (AlgebraicGeometry.sourceAffineLocally fun {R S} [CommRing R] [CommRing S] => P).toProperty.RespectsIso","decl":"theorem sourceAffineLocally_respectsIso (h₁ : RingHom.RespectsIso P) :\n    (sourceAffineLocally P).toProperty.RespectsIso := by\n  apply AffineTargetMorphismProperty.respectsIso_mk\n  · introv H U\n    have : IsIso (e.hom.appLE (e.hom ''ᵁ U) U.1 (e.hom.preimage_image_eq _).ge) :=\n      inferInstanceAs (IsIso (e.hom.app _ ≫\n        X.presheaf.map (eqToHom (e.hom.preimage_image_eq _).symm).op))\n    rw [← Scheme.appLE_comp_appLE _ _ ⊤ (e.hom ''ᵁ U) U.1 le_top (e.hom.preimage_image_eq _).ge,\n      CommRingCat.hom_comp, h₁.cancel_right_isIso]\n    exact H ⟨_, U.prop.image_of_isOpenImmersion e.hom⟩\n  · introv H U\n    rw [Scheme.comp_appLE, CommRingCat.hom_comp, h₁.cancel_left_isIso]\n    exact H U\n\n"}
{"name":"AlgebraicGeometry.affineLocally_respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nh : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\n⊢ (AlgebraicGeometry.affineLocally fun {R S} [CommRing R] [CommRing S] => P).RespectsIso","decl":"theorem affineLocally_respectsIso (h : RingHom.RespectsIso P) : (affineLocally P).RespectsIso :=\n  letI := sourceAffineLocally_respectsIso P h\n  inferInstance\n\n"}
{"name":"AlgebraicGeometry.sourceAffineLocally_morphismRestrict","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nhU : AlgebraicGeometry.IsAffineOpen U\n⊢ Iff (AlgebraicGeometry.sourceAffineLocally (fun {R S} [CommRing R] [CommRing S] => P) (AlgebraicGeometry.morphismRestrict f U)) (∀ (V : ↑X.affineOpens) (e : LE.le (↑V) ((TopologicalSpace.Opens.map f.base).obj U)), P (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f U (↑V) e)))","decl":"open Scheme in\ntheorem sourceAffineLocally_morphismRestrict {X Y : Scheme.{u}} (f : X ⟶ Y)\n    (U : Y.Opens) (hU : IsAffineOpen U) :\n    @sourceAffineLocally P _ _ (f ∣_ U) hU ↔\n      ∀ (V : X.affineOpens) (e : V.1 ≤ f ⁻¹ᵁ U), P (f.appLE U V e).hom := by\n  dsimp only [sourceAffineLocally]\n  simp only [morphismRestrict_appLE]\n  rw [(affineOpensRestrict (f ⁻¹ᵁ U)).forall_congr_left, Subtype.forall]\n  refine forall₂_congr fun V h ↦ ?_\n  have := (affineOpensRestrict (f ⁻¹ᵁ U)).apply_symm_apply ⟨V, h⟩\n  exact f.appLE_congr _ (Opens.ι_image_top _) congr($(this).1.1) (fun f => P f.hom)\n\n"}
{"name":"AlgebraicGeometry.affineLocally_iff_affineOpens_le","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n⊢ Iff (AlgebraicGeometry.affineLocally (fun {R S} [CommRing R] [CommRing S] => P) f) (∀ (U : ↑Y.affineOpens) (V : ↑X.affineOpens) (e : LE.le (↑V) ((TopologicalSpace.Opens.map f.base).obj ↑U)), P (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (↑U) (↑V) e)))","decl":"theorem affineLocally_iff_affineOpens_le {X Y : Scheme.{u}} (f : X ⟶ Y) :\n    affineLocally.{u} P f ↔\n      ∀ (U : Y.affineOpens) (V : X.affineOpens) (e : V.1 ≤ f ⁻¹ᵁ U.1), P (f.appLE U V e).hom :=\n  forall_congr' fun U ↦ sourceAffineLocally_morphismRestrict P f U U.2\n\n"}
{"name":"AlgebraicGeometry.sourceAffineLocally_isLocal","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nh₁ : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => P\nh₂ : RingHom.LocalizationAwayPreserves fun {R S} [CommRing R] [CommRing S] => P\nh₃ : RingHom.OfLocalizationSpan fun {R S} [CommRing R] [CommRing S] => P\n⊢ (AlgebraicGeometry.sourceAffineLocally fun {R S} [CommRing R] [CommRing S] => P).IsLocal","decl":"theorem sourceAffineLocally_isLocal (h₁ : RingHom.RespectsIso P)\n    (h₂ : RingHom.LocalizationAwayPreserves P) (h₃ : RingHom.OfLocalizationSpan P) :\n    (sourceAffineLocally P).IsLocal := by\n  constructor\n  · exact sourceAffineLocally_respectsIso P h₁\n  · intro X Y _ f r H\n    rw [sourceAffineLocally_morphismRestrict]\n    intro U hU\n    have : X.basicOpen (f.appLE ⊤ U (by simp) r) = U := by\n      simp only [Scheme.Hom.appLE, Opens.map_top, CommRingCat.comp_apply, RingHom.coe_comp,\n        Function.comp_apply]\n      rw [Scheme.basicOpen_res]\n      simpa using hU\n    rw [← f.appLE_congr _ rfl this (fun f => P f.hom),\n      IsAffineOpen.appLE_eq_away_map f (isAffineOpen_top Y) U.2 _ r]\n    simp only [CommRingCat.hom_ofHom]\n    apply (config := { allowSynthFailures := true }) h₂\n    exact H U\n  · introv hs hs' U\n    apply h₃ _ _ hs\n    intro r\n    simp_rw [sourceAffineLocally_morphismRestrict] at hs'\n    have := hs' r ⟨X.basicOpen (f.appLE ⊤ U le_top r.1), U.2.basicOpen (f.appLE ⊤ U le_top r.1)⟩\n      (by simp [Scheme.Hom.appLE])\n    rwa [IsAffineOpen.appLE_eq_away_map f (isAffineOpen_top Y) U.2, CommRingCat.hom_ofHom,\n      ← h₁.is_localization_away_iff] at this\n\n"}
{"name":"AlgebraicGeometry.affineLocally_le","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P Q : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhPQ : ∀ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] {f : RingHom R S}, P f → Q f\n⊢ LE.le (AlgebraicGeometry.affineLocally fun {R S} [CommRing R] [CommRing S] => P) (AlgebraicGeometry.affineLocally fun {R S} [CommRing R] [CommRing S] => Q)","decl":"lemma affineLocally_le {Q : ∀ {R S : Type u} [CommRing R] [CommRing S], (R →+* S) → Prop}\n    (hPQ : ∀ {R S : Type u} [CommRing R] [CommRing S] {f : R →+* S}, P f → Q f) :\n    affineLocally P ≤ affineLocally Q :=\n  fun _ _ _ hf U V ↦ hPQ (hf U V)\n\n"}
{"name":"AlgebraicGeometry.exists_basicOpen_le_appLE_of_appLE_of_isAffine","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhPa : RingHom.StableUnderCompositionWithLocalizationAwayTarget fun {R S} [CommRing R] [CommRing S] => P\nhPl : RingHom.LocalizationAwayPreserves fun {R S} [CommRing R] [CommRing S] => P\nx : ↑↑X.toPresheafedSpace\nU₁ U₂ : ↑Y.affineOpens\nV₁ V₂ : ↑X.affineOpens\nhx₁ : Membership.mem (↑V₁) x\nhx₂ : Membership.mem (↑V₂) x\ne₂ : LE.le (↑V₂) ((TopologicalSpace.Opens.map f.base).obj ↑U₂)\nh₂ : P (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (↑U₂) (↑V₂) e₂))\nhfx₁ : Membership.mem (↑U₁) (f.base x)\n⊢ Exists fun r => Exists fun s => Exists fun x => Exists fun e => P (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (Y.basicOpen r) (X.basicOpen s) e))","decl":"/-- If `P` holds for `f` over affine opens `U₂` of `Y` and `V₂` of `X` and `U₁` (resp. `V₁`) are\nopen affine neighborhoods of `x` (resp. `f.base x`), then `P` also holds for `f`\nover some basic open of `U₁` (resp. `V₁`). -/\nlemma exists_basicOpen_le_appLE_of_appLE_of_isAffine\n    (hPa : StableUnderCompositionWithLocalizationAwayTarget P) (hPl : LocalizationAwayPreserves P)\n    (x : X) (U₁ : Y.affineOpens) (U₂ : Y.affineOpens) (V₁ : X.affineOpens) (V₂ : X.affineOpens)\n    (hx₁ : x ∈ V₁.1) (hx₂ : x ∈ V₂.1) (e₂ : V₂.1 ≤ f ⁻¹ᵁ U₂.1) (h₂ : P (f.appLE U₂ V₂ e₂).hom)\n    (hfx₁ : f.base x ∈ U₁.1) :\n    ∃ (r : Γ(Y, U₁)) (s : Γ(X, V₁)) (_ : x ∈ X.basicOpen s)\n      (e : X.basicOpen s ≤ f ⁻¹ᵁ Y.basicOpen r),\n        P (f.appLE (Y.basicOpen r) (X.basicOpen s) e).hom := by\n  obtain ⟨r, r', hBrr', hBfx⟩ := exists_basicOpen_le_affine_inter U₁.2 U₂.2 (f.base x)\n    ⟨hfx₁, e₂ hx₂⟩\n  have ha : IsAffineOpen (X.basicOpen (f.appLE U₂ V₂ e₂ r')) := V₂.2.basicOpen _\n  have hxa : x ∈ X.basicOpen (f.appLE U₂ V₂ e₂ r') := by\n    simpa [Scheme.Hom.appLE, ← Scheme.preimage_basicOpen] using And.intro hx₂ (hBrr' ▸ hBfx)\n  obtain ⟨s, s', hBss', hBx⟩ := exists_basicOpen_le_affine_inter V₁.2 ha x ⟨hx₁, hxa⟩\n  haveI := V₂.2.isLocalization_basicOpen (f.appLE U₂ V₂ e₂ r')\n  haveI := U₂.2.isLocalization_basicOpen r'\n  haveI := ha.isLocalization_basicOpen s'\n  have ers : X.basicOpen s ≤ f ⁻¹ᵁ Y.basicOpen r := by\n    rw [hBss', hBrr']\n    apply le_trans (X.basicOpen_le _)\n    simp [Scheme.Hom.appLE]\n  have heq : f.appLE (Y.basicOpen r') (X.basicOpen s') (hBrr' ▸ hBss' ▸ ers) =\n      f.appLE (Y.basicOpen r') (X.basicOpen (f.appLE U₂ V₂ e₂ r')) (by simp [Scheme.Hom.appLE]) ≫\n        CommRingCat.ofHom (algebraMap _ _) := by\n    simp only [Scheme.Hom.appLE, homOfLE_leOfHom, CommRingCat.comp_apply, Category.assoc]\n    congr\n    apply X.presheaf.map_comp\n  refine ⟨r, s, hBx, ers, ?_⟩\n  · rw [f.appLE_congr _ hBrr' hBss' (fun f => P f.hom), heq]\n    apply hPa _ s' _\n    rw [U₂.2.appLE_eq_away_map f V₂.2]\n    exact hPl _ _ _ _ h₂\n\n"}
{"name":"AlgebraicGeometry.exists_affineOpens_le_appLE_of_appLE","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhPa : RingHom.StableUnderCompositionWithLocalizationAwayTarget fun {R S} [CommRing R] [CommRing S] => P\nhPl : RingHom.LocalizationAwayPreserves fun {R S} [CommRing R] [CommRing S] => P\nx : ↑↑X.toPresheafedSpace\nU₁ : Y.Opens\nU₂ : ↑Y.affineOpens\nV₁ : X.Opens\nV₂ : ↑X.affineOpens\nhx₁ : Membership.mem V₁ x\nhx₂ : Membership.mem (↑V₂) x\ne₂ : LE.le (↑V₂) ((TopologicalSpace.Opens.map f.base).obj ↑U₂)\nh₂ : P (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (↑U₂) (↑V₂) e₂))\nhfx₁ : Membership.mem U₁.carrier (f.base x)\n⊢ Exists fun U' => Exists fun V' => Exists fun x_1 => Exists fun x_2 => Exists fun x => Exists fun e => P (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (↑U') (↑V') e))","decl":"/-- If `P` holds for `f` over affine opens `U₂` of `Y` and `V₂` of `X` and `U₁` (resp. `V₁`) are\nopen neighborhoods of `x` (resp. `f.base x`), then `P` also holds for `f` over some affine open\n`U'` of `Y` (resp. `V'` of `X`) that is contained in `U₁` (resp. `V₁`). -/\nlemma exists_affineOpens_le_appLE_of_appLE\n    (hPa : StableUnderCompositionWithLocalizationAwayTarget P) (hPl : LocalizationAwayPreserves P)\n    (x : X) (U₁ : Y.Opens) (U₂ : Y.affineOpens) (V₁ : X.Opens) (V₂ : X.affineOpens)\n    (hx₁ : x ∈ V₁) (hx₂ : x ∈ V₂.1) (e₂ : V₂.1 ≤ f ⁻¹ᵁ U₂.1) (h₂ : P (f.appLE U₂ V₂ e₂).hom)\n    (hfx₁ : f.base x ∈ U₁.1) :\n    ∃ (U' : Y.affineOpens) (V' : X.affineOpens) (_ : U'.1 ≤ U₁) (_ : V'.1 ≤ V₁) (_ : x ∈ V'.1)\n      (e : V'.1 ≤ f⁻¹ᵁ U'.1), P (f.appLE U' V' e).hom := by\n  obtain ⟨r, hBr, hBfx⟩ := U₂.2.exists_basicOpen_le ⟨f.base x, hfx₁⟩ (e₂ hx₂)\n  obtain ⟨s, hBs, hBx⟩ := V₂.2.exists_basicOpen_le ⟨x, hx₁⟩ hx₂\n  obtain ⟨r', s', hBx', e', hf'⟩ := exists_basicOpen_le_appLE_of_appLE_of_isAffine hPa hPl x\n    ⟨Y.basicOpen r, U₂.2.basicOpen _⟩ U₂ ⟨X.basicOpen s, V₂.2.basicOpen _⟩ V₂ hBx hx₂ e₂ h₂ hBfx\n  exact ⟨⟨Y.basicOpen r', (U₂.2.basicOpen _).basicOpen _⟩,\n    ⟨X.basicOpen s', (V₂.2.basicOpen _).basicOpen _⟩, le_trans (Y.basicOpen_le _) hBr,\n    le_trans (X.basicOpen_le _) hBs, hBx', e', hf'⟩\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.isLocal_ringHomProperty","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : outParam ({R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop)\nself : AlgebraicGeometry.HasRingHomProperty P Q\n⊢ RingHom.PropertyIsLocal fun {R S} [CommRing R] [CommRing S] => Q","decl":"/--\n`HasRingHomProperty P Q` is a type class asserting that `P` is local at the target and the source,\nand for `f : Spec B ⟶ Spec A`, it is equivalent to the ring hom property `Q`.\nTo make the proofs easier, we state it instead as\n1. `Q` is local (See `RingHom.PropertyIsLocal`)\n2. `P f` if and only if `Q` holds for every `Γ(Y, U) ⟶ Γ(X, V)` for all affine `U`, `V`.\nSee `HasRingHomProperty.iff_appLE`.\n-/\nclass HasRingHomProperty (P : MorphismProperty Scheme.{u})\n    (Q : outParam (∀ {R S : Type u} [CommRing R] [CommRing S], (R →+* S) → Prop)) : Prop where\n  isLocal_ringHomProperty : RingHom.PropertyIsLocal Q\n  eq_affineLocally' : P = affineLocally Q\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.eq_affineLocally'","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : outParam ({R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop)\nself : AlgebraicGeometry.HasRingHomProperty P Q\n⊢ Eq P (AlgebraicGeometry.affineLocally fun {R S} [CommRing R] [CommRing S] => Q)","decl":"/--\n`HasRingHomProperty P Q` is a type class asserting that `P` is local at the target and the source,\nand for `f : Spec B ⟶ Spec A`, it is equivalent to the ring hom property `Q`.\nTo make the proofs easier, we state it instead as\n1. `Q` is local (See `RingHom.PropertyIsLocal`)\n2. `P f` if and only if `Q` holds for every `Γ(Y, U) ⟶ Γ(X, V)` for all affine `U`, `V`.\nSee `HasRingHomProperty.iff_appLE`.\n-/\nclass HasRingHomProperty (P : MorphismProperty Scheme.{u})\n    (Q : outParam (∀ {R S : Type u} [CommRing R] [CommRing S], (R →+* S) → Prop)) : Prop where\n  isLocal_ringHomProperty : RingHom.PropertyIsLocal Q\n  eq_affineLocally' : P = affineLocally Q\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.copy","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝ : AlgebraicGeometry.HasRingHomProperty P Q\nP' : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ' : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ne : Eq P P'\ne' : ∀ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (f : RingHom R S), Iff (Q f) (Q' f)\n⊢ AlgebraicGeometry.HasRingHomProperty P' fun {R S} [CommRing R] [CommRing S] => Q'","decl":"lemma copy {P' : MorphismProperty Scheme.{u}}\n    {Q' : ∀ {R S : Type u} [CommRing R] [CommRing S], (R →+* S) → Prop}\n    (e : P = P') (e' : ∀ {R S : Type u} [CommRing R] [CommRing S] (f : R →+* S), Q f ↔ Q' f) :\n    HasRingHomProperty P' Q' := by\n  subst e\n  have heq : @Q = @Q' := by\n    ext R S _ _ f\n    exact (e' f)\n  rw [← heq]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.eq_affineLocally","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝ : AlgebraicGeometry.HasRingHomProperty P Q\n⊢ Eq P (AlgebraicGeometry.affineLocally fun {R S} [CommRing R] [CommRing S] => Q)","decl":"lemma eq_affineLocally : P = affineLocally Q := eq_affineLocally'\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.HasAffineProperty","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝ : AlgebraicGeometry.HasRingHomProperty P Q\n⊢ AlgebraicGeometry.HasAffineProperty P (AlgebraicGeometry.sourceAffineLocally fun {R S} [CommRing R] [CommRing S] => Q)","decl":"@[local instance]\nlemma HasAffineProperty : HasAffineProperty P (sourceAffineLocally Q) where\n  isLocal_affineProperty := sourceAffineLocally_isLocal _\n    (isLocal_ringHomProperty P).respectsIso\n    (isLocal_ringHomProperty P).localizationAwayPreserves\n    (isLocal_ringHomProperty P).ofLocalizationSpan\n  eq_targetAffineLocally' := eq_affineLocally P\n\n/- This is only `inferInstance` because of the `@[local instance]` on `HasAffineProperty` above. -/\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.instIsLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝ : AlgebraicGeometry.HasRingHomProperty P Q\n⊢ AlgebraicGeometry.IsLocalAtTarget P","decl":"instance (priority := 900) : IsLocalAtTarget P := inferInstance\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.appLE","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝ : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nH : P f\nU : ↑Y.affineOpens\nV : ↑X.affineOpens\ne : LE.le (↑V) ((TopologicalSpace.Opens.map f.base).obj ↑U)\n⊢ Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (↑U) (↑V) e))","decl":"theorem appLE (H : P f) (U : Y.affineOpens) (V : X.affineOpens) (e) : Q (f.appLE U V e).hom := by\n  rw [eq_affineLocally P, affineLocally_iff_affineOpens_le] at H\n  exact H _ _ _\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.appTop","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝² : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nH : P f\ninst✝¹ : AlgebraicGeometry.IsAffine X\ninst✝ : AlgebraicGeometry.IsAffine Y\n⊢ Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appTop f))","decl":"theorem appTop (H : P f) [IsAffine X] [IsAffine Y] : Q f.appTop.hom := by\n  rw [Scheme.Hom.appTop, Scheme.Hom.app_eq_appLE]\n  exact appLE P f H ⟨_, isAffineOpen_top _⟩ ⟨_, isAffineOpen_top _⟩ _\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.app_top","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝² : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nH : P f\ninst✝¹ : AlgebraicGeometry.IsAffine X\ninst✝ : AlgebraicGeometry.IsAffine Y\n⊢ Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appTop f))","decl":"@[deprecated (since := \"2024-11-23\")] alias app_top := appTop\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.comp_of_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝¹ : AlgebraicGeometry.HasRingHomProperty P Q\nX Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nH : P g\n⊢ P (CategoryTheory.CategoryStruct.comp f g)","decl":"include Q in\ntheorem comp_of_isOpenImmersion [IsOpenImmersion f] (H : P g) :\n    P (f ≫ g) := by\n  rw [eq_affineLocally P, affineLocally_iff_affineOpens_le] at H ⊢\n  intro U V e\n  have : IsIso (f.appLE (f ''ᵁ V) V.1 (f.preimage_image_eq _).ge) :=\n    inferInstanceAs (IsIso (f.app _ ≫\n      X.presheaf.map (eqToHom (f.preimage_image_eq _).symm).op))\n  rw [← Scheme.appLE_comp_appLE _ _ _ (f ''ᵁ V) V.1\n    (Set.image_subset_iff.mpr e) (f.preimage_image_eq _).ge,\n    CommRingCat.hom_comp,\n    (isLocal_ringHomProperty P).respectsIso.cancel_right_isIso]\n  exact H _ ⟨_, V.2.image_of_isOpenImmersion _⟩ _\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.iff_appLE","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝ : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\n⊢ Iff (P f) (∀ (U : ↑Y.affineOpens) (V : ↑X.affineOpens) (e : LE.le (↑V) ((TopologicalSpace.Opens.map f.base).obj ↑U)), Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (↑U) (↑V) e)))","decl":"lemma iff_appLE : P f ↔ ∀ (U : Y.affineOpens) (V : X.affineOpens) (e), Q (f.appLE U V e).hom := by\n  rw [eq_affineLocally P, affineLocally_iff_affineOpens_le]\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.of_source_openCover","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝² : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝¹ : AlgebraicGeometry.IsAffine Y\n𝒰 : X.OpenCover\ninst✝ : ∀ (i : 𝒰.J), AlgebraicGeometry.IsAffine (𝒰.obj i)\nH : ∀ (i : 𝒰.J), Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appTop (CategoryTheory.CategoryStruct.comp (𝒰.map i) f)))\n⊢ P f","decl":"theorem of_source_openCover [IsAffine Y]\n    (𝒰 : X.OpenCover) [∀ i, IsAffine (𝒰.obj i)] (H : ∀ i, Q ((𝒰.map i ≫ f).appTop.hom)) :\n    P f := by\n  rw [HasAffineProperty.iff_of_isAffine (P := P)]\n  intro U\n  let S i : X.affineOpens := ⟨_, isAffineOpen_opensRange (𝒰.map i)⟩\n  induction U using of_affine_open_cover S 𝒰.iSup_opensRange with\n  | basicOpen U r H =>\n    simp_rw [Scheme.affineBasicOpen_coe,\n      ← f.appLE_map (U := ⊤) le_top (homOfLE (X.basicOpen_le r)).op]\n    have := U.2.isLocalization_basicOpen r\n    exact (isLocal_ringHomProperty P).StableUnderCompositionWithLocalizationAwayTarget _ r _ H\n  | openCover U s hs H =>\n    apply (isLocal_ringHomProperty P).ofLocalizationSpanTarget.ofIsLocalization\n      (isLocal_ringHomProperty P).respectsIso _ _ hs\n    rintro r\n    refine ⟨_, _, _, IsAffineOpen.isLocalization_basicOpen U.2 r, ?_⟩\n    rw [RingHom.algebraMap_toAlgebra, ← CommRingCat.hom_comp, Scheme.Hom.appLE_map]\n    exact H r\n  | hU i =>\n    specialize H i\n    rw [← (isLocal_ringHomProperty P).respectsIso.cancel_right_isIso _\n      ((IsOpenImmersion.isoOfRangeEq (𝒰.map i) (S i).1.ι\n      Subtype.range_coe.symm).inv.app _), ← CommRingCat.hom_comp, ← Scheme.comp_appTop,\n      IsOpenImmersion.isoOfRangeEq_inv_fac_assoc, Scheme.comp_appTop,\n      Scheme.Opens.ι_appTop, Scheme.Hom.appTop, Scheme.Hom.app_eq_appLE, Scheme.Hom.appLE_map] at H\n    exact (f.appLE_congr _ rfl (by simp) (fun f => Q f.hom)).mp H\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.iff_of_source_openCover","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝² : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝¹ : AlgebraicGeometry.IsAffine Y\n𝒰 : X.OpenCover\ninst✝ : ∀ (i : 𝒰.J), AlgebraicGeometry.IsAffine (𝒰.obj i)\n⊢ Iff (P f) (∀ (i : 𝒰.J), Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appTop (CategoryTheory.CategoryStruct.comp (𝒰.map i) f))))","decl":"theorem iff_of_source_openCover [IsAffine Y] (𝒰 : X.OpenCover) [∀ i, IsAffine (𝒰.obj i)] :\n    P f ↔ ∀ i, Q ((𝒰.map i ≫ f).appTop).hom :=\n  ⟨fun H i ↦ appTop P _ (comp_of_isOpenImmersion P (𝒰.map i) f H), of_source_openCover 𝒰⟩\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.iff_of_isAffine","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝² : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝¹ : AlgebraicGeometry.IsAffine X\ninst✝ : AlgebraicGeometry.IsAffine Y\n⊢ Iff (P f) (Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appTop f)))","decl":"theorem iff_of_isAffine [IsAffine X] [IsAffine Y] :\n    P f ↔ Q (f.appTop).hom := by\n  rw [iff_of_source_openCover (P := P) (Scheme.coverOfIsIso.{u} (𝟙 _))]\n  simp\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.Spec_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝ : AlgebraicGeometry.HasRingHomProperty P Q\nR S : CommRingCat\nφ : Quiver.Hom R S\n⊢ Iff (P (AlgebraicGeometry.Spec.map φ)) (Q (CommRingCat.Hom.hom φ))","decl":"theorem Spec_iff {R S : CommRingCat.{u}} {φ : R ⟶ S} :\n    P (Spec.map φ) ↔ Q φ.hom := by\n  have H := (isLocal_ringHomProperty P).respectsIso\n  rw [iff_of_isAffine (P := P), ← H.cancel_right_isIso _ (Scheme.ΓSpecIso _).hom,\n    ← CommRingCat.hom_comp, Scheme.ΓSpecIso_naturality, CommRingCat.hom_comp, H.cancel_left_isIso]\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.of_iSup_eq_top","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝¹ : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsAffine Y\nι : Type u_1\nU : ι → ↑X.affineOpens\nhU : Eq (iSup fun i => ↑(U i)) Top.top\nH : ∀ (i : ι), Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f Top.top ↑(U i) ⋯))\n⊢ P f","decl":"theorem of_iSup_eq_top [IsAffine Y] {ι : Type*}\n    (U : ι → X.affineOpens) (hU : ⨆ i, (U i : Opens X) = ⊤)\n    (H : ∀ i, Q (f.appLE ⊤ (U i).1 le_top).hom) :\n    P f := by\n  have (i) : IsAffine ((X.openCoverOfISupEqTop _ hU).obj i) := (U i).2\n  refine of_source_openCover (X.openCoverOfISupEqTop _ hU) fun i ↦ ?_\n  simpa [Scheme.Hom.app_eq_appLE] using (f.appLE_congr _ rfl (by simp) (fun f => Q f.hom)).mp (H i)\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.iff_of_iSup_eq_top","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝¹ : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsAffine Y\nι : Type u_1\nU : ι → ↑X.affineOpens\nhU : Eq (iSup fun i => ↑(U i)) Top.top\n⊢ Iff (P f) (∀ (i : ι), Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f Top.top ↑(U i) ⋯)))","decl":"theorem iff_of_iSup_eq_top [IsAffine Y] {ι : Type*}\n    (U : ι → X.affineOpens) (hU : ⨆ i, (U i : Opens X) = ⊤) :\n    P f ↔ ∀ i, Q (f.appLE ⊤ (U i).1 le_top).hom :=\n  ⟨fun H _ ↦ appLE P f H ⟨_, isAffineOpen_top _⟩ _ le_top, of_iSup_eq_top U hU⟩\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.instIsLocalAtSource","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\n⊢ AlgebraicGeometry.IsLocalAtSource P","decl":"instance : IsLocalAtSource P := by\n  apply HasAffineProperty.isLocalAtSource\n  intros X Y f _ 𝒰\n  simp_rw [← HasAffineProperty.iff_of_isAffine (P := P),\n    iff_of_source_openCover 𝒰.affineRefinement.openCover,\n    fun i ↦ iff_of_source_openCover (P := P) (f := 𝒰.map i ≫ f) (𝒰.obj i).affineCover]\n  simp [Scheme.OpenCover.affineRefinement, Sigma.forall]\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.containsIdentities","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝ : AlgebraicGeometry.HasRingHomProperty P Q\nhP : RingHom.ContainsIdentities fun {R S} [CommRing R] [CommRing S] => Q\n⊢ P.ContainsIdentities","decl":"lemma containsIdentities (hP : RingHom.ContainsIdentities Q) : P.ContainsIdentities where\n  id_mem X := by\n    rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := P) _ (iSup_affineOpens_eq_top _)]\n    intro U\n    have : IsAffine (𝟙 X ⁻¹ᵁ U.1) := U.2\n    rw [morphismRestrict_id, iff_of_isAffine (P := P), Scheme.id_appTop]\n    apply hP\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.isLocal_ringHomProperty_of_isLocalAtSource_of_isLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝¹ : AlgebraicGeometry.IsLocalAtTarget P\ninst✝ : AlgebraicGeometry.IsLocalAtSource P\n⊢ RingHom.PropertyIsLocal fun {R S} [CommRing R] [CommRing S] f => P (AlgebraicGeometry.Spec.map (CommRingCat.ofHom f))","decl":"variable (P) in\nopen _root_.PrimeSpectrum in\nlemma isLocal_ringHomProperty_of_isLocalAtSource_of_isLocalAtTarget\n    [IsLocalAtTarget P] [IsLocalAtSource P] :\n    RingHom.PropertyIsLocal fun f ↦ P (Spec.map (CommRingCat.ofHom f)) := by\n  have hP : RingHom.RespectsIso (fun f ↦ P (Spec.map (CommRingCat.ofHom f))) :=\n    RingHom.toMorphismProperty_respectsIso_iff.mpr\n      (inferInstanceAs (P.inverseImage Scheme.Spec).unop.RespectsIso)\n  constructor\n  · intro R S _ _ f r R' S' _ _ _ _ _ _ H\n    refine (RingHom.RespectsIso.is_localization_away_iff hP ..).mp ?_\n    exact (MorphismProperty.arrow_mk_iso_iff P (SpecMapRestrictBasicOpenIso\n      (CommRingCat.ofHom f) r)).mp (IsLocalAtTarget.restrict H (basicOpen r))\n  · intros R S _ _ f s hs H\n    apply IsLocalAtSource.of_openCover (Scheme.affineOpenCoverOfSpanRangeEqTop\n      (fun i : s ↦ (i : S)) (by simpa)).openCover\n    intro i\n    simp only [CommRingCat.coe_of, Set.setOf_mem_eq, id_eq, eq_mpr_eq_cast,\n      Scheme.AffineOpenCover.openCover_obj, Scheme.affineOpenCoverOfSpanRangeEqTop_obj_carrier,\n      Scheme.AffineOpenCover.openCover_map, Scheme.affineOpenCoverOfSpanRangeEqTop_map,\n      ← Spec.map_comp]\n    exact H i\n  · intro R S _ _  f s hs H\n    apply IsLocalAtTarget.of_iSup_eq_top _ (PrimeSpectrum.iSup_basicOpen_eq_top_iff\n      (f := fun i : s ↦ (i : R)).mpr (by simpa))\n    intro i\n    exact (MorphismProperty.arrow_mk_iso_iff P (SpecMapRestrictBasicOpenIso\n      (CommRingCat.ofHom f) i.1)).mpr (H i)\n  · intro R S T _ _ _ _ r _ f hf\n    have := AlgebraicGeometry.IsOpenImmersion.of_isLocalization (S := T) r\n    show P (Spec.map (CommRingCat.ofHom f ≫ CommRingCat.ofHom (algebraMap _ _)))\n    rw [Spec.map_comp]\n    exact IsLocalAtSource.comp hf ..\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.of_isLocalAtSource_of_isLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst✝¹ : AlgebraicGeometry.IsLocalAtTarget P\ninst✝ : AlgebraicGeometry.IsLocalAtSource P\n⊢ AlgebraicGeometry.HasRingHomProperty P fun {R S} [CommRing R] [CommRing S] f => P (AlgebraicGeometry.Spec.map (CommRingCat.ofHom f))","decl":"open _root_.PrimeSpectrum in\nvariable (P) in\nlemma of_isLocalAtSource_of_isLocalAtTarget [IsLocalAtTarget P] [IsLocalAtSource P] :\n    HasRingHomProperty P (fun f ↦ P (Spec.map (CommRingCat.ofHom f))) where\n  isLocal_ringHomProperty :=\n    isLocal_ringHomProperty_of_isLocalAtSource_of_isLocalAtTarget P\n  eq_affineLocally' := by\n    let Q := affineLocally (fun f ↦ P (Spec.map (CommRingCat.ofHom f)))\n    have : HasRingHomProperty Q (fun f ↦ P (Spec.map (CommRingCat.ofHom f))) :=\n      ⟨isLocal_ringHomProperty_of_isLocalAtSource_of_isLocalAtTarget P, rfl⟩\n    show P = Q\n    ext X Y f\n    wlog hY : ∃ R, Y = Spec R generalizing X Y\n    · rw [IsLocalAtTarget.iff_of_openCover (P := P) Y.affineCover,\n        IsLocalAtTarget.iff_of_openCover (P := Q) Y.affineCover]\n      refine forall_congr' fun _ ↦ this _ ⟨_, rfl⟩\n    obtain ⟨S, rfl⟩ := hY\n    wlog hX : ∃ R, X = Spec R generalizing X\n    · rw [IsLocalAtSource.iff_of_openCover (P := P) X.affineCover,\n        IsLocalAtSource.iff_of_openCover (P := Q) X.affineCover]\n      refine forall_congr' fun _ ↦ this _ ⟨_, rfl⟩\n    obtain ⟨R, rfl⟩ := hX\n    obtain ⟨φ, rfl⟩ : ∃ φ, Spec.map φ = f := ⟨_, Spec.map_preimage _⟩\n    rw [HasRingHomProperty.Spec_iff (P := Q)]\n    rfl\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.stalkwise","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : {R S : Type u_1} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhP : RingHom.RespectsIso P\n⊢ AlgebraicGeometry.HasRingHomProperty (AlgebraicGeometry.stalkwise fun {R S} [CommRing R] [CommRing S] => P) fun {x S} {x_1} {x_2} φ => ∀ (p : Ideal S) (x_3 : p.IsPrime), P (Localization.localRingHom (Ideal.comap φ p) p φ ⋯)","decl":"lemma stalkwise {P} (hP : RingHom.RespectsIso P) :\n    HasRingHomProperty (stalkwise P) fun {_ S _ _} φ ↦\n      ∀ (p : Ideal S) (_ : p.IsPrime), P (Localization.localRingHom _ p φ rfl) := by\n  have := stalkwiseIsLocalAtTarget_of_respectsIso hP\n  have := stalkwise_isLocalAtSource_of_respectsIso hP\n  convert of_isLocalAtSource_of_isLocalAtTarget (P := AlgebraicGeometry.stalkwise P) with R S _ _ φ\n  exact (stalkwise_Spec_map_iff hP (CommRingCat.ofHom φ)).symm\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.stableUnderComposition","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝ : AlgebraicGeometry.HasRingHomProperty P Q\nhP : RingHom.StableUnderComposition fun {R S} [CommRing R] [CommRing S] => Q\n⊢ P.IsStableUnderComposition","decl":"lemma stableUnderComposition (hP : RingHom.StableUnderComposition Q) :\n    P.IsStableUnderComposition where\n  comp_mem {X Y Z} f g hf hg := by\n    wlog hZ : IsAffine Z generalizing X Y Z\n    · rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := P) _ (iSup_affineOpens_eq_top _)]\n      intro U\n      rw [morphismRestrict_comp]\n      exact this _ _ (IsLocalAtTarget.restrict hf _) (IsLocalAtTarget.restrict hg _) U.2\n    wlog hY : IsAffine Y generalizing X Y\n    · rw [IsLocalAtSource.iff_of_openCover (P := P) (Y.affineCover.pullbackCover f)]\n      intro i\n      rw [← Scheme.Cover.pullbackHom_map_assoc]\n      exact this _ _ (IsLocalAtTarget.of_isPullback (.of_hasPullback _ _) hf)\n        (comp_of_isOpenImmersion _ _ _ hg) inferInstance\n    wlog hX : IsAffine X generalizing X\n    · rw [IsLocalAtSource.iff_of_openCover (P := P) X.affineCover]\n      intro i\n      rw [← Category.assoc]\n      exact this _ (comp_of_isOpenImmersion _ _ _ hf) inferInstance\n    rw [iff_of_isAffine (P := P)] at hf hg ⊢\n    exact hP _ _ hg hf\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.of_comp","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝ : AlgebraicGeometry.HasRingHomProperty P Q\nH : ∀ {R S T : Type u} [inst : CommRing R] [inst_1 : CommRing S] [inst_2 : CommRing T] (f : RingHom R S) (g : RingHom S T), Q (g.comp f) → Q g\nX Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nh : P (CategoryTheory.CategoryStruct.comp f g)\n⊢ P f","decl":"theorem of_comp\n    (H : ∀ {R S T : Type u} [CommRing R] [CommRing S] [CommRing T],\n      ∀ (f : R →+* S) (g : S →+* T), Q (g.comp f) → Q g)\n    {X Y Z : Scheme.{u}} {f : X ⟶ Y} {g : Y ⟶ Z} (h : P (f ≫ g)) : P f := by\n  wlog hZ : IsAffine Z generalizing X Y Z\n  · rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := P) _\n      (g.preimage_iSup_eq_top (iSup_affineOpens_eq_top Z))]\n    intro U\n    have H := IsLocalAtTarget.restrict h U.1\n    rw [morphismRestrict_comp] at H\n    exact this H inferInstance\n  wlog hY : IsAffine Y generalizing X Y\n  · rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := P) _ (iSup_affineOpens_eq_top Y)]\n    intro U\n    have H := comp_of_isOpenImmersion P (f ⁻¹ᵁ U.1).ι (f ≫ g) h\n    rw [← morphismRestrict_ι_assoc] at H\n    exact this H inferInstance\n  wlog hY : IsAffine X generalizing X\n  · rw [IsLocalAtSource.iff_of_iSup_eq_top (P := P) _ (iSup_affineOpens_eq_top X)]\n    intro U\n    have H := comp_of_isOpenImmersion P U.1.ι (f ≫ g) h\n    rw [← Category.assoc] at H\n    exact this H inferInstance\n  rw [iff_of_isAffine (P := P)] at h ⊢\n  exact H _ _ h\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.isMultiplicative","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝ : AlgebraicGeometry.HasRingHomProperty P Q\nhPc : RingHom.StableUnderComposition fun {R S} [CommRing R] [CommRing S] => Q\nhPi : RingHom.ContainsIdentities fun {R S} [CommRing R] [CommRing S] => Q\n⊢ P.IsMultiplicative","decl":"lemma isMultiplicative (hPc : RingHom.StableUnderComposition Q)\n    (hPi : RingHom.ContainsIdentities Q) :\n    P.IsMultiplicative where\n  comp_mem := (stableUnderComposition hPc).comp_mem\n  id_mem := (containsIdentities hPi).id_mem\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.of_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝¹ : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhP : RingHom.ContainsIdentities fun {R S} [CommRing R] [CommRing S] => Q\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\n⊢ P f","decl":"include Q in\nlemma of_isOpenImmersion (hP : RingHom.ContainsIdentities Q) [IsOpenImmersion f] : P f :=\n  haveI : P.ContainsIdentities := containsIdentities hP\n  IsLocalAtSource.of_isOpenImmersion f\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.isStableUnderBaseChange","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝ : AlgebraicGeometry.HasRingHomProperty P Q\nhP : RingHom.IsStableUnderBaseChange fun {R S} [CommRing R] [CommRing S] => Q\n⊢ P.IsStableUnderBaseChange","decl":"lemma isStableUnderBaseChange (hP : RingHom.IsStableUnderBaseChange Q) :\n    P.IsStableUnderBaseChange := by\n  apply HasAffineProperty.isStableUnderBaseChange\n  letI := HasAffineProperty.isLocal_affineProperty P\n  apply AffineTargetMorphismProperty.IsStableUnderBaseChange.mk\n  intros X Y S _ _ f g H\n  rw [← HasAffineProperty.iff_of_isAffine (P := P)] at H ⊢\n  wlog hX : IsAffine Y generalizing Y\n  · rw [IsLocalAtSource.iff_of_openCover (P := P)\n      (Scheme.Pullback.openCoverOfRight Y.affineCover f g)]\n    intro i\n    simp only [Scheme.Pullback.openCoverOfRight_obj, Scheme.Pullback.openCoverOfRight_map,\n      limit.lift_π, PullbackCone.mk_pt, PullbackCone.mk_π_app, Category.comp_id]\n    apply this _ (comp_of_isOpenImmersion _ _ _ H) inferInstance\n  rw [iff_of_isAffine (P := P)] at H ⊢\n  exact hP.pullback_fst_appTop _ (isLocal_ringHomProperty P).respectsIso _ _ H\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.respects_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝ : AlgebraicGeometry.HasRingHomProperty P Q\nhQ : RingHom.StableUnderCompositionWithLocalizationAwaySource fun {R S} [CommRing R] [CommRing S] => Q\n⊢ P.Respects @AlgebraicGeometry.IsOpenImmersion","decl":"/-- Any property of scheme morphisms induced by a property of ring homomorphisms is stable\nunder composition with open immersions. -/\nlemma respects_isOpenImmersion (hQ : RingHom.StableUnderCompositionWithLocalizationAwaySource Q) :\n    P.Respects @IsOpenImmersion where\n  postcomp {X Y Z} i hi f hf := by\n    wlog hZ : IsAffine Z generalizing X Y Z\n    · rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := P) _ (iSup_affineOpens_eq_top _)]\n      intro U\n      rw [morphismRestrict_comp]\n      exact this _ inferInstance _ (IsLocalAtTarget.restrict hf _) U.2\n    let e : Y ≅ i.opensRange.toScheme := IsOpenImmersion.isoOfRangeEq i i.opensRange.ι (by simp)\n    rw [show f ≫ i = f ≫ e.hom ≫ i.opensRange.ι by simp [e], ← Category.assoc]\n    exact respects_isOpenImmersion_aux hQ _ (by rwa [P.cancel_right_of_respectsIso])\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.iff_exists_appLE_locally","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhQ : RingHom.StableUnderCompositionWithLocalizationAwaySource fun {R S} [CommRing R] [CommRing S] => Q\nhQi : RingHom.RespectsIso fun {R S} [CommRing R] [CommRing S] => Q\ninst✝ : AlgebraicGeometry.HasRingHomProperty P fun {R S} [CommRing R] [CommRing S] => RingHom.Locally fun {R S} [CommRing R] [CommRing S] => Q\n⊢ Iff (P f) (∀ (x : ↑↑X.toPresheafedSpace), Exists fun U => Exists fun V => Exists fun x => Exists fun e => Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (↑U) (↑V) e)))","decl":"omit [HasRingHomProperty P Q] in\n/-- If `P` is induced by `Locally Q`, it suffices to check `Q` on affine open sets locally around\npoints of the source. -/\nlemma iff_exists_appLE_locally\n    (hQ : RingHom.StableUnderCompositionWithLocalizationAwaySource Q)\n    (hQi : RespectsIso Q) [HasRingHomProperty P (Locally Q)] :\n    P f ↔ ∀ (x : X), ∃ (U : Y.affineOpens) (V : X.affineOpens) (_ : x ∈ V.1) (e : V.1 ≤ f ⁻¹ᵁ U.1),\n      Q (f.appLE U V e).hom := by\n  have := respects_isOpenImmersion (P := P)\n    (RingHom.locally_StableUnderCompositionWithLocalizationAwaySource hQ)\n  refine ⟨fun hf x ↦ ?_, fun hf ↦ (IsLocalAtSource.iff_exists_resLE (P := P)).mpr <| fun x ↦ ?_⟩\n  · obtain ⟨U, hU, hfx, _⟩ := Opens.isBasis_iff_nbhd.mp (isBasis_affine_open Y)\n      (Opens.mem_top <| f.base x)\n    obtain ⟨V, hV, hx, e⟩ := Opens.isBasis_iff_nbhd.mp (isBasis_affine_open X)\n      (show x ∈ f ⁻¹ᵁ U from hfx)\n    simp_rw [HasRingHomProperty.iff_appLE (P := P), locally_iff_isLocalization hQi] at hf\n    obtain ⟨s, hs, hfs⟩ := hf ⟨U, hU⟩ ⟨V, hV⟩ e\n    apply iSup_basicOpen_of_span_eq_top at hs\n    have : x ∈ (⨆ i ∈ s, X.basicOpen i) := hs.symm ▸ hx\n    have : ∃ r ∈ s, x ∈ X.basicOpen r := by simpa using this\n    obtain ⟨r, hr, hrs⟩ := this\n    refine ⟨⟨U, hU⟩, ⟨X.basicOpen r, hV.basicOpen r⟩, hrs, (X.basicOpen_le r).trans e, ?_⟩\n    rw [← f.appLE_map e (homOfLE (X.basicOpen_le r)).op]\n    haveI : IsLocalization.Away r Γ(X, X.basicOpen r) := hV.isLocalization_basicOpen r\n    exact hfs r hr _\n  · obtain ⟨U, V, hxV, e, hf⟩ := hf x\n    use U, V, hxV, e\n    simp only [iff_of_isAffine (P := P), Scheme.Hom.appLE, homOfLE_leOfHom] at hf ⊢\n    haveI : (toMorphismProperty (Locally Q)).RespectsIso := toMorphismProperty_respectsIso_iff.mp <|\n      (isLocal_ringHomProperty P).respectsIso\n    exact (MorphismProperty.arrow_mk_iso_iff (toMorphismProperty (Locally Q))\n      (arrowResLEAppIso f U V e)).mpr (locally_of hQi _ hf)\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.iff_exists_appLE","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝ : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhQ : RingHom.StableUnderCompositionWithLocalizationAwaySource fun {R S} [CommRing R] [CommRing S] => Q\n⊢ Iff (P f) (∀ (x : ↑↑X.toPresheafedSpace), Exists fun U => Exists fun V => Exists fun x => Exists fun e => Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (↑U) (↑V) e)))","decl":"/-- `P` can be checked locally around points of the source. -/\nlemma iff_exists_appLE\n    (hQ : StableUnderCompositionWithLocalizationAwaySource Q) : P f ↔\n    ∀ (x : X), ∃ (U : Y.affineOpens) (V : X.affineOpens) (_ : x ∈ V.1) (e : V.1 ≤ f ⁻¹ᵁ U.1),\n      Q (f.appLE U V e).hom := by\n  haveI inst : HasRingHomProperty P Q := inferInstance\n  haveI : HasRingHomProperty P (Locally Q) := by\n    apply @copy (P' := P) (Q := Q) (Q' := Locally Q)\n    · infer_instance\n    · rfl\n    · intro R S _ _ f\n      exact (locally_iff_of_localizationSpanTarget (isLocal_ringHomProperty P).respectsIso\n        (isLocal_ringHomProperty P).ofLocalizationSpanTarget _).symm\n  rw [iff_exists_appLE_locally (P := P) hQ]\n  haveI : HasRingHomProperty P Q := inst\n  apply (isLocal_ringHomProperty P (Q := Q)).respectsIso\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.locally_of_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\nhQl : RingHom.LocalizationAwayPreserves fun {R S} [CommRing R] [CommRing S] => Q\nhQa : RingHom.StableUnderCompositionWithLocalizationAway fun {R S} [CommRing R] [CommRing S] => Q\nh : ∀ {X Y : AlgebraicGeometry.Scheme} (f : Quiver.Hom X Y), Iff (P f) (∀ (x : ↑↑X.toPresheafedSpace), Exists fun U => Exists fun V => Exists fun x => Exists fun e => Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.appLE f (↑U) (↑V) e)))\n⊢ AlgebraicGeometry.HasRingHomProperty P fun {R S} [CommRing R] [CommRing S] => RingHom.Locally fun {R S} [CommRing R] [CommRing S] => Q","decl":"omit [HasRingHomProperty P Q] in\nlemma locally_of_iff (hQl : LocalizationAwayPreserves Q)\n    (hQa : StableUnderCompositionWithLocalizationAway Q)\n    (h : ∀ {X Y : Scheme.{u}} (f : X ⟶ Y), P f ↔\n      ∀ (x : X), ∃ (U : Y.affineOpens) (V : X.affineOpens) (_ : x ∈ V.1) (e : V.1 ≤ f ⁻¹ᵁ U.1),\n      Q (f.appLE U V e).hom) : HasRingHomProperty P (Locally Q) where\n  isLocal_ringHomProperty := locally_propertyIsLocal hQl hQa\n  eq_affineLocally' := by\n    haveI : HasRingHomProperty (affineLocally (Locally Q)) (Locally Q) :=\n      ⟨locally_propertyIsLocal hQl hQa, rfl⟩\n    ext X Y f\n    rw [h, iff_exists_appLE_locally (P := affineLocally (Locally Q)) hQa.left hQa.respectsIso]\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.of_stalkMap","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝ : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhQ : RingHom.OfLocalizationPrime fun {R S} [CommRing R] [CommRing S] => Q\nH : ∀ (x : ↑↑X.toPresheafedSpace), Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.stalkMap f x))\n⊢ P f","decl":"/-- If `Q` is a property of ring maps that can be checked on prime ideals, the\nassociated property of scheme morphisms can be checked on stalks. -/\nlemma of_stalkMap (hQ : OfLocalizationPrime Q) (H : ∀ x, Q (f.stalkMap x).hom) : P f := by\n  have hQi := (HasRingHomProperty.isLocal_ringHomProperty P).respectsIso\n  wlog hY : IsAffine Y generalizing X Y f\n  · rw [IsLocalAtTarget.iff_of_iSup_eq_top (P := P) _ (iSup_affineOpens_eq_top _)]\n    intro U\n    refine this (fun x ↦ ?_) U.2\n    exact (hQi.arrow_mk_iso_iff (AlgebraicGeometry.morphismRestrictStalkMap f U x)).mpr (H x.val)\n  wlog hX : IsAffine X generalizing X f\n  · rw [IsLocalAtSource.iff_of_iSup_eq_top (P := P) _ (iSup_affineOpens_eq_top _)]\n    intro U\n    refine this ?_ U.2\n    intro x\n    rw [Scheme.stalkMap_comp, CommRingCat.hom_comp, hQi.cancel_right_isIso]\n    exact H x.val\n  wlog hXY : ∃ R S, Y = Spec R ∧ X = Spec S generalizing X Y\n  · rw [← P.cancel_right_of_respectsIso (g := Y.isoSpec.hom)]\n    rw [← P.cancel_left_of_respectsIso (f := X.isoSpec.inv)]\n    refine this inferInstance (fun x ↦ ?_) inferInstance ?_\n    · rw [Scheme.stalkMap_comp, Scheme.stalkMap_comp, CommRingCat.hom_comp,\n        hQi.cancel_right_isIso, CommRingCat.hom_comp, hQi.cancel_left_isIso]\n      apply H\n    · use Γ(Y, ⊤), Γ(X, ⊤)\n  obtain ⟨R, S, rfl, rfl⟩ := hXY\n  obtain ⟨φ, rfl⟩ := Spec.map_surjective f\n  rw [Spec_iff (P := P)]\n  apply hQ\n  intro P hP\n  specialize H ⟨P, hP⟩\n  rwa [hQi.arrow_mk_iso_iff (Scheme.arrowStalkMapSpecIso φ _)] at H\n\n"}
{"name":"AlgebraicGeometry.HasRingHomProperty.stalkMap","module":"Mathlib.AlgebraicGeometry.Morphisms.RingHomProperties","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : {R S : Type u} → [inst : CommRing R] → [inst_1 : CommRing S] → RingHom R S → Prop\ninst✝ : AlgebraicGeometry.HasRingHomProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhQ : ∀ {R S : Type u} [inst : CommRing R] [inst_1 : CommRing S] (f : RingHom R S), Q f → ∀ (J : Ideal S) (x : J.IsPrime), Q (Localization.localRingHom (Ideal.comap f J) J f ⋯)\nhf : P f\nx : ↑↑X.toPresheafedSpace\n⊢ Q (CommRingCat.Hom.hom (AlgebraicGeometry.Scheme.Hom.stalkMap f x))","decl":"/-- Let `Q` be a property of ring maps that is stable under localization.\nThen if the associated property of scheme morphisms holds for `f`, `Q` holds on all stalks. -/\nlemma stalkMap\n      (hQ : ∀ {R S : Type u} [CommRing R] [CommRing S] (f : R →+* S) (_ : Q f)\n        (J : Ideal S) (_ : J.IsPrime), Q (Localization.localRingHom _ J f rfl))\n      (hf : P f) (x : X) : Q (f.stalkMap x).hom := by\n  have hQi := (HasRingHomProperty.isLocal_ringHomProperty P).respectsIso\n  wlog h : IsAffine X ∧ IsAffine Y generalizing X Y f\n  · obtain ⟨U, hU, hfx, _⟩ := Opens.isBasis_iff_nbhd.mp (isBasis_affine_open Y)\n      (Opens.mem_top <| f.base x)\n    obtain ⟨V, hV, hx, e⟩ := Opens.isBasis_iff_nbhd.mp (isBasis_affine_open X)\n      (show x ∈ f ⁻¹ᵁ U from hfx)\n    rw [← hQi.arrow_mk_iso_iff (Scheme.Hom.resLEStalkMap f e ⟨x, hx⟩)]\n    exact this (IsLocalAtSource.resLE _ hf) _ ⟨hV, hU⟩\n  obtain ⟨hX, hY⟩ := h\n  wlog hXY : ∃ R S, Y = Spec R ∧ X = Spec S generalizing X Y\n  · have : Q ((X.isoSpec.inv ≫ f ≫ Y.isoSpec.hom).stalkMap (X.isoSpec.hom.base x)).hom := by\n      refine this ?_ (X.isoSpec.hom.base x) inferInstance inferInstance ?_\n      · rwa [P.cancel_left_of_respectsIso, P.cancel_right_of_respectsIso]\n      · use Γ(Y, ⊤), Γ(X, ⊤)\n    rw [Scheme.stalkMap_comp, Scheme.stalkMap_comp, CommRingCat.hom_comp,\n      hQi.cancel_right_isIso, CommRingCat.hom_comp, hQi.cancel_left_isIso] at this\n    have heq : (X.isoSpec.inv.base (X.isoSpec.hom.base x)) = x := by simp\n    rwa [hQi.arrow_mk_iso_iff\n      (Scheme.arrowStalkMapIsoOfEq f heq)] at this\n  obtain ⟨R, S, rfl, rfl⟩ := hXY\n  obtain ⟨φ, rfl⟩ := Spec.map_surjective f\n  rw [hQi.arrow_mk_iso_iff (Scheme.arrowStalkMapSpecIso φ _)]\n  rw [Spec_iff (P := P)] at hf\n  apply hQ _ hf\n\n"}
