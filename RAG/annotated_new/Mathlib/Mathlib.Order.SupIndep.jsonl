{"name":"Finset.supIndep_iff_disjoint_erase","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝² : Lattice α\ninst✝¹ : OrderBot α\ns : Finset ι\nf : ι → α\ninst✝ : DecidableEq ι\n⊢ Iff (s.SupIndep f) (∀ (i : ι), Membership.mem s i → Disjoint (f i) ((s.erase i).sup f))","decl":"/-- The RHS looks like the definition of `iSupIndep`. -/\ntheorem supIndep_iff_disjoint_erase [DecidableEq ι] :\n    s.SupIndep f ↔ ∀ i ∈ s, Disjoint (f i) ((s.erase i).sup f) :=\n  ⟨fun hs _ hi => hs (erase_subset _ _) hi (not_mem_erase _ _), fun hs _ ht i hi hit =>\n    (hs i hi).mono_right (sup_mono fun _ hj => mem_erase.2 ⟨ne_of_mem_of_not_mem hj hit, ht hj⟩)⟩\n\n"}
{"name":"Finset.SupIndep.subset","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\ns t : Finset ι\nf : ι → α\nht : t.SupIndep f\nh : HasSubset.Subset s t\n⊢ s.SupIndep f","decl":"theorem SupIndep.subset (ht : t.SupIndep f) (h : s ⊆ t) : s.SupIndep f := fun _ hu _ hi =>\n  ht (hu.trans h) (h hi)\n\n"}
{"name":"Finset.supIndep_empty","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\nf : ι → α\n⊢ EmptyCollection.emptyCollection.SupIndep f","decl":"@[simp]\ntheorem supIndep_empty (f : ι → α) : (∅ : Finset ι).SupIndep f := fun _ _ a ha =>\n  (not_mem_empty a ha).elim\n\n"}
{"name":"Finset.supIndep_singleton","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\ni : ι\nf : ι → α\n⊢ (Singleton.singleton i).SupIndep f","decl":"@[simp]\ntheorem supIndep_singleton (i : ι) (f : ι → α) : ({i} : Finset ι).SupIndep f :=\n  fun s hs j hji hj => by\n    rw [eq_empty_of_ssubset_singleton ⟨hs, fun h => hj (h hji)⟩, sup_empty]\n    exact disjoint_bot_right\n\n"}
{"name":"Finset.SupIndep.pairwiseDisjoint","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\ns : Finset ι\nf : ι → α\nhs : s.SupIndep f\n⊢ (↑s).PairwiseDisjoint f","decl":"theorem SupIndep.pairwiseDisjoint (hs : s.SupIndep f) : (s : Set ι).PairwiseDisjoint f :=\n  fun _ ha _ hb hab =>\n    sup_singleton.subst <| hs (singleton_subset_iff.2 hb) ha <| not_mem_singleton.2 hab\n\n"}
{"name":"Finset.sup_indep.pairwise_disjoint","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\ns : Finset ι\nf : ι → α\nhs : s.SupIndep f\n⊢ (↑s).PairwiseDisjoint f","decl":"@[deprecated (since := \"2025-01-17\")] alias sup_indep.pairwise_disjoint := SupIndep.pairwiseDisjoint\n\n"}
{"name":"Finset.SupIndep.le_sup_iff","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\ns t : Finset ι\nf : ι → α\ni : ι\nhs : s.SupIndep f\nhts : HasSubset.Subset t s\nhi : Membership.mem s i\nhf : ∀ (i : ι), Ne (f i) Bot.bot\n⊢ Iff (LE.le (f i) (t.sup f)) (Membership.mem t i)","decl":"theorem SupIndep.le_sup_iff (hs : s.SupIndep f) (hts : t ⊆ s) (hi : i ∈ s) (hf : ∀ i, f i ≠ ⊥) :\n    f i ≤ t.sup f ↔ i ∈ t := by\n  refine ⟨fun h => ?_, le_sup⟩\n  by_contra hit\n  exact hf i (disjoint_self.1 <| (hs hts hi hit).mono_right h)\n\n"}
{"name":"Finset.SupIndep.antitone_fun","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\ns : Finset ι\nf g : ι → α\nhle : ∀ (x : ι), Membership.mem s x → LE.le (f x) (g x)\nh : s.SupIndep g\n⊢ s.SupIndep f","decl":"theorem SupIndep.antitone_fun {g : ι → α} (hle : ∀ x ∈ s, f x ≤ g x) (h : s.SupIndep g) :\n    s.SupIndep f := fun _t hts i his hit ↦\n  (h hts his hit).mono (hle i his) <| Finset.sup_mono_fun fun x hx ↦ hle x <| hts hx\n\n"}
{"name":"Finset.supIndep_antimono_fun","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\ns : Finset ι\nf g : ι → α\nhle : ∀ (x : ι), Membership.mem s x → LE.le (f x) (g x)\nh : s.SupIndep g\n⊢ s.SupIndep f","decl":"@[deprecated (since := \"2025-01-17\")]\nalias supIndep_antimono_fun := SupIndep.antitone_fun\n\n"}
{"name":"Finset.SupIndep.image","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\nι' : Type u_4\ninst✝² : Lattice α\ninst✝¹ : OrderBot α\nf : ι → α\ninst✝ : DecidableEq ι\ns : Finset ι'\ng : ι' → ι\nhs : s.SupIndep (Function.comp f g)\n⊢ (Finset.image g s).SupIndep f","decl":"protected theorem SupIndep.image [DecidableEq ι] {s : Finset ι'} {g : ι' → ι}\n    (hs : s.SupIndep (f ∘ g)) : (s.image g).SupIndep f := by\n  intro t ht i hi hit\n  rcases subset_image_iff.mp ht with ⟨t, hts, rfl⟩\n  rcases mem_image.mp hi with ⟨i, his, rfl⟩\n  rw [sup_image]\n  exact hs hts his (hit <| mem_image_of_mem _ ·)\n\n"}
{"name":"Finset.supIndep_map","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\nι' : Type u_4\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\nf : ι → α\ns : Finset ι'\ng : Function.Embedding ι' ι\n⊢ Iff ((Finset.map g s).SupIndep f) (s.SupIndep (Function.comp f ⇑g))","decl":"theorem supIndep_map {s : Finset ι'} {g : ι' ↪ ι} : (s.map g).SupIndep f ↔ s.SupIndep (f ∘ g) := by\n  refine ⟨fun hs t ht i hi hit => ?_, fun hs => ?_⟩\n  · rw [← sup_map]\n    exact hs (map_subset_map.2 ht) ((mem_map' _).2 hi) (by rwa [mem_map'])\n  · classical\n    rw [map_eq_image]\n    exact hs.image\n\n"}
{"name":"Finset.supIndep_pair","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝² : Lattice α\ninst✝¹ : OrderBot α\nf : ι → α\ninst✝ : DecidableEq ι\ni j : ι\nhij : Ne i j\n⊢ Iff ((Insert.insert i (Singleton.singleton j)).SupIndep f) (Disjoint (f i) (f j))","decl":"@[simp]\ntheorem supIndep_pair [DecidableEq ι] {i j : ι} (hij : i ≠ j) :\n    ({i, j} : Finset ι).SupIndep f ↔ Disjoint (f i) (f j) := by\n  suffices Disjoint (f i) (f j) → Disjoint (f j) ((Finset.erase {i, j} j).sup f) by\n    simpa [supIndep_iff_disjoint_erase, hij]\n  rw [pair_comm]\n  simp [hij.symm, disjoint_comm]\n\n"}
{"name":"Finset.supIndep_univ_bool","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\nf : Bool → α\n⊢ Iff (Finset.univ.SupIndep f) (Disjoint (f Bool.false) (f Bool.true))","decl":"theorem supIndep_univ_bool (f : Bool → α) :\n    (Finset.univ : Finset Bool).SupIndep f ↔ Disjoint (f false) (f true) :=\n  haveI : true ≠ false := by simp only [Ne, not_false_iff, reduceCtorEq]\n  (supIndep_pair this).trans disjoint_comm\n\n"}
{"name":"Finset.supIndep_univ_fin_two","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\nf : Fin 2 → α\n⊢ Iff (Finset.univ.SupIndep f) (Disjoint (f 0) (f 1))","decl":"@[simp]\ntheorem supIndep_univ_fin_two (f : Fin 2 → α) :\n    (Finset.univ : Finset (Fin 2)).SupIndep f ↔ Disjoint (f 0) (f 1) :=\n  have : (0 : Fin 2) ≠ 1 := by simp\n  supIndep_pair this\n\n"}
{"name":"Finset.supIndep_attach","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\ns : Finset ι\nf : ι → α\n⊢ Iff (s.attach.SupIndep fun a => f ↑a) (s.SupIndep f)","decl":"@[simp]\ntheorem supIndep_attach : (s.attach.SupIndep fun a => f a) ↔ s.SupIndep f := by\n  simpa [Finset.attach_map_val] using (supIndep_map (s := s.attach) (g := .subtype _)).symm\n\n"}
{"name":"Finset.SupIndep.attach","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝¹ : Lattice α\ninst✝ : OrderBot α\ns : Finset ι\nf : ι → α\na✝ : s.SupIndep f\n⊢ s.attach.SupIndep fun a => f ↑a","decl":"alias ⟨_, SupIndep.attach⟩ := supIndep_attach\n\n"}
{"name":"Finset.supIndep_iff_pairwiseDisjoint","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝¹ : DistribLattice α\ninst✝ : OrderBot α\ns : Finset ι\nf : ι → α\n⊢ Iff (s.SupIndep f) ((↑s).PairwiseDisjoint f)","decl":"theorem supIndep_iff_pairwiseDisjoint : s.SupIndep f ↔ (s : Set ι).PairwiseDisjoint f :=\n  ⟨SupIndep.pairwiseDisjoint, fun hs _ ht _ hi hit =>\n    Finset.disjoint_sup_right.2 fun _ hj => hs hi (ht hj) (ne_of_mem_of_not_mem hj hit).symm⟩\n\n"}
{"name":"Set.PairwiseDisjoint.supIndep","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝¹ : DistribLattice α\ninst✝ : OrderBot α\ns : Finset ι\nf : ι → α\na✝ : (↑s).PairwiseDisjoint f\n⊢ s.SupIndep f","decl":"alias ⟨_, _root_.Set.PairwiseDisjoint.supIndep⟩ := supIndep_iff_pairwiseDisjoint\n\n"}
{"name":"Finset.SupIndep.sup","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\nι' : Type u_4\ninst✝² : DistribLattice α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq ι\ns : Finset ι'\ng : ι' → Finset ι\nf : ι → α\nhs : s.SupIndep fun i => (g i).sup f\nhg : ∀ (i' : ι'), Membership.mem s i' → (g i').SupIndep f\n⊢ (s.sup g).SupIndep f","decl":"/-- Bind operation for `SupIndep`. -/\nprotected theorem SupIndep.sup [DecidableEq ι] {s : Finset ι'} {g : ι' → Finset ι} {f : ι → α}\n    (hs : s.SupIndep fun i => (g i).sup f) (hg : ∀ i' ∈ s, (g i').SupIndep f) :\n    (s.sup g).SupIndep f := by\n  simp_rw [supIndep_iff_pairwiseDisjoint] at hs hg ⊢\n  rw [sup_eq_biUnion, coe_biUnion]\n  exact hs.biUnion_finset hg\n\n"}
{"name":"Finset.SupIndep.biUnion","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\nι' : Type u_4\ninst✝² : DistribLattice α\ninst✝¹ : OrderBot α\ninst✝ : DecidableEq ι\ns : Finset ι'\ng : ι' → Finset ι\nf : ι → α\nhs : s.SupIndep fun i => (g i).sup f\nhg : ∀ (i' : ι'), Membership.mem s i' → (g i').SupIndep f\n⊢ (s.biUnion g).SupIndep f","decl":"/-- Bind operation for `SupIndep`. -/\nprotected theorem SupIndep.biUnion [DecidableEq ι] {s : Finset ι'} {g : ι' → Finset ι} {f : ι → α}\n    (hs : s.SupIndep fun i => (g i).sup f) (hg : ∀ i' ∈ s, (g i').SupIndep f) :\n    (s.biUnion g).SupIndep f := by\n  rw [← sup_eq_biUnion]\n  exact hs.sup hg\n\n"}
{"name":"Finset.SupIndep.sigma","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝¹ : DistribLattice α\ninst✝ : OrderBot α\nβ : ι → Type u_5\ns : Finset ι\ng : (i : ι) → Finset (β i)\nf : Sigma β → α\nhs : s.SupIndep fun i => (g i).sup fun b => f ⟨i, b⟩\nhg : ∀ (i : ι), Membership.mem s i → (g i).SupIndep fun b => f ⟨i, b⟩\n⊢ (s.sigma g).SupIndep f","decl":"/-- Bind operation for `SupIndep`. -/\nprotected theorem SupIndep.sigma {β : ι → Type*} {s : Finset ι} {g : ∀ i, Finset (β i)}\n    {f : Sigma β → α} (hs : s.SupIndep fun i => (g i).sup fun b => f ⟨i, b⟩)\n    (hg : ∀ i ∈ s, (g i).SupIndep fun b => f ⟨i, b⟩) : (s.sigma g).SupIndep f := by\n  rintro t ht ⟨i, b⟩ hi hit\n  rw [Finset.disjoint_sup_right]\n  rintro ⟨j, c⟩ hj\n  have hbc := (ne_of_mem_of_not_mem hj hit).symm\n  replace hj := ht hj\n  rw [mem_sigma] at hi hj\n  obtain rfl | hij := eq_or_ne i j\n  · exact (hg _ hj.1).pairwiseDisjoint hi.2 hj.2 (sigma_mk_injective.ne_iff.1 hbc)\n  · refine (hs.pairwiseDisjoint hi.1 hj.1 hij).mono ?_ ?_\n    · convert le_sup (α := α) hi.2; simp\n    · convert le_sup (α := α) hj.2; simp\n\n"}
{"name":"Finset.SupIndep.product","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\nι' : Type u_4\ninst✝¹ : DistribLattice α\ninst✝ : OrderBot α\ns : Finset ι\nt : Finset ι'\nf : Prod ι ι' → α\nhs : s.SupIndep fun i => t.sup fun i' => f { fst := i, snd := i' }\nht : t.SupIndep fun i' => s.sup fun i => f { fst := i, snd := i' }\n⊢ (SProd.sprod s t).SupIndep f","decl":"protected theorem SupIndep.product {s : Finset ι} {t : Finset ι'} {f : ι × ι' → α}\n    (hs : s.SupIndep fun i => t.sup fun i' => f (i, i'))\n    (ht : t.SupIndep fun i' => s.sup fun i => f (i, i')) : (s ×ˢ t).SupIndep f := by\n  rintro u hu ⟨i, i'⟩ hi hiu\n  rw [Finset.disjoint_sup_right]\n  rintro ⟨j, j'⟩ hj\n  have hij := (ne_of_mem_of_not_mem hj hiu).symm\n  replace hj := hu hj\n  rw [mem_product] at hi hj\n  obtain rfl | hij := eq_or_ne i j\n  · refine (ht.pairwiseDisjoint hi.2 hj.2 <| (Prod.mk.inj_left _).ne_iff.1 hij).mono ?_ ?_\n    · convert le_sup (α := α) hi.1; simp\n    · convert le_sup (α := α) hj.1; simp\n  · refine (hs.pairwiseDisjoint hi.1 hj.1 hij).mono ?_ ?_\n    · convert le_sup (α := α) hi.2; simp\n    · convert le_sup (α := α) hj.2; simp\n\n"}
{"name":"Finset.supIndep_product_iff","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\nι' : Type u_4\ninst✝¹ : DistribLattice α\ninst✝ : OrderBot α\ns : Finset ι\nt : Finset ι'\nf : Prod ι ι' → α\n⊢ Iff ((s.product t).SupIndep f) (And (s.SupIndep fun i => t.sup fun i' => f { fst := i, snd := i' }) (t.SupIndep fun i' => s.sup fun i => f { fst := i, snd := i' }))","decl":"theorem supIndep_product_iff {s : Finset ι} {t : Finset ι'} {f : ι × ι' → α} :\n    (s.product t).SupIndep f ↔ (s.SupIndep fun i => t.sup fun i' => f (i, i'))\n      ∧ t.SupIndep fun i' => s.sup fun i => f (i, i') := by\n  refine ⟨?_, fun h => h.1.product h.2⟩\n  simp_rw [supIndep_iff_pairwiseDisjoint]\n  refine fun h => ⟨fun i hi j hj hij => ?_, fun i hi j hj hij => ?_⟩ <;>\n      simp_rw [Finset.disjoint_sup_left, Finset.disjoint_sup_right] <;>\n    intro i' hi' j' hj'\n  · exact h (mk_mem_product hi hi') (mk_mem_product hj hj') (ne_of_apply_ne Prod.fst hij)\n  · exact h (mk_mem_product hi' hi) (mk_mem_product hj' hj) (ne_of_apply_ne Prod.snd hij)\n\n"}
{"name":"sSupIndep_empty","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\n⊢ sSupIndep EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem sSupIndep_empty : sSupIndep (∅ : Set α) := fun x hx =>\n  (Set.not_mem_empty x hx).elim\n\n"}
{"name":"CompleteLattice.setIndependent_empty","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\n⊢ sSupIndep EmptyCollection.emptyCollection","decl":"@[deprecated (since := \"2024-11-24\")] alias CompleteLattice.setIndependent_empty := sSupIndep_empty\n\n"}
{"name":"sSupIndep.mono","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\nhs : sSupIndep s\nt : Set α\nhst : HasSubset.Subset t s\n⊢ sSupIndep t","decl":"include hs in\ntheorem sSupIndep.mono {t : Set α} (hst : t ⊆ s) : sSupIndep t := fun _ ha =>\n  (hs (hst ha)).mono_right (sSup_le_sSup (diff_subset_diff_left hst))\n\n"}
{"name":"CompleteLattice.SetIndependent.mono","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\nhs : sSupIndep s\nt : Set α\nhst : HasSubset.Subset t s\n⊢ sSupIndep t","decl":"@[deprecated (since := \"2024-11-24\")] alias CompleteLattice.SetIndependent.mono := sSupIndep.mono\n\n"}
{"name":"sSupIndep.pairwiseDisjoint","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\nhs : sSupIndep s\n⊢ s.PairwiseDisjoint id","decl":"include hs in\n/-- If the elements of a set are independent, then any pair within that set is disjoint. -/\ntheorem sSupIndep.pairwiseDisjoint : s.PairwiseDisjoint id := fun _ hx y hy h =>\n  disjoint_sSup_right (hs hx) ((mem_diff y).mpr ⟨hy, h.symm⟩)\n\n"}
{"name":"CompleteLattice.SetIndependent.pairwiseDisjoint","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\nhs : sSupIndep s\n⊢ s.PairwiseDisjoint id","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.SetIndependent.pairwiseDisjoint := sSupIndep.pairwiseDisjoint\n\n"}
{"name":"sSupIndep_singleton","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\na : α\n⊢ sSupIndep (Singleton.singleton a)","decl":"theorem sSupIndep_singleton (a : α) : sSupIndep ({a} : Set α) := fun i hi ↦ by\n  simp_all\n\n"}
{"name":"CompleteLattice.setIndependent_singleton","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\na : α\n⊢ sSupIndep (Singleton.singleton a)","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.setIndependent_singleton := sSupIndep_singleton\n\n"}
{"name":"sSupIndep_pair","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\na b : α\nhab : Ne a b\n⊢ Iff (sSupIndep (Insert.insert a (Singleton.singleton b))) (Disjoint a b)","decl":"theorem sSupIndep_pair {a b : α} (hab : a ≠ b) :\n    sSupIndep ({a, b} : Set α) ↔ Disjoint a b := by\n  constructor\n  · intro h\n    exact h.pairwiseDisjoint (mem_insert _ _) (mem_insert_of_mem _ (mem_singleton _)) hab\n  · rintro h c ((rfl : c = a) | (rfl : c = b))\n    · convert h using 1\n      simp [hab, sSup_singleton]\n    · convert h.symm using 1\n      simp [hab, sSup_singleton]\n\n"}
{"name":"CompleteLattice.setIndependent_pair","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\na b : α\nhab : Ne a b\n⊢ Iff (sSupIndep (Insert.insert a (Singleton.singleton b))) (Disjoint a b)","decl":"@[deprecated (since := \"2024-11-24\")] alias CompleteLattice.setIndependent_pair := sSupIndep_pair\n\n"}
{"name":"sSupIndep.disjoint_sSup","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\nhs : sSupIndep s\nx : α\ny : Set α\nhx : Membership.mem s x\nhy : HasSubset.Subset y s\nhxy : Not (Membership.mem y x)\n⊢ Disjoint x (SupSet.sSup y)","decl":"include hs in\n/-- If the elements of a set are independent, then any element is disjoint from the `sSup` of some\nsubset of the rest. -/\ntheorem sSupIndep.disjoint_sSup {x : α} {y : Set α} (hx : x ∈ s) (hy : y ⊆ s) (hxy : x ∉ y) :\n    Disjoint x (sSup y) := by\n  have := (hs.mono <| insert_subset_iff.mpr ⟨hx, hy⟩) (mem_insert x _)\n  rw [insert_diff_of_mem _ (mem_singleton _), diff_singleton_eq_self hxy] at this\n  exact this\n\n"}
{"name":"CompleteLattice.SetIndependent.disjoint_sSup","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\ns : Set α\nhs : sSupIndep s\nx : α\ny : Set α\nhx : Membership.mem s x\nhy : HasSubset.Subset y s\nhxy : Not (Membership.mem y x)\n⊢ Disjoint x (SupSet.sSup y)","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.SetIndependent.disjoint_sSup := sSupIndep.disjoint_sSup\n\n"}
{"name":"sSupIndep_iff","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_5\ninst✝ : CompleteLattice α\ns : Set α\n⊢ Iff (sSupIndep s) (iSupIndep Subtype.val)","decl":"theorem sSupIndep_iff {α : Type*} [CompleteLattice α] (s : Set α) :\n    sSupIndep s ↔ iSupIndep ((↑) : s → α) := by\n  simp_rw [iSupIndep, sSupIndep, SetCoe.forall, sSup_eq_iSup]\n  refine forall₂_congr fun a ha => ?_\n  simp [iSup_subtype, iSup_and]\n\n"}
{"name":"CompleteLattice.setIndependent_iff","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_5\ninst✝ : CompleteLattice α\ns : Set α\n⊢ Iff (sSupIndep s) (iSupIndep Subtype.val)","decl":"@[deprecated (since := \"2024-11-24\")] alias CompleteLattice.setIndependent_iff := sSupIndep_iff\n\n"}
{"name":"iSupIndep_def","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\nt : ι → α\n⊢ Iff (iSupIndep t) (∀ (i : ι), Disjoint (t i) (iSup fun j => iSup fun x => t j))","decl":"theorem iSupIndep_def : iSupIndep t ↔ ∀ i, Disjoint (t i) (⨆ (j) (_ : j ≠ i), t j) :=\n  Iff.rfl\n\n"}
{"name":"CompleteLattice.independent_def","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\nt : ι → α\n⊢ Iff (iSupIndep t) (∀ (i : ι), Disjoint (t i) (iSup fun j => iSup fun x => t j))","decl":"@[deprecated (since := \"2024-11-24\")] alias CompleteLattice.independent_def := iSupIndep_def\n\n"}
{"name":"iSupIndep_def'","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\nt : ι → α\n⊢ Iff (iSupIndep t) (∀ (i : ι), Disjoint (t i) (SupSet.sSup (Set.image t (setOf fun j => Ne j i))))","decl":"theorem iSupIndep_def' : iSupIndep t ↔ ∀ i, Disjoint (t i) (sSup (t '' { j | j ≠ i })) := by\n  simp_rw [sSup_image]\n  rfl\n\n"}
{"name":"CompleteLattice.independent_def'","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\nt : ι → α\n⊢ Iff (iSupIndep t) (∀ (i : ι), Disjoint (t i) (SupSet.sSup (Set.image t (setOf fun j => Ne j i))))","decl":"@[deprecated (since := \"2024-11-24\")] alias CompleteLattice.independent_def' := iSupIndep_def'\n\n"}
{"name":"iSupIndep_def''","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\nt : ι → α\n⊢ Iff (iSupIndep t) (∀ (i : ι), Disjoint (t i) (SupSet.sSup (setOf fun a => Exists fun j => And (Ne j i) (Eq (t j) a))))","decl":"theorem iSupIndep_def'' :\n    iSupIndep t ↔ ∀ i, Disjoint (t i) (sSup { a | ∃ j ≠ i, t j = a }) := by\n  rw [iSupIndep_def']\n  aesop\n\n"}
{"name":"CompleteLattice.independent_def''","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\nt : ι → α\n⊢ Iff (iSupIndep t) (∀ (i : ι), Disjoint (t i) (SupSet.sSup (setOf fun a => Exists fun j => And (Ne j i) (Eq (t j) a))))","decl":"@[deprecated (since := \"2024-11-24\")] alias CompleteLattice.independent_def'' := iSupIndep_def''\n\n"}
{"name":"iSupIndep_empty","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nt : Empty → α\n⊢ iSupIndep t","decl":"@[simp]\ntheorem iSupIndep_empty (t : Empty → α) : iSupIndep t :=\n  nofun\n\n"}
{"name":"CompleteLattice.independent_empty","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nt : Empty → α\n⊢ iSupIndep t","decl":"@[deprecated (since := \"2024-11-24\")] alias CompleteLattice.independent_empty := iSupIndep_empty\n\n"}
{"name":"iSupIndep_pempty","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nt : PEmpty.{u_5} → α\n⊢ iSupIndep t","decl":"@[simp]\ntheorem iSupIndep_pempty (t : PEmpty → α) : iSupIndep t :=\n  nofun\n\n"}
{"name":"CompleteLattice.independent_pempty","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nt : PEmpty.{u_5} → α\n⊢ iSupIndep t","decl":"@[deprecated (since := \"2024-11-24\")] alias CompleteLattice.independent_pempty := iSupIndep_pempty\n\n"}
{"name":"iSupIndep.pairwiseDisjoint","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\nt : ι → α\nht : iSupIndep t\n⊢ Pairwise (Function.onFun Disjoint t)","decl":"include ht in\n/-- If the elements of a set are independent, then any pair within that set is disjoint. -/\ntheorem iSupIndep.pairwiseDisjoint : Pairwise (Disjoint on t) := fun x y h =>\n  disjoint_sSup_right (ht x) ⟨y, iSup_pos h.symm⟩\n\n"}
{"name":"CompleteLattice.Independent.pairwiseDisjoint","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\nt : ι → α\nht : iSupIndep t\n⊢ Pairwise (Function.onFun Disjoint t)","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.Independent.pairwiseDisjoint := iSupIndep.pairwiseDisjoint\n\n"}
{"name":"iSupIndep.mono","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\ns t : ι → α\nhs : iSupIndep s\nhst : LE.le t s\n⊢ iSupIndep t","decl":"theorem iSupIndep.mono {s t : ι → α} (hs : iSupIndep s) (hst : t ≤ s) : iSupIndep t :=\n  fun i => (hs i).mono (hst i) <| iSup₂_mono fun j _ => hst j\n\n"}
{"name":"CompleteLattice.Independent.mono","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\ns t : ι → α\nhs : iSupIndep s\nhst : LE.le t s\n⊢ iSupIndep t","decl":"@[deprecated (since := \"2024-11-24\")] alias CompleteLattice.Independent.mono := iSupIndep.mono\n\n"}
{"name":"iSupIndep.comp","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nι : Sort u_5\nι' : Sort u_6\nt : ι → α\nf : ι' → ι\nht : iSupIndep t\nhf : Function.Injective f\n⊢ iSupIndep (Function.comp t f)","decl":"/-- Composing an independent indexed family with an injective function on the index results in\nanother indepedendent indexed family. -/\ntheorem iSupIndep.comp {ι ι' : Sort*} {t : ι → α} {f : ι' → ι} (ht : iSupIndep t)\n    (hf : Injective f) : iSupIndep (t ∘ f) := fun i =>\n  (ht (f i)).mono_right <| by\n    refine (iSup_mono fun i => ?_).trans (iSup_comp_le _ f)\n    exact iSup_const_mono hf.ne\n\n"}
{"name":"CompleteLattice.Independent.comp","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nι : Sort u_5\nι' : Sort u_6\nt : ι → α\nf : ι' → ι\nht : iSupIndep t\nhf : Function.Injective f\n⊢ iSupIndep (Function.comp t f)","decl":"@[deprecated (since := \"2024-11-24\")] alias CompleteLattice.Independent.comp := iSupIndep.comp\n\n"}
{"name":"iSupIndep.comp'","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nι : Sort u_5\nι' : Sort u_6\nt : ι → α\nf : ι' → ι\nht : iSupIndep (Function.comp t f)\nhf : Function.Surjective f\n⊢ iSupIndep t","decl":"theorem iSupIndep.comp' {ι ι' : Sort*} {t : ι → α} {f : ι' → ι} (ht : iSupIndep <| t ∘ f)\n    (hf : Surjective f) : iSupIndep t := by\n  intro i\n  obtain ⟨i', rfl⟩ := hf i\n  rw [← hf.iSup_comp]\n  exact (ht i').mono_right (biSup_mono fun j' hij => mt (congr_arg f) hij)\n\n"}
{"name":"CompleteLattice.Independent.comp'","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nι : Sort u_5\nι' : Sort u_6\nt : ι → α\nf : ι' → ι\nht : iSupIndep (Function.comp t f)\nhf : Function.Surjective f\n⊢ iSupIndep t","decl":"@[deprecated (since := \"2024-11-24\")] alias CompleteLattice.Independent.comp' := iSupIndep.comp'\n\n"}
{"name":"iSupIndep.sSupIndep_range","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\nt : ι → α\nht : iSupIndep t\n⊢ sSupIndep (Set.range t)","decl":"theorem iSupIndep.sSupIndep_range (ht : iSupIndep t) : sSupIndep <| range t := by\n  rw [sSupIndep_iff]\n  rw [← coe_comp_rangeFactorization t] at ht\n  exact ht.comp' surjective_onto_range\n\n"}
{"name":"CompleteLattice.Independent.setIndependent_range","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\nt : ι → α\nht : iSupIndep t\n⊢ sSupIndep (Set.range t)","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.Independent.setIndependent_range := iSupIndep.sSupIndep_range\n\n"}
{"name":"iSupIndep_ne_bot","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\nt : ι → α\n⊢ Iff (iSupIndep fun i => t ↑i) (iSupIndep t)","decl":"@[simp]\ntheorem iSupIndep_ne_bot :\n    iSupIndep (fun i : {i // t i ≠ ⊥} ↦ t i) ↔ iSupIndep t := by\n  refine ⟨fun h ↦ ?_, fun h ↦ h.comp Subtype.val_injective⟩\n  simp only [iSupIndep_def] at h ⊢\n  intro i\n  cases eq_or_ne (t i) ⊥ with\n  | inl hi => simp [hi]\n  | inr hi => ?_\n  convert h ⟨i, hi⟩\n  have : ∀ j, ⨆ (_ : t j = ⊥), t j = ⊥ := fun j ↦ by simp only [iSup_eq_bot, imp_self]\n  rw [iSup_split _ (fun j ↦ t j = ⊥), iSup_subtype]\n  simp only [iSup_comm (ι' := _ ≠ i), this, ne_eq, sup_of_le_right, Subtype.mk.injEq, iSup_bot,\n    bot_le]\n\n"}
{"name":"CompleteLattice.independent_ne_bot_iff_independent","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\nt : ι → α\n⊢ Iff (iSupIndep fun i => t ↑i) (iSupIndep t)","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.independent_ne_bot_iff_independent := iSupIndep_ne_bot\n\n"}
{"name":"iSupIndep.injOn","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\nt : ι → α\nht : iSupIndep t\n⊢ Set.InjOn t (setOf fun i => Ne (t i) Bot.bot)","decl":"theorem iSupIndep.injOn (ht : iSupIndep t) : InjOn t {i | t i ≠ ⊥} := by\n  rintro i _ j (hj : t j ≠ ⊥) h\n  by_contra! contra\n  apply hj\n  suffices t j ≤ ⨆ (k) (_ : k ≠ i), t k by\n    replace ht := (ht i).mono_right this\n    rwa [h, disjoint_self] at ht\n  replace contra : j ≠ i := Ne.symm contra\n  -- Porting note: needs explicit `f`\n  exact le_iSup₂ (f := fun x _ ↦ t x) j contra\n\n"}
{"name":"CompleteLattice.Independent.injOn","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\nt : ι → α\nht : iSupIndep t\n⊢ Set.InjOn t (setOf fun i => Ne (t i) Bot.bot)","decl":"@[deprecated (since := \"2024-11-24\")] alias CompleteLattice.Independent.injOn := iSupIndep.injOn\n\n"}
{"name":"iSupIndep.injective","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\nt : ι → α\nht : iSupIndep t\nh_ne_bot : ∀ (i : ι), Ne (t i) Bot.bot\n⊢ Function.Injective t","decl":"theorem iSupIndep.injective (ht : iSupIndep t) (h_ne_bot : ∀ i, t i ≠ ⊥) : Injective t := by\n  suffices univ = {i | t i ≠ ⊥} by rw [injective_iff_injOn_univ, this]; exact ht.injOn\n  aesop\n\n"}
{"name":"CompleteLattice.Independent.injective","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\nt : ι → α\nht : iSupIndep t\nh_ne_bot : ∀ (i : ι), Ne (t i) Bot.bot\n⊢ Function.Injective t","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.Independent.injective := iSupIndep.injective\n\n"}
{"name":"iSupIndep_pair","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\nt : ι → α\ni j : ι\nhij : Ne i j\nhuniv : ∀ (k : ι), Or (Eq k i) (Eq k j)\n⊢ Iff (iSupIndep t) (Disjoint (t i) (t j))","decl":"theorem iSupIndep_pair {i j : ι} (hij : i ≠ j) (huniv : ∀ k, k = i ∨ k = j) :\n    iSupIndep t ↔ Disjoint (t i) (t j) := by\n  constructor\n  · exact fun h => h.pairwiseDisjoint hij\n  · rintro h k\n    obtain rfl | rfl := huniv k\n    · refine h.mono_right (iSup_le fun i => iSup_le fun hi => Eq.le ?_)\n      rw [(huniv i).resolve_left hi]\n    · refine h.symm.mono_right (iSup_le fun j => iSup_le fun hj => Eq.le ?_)\n      rw [(huniv j).resolve_right hj]\n\n"}
{"name":"CompleteLattice.independent_pair","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\nt : ι → α\ni j : ι\nhij : Ne i j\nhuniv : ∀ (k : ι), Or (Eq k i) (Eq k j)\n⊢ Iff (iSupIndep t) (Disjoint (t i) (t j))","decl":"@[deprecated (since := \"2024-11-24\")] alias CompleteLattice.independent_pair := iSupIndep_pair\n\n"}
{"name":"iSupIndep.map_orderIso","module":"Mathlib.Order.SupIndep","initialProofState":"ι : Sort u_5\nα : Type u_6\nβ : Type u_7\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : OrderIso α β\na : ι → α\nha : iSupIndep a\n⊢ iSupIndep (Function.comp (⇑f) a)","decl":"/-- Composing an independent indexed family with an order isomorphism on the elements results in\nanother independent indexed family. -/\ntheorem iSupIndep.map_orderIso {ι : Sort*} {α β : Type*} [CompleteLattice α]\n    [CompleteLattice β] (f : α ≃o β) {a : ι → α} (ha : iSupIndep a) : iSupIndep (f ∘ a) :=\n  fun i => ((ha i).map_orderIso f).mono_right (f.monotone.le_map_iSup₂ _)\n\n"}
{"name":"CompleteLattice.Independent.map_orderIso","module":"Mathlib.Order.SupIndep","initialProofState":"ι : Sort u_5\nα : Type u_6\nβ : Type u_7\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : OrderIso α β\na : ι → α\nha : iSupIndep a\n⊢ iSupIndep (Function.comp (⇑f) a)","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.Independent.map_orderIso := iSupIndep.map_orderIso\n\n"}
{"name":"iSupIndep_map_orderIso_iff","module":"Mathlib.Order.SupIndep","initialProofState":"ι : Sort u_5\nα : Type u_6\nβ : Type u_7\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : OrderIso α β\na : ι → α\n⊢ Iff (iSupIndep (Function.comp (⇑f) a)) (iSupIndep a)","decl":"@[simp]\ntheorem iSupIndep_map_orderIso_iff {ι : Sort*} {α β : Type*} [CompleteLattice α]\n    [CompleteLattice β] (f : α ≃o β) {a : ι → α} : iSupIndep (f ∘ a) ↔ iSupIndep a :=\n  ⟨fun h =>\n    have hf : f.symm ∘ f ∘ a = a := congr_arg (· ∘ a) f.left_inv.comp_eq_id\n    hf ▸ h.map_orderIso f.symm,\n    fun h => h.map_orderIso f⟩\n\n"}
{"name":"CompleteLattice.independent_map_orderIso_iff","module":"Mathlib.Order.SupIndep","initialProofState":"ι : Sort u_5\nα : Type u_6\nβ : Type u_7\ninst✝¹ : CompleteLattice α\ninst✝ : CompleteLattice β\nf : OrderIso α β\na : ι → α\n⊢ Iff (iSupIndep (Function.comp (⇑f) a)) (iSupIndep a)","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.independent_map_orderIso_iff := iSupIndep_map_orderIso_iff\n\n"}
{"name":"iSupIndep.disjoint_biSup","module":"Mathlib.Order.SupIndep","initialProofState":"ι : Type u_5\nα : Type u_6\ninst✝ : CompleteLattice α\nt : ι → α\nht : iSupIndep t\nx : ι\ny : Set ι\nhx : Not (Membership.mem y x)\n⊢ Disjoint (t x) (iSup fun i => iSup fun h => t i)","decl":"/-- If the elements of a set are independent, then any element is disjoint from the `iSup` of some\nsubset of the rest. -/\ntheorem iSupIndep.disjoint_biSup {ι : Type*} {α : Type*} [CompleteLattice α] {t : ι → α}\n    (ht : iSupIndep t) {x : ι} {y : Set ι} (hx : x ∉ y) : Disjoint (t x) (⨆ i ∈ y, t i) :=\n  Disjoint.mono_right (biSup_mono fun _ hi => (ne_of_mem_of_not_mem hi hx :)) (ht x)\n\n"}
{"name":"CompleteLattice.Independent.disjoint_biSup","module":"Mathlib.Order.SupIndep","initialProofState":"ι : Type u_5\nα : Type u_6\ninst✝ : CompleteLattice α\nt : ι → α\nht : iSupIndep t\nx : ι\ny : Set ι\nhx : Not (Membership.mem y x)\n⊢ Disjoint (t x) (iSup fun i => iSup fun h => t i)","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.Independent.disjoint_biSup := iSupIndep.disjoint_biSup\n\n"}
{"name":"iSupIndep.of_coe_Iic_comp","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nι : Sort u_5\na : α\nt : ι → ↑(Set.Iic a)\nht : iSupIndep (Function.comp Subtype.val t)\n⊢ iSupIndep t","decl":"lemma iSupIndep.of_coe_Iic_comp {ι : Sort*} {a : α} {t : ι → Set.Iic a}\n    (ht : iSupIndep ((↑) ∘ t : ι → α)) : iSupIndep t := by\n  intro i x\n  specialize ht i\n  simp_rw [Function.comp_apply, ← Set.Iic.coe_iSup] at ht\n  exact @ht x\n\n"}
{"name":"CompleteLattice.independent_of_independent_coe_Iic_comp","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nι : Sort u_5\na : α\nt : ι → ↑(Set.Iic a)\nht : iSupIndep (Function.comp Subtype.val t)\n⊢ iSupIndep t","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.independent_of_independent_coe_Iic_comp := iSupIndep.of_coe_Iic_comp\n\n"}
{"name":"iSupIndep_iff_supIndep","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\ns : Finset ι\nf : ι → α\n⊢ Iff (iSupIndep (Function.comp f Subtype.val)) (s.SupIndep f)","decl":"theorem iSupIndep_iff_supIndep {s : Finset ι} {f : ι → α} :\n    iSupIndep (f ∘ ((↑) : s → ι)) ↔ s.SupIndep f := by\n  classical\n    rw [Finset.supIndep_iff_disjoint_erase]\n    refine Subtype.forall.trans (forall₂_congr fun a b => ?_)\n    rw [Finset.sup_eq_iSup]\n    congr! 1\n    refine iSup_subtype.trans ?_\n    congr! 1\n    simp [iSup_and, @iSup_comm _ (_ ∈ s)]\n\n"}
{"name":"CompleteLattice.independent_iff_supIndep","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\ns : Finset ι\nf : ι → α\n⊢ Iff (iSupIndep (Function.comp f Subtype.val)) (s.SupIndep f)","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.independent_iff_supIndep := iSupIndep_iff_supIndep\n\n"}
{"name":"Finset.SupIndep.independent","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\ns : Finset ι\nf : ι → α\na✝ : s.SupIndep f\n⊢ iSupIndep (Function.comp f Subtype.val)","decl":"alias ⟨iSupIndep.supIndep, Finset.SupIndep.independent⟩ := iSupIndep_iff_supIndep\n\n"}
{"name":"iSupIndep.supIndep","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\ns : Finset ι\nf : ι → α\na✝ : iSupIndep (Function.comp f Subtype.val)\n⊢ s.SupIndep f","decl":"alias ⟨iSupIndep.supIndep, Finset.SupIndep.independent⟩ := iSupIndep_iff_supIndep\n\n"}
{"name":"iSupIndep.supIndep'","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\nf : ι → α\ns : Finset ι\nh : iSupIndep f\n⊢ s.SupIndep f","decl":"theorem iSupIndep.supIndep' {f : ι → α} (s : Finset ι) (h : iSupIndep f) : s.SupIndep f :=\n  iSupIndep.supIndep (h.comp Subtype.coe_injective)\n\n"}
{"name":"CompleteLattice.Independent.supIndep'","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : CompleteLattice α\nf : ι → α\ns : Finset ι\nh : iSupIndep f\n⊢ s.SupIndep f","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.Independent.supIndep' := iSupIndep.supIndep'\n\n"}
{"name":"iSupIndep_iff_supIndep_univ","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝¹ : CompleteLattice α\ninst✝ : Fintype ι\nf : ι → α\n⊢ Iff (iSupIndep f) (Finset.univ.SupIndep f)","decl":"/-- A variant of `CompleteLattice.iSupIndep_iff_supIndep` for `Fintype`s. -/\ntheorem iSupIndep_iff_supIndep_univ [Fintype ι] {f : ι → α} :\n    iSupIndep f ↔ Finset.univ.SupIndep f := by\n  classical\n    simp [Finset.supIndep_iff_disjoint_erase, iSupIndep, Finset.sup_eq_iSup]\n\n"}
{"name":"CompleteLattice.independent_iff_supIndep_univ","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝¹ : CompleteLattice α\ninst✝ : Fintype ι\nf : ι → α\n⊢ Iff (iSupIndep f) (Finset.univ.SupIndep f)","decl":"@[deprecated (since := \"2024-11-24\")]\nalias CompleteLattice.independent_iff_supIndep_univ := iSupIndep_iff_supIndep_univ\n\n"}
{"name":"Finset.SupIndep.iSupIndep_of_univ","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝¹ : CompleteLattice α\ninst✝ : Fintype ι\nf : ι → α\na✝ : Finset.univ.SupIndep f\n⊢ iSupIndep f","decl":"alias ⟨iSupIndep.sup_indep_univ, Finset.SupIndep.iSupIndep_of_univ⟩ := iSupIndep_iff_supIndep_univ\n\n"}
{"name":"iSupIndep.sup_indep_univ","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝¹ : CompleteLattice α\ninst✝ : Fintype ι\nf : ι → α\na✝ : iSupIndep f\n⊢ Finset.univ.SupIndep f","decl":"alias ⟨iSupIndep.sup_indep_univ, Finset.SupIndep.iSupIndep_of_univ⟩ := iSupIndep_iff_supIndep_univ\n\n"}
{"name":"sSupIndep_iff_pairwiseDisjoint","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : Order.Frame α\ns : Set α\n⊢ Iff (sSupIndep s) (s.PairwiseDisjoint id)","decl":"theorem sSupIndep_iff_pairwiseDisjoint {s : Set α} : sSupIndep s ↔ s.PairwiseDisjoint id :=\n  ⟨sSupIndep.pairwiseDisjoint, fun hs _ hi =>\n    disjoint_sSup_iff.2 fun _ hj => hs hi hj.1 <| Ne.symm hj.2⟩\n\n"}
{"name":"setIndependent_iff_pairwiseDisjoint","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : Order.Frame α\ns : Set α\n⊢ Iff (sSupIndep s) (s.PairwiseDisjoint id)","decl":"@[deprecated (since := \"2024-11-24\")]\nalias setIndependent_iff_pairwiseDisjoint := sSupIndep_iff_pairwiseDisjoint\n\n"}
{"name":"Set.PairwiseDisjoint.sSupIndep","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\ninst✝ : Order.Frame α\ns : Set α\na✝ : s.PairwiseDisjoint id\n⊢ sSupIndep s","decl":"alias ⟨_, _root_.Set.PairwiseDisjoint.sSupIndep⟩ := sSupIndep_iff_pairwiseDisjoint\n\n"}
{"name":"iSupIndep_iff_pairwiseDisjoint","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : Order.Frame α\nf : ι → α\n⊢ Iff (iSupIndep f) (Pairwise (Function.onFun Disjoint f))","decl":"open scoped Function in -- required for scoped `on` notation\ntheorem iSupIndep_iff_pairwiseDisjoint {f : ι → α} : iSupIndep f ↔ Pairwise (Disjoint on f) :=\n  ⟨iSupIndep.pairwiseDisjoint, fun hs _ =>\n    disjoint_iSup_iff.2 fun _ => disjoint_iSup_iff.2 fun hij => hs hij.symm⟩\n\n"}
{"name":"independent_iff_pairwiseDisjoint","module":"Mathlib.Order.SupIndep","initialProofState":"α : Type u_1\nι : Type u_3\ninst✝ : Order.Frame α\nf : ι → α\n⊢ Iff (iSupIndep f) (Pairwise (Function.onFun Disjoint f))","decl":"@[deprecated (since := \"2024-11-24\")]\nalias independent_iff_pairwiseDisjoint := iSupIndep_iff_pairwiseDisjoint\n\n"}
