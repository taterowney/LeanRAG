{"name":"Module.Projective.out","module":"Mathlib.Algebra.Module.Projective","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nP : Type u_2\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\nself : Module.Projective R P\n⊢ Exists fun s => Function.LeftInverse ⇑(Finsupp.linearCombination R id) ⇑s","decl":"/-- An R-module is projective if it is a direct summand of a free module, or equivalently\n  if maps from the module lift along surjections. There are several other equivalent\n  definitions. -/\nclass Module.Projective (R : Type*) [Semiring R] (P : Type*) [AddCommMonoid P] [Module R P] :\n    Prop where\n  out : ∃ s : P →ₗ[R] P →₀ R, Function.LeftInverse (Finsupp.linearCombination R id) s\n\n"}
{"name":"Module.projective_def","module":"Mathlib.Algebra.Module.Projective","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nP : Type u_2\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\n⊢ Iff (Module.Projective R P) (Exists fun s => Function.LeftInverse ⇑(Finsupp.linearCombination R id) ⇑s)","decl":"theorem projective_def :\n    Projective R P ↔ ∃ s : P →ₗ[R] P →₀ R, Function.LeftInverse (linearCombination R id) s :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n\n"}
{"name":"Module.projective_def'","module":"Mathlib.Algebra.Module.Projective","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nP : Type u_2\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\n⊢ Iff (Module.Projective R P) (Exists fun s => Eq ((Finsupp.linearCombination R id).comp s) LinearMap.id)","decl":"theorem projective_def' :\n    Projective R P ↔ ∃ s : P →ₗ[R] P →₀ R, Finsupp.linearCombination R id ∘ₗ s = .id := by\n  simp_rw [projective_def, DFunLike.ext_iff, Function.LeftInverse, comp_apply, id_apply]\n\n"}
{"name":"Module.projective_lifting_property","module":"Mathlib.Algebra.Module.Projective","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nP : Type u_2\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module R P\nM : Type u_3\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_4\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nh : Module.Projective R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) P N\nhf : Function.Surjective ⇑f\n⊢ Exists fun h => Eq (f.comp h) g","decl":"/-- A projective R-module has the property that maps from it lift along surjections. -/\ntheorem projective_lifting_property [h : Projective R P] (f : M →ₗ[R] N) (g : P →ₗ[R] N)\n    (hf : Function.Surjective f) : ∃ h : P →ₗ[R] M, f ∘ₗ h = g := by\n  /-\n    Here's the first step of the proof.\n    Recall that `X →₀ R` is Lean's way of talking about the free `R`-module\n    on a type `X`. The universal property `Finsupp.linearCombination` says that to a map\n    `X → N` from a type to an `R`-module, we get an associated R-module map\n    `(X →₀ R) →ₗ N`. Apply this to a (noncomputable) map `P → M` coming from the map\n    `P →ₗ N` and a random splitting of the surjection `M →ₗ N`, and we get\n    a map `φ : (P →₀ R) →ₗ M`.\n    -/\n  let φ : (P →₀ R) →ₗ[R] M := Finsupp.linearCombination _ fun p => Function.surjInv hf (g p)\n  -- By projectivity we have a map `P →ₗ (P →₀ R)`;\n  cases' h.out with s hs\n  -- Compose to get `P →ₗ M`. This works.\n  use φ.comp s\n  ext p\n  conv_rhs => rw [← hs p]\n  simp [φ, Finsupp.linearCombination_apply, Function.surjInv_eq hf, map_finsupp_sum]\n\n"}
{"name":"LinearMap.exists_rightInverse_of_surjective","module":"Mathlib.Algebra.Module.Projective","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nP : Type u_2\ninst✝⁴ : AddCommMonoid P\ninst✝³ : Module R P\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Projective R P\nf : LinearMap (RingHom.id R) M P\nhf_surj : Eq (LinearMap.range f) Top.top\n⊢ Exists fun g => Eq (f.comp g) LinearMap.id","decl":"theorem _root_.LinearMap.exists_rightInverse_of_surjective [Projective R P]\n    (f : M →ₗ[R] P) (hf_surj : range f = ⊤) : ∃ g : P →ₗ[R] M, f ∘ₗ g = LinearMap.id :=\n  projective_lifting_property f (.id : P →ₗ[R] P) (LinearMap.range_eq_top.1 hf_surj)\n\n"}
{"name":"Module.Projective.of_lifting_property''","module":"Mathlib.Algebra.Module.Projective","initialProofState":"R : Type u\ninst✝² : Semiring R\nP : Type v\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\nhuniv : ∀ (f : LinearMap (RingHom.id R) (Finsupp P R) P), Function.Surjective ⇑f → Exists fun h => Eq (f.comp h) LinearMap.id\n⊢ Module.Projective R P","decl":"/-- A module which satisfies the universal property is projective: If all surjections of\n`R`-modules `(P →₀ R) →ₗ[R] P` have `R`-linear left inverse maps, then `P` is\nprojective. -/\ntheorem Projective.of_lifting_property'' {R : Type u} [Semiring R] {P : Type v} [AddCommMonoid P]\n    [Module R P] (huniv : ∀ (f : (P →₀ R) →ₗ[R] P), Function.Surjective f →\n      ∃ h : P →ₗ[R] (P →₀ R), f.comp h = .id) :\n    Projective R P :=\n  projective_def'.2 <| huniv (Finsupp.linearCombination R (id : P → P))\n    (linearCombination_surjective _ Function.surjective_id)\n\n"}
{"name":"Module.instProjectiveProd","module":"Mathlib.Algebra.Module.Projective","initialProofState":"R : Type u_1\ninst✝⁶ : Semiring R\nP : Type u_2\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module R P\nQ : Type u_5\ninst✝³ : AddCommMonoid Q\ninst✝² : Module R Q\ninst✝¹ : Module.Projective R P\ninst✝ : Module.Projective R Q\n⊢ Module.Projective R (Prod P Q)","decl":"instance [Projective R P] [Projective R Q] : Projective R (P × Q) := by\n  refine .of_lifting_property'' fun f hf ↦ ?_\n  rcases projective_lifting_property f (.inl _ _ _) hf with ⟨g₁, hg₁⟩\n  rcases projective_lifting_property f (.inr _ _ _) hf with ⟨g₂, hg₂⟩\n  refine ⟨coprod g₁ g₂, ?_⟩\n  rw [LinearMap.comp_coprod, hg₁, hg₂, LinearMap.coprod_inl_inr]\n\n"}
{"name":"Module.instProjectiveDFinsupp","module":"Mathlib.Algebra.Module.Projective","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nι : Type u_6\nA : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (A i)\ninst✝ : (i : ι) → Module R (A i)\nh : ∀ (i : ι), Module.Projective R (A i)\n⊢ Module.Projective R (DFinsupp fun i => A i)","decl":"instance [h : ∀ i : ι, Projective R (A i)] : Projective R (Π₀ i, A i) :=\n  .of_lifting_property'' fun f hf ↦ by\n    classical\n      choose g hg using fun i ↦ projective_lifting_property f (DFinsupp.lsingle i) hf\n      replace hg : ∀ i x, f (g i x) = DFinsupp.single i x := fun i ↦ DFunLike.congr_fun (hg i)\n      refine ⟨DFinsupp.coprodMap g, ?_⟩\n      ext i x j\n      simp only [comp_apply, id_apply, DFinsupp.lsingle_apply, DFinsupp.coprodMap_apply_single, hg]\n\n"}
{"name":"Module.Projective.of_basis","module":"Mathlib.Algebra.Module.Projective","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nP : Type u_2\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\nι : Type u_8\nb : Basis ι R P\n⊢ Module.Projective R P","decl":"/-- Free modules are projective. -/\ntheorem Projective.of_basis {ι : Type*} (b : Basis ι R P) : Projective R P := by\n  -- need P →ₗ (P →₀ R) for definition of projective.\n  -- get it from `ι → (P →₀ R)` coming from `b`.\n  use b.constr ℕ fun i => Finsupp.single (b i) (1 : R)\n  intro m\n  simp only [b.constr_apply, mul_one, id, Finsupp.smul_single', Finsupp.linearCombination_single,\n    map_finsupp_sum]\n  exact b.linearCombination_repr m\n\n"}
{"name":"Module.Projective.of_free","module":"Mathlib.Algebra.Module.Projective","initialProofState":"R : Type u_1\ninst✝³ : Semiring R\nP : Type u_2\ninst✝² : AddCommMonoid P\ninst✝¹ : Module R P\ninst✝ : Module.Free R P\n⊢ Module.Projective R P","decl":"instance (priority := 100) Projective.of_free [Module.Free R P] : Module.Projective R P :=\n  .of_basis <| Module.Free.chooseBasis R P\n\n"}
{"name":"Module.Projective.of_split","module":"Mathlib.Algebra.Module.Projective","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nP : Type u_2\ninst✝⁴ : AddCommMonoid P\ninst✝³ : Module R P\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Projective R M\ni : LinearMap (RingHom.id R) P M\ns : LinearMap (RingHom.id R) M P\nH : Eq (s.comp i) LinearMap.id\n⊢ Module.Projective R P","decl":"/-- A direct summand of a projective module is projective. -/\ntheorem Projective.of_split [Module.Projective R M]\n    (i : P →ₗ[R] M) (s : M →ₗ[R] P) (H : s.comp i = LinearMap.id) : Module.Projective R P := by\n  obtain ⟨g, hg⟩ := projective_lifting_property (Finsupp.linearCombination R id) s\n    (fun x ↦ ⟨Finsupp.single x 1, by simp⟩)\n  refine ⟨g.comp i, fun x ↦ ?_⟩\n  rw [LinearMap.comp_apply, ← LinearMap.comp_apply, hg,\n    ← LinearMap.comp_apply, H, LinearMap.id_apply]\n\n"}
{"name":"Module.Projective.of_equiv","module":"Mathlib.Algebra.Module.Projective","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nP : Type u_2\ninst✝⁴ : AddCommMonoid P\ninst✝³ : Module R P\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Projective R M\ne : LinearEquiv (RingHom.id R) M P\n⊢ Module.Projective R P","decl":"theorem Projective.of_equiv [Module.Projective R M]\n    (e : M ≃ₗ[R] P) : Module.Projective R P :=\n  Projective.of_split e.symm e.toLinearMap (by ext; simp)\n\n"}
{"name":"Module.Projective.iff_split_of_projective","module":"Mathlib.Algebra.Module.Projective","initialProofState":"R : Type u_1\ninst✝⁵ : Semiring R\nP : Type u_2\ninst✝⁴ : AddCommMonoid P\ninst✝³ : Module R P\nM : Type u_3\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Projective R M\ns : LinearMap (RingHom.id R) M P\nhs : Function.Surjective ⇑s\n⊢ Iff (Module.Projective R P) (Exists fun i => Eq (s.comp i) LinearMap.id)","decl":"/-- A quotient of a projective module is projective iff it is a direct summand. -/\ntheorem Projective.iff_split_of_projective [Module.Projective R M] (s : M →ₗ[R] P)\n    (hs : Function.Surjective s) :\n    Module.Projective R P ↔ ∃ i, s ∘ₗ i = LinearMap.id :=\n  ⟨fun _ ↦ projective_lifting_property _ _ hs, fun ⟨i, H⟩ ↦ Projective.of_split i s H⟩\n\n"}
{"name":"Module.Projective.of_ringEquiv","module":"Mathlib.Algebra.Module.Projective","initialProofState":"R : Type u_8\nS : Type u_9\ninst✝⁶ : Semiring R\ninst✝⁵ : Semiring S\nM : Type u_10\nN : Type u_11\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid N\ninst✝² : Module R M\ninst✝¹ : Module S N\ne₁ : RingEquiv R S\ne₂ : LinearEquiv (↑e₁) M N\ninst✝ : Module.Projective R M\n⊢ Module.Projective S N","decl":"attribute [local instance] RingHomInvPair.of_ringEquiv in\ntheorem Projective.of_ringEquiv {R S} [Semiring R] [Semiring S] {M N}\n    [AddCommMonoid M] [AddCommMonoid N] [Module R M] [Module S N]\n    (e₁ : R ≃+* S) (e₂ : M ≃ₛₗ[RingHomClass.toRingHom e₁] N)\n    [Projective R M] : Projective S N := by\n  obtain ⟨f, hf⟩ := ‹Projective R M›\n  let g : N →ₗ[S] N →₀ S :=\n  { toFun := fun x ↦ (equivCongrLeft e₂ (f (e₂.symm x))).mapRange e₁ e₁.map_zero\n    map_add' := fun x y ↦ by ext; simp\n    map_smul' := fun r v ↦ by ext i; simp [e₂.symm.map_smulₛₗ] }\n  refine ⟨⟨g, fun x ↦ ?_⟩⟩\n  replace hf := congr(e₂ $(hf (e₂.symm x)))\n  simpa [linearCombination_apply, sum_mapRange_index, g, map_finsupp_sum, e₂.map_smulₛₗ] using hf\n\n"}
{"name":"Module.Projective.iff_split","module":"Mathlib.Algebra.Module.Projective","initialProofState":"R : Type u\ninst✝² : Semiring R\nP : Type v\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\n⊢ Iff (Module.Projective R P) (Exists fun M => Exists fun x => Exists fun x_1 => Exists fun x_2 => Exists fun i => Exists fun s => Eq (s.comp i) LinearMap.id)","decl":"/-- A module is projective iff it is the direct summand of a free module. -/\ntheorem Projective.iff_split : Module.Projective R P ↔\n    ∃ (M : Type max u v) (_ : AddCommMonoid M) (_ : Module R M) (_ : Module.Free R M)\n      (i : P →ₗ[R] M) (s : M →ₗ[R] P), s.comp i = LinearMap.id :=\n  ⟨fun ⟨i, hi⟩ ↦ ⟨P →₀ R, _, _, inferInstance, i, Finsupp.linearCombination R id, LinearMap.ext hi⟩,\n    fun ⟨_, _, _, _, i, s, H⟩ ↦ Projective.of_split i s H⟩\n\n"}
{"name":"Module.Projective.tensorProduct","module":"Mathlib.Algebra.Module.Projective","initialProofState":"R : Type u\ninst✝⁸ : Semiring R\nR₀ : Type u_2\nM : Type u_1\nN : Type u_3\ninst✝⁷ : CommSemiring R₀\ninst✝⁶ : Algebra R₀ R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R₀ M\ninst✝³ : Module R M\ninst✝² : IsScalarTower R₀ R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R₀ N\nhM : Module.Projective R M\nhN : Module.Projective R₀ N\n⊢ Module.Projective R (TensorProduct R₀ M N)","decl":"set_option maxSynthPendingDepth 2 in\nopen TensorProduct in\ninstance Projective.tensorProduct [hM : Module.Projective R M] [hN : Module.Projective R₀ N] :\n    Module.Projective R (M ⊗[R₀] N) := by\n  obtain ⟨sM, hsM⟩ := hM\n  obtain ⟨sN, hsN⟩ := hN\n  have : Module.Projective R (M ⊗[R₀] (N →₀ R₀)) := by\n    fapply Projective.of_split (R := R) (M := ((M →₀ R) ⊗[R₀] (N →₀ R₀)))\n    · exact (AlgebraTensorModule.map sM (LinearMap.id (R := R₀) (M := N →₀ R₀)))\n    · exact (AlgebraTensorModule.map\n        (Finsupp.linearCombination R id) (LinearMap.id (R := R₀) (M := N →₀ R₀)))\n    · ext; simp [hsM _]\n  fapply Projective.of_split (R := R) (M := (M ⊗[R₀] (N →₀ R₀)))\n  · exact (AlgebraTensorModule.map (LinearMap.id (R := R) (M := M)) sN)\n  · exact (AlgebraTensorModule.map (LinearMap.id (R := R) (M := M)) (linearCombination R₀ id))\n  · ext; simp [hsN _]\n\n"}
{"name":"Module.Projective.of_lifting_property'","module":"Mathlib.Algebra.Module.Projective","initialProofState":"R : Type u\ninst✝² : Semiring R\nP : Type (max u v)\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\nhuniv : ∀ {M : Type (max v u)} {N : Type (max u v)} [inst : AddCommMonoid M] [inst_1 : AddCommMonoid N] [inst_2 : Module R M] [inst_3 : Module R N] (f : LinearMap (RingHom.id R) M N) (g : LinearMap (RingHom.id R) P N), Function.Surjective ⇑f → Exists fun h => Eq (f.comp h) g\n⊢ Module.Projective R P","decl":"/-- A module which satisfies the universal property is projective. Note that the universe variables\nin `huniv` are somewhat restricted. -/\ntheorem Projective.of_lifting_property' {R : Type u} [Semiring R] {P : Type max u v}\n    [AddCommMonoid P] [Module R P]\n    -- If for all surjections of `R`-modules `M →ₗ N`, all maps `P →ₗ N` lift to `P →ₗ M`,\n    (huniv : ∀ {M : Type max v u} {N : Type max u v} [AddCommMonoid M] [AddCommMonoid N]\n      [Module R M] [Module R N] (f : M →ₗ[R] N) (g : P →ₗ[R] N),\n        Function.Surjective f → ∃ h : P →ₗ[R] M, f.comp h = g) :\n    -- then `P` is projective.\n    Projective R P :=\n  .of_lifting_property'' (huniv · _)\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: generalize to `P : Type v`?\n"}
{"name":"Module.Projective.of_lifting_property","module":"Mathlib.Algebra.Module.Projective","initialProofState":"R : Type u\ninst✝² : Ring R\nP : Type (max u v)\ninst✝¹ : AddCommGroup P\ninst✝ : Module R P\nhuniv : ∀ {M : Type (max v u)} {N : Type (max u v)} [inst : AddCommGroup M] [inst_1 : AddCommGroup N] [inst_2 : Module R M] [inst_3 : Module R N] (f : LinearMap (RingHom.id R) M N) (g : LinearMap (RingHom.id R) P N), Function.Surjective ⇑f → Exists fun h => Eq (f.comp h) g\n⊢ Module.Projective R P","decl":"/-- A variant of `of_lifting_property'` when we're working over a `[Ring R]`,\nwhich only requires quantifying over modules with an `AddCommGroup` instance. -/\ntheorem Projective.of_lifting_property {R : Type u} [Ring R] {P : Type max u v} [AddCommGroup P]\n    [Module R P]\n    -- If for all surjections of `R`-modules `M →ₗ N`, all maps `P →ₗ N` lift to `P →ₗ M`,\n    (huniv : ∀ {M : Type max v u} {N : Type max u v} [AddCommGroup M] [AddCommGroup N]\n      [Module R M] [Module R N] (f : M →ₗ[R] N) (g : P →ₗ[R] N),\n        Function.Surjective f → ∃ h : P →ₗ[R] M, f.comp h = g) :\n    -- then `P` is projective.\n    Projective R P :=\n  .of_lifting_property'' (huniv · _)\n\n"}
