{"name":"harmonic_zero","module":"Mathlib.NumberTheory.Harmonic.Defs","initialProofState":"⊢ Eq (harmonic 0) 0","decl":"@[simp]\nlemma harmonic_zero : harmonic 0 = 0 :=\n  rfl\n\n"}
{"name":"harmonic_succ","module":"Mathlib.NumberTheory.Harmonic.Defs","initialProofState":"n : Nat\n⊢ Eq (harmonic (HAdd.hAdd n 1)) (HAdd.hAdd (harmonic n) (Inv.inv ↑(HAdd.hAdd n 1)))","decl":"@[simp]\nlemma harmonic_succ (n : ℕ) : harmonic (n + 1) = harmonic n + (↑(n + 1))⁻¹ :=\n  Finset.sum_range_succ ..\n\n"}
{"name":"harmonic_pos","module":"Mathlib.NumberTheory.Harmonic.Defs","initialProofState":"n : Nat\nHn : Ne n 0\n⊢ LT.lt 0 (harmonic n)","decl":"lemma harmonic_pos {n : ℕ} (Hn : n ≠ 0) : 0 < harmonic n := by\n  unfold harmonic\n  rw [← Finset.nonempty_range_iff] at Hn\n  positivity\n\n\n"}
{"name":"harmonic_eq_sum_Icc","module":"Mathlib.NumberTheory.Harmonic.Defs","initialProofState":"n : Nat\n⊢ Eq (harmonic n) ((Finset.Icc 1 n).sum fun i => Inv.inv ↑i)","decl":"lemma harmonic_eq_sum_Icc {n : ℕ} :  harmonic n = ∑ i ∈ Finset.Icc 1 n, (↑i)⁻¹ := by\n  rw [harmonic, Finset.range_eq_Ico, Finset.sum_Ico_add' (fun (i : ℕ) ↦ (i : ℚ)⁻¹) 0 n (c := 1)]\n  -- It might be better to restate `Nat.Ico_succ_right` in terms of `+ 1`,\n  -- as we try to move away from `Nat.succ`.\n  simp only [Nat.add_one, Nat.Ico_succ_right]\n"}
