{"name":"LinearMap.BilinForm.isOrtho_def","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nx y : M\n⊢ Iff (B.IsOrtho x y) (Eq ((B x) y) 0)","decl":"theorem isOrtho_def {B : BilinForm R M} {x y : M} : B.IsOrtho x y ↔ B x y = 0 :=\n  Iff.rfl\n\n"}
{"name":"LinearMap.BilinForm.isOrtho_zero_left","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nx : M\n⊢ B.IsOrtho 0 x","decl":"theorem isOrtho_zero_left (x : M) : IsOrtho B (0 : M) x := LinearMap.isOrtho_zero_left B x\n\n"}
{"name":"LinearMap.BilinForm.isOrtho_zero_right","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nx : M\n⊢ B.IsOrtho x 0","decl":"theorem isOrtho_zero_right (x : M) : IsOrtho B x (0 : M) :=\n  zero_right x\n\n"}
{"name":"LinearMap.BilinForm.ne_zero_of_not_isOrtho_self","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nB : LinearMap.BilinForm K V\nx : V\nhx₁ : Not (B.IsOrtho x x)\n⊢ Ne x 0","decl":"theorem ne_zero_of_not_isOrtho_self {B : BilinForm K V} (x : V) (hx₁ : ¬B.IsOrtho x x) : x ≠ 0 :=\n  fun hx₂ => hx₁ (hx₂.symm ▸ isOrtho_zero_left _)\n\n"}
{"name":"LinearMap.BilinForm.IsRefl.ortho_comm","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nH : B.IsRefl\nx y : M\n⊢ Iff (B.IsOrtho x y) (B.IsOrtho y x)","decl":"theorem IsRefl.ortho_comm (H : B.IsRefl) {x y : M} : IsOrtho B x y ↔ IsOrtho B y x :=\n  ⟨eq_zero H, eq_zero H⟩\n\n"}
{"name":"LinearMap.BilinForm.IsAlt.ortho_comm","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"R₁ : Type u_3\nM₁ : Type u_4\ninst✝² : CommRing R₁\ninst✝¹ : AddCommGroup M₁\ninst✝ : Module R₁ M₁\nB₁ : LinearMap.BilinForm R₁ M₁\nH : B₁.IsAlt\nx y : M₁\n⊢ Iff (B₁.IsOrtho x y) (B₁.IsOrtho y x)","decl":"theorem IsAlt.ortho_comm (H : B₁.IsAlt) {x y : M₁} : IsOrtho B₁ x y ↔ IsOrtho B₁ y x :=\n  LinearMap.IsAlt.ortho_comm H\n\n"}
{"name":"LinearMap.BilinForm.IsSymm.ortho_comm","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nH : B.IsSymm\nx y : M\n⊢ Iff (B.IsOrtho x y) (B.IsOrtho y x)","decl":"theorem IsSymm.ortho_comm (H : B.IsSymm) {x y : M} : IsOrtho B x y ↔ IsOrtho B y x :=\n  LinearMap.IsSymm.ortho_comm H\n\n"}
{"name":"LinearMap.BilinForm.iIsOrtho_def","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nn : Type w\nB : LinearMap.BilinForm R M\nv : n → M\n⊢ Iff (B.iIsOrtho v) (∀ (i j : n), Ne i j → Eq ((B (v i)) (v j)) 0)","decl":"theorem iIsOrtho_def {n : Type w} {B : BilinForm R M} {v : n → M} :\n    B.iIsOrtho v ↔ ∀ i j : n, i ≠ j → B (v i) (v j) = 0 :=\n  Iff.rfl\n\n"}
{"name":"LinearMap.BilinForm.isOrtho_smul_left","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"R₄ : Type u_7\nM₄ : Type u_8\ninst✝³ : CommRing R₄\ninst✝² : IsDomain R₄\ninst✝¹ : AddCommGroup M₄\ninst✝ : Module R₄ M₄\nG : LinearMap.BilinForm R₄ M₄\nx y : M₄\na : R₄\nha : Ne a 0\n⊢ Iff (G.IsOrtho (HSMul.hSMul a x) y) (G.IsOrtho x y)","decl":"@[simp]\ntheorem isOrtho_smul_left {x y : M₄} {a : R₄} (ha : a ≠ 0) :\n    IsOrtho G (a • x) y ↔ IsOrtho G x y := by\n  dsimp only [IsOrtho]\n  rw [map_smul]\n  simp only [LinearMap.smul_apply, smul_eq_mul, mul_eq_zero, or_iff_right_iff_imp]\n  exact fun a ↦ (ha a).elim\n\n"}
{"name":"LinearMap.BilinForm.isOrtho_smul_right","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"R₄ : Type u_7\nM₄ : Type u_8\ninst✝³ : CommRing R₄\ninst✝² : IsDomain R₄\ninst✝¹ : AddCommGroup M₄\ninst✝ : Module R₄ M₄\nG : LinearMap.BilinForm R₄ M₄\nx y : M₄\na : R₄\nha : Ne a 0\n⊢ Iff (G.IsOrtho x (HSMul.hSMul a y)) (G.IsOrtho x y)","decl":"@[simp]\ntheorem isOrtho_smul_right {x y : M₄} {a : R₄} (ha : a ≠ 0) :\n    IsOrtho G x (a • y) ↔ IsOrtho G x y := by\n  dsimp only [IsOrtho]\n  rw [map_smul]\n  simp only [smul_eq_mul, mul_eq_zero, or_iff_right_iff_imp]\n  exact fun a ↦ (ha a).elim\n\n"}
{"name":"LinearMap.BilinForm.linearIndependent_of_iIsOrtho","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nn : Type w\nB : LinearMap.BilinForm K V\nv : n → V\nhv₁ : B.iIsOrtho v\nhv₂ : ∀ (i : n), Not (B.IsOrtho (v i) (v i))\n⊢ LinearIndependent K v","decl":"/-- A set of orthogonal vectors `v` with respect to some bilinear form `B` is linearly independent\n  if for all `i`, `B (v i) (v i) ≠ 0`. -/\ntheorem linearIndependent_of_iIsOrtho {n : Type w} {B : BilinForm K V} {v : n → V}\n    (hv₁ : B.iIsOrtho v) (hv₂ : ∀ i, ¬B.IsOrtho (v i) (v i)) : LinearIndependent K v := by\n  classical\n    rw [linearIndependent_iff']\n    intro s w hs i hi\n    have : B (s.sum fun i : n => w i • v i) (v i) = 0 := by rw [hs, zero_left]\n    have hsum : (s.sum fun j : n => w j * B (v j) (v i)) = w i * B (v i) (v i) := by\n      apply Finset.sum_eq_single_of_mem i hi\n      intro j _ hij\n      rw [iIsOrtho_def.1 hv₁ _ _ hij, mul_zero]\n    simp_rw [sum_left, smul_left, hsum] at this\n    exact eq_zero_of_ne_zero_of_mul_right_eq_zero (hv₂ i) this\n\n"}
{"name":"LinearMap.BilinForm.mem_orthogonal_iff","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nN : Submodule R M\nm : M\n⊢ Iff (Membership.mem (B.orthogonal N) m) (∀ (n : M), Membership.mem N n → B.IsOrtho n m)","decl":"@[simp]\ntheorem mem_orthogonal_iff {N : Submodule R M} {m : M} :\n    m ∈ B.orthogonal N ↔ ∀ n ∈ N, IsOrtho B n m :=\n  Iff.rfl\n\n"}
{"name":"LinearMap.BilinForm.orthogonal_bot","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\n⊢ Eq (B.orthogonal Bot.bot) Top.top","decl":"@[simp] lemma orthogonal_bot : B.orthogonal ⊥ = ⊤ := by ext; simp [IsOrtho]\n\n"}
{"name":"LinearMap.BilinForm.orthogonal_le","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nN L : Submodule R M\nh : LE.le N L\n⊢ LE.le (B.orthogonal L) (B.orthogonal N)","decl":"theorem orthogonal_le (h : N ≤ L) : B.orthogonal L ≤ B.orthogonal N := fun _ hn l hl => hn l (h hl)\n\n"}
{"name":"LinearMap.BilinForm.le_orthogonal_orthogonal","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nN : Submodule R M\nb : B.IsRefl\n⊢ LE.le N (B.orthogonal (B.orthogonal N))","decl":"theorem le_orthogonal_orthogonal (b : B.IsRefl) : N ≤ B.orthogonal (B.orthogonal N) :=\n  fun n hn _ hm => b _ _ (hm n hn)\n\n"}
{"name":"LinearMap.BilinForm.orthogonal_top_eq_ker","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nhB : B.IsRefl\n⊢ Eq (B.orthogonal Top.top) (LinearMap.ker B)","decl":"lemma orthogonal_top_eq_ker (hB : B.IsRefl) :\n    B.orthogonal ⊤ = LinearMap.ker B := by\n  ext; simp [LinearMap.BilinForm.IsOrtho, LinearMap.ext_iff, hB.eq_iff]\n\n"}
{"name":"LinearMap.BilinForm.orthogonal_top_eq_bot","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nhB : B.Nondegenerate\nhB₀ : B.IsRefl\n⊢ Eq (B.orthogonal Top.top) Bot.bot","decl":"lemma orthogonal_top_eq_bot (hB : B.Nondegenerate) (hB₀ : B.IsRefl) :\n    B.orthogonal ⊤ = ⊥ :=\n  (Submodule.eq_bot_iff _).mpr fun _ hx ↦ hB _ fun y ↦ hB₀ _ _ <| hx y Submodule.mem_top\n\n-- ↓ This lemma only applies in fields as we require `a * b = 0 → a = 0 ∨ b = 0`\n"}
{"name":"LinearMap.BilinForm.span_singleton_inf_orthogonal_eq_bot","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nB : LinearMap.BilinForm K V\nx : V\nhx : Not (B.IsOrtho x x)\n⊢ Eq (Min.min (Submodule.span K (Singleton.singleton x)) (B.orthogonal (Submodule.span K (Singleton.singleton x)))) Bot.bot","decl":"theorem span_singleton_inf_orthogonal_eq_bot {B : BilinForm K V} {x : V} (hx : ¬B.IsOrtho x x) :\n    (K ∙ x) ⊓ B.orthogonal (K ∙ x) = ⊥ := by\n  rw [← Finset.coe_singleton]\n  refine eq_bot_iff.2 fun y h => ?_\n  rcases mem_span_finset.1 h.1 with ⟨μ, rfl⟩\n  have := h.2 x ?_\n  · rw [Finset.sum_singleton] at this ⊢\n    suffices hμzero : μ x = 0 by rw [hμzero, zero_smul, Submodule.mem_bot]\n    change B x (μ x • x) = 0 at this\n    rw [smul_right] at this\n    exact eq_zero_of_ne_zero_of_mul_right_eq_zero hx this\n  · rw [Submodule.mem_span]\n    exact fun _ hp => hp <| Finset.mem_singleton_self _\n\n-- ↓ This lemma only applies in fields since we use the `mul_eq_zero`\n"}
{"name":"LinearMap.BilinForm.orthogonal_span_singleton_eq_toLin_ker","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nB : LinearMap.BilinForm K V\nx : V\n⊢ Eq (B.orthogonal (Submodule.span K (Singleton.singleton x))) (LinearMap.ker (B.toLinHomAux₁ x))","decl":"theorem orthogonal_span_singleton_eq_toLin_ker {B : BilinForm K V} (x : V) :\n    B.orthogonal (K ∙ x) = LinearMap.ker (LinearMap.BilinForm.toLinHomAux₁ B x) := by\n  ext y\n  simp_rw [mem_orthogonal_iff, LinearMap.mem_ker, Submodule.mem_span_singleton]\n  constructor\n  · exact fun h => h x ⟨1, one_smul _ _⟩\n  · rintro h _ ⟨z, rfl⟩\n    rw [IsOrtho, smul_left, mul_eq_zero]\n    exact Or.intro_right _ h\n\n"}
{"name":"LinearMap.BilinForm.span_singleton_sup_orthogonal_eq_top","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nB : LinearMap.BilinForm K V\nx : V\nhx : Not (B.IsOrtho x x)\n⊢ Eq (Max.max (Submodule.span K (Singleton.singleton x)) (B.orthogonal (Submodule.span K (Singleton.singleton x)))) Top.top","decl":"theorem span_singleton_sup_orthogonal_eq_top {B : BilinForm K V} {x : V} (hx : ¬B.IsOrtho x x) :\n    (K ∙ x) ⊔ B.orthogonal (K ∙ x) = ⊤ := by\n  rw [orthogonal_span_singleton_eq_toLin_ker]\n  exact LinearMap.span_singleton_sup_ker_eq_top _ hx\n\n"}
{"name":"LinearMap.BilinForm.isCompl_span_singleton_orthogonal","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nB : LinearMap.BilinForm K V\nx : V\nhx : Not (B.IsOrtho x x)\n⊢ IsCompl (Submodule.span K (Singleton.singleton x)) (B.orthogonal (Submodule.span K (Singleton.singleton x)))","decl":"/-- Given a bilinear form `B` and some `x` such that `B x x ≠ 0`, the span of the singleton of `x`\n  is complement to its orthogonal complement. -/\ntheorem isCompl_span_singleton_orthogonal {B : BilinForm K V} {x : V} (hx : ¬B.IsOrtho x x) :\n    IsCompl (K ∙ x) (B.orthogonal <| K ∙ x) :=\n  { disjoint := disjoint_iff.2 <| span_singleton_inf_orthogonal_eq_bot hx\n    codisjoint := codisjoint_iff.2 <| span_singleton_sup_orthogonal_eq_top hx }\n\n"}
{"name":"LinearMap.BilinForm.nondegenerate_restrict_of_disjoint_orthogonal","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"R₁ : Type u_3\nM₁ : Type u_4\ninst✝² : CommRing R₁\ninst✝¹ : AddCommGroup M₁\ninst✝ : Module R₁ M₁\nB : LinearMap.BilinForm R₁ M₁\nb : B.IsRefl\nW : Submodule R₁ M₁\nhW : Disjoint W (B.orthogonal W)\n⊢ (B.restrict W).Nondegenerate","decl":"/-- The restriction of a reflexive bilinear form `B` onto a submodule `W` is\nnondegenerate if `Disjoint W (B.orthogonal W)`. -/\ntheorem nondegenerate_restrict_of_disjoint_orthogonal (B : BilinForm R₁ M₁) (b : B.IsRefl)\n    {W : Submodule R₁ M₁} (hW : Disjoint W (B.orthogonal W)) : (B.restrict W).Nondegenerate := by\n  rintro ⟨x, hx⟩ b₁\n  rw [Submodule.mk_eq_zero, ← Submodule.mem_bot R₁]\n  refine hW.le_bot ⟨hx, fun y hy => ?_⟩\n  specialize b₁ ⟨y, hy⟩\n  simp only [restrict_apply, domRestrict_apply] at b₁\n  exact isOrtho_def.mpr (b x y b₁)\n\n"}
{"name":"LinearMap.BilinForm.iIsOrtho.not_isOrtho_basis_self_of_nondegenerate","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nn : Type w\ninst✝ : Nontrivial R\nB : LinearMap.BilinForm R M\nv : Basis n R M\nh : B.iIsOrtho ⇑v\nhB : B.Nondegenerate\ni : n\n⊢ Not (B.IsOrtho (v i) (v i))","decl":"/-- An orthogonal basis with respect to a nondegenerate bilinear form has no self-orthogonal\nelements. -/\ntheorem iIsOrtho.not_isOrtho_basis_self_of_nondegenerate {n : Type w} [Nontrivial R]\n    {B : BilinForm R M} {v : Basis n R M} (h : B.iIsOrtho v) (hB : B.Nondegenerate) (i : n) :\n    ¬B.IsOrtho (v i) (v i) := by\n  intro ho\n  refine v.ne_zero i (hB (v i) fun m => ?_)\n  obtain ⟨vi, rfl⟩ := v.repr.symm.surjective m\n  rw [Basis.repr_symm_apply, Finsupp.linearCombination_apply, Finsupp.sum, sum_right]\n  apply Finset.sum_eq_zero\n  rintro j -\n  rw [smul_right]\n  convert mul_zero (vi j) using 2\n  obtain rfl | hij := eq_or_ne i j\n  · exact ho\n  · exact h hij\n\n"}
{"name":"LinearMap.BilinForm.iIsOrtho.nondegenerate_iff_not_isOrtho_basis_self","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nn : Type w\ninst✝¹ : Nontrivial R\ninst✝ : NoZeroDivisors R\nB : LinearMap.BilinForm R M\nv : Basis n R M\nhO : B.iIsOrtho ⇑v\n⊢ Iff B.Nondegenerate (∀ (i : n), Not (B.IsOrtho (v i) (v i)))","decl":"/-- Given an orthogonal basis with respect to a bilinear form, the bilinear form is nondegenerate\niff the basis has no elements which are self-orthogonal. -/\ntheorem iIsOrtho.nondegenerate_iff_not_isOrtho_basis_self {n : Type w} [Nontrivial R]\n    [NoZeroDivisors R] (B : BilinForm R M) (v : Basis n R M) (hO : B.iIsOrtho v) :\n    B.Nondegenerate ↔ ∀ i, ¬B.IsOrtho (v i) (v i) := by\n  refine ⟨hO.not_isOrtho_basis_self_of_nondegenerate, fun ho m hB => ?_⟩\n  obtain ⟨vi, rfl⟩ := v.repr.symm.surjective m\n  rw [LinearEquiv.map_eq_zero_iff]\n  ext i\n  rw [Finsupp.zero_apply]\n  specialize hB (v i)\n  simp_rw [Basis.repr_symm_apply, Finsupp.linearCombination_apply, Finsupp.sum, sum_left,\n           smul_left] at hB\n  rw [Finset.sum_eq_single i] at hB\n  · exact eq_zero_of_ne_zero_of_mul_right_eq_zero (ho i) hB\n  · intro j _ hij\n    convert mul_zero (vi j) using 2\n    exact hO hij\n  · intro hi\n    convert zero_mul (M₀ := R) _ using 2\n    exact Finsupp.not_mem_support_iff.mp hi\n\n"}
{"name":"LinearMap.BilinForm.toLin_restrict_ker_eq_inf_orthogonal","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nB : LinearMap.BilinForm K V\nW : Subspace K V\nb : B.IsRefl\n⊢ Eq (Submodule.map (Submodule.subtype W) (LinearMap.ker (LinearMap.domRestrict B W))) (Min.min W (B.orthogonal Top.top))","decl":"theorem toLin_restrict_ker_eq_inf_orthogonal (B : BilinForm K V) (W : Subspace K V) (b : B.IsRefl) :\n    (B.domRestrict W).ker.map W.subtype = (W ⊓ B.orthogonal ⊤ : Subspace K V) := by\n  ext x; constructor <;> intro hx\n  · rcases hx with ⟨⟨x, hx⟩, hker, rfl⟩\n    erw [LinearMap.mem_ker] at hker\n    constructor\n    · simp [hx]\n    · intro y _\n      rw [IsOrtho, b]\n      change (B.domRestrict W) ⟨x, hx⟩ y = 0\n      rw [hker]\n      rfl\n  · simp_rw [Submodule.mem_map, LinearMap.mem_ker]\n    refine ⟨⟨x, hx.1⟩, ?_, rfl⟩\n    ext y\n    change B x y = 0\n    rw [b]\n    exact hx.2 _ Submodule.mem_top\n\n"}
{"name":"LinearMap.BilinForm.toLin_restrict_range_dualCoannihilator_eq_orthogonal","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nB : LinearMap.BilinForm K V\nW : Subspace K V\n⊢ Eq (LinearMap.range (LinearMap.domRestrict B W)).dualCoannihilator (B.orthogonal W)","decl":"theorem toLin_restrict_range_dualCoannihilator_eq_orthogonal (B : BilinForm K V)\n    (W : Subspace K V) : (B.domRestrict W).range.dualCoannihilator = B.orthogonal W := by\n  ext x; constructor <;> rw [mem_orthogonal_iff] <;> intro hx\n  · intro y hy\n    rw [Submodule.mem_dualCoannihilator] at hx\n    exact hx (B.domRestrict W ⟨y, hy⟩) ⟨⟨y, hy⟩, rfl⟩\n  · rw [Submodule.mem_dualCoannihilator]\n    rintro _ ⟨⟨w, hw⟩, rfl⟩\n    exact hx w hw\n\n"}
{"name":"LinearMap.BilinForm.ker_restrict_eq_of_codisjoint","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np q : Submodule R M\nhpq : Codisjoint p q\nB : LinearMap.BilinForm R M\nhB : ∀ (x : M), Membership.mem p x → ∀ (y : M), Membership.mem q y → Eq ((B x) y) 0\n⊢ Eq (LinearMap.ker (B.restrict p)) (Submodule.comap p.subtype (LinearMap.ker B))","decl":"lemma ker_restrict_eq_of_codisjoint {p q : Submodule R M} (hpq : Codisjoint p q)\n    {B : LinearMap.BilinForm R M} (hB : ∀ x ∈ p, ∀ y ∈ q, B x y = 0) :\n    LinearMap.ker (B.restrict p) = (LinearMap.ker B).comap p.subtype := by\n  ext ⟨z, hz⟩\n  simp only [LinearMap.mem_ker, Submodule.mem_comap, Submodule.coe_subtype]\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · ext w\n    obtain ⟨x, hx, y, hy, rfl⟩ := Submodule.exists_add_eq_of_codisjoint hpq w\n    simpa [hB z hz y hy] using LinearMap.congr_fun h ⟨x, hx⟩\n  · ext ⟨x, hx⟩\n    simpa using LinearMap.congr_fun h x\n\n"}
{"name":"LinearMap.BilinForm.inf_orthogonal_self_le_ker_restrict","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nW : Submodule R M\nb₁ : B.IsRefl\n⊢ LE.le (Min.min W (B.orthogonal W)) (Submodule.map W.subtype (LinearMap.ker (B.restrict W)))","decl":"lemma inf_orthogonal_self_le_ker_restrict {W : Submodule R M} (b₁ : B.IsRefl) :\n    W ⊓ B.orthogonal W ≤ (LinearMap.ker <| B.restrict W).map W.subtype := by\n  rintro v ⟨hv : v ∈ W, hv' : v ∈ B.orthogonal W⟩\n  simp only [Submodule.mem_map, mem_ker, restrict_apply, Submodule.coe_subtype, Subtype.exists,\n    exists_and_left, exists_prop, exists_eq_right_right]\n  refine ⟨?_, hv⟩\n  ext ⟨w, hw⟩\n  exact b₁ w v <| hv' w hw\n\n"}
{"name":"LinearMap.BilinForm.finrank_add_finrank_orthogonal","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nB : LinearMap.BilinForm K V\nb₁ : B.IsRefl\nW : Submodule K V\n⊢ Eq (HAdd.hAdd (Module.finrank K (Subtype fun x => Membership.mem W x)) (Module.finrank K (Subtype fun x => Membership.mem (B.orthogonal W) x))) (HAdd.hAdd (Module.finrank K V) (Module.finrank K (Subtype fun x => Membership.mem (Min.min W (B.orthogonal Top.top)) x)))","decl":"theorem finrank_add_finrank_orthogonal (b₁ : B.IsRefl) (W : Submodule K V) :\n    finrank K W + finrank K (B.orthogonal W) =\n      finrank K V + finrank K (W ⊓ B.orthogonal ⊤ : Subspace K V) := by\n  rw [← toLin_restrict_ker_eq_inf_orthogonal _ _ b₁, ←\n    toLin_restrict_range_dualCoannihilator_eq_orthogonal _ _, finrank_map_subtype_eq]\n  conv_rhs =>\n    rw [← @Subspace.finrank_add_finrank_dualCoannihilator_eq K V _ _ _ _\n        (LinearMap.range (B.domRestrict W)),\n      add_comm, ← add_assoc, add_comm (finrank K (LinearMap.ker (B.domRestrict W))),\n      LinearMap.finrank_range_add_finrank_ker]\n\n"}
{"name":"LinearMap.BilinForm.finrank_orthogonal","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nB : LinearMap.BilinForm K V\nhB : B.Nondegenerate\nhB₀ : B.IsRefl\nW : Submodule K V\n⊢ Eq (Module.finrank K (Subtype fun x => Membership.mem (B.orthogonal W) x)) (HSub.hSub (Module.finrank K V) (Module.finrank K (Subtype fun x => Membership.mem W x)))","decl":"lemma finrank_orthogonal (hB : B.Nondegenerate) (hB₀ : B.IsRefl) (W : Submodule K V) :\n    finrank K (B.orthogonal W) = finrank K V - finrank K W := by\n  have := finrank_add_finrank_orthogonal hB₀ (W := W)\n  rw [B.orthogonal_top_eq_bot hB hB₀, inf_bot_eq, finrank_bot, add_zero] at this\n  omega\n\n"}
{"name":"LinearMap.BilinForm.orthogonal_orthogonal","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nB : LinearMap.BilinForm K V\nhB : B.Nondegenerate\nhB₀ : B.IsRefl\nW : Submodule K V\n⊢ Eq (B.orthogonal (B.orthogonal W)) W","decl":"lemma orthogonal_orthogonal (hB : B.Nondegenerate) (hB₀ : B.IsRefl) (W : Submodule K V) :\n    B.orthogonal (B.orthogonal W) = W := by\n  apply (eq_of_le_of_finrank_le (LinearMap.BilinForm.le_orthogonal_orthogonal hB₀) _).symm\n  simp only [finrank_orthogonal hB hB₀]\n  omega\n\n"}
{"name":"LinearMap.BilinForm.isCompl_orthogonal_iff_disjoint","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nB : LinearMap.BilinForm K V\nW : Submodule K V\nhB₀ : B.IsRefl\n⊢ Iff (IsCompl W (B.orthogonal W)) (Disjoint W (B.orthogonal W))","decl":"lemma isCompl_orthogonal_iff_disjoint (hB₀ : B.IsRefl) :\n    IsCompl W (B.orthogonal W) ↔ Disjoint W (B.orthogonal W) := by\n  refine ⟨IsCompl.disjoint, fun h ↦ ⟨h, ?_⟩⟩\n  rw [codisjoint_iff]\n  apply (eq_top_of_finrank_eq <| (finrank_le _).antisymm _)\n  calc\n    finrank K V ≤ finrank K V + finrank K ↥(W ⊓ B.orthogonal ⊤) := le_self_add\n    _ ≤ finrank K ↥(W ⊔ B.orthogonal W) + finrank K ↥(W ⊓ B.orthogonal W) := ?_\n    _ ≤ finrank K ↥(W ⊔ B.orthogonal W) := by simp [h.eq_bot]\n  rw [finrank_sup_add_finrank_inf_eq, finrank_add_finrank_orthogonal hB₀ W]\n\n"}
{"name":"LinearMap.BilinForm.isCompl_orthogonal_of_restrict_nondegenerate","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nB : LinearMap.BilinForm K V\nW : Submodule K V\nb₁ : B.IsRefl\nb₂ : (B.restrict W).Nondegenerate\n⊢ IsCompl W (B.orthogonal W)","decl":"/-- A subspace is complement to its orthogonal complement with respect to some\nreflexive bilinear form if that bilinear form restricted on to the subspace is nondegenerate. -/\ntheorem isCompl_orthogonal_of_restrict_nondegenerate\n    (b₁ : B.IsRefl) (b₂ : (B.restrict W).Nondegenerate) : IsCompl W (B.orthogonal W) := by\n  have : W ⊓ B.orthogonal W = ⊥ := by\n    rw [eq_bot_iff]\n    intro x hx\n    obtain ⟨hx₁, hx₂⟩ := mem_inf.1 hx\n    refine Subtype.mk_eq_mk.1 (b₂ ⟨x, hx₁⟩ ?_)\n    rintro ⟨n, hn⟩\n    simp only [restrict_apply, domRestrict_apply]\n    exact b₁ n x (b₁ x n (b₁ n x (hx₂ n hn)))\n  refine IsCompl.of_eq this (eq_top_of_finrank_eq <| (finrank_le _).antisymm ?_)\n  conv_rhs => rw [← add_zero (finrank K _)]\n  rw [← finrank_bot K V, ← this, finrank_sup_add_finrank_inf_eq,\n    finrank_add_finrank_orthogonal b₁]\n  exact le_self_add\n\n"}
{"name":"LinearMap.BilinForm.restrict_nondegenerate_iff_isCompl_orthogonal","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nB : LinearMap.BilinForm K V\nW : Submodule K V\nb₁ : B.IsRefl\n⊢ Iff (B.restrict W).Nondegenerate (IsCompl W (B.orthogonal W))","decl":"/-- A subspace is complement to its orthogonal complement with respect to some reflexive bilinear\nform if and only if that bilinear form restricted on to the subspace is nondegenerate. -/\ntheorem restrict_nondegenerate_iff_isCompl_orthogonal\n    (b₁ : B.IsRefl) : (B.restrict W).Nondegenerate ↔ IsCompl W (B.orthogonal W) :=\n  ⟨fun b₂ => isCompl_orthogonal_of_restrict_nondegenerate b₁ b₂, fun h =>\n    B.nondegenerate_restrict_of_disjoint_orthogonal b₁ h.1⟩\n\n"}
{"name":"LinearMap.BilinForm.orthogonal_eq_top_iff","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nB : LinearMap.BilinForm K V\nW : Submodule K V\nb₁ : B.IsRefl\nb₂ : (B.restrict W).Nondegenerate\n⊢ Iff (Eq (B.orthogonal W) Top.top) (Eq W Bot.bot)","decl":"lemma orthogonal_eq_top_iff (b₁ : B.IsRefl) (b₂ : (B.restrict W).Nondegenerate) :\n    B.orthogonal W = ⊤ ↔ W = ⊥ := by\n  refine ⟨fun h ↦ ?_, fun h ↦ by simp [h]⟩\n  have := (B.isCompl_orthogonal_of_restrict_nondegenerate b₁ b₂).inf_eq_bot\n  rwa [h, inf_top_eq] at this\n\n"}
{"name":"LinearMap.BilinForm.eq_top_of_restrict_nondegenerate_of_orthogonal_eq_bot","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nB : LinearMap.BilinForm K V\nW : Submodule K V\nb₁ : B.IsRefl\nb₂ : (B.restrict W).Nondegenerate\nb₃ : Eq (B.orthogonal W) Bot.bot\n⊢ Eq W Top.top","decl":"lemma eq_top_of_restrict_nondegenerate_of_orthogonal_eq_bot\n    (b₁ : B.IsRefl) (b₂ : (B.restrict W).Nondegenerate) (b₃ : B.orthogonal W = ⊥) :\n    W = ⊤ := by\n  have := (B.isCompl_orthogonal_of_restrict_nondegenerate b₁ b₂).sup_eq_top\n  rwa [b₃, sup_bot_eq] at this\n\n"}
{"name":"LinearMap.BilinForm.orthogonal_eq_bot_iff","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝³ : Field K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : FiniteDimensional K V\nB : LinearMap.BilinForm K V\nW : Submodule K V\nb₁ : B.IsRefl\nb₂ : (B.restrict W).Nondegenerate\nb₃ : B.Nondegenerate\n⊢ Iff (Eq (B.orthogonal W) Bot.bot) (Eq W Top.top)","decl":"lemma orthogonal_eq_bot_iff\n    (b₁ : B.IsRefl) (b₂ : (B.restrict W).Nondegenerate) (b₃ : B.Nondegenerate) :\n    B.orthogonal W = ⊥ ↔ W = ⊤ := by\n  refine ⟨eq_top_of_restrict_nondegenerate_of_orthogonal_eq_bot b₁ b₂, fun h ↦ ?_⟩\n  rw [h, eq_bot_iff]\n  exact fun x hx ↦ b₃ x fun y ↦ b₁ y x <| by simpa using hx y\n\n"}
{"name":"LinearMap.BilinForm.restrict_nondegenerate_orthogonal_spanSingleton","module":"Mathlib.LinearAlgebra.BilinearForm.Orthogonal","initialProofState":"V : Type u_5\nK : Type u_6\ninst✝² : Field K\ninst✝¹ : AddCommGroup V\ninst✝ : Module K V\nB : LinearMap.BilinForm K V\nb₁ : B.Nondegenerate\nb₂ : B.IsRefl\nx : V\nhx : Not (B.IsOrtho x x)\n⊢ (B.restrict (B.orthogonal (Submodule.span K (Singleton.singleton x)))).Nondegenerate","decl":"/-- The restriction of a reflexive, non-degenerate bilinear form on the orthogonal complement of\nthe span of a singleton is also non-degenerate. -/\ntheorem restrict_nondegenerate_orthogonal_spanSingleton (B : BilinForm K V) (b₁ : B.Nondegenerate)\n    (b₂ : B.IsRefl) {x : V} (hx : ¬B.IsOrtho x x) :\n    Nondegenerate <| B.restrict <| B.orthogonal (K ∙ x) := by\n  refine fun m hm => Submodule.coe_eq_zero.1 (b₁ m.1 fun n => ?_)\n  have : n ∈ (K ∙ x) ⊔ B.orthogonal (K ∙ x) :=\n    (span_singleton_sup_orthogonal_eq_top hx).symm ▸ Submodule.mem_top\n  rcases Submodule.mem_sup.1 this with ⟨y, hy, z, hz, rfl⟩\n  specialize hm ⟨z, hz⟩\n  rw [restrict] at hm\n  erw [add_right, show B m.1 y = 0 by rw [b₂]; exact m.2 y hy, hm, add_zero]\n\n"}
