{"name":"CategoryTheory.Groupoid.Free.instNonemptyFreeGroupoid","module":"Mathlib.CategoryTheory.Groupoid.FreeGroupoid","initialProofState":"V : Type u_1\ninst‚úù¬π : Quiver V\ninst‚úù : Nonempty V\n‚ä¢ Nonempty (CategoryTheory.FreeGroupoid V)","decl":"instance {V} [Quiver V] [Nonempty V] : Nonempty (FreeGroupoid V) := by\n  inhabit V; exact ‚ü®‚ü®@default V _‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Groupoid.Free.congr_reverse","module":"Mathlib.CategoryTheory.Groupoid.FreeGroupoid","initialProofState":"V : Type u\ninst‚úù : Quiver V\nX Y : CategoryTheory.Paths (Quiver.Symmetrify V)\np q : Quiver.Hom X Y\na‚úù : CategoryTheory.Quotient.CompClosure CategoryTheory.Groupoid.Free.redStep p q\n‚ä¢ CategoryTheory.Quotient.CompClosure CategoryTheory.Groupoid.Free.redStep (Quiver.Path.reverse p) (Quiver.Path.reverse q)","decl":"theorem congr_reverse {X Y : Paths <| Quiver.Symmetrify V} (p q : X ‚ü∂ Y) :\n    Quotient.CompClosure redStep p q ‚Üí Quotient.CompClosure redStep p.reverse q.reverse := by\n  rintro ‚ü®XW, pp, qq, WY, _, Z, f‚ü©\n  have : Quotient.CompClosure redStep (WY.reverse ‚â´ ùüô _ ‚â´ XW.reverse)\n      (WY.reverse ‚â´ (f.toPath ‚â´ (Quiver.reverse f).toPath) ‚â´ XW.reverse) := by\n    constructor\n    constructor\n  simpa only [CategoryStruct.comp, CategoryStruct.id, Quiver.Path.reverse, Quiver.Path.nil_comp,\n    Quiver.Path.reverse_comp, Quiver.reverse_reverse, Quiver.Path.reverse_toPath,\n    Quiver.Path.comp_assoc] using this\n\n"}
{"name":"CategoryTheory.Groupoid.Free.congr_comp_reverse","module":"Mathlib.CategoryTheory.Groupoid.FreeGroupoid","initialProofState":"V : Type u\ninst‚úù : Quiver V\nX Y : CategoryTheory.Paths (Quiver.Symmetrify V)\np : Quiver.Hom X Y\n‚ä¢ Eq (Quot.mk (CategoryTheory.Quotient.CompClosure CategoryTheory.Groupoid.Free.redStep) (CategoryTheory.CategoryStruct.comp p (Quiver.Path.reverse p))) (Quot.mk (CategoryTheory.Quotient.CompClosure CategoryTheory.Groupoid.Free.redStep) (CategoryTheory.CategoryStruct.id X))","decl":"open Relation in\ntheorem congr_comp_reverse {X Y : Paths <| Quiver.Symmetrify V} (p : X ‚ü∂ Y) :\n    Quot.mk (@Quotient.CompClosure _ _ redStep _ _) (p ‚â´ p.reverse) =\n      Quot.mk (@Quotient.CompClosure _ _ redStep _ _) (ùüô X) := by\n  apply Quot.eqvGen_sound\n  induction' p with a b q f ih\n  ¬∑ apply EqvGen.refl\n  ¬∑ simp only [Quiver.Path.reverse]\n    fapply EqvGen.trans\n    -- Porting note: `Quiver.Path.*` and `Quiver.Hom.*` notation not working\n    ¬∑ exact q ‚â´ Quiver.Path.reverse q\n    ¬∑ apply EqvGen.symm\n      apply EqvGen.rel\n      have : Quotient.CompClosure redStep (q ‚â´ ùüô _ ‚â´ Quiver.Path.reverse q)\n          (q ‚â´ (Quiver.Hom.toPath f ‚â´ Quiver.Hom.toPath (Quiver.reverse f)) ‚â´\n            Quiver.Path.reverse q) := by\n        apply Quotient.CompClosure.intro\n        apply redStep.step\n      simp only [Category.assoc, Category.id_comp] at this ‚ä¢\n      -- Porting note: `simp` cannot see how `Quiver.Path.comp_assoc` is relevant, so change to\n      -- category notation\n      change Quotient.CompClosure redStep (q ‚â´ Quiver.Path.reverse q)\n        (Quiver.Path.cons q f ‚â´ (Quiver.Hom.toPath (Quiver.reverse f)) ‚â´ (Quiver.Path.reverse q))\n      simp only [‚Üê Category.assoc] at this ‚ä¢\n      exact this\n    ¬∑ exact ih\n\n"}
{"name":"CategoryTheory.Groupoid.Free.congr_reverse_comp","module":"Mathlib.CategoryTheory.Groupoid.FreeGroupoid","initialProofState":"V : Type u\ninst‚úù : Quiver V\nX Y : CategoryTheory.Paths (Quiver.Symmetrify V)\np : Quiver.Hom X Y\n‚ä¢ Eq (Quot.mk (CategoryTheory.Quotient.CompClosure CategoryTheory.Groupoid.Free.redStep) (CategoryTheory.CategoryStruct.comp (Quiver.Path.reverse p) p)) (Quot.mk (CategoryTheory.Quotient.CompClosure CategoryTheory.Groupoid.Free.redStep) (CategoryTheory.CategoryStruct.id Y))","decl":"theorem congr_reverse_comp {X Y : Paths <| Quiver.Symmetrify V} (p : X ‚ü∂ Y) :\n    Quot.mk (@Quotient.CompClosure _ _ redStep _ _) (p.reverse ‚â´ p) =\n      Quot.mk (@Quotient.CompClosure _ _ redStep _ _) (ùüô Y) := by\n  nth_rw 2 [‚Üê Quiver.Path.reverse_reverse p]\n  apply congr_comp_reverse\n\n"}
{"name":"CategoryTheory.Groupoid.Free.of_eq","module":"Mathlib.CategoryTheory.Groupoid.FreeGroupoid","initialProofState":"V : Type u\ninst‚úù : Quiver V\n‚ä¢ Eq (CategoryTheory.Groupoid.Free.of V) ((Quiver.Symmetrify.of.comp CategoryTheory.Paths.of).comp (CategoryTheory.Quotient.functor CategoryTheory.Groupoid.Free.redStep).toPrefunctor)","decl":"theorem of_eq :\n    of V = (Quiver.Symmetrify.of ‚ãôq Paths.of).comp\n      (Quotient.functor <| @redStep V _).toPrefunctor := rfl\n\n"}
{"name":"CategoryTheory.Groupoid.Free.lift_spec","module":"Mathlib.CategoryTheory.Groupoid.FreeGroupoid","initialProofState":"V : Type u\ninst‚úù¬π : Quiver V\nV' : Type u'\ninst‚úù : CategoryTheory.Groupoid V'\nœÜ : Prefunctor V V'\n‚ä¢ Eq ((CategoryTheory.Groupoid.Free.of V).comp (CategoryTheory.Groupoid.Free.lift œÜ).toPrefunctor) œÜ","decl":"theorem lift_spec (œÜ : V ‚•§q V') : of V ‚ãôq (lift œÜ).toPrefunctor = œÜ := by\n  rw [of_eq, Prefunctor.comp_assoc, Prefunctor.comp_assoc, Functor.toPrefunctor_comp]\n  dsimp [lift]\n  rw [Quotient.lift_spec, Paths.lift_spec, Quiver.Symmetrify.lift_spec]\n\n"}
{"name":"CategoryTheory.Groupoid.Free.lift_unique","module":"Mathlib.CategoryTheory.Groupoid.FreeGroupoid","initialProofState":"V : Type u\ninst‚úù¬π : Quiver V\nV' : Type u'\ninst‚úù : CategoryTheory.Groupoid V'\nœÜ : Prefunctor V V'\nŒ¶ : CategoryTheory.Functor (CategoryTheory.FreeGroupoid V) V'\nhŒ¶ : Eq ((CategoryTheory.Groupoid.Free.of V).comp Œ¶.toPrefunctor) œÜ\n‚ä¢ Eq Œ¶ (CategoryTheory.Groupoid.Free.lift œÜ)","decl":"theorem lift_unique (œÜ : V ‚•§q V') (Œ¶ : FreeGroupoid V ‚•§ V') (hŒ¶ : of V ‚ãôq Œ¶.toPrefunctor = œÜ) :\n    Œ¶ = lift œÜ := by\n  apply Quotient.lift_unique\n  apply Paths.lift_unique\n  fapply @Quiver.Symmetrify.lift_unique _ _ _ _ _ _ _ _ _\n  ¬∑ rw [‚Üê Functor.toPrefunctor_comp]\n    exact hŒ¶\n  ¬∑ rintro X Y f\n    simp only [‚Üê Functor.toPrefunctor_comp, Prefunctor.comp_map, Paths.of_map, inv_eq_inv]\n    change Œ¶.map (inv ((Quotient.functor redStep).toPrefunctor.map f.toPath)) =\n      inv (Œ¶.map ((Quotient.functor redStep).toPrefunctor.map f.toPath))\n    have := Functor.map_inv Œ¶ ((Quotient.functor redStep).toPrefunctor.map f.toPath)\n    convert this <;> simp only [inv_eq_inv]\n\n"}
{"name":"CategoryTheory.Groupoid.Free.freeGroupoidFunctor_id","module":"Mathlib.CategoryTheory.Groupoid.FreeGroupoid","initialProofState":"V : Type u\ninst‚úù : Quiver V\n‚ä¢ Eq (CategoryTheory.freeGroupoidFunctor (Prefunctor.id V)) (CategoryTheory.Functor.id (CategoryTheory.FreeGroupoid V))","decl":"theorem freeGroupoidFunctor_id :\n    freeGroupoidFunctor (Prefunctor.id V) = Functor.id (FreeGroupoid V) := by\n  dsimp only [freeGroupoidFunctor]; symm\n  apply lift_unique; rfl\n\n"}
{"name":"CategoryTheory.Groupoid.Free.freeGroupoidFunctor_comp","module":"Mathlib.CategoryTheory.Groupoid.FreeGroupoid","initialProofState":"V : Type u\ninst‚úù¬≤ : Quiver V\nV' : Type u'\ninst‚úù¬π : Quiver V'\nV'' : Type u''\ninst‚úù : Quiver V''\nœÜ : Prefunctor V V'\nœÜ' : Prefunctor V' V''\n‚ä¢ Eq (CategoryTheory.freeGroupoidFunctor (œÜ.comp œÜ')) ((CategoryTheory.freeGroupoidFunctor œÜ).comp (CategoryTheory.freeGroupoidFunctor œÜ'))","decl":"theorem freeGroupoidFunctor_comp (œÜ : V ‚•§q V') (œÜ' : V' ‚•§q V'') :\n    freeGroupoidFunctor (œÜ ‚ãôq œÜ') = freeGroupoidFunctor œÜ ‚ãô freeGroupoidFunctor œÜ' := by\n  dsimp only [freeGroupoidFunctor]; symm\n  apply lift_unique; rfl\n\n"}
