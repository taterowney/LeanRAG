{"name":"CategoryTheory.yoneda_map_app","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\nx‚úù : Opposite C\ng : ((fun X => { obj := fun Y => Quiver.Hom (Opposite.unop Y) X, map := fun {X_1 Y} f g => CategoryTheory.CategoryStruct.comp f.unop g, map_id := ‚ãØ, map_comp := ‚ãØ }) X‚úù).obj x‚úù\n‚ä¢ Eq ((CategoryTheory.yoneda.map f).app x‚úù g) (CategoryTheory.CategoryStruct.comp g f)","decl":"/-- The Yoneda embedding, as a functor from `C` into presheaves on `C`. -/\n@[simps, stacks 001O]\ndef yoneda : C ‚•§ C·µí·µñ ‚•§ Type v‚ÇÅ where\n  obj X :=\n    { obj := fun Y => unop Y ‚ü∂ X\n      map := fun f g => f.unop ‚â´ g }\n  map f :=\n    { app := fun _ g => g ‚â´ f }\n\n"}
{"name":"CategoryTheory.yoneda_obj_map","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nX‚úù Y‚úù : Opposite C\nf : Quiver.Hom X‚úù Y‚úù\ng : Quiver.Hom (Opposite.unop X‚úù) X\n‚ä¢ Eq ((CategoryTheory.yoneda.obj X).map f g) (CategoryTheory.CategoryStruct.comp f.unop g)","decl":"/-- The Yoneda embedding, as a functor from `C` into presheaves on `C`. -/\n@[simps, stacks 001O]\ndef yoneda : C ‚•§ C·µí·µñ ‚•§ Type v‚ÇÅ where\n  obj X :=\n    { obj := fun Y => unop Y ‚ü∂ X\n      map := fun f g => f.unop ‚â´ g }\n  map f :=\n    { app := fun _ g => g ‚â´ f }\n\n"}
{"name":"CategoryTheory.yoneda_obj_obj","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nY : Opposite C\n‚ä¢ Eq ((CategoryTheory.yoneda.obj X).obj Y) (Quiver.Hom (Opposite.unop Y) X)","decl":"/-- The Yoneda embedding, as a functor from `C` into presheaves on `C`. -/\n@[simps, stacks 001O]\ndef yoneda : C ‚•§ C·µí·µñ ‚•§ Type v‚ÇÅ where\n  obj X :=\n    { obj := fun Y => unop Y ‚ü∂ X\n      map := fun f g => f.unop ‚â´ g }\n  map f :=\n    { app := fun _ g => g ‚â´ f }\n\n"}
{"name":"CategoryTheory.coyoneda_map_app","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù Y‚úù : Opposite C\nf : Quiver.Hom X‚úù Y‚úù\nx‚úù : C\ng : ((fun X => { obj := fun Y => Quiver.Hom (Opposite.unop X) Y, map := fun {X_1 Y} f g => CategoryTheory.CategoryStruct.comp g f, map_id := ‚ãØ, map_comp := ‚ãØ }) X‚úù).obj x‚úù\n‚ä¢ Eq ((CategoryTheory.coyoneda.map f).app x‚úù g) (CategoryTheory.CategoryStruct.comp f.unop g)","decl":"/-- The co-Yoneda embedding, as a functor from `C·µí·µñ` into co-presheaves on `C`.\n-/\n@[simps]\ndef coyoneda : C·µí·µñ ‚•§ C ‚•§ Type v‚ÇÅ where\n  obj X :=\n    { obj := fun Y => unop X ‚ü∂ Y\n      map := fun f g => g ‚â´ f }\n  map f :=\n    { app := fun _ g => f.unop ‚â´ g }\n\n"}
{"name":"CategoryTheory.coyoneda_obj_map","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : Opposite C\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\ng : Quiver.Hom (Opposite.unop X) X‚úù\n‚ä¢ Eq ((CategoryTheory.coyoneda.obj X).map f g) (CategoryTheory.CategoryStruct.comp g f)","decl":"/-- The co-Yoneda embedding, as a functor from `C·µí·µñ` into co-presheaves on `C`.\n-/\n@[simps]\ndef coyoneda : C·µí·µñ ‚•§ C ‚•§ Type v‚ÇÅ where\n  obj X :=\n    { obj := fun Y => unop X ‚ü∂ Y\n      map := fun f g => g ‚â´ f }\n  map f :=\n    { app := fun _ g => f.unop ‚â´ g }\n\n"}
{"name":"CategoryTheory.coyoneda_obj_obj","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : Opposite C\nY : C\n‚ä¢ Eq ((CategoryTheory.coyoneda.obj X).obj Y) (Quiver.Hom (Opposite.unop X) Y)","decl":"/-- The co-Yoneda embedding, as a functor from `C·µí·µñ` into co-presheaves on `C`.\n-/\n@[simps]\ndef coyoneda : C·µí·µñ ‚•§ C ‚•§ Type v‚ÇÅ where\n  obj X :=\n    { obj := fun Y => unop X ‚ü∂ Y\n      map := fun f g => g ‚â´ f }\n  map f :=\n    { app := fun _ g => f.unop ‚â´ g }\n\n"}
{"name":"CategoryTheory.Yoneda.obj_map_id","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom { unop := X } { unop := Y }\n‚ä¢ Eq ((CategoryTheory.yoneda.obj X).map f (CategoryTheory.CategoryStruct.id X)) ((CategoryTheory.yoneda.map f.unop).app { unop := Y } (CategoryTheory.CategoryStruct.id Y))","decl":"theorem obj_map_id {X Y : C} (f : op X ‚ü∂ op Y) :\n    (yoneda.obj X).map f (ùüô X) = (yoneda.map f.unop).app (op Y) (ùüô Y) := by\n  dsimp\n  simp\n\n"}
{"name":"CategoryTheory.Yoneda.naturality","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nŒ± : Quiver.Hom (CategoryTheory.yoneda.obj X) (CategoryTheory.yoneda.obj Y)\nZ Z' : C\nf : Quiver.Hom Z Z'\nh : Quiver.Hom Z' X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (Œ±.app { unop := Z' } h)) (Œ±.app { unop := Z } (CategoryTheory.CategoryStruct.comp f h))","decl":"@[simp]\ntheorem naturality {X Y : C} (Œ± : yoneda.obj X ‚ü∂ yoneda.obj Y) {Z Z' : C} (f : Z ‚ü∂ Z')\n    (h : Z' ‚ü∂ X) : f ‚â´ Œ±.app (op Z') h = Œ±.app (op Z) (f ‚â´ h) :=\n  (FunctorToTypes.naturality _ _ Œ± f.op h).symm\n\n"}
{"name":"CategoryTheory.Yoneda.fullyFaithful_preimage","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom (CategoryTheory.yoneda.obj X) (CategoryTheory.yoneda.obj Y)\n‚ä¢ Eq (CategoryTheory.Yoneda.fullyFaithful.preimage f) (f.app { unop := X } (CategoryTheory.CategoryStruct.id X))","decl":"lemma fullyFaithful_preimage {X Y : C} (f : yoneda.obj X ‚ü∂ yoneda.obj Y) :\n    fullyFaithful.preimage f = f.app (op X) (ùüô X) := rfl\n\n"}
{"name":"CategoryTheory.Yoneda.yoneda_full","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ CategoryTheory.yoneda.Full","decl":"/-- The Yoneda embedding is full. -/\n@[stacks 001P]\ninstance yoneda_full : (yoneda : C ‚•§ C·µí·µñ ‚•§ Type v‚ÇÅ).Full :=\n  fullyFaithful.full\n\n"}
{"name":"CategoryTheory.Yoneda.yoneda_faithful","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ CategoryTheory.yoneda.Faithful","decl":"/-- The Yoneda embedding is faithful. -/\n@[stacks 001P]\ninstance yoneda_faithful : (yoneda : C ‚•§ C·µí·µñ ‚•§ Type v‚ÇÅ).Faithful :=\n  fullyFaithful.faithful\n\n"}
{"name":"CategoryTheory.Yoneda.isIso","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.yoneda.map f)\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- If `yoneda.map f` is an isomorphism, so was `f`.\n-/\ntheorem isIso {X Y : C} (f : X ‚ü∂ Y) [IsIso (yoneda.map f)] : IsIso f :=\n  isIso_of_fully_faithful yoneda f\n\n"}
{"name":"CategoryTheory.Coyoneda.naturality","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : Opposite C\nŒ± : Quiver.Hom (CategoryTheory.coyoneda.obj X) (CategoryTheory.coyoneda.obj Y)\nZ Z' : C\nf : Quiver.Hom Z' Z\nh : Quiver.Hom (Opposite.unop X) Z'\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Œ±.app Z' h) f) (Œ±.app Z (CategoryTheory.CategoryStruct.comp h f))","decl":"@[simp]\ntheorem naturality {X Y : C·µí·µñ} (Œ± : coyoneda.obj X ‚ü∂ coyoneda.obj Y) {Z Z' : C} (f : Z' ‚ü∂ Z)\n    (h : unop X ‚ü∂ Z') : Œ±.app Z' h ‚â´ f = Œ±.app Z (h ‚â´ f) :=\n  (FunctorToTypes.naturality _ _ Œ± f h).symm\n\n"}
{"name":"CategoryTheory.Coyoneda.fullyFaithful_preimage","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : Opposite C\nf : Quiver.Hom (CategoryTheory.coyoneda.obj X) (CategoryTheory.coyoneda.obj Y)\n‚ä¢ Eq (CategoryTheory.Coyoneda.fullyFaithful.preimage f) (Quiver.Hom.op (f.app (Opposite.unop X) (CategoryTheory.CategoryStruct.id (Opposite.unop X))))","decl":"lemma fullyFaithful_preimage {X Y : C·µí·µñ} (f : coyoneda.obj X ‚ü∂ coyoneda.obj Y) :\n    fullyFaithful.preimage f = (f.app X.unop (ùüô X.unop)).op := rfl\n\n"}
{"name":"CategoryTheory.Coyoneda.coyoneda_full","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ CategoryTheory.coyoneda.Full","decl":"instance coyoneda_full : (coyoneda : C·µí·µñ ‚•§ C ‚•§ Type v‚ÇÅ).Full :=\n  fullyFaithful.full\n\n"}
{"name":"CategoryTheory.Coyoneda.coyoneda_faithful","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ CategoryTheory.coyoneda.Faithful","decl":"instance coyoneda_faithful : (coyoneda : C·µí·µñ ‚•§ C ‚•§ Type v‚ÇÅ).Faithful :=\n  fullyFaithful.faithful\n\n"}
{"name":"CategoryTheory.Coyoneda.isIso","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : Opposite C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso (CategoryTheory.coyoneda.map f)\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- If `coyoneda.map f` is an isomorphism, so was `f`.\n-/\ntheorem isIso {X Y : C·µí·µñ} (f : X ‚ü∂ Y) [IsIso (coyoneda.map f)] : IsIso f :=\n  isIso_of_fully_faithful coyoneda f\n\n"}
{"name":"CategoryTheory.Coyoneda.objOpOp_inv_app","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù : C\nX : Opposite C\na‚úù : (CategoryTheory.yoneda.obj X‚úù).obj X\n‚ä¢ Eq ((CategoryTheory.Coyoneda.objOpOp X‚úù).inv.app X a‚úù) ((CategoryTheory.opEquiv { unop := X‚úù } X).symm a‚úù)","decl":"/-- Taking the `unop` of morphisms is a natural isomorphism. -/\n@[simps!]\ndef objOpOp (X : C) : coyoneda.obj (op (op X)) ‚âÖ yoneda.obj X :=\n  NatIso.ofComponents fun _ => (opEquiv _ _).toIso\n\n"}
{"name":"CategoryTheory.Coyoneda.objOpOp_hom_app","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù : C\nX : Opposite C\na‚úù : (CategoryTheory.coyoneda.obj { unop := { unop := X‚úù } }).obj X\n‚ä¢ Eq ((CategoryTheory.Coyoneda.objOpOp X‚úù).hom.app X a‚úù) ((CategoryTheory.opEquiv { unop := X‚úù } X) a‚úù)","decl":"/-- Taking the `unop` of morphisms is a natural isomorphism. -/\n@[simps!]\ndef objOpOp (X : C) : coyoneda.obj (op (op X)) ‚âÖ yoneda.obj X :=\n  NatIso.ofComponents fun _ => (opEquiv _ _).toIso\n\n"}
{"name":"CategoryTheory.Functor.RepresentableBy.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nY : C\ninst‚úù : SizeOf C\nhomEquiv : {X : C} ‚Üí Equiv (Quiver.Hom X Y) (F.obj { unop := X })\nhomEquiv_comp : ‚àÄ {X X' : C} (f : Quiver.Hom X X') (g : Quiver.Hom X' Y), Eq (homEquiv (CategoryTheory.CategoryStruct.comp f g)) (F.map f.op (homEquiv g))\n‚ä¢ Eq (SizeOf.sizeOf { homEquiv := homEquiv, homEquiv_comp := homEquiv_comp }) 1","decl":"/-- The data which expresses that a functor `F : C·µí·µñ ‚•§ Type v` is representable by `Y : C`. -/\nstructure RepresentableBy (F : C·µí·µñ ‚•§ Type v) (Y : C) where\n  /-- the natural bijection `(X ‚ü∂ Y) ‚âÉ F.obj (op X)`. -/\n  homEquiv {X : C} : (X ‚ü∂ Y) ‚âÉ F.obj (op X)\n  homEquiv_comp {X X' : C} (f : X ‚ü∂ X') (g : X' ‚ü∂ Y) :\n    homEquiv (f ‚â´ g) = F.map f.op (homEquiv g)\n\n"}
{"name":"CategoryTheory.Functor.RepresentableBy.mk.inj","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nY : C\nhomEquiv‚úù : {X : C} ‚Üí Equiv (Quiver.Hom X Y) (F.obj { unop := X })\nhomEquiv_comp‚úù : ‚àÄ {X X' : C} (f : Quiver.Hom X X') (g : Quiver.Hom X' Y), Eq (homEquiv‚úù (CategoryTheory.CategoryStruct.comp f g)) (F.map f.op (homEquiv‚úù g))\nhomEquiv : {X : C} ‚Üí Equiv (Quiver.Hom X Y) (F.obj { unop := X })\nhomEquiv_comp : ‚àÄ {X X' : C} (f : Quiver.Hom X X') (g : Quiver.Hom X' Y), Eq (homEquiv (CategoryTheory.CategoryStruct.comp f g)) (F.map f.op (homEquiv g))\nx‚úù : Eq { homEquiv := homEquiv‚úù, homEquiv_comp := homEquiv_comp‚úù } { homEquiv := homEquiv, homEquiv_comp := homEquiv_comp }\n‚ä¢ Eq homEquiv‚úù homEquiv","decl":"/-- The data which expresses that a functor `F : C·µí·µñ ‚•§ Type v` is representable by `Y : C`. -/\nstructure RepresentableBy (F : C·µí·µñ ‚•§ Type v) (Y : C) where\n  /-- the natural bijection `(X ‚ü∂ Y) ‚âÉ F.obj (op X)`. -/\n  homEquiv {X : C} : (X ‚ü∂ Y) ‚âÉ F.obj (op X)\n  homEquiv_comp {X X' : C} (f : X ‚ü∂ X') (g : X' ‚ü∂ Y) :\n    homEquiv (f ‚â´ g) = F.map f.op (homEquiv g)\n\n"}
{"name":"CategoryTheory.Functor.RepresentableBy.mk.injEq","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nY : C\nhomEquiv‚úù : {X : C} ‚Üí Equiv (Quiver.Hom X Y) (F.obj { unop := X })\nhomEquiv_comp‚úù : ‚àÄ {X X' : C} (f : Quiver.Hom X X') (g : Quiver.Hom X' Y), Eq (homEquiv‚úù (CategoryTheory.CategoryStruct.comp f g)) (F.map f.op (homEquiv‚úù g))\nhomEquiv : {X : C} ‚Üí Equiv (Quiver.Hom X Y) (F.obj { unop := X })\nhomEquiv_comp : ‚àÄ {X X' : C} (f : Quiver.Hom X X') (g : Quiver.Hom X' Y), Eq (homEquiv (CategoryTheory.CategoryStruct.comp f g)) (F.map f.op (homEquiv g))\n‚ä¢ Eq (Eq { homEquiv := homEquiv‚úù, homEquiv_comp := homEquiv_comp‚úù } { homEquiv := homEquiv, homEquiv_comp := homEquiv_comp }) (Eq homEquiv‚úù homEquiv)","decl":"/-- The data which expresses that a functor `F : C·µí·µñ ‚•§ Type v` is representable by `Y : C`. -/\nstructure RepresentableBy (F : C·µí·µñ ‚•§ Type v) (Y : C) where\n  /-- the natural bijection `(X ‚ü∂ Y) ‚âÉ F.obj (op X)`. -/\n  homEquiv {X : C} : (X ‚ü∂ Y) ‚âÉ F.obj (op X)\n  homEquiv_comp {X X' : C} (f : X ‚ü∂ X') (g : X' ‚ü∂ Y) :\n    homEquiv (f ‚â´ g) = F.map f.op (homEquiv g)\n\n"}
{"name":"CategoryTheory.Functor.RepresentableBy.homEquiv_comp","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nY : C\nself : F.RepresentableBy Y\nX X' : C\nf : Quiver.Hom X X'\ng : Quiver.Hom X' Y\n‚ä¢ Eq (self.homEquiv (CategoryTheory.CategoryStruct.comp f g)) (F.map f.op (self.homEquiv g))","decl":"/-- The data which expresses that a functor `F : C·µí·µñ ‚•§ Type v` is representable by `Y : C`. -/\nstructure RepresentableBy (F : C·µí·µñ ‚•§ Type v) (Y : C) where\n  /-- the natural bijection `(X ‚ü∂ Y) ‚âÉ F.obj (op X)`. -/\n  homEquiv {X : C} : (X ‚ü∂ Y) ‚âÉ F.obj (op X)\n  homEquiv_comp {X X' : C} (f : X ‚ü∂ X') (g : X' ‚ü∂ Y) :\n    homEquiv (f ‚â´ g) = F.map f.op (homEquiv g)\n\n"}
{"name":"CategoryTheory.Functor.CorepresentableBy.mk.injEq","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C (Type v)\nX : C\nhomEquiv‚úù : {Y : C} ‚Üí Equiv (Quiver.Hom X Y) (F.obj Y)\nhomEquiv_comp‚úù : ‚àÄ {Y Y' : C} (g : Quiver.Hom Y Y') (f : Quiver.Hom X Y), Eq (homEquiv‚úù (CategoryTheory.CategoryStruct.comp f g)) (F.map g (homEquiv‚úù f))\nhomEquiv : {Y : C} ‚Üí Equiv (Quiver.Hom X Y) (F.obj Y)\nhomEquiv_comp : ‚àÄ {Y Y' : C} (g : Quiver.Hom Y Y') (f : Quiver.Hom X Y), Eq (homEquiv (CategoryTheory.CategoryStruct.comp f g)) (F.map g (homEquiv f))\n‚ä¢ Eq (Eq { homEquiv := homEquiv‚úù, homEquiv_comp := homEquiv_comp‚úù } { homEquiv := homEquiv, homEquiv_comp := homEquiv_comp }) (Eq homEquiv‚úù homEquiv)","decl":"/-- The data which expresses that a functor `F : C ‚•§ Type v` is corepresentable by `X : C`. -/\nstructure CorepresentableBy (F : C ‚•§ Type v) (X : C) where\n  /-- the natural bijection `(X ‚ü∂ Y) ‚âÉ F.obj Y`. -/\n  homEquiv {Y : C} : (X ‚ü∂ Y) ‚âÉ F.obj Y\n  homEquiv_comp {Y Y' : C} (g : Y ‚ü∂ Y') (f : X ‚ü∂ Y) :\n    homEquiv (f ‚â´ g) = F.map g (homEquiv f)\n\n"}
{"name":"CategoryTheory.Functor.CorepresentableBy.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C (Type v)\nX : C\ninst‚úù : SizeOf C\nhomEquiv : {Y : C} ‚Üí Equiv (Quiver.Hom X Y) (F.obj Y)\nhomEquiv_comp : ‚àÄ {Y Y' : C} (g : Quiver.Hom Y Y') (f : Quiver.Hom X Y), Eq (homEquiv (CategoryTheory.CategoryStruct.comp f g)) (F.map g (homEquiv f))\n‚ä¢ Eq (SizeOf.sizeOf { homEquiv := homEquiv, homEquiv_comp := homEquiv_comp }) 1","decl":"/-- The data which expresses that a functor `F : C ‚•§ Type v` is corepresentable by `X : C`. -/\nstructure CorepresentableBy (F : C ‚•§ Type v) (X : C) where\n  /-- the natural bijection `(X ‚ü∂ Y) ‚âÉ F.obj Y`. -/\n  homEquiv {Y : C} : (X ‚ü∂ Y) ‚âÉ F.obj Y\n  homEquiv_comp {Y Y' : C} (g : Y ‚ü∂ Y') (f : X ‚ü∂ Y) :\n    homEquiv (f ‚â´ g) = F.map g (homEquiv f)\n\n"}
{"name":"CategoryTheory.Functor.CorepresentableBy.homEquiv_comp","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C (Type v)\nX : C\nself : F.CorepresentableBy X\nY Y' : C\ng : Quiver.Hom Y Y'\nf : Quiver.Hom X Y\n‚ä¢ Eq (self.homEquiv (CategoryTheory.CategoryStruct.comp f g)) (F.map g (self.homEquiv f))","decl":"/-- The data which expresses that a functor `F : C ‚•§ Type v` is corepresentable by `X : C`. -/\nstructure CorepresentableBy (F : C ‚•§ Type v) (X : C) where\n  /-- the natural bijection `(X ‚ü∂ Y) ‚âÉ F.obj Y`. -/\n  homEquiv {Y : C} : (X ‚ü∂ Y) ‚âÉ F.obj Y\n  homEquiv_comp {Y Y' : C} (g : Y ‚ü∂ Y') (f : X ‚ü∂ Y) :\n    homEquiv (f ‚â´ g) = F.map g (homEquiv f)\n\n"}
{"name":"CategoryTheory.Functor.CorepresentableBy.mk.inj","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C (Type v)\nX : C\nhomEquiv‚úù : {Y : C} ‚Üí Equiv (Quiver.Hom X Y) (F.obj Y)\nhomEquiv_comp‚úù : ‚àÄ {Y Y' : C} (g : Quiver.Hom Y Y') (f : Quiver.Hom X Y), Eq (homEquiv‚úù (CategoryTheory.CategoryStruct.comp f g)) (F.map g (homEquiv‚úù f))\nhomEquiv : {Y : C} ‚Üí Equiv (Quiver.Hom X Y) (F.obj Y)\nhomEquiv_comp : ‚àÄ {Y Y' : C} (g : Quiver.Hom Y Y') (f : Quiver.Hom X Y), Eq (homEquiv (CategoryTheory.CategoryStruct.comp f g)) (F.map g (homEquiv f))\nx‚úù : Eq { homEquiv := homEquiv‚úù, homEquiv_comp := homEquiv_comp‚úù } { homEquiv := homEquiv, homEquiv_comp := homEquiv_comp }\n‚ä¢ Eq homEquiv‚úù homEquiv","decl":"/-- The data which expresses that a functor `F : C ‚•§ Type v` is corepresentable by `X : C`. -/\nstructure CorepresentableBy (F : C ‚•§ Type v) (X : C) where\n  /-- the natural bijection `(X ‚ü∂ Y) ‚âÉ F.obj Y`. -/\n  homEquiv {Y : C} : (X ‚ü∂ Y) ‚âÉ F.obj Y\n  homEquiv_comp {Y Y' : C} (g : Y ‚ü∂ Y') (f : X ‚ü∂ Y) :\n    homEquiv (f ‚â´ g) = F.map g (homEquiv f)\n\n"}
{"name":"CategoryTheory.Functor.RepresentableBy.homEquiv_eq","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nY : C\ne : F.RepresentableBy Y\nX : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (e.homEquiv f) (F.map f.op (e.homEquiv (CategoryTheory.CategoryStruct.id Y)))","decl":"lemma RepresentableBy.homEquiv_eq {F : C·µí·µñ ‚•§ Type v} {Y : C} (e : F.RepresentableBy Y)\n    {X : C} (f : X ‚ü∂ Y) :\n    e.homEquiv f = F.map f.op (e.homEquiv (ùüô Y)) := by\n  conv_lhs => rw [‚Üê Category.comp_id f, e.homEquiv_comp]\n\n"}
{"name":"CategoryTheory.Functor.CorepresentableBy.homEquiv_eq","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C (Type v)\nX : C\ne : F.CorepresentableBy X\nY : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (e.homEquiv f) (F.map f (e.homEquiv (CategoryTheory.CategoryStruct.id X)))","decl":"lemma CorepresentableBy.homEquiv_eq {F : C ‚•§ Type v} {X : C} (e : F.CorepresentableBy X)\n    {Y : C} (f : X ‚ü∂ Y) :\n    e.homEquiv f = F.map f (e.homEquiv (ùüô X)) := by\n  conv_lhs => rw [‚Üê Category.id_comp f, e.homEquiv_comp]\n\n"}
{"name":"CategoryTheory.Functor.RepresentableBy.ext","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nY : C\ne e' : F.RepresentableBy Y\nh : Eq (e.homEquiv (CategoryTheory.CategoryStruct.id Y)) (e'.homEquiv (CategoryTheory.CategoryStruct.id Y))\n‚ä¢ Eq e e'","decl":"@[ext]\nlemma RepresentableBy.ext {F : C·µí·µñ ‚•§ Type v} {Y : C} {e e' : F.RepresentableBy Y}\n    (h : e.homEquiv (ùüô Y) = e'.homEquiv (ùüô Y)) : e = e' := by\n  have : ‚àÄ {X : C} (f : X ‚ü∂ Y), e.homEquiv f = e'.homEquiv f := fun {X} f ‚Ü¶ by\n    rw [e.homEquiv_eq, e'.homEquiv_eq, h]\n  obtain ‚ü®e, he‚ü© := e\n  obtain ‚ü®e', he'‚ü© := e'\n  obtain rfl : @e = @e' := by ext; apply this\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.RepresentableBy.ext_iff","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nY : C\ne e' : F.RepresentableBy Y\n‚ä¢ Iff (Eq e e') (Eq (e.homEquiv (CategoryTheory.CategoryStruct.id Y)) (e'.homEquiv (CategoryTheory.CategoryStruct.id Y)))","decl":"@[ext]\nlemma RepresentableBy.ext {F : C·µí·µñ ‚•§ Type v} {Y : C} {e e' : F.RepresentableBy Y}\n    (h : e.homEquiv (ùüô Y) = e'.homEquiv (ùüô Y)) : e = e' := by\n  have : ‚àÄ {X : C} (f : X ‚ü∂ Y), e.homEquiv f = e'.homEquiv f := fun {X} f ‚Ü¶ by\n    rw [e.homEquiv_eq, e'.homEquiv_eq, h]\n  obtain ‚ü®e, he‚ü© := e\n  obtain ‚ü®e', he'‚ü© := e'\n  obtain rfl : @e = @e' := by ext; apply this\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.CorepresentableBy.ext","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C (Type v)\nX : C\ne e' : F.CorepresentableBy X\nh : Eq (e.homEquiv (CategoryTheory.CategoryStruct.id X)) (e'.homEquiv (CategoryTheory.CategoryStruct.id X))\n‚ä¢ Eq e e'","decl":"@[ext]\nlemma CorepresentableBy.ext {F : C ‚•§ Type v} {X : C} {e e' : F.CorepresentableBy X}\n    (h : e.homEquiv (ùüô X) = e'.homEquiv (ùüô X)) : e = e' := by\n  have : ‚àÄ {Y : C} (f : X ‚ü∂ Y), e.homEquiv f = e'.homEquiv f := fun {X} f ‚Ü¶ by\n    rw [e.homEquiv_eq, e'.homEquiv_eq, h]\n  obtain ‚ü®e, he‚ü© := e\n  obtain ‚ü®e', he'‚ü© := e'\n  obtain rfl : @e = @e' := by ext; apply this\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.CorepresentableBy.ext_iff","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C (Type v)\nX : C\ne e' : F.CorepresentableBy X\n‚ä¢ Iff (Eq e e') (Eq (e.homEquiv (CategoryTheory.CategoryStruct.id X)) (e'.homEquiv (CategoryTheory.CategoryStruct.id X)))","decl":"@[ext]\nlemma CorepresentableBy.ext {F : C ‚•§ Type v} {X : C} {e e' : F.CorepresentableBy X}\n    (h : e.homEquiv (ùüô X) = e'.homEquiv (ùüô X)) : e = e' := by\n  have : ‚àÄ {Y : C} (f : X ‚ü∂ Y), e.homEquiv f = e'.homEquiv f := fun {X} f ‚Ü¶ by\n    rw [e.homEquiv_eq, e'.homEquiv_eq, h]\n  obtain ‚ü®e, he‚ü© := e\n  obtain ‚ü®e', he'‚ü© := e'\n  obtain rfl : @e = @e' := by ext; apply this\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.IsRepresentable.has_representation","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nself : F.IsRepresentable\n‚ä¢ Exists fun Y => Nonempty (F.RepresentableBy Y)","decl":"/-- A functor `F : C·µí·µñ ‚•§ Type v` is representable if there is an object `Y` with a structure\n`F.RepresentableBy Y`, i.e. there is a natural bijection `(X ‚ü∂ Y) ‚âÉ F.obj (op X)`,\nwhich may also be rephrased as a natural isomorphism `yoneda.obj X ‚âÖ F` when `Category.{v} C`. -/\n@[stacks 001Q]\nclass IsRepresentable (F : C·µí·µñ ‚•§ Type v) : Prop where\n  has_representation : ‚àÉ (Y : C), Nonempty (F.RepresentableBy Y)\n\n"}
{"name":"CategoryTheory.Functor.RepresentableBy.isRepresentable","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nY : C\ne : F.RepresentableBy Y\n‚ä¢ F.IsRepresentable","decl":"lemma RepresentableBy.isRepresentable {F : C·µí·µñ ‚•§ Type v} {Y : C} (e : F.RepresentableBy Y) :\n    F.IsRepresentable where\n  has_representation := ‚ü®Y, ‚ü®e‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Functor.IsRepresentable.mk'","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor (Opposite C) (Type v‚ÇÅ)\nX : C\ne : CategoryTheory.Iso (CategoryTheory.yoneda.obj X) F\n‚ä¢ F.IsRepresentable","decl":"/-- Alternative constructor for `F.IsRepresentable`, which takes as an input an\nisomorphism `yoneda.obj X ‚âÖ F`. -/\nlemma IsRepresentable.mk' {F : C·µí·µñ ‚•§ Type v‚ÇÅ} {X : C} (e : yoneda.obj X ‚âÖ F) :\n    F.IsRepresentable :=\n  (representableByEquiv.symm e).isRepresentable\n\n"}
{"name":"CategoryTheory.Functor.instIsRepresentableObjOppositeTypeYoneda","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ (CategoryTheory.yoneda.obj X).IsRepresentable","decl":"instance {X : C} : IsRepresentable (yoneda.obj X) :=\n  IsRepresentable.mk' (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Functor.IsCorepresentable.has_corepresentation","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C (Type v)\nself : F.IsCorepresentable\n‚ä¢ Exists fun X => Nonempty (F.CorepresentableBy X)","decl":"/-- A functor `F : C ‚•§ Type v‚ÇÅ` is corepresentable if there is object `X` so `F ‚âÖ coyoneda.obj X`.\n-/\n@[stacks 001Q]\nclass IsCorepresentable (F : C ‚•§ Type v) : Prop where\n  has_corepresentation : ‚àÉ (X : C), Nonempty (F.CorepresentableBy X)\n\n"}
{"name":"CategoryTheory.Functor.CorepresentableBy.isCorepresentable","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C (Type v)\nX : C\ne : F.CorepresentableBy X\n‚ä¢ F.IsCorepresentable","decl":"lemma CorepresentableBy.isCorepresentable {F : C ‚•§ Type v} {X : C} (e : F.CorepresentableBy X) :\n    F.IsCorepresentable where\n  has_corepresentation := ‚ü®X, ‚ü®e‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Functor.IsCorepresentable.mk'","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C (Type v‚ÇÅ)\nX : C\ne : CategoryTheory.Iso (CategoryTheory.coyoneda.obj { unop := X }) F\n‚ä¢ F.IsCorepresentable","decl":"/-- Alternative constructor for `F.IsCorepresentable`, which takes as an input an\nisomorphism `coyoneda.obj (op X) ‚âÖ F`. -/\nlemma IsCorepresentable.mk' {F : C ‚•§ Type v‚ÇÅ} {X : C} (e : coyoneda.obj (op X) ‚âÖ F) :\n    F.IsCorepresentable :=\n  (corepresentableByEquiv.symm e).isCorepresentable\n\n"}
{"name":"CategoryTheory.Functor.instIsCorepresentableObjOppositeTypeCoyoneda","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : Opposite C\n‚ä¢ (CategoryTheory.coyoneda.obj X).IsCorepresentable","decl":"instance {X : C·µí·µñ} : IsCorepresentable (coyoneda.obj X) :=\n  IsCorepresentable.mk' (Iso.refl _)\n\n-- instance : corepresentable (ùü≠ (Type v‚ÇÅ)) :=\n-- corepresentable_of_nat_iso (op punit) coyoneda.punit_iso\n"}
{"name":"CategoryTheory.Functor.reprW_hom_app","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor (Opposite C) (Type v‚ÇÅ)\ninst‚úù : F.IsRepresentable\nX : Opposite C\nf : Quiver.Hom (Opposite.unop X) F.reprX\n‚ä¢ Eq (F.reprW.hom.app X f) (F.map f.op F.reprx)","decl":"theorem reprW_hom_app (F : C·µí·µñ ‚•§ Type v‚ÇÅ) [F.IsRepresentable]\n    (X : C·µí·µñ) (f : unop X ‚ü∂ F.reprX) :\n    F.reprW.hom.app X f = F.map f.op F.reprx := by\n  apply RepresentableBy.homEquiv_eq\n\n"}
{"name":"CategoryTheory.Functor.coreprW_hom_app","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF : CategoryTheory.Functor C (Type v‚ÇÅ)\ninst‚úù : F.IsCorepresentable\nX : C\nf : Quiver.Hom F.coreprX X\n‚ä¢ Eq (F.coreprW.hom.app X f) (F.map f F.coreprx)","decl":"theorem coreprW_hom_app (F : C ‚•§ Type v‚ÇÅ) [F.IsCorepresentable] (X : C) (f : F.coreprX ‚ü∂ X) :\n    F.coreprW.hom.app X f = F.map f F.coreprx := by\n  apply CorepresentableBy.homEquiv_eq\n\n"}
{"name":"CategoryTheory.isRepresentable_of_natIso","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF G : CategoryTheory.Functor (Opposite C) (Type v‚ÇÅ)\ni : CategoryTheory.Iso F G\ninst‚úù : F.IsRepresentable\n‚ä¢ G.IsRepresentable","decl":"theorem isRepresentable_of_natIso (F : C·µí·µñ ‚•§ Type v‚ÇÅ) {G} (i : F ‚âÖ G) [F.IsRepresentable] :\n    G.IsRepresentable :=\n  (F.representableBy.ofIso i).isRepresentable\n\n"}
{"name":"CategoryTheory.corepresentable_of_natIso","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nF G : CategoryTheory.Functor C (Type v‚ÇÅ)\ni : CategoryTheory.Iso F G\ninst‚úù : F.IsCorepresentable\n‚ä¢ G.IsCorepresentable","decl":"theorem corepresentable_of_natIso (F : C ‚•§ Type v‚ÇÅ) {G} (i : F ‚âÖ G) [F.IsCorepresentable] :\n    G.IsCorepresentable :=\n  (F.corepresentableBy.ofIso i).isCorepresentable\n\n"}
{"name":"CategoryTheory.instIsCorepresentableIdType","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"‚ä¢ (CategoryTheory.Functor.id (Type v‚ÇÅ)).IsCorepresentable","decl":"instance : Functor.IsCorepresentable (ùü≠ (Type v‚ÇÅ)) :=\n  corepresentable_of_natIso (coyoneda.obj (op PUnit)) Coyoneda.punitIso\n\n"}
{"name":"CategoryTheory.yonedaEquiv_apply","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nF : CategoryTheory.Functor (Opposite C) (Type v‚ÇÅ)\nf : Quiver.Hom (CategoryTheory.yoneda.obj X) F\n‚ä¢ Eq (CategoryTheory.yonedaEquiv f) (f.app { unop := X } (CategoryTheory.CategoryStruct.id X))","decl":"theorem yonedaEquiv_apply {X : C} {F : C·µí·µñ ‚•§ Type v‚ÇÅ} (f : yoneda.obj X ‚ü∂ F) :\n    yonedaEquiv f = f.app (op X) (ùüô X) :=\n  rfl\n\n"}
{"name":"CategoryTheory.yonedaEquiv_symm_app_apply","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nF : CategoryTheory.Functor (Opposite C) (Type v‚ÇÅ)\nx : F.obj { unop := X }\nY : Opposite C\nf : Quiver.Hom (Opposite.unop Y) X\n‚ä¢ Eq ((CategoryTheory.yonedaEquiv.symm x).app Y f) (F.map f.op x)","decl":"@[simp]\ntheorem yonedaEquiv_symm_app_apply {X : C} {F : C·µí·µñ ‚•§ Type v‚ÇÅ} (x : F.obj (op X)) (Y : C·µí·µñ)\n    (f : Y.unop ‚ü∂ X) : (yonedaEquiv.symm x).app Y f = F.map f.op x :=\n  rfl\n\n"}
{"name":"CategoryTheory.yonedaEquiv_naturality","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nF : CategoryTheory.Functor (Opposite C) (Type v‚ÇÅ)\nf : Quiver.Hom (CategoryTheory.yoneda.obj X) F\ng : Quiver.Hom Y X\n‚ä¢ Eq (F.map g.op (CategoryTheory.yonedaEquiv f)) (CategoryTheory.yonedaEquiv (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map g) f))","decl":"/-- See also `yonedaEquiv_naturality'` for a more general version. -/\nlemma yonedaEquiv_naturality {X Y : C} {F : C·µí·µñ ‚•§ Type v‚ÇÅ} (f : yoneda.obj X ‚ü∂ F)\n    (g : Y ‚ü∂ X) : F.map g.op (yonedaEquiv f) = yonedaEquiv (yoneda.map g ‚â´ f) := by\n  change (f.app (op X) ‚â´ F.map g.op) (ùüô X) = f.app (op Y) (ùüô Y ‚â´ g)\n  rw [‚Üê f.naturality]\n  dsimp\n  simp\n\n"}
{"name":"CategoryTheory.yonedaEquiv_naturality'","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : Opposite C\nF : CategoryTheory.Functor (Opposite C) (Type v‚ÇÅ)\nf : Quiver.Hom (CategoryTheory.yoneda.obj (Opposite.unop X)) F\ng : Quiver.Hom X Y\n‚ä¢ Eq (F.map g (CategoryTheory.yonedaEquiv f)) (CategoryTheory.yonedaEquiv (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map g.unop) f))","decl":"/-- Variant of `yonedaEquiv_naturality` with general `g`. This is technically strictly more general\n    than `yonedaEquiv_naturality`, but `yonedaEquiv_naturality` is sometimes preferable because it\n    can avoid the \"motive is not type correct\" error. -/\nlemma yonedaEquiv_naturality' {X Y : C·µí·µñ} {F : C·µí·µñ ‚•§ Type v‚ÇÅ} (f : yoneda.obj (unop X) ‚ü∂ F)\n    (g : X ‚ü∂ Y) : F.map g (yonedaEquiv f) = yonedaEquiv (yoneda.map g.unop ‚â´ f) :=\n  yonedaEquiv_naturality _ _\n\n"}
{"name":"CategoryTheory.yonedaEquiv_comp","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nF G : CategoryTheory.Functor (Opposite C) (Type v‚ÇÅ)\nŒ± : Quiver.Hom (CategoryTheory.yoneda.obj X) F\nŒ≤ : Quiver.Hom F G\n‚ä¢ Eq (CategoryTheory.yonedaEquiv (CategoryTheory.CategoryStruct.comp Œ± Œ≤)) (Œ≤.app { unop := X } (CategoryTheory.yonedaEquiv Œ±))","decl":"lemma yonedaEquiv_comp {X : C} {F G : C·µí·µñ ‚•§ Type v‚ÇÅ} (Œ± : yoneda.obj X ‚ü∂ F) (Œ≤ : F ‚ü∂ G) :\n    yonedaEquiv (Œ± ‚â´ Œ≤) = Œ≤.app _ (yonedaEquiv Œ±) :=\n  rfl\n\n"}
{"name":"CategoryTheory.yonedaEquiv_yoneda_map","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.yonedaEquiv (CategoryTheory.yoneda.map f)) f","decl":"lemma yonedaEquiv_yoneda_map {X Y : C} (f : X ‚ü∂ Y) : yonedaEquiv (yoneda.map f) = f := by\n  rw [yonedaEquiv_apply]\n  simp\n\n"}
{"name":"CategoryTheory.yonedaEquiv_symm_naturality_left","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX X' : C\nf : Quiver.Hom X' X\nF : CategoryTheory.Functor (Opposite C) (Type v‚ÇÅ)\nx : F.obj { unop := X }\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map f) (CategoryTheory.yonedaEquiv.symm x)) (CategoryTheory.yonedaEquiv.symm (F.map f.op x))","decl":"lemma yonedaEquiv_symm_naturality_left {X X' : C} (f : X' ‚ü∂ X) (F : C·µí·µñ ‚•§ Type v‚ÇÅ)\n    (x : F.obj ‚ü®X‚ü©) : yoneda.map f ‚â´ yonedaEquiv.symm x = yonedaEquiv.symm ((F.map f.op) x) := by\n  apply yonedaEquiv.injective\n  simp only [yonedaEquiv_comp, yoneda_obj_obj, yonedaEquiv_symm_app_apply, Equiv.apply_symm_apply]\n  erw [yonedaEquiv_yoneda_map]\n\n"}
{"name":"CategoryTheory.yonedaEquiv_symm_naturality_right","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nF F' : CategoryTheory.Functor (Opposite C) (Type v‚ÇÅ)\nf : Quiver.Hom F F'\nx : F.obj { unop := X }\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.yonedaEquiv.symm x) f) (CategoryTheory.yonedaEquiv.symm (f.app { unop := X } x))","decl":"lemma yonedaEquiv_symm_naturality_right (X : C) {F F' : C·µí·µñ ‚•§ Type v‚ÇÅ} (f : F ‚ü∂ F')\n    (x : F.obj ‚ü®X‚ü©) : yonedaEquiv.symm x ‚â´ f = yonedaEquiv.symm (f.app ‚ü®X‚ü© x) := by\n  apply yonedaEquiv.injective\n  simp [yonedaEquiv_comp]\n\n"}
{"name":"CategoryTheory.map_yonedaEquiv","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nF : CategoryTheory.Functor (Opposite C) (Type v‚ÇÅ)\nf : Quiver.Hom (CategoryTheory.yoneda.obj X) F\ng : Quiver.Hom Y X\n‚ä¢ Eq (F.map g.op (CategoryTheory.yonedaEquiv f)) (f.app { unop := Y } g)","decl":"/-- See also `map_yonedaEquiv'` for a more general version. -/\nlemma map_yonedaEquiv {X Y : C} {F : C·µí·µñ ‚•§ Type v‚ÇÅ} (f : yoneda.obj X ‚ü∂ F)\n    (g : Y ‚ü∂ X) : F.map g.op (yonedaEquiv f) = f.app (op Y) g := by\n  rw [yonedaEquiv_naturality, yonedaEquiv_comp, yonedaEquiv_yoneda_map]\n\n"}
{"name":"CategoryTheory.map_yonedaEquiv'","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : Opposite C\nF : CategoryTheory.Functor (Opposite C) (Type v‚ÇÅ)\nf : Quiver.Hom (CategoryTheory.yoneda.obj (Opposite.unop X)) F\ng : Quiver.Hom X Y\n‚ä¢ Eq (F.map g (CategoryTheory.yonedaEquiv f)) (f.app Y g.unop)","decl":"/-- Variant of `map_yonedaEquiv` with general `g`. This is technically strictly more general\n    than `map_yonedaEquiv`, but `map_yonedaEquiv` is sometimes preferable because it\n    can avoid the \"motive is not type correct\" error. -/\nlemma map_yonedaEquiv' {X Y : C·µí·µñ} {F : C·µí·µñ ‚•§ Type v‚ÇÅ} (f : yoneda.obj (unop X) ‚ü∂ F)\n    (g : X ‚ü∂ Y) : F.map g (yonedaEquiv f) = f.app Y g.unop := by\n  rw [yonedaEquiv_naturality', yonedaEquiv_comp, yonedaEquiv_yoneda_map]\n\n"}
{"name":"CategoryTheory.yonedaEquiv_symm_map","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : Opposite C\nf : Quiver.Hom X Y\nF : CategoryTheory.Functor (Opposite C) (Type v‚ÇÅ)\nt : F.obj X\n‚ä¢ Eq (CategoryTheory.yonedaEquiv.symm (F.map f t)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map f.unop) (CategoryTheory.yonedaEquiv.symm t))","decl":"lemma yonedaEquiv_symm_map {X Y : C·µí·µñ} (f : X ‚ü∂ Y) {F : C·µí·µñ ‚•§ Type v‚ÇÅ} (t : F.obj X) :\n    yonedaEquiv.symm (F.map f t) = yoneda.map f.unop ‚â´ yonedaEquiv.symm t := by\n  obtain ‚ü®u, rfl‚ü© := yonedaEquiv.surjective t\n  rw [yonedaEquiv_naturality', Equiv.symm_apply_apply, Equiv.symm_apply_apply]\n\n"}
{"name":"CategoryTheory.hom_ext_yoneda","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nP Q : CategoryTheory.Functor (Opposite C) (Type v‚ÇÅ)\nf g : Quiver.Hom P Q\nh : ‚àÄ (X : C) (p : Quiver.Hom (CategoryTheory.yoneda.obj X) P), Eq (CategoryTheory.CategoryStruct.comp p f) (CategoryTheory.CategoryStruct.comp p g)\n‚ä¢ Eq f g","decl":"/-- Two morphisms of presheaves of types `P ‚ü∂ Q` coincide if the precompositions\nwith morphisms `yoneda.obj X ‚ü∂ P` agree. -/\nlemma hom_ext_yoneda {P Q : C·µí·µñ ‚•§ Type v‚ÇÅ} {f g : P ‚ü∂ Q}\n    (h : ‚àÄ (X : C) (p : yoneda.obj X ‚ü∂ P), p ‚â´ f = p ‚â´ g) :\n    f = g := by\n  ext X x\n  simpa only [yonedaEquiv_comp, Equiv.apply_symm_apply]\n    using congr_arg (yonedaEquiv) (h _ (yonedaEquiv.symm x))\n\n"}
{"name":"CategoryTheory.yonedaEvaluation_map_down","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nP Q : Prod (Opposite C) (CategoryTheory.Functor (Opposite C) (Type v‚ÇÅ))\nŒ± : Quiver.Hom P Q\nx : (CategoryTheory.yonedaEvaluation C).obj P\n‚ä¢ Eq ((CategoryTheory.yonedaEvaluation C).map Œ± x).down (Œ±.2.app Q.1 (P.2.map Œ±.1 x.down))","decl":"@[simp]\ntheorem yonedaEvaluation_map_down (P Q : C·µí·µñ √ó (C·µí·µñ ‚•§ Type v‚ÇÅ)) (Œ± : P ‚ü∂ Q)\n    (x : (yonedaEvaluation C).obj P) :\n    ((yonedaEvaluation C).map Œ± x).down = Œ±.2.app Q.1 (P.2.map Œ±.1 x.down) :=\n  rfl\n\n"}
{"name":"CategoryTheory.yonedaPairingExt","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : Prod (Opposite C) (CategoryTheory.Functor (Opposite C) (Type v‚ÇÅ))\nx y : (CategoryTheory.yonedaPairing C).obj X\nw : ‚àÄ (Y : Opposite C), Eq (x.app Y) (y.app Y)\n‚ä¢ Eq x y","decl":"@[ext]\nlemma yonedaPairingExt {X : C·µí·µñ √ó (C·µí·µñ ‚•§ Type v‚ÇÅ)} {x y : (yonedaPairing C).obj X}\n    (w : ‚àÄ Y, x.app Y = y.app Y) : x = y :=\n  NatTrans.ext (funext w)\n\n"}
{"name":"CategoryTheory.yonedaPairingExt_iff","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : Prod (Opposite C) (CategoryTheory.Functor (Opposite C) (Type v‚ÇÅ))\nx y : (CategoryTheory.yonedaPairing C).obj X\n‚ä¢ Iff (Eq x y) (‚àÄ (Y : Opposite C), Eq (x.app Y) (y.app Y))","decl":"@[ext]\nlemma yonedaPairingExt {X : C·µí·µñ √ó (C·µí·µñ ‚•§ Type v‚ÇÅ)} {x y : (yonedaPairing C).obj X}\n    (w : ‚àÄ Y, x.app Y = y.app Y) : x = y :=\n  NatTrans.ext (funext w)\n\n"}
{"name":"CategoryTheory.yonedaPairing_map","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nP Q : Prod (Opposite C) (CategoryTheory.Functor (Opposite C) (Type v‚ÇÅ))\nŒ± : Quiver.Hom P Q\nŒ≤ : (CategoryTheory.yonedaPairing C).obj P\n‚ä¢ Eq ((CategoryTheory.yonedaPairing C).map Œ± Œ≤) (CategoryTheory.CategoryStruct.comp (CategoryTheory.yoneda.map Œ±.1.unop) (CategoryTheory.CategoryStruct.comp Œ≤ Œ±.2))","decl":"@[simp]\ntheorem yonedaPairing_map (P Q : C·µí·µñ √ó (C·µí·µñ ‚•§ Type v‚ÇÅ)) (Œ± : P ‚ü∂ Q) (Œ≤ : (yonedaPairing C).obj P) :\n    (yonedaPairing C).map Œ± Œ≤ = yoneda.map Œ±.1.unop ‚â´ Œ≤ ‚â´ Œ±.2 :=\n  rfl\n\n"}
{"name":"CategoryTheory.isIso_of_yoneda_map_bijective","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nhf : ‚àÄ (T : C), Function.Bijective fun x => CategoryTheory.CategoryStruct.comp x f\n‚ä¢ CategoryTheory.IsIso f","decl":"lemma isIso_of_yoneda_map_bijective {X Y : C} (f : X ‚ü∂ Y)\n    (hf : ‚àÄ (T : C), Function.Bijective (fun (x : T ‚ü∂ X) => x ‚â´ f)) :\n    IsIso f := by\n  obtain ‚ü®g, hg : g ‚â´ f = ùüô Y‚ü© := (hf Y).2 (ùüô Y)\n  exact ‚ü®g, (hf _).1 (by aesop_cat), hg‚ü©\n\n"}
{"name":"CategoryTheory.isIso_iff_yoneda_map_bijective","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Iff (CategoryTheory.IsIso f) (‚àÄ (T : C), Function.Bijective fun x => CategoryTheory.CategoryStruct.comp x f)","decl":"lemma isIso_iff_yoneda_map_bijective {X Y : C} (f : X ‚ü∂ Y) :\n    IsIso f ‚Üî (‚àÄ (T : C), Function.Bijective (fun (x : T ‚ü∂ X) => x ‚â´ f)) := by\n  refine ‚ü®fun _ ‚Ü¶ ?_, fun hf ‚Ü¶ isIso_of_yoneda_map_bijective f hf‚ü©\n  have : IsIso (yoneda.map f) := inferInstance\n  intro T\n  rw [‚Üê isIso_iff_bijective]\n  exact inferInstanceAs (IsIso ((yoneda.map f).app _))\n\n"}
{"name":"CategoryTheory.isIso_iff_isIso_yoneda_map","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Iff (CategoryTheory.IsIso f) (‚àÄ (c : C), CategoryTheory.IsIso ((CategoryTheory.yoneda.map f).app { unop := c }))","decl":"lemma isIso_iff_isIso_yoneda_map {X Y : C} (f : X ‚ü∂ Y) :\n    IsIso f ‚Üî ‚àÄ c : C, IsIso ((yoneda.map f).app ‚ü®c‚ü©) := by\n  rw [isIso_iff_yoneda_map_bijective]\n  exact forall_congr' fun _ ‚Ü¶ (isIso_iff_bijective _).symm\n\n"}
{"name":"CategoryTheory.coyonedaEquiv_apply","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nF : CategoryTheory.Functor C (Type v‚ÇÅ)\nf : Quiver.Hom (CategoryTheory.coyoneda.obj { unop := X }) F\n‚ä¢ Eq (CategoryTheory.coyonedaEquiv f) (f.app X (CategoryTheory.CategoryStruct.id X))","decl":"theorem coyonedaEquiv_apply {X : C} {F : C ‚•§ Type v‚ÇÅ} (f : coyoneda.obj (op X) ‚ü∂ F) :\n    coyonedaEquiv f = f.app X (ùüô X) :=\n  rfl\n\n"}
{"name":"CategoryTheory.coyonedaEquiv_symm_app_apply","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nF : CategoryTheory.Functor C (Type v‚ÇÅ)\nx : F.obj X\nY : C\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.coyonedaEquiv.symm x).app Y f) (F.map f x)","decl":"@[simp]\ntheorem coyonedaEquiv_symm_app_apply {X : C} {F : C ‚•§ Type v‚ÇÅ} (x : F.obj X) (Y : C)\n    (f : X ‚ü∂ Y) : (coyonedaEquiv.symm x).app Y f = F.map f x :=\n  rfl\n\n"}
{"name":"CategoryTheory.coyonedaEquiv_naturality","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nF : CategoryTheory.Functor C (Type v‚ÇÅ)\nf : Quiver.Hom (CategoryTheory.coyoneda.obj { unop := X }) F\ng : Quiver.Hom X Y\n‚ä¢ Eq (F.map g (CategoryTheory.coyonedaEquiv f)) (CategoryTheory.coyonedaEquiv (CategoryTheory.CategoryStruct.comp (CategoryTheory.coyoneda.map g.op) f))","decl":"lemma coyonedaEquiv_naturality {X Y : C} {F : C ‚•§ Type v‚ÇÅ} (f : coyoneda.obj (op X) ‚ü∂ F)\n    (g : X ‚ü∂ Y) : F.map g (coyonedaEquiv f) = coyonedaEquiv (coyoneda.map g.op ‚â´ f) := by\n  change (f.app X ‚â´ F.map g) (ùüô X) = f.app Y (g ‚â´ ùüô Y)\n  rw [‚Üê f.naturality]\n  dsimp\n  simp\n\n"}
{"name":"CategoryTheory.coyonedaEquiv_comp","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nF G : CategoryTheory.Functor C (Type v‚ÇÅ)\nŒ± : Quiver.Hom (CategoryTheory.coyoneda.obj { unop := X }) F\nŒ≤ : Quiver.Hom F G\n‚ä¢ Eq (CategoryTheory.coyonedaEquiv (CategoryTheory.CategoryStruct.comp Œ± Œ≤)) (Œ≤.app X (CategoryTheory.coyonedaEquiv Œ±))","decl":"lemma coyonedaEquiv_comp {X : C} {F G : C ‚•§ Type v‚ÇÅ} (Œ± : coyoneda.obj (op X) ‚ü∂ F) (Œ≤ : F ‚ü∂ G) :\n    coyonedaEquiv (Œ± ‚â´ Œ≤) = Œ≤.app _ (coyonedaEquiv Œ±) := by\n  rfl\n\n"}
{"name":"CategoryTheory.coyonedaEquiv_coyoneda_map","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.coyonedaEquiv (CategoryTheory.coyoneda.map f.op)) f","decl":"lemma coyonedaEquiv_coyoneda_map {X Y : C} (f : X ‚ü∂ Y) :\n    coyonedaEquiv (coyoneda.map f.op) = f := by\n  rw [coyonedaEquiv_apply]\n  simp\n\n"}
{"name":"CategoryTheory.map_coyonedaEquiv","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nF : CategoryTheory.Functor C (Type v‚ÇÅ)\nf : Quiver.Hom (CategoryTheory.coyoneda.obj { unop := X }) F\ng : Quiver.Hom X Y\n‚ä¢ Eq (F.map g (CategoryTheory.coyonedaEquiv f)) (f.app Y g)","decl":"lemma map_coyonedaEquiv {X Y : C} {F : C ‚•§ Type v‚ÇÅ} (f : coyoneda.obj (op X) ‚ü∂ F)\n    (g : X ‚ü∂ Y) : F.map g (coyonedaEquiv f) = f.app Y g := by\n  rw [coyonedaEquiv_naturality, coyonedaEquiv_comp, coyonedaEquiv_coyoneda_map]\n\n"}
{"name":"CategoryTheory.coyonedaEquiv_symm_map","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nF : CategoryTheory.Functor C (Type v‚ÇÅ)\nt : F.obj X\n‚ä¢ Eq (CategoryTheory.coyonedaEquiv.symm (F.map f t)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.coyoneda.map f.op) (CategoryTheory.coyonedaEquiv.symm t))","decl":"lemma coyonedaEquiv_symm_map {X Y : C} (f : X ‚ü∂ Y) {F : C ‚•§ Type v‚ÇÅ} (t : F.obj X) :\n    coyonedaEquiv.symm (F.map f t) = coyoneda.map f.op ‚â´ coyonedaEquiv.symm t := by\n  obtain ‚ü®u, rfl‚ü© := coyonedaEquiv.surjective t\n  simp [coyonedaEquiv_naturality u f]\n\n"}
{"name":"CategoryTheory.coyonedaEvaluation_map_down","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nP Q : Prod C (CategoryTheory.Functor C (Type v‚ÇÅ))\nŒ± : Quiver.Hom P Q\nx : (CategoryTheory.coyonedaEvaluation C).obj P\n‚ä¢ Eq ((CategoryTheory.coyonedaEvaluation C).map Œ± x).down (Œ±.2.app Q.1 (P.2.map Œ±.1 x.down))","decl":"@[simp]\ntheorem coyonedaEvaluation_map_down (P Q : C √ó (C ‚•§ Type v‚ÇÅ)) (Œ± : P ‚ü∂ Q)\n    (x : (coyonedaEvaluation C).obj P) :\n    ((coyonedaEvaluation C).map Œ± x).down = Œ±.2.app Q.1 (P.2.map Œ±.1 x.down) :=\n  rfl\n\n"}
{"name":"CategoryTheory.coyonedaPairingExt","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : Prod C (CategoryTheory.Functor C (Type v‚ÇÅ))\nx y : (CategoryTheory.coyonedaPairing C).obj X\nw : ‚àÄ (Y : C), Eq (x.app Y) (y.app Y)\n‚ä¢ Eq x y","decl":"@[ext]\nlemma coyonedaPairingExt {X : C √ó (C ‚•§ Type v‚ÇÅ)} {x y : (coyonedaPairing C).obj X}\n    (w : ‚àÄ Y, x.app Y = y.app Y) : x = y :=\n  NatTrans.ext (funext w)\n\n"}
{"name":"CategoryTheory.coyonedaPairingExt_iff","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : Prod C (CategoryTheory.Functor C (Type v‚ÇÅ))\nx y : (CategoryTheory.coyonedaPairing C).obj X\n‚ä¢ Iff (Eq x y) (‚àÄ (Y : C), Eq (x.app Y) (y.app Y))","decl":"@[ext]\nlemma coyonedaPairingExt {X : C √ó (C ‚•§ Type v‚ÇÅ)} {x y : (coyonedaPairing C).obj X}\n    (w : ‚àÄ Y, x.app Y = y.app Y) : x = y :=\n  NatTrans.ext (funext w)\n\n"}
{"name":"CategoryTheory.coyonedaPairing_map","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nP Q : Prod C (CategoryTheory.Functor C (Type v‚ÇÅ))\nŒ± : Quiver.Hom P Q\nŒ≤ : (CategoryTheory.coyonedaPairing C).obj P\n‚ä¢ Eq ((CategoryTheory.coyonedaPairing C).map Œ± Œ≤) (CategoryTheory.CategoryStruct.comp (CategoryTheory.coyoneda.map Œ±.1.op) (CategoryTheory.CategoryStruct.comp Œ≤ Œ±.2))","decl":"@[simp]\ntheorem coyonedaPairing_map (P Q : C √ó (C ‚•§ Type v‚ÇÅ)) (Œ± : P ‚ü∂ Q) (Œ≤ : (coyonedaPairing C).obj P) :\n    (coyonedaPairing C).map Œ± Œ≤ = coyoneda.map Œ±.1.op ‚â´ Œ≤ ‚â´ Œ±.2 :=\n  rfl\n\n"}
{"name":"CategoryTheory.isIso_of_coyoneda_map_bijective","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\nhf : ‚àÄ (T : C), Function.Bijective fun x => CategoryTheory.CategoryStruct.comp f x\n‚ä¢ CategoryTheory.IsIso f","decl":"lemma isIso_of_coyoneda_map_bijective {X Y : C} (f : X ‚ü∂ Y)\n    (hf : ‚àÄ (T : C), Function.Bijective (fun (x : Y ‚ü∂ T) => f ‚â´ x)) :\n    IsIso f := by\n  obtain ‚ü®g, hg : f ‚â´ g = ùüô X‚ü© := (hf X).2 (ùüô X)\n  refine ‚ü®g, hg, (hf _).1 ?_‚ü©\n  simp only [Category.comp_id, ‚Üê Category.assoc, hg, Category.id_comp]\n\n"}
{"name":"CategoryTheory.isIso_iff_coyoneda_map_bijective","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Iff (CategoryTheory.IsIso f) (‚àÄ (T : C), Function.Bijective fun x => CategoryTheory.CategoryStruct.comp f x)","decl":"lemma isIso_iff_coyoneda_map_bijective {X Y : C} (f : X ‚ü∂ Y) :\n    IsIso f ‚Üî (‚àÄ (T : C), Function.Bijective (fun (x : Y ‚ü∂ T) => f ‚â´ x)) := by\n  refine ‚ü®fun _ ‚Ü¶ ?_, fun hf ‚Ü¶ isIso_of_coyoneda_map_bijective f hf‚ü©\n  have : IsIso (coyoneda.map f.op) := inferInstance\n  intro T\n  rw [‚Üê isIso_iff_bijective]\n  exact inferInstanceAs (IsIso ((coyoneda.map f.op).app _))\n\n"}
{"name":"CategoryTheory.isIso_iff_isIso_coyoneda_map","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Iff (CategoryTheory.IsIso f) (‚àÄ (c : C), CategoryTheory.IsIso ((CategoryTheory.coyoneda.map f.op).app c))","decl":"lemma isIso_iff_isIso_coyoneda_map {X Y : C} (f : X ‚ü∂ Y) :\n    IsIso f ‚Üî ‚àÄ c : C, IsIso ((coyoneda.map f.op).app c) := by\n  rw [isIso_iff_coyoneda_map_bijective]\n  exact forall_congr' fun _ ‚Ü¶ (isIso_iff_bijective _).symm\n\n"}
{"name":"CategoryTheory.yonedaMap_app_apply","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u_1} D\nF : CategoryTheory.Functor C D\nY : C\nX : Opposite C\nf : Quiver.Hom (Opposite.unop X) Y\n‚ä¢ Eq ((CategoryTheory.yonedaMap F Y).app X f) (F.map f)","decl":"@[simp]\nlemma yonedaMap_app_apply {Y : C} {X : C·µí·µñ} (f : X.unop ‚ü∂ Y) :\n    (yonedaMap F Y).app X f = F.map f := rfl\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.homNatIso_hom_app_down","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\nX‚úù : C\nX : Opposite C\na‚úù : (F.op.comp ((CategoryTheory.yoneda.obj (F.obj X‚úù)).comp CategoryTheory.uliftFunctor.{v‚ÇÅ, v‚ÇÇ})).obj X\n‚ä¢ Eq ((hF.homNatIso X‚úù).hom.app X a‚úù).down (hF.preimage a‚úù.down)","decl":"/-- `FullyFaithful.homEquiv` as a natural isomorphism. -/\n@[simps!]\ndef homNatIso {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D] {F : C ‚•§ D} (hF : F.FullyFaithful) (X : C) :\n    F.op ‚ãô yoneda.obj (F.obj X) ‚ãô uliftFunctor.{v‚ÇÅ} ‚âÖ yoneda.obj X ‚ãô uliftFunctor.{v‚ÇÇ} :=\n  NatIso.ofComponents\n    (fun Y => Equiv.toIso (Equiv.ulift.trans <| hF.homEquiv.symm.trans Equiv.ulift.symm))\n    (fun f => by ext; exact Equiv.ulift.injective (hF.map_injective (by simp)))\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.homNatIso_inv_app_down","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\nX‚úù : C\nX : Opposite C\na‚úù : ((CategoryTheory.yoneda.obj X‚úù).comp CategoryTheory.uliftFunctor.{v‚ÇÇ, v‚ÇÅ}).obj X\n‚ä¢ Eq ((hF.homNatIso X‚úù).inv.app X a‚úù).down (F.map a‚úù.down)","decl":"/-- `FullyFaithful.homEquiv` as a natural isomorphism. -/\n@[simps!]\ndef homNatIso {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D] {F : C ‚•§ D} (hF : F.FullyFaithful) (X : C) :\n    F.op ‚ãô yoneda.obj (F.obj X) ‚ãô uliftFunctor.{v‚ÇÅ} ‚âÖ yoneda.obj X ‚ãô uliftFunctor.{v‚ÇÇ} :=\n  NatIso.ofComponents\n    (fun Y => Equiv.toIso (Equiv.ulift.trans <| hF.homEquiv.symm.trans Equiv.ulift.symm))\n    (fun f => by ext; exact Equiv.ulift.injective (hF.map_injective (by simp)))\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.homNatIsoMaxRight_hom_app_down","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{max v‚ÇÅ v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\nX‚úù : C\nX : Opposite C\na‚úù : (F.op.comp (CategoryTheory.yoneda.obj (F.obj X‚úù))).obj X\n‚ä¢ Eq ((hF.homNatIsoMaxRight X‚úù).hom.app X a‚úù).down (hF.preimage a‚úù)","decl":"/-- `FullyFaithful.homEquiv` as a natural isomorphism. -/\n@[simps!]\ndef homNatIsoMaxRight {D : Type u‚ÇÇ} [Category.{max v‚ÇÅ v‚ÇÇ} D] {F : C ‚•§ D} (hF : F.FullyFaithful)\n    (X : C) : F.op ‚ãô yoneda.obj (F.obj X) ‚âÖ yoneda.obj X ‚ãô uliftFunctor.{v‚ÇÇ} :=\n  NatIso.ofComponents\n    (fun Y => Equiv.toIso (hF.homEquiv.symm.trans Equiv.ulift.symm))\n    (fun f => by ext; exact Equiv.ulift.injective (hF.map_injective (by simp)))\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.homNatIsoMaxRight_inv_app","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{max v‚ÇÅ v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\nX‚úù : C\nX : Opposite C\na‚úù : ((CategoryTheory.yoneda.obj X‚úù).comp CategoryTheory.uliftFunctor.{v‚ÇÇ, v‚ÇÅ}).obj X\n‚ä¢ Eq ((hF.homNatIsoMaxRight X‚úù).inv.app X a‚úù) (F.map a‚úù.down)","decl":"/-- `FullyFaithful.homEquiv` as a natural isomorphism. -/\n@[simps!]\ndef homNatIsoMaxRight {D : Type u‚ÇÇ} [Category.{max v‚ÇÅ v‚ÇÇ} D] {F : C ‚•§ D} (hF : F.FullyFaithful)\n    (X : C) : F.op ‚ãô yoneda.obj (F.obj X) ‚âÖ yoneda.obj X ‚ãô uliftFunctor.{v‚ÇÇ} :=\n  NatIso.ofComponents\n    (fun Y => Equiv.toIso (hF.homEquiv.symm.trans Equiv.ulift.symm))\n    (fun f => by ext; exact Equiv.ulift.injective (hF.map_injective (by simp)))\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.compYonedaCompWhiskeringLeft_inv_app_app_down","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\nX‚úù : C\nX : Opposite C\na‚úù : ((CategoryTheory.yoneda.obj X‚úù).comp CategoryTheory.uliftFunctor.{v‚ÇÇ, v‚ÇÅ}).obj X\n‚ä¢ Eq ((hF.compYonedaCompWhiskeringLeft.inv.app X‚úù).app X a‚úù).down (F.map a‚úù.down)","decl":"/-- `FullyFaithful.homEquiv` as a natural isomorphism. -/\n@[simps!]\ndef compYonedaCompWhiskeringLeft {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D] {F : C ‚•§ D}\n    (hF : F.FullyFaithful) : F ‚ãô yoneda ‚ãô (whiskeringLeft _ _ _).obj F.op ‚ãô\n      (CategoryTheory.whiskeringRight _ _ _).obj uliftFunctor.{v‚ÇÅ} ‚âÖ\n      yoneda ‚ãô (CategoryTheory.whiskeringRight _ _ _).obj uliftFunctor.{v‚ÇÇ} :=\n  NatIso.ofComponents (fun X => hF.homNatIso _)\n    (fun f => by ext; exact Equiv.ulift.injective (hF.map_injective (by simp)))\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.compYonedaCompWhiskeringLeft_hom_app_app_down","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\nX‚úù : C\nX : Opposite C\na‚úù : (F.op.comp ((CategoryTheory.yoneda.obj (F.obj X‚úù)).comp CategoryTheory.uliftFunctor.{v‚ÇÅ, v‚ÇÇ})).obj X\n‚ä¢ Eq ((hF.compYonedaCompWhiskeringLeft.hom.app X‚úù).app X a‚úù).down (hF.preimage a‚úù.down)","decl":"/-- `FullyFaithful.homEquiv` as a natural isomorphism. -/\n@[simps!]\ndef compYonedaCompWhiskeringLeft {D : Type u‚ÇÇ} [Category.{v‚ÇÇ} D] {F : C ‚•§ D}\n    (hF : F.FullyFaithful) : F ‚ãô yoneda ‚ãô (whiskeringLeft _ _ _).obj F.op ‚ãô\n      (CategoryTheory.whiskeringRight _ _ _).obj uliftFunctor.{v‚ÇÅ} ‚âÖ\n      yoneda ‚ãô (CategoryTheory.whiskeringRight _ _ _).obj uliftFunctor.{v‚ÇÇ} :=\n  NatIso.ofComponents (fun X => hF.homNatIso _)\n    (fun f => by ext; exact Equiv.ulift.injective (hF.map_injective (by simp)))\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.compYonedaCompWhiskeringLeftMaxRight_inv_app_app","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{max v‚ÇÅ v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\nX‚úù : C\nX : Opposite C\na‚úù : ((CategoryTheory.yoneda.obj X‚úù).comp CategoryTheory.uliftFunctor.{v‚ÇÇ, v‚ÇÅ}).obj X\n‚ä¢ Eq ((hF.compYonedaCompWhiskeringLeftMaxRight.inv.app X‚úù).app X a‚úù) (F.map a‚úù.down)","decl":"/-- `FullyFaithful.homEquiv` as a natural isomorphism. -/\n@[simps!]\ndef compYonedaCompWhiskeringLeftMaxRight {D : Type u‚ÇÇ} [Category.{max v‚ÇÅ v‚ÇÇ} D] {F : C ‚•§ D}\n    (hF : F.FullyFaithful) : F ‚ãô yoneda ‚ãô (whiskeringLeft _ _ _).obj F.op ‚âÖ\n      yoneda ‚ãô (CategoryTheory.whiskeringRight _ _ _).obj uliftFunctor.{v‚ÇÇ} :=\n  NatIso.ofComponents (fun X => hF.homNatIsoMaxRight _)\n    (fun f => by ext; exact Equiv.ulift.injective (hF.map_injective (by simp)))\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.compYonedaCompWhiskeringLeftMaxRight_hom_app_app_down","module":"Mathlib.CategoryTheory.Yoneda","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{max v‚ÇÅ v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nhF : F.FullyFaithful\nX‚úù : C\nX : Opposite C\na‚úù : (F.op.comp (CategoryTheory.yoneda.obj (F.obj X‚úù))).obj X\n‚ä¢ Eq ((hF.compYonedaCompWhiskeringLeftMaxRight.hom.app X‚úù).app X a‚úù).down (hF.preimage a‚úù)","decl":"/-- `FullyFaithful.homEquiv` as a natural isomorphism. -/\n@[simps!]\ndef compYonedaCompWhiskeringLeftMaxRight {D : Type u‚ÇÇ} [Category.{max v‚ÇÅ v‚ÇÇ} D] {F : C ‚•§ D}\n    (hF : F.FullyFaithful) : F ‚ãô yoneda ‚ãô (whiskeringLeft _ _ _).obj F.op ‚âÖ\n      yoneda ‚ãô (CategoryTheory.whiskeringRight _ _ _).obj uliftFunctor.{v‚ÇÇ} :=\n  NatIso.ofComponents (fun X => hF.homNatIsoMaxRight _)\n    (fun f => by ext; exact Equiv.ulift.injective (hF.map_injective (by simp)))\n\n"}
