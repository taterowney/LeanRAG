{"name":"PseudoMetricSpace.dist_ofPreNNDist","module":"Mathlib.Topology.Metrizable.Uniformity","initialProofState":"X : Type u_1\nd : X ‚Üí X ‚Üí NNReal\ndist_self : ‚àÄ (x : X), Eq (d x x) 0\ndist_comm : ‚àÄ (x y : X), Eq (d x y) (d y x)\nx y : X\n‚ä¢ Eq (Dist.dist x y) ‚Üë(iInf fun l => (List.zipWith d (List.cons x l) (HAppend.hAppend l (List.cons y List.nil))).sum)","decl":"theorem dist_ofPreNNDist (d : X ‚Üí X ‚Üí ‚Ñù‚â•0) (dist_self : ‚àÄ x, d x x = 0)\n    (dist_comm : ‚àÄ x y, d x y = d y x) (x y : X) :\n    @dist X (@PseudoMetricSpace.toDist X (PseudoMetricSpace.ofPreNNDist d dist_self dist_comm)) x\n        y =\n      ‚Üë(‚®Ö l : List X, ((x::l).zipWith d (l ++ [y])).sum : ‚Ñù‚â•0) :=\n  rfl\n\n"}
{"name":"PseudoMetricSpace.dist_ofPreNNDist_le","module":"Mathlib.Topology.Metrizable.Uniformity","initialProofState":"X : Type u_1\nd : X ‚Üí X ‚Üí NNReal\ndist_self : ‚àÄ (x : X), Eq (d x x) 0\ndist_comm : ‚àÄ (x y : X), Eq (d x y) (d y x)\nx y : X\n‚ä¢ LE.le (Dist.dist x y) ‚Üë(d x y)","decl":"theorem dist_ofPreNNDist_le (d : X ‚Üí X ‚Üí ‚Ñù‚â•0) (dist_self : ‚àÄ x, d x x = 0)\n    (dist_comm : ‚àÄ x y, d x y = d y x) (x y : X) :\n    @dist X (@PseudoMetricSpace.toDist X (PseudoMetricSpace.ofPreNNDist d dist_self dist_comm)) x\n        y ‚â§\n      d x y :=\n  NNReal.coe_le_coe.2 <| (ciInf_le (OrderBot.bddBelow _) []).trans_eq <| by simp\n\n"}
{"name":"PseudoMetricSpace.le_two_mul_dist_ofPreNNDist","module":"Mathlib.Topology.Metrizable.Uniformity","initialProofState":"X : Type u_1\nd : X ‚Üí X ‚Üí NNReal\ndist_self : ‚àÄ (x : X), Eq (d x x) 0\ndist_comm : ‚àÄ (x y : X), Eq (d x y) (d y x)\nhd : ‚àÄ (x‚ÇÅ x‚ÇÇ x‚ÇÉ x‚ÇÑ : X), LE.le (d x‚ÇÅ x‚ÇÑ) (HMul.hMul 2 (Max.max (d x‚ÇÅ x‚ÇÇ) (Max.max (d x‚ÇÇ x‚ÇÉ) (d x‚ÇÉ x‚ÇÑ))))\nx y : X\n‚ä¢ LE.le (‚Üë(d x y)) (HMul.hMul 2 (Dist.dist x y))","decl":"/-- Consider a function `d : X ‚Üí X ‚Üí ‚Ñù‚â•0` such that `d x x = 0` and `d x y = d y x` for all `x`,\n`y`. Let `dist` be the largest pseudometric distance such that `dist x y ‚â§ d x y`, see\n`PseudoMetricSpace.ofPreNNDist`. Suppose that `d` satisfies the following triangle-like\ninequality: `d x‚ÇÅ x‚ÇÑ ‚â§ 2 * max (d x‚ÇÅ x‚ÇÇ, d x‚ÇÇ x‚ÇÉ, d x‚ÇÉ x‚ÇÑ)`. Then `d x y ‚â§ 2 * dist x y` for all\n`x`, `y`. -/\ntheorem le_two_mul_dist_ofPreNNDist (d : X ‚Üí X ‚Üí ‚Ñù‚â•0) (dist_self : ‚àÄ x, d x x = 0)\n    (dist_comm : ‚àÄ x y, d x y = d y x)\n    (hd : ‚àÄ x‚ÇÅ x‚ÇÇ x‚ÇÉ x‚ÇÑ, d x‚ÇÅ x‚ÇÑ ‚â§ 2 * max (d x‚ÇÅ x‚ÇÇ) (max (d x‚ÇÇ x‚ÇÉ) (d x‚ÇÉ x‚ÇÑ))) (x y : X) :\n    ‚Üë(d x y) ‚â§ 2 * @dist X\n      (@PseudoMetricSpace.toDist X (PseudoMetricSpace.ofPreNNDist d dist_self dist_comm)) x y := by\n  /- We need to show that `d x y` is at most twice the sum `L` of `d x·µ¢ x·µ¢‚Çä‚ÇÅ` over a path\n    `x‚ÇÄ=x, ..., x‚Çô=y`. We prove it by induction on the length `n` of the sequence. Find an edge that\n    splits the path into two parts of almost equal length: both `d x‚ÇÄ x‚ÇÅ + ... + d x‚Çñ‚Çã‚ÇÅ x‚Çñ` and\n    `d x‚Çñ‚Çä‚ÇÅ x‚Çñ‚Çä‚ÇÇ + ... + d x‚Çô‚Çã‚ÇÅ x‚Çô` are less than or equal to `L / 2`.\n    Then `d x‚ÇÄ x‚Çñ ‚â§ L`, `d x‚Çñ x‚Çñ‚Çä‚ÇÅ ‚â§ L`, and `d x‚Çñ‚Çä‚ÇÅ x‚Çô ‚â§ L`, thus `d x‚ÇÄ x‚Çô ‚â§ 2 * L`. -/\n  rw [dist_ofPreNNDist, ‚Üê NNReal.coe_two, ‚Üê NNReal.coe_mul, NNReal.mul_iInf, NNReal.coe_le_coe]\n  refine le_ciInf fun l => ?_\n  have hd‚ÇÄ_trans : Transitive fun x y => d x y = 0 := by\n    intro a b c hab hbc\n    rw [‚Üê nonpos_iff_eq_zero]\n    simpa only [nonpos_iff_eq_zero, hab, hbc, dist_self c, max_self, mul_zero] using hd a b c c\n  haveI : IsTrans X fun x y => d x y = 0 := ‚ü®hd‚ÇÄ_trans‚ü©\n  induction' hn : length l using Nat.strong_induction_on with n ihn generalizing x y l\n  simp only at ihn\n  subst n\n  set L := zipWith d (x::l) (l ++ [y])\n  have hL_len : length L = length l + 1 := by simp [L]\n  rcases eq_or_ne (d x y) 0 with hd‚ÇÄ | hd‚ÇÄ\n  ¬∑ simp only [hd‚ÇÄ, zero_le]\n  rsuffices ‚ü®z, z', hxz, hzz', hz'y‚ü© : ‚àÉ z z' : X, d x z ‚â§ L.sum ‚àß d z z' ‚â§ L.sum ‚àß d z' y ‚â§ L.sum\n  ¬∑ exact (hd x z z' y).trans (mul_le_mul_left' (max_le hxz (max_le hzz' hz'y)) _)\n  set s : Set ‚Ñï := { m : ‚Ñï | 2 * (take m L).sum ‚â§ L.sum }\n  have hs‚ÇÄ : 0 ‚àà s := by simp [s]\n  have hsne : s.Nonempty := ‚ü®0, hs‚ÇÄ‚ü©\n  obtain ‚ü®M, hMl, hMs‚ü© : ‚àÉ M ‚â§ length l, IsGreatest s M := by\n    have hs_ub : length l ‚àà upperBounds s := by\n      intro m hm\n      rw [‚Üê not_lt, Nat.lt_iff_add_one_le, ‚Üê hL_len]\n      intro hLm\n      rw [mem_setOf_eq, take_of_length_le hLm, two_mul, add_le_iff_nonpos_left, nonpos_iff_eq_zero,\n          sum_eq_zero_iff, ‚Üê forall_iff_forall_mem, forall_zipWith,\n          ‚Üê chain_append_singleton_iff_forall‚ÇÇ]\n          at hm <;>\n        [skip; simp]\n      exact hd‚ÇÄ (hm.rel (mem_append.2 <| Or.inr <| mem_singleton_self _))\n    have hs_bdd : BddAbove s := ‚ü®length l, hs_ub‚ü©\n    exact ‚ü®sSup s, csSup_le hsne hs_ub, ‚ü®Nat.sSup_mem hsne hs_bdd, fun k => le_csSup hs_bdd‚ü©‚ü©\n  have hM_lt : M < length L := by rwa [hL_len, Nat.lt_succ_iff]\n  have hM_ltx : M < length (x::l) := lt_length_left_of_zipWith hM_lt\n  have hM_lty : M < length (l ++ [y]) := lt_length_right_of_zipWith hM_lt\n  refine ‚ü®(x::l)[M], (l ++ [y])[M], ?_, ?_, ?_‚ü©\n  ¬∑ cases M with\n    | zero =>\n      simp [dist_self, List.get]\n    | succ M =>\n      rw [Nat.succ_le_iff] at hMl\n      have hMl' : length (take M l) = M := (length_take _ _).trans (min_eq_left hMl.le)\n      refine (ihn _ hMl _ _ _ hMl').trans ?_\n      convert hMs.1.out\n      rw [take_zipWith, take, take_succ, getElem?_append_left hMl, getElem?_eq_getElem hMl,\n        ‚Üê Option.coe_def, Option.toList_some, take_append_of_le_length hMl.le, getElem_cons_succ]\n  ¬∑ exact single_le_sum (fun x _ => zero_le x) _ (mem_iff_get.2 ‚ü®‚ü®M, hM_lt‚ü©, getElem_zipWith‚ü©)\n  ¬∑ rcases hMl.eq_or_lt with (rfl | hMl)\n    ¬∑ simp only [getElem_append_right le_rfl, sub_self, getElem_singleton, dist_self, zero_le]\n    rw [getElem_append_left hMl]\n    have hlen : length (drop (M + 1) l) = length l - (M + 1) := length_drop _ _\n    have hlen_lt : length l - (M + 1) < length l := Nat.sub_lt_of_pos_le M.succ_pos hMl\n    refine (ihn _ hlen_lt _ y _ hlen).trans ?_\n    rw [cons_getElem_drop_succ]\n    have hMs' : L.sum ‚â§ 2 * (L.take (M + 1)).sum :=\n      not_lt.1 fun h => (hMs.2 h.le).not_lt M.lt_succ_self\n    rw [‚Üê sum_take_add_sum_drop L (M + 1), two_mul, add_le_add_iff_left, ‚Üê add_le_add_iff_right,\n      sum_take_add_sum_drop, ‚Üê two_mul] at hMs'\n    convert hMs'\n    rwa [drop_zipWith, drop, drop_append_of_le_length]\n\n"}
{"name":"UniformSpace.metrizable_uniformity","module":"Mathlib.Topology.Metrizable.Uniformity","initialProofState":"X : Type u_2\ninst‚úù¬π : UniformSpace X\ninst‚úù : (uniformity X).IsCountablyGenerated\n‚ä¢ Exists fun I => Eq PseudoMetricSpace.toUniformSpace inst‚úù¬π","decl":"/-- If `X` is a uniform space with countably generated uniformity filter, there exists a\n`PseudoMetricSpace` structure compatible with the `UniformSpace` structure. Use\n`UniformSpace.pseudoMetricSpace` or `UniformSpace.metricSpace` instead. -/\nprotected theorem UniformSpace.metrizable_uniformity (X : Type*) [UniformSpace X]\n    [IsCountablyGenerated (ùì§ X)] : ‚àÉ I : PseudoMetricSpace X, I.toUniformSpace = ‚Äπ_‚Ä∫ := by\n  classical\n  /- Choose a fast decreasing antitone basis `U : ‚Ñï ‚Üí set (X √ó X)` of the uniformity filter `ùì§ X`.\n    Define `d x y : ‚Ñù‚â•0` to be `(1 / 2) ^ n`, where `n` is the minimal index of `U n` that\n    separates `x` and `y`: `(x, y) ‚àâ U n`, or `0` if `x` is not separated from `y`. This function\n    satisfies the assumptions of `PseudoMetricSpace.ofPreNNDist` and\n    `PseudoMetricSpace.le_two_mul_dist_ofPreNNDist`, hence the distance given by the former pseudo\n    metric space structure is Lipschitz equivalent to the `d`. Thus the uniformities generated by\n    `d` and `dist` are equal. Since the former uniformity is equal to `ùì§ X`, the latter is equal to\n    `ùì§ X` as well. -/\n  obtain ‚ü®U, hU_symm, hU_comp, hB‚ü© :\n    ‚àÉ U : ‚Ñï ‚Üí Set (X √ó X),\n      (‚àÄ n, SymmetricRel (U n)) ‚àß\n        (‚àÄ ‚¶Ém n‚¶Ñ, m < n ‚Üí U n ‚óã (U n ‚óã U n) ‚äÜ U m) ‚àß (ùì§ X).HasAntitoneBasis U := by\n    rcases UniformSpace.has_seq_basis X with ‚ü®V, hB, hV_symm‚ü©\n    rcases hB.subbasis_with_rel fun m =>\n        hB.tendsto_smallSets.eventually\n          (eventually_uniformity_iterate_comp_subset (hB.mem m) 2) with\n      ‚ü®œÜ, -, hœÜ_comp, hœÜB‚ü©\n    exact ‚ü®V ‚àò œÜ, fun n => hV_symm _, hœÜ_comp, hœÜB‚ü©\n  set d : X ‚Üí X ‚Üí ‚Ñù‚â•0 := fun x y => if h : ‚àÉ n, (x, y) ‚àâ U n then (1 / 2) ^ Nat.find h else 0\n  have hd‚ÇÄ : ‚àÄ {x y}, d x y = 0 ‚Üî Inseparable x y := by\n    intro x y\n    refine Iff.trans ?_ hB.inseparable_iff_uniformity.symm\n    simp only [d, true_imp_iff]\n    split_ifs with h\n    ¬∑ rw [‚Üê not_forall] at h\n      simp [h, pow_eq_zero_iff']\n    ¬∑ simpa only [not_exists, Classical.not_not, eq_self_iff_true, true_iff] using h\n  have hd_symm : ‚àÄ x y, d x y = d y x := by\n    intro x y\n    simp only [d, @SymmetricRel.mk_mem_comm _ _ (hU_symm _) x y]\n  have hr : (1 / 2 : ‚Ñù‚â•0) ‚àà Ioo (0 : ‚Ñù‚â•0) 1 := ‚ü®half_pos one_pos, NNReal.half_lt_self one_ne_zero‚ü©\n  letI I := PseudoMetricSpace.ofPreNNDist d (fun x => hd‚ÇÄ.2 rfl) hd_symm\n  have hdist_le : ‚àÄ x y, dist x y ‚â§ d x y := PseudoMetricSpace.dist_ofPreNNDist_le _ _ _\n  have hle_d : ‚àÄ {x y : X} {n : ‚Ñï}, (1 / 2) ^ n ‚â§ d x y ‚Üî (x, y) ‚àâ U n := by\n    intro x y n\n    dsimp only [d]\n    split_ifs with h\n    ¬∑ rw [(pow_right_strictAnti‚ÇÄ hr.1 hr.2).le_iff_le, Nat.find_le_iff]\n      exact ‚ü®fun ‚ü®m, hmn, hm‚ü© hn => hm (hB.antitone hmn hn), fun h => ‚ü®n, le_rfl, h‚ü©‚ü©\n    ¬∑ push_neg at h\n      simp only [h, not_true, (pow_pos hr.1 _).not_le]\n  have hd_le : ‚àÄ x y, ‚Üë(d x y) ‚â§ 2 * dist x y := by\n    refine PseudoMetricSpace.le_two_mul_dist_ofPreNNDist _ _ _ fun x‚ÇÅ x‚ÇÇ x‚ÇÉ x‚ÇÑ => ?_\n    by_cases H : ‚àÉ n, (x‚ÇÅ, x‚ÇÑ) ‚àâ U n\n    ¬∑ refine (dif_pos H).trans_le ?_\n      rw [‚Üê div_le_iff‚ÇÄ' zero_lt_two, ‚Üê mul_one_div (_ ^ _), ‚Üê pow_succ]\n      simp only [le_max_iff, hle_d, ‚Üê not_and_or]\n      rintro ‚ü®h‚ÇÅ‚ÇÇ, h‚ÇÇ‚ÇÉ, h‚ÇÉ‚ÇÑ‚ü©\n      refine Nat.find_spec H (hU_comp (lt_add_one <| Nat.find H) ?_)\n      exact ‚ü®x‚ÇÇ, h‚ÇÅ‚ÇÇ, x‚ÇÉ, h‚ÇÇ‚ÇÉ, h‚ÇÉ‚ÇÑ‚ü©\n    ¬∑ exact (dif_neg H).trans_le (zero_le _)\n  -- Porting note: without the next line, `uniformity_basis_dist_pow` ends up introducing some\n  -- `Subtype.val` applications instead of `NNReal.toReal`.\n  rw [mem_Ioo, ‚Üê NNReal.coe_lt_coe, ‚Üê NNReal.coe_lt_coe] at hr\n  refine ‚ü®I, UniformSpace.ext <| (uniformity_basis_dist_pow hr.1 hr.2).ext hB.toHasBasis ?_ ?_‚ü©\n  ¬∑ refine fun n hn => ‚ü®n, hn, fun x hx => (hdist_le _ _).trans_lt ?_‚ü©\n    rwa [‚Üê NNReal.coe_pow, NNReal.coe_lt_coe, ‚Üê not_le, hle_d, Classical.not_not]\n  ¬∑ refine fun n _ => ‚ü®n + 1, trivial, fun x hx => ?_‚ü©\n    rw [mem_setOf_eq] at hx\n    contrapose! hx\n    refine le_trans ?_ ((div_le_iff‚ÇÄ' zero_lt_two).2 (hd_le x.1 x.2))\n    rwa [‚Üê NNReal.coe_two, ‚Üê NNReal.coe_div, ‚Üê NNReal.coe_pow, NNReal.coe_le_coe, pow_succ,\n      mul_one_div, div_le_iff‚ÇÄ zero_lt_two, div_mul_cancel‚ÇÄ _ two_ne_zero, hle_d]\n\n"}
{"name":"UniformSpace.pseudoMetrizableSpace","module":"Mathlib.Topology.Metrizable.Uniformity","initialProofState":"X : Type u_1\ninst‚úù¬π : UniformSpace X\ninst‚úù : (uniformity X).IsCountablyGenerated\n‚ä¢ TopologicalSpace.PseudoMetrizableSpace X","decl":"/-- A uniform space with countably generated `ùì§ X` is pseudo metrizable. -/\ninstance (priority := 100) UniformSpace.pseudoMetrizableSpace [UniformSpace X]\n    [IsCountablyGenerated (ùì§ X)] : TopologicalSpace.PseudoMetrizableSpace X := by\n  letI := UniformSpace.pseudoMetricSpace X\n  infer_instance\n\n"}
{"name":"UniformSpace.metrizableSpace","module":"Mathlib.Topology.Metrizable.Uniformity","initialProofState":"X : Type u_1\ninst‚úù¬≤ : UniformSpace X\ninst‚úù¬π : (uniformity X).IsCountablyGenerated\ninst‚úù : T0Space X\n‚ä¢ TopologicalSpace.MetrizableSpace X","decl":"/-- A T‚ÇÄ uniform space with countably generated `ùì§ X` is metrizable. This is not an instance to\navoid loops. -/\ntheorem UniformSpace.metrizableSpace [UniformSpace X] [IsCountablyGenerated (ùì§ X)] [T0Space X] :\n    TopologicalSpace.MetrizableSpace X := by\n  letI := UniformSpace.metricSpace X\n  infer_instance\n\n"}
{"name":"TotallyBounded.isSeparable","module":"Mathlib.Topology.Metrizable.Uniformity","initialProofState":"X : Type u_1\ninst‚úù : UniformSpace X\ni : (uniformity X).IsCountablyGenerated\ns : Set X\nh : TotallyBounded s\n‚ä¢ TopologicalSpace.IsSeparable s","decl":"/-- A totally bounded set is separable in countably generated uniform spaces. This can be obtained\nfrom the more general `EMetric.subset_countable_closure_of_almost_dense_set`.-/\nlemma TotallyBounded.isSeparable [UniformSpace X] [i : IsCountablyGenerated (ùì§ X)]\n    {s : Set X} (h : TotallyBounded s) : TopologicalSpace.IsSeparable s := by\n  letI := (UniformSpace.pseudoMetricSpace (X := X)).toPseudoEMetricSpace\n  rw [EMetric.totallyBounded_iff] at h\n  have h' : ‚àÄ Œµ > 0, ‚àÉ t, Set.Countable t ‚àß s ‚äÜ ‚ãÉ y ‚àà t, EMetric.closedBall y Œµ := by\n    intro Œµ hŒµ\n    obtain ‚ü®t, ht‚ü© := h Œµ hŒµ\n    refine ‚ü®t, ht.1.countable, subset_trans ht.2 ?_‚ü©\n    gcongr\n    exact EMetric.ball_subset_closedBall\n  obtain ‚ü®t, _, htc, hts‚ü© := EMetric.subset_countable_closure_of_almost_dense_set s h'\n  exact ‚ü®t, htc, hts‚ü©\n\n"}
{"name":"DiscreteTopology.metrizableSpace","module":"Mathlib.Topology.Metrizable.Uniformity","initialProofState":"Œ± : Type u_2\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : DiscreteTopology Œ±\n‚ä¢ TopologicalSpace.MetrizableSpace Œ±","decl":"open TopologicalSpace in\ninstance (priority := 100) DiscreteTopology.metrizableSpace\n    {Œ±} [TopologicalSpace Œ±] [DiscreteTopology Œ±] :\n    MetrizableSpace Œ± := by\n  obtain rfl := DiscreteTopology.eq_bot (Œ± := Œ±)\n  exact @UniformSpace.metrizableSpace Œ± ‚ä• (isCountablyGenerated_principal _) _\n"}
