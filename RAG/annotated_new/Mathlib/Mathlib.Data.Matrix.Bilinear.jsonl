{"name":"mulLeftLinearMap_apply","module":"Mathlib.Data.Matrix.Bilinear","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nR : Type u_5\nA : Type u_6\ninst✝⁴ : Fintype m\ninst✝³ : Semiring R\ninst✝² : NonUnitalNonAssocSemiring A\ninst✝¹ : Module R A\ninst✝ : SMulCommClass R A A\nX : Matrix l m A\nx✝ : Matrix m n A\n⊢ Eq ((mulLeftLinearMap n R X) x✝) (HMul.hMul X x✝)","decl":"/-- A version of `LinearMap.mulLeft` for matrix multiplication. -/\n@[simps]\ndef mulLeftLinearMap (X : Matrix l m A) :\n    Matrix m n A →ₗ[R] Matrix l n A where\n  toFun := (X * ·)\n  map_smul' := Matrix.mul_smul _\n  map_add' := Matrix.mul_add _\n\n"}
{"name":"mulLeftLinearMap_eq_mulLeft","module":"Mathlib.Data.Matrix.Bilinear","initialProofState":"m : Type u_2\nR : Type u_5\nA : Type u_6\ninst✝⁴ : Fintype m\ninst✝³ : Semiring R\ninst✝² : NonUnitalNonAssocSemiring A\ninst✝¹ : Module R A\ninst✝ : SMulCommClass R A A\n⊢ Eq (mulLeftLinearMap m R) (LinearMap.mulLeft R)","decl":"/-- On square matrices, `Matrix.mulLeftLinearMap` and `LinearMap.mulLeft` coincide. -/\ntheorem mulLeftLinearMap_eq_mulLeft :\n  mulLeftLinearMap m R = LinearMap.mulLeft R (A := Matrix m m A) := rfl\n\n"}
{"name":"mulLeftLinearMap_zero_eq_zero","module":"Mathlib.Data.Matrix.Bilinear","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nR : Type u_5\nA : Type u_6\ninst✝⁴ : Fintype m\ninst✝³ : Semiring R\ninst✝² : NonUnitalNonAssocSemiring A\ninst✝¹ : Module R A\ninst✝ : SMulCommClass R A A\n⊢ Eq (mulLeftLinearMap n R 0) 0","decl":"/-- A version of `LinearMap.mulLeft_zero_eq_zero` for matrix multiplication. -/\n@[simp]\ntheorem mulLeftLinearMap_zero_eq_zero :\n  mulLeftLinearMap n R (0 : Matrix l m A) = 0 := LinearMap.ext fun _ => Matrix.zero_mul _\n\n"}
{"name":"mulRightLinearMap_apply","module":"Mathlib.Data.Matrix.Bilinear","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nR : Type u_5\nA : Type u_6\ninst✝⁴ : Fintype m\ninst✝³ : Semiring R\ninst✝² : NonUnitalNonAssocSemiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\nY : Matrix m n A\nx✝ : Matrix l m A\n⊢ Eq ((mulRightLinearMap l R Y) x✝) (HMul.hMul x✝ Y)","decl":"/-- A version of `LinearMap.mulRight` for matrix multiplication. -/\n@[simps]\ndef mulRightLinearMap (Y : Matrix m n A) :\n    Matrix l m A →ₗ[R] Matrix l n A where\n  toFun := (· * Y)\n  map_smul' _ _ := Matrix.smul_mul _ _ _\n  map_add' _ _ := Matrix.add_mul _ _ _\n\n"}
{"name":"mulRightLinearMap_eq_mulRight","module":"Mathlib.Data.Matrix.Bilinear","initialProofState":"m : Type u_2\nR : Type u_5\nA : Type u_6\ninst✝⁴ : Fintype m\ninst✝³ : Semiring R\ninst✝² : NonUnitalNonAssocSemiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\n⊢ Eq (mulRightLinearMap m R) (LinearMap.mulRight R)","decl":"/-- On square matrices, `Matrix.mulRightLinearMap` and `LinearMap.mulRight` coincide. -/\ntheorem mulRightLinearMap_eq_mulRight :\n  mulRightLinearMap m R = LinearMap.mulRight R (A := Matrix m m A) := rfl\n\n"}
{"name":"mulRightLinearMap_zero_eq_zero","module":"Mathlib.Data.Matrix.Bilinear","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nR : Type u_5\nA : Type u_6\ninst✝⁴ : Fintype m\ninst✝³ : Semiring R\ninst✝² : NonUnitalNonAssocSemiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\n⊢ Eq (mulRightLinearMap l R 0) 0","decl":"/-- A version of `LinearMap.mulLeft_zero_eq_zero` for matrix multiplication. -/\n@[simp]\ntheorem mulRightLinearMap_zero_eq_zero :\n  mulRightLinearMap l R (0 : Matrix m n A) = 0 := LinearMap.ext fun _ => Matrix.mul_zero _\n\n"}
{"name":"mulLinearMap_apply_apply","module":"Mathlib.Data.Matrix.Bilinear","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nR : Type u_5\nA : Type u_6\ninst✝⁵ : Fintype m\ninst✝⁴ : CommSemiring R\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Module R A\ninst✝¹ : SMulCommClass R A A\ninst✝ : IsScalarTower R A A\nX : Matrix l m A\nx✝ : Matrix m n A\n⊢ Eq (((mulLinearMap R) X) x✝) (HMul.hMul X x✝)","decl":"/-- A version of `LinearMap.mul` for matrix multiplication. -/\n@[simps!]\ndef mulLinearMap : Matrix l m A →ₗ[R] Matrix m n A →ₗ[R] Matrix l n A where\n  toFun := mulLeftLinearMap n R\n  map_add' _ _ := LinearMap.ext fun _ => Matrix.add_mul _ _ _\n  map_smul' _ _ := LinearMap.ext fun _ => Matrix.smul_mul _ _ _\n\n"}
{"name":"mulLinearMap_eq_mul","module":"Mathlib.Data.Matrix.Bilinear","initialProofState":"m : Type u_2\nR : Type u_5\nA : Type u_6\ninst✝⁵ : Fintype m\ninst✝⁴ : CommSemiring R\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Module R A\ninst✝¹ : SMulCommClass R A A\ninst✝ : IsScalarTower R A A\n⊢ Eq (mulLinearMap R) (LinearMap.mul R (Matrix m m A))","decl":"/-- On square matrices, `Matrix.mulLinearMap` and `LinearMap.mul` coincide. -/\ntheorem mulLinearMap_eq_mul :\n  mulLinearMap R = LinearMap.mul R (A := Matrix m m A) := rfl\n\n"}
{"name":"mulLeftLinearMap_mul","module":"Mathlib.Data.Matrix.Bilinear","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nR : Type u_5\nA : Type u_6\ninst✝⁵ : Fintype m\ninst✝⁴ : Fintype n\ninst✝³ : Semiring R\ninst✝² : NonUnitalSemiring A\ninst✝¹ : Module R A\ninst✝ : SMulCommClass R A A\na : Matrix l m A\nb : Matrix m n A\n⊢ Eq (mulLeftLinearMap o R (HMul.hMul a b)) ((mulLeftLinearMap o R a).comp (mulLeftLinearMap o R b))","decl":"/-- A version of `LinearMap.mulLeft_mul` for matrix multiplication. -/\n@[simp]\ntheorem mulLeftLinearMap_mul [SMulCommClass R A A] (a : Matrix l m A) (b : Matrix m n A) :\n    mulLeftLinearMap o R (a * b) = (mulLeftLinearMap o R a).comp (mulLeftLinearMap o R b) := by\n  ext\n  simp only [mulLeftLinearMap_apply, LinearMap.comp_apply, Matrix.mul_assoc]\n\n"}
{"name":"mulRightLinearMap_mul","module":"Mathlib.Data.Matrix.Bilinear","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nR : Type u_5\nA : Type u_6\ninst✝⁵ : Fintype m\ninst✝⁴ : Fintype n\ninst✝³ : Semiring R\ninst✝² : NonUnitalSemiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\na : Matrix m n A\nb : Matrix n o A\n⊢ Eq (mulRightLinearMap l R (HMul.hMul a b)) ((mulRightLinearMap l R b).comp (mulRightLinearMap l R a))","decl":"/-- A version of `LinearMap.mulRight_mul` for matrix multiplication. -/\n@[simp]\ntheorem mulRightLinearMap_mul [IsScalarTower R A A] (a : Matrix m n A) (b : Matrix n o A) :\n    mulRightLinearMap l R (a * b) = (mulRightLinearMap l R b).comp (mulRightLinearMap l R a) := by\n  ext\n  simp only [mulRightLinearMap_apply, LinearMap.comp_apply, Matrix.mul_assoc]\n\n"}
{"name":"commute_mulLeftLinearMap_mulRightLinearMap","module":"Mathlib.Data.Matrix.Bilinear","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nR : Type u_5\nA : Type u_6\ninst✝⁶ : Fintype m\ninst✝⁵ : Fintype n\ninst✝⁴ : CommSemiring R\ninst✝³ : NonUnitalSemiring A\ninst✝² : Module R A\ninst✝¹ : SMulCommClass R A A\ninst✝ : IsScalarTower R A A\na : Matrix l m A\nb : Matrix n o A\n⊢ Eq ((mulLeftLinearMap o R a).comp (mulRightLinearMap m R b)) ((mulRightLinearMap l R b).comp (mulLeftLinearMap n R a))","decl":"/-- A version of `LinearMap.commute_mulLeft_right` for matrix multiplication. -/\ntheorem commute_mulLeftLinearMap_mulRightLinearMap (a : Matrix l m A) (b : Matrix n o A) :\n    mulLeftLinearMap o R a ∘ₗ mulRightLinearMap m R b =\n      mulRightLinearMap l R b ∘ₗ mulLeftLinearMap n R a := by\n  ext c : 1\n  exact (Matrix.mul_assoc a c b).symm\n\n"}
{"name":"mulLeftLinearMap_one","module":"Mathlib.Data.Matrix.Bilinear","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\nA : Type u_6\ninst✝⁵ : Fintype m\ninst✝⁴ : DecidableEq m\ninst✝³ : Semiring R\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : SMulCommClass R A A\n⊢ Eq (mulLeftLinearMap n R 1) LinearMap.id","decl":"/-- A version of `LinearMap.mulLeft_one` for matrix multiplication. -/\n@[simp]\ntheorem mulLeftLinearMap_one : mulLeftLinearMap n R (1 : Matrix m m A) = LinearMap.id :=\n  LinearMap.ext fun _ => Matrix.one_mul _\n\n"}
{"name":"mulLeftLinearMap_eq_zero_iff","module":"Mathlib.Data.Matrix.Bilinear","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nR : Type u_5\nA : Type u_6\ninst✝⁶ : Fintype m\ninst✝⁵ : DecidableEq m\ninst✝⁴ : Semiring R\ninst✝³ : Semiring A\ninst✝² : Module R A\ninst✝¹ : SMulCommClass R A A\ninst✝ : Nonempty n\na : Matrix l m A\n⊢ Iff (Eq (mulLeftLinearMap n R a) 0) (Eq a 0)","decl":"/-- A version of `LinearMap.mulLeft_eq_zero_iff` for matrix multiplication. -/\n@[simp]\ntheorem mulLeftLinearMap_eq_zero_iff [Nonempty n] (a : Matrix l m A) :\n    mulLeftLinearMap n R a = 0 ↔ a = 0 := by\n  constructor <;> intro h\n  · inhabit n\n    ext i j\n    classical\n    replace h := DFunLike.congr_fun h (Matrix.stdBasisMatrix j (default : n) 1)\n    simpa using Matrix.ext_iff.2 h i default\n  · rw [h]\n    exact mulLeftLinearMap_zero_eq_zero _ _\n\n"}
{"name":"pow_mulLeftLinearMap","module":"Mathlib.Data.Matrix.Bilinear","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_5\nA : Type u_6\ninst✝⁵ : Fintype m\ninst✝⁴ : DecidableEq m\ninst✝³ : Semiring R\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : SMulCommClass R A A\na : Matrix m m A\nk : Nat\n⊢ Eq (HPow.hPow (mulLeftLinearMap n R a) k) (mulLeftLinearMap n R (HPow.hPow a k))","decl":"/-- A version of `LinearMap.pow_mulLeft` for matrix multiplication. -/\n@[simp]\ntheorem pow_mulLeftLinearMap (a : Matrix m m A) (k : ℕ) :\n    mulLeftLinearMap n R a ^ k = mulLeftLinearMap n R (a ^ k) :=\n  match k with\n  | 0 => by rw [pow_zero, pow_zero, mulLeftLinearMap_one, LinearMap.one_eq_id]\n  | (n + 1) => by\n    rw [pow_succ, pow_succ, mulLeftLinearMap_mul, LinearMap.mul_eq_comp, pow_mulLeftLinearMap]\n\n"}
{"name":"mulRightLinearMap_one","module":"Mathlib.Data.Matrix.Bilinear","initialProofState":"l : Type u_1\nm : Type u_2\nR : Type u_5\nA : Type u_6\ninst✝⁵ : Fintype m\ninst✝⁴ : DecidableEq m\ninst✝³ : Semiring R\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\n⊢ Eq (mulRightLinearMap l R 1) LinearMap.id","decl":"/-- A version of `LinearMap.mulRight_one` for matrix multiplication. -/\n@[simp]\ntheorem mulRightLinearMap_one : mulRightLinearMap l R (1 : Matrix m m A) = LinearMap.id :=\n  LinearMap.ext fun _ => Matrix.mul_one _\n\n"}
{"name":"mulRightLinearMap_eq_zero_iff","module":"Mathlib.Data.Matrix.Bilinear","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\nR : Type u_5\nA : Type u_6\ninst✝⁶ : Fintype m\ninst✝⁵ : DecidableEq m\ninst✝⁴ : Semiring R\ninst✝³ : Semiring A\ninst✝² : Module R A\ninst✝¹ : IsScalarTower R A A\na : Matrix m n A\ninst✝ : Nonempty l\n⊢ Iff (Eq (mulRightLinearMap l R a) 0) (Eq a 0)","decl":"/-- A version of `LinearMap.mulRight_eq_zero_iff` for matrix multiplication. -/\n@[simp]\ntheorem mulRightLinearMap_eq_zero_iff (a : Matrix m n A) [Nonempty l] :\n    mulRightLinearMap l R a = 0 ↔ a = 0 := by\n  constructor <;> intro h\n  · inhabit l\n    ext i j\n    classical\n    replace h := DFunLike.congr_fun h (Matrix.stdBasisMatrix (default : l) i 1)\n    simpa using Matrix.ext_iff.2 h default j\n  · rw [h]\n    exact mulRightLinearMap_zero_eq_zero _ _\n\n"}
{"name":"pow_mulRightLinearMap","module":"Mathlib.Data.Matrix.Bilinear","initialProofState":"l : Type u_1\nm : Type u_2\nR : Type u_5\nA : Type u_6\ninst✝⁵ : Fintype m\ninst✝⁴ : DecidableEq m\ninst✝³ : Semiring R\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\na : Matrix m m A\nk : Nat\n⊢ Eq (HPow.hPow (mulRightLinearMap l R a) k) (mulRightLinearMap l R (HPow.hPow a k))","decl":"/-- A version of `LinearMap.pow_mulRight` for matrix multiplication. -/\n@[simp]\ntheorem pow_mulRightLinearMap (a : Matrix m m A) (k : ℕ) :\n    mulRightLinearMap l R a ^ k = mulRightLinearMap l R (a ^ k) :=\n  match k with\n  | 0 => by rw [pow_zero, pow_zero, mulRightLinearMap_one, LinearMap.one_eq_id]\n  | (n + 1) => by\n    rw [pow_succ, pow_succ', mulRightLinearMap_mul, LinearMap.mul_eq_comp, pow_mulRightLinearMap]\n\n"}
