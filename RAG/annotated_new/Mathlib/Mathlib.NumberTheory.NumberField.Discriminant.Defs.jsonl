{"name":"NumberField.coe_discr","module":"Mathlib.NumberTheory.NumberField.Discriminant.Defs","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ Eq (↑(NumberField.discr K)) (Algebra.discr Rat ⇑(NumberField.integralBasis K))","decl":"theorem coe_discr : (discr K : ℚ) = Algebra.discr ℚ (integralBasis K) :=\n  (Algebra.discr_localizationLocalization ℤ _ K (RingOfIntegers.basis K)).symm\n\n"}
{"name":"NumberField.discr_ne_zero","module":"Mathlib.NumberTheory.NumberField.Discriminant.Defs","initialProofState":"K : Type u_1\ninst✝¹ : Field K\ninst✝ : NumberField K\n⊢ Ne (NumberField.discr K) 0","decl":"theorem discr_ne_zero : discr K ≠ 0 := by\n  rw [← (Int.cast_injective (α := ℚ)).ne_iff, coe_discr]\n  exact Algebra.discr_not_zero_of_basis ℚ (integralBasis K)\n\n"}
{"name":"NumberField.discr_eq_discr","module":"Mathlib.NumberTheory.NumberField.Discriminant.Defs","initialProofState":"K : Type u_1\ninst✝³ : Field K\ninst✝² : NumberField K\nι : Type u_2\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nb : Basis ι Int (NumberField.RingOfIntegers K)\n⊢ Eq (Algebra.discr Int ⇑b) (NumberField.discr K)","decl":"theorem discr_eq_discr {ι : Type*} [Fintype ι] [DecidableEq ι] (b : Basis ι ℤ (𝓞 K)) :\n    Algebra.discr ℤ b = discr K := by\n  let b₀ := Basis.reindex (RingOfIntegers.basis K) (Basis.indexEquiv (RingOfIntegers.basis K) b)\n  rw [Algebra.discr_eq_discr (𝓞 K) b b₀, Basis.coe_reindex, Algebra.discr_reindex]\n\n"}
{"name":"NumberField.discr_eq_discr_of_algEquiv","module":"Mathlib.NumberTheory.NumberField.Discriminant.Defs","initialProofState":"K : Type u_1\ninst✝³ : Field K\ninst✝² : NumberField K\nL : Type u_2\ninst✝¹ : Field L\ninst✝ : NumberField L\nf : AlgEquiv Rat K L\n⊢ Eq (NumberField.discr K) (NumberField.discr L)","decl":"theorem discr_eq_discr_of_algEquiv {L : Type*} [Field L] [NumberField L] (f : K ≃ₐ[ℚ] L) :\n    discr K = discr L := by\n  let f₀ : 𝓞 K ≃ₗ[ℤ] 𝓞 L := (f.restrictScalars ℤ).mapIntegralClosure.toLinearEquiv\n  rw [← Rat.intCast_inj, coe_discr, Algebra.discr_eq_discr_of_algEquiv (integralBasis K) f,\n    ← discr_eq_discr L ((RingOfIntegers.basis K).map f₀)]\n  change _ = algebraMap ℤ ℚ _\n  rw [← Algebra.discr_localizationLocalization ℤ (nonZeroDivisors ℤ) L]\n  congr\n  ext\n  simp only [Function.comp_apply, integralBasis_apply, Basis.localizationLocalization_apply,\n    Basis.map_apply]\n  rfl\n\n"}
{"name":"Rat.numberField_discr","module":"Mathlib.NumberTheory.NumberField.Discriminant.Defs","initialProofState":"⊢ Eq (NumberField.discr Rat) 1","decl":"/-- The absolute discriminant of the number field `ℚ` is 1. -/\n@[simp]\ntheorem numberField_discr : discr ℚ = 1 := by\n  let b : Basis (Fin 1) ℤ (𝓞 ℚ) :=\n    Basis.map (Basis.singleton (Fin 1) ℤ) ringOfIntegersEquiv.toAddEquiv.toIntLinearEquiv.symm\n  calc NumberField.discr ℚ\n    _ = Algebra.discr ℤ b := by convert (discr_eq_discr ℚ b).symm\n    _ = Algebra.trace ℤ (𝓞 ℚ) (b default * b default) := by\n      rw [Algebra.discr_def, Matrix.det_unique, Algebra.traceMatrix_apply, Algebra.traceForm_apply]\n    _ = Algebra.trace ℤ (𝓞 ℚ) 1 := by\n      rw [Basis.map_apply, RingEquiv.toAddEquiv_eq_coe, AddEquiv.toIntLinearEquiv_symm,\n        AddEquiv.coe_toIntLinearEquiv, Basis.singleton_apply,\n        show (AddEquiv.symm ↑ringOfIntegersEquiv) (1 : ℤ) = ringOfIntegersEquiv.symm 1 by rfl,\n        map_one, mul_one]\n    _ = 1 := by rw [Algebra.trace_eq_matrix_trace b]; norm_num\n\n"}
{"name":"NumberField.discr_rat","module":"Mathlib.NumberTheory.NumberField.Discriminant.Defs","initialProofState":"⊢ Eq (NumberField.discr Rat) 1","decl":"alias _root_.NumberField.discr_rat := numberField_discr\n\n"}
{"name":"Algebra.discr_eq_discr_of_toMatrix_coeff_isIntegral","module":"Mathlib.NumberTheory.NumberField.Discriminant.Defs","initialProofState":"ι : Type u_2\nι' : Type u_3\nK : Type u_1\ninst✝⁵ : Field K\ninst✝⁴ : DecidableEq ι\ninst✝³ : DecidableEq ι'\ninst✝² : Fintype ι\ninst✝¹ : Fintype ι'\ninst✝ : NumberField K\nb : Basis ι Rat K\nb' : Basis ι' Rat K\nh : ∀ (i : ι) (j : ι'), IsIntegral Int (b.toMatrix (⇑b') i j)\nh' : ∀ (i : ι') (j : ι), IsIntegral Int (b'.toMatrix (⇑b) i j)\n⊢ Eq (Algebra.discr Rat ⇑b) (Algebra.discr Rat ⇑b')","decl":"/-- If `b` and `b'` are `ℚ`-bases of a number field `K` such that\n`∀ i j, IsIntegral ℤ (b.toMatrix b' i j)` and `∀ i j, IsIntegral ℤ (b'.toMatrix b i j)` then\n`discr ℚ b = discr ℚ b'`. -/\ntheorem Algebra.discr_eq_discr_of_toMatrix_coeff_isIntegral [NumberField K]\n    {b : Basis ι ℚ K} {b' : Basis ι' ℚ K} (h : ∀ i j, IsIntegral ℤ (b.toMatrix b' i j))\n    (h' : ∀ i j, IsIntegral ℤ (b'.toMatrix b i j)) : discr ℚ b = discr ℚ b' := by\n  replace h' : ∀ i j, IsIntegral ℤ (b'.toMatrix (b.reindex (b.indexEquiv b')) i j) := by\n    intro i j\n    convert h' i ((b.indexEquiv b').symm j)\n    simp [Basis.toMatrix_apply]\n  classical\n  rw [← (b.reindex (b.indexEquiv b')).toMatrix_map_vecMul b', discr_of_matrix_vecMul,\n    ← one_mul (discr ℚ b), Basis.coe_reindex, discr_reindex]\n  congr\n  have hint : IsIntegral ℤ ((b.reindex (b.indexEquiv b')).toMatrix b').det :=\n    IsIntegral.det fun i j => h _ _\n  obtain ⟨r, hr⟩ := IsIntegrallyClosed.isIntegral_iff.1 hint\n  have hunit : IsUnit r := by\n    have : IsIntegral ℤ (b'.toMatrix (b.reindex (b.indexEquiv b'))).det :=\n      IsIntegral.det fun i j => h' _ _\n    obtain ⟨r', hr'⟩ := IsIntegrallyClosed.isIntegral_iff.1 this\n    refine isUnit_iff_exists_inv.2 ⟨r', ?_⟩\n    suffices algebraMap ℤ ℚ (r * r') = 1 by\n      rw [← RingHom.map_one (algebraMap ℤ ℚ)] at this\n      exact (IsFractionRing.injective ℤ ℚ) this\n    rw [RingHom.map_mul, hr, hr', ← Matrix.det_mul,\n      Basis.toMatrix_mul_toMatrix_flip, Matrix.det_one]\n  rw [← RingHom.map_one (algebraMap ℤ ℚ), ← hr]\n  cases' Int.isUnit_iff.1 hunit with hp hm\n  · simp [hp]\n  · simp [hm]\n"}
