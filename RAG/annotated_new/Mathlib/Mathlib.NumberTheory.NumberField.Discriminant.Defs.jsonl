{"name":"NumberField.coe_discr","module":"Mathlib.NumberTheory.NumberField.Discriminant.Defs","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Eq (â†‘(NumberField.discr K)) (Algebra.discr Rat â‡‘(NumberField.integralBasis K))","decl":"theorem coe_discr : (discr K : â„š) = Algebra.discr â„š (integralBasis K) :=\n  (Algebra.discr_localizationLocalization â„¤ _ K (RingOfIntegers.basis K)).symm\n\n"}
{"name":"NumberField.discr_ne_zero","module":"Mathlib.NumberTheory.NumberField.Discriminant.Defs","initialProofState":"K : Type u_1\ninstâœÂ¹ : Field K\ninstâœ : NumberField K\nâŠ¢ Ne (NumberField.discr K) 0","decl":"theorem discr_ne_zero : discr K â‰  0 := by\n  rw [â† (Int.cast_injective (Î± := â„š)).ne_iff, coe_discr]\n  exact Algebra.discr_not_zero_of_basis â„š (integralBasis K)\n\n"}
{"name":"NumberField.discr_eq_discr","module":"Mathlib.NumberTheory.NumberField.Discriminant.Defs","initialProofState":"K : Type u_1\ninstâœÂ³ : Field K\ninstâœÂ² : NumberField K\nÎ¹ : Type u_2\ninstâœÂ¹ : Fintype Î¹\ninstâœ : DecidableEq Î¹\nb : Basis Î¹ Int (NumberField.RingOfIntegers K)\nâŠ¢ Eq (Algebra.discr Int â‡‘b) (NumberField.discr K)","decl":"theorem discr_eq_discr {Î¹ : Type*} [Fintype Î¹] [DecidableEq Î¹] (b : Basis Î¹ â„¤ (ğ“ K)) :\n    Algebra.discr â„¤ b = discr K := by\n  let bâ‚€ := Basis.reindex (RingOfIntegers.basis K) (Basis.indexEquiv (RingOfIntegers.basis K) b)\n  rw [Algebra.discr_eq_discr (ğ“ K) b bâ‚€, Basis.coe_reindex, Algebra.discr_reindex]\n\n"}
{"name":"NumberField.discr_eq_discr_of_algEquiv","module":"Mathlib.NumberTheory.NumberField.Discriminant.Defs","initialProofState":"K : Type u_1\ninstâœÂ³ : Field K\ninstâœÂ² : NumberField K\nL : Type u_2\ninstâœÂ¹ : Field L\ninstâœ : NumberField L\nf : AlgEquiv Rat K L\nâŠ¢ Eq (NumberField.discr K) (NumberField.discr L)","decl":"theorem discr_eq_discr_of_algEquiv {L : Type*} [Field L] [NumberField L] (f : K â‰ƒâ‚[â„š] L) :\n    discr K = discr L := by\n  let fâ‚€ : ğ“ K â‰ƒâ‚—[â„¤] ğ“ L := (f.restrictScalars â„¤).mapIntegralClosure.toLinearEquiv\n  rw [â† Rat.intCast_inj, coe_discr, Algebra.discr_eq_discr_of_algEquiv (integralBasis K) f,\n    â† discr_eq_discr L ((RingOfIntegers.basis K).map fâ‚€)]\n  change _ = algebraMap â„¤ â„š _\n  rw [â† Algebra.discr_localizationLocalization â„¤ (nonZeroDivisors â„¤) L]\n  congr\n  ext\n  simp only [Function.comp_apply, integralBasis_apply, Basis.localizationLocalization_apply,\n    Basis.map_apply]\n  rfl\n\n"}
{"name":"Rat.numberField_discr","module":"Mathlib.NumberTheory.NumberField.Discriminant.Defs","initialProofState":"âŠ¢ Eq (NumberField.discr Rat) 1","decl":"/-- The absolute discriminant of the number field `â„š` is 1. -/\n@[simp]\ntheorem numberField_discr : discr â„š = 1 := by\n  let b : Basis (Fin 1) â„¤ (ğ“ â„š) :=\n    Basis.map (Basis.singleton (Fin 1) â„¤) ringOfIntegersEquiv.toAddEquiv.toIntLinearEquiv.symm\n  calc NumberField.discr â„š\n    _ = Algebra.discr â„¤ b := by convert (discr_eq_discr â„š b).symm\n    _ = Algebra.trace â„¤ (ğ“ â„š) (b default * b default) := by\n      rw [Algebra.discr_def, Matrix.det_unique, Algebra.traceMatrix_apply, Algebra.traceForm_apply]\n    _ = Algebra.trace â„¤ (ğ“ â„š) 1 := by\n      rw [Basis.map_apply, RingEquiv.toAddEquiv_eq_coe, AddEquiv.toIntLinearEquiv_symm,\n        AddEquiv.coe_toIntLinearEquiv, Basis.singleton_apply,\n        show (AddEquiv.symm â†‘ringOfIntegersEquiv) (1 : â„¤) = ringOfIntegersEquiv.symm 1 by rfl,\n        map_one, mul_one]\n    _ = 1 := by rw [Algebra.trace_eq_matrix_trace b]; norm_num\n\n"}
{"name":"NumberField.discr_rat","module":"Mathlib.NumberTheory.NumberField.Discriminant.Defs","initialProofState":"âŠ¢ Eq (NumberField.discr Rat) 1","decl":"alias _root_.NumberField.discr_rat := numberField_discr\n\n"}
{"name":"Algebra.discr_eq_discr_of_toMatrix_coeff_isIntegral","module":"Mathlib.NumberTheory.NumberField.Discriminant.Defs","initialProofState":"Î¹ : Type u_2\nÎ¹' : Type u_3\nK : Type u_1\ninstâœâµ : Field K\ninstâœâ´ : DecidableEq Î¹\ninstâœÂ³ : DecidableEq Î¹'\ninstâœÂ² : Fintype Î¹\ninstâœÂ¹ : Fintype Î¹'\ninstâœ : NumberField K\nb : Basis Î¹ Rat K\nb' : Basis Î¹' Rat K\nh : âˆ€ (i : Î¹) (j : Î¹'), IsIntegral Int (b.toMatrix (â‡‘b') i j)\nh' : âˆ€ (i : Î¹') (j : Î¹), IsIntegral Int (b'.toMatrix (â‡‘b) i j)\nâŠ¢ Eq (Algebra.discr Rat â‡‘b) (Algebra.discr Rat â‡‘b')","decl":"/-- If `b` and `b'` are `â„š`-bases of a number field `K` such that\n`âˆ€ i j, IsIntegral â„¤ (b.toMatrix b' i j)` and `âˆ€ i j, IsIntegral â„¤ (b'.toMatrix b i j)` then\n`discr â„š b = discr â„š b'`. -/\ntheorem Algebra.discr_eq_discr_of_toMatrix_coeff_isIntegral [NumberField K]\n    {b : Basis Î¹ â„š K} {b' : Basis Î¹' â„š K} (h : âˆ€ i j, IsIntegral â„¤ (b.toMatrix b' i j))\n    (h' : âˆ€ i j, IsIntegral â„¤ (b'.toMatrix b i j)) : discr â„š b = discr â„š b' := by\n  replace h' : âˆ€ i j, IsIntegral â„¤ (b'.toMatrix (b.reindex (b.indexEquiv b')) i j) := by\n    intro i j\n    convert h' i ((b.indexEquiv b').symm j)\n    simp [Basis.toMatrix_apply]\n  classical\n  rw [â† (b.reindex (b.indexEquiv b')).toMatrix_map_vecMul b', discr_of_matrix_vecMul,\n    â† one_mul (discr â„š b), Basis.coe_reindex, discr_reindex]\n  congr\n  have hint : IsIntegral â„¤ ((b.reindex (b.indexEquiv b')).toMatrix b').det :=\n    IsIntegral.det fun i j => h _ _\n  obtain âŸ¨r, hrâŸ© := IsIntegrallyClosed.isIntegral_iff.1 hint\n  have hunit : IsUnit r := by\n    have : IsIntegral â„¤ (b'.toMatrix (b.reindex (b.indexEquiv b'))).det :=\n      IsIntegral.det fun i j => h' _ _\n    obtain âŸ¨r', hr'âŸ© := IsIntegrallyClosed.isIntegral_iff.1 this\n    refine isUnit_iff_exists_inv.2 âŸ¨r', ?_âŸ©\n    suffices algebraMap â„¤ â„š (r * r') = 1 by\n      rw [â† RingHom.map_one (algebraMap â„¤ â„š)] at this\n      exact (IsFractionRing.injective â„¤ â„š) this\n    rw [RingHom.map_mul, hr, hr', â† Matrix.det_mul,\n      Basis.toMatrix_mul_toMatrix_flip, Matrix.det_one]\n  rw [â† RingHom.map_one (algebraMap â„¤ â„š), â† hr]\n  cases' Int.isUnit_iff.1 hunit with hp hm\n  Â· simp [hp]\n  Â· simp [hm]\n"}
