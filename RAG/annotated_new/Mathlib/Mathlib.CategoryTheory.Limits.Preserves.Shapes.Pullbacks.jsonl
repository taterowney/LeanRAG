{"name":"CategoryTheory.Limits.preservesPullback_symmetry","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) G\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan g f) G","decl":"/-- If `F` preserves the pullback of `f, g`, it also preserves the pullback of `g, f`. -/\nlemma preservesPullback_symmetry : PreservesLimit (cospan g f) G where\n  preserves {c} hc := ⟨by\n    apply (IsLimit.postcomposeHomEquiv (diagramIsoCospan.{v₂} _) _).toFun\n    apply IsLimit.ofIsoLimit _ (PullbackCone.isoMk _).symm\n    apply PullbackCone.isLimitOfFlip\n    apply (isLimitMapConePullbackConeEquiv _ _).toFun\n    · refine @isLimitOfPreserves _ _ _ _ _ _ _ _ _ ?_ ?_\n      · apply PullbackCone.isLimitOfFlip\n        apply IsLimit.ofIsoLimit _ (PullbackCone.isoMk _)\n        exact (IsLimit.postcomposeHomEquiv (diagramIsoCospan.{v₁} _) _).invFun hc\n      · dsimp\n        infer_instance\n    · exact\n        (c.π.naturality WalkingCospan.Hom.inr).symm.trans\n          (c.π.naturality WalkingCospan.Hom.inl :)⟩\n\n"}
{"name":"CategoryTheory.Limits.hasPullback_of_preservesPullback","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) G\ninst✝ : CategoryTheory.Limits.HasPullback f g\n⊢ CategoryTheory.Limits.HasPullback (G.map f) (G.map g)","decl":"theorem hasPullback_of_preservesPullback [HasPullback f g] : HasPullback (G.map f) (G.map g) :=\n  ⟨⟨⟨_, isLimitPullbackConeMapOfIsLimit G _ (pullbackIsPullback _ _)⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.PreservesPullback.iso_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝² : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) G\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\n⊢ Eq (CategoryTheory.Limits.PreservesPullback.iso G f g).hom (CategoryTheory.Limits.pullbackComparison G f g)","decl":"@[simp]\ntheorem PreservesPullback.iso_hom : (PreservesPullback.iso G f g).hom = pullbackComparison G f g :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.PreservesPullback.iso_hom_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝² : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) G\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\nZ : D\nh : Quiver.Hom (G.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesPullback.iso G f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (G.map f) (G.map g)) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pullback.fst f g)) h)","decl":"@[reassoc]\ntheorem PreservesPullback.iso_hom_fst :\n    (PreservesPullback.iso G f g).hom ≫ pullback.fst _ _ = G.map (pullback.fst f g) := by\n  simp [PreservesPullback.iso]\n\n"}
{"name":"CategoryTheory.Limits.PreservesPullback.iso_hom_fst","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝² : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) G\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesPullback.iso G f g).hom (CategoryTheory.Limits.pullback.fst (G.map f) (G.map g))) (G.map (CategoryTheory.Limits.pullback.fst f g))","decl":"@[reassoc]\ntheorem PreservesPullback.iso_hom_fst :\n    (PreservesPullback.iso G f g).hom ≫ pullback.fst _ _ = G.map (pullback.fst f g) := by\n  simp [PreservesPullback.iso]\n\n"}
{"name":"CategoryTheory.Limits.PreservesPullback.iso_hom_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝² : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) G\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\nZ : D\nh : Quiver.Hom (G.obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesPullback.iso G f g).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (G.map f) (G.map g)) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pullback.snd f g)) h)","decl":"@[reassoc]\ntheorem PreservesPullback.iso_hom_snd :\n    (PreservesPullback.iso G f g).hom ≫ pullback.snd _ _ = G.map (pullback.snd f g) := by\n  simp [PreservesPullback.iso]\n\n"}
{"name":"CategoryTheory.Limits.PreservesPullback.iso_hom_snd","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝² : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) G\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesPullback.iso G f g).hom (CategoryTheory.Limits.pullback.snd (G.map f) (G.map g))) (G.map (CategoryTheory.Limits.pullback.snd f g))","decl":"@[reassoc]\ntheorem PreservesPullback.iso_hom_snd :\n    (PreservesPullback.iso G f g).hom ≫ pullback.snd _ _ = G.map (pullback.snd f g) := by\n  simp [PreservesPullback.iso]\n\n"}
{"name":"CategoryTheory.Limits.PreservesPullback.iso_inv_fst","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝² : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) G\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesPullback.iso G f g).inv (G.map (CategoryTheory.Limits.pullback.fst f g))) (CategoryTheory.Limits.pullback.fst (G.map f) (G.map g))","decl":"@[reassoc (attr := simp)]\ntheorem PreservesPullback.iso_inv_fst :\n    (PreservesPullback.iso G f g).inv ≫ G.map (pullback.fst f g) = pullback.fst _ _ := by\n  simp [PreservesPullback.iso, Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.PreservesPullback.iso_inv_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝² : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) G\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\nZ : D\nh : Quiver.Hom (G.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesPullback.iso G f g).inv (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pullback.fst f g)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (G.map f) (G.map g)) h)","decl":"@[reassoc (attr := simp)]\ntheorem PreservesPullback.iso_inv_fst :\n    (PreservesPullback.iso G f g).inv ≫ G.map (pullback.fst f g) = pullback.fst _ _ := by\n  simp [PreservesPullback.iso, Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.PreservesPullback.iso_inv_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ninst✝² : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) G\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\nZ : D\nh : Quiver.Hom (G.obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesPullback.iso G f g).inv (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pullback.snd f g)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (G.map f) (G.map g)) h)","decl":"@[reassoc (attr := simp)]\ntheorem PreservesPullback.iso_inv_snd :\n    (PreservesPullback.iso G f g).inv ≫ G.map (pullback.snd f g) = pullback.snd _ _ := by\n  simp [PreservesPullback.iso, Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.PreservesPullback.iso_inv_snd","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝² : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) G\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesPullback.iso G f g).inv (G.map (CategoryTheory.Limits.pullback.snd f g))) (CategoryTheory.Limits.pullback.snd (G.map f) (G.map g))","decl":"@[reassoc (attr := simp)]\ntheorem PreservesPullback.iso_inv_snd :\n    (PreservesPullback.iso G f g).inv ≫ G.map (pullback.snd f g) = pullback.snd _ _ := by\n  simp [PreservesPullback.iso, Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.preservesPushout_symmetry","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nW X Y : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) G\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span g f) G","decl":"/-- If `F` preserves the pushout of `f, g`, it also preserves the pushout of `g, f`. -/\nlemma preservesPushout_symmetry : PreservesColimit (span g f) G where\n  preserves {c} hc := ⟨by\n    apply (IsColimit.precomposeHomEquiv (diagramIsoSpan.{v₂} _).symm _).toFun\n    apply IsColimit.ofIsoColimit _ (PushoutCocone.isoMk _).symm\n    apply PushoutCocone.isColimitOfFlip\n    apply (isColimitMapCoconePushoutCoconeEquiv _ _).toFun\n    · refine @isColimitOfPreserves _ _ _ _ _ _ _ _ _ ?_ ?_ -- Porting note: more TC coddling\n      · exact PushoutCocone.flipIsColimit hc\n      · dsimp\n        infer_instance⟩\n\n"}
{"name":"CategoryTheory.Limits.hasPushout_of_preservesPushout","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nW X Y : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ninst✝¹ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) G\ninst✝ : CategoryTheory.Limits.HasPushout f g\n⊢ CategoryTheory.Limits.HasPushout (G.map f) (G.map g)","decl":"theorem hasPushout_of_preservesPushout [HasPushout f g] : HasPushout (G.map f) (G.map g) :=\n  ⟨⟨⟨_, isColimitPushoutCoconeMapOfIsColimit G _ (pushoutIsPushout _ _)⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.PreservesPushout.iso_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nW X Y : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ninst✝² : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) G\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\n⊢ Eq (CategoryTheory.Limits.PreservesPushout.iso G f g).hom (CategoryTheory.Limits.pushoutComparison G f g)","decl":"@[simp]\ntheorem PreservesPushout.iso_hom : (PreservesPushout.iso G f g).hom = pushoutComparison G f g :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.PreservesPushout.inl_iso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nW X Y : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ninst✝² : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) G\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\nZ : D\nh : Quiver.Hom (G.obj (CategoryTheory.Limits.pushout f g)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (G.map f) (G.map g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesPushout.iso G f g).hom h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pushout.inl f g)) h)","decl":"@[reassoc]\ntheorem PreservesPushout.inl_iso_hom :\n    pushout.inl _ _ ≫ (PreservesPushout.iso G f g).hom = G.map (pushout.inl _ _) := by\n  delta PreservesPushout.iso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.PreservesPushout.inl_iso_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nW X Y : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ninst✝² : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) G\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (G.map f) (G.map g)) (CategoryTheory.Limits.PreservesPushout.iso G f g).hom) (G.map (CategoryTheory.Limits.pushout.inl f g))","decl":"@[reassoc]\ntheorem PreservesPushout.inl_iso_hom :\n    pushout.inl _ _ ≫ (PreservesPushout.iso G f g).hom = G.map (pushout.inl _ _) := by\n  delta PreservesPushout.iso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.PreservesPushout.inr_iso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nW X Y : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ninst✝² : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) G\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\nZ : D\nh : Quiver.Hom (G.obj (CategoryTheory.Limits.pushout f g)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr (G.map f) (G.map g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesPushout.iso G f g).hom h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pushout.inr f g)) h)","decl":"@[reassoc]\ntheorem PreservesPushout.inr_iso_hom :\n    pushout.inr _ _ ≫ (PreservesPushout.iso G f g).hom = G.map (pushout.inr _ _) := by\n  delta PreservesPushout.iso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.PreservesPushout.inr_iso_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nW X Y : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ninst✝² : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) G\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr (G.map f) (G.map g)) (CategoryTheory.Limits.PreservesPushout.iso G f g).hom) (G.map (CategoryTheory.Limits.pushout.inr f g))","decl":"@[reassoc]\ntheorem PreservesPushout.inr_iso_hom :\n    pushout.inr _ _ ≫ (PreservesPushout.iso G f g).hom = G.map (pushout.inr _ _) := by\n  delta PreservesPushout.iso\n  simp\n\n"}
{"name":"CategoryTheory.Limits.PreservesPushout.inl_iso_inv","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nW X Y : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ninst✝² : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) G\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pushout.inl f g)) (CategoryTheory.Limits.PreservesPushout.iso G f g).inv) (CategoryTheory.Limits.pushout.inl (G.map f) (G.map g))","decl":"@[reassoc (attr := simp)]\ntheorem PreservesPushout.inl_iso_inv :\n    G.map (pushout.inl _ _) ≫ (PreservesPushout.iso G f g).inv = pushout.inl _ _ := by\n  simp [PreservesPushout.iso, Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.PreservesPushout.inl_iso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nW X Y : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ninst✝² : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) G\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.pushout (G.map f) (G.map g)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pushout.inl f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesPushout.iso G f g).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (G.map f) (G.map g)) h)","decl":"@[reassoc (attr := simp)]\ntheorem PreservesPushout.inl_iso_inv :\n    G.map (pushout.inl _ _) ≫ (PreservesPushout.iso G f g).inv = pushout.inl _ _ := by\n  simp [PreservesPushout.iso, Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.PreservesPushout.inr_iso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nW X Y : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ninst✝² : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) G\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.pushout (G.map f) (G.map g)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pushout.inr f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesPushout.iso G f g).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr (G.map f) (G.map g)) h)","decl":"@[reassoc (attr := simp)]\ntheorem PreservesPushout.inr_iso_inv :\n    G.map (pushout.inr _ _) ≫ (PreservesPushout.iso G f g).inv = pushout.inr _ _ := by\n  simp [PreservesPushout.iso, Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.PreservesPushout.inr_iso_inv","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nW X Y : C\nf : Quiver.Hom W X\ng : Quiver.Hom W Y\ninst✝² : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) G\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.pushout.inr f g)) (CategoryTheory.Limits.PreservesPushout.iso G f g).inv) (CategoryTheory.Limits.pushout.inr (G.map f) (G.map g))","decl":"@[reassoc (attr := simp)]\ntheorem PreservesPushout.inr_iso_inv :\n    G.map (pushout.inr _ _) ≫ (PreservesPushout.iso G f g).inv = pushout.inr _ _ := by\n  simp [PreservesPushout.iso, Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.PreservesPullback.of_iso_comparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\ni : CategoryTheory.IsIso (CategoryTheory.Limits.pullbackComparison G f g)\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.cospan f g) G","decl":"/-- If the pullback comparison map for `G` at `(f,g)` is an isomorphism, then `G` preserves the\npullback of `(f,g)`. -/\nlemma PreservesPullback.of_iso_comparison [i : IsIso (pullbackComparison G f g)] :\n    PreservesLimit (cospan f g) G := by\n  apply preservesLimit_of_preserves_limit_cone (pullbackIsPullback f g)\n  apply (isLimitMapConePullbackConeEquiv _ _).symm _\n  exact @IsLimit.ofPointIso _ _ _ _ _ _ _ (limit.isLimit (cospan (G.map f) (G.map g))) i\n\n"}
{"name":"CategoryTheory.Limits.instIsIsoPullbackComparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (G.map f) (G.map g)\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.pullbackComparison G f g)","decl":"instance : IsIso (pullbackComparison G f g) := by\n  rw [← PreservesPullback.iso_hom]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.PreservesPushout.of_iso_comparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\ni : CategoryTheory.IsIso (CategoryTheory.Limits.pushoutComparison G f g)\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.span f g) G","decl":"/-- If the pushout comparison map for `G` at `(f,g)` is an isomorphism, then `G` preserves the\npushout of `(f,g)`. -/\nlemma PreservesPushout.of_iso_comparison [i : IsIso (pushoutComparison G f g)] :\n    PreservesColimit (span f g) G := by\n  apply preservesColimit_of_preserves_colimit_cocone (pushoutIsPushout f g)\n  apply (isColimitMapCoconePushoutCoconeEquiv _ _).symm _\n  -- Porting note: apply no longer creates goals for instances\n  exact @IsColimit.ofPointIso _ _ _ _ _ _ _ (colimit.isColimit (span (G.map f) (G.map g))) i\n\n"}
{"name":"CategoryTheory.Limits.instIsIsoPushoutComparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Pullbacks","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (G.map f) (G.map g)\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.pushoutComparison G f g)","decl":"instance : IsIso (pushoutComparison G f g) := by\n  rw [← PreservesPushout.iso_hom]\n  infer_instance\n\n"}
