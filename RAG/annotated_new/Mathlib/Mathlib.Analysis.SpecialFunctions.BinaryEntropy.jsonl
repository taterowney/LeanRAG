{"name":"Real.binEntropy_zero","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"‚ä¢ Eq (Real.binEntropy 0) 0","decl":"@[simp] lemma binEntropy_zero : binEntropy 0 = 0 := by simp [binEntropy]\n"}
{"name":"Real.binEntropy_one","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"‚ä¢ Eq (Real.binEntropy 1) 0","decl":"@[simp] lemma binEntropy_one : binEntropy 1 = 0 := by simp [binEntropy]\n"}
{"name":"Real.binEntropy_two_inv","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"‚ä¢ Eq (Real.binEntropy (Inv.inv 2)) (Real.log 2)","decl":"@[simp] lemma binEntropy_two_inv : binEntropy 2‚Åª¬π = log 2 := by norm_num [binEntropy]; simp; ring\n\n"}
{"name":"Real.binEntropy_eq_negMulLog_add_negMulLog_one_sub","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"p : Real\n‚ä¢ Eq (Real.binEntropy p) (HAdd.hAdd p.negMulLog (HSub.hSub 1 p).negMulLog)","decl":"lemma binEntropy_eq_negMulLog_add_negMulLog_one_sub (p : ‚Ñù) :\n    binEntropy p = negMulLog p + negMulLog (1 - p) := by simp [binEntropy, negMulLog, ‚Üê neg_mul]\n\n"}
{"name":"Real.binEntropy_eq_negMulLog_add_negMulLog_one_sub'","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"‚ä¢ Eq Real.binEntropy fun p => HAdd.hAdd p.negMulLog (HSub.hSub 1 p).negMulLog","decl":"lemma binEntropy_eq_negMulLog_add_negMulLog_one_sub' :\n    binEntropy = fun p ‚Ü¶ negMulLog p + negMulLog (1 - p) :=\n  funext binEntropy_eq_negMulLog_add_negMulLog_one_sub\n\n"}
{"name":"Real.binEntropy_one_sub","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"p : Real\n‚ä¢ Eq (Real.binEntropy (HSub.hSub 1 p)) (Real.binEntropy p)","decl":"/-- `binEntropy` is symmetric about 1/2. -/\n@[simp] lemma binEntropy_one_sub (p : ‚Ñù) : binEntropy (1 - p) = binEntropy p := by\n  simp [binEntropy, add_comm]\n\n"}
{"name":"Real.binEntropy_two_inv_add","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"p : Real\n‚ä¢ Eq (Real.binEntropy (HAdd.hAdd (Inv.inv 2) p)) (Real.binEntropy (HSub.hSub (Inv.inv 2) p))","decl":"/-- `binEntropy` is symmetric about 1/2. -/\nlemma binEntropy_two_inv_add (p : ‚Ñù) : binEntropy (2‚Åª¬π + p) = binEntropy (2‚Åª¬π - p) := by\n  rw [‚Üê binEntropy_one_sub]; ring_nf\n\n"}
{"name":"Real.binEntropy_pos","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"p : Real\nhp‚ÇÄ : LT.lt 0 p\nhp‚ÇÅ : LT.lt p 1\n‚ä¢ LT.lt 0 (Real.binEntropy p)","decl":"lemma binEntropy_pos (hp‚ÇÄ : 0 < p) (hp‚ÇÅ : p < 1) : 0 < binEntropy p := by\n  unfold binEntropy\n  have : 0 < 1 - p := sub_pos.2 hp‚ÇÅ\n  have : 0 < log p‚Åª¬π := log_pos <| (one_lt_inv‚ÇÄ hp‚ÇÄ).2 hp‚ÇÅ\n  have : 0 < log (1 - p)‚Åª¬π := log_pos <| (one_lt_inv‚ÇÄ ‚Äπ_‚Ä∫).2 (sub_lt_self _ hp‚ÇÄ)\n  positivity\n\n"}
{"name":"Real.binEntropy_nonneg","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"p : Real\nhp‚ÇÄ : LE.le 0 p\nhp‚ÇÅ : LE.le p 1\n‚ä¢ LE.le 0 (Real.binEntropy p)","decl":"lemma binEntropy_nonneg (hp‚ÇÄ : 0 ‚â§ p) (hp‚ÇÅ : p ‚â§ 1) : 0 ‚â§ binEntropy p := by\n  obtain rfl | hp‚ÇÄ := hp‚ÇÄ.eq_or_lt\n  ¬∑ simp\n  obtain rfl | hp‚ÇÅ := hp‚ÇÅ.eq_or_lt\n  ¬∑ simp\n  exact (binEntropy_pos hp‚ÇÄ hp‚ÇÅ).le\n\n"}
{"name":"Real.binEntropy_neg_of_neg","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"p : Real\nhp : LT.lt p 0\n‚ä¢ LT.lt (Real.binEntropy p) 0","decl":"/-- Outside the usual range of `binEntropy`, it is negative. This is due to `log p = log |p|`. -/\nlemma binEntropy_neg_of_neg (hp : p < 0) : binEntropy p < 0 := by\n  rw [binEntropy, log_inv, log_inv]\n  suffices -p * log p < (1 - p) * log (1 - p) by linarith\n  by_cases hp' : p < -1\n  ¬∑ have : log p < log (1 - p) := by\n      rw [‚Üê log_neg_eq_log]\n      exact log_lt_log (Left.neg_pos_iff.mpr hp) (by linarith)\n    nlinarith [log_pos_of_lt_neg_one hp']\n  ¬∑ have : -p * log p ‚â§ 0 := by\n      wlog h : -1 < p\n      ¬∑ simp only [show p = -1 by linarith, log_neg_eq_log, log_one, le_refl, mul_zero]\n      ¬∑ nlinarith [log_neg_of_lt_zero hp h]\n    nlinarith [(log_pos (by linarith) : 0 < log (1 - p))]\n\n"}
{"name":"Real.binEntropy_nonpos_of_nonpos","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"p : Real\nhp : LE.le p 0\n‚ä¢ LE.le (Real.binEntropy p) 0","decl":"/-- Outside the usual range of `binEntropy`, it is negative. This is due to `log p = log |p|`. -/\nlemma binEntropy_nonpos_of_nonpos (hp : p ‚â§ 0) : binEntropy p ‚â§ 0 := by\n  obtain rfl | hp := hp.eq_or_lt\n  ¬∑ simp\n  ¬∑ exact (binEntropy_neg_of_neg hp).le\n\n"}
{"name":"Real.binEntropy_neg_of_one_lt","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"p : Real\nhp : LT.lt 1 p\n‚ä¢ LT.lt (Real.binEntropy p) 0","decl":"/-- Outside the usual range of `binEntropy`, it is negative. This is due to `log p = log |p|` -/\nlemma binEntropy_neg_of_one_lt (hp : 1 < p) : binEntropy p < 0 := by\n  rw [‚Üê binEntropy_one_sub]; exact binEntropy_neg_of_neg (sub_neg.2 hp)\n\n"}
{"name":"Real.binEntropy_nonpos_of_one_le","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"p : Real\nhp : LE.le 1 p\n‚ä¢ LE.le (Real.binEntropy p) 0","decl":"/-- Outside the usual range of `binEntropy`, it is negative. This is due to `log p = log |p|` -/\nlemma binEntropy_nonpos_of_one_le (hp : 1 ‚â§ p) : binEntropy p ‚â§ 0 := by\n  rw [‚Üê binEntropy_one_sub]; exact binEntropy_nonpos_of_nonpos (sub_nonpos.2 hp)\n\n"}
{"name":"Real.binEntropy_eq_zero","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"p : Real\n‚ä¢ Iff (Eq (Real.binEntropy p) 0) (Or (Eq p 0) (Eq p 1))","decl":"lemma binEntropy_eq_zero : binEntropy p = 0 ‚Üî p = 0 ‚à® p = 1 := by\n  refine ‚ü®fun h ‚Ü¶ ?_, by rintro (rfl | rfl) <;> simp‚ü©\n  contrapose! h\n  obtain hp‚ÇÄ | hp‚ÇÄ := h.1.lt_or_lt\n  ¬∑ exact (binEntropy_neg_of_neg hp‚ÇÄ).ne\n  obtain hp‚ÇÅ | hp‚ÇÅ := h.2.lt_or_lt.symm\n  ¬∑ exact (binEntropy_neg_of_one_lt hp‚ÇÅ).ne\n  ¬∑ exact (binEntropy_pos hp‚ÇÄ hp‚ÇÅ).ne'\n\n"}
{"name":"Real.binEntropy_lt_log_two","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"p : Real\n‚ä¢ Iff (LT.lt (Real.binEntropy p) (Real.log 2)) (Ne p (Inv.inv 2))","decl":"/-- For probability `p ‚â† 0.5`, `binEntropy p < log 2`. -/\nlemma binEntropy_lt_log_two : binEntropy p < log 2 ‚Üî p ‚â† 2‚Åª¬π := by\n  refine ‚ü®?_, fun h ‚Ü¶ ?_‚ü©\n  ¬∑ rintro h rfl\n    simp at h\n  wlog hp : p < 2‚Åª¬π\n  ¬∑ have hp : 1 - p < 2‚Åª¬π := by\n      rw [sub_lt_comm]; norm_num at *; linarith (config := { splitNe := true })\n    rw [‚Üê binEntropy_one_sub]\n    exact this hp.ne hp\n  obtain hp‚ÇÄ | hp‚ÇÄ := le_or_lt p 0\n  ¬∑ exact (binEntropy_nonpos_of_nonpos hp‚ÇÄ).trans_lt <| log_pos <| by norm_num\n  have hp‚ÇÅ : 0 < 1 - p := sub_pos.2 <| hp.trans <| by norm_num\n  calc\n  _ < log (p * p‚Åª¬π + (1 - p) * (1 - p)‚Åª¬π) :=\n    strictConcaveOn_log_Ioi.2 (inv_pos.2 hp‚ÇÄ) (inv_pos.2 hp‚ÇÅ)\n      (by simpa [eq_sub_iff_add_eq, ‚Üê two_mul, mul_comm, mul_eq_one_iff_eq_inv‚ÇÄ]) hp‚ÇÄ hp‚ÇÅ (by simp)\n  _ = log 2 := by rw [mul_inv_cancel‚ÇÄ, mul_inv_cancel‚ÇÄ, one_add_one_eq_two] <;> positivity\n\n"}
{"name":"Real.binEntropy_le_log_two","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"p : Real\n‚ä¢ LE.le (Real.binEntropy p) (Real.log 2)","decl":"lemma binEntropy_le_log_two : binEntropy p ‚â§ log 2 := by\n  obtain rfl | hp := eq_or_ne p 2‚Åª¬π\n  ¬∑ simp\n  ¬∑ exact (binEntropy_lt_log_two.2 hp).le\n\n"}
{"name":"Real.binEntropy_eq_log_two","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"p : Real\n‚ä¢ Iff (Eq (Real.binEntropy p) (Real.log 2)) (Eq p (Inv.inv 2))","decl":"lemma binEntropy_eq_log_two : binEntropy p = log 2 ‚Üî p = 2‚Åª¬π := by\n  rw [binEntropy_le_log_two.eq_iff_not_lt, binEntropy_lt_log_two, not_ne_iff]\n\n"}
{"name":"Real.binEntropy_continuous","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"‚ä¢ Continuous Real.binEntropy","decl":"/-- Binary entropy is continuous everywhere.\nThis is due to definition of `Real.log` for negative numbers. -/\n@[fun_prop] lemma binEntropy_continuous : Continuous binEntropy := by\n  rw [binEntropy_eq_negMulLog_add_negMulLog_one_sub']; fun_prop\n\n"}
{"name":"Real.differentiableAt_binEntropy","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"p : Real\nhp‚ÇÄ : Ne p 0\nhp‚ÇÅ : Ne p 1\n‚ä¢ DifferentiableAt Real Real.binEntropy p","decl":"@[fun_prop] lemma differentiableAt_binEntropy (hp‚ÇÄ : p ‚â† 0) (hp‚ÇÅ : p ‚â† 1) :\n    DifferentiableAt ‚Ñù binEntropy p := by\n  rw [ne_comm, ‚Üê sub_ne_zero] at hp‚ÇÅ\n  unfold binEntropy\n  simp only [log_inv, mul_neg]\n  fun_prop (disch := assumption)\n\n"}
{"name":"Real.differentiableAt_binEntropy_iff_ne_zero_one","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"p : Real\n‚ä¢ Iff (DifferentiableAt Real Real.binEntropy p) (And (Ne p 0) (Ne p 1))","decl":"set_option push_neg.use_distrib true in\nlemma differentiableAt_binEntropy_iff_ne_zero_one :\n    DifferentiableAt ‚Ñù binEntropy p ‚Üî p ‚â† 0 ‚àß p ‚â† 1 := by\n  refine ‚ü®fun h ‚Ü¶ ‚ü®?_, ?_‚ü©, fun h ‚Ü¶ differentiableAt_binEntropy h.1 h.2‚ü©\n    <;> rintro rfl <;> unfold binEntropy at h\n  ¬∑ rw [DifferentiableAt.add_iff_left] at h\n    ¬∑ simp [log_inv, mul_neg, ‚Üê neg_mul, ‚Üê negMulLog_def, differentiableAt_negMulLog_iff] at h\n    ¬∑ fun_prop (disch := simp)\n  ¬∑ rw [DifferentiableAt.add_iff_right, differentiableAt_iff_comp_const_sub (b := 1)] at h\n    ¬∑ simp [log_inv, mul_neg, ‚Üê neg_mul, ‚Üê negMulLog_def, differentiableAt_negMulLog_iff] at h\n    ¬∑ fun_prop (disch := simp)\n\n"}
{"name":"Real.deriv_binEntropy","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"p : Real\n‚ä¢ Eq (deriv Real.binEntropy p) (HSub.hSub (Real.log (HSub.hSub 1 p)) (Real.log p))","decl":"set_option push_neg.use_distrib true in\n/-- Binary entropy has derivative `log (1 - p) - log p`.\nIt's not differentiable at `0` or `1` but the junk values of `deriv` and `log` coincide there. -/\nlemma deriv_binEntropy (p : ‚Ñù) : deriv binEntropy p = log (1 - p) - log p := by\n  by_cases hp : p ‚â† 0 ‚àß p ‚â† 1\n  ¬∑ obtain ‚ü®hp‚ÇÄ, hp‚ÇÅ‚ü© := hp\n    rw [ne_comm, ‚Üê sub_ne_zero] at hp‚ÇÅ\n    rw [binEntropy_eq_negMulLog_add_negMulLog_one_sub', deriv_add, deriv_comp_const_sub,\n      deriv_negMulLog hp‚ÇÄ, deriv_negMulLog hp‚ÇÅ]\n    ¬∑ ring\n    all_goals fun_prop (disch := assumption)\n  -- pathological case where `deriv = 0` since `binEntropy` is not differentiable there\n  ¬∑ rw [deriv_zero_of_not_differentiableAt (differentiableAt_binEntropy_iff_ne_zero_one.not.2 hp)]\n    push_neg at hp\n    obtain rfl | rfl := hp <;> simp\n\n"}
{"name":"Real.qaryEntropy_zero","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"q : Nat\n‚ä¢ Eq (Real.qaryEntropy q 0) 0","decl":"@[simp] lemma qaryEntropy_zero (q : ‚Ñï) : qaryEntropy q 0 = 0 := by simp [qaryEntropy]\n"}
{"name":"Real.qaryEntropy_one","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"q : Nat\n‚ä¢ Eq (Real.qaryEntropy q 1) (Real.log ‚Üë(HSub.hSub (‚Üëq) 1))","decl":"@[simp] lemma qaryEntropy_one (q : ‚Ñï) : qaryEntropy q 1 = log (q - 1 : ‚Ñ§) := by simp [qaryEntropy]\n"}
{"name":"Real.qaryEntropy_two","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"‚ä¢ Eq (Real.qaryEntropy 2) Real.binEntropy","decl":"@[simp] lemma qaryEntropy_two : qaryEntropy 2 = binEntropy := by ext; simp [qaryEntropy]\n\n"}
{"name":"Real.qaryEntropy_pos","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"q : Nat\np : Real\nhp‚ÇÄ : LT.lt 0 p\nhp‚ÇÅ : LT.lt p 1\n‚ä¢ LT.lt 0 (Real.qaryEntropy q p)","decl":"lemma qaryEntropy_pos (hp‚ÇÄ : 0 < p) (hp‚ÇÅ : p < 1) : 0 < qaryEntropy q p := by\n  unfold qaryEntropy\n  have := binEntropy_pos hp‚ÇÄ hp‚ÇÅ\n  positivity\n\n"}
{"name":"Real.qaryEntropy_nonneg","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"q : Nat\np : Real\nhp‚ÇÄ : LE.le 0 p\nhp‚ÇÅ : LE.le p 1\n‚ä¢ LE.le 0 (Real.qaryEntropy q p)","decl":"lemma qaryEntropy_nonneg (hp‚ÇÄ : 0 ‚â§ p) (hp‚ÇÅ : p ‚â§ 1) : 0 ‚â§ qaryEntropy q p := by\n  obtain rfl | hp‚ÇÄ := hp‚ÇÄ.eq_or_lt\n  ¬∑ simp\n  obtain rfl | hp‚ÇÅ := hp‚ÇÅ.eq_or_lt\n  ¬∑ simpa [qaryEntropy, -Int.cast_sub] using log_intCast_nonneg _\n  exact (qaryEntropy_pos hp‚ÇÄ hp‚ÇÅ).le\n\n"}
{"name":"Real.qaryEntropy_neg_of_neg","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"q : Nat\np : Real\nhp : LT.lt p 0\n‚ä¢ LT.lt (Real.qaryEntropy q p) 0","decl":"/-- Outside the usual range of `qaryEntropy`, it is negative. This is due to `log p = log |p|`. -/\nlemma qaryEntropy_neg_of_neg (hp : p < 0) : qaryEntropy q p < 0 :=\n  add_neg_of_nonpos_of_neg (mul_nonpos_of_nonpos_of_nonneg hp.le (log_intCast_nonneg _))\n    (binEntropy_neg_of_neg hp)\n\n"}
{"name":"Real.qaryEntropy_nonpos_of_nonpos","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"q : Nat\np : Real\nhp : LE.le p 0\n‚ä¢ LE.le (Real.qaryEntropy q p) 0","decl":"/-- Outside the usual range of `qaryEntropy`, it is negative. This is due to `log p = log |p|`. -/\nlemma qaryEntropy_nonpos_of_nonpos (hp : p ‚â§ 0) : qaryEntropy q p ‚â§ 0 :=\n  add_nonpos (mul_nonpos_of_nonpos_of_nonneg hp (log_intCast_nonneg _))\n    (binEntropy_nonpos_of_nonpos hp)\n\n"}
{"name":"Real.qaryEntropy_continuous","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"q : Nat\n‚ä¢ Continuous (Real.qaryEntropy q)","decl":"/-- The q-ary entropy function is continuous everywhere.\nThis is due to definition of `Real.log` for negative numbers. -/\n@[fun_prop] lemma qaryEntropy_continuous : Continuous (qaryEntropy q) := by\n  unfold qaryEntropy; fun_prop\n\n"}
{"name":"Real.differentiableAt_qaryEntropy","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"q : Nat\np : Real\nhp‚ÇÄ : Ne p 0\nhp‚ÇÅ : Ne p 1\n‚ä¢ DifferentiableAt Real (Real.qaryEntropy q) p","decl":"@[fun_prop] lemma differentiableAt_qaryEntropy (hp‚ÇÄ : p ‚â† 0) (hp‚ÇÅ : p ‚â† 1) :\n    DifferentiableAt ‚Ñù (qaryEntropy q) p := by unfold qaryEntropy; fun_prop (disch := assumption)\n\n"}
{"name":"Real.deriv_qaryEntropy","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"q : Nat\np : Real\nhp‚ÇÄ : Ne p 0\nhp‚ÇÅ : Ne p 1\n‚ä¢ Eq (deriv (Real.qaryEntropy q) p) (HSub.hSub (HAdd.hAdd (Real.log (HSub.hSub (‚Üëq) 1)) (Real.log (HSub.hSub 1 p))) (Real.log p))","decl":"lemma deriv_qaryEntropy (hp‚ÇÄ : p ‚â† 0) (hp‚ÇÅ : p ‚â† 1) :\n    deriv (qaryEntropy q) p = log (q - 1) + log (1 - p) - log p := by\n  unfold qaryEntropy\n  rw [deriv_add]\n  ¬∑ simp only [Int.cast_sub, Int.cast_natCast, Int.cast_one, differentiableAt_id', deriv_mul_const,\n      deriv_id'', one_mul, deriv_binEntropy, add_sub_assoc]\n  all_goals fun_prop (disch := assumption)\n\n"}
{"name":"Real.hasDerivAt_binEntropy","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"p : Real\nhp‚ÇÄ : Ne p 0\nhp‚ÇÅ : Ne p 1\n‚ä¢ HasDerivAt Real.binEntropy (HSub.hSub (Real.log (HSub.hSub 1 p)) (Real.log p)) p","decl":"/-- Binary entropy has derivative `log (1 - p) - log p`. -/\nlemma hasDerivAt_binEntropy (hp‚ÇÄ : p ‚â† 0) (hp‚ÇÅ : p ‚â† 1) :\n    HasDerivAt binEntropy (log (1 - p) - log p) p :=\n  deriv_binEntropy _ ‚ñ∏ (differentiableAt_binEntropy hp‚ÇÄ hp‚ÇÅ).hasDerivAt\n\n"}
{"name":"Real.hasDerivAt_qaryEntropy","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"q : Nat\np : Real\nhp‚ÇÄ : Ne p 0\nhp‚ÇÅ : Ne p 1\n‚ä¢ HasDerivAt (Real.qaryEntropy q) (HSub.hSub (HAdd.hAdd (Real.log (HSub.hSub (‚Üëq) 1)) (Real.log (HSub.hSub 1 p))) (Real.log p)) p","decl":"lemma hasDerivAt_qaryEntropy (hp‚ÇÄ : p ‚â† 0) (hp‚ÇÅ : p ‚â† 1) :\n    HasDerivAt (qaryEntropy q) (log (q - 1) + log (1 - p) - log p) p :=\n  deriv_qaryEntropy hp‚ÇÄ hp‚ÇÅ ‚ñ∏ (differentiableAt_qaryEntropy hp‚ÇÄ hp‚ÇÅ).hasDerivAt\n\n"}
{"name":"Real.not_continuousAt_deriv_qaryEntropy_one","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"q : Nat\n‚ä¢ Not (ContinuousAt (deriv (Real.qaryEntropy q)) 1)","decl":"lemma not_continuousAt_deriv_qaryEntropy_one :\n    ¬¨ContinuousAt (deriv (qaryEntropy q)) 1 := by\n  have tendstoBot : Tendsto (fun p ‚Ü¶ log (q - 1) + log (1 - p) - log p) (ùìù[<] 1) atBot := by\n    have : (fun p ‚Ü¶ log (q - 1) + log (1 - p) - log p)\n      = (fun p ‚Ü¶ log (q - 1) + (log (1 - p) - log p)) := by\n      ext\n      ring\n    rw [this]\n    apply tendsto_atBot_add_const_left\n    exact tendsto_log_one_sub_sub_log_nhdsLT_one_atBot\n  apply not_continuousAt_of_tendsto (Filter.Tendsto.congr' _ tendstoBot) nhdsWithin_le_nhds\n  ¬∑ simp only [disjoint_nhds_atBot_iff, not_isBot, not_false_eq_true]\n  filter_upwards [Ioo_mem_nhdsLT (show 1 - 2‚Åª¬π < (1 : ‚Ñù) by norm_num)]\n  intros\n  apply (deriv_qaryEntropy _ _).symm\n  ¬∑ simp_all only [mem_Ioo, ne_eq]\n    linarith [show (1 : ‚Ñù) = 2‚Åª¬π + 2‚Åª¬π by norm_num]\n  ¬∑ simp_all only [mem_Ioo, ne_eq]\n    linarith [two_inv_lt_one (Œ± := ‚Ñù)]\n\n"}
{"name":"Real.not_continuousAt_deriv_qaryEntropy_zero","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"q : Nat\n‚ä¢ Not (ContinuousAt (deriv (Real.qaryEntropy q)) 0)","decl":"lemma not_continuousAt_deriv_qaryEntropy_zero :\n    ¬¨ContinuousAt (deriv (qaryEntropy q)) 0 := by\n  have tendstoTop : Tendsto (fun p ‚Ü¶ log (q - 1) + log (1 - p) - log p) (ùìù[>] 0) atTop := by\n    have : (fun p ‚Ü¶ log (q - 1) + log (1 - p) - log p)\n        = (fun p ‚Ü¶ log (q - 1) + (log (1 - p) - log p)) := by ext; ring\n    rw [this]\n    exact tendsto_atTop_add_const_left _ _ tendsto_log_one_sub_sub_log_nhdsGT_atAtop\n  apply not_continuousAt_of_tendsto (Filter.Tendsto.congr' _ tendstoTop) nhdsWithin_le_nhds\n  ¬∑ simp only [disjoint_nhds_atTop_iff, not_isTop, not_false_eq_true]\n  filter_upwards [Ioo_mem_nhdsGT (show (0 : ‚Ñù) < 2‚Åª¬π by norm_num)]\n  intros\n  apply (deriv_qaryEntropy _ _).symm\n  ¬∑ simp_all only [zero_add, mem_Ioo, ne_eq]\n    linarith\n  ¬∑ simp_all only [zero_add, mem_Ioo, ne_eq]\n    linarith [two_inv_lt_one (Œ± := ‚Ñù)]\n\n"}
{"name":"Real.deriv2_qaryEntropy","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"q : Nat\np : Real\n‚ä¢ Eq (Nat.iterate deriv 2 (Real.qaryEntropy q) p) (HDiv.hDiv (-1) (HMul.hMul p (HSub.hSub 1 p)))","decl":"/-- Second derivative of q-ary entropy. -/\nlemma deriv2_qaryEntropy :\n    deriv^[2] (qaryEntropy q) p = -1 / (p * (1 - p)) := by\n  simp only [Function.iterate_succ, Function.iterate_zero, Function.id_comp, Function.comp_apply]\n  by_cases is_x_where_nondiff : p ‚â† 0 ‚àß p ‚â† 1  -- normal case\n  ¬∑ obtain ‚ü®xne0, xne1‚ü© := is_x_where_nondiff\n    suffices ‚àÄ·∂† y in (ùìù p),\n        deriv (fun p ‚Ü¶ (qaryEntropy q) p) y = log (q - 1) + log (1 - y) - log y by\n      refine (Filter.EventuallyEq.deriv_eq this).trans ?_\n      rw [deriv_sub ?_ (differentiableAt_log xne0)]\n      ¬∑ rw [deriv.log differentiableAt_id' xne0]\n        simp only [deriv_id'', one_div]\n        ¬∑ have {q : ‚Ñù} (p : ‚Ñù) : DifferentiableAt ‚Ñù (fun p => q - p) p := by fun_prop\n          have d_oneminus (p : ‚Ñù) : deriv (fun (y : ‚Ñù) ‚Ü¶ 1 - y) p = -1 := by\n            rw [deriv_const_sub 1, deriv_id'']\n          field_simp [sub_ne_zero_of_ne xne1.symm, this, d_oneminus]\n          ring\n      ¬∑ apply DifferentiableAt.add\n        simp only [ne_eq, differentiableAt_const]\n        exact DifferentiableAt.log (by fun_prop) (sub_ne_zero.mpr xne1.symm)\n    filter_upwards [eventually_ne_nhds xne0, eventually_ne_nhds xne1]\n      with y xne0 h2 using deriv_qaryEntropy xne0 h2\n  -- Pathological case where we use junk value (because function not differentiable)\n  ¬∑ have : p = 0 ‚à® p = 1 := Decidable.or_iff_not_and_not.mpr is_x_where_nondiff\n    rw [deriv_zero_of_not_differentiableAt]\n    ¬∑ simp_all only [ne_eq, not_and, Decidable.not_not]\n      cases this <;> simp_all only [\n        mul_zero, one_ne_zero, zero_ne_one, sub_zero, mul_one, div_zero, sub_self]\n    ¬∑ intro h\n      have contAt := h.continuousAt\n      cases this <;> simp_all [\n        not_continuousAt_deriv_qaryEntropy_zero, not_continuousAt_deriv_qaryEntropy_one, contAt]\n\n"}
{"name":"Real.deriv2_binEntropy","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"p : Real\n‚ä¢ Eq (Nat.iterate deriv 2 Real.binEntropy p) (HDiv.hDiv (-1) (HMul.hMul p (HSub.hSub 1 p)))","decl":"lemma deriv2_binEntropy : deriv^[2] binEntropy p = -1 / (p * (1 - p)) :=\n  qaryEntropy_two ‚ñ∏ deriv2_qaryEntropy\n\n"}
{"name":"Real.qaryEntropy_strictMonoOn","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"q : Nat\nqLe2 : LE.le 2 q\n‚ä¢ StrictMonoOn (Real.qaryEntropy q) (Set.Icc 0 (HSub.hSub 1 (HDiv.hDiv 1 ‚Üëq)))","decl":"/-- Qary entropy is strictly increasing in the interval [0, 1 - q‚Åª¬π]. -/\nlemma qaryEntropy_strictMonoOn (qLe2 : 2 ‚â§ q) :\n    StrictMonoOn (qaryEntropy q) (Icc 0 (1 - 1/q)) := by\n  intro p1 hp1 p2 hp2 p1le2\n  apply strictMonoOn_of_deriv_pos (convex_Icc 0 (1 - 1/(q : ‚Ñù))) _ _ hp1 hp2 p1le2\n  ¬∑ exact qaryEntropy_continuous.continuousOn\n  ¬∑ intro p hp\n    have : 2 ‚â§ (q : ‚Ñù) := Nat.ofNat_le_cast.mpr qLe2\n    have zero_le_qinv : 0 < (q : ‚Ñù)‚Åª¬π := by positivity\n    have : 0 < 1 - p := by\n      simp only [sub_pos, hp.2]\n      have p_lt_1_minus_qinv : p < 1 - (q : ‚Ñù)‚Åª¬π := by\n        simp_all only [inv_pos, interior_Icc, mem_Ioo, one_div]\n      linarith\n    simp only [one_div, interior_Icc, mem_Ioo] at hp\n    rw [deriv_qaryEntropy (by linarith)]\n    ¬∑ field_simp\n      rw [‚Üê log_mul (by linarith) (by linarith)]\n      apply Real.strictMonoOn_log (mem_Ioi.mpr hp.1)\n      ¬∑ simp_all only [mem_Ioi, mul_pos_iff_of_pos_left, show 0 < (q : ‚Ñù) - 1 by linarith]\n      ¬∑ have qpos : 0 < (q : ‚Ñù) := by positivity\n        have : q * p < q - 1 := by\n          convert (mul_lt_mul_left qpos).2 hp.2 using 1\n          simp only [mul_sub, mul_one, isUnit_iff_ne_zero, ne_eq, ne_of_gt qpos, not_false_eq_true,\n            IsUnit.mul_inv_cancel]\n        linarith\n    exact (ne_of_gt (lt_add_neg_iff_lt.mp this : p < 1)).symm\n\n"}
{"name":"Real.qaryEntropy_strictAntiOn","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"q : Nat\nqLe2 : LE.le 2 q\n‚ä¢ StrictAntiOn (Real.qaryEntropy q) (Set.Icc (HSub.hSub 1 (HDiv.hDiv 1 ‚Üëq)) 1)","decl":"/-- Qary entropy is strictly decreasing in the interval [1 - q‚Åª¬π, 1]. -/\nlemma qaryEntropy_strictAntiOn (qLe2 : 2 ‚â§ q) :\n    StrictAntiOn (qaryEntropy q) (Icc (1 - 1/q) 1) := by\n  intro p1 hp1 p2 hp2 p1le2\n  apply strictAntiOn_of_deriv_neg (convex_Icc (1 - 1/(q : ‚Ñù)) 1) _ _ hp1 hp2 p1le2\n  ¬∑ exact qaryEntropy_continuous.continuousOn\n  ¬∑ intro p hp\n    have : 2 ‚â§ (q : ‚Ñù) := Nat.ofNat_le_cast.mpr qLe2\n    have qinv_lt_1 : (q : ‚Ñù)‚Åª¬π < 1 := inv_lt_one_of_one_lt‚ÇÄ (by linarith)\n    have zero_lt_1_sub_p : 0 < 1 - p := by simp_all only [sub_pos, hp.2, interior_Icc, mem_Ioo]\n    simp only [one_div, interior_Icc, mem_Ioo] at hp\n    rw [deriv_qaryEntropy (by linarith)]\n    ¬∑ field_simp\n      rw [‚Üê log_mul (by linarith) (by linarith)]\n      apply Real.strictMonoOn_log (mem_Ioi.mpr (show 0 < (‚Üëq - 1) * (1 - p) by nlinarith))\n      ¬∑ simp_all only [mem_Ioi, mul_pos_iff_of_pos_left]\n        linarith\n      ¬∑ have qpos : 0 < (q : ‚Ñù) := by positivity\n        ring_nf\n        simp only [add_lt_iff_neg_right, neg_add_lt_iff_lt_add, add_zero, gt_iff_lt]\n        have : (q : ‚Ñù) - 1 < p * q := by\n          have tmp := mul_lt_mul_of_pos_right hp.1 qpos\n          simp at tmp\n          have : (q : ‚Ñù) ‚â† 0 := (ne_of_lt qpos).symm\n          have asdfasfd : (1 - (q : ‚Ñù)‚Åª¬π) * ‚Üëq = q - 1 := by calc (1 - (q : ‚Ñù)‚Åª¬π) * ‚Üëq\n            _ = q - (q : ‚Ñù)‚Åª¬π * (q : ‚Ñù) := by ring\n            _ = q - 1 := by simp_all only [ne_eq, isUnit_iff_ne_zero, Rat.cast_eq_zero,\n              not_false_eq_true, IsUnit.inv_mul_cancel]\n          rwa [asdfasfd] at tmp\n        nlinarith\n    exact (ne_of_gt (lt_add_neg_iff_lt.mp zero_lt_1_sub_p : p < 1)).symm\n\n"}
{"name":"Real.binEntropy_strictMonoOn","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"‚ä¢ StrictMonoOn Real.binEntropy (Set.Icc 0 (Inv.inv 2))","decl":"/-- Binary entropy is strictly increasing in interval [0, 1/2]. -/\nlemma binEntropy_strictMonoOn : StrictMonoOn binEntropy (Icc 0 2‚Åª¬π) := by\n  rw [show Icc (0 : ‚Ñù) 2‚Åª¬π = Icc 0 (1 - 1/2) by norm_num, ‚Üê qaryEntropy_two]\n  exact qaryEntropy_strictMonoOn (by rfl)\n\n"}
{"name":"Real.binEntropy_strictAntiOn","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"‚ä¢ StrictAntiOn Real.binEntropy (Set.Icc (Inv.inv 2) 1)","decl":"/-- Binary entropy is strictly decreasing in interval [1/2, 1]. -/\nlemma binEntropy_strictAntiOn : StrictAntiOn binEntropy (Icc 2‚Åª¬π 1) := by\n  rw [show (Icc (2‚Åª¬π : ‚Ñù) 1) = Icc (1/2) 1 by norm_num, ‚Üê qaryEntropy_two]\n  convert qaryEntropy_strictAntiOn (by rfl) using 1\n  norm_num\n\n"}
{"name":"Real.strictConcaveOn_qaryEntropy","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"q : Nat\n‚ä¢ StrictConcaveOn Real (Set.Icc 0 1) (Real.qaryEntropy q)","decl":"lemma strictConcaveOn_qaryEntropy : StrictConcaveOn ‚Ñù (Icc 0 1) (qaryEntropy q) := by\n  apply strictConcaveOn_of_deriv2_neg (convex_Icc 0 1) qaryEntropy_continuous.continuousOn\n  intro p hp\n  rw [deriv2_qaryEntropy]\n  ¬∑ simp_all only [interior_Icc, mem_Ioo]\n    apply div_neg_of_neg_of_pos\n    ¬∑ norm_num [show 0 < log 2 by positivity]\n    ¬∑ simp_all only [gt_iff_lt, mul_pos_iff_of_pos_left, sub_pos, hp]\n\n"}
{"name":"Real.strictConcave_binEntropy","module":"Mathlib.Analysis.SpecialFunctions.BinaryEntropy","initialProofState":"‚ä¢ StrictConcaveOn Real (Set.Icc 0 1) Real.binEntropy","decl":"lemma strictConcave_binEntropy : StrictConcaveOn ‚Ñù (Icc 0 1) binEntropy :=\n  qaryEntropy_two ‚ñ∏ strictConcaveOn_qaryEntropy\n\n"}
