{"name":"ContinuousLinearMap.opNorm_ext","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝⁹ : SeminormedAddCommGroup E\ninst✝⁸ : SeminormedAddCommGroup F\ninst✝⁷ : SeminormedAddCommGroup G\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NontriviallyNormedField 𝕜₂\ninst✝⁴ : NontriviallyNormedField 𝕜₃\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedSpace 𝕜₂ F\ninst✝¹ : NormedSpace 𝕜₃ G\nσ₁₂ : RingHom 𝕜 𝕜₂\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝ : RingHomIsometric σ₁₃\nf : ContinuousLinearMap σ₁₂ E F\ng : ContinuousLinearMap σ₁₃ E G\nh : ∀ (x : E), Eq (Norm.norm (f x)) (Norm.norm (g x))\n⊢ Eq (Norm.norm f) (Norm.norm g)","decl":"theorem opNorm_ext [RingHomIsometric σ₁₃] (f : E →SL[σ₁₂] F) (g : E →SL[σ₁₃] G)\n    (h : ∀ x, ‖f x‖ = ‖g x‖) : ‖f‖ = ‖g‖ :=\n  opNorm_eq_of_bounds (norm_nonneg _)\n    (fun x => by\n      rw [h x]\n      exact le_opNorm _ _)\n    fun c hc h₂ =>\n    opNorm_le_bound _ hc fun z => by\n      rw [← h z]\n      exact h₂ z\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_le_bound₂","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝⁹ : SeminormedAddCommGroup E\ninst✝⁸ : SeminormedAddCommGroup F\ninst✝⁷ : SeminormedAddCommGroup G\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NontriviallyNormedField 𝕜₂\ninst✝⁴ : NontriviallyNormedField 𝕜₃\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedSpace 𝕜₂ F\ninst✝¹ : NormedSpace 𝕜₃ G\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝ : RingHomIsometric σ₂₃\nf : ContinuousLinearMap σ₁₃ E (ContinuousLinearMap σ₂₃ F G)\nC : Real\nh0 : LE.le 0 C\nhC : ∀ (x : E) (y : F), LE.le (Norm.norm ((f x) y)) (HMul.hMul (HMul.hMul C (Norm.norm x)) (Norm.norm y))\n⊢ LE.le (Norm.norm f) C","decl":"theorem opNorm_le_bound₂ (f : E →SL[σ₁₃] F →SL[σ₂₃] G) {C : ℝ} (h0 : 0 ≤ C)\n    (hC : ∀ x y, ‖f x y‖ ≤ C * ‖x‖ * ‖y‖) : ‖f‖ ≤ C :=\n  f.opNorm_le_bound h0 fun x => (f x).opNorm_le_bound (mul_nonneg h0 (norm_nonneg _)) <| hC x\n\n\n"}
{"name":"ContinuousLinearMap.le_opNorm₂","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝¹⁰ : SeminormedAddCommGroup E\ninst✝⁹ : SeminormedAddCommGroup F\ninst✝⁸ : SeminormedAddCommGroup G\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NontriviallyNormedField 𝕜₂\ninst✝⁵ : NontriviallyNormedField 𝕜₃\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedSpace 𝕜₂ F\ninst✝² : NormedSpace 𝕜₃ G\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝¹ : RingHomIsometric σ₂₃\ninst✝ : RingHomIsometric σ₁₃\nf : ContinuousLinearMap σ₁₃ E (ContinuousLinearMap σ₂₃ F G)\nx : E\ny : F\n⊢ LE.le (Norm.norm ((f x) y)) (HMul.hMul (HMul.hMul (Norm.norm f) (Norm.norm x)) (Norm.norm y))","decl":"theorem le_opNorm₂ [RingHomIsometric σ₁₃] (f : E →SL[σ₁₃] F →SL[σ₂₃] G) (x : E) (y : F) :\n    ‖f x y‖ ≤ ‖f‖ * ‖x‖ * ‖y‖ :=\n  (f x).le_of_opNorm_le (f.le_opNorm x) y\n\n\n"}
{"name":"ContinuousLinearMap.le_of_opNorm₂_le_of_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝¹⁰ : SeminormedAddCommGroup E\ninst✝⁹ : SeminormedAddCommGroup F\ninst✝⁸ : SeminormedAddCommGroup G\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NontriviallyNormedField 𝕜₂\ninst✝⁵ : NontriviallyNormedField 𝕜₃\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedSpace 𝕜₂ F\ninst✝² : NormedSpace 𝕜₃ G\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝¹ : RingHomIsometric σ₂₃\ninst✝ : RingHomIsometric σ₁₃\nf : ContinuousLinearMap σ₁₃ E (ContinuousLinearMap σ₂₃ F G)\nx : E\ny : F\na b c : Real\nhf : LE.le (Norm.norm f) a\nhx : LE.le (Norm.norm x) b\nhy : LE.le (Norm.norm y) c\n⊢ LE.le (Norm.norm ((f x) y)) (HMul.hMul (HMul.hMul a b) c)","decl":"theorem le_of_opNorm₂_le_of_le [RingHomIsometric σ₁₃] (f : E →SL[σ₁₃] F →SL[σ₂₃] G) {x : E} {y : F}\n    {a b c : ℝ} (hf : ‖f‖ ≤ a) (hx : ‖x‖ ≤ b) (hy : ‖y‖ ≤ c) :\n    ‖f x y‖ ≤ a * b * c :=\n  (f x).le_of_opNorm_le_of_le (f.le_of_opNorm_le_of_le hf hx) hy\n\n\n"}
{"name":"LinearMap.norm_mkContinuous₂_aux","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝⁸ : SeminormedAddCommGroup E\ninst✝⁷ : SeminormedAddCommGroup F\ninst✝⁶ : SeminormedAddCommGroup G\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NontriviallyNormedField 𝕜₂\ninst✝³ : NontriviallyNormedField 𝕜₃\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\ninst✝ : NormedSpace 𝕜₃ G\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\nf : LinearMap σ₁₃ E (LinearMap σ₂₃ F G)\nC : Real\nh : ∀ (x : E) (y : F), LE.le (Norm.norm ((f x) y)) (HMul.hMul (HMul.hMul C (Norm.norm x)) (Norm.norm y))\nx : E\n⊢ LE.le (Norm.norm ((f x).mkContinuous (HMul.hMul C (Norm.norm x)) ⋯)) (HMul.hMul (Max.max C 0) (Norm.norm x))","decl":"lemma norm_mkContinuous₂_aux (f : E →ₛₗ[σ₁₃] F →ₛₗ[σ₂₃] G) (C : ℝ)\n    (h : ∀ x y, ‖f x y‖ ≤ C * ‖x‖ * ‖y‖) (x : E) :\n    ‖(f x).mkContinuous (C * ‖x‖) (h x)‖ ≤ max C 0 * ‖x‖ :=\n  (mkContinuous_norm_le' (f x) (h x)).trans_eq <| by\n    rw [max_mul_of_nonneg _ _ (norm_nonneg x), zero_mul]\n\n"}
{"name":"LinearMap.mkContinuous₂_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝⁹ : SeminormedAddCommGroup E\ninst✝⁸ : SeminormedAddCommGroup F\ninst✝⁷ : SeminormedAddCommGroup G\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NontriviallyNormedField 𝕜₂\ninst✝⁴ : NontriviallyNormedField 𝕜₃\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedSpace 𝕜₂ F\ninst✝¹ : NormedSpace 𝕜₃ G\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝ : RingHomIsometric σ₂₃\nf : LinearMap σ₁₃ E (LinearMap σ₂₃ F G)\nC : Real\nhC : ∀ (x : E) (y : F), LE.le (Norm.norm ((f x) y)) (HMul.hMul (HMul.hMul C (Norm.norm x)) (Norm.norm y))\nx : E\ny : F\n⊢ Eq (((f.mkContinuous₂ C hC) x) y) ((f x) y)","decl":"@[simp]\ntheorem mkContinuous₂_apply (f : E →ₛₗ[σ₁₃] F →ₛₗ[σ₂₃] G) {C : ℝ}\n    (hC : ∀ x y, ‖f x y‖ ≤ C * ‖x‖ * ‖y‖) (x : E) (y : F) : f.mkContinuous₂ C hC x y = f x y :=\n  rfl\n\n"}
{"name":"LinearMap.mkContinuous₂_norm_le'","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝⁹ : SeminormedAddCommGroup E\ninst✝⁸ : SeminormedAddCommGroup F\ninst✝⁷ : SeminormedAddCommGroup G\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NontriviallyNormedField 𝕜₂\ninst✝⁴ : NontriviallyNormedField 𝕜₃\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedSpace 𝕜₂ F\ninst✝¹ : NormedSpace 𝕜₃ G\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝ : RingHomIsometric σ₂₃\nf : LinearMap σ₁₃ E (LinearMap σ₂₃ F G)\nC : Real\nhC : ∀ (x : E) (y : F), LE.le (Norm.norm ((f x) y)) (HMul.hMul (HMul.hMul C (Norm.norm x)) (Norm.norm y))\n⊢ LE.le (Norm.norm (f.mkContinuous₂ C hC)) (Max.max C 0)","decl":"theorem mkContinuous₂_norm_le' (f : E →ₛₗ[σ₁₃] F →ₛₗ[σ₂₃] G) {C : ℝ}\n    (hC : ∀ x y, ‖f x y‖ ≤ C * ‖x‖ * ‖y‖) : ‖f.mkContinuous₂ C hC‖ ≤ max C 0 :=\n  mkContinuous_norm_le _ (le_max_iff.2 <| Or.inr le_rfl) (norm_mkContinuous₂_aux f C hC)\n\n"}
{"name":"LinearMap.mkContinuous₂_norm_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝⁹ : SeminormedAddCommGroup E\ninst✝⁸ : SeminormedAddCommGroup F\ninst✝⁷ : SeminormedAddCommGroup G\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NontriviallyNormedField 𝕜₂\ninst✝⁴ : NontriviallyNormedField 𝕜₃\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedSpace 𝕜₂ F\ninst✝¹ : NormedSpace 𝕜₃ G\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝ : RingHomIsometric σ₂₃\nf : LinearMap σ₁₃ E (LinearMap σ₂₃ F G)\nC : Real\nh0 : LE.le 0 C\nhC : ∀ (x : E) (y : F), LE.le (Norm.norm ((f x) y)) (HMul.hMul (HMul.hMul C (Norm.norm x)) (Norm.norm y))\n⊢ LE.le (Norm.norm (f.mkContinuous₂ C hC)) C","decl":"theorem mkContinuous₂_norm_le (f : E →ₛₗ[σ₁₃] F →ₛₗ[σ₂₃] G) {C : ℝ} (h0 : 0 ≤ C)\n    (hC : ∀ x y, ‖f x y‖ ≤ C * ‖x‖ * ‖y‖) : ‖f.mkContinuous₂ C hC‖ ≤ C :=\n  (f.mkContinuous₂_norm_le' hC).trans_eq <| max_eq_left h0\n\n"}
{"name":"ContinuousLinearMap.flip_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝¹⁰ : SeminormedAddCommGroup E\ninst✝⁹ : SeminormedAddCommGroup F\ninst✝⁸ : SeminormedAddCommGroup G\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NontriviallyNormedField 𝕜₂\ninst✝⁵ : NontriviallyNormedField 𝕜₃\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedSpace 𝕜₂ F\ninst✝² : NormedSpace 𝕜₃ G\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝¹ : RingHomIsometric σ₂₃\ninst✝ : RingHomIsometric σ₁₃\nf : ContinuousLinearMap σ₁₃ E (ContinuousLinearMap σ₂₃ F G)\nx : E\ny : F\n⊢ Eq ((f.flip y) x) ((f x) y)","decl":"@[simp]\ntheorem flip_apply (f : E →SL[σ₁₃] F →SL[σ₂₃] G) (x : E) (y : F) : f.flip y x = f x y :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.flip_flip","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝¹⁰ : SeminormedAddCommGroup E\ninst✝⁹ : SeminormedAddCommGroup F\ninst✝⁸ : SeminormedAddCommGroup G\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NontriviallyNormedField 𝕜₂\ninst✝⁵ : NontriviallyNormedField 𝕜₃\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedSpace 𝕜₂ F\ninst✝² : NormedSpace 𝕜₃ G\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝¹ : RingHomIsometric σ₂₃\ninst✝ : RingHomIsometric σ₁₃\nf : ContinuousLinearMap σ₁₃ E (ContinuousLinearMap σ₂₃ F G)\n⊢ Eq f.flip.flip f","decl":"@[simp]\ntheorem flip_flip (f : E →SL[σ₁₃] F →SL[σ₂₃] G) : f.flip.flip = f := by\n  ext\n  rfl\n\n"}
{"name":"ContinuousLinearMap.opNorm_flip","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝¹⁰ : SeminormedAddCommGroup E\ninst✝⁹ : SeminormedAddCommGroup F\ninst✝⁸ : SeminormedAddCommGroup G\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NontriviallyNormedField 𝕜₂\ninst✝⁵ : NontriviallyNormedField 𝕜₃\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedSpace 𝕜₂ F\ninst✝² : NormedSpace 𝕜₃ G\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝¹ : RingHomIsometric σ₂₃\ninst✝ : RingHomIsometric σ₁₃\nf : ContinuousLinearMap σ₁₃ E (ContinuousLinearMap σ₂₃ F G)\n⊢ Eq (Norm.norm f.flip) (Norm.norm f)","decl":"@[simp]\ntheorem opNorm_flip (f : E →SL[σ₁₃] F →SL[σ₂₃] G) : ‖f.flip‖ = ‖f‖ :=\n  le_antisymm (by simpa only [flip_flip] using le_norm_flip f.flip) (le_norm_flip f)\n\n\n"}
{"name":"ContinuousLinearMap.flip_add","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝¹⁰ : SeminormedAddCommGroup E\ninst✝⁹ : SeminormedAddCommGroup F\ninst✝⁸ : SeminormedAddCommGroup G\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NontriviallyNormedField 𝕜₂\ninst✝⁵ : NontriviallyNormedField 𝕜₃\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedSpace 𝕜₂ F\ninst✝² : NormedSpace 𝕜₃ G\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝¹ : RingHomIsometric σ₂₃\ninst✝ : RingHomIsometric σ₁₃\nf g : ContinuousLinearMap σ₁₃ E (ContinuousLinearMap σ₂₃ F G)\n⊢ Eq (HAdd.hAdd f g).flip (HAdd.hAdd f.flip g.flip)","decl":"@[simp]\ntheorem flip_add (f g : E →SL[σ₁₃] F →SL[σ₂₃] G) : (f + g).flip = f.flip + g.flip :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.flip_smul","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝¹⁰ : SeminormedAddCommGroup E\ninst✝⁹ : SeminormedAddCommGroup F\ninst✝⁸ : SeminormedAddCommGroup G\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NontriviallyNormedField 𝕜₂\ninst✝⁵ : NontriviallyNormedField 𝕜₃\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedSpace 𝕜₂ F\ninst✝² : NormedSpace 𝕜₃ G\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝¹ : RingHomIsometric σ₂₃\ninst✝ : RingHomIsometric σ₁₃\nc : 𝕜₃\nf : ContinuousLinearMap σ₁₃ E (ContinuousLinearMap σ₂₃ F G)\n⊢ Eq (HSMul.hSMul c f).flip (HSMul.hSMul c f.flip)","decl":"@[simp]\ntheorem flip_smul (c : 𝕜₃) (f : E →SL[σ₁₃] F →SL[σ₂₃] G) : (c • f).flip = c • f.flip :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.flipₗᵢ'_symm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝¹⁰ : SeminormedAddCommGroup E\ninst✝⁹ : SeminormedAddCommGroup F\ninst✝⁸ : SeminormedAddCommGroup G\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NontriviallyNormedField 𝕜₂\ninst✝⁵ : NontriviallyNormedField 𝕜₃\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedSpace 𝕜₂ F\ninst✝² : NormedSpace 𝕜₃ G\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝¹ : RingHomIsometric σ₂₃\ninst✝ : RingHomIsometric σ₁₃\n⊢ Eq (ContinuousLinearMap.flipₗᵢ' E F G σ₂₃ σ₁₃).symm (ContinuousLinearMap.flipₗᵢ' F E G σ₁₃ σ₂₃)","decl":"@[simp]\ntheorem flipₗᵢ'_symm : (flipₗᵢ' E F G σ₂₃ σ₁₃).symm = flipₗᵢ' F E G σ₁₃ σ₂₃ :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_flipₗᵢ'","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝¹⁰ : SeminormedAddCommGroup E\ninst✝⁹ : SeminormedAddCommGroup F\ninst✝⁸ : SeminormedAddCommGroup G\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NontriviallyNormedField 𝕜₂\ninst✝⁵ : NontriviallyNormedField 𝕜₃\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedSpace 𝕜₂ F\ninst✝² : NormedSpace 𝕜₃ G\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝¹ : RingHomIsometric σ₂₃\ninst✝ : RingHomIsometric σ₁₃\n⊢ Eq (⇑(ContinuousLinearMap.flipₗᵢ' E F G σ₂₃ σ₁₃)) ContinuousLinearMap.flip","decl":"@[simp]\ntheorem coe_flipₗᵢ' : ⇑(flipₗᵢ' E F G σ₂₃ σ₁₃) = flip :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.flipₗᵢ_symm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nFₗ : Type u_7\nGₗ : Type u_9\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup Fₗ\ninst✝⁴ : SeminormedAddCommGroup Gₗ\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜 Fₗ\ninst✝ : NormedSpace 𝕜 Gₗ\n⊢ Eq (ContinuousLinearMap.flipₗᵢ 𝕜 E Fₗ Gₗ).symm (ContinuousLinearMap.flipₗᵢ 𝕜 Fₗ E Gₗ)","decl":"@[simp]\ntheorem flipₗᵢ_symm : (flipₗᵢ 𝕜 E Fₗ Gₗ).symm = flipₗᵢ 𝕜 Fₗ E Gₗ :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_flipₗᵢ","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nFₗ : Type u_7\nGₗ : Type u_9\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup Fₗ\ninst✝⁴ : SeminormedAddCommGroup Gₗ\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜 Fₗ\ninst✝ : NormedSpace 𝕜 Gₗ\n⊢ Eq (⇑(ContinuousLinearMap.flipₗᵢ 𝕜 E Fₗ Gₗ)) ContinuousLinearMap.flip","decl":"@[simp]\ntheorem coe_flipₗᵢ : ⇑(flipₗᵢ 𝕜 E Fₗ Gₗ) = flip :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.apply_apply'","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_6\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nv : E\nf : ContinuousLinearMap σ₁₂ E F\n⊢ Eq (((ContinuousLinearMap.apply' F σ₁₂) v) f) (f v)","decl":"@[simp]\ntheorem apply_apply' (v : E) (f : E →SL[σ₁₂] F) : apply' F σ₁₂ v f = f v :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.apply_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nFₗ : Type u_7\ninst✝⁴ : SeminormedAddCommGroup E\ninst✝³ : SeminormedAddCommGroup Fₗ\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜 Fₗ\nv : E\nf : ContinuousLinearMap (RingHom.id 𝕜) E Fₗ\n⊢ Eq (((ContinuousLinearMap.apply 𝕜 Fₗ) v) f) (f v)","decl":"@[simp]\ntheorem apply_apply (v : E) (f : E →L[𝕜] Fₗ) : apply 𝕜 Fₗ v f = f v :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.norm_compSL_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝¹² : SeminormedAddCommGroup E\ninst✝¹¹ : SeminormedAddCommGroup F\ninst✝¹⁰ : SeminormedAddCommGroup G\ninst✝⁹ : NontriviallyNormedField 𝕜\ninst✝⁸ : NontriviallyNormedField 𝕜₂\ninst✝⁷ : NontriviallyNormedField 𝕜₃\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedSpace 𝕜₂ F\ninst✝⁴ : NormedSpace 𝕜₃ G\nσ₁₂ : RingHom 𝕜 𝕜₂\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝³ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\ninst✝² : RingHomIsometric σ₂₃\ninst✝¹ : RingHomIsometric σ₁₃\ninst✝ : RingHomIsometric σ₁₂\n⊢ LE.le (Norm.norm (ContinuousLinearMap.compSL E F G σ₁₂ σ₂₃)) 1","decl":"set_option maxSynthPendingDepth 2 in\ntheorem norm_compSL_le : ‖compSL E F G σ₁₂ σ₂₃‖ ≤ 1 :=\n  LinearMap.mkContinuous₂_norm_le _ zero_le_one _\n\n"}
{"name":"ContinuousLinearMap.compSL_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝¹² : SeminormedAddCommGroup E\ninst✝¹¹ : SeminormedAddCommGroup F\ninst✝¹⁰ : SeminormedAddCommGroup G\ninst✝⁹ : NontriviallyNormedField 𝕜\ninst✝⁸ : NontriviallyNormedField 𝕜₂\ninst✝⁷ : NontriviallyNormedField 𝕜₃\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedSpace 𝕜₂ F\ninst✝⁴ : NormedSpace 𝕜₃ G\nσ₁₂ : RingHom 𝕜 𝕜₂\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝³ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\ninst✝² : RingHomIsometric σ₂₃\ninst✝¹ : RingHomIsometric σ₁₃\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₂₃ F G\ng : ContinuousLinearMap σ₁₂ E F\n⊢ Eq (((ContinuousLinearMap.compSL E F G σ₁₂ σ₂₃) f) g) (f.comp g)","decl":"@[simp]\ntheorem compSL_apply (f : F →SL[σ₂₃] G) (g : E →SL[σ₁₂] F) : compSL E F G σ₁₂ σ₂₃ f g = f.comp g :=\n  rfl\n\n"}
{"name":"Continuous.const_clm_comp","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝¹³ : SeminormedAddCommGroup E\ninst✝¹² : SeminormedAddCommGroup F\ninst✝¹¹ : SeminormedAddCommGroup G\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NontriviallyNormedField 𝕜₂\ninst✝⁸ : NontriviallyNormedField 𝕜₃\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : NormedSpace 𝕜₂ F\ninst✝⁵ : NormedSpace 𝕜₃ G\nσ₁₂ : RingHom 𝕜 𝕜₂\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝⁴ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\ninst✝³ : RingHomIsometric σ₂₃\ninst✝² : RingHomIsometric σ₁₃\ninst✝¹ : RingHomIsometric σ₁₂\nX : Type u_11\ninst✝ : TopologicalSpace X\nf : X → ContinuousLinearMap σ₁₂ E F\nhf : Continuous f\ng : ContinuousLinearMap σ₂₃ F G\n⊢ Continuous fun x => g.comp (f x)","decl":"theorem _root_.Continuous.const_clm_comp {X} [TopologicalSpace X] {f : X → E →SL[σ₁₂] F}\n    (hf : Continuous f) (g : F →SL[σ₂₃] G) :\n    Continuous (fun x => g.comp (f x) : X → E →SL[σ₁₃] G) :=\n  (compSL E F G σ₁₂ σ₂₃ g).continuous.comp hf\n\n-- Giving the implicit argument speeds up elaboration significantly\n"}
{"name":"Continuous.clm_comp_const","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝¹³ : SeminormedAddCommGroup E\ninst✝¹² : SeminormedAddCommGroup F\ninst✝¹¹ : SeminormedAddCommGroup G\ninst✝¹⁰ : NontriviallyNormedField 𝕜\ninst✝⁹ : NontriviallyNormedField 𝕜₂\ninst✝⁸ : NontriviallyNormedField 𝕜₃\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : NormedSpace 𝕜₂ F\ninst✝⁵ : NormedSpace 𝕜₃ G\nσ₁₂ : RingHom 𝕜 𝕜₂\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝⁴ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\ninst✝³ : RingHomIsometric σ₂₃\ninst✝² : RingHomIsometric σ₁₃\ninst✝¹ : RingHomIsometric σ₁₂\nX : Type u_11\ninst✝ : TopologicalSpace X\ng : X → ContinuousLinearMap σ₂₃ F G\nhg : Continuous g\nf : ContinuousLinearMap σ₁₂ E F\n⊢ Continuous fun x => (g x).comp f","decl":"theorem _root_.Continuous.clm_comp_const {X} [TopologicalSpace X] {g : X → F →SL[σ₂₃] G}\n    (hg : Continuous g) (f : E →SL[σ₁₂] F) :\n    Continuous (fun x => (g x).comp f : X → E →SL[σ₁₃] G) :=\n  (@ContinuousLinearMap.flip _ _ _ _ _ (E →SL[σ₁₃] G) _ _ _ _ _ _ _ _ _ _ _ _ _\n    (compSL E F G σ₁₂ σ₂₃) f).continuous.comp hg\n\n"}
{"name":"ContinuousLinearMap.norm_compL_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nFₗ : Type u_7\nGₗ : Type u_9\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup Fₗ\ninst✝⁴ : SeminormedAddCommGroup Gₗ\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜 Fₗ\ninst✝ : NormedSpace 𝕜 Gₗ\n⊢ LE.le (Norm.norm (ContinuousLinearMap.compL 𝕜 E Fₗ Gₗ)) 1","decl":"set_option maxSynthPendingDepth 2 in\ntheorem norm_compL_le : ‖compL 𝕜 E Fₗ Gₗ‖ ≤ 1 :=\n  norm_compSL_le _ _ _ _ _\n\n"}
{"name":"ContinuousLinearMap.compL_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nFₗ : Type u_7\nGₗ : Type u_9\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup Fₗ\ninst✝⁴ : SeminormedAddCommGroup Gₗ\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜 Fₗ\ninst✝ : NormedSpace 𝕜 Gₗ\nf : ContinuousLinearMap (RingHom.id 𝕜) Fₗ Gₗ\ng : ContinuousLinearMap (RingHom.id 𝕜) E Fₗ\n⊢ Eq (((ContinuousLinearMap.compL 𝕜 E Fₗ Gₗ) f) g) (f.comp g)","decl":"@[simp]\ntheorem compL_apply (f : Fₗ →L[𝕜] Gₗ) (g : E →L[𝕜] Fₗ) : compL 𝕜 E Fₗ Gₗ f g = f.comp g :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.precompR_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nEₗ : Type u_5\nFₗ : Type u_7\nGₗ : Type u_9\ninst✝⁸ : SeminormedAddCommGroup E\ninst✝⁷ : SeminormedAddCommGroup Eₗ\ninst✝⁶ : SeminormedAddCommGroup Fₗ\ninst✝⁵ : SeminormedAddCommGroup Gₗ\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedSpace 𝕜 Eₗ\ninst✝¹ : NormedSpace 𝕜 Fₗ\ninst✝ : NormedSpace 𝕜 Gₗ\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) Fₗ Gₗ)\na✝ : E\n⊢ Eq ((ContinuousLinearMap.precompR Eₗ L) a✝) ((ContinuousLinearMap.compL 𝕜 Eₗ Fₗ Gₗ) (L a✝))","decl":"/-- Apply `L(x,-)` pointwise to bilinear maps, as a continuous bilinear map -/\n@[simps! apply]\ndef precompR (L : E →L[𝕜] Fₗ →L[𝕜] Gₗ) : E →L[𝕜] (Eₗ →L[𝕜] Fₗ) →L[𝕜] Eₗ →L[𝕜] Gₗ :=\n  (compL 𝕜 Eₗ Fₗ Gₗ).comp L\n\n"}
{"name":"ContinuousLinearMap.precompL_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nEₗ : Type u_5\nFₗ : Type u_7\nGₗ : Type u_9\ninst✝⁸ : SeminormedAddCommGroup E\ninst✝⁷ : SeminormedAddCommGroup Eₗ\ninst✝⁶ : SeminormedAddCommGroup Fₗ\ninst✝⁵ : SeminormedAddCommGroup Gₗ\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedSpace 𝕜 Eₗ\ninst✝¹ : NormedSpace 𝕜 Fₗ\ninst✝ : NormedSpace 𝕜 Gₗ\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) Fₗ Gₗ)\nu : ContinuousLinearMap (RingHom.id 𝕜) Eₗ E\nf : Fₗ\ng : Eₗ\n⊢ Eq ((((ContinuousLinearMap.precompL Eₗ L) u) f) g) ((L (u g)) f)","decl":"@[simp] lemma precompL_apply (L : E →L[𝕜] Fₗ →L[𝕜] Gₗ) (u : Eₗ →L[𝕜] E) (f : Fₗ) (g : Eₗ) :\n    precompL Eₗ L u f g = L (u g) f := rfl\n\n"}
{"name":"ContinuousLinearMap.norm_precompR_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nEₗ : Type u_5\nFₗ : Type u_7\nGₗ : Type u_9\ninst✝⁸ : SeminormedAddCommGroup E\ninst✝⁷ : SeminormedAddCommGroup Eₗ\ninst✝⁶ : SeminormedAddCommGroup Fₗ\ninst✝⁵ : SeminormedAddCommGroup Gₗ\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedSpace 𝕜 Eₗ\ninst✝¹ : NormedSpace 𝕜 Fₗ\ninst✝ : NormedSpace 𝕜 Gₗ\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) Fₗ Gₗ)\n⊢ LE.le (Norm.norm (ContinuousLinearMap.precompR Eₗ L)) (Norm.norm L)","decl":"set_option maxSynthPendingDepth 2 in\ntheorem norm_precompR_le (L : E →L[𝕜] Fₗ →L[𝕜] Gₗ) : ‖precompR Eₗ L‖ ≤ ‖L‖ :=\n  calc\n    ‖precompR Eₗ L‖ ≤ ‖compL 𝕜 Eₗ Fₗ Gₗ‖ * ‖L‖ := opNorm_comp_le _ _\n    _ ≤ 1 * ‖L‖ := mul_le_mul_of_nonneg_right (norm_compL_le _ _ _ _) (norm_nonneg L)\n    _ = ‖L‖ := by rw [one_mul]\n\n"}
{"name":"ContinuousLinearMap.norm_precompL_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nEₗ : Type u_5\nFₗ : Type u_7\nGₗ : Type u_9\ninst✝⁸ : SeminormedAddCommGroup E\ninst✝⁷ : SeminormedAddCommGroup Eₗ\ninst✝⁶ : SeminormedAddCommGroup Fₗ\ninst✝⁵ : SeminormedAddCommGroup Gₗ\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedSpace 𝕜 Eₗ\ninst✝¹ : NormedSpace 𝕜 Fₗ\ninst✝ : NormedSpace 𝕜 Gₗ\nL : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) Fₗ Gₗ)\n⊢ LE.le (Norm.norm (ContinuousLinearMap.precompL Eₗ L)) (Norm.norm L)","decl":"set_option maxSynthPendingDepth 2 in\ntheorem norm_precompL_le (L : E →L[𝕜] Fₗ →L[𝕜] Gₗ) : ‖precompL Eₗ L‖ ≤ ‖L‖ := by\n  rw [precompL, opNorm_flip, ← opNorm_flip L]\n  exact norm_precompR_le _ L.flip\n\n"}
{"name":"ContinuousLinearMap.bilinearComp_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninst✝¹⁹ : SeminormedAddCommGroup E\ninst✝¹⁸ : SeminormedAddCommGroup F\ninst✝¹⁷ : SeminormedAddCommGroup G\ninst✝¹⁶ : NontriviallyNormedField 𝕜\ninst✝¹⁵ : NontriviallyNormedField 𝕜₂\ninst✝¹⁴ : NontriviallyNormedField 𝕜₃\ninst✝¹³ : NormedSpace 𝕜 E\ninst✝¹² : NormedSpace 𝕜₂ F\ninst✝¹¹ : NormedSpace 𝕜₃ G\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\nE' : Type u_11\nF' : Type u_12\ninst✝¹⁰ : SeminormedAddCommGroup E'\ninst✝⁹ : SeminormedAddCommGroup F'\n𝕜₁' : Type u_13\n𝕜₂' : Type u_14\ninst✝⁸ : NontriviallyNormedField 𝕜₁'\ninst✝⁷ : NontriviallyNormedField 𝕜₂'\ninst✝⁶ : NormedSpace 𝕜₁' E'\ninst✝⁵ : NormedSpace 𝕜₂' F'\nσ₁' : RingHom 𝕜₁' 𝕜\nσ₁₃' : RingHom 𝕜₁' 𝕜₃\nσ₂' : RingHom 𝕜₂' 𝕜₂\nσ₂₃' : RingHom 𝕜₂' 𝕜₃\ninst✝⁴ : RingHomCompTriple σ₁' σ₁₃ σ₁₃'\ninst✝³ : RingHomCompTriple σ₂' σ₂₃ σ₂₃'\ninst✝² : RingHomIsometric σ₂₃\ninst✝¹ : RingHomIsometric σ₁₃'\ninst✝ : RingHomIsometric σ₂₃'\nf : ContinuousLinearMap σ₁₃ E (ContinuousLinearMap σ₂₃ F G)\ngE : ContinuousLinearMap σ₁' E' E\ngF : ContinuousLinearMap σ₂' F' F\nx : E'\ny : F'\n⊢ Eq (((f.bilinearComp gE gF) x) y) ((f (gE x)) (gF y))","decl":"@[simp]\ntheorem bilinearComp_apply (f : E →SL[σ₁₃] F →SL[σ₂₃] G) (gE : E' →SL[σ₁'] E) (gF : F' →SL[σ₂'] F)\n    (x : E') (y : F') : f.bilinearComp gE gF x y = f (gE x) (gF y) :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_deriv₂","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nFₗ : Type u_7\nGₗ : Type u_9\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup Fₗ\ninst✝⁴ : SeminormedAddCommGroup Gₗ\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜 Fₗ\ninst✝ : NormedSpace 𝕜 Gₗ\nf : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) Fₗ Gₗ)\np : Prod E Fₗ\n⊢ Eq ⇑(f.deriv₂ p) fun q => HAdd.hAdd ((f p.1) q.2) ((f q.1) p.2)","decl":"@[simp]\ntheorem coe_deriv₂ (f : E →L[𝕜] Fₗ →L[𝕜] Gₗ) (p : E × Fₗ) :\n    ⇑(f.deriv₂ p) = fun q : E × Fₗ => f p.1 q.2 + f q.1 p.2 :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.map_add_add","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nFₗ : Type u_7\nGₗ : Type u_9\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup Fₗ\ninst✝⁴ : SeminormedAddCommGroup Gₗ\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜 Fₗ\ninst✝ : NormedSpace 𝕜 Gₗ\nf : ContinuousLinearMap (RingHom.id 𝕜) E (ContinuousLinearMap (RingHom.id 𝕜) Fₗ Gₗ)\nx x' : E\ny y' : Fₗ\n⊢ Eq ((f (HAdd.hAdd x x')) (HAdd.hAdd y y')) (HAdd.hAdd (HAdd.hAdd ((f x) y) ((f.deriv₂ { fst := x, snd := y }) { fst := x', snd := y' })) ((f x') y'))","decl":"theorem map_add_add (f : E →L[𝕜] Fₗ →L[𝕜] Gₗ) (x x' : E) (y y' : Fₗ) :\n    f (x + x') (y + y') = f x y + f.deriv₂ (x, y) (x', y') + f x' y' := by\n  simp only [map_add, add_apply, coe_deriv₂, add_assoc]\n  abel\n\n"}
{"name":"ContinuousLinearMap.norm_smulRight_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nFₗ : Type u_7\ninst✝⁴ : SeminormedAddCommGroup E\ninst✝³ : SeminormedAddCommGroup Fₗ\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜 Fₗ\nc : ContinuousLinearMap (RingHom.id 𝕜) E 𝕜\nf : Fₗ\n⊢ Eq (Norm.norm (c.smulRight f)) (HMul.hMul (Norm.norm c) (Norm.norm f))","decl":"/-- The norm of the tensor product of a scalar linear map and of an element of a normed space\nis the product of the norms. -/\n@[simp]\ntheorem norm_smulRight_apply (c : E →L[𝕜] 𝕜) (f : Fₗ) : ‖smulRight c f‖ = ‖c‖ * ‖f‖ := by\n  refine le_antisymm ?_ ?_\n  · refine opNorm_le_bound _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) fun x => ?_\n    calc\n      ‖c x • f‖ = ‖c x‖ * ‖f‖ := norm_smul _ _\n      _ ≤ ‖c‖ * ‖x‖ * ‖f‖ := mul_le_mul_of_nonneg_right (le_opNorm _ _) (norm_nonneg _)\n      _ = ‖c‖ * ‖f‖ * ‖x‖ := by ring\n  · obtain hf | hf := (norm_nonneg f).eq_or_gt\n    · simp [hf]\n    · rw [← le_div_iff₀ hf]\n      refine opNorm_le_bound _ (div_nonneg (norm_nonneg _) (norm_nonneg f)) fun x => ?_\n      rw [div_mul_eq_mul_div, le_div_iff₀ hf]\n      calc\n        ‖c x‖ * ‖f‖ = ‖c x • f‖ := (norm_smul _ _).symm\n        _ = ‖smulRight c f x‖ := rfl\n        _ ≤ ‖smulRight c f‖ * ‖x‖ := le_opNorm _ _\n\n"}
{"name":"ContinuousLinearMap.nnnorm_smulRight_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nFₗ : Type u_7\ninst✝⁴ : SeminormedAddCommGroup E\ninst✝³ : SeminormedAddCommGroup Fₗ\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜 Fₗ\nc : ContinuousLinearMap (RingHom.id 𝕜) E 𝕜\nf : Fₗ\n⊢ Eq (NNNorm.nnnorm (c.smulRight f)) (HMul.hMul (NNNorm.nnnorm c) (NNNorm.nnnorm f))","decl":"/-- The non-negative norm of the tensor product of a scalar linear map and of an element of a normed\nspace is the product of the non-negative norms. -/\n@[simp]\ntheorem nnnorm_smulRight_apply (c : E →L[𝕜] 𝕜) (f : Fₗ) : ‖smulRight c f‖₊ = ‖c‖₊ * ‖f‖₊ :=\n  NNReal.eq <| c.norm_smulRight_apply f\n\n"}
{"name":"ContinuousLinearMap.norm_smulRightL_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nFₗ : Type u_7\ninst✝⁴ : SeminormedAddCommGroup E\ninst✝³ : SeminormedAddCommGroup Fₗ\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜 Fₗ\nc : ContinuousLinearMap (RingHom.id 𝕜) E 𝕜\nf : Fₗ\n⊢ Eq (Norm.norm (((ContinuousLinearMap.smulRightL 𝕜 E Fₗ) c) f)) (HMul.hMul (Norm.norm c) (Norm.norm f))","decl":"@[simp]\ntheorem norm_smulRightL_apply (c : E →L[𝕜] 𝕜) (f : Fₗ) : ‖smulRightL 𝕜 E Fₗ c f‖ = ‖c‖ * ‖f‖ :=\n  norm_smulRight_apply c f\n\n"}
{"name":"ContinuousLinearMap.bilinearRestrictScalars_eq_restrictScalarsL_comp_restrictScalars","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nF : Type u_6\nG : Type u_8\n𝕜' : Type u_11\ninst✝¹⁴ : NontriviallyNormedField 𝕜\ninst✝¹³ : NontriviallyNormedField 𝕜'\ninst✝¹² : NormedAlgebra 𝕜 𝕜'\ninst✝¹¹ : SeminormedAddCommGroup E\ninst✝¹⁰ : NormedSpace 𝕜 E\ninst✝⁹ : NormedSpace 𝕜' E\ninst✝⁸ : IsScalarTower 𝕜 𝕜' E\ninst✝⁷ : SeminormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\ninst✝⁵ : NormedSpace 𝕜' F\ninst✝⁴ : IsScalarTower 𝕜 𝕜' F\ninst✝³ : SeminormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedSpace 𝕜' G\ninst✝ : IsScalarTower 𝕜 𝕜' G\nB : ContinuousLinearMap (RingHom.id 𝕜') E (ContinuousLinearMap (RingHom.id 𝕜') F G)\n⊢ Eq (ContinuousLinearMap.bilinearRestrictScalars 𝕜 B) ((ContinuousLinearMap.restrictScalarsL 𝕜' F G 𝕜 𝕜).comp (ContinuousLinearMap.restrictScalars 𝕜 B))","decl":"theorem bilinearRestrictScalars_eq_restrictScalarsL_comp_restrictScalars :\n    B.bilinearRestrictScalars 𝕜 = (restrictScalarsL 𝕜' F G 𝕜 𝕜).comp (B.restrictScalars 𝕜) := rfl\n\n"}
{"name":"ContinuousLinearMap.bilinearRestrictScalars_eq_restrictScalars_restrictScalarsL_comp","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nF : Type u_6\nG : Type u_8\n𝕜' : Type u_11\ninst✝¹⁴ : NontriviallyNormedField 𝕜\ninst✝¹³ : NontriviallyNormedField 𝕜'\ninst✝¹² : NormedAlgebra 𝕜 𝕜'\ninst✝¹¹ : SeminormedAddCommGroup E\ninst✝¹⁰ : NormedSpace 𝕜 E\ninst✝⁹ : NormedSpace 𝕜' E\ninst✝⁸ : IsScalarTower 𝕜 𝕜' E\ninst✝⁷ : SeminormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\ninst✝⁵ : NormedSpace 𝕜' F\ninst✝⁴ : IsScalarTower 𝕜 𝕜' F\ninst✝³ : SeminormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedSpace 𝕜' G\ninst✝ : IsScalarTower 𝕜 𝕜' G\nB : ContinuousLinearMap (RingHom.id 𝕜') E (ContinuousLinearMap (RingHom.id 𝕜') F G)\n⊢ Eq (ContinuousLinearMap.bilinearRestrictScalars 𝕜 B) (ContinuousLinearMap.restrictScalars 𝕜 ((ContinuousLinearMap.restrictScalarsL 𝕜' F G 𝕜 𝕜').comp B))","decl":"theorem bilinearRestrictScalars_eq_restrictScalars_restrictScalarsL_comp :\n    B.bilinearRestrictScalars 𝕜 = restrictScalars 𝕜 ((restrictScalarsL 𝕜' F G 𝕜 𝕜').comp B) := rfl\n\n"}
{"name":"ContinuousLinearMap.bilinearRestrictScalars_apply_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nF : Type u_6\nG : Type u_8\n𝕜' : Type u_11\ninst✝¹⁴ : NontriviallyNormedField 𝕜\ninst✝¹³ : NontriviallyNormedField 𝕜'\ninst✝¹² : NormedAlgebra 𝕜 𝕜'\ninst✝¹¹ : SeminormedAddCommGroup E\ninst✝¹⁰ : NormedSpace 𝕜 E\ninst✝⁹ : NormedSpace 𝕜' E\ninst✝⁸ : IsScalarTower 𝕜 𝕜' E\ninst✝⁷ : SeminormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\ninst✝⁵ : NormedSpace 𝕜' F\ninst✝⁴ : IsScalarTower 𝕜 𝕜' F\ninst✝³ : SeminormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedSpace 𝕜' G\ninst✝ : IsScalarTower 𝕜 𝕜' G\nB : ContinuousLinearMap (RingHom.id 𝕜') E (ContinuousLinearMap (RingHom.id 𝕜') F G)\nx : E\ny : F\n⊢ Eq (((ContinuousLinearMap.bilinearRestrictScalars 𝕜 B) x) y) ((B x) y)","decl":"variable (𝕜) in\n@[simp]\ntheorem bilinearRestrictScalars_apply_apply : (B.bilinearRestrictScalars 𝕜) x y = B x y := rfl\n\n"}
{"name":"ContinuousLinearMap.norm_bilinearRestrictScalars","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nF : Type u_6\nG : Type u_8\n𝕜' : Type u_11\ninst✝¹⁴ : NontriviallyNormedField 𝕜\ninst✝¹³ : NontriviallyNormedField 𝕜'\ninst✝¹² : NormedAlgebra 𝕜 𝕜'\ninst✝¹¹ : SeminormedAddCommGroup E\ninst✝¹⁰ : NormedSpace 𝕜 E\ninst✝⁹ : NormedSpace 𝕜' E\ninst✝⁸ : IsScalarTower 𝕜 𝕜' E\ninst✝⁷ : SeminormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\ninst✝⁵ : NormedSpace 𝕜' F\ninst✝⁴ : IsScalarTower 𝕜 𝕜' F\ninst✝³ : SeminormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedSpace 𝕜' G\ninst✝ : IsScalarTower 𝕜 𝕜' G\nB : ContinuousLinearMap (RingHom.id 𝕜') E (ContinuousLinearMap (RingHom.id 𝕜') F G)\n⊢ Eq (Norm.norm (ContinuousLinearMap.bilinearRestrictScalars 𝕜 B)) (Norm.norm B)","decl":"@[simp]\ntheorem norm_bilinearRestrictScalars : ‖B.bilinearRestrictScalars 𝕜‖ = ‖B‖ := rfl\n\n"}
