{"name":"ContinuousLinearMap.opNorm_ext","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœâ¹ : SeminormedAddCommGroup E\ninstâœâ¸ : SeminormedAddCommGroup F\ninstâœâ· : SeminormedAddCommGroup G\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ´ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedSpace ğ•œâ‚‚ F\ninstâœÂ¹ : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœ : RingHomIsometric Ïƒâ‚â‚ƒ\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\ng : ContinuousLinearMap Ïƒâ‚â‚ƒ E G\nh : âˆ€ (x : E), Eq (Norm.norm (f x)) (Norm.norm (g x))\nâŠ¢ Eq (Norm.norm f) (Norm.norm g)","decl":"theorem opNorm_ext [RingHomIsometric Ïƒâ‚â‚ƒ] (f : E â†’SL[Ïƒâ‚â‚‚] F) (g : E â†’SL[Ïƒâ‚â‚ƒ] G)\n    (h : âˆ€ x, â€–f xâ€– = â€–g xâ€–) : â€–fâ€– = â€–gâ€– :=\n  opNorm_eq_of_bounds (norm_nonneg _)\n    (fun x => by\n      rw [h x]\n      exact le_opNorm _ _)\n    fun c hc hâ‚‚ =>\n    opNorm_le_bound _ hc fun z => by\n      rw [â† h z]\n      exact hâ‚‚ z\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_le_boundâ‚‚","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœâ¹ : SeminormedAddCommGroup E\ninstâœâ¸ : SeminormedAddCommGroup F\ninstâœâ· : SeminormedAddCommGroup G\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ´ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedSpace ğ•œâ‚‚ F\ninstâœÂ¹ : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœ : RingHomIsometric Ïƒâ‚‚â‚ƒ\nf : ContinuousLinearMap Ïƒâ‚â‚ƒ E (ContinuousLinearMap Ïƒâ‚‚â‚ƒ F G)\nC : Real\nh0 : LE.le 0 C\nhC : âˆ€ (x : E) (y : F), LE.le (Norm.norm ((f x) y)) (HMul.hMul (HMul.hMul C (Norm.norm x)) (Norm.norm y))\nâŠ¢ LE.le (Norm.norm f) C","decl":"theorem opNorm_le_boundâ‚‚ (f : E â†’SL[Ïƒâ‚â‚ƒ] F â†’SL[Ïƒâ‚‚â‚ƒ] G) {C : â„} (h0 : 0 â‰¤ C)\n    (hC : âˆ€ x y, â€–f x yâ€– â‰¤ C * â€–xâ€– * â€–yâ€–) : â€–fâ€– â‰¤ C :=\n  f.opNorm_le_bound h0 fun x => (f x).opNorm_le_bound (mul_nonneg h0 (norm_nonneg _)) <| hC x\n\n\n"}
{"name":"ContinuousLinearMap.le_opNormâ‚‚","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœÂ¹â° : SeminormedAddCommGroup E\ninstâœâ¹ : SeminormedAddCommGroup F\ninstâœâ¸ : SeminormedAddCommGroup G\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâµ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedSpace ğ•œâ‚‚ F\ninstâœÂ² : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚‚â‚ƒ\ninstâœ : RingHomIsometric Ïƒâ‚â‚ƒ\nf : ContinuousLinearMap Ïƒâ‚â‚ƒ E (ContinuousLinearMap Ïƒâ‚‚â‚ƒ F G)\nx : E\ny : F\nâŠ¢ LE.le (Norm.norm ((f x) y)) (HMul.hMul (HMul.hMul (Norm.norm f) (Norm.norm x)) (Norm.norm y))","decl":"theorem le_opNormâ‚‚ [RingHomIsometric Ïƒâ‚â‚ƒ] (f : E â†’SL[Ïƒâ‚â‚ƒ] F â†’SL[Ïƒâ‚‚â‚ƒ] G) (x : E) (y : F) :\n    â€–f x yâ€– â‰¤ â€–fâ€– * â€–xâ€– * â€–yâ€– :=\n  (f x).le_of_opNorm_le (f.le_opNorm x) y\n\n\n"}
{"name":"ContinuousLinearMap.le_of_opNormâ‚‚_le_of_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœÂ¹â° : SeminormedAddCommGroup E\ninstâœâ¹ : SeminormedAddCommGroup F\ninstâœâ¸ : SeminormedAddCommGroup G\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâµ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedSpace ğ•œâ‚‚ F\ninstâœÂ² : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚‚â‚ƒ\ninstâœ : RingHomIsometric Ïƒâ‚â‚ƒ\nf : ContinuousLinearMap Ïƒâ‚â‚ƒ E (ContinuousLinearMap Ïƒâ‚‚â‚ƒ F G)\nx : E\ny : F\na b c : Real\nhf : LE.le (Norm.norm f) a\nhx : LE.le (Norm.norm x) b\nhy : LE.le (Norm.norm y) c\nâŠ¢ LE.le (Norm.norm ((f x) y)) (HMul.hMul (HMul.hMul a b) c)","decl":"theorem le_of_opNormâ‚‚_le_of_le [RingHomIsometric Ïƒâ‚â‚ƒ] (f : E â†’SL[Ïƒâ‚â‚ƒ] F â†’SL[Ïƒâ‚‚â‚ƒ] G) {x : E} {y : F}\n    {a b c : â„} (hf : â€–fâ€– â‰¤ a) (hx : â€–xâ€– â‰¤ b) (hy : â€–yâ€– â‰¤ c) :\n    â€–f x yâ€– â‰¤ a * b * c :=\n  (f x).le_of_opNorm_le_of_le (f.le_of_opNorm_le_of_le hf hx) hy\n\n\n"}
{"name":"LinearMap.norm_mkContinuousâ‚‚_aux","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœâ¸ : SeminormedAddCommGroup E\ninstâœâ· : SeminormedAddCommGroup F\ninstâœâ¶ : SeminormedAddCommGroup G\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\ninstâœ : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\nf : LinearMap Ïƒâ‚â‚ƒ E (LinearMap Ïƒâ‚‚â‚ƒ F G)\nC : Real\nh : âˆ€ (x : E) (y : F), LE.le (Norm.norm ((f x) y)) (HMul.hMul (HMul.hMul C (Norm.norm x)) (Norm.norm y))\nx : E\nâŠ¢ LE.le (Norm.norm ((f x).mkContinuous (HMul.hMul C (Norm.norm x)) â‹¯)) (HMul.hMul (Max.max C 0) (Norm.norm x))","decl":"lemma norm_mkContinuousâ‚‚_aux (f : E â†’â‚›â‚—[Ïƒâ‚â‚ƒ] F â†’â‚›â‚—[Ïƒâ‚‚â‚ƒ] G) (C : â„)\n    (h : âˆ€ x y, â€–f x yâ€– â‰¤ C * â€–xâ€– * â€–yâ€–) (x : E) :\n    â€–(f x).mkContinuous (C * â€–xâ€–) (h x)â€– â‰¤ max C 0 * â€–xâ€– :=\n  (mkContinuous_norm_le' (f x) (h x)).trans_eq <| by\n    rw [max_mul_of_nonneg _ _ (norm_nonneg x), zero_mul]\n\n"}
{"name":"LinearMap.mkContinuousâ‚‚_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœâ¹ : SeminormedAddCommGroup E\ninstâœâ¸ : SeminormedAddCommGroup F\ninstâœâ· : SeminormedAddCommGroup G\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ´ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedSpace ğ•œâ‚‚ F\ninstâœÂ¹ : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœ : RingHomIsometric Ïƒâ‚‚â‚ƒ\nf : LinearMap Ïƒâ‚â‚ƒ E (LinearMap Ïƒâ‚‚â‚ƒ F G)\nC : Real\nhC : âˆ€ (x : E) (y : F), LE.le (Norm.norm ((f x) y)) (HMul.hMul (HMul.hMul C (Norm.norm x)) (Norm.norm y))\nx : E\ny : F\nâŠ¢ Eq (((f.mkContinuousâ‚‚ C hC) x) y) ((f x) y)","decl":"@[simp]\ntheorem mkContinuousâ‚‚_apply (f : E â†’â‚›â‚—[Ïƒâ‚â‚ƒ] F â†’â‚›â‚—[Ïƒâ‚‚â‚ƒ] G) {C : â„}\n    (hC : âˆ€ x y, â€–f x yâ€– â‰¤ C * â€–xâ€– * â€–yâ€–) (x : E) (y : F) : f.mkContinuousâ‚‚ C hC x y = f x y :=\n  rfl\n\n"}
{"name":"LinearMap.mkContinuousâ‚‚_norm_le'","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœâ¹ : SeminormedAddCommGroup E\ninstâœâ¸ : SeminormedAddCommGroup F\ninstâœâ· : SeminormedAddCommGroup G\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ´ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedSpace ğ•œâ‚‚ F\ninstâœÂ¹ : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœ : RingHomIsometric Ïƒâ‚‚â‚ƒ\nf : LinearMap Ïƒâ‚â‚ƒ E (LinearMap Ïƒâ‚‚â‚ƒ F G)\nC : Real\nhC : âˆ€ (x : E) (y : F), LE.le (Norm.norm ((f x) y)) (HMul.hMul (HMul.hMul C (Norm.norm x)) (Norm.norm y))\nâŠ¢ LE.le (Norm.norm (f.mkContinuousâ‚‚ C hC)) (Max.max C 0)","decl":"theorem mkContinuousâ‚‚_norm_le' (f : E â†’â‚›â‚—[Ïƒâ‚â‚ƒ] F â†’â‚›â‚—[Ïƒâ‚‚â‚ƒ] G) {C : â„}\n    (hC : âˆ€ x y, â€–f x yâ€– â‰¤ C * â€–xâ€– * â€–yâ€–) : â€–f.mkContinuousâ‚‚ C hCâ€– â‰¤ max C 0 :=\n  mkContinuous_norm_le _ (le_max_iff.2 <| Or.inr le_rfl) (norm_mkContinuousâ‚‚_aux f C hC)\n\n"}
{"name":"LinearMap.mkContinuousâ‚‚_norm_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœâ¹ : SeminormedAddCommGroup E\ninstâœâ¸ : SeminormedAddCommGroup F\ninstâœâ· : SeminormedAddCommGroup G\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ´ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedSpace ğ•œâ‚‚ F\ninstâœÂ¹ : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœ : RingHomIsometric Ïƒâ‚‚â‚ƒ\nf : LinearMap Ïƒâ‚â‚ƒ E (LinearMap Ïƒâ‚‚â‚ƒ F G)\nC : Real\nh0 : LE.le 0 C\nhC : âˆ€ (x : E) (y : F), LE.le (Norm.norm ((f x) y)) (HMul.hMul (HMul.hMul C (Norm.norm x)) (Norm.norm y))\nâŠ¢ LE.le (Norm.norm (f.mkContinuousâ‚‚ C hC)) C","decl":"theorem mkContinuousâ‚‚_norm_le (f : E â†’â‚›â‚—[Ïƒâ‚â‚ƒ] F â†’â‚›â‚—[Ïƒâ‚‚â‚ƒ] G) {C : â„} (h0 : 0 â‰¤ C)\n    (hC : âˆ€ x y, â€–f x yâ€– â‰¤ C * â€–xâ€– * â€–yâ€–) : â€–f.mkContinuousâ‚‚ C hCâ€– â‰¤ C :=\n  (f.mkContinuousâ‚‚_norm_le' hC).trans_eq <| max_eq_left h0\n\n"}
{"name":"ContinuousLinearMap.flip_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœÂ¹â° : SeminormedAddCommGroup E\ninstâœâ¹ : SeminormedAddCommGroup F\ninstâœâ¸ : SeminormedAddCommGroup G\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâµ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedSpace ğ•œâ‚‚ F\ninstâœÂ² : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚‚â‚ƒ\ninstâœ : RingHomIsometric Ïƒâ‚â‚ƒ\nf : ContinuousLinearMap Ïƒâ‚â‚ƒ E (ContinuousLinearMap Ïƒâ‚‚â‚ƒ F G)\nx : E\ny : F\nâŠ¢ Eq ((f.flip y) x) ((f x) y)","decl":"@[simp]\ntheorem flip_apply (f : E â†’SL[Ïƒâ‚â‚ƒ] F â†’SL[Ïƒâ‚‚â‚ƒ] G) (x : E) (y : F) : f.flip y x = f x y :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.flip_flip","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœÂ¹â° : SeminormedAddCommGroup E\ninstâœâ¹ : SeminormedAddCommGroup F\ninstâœâ¸ : SeminormedAddCommGroup G\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâµ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedSpace ğ•œâ‚‚ F\ninstâœÂ² : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚‚â‚ƒ\ninstâœ : RingHomIsometric Ïƒâ‚â‚ƒ\nf : ContinuousLinearMap Ïƒâ‚â‚ƒ E (ContinuousLinearMap Ïƒâ‚‚â‚ƒ F G)\nâŠ¢ Eq f.flip.flip f","decl":"@[simp]\ntheorem flip_flip (f : E â†’SL[Ïƒâ‚â‚ƒ] F â†’SL[Ïƒâ‚‚â‚ƒ] G) : f.flip.flip = f := by\n  ext\n  rfl\n\n"}
{"name":"ContinuousLinearMap.opNorm_flip","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœÂ¹â° : SeminormedAddCommGroup E\ninstâœâ¹ : SeminormedAddCommGroup F\ninstâœâ¸ : SeminormedAddCommGroup G\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâµ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedSpace ğ•œâ‚‚ F\ninstâœÂ² : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚‚â‚ƒ\ninstâœ : RingHomIsometric Ïƒâ‚â‚ƒ\nf : ContinuousLinearMap Ïƒâ‚â‚ƒ E (ContinuousLinearMap Ïƒâ‚‚â‚ƒ F G)\nâŠ¢ Eq (Norm.norm f.flip) (Norm.norm f)","decl":"@[simp]\ntheorem opNorm_flip (f : E â†’SL[Ïƒâ‚â‚ƒ] F â†’SL[Ïƒâ‚‚â‚ƒ] G) : â€–f.flipâ€– = â€–fâ€– :=\n  le_antisymm (by simpa only [flip_flip] using le_norm_flip f.flip) (le_norm_flip f)\n\n\n"}
{"name":"ContinuousLinearMap.flip_add","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœÂ¹â° : SeminormedAddCommGroup E\ninstâœâ¹ : SeminormedAddCommGroup F\ninstâœâ¸ : SeminormedAddCommGroup G\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâµ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedSpace ğ•œâ‚‚ F\ninstâœÂ² : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚‚â‚ƒ\ninstâœ : RingHomIsometric Ïƒâ‚â‚ƒ\nf g : ContinuousLinearMap Ïƒâ‚â‚ƒ E (ContinuousLinearMap Ïƒâ‚‚â‚ƒ F G)\nâŠ¢ Eq (HAdd.hAdd f g).flip (HAdd.hAdd f.flip g.flip)","decl":"@[simp]\ntheorem flip_add (f g : E â†’SL[Ïƒâ‚â‚ƒ] F â†’SL[Ïƒâ‚‚â‚ƒ] G) : (f + g).flip = f.flip + g.flip :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.flip_smul","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœÂ¹â° : SeminormedAddCommGroup E\ninstâœâ¹ : SeminormedAddCommGroup F\ninstâœâ¸ : SeminormedAddCommGroup G\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâµ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedSpace ğ•œâ‚‚ F\ninstâœÂ² : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚‚â‚ƒ\ninstâœ : RingHomIsometric Ïƒâ‚â‚ƒ\nc : ğ•œâ‚ƒ\nf : ContinuousLinearMap Ïƒâ‚â‚ƒ E (ContinuousLinearMap Ïƒâ‚‚â‚ƒ F G)\nâŠ¢ Eq (HSMul.hSMul c f).flip (HSMul.hSMul c f.flip)","decl":"@[simp]\ntheorem flip_smul (c : ğ•œâ‚ƒ) (f : E â†’SL[Ïƒâ‚â‚ƒ] F â†’SL[Ïƒâ‚‚â‚ƒ] G) : (c â€¢ f).flip = c â€¢ f.flip :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.flipâ‚—áµ¢'_symm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœÂ¹â° : SeminormedAddCommGroup E\ninstâœâ¹ : SeminormedAddCommGroup F\ninstâœâ¸ : SeminormedAddCommGroup G\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâµ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedSpace ğ•œâ‚‚ F\ninstâœÂ² : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚‚â‚ƒ\ninstâœ : RingHomIsometric Ïƒâ‚â‚ƒ\nâŠ¢ Eq (ContinuousLinearMap.flipâ‚—áµ¢' E F G Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ).symm (ContinuousLinearMap.flipâ‚—áµ¢' F E G Ïƒâ‚â‚ƒ Ïƒâ‚‚â‚ƒ)","decl":"@[simp]\ntheorem flipâ‚—áµ¢'_symm : (flipâ‚—áµ¢' E F G Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ).symm = flipâ‚—áµ¢' F E G Ïƒâ‚â‚ƒ Ïƒâ‚‚â‚ƒ :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_flipâ‚—áµ¢'","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœÂ¹â° : SeminormedAddCommGroup E\ninstâœâ¹ : SeminormedAddCommGroup F\ninstâœâ¸ : SeminormedAddCommGroup G\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâµ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedSpace ğ•œâ‚‚ F\ninstâœÂ² : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚‚â‚ƒ\ninstâœ : RingHomIsometric Ïƒâ‚â‚ƒ\nâŠ¢ Eq (â‡‘(ContinuousLinearMap.flipâ‚—áµ¢' E F G Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ)) ContinuousLinearMap.flip","decl":"@[simp]\ntheorem coe_flipâ‚—áµ¢' : â‡‘(flipâ‚—áµ¢' E F G Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ) = flip :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.flipâ‚—áµ¢_symm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nFâ‚— : Type u_7\nGâ‚— : Type u_9\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup Fâ‚—\ninstâœâ´ : SeminormedAddCommGroup Gâ‚—\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œ Fâ‚—\ninstâœ : NormedSpace ğ•œ Gâ‚—\nâŠ¢ Eq (ContinuousLinearMap.flipâ‚—áµ¢ ğ•œ E Fâ‚— Gâ‚—).symm (ContinuousLinearMap.flipâ‚—áµ¢ ğ•œ Fâ‚— E Gâ‚—)","decl":"@[simp]\ntheorem flipâ‚—áµ¢_symm : (flipâ‚—áµ¢ ğ•œ E Fâ‚— Gâ‚—).symm = flipâ‚—áµ¢ ğ•œ Fâ‚— E Gâ‚— :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_flipâ‚—áµ¢","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nFâ‚— : Type u_7\nGâ‚— : Type u_9\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup Fâ‚—\ninstâœâ´ : SeminormedAddCommGroup Gâ‚—\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œ Fâ‚—\ninstâœ : NormedSpace ğ•œ Gâ‚—\nâŠ¢ Eq (â‡‘(ContinuousLinearMap.flipâ‚—áµ¢ ğ•œ E Fâ‚— Gâ‚—)) ContinuousLinearMap.flip","decl":"@[simp]\ntheorem coe_flipâ‚—áµ¢ : â‡‘(flipâ‚—áµ¢ ğ•œ E Fâ‚— Gâ‚—) = flip :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.apply_apply'","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_6\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nv : E\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Eq (((ContinuousLinearMap.apply' F Ïƒâ‚â‚‚) v) f) (f v)","decl":"@[simp]\ntheorem apply_apply' (v : E) (f : E â†’SL[Ïƒâ‚â‚‚] F) : apply' F Ïƒâ‚â‚‚ v f = f v :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.apply_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nFâ‚— : Type u_7\ninstâœâ´ : SeminormedAddCommGroup E\ninstâœÂ³ : SeminormedAddCommGroup Fâ‚—\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œ Fâ‚—\nv : E\nf : ContinuousLinearMap (RingHom.id ğ•œ) E Fâ‚—\nâŠ¢ Eq (((ContinuousLinearMap.apply ğ•œ Fâ‚—) v) f) (f v)","decl":"@[simp]\ntheorem apply_apply (v : E) (f : E â†’L[ğ•œ] Fâ‚—) : apply ğ•œ Fâ‚— v f = f v :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.norm_compSL_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœÂ¹Â² : SeminormedAddCommGroup E\ninstâœÂ¹Â¹ : SeminormedAddCommGroup F\ninstâœÂ¹â° : SeminormedAddCommGroup G\ninstâœâ¹ : NontriviallyNormedField ğ•œ\ninstâœâ¸ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ· : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedSpace ğ•œâ‚‚ F\ninstâœâ´ : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœÂ³ : RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ\ninstâœÂ² : RingHomIsometric Ïƒâ‚‚â‚ƒ\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚ƒ\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nâŠ¢ LE.le (Norm.norm (ContinuousLinearMap.compSL E F G Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ)) 1","decl":"set_option maxSynthPendingDepth 2 in\ntheorem norm_compSL_le : â€–compSL E F G Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒâ€– â‰¤ 1 :=\n  LinearMap.mkContinuousâ‚‚_norm_le _ zero_le_one _\n\n"}
{"name":"ContinuousLinearMap.compSL_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœÂ¹Â² : SeminormedAddCommGroup E\ninstâœÂ¹Â¹ : SeminormedAddCommGroup F\ninstâœÂ¹â° : SeminormedAddCommGroup G\ninstâœâ¹ : NontriviallyNormedField ğ•œ\ninstâœâ¸ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ· : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedSpace ğ•œâ‚‚ F\ninstâœâ´ : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœÂ³ : RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ\ninstâœÂ² : RingHomIsometric Ïƒâ‚‚â‚ƒ\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚ƒ\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚‚â‚ƒ F G\ng : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Eq (((ContinuousLinearMap.compSL E F G Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ) f) g) (f.comp g)","decl":"@[simp]\ntheorem compSL_apply (f : F â†’SL[Ïƒâ‚‚â‚ƒ] G) (g : E â†’SL[Ïƒâ‚â‚‚] F) : compSL E F G Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ f g = f.comp g :=\n  rfl\n\n"}
{"name":"Continuous.const_clm_comp","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœÂ¹Â³ : SeminormedAddCommGroup E\ninstâœÂ¹Â² : SeminormedAddCommGroup F\ninstâœÂ¹Â¹ : SeminormedAddCommGroup G\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ¸ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : NormedSpace ğ•œâ‚‚ F\ninstâœâµ : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœâ´ : RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ\ninstâœÂ³ : RingHomIsometric Ïƒâ‚‚â‚ƒ\ninstâœÂ² : RingHomIsometric Ïƒâ‚â‚ƒ\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\nX : Type u_11\ninstâœ : TopologicalSpace X\nf : X â†’ ContinuousLinearMap Ïƒâ‚â‚‚ E F\nhf : Continuous f\ng : ContinuousLinearMap Ïƒâ‚‚â‚ƒ F G\nâŠ¢ Continuous fun x => g.comp (f x)","decl":"theorem _root_.Continuous.const_clm_comp {X} [TopologicalSpace X] {f : X â†’ E â†’SL[Ïƒâ‚â‚‚] F}\n    (hf : Continuous f) (g : F â†’SL[Ïƒâ‚‚â‚ƒ] G) :\n    Continuous (fun x => g.comp (f x) : X â†’ E â†’SL[Ïƒâ‚â‚ƒ] G) :=\n  (compSL E F G Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ g).continuous.comp hf\n\n-- Giving the implicit argument speeds up elaboration significantly\n"}
{"name":"Continuous.clm_comp_const","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœÂ¹Â³ : SeminormedAddCommGroup E\ninstâœÂ¹Â² : SeminormedAddCommGroup F\ninstâœÂ¹Â¹ : SeminormedAddCommGroup G\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\ninstâœâ¹ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ¸ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : NormedSpace ğ•œâ‚‚ F\ninstâœâµ : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœâ´ : RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ\ninstâœÂ³ : RingHomIsometric Ïƒâ‚‚â‚ƒ\ninstâœÂ² : RingHomIsometric Ïƒâ‚â‚ƒ\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\nX : Type u_11\ninstâœ : TopologicalSpace X\ng : X â†’ ContinuousLinearMap Ïƒâ‚‚â‚ƒ F G\nhg : Continuous g\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Continuous fun x => (g x).comp f","decl":"theorem _root_.Continuous.clm_comp_const {X} [TopologicalSpace X] {g : X â†’ F â†’SL[Ïƒâ‚‚â‚ƒ] G}\n    (hg : Continuous g) (f : E â†’SL[Ïƒâ‚â‚‚] F) :\n    Continuous (fun x => (g x).comp f : X â†’ E â†’SL[Ïƒâ‚â‚ƒ] G) :=\n  (@ContinuousLinearMap.flip _ _ _ _ _ (E â†’SL[Ïƒâ‚â‚ƒ] G) _ _ _ _ _ _ _ _ _ _ _ _ _\n    (compSL E F G Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ) f).continuous.comp hg\n\n"}
{"name":"ContinuousLinearMap.norm_compL_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nFâ‚— : Type u_7\nGâ‚— : Type u_9\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup Fâ‚—\ninstâœâ´ : SeminormedAddCommGroup Gâ‚—\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œ Fâ‚—\ninstâœ : NormedSpace ğ•œ Gâ‚—\nâŠ¢ LE.le (Norm.norm (ContinuousLinearMap.compL ğ•œ E Fâ‚— Gâ‚—)) 1","decl":"set_option maxSynthPendingDepth 2 in\ntheorem norm_compL_le : â€–compL ğ•œ E Fâ‚— Gâ‚—â€– â‰¤ 1 :=\n  norm_compSL_le _ _ _ _ _\n\n"}
{"name":"ContinuousLinearMap.compL_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nFâ‚— : Type u_7\nGâ‚— : Type u_9\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup Fâ‚—\ninstâœâ´ : SeminormedAddCommGroup Gâ‚—\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œ Fâ‚—\ninstâœ : NormedSpace ğ•œ Gâ‚—\nf : ContinuousLinearMap (RingHom.id ğ•œ) Fâ‚— Gâ‚—\ng : ContinuousLinearMap (RingHom.id ğ•œ) E Fâ‚—\nâŠ¢ Eq (((ContinuousLinearMap.compL ğ•œ E Fâ‚— Gâ‚—) f) g) (f.comp g)","decl":"@[simp]\ntheorem compL_apply (f : Fâ‚— â†’L[ğ•œ] Gâ‚—) (g : E â†’L[ğ•œ] Fâ‚—) : compL ğ•œ E Fâ‚— Gâ‚— f g = f.comp g :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.precompR_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nEâ‚— : Type u_5\nFâ‚— : Type u_7\nGâ‚— : Type u_9\ninstâœâ¸ : SeminormedAddCommGroup E\ninstâœâ· : SeminormedAddCommGroup Eâ‚—\ninstâœâ¶ : SeminormedAddCommGroup Fâ‚—\ninstâœâµ : SeminormedAddCommGroup Gâ‚—\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedSpace ğ•œ Eâ‚—\ninstâœÂ¹ : NormedSpace ğ•œ Fâ‚—\ninstâœ : NormedSpace ğ•œ Gâ‚—\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) Fâ‚— Gâ‚—)\naâœ : E\nâŠ¢ Eq ((ContinuousLinearMap.precompR Eâ‚— L) aâœ) ((ContinuousLinearMap.compL ğ•œ Eâ‚— Fâ‚— Gâ‚—) (L aâœ))","decl":"/-- Apply `L(x,-)` pointwise to bilinear maps, as a continuous bilinear map -/\n@[simps! apply]\ndef precompR (L : E â†’L[ğ•œ] Fâ‚— â†’L[ğ•œ] Gâ‚—) : E â†’L[ğ•œ] (Eâ‚— â†’L[ğ•œ] Fâ‚—) â†’L[ğ•œ] Eâ‚— â†’L[ğ•œ] Gâ‚— :=\n  (compL ğ•œ Eâ‚— Fâ‚— Gâ‚—).comp L\n\n"}
{"name":"ContinuousLinearMap.precompL_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nEâ‚— : Type u_5\nFâ‚— : Type u_7\nGâ‚— : Type u_9\ninstâœâ¸ : SeminormedAddCommGroup E\ninstâœâ· : SeminormedAddCommGroup Eâ‚—\ninstâœâ¶ : SeminormedAddCommGroup Fâ‚—\ninstâœâµ : SeminormedAddCommGroup Gâ‚—\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedSpace ğ•œ Eâ‚—\ninstâœÂ¹ : NormedSpace ğ•œ Fâ‚—\ninstâœ : NormedSpace ğ•œ Gâ‚—\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) Fâ‚— Gâ‚—)\nu : ContinuousLinearMap (RingHom.id ğ•œ) Eâ‚— E\nf : Fâ‚—\ng : Eâ‚—\nâŠ¢ Eq ((((ContinuousLinearMap.precompL Eâ‚— L) u) f) g) ((L (u g)) f)","decl":"@[simp] lemma precompL_apply (L : E â†’L[ğ•œ] Fâ‚— â†’L[ğ•œ] Gâ‚—) (u : Eâ‚— â†’L[ğ•œ] E) (f : Fâ‚—) (g : Eâ‚—) :\n    precompL Eâ‚— L u f g = L (u g) f := rfl\n\n"}
{"name":"ContinuousLinearMap.norm_precompR_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nEâ‚— : Type u_5\nFâ‚— : Type u_7\nGâ‚— : Type u_9\ninstâœâ¸ : SeminormedAddCommGroup E\ninstâœâ· : SeminormedAddCommGroup Eâ‚—\ninstâœâ¶ : SeminormedAddCommGroup Fâ‚—\ninstâœâµ : SeminormedAddCommGroup Gâ‚—\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedSpace ğ•œ Eâ‚—\ninstâœÂ¹ : NormedSpace ğ•œ Fâ‚—\ninstâœ : NormedSpace ğ•œ Gâ‚—\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) Fâ‚— Gâ‚—)\nâŠ¢ LE.le (Norm.norm (ContinuousLinearMap.precompR Eâ‚— L)) (Norm.norm L)","decl":"set_option maxSynthPendingDepth 2 in\ntheorem norm_precompR_le (L : E â†’L[ğ•œ] Fâ‚— â†’L[ğ•œ] Gâ‚—) : â€–precompR Eâ‚— Lâ€– â‰¤ â€–Lâ€– :=\n  calc\n    â€–precompR Eâ‚— Lâ€– â‰¤ â€–compL ğ•œ Eâ‚— Fâ‚— Gâ‚—â€– * â€–Lâ€– := opNorm_comp_le _ _\n    _ â‰¤ 1 * â€–Lâ€– := mul_le_mul_of_nonneg_right (norm_compL_le _ _ _ _) (norm_nonneg L)\n    _ = â€–Lâ€– := by rw [one_mul]\n\n"}
{"name":"ContinuousLinearMap.norm_precompL_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nEâ‚— : Type u_5\nFâ‚— : Type u_7\nGâ‚— : Type u_9\ninstâœâ¸ : SeminormedAddCommGroup E\ninstâœâ· : SeminormedAddCommGroup Eâ‚—\ninstâœâ¶ : SeminormedAddCommGroup Fâ‚—\ninstâœâµ : SeminormedAddCommGroup Gâ‚—\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedSpace ğ•œ Eâ‚—\ninstâœÂ¹ : NormedSpace ğ•œ Fâ‚—\ninstâœ : NormedSpace ğ•œ Gâ‚—\nL : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) Fâ‚— Gâ‚—)\nâŠ¢ LE.le (Norm.norm (ContinuousLinearMap.precompL Eâ‚— L)) (Norm.norm L)","decl":"set_option maxSynthPendingDepth 2 in\ntheorem norm_precompL_le (L : E â†’L[ğ•œ] Fâ‚— â†’L[ğ•œ] Gâ‚—) : â€–precompL Eâ‚— Lâ€– â‰¤ â€–Lâ€– := by\n  rw [precompL, opNorm_flip, â† opNorm_flip L]\n  exact norm_precompR_le _ L.flip\n\n"}
{"name":"ContinuousLinearMap.bilinearComp_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_6\nG : Type u_8\ninstâœÂ¹â¹ : SeminormedAddCommGroup E\ninstâœÂ¹â¸ : SeminormedAddCommGroup F\ninstâœÂ¹â· : SeminormedAddCommGroup G\ninstâœÂ¹â¶ : NontriviallyNormedField ğ•œ\ninstâœÂ¹âµ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ¹â´ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœÂ¹Â³ : NormedSpace ğ•œ E\ninstâœÂ¹Â² : NormedSpace ğ•œâ‚‚ F\ninstâœÂ¹Â¹ : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\nE' : Type u_11\nF' : Type u_12\ninstâœÂ¹â° : SeminormedAddCommGroup E'\ninstâœâ¹ : SeminormedAddCommGroup F'\nğ•œâ‚' : Type u_13\nğ•œâ‚‚' : Type u_14\ninstâœâ¸ : NontriviallyNormedField ğ•œâ‚'\ninstâœâ· : NontriviallyNormedField ğ•œâ‚‚'\ninstâœâ¶ : NormedSpace ğ•œâ‚' E'\ninstâœâµ : NormedSpace ğ•œâ‚‚' F'\nÏƒâ‚' : RingHom ğ•œâ‚' ğ•œ\nÏƒâ‚â‚ƒ' : RingHom ğ•œâ‚' ğ•œâ‚ƒ\nÏƒâ‚‚' : RingHom ğ•œâ‚‚' ğ•œâ‚‚\nÏƒâ‚‚â‚ƒ' : RingHom ğ•œâ‚‚' ğ•œâ‚ƒ\ninstâœâ´ : RingHomCompTriple Ïƒâ‚' Ïƒâ‚â‚ƒ Ïƒâ‚â‚ƒ'\ninstâœÂ³ : RingHomCompTriple Ïƒâ‚‚' Ïƒâ‚‚â‚ƒ Ïƒâ‚‚â‚ƒ'\ninstâœÂ² : RingHomIsometric Ïƒâ‚‚â‚ƒ\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚ƒ'\ninstâœ : RingHomIsometric Ïƒâ‚‚â‚ƒ'\nf : ContinuousLinearMap Ïƒâ‚â‚ƒ E (ContinuousLinearMap Ïƒâ‚‚â‚ƒ F G)\ngE : ContinuousLinearMap Ïƒâ‚' E' E\ngF : ContinuousLinearMap Ïƒâ‚‚' F' F\nx : E'\ny : F'\nâŠ¢ Eq (((f.bilinearComp gE gF) x) y) ((f (gE x)) (gF y))","decl":"@[simp]\ntheorem bilinearComp_apply (f : E â†’SL[Ïƒâ‚â‚ƒ] F â†’SL[Ïƒâ‚‚â‚ƒ] G) (gE : E' â†’SL[Ïƒâ‚'] E) (gF : F' â†’SL[Ïƒâ‚‚'] F)\n    (x : E') (y : F') : f.bilinearComp gE gF x y = f (gE x) (gF y) :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_derivâ‚‚","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nFâ‚— : Type u_7\nGâ‚— : Type u_9\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup Fâ‚—\ninstâœâ´ : SeminormedAddCommGroup Gâ‚—\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œ Fâ‚—\ninstâœ : NormedSpace ğ•œ Gâ‚—\nf : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) Fâ‚— Gâ‚—)\np : Prod E Fâ‚—\nâŠ¢ Eq â‡‘(f.derivâ‚‚ p) fun q => HAdd.hAdd ((f p.1) q.2) ((f q.1) p.2)","decl":"@[simp]\ntheorem coe_derivâ‚‚ (f : E â†’L[ğ•œ] Fâ‚— â†’L[ğ•œ] Gâ‚—) (p : E Ã— Fâ‚—) :\n    â‡‘(f.derivâ‚‚ p) = fun q : E Ã— Fâ‚— => f p.1 q.2 + f q.1 p.2 :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.map_add_add","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nFâ‚— : Type u_7\nGâ‚— : Type u_9\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup Fâ‚—\ninstâœâ´ : SeminormedAddCommGroup Gâ‚—\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œ Fâ‚—\ninstâœ : NormedSpace ğ•œ Gâ‚—\nf : ContinuousLinearMap (RingHom.id ğ•œ) E (ContinuousLinearMap (RingHom.id ğ•œ) Fâ‚— Gâ‚—)\nx x' : E\ny y' : Fâ‚—\nâŠ¢ Eq ((f (HAdd.hAdd x x')) (HAdd.hAdd y y')) (HAdd.hAdd (HAdd.hAdd ((f x) y) ((f.derivâ‚‚ { fst := x, snd := y }) { fst := x', snd := y' })) ((f x') y'))","decl":"theorem map_add_add (f : E â†’L[ğ•œ] Fâ‚— â†’L[ğ•œ] Gâ‚—) (x x' : E) (y y' : Fâ‚—) :\n    f (x + x') (y + y') = f x y + f.derivâ‚‚ (x, y) (x', y') + f x' y' := by\n  simp only [map_add, add_apply, coe_derivâ‚‚, add_assoc]\n  abel\n\n"}
{"name":"ContinuousLinearMap.norm_smulRight_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nFâ‚— : Type u_7\ninstâœâ´ : SeminormedAddCommGroup E\ninstâœÂ³ : SeminormedAddCommGroup Fâ‚—\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œ Fâ‚—\nc : ContinuousLinearMap (RingHom.id ğ•œ) E ğ•œ\nf : Fâ‚—\nâŠ¢ Eq (Norm.norm (c.smulRight f)) (HMul.hMul (Norm.norm c) (Norm.norm f))","decl":"/-- The norm of the tensor product of a scalar linear map and of an element of a normed space\nis the product of the norms. -/\n@[simp]\ntheorem norm_smulRight_apply (c : E â†’L[ğ•œ] ğ•œ) (f : Fâ‚—) : â€–smulRight c fâ€– = â€–câ€– * â€–fâ€– := by\n  refine le_antisymm ?_ ?_\n  Â· refine opNorm_le_bound _ (mul_nonneg (norm_nonneg _) (norm_nonneg _)) fun x => ?_\n    calc\n      â€–c x â€¢ fâ€– = â€–c xâ€– * â€–fâ€– := norm_smul _ _\n      _ â‰¤ â€–câ€– * â€–xâ€– * â€–fâ€– := mul_le_mul_of_nonneg_right (le_opNorm _ _) (norm_nonneg _)\n      _ = â€–câ€– * â€–fâ€– * â€–xâ€– := by ring\n  Â· obtain hf | hf := (norm_nonneg f).eq_or_gt\n    Â· simp [hf]\n    Â· rw [â† le_div_iffâ‚€ hf]\n      refine opNorm_le_bound _ (div_nonneg (norm_nonneg _) (norm_nonneg f)) fun x => ?_\n      rw [div_mul_eq_mul_div, le_div_iffâ‚€ hf]\n      calc\n        â€–c xâ€– * â€–fâ€– = â€–c x â€¢ fâ€– := (norm_smul _ _).symm\n        _ = â€–smulRight c f xâ€– := rfl\n        _ â‰¤ â€–smulRight c fâ€– * â€–xâ€– := le_opNorm _ _\n\n"}
{"name":"ContinuousLinearMap.nnnorm_smulRight_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nFâ‚— : Type u_7\ninstâœâ´ : SeminormedAddCommGroup E\ninstâœÂ³ : SeminormedAddCommGroup Fâ‚—\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œ Fâ‚—\nc : ContinuousLinearMap (RingHom.id ğ•œ) E ğ•œ\nf : Fâ‚—\nâŠ¢ Eq (NNNorm.nnnorm (c.smulRight f)) (HMul.hMul (NNNorm.nnnorm c) (NNNorm.nnnorm f))","decl":"/-- The non-negative norm of the tensor product of a scalar linear map and of an element of a normed\nspace is the product of the non-negative norms. -/\n@[simp]\ntheorem nnnorm_smulRight_apply (c : E â†’L[ğ•œ] ğ•œ) (f : Fâ‚—) : â€–smulRight c fâ€–â‚Š = â€–câ€–â‚Š * â€–fâ€–â‚Š :=\n  NNReal.eq <| c.norm_smulRight_apply f\n\n"}
{"name":"ContinuousLinearMap.norm_smulRightL_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nFâ‚— : Type u_7\ninstâœâ´ : SeminormedAddCommGroup E\ninstâœÂ³ : SeminormedAddCommGroup Fâ‚—\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œ Fâ‚—\nc : ContinuousLinearMap (RingHom.id ğ•œ) E ğ•œ\nf : Fâ‚—\nâŠ¢ Eq (Norm.norm (((ContinuousLinearMap.smulRightL ğ•œ E Fâ‚—) c) f)) (HMul.hMul (Norm.norm c) (Norm.norm f))","decl":"@[simp]\ntheorem norm_smulRightL_apply (c : E â†’L[ğ•œ] ğ•œ) (f : Fâ‚—) : â€–smulRightL ğ•œ E Fâ‚— c fâ€– = â€–câ€– * â€–fâ€– :=\n  norm_smulRight_apply c f\n\n"}
{"name":"ContinuousLinearMap.bilinearRestrictScalars_eq_restrictScalarsL_comp_restrictScalars","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nF : Type u_6\nG : Type u_8\nğ•œ' : Type u_11\ninstâœÂ¹â´ : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â³ : NontriviallyNormedField ğ•œ'\ninstâœÂ¹Â² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹Â¹ : SeminormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace ğ•œ E\ninstâœâ¹ : NormedSpace ğ•œ' E\ninstâœâ¸ : IsScalarTower ğ•œ ğ•œ' E\ninstâœâ· : SeminormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\ninstâœâµ : NormedSpace ğ•œ' F\ninstâœâ´ : IsScalarTower ğ•œ ğ•œ' F\ninstâœÂ³ : SeminormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedSpace ğ•œ' G\ninstâœ : IsScalarTower ğ•œ ğ•œ' G\nB : ContinuousLinearMap (RingHom.id ğ•œ') E (ContinuousLinearMap (RingHom.id ğ•œ') F G)\nâŠ¢ Eq (ContinuousLinearMap.bilinearRestrictScalars ğ•œ B) ((ContinuousLinearMap.restrictScalarsL ğ•œ' F G ğ•œ ğ•œ).comp (ContinuousLinearMap.restrictScalars ğ•œ B))","decl":"theorem bilinearRestrictScalars_eq_restrictScalarsL_comp_restrictScalars :\n    B.bilinearRestrictScalars ğ•œ = (restrictScalarsL ğ•œ' F G ğ•œ ğ•œ).comp (B.restrictScalars ğ•œ) := rfl\n\n"}
{"name":"ContinuousLinearMap.bilinearRestrictScalars_eq_restrictScalars_restrictScalarsL_comp","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nF : Type u_6\nG : Type u_8\nğ•œ' : Type u_11\ninstâœÂ¹â´ : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â³ : NontriviallyNormedField ğ•œ'\ninstâœÂ¹Â² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹Â¹ : SeminormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace ğ•œ E\ninstâœâ¹ : NormedSpace ğ•œ' E\ninstâœâ¸ : IsScalarTower ğ•œ ğ•œ' E\ninstâœâ· : SeminormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\ninstâœâµ : NormedSpace ğ•œ' F\ninstâœâ´ : IsScalarTower ğ•œ ğ•œ' F\ninstâœÂ³ : SeminormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedSpace ğ•œ' G\ninstâœ : IsScalarTower ğ•œ ğ•œ' G\nB : ContinuousLinearMap (RingHom.id ğ•œ') E (ContinuousLinearMap (RingHom.id ğ•œ') F G)\nâŠ¢ Eq (ContinuousLinearMap.bilinearRestrictScalars ğ•œ B) (ContinuousLinearMap.restrictScalars ğ•œ ((ContinuousLinearMap.restrictScalarsL ğ•œ' F G ğ•œ ğ•œ').comp B))","decl":"theorem bilinearRestrictScalars_eq_restrictScalars_restrictScalarsL_comp :\n    B.bilinearRestrictScalars ğ•œ = restrictScalars ğ•œ ((restrictScalarsL ğ•œ' F G ğ•œ ğ•œ').comp B) := rfl\n\n"}
{"name":"ContinuousLinearMap.bilinearRestrictScalars_apply_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nF : Type u_6\nG : Type u_8\nğ•œ' : Type u_11\ninstâœÂ¹â´ : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â³ : NontriviallyNormedField ğ•œ'\ninstâœÂ¹Â² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹Â¹ : SeminormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace ğ•œ E\ninstâœâ¹ : NormedSpace ğ•œ' E\ninstâœâ¸ : IsScalarTower ğ•œ ğ•œ' E\ninstâœâ· : SeminormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\ninstâœâµ : NormedSpace ğ•œ' F\ninstâœâ´ : IsScalarTower ğ•œ ğ•œ' F\ninstâœÂ³ : SeminormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedSpace ğ•œ' G\ninstâœ : IsScalarTower ğ•œ ğ•œ' G\nB : ContinuousLinearMap (RingHom.id ğ•œ') E (ContinuousLinearMap (RingHom.id ğ•œ') F G)\nx : E\ny : F\nâŠ¢ Eq (((ContinuousLinearMap.bilinearRestrictScalars ğ•œ B) x) y) ((B x) y)","decl":"variable (ğ•œ) in\n@[simp]\ntheorem bilinearRestrictScalars_apply_apply : (B.bilinearRestrictScalars ğ•œ) x y = B x y := rfl\n\n"}
{"name":"ContinuousLinearMap.norm_bilinearRestrictScalars","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Bilinear","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nF : Type u_6\nG : Type u_8\nğ•œ' : Type u_11\ninstâœÂ¹â´ : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â³ : NontriviallyNormedField ğ•œ'\ninstâœÂ¹Â² : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ¹Â¹ : SeminormedAddCommGroup E\ninstâœÂ¹â° : NormedSpace ğ•œ E\ninstâœâ¹ : NormedSpace ğ•œ' E\ninstâœâ¸ : IsScalarTower ğ•œ ğ•œ' E\ninstâœâ· : SeminormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\ninstâœâµ : NormedSpace ğ•œ' F\ninstâœâ´ : IsScalarTower ğ•œ ğ•œ' F\ninstâœÂ³ : SeminormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedSpace ğ•œ' G\ninstâœ : IsScalarTower ğ•œ ğ•œ' G\nB : ContinuousLinearMap (RingHom.id ğ•œ') E (ContinuousLinearMap (RingHom.id ğ•œ') F G)\nâŠ¢ Eq (Norm.norm (ContinuousLinearMap.bilinearRestrictScalars ğ•œ B)) (Norm.norm B)","decl":"@[simp]\ntheorem norm_bilinearRestrictScalars : â€–B.bilinearRestrictScalars ğ•œâ€– = â€–Bâ€– := rfl\n\n"}
