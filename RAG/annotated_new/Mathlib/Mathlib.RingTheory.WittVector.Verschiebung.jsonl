{"name":"WittVector.verschiebungFun_coeff","module":"Mathlib.RingTheory.WittVector.Verschiebung","initialProofState":"p : Nat\nR : Type u_1\ninst‚úù : CommRing R\nx : WittVector p R\nn : Nat\n‚ä¢ Eq (x.verschiebungFun.coeff n) (ite (Eq n 0) 0 (x.coeff (HSub.hSub n 1)))","decl":"theorem verschiebungFun_coeff (x : ùïé R) (n : ‚Ñï) :\n    (verschiebungFun x).coeff n = if n = 0 then 0 else x.coeff (n - 1) := by\n  simp only [verschiebungFun]\n\n"}
{"name":"WittVector.verschiebungFun_coeff_zero","module":"Mathlib.RingTheory.WittVector.Verschiebung","initialProofState":"p : Nat\nR : Type u_1\ninst‚úù : CommRing R\nx : WittVector p R\n‚ä¢ Eq (x.verschiebungFun.coeff 0) 0","decl":"theorem verschiebungFun_coeff_zero (x : ùïé R) : (verschiebungFun x).coeff 0 = 0 := by\n  rw [verschiebungFun_coeff, if_pos rfl]\n\n"}
{"name":"WittVector.verschiebungFun_coeff_succ","module":"Mathlib.RingTheory.WittVector.Verschiebung","initialProofState":"p : Nat\nR : Type u_1\ninst‚úù : CommRing R\nx : WittVector p R\nn : Nat\n‚ä¢ Eq (x.verschiebungFun.coeff n.succ) (x.coeff n)","decl":"@[simp]\ntheorem verschiebungFun_coeff_succ (x : ùïé R) (n : ‚Ñï) :\n    (verschiebungFun x).coeff n.succ = x.coeff n :=\n  rfl\n\n"}
{"name":"WittVector.ghostComponent_zero_verschiebungFun","module":"Mathlib.RingTheory.WittVector.Verschiebung","initialProofState":"p : Nat\nR : Type u_1\ninst‚úù : CommRing R\nhp : Fact (Nat.Prime p)\nx : WittVector p R\n‚ä¢ Eq ((WittVector.ghostComponent 0) x.verschiebungFun) 0","decl":"@[ghost_simps]\ntheorem ghostComponent_zero_verschiebungFun [hp : Fact p.Prime] (x : ùïé R) :\n    ghostComponent 0 (verschiebungFun x) = 0 := by\n  rw [ghostComponent_apply, aeval_wittPolynomial, Finset.range_one, Finset.sum_singleton,\n    verschiebungFun_coeff_zero, pow_zero, pow_zero, pow_one, one_mul]\n\n"}
{"name":"WittVector.ghostComponent_verschiebungFun","module":"Mathlib.RingTheory.WittVector.Verschiebung","initialProofState":"p : Nat\nR : Type u_1\ninst‚úù : CommRing R\nhp : Fact (Nat.Prime p)\nx : WittVector p R\nn : Nat\n‚ä¢ Eq ((WittVector.ghostComponent (HAdd.hAdd n 1)) x.verschiebungFun) (HMul.hMul (‚Üëp) ((WittVector.ghostComponent n) x))","decl":"@[ghost_simps]\ntheorem ghostComponent_verschiebungFun [hp : Fact p.Prime] (x : ùïé R) (n : ‚Ñï) :\n    ghostComponent (n + 1) (verschiebungFun x) = p * ghostComponent n x := by\n  simp only [ghostComponent_apply, aeval_wittPolynomial]\n  rw [Finset.sum_range_succ', verschiebungFun_coeff, if_pos rfl,\n    zero_pow (pow_ne_zero _ hp.1.ne_zero), mul_zero, add_zero, Finset.mul_sum, Finset.sum_congr rfl]\n  rintro i -\n  simp only [pow_succ', verschiebungFun_coeff_succ, Nat.succ_sub_succ_eq_sub, mul_assoc]\n\n"}
{"name":"WittVector.verschiebungPoly_zero","module":"Mathlib.RingTheory.WittVector.Verschiebung","initialProofState":"‚ä¢ Eq (WittVector.verschiebungPoly 0) 0","decl":"@[simp]\ntheorem verschiebungPoly_zero : verschiebungPoly 0 = 0 :=\n  rfl\n\n"}
{"name":"WittVector.aeval_verschiebung_poly'","module":"Mathlib.RingTheory.WittVector.Verschiebung","initialProofState":"p : Nat\nR : Type u_1\ninst‚úù : CommRing R\nx : WittVector p R\nn : Nat\n‚ä¢ Eq ((MvPolynomial.aeval x.coeff) (WittVector.verschiebungPoly n)) (x.verschiebungFun.coeff n)","decl":"theorem aeval_verschiebung_poly' (x : ùïé R) (n : ‚Ñï) :\n    aeval x.coeff (verschiebungPoly n) = (verschiebungFun x).coeff n := by\n  cases' n with n\n  ¬∑ simp only [verschiebungPoly, ite_true, map_zero, verschiebungFun_coeff_zero]\n  ¬∑ rw [verschiebungPoly, verschiebungFun_coeff_succ, if_neg n.succ_ne_zero, aeval_X,\n      add_tsub_cancel_right]\n\n"}
{"name":"WittVector.verschiebungFun_isPoly","module":"Mathlib.RingTheory.WittVector.Verschiebung","initialProofState":"p : Nat\n‚ä¢ WittVector.IsPoly p fun R _Rcr => WittVector.verschiebungFun","decl":"/-- `WittVector.verschiebung` has polynomial structure given by `WittVector.verschiebungPoly`.\n-/\n-- Porting note: replaced `@[is_poly]` with `instance`.\ninstance verschiebungFun_isPoly : IsPoly p fun R _Rcr => @verschiebungFun p R _Rcr := by\n  use verschiebungPoly\n  simp only [aeval_verschiebung_poly', eq_self_iff_true, forall‚ÇÉ_true_iff]\n\n-- Porting note: we add this example as a verification that Lean 4's instance resolution\n-- can handle what in Lean 3 we needed the `@[is_poly]` attribute to help with.\n"}
{"name":"WittVector.verschiebung_isPoly","module":"Mathlib.RingTheory.WittVector.Verschiebung","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n‚ä¢ WittVector.IsPoly p fun x x_1 => ‚áëWittVector.verschiebung","decl":"/-- `WittVector.verschiebung` is a polynomial function. -/\n@[is_poly]\ntheorem verschiebung_isPoly : IsPoly p fun _ _ => verschiebung (p := p) :=\n  verschiebungFun_isPoly p\n\n"}
{"name":"WittVector.map_verschiebung","module":"Mathlib.RingTheory.WittVector.Verschiebung","initialProofState":"p : Nat\nR : Type u_1\nS : Type u_2\ninst‚úù¬π : CommRing R\ninst‚úù : CommRing S\nhp : Fact (Nat.Prime p)\nf : RingHom R S\nx : WittVector p R\n‚ä¢ Eq ((WittVector.map f) (WittVector.verschiebung x)) (WittVector.verschiebung ((WittVector.map f) x))","decl":"/-- verschiebung is a natural transformation -/\n@[simp]\ntheorem map_verschiebung (f : R ‚Üí+* S) (x : ùïé R) :\n    map f (verschiebung x) = verschiebung (map f x) := by\n  ext ‚ü®-, -‚ü©\n  ¬∑ exact f.map_zero\n  ¬∑ rfl\n\n"}
{"name":"WittVector.ghostComponent_zero_verschiebung","module":"Mathlib.RingTheory.WittVector.Verschiebung","initialProofState":"p : Nat\nR : Type u_1\ninst‚úù : CommRing R\nhp : Fact (Nat.Prime p)\nx : WittVector p R\n‚ä¢ Eq ((WittVector.ghostComponent 0) (WittVector.verschiebung x)) 0","decl":"@[ghost_simps]\ntheorem ghostComponent_zero_verschiebung (x : ùïé R) : ghostComponent 0 (verschiebung x) = 0 :=\n  ghostComponent_zero_verschiebungFun _\n\n"}
{"name":"WittVector.ghostComponent_verschiebung","module":"Mathlib.RingTheory.WittVector.Verschiebung","initialProofState":"p : Nat\nR : Type u_1\ninst‚úù : CommRing R\nhp : Fact (Nat.Prime p)\nx : WittVector p R\nn : Nat\n‚ä¢ Eq ((WittVector.ghostComponent (HAdd.hAdd n 1)) (WittVector.verschiebung x)) (HMul.hMul (‚Üëp) ((WittVector.ghostComponent n) x))","decl":"@[ghost_simps]\ntheorem ghostComponent_verschiebung (x : ùïé R) (n : ‚Ñï) :\n    ghostComponent (n + 1) (verschiebung x) = p * ghostComponent n x :=\n  ghostComponent_verschiebungFun _ _\n\n"}
{"name":"WittVector.verschiebung_coeff_zero","module":"Mathlib.RingTheory.WittVector.Verschiebung","initialProofState":"p : Nat\nR : Type u_1\ninst‚úù : CommRing R\nhp : Fact (Nat.Prime p)\nx : WittVector p R\n‚ä¢ Eq ((WittVector.verschiebung x).coeff 0) 0","decl":"@[simp]\ntheorem verschiebung_coeff_zero (x : ùïé R) : (verschiebung x).coeff 0 = 0 :=\n  rfl\n\n-- simp_nf complains if this is simp\n"}
{"name":"WittVector.verschiebung_coeff_add_one","module":"Mathlib.RingTheory.WittVector.Verschiebung","initialProofState":"p : Nat\nR : Type u_1\ninst‚úù : CommRing R\nhp : Fact (Nat.Prime p)\nx : WittVector p R\nn : Nat\n‚ä¢ Eq ((WittVector.verschiebung x).coeff (HAdd.hAdd n 1)) (x.coeff n)","decl":"theorem verschiebung_coeff_add_one (x : ùïé R) (n : ‚Ñï) :\n    (verschiebung x).coeff (n + 1) = x.coeff n :=\n  rfl\n\n"}
{"name":"WittVector.verschiebung_coeff_succ","module":"Mathlib.RingTheory.WittVector.Verschiebung","initialProofState":"p : Nat\nR : Type u_1\ninst‚úù : CommRing R\nhp : Fact (Nat.Prime p)\nx : WittVector p R\nn : Nat\n‚ä¢ Eq ((WittVector.verschiebung x).coeff n.succ) (x.coeff n)","decl":"@[simp]\ntheorem verschiebung_coeff_succ (x : ùïé R) (n : ‚Ñï) : (verschiebung x).coeff n.succ = x.coeff n :=\n  rfl\n\n"}
{"name":"WittVector.verschiebung_injective","module":"Mathlib.RingTheory.WittVector.Verschiebung","initialProofState":"p : Nat\nR : Type u_1\ninst‚úù : CommRing R\nhp : Fact (Nat.Prime p)\n‚ä¢ Function.Injective ‚áëWittVector.verschiebung","decl":"variable (p R) in\ntheorem verschiebung_injective : Function.Injective (verschiebung : ùïé R ‚Üí ùïé R) := by\n  rw [injective_iff_map_eq_zero]\n  intro w h\n  ext n\n  rw [‚Üê verschiebung_coeff_succ, h]\n  simp only [zero_coeff]\n\n"}
{"name":"WittVector.aeval_verschiebungPoly","module":"Mathlib.RingTheory.WittVector.Verschiebung","initialProofState":"p : Nat\nR : Type u_1\ninst‚úù : CommRing R\nhp : Fact (Nat.Prime p)\nx : WittVector p R\nn : Nat\n‚ä¢ Eq ((MvPolynomial.aeval x.coeff) (WittVector.verschiebungPoly n)) ((WittVector.verschiebung x).coeff n)","decl":"theorem aeval_verschiebungPoly (x : ùïé R) (n : ‚Ñï) :\n    aeval x.coeff (verschiebungPoly n) = (verschiebung x).coeff n :=\n  aeval_verschiebung_poly' x n\n\n"}
{"name":"WittVector.bind‚ÇÅ_verschiebungPoly_wittPolynomial","module":"Mathlib.RingTheory.WittVector.Verschiebung","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ Eq ((MvPolynomial.bind‚ÇÅ WittVector.verschiebungPoly) (wittPolynomial p Int n)) (ite (Eq n 0) 0 (HMul.hMul (‚Üëp) (wittPolynomial p Int (HSub.hSub n 1))))","decl":"@[simp]\ntheorem bind‚ÇÅ_verschiebungPoly_wittPolynomial (n : ‚Ñï) :\n    bind‚ÇÅ verschiebungPoly (wittPolynomial p ‚Ñ§ n) =\n      if n = 0 then 0 else p * wittPolynomial p ‚Ñ§ (n - 1) := by\n  apply MvPolynomial.funext\n  intro x\n  split_ifs with hn\n  ¬∑ simp only [hn, wittPolynomial_zero, bind‚ÇÅ_X_right, verschiebungPoly_zero, map_zero, ite_true]\n  ¬∑ obtain ‚ü®n, rfl‚ü© := Nat.exists_eq_succ_of_ne_zero hn\n    rw [Nat.succ_eq_add_one, add_tsub_cancel_right]\n    simp only [add_eq_zero, and_false, ite_false, map_mul]\n    rw [map_natCast, hom_bind‚ÇÅ]\n    calc\n      _ = ghostComponent (n + 1) (verschiebung <| mk p x) := by\n       apply eval‚ÇÇHom_congr (RingHom.ext_int _ _) _ rfl\n       funext k\n       simp only [‚Üê aeval_verschiebungPoly]\n       exact eval‚ÇÇHom_congr (RingHom.ext_int _ _) rfl rfl\n      _ = _ := by rw [ghostComponent_verschiebung]; rfl\n\n"}
