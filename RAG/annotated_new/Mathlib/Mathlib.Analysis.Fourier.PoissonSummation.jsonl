{"name":"Real.fourierCoeff_tsum_comp_add","module":"Mathlib.Analysis.Fourier.PoissonSummation","initialProofState":"f : ContinuousMap Real Complex\nhf : ‚àÄ (K : TopologicalSpace.Compacts Real), Summable fun n => Norm.norm (ContinuousMap.restrict (‚ÜëK) (f.comp (ContinuousMap.addRight ‚Üën)))\nm : Int\n‚ä¢ Eq (fourierCoeff ‚ãØ.lift m) (Real.fourierIntegral ‚áëf ‚Üëm)","decl":"/-- The key lemma for Poisson summation: the `m`-th Fourier coefficient of the periodic function\n`‚àë' n : ‚Ñ§, f (x + n)` is the value at `m` of the Fourier transform of `f`. -/\ntheorem Real.fourierCoeff_tsum_comp_add {f : C(‚Ñù, ‚ÑÇ)}\n    (hf : ‚àÄ K : Compacts ‚Ñù, Summable fun n : ‚Ñ§ => ‚Äñ(f.comp (ContinuousMap.addRight n)).restrict K‚Äñ)\n    (m : ‚Ñ§) : fourierCoeff (Periodic.lift <| f.periodic_tsum_comp_add_zsmul 1) m = ùìï f m := by\n  -- NB: This proof can be shortened somewhat by telescoping together some of the steps in the calc\n  -- block, but I think it's more legible this way. We start with preliminaries about the integrand.\n  let e : C(‚Ñù, ‚ÑÇ) := (fourier (-m)).comp ‚ü®((‚Üë) : ‚Ñù ‚Üí UnitAddCircle), continuous_quotient_mk'‚ü©\n  have neK : ‚àÄ (K : Compacts ‚Ñù) (g : C(‚Ñù, ‚ÑÇ)), ‚Äñ(e * g).restrict K‚Äñ = ‚Äñg.restrict K‚Äñ := by\n    have (x : ‚Ñù) : ‚Äñe x‚Äñ = 1 := (AddCircle.toCircle (-m ‚Ä¢ x)).abs_coe\n    intro K g\n    simp_rw [norm_eq_iSup_norm, restrict_apply, mul_apply, norm_mul, this, one_mul]\n  have eadd : ‚àÄ (n : ‚Ñ§), e.comp (ContinuousMap.addRight n) = e := by\n    intro n; ext1 x\n    have : Periodic e 1 := Periodic.comp (fun x => AddCircle.coe_add_period 1 x) (fourier (-m))\n    simpa only [mul_one] using this.int_mul n x\n  -- Now the main argument. First unwind some definitions.\n  calc\n    fourierCoeff (Periodic.lift <| f.periodic_tsum_comp_add_zsmul 1) m =\n        ‚à´ x in (0 : ‚Ñù)..1, e x * (‚àë' n : ‚Ñ§, f.comp (ContinuousMap.addRight n)) x := by\n      simp_rw [fourierCoeff_eq_intervalIntegral _ m 0, div_one, one_smul, zero_add, e, comp_apply,\n        coe_mk, Periodic.lift_coe, zsmul_one, smul_eq_mul]\n    -- Transform sum in C(‚Ñù, ‚ÑÇ) evaluated at x into pointwise sum of values.\n    _ = ‚à´ x in (0 : ‚Ñù)..1, ‚àë' n : ‚Ñ§, (e * f.comp (ContinuousMap.addRight n)) x := by\n      simp_rw [coe_mul, Pi.mul_apply,\n        ‚Üê ContinuousMap.tsum_apply (summable_of_locally_summable_norm hf), tsum_mul_left]\n    -- Swap sum and integral.\n    _ = ‚àë' n : ‚Ñ§, ‚à´ x in (0 : ‚Ñù)..1, (e * f.comp (ContinuousMap.addRight n)) x := by\n      refine (intervalIntegral.tsum_intervalIntegral_eq_of_summable_norm ?_).symm\n      convert hf ‚ü®uIcc 0 1, isCompact_uIcc‚ü© using 1\n      exact funext fun n => neK _ _\n    _ = ‚àë' n : ‚Ñ§, ‚à´ x in (0 : ‚Ñù)..1, (e * f).comp (ContinuousMap.addRight n) x := by\n      simp only [ContinuousMap.comp_apply, mul_comp] at eadd ‚ä¢\n      simp_rw [eadd]\n    -- Rearrange sum of interval integrals into an integral over `‚Ñù`.\n    _ = ‚à´ x, e x * f x := by\n      suffices Integrable (e * f) from this.hasSum_intervalIntegral_comp_add_int.tsum_eq\n      apply integrable_of_summable_norm_Icc\n      convert hf ‚ü®Icc 0 1, isCompact_Icc‚ü© using 1\n      simp_rw [mul_comp] at eadd ‚ä¢\n      simp_rw [eadd]\n      exact funext fun n => neK ‚ü®Icc 0 1, isCompact_Icc‚ü© _\n    -- Minor tidying to finish\n    _ = ùìï f m := by\n      rw [fourierIntegral_real_eq_integral_exp_smul]\n      congr 1 with x : 1\n      rw [smul_eq_mul, comp_apply, coe_mk, coe_mk, ContinuousMap.toFun_eq_coe, fourier_coe_apply]\n      congr 2\n      push_cast\n      ring\n\n"}
{"name":"Real.tsum_eq_tsum_fourierIntegral","module":"Mathlib.Analysis.Fourier.PoissonSummation","initialProofState":"f : ContinuousMap Real Complex\nh_norm : ‚àÄ (K : TopologicalSpace.Compacts Real), Summable fun n => Norm.norm (ContinuousMap.restrict (‚ÜëK) (f.comp (ContinuousMap.addRight ‚Üën)))\nh_sum : Summable fun n => Real.fourierIntegral ‚áëf ‚Üën\nx : Real\n‚ä¢ Eq (tsum fun n => f (HAdd.hAdd x ‚Üën)) (tsum fun n => HMul.hMul (Real.fourierIntegral ‚áëf ‚Üën) ((fourier n) ‚Üëx))","decl":"/-- **Poisson's summation formula**, most general form. -/\ntheorem Real.tsum_eq_tsum_fourierIntegral {f : C(‚Ñù, ‚ÑÇ)}\n    (h_norm :\n      ‚àÄ K : Compacts ‚Ñù, Summable fun n : ‚Ñ§ => ‚Äñ(f.comp <| ContinuousMap.addRight n).restrict K‚Äñ)\n    (h_sum : Summable fun n : ‚Ñ§ => ùìï f n) (x : ‚Ñù) :\n    ‚àë' n : ‚Ñ§, f (x + n) = ‚àë' n : ‚Ñ§, ùìï f n * fourier n (x : UnitAddCircle) := by\n  let F : C(UnitAddCircle, ‚ÑÇ) :=\n    ‚ü®(f.periodic_tsum_comp_add_zsmul 1).lift, continuous_coinduced_dom.mpr (map_continuous _)‚ü©\n  have : Summable (fourierCoeff F) := by\n    convert h_sum\n    exact Real.fourierCoeff_tsum_comp_add h_norm _\n  convert (has_pointwise_sum_fourier_series_of_summable this x).tsum_eq.symm using 1\n  ¬∑ simpa only [F, coe_mk, ‚Üê QuotientAddGroup.mk_zero, Periodic.lift_coe, zsmul_one, comp_apply,\n      coe_addRight, zero_add]\n       using (hasSum_apply (summable_of_locally_summable_norm h_norm).hasSum x).tsum_eq\n  ¬∑ simp_rw [‚Üê Real.fourierCoeff_tsum_comp_add h_norm, smul_eq_mul, F, coe_mk]\n\n"}
{"name":"isBigO_norm_Icc_restrict_atTop","module":"Mathlib.Analysis.Fourier.PoissonSummation","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : ContinuousMap Real E\nb : Real\nhb : LT.lt 0 b\nhf : Asymptotics.IsBigO Filter.atTop ‚áëf fun x => HPow.hPow (abs x) (Neg.neg b)\nR S : Real\n‚ä¢ Asymptotics.IsBigO Filter.atTop (fun x => Norm.norm (ContinuousMap.restrict (Set.Icc (HAdd.hAdd x R) (HAdd.hAdd x S)) f)) fun x => HPow.hPow (abs x) (Neg.neg b)","decl":"/-- If `f` is `O(x ^ (-b))` at infinity, then so is the function\n`fun x ‚Ü¶ ‚Äñf.restrict (Icc (x + R) (x + S))‚Äñ` for any fixed `R` and `S`. -/\ntheorem isBigO_norm_Icc_restrict_atTop {f : C(‚Ñù, E)} {b : ‚Ñù} (hb : 0 < b)\n    (hf : f =O[atTop] fun x : ‚Ñù => |x| ^ (-b)) (R S : ‚Ñù) :\n    (fun x : ‚Ñù => ‚Äñf.restrict (Icc (x + R) (x + S))‚Äñ) =O[atTop] fun x : ‚Ñù => |x| ^ (-b) := by\n  -- First establish an explicit estimate on decay of inverse powers.\n  -- This is logically independent of the rest of the proof, but of no mathematical interest in\n  -- itself, so it is proved in-line rather than being formulated as a separate lemma.\n  have claim : ‚àÄ x : ‚Ñù, max 0 (-2 * R) < x ‚Üí ‚àÄ y : ‚Ñù, x + R ‚â§ y ‚Üí\n      y ^ (-b) ‚â§ (1 / 2) ^ (-b) * x ^ (-b) := fun x hx y hy ‚Ü¶ by\n    rw [max_lt_iff] at hx\n    obtain ‚ü®hx1, hx2‚ü© := hx\n    rw [‚Üê mul_rpow] <;> try positivity\n    apply rpow_le_rpow_of_nonpos <;> linarith\n  -- Now the main proof.\n  obtain ‚ü®c, hc, hc'‚ü© := hf.exists_pos\n  simp only [IsBigO, IsBigOWith, eventually_atTop] at hc' ‚ä¢\n  obtain ‚ü®d, hd‚ü© := hc'\n  refine ‚ü®c * (1 / 2) ^ (-b), ‚ü®max (1 + max 0 (-2 * R)) (d - R), fun x hx => ?_‚ü©‚ü©\n  rw [ge_iff_le, max_le_iff] at hx\n  have hx' : max 0 (-2 * R) < x := by linarith\n  rw [max_lt_iff] at hx'\n  rw [norm_norm, ContinuousMap.norm_le _ (by positivity)]\n  refine fun y => (hd y.1 (by linarith [hx.1, y.2.1])).trans ?_\n  have A : ‚àÄ x : ‚Ñù, 0 ‚â§ |x| ^ (-b) := fun x => by positivity\n  rw [mul_assoc, mul_le_mul_left hc, norm_of_nonneg (A _), norm_of_nonneg (A _)]\n  convert claim x (by linarith only [hx.1]) y.1 y.2.1\n  ¬∑ apply abs_of_nonneg; linarith [y.2.1]\n  ¬∑ exact abs_of_pos hx'.1\n\n"}
{"name":"isBigO_norm_Icc_restrict_atBot","module":"Mathlib.Analysis.Fourier.PoissonSummation","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : ContinuousMap Real E\nb : Real\nhb : LT.lt 0 b\nhf : Asymptotics.IsBigO Filter.atBot ‚áëf fun x => HPow.hPow (abs x) (Neg.neg b)\nR S : Real\n‚ä¢ Asymptotics.IsBigO Filter.atBot (fun x => Norm.norm (ContinuousMap.restrict (Set.Icc (HAdd.hAdd x R) (HAdd.hAdd x S)) f)) fun x => HPow.hPow (abs x) (Neg.neg b)","decl":"theorem isBigO_norm_Icc_restrict_atBot {f : C(‚Ñù, E)} {b : ‚Ñù} (hb : 0 < b)\n    (hf : f =O[atBot] fun x : ‚Ñù => |x| ^ (-b)) (R S : ‚Ñù) :\n    (fun x : ‚Ñù => ‚Äñf.restrict (Icc (x + R) (x + S))‚Äñ) =O[atBot] fun x : ‚Ñù => |x| ^ (-b) := by\n  have h1 : (f.comp (ContinuousMap.mk _ continuous_neg)) =O[atTop] fun x : ‚Ñù => |x| ^ (-b) := by\n    convert hf.comp_tendsto tendsto_neg_atTop_atBot using 1\n    ext1 x; simp only [Function.comp_apply, abs_neg]\n  have h2 := (isBigO_norm_Icc_restrict_atTop hb h1 (-S) (-R)).comp_tendsto tendsto_neg_atBot_atTop\n  have : (fun x : ‚Ñù => |x| ^ (-b)) ‚àò Neg.neg = fun x : ‚Ñù => |x| ^ (-b) := by\n    ext1 x; simp only [Function.comp_apply, abs_neg]\n  rw [this] at h2\n  refine (isBigO_of_le _ fun x => ?_).trans h2\n  -- equality holds, but less work to prove `‚â§` alone\n  rw [norm_norm, Function.comp_apply, norm_norm, ContinuousMap.norm_le _ (norm_nonneg _)]\n  rintro ‚ü®x, hx‚ü©\n  rw [ContinuousMap.restrict_apply_mk]\n  refine (le_of_eq ?_).trans (ContinuousMap.norm_coe_le_norm _ ‚ü®-x, ?_‚ü©)\n  ¬∑ rw [ContinuousMap.restrict_apply_mk, ContinuousMap.comp_apply, ContinuousMap.coe_mk,\n      ContinuousMap.coe_mk, neg_neg]\n  ¬∑ exact ‚ü®by linarith [hx.2], by linarith [hx.1]‚ü©\n\n"}
{"name":"isBigO_norm_restrict_cocompact","module":"Mathlib.Analysis.Fourier.PoissonSummation","initialProofState":"E : Type u_1\ninst‚úù : NormedAddCommGroup E\nf : ContinuousMap Real E\nb : Real\nhb : LT.lt 0 b\nhf : Asymptotics.IsBigO (Filter.cocompact Real) ‚áëf fun x => HPow.hPow (abs x) (Neg.neg b)\nK : TopologicalSpace.Compacts Real\n‚ä¢ Asymptotics.IsBigO (Filter.cocompact Real) (fun x => Norm.norm (ContinuousMap.restrict (‚ÜëK) (f.comp (ContinuousMap.addRight x)))) fun x => HPow.hPow (abs x) (Neg.neg b)","decl":"theorem isBigO_norm_restrict_cocompact (f : C(‚Ñù, E)) {b : ‚Ñù} (hb : 0 < b)\n    (hf : f =O[cocompact ‚Ñù] fun x : ‚Ñù => |x| ^ (-b)) (K : Compacts ‚Ñù) :\n    (fun x => ‚Äñ(f.comp (ContinuousMap.addRight x)).restrict K‚Äñ) =O[cocompact ‚Ñù] (|¬∑| ^ (-b)) := by\n  obtain ‚ü®r, hr‚ü© := K.isCompact.isBounded.subset_closedBall 0\n  rw [closedBall_eq_Icc, zero_add, zero_sub] at hr\n  have : ‚àÄ x : ‚Ñù,\n      ‚Äñ(f.comp (ContinuousMap.addRight x)).restrict K‚Äñ ‚â§ ‚Äñf.restrict (Icc (x - r) (x + r))‚Äñ := by\n    intro x\n    rw [ContinuousMap.norm_le _ (norm_nonneg _)]\n    rintro ‚ü®y, hy‚ü©\n    refine (le_of_eq ?_).trans (ContinuousMap.norm_coe_le_norm _ ‚ü®y + x, ?_‚ü©)\n    ¬∑ simp_rw [ContinuousMap.restrict_apply, ContinuousMap.comp_apply, ContinuousMap.coe_addRight]\n    ¬∑ exact ‚ü®by linarith [(hr hy).1], by linarith [(hr hy).2]‚ü©\n  simp_rw [cocompact_eq_atBot_atTop, isBigO_sup] at hf ‚ä¢\n  constructor\n  ¬∑ refine (isBigO_of_le atBot ?_).trans (isBigO_norm_Icc_restrict_atBot hb hf.1 (-r) r)\n    simp_rw [norm_norm]; exact this\n  ¬∑ refine (isBigO_of_le atTop ?_).trans (isBigO_norm_Icc_restrict_atTop hb hf.2 (-r) r)\n    simp_rw [norm_norm]; exact this\n\n"}
{"name":"Real.tsum_eq_tsum_fourierIntegral_of_rpow_decay_of_summable","module":"Mathlib.Analysis.Fourier.PoissonSummation","initialProofState":"f : Real ‚Üí Complex\nhc : Continuous f\nb : Real\nhb : LT.lt 1 b\nhf : Asymptotics.IsBigO (Filter.cocompact Real) f fun x => HPow.hPow (abs x) (Neg.neg b)\nhFf : Summable fun n => Real.fourierIntegral f ‚Üën\nx : Real\n‚ä¢ Eq (tsum fun n => f (HAdd.hAdd x ‚Üën)) (tsum fun n => HMul.hMul (Real.fourierIntegral f ‚Üën) ((fourier n) ‚Üëx))","decl":"/-- **Poisson's summation formula**, assuming that `f` decays as\n`|x| ^ (-b)` for some `1 < b` and its Fourier transform is summable. -/\ntheorem Real.tsum_eq_tsum_fourierIntegral_of_rpow_decay_of_summable {f : ‚Ñù ‚Üí ‚ÑÇ} (hc : Continuous f)\n    {b : ‚Ñù} (hb : 1 < b) (hf : IsBigO (cocompact ‚Ñù) f fun x : ‚Ñù => |x| ^ (-b))\n    (hFf : Summable fun n : ‚Ñ§ => ùìï f n) (x : ‚Ñù) :\n    ‚àë' n : ‚Ñ§, f (x + n) = ‚àë' n : ‚Ñ§, ùìï f n * fourier n (x : UnitAddCircle) :=\n  Real.tsum_eq_tsum_fourierIntegral (fun K => summable_of_isBigO (Real.summable_abs_int_rpow hb)\n    ((isBigO_norm_restrict_cocompact ‚ü®_, hc‚ü© (zero_lt_one.trans hb) hf K).comp_tendsto\n    Int.tendsto_coe_cofinite)) hFf x\n\n"}
{"name":"Real.tsum_eq_tsum_fourierIntegral_of_rpow_decay","module":"Mathlib.Analysis.Fourier.PoissonSummation","initialProofState":"f : Real ‚Üí Complex\nhc : Continuous f\nb : Real\nhb : LT.lt 1 b\nhf : Asymptotics.IsBigO (Filter.cocompact Real) f fun x => HPow.hPow (abs x) (Neg.neg b)\nhFf : Asymptotics.IsBigO (Filter.cocompact Real) (Real.fourierIntegral f) fun x => HPow.hPow (abs x) (Neg.neg b)\nx : Real\n‚ä¢ Eq (tsum fun n => f (HAdd.hAdd x ‚Üën)) (tsum fun n => HMul.hMul (Real.fourierIntegral f ‚Üën) ((fourier n) ‚Üëx))","decl":"/-- **Poisson's summation formula**, assuming that both `f` and its Fourier transform decay as\n`|x| ^ (-b)` for some `1 < b`. (This is the one-dimensional case of Corollary VII.2.6 of Stein and\nWeiss, *Introduction to Fourier analysis on Euclidean spaces*.) -/\ntheorem Real.tsum_eq_tsum_fourierIntegral_of_rpow_decay {f : ‚Ñù ‚Üí ‚ÑÇ} (hc : Continuous f) {b : ‚Ñù}\n    (hb : 1 < b) (hf : f =O[cocompact ‚Ñù] (|¬∑| ^ (-b)))\n    (hFf : (ùìï f) =O[cocompact ‚Ñù] (|¬∑| ^ (-b))) (x : ‚Ñù) :\n    ‚àë' n : ‚Ñ§, f (x + n) = ‚àë' n : ‚Ñ§, ùìï f n * fourier n (x : UnitAddCircle) :=\n  Real.tsum_eq_tsum_fourierIntegral_of_rpow_decay_of_summable hc hb hf (summable_of_isBigO\n    (Real.summable_abs_int_rpow hb) (hFf.comp_tendsto Int.tendsto_coe_cofinite)) x\n\n"}
{"name":"SchwartzMap.tsum_eq_tsum_fourierIntegral","module":"Mathlib.Analysis.Fourier.PoissonSummation","initialProofState":"f : SchwartzMap Real Complex\nx : Real\n‚ä¢ Eq (tsum fun n => f (HAdd.hAdd x ‚Üën)) (tsum fun n => HMul.hMul (((SchwartzMap.fourierTransformCLM Real) f) ‚Üën) ((fourier n) ‚Üëx))","decl":"/-- **Poisson's summation formula** for Schwartz functions. -/\ntheorem SchwartzMap.tsum_eq_tsum_fourierIntegral (f : SchwartzMap ‚Ñù ‚ÑÇ) (x : ‚Ñù) :\n    ‚àë' n : ‚Ñ§, f (x + n) = ‚àë' n : ‚Ñ§, fourierTransformCLM ‚Ñù f n * fourier n (x : UnitAddCircle) := by\n  -- We know that Schwartz functions are `O(‚Äñx ^ (-b)‚Äñ)` for *every* `b`; for this argument we take\n  -- `b = 2` and work with that.\n  apply Real.tsum_eq_tsum_fourierIntegral_of_rpow_decay f.continuous one_lt_two\n    (f.isBigO_cocompact_rpow (-2)) ((fourierTransformCLM ‚Ñù f).isBigO_cocompact_rpow (-2))\n\n"}
