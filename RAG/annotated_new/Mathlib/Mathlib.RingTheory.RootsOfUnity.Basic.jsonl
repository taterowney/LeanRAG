{"name":"mem_rootsOfUnity","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nk : Nat\nζ : Units M\n⊢ Iff (Membership.mem (rootsOfUnity k M) ζ) (Eq (HPow.hPow ζ k) 1)","decl":"@[simp]\ntheorem mem_rootsOfUnity (k : ℕ) (ζ : Mˣ) : ζ ∈ rootsOfUnity k M ↔ ζ ^ k = 1 :=\n  Iff.rfl\n\n"}
{"name":"mem_rootsOfUnity'","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nk : Nat\nζ : Units M\n⊢ Iff (Membership.mem (rootsOfUnity k M) ζ) (Eq (HPow.hPow (↑ζ) k) 1)","decl":"/-- A variant of `mem_rootsOfUnity` using `ζ : M`. -/\ntheorem mem_rootsOfUnity' (k : ℕ) (ζ : Mˣ) : ζ ∈ rootsOfUnity k M ↔ (ζ : M) ^ k = 1 := by\n  rw [mem_rootsOfUnity]; norm_cast\n\n"}
{"name":"rootsOfUnity_one","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"M : Type u_7\ninst✝ : CommMonoid M\n⊢ Eq (rootsOfUnity 1 M) Bot.bot","decl":"@[simp]\ntheorem rootsOfUnity_one (M : Type*) [CommMonoid M] : rootsOfUnity 1 M = ⊥ := by\n  ext1\n  simp only [mem_rootsOfUnity, pow_one, Subgroup.mem_bot]\n\n"}
{"name":"rootsOfUnity_zero","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"M : Type u_7\ninst✝ : CommMonoid M\n⊢ Eq (rootsOfUnity 0 M) Top.top","decl":"@[simp]\nlemma rootsOfUnity_zero (M : Type*) [CommMonoid M] : rootsOfUnity 0 M = ⊤ := by\n  ext1\n  simp only [mem_rootsOfUnity, pow_zero, Subgroup.mem_top]\n\n"}
{"name":"rootsOfUnity.coe_injective","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nn : Nat\n⊢ Function.Injective fun x => ↑↑x","decl":"theorem rootsOfUnity.coe_injective {n : ℕ} :\n    Function.Injective (fun x : rootsOfUnity n M ↦ x.val.val) :=\n  Units.ext.comp fun _ _ ↦ Subtype.eq\n\n"}
{"name":"rootsOfUnity.val_mkOfPowEq_coe","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nζ : M\nn : Nat\ninst✝ : NeZero n\nh : Eq (HPow.hPow ζ n) 1\n⊢ Eq (↑↑(rootsOfUnity.mkOfPowEq ζ h)) ζ","decl":"/-- Make an element of `rootsOfUnity` from a member of the base ring, and a proof that it has\na positive power equal to one. -/\n@[simps! coe_val]\ndef rootsOfUnity.mkOfPowEq (ζ : M) {n : ℕ} [NeZero n] (h : ζ ^ n = 1) : rootsOfUnity n M :=\n  ⟨Units.ofPowEqOne ζ n h <| NeZero.ne n, Units.pow_ofPowEqOne _ _⟩\n\n"}
{"name":"rootsOfUnity.coe_mkOfPowEq","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nζ : M\nn : Nat\ninst✝ : NeZero n\nh : Eq (HPow.hPow ζ n) 1\n⊢ Eq (↑↑(rootsOfUnity.mkOfPowEq ζ h)) ζ","decl":"@[simp]\ntheorem rootsOfUnity.coe_mkOfPowEq {ζ : M} {n : ℕ} [NeZero n] (h : ζ ^ n = 1) :\n    ((rootsOfUnity.mkOfPowEq _ h : Mˣ) : M) = ζ :=\n  rfl\n\n"}
{"name":"rootsOfUnity_le_of_dvd","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nk l : Nat\nh : Dvd.dvd k l\n⊢ LE.le (rootsOfUnity k M) (rootsOfUnity l M)","decl":"theorem rootsOfUnity_le_of_dvd (h : k ∣ l) : rootsOfUnity k M ≤ rootsOfUnity l M := by\n  obtain ⟨d, rfl⟩ := h\n  intro ζ h\n  simp_all only [mem_rootsOfUnity, pow_mul, one_pow]\n\n"}
{"name":"map_rootsOfUnity","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝¹ : CommMonoid M\ninst✝ : CommMonoid N\nf : MonoidHom (Units M) (Units N)\nk : Nat\n⊢ LE.le (Subgroup.map f (rootsOfUnity k M)) (rootsOfUnity k N)","decl":"theorem map_rootsOfUnity (f : Mˣ →* Nˣ) (k : ℕ) : (rootsOfUnity k M).map f ≤ rootsOfUnity k N := by\n  rintro _ ⟨ζ, h, rfl⟩\n  simp_all only [← map_pow, mem_rootsOfUnity, SetLike.mem_coe, MonoidHom.map_one]\n\n"}
{"name":"rootsOfUnity.coe_pow","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"R : Type u_4\nk : Nat\ninst✝ : CommMonoid R\nζ : Subtype fun x => Membership.mem (rootsOfUnity k R) x\nm : Nat\n⊢ Eq (↑↑(HPow.hPow ζ m)) (HPow.hPow (↑↑ζ) m)","decl":"@[norm_cast]\ntheorem rootsOfUnity.coe_pow [CommMonoid R] (ζ : rootsOfUnity k R) (m : ℕ) :\n    (((ζ ^ m :) : Rˣ) : R) = ((ζ : Rˣ) : R) ^ m := by\n  rw [Subgroup.coe_pow, Units.val_pow_eq_pow_val]\n\n"}
{"name":"restrictRootsOfUnity_coe_apply","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"R : Type u_4\nS : Type u_5\nF : Type u_6\nk : Nat\ninst✝³ : CommMonoid R\ninst✝² : CommMonoid S\ninst✝¹ : FunLike F R S\ninst✝ : MonoidHomClass F R S\nσ : F\nζ : Subtype fun x => Membership.mem (rootsOfUnity k R) x\n⊢ Eq (↑↑((restrictRootsOfUnity σ k) ζ)) (σ ↑↑ζ)","decl":"@[simp]\ntheorem restrictRootsOfUnity_coe_apply [MonoidHomClass F R S] (σ : F) (ζ : rootsOfUnity k R) :\n    (restrictRootsOfUnity σ k ζ : Sˣ) = σ (ζ : Rˣ) :=\n  rfl\n\n"}
{"name":"MulEquiv.restrictRootsOfUnity_coe_apply","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"R : Type u_4\nS : Type u_5\nk : Nat\ninst✝¹ : CommMonoid R\ninst✝ : CommMonoid S\nσ : MulEquiv R S\nζ : Subtype fun x => Membership.mem (rootsOfUnity k R) x\n⊢ Eq (↑↑((σ.restrictRootsOfUnity k) ζ)) (σ ↑↑ζ)","decl":"@[simp]\ntheorem MulEquiv.restrictRootsOfUnity_coe_apply (σ : R ≃* S) (ζ : rootsOfUnity k R) :\n    (σ.restrictRootsOfUnity k ζ : Sˣ) = σ (ζ : Rˣ) :=\n  rfl\n\n"}
{"name":"MulEquiv.restrictRootsOfUnity_symm","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"R : Type u_4\nS : Type u_5\nk : Nat\ninst✝¹ : CommMonoid R\ninst✝ : CommMonoid S\nσ : MulEquiv R S\n⊢ Eq (σ.restrictRootsOfUnity k).symm (σ.symm.restrictRootsOfUnity k)","decl":"@[simp]\ntheorem MulEquiv.restrictRootsOfUnity_symm (σ : R ≃* S) :\n    (σ.restrictRootsOfUnity k).symm = σ.symm.restrictRootsOfUnity k :=\n  rfl\n\n"}
{"name":"mem_rootsOfUnity_iff_mem_nthRoots","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"R : Type u_4\nk : Nat\ninst✝² : NeZero k\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nζ : Units R\n⊢ Iff (Membership.mem (rootsOfUnity k R) ζ) (Membership.mem (Polynomial.nthRoots k 1) ↑ζ)","decl":"theorem mem_rootsOfUnity_iff_mem_nthRoots {ζ : Rˣ} :\n    ζ ∈ rootsOfUnity k R ↔ (ζ : R) ∈ nthRoots k (1 : R) := by\n  simp only [mem_rootsOfUnity, mem_nthRoots (NeZero.pos k), Units.ext_iff, Units.val_one,\n    Units.val_pow_eq_pow_val]\n\n"}
{"name":"rootsOfUnityEquivNthRoots_apply","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"R : Type u_4\nk : Nat\ninst✝² : NeZero k\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nx : Subtype fun x => Membership.mem (rootsOfUnity k R) x\n⊢ Eq ↑((rootsOfUnityEquivNthRoots R k) x) ↑↑x","decl":"@[simp]\ntheorem rootsOfUnityEquivNthRoots_apply (x : rootsOfUnity k R) :\n    (rootsOfUnityEquivNthRoots R k x : R) = ((x : Rˣ) : R) :=\n  rfl\n\n"}
{"name":"rootsOfUnityEquivNthRoots_symm_apply","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"R : Type u_4\nk : Nat\ninst✝² : NeZero k\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\nx : Subtype fun x => Membership.mem (Polynomial.nthRoots k 1) x\n⊢ Eq ↑↑((rootsOfUnityEquivNthRoots R k).symm x) ↑x","decl":"@[simp]\ntheorem rootsOfUnityEquivNthRoots_symm_apply (x : { x // x ∈ nthRoots k (1 : R) }) :\n    (((rootsOfUnityEquivNthRoots R k).symm x : Rˣ) : R) = (x : R) :=\n  rfl\n\n"}
{"name":"rootsOfUnity.isCyclic","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"R : Type u_4\nk : Nat\ninst✝² : NeZero k\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ IsCyclic (Subtype fun x => Membership.mem (rootsOfUnity k R) x)","decl":"instance rootsOfUnity.isCyclic : IsCyclic (rootsOfUnity k R) :=\n  isCyclic_of_subgroup_isDomain ((Units.coeHom R).comp (rootsOfUnity k R).subtype) coe_injective\n\n"}
{"name":"card_rootsOfUnity","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"R : Type u_4\nk : Nat\ninst✝² : NeZero k\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n⊢ LE.le (Fintype.card (Subtype fun x => Membership.mem (rootsOfUnity k R) x)) k","decl":"theorem card_rootsOfUnity : Fintype.card (rootsOfUnity k R) ≤ k := by\n  classical\n  calc\n    Fintype.card (rootsOfUnity k R) = Fintype.card { x // x ∈ nthRoots k (1 : R) } :=\n      Fintype.card_congr (rootsOfUnityEquivNthRoots R k)\n    _ ≤ Multiset.card (nthRoots k (1 : R)).attach := Multiset.card_le_card (Multiset.dedup_le _)\n    _ = Multiset.card (nthRoots k (1 : R)) := Multiset.card_attach\n    _ ≤ k := card_nthRoots k 1\n\n"}
{"name":"map_rootsOfUnity_eq_pow_self","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"R : Type u_4\nF : Type u_6\nk : Nat\ninst✝⁴ : NeZero k\ninst✝³ : CommRing R\ninst✝² : IsDomain R\ninst✝¹ : FunLike F R R\ninst✝ : RingHomClass F R R\nσ : F\nζ : Subtype fun x => Membership.mem (rootsOfUnity k R) x\n⊢ Exists fun m => Eq (σ ↑↑ζ) (HPow.hPow (↑↑ζ) m)","decl":"theorem map_rootsOfUnity_eq_pow_self [FunLike F R R] [RingHomClass F R R] (σ : F)\n    (ζ : rootsOfUnity k R) :\n    ∃ m : ℕ, σ (ζ : Rˣ) = ((ζ : Rˣ) : R) ^ m := by\n  obtain ⟨m, hm⟩ := MonoidHom.map_cyclic (restrictRootsOfUnity σ k)\n  rw [← restrictRootsOfUnity_coe_apply, hm, ← zpow_mod_orderOf, ← Int.toNat_of_nonneg\n      (m.emod_nonneg (Int.natCast_ne_zero.mpr (pos_iff_ne_zero.mp (orderOf_pos ζ)))),\n    zpow_natCast, rootsOfUnity.coe_pow]\n  exact ⟨(m % orderOf ζ).toNat, rfl⟩\n\n"}
{"name":"mem_rootsOfUnity_prime_pow_mul_iff","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"R : Type u_4\ninst✝² : CommRing R\ninst✝¹ : IsReduced R\np k m : Nat\ninst✝ : ExpChar R p\nζ : Units R\n⊢ Iff (Membership.mem (rootsOfUnity (HMul.hMul (HPow.hPow p k) m) R) ζ) (Membership.mem (rootsOfUnity m R) ζ)","decl":"theorem mem_rootsOfUnity_prime_pow_mul_iff (p k : ℕ) (m : ℕ) [ExpChar R p] {ζ : Rˣ} :\n    ζ ∈ rootsOfUnity (p ^ k * m) R ↔ ζ ∈ rootsOfUnity m R := by\n  simp only [mem_rootsOfUnity', ExpChar.pow_prime_pow_mul_eq_one_iff]\n\n"}
{"name":"mem_rootsOfUnity_prime_pow_mul_iff'","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"R : Type u_4\ninst✝² : CommRing R\ninst✝¹ : IsReduced R\np k m : Nat\ninst✝ : ExpChar R p\nζ : Units R\n⊢ Iff (Eq (HPow.hPow ζ (HMul.hMul (HPow.hPow p k) m)) 1) (Membership.mem (rootsOfUnity m R) ζ)","decl":"/-- A variant of `mem_rootsOfUnity_prime_pow_mul_iff` in terms of `ζ ^ _`.-/\n@[simp]\ntheorem mem_rootsOfUnity_prime_pow_mul_iff' (p k : ℕ) (m : ℕ) [ExpChar R p] {ζ : Rˣ} :\n    ζ ^ (p ^ k * m) = 1 ↔ ζ ∈ rootsOfUnity m R := by\n  rw [← mem_rootsOfUnity, mem_rootsOfUnity_prime_pow_mul_iff]\n\n"}
{"name":"IsCyclic.monoidHom_mulEquiv_rootsOfUnity","module":"Mathlib.RingTheory.RootsOfUnity.Basic","initialProofState":"G : Type u_7\ninst✝² : CommGroup G\ninst✝¹ : IsCyclic G\nG' : Type u_8\ninst✝ : CommGroup G'\n⊢ Nonempty (MulEquiv (MonoidHom G G') (Subtype fun x => Membership.mem (rootsOfUnity (Nat.card G) G') x))","decl":"/-- The group of group homomorphisms from a finite cyclic group `G` of order `n` into another\ngroup `G'` is (noncanonically) isomorphic to the group of `n`th roots of unity in `G'`. -/\nlemma monoidHom_mulEquiv_rootsOfUnity (G : Type*) [CommGroup G] [IsCyclic G]\n    (G' : Type*) [CommGroup G'] :\n    Nonempty <| (G →* G') ≃* rootsOfUnity (Nat.card G) G' := by\n  obtain ⟨g, hg⟩ := IsCyclic.exists_generator (α := G)\n  exact ⟨monoidHomMulEquivRootsOfUnityOfGenerator hg G'⟩\n\n"}
