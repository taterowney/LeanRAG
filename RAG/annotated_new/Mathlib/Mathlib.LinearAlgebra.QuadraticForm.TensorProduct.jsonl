{"name":"QuadraticMap.tensorDistrib_tmul","module":"Mathlib.LinearAlgebra.QuadraticForm.TensorProduct","initialProofState":"R : Type uR\nA : Type uA\nM₁ : Type uM₁\nM₂ : Type uM₂\nN₁ : Type uN₁\nN₂ : Type uN₂\ninst✝¹⁶ : CommRing R\ninst✝¹⁵ : CommRing A\ninst✝¹⁴ : AddCommGroup M₁\ninst✝¹³ : AddCommGroup M₂\ninst✝¹² : AddCommGroup N₁\ninst✝¹¹ : AddCommGroup N₂\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : Module R M₁\ninst✝⁸ : Module A M₁\ninst✝⁷ : Module R N₁\ninst✝⁶ : Module A N₁\ninst✝⁵ : SMulCommClass R A M₁\ninst✝⁴ : IsScalarTower R A M₁\ninst✝³ : IsScalarTower R A N₁\ninst✝² : Module R M₂\ninst✝¹ : Module R N₂\ninst✝ : Invertible 2\nQ₁ : QuadraticMap A M₁ N₁\nQ₂ : QuadraticMap R M₂ N₂\nm₁ : M₁\nm₂ : M₂\n⊢ Eq (((QuadraticMap.tensorDistrib R A) (TensorProduct.tmul R Q₁ Q₂)) (TensorProduct.tmul R m₁ m₂)) (TensorProduct.tmul R (Q₁ m₁) (Q₂ m₂))","decl":"@[simp]\ntheorem tensorDistrib_tmul (Q₁ : QuadraticMap A M₁ N₁) (Q₂ : QuadraticMap R M₂ N₂) (m₁ : M₁)\n    (m₂ : M₂) : tensorDistrib R A (Q₁ ⊗ₜ Q₂) (m₁ ⊗ₜ m₂) = Q₁ m₁ ⊗ₜ Q₂ m₂   :=\n  letI : Invertible (2 : A) := (Invertible.map (algebraMap R A) 2).copy 2 (map_ofNat _ _).symm\n  (BilinMap.tensorDistrib_tmul _ _ _ _ _ _).trans <| congr_arg₂ _\n    (associated_eq_self_apply _ _ _) (associated_eq_self_apply _ _ _)\n\n"}
{"name":"QuadraticMap.associated_tmul","module":"Mathlib.LinearAlgebra.QuadraticForm.TensorProduct","initialProofState":"R : Type uR\nA : Type uA\nM₁ : Type uM₁\nM₂ : Type uM₂\nN₁ : Type uN₁\nN₂ : Type uN₂\ninst✝¹⁷ : CommRing R\ninst✝¹⁶ : CommRing A\ninst✝¹⁵ : AddCommGroup M₁\ninst✝¹⁴ : AddCommGroup M₂\ninst✝¹³ : AddCommGroup N₁\ninst✝¹² : AddCommGroup N₂\ninst✝¹¹ : Algebra R A\ninst✝¹⁰ : Module R M₁\ninst✝⁹ : Module A M₁\ninst✝⁸ : Module R N₁\ninst✝⁷ : Module A N₁\ninst✝⁶ : SMulCommClass R A M₁\ninst✝⁵ : IsScalarTower R A M₁\ninst✝⁴ : IsScalarTower R A N₁\ninst✝³ : Module R M₂\ninst✝² : Module R N₂\ninst✝¹ : Invertible 2\ninst✝ : Invertible 2\nQ₁ : QuadraticMap A M₁ N₁\nQ₂ : QuadraticMap R M₂ N₂\n⊢ Eq (QuadraticMap.associated (Q₁.tmul Q₂)) ((QuadraticMap.associated Q₁).tmul (QuadraticMap.associated Q₂))","decl":"theorem associated_tmul [Invertible (2 : A)]\n    (Q₁ : QuadraticMap A M₁ N₁) (Q₂ : QuadraticMap R M₂ N₂) :\n    (Q₁.tmul Q₂).associated = Q₁.associated.tmul Q₂.associated := by\n  letI : Invertible (2 : A) := (Invertible.map (algebraMap R A) 2).copy 2 (map_ofNat _ _).symm\n  rw [QuadraticMap.tmul, BilinMap.tmul]\n  have : Subsingleton (Invertible (2 : A)) := inferInstance\n  convert associated_left_inverse A (LinearMap.BilinMap.tmul_isSymm\n    (QuadraticMap.associated_isSymm A Q₁) (QuadraticMap.associated_isSymm R Q₂))\n\n"}
{"name":"QuadraticForm.tensorDistrib_tmul","module":"Mathlib.LinearAlgebra.QuadraticForm.TensorProduct","initialProofState":"R : Type uR\nA : Type uA\nM₁ : Type uM₁\nM₂ : Type uM₂\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing A\ninst✝⁸ : AddCommGroup M₁\ninst✝⁷ : AddCommGroup M₂\ninst✝⁶ : Algebra R A\ninst✝⁵ : Module R M₁\ninst✝⁴ : Module A M₁\ninst✝³ : SMulCommClass R A M₁\ninst✝² : IsScalarTower R A M₁\ninst✝¹ : Module R M₂\ninst✝ : Invertible 2\nQ₁ : QuadraticForm A M₁\nQ₂ : QuadraticForm R M₂\nm₁ : M₁\nm₂ : M₂\n⊢ Eq (((QuadraticForm.tensorDistrib R A) (TensorProduct.tmul R Q₁ Q₂)) (TensorProduct.tmul R m₁ m₂)) (HSMul.hSMul (Q₂ m₂) (Q₁ m₁))","decl":"@[simp]\ntheorem tensorDistrib_tmul (Q₁ : QuadraticForm A M₁) (Q₂ : QuadraticForm R M₂) (m₁ : M₁) (m₂ : M₂) :\n    tensorDistrib R A (Q₁ ⊗ₜ Q₂) (m₁ ⊗ₜ m₂) = Q₂ m₂ • Q₁ m₁ :=\n  letI : Invertible (2 : A) := (Invertible.map (algebraMap R A) 2).copy 2 (map_ofNat _ _).symm\n  (LinearMap.BilinForm.tensorDistrib_tmul _ _ _ _ _ _ _ _).trans <| congr_arg₂ _\n    (associated_eq_self_apply _ _ _) (associated_eq_self_apply _ _ _)\n\n"}
{"name":"QuadraticForm.associated_tmul","module":"Mathlib.LinearAlgebra.QuadraticForm.TensorProduct","initialProofState":"R : Type uR\nA : Type uA\nM₁ : Type uM₁\nM₂ : Type uM₂\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : CommRing A\ninst✝⁹ : AddCommGroup M₁\ninst✝⁸ : AddCommGroup M₂\ninst✝⁷ : Algebra R A\ninst✝⁶ : Module R M₁\ninst✝⁵ : Module A M₁\ninst✝⁴ : SMulCommClass R A M₁\ninst✝³ : IsScalarTower R A M₁\ninst✝² : Module R M₂\ninst✝¹ : Invertible 2\ninst✝ : Invertible 2\nQ₁ : QuadraticForm A M₁\nQ₂ : QuadraticForm R M₂\n⊢ Eq (QuadraticMap.associated (Q₁.tmul Q₂)) (LinearMap.BilinForm.tmul (QuadraticMap.associated Q₁) (QuadraticMap.associated Q₂))","decl":"theorem associated_tmul [Invertible (2 : A)] (Q₁ : QuadraticForm A M₁) (Q₂ : QuadraticForm R M₂) :\n    (Q₁.tmul Q₂).associated = BilinForm.tmul Q₁.associated Q₂.associated := by\n  rw [BilinForm.tmul, BilinForm.tensorDistrib, LinearMap.comp_apply, ← BilinMap.tmul,\n    ← QuadraticMap.associated_tmul Q₁ Q₂]\n  aesop\n\n"}
{"name":"QuadraticForm.polarBilin_tmul","module":"Mathlib.LinearAlgebra.QuadraticForm.TensorProduct","initialProofState":"R : Type uR\nA : Type uA\nM₁ : Type uM₁\nM₂ : Type uM₂\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : CommRing A\ninst✝⁹ : AddCommGroup M₁\ninst✝⁸ : AddCommGroup M₂\ninst✝⁷ : Algebra R A\ninst✝⁶ : Module R M₁\ninst✝⁵ : Module A M₁\ninst✝⁴ : SMulCommClass R A M₁\ninst✝³ : IsScalarTower R A M₁\ninst✝² : Module R M₂\ninst✝¹ : Invertible 2\ninst✝ : Invertible 2\nQ₁ : QuadraticForm A M₁\nQ₂ : QuadraticForm R M₂\n⊢ Eq (QuadraticMap.polarBilin (Q₁.tmul Q₂)) (HSMul.hSMul (Invertible.invOf 2) (LinearMap.BilinForm.tmul (QuadraticMap.polarBilin Q₁) (QuadraticMap.polarBilin Q₂)))","decl":"theorem polarBilin_tmul [Invertible (2 : A)] (Q₁ : QuadraticForm A M₁) (Q₂ : QuadraticForm R M₂) :\n    polarBilin (Q₁.tmul Q₂) = ⅟(2 : A) • BilinForm.tmul (polarBilin Q₁) (polarBilin Q₂) := by\n  simp_rw [← two_nsmul_associated A, ← two_nsmul_associated R, BilinForm.tmul, tmul_smul,\n    ← smul_tmul', map_nsmul, associated_tmul]\n  rw [smul_comm (_ : A) (_ : ℕ), ← smul_assoc, two_smul _ (_ : A), invOf_two_add_invOf_two,\n    one_smul]\n\n"}
{"name":"QuadraticForm.baseChange_tmul","module":"Mathlib.LinearAlgebra.QuadraticForm.TensorProduct","initialProofState":"R : Type uR\nA : Type uA\nM₂ : Type uM₂\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : AddCommGroup M₂\ninst✝² : Algebra R A\ninst✝¹ : Module R M₂\ninst✝ : Invertible 2\nQ : QuadraticForm R M₂\na : A\nm₂ : M₂\n⊢ Eq ((QuadraticForm.baseChange A Q) (TensorProduct.tmul R a m₂)) (HSMul.hSMul (Q m₂) (HMul.hMul a a))","decl":"@[simp]\ntheorem baseChange_tmul (Q : QuadraticForm R M₂) (a : A) (m₂ : M₂) :\n    Q.baseChange A (a ⊗ₜ m₂) = Q m₂ • (a * a) :=\n  tensorDistrib_tmul _ _ _ _\n\n"}
{"name":"QuadraticForm.associated_baseChange","module":"Mathlib.LinearAlgebra.QuadraticForm.TensorProduct","initialProofState":"R : Type uR\nA : Type uA\nM₂ : Type uM₂\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing A\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : Algebra R A\ninst✝² : Module R M₂\ninst✝¹ : Invertible 2\ninst✝ : Invertible 2\nQ : QuadraticForm R M₂\n⊢ Eq (QuadraticMap.associated (QuadraticForm.baseChange A Q)) (LinearMap.BilinForm.baseChange A (QuadraticMap.associated Q))","decl":"theorem associated_baseChange [Invertible (2 : A)] (Q : QuadraticForm R M₂) :\n    associated (R := A) (Q.baseChange A) = BilinForm.baseChange A (associated (R := R) Q) := by\n  dsimp only [QuadraticForm.baseChange, LinearMap.baseChange]\n  rw [associated_tmul (QuadraticMap.sq (R := A)) Q, associated_sq]\n  exact rfl\n\n"}
{"name":"QuadraticForm.polarBilin_baseChange","module":"Mathlib.LinearAlgebra.QuadraticForm.TensorProduct","initialProofState":"R : Type uR\nA : Type uA\nM₂ : Type uM₂\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing A\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : Algebra R A\ninst✝² : Module R M₂\ninst✝¹ : Invertible 2\ninst✝ : Invertible 2\nQ : QuadraticForm R M₂\n⊢ Eq (QuadraticMap.polarBilin (QuadraticForm.baseChange A Q)) (LinearMap.BilinForm.baseChange A (QuadraticMap.polarBilin Q))","decl":"theorem polarBilin_baseChange [Invertible (2 : A)] (Q : QuadraticForm R M₂) :\n    polarBilin (Q.baseChange A) = BilinForm.baseChange A (polarBilin Q) := by\n  rw [QuadraticForm.baseChange, BilinForm.baseChange, polarBilin_tmul, BilinForm.tmul,\n    ← LinearMap.map_smul, smul_tmul', ← two_nsmul_associated R, coe_associatedHom, associated_sq,\n    smul_comm, ← smul_assoc, two_smul, invOf_two_add_invOf_two, one_smul]\n\n"}
{"name":"baseChange_ext_iff","module":"Mathlib.LinearAlgebra.QuadraticForm.TensorProduct","initialProofState":"R : Type uR\nA : Type uA\nM₂ : Type uM₂\nN₁ : Type uN₁\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing A\ninst✝⁶ : AddCommGroup M₂\ninst✝⁵ : AddCommGroup N₁\ninst✝⁴ : Algebra R A\ninst✝³ : Module R N₁\ninst✝² : Module A N₁\ninst✝¹ : IsScalarTower R A N₁\ninst✝ : Module R M₂\nQ₁ Q₂ : QuadraticMap A (TensorProduct R A M₂) N₁\n⊢ Iff (Eq Q₁ Q₂) (∀ (m : M₂), Eq (Q₁ (TensorProduct.tmul R 1 m)) (Q₂ (TensorProduct.tmul R 1 m)))","decl":"/-- If two quadratic maps from `A ⊗[R] M₂` agree on elements of the form `1 ⊗ m`, they are equal.\n\nIn other words, if a base change exists for a quadratic map, it is unique.\n\nNote that unlike `QuadraticForm.baseChange`, this does not need `Invertible (2 : R)`. -/\n@[ext]\ntheorem baseChange_ext ⦃Q₁ Q₂ : QuadraticMap A (A ⊗[R] M₂) N₁⦄\n    (h : ∀ m, Q₁ (1 ⊗ₜ m) = Q₂ (1 ⊗ₜ m)) :\n    Q₁ = Q₂ := by\n  replace h (a m) : Q₁ (a ⊗ₜ m) = Q₂ (a ⊗ₜ m) := by\n    rw [← mul_one a, ← smul_eq_mul, ← smul_tmul', QuadraticMap.map_smul, QuadraticMap.map_smul, h]\n  ext x\n  induction x with\n  | tmul => simp [h]\n  | zero => simp\n  | add x y hx hy =>\n    have : Q₁.polarBilin = Q₂.polarBilin := by\n      ext\n      dsimp [polar]\n      rw [← TensorProduct.tmul_add, h, h, h]\n    replace := congr($this x y)\n    dsimp [polar] at this\n    linear_combination (norm := module) this + hx + hy\n\n"}
{"name":"baseChange_ext","module":"Mathlib.LinearAlgebra.QuadraticForm.TensorProduct","initialProofState":"R : Type uR\nA : Type uA\nM₂ : Type uM₂\nN₁ : Type uN₁\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing A\ninst✝⁶ : AddCommGroup M₂\ninst✝⁵ : AddCommGroup N₁\ninst✝⁴ : Algebra R A\ninst✝³ : Module R N₁\ninst✝² : Module A N₁\ninst✝¹ : IsScalarTower R A N₁\ninst✝ : Module R M₂\nQ₁ Q₂ : QuadraticMap A (TensorProduct R A M₂) N₁\nh : ∀ (m : M₂), Eq (Q₁ (TensorProduct.tmul R 1 m)) (Q₂ (TensorProduct.tmul R 1 m))\n⊢ Eq Q₁ Q₂","decl":"/-- If two quadratic maps from `A ⊗[R] M₂` agree on elements of the form `1 ⊗ m`, they are equal.\n\nIn other words, if a base change exists for a quadratic map, it is unique.\n\nNote that unlike `QuadraticForm.baseChange`, this does not need `Invertible (2 : R)`. -/\n@[ext]\ntheorem baseChange_ext ⦃Q₁ Q₂ : QuadraticMap A (A ⊗[R] M₂) N₁⦄\n    (h : ∀ m, Q₁ (1 ⊗ₜ m) = Q₂ (1 ⊗ₜ m)) :\n    Q₁ = Q₂ := by\n  replace h (a m) : Q₁ (a ⊗ₜ m) = Q₂ (a ⊗ₜ m) := by\n    rw [← mul_one a, ← smul_eq_mul, ← smul_tmul', QuadraticMap.map_smul, QuadraticMap.map_smul, h]\n  ext x\n  induction x with\n  | tmul => simp [h]\n  | zero => simp\n  | add x y hx hy =>\n    have : Q₁.polarBilin = Q₂.polarBilin := by\n      ext\n      dsimp [polar]\n      rw [← TensorProduct.tmul_add, h, h, h]\n    replace := congr($this x y)\n    dsimp [polar] at this\n    linear_combination (norm := module) this + hx + hy\n\n"}
