{"name":"CategoryTheory.MonoidalPreadditive.whiskerLeft_zero","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.MonoidalCategory C\nself : CategoryTheory.MonoidalPreadditive C\nX Y Z : C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X 0) 0","decl":"/-- A category is `MonoidalPreadditive` if tensoring is additive in both factors.\n\nNote we don't `extend Preadditive C` here, as `Abelian C` already extends it,\nand we'll need to have both typeclasses sometimes.\n-/\nclass MonoidalPreadditive : Prop where\n  whiskerLeft_zero : âˆ€ {X Y Z : C}, X â— (0 : Y âŸ¶ Z) = 0 := by aesop_cat\n  zero_whiskerRight : âˆ€ {X Y Z : C}, (0 : Y âŸ¶ Z) â–· X = 0 := by aesop_cat\n  whiskerLeft_add : âˆ€ {X Y Z : C} (f g : Y âŸ¶ Z), X â— (f + g) = X â— f + X â— g := by aesop_cat\n  add_whiskerRight : âˆ€ {X Y Z : C} (f g : Y âŸ¶ Z), (f + g) â–· X = f â–· X + g â–· X := by aesop_cat\n\n"}
{"name":"CategoryTheory.MonoidalPreadditive.add_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.MonoidalCategory C\nself : CategoryTheory.MonoidalPreadditive C\nX Y Z : C\nf g : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight (HAdd.hAdd f g) X) (HAdd.hAdd (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X) (CategoryTheory.MonoidalCategoryStruct.whiskerRight g X))","decl":"/-- A category is `MonoidalPreadditive` if tensoring is additive in both factors.\n\nNote we don't `extend Preadditive C` here, as `Abelian C` already extends it,\nand we'll need to have both typeclasses sometimes.\n-/\nclass MonoidalPreadditive : Prop where\n  whiskerLeft_zero : âˆ€ {X Y Z : C}, X â— (0 : Y âŸ¶ Z) = 0 := by aesop_cat\n  zero_whiskerRight : âˆ€ {X Y Z : C}, (0 : Y âŸ¶ Z) â–· X = 0 := by aesop_cat\n  whiskerLeft_add : âˆ€ {X Y Z : C} (f g : Y âŸ¶ Z), X â— (f + g) = X â— f + X â— g := by aesop_cat\n  add_whiskerRight : âˆ€ {X Y Z : C} (f g : Y âŸ¶ Z), (f + g) â–· X = f â–· X + g â–· X := by aesop_cat\n\n"}
{"name":"CategoryTheory.MonoidalPreadditive.zero_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.MonoidalCategory C\nself : CategoryTheory.MonoidalPreadditive C\nX Y Z : C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight 0 X) 0","decl":"/-- A category is `MonoidalPreadditive` if tensoring is additive in both factors.\n\nNote we don't `extend Preadditive C` here, as `Abelian C` already extends it,\nand we'll need to have both typeclasses sometimes.\n-/\nclass MonoidalPreadditive : Prop where\n  whiskerLeft_zero : âˆ€ {X Y Z : C}, X â— (0 : Y âŸ¶ Z) = 0 := by aesop_cat\n  zero_whiskerRight : âˆ€ {X Y Z : C}, (0 : Y âŸ¶ Z) â–· X = 0 := by aesop_cat\n  whiskerLeft_add : âˆ€ {X Y Z : C} (f g : Y âŸ¶ Z), X â— (f + g) = X â— f + X â— g := by aesop_cat\n  add_whiskerRight : âˆ€ {X Y Z : C} (f g : Y âŸ¶ Z), (f + g) â–· X = f â–· X + g â–· X := by aesop_cat\n\n"}
{"name":"CategoryTheory.MonoidalPreadditive.whiskerLeft_add","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.MonoidalCategory C\nself : CategoryTheory.MonoidalPreadditive C\nX Y Z : C\nf g : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (HAdd.hAdd f g)) (HAdd.hAdd (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X g))","decl":"/-- A category is `MonoidalPreadditive` if tensoring is additive in both factors.\n\nNote we don't `extend Preadditive C` here, as `Abelian C` already extends it,\nand we'll need to have both typeclasses sometimes.\n-/\nclass MonoidalPreadditive : Prop where\n  whiskerLeft_zero : âˆ€ {X Y Z : C}, X â— (0 : Y âŸ¶ Z) = 0 := by aesop_cat\n  zero_whiskerRight : âˆ€ {X Y Z : C}, (0 : Y âŸ¶ Z) â–· X = 0 := by aesop_cat\n  whiskerLeft_add : âˆ€ {X Y Z : C} (f g : Y âŸ¶ Z), X â— (f + g) = X â— f + X â— g := by aesop_cat\n  add_whiskerRight : âˆ€ {X Y Z : C} (f g : Y âŸ¶ Z), (f + g) â–· X = f â–· X + g â–· X := by aesop_cat\n\n"}
{"name":"CategoryTheory.MonoidalPreadditive.tensor_zero","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\ninstâœ : CategoryTheory.MonoidalPreadditive C\nW X Y Z : C\nf : Quiver.Hom W X\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f 0) 0","decl":"@[simp (low)]\ntheorem tensor_zero {W X Y Z : C} (f : W âŸ¶ X) : f âŠ— (0 : Y âŸ¶ Z) = 0 := by\n  simp [tensorHom_def]\n\n-- The priority setting will not be needed when we replace `f âŠ— ğŸ™ X` by `f â–· X`.\n"}
{"name":"CategoryTheory.MonoidalPreadditive.zero_tensor","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\ninstâœ : CategoryTheory.MonoidalPreadditive C\nW X Y Z : C\nf : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom 0 f) 0","decl":"@[simp (low)]\ntheorem zero_tensor {W X Y Z : C} (f : Y âŸ¶ Z) : (0 : W âŸ¶ X) âŠ— f = 0 := by\n  simp [tensorHom_def]\n\n"}
{"name":"CategoryTheory.MonoidalPreadditive.tensor_add","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\ninstâœ : CategoryTheory.MonoidalPreadditive C\nW X Y Z : C\nf : Quiver.Hom W X\ng h : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f (HAdd.hAdd g h)) (HAdd.hAdd (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) (CategoryTheory.MonoidalCategoryStruct.tensorHom f h))","decl":"theorem tensor_add {W X Y Z : C} (f : W âŸ¶ X) (g h : Y âŸ¶ Z) : f âŠ— (g + h) = f âŠ— g + f âŠ— h := by\n  simp [tensorHom_def]\n\n"}
{"name":"CategoryTheory.MonoidalPreadditive.add_tensor","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\ninstâœ : CategoryTheory.MonoidalPreadditive C\nW X Y Z : C\nf g : Quiver.Hom W X\nh : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom (HAdd.hAdd f g) h) (HAdd.hAdd (CategoryTheory.MonoidalCategoryStruct.tensorHom f h) (CategoryTheory.MonoidalCategoryStruct.tensorHom g h))","decl":"theorem add_tensor {W X Y Z : C} (f g : W âŸ¶ X) (h : Y âŸ¶ Z) : (f + g) âŠ— h = f âŠ— h + g âŠ— h := by\n  simp [tensorHom_def]\n\n"}
{"name":"CategoryTheory.tensorLeft_additive","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.MonoidalCategory C\nX : C\nâŠ¢ (CategoryTheory.MonoidalCategory.tensorLeft X).Additive","decl":"instance tensorLeft_additive (X : C) : (tensorLeft X).Additive where\n\n"}
{"name":"CategoryTheory.tensorRight_additive","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.MonoidalCategory C\nX : C\nâŠ¢ (CategoryTheory.MonoidalCategory.tensorRight X).Additive","decl":"instance tensorRight_additive (X : C) : (tensorRight X).Additive where\n\n"}
{"name":"CategoryTheory.tensoringLeft_additive","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.MonoidalCategory C\nX : C\nâŠ¢ ((CategoryTheory.MonoidalCategory.tensoringLeft C).obj X).Additive","decl":"instance tensoringLeft_additive (X : C) : ((tensoringLeft C).obj X).Additive where\n\n"}
{"name":"CategoryTheory.tensoringRight_additive","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.MonoidalCategory C\nX : C\nâŠ¢ ((CategoryTheory.MonoidalCategory.tensoringRight C).obj X).Additive","decl":"instance tensoringRight_additive (X : C) : ((tensoringRight C).obj X).Additive where\n\n"}
{"name":"CategoryTheory.monoidalPreadditive_of_faithful","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâ¹ : CategoryTheory.Category.{u_4, u_1} C\ninstâœâ¸ : CategoryTheory.Preadditive C\ninstâœâ· : CategoryTheory.MonoidalCategory C\ninstâœâ¶ : CategoryTheory.MonoidalPreadditive C\nD : Type u_2\ninstâœâµ : CategoryTheory.Category.{u_3, u_2} D\ninstâœâ´ : CategoryTheory.Preadditive D\ninstâœÂ³ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor D C\ninstâœÂ² : F.Monoidal\ninstâœÂ¹ : F.Faithful\ninstâœ : F.Additive\nâŠ¢ CategoryTheory.MonoidalPreadditive D","decl":"/-- A faithful additive monoidal functor to a monoidal preadditive category\nensures that the domain is monoidal preadditive. -/\ntheorem monoidalPreadditive_of_faithful {D} [Category D] [Preadditive D] [MonoidalCategory D]\n    (F : D â¥¤ C) [F.Monoidal] [F.Faithful] [F.Additive] :\n    MonoidalPreadditive D :=\n  { whiskerLeft_zero := by\n      intros\n      apply F.map_injective\n      simp [Functor.Monoidal.map_whiskerLeft]\n    zero_whiskerRight := by\n      intros\n      apply F.map_injective\n      simp [Functor.Monoidal.map_whiskerRight]\n    whiskerLeft_add := by\n      intros\n      apply F.map_injective\n      simp only [Functor.Monoidal.map_whiskerLeft, Functor.map_add, Preadditive.comp_add,\n        Preadditive.add_comp, MonoidalPreadditive.whiskerLeft_add]\n    add_whiskerRight := by\n      intros\n      apply F.map_injective\n      simp only [Functor.Monoidal.map_whiskerRight, Functor.map_add, Preadditive.comp_add,\n        Preadditive.add_comp, MonoidalPreadditive.add_whiskerRight] }\n\n"}
{"name":"CategoryTheory.whiskerLeft_sum","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\ninstâœ : CategoryTheory.MonoidalPreadditive C\nP Q R : C\nJ : Type u_2\ns : Finset J\ng : J â†’ Quiver.Hom Q R\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft P (s.sum fun j => g j)) (s.sum fun j => CategoryTheory.MonoidalCategoryStruct.whiskerLeft P (g j))","decl":"theorem whiskerLeft_sum (P : C) {Q R : C} {J : Type*} (s : Finset J) (g : J â†’ (Q âŸ¶ R)) :\n    P â— âˆ‘ j âˆˆ s, g j = âˆ‘ j âˆˆ s, P â— g j :=\n  map_sum ((tensoringLeft C).obj P).mapAddHom g s\n\n"}
{"name":"CategoryTheory.sum_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\ninstâœ : CategoryTheory.MonoidalPreadditive C\nQ R : C\nJ : Type u_2\ns : Finset J\ng : J â†’ Quiver.Hom Q R\nP : C\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight (s.sum fun j => g j) P) (s.sum fun j => CategoryTheory.MonoidalCategoryStruct.whiskerRight (g j) P)","decl":"theorem sum_whiskerRight {Q R : C} {J : Type*} (s : Finset J) (g : J â†’ (Q âŸ¶ R)) (P : C) :\n    (âˆ‘ j âˆˆ s, g j) â–· P = âˆ‘ j âˆˆ s, g j â–· P :=\n  map_sum ((tensoringRight C).obj P).mapAddHom g s\n\n"}
{"name":"CategoryTheory.tensor_sum","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\ninstâœ : CategoryTheory.MonoidalPreadditive C\nP Q R S : C\nJ : Type u_2\ns : Finset J\nf : Quiver.Hom P Q\ng : J â†’ Quiver.Hom R S\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f (s.sum fun j => g j)) (s.sum fun j => CategoryTheory.MonoidalCategoryStruct.tensorHom f (g j))","decl":"theorem tensor_sum {P Q R S : C} {J : Type*} (s : Finset J) (f : P âŸ¶ Q) (g : J â†’ (R âŸ¶ S)) :\n    (f âŠ— âˆ‘ j âˆˆ s, g j) = âˆ‘ j âˆˆ s, f âŠ— g j := by\n  simp only [tensorHom_def, whiskerLeft_sum, Preadditive.comp_sum]\n\n"}
{"name":"CategoryTheory.sum_tensor","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_3, u_1} C\ninstâœÂ² : CategoryTheory.Preadditive C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\ninstâœ : CategoryTheory.MonoidalPreadditive C\nP Q R S : C\nJ : Type u_2\ns : Finset J\nf : Quiver.Hom P Q\ng : J â†’ Quiver.Hom R S\nâŠ¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom (s.sum fun j => g j) f) (s.sum fun j => CategoryTheory.MonoidalCategoryStruct.tensorHom (g j) f)","decl":"theorem sum_tensor {P Q R S : C} {J : Type*} (s : Finset J) (f : P âŸ¶ Q) (g : J â†’ (R âŸ¶ S)) :\n    (âˆ‘ j âˆˆ s, g j) âŠ— f = âˆ‘ j âˆˆ s, g j âŠ— f := by\n  simp only [tensorHom_def, sum_whiskerRight, Preadditive.sum_comp]\n\n-- In a closed monoidal category, this would hold because\n-- `tensorLeft X` is a left adjoint and hence preserves all colimits.\n-- In any case it is true in any preadditive category.\n"}
{"name":"CategoryTheory.instPreservesFiniteBiproductsTensorLeft","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.MonoidalCategory C\nX : C\nâŠ¢ CategoryTheory.Limits.PreservesFiniteBiproducts (CategoryTheory.MonoidalCategory.tensorLeft X)","decl":"instance (X : C) : PreservesFiniteBiproducts (tensorLeft X) where\n  preserves {J} :=\n    { preserves := fun {f} =>\n        { preserves := fun {b} i => âŸ¨isBilimitOfTotal _ (by\n            dsimp\n            simp_rw [â† id_tensorHom]\n            simp only [â† tensor_comp, Category.comp_id, â† tensor_sum, â† tensor_id,\n              IsBilimit.total i])âŸ© } }\n\n"}
{"name":"CategoryTheory.instPreservesFiniteBiproductsTensorRight","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ¹ : CategoryTheory.Preadditive C\ninstâœ : CategoryTheory.MonoidalCategory C\nX : C\nâŠ¢ CategoryTheory.Limits.PreservesFiniteBiproducts (CategoryTheory.MonoidalCategory.tensorRight X)","decl":"instance (X : C) : PreservesFiniteBiproducts (tensorRight X) where\n  preserves {J} :=\n    { preserves := fun {f} =>\n        { preserves := fun {b} i => âŸ¨isBilimitOfTotal _ (by\n            dsimp\n            simp_rw [â† tensorHom_id]\n            simp only [â† tensor_comp, Category.comp_id, â† sum_tensor, â† tensor_id,\n               IsBilimit.total i])âŸ© } }\n\n"}
{"name":"CategoryTheory.leftDistributor_hom","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nX : C\nf : J â†’ C\nâŠ¢ Eq (CategoryTheory.leftDistributor X f).hom (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Ï€ f j)) (CategoryTheory.Limits.biproduct.Î¹ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) j))","decl":"theorem leftDistributor_hom {J : Type} [Fintype J] (X : C) (f : J â†’ C) :\n    (leftDistributor X f).hom =\n      âˆ‘ j : J, (X â— biproduct.Ï€ f j) â‰« biproduct.Î¹ (fun j => X âŠ— f j) j := by\n  classical\n  ext\n  dsimp [leftDistributor, Functor.mapBiproduct, Functor.mapBicone]\n  erw [biproduct.lift_Ï€]\n  simp only [Preadditive.sum_comp, Category.assoc, biproduct.Î¹_Ï€, comp_dite, comp_zero,\n    Finset.sum_dite_eq', Finset.mem_univ, ite_true, eqToHom_refl, Category.comp_id]\n\n"}
{"name":"CategoryTheory.leftDistributor_inv","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nX : C\nf : J â†’ C\nâŠ¢ Eq (CategoryTheory.leftDistributor X f).inv (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) j) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Î¹ f j)))","decl":"theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J â†’ C) :\n    (leftDistributor X f).inv = âˆ‘ j : J, biproduct.Ï€ _ j â‰« (X â— biproduct.Î¹ f j) := by\n  classical\n  ext\n  dsimp [leftDistributor, Functor.mapBiproduct, Functor.mapBicone]\n  simp only [Preadditive.comp_sum, biproduct.Î¹_Ï€_assoc, dite_comp, zero_comp,\n    Finset.sum_dite_eq, Finset.mem_univ, ite_true, eqToHom_refl, Category.id_comp,\n    biproduct.Î¹_desc]\n\n"}
{"name":"CategoryTheory.leftDistributor_hom_comp_biproduct_Ï€_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nX : C\nf : J â†’ C\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftDistributor X f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Ï€ f j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem leftDistributor_hom_comp_biproduct_Ï€ {J : Type} [Fintype J] (X : C) (f : J â†’ C) (j : J) :\n    (leftDistributor X f).hom â‰« biproduct.Ï€ _ j = X â— biproduct.Ï€ _ j := by\n  classical\n  simp [leftDistributor_hom, Preadditive.sum_comp, biproduct.Î¹_Ï€, comp_dite]\n\n"}
{"name":"CategoryTheory.leftDistributor_hom_comp_biproduct_Ï€","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nX : C\nf : J â†’ C\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftDistributor X f).hom (CategoryTheory.Limits.biproduct.Ï€ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) j)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Ï€ f j))","decl":"@[reassoc (attr := simp)]\ntheorem leftDistributor_hom_comp_biproduct_Ï€ {J : Type} [Fintype J] (X : C) (f : J â†’ C) (j : J) :\n    (leftDistributor X f).hom â‰« biproduct.Ï€ _ j = X â— biproduct.Ï€ _ j := by\n  classical\n  simp [leftDistributor_hom, Preadditive.sum_comp, biproduct.Î¹_Ï€, comp_dite]\n\n"}
{"name":"CategoryTheory.biproduct_Î¹_comp_leftDistributor_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nX : C\nf : J â†’ C\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Î¹ f j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftDistributor X f).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) j) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct_Î¹_comp_leftDistributor_hom {J : Type} [Fintype J] (X : C) (f : J â†’ C) (j : J) :\n    (X â— biproduct.Î¹ _ j) â‰« (leftDistributor X f).hom = biproduct.Î¹ (fun j => X âŠ— f j) j := by\n  classical\n  simp [leftDistributor_hom, Preadditive.comp_sum, â† MonoidalCategory.whiskerLeft_comp_assoc,\n    biproduct.Î¹_Ï€, whiskerLeft_dite, dite_comp]\n\n"}
{"name":"CategoryTheory.biproduct_Î¹_comp_leftDistributor_hom","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nX : C\nf : J â†’ C\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Î¹ f j)) (CategoryTheory.leftDistributor X f).hom) (CategoryTheory.Limits.biproduct.Î¹ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) j)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct_Î¹_comp_leftDistributor_hom {J : Type} [Fintype J] (X : C) (f : J â†’ C) (j : J) :\n    (X â— biproduct.Î¹ _ j) â‰« (leftDistributor X f).hom = biproduct.Î¹ (fun j => X âŠ— f j) j := by\n  classical\n  simp [leftDistributor_hom, Preadditive.comp_sum, â† MonoidalCategory.whiskerLeft_comp_assoc,\n    biproduct.Î¹_Ï€, whiskerLeft_dite, dite_comp]\n\n"}
{"name":"CategoryTheory.leftDistributor_inv_comp_biproduct_Ï€","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nX : C\nf : J â†’ C\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftDistributor X f).inv (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Ï€ f j))) (CategoryTheory.Limits.biproduct.Ï€ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) j)","decl":"@[reassoc (attr := simp)]\ntheorem leftDistributor_inv_comp_biproduct_Ï€ {J : Type} [Fintype J] (X : C) (f : J â†’ C) (j : J) :\n    (leftDistributor X f).inv â‰« (X â— biproduct.Ï€ _ j) = biproduct.Ï€ _ j := by\n  classical\n  simp [leftDistributor_inv, Preadditive.sum_comp, â† MonoidalCategory.whiskerLeft_comp,\n    biproduct.Î¹_Ï€, whiskerLeft_dite, comp_dite]\n\n"}
{"name":"CategoryTheory.leftDistributor_inv_comp_biproduct_Ï€_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nX : C\nf : J â†’ C\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftDistributor X f).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Ï€ f j)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) j) h)","decl":"@[reassoc (attr := simp)]\ntheorem leftDistributor_inv_comp_biproduct_Ï€ {J : Type} [Fintype J] (X : C) (f : J â†’ C) (j : J) :\n    (leftDistributor X f).inv â‰« (X â— biproduct.Ï€ _ j) = biproduct.Ï€ _ j := by\n  classical\n  simp [leftDistributor_inv, Preadditive.sum_comp, â† MonoidalCategory.whiskerLeft_comp,\n    biproduct.Î¹_Ï€, whiskerLeft_dite, comp_dite]\n\n"}
{"name":"CategoryTheory.biproduct_Î¹_comp_leftDistributor_inv","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nX : C\nf : J â†’ C\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) j) (CategoryTheory.leftDistributor X f).inv) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Î¹ f j))","decl":"@[reassoc (attr := simp)]\ntheorem biproduct_Î¹_comp_leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J â†’ C) (j : J) :\n    biproduct.Î¹ _ j â‰« (leftDistributor X f).inv = X â— biproduct.Î¹ _ j := by\n  classical\n  simp [leftDistributor_inv, Preadditive.comp_sum, â† id_tensor_comp, biproduct.Î¹_Ï€_assoc, dite_comp]\n\n"}
{"name":"CategoryTheory.biproduct_Î¹_comp_leftDistributor_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nX : C\nf : J â†’ C\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.Limits.biproduct f)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftDistributor X f).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Î¹ f j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct_Î¹_comp_leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J â†’ C) (j : J) :\n    biproduct.Î¹ _ j â‰« (leftDistributor X f).inv = X â— biproduct.Î¹ _ j := by\n  classical\n  simp [leftDistributor_inv, Preadditive.comp_sum, â† id_tensor_comp, biproduct.Î¹_Ï€_assoc, dite_comp]\n\n"}
{"name":"CategoryTheory.leftDistributor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nX Y : C\nf : J â†’ C\nâŠ¢ Eq ((CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.asIso (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.leftDistributor Y f)).trans (CategoryTheory.leftDistributor X fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj Y (f j))) ((CategoryTheory.MonoidalCategoryStruct.associator X Y (CategoryTheory.Limits.biproduct f)).symm.trans ((CategoryTheory.leftDistributor (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) f).trans (CategoryTheory.Limits.biproduct.mapIso fun x => CategoryTheory.MonoidalCategoryStruct.associator X Y (f x))))","decl":"theorem leftDistributor_assoc {J : Type} [Fintype J] (X Y : C) (f : J â†’ C) :\n    (asIso (ğŸ™ X) âŠ— leftDistributor Y f) â‰ªâ‰« leftDistributor X _ =\n      (Î±_ X Y (â¨ f)).symm â‰ªâ‰« leftDistributor (X âŠ— Y) f â‰ªâ‰« biproduct.mapIso fun _ => Î±_ X Y _ := by\n  classical\n  ext\n  simp only [Category.comp_id, Category.assoc, eqToHom_refl, Iso.trans_hom, Iso.symm_hom,\n    asIso_hom, comp_zero, comp_dite, Preadditive.sum_comp, Preadditive.comp_sum, tensor_sum,\n    id_tensor_comp, tensorIso_hom, leftDistributor_hom, biproduct.mapIso_hom, biproduct.Î¹_map,\n    biproduct.Î¹_Ï€, Finset.sum_dite_irrel, Finset.sum_dite_eq', Finset.sum_const_zero]\n  simp_rw [â† id_tensorHom]\n  simp only [â† id_tensor_comp, biproduct.Î¹_Ï€]\n  simp only [id_tensor_comp, tensor_dite, comp_dite]\n  simp\n\n"}
{"name":"CategoryTheory.rightDistributor_hom","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nf : J â†’ C\nX : C\nâŠ¢ Eq (CategoryTheory.rightDistributor f X).hom (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Ï€ f j) X) (CategoryTheory.Limits.biproduct.Î¹ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) j))","decl":"theorem rightDistributor_hom {J : Type} [Fintype J] (f : J â†’ C) (X : C) :\n    (rightDistributor f X).hom =\n      âˆ‘ j : J, (biproduct.Ï€ f j â–· X) â‰« biproduct.Î¹ (fun j => f j âŠ— X) j := by\n  classical\n  ext\n  dsimp [rightDistributor, Functor.mapBiproduct, Functor.mapBicone]\n  erw [biproduct.lift_Ï€]\n  simp only [Preadditive.sum_comp, Category.assoc, biproduct.Î¹_Ï€, comp_dite, comp_zero,\n    Finset.sum_dite_eq', Finset.mem_univ, eqToHom_refl, Category.comp_id, ite_true]\n\n"}
{"name":"CategoryTheory.rightDistributor_inv","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nf : J â†’ C\nX : C\nâŠ¢ Eq (CategoryTheory.rightDistributor f X).inv (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) j) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Î¹ f j) X))","decl":"theorem rightDistributor_inv {J : Type} [Fintype J] (f : J â†’ C) (X : C) :\n    (rightDistributor f X).inv = âˆ‘ j : J, biproduct.Ï€ _ j â‰« (biproduct.Î¹ f j â–· X) := by\n  classical\n  ext\n  dsimp [rightDistributor, Functor.mapBiproduct, Functor.mapBicone]\n  simp only [biproduct.Î¹_desc, Preadditive.comp_sum, ne_eq, biproduct.Î¹_Ï€_assoc, dite_comp,\n    zero_comp, Finset.sum_dite_eq, Finset.mem_univ, eqToHom_refl, Category.id_comp, ite_true]\n\n"}
{"name":"CategoryTheory.rightDistributor_hom_comp_biproduct_Ï€","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nf : J â†’ C\nX : C\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightDistributor f X).hom (CategoryTheory.Limits.biproduct.Ï€ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) j)) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Ï€ f j) X)","decl":"@[reassoc (attr := simp)]\ntheorem rightDistributor_hom_comp_biproduct_Ï€ {J : Type} [Fintype J] (f : J â†’ C) (X : C) (j : J) :\n    (rightDistributor f X).hom â‰« biproduct.Ï€ _ j = biproduct.Ï€ _ j â–· X := by\n  classical\n  simp [rightDistributor_hom, Preadditive.sum_comp, biproduct.Î¹_Ï€, comp_dite]\n\n"}
{"name":"CategoryTheory.rightDistributor_hom_comp_biproduct_Ï€_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nf : J â†’ C\nX : C\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightDistributor f X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Ï€ f j) X) h)","decl":"@[reassoc (attr := simp)]\ntheorem rightDistributor_hom_comp_biproduct_Ï€ {J : Type} [Fintype J] (f : J â†’ C) (X : C) (j : J) :\n    (rightDistributor f X).hom â‰« biproduct.Ï€ _ j = biproduct.Ï€ _ j â–· X := by\n  classical\n  simp [rightDistributor_hom, Preadditive.sum_comp, biproduct.Î¹_Ï€, comp_dite]\n\n"}
{"name":"CategoryTheory.biproduct_Î¹_comp_rightDistributor_hom","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nf : J â†’ C\nX : C\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Î¹ f j) X) (CategoryTheory.rightDistributor f X).hom) (CategoryTheory.Limits.biproduct.Î¹ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) j)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct_Î¹_comp_rightDistributor_hom {J : Type} [Fintype J] (f : J â†’ C) (X : C) (j : J) :\n    (biproduct.Î¹ _ j â–· X) â‰« (rightDistributor f X).hom = biproduct.Î¹ (fun j => f j âŠ— X) j := by\n  classical\n  simp [rightDistributor_hom, Preadditive.comp_sum, â† comp_whiskerRight_assoc, biproduct.Î¹_Ï€,\n    dite_whiskerRight, dite_comp]\n\n"}
{"name":"CategoryTheory.biproduct_Î¹_comp_rightDistributor_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nf : J â†’ C\nX : C\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Î¹ f j) X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightDistributor f X).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) j) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct_Î¹_comp_rightDistributor_hom {J : Type} [Fintype J] (f : J â†’ C) (X : C) (j : J) :\n    (biproduct.Î¹ _ j â–· X) â‰« (rightDistributor f X).hom = biproduct.Î¹ (fun j => f j âŠ— X) j := by\n  classical\n  simp [rightDistributor_hom, Preadditive.comp_sum, â† comp_whiskerRight_assoc, biproduct.Î¹_Ï€,\n    dite_whiskerRight, dite_comp]\n\n"}
{"name":"CategoryTheory.rightDistributor_inv_comp_biproduct_Ï€","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nf : J â†’ C\nX : C\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightDistributor f X).inv (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Ï€ f j) X)) (CategoryTheory.Limits.biproduct.Ï€ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) j)","decl":"@[reassoc (attr := simp)]\ntheorem rightDistributor_inv_comp_biproduct_Ï€ {J : Type} [Fintype J] (f : J â†’ C) (X : C) (j : J) :\n    (rightDistributor f X).inv â‰« (biproduct.Ï€ _ j â–· X) = biproduct.Ï€ _ j := by\n  classical\n  simp [rightDistributor_inv, Preadditive.sum_comp, â† MonoidalCategory.comp_whiskerRight,\n    biproduct.Î¹_Ï€, dite_whiskerRight, comp_dite]\n\n"}
{"name":"CategoryTheory.rightDistributor_inv_comp_biproduct_Ï€_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nf : J â†’ C\nX : C\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightDistributor f X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Ï€ f j) X) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Ï€ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) j) h)","decl":"@[reassoc (attr := simp)]\ntheorem rightDistributor_inv_comp_biproduct_Ï€ {J : Type} [Fintype J] (f : J â†’ C) (X : C) (j : J) :\n    (rightDistributor f X).inv â‰« (biproduct.Ï€ _ j â–· X) = biproduct.Ï€ _ j := by\n  classical\n  simp [rightDistributor_inv, Preadditive.sum_comp, â† MonoidalCategory.comp_whiskerRight,\n    biproduct.Î¹_Ï€, dite_whiskerRight, comp_dite]\n\n"}
{"name":"CategoryTheory.biproduct_Î¹_comp_rightDistributor_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nf : J â†’ C\nX : C\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.Limits.biproduct f) X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightDistributor f X).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Î¹ f j) X) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct_Î¹_comp_rightDistributor_inv {J : Type} [Fintype J] (f : J â†’ C) (X : C) (j : J) :\n    biproduct.Î¹ _ j â‰« (rightDistributor f X).inv = biproduct.Î¹ _ j â–· X := by\n  classical\n  simp [rightDistributor_inv, Preadditive.comp_sum, â† id_tensor_comp, biproduct.Î¹_Ï€_assoc,\n    dite_comp]\n\n"}
{"name":"CategoryTheory.biproduct_Î¹_comp_rightDistributor_inv","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nf : J â†’ C\nX : C\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Î¹ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) j) (CategoryTheory.rightDistributor f X).inv) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Î¹ f j) X)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct_Î¹_comp_rightDistributor_inv {J : Type} [Fintype J] (f : J â†’ C) (X : C) (j : J) :\n    biproduct.Î¹ _ j â‰« (rightDistributor f X).inv = biproduct.Î¹ _ j â–· X := by\n  classical\n  simp [rightDistributor_inv, Preadditive.comp_sum, â† id_tensor_comp, biproduct.Î¹_Ï€_assoc,\n    dite_comp]\n\n"}
{"name":"CategoryTheory.rightDistributor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nf : J â†’ C\nX Y : C\nâŠ¢ Eq ((CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.rightDistributor f X) (CategoryTheory.asIso (CategoryTheory.CategoryStruct.id Y))).trans (CategoryTheory.rightDistributor (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) Y)) ((CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.Limits.biproduct f) X Y).trans ((CategoryTheory.rightDistributor f (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).trans (CategoryTheory.Limits.biproduct.mapIso fun x => (CategoryTheory.MonoidalCategoryStruct.associator (f x) X Y).symm)))","decl":"theorem rightDistributor_assoc {J : Type} [Fintype J] (f : J â†’ C) (X Y : C) :\n    (rightDistributor f X âŠ— asIso (ğŸ™ Y)) â‰ªâ‰« rightDistributor _ Y =\n      Î±_ (â¨ f) X Y â‰ªâ‰« rightDistributor f (X âŠ— Y) â‰ªâ‰« biproduct.mapIso fun _ => (Î±_ _ X Y).symm := by\n  classical\n  ext\n  simp only [Category.comp_id, Category.assoc, eqToHom_refl, Iso.symm_hom, Iso.trans_hom,\n    asIso_hom, comp_zero, comp_dite, Preadditive.sum_comp, Preadditive.comp_sum, sum_tensor,\n    comp_tensor_id, tensorIso_hom, rightDistributor_hom, biproduct.mapIso_hom, biproduct.Î¹_map,\n    biproduct.Î¹_Ï€, Finset.sum_dite_irrel, Finset.sum_dite_eq', Finset.sum_const_zero,\n    Finset.mem_univ, if_true]\n  simp_rw [â† tensorHom_id]\n  simp only [â† comp_tensor_id, biproduct.Î¹_Ï€, dite_tensor, comp_dite]\n  simp\n\n"}
{"name":"CategoryTheory.leftDistributor_rightDistributor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nX : C\nf : J â†’ C\nY : C\nâŠ¢ Eq ((CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.leftDistributor X f) (CategoryTheory.asIso (CategoryTheory.CategoryStruct.id Y))).trans (CategoryTheory.rightDistributor (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) Y)) ((CategoryTheory.MonoidalCategoryStruct.associator X (CategoryTheory.Limits.biproduct f) Y).trans ((CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.asIso (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.rightDistributor f Y)).trans ((CategoryTheory.leftDistributor X fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) Y).trans (CategoryTheory.Limits.biproduct.mapIso fun x => (CategoryTheory.MonoidalCategoryStruct.associator X (f x) Y).symm))))","decl":"theorem leftDistributor_rightDistributor_assoc {J : Type _} [Fintype J]\n    (X : C) (f : J â†’ C) (Y : C) :\n    (leftDistributor X f âŠ— asIso (ğŸ™ Y)) â‰ªâ‰« rightDistributor _ Y =\n      Î±_ X (â¨ f) Y â‰ªâ‰«\n        (asIso (ğŸ™ X) âŠ— rightDistributor _ Y) â‰ªâ‰«\n          leftDistributor X _ â‰ªâ‰« biproduct.mapIso fun _ => (Î±_ _ _ _).symm := by\n  classical\n  ext\n  simp only [Category.comp_id, Category.assoc, eqToHom_refl, Iso.symm_hom, Iso.trans_hom,\n    asIso_hom, comp_zero, comp_dite, Preadditive.sum_comp, Preadditive.comp_sum, sum_tensor,\n    tensor_sum, comp_tensor_id, tensorIso_hom, leftDistributor_hom, rightDistributor_hom,\n    biproduct.mapIso_hom, biproduct.Î¹_map, biproduct.Î¹_Ï€, Finset.sum_dite_irrel,\n    Finset.sum_dite_eq', Finset.sum_const_zero, Finset.mem_univ, if_true]\n  simp_rw [â† tensorHom_id, â† id_tensorHom]\n  simp only [â† comp_tensor_id, â† id_tensor_comp_assoc, Category.assoc, biproduct.Î¹_Ï€, comp_dite,\n    dite_comp, tensor_dite, dite_tensor]\n  simp\n\n"}
{"name":"CategoryTheory.leftDistributor_ext_left_iff","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nX Y : C\nf : J â†’ C\ng h : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.Limits.biproduct f)) Y\nâŠ¢ Iff (Eq g h) (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Î¹ f j)) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Î¹ f j)) h))","decl":"@[ext]\ntheorem leftDistributor_ext_left {J : Type} [Fintype J] {X Y : C} {f : J â†’ C} {g h : X âŠ— â¨ f âŸ¶ Y}\n    (w : âˆ€ j, (X â— biproduct.Î¹ f j) â‰« g = (X â— biproduct.Î¹ f j) â‰« h) : g = h := by\n  classical\n  apply (cancel_epi (leftDistributor X f).inv).mp\n  ext\n  simp? [leftDistributor_inv, Preadditive.comp_sum_assoc, biproduct.Î¹_Ï€_assoc, dite_comp] says\n    simp only [leftDistributor_inv, Preadditive.comp_sum_assoc, biproduct.Î¹_Ï€_assoc, dite_comp,\n      zero_comp, Finset.sum_dite_eq, Finset.mem_univ, â†“reduceIte, eqToHom_refl, Category.id_comp]\n  apply w\n\n"}
{"name":"CategoryTheory.leftDistributor_ext_left","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nX Y : C\nf : J â†’ C\ng h : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.Limits.biproduct f)) Y\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Î¹ f j)) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Î¹ f j)) h)\nâŠ¢ Eq g h","decl":"@[ext]\ntheorem leftDistributor_ext_left {J : Type} [Fintype J] {X Y : C} {f : J â†’ C} {g h : X âŠ— â¨ f âŸ¶ Y}\n    (w : âˆ€ j, (X â— biproduct.Î¹ f j) â‰« g = (X â— biproduct.Î¹ f j) â‰« h) : g = h := by\n  classical\n  apply (cancel_epi (leftDistributor X f).inv).mp\n  ext\n  simp? [leftDistributor_inv, Preadditive.comp_sum_assoc, biproduct.Î¹_Ï€_assoc, dite_comp] says\n    simp only [leftDistributor_inv, Preadditive.comp_sum_assoc, biproduct.Î¹_Ï€_assoc, dite_comp,\n      zero_comp, Finset.sum_dite_eq, Finset.mem_univ, â†“reduceIte, eqToHom_refl, Category.id_comp]\n  apply w\n\n"}
{"name":"CategoryTheory.leftDistributor_ext_right","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nX Y : C\nf : J â†’ C\ng h : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y (CategoryTheory.Limits.biproduct f))\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.Limits.biproduct.Ï€ f j))) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.Limits.biproduct.Ï€ f j)))\nâŠ¢ Eq g h","decl":"@[ext]\ntheorem leftDistributor_ext_right {J : Type} [Fintype J] {X Y : C} {f : J â†’ C} {g h : X âŸ¶ Y âŠ— â¨ f}\n    (w : âˆ€ j, g â‰« (Y â— biproduct.Ï€ f j) = h â‰« (Y â— biproduct.Ï€ f j)) : g = h := by\n  classical\n  apply (cancel_mono (leftDistributor Y f).hom).mp\n  ext\n  simp? [leftDistributor_hom, Preadditive.sum_comp, Preadditive.comp_sum_assoc, biproduct.Î¹_Ï€,\n      comp_dite] says\n    simp only [leftDistributor_hom, Category.assoc, Preadditive.sum_comp, biproduct.Î¹_Ï€, comp_dite,\n      comp_zero, Finset.sum_dite_eq', Finset.mem_univ, â†“reduceIte, eqToHom_refl, Category.comp_id]\n\n  apply w\n\n-- One might wonder how many iterated tensor products we need simp lemmas for.\n-- The answer is two: this lemma is needed to verify the pentagon identity.\n"}
{"name":"CategoryTheory.leftDistributor_ext_right_iff","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nX Y : C\nf : J â†’ C\ng h : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y (CategoryTheory.Limits.biproduct f))\nâŠ¢ Iff (Eq g h) (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.Limits.biproduct.Ï€ f j))) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.Limits.biproduct.Ï€ f j))))","decl":"@[ext]\ntheorem leftDistributor_ext_right {J : Type} [Fintype J] {X Y : C} {f : J â†’ C} {g h : X âŸ¶ Y âŠ— â¨ f}\n    (w : âˆ€ j, g â‰« (Y â— biproduct.Ï€ f j) = h â‰« (Y â— biproduct.Ï€ f j)) : g = h := by\n  classical\n  apply (cancel_mono (leftDistributor Y f).hom).mp\n  ext\n  simp? [leftDistributor_hom, Preadditive.sum_comp, Preadditive.comp_sum_assoc, biproduct.Î¹_Ï€,\n      comp_dite] says\n    simp only [leftDistributor_hom, Category.assoc, Preadditive.sum_comp, biproduct.Î¹_Ï€, comp_dite,\n      comp_zero, Finset.sum_dite_eq', Finset.mem_univ, â†“reduceIte, eqToHom_refl, Category.comp_id]\n\n  apply w\n\n-- One might wonder how many iterated tensor products we need simp lemmas for.\n-- The answer is two: this lemma is needed to verify the pentagon identity.\n"}
{"name":"CategoryTheory.leftDistributor_extâ‚‚_left_iff","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nX Y Z : C\nf : J â†’ C\ng h : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y (CategoryTheory.Limits.biproduct f))) Z\nâŠ¢ Iff (Eq g h) (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.Limits.biproduct.Î¹ f j))) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.Limits.biproduct.Î¹ f j))) h))","decl":"@[ext]\ntheorem leftDistributor_extâ‚‚_left {J : Type} [Fintype J]\n    {X Y Z : C} {f : J â†’ C} {g h : X âŠ— (Y âŠ— â¨ f) âŸ¶ Z}\n    (w : âˆ€ j, (X â— (Y â— biproduct.Î¹ f j)) â‰« g = (X â— (Y â— biproduct.Î¹ f j)) â‰« h) :\n    g = h := by\n  apply (cancel_epi (Î±_ _ _ _).hom).mp\n  ext\n  simp [w]\n\n"}
{"name":"CategoryTheory.leftDistributor_extâ‚‚_left","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nX Y Z : C\nf : J â†’ C\ng h : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y (CategoryTheory.Limits.biproduct f))) Z\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.Limits.biproduct.Î¹ f j))) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.Limits.biproduct.Î¹ f j))) h)\nâŠ¢ Eq g h","decl":"@[ext]\ntheorem leftDistributor_extâ‚‚_left {J : Type} [Fintype J]\n    {X Y Z : C} {f : J â†’ C} {g h : X âŠ— (Y âŠ— â¨ f) âŸ¶ Z}\n    (w : âˆ€ j, (X â— (Y â— biproduct.Î¹ f j)) â‰« g = (X â— (Y â— biproduct.Î¹ f j)) â‰« h) :\n    g = h := by\n  apply (cancel_epi (Î±_ _ _ _).hom).mp\n  ext\n  simp [w]\n\n"}
{"name":"CategoryTheory.leftDistributor_extâ‚‚_right_iff","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nX Y Z : C\nf : J â†’ C\ng h : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y (CategoryTheory.MonoidalCategoryStruct.tensorObj Z (CategoryTheory.Limits.biproduct f)))\nâŠ¢ Iff (Eq g h) (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z (CategoryTheory.Limits.biproduct.Ï€ f j)))) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z (CategoryTheory.Limits.biproduct.Ï€ f j)))))","decl":"@[ext]\ntheorem leftDistributor_extâ‚‚_right {J : Type} [Fintype J]\n    {X Y Z : C} {f : J â†’ C} {g h : X âŸ¶ Y âŠ— (Z âŠ— â¨ f)}\n    (w : âˆ€ j, g â‰« (Y â— (Z â— biproduct.Ï€ f j)) = h â‰« (Y â— (Z â— biproduct.Ï€ f j))) :\n    g = h := by\n  apply (cancel_mono (Î±_ _ _ _).inv).mp\n  ext\n  simp [w]\n\n"}
{"name":"CategoryTheory.leftDistributor_extâ‚‚_right","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nX Y Z : C\nf : J â†’ C\ng h : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y (CategoryTheory.MonoidalCategoryStruct.tensorObj Z (CategoryTheory.Limits.biproduct f)))\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z (CategoryTheory.Limits.biproduct.Ï€ f j)))) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z (CategoryTheory.Limits.biproduct.Ï€ f j))))\nâŠ¢ Eq g h","decl":"@[ext]\ntheorem leftDistributor_extâ‚‚_right {J : Type} [Fintype J]\n    {X Y Z : C} {f : J â†’ C} {g h : X âŸ¶ Y âŠ— (Z âŠ— â¨ f)}\n    (w : âˆ€ j, g â‰« (Y â— (Z â— biproduct.Ï€ f j)) = h â‰« (Y â— (Z â— biproduct.Ï€ f j))) :\n    g = h := by\n  apply (cancel_mono (Î±_ _ _ _).inv).mp\n  ext\n  simp [w]\n\n"}
{"name":"CategoryTheory.rightDistributor_ext_left_iff","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nf : J â†’ C\nX Y : C\ng h : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.Limits.biproduct f) X) Y\nâŠ¢ Iff (Eq g h) (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Î¹ f j) X) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Î¹ f j) X) h))","decl":"@[ext]\ntheorem rightDistributor_ext_left {J : Type} [Fintype J]\n    {f : J â†’ C} {X Y : C} {g h : (â¨ f) âŠ— X âŸ¶ Y}\n    (w : âˆ€ j, (biproduct.Î¹ f j â–· X) â‰« g = (biproduct.Î¹ f j â–· X) â‰« h) : g = h := by\n  classical\n  apply (cancel_epi (rightDistributor f X).inv).mp\n  ext\n  simp? [rightDistributor_inv, Preadditive.comp_sum_assoc, biproduct.Î¹_Ï€_assoc, dite_comp] says\n    simp only [rightDistributor_inv, Preadditive.comp_sum_assoc, biproduct.Î¹_Ï€_assoc, dite_comp,\n      zero_comp, Finset.sum_dite_eq, Finset.mem_univ, â†“reduceIte, eqToHom_refl, Category.id_comp]\n  apply w\n\n"}
{"name":"CategoryTheory.rightDistributor_ext_left","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nf : J â†’ C\nX Y : C\ng h : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.Limits.biproduct f) X) Y\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Î¹ f j) X) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Î¹ f j) X) h)\nâŠ¢ Eq g h","decl":"@[ext]\ntheorem rightDistributor_ext_left {J : Type} [Fintype J]\n    {f : J â†’ C} {X Y : C} {g h : (â¨ f) âŠ— X âŸ¶ Y}\n    (w : âˆ€ j, (biproduct.Î¹ f j â–· X) â‰« g = (biproduct.Î¹ f j â–· X) â‰« h) : g = h := by\n  classical\n  apply (cancel_epi (rightDistributor f X).inv).mp\n  ext\n  simp? [rightDistributor_inv, Preadditive.comp_sum_assoc, biproduct.Î¹_Ï€_assoc, dite_comp] says\n    simp only [rightDistributor_inv, Preadditive.comp_sum_assoc, biproduct.Î¹_Ï€_assoc, dite_comp,\n      zero_comp, Finset.sum_dite_eq, Finset.mem_univ, â†“reduceIte, eqToHom_refl, Category.id_comp]\n  apply w\n\n"}
{"name":"CategoryTheory.rightDistributor_ext_right_iff","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nf : J â†’ C\nX Y : C\ng h : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.Limits.biproduct f) Y)\nâŠ¢ Iff (Eq g h) (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Ï€ f j) Y)) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Ï€ f j) Y)))","decl":"@[ext]\ntheorem rightDistributor_ext_right {J : Type} [Fintype J]\n    {f : J â†’ C} {X Y : C} {g h : X âŸ¶ (â¨ f) âŠ— Y}\n    (w : âˆ€ j, g â‰« (biproduct.Ï€ f j â–· Y) = h â‰« (biproduct.Ï€ f j â–· Y)) : g = h := by\n  classical\n  apply (cancel_mono (rightDistributor f Y).hom).mp\n  ext\n  simp? [rightDistributor_hom, Preadditive.sum_comp, Preadditive.comp_sum_assoc, biproduct.Î¹_Ï€,\n      comp_dite] says\n    simp only [rightDistributor_hom, Category.assoc, Preadditive.sum_comp, biproduct.Î¹_Ï€, comp_dite,\n      comp_zero, Finset.sum_dite_eq', Finset.mem_univ, â†“reduceIte, eqToHom_refl, Category.comp_id]\n  apply w\n\n"}
{"name":"CategoryTheory.rightDistributor_ext_right","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nf : J â†’ C\nX Y : C\ng h : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.Limits.biproduct f) Y)\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Ï€ f j) Y)) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Ï€ f j) Y))\nâŠ¢ Eq g h","decl":"@[ext]\ntheorem rightDistributor_ext_right {J : Type} [Fintype J]\n    {f : J â†’ C} {X Y : C} {g h : X âŸ¶ (â¨ f) âŠ— Y}\n    (w : âˆ€ j, g â‰« (biproduct.Ï€ f j â–· Y) = h â‰« (biproduct.Ï€ f j â–· Y)) : g = h := by\n  classical\n  apply (cancel_mono (rightDistributor f Y).hom).mp\n  ext\n  simp? [rightDistributor_hom, Preadditive.sum_comp, Preadditive.comp_sum_assoc, biproduct.Î¹_Ï€,\n      comp_dite] says\n    simp only [rightDistributor_hom, Category.assoc, Preadditive.sum_comp, biproduct.Î¹_Ï€, comp_dite,\n      comp_zero, Finset.sum_dite_eq', Finset.mem_univ, â†“reduceIte, eqToHom_refl, Category.comp_id]\n  apply w\n\n"}
{"name":"CategoryTheory.rightDistributor_extâ‚‚_left_iff","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nf : J â†’ C\nX Y Z : C\ng h : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.Limits.biproduct f) X) Y) Z\nâŠ¢ Iff (Eq g h) (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Î¹ f j) X) Y) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Î¹ f j) X) Y) h))","decl":"@[ext]\ntheorem rightDistributor_extâ‚‚_left {J : Type} [Fintype J]\n    {f : J â†’ C} {X Y Z : C} {g h : ((â¨ f) âŠ— X) âŠ— Y âŸ¶ Z}\n    (w : âˆ€ j, ((biproduct.Î¹ f j â–· X) â–· Y) â‰« g = ((biproduct.Î¹ f j â–· X) â–· Y) â‰« h) :\n    g = h := by\n  apply (cancel_epi (Î±_ _ _ _).inv).mp\n  ext\n  simp [w]\n\n"}
{"name":"CategoryTheory.rightDistributor_extâ‚‚_left","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nf : J â†’ C\nX Y Z : C\ng h : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.Limits.biproduct f) X) Y) Z\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Î¹ f j) X) Y) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Î¹ f j) X) Y) h)\nâŠ¢ Eq g h","decl":"@[ext]\ntheorem rightDistributor_extâ‚‚_left {J : Type} [Fintype J]\n    {f : J â†’ C} {X Y Z : C} {g h : ((â¨ f) âŠ— X) âŠ— Y âŸ¶ Z}\n    (w : âˆ€ j, ((biproduct.Î¹ f j â–· X) â–· Y) â‰« g = ((biproduct.Î¹ f j â–· X) â–· Y) â‰« h) :\n    g = h := by\n  apply (cancel_epi (Î±_ _ _ _).inv).mp\n  ext\n  simp [w]\n\n"}
{"name":"CategoryTheory.rightDistributor_extâ‚‚_right","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nf : J â†’ C\nX Y Z : C\ng h : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.Limits.biproduct f) Y) Z)\nw : âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Ï€ f j) Y) Z)) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Ï€ f j) Y) Z))\nâŠ¢ Eq g h","decl":"@[ext]\ntheorem rightDistributor_extâ‚‚_right {J : Type} [Fintype J]\n    {f : J â†’ C} {X Y Z : C} {g h : X âŸ¶ ((â¨ f) âŠ— Y) âŠ— Z}\n    (w : âˆ€ j, g â‰« ((biproduct.Ï€ f j â–· Y) â–· Z) = h â‰« ((biproduct.Ï€ f j â–· Y) â–· Z)) :\n    g = h := by\n  apply (cancel_mono (Î±_ _ _ _).hom).mp\n  ext\n  simp [w]\n\n"}
{"name":"CategoryTheory.rightDistributor_extâ‚‚_right_iff","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_2, u_1} C\ninstâœâ´ : CategoryTheory.Preadditive C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.MonoidalPreadditive C\ninstâœÂ¹ : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninstâœ : Fintype J\nf : J â†’ C\nX Y Z : C\ng h : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.Limits.biproduct f) Y) Z)\nâŠ¢ Iff (Eq g h) (âˆ€ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Ï€ f j) Y) Z)) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Ï€ f j) Y) Z)))","decl":"@[ext]\ntheorem rightDistributor_extâ‚‚_right {J : Type} [Fintype J]\n    {f : J â†’ C} {X Y Z : C} {g h : X âŸ¶ ((â¨ f) âŠ— Y) âŠ— Z}\n    (w : âˆ€ j, g â‰« ((biproduct.Ï€ f j â–· Y) â–· Z) = h â‰« ((biproduct.Ï€ f j â–· Y) â–· Z)) :\n    g = h := by\n  apply (cancel_mono (Î±_ _ _ _).hom).mp\n  ext\n  simp [w]\n\n"}
