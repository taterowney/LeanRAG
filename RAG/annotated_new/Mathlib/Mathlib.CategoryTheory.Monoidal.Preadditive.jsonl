{"name":"CategoryTheory.MonoidalPreadditive.whiskerLeft_zero","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.MonoidalCategory C\nself : CategoryTheory.MonoidalPreadditive C\nX Y Z : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X 0) 0","decl":"/-- A category is `MonoidalPreadditive` if tensoring is additive in both factors.\n\nNote we don't `extend Preadditive C` here, as `Abelian C` already extends it,\nand we'll need to have both typeclasses sometimes.\n-/\nclass MonoidalPreadditive : Prop where\n  whiskerLeft_zero : ‚àÄ {X Y Z : C}, X ‚óÅ (0 : Y ‚ü∂ Z) = 0 := by aesop_cat\n  zero_whiskerRight : ‚àÄ {X Y Z : C}, (0 : Y ‚ü∂ Z) ‚ñ∑ X = 0 := by aesop_cat\n  whiskerLeft_add : ‚àÄ {X Y Z : C} (f g : Y ‚ü∂ Z), X ‚óÅ (f + g) = X ‚óÅ f + X ‚óÅ g := by aesop_cat\n  add_whiskerRight : ‚àÄ {X Y Z : C} (f g : Y ‚ü∂ Z), (f + g) ‚ñ∑ X = f ‚ñ∑ X + g ‚ñ∑ X := by aesop_cat\n\n"}
{"name":"CategoryTheory.MonoidalPreadditive.add_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.MonoidalCategory C\nself : CategoryTheory.MonoidalPreadditive C\nX Y Z : C\nf g : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight (HAdd.hAdd f g) X) (HAdd.hAdd (CategoryTheory.MonoidalCategoryStruct.whiskerRight f X) (CategoryTheory.MonoidalCategoryStruct.whiskerRight g X))","decl":"/-- A category is `MonoidalPreadditive` if tensoring is additive in both factors.\n\nNote we don't `extend Preadditive C` here, as `Abelian C` already extends it,\nand we'll need to have both typeclasses sometimes.\n-/\nclass MonoidalPreadditive : Prop where\n  whiskerLeft_zero : ‚àÄ {X Y Z : C}, X ‚óÅ (0 : Y ‚ü∂ Z) = 0 := by aesop_cat\n  zero_whiskerRight : ‚àÄ {X Y Z : C}, (0 : Y ‚ü∂ Z) ‚ñ∑ X = 0 := by aesop_cat\n  whiskerLeft_add : ‚àÄ {X Y Z : C} (f g : Y ‚ü∂ Z), X ‚óÅ (f + g) = X ‚óÅ f + X ‚óÅ g := by aesop_cat\n  add_whiskerRight : ‚àÄ {X Y Z : C} (f g : Y ‚ü∂ Z), (f + g) ‚ñ∑ X = f ‚ñ∑ X + g ‚ñ∑ X := by aesop_cat\n\n"}
{"name":"CategoryTheory.MonoidalPreadditive.zero_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.MonoidalCategory C\nself : CategoryTheory.MonoidalPreadditive C\nX Y Z : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight 0 X) 0","decl":"/-- A category is `MonoidalPreadditive` if tensoring is additive in both factors.\n\nNote we don't `extend Preadditive C` here, as `Abelian C` already extends it,\nand we'll need to have both typeclasses sometimes.\n-/\nclass MonoidalPreadditive : Prop where\n  whiskerLeft_zero : ‚àÄ {X Y Z : C}, X ‚óÅ (0 : Y ‚ü∂ Z) = 0 := by aesop_cat\n  zero_whiskerRight : ‚àÄ {X Y Z : C}, (0 : Y ‚ü∂ Z) ‚ñ∑ X = 0 := by aesop_cat\n  whiskerLeft_add : ‚àÄ {X Y Z : C} (f g : Y ‚ü∂ Z), X ‚óÅ (f + g) = X ‚óÅ f + X ‚óÅ g := by aesop_cat\n  add_whiskerRight : ‚àÄ {X Y Z : C} (f g : Y ‚ü∂ Z), (f + g) ‚ñ∑ X = f ‚ñ∑ X + g ‚ñ∑ X := by aesop_cat\n\n"}
{"name":"CategoryTheory.MonoidalPreadditive.whiskerLeft_add","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.MonoidalCategory C\nself : CategoryTheory.MonoidalPreadditive C\nX Y Z : C\nf g : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (HAdd.hAdd f g)) (HAdd.hAdd (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X g))","decl":"/-- A category is `MonoidalPreadditive` if tensoring is additive in both factors.\n\nNote we don't `extend Preadditive C` here, as `Abelian C` already extends it,\nand we'll need to have both typeclasses sometimes.\n-/\nclass MonoidalPreadditive : Prop where\n  whiskerLeft_zero : ‚àÄ {X Y Z : C}, X ‚óÅ (0 : Y ‚ü∂ Z) = 0 := by aesop_cat\n  zero_whiskerRight : ‚àÄ {X Y Z : C}, (0 : Y ‚ü∂ Z) ‚ñ∑ X = 0 := by aesop_cat\n  whiskerLeft_add : ‚àÄ {X Y Z : C} (f g : Y ‚ü∂ Z), X ‚óÅ (f + g) = X ‚óÅ f + X ‚óÅ g := by aesop_cat\n  add_whiskerRight : ‚àÄ {X Y Z : C} (f g : Y ‚ü∂ Z), (f + g) ‚ñ∑ X = f ‚ñ∑ X + g ‚ñ∑ X := by aesop_cat\n\n"}
{"name":"CategoryTheory.MonoidalPreadditive.tensor_zero","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.MonoidalPreadditive C\nW X Y Z : C\nf : Quiver.Hom W X\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f 0) 0","decl":"@[simp (low)]\ntheorem tensor_zero {W X Y Z : C} (f : W ‚ü∂ X) : f ‚äó (0 : Y ‚ü∂ Z) = 0 := by\n  simp [tensorHom_def]\n\n-- The priority setting will not be needed when we replace `f ‚äó ùüô X` by `f ‚ñ∑ X`.\n"}
{"name":"CategoryTheory.MonoidalPreadditive.zero_tensor","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.MonoidalPreadditive C\nW X Y Z : C\nf : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom 0 f) 0","decl":"@[simp (low)]\ntheorem zero_tensor {W X Y Z : C} (f : Y ‚ü∂ Z) : (0 : W ‚ü∂ X) ‚äó f = 0 := by\n  simp [tensorHom_def]\n\n"}
{"name":"CategoryTheory.MonoidalPreadditive.tensor_add","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.MonoidalPreadditive C\nW X Y Z : C\nf : Quiver.Hom W X\ng h : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f (HAdd.hAdd g h)) (HAdd.hAdd (CategoryTheory.MonoidalCategoryStruct.tensorHom f g) (CategoryTheory.MonoidalCategoryStruct.tensorHom f h))","decl":"theorem tensor_add {W X Y Z : C} (f : W ‚ü∂ X) (g h : Y ‚ü∂ Z) : f ‚äó (g + h) = f ‚äó g + f ‚äó h := by\n  simp [tensorHom_def]\n\n"}
{"name":"CategoryTheory.MonoidalPreadditive.add_tensor","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.MonoidalPreadditive C\nW X Y Z : C\nf g : Quiver.Hom W X\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom (HAdd.hAdd f g) h) (HAdd.hAdd (CategoryTheory.MonoidalCategoryStruct.tensorHom f h) (CategoryTheory.MonoidalCategoryStruct.tensorHom g h))","decl":"theorem add_tensor {W X Y Z : C} (f g : W ‚ü∂ X) (h : Y ‚ü∂ Z) : (f + g) ‚äó h = f ‚äó h + g ‚äó h := by\n  simp [tensorHom_def]\n\n"}
{"name":"CategoryTheory.tensorLeft_additive","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\n‚ä¢ (CategoryTheory.MonoidalCategory.tensorLeft X).Additive","decl":"instance tensorLeft_additive (X : C) : (tensorLeft X).Additive where\n\n"}
{"name":"CategoryTheory.tensorRight_additive","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\n‚ä¢ (CategoryTheory.MonoidalCategory.tensorRight X).Additive","decl":"instance tensorRight_additive (X : C) : (tensorRight X).Additive where\n\n"}
{"name":"CategoryTheory.tensoringLeft_additive","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\n‚ä¢ ((CategoryTheory.MonoidalCategory.tensoringLeft C).obj X).Additive","decl":"instance tensoringLeft_additive (X : C) : ((tensoringLeft C).obj X).Additive where\n\n"}
{"name":"CategoryTheory.tensoringRight_additive","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\n‚ä¢ ((CategoryTheory.MonoidalCategory.tensoringRight C).obj X).Additive","decl":"instance tensoringRight_additive (X : C) : ((tensoringRight C).obj X).Additive where\n\n"}
{"name":"CategoryTheory.monoidalPreadditive_of_faithful","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åπ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å∏ : CategoryTheory.Preadditive C\ninst‚úù‚Å∑ : CategoryTheory.MonoidalCategory C\ninst‚úù‚Å∂ : CategoryTheory.MonoidalPreadditive C\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_3, u_2} D\ninst‚úù‚Å¥ : CategoryTheory.Preadditive D\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory D\nF : CategoryTheory.Functor D C\ninst‚úù¬≤ : F.Monoidal\ninst‚úù¬π : F.Faithful\ninst‚úù : F.Additive\n‚ä¢ CategoryTheory.MonoidalPreadditive D","decl":"/-- A faithful additive monoidal functor to a monoidal preadditive category\nensures that the domain is monoidal preadditive. -/\ntheorem monoidalPreadditive_of_faithful {D} [Category D] [Preadditive D] [MonoidalCategory D]\n    (F : D ‚•§ C) [F.Monoidal] [F.Faithful] [F.Additive] :\n    MonoidalPreadditive D :=\n  { whiskerLeft_zero := by\n      intros\n      apply F.map_injective\n      simp [Functor.Monoidal.map_whiskerLeft]\n    zero_whiskerRight := by\n      intros\n      apply F.map_injective\n      simp [Functor.Monoidal.map_whiskerRight]\n    whiskerLeft_add := by\n      intros\n      apply F.map_injective\n      simp only [Functor.Monoidal.map_whiskerLeft, Functor.map_add, Preadditive.comp_add,\n        Preadditive.add_comp, MonoidalPreadditive.whiskerLeft_add]\n    add_whiskerRight := by\n      intros\n      apply F.map_injective\n      simp only [Functor.Monoidal.map_whiskerRight, Functor.map_add, Preadditive.comp_add,\n        Preadditive.add_comp, MonoidalPreadditive.add_whiskerRight] }\n\n"}
{"name":"CategoryTheory.whiskerLeft_sum","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.MonoidalPreadditive C\nP Q R : C\nJ : Type u_2\ns : Finset J\ng : J ‚Üí Quiver.Hom Q R\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft P (s.sum fun j => g j)) (s.sum fun j => CategoryTheory.MonoidalCategoryStruct.whiskerLeft P (g j))","decl":"theorem whiskerLeft_sum (P : C) {Q R : C} {J : Type*} (s : Finset J) (g : J ‚Üí (Q ‚ü∂ R)) :\n    P ‚óÅ ‚àë j ‚àà s, g j = ‚àë j ‚àà s, P ‚óÅ g j :=\n  map_sum ((tensoringLeft C).obj P).mapAddHom g s\n\n"}
{"name":"CategoryTheory.sum_whiskerRight","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.MonoidalPreadditive C\nQ R : C\nJ : Type u_2\ns : Finset J\ng : J ‚Üí Quiver.Hom Q R\nP : C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight (s.sum fun j => g j) P) (s.sum fun j => CategoryTheory.MonoidalCategoryStruct.whiskerRight (g j) P)","decl":"theorem sum_whiskerRight {Q R : C} {J : Type*} (s : Finset J) (g : J ‚Üí (Q ‚ü∂ R)) (P : C) :\n    (‚àë j ‚àà s, g j) ‚ñ∑ P = ‚àë j ‚àà s, g j ‚ñ∑ P :=\n  map_sum ((tensoringRight C).obj P).mapAddHom g s\n\n"}
{"name":"CategoryTheory.tensor_sum","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.MonoidalPreadditive C\nP Q R S : C\nJ : Type u_2\ns : Finset J\nf : Quiver.Hom P Q\ng : J ‚Üí Quiver.Hom R S\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f (s.sum fun j => g j)) (s.sum fun j => CategoryTheory.MonoidalCategoryStruct.tensorHom f (g j))","decl":"theorem tensor_sum {P Q R S : C} {J : Type*} (s : Finset J) (f : P ‚ü∂ Q) (g : J ‚Üí (R ‚ü∂ S)) :\n    (f ‚äó ‚àë j ‚àà s, g j) = ‚àë j ‚àà s, f ‚äó g j := by\n  simp only [tensorHom_def, whiskerLeft_sum, Preadditive.comp_sum]\n\n"}
{"name":"CategoryTheory.sum_tensor","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.MonoidalCategory C\ninst‚úù : CategoryTheory.MonoidalPreadditive C\nP Q R S : C\nJ : Type u_2\ns : Finset J\nf : Quiver.Hom P Q\ng : J ‚Üí Quiver.Hom R S\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom (s.sum fun j => g j) f) (s.sum fun j => CategoryTheory.MonoidalCategoryStruct.tensorHom (g j) f)","decl":"theorem sum_tensor {P Q R S : C} {J : Type*} (s : Finset J) (f : P ‚ü∂ Q) (g : J ‚Üí (R ‚ü∂ S)) :\n    (‚àë j ‚àà s, g j) ‚äó f = ‚àë j ‚àà s, g j ‚äó f := by\n  simp only [tensorHom_def, sum_whiskerRight, Preadditive.sum_comp]\n\n-- In a closed monoidal category, this would hold because\n-- `tensorLeft X` is a left adjoint and hence preserves all colimits.\n-- In any case it is true in any preadditive category.\n"}
{"name":"CategoryTheory.instPreservesFiniteBiproductsTensorLeft","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\n‚ä¢ CategoryTheory.Limits.PreservesFiniteBiproducts (CategoryTheory.MonoidalCategory.tensorLeft X)","decl":"instance (X : C) : PreservesFiniteBiproducts (tensorLeft X) where\n  preserves {J} :=\n    { preserves := fun {f} =>\n        { preserves := fun {b} i => ‚ü®isBilimitOfTotal _ (by\n            dsimp\n            simp_rw [‚Üê id_tensorHom]\n            simp only [‚Üê tensor_comp, Category.comp_id, ‚Üê tensor_sum, ‚Üê tensor_id,\n              IsBilimit.total i])‚ü© } }\n\n"}
{"name":"CategoryTheory.instPreservesFiniteBiproductsTensorRight","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.MonoidalCategory C\nX : C\n‚ä¢ CategoryTheory.Limits.PreservesFiniteBiproducts (CategoryTheory.MonoidalCategory.tensorRight X)","decl":"instance (X : C) : PreservesFiniteBiproducts (tensorRight X) where\n  preserves {J} :=\n    { preserves := fun {f} =>\n        { preserves := fun {b} i => ‚ü®isBilimitOfTotal _ (by\n            dsimp\n            simp_rw [‚Üê tensorHom_id]\n            simp only [‚Üê tensor_comp, Category.comp_id, ‚Üê sum_tensor, ‚Üê tensor_id,\n               IsBilimit.total i])‚ü© } }\n\n"}
{"name":"CategoryTheory.leftDistributor_hom","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nX : C\nf : J ‚Üí C\n‚ä¢ Eq (CategoryTheory.leftDistributor X f).hom (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.œÄ f j)) (CategoryTheory.Limits.biproduct.Œπ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) j))","decl":"theorem leftDistributor_hom {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :\n    (leftDistributor X f).hom =\n      ‚àë j : J, (X ‚óÅ biproduct.œÄ f j) ‚â´ biproduct.Œπ (fun j => X ‚äó f j) j := by\n  classical\n  ext\n  dsimp [leftDistributor, Functor.mapBiproduct, Functor.mapBicone]\n  erw [biproduct.lift_œÄ]\n  simp only [Preadditive.sum_comp, Category.assoc, biproduct.Œπ_œÄ, comp_dite, comp_zero,\n    Finset.sum_dite_eq', Finset.mem_univ, ite_true, eqToHom_refl, Category.comp_id]\n\n"}
{"name":"CategoryTheory.leftDistributor_inv","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nX : C\nf : J ‚Üí C\n‚ä¢ Eq (CategoryTheory.leftDistributor X f).inv (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.œÄ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) j) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Œπ f j)))","decl":"theorem leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) :\n    (leftDistributor X f).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (X ‚óÅ biproduct.Œπ f j) := by\n  classical\n  ext\n  dsimp [leftDistributor, Functor.mapBiproduct, Functor.mapBicone]\n  simp only [Preadditive.comp_sum, biproduct.Œπ_œÄ_assoc, dite_comp, zero_comp,\n    Finset.sum_dite_eq, Finset.mem_univ, ite_true, eqToHom_refl, Category.id_comp,\n    biproduct.Œπ_desc]\n\n"}
{"name":"CategoryTheory.leftDistributor_hom_comp_biproduct_œÄ_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nX : C\nf : J ‚Üí C\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftDistributor X f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.œÄ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.œÄ f j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem leftDistributor_hom_comp_biproduct_œÄ {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) (j : J) :\n    (leftDistributor X f).hom ‚â´ biproduct.œÄ _ j = X ‚óÅ biproduct.œÄ _ j := by\n  classical\n  simp [leftDistributor_hom, Preadditive.sum_comp, biproduct.Œπ_œÄ, comp_dite]\n\n"}
{"name":"CategoryTheory.leftDistributor_hom_comp_biproduct_œÄ","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nX : C\nf : J ‚Üí C\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftDistributor X f).hom (CategoryTheory.Limits.biproduct.œÄ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) j)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.œÄ f j))","decl":"@[reassoc (attr := simp)]\ntheorem leftDistributor_hom_comp_biproduct_œÄ {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) (j : J) :\n    (leftDistributor X f).hom ‚â´ biproduct.œÄ _ j = X ‚óÅ biproduct.œÄ _ j := by\n  classical\n  simp [leftDistributor_hom, Preadditive.sum_comp, biproduct.Œπ_œÄ, comp_dite]\n\n"}
{"name":"CategoryTheory.biproduct_Œπ_comp_leftDistributor_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nX : C\nf : J ‚Üí C\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Œπ f j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftDistributor X f).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Œπ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) j) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct_Œπ_comp_leftDistributor_hom {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) (j : J) :\n    (X ‚óÅ biproduct.Œπ _ j) ‚â´ (leftDistributor X f).hom = biproduct.Œπ (fun j => X ‚äó f j) j := by\n  classical\n  simp [leftDistributor_hom, Preadditive.comp_sum, ‚Üê MonoidalCategory.whiskerLeft_comp_assoc,\n    biproduct.Œπ_œÄ, whiskerLeft_dite, dite_comp]\n\n"}
{"name":"CategoryTheory.biproduct_Œπ_comp_leftDistributor_hom","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nX : C\nf : J ‚Üí C\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Œπ f j)) (CategoryTheory.leftDistributor X f).hom) (CategoryTheory.Limits.biproduct.Œπ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) j)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct_Œπ_comp_leftDistributor_hom {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) (j : J) :\n    (X ‚óÅ biproduct.Œπ _ j) ‚â´ (leftDistributor X f).hom = biproduct.Œπ (fun j => X ‚äó f j) j := by\n  classical\n  simp [leftDistributor_hom, Preadditive.comp_sum, ‚Üê MonoidalCategory.whiskerLeft_comp_assoc,\n    biproduct.Œπ_œÄ, whiskerLeft_dite, dite_comp]\n\n"}
{"name":"CategoryTheory.leftDistributor_inv_comp_biproduct_œÄ","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nX : C\nf : J ‚Üí C\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftDistributor X f).inv (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.œÄ f j))) (CategoryTheory.Limits.biproduct.œÄ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) j)","decl":"@[reassoc (attr := simp)]\ntheorem leftDistributor_inv_comp_biproduct_œÄ {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) (j : J) :\n    (leftDistributor X f).inv ‚â´ (X ‚óÅ biproduct.œÄ _ j) = biproduct.œÄ _ j := by\n  classical\n  simp [leftDistributor_inv, Preadditive.sum_comp, ‚Üê MonoidalCategory.whiskerLeft_comp,\n    biproduct.Œπ_œÄ, whiskerLeft_dite, comp_dite]\n\n"}
{"name":"CategoryTheory.leftDistributor_inv_comp_biproduct_œÄ_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nX : C\nf : J ‚Üí C\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftDistributor X f).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.œÄ f j)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.œÄ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) j) h)","decl":"@[reassoc (attr := simp)]\ntheorem leftDistributor_inv_comp_biproduct_œÄ {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) (j : J) :\n    (leftDistributor X f).inv ‚â´ (X ‚óÅ biproduct.œÄ _ j) = biproduct.œÄ _ j := by\n  classical\n  simp [leftDistributor_inv, Preadditive.sum_comp, ‚Üê MonoidalCategory.whiskerLeft_comp,\n    biproduct.Œπ_œÄ, whiskerLeft_dite, comp_dite]\n\n"}
{"name":"CategoryTheory.biproduct_Œπ_comp_leftDistributor_inv","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nX : C\nf : J ‚Üí C\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Œπ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) j) (CategoryTheory.leftDistributor X f).inv) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Œπ f j))","decl":"@[reassoc (attr := simp)]\ntheorem biproduct_Œπ_comp_leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) (j : J) :\n    biproduct.Œπ _ j ‚â´ (leftDistributor X f).inv = X ‚óÅ biproduct.Œπ _ j := by\n  classical\n  simp [leftDistributor_inv, Preadditive.comp_sum, ‚Üê id_tensor_comp, biproduct.Œπ_œÄ_assoc, dite_comp]\n\n"}
{"name":"CategoryTheory.biproduct_Œπ_comp_leftDistributor_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nX : C\nf : J ‚Üí C\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.Limits.biproduct f)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Œπ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.leftDistributor X f).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Œπ f j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct_Œπ_comp_leftDistributor_inv {J : Type} [Fintype J] (X : C) (f : J ‚Üí C) (j : J) :\n    biproduct.Œπ _ j ‚â´ (leftDistributor X f).inv = X ‚óÅ biproduct.Œπ _ j := by\n  classical\n  simp [leftDistributor_inv, Preadditive.comp_sum, ‚Üê id_tensor_comp, biproduct.Œπ_œÄ_assoc, dite_comp]\n\n"}
{"name":"CategoryTheory.leftDistributor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nX Y : C\nf : J ‚Üí C\n‚ä¢ Eq ((CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.asIso (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.leftDistributor Y f)).trans (CategoryTheory.leftDistributor X fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj Y (f j))) ((CategoryTheory.MonoidalCategoryStruct.associator X Y (CategoryTheory.Limits.biproduct f)).symm.trans ((CategoryTheory.leftDistributor (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y) f).trans (CategoryTheory.Limits.biproduct.mapIso fun x => CategoryTheory.MonoidalCategoryStruct.associator X Y (f x))))","decl":"theorem leftDistributor_assoc {J : Type} [Fintype J] (X Y : C) (f : J ‚Üí C) :\n    (asIso (ùüô X) ‚äó leftDistributor Y f) ‚â™‚â´ leftDistributor X _ =\n      (Œ±_ X Y (‚®Å f)).symm ‚â™‚â´ leftDistributor (X ‚äó Y) f ‚â™‚â´ biproduct.mapIso fun _ => Œ±_ X Y _ := by\n  classical\n  ext\n  simp only [Category.comp_id, Category.assoc, eqToHom_refl, Iso.trans_hom, Iso.symm_hom,\n    asIso_hom, comp_zero, comp_dite, Preadditive.sum_comp, Preadditive.comp_sum, tensor_sum,\n    id_tensor_comp, tensorIso_hom, leftDistributor_hom, biproduct.mapIso_hom, biproduct.Œπ_map,\n    biproduct.Œπ_œÄ, Finset.sum_dite_irrel, Finset.sum_dite_eq', Finset.sum_const_zero]\n  simp_rw [‚Üê id_tensorHom]\n  simp only [‚Üê id_tensor_comp, biproduct.Œπ_œÄ]\n  simp only [id_tensor_comp, tensor_dite, comp_dite]\n  simp\n\n"}
{"name":"CategoryTheory.rightDistributor_hom","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nf : J ‚Üí C\nX : C\n‚ä¢ Eq (CategoryTheory.rightDistributor f X).hom (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.œÄ f j) X) (CategoryTheory.Limits.biproduct.Œπ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) j))","decl":"theorem rightDistributor_hom {J : Type} [Fintype J] (f : J ‚Üí C) (X : C) :\n    (rightDistributor f X).hom =\n      ‚àë j : J, (biproduct.œÄ f j ‚ñ∑ X) ‚â´ biproduct.Œπ (fun j => f j ‚äó X) j := by\n  classical\n  ext\n  dsimp [rightDistributor, Functor.mapBiproduct, Functor.mapBicone]\n  erw [biproduct.lift_œÄ]\n  simp only [Preadditive.sum_comp, Category.assoc, biproduct.Œπ_œÄ, comp_dite, comp_zero,\n    Finset.sum_dite_eq', Finset.mem_univ, eqToHom_refl, Category.comp_id, ite_true]\n\n"}
{"name":"CategoryTheory.rightDistributor_inv","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nf : J ‚Üí C\nX : C\n‚ä¢ Eq (CategoryTheory.rightDistributor f X).inv (Finset.univ.sum fun j => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.œÄ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) j) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Œπ f j) X))","decl":"theorem rightDistributor_inv {J : Type} [Fintype J] (f : J ‚Üí C) (X : C) :\n    (rightDistributor f X).inv = ‚àë j : J, biproduct.œÄ _ j ‚â´ (biproduct.Œπ f j ‚ñ∑ X) := by\n  classical\n  ext\n  dsimp [rightDistributor, Functor.mapBiproduct, Functor.mapBicone]\n  simp only [biproduct.Œπ_desc, Preadditive.comp_sum, ne_eq, biproduct.Œπ_œÄ_assoc, dite_comp,\n    zero_comp, Finset.sum_dite_eq, Finset.mem_univ, eqToHom_refl, Category.id_comp, ite_true]\n\n"}
{"name":"CategoryTheory.rightDistributor_hom_comp_biproduct_œÄ","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nf : J ‚Üí C\nX : C\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightDistributor f X).hom (CategoryTheory.Limits.biproduct.œÄ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) j)) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.œÄ f j) X)","decl":"@[reassoc (attr := simp)]\ntheorem rightDistributor_hom_comp_biproduct_œÄ {J : Type} [Fintype J] (f : J ‚Üí C) (X : C) (j : J) :\n    (rightDistributor f X).hom ‚â´ biproduct.œÄ _ j = biproduct.œÄ _ j ‚ñ∑ X := by\n  classical\n  simp [rightDistributor_hom, Preadditive.sum_comp, biproduct.Œπ_œÄ, comp_dite]\n\n"}
{"name":"CategoryTheory.rightDistributor_hom_comp_biproduct_œÄ_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nf : J ‚Üí C\nX : C\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightDistributor f X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.œÄ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.œÄ f j) X) h)","decl":"@[reassoc (attr := simp)]\ntheorem rightDistributor_hom_comp_biproduct_œÄ {J : Type} [Fintype J] (f : J ‚Üí C) (X : C) (j : J) :\n    (rightDistributor f X).hom ‚â´ biproduct.œÄ _ j = biproduct.œÄ _ j ‚ñ∑ X := by\n  classical\n  simp [rightDistributor_hom, Preadditive.sum_comp, biproduct.Œπ_œÄ, comp_dite]\n\n"}
{"name":"CategoryTheory.biproduct_Œπ_comp_rightDistributor_hom","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nf : J ‚Üí C\nX : C\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Œπ f j) X) (CategoryTheory.rightDistributor f X).hom) (CategoryTheory.Limits.biproduct.Œπ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) j)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct_Œπ_comp_rightDistributor_hom {J : Type} [Fintype J] (f : J ‚Üí C) (X : C) (j : J) :\n    (biproduct.Œπ _ j ‚ñ∑ X) ‚â´ (rightDistributor f X).hom = biproduct.Œπ (fun j => f j ‚äó X) j := by\n  classical\n  simp [rightDistributor_hom, Preadditive.comp_sum, ‚Üê comp_whiskerRight_assoc, biproduct.Œπ_œÄ,\n    dite_whiskerRight, dite_comp]\n\n"}
{"name":"CategoryTheory.biproduct_Œπ_comp_rightDistributor_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nf : J ‚Üí C\nX : C\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.biproduct fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Œπ f j) X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightDistributor f X).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Œπ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) j) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct_Œπ_comp_rightDistributor_hom {J : Type} [Fintype J] (f : J ‚Üí C) (X : C) (j : J) :\n    (biproduct.Œπ _ j ‚ñ∑ X) ‚â´ (rightDistributor f X).hom = biproduct.Œπ (fun j => f j ‚äó X) j := by\n  classical\n  simp [rightDistributor_hom, Preadditive.comp_sum, ‚Üê comp_whiskerRight_assoc, biproduct.Œπ_œÄ,\n    dite_whiskerRight, dite_comp]\n\n"}
{"name":"CategoryTheory.rightDistributor_inv_comp_biproduct_œÄ","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nf : J ‚Üí C\nX : C\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightDistributor f X).inv (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.œÄ f j) X)) (CategoryTheory.Limits.biproduct.œÄ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) j)","decl":"@[reassoc (attr := simp)]\ntheorem rightDistributor_inv_comp_biproduct_œÄ {J : Type} [Fintype J] (f : J ‚Üí C) (X : C) (j : J) :\n    (rightDistributor f X).inv ‚â´ (biproduct.œÄ _ j ‚ñ∑ X) = biproduct.œÄ _ j := by\n  classical\n  simp [rightDistributor_inv, Preadditive.sum_comp, ‚Üê MonoidalCategory.comp_whiskerRight,\n    biproduct.Œπ_œÄ, dite_whiskerRight, comp_dite]\n\n"}
{"name":"CategoryTheory.rightDistributor_inv_comp_biproduct_œÄ_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nf : J ‚Üí C\nX : C\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightDistributor f X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.œÄ f j) X) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.œÄ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) j) h)","decl":"@[reassoc (attr := simp)]\ntheorem rightDistributor_inv_comp_biproduct_œÄ {J : Type} [Fintype J] (f : J ‚Üí C) (X : C) (j : J) :\n    (rightDistributor f X).inv ‚â´ (biproduct.œÄ _ j ‚ñ∑ X) = biproduct.œÄ _ j := by\n  classical\n  simp [rightDistributor_inv, Preadditive.sum_comp, ‚Üê MonoidalCategory.comp_whiskerRight,\n    biproduct.Œπ_œÄ, dite_whiskerRight, comp_dite]\n\n"}
{"name":"CategoryTheory.biproduct_Œπ_comp_rightDistributor_inv_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nf : J ‚Üí C\nX : C\nj : J\nZ : C\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.Limits.biproduct f) X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Œπ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.rightDistributor f X).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Œπ f j) X) h)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct_Œπ_comp_rightDistributor_inv {J : Type} [Fintype J] (f : J ‚Üí C) (X : C) (j : J) :\n    biproduct.Œπ _ j ‚â´ (rightDistributor f X).inv = biproduct.Œπ _ j ‚ñ∑ X := by\n  classical\n  simp [rightDistributor_inv, Preadditive.comp_sum, ‚Üê id_tensor_comp, biproduct.Œπ_œÄ_assoc,\n    dite_comp]\n\n"}
{"name":"CategoryTheory.biproduct_Œπ_comp_rightDistributor_inv","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nf : J ‚Üí C\nX : C\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.biproduct.Œπ (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) j) (CategoryTheory.rightDistributor f X).inv) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Œπ f j) X)","decl":"@[reassoc (attr := simp)]\ntheorem biproduct_Œπ_comp_rightDistributor_inv {J : Type} [Fintype J] (f : J ‚Üí C) (X : C) (j : J) :\n    biproduct.Œπ _ j ‚â´ (rightDistributor f X).inv = biproduct.Œπ _ j ‚ñ∑ X := by\n  classical\n  simp [rightDistributor_inv, Preadditive.comp_sum, ‚Üê id_tensor_comp, biproduct.Œπ_œÄ_assoc,\n    dite_comp]\n\n"}
{"name":"CategoryTheory.rightDistributor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nf : J ‚Üí C\nX Y : C\n‚ä¢ Eq ((CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.rightDistributor f X) (CategoryTheory.asIso (CategoryTheory.CategoryStruct.id Y))).trans (CategoryTheory.rightDistributor (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) X) Y)) ((CategoryTheory.MonoidalCategoryStruct.associator (CategoryTheory.Limits.biproduct f) X Y).trans ((CategoryTheory.rightDistributor f (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y)).trans (CategoryTheory.Limits.biproduct.mapIso fun x => (CategoryTheory.MonoidalCategoryStruct.associator (f x) X Y).symm)))","decl":"theorem rightDistributor_assoc {J : Type} [Fintype J] (f : J ‚Üí C) (X Y : C) :\n    (rightDistributor f X ‚äó asIso (ùüô Y)) ‚â™‚â´ rightDistributor _ Y =\n      Œ±_ (‚®Å f) X Y ‚â™‚â´ rightDistributor f (X ‚äó Y) ‚â™‚â´ biproduct.mapIso fun _ => (Œ±_ _ X Y).symm := by\n  classical\n  ext\n  simp only [Category.comp_id, Category.assoc, eqToHom_refl, Iso.symm_hom, Iso.trans_hom,\n    asIso_hom, comp_zero, comp_dite, Preadditive.sum_comp, Preadditive.comp_sum, sum_tensor,\n    comp_tensor_id, tensorIso_hom, rightDistributor_hom, biproduct.mapIso_hom, biproduct.Œπ_map,\n    biproduct.Œπ_œÄ, Finset.sum_dite_irrel, Finset.sum_dite_eq', Finset.sum_const_zero,\n    Finset.mem_univ, if_true]\n  simp_rw [‚Üê tensorHom_id]\n  simp only [‚Üê comp_tensor_id, biproduct.Œπ_œÄ, dite_tensor, comp_dite]\n  simp\n\n"}
{"name":"CategoryTheory.leftDistributor_rightDistributor_assoc","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nX : C\nf : J ‚Üí C\nY : C\n‚ä¢ Eq ((CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.leftDistributor X f) (CategoryTheory.asIso (CategoryTheory.CategoryStruct.id Y))).trans (CategoryTheory.rightDistributor (fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj X (f j)) Y)) ((CategoryTheory.MonoidalCategoryStruct.associator X (CategoryTheory.Limits.biproduct f) Y).trans ((CategoryTheory.MonoidalCategory.tensorIso (CategoryTheory.asIso (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.rightDistributor f Y)).trans ((CategoryTheory.leftDistributor X fun j => CategoryTheory.MonoidalCategoryStruct.tensorObj (f j) Y).trans (CategoryTheory.Limits.biproduct.mapIso fun x => (CategoryTheory.MonoidalCategoryStruct.associator X (f x) Y).symm))))","decl":"theorem leftDistributor_rightDistributor_assoc {J : Type _} [Fintype J]\n    (X : C) (f : J ‚Üí C) (Y : C) :\n    (leftDistributor X f ‚äó asIso (ùüô Y)) ‚â™‚â´ rightDistributor _ Y =\n      Œ±_ X (‚®Å f) Y ‚â™‚â´\n        (asIso (ùüô X) ‚äó rightDistributor _ Y) ‚â™‚â´\n          leftDistributor X _ ‚â™‚â´ biproduct.mapIso fun _ => (Œ±_ _ _ _).symm := by\n  classical\n  ext\n  simp only [Category.comp_id, Category.assoc, eqToHom_refl, Iso.symm_hom, Iso.trans_hom,\n    asIso_hom, comp_zero, comp_dite, Preadditive.sum_comp, Preadditive.comp_sum, sum_tensor,\n    tensor_sum, comp_tensor_id, tensorIso_hom, leftDistributor_hom, rightDistributor_hom,\n    biproduct.mapIso_hom, biproduct.Œπ_map, biproduct.Œπ_œÄ, Finset.sum_dite_irrel,\n    Finset.sum_dite_eq', Finset.sum_const_zero, Finset.mem_univ, if_true]\n  simp_rw [‚Üê tensorHom_id, ‚Üê id_tensorHom]\n  simp only [‚Üê comp_tensor_id, ‚Üê id_tensor_comp_assoc, Category.assoc, biproduct.Œπ_œÄ, comp_dite,\n    dite_comp, tensor_dite, dite_tensor]\n  simp\n\n"}
{"name":"CategoryTheory.leftDistributor_ext_left_iff","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nX Y : C\nf : J ‚Üí C\ng h : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.Limits.biproduct f)) Y\n‚ä¢ Iff (Eq g h) (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Œπ f j)) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Œπ f j)) h))","decl":"@[ext]\ntheorem leftDistributor_ext_left {J : Type} [Fintype J] {X Y : C} {f : J ‚Üí C} {g h : X ‚äó ‚®Å f ‚ü∂ Y}\n    (w : ‚àÄ j, (X ‚óÅ biproduct.Œπ f j) ‚â´ g = (X ‚óÅ biproduct.Œπ f j) ‚â´ h) : g = h := by\n  classical\n  apply (cancel_epi (leftDistributor X f).inv).mp\n  ext\n  simp? [leftDistributor_inv, Preadditive.comp_sum_assoc, biproduct.Œπ_œÄ_assoc, dite_comp] says\n    simp only [leftDistributor_inv, Preadditive.comp_sum_assoc, biproduct.Œπ_œÄ_assoc, dite_comp,\n      zero_comp, Finset.sum_dite_eq, Finset.mem_univ, ‚ÜìreduceIte, eqToHom_refl, Category.id_comp]\n  apply w\n\n"}
{"name":"CategoryTheory.leftDistributor_ext_left","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nX Y : C\nf : J ‚Üí C\ng h : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.Limits.biproduct f)) Y\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Œπ f j)) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.Limits.biproduct.Œπ f j)) h)\n‚ä¢ Eq g h","decl":"@[ext]\ntheorem leftDistributor_ext_left {J : Type} [Fintype J] {X Y : C} {f : J ‚Üí C} {g h : X ‚äó ‚®Å f ‚ü∂ Y}\n    (w : ‚àÄ j, (X ‚óÅ biproduct.Œπ f j) ‚â´ g = (X ‚óÅ biproduct.Œπ f j) ‚â´ h) : g = h := by\n  classical\n  apply (cancel_epi (leftDistributor X f).inv).mp\n  ext\n  simp? [leftDistributor_inv, Preadditive.comp_sum_assoc, biproduct.Œπ_œÄ_assoc, dite_comp] says\n    simp only [leftDistributor_inv, Preadditive.comp_sum_assoc, biproduct.Œπ_œÄ_assoc, dite_comp,\n      zero_comp, Finset.sum_dite_eq, Finset.mem_univ, ‚ÜìreduceIte, eqToHom_refl, Category.id_comp]\n  apply w\n\n"}
{"name":"CategoryTheory.leftDistributor_ext_right","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nX Y : C\nf : J ‚Üí C\ng h : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y (CategoryTheory.Limits.biproduct f))\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.Limits.biproduct.œÄ f j))) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.Limits.biproduct.œÄ f j)))\n‚ä¢ Eq g h","decl":"@[ext]\ntheorem leftDistributor_ext_right {J : Type} [Fintype J] {X Y : C} {f : J ‚Üí C} {g h : X ‚ü∂ Y ‚äó ‚®Å f}\n    (w : ‚àÄ j, g ‚â´ (Y ‚óÅ biproduct.œÄ f j) = h ‚â´ (Y ‚óÅ biproduct.œÄ f j)) : g = h := by\n  classical\n  apply (cancel_mono (leftDistributor Y f).hom).mp\n  ext\n  simp? [leftDistributor_hom, Preadditive.sum_comp, Preadditive.comp_sum_assoc, biproduct.Œπ_œÄ,\n      comp_dite] says\n    simp only [leftDistributor_hom, Category.assoc, Preadditive.sum_comp, biproduct.Œπ_œÄ, comp_dite,\n      comp_zero, Finset.sum_dite_eq', Finset.mem_univ, ‚ÜìreduceIte, eqToHom_refl, Category.comp_id]\n\n  apply w\n\n-- One might wonder how many iterated tensor products we need simp lemmas for.\n-- The answer is two: this lemma is needed to verify the pentagon identity.\n"}
{"name":"CategoryTheory.leftDistributor_ext_right_iff","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nX Y : C\nf : J ‚Üí C\ng h : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y (CategoryTheory.Limits.biproduct f))\n‚ä¢ Iff (Eq g h) (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.Limits.biproduct.œÄ f j))) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.Limits.biproduct.œÄ f j))))","decl":"@[ext]\ntheorem leftDistributor_ext_right {J : Type} [Fintype J] {X Y : C} {f : J ‚Üí C} {g h : X ‚ü∂ Y ‚äó ‚®Å f}\n    (w : ‚àÄ j, g ‚â´ (Y ‚óÅ biproduct.œÄ f j) = h ‚â´ (Y ‚óÅ biproduct.œÄ f j)) : g = h := by\n  classical\n  apply (cancel_mono (leftDistributor Y f).hom).mp\n  ext\n  simp? [leftDistributor_hom, Preadditive.sum_comp, Preadditive.comp_sum_assoc, biproduct.Œπ_œÄ,\n      comp_dite] says\n    simp only [leftDistributor_hom, Category.assoc, Preadditive.sum_comp, biproduct.Œπ_œÄ, comp_dite,\n      comp_zero, Finset.sum_dite_eq', Finset.mem_univ, ‚ÜìreduceIte, eqToHom_refl, Category.comp_id]\n\n  apply w\n\n-- One might wonder how many iterated tensor products we need simp lemmas for.\n-- The answer is two: this lemma is needed to verify the pentagon identity.\n"}
{"name":"CategoryTheory.leftDistributor_ext‚ÇÇ_left_iff","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nX Y Z : C\nf : J ‚Üí C\ng h : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y (CategoryTheory.Limits.biproduct f))) Z\n‚ä¢ Iff (Eq g h) (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.Limits.biproduct.Œπ f j))) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.Limits.biproduct.Œπ f j))) h))","decl":"@[ext]\ntheorem leftDistributor_ext‚ÇÇ_left {J : Type} [Fintype J]\n    {X Y Z : C} {f : J ‚Üí C} {g h : X ‚äó (Y ‚äó ‚®Å f) ‚ü∂ Z}\n    (w : ‚àÄ j, (X ‚óÅ (Y ‚óÅ biproduct.Œπ f j)) ‚â´ g = (X ‚óÅ (Y ‚óÅ biproduct.Œπ f j)) ‚â´ h) :\n    g = h := by\n  apply (cancel_epi (Œ±_ _ _ _).hom).mp\n  ext\n  simp [w]\n\n"}
{"name":"CategoryTheory.leftDistributor_ext‚ÇÇ_left","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nX Y Z : C\nf : J ‚Üí C\ng h : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y (CategoryTheory.Limits.biproduct f))) Z\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.Limits.biproduct.Œπ f j))) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.Limits.biproduct.Œπ f j))) h)\n‚ä¢ Eq g h","decl":"@[ext]\ntheorem leftDistributor_ext‚ÇÇ_left {J : Type} [Fintype J]\n    {X Y Z : C} {f : J ‚Üí C} {g h : X ‚äó (Y ‚äó ‚®Å f) ‚ü∂ Z}\n    (w : ‚àÄ j, (X ‚óÅ (Y ‚óÅ biproduct.Œπ f j)) ‚â´ g = (X ‚óÅ (Y ‚óÅ biproduct.Œπ f j)) ‚â´ h) :\n    g = h := by\n  apply (cancel_epi (Œ±_ _ _ _).hom).mp\n  ext\n  simp [w]\n\n"}
{"name":"CategoryTheory.leftDistributor_ext‚ÇÇ_right_iff","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nX Y Z : C\nf : J ‚Üí C\ng h : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y (CategoryTheory.MonoidalCategoryStruct.tensorObj Z (CategoryTheory.Limits.biproduct f)))\n‚ä¢ Iff (Eq g h) (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z (CategoryTheory.Limits.biproduct.œÄ f j)))) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z (CategoryTheory.Limits.biproduct.œÄ f j)))))","decl":"@[ext]\ntheorem leftDistributor_ext‚ÇÇ_right {J : Type} [Fintype J]\n    {X Y Z : C} {f : J ‚Üí C} {g h : X ‚ü∂ Y ‚äó (Z ‚äó ‚®Å f)}\n    (w : ‚àÄ j, g ‚â´ (Y ‚óÅ (Z ‚óÅ biproduct.œÄ f j)) = h ‚â´ (Y ‚óÅ (Z ‚óÅ biproduct.œÄ f j))) :\n    g = h := by\n  apply (cancel_mono (Œ±_ _ _ _).inv).mp\n  ext\n  simp [w]\n\n"}
{"name":"CategoryTheory.leftDistributor_ext‚ÇÇ_right","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nX Y Z : C\nf : J ‚Üí C\ng h : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj Y (CategoryTheory.MonoidalCategoryStruct.tensorObj Z (CategoryTheory.Limits.biproduct f)))\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z (CategoryTheory.Limits.biproduct.œÄ f j)))) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Y (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z (CategoryTheory.Limits.biproduct.œÄ f j))))\n‚ä¢ Eq g h","decl":"@[ext]\ntheorem leftDistributor_ext‚ÇÇ_right {J : Type} [Fintype J]\n    {X Y Z : C} {f : J ‚Üí C} {g h : X ‚ü∂ Y ‚äó (Z ‚äó ‚®Å f)}\n    (w : ‚àÄ j, g ‚â´ (Y ‚óÅ (Z ‚óÅ biproduct.œÄ f j)) = h ‚â´ (Y ‚óÅ (Z ‚óÅ biproduct.œÄ f j))) :\n    g = h := by\n  apply (cancel_mono (Œ±_ _ _ _).inv).mp\n  ext\n  simp [w]\n\n"}
{"name":"CategoryTheory.rightDistributor_ext_left_iff","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nf : J ‚Üí C\nX Y : C\ng h : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.Limits.biproduct f) X) Y\n‚ä¢ Iff (Eq g h) (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Œπ f j) X) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Œπ f j) X) h))","decl":"@[ext]\ntheorem rightDistributor_ext_left {J : Type} [Fintype J]\n    {f : J ‚Üí C} {X Y : C} {g h : (‚®Å f) ‚äó X ‚ü∂ Y}\n    (w : ‚àÄ j, (biproduct.Œπ f j ‚ñ∑ X) ‚â´ g = (biproduct.Œπ f j ‚ñ∑ X) ‚â´ h) : g = h := by\n  classical\n  apply (cancel_epi (rightDistributor f X).inv).mp\n  ext\n  simp? [rightDistributor_inv, Preadditive.comp_sum_assoc, biproduct.Œπ_œÄ_assoc, dite_comp] says\n    simp only [rightDistributor_inv, Preadditive.comp_sum_assoc, biproduct.Œπ_œÄ_assoc, dite_comp,\n      zero_comp, Finset.sum_dite_eq, Finset.mem_univ, ‚ÜìreduceIte, eqToHom_refl, Category.id_comp]\n  apply w\n\n"}
{"name":"CategoryTheory.rightDistributor_ext_left","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nf : J ‚Üí C\nX Y : C\ng h : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.Limits.biproduct f) X) Y\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Œπ f j) X) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Œπ f j) X) h)\n‚ä¢ Eq g h","decl":"@[ext]\ntheorem rightDistributor_ext_left {J : Type} [Fintype J]\n    {f : J ‚Üí C} {X Y : C} {g h : (‚®Å f) ‚äó X ‚ü∂ Y}\n    (w : ‚àÄ j, (biproduct.Œπ f j ‚ñ∑ X) ‚â´ g = (biproduct.Œπ f j ‚ñ∑ X) ‚â´ h) : g = h := by\n  classical\n  apply (cancel_epi (rightDistributor f X).inv).mp\n  ext\n  simp? [rightDistributor_inv, Preadditive.comp_sum_assoc, biproduct.Œπ_œÄ_assoc, dite_comp] says\n    simp only [rightDistributor_inv, Preadditive.comp_sum_assoc, biproduct.Œπ_œÄ_assoc, dite_comp,\n      zero_comp, Finset.sum_dite_eq, Finset.mem_univ, ‚ÜìreduceIte, eqToHom_refl, Category.id_comp]\n  apply w\n\n"}
{"name":"CategoryTheory.rightDistributor_ext_right_iff","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nf : J ‚Üí C\nX Y : C\ng h : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.Limits.biproduct f) Y)\n‚ä¢ Iff (Eq g h) (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.œÄ f j) Y)) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.œÄ f j) Y)))","decl":"@[ext]\ntheorem rightDistributor_ext_right {J : Type} [Fintype J]\n    {f : J ‚Üí C} {X Y : C} {g h : X ‚ü∂ (‚®Å f) ‚äó Y}\n    (w : ‚àÄ j, g ‚â´ (biproduct.œÄ f j ‚ñ∑ Y) = h ‚â´ (biproduct.œÄ f j ‚ñ∑ Y)) : g = h := by\n  classical\n  apply (cancel_mono (rightDistributor f Y).hom).mp\n  ext\n  simp? [rightDistributor_hom, Preadditive.sum_comp, Preadditive.comp_sum_assoc, biproduct.Œπ_œÄ,\n      comp_dite] says\n    simp only [rightDistributor_hom, Category.assoc, Preadditive.sum_comp, biproduct.Œπ_œÄ, comp_dite,\n      comp_zero, Finset.sum_dite_eq', Finset.mem_univ, ‚ÜìreduceIte, eqToHom_refl, Category.comp_id]\n  apply w\n\n"}
{"name":"CategoryTheory.rightDistributor_ext_right","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nf : J ‚Üí C\nX Y : C\ng h : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.Limits.biproduct f) Y)\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.œÄ f j) Y)) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.œÄ f j) Y))\n‚ä¢ Eq g h","decl":"@[ext]\ntheorem rightDistributor_ext_right {J : Type} [Fintype J]\n    {f : J ‚Üí C} {X Y : C} {g h : X ‚ü∂ (‚®Å f) ‚äó Y}\n    (w : ‚àÄ j, g ‚â´ (biproduct.œÄ f j ‚ñ∑ Y) = h ‚â´ (biproduct.œÄ f j ‚ñ∑ Y)) : g = h := by\n  classical\n  apply (cancel_mono (rightDistributor f Y).hom).mp\n  ext\n  simp? [rightDistributor_hom, Preadditive.sum_comp, Preadditive.comp_sum_assoc, biproduct.Œπ_œÄ,\n      comp_dite] says\n    simp only [rightDistributor_hom, Category.assoc, Preadditive.sum_comp, biproduct.Œπ_œÄ, comp_dite,\n      comp_zero, Finset.sum_dite_eq', Finset.mem_univ, ‚ÜìreduceIte, eqToHom_refl, Category.comp_id]\n  apply w\n\n"}
{"name":"CategoryTheory.rightDistributor_ext‚ÇÇ_left_iff","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nf : J ‚Üí C\nX Y Z : C\ng h : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.Limits.biproduct f) X) Y) Z\n‚ä¢ Iff (Eq g h) (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Œπ f j) X) Y) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Œπ f j) X) Y) h))","decl":"@[ext]\ntheorem rightDistributor_ext‚ÇÇ_left {J : Type} [Fintype J]\n    {f : J ‚Üí C} {X Y Z : C} {g h : ((‚®Å f) ‚äó X) ‚äó Y ‚ü∂ Z}\n    (w : ‚àÄ j, ((biproduct.Œπ f j ‚ñ∑ X) ‚ñ∑ Y) ‚â´ g = ((biproduct.Œπ f j ‚ñ∑ X) ‚ñ∑ Y) ‚â´ h) :\n    g = h := by\n  apply (cancel_epi (Œ±_ _ _ _).inv).mp\n  ext\n  simp [w]\n\n"}
{"name":"CategoryTheory.rightDistributor_ext‚ÇÇ_left","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nf : J ‚Üí C\nX Y Z : C\ng h : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.Limits.biproduct f) X) Y) Z\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Œπ f j) X) Y) g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.Œπ f j) X) Y) h)\n‚ä¢ Eq g h","decl":"@[ext]\ntheorem rightDistributor_ext‚ÇÇ_left {J : Type} [Fintype J]\n    {f : J ‚Üí C} {X Y Z : C} {g h : ((‚®Å f) ‚äó X) ‚äó Y ‚ü∂ Z}\n    (w : ‚àÄ j, ((biproduct.Œπ f j ‚ñ∑ X) ‚ñ∑ Y) ‚â´ g = ((biproduct.Œπ f j ‚ñ∑ X) ‚ñ∑ Y) ‚â´ h) :\n    g = h := by\n  apply (cancel_epi (Œ±_ _ _ _).inv).mp\n  ext\n  simp [w]\n\n"}
{"name":"CategoryTheory.rightDistributor_ext‚ÇÇ_right","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nf : J ‚Üí C\nX Y Z : C\ng h : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.Limits.biproduct f) Y) Z)\nw : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.œÄ f j) Y) Z)) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.œÄ f j) Y) Z))\n‚ä¢ Eq g h","decl":"@[ext]\ntheorem rightDistributor_ext‚ÇÇ_right {J : Type} [Fintype J]\n    {f : J ‚Üí C} {X Y Z : C} {g h : X ‚ü∂ ((‚®Å f) ‚äó Y) ‚äó Z}\n    (w : ‚àÄ j, g ‚â´ ((biproduct.œÄ f j ‚ñ∑ Y) ‚ñ∑ Z) = h ‚â´ ((biproduct.œÄ f j ‚ñ∑ Y) ‚ñ∑ Z)) :\n    g = h := by\n  apply (cancel_mono (Œ±_ _ _ _).hom).mp\n  ext\n  simp [w]\n\n"}
{"name":"CategoryTheory.rightDistributor_ext‚ÇÇ_right_iff","module":"Mathlib.CategoryTheory.Monoidal.Preadditive","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≤ : CategoryTheory.MonoidalPreadditive C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteBiproducts C\nJ : Type\ninst‚úù : Fintype J\nf : J ‚Üí C\nX Y Z : C\ng h : Quiver.Hom X (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.MonoidalCategoryStruct.tensorObj (CategoryTheory.Limits.biproduct f) Y) Z)\n‚ä¢ Iff (Eq g h) (‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.œÄ f j) Y) Z)) (CategoryTheory.CategoryStruct.comp h (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.biproduct.œÄ f j) Y) Z)))","decl":"@[ext]\ntheorem rightDistributor_ext‚ÇÇ_right {J : Type} [Fintype J]\n    {f : J ‚Üí C} {X Y Z : C} {g h : X ‚ü∂ ((‚®Å f) ‚äó Y) ‚äó Z}\n    (w : ‚àÄ j, g ‚â´ ((biproduct.œÄ f j ‚ñ∑ Y) ‚ñ∑ Z) = h ‚â´ ((biproduct.œÄ f j ‚ñ∑ Y) ‚ñ∑ Z)) :\n    g = h := by\n  apply (cancel_mono (Œ±_ _ _ _).hom).mp\n  ext\n  simp [w]\n\n"}
