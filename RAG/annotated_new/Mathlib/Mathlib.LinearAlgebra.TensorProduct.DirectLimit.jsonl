{"name":"TensorProduct.fromDirectLimit_of_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.DirectLimit","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nι : Type u_2\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Preorder ι\nG : ι → Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (G i)\ninst✝² : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ni : ι\ng : G i\nm : M\n⊢ Eq ((TensorProduct.fromDirectLimit f M) ((Module.DirectLimit.of R ι (fun x => TensorProduct R (G x) M) (fun i j h => LinearMap.rTensor M (f i j h)) i) (TensorProduct.tmul R g m))) (TensorProduct.tmul R ((Module.DirectLimit.of R ι G f i) g) m)","decl":"variable {M} in\n@[simp] lemma fromDirectLimit_of_tmul {i : ι} (g : G i) (m : M) :\n    fromDirectLimit f M (of _ _ _ _ i (g ⊗ₜ m)) = (of _ _ _ f i g) ⊗ₜ m :=\n  lift_of (G := (G · ⊗[R] M)) _ _ (g ⊗ₜ m)\n\n"}
{"name":"TensorProduct.toDirectLimit_tmul_of","module":"Mathlib.LinearAlgebra.TensorProduct.DirectLimit","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nι : Type u_2\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Preorder ι\nG : ι → Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (G i)\ninst✝² : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ni : ι\ng : G i\nm : M\n⊢ Eq ((TensorProduct.toDirectLimit f M) (TensorProduct.tmul R ((Module.DirectLimit.of R ι G f i) g) m)) ((Module.DirectLimit.of R ι (fun x => TensorProduct R (G x) M) (fun i j h => LinearMap.rTensor M (f i j h)) i) (TensorProduct.tmul R g m))","decl":"variable {M} in\n@[simp] lemma toDirectLimit_tmul_of\n    {i : ι} (g : G i) (m : M) :\n    (toDirectLimit f M <| (of _ _ G f i g) ⊗ₜ m) = (of _ _ _ _ i (g ⊗ₜ m)) := by\n  rw [toDirectLimit, lift.tmul, lift_of]\n  rfl\n\n"}
{"name":"TensorProduct.directLimitLeft_tmul_of","module":"Mathlib.LinearAlgebra.TensorProduct.DirectLimit","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nι : Type u_2\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Preorder ι\nG : ι → Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (G i)\ninst✝² : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ni : ι\ng : G i\nm : M\n⊢ Eq ((TensorProduct.directLimitLeft f M) (TensorProduct.tmul R ((Module.DirectLimit.of R ι G f i) g) m)) ((Module.DirectLimit.of R ι (fun i => TensorProduct R (G i) M) (fun i j h => LinearMap.rTensor M (f i j h)) i) (TensorProduct.tmul R g m))","decl":"@[simp] lemma directLimitLeft_tmul_of {i : ι} (g : G i) (m : M) :\n    directLimitLeft f M (of _ _ _ _ _ g ⊗ₜ m) = of _ _ _ (f ▷ M) _ (g ⊗ₜ m) :=\n  toDirectLimit_tmul_of f g m\n\n"}
{"name":"TensorProduct.directLimitLeft_symm_of_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.DirectLimit","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nι : Type u_2\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Preorder ι\nG : ι → Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (G i)\ninst✝² : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ni : ι\ng : G i\nm : M\n⊢ Eq ((TensorProduct.directLimitLeft f M).symm ((Module.DirectLimit.of R ι (fun x => TensorProduct R (G x) M) (fun i j h => LinearMap.rTensor M (f i j h)) i) (TensorProduct.tmul R g m))) (TensorProduct.tmul R ((Module.DirectLimit.of R ι G f i) g) m)","decl":"@[simp] lemma directLimitLeft_symm_of_tmul {i : ι} (g : G i) (m : M) :\n    (directLimitLeft f M).symm (of _ _ _ _ _ (g ⊗ₜ m)) = of _ _ _ f _ g ⊗ₜ m :=\n  fromDirectLimit_of_tmul f g m\n\n"}
{"name":"TensorProduct.directLimitLeft_rTensor_of","module":"Mathlib.LinearAlgebra.TensorProduct.DirectLimit","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nι : Type u_2\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Preorder ι\nG : ι → Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (G i)\ninst✝² : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ni : ι\nx : TensorProduct R (G i) M\n⊢ Eq ((TensorProduct.directLimitLeft f M) ((LinearMap.rTensor M (Module.DirectLimit.of R ι G f i)) x)) ((Module.DirectLimit.of R ι (fun i => TensorProduct R (G i) M) (fun i j h => LinearMap.rTensor M (f i j h)) i) x)","decl":"lemma directLimitLeft_rTensor_of {i : ι} (x : G i ⊗[R] M) :\n    directLimitLeft f M (LinearMap.rTensor M (of ..) x) = of _ _ _ (f ▷ M) _ x :=\n  x.induction_on (by simp) (by simp+contextual) (by simp+contextual)\n\n"}
{"name":"TensorProduct.directLimitRight_tmul_of","module":"Mathlib.LinearAlgebra.TensorProduct.DirectLimit","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nι : Type u_2\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Preorder ι\nG : ι → Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (G i)\ninst✝² : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ni : ι\nm : M\ng : G i\n⊢ Eq ((TensorProduct.directLimitRight f M) (TensorProduct.tmul R m ((Module.DirectLimit.of R ι G f i) g))) ((Module.DirectLimit.of R ι (fun x => TensorProduct R M (G x)) (fun i j h => LinearMap.lTensor M (f i j h)) i) (TensorProduct.tmul R m g))","decl":"@[simp] lemma directLimitRight_tmul_of {i : ι} (m : M) (g : G i) :\n    directLimitRight f M (m ⊗ₜ of _ _ _ _ _ g) = of _ _ _ _ i (m ⊗ₜ g) := by\n  simp [directLimitRight, congr_apply_of]\n\n"}
{"name":"TensorProduct.directLimitRight_symm_of_tmul","module":"Mathlib.LinearAlgebra.TensorProduct.DirectLimit","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nι : Type u_2\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Preorder ι\nG : ι → Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (G i)\ninst✝² : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ni : ι\nm : M\ng : G i\n⊢ Eq ((TensorProduct.directLimitRight f M).symm ((Module.DirectLimit.of R ι (fun x => TensorProduct R M (G x)) (fun i j h => LinearMap.lTensor M (f i j h)) i) (TensorProduct.tmul R m g))) (TensorProduct.tmul R m ((Module.DirectLimit.of R ι G f i) g))","decl":"@[simp] lemma directLimitRight_symm_of_tmul {i : ι} (m : M) (g : G i) :\n    (directLimitRight f M).symm (of _ _ _ _ _ (m ⊗ₜ g)) = m ⊗ₜ of _ _ _ f _ g := by\n  simp [directLimitRight, congr_symm_apply_of]\n\n"}
{"name":"TensorProduct.instDirectedSystemCoeLinearMapIdRTensor","module":"Mathlib.LinearAlgebra.TensorProduct.DirectLimit","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nι : Type u_2\ninst✝⁴ : Preorder ι\nG : ι → Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (G i)\ninst✝² : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ DirectedSystem (fun x => TensorProduct R (G x) M) fun i j h => ⇑(LinearMap.rTensor M (f i j h))","decl":"instance : DirectedSystem (G · ⊗[R] M) (f ▷ M) where\n  map_self i x := by\n    convert LinearMap.rTensor_id_apply M (G i) x; ext; apply DirectedSystem.map_self'\n  map_map _ _ _ _ _ x := by\n    convert ← (LinearMap.rTensor_comp_apply M _ _ x).symm; ext; apply DirectedSystem.map_map' f\n\n"}
{"name":"TensorProduct.instDirectedSystemCoeLinearMapIdLTensor","module":"Mathlib.LinearAlgebra.TensorProduct.DirectLimit","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nι : Type u_2\ninst✝⁴ : Preorder ι\nG : ι → Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (G i)\ninst✝² : (i : ι) → Module R (G i)\nf : (i j : ι) → LE.le i j → LinearMap (RingHom.id R) (G i) (G j)\nM : Type u_4\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ DirectedSystem (fun x => TensorProduct R M (G x)) fun i j h => ⇑(LinearMap.lTensor M (f i j h))","decl":"instance : DirectedSystem (M ⊗[R] G ·) (M ◁ f) where\n  map_self i x := by\n    convert LinearMap.lTensor_id_apply M _ x; ext; apply DirectedSystem.map_self'\n  map_map _ _ _ h₁ h₂ x := by\n    convert ← (LinearMap.lTensor_comp_apply M _ _ x).symm; ext; apply DirectedSystem.map_map' f\n\n"}
