{"name":"volume_regionBetween_eq_integral'","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Integral","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → Real\ns : Set α\ninst✝ : MeasureTheory.SigmaFinite μ\nf_int : MeasureTheory.IntegrableOn f s μ\ng_int : MeasureTheory.IntegrableOn g s μ\nhs : MeasurableSet s\nhfg : (MeasureTheory.ae (μ.restrict s)).EventuallyLE f g\n⊢ Eq ((μ.prod MeasureTheory.MeasureSpace.volume) (regionBetween f g s)) (ENNReal.ofReal (MeasureTheory.integral (μ.restrict s) fun y => HSub.hSub g f y))","decl":"theorem volume_regionBetween_eq_integral' [SigmaFinite μ] (f_int : IntegrableOn f s μ)\n    (g_int : IntegrableOn g s μ) (hs : MeasurableSet s) (hfg : f ≤ᵐ[μ.restrict s] g) :\n    μ.prod volume (regionBetween f g s) = ENNReal.ofReal (∫ y in s, (g - f) y ∂μ) := by\n  have h : g - f =ᵐ[μ.restrict s] fun x => Real.toNNReal (g x - f x) :=\n    hfg.mono fun x hx => (Real.coe_toNNReal _ <| sub_nonneg.2 hx).symm\n  rw [volume_regionBetween_eq_lintegral f_int.aemeasurable g_int.aemeasurable hs,\n    integral_congr_ae h, lintegral_congr_ae,\n    lintegral_coe_eq_integral _ ((integrable_congr h).mp (g_int.sub f_int))]\n  dsimp only\n  rfl\n\n"}
{"name":"volume_regionBetween_eq_integral","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Integral","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → Real\ns : Set α\ninst✝ : MeasureTheory.SigmaFinite μ\nf_int : MeasureTheory.IntegrableOn f s μ\ng_int : MeasureTheory.IntegrableOn g s μ\nhs : MeasurableSet s\nhfg : ∀ (x : α), Membership.mem s x → LE.le (f x) (g x)\n⊢ Eq ((μ.prod MeasureTheory.MeasureSpace.volume) (regionBetween f g s)) (ENNReal.ofReal (MeasureTheory.integral (μ.restrict s) fun y => HSub.hSub g f y))","decl":"/-- If two functions are integrable on a measurable set, and one function is less than\n    or equal to the other on that set, then the volume of the region\n    between the two functions can be represented as an integral. -/\ntheorem volume_regionBetween_eq_integral [SigmaFinite μ] (f_int : IntegrableOn f s μ)\n    (g_int : IntegrableOn g s μ) (hs : MeasurableSet s) (hfg : ∀ x ∈ s, f x ≤ g x) :\n    μ.prod volume (regionBetween f g s) = ENNReal.ofReal (∫ y in s, (g - f) y ∂μ) :=\n  volume_regionBetween_eq_integral' f_int g_int hs\n    ((ae_restrict_iff' hs).mpr (Eventually.of_forall hfg))\n\n"}
{"name":"Real.integrable_of_summable_norm_Icc","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Integral","initialProofState":"E : Type u_1\ninst✝ : NormedAddCommGroup E\nf : ContinuousMap Real E\nhf : Summable fun n => Norm.norm (ContinuousMap.restrict (Set.Icc 0 1) (f.comp (ContinuousMap.addRight ↑n)))\n⊢ MeasureTheory.Integrable (⇑f) MeasureTheory.MeasureSpace.volume","decl":"/-- If the sequence with `n`-th term the sup norm of `fun x ↦ f (x + n)` on the interval `Icc 0 1`,\nfor `n ∈ ℤ`, is summable, then `f` is integrable on `ℝ`. -/\ntheorem Real.integrable_of_summable_norm_Icc {E : Type*} [NormedAddCommGroup E] {f : C(ℝ, E)}\n    (hf : Summable fun n : ℤ => ‖(f.comp <| ContinuousMap.addRight n).restrict (Icc 0 1)‖) :\n    Integrable f := by\n  refine integrable_of_summable_norm_restrict (.of_nonneg_of_le\n    (fun n : ℤ => mul_nonneg (norm_nonneg\n      (f.restrict (⟨Icc (n : ℝ) ((n : ℝ) + 1), isCompact_Icc⟩ : Compacts ℝ)))\n        ENNReal.toReal_nonneg) (fun n => ?_) hf) ?_\n  · simp only [Compacts.coe_mk, Real.volume_Icc, add_sub_cancel_left,\n      ENNReal.toReal_ofReal zero_le_one, mul_one, norm_le _ (norm_nonneg _)]\n    intro x\n    have := ((f.comp <| ContinuousMap.addRight n).restrict (Icc 0 1)).norm_coe_le_norm\n        ⟨x - n, ⟨sub_nonneg.mpr x.2.1, sub_le_iff_le_add'.mpr x.2.2⟩⟩\n    simpa only [ContinuousMap.restrict_apply, comp_apply, coe_addRight, Subtype.coe_mk,\n      sub_add_cancel] using this\n  · exact iUnion_Icc_intCast ℝ\n\n"}
{"name":"integral_comp_neg_Iic","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Integral","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nc : Real\nf : Real → E\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Iic c)) fun x => f (Neg.neg x)) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi (Neg.neg c))) fun x => f x)","decl":"theorem integral_comp_neg_Iic {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]\n    (c : ℝ) (f : ℝ → E) : (∫ x in Iic c, f (-x)) = ∫ x in Ioi (-c), f x := by\n  have A : MeasurableEmbedding fun x : ℝ => -x :=\n    (Homeomorph.neg ℝ).isClosedEmbedding.measurableEmbedding\n  have := MeasurableEmbedding.setIntegral_map (μ := volume) A f (Ici (-c))\n  rw [Measure.map_neg_eq_self (volume : Measure ℝ)] at this\n  simp_rw [← integral_Ici_eq_integral_Ioi, this, neg_preimage, neg_Ici, neg_neg]\n\n/- @[simp] Porting note: Linter complains it does not apply to itself. Although it does apply to\nitself, it does not apply when `f` is more complicated -/\n"}
{"name":"integral_comp_neg_Ioi","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Integral","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nc : Real\nf : Real → E\n⊢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi c)) fun x => f (Neg.neg x)) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Iic (Neg.neg c))) fun x => f x)","decl":"theorem integral_comp_neg_Ioi {E : Type*} [NormedAddCommGroup E] [NormedSpace ℝ E]\n    (c : ℝ) (f : ℝ → E) : (∫ x in Ioi c, f (-x)) = ∫ x in Iic (-c), f x := by\n  rw [← neg_neg c, ← integral_comp_neg_Iic]\n  simp only [neg_neg]\n\n"}
{"name":"integral_comp_abs","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Integral","initialProofState":"f : Real → Real\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => f (abs x)) (HMul.hMul 2 (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun x => f x))","decl":"theorem integral_comp_abs {f : ℝ → ℝ} :\n    ∫ x, f |x| = 2 * ∫ x in Ioi (0 : ℝ), f x := by\n  have eq : ∫ (x : ℝ) in Ioi 0, f |x| = ∫ (x : ℝ) in Ioi 0, f x := by\n    refine setIntegral_congr_fun measurableSet_Ioi (fun _ hx => ?_)\n    rw [abs_eq_self.mpr (le_of_lt (by exact hx))]\n  by_cases hf : IntegrableOn (fun x => f |x|) (Ioi 0)\n  · have int_Iic : IntegrableOn (fun x ↦ f |x|) (Iic 0) := by\n      rw [← Measure.map_neg_eq_self (volume : Measure ℝ)]\n      let m : MeasurableEmbedding fun x : ℝ => -x := (Homeomorph.neg ℝ).measurableEmbedding\n      rw [m.integrableOn_map_iff]\n      simp_rw [Function.comp_def, abs_neg, neg_preimage, neg_Iic, neg_zero]\n      exact integrableOn_Ici_iff_integrableOn_Ioi.mpr hf\n    calc\n      _ = (∫ x in Iic 0, f |x|) + ∫ x in Ioi 0, f |x| := by\n        rw [← setIntegral_union (Iic_disjoint_Ioi le_rfl) measurableSet_Ioi int_Iic hf,\n          Iic_union_Ioi, restrict_univ]\n      _ = 2 * ∫ x in Ioi 0, f x := by\n        rw [two_mul, eq]\n        congr! 1\n        rw [← neg_zero, ← integral_comp_neg_Iic, neg_zero]\n        refine setIntegral_congr_fun measurableSet_Iic (fun _ hx => ?_)\n        rw [abs_eq_neg_self.mpr (by exact hx)]\n  · have : ¬ Integrable (fun x => f |x|) := by\n      contrapose! hf\n      exact hf.integrableOn\n    rw [← eq, integral_undef hf, integral_undef this, mul_zero]\n"}
