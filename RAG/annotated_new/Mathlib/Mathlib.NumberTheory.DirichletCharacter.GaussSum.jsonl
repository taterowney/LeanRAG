{"name":"gaussSum_aux_of_mulShift","module":"Mathlib.NumberTheory.DirichletCharacter.GaussSum","initialProofState":"N : Nat\ninst✝¹ : NeZero N\nR : Type u_1\ninst✝ : CommRing R\ne : AddChar (ZMod N) R\nχ : DirichletCharacter R N\nd : Nat\nhd : Dvd.dvd d N\nhe : Eq (e.mulShift ↑d) 1\nu : Units (ZMod N)\nhu : Eq ((ZMod.unitsMap hd) u) 1\n⊢ Eq (HMul.hMul (χ ↑u) (gaussSum χ e)) (gaussSum χ e)","decl":"lemma gaussSum_aux_of_mulShift (χ : DirichletCharacter R N) {d : ℕ}\n    (hd : d ∣ N) (he : e.mulShift d = 1) {u : (ZMod N)ˣ} (hu : ZMod.unitsMap hd u = 1) :\n    χ u * gaussSum χ e = gaussSum χ e := by\n  suffices e.mulShift u = e by conv_lhs => rw [← this, gaussSum_mulShift]\n  rw [(by ring : u.val = (u - 1) + 1), ← mulShift_mul, mulShift_one, mul_left_eq_self]\n  rsuffices ⟨a, ha⟩ : (d : ℤ) ∣ (u.val.val - 1 : ℤ)\n  · have : u.val - 1 = ↑(u.val.val - 1 : ℤ) := by simp only [ZMod.natCast_val, Int.cast_sub,\n      ZMod.intCast_cast, ZMod.cast_id', id_eq, Int.cast_one]\n    rw [this, ha]\n    ext1 y\n    simpa only [Int.cast_mul, Int.cast_natCast, mulShift_apply, mul_assoc, one_apply]\n      using DFunLike.ext_iff.mp he (a * y)\n  rw [← Units.eq_iff, Units.val_one, ZMod.unitsMap_def, Units.coe_map] at hu\n  have : ZMod.castHom hd (ZMod d) u.val = ((u.val.val : ℤ) : ZMod d) := by simp\n  rwa [MonoidHom.coe_coe, this, ← Int.cast_one, eq_comm,\n    ZMod.intCast_eq_intCast_iff_dvd_sub] at hu\n\n"}
{"name":"factorsThrough_of_gaussSum_ne_zero","module":"Mathlib.NumberTheory.DirichletCharacter.GaussSum","initialProofState":"N : Nat\ninst✝² : NeZero N\nR : Type u_1\ninst✝¹ : CommRing R\ne : AddChar (ZMod N) R\ninst✝ : IsDomain R\nχ : DirichletCharacter R N\nd : Nat\nhd : Dvd.dvd d N\nhe : Eq (e.mulShift ↑d) 1\nh_ne : Ne (gaussSum χ e) 0\n⊢ χ.FactorsThrough d","decl":"/-- If `gaussSum χ e ≠ 0`, and `d` is such that `e.mulShift d = 1`, then `χ` must factor through\n`d`. (This will be used to show that Gauss sums vanish when `χ` is primitive and `e` is not.) -/\nlemma factorsThrough_of_gaussSum_ne_zero [IsDomain R] {χ : DirichletCharacter R N} {d : ℕ}\n    (hd : d ∣ N) (he : e.mulShift d = 1) (h_ne : gaussSum χ e ≠ 0) :\n    χ.FactorsThrough d := by\n  rw [DirichletCharacter.factorsThrough_iff_ker_unitsMap hd]\n  intro u hu\n  rw [MonoidHom.mem_ker, ← Units.eq_iff, MulChar.coe_toUnitHom]\n  simpa only [Units.val_one, ne_eq, h_ne, not_false_eq_true, mul_eq_right₀] using\n    gaussSum_aux_of_mulShift e χ hd he hu\n\n"}
{"name":"gaussSum_eq_zero_of_isPrimitive_of_not_isPrimitive","module":"Mathlib.NumberTheory.DirichletCharacter.GaussSum","initialProofState":"N : Nat\ninst✝² : NeZero N\nR : Type u_1\ninst✝¹ : CommRing R\ne : AddChar (ZMod N) R\ninst✝ : IsDomain R\nχ : DirichletCharacter R N\nhχ : χ.IsPrimitive\nhe : Not e.IsPrimitive\n⊢ Eq (gaussSum χ e) 0","decl":"/-- If `χ` is primitive, but `e` is not, then `gaussSum χ e = 0`. -/\nlemma gaussSum_eq_zero_of_isPrimitive_of_not_isPrimitive [IsDomain R]\n    {χ : DirichletCharacter R N} (hχ : IsPrimitive χ) (he : ¬IsPrimitive e) :\n    gaussSum χ e = 0 := by\n  contrapose! hχ\n  rcases e.exists_divisor_of_not_isPrimitive he with ⟨d, hd₁, hd₂, hed⟩\n  have : χ.conductor ≤ d := Nat.sInf_le <| factorsThrough_of_gaussSum_ne_zero e hd₁ hed hχ\n  exact (this.trans_lt hd₂).ne\n\n"}
{"name":"gaussSum_mulShift_of_isPrimitive","module":"Mathlib.NumberTheory.DirichletCharacter.GaussSum","initialProofState":"N : Nat\ninst✝² : NeZero N\nR : Type u_1\ninst✝¹ : CommRing R\ne : AddChar (ZMod N) R\ninst✝ : IsDomain R\nχ : DirichletCharacter R N\nhχ : χ.IsPrimitive\na : ZMod N\n⊢ Eq (gaussSum χ (e.mulShift a)) (HMul.hMul ((Inv.inv χ) a) (gaussSum χ e))","decl":"/-- If `χ` is a primitive character, then the function `a ↦ gaussSum χ (e.mulShift a)`, for any\nfixed additive character `e`, is a constant multiple of `χ⁻¹`. -/\nlemma gaussSum_mulShift_of_isPrimitive [IsDomain R] {χ : DirichletCharacter R N}\n    (hχ : IsPrimitive χ) (a : ZMod N) :\n    gaussSum χ (e.mulShift a) = χ⁻¹ a * gaussSum χ e := by\n  by_cases ha : IsUnit a\n  · conv_rhs => rw [← gaussSum_mulShift χ e ha.unit]\n    rw [IsUnit.unit_spec, MulChar.inv_apply_eq_inv, Ring.inverse_mul_cancel_left _ _ (ha.map χ)]\n  · rw [MulChar.map_nonunit _ ha, zero_mul]\n    exact gaussSum_eq_zero_of_isPrimitive_of_not_isPrimitive _ hχ (not_isPrimitive_mulShift e ha)\n"}
