{"name":"BoundedAdd.isBounded_add","module":"Mathlib.Topology.Bornology.BoundedOperation","initialProofState":"R : Type u_1\ninst✝¹ : Bornology R\ninst✝ : Add R\nself : BoundedAdd R\ns t : Set R\na✝¹ : Bornology.IsBounded s\na✝ : Bornology.IsBounded t\n⊢ Bornology.IsBounded (HAdd.hAdd s t)","decl":"/-- A typeclass saying that `(p : R × R) ↦ p.1 + p.2` maps any product of bounded sets to a bounded\nset. This property follows from `LipschitzAdd`, and thus automatically holds, e.g., for seminormed\nadditive groups. -/\nclass BoundedAdd (R : Type*) [Bornology R] [Add R] : Prop where\n  isBounded_add : ∀ {s t : Set R},\n    Bornology.IsBounded s → Bornology.IsBounded t → Bornology.IsBounded (s + t)\n\n"}
{"name":"isBounded_add","module":"Mathlib.Topology.Bornology.BoundedOperation","initialProofState":"R : Type u_1\ninst✝² : Bornology R\ninst✝¹ : Add R\ninst✝ : BoundedAdd R\ns t : Set R\nhs : Bornology.IsBounded s\nht : Bornology.IsBounded t\n⊢ Bornology.IsBounded (HAdd.hAdd s t)","decl":"lemma isBounded_add [Bornology R] [Add R] [BoundedAdd R] {s t : Set R}\n    (hs : Bornology.IsBounded s) (ht : Bornology.IsBounded t) :\n    Bornology.IsBounded (s + t) := BoundedAdd.isBounded_add hs ht\n\n"}
{"name":"add_bounded_of_bounded_of_bounded","module":"Mathlib.Topology.Bornology.BoundedOperation","initialProofState":"R : Type u_1\nX : Type u_2\ninst✝² : PseudoMetricSpace R\ninst✝¹ : Add R\ninst✝ : BoundedAdd R\nf g : X → R\nf_bdd : Exists fun C => ∀ (x y : X), LE.le (Dist.dist (f x) (f y)) C\ng_bdd : Exists fun C => ∀ (x y : X), LE.le (Dist.dist (g x) (g y)) C\n⊢ Exists fun C => ∀ (x y : X), LE.le (Dist.dist (HAdd.hAdd f g x) (HAdd.hAdd f g y)) C","decl":"lemma add_bounded_of_bounded_of_bounded {X : Type*} [PseudoMetricSpace R] [Add R] [BoundedAdd R]\n    {f g : X → R} (f_bdd : ∃ C, ∀ x y, dist (f x) (f y) ≤ C)\n    (g_bdd : ∃ C, ∀ x y, dist (g x) (g y) ≤ C) :\n    ∃ C, ∀ x y, dist ((f + g) x) ((f + g) y) ≤ C := by\n  obtain ⟨C, hC⟩ := Metric.isBounded_iff.mp <|\n    isBounded_add (Metric.isBounded_range_iff.mpr f_bdd) (Metric.isBounded_range_iff.mpr g_bdd)\n  use C\n  intro x y\n  exact hC (Set.add_mem_add (Set.mem_range_self (f := f) x) (Set.mem_range_self (f := g) x))\n           (Set.add_mem_add (Set.mem_range_self (f := f) y) (Set.mem_range_self (f := g) y))\n\n"}
{"name":"instBoundedAddOfLipschitzAdd","module":"Mathlib.Topology.Bornology.BoundedOperation","initialProofState":"R : Type u_1\ninst✝² : PseudoMetricSpace R\ninst✝¹ : AddMonoid R\ninst✝ : LipschitzAdd R\n⊢ BoundedAdd R","decl":"instance [PseudoMetricSpace R] [AddMonoid R] [LipschitzAdd R] : BoundedAdd R where\n  isBounded_add {s t} s_bdd t_bdd := by\n    have bdd : Bornology.IsBounded (s ×ˢ t) := Bornology.IsBounded.prod s_bdd t_bdd\n    obtain ⟨C, add_lip⟩ := ‹LipschitzAdd R›.lipschitz_add\n    convert add_lip.isBounded_image bdd\n    ext p\n    simp only [Set.mem_image, Set.mem_prod, Prod.exists]\n    constructor\n    · intro ⟨a, a_in_s, b, b_in_t, eq_p⟩\n      exact ⟨a, b, ⟨a_in_s, b_in_t⟩, eq_p⟩\n    · intro ⟨a, b, ⟨a_in_s, b_in_t⟩, eq_p⟩\n      simpa [← eq_p] using Set.add_mem_add a_in_s b_in_t\n\n"}
{"name":"BoundedSub.isBounded_sub","module":"Mathlib.Topology.Bornology.BoundedOperation","initialProofState":"R : Type u_1\ninst✝¹ : Bornology R\ninst✝ : Sub R\nself : BoundedSub R\ns t : Set R\na✝¹ : Bornology.IsBounded s\na✝ : Bornology.IsBounded t\n⊢ Bornology.IsBounded (HSub.hSub s t)","decl":"/-- A typeclass saying that `(p : R × R) ↦ p.1 - p.2` maps any product of bounded sets to a bounded\nset. This property automatically holds for seminormed additive groups, but it also holds, e.g.,\nfor `ℝ≥0`. -/\nclass BoundedSub (R : Type*) [Bornology R] [Sub R] : Prop where\n  isBounded_sub : ∀ {s t : Set R},\n    Bornology.IsBounded s → Bornology.IsBounded t → Bornology.IsBounded (s - t)\n\n"}
{"name":"isBounded_sub","module":"Mathlib.Topology.Bornology.BoundedOperation","initialProofState":"R : Type u_1\ninst✝² : Bornology R\ninst✝¹ : Sub R\ninst✝ : BoundedSub R\ns t : Set R\nhs : Bornology.IsBounded s\nht : Bornology.IsBounded t\n⊢ Bornology.IsBounded (HSub.hSub s t)","decl":"lemma isBounded_sub [Bornology R] [Sub R] [BoundedSub R] {s t : Set R}\n    (hs : Bornology.IsBounded s) (ht : Bornology.IsBounded t) :\n    Bornology.IsBounded (s - t) := BoundedSub.isBounded_sub hs ht\n\n"}
{"name":"sub_bounded_of_bounded_of_bounded","module":"Mathlib.Topology.Bornology.BoundedOperation","initialProofState":"R : Type u_1\nX : Type u_2\ninst✝² : PseudoMetricSpace R\ninst✝¹ : Sub R\ninst✝ : BoundedSub R\nf g : X → R\nf_bdd : Exists fun C => ∀ (x y : X), LE.le (Dist.dist (f x) (f y)) C\ng_bdd : Exists fun C => ∀ (x y : X), LE.le (Dist.dist (g x) (g y)) C\n⊢ Exists fun C => ∀ (x y : X), LE.le (Dist.dist (HSub.hSub f g x) (HSub.hSub f g y)) C","decl":"lemma sub_bounded_of_bounded_of_bounded {X : Type*} [PseudoMetricSpace R] [Sub R] [BoundedSub R]\n    {f g : X → R} (f_bdd : ∃ C, ∀ x y, dist (f x) (f y) ≤ C)\n    (g_bdd : ∃ C, ∀ x y, dist (g x) (g y) ≤ C) :\n    ∃ C, ∀ x y, dist ((f - g) x) ((f - g) y) ≤ C := by\n  obtain ⟨C, hC⟩ := Metric.isBounded_iff.mp <|\n    isBounded_sub (Metric.isBounded_range_iff.mpr f_bdd) (Metric.isBounded_range_iff.mpr g_bdd)\n  use C\n  intro x y\n  exact hC (Set.sub_mem_sub (Set.mem_range_self (f := f) x) (Set.mem_range_self (f := g) x))\n           (Set.sub_mem_sub (Set.mem_range_self (f := f) y) (Set.mem_range_self (f := g) y))\n\n"}
{"name":"boundedSub_of_lipschitzWith_sub","module":"Mathlib.Topology.Bornology.BoundedOperation","initialProofState":"R : Type u_1\ninst✝¹ : PseudoMetricSpace R\ninst✝ : Sub R\nK : NNReal\nlip : LipschitzWith K fun p => HSub.hSub p.1 p.2\n⊢ BoundedSub R","decl":"lemma boundedSub_of_lipschitzWith_sub [PseudoMetricSpace R] [Sub R] {K : NNReal}\n    (lip : LipschitzWith K (fun (p : R × R) ↦ p.1 - p.2)) :\n    BoundedSub R where\n  isBounded_sub {s t} s_bdd t_bdd := by\n    have bdd : Bornology.IsBounded (s ×ˢ t) := Bornology.IsBounded.prod s_bdd t_bdd\n    convert lip.isBounded_image bdd\n    ext p\n    simp only [Set.mem_image, Set.mem_prod, Prod.exists]\n    constructor\n    · intro ⟨a, a_in_s, b, b_in_t, eq_p⟩\n      exact ⟨a, b, ⟨a_in_s, b_in_t⟩, eq_p⟩\n    · intro ⟨a, b, ⟨a_in_s, b_in_t⟩, eq_p⟩\n      simpa [← eq_p] using Set.sub_mem_sub a_in_s b_in_t\n\n"}
{"name":"BoundedMul.isBounded_mul","module":"Mathlib.Topology.Bornology.BoundedOperation","initialProofState":"R : Type u_1\ninst✝¹ : Bornology R\ninst✝ : Mul R\nself : BoundedMul R\ns t : Set R\na✝¹ : Bornology.IsBounded s\na✝ : Bornology.IsBounded t\n⊢ Bornology.IsBounded (HMul.hMul s t)","decl":"/-- A typeclass saying that `(p : R × R) ↦ p.1 * p.2` maps any product of bounded sets to a bounded\nset. This property automatically holds for non-unital seminormed rings, but it also holds, e.g.,\nfor `ℝ≥0`. -/\nclass BoundedMul (R : Type*) [Bornology R] [Mul R] : Prop where\n  isBounded_mul : ∀ {s t : Set R},\n    Bornology.IsBounded s → Bornology.IsBounded t → Bornology.IsBounded (s * t)\n\n"}
{"name":"isBounded_mul","module":"Mathlib.Topology.Bornology.BoundedOperation","initialProofState":"R : Type u_1\ninst✝² : Bornology R\ninst✝¹ : Mul R\ninst✝ : BoundedMul R\ns t : Set R\nhs : Bornology.IsBounded s\nht : Bornology.IsBounded t\n⊢ Bornology.IsBounded (HMul.hMul s t)","decl":"lemma isBounded_mul [Bornology R] [Mul R] [BoundedMul R] {s t : Set R}\n    (hs : Bornology.IsBounded s) (ht : Bornology.IsBounded t) :\n    Bornology.IsBounded (s * t) := BoundedMul.isBounded_mul hs ht\n\n"}
{"name":"isBounded_pow","module":"Mathlib.Topology.Bornology.BoundedOperation","initialProofState":"R : Type u_2\ninst✝² : Bornology R\ninst✝¹ : Monoid R\ninst✝ : BoundedMul R\ns : Set R\ns_bdd : Bornology.IsBounded s\nn : Nat\n⊢ Bornology.IsBounded (Set.image (fun x => HPow.hPow x n) s)","decl":"lemma isBounded_pow {R : Type*} [Bornology R] [Monoid R] [BoundedMul R] {s : Set R}\n    (s_bdd : Bornology.IsBounded s) (n : ℕ) :\n    Bornology.IsBounded ((fun x ↦ x ^ n) '' s) := by\n  induction' n with n hn\n  · by_cases s_empty : s = ∅\n    · simp [s_empty]\n    simp_rw [← nonempty_iff_ne_empty] at s_empty\n    simp [s_empty]\n  · have obs : ((fun x ↦ x ^ (n + 1)) '' s) ⊆ ((fun x ↦ x ^ n) '' s) * s := by\n      intro x hx\n      simp only [mem_image] at hx\n      obtain ⟨y, y_in_s, ypow_eq_x⟩ := hx\n      rw [← ypow_eq_x, pow_succ y n]\n      apply Set.mul_mem_mul _ y_in_s\n      use y\n    exact (isBounded_mul hn s_bdd).subset obs\n\n"}
{"name":"mul_bounded_of_bounded_of_bounded","module":"Mathlib.Topology.Bornology.BoundedOperation","initialProofState":"R : Type u_1\nX : Type u_2\ninst✝² : PseudoMetricSpace R\ninst✝¹ : Mul R\ninst✝ : BoundedMul R\nf g : X → R\nf_bdd : Exists fun C => ∀ (x y : X), LE.le (Dist.dist (f x) (f y)) C\ng_bdd : Exists fun C => ∀ (x y : X), LE.le (Dist.dist (g x) (g y)) C\n⊢ Exists fun C => ∀ (x y : X), LE.le (Dist.dist (HMul.hMul f g x) (HMul.hMul f g y)) C","decl":"lemma mul_bounded_of_bounded_of_bounded {X : Type*} [PseudoMetricSpace R] [Mul R] [BoundedMul R]\n    {f g : X → R} (f_bdd : ∃ C, ∀ x y, dist (f x) (f y) ≤ C)\n    (g_bdd : ∃ C, ∀ x y, dist (g x) (g y) ≤ C) :\n    ∃ C, ∀ x y, dist ((f * g) x) ((f * g) y) ≤ C := by\n  obtain ⟨C, hC⟩ := Metric.isBounded_iff.mp <|\n    isBounded_mul (Metric.isBounded_range_iff.mpr f_bdd) (Metric.isBounded_range_iff.mpr g_bdd)\n  use C\n  intro x y\n  exact hC (Set.mul_mem_mul (Set.mem_range_self (f := f) x) (Set.mem_range_self (f := g) x))\n           (Set.mul_mem_mul (Set.mem_range_self (f := f) y) (Set.mem_range_self (f := g) y))\n\n"}
{"name":"SeminormedAddCommGroup.lipschitzWith_sub","module":"Mathlib.Topology.Bornology.BoundedOperation","initialProofState":"R : Type u_1\ninst✝ : SeminormedAddCommGroup R\n⊢ LipschitzWith 2 fun p => HSub.hSub p.1 p.2","decl":"lemma SeminormedAddCommGroup.lipschitzWith_sub :\n    LipschitzWith 2 (fun (p : R × R) ↦ p.1 - p.2) := by\n  convert LipschitzWith.prod_fst.sub LipschitzWith.prod_snd\n  norm_num\n\n"}
{"name":"instBoundedSub","module":"Mathlib.Topology.Bornology.BoundedOperation","initialProofState":"R : Type u_1\ninst✝ : SeminormedAddCommGroup R\n⊢ BoundedSub R","decl":"instance : BoundedSub R := boundedSub_of_lipschitzWith_sub SeminormedAddCommGroup.lipschitzWith_sub\n\n"}
{"name":"instBoundedMul","module":"Mathlib.Topology.Bornology.BoundedOperation","initialProofState":"R : Type u_1\ninst✝ : NonUnitalSeminormedRing R\n⊢ BoundedMul R","decl":"instance : BoundedMul R where\n  isBounded_mul {s t} hs ht := by\n    obtain ⟨Af, hAf⟩ := (Metric.isBounded_iff_subset_closedBall 0).mp hs\n    obtain ⟨Ag, hAg⟩ := (Metric.isBounded_iff_subset_closedBall 0).mp ht\n    rw [Metric.isBounded_iff] at hs ht ⊢\n    use 2 * Af * Ag\n    intro z hz w hw\n    obtain ⟨x₁, hx₁, y₁, hy₁, z_eq⟩ := Set.mem_mul.mp hz\n    obtain ⟨x₂, hx₂, y₂, hy₂, w_eq⟩ := Set.mem_mul.mp hw\n    rw [← w_eq, ← z_eq, dist_eq_norm]\n    have hAf' : 0 ≤ Af := Metric.nonempty_closedBall.mp ⟨_, hAf hx₁⟩\n    have aux : ∀ {x y}, x ∈ s → y ∈ t → ‖x * y‖ ≤ Af * Ag := by\n      intro x y x_in_s y_in_t\n      apply (norm_mul_le _ _).trans (mul_le_mul _ _ (norm_nonneg _) hAf')\n      · exact mem_closedBall_zero_iff.mp (hAf x_in_s)\n      · exact mem_closedBall_zero_iff.mp (hAg y_in_t)\n    calc ‖x₁ * y₁ - x₂ * y₂‖\n     _ ≤ ‖x₁ * y₁‖ + ‖x₂ * y₂‖        := norm_sub_le _ _\n     _ ≤ Af * Ag + Af * Ag            := add_le_add (aux hx₁ hy₁) (aux hx₂ hy₂)\n     _ = 2 * Af * Ag                  := by simp [← two_mul, mul_assoc]\n\n"}
{"name":"instBoundedSubNNReal","module":"Mathlib.Topology.Bornology.BoundedOperation","initialProofState":"⊢ BoundedSub NNReal","decl":"instance : BoundedSub ℝ≥0 := boundedSub_of_lipschitzWith_sub NNReal.lipschitzWith_sub\n\n"}
{"name":"instBoundedMulNNReal","module":"Mathlib.Topology.Bornology.BoundedOperation","initialProofState":"⊢ BoundedMul NNReal","decl":"open Metric in\ninstance : BoundedMul ℝ≥0 where\n  isBounded_mul {s t} hs ht := by\n    obtain ⟨Af, hAf⟩ := (isBounded_iff_subset_closedBall 0).mp hs\n    obtain ⟨Ag, hAg⟩ := (isBounded_iff_subset_closedBall 0).mp ht\n    have key : IsCompact (closedBall (0 : ℝ≥0) Af ×ˢ closedBall (0 : ℝ≥0) Ag) :=\n      IsCompact.prod (isCompact_closedBall _ _) (isCompact_closedBall _ _)\n    apply Bornology.IsBounded.subset (key.image continuous_mul).isBounded\n    intro _ ⟨x, x_in_s, y, y_in_t, xy_eq⟩\n    exact ⟨⟨x, y⟩, by simpa only [Set.mem_prod] using ⟨⟨hAf x_in_s, hAg y_in_t⟩, xy_eq⟩⟩\n\n"}
