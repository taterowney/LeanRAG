{"name":"Real.sInf_smul_of_nonneg","module":"Mathlib.Data.Real.Pointwise","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : MulActionWithZero α Real\ninst✝ : OrderedSMul α Real\na : α\nha : LE.le 0 a\ns : Set Real\n⊢ Eq (InfSet.sInf (HSMul.hSMul a s)) (HSMul.hSMul a (InfSet.sInf s))","decl":"theorem Real.sInf_smul_of_nonneg (ha : 0 ≤ a) (s : Set ℝ) : sInf (a • s) = a • sInf s := by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  · rw [smul_set_empty, Real.sInf_empty, smul_zero]\n  obtain rfl | ha' := ha.eq_or_lt\n  · rw [zero_smul_set hs, zero_smul]\n    exact csInf_singleton 0\n  by_cases h : BddBelow s\n  · exact ((OrderIso.smulRight ha').map_csInf' hs h).symm\n  · rw [Real.sInf_of_not_bddBelow (mt (bddBelow_smul_iff_of_pos ha').1 h),\n        Real.sInf_of_not_bddBelow h, smul_zero]\n\n"}
{"name":"Real.smul_iInf_of_nonneg","module":"Mathlib.Data.Real.Pointwise","initialProofState":"ι : Sort u_1\nα : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : MulActionWithZero α Real\ninst✝ : OrderedSMul α Real\na : α\nha : LE.le 0 a\nf : ι → Real\n⊢ Eq (HSMul.hSMul a (iInf fun i => f i)) (iInf fun i => HSMul.hSMul a (f i))","decl":"theorem Real.smul_iInf_of_nonneg (ha : 0 ≤ a) (f : ι → ℝ) : (a • ⨅ i, f i) = ⨅ i, a • f i :=\n  (Real.sInf_smul_of_nonneg ha _).symm.trans <| congr_arg sInf <| (range_comp _ _).symm\n\n"}
{"name":"Real.sSup_smul_of_nonneg","module":"Mathlib.Data.Real.Pointwise","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : MulActionWithZero α Real\ninst✝ : OrderedSMul α Real\na : α\nha : LE.le 0 a\ns : Set Real\n⊢ Eq (SupSet.sSup (HSMul.hSMul a s)) (HSMul.hSMul a (SupSet.sSup s))","decl":"theorem Real.sSup_smul_of_nonneg (ha : 0 ≤ a) (s : Set ℝ) : sSup (a • s) = a • sSup s := by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  · rw [smul_set_empty, Real.sSup_empty, smul_zero]\n  obtain rfl | ha' := ha.eq_or_lt\n  · rw [zero_smul_set hs, zero_smul]\n    exact csSup_singleton 0\n  by_cases h : BddAbove s\n  · exact ((OrderIso.smulRight ha').map_csSup' hs h).symm\n  · rw [Real.sSup_of_not_bddAbove (mt (bddAbove_smul_iff_of_pos ha').1 h),\n        Real.sSup_of_not_bddAbove h, smul_zero]\n\n"}
{"name":"Real.smul_iSup_of_nonneg","module":"Mathlib.Data.Real.Pointwise","initialProofState":"ι : Sort u_1\nα : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : MulActionWithZero α Real\ninst✝ : OrderedSMul α Real\na : α\nha : LE.le 0 a\nf : ι → Real\n⊢ Eq (HSMul.hSMul a (iSup fun i => f i)) (iSup fun i => HSMul.hSMul a (f i))","decl":"theorem Real.smul_iSup_of_nonneg (ha : 0 ≤ a) (f : ι → ℝ) : (a • ⨆ i, f i) = ⨆ i, a • f i :=\n  (Real.sSup_smul_of_nonneg ha _).symm.trans <| congr_arg sSup <| (range_comp _ _).symm\n\n"}
{"name":"Real.sInf_smul_of_nonpos","module":"Mathlib.Data.Real.Pointwise","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Module α Real\ninst✝ : OrderedSMul α Real\na : α\nha : LE.le a 0\ns : Set Real\n⊢ Eq (InfSet.sInf (HSMul.hSMul a s)) (HSMul.hSMul a (SupSet.sSup s))","decl":"theorem Real.sInf_smul_of_nonpos (ha : a ≤ 0) (s : Set ℝ) : sInf (a • s) = a • sSup s := by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  · rw [smul_set_empty, Real.sInf_empty, Real.sSup_empty, smul_zero]\n  obtain rfl | ha' := ha.eq_or_lt\n  · rw [zero_smul_set hs, zero_smul]\n    exact csInf_singleton 0\n  by_cases h : BddAbove s\n  · exact ((OrderIso.smulRightDual ℝ ha').map_csSup' hs h).symm\n  · rw [Real.sInf_of_not_bddBelow (mt (bddBelow_smul_iff_of_neg ha').1 h),\n        Real.sSup_of_not_bddAbove h, smul_zero]\n\n"}
{"name":"Real.smul_iSup_of_nonpos","module":"Mathlib.Data.Real.Pointwise","initialProofState":"ι : Sort u_1\nα : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Module α Real\ninst✝ : OrderedSMul α Real\na : α\nha : LE.le a 0\nf : ι → Real\n⊢ Eq (HSMul.hSMul a (iSup fun i => f i)) (iInf fun i => HSMul.hSMul a (f i))","decl":"theorem Real.smul_iSup_of_nonpos (ha : a ≤ 0) (f : ι → ℝ) : (a • ⨆ i, f i) = ⨅ i, a • f i :=\n  (Real.sInf_smul_of_nonpos ha _).symm.trans <| congr_arg sInf <| (range_comp _ _).symm\n\n"}
{"name":"Real.sSup_smul_of_nonpos","module":"Mathlib.Data.Real.Pointwise","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Module α Real\ninst✝ : OrderedSMul α Real\na : α\nha : LE.le a 0\ns : Set Real\n⊢ Eq (SupSet.sSup (HSMul.hSMul a s)) (HSMul.hSMul a (InfSet.sInf s))","decl":"theorem Real.sSup_smul_of_nonpos (ha : a ≤ 0) (s : Set ℝ) : sSup (a • s) = a • sInf s := by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  · rw [smul_set_empty, Real.sSup_empty, Real.sInf_empty, smul_zero]\n  obtain rfl | ha' := ha.eq_or_lt\n  · rw [zero_smul_set hs, zero_smul]\n    exact csSup_singleton 0\n  by_cases h : BddBelow s\n  · exact ((OrderIso.smulRightDual ℝ ha').map_csInf' hs h).symm\n  · rw [Real.sSup_of_not_bddAbove (mt (bddAbove_smul_iff_of_neg ha').1 h),\n        Real.sInf_of_not_bddBelow h, smul_zero]\n\n"}
{"name":"Real.smul_iInf_of_nonpos","module":"Mathlib.Data.Real.Pointwise","initialProofState":"ι : Sort u_1\nα : Type u_2\ninst✝² : LinearOrderedField α\ninst✝¹ : Module α Real\ninst✝ : OrderedSMul α Real\na : α\nha : LE.le a 0\nf : ι → Real\n⊢ Eq (HSMul.hSMul a (iInf fun i => f i)) (iSup fun i => HSMul.hSMul a (f i))","decl":"theorem Real.smul_iInf_of_nonpos (ha : a ≤ 0) (f : ι → ℝ) : (a • ⨅ i, f i) = ⨆ i, a • f i :=\n  (Real.sSup_smul_of_nonpos ha _).symm.trans <| congr_arg sSup <| (range_comp _ _).symm\n\n"}
{"name":"Real.mul_iInf_of_nonneg","module":"Mathlib.Data.Real.Pointwise","initialProofState":"ι : Sort u_1\nr : Real\nha : LE.le 0 r\nf : ι → Real\n⊢ Eq (HMul.hMul r (iInf fun i => f i)) (iInf fun i => HMul.hMul r (f i))","decl":"theorem Real.mul_iInf_of_nonneg (ha : 0 ≤ r) (f : ι → ℝ) : (r * ⨅ i, f i) = ⨅ i, r * f i :=\n  Real.smul_iInf_of_nonneg ha f\n\n"}
{"name":"Real.mul_iSup_of_nonneg","module":"Mathlib.Data.Real.Pointwise","initialProofState":"ι : Sort u_1\nr : Real\nha : LE.le 0 r\nf : ι → Real\n⊢ Eq (HMul.hMul r (iSup fun i => f i)) (iSup fun i => HMul.hMul r (f i))","decl":"theorem Real.mul_iSup_of_nonneg (ha : 0 ≤ r) (f : ι → ℝ) : (r * ⨆ i, f i) = ⨆ i, r * f i :=\n  Real.smul_iSup_of_nonneg ha f\n\n"}
{"name":"Real.mul_iInf_of_nonpos","module":"Mathlib.Data.Real.Pointwise","initialProofState":"ι : Sort u_1\nr : Real\nha : LE.le r 0\nf : ι → Real\n⊢ Eq (HMul.hMul r (iInf fun i => f i)) (iSup fun i => HMul.hMul r (f i))","decl":"theorem Real.mul_iInf_of_nonpos (ha : r ≤ 0) (f : ι → ℝ) : (r * ⨅ i, f i) = ⨆ i, r * f i :=\n  Real.smul_iInf_of_nonpos ha f\n\n"}
{"name":"Real.mul_iSup_of_nonpos","module":"Mathlib.Data.Real.Pointwise","initialProofState":"ι : Sort u_1\nr : Real\nha : LE.le r 0\nf : ι → Real\n⊢ Eq (HMul.hMul r (iSup fun i => f i)) (iInf fun i => HMul.hMul r (f i))","decl":"theorem Real.mul_iSup_of_nonpos (ha : r ≤ 0) (f : ι → ℝ) : (r * ⨆ i, f i) = ⨅ i, r * f i :=\n  Real.smul_iSup_of_nonpos ha f\n\n"}
{"name":"Real.iInf_mul_of_nonneg","module":"Mathlib.Data.Real.Pointwise","initialProofState":"ι : Sort u_1\nr : Real\nha : LE.le 0 r\nf : ι → Real\n⊢ Eq (HMul.hMul (iInf fun i => f i) r) (iInf fun i => HMul.hMul (f i) r)","decl":"theorem Real.iInf_mul_of_nonneg (ha : 0 ≤ r) (f : ι → ℝ) : (⨅ i, f i) * r = ⨅ i, f i * r := by\n  simp only [Real.mul_iInf_of_nonneg ha, mul_comm]\n\n"}
{"name":"Real.iSup_mul_of_nonneg","module":"Mathlib.Data.Real.Pointwise","initialProofState":"ι : Sort u_1\nr : Real\nha : LE.le 0 r\nf : ι → Real\n⊢ Eq (HMul.hMul (iSup fun i => f i) r) (iSup fun i => HMul.hMul (f i) r)","decl":"theorem Real.iSup_mul_of_nonneg (ha : 0 ≤ r) (f : ι → ℝ) : (⨆ i, f i) * r = ⨆ i, f i * r := by\n  simp only [Real.mul_iSup_of_nonneg ha, mul_comm]\n\n"}
{"name":"Real.iInf_mul_of_nonpos","module":"Mathlib.Data.Real.Pointwise","initialProofState":"ι : Sort u_1\nr : Real\nha : LE.le r 0\nf : ι → Real\n⊢ Eq (HMul.hMul (iInf fun i => f i) r) (iSup fun i => HMul.hMul (f i) r)","decl":"theorem Real.iInf_mul_of_nonpos (ha : r ≤ 0) (f : ι → ℝ) : (⨅ i, f i) * r = ⨆ i, f i * r := by\n  simp only [Real.mul_iInf_of_nonpos ha, mul_comm]\n\n"}
{"name":"Real.iSup_mul_of_nonpos","module":"Mathlib.Data.Real.Pointwise","initialProofState":"ι : Sort u_1\nr : Real\nha : LE.le r 0\nf : ι → Real\n⊢ Eq (HMul.hMul (iSup fun i => f i) r) (iInf fun i => HMul.hMul (f i) r)","decl":"theorem Real.iSup_mul_of_nonpos (ha : r ≤ 0) (f : ι → ℝ) : (⨆ i, f i) * r = ⨅ i, f i * r := by\n  simp only [Real.mul_iSup_of_nonpos ha, mul_comm]\n\n"}
