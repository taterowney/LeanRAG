{"name":"isCompactOperator_zero","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"M₁ : Type u_1\nM₂ : Type u_2\ninst✝³ : Zero M₁\ninst✝² : TopologicalSpace M₁\ninst✝¹ : TopologicalSpace M₂\ninst✝ : Zero M₂\n⊢ IsCompactOperator 0","decl":"theorem isCompactOperator_zero {M₁ M₂ : Type*} [Zero M₁] [TopologicalSpace M₁]\n    [TopologicalSpace M₂] [Zero M₂] : IsCompactOperator (0 : M₁ → M₂) :=\n  ⟨{0}, isCompact_singleton, mem_of_superset univ_mem fun _ _ => rfl⟩\n\n"}
{"name":"isCompactOperator_iff_exists_mem_nhds_image_subset_compact","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"M₁ : Type u_2\nM₂ : Type u_3\ninst✝² : TopologicalSpace M₁\ninst✝¹ : AddCommMonoid M₁\ninst✝ : TopologicalSpace M₂\nf : M₁ → M₂\n⊢ Iff (IsCompactOperator f) (Exists fun V => And (Membership.mem (nhds 0) V) (Exists fun K => And (IsCompact K) (HasSubset.Subset (Set.image f V) K)))","decl":"theorem isCompactOperator_iff_exists_mem_nhds_image_subset_compact (f : M₁ → M₂) :\n    IsCompactOperator f ↔ ∃ V ∈ (𝓝 0 : Filter M₁), ∃ K : Set M₂, IsCompact K ∧ f '' V ⊆ K :=\n  ⟨fun ⟨K, hK, hKf⟩ => ⟨f ⁻¹' K, hKf, K, hK, image_preimage_subset _ _⟩, fun ⟨_, hV, K, hK, hVK⟩ =>\n    ⟨K, hK, mem_of_superset hV (image_subset_iff.mp hVK)⟩⟩\n\n"}
{"name":"isCompactOperator_iff_exists_mem_nhds_isCompact_closure_image","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"M₁ : Type u_2\nM₂ : Type u_3\ninst✝³ : TopologicalSpace M₁\ninst✝² : AddCommMonoid M₁\ninst✝¹ : TopologicalSpace M₂\ninst✝ : T2Space M₂\nf : M₁ → M₂\n⊢ Iff (IsCompactOperator f) (Exists fun V => And (Membership.mem (nhds 0) V) (IsCompact (closure (Set.image f V))))","decl":"theorem isCompactOperator_iff_exists_mem_nhds_isCompact_closure_image [T2Space M₂] (f : M₁ → M₂) :\n    IsCompactOperator f ↔ ∃ V ∈ (𝓝 0 : Filter M₁), IsCompact (closure <| f '' V) := by\n  rw [isCompactOperator_iff_exists_mem_nhds_image_subset_compact]\n  exact\n    ⟨fun ⟨V, hV, K, hK, hKV⟩ => ⟨V, hV, hK.closure_of_subset hKV⟩,\n      fun ⟨V, hV, hVc⟩ => ⟨V, hV, closure (f '' V), hVc, subset_closure⟩⟩\n\n"}
{"name":"IsCompactOperator.image_subset_compact_of_isVonNBounded","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"𝕜₁ : Type u_1\n𝕜₂ : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜₁\ninst✝⁷ : SeminormedRing 𝕜₂\nσ₁₂ : RingHom 𝕜₁ 𝕜₂\nM₁ : Type u_3\nM₂ : Type u_4\ninst✝⁶ : TopologicalSpace M₁\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : TopologicalSpace M₂\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module 𝕜₁ M₁\ninst✝¹ : Module 𝕜₂ M₂\ninst✝ : ContinuousConstSMul 𝕜₂ M₂\nf : LinearMap σ₁₂ M₁ M₂\nhf : IsCompactOperator ⇑f\nS : Set M₁\nhS : Bornology.IsVonNBounded 𝕜₁ S\n⊢ Exists fun K => And (IsCompact K) (HasSubset.Subset (Set.image (⇑f) S) K)","decl":"theorem IsCompactOperator.image_subset_compact_of_isVonNBounded {f : M₁ →ₛₗ[σ₁₂] M₂}\n    (hf : IsCompactOperator f) {S : Set M₁} (hS : IsVonNBounded 𝕜₁ S) :\n    ∃ K : Set M₂, IsCompact K ∧ f '' S ⊆ K :=\n  let ⟨K, hK, hKf⟩ := hf\n  let ⟨r, hr, hrS⟩ := (hS hKf).exists_pos\n  let ⟨c, hc⟩ := NormedField.exists_lt_norm 𝕜₁ r\n  let this := ne_zero_of_norm_ne_zero (hr.trans hc).ne.symm\n  ⟨σ₁₂ c • K, hK.image <| continuous_id.const_smul (σ₁₂ c), by\n    rw [image_subset_iff, preimage_smul_setₛₗ _ _ _ f this.isUnit]; exact hrS c hc.le⟩\n\n"}
{"name":"IsCompactOperator.isCompact_closure_image_of_isVonNBounded","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"𝕜₁ : Type u_1\n𝕜₂ : Type u_2\ninst✝⁹ : NontriviallyNormedField 𝕜₁\ninst✝⁸ : SeminormedRing 𝕜₂\nσ₁₂ : RingHom 𝕜₁ 𝕜₂\nM₁ : Type u_3\nM₂ : Type u_4\ninst✝⁷ : TopologicalSpace M₁\ninst✝⁶ : AddCommMonoid M₁\ninst✝⁵ : TopologicalSpace M₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module 𝕜₁ M₁\ninst✝² : Module 𝕜₂ M₂\ninst✝¹ : ContinuousConstSMul 𝕜₂ M₂\ninst✝ : T2Space M₂\nf : LinearMap σ₁₂ M₁ M₂\nhf : IsCompactOperator ⇑f\nS : Set M₁\nhS : Bornology.IsVonNBounded 𝕜₁ S\n⊢ IsCompact (closure (Set.image (⇑f) S))","decl":"theorem IsCompactOperator.isCompact_closure_image_of_isVonNBounded [T2Space M₂] {f : M₁ →ₛₗ[σ₁₂] M₂}\n    (hf : IsCompactOperator f) {S : Set M₁} (hS : IsVonNBounded 𝕜₁ S) :\n    IsCompact (closure <| f '' S) :=\n  let ⟨_, hK, hKf⟩ := hf.image_subset_compact_of_isVonNBounded hS\n  hK.closure_of_subset hKf\n\n"}
{"name":"IsCompactOperator.image_subset_compact_of_bounded","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"𝕜₁ : Type u_1\n𝕜₂ : Type u_2\ninst✝⁷ : NontriviallyNormedField 𝕜₁\ninst✝⁶ : SeminormedRing 𝕜₂\nσ₁₂ : RingHom 𝕜₁ 𝕜₂\nM₁ : Type u_3\nM₂ : Type u_4\ninst✝⁵ : SeminormedAddCommGroup M₁\ninst✝⁴ : TopologicalSpace M₂\ninst✝³ : AddCommMonoid M₂\ninst✝² : NormedSpace 𝕜₁ M₁\ninst✝¹ : Module 𝕜₂ M₂\ninst✝ : ContinuousConstSMul 𝕜₂ M₂\nf : LinearMap σ₁₂ M₁ M₂\nhf : IsCompactOperator ⇑f\nS : Set M₁\nhS : Bornology.IsBounded S\n⊢ Exists fun K => And (IsCompact K) (HasSubset.Subset (Set.image (⇑f) S) K)","decl":"theorem IsCompactOperator.image_subset_compact_of_bounded [ContinuousConstSMul 𝕜₂ M₂]\n    {f : M₁ →ₛₗ[σ₁₂] M₂} (hf : IsCompactOperator f) {S : Set M₁} (hS : Bornology.IsBounded S) :\n    ∃ K : Set M₂, IsCompact K ∧ f '' S ⊆ K :=\n  hf.image_subset_compact_of_isVonNBounded <| by rwa [NormedSpace.isVonNBounded_iff]\n\n"}
{"name":"IsCompactOperator.isCompact_closure_image_of_bounded","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"𝕜₁ : Type u_1\n𝕜₂ : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜₁\ninst✝⁷ : SeminormedRing 𝕜₂\nσ₁₂ : RingHom 𝕜₁ 𝕜₂\nM₁ : Type u_3\nM₂ : Type u_4\ninst✝⁶ : SeminormedAddCommGroup M₁\ninst✝⁵ : TopologicalSpace M₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : NormedSpace 𝕜₁ M₁\ninst✝² : Module 𝕜₂ M₂\ninst✝¹ : ContinuousConstSMul 𝕜₂ M₂\ninst✝ : T2Space M₂\nf : LinearMap σ₁₂ M₁ M₂\nhf : IsCompactOperator ⇑f\nS : Set M₁\nhS : Bornology.IsBounded S\n⊢ IsCompact (closure (Set.image (⇑f) S))","decl":"theorem IsCompactOperator.isCompact_closure_image_of_bounded [ContinuousConstSMul 𝕜₂ M₂]\n    [T2Space M₂] {f : M₁ →ₛₗ[σ₁₂] M₂} (hf : IsCompactOperator f) {S : Set M₁}\n    (hS : Bornology.IsBounded S) : IsCompact (closure <| f '' S) :=\n  hf.isCompact_closure_image_of_isVonNBounded <| by rwa [NormedSpace.isVonNBounded_iff]\n\n"}
{"name":"IsCompactOperator.image_ball_subset_compact","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"𝕜₁ : Type u_1\n𝕜₂ : Type u_2\ninst✝⁷ : NontriviallyNormedField 𝕜₁\ninst✝⁶ : SeminormedRing 𝕜₂\nσ₁₂ : RingHom 𝕜₁ 𝕜₂\nM₁ : Type u_3\nM₂ : Type u_4\ninst✝⁵ : SeminormedAddCommGroup M₁\ninst✝⁴ : TopologicalSpace M₂\ninst✝³ : AddCommMonoid M₂\ninst✝² : NormedSpace 𝕜₁ M₁\ninst✝¹ : Module 𝕜₂ M₂\ninst✝ : ContinuousConstSMul 𝕜₂ M₂\nf : LinearMap σ₁₂ M₁ M₂\nhf : IsCompactOperator ⇑f\nr : Real\n⊢ Exists fun K => And (IsCompact K) (HasSubset.Subset (Set.image (⇑f) (Metric.ball 0 r)) K)","decl":"theorem IsCompactOperator.image_ball_subset_compact [ContinuousConstSMul 𝕜₂ M₂] {f : M₁ →ₛₗ[σ₁₂] M₂}\n    (hf : IsCompactOperator f) (r : ℝ) : ∃ K : Set M₂, IsCompact K ∧ f '' Metric.ball 0 r ⊆ K :=\n  hf.image_subset_compact_of_isVonNBounded (NormedSpace.isVonNBounded_ball 𝕜₁ M₁ r)\n\n"}
{"name":"IsCompactOperator.image_closedBall_subset_compact","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"𝕜₁ : Type u_1\n𝕜₂ : Type u_2\ninst✝⁷ : NontriviallyNormedField 𝕜₁\ninst✝⁶ : SeminormedRing 𝕜₂\nσ₁₂ : RingHom 𝕜₁ 𝕜₂\nM₁ : Type u_3\nM₂ : Type u_4\ninst✝⁵ : SeminormedAddCommGroup M₁\ninst✝⁴ : TopologicalSpace M₂\ninst✝³ : AddCommMonoid M₂\ninst✝² : NormedSpace 𝕜₁ M₁\ninst✝¹ : Module 𝕜₂ M₂\ninst✝ : ContinuousConstSMul 𝕜₂ M₂\nf : LinearMap σ₁₂ M₁ M₂\nhf : IsCompactOperator ⇑f\nr : Real\n⊢ Exists fun K => And (IsCompact K) (HasSubset.Subset (Set.image (⇑f) (Metric.closedBall 0 r)) K)","decl":"theorem IsCompactOperator.image_closedBall_subset_compact [ContinuousConstSMul 𝕜₂ M₂]\n    {f : M₁ →ₛₗ[σ₁₂] M₂} (hf : IsCompactOperator f) (r : ℝ) :\n    ∃ K : Set M₂, IsCompact K ∧ f '' Metric.closedBall 0 r ⊆ K :=\n  hf.image_subset_compact_of_isVonNBounded (NormedSpace.isVonNBounded_closedBall 𝕜₁ M₁ r)\n\n"}
{"name":"IsCompactOperator.isCompact_closure_image_ball","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"𝕜₁ : Type u_1\n𝕜₂ : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜₁\ninst✝⁷ : SeminormedRing 𝕜₂\nσ₁₂ : RingHom 𝕜₁ 𝕜₂\nM₁ : Type u_3\nM₂ : Type u_4\ninst✝⁶ : SeminormedAddCommGroup M₁\ninst✝⁵ : TopologicalSpace M₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : NormedSpace 𝕜₁ M₁\ninst✝² : Module 𝕜₂ M₂\ninst✝¹ : ContinuousConstSMul 𝕜₂ M₂\ninst✝ : T2Space M₂\nf : LinearMap σ₁₂ M₁ M₂\nhf : IsCompactOperator ⇑f\nr : Real\n⊢ IsCompact (closure (Set.image (⇑f) (Metric.ball 0 r)))","decl":"theorem IsCompactOperator.isCompact_closure_image_ball [ContinuousConstSMul 𝕜₂ M₂] [T2Space M₂]\n    {f : M₁ →ₛₗ[σ₁₂] M₂} (hf : IsCompactOperator f) (r : ℝ) :\n    IsCompact (closure <| f '' Metric.ball 0 r) :=\n  hf.isCompact_closure_image_of_isVonNBounded (NormedSpace.isVonNBounded_ball 𝕜₁ M₁ r)\n\n"}
{"name":"IsCompactOperator.isCompact_closure_image_closedBall","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"𝕜₁ : Type u_1\n𝕜₂ : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜₁\ninst✝⁷ : SeminormedRing 𝕜₂\nσ₁₂ : RingHom 𝕜₁ 𝕜₂\nM₁ : Type u_3\nM₂ : Type u_4\ninst✝⁶ : SeminormedAddCommGroup M₁\ninst✝⁵ : TopologicalSpace M₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : NormedSpace 𝕜₁ M₁\ninst✝² : Module 𝕜₂ M₂\ninst✝¹ : ContinuousConstSMul 𝕜₂ M₂\ninst✝ : T2Space M₂\nf : LinearMap σ₁₂ M₁ M₂\nhf : IsCompactOperator ⇑f\nr : Real\n⊢ IsCompact (closure (Set.image (⇑f) (Metric.closedBall 0 r)))","decl":"theorem IsCompactOperator.isCompact_closure_image_closedBall [ContinuousConstSMul 𝕜₂ M₂]\n    [T2Space M₂] {f : M₁ →ₛₗ[σ₁₂] M₂} (hf : IsCompactOperator f) (r : ℝ) :\n    IsCompact (closure <| f '' Metric.closedBall 0 r) :=\n  hf.isCompact_closure_image_of_isVonNBounded (NormedSpace.isVonNBounded_closedBall 𝕜₁ M₁ r)\n\n"}
{"name":"isCompactOperator_iff_image_ball_subset_compact","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"𝕜₁ : Type u_1\n𝕜₂ : Type u_2\ninst✝⁷ : NontriviallyNormedField 𝕜₁\ninst✝⁶ : SeminormedRing 𝕜₂\nσ₁₂ : RingHom 𝕜₁ 𝕜₂\nM₁ : Type u_3\nM₂ : Type u_4\ninst✝⁵ : SeminormedAddCommGroup M₁\ninst✝⁴ : TopologicalSpace M₂\ninst✝³ : AddCommMonoid M₂\ninst✝² : NormedSpace 𝕜₁ M₁\ninst✝¹ : Module 𝕜₂ M₂\ninst✝ : ContinuousConstSMul 𝕜₂ M₂\nf : LinearMap σ₁₂ M₁ M₂\nr : Real\nhr : LT.lt 0 r\n⊢ Iff (IsCompactOperator ⇑f) (Exists fun K => And (IsCompact K) (HasSubset.Subset (Set.image (⇑f) (Metric.ball 0 r)) K))","decl":"theorem isCompactOperator_iff_image_ball_subset_compact [ContinuousConstSMul 𝕜₂ M₂]\n    (f : M₁ →ₛₗ[σ₁₂] M₂) {r : ℝ} (hr : 0 < r) :\n    IsCompactOperator f ↔ ∃ K : Set M₂, IsCompact K ∧ f '' Metric.ball 0 r ⊆ K :=\n  ⟨fun hf => hf.image_ball_subset_compact r, fun ⟨K, hK, hKr⟩ =>\n    (isCompactOperator_iff_exists_mem_nhds_image_subset_compact f).mpr\n      ⟨Metric.ball 0 r, ball_mem_nhds _ hr, K, hK, hKr⟩⟩\n\n"}
{"name":"isCompactOperator_iff_image_closedBall_subset_compact","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"𝕜₁ : Type u_1\n𝕜₂ : Type u_2\ninst✝⁷ : NontriviallyNormedField 𝕜₁\ninst✝⁶ : SeminormedRing 𝕜₂\nσ₁₂ : RingHom 𝕜₁ 𝕜₂\nM₁ : Type u_3\nM₂ : Type u_4\ninst✝⁵ : SeminormedAddCommGroup M₁\ninst✝⁴ : TopologicalSpace M₂\ninst✝³ : AddCommMonoid M₂\ninst✝² : NormedSpace 𝕜₁ M₁\ninst✝¹ : Module 𝕜₂ M₂\ninst✝ : ContinuousConstSMul 𝕜₂ M₂\nf : LinearMap σ₁₂ M₁ M₂\nr : Real\nhr : LT.lt 0 r\n⊢ Iff (IsCompactOperator ⇑f) (Exists fun K => And (IsCompact K) (HasSubset.Subset (Set.image (⇑f) (Metric.closedBall 0 r)) K))","decl":"theorem isCompactOperator_iff_image_closedBall_subset_compact [ContinuousConstSMul 𝕜₂ M₂]\n    (f : M₁ →ₛₗ[σ₁₂] M₂) {r : ℝ} (hr : 0 < r) :\n    IsCompactOperator f ↔ ∃ K : Set M₂, IsCompact K ∧ f '' Metric.closedBall 0 r ⊆ K :=\n  ⟨fun hf => hf.image_closedBall_subset_compact r, fun ⟨K, hK, hKr⟩ =>\n    (isCompactOperator_iff_exists_mem_nhds_image_subset_compact f).mpr\n      ⟨Metric.closedBall 0 r, closedBall_mem_nhds _ hr, K, hK, hKr⟩⟩\n\n"}
{"name":"isCompactOperator_iff_isCompact_closure_image_ball","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"𝕜₁ : Type u_1\n𝕜₂ : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜₁\ninst✝⁷ : SeminormedRing 𝕜₂\nσ₁₂ : RingHom 𝕜₁ 𝕜₂\nM₁ : Type u_3\nM₂ : Type u_4\ninst✝⁶ : SeminormedAddCommGroup M₁\ninst✝⁵ : TopologicalSpace M₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : NormedSpace 𝕜₁ M₁\ninst✝² : Module 𝕜₂ M₂\ninst✝¹ : ContinuousConstSMul 𝕜₂ M₂\ninst✝ : T2Space M₂\nf : LinearMap σ₁₂ M₁ M₂\nr : Real\nhr : LT.lt 0 r\n⊢ Iff (IsCompactOperator ⇑f) (IsCompact (closure (Set.image (⇑f) (Metric.ball 0 r))))","decl":"theorem isCompactOperator_iff_isCompact_closure_image_ball [ContinuousConstSMul 𝕜₂ M₂] [T2Space M₂]\n    (f : M₁ →ₛₗ[σ₁₂] M₂) {r : ℝ} (hr : 0 < r) :\n    IsCompactOperator f ↔ IsCompact (closure <| f '' Metric.ball 0 r) :=\n  ⟨fun hf => hf.isCompact_closure_image_ball r, fun hf =>\n    (isCompactOperator_iff_exists_mem_nhds_isCompact_closure_image f).mpr\n      ⟨Metric.ball 0 r, ball_mem_nhds _ hr, hf⟩⟩\n\n"}
{"name":"isCompactOperator_iff_isCompact_closure_image_closedBall","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"𝕜₁ : Type u_1\n𝕜₂ : Type u_2\ninst✝⁸ : NontriviallyNormedField 𝕜₁\ninst✝⁷ : SeminormedRing 𝕜₂\nσ₁₂ : RingHom 𝕜₁ 𝕜₂\nM₁ : Type u_3\nM₂ : Type u_4\ninst✝⁶ : SeminormedAddCommGroup M₁\ninst✝⁵ : TopologicalSpace M₂\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : NormedSpace 𝕜₁ M₁\ninst✝² : Module 𝕜₂ M₂\ninst✝¹ : ContinuousConstSMul 𝕜₂ M₂\ninst✝ : T2Space M₂\nf : LinearMap σ₁₂ M₁ M₂\nr : Real\nhr : LT.lt 0 r\n⊢ Iff (IsCompactOperator ⇑f) (IsCompact (closure (Set.image (⇑f) (Metric.closedBall 0 r))))","decl":"theorem isCompactOperator_iff_isCompact_closure_image_closedBall [ContinuousConstSMul 𝕜₂ M₂]\n    [T2Space M₂] (f : M₁ →ₛₗ[σ₁₂] M₂) {r : ℝ} (hr : 0 < r) :\n    IsCompactOperator f ↔ IsCompact (closure <| f '' Metric.closedBall 0 r) :=\n  ⟨fun hf => hf.isCompact_closure_image_closedBall r, fun hf =>\n    (isCompactOperator_iff_exists_mem_nhds_isCompact_closure_image f).mpr\n      ⟨Metric.closedBall 0 r, closedBall_mem_nhds _ hr, hf⟩⟩\n\n"}
{"name":"IsCompactOperator.smul","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"M₁ : Type u_3\nM₂ : Type u_4\ninst✝⁶ : TopologicalSpace M₁\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : TopologicalSpace M₂\ninst✝³ : AddCommMonoid M₂\nS : Type u_6\ninst✝² : Monoid S\ninst✝¹ : DistribMulAction S M₂\ninst✝ : ContinuousConstSMul S M₂\nf : M₁ → M₂\nhf : IsCompactOperator f\nc : S\n⊢ IsCompactOperator (HSMul.hSMul c f)","decl":"theorem IsCompactOperator.smul {S : Type*} [Monoid S] [DistribMulAction S M₂]\n    [ContinuousConstSMul S M₂] {f : M₁ → M₂} (hf : IsCompactOperator f) (c : S) :\n    IsCompactOperator (c • f) :=\n  let ⟨K, hK, hKf⟩ := hf\n  ⟨c • K, hK.image <| continuous_id.const_smul c,\n    mem_of_superset hKf fun _ hx => smul_mem_smul_set hx⟩\n\n"}
{"name":"IsCompactOperator.add","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"M₁ : Type u_3\nM₂ : Type u_4\ninst✝⁴ : TopologicalSpace M₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : TopologicalSpace M₂\ninst✝¹ : AddCommMonoid M₂\ninst✝ : ContinuousAdd M₂\nf g : M₁ → M₂\nhf : IsCompactOperator f\nhg : IsCompactOperator g\n⊢ IsCompactOperator (HAdd.hAdd f g)","decl":"theorem IsCompactOperator.add [ContinuousAdd M₂] {f g : M₁ → M₂} (hf : IsCompactOperator f)\n    (hg : IsCompactOperator g) : IsCompactOperator (f + g) :=\n  let ⟨A, hA, hAf⟩ := hf\n  let ⟨B, hB, hBg⟩ := hg\n  ⟨A + B, hA.add hB,\n    mem_of_superset (inter_mem hAf hBg) fun _ ⟨hxA, hxB⟩ => Set.add_mem_add hxA hxB⟩\n\n"}
{"name":"IsCompactOperator.neg","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"M₁ : Type u_3\nM₄ : Type u_5\ninst✝⁴ : TopologicalSpace M₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : TopologicalSpace M₄\ninst✝¹ : AddCommGroup M₄\ninst✝ : ContinuousNeg M₄\nf : M₁ → M₄\nhf : IsCompactOperator f\n⊢ IsCompactOperator (Neg.neg f)","decl":"theorem IsCompactOperator.neg [ContinuousNeg M₄] {f : M₁ → M₄} (hf : IsCompactOperator f) :\n    IsCompactOperator (-f) :=\n  let ⟨K, hK, hKf⟩ := hf\n  ⟨-K, hK.neg, mem_of_superset hKf fun x (hx : f x ∈ K) => Set.neg_mem_neg.mpr hx⟩\n\n"}
{"name":"IsCompactOperator.sub","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"M₁ : Type u_3\nM₄ : Type u_5\ninst✝⁴ : TopologicalSpace M₁\ninst✝³ : AddCommMonoid M₁\ninst✝² : TopologicalSpace M₄\ninst✝¹ : AddCommGroup M₄\ninst✝ : TopologicalAddGroup M₄\nf g : M₁ → M₄\nhf : IsCompactOperator f\nhg : IsCompactOperator g\n⊢ IsCompactOperator (HSub.hSub f g)","decl":"theorem IsCompactOperator.sub [TopologicalAddGroup M₄] {f g : M₁ → M₄} (hf : IsCompactOperator f)\n    (hg : IsCompactOperator g) : IsCompactOperator (f - g) := by\n  rw [sub_eq_add_neg]; exact hf.add hg.neg\n\n"}
{"name":"IsCompactOperator.comp_clm","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"R₁ : Type u_1\nR₂ : Type u_2\ninst✝⁸ : Semiring R₁\ninst✝⁷ : Semiring R₂\nσ₁₂ : RingHom R₁ R₂\nM₁ : Type u_4\nM₂ : Type u_5\nM₃ : Type u_6\ninst✝⁶ : TopologicalSpace M₁\ninst✝⁵ : TopologicalSpace M₂\ninst✝⁴ : TopologicalSpace M₃\ninst✝³ : AddCommMonoid M₁\ninst✝² : Module R₁ M₁\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R₂ M₂\nf : M₂ → M₃\nhf : IsCompactOperator f\ng : ContinuousLinearMap σ₁₂ M₁ M₂\n⊢ IsCompactOperator (Function.comp f ⇑g)","decl":"theorem IsCompactOperator.comp_clm [AddCommMonoid M₂] [Module R₂ M₂] {f : M₂ → M₃}\n    (hf : IsCompactOperator f) (g : M₁ →SL[σ₁₂] M₂) : IsCompactOperator (f ∘ g) := by\n  have := g.continuous.tendsto 0\n  rw [map_zero] at this\n  rcases hf with ⟨K, hK, hKf⟩\n  exact ⟨K, hK, this hKf⟩\n\n"}
{"name":"IsCompactOperator.continuous_comp","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"M₁ : Type u_4\nM₂ : Type u_5\nM₃ : Type u_6\ninst✝³ : TopologicalSpace M₁\ninst✝² : TopologicalSpace M₂\ninst✝¹ : TopologicalSpace M₃\ninst✝ : AddCommMonoid M₁\nf : M₁ → M₂\nhf : IsCompactOperator f\ng : M₂ → M₃\nhg : Continuous g\n⊢ IsCompactOperator (Function.comp g f)","decl":"theorem IsCompactOperator.continuous_comp {f : M₁ → M₂} (hf : IsCompactOperator f) {g : M₂ → M₃}\n    (hg : Continuous g) : IsCompactOperator (g ∘ f) := by\n  rcases hf with ⟨K, hK, hKf⟩\n  refine ⟨g '' K, hK.image hg, mem_of_superset hKf ?_⟩\n  rw [preimage_comp]\n  exact preimage_mono (subset_preimage_image _ _)\n\n"}
{"name":"IsCompactOperator.clm_comp","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"R₂ : Type u_2\nR₃ : Type u_3\ninst✝⁹ : Semiring R₂\ninst✝⁸ : Semiring R₃\nσ₂₃ : RingHom R₂ R₃\nM₁ : Type u_4\nM₂ : Type u_5\nM₃ : Type u_6\ninst✝⁷ : TopologicalSpace M₁\ninst✝⁶ : TopologicalSpace M₂\ninst✝⁵ : TopologicalSpace M₃\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R₂ M₂\ninst✝¹ : AddCommMonoid M₃\ninst✝ : Module R₃ M₃\nf : M₁ → M₂\nhf : IsCompactOperator f\ng : ContinuousLinearMap σ₂₃ M₂ M₃\n⊢ IsCompactOperator (Function.comp (⇑g) f)","decl":"theorem IsCompactOperator.clm_comp [AddCommMonoid M₂] [Module R₂ M₂] [AddCommMonoid M₃]\n    [Module R₃ M₃] {f : M₁ → M₂} (hf : IsCompactOperator f) (g : M₂ →SL[σ₂₃] M₃) :\n    IsCompactOperator (g ∘ f) :=\n  hf.continuous_comp g.continuous\n\n"}
{"name":"IsCompactOperator.codRestrict","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"R₂ : Type u_1\ninst✝⁵ : Semiring R₂\nM₁ : Type u_2\nM₂ : Type u_3\ninst✝⁴ : TopologicalSpace M₁\ninst✝³ : TopologicalSpace M₂\ninst✝² : AddCommMonoid M₁\ninst✝¹ : AddCommMonoid M₂\ninst✝ : Module R₂ M₂\nf : M₁ → M₂\nhf : IsCompactOperator f\nV : Submodule R₂ M₂\nhV : ∀ (x : M₁), Membership.mem V (f x)\nh_closed : IsClosed ↑V\n⊢ IsCompactOperator (Set.codRestrict f (↑V) hV)","decl":"theorem IsCompactOperator.codRestrict {f : M₁ → M₂} (hf : IsCompactOperator f) {V : Submodule R₂ M₂}\n    (hV : ∀ x, f x ∈ V) (h_closed : IsClosed (V : Set M₂)) :\n    IsCompactOperator (Set.codRestrict f V hV) :=\n  let ⟨_, hK, hKf⟩ := hf\n  ⟨_, h_closed.isClosedEmbedding_subtypeVal.isCompact_preimage hK, hKf⟩\n\n"}
{"name":"IsCompactOperator.restrict","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"R₁ : Type u_1\ninst✝³ : Semiring R₁\nM₁ : Type u_3\ninst✝² : TopologicalSpace M₁\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R₁ M₁\nf : LinearMap (RingHom.id R₁) M₁ M₁\nhf : IsCompactOperator ⇑f\nV : Submodule R₁ M₁\nhV : ∀ (v : M₁), Membership.mem V v → Membership.mem V (f v)\nh_closed : IsClosed ↑V\n⊢ IsCompactOperator ⇑(f.restrict hV)","decl":"/-- If a compact operator preserves a closed submodule, its restriction to that submodule is\ncompact.\n\nNote that, following mathlib's convention in linear algebra, `restrict` designates the restriction\nof an endomorphism `f : E →ₗ E` to an endomorphism `f' : ↥V →ₗ ↥V`. To prove that the restriction\n`f' : ↥U →ₛₗ ↥V` of a compact operator `f : E →ₛₗ F` is compact, apply\n`IsCompactOperator.codRestrict` to `f ∘ U.subtypeL`, which is compact by\n`IsCompactOperator.comp_clm`. -/\ntheorem IsCompactOperator.restrict {f : M₁ →ₗ[R₁] M₁} (hf : IsCompactOperator f)\n    {V : Submodule R₁ M₁} (hV : ∀ v ∈ V, f v ∈ V) (h_closed : IsClosed (V : Set M₁)) :\n    IsCompactOperator (f.restrict hV) :=\n  (hf.comp_clm V.subtypeL).codRestrict (SetLike.forall.2 hV) h_closed\n\n"}
{"name":"IsCompactOperator.restrict'","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"R₂ : Type u_2\ninst✝⁴ : Semiring R₂\nM₂ : Type u_4\ninst✝³ : UniformSpace M₂\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R₂ M₂\ninst✝ : T0Space M₂\nf : LinearMap (RingHom.id R₂) M₂ M₂\nhf : IsCompactOperator ⇑f\nV : Submodule R₂ M₂\nhV : ∀ (v : M₂), Membership.mem V v → Membership.mem V (f v)\nhcomplete : CompleteSpace (Subtype fun x => Membership.mem V x)\n⊢ IsCompactOperator ⇑(f.restrict hV)","decl":"/-- If a compact operator preserves a complete submodule, its restriction to that submodule is\ncompact.\n\nNote that, following mathlib's convention in linear algebra, `restrict` designates the restriction\nof an endomorphism `f : E →ₗ E` to an endomorphism `f' : ↥V →ₗ ↥V`. To prove that the restriction\n`f' : ↥U →ₛₗ ↥V` of a compact operator `f : E →ₛₗ F` is compact, apply\n`IsCompactOperator.codRestrict` to `f ∘ U.subtypeL`, which is compact by\n`IsCompactOperator.comp_clm`. -/\ntheorem IsCompactOperator.restrict' [T0Space M₂] {f : M₂ →ₗ[R₂] M₂}\n    (hf : IsCompactOperator f) {V : Submodule R₂ M₂} (hV : ∀ v ∈ V, f v ∈ V)\n    [hcomplete : CompleteSpace V] : IsCompactOperator (f.restrict hV) :=\n  hf.restrict hV (completeSpace_coe_iff_isComplete.mp hcomplete).isClosed\n\n"}
{"name":"IsCompactOperator.continuous","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"𝕜₁ : Type u_1\n𝕜₂ : Type u_2\ninst✝¹² : NontriviallyNormedField 𝕜₁\ninst✝¹¹ : NontriviallyNormedField 𝕜₂\nσ₁₂ : RingHom 𝕜₁ 𝕜₂\ninst✝¹⁰ : RingHomIsometric σ₁₂\nM₁ : Type u_3\nM₂ : Type u_4\ninst✝⁹ : TopologicalSpace M₁\ninst✝⁸ : AddCommGroup M₁\ninst✝⁷ : TopologicalSpace M₂\ninst✝⁶ : AddCommGroup M₂\ninst✝⁵ : Module 𝕜₁ M₁\ninst✝⁴ : Module 𝕜₂ M₂\ninst✝³ : TopologicalAddGroup M₁\ninst✝² : ContinuousConstSMul 𝕜₁ M₁\ninst✝¹ : TopologicalAddGroup M₂\ninst✝ : ContinuousSMul 𝕜₂ M₂\nf : LinearMap σ₁₂ M₁ M₂\nhf : IsCompactOperator ⇑f\n⊢ Continuous ⇑f","decl":"@[continuity]\ntheorem IsCompactOperator.continuous {f : M₁ →ₛₗ[σ₁₂] M₂} (hf : IsCompactOperator f) :\n    Continuous f := by\n  letI : UniformSpace M₂ := TopologicalAddGroup.toUniformSpace _\n  haveI : UniformAddGroup M₂ := comm_topologicalAddGroup_is_uniform\n  -- Since `f` is linear, we only need to show that it is continuous at zero.\n  -- Let `U` be a neighborhood of `0` in `M₂`.\n  refine continuous_of_continuousAt_zero f fun U hU => ?_\n  rw [map_zero] at hU\n  -- The compactness of `f` gives us a compact set `K : Set M₂` such that `f ⁻¹' K` is a\n  -- neighborhood of `0` in `M₁`.\n  rcases hf with ⟨K, hK, hKf⟩\n  -- But any compact set is totally bounded, hence Von-Neumann bounded. Thus, `K` absorbs `U`.\n  -- This gives `r > 0` such that `∀ a : 𝕜₂, r ≤ ‖a‖ → K ⊆ a • U`.\n  rcases (hK.totallyBounded.isVonNBounded 𝕜₂ hU).exists_pos with ⟨r, hr, hrU⟩\n  -- Choose `c : 𝕜₂` with `r < ‖c‖`.\n  rcases NormedField.exists_lt_norm 𝕜₁ r with ⟨c, hc⟩\n  have hcnz : c ≠ 0 := ne_zero_of_norm_ne_zero (hr.trans hc).ne.symm\n  -- We have `f ⁻¹' ((σ₁₂ c⁻¹) • K) = c⁻¹ • f ⁻¹' K ∈ 𝓝 0`. Thus, showing that\n  -- `(σ₁₂ c⁻¹) • K ⊆ U` is enough to deduce that `f ⁻¹' U ∈ 𝓝 0`.\n  suffices (σ₁₂ <| c⁻¹) • K ⊆ U by\n    refine mem_of_superset ?_ this\n    have : IsUnit c⁻¹ := hcnz.isUnit.inv\n    rwa [mem_map, preimage_smul_setₛₗ _ _ _ f this, set_smul_mem_nhds_zero_iff (inv_ne_zero hcnz)]\n  -- Since `σ₁₂ c⁻¹` = `(σ₁₂ c)⁻¹`, we have to prove that `K ⊆ σ₁₂ c • U`.\n  rw [map_inv₀, ← subset_smul_set_iff₀ ((map_ne_zero σ₁₂).mpr hcnz)]\n  -- But `σ₁₂` is isometric, so `‖σ₁₂ c‖ = ‖c‖ > r`, which concludes the argument since\n  -- `∀ a : 𝕜₂, r ≤ ‖a‖ → K ⊆ a • U`.\n  refine hrU (σ₁₂ c) ?_\n  rw [RingHomIsometric.is_iso]\n  exact hc.le\n\n"}
{"name":"ContinuousLinearMap.mkOfIsCompactOperator_to_linearMap","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"𝕜₁ : Type u_1\n𝕜₂ : Type u_2\ninst✝¹² : NontriviallyNormedField 𝕜₁\ninst✝¹¹ : NontriviallyNormedField 𝕜₂\nσ₁₂ : RingHom 𝕜₁ 𝕜₂\ninst✝¹⁰ : RingHomIsometric σ₁₂\nM₁ : Type u_3\nM₂ : Type u_4\ninst✝⁹ : TopologicalSpace M₁\ninst✝⁸ : AddCommGroup M₁\ninst✝⁷ : TopologicalSpace M₂\ninst✝⁶ : AddCommGroup M₂\ninst✝⁵ : Module 𝕜₁ M₁\ninst✝⁴ : Module 𝕜₂ M₂\ninst✝³ : TopologicalAddGroup M₁\ninst✝² : ContinuousConstSMul 𝕜₁ M₁\ninst✝¹ : TopologicalAddGroup M₂\ninst✝ : ContinuousSMul 𝕜₂ M₂\nf : LinearMap σ₁₂ M₁ M₂\nhf : IsCompactOperator ⇑f\n⊢ Eq (↑(ContinuousLinearMap.mkOfIsCompactOperator hf)) f","decl":"@[simp]\ntheorem ContinuousLinearMap.mkOfIsCompactOperator_to_linearMap {f : M₁ →ₛₗ[σ₁₂] M₂}\n    (hf : IsCompactOperator f) :\n    (ContinuousLinearMap.mkOfIsCompactOperator hf : M₁ →ₛₗ[σ₁₂] M₂) = f :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_mkOfIsCompactOperator","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"𝕜₁ : Type u_1\n𝕜₂ : Type u_2\ninst✝¹² : NontriviallyNormedField 𝕜₁\ninst✝¹¹ : NontriviallyNormedField 𝕜₂\nσ₁₂ : RingHom 𝕜₁ 𝕜₂\ninst✝¹⁰ : RingHomIsometric σ₁₂\nM₁ : Type u_3\nM₂ : Type u_4\ninst✝⁹ : TopologicalSpace M₁\ninst✝⁸ : AddCommGroup M₁\ninst✝⁷ : TopologicalSpace M₂\ninst✝⁶ : AddCommGroup M₂\ninst✝⁵ : Module 𝕜₁ M₁\ninst✝⁴ : Module 𝕜₂ M₂\ninst✝³ : TopologicalAddGroup M₁\ninst✝² : ContinuousConstSMul 𝕜₁ M₁\ninst✝¹ : TopologicalAddGroup M₂\ninst✝ : ContinuousSMul 𝕜₂ M₂\nf : LinearMap σ₁₂ M₁ M₂\nhf : IsCompactOperator ⇑f\n⊢ Eq ⇑(ContinuousLinearMap.mkOfIsCompactOperator hf) ⇑f","decl":"@[simp]\ntheorem ContinuousLinearMap.coe_mkOfIsCompactOperator {f : M₁ →ₛₗ[σ₁₂] M₂}\n    (hf : IsCompactOperator f) : (ContinuousLinearMap.mkOfIsCompactOperator hf : M₁ → M₂) = f :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.mkOfIsCompactOperator_mem_compactOperator","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"𝕜₁ : Type u_1\n𝕜₂ : Type u_2\ninst✝¹² : NontriviallyNormedField 𝕜₁\ninst✝¹¹ : NontriviallyNormedField 𝕜₂\nσ₁₂ : RingHom 𝕜₁ 𝕜₂\ninst✝¹⁰ : RingHomIsometric σ₁₂\nM₁ : Type u_3\nM₂ : Type u_4\ninst✝⁹ : TopologicalSpace M₁\ninst✝⁸ : AddCommGroup M₁\ninst✝⁷ : TopologicalSpace M₂\ninst✝⁶ : AddCommGroup M₂\ninst✝⁵ : Module 𝕜₁ M₁\ninst✝⁴ : Module 𝕜₂ M₂\ninst✝³ : TopologicalAddGroup M₁\ninst✝² : ContinuousConstSMul 𝕜₁ M₁\ninst✝¹ : TopologicalAddGroup M₂\ninst✝ : ContinuousSMul 𝕜₂ M₂\nf : LinearMap σ₁₂ M₁ M₂\nhf : IsCompactOperator ⇑f\n⊢ Membership.mem (compactOperator σ₁₂ M₁ M₂) (ContinuousLinearMap.mkOfIsCompactOperator hf)","decl":"theorem ContinuousLinearMap.mkOfIsCompactOperator_mem_compactOperator {f : M₁ →ₛₗ[σ₁₂] M₂}\n    (hf : IsCompactOperator f) :\n    ContinuousLinearMap.mkOfIsCompactOperator hf ∈ compactOperator σ₁₂ M₁ M₂ :=\n  hf\n\n"}
{"name":"isClosed_setOf_isCompactOperator","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"𝕜₁ : Type u_1\n𝕜₂ : Type u_2\ninst✝¹⁰ : NontriviallyNormedField 𝕜₁\ninst✝⁹ : NormedField 𝕜₂\nσ₁₂ : RingHom 𝕜₁ 𝕜₂\nM₁ : Type u_3\nM₂ : Type u_4\ninst✝⁸ : SeminormedAddCommGroup M₁\ninst✝⁷ : AddCommGroup M₂\ninst✝⁶ : NormedSpace 𝕜₁ M₁\ninst✝⁵ : Module 𝕜₂ M₂\ninst✝⁴ : UniformSpace M₂\ninst✝³ : UniformAddGroup M₂\ninst✝² : ContinuousConstSMul 𝕜₂ M₂\ninst✝¹ : T2Space M₂\ninst✝ : CompleteSpace M₂\n⊢ IsClosed (setOf fun f => IsCompactOperator ⇑f)","decl":"/-- The set of compact operators from a normed space to a complete topological vector space is\nclosed. -/\ntheorem isClosed_setOf_isCompactOperator {𝕜₁ 𝕜₂ : Type*} [NontriviallyNormedField 𝕜₁]\n    [NormedField 𝕜₂] {σ₁₂ : 𝕜₁ →+* 𝕜₂} {M₁ M₂ : Type*} [SeminormedAddCommGroup M₁]\n    [AddCommGroup M₂] [NormedSpace 𝕜₁ M₁] [Module 𝕜₂ M₂] [UniformSpace M₂] [UniformAddGroup M₂]\n    [ContinuousConstSMul 𝕜₂ M₂] [T2Space M₂] [CompleteSpace M₂] :\n    IsClosed { f : M₁ →SL[σ₁₂] M₂ | IsCompactOperator f } := by\n  refine isClosed_of_closure_subset ?_\n  rintro u hu\n  rw [mem_closure_iff_nhds_zero] at hu\n  suffices TotallyBounded (u '' Metric.closedBall 0 1) by\n    change IsCompactOperator (u : M₁ →ₛₗ[σ₁₂] M₂)\n    rw [isCompactOperator_iff_isCompact_closure_image_closedBall (u : M₁ →ₛₗ[σ₁₂] M₂) zero_lt_one]\n    exact isCompact_of_totallyBounded_isClosed this.closure isClosed_closure\n  rw [totallyBounded_iff_subset_finite_iUnion_nhds_zero]\n  intro U hU\n  rcases exists_nhds_zero_half hU with ⟨V, hV, hVU⟩\n  let SV : Set M₁ × Set M₂ := ⟨closedBall 0 1, -V⟩\n  rcases hu { f | ∀ x ∈ SV.1, f x ∈ SV.2 }\n      (ContinuousLinearMap.hasBasis_nhds_zero.mem_of_mem\n        ⟨NormedSpace.isVonNBounded_closedBall _ _ _, neg_mem_nhds_zero M₂ hV⟩) with\n    ⟨v, hv, huv⟩\n  rcases totallyBounded_iff_subset_finite_iUnion_nhds_zero.mp\n      (hv.isCompact_closure_image_closedBall 1).totallyBounded V hV with\n    ⟨T, hT, hTv⟩\n  have hTv : v '' closedBall 0 1 ⊆ _ := subset_closure.trans hTv\n  refine ⟨T, hT, ?_⟩\n  rw [image_subset_iff, preimage_iUnion₂] at hTv ⊢\n  intro x hx\n  specialize hTv hx\n  rw [mem_iUnion₂] at hTv ⊢\n  rcases hTv with ⟨t, ht, htx⟩\n  refine ⟨t, ht, ?_⟩\n  rw [mem_preimage, mem_vadd_set_iff_neg_vadd_mem, vadd_eq_add, neg_add_eq_sub] at htx ⊢\n  convert hVU _ htx _ (huv x hx) using 1\n  rw [ContinuousLinearMap.sub_apply]\n  abel\n\n"}
{"name":"compactOperator_topologicalClosure","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"𝕜₁ : Type u_1\n𝕜₂ : Type u_2\ninst✝¹⁰ : NontriviallyNormedField 𝕜₁\ninst✝⁹ : NormedField 𝕜₂\nσ₁₂ : RingHom 𝕜₁ 𝕜₂\nM₁ : Type u_3\nM₂ : Type u_4\ninst✝⁸ : SeminormedAddCommGroup M₁\ninst✝⁷ : AddCommGroup M₂\ninst✝⁶ : NormedSpace 𝕜₁ M₁\ninst✝⁵ : Module 𝕜₂ M₂\ninst✝⁴ : UniformSpace M₂\ninst✝³ : UniformAddGroup M₂\ninst✝² : ContinuousConstSMul 𝕜₂ M₂\ninst✝¹ : T2Space M₂\ninst✝ : CompleteSpace M₂\n⊢ Eq (compactOperator σ₁₂ M₁ M₂).topologicalClosure (compactOperator σ₁₂ M₁ M₂)","decl":"theorem compactOperator_topologicalClosure {𝕜₁ 𝕜₂ : Type*} [NontriviallyNormedField 𝕜₁]\n    [NormedField 𝕜₂] {σ₁₂ : 𝕜₁ →+* 𝕜₂} {M₁ M₂ : Type*} [SeminormedAddCommGroup M₁]\n    [AddCommGroup M₂] [NormedSpace 𝕜₁ M₁] [Module 𝕜₂ M₂] [UniformSpace M₂] [UniformAddGroup M₂]\n    [ContinuousConstSMul 𝕜₂ M₂] [T2Space M₂] [CompleteSpace M₂] :\n    (compactOperator σ₁₂ M₁ M₂).topologicalClosure = compactOperator σ₁₂ M₁ M₂ :=\n  SetLike.ext' isClosed_setOf_isCompactOperator.closure_eq\n\n"}
{"name":"isCompactOperator_of_tendsto","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"ι : Type u_1\n𝕜₁ : Type u_2\n𝕜₂ : Type u_3\ninst✝¹¹ : NontriviallyNormedField 𝕜₁\ninst✝¹⁰ : NormedField 𝕜₂\nσ₁₂ : RingHom 𝕜₁ 𝕜₂\nM₁ : Type u_4\nM₂ : Type u_5\ninst✝⁹ : SeminormedAddCommGroup M₁\ninst✝⁸ : AddCommGroup M₂\ninst✝⁷ : NormedSpace 𝕜₁ M₁\ninst✝⁶ : Module 𝕜₂ M₂\ninst✝⁵ : UniformSpace M₂\ninst✝⁴ : UniformAddGroup M₂\ninst✝³ : ContinuousConstSMul 𝕜₂ M₂\ninst✝² : T2Space M₂\ninst✝¹ : CompleteSpace M₂\nl : Filter ι\ninst✝ : l.NeBot\nF : ι → ContinuousLinearMap σ₁₂ M₁ M₂\nf : ContinuousLinearMap σ₁₂ M₁ M₂\nhf : Filter.Tendsto F l (nhds f)\nhF : Filter.Eventually (fun i => IsCompactOperator ⇑(F i)) l\n⊢ IsCompactOperator ⇑f","decl":"theorem isCompactOperator_of_tendsto {ι 𝕜₁ 𝕜₂ : Type*} [NontriviallyNormedField 𝕜₁]\n    [NormedField 𝕜₂] {σ₁₂ : 𝕜₁ →+* 𝕜₂} {M₁ M₂ : Type*} [SeminormedAddCommGroup M₁]\n    [AddCommGroup M₂] [NormedSpace 𝕜₁ M₁] [Module 𝕜₂ M₂] [UniformSpace M₂] [UniformAddGroup M₂]\n    [ContinuousConstSMul 𝕜₂ M₂] [T2Space M₂] [CompleteSpace M₂] {l : Filter ι} [l.NeBot]\n    {F : ι → M₁ →SL[σ₁₂] M₂} {f : M₁ →SL[σ₁₂] M₂} (hf : Tendsto F l (𝓝 f))\n    (hF : ∀ᶠ i in l, IsCompactOperator (F i)) : IsCompactOperator f :=\n  isClosed_setOf_isCompactOperator.mem_of_tendsto hf hF\n"}
