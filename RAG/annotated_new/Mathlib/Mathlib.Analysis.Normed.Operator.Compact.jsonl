{"name":"isCompactOperator_zero","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"Mâ‚ : Type u_1\nMâ‚‚ : Type u_2\ninstâœÂ³ : Zero Mâ‚\ninstâœÂ² : TopologicalSpace Mâ‚\ninstâœÂ¹ : TopologicalSpace Mâ‚‚\ninstâœ : Zero Mâ‚‚\nâŠ¢ IsCompactOperator 0","decl":"theorem isCompactOperator_zero {Mâ‚ Mâ‚‚ : Type*} [Zero Mâ‚] [TopologicalSpace Mâ‚]\n    [TopologicalSpace Mâ‚‚] [Zero Mâ‚‚] : IsCompactOperator (0 : Mâ‚ â†’ Mâ‚‚) :=\n  âŸ¨{0}, isCompact_singleton, mem_of_superset univ_mem fun _ _ => rflâŸ©\n\n"}
{"name":"isCompactOperator_iff_exists_mem_nhds_image_subset_compact","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"Mâ‚ : Type u_2\nMâ‚‚ : Type u_3\ninstâœÂ² : TopologicalSpace Mâ‚\ninstâœÂ¹ : AddCommMonoid Mâ‚\ninstâœ : TopologicalSpace Mâ‚‚\nf : Mâ‚ â†’ Mâ‚‚\nâŠ¢ Iff (IsCompactOperator f) (Exists fun V => And (Membership.mem (nhds 0) V) (Exists fun K => And (IsCompact K) (HasSubset.Subset (Set.image f V) K)))","decl":"theorem isCompactOperator_iff_exists_mem_nhds_image_subset_compact (f : Mâ‚ â†’ Mâ‚‚) :\n    IsCompactOperator f â†” âˆƒ V âˆˆ (ğ“ 0 : Filter Mâ‚), âˆƒ K : Set Mâ‚‚, IsCompact K âˆ§ f '' V âŠ† K :=\n  âŸ¨fun âŸ¨K, hK, hKfâŸ© => âŸ¨f â»Â¹' K, hKf, K, hK, image_preimage_subset _ _âŸ©, fun âŸ¨_, hV, K, hK, hVKâŸ© =>\n    âŸ¨K, hK, mem_of_superset hV (image_subset_iff.mp hVK)âŸ©âŸ©\n\n"}
{"name":"isCompactOperator_iff_exists_mem_nhds_isCompact_closure_image","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"Mâ‚ : Type u_2\nMâ‚‚ : Type u_3\ninstâœÂ³ : TopologicalSpace Mâ‚\ninstâœÂ² : AddCommMonoid Mâ‚\ninstâœÂ¹ : TopologicalSpace Mâ‚‚\ninstâœ : T2Space Mâ‚‚\nf : Mâ‚ â†’ Mâ‚‚\nâŠ¢ Iff (IsCompactOperator f) (Exists fun V => And (Membership.mem (nhds 0) V) (IsCompact (closure (Set.image f V))))","decl":"theorem isCompactOperator_iff_exists_mem_nhds_isCompact_closure_image [T2Space Mâ‚‚] (f : Mâ‚ â†’ Mâ‚‚) :\n    IsCompactOperator f â†” âˆƒ V âˆˆ (ğ“ 0 : Filter Mâ‚), IsCompact (closure <| f '' V) := by\n  rw [isCompactOperator_iff_exists_mem_nhds_image_subset_compact]\n  exact\n    âŸ¨fun âŸ¨V, hV, K, hK, hKVâŸ© => âŸ¨V, hV, hK.closure_of_subset hKVâŸ©,\n      fun âŸ¨V, hV, hVcâŸ© => âŸ¨V, hV, closure (f '' V), hVc, subset_closureâŸ©âŸ©\n\n"}
{"name":"IsCompactOperator.image_subset_compact_of_isVonNBounded","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œâ‚\ninstâœâ· : SeminormedRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œâ‚ ğ•œâ‚‚\nMâ‚ : Type u_3\nMâ‚‚ : Type u_4\ninstâœâ¶ : TopologicalSpace Mâ‚\ninstâœâµ : AddCommMonoid Mâ‚\ninstâœâ´ : TopologicalSpace Mâ‚‚\ninstâœÂ³ : AddCommMonoid Mâ‚‚\ninstâœÂ² : Module ğ•œâ‚ Mâ‚\ninstâœÂ¹ : Module ğ•œâ‚‚ Mâ‚‚\ninstâœ : ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚\nhf : IsCompactOperator â‡‘f\nS : Set Mâ‚\nhS : Bornology.IsVonNBounded ğ•œâ‚ S\nâŠ¢ Exists fun K => And (IsCompact K) (HasSubset.Subset (Set.image (â‡‘f) S) K)","decl":"theorem IsCompactOperator.image_subset_compact_of_isVonNBounded {f : Mâ‚ â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚}\n    (hf : IsCompactOperator f) {S : Set Mâ‚} (hS : IsVonNBounded ğ•œâ‚ S) :\n    âˆƒ K : Set Mâ‚‚, IsCompact K âˆ§ f '' S âŠ† K :=\n  let âŸ¨K, hK, hKfâŸ© := hf\n  let âŸ¨r, hr, hrSâŸ© := (hS hKf).exists_pos\n  let âŸ¨c, hcâŸ© := NormedField.exists_lt_norm ğ•œâ‚ r\n  let this := ne_zero_of_norm_ne_zero (hr.trans hc).ne.symm\n  âŸ¨Ïƒâ‚â‚‚ c â€¢ K, hK.image <| continuous_id.const_smul (Ïƒâ‚â‚‚ c), by\n    rw [image_subset_iff, preimage_smul_setâ‚›â‚— _ _ _ f this.isUnit]; exact hrS c hc.leâŸ©\n\n"}
{"name":"IsCompactOperator.isCompact_closure_image_of_isVonNBounded","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¹ : NontriviallyNormedField ğ•œâ‚\ninstâœâ¸ : SeminormedRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œâ‚ ğ•œâ‚‚\nMâ‚ : Type u_3\nMâ‚‚ : Type u_4\ninstâœâ· : TopologicalSpace Mâ‚\ninstâœâ¶ : AddCommMonoid Mâ‚\ninstâœâµ : TopologicalSpace Mâ‚‚\ninstâœâ´ : AddCommMonoid Mâ‚‚\ninstâœÂ³ : Module ğ•œâ‚ Mâ‚\ninstâœÂ² : Module ğ•œâ‚‚ Mâ‚‚\ninstâœÂ¹ : ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚\ninstâœ : T2Space Mâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚\nhf : IsCompactOperator â‡‘f\nS : Set Mâ‚\nhS : Bornology.IsVonNBounded ğ•œâ‚ S\nâŠ¢ IsCompact (closure (Set.image (â‡‘f) S))","decl":"theorem IsCompactOperator.isCompact_closure_image_of_isVonNBounded [T2Space Mâ‚‚] {f : Mâ‚ â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚}\n    (hf : IsCompactOperator f) {S : Set Mâ‚} (hS : IsVonNBounded ğ•œâ‚ S) :\n    IsCompact (closure <| f '' S) :=\n  let âŸ¨_, hK, hKfâŸ© := hf.image_subset_compact_of_isVonNBounded hS\n  hK.closure_of_subset hKf\n\n"}
{"name":"IsCompactOperator.image_subset_compact_of_bounded","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œâ‚\ninstâœâ¶ : SeminormedRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œâ‚ ğ•œâ‚‚\nMâ‚ : Type u_3\nMâ‚‚ : Type u_4\ninstâœâµ : SeminormedAddCommGroup Mâ‚\ninstâœâ´ : TopologicalSpace Mâ‚‚\ninstâœÂ³ : AddCommMonoid Mâ‚‚\ninstâœÂ² : NormedSpace ğ•œâ‚ Mâ‚\ninstâœÂ¹ : Module ğ•œâ‚‚ Mâ‚‚\ninstâœ : ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚\nhf : IsCompactOperator â‡‘f\nS : Set Mâ‚\nhS : Bornology.IsBounded S\nâŠ¢ Exists fun K => And (IsCompact K) (HasSubset.Subset (Set.image (â‡‘f) S) K)","decl":"theorem IsCompactOperator.image_subset_compact_of_bounded [ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚]\n    {f : Mâ‚ â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚} (hf : IsCompactOperator f) {S : Set Mâ‚} (hS : Bornology.IsBounded S) :\n    âˆƒ K : Set Mâ‚‚, IsCompact K âˆ§ f '' S âŠ† K :=\n  hf.image_subset_compact_of_isVonNBounded <| by rwa [NormedSpace.isVonNBounded_iff]\n\n"}
{"name":"IsCompactOperator.isCompact_closure_image_of_bounded","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œâ‚\ninstâœâ· : SeminormedRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œâ‚ ğ•œâ‚‚\nMâ‚ : Type u_3\nMâ‚‚ : Type u_4\ninstâœâ¶ : SeminormedAddCommGroup Mâ‚\ninstâœâµ : TopologicalSpace Mâ‚‚\ninstâœâ´ : AddCommMonoid Mâ‚‚\ninstâœÂ³ : NormedSpace ğ•œâ‚ Mâ‚\ninstâœÂ² : Module ğ•œâ‚‚ Mâ‚‚\ninstâœÂ¹ : ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚\ninstâœ : T2Space Mâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚\nhf : IsCompactOperator â‡‘f\nS : Set Mâ‚\nhS : Bornology.IsBounded S\nâŠ¢ IsCompact (closure (Set.image (â‡‘f) S))","decl":"theorem IsCompactOperator.isCompact_closure_image_of_bounded [ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚]\n    [T2Space Mâ‚‚] {f : Mâ‚ â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚} (hf : IsCompactOperator f) {S : Set Mâ‚}\n    (hS : Bornology.IsBounded S) : IsCompact (closure <| f '' S) :=\n  hf.isCompact_closure_image_of_isVonNBounded <| by rwa [NormedSpace.isVonNBounded_iff]\n\n"}
{"name":"IsCompactOperator.image_ball_subset_compact","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œâ‚\ninstâœâ¶ : SeminormedRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œâ‚ ğ•œâ‚‚\nMâ‚ : Type u_3\nMâ‚‚ : Type u_4\ninstâœâµ : SeminormedAddCommGroup Mâ‚\ninstâœâ´ : TopologicalSpace Mâ‚‚\ninstâœÂ³ : AddCommMonoid Mâ‚‚\ninstâœÂ² : NormedSpace ğ•œâ‚ Mâ‚\ninstâœÂ¹ : Module ğ•œâ‚‚ Mâ‚‚\ninstâœ : ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚\nhf : IsCompactOperator â‡‘f\nr : Real\nâŠ¢ Exists fun K => And (IsCompact K) (HasSubset.Subset (Set.image (â‡‘f) (Metric.ball 0 r)) K)","decl":"theorem IsCompactOperator.image_ball_subset_compact [ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚] {f : Mâ‚ â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚}\n    (hf : IsCompactOperator f) (r : â„) : âˆƒ K : Set Mâ‚‚, IsCompact K âˆ§ f '' Metric.ball 0 r âŠ† K :=\n  hf.image_subset_compact_of_isVonNBounded (NormedSpace.isVonNBounded_ball ğ•œâ‚ Mâ‚ r)\n\n"}
{"name":"IsCompactOperator.image_closedBall_subset_compact","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œâ‚\ninstâœâ¶ : SeminormedRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œâ‚ ğ•œâ‚‚\nMâ‚ : Type u_3\nMâ‚‚ : Type u_4\ninstâœâµ : SeminormedAddCommGroup Mâ‚\ninstâœâ´ : TopologicalSpace Mâ‚‚\ninstâœÂ³ : AddCommMonoid Mâ‚‚\ninstâœÂ² : NormedSpace ğ•œâ‚ Mâ‚\ninstâœÂ¹ : Module ğ•œâ‚‚ Mâ‚‚\ninstâœ : ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚\nhf : IsCompactOperator â‡‘f\nr : Real\nâŠ¢ Exists fun K => And (IsCompact K) (HasSubset.Subset (Set.image (â‡‘f) (Metric.closedBall 0 r)) K)","decl":"theorem IsCompactOperator.image_closedBall_subset_compact [ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚]\n    {f : Mâ‚ â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚} (hf : IsCompactOperator f) (r : â„) :\n    âˆƒ K : Set Mâ‚‚, IsCompact K âˆ§ f '' Metric.closedBall 0 r âŠ† K :=\n  hf.image_subset_compact_of_isVonNBounded (NormedSpace.isVonNBounded_closedBall ğ•œâ‚ Mâ‚ r)\n\n"}
{"name":"IsCompactOperator.isCompact_closure_image_ball","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œâ‚\ninstâœâ· : SeminormedRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œâ‚ ğ•œâ‚‚\nMâ‚ : Type u_3\nMâ‚‚ : Type u_4\ninstâœâ¶ : SeminormedAddCommGroup Mâ‚\ninstâœâµ : TopologicalSpace Mâ‚‚\ninstâœâ´ : AddCommMonoid Mâ‚‚\ninstâœÂ³ : NormedSpace ğ•œâ‚ Mâ‚\ninstâœÂ² : Module ğ•œâ‚‚ Mâ‚‚\ninstâœÂ¹ : ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚\ninstâœ : T2Space Mâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚\nhf : IsCompactOperator â‡‘f\nr : Real\nâŠ¢ IsCompact (closure (Set.image (â‡‘f) (Metric.ball 0 r)))","decl":"theorem IsCompactOperator.isCompact_closure_image_ball [ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚] [T2Space Mâ‚‚]\n    {f : Mâ‚ â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚} (hf : IsCompactOperator f) (r : â„) :\n    IsCompact (closure <| f '' Metric.ball 0 r) :=\n  hf.isCompact_closure_image_of_isVonNBounded (NormedSpace.isVonNBounded_ball ğ•œâ‚ Mâ‚ r)\n\n"}
{"name":"IsCompactOperator.isCompact_closure_image_closedBall","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œâ‚\ninstâœâ· : SeminormedRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œâ‚ ğ•œâ‚‚\nMâ‚ : Type u_3\nMâ‚‚ : Type u_4\ninstâœâ¶ : SeminormedAddCommGroup Mâ‚\ninstâœâµ : TopologicalSpace Mâ‚‚\ninstâœâ´ : AddCommMonoid Mâ‚‚\ninstâœÂ³ : NormedSpace ğ•œâ‚ Mâ‚\ninstâœÂ² : Module ğ•œâ‚‚ Mâ‚‚\ninstâœÂ¹ : ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚\ninstâœ : T2Space Mâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚\nhf : IsCompactOperator â‡‘f\nr : Real\nâŠ¢ IsCompact (closure (Set.image (â‡‘f) (Metric.closedBall 0 r)))","decl":"theorem IsCompactOperator.isCompact_closure_image_closedBall [ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚]\n    [T2Space Mâ‚‚] {f : Mâ‚ â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚} (hf : IsCompactOperator f) (r : â„) :\n    IsCompact (closure <| f '' Metric.closedBall 0 r) :=\n  hf.isCompact_closure_image_of_isVonNBounded (NormedSpace.isVonNBounded_closedBall ğ•œâ‚ Mâ‚ r)\n\n"}
{"name":"isCompactOperator_iff_image_ball_subset_compact","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œâ‚\ninstâœâ¶ : SeminormedRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œâ‚ ğ•œâ‚‚\nMâ‚ : Type u_3\nMâ‚‚ : Type u_4\ninstâœâµ : SeminormedAddCommGroup Mâ‚\ninstâœâ´ : TopologicalSpace Mâ‚‚\ninstâœÂ³ : AddCommMonoid Mâ‚‚\ninstâœÂ² : NormedSpace ğ•œâ‚ Mâ‚\ninstâœÂ¹ : Module ğ•œâ‚‚ Mâ‚‚\ninstâœ : ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Iff (IsCompactOperator â‡‘f) (Exists fun K => And (IsCompact K) (HasSubset.Subset (Set.image (â‡‘f) (Metric.ball 0 r)) K))","decl":"theorem isCompactOperator_iff_image_ball_subset_compact [ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚]\n    (f : Mâ‚ â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚) {r : â„} (hr : 0 < r) :\n    IsCompactOperator f â†” âˆƒ K : Set Mâ‚‚, IsCompact K âˆ§ f '' Metric.ball 0 r âŠ† K :=\n  âŸ¨fun hf => hf.image_ball_subset_compact r, fun âŸ¨K, hK, hKrâŸ© =>\n    (isCompactOperator_iff_exists_mem_nhds_image_subset_compact f).mpr\n      âŸ¨Metric.ball 0 r, ball_mem_nhds _ hr, K, hK, hKrâŸ©âŸ©\n\n"}
{"name":"isCompactOperator_iff_image_closedBall_subset_compact","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ· : NontriviallyNormedField ğ•œâ‚\ninstâœâ¶ : SeminormedRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œâ‚ ğ•œâ‚‚\nMâ‚ : Type u_3\nMâ‚‚ : Type u_4\ninstâœâµ : SeminormedAddCommGroup Mâ‚\ninstâœâ´ : TopologicalSpace Mâ‚‚\ninstâœÂ³ : AddCommMonoid Mâ‚‚\ninstâœÂ² : NormedSpace ğ•œâ‚ Mâ‚\ninstâœÂ¹ : Module ğ•œâ‚‚ Mâ‚‚\ninstâœ : ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Iff (IsCompactOperator â‡‘f) (Exists fun K => And (IsCompact K) (HasSubset.Subset (Set.image (â‡‘f) (Metric.closedBall 0 r)) K))","decl":"theorem isCompactOperator_iff_image_closedBall_subset_compact [ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚]\n    (f : Mâ‚ â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚) {r : â„} (hr : 0 < r) :\n    IsCompactOperator f â†” âˆƒ K : Set Mâ‚‚, IsCompact K âˆ§ f '' Metric.closedBall 0 r âŠ† K :=\n  âŸ¨fun hf => hf.image_closedBall_subset_compact r, fun âŸ¨K, hK, hKrâŸ© =>\n    (isCompactOperator_iff_exists_mem_nhds_image_subset_compact f).mpr\n      âŸ¨Metric.closedBall 0 r, closedBall_mem_nhds _ hr, K, hK, hKrâŸ©âŸ©\n\n"}
{"name":"isCompactOperator_iff_isCompact_closure_image_ball","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œâ‚\ninstâœâ· : SeminormedRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œâ‚ ğ•œâ‚‚\nMâ‚ : Type u_3\nMâ‚‚ : Type u_4\ninstâœâ¶ : SeminormedAddCommGroup Mâ‚\ninstâœâµ : TopologicalSpace Mâ‚‚\ninstâœâ´ : AddCommMonoid Mâ‚‚\ninstâœÂ³ : NormedSpace ğ•œâ‚ Mâ‚\ninstâœÂ² : Module ğ•œâ‚‚ Mâ‚‚\ninstâœÂ¹ : ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚\ninstâœ : T2Space Mâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Iff (IsCompactOperator â‡‘f) (IsCompact (closure (Set.image (â‡‘f) (Metric.ball 0 r))))","decl":"theorem isCompactOperator_iff_isCompact_closure_image_ball [ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚] [T2Space Mâ‚‚]\n    (f : Mâ‚ â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚) {r : â„} (hr : 0 < r) :\n    IsCompactOperator f â†” IsCompact (closure <| f '' Metric.ball 0 r) :=\n  âŸ¨fun hf => hf.isCompact_closure_image_ball r, fun hf =>\n    (isCompactOperator_iff_exists_mem_nhds_isCompact_closure_image f).mpr\n      âŸ¨Metric.ball 0 r, ball_mem_nhds _ hr, hfâŸ©âŸ©\n\n"}
{"name":"isCompactOperator_iff_isCompact_closure_image_closedBall","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœâ¸ : NontriviallyNormedField ğ•œâ‚\ninstâœâ· : SeminormedRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œâ‚ ğ•œâ‚‚\nMâ‚ : Type u_3\nMâ‚‚ : Type u_4\ninstâœâ¶ : SeminormedAddCommGroup Mâ‚\ninstâœâµ : TopologicalSpace Mâ‚‚\ninstâœâ´ : AddCommMonoid Mâ‚‚\ninstâœÂ³ : NormedSpace ğ•œâ‚ Mâ‚\ninstâœÂ² : Module ğ•œâ‚‚ Mâ‚‚\ninstâœÂ¹ : ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚\ninstâœ : T2Space Mâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Iff (IsCompactOperator â‡‘f) (IsCompact (closure (Set.image (â‡‘f) (Metric.closedBall 0 r))))","decl":"theorem isCompactOperator_iff_isCompact_closure_image_closedBall [ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚]\n    [T2Space Mâ‚‚] (f : Mâ‚ â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚) {r : â„} (hr : 0 < r) :\n    IsCompactOperator f â†” IsCompact (closure <| f '' Metric.closedBall 0 r) :=\n  âŸ¨fun hf => hf.isCompact_closure_image_closedBall r, fun hf =>\n    (isCompactOperator_iff_exists_mem_nhds_isCompact_closure_image f).mpr\n      âŸ¨Metric.closedBall 0 r, closedBall_mem_nhds _ hr, hfâŸ©âŸ©\n\n"}
{"name":"IsCompactOperator.smul","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"Mâ‚ : Type u_3\nMâ‚‚ : Type u_4\ninstâœâ¶ : TopologicalSpace Mâ‚\ninstâœâµ : AddCommMonoid Mâ‚\ninstâœâ´ : TopologicalSpace Mâ‚‚\ninstâœÂ³ : AddCommMonoid Mâ‚‚\nS : Type u_6\ninstâœÂ² : Monoid S\ninstâœÂ¹ : DistribMulAction S Mâ‚‚\ninstâœ : ContinuousConstSMul S Mâ‚‚\nf : Mâ‚ â†’ Mâ‚‚\nhf : IsCompactOperator f\nc : S\nâŠ¢ IsCompactOperator (HSMul.hSMul c f)","decl":"theorem IsCompactOperator.smul {S : Type*} [Monoid S] [DistribMulAction S Mâ‚‚]\n    [ContinuousConstSMul S Mâ‚‚] {f : Mâ‚ â†’ Mâ‚‚} (hf : IsCompactOperator f) (c : S) :\n    IsCompactOperator (c â€¢ f) :=\n  let âŸ¨K, hK, hKfâŸ© := hf\n  âŸ¨c â€¢ K, hK.image <| continuous_id.const_smul c,\n    mem_of_superset hKf fun _ hx => smul_mem_smul_set hxâŸ©\n\n"}
{"name":"IsCompactOperator.add","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"Mâ‚ : Type u_3\nMâ‚‚ : Type u_4\ninstâœâ´ : TopologicalSpace Mâ‚\ninstâœÂ³ : AddCommMonoid Mâ‚\ninstâœÂ² : TopologicalSpace Mâ‚‚\ninstâœÂ¹ : AddCommMonoid Mâ‚‚\ninstâœ : ContinuousAdd Mâ‚‚\nf g : Mâ‚ â†’ Mâ‚‚\nhf : IsCompactOperator f\nhg : IsCompactOperator g\nâŠ¢ IsCompactOperator (HAdd.hAdd f g)","decl":"theorem IsCompactOperator.add [ContinuousAdd Mâ‚‚] {f g : Mâ‚ â†’ Mâ‚‚} (hf : IsCompactOperator f)\n    (hg : IsCompactOperator g) : IsCompactOperator (f + g) :=\n  let âŸ¨A, hA, hAfâŸ© := hf\n  let âŸ¨B, hB, hBgâŸ© := hg\n  âŸ¨A + B, hA.add hB,\n    mem_of_superset (inter_mem hAf hBg) fun _ âŸ¨hxA, hxBâŸ© => Set.add_mem_add hxA hxBâŸ©\n\n"}
{"name":"IsCompactOperator.neg","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"Mâ‚ : Type u_3\nMâ‚„ : Type u_5\ninstâœâ´ : TopologicalSpace Mâ‚\ninstâœÂ³ : AddCommMonoid Mâ‚\ninstâœÂ² : TopologicalSpace Mâ‚„\ninstâœÂ¹ : AddCommGroup Mâ‚„\ninstâœ : ContinuousNeg Mâ‚„\nf : Mâ‚ â†’ Mâ‚„\nhf : IsCompactOperator f\nâŠ¢ IsCompactOperator (Neg.neg f)","decl":"theorem IsCompactOperator.neg [ContinuousNeg Mâ‚„] {f : Mâ‚ â†’ Mâ‚„} (hf : IsCompactOperator f) :\n    IsCompactOperator (-f) :=\n  let âŸ¨K, hK, hKfâŸ© := hf\n  âŸ¨-K, hK.neg, mem_of_superset hKf fun x (hx : f x âˆˆ K) => Set.neg_mem_neg.mpr hxâŸ©\n\n"}
{"name":"IsCompactOperator.sub","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"Mâ‚ : Type u_3\nMâ‚„ : Type u_5\ninstâœâ´ : TopologicalSpace Mâ‚\ninstâœÂ³ : AddCommMonoid Mâ‚\ninstâœÂ² : TopologicalSpace Mâ‚„\ninstâœÂ¹ : AddCommGroup Mâ‚„\ninstâœ : TopologicalAddGroup Mâ‚„\nf g : Mâ‚ â†’ Mâ‚„\nhf : IsCompactOperator f\nhg : IsCompactOperator g\nâŠ¢ IsCompactOperator (HSub.hSub f g)","decl":"theorem IsCompactOperator.sub [TopologicalAddGroup Mâ‚„] {f g : Mâ‚ â†’ Mâ‚„} (hf : IsCompactOperator f)\n    (hg : IsCompactOperator g) : IsCompactOperator (f - g) := by\n  rw [sub_eq_add_neg]; exact hf.add hg.neg\n\n"}
{"name":"IsCompactOperator.comp_clm","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"Râ‚ : Type u_1\nRâ‚‚ : Type u_2\ninstâœâ¸ : Semiring Râ‚\ninstâœâ· : Semiring Râ‚‚\nÏƒâ‚â‚‚ : RingHom Râ‚ Râ‚‚\nMâ‚ : Type u_4\nMâ‚‚ : Type u_5\nMâ‚ƒ : Type u_6\ninstâœâ¶ : TopologicalSpace Mâ‚\ninstâœâµ : TopologicalSpace Mâ‚‚\ninstâœâ´ : TopologicalSpace Mâ‚ƒ\ninstâœÂ³ : AddCommMonoid Mâ‚\ninstâœÂ² : Module Râ‚ Mâ‚\ninstâœÂ¹ : AddCommMonoid Mâ‚‚\ninstâœ : Module Râ‚‚ Mâ‚‚\nf : Mâ‚‚ â†’ Mâ‚ƒ\nhf : IsCompactOperator f\ng : ContinuousLinearMap Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚\nâŠ¢ IsCompactOperator (Function.comp f â‡‘g)","decl":"theorem IsCompactOperator.comp_clm [AddCommMonoid Mâ‚‚] [Module Râ‚‚ Mâ‚‚] {f : Mâ‚‚ â†’ Mâ‚ƒ}\n    (hf : IsCompactOperator f) (g : Mâ‚ â†’SL[Ïƒâ‚â‚‚] Mâ‚‚) : IsCompactOperator (f âˆ˜ g) := by\n  have := g.continuous.tendsto 0\n  rw [map_zero] at this\n  rcases hf with âŸ¨K, hK, hKfâŸ©\n  exact âŸ¨K, hK, this hKfâŸ©\n\n"}
{"name":"IsCompactOperator.continuous_comp","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"Mâ‚ : Type u_4\nMâ‚‚ : Type u_5\nMâ‚ƒ : Type u_6\ninstâœÂ³ : TopologicalSpace Mâ‚\ninstâœÂ² : TopologicalSpace Mâ‚‚\ninstâœÂ¹ : TopologicalSpace Mâ‚ƒ\ninstâœ : AddCommMonoid Mâ‚\nf : Mâ‚ â†’ Mâ‚‚\nhf : IsCompactOperator f\ng : Mâ‚‚ â†’ Mâ‚ƒ\nhg : Continuous g\nâŠ¢ IsCompactOperator (Function.comp g f)","decl":"theorem IsCompactOperator.continuous_comp {f : Mâ‚ â†’ Mâ‚‚} (hf : IsCompactOperator f) {g : Mâ‚‚ â†’ Mâ‚ƒ}\n    (hg : Continuous g) : IsCompactOperator (g âˆ˜ f) := by\n  rcases hf with âŸ¨K, hK, hKfâŸ©\n  refine âŸ¨g '' K, hK.image hg, mem_of_superset hKf ?_âŸ©\n  rw [preimage_comp]\n  exact preimage_mono (subset_preimage_image _ _)\n\n"}
{"name":"IsCompactOperator.clm_comp","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"Râ‚‚ : Type u_2\nRâ‚ƒ : Type u_3\ninstâœâ¹ : Semiring Râ‚‚\ninstâœâ¸ : Semiring Râ‚ƒ\nÏƒâ‚‚â‚ƒ : RingHom Râ‚‚ Râ‚ƒ\nMâ‚ : Type u_4\nMâ‚‚ : Type u_5\nMâ‚ƒ : Type u_6\ninstâœâ· : TopologicalSpace Mâ‚\ninstâœâ¶ : TopologicalSpace Mâ‚‚\ninstâœâµ : TopologicalSpace Mâ‚ƒ\ninstâœâ´ : AddCommMonoid Mâ‚\ninstâœÂ³ : AddCommMonoid Mâ‚‚\ninstâœÂ² : Module Râ‚‚ Mâ‚‚\ninstâœÂ¹ : AddCommMonoid Mâ‚ƒ\ninstâœ : Module Râ‚ƒ Mâ‚ƒ\nf : Mâ‚ â†’ Mâ‚‚\nhf : IsCompactOperator f\ng : ContinuousLinearMap Ïƒâ‚‚â‚ƒ Mâ‚‚ Mâ‚ƒ\nâŠ¢ IsCompactOperator (Function.comp (â‡‘g) f)","decl":"theorem IsCompactOperator.clm_comp [AddCommMonoid Mâ‚‚] [Module Râ‚‚ Mâ‚‚] [AddCommMonoid Mâ‚ƒ]\n    [Module Râ‚ƒ Mâ‚ƒ] {f : Mâ‚ â†’ Mâ‚‚} (hf : IsCompactOperator f) (g : Mâ‚‚ â†’SL[Ïƒâ‚‚â‚ƒ] Mâ‚ƒ) :\n    IsCompactOperator (g âˆ˜ f) :=\n  hf.continuous_comp g.continuous\n\n"}
{"name":"IsCompactOperator.codRestrict","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"Râ‚‚ : Type u_1\ninstâœâµ : Semiring Râ‚‚\nMâ‚ : Type u_2\nMâ‚‚ : Type u_3\ninstâœâ´ : TopologicalSpace Mâ‚\ninstâœÂ³ : TopologicalSpace Mâ‚‚\ninstâœÂ² : AddCommMonoid Mâ‚\ninstâœÂ¹ : AddCommMonoid Mâ‚‚\ninstâœ : Module Râ‚‚ Mâ‚‚\nf : Mâ‚ â†’ Mâ‚‚\nhf : IsCompactOperator f\nV : Submodule Râ‚‚ Mâ‚‚\nhV : âˆ€ (x : Mâ‚), Membership.mem V (f x)\nh_closed : IsClosed â†‘V\nâŠ¢ IsCompactOperator (Set.codRestrict f (â†‘V) hV)","decl":"theorem IsCompactOperator.codRestrict {f : Mâ‚ â†’ Mâ‚‚} (hf : IsCompactOperator f) {V : Submodule Râ‚‚ Mâ‚‚}\n    (hV : âˆ€ x, f x âˆˆ V) (h_closed : IsClosed (V : Set Mâ‚‚)) :\n    IsCompactOperator (Set.codRestrict f V hV) :=\n  let âŸ¨_, hK, hKfâŸ© := hf\n  âŸ¨_, h_closed.isClosedEmbedding_subtypeVal.isCompact_preimage hK, hKfâŸ©\n\n"}
{"name":"IsCompactOperator.restrict","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"Râ‚ : Type u_1\ninstâœÂ³ : Semiring Râ‚\nMâ‚ : Type u_3\ninstâœÂ² : TopologicalSpace Mâ‚\ninstâœÂ¹ : AddCommMonoid Mâ‚\ninstâœ : Module Râ‚ Mâ‚\nf : LinearMap (RingHom.id Râ‚) Mâ‚ Mâ‚\nhf : IsCompactOperator â‡‘f\nV : Submodule Râ‚ Mâ‚\nhV : âˆ€ (v : Mâ‚), Membership.mem V v â†’ Membership.mem V (f v)\nh_closed : IsClosed â†‘V\nâŠ¢ IsCompactOperator â‡‘(f.restrict hV)","decl":"/-- If a compact operator preserves a closed submodule, its restriction to that submodule is\ncompact.\n\nNote that, following mathlib's convention in linear algebra, `restrict` designates the restriction\nof an endomorphism `f : E â†’â‚— E` to an endomorphism `f' : â†¥V â†’â‚— â†¥V`. To prove that the restriction\n`f' : â†¥U â†’â‚›â‚— â†¥V` of a compact operator `f : E â†’â‚›â‚— F` is compact, apply\n`IsCompactOperator.codRestrict` to `f âˆ˜ U.subtypeL`, which is compact by\n`IsCompactOperator.comp_clm`. -/\ntheorem IsCompactOperator.restrict {f : Mâ‚ â†’â‚—[Râ‚] Mâ‚} (hf : IsCompactOperator f)\n    {V : Submodule Râ‚ Mâ‚} (hV : âˆ€ v âˆˆ V, f v âˆˆ V) (h_closed : IsClosed (V : Set Mâ‚)) :\n    IsCompactOperator (f.restrict hV) :=\n  (hf.comp_clm V.subtypeL).codRestrict (SetLike.forall.2 hV) h_closed\n\n"}
{"name":"IsCompactOperator.restrict'","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"Râ‚‚ : Type u_2\ninstâœâ´ : Semiring Râ‚‚\nMâ‚‚ : Type u_4\ninstâœÂ³ : UniformSpace Mâ‚‚\ninstâœÂ² : AddCommMonoid Mâ‚‚\ninstâœÂ¹ : Module Râ‚‚ Mâ‚‚\ninstâœ : T0Space Mâ‚‚\nf : LinearMap (RingHom.id Râ‚‚) Mâ‚‚ Mâ‚‚\nhf : IsCompactOperator â‡‘f\nV : Submodule Râ‚‚ Mâ‚‚\nhV : âˆ€ (v : Mâ‚‚), Membership.mem V v â†’ Membership.mem V (f v)\nhcomplete : CompleteSpace (Subtype fun x => Membership.mem V x)\nâŠ¢ IsCompactOperator â‡‘(f.restrict hV)","decl":"/-- If a compact operator preserves a complete submodule, its restriction to that submodule is\ncompact.\n\nNote that, following mathlib's convention in linear algebra, `restrict` designates the restriction\nof an endomorphism `f : E â†’â‚— E` to an endomorphism `f' : â†¥V â†’â‚— â†¥V`. To prove that the restriction\n`f' : â†¥U â†’â‚›â‚— â†¥V` of a compact operator `f : E â†’â‚›â‚— F` is compact, apply\n`IsCompactOperator.codRestrict` to `f âˆ˜ U.subtypeL`, which is compact by\n`IsCompactOperator.comp_clm`. -/\ntheorem IsCompactOperator.restrict' [T0Space Mâ‚‚] {f : Mâ‚‚ â†’â‚—[Râ‚‚] Mâ‚‚}\n    (hf : IsCompactOperator f) {V : Submodule Râ‚‚ Mâ‚‚} (hV : âˆ€ v âˆˆ V, f v âˆˆ V)\n    [hcomplete : CompleteSpace V] : IsCompactOperator (f.restrict hV) :=\n  hf.restrict hV (completeSpace_coe_iff_isComplete.mp hcomplete).isClosed\n\n"}
{"name":"IsCompactOperator.continuous","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœÂ¹Â² : NontriviallyNormedField ğ•œâ‚\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œâ‚ ğ•œâ‚‚\ninstâœÂ¹â° : RingHomIsometric Ïƒâ‚â‚‚\nMâ‚ : Type u_3\nMâ‚‚ : Type u_4\ninstâœâ¹ : TopologicalSpace Mâ‚\ninstâœâ¸ : AddCommGroup Mâ‚\ninstâœâ· : TopologicalSpace Mâ‚‚\ninstâœâ¶ : AddCommGroup Mâ‚‚\ninstâœâµ : Module ğ•œâ‚ Mâ‚\ninstâœâ´ : Module ğ•œâ‚‚ Mâ‚‚\ninstâœÂ³ : TopologicalAddGroup Mâ‚\ninstâœÂ² : ContinuousConstSMul ğ•œâ‚ Mâ‚\ninstâœÂ¹ : TopologicalAddGroup Mâ‚‚\ninstâœ : ContinuousSMul ğ•œâ‚‚ Mâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚\nhf : IsCompactOperator â‡‘f\nâŠ¢ Continuous â‡‘f","decl":"@[continuity]\ntheorem IsCompactOperator.continuous {f : Mâ‚ â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚} (hf : IsCompactOperator f) :\n    Continuous f := by\n  letI : UniformSpace Mâ‚‚ := TopologicalAddGroup.toUniformSpace _\n  haveI : UniformAddGroup Mâ‚‚ := comm_topologicalAddGroup_is_uniform\n  -- Since `f` is linear, we only need to show that it is continuous at zero.\n  -- Let `U` be a neighborhood of `0` in `Mâ‚‚`.\n  refine continuous_of_continuousAt_zero f fun U hU => ?_\n  rw [map_zero] at hU\n  -- The compactness of `f` gives us a compact set `K : Set Mâ‚‚` such that `f â»Â¹' K` is a\n  -- neighborhood of `0` in `Mâ‚`.\n  rcases hf with âŸ¨K, hK, hKfâŸ©\n  -- But any compact set is totally bounded, hence Von-Neumann bounded. Thus, `K` absorbs `U`.\n  -- This gives `r > 0` such that `âˆ€ a : ğ•œâ‚‚, r â‰¤ â€–aâ€– â†’ K âŠ† a â€¢ U`.\n  rcases (hK.totallyBounded.isVonNBounded ğ•œâ‚‚ hU).exists_pos with âŸ¨r, hr, hrUâŸ©\n  -- Choose `c : ğ•œâ‚‚` with `r < â€–câ€–`.\n  rcases NormedField.exists_lt_norm ğ•œâ‚ r with âŸ¨c, hcâŸ©\n  have hcnz : c â‰  0 := ne_zero_of_norm_ne_zero (hr.trans hc).ne.symm\n  -- We have `f â»Â¹' ((Ïƒâ‚â‚‚ câ»Â¹) â€¢ K) = câ»Â¹ â€¢ f â»Â¹' K âˆˆ ğ“ 0`. Thus, showing that\n  -- `(Ïƒâ‚â‚‚ câ»Â¹) â€¢ K âŠ† U` is enough to deduce that `f â»Â¹' U âˆˆ ğ“ 0`.\n  suffices (Ïƒâ‚â‚‚ <| câ»Â¹) â€¢ K âŠ† U by\n    refine mem_of_superset ?_ this\n    have : IsUnit câ»Â¹ := hcnz.isUnit.inv\n    rwa [mem_map, preimage_smul_setâ‚›â‚— _ _ _ f this, set_smul_mem_nhds_zero_iff (inv_ne_zero hcnz)]\n  -- Since `Ïƒâ‚â‚‚ câ»Â¹` = `(Ïƒâ‚â‚‚ c)â»Â¹`, we have to prove that `K âŠ† Ïƒâ‚â‚‚ c â€¢ U`.\n  rw [map_invâ‚€, â† subset_smul_set_iffâ‚€ ((map_ne_zero Ïƒâ‚â‚‚).mpr hcnz)]\n  -- But `Ïƒâ‚â‚‚` is isometric, so `â€–Ïƒâ‚â‚‚ câ€– = â€–câ€– > r`, which concludes the argument since\n  -- `âˆ€ a : ğ•œâ‚‚, r â‰¤ â€–aâ€– â†’ K âŠ† a â€¢ U`.\n  refine hrU (Ïƒâ‚â‚‚ c) ?_\n  rw [RingHomIsometric.is_iso]\n  exact hc.le\n\n"}
{"name":"ContinuousLinearMap.mkOfIsCompactOperator_to_linearMap","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœÂ¹Â² : NontriviallyNormedField ğ•œâ‚\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œâ‚ ğ•œâ‚‚\ninstâœÂ¹â° : RingHomIsometric Ïƒâ‚â‚‚\nMâ‚ : Type u_3\nMâ‚‚ : Type u_4\ninstâœâ¹ : TopologicalSpace Mâ‚\ninstâœâ¸ : AddCommGroup Mâ‚\ninstâœâ· : TopologicalSpace Mâ‚‚\ninstâœâ¶ : AddCommGroup Mâ‚‚\ninstâœâµ : Module ğ•œâ‚ Mâ‚\ninstâœâ´ : Module ğ•œâ‚‚ Mâ‚‚\ninstâœÂ³ : TopologicalAddGroup Mâ‚\ninstâœÂ² : ContinuousConstSMul ğ•œâ‚ Mâ‚\ninstâœÂ¹ : TopologicalAddGroup Mâ‚‚\ninstâœ : ContinuousSMul ğ•œâ‚‚ Mâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚\nhf : IsCompactOperator â‡‘f\nâŠ¢ Eq (â†‘(ContinuousLinearMap.mkOfIsCompactOperator hf)) f","decl":"@[simp]\ntheorem ContinuousLinearMap.mkOfIsCompactOperator_to_linearMap {f : Mâ‚ â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚}\n    (hf : IsCompactOperator f) :\n    (ContinuousLinearMap.mkOfIsCompactOperator hf : Mâ‚ â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚) = f :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.coe_mkOfIsCompactOperator","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœÂ¹Â² : NontriviallyNormedField ğ•œâ‚\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œâ‚ ğ•œâ‚‚\ninstâœÂ¹â° : RingHomIsometric Ïƒâ‚â‚‚\nMâ‚ : Type u_3\nMâ‚‚ : Type u_4\ninstâœâ¹ : TopologicalSpace Mâ‚\ninstâœâ¸ : AddCommGroup Mâ‚\ninstâœâ· : TopologicalSpace Mâ‚‚\ninstâœâ¶ : AddCommGroup Mâ‚‚\ninstâœâµ : Module ğ•œâ‚ Mâ‚\ninstâœâ´ : Module ğ•œâ‚‚ Mâ‚‚\ninstâœÂ³ : TopologicalAddGroup Mâ‚\ninstâœÂ² : ContinuousConstSMul ğ•œâ‚ Mâ‚\ninstâœÂ¹ : TopologicalAddGroup Mâ‚‚\ninstâœ : ContinuousSMul ğ•œâ‚‚ Mâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚\nhf : IsCompactOperator â‡‘f\nâŠ¢ Eq â‡‘(ContinuousLinearMap.mkOfIsCompactOperator hf) â‡‘f","decl":"@[simp]\ntheorem ContinuousLinearMap.coe_mkOfIsCompactOperator {f : Mâ‚ â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚}\n    (hf : IsCompactOperator f) : (ContinuousLinearMap.mkOfIsCompactOperator hf : Mâ‚ â†’ Mâ‚‚) = f :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.mkOfIsCompactOperator_mem_compactOperator","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœÂ¹Â² : NontriviallyNormedField ğ•œâ‚\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œâ‚ ğ•œâ‚‚\ninstâœÂ¹â° : RingHomIsometric Ïƒâ‚â‚‚\nMâ‚ : Type u_3\nMâ‚‚ : Type u_4\ninstâœâ¹ : TopologicalSpace Mâ‚\ninstâœâ¸ : AddCommGroup Mâ‚\ninstâœâ· : TopologicalSpace Mâ‚‚\ninstâœâ¶ : AddCommGroup Mâ‚‚\ninstâœâµ : Module ğ•œâ‚ Mâ‚\ninstâœâ´ : Module ğ•œâ‚‚ Mâ‚‚\ninstâœÂ³ : TopologicalAddGroup Mâ‚\ninstâœÂ² : ContinuousConstSMul ğ•œâ‚ Mâ‚\ninstâœÂ¹ : TopologicalAddGroup Mâ‚‚\ninstâœ : ContinuousSMul ğ•œâ‚‚ Mâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚\nhf : IsCompactOperator â‡‘f\nâŠ¢ Membership.mem (compactOperator Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚) (ContinuousLinearMap.mkOfIsCompactOperator hf)","decl":"theorem ContinuousLinearMap.mkOfIsCompactOperator_mem_compactOperator {f : Mâ‚ â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚}\n    (hf : IsCompactOperator f) :\n    ContinuousLinearMap.mkOfIsCompactOperator hf âˆˆ compactOperator Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚ :=\n  hf\n\n"}
{"name":"isClosed_setOf_isCompactOperator","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œâ‚\ninstâœâ¹ : NormedField ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œâ‚ ğ•œâ‚‚\nMâ‚ : Type u_3\nMâ‚‚ : Type u_4\ninstâœâ¸ : SeminormedAddCommGroup Mâ‚\ninstâœâ· : AddCommGroup Mâ‚‚\ninstâœâ¶ : NormedSpace ğ•œâ‚ Mâ‚\ninstâœâµ : Module ğ•œâ‚‚ Mâ‚‚\ninstâœâ´ : UniformSpace Mâ‚‚\ninstâœÂ³ : UniformAddGroup Mâ‚‚\ninstâœÂ² : ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚\ninstâœÂ¹ : T2Space Mâ‚‚\ninstâœ : CompleteSpace Mâ‚‚\nâŠ¢ IsClosed (setOf fun f => IsCompactOperator â‡‘f)","decl":"/-- The set of compact operators from a normed space to a complete topological vector space is\nclosed. -/\ntheorem isClosed_setOf_isCompactOperator {ğ•œâ‚ ğ•œâ‚‚ : Type*} [NontriviallyNormedField ğ•œâ‚]\n    [NormedField ğ•œâ‚‚] {Ïƒâ‚â‚‚ : ğ•œâ‚ â†’+* ğ•œâ‚‚} {Mâ‚ Mâ‚‚ : Type*} [SeminormedAddCommGroup Mâ‚]\n    [AddCommGroup Mâ‚‚] [NormedSpace ğ•œâ‚ Mâ‚] [Module ğ•œâ‚‚ Mâ‚‚] [UniformSpace Mâ‚‚] [UniformAddGroup Mâ‚‚]\n    [ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚] [T2Space Mâ‚‚] [CompleteSpace Mâ‚‚] :\n    IsClosed { f : Mâ‚ â†’SL[Ïƒâ‚â‚‚] Mâ‚‚ | IsCompactOperator f } := by\n  refine isClosed_of_closure_subset ?_\n  rintro u hu\n  rw [mem_closure_iff_nhds_zero] at hu\n  suffices TotallyBounded (u '' Metric.closedBall 0 1) by\n    change IsCompactOperator (u : Mâ‚ â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚)\n    rw [isCompactOperator_iff_isCompact_closure_image_closedBall (u : Mâ‚ â†’â‚›â‚—[Ïƒâ‚â‚‚] Mâ‚‚) zero_lt_one]\n    exact isCompact_of_totallyBounded_isClosed this.closure isClosed_closure\n  rw [totallyBounded_iff_subset_finite_iUnion_nhds_zero]\n  intro U hU\n  rcases exists_nhds_zero_half hU with âŸ¨V, hV, hVUâŸ©\n  let SV : Set Mâ‚ Ã— Set Mâ‚‚ := âŸ¨closedBall 0 1, -VâŸ©\n  rcases hu { f | âˆ€ x âˆˆ SV.1, f x âˆˆ SV.2 }\n      (ContinuousLinearMap.hasBasis_nhds_zero.mem_of_mem\n        âŸ¨NormedSpace.isVonNBounded_closedBall _ _ _, neg_mem_nhds_zero Mâ‚‚ hVâŸ©) with\n    âŸ¨v, hv, huvâŸ©\n  rcases totallyBounded_iff_subset_finite_iUnion_nhds_zero.mp\n      (hv.isCompact_closure_image_closedBall 1).totallyBounded V hV with\n    âŸ¨T, hT, hTvâŸ©\n  have hTv : v '' closedBall 0 1 âŠ† _ := subset_closure.trans hTv\n  refine âŸ¨T, hT, ?_âŸ©\n  rw [image_subset_iff, preimage_iUnionâ‚‚] at hTv âŠ¢\n  intro x hx\n  specialize hTv hx\n  rw [mem_iUnionâ‚‚] at hTv âŠ¢\n  rcases hTv with âŸ¨t, ht, htxâŸ©\n  refine âŸ¨t, ht, ?_âŸ©\n  rw [mem_preimage, mem_vadd_set_iff_neg_vadd_mem, vadd_eq_add, neg_add_eq_sub] at htx âŠ¢\n  convert hVU _ htx _ (huv x hx) using 1\n  rw [ContinuousLinearMap.sub_apply]\n  abel\n\n"}
{"name":"compactOperator_topologicalClosure","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"ğ•œâ‚ : Type u_1\nğ•œâ‚‚ : Type u_2\ninstâœÂ¹â° : NontriviallyNormedField ğ•œâ‚\ninstâœâ¹ : NormedField ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œâ‚ ğ•œâ‚‚\nMâ‚ : Type u_3\nMâ‚‚ : Type u_4\ninstâœâ¸ : SeminormedAddCommGroup Mâ‚\ninstâœâ· : AddCommGroup Mâ‚‚\ninstâœâ¶ : NormedSpace ğ•œâ‚ Mâ‚\ninstâœâµ : Module ğ•œâ‚‚ Mâ‚‚\ninstâœâ´ : UniformSpace Mâ‚‚\ninstâœÂ³ : UniformAddGroup Mâ‚‚\ninstâœÂ² : ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚\ninstâœÂ¹ : T2Space Mâ‚‚\ninstâœ : CompleteSpace Mâ‚‚\nâŠ¢ Eq (compactOperator Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚).topologicalClosure (compactOperator Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚)","decl":"theorem compactOperator_topologicalClosure {ğ•œâ‚ ğ•œâ‚‚ : Type*} [NontriviallyNormedField ğ•œâ‚]\n    [NormedField ğ•œâ‚‚] {Ïƒâ‚â‚‚ : ğ•œâ‚ â†’+* ğ•œâ‚‚} {Mâ‚ Mâ‚‚ : Type*} [SeminormedAddCommGroup Mâ‚]\n    [AddCommGroup Mâ‚‚] [NormedSpace ğ•œâ‚ Mâ‚] [Module ğ•œâ‚‚ Mâ‚‚] [UniformSpace Mâ‚‚] [UniformAddGroup Mâ‚‚]\n    [ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚] [T2Space Mâ‚‚] [CompleteSpace Mâ‚‚] :\n    (compactOperator Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚).topologicalClosure = compactOperator Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚ :=\n  SetLike.ext' isClosed_setOf_isCompactOperator.closure_eq\n\n"}
{"name":"isCompactOperator_of_tendsto","module":"Mathlib.Analysis.Normed.Operator.Compact","initialProofState":"Î¹ : Type u_1\nğ•œâ‚ : Type u_2\nğ•œâ‚‚ : Type u_3\ninstâœÂ¹Â¹ : NontriviallyNormedField ğ•œâ‚\ninstâœÂ¹â° : NormedField ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œâ‚ ğ•œâ‚‚\nMâ‚ : Type u_4\nMâ‚‚ : Type u_5\ninstâœâ¹ : SeminormedAddCommGroup Mâ‚\ninstâœâ¸ : AddCommGroup Mâ‚‚\ninstâœâ· : NormedSpace ğ•œâ‚ Mâ‚\ninstâœâ¶ : Module ğ•œâ‚‚ Mâ‚‚\ninstâœâµ : UniformSpace Mâ‚‚\ninstâœâ´ : UniformAddGroup Mâ‚‚\ninstâœÂ³ : ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚\ninstâœÂ² : T2Space Mâ‚‚\ninstâœÂ¹ : CompleteSpace Mâ‚‚\nl : Filter Î¹\ninstâœ : l.NeBot\nF : Î¹ â†’ ContinuousLinearMap Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ Mâ‚ Mâ‚‚\nhf : Filter.Tendsto F l (nhds f)\nhF : Filter.Eventually (fun i => IsCompactOperator â‡‘(F i)) l\nâŠ¢ IsCompactOperator â‡‘f","decl":"theorem isCompactOperator_of_tendsto {Î¹ ğ•œâ‚ ğ•œâ‚‚ : Type*} [NontriviallyNormedField ğ•œâ‚]\n    [NormedField ğ•œâ‚‚] {Ïƒâ‚â‚‚ : ğ•œâ‚ â†’+* ğ•œâ‚‚} {Mâ‚ Mâ‚‚ : Type*} [SeminormedAddCommGroup Mâ‚]\n    [AddCommGroup Mâ‚‚] [NormedSpace ğ•œâ‚ Mâ‚] [Module ğ•œâ‚‚ Mâ‚‚] [UniformSpace Mâ‚‚] [UniformAddGroup Mâ‚‚]\n    [ContinuousConstSMul ğ•œâ‚‚ Mâ‚‚] [T2Space Mâ‚‚] [CompleteSpace Mâ‚‚] {l : Filter Î¹} [l.NeBot]\n    {F : Î¹ â†’ Mâ‚ â†’SL[Ïƒâ‚â‚‚] Mâ‚‚} {f : Mâ‚ â†’SL[Ïƒâ‚â‚‚] Mâ‚‚} (hf : Tendsto F l (ğ“ f))\n    (hF : âˆ€á¶  i in l, IsCompactOperator (F i)) : IsCompactOperator f :=\n  isClosed_setOf_isCompactOperator.mem_of_tendsto hf hF\n"}
