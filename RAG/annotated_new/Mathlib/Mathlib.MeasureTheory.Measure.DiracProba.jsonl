{"name":"CompletelyRegularSpace.exists_BCNN","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : CompletelyRegularSpace X\nK : Set X\nK_closed : IsClosed K\nx : X\nx_notin_K : Not (Membership.mem K x)\nâŠ¢ Exists fun f => And (Eq (f x) 1) (âˆ€ (y : X), Membership.mem K y â†’ Eq (f y) 0)","decl":"lemma CompletelyRegularSpace.exists_BCNN {X : Type*} [TopologicalSpace X] [CompletelyRegularSpace X]\n    {K : Set X} (K_closed : IsClosed K) {x : X} (x_notin_K : x âˆ‰ K) :\n    âˆƒ (f : X â†’áµ‡ â„â‰¥0), f x = 1 âˆ§ (âˆ€ y âˆˆ K, f y = 0) := by\n  obtain âŸ¨g, g_cont, gx_zero, g_one_on_KâŸ© :=\n    CompletelyRegularSpace.completely_regular x K K_closed x_notin_K\n  have g_bdd : âˆ€ x y, dist (Real.toNNReal (g x)) (Real.toNNReal (g y)) â‰¤ 1 := by\n    refine fun x y â†¦ ((Real.lipschitzWith_toNNReal).dist_le_mul (g x) (g y)).trans ?_\n    simpa using Real.dist_le_of_mem_Icc_01 (g x).prop (g y).prop\n  set g' := BoundedContinuousFunction.mkOfBound\n      âŸ¨fun x â†¦ Real.toNNReal (g x), continuous_real_toNNReal.comp g_cont.subtype_valâŸ© 1 g_bdd\n  set f := 1 - g'\n  refine âŸ¨f, by simp [f, g', gx_zero], fun y y_in_K â†¦ by simp [f, g', g_one_on_K y_in_K, tsub_self]âŸ©\n\n"}
{"name":"MeasureTheory.injective_diracProba","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_2\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : MeasurableSpace.SeparatesPoints X\nâŠ¢ Function.Injective fun x => MeasureTheory.diracProba x","decl":"/-- The assignment `x â†¦ diracProba x` is injective if all singletons are measurable. -/\nlemma injective_diracProba {X : Type*} [MeasurableSpace X] [MeasurableSpace.SeparatesPoints X] :\n    Function.Injective (fun (x : X) â†¦ diracProba x) := by\n  intro x y x_eq_y\n  rw [â† dirac_eq_dirac_iff]\n  rwa [Subtype.ext_iff] at x_eq_y\n\n"}
{"name":"MeasureTheory.diracProba_toMeasure_apply'","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nx : X\nA : Set X\nA_mble : MeasurableSet A\nâŠ¢ Eq (â†‘(MeasureTheory.diracProba x) A) (A.indicator 1 x)","decl":"@[simp] lemma diracProba_toMeasure_apply' (x : X) {A : Set X} (A_mble : MeasurableSet A) :\n    (diracProba x).toMeasure A = A.indicator 1 x := Measure.dirac_apply' x A_mble\n\n"}
{"name":"MeasureTheory.diracProba_toMeasure_apply_of_mem","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nx : X\nA : Set X\nx_in_A : Membership.mem A x\nâŠ¢ Eq (â†‘(MeasureTheory.diracProba x) A) 1","decl":"@[simp] lemma diracProba_toMeasure_apply_of_mem {x : X} {A : Set X} (x_in_A : x âˆˆ A) :\n    (diracProba x).toMeasure A = 1 := Measure.dirac_apply_of_mem x_in_A\n\n"}
{"name":"MeasureTheory.diracProba_toMeasure_apply","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : MeasurableSingletonClass X\nx : X\nA : Set X\nâŠ¢ Eq (â†‘(MeasureTheory.diracProba x) A) (A.indicator 1 x)","decl":"@[simp] lemma diracProba_toMeasure_apply [MeasurableSingletonClass X] (x : X) (A : Set X) :\n    (diracProba x).toMeasure A = A.indicator 1 x := Measure.dirac_apply _ _\n\n"}
{"name":"MeasureTheory.continuous_diracProba","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : OpensMeasurableSpace X\nâŠ¢ Continuous fun x => MeasureTheory.diracProba x","decl":"/-- The assignment `x â†¦ diracProba x` is continuous `X â†’ ProbabilityMeasure X`. -/\nlemma continuous_diracProba : Continuous (fun (x : X) â†¦ diracProba x) := by\n  rw [continuous_iff_continuousAt]\n  apply fun x â†¦ ProbabilityMeasure.tendsto_iff_forall_lintegral_tendsto.mpr fun f â†¦ ?_\n  have f_mble : Measurable (fun X â†¦ (f X : â„â‰¥0âˆž)) :=\n    measurable_coe_nnreal_ennreal_iff.mpr f.continuous.measurable\n  simp only [diracProba, ProbabilityMeasure.coe_mk, lintegral_dirac' _ f_mble]\n  exact (ENNReal.continuous_coe.comp f.continuous).continuousAt\n\n"}
{"name":"MeasureTheory.injective_diracProba_of_T0","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : OpensMeasurableSpace X\ninstâœ : T0Space X\nâŠ¢ Function.Injective fun x => MeasureTheory.diracProba x","decl":"/-- In a T0 topological space equipped with a sigma algebra which contains all open sets,\nthe assignment `x â†¦ diracProba x` is injective. -/\nlemma injective_diracProba_of_T0 [T0Space X] :\n    Function.Injective (fun (x : X) â†¦ diracProba x) := by\n  intro x y Î´x_eq_Î´y\n  by_contra x_ne_y\n  exact dirac_ne_dirac x_ne_y <| congr_arg Subtype.val Î´x_eq_Î´y\n\n"}
{"name":"MeasureTheory.not_tendsto_diracProba_of_not_tendsto","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : OpensMeasurableSpace X\ninstâœ : CompletelyRegularSpace X\nx : X\nL : Filter X\nh : Not (Filter.Tendsto id L (nhds x))\nâŠ¢ Not (Filter.Tendsto MeasureTheory.diracProba L (nhds (MeasureTheory.diracProba x)))","decl":"lemma not_tendsto_diracProba_of_not_tendsto [CompletelyRegularSpace X] {x : X} (L : Filter X)\n    (h : Â¬ Tendsto id L (ð“ x)) :\n    Â¬ Tendsto diracProba L (ð“ (diracProba x)) := by\n  obtain âŸ¨U, U_nhd, hUâŸ© : âˆƒ U, U âˆˆ ð“ x âˆ§ âˆƒá¶  x in L, x âˆ‰ U := by\n    by_contra! con\n    apply h\n    intro U U_nhd\n    simpa only [not_frequently, not_not] using con U U_nhd\n  have Uint_nhd : interior U âˆˆ ð“ x := by simpa only [interior_mem_nhds] using U_nhd\n  obtain âŸ¨f, fx_eq_one, f_vanishes_outsideâŸ© :=\n    CompletelyRegularSpace.exists_BCNN isOpen_interior.isClosed_compl\n      (by simpa only [mem_compl_iff, not_not] using mem_of_mem_nhds Uint_nhd)\n  rw [ProbabilityMeasure.tendsto_iff_forall_lintegral_tendsto, not_forall]\n  use f\n  simp only [diracProba, ProbabilityMeasure.coe_mk, fx_eq_one,\n             lintegral_dirac' _ (measurable_coe_nnreal_ennreal_iff.mpr f.continuous.measurable)]\n  apply not_tendsto_iff_exists_frequently_nmem.mpr\n  refine âŸ¨Ioi 0, Ioi_mem_nhds (by simp only [ENNReal.coe_one, zero_lt_one]),\n          hU.mp (Eventually.of_forall ?_)âŸ©\n  intro x x_notin_U\n  rw [f_vanishes_outside x\n        (compl_subset_compl.mpr (show interior U âŠ† U from interior_subset) x_notin_U)]\n  simp only [ENNReal.coe_zero, mem_Ioi, lt_self_iff_false, not_false_eq_true]\n\n"}
{"name":"MeasureTheory.tendsto_diracProba_iff_tendsto","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : OpensMeasurableSpace X\ninstâœ : CompletelyRegularSpace X\nx : X\nL : Filter X\nâŠ¢ Iff (Filter.Tendsto MeasureTheory.diracProba L (nhds (MeasureTheory.diracProba x))) (Filter.Tendsto id L (nhds x))","decl":"lemma tendsto_diracProba_iff_tendsto [CompletelyRegularSpace X] {x : X} (L : Filter X) :\n    Tendsto diracProba L (ð“ (diracProba x)) â†” Tendsto id L (ð“ x) := by\n  constructor\n  Â· contrapose\n    exact not_tendsto_diracProba_of_not_tendsto L\n  Â· intro h\n    have aux := (@continuous_diracProba X _ _ _).continuousAt (x := x)\n    simp only [ContinuousAt] at aux\n    exact aux.comp h\n\n"}
{"name":"MeasureTheory.diracProba_diracProbaInverse","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_2\ninstâœ : MeasurableSpace X\nÎ¼ : â†‘(Set.range MeasureTheory.diracProba)\nâŠ¢ Eq (MeasureTheory.diracProba (MeasureTheory.diracProbaInverse Î¼)) â†‘Î¼","decl":"@[simp] lemma diracProba_diracProbaInverse {X : Type*} [MeasurableSpace X]\n    (Î¼ : range (diracProba (X := X))) :\n    diracProba (diracProbaInverse Î¼) = Î¼ := (mem_range.mp Î¼.prop).choose_spec\n\n"}
{"name":"MeasureTheory.diracProbaInverse_eq","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : OpensMeasurableSpace X\ninstâœ : T0Space X\nx : X\nÎ¼ : â†‘(Set.range MeasureTheory.diracProba)\nh : Eq (â†‘Î¼) (MeasureTheory.diracProba x)\nâŠ¢ Eq (MeasureTheory.diracProbaInverse Î¼) x","decl":"lemma diracProbaInverse_eq [T0Space X] {x : X} {Î¼ : range (diracProba (X := X))}\n    (h : Î¼ = diracProba x) :\n    diracProbaInverse Î¼ = x := by\n  apply injective_diracProba_of_T0 (X := X)\n  simp only [â† h]\n  exact (mem_range.mp Î¼.prop).choose_spec\n\n"}
{"name":"MeasureTheory.diracProba_comp_diracProbaEquiv_symm_eq_val","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : OpensMeasurableSpace X\ninstâœ : T0Space X\nâŠ¢ Eq (Function.comp MeasureTheory.diracProba â‡‘MeasureTheory.diracProbaEquiv.symm) fun Î¼ => â†‘Î¼","decl":"/-- The composition of `diracProbaEquiv.symm` and `diracProba` is the subtype inclusion. -/\nlemma diracProba_comp_diracProbaEquiv_symm_eq_val [T0Space X] :\n    diracProba âˆ˜ (diracProbaEquiv (X := X)).symm = fun Î¼ â†¦ Î¼.val := by\n  funext Î¼; simp [diracProbaEquiv]\n\n"}
{"name":"MeasureTheory.tendsto_diracProbaEquivSymm_iff_tendsto","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninstâœâ´ : MeasurableSpace X\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : OpensMeasurableSpace X\ninstâœÂ¹ : T0Space X\ninstâœ : CompletelyRegularSpace X\nÎ¼ : â†‘(Set.range MeasureTheory.diracProba)\nF : Filter â†‘(Set.range MeasureTheory.diracProba)\nâŠ¢ Iff (Filter.Tendsto (â‡‘MeasureTheory.diracProbaEquiv.symm) F (nhds (MeasureTheory.diracProbaEquiv.symm Î¼))) (Filter.Tendsto id F (nhds Î¼))","decl":"lemma tendsto_diracProbaEquivSymm_iff_tendsto [T0Space X] [CompletelyRegularSpace X]\n    {Î¼ : range (diracProba (X := X))} (F : Filter (range (diracProba (X := X)))) :\n    Tendsto diracProbaEquiv.symm F (ð“ (diracProbaEquiv.symm Î¼)) â†” Tendsto id F (ð“ Î¼) := by\n  have key :=\n    tendsto_diracProba_iff_tendsto (F.map diracProbaEquiv.symm) (x := diracProbaEquiv.symm Î¼)\n  rw [â† (diracProbaEquiv (X := X)).symm_comp_self, â† tendsto_map'_iff] at key\n  simp only [tendsto_map'_iff, map_map, Equiv.self_comp_symm, map_id] at key\n  simp only [â† key, diracProba_comp_diracProbaEquiv_symm_eq_val]\n  convert tendsto_subtype_rng.symm\n  exact apply_rangeSplitting (fun x â†¦ diracProba x) Î¼\n\n"}
{"name":"MeasureTheory.continuous_diracProbaEquiv","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : OpensMeasurableSpace X\ninstâœ : T0Space X\nâŠ¢ Continuous â‡‘MeasureTheory.diracProbaEquiv","decl":"/-- In a T0 topological space, `diracProbaEquiv` is continuous. -/\nlemma continuous_diracProbaEquiv [T0Space X] :\n    Continuous (diracProbaEquiv (X := X)) :=\n  Continuous.subtype_mk continuous_diracProba mem_range_self\n\n"}
{"name":"MeasureTheory.continuous_diracProbaEquivSymm","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninstâœâ´ : MeasurableSpace X\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : OpensMeasurableSpace X\ninstâœÂ¹ : T0Space X\ninstâœ : CompletelyRegularSpace X\nâŠ¢ Continuous â‡‘MeasureTheory.diracProbaEquiv.symm","decl":"/-- In a completely regular T0 topological space, the inverse of `diracProbaEquiv` is continuous. -/\nlemma continuous_diracProbaEquivSymm [T0Space X] [CompletelyRegularSpace X] :\n    Continuous (diracProbaEquiv (X := X)).symm := by\n  apply continuous_iff_continuousAt.mpr\n  intro Î¼\n  apply continuousAt_of_tendsto_nhds (y := diracProbaInverse Î¼)\n  exact (tendsto_diracProbaEquivSymm_iff_tendsto _).mpr fun _ mem_nhd â†¦ mem_nhd\n\n"}
{"name":"MeasureTheory.isEmbedding_diracProba","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninstâœâ´ : MeasurableSpace X\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : OpensMeasurableSpace X\ninstâœÂ¹ : T0Space X\ninstâœ : CompletelyRegularSpace X\nâŠ¢ Topology.IsEmbedding fun x => MeasureTheory.diracProba x","decl":"/-- If `X` is a completely regular T0 space with its Borel sigma algebra, then the mapping\nthat takes a point `x : X` to the delta-measure `diracProba x` is an embedding\n`X â†’ ProbabilityMeasure X`. -/\ntheorem isEmbedding_diracProba [T0Space X] [CompletelyRegularSpace X] :\n    IsEmbedding (fun (x : X) â†¦ diracProba x) :=\n  IsEmbedding.subtypeVal.comp diracProbaHomeomorph.isEmbedding\n\n"}
{"name":"MeasureTheory.embedding_diracProba","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninstâœâ´ : MeasurableSpace X\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : OpensMeasurableSpace X\ninstâœÂ¹ : T0Space X\ninstâœ : CompletelyRegularSpace X\nâŠ¢ Topology.IsEmbedding fun x => MeasureTheory.diracProba x","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_diracProba := isEmbedding_diracProba\n\n"}
