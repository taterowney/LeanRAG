{"name":"CompletelyRegularSpace.exists_BCNN","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompletelyRegularSpace X\nK : Set X\nK_closed : IsClosed K\nx : X\nx_notin_K : Not (Membership.mem K x)\n‚ä¢ Exists fun f => And (Eq (f x) 1) (‚àÄ (y : X), Membership.mem K y ‚Üí Eq (f y) 0)","decl":"lemma CompletelyRegularSpace.exists_BCNN {X : Type*} [TopologicalSpace X] [CompletelyRegularSpace X]\n    {K : Set X} (K_closed : IsClosed K) {x : X} (x_notin_K : x ‚àâ K) :\n    ‚àÉ (f : X ‚Üí·µá ‚Ñù‚â•0), f x = 1 ‚àß (‚àÄ y ‚àà K, f y = 0) := by\n  obtain ‚ü®g, g_cont, gx_zero, g_one_on_K‚ü© :=\n    CompletelyRegularSpace.completely_regular x K K_closed x_notin_K\n  have g_bdd : ‚àÄ x y, dist (Real.toNNReal (g x)) (Real.toNNReal (g y)) ‚â§ 1 := by\n    refine fun x y ‚Ü¶ ((Real.lipschitzWith_toNNReal).dist_le_mul (g x) (g y)).trans ?_\n    simpa using Real.dist_le_of_mem_Icc_01 (g x).prop (g y).prop\n  set g' := BoundedContinuousFunction.mkOfBound\n      ‚ü®fun x ‚Ü¶ Real.toNNReal (g x), continuous_real_toNNReal.comp g_cont.subtype_val‚ü© 1 g_bdd\n  set f := 1 - g'\n  refine ‚ü®f, by simp [f, g', gx_zero], fun y y_in_K ‚Ü¶ by simp [f, g', g_one_on_K y_in_K, tsub_self]‚ü©\n\n"}
{"name":"MeasureTheory.injective_diracProba","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_2\ninst‚úù¬π : MeasurableSpace X\ninst‚úù : MeasurableSpace.SeparatesPoints X\n‚ä¢ Function.Injective fun x => MeasureTheory.diracProba x","decl":"/-- The assignment `x ‚Ü¶ diracProba x` is injective if all singletons are measurable. -/\nlemma injective_diracProba {X : Type*} [MeasurableSpace X] [MeasurableSpace.SeparatesPoints X] :\n    Function.Injective (fun (x : X) ‚Ü¶ diracProba x) := by\n  intro x y x_eq_y\n  rw [‚Üê dirac_eq_dirac_iff]\n  rwa [Subtype.ext_iff] at x_eq_y\n\n"}
{"name":"MeasureTheory.diracProba_toMeasure_apply'","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninst‚úù : MeasurableSpace X\nx : X\nA : Set X\nA_mble : MeasurableSet A\n‚ä¢ Eq (‚Üë(MeasureTheory.diracProba x) A) (A.indicator 1 x)","decl":"@[simp] lemma diracProba_toMeasure_apply' (x : X) {A : Set X} (A_mble : MeasurableSet A) :\n    (diracProba x).toMeasure A = A.indicator 1 x := Measure.dirac_apply' x A_mble\n\n"}
{"name":"MeasureTheory.diracProba_toMeasure_apply_of_mem","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninst‚úù : MeasurableSpace X\nx : X\nA : Set X\nx_in_A : Membership.mem A x\n‚ä¢ Eq (‚Üë(MeasureTheory.diracProba x) A) 1","decl":"@[simp] lemma diracProba_toMeasure_apply_of_mem {x : X} {A : Set X} (x_in_A : x ‚àà A) :\n    (diracProba x).toMeasure A = 1 := Measure.dirac_apply_of_mem x_in_A\n\n"}
{"name":"MeasureTheory.diracProba_toMeasure_apply","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninst‚úù¬π : MeasurableSpace X\ninst‚úù : MeasurableSingletonClass X\nx : X\nA : Set X\n‚ä¢ Eq (‚Üë(MeasureTheory.diracProba x) A) (A.indicator 1 x)","decl":"@[simp] lemma diracProba_toMeasure_apply [MeasurableSingletonClass X] (x : X) (A : Set X) :\n    (diracProba x).toMeasure A = A.indicator 1 x := Measure.dirac_apply _ _\n\n"}
{"name":"MeasureTheory.continuous_diracProba","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninst‚úù¬≤ : MeasurableSpace X\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : OpensMeasurableSpace X\n‚ä¢ Continuous fun x => MeasureTheory.diracProba x","decl":"/-- The assignment `x ‚Ü¶ diracProba x` is continuous `X ‚Üí ProbabilityMeasure X`. -/\nlemma continuous_diracProba : Continuous (fun (x : X) ‚Ü¶ diracProba x) := by\n  rw [continuous_iff_continuousAt]\n  apply fun x ‚Ü¶ ProbabilityMeasure.tendsto_iff_forall_lintegral_tendsto.mpr fun f ‚Ü¶ ?_\n  have f_mble : Measurable (fun X ‚Ü¶ (f X : ‚Ñù‚â•0‚àû)) :=\n    measurable_coe_nnreal_ennreal_iff.mpr f.continuous.measurable\n  simp only [diracProba, ProbabilityMeasure.coe_mk, lintegral_dirac' _ f_mble]\n  exact (ENNReal.continuous_coe.comp f.continuous).continuousAt\n\n"}
{"name":"MeasureTheory.injective_diracProba_of_T0","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninst‚úù¬≥ : MeasurableSpace X\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : OpensMeasurableSpace X\ninst‚úù : T0Space X\n‚ä¢ Function.Injective fun x => MeasureTheory.diracProba x","decl":"/-- In a T0 topological space equipped with a sigma algebra which contains all open sets,\nthe assignment `x ‚Ü¶ diracProba x` is injective. -/\nlemma injective_diracProba_of_T0 [T0Space X] :\n    Function.Injective (fun (x : X) ‚Ü¶ diracProba x) := by\n  intro x y Œ¥x_eq_Œ¥y\n  by_contra x_ne_y\n  exact dirac_ne_dirac x_ne_y <| congr_arg Subtype.val Œ¥x_eq_Œ¥y\n\n"}
{"name":"MeasureTheory.not_tendsto_diracProba_of_not_tendsto","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninst‚úù¬≥ : MeasurableSpace X\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : OpensMeasurableSpace X\ninst‚úù : CompletelyRegularSpace X\nx : X\nL : Filter X\nh : Not (Filter.Tendsto id L (nhds x))\n‚ä¢ Not (Filter.Tendsto MeasureTheory.diracProba L (nhds (MeasureTheory.diracProba x)))","decl":"lemma not_tendsto_diracProba_of_not_tendsto [CompletelyRegularSpace X] {x : X} (L : Filter X)\n    (h : ¬¨ Tendsto id L (ùìù x)) :\n    ¬¨ Tendsto diracProba L (ùìù (diracProba x)) := by\n  obtain ‚ü®U, U_nhd, hU‚ü© : ‚àÉ U, U ‚àà ùìù x ‚àß ‚àÉ·∂† x in L, x ‚àâ U := by\n    by_contra! con\n    apply h\n    intro U U_nhd\n    simpa only [not_frequently, not_not] using con U U_nhd\n  have Uint_nhd : interior U ‚àà ùìù x := by simpa only [interior_mem_nhds] using U_nhd\n  obtain ‚ü®f, fx_eq_one, f_vanishes_outside‚ü© :=\n    CompletelyRegularSpace.exists_BCNN isOpen_interior.isClosed_compl\n      (by simpa only [mem_compl_iff, not_not] using mem_of_mem_nhds Uint_nhd)\n  rw [ProbabilityMeasure.tendsto_iff_forall_lintegral_tendsto, not_forall]\n  use f\n  simp only [diracProba, ProbabilityMeasure.coe_mk, fx_eq_one,\n             lintegral_dirac' _ (measurable_coe_nnreal_ennreal_iff.mpr f.continuous.measurable)]\n  apply not_tendsto_iff_exists_frequently_nmem.mpr\n  refine ‚ü®Ioi 0, Ioi_mem_nhds (by simp only [ENNReal.coe_one, zero_lt_one]),\n          hU.mp (Eventually.of_forall ?_)‚ü©\n  intro x x_notin_U\n  rw [f_vanishes_outside x\n        (compl_subset_compl.mpr (show interior U ‚äÜ U from interior_subset) x_notin_U)]\n  simp only [ENNReal.coe_zero, mem_Ioi, lt_self_iff_false, not_false_eq_true]\n\n"}
{"name":"MeasureTheory.tendsto_diracProba_iff_tendsto","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninst‚úù¬≥ : MeasurableSpace X\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : OpensMeasurableSpace X\ninst‚úù : CompletelyRegularSpace X\nx : X\nL : Filter X\n‚ä¢ Iff (Filter.Tendsto MeasureTheory.diracProba L (nhds (MeasureTheory.diracProba x))) (Filter.Tendsto id L (nhds x))","decl":"lemma tendsto_diracProba_iff_tendsto [CompletelyRegularSpace X] {x : X} (L : Filter X) :\n    Tendsto diracProba L (ùìù (diracProba x)) ‚Üî Tendsto id L (ùìù x) := by\n  constructor\n  ¬∑ contrapose\n    exact not_tendsto_diracProba_of_not_tendsto L\n  ¬∑ intro h\n    have aux := (@continuous_diracProba X _ _ _).continuousAt (x := x)\n    simp only [ContinuousAt] at aux\n    exact aux.comp h\n\n"}
{"name":"MeasureTheory.diracProba_diracProbaInverse","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_2\ninst‚úù : MeasurableSpace X\nŒº : ‚Üë(Set.range MeasureTheory.diracProba)\n‚ä¢ Eq (MeasureTheory.diracProba (MeasureTheory.diracProbaInverse Œº)) ‚ÜëŒº","decl":"@[simp] lemma diracProba_diracProbaInverse {X : Type*} [MeasurableSpace X]\n    (Œº : range (diracProba (X := X))) :\n    diracProba (diracProbaInverse Œº) = Œº := (mem_range.mp Œº.prop).choose_spec\n\n"}
{"name":"MeasureTheory.diracProbaInverse_eq","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninst‚úù¬≥ : MeasurableSpace X\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : OpensMeasurableSpace X\ninst‚úù : T0Space X\nx : X\nŒº : ‚Üë(Set.range MeasureTheory.diracProba)\nh : Eq (‚ÜëŒº) (MeasureTheory.diracProba x)\n‚ä¢ Eq (MeasureTheory.diracProbaInverse Œº) x","decl":"lemma diracProbaInverse_eq [T0Space X] {x : X} {Œº : range (diracProba (X := X))}\n    (h : Œº = diracProba x) :\n    diracProbaInverse Œº = x := by\n  apply injective_diracProba_of_T0 (X := X)\n  simp only [‚Üê h]\n  exact (mem_range.mp Œº.prop).choose_spec\n\n"}
{"name":"MeasureTheory.diracProba_comp_diracProbaEquiv_symm_eq_val","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninst‚úù¬≥ : MeasurableSpace X\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : OpensMeasurableSpace X\ninst‚úù : T0Space X\n‚ä¢ Eq (Function.comp MeasureTheory.diracProba ‚áëMeasureTheory.diracProbaEquiv.symm) fun Œº => ‚ÜëŒº","decl":"/-- The composition of `diracProbaEquiv.symm` and `diracProba` is the subtype inclusion. -/\nlemma diracProba_comp_diracProbaEquiv_symm_eq_val [T0Space X] :\n    diracProba ‚àò (diracProbaEquiv (X := X)).symm = fun Œº ‚Ü¶ Œº.val := by\n  funext Œº; simp [diracProbaEquiv]\n\n"}
{"name":"MeasureTheory.tendsto_diracProbaEquivSymm_iff_tendsto","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninst‚úù‚Å¥ : MeasurableSpace X\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : OpensMeasurableSpace X\ninst‚úù¬π : T0Space X\ninst‚úù : CompletelyRegularSpace X\nŒº : ‚Üë(Set.range MeasureTheory.diracProba)\nF : Filter ‚Üë(Set.range MeasureTheory.diracProba)\n‚ä¢ Iff (Filter.Tendsto (‚áëMeasureTheory.diracProbaEquiv.symm) F (nhds (MeasureTheory.diracProbaEquiv.symm Œº))) (Filter.Tendsto id F (nhds Œº))","decl":"lemma tendsto_diracProbaEquivSymm_iff_tendsto [T0Space X] [CompletelyRegularSpace X]\n    {Œº : range (diracProba (X := X))} (F : Filter (range (diracProba (X := X)))) :\n    Tendsto diracProbaEquiv.symm F (ùìù (diracProbaEquiv.symm Œº)) ‚Üî Tendsto id F (ùìù Œº) := by\n  have key :=\n    tendsto_diracProba_iff_tendsto (F.map diracProbaEquiv.symm) (x := diracProbaEquiv.symm Œº)\n  rw [‚Üê (diracProbaEquiv (X := X)).symm_comp_self, ‚Üê tendsto_map'_iff] at key\n  simp only [tendsto_map'_iff, map_map, Equiv.self_comp_symm, map_id] at key\n  simp only [‚Üê key, diracProba_comp_diracProbaEquiv_symm_eq_val]\n  convert tendsto_subtype_rng.symm\n  exact apply_rangeSplitting (fun x ‚Ü¶ diracProba x) Œº\n\n"}
{"name":"MeasureTheory.continuous_diracProbaEquiv","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninst‚úù¬≥ : MeasurableSpace X\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : OpensMeasurableSpace X\ninst‚úù : T0Space X\n‚ä¢ Continuous ‚áëMeasureTheory.diracProbaEquiv","decl":"/-- In a T0 topological space, `diracProbaEquiv` is continuous. -/\nlemma continuous_diracProbaEquiv [T0Space X] :\n    Continuous (diracProbaEquiv (X := X)) :=\n  Continuous.subtype_mk continuous_diracProba mem_range_self\n\n"}
{"name":"MeasureTheory.continuous_diracProbaEquivSymm","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninst‚úù‚Å¥ : MeasurableSpace X\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : OpensMeasurableSpace X\ninst‚úù¬π : T0Space X\ninst‚úù : CompletelyRegularSpace X\n‚ä¢ Continuous ‚áëMeasureTheory.diracProbaEquiv.symm","decl":"/-- In a completely regular T0 topological space, the inverse of `diracProbaEquiv` is continuous. -/\nlemma continuous_diracProbaEquivSymm [T0Space X] [CompletelyRegularSpace X] :\n    Continuous (diracProbaEquiv (X := X)).symm := by\n  apply continuous_iff_continuousAt.mpr\n  intro Œº\n  apply continuousAt_of_tendsto_nhds (y := diracProbaInverse Œº)\n  exact (tendsto_diracProbaEquivSymm_iff_tendsto _).mpr fun _ mem_nhd ‚Ü¶ mem_nhd\n\n"}
{"name":"MeasureTheory.isEmbedding_diracProba","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninst‚úù‚Å¥ : MeasurableSpace X\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : OpensMeasurableSpace X\ninst‚úù¬π : T0Space X\ninst‚úù : CompletelyRegularSpace X\n‚ä¢ Topology.IsEmbedding fun x => MeasureTheory.diracProba x","decl":"/-- If `X` is a completely regular T0 space with its Borel sigma algebra, then the mapping\nthat takes a point `x : X` to the delta-measure `diracProba x` is an embedding\n`X ‚Üí ProbabilityMeasure X`. -/\ntheorem isEmbedding_diracProba [T0Space X] [CompletelyRegularSpace X] :\n    IsEmbedding (fun (x : X) ‚Ü¶ diracProba x) :=\n  IsEmbedding.subtypeVal.comp diracProbaHomeomorph.isEmbedding\n\n"}
{"name":"MeasureTheory.embedding_diracProba","module":"Mathlib.MeasureTheory.Measure.DiracProba","initialProofState":"X : Type u_1\ninst‚úù‚Å¥ : MeasurableSpace X\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : OpensMeasurableSpace X\ninst‚úù¬π : T0Space X\ninst‚úù : CompletelyRegularSpace X\n‚ä¢ Topology.IsEmbedding fun x => MeasureTheory.diracProba x","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_diracProba := isEmbedding_diracProba\n\n"}
