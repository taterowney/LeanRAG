{"name":"Multiset.fold_eq_foldr","module":"Mathlib.Data.Multiset.Fold","initialProofState":"α : Type u_1\nop : α → α → α\nhc : Std.Commutative op\nha : Std.Associative op\nb : α\ns : Multiset α\n⊢ Eq (Multiset.fold op b s) (Multiset.foldr op b s)","decl":"theorem fold_eq_foldr (b : α) (s : Multiset α) :\n    fold op b s = foldr op b s :=\n  rfl\n\n"}
{"name":"Multiset.coe_fold_r","module":"Mathlib.Data.Multiset.Fold","initialProofState":"α : Type u_1\nop : α → α → α\nhc : Std.Commutative op\nha : Std.Associative op\nb : α\nl : List α\n⊢ Eq (Multiset.fold op b ↑l) (List.foldr op b l)","decl":"@[simp]\ntheorem coe_fold_r (b : α) (l : List α) : fold op b l = l.foldr op b :=\n  rfl\n\n"}
{"name":"Multiset.coe_fold_l","module":"Mathlib.Data.Multiset.Fold","initialProofState":"α : Type u_1\nop : α → α → α\nhc : Std.Commutative op\nha : Std.Associative op\nb : α\nl : List α\n⊢ Eq (Multiset.fold op b ↑l) (List.foldl op b l)","decl":"theorem coe_fold_l (b : α) (l : List α) : fold op b l = l.foldl op b :=\n  (coe_foldr_swap op b l).trans <| by simp [hc.comm]\n\n"}
{"name":"Multiset.fold_eq_foldl","module":"Mathlib.Data.Multiset.Fold","initialProofState":"α : Type u_1\nop : α → α → α\nhc : Std.Commutative op\nha : Std.Associative op\nb : α\ns : Multiset α\n⊢ Eq (Multiset.fold op b s) (Multiset.foldl op b s)","decl":"theorem fold_eq_foldl (b : α) (s : Multiset α) :\n    fold op b s = foldl op b s :=\n  Quot.inductionOn s fun _ => coe_fold_l _ _ _\n\n"}
{"name":"Multiset.fold_zero","module":"Mathlib.Data.Multiset.Fold","initialProofState":"α : Type u_1\nop : α → α → α\nhc : Std.Commutative op\nha : Std.Associative op\nb : α\n⊢ Eq (Multiset.fold op b 0) b","decl":"@[simp]\ntheorem fold_zero (b : α) : (0 : Multiset α).fold op b = b :=\n  rfl\n\n"}
{"name":"Multiset.fold_cons_left","module":"Mathlib.Data.Multiset.Fold","initialProofState":"α : Type u_1\nop : α → α → α\nhc : Std.Commutative op\nha : Std.Associative op\nb a : α\ns : Multiset α\n⊢ Eq (Multiset.fold op b (Multiset.cons a s)) (op a (Multiset.fold op b s))","decl":"@[simp]\ntheorem fold_cons_left : ∀ (b a : α) (s : Multiset α), (a ::ₘ s).fold op b = a * s.fold op b :=\n  foldr_cons _\n\n"}
{"name":"Multiset.fold_cons_right","module":"Mathlib.Data.Multiset.Fold","initialProofState":"α : Type u_1\nop : α → α → α\nhc : Std.Commutative op\nha : Std.Associative op\nb a : α\ns : Multiset α\n⊢ Eq (Multiset.fold op b (Multiset.cons a s)) (op (Multiset.fold op b s) a)","decl":"theorem fold_cons_right (b a : α) (s : Multiset α) : (a ::ₘ s).fold op b = s.fold op b * a := by\n  simp [hc.comm]\n\n"}
{"name":"Multiset.fold_cons'_right","module":"Mathlib.Data.Multiset.Fold","initialProofState":"α : Type u_1\nop : α → α → α\nhc : Std.Commutative op\nha : Std.Associative op\nb a : α\ns : Multiset α\n⊢ Eq (Multiset.fold op b (Multiset.cons a s)) (Multiset.fold op (op b a) s)","decl":"theorem fold_cons'_right (b a : α) (s : Multiset α) : (a ::ₘ s).fold op b = s.fold op (b * a) := by\n  rw [fold_eq_foldl, foldl_cons, ← fold_eq_foldl]\n\n"}
{"name":"Multiset.fold_cons'_left","module":"Mathlib.Data.Multiset.Fold","initialProofState":"α : Type u_1\nop : α → α → α\nhc : Std.Commutative op\nha : Std.Associative op\nb a : α\ns : Multiset α\n⊢ Eq (Multiset.fold op b (Multiset.cons a s)) (Multiset.fold op (op a b) s)","decl":"theorem fold_cons'_left (b a : α) (s : Multiset α) : (a ::ₘ s).fold op b = s.fold op (a * b) := by\n  rw [fold_cons'_right, hc.comm]\n\n"}
{"name":"Multiset.fold_add","module":"Mathlib.Data.Multiset.Fold","initialProofState":"α : Type u_1\nop : α → α → α\nhc : Std.Commutative op\nha : Std.Associative op\nb₁ b₂ : α\ns₁ s₂ : Multiset α\n⊢ Eq (Multiset.fold op (op b₁ b₂) (HAdd.hAdd s₁ s₂)) (op (Multiset.fold op b₁ s₁) (Multiset.fold op b₂ s₂))","decl":"theorem fold_add (b₁ b₂ : α) (s₁ s₂ : Multiset α) :\n    (s₁ + s₂).fold op (b₁ * b₂) = s₁.fold op b₁ * s₂.fold op b₂ :=\n  Multiset.induction_on s₂ (by rw [add_zero, fold_zero, ← fold_cons'_right, ← fold_cons_right op])\n    (fun a b h => by rw [fold_cons_left, add_cons, fold_cons_left, h, ← ha.assoc, hc.comm a,\n      ha.assoc])\n\n"}
{"name":"Multiset.fold_bind","module":"Mathlib.Data.Multiset.Fold","initialProofState":"α : Type u_1\nop : α → α → α\nhc : Std.Commutative op\nha : Std.Associative op\nι : Type u_3\ns : Multiset ι\nt : ι → Multiset α\nb : ι → α\nb₀ : α\n⊢ Eq (Multiset.fold op (Multiset.fold op b₀ (Multiset.map b s)) (s.bind t)) (Multiset.fold op b₀ (Multiset.map (fun i => Multiset.fold op (b i) (t i)) s))","decl":"theorem fold_bind {ι : Type*} (s : Multiset ι) (t : ι → Multiset α) (b : ι → α) (b₀ : α) :\n    (s.bind t).fold op ((s.map b).fold op b₀) =\n    (s.map fun i => (t i).fold op (b i)).fold op b₀ := by\n  induction' s using Multiset.induction_on with a ha ih\n  · rw [zero_bind, map_zero, map_zero, fold_zero]\n  · rw [cons_bind, map_cons, map_cons, fold_cons_left, fold_cons_left, fold_add, ih]\n\n"}
{"name":"Multiset.fold_singleton","module":"Mathlib.Data.Multiset.Fold","initialProofState":"α : Type u_1\nop : α → α → α\nhc : Std.Commutative op\nha : Std.Associative op\nb a : α\n⊢ Eq (Multiset.fold op b (Singleton.singleton a)) (op a b)","decl":"theorem fold_singleton (b a : α) : ({a} : Multiset α).fold op b = a * b :=\n  foldr_singleton _ _ _\n\n"}
{"name":"Multiset.fold_distrib","module":"Mathlib.Data.Multiset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nop : α → α → α\nhc : Std.Commutative op\nha : Std.Associative op\nf g : β → α\nu₁ u₂ : α\ns : Multiset β\n⊢ Eq (Multiset.fold op (op u₁ u₂) (Multiset.map (fun x => op (f x) (g x)) s)) (op (Multiset.fold op u₁ (Multiset.map f s)) (Multiset.fold op u₂ (Multiset.map g s)))","decl":"theorem fold_distrib {f g : β → α} (u₁ u₂ : α) (s : Multiset β) :\n    (s.map fun x => f x * g x).fold op (u₁ * u₂) = (s.map f).fold op u₁ * (s.map g).fold op u₂ :=\n  Multiset.induction_on s (by simp) (fun a b h => by\n    rw [map_cons, fold_cons_left, h, map_cons, fold_cons_left, map_cons,\n      fold_cons_right, ha.assoc, ← ha.assoc (g a), hc.comm (g a),\n      ha.assoc, hc.comm (g a), ha.assoc])\n\n"}
{"name":"Multiset.fold_hom","module":"Mathlib.Data.Multiset.Fold","initialProofState":"α : Type u_1\nβ : Type u_2\nop : α → α → α\nhc : Std.Commutative op\nha : Std.Associative op\nop' : β → β → β\ninst✝¹ : Std.Commutative op'\ninst✝ : Std.Associative op'\nm : α → β\nhm : ∀ (x y : α), Eq (m (op x y)) (op' (m x) (m y))\nb : α\ns : Multiset α\n⊢ Eq (Multiset.fold op' (m b) (Multiset.map m s)) (m (Multiset.fold op b s))","decl":"theorem fold_hom {op' : β → β → β} [Std.Commutative op'] [Std.Associative op'] {m : α → β}\n    (hm : ∀ x y, m (op x y) = op' (m x) (m y)) (b : α) (s : Multiset α) :\n    (s.map m).fold op' (m b) = m (s.fold op b) :=\n  Multiset.induction_on s (by simp) (by simp +contextual [hm])\n\n"}
{"name":"Multiset.fold_union_inter","module":"Mathlib.Data.Multiset.Fold","initialProofState":"α : Type u_1\nop : α → α → α\nhc : Std.Commutative op\nha : Std.Associative op\ninst✝ : DecidableEq α\ns₁ s₂ : Multiset α\nb₁ b₂ : α\n⊢ Eq (op (Multiset.fold op b₁ (Union.union s₁ s₂)) (Multiset.fold op b₂ (Inter.inter s₁ s₂))) (op (Multiset.fold op b₁ s₁) (Multiset.fold op b₂ s₂))","decl":"theorem fold_union_inter [DecidableEq α] (s₁ s₂ : Multiset α) (b₁ b₂ : α) :\n    ((s₁ ∪ s₂).fold op b₁ * (s₁ ∩ s₂).fold op b₂) = s₁.fold op b₁ * s₂.fold op b₂ := by\n  rw [← fold_add op, union_add_inter, fold_add op]\n\n"}
{"name":"Multiset.fold_dedup_idem","module":"Mathlib.Data.Multiset.Fold","initialProofState":"α : Type u_1\nop : α → α → α\nhc : Std.Commutative op\nha : Std.Associative op\ninst✝ : DecidableEq α\nhi : Std.IdempotentOp op\ns : Multiset α\nb : α\n⊢ Eq (Multiset.fold op b s.dedup) (Multiset.fold op b s)","decl":"@[simp]\ntheorem fold_dedup_idem [DecidableEq α] [hi : Std.IdempotentOp op] (s : Multiset α) (b : α) :\n    (dedup s).fold op b = s.fold op b :=\n  Multiset.induction_on s (by simp) fun a s IH => by\n    by_cases h : a ∈ s <;> simp [IH, h]\n    show fold op b s = op a (fold op b s)\n    rw [← cons_erase h, fold_cons_left, ← ha.assoc, hi.idempotent]\n\n"}
{"name":"Multiset.le_smul_dedup","module":"Mathlib.Data.Multiset.Fold","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\ns : Multiset α\n⊢ Exists fun n => LE.le s (HSMul.hSMul n s.dedup)","decl":"theorem le_smul_dedup [DecidableEq α] (s : Multiset α) : ∃ n : ℕ, s ≤ n • dedup s :=\n  ⟨(s.map fun a => count a s).fold max 0,\n    le_iff_count.2 fun a => by\n      rw [count_nsmul]; by_cases h : a ∈ s\n      · refine le_trans ?_ (Nat.mul_le_mul_left _ <| count_pos.2 <| mem_dedup.2 h)\n        have : count a s ≤ fold max 0 (map (fun a => count a s) (a ::ₘ erase s a)) := by\n          simp [le_max_left]\n        rw [cons_erase h] at this\n        simpa [mul_succ] using this\n      · simp [count_eq_zero.2 h, Nat.zero_le]⟩\n\n"}
