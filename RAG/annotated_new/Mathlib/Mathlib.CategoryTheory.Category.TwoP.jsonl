{"name":"TwoP.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X : Type u\ntoTwoPointing : TwoPointing X\n⊢ Eq (SizeOf.sizeOf { X := X, toTwoPointing := toTwoPointing }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf X)) (SizeOf.sizeOf toTwoPointing))","decl":"/-- The category of two-pointed types. -/\nstructure TwoP : Type (u + 1) where\n  /-- The underlying type of a two-pointed type. -/\n  protected X : Type u\n  /-- The two points of a bipointed type, bundled together as a pair of distinct elements. -/\n  toTwoPointing : TwoPointing X\n\n"}
{"name":"TwoP.mk.inj","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X✝ : Type u\ntoTwoPointing✝ : TwoPointing X✝\nX : Type u\ntoTwoPointing : TwoPointing X\nx✝ : Eq { X := X✝, toTwoPointing := toTwoPointing✝ } { X := X, toTwoPointing := toTwoPointing }\n⊢ And (Eq X✝ X) (HEq toTwoPointing✝ toTwoPointing)","decl":"/-- The category of two-pointed types. -/\nstructure TwoP : Type (u + 1) where\n  /-- The underlying type of a two-pointed type. -/\n  protected X : Type u\n  /-- The two points of a bipointed type, bundled together as a pair of distinct elements. -/\n  toTwoPointing : TwoPointing X\n\n"}
{"name":"TwoP.mk.injEq","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X✝ : Type u\ntoTwoPointing✝ : TwoPointing X✝\nX : Type u\ntoTwoPointing : TwoPointing X\n⊢ Eq (Eq { X := X✝, toTwoPointing := toTwoPointing✝ } { X := X, toTwoPointing := toTwoPointing }) (And (Eq X✝ X) (HEq toTwoPointing✝ toTwoPointing))","decl":"/-- The category of two-pointed types. -/\nstructure TwoP : Type (u + 1) where\n  /-- The underlying type of a two-pointed type. -/\n  protected X : Type u\n  /-- The two points of a bipointed type, bundled together as a pair of distinct elements. -/\n  toTwoPointing : TwoPointing X\n\n"}
{"name":"TwoP.coe_of","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X : Type u_3\ntoTwoPointing : TwoPointing X\n⊢ Eq (TwoP.of toTwoPointing).X X","decl":"@[simp]\ntheorem coe_of {X : Type*} (toTwoPointing : TwoPointing X) : ↥(of toTwoPointing) = X :=\n  rfl\n\n"}
{"name":"TwoP.coe_toBipointed","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X : TwoP\n⊢ Eq X.toBipointed.X X.X","decl":"@[simp]\ntheorem coe_toBipointed (X : TwoP) : ↥X.toBipointed = ↥X :=\n  rfl\n\n"}
{"name":"TwoP.swap_obj_X","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X : TwoP\n⊢ Eq (TwoP.swap.obj X).X X.X","decl":"/-- Swaps the pointed elements of a two-pointed type. `TwoPointing.swap` as a functor. -/\n@[simps]\nnoncomputable def swap : TwoP ⥤ TwoP where\n  obj X := ⟨X, X.toTwoPointing.swap⟩\n  map f := ⟨f.toFun, f.map_snd, f.map_fst⟩\n\n"}
{"name":"TwoP.swap_obj_toTwoPointing","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X : TwoP\n⊢ Eq (TwoP.swap.obj X).toTwoPointing X.toTwoPointing.swap","decl":"/-- Swaps the pointed elements of a two-pointed type. `TwoPointing.swap` as a functor. -/\n@[simps]\nnoncomputable def swap : TwoP ⥤ TwoP where\n  obj X := ⟨X, X.toTwoPointing.swap⟩\n  map f := ⟨f.toFun, f.map_snd, f.map_fst⟩\n\n"}
{"name":"TwoP.swap_map_toFun","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X✝ Y✝ : TwoP\nf : Quiver.Hom X✝ Y✝\na✝ : X✝.toBipointed.X\n⊢ Eq ((TwoP.swap.map f).toFun a✝) (f.toFun a✝)","decl":"/-- Swaps the pointed elements of a two-pointed type. `TwoPointing.swap` as a functor. -/\n@[simps]\nnoncomputable def swap : TwoP ⥤ TwoP where\n  obj X := ⟨X, X.toTwoPointing.swap⟩\n  map f := ⟨f.toFun, f.map_snd, f.map_fst⟩\n\n"}
{"name":"TwoP.swapEquiv_unitIso_inv_app_toFun","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X : TwoP\na : ((CategoryTheory.Functor.id TwoP).obj X).toBipointed.X\n⊢ Eq ((TwoP.swapEquiv.unitIso.inv.app X).toFun a) a","decl":"/-- The equivalence between `TwoP` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\nnoncomputable def swapEquiv : TwoP ≌ TwoP where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"TwoP.swapEquiv_unitIso_hom_app_toFun","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X : TwoP\na : ((CategoryTheory.Functor.id TwoP).obj X).toBipointed.X\n⊢ Eq ((TwoP.swapEquiv.unitIso.hom.app X).toFun a) a","decl":"/-- The equivalence between `TwoP` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\nnoncomputable def swapEquiv : TwoP ≌ TwoP where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"TwoP.swapEquiv_inverse_obj_toTwoPointing_toProd","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X : TwoP\n⊢ Eq (TwoP.swapEquiv.inverse.obj X).toTwoPointing.toProd { fst := X.toTwoPointing.toProd.2, snd := X.toTwoPointing.toProd.1 }","decl":"/-- The equivalence between `TwoP` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\nnoncomputable def swapEquiv : TwoP ≌ TwoP where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"TwoP.swapEquiv_functor_map_toFun","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X✝ Y✝ : TwoP\nf : Quiver.Hom X✝ Y✝\na✝ : X✝.toBipointed.X\n⊢ Eq ((TwoP.swapEquiv.functor.map f).toFun a✝) (f.toFun a✝)","decl":"/-- The equivalence between `TwoP` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\nnoncomputable def swapEquiv : TwoP ≌ TwoP where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"TwoP.swapEquiv_functor_obj_X","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X : TwoP\n⊢ Eq (TwoP.swapEquiv.functor.obj X).X X.X","decl":"/-- The equivalence between `TwoP` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\nnoncomputable def swapEquiv : TwoP ≌ TwoP where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"TwoP.swapEquiv_counitIso_inv_app_toFun","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X : TwoP\na : ((TwoP.swap.comp TwoP.swap).obj X).toBipointed.X\n⊢ Eq ((TwoP.swapEquiv.counitIso.inv.app X).toFun a) a","decl":"/-- The equivalence between `TwoP` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\nnoncomputable def swapEquiv : TwoP ≌ TwoP where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"TwoP.swapEquiv_inverse_obj_X","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X : TwoP\n⊢ Eq (TwoP.swapEquiv.inverse.obj X).X X.X","decl":"/-- The equivalence between `TwoP` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\nnoncomputable def swapEquiv : TwoP ≌ TwoP where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"TwoP.swapEquiv_functor_obj_toTwoPointing_toProd","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X : TwoP\n⊢ Eq (TwoP.swapEquiv.functor.obj X).toTwoPointing.toProd { fst := X.toTwoPointing.toProd.2, snd := X.toTwoPointing.toProd.1 }","decl":"/-- The equivalence between `TwoP` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\nnoncomputable def swapEquiv : TwoP ≌ TwoP where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"TwoP.swapEquiv_inverse_map_toFun","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X✝ Y✝ : TwoP\nf : Quiver.Hom X✝ Y✝\na✝ : X✝.toBipointed.X\n⊢ Eq ((TwoP.swapEquiv.inverse.map f).toFun a✝) (f.toFun a✝)","decl":"/-- The equivalence between `TwoP` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\nnoncomputable def swapEquiv : TwoP ≌ TwoP where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"TwoP.swapEquiv_counitIso_hom_app_toFun","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X : TwoP\na : ((TwoP.swap.comp TwoP.swap).obj X).toBipointed.X\n⊢ Eq ((TwoP.swapEquiv.counitIso.hom.app X).toFun a) a","decl":"/-- The equivalence between `TwoP` and itself induced by `Prod.swap` both ways. -/\n@[simps!]\nnoncomputable def swapEquiv : TwoP ≌ TwoP where\n  functor := swap\n  inverse := swap\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"TwoP.swapEquiv_symm","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"⊢ Eq TwoP.swapEquiv.symm TwoP.swapEquiv","decl":"@[simp]\ntheorem swapEquiv_symm : swapEquiv.symm = swapEquiv :=\n  rfl\n\n"}
{"name":"TwoP_swap_comp_forget_to_Bipointed","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"⊢ Eq (TwoP.swap.comp (CategoryTheory.forget₂ TwoP Bipointed)) ((CategoryTheory.forget₂ TwoP Bipointed).comp Bipointed.swap)","decl":"@[simp]\ntheorem TwoP_swap_comp_forget_to_Bipointed :\n    TwoP.swap ⋙ forget₂ TwoP Bipointed = forget₂ TwoP Bipointed ⋙ Bipointed.swap :=\n  rfl\n\n"}
{"name":"pointedToTwoPFst_obj_X","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X : Pointed\n⊢ Eq (pointedToTwoPFst.obj X).X (Option X.X)","decl":"/-- The functor from `Pointed` to `TwoP` which adds a second point. -/\n@[simps]\nnoncomputable def pointedToTwoPFst : Pointed.{u} ⥤ TwoP where\n  obj X := ⟨Option X, ⟨X.point, none⟩, some_ne_none _⟩\n  map f := ⟨Option.map f.toFun, congr_arg _ f.map_point, rfl⟩\n  map_id _ := Bipointed.Hom.ext Option.map_id\n  map_comp f g := Bipointed.Hom.ext (Option.map_comp_map f.1 g.1).symm\n\n"}
{"name":"pointedToTwoPFst_map_toFun","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X✝ Y✝ : Pointed\nf : Quiver.Hom X✝ Y✝\na✝ : Option X✝.X\n⊢ Eq ((pointedToTwoPFst.map f).toFun a✝) (Option.map f.toFun a✝)","decl":"/-- The functor from `Pointed` to `TwoP` which adds a second point. -/\n@[simps]\nnoncomputable def pointedToTwoPFst : Pointed.{u} ⥤ TwoP where\n  obj X := ⟨Option X, ⟨X.point, none⟩, some_ne_none _⟩\n  map f := ⟨Option.map f.toFun, congr_arg _ f.map_point, rfl⟩\n  map_id _ := Bipointed.Hom.ext Option.map_id\n  map_comp f g := Bipointed.Hom.ext (Option.map_comp_map f.1 g.1).symm\n\n"}
{"name":"pointedToTwoPFst_obj_toTwoPointing_toProd","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X : Pointed\n⊢ Eq (pointedToTwoPFst.obj X).toTwoPointing.toProd { fst := Option.some X.point, snd := Option.none }","decl":"/-- The functor from `Pointed` to `TwoP` which adds a second point. -/\n@[simps]\nnoncomputable def pointedToTwoPFst : Pointed.{u} ⥤ TwoP where\n  obj X := ⟨Option X, ⟨X.point, none⟩, some_ne_none _⟩\n  map f := ⟨Option.map f.toFun, congr_arg _ f.map_point, rfl⟩\n  map_id _ := Bipointed.Hom.ext Option.map_id\n  map_comp f g := Bipointed.Hom.ext (Option.map_comp_map f.1 g.1).symm\n\n"}
{"name":"pointedToTwoPSnd_obj_toTwoPointing_toProd","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X : Pointed\n⊢ Eq (pointedToTwoPSnd.obj X).toTwoPointing.toProd { fst := Option.none, snd := Option.some X.point }","decl":"/-- The functor from `Pointed` to `TwoP` which adds a first point. -/\n@[simps]\nnoncomputable def pointedToTwoPSnd : Pointed.{u} ⥤ TwoP where\n  obj X := ⟨Option X, ⟨none, X.point⟩, (some_ne_none _).symm⟩\n  map f := ⟨Option.map f.toFun, rfl, congr_arg _ f.map_point⟩\n  map_id _ := Bipointed.Hom.ext Option.map_id\n  map_comp f g := Bipointed.Hom.ext (Option.map_comp_map f.1 g.1).symm\n\n"}
{"name":"pointedToTwoPSnd_obj_X","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X : Pointed\n⊢ Eq (pointedToTwoPSnd.obj X).X (Option X.X)","decl":"/-- The functor from `Pointed` to `TwoP` which adds a first point. -/\n@[simps]\nnoncomputable def pointedToTwoPSnd : Pointed.{u} ⥤ TwoP where\n  obj X := ⟨Option X, ⟨none, X.point⟩, (some_ne_none _).symm⟩\n  map f := ⟨Option.map f.toFun, rfl, congr_arg _ f.map_point⟩\n  map_id _ := Bipointed.Hom.ext Option.map_id\n  map_comp f g := Bipointed.Hom.ext (Option.map_comp_map f.1 g.1).symm\n\n"}
{"name":"pointedToTwoPSnd_map_toFun","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"X✝ Y✝ : Pointed\nf : Quiver.Hom X✝ Y✝\na✝ : Option X✝.X\n⊢ Eq ((pointedToTwoPSnd.map f).toFun a✝) (Option.map f.toFun a✝)","decl":"/-- The functor from `Pointed` to `TwoP` which adds a first point. -/\n@[simps]\nnoncomputable def pointedToTwoPSnd : Pointed.{u} ⥤ TwoP where\n  obj X := ⟨Option X, ⟨none, X.point⟩, (some_ne_none _).symm⟩\n  map f := ⟨Option.map f.toFun, rfl, congr_arg _ f.map_point⟩\n  map_id _ := Bipointed.Hom.ext Option.map_id\n  map_comp f g := Bipointed.Hom.ext (Option.map_comp_map f.1 g.1).symm\n\n"}
{"name":"pointedToTwoPFst_comp_swap","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"⊢ Eq (pointedToTwoPFst.comp TwoP.swap) pointedToTwoPSnd","decl":"@[simp]\ntheorem pointedToTwoPFst_comp_swap : pointedToTwoPFst ⋙ TwoP.swap = pointedToTwoPSnd :=\n  rfl\n\n"}
{"name":"pointedToTwoPSnd_comp_swap","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"⊢ Eq (pointedToTwoPSnd.comp TwoP.swap) pointedToTwoPFst","decl":"@[simp]\ntheorem pointedToTwoPSnd_comp_swap : pointedToTwoPSnd ⋙ TwoP.swap = pointedToTwoPFst :=\n  rfl\n\n"}
{"name":"pointedToTwoPFst_comp_forget_to_bipointed","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"⊢ Eq (pointedToTwoPFst.comp (CategoryTheory.forget₂ TwoP Bipointed)) pointedToBipointedFst","decl":"@[simp]\ntheorem pointedToTwoPFst_comp_forget_to_bipointed :\n    pointedToTwoPFst ⋙ forget₂ TwoP Bipointed = pointedToBipointedFst :=\n  rfl\n\n"}
{"name":"pointedToTwoPSnd_comp_forget_to_bipointed","module":"Mathlib.CategoryTheory.Category.TwoP","initialProofState":"⊢ Eq (pointedToTwoPSnd.comp (CategoryTheory.forget₂ TwoP Bipointed)) pointedToBipointedSnd","decl":"@[simp]\ntheorem pointedToTwoPSnd_comp_forget_to_bipointed :\n    pointedToTwoPSnd ⋙ forget₂ TwoP Bipointed = pointedToBipointedSnd :=\n  rfl\n\n"}
