{"name":"CategoryTheory.Limits.PreservesFilteredColimitsOfSize.preserves_filtered_colimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v, u₂} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.PreservesFilteredColimitsOfSize.{w', w, v, u₁, u₂} F\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\ninst✝ : CategoryTheory.IsFiltered J\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J F","decl":"/-- `PreservesFilteredColimitsOfSize.{w', w} F` means that `F` sends all colimit cocones over any\nfiltered diagram `J ⥤ C` to colimit cocones, where `J : Type w` with `[Category.{w'} J]`. -/\n@[nolint checkUnivs, pp_with_univ]\nclass PreservesFilteredColimitsOfSize (F : C ⥤ D) : Prop where\n  preserves_filtered_colimits :\n    ∀ (J : Type w) [Category.{w'} J] [IsFiltered J], PreservesColimitsOfShape J F\n\n"}
{"name":"CategoryTheory.Limits.PreservesColimits.preservesFilteredColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', v, v, u₁, u₂} F\n⊢ CategoryTheory.Limits.PreservesFilteredColimitsOfSize.{w, w', v, u₁, u₂} F","decl":"instance (priority := 100) PreservesColimits.preservesFilteredColimits (F : C ⥤ D)\n    [PreservesColimitsOfSize.{w, w'} F] : PreservesFilteredColimitsOfSize.{w, w'} F where\n  preserves_filtered_colimits _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.comp_preservesFilteredColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : CategoryTheory.Limits.PreservesFilteredColimitsOfSize.{w, w', v, u₁, u₂} F\ninst✝ : CategoryTheory.Limits.PreservesFilteredColimitsOfSize.{w, w', v, u₂, u₃} G\n⊢ CategoryTheory.Limits.PreservesFilteredColimitsOfSize.{w, w', v, u₁, u₃} (F.comp G)","decl":"instance comp_preservesFilteredColimits (F : C ⥤ D) (G : D ⥤ E)\n    [PreservesFilteredColimitsOfSize.{w, w'} F] [PreservesFilteredColimitsOfSize.{w, w'} G] :\n      PreservesFilteredColimitsOfSize.{w, w'} (F ⋙ G) where\n  preserves_filtered_colimits _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.preservesFilteredColimitsOfSize_of_univLE","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : UnivLE.{w, w'}\ninst✝¹ : UnivLE.{w₂, w₂'}\ninst✝ : CategoryTheory.Limits.PreservesFilteredColimitsOfSize.{w', w₂', v, u₁, u₂} F\n⊢ CategoryTheory.Limits.PreservesFilteredColimitsOfSize.{w, w₂, v, u₁, u₂} F","decl":"/-- A functor preserving larger filtered colimits also preserves smaller filtered colimits. -/\nlemma preservesFilteredColimitsOfSize_of_univLE (F : C ⥤ D) [UnivLE.{w, w'}]\n    [UnivLE.{w₂, w₂'}] [PreservesFilteredColimitsOfSize.{w', w₂'} F] :\n      PreservesFilteredColimitsOfSize.{w, w₂} F where\n  preserves_filtered_colimits J _ _ := by\n    let e := ((ShrinkHoms.equivalence J).trans <| Shrink.equivalence _).symm\n    haveI := IsFiltered.of_equivalence e.symm\n    exact preservesColimitsOfShape_of_equiv e F\n\n"}
{"name":"CategoryTheory.Limits.preservesFilteredColimitsOfSize_shrink","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesFilteredColimitsOfSize.{max w w₂, max w' w₂', v, u₁, u₂} F\n⊢ CategoryTheory.Limits.PreservesFilteredColimitsOfSize.{w, w', v, u₁, u₂} F","decl":"/--\n`PreservesFilteredColimitsOfSize_shrink.{w, w'} F` tries to obtain\n`PreservesFilteredColimitsOfSize.{w, w'} F` from some other `PreservesFilteredColimitsOfSize F`.\n-/\nlemma preservesFilteredColimitsOfSize_shrink (F : C ⥤ D)\n    [PreservesFilteredColimitsOfSize.{max w w₂, max w' w₂'} F] :\n      PreservesFilteredColimitsOfSize.{w, w'} F :=\n  preservesFilteredColimitsOfSize_of_univLE.{max w w₂, max w' w₂'} F\n\n"}
{"name":"CategoryTheory.Limits.preservesSmallestFilteredColimits_of_preservesFilteredColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesFilteredColimitsOfSize.{w', w, v, u₁, u₂} F\n⊢ CategoryTheory.Limits.PreservesFilteredColimitsOfSize.{0, 0, v, u₁, u₂} F","decl":"/--\nPreserving filtered colimits at any universe implies preserving filtered colimits at universe `0`.\n-/\nlemma preservesSmallestFilteredColimits_of_preservesFilteredColimits (F : C ⥤ D)\n    [PreservesFilteredColimitsOfSize.{w', w} F] : PreservesFilteredColimitsOfSize.{0, 0} F :=\n  preservesFilteredColimitsOfSize_shrink F\n\n"}
{"name":"CategoryTheory.Limits.ReflectsFilteredColimitsOfSize.reflects_filtered_colimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v, u₂} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.ReflectsFilteredColimitsOfSize.{w', w, v, u₁, u₂} F\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\ninst✝ : CategoryTheory.IsFiltered J\n⊢ CategoryTheory.Limits.ReflectsColimitsOfShape J F","decl":"/-- `ReflectsFilteredColimitsOfSize.{w', w} F` means that whenever the image of a filtered cocone\nunder `F` is a colimit cocone, the original cocone was already a colimit. -/\n@[nolint checkUnivs, pp_with_univ]\nclass ReflectsFilteredColimitsOfSize (F : C ⥤ D) : Prop where\n  reflects_filtered_colimits :\n    ∀ (J : Type w) [Category.{w'} J] [IsFiltered J], ReflectsColimitsOfShape J F\n\n"}
{"name":"CategoryTheory.Limits.ReflectsColimits.reflectsFilteredColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.ReflectsColimitsOfSize.{w, w', v, v, u₁, u₂} F\n⊢ CategoryTheory.Limits.ReflectsFilteredColimitsOfSize.{w, w', v, u₁, u₂} F","decl":"instance (priority := 100) ReflectsColimits.reflectsFilteredColimits (F : C ⥤ D)\n    [ReflectsColimitsOfSize.{w, w'} F] : ReflectsFilteredColimitsOfSize.{w, w'} F where\n  reflects_filtered_colimits _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.comp_reflectsFilteredColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : CategoryTheory.Limits.ReflectsFilteredColimitsOfSize.{w, w', v, u₁, u₂} F\ninst✝ : CategoryTheory.Limits.ReflectsFilteredColimitsOfSize.{w, w', v, u₂, u₃} G\n⊢ CategoryTheory.Limits.ReflectsFilteredColimitsOfSize.{w, w', v, u₁, u₃} (F.comp G)","decl":"instance comp_reflectsFilteredColimits (F : C ⥤ D) (G : D ⥤ E)\n    [ReflectsFilteredColimitsOfSize.{w, w'} F] [ReflectsFilteredColimitsOfSize.{w, w'} G] :\n      ReflectsFilteredColimitsOfSize.{w, w'} (F ⋙ G) where\n  reflects_filtered_colimits _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.reflectsFilteredColimitsOfSize_of_univLE","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : UnivLE.{w, w'}\ninst✝¹ : UnivLE.{w₂, w₂'}\ninst✝ : CategoryTheory.Limits.ReflectsFilteredColimitsOfSize.{w', w₂', v, u₁, u₂} F\n⊢ CategoryTheory.Limits.ReflectsFilteredColimitsOfSize.{w, w₂, v, u₁, u₂} F","decl":"/-- A functor reflecting larger filtered colimits also reflects smaller filtered colimits. -/\nlemma reflectsFilteredColimitsOfSize_of_univLE (F : C ⥤ D) [UnivLE.{w, w'}]\n    [UnivLE.{w₂, w₂'}] [ReflectsFilteredColimitsOfSize.{w', w₂'} F] :\n      ReflectsFilteredColimitsOfSize.{w, w₂} F where\n  reflects_filtered_colimits J _ _ := by\n    let e := ((ShrinkHoms.equivalence J).trans <| Shrink.equivalence _).symm\n    haveI := IsFiltered.of_equivalence e.symm\n    exact reflectsColimitsOfShape_of_equiv e F\n\n"}
{"name":"CategoryTheory.Limits.reflectsFilteredColimitsOfSize_shrink","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.ReflectsFilteredColimitsOfSize.{max w w₂, max w' w₂', v, u₁, u₂} F\n⊢ CategoryTheory.Limits.ReflectsFilteredColimitsOfSize.{w, w', v, u₁, u₂} F","decl":"/--\n`ReflectsFilteredColimitsOfSize_shrink.{w, w'} F` tries to obtain\n`ReflectsFilteredColimitsOfSize.{w, w'} F` from some other `ReflectsFilteredColimitsOfSize F`.\n-/\nlemma reflectsFilteredColimitsOfSize_shrink (F : C ⥤ D)\n    [ReflectsFilteredColimitsOfSize.{max w w₂, max w' w₂'} F] :\n      ReflectsFilteredColimitsOfSize.{w, w'} F :=\n  reflectsFilteredColimitsOfSize_of_univLE.{max w w₂, max w' w₂'} F\n\n"}
{"name":"CategoryTheory.Limits.reflectsSmallestFilteredColimits_of_reflectsFilteredColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.ReflectsFilteredColimitsOfSize.{w', w, v, u₁, u₂} F\n⊢ CategoryTheory.Limits.ReflectsFilteredColimitsOfSize.{0, 0, v, u₁, u₂} F","decl":"/--\nReflecting filtered colimits at any universe implies reflecting filtered colimits at universe `0`.\n-/\nlemma reflectsSmallestFilteredColimits_of_reflectsFilteredColimits (F : C ⥤ D)\n    [ReflectsFilteredColimitsOfSize.{w', w} F] : ReflectsFilteredColimitsOfSize.{0, 0} F :=\n  reflectsFilteredColimitsOfSize_shrink F\n\n"}
{"name":"CategoryTheory.Limits.PreservesCofilteredLimitsOfSize.preserves_cofiltered_limits","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v, u₂} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.PreservesCofilteredLimitsOfSize.{w', w, v, u₁, u₂} F\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\ninst✝ : CategoryTheory.IsCofiltered J\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J F","decl":"/-- `PreservesCofilteredLimitsOfSize.{w', w} F` means that `F` sends all limit cones over any\ncofiltered diagram `J ⥤ C` to limit cones, where `J : Type w` with `[Category.{w'} J]`. -/\n@[nolint checkUnivs, pp_with_univ]\nclass PreservesCofilteredLimitsOfSize (F : C ⥤ D) : Prop where\n  preserves_cofiltered_limits :\n    ∀ (J : Type w) [Category.{w'} J] [IsCofiltered J], PreservesLimitsOfShape J F\n\n"}
{"name":"CategoryTheory.Limits.PreservesLimits.preservesCofilteredLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', v, v, u₁, u₂} F\n⊢ CategoryTheory.Limits.PreservesCofilteredLimitsOfSize.{w, w', v, u₁, u₂} F","decl":"instance (priority := 100) PreservesLimits.preservesCofilteredLimits (F : C ⥤ D)\n    [PreservesLimitsOfSize.{w, w'} F] : PreservesCofilteredLimitsOfSize.{w, w'} F where\n  preserves_cofiltered_limits _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.comp_preservesCofilteredLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : CategoryTheory.Limits.PreservesCofilteredLimitsOfSize.{w, w', v, u₁, u₂} F\ninst✝ : CategoryTheory.Limits.PreservesCofilteredLimitsOfSize.{w, w', v, u₂, u₃} G\n⊢ CategoryTheory.Limits.PreservesCofilteredLimitsOfSize.{w, w', v, u₁, u₃} (F.comp G)","decl":"instance comp_preservesCofilteredLimits (F : C ⥤ D) (G : D ⥤ E)\n    [PreservesCofilteredLimitsOfSize.{w, w'} F] [PreservesCofilteredLimitsOfSize.{w, w'} G] :\n      PreservesCofilteredLimitsOfSize.{w, w'} (F ⋙ G) where\n  preserves_cofiltered_limits _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.preservesCofilteredLimitsOfSize_of_univLE","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : UnivLE.{w, w'}\ninst✝¹ : UnivLE.{w₂, w₂'}\ninst✝ : CategoryTheory.Limits.PreservesCofilteredLimitsOfSize.{w', w₂', v, u₁, u₂} F\n⊢ CategoryTheory.Limits.PreservesCofilteredLimitsOfSize.{w, w₂, v, u₁, u₂} F","decl":"/-- A functor preserving larger cofiltered limits also preserves smaller cofiltered limits. -/\nlemma preservesCofilteredLimitsOfSize_of_univLE (F : C ⥤ D) [UnivLE.{w, w'}]\n    [UnivLE.{w₂, w₂'}] [PreservesCofilteredLimitsOfSize.{w', w₂'} F] :\n      PreservesCofilteredLimitsOfSize.{w, w₂} F where\n  preserves_cofiltered_limits J _ _ := by\n    let e := ((ShrinkHoms.equivalence J).trans <| Shrink.equivalence _).symm\n    haveI := IsCofiltered.of_equivalence e.symm\n    exact preservesLimitsOfShape_of_equiv e F\n\n"}
{"name":"CategoryTheory.Limits.preservesCofilteredLimitsOfSize_shrink","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesCofilteredLimitsOfSize.{max w w₂, max w' w₂', v, u₁, u₂} F\n⊢ CategoryTheory.Limits.PreservesCofilteredLimitsOfSize.{w, w', v, u₁, u₂} F","decl":"/--\n`PreservesCofilteredLimitsOfSizeShrink.{w, w'} F` tries to obtain\n`PreservesCofilteredLimitsOfSize.{w, w'} F` from some other `PreservesCofilteredLimitsOfSize F`.\n-/\nlemma preservesCofilteredLimitsOfSize_shrink (F : C ⥤ D)\n    [PreservesCofilteredLimitsOfSize.{max w w₂, max w' w₂'} F] :\n      PreservesCofilteredLimitsOfSize.{w, w'} F :=\n  preservesCofilteredLimitsOfSize_of_univLE.{max w w₂, max w' w₂'} F\n\n"}
{"name":"CategoryTheory.Limits.preservesSmallestCofilteredLimits_of_preservesCofilteredLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesCofilteredLimitsOfSize.{w', w, v, u₁, u₂} F\n⊢ CategoryTheory.Limits.PreservesCofilteredLimitsOfSize.{0, 0, v, u₁, u₂} F","decl":"/--\nPreserving cofiltered limits at any universe implies preserving cofiltered limits at universe `0`.\n-/\nlemma preservesSmallestCofilteredLimits_of_preservesCofilteredLimits (F : C ⥤ D)\n    [PreservesCofilteredLimitsOfSize.{w', w} F] : PreservesCofilteredLimitsOfSize.{0, 0} F :=\n  preservesCofilteredLimitsOfSize_shrink F\n\n"}
{"name":"CategoryTheory.Limits.ReflectsCofilteredLimitsOfSize.reflects_cofiltered_limits","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v, u₂} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.Limits.ReflectsCofilteredLimitsOfSize.{w', w, v, u₁, u₂} F\nJ : Type w\ninst✝¹ : CategoryTheory.Category.{w', w} J\ninst✝ : CategoryTheory.IsCofiltered J\n⊢ CategoryTheory.Limits.ReflectsLimitsOfShape J F","decl":"/-- `ReflectsCofilteredLimitsOfSize.{w', w} F` means that whenever the image of a cofiltered cone\nunder `F` is a limit cone, the original cone was already a limit. -/\n@[nolint checkUnivs, pp_with_univ]\nclass ReflectsCofilteredLimitsOfSize (F : C ⥤ D) : Prop where\n  reflects_cofiltered_limits :\n    ∀ (J : Type w) [Category.{w'} J] [IsCofiltered J], ReflectsLimitsOfShape J F\n\n"}
{"name":"CategoryTheory.Limits.ReflectsLimits.reflectsCofilteredLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.ReflectsLimitsOfSize.{w, w', v, v, u₁, u₂} F\n⊢ CategoryTheory.Limits.ReflectsCofilteredLimitsOfSize.{w, w', v, u₁, u₂} F","decl":"instance (priority := 100) ReflectsLimits.reflectsCofilteredLimits (F : C ⥤ D)\n    [ReflectsLimitsOfSize.{w, w'} F] : ReflectsCofilteredLimitsOfSize.{w, w'} F where\n  reflects_cofiltered_limits _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.comp_reflectsCofilteredLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v, u₂} D\nE : Type u₃\ninst✝² : CategoryTheory.Category.{v, u₃} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝¹ : CategoryTheory.Limits.ReflectsCofilteredLimitsOfSize.{w, w', v, u₁, u₂} F\ninst✝ : CategoryTheory.Limits.ReflectsCofilteredLimitsOfSize.{w, w', v, u₂, u₃} G\n⊢ CategoryTheory.Limits.ReflectsCofilteredLimitsOfSize.{w, w', v, u₁, u₃} (F.comp G)","decl":"instance comp_reflectsCofilteredLimits (F : C ⥤ D) (G : D ⥤ E)\n    [ReflectsCofilteredLimitsOfSize.{w, w'} F] [ReflectsCofilteredLimitsOfSize.{w, w'} G] :\n      ReflectsCofilteredLimitsOfSize.{w, w'} (F ⋙ G) where\n  reflects_cofiltered_limits _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.reflectsCofilteredLimitsOfSize_of_univLE","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v, u₂} D\nF : CategoryTheory.Functor C D\ninst✝² : UnivLE.{w, w'}\ninst✝¹ : UnivLE.{w₂, w₂'}\ninst✝ : CategoryTheory.Limits.ReflectsCofilteredLimitsOfSize.{w', w₂', v, u₁, u₂} F\n⊢ CategoryTheory.Limits.ReflectsCofilteredLimitsOfSize.{w, w₂, v, u₁, u₂} F","decl":"/-- A functor reflecting larger cofiltered limits also reflects smaller cofiltered limits. -/\nlemma reflectsCofilteredLimitsOfSize_of_univLE (F : C ⥤ D) [UnivLE.{w, w'}]\n    [UnivLE.{w₂, w₂'}] [ReflectsCofilteredLimitsOfSize.{w', w₂'} F] :\n      ReflectsCofilteredLimitsOfSize.{w, w₂} F where\n  reflects_cofiltered_limits J _ _ := by\n    let e := ((ShrinkHoms.equivalence J).trans <| Shrink.equivalence _).symm\n    haveI := IsCofiltered.of_equivalence e.symm\n    exact reflectsLimitsOfShape_of_equiv e F\n\n"}
{"name":"CategoryTheory.Limits.reflectsCofilteredLimitsOfSize_shrink","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.ReflectsCofilteredLimitsOfSize.{max w w₂, max w' w₂', v, u₁, u₂} F\n⊢ CategoryTheory.Limits.ReflectsCofilteredLimitsOfSize.{w, w', v, u₁, u₂} F","decl":"/--\n`ReflectsCofilteredLimitsOfSize_shrink.{w, w'} F` tries to obtain\n`ReflectsCofilteredLimitsOfSize.{w, w'} F` from some other `ReflectsCofilteredLimitsOfSize F`.\n-/\nlemma reflectsCofilteredLimitsOfSize_shrink (F : C ⥤ D)\n    [ReflectsCofilteredLimitsOfSize.{max w w₂, max w' w₂'} F] :\n      ReflectsCofilteredLimitsOfSize.{w, w'} F :=\n  reflectsCofilteredLimitsOfSize_of_univLE.{max w w₂, max w' w₂'} F\n\n"}
{"name":"CategoryTheory.Limits.reflectsSmallestCofilteredLimits_of_reflectsCofilteredLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.Filtered","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.ReflectsCofilteredLimitsOfSize.{w', w, v, u₁, u₂} F\n⊢ CategoryTheory.Limits.ReflectsCofilteredLimitsOfSize.{0, 0, v, u₁, u₂} F","decl":"/--\nReflecting cofiltered limits at any universe implies reflecting cofiltered limits at universe `0`.\n-/\nlemma reflectsSmallestCofilteredLimits_of_reflectsCofilteredLimits (F : C ⥤ D)\n    [ReflectsCofilteredLimitsOfSize.{w', w} F] : ReflectsCofilteredLimitsOfSize.{0, 0} F :=\n  reflectsCofilteredLimitsOfSize_shrink F\n\n"}
