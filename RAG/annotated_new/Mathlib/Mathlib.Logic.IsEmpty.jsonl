{"name":"IsEmpty.false","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_4\nself : IsEmpty α\na✝ : α\n⊢ False","decl":"/-- `IsEmpty α` expresses that `α` is empty. -/\nclass IsEmpty (α : Sort*) : Prop where\n  protected false : α → False\n\n"}
{"name":"Empty.instIsEmpty","module":"Mathlib.Logic.IsEmpty","initialProofState":"⊢ IsEmpty Empty","decl":"instance Empty.instIsEmpty : IsEmpty Empty :=\n  ⟨Empty.elim⟩\n\n"}
{"name":"PEmpty.instIsEmpty","module":"Mathlib.Logic.IsEmpty","initialProofState":"⊢ IsEmpty PEmpty.{u_4}","decl":"instance PEmpty.instIsEmpty : IsEmpty PEmpty :=\n  ⟨PEmpty.elim⟩\n\n"}
{"name":"instIsEmptyFalse","module":"Mathlib.Logic.IsEmpty","initialProofState":"⊢ IsEmpty False","decl":"instance : IsEmpty False :=\n  ⟨id⟩\n\n"}
{"name":"Fin.isEmpty","module":"Mathlib.Logic.IsEmpty","initialProofState":"⊢ IsEmpty (Fin 0)","decl":"instance Fin.isEmpty : IsEmpty (Fin 0) :=\n  ⟨fun n ↦ Nat.not_lt_zero n.1 n.2⟩\n\n"}
{"name":"Fin.isEmpty'","module":"Mathlib.Logic.IsEmpty","initialProofState":"⊢ IsEmpty (Fin Nat.zero)","decl":"instance Fin.isEmpty' : IsEmpty (Fin Nat.zero) :=\n  Fin.isEmpty\n\n"}
{"name":"Function.isEmpty","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝ : IsEmpty β\nf : α → β\n⊢ IsEmpty α","decl":"protected theorem Function.isEmpty [IsEmpty β] (f : α → β) : IsEmpty α :=\n  ⟨fun x ↦ IsEmpty.false (f x)⟩\n\n"}
{"name":"Function.Surjective.isEmpty","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝ : IsEmpty α\nf : α → β\nhf : Function.Surjective f\n⊢ IsEmpty β","decl":"theorem Function.Surjective.isEmpty [IsEmpty α] {f : α → β} (hf : f.Surjective) : IsEmpty β :=\n  ⟨fun y ↦ let ⟨x, _⟩ := hf y; IsEmpty.false x⟩\n\n"}
{"name":"instIsEmptyForallOfNonempty","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\np : α → Sort u_4\nh : Nonempty α\ninst✝ : ∀ (x : α), IsEmpty (p x)\n⊢ IsEmpty ((x : α) → p x)","decl":"instance {p : α → Sort*} [h : Nonempty α] [∀ x, IsEmpty (p x)] : IsEmpty (∀ x, p x) :=\n  h.elim fun x ↦ Function.isEmpty <| Function.eval x\n\n"}
{"name":"PProd.isEmpty_left","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝ : IsEmpty α\n⊢ IsEmpty (PProd α β)","decl":"instance PProd.isEmpty_left [IsEmpty α] : IsEmpty (PProd α β) :=\n  Function.isEmpty PProd.fst\n\n"}
{"name":"PProd.isEmpty_right","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝ : IsEmpty β\n⊢ IsEmpty (PProd α β)","decl":"instance PProd.isEmpty_right [IsEmpty β] : IsEmpty (PProd α β) :=\n  Function.isEmpty PProd.snd\n\n"}
{"name":"Prod.isEmpty_left","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝ : IsEmpty α\n⊢ IsEmpty (Prod α β)","decl":"instance Prod.isEmpty_left {α β} [IsEmpty α] : IsEmpty (α × β) :=\n  Function.isEmpty Prod.fst\n\n"}
{"name":"Prod.isEmpty_right","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝ : IsEmpty β\n⊢ IsEmpty (Prod α β)","decl":"instance Prod.isEmpty_right {α β} [IsEmpty β] : IsEmpty (α × β) :=\n  Function.isEmpty Prod.snd\n\n"}
{"name":"Quot.instIsEmpty","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_4\ninst✝ : IsEmpty α\nr : α → α → Prop\n⊢ IsEmpty (Quot r)","decl":"instance Quot.instIsEmpty {α : Sort*} [IsEmpty α] {r : α → α → Prop} : IsEmpty (Quot r) :=\n  Function.Surjective.isEmpty Quot.exists_rep\n\n"}
{"name":"Quotient.instIsEmpty","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_4\ninst✝ : IsEmpty α\ns : Setoid α\n⊢ IsEmpty (Quotient s)","decl":"instance Quotient.instIsEmpty {α : Sort*} [IsEmpty α] {s : Setoid α} : IsEmpty (Quotient s) :=\n  Quot.instIsEmpty\n\n"}
{"name":"instIsEmptyPSum","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝¹ : IsEmpty α\ninst✝ : IsEmpty β\n⊢ IsEmpty (PSum α β)","decl":"instance [IsEmpty α] [IsEmpty β] : IsEmpty (α ⊕' β) :=\n  ⟨fun x ↦ PSum.rec IsEmpty.false IsEmpty.false x⟩\n\n"}
{"name":"instIsEmptySum","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : IsEmpty α\ninst✝ : IsEmpty β\n⊢ IsEmpty (Sum α β)","decl":"instance instIsEmptySum {α β} [IsEmpty α] [IsEmpty β] : IsEmpty (α ⊕ β) :=\n  ⟨fun x ↦ Sum.rec IsEmpty.false IsEmpty.false x⟩\n\n"}
{"name":"instIsEmptySubtype","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\ninst✝ : IsEmpty α\np : α → Prop\n⊢ IsEmpty (Subtype p)","decl":"/-- subtypes of an empty type are empty -/\ninstance [IsEmpty α] (p : α → Prop) : IsEmpty (Subtype p) :=\n  ⟨fun x ↦ IsEmpty.false x.1⟩\n\n"}
{"name":"Subtype.isEmpty_of_false","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\np : α → Prop\nhp : ∀ (a : α), Not (p a)\n⊢ IsEmpty (Subtype p)","decl":"/-- subtypes by an all-false predicate are false. -/\ntheorem Subtype.isEmpty_of_false {p : α → Prop} (hp : ∀ a, ¬p a) : IsEmpty (Subtype p) :=\n  ⟨fun x ↦ hp _ x.2⟩\n\n"}
{"name":"Subtype.isEmpty_false","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\n⊢ IsEmpty (Subtype fun _a => False)","decl":"/-- subtypes by false are false. -/\ninstance Subtype.isEmpty_false : IsEmpty { _a : α // False } :=\n  Subtype.isEmpty_of_false fun _ ↦ id\n\n"}
{"name":"Sigma.isEmpty_left","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Type u_5\ninst✝ : IsEmpty α\nE : α → Type u_4\n⊢ IsEmpty (Sigma E)","decl":"instance Sigma.isEmpty_left {α} [IsEmpty α] {E : α → Type*} : IsEmpty (Sigma E) :=\n  Function.isEmpty Sigma.fst\n\n"}
{"name":"isEmpty_iff","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\n⊢ Iff (IsEmpty α) (α → False)","decl":"theorem isEmpty_iff : IsEmpty α ↔ α → False :=\n  ⟨@IsEmpty.false α, IsEmpty.mk⟩\n\n"}
{"name":"IsEmpty.prop_iff","module":"Mathlib.Logic.IsEmpty","initialProofState":"p : Prop\n⊢ Iff (IsEmpty p) (Not p)","decl":"protected theorem prop_iff {p : Prop} : IsEmpty p ↔ ¬p :=\n  isEmpty_iff\n\n"}
{"name":"IsEmpty.forall_iff","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\ninst✝ : IsEmpty α\np : α → Prop\n⊢ Iff (∀ (a : α), p a) True","decl":"@[simp]\ntheorem forall_iff {p : α → Prop} : (∀ a, p a) ↔ True :=\n  iff_true_intro isEmptyElim\n\n"}
{"name":"IsEmpty.exists_iff","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\ninst✝ : IsEmpty α\np : α → Prop\n⊢ Iff (Exists fun a => p a) False","decl":"@[simp]\ntheorem exists_iff {p : α → Prop} : (∃ a, p a) ↔ False :=\n  iff_false_intro fun ⟨x, _⟩ ↦ IsEmpty.false x\n\n-- see Note [lower instance priority]\n"}
{"name":"IsEmpty.instSubsingleton","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\ninst✝ : IsEmpty α\n⊢ Subsingleton α","decl":"instance (priority := 100) : Subsingleton α :=\n  ⟨isEmptyElim⟩\n\n"}
{"name":"not_nonempty_iff","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\n⊢ Iff (Not (Nonempty α)) (IsEmpty α)","decl":"@[simp]\ntheorem not_nonempty_iff : ¬Nonempty α ↔ IsEmpty α :=\n  ⟨fun h ↦ ⟨fun x ↦ h ⟨x⟩⟩, fun h1 h2 ↦ h2.elim h1.elim⟩\n\n"}
{"name":"not_isEmpty_iff","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\n⊢ Iff (Not (IsEmpty α)) (Nonempty α)","decl":"@[simp]\ntheorem not_isEmpty_iff : ¬IsEmpty α ↔ Nonempty α :=\n  not_iff_comm.mp not_nonempty_iff\n\n"}
{"name":"isEmpty_Prop","module":"Mathlib.Logic.IsEmpty","initialProofState":"p : Prop\n⊢ Iff (IsEmpty p) (Not p)","decl":"@[simp]\ntheorem isEmpty_Prop {p : Prop} : IsEmpty p ↔ ¬p := by\n  simp only [← not_nonempty_iff, nonempty_prop]\n\n"}
{"name":"isEmpty_pi","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\nπ : α → Sort u_4\n⊢ Iff (IsEmpty ((a : α) → π a)) (Exists fun a => IsEmpty (π a))","decl":"@[simp]\ntheorem isEmpty_pi {π : α → Sort*} : IsEmpty (∀ a, π a) ↔ ∃ a, IsEmpty (π a) := by\n  simp only [← not_nonempty_iff, Classical.nonempty_pi, not_forall]\n\n"}
{"name":"isEmpty_fun","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\nβ : Sort u_2\n⊢ Iff (IsEmpty (α → β)) (And (Nonempty α) (IsEmpty β))","decl":"theorem isEmpty_fun : IsEmpty (α → β) ↔ Nonempty α ∧ IsEmpty β := by\n  rw [isEmpty_pi, ← exists_true_iff_nonempty, ← exists_and_right, true_and]\n\n"}
{"name":"nonempty_fun","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\nβ : Sort u_2\n⊢ Iff (Nonempty (α → β)) (Or (IsEmpty α) (Nonempty β))","decl":"@[simp]\ntheorem nonempty_fun : Nonempty (α → β) ↔ IsEmpty α ∨ Nonempty β :=\n  not_iff_not.mp <| by rw [not_or, not_nonempty_iff, not_nonempty_iff, isEmpty_fun, not_isEmpty_iff]\n\n"}
{"name":"isEmpty_sigma","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Type u_5\nE : α → Type u_4\n⊢ Iff (IsEmpty (Sigma E)) (∀ (a : α), IsEmpty (E a))","decl":"@[simp]\ntheorem isEmpty_sigma {α} {E : α → Type*} : IsEmpty (Sigma E) ↔ ∀ a, IsEmpty (E a) := by\n  simp only [← not_nonempty_iff, nonempty_sigma, not_exists]\n\n"}
{"name":"isEmpty_psigma","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_5\nE : α → Sort u_4\n⊢ Iff (IsEmpty (PSigma E)) (∀ (a : α), IsEmpty (E a))","decl":"@[simp]\ntheorem isEmpty_psigma {α} {E : α → Sort*} : IsEmpty (PSigma E) ↔ ∀ a, IsEmpty (E a) := by\n  simp only [← not_nonempty_iff, nonempty_psigma, not_exists]\n\n"}
{"name":"isEmpty_subtype","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\np : α → Prop\n⊢ Iff (IsEmpty (Subtype p)) (∀ (x : α), Not (p x))","decl":"theorem isEmpty_subtype (p : α → Prop) : IsEmpty (Subtype p) ↔ ∀ x, ¬p x := by\n  simp only [← not_nonempty_iff, nonempty_subtype, not_exists]\n\n"}
{"name":"isEmpty_prod","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Type u_4\nβ : Type u_5\n⊢ Iff (IsEmpty (Prod α β)) (Or (IsEmpty α) (IsEmpty β))","decl":"@[simp]\ntheorem isEmpty_prod {α β : Type*} : IsEmpty (α × β) ↔ IsEmpty α ∨ IsEmpty β := by\n  simp only [← not_nonempty_iff, nonempty_prod, not_and_or]\n\n"}
{"name":"isEmpty_pprod","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\nβ : Sort u_2\n⊢ Iff (IsEmpty (PProd α β)) (Or (IsEmpty α) (IsEmpty β))","decl":"@[simp]\ntheorem isEmpty_pprod : IsEmpty (PProd α β) ↔ IsEmpty α ∨ IsEmpty β := by\n  simp only [← not_nonempty_iff, nonempty_pprod, not_and_or]\n\n"}
{"name":"isEmpty_sum","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Type u_4\nβ : Type u_5\n⊢ Iff (IsEmpty (Sum α β)) (And (IsEmpty α) (IsEmpty β))","decl":"@[simp]\ntheorem isEmpty_sum {α β} : IsEmpty (α ⊕ β) ↔ IsEmpty α ∧ IsEmpty β := by\n  simp only [← not_nonempty_iff, nonempty_sum, not_or]\n\n"}
{"name":"isEmpty_psum","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_4\nβ : Sort u_5\n⊢ Iff (IsEmpty (PSum α β)) (And (IsEmpty α) (IsEmpty β))","decl":"@[simp]\ntheorem isEmpty_psum {α β} : IsEmpty (α ⊕' β) ↔ IsEmpty α ∧ IsEmpty β := by\n  simp only [← not_nonempty_iff, nonempty_psum, not_or]\n\n"}
{"name":"isEmpty_ulift","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Type u_4\n⊢ Iff (IsEmpty (ULift.{u_5, u_4} α)) (IsEmpty α)","decl":"@[simp]\ntheorem isEmpty_ulift {α} : IsEmpty (ULift α) ↔ IsEmpty α := by\n  simp only [← not_nonempty_iff, nonempty_ulift]\n\n"}
{"name":"isEmpty_plift","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_4\n⊢ Iff (IsEmpty (PLift α)) (IsEmpty α)","decl":"@[simp]\ntheorem isEmpty_plift {α} : IsEmpty (PLift α) ↔ IsEmpty α := by\n  simp only [← not_nonempty_iff, nonempty_plift]\n\n"}
{"name":"wellFounded_of_isEmpty","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_4\ninst✝ : IsEmpty α\nr : α → α → Prop\n⊢ WellFounded r","decl":"theorem wellFounded_of_isEmpty {α} [IsEmpty α] (r : α → α → Prop) : WellFounded r :=\n  ⟨isEmptyElim⟩\n\n"}
{"name":"isEmpty_or_nonempty","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\n⊢ Or (IsEmpty α) (Nonempty α)","decl":"theorem isEmpty_or_nonempty : IsEmpty α ∨ Nonempty α :=\n  (em <| IsEmpty α).elim Or.inl <| Or.inr ∘ not_isEmpty_iff.mp\n\n"}
{"name":"not_isEmpty_of_nonempty","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\nh : Nonempty α\n⊢ Not (IsEmpty α)","decl":"@[simp]\ntheorem not_isEmpty_of_nonempty [h : Nonempty α] : ¬IsEmpty α :=\n  not_isEmpty_iff.mpr h\n\n"}
{"name":"Function.extend_of_isEmpty","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\ninst✝ : IsEmpty α\nf : α → β\ng : α → γ\nh : β → γ\n⊢ Eq (Function.extend f g h) h","decl":"theorem Function.extend_of_isEmpty [IsEmpty α] (f : α → β) (g : α → γ) (h : β → γ) :\n    Function.extend f g h = h :=\n  funext fun _ ↦ (Function.extend_apply' _ _ _) fun ⟨a, _⟩ ↦ isEmptyElim a\n\n"}
{"name":"leftTotal_empty","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Type u_4\nβ : Type u_5\nR : α → β → Prop\ninst✝ : IsEmpty α\n⊢ Relator.LeftTotal R","decl":"@[simp]\ntheorem leftTotal_empty [IsEmpty α] : LeftTotal R := by\n  simp only [LeftTotal, IsEmpty.forall_iff]\n\n"}
{"name":"leftTotal_iff_isEmpty_left","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Type u_4\nβ : Type u_5\nR : α → β → Prop\ninst✝ : IsEmpty β\n⊢ Iff (Relator.LeftTotal R) (IsEmpty α)","decl":"theorem leftTotal_iff_isEmpty_left [IsEmpty β] : LeftTotal R ↔ IsEmpty α := by\n  simp only [LeftTotal, IsEmpty.exists_iff, isEmpty_iff]\n\n"}
{"name":"rightTotal_empty","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Type u_4\nβ : Type u_5\nR : α → β → Prop\ninst✝ : IsEmpty β\n⊢ Relator.RightTotal R","decl":"@[simp]\ntheorem rightTotal_empty [IsEmpty β] : RightTotal R := by\n  simp only [RightTotal, IsEmpty.forall_iff]\n\n"}
{"name":"rightTotal_iff_isEmpty_right","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Type u_4\nβ : Type u_5\nR : α → β → Prop\ninst✝ : IsEmpty α\n⊢ Iff (Relator.RightTotal R) (IsEmpty β)","decl":"theorem rightTotal_iff_isEmpty_right [IsEmpty α] : RightTotal R ↔ IsEmpty β := by\n  simp only [RightTotal, IsEmpty.exists_iff, isEmpty_iff, imp_self]\n\n"}
{"name":"biTotal_empty","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Type u_4\nβ : Type u_5\nR : α → β → Prop\ninst✝¹ : IsEmpty α\ninst✝ : IsEmpty β\n⊢ Relator.BiTotal R","decl":"@[simp]\ntheorem biTotal_empty [IsEmpty α] [IsEmpty β] : BiTotal R :=\n  ⟨leftTotal_empty R, rightTotal_empty R⟩\n\n"}
{"name":"biTotal_iff_isEmpty_right","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Type u_4\nβ : Type u_5\nR : α → β → Prop\ninst✝ : IsEmpty α\n⊢ Iff (Relator.BiTotal R) (IsEmpty β)","decl":"theorem biTotal_iff_isEmpty_right [IsEmpty α] : BiTotal R ↔ IsEmpty β := by\n  simp only [BiTotal, leftTotal_empty, rightTotal_iff_isEmpty_right, true_and]\n\n"}
{"name":"biTotal_iff_isEmpty_left","module":"Mathlib.Logic.IsEmpty","initialProofState":"α : Type u_4\nβ : Type u_5\nR : α → β → Prop\ninst✝ : IsEmpty β\n⊢ Iff (Relator.BiTotal R) (IsEmpty α)","decl":"theorem biTotal_iff_isEmpty_left [IsEmpty β] : BiTotal R ↔ IsEmpty α := by\n  simp only [BiTotal, leftTotal_iff_isEmpty_left, rightTotal_empty, and_true]\n"}
