{"name":"Algebra.adjoin.powerBasis_gen","module":"Mathlib.RingTheory.Adjoin.PowerBasis","initialProofState":"K : Type u_1\nS : Type u_2\ninst✝² : Field K\ninst✝¹ : CommRing S\ninst✝ : Algebra K S\nx : S\nhx : IsIntegral K x\n⊢ Eq (Algebra.adjoin.powerBasis hx).gen ⟨x, ⋯⟩","decl":"/-- The power basis `1, x, ..., x ^ (d - 1)` for `K[x]`,\nwhere `d` is the degree of the minimal polynomial of `x`. See `Algebra.adjoin.powerBasis'` for\na version over a more general base ring. -/\n@[simps gen dim]\nnoncomputable def adjoin.powerBasis {x : S} (hx : IsIntegral K x) :\n    PowerBasis K (adjoin K ({x} : Set S)) where\n  gen := ⟨x, subset_adjoin (Set.mem_singleton x)⟩\n  dim := (minpoly K x).natDegree\n  basis := adjoin.powerBasisAux hx\n  basis_eq_pow i := by rw [adjoin.powerBasisAux, Basis.mk_apply]\n\n"}
{"name":"Algebra.adjoin.powerBasis_dim","module":"Mathlib.RingTheory.Adjoin.PowerBasis","initialProofState":"K : Type u_1\nS : Type u_2\ninst✝² : Field K\ninst✝¹ : CommRing S\ninst✝ : Algebra K S\nx : S\nhx : IsIntegral K x\n⊢ Eq (Algebra.adjoin.powerBasis hx).dim (minpoly K x).natDegree","decl":"/-- The power basis `1, x, ..., x ^ (d - 1)` for `K[x]`,\nwhere `d` is the degree of the minimal polynomial of `x`. See `Algebra.adjoin.powerBasis'` for\na version over a more general base ring. -/\n@[simps gen dim]\nnoncomputable def adjoin.powerBasis {x : S} (hx : IsIntegral K x) :\n    PowerBasis K (adjoin K ({x} : Set S)) where\n  gen := ⟨x, subset_adjoin (Set.mem_singleton x)⟩\n  dim := (minpoly K x).natDegree\n  basis := adjoin.powerBasisAux hx\n  basis_eq_pow i := by rw [adjoin.powerBasisAux, Basis.mk_apply]\n\n"}
{"name":"PowerBasis.ofGenMemAdjoin_dim","module":"Mathlib.RingTheory.Adjoin.PowerBasis","initialProofState":"K : Type u_1\nS : Type u_2\ninst✝² : Field K\ninst✝¹ : CommRing S\ninst✝ : Algebra K S\nx : S\nB : PowerBasis K S\nhint : IsIntegral K x\nhx : Membership.mem (Algebra.adjoin K (Singleton.singleton x)) B.gen\n⊢ Eq (B.ofGenMemAdjoin hint hx).dim (minpoly K x).natDegree","decl":"/-- The power basis given by `x` if `B.gen ∈ adjoin K {x}`. See `PowerBasis.ofGenMemAdjoin'`\nfor a version over a more general base ring. -/\n@[simps!]\nnoncomputable def PowerBasis.ofGenMemAdjoin {x : S} (B : PowerBasis K S) (hint : IsIntegral K x)\n    (hx : B.gen ∈ adjoin K ({x} : Set S)) : PowerBasis K S :=\n  (Algebra.adjoin.powerBasis hint).map <|\n    (Subalgebra.equivOfEq _ _ <| PowerBasis.adjoin_eq_top_of_gen_mem_adjoin hx).trans\n      Subalgebra.topEquiv\n\n"}
{"name":"PowerBasis.ofGenMemAdjoin_gen","module":"Mathlib.RingTheory.Adjoin.PowerBasis","initialProofState":"K : Type u_1\nS : Type u_2\ninst✝² : Field K\ninst✝¹ : CommRing S\ninst✝ : Algebra K S\nx : S\nB : PowerBasis K S\nhint : IsIntegral K x\nhx : Membership.mem (Algebra.adjoin K (Singleton.singleton x)) B.gen\n⊢ Eq (B.ofGenMemAdjoin hint hx).gen x","decl":"/-- The power basis given by `x` if `B.gen ∈ adjoin K {x}`. See `PowerBasis.ofGenMemAdjoin'`\nfor a version over a more general base ring. -/\n@[simps!]\nnoncomputable def PowerBasis.ofGenMemAdjoin {x : S} (B : PowerBasis K S) (hint : IsIntegral K x)\n    (hx : B.gen ∈ adjoin K ({x} : Set S)) : PowerBasis K S :=\n  (Algebra.adjoin.powerBasis hint).map <|\n    (Subalgebra.equivOfEq _ _ <| PowerBasis.adjoin_eq_top_of_gen_mem_adjoin hx).trans\n      Subalgebra.topEquiv\n\n"}
{"name":"PowerBasis.repr_gen_pow_isIntegral","module":"Mathlib.RingTheory.Adjoin.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁷ : CommRing S\nR : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : Algebra R S\nA : Type u_4\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : Algebra S A\ninst✝¹ : IsScalarTower R S A\nB : PowerBasis S A\nhB : IsIntegral R B.gen\ninst✝ : IsDomain S\nhmin : Eq (minpoly S B.gen) (Polynomial.map (algebraMap R S) (minpoly R B.gen))\nn : Nat\ni : Fin B.dim\n⊢ IsIntegral R ((B.basis.repr (HPow.hPow B.gen n)) i)","decl":"/-- If `B : PowerBasis S A` is such that `IsIntegral R B.gen`, then\n`IsIntegral R (B.basis.repr (B.gen ^ n) i)` for all `i` if\n`minpoly S B.gen = (minpoly R B.gen).map (algebraMap R S)`. This is the case if `R` is a GCD domain\nand `S` is its fraction ring. -/\ntheorem repr_gen_pow_isIntegral (hB : IsIntegral R B.gen) [IsDomain S]\n    (hmin : minpoly S B.gen = (minpoly R B.gen).map (algebraMap R S)) (n : ℕ) :\n    ∀ i, IsIntegral R (B.basis.repr (B.gen ^ n) i) := by\n  intro i\n  let Q := X ^ n %ₘ minpoly R B.gen\n  have : B.gen ^ n = aeval B.gen Q := by\n    rw [← @aeval_X_pow R _ _ _ _ B.gen, ← modByMonic_add_div (X ^ n) (minpoly.monic hB)]\n    simp [Q]\n  by_cases hQ : Q = 0\n  · simp [this, hQ, isIntegral_zero]\n  have hlt : Q.natDegree < B.dim := by\n    rw [← B.natDegree_minpoly, hmin, (minpoly.monic hB).natDegree_map,\n      natDegree_lt_natDegree_iff hQ]\n    letI : Nontrivial R := Nontrivial.of_polynomial_ne hQ\n    exact degree_modByMonic_lt _ (minpoly.monic hB)\n  rw [this, aeval_eq_sum_range' hlt]\n  simp only [map_sum, LinearEquiv.map_smulₛₗ, RingHom.id_apply, Finset.sum_apply']\n  refine IsIntegral.sum _ fun j hj => ?_\n  replace hj := Finset.mem_range.1 hj\n  rw [← Fin.val_mk hj, ← B.basis_eq_pow, Algebra.smul_def, IsScalarTower.algebraMap_apply R S A, ←\n    Algebra.smul_def, LinearEquiv.map_smul]\n  simp only [algebraMap_smul, Finsupp.coe_smul, Pi.smul_apply, B.basis.repr_self_apply]\n  by_cases hij : (⟨j, hj⟩ : Fin _) = i\n  · simp only [hij, eq_self_iff_true, if_true]\n    rw [Algebra.smul_def, mul_one]\n    exact isIntegral_algebraMap\n  · simp [hij, isIntegral_zero]\n\n"}
{"name":"PowerBasis.repr_mul_isIntegral","module":"Mathlib.RingTheory.Adjoin.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁷ : CommRing S\nR : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : Algebra R S\nA : Type u_4\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : Algebra S A\ninst✝¹ : IsScalarTower R S A\nB : PowerBasis S A\nhB : IsIntegral R B.gen\ninst✝ : IsDomain S\nx y : A\nhx : ∀ (i : Fin B.dim), IsIntegral R ((B.basis.repr x) i)\nhy : ∀ (i : Fin B.dim), IsIntegral R ((B.basis.repr y) i)\nhmin : Eq (minpoly S B.gen) (Polynomial.map (algebraMap R S) (minpoly R B.gen))\ni : Fin B.dim\n⊢ IsIntegral R ((B.basis.repr (HMul.hMul x y)) i)","decl":"/-- Let `B : PowerBasis S A` be such that `IsIntegral R B.gen`, and let `x y : A` be elements with\nintegral coordinates in the base `B.basis`. Then `IsIntegral R ((B.basis.repr (x * y) i)` for all\n`i` if `minpoly S B.gen = (minpoly R B.gen).map (algebraMap R S)`. This is the case if `R` is a GCD\ndomain and `S` is its fraction ring. -/\ntheorem repr_mul_isIntegral (hB : IsIntegral R B.gen) [IsDomain S] {x y : A}\n    (hx : ∀ i, IsIntegral R (B.basis.repr x i)) (hy : ∀ i, IsIntegral R (B.basis.repr y i))\n    (hmin : minpoly S B.gen = (minpoly R B.gen).map (algebraMap R S)) :\n    ∀ i, IsIntegral R (B.basis.repr (x * y) i) := by\n  intro i\n  rw [← B.basis.sum_repr x, ← B.basis.sum_repr y, Finset.sum_mul_sum, ← Finset.sum_product',\n    map_sum, Finset.sum_apply']\n  refine IsIntegral.sum _ fun I _ => ?_\n  simp only [Algebra.smul_mul_assoc, Algebra.mul_smul_comm, LinearEquiv.map_smulₛₗ,\n    RingHom.id_apply, Finsupp.coe_smul, Pi.smul_apply, id.smul_eq_mul]\n  refine (hy _).mul ((hx _).mul ?_)\n  simp only [coe_basis, ← pow_add]\n  exact repr_gen_pow_isIntegral hB hmin _ _\n\n"}
{"name":"PowerBasis.repr_pow_isIntegral","module":"Mathlib.RingTheory.Adjoin.PowerBasis","initialProofState":"S : Type u_2\ninst✝⁷ : CommRing S\nR : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : Algebra R S\nA : Type u_4\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : Algebra S A\ninst✝¹ : IsScalarTower R S A\nB : PowerBasis S A\ninst✝ : IsDomain S\nhB : IsIntegral R B.gen\nx : A\nhx : ∀ (i : Fin B.dim), IsIntegral R ((B.basis.repr x) i)\nhmin : Eq (minpoly S B.gen) (Polynomial.map (algebraMap R S) (minpoly R B.gen))\nn : Nat\ni : Fin B.dim\n⊢ IsIntegral R ((B.basis.repr (HPow.hPow x n)) i)","decl":"/-- Let `B : PowerBasis S A` be such that `IsIntegral R B.gen`, and let `x : A` be an element\nwith integral coordinates in the base `B.basis`. Then `IsIntegral R ((B.basis.repr (x ^ n) i)` for\nall `i` and all `n` if `minpoly S B.gen = (minpoly R B.gen).map (algebraMap R S)`. This is the case\nif `R` is a GCD domain and `S` is its fraction ring. -/\ntheorem repr_pow_isIntegral [IsDomain S] (hB : IsIntegral R B.gen) {x : A}\n    (hx : ∀ i, IsIntegral R (B.basis.repr x i))\n    (hmin : minpoly S B.gen = (minpoly R B.gen).map (algebraMap R S)) (n : ℕ) :\n    ∀ i, IsIntegral R (B.basis.repr (x ^ n) i) := by\n  nontriviality A using Subsingleton.elim (x ^ n) 0, isIntegral_zero\n  revert hx\n  refine Nat.case_strong_induction_on\n    -- Porting note: had to hint what to induct on\n    (p := fun n ↦ _ → ∀ (i : Fin B.dim), IsIntegral R (B.basis.repr (x ^ n) i))\n    n ?_ fun n hn => ?_\n  · intro _ i\n    rw [pow_zero, ← pow_zero B.gen, ← Fin.val_mk B.dim_pos, ← B.basis_eq_pow,\n      B.basis.repr_self_apply]\n    split_ifs\n    · exact isIntegral_one\n    · exact isIntegral_zero\n  · intro hx\n    rw [pow_succ]\n    exact repr_mul_isIntegral hB (fun _ => hn _ le_rfl (fun _ => hx _) _) hx hmin\n\n"}
{"name":"PowerBasis.toMatrix_isIntegral","module":"Mathlib.RingTheory.Adjoin.PowerBasis","initialProofState":"K : Type u_1\nS : Type u_2\ninst✝⁶ : Field K\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra K S\nR : Type u_3\ninst✝³ : CommRing R\ninst✝² : Algebra R S\ninst✝¹ : Algebra R K\ninst✝ : IsScalarTower R K S\nB B' : PowerBasis K S\nP : Polynomial R\nh : Eq ((Polynomial.aeval B.gen) P) B'.gen\nhB : IsIntegral R B.gen\nhmin : Eq (minpoly K B.gen) (Polynomial.map (algebraMap R K) (minpoly R B.gen))\ni : Fin B.dim\nj : Fin B'.dim\n⊢ IsIntegral R (B.basis.toMatrix (⇑B'.basis) i j)","decl":"/-- Let `B B' : PowerBasis K S` be such that `IsIntegral R B.gen`, and let `P : R[X]` be such that\n`aeval B.gen P = B'.gen`. Then `IsIntegral R (B.basis.to_matrix B'.basis i j)` for all `i` and `j`\nif `minpoly K B.gen = (minpoly R B.gen).map (algebraMap R L)`. This is the case\nif `R` is a GCD domain and `K` is its fraction ring. -/\ntheorem toMatrix_isIntegral {B B' : PowerBasis K S} {P : R[X]} (h : aeval B.gen P = B'.gen)\n    (hB : IsIntegral R B.gen) (hmin : minpoly K B.gen = (minpoly R B.gen).map (algebraMap R K)) :\n    ∀ i j, IsIntegral R (B.basis.toMatrix B'.basis i j) := by\n  intro i j\n  rw [B.basis.toMatrix_apply, B'.coe_basis]\n  refine repr_pow_isIntegral hB (fun i => ?_) hmin _ _\n  rw [← h, aeval_eq_sum_range, map_sum, Finset.sum_apply']\n  refine IsIntegral.sum _ fun n _ => ?_\n  rw [Algebra.smul_def, IsScalarTower.algebraMap_apply R K S, ← Algebra.smul_def,\n    LinearEquiv.map_smul, algebraMap_smul]\n  exact (repr_gen_pow_isIntegral hB hmin _ _).smul _\n\n"}
