{"name":"mem_derangements_iff_fixedPoints_eq_empty","module":"Mathlib.Combinatorics.Derangements.Basic","initialProofState":"α : Type u_1\nf : Equiv.Perm α\n⊢ Iff (Membership.mem (derangements α) f) (Eq (Function.fixedPoints ⇑f) EmptyCollection.emptyCollection)","decl":"theorem mem_derangements_iff_fixedPoints_eq_empty {f : Perm α} :\n    f ∈ derangements α ↔ fixedPoints f = ∅ :=\n  Set.eq_empty_iff_forall_not_mem.symm\n\n"}
{"name":"derangements.Equiv.RemoveNone.mem_fiber","module":"Mathlib.Combinatorics.Derangements.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : Option α\nf : Equiv.Perm α\n⊢ Iff (Membership.mem (derangements.Equiv.RemoveNone.fiber a) f) (Exists fun F => And (Membership.mem (derangements (Option α)) F) (And (Eq (F Option.none) a) (Eq (Equiv.removeNone F) f)))","decl":"theorem RemoveNone.mem_fiber (a : Option α) (f : Perm α) :\n    f ∈ RemoveNone.fiber a ↔\n      ∃ F : Perm (Option α), F ∈ derangements (Option α) ∧ F none = a ∧ removeNone F = f := by\n  simp [RemoveNone.fiber, derangements]\n\n"}
{"name":"derangements.Equiv.RemoveNone.fiber_none","module":"Mathlib.Combinatorics.Derangements.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Eq (derangements.Equiv.RemoveNone.fiber Option.none) EmptyCollection.emptyCollection","decl":"theorem RemoveNone.fiber_none : RemoveNone.fiber (@none α) = ∅ := by\n  rw [Set.eq_empty_iff_forall_not_mem]\n  intro f hyp\n  rw [RemoveNone.mem_fiber] at hyp\n  rcases hyp with ⟨F, F_derangement, F_none, _⟩\n  exact F_derangement none F_none\n\n"}
{"name":"derangements.Equiv.RemoveNone.fiber_some","module":"Mathlib.Combinatorics.Derangements.Basic","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\n⊢ Eq (derangements.Equiv.RemoveNone.fiber (Option.some a)) (setOf fun f => HasSubset.Subset (Function.fixedPoints ⇑f) (Singleton.singleton a))","decl":"/-- For any `a : α`, the fiber over `some a` is the set of permutations\n    where `a` is the only possible fixed point. -/\ntheorem RemoveNone.fiber_some (a : α) :\n    RemoveNone.fiber (some a) = { f : Perm α | fixedPoints f ⊆ {a} } := by\n  ext f\n  constructor\n  · rw [RemoveNone.mem_fiber]\n    rintro ⟨F, F_derangement, F_none, rfl⟩ x x_fixed\n    rw [mem_fixedPoints_iff] at x_fixed\n    apply_fun some at x_fixed\n    cases' Fx : F (some x) with y\n    · rwa [removeNone_none F Fx, F_none, Option.some_inj, eq_comm] at x_fixed\n    · exfalso\n      rw [removeNone_some F ⟨y, Fx⟩] at x_fixed\n      exact F_derangement _ x_fixed\n  · intro h_opfp\n    use Equiv.Perm.decomposeOption.symm (some a, f)\n    constructor\n    · intro x\n      apply_fun fun x => Equiv.swap none (some a) x\n      simp only [Perm.decomposeOption_symm_apply, swap_apply_self, Perm.coe_mul]\n      cases' x with x\n      · simp\n      simp only [comp, optionCongr_apply, Option.map_some', swap_apply_self]\n      by_cases x_vs_a : x = a\n      · rw [x_vs_a, swap_apply_right]\n        apply Option.some_ne_none\n      have ne_1 : some x ≠ none := Option.some_ne_none _\n      have ne_2 : some x ≠ some a := (Option.some_injective α).ne_iff.mpr x_vs_a\n      rw [swap_apply_of_ne_of_ne ne_1 ne_2, (Option.some_injective α).ne_iff]\n      intro contra\n      exact x_vs_a (h_opfp contra)\n    · rw [apply_symm_apply]\n\n"}
