{"name":"CategoryTheory.instOverClass_over","module":"Mathlib.CategoryTheory.Comma.OverClass","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\n‚ä¢ Eq (CategoryTheory.over X X inferInstance) (CategoryTheory.CategoryStruct.id X)","decl":"@[simps]\ninstance : OverClass X X := ‚ü®ùüô _‚ü©\n\n"}
{"name":"CategoryTheory.instIsIsoOverInferInstanceOverClass","module":"Mathlib.CategoryTheory.Comma.OverClass","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nS : C\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.over S S inferInstance)","decl":"instance : IsIso (S ‚Üò S) := inferInstanceAs (IsIso (ùüô S))\n\n-- This cannot be a simp lemma be cause it loops with `comp_over`.\n"}
{"name":"CategoryTheory.instOverClassOfCanonicallyOverClass_over","module":"Mathlib.CategoryTheory.Comma.OverClass","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y S : C\ninst‚úù¬π : CategoryTheory.CanonicallyOverClass X Y\ninst‚úù : CategoryTheory.OverClass Y S\n‚ä¢ Eq (CategoryTheory.over X S inferInstance) (CategoryTheory.CategoryStruct.comp (CategoryTheory.over X Y inferInstance) (CategoryTheory.over Y S inferInstance))","decl":"@[simps (config := .lemmasOnly)]\ninstance (priority := 900) [CanonicallyOverClass X Y] [OverClass Y S] : OverClass X S :=\n  ‚ü®X ‚Üò Y ‚â´ Y ‚Üò S‚ü©\n\n"}
{"name":"CategoryTheory.HomIsOver.comp_over","module":"Mathlib.CategoryTheory.Comma.OverClass","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nS : C\ninst‚úù¬π : CategoryTheory.OverClass X S\ninst‚úù : CategoryTheory.OverClass Y S\nself : CategoryTheory.HomIsOver f S\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.over Y S inferInstance)) (CategoryTheory.over X S inferInstance)","decl":"/-- Given `OverClass X S` and `OverClass Y S` and `f : X ‚ü∂ Y`,\n`HomIsOver f S` is the typeclass asserting `f` commutes with the structure morphisms. -/\nclass HomIsOver (f : X ‚ü∂ Y) (S : C) [OverClass X S] [OverClass Y S] : Prop where\n  comp_over : f ‚â´ Y ‚Üò S = X ‚Üò S := by aesop\n\n"}
{"name":"CategoryTheory.comp_over_assoc","module":"Mathlib.CategoryTheory.Comma.OverClass","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nS : C\ninst‚úù¬≤ : CategoryTheory.OverClass X S\ninst‚úù¬π : CategoryTheory.OverClass Y S\ninst‚úù : CategoryTheory.HomIsOver f S\nZ : C\nh : Quiver.Hom S Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.over Y S inferInstance) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.over X S inferInstance) h)","decl":"@[reassoc (attr := simp)]\nlemma comp_over [OverClass X S] [OverClass Y S] [HomIsOver f S] :\n    f ‚â´ Y ‚Üò S = X ‚Üò S :=\n  HomIsOver.comp_over\n\n"}
{"name":"CategoryTheory.comp_over","module":"Mathlib.CategoryTheory.Comma.OverClass","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nS : C\ninst‚úù¬≤ : CategoryTheory.OverClass X S\ninst‚úù¬π : CategoryTheory.OverClass Y S\ninst‚úù : CategoryTheory.HomIsOver f S\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.over Y S inferInstance)) (CategoryTheory.over X S inferInstance)","decl":"@[reassoc (attr := simp)]\nlemma comp_over [OverClass X S] [OverClass Y S] [HomIsOver f S] :\n    f ‚â´ Y ‚Üò S = X ‚Üò S :=\n  HomIsOver.comp_over\n\n"}
{"name":"CategoryTheory.instHomIsOverId","module":"Mathlib.CategoryTheory.Comma.OverClass","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX S : C\ninst‚úù : CategoryTheory.OverClass X S\n‚ä¢ CategoryTheory.HomIsOver (CategoryTheory.CategoryStruct.id X) S","decl":"instance [OverClass X S] : HomIsOver (ùüô X) S where\n\n"}
{"name":"CategoryTheory.instHomIsOverComp","module":"Mathlib.CategoryTheory.Comma.OverClass","initialProofState":"C : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} C\nX Y Z S : C\ninst‚úù‚Å¥ : CategoryTheory.OverClass X S\ninst‚úù¬≥ : CategoryTheory.OverClass Y S\ninst‚úù¬≤ : CategoryTheory.OverClass Z S\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.HomIsOver f S\ninst‚úù : CategoryTheory.HomIsOver g S\n‚ä¢ CategoryTheory.HomIsOver (CategoryTheory.CategoryStruct.comp f g) S","decl":"instance [OverClass X S] [OverClass Y S] [OverClass Z S]\n    (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [HomIsOver f S] [HomIsOver g S] :\n    HomIsOver (f ‚â´ g) S where\n\n"}
{"name":"CategoryTheory.instIsOverTower","module":"Mathlib.CategoryTheory.Comma.OverClass","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX S : C\ninst‚úù : CategoryTheory.OverClass X S\n‚ä¢ CategoryTheory.IsOverTower X X S","decl":"instance [OverClass X S] : IsOverTower X X S where\n"}
{"name":"CategoryTheory.instIsOverTower_1","module":"Mathlib.CategoryTheory.Comma.OverClass","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX S : C\ninst‚úù : CategoryTheory.OverClass X S\n‚ä¢ CategoryTheory.IsOverTower X S S","decl":"instance [OverClass X S] : IsOverTower X S S where\n\n"}
{"name":"CategoryTheory.instIsOverTower_2","module":"Mathlib.CategoryTheory.Comma.OverClass","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y S : C\ninst‚úù¬π : CategoryTheory.CanonicallyOverClass X Y\ninst‚úù : CategoryTheory.OverClass Y S\n‚ä¢ CategoryTheory.IsOverTower X Y S","decl":"instance [CanonicallyOverClass X Y] [OverClass Y S] : IsOverTower X Y S :=\n  ‚ü®rfl‚ü©\n\n"}
{"name":"CategoryTheory.homIsOver_of_isOverTower","module":"Mathlib.CategoryTheory.Comma.OverClass","initialProofState":"C : Type u\ninst‚úù‚Å∏ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nS S' : C\ninst‚úù‚Å∑ : CategoryTheory.OverClass X S\ninst‚úù‚Å∂ : CategoryTheory.OverClass X S'\ninst‚úù‚Åµ : CategoryTheory.OverClass Y S\ninst‚úù‚Å¥ : CategoryTheory.OverClass Y S'\ninst‚úù¬≥ : CategoryTheory.OverClass S S'\ninst‚úù¬≤ : CategoryTheory.IsOverTower X S S'\ninst‚úù¬π : CategoryTheory.IsOverTower Y S S'\ninst‚úù : CategoryTheory.HomIsOver f S\n‚ä¢ CategoryTheory.HomIsOver f S'","decl":"lemma homIsOver_of_isOverTower [OverClass X S] [OverClass X S'] [OverClass Y S]\n    [OverClass Y S'] [OverClass S S']\n    [IsOverTower X S S'] [IsOverTower Y S S'] [HomIsOver f S] : HomIsOver f S' := by\n  constructor\n  rw [‚Üê comp_over (Y ‚Üò S), comp_over_assoc f, comp_over]\n\n"}
{"name":"CategoryTheory.instHomIsOverOfIsOverTower","module":"Mathlib.CategoryTheory.Comma.OverClass","initialProofState":"C : Type u\ninst‚úù‚Å∏ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nS S' : C\ninst‚úù‚Å∑ : CategoryTheory.CanonicallyOverClass X S\ninst‚úù‚Å∂ : CategoryTheory.OverClass X S'\ninst‚úù‚Åµ : CategoryTheory.OverClass Y S\ninst‚úù‚Å¥ : CategoryTheory.OverClass Y S'\ninst‚úù¬≥ : CategoryTheory.OverClass S S'\ninst‚úù¬≤ : CategoryTheory.IsOverTower X S S'\ninst‚úù¬π : CategoryTheory.IsOverTower Y S S'\ninst‚úù : CategoryTheory.HomIsOver f S\n‚ä¢ CategoryTheory.HomIsOver f S'","decl":"instance [CanonicallyOverClass X S]\n    [OverClass X S'] [OverClass Y S] [OverClass Y S'] [OverClass S S']\n    [IsOverTower X S S'] [IsOverTower Y S S'] [HomIsOver f S] : HomIsOver f S' :=\n  homIsOver_of_isOverTower f S S'\n\n"}
{"name":"CategoryTheory.instHomIsOverOfIsOverTower_1","module":"Mathlib.CategoryTheory.Comma.OverClass","initialProofState":"C : Type u\ninst‚úù‚Å∏ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nS S' : C\ninst‚úù‚Å∑ : CategoryTheory.OverClass X S\ninst‚úù‚Å∂ : CategoryTheory.OverClass X S'\ninst‚úù‚Åµ : CategoryTheory.CanonicallyOverClass Y S\ninst‚úù‚Å¥ : CategoryTheory.OverClass Y S'\ninst‚úù¬≥ : CategoryTheory.OverClass S S'\ninst‚úù¬≤ : CategoryTheory.IsOverTower X S S'\ninst‚úù¬π : CategoryTheory.IsOverTower Y S S'\ninst‚úù : CategoryTheory.HomIsOver f S\n‚ä¢ CategoryTheory.HomIsOver f S'","decl":"instance [OverClass X S]\n    [OverClass X S'] [CanonicallyOverClass Y S] [OverClass Y S'] [OverClass S S']\n    [IsOverTower X S S'] [IsOverTower Y S S'] [HomIsOver f S] : HomIsOver f S' :=\n  homIsOver_of_isOverTower f S S'\n\n"}
{"name":"CategoryTheory.OverClass.asOver_left","module":"Mathlib.CategoryTheory.Comma.OverClass","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX S : C\ninst‚úù : CategoryTheory.OverClass X S\n‚ä¢ Eq (CategoryTheory.OverClass.asOver X S).left X","decl":"variable (X) in\n/-- Bundle `X` with an `OverClass X S` instance into `Over S`. -/\n@[simps! hom left]\ndef OverClass.asOver [OverClass X S] : Over S := Over.mk (X ‚Üò S)\n\n"}
{"name":"CategoryTheory.OverClass.asOver_hom","module":"Mathlib.CategoryTheory.Comma.OverClass","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX S : C\ninst‚úù : CategoryTheory.OverClass X S\n‚ä¢ Eq (CategoryTheory.OverClass.asOver X S).hom (CategoryTheory.over X S inferInstance)","decl":"variable (X) in\n/-- Bundle `X` with an `OverClass X S` instance into `Over S`. -/\n@[simps! hom left]\ndef OverClass.asOver [OverClass X S] : Over S := Over.mk (X ‚Üò S)\n\n"}
{"name":"CategoryTheory.OverClass.asOverHom_left","module":"Mathlib.CategoryTheory.Comma.OverClass","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nX Y S : C\ninst‚úù¬≤ : CategoryTheory.OverClass X S\ninst‚úù¬π : CategoryTheory.OverClass Y S\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.HomIsOver f S\n‚ä¢ Eq (CategoryTheory.OverClass.asOverHom S f).left f","decl":"/-- Bundle a morphism `f : X ‚ü∂ Y` with `HomIsOver f S` into a morphism in `Over S`. -/\n@[simps! left]\ndef OverClass.asOverHom [OverClass X S] [OverClass Y S] (f : X ‚ü∂ Y) [HomIsOver f S] :\n    OverClass.asOver X S ‚ü∂ OverClass.asOver Y S :=\n  Over.homMk f (comp_over f S)\n\n"}
{"name":"CategoryTheory.OverClass.fromOver_over","module":"Mathlib.CategoryTheory.Comma.OverClass","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nS : C\nX : CategoryTheory.Over S\n‚ä¢ Eq (CategoryTheory.over X.left S inferInstance) X.hom","decl":"@[simps]\ninstance OverClass.fromOver {S : C} (X : Over S) : OverClass X.left S where\n  hom := X.hom\n\n"}
{"name":"CategoryTheory.instHomIsOverLeftDiscretePUnit","module":"Mathlib.CategoryTheory.Comma.OverClass","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nS : C\nX Y : CategoryTheory.Over S\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.HomIsOver f.left S","decl":"instance {S : C} {X Y : Over S} (f : X ‚ü∂ Y) : HomIsOver f.left S where\n  comp_over := Over.w f\n\n"}
