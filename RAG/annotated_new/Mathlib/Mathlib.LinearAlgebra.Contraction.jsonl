{"name":"contractLeft_apply","module":"Mathlib.LinearAlgebra.Contraction","initialProofState":"R : Type u\nM : Type v₁\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.Dual R M\nm : M\n⊢ Eq ((contractLeft R M) (TensorProduct.tmul R f m)) (f m)","decl":"@[simp]\ntheorem contractLeft_apply (f : Module.Dual R M) (m : M) : contractLeft R M (f ⊗ₜ m) = f m :=\n  rfl\n\n"}
{"name":"contractRight_apply","module":"Mathlib.LinearAlgebra.Contraction","initialProofState":"R : Type u\nM : Type v₁\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.Dual R M\nm : M\n⊢ Eq ((contractRight R M) (TensorProduct.tmul R m f)) (f m)","decl":"@[simp]\ntheorem contractRight_apply (f : Module.Dual R M) (m : M) : contractRight R M (m ⊗ₜ f) = f m :=\n  rfl\n\n"}
{"name":"dualTensorHom_apply","module":"Mathlib.LinearAlgebra.Contraction","initialProofState":"R : Type u\nM : Type v₁\nN : Type v₂\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R M\ninst✝ : Module R N\nf : Module.Dual R M\nm : M\nn : N\n⊢ Eq (((dualTensorHom R M N) (TensorProduct.tmul R f n)) m) (HSMul.hSMul (f m) n)","decl":"@[simp]\ntheorem dualTensorHom_apply (f : Module.Dual R M) (m : M) (n : N) :\n    dualTensorHom R M N (f ⊗ₜ n) m = f m • n :=\n  rfl\n\n"}
{"name":"transpose_dualTensorHom","module":"Mathlib.LinearAlgebra.Contraction","initialProofState":"R : Type u\nM : Type v₁\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nf : Module.Dual R M\nm : M\n⊢ Eq (Module.Dual.transpose ((dualTensorHom R M M) (TensorProduct.tmul R f m))) ((dualTensorHom R (Module.Dual R M) (Module.Dual R M)) (TensorProduct.tmul R ((Module.Dual.eval R M) m) f))","decl":"@[simp]\ntheorem transpose_dualTensorHom (f : Module.Dual R M) (m : M) :\n    Dual.transpose (R := R) (dualTensorHom R M M (f ⊗ₜ m)) =\n    dualTensorHom R _ _ (Dual.eval R M m ⊗ₜ f) := by\n  ext f' m'\n  simp only [Dual.transpose_apply, coe_comp, Function.comp_apply, dualTensorHom_apply,\n    LinearMap.map_smulₛₗ, RingHom.id_apply, Algebra.id.smul_eq_mul, Dual.eval_apply,\n    LinearMap.smul_apply]\n  exact mul_comm _ _\n\n"}
{"name":"dualTensorHom_prodMap_zero","module":"Mathlib.LinearAlgebra.Contraction","initialProofState":"R : Type u\nM : Type v₁\nN : Type v₂\nP : Type v₃\nQ : Type v₄\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R P\ninst✝ : Module R Q\nf : Module.Dual R M\np : P\n⊢ Eq (((dualTensorHom R M P) (TensorProduct.tmul R f p)).prodMap 0) ((dualTensorHom R (Prod M N) (Prod P Q)) (TensorProduct.tmul R (LinearMap.comp f (LinearMap.fst R M N)) ((LinearMap.inl R P Q) p)))","decl":"@[simp]\ntheorem dualTensorHom_prodMap_zero (f : Module.Dual R M) (p : P) :\n    ((dualTensorHom R M P) (f ⊗ₜ[R] p)).prodMap (0 : N →ₗ[R] Q) =\n      dualTensorHom R (M × N) (P × Q) ((f ∘ₗ fst R M N) ⊗ₜ inl R P Q p) := by\n  ext <;>\n    simp only [coe_comp, coe_inl, Function.comp_apply, prodMap_apply, dualTensorHom_apply,\n      fst_apply, Prod.smul_mk, LinearMap.zero_apply, smul_zero]\n\n"}
{"name":"zero_prodMap_dualTensorHom","module":"Mathlib.LinearAlgebra.Contraction","initialProofState":"R : Type u\nM : Type v₁\nN : Type v₂\nP : Type v₃\nQ : Type v₄\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R P\ninst✝ : Module R Q\ng : Module.Dual R N\nq : Q\n⊢ Eq (LinearMap.prodMap 0 ((dualTensorHom R N Q) (TensorProduct.tmul R g q))) ((dualTensorHom R (Prod M N) (Prod P Q)) (TensorProduct.tmul R (LinearMap.comp g (LinearMap.snd R M N)) ((LinearMap.inr R P Q) q)))","decl":"@[simp]\ntheorem zero_prodMap_dualTensorHom (g : Module.Dual R N) (q : Q) :\n    (0 : M →ₗ[R] P).prodMap ((dualTensorHom R N Q) (g ⊗ₜ[R] q)) =\n      dualTensorHom R (M × N) (P × Q) ((g ∘ₗ snd R M N) ⊗ₜ inr R P Q q) := by\n  ext <;>\n    simp only [coe_comp, coe_inr, Function.comp_apply, prodMap_apply, dualTensorHom_apply,\n      snd_apply, Prod.smul_mk, LinearMap.zero_apply, smul_zero]\n\n"}
{"name":"map_dualTensorHom","module":"Mathlib.LinearAlgebra.Contraction","initialProofState":"R : Type u\nM : Type v₁\nN : Type v₂\nP : Type v₃\nQ : Type v₄\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : AddCommMonoid Q\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module R P\ninst✝ : Module R Q\nf : Module.Dual R M\np : P\ng : Module.Dual R N\nq : Q\n⊢ Eq (TensorProduct.map ((dualTensorHom R M P) (TensorProduct.tmul R f p)) ((dualTensorHom R N Q) (TensorProduct.tmul R g q))) ((dualTensorHom R (TensorProduct R M N) (TensorProduct R P Q)) (TensorProduct.tmul R ((TensorProduct.dualDistrib R M N) (TensorProduct.tmul R f g)) (TensorProduct.tmul R p q)))","decl":"theorem map_dualTensorHom (f : Module.Dual R M) (p : P) (g : Module.Dual R N) (q : Q) :\n    TensorProduct.map (dualTensorHom R M P (f ⊗ₜ[R] p)) (dualTensorHom R N Q (g ⊗ₜ[R] q)) =\n      dualTensorHom R (M ⊗[R] N) (P ⊗[R] Q) (dualDistrib R M N (f ⊗ₜ g) ⊗ₜ[R] p ⊗ₜ[R] q) := by\n  ext m n\n  simp only [compr₂_apply, mk_apply, map_tmul, dualTensorHom_apply, dualDistrib_apply, ←\n    smul_tmul_smul]\n\n"}
{"name":"comp_dualTensorHom","module":"Mathlib.LinearAlgebra.Contraction","initialProofState":"R : Type u\nM : Type v₁\nN : Type v₂\nP : Type v₃\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid P\ninst✝² : Module R M\ninst✝¹ : Module R N\ninst✝ : Module R P\nf : Module.Dual R M\nn : N\ng : Module.Dual R N\np : P\n⊢ Eq (((dualTensorHom R N P) (TensorProduct.tmul R g p)).comp ((dualTensorHom R M N) (TensorProduct.tmul R f n))) (HSMul.hSMul (g n) ((dualTensorHom R M P) (TensorProduct.tmul R f p)))","decl":"@[simp]\ntheorem comp_dualTensorHom (f : Module.Dual R M) (n : N) (g : Module.Dual R N) (p : P) :\n    dualTensorHom R N P (g ⊗ₜ[R] p) ∘ₗ dualTensorHom R M N (f ⊗ₜ[R] n) =\n      g n • dualTensorHom R M P (f ⊗ₜ p) := by\n  ext m\n  simp only [coe_comp, Function.comp_apply, dualTensorHom_apply, LinearMap.map_smul,\n    RingHom.id_apply, LinearMap.smul_apply]\n  rw [smul_comm]\n\n"}
{"name":"toMatrix_dualTensorHom","module":"Mathlib.LinearAlgebra.Contraction","initialProofState":"R : Type u\nM : Type v₁\nN : Type v₂\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\nm : Type u_1\nn : Type u_2\ninst✝³ : Fintype m\ninst✝² : Finite n\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq n\nbM : Basis m R M\nbN : Basis n R N\nj : m\ni : n\n⊢ Eq ((LinearMap.toMatrix bM bN) ((dualTensorHom R M N) (TensorProduct.tmul R (bM.coord j) (bN i)))) (Matrix.stdBasisMatrix i j 1)","decl":"/-- As a matrix, `dualTensorHom` evaluated on a basis element of `M* ⊗ N` is a matrix with a\nsingle one and zeros elsewhere -/\ntheorem toMatrix_dualTensorHom {m : Type*} {n : Type*} [Fintype m] [Finite n] [DecidableEq m]\n    [DecidableEq n] (bM : Basis m R M) (bN : Basis n R N) (j : m) (i : n) :\n    toMatrix bM bN (dualTensorHom R M N (bM.coord j ⊗ₜ bN i)) = stdBasisMatrix i j 1 := by\n  ext i' j'\n  by_cases hij : i = i' ∧ j = j' <;>\n    simp [LinearMap.toMatrix_apply, Finsupp.single_eq_pi_single, hij]\n  rw [and_iff_not_or_not, Classical.not_not] at hij\n  cases' hij with hij hij <;> simp [hij]\n\n"}
{"name":"dualTensorHomEquivOfBasis_apply","module":"Mathlib.LinearAlgebra.Contraction","initialProofState":"ι : Type w\nR : Type u\nM : Type v₁\nN : Type v₂\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nb : Basis ι R M\nx : TensorProduct R (Module.Dual R M) N\n⊢ Eq ((dualTensorHomEquivOfBasis b) x) ((dualTensorHom R M N) x)","decl":"@[simp]\ntheorem dualTensorHomEquivOfBasis_apply (x : Module.Dual R M ⊗[R] N) :\n    (dualTensorHomEquivOfBasis (N := N) b :\n    Module.Dual R M ⊗[R] N → (M →ₗ[R] N)) x = (dualTensorHom R M N) x := by\n  ext; rfl\n\n"}
{"name":"dualTensorHomEquivOfBasis_toLinearMap","module":"Mathlib.LinearAlgebra.Contraction","initialProofState":"ι : Type w\nR : Type u\nM : Type v₁\nN : Type v₂\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nb : Basis ι R M\n⊢ Eq (↑(dualTensorHomEquivOfBasis b)) (dualTensorHom R M N)","decl":"@[simp]\ntheorem dualTensorHomEquivOfBasis_toLinearMap :\n    (dualTensorHomEquivOfBasis b : Module.Dual R M ⊗[R] N ≃ₗ[R] M →ₗ[R] N).toLinearMap =\n      dualTensorHom R M N :=\n  rfl\n\n-- Porting note: should N be explicit in dualTensorHomEquivOfBasis?\n"}
{"name":"dualTensorHomEquivOfBasis_symm_cancel_left","module":"Mathlib.LinearAlgebra.Contraction","initialProofState":"ι : Type w\nR : Type u\nM : Type v₁\nN : Type v₂\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nb : Basis ι R M\nx : TensorProduct R (Module.Dual R M) N\n⊢ Eq ((dualTensorHomEquivOfBasis b).symm ((dualTensorHom R M N) x)) x","decl":"@[simp]\ntheorem dualTensorHomEquivOfBasis_symm_cancel_left (x : Module.Dual R M ⊗[R] N) :\n    (dualTensorHomEquivOfBasis (N := N) b).symm (dualTensorHom R M N x) = x := by\n  rw [← dualTensorHomEquivOfBasis_apply b,\n    LinearEquiv.symm_apply_apply <| dualTensorHomEquivOfBasis (N := N) b]\n\n"}
{"name":"dualTensorHomEquivOfBasis_symm_cancel_right","module":"Mathlib.LinearAlgebra.Contraction","initialProofState":"ι : Type w\nR : Type u\nM : Type v₁\nN : Type v₂\ninst✝⁶ : CommRing R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nb : Basis ι R M\nx : LinearMap (RingHom.id R) M N\n⊢ Eq ((dualTensorHom R M N) ((dualTensorHomEquivOfBasis b).symm x)) x","decl":"@[simp]\ntheorem dualTensorHomEquivOfBasis_symm_cancel_right (x : M →ₗ[R] N) :\n    dualTensorHom R M N ((dualTensorHomEquivOfBasis (N := N) b).symm x) = x := by\n  rw [← dualTensorHomEquivOfBasis_apply b, LinearEquiv.apply_symm_apply]\n\n"}
{"name":"lTensorHomEquivHomLTensor_toLinearMap","module":"Mathlib.LinearAlgebra.Contraction","initialProofState":"R : Type u\nM : Type v₁\nP : Type v₃\nQ : Type v₄\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup P\ninst✝⁵ : AddCommGroup Q\ninst✝⁴ : Module R M\ninst✝³ : Module R P\ninst✝² : Module R Q\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\n⊢ Eq (↑(lTensorHomEquivHomLTensor R M P Q)) (TensorProduct.lTensorHomToHomLTensor R M P Q)","decl":"@[simp]\ntheorem lTensorHomEquivHomLTensor_toLinearMap :\n    (lTensorHomEquivHomLTensor R M P Q).toLinearMap = lTensorHomToHomLTensor R M P Q := by\n  classical -- Porting note: missing decidable for choosing basis\n  let e := congr (LinearEquiv.refl R P) (dualTensorHomEquiv R M Q)\n  have h : Function.Surjective e.toLinearMap := e.surjective\n  refine (cancel_right h).1 ?_\n  ext f q m\n  simp only [e, lTensorHomEquivHomLTensor, dualTensorHomEquiv, LinearEquiv.comp_coe, compr₂_apply,\n    mk_apply, LinearEquiv.coe_coe, LinearEquiv.trans_apply, congr_tmul, LinearEquiv.refl_apply,\n    dualTensorHomEquivOfBasis_apply, dualTensorHomEquivOfBasis_symm_cancel_left, leftComm_tmul,\n    dualTensorHom_apply, coe_comp, Function.comp_apply, lTensorHomToHomLTensor_apply, tmul_smul]\n\n"}
{"name":"rTensorHomEquivHomRTensor_toLinearMap","module":"Mathlib.LinearAlgebra.Contraction","initialProofState":"R : Type u\nM : Type v₁\nP : Type v₃\nQ : Type v₄\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup P\ninst✝⁵ : AddCommGroup Q\ninst✝⁴ : Module R M\ninst✝³ : Module R P\ninst✝² : Module R Q\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\n⊢ Eq (↑(rTensorHomEquivHomRTensor R M P Q)) (TensorProduct.rTensorHomToHomRTensor R M P Q)","decl":"@[simp]\ntheorem rTensorHomEquivHomRTensor_toLinearMap :\n    (rTensorHomEquivHomRTensor R M P Q).toLinearMap = rTensorHomToHomRTensor R M P Q := by\n  classical -- Porting note: missing decidable for choosing basis\n  let e := congr (dualTensorHomEquiv R M P) (LinearEquiv.refl R Q)\n  have h : Function.Surjective e.toLinearMap := e.surjective\n  refine (cancel_right h).1 ?_\n  ext f p q m\n  simp only [e, rTensorHomEquivHomRTensor, dualTensorHomEquiv, compr₂_apply, mk_apply, coe_comp,\n    LinearEquiv.coe_toLinearMap, Function.comp_apply, map_tmul, LinearEquiv.coe_coe,\n    dualTensorHomEquivOfBasis_apply, LinearEquiv.trans_apply, congr_tmul,\n    dualTensorHomEquivOfBasis_symm_cancel_left, LinearEquiv.refl_apply, assoc_tmul,\n    dualTensorHom_apply, rTensorHomToHomRTensor_apply, smul_tmul']\n\n"}
{"name":"lTensorHomEquivHomLTensor_apply","module":"Mathlib.LinearAlgebra.Contraction","initialProofState":"R : Type u\nM : Type v₁\nP : Type v₃\nQ : Type v₄\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup P\ninst✝⁵ : AddCommGroup Q\ninst✝⁴ : Module R M\ninst✝³ : Module R P\ninst✝² : Module R Q\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\nx : TensorProduct R P (LinearMap (RingHom.id R) M Q)\n⊢ Eq ((lTensorHomEquivHomLTensor R M P Q) x) ((TensorProduct.lTensorHomToHomLTensor R M P Q) x)","decl":"@[simp]\ntheorem lTensorHomEquivHomLTensor_apply (x : P ⊗[R] (M →ₗ[R] Q)) :\n    lTensorHomEquivHomLTensor R M P Q x = lTensorHomToHomLTensor R M P Q x := by\n  rw [← LinearEquiv.coe_toLinearMap, lTensorHomEquivHomLTensor_toLinearMap]\n\n"}
{"name":"rTensorHomEquivHomRTensor_apply","module":"Mathlib.LinearAlgebra.Contraction","initialProofState":"R : Type u\nM : Type v₁\nP : Type v₃\nQ : Type v₄\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup P\ninst✝⁵ : AddCommGroup Q\ninst✝⁴ : Module R M\ninst✝³ : Module R P\ninst✝² : Module R Q\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\nx : TensorProduct R (LinearMap (RingHom.id R) M P) Q\n⊢ Eq ((rTensorHomEquivHomRTensor R M P Q) x) ((TensorProduct.rTensorHomToHomRTensor R M P Q) x)","decl":"@[simp]\ntheorem rTensorHomEquivHomRTensor_apply (x : (M →ₗ[R] P) ⊗[R] Q) :\n    rTensorHomEquivHomRTensor R M P Q x = rTensorHomToHomRTensor R M P Q x := by\n  rw [← LinearEquiv.coe_toLinearMap, rTensorHomEquivHomRTensor_toLinearMap]\n\n"}
{"name":"homTensorHomEquiv_toLinearMap","module":"Mathlib.LinearAlgebra.Contraction","initialProofState":"R : Type u\nM : Type v₁\nN : Type v₂\nP : Type v₃\nQ : Type v₄\ninst✝¹² : CommRing R\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : AddCommGroup N\ninst✝⁹ : AddCommGroup P\ninst✝⁸ : AddCommGroup Q\ninst✝⁷ : Module R M\ninst✝⁶ : Module R N\ninst✝⁵ : Module R P\ninst✝⁴ : Module R Q\ninst✝³ : Module.Free R M\ninst✝² : Module.Finite R M\ninst✝¹ : Module.Free R N\ninst✝ : Module.Finite R N\n⊢ Eq (↑(homTensorHomEquiv R M N P Q)) (TensorProduct.homTensorHomMap R M N P Q)","decl":"@[simp]\ntheorem homTensorHomEquiv_toLinearMap :\n    (homTensorHomEquiv R M N P Q).toLinearMap = homTensorHomMap R M N P Q := by\n  ext m n\n  simp only [homTensorHomEquiv, compr₂_apply, mk_apply, LinearEquiv.coe_toLinearMap,\n    LinearEquiv.trans_apply, lift.equiv_apply, LinearEquiv.arrowCongr_apply, LinearEquiv.refl_symm,\n    LinearEquiv.refl_apply, rTensorHomEquivHomRTensor_apply, lTensorHomEquivHomLTensor_apply,\n    lTensorHomToHomLTensor_apply, rTensorHomToHomRTensor_apply, homTensorHomMap_apply,\n    map_tmul]\n\n"}
{"name":"homTensorHomEquiv_apply","module":"Mathlib.LinearAlgebra.Contraction","initialProofState":"R : Type u\nM : Type v₁\nN : Type v₂\nP : Type v₃\nQ : Type v₄\ninst✝¹² : CommRing R\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : AddCommGroup N\ninst✝⁹ : AddCommGroup P\ninst✝⁸ : AddCommGroup Q\ninst✝⁷ : Module R M\ninst✝⁶ : Module R N\ninst✝⁵ : Module R P\ninst✝⁴ : Module R Q\ninst✝³ : Module.Free R M\ninst✝² : Module.Finite R M\ninst✝¹ : Module.Free R N\ninst✝ : Module.Finite R N\nx : TensorProduct R (LinearMap (RingHom.id R) M P) (LinearMap (RingHom.id R) N Q)\n⊢ Eq ((homTensorHomEquiv R M N P Q) x) ((TensorProduct.homTensorHomMap R M N P Q) x)","decl":"@[simp]\ntheorem homTensorHomEquiv_apply (x : (M →ₗ[R] P) ⊗[R] (N →ₗ[R] Q)) :\n    homTensorHomEquiv R M N P Q x = homTensorHomMap R M N P Q x := by\n  rw [← LinearEquiv.coe_toLinearMap, homTensorHomEquiv_toLinearMap]\n\n"}
