{"name":"Finset.Nat.prod_antidiagonal_succ","module":"Mathlib.Algebra.BigOperators.NatAntidiagonal","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nn : Nat\nf : Prod Nat Nat → M\n⊢ Eq ((Finset.HasAntidiagonal.antidiagonal (HAdd.hAdd n 1)).prod fun p => f p) (HMul.hMul (f { fst := 0, snd := HAdd.hAdd n 1 }) ((Finset.HasAntidiagonal.antidiagonal n).prod fun p => f { fst := HAdd.hAdd p.1 1, snd := p.2 }))","decl":"theorem prod_antidiagonal_succ {n : ℕ} {f : ℕ × ℕ → M} :\n    (∏ p ∈ antidiagonal (n + 1), f p)\n      = f (0, n + 1) * ∏ p ∈ antidiagonal n, f (p.1 + 1, p.2) := by\n  rw [antidiagonal_succ, prod_cons, prod_map]; rfl\n\n"}
{"name":"Finset.Nat.sum_antidiagonal_succ","module":"Mathlib.Algebra.BigOperators.NatAntidiagonal","initialProofState":"N : Type u_2\ninst✝ : AddCommMonoid N\nn : Nat\nf : Prod Nat Nat → N\n⊢ Eq ((Finset.HasAntidiagonal.antidiagonal (HAdd.hAdd n 1)).sum fun p => f p) (HAdd.hAdd (f { fst := 0, snd := HAdd.hAdd n 1 }) ((Finset.HasAntidiagonal.antidiagonal n).sum fun p => f { fst := HAdd.hAdd p.1 1, snd := p.2 }))","decl":"theorem sum_antidiagonal_succ {n : ℕ} {f : ℕ × ℕ → N} :\n    (∑ p ∈ antidiagonal (n + 1), f p) = f (0, n + 1) + ∑ p ∈ antidiagonal n, f (p.1 + 1, p.2) :=\n  @prod_antidiagonal_succ (Multiplicative N) _ _ _\n\n"}
{"name":"Finset.Nat.prod_antidiagonal_swap","module":"Mathlib.Algebra.BigOperators.NatAntidiagonal","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nn : Nat\nf : Prod Nat Nat → M\n⊢ Eq ((Finset.HasAntidiagonal.antidiagonal n).prod fun p => f p.swap) ((Finset.HasAntidiagonal.antidiagonal n).prod fun p => f p)","decl":"@[to_additive]\ntheorem prod_antidiagonal_swap {n : ℕ} {f : ℕ × ℕ → M} :\n    ∏ p ∈ antidiagonal n, f p.swap = ∏ p ∈ antidiagonal n, f p := by\n  conv_lhs => rw [← map_swap_antidiagonal, Finset.prod_map]\n  rfl\n\n"}
{"name":"Finset.Nat.sum_antidiagonal_swap","module":"Mathlib.Algebra.BigOperators.NatAntidiagonal","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nn : Nat\nf : Prod Nat Nat → M\n⊢ Eq ((Finset.HasAntidiagonal.antidiagonal n).sum fun p => f p.swap) ((Finset.HasAntidiagonal.antidiagonal n).sum fun p => f p)","decl":"@[to_additive]\ntheorem prod_antidiagonal_swap {n : ℕ} {f : ℕ × ℕ → M} :\n    ∏ p ∈ antidiagonal n, f p.swap = ∏ p ∈ antidiagonal n, f p := by\n  conv_lhs => rw [← map_swap_antidiagonal, Finset.prod_map]\n  rfl\n\n"}
{"name":"Finset.Nat.prod_antidiagonal_succ'","module":"Mathlib.Algebra.BigOperators.NatAntidiagonal","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nn : Nat\nf : Prod Nat Nat → M\n⊢ Eq ((Finset.HasAntidiagonal.antidiagonal (HAdd.hAdd n 1)).prod fun p => f p) (HMul.hMul (f { fst := HAdd.hAdd n 1, snd := 0 }) ((Finset.HasAntidiagonal.antidiagonal n).prod fun p => f { fst := p.1, snd := HAdd.hAdd p.2 1 }))","decl":"theorem prod_antidiagonal_succ' {n : ℕ} {f : ℕ × ℕ → M} : (∏ p ∈ antidiagonal (n + 1), f p) =\n    f (n + 1, 0) * ∏ p ∈ antidiagonal n, f (p.1, p.2 + 1) := by\n  rw [← prod_antidiagonal_swap, prod_antidiagonal_succ, ← prod_antidiagonal_swap]\n  rfl\n\n"}
{"name":"Finset.Nat.sum_antidiagonal_succ'","module":"Mathlib.Algebra.BigOperators.NatAntidiagonal","initialProofState":"N : Type u_2\ninst✝ : AddCommMonoid N\nn : Nat\nf : Prod Nat Nat → N\n⊢ Eq ((Finset.HasAntidiagonal.antidiagonal (HAdd.hAdd n 1)).sum fun p => f p) (HAdd.hAdd (f { fst := HAdd.hAdd n 1, snd := 0 }) ((Finset.HasAntidiagonal.antidiagonal n).sum fun p => f { fst := p.1, snd := HAdd.hAdd p.2 1 }))","decl":"theorem sum_antidiagonal_succ' {n : ℕ} {f : ℕ × ℕ → N} :\n    (∑ p ∈ antidiagonal (n + 1), f p) = f (n + 1, 0) + ∑ p ∈ antidiagonal n, f (p.1, p.2 + 1) :=\n  @prod_antidiagonal_succ' (Multiplicative N) _ _ _\n\n"}
{"name":"Finset.Nat.prod_antidiagonal_subst","module":"Mathlib.Algebra.BigOperators.NatAntidiagonal","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nn : Nat\nf : Prod Nat Nat → Nat → M\n⊢ Eq ((Finset.HasAntidiagonal.antidiagonal n).prod fun p => f p n) ((Finset.HasAntidiagonal.antidiagonal n).prod fun p => f p (HAdd.hAdd p.1 p.2))","decl":"@[to_additive]\ntheorem prod_antidiagonal_subst {n : ℕ} {f : ℕ × ℕ → ℕ → M} :\n    ∏ p ∈ antidiagonal n, f p n = ∏ p ∈ antidiagonal n, f p (p.1 + p.2) :=\n  prod_congr rfl fun p hp ↦ by rw [mem_antidiagonal.mp hp]\n\n"}
{"name":"Finset.Nat.sum_antidiagonal_subst","module":"Mathlib.Algebra.BigOperators.NatAntidiagonal","initialProofState":"M : Type u_1\ninst✝ : AddCommMonoid M\nn : Nat\nf : Prod Nat Nat → Nat → M\n⊢ Eq ((Finset.HasAntidiagonal.antidiagonal n).sum fun p => f p n) ((Finset.HasAntidiagonal.antidiagonal n).sum fun p => f p (HAdd.hAdd p.1 p.2))","decl":"@[to_additive]\ntheorem prod_antidiagonal_subst {n : ℕ} {f : ℕ × ℕ → ℕ → M} :\n    ∏ p ∈ antidiagonal n, f p n = ∏ p ∈ antidiagonal n, f p (p.1 + p.2) :=\n  prod_congr rfl fun p hp ↦ by rw [mem_antidiagonal.mp hp]\n\n"}
{"name":"Finset.Nat.prod_antidiagonal_eq_prod_range_succ_mk","module":"Mathlib.Algebra.BigOperators.NatAntidiagonal","initialProofState":"M : Type u_3\ninst✝ : CommMonoid M\nf : Prod Nat Nat → M\nn : Nat\n⊢ Eq ((Finset.HasAntidiagonal.antidiagonal n).prod fun ij => f ij) ((Finset.range n.succ).prod fun k => f { fst := k, snd := HSub.hSub n k })","decl":"@[to_additive]\ntheorem prod_antidiagonal_eq_prod_range_succ_mk {M : Type*} [CommMonoid M] (f : ℕ × ℕ → M)\n    (n : ℕ) : ∏ ij ∈ antidiagonal n, f ij = ∏ k ∈ range n.succ, f (k, n - k) :=\n  Finset.prod_map (range n.succ) ⟨fun i ↦ (i, n - i), fun _ _ h ↦ (Prod.mk.inj h).1⟩ f\n\n"}
{"name":"Finset.Nat.sum_antidiagonal_eq_sum_range_succ_mk","module":"Mathlib.Algebra.BigOperators.NatAntidiagonal","initialProofState":"M : Type u_3\ninst✝ : AddCommMonoid M\nf : Prod Nat Nat → M\nn : Nat\n⊢ Eq ((Finset.HasAntidiagonal.antidiagonal n).sum fun ij => f ij) ((Finset.range n.succ).sum fun k => f { fst := k, snd := HSub.hSub n k })","decl":"@[to_additive]\ntheorem prod_antidiagonal_eq_prod_range_succ_mk {M : Type*} [CommMonoid M] (f : ℕ × ℕ → M)\n    (n : ℕ) : ∏ ij ∈ antidiagonal n, f ij = ∏ k ∈ range n.succ, f (k, n - k) :=\n  Finset.prod_map (range n.succ) ⟨fun i ↦ (i, n - i), fun _ _ h ↦ (Prod.mk.inj h).1⟩ f\n\n"}
{"name":"Finset.Nat.sum_antidiagonal_eq_sum_range_succ","module":"Mathlib.Algebra.BigOperators.NatAntidiagonal","initialProofState":"M : Type u_3\ninst✝ : AddCommMonoid M\nf : Nat → Nat → M\nn : Nat\n⊢ Eq ((Finset.HasAntidiagonal.antidiagonal n).sum fun ij => f ij.1 ij.2) ((Finset.range n.succ).sum fun k => f k (HSub.hSub n k))","decl":"/-- This lemma matches more generally than `Finset.Nat.prod_antidiagonal_eq_prod_range_succ_mk` when\nusing `rw ← `. -/\n@[to_additive \"This lemma matches more generally than\n`Finset.Nat.sum_antidiagonal_eq_sum_range_succ_mk` when using `rw ← `.\"]\ntheorem prod_antidiagonal_eq_prod_range_succ {M : Type*} [CommMonoid M] (f : ℕ → ℕ → M) (n : ℕ) :\n    ∏ ij ∈ antidiagonal n, f ij.1 ij.2 = ∏ k ∈ range n.succ, f k (n - k) :=\n  prod_antidiagonal_eq_prod_range_succ_mk _ _\n"}
{"name":"Finset.Nat.prod_antidiagonal_eq_prod_range_succ","module":"Mathlib.Algebra.BigOperators.NatAntidiagonal","initialProofState":"M : Type u_3\ninst✝ : CommMonoid M\nf : Nat → Nat → M\nn : Nat\n⊢ Eq ((Finset.HasAntidiagonal.antidiagonal n).prod fun ij => f ij.1 ij.2) ((Finset.range n.succ).prod fun k => f k (HSub.hSub n k))","decl":"/-- This lemma matches more generally than `Finset.Nat.prod_antidiagonal_eq_prod_range_succ_mk` when\nusing `rw ← `. -/\n@[to_additive \"This lemma matches more generally than\n`Finset.Nat.sum_antidiagonal_eq_sum_range_succ_mk` when using `rw ← `.\"]\ntheorem prod_antidiagonal_eq_prod_range_succ {M : Type*} [CommMonoid M] (f : ℕ → ℕ → M) (n : ℕ) :\n    ∏ ij ∈ antidiagonal n, f ij.1 ij.2 = ∏ k ∈ range n.succ, f k (n - k) :=\n  prod_antidiagonal_eq_prod_range_succ_mk _ _\n"}
