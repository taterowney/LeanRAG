{"name":"CategoryTheory.Localization.Construction.LocQuiver.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬≤ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\ninst‚úù¬π : SizeOf C\ninst‚úù : ‚¶ÉX Y : C‚¶Ñ ‚Üí (x : Quiver.Hom X Y) ‚Üí SizeOf (W x)\nobj : C\n‚ä¢ Eq (SizeOf.sizeOf { obj := obj }) (HAdd.hAdd 1 (SizeOf.sizeOf obj))","decl":"/-- If `W : MorphismProperty C`, `LocQuiver W` is a quiver with the same objects\nas `C`, and whose morphisms are those in `C` and placeholders for formal\ninverses of the morphisms in `W`. -/\nstructure LocQuiver (W : MorphismProperty C) where\n  /-- underlying object -/\n  obj : C\n\n"}
{"name":"CategoryTheory.Localization.Construction.LocQuiver.mk.injEq","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nobj‚úù obj : C\n‚ä¢ Eq (Eq { obj := obj‚úù } { obj := obj }) (Eq obj‚úù obj)","decl":"/-- If `W : MorphismProperty C`, `LocQuiver W` is a quiver with the same objects\nas `C`, and whose morphisms are those in `C` and placeholders for formal\ninverses of the morphisms in `W`. -/\nstructure LocQuiver (W : MorphismProperty C) where\n  /-- underlying object -/\n  obj : C\n\n"}
{"name":"CategoryTheory.Localization.Construction.LocQuiver.mk.inj","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nobj‚úù obj : C\nx‚úù : Eq { obj := obj‚úù } { obj := obj }\n‚ä¢ Eq obj‚úù obj","decl":"/-- If `W : MorphismProperty C`, `LocQuiver W` is a quiver with the same objects\nas `C`, and whose morphisms are those in `C` and placeholders for formal\ninverses of the morphisms in `W`. -/\nstructure LocQuiver (W : MorphismProperty C) where\n  /-- underlying object -/\n  obj : C\n\n"}
{"name":"CategoryTheory.MorphismProperty.Q_inverts","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\n‚ä¢ W.IsInvertedBy W.Q","decl":"theorem _root_.CategoryTheory.MorphismProperty.Q_inverts : W.IsInvertedBy W.Q := fun _ _ w hw =>\n  (Localization.Construction.wIso w hw).isIso_hom\n\n"}
{"name":"CategoryTheory.Localization.Construction.liftToPathCategory_map","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst‚úù : CategoryTheory.Category.{uD', uD} D\nG : CategoryTheory.Functor C D\nhG : W.IsInvertedBy G\nX‚úù Y‚úù : CategoryTheory.Paths (CategoryTheory.Localization.Construction.LocQuiver W)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Localization.Construction.liftToPathCategory G hG).map f) (CategoryTheory.composePath ({ obj := fun X => G.obj X.obj, map := fun {X Y} a => Sum.rec (fun val => G.map val) (fun val => CategoryTheory.inv (G.map ‚Üëval)) a }.mapPath f))","decl":"/-- The lifting of a functor to the path category of `LocQuiver W` -/\n@[simps!]\ndef liftToPathCategory : Paths (LocQuiver W) ‚•§ D :=\n  Quiv.lift\n    { obj := fun X => G.obj X.obj\n      map := by\n        intros X Y\n        rintro (f | ‚ü®g, hg‚ü©)\n        ¬∑ exact G.map f\n        ¬∑ haveI := hG g hg\n          exact inv (G.map g) }\n\n"}
{"name":"CategoryTheory.Localization.Construction.liftToPathCategory_obj","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst‚úù : CategoryTheory.Category.{uD', uD} D\nG : CategoryTheory.Functor C D\nhG : W.IsInvertedBy G\nX : CategoryTheory.Paths (CategoryTheory.Localization.Construction.LocQuiver W)\n‚ä¢ Eq ((CategoryTheory.Localization.Construction.liftToPathCategory G hG).obj X) (G.obj X.obj)","decl":"/-- The lifting of a functor to the path category of `LocQuiver W` -/\n@[simps!]\ndef liftToPathCategory : Paths (LocQuiver W) ‚•§ D :=\n  Quiv.lift\n    { obj := fun X => G.obj X.obj\n      map := by\n        intros X Y\n        rintro (f | ‚ü®g, hg‚ü©)\n        ¬∑ exact G.map f\n        ¬∑ haveI := hG g hg\n          exact inv (G.map g) }\n\n"}
{"name":"CategoryTheory.Localization.Construction.lift_obj","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst‚úù : CategoryTheory.Category.{uD', uD} D\nG : CategoryTheory.Functor C D\nhG : W.IsInvertedBy G\na : CategoryTheory.Quotient (CategoryTheory.Localization.Construction.relations W)\n‚ä¢ Eq ((CategoryTheory.Localization.Construction.lift G hG).obj a) (G.obj a.as.obj)","decl":"/-- The lifting of a functor `C ‚•§ D` inverting `W` as a functor `W.Localization ‚•§ D` -/\n@[simps!]\ndef lift : W.Localization ‚•§ D :=\n  Quotient.lift (relations W) (liftToPathCategory G hG)\n    (by\n      rintro ‚ü®X‚ü© ‚ü®Y‚ü© f‚ÇÅ f‚ÇÇ r\n      -- Porting note: rest of proof was `rcases r with ‚ü®‚ü©; tidy`\n      rcases r with (_|_|‚ü®f,hf‚ü©|‚ü®f,hf‚ü©)\n      ¬∑ aesop_cat\n      ¬∑ simp\n      all_goals\n        dsimp\n        haveI := hG f hf\n        simp\n        rfl)\n\n"}
{"name":"CategoryTheory.Localization.Construction.lift_map","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst‚úù : CategoryTheory.Category.{uD', uD} D\nG : CategoryTheory.Functor C D\nhG : W.IsInvertedBy G\na b : CategoryTheory.Quotient (CategoryTheory.Localization.Construction.relations W)\nhf : Quiver.Hom a b\n‚ä¢ Eq ((CategoryTheory.Localization.Construction.lift G hG).map hf) (Quot.liftOn hf (fun f => CategoryTheory.composePath ({ obj := fun X => G.obj X.obj, map := fun {X Y} a => Sum.rec (fun val => G.map val) (fun val => CategoryTheory.inv (G.map ‚Üëval)) a }.mapPath f)) ‚ãØ)","decl":"/-- The lifting of a functor `C ‚•§ D` inverting `W` as a functor `W.Localization ‚•§ D` -/\n@[simps!]\ndef lift : W.Localization ‚•§ D :=\n  Quotient.lift (relations W) (liftToPathCategory G hG)\n    (by\n      rintro ‚ü®X‚ü© ‚ü®Y‚ü© f‚ÇÅ f‚ÇÇ r\n      -- Porting note: rest of proof was `rcases r with ‚ü®‚ü©; tidy`\n      rcases r with (_|_|‚ü®f,hf‚ü©|‚ü®f,hf‚ü©)\n      ¬∑ aesop_cat\n      ¬∑ simp\n      all_goals\n        dsimp\n        haveI := hG f hf\n        simp\n        rfl)\n\n"}
{"name":"CategoryTheory.Localization.Construction.fac","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst‚úù : CategoryTheory.Category.{uD', uD} D\nG : CategoryTheory.Functor C D\nhG : W.IsInvertedBy G\n‚ä¢ Eq (W.Q.comp (CategoryTheory.Localization.Construction.lift G hG)) G","decl":"@[simp]\ntheorem fac : W.Q ‚ãô lift G hG = G :=\n  Functor.ext (fun _ => rfl)\n    (by\n      intro X Y f\n      simp only [Functor.comp_map, eqToHom_refl, comp_id, id_comp]\n      dsimp [MorphismProperty.Q, Quot.liftOn, Quotient.functor]\n      rw [composePath_toPath])\n\n"}
{"name":"CategoryTheory.Localization.Construction.uniq","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst‚úù : CategoryTheory.Category.{uD', uD} D\nG‚ÇÅ G‚ÇÇ : CategoryTheory.Functor W.Localization D\nh : Eq (W.Q.comp G‚ÇÅ) (W.Q.comp G‚ÇÇ)\n‚ä¢ Eq G‚ÇÅ G‚ÇÇ","decl":"theorem uniq (G‚ÇÅ G‚ÇÇ : W.Localization ‚•§ D) (h : W.Q ‚ãô G‚ÇÅ = W.Q ‚ãô G‚ÇÇ) : G‚ÇÅ = G‚ÇÇ := by\n  suffices h' : Quotient.functor _ ‚ãô G‚ÇÅ = Quotient.functor _ ‚ãô G‚ÇÇ by\n    refine Functor.ext ?_ ?_\n    ¬∑ rintro ‚ü®‚ü®X‚ü©‚ü©\n      apply Functor.congr_obj h\n    ¬∑ rintro ‚ü®‚ü®X‚ü©‚ü© ‚ü®‚ü®Y‚ü©‚ü© ‚ü®f‚ü©\n      apply Functor.congr_hom h'\n  refine Paths.ext_functor ?_ ?_\n  ¬∑ ext X\n    cases X\n    apply Functor.congr_obj h\n  ¬∑ rintro ‚ü®X‚ü© ‚ü®Y‚ü© (f | ‚ü®w, hw‚ü©)\n    ¬∑ simpa only using Functor.congr_hom h f\n    ¬∑ have hw : W.Q.map w = (wIso w hw).hom := rfl\n      have hw' := Functor.congr_hom h w\n      simp only [Functor.comp_map, hw] at hw'\n      refine Functor.congr_inv_of_congr_hom _ _ _ ?_ ?_ hw'\n      all_goals apply Functor.congr_obj h\n\n"}
{"name":"CategoryTheory.Localization.Construction.objEquiv_apply","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\na‚úù : C\n‚ä¢ Eq ((CategoryTheory.Localization.Construction.objEquiv W) a‚úù) (W.Q.obj a‚úù)","decl":"/-- The canonical bijection between objects in a category and its\nlocalization with respect to a morphism_property `W` -/\n@[simps]\ndef objEquiv : C ‚âÉ W.Localization where\n  toFun := W.Q.obj\n  invFun X := X.as.obj\n  left_inv _ := rfl\n  right_inv := by\n    rintro ‚ü®‚ü®X‚ü©‚ü©\n    rfl\n\n"}
{"name":"CategoryTheory.Localization.Construction.objEquiv_symm_apply","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nX : W.Localization\n‚ä¢ Eq ((CategoryTheory.Localization.Construction.objEquiv W).symm X) X.as.obj","decl":"/-- The canonical bijection between objects in a category and its\nlocalization with respect to a morphism_property `W` -/\n@[simps]\ndef objEquiv : C ‚âÉ W.Localization where\n  toFun := W.Q.obj\n  invFun X := X.as.obj\n  left_inv _ := rfl\n  right_inv := by\n    rintro ‚ü®‚ü®X‚ü©‚ü©\n    rfl\n\n"}
{"name":"CategoryTheory.Localization.Construction.morphismProperty_is_top","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nP : CategoryTheory.MorphismProperty W.Localization\ninst‚úù : P.IsStableUnderComposition\nhP‚ÇÅ : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : Quiver.Hom X Y), P (W.Q.map f)\nhP‚ÇÇ : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (w : Quiver.Hom X Y) (hw : W w), P (CategoryTheory.Localization.Construction.wInv w hw)\n‚ä¢ Eq P Top.top","decl":"/-- A `MorphismProperty` in `W.Localization` is satisfied by all\nmorphisms in the localized category if it contains the image of the\nmorphisms in the original category, the inverses of the morphisms\nin `W` and if it is stable under composition -/\ntheorem morphismProperty_is_top (P : MorphismProperty W.Localization)\n    [P.IsStableUnderComposition] (hP‚ÇÅ : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : X ‚ü∂ Y), P (W.Q.map f))\n    (hP‚ÇÇ : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (w : X ‚ü∂ Y) (hw : W w), P (wInv w hw)) :\n    P = ‚ä§ := by\n  funext X Y f\n  ext\n  constructor\n  ¬∑ intro\n    apply MorphismProperty.top_apply\n  ¬∑ intro\n    let G : _ ‚•§ W.Localization := Quotient.functor _\n    haveI : G.Full := Quotient.full_functor _\n    suffices ‚àÄ (X‚ÇÅ X‚ÇÇ : Paths (LocQuiver W)) (f : X‚ÇÅ ‚ü∂ X‚ÇÇ), P (G.map f) by\n      rcases X with ‚ü®‚ü®X‚ü©‚ü©\n      rcases Y with ‚ü®‚ü®Y‚ü©‚ü©\n      simpa only [Functor.map_preimage] using this _ _ (G.preimage f)\n    intros X‚ÇÅ X‚ÇÇ p\n    induction' p with X‚ÇÇ X‚ÇÉ p g hp\n    ¬∑ simpa only [Functor.map_id] using hP‚ÇÅ (ùüô X‚ÇÅ.obj)\n    ¬∑ let p' : X‚ÇÅ ‚ü∂X‚ÇÇ := p\n      rw [show p'.cons g = p' ‚â´ Quiver.Hom.toPath g by rfl, G.map_comp]\n      refine P.comp_mem _ _ hp ?_\n      rcases g with (g | ‚ü®g, hg‚ü©)\n      ¬∑ apply hP‚ÇÅ\n      ¬∑ apply hP‚ÇÇ\n\n"}
{"name":"CategoryTheory.Localization.Construction.morphismProperty_is_top'","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nP : CategoryTheory.MorphismProperty W.Localization\ninst‚úù : P.IsStableUnderComposition\nhP‚ÇÅ : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : Quiver.Hom X Y), P (W.Q.map f)\nhP‚ÇÇ : ‚àÄ ‚¶ÉX Y : W.Localization‚¶Ñ (e : CategoryTheory.Iso X Y), P e.hom ‚Üí P e.inv\n‚ä¢ Eq P Top.top","decl":"/-- A `MorphismProperty` in `W.Localization` is satisfied by all\nmorphisms in the localized category if it contains the image of the\nmorphisms in the original category, if is stable under composition\nand if the property is stable by passing to inverses. -/\ntheorem morphismProperty_is_top' (P : MorphismProperty W.Localization)\n    [P.IsStableUnderComposition] (hP‚ÇÅ : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : X ‚ü∂ Y), P (W.Q.map f))\n    (hP‚ÇÇ : ‚àÄ ‚¶ÉX Y : W.Localization‚¶Ñ (e : X ‚âÖ Y) (_ : P e.hom), P e.inv) : P = ‚ä§ :=\n  morphismProperty_is_top P hP‚ÇÅ (fun _ _ w _ => hP‚ÇÇ _ (hP‚ÇÅ w))\n\n"}
{"name":"CategoryTheory.Localization.Construction.NatTransExtension.app_eq","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst‚úù : CategoryTheory.Category.{uD', uD} D\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor W.Localization D\nœÑ : Quiver.Hom (W.Q.comp F‚ÇÅ) (W.Q.comp F‚ÇÇ)\nX : C\n‚ä¢ Eq (CategoryTheory.Localization.Construction.NatTransExtension.app œÑ (W.Q.obj X)) (œÑ.app X)","decl":"@[simp]\ntheorem app_eq (X : C) : (app œÑ) (W.Q.obj X) = œÑ.app X := by\n  simp only [app, eqToHom_refl, comp_id, id_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.Localization.Construction.natTransExtension_app","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst‚úù : CategoryTheory.Category.{uD', uD} D\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor W.Localization D\nœÑ : Quiver.Hom (W.Q.comp F‚ÇÅ) (W.Q.comp F‚ÇÇ)\nX : W.Localization\n‚ä¢ Eq ((CategoryTheory.Localization.Construction.natTransExtension œÑ).app X) (CategoryTheory.Localization.Construction.NatTransExtension.app œÑ X)","decl":"/-- If `F‚ÇÅ` and `F‚ÇÇ` are functors `W.Localization ‚•§ D`, a natural transformation `F‚ÇÅ ‚ü∂ F‚ÇÇ`\ncan be obtained from a natural transformation `W.Q ‚ãô F‚ÇÅ ‚ü∂ W.Q ‚ãô F‚ÇÇ`. -/\n@[simps]\ndef natTransExtension {F‚ÇÅ F‚ÇÇ : W.Localization ‚•§ D} (œÑ : W.Q ‚ãô F‚ÇÅ ‚ü∂ W.Q ‚ãô F‚ÇÇ) : F‚ÇÅ ‚ü∂ F‚ÇÇ where\n  app := NatTransExtension.app œÑ\n  naturality := by\n    suffices MorphismProperty.naturalityProperty (NatTransExtension.app œÑ) = ‚ä§ by\n      intro X Y f\n      simpa only [‚Üê this] using MorphismProperty.top_apply f\n    refine morphismProperty_is_top'\n      (MorphismProperty.naturalityProperty (NatTransExtension.app œÑ))\n      ?_ (MorphismProperty.naturalityProperty.stableUnderInverse _)\n    intros X Y f\n    dsimp\n    simpa only [NatTransExtension.app_eq] using œÑ.naturality f\n\n"}
{"name":"CategoryTheory.Localization.Construction.natTransExtension_hcomp","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst‚úù : CategoryTheory.Category.{uD', uD} D\nF G : CategoryTheory.Functor W.Localization D\nœÑ : Quiver.Hom (W.Q.comp F) (W.Q.comp G)\n‚ä¢ Eq (CategoryTheory.NatTrans.hcomp (CategoryTheory.CategoryStruct.id W.Q) (CategoryTheory.Localization.Construction.natTransExtension œÑ)) œÑ","decl":"@[simp]\ntheorem natTransExtension_hcomp {F G : W.Localization ‚•§ D} (œÑ : W.Q ‚ãô F ‚ü∂ W.Q ‚ãô G) :\n    ùüô W.Q ‚ó´ natTransExtension œÑ = œÑ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Localization.Construction.natTrans_hcomp_injective","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst‚úù : CategoryTheory.Category.{uD', uD} D\nF G : CategoryTheory.Functor W.Localization D\nœÑ‚ÇÅ œÑ‚ÇÇ : Quiver.Hom F G\nh : Eq (CategoryTheory.NatTrans.hcomp (CategoryTheory.CategoryStruct.id W.Q) œÑ‚ÇÅ) (CategoryTheory.NatTrans.hcomp (CategoryTheory.CategoryStruct.id W.Q) œÑ‚ÇÇ)\n‚ä¢ Eq œÑ‚ÇÅ œÑ‚ÇÇ","decl":"theorem natTrans_hcomp_injective {F G : W.Localization ‚•§ D} {œÑ‚ÇÅ œÑ‚ÇÇ : F ‚ü∂ G}\n    (h : ùüô W.Q ‚ó´ œÑ‚ÇÅ = ùüô W.Q ‚ó´ œÑ‚ÇÇ) : œÑ‚ÇÅ = œÑ‚ÇÇ := by\n  ext X\n  have eq := (objEquiv W).right_inv X\n  simp only [objEquiv] at eq\n  rw [‚Üê eq, ‚Üê NatTrans.id_hcomp_app, ‚Üê NatTrans.id_hcomp_app, h]\n\n"}
{"name":"CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.functor_obj_obj_map","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst‚úù : CategoryTheory.Category.{uD', uD} D\nX : CategoryTheory.Functor W.Localization D\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.functor W D).obj X).obj.map f) (X.map (W.Q.map f))","decl":"/-- The functor `(W.Localization ‚•§ D) ‚•§ (W.FunctorsInverting D)` induced by the\ncomposition with `W.Q : C ‚•§ W.Localization`. -/\n@[simps!]\ndef functor : (W.Localization ‚•§ D) ‚•§ W.FunctorsInverting D :=\n  FullSubcategory.lift _ ((whiskeringLeft _ _ D).obj W.Q) fun _ =>\n    MorphismProperty.IsInvertedBy.of_comp W W.Q W.Q_inverts _\n\n"}
{"name":"CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.functor_obj_obj_obj","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst‚úù : CategoryTheory.Category.{uD', uD} D\nX‚úù : CategoryTheory.Functor W.Localization D\nX : C\n‚ä¢ Eq (((CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.functor W D).obj X‚úù).obj.obj X) (X‚úù.obj (W.Q.obj X))","decl":"/-- The functor `(W.Localization ‚•§ D) ‚•§ (W.FunctorsInverting D)` induced by the\ncomposition with `W.Q : C ‚•§ W.Localization`. -/\n@[simps!]\ndef functor : (W.Localization ‚•§ D) ‚•§ W.FunctorsInverting D :=\n  FullSubcategory.lift _ ((whiskeringLeft _ _ D).obj W.Q) fun _ =>\n    MorphismProperty.IsInvertedBy.of_comp W W.Q W.Q_inverts _\n\n"}
{"name":"CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.functor_map_app","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst‚úù : CategoryTheory.Category.{uD', uD} D\nX‚úù Y‚úù : CategoryTheory.Functor W.Localization D\nf : Quiver.Hom X‚úù Y‚úù\nX : C\n‚ä¢ Eq (((CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.functor W D).map f).app X) (f.app (W.Q.obj X))","decl":"/-- The functor `(W.Localization ‚•§ D) ‚•§ (W.FunctorsInverting D)` induced by the\ncomposition with `W.Q : C ‚•§ W.Localization`. -/\n@[simps!]\ndef functor : (W.Localization ‚•§ D) ‚•§ W.FunctorsInverting D :=\n  FullSubcategory.lift _ ((whiskeringLeft _ _ D).obj W.Q) fun _ =>\n    MorphismProperty.IsInvertedBy.of_comp W W.Q W.Q_inverts _\n\n"}
{"name":"CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.inverse_obj_map","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst‚úù : CategoryTheory.Category.{uD', uD} D\nG : W.FunctorsInverting D\na b : CategoryTheory.Quotient (CategoryTheory.Localization.Construction.relations W)\nhf : Quiver.Hom a b\n‚ä¢ Eq (((CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.inverse W D).obj G).map hf) (Quot.liftOn hf (fun f => CategoryTheory.composePath ({ obj := fun X => G.obj.obj X.obj, map := fun {X Y} a => Sum.rec (fun val => G.obj.map val) (fun val => CategoryTheory.inv (G.obj.map ‚Üëval)) a }.mapPath f)) ‚ãØ)","decl":"/-- The function `(W.FunctorsInverting D) ‚•§ (W.Localization ‚•§ D)` induced by\n`Construction.lift`. -/\n@[simps!]\ndef inverse : W.FunctorsInverting D ‚•§ W.Localization ‚•§ D where\n  obj G := lift G.obj G.property\n  map œÑ := natTransExtension (eqToHom (by rw [fac]) ‚â´ œÑ ‚â´ eqToHom (by rw [fac]))\n  map_id G :=\n    natTrans_hcomp_injective\n      (by\n        rw [natTransExtension_hcomp]\n        ext X\n        simp only [NatTrans.comp_app, eqToHom_app, eqToHom_refl, comp_id, id_comp,\n          NatTrans.hcomp_id_app, NatTrans.id_app, Functor.map_id]\n        rfl)\n  map_comp œÑ‚ÇÅ œÑ‚ÇÇ :=\n    natTrans_hcomp_injective\n      (by\n        ext X\n        simp only [natTransExtension_hcomp, NatTrans.comp_app, eqToHom_app, eqToHom_refl,\n          id_comp, comp_id, NatTrans.hcomp_app, NatTrans.id_app, Functor.map_id,\n          natTransExtension_app, NatTransExtension.app_eq]\n        rfl)\n\n"}
{"name":"CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.inverse_obj_obj","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst‚úù : CategoryTheory.Category.{uD', uD} D\nG : W.FunctorsInverting D\na : CategoryTheory.Quotient (CategoryTheory.Localization.Construction.relations W)\n‚ä¢ Eq (((CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.inverse W D).obj G).obj a) (G.obj.obj a.as.obj)","decl":"/-- The function `(W.FunctorsInverting D) ‚•§ (W.Localization ‚•§ D)` induced by\n`Construction.lift`. -/\n@[simps!]\ndef inverse : W.FunctorsInverting D ‚•§ W.Localization ‚•§ D where\n  obj G := lift G.obj G.property\n  map œÑ := natTransExtension (eqToHom (by rw [fac]) ‚â´ œÑ ‚â´ eqToHom (by rw [fac]))\n  map_id G :=\n    natTrans_hcomp_injective\n      (by\n        rw [natTransExtension_hcomp]\n        ext X\n        simp only [NatTrans.comp_app, eqToHom_app, eqToHom_refl, comp_id, id_comp,\n          NatTrans.hcomp_id_app, NatTrans.id_app, Functor.map_id]\n        rfl)\n  map_comp œÑ‚ÇÅ œÑ‚ÇÇ :=\n    natTrans_hcomp_injective\n      (by\n        ext X\n        simp only [natTransExtension_hcomp, NatTrans.comp_app, eqToHom_app, eqToHom_refl,\n          id_comp, comp_id, NatTrans.hcomp_app, NatTrans.id_app, Functor.map_id,\n          natTransExtension_app, NatTransExtension.app_eq]\n        rfl)\n\n"}
{"name":"CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.inverse_map_app","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst‚úù : CategoryTheory.Category.{uD', uD} D\nX‚úù Y‚úù : W.FunctorsInverting D\nœÑ : Quiver.Hom X‚úù Y‚úù\nX : W.Localization\n‚ä¢ Eq (((CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.inverse W D).map œÑ).app X) (CategoryTheory.Localization.Construction.NatTransExtension.app (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp œÑ (CategoryTheory.eqToHom ‚ãØ))) X)","decl":"/-- The function `(W.FunctorsInverting D) ‚•§ (W.Localization ‚•§ D)` induced by\n`Construction.lift`. -/\n@[simps!]\ndef inverse : W.FunctorsInverting D ‚•§ W.Localization ‚•§ D where\n  obj G := lift G.obj G.property\n  map œÑ := natTransExtension (eqToHom (by rw [fac]) ‚â´ œÑ ‚â´ eqToHom (by rw [fac]))\n  map_id G :=\n    natTrans_hcomp_injective\n      (by\n        rw [natTransExtension_hcomp]\n        ext X\n        simp only [NatTrans.comp_app, eqToHom_app, eqToHom_refl, comp_id, id_comp,\n          NatTrans.hcomp_id_app, NatTrans.id_app, Functor.map_id]\n        rfl)\n  map_comp œÑ‚ÇÅ œÑ‚ÇÇ :=\n    natTrans_hcomp_injective\n      (by\n        ext X\n        simp only [natTransExtension_hcomp, NatTrans.comp_app, eqToHom_app, eqToHom_refl,\n          id_comp, comp_id, NatTrans.hcomp_app, NatTrans.id_app, Functor.map_id,\n          natTransExtension_app, NatTransExtension.app_eq]\n        rfl)\n\n"}
{"name":"CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.unitIso_hom","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst‚úù : CategoryTheory.Category.{uD', uD} D\n‚ä¢ Eq (CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.unitIso W D).hom (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- The unit isomorphism of the equivalence of categories `whiskeringLeftEquivalence W D`. -/\n@[simps!]\ndef unitIso : ùü≠ (W.Localization ‚•§ D) ‚âÖ functor W D ‚ãô inverse W D :=\n  eqToIso\n    (by\n      refine Functor.ext (fun G => ?_) fun G‚ÇÅ G‚ÇÇ œÑ => ?_\n      ¬∑ apply uniq\n        dsimp [Functor]\n        erw [fac]\n        rfl\n      ¬∑ apply natTrans_hcomp_injective\n        ext X\n        simp)\n\n"}
{"name":"CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.unitIso_inv","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst‚úù : CategoryTheory.Category.{uD', uD} D\n‚ä¢ Eq (CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.unitIso W D).inv (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- The unit isomorphism of the equivalence of categories `whiskeringLeftEquivalence W D`. -/\n@[simps!]\ndef unitIso : ùü≠ (W.Localization ‚•§ D) ‚âÖ functor W D ‚ãô inverse W D :=\n  eqToIso\n    (by\n      refine Functor.ext (fun G => ?_) fun G‚ÇÅ G‚ÇÇ œÑ => ?_\n      ¬∑ apply uniq\n        dsimp [Functor]\n        erw [fac]\n        rfl\n      ¬∑ apply natTrans_hcomp_injective\n        ext X\n        simp)\n\n"}
{"name":"CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.counitIso_hom","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst‚úù : CategoryTheory.Category.{uD', uD} D\n‚ä¢ Eq (CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.counitIso W D).hom (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- The counit isomorphism of the equivalence of categories `WhiskeringLeftEquivalence W D`. -/\n@[simps!]\ndef counitIso : inverse W D ‚ãô functor W D ‚âÖ ùü≠ (W.FunctorsInverting D) :=\n  eqToIso\n    (by\n      refine Functor.ext ?_ ?_\n      ¬∑ rintro ‚ü®G, hG‚ü©\n        ext\n        exact fac G hG\n      ¬∑ rintro ‚ü®G‚ÇÅ, hG‚ÇÅ‚ü© ‚ü®G‚ÇÇ, hG‚ÇÇ‚ü© f\n        ext\n        apply NatTransExtension.app_eq)\n\n"}
{"name":"CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.counitIso_inv","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst‚úù¬π : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst‚úù : CategoryTheory.Category.{uD', uD} D\n‚ä¢ Eq (CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.counitIso W D).inv (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- The counit isomorphism of the equivalence of categories `WhiskeringLeftEquivalence W D`. -/\n@[simps!]\ndef counitIso : inverse W D ‚ãô functor W D ‚âÖ ùü≠ (W.FunctorsInverting D) :=\n  eqToIso\n    (by\n      refine Functor.ext ?_ ?_\n      ¬∑ rintro ‚ü®G, hG‚ü©\n        ext\n        exact fac G hG\n      ¬∑ rintro ‚ü®G‚ÇÅ, hG‚ÇÅ‚ü© ‚ü®G‚ÇÇ, hG‚ÇÇ‚ü© f\n        ext\n        apply NatTransExtension.app_eq)\n\n"}
