{"name":"CategoryTheory.Localization.Construction.LocQuiver.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝² : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : SizeOf C\ninst✝ : ⦃X Y : C⦄ → (x : Quiver.Hom X Y) → SizeOf (W x)\nobj : C\n⊢ Eq (SizeOf.sizeOf { obj := obj }) (HAdd.hAdd 1 (SizeOf.sizeOf obj))","decl":"/-- If `W : MorphismProperty C`, `LocQuiver W` is a quiver with the same objects\nas `C`, and whose morphisms are those in `C` and placeholders for formal\ninverses of the morphisms in `W`. -/\nstructure LocQuiver (W : MorphismProperty C) where\n  /-- underlying object -/\n  obj : C\n\n"}
{"name":"CategoryTheory.Localization.Construction.LocQuiver.mk.injEq","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nobj✝ obj : C\n⊢ Eq (Eq { obj := obj✝ } { obj := obj }) (Eq obj✝ obj)","decl":"/-- If `W : MorphismProperty C`, `LocQuiver W` is a quiver with the same objects\nas `C`, and whose morphisms are those in `C` and placeholders for formal\ninverses of the morphisms in `W`. -/\nstructure LocQuiver (W : MorphismProperty C) where\n  /-- underlying object -/\n  obj : C\n\n"}
{"name":"CategoryTheory.Localization.Construction.LocQuiver.mk.inj","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nobj✝ obj : C\nx✝ : Eq { obj := obj✝ } { obj := obj }\n⊢ Eq obj✝ obj","decl":"/-- If `W : MorphismProperty C`, `LocQuiver W` is a quiver with the same objects\nas `C`, and whose morphisms are those in `C` and placeholders for formal\ninverses of the morphisms in `W`. -/\nstructure LocQuiver (W : MorphismProperty C) where\n  /-- underlying object -/\n  obj : C\n\n"}
{"name":"CategoryTheory.MorphismProperty.Q_inverts","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\n⊢ W.IsInvertedBy W.Q","decl":"theorem _root_.CategoryTheory.MorphismProperty.Q_inverts : W.IsInvertedBy W.Q := fun _ _ w hw =>\n  (Localization.Construction.wIso w hw).isIso_hom\n\n"}
{"name":"CategoryTheory.Localization.Construction.liftToPathCategory_map","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst✝ : CategoryTheory.Category.{uD', uD} D\nG : CategoryTheory.Functor C D\nhG : W.IsInvertedBy G\nX✝ Y✝ : CategoryTheory.Paths (CategoryTheory.Localization.Construction.LocQuiver W)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Localization.Construction.liftToPathCategory G hG).map f) (CategoryTheory.composePath ({ obj := fun X => G.obj X.obj, map := fun {X Y} a => Sum.rec (fun val => G.map val) (fun val => CategoryTheory.inv (G.map ↑val)) a }.mapPath f))","decl":"/-- The lifting of a functor to the path category of `LocQuiver W` -/\n@[simps!]\ndef liftToPathCategory : Paths (LocQuiver W) ⥤ D :=\n  Quiv.lift\n    { obj := fun X => G.obj X.obj\n      map := by\n        intros X Y\n        rintro (f | ⟨g, hg⟩)\n        · exact G.map f\n        · haveI := hG g hg\n          exact inv (G.map g) }\n\n"}
{"name":"CategoryTheory.Localization.Construction.liftToPathCategory_obj","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst✝ : CategoryTheory.Category.{uD', uD} D\nG : CategoryTheory.Functor C D\nhG : W.IsInvertedBy G\nX : CategoryTheory.Paths (CategoryTheory.Localization.Construction.LocQuiver W)\n⊢ Eq ((CategoryTheory.Localization.Construction.liftToPathCategory G hG).obj X) (G.obj X.obj)","decl":"/-- The lifting of a functor to the path category of `LocQuiver W` -/\n@[simps!]\ndef liftToPathCategory : Paths (LocQuiver W) ⥤ D :=\n  Quiv.lift\n    { obj := fun X => G.obj X.obj\n      map := by\n        intros X Y\n        rintro (f | ⟨g, hg⟩)\n        · exact G.map f\n        · haveI := hG g hg\n          exact inv (G.map g) }\n\n"}
{"name":"CategoryTheory.Localization.Construction.lift_obj","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst✝ : CategoryTheory.Category.{uD', uD} D\nG : CategoryTheory.Functor C D\nhG : W.IsInvertedBy G\na : CategoryTheory.Quotient (CategoryTheory.Localization.Construction.relations W)\n⊢ Eq ((CategoryTheory.Localization.Construction.lift G hG).obj a) (G.obj a.as.obj)","decl":"/-- The lifting of a functor `C ⥤ D` inverting `W` as a functor `W.Localization ⥤ D` -/\n@[simps!]\ndef lift : W.Localization ⥤ D :=\n  Quotient.lift (relations W) (liftToPathCategory G hG)\n    (by\n      rintro ⟨X⟩ ⟨Y⟩ f₁ f₂ r\n      -- Porting note: rest of proof was `rcases r with ⟨⟩; tidy`\n      rcases r with (_|_|⟨f,hf⟩|⟨f,hf⟩)\n      · aesop_cat\n      · simp\n      all_goals\n        dsimp\n        haveI := hG f hf\n        simp\n        rfl)\n\n"}
{"name":"CategoryTheory.Localization.Construction.lift_map","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst✝ : CategoryTheory.Category.{uD', uD} D\nG : CategoryTheory.Functor C D\nhG : W.IsInvertedBy G\na b : CategoryTheory.Quotient (CategoryTheory.Localization.Construction.relations W)\nhf : Quiver.Hom a b\n⊢ Eq ((CategoryTheory.Localization.Construction.lift G hG).map hf) (Quot.liftOn hf (fun f => CategoryTheory.composePath ({ obj := fun X => G.obj X.obj, map := fun {X Y} a => Sum.rec (fun val => G.map val) (fun val => CategoryTheory.inv (G.map ↑val)) a }.mapPath f)) ⋯)","decl":"/-- The lifting of a functor `C ⥤ D` inverting `W` as a functor `W.Localization ⥤ D` -/\n@[simps!]\ndef lift : W.Localization ⥤ D :=\n  Quotient.lift (relations W) (liftToPathCategory G hG)\n    (by\n      rintro ⟨X⟩ ⟨Y⟩ f₁ f₂ r\n      -- Porting note: rest of proof was `rcases r with ⟨⟩; tidy`\n      rcases r with (_|_|⟨f,hf⟩|⟨f,hf⟩)\n      · aesop_cat\n      · simp\n      all_goals\n        dsimp\n        haveI := hG f hf\n        simp\n        rfl)\n\n"}
{"name":"CategoryTheory.Localization.Construction.fac","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst✝ : CategoryTheory.Category.{uD', uD} D\nG : CategoryTheory.Functor C D\nhG : W.IsInvertedBy G\n⊢ Eq (W.Q.comp (CategoryTheory.Localization.Construction.lift G hG)) G","decl":"@[simp]\ntheorem fac : W.Q ⋙ lift G hG = G :=\n  Functor.ext (fun _ => rfl)\n    (by\n      intro X Y f\n      simp only [Functor.comp_map, eqToHom_refl, comp_id, id_comp]\n      dsimp [MorphismProperty.Q, Quot.liftOn, Quotient.functor]\n      rw [composePath_toPath])\n\n"}
{"name":"CategoryTheory.Localization.Construction.uniq","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst✝ : CategoryTheory.Category.{uD', uD} D\nG₁ G₂ : CategoryTheory.Functor W.Localization D\nh : Eq (W.Q.comp G₁) (W.Q.comp G₂)\n⊢ Eq G₁ G₂","decl":"theorem uniq (G₁ G₂ : W.Localization ⥤ D) (h : W.Q ⋙ G₁ = W.Q ⋙ G₂) : G₁ = G₂ := by\n  suffices h' : Quotient.functor _ ⋙ G₁ = Quotient.functor _ ⋙ G₂ by\n    refine Functor.ext ?_ ?_\n    · rintro ⟨⟨X⟩⟩\n      apply Functor.congr_obj h\n    · rintro ⟨⟨X⟩⟩ ⟨⟨Y⟩⟩ ⟨f⟩\n      apply Functor.congr_hom h'\n  refine Paths.ext_functor ?_ ?_\n  · ext X\n    cases X\n    apply Functor.congr_obj h\n  · rintro ⟨X⟩ ⟨Y⟩ (f | ⟨w, hw⟩)\n    · simpa only using Functor.congr_hom h f\n    · have hw : W.Q.map w = (wIso w hw).hom := rfl\n      have hw' := Functor.congr_hom h w\n      simp only [Functor.comp_map, hw] at hw'\n      refine Functor.congr_inv_of_congr_hom _ _ _ ?_ ?_ hw'\n      all_goals apply Functor.congr_obj h\n\n"}
{"name":"CategoryTheory.Localization.Construction.objEquiv_apply","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\na✝ : C\n⊢ Eq ((CategoryTheory.Localization.Construction.objEquiv W) a✝) (W.Q.obj a✝)","decl":"/-- The canonical bijection between objects in a category and its\nlocalization with respect to a morphism_property `W` -/\n@[simps]\ndef objEquiv : C ≃ W.Localization where\n  toFun := W.Q.obj\n  invFun X := X.as.obj\n  left_inv _ := rfl\n  right_inv := by\n    rintro ⟨⟨X⟩⟩\n    rfl\n\n"}
{"name":"CategoryTheory.Localization.Construction.objEquiv_symm_apply","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nX : W.Localization\n⊢ Eq ((CategoryTheory.Localization.Construction.objEquiv W).symm X) X.as.obj","decl":"/-- The canonical bijection between objects in a category and its\nlocalization with respect to a morphism_property `W` -/\n@[simps]\ndef objEquiv : C ≃ W.Localization where\n  toFun := W.Q.obj\n  invFun X := X.as.obj\n  left_inv _ := rfl\n  right_inv := by\n    rintro ⟨⟨X⟩⟩\n    rfl\n\n"}
{"name":"CategoryTheory.Localization.Construction.morphismProperty_is_top","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nP : CategoryTheory.MorphismProperty W.Localization\ninst✝ : P.IsStableUnderComposition\nhP₁ : ∀ ⦃X Y : C⦄ (f : Quiver.Hom X Y), P (W.Q.map f)\nhP₂ : ∀ ⦃X Y : C⦄ (w : Quiver.Hom X Y) (hw : W w), P (CategoryTheory.Localization.Construction.wInv w hw)\n⊢ Eq P Top.top","decl":"/-- A `MorphismProperty` in `W.Localization` is satisfied by all\nmorphisms in the localized category if it contains the image of the\nmorphisms in the original category, the inverses of the morphisms\nin `W` and if it is stable under composition -/\ntheorem morphismProperty_is_top (P : MorphismProperty W.Localization)\n    [P.IsStableUnderComposition] (hP₁ : ∀ ⦃X Y : C⦄ (f : X ⟶ Y), P (W.Q.map f))\n    (hP₂ : ∀ ⦃X Y : C⦄ (w : X ⟶ Y) (hw : W w), P (wInv w hw)) :\n    P = ⊤ := by\n  funext X Y f\n  ext\n  constructor\n  · intro\n    apply MorphismProperty.top_apply\n  · intro\n    let G : _ ⥤ W.Localization := Quotient.functor _\n    haveI : G.Full := Quotient.full_functor _\n    suffices ∀ (X₁ X₂ : Paths (LocQuiver W)) (f : X₁ ⟶ X₂), P (G.map f) by\n      rcases X with ⟨⟨X⟩⟩\n      rcases Y with ⟨⟨Y⟩⟩\n      simpa only [Functor.map_preimage] using this _ _ (G.preimage f)\n    intros X₁ X₂ p\n    induction' p with X₂ X₃ p g hp\n    · simpa only [Functor.map_id] using hP₁ (𝟙 X₁.obj)\n    · let p' : X₁ ⟶X₂ := p\n      rw [show p'.cons g = p' ≫ Quiver.Hom.toPath g by rfl, G.map_comp]\n      refine P.comp_mem _ _ hp ?_\n      rcases g with (g | ⟨g, hg⟩)\n      · apply hP₁\n      · apply hP₂\n\n"}
{"name":"CategoryTheory.Localization.Construction.morphismProperty_is_top'","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nP : CategoryTheory.MorphismProperty W.Localization\ninst✝ : P.IsStableUnderComposition\nhP₁ : ∀ ⦃X Y : C⦄ (f : Quiver.Hom X Y), P (W.Q.map f)\nhP₂ : ∀ ⦃X Y : W.Localization⦄ (e : CategoryTheory.Iso X Y), P e.hom → P e.inv\n⊢ Eq P Top.top","decl":"/-- A `MorphismProperty` in `W.Localization` is satisfied by all\nmorphisms in the localized category if it contains the image of the\nmorphisms in the original category, if is stable under composition\nand if the property is stable by passing to inverses. -/\ntheorem morphismProperty_is_top' (P : MorphismProperty W.Localization)\n    [P.IsStableUnderComposition] (hP₁ : ∀ ⦃X Y : C⦄ (f : X ⟶ Y), P (W.Q.map f))\n    (hP₂ : ∀ ⦃X Y : W.Localization⦄ (e : X ≅ Y) (_ : P e.hom), P e.inv) : P = ⊤ :=\n  morphismProperty_is_top P hP₁ (fun _ _ w _ => hP₂ _ (hP₁ w))\n\n"}
{"name":"CategoryTheory.Localization.Construction.NatTransExtension.app_eq","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst✝ : CategoryTheory.Category.{uD', uD} D\nF₁ F₂ : CategoryTheory.Functor W.Localization D\nτ : Quiver.Hom (W.Q.comp F₁) (W.Q.comp F₂)\nX : C\n⊢ Eq (CategoryTheory.Localization.Construction.NatTransExtension.app τ (W.Q.obj X)) (τ.app X)","decl":"@[simp]\ntheorem app_eq (X : C) : (app τ) (W.Q.obj X) = τ.app X := by\n  simp only [app, eqToHom_refl, comp_id, id_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.Localization.Construction.natTransExtension_app","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst✝ : CategoryTheory.Category.{uD', uD} D\nF₁ F₂ : CategoryTheory.Functor W.Localization D\nτ : Quiver.Hom (W.Q.comp F₁) (W.Q.comp F₂)\nX : W.Localization\n⊢ Eq ((CategoryTheory.Localization.Construction.natTransExtension τ).app X) (CategoryTheory.Localization.Construction.NatTransExtension.app τ X)","decl":"/-- If `F₁` and `F₂` are functors `W.Localization ⥤ D`, a natural transformation `F₁ ⟶ F₂`\ncan be obtained from a natural transformation `W.Q ⋙ F₁ ⟶ W.Q ⋙ F₂`. -/\n@[simps]\ndef natTransExtension {F₁ F₂ : W.Localization ⥤ D} (τ : W.Q ⋙ F₁ ⟶ W.Q ⋙ F₂) : F₁ ⟶ F₂ where\n  app := NatTransExtension.app τ\n  naturality := by\n    suffices MorphismProperty.naturalityProperty (NatTransExtension.app τ) = ⊤ by\n      intro X Y f\n      simpa only [← this] using MorphismProperty.top_apply f\n    refine morphismProperty_is_top'\n      (MorphismProperty.naturalityProperty (NatTransExtension.app τ))\n      ?_ (MorphismProperty.naturalityProperty.stableUnderInverse _)\n    intros X Y f\n    dsimp\n    simpa only [NatTransExtension.app_eq] using τ.naturality f\n\n"}
{"name":"CategoryTheory.Localization.Construction.natTransExtension_hcomp","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst✝ : CategoryTheory.Category.{uD', uD} D\nF G : CategoryTheory.Functor W.Localization D\nτ : Quiver.Hom (W.Q.comp F) (W.Q.comp G)\n⊢ Eq (CategoryTheory.NatTrans.hcomp (CategoryTheory.CategoryStruct.id W.Q) (CategoryTheory.Localization.Construction.natTransExtension τ)) τ","decl":"@[simp]\ntheorem natTransExtension_hcomp {F G : W.Localization ⥤ D} (τ : W.Q ⋙ F ⟶ W.Q ⋙ G) :\n    𝟙 W.Q ◫ natTransExtension τ = τ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Localization.Construction.natTrans_hcomp_injective","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst✝ : CategoryTheory.Category.{uD', uD} D\nF G : CategoryTheory.Functor W.Localization D\nτ₁ τ₂ : Quiver.Hom F G\nh : Eq (CategoryTheory.NatTrans.hcomp (CategoryTheory.CategoryStruct.id W.Q) τ₁) (CategoryTheory.NatTrans.hcomp (CategoryTheory.CategoryStruct.id W.Q) τ₂)\n⊢ Eq τ₁ τ₂","decl":"theorem natTrans_hcomp_injective {F G : W.Localization ⥤ D} {τ₁ τ₂ : F ⟶ G}\n    (h : 𝟙 W.Q ◫ τ₁ = 𝟙 W.Q ◫ τ₂) : τ₁ = τ₂ := by\n  ext X\n  have eq := (objEquiv W).right_inv X\n  simp only [objEquiv] at eq\n  rw [← eq, ← NatTrans.id_hcomp_app, ← NatTrans.id_hcomp_app, h]\n\n"}
{"name":"CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.functor_obj_obj_map","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst✝ : CategoryTheory.Category.{uD', uD} D\nX : CategoryTheory.Functor W.Localization D\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.functor W D).obj X).obj.map f) (X.map (W.Q.map f))","decl":"/-- The functor `(W.Localization ⥤ D) ⥤ (W.FunctorsInverting D)` induced by the\ncomposition with `W.Q : C ⥤ W.Localization`. -/\n@[simps!]\ndef functor : (W.Localization ⥤ D) ⥤ W.FunctorsInverting D :=\n  FullSubcategory.lift _ ((whiskeringLeft _ _ D).obj W.Q) fun _ =>\n    MorphismProperty.IsInvertedBy.of_comp W W.Q W.Q_inverts _\n\n"}
{"name":"CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.functor_obj_obj_obj","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst✝ : CategoryTheory.Category.{uD', uD} D\nX✝ : CategoryTheory.Functor W.Localization D\nX : C\n⊢ Eq (((CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.functor W D).obj X✝).obj.obj X) (X✝.obj (W.Q.obj X))","decl":"/-- The functor `(W.Localization ⥤ D) ⥤ (W.FunctorsInverting D)` induced by the\ncomposition with `W.Q : C ⥤ W.Localization`. -/\n@[simps!]\ndef functor : (W.Localization ⥤ D) ⥤ W.FunctorsInverting D :=\n  FullSubcategory.lift _ ((whiskeringLeft _ _ D).obj W.Q) fun _ =>\n    MorphismProperty.IsInvertedBy.of_comp W W.Q W.Q_inverts _\n\n"}
{"name":"CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.functor_map_app","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst✝ : CategoryTheory.Category.{uD', uD} D\nX✝ Y✝ : CategoryTheory.Functor W.Localization D\nf : Quiver.Hom X✝ Y✝\nX : C\n⊢ Eq (((CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.functor W D).map f).app X) (f.app (W.Q.obj X))","decl":"/-- The functor `(W.Localization ⥤ D) ⥤ (W.FunctorsInverting D)` induced by the\ncomposition with `W.Q : C ⥤ W.Localization`. -/\n@[simps!]\ndef functor : (W.Localization ⥤ D) ⥤ W.FunctorsInverting D :=\n  FullSubcategory.lift _ ((whiskeringLeft _ _ D).obj W.Q) fun _ =>\n    MorphismProperty.IsInvertedBy.of_comp W W.Q W.Q_inverts _\n\n"}
{"name":"CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.inverse_obj_map","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst✝ : CategoryTheory.Category.{uD', uD} D\nG : W.FunctorsInverting D\na b : CategoryTheory.Quotient (CategoryTheory.Localization.Construction.relations W)\nhf : Quiver.Hom a b\n⊢ Eq (((CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.inverse W D).obj G).map hf) (Quot.liftOn hf (fun f => CategoryTheory.composePath ({ obj := fun X => G.obj.obj X.obj, map := fun {X Y} a => Sum.rec (fun val => G.obj.map val) (fun val => CategoryTheory.inv (G.obj.map ↑val)) a }.mapPath f)) ⋯)","decl":"/-- The function `(W.FunctorsInverting D) ⥤ (W.Localization ⥤ D)` induced by\n`Construction.lift`. -/\n@[simps!]\ndef inverse : W.FunctorsInverting D ⥤ W.Localization ⥤ D where\n  obj G := lift G.obj G.property\n  map τ := natTransExtension (eqToHom (by rw [fac]) ≫ τ ≫ eqToHom (by rw [fac]))\n  map_id G :=\n    natTrans_hcomp_injective\n      (by\n        rw [natTransExtension_hcomp]\n        ext X\n        simp only [NatTrans.comp_app, eqToHom_app, eqToHom_refl, comp_id, id_comp,\n          NatTrans.hcomp_id_app, NatTrans.id_app, Functor.map_id]\n        rfl)\n  map_comp τ₁ τ₂ :=\n    natTrans_hcomp_injective\n      (by\n        ext X\n        simp only [natTransExtension_hcomp, NatTrans.comp_app, eqToHom_app, eqToHom_refl,\n          id_comp, comp_id, NatTrans.hcomp_app, NatTrans.id_app, Functor.map_id,\n          natTransExtension_app, NatTransExtension.app_eq]\n        rfl)\n\n"}
{"name":"CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.inverse_obj_obj","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst✝ : CategoryTheory.Category.{uD', uD} D\nG : W.FunctorsInverting D\na : CategoryTheory.Quotient (CategoryTheory.Localization.Construction.relations W)\n⊢ Eq (((CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.inverse W D).obj G).obj a) (G.obj.obj a.as.obj)","decl":"/-- The function `(W.FunctorsInverting D) ⥤ (W.Localization ⥤ D)` induced by\n`Construction.lift`. -/\n@[simps!]\ndef inverse : W.FunctorsInverting D ⥤ W.Localization ⥤ D where\n  obj G := lift G.obj G.property\n  map τ := natTransExtension (eqToHom (by rw [fac]) ≫ τ ≫ eqToHom (by rw [fac]))\n  map_id G :=\n    natTrans_hcomp_injective\n      (by\n        rw [natTransExtension_hcomp]\n        ext X\n        simp only [NatTrans.comp_app, eqToHom_app, eqToHom_refl, comp_id, id_comp,\n          NatTrans.hcomp_id_app, NatTrans.id_app, Functor.map_id]\n        rfl)\n  map_comp τ₁ τ₂ :=\n    natTrans_hcomp_injective\n      (by\n        ext X\n        simp only [natTransExtension_hcomp, NatTrans.comp_app, eqToHom_app, eqToHom_refl,\n          id_comp, comp_id, NatTrans.hcomp_app, NatTrans.id_app, Functor.map_id,\n          natTransExtension_app, NatTransExtension.app_eq]\n        rfl)\n\n"}
{"name":"CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.inverse_map_app","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst✝ : CategoryTheory.Category.{uD', uD} D\nX✝ Y✝ : W.FunctorsInverting D\nτ : Quiver.Hom X✝ Y✝\nX : W.Localization\n⊢ Eq (((CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.inverse W D).map τ).app X) (CategoryTheory.Localization.Construction.NatTransExtension.app (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp τ (CategoryTheory.eqToHom ⋯))) X)","decl":"/-- The function `(W.FunctorsInverting D) ⥤ (W.Localization ⥤ D)` induced by\n`Construction.lift`. -/\n@[simps!]\ndef inverse : W.FunctorsInverting D ⥤ W.Localization ⥤ D where\n  obj G := lift G.obj G.property\n  map τ := natTransExtension (eqToHom (by rw [fac]) ≫ τ ≫ eqToHom (by rw [fac]))\n  map_id G :=\n    natTrans_hcomp_injective\n      (by\n        rw [natTransExtension_hcomp]\n        ext X\n        simp only [NatTrans.comp_app, eqToHom_app, eqToHom_refl, comp_id, id_comp,\n          NatTrans.hcomp_id_app, NatTrans.id_app, Functor.map_id]\n        rfl)\n  map_comp τ₁ τ₂ :=\n    natTrans_hcomp_injective\n      (by\n        ext X\n        simp only [natTransExtension_hcomp, NatTrans.comp_app, eqToHom_app, eqToHom_refl,\n          id_comp, comp_id, NatTrans.hcomp_app, NatTrans.id_app, Functor.map_id,\n          natTransExtension_app, NatTransExtension.app_eq]\n        rfl)\n\n"}
{"name":"CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.unitIso_hom","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst✝ : CategoryTheory.Category.{uD', uD} D\n⊢ Eq (CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.unitIso W D).hom (CategoryTheory.eqToHom ⋯)","decl":"/-- The unit isomorphism of the equivalence of categories `whiskeringLeftEquivalence W D`. -/\n@[simps!]\ndef unitIso : 𝟭 (W.Localization ⥤ D) ≅ functor W D ⋙ inverse W D :=\n  eqToIso\n    (by\n      refine Functor.ext (fun G => ?_) fun G₁ G₂ τ => ?_\n      · apply uniq\n        dsimp [Functor]\n        erw [fac]\n        rfl\n      · apply natTrans_hcomp_injective\n        ext X\n        simp)\n\n"}
{"name":"CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.unitIso_inv","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst✝ : CategoryTheory.Category.{uD', uD} D\n⊢ Eq (CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.unitIso W D).inv (CategoryTheory.eqToHom ⋯)","decl":"/-- The unit isomorphism of the equivalence of categories `whiskeringLeftEquivalence W D`. -/\n@[simps!]\ndef unitIso : 𝟭 (W.Localization ⥤ D) ≅ functor W D ⋙ inverse W D :=\n  eqToIso\n    (by\n      refine Functor.ext (fun G => ?_) fun G₁ G₂ τ => ?_\n      · apply uniq\n        dsimp [Functor]\n        erw [fac]\n        rfl\n      · apply natTrans_hcomp_injective\n        ext X\n        simp)\n\n"}
{"name":"CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.counitIso_hom","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst✝ : CategoryTheory.Category.{uD', uD} D\n⊢ Eq (CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.counitIso W D).hom (CategoryTheory.eqToHom ⋯)","decl":"/-- The counit isomorphism of the equivalence of categories `WhiskeringLeftEquivalence W D`. -/\n@[simps!]\ndef counitIso : inverse W D ⋙ functor W D ≅ 𝟭 (W.FunctorsInverting D) :=\n  eqToIso\n    (by\n      refine Functor.ext ?_ ?_\n      · rintro ⟨G, hG⟩\n        ext\n        exact fac G hG\n      · rintro ⟨G₁, hG₁⟩ ⟨G₂, hG₂⟩ f\n        ext\n        apply NatTransExtension.app_eq)\n\n"}
{"name":"CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.counitIso_inv","module":"Mathlib.CategoryTheory.Localization.Construction","initialProofState":"C : Type uC\ninst✝¹ : CategoryTheory.Category.{uC', uC} C\nW : CategoryTheory.MorphismProperty C\nD : Type uD\ninst✝ : CategoryTheory.Category.{uD', uD} D\n⊢ Eq (CategoryTheory.Localization.Construction.WhiskeringLeftEquivalence.counitIso W D).inv (CategoryTheory.eqToHom ⋯)","decl":"/-- The counit isomorphism of the equivalence of categories `WhiskeringLeftEquivalence W D`. -/\n@[simps!]\ndef counitIso : inverse W D ⋙ functor W D ≅ 𝟭 (W.FunctorsInverting D) :=\n  eqToIso\n    (by\n      refine Functor.ext ?_ ?_\n      · rintro ⟨G, hG⟩\n        ext\n        exact fac G hG\n      · rintro ⟨G₁, hG₁⟩ ⟨G₂, hG₂⟩ f\n        ext\n        apply NatTransExtension.app_eq)\n\n"}
