{"name":"LinearMap.BilinForm.isSkewAdjoint_bracket","module":"Mathlib.Algebra.Lie.SkewAdjoint","initialProofState":"R : Type u\nM : Type v\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nB : LinearMap.BilinForm R M\nf g : Module.End R M\nhf : Membership.mem (LinearMap.skewAdjointSubmodule B) f\nhg : Membership.mem (LinearMap.skewAdjointSubmodule B) g\n⊢ Membership.mem (LinearMap.skewAdjointSubmodule B) (Bracket.bracket f g)","decl":"theorem LinearMap.BilinForm.isSkewAdjoint_bracket {f g : Module.End R M}\n    (hf : f ∈ B.skewAdjointSubmodule) (hg : g ∈ B.skewAdjointSubmodule) :\n    ⁅f, g⁆ ∈ B.skewAdjointSubmodule := by\n  rw [mem_skewAdjointSubmodule] at *\n  have hfg : IsAdjointPair B B (f * g) (g * f) := by rw [← neg_mul_neg g f]; exact hg.comp hf\n  have hgf : IsAdjointPair B B (g * f) (f * g) := by rw [← neg_mul_neg f g]; exact hf.comp hg\n  change IsAdjointPair B B (f * g - g * f) (-(f * g - g * f)); rw [neg_sub]\n  exact hfg.sub hgf\n\n"}
{"name":"skewAdjointLieSubalgebraEquiv_apply","module":"Mathlib.Algebra.Lie.SkewAdjoint","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nB : LinearMap.BilinForm R M\nN : Type w\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\ne : LinearEquiv (RingHom.id R) N M\nf : Subtype fun x => Membership.mem (skewAdjointLieSubalgebra (LinearMap.compl₁₂ B ↑e ↑e)) x\n⊢ Eq (↑((skewAdjointLieSubalgebraEquiv B e) f)) (e.lieConj ↑f)","decl":"@[simp]\ntheorem skewAdjointLieSubalgebraEquiv_apply\n    (f : skewAdjointLieSubalgebra (B.compl₁₂ (Qₗ := N) (Qₗ' := N) ↑e ↑e)) :\n    ↑(skewAdjointLieSubalgebraEquiv B e f) = e.lieConj f := by\n  simp [skewAdjointLieSubalgebraEquiv]\n\n"}
{"name":"skewAdjointLieSubalgebraEquiv_symm_apply","module":"Mathlib.Algebra.Lie.SkewAdjoint","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nB : LinearMap.BilinForm R M\nN : Type w\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\ne : LinearEquiv (RingHom.id R) N M\nf : Subtype fun x => Membership.mem (skewAdjointLieSubalgebra B) x\n⊢ Eq (↑((skewAdjointLieSubalgebraEquiv B e).symm f)) (e.symm.lieConj ↑f)","decl":"@[simp]\ntheorem skewAdjointLieSubalgebraEquiv_symm_apply (f : skewAdjointLieSubalgebra B) :\n    ↑((skewAdjointLieSubalgebraEquiv B e).symm f) = e.symm.lieConj f := by\n  simp [skewAdjointLieSubalgebraEquiv]\n\n"}
{"name":"Matrix.lie_transpose","module":"Mathlib.Algebra.Lie.SkewAdjoint","initialProofState":"R : Type u\nn : Type w\ninst✝² : CommRing R\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nA B : Matrix n n R\n⊢ Eq (Bracket.bracket A B).transpose (Bracket.bracket B.transpose A.transpose)","decl":"theorem Matrix.lie_transpose (A B : Matrix n n R) : ⁅A, B⁆ᵀ = ⁅Bᵀ, Aᵀ⁆ :=\n  show (A * B - B * A)ᵀ = Bᵀ * Aᵀ - Aᵀ * Bᵀ by simp\n\n-- Porting note: Changed `(A B)` to `{A B}` for convenience in `skewAdjointMatricesLieSubalgebra`\n"}
{"name":"Matrix.isSkewAdjoint_bracket","module":"Mathlib.Algebra.Lie.SkewAdjoint","initialProofState":"R : Type u\nn : Type w\ninst✝² : CommRing R\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nJ A B : Matrix n n R\nhA : Membership.mem (skewAdjointMatricesSubmodule J) A\nhB : Membership.mem (skewAdjointMatricesSubmodule J) B\n⊢ Membership.mem (skewAdjointMatricesSubmodule J) (Bracket.bracket A B)","decl":"theorem Matrix.isSkewAdjoint_bracket {A B : Matrix n n R} (hA : A ∈ skewAdjointMatricesSubmodule J)\n    (hB : B ∈ skewAdjointMatricesSubmodule J) : ⁅A, B⁆ ∈ skewAdjointMatricesSubmodule J := by\n  simp only [mem_skewAdjointMatricesSubmodule] at *\n  change ⁅A, B⁆ᵀ * J = J * (-⁅A, B⁆)\n  change Aᵀ * J = J * (-A) at hA\n  change Bᵀ * J = J * (-B) at hB\n  rw [Matrix.lie_transpose, LieRing.of_associative_ring_bracket,\n    LieRing.of_associative_ring_bracket, sub_mul, mul_assoc, mul_assoc, hA, hB, ← mul_assoc,\n    ← mul_assoc, hA, hB]\n  noncomm_ring\n\n"}
{"name":"mem_skewAdjointMatricesLieSubalgebra","module":"Mathlib.Algebra.Lie.SkewAdjoint","initialProofState":"R : Type u\nn : Type w\ninst✝² : CommRing R\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nJ A : Matrix n n R\n⊢ Iff (Membership.mem (skewAdjointMatricesLieSubalgebra J) A) (Membership.mem (skewAdjointMatricesSubmodule J) A)","decl":"@[simp]\ntheorem mem_skewAdjointMatricesLieSubalgebra (A : Matrix n n R) :\n    A ∈ skewAdjointMatricesLieSubalgebra J ↔ A ∈ skewAdjointMatricesSubmodule J :=\n  Iff.rfl\n\n"}
{"name":"skewAdjointMatricesLieSubalgebraEquiv_apply","module":"Mathlib.Algebra.Lie.SkewAdjoint","initialProofState":"R : Type u\nn : Type w\ninst✝² : CommRing R\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nJ P : Matrix n n R\nh : Invertible P\nA : Subtype fun x => Membership.mem (skewAdjointMatricesLieSubalgebra J) x\n⊢ Eq (↑((skewAdjointMatricesLieSubalgebraEquiv J P h) A)) (HMul.hMul (HMul.hMul (Inv.inv P) ↑A) P)","decl":"theorem skewAdjointMatricesLieSubalgebraEquiv_apply (P : Matrix n n R) (h : Invertible P)\n    (A : skewAdjointMatricesLieSubalgebra J) :\n    ↑(skewAdjointMatricesLieSubalgebraEquiv J P h A) = P⁻¹ * A * P := by\n  simp [skewAdjointMatricesLieSubalgebraEquiv]\n\n"}
{"name":"skewAdjointMatricesLieSubalgebraEquivTranspose_apply","module":"Mathlib.Algebra.Lie.SkewAdjoint","initialProofState":"R : Type u\nn : Type w\ninst✝⁴ : CommRing R\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\nJ : Matrix n n R\nm : Type w\ninst✝¹ : DecidableEq m\ninst✝ : Fintype m\ne : AlgEquiv R (Matrix n n R) (Matrix m m R)\nh : ∀ (A : Matrix n n R), Eq (e A).transpose (e A.transpose)\nA : Subtype fun x => Membership.mem (skewAdjointMatricesLieSubalgebra J) x\n⊢ Eq (↑((skewAdjointMatricesLieSubalgebraEquivTranspose J e h) A)) (e ↑A)","decl":"@[simp]\ntheorem skewAdjointMatricesLieSubalgebraEquivTranspose_apply {m : Type w} [DecidableEq m]\n    [Fintype m] (e : Matrix n n R ≃ₐ[R] Matrix m m R) (h : ∀ A, (e A)ᵀ = e Aᵀ)\n    (A : skewAdjointMatricesLieSubalgebra J) :\n    (skewAdjointMatricesLieSubalgebraEquivTranspose J e h A : Matrix m m R) = e A :=\n  rfl\n\n"}
{"name":"mem_skewAdjointMatricesLieSubalgebra_unit_smul","module":"Mathlib.Algebra.Lie.SkewAdjoint","initialProofState":"R : Type u\nn : Type w\ninst✝² : CommRing R\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nu : Units R\nJ A : Matrix n n R\n⊢ Iff (Membership.mem (skewAdjointMatricesLieSubalgebra (HSMul.hSMul u J)) A) (Membership.mem (skewAdjointMatricesLieSubalgebra J) A)","decl":"theorem mem_skewAdjointMatricesLieSubalgebra_unit_smul (u : Rˣ) (J A : Matrix n n R) :\n    A ∈ skewAdjointMatricesLieSubalgebra (u • J) ↔ A ∈ skewAdjointMatricesLieSubalgebra J := by\n  change A ∈ skewAdjointMatricesSubmodule (u • J) ↔ A ∈ skewAdjointMatricesSubmodule J\n  simp only [mem_skewAdjointMatricesSubmodule, Matrix.IsSkewAdjoint, Matrix.IsAdjointPair]\n  constructor <;> intro h\n  · simpa using congr_arg (fun B => u⁻¹ • B) h\n  · simp [h]\n\n"}
