{"name":"QPF.abs_repr","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nself : QPF F\nα : Type u\nx : F α\n⊢ Eq (QPF.abs (QPF.repr x)) x","decl":"/-- Quotients of polynomial functors.\n\nRoughly speaking, saying that `F` is a quotient of a polynomial functor means that for each `α`,\nelements of `F α` are represented by pairs `⟨a, f⟩`, where `a` is the shape of the object and\n`f` indexes the relevant elements of `α`, in a suitably natural manner.\n-/\nclass QPF (F : Type u → Type u) extends Functor F where\n  P : PFunctor.{u}\n  abs : ∀ {α}, P α → F α\n  repr : ∀ {α}, F α → P α\n  abs_repr : ∀ {α} (x : F α), abs (repr x) = x\n  abs_map : ∀ {α β} (f : α → β) (p : P α), abs (P.map f p) = f <$> abs p\n\n"}
{"name":"QPF.abs_map","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nself : QPF F\nα β : Type u\nf : α → β\np : ↑(QPF.P F) α\n⊢ Eq (QPF.abs ((QPF.P F).map f p)) (Functor.map f (QPF.abs p))","decl":"/-- Quotients of polynomial functors.\n\nRoughly speaking, saying that `F` is a quotient of a polynomial functor means that for each `α`,\nelements of `F α` are represented by pairs `⟨a, f⟩`, where `a` is the shape of the object and\n`f` indexes the relevant elements of `α`, in a suitably natural manner.\n-/\nclass QPF (F : Type u → Type u) extends Functor F where\n  P : PFunctor.{u}\n  abs : ∀ {α}, P α → F α\n  repr : ∀ {α}, F α → P α\n  abs_repr : ∀ {α} (x : F α), abs (repr x) = x\n  abs_map : ∀ {α β} (f : α → β) (p : P α), abs (P.map f p) = f <$> abs p\n\n"}
{"name":"QPF.id_map","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nα : Type u\nx : F α\n⊢ Eq (Functor.map id x) x","decl":"theorem id_map {α : Type _} (x : F α) : id <$> x = x := by\n  rw [← abs_repr x]\n  cases' repr x with a f\n  rw [← abs_map]\n  rfl\n\n"}
{"name":"QPF.comp_map","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nα β γ : Type u\nf : α → β\ng : β → γ\nx : F α\n⊢ Eq (Functor.map (Function.comp g f) x) (Functor.map g (Functor.map f x))","decl":"theorem comp_map {α β γ : Type _} (f : α → β) (g : β → γ) (x : F α) :\n    (g ∘ f) <$> x = g <$> f <$> x := by\n  rw [← abs_repr x]\n  cases' repr x with a f\n  rw [← abs_map, ← abs_map, ← abs_map]\n  rfl\n\n"}
{"name":"QPF.lawfulFunctor","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nh : ∀ (α β : Type u), Eq Functor.mapConst (Function.comp Functor.map (Function.const β))\n⊢ LawfulFunctor F","decl":"theorem lawfulFunctor\n    (h : ∀ α β : Type u, @Functor.mapConst F _ α _ = Functor.map ∘ Function.const β) :\n    LawfulFunctor F :=\n  { map_const := @h\n    id_map := @id_map F _\n    comp_map := @comp_map F _ }\n\n/-\nLifting predicates and relations\n-/\n"}
{"name":"QPF.liftp_iff","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nα : Type u\np : α → Prop\nx : F α\n⊢ Iff (Functor.Liftp p x) (Exists fun a => Exists fun f => And (Eq x (QPF.abs ⟨a, f⟩)) (∀ (i : (QPF.P F).B a), p (f i)))","decl":"theorem liftp_iff {α : Type u} (p : α → Prop) (x : F α) :\n    Liftp p x ↔ ∃ a f, x = abs ⟨a, f⟩ ∧ ∀ i, p (f i) := by\n  constructor\n  · rintro ⟨y, hy⟩\n    cases' h : repr y with a f\n    use a, fun i => (f i).val\n    constructor\n    · rw [← hy, ← abs_repr y, h, ← abs_map]\n      rfl\n    intro i\n    apply (f i).property\n  rintro ⟨a, f, h₀, h₁⟩\n  use abs ⟨a, fun i => ⟨f i, h₁ i⟩⟩\n  rw [← abs_map, h₀]; rfl\n\n"}
{"name":"QPF.liftp_iff'","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nα : Type u\np : α → Prop\nx : F α\n⊢ Iff (Functor.Liftp p x) (Exists fun u => And (Eq (QPF.abs u) x) (∀ (i : (QPF.P F).B u.fst), p (u.snd i)))","decl":"theorem liftp_iff' {α : Type u} (p : α → Prop) (x : F α) :\n    Liftp p x ↔ ∃ u : q.P α, abs u = x ∧ ∀ i, p (u.snd i) := by\n  constructor\n  · rintro ⟨y, hy⟩\n    cases' h : repr y with a f\n    use ⟨a, fun i => (f i).val⟩\n    dsimp\n    constructor\n    · rw [← hy, ← abs_repr y, h, ← abs_map]\n      rfl\n    intro i\n    apply (f i).property\n  rintro ⟨⟨a, f⟩, h₀, h₁⟩; dsimp at *\n  use abs ⟨a, fun i => ⟨f i, h₁ i⟩⟩\n  rw [← abs_map, ← h₀]; rfl\n\n"}
{"name":"QPF.liftr_iff","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nα : Type u\nr : α → α → Prop\nx y : F α\n⊢ Iff (Functor.Liftr r x y) (Exists fun a => Exists fun f₀ => Exists fun f₁ => And (Eq x (QPF.abs ⟨a, f₀⟩)) (And (Eq y (QPF.abs ⟨a, f₁⟩)) (∀ (i : (QPF.P F).B a), r (f₀ i) (f₁ i))))","decl":"theorem liftr_iff {α : Type u} (r : α → α → Prop) (x y : F α) :\n    Liftr r x y ↔ ∃ a f₀ f₁, x = abs ⟨a, f₀⟩ ∧ y = abs ⟨a, f₁⟩ ∧ ∀ i, r (f₀ i) (f₁ i) := by\n  constructor\n  · rintro ⟨u, xeq, yeq⟩\n    cases' h : repr u with a f\n    use a, fun i => (f i).val.fst, fun i => (f i).val.snd\n    constructor\n    · rw [← xeq, ← abs_repr u, h, ← abs_map]\n      rfl\n    constructor\n    · rw [← yeq, ← abs_repr u, h, ← abs_map]\n      rfl\n    intro i\n    exact (f i).property\n  rintro ⟨a, f₀, f₁, xeq, yeq, h⟩\n  use abs ⟨a, fun i => ⟨(f₀ i, f₁ i), h i⟩⟩\n  constructor\n  · rw [xeq, ← abs_map]\n    rfl\n  rw [yeq, ← abs_map]; rfl\n\n"}
{"name":"QPF.recF_eq","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nα : Type u\ng : F α → α\nx : (QPF.P F).W\n⊢ Eq (QPF.recF g x) (g (QPF.abs ((QPF.P F).map (QPF.recF g) x.dest)))","decl":"theorem recF_eq {α : Type _} (g : F α → α) (x : q.P.W) :\n    recF g x = g (abs (q.P.map (recF g) x.dest)) := by\n  cases x\n  rfl\n\n"}
{"name":"QPF.recF_eq'","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nα : Type u\ng : F α → α\na : (QPF.P F).A\nf : (QPF.P F).B a → (QPF.P F).W\n⊢ Eq (QPF.recF g (WType.mk a f)) (g (QPF.abs ((QPF.P F).map (QPF.recF g) ⟨a, f⟩)))","decl":"theorem recF_eq' {α : Type _} (g : F α → α) (a : q.P.A) (f : q.P.B a → q.P.W) :\n    recF g ⟨a, f⟩ = g (abs (q.P.map (recF g) ⟨a, f⟩)) :=\n  rfl\n\n"}
{"name":"QPF.recF_eq_of_Wequiv","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nα : Type u\nu : F α → α\nx y : (QPF.P F).W\na✝ : QPF.Wequiv x y\n⊢ Eq (QPF.recF u x) (QPF.recF u y)","decl":"/-- `recF` is insensitive to the representation -/\ntheorem recF_eq_of_Wequiv {α : Type u} (u : F α → α) (x y : q.P.W) :\n    Wequiv x y → recF u x = recF u y := by\n  intro h\n  induction h with\n  | ind a f f' _ ih => simp only [recF_eq', PFunctor.map_eq, Function.comp_def, ih]\n  | abs a f a' f' h => simp only [recF_eq', abs_map, h]\n  | trans x y z _ _ ih₁ ih₂ => exact Eq.trans ih₁ ih₂\n\n"}
{"name":"QPF.Wequiv.abs'","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nx y : (QPF.P F).W\nh : Eq (QPF.abs x.dest) (QPF.abs y.dest)\n⊢ QPF.Wequiv x y","decl":"theorem Wequiv.abs' (x y : q.P.W) (h : QPF.abs x.dest = QPF.abs y.dest) : Wequiv x y := by\n  cases x\n  cases y\n  apply Wequiv.abs\n  apply h\n\n"}
{"name":"QPF.Wequiv.refl","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nx : (QPF.P F).W\n⊢ QPF.Wequiv x x","decl":"theorem Wequiv.refl (x : q.P.W) : Wequiv x x := by\n  cases' x with a f\n  exact Wequiv.abs a f a f rfl\n\n"}
{"name":"QPF.Wequiv.symm","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nx y : (QPF.P F).W\na✝ : QPF.Wequiv x y\n⊢ QPF.Wequiv y x","decl":"theorem Wequiv.symm (x y : q.P.W) : Wequiv x y → Wequiv y x := by\n  intro h\n  induction h with\n  | ind a f f' _ ih => exact Wequiv.ind _ _ _ ih\n  | abs a f a' f' h => exact Wequiv.abs _ _ _ _ h.symm\n  | trans x y z _ _ ih₁ ih₂ => exact QPF.Wequiv.trans _ _ _ ih₂ ih₁\n\n"}
{"name":"QPF.Wrepr_equiv","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nx : (QPF.P F).W\n⊢ QPF.Wequiv (QPF.Wrepr x) x","decl":"theorem Wrepr_equiv (x : q.P.W) : Wequiv (Wrepr x) x := by\n  induction' x with a f ih\n  apply Wequiv.trans\n  · change Wequiv (Wrepr ⟨a, f⟩) (PFunctor.W.mk (q.P.map Wrepr ⟨a, f⟩))\n    apply Wequiv.abs'\n    have : Wrepr ⟨a, f⟩ = PFunctor.W.mk (repr (abs (q.P.map Wrepr ⟨a, f⟩))) := rfl\n    rw [this, PFunctor.W.dest_mk, abs_repr]\n    rfl\n  apply Wequiv.ind; exact ih\n\n"}
{"name":"QPF.Fix.rec_eq","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nα : Type u\ng : F α → α\nx : F (QPF.Fix F)\n⊢ Eq (QPF.Fix.rec g (QPF.Fix.mk x)) (g (Functor.map (QPF.Fix.rec g) x))","decl":"theorem Fix.rec_eq {α : Type _} (g : F α → α) (x : F (Fix F)) :\n    Fix.rec g (Fix.mk x) = g (Fix.rec g <$> x) := by\n  have : recF g ∘ fixToW = Fix.rec g := by\n    ext ⟨x⟩\n    apply recF_eq_of_Wequiv\n    rw [fixToW]\n    apply Wrepr_equiv\n  conv =>\n    lhs\n    rw [Fix.rec, Fix.mk]\n    dsimp\n  cases' h : repr x with a f\n  rw [PFunctor.map_eq, recF_eq, ← PFunctor.map_eq, PFunctor.W.dest_mk, PFunctor.map_map, abs_map,\n    ← h, abs_repr, this]\n\n"}
{"name":"QPF.Fix.ind_aux","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\na : (QPF.P F).A\nf : (QPF.P F).B a → (QPF.P F).W\n⊢ Eq (QPF.Fix.mk (QPF.abs ⟨a, fun x => Quotient.mk QPF.Wsetoid (f x)⟩)) (Quotient.mk QPF.Wsetoid (WType.mk a f))","decl":"theorem Fix.ind_aux (a : q.P.A) (f : q.P.B a → q.P.W) :\n    Fix.mk (abs ⟨a, fun x => ⟦f x⟧⟩) = ⟦⟨a, f⟩⟧ := by\n  have : Fix.mk (abs ⟨a, fun x => ⟦f x⟧⟩) = ⟦Wrepr ⟨a, f⟩⟧ := by\n    apply Quot.sound; apply Wequiv.abs'\n    rw [PFunctor.W.dest_mk, abs_map, abs_repr, ← abs_map, PFunctor.map_eq]\n    simp only [Wrepr, recF_eq, PFunctor.W.dest_mk, abs_repr, Function.comp]\n    rfl\n  rw [this]\n  apply Quot.sound\n  apply Wrepr_equiv\n\n"}
{"name":"QPF.Fix.ind_rec","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nα : Type u\ng₁ g₂ : QPF.Fix F → α\nh : ∀ (x : F (QPF.Fix F)), Eq (Functor.map g₁ x) (Functor.map g₂ x) → Eq (g₁ (QPF.Fix.mk x)) (g₂ (QPF.Fix.mk x))\nx : QPF.Fix F\n⊢ Eq (g₁ x) (g₂ x)","decl":"theorem Fix.ind_rec {α : Type u} (g₁ g₂ : Fix F → α)\n    (h : ∀ x : F (Fix F), g₁ <$> x = g₂ <$> x → g₁ (Fix.mk x) = g₂ (Fix.mk x)) :\n    ∀ x, g₁ x = g₂ x := by\n  rintro ⟨x⟩\n  induction' x with a f ih\n  change g₁ ⟦⟨a, f⟩⟧ = g₂ ⟦⟨a, f⟩⟧\n  rw [← Fix.ind_aux a f]; apply h\n  rw [← abs_map, ← abs_map, PFunctor.map_eq, PFunctor.map_eq]\n  congr with x\n  apply ih\n\n"}
{"name":"QPF.Fix.rec_unique","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nα : Type u\ng : F α → α\nh : QPF.Fix F → α\nhyp : ∀ (x : F (QPF.Fix F)), Eq (h (QPF.Fix.mk x)) (g (Functor.map h x))\n⊢ Eq (QPF.Fix.rec g) h","decl":"theorem Fix.rec_unique {α : Type u} (g : F α → α) (h : Fix F → α)\n    (hyp : ∀ x, h (Fix.mk x) = g (h <$> x)) : Fix.rec g = h := by\n  ext x\n  apply Fix.ind_rec\n  intro x hyp'\n  rw [hyp, ← hyp', Fix.rec_eq]\n\n"}
{"name":"QPF.Fix.mk_dest","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nx : QPF.Fix F\n⊢ Eq (QPF.Fix.mk x.dest) x","decl":"theorem Fix.mk_dest (x : Fix F) : Fix.mk (Fix.dest x) = x := by\n  change (Fix.mk ∘ Fix.dest) x = id x\n  apply Fix.ind_rec (mk ∘ dest) id\n  intro x\n  rw [Function.comp_apply, id_eq, Fix.dest, Fix.rec_eq, id_map, comp_map]\n  intro h\n  rw [h]\n\n"}
{"name":"QPF.Fix.dest_mk","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nx : F (QPF.Fix F)\n⊢ Eq (QPF.Fix.mk x).dest x","decl":"theorem Fix.dest_mk (x : F (Fix F)) : Fix.dest (Fix.mk x) = x := by\n  unfold Fix.dest; rw [Fix.rec_eq, ← Fix.dest, ← comp_map]\n  conv =>\n    rhs\n    rw [← id_map x]\n  congr with x\n  apply Fix.mk_dest\n\n"}
{"name":"QPF.Fix.ind","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\np : QPF.Fix F → Prop\nh : ∀ (x : F (QPF.Fix F)), Functor.Liftp p x → p (QPF.Fix.mk x)\nx : QPF.Fix F\n⊢ p x","decl":"theorem Fix.ind (p : Fix F → Prop) (h : ∀ x : F (Fix F), Liftp p x → p (Fix.mk x)) : ∀ x, p x := by\n  rintro ⟨x⟩\n  induction' x with a f ih\n  change p ⟦⟨a, f⟩⟧\n  rw [← Fix.ind_aux a f]\n  apply h\n  rw [liftp_iff]\n  refine ⟨_, _, rfl, ?_⟩\n  convert ih\n\n"}
{"name":"QPF.corecF_eq","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nα : Type u\ng : α → F α\nx : α\n⊢ Eq (QPF.corecF g x).dest ((QPF.P F).map (QPF.corecF g) (QPF.repr (g x)))","decl":"theorem corecF_eq {α : Type _} (g : α → F α) (x : α) :\n    PFunctor.M.dest (corecF g x) = q.P.map (corecF g) (repr (g x)) := by\n  rw [corecF, PFunctor.M.dest_corec]\n\n-- Equivalence\n"}
{"name":"QPF.Cofix.dest_corec","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nα : Type u\ng : α → F α\nx : α\n⊢ Eq (QPF.Cofix.corec g x).dest (Functor.map (QPF.Cofix.corec g) (g x))","decl":"theorem Cofix.dest_corec {α : Type u} (g : α → F α) (x : α) :\n    Cofix.dest (Cofix.corec g x) = Cofix.corec g <$> g x := by\n  conv =>\n    lhs\n    rw [Cofix.dest, Cofix.corec]\n  dsimp\n  rw [corecF_eq, abs_map, abs_repr, ← comp_map]; rfl\n\n"}
{"name":"QPF.Cofix.bisim_rel","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nr : QPF.Cofix F → QPF.Cofix F → Prop\nh : ∀ (x y : QPF.Cofix F), r x y → Eq (Functor.map (Quot.mk r) x.dest) (Functor.map (Quot.mk r) y.dest)\nx y : QPF.Cofix F\na✝ : r x y\n⊢ Eq x y","decl":"theorem Cofix.bisim_rel (r : Cofix F → Cofix F → Prop)\n    (h : ∀ x y, r x y → Quot.mk r <$> Cofix.dest x = Quot.mk r <$> Cofix.dest y) :\n    ∀ x y, r x y → x = y := by\n  let r' (x y) := x = y ∨ r x y\n  intro x y rxy\n  apply Cofix.bisim_aux r'\n  · intro x\n    left\n    rfl\n  · intro x y r'xy\n    cases' r'xy with r'xy r'xy\n    · rw [r'xy]\n    have : ∀ x y, r x y → r' x y := fun x y h => Or.inr h\n    rw [← Quot.factor_mk_eq _ _ this]\n    dsimp [r']\n    rw [@comp_map _ q _ _ _ (Quot.mk r), @comp_map _ q _ _ _ (Quot.mk r)]\n    rw [h _ _ r'xy]\n  right; exact rxy\n\n"}
{"name":"QPF.Cofix.bisim","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nr : QPF.Cofix F → QPF.Cofix F → Prop\nh : ∀ (x y : QPF.Cofix F), r x y → Functor.Liftr r x.dest y.dest\nx y : QPF.Cofix F\na✝ : r x y\n⊢ Eq x y","decl":"theorem Cofix.bisim (r : Cofix F → Cofix F → Prop)\n    (h : ∀ x y, r x y → Liftr r (Cofix.dest x) (Cofix.dest y)) : ∀ x y, r x y → x = y := by\n  apply Cofix.bisim_rel\n  intro x y rxy\n  rcases (liftr_iff r _ _).mp (h x y rxy) with ⟨a, f₀, f₁, dxeq, dyeq, h'⟩\n  rw [dxeq, dyeq, ← abs_map, ← abs_map, PFunctor.map_eq, PFunctor.map_eq]\n  congr 2 with i\n  apply Quot.sound\n  apply h'\n\n"}
{"name":"QPF.Cofix.bisim'","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nα : Type u_1\nQ : α → Prop\nu v : α → QPF.Cofix F\nh : ∀ (x : α), Q x → Exists fun a => Exists fun f => Exists fun f' => And (Eq (u x).dest (QPF.abs ⟨a, f⟩)) (And (Eq (v x).dest (QPF.abs ⟨a, f'⟩)) (∀ (i : (QPF.P F).B a), Exists fun x' => And (Q x') (And (Eq (f i) (u x')) (Eq (f' i) (v x')))))\nx : α\na✝ : Q x\n⊢ Eq (u x) (v x)","decl":"theorem Cofix.bisim' {α : Type*} (Q : α → Prop) (u v : α → Cofix F)\n    (h : ∀ x, Q x → ∃ a f f', Cofix.dest (u x) = abs ⟨a, f⟩ ∧ Cofix.dest (v x) = abs ⟨a, f'⟩ ∧\n      ∀ i, ∃ x', Q x' ∧ f i = u x' ∧ f' i = v x') :\n    ∀ x, Q x → u x = v x := fun x Qx =>\n  let R := fun w z : Cofix F => ∃ x', Q x' ∧ w = u x' ∧ z = v x'\n  Cofix.bisim R\n    (fun x y ⟨x', Qx', xeq, yeq⟩ => by\n      rcases h x' Qx' with ⟨a, f, f', ux'eq, vx'eq, h'⟩\n      rw [liftr_iff]\n      exact ⟨a, f, f', xeq.symm ▸ ux'eq, yeq.symm ▸ vx'eq, h'⟩)\n    _ _ ⟨x, Qx, rfl, rfl⟩\n\n"}
{"name":"QPF.mem_supp","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nα : Type u\nx : F α\nu : α\n⊢ Iff (Membership.mem (Functor.supp x) u) (∀ (a : (QPF.P F).A) (f : (QPF.P F).B a → α), Eq (QPF.abs ⟨a, f⟩) x → Membership.mem (Set.image f Set.univ) u)","decl":"theorem mem_supp {α : Type u} (x : F α) (u : α) :\n    u ∈ supp x ↔ ∀ a f, abs ⟨a, f⟩ = x → u ∈ f '' univ := by\n  rw [supp]; dsimp; constructor\n  · intro h a f haf\n    have : Liftp (fun u => u ∈ f '' univ) x := by\n      rw [liftp_iff]\n      exact ⟨a, f, haf.symm, fun i => mem_image_of_mem _ (mem_univ _)⟩\n    exact h this\n  intro h p; rw [liftp_iff]\n  rintro ⟨a, f, xeq, h'⟩\n  rcases h a f xeq.symm with ⟨i, _, hi⟩\n  rw [← hi]; apply h'\n\n"}
{"name":"QPF.supp_eq","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nα : Type u\nx : F α\n⊢ Eq (Functor.supp x) (setOf fun u => ∀ (a : (QPF.P F).A) (f : (QPF.P F).B a → α), Eq (QPF.abs ⟨a, f⟩) x → Membership.mem (Set.image f Set.univ) u)","decl":"theorem supp_eq {α : Type u} (x : F α) :\n    supp x = { u | ∀ a f, abs ⟨a, f⟩ = x → u ∈ f '' univ } := by\n  ext\n  apply mem_supp\n\n"}
{"name":"QPF.has_good_supp_iff","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nα : Type u\nx : F α\n⊢ Iff (∀ (p : α → Prop), Iff (Functor.Liftp p x) (∀ (u : α), Membership.mem (Functor.supp x) u → p u)) (Exists fun a => Exists fun f => And (Eq (QPF.abs ⟨a, f⟩) x) (∀ (a' : (QPF.P F).A) (f' : (QPF.P F).B a' → α), Eq (QPF.abs ⟨a', f'⟩) x → HasSubset.Subset (Set.image f Set.univ) (Set.image f' Set.univ)))","decl":"theorem has_good_supp_iff {α : Type u} (x : F α) :\n    (∀ p, Liftp p x ↔ ∀ u ∈ supp x, p u) ↔\n      ∃ a f, abs ⟨a, f⟩ = x ∧ ∀ a' f', abs ⟨a', f'⟩ = x → f '' univ ⊆ f' '' univ := by\n  constructor\n  · intro h\n    have : Liftp (supp x) x := by rw [h]; intro u; exact id\n    rw [liftp_iff] at this\n    rcases this with ⟨a, f, xeq, h'⟩\n    refine ⟨a, f, xeq.symm, ?_⟩\n    intro a' f' h''\n    rintro u ⟨i, _, hfi⟩\n    have : u ∈ supp x := by rw [← hfi]; apply h'\n    exact (mem_supp x u).mp this _ _ h''\n  rintro ⟨a, f, xeq, h⟩ p; rw [liftp_iff]; constructor\n  · rintro ⟨a', f', xeq', h'⟩ u usuppx\n    rcases (mem_supp x u).mp usuppx a' f' xeq'.symm with ⟨i, _, f'ieq⟩\n    rw [← f'ieq]\n    apply h'\n  intro h'\n  refine ⟨a, f, xeq.symm, ?_⟩; intro i\n  apply h'; rw [mem_supp]\n  intro a' f' xeq'\n  apply h a' f' xeq'\n  apply mem_image_of_mem _ (mem_univ _)\n\n"}
{"name":"QPF.supp_eq_of_isUniform","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nh : QPF.IsUniform\nα : Type u\na : (QPF.P F).A\nf : (QPF.P F).B a → α\n⊢ Eq (Functor.supp (QPF.abs ⟨a, f⟩)) (Set.image f Set.univ)","decl":"theorem supp_eq_of_isUniform (h : q.IsUniform) {α : Type u} (a : q.P.A) (f : q.P.B a → α) :\n    supp (abs ⟨a, f⟩) = f '' univ := by\n  ext u; rw [mem_supp]; constructor\n  · intro h'\n    apply h' _ _ rfl\n  intro h' a' f' e\n  rw [← h _ _ _ _ e.symm]; apply h'\n\n"}
{"name":"QPF.liftp_iff_of_isUniform","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nh : QPF.IsUniform\nα : Type u\nx : F α\np : α → Prop\n⊢ Iff (Functor.Liftp p x) (∀ (u : α), Membership.mem (Functor.supp x) u → p u)","decl":"theorem liftp_iff_of_isUniform (h : q.IsUniform) {α : Type u} (x : F α) (p : α → Prop) :\n    Liftp p x ↔ ∀ u ∈ supp x, p u := by\n  rw [liftp_iff, ← abs_repr x]\n  cases' repr x with a f; constructor\n  · rintro ⟨a', f', abseq, hf⟩ u\n    rw [supp_eq_of_isUniform h, h _ _ _ _ abseq]\n    rintro ⟨i, _, hi⟩\n    rw [← hi]\n    apply hf\n  intro h'\n  refine ⟨a, f, rfl, fun i => h' _ ?_⟩\n  rw [supp_eq_of_isUniform h]\n  exact ⟨i, mem_univ i, rfl⟩\n\n"}
{"name":"QPF.supp_map","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\nh : QPF.IsUniform\nα β : Type u\ng : α → β\nx : F α\n⊢ Eq (Functor.supp (Functor.map g x)) (Set.image g (Functor.supp x))","decl":"theorem supp_map (h : q.IsUniform) {α β : Type u} (g : α → β) (x : F α) :\n    supp (g <$> x) = g '' supp x := by\n  rw [← abs_repr x]; cases' repr x with a f; rw [← abs_map, PFunctor.map_eq]\n  rw [supp_eq_of_isUniform h, supp_eq_of_isUniform h, image_comp]\n\n"}
{"name":"QPF.suppPreservation_iff_uniform","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\n⊢ Iff QPF.SuppPreservation QPF.IsUniform","decl":"theorem suppPreservation_iff_uniform : q.SuppPreservation ↔ q.IsUniform := by\n  constructor\n  · intro h α a a' f f' h'\n    rw [← PFunctor.supp_eq, ← PFunctor.supp_eq, ← h, h', h]\n  · rintro h α ⟨a, f⟩\n    rwa [supp_eq_of_isUniform, PFunctor.supp_eq]\n\n"}
{"name":"QPF.suppPreservation_iff_liftpPreservation","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\n⊢ Iff QPF.SuppPreservation QPF.LiftpPreservation","decl":"theorem suppPreservation_iff_liftpPreservation : q.SuppPreservation ↔ q.LiftpPreservation := by\n  constructor <;> intro h\n  · rintro α p ⟨a, f⟩\n    have h' := h\n    rw [suppPreservation_iff_uniform] at h'\n    dsimp only [SuppPreservation, supp] at h\n    rw [liftp_iff_of_isUniform h', supp_eq_of_isUniform h', PFunctor.liftp_iff']\n    simp only [image_univ, mem_range, exists_imp]\n    constructor <;> intros <;> subst_vars <;> solve_by_elim\n  · rintro α ⟨a, f⟩\n    simp only [LiftpPreservation] at h\n    simp only [supp, h]\n\n"}
{"name":"QPF.liftpPreservation_iff_uniform","module":"Mathlib.Data.QPF.Univariate.Basic","initialProofState":"F : Type u → Type u\nq : QPF F\n⊢ Iff QPF.LiftpPreservation QPF.IsUniform","decl":"theorem liftpPreservation_iff_uniform : q.LiftpPreservation ↔ q.IsUniform := by\n  rw [← suppPreservation_iff_liftpPreservation, suppPreservation_iff_uniform]\n\n"}
