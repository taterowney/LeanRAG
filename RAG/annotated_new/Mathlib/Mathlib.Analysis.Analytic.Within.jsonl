{"name":"analyticWithinAt_of_singleton_mem","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nx : E\nh : Membership.mem (nhdsWithin x s) (Singleton.singleton x)\n⊢ AnalyticWithinAt 𝕜 f s x","decl":"/-- `AnalyticWithinAt` is trivial if `{x} ∈ 𝓝[s] x` -/\nlemma analyticWithinAt_of_singleton_mem {f : E → F} {s : Set E} {x : E} (h : {x} ∈ 𝓝[s] x) :\n    AnalyticWithinAt 𝕜 f s x := by\n  rcases mem_nhdsWithin.mp h with ⟨t, ot, xt, st⟩\n  rcases Metric.mem_nhds_iff.mp (ot.mem_nhds xt) with ⟨r, r0, rt⟩\n  exact ⟨constFormalMultilinearSeries 𝕜 E (f x), .ofReal r,\n  { r_le := by simp only [FormalMultilinearSeries.constFormalMultilinearSeries_radius, le_top]\n    r_pos := by positivity\n    hasSum := by\n      intro y ys yr\n      simp only [subset_singleton_iff, mem_inter_iff, and_imp] at st\n      simp only [mem_insert_iff, add_right_eq_self] at ys\n      have : x + y = x := by\n        rcases ys with rfl | ys\n        · simp\n        · exact st (x + y) (rt (by simpa using yr)) ys\n      simp only [this]\n      apply (hasFPowerSeriesOnBall_const (e := 0)).hasSum\n      simp only [Metric.emetric_ball_top, mem_univ] }⟩\n\n"}
{"name":"analyticOn_of_locally_analyticOn","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nh : ∀ (x : E), Membership.mem s x → Exists fun u => And (IsOpen u) (And (Membership.mem u x) (AnalyticOn 𝕜 f (Inter.inter s u)))\n⊢ AnalyticOn 𝕜 f s","decl":"/-- If `f` is `AnalyticOn` near each point in a set, it is `AnalyticOn` the set -/\nlemma analyticOn_of_locally_analyticOn {f : E → F} {s : Set E}\n    (h : ∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ AnalyticOn 𝕜 f (s ∩ u)) :\n    AnalyticOn 𝕜 f s := by\n  intro x m\n  rcases h x m with ⟨u, ou, xu, fu⟩\n  rcases Metric.mem_nhds_iff.mp (ou.mem_nhds xu) with ⟨r, r0, ru⟩\n  rcases fu x ⟨m, xu⟩ with ⟨p, t, fp⟩\n  exact ⟨p, min (.ofReal r) t,\n    { r_pos := lt_min (by positivity) fp.r_pos\n      r_le := min_le_of_right_le fp.r_le\n      hasSum := by\n        intro y ys yr\n        simp only [EMetric.mem_ball, lt_min_iff, edist_lt_ofReal, dist_zero_right] at yr\n        apply fp.hasSum\n        · simp only [mem_insert_iff, add_right_eq_self] at ys\n          rcases ys with rfl | ys\n          · simp\n          · simp only [mem_insert_iff, add_right_eq_self, mem_inter_iff, ys, true_and]\n            apply Or.inr (ru ?_)\n            simp only [Metric.mem_ball, dist_self_add_left, yr]\n        · simp only [EMetric.mem_ball, yr] }⟩\n\n"}
{"name":"analyticWithinOn_of_locally_analyticWithinOn","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nh : ∀ (x : E), Membership.mem s x → Exists fun u => And (IsOpen u) (And (Membership.mem u x) (AnalyticOn 𝕜 f (Inter.inter s u)))\n⊢ AnalyticOn 𝕜 f s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias analyticWithinOn_of_locally_analyticWithinOn := analyticOn_of_locally_analyticOn\n\n"}
{"name":"IsOpen.analyticOn_iff_analyticOnNhd","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nhs : IsOpen s\n⊢ Iff (AnalyticOn 𝕜 f s) (AnalyticOnNhd 𝕜 f s)","decl":"/-- On open sets, `AnalyticOnNhd` and `AnalyticOn` coincide -/\nlemma IsOpen.analyticOn_iff_analyticOnNhd {f : E → F} {s : Set E} (hs : IsOpen s) :\n    AnalyticOn 𝕜 f s ↔ AnalyticOnNhd 𝕜 f s := by\n  refine ⟨?_, AnalyticOnNhd.analyticOn⟩\n  intro hf x m\n  rcases Metric.mem_nhds_iff.mp (hs.mem_nhds m) with ⟨r, r0, rs⟩\n  rcases hf x m with ⟨p, t, fp⟩\n  exact ⟨p, min (.ofReal r) t,\n  { r_pos := lt_min (by positivity) fp.r_pos\n    r_le := min_le_of_right_le fp.r_le\n    hasSum := by\n      intro y ym\n      simp only [EMetric.mem_ball, lt_min_iff, edist_lt_ofReal, dist_zero_right] at ym\n      refine fp.hasSum ?_ ym.2\n      apply mem_insert_of_mem\n      apply rs\n      simp only [Metric.mem_ball, dist_self_add_left, ym.1] }⟩\n\n"}
{"name":"IsOpen.analyticWithinOn_iff_analyticOn","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\ns : Set E\nhs : IsOpen s\n⊢ Iff (AnalyticOn 𝕜 f s) (AnalyticOnNhd 𝕜 f s)","decl":"@[deprecated (since := \"2024-09-26\")]\nalias IsOpen.analyticWithinOn_iff_analyticOn := IsOpen.analyticOn_iff_analyticOnNhd\n\n\n"}
{"name":"hasFPowerSeriesWithinOnBall_iff_exists_hasFPowerSeriesOnBall","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\nr : ENNReal\n⊢ Iff (HasFPowerSeriesWithinOnBall f p s x r) (Exists fun g => And (Set.EqOn f g (Inter.inter (Insert.insert x s) (EMetric.ball x r))) (HasFPowerSeriesOnBall g p x r))","decl":"set_option linter.style.multiGoal false in\n/-- `f` has power series `p` at `x` iff some local extension of `f` has that series -/\nlemma hasFPowerSeriesWithinOnBall_iff_exists_hasFPowerSeriesOnBall [CompleteSpace F] {f : E → F}\n    {p : FormalMultilinearSeries 𝕜 E F} {s : Set E} {x : E} {r : ℝ≥0∞} :\n    HasFPowerSeriesWithinOnBall f p s x r ↔\n      ∃ g, EqOn f g (insert x s ∩ EMetric.ball x r) ∧\n        HasFPowerSeriesOnBall g p x r := by\n  constructor\n  · intro h\n    refine ⟨fun y ↦ p.sum (y - x), ?_, ?_⟩\n    · intro y ⟨ys,yb⟩\n      simp only [EMetric.mem_ball, edist_eq_enorm_sub] at yb\n      have e0 := p.hasSum (x := y - x) ?_\n      have e1 := (h.hasSum (y := y - x) ?_ ?_)\n      · simp only [add_sub_cancel] at e1\n        exact e1.unique e0\n      · simpa only [add_sub_cancel]\n      · simpa only [EMetric.mem_ball, edist_zero_eq_enorm]\n      · simp only [EMetric.mem_ball, edist_zero_eq_enorm]\n        exact lt_of_lt_of_le yb h.r_le\n    · refine ⟨h.r_le, h.r_pos, ?_⟩\n      intro y lt\n      simp only [add_sub_cancel_left]\n      apply p.hasSum\n      simp only [EMetric.mem_ball] at lt ⊢\n      exact lt_of_lt_of_le lt h.r_le\n  · intro ⟨g, hfg, hg⟩\n    refine ⟨hg.r_le, hg.r_pos, ?_⟩\n    intro y ys lt\n    rw [hfg]\n    · exact hg.hasSum lt\n    · refine ⟨ys, ?_⟩\n      simpa only [EMetric.mem_ball, edist_eq_enorm_sub, add_sub_cancel_left, sub_zero] using lt\n\n"}
{"name":"hasFPowerSeriesWithinAt_iff_exists_hasFPowerSeriesAt","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace F\nf : E → F\np : FormalMultilinearSeries 𝕜 E F\ns : Set E\nx : E\n⊢ Iff (HasFPowerSeriesWithinAt f p s x) (Exists fun g => And ((nhdsWithin x (Insert.insert x s)).EventuallyEq f g) (HasFPowerSeriesAt g p x))","decl":"/-- `f` has power series `p` at `x` iff some local extension of `f` has that series -/\nlemma hasFPowerSeriesWithinAt_iff_exists_hasFPowerSeriesAt [CompleteSpace F] {f : E → F}\n    {p : FormalMultilinearSeries 𝕜 E F} {s : Set E} {x : E} :\n    HasFPowerSeriesWithinAt f p s x ↔\n      ∃ g, f =ᶠ[𝓝[insert x s] x] g ∧ HasFPowerSeriesAt g p x := by\n  constructor\n  · intro ⟨r, h⟩\n    rcases hasFPowerSeriesWithinOnBall_iff_exists_hasFPowerSeriesOnBall.mp h with ⟨g, e, h⟩\n    refine ⟨g, ?_, ⟨r, h⟩⟩\n    refine Filter.eventuallyEq_iff_exists_mem.mpr ⟨_, ?_, e⟩\n    exact inter_mem_nhdsWithin _ (EMetric.ball_mem_nhds _ h.r_pos)\n  · intro ⟨g, hfg, ⟨r, hg⟩⟩\n    simp only [eventuallyEq_nhdsWithin_iff, Metric.eventually_nhds_iff] at hfg\n    rcases hfg with ⟨e, e0, hfg⟩\n    refine ⟨min r (.ofReal e), ?_⟩\n    refine hasFPowerSeriesWithinOnBall_iff_exists_hasFPowerSeriesOnBall.mpr ⟨g, ?_, ?_⟩\n    · intro y ⟨ys, xy⟩\n      refine hfg ?_ ys\n      simp only [EMetric.mem_ball, lt_min_iff, edist_lt_ofReal] at xy\n      exact xy.2\n    · exact hg.mono (lt_min hg.r_pos (by positivity)) (min_le_left _ _)\n\n"}
{"name":"analyticWithinAt_iff_exists_analyticAt","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace F\nf : E → F\ns : Set E\nx : E\n⊢ Iff (AnalyticWithinAt 𝕜 f s x) (Exists fun g => And ((nhdsWithin x (Insert.insert x s)).EventuallyEq f g) (AnalyticAt 𝕜 g x))","decl":"/-- `f` is analytic within `s` at `x` iff some local extension of `f` is analytic at `x` -/\nlemma analyticWithinAt_iff_exists_analyticAt [CompleteSpace F] {f : E → F} {s : Set E} {x : E} :\n    AnalyticWithinAt 𝕜 f s x ↔\n      ∃ g, f =ᶠ[𝓝[insert x s] x] g ∧ AnalyticAt 𝕜 g x := by\n  simp only [AnalyticWithinAt, AnalyticAt, hasFPowerSeriesWithinAt_iff_exists_hasFPowerSeriesAt]\n  tauto\n\n"}
{"name":"analyticWithinAt_iff_exists_analyticAt'","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace F\nf : E → F\ns : Set E\nx : E\n⊢ Iff (AnalyticWithinAt 𝕜 f s x) (Exists fun g => And (Eq (f x) (g x)) (And (Set.EqOn f g (Insert.insert x s)) (AnalyticAt 𝕜 g x)))","decl":"/-- `f` is analytic within `s` at `x` iff some local extension of `f` is analytic at `x`. In this\nversion, we make sure that the extension coincides with `f` on all of `insert x s`. -/\nlemma analyticWithinAt_iff_exists_analyticAt' [CompleteSpace F] {f : E → F} {s : Set E} {x : E} :\n    AnalyticWithinAt 𝕜 f s x ↔\n      ∃ g, f x = g x ∧ EqOn f g (insert x s) ∧ AnalyticAt 𝕜 g x := by\n  classical\n  simp only [analyticWithinAt_iff_exists_analyticAt]\n  refine ⟨?_, ?_⟩\n  · rintro ⟨g, hf, hg⟩\n    rcases mem_nhdsWithin.1 hf with ⟨u, u_open, xu, hu⟩\n    let g' := Set.piecewise u g f\n    refine ⟨g', ?_, ?_, ?_⟩\n    · have : x ∈ u ∩ insert x s := ⟨xu, by simp⟩\n      simpa [g', xu, this] using hu this\n    · intro y hy\n      by_cases h'y : y ∈ u\n      · have : y ∈ u ∩ insert x s := ⟨h'y, hy⟩\n        simpa [g', h'y, this] using hu this\n      · simp [g', h'y]\n    · apply hg.congr\n      filter_upwards [u_open.mem_nhds xu] with y hy using by simp [g', hy]\n  · rintro ⟨g, -, hf, hg⟩\n    exact ⟨g, by filter_upwards [self_mem_nhdsWithin] using hf, hg⟩\n\n"}
{"name":"AnalyticWithinAt.exists_analyticAt","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace F\nf : E → F\ns : Set E\nx : E\na✝ : AnalyticWithinAt 𝕜 f s x\n⊢ Exists fun g => And (Eq (f x) (g x)) (And (Set.EqOn f g (Insert.insert x s)) (AnalyticAt 𝕜 g x))","decl":"alias ⟨AnalyticWithinAt.exists_analyticAt, _⟩ := analyticWithinAt_iff_exists_analyticAt'\n\n"}
{"name":"AnalyticWithinAt.exists_mem_nhdsWithin_analyticOn","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\nF : Type u_3\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : CompleteSpace F\nf : E → F\ns : Set E\nx : E\nh : AnalyticWithinAt 𝕜 f s x\n⊢ Exists fun u => And (Membership.mem (nhdsWithin x (Insert.insert x s)) u) (AnalyticOn 𝕜 f u)","decl":"lemma AnalyticWithinAt.exists_mem_nhdsWithin_analyticOn\n    [CompleteSpace F] {f : E → F} {s : Set E} {x : E} (h : AnalyticWithinAt 𝕜 f s x) :\n    ∃ u ∈ 𝓝[insert x s] x, AnalyticOn 𝕜 f u := by\n  obtain ⟨g, -, h'g, hg⟩ : ∃ g, f x = g x ∧ EqOn f g (insert x s) ∧ AnalyticAt 𝕜 g x :=\n    h.exists_analyticAt\n  let u := insert x s ∩ {y | AnalyticAt 𝕜 g y}\n  refine ⟨u, ?_, ?_⟩\n  · exact inter_mem_nhdsWithin _ ((isOpen_analyticAt 𝕜 g).mem_nhds hg)\n  · intro y hy\n    have : AnalyticWithinAt 𝕜 g u y := hy.2.analyticWithinAt\n    exact this.congr (h'g.mono (inter_subset_left)) (h'g (inter_subset_left hy))\n"}
