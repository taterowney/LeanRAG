{"name":"analyticWithinAt_of_singleton_mem","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nx : E\nh : Membership.mem (nhdsWithin x s) (Singleton.singleton x)\nâŠ¢ AnalyticWithinAt ğ•œ f s x","decl":"/-- `AnalyticWithinAt` is trivial if `{x} âˆˆ ğ“[s] x` -/\nlemma analyticWithinAt_of_singleton_mem {f : E â†’ F} {s : Set E} {x : E} (h : {x} âˆˆ ğ“[s] x) :\n    AnalyticWithinAt ğ•œ f s x := by\n  rcases mem_nhdsWithin.mp h with âŸ¨t, ot, xt, stâŸ©\n  rcases Metric.mem_nhds_iff.mp (ot.mem_nhds xt) with âŸ¨r, r0, rtâŸ©\n  exact âŸ¨constFormalMultilinearSeries ğ•œ E (f x), .ofReal r,\n  { r_le := by simp only [FormalMultilinearSeries.constFormalMultilinearSeries_radius, le_top]\n    r_pos := by positivity\n    hasSum := by\n      intro y ys yr\n      simp only [subset_singleton_iff, mem_inter_iff, and_imp] at st\n      simp only [mem_insert_iff, add_right_eq_self] at ys\n      have : x + y = x := by\n        rcases ys with rfl | ys\n        Â· simp\n        Â· exact st (x + y) (rt (by simpa using yr)) ys\n      simp only [this]\n      apply (hasFPowerSeriesOnBall_const (e := 0)).hasSum\n      simp only [Metric.emetric_ball_top, mem_univ] }âŸ©\n\n"}
{"name":"analyticOn_of_locally_analyticOn","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nh : âˆ€ (x : E), Membership.mem s x â†’ Exists fun u => And (IsOpen u) (And (Membership.mem u x) (AnalyticOn ğ•œ f (Inter.inter s u)))\nâŠ¢ AnalyticOn ğ•œ f s","decl":"/-- If `f` is `AnalyticOn` near each point in a set, it is `AnalyticOn` the set -/\nlemma analyticOn_of_locally_analyticOn {f : E â†’ F} {s : Set E}\n    (h : âˆ€ x âˆˆ s, âˆƒ u, IsOpen u âˆ§ x âˆˆ u âˆ§ AnalyticOn ğ•œ f (s âˆ© u)) :\n    AnalyticOn ğ•œ f s := by\n  intro x m\n  rcases h x m with âŸ¨u, ou, xu, fuâŸ©\n  rcases Metric.mem_nhds_iff.mp (ou.mem_nhds xu) with âŸ¨r, r0, ruâŸ©\n  rcases fu x âŸ¨m, xuâŸ© with âŸ¨p, t, fpâŸ©\n  exact âŸ¨p, min (.ofReal r) t,\n    { r_pos := lt_min (by positivity) fp.r_pos\n      r_le := min_le_of_right_le fp.r_le\n      hasSum := by\n        intro y ys yr\n        simp only [EMetric.mem_ball, lt_min_iff, edist_lt_ofReal, dist_zero_right] at yr\n        apply fp.hasSum\n        Â· simp only [mem_insert_iff, add_right_eq_self] at ys\n          rcases ys with rfl | ys\n          Â· simp\n          Â· simp only [mem_insert_iff, add_right_eq_self, mem_inter_iff, ys, true_and]\n            apply Or.inr (ru ?_)\n            simp only [Metric.mem_ball, dist_self_add_left, yr]\n        Â· simp only [EMetric.mem_ball, yr] }âŸ©\n\n"}
{"name":"analyticWithinOn_of_locally_analyticWithinOn","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nh : âˆ€ (x : E), Membership.mem s x â†’ Exists fun u => And (IsOpen u) (And (Membership.mem u x) (AnalyticOn ğ•œ f (Inter.inter s u)))\nâŠ¢ AnalyticOn ğ•œ f s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias analyticWithinOn_of_locally_analyticWithinOn := analyticOn_of_locally_analyticOn\n\n"}
{"name":"IsOpen.analyticOn_iff_analyticOnNhd","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nhs : IsOpen s\nâŠ¢ Iff (AnalyticOn ğ•œ f s) (AnalyticOnNhd ğ•œ f s)","decl":"/-- On open sets, `AnalyticOnNhd` and `AnalyticOn` coincide -/\nlemma IsOpen.analyticOn_iff_analyticOnNhd {f : E â†’ F} {s : Set E} (hs : IsOpen s) :\n    AnalyticOn ğ•œ f s â†” AnalyticOnNhd ğ•œ f s := by\n  refine âŸ¨?_, AnalyticOnNhd.analyticOnâŸ©\n  intro hf x m\n  rcases Metric.mem_nhds_iff.mp (hs.mem_nhds m) with âŸ¨r, r0, rsâŸ©\n  rcases hf x m with âŸ¨p, t, fpâŸ©\n  exact âŸ¨p, min (.ofReal r) t,\n  { r_pos := lt_min (by positivity) fp.r_pos\n    r_le := min_le_of_right_le fp.r_le\n    hasSum := by\n      intro y ym\n      simp only [EMetric.mem_ball, lt_min_iff, edist_lt_ofReal, dist_zero_right] at ym\n      refine fp.hasSum ?_ ym.2\n      apply mem_insert_of_mem\n      apply rs\n      simp only [Metric.mem_ball, dist_self_add_left, ym.1] }âŸ©\n\n"}
{"name":"IsOpen.analyticWithinOn_iff_analyticOn","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\ns : Set E\nhs : IsOpen s\nâŠ¢ Iff (AnalyticOn ğ•œ f s) (AnalyticOnNhd ğ•œ f s)","decl":"@[deprecated (since := \"2024-09-26\")]\nalias IsOpen.analyticWithinOn_iff_analyticOn := IsOpen.analyticOn_iff_analyticOnNhd\n\n\n"}
{"name":"hasFPowerSeriesWithinOnBall_iff_exists_hasFPowerSeriesOnBall","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nr : ENNReal\nâŠ¢ Iff (HasFPowerSeriesWithinOnBall f p s x r) (Exists fun g => And (Set.EqOn f g (Inter.inter (Insert.insert x s) (EMetric.ball x r))) (HasFPowerSeriesOnBall g p x r))","decl":"set_option linter.style.multiGoal false in\n/-- `f` has power series `p` at `x` iff some local extension of `f` has that series -/\nlemma hasFPowerSeriesWithinOnBall_iff_exists_hasFPowerSeriesOnBall [CompleteSpace F] {f : E â†’ F}\n    {p : FormalMultilinearSeries ğ•œ E F} {s : Set E} {x : E} {r : â„â‰¥0âˆ} :\n    HasFPowerSeriesWithinOnBall f p s x r â†”\n      âˆƒ g, EqOn f g (insert x s âˆ© EMetric.ball x r) âˆ§\n        HasFPowerSeriesOnBall g p x r := by\n  constructor\n  Â· intro h\n    refine âŸ¨fun y â†¦ p.sum (y - x), ?_, ?_âŸ©\n    Â· intro y âŸ¨ys,ybâŸ©\n      simp only [EMetric.mem_ball, edist_eq_enorm_sub] at yb\n      have e0 := p.hasSum (x := y - x) ?_\n      have e1 := (h.hasSum (y := y - x) ?_ ?_)\n      Â· simp only [add_sub_cancel] at e1\n        exact e1.unique e0\n      Â· simpa only [add_sub_cancel]\n      Â· simpa only [EMetric.mem_ball, edist_zero_eq_enorm]\n      Â· simp only [EMetric.mem_ball, edist_zero_eq_enorm]\n        exact lt_of_lt_of_le yb h.r_le\n    Â· refine âŸ¨h.r_le, h.r_pos, ?_âŸ©\n      intro y lt\n      simp only [add_sub_cancel_left]\n      apply p.hasSum\n      simp only [EMetric.mem_ball] at lt âŠ¢\n      exact lt_of_lt_of_le lt h.r_le\n  Â· intro âŸ¨g, hfg, hgâŸ©\n    refine âŸ¨hg.r_le, hg.r_pos, ?_âŸ©\n    intro y ys lt\n    rw [hfg]\n    Â· exact hg.hasSum lt\n    Â· refine âŸ¨ys, ?_âŸ©\n      simpa only [EMetric.mem_ball, edist_eq_enorm_sub, add_sub_cancel_left, sub_zero] using lt\n\n"}
{"name":"hasFPowerSeriesWithinAt_iff_exists_hasFPowerSeriesAt","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\nf : E â†’ F\np : FormalMultilinearSeries ğ•œ E F\ns : Set E\nx : E\nâŠ¢ Iff (HasFPowerSeriesWithinAt f p s x) (Exists fun g => And ((nhdsWithin x (Insert.insert x s)).EventuallyEq f g) (HasFPowerSeriesAt g p x))","decl":"/-- `f` has power series `p` at `x` iff some local extension of `f` has that series -/\nlemma hasFPowerSeriesWithinAt_iff_exists_hasFPowerSeriesAt [CompleteSpace F] {f : E â†’ F}\n    {p : FormalMultilinearSeries ğ•œ E F} {s : Set E} {x : E} :\n    HasFPowerSeriesWithinAt f p s x â†”\n      âˆƒ g, f =á¶ [ğ“[insert x s] x] g âˆ§ HasFPowerSeriesAt g p x := by\n  constructor\n  Â· intro âŸ¨r, hâŸ©\n    rcases hasFPowerSeriesWithinOnBall_iff_exists_hasFPowerSeriesOnBall.mp h with âŸ¨g, e, hâŸ©\n    refine âŸ¨g, ?_, âŸ¨r, hâŸ©âŸ©\n    refine Filter.eventuallyEq_iff_exists_mem.mpr âŸ¨_, ?_, eâŸ©\n    exact inter_mem_nhdsWithin _ (EMetric.ball_mem_nhds _ h.r_pos)\n  Â· intro âŸ¨g, hfg, âŸ¨r, hgâŸ©âŸ©\n    simp only [eventuallyEq_nhdsWithin_iff, Metric.eventually_nhds_iff] at hfg\n    rcases hfg with âŸ¨e, e0, hfgâŸ©\n    refine âŸ¨min r (.ofReal e), ?_âŸ©\n    refine hasFPowerSeriesWithinOnBall_iff_exists_hasFPowerSeriesOnBall.mpr âŸ¨g, ?_, ?_âŸ©\n    Â· intro y âŸ¨ys, xyâŸ©\n      refine hfg ?_ ys\n      simp only [EMetric.mem_ball, lt_min_iff, edist_lt_ofReal] at xy\n      exact xy.2\n    Â· exact hg.mono (lt_min hg.r_pos (by positivity)) (min_le_left _ _)\n\n"}
{"name":"analyticWithinAt_iff_exists_analyticAt","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\nf : E â†’ F\ns : Set E\nx : E\nâŠ¢ Iff (AnalyticWithinAt ğ•œ f s x) (Exists fun g => And ((nhdsWithin x (Insert.insert x s)).EventuallyEq f g) (AnalyticAt ğ•œ g x))","decl":"/-- `f` is analytic within `s` at `x` iff some local extension of `f` is analytic at `x` -/\nlemma analyticWithinAt_iff_exists_analyticAt [CompleteSpace F] {f : E â†’ F} {s : Set E} {x : E} :\n    AnalyticWithinAt ğ•œ f s x â†”\n      âˆƒ g, f =á¶ [ğ“[insert x s] x] g âˆ§ AnalyticAt ğ•œ g x := by\n  simp only [AnalyticWithinAt, AnalyticAt, hasFPowerSeriesWithinAt_iff_exists_hasFPowerSeriesAt]\n  tauto\n\n"}
{"name":"analyticWithinAt_iff_exists_analyticAt'","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\nf : E â†’ F\ns : Set E\nx : E\nâŠ¢ Iff (AnalyticWithinAt ğ•œ f s x) (Exists fun g => And (Eq (f x) (g x)) (And (Set.EqOn f g (Insert.insert x s)) (AnalyticAt ğ•œ g x)))","decl":"/-- `f` is analytic within `s` at `x` iff some local extension of `f` is analytic at `x`. In this\nversion, we make sure that the extension coincides with `f` on all of `insert x s`. -/\nlemma analyticWithinAt_iff_exists_analyticAt' [CompleteSpace F] {f : E â†’ F} {s : Set E} {x : E} :\n    AnalyticWithinAt ğ•œ f s x â†”\n      âˆƒ g, f x = g x âˆ§ EqOn f g (insert x s) âˆ§ AnalyticAt ğ•œ g x := by\n  classical\n  simp only [analyticWithinAt_iff_exists_analyticAt]\n  refine âŸ¨?_, ?_âŸ©\n  Â· rintro âŸ¨g, hf, hgâŸ©\n    rcases mem_nhdsWithin.1 hf with âŸ¨u, u_open, xu, huâŸ©\n    let g' := Set.piecewise u g f\n    refine âŸ¨g', ?_, ?_, ?_âŸ©\n    Â· have : x âˆˆ u âˆ© insert x s := âŸ¨xu, by simpâŸ©\n      simpa [g', xu, this] using hu this\n    Â· intro y hy\n      by_cases h'y : y âˆˆ u\n      Â· have : y âˆˆ u âˆ© insert x s := âŸ¨h'y, hyâŸ©\n        simpa [g', h'y, this] using hu this\n      Â· simp [g', h'y]\n    Â· apply hg.congr\n      filter_upwards [u_open.mem_nhds xu] with y hy using by simp [g', hy]\n  Â· rintro âŸ¨g, -, hf, hgâŸ©\n    exact âŸ¨g, by filter_upwards [self_mem_nhdsWithin] using hf, hgâŸ©\n\n"}
{"name":"AnalyticWithinAt.exists_analyticAt","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\nf : E â†’ F\ns : Set E\nx : E\naâœ : AnalyticWithinAt ğ•œ f s x\nâŠ¢ Exists fun g => And (Eq (f x) (g x)) (And (Set.EqOn f g (Insert.insert x s)) (AnalyticAt ğ•œ g x))","decl":"alias âŸ¨AnalyticWithinAt.exists_analyticAt, _âŸ© := analyticWithinAt_iff_exists_analyticAt'\n\n"}
{"name":"AnalyticWithinAt.exists_mem_nhdsWithin_analyticOn","module":"Mathlib.Analysis.Analytic.Within","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\nF : Type u_3\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : CompleteSpace F\nf : E â†’ F\ns : Set E\nx : E\nh : AnalyticWithinAt ğ•œ f s x\nâŠ¢ Exists fun u => And (Membership.mem (nhdsWithin x (Insert.insert x s)) u) (AnalyticOn ğ•œ f u)","decl":"lemma AnalyticWithinAt.exists_mem_nhdsWithin_analyticOn\n    [CompleteSpace F] {f : E â†’ F} {s : Set E} {x : E} (h : AnalyticWithinAt ğ•œ f s x) :\n    âˆƒ u âˆˆ ğ“[insert x s] x, AnalyticOn ğ•œ f u := by\n  obtain âŸ¨g, -, h'g, hgâŸ© : âˆƒ g, f x = g x âˆ§ EqOn f g (insert x s) âˆ§ AnalyticAt ğ•œ g x :=\n    h.exists_analyticAt\n  let u := insert x s âˆ© {y | AnalyticAt ğ•œ g y}\n  refine âŸ¨u, ?_, ?_âŸ©\n  Â· exact inter_mem_nhdsWithin _ ((isOpen_analyticAt ğ•œ g).mem_nhds hg)\n  Â· intro y hy\n    have : AnalyticWithinAt ğ•œ g u y := hy.2.analyticWithinAt\n    exact this.congr (h'g.mono (inter_subset_left)) (h'g (inter_subset_left hy))\n"}
