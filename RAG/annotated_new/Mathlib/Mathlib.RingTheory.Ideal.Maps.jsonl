{"name":"Ideal.coe_comap","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nI : Ideal S\n⊢ Eq (↑(Ideal.comap f I)) (Set.preimage ⇑f ↑I)","decl":"@[simp]\ntheorem coe_comap [RingHomClass F R S] (I : Ideal S) : (comap f I : Set R) = f ⁻¹' I := rfl\n\n"}
{"name":"Ideal.comap_coe","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nI : Ideal S\n⊢ Eq (Ideal.comap (↑f) I) (Ideal.comap f I)","decl":"lemma comap_coe [RingHomClass F R S] (I : Ideal S) : I.comap (f : R →+* S) = I.comap f := rfl\n\n"}
{"name":"Ideal.map_mono","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝² : Semiring R\ninst✝¹ : Semiring S\ninst✝ : FunLike F R S\nf : F\nI J : Ideal R\nh : LE.le I J\n⊢ LE.le (Ideal.map f I) (Ideal.map f J)","decl":"theorem map_mono (h : I ≤ J) : map f I ≤ map f J :=\n  span_mono <| Set.image_subset _ h\n\n"}
{"name":"Ideal.mem_map_of_mem","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝² : Semiring R\ninst✝¹ : Semiring S\ninst✝ : FunLike F R S\nf : F\nI : Ideal R\nx : R\nh : Membership.mem I x\n⊢ Membership.mem (Ideal.map f I) (f x)","decl":"theorem mem_map_of_mem (f : F) {I : Ideal R} {x : R} (h : x ∈ I) : f x ∈ map f I :=\n  subset_span ⟨x, h, rfl⟩\n\n"}
{"name":"Ideal.apply_coe_mem_map","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝² : Semiring R\ninst✝¹ : Semiring S\ninst✝ : FunLike F R S\nf : F\nI : Ideal R\nx : Subtype fun x => Membership.mem I x\n⊢ Membership.mem (Ideal.map f I) (f ↑x)","decl":"theorem apply_coe_mem_map (f : F) (I : Ideal R) (x : I) : f x ∈ I.map f :=\n  mem_map_of_mem f x.2\n\n"}
{"name":"Ideal.map_le_iff_le_comap","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\nI : Ideal R\nK : Ideal S\ninst✝ : RingHomClass F R S\n⊢ Iff (LE.le (Ideal.map f I) K) (LE.le I (Ideal.comap f K))","decl":"theorem map_le_iff_le_comap [RingHomClass F R S] : map f I ≤ K ↔ I ≤ comap f K :=\n  span_le.trans Set.image_subset_iff\n\n"}
{"name":"Ideal.mem_comap","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\nK : Ideal S\ninst✝ : RingHomClass F R S\nx : R\n⊢ Iff (Membership.mem (Ideal.comap f K) x) (Membership.mem K (f x))","decl":"@[simp]\ntheorem mem_comap [RingHomClass F R S] {x} : x ∈ comap f K ↔ f x ∈ K :=\n  Iff.rfl\n\n"}
{"name":"Ideal.comap_mono","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\nK L : Ideal S\ninst✝ : RingHomClass F R S\nh : LE.le K L\n⊢ LE.le (Ideal.comap f K) (Ideal.comap f L)","decl":"theorem comap_mono [RingHomClass F R S] (h : K ≤ L) : comap f K ≤ comap f L :=\n  Set.preimage_mono fun _ hx => h hx\n\n"}
{"name":"Ideal.comap_ne_top","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\nK : Ideal S\ninst✝ : RingHomClass F R S\nhK : Ne K Top.top\n⊢ Ne (Ideal.comap f K) Top.top","decl":"theorem comap_ne_top [RingHomClass F R S] (hK : K ≠ ⊤) : comap f K ≠ ⊤ :=\n  (ne_top_iff_one _).2 <| by rw [mem_comap, map_one]; exact (ne_top_iff_one _).1 hK\n\n"}
{"name":"Ideal.map_le_comap_of_inv_on","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝⁴ : Semiring R\ninst✝³ : Semiring S\ninst✝² : FunLike F R S\nf : F\nG : Type u_2\ninst✝¹ : FunLike G S R\ninst✝ : RingHomClass G S R\ng : G\nI : Ideal R\nhf : Set.LeftInvOn ⇑g ⇑f ↑I\n⊢ LE.le (Ideal.map f I) (Ideal.comap g I)","decl":"theorem map_le_comap_of_inv_on [RingHomClass G S R] (g : G) (I : Ideal R)\n    (hf : Set.LeftInvOn g f I) :\n    I.map f ≤ I.comap g := by\n  refine Ideal.span_le.2 ?_\n  rintro x ⟨x, hx, rfl⟩\n  rw [SetLike.mem_coe, mem_comap, hf hx]\n  exact hx\n\n"}
{"name":"Ideal.comap_le_map_of_inv_on","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝⁴ : Semiring R\ninst✝³ : Semiring S\ninst✝² : FunLike F R S\nf : F\nG : Type u_2\ninst✝¹ : FunLike G S R\ninst✝ : RingHomClass F R S\ng : G\nI : Ideal S\nhf : Set.LeftInvOn (⇑g) (⇑f) (Set.preimage ⇑f ↑I)\n⊢ LE.le (Ideal.comap f I) (Ideal.map g I)","decl":"theorem comap_le_map_of_inv_on [RingHomClass F R S] (g : G) (I : Ideal S)\n    (hf : Set.LeftInvOn g f (f ⁻¹' I)) :\n    I.comap f ≤ I.map g :=\n  fun x (hx : f x ∈ I) => hf hx ▸ Ideal.mem_map_of_mem g hx\n\n"}
{"name":"Ideal.map_le_comap_of_inverse","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝⁴ : Semiring R\ninst✝³ : Semiring S\ninst✝² : FunLike F R S\nf : F\nG : Type u_2\ninst✝¹ : FunLike G S R\ninst✝ : RingHomClass G S R\ng : G\nI : Ideal R\nh : Function.LeftInverse ⇑g ⇑f\n⊢ LE.le (Ideal.map f I) (Ideal.comap g I)","decl":"/-- The `Ideal` version of `Set.image_subset_preimage_of_inverse`. -/\ntheorem map_le_comap_of_inverse [RingHomClass G S R] (g : G) (I : Ideal R)\n    (h : Function.LeftInverse g f) :\n    I.map f ≤ I.comap g :=\n  map_le_comap_of_inv_on _ _ _ <| h.leftInvOn _\n\n"}
{"name":"Ideal.comap_le_map_of_inverse","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝⁴ : Semiring R\ninst✝³ : Semiring S\ninst✝² : FunLike F R S\nf : F\nG : Type u_2\ninst✝¹ : FunLike G S R\ninst✝ : RingHomClass F R S\ng : G\nI : Ideal S\nh : Function.LeftInverse ⇑g ⇑f\n⊢ LE.le (Ideal.comap f I) (Ideal.map g I)","decl":"/-- The `Ideal` version of `Set.preimage_subset_image_of_inverse`. -/\ntheorem comap_le_map_of_inverse (g : G) (I : Ideal S) (h : Function.LeftInverse g f) :\n    I.comap f ≤ I.map g :=\n  comap_le_map_of_inv_on _ _ _ <| h.leftInvOn _\n\n"}
{"name":"Ideal.IsPrime.comap","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\nK : Ideal S\ninst✝ : RingHomClass F R S\nhK : K.IsPrime\n⊢ (Ideal.comap f K).IsPrime","decl":"instance IsPrime.comap [hK : K.IsPrime] : (comap f K).IsPrime :=\n  ⟨comap_ne_top _ hK.1, fun {x y} => by simp only [mem_comap, map_mul]; apply hK.2⟩\n\n"}
{"name":"Ideal.map_top","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\n⊢ Eq (Ideal.map f Top.top) Top.top","decl":"theorem map_top : map f ⊤ = ⊤ :=\n  (eq_top_iff_one _).2 <| subset_span ⟨1, trivial, map_one f⟩\n\n"}
{"name":"Ideal.gc_map_comap","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\n⊢ GaloisConnection (Ideal.map f) (Ideal.comap f)","decl":"theorem gc_map_comap : GaloisConnection (Ideal.map f) (Ideal.comap f) := fun _ _ =>\n  Ideal.map_le_iff_le_comap\n\n"}
{"name":"Ideal.comap_id","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\ninst✝ : Semiring R\nI : Ideal R\n⊢ Eq (Ideal.comap (RingHom.id R) I) I","decl":"@[simp]\ntheorem comap_id : I.comap (RingHom.id R) = I :=\n  Ideal.ext fun _ => Iff.rfl\n\n"}
{"name":"Ideal.map_id","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\ninst✝ : Semiring R\nI : Ideal R\n⊢ Eq (Ideal.map (RingHom.id R) I) I","decl":"@[simp]\ntheorem map_id : I.map (RingHom.id R) = I :=\n  (gc_map_comap (RingHom.id R)).l_unique GaloisConnection.id comap_id\n\n"}
{"name":"Ideal.comap_comap","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\ninst✝² : Semiring R\ninst✝¹ : Semiring S\nT : Type u_3\ninst✝ : Semiring T\nI : Ideal T\nf : RingHom R S\ng : RingHom S T\n⊢ Eq (Ideal.comap f (Ideal.comap g I)) (Ideal.comap (g.comp f) I)","decl":"theorem comap_comap {T : Type*} [Semiring T] {I : Ideal T} (f : R →+* S) (g : S →+* T) :\n    (I.comap g).comap f = I.comap (g.comp f) :=\n  rfl\n\n"}
{"name":"Ideal.comap_comapₐ","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_3\nA : Type u_4\nB : Type u_5\nC : Type u_6\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Semiring B\ninst✝² : Algebra R B\ninst✝¹ : Semiring C\ninst✝ : Algebra R C\nI : Ideal C\nf : AlgHom R A B\ng : AlgHom R B C\n⊢ Eq (Ideal.comap f (Ideal.comap g I)) (Ideal.comap (g.comp f) I)","decl":"lemma comap_comapₐ {R A B C : Type*} [CommSemiring R] [Semiring A] [Algebra R A] [Semiring B]\n    [Algebra R B] [Semiring C] [Algebra R C] {I : Ideal C} (f : A →ₐ[R] B) (g : B →ₐ[R] C) :\n    (I.comap g).comap f = I.comap (g.comp f) :=\n  I.comap_comap f.toRingHom g.toRingHom\n\n"}
{"name":"Ideal.map_map","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\ninst✝² : Semiring R\ninst✝¹ : Semiring S\nT : Type u_3\ninst✝ : Semiring T\nI : Ideal R\nf : RingHom R S\ng : RingHom S T\n⊢ Eq (Ideal.map g (Ideal.map f I)) (Ideal.map (g.comp f) I)","decl":"theorem map_map {T : Type*} [Semiring T] {I : Ideal R} (f : R →+* S) (g : S →+* T) :\n    (I.map f).map g = I.map (g.comp f) :=\n  ((gc_map_comap f).compose (gc_map_comap g)).l_unique (gc_map_comap (g.comp f)) fun _ =>\n    comap_comap _ _\n\n"}
{"name":"Ideal.map_mapₐ","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_3\nA : Type u_4\nB : Type u_5\nC : Type u_6\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\ninst✝³ : Semiring B\ninst✝² : Algebra R B\ninst✝¹ : Semiring C\ninst✝ : Algebra R C\nI : Ideal A\nf : AlgHom R A B\ng : AlgHom R B C\n⊢ Eq (Ideal.map g (Ideal.map f I)) (Ideal.map (g.comp f) I)","decl":"lemma map_mapₐ {R A B C : Type*} [CommSemiring R] [Semiring A] [Algebra R A] [Semiring B]\n    [Algebra R B] [Semiring C] [Algebra R C] {I : Ideal A} (f : A →ₐ[R] B) (g : B →ₐ[R] C) :\n    (I.map f).map g = I.map (g.comp f) :=\n  I.map_map f.toRingHom g.toRingHom\n\n"}
{"name":"Ideal.map_span","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\ninst✝ : RingHomClass F R S\nf : F\ns : Set R\n⊢ Eq (Ideal.map f (Ideal.span s)) (Ideal.span (Set.image (⇑f) s))","decl":"theorem map_span (f : F) (s : Set R) : map f (span s) = span (f '' s) := by\n  refine (Submodule.span_eq_of_le _ ?_ ?_).symm\n  · rintro _ ⟨x, hx, rfl⟩; exact mem_map_of_mem f (subset_span hx)\n  · rw [map_le_iff_le_comap, span_le, coe_comap, ← Set.image_subset_iff]\n    exact subset_span\n\n"}
{"name":"Ideal.map_le_of_le_comap","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\nI : Ideal R\nK : Ideal S\ninst✝ : RingHomClass F R S\na✝ : LE.le I (Ideal.comap f K)\n⊢ LE.le (Ideal.map f I) K","decl":"theorem map_le_of_le_comap : I ≤ K.comap f → I.map f ≤ K :=\n  (gc_map_comap f).l_le\n\n"}
{"name":"Ideal.le_comap_of_map_le","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\nI : Ideal R\nK : Ideal S\ninst✝ : RingHomClass F R S\na✝ : LE.le (Ideal.map f I) K\n⊢ LE.le I (Ideal.comap f K)","decl":"theorem le_comap_of_map_le : I.map f ≤ K → I ≤ K.comap f :=\n  (gc_map_comap f).le_u\n\n"}
{"name":"Ideal.le_comap_map","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\nI : Ideal R\ninst✝ : RingHomClass F R S\n⊢ LE.le I (Ideal.comap f (Ideal.map f I))","decl":"theorem le_comap_map : I ≤ (I.map f).comap f :=\n  (gc_map_comap f).le_u_l _\n\n"}
{"name":"Ideal.map_comap_le","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\nK : Ideal S\ninst✝ : RingHomClass F R S\n⊢ LE.le (Ideal.map f (Ideal.comap f K)) K","decl":"theorem map_comap_le : (K.comap f).map f ≤ K :=\n  (gc_map_comap f).l_u_le _\n\n"}
{"name":"Ideal.comap_top","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\n⊢ Eq (Ideal.comap f Top.top) Top.top","decl":"@[simp]\ntheorem comap_top : (⊤ : Ideal S).comap f = ⊤ :=\n  (gc_map_comap f).u_top\n\n"}
{"name":"Ideal.comap_eq_top_iff","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nI : Ideal S\n⊢ Iff (Eq (Ideal.comap f I) Top.top) (Eq I Top.top)","decl":"@[simp]\ntheorem comap_eq_top_iff {I : Ideal S} : I.comap f = ⊤ ↔ I = ⊤ :=\n  ⟨fun h => I.eq_top_iff_one.mpr (map_one f ▸ mem_comap.mp ((I.comap f).eq_top_iff_one.mp h)),\n    fun h => by rw [h, comap_top]⟩\n\n"}
{"name":"Ideal.map_bot","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\n⊢ Eq (Ideal.map f Bot.bot) Bot.bot","decl":"@[simp]\ntheorem map_bot : (⊥ : Ideal R).map f = ⊥ :=\n  (gc_map_comap f).l_bot\n\n"}
{"name":"Ideal.ne_bot_of_map_ne_bot","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\nI : Ideal R\ninst✝ : RingHomClass F R S\nhI : Ne (Ideal.map f I) Bot.bot\n⊢ Ne I Bot.bot","decl":"theorem ne_bot_of_map_ne_bot (hI : map f I ≠ ⊥) : I ≠ ⊥ :=\n  fun h => hI (Eq.mpr (congrArg (fun I ↦ map f I = ⊥) h) map_bot)\n\n"}
{"name":"Ideal.map_comap_map","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\nI : Ideal R\ninst✝ : RingHomClass F R S\n⊢ Eq (Ideal.map f (Ideal.comap f (Ideal.map f I))) (Ideal.map f I)","decl":"@[simp]\ntheorem map_comap_map : ((I.map f).comap f).map f = I.map f :=\n  (gc_map_comap f).l_u_l_eq_l I\n\n"}
{"name":"Ideal.comap_map_comap","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\nK : Ideal S\ninst✝ : RingHomClass F R S\n⊢ Eq (Ideal.comap f (Ideal.map f (Ideal.comap f K))) (Ideal.comap f K)","decl":"@[simp]\ntheorem comap_map_comap : ((K.comap f).map f).comap f = K.comap f :=\n  (gc_map_comap f).u_l_u_eq_u K\n\n"}
{"name":"Ideal.map_sup","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\nI J : Ideal R\ninst✝ : RingHomClass F R S\n⊢ Eq (Ideal.map f (Max.max I J)) (Max.max (Ideal.map f I) (Ideal.map f J))","decl":"theorem map_sup : (I ⊔ J).map f = I.map f ⊔ J.map f :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).l_sup\n\n"}
{"name":"Ideal.comap_inf","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\nK L : Ideal S\ninst✝ : RingHomClass F R S\n⊢ Eq (Ideal.comap f (Min.min K L)) (Min.min (Ideal.comap f K) (Ideal.comap f L))","decl":"theorem comap_inf : comap f (K ⊓ L) = comap f K ⊓ comap f L :=\n  rfl\n\n"}
{"name":"Ideal.map_iSup","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nι : Sort u_3\nK : ι → Ideal R\n⊢ Eq (Ideal.map f (iSup K)) (iSup fun i => Ideal.map f (K i))","decl":"theorem map_iSup (K : ι → Ideal R) : (iSup K).map f = ⨆ i, (K i).map f :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).l_iSup\n\n"}
{"name":"Ideal.comap_iInf","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nι : Sort u_3\nK : ι → Ideal S\n⊢ Eq (Ideal.comap f (iInf K)) (iInf fun i => Ideal.comap f (K i))","decl":"theorem comap_iInf (K : ι → Ideal S) : (iInf K).comap f = ⨅ i, (K i).comap f :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).u_iInf\n\n"}
{"name":"Ideal.map_sSup","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\ns : Set (Ideal R)\n⊢ Eq (Ideal.map f (SupSet.sSup s)) (iSup fun I => iSup fun h => Ideal.map f I)","decl":"theorem map_sSup (s : Set (Ideal R)) : (sSup s).map f = ⨆ I ∈ s, (I : Ideal R).map f :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).l_sSup\n\n"}
{"name":"Ideal.comap_sInf","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\ns : Set (Ideal S)\n⊢ Eq (Ideal.comap f (InfSet.sInf s)) (iInf fun I => iInf fun h => Ideal.comap f I)","decl":"theorem comap_sInf (s : Set (Ideal S)) : (sInf s).comap f = ⨅ I ∈ s, (I : Ideal S).comap f :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).u_sInf\n\n"}
{"name":"Ideal.comap_sInf'","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\ns : Set (Ideal S)\n⊢ Eq (Ideal.comap f (InfSet.sInf s)) (iInf fun I => iInf fun h => I)","decl":"theorem comap_sInf' (s : Set (Ideal S)) : (sInf s).comap f = ⨅ I ∈ comap f '' s, I :=\n  _root_.trans (comap_sInf f s) (by rw [iInf_image])\n\n"}
{"name":"Ideal.comap_isPrime","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\nK : Ideal S\ninst✝ : RingHomClass F R S\nH : K.IsPrime\n⊢ (Ideal.comap f K).IsPrime","decl":"/-- Variant of `Ideal.IsPrime.comap` where ideal is explicit rather than implicit.  -/\ntheorem comap_isPrime [H : IsPrime K] : IsPrime (comap f K) :=\n  H.comap f\n\n"}
{"name":"Ideal.map_inf_le","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\nI J : Ideal R\ninst✝ : RingHomClass F R S\n⊢ LE.le (Ideal.map f (Min.min I J)) (Min.min (Ideal.map f I) (Ideal.map f J))","decl":"theorem map_inf_le : map f (I ⊓ J) ≤ map f I ⊓ map f J :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).monotone_l.map_inf_le _ _\n\n"}
{"name":"Ideal.le_comap_sup","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\nK L : Ideal S\ninst✝ : RingHomClass F R S\n⊢ LE.le (Max.max (Ideal.comap f K) (Ideal.comap f L)) (Ideal.comap f (Max.max K L))","decl":"theorem le_comap_sup : comap f K ⊔ comap f L ≤ comap f (K ⊔ L) :=\n  (gc_map_comap f : GaloisConnection (map f) (comap f)).monotone_u.le_map_sup _ _\n\n-- TODO: Should these be simp lemmas?\n"}
{"name":"element_smul_restrictScalars","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_4\nS : Type u_5\nM : Type u_6\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nr : R\nN : Submodule S M\n⊢ Eq (Submodule.restrictScalars R (HSMul.hSMul ((algebraMap R S) r) N)) (HSMul.hSMul r (Submodule.restrictScalars R N))","decl":"theorem _root_.element_smul_restrictScalars {R S M}\n    [CommSemiring R] [CommSemiring S] [Algebra R S] [AddCommMonoid M]\n    [Module R M] [Module S M] [IsScalarTower R S M] (r : R) (N : Submodule S M) :\n    (algebraMap R S r • N).restrictScalars R = r • N.restrictScalars R :=\n  SetLike.coe_injective (congrArg (· '' _) (funext (algebraMap_smul S r)))\n\n"}
{"name":"Ideal.smul_restrictScalars","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_4\nS : Type u_5\nM : Type u_6\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nI : Ideal R\nN : Submodule S M\n⊢ Eq (Submodule.restrictScalars R (HSMul.hSMul (Ideal.map (algebraMap R S) I) N)) (HSMul.hSMul I (Submodule.restrictScalars R N))","decl":"theorem smul_restrictScalars {R S M} [CommSemiring R] [CommSemiring S]\n    [Algebra R S] [AddCommMonoid M] [Module R M] [Module S M]\n    [IsScalarTower R S M] (I : Ideal R) (N : Submodule S M) :\n    (I.map (algebraMap R S) • N).restrictScalars R = I • N.restrictScalars R := by\n  simp_rw [map, Submodule.span_smul_eq, ← Submodule.coe_set_smul,\n    Submodule.set_smul_eq_iSup, ← element_smul_restrictScalars, iSup_image]\n  exact map_iSup₂ (Submodule.restrictScalarsLatticeHom R S M) _\n\n"}
{"name":"Ideal.smul_top_eq_map","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nI : Ideal R\n⊢ Eq (HSMul.hSMul I Top.top) (Submodule.restrictScalars R (Ideal.map (algebraMap R S) I))","decl":"@[simp]\ntheorem smul_top_eq_map {R S : Type*} [CommSemiring R] [CommSemiring S] [Algebra R S]\n    (I : Ideal R) : I • (⊤ : Submodule R S) = (I.map (algebraMap R S)).restrictScalars R :=\n  Eq.trans (smul_restrictScalars I (⊤ : Ideal S)).symm <|\n    congrArg _ <| Eq.trans (Ideal.smul_eq_mul _ _) (Ideal.mul_top _)\n\n"}
{"name":"Ideal.coe_restrictScalars","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : Module R S\ninst✝ : IsScalarTower R S S\nI : Ideal S\n⊢ Eq ↑(Submodule.restrictScalars R I) ↑I","decl":"@[simp]\ntheorem coe_restrictScalars {R S : Type*} [Semiring R] [Semiring S] [Module R S]\n    [IsScalarTower R S S] (I : Ideal S) : (I.restrictScalars R : Set S) = ↑I :=\n  rfl\n\n"}
{"name":"Ideal.restrictScalars_mul","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_4\nS : Type u_5\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : Module R S\ninst✝ : IsScalarTower R S S\nI J : Ideal S\n⊢ Eq (Submodule.restrictScalars R (HMul.hMul I J)) (HMul.hMul (Submodule.restrictScalars R I) (Submodule.restrictScalars R J))","decl":"/-- The smallest `S`-submodule that contains all `x ∈ I * y ∈ J`\nis also the smallest `R`-submodule that does so. -/\n@[simp]\ntheorem restrictScalars_mul {R S : Type*} [Semiring R] [Semiring S] [Module R S]\n    [IsScalarTower R S S] (I J : Ideal S) :\n    (I * J).restrictScalars R = I.restrictScalars R * J.restrictScalars R :=\n  rfl\n\n"}
{"name":"Ideal.map_comap_of_surjective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nhf : Function.Surjective ⇑f\nI : Ideal S\n⊢ Eq (Ideal.map f (Ideal.comap f I)) I","decl":"theorem map_comap_of_surjective (I : Ideal S) : map f (comap f I) = I :=\n  le_antisymm (map_le_iff_le_comap.2 le_rfl) fun s hsi =>\n    let ⟨r, hfrs⟩ := hf s\n    hfrs ▸ (mem_map_of_mem f <| show f r ∈ I from hfrs.symm ▸ hsi)\n\n"}
{"name":"Ideal.map_surjective_of_surjective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nhf : Function.Surjective ⇑f\n⊢ Function.Surjective (Ideal.map f)","decl":"theorem map_surjective_of_surjective : Surjective (map f) :=\n  (giMapComap f hf).l_surjective\n\n"}
{"name":"Ideal.comap_injective_of_surjective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nhf : Function.Surjective ⇑f\n⊢ Function.Injective (Ideal.comap f)","decl":"theorem comap_injective_of_surjective : Injective (comap f) :=\n  (giMapComap f hf).u_injective\n\n"}
{"name":"Ideal.map_sup_comap_of_surjective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nhf : Function.Surjective ⇑f\nI J : Ideal S\n⊢ Eq (Ideal.map f (Max.max (Ideal.comap f I) (Ideal.comap f J))) (Max.max I J)","decl":"theorem map_sup_comap_of_surjective (I J : Ideal S) : (I.comap f ⊔ J.comap f).map f = I ⊔ J :=\n  (giMapComap f hf).l_sup_u _ _\n\n"}
{"name":"Ideal.map_iSup_comap_of_surjective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nι : Sort u_3\nhf : Function.Surjective ⇑f\nK : ι → Ideal S\n⊢ Eq (Ideal.map f (iSup fun i => Ideal.comap f (K i))) (iSup K)","decl":"theorem map_iSup_comap_of_surjective (K : ι → Ideal S) : (⨆ i, (K i).comap f).map f = iSup K :=\n  (giMapComap f hf).l_iSup_u _\n\n"}
{"name":"Ideal.map_inf_comap_of_surjective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nhf : Function.Surjective ⇑f\nI J : Ideal S\n⊢ Eq (Ideal.map f (Min.min (Ideal.comap f I) (Ideal.comap f J))) (Min.min I J)","decl":"theorem map_inf_comap_of_surjective (I J : Ideal S) : (I.comap f ⊓ J.comap f).map f = I ⊓ J :=\n  (giMapComap f hf).l_inf_u _ _\n\n"}
{"name":"Ideal.map_iInf_comap_of_surjective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nι : Sort u_3\nhf : Function.Surjective ⇑f\nK : ι → Ideal S\n⊢ Eq (Ideal.map f (iInf fun i => Ideal.comap f (K i))) (iInf K)","decl":"theorem map_iInf_comap_of_surjective (K : ι → Ideal S) : (⨅ i, (K i).comap f).map f = iInf K :=\n  (giMapComap f hf).l_iInf_u _\n\n"}
{"name":"Ideal.mem_image_of_mem_map_of_surjective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nhf : Function.Surjective ⇑f\nI : Ideal R\ny : S\nH : Membership.mem (Ideal.map f I) y\n⊢ Membership.mem (Set.image ⇑f ↑I) y","decl":"theorem mem_image_of_mem_map_of_surjective {I : Ideal R} {y} (H : y ∈ map f I) : y ∈ f '' I :=\n  Submodule.span_induction (hx := H) (fun _ => id) ⟨0, I.zero_mem, map_zero f⟩\n    (fun _ _ _ _ ⟨x1, hx1i, hxy1⟩ ⟨x2, hx2i, hxy2⟩ =>\n      ⟨x1 + x2, I.add_mem hx1i hx2i, hxy1 ▸ hxy2 ▸ map_add f _ _⟩)\n    fun c _ _ ⟨x, hxi, hxy⟩ =>\n    let ⟨d, hdc⟩ := hf c\n    ⟨d * x, I.mul_mem_left _ hxi, hdc ▸ hxy ▸ map_mul f _ _⟩\n\n"}
{"name":"Ideal.mem_map_iff_of_surjective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nhf : Function.Surjective ⇑f\nI : Ideal R\ny : S\n⊢ Iff (Membership.mem (Ideal.map f I) y) (Exists fun x => And (Membership.mem I x) (Eq (f x) y))","decl":"theorem mem_map_iff_of_surjective {I : Ideal R} {y} : y ∈ map f I ↔ ∃ x, x ∈ I ∧ f x = y :=\n  ⟨fun h => (Set.mem_image _ _ _).2 (mem_image_of_mem_map_of_surjective f hf h), fun ⟨_, hx⟩ =>\n    hx.right ▸ mem_map_of_mem f hx.left⟩\n\n"}
{"name":"Ideal.le_map_of_comap_le_of_surjective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\nI : Ideal R\nK : Ideal S\ninst✝ : RingHomClass F R S\nhf : Function.Surjective ⇑f\na✝ : LE.le (Ideal.comap f K) I\n⊢ LE.le K (Ideal.map f I)","decl":"theorem le_map_of_comap_le_of_surjective : comap f K ≤ I → K ≤ map f I := fun h =>\n  map_comap_of_surjective f hf K ▸ map_mono h\n\n"}
{"name":"Ideal.map_comap_eq_self_of_equiv","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\ninst✝³ : Semiring R\ninst✝² : Semiring S\nE : Type u_4\ninst✝¹ : EquivLike E R S\ninst✝ : RingEquivClass E R S\ne : E\nI : Ideal S\n⊢ Eq (Ideal.map e (Ideal.comap e I)) I","decl":"theorem map_comap_eq_self_of_equiv {E : Type*} [EquivLike E R S] [RingEquivClass E R S] (e : E)\n    (I : Ideal S) : map e (comap e I) = I :=\n  I.map_comap_of_surjective e (EquivLike.surjective e)\n\n"}
{"name":"Ideal.map_eq_submodule_map","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nh : RingHomSurjective f\nI : Ideal R\n⊢ Eq (Ideal.map f I) (Submodule.map f.toSemilinearMap I)","decl":"theorem map_eq_submodule_map (f : R →+* S) [h : RingHomSurjective f] (I : Ideal R) :\n    I.map f = Submodule.map f.toSemilinearMap I :=\n  Submodule.ext fun _ => mem_map_iff_of_surjective f h.1\n\n"}
{"name":"Ideal.IsMaximal.comap_piEvalRingHom","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"ι : Type u_4\nR : ι → Type u_5\ninst✝ : (i : ι) → Semiring (R i)\ni : ι\nI : Ideal (R i)\nh : I.IsMaximal\n⊢ (Ideal.comap (Pi.evalRingHom R i) I).IsMaximal","decl":"open Function in\ntheorem IsMaximal.comap_piEvalRingHom {ι : Type*} {R : ι → Type*} [∀ i, Semiring (R i)]\n    {i : ι} {I : Ideal (R i)} (h : I.IsMaximal) : (I.comap <| Pi.evalRingHom R i).IsMaximal := by\n  refine isMaximal_iff.mpr ⟨I.ne_top_iff_one.mp h.ne_top, fun J x le hxI hxJ ↦ ?_⟩\n  have ⟨r, y, hy, eq⟩ := h.exists_inv hxI\n  classical\n  convert J.add_mem (J.mul_mem_left (update 0 i r) hxJ)\n    (b := update 1 i y) (le <| by apply update_self i y 1 ▸ hy)\n  ext j\n  obtain rfl | ne := eq_or_ne j i\n  · simpa [eq_comm] using eq\n  · simp [update_of_ne ne]\n\n"}
{"name":"Ideal.comap_le_comap_iff_of_surjective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nhf : Function.Surjective ⇑f\nI J : Ideal S\n⊢ Iff (LE.le (Ideal.comap f I) (Ideal.comap f J)) (LE.le I J)","decl":"theorem comap_le_comap_iff_of_surjective (hf : Function.Surjective f) (I J : Ideal S) :\n    comap f I ≤ comap f J ↔ I ≤ J :=\n  ⟨fun h => (map_comap_of_surjective f hf I).symm.le.trans (map_le_of_le_comap h), fun h =>\n    le_comap_of_map_le ((map_comap_of_surjective f hf I).le.trans h)⟩\n\n"}
{"name":"Ideal.map_eq_top_or_isMaximal_of_surjective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nhf : Function.Surjective ⇑f\nI : Ideal R\nH : I.IsMaximal\n⊢ Or (Eq (Ideal.map f I) Top.top) (Ideal.map f I).IsMaximal","decl":"theorem map_eq_top_or_isMaximal_of_surjective (hf : Function.Surjective f) {I : Ideal R}\n    (H : IsMaximal I) : map f I = ⊤ ∨ IsMaximal (map f I) :=\n  or_iff_not_imp_left.2 fun ne_top ↦ ⟨⟨ne_top, fun _J hJ ↦ comap_injective_of_surjective f hf <|\n    H.1.2 _ (le_comap_map.trans_lt <| (orderEmbeddingOfSurjective f hf).strictMono hJ)⟩⟩\n\n"}
{"name":"Ideal.comap_bot_le_of_injective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\nI : Ideal R\ninst✝ : RingHomClass F R S\nhf : Function.Injective ⇑f\n⊢ LE.le (Ideal.comap f Bot.bot) I","decl":"theorem comap_bot_le_of_injective (hf : Function.Injective f) : comap f ⊥ ≤ I := by\n  refine le_trans (fun x hx => ?_) bot_le\n  rw [mem_comap, Submodule.mem_bot, ← map_zero f] at hx\n  exact Eq.symm (hf hx) ▸ Submodule.zero_mem ⊥\n\n"}
{"name":"Ideal.comap_bot_of_injective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nhf : Function.Injective ⇑f\n⊢ Eq (Ideal.comap f Bot.bot) Bot.bot","decl":"theorem comap_bot_of_injective (hf : Function.Injective f) : Ideal.comap f ⊥ = ⊥ :=\n  le_bot_iff.mp (Ideal.comap_bot_le_of_injective f hf)\n\n"}
{"name":"Ideal.map_of_equiv","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nI : Ideal R\nf : RingEquiv R S\n⊢ Eq (Ideal.map (↑f.symm) (Ideal.map (↑f) I)) I","decl":"/-- If `f : R ≃+* S` is a ring isomorphism and `I : Ideal R`, then `map f.symm (map f I) = I`. -/\n@[simp]\ntheorem map_of_equiv {I : Ideal R} (f : R ≃+* S) :\n    (I.map (f : R →+* S)).map (f.symm : S →+* R) = I := by\n  rw [← RingEquiv.toRingHom_eq_coe, ← RingEquiv.toRingHom_eq_coe, map_map,\n    RingEquiv.toRingHom_eq_coe, RingEquiv.toRingHom_eq_coe, RingEquiv.symm_comp, map_id]\n\n"}
{"name":"Ideal.comap_of_equiv","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nI : Ideal R\nf : RingEquiv R S\n⊢ Eq (Ideal.comap (↑f) (Ideal.comap (↑f.symm) I)) I","decl":"/-- If `f : R ≃+* S` is a ring isomorphism and `I : Ideal R`,\n  then `comap f (comap f.symm I) = I`. -/\n@[simp]\ntheorem comap_of_equiv {I : Ideal R} (f : R ≃+* S) :\n    (I.comap (f.symm : S →+* R)).comap (f : R →+* S) = I := by\n  rw [← RingEquiv.toRingHom_eq_coe, ← RingEquiv.toRingHom_eq_coe, comap_comap,\n    RingEquiv.toRingHom_eq_coe, RingEquiv.toRingHom_eq_coe, RingEquiv.symm_comp, comap_id]\n\n"}
{"name":"Ideal.map_comap_of_equiv","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nI : Ideal R\nf : RingEquiv R S\n⊢ Eq (Ideal.map (↑f) I) (Ideal.comap f.symm I)","decl":"/-- If `f : R ≃+* S` is a ring isomorphism and `I : Ideal R`, then `map f I = comap f.symm I`. -/\ntheorem map_comap_of_equiv {I : Ideal R} (f : R ≃+* S) : I.map (f : R →+* S) = I.comap f.symm :=\n  le_antisymm (Ideal.map_le_comap_of_inverse _ _ _ (Equiv.left_inv' _))\n    (Ideal.comap_le_map_of_inverse _ _ _ (Equiv.right_inv' _))\n\n"}
{"name":"Ideal.comap_symm","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nI : Ideal R\nf : RingEquiv R S\n⊢ Eq (Ideal.comap f.symm I) (Ideal.map f I)","decl":"/-- If `f : R ≃+* S` is a ring isomorphism and `I : Ideal R`, then `comap f.symm I = map f I`. -/\n@[simp]\ntheorem comap_symm {I : Ideal R} (f : R ≃+* S) : I.comap f.symm = I.map f :=\n  (map_comap_of_equiv f).symm\n\n"}
{"name":"Ideal.map_symm","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nI : Ideal S\nf : RingEquiv R S\n⊢ Eq (Ideal.map f.symm I) (Ideal.comap f I)","decl":"/-- If `f : R ≃+* S` is a ring isomorphism and `I : Ideal R`, then `map f.symm I = comap f I`. -/\n@[simp]\n\ntheorem map_symm {I : Ideal S} (f : R ≃+* S) : I.map f.symm = I.comap f :=\n  map_comap_of_equiv (RingEquiv.symm f)\n\n"}
{"name":"Ideal.symm_apply_mem_of_equiv_iff","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nI : Ideal R\nf : RingEquiv R S\ny : S\n⊢ Iff (Membership.mem I (f.symm y)) (Membership.mem (Ideal.map f I) y)","decl":"@[simp]\ntheorem symm_apply_mem_of_equiv_iff {I : Ideal R} {f : R ≃+* S} {y : S} :\n    f.symm y ∈ I ↔ y ∈ I.map f := by\n  rw [← comap_symm, mem_comap]\n\n"}
{"name":"Ideal.apply_mem_of_equiv_iff","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nI : Ideal R\nf : RingEquiv R S\nx : R\n⊢ Iff (Membership.mem (Ideal.map f I) (f x)) (Membership.mem I x)","decl":"@[simp]\ntheorem apply_mem_of_equiv_iff {I : Ideal R} {f : R ≃+* S} {x : R} :\n    f x ∈ I.map f ↔ x ∈ I := by\n  rw [← comap_symm, Ideal.mem_comap, f.symm_apply_apply]\n\n"}
{"name":"Ideal.mem_map_of_equiv","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\ninst✝³ : Semiring R\ninst✝² : Semiring S\nE : Type u_4\ninst✝¹ : EquivLike E R S\ninst✝ : RingEquivClass E R S\ne : E\nI : Ideal R\ny : S\n⊢ Iff (Membership.mem (Ideal.map e I) y) (Exists fun x => And (Membership.mem I x) (Eq (e x) y))","decl":"theorem mem_map_of_equiv {E : Type*} [EquivLike E R S] [RingEquivClass E R S] (e : E)\n    {I : Ideal R} (y : S) : y ∈ map e I ↔ ∃ x ∈ I, e x = y := by\n  constructor\n  · intro h\n    simp_rw [show map e I = _ from map_comap_of_equiv (e : R ≃+* S)] at h\n    exact ⟨(e : R ≃+* S).symm y, h, (e : R ≃+* S).apply_symm_apply y⟩\n  · rintro ⟨x, hx, rfl⟩\n    exact mem_map_of_mem e hx\n\n"}
{"name":"Ideal.comap_le_iff_le_map","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nhf : Function.Bijective ⇑f\nI : Ideal R\nK : Ideal S\n⊢ Iff (LE.le (Ideal.comap f K) I) (LE.le K (Ideal.map f I))","decl":"theorem comap_le_iff_le_map : comap f K ≤ I ↔ K ≤ map f I :=\n  ⟨fun h => le_map_of_comap_le_of_surjective f hf.right h, fun h =>\n    (relIsoOfBijective f hf).right_inv I ▸ comap_mono h⟩\n\n"}
{"name":"Ideal.comap_map_of_bijective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nhf : Function.Bijective ⇑f\nI : Ideal R\n⊢ Eq (Ideal.comap f (Ideal.map f I)) I","decl":"lemma comap_map_of_bijective : (I.map f).comap f = I :=\n  le_antisymm ((comap_le_iff_le_map f hf).mpr fun _ ↦ id) le_comap_map\n\n"}
{"name":"Ideal.isMaximal_map_iff_of_bijective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nhf : Function.Bijective ⇑f\nI : Ideal R\n⊢ Iff (Ideal.map f I).IsMaximal I.IsMaximal","decl":"theorem isMaximal_map_iff_of_bijective : IsMaximal (map f I) ↔ IsMaximal I := by\n  simpa only [isMaximal_def] using (relIsoOfBijective _ hf).symm.isCoatom_iff _\n\n"}
{"name":"Ideal.isMaximal_comap_iff_of_bijective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nhf : Function.Bijective ⇑f\nK : Ideal S\n⊢ Iff (Ideal.comap f K).IsMaximal K.IsMaximal","decl":"theorem isMaximal_comap_iff_of_bijective : IsMaximal (comap f K) ↔ IsMaximal K := by\n  simpa only [isMaximal_def] using (relIsoOfBijective _ hf).isCoatom_iff _\n\n"}
{"name":"Ideal.IsMaximal.map_bijective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nhf : Function.Bijective ⇑f\nI : Ideal R\na✝ : I.IsMaximal\n⊢ (Ideal.map f I).IsMaximal","decl":"alias ⟨_, IsMaximal.map_bijective⟩ := isMaximal_map_iff_of_bijective\n"}
{"name":"Ideal.IsMaximal.comap_bijective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nhf : Function.Bijective ⇑f\nK : Ideal S\na✝ : K.IsMaximal\n⊢ (Ideal.comap f K).IsMaximal","decl":"alias ⟨_, IsMaximal.comap_bijective⟩ := isMaximal_comap_iff_of_bijective\n\n"}
{"name":"Ideal.map_isMaximal_of_equiv","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\ninst✝³ : Semiring R\ninst✝² : Semiring S\nE : Type u_4\ninst✝¹ : EquivLike E R S\ninst✝ : RingEquivClass E R S\ne : E\np : Ideal R\nhp : p.IsMaximal\n⊢ (Ideal.map e p).IsMaximal","decl":"/-- A ring isomorphism sends a maximal ideal to a maximal ideal. -/\ninstance map_isMaximal_of_equiv {E : Type*} [EquivLike E R S] [RingEquivClass E R S] (e : E)\n    {p : Ideal R} [hp : p.IsMaximal] : (map e p).IsMaximal :=\n  hp.map_bijective e (EquivLike.bijective e)\n\n"}
{"name":"Ideal.comap_isMaximal_of_equiv","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\ninst✝³ : Semiring R\ninst✝² : Semiring S\nE : Type u_4\ninst✝¹ : EquivLike E R S\ninst✝ : RingEquivClass E R S\ne : E\np : Ideal S\nhp : p.IsMaximal\n⊢ (Ideal.comap e p).IsMaximal","decl":"/-- The pullback of a maximal ideal under a ring isomorphism is a maximal ideal. -/\ninstance comap_isMaximal_of_equiv {E : Type*} [EquivLike E R S] [RingEquivClass E R S] (e : E)\n    {p : Ideal S} [hp : p.IsMaximal] : (comap e p).IsMaximal :=\n  hp.comap_bijective e (EquivLike.bijective e)\n\n"}
{"name":"Ideal.isMaximal_iff_of_bijective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nhf : Function.Bijective ⇑f\n⊢ Iff Bot.bot.IsMaximal Bot.bot.IsMaximal","decl":"theorem isMaximal_iff_of_bijective : (⊥ : Ideal R).IsMaximal ↔ (⊥ : Ideal S).IsMaximal :=\n  ⟨fun h ↦ map_bot (f := f) ▸ h.map_bijective f hf, fun h ↦ have e := RingEquiv.ofBijective f hf\n    map_bot (f := e.symm) ▸ h.map_bijective _ e.symm.bijective⟩\n\n"}
{"name":"Ideal.map.isMaximal","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nhf : Function.Bijective ⇑f\nI : Ideal R\na✝ : I.IsMaximal\n⊢ (Ideal.map f I).IsMaximal","decl":"@[deprecated (since := \"2024-12-07\")] alias map.isMaximal := IsMaximal.map_bijective\n"}
{"name":"Ideal.comap.isMaximal","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nhf : Function.Bijective ⇑f\nK : Ideal S\na✝ : K.IsMaximal\n⊢ (Ideal.comap f K).IsMaximal","decl":"@[deprecated (since := \"2024-12-07\")] alias comap.isMaximal := IsMaximal.comap_bijective\n"}
{"name":"Ideal.RingEquiv.bot_maximal_iff","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : RingHomClass F R S\nhf : Function.Bijective ⇑f\n⊢ Iff Bot.bot.IsMaximal Bot.bot.IsMaximal","decl":"@[deprecated (since := \"2024-12-07\")] alias RingEquiv.bot_maximal_iff := isMaximal_iff_of_bijective\n\n"}
{"name":"Ideal.comap_map_of_surjective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Ring R\ninst✝² : Ring S\ninst✝¹ : FunLike F R S\ninst✝ : RingHomClass F R S\nf : F\nhf : Function.Surjective ⇑f\nI : Ideal R\n⊢ Eq (Ideal.comap f (Ideal.map f I)) (Max.max I (Ideal.comap f Bot.bot))","decl":"theorem comap_map_of_surjective (hf : Function.Surjective f) (I : Ideal R) :\n    comap f (map f I) = I ⊔ comap f ⊥ :=\n  le_antisymm\n    (fun r h =>\n      let ⟨s, hsi, hfsr⟩ := mem_image_of_mem_map_of_surjective f hf h\n      Submodule.mem_sup.2\n        ⟨s, hsi, r - s, (Submodule.mem_bot S).2 <| by rw [map_sub, hfsr, sub_self],\n          add_sub_cancel s r⟩)\n    (sup_le (map_le_iff_le_comap.1 le_rfl) (comap_mono bot_le))\n\n"}
{"name":"Ideal.comap_isMaximal_of_surjective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Ring R\ninst✝² : Ring S\ninst✝¹ : FunLike F R S\ninst✝ : RingHomClass F R S\nf : F\nhf : Function.Surjective ⇑f\nK : Ideal S\nH : K.IsMaximal\n⊢ (Ideal.comap f K).IsMaximal","decl":"theorem comap_isMaximal_of_surjective (hf : Function.Surjective f) {K : Ideal S} [H : IsMaximal K] :\n    IsMaximal (comap f K) := by\n  refine ⟨⟨comap_ne_top _ H.1.1, fun J hJ => ?_⟩⟩\n  suffices map f J = ⊤ by\n    have := congr_arg (comap f) this\n    rw [comap_top, comap_map_of_surjective _ hf, eq_top_iff] at this\n    rw [eq_top_iff]\n    exact le_trans this (sup_le (le_of_eq rfl) (le_trans (comap_mono bot_le) (le_of_lt hJ)))\n  refine\n    H.1.2 (map f J)\n      (lt_of_le_of_ne (le_map_of_comap_le_of_surjective _ hf (le_of_lt hJ)) fun h =>\n        ne_of_lt hJ (_root_.trans (congr_arg (comap f) h) ?_))\n  rw [comap_map_of_surjective _ hf, sup_eq_left]\n  exact le_trans (comap_mono bot_le) (le_of_lt hJ)\n\n"}
{"name":"Ideal.map_mul","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"S : Type v\nF : Type u_1\ninst✝³ : CommSemiring S\nR : Type u_2\ninst✝² : Semiring R\ninst✝¹ : FunLike F R S\ninst✝ : RingHomClass F R S\nf : F\nI J : Ideal R\n⊢ Eq (Ideal.map f (HMul.hMul I J)) (HMul.hMul (Ideal.map f I) (Ideal.map f J))","decl":"theorem map_mul {R} [Semiring R] [FunLike F R S] [RingHomClass F R S] (f : F) (I J : Ideal R) :\n    map f (I * J) = map f I * map f J :=\n  le_antisymm\n    (map_le_iff_le_comap.2 <|\n      mul_le.2 fun r hri s hsj =>\n        show (f (r * s)) ∈ map f I * map f J by\n          rw [_root_.map_mul]; exact mul_mem_mul (mem_map_of_mem f hri) (mem_map_of_mem f hsj))\n    (span_mul_span (↑f '' ↑I) (↑f '' ↑J) ▸ (span_le.2 <|\n      Set.iUnion₂_subset fun _ ⟨r, hri, hfri⟩ =>\n        Set.iUnion₂_subset fun _ ⟨s, hsj, hfsj⟩ =>\n          Set.singleton_subset_iff.2 <|\n            hfri ▸ hfsj ▸ by rw [← _root_.map_mul]; exact mem_map_of_mem f (mul_mem_mul hri hsj)))\n\n"}
{"name":"Ideal.mapHom_apply","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : FunLike F R S\nrc : RingHomClass F R S\nf : F\nI : Ideal R\n⊢ Eq ((Ideal.mapHom f) I) (Ideal.map f I)","decl":"/-- The pushforward `Ideal.map` as a (semi)ring homomorphism. -/\n@[simps]\ndef mapHom : Ideal R →+* Ideal S where\n  toFun := map f\n  map_mul' := Ideal.map_mul f\n  map_one' := by simp only [one_eq_top]; exact Ideal.map_top f\n  map_add' I J := Ideal.map_sup f I J\n  map_zero' := Ideal.map_bot\n\n"}
{"name":"Ideal.map_pow","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : FunLike F R S\nrc : RingHomClass F R S\nf : F\nI : Ideal R\nn : Nat\n⊢ Eq (Ideal.map f (HPow.hPow I n)) (HPow.hPow (Ideal.map f I) n)","decl":"protected theorem map_pow (n : ℕ) : map f (I ^ n) = map f I ^ n :=\n  map_pow (mapHom f) I n\n\n"}
{"name":"Ideal.comap_radical","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : FunLike F R S\nrc : RingHomClass F R S\nf : F\nK : Ideal S\n⊢ Eq (Ideal.comap f K.radical) (Ideal.comap f K).radical","decl":"theorem comap_radical : comap f (radical K) = radical (comap f K) := by\n  ext\n  simp [radical]\n\n"}
{"name":"Ideal.IsRadical.comap","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : FunLike F R S\nrc : RingHomClass F R S\nf : F\nK : Ideal S\nhK : K.IsRadical\n⊢ (Ideal.comap f K).IsRadical","decl":"theorem IsRadical.comap (hK : K.IsRadical) : (comap f K).IsRadical := by\n  rw [← hK.radical, comap_radical]\n  apply radical_isRadical\n\n"}
{"name":"Ideal.map_radical_le","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : FunLike F R S\nrc : RingHomClass F R S\nf : F\nI : Ideal R\n⊢ LE.le (Ideal.map f I.radical) (Ideal.map f I).radical","decl":"theorem map_radical_le : map f (radical I) ≤ radical (map f I) :=\n  map_le_iff_le_comap.2 fun r ⟨n, hrni⟩ => ⟨n, map_pow f r n ▸ mem_map_of_mem f hrni⟩\n\n"}
{"name":"Ideal.le_comap_mul","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : FunLike F R S\nrc : RingHomClass F R S\nf : F\nK L : Ideal S\n⊢ LE.le (HMul.hMul (Ideal.comap f K) (Ideal.comap f L)) (Ideal.comap f (HMul.hMul K L))","decl":"theorem le_comap_mul : comap f K * comap f L ≤ comap f (K * L) :=\n  map_le_iff_le_comap.1 <|\n    (map_mul f (comap f K) (comap f L)).symm ▸\n      mul_mono (map_le_iff_le_comap.2 <| le_rfl) (map_le_iff_le_comap.2 <| le_rfl)\n\n"}
{"name":"Ideal.le_comap_pow","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : FunLike F R S\nrc : RingHomClass F R S\nf : F\nK : Ideal S\nn : Nat\n⊢ LE.le (HPow.hPow (Ideal.comap f K) n) (Ideal.comap f (HPow.hPow K n))","decl":"theorem le_comap_pow (n : ℕ) : K.comap f ^ n ≤ (K ^ n).comap f := by\n  induction' n with n n_ih\n  · rw [pow_zero, pow_zero, Ideal.one_eq_top, Ideal.one_eq_top]\n    exact rfl.le\n  · rw [pow_succ, pow_succ]\n    exact (Ideal.mul_mono_left n_ih).trans (Ideal.le_comap_mul f)\n\n"}
{"name":"RingHom.mem_ker","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝² : Semiring R\ninst✝¹ : Semiring S\ninst✝ : FunLike F R S\nrcf : RingHomClass F R S\nf : F\nr : R\n⊢ Iff (Membership.mem (RingHom.ker f) r) (Eq (f r) 0)","decl":"variable {f} in\n/-- An element is in the kernel if and only if it maps to zero. -/\n@[simp] theorem mem_ker {r} : r ∈ ker f ↔ f r = 0 := by rw [ker, Ideal.mem_comap, Submodule.mem_bot]\n\n"}
{"name":"RingHom.ker_eq","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝² : Semiring R\ninst✝¹ : Semiring S\ninst✝ : FunLike F R S\nrcf : RingHomClass F R S\nf : F\n⊢ Eq (↑(RingHom.ker f)) (Set.preimage (⇑f) (Singleton.singleton 0))","decl":"theorem ker_eq : (ker f : Set R) = Set.preimage f {0} :=\n  rfl\n\n"}
{"name":"RingHom.ker_eq_comap_bot","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝² : Semiring R\ninst✝¹ : Semiring S\ninst✝ : FunLike F R S\nrcf : RingHomClass F R S\nf : F\n⊢ Eq (RingHom.ker f) (Ideal.comap f Bot.bot)","decl":"theorem ker_eq_comap_bot (f : F) : ker f = Ideal.comap f ⊥ :=\n  rfl\n\n"}
{"name":"RingHom.comap_ker","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nT : Type w\ninst✝² : Semiring R\ninst✝¹ : Semiring S\ninst✝ : Semiring T\nf : RingHom S R\ng : RingHom T S\n⊢ Eq (Ideal.comap g (RingHom.ker f)) (RingHom.ker (f.comp g))","decl":"theorem comap_ker (f : S →+* R) (g : T →+* S) : f.ker.comap g = ker (f.comp g) := by\n  rw [RingHom.ker_eq_comap_bot, Ideal.comap_comap, RingHom.ker_eq_comap_bot]\n\n"}
{"name":"RingHom.not_one_mem_ker","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nrcf : RingHomClass F R S\ninst✝ : Nontrivial S\nf : F\n⊢ Not (Membership.mem (RingHom.ker f) 1)","decl":"/-- If the target is not the zero ring, then one is not in the kernel. -/\ntheorem not_one_mem_ker [Nontrivial S] (f : F) : (1 : R) ∉ ker f := by\n  rw [mem_ker, map_one]\n  exact one_ne_zero\n\n"}
{"name":"RingHom.ker_ne_top","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝³ : Semiring R\ninst✝² : Semiring S\ninst✝¹ : FunLike F R S\nrcf : RingHomClass F R S\ninst✝ : Nontrivial S\nf : F\n⊢ Ne (RingHom.ker f) Top.top","decl":"theorem ker_ne_top [Nontrivial S] (f : F) : ker f ≠ ⊤ :=\n  (Ideal.ne_top_iff_one _).mpr <| not_one_mem_ker f\n\n"}
{"name":"Pi.ker_ringHom","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"S : Type v\ninst✝¹ : Semiring S\nι : Type u_3\nR : ι → Type u_4\ninst✝ : (i : ι) → Semiring (R i)\nφ : (i : ι) → RingHom S (R i)\n⊢ Eq (RingHom.ker (Pi.ringHom φ)) (iInf fun i => RingHom.ker (φ i))","decl":"lemma _root_.Pi.ker_ringHom {ι : Type*} {R : ι → Type*} [∀ i, Semiring (R i)]\n    (φ : ∀ i, S →+* R i) : ker (Pi.ringHom φ) = ⨅ i, ker (φ i) := by\n  ext x\n  simp [mem_ker, Ideal.mem_iInf, funext_iff]\n\n"}
{"name":"RingHom.ker_rangeSRestrict","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\n⊢ Eq (RingHom.ker f.rangeSRestrict) (RingHom.ker f)","decl":"@[simp]\ntheorem ker_rangeSRestrict (f : R →+* S) : ker f.rangeSRestrict = ker f :=\n  Ideal.ext fun _ ↦ Subtype.ext_iff\n\n"}
{"name":"RingHom.injective_iff_ker_eq_bot","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝² : Ring R\ninst✝¹ : Semiring S\ninst✝ : FunLike F R S\nrc : RingHomClass F R S\nf : F\n⊢ Iff (Function.Injective ⇑f) (Eq (RingHom.ker f) Bot.bot)","decl":"theorem injective_iff_ker_eq_bot : Function.Injective f ↔ ker f = ⊥ := by\n  rw [SetLike.ext'_iff, ker_eq, Set.ext_iff]\n  exact injective_iff_map_eq_zero' f\n\n"}
{"name":"RingHom.ker_eq_bot_iff_eq_zero","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝² : Ring R\ninst✝¹ : Semiring S\ninst✝ : FunLike F R S\nrc : RingHomClass F R S\nf : F\n⊢ Iff (Eq (RingHom.ker f) Bot.bot) (∀ (x : R), Eq (f x) 0 → Eq x 0)","decl":"theorem ker_eq_bot_iff_eq_zero : ker f = ⊥ ↔ ∀ x, f x = 0 → x = 0 := by\n  rw [← injective_iff_map_eq_zero f, injective_iff_ker_eq_bot]\n\n"}
{"name":"RingHom.ker_coe_equiv","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Semiring S\nf : RingEquiv R S\n⊢ Eq (RingHom.ker ↑f) Bot.bot","decl":"@[simp]\ntheorem ker_coe_equiv (f : R ≃+* S) : ker (f : R →+* S) = ⊥ := by\n  simpa only [← injective_iff_ker_eq_bot] using EquivLike.injective f\n\n"}
{"name":"RingHom.ker_equiv","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\ninst✝³ : Ring R\ninst✝² : Semiring S\nF' : Type u_2\ninst✝¹ : EquivLike F' R S\ninst✝ : RingEquivClass F' R S\nf : F'\n⊢ Eq (RingHom.ker f) Bot.bot","decl":"@[simp]\ntheorem ker_equiv {F' : Type*} [EquivLike F' R S] [RingEquivClass F' R S] (f : F') : ker f = ⊥ := by\n  simpa only [← injective_iff_ker_eq_bot] using EquivLike.injective f\n\n"}
{"name":"RingHom.sub_mem_ker_iff","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝² : Ring R\ninst✝¹ : Ring S\ninst✝ : FunLike F R S\nrc : RingHomClass F R S\nf : F\nx y : R\n⊢ Iff (Membership.mem (RingHom.ker f) (HSub.hSub x y)) (Eq (f x) (f y))","decl":"theorem sub_mem_ker_iff {x y} : x - y ∈ ker f ↔ f x = f y := by rw [mem_ker, map_sub, sub_eq_zero]\n\n"}
{"name":"RingHom.ker_rangeRestrict","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Ring R\ninst✝ : Ring S\nf : RingHom R S\n⊢ Eq (RingHom.ker f.rangeRestrict) (RingHom.ker f)","decl":"@[simp]\ntheorem ker_rangeRestrict (f : R →+* S) : ker f.rangeRestrict = ker f :=\n  Ideal.ext fun _ ↦ Subtype.ext_iff\n\n"}
{"name":"RingHom.ker_isPrime","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u\nS : Type v\nF : Type u_1\ninst✝⁴ : Semiring R\ninst✝³ : Semiring S\ninst✝² : IsDomain S\ninst✝¹ : FunLike F R S\ninst✝ : RingHomClass F R S\nf : F\n⊢ (RingHom.ker f).IsPrime","decl":"/-- The kernel of a homomorphism to a domain is a prime ideal. -/\ntheorem ker_isPrime {F : Type*} [Semiring R] [Semiring S] [IsDomain S]\n    [FunLike F R S] [RingHomClass F R S] (f : F) :\n    (ker f).IsPrime :=\n  ⟨by\n    rw [Ne, Ideal.eq_top_iff_one]\n    exact not_one_mem_ker f,\n   fun {x y} => by\n    simpa only [mem_ker, map_mul] using @eq_zero_or_eq_zero_of_mul_eq_zero S _ _ _ _ _⟩\n\n"}
{"name":"RingHom.ker_isMaximal_of_surjective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nK : Type u_2\nF : Type u_3\ninst✝³ : Ring R\ninst✝² : DivisionRing K\ninst✝¹ : FunLike F R K\ninst✝ : RingHomClass F R K\nf : F\nhf : Function.Surjective ⇑f\n⊢ (RingHom.ker f).IsMaximal","decl":"/-- The kernel of a homomorphism to a field is a maximal ideal. -/\ntheorem ker_isMaximal_of_surjective {R K F : Type*} [Ring R] [DivisionRing K]\n    [FunLike F R K] [RingHomClass F R K] (f : F)\n    (hf : Function.Surjective f) : (ker f).IsMaximal := by\n  refine\n    Ideal.isMaximal_iff.mpr\n      ⟨fun h1 => one_ne_zero' K <| map_one f ▸ mem_ker.mp h1, fun J x hJ hxf hxJ => ?_⟩\n  obtain ⟨y, hy⟩ := hf (f x)⁻¹\n  have H : 1 = y * x - (y * x - 1) := (sub_sub_cancel _ _).symm\n  rw [H]\n  refine J.sub_mem (J.mul_mem_left _ hxJ) (hJ ?_)\n  rw [mem_ker]\n  simp only [hy, map_sub, map_one, map_mul, inv_mul_cancel₀ (mt mem_ker.mpr hxf :), sub_self]\n\n"}
{"name":"Module.mem_annihilator","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nr : R\n⊢ Iff (Membership.mem (Module.annihilator R M) r) (∀ (m : M), Eq (HSMul.hSMul r m) 0)","decl":"theorem Module.mem_annihilator {r} : r ∈ Module.annihilator R M ↔ ∀ m : M, r • m = 0 :=\n  ⟨fun h ↦ (congr($h ·)), (AddMonoidHom.ext ·)⟩\n\n"}
{"name":"LinearMap.annihilator_le_of_injective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\nhf : Function.Injective ⇑f\n⊢ LE.le (Module.annihilator R M') (Module.annihilator R M)","decl":"theorem LinearMap.annihilator_le_of_injective (f : M →ₗ[R] M') (hf : Function.Injective f) :\n    Module.annihilator R M' ≤ Module.annihilator R M := fun x h ↦ by\n  rw [Module.mem_annihilator] at h ⊢; exact fun m ↦ hf (by rw [map_smul, h, f.map_zero])\n\n"}
{"name":"LinearMap.annihilator_le_of_surjective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\nhf : Function.Surjective ⇑f\n⊢ LE.le (Module.annihilator R M) (Module.annihilator R M')","decl":"theorem LinearMap.annihilator_le_of_surjective (f : M →ₗ[R] M')\n    (hf : Function.Surjective f) : Module.annihilator R M ≤ Module.annihilator R M' := fun x h ↦ by\n  rw [Module.mem_annihilator] at h ⊢\n  intro m; obtain ⟨m, rfl⟩ := hf m\n  rw [← map_smul, h, f.map_zero]\n\n"}
{"name":"LinearEquiv.annihilator_eq","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\ne : LinearEquiv (RingHom.id R) M M'\n⊢ Eq (Module.annihilator R M) (Module.annihilator R M')","decl":"theorem LinearEquiv.annihilator_eq (e : M ≃ₗ[R] M') :\n    Module.annihilator R M = Module.annihilator R M' :=\n  (e.annihilator_le_of_surjective e.surjective).antisymm (e.annihilator_le_of_injective e.injective)\n\n"}
{"name":"Module.comap_annihilator","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nR₀ : Type u_4\ninst✝³ : CommSemiring R₀\ninst✝² : Module R₀ M\ninst✝¹ : Algebra R₀ R\ninst✝ : IsScalarTower R₀ R M\n⊢ Eq (Ideal.comap (algebraMap R₀ R) (Module.annihilator R M)) (Module.annihilator R₀ M)","decl":"theorem Module.comap_annihilator {R₀} [CommSemiring R₀] [Module R₀ M]\n    [Algebra R₀ R] [IsScalarTower R₀ R M] :\n    (Module.annihilator R M).comap (algebraMap R₀ R) = Module.annihilator R₀ M := by\n  ext x\n  simp [mem_annihilator]\n\n"}
{"name":"Module.annihilator_eq_bot","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_4\nM : Type u_5\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (Eq (Module.annihilator R M) Bot.bot) (FaithfulSMul R M)","decl":"lemma Module.annihilator_eq_bot {R M} [Ring R] [AddCommGroup M] [Module R M] :\n    Module.annihilator R M = ⊥ ↔ FaithfulSMul R M := by\n  rw [← le_bot_iff]\n  refine ⟨fun H ↦ ⟨fun {r s} H' ↦ ?_⟩, fun ⟨H⟩ {a} ha ↦ ?_⟩\n  · rw [← sub_eq_zero]\n    exact H (Module.mem_annihilator (r := r - s).mpr\n      (by simp only [sub_smul, H', sub_self, implies_true]))\n  · exact @H a 0 (by simp [Module.mem_annihilator.mp ha])\n\n"}
{"name":"Submodule.annihilator_top","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq Top.top.annihilator (Module.annihilator R M)","decl":"theorem annihilator_top : (⊤ : Submodule R M).annihilator = Module.annihilator R M :=\n  topEquiv.annihilator_eq\n\n"}
{"name":"Submodule.mem_annihilator","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN : Submodule R M\nr : R\n⊢ Iff (Membership.mem N.annihilator r) (∀ (n : M), Membership.mem N n → Eq (HSMul.hSMul r n) 0)","decl":"theorem mem_annihilator {r} : r ∈ N.annihilator ↔ ∀ n ∈ N, r • n = (0 : M) := by\n  simp_rw [annihilator, Module.mem_annihilator, Subtype.forall, Subtype.ext_iff]; rfl\n\n"}
{"name":"Submodule.annihilator_bot","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq Bot.bot.annihilator Top.top","decl":"theorem annihilator_bot : (⊥ : Submodule R M).annihilator = ⊤ :=\n  top_le_iff.mp fun _ _ ↦ mem_annihilator.mpr fun _ ↦ by rintro rfl; rw [smul_zero]\n\n"}
{"name":"Submodule.annihilator_eq_top_iff","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN : Submodule R M\n⊢ Iff (Eq N.annihilator Top.top) (Eq N Bot.bot)","decl":"theorem annihilator_eq_top_iff : N.annihilator = ⊤ ↔ N = ⊥ :=\n  ⟨fun H ↦\n    eq_bot_iff.2 fun (n : M) hn =>\n      (mem_bot R).2 <| one_smul R n ▸ mem_annihilator.1 ((Ideal.eq_top_iff_one _).1 H) n hn,\n    fun H ↦ H.symm ▸ annihilator_bot⟩\n\n"}
{"name":"Submodule.annihilator_mono","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN P : Submodule R M\nh : LE.le N P\n⊢ LE.le P.annihilator N.annihilator","decl":"theorem annihilator_mono (h : N ≤ P) : P.annihilator ≤ N.annihilator := fun _ hrp =>\n  mem_annihilator.2 fun n hn => mem_annihilator.1 hrp n <| h hn\n\n"}
{"name":"Submodule.annihilator_iSup","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Sort w\nf : ι → Submodule R M\n⊢ Eq (iSup fun i => f i).annihilator (iInf fun i => (f i).annihilator)","decl":"theorem annihilator_iSup (ι : Sort w) (f : ι → Submodule R M) :\n    annihilator (⨆ i, f i) = ⨅ i, annihilator (f i) :=\n  le_antisymm (le_iInf fun _ => annihilator_mono <| le_iSup _ _) fun r H =>\n    mem_annihilator.2 fun n hn ↦ iSup_induction f (C := (r • · = 0)) hn\n      (fun i ↦ mem_annihilator.1 <| (mem_iInf _).mp H i) (smul_zero _)\n      fun m₁ m₂ h₁ h₂ ↦ by simp_rw [smul_add, h₁, h₂, add_zero]\n\n"}
{"name":"Submodule.annihilator_smul","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN : Submodule R M\n⊢ Eq (HSMul.hSMul N.annihilator N) Bot.bot","decl":"@[simp]\ntheorem annihilator_smul (N : Submodule R M) : annihilator N • N = ⊥ :=\n  eq_bot_iff.2 (smul_le.2 fun _ => mem_annihilator.1)\n\n"}
{"name":"Submodule.annihilator_mul","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nI : Ideal R\n⊢ Eq (HMul.hMul (Submodule.annihilator I) I) Bot.bot","decl":"@[simp]\ntheorem annihilator_mul (I : Ideal R) : annihilator I * I = ⊥ :=\n  annihilator_smul I\n\n"}
{"name":"Submodule.mem_annihilator'","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN : Submodule R M\nr : R\n⊢ Iff (Membership.mem N.annihilator r) (LE.le N (Submodule.comap (HSMul.hSMul r LinearMap.id) Bot.bot))","decl":"theorem mem_annihilator' {r} : r ∈ N.annihilator ↔ N ≤ comap (r • (LinearMap.id : M →ₗ[R] M)) ⊥ :=\n  mem_annihilator.trans ⟨fun H n hn => (mem_bot R).2 <| H n hn, fun H _ hn => (mem_bot R).1 <| H hn⟩\n\n"}
{"name":"Submodule.mem_annihilator_span","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\nr : R\n⊢ Iff (Membership.mem (Submodule.span R s).annihilator r) (∀ (n : ↑s), Eq (HSMul.hSMul r ↑n) 0)","decl":"theorem mem_annihilator_span (s : Set M) (r : R) :\n    r ∈ (Submodule.span R s).annihilator ↔ ∀ n : s, r • (n : M) = 0 := by\n  rw [Submodule.mem_annihilator]\n  constructor\n  · intro h n\n    exact h _ (Submodule.subset_span n.prop)\n  · intro h n hn\n    refine Submodule.span_induction ?_ ?_ ?_ ?_ hn\n    · intro x hx\n      exact h ⟨x, hx⟩\n    · exact smul_zero _\n    · intro x y _ _ hx hy\n      rw [smul_add, hx, hy, zero_add]\n    · intro a x _ hx\n      rw [smul_comm, hx, smul_zero]\n\n"}
{"name":"Submodule.mem_annihilator_span_singleton","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ng : M\nr : R\n⊢ Iff (Membership.mem (Submodule.span R (Singleton.singleton g)).annihilator r) (Eq (HSMul.hSMul r g) 0)","decl":"theorem mem_annihilator_span_singleton (g : M) (r : R) :\n    r ∈ (Submodule.span R ({g} : Set M)).annihilator ↔ r • g = 0 := by simp [mem_annihilator_span]\n\n"}
{"name":"Submodule.annihilator_span","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\n⊢ Eq (Submodule.span R s).annihilator (iInf fun g => LinearMap.ker (LinearMap.toSpanSingleton R M ↑g))","decl":"open LinearMap in\ntheorem annihilator_span (s : Set M) :\n    (Submodule.span R s).annihilator = ⨅ g : s, ker (toSpanSingleton R M g.1) := by\n  ext; simp [mem_annihilator_span]\n\n"}
{"name":"Submodule.annihilator_span_singleton","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ng : M\n⊢ Eq (Submodule.span R (Singleton.singleton g)).annihilator (LinearMap.ker (LinearMap.toSpanSingleton R M g))","decl":"open LinearMap in\ntheorem annihilator_span_singleton (g : M) :\n    (Submodule.span R {g}).annihilator = ker (toSpanSingleton R M g) := by\n  simp [annihilator_span]\n\n"}
{"name":"Submodule.mul_annihilator","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\n⊢ Eq (HMul.hMul I (Submodule.annihilator I)) Bot.bot","decl":"@[simp]\ntheorem mul_annihilator (I : Ideal R) : I * annihilator I = ⊥ := by rw [mul_comm, annihilator_mul]\n\n"}
{"name":"Ideal.map_eq_bot_iff_le_ker","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nS : Type u_2\nF : Type u_3\ninst✝² : Semiring R\ninst✝¹ : Semiring S\ninst✝ : FunLike F R S\nrc : RingHomClass F R S\nI : Ideal R\nf : F\n⊢ Iff (Eq (Ideal.map f I) Bot.bot) (LE.le I (RingHom.ker f))","decl":"theorem map_eq_bot_iff_le_ker {I : Ideal R} (f : F) : I.map f = ⊥ ↔ I ≤ RingHom.ker f := by\n  rw [RingHom.ker, eq_bot_iff, map_le_iff_le_comap]\n\n"}
{"name":"Ideal.ker_le_comap","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nS : Type u_2\nF : Type u_3\ninst✝² : Semiring R\ninst✝¹ : Semiring S\ninst✝ : FunLike F R S\nrc : RingHomClass F R S\nK : Ideal S\nf : F\n⊢ LE.le (RingHom.ker f) (Ideal.comap f K)","decl":"theorem ker_le_comap {K : Ideal S} (f : F) : RingHom.ker f ≤ comap f K := fun _ hx =>\n  mem_comap.2 (RingHom.mem_ker.1 hx ▸ K.zero_mem)\n\n"}
{"name":"Ideal.map_isPrime_of_equiv","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : Semiring R\ninst✝³ : Semiring S\nF' : Type u_4\ninst✝² : EquivLike F' R S\ninst✝¹ : RingEquivClass F' R S\nf : F'\nI : Ideal R\ninst✝ : I.IsPrime\n⊢ (Ideal.map f I).IsPrime","decl":"/-- A ring isomorphism sends a prime ideal to a prime ideal. -/\ninstance map_isPrime_of_equiv {F' : Type*} [EquivLike F' R S] [RingEquivClass F' R S]\n    (f : F') {I : Ideal R} [IsPrime I] : IsPrime (map f I) := by\n  have h : I.map f = I.map ((f : R ≃+* S) : R →+* S) := rfl\n  rw [h, map_comap_of_equiv (f : R ≃+* S)]\n  exact Ideal.IsPrime.comap (RingEquiv.symm (f : R ≃+* S))\n\n"}
{"name":"Ideal.map_eq_bot_iff_of_injective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nS : Type u_2\nF : Type u_3\ninst✝² : Semiring R\ninst✝¹ : Semiring S\ninst✝ : FunLike F R S\nrc : RingHomClass F R S\nI : Ideal R\nf : F\nhf : Function.Injective ⇑f\n⊢ Iff (Eq (Ideal.map f I) Bot.bot) (Eq I Bot.bot)","decl":"theorem map_eq_bot_iff_of_injective {I : Ideal R} {f : F} (hf : Function.Injective f) :\n    I.map f = ⊥ ↔ I = ⊥ := by\n  simp [map, span_eq_bot, ← map_zero f, -map_zero, hf.eq_iff, I.eq_bot_iff]\n\n"}
{"name":"Ideal.comap_map_of_surjective'","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nS : Type u_2\nF : Type u_3\ninst✝² : Ring R\ninst✝¹ : Ring S\ninst✝ : FunLike F R S\nrc : RingHomClass F R S\nf : F\nhf : Function.Surjective ⇑f\nI : Ideal R\n⊢ Eq (Ideal.comap f (Ideal.map f I)) (Max.max I (RingHom.ker f))","decl":"lemma comap_map_of_surjective' (f : F) (hf : Function.Surjective f) (I : Ideal R) :\n    (I.map f).comap f = I ⊔ RingHom.ker f :=\n  comap_map_of_surjective f hf I\n\n"}
{"name":"Ideal.map_sInf","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nS : Type u_2\nF : Type u_3\ninst✝² : Ring R\ninst✝¹ : Ring S\ninst✝ : FunLike F R S\nrc : RingHomClass F R S\nA : Set (Ideal R)\nf : F\nhf : Function.Surjective ⇑f\na✝ : ∀ (J : Ideal R), Membership.mem A J → LE.le (RingHom.ker f) J\n⊢ Eq (Ideal.map f (InfSet.sInf A)) (InfSet.sInf (Set.image (Ideal.map f) A))","decl":"theorem map_sInf {A : Set (Ideal R)} {f : F} (hf : Function.Surjective f) :\n    (∀ J ∈ A, RingHom.ker f ≤ J) → map f (sInf A) = sInf (map f '' A) := by\n  refine fun h => le_antisymm (le_sInf ?_) ?_\n  · intro j hj y hy\n    cases' (mem_map_iff_of_surjective f hf).1 hy with x hx\n    cases' (Set.mem_image _ _ _).mp hj with J hJ\n    rw [← hJ.right, ← hx.right]\n    exact mem_map_of_mem f (sInf_le_of_le hJ.left (le_of_eq rfl) hx.left)\n  · intro y hy\n    cases' hf y with x hx\n    refine hx ▸ mem_map_of_mem f ?_\n    have : ∀ I ∈ A, y ∈ map f I := by simpa using hy\n    rw [Submodule.mem_sInf]\n    intro J hJ\n    rcases (mem_map_iff_of_surjective f hf).1 (this J hJ) with ⟨x', hx', rfl⟩\n    have : x - x' ∈ J := by\n      apply h J hJ\n      rw [RingHom.mem_ker, map_sub, hx, sub_self]\n    simpa only [sub_add_cancel] using J.add_mem this hx'\n\n"}
{"name":"Ideal.map_isPrime_of_surjective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nS : Type u_2\nF : Type u_3\ninst✝² : Ring R\ninst✝¹ : Ring S\ninst✝ : FunLike F R S\nrc : RingHomClass F R S\nf : F\nhf : Function.Surjective ⇑f\nI : Ideal R\nH : I.IsPrime\nhk : LE.le (RingHom.ker f) I\n⊢ (Ideal.map f I).IsPrime","decl":"theorem map_isPrime_of_surjective {f : F} (hf : Function.Surjective f) {I : Ideal R} [H : IsPrime I]\n    (hk : RingHom.ker f ≤ I) : IsPrime (map f I) := by\n  refine ⟨fun h => H.ne_top (eq_top_iff.2 ?_), fun {x y} => ?_⟩\n  · replace h := congr_arg (comap f) h\n    rw [comap_map_of_surjective _ hf, comap_top] at h\n    exact h ▸ sup_le (le_of_eq rfl) hk\n  · refine fun hxy => (hf x).recOn fun a ha => (hf y).recOn fun b hb => ?_\n    rw [← ha, ← hb, ← _root_.map_mul f, mem_map_iff_of_surjective _ hf] at hxy\n    rcases hxy with ⟨c, hc, hc'⟩\n    rw [← sub_eq_zero, ← map_sub] at hc'\n    have : a * b ∈ I := by\n      convert I.sub_mem hc (hk (hc' : c - a * b ∈ RingHom.ker f)) using 1\n      abel\n    exact\n      (H.mem_or_mem this).imp (fun h => ha ▸ mem_map_of_mem f h) fun h => hb ▸ mem_map_of_mem f h\n\n"}
{"name":"Ideal.map_ne_bot_of_ne_bot","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nS : Type u_4\ninst✝³ : Ring S\ninst✝² : Nontrivial S\ninst✝¹ : Algebra R S\ninst✝ : NoZeroSMulDivisors R S\nI : Ideal R\nh : Ne I Bot.bot\n⊢ Ne (Ideal.map (algebraMap R S) I) Bot.bot","decl":"theorem map_ne_bot_of_ne_bot {S : Type*} [Ring S] [Nontrivial S] [Algebra R S]\n    [NoZeroSMulDivisors R S] {I : Ideal R} (h : I ≠ ⊥) : map (algebraMap R S) I ≠ ⊥ :=\n  (map_eq_bot_iff_of_injective (NoZeroSMulDivisors.algebraMap_injective R S)).mp.mt h\n\n"}
{"name":"Ideal.map_eq_iff_sup_ker_eq_of_surjective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nI J : Ideal R\nf : RingHom R S\nhf : Function.Surjective ⇑f\n⊢ Iff (Eq (Ideal.map f I) (Ideal.map f J)) (Eq (Max.max I (RingHom.ker f)) (Max.max J (RingHom.ker f)))","decl":"theorem map_eq_iff_sup_ker_eq_of_surjective {I J : Ideal R} (f : R →+* S)\n    (hf : Function.Surjective f) : map f I = map f J ↔ I ⊔ RingHom.ker f = J ⊔ RingHom.ker f := by\n  rw [← (comap_injective_of_surjective f hf).eq_iff, comap_map_of_surjective f hf,\n    comap_map_of_surjective f hf, RingHom.ker_eq_comap_bot]\n\n"}
{"name":"Ideal.map_radical_of_surjective","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : Function.Surjective ⇑f\nI : Ideal R\nh : LE.le (RingHom.ker f) I\n⊢ Eq (Ideal.map f I.radical) (Ideal.map f I).radical","decl":"theorem map_radical_of_surjective {f : R →+* S} (hf : Function.Surjective f) {I : Ideal R}\n    (h : RingHom.ker f ≤ I) : map f I.radical = (map f I).radical := by\n  rw [radical_eq_sInf, radical_eq_sInf]\n  have : ∀ J ∈ {J : Ideal R | I ≤ J ∧ J.IsPrime}, RingHom.ker f ≤ J := fun J hJ => h.trans hJ.left\n  convert map_sInf hf this\n  refine funext fun j => propext ⟨?_, ?_⟩\n  · rintro ⟨hj, hj'⟩\n    haveI : j.IsPrime := hj'\n    exact\n      ⟨comap f j, ⟨⟨map_le_iff_le_comap.1 hj, comap_isPrime f j⟩, map_comap_of_surjective f hf j⟩⟩\n  · rintro ⟨J, ⟨hJ, hJ'⟩⟩\n    haveI : J.IsPrime := hJ.right\n    exact ⟨hJ' ▸ map_mono hJ.left, hJ' ▸ map_isPrime_of_surjective hf (le_trans h hJ.left)⟩\n\n"}
{"name":"RingHom.liftOfRightInverseAux_comp_apply","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"A : Type u_1\nB : Type u_2\nC : Type u_3\ninst✝² : Ring A\ninst✝¹ : Ring B\ninst✝ : Ring C\nf : RingHom A B\nf_inv : B → A\nhf : Function.RightInverse f_inv ⇑f\ng : RingHom A C\nhg : LE.le (RingHom.ker f) (RingHom.ker g)\na : A\n⊢ Eq ((f.liftOfRightInverseAux f_inv hf g hg) (f a)) (g a)","decl":"@[simp]\ntheorem liftOfRightInverseAux_comp_apply (hf : Function.RightInverse f_inv f) (g : A →+* C)\n    (hg : RingHom.ker f ≤ RingHom.ker g) (a : A) :\n    (f.liftOfRightInverseAux f_inv hf g hg) (f a) = g a :=\n  f.toAddMonoidHom.liftOfRightInverse_comp_apply f_inv hf ⟨g.toAddMonoidHom, hg⟩ a\n\n"}
{"name":"RingHom.liftOfRightInverse_comp_apply","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"A : Type u_1\nB : Type u_2\nC : Type u_3\ninst✝² : Ring A\ninst✝¹ : Ring B\ninst✝ : Ring C\nf : RingHom A B\nf_inv : B → A\nhf : Function.RightInverse f_inv ⇑f\ng : Subtype fun g => LE.le (RingHom.ker f) (RingHom.ker g)\nx : A\n⊢ Eq (((f.liftOfRightInverse f_inv hf) g) (f x)) (↑g x)","decl":"theorem liftOfRightInverse_comp_apply (hf : Function.RightInverse f_inv f)\n    (g : { g : A →+* C // RingHom.ker f ≤ RingHom.ker g }) (x : A) :\n    (f.liftOfRightInverse f_inv hf g) (f x) = g.1 x :=\n  f.liftOfRightInverseAux_comp_apply f_inv hf g.1 g.2 x\n\n"}
{"name":"RingHom.liftOfRightInverse_comp","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"A : Type u_1\nB : Type u_2\nC : Type u_3\ninst✝² : Ring A\ninst✝¹ : Ring B\ninst✝ : Ring C\nf : RingHom A B\nf_inv : B → A\nhf : Function.RightInverse f_inv ⇑f\ng : Subtype fun g => LE.le (RingHom.ker f) (RingHom.ker g)\n⊢ Eq (((f.liftOfRightInverse f_inv hf) g).comp f) ↑g","decl":"theorem liftOfRightInverse_comp (hf : Function.RightInverse f_inv f)\n    (g : { g : A →+* C // RingHom.ker f ≤ RingHom.ker g }) :\n    (f.liftOfRightInverse f_inv hf g).comp f = g :=\n  RingHom.ext <| f.liftOfRightInverse_comp_apply f_inv hf g\n\n"}
{"name":"RingHom.eq_liftOfRightInverse","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"A : Type u_1\nB : Type u_2\nC : Type u_3\ninst✝² : Ring A\ninst✝¹ : Ring B\ninst✝ : Ring C\nf : RingHom A B\nf_inv : B → A\nhf : Function.RightInverse f_inv ⇑f\ng : RingHom A C\nhg : LE.le (RingHom.ker f) (RingHom.ker g)\nh : RingHom B C\nhh : Eq (h.comp f) g\n⊢ Eq h ((f.liftOfRightInverse f_inv hf) ⟨g, hg⟩)","decl":"theorem eq_liftOfRightInverse (hf : Function.RightInverse f_inv f) (g : A →+* C)\n    (hg : RingHom.ker f ≤ RingHom.ker g) (h : B →+* C) (hh : h.comp f = g) :\n    h = f.liftOfRightInverse f_inv hf ⟨g, hg⟩ := by\n  simp_rw [← hh]\n  exact ((f.liftOfRightInverse f_inv hf).apply_symm_apply _).symm\n\n"}
{"name":"AlgHom.coe_ker","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgHom R A B\n⊢ Eq (RingHom.ker f) (RingHom.ker ↑f)","decl":"lemma coe_ker : RingHom.ker f = RingHom.ker (f : A →+* B) := rfl\n\n"}
{"name":"AlgHom.coe_ideal_map","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgHom R A B\nI : Ideal A\n⊢ Eq (Ideal.map f I) (Ideal.map (↑f) I)","decl":"lemma coe_ideal_map (I : Ideal A) :\n    Ideal.map f I = Ideal.map (f : A →+* B) I := rfl\n\n"}
{"name":"AlgHom.comap_ker","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : Semiring B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\nC : Type u_4\ninst✝¹ : Semiring C\ninst✝ : Algebra R C\nf : AlgHom R B C\ng : AlgHom R A B\n⊢ Eq (Ideal.comap g (RingHom.ker f)) (RingHom.ker (f.comp g))","decl":"lemma comap_ker {C : Type*} [Semiring C] [Algebra R C] (f : B →ₐ[R] C) (g : A →ₐ[R] B) :\n    (RingHom.ker f).comap g = RingHom.ker (f.comp g) :=\n  RingHom.comap_ker f.toRingHom g.toRingHom\n\n"}
{"name":"Algebra.idealMap_apply_coe","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Type u_2\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nI : Ideal R\nc : Subtype fun x => Membership.mem I x\n⊢ Eq (↑((Algebra.idealMap S I) c)) ((algebraMap R S) ↑c)","decl":"/-- The induced linear map from `I` to the span of `I` in an `R`-algebra `S`. -/\n@[simps!]\ndef idealMap (I : Ideal R) : I →ₗ[R] I.map (algebraMap R S) :=\n  (Algebra.linearMap R S).restrict (q := (I.map (algebraMap R S)).restrictScalars R)\n    (fun _ ↦ Ideal.mem_map_of_mem _)\n\n"}
{"name":"NoZeroSMulDivisors.of_ker_algebraMap_eq_bot","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : Semiring A\ninst✝¹ : Algebra R A\ninst✝ : NoZeroDivisors A\nh : Eq (RingHom.ker (algebraMap R A)) Bot.bot\n⊢ NoZeroSMulDivisors R A","decl":"theorem of_ker_algebraMap_eq_bot (R A : Type*) [CommRing R] [Semiring A] [Algebra R A]\n    [NoZeroDivisors A] (h : RingHom.ker (algebraMap R A) = ⊥) : NoZeroSMulDivisors R A :=\n  of_algebraMap_injective ((RingHom.injective_iff_ker_eq_bot _).mpr h)\n\n"}
{"name":"NoZeroSMulDivisors.ker_algebraMap_eq_bot","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring A\ninst✝² : Nontrivial A\ninst✝¹ : Algebra R A\ninst✝ : NoZeroSMulDivisors R A\n⊢ Eq (RingHom.ker (algebraMap R A)) Bot.bot","decl":"theorem ker_algebraMap_eq_bot (R A : Type*) [CommSemiring R] [Semiring A] [Nontrivial A]\n    [Algebra R A] [NoZeroSMulDivisors R A] : RingHom.ker (algebraMap R A) = ⊥ := by\n  ext; simp [Algebra.algebraMap_eq_smul_one']\n\n"}
{"name":"NoZeroSMulDivisors.iff_ker_algebraMap_eq_bot","module":"Mathlib.RingTheory.Ideal.Maps","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : Ring A\ninst✝¹ : IsDomain A\ninst✝ : Algebra R A\n⊢ Iff (NoZeroSMulDivisors R A) (Eq (RingHom.ker (algebraMap R A)) Bot.bot)","decl":"theorem iff_ker_algebraMap_eq_bot {R A : Type*} [CommRing R] [Ring A] [IsDomain A] [Algebra R A] :\n    NoZeroSMulDivisors R A ↔ RingHom.ker (algebraMap R A) = ⊥ :=\n  iff_algebraMap_injective.trans (RingHom.injective_iff_ker_eq_bot (algebraMap R A))\n\n"}
