{"name":"ENNReal.instCharZero","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ CharZero ENNReal","decl":"instance : CharZero ℝ≥0∞ := inferInstanceAs (CharZero (WithTop ℝ≥0))\n"}
{"name":"ENNReal.instCanonicallyOrderedAdd","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ CanonicallyOrderedAdd ENNReal","decl":"instance : CanonicallyOrderedAdd ℝ≥0∞ :=\n  inferInstanceAs (CanonicallyOrderedAdd (WithTop ℝ≥0))\n\n"}
{"name":"ENNReal.instNoZeroDivisors","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ NoZeroDivisors ENNReal","decl":"instance : NoZeroDivisors ℝ≥0∞ :=\n  inferInstanceAs (NoZeroDivisors (WithTop ℝ≥0))\n\n"}
{"name":"ENNReal.instDenselyOrdered","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ DenselyOrdered ENNReal","decl":"instance : DenselyOrdered ℝ≥0∞ := inferInstanceAs (DenselyOrdered (WithTop ℝ≥0))\n\n"}
{"name":"ENNReal.instOrderedSub","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ OrderedSub ENNReal","decl":"instance : OrderedSub ℝ≥0∞ := inferInstanceAs (OrderedSub (WithTop ℝ≥0))\n\n"}
{"name":"ENNReal.mulLeftMono","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ MulLeftMono ENNReal","decl":"instance mulLeftMono : MulLeftMono ℝ≥0∞ := inferInstance\n\n"}
{"name":"ENNReal.addLeftMono","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ AddLeftMono ENNReal","decl":"instance addLeftMono : AddLeftMono ℝ≥0∞ := inferInstance\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: add a `WithTop` instance and use it here\n"}
{"name":"ENNReal.canLift","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ CanLift ENNReal NNReal ENNReal.ofNNReal fun x => Ne x Top.top","decl":"instance canLift : CanLift ℝ≥0∞ ℝ≥0 ofNNReal (· ≠ ∞) := WithTop.canLift\n\n"}
{"name":"ENNReal.none_eq_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Eq Option.none Top.top","decl":"@[simp] theorem none_eq_top : (none : ℝ≥0∞) = ∞ := rfl\n\n"}
{"name":"ENNReal.some_eq_coe","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : NNReal\n⊢ Eq (Option.some a) ↑a","decl":"@[simp] theorem some_eq_coe (a : ℝ≥0) : (Option.some a : ℝ≥0∞) = (↑a : ℝ≥0∞) := rfl\n\n"}
{"name":"ENNReal.some_eq_coe'","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : NNReal\n⊢ Eq ↑a ↑a","decl":"@[simp] theorem some_eq_coe' (a : ℝ≥0) : (WithTop.some a : ℝ≥0∞) = (↑a : ℝ≥0∞) := rfl\n\n"}
{"name":"ENNReal.coe_injective","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Function.Injective ENNReal.ofNNReal","decl":"lemma coe_injective : Injective ((↑) : ℝ≥0 → ℝ≥0∞) := WithTop.coe_injective\n\n"}
{"name":"ENNReal.coe_inj","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"p q : NNReal\n⊢ Iff (Eq ↑p ↑q) (Eq p q)","decl":"@[simp, norm_cast] lemma coe_inj : (p : ℝ≥0∞) = q ↔ p = q := coe_injective.eq_iff\n\n"}
{"name":"ENNReal.coe_ne_coe","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"p q : NNReal\n⊢ Iff (Ne ↑p ↑q) (Ne p q)","decl":"lemma coe_ne_coe : (p : ℝ≥0∞) ≠ q ↔ p ≠ q := coe_inj.not\n\n"}
{"name":"ENNReal.range_coe'","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Eq (Set.range ENNReal.ofNNReal) (Set.Iio Top.top)","decl":"theorem range_coe' : range ofNNReal = Iio ∞ := WithTop.range_coe\n"}
{"name":"ENNReal.range_coe","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Eq (Set.range ENNReal.ofNNReal) (HasCompl.compl (Singleton.singleton Top.top))","decl":"theorem range_coe : range ofNNReal = {∞}ᶜ := (isCompl_range_some_none ℝ≥0).symm.compl_eq.symm\n\n"}
{"name":"ENNReal.coe_nnratCast","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"q : NNRat\n⊢ Eq ↑↑q ↑q","decl":"@[norm_cast]\ntheorem coe_nnratCast (q : ℚ≥0) : ↑(q : ℝ≥0) = (q : ℝ≥0∞) := rfl\n\n"}
{"name":"ENNReal.toNNReal_coe","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : NNReal\n⊢ Eq (↑r).toNNReal r","decl":"@[simp, norm_cast] lemma toNNReal_coe (r : ℝ≥0) : (r : ℝ≥0∞).toNNReal = r := rfl\n\n"}
{"name":"ENNReal.coe_toNNReal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : ENNReal\na✝ : Ne a Top.top\n⊢ Eq (↑a.toNNReal) a","decl":"@[simp]\ntheorem coe_toNNReal : ∀ {a : ℝ≥0∞}, a ≠ ∞ → ↑a.toNNReal = a\n  | ofNNReal _, _ => rfl\n  | ⊤, h => (h rfl).elim\n\n"}
{"name":"ENNReal.ofReal_toReal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : ENNReal\nh : Ne a Top.top\n⊢ Eq (ENNReal.ofReal a.toReal) a","decl":"@[simp]\ntheorem ofReal_toReal {a : ℝ≥0∞} (h : a ≠ ∞) : ENNReal.ofReal a.toReal = a := by\n  simp [ENNReal.toReal, ENNReal.ofReal, h]\n\n"}
{"name":"ENNReal.toReal_ofReal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : Real\nh : LE.le 0 r\n⊢ Eq (ENNReal.ofReal r).toReal r","decl":"@[simp]\ntheorem toReal_ofReal {r : ℝ} (h : 0 ≤ r) : (ENNReal.ofReal r).toReal = r :=\n  max_eq_left h\n\n"}
{"name":"ENNReal.toReal_ofReal'","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : Real\n⊢ Eq (ENNReal.ofReal r).toReal (Max.max r 0)","decl":"theorem toReal_ofReal' {r : ℝ} : (ENNReal.ofReal r).toReal = max r 0 := rfl\n\n"}
{"name":"ENNReal.coe_toNNReal_le_self","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : ENNReal\n⊢ LE.le (↑a.toNNReal) a","decl":"theorem coe_toNNReal_le_self : ∀ {a : ℝ≥0∞}, ↑a.toNNReal ≤ a\n  | ofNNReal r => by rw [toNNReal_coe]\n  | ⊤ => le_top\n\n"}
{"name":"ENNReal.coe_nnreal_eq","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : NNReal\n⊢ Eq (↑r) (ENNReal.ofReal ↑r)","decl":"theorem coe_nnreal_eq (r : ℝ≥0) : (r : ℝ≥0∞) = ENNReal.ofReal r := by\n  rw [ENNReal.ofReal, Real.toNNReal_coe]\n\n"}
{"name":"ENNReal.ofReal_eq_coe_nnreal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"x : Real\nh : LE.le 0 x\n⊢ Eq (ENNReal.ofReal x) ↑⟨x, h⟩","decl":"theorem ofReal_eq_coe_nnreal {x : ℝ} (h : 0 ≤ x) :\n    ENNReal.ofReal x = ofNNReal ⟨x, h⟩ :=\n  (coe_nnreal_eq ⟨x, h⟩).symm\n\n"}
{"name":"ENNReal.ofNNReal_toNNReal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"x : Real\n⊢ Eq (↑x.toNNReal) (ENNReal.ofReal x)","decl":"theorem ofNNReal_toNNReal (x : ℝ) : (Real.toNNReal x : ℝ≥0∞) = ENNReal.ofReal x := rfl\n\n"}
{"name":"ENNReal.ofReal_coe_nnreal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"p : NNReal\n⊢ Eq (ENNReal.ofReal ↑p) ↑p","decl":"@[simp] theorem ofReal_coe_nnreal : ENNReal.ofReal p = p := (coe_nnreal_eq p).symm\n\n"}
{"name":"ENNReal.coe_zero","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Eq (↑0) 0","decl":"@[simp, norm_cast] theorem coe_zero : ↑(0 : ℝ≥0) = (0 : ℝ≥0∞) := rfl\n\n"}
{"name":"ENNReal.coe_one","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Eq (↑1) 1","decl":"@[simp, norm_cast] theorem coe_one : ↑(1 : ℝ≥0) = (1 : ℝ≥0∞) := rfl\n\n"}
{"name":"ENNReal.toReal_nonneg","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : ENNReal\n⊢ LE.le 0 a.toReal","decl":"@[simp] theorem toReal_nonneg {a : ℝ≥0∞} : 0 ≤ a.toReal := a.toNNReal.2\n\n"}
{"name":"ENNReal.coe_toNNReal_eq_toReal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"z : ENNReal\n⊢ Eq (↑z.toNNReal) z.toReal","decl":"@[norm_cast] theorem coe_toNNReal_eq_toReal (z : ℝ≥0∞) : (z.toNNReal : ℝ) = z.toReal := rfl\n\n"}
{"name":"ENNReal.toNNReal_toReal_eq","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"z : ENNReal\n⊢ Eq z.toReal.toNNReal z.toNNReal","decl":"@[simp] theorem toNNReal_toReal_eq (z : ℝ≥0∞) : z.toReal.toNNReal = z.toNNReal := by\n  ext; simp [coe_toNNReal_eq_toReal]\n\n"}
{"name":"ENNReal.top_toNNReal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Eq Top.top.toNNReal 0","decl":"@[simp] theorem top_toNNReal : ∞.toNNReal = 0 := rfl\n\n"}
{"name":"ENNReal.top_toReal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Eq Top.top.toReal 0","decl":"@[simp] theorem top_toReal : ∞.toReal = 0 := rfl\n\n"}
{"name":"ENNReal.one_toReal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Eq (ENNReal.toReal 1) 1","decl":"@[simp] theorem one_toReal : (1 : ℝ≥0∞).toReal = 1 := rfl\n\n"}
{"name":"ENNReal.one_toNNReal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Eq (ENNReal.toNNReal 1) 1","decl":"@[simp] theorem one_toNNReal : (1 : ℝ≥0∞).toNNReal = 1 := rfl\n\n"}
{"name":"ENNReal.coe_toReal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : NNReal\n⊢ Eq (↑r).toReal ↑r","decl":"@[simp] theorem coe_toReal (r : ℝ≥0) : (r : ℝ≥0∞).toReal = r := rfl\n\n"}
{"name":"ENNReal.zero_toNNReal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Eq (ENNReal.toNNReal 0) 0","decl":"@[simp] theorem zero_toNNReal : (0 : ℝ≥0∞).toNNReal = 0 := rfl\n\n"}
{"name":"ENNReal.zero_toReal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Eq (ENNReal.toReal 0) 0","decl":"@[simp] theorem zero_toReal : (0 : ℝ≥0∞).toReal = 0 := rfl\n\n"}
{"name":"ENNReal.ofReal_zero","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Eq (ENNReal.ofReal 0) 0","decl":"@[simp] theorem ofReal_zero : ENNReal.ofReal (0 : ℝ) = 0 := by simp [ENNReal.ofReal]\n\n"}
{"name":"ENNReal.ofReal_one","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Eq (ENNReal.ofReal 1) 1","decl":"@[simp] theorem ofReal_one : ENNReal.ofReal (1 : ℝ) = (1 : ℝ≥0∞) := by simp [ENNReal.ofReal]\n\n"}
{"name":"ENNReal.ofReal_toReal_le","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : ENNReal\n⊢ LE.le (ENNReal.ofReal a.toReal) a","decl":"theorem ofReal_toReal_le {a : ℝ≥0∞} : ENNReal.ofReal a.toReal ≤ a :=\n  if ha : a = ∞ then ha.symm ▸ le_top else le_of_eq (ofReal_toReal ha)\n\n"}
{"name":"ENNReal.forall_ennreal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"p : ENNReal → Prop\n⊢ Iff (∀ (a : ENNReal), p a) (And (∀ (r : NNReal), p ↑r) (p Top.top))","decl":"theorem forall_ennreal {p : ℝ≥0∞ → Prop} : (∀ a, p a) ↔ (∀ r : ℝ≥0, p r) ∧ p ∞ :=\n  Option.forall.trans and_comm\n\n"}
{"name":"ENNReal.forall_ne_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"p : ENNReal → Prop\n⊢ Iff (∀ (a : ENNReal), Ne a Top.top → p a) (∀ (r : NNReal), p ↑r)","decl":"theorem forall_ne_top {p : ℝ≥0∞ → Prop} : (∀ a, a ≠ ∞ → p a) ↔ ∀ r : ℝ≥0, p r :=\n  Option.ball_ne_none\n\n"}
{"name":"ENNReal.exists_ne_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"p : ENNReal → Prop\n⊢ Iff (Exists fun a => And (Ne a Top.top) (p a)) (Exists fun r => p ↑r)","decl":"theorem exists_ne_top {p : ℝ≥0∞ → Prop} : (∃ a ≠ ∞, p a) ↔ ∃ r : ℝ≥0, p r :=\n  Option.exists_ne_none\n\n"}
{"name":"ENNReal.toNNReal_eq_zero_iff","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"x : ENNReal\n⊢ Iff (Eq x.toNNReal 0) (Or (Eq x 0) (Eq x Top.top))","decl":"theorem toNNReal_eq_zero_iff (x : ℝ≥0∞) : x.toNNReal = 0 ↔ x = 0 ∨ x = ∞ :=\n  WithTop.untop'_eq_self_iff\n\n"}
{"name":"ENNReal.toReal_eq_zero_iff","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"x : ENNReal\n⊢ Iff (Eq x.toReal 0) (Or (Eq x 0) (Eq x Top.top))","decl":"theorem toReal_eq_zero_iff (x : ℝ≥0∞) : x.toReal = 0 ↔ x = 0 ∨ x = ∞ := by\n  simp [ENNReal.toReal, toNNReal_eq_zero_iff]\n\n"}
{"name":"ENNReal.toNNReal_ne_zero","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : ENNReal\n⊢ Iff (Ne a.toNNReal 0) (And (Ne a 0) (Ne a Top.top))","decl":"theorem toNNReal_ne_zero : a.toNNReal ≠ 0 ↔ a ≠ 0 ∧ a ≠ ∞ :=\n  a.toNNReal_eq_zero_iff.not.trans not_or\n\n"}
{"name":"ENNReal.toReal_ne_zero","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : ENNReal\n⊢ Iff (Ne a.toReal 0) (And (Ne a 0) (Ne a Top.top))","decl":"theorem toReal_ne_zero : a.toReal ≠ 0 ↔ a ≠ 0 ∧ a ≠ ∞ :=\n  a.toReal_eq_zero_iff.not.trans not_or\n\n"}
{"name":"ENNReal.toNNReal_eq_one_iff","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"x : ENNReal\n⊢ Iff (Eq x.toNNReal 1) (Eq x 1)","decl":"theorem toNNReal_eq_one_iff (x : ℝ≥0∞) : x.toNNReal = 1 ↔ x = 1 :=\n  WithTop.untop'_eq_iff.trans <| by simp\n\n"}
{"name":"ENNReal.toReal_eq_one_iff","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"x : ENNReal\n⊢ Iff (Eq x.toReal 1) (Eq x 1)","decl":"theorem toReal_eq_one_iff (x : ℝ≥0∞) : x.toReal = 1 ↔ x = 1 := by\n  rw [ENNReal.toReal, NNReal.coe_eq_one, ENNReal.toNNReal_eq_one_iff]\n\n"}
{"name":"ENNReal.toNNReal_ne_one","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : ENNReal\n⊢ Iff (Ne a.toNNReal 1) (Ne a 1)","decl":"theorem toNNReal_ne_one : a.toNNReal ≠ 1 ↔ a ≠ 1 :=\n  a.toNNReal_eq_one_iff.not\n\n"}
{"name":"ENNReal.toReal_ne_one","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : ENNReal\n⊢ Iff (Ne a.toReal 1) (Ne a 1)","decl":"theorem toReal_ne_one : a.toReal ≠ 1 ↔ a ≠ 1 :=\n  a.toReal_eq_one_iff.not\n\n"}
{"name":"ENNReal.coe_ne_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : NNReal\n⊢ Ne (↑r) Top.top","decl":"@[simp, aesop (rule_sets := [finiteness]) safe apply]\ntheorem coe_ne_top : (r : ℝ≥0∞) ≠ ∞ := WithTop.coe_ne_top\n\n"}
{"name":"ENNReal.top_ne_coe","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : NNReal\n⊢ Ne Top.top ↑r","decl":"@[simp] theorem top_ne_coe : ∞ ≠ (r : ℝ≥0∞) := WithTop.top_ne_coe\n\n"}
{"name":"ENNReal.coe_lt_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : NNReal\n⊢ LT.lt (↑r) Top.top","decl":"@[simp] theorem coe_lt_top : (r : ℝ≥0∞) < ∞ := WithTop.coe_lt_top r\n\n"}
{"name":"ENNReal.ofReal_ne_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : Real\n⊢ Ne (ENNReal.ofReal r) Top.top","decl":"@[simp, aesop (rule_sets := [finiteness]) safe apply]\ntheorem ofReal_ne_top {r : ℝ} : ENNReal.ofReal r ≠ ∞ := coe_ne_top\n\n"}
{"name":"ENNReal.ofReal_lt_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : Real\n⊢ LT.lt (ENNReal.ofReal r) Top.top","decl":"@[simp] theorem ofReal_lt_top {r : ℝ} : ENNReal.ofReal r < ∞ := coe_lt_top\n\n"}
{"name":"ENNReal.top_ne_ofReal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : Real\n⊢ Ne Top.top (ENNReal.ofReal r)","decl":"@[simp] theorem top_ne_ofReal {r : ℝ} : ∞ ≠ ENNReal.ofReal r := top_ne_coe\n\n"}
{"name":"ENNReal.ofReal_toReal_eq_iff","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : ENNReal\n⊢ Iff (Eq (ENNReal.ofReal a.toReal) a) (Ne a Top.top)","decl":"@[simp]\ntheorem ofReal_toReal_eq_iff : ENNReal.ofReal a.toReal = a ↔ a ≠ ⊤ :=\n  ⟨fun h => by\n    rw [← h]\n    exact ofReal_ne_top, ofReal_toReal⟩\n\n"}
{"name":"ENNReal.toReal_ofReal_eq_iff","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : Real\n⊢ Iff (Eq (ENNReal.ofReal a).toReal a) (LE.le 0 a)","decl":"@[simp]\ntheorem toReal_ofReal_eq_iff {a : ℝ} : (ENNReal.ofReal a).toReal = a ↔ 0 ≤ a :=\n  ⟨fun h => by\n    rw [← h]\n    exact toReal_nonneg, toReal_ofReal⟩\n\n"}
{"name":"ENNReal.zero_ne_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Ne 0 Top.top","decl":"@[simp, aesop (rule_sets := [finiteness]) safe apply] theorem zero_ne_top : 0 ≠ ∞ := coe_ne_top\n\n"}
{"name":"ENNReal.top_ne_zero","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Ne Top.top 0","decl":"@[simp] theorem top_ne_zero : ∞ ≠ 0 := top_ne_coe\n\n"}
{"name":"ENNReal.one_ne_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Ne 1 Top.top","decl":"@[simp, aesop (rule_sets := [finiteness]) safe apply] theorem one_ne_top : 1 ≠ ∞ := coe_ne_top\n\n"}
{"name":"ENNReal.top_ne_one","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Ne Top.top 1","decl":"@[simp] theorem top_ne_one : ∞ ≠ 1 := top_ne_coe\n\n"}
{"name":"ENNReal.zero_lt_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ LT.lt 0 Top.top","decl":"@[simp] theorem zero_lt_top : 0 < ∞ := coe_lt_top\n\n"}
{"name":"ENNReal.coe_le_coe","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r q : NNReal\n⊢ Iff (LE.le ↑r ↑q) (LE.le r q)","decl":"@[simp, norm_cast] theorem coe_le_coe : (↑r : ℝ≥0∞) ≤ ↑q ↔ r ≤ q := WithTop.coe_le_coe\n\n"}
{"name":"ENNReal.coe_lt_coe","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r q : NNReal\n⊢ Iff (LT.lt ↑r ↑q) (LT.lt r q)","decl":"@[simp, norm_cast] theorem coe_lt_coe : (↑r : ℝ≥0∞) < ↑q ↔ r < q := WithTop.coe_lt_coe\n\n-- Needed until `@[gcongr]` accepts iff statements\n"}
{"name":"ENNReal.coe_le_coe_of_le","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r q : NNReal\na✝ : LE.le r q\n⊢ LE.le ↑r ↑q","decl":"alias ⟨_, coe_le_coe_of_le⟩ := coe_le_coe\n"}
{"name":"ENNReal.coe_lt_coe_of_lt","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r q : NNReal\na✝ : LT.lt r q\n⊢ LT.lt ↑r ↑q","decl":"alias ⟨_, coe_lt_coe_of_lt⟩ := coe_lt_coe\n"}
{"name":"ENNReal.coe_mono","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Monotone ENNReal.ofNNReal","decl":"theorem coe_mono : Monotone ofNNReal := fun _ _ => coe_le_coe.2\n\n"}
{"name":"ENNReal.coe_strictMono","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ StrictMono ENNReal.ofNNReal","decl":"theorem coe_strictMono : StrictMono ofNNReal := fun _ _ => coe_lt_coe.2\n\n"}
{"name":"ENNReal.coe_eq_zero","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : NNReal\n⊢ Iff (Eq (↑r) 0) (Eq r 0)","decl":"@[simp, norm_cast] theorem coe_eq_zero : (↑r : ℝ≥0∞) = 0 ↔ r = 0 := coe_inj\n\n"}
{"name":"ENNReal.zero_eq_coe","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : NNReal\n⊢ Iff (Eq 0 ↑r) (Eq 0 r)","decl":"@[simp, norm_cast] theorem zero_eq_coe : 0 = (↑r : ℝ≥0∞) ↔ 0 = r := coe_inj\n\n"}
{"name":"ENNReal.coe_eq_one","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : NNReal\n⊢ Iff (Eq (↑r) 1) (Eq r 1)","decl":"@[simp, norm_cast] theorem coe_eq_one : (↑r : ℝ≥0∞) = 1 ↔ r = 1 := coe_inj\n\n"}
{"name":"ENNReal.one_eq_coe","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : NNReal\n⊢ Iff (Eq 1 ↑r) (Eq 1 r)","decl":"@[simp, norm_cast] theorem one_eq_coe : 1 = (↑r : ℝ≥0∞) ↔ 1 = r := coe_inj\n\n"}
{"name":"ENNReal.coe_pos","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : NNReal\n⊢ Iff (LT.lt 0 ↑r) (LT.lt 0 r)","decl":"@[simp, norm_cast] theorem coe_pos : 0 < (r : ℝ≥0∞) ↔ 0 < r := coe_lt_coe\n\n"}
{"name":"ENNReal.coe_ne_zero","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : NNReal\n⊢ Iff (Ne (↑r) 0) (Ne r 0)","decl":"theorem coe_ne_zero : (r : ℝ≥0∞) ≠ 0 ↔ r ≠ 0 := coe_eq_zero.not\n\n"}
{"name":"ENNReal.coe_ne_one","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : NNReal\n⊢ Iff (Ne (↑r) 1) (Ne r 1)","decl":"lemma coe_ne_one : (r : ℝ≥0∞) ≠ 1 ↔ r ≠ 1 := coe_eq_one.not\n\n"}
{"name":"ENNReal.coe_add","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"x y : NNReal\n⊢ Eq (↑(HAdd.hAdd x y)) (HAdd.hAdd ↑x ↑y)","decl":"@[simp, norm_cast] lemma coe_add (x y : ℝ≥0) : (↑(x + y) : ℝ≥0∞) = x + y := rfl\n\n"}
{"name":"ENNReal.coe_mul","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"x y : NNReal\n⊢ Eq (↑(HMul.hMul x y)) (HMul.hMul ↑x ↑y)","decl":"@[simp, norm_cast] lemma coe_mul (x y : ℝ≥0) : (↑(x * y) : ℝ≥0∞) = x * y := rfl\n\n"}
{"name":"ENNReal.coe_nsmul","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"n : Nat\nx : NNReal\n⊢ Eq (↑(HSMul.hSMul n x)) (HSMul.hSMul n ↑x)","decl":"@[norm_cast] lemma coe_nsmul (n : ℕ) (x : ℝ≥0) : (↑(n • x) : ℝ≥0∞) = n • x := rfl\n\n"}
{"name":"ENNReal.coe_pow","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"x : NNReal\nn : Nat\n⊢ Eq (↑(HPow.hPow x n)) (HPow.hPow (↑x) n)","decl":"@[simp, norm_cast] lemma coe_pow (x : ℝ≥0) (n : ℕ) : (↑(x ^ n) : ℝ≥0∞) = x ^ n := rfl\n\n"}
{"name":"ENNReal.coe_ofNat","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (↑(OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp, norm_cast]\ntheorem coe_ofNat (n : ℕ) [n.AtLeastTwo] : ((ofNat(n) : ℝ≥0) : ℝ≥0∞) = ofNat(n) := rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: add lemmas about `OfNat.ofNat` and `<`/`≤`\n\n"}
{"name":"ENNReal.coe_two","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Eq (↑2) 2","decl":"theorem coe_two : ((2 : ℝ≥0) : ℝ≥0∞) = 2 := rfl\n\n"}
{"name":"ENNReal.toNNReal_eq_toNNReal_iff","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"x y : ENNReal\n⊢ Iff (Eq x.toNNReal y.toNNReal) (Or (Eq x y) (Or (And (Eq x 0) (Eq y Top.top)) (And (Eq x Top.top) (Eq y 0))))","decl":"theorem toNNReal_eq_toNNReal_iff (x y : ℝ≥0∞) :\n    x.toNNReal = y.toNNReal ↔ x = y ∨ x = 0 ∧ y = ⊤ ∨ x = ⊤ ∧ y = 0 :=\n  WithTop.untop'_eq_untop'_iff\n\n"}
{"name":"ENNReal.toReal_eq_toReal_iff","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"x y : ENNReal\n⊢ Iff (Eq x.toReal y.toReal) (Or (Eq x y) (Or (And (Eq x 0) (Eq y Top.top)) (And (Eq x Top.top) (Eq y 0))))","decl":"theorem toReal_eq_toReal_iff (x y : ℝ≥0∞) :\n    x.toReal = y.toReal ↔ x = y ∨ x = 0 ∧ y = ⊤ ∨ x = ⊤ ∧ y = 0 := by\n  simp only [ENNReal.toReal, NNReal.coe_inj, toNNReal_eq_toNNReal_iff]\n\n"}
{"name":"ENNReal.toNNReal_eq_toNNReal_iff'","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"x y : ENNReal\nhx : Ne x Top.top\nhy : Ne y Top.top\n⊢ Iff (Eq x.toNNReal y.toNNReal) (Eq x y)","decl":"theorem toNNReal_eq_toNNReal_iff' {x y : ℝ≥0∞} (hx : x ≠ ⊤) (hy : y ≠ ⊤) :\n    x.toNNReal = y.toNNReal ↔ x = y := by\n  simp only [ENNReal.toNNReal_eq_toNNReal_iff x y, hx, hy, and_false, false_and, or_false]\n\n"}
{"name":"ENNReal.toReal_eq_toReal_iff'","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"x y : ENNReal\nhx : Ne x Top.top\nhy : Ne y Top.top\n⊢ Iff (Eq x.toReal y.toReal) (Eq x y)","decl":"theorem toReal_eq_toReal_iff' {x y : ℝ≥0∞} (hx : x ≠ ⊤) (hy : y ≠ ⊤) :\n    x.toReal = y.toReal ↔ x = y := by\n  simp only [ENNReal.toReal, NNReal.coe_inj, toNNReal_eq_toNNReal_iff' hx hy]\n\n"}
{"name":"ENNReal.one_lt_two","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ LT.lt 1 2","decl":"theorem one_lt_two : (1 : ℝ≥0∞) < 2 := Nat.one_lt_ofNat\n\n"}
{"name":"fact_one_le_one_ennreal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Fact (LE.le 1 1)","decl":"/-- `(1 : ℝ≥0∞) ≤ 1`, recorded as a `Fact` for use with `Lp` spaces. -/\ninstance _root_.fact_one_le_one_ennreal : Fact ((1 : ℝ≥0∞) ≤ 1) :=\n  ⟨le_rfl⟩\n\n"}
{"name":"fact_one_le_two_ennreal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Fact (LE.le 1 2)","decl":"/-- `(1 : ℝ≥0∞) ≤ 2`, recorded as a `Fact` for use with `Lp` spaces. -/\ninstance _root_.fact_one_le_two_ennreal : Fact ((1 : ℝ≥0∞) ≤ 2) :=\n  ⟨one_le_two⟩\n\n"}
{"name":"fact_one_le_top_ennreal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Fact (LE.le 1 Top.top)","decl":"/-- `(1 : ℝ≥0∞) ≤ ∞`, recorded as a `Fact` for use with `Lp` spaces. -/\ninstance _root_.fact_one_le_top_ennreal : Fact ((1 : ℝ≥0∞) ≤ ∞) :=\n  ⟨le_top⟩\n\n"}
{"name":"ENNReal.cinfi_ne_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"α : Type u_1\ninst✝ : InfSet α\nf : ENNReal → α\n⊢ Eq (iInf fun x => f ↑x) (iInf fun x => f ↑x)","decl":"theorem cinfi_ne_top [InfSet α] (f : ℝ≥0∞ → α) : ⨅ x : { x // x ≠ ∞ }, f x = ⨅ x : ℝ≥0, f x :=\n  Eq.symm <| neTopEquivNNReal.symm.surjective.iInf_congr _ fun _ => rfl\n\n"}
{"name":"ENNReal.iInf_ne_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nf : ENNReal → α\n⊢ Eq (iInf fun x => iInf fun x_1 => f x) (iInf fun x => f ↑x)","decl":"theorem iInf_ne_top [CompleteLattice α] (f : ℝ≥0∞ → α) :\n    ⨅ (x) (_ : x ≠ ∞), f x = ⨅ x : ℝ≥0, f x := by rw [iInf_subtype', cinfi_ne_top]\n\n"}
{"name":"ENNReal.csupr_ne_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"α : Type u_1\ninst✝ : SupSet α\nf : ENNReal → α\n⊢ Eq (iSup fun x => f ↑x) (iSup fun x => f ↑x)","decl":"theorem csupr_ne_top [SupSet α] (f : ℝ≥0∞ → α) : ⨆ x : { x // x ≠ ∞ }, f x = ⨆ x : ℝ≥0, f x :=\n  @cinfi_ne_top αᵒᵈ _ _\n\n"}
{"name":"ENNReal.iSup_ne_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nf : ENNReal → α\n⊢ Eq (iSup fun x => iSup fun x_1 => f x) (iSup fun x => f ↑x)","decl":"theorem iSup_ne_top [CompleteLattice α] (f : ℝ≥0∞ → α) :\n    ⨆ (x) (_ : x ≠ ∞), f x = ⨆ x : ℝ≥0, f x :=\n  @iInf_ne_top αᵒᵈ _ _\n\n"}
{"name":"ENNReal.iInf_ennreal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\nf : ENNReal → α\n⊢ Eq (iInf fun n => f n) (Min.min (iInf fun n => f ↑n) (f Top.top))","decl":"theorem iInf_ennreal {α : Type*} [CompleteLattice α] {f : ℝ≥0∞ → α} :\n    ⨅ n, f n = (⨅ n : ℝ≥0, f n) ⊓ f ∞ :=\n  (iInf_option f).trans (inf_comm _ _)\n\n"}
{"name":"ENNReal.iSup_ennreal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"α : Type u_2\ninst✝ : CompleteLattice α\nf : ENNReal → α\n⊢ Eq (iSup fun n => f n) (Max.max (iSup fun n => f ↑n) (f Top.top))","decl":"theorem iSup_ennreal {α : Type*} [CompleteLattice α] {f : ℝ≥0∞ → α} :\n    ⨆ n, f n = (⨆ n : ℝ≥0, f n) ⊔ f ∞ :=\n  @iInf_ennreal αᵒᵈ _ _\n\n"}
{"name":"ENNReal.coe_ofNNRealHom","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Eq (⇑ENNReal.ofNNRealHom) Option.some","decl":"@[simp] theorem coe_ofNNRealHom : ⇑ofNNRealHom = some := rfl\n\n"}
{"name":"ENNReal.bot_eq_zero","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Eq Bot.bot 0","decl":"theorem bot_eq_zero : (⊥ : ℝ≥0∞) = 0 := rfl\n\n-- `coe_lt_top` moved up\n\n"}
{"name":"ENNReal.not_top_le_coe","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : NNReal\n⊢ Not (LE.le Top.top ↑r)","decl":"theorem not_top_le_coe : ¬∞ ≤ ↑r := WithTop.not_top_le_coe r\n\n"}
{"name":"ENNReal.one_le_coe_iff","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : NNReal\n⊢ Iff (LE.le 1 ↑r) (LE.le 1 r)","decl":"@[simp, norm_cast]\ntheorem one_le_coe_iff : (1 : ℝ≥0∞) ≤ ↑r ↔ 1 ≤ r := coe_le_coe\n\n"}
{"name":"ENNReal.coe_le_one_iff","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : NNReal\n⊢ Iff (LE.le (↑r) 1) (LE.le r 1)","decl":"@[simp, norm_cast]\ntheorem coe_le_one_iff : ↑r ≤ (1 : ℝ≥0∞) ↔ r ≤ 1 := coe_le_coe\n\n"}
{"name":"ENNReal.coe_lt_one_iff","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"p : NNReal\n⊢ Iff (LT.lt (↑p) 1) (LT.lt p 1)","decl":"@[simp, norm_cast]\ntheorem coe_lt_one_iff : (↑p : ℝ≥0∞) < 1 ↔ p < 1 := coe_lt_coe\n\n"}
{"name":"ENNReal.one_lt_coe_iff","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"p : NNReal\n⊢ Iff (LT.lt 1 ↑p) (LT.lt 1 p)","decl":"@[simp, norm_cast]\ntheorem one_lt_coe_iff : 1 < (↑p : ℝ≥0∞) ↔ 1 < p := coe_lt_coe\n\n"}
{"name":"ENNReal.coe_natCast","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"n : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast]\ntheorem coe_natCast (n : ℕ) : ((n : ℝ≥0) : ℝ≥0∞) = n := rfl\n\n"}
{"name":"ENNReal.ofReal_natCast","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"n : Nat\n⊢ Eq (ENNReal.ofReal ↑n) ↑n","decl":"@[simp, norm_cast] lemma ofReal_natCast (n : ℕ) : ENNReal.ofReal n = n := by simp [ENNReal.ofReal]\n\n"}
{"name":"ENNReal.ofReal_ofNat","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (ENNReal.ofReal (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp] theorem ofReal_ofNat (n : ℕ) [n.AtLeastTwo] : ENNReal.ofReal ofNat(n) = ofNat(n) :=\n  ofReal_natCast n\n\n"}
{"name":"ENNReal.natCast_ne_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"n : Nat\n⊢ Ne (↑n) Top.top","decl":"@[simp, aesop (rule_sets := [finiteness]) safe apply]\ntheorem natCast_ne_top (n : ℕ) : (n : ℝ≥0∞) ≠ ∞ := WithTop.natCast_ne_top n\n\n"}
{"name":"ENNReal.natCast_lt_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"n : Nat\n⊢ LT.lt (↑n) Top.top","decl":"@[simp] theorem natCast_lt_top (n : ℕ) : (n : ℝ≥0∞) < ∞ := WithTop.natCast_lt_top n\n\n"}
{"name":"ENNReal.ofNat_ne_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Ne (OfNat.ofNat n) Top.top","decl":"@[simp, aesop (rule_sets := [finiteness]) safe apply]\nlemma ofNat_ne_top {n : ℕ} [Nat.AtLeastTwo n] : ofNat(n) ≠ ∞ := natCast_ne_top n\n\n"}
{"name":"ENNReal.ofNat_lt_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ LT.lt (OfNat.ofNat n) Top.top","decl":"@[simp]\nlemma ofNat_lt_top {n : ℕ} [Nat.AtLeastTwo n] : ofNat(n) < ∞ := natCast_lt_top n\n\n"}
{"name":"ENNReal.top_ne_natCast","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"n : Nat\n⊢ Ne Top.top ↑n","decl":"@[simp] theorem top_ne_natCast (n : ℕ) : ∞ ≠ n := WithTop.top_ne_natCast n\n\n"}
{"name":"ENNReal.top_ne_ofNat","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Ne Top.top (OfNat.ofNat n)","decl":"@[simp] theorem top_ne_ofNat {n : ℕ} [n.AtLeastTwo] : ∞ ≠ ofNat(n) :=\n  ofNat_ne_top.symm\n\n"}
{"name":"ENNReal.two_ne_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Ne 2 Top.top","decl":"@[deprecated ofNat_ne_top (since := \"2025-01-21\")] lemma two_ne_top : (2 : ℝ≥0∞) ≠ ∞ := coe_ne_top\n"}
{"name":"ENNReal.two_lt_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ LT.lt 2 Top.top","decl":"@[deprecated ofNat_lt_top (since := \"2025-01-21\")] lemma two_lt_top : (2 : ℝ≥0∞) < ∞ := coe_lt_top\n\n"}
{"name":"ENNReal.one_lt_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ LT.lt 1 Top.top","decl":"@[simp] theorem one_lt_top : 1 < ∞ := coe_lt_top\n\n"}
{"name":"ENNReal.toNNReal_nat","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"n : Nat\n⊢ Eq (↑n).toNNReal ↑n","decl":"@[simp, norm_cast]\ntheorem toNNReal_nat (n : ℕ) : (n : ℝ≥0∞).toNNReal = n := by\n  rw [← ENNReal.coe_natCast n, ENNReal.toNNReal_coe]\n\n"}
{"name":"ENNReal.toReal_nat","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"n : Nat\n⊢ Eq (↑n).toReal ↑n","decl":"@[simp, norm_cast]\ntheorem toReal_nat (n : ℕ) : (n : ℝ≥0∞).toReal = n := by\n  rw [← ENNReal.ofReal_natCast n, ENNReal.toReal_ofReal (Nat.cast_nonneg _)]\n\n"}
{"name":"ENNReal.toReal_ofNat","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (OfNat.ofNat n).toReal (OfNat.ofNat n)","decl":"@[simp] theorem toReal_ofNat (n : ℕ) [n.AtLeastTwo] : ENNReal.toReal ofNat(n) = ofNat(n) :=\n  toReal_nat n\n\n"}
{"name":"ENNReal.le_coe_iff","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : ENNReal\nr : NNReal\n⊢ Iff (LE.le a ↑r) (Exists fun p => And (Eq a ↑p) (LE.le p r))","decl":"theorem le_coe_iff : a ≤ ↑r ↔ ∃ p : ℝ≥0, a = p ∧ p ≤ r := WithTop.le_coe_iff\n\n"}
{"name":"ENNReal.coe_le_iff","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : ENNReal\nr : NNReal\n⊢ Iff (LE.le (↑r) a) (∀ (p : NNReal), Eq a ↑p → LE.le r p)","decl":"theorem coe_le_iff : ↑r ≤ a ↔ ∀ p : ℝ≥0, a = p → r ≤ p := WithTop.coe_le_iff\n\n"}
{"name":"ENNReal.lt_iff_exists_coe","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a b : ENNReal\n⊢ Iff (LT.lt a b) (Exists fun p => And (Eq a ↑p) (LT.lt (↑p) b))","decl":"theorem lt_iff_exists_coe : a < b ↔ ∃ p : ℝ≥0, a = p ∧ ↑p < b :=\n  WithTop.lt_iff_exists_coe\n\n"}
{"name":"ENNReal.toReal_le_coe_of_le_coe","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : ENNReal\nb : NNReal\nh : LE.le a ↑b\n⊢ LE.le a.toReal ↑b","decl":"theorem toReal_le_coe_of_le_coe {a : ℝ≥0∞} {b : ℝ≥0} (h : a ≤ b) : a.toReal ≤ b := by\n  lift a to ℝ≥0 using ne_top_of_le_ne_top coe_ne_top h\n  simpa using h\n\n"}
{"name":"ENNReal.max_eq_zero_iff","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a b : ENNReal\n⊢ Iff (Eq (Max.max a b) 0) (And (Eq a 0) (Eq b 0))","decl":"@[simp] theorem max_eq_zero_iff : max a b = 0 ↔ a = 0 ∧ b = 0 := max_eq_bot\n\n"}
{"name":"ENNReal.max_zero_left","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : ENNReal\n⊢ Eq (Max.max 0 a) a","decl":"theorem max_zero_left : max 0 a = a :=\n  max_eq_right (zero_le a)\n\n"}
{"name":"ENNReal.max_zero_right","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : ENNReal\n⊢ Eq (Max.max a 0) a","decl":"theorem max_zero_right : max a 0 = a :=\n  max_eq_left (zero_le a)\n\n-- Porting note: moved `le_of_forall_pos_le_add` down\n\n"}
{"name":"ENNReal.lt_iff_exists_rat_btwn","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a b : ENNReal\n⊢ Iff (LT.lt a b) (Exists fun q => And (LE.le 0 q) (And (LT.lt a ↑(↑q).toNNReal) (LT.lt (↑(↑q).toNNReal) b)))","decl":"theorem lt_iff_exists_rat_btwn :\n    a < b ↔ ∃ q : ℚ, 0 ≤ q ∧ a < Real.toNNReal q ∧ (Real.toNNReal q : ℝ≥0∞) < b :=\n  ⟨fun h => by\n    rcases lt_iff_exists_coe.1 h with ⟨p, rfl, _⟩\n    rcases exists_between h with ⟨c, pc, cb⟩\n    rcases lt_iff_exists_coe.1 cb with ⟨r, rfl, _⟩\n    rcases (NNReal.lt_iff_exists_rat_btwn _ _).1 (coe_lt_coe.1 pc) with ⟨q, hq0, pq, qr⟩\n    exact ⟨q, hq0, coe_lt_coe.2 pq, lt_trans (coe_lt_coe.2 qr) cb⟩,\n      fun ⟨_, _, qa, qb⟩ => lt_trans qa qb⟩\n\n"}
{"name":"ENNReal.lt_iff_exists_real_btwn","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a b : ENNReal\n⊢ Iff (LT.lt a b) (Exists fun r => And (LE.le 0 r) (And (LT.lt a (ENNReal.ofReal r)) (LT.lt (ENNReal.ofReal r) b)))","decl":"theorem lt_iff_exists_real_btwn :\n    a < b ↔ ∃ r : ℝ, 0 ≤ r ∧ a < ENNReal.ofReal r ∧ (ENNReal.ofReal r : ℝ≥0∞) < b :=\n  ⟨fun h =>\n    let ⟨q, q0, aq, qb⟩ := ENNReal.lt_iff_exists_rat_btwn.1 h\n    ⟨q, Rat.cast_nonneg.2 q0, aq, qb⟩,\n    fun ⟨_, _, qa, qb⟩ => lt_trans qa qb⟩\n\n"}
{"name":"ENNReal.lt_iff_exists_nnreal_btwn","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a b : ENNReal\n⊢ Iff (LT.lt a b) (Exists fun r => And (LT.lt a ↑r) (LT.lt (↑r) b))","decl":"theorem lt_iff_exists_nnreal_btwn : a < b ↔ ∃ r : ℝ≥0, a < r ∧ (r : ℝ≥0∞) < b :=\n  WithTop.lt_iff_exists_coe_btwn\n\n"}
{"name":"ENNReal.lt_iff_exists_add_pos_lt","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a b : ENNReal\n⊢ Iff (LT.lt a b) (Exists fun r => And (LT.lt 0 r) (LT.lt (HAdd.hAdd a ↑r) b))","decl":"theorem lt_iff_exists_add_pos_lt : a < b ↔ ∃ r : ℝ≥0, 0 < r ∧ a + r < b := by\n  refine ⟨fun hab => ?_, fun ⟨r, _, hr⟩ => lt_of_le_of_lt le_self_add hr⟩\n  rcases lt_iff_exists_nnreal_btwn.1 hab with ⟨c, ac, cb⟩\n  lift a to ℝ≥0 using ac.ne_top\n  rw [coe_lt_coe] at ac\n  refine ⟨c - a, tsub_pos_iff_lt.2 ac, ?_⟩\n  rwa [← coe_add, add_tsub_cancel_of_le ac.le]\n\n"}
{"name":"ENNReal.le_of_forall_pos_le_add","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a b : ENNReal\nh : ∀ (ε : NNReal), LT.lt 0 ε → LT.lt b Top.top → LE.le a (HAdd.hAdd b ↑ε)\n⊢ LE.le a b","decl":"theorem le_of_forall_pos_le_add (h : ∀ ε : ℝ≥0, 0 < ε → b < ∞ → a ≤ b + ε) : a ≤ b := by\n  contrapose! h\n  rcases lt_iff_exists_add_pos_lt.1 h with ⟨r, hr0, hr⟩\n  exact ⟨r, hr0, h.trans_le le_top, hr⟩\n\n"}
{"name":"ENNReal.natCast_lt_coe","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : NNReal\nn : Nat\n⊢ Iff (LT.lt ↑n ↑r) (LT.lt (↑n) r)","decl":"theorem natCast_lt_coe {n : ℕ} : n < (r : ℝ≥0∞) ↔ n < r := ENNReal.coe_natCast n ▸ coe_lt_coe\n\n"}
{"name":"ENNReal.coe_lt_natCast","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : NNReal\nn : Nat\n⊢ Iff (LT.lt ↑r ↑n) (LT.lt r ↑n)","decl":"theorem coe_lt_natCast {n : ℕ} : (r : ℝ≥0∞) < n ↔ r < n := ENNReal.coe_natCast n ▸ coe_lt_coe\n\n"}
{"name":"ENNReal.exists_nat_gt","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : ENNReal\nh : Ne r Top.top\n⊢ Exists fun n => LT.lt r ↑n","decl":"protected theorem exists_nat_gt {r : ℝ≥0∞} (h : r ≠ ∞) : ∃ n : ℕ, r < n := by\n  lift r to ℝ≥0 using h\n  rcases exists_nat_gt r with ⟨n, hn⟩\n  exact ⟨n, coe_lt_natCast.2 hn⟩\n\n"}
{"name":"ENNReal.iUnion_Iio_coe_nat","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Eq (Set.iUnion fun n => Set.Iio ↑n) (HasCompl.compl (Singleton.singleton Top.top))","decl":"@[simp]\ntheorem iUnion_Iio_coe_nat : ⋃ n : ℕ, Iio (n : ℝ≥0∞) = {∞}ᶜ := by\n  ext x\n  rw [mem_iUnion]\n  exact ⟨fun ⟨n, hn⟩ => ne_top_of_lt hn, ENNReal.exists_nat_gt⟩\n\n"}
{"name":"ENNReal.iUnion_Iic_coe_nat","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Eq (Set.iUnion fun n => Set.Iic ↑n) (HasCompl.compl (Singleton.singleton Top.top))","decl":"@[simp]\ntheorem iUnion_Iic_coe_nat : ⋃ n : ℕ, Iic (n : ℝ≥0∞) = {∞}ᶜ :=\n  Subset.antisymm (iUnion_subset fun n _x hx => ne_top_of_le_ne_top (natCast_ne_top n) hx) <|\n    iUnion_Iio_coe_nat ▸ iUnion_mono fun _ => Iio_subset_Iic_self\n\n"}
{"name":"ENNReal.iUnion_Ioc_coe_nat","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : ENNReal\n⊢ Eq (Set.iUnion fun n => Set.Ioc a ↑n) (SDiff.sdiff (Set.Ioi a) (Singleton.singleton Top.top))","decl":"@[simp]\ntheorem iUnion_Ioc_coe_nat : ⋃ n : ℕ, Ioc a n = Ioi a \\ {∞} := by\n  simp only [← Ioi_inter_Iic, ← inter_iUnion, iUnion_Iic_coe_nat, diff_eq]\n\n"}
{"name":"ENNReal.iUnion_Ioo_coe_nat","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : ENNReal\n⊢ Eq (Set.iUnion fun n => Set.Ioo a ↑n) (SDiff.sdiff (Set.Ioi a) (Singleton.singleton Top.top))","decl":"@[simp]\ntheorem iUnion_Ioo_coe_nat : ⋃ n : ℕ, Ioo a n = Ioi a \\ {∞} := by\n  simp only [← Ioi_inter_Iio, ← inter_iUnion, iUnion_Iio_coe_nat, diff_eq]\n\n"}
{"name":"ENNReal.iUnion_Icc_coe_nat","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : ENNReal\n⊢ Eq (Set.iUnion fun n => Set.Icc a ↑n) (SDiff.sdiff (Set.Ici a) (Singleton.singleton Top.top))","decl":"@[simp]\ntheorem iUnion_Icc_coe_nat : ⋃ n : ℕ, Icc a n = Ici a \\ {∞} := by\n  simp only [← Ici_inter_Iic, ← inter_iUnion, iUnion_Iic_coe_nat, diff_eq]\n\n"}
{"name":"ENNReal.iUnion_Ico_coe_nat","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a : ENNReal\n⊢ Eq (Set.iUnion fun n => Set.Ico a ↑n) (SDiff.sdiff (Set.Ici a) (Singleton.singleton Top.top))","decl":"@[simp]\ntheorem iUnion_Ico_coe_nat : ⋃ n : ℕ, Ico a n = Ici a \\ {∞} := by\n  simp only [← Ici_inter_Iio, ← inter_iUnion, iUnion_Iio_coe_nat, diff_eq]\n\n"}
{"name":"ENNReal.iInter_Ici_coe_nat","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Eq (Set.iInter fun n => Set.Ici ↑n) (Singleton.singleton Top.top)","decl":"@[simp]\ntheorem iInter_Ici_coe_nat : ⋂ n : ℕ, Ici (n : ℝ≥0∞) = {∞} := by\n  simp only [← compl_Iio, ← compl_iUnion, iUnion_Iio_coe_nat, compl_compl]\n\n"}
{"name":"ENNReal.iInter_Ioi_coe_nat","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"⊢ Eq (Set.iInter fun n => Set.Ioi ↑n) (Singleton.singleton Top.top)","decl":"@[simp]\ntheorem iInter_Ioi_coe_nat : ⋂ n : ℕ, Ioi (n : ℝ≥0∞) = {∞} := by\n  simp only [← compl_Iic, ← compl_iUnion, iUnion_Iic_coe_nat, compl_compl]\n\n"}
{"name":"ENNReal.coe_min","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r p : NNReal\n⊢ Eq (↑(Min.min r p)) (Min.min ↑r ↑p)","decl":"@[simp, norm_cast]\ntheorem coe_min (r p : ℝ≥0) : ((min r p : ℝ≥0) : ℝ≥0∞) = min (r : ℝ≥0∞) p := rfl\n\n"}
{"name":"ENNReal.coe_max","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r p : NNReal\n⊢ Eq (↑(Max.max r p)) (Max.max ↑r ↑p)","decl":"@[simp, norm_cast]\ntheorem coe_max (r p : ℝ≥0) : ((max r p : ℝ≥0) : ℝ≥0∞) = max (r : ℝ≥0∞) p := rfl\n\n"}
{"name":"ENNReal.le_of_top_imp_top_of_toNNReal_le","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"a b : ENNReal\nh : Eq a Top.top → Eq b Top.top\nh_nnreal : Ne a Top.top → Ne b Top.top → LE.le a.toNNReal b.toNNReal\n⊢ LE.le a b","decl":"theorem le_of_top_imp_top_of_toNNReal_le {a b : ℝ≥0∞} (h : a = ⊤ → b = ⊤)\n    (h_nnreal : a ≠ ⊤ → b ≠ ⊤ → a.toNNReal ≤ b.toNNReal) : a ≤ b := by\n  by_contra! hlt\n  lift b to ℝ≥0 using hlt.ne_top\n  lift a to ℝ≥0 using mt h coe_ne_top\n  refine hlt.not_le ?_\n  simpa using h_nnreal\n\n"}
{"name":"ENNReal.abs_toReal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"x : ENNReal\n⊢ Eq (abs x.toReal) x.toReal","decl":"@[simp]\ntheorem abs_toReal {x : ℝ≥0∞} : |x.toReal| = x.toReal := by cases x <;> simp\n\n"}
{"name":"ENNReal.coe_sSup","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"s : Set NNReal\na✝ : BddAbove s\n⊢ Eq (↑(SupSet.sSup s)) (iSup fun a => iSup fun h => ↑a)","decl":"theorem coe_sSup {s : Set ℝ≥0} : BddAbove s → (↑(sSup s) : ℝ≥0∞) = ⨆ a ∈ s, ↑a :=\n  WithTop.coe_sSup\n\n"}
{"name":"ENNReal.coe_sInf","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"s : Set NNReal\nhs : s.Nonempty\n⊢ Eq (↑(InfSet.sInf s)) (iInf fun a => iInf fun h => ↑a)","decl":"theorem coe_sInf {s : Set ℝ≥0} (hs : s.Nonempty) : (↑(sInf s) : ℝ≥0∞) = ⨅ a ∈ s, ↑a :=\n  WithTop.coe_sInf hs (OrderBot.bddBelow s)\n\n"}
{"name":"ENNReal.coe_iSup","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"ι : Sort u_3\nf : ι → NNReal\nhf : BddAbove (Set.range f)\n⊢ Eq (↑(iSup f)) (iSup fun a => ↑(f a))","decl":"theorem coe_iSup {ι : Sort*} {f : ι → ℝ≥0} (hf : BddAbove (range f)) :\n    (↑(iSup f) : ℝ≥0∞) = ⨆ a, ↑(f a) :=\n  WithTop.coe_iSup _ hf\n\n"}
{"name":"ENNReal.coe_iInf","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"ι : Sort u_3\ninst✝ : Nonempty ι\nf : ι → NNReal\n⊢ Eq (↑(iInf f)) (iInf fun a => ↑(f a))","decl":"@[norm_cast]\ntheorem coe_iInf {ι : Sort*} [Nonempty ι] (f : ι → ℝ≥0) : (↑(iInf f) : ℝ≥0∞) = ⨅ a, ↑(f a) :=\n  WithTop.coe_iInf (OrderBot.bddBelow _)\n\n"}
{"name":"ENNReal.coe_mem_upperBounds","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"r : NNReal\ns : Set NNReal\n⊢ Iff (Membership.mem (upperBounds (Set.image ENNReal.ofNNReal s)) ↑r) (Membership.mem (upperBounds s) r)","decl":"theorem coe_mem_upperBounds {s : Set ℝ≥0} :\n    ↑r ∈ upperBounds (ofNNReal '' s) ↔ r ∈ upperBounds s := by\n  simp +contextual [upperBounds, forall_mem_image, -mem_image, *]\n\n"}
{"name":"ENNReal.iSup_coe_eq_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"ι : Sort u_2\nf : ι → NNReal\n⊢ Iff (Eq (iSup fun i => ↑(f i)) Top.top) (Not (BddAbove (Set.range f)))","decl":"lemma iSup_coe_eq_top : ⨆ i, (f i : ℝ≥0∞) = ⊤ ↔ ¬ BddAbove (range f) := WithTop.iSup_coe_eq_top\n"}
{"name":"ENNReal.iSup_coe_lt_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"ι : Sort u_2\nf : ι → NNReal\n⊢ Iff (LT.lt (iSup fun i => ↑(f i)) Top.top) (BddAbove (Set.range f))","decl":"lemma iSup_coe_lt_top : ⨆ i, (f i : ℝ≥0∞) < ⊤ ↔ BddAbove (range f) := WithTop.iSup_coe_lt_top\n"}
{"name":"ENNReal.iInf_coe_eq_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"ι : Sort u_2\nf : ι → NNReal\n⊢ Iff (Eq (iInf fun i => ↑(f i)) Top.top) (IsEmpty ι)","decl":"lemma iInf_coe_eq_top : ⨅ i, (f i : ℝ≥0∞) = ⊤ ↔ IsEmpty ι := WithTop.iInf_coe_eq_top\n"}
{"name":"ENNReal.iInf_coe_lt_top","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"ι : Sort u_2\nf : ι → NNReal\n⊢ Iff (LT.lt (iInf fun i => ↑(f i)) Top.top) (Nonempty ι)","decl":"lemma iInf_coe_lt_top : ⨅ i, (f i : ℝ≥0∞) < ⊤ ↔ Nonempty ι := WithTop.iInf_coe_lt_top\n\n"}
{"name":"Set.OrdConnected.preimage_coe_nnreal_ennreal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"u : Set ENNReal\nh : u.OrdConnected\n⊢ (Set.preimage ENNReal.ofNNReal u).OrdConnected","decl":"theorem preimage_coe_nnreal_ennreal (h : u.OrdConnected) : ((↑) ⁻¹' u : Set ℝ≥0).OrdConnected :=\n  h.preimage_mono ENNReal.coe_mono\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: generalize to `WithTop`\n"}
{"name":"Set.OrdConnected.image_coe_nnreal_ennreal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"t : Set NNReal\nh : t.OrdConnected\n⊢ (Set.image ENNReal.ofNNReal t).OrdConnected","decl":"theorem image_coe_nnreal_ennreal (h : t.OrdConnected) : ((↑) '' t : Set ℝ≥0∞).OrdConnected := by\n  refine ⟨forall_mem_image.2 fun x hx => forall_mem_image.2 fun y hy z hz => ?_⟩\n  rcases ENNReal.le_coe_iff.1 hz.2 with ⟨z, rfl, -⟩\n  exact mem_image_of_mem _ (h.out hx hy ⟨ENNReal.coe_le_coe.1 hz.1, ENNReal.coe_le_coe.1 hz.2⟩)\n\n"}
{"name":"Set.OrdConnected.preimage_ennreal_ofReal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"u : Set ENNReal\nh : u.OrdConnected\n⊢ (Set.preimage ENNReal.ofReal u).OrdConnected","decl":"theorem preimage_ennreal_ofReal (h : u.OrdConnected) : (ENNReal.ofReal ⁻¹' u).OrdConnected :=\n  h.preimage_coe_nnreal_ennreal.preimage_real_toNNReal\n\n"}
{"name":"Set.OrdConnected.image_ennreal_ofReal","module":"Mathlib.Data.ENNReal.Basic","initialProofState":"s : Set Real\nh : s.OrdConnected\n⊢ (Set.image ENNReal.ofReal s).OrdConnected","decl":"theorem image_ennreal_ofReal (h : s.OrdConnected) : (ENNReal.ofReal '' s).OrdConnected := by\n  simpa only [image_image] using h.image_real_toNNReal.image_coe_nnreal_ennreal\n\n"}
