{"name":"List.Vector.toList_injective","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\n⊢ Function.Injective List.Vector.toList","decl":"theorem toList_injective : Function.Injective (@toList α n) :=\n  Subtype.val_injective\n\n"}
{"name":"List.Vector.ext","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv w : List.Vector α n\nx✝ : ∀ (m : Fin n), Eq (v.get m) (w.get m)\n⊢ Eq v w","decl":"/-- Two `v w : Vector α n` are equal iff they are equal at every single index. -/\n@[ext]\ntheorem ext : ∀ {v w : Vector α n} (_ : ∀ m : Fin n, Vector.get v m = Vector.get w m), v = w\n  | ⟨v, hv⟩, ⟨w, hw⟩, h =>\n    Subtype.eq (List.ext_get (by rw [hv, hw]) fun m hm _ => h ⟨m, hv ▸ hm⟩)\n\n"}
{"name":"List.Vector.ext_iff","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv w : List.Vector α n\n⊢ Iff (Eq v w) (∀ (m : Fin n), Eq (v.get m) (w.get m))","decl":"/-- Two `v w : Vector α n` are equal iff they are equal at every single index. -/\n@[ext]\ntheorem ext : ∀ {v w : Vector α n} (_ : ∀ m : Fin n, Vector.get v m = Vector.get w m), v = w\n  | ⟨v, hv⟩, ⟨w, hw⟩, h =>\n    Subtype.eq (List.ext_get (by rw [hv, hw]) fun m hm _ => h ⟨m, hv ▸ hm⟩)\n\n"}
{"name":"List.Vector.zero_subsingleton","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\n⊢ Subsingleton (List.Vector α 0)","decl":"/-- The empty `Vector` is a `Subsingleton`. -/\ninstance zero_subsingleton : Subsingleton (Vector α 0) :=\n  ⟨fun _ _ => Vector.ext fun m => Fin.elim0 m⟩\n\n"}
{"name":"List.Vector.cons_val","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\na : α\nv : List.Vector α n\n⊢ Eq (↑(List.Vector.cons a v)) (List.cons a ↑v)","decl":"@[simp]\ntheorem cons_val (a : α) : ∀ v : Vector α n, (a ::ᵥ v).val = a :: v.val\n  | ⟨_, _⟩ => rfl\n\n"}
{"name":"List.Vector.eq_cons_iff","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\na : α\nv : List.Vector α n.succ\nv' : List.Vector α n\n⊢ Iff (Eq v (List.Vector.cons a v')) (And (Eq v.head a) (Eq v.tail v'))","decl":"theorem eq_cons_iff (a : α) (v : Vector α n.succ) (v' : Vector α n) :\n    v = a ::ᵥ v' ↔ v.head = a ∧ v.tail = v' :=\n  ⟨fun h => h.symm ▸ ⟨head_cons a v', tail_cons a v'⟩, fun h =>\n    _root_.trans (cons_head_tail v).symm (by rw [h.1, h.2])⟩\n\n"}
{"name":"List.Vector.ne_cons_iff","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\na : α\nv : List.Vector α n.succ\nv' : List.Vector α n\n⊢ Iff (Ne v (List.Vector.cons a v')) (Or (Ne v.head a) (Ne v.tail v'))","decl":"theorem ne_cons_iff (a : α) (v : Vector α n.succ) (v' : Vector α n) :\n    v ≠ a ::ᵥ v' ↔ v.head ≠ a ∨ v.tail ≠ v' := by rw [Ne, eq_cons_iff a v v', not_and_or]\n\n"}
{"name":"List.Vector.exists_eq_cons","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n.succ\n⊢ Exists fun a => Exists fun as => Eq v (List.Vector.cons a as)","decl":"theorem exists_eq_cons (v : Vector α n.succ) : ∃ (a : α) (as : Vector α n), v = a ::ᵥ as :=\n  ⟨v.head, v.tail, (eq_cons_iff v.head v v.tail).2 ⟨rfl, rfl⟩⟩\n\n"}
{"name":"List.Vector.toList_ofFn","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nf : Fin n → α\n⊢ Eq (List.Vector.ofFn f).toList (List.ofFn f)","decl":"@[simp]\ntheorem toList_ofFn : ∀ {n} (f : Fin n → α), toList (ofFn f) = List.ofFn f\n  | 0, f => by rw [ofFn, List.ofFn_zero, toList, nil]\n  | n + 1, f => by rw [ofFn, List.ofFn_succ, toList_cons, toList_ofFn]\n\n"}
{"name":"List.Vector.mk_toList","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n\nh : Eq v.toList.length n\n⊢ Eq ⟨v.toList, h⟩ v","decl":"@[simp]\ntheorem mk_toList : ∀ (v : Vector α n) (h), (⟨toList v, h⟩ : Vector α n) = v\n  | ⟨_, _⟩, _ => rfl\n\n\n"}
{"name":"List.Vector.length_val","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n\n⊢ Eq (↑v).length n","decl":"@[simp] theorem length_val (v : Vector α n) : v.val.length = n := v.2\n\n"}
{"name":"List.Vector.pmap_cons","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nat\np : α → Prop\nf : (a : α) → p a → β\na : α\nv : List.Vector α n\nhp : ∀ (x : α), Membership.mem (List.Vector.cons a v).toList x → p x\n⊢ Eq (List.Vector.pmap f (List.Vector.cons a v) hp) (List.Vector.cons (f a ⋯) (List.Vector.pmap f v ⋯))","decl":"@[simp]\ntheorem pmap_cons {p : α → Prop} (f : (a : α) → p a → β) (a : α) (v : Vector α n)\n    (hp : ∀ x ∈ (cons a v).toList, p x) :\n    (cons a v).pmap f hp = cons (f a (by\n      simp only [Nat.succ_eq_add_one, toList_cons, List.mem_cons, forall_eq_or_imp] at hp\n      exact hp.1))\n      (v.pmap f (by\n        simp only [Nat.succ_eq_add_one, toList_cons, List.mem_cons, forall_eq_or_imp] at hp\n        exact hp.2)) := rfl\n\n"}
{"name":"List.Vector.pmap_cons'","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nat\np : α → Prop\nf : (a : α) → p a → β\na : α\nv : List.Vector α n\nha : p a\nhp : ∀ (x : α), Membership.mem v.toList x → p x\n⊢ Eq (List.Vector.cons (f a ha) (List.Vector.pmap f v hp)) (List.Vector.pmap f (List.Vector.cons a v) ⋯)","decl":"/-- Opposite direction of `Vector.pmap_cons` -/\ntheorem pmap_cons' {p : α → Prop} (f : (a : α) → p a → β) (a : α) (v : Vector α n)\n    (ha : p a) (hp : ∀ x ∈ v.toList, p x) :\n    cons (f a ha) (v.pmap f hp) = (cons a v).pmap f (by simpa [ha]) := rfl\n\n"}
{"name":"List.Vector.toList_map","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nβ : Type u_6\nv : List.Vector α n\nf : α → β\n⊢ Eq (List.Vector.map f v).toList (List.map f v.toList)","decl":"@[simp]\ntheorem toList_map {β : Type*} (v : Vector α n) (f : α → β) :\n    (v.map f).toList = v.toList.map f := by cases v; rfl\n\n"}
{"name":"List.Vector.head_map","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nβ : Type u_6\nv : List.Vector α (HAdd.hAdd n 1)\nf : α → β\n⊢ Eq (List.Vector.map f v).head (f v.head)","decl":"@[simp]\ntheorem head_map {β : Type*} (v : Vector α (n + 1)) (f : α → β) : (v.map f).head = f v.head := by\n  obtain ⟨a, v', h⟩ := Vector.exists_eq_cons v\n  rw [h, map_cons, head_cons, head_cons]\n\n"}
{"name":"List.Vector.tail_map","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nβ : Type u_6\nv : List.Vector α (HAdd.hAdd n 1)\nf : α → β\n⊢ Eq (List.Vector.map f v).tail (List.Vector.map f v.tail)","decl":"@[simp]\ntheorem tail_map {β : Type*} (v : Vector α (n + 1)) (f : α → β) :\n    (v.map f).tail = v.tail.map f := by\n  obtain ⟨a, v', h⟩ := Vector.exists_eq_cons v\n  rw [h, map_cons, tail_cons, tail_cons]\n\n"}
{"name":"List.Vector.getElem_map","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nβ : Type u_6\nv : List.Vector α n\nf : α → β\ni : Nat\nhi : LT.lt i n\n⊢ Eq (GetElem.getElem (List.Vector.map f v) i ⋯) (f (GetElem.getElem v i ⋯))","decl":"@[simp]\ntheorem getElem_map {β : Type*} (v : Vector α n) (f : α → β) {i : ℕ} (hi : i < n) :\n    (v.map f)[i] = f v[i] := by\n  simp only [getElem_def, toList_map, List.getElem_map]\n\n"}
{"name":"List.Vector.toList_pmap","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nat\np : α → Prop\nf : (a : α) → p a → β\nv : List.Vector α n\nhp : ∀ (x : α), Membership.mem v.toList x → p x\n⊢ Eq (List.Vector.pmap f v hp).toList (List.pmap f v.toList hp)","decl":"@[simp]\ntheorem toList_pmap {p : α → Prop} (f : (a : α) → p a → β) (v : Vector α n)\n    (hp : ∀ x ∈ v.toList, p x) :\n    (v.pmap f hp).toList = v.toList.pmap f hp := by cases v; rfl\n\n"}
{"name":"List.Vector.head_pmap","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nat\np : α → Prop\nf : (a : α) → p a → β\nv : List.Vector α (HAdd.hAdd n 1)\nhp : ∀ (x : α), Membership.mem v.toList x → p x\n⊢ Eq (List.Vector.pmap f v hp).head (f v.head ⋯)","decl":"@[simp]\ntheorem head_pmap {p : α → Prop} (f : (a : α) → p a → β) (v : Vector α (n + 1))\n    (hp : ∀ x ∈ v.toList, p x) :\n    (v.pmap f hp).head = f v.head (hp _ <| by\n      rw [← cons_head_tail v, toList_cons, head_cons, List.mem_cons]; exact .inl rfl) := by\n  obtain ⟨a, v', h⟩ := Vector.exists_eq_cons v\n  simp_rw [h, pmap_cons, head_cons]\n\n"}
{"name":"List.Vector.tail_pmap","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nat\np : α → Prop\nf : (a : α) → p a → β\nv : List.Vector α (HAdd.hAdd n 1)\nhp : ∀ (x : α), Membership.mem v.toList x → p x\n⊢ Eq (List.Vector.pmap f v hp).tail (List.Vector.pmap f v.tail ⋯)","decl":"@[simp]\ntheorem tail_pmap {p : α → Prop} (f : (a : α) → p a → β) (v : Vector α (n + 1))\n    (hp : ∀ x ∈ v.toList, p x) :\n    (v.pmap f hp).tail = v.tail.pmap f (fun x hx ↦ hp _ <| by\n      rw [← cons_head_tail v, toList_cons, List.mem_cons]; exact .inr hx) := by\n  obtain ⟨a, v', h⟩ := Vector.exists_eq_cons v\n  simp_rw [h, pmap_cons, tail_cons]\n\n"}
{"name":"List.Vector.getElem_pmap","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nn : Nat\np : α → Prop\nf : (a : α) → p a → β\nv : List.Vector α n\nhp : ∀ (x : α), Membership.mem v.toList x → p x\ni : Nat\nhi : LT.lt i n\n⊢ Eq (GetElem.getElem (List.Vector.pmap f v hp) i ⋯) (f (GetElem.getElem v i ⋯) ⋯)","decl":"@[simp]\ntheorem getElem_pmap {p : α → Prop} (f : (a : α) → p a → β) (v : Vector α n)\n    (hp : ∀ x ∈ v.toList, p x) {i : ℕ} (hi : i < n) :\n    (v.pmap f hp)[i] = f v[i] (hp _ (by simp [getElem_def, List.getElem_mem])) := by\n  simp only [getElem_def, toList_pmap, List.getElem_pmap]\n\n"}
{"name":"List.Vector.get_eq_get_toList","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n\ni : Fin n\n⊢ Eq (v.get i) (v.toList.get (Fin.cast ⋯ i))","decl":"theorem get_eq_get_toList (v : Vector α n) (i : Fin n) :\n    v.get i = v.toList.get (Fin.cast v.toList_length.symm i) :=\n  rfl\n\n"}
{"name":"List.Vector.get_eq_get","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n\ni : Fin n\n⊢ Eq (v.get i) (v.toList.get (Fin.cast ⋯ i))","decl":"@[deprecated (since := \"2024-12-20\")]\nalias get_eq_get := get_eq_get_toList\n\n"}
{"name":"List.Vector.get_replicate","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\na : α\ni : Fin n\n⊢ Eq ((List.Vector.replicate n a).get i) a","decl":"@[simp]\ntheorem get_replicate (a : α) (i : Fin n) : (Vector.replicate n a).get i = a := by\n  apply List.getElem_replicate\n\n"}
{"name":"List.Vector.get_map","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nβ : Type u_6\nv : List.Vector α n\nf : α → β\ni : Fin n\n⊢ Eq ((List.Vector.map f v).get i) (f (v.get i))","decl":"@[simp]\ntheorem get_map {β : Type*} (v : Vector α n) (f : α → β) (i : Fin n) :\n    (v.map f).get i = f (v.get i) := by\n  cases v; simp [Vector.map, get_eq_get_toList]\n\n"}
{"name":"List.Vector.map₂_nil","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\n⊢ Eq (List.Vector.map₂ f List.Vector.nil List.Vector.nil) List.Vector.nil","decl":"@[simp]\ntheorem map₂_nil (f : α → β → γ) : Vector.map₂ f nil nil = nil :=\n  rfl\n\n"}
{"name":"List.Vector.map₂_cons","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nn : Nat\nhd₁ : α\ntl₁ : List.Vector α n\nhd₂ : β\ntl₂ : List.Vector β n\nf : α → β → γ\n⊢ Eq (List.Vector.map₂ f (List.Vector.cons hd₁ tl₁) (List.Vector.cons hd₂ tl₂)) (List.Vector.cons (f hd₁ hd₂) (List.Vector.map₂ f tl₁ tl₂))","decl":"@[simp]\ntheorem map₂_cons (hd₁ : α) (tl₁ : Vector α n) (hd₂ : β) (tl₂ : Vector β n) (f : α → β → γ) :\n    Vector.map₂ f (hd₁ ::ᵥ tl₁) (hd₂ ::ᵥ tl₂) = f hd₁ hd₂ ::ᵥ (Vector.map₂ f tl₁ tl₂) :=\n  rfl\n\n"}
{"name":"List.Vector.get_ofFn","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nf : Fin n → α\ni : Fin n\n⊢ Eq ((List.Vector.ofFn f).get i) (f i)","decl":"@[simp]\ntheorem get_ofFn {n} (f : Fin n → α) (i) : get (ofFn f) i = f i := by\n  conv_rhs => erw [← List.get_ofFn f ⟨i, by simp⟩]\n  simp only [get_eq_get_toList]\n  congr <;> simp [Fin.heq_ext_iff]\n\n"}
{"name":"List.Vector.ofFn_get","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n\n⊢ Eq (List.Vector.ofFn v.get) v","decl":"@[simp]\ntheorem ofFn_get (v : Vector α n) : ofFn (get v) = v := by\n  rcases v with ⟨l, rfl⟩\n  apply toList_injective\n  dsimp\n  simpa only [toList_ofFn] using List.ofFn_get _\n\n"}
{"name":"List.Vector.get_tail","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nx : List.Vector α n\ni : Fin (HSub.hSub n 1)\n⊢ Eq (x.tail.get i) (x.get ⟨HAdd.hAdd (↑i) 1, ⋯⟩)","decl":"theorem get_tail (x : Vector α n) (i) : x.tail.get i = x.get ⟨i.1 + 1, by omega⟩ := by\n  cases' i with i ih; dsimp\n  rcases x with ⟨_ | _, h⟩ <;> try rfl\n  rw [List.length] at h\n  rw [← h] at ih\n  contradiction\n\n"}
{"name":"List.Vector.get_tail_succ","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n.succ\ni : Fin n\n⊢ Eq (v.tail.get i) (v.get i.succ)","decl":"@[simp]\ntheorem get_tail_succ : ∀ (v : Vector α n.succ) (i : Fin n), get (tail v) i = get v i.succ\n  | ⟨a :: l, e⟩, ⟨i, h⟩ => by simp [get_eq_get_toList]; rfl\n\n"}
{"name":"List.Vector.tail_val","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n.succ\n⊢ Eq (↑v.tail) (↑v).tail","decl":"@[simp]\ntheorem tail_val : ∀ v : Vector α n.succ, v.tail.val = v.val.tail\n  | ⟨_ :: _, _⟩ => rfl\n\n"}
{"name":"List.Vector.tail_nil","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\n⊢ Eq List.Vector.nil.tail List.Vector.nil","decl":"/-- The `tail` of a `nil` vector is `nil`. -/\n@[simp]\ntheorem tail_nil : (@nil α).tail = nil :=\n  rfl\n\n"}
{"name":"List.Vector.singleton_tail","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nv : List.Vector α 1\n⊢ Eq v.tail List.Vector.nil","decl":"/-- The `tail` of a vector made up of one element is `nil`. -/\n@[simp]\ntheorem singleton_tail : ∀ (v : Vector α 1), v.tail = Vector.nil\n  | ⟨[_], _⟩ => rfl\n\n"}
{"name":"List.Vector.tail_ofFn","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nf : Fin n.succ → α\n⊢ Eq (List.Vector.ofFn f).tail (List.Vector.ofFn fun i => f i.succ)","decl":"@[simp]\ntheorem tail_ofFn {n : ℕ} (f : Fin n.succ → α) : tail (ofFn f) = ofFn fun i => f i.succ :=\n  (ofFn_get _).symm.trans <| by\n    congr\n    funext i\n    rw [get_tail, get_ofFn]\n    rfl\n\n"}
{"name":"List.Vector.toList_empty","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nv : List.Vector α 0\n⊢ Eq v.toList List.nil","decl":"@[simp]\ntheorem toList_empty (v : Vector α 0) : v.toList = [] :=\n  List.length_eq_zero.mp v.2\n\n"}
{"name":"List.Vector.toList_singleton","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nv : List.Vector α 1\n⊢ Eq v.toList (List.cons v.head List.nil)","decl":"/-- The list that makes up a `Vector` made up of a single element,\nretrieved via `toList`, is equal to the list of that single element. -/\n@[simp]\ntheorem toList_singleton (v : Vector α 1) : v.toList = [v.head] := by\n  rw [← v.cons_head_tail]\n  simp only [toList_cons, toList_nil, head_cons, eq_self_iff_true, and_self_iff, singleton_tail]\n\n"}
{"name":"List.Vector.empty_toList_eq_ff","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α (HAdd.hAdd n 1)\n⊢ Eq v.toList.isEmpty Bool.false","decl":"@[simp]\ntheorem empty_toList_eq_ff (v : Vector α (n + 1)) : v.toList.isEmpty = false :=\n  match v with\n  | ⟨_ :: _, _⟩ => rfl\n\n"}
{"name":"List.Vector.not_empty_toList","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α (HAdd.hAdd n 1)\n⊢ Not (Eq v.toList.isEmpty Bool.true)","decl":"theorem not_empty_toList (v : Vector α (n + 1)) : ¬v.toList.isEmpty := by\n  simp only [empty_toList_eq_ff, Bool.coe_sort_false, not_false_iff]\n\n"}
{"name":"List.Vector.map_id","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n\n⊢ Eq (List.Vector.map id v) v","decl":"/-- Mapping under `id` does not change a vector. -/\n@[simp]\ntheorem map_id {n : ℕ} (v : Vector α n) : Vector.map id v = v :=\n  Vector.eq _ _ (by simp only [List.map_id, Vector.toList_map])\n\n"}
{"name":"List.Vector.nodup_iff_injective_get","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n\n⊢ Iff v.toList.Nodup (Function.Injective v.get)","decl":"theorem nodup_iff_injective_get {v : Vector α n} : v.toList.Nodup ↔ Function.Injective v.get := by\n  cases' v with l hl\n  subst hl\n  exact List.nodup_iff_injective_get\n\n"}
{"name":"List.Vector.head?_toList","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n.succ\n⊢ Eq v.toList.head? (Option.some v.head)","decl":"theorem head?_toList : ∀ v : Vector α n.succ, (toList v).head? = some (head v)\n  | ⟨_ :: _, _⟩ => rfl\n\n"}
{"name":"List.Vector.toList_reverse","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n\n⊢ Eq v.reverse.toList v.toList.reverse","decl":"/-- The `List` of a vector after a `reverse`, retrieved by `toList` is equal\nto the `List.reverse` after retrieving a vector's `toList`. -/\ntheorem toList_reverse {v : Vector α n} : v.reverse.toList = v.toList.reverse :=\n  rfl\n\n"}
{"name":"List.Vector.reverse_reverse","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n\n⊢ Eq v.reverse.reverse v","decl":"@[simp]\ntheorem reverse_reverse {v : Vector α n} : v.reverse.reverse = v := by\n  cases v\n  simp [Vector.reverse]\n\n"}
{"name":"List.Vector.get_zero","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n.succ\n⊢ Eq (v.get 0) v.head","decl":"@[simp]\ntheorem get_zero : ∀ v : Vector α n.succ, get v 0 = head v\n  | ⟨_ :: _, _⟩ => rfl\n\n"}
{"name":"List.Vector.head_ofFn","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nf : Fin n.succ → α\n⊢ Eq (List.Vector.ofFn f).head (f 0)","decl":"@[simp]\ntheorem head_ofFn {n : ℕ} (f : Fin n.succ → α) : head (ofFn f) = f 0 := by\n  rw [← get_zero, get_ofFn]\n\n"}
{"name":"List.Vector.get_cons_zero","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\na : α\nv : List.Vector α n\n⊢ Eq ((List.Vector.cons a v).get 0) a","decl":"theorem get_cons_zero (a : α) (v : Vector α n) : get (a ::ᵥ v) 0 = a := by simp [get_zero]\n\n"}
{"name":"List.Vector.get_cons_nil","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nix : Fin 1\nx : α\n⊢ Eq ((List.Vector.cons x List.Vector.nil).get ix) x","decl":"/-- Accessing the nth element of a vector made up\nof one element `x : α` is `x` itself. -/\n@[simp]\ntheorem get_cons_nil : ∀ {ix : Fin 1} (x : α), get (x ::ᵥ nil) ix = x\n  | ⟨0, _⟩, _ => rfl\n\n"}
{"name":"List.Vector.get_cons_succ","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\na : α\nv : List.Vector α n\ni : Fin n\n⊢ Eq ((List.Vector.cons a v).get i.succ) (v.get i)","decl":"@[simp]\ntheorem get_cons_succ (a : α) (v : Vector α n) (i : Fin n) : get (a ::ᵥ v) i.succ = get v i := by\n  rw [← get_tail_succ, tail_cons]\n\n"}
{"name":"List.Vector.last_def","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α (HAdd.hAdd n 1)\n⊢ Eq v.last (v.get (Fin.last n))","decl":"/-- The last element of a `Vector`, given that the vector is at least one element. -/\ntheorem last_def {v : Vector α (n + 1)} : v.last = v.get (Fin.last n) :=\n  rfl\n\n"}
{"name":"List.Vector.reverse_get_zero","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α (HAdd.hAdd n 1)\n⊢ Eq v.reverse.head v.last","decl":"/-- The `last` element of a vector is the `head` of the `reverse` vector. -/\ntheorem reverse_get_zero {v : Vector α (n + 1)} : v.reverse.head = v.last := by\n  rw [← get_zero, last_def, get_eq_get_toList, get_eq_get_toList]\n  simp_rw [toList_reverse]\n  rw [List.get_eq_getElem, List.get_eq_getElem, ← Option.some_inj, Fin.cast, Fin.cast,\n    ← List.getElem?_eq_getElem, ← List.getElem?_eq_getElem, List.getElem?_reverse]\n  · congr\n    simp\n  · simp\n\n"}
{"name":"List.Vector.scanl_nil","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nβ : Type u_6\nf : β → α → β\nb : β\n⊢ Eq (List.Vector.scanl f b List.Vector.nil) (List.Vector.cons b List.Vector.nil)","decl":"/-- Providing an empty vector to `scanl` gives the starting value `b : β`. -/\n@[simp]\ntheorem scanl_nil : scanl f b nil = b ::ᵥ nil :=\n  rfl\n\n"}
{"name":"List.Vector.scanl_cons","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nβ : Type u_6\nf : β → α → β\nb : β\nv : List.Vector α n\nx : α\n⊢ Eq (List.Vector.scanl f b (List.Vector.cons x v)) (List.Vector.cons b (List.Vector.scanl f (f b x) v))","decl":"/-- The recursive step of `scanl` splits a vector `x ::ᵥ v : Vector α (n + 1)`\ninto the provided starting value `b : β` and the recursed `scanl`\n`f b x : β` as the starting value.\n\nThis lemma is the `cons` version of `scanl_get`.\n-/\n@[simp]\ntheorem scanl_cons (x : α) : scanl f b (x ::ᵥ v) = b ::ᵥ scanl f (f b x) v := by\n  simp only [scanl, toList_cons, List.scanl]; dsimp\n  simp only [cons]\n\n"}
{"name":"List.Vector.scanl_val","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nβ : Type u_6\nf : β → α → β\nb : β\nv : List.Vector α n\n⊢ Eq (↑(List.Vector.scanl f b v)) (List.scanl f b ↑v)","decl":"/-- The underlying `List` of a `Vector` after a `scanl` is the `List.scanl`\nof the underlying `List` of the original `Vector`.\n-/\n@[simp]\ntheorem scanl_val : ∀ {v : Vector α n}, (scanl f b v).val = List.scanl f b v.val\n  | _ => rfl\n\n"}
{"name":"List.Vector.toList_scanl","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nβ : Type u_6\nf : β → α → β\nb : β\nv : List.Vector α n\n⊢ Eq (List.Vector.scanl f b v).toList (List.scanl f b v.toList)","decl":"/-- The `toList` of a `Vector` after a `scanl` is the `List.scanl`\nof the `toList` of the original `Vector`.\n-/\n@[simp]\ntheorem toList_scanl : (scanl f b v).toList = List.scanl f b v.toList :=\n  rfl\n\n"}
{"name":"List.Vector.scanl_singleton","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nβ : Type u_6\nf : β → α → β\nb : β\nv : List.Vector α 1\n⊢ Eq (List.Vector.scanl f b v) (List.Vector.cons b (List.Vector.cons (f b v.head) List.Vector.nil))","decl":"/-- The recursive step of `scanl` splits a vector made up of a single element\n`x ::ᵥ nil : Vector α 1` into a `Vector` of the provided starting value `b : β`\nand the mapped `f b x : β` as the last value.\n-/\n@[simp]\ntheorem scanl_singleton (v : Vector α 1) : scanl f b v = b ::ᵥ f b v.head ::ᵥ nil := by\n  rw [← cons_head_tail v]\n  simp only [scanl_cons, scanl_nil, head_cons, singleton_tail]\n\n"}
{"name":"List.Vector.scanl_head","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nβ : Type u_6\nf : β → α → β\nb : β\nv : List.Vector α n\n⊢ Eq (List.Vector.scanl f b v).head b","decl":"/-- The first element of `scanl` of a vector `v : Vector α n`,\nretrieved via `head`, is the starting value `b : β`.\n-/\n@[simp]\ntheorem scanl_head : (scanl f b v).head = b := by\n  cases n\n  · have : v = nil := by simp only [eq_iff_true_of_subsingleton]\n    simp only [this, scanl_nil, head_cons]\n  · rw [← cons_head_tail v]\n    simp [← get_zero, get_eq_get_toList]\n\n"}
{"name":"List.Vector.scanl_get","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nβ : Type u_6\nf : β → α → β\nb : β\nv : List.Vector α n\ni : Fin n\n⊢ Eq ((List.Vector.scanl f b v).get i.succ) (f ((List.Vector.scanl f b v).get i.castSucc) (v.get i))","decl":"/-- For an index `i : Fin n`, the nth element of `scanl` of a\nvector `v : Vector α n` at `i.succ`, is equal to the application\nfunction `f : β → α → β` of the `castSucc i` element of\n`scanl f b v` and `get v i`.\n\nThis lemma is the `get` version of `scanl_cons`.\n-/\n@[simp]\ntheorem scanl_get (i : Fin n) :\n    (scanl f b v).get i.succ = f ((scanl f b v).get (Fin.castSucc i)) (v.get i) := by\n  cases' n with n\n  · exact i.elim0\n  induction' n with n hn generalizing b\n  · have i0 : i = 0 := Fin.eq_zero _\n    simp [scanl_singleton, i0, get_zero]; simp [get_eq_get_toList, List.get]\n  · rw [← cons_head_tail v, scanl_cons, get_cons_succ]\n    refine Fin.cases ?_ ?_ i\n    · simp only [get_zero, scanl_head, Fin.castSucc_zero, head_cons]\n    · intro i'\n      simp only [hn, Fin.castSucc_fin_succ, get_cons_succ]\n\n"}
{"name":"List.Vector.mOfFn_pure","module":"Mathlib.Data.Vector.Basic","initialProofState":"m : Type u_6 → Type u_7\ninst✝¹ : Monad m\ninst✝ : LawfulMonad m\nα : Type u_6\nn : Nat\nf : Fin n → α\n⊢ Eq (List.Vector.mOfFn fun i => Pure.pure (f i)) (Pure.pure (List.Vector.ofFn f))","decl":"theorem mOfFn_pure {m} [Monad m] [LawfulMonad m] {α} :\n    ∀ {n} (f : Fin n → α), (@mOfFn m _ _ _ fun i => pure (f i)) = pure (ofFn f)\n  | 0, _ => rfl\n  | n + 1, f => by\n    rw [mOfFn, @mOfFn_pure m _ _ _ n _, ofFn]\n    simp\n\n"}
{"name":"List.Vector.mmap_nil","module":"Mathlib.Data.Vector.Basic","initialProofState":"m : Type u_6 → Type u_7\ninst✝ : Monad m\nα : Type u_8\nβ : Type u_6\nf : α → m β\n⊢ Eq (List.Vector.mmap f List.Vector.nil) (Pure.pure List.Vector.nil)","decl":"@[simp]\ntheorem mmap_nil {m} [Monad m] {α β} (f : α → m β) : mmap f nil = pure nil :=\n  rfl\n\n"}
{"name":"List.Vector.mmap_cons","module":"Mathlib.Data.Vector.Basic","initialProofState":"m : Type u_6 → Type u_7\ninst✝ : Monad m\nα : Type u_8\nβ : Type u_6\nf : α → m β\na : α\nn : Nat\nv : List.Vector α n\n⊢ Eq (List.Vector.mmap f (List.Vector.cons a v)) (Bind.bind (f a) fun h' => Bind.bind (List.Vector.mmap f v) fun t' => Pure.pure (List.Vector.cons h' t'))","decl":"@[simp]\ntheorem mmap_cons {m} [Monad m] {α β} (f : α → m β) (a) :\n    ∀ {n} (v : Vector α n),\n      mmap f (a ::ᵥ v) = do\n        let h' ← f a\n        let t' ← mmap f v\n        pure (h' ::ᵥ t')\n  | _, ⟨_, rfl⟩ => rfl\n\n"}
{"name":"List.Vector.inductionOn_nil","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nC : {n : Nat} → List.Vector α n → Sort u_6\nnil : C List.Vector.nil\ncons : {n : Nat} → {x : α} → {w : List.Vector α n} → C w → C (List.Vector.cons x w)\n⊢ Eq (List.Vector.nil.inductionOn nil fun {n} {x} {w} => cons) nil","decl":"@[simp]\ntheorem inductionOn_nil {C : ∀ {n : ℕ}, Vector α n → Sort*}\n    (nil : C nil) (cons : ∀ {n : ℕ} {x : α} {w : Vector α n}, C w → C (x ::ᵥ w)) :\n    Vector.nil.inductionOn nil cons = nil :=\n  rfl\n\n"}
{"name":"List.Vector.inductionOn_cons","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nC : {n : Nat} → List.Vector α n → Sort u_6\nn : Nat\nx : α\nv : List.Vector α n\nnil : C List.Vector.nil\ncons : {n : Nat} → {x : α} → {w : List.Vector α n} → C w → C (List.Vector.cons x w)\n⊢ Eq ((List.Vector.cons x v).inductionOn nil fun {n} {x} {w} => cons) (cons (v.inductionOn nil fun {n} {x} {w} => cons))","decl":"@[simp]\ntheorem inductionOn_cons {C : ∀ {n : ℕ}, Vector α n → Sort*} {n : ℕ} (x : α) (v : Vector α n)\n    (nil : C nil) (cons : ∀ {n : ℕ} {x : α} {w : Vector α n}, C w → C (x ::ᵥ w)) :\n    (x ::ᵥ v).inductionOn nil cons = cons (v.inductionOn nil cons : C v) :=\n  rfl\n\n"}
{"name":"List.Vector.insertIdx_val","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\na : α\ni : Fin (HAdd.hAdd n 1)\nv : List.Vector α n\n⊢ Eq (↑(List.Vector.insertIdx a i v)) (List.insertIdx (↑i) a ↑v)","decl":"theorem insertIdx_val {i : Fin (n + 1)} {v : Vector α n} :\n    (v.insertIdx a i).val = v.val.insertIdx i.1 a :=\n  rfl\n\n"}
{"name":"List.Vector.insertNth_val","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\na : α\ni : Fin (HAdd.hAdd n 1)\nv : List.Vector α n\n⊢ Eq (↑(List.Vector.insertIdx a i v)) (List.insertIdx (↑i) a ↑v)","decl":"@[deprecated (since := \"2024-10-21\")] alias insertNth_val := insertIdx_val\n\n"}
{"name":"List.Vector.eraseIdx_val","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\ni : Fin n\nv : List.Vector α n\n⊢ Eq (↑(List.Vector.eraseIdx i v)) ((↑v).eraseIdx ↑i)","decl":"@[simp]\ntheorem eraseIdx_val {i : Fin n} : ∀ {v : Vector α n}, (eraseIdx i v).val = v.val.eraseIdx i\n  | _ => rfl\n\n"}
{"name":"List.Vector.eraseNth_val","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\ni : Fin n\nv : List.Vector α n\n⊢ Eq (↑(List.Vector.eraseIdx i v)) ((↑v).eraseIdx ↑i)","decl":"@[deprecated (since := \"2024-10-21\")] alias eraseNth_val := eraseIdx_val\n"}
{"name":"List.Vector.eraseIdx_insertIdx","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\na : α\nv : List.Vector α n\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (List.Vector.eraseIdx i (List.Vector.insertIdx a i v)) v","decl":"theorem eraseIdx_insertIdx {v : Vector α n} {i : Fin (n + 1)} :\n    eraseIdx i (insertIdx a i v) = v :=\n  Subtype.eq <| List.eraseIdx_insertIdx i.1 v.1\n\n"}
{"name":"List.Vector.eraseIdx_insertIdx'","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\na : α\nv : List.Vector α (HAdd.hAdd n 1)\ni : Fin (HAdd.hAdd n 1)\nj : Fin (HAdd.hAdd n 2)\n⊢ Eq (List.Vector.eraseIdx (j.succAbove i) (List.Vector.insertIdx a j v)) (List.Vector.insertIdx a (i.predAbove j) (List.Vector.eraseIdx i v))","decl":"/-- Erasing an element after inserting an element, at different indices. -/\ntheorem eraseIdx_insertIdx' {v : Vector α (n + 1)} :\n    ∀ {i : Fin (n + 1)} {j : Fin (n + 2)},\n      eraseIdx (j.succAbove i) (insertIdx a j v) = insertIdx a (i.predAbove j) (eraseIdx i v)\n  | ⟨i, hi⟩, ⟨j, hj⟩ => by\n    dsimp [insertIdx, eraseIdx, Fin.succAbove, Fin.predAbove]\n    rw [Subtype.mk_eq_mk]\n    simp only [Fin.lt_iff_val_lt_val]\n    split_ifs with hij\n    · rcases Nat.exists_eq_succ_of_ne_zero\n        (Nat.pos_iff_ne_zero.1 (lt_of_le_of_lt (Nat.zero_le _) hij)) with ⟨j, rfl⟩\n      rw [← List.insertIdx_eraseIdx_of_ge]\n      · simp; rfl\n      · simpa\n      · simpa [Nat.lt_succ_iff] using hij\n    · dsimp\n      rw [← List.insertIdx_eraseIdx_of_le i j _ _ _]\n      · rfl\n      · simpa\n      · simpa [not_lt] using hij\n\n"}
{"name":"List.Vector.insertIdx_comm","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\na b : α\ni j : Fin (HAdd.hAdd n 1)\nh : LE.le i j\nv : List.Vector α n\n⊢ Eq (List.Vector.insertIdx b j.succ (List.Vector.insertIdx a i v)) (List.Vector.insertIdx a i.castSucc (List.Vector.insertIdx b j v))","decl":"theorem insertIdx_comm (a b : α) (i j : Fin (n + 1)) (h : i ≤ j) :\n    ∀ v : Vector α n,\n      (v.insertIdx a i).insertIdx b j.succ = (v.insertIdx b j).insertIdx a (Fin.castSucc i)\n  | ⟨l, hl⟩ => by\n    refine Subtype.eq ?_\n    simp only [insertIdx_val, Fin.val_succ, Fin.castSucc, Fin.coe_castAdd]\n    apply List.insertIdx_comm\n    · assumption\n    · rw [hl]\n      exact Nat.le_of_succ_le_succ j.2\n\n"}
{"name":"List.Vector.insertNth_comm","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\na b : α\ni j : Fin (HAdd.hAdd n 1)\nh : LE.le i j\nv : List.Vector α n\n⊢ Eq (List.Vector.insertIdx b j.succ (List.Vector.insertIdx a i v)) (List.Vector.insertIdx a i.castSucc (List.Vector.insertIdx b j v))","decl":"@[deprecated (since := \"2024-10-21\")] alias insertNth_comm := insertIdx_comm\n\n"}
{"name":"List.Vector.toList_set","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n\ni : Fin n\na : α\n⊢ Eq (v.set i a).toList (v.toList.set (↑i) a)","decl":"@[simp]\ntheorem toList_set (v : Vector α n) (i : Fin n) (a : α) :\n    (v.set i a).toList = v.toList.set i a :=\n  rfl\n\n"}
{"name":"List.Vector.get_set_same","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n\ni : Fin n\na : α\n⊢ Eq ((v.set i a).get i) a","decl":"@[simp]\ntheorem get_set_same (v : Vector α n) (i : Fin n) (a : α) : (v.set i a).get i = a := by\n  cases v; cases i; simp [Vector.set, get_eq_get_toList]\n\n"}
{"name":"List.Vector.get_set_of_ne","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n\ni j : Fin n\nh : Ne i j\na : α\n⊢ Eq ((v.set i a).get j) (v.get j)","decl":"theorem get_set_of_ne {v : Vector α n} {i j : Fin n} (h : i ≠ j) (a : α) :\n    (v.set i a).get j = v.get j := by\n  cases v; cases i; cases j\n  simp only [get_eq_get_toList, toList_set, toList_mk, Fin.cast_mk, List.get_eq_getElem]\n  rw [List.getElem_set_of_ne]\n  · simpa using h\n\n"}
{"name":"List.Vector.get_set_eq_if","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nv : List.Vector α n\ni j : Fin n\na : α\n⊢ Eq ((v.set i a).get j) (ite (Eq i j) a (v.get j))","decl":"theorem get_set_eq_if {v : Vector α n} {i j : Fin n} (a : α) :\n    (v.set i a).get j = if i = j then a else v.get j := by\n  split_ifs <;> (try simp [*]); rwa [get_set_of_ne]\n\n"}
{"name":"List.Vector.sum_set","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : AddMonoid α\nv : List.Vector α n\ni : Fin n\na : α\n⊢ Eq (v.set i a).toList.sum (HAdd.hAdd (HAdd.hAdd (List.Vector.take (↑i) v).toList.sum a) (List.Vector.drop (HAdd.hAdd (↑i) 1) v).toList.sum)","decl":"@[to_additive]\ntheorem prod_set [Monoid α] (v : Vector α n) (i : Fin n) (a : α) :\n    (v.set i a).toList.prod = (v.take i).toList.prod * a * (v.drop (i + 1)).toList.prod := by\n  refine (List.prod_set v.toList i a).trans ?_\n  simp_all\n\n"}
{"name":"List.Vector.prod_set","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : Monoid α\nv : List.Vector α n\ni : Fin n\na : α\n⊢ Eq (v.set i a).toList.prod (HMul.hMul (HMul.hMul (List.Vector.take (↑i) v).toList.prod a) (List.Vector.drop (HAdd.hAdd (↑i) 1) v).toList.prod)","decl":"@[to_additive]\ntheorem prod_set [Monoid α] (v : Vector α n) (i : Fin n) (a : α) :\n    (v.set i a).toList.prod = (v.take i).toList.prod * a * (v.drop (i + 1)).toList.prod := by\n  refine (List.prod_set v.toList i a).trans ?_\n  simp_all\n\n"}
{"name":"List.Vector.sum_set'","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : AddCommGroup α\nv : List.Vector α n\ni : Fin n\na : α\n⊢ Eq (v.set i a).toList.sum (HAdd.hAdd (HAdd.hAdd v.toList.sum (Neg.neg (v.get i))) a)","decl":"/-- Variant of `List.Vector.prod_set` that multiplies by the inverse of the replaced element.-/\n@[to_additive\n  \"Variant of `List.Vector.sum_set` that subtracts the inverse of the replaced element.\"]\ntheorem prod_set' [CommGroup α] (v : Vector α n) (i : Fin n) (a : α) :\n    (v.set i a).toList.prod = v.toList.prod * (v.get i)⁻¹ * a := by\n  refine (List.prod_set' v.toList i a).trans ?_\n  simp [get_eq_get_toList, mul_assoc]\n\n"}
{"name":"List.Vector.prod_set'","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : CommGroup α\nv : List.Vector α n\ni : Fin n\na : α\n⊢ Eq (v.set i a).toList.prod (HMul.hMul (HMul.hMul v.toList.prod (Inv.inv (v.get i))) a)","decl":"/-- Variant of `List.Vector.prod_set` that multiplies by the inverse of the replaced element.-/\n@[to_additive\n  \"Variant of `List.Vector.sum_set` that subtracts the inverse of the replaced element.\"]\ntheorem prod_set' [CommGroup α] (v : Vector α n) (i : Fin n) (a : α) :\n    (v.set i a).toList.prod = v.toList.prod * (v.get i)⁻¹ * a := by\n  refine (List.prod_set' v.toList i a).trans ?_\n  simp [get_eq_get_toList, mul_assoc]\n\n"}
{"name":"List.Vector.traverse_def","module":"Mathlib.Data.Vector.Basic","initialProofState":"n : Nat\nF : Type u → Type u\ninst✝ : Applicative F\nα β : Type u\nf : α → F β\nx : α\nxs : List.Vector α n\n⊢ Eq (List.Vector.traverse f (List.Vector.cons x xs)) (Seq.seq (Functor.map List.Vector.cons (f x)) fun x => List.Vector.traverse f xs)","decl":"@[simp]\nprotected theorem traverse_def (f : α → F β) (x : α) :\n    ∀ xs : Vector α n, (x ::ᵥ xs).traverse f = cons <$> f x <*> xs.traverse f := by\n  rintro ⟨xs, rfl⟩; rfl\n\n"}
{"name":"List.Vector.id_traverse","module":"Mathlib.Data.Vector.Basic","initialProofState":"n : Nat\nα : Type u\nx : List.Vector α n\n⊢ Eq (List.Vector.traverse Pure.pure x) x","decl":"protected theorem id_traverse : ∀ x : Vector α n, x.traverse (pure : _ → Id _) = x := by\n  rintro ⟨x, rfl⟩; dsimp [Vector.traverse, cast]\n  induction' x with x xs IH; · rfl\n  simp! [IH]; rfl\n\n"}
{"name":"List.Vector.comp_traverse","module":"Mathlib.Data.Vector.Basic","initialProofState":"n : Nat\nF G : Type u → Type u\ninst✝² : Applicative F\ninst✝¹ : Applicative G\ninst✝ : LawfulApplicative G\nα β γ : Type u\nf : β → F γ\ng : α → G β\nx : List.Vector α n\n⊢ Eq (List.Vector.traverse (Function.comp Functor.Comp.mk (Function.comp (Functor.map f) g)) x) (Functor.Comp.mk (Functor.map (List.Vector.traverse f) (List.Vector.traverse g x)))","decl":"@[nolint unusedArguments]\nprotected theorem comp_traverse (f : β → F γ) (g : α → G β) (x : Vector α n) :\n    Vector.traverse (Comp.mk ∘ Functor.map f ∘ g) x =\n      Comp.mk (Vector.traverse f <$> Vector.traverse g x) := by\n  induction' x with n x xs ih\n  · simp! [cast, *, functor_norm]\n    rfl\n  · rw [Vector.traverse_def, ih]\n    simp [functor_norm, Function.comp_def]\n\n"}
{"name":"List.Vector.traverse_eq_map_id","module":"Mathlib.Data.Vector.Basic","initialProofState":"n : Nat\nα β : Type u_6\nf : α → β\nx : List.Vector α n\n⊢ Eq (List.Vector.traverse (Function.comp Pure.pure f) x) (Pure.pure (List.Vector.map f x))","decl":"protected theorem traverse_eq_map_id {α β} (f : α → β) :\n    ∀ x : Vector α n, x.traverse ((pure : _ → Id _) ∘ f) = (pure : _ → Id _) (map f x) := by\n  rintro ⟨x, rfl⟩; simp!; induction x <;> simp! [*, functor_norm] <;> rfl\n\n"}
{"name":"List.Vector.naturality","module":"Mathlib.Data.Vector.Basic","initialProofState":"n : Nat\nF G : Type u → Type u\ninst✝³ : Applicative F\ninst✝² : Applicative G\ninst✝¹ : LawfulApplicative G\ninst✝ : LawfulApplicative F\nη : ApplicativeTransformation F G\nα β : Type u\nf : α → F β\nx : List.Vector α n\n⊢ Eq ((fun {α} => η.app α) (List.Vector.traverse f x)) (List.Vector.traverse (Function.comp (fun {α} => η.app α) f) x)","decl":"protected theorem naturality {α β : Type u} (f : α → F β) (x : Vector α n) :\n    η (x.traverse f) = x.traverse (@η _ ∘ f) := by\n  induction' x with n x xs ih\n  · simp! [functor_norm, cast, η.preserves_pure]\n  · rw [Vector.traverse_def, Vector.traverse_def, ← ih, η.preserves_seq, η.preserves_map]\n    rfl\n\n"}
{"name":"List.Vector.instLawfulTraversableFlipNat","module":"Mathlib.Data.Vector.Basic","initialProofState":"n : Nat\n⊢ LawfulTraversable (flip List.Vector n)","decl":"instance : LawfulTraversable.{u} (flip Vector n) where\n  id_traverse := @Vector.id_traverse n\n  comp_traverse := Vector.comp_traverse\n  traverse_eq_map_id := @Vector.traverse_eq_map_id n\n  naturality := Vector.naturality\n  id_map := by intro _ x; cases x; simp! [(· <$> ·)]\n  comp_map := by intro _ _ _ _ _ x; cases x; simp! [(· <$> ·)]\n  map_const := rfl\n\n-- Porting note: not porting meta instances\n-- unsafe instance reflect [reflected_univ.{u}] {α : Type u} [has_reflect α]\n--     [reflected _ α] {n : ℕ} : has_reflect (Vector α n) := fun v =>\n--   @Vector.inductionOn α (fun n => reflected _) n v\n--     ((by\n--           trace\n--             \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14:\n--              unsupported tactic `reflect_name #[]\" :\n--           reflected _ @Vector.nil.{u}).subst\n--       q(α))\n--     fun n x xs ih =>\n--     (by\n--           trace\n--             \"./././Mathport/Syntax/Translate/Tactic/Builtin.lean:76:14:\n--              unsupported tactic `reflect_name #[]\" :\n--           reflected _ @Vector.cons.{u}).subst₄\n--       q(α) q(n) q(x) ih\n\n"}
{"name":"List.Vector.replicate_succ","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nval : α\n⊢ Eq (List.Vector.replicate (HAdd.hAdd n 1) val) (List.Vector.cons val (List.Vector.replicate n val))","decl":"@[simp]\ntheorem replicate_succ (val : α) :\n    replicate (n+1) val = val ::ᵥ (replicate n val) :=\n  rfl\n\n"}
{"name":"List.Vector.get_append_cons_zero","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nm n : Nat\nx : α\nxs : List.Vector α n\nys : List.Vector α m\n⊢ Eq (((List.Vector.cons x xs).append ys).get ⟨0, ⋯⟩) x","decl":"@[simp] lemma get_append_cons_zero : get (append (x ::ᵥ xs) ys) ⟨0, by omega⟩ = x := rfl\n\n"}
{"name":"List.Vector.get_append_cons_succ","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nm n : Nat\nx : α\nxs : List.Vector α n\nys : List.Vector α m\ni : Fin (HAdd.hAdd n m)\nh : LT.lt (HAdd.hAdd (↑i) 1) (HAdd.hAdd n.succ m)\n⊢ Eq (((List.Vector.cons x xs).append ys).get ⟨HAdd.hAdd (↑i) 1, h⟩) ((xs.append ys).get i)","decl":"@[simp]\ntheorem get_append_cons_succ {i : Fin (n + m)} {h} :\n    get (append (x ::ᵥ xs) ys) ⟨i+1, h⟩ = get (append xs ys) i :=\n  rfl\n\n"}
{"name":"List.Vector.append_nil","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nn : Nat\nxs : List.Vector α n\n⊢ Eq (xs.append List.Vector.nil) xs","decl":"@[simp]\ntheorem append_nil : append xs nil = xs := by\n  cases xs; simp [append]\n\n"}
{"name":"List.Vector.get_map₂","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nn : Nat\nv₁ : List.Vector α n\nv₂ : List.Vector β n\nf : α → β → γ\ni : Fin n\n⊢ Eq ((List.Vector.map₂ f v₁ v₂).get i) (f (v₁.get i) (v₂.get i))","decl":"@[simp]\ntheorem get_map₂ (v₁ : Vector α n) (v₂ : Vector β n) (f : α → β → γ) (i : Fin n) :\n    get (map₂ f v₁ v₂) i = f (get v₁ i) (get v₂ i) := by\n  clear * - v₁ v₂\n  induction v₁, v₂ using inductionOn₂ with\n  | nil =>\n    exact Fin.elim0 i\n  | cons ih =>\n    rw [map₂_cons]\n    cases i using Fin.cases\n    · simp only [get_zero, head_cons]\n    · simp only [get_cons_succ, ih]\n\n"}
{"name":"List.Vector.mapAccumr_cons","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_4\nn : Nat\nx : α\ns : σ\nxs : List.Vector α n\nf : α → σ → Prod σ β\n⊢ Eq (List.Vector.mapAccumr f (List.Vector.cons x xs) s)\n    (let r := List.Vector.mapAccumr f xs s;\n    let q := f x r.1;\n    { fst := q.1, snd := List.Vector.cons q.2 r.2 })","decl":"@[simp]\ntheorem mapAccumr_cons {f : α → σ → σ × β} :\n    mapAccumr f (x ::ᵥ xs) s\n    = let r := mapAccumr f xs s\n      let q := f x r.1\n      (q.1, q.2 ::ᵥ r.2) :=\n  rfl\n\n"}
{"name":"List.Vector.mapAccumr₂_cons","module":"Mathlib.Data.Vector.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nσ : Type u_4\nφ : Type u_5\nn : Nat\nx : α\ny : β\ns : σ\nxs : List.Vector α n\nys : List.Vector β n\nf : α → β → σ → Prod σ φ\n⊢ Eq (List.Vector.mapAccumr₂ f (List.Vector.cons x xs) (List.Vector.cons y ys) s)\n    (let r := List.Vector.mapAccumr₂ f xs ys s;\n    let q := f x y r.1;\n    { fst := q.1, snd := List.Vector.cons q.2 r.2 })","decl":"@[simp]\ntheorem mapAccumr₂_cons {f : α → β → σ → σ × φ} :\n    mapAccumr₂ f (x ::ᵥ xs) (y ::ᵥ ys) s\n    = let r := mapAccumr₂ f xs ys s\n      let q := f x y r.1\n      (q.1, q.2 ::ᵥ r.2) :=\n  rfl\n\n"}
