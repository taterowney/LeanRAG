{"name":"RelEmbedding.coe_natLT","module":"Mathlib.Order.OrderIsoNat","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\nf : Nat → α\nH : ∀ (n : Nat), r (f n) (f (HAdd.hAdd n 1))\n⊢ Eq (⇑(RelEmbedding.natLT f H)) f","decl":"@[simp]\ntheorem coe_natLT {f : ℕ → α} {H : ∀ n : ℕ, r (f n) (f (n + 1))} : ⇑(natLT f H) = f :=\n  rfl\n\n"}
{"name":"RelEmbedding.coe_natGT","module":"Mathlib.Order.OrderIsoNat","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\nf : Nat → α\nH : ∀ (n : Nat), r (f (HAdd.hAdd n 1)) (f n)\n⊢ Eq (⇑(RelEmbedding.natGT f H)) f","decl":"@[simp]\ntheorem coe_natGT {f : ℕ → α} {H : ∀ n : ℕ, r (f (n + 1)) (f n)} : ⇑(natGT f H) = f :=\n  rfl\n\n"}
{"name":"RelEmbedding.exists_not_acc_lt_of_not_acc","module":"Mathlib.Order.OrderIsoNat","initialProofState":"α : Type u_1\na : α\nr : α → α → Prop\nh : Not (Acc r a)\n⊢ Exists fun b => And (Not (Acc r b)) (r b a)","decl":"theorem exists_not_acc_lt_of_not_acc {a : α} {r} (h : ¬Acc r a) : ∃ b, ¬Acc r b ∧ r b a := by\n  contrapose! h\n  refine ⟨_, fun b hr => ?_⟩\n  by_contra hb\n  exact h b hb hr\n\n"}
{"name":"RelEmbedding.acc_iff_no_decreasing_seq","module":"Mathlib.Order.OrderIsoNat","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\nx : α\n⊢ Iff (Acc r x) (IsEmpty (Subtype fun f => Membership.mem (Set.range ⇑f) x))","decl":"/-- A value is accessible iff it isn't contained in any infinite decreasing sequence. -/\ntheorem acc_iff_no_decreasing_seq {x} :\n    Acc r x ↔ IsEmpty { f : ((· > ·) : ℕ → ℕ → Prop) ↪r r // x ∈ Set.range f } := by\n  constructor\n  · refine fun h => h.recOn fun x _ IH => ?_\n    constructor\n    rintro ⟨f, k, hf⟩\n    exact IsEmpty.elim' (IH (f (k + 1)) (hf ▸ f.map_rel_iff.2 (Nat.lt_succ_self _))) ⟨f, _, rfl⟩\n  · have : ∀ x : { a // ¬Acc r a }, ∃ y : { a // ¬Acc r a }, r y.1 x.1 := by\n      rintro ⟨x, hx⟩\n      cases exists_not_acc_lt_of_not_acc hx with\n      | intro w h => exact ⟨⟨w, h.1⟩, h.2⟩\n    choose f h using this\n    refine fun E =>\n      by_contradiction fun hx => E.elim' ⟨natGT (fun n => (f^[n] ⟨x, hx⟩).1) fun n => ?_, 0, rfl⟩\n    simp only [Function.iterate_succ']\n    apply h\n\n"}
{"name":"RelEmbedding.not_acc_of_decreasing_seq","module":"Mathlib.Order.OrderIsoNat","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\nf : RelEmbedding (fun x1 x2 => GT.gt x1 x2) r\nk : Nat\n⊢ Not (Acc r (f k))","decl":"theorem not_acc_of_decreasing_seq (f : ((· > ·) : ℕ → ℕ → Prop) ↪r r) (k : ℕ) : ¬Acc r (f k) := by\n  rw [acc_iff_no_decreasing_seq, not_isEmpty_iff]\n  exact ⟨⟨f, k, rfl⟩⟩\n\n"}
{"name":"RelEmbedding.wellFounded_iff_no_descending_seq","module":"Mathlib.Order.OrderIsoNat","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\n⊢ Iff (WellFounded r) (IsEmpty (RelEmbedding (fun x1 x2 => GT.gt x1 x2) r))","decl":"/-- A strict order relation is well-founded iff it doesn't have any infinite decreasing sequence.\n\nSee `wellFounded_iff_no_descending_seq` for a version which works on any relation. -/\ntheorem wellFounded_iff_no_descending_seq :\n    WellFounded r ↔ IsEmpty (((· > ·) : ℕ → ℕ → Prop) ↪r r) := by\n  constructor\n  · rintro ⟨h⟩\n    exact ⟨fun f => not_acc_of_decreasing_seq f 0 (h _)⟩\n  · intro h\n    exact ⟨fun x => acc_iff_no_decreasing_seq.2 inferInstance⟩\n\n"}
{"name":"RelEmbedding.not_wellFounded_of_decreasing_seq","module":"Mathlib.Order.OrderIsoNat","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\nf : RelEmbedding (fun x1 x2 => GT.gt x1 x2) r\n⊢ Not (WellFounded r)","decl":"theorem not_wellFounded_of_decreasing_seq (f : ((· > ·) : ℕ → ℕ → Prop) ↪r r) : ¬WellFounded r := by\n  rw [wellFounded_iff_no_descending_seq, not_isEmpty_iff]\n  exact ⟨f⟩\n\n"}
{"name":"not_strictAnti_of_wellFoundedLT","module":"Mathlib.Order.OrderIsoNat","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : WellFoundedLT α\nf : Nat → α\n⊢ Not (StrictAnti f)","decl":"theorem not_strictAnti_of_wellFoundedLT [Preorder α] [WellFoundedLT α] (f : ℕ → α) :\n    ¬ StrictAnti f := fun hf ↦\n  (RelEmbedding.natGT f (fun n ↦ hf (by simp))).not_wellFounded_of_decreasing_seq wellFounded_lt\n\n"}
{"name":"not_strictMono_of_wellFoundedGT","module":"Mathlib.Order.OrderIsoNat","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : WellFoundedGT α\nf : Nat → α\n⊢ Not (StrictMono f)","decl":"theorem not_strictMono_of_wellFoundedGT [Preorder α] [WellFoundedGT α] (f : ℕ → α) :\n    ¬ StrictMono f :=\n  not_strictAnti_of_wellFoundedLT (α := αᵒᵈ) f\n\n"}
{"name":"Nat.coe_orderEmbeddingOfSet","module":"Mathlib.Order.OrderIsoNat","initialProofState":"s : Set Nat\ninst✝¹ : Infinite ↑s\ninst✝ : DecidablePred fun x => Membership.mem s x\n⊢ Eq (⇑(Nat.orderEmbeddingOfSet s)) (Function.comp Subtype.val (Nat.Subtype.ofNat s))","decl":"@[simp]\ntheorem coe_orderEmbeddingOfSet [DecidablePred (· ∈ s)] :\n    ⇑(orderEmbeddingOfSet s) = (↑) ∘ Subtype.ofNat s :=\n  rfl\n\n"}
{"name":"Nat.orderEmbeddingOfSet_apply","module":"Mathlib.Order.OrderIsoNat","initialProofState":"s : Set Nat\ninst✝¹ : Infinite ↑s\ninst✝ : DecidablePred fun x => Membership.mem s x\nn : Nat\n⊢ Eq ((Nat.orderEmbeddingOfSet s) n) ↑(Nat.Subtype.ofNat s n)","decl":"theorem orderEmbeddingOfSet_apply [DecidablePred (· ∈ s)] {n : ℕ} :\n    orderEmbeddingOfSet s n = Subtype.ofNat s n :=\n  rfl\n\n"}
{"name":"Nat.Subtype.orderIsoOfNat_apply","module":"Mathlib.Order.OrderIsoNat","initialProofState":"s : Set Nat\ninst✝ : Infinite ↑s\ndP : DecidablePred fun x => Membership.mem s x\nn : Nat\n⊢ Eq ((Nat.Subtype.orderIsoOfNat s) n) (Nat.Subtype.ofNat s n)","decl":"@[simp]\ntheorem Subtype.orderIsoOfNat_apply [dP : DecidablePred (· ∈ s)] {n : ℕ} :\n    Subtype.orderIsoOfNat s n = Subtype.ofNat s n := by\n  simp [orderIsoOfNat]; congr!\n\n"}
{"name":"Nat.orderEmbeddingOfSet_range","module":"Mathlib.Order.OrderIsoNat","initialProofState":"s : Set Nat\ninst✝¹ : Infinite ↑s\ninst✝ : DecidablePred fun x => Membership.mem s x\n⊢ Eq (Set.range ⇑(Nat.orderEmbeddingOfSet s)) s","decl":"theorem orderEmbeddingOfSet_range [DecidablePred (· ∈ s)] :\n    Set.range (Nat.orderEmbeddingOfSet s) = s :=\n  Subtype.coe_comp_ofNat_range\n\n"}
{"name":"Nat.exists_subseq_of_forall_mem_union","module":"Mathlib.Order.OrderIsoNat","initialProofState":"α : Type u_1\ns t : Set α\ne : Nat → α\nhe : ∀ (n : Nat), Membership.mem (Union.union s t) (e n)\n⊢ Exists fun g => Or (∀ (n : Nat), Membership.mem s (e (g n))) (∀ (n : Nat), Membership.mem t (e (g n)))","decl":"theorem exists_subseq_of_forall_mem_union {s t : Set α} (e : ℕ → α) (he : ∀ n, e n ∈ s ∪ t) :\n    ∃ g : ℕ ↪o ℕ, (∀ n, e (g n) ∈ s) ∨ ∀ n, e (g n) ∈ t := by\n  classical\n    have : Infinite (e ⁻¹' s) ∨ Infinite (e ⁻¹' t) := by\n      simp only [Set.infinite_coe_iff, ← Set.infinite_union, ← Set.preimage_union,\n        Set.eq_univ_of_forall fun n => Set.mem_preimage.2 (he n), Set.infinite_univ]\n    cases this\n    exacts [⟨Nat.orderEmbeddingOfSet (e ⁻¹' s), Or.inl fun n => (Nat.Subtype.ofNat (e ⁻¹' s) _).2⟩,\n      ⟨Nat.orderEmbeddingOfSet (e ⁻¹' t), Or.inr fun n => (Nat.Subtype.ofNat (e ⁻¹' t) _).2⟩]\n\n"}
{"name":"exists_increasing_or_nonincreasing_subseq'","module":"Mathlib.Order.OrderIsoNat","initialProofState":"α : Type u_1\nr : α → α → Prop\nf : Nat → α\n⊢ Exists fun g => Or (∀ (n : Nat), r (f (g n)) (f (g (HAdd.hAdd n 1)))) (∀ (m n : Nat), LT.lt m n → Not (r (f (g m)) (f (g n))))","decl":"theorem exists_increasing_or_nonincreasing_subseq' (r : α → α → Prop) (f : ℕ → α) :\n    ∃ g : ℕ ↪o ℕ,\n      (∀ n : ℕ, r (f (g n)) (f (g (n + 1)))) ∨ ∀ m n : ℕ, m < n → ¬r (f (g m)) (f (g n)) := by\n  classical\n    let bad : Set ℕ := { m | ∀ n, m < n → ¬r (f m) (f n) }\n    by_cases hbad : Infinite bad\n    · haveI := hbad\n      refine ⟨Nat.orderEmbeddingOfSet bad, Or.intro_right _ fun m n mn => ?_⟩\n      have h := @Set.mem_range_self _ _ ↑(Nat.orderEmbeddingOfSet bad) m\n      rw [Nat.orderEmbeddingOfSet_range bad] at h\n      exact h _ ((OrderEmbedding.lt_iff_lt _).2 mn)\n    · rw [Set.infinite_coe_iff, Set.Infinite, not_not] at hbad\n      obtain ⟨m, hm⟩ : ∃ m, ∀ n, m ≤ n → ¬n ∈ bad := by\n        by_cases he : hbad.toFinset.Nonempty\n        · refine\n            ⟨(hbad.toFinset.max' he).succ, fun n hn nbad =>\n              Nat.not_succ_le_self _\n                (hn.trans (hbad.toFinset.le_max' n (hbad.mem_toFinset.2 nbad)))⟩\n        · exact ⟨0, fun n _ nbad => he ⟨n, hbad.mem_toFinset.2 nbad⟩⟩\n      have h : ∀ n : ℕ, ∃ n' : ℕ, n < n' ∧ r (f (n + m)) (f (n' + m)) := by\n        intro n\n        have h := hm _ (Nat.le_add_left m n)\n        simp only [bad, exists_prop, not_not, Set.mem_setOf_eq, not_forall] at h\n        obtain ⟨n', hn1, hn2⟩ := h\n        refine ⟨n + n' - n - m, by omega, ?_⟩\n        convert hn2\n        omega\n      let g' : ℕ → ℕ := @Nat.rec (fun _ => ℕ) m fun n gn => Nat.find (h gn)\n      exact\n        ⟨(RelEmbedding.natLT (fun n => g' n + m) fun n =>\n              Nat.add_lt_add_right (Nat.find_spec (h (g' n))).1 m).orderEmbeddingOfLTEmbedding,\n          Or.intro_left _ fun n => (Nat.find_spec (h (g' n))).2⟩\n\n"}
{"name":"exists_increasing_or_nonincreasing_subseq","module":"Mathlib.Order.OrderIsoNat","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsTrans α r\nf : Nat → α\n⊢ Exists fun g => Or (∀ (m n : Nat), LT.lt m n → r (f (g m)) (f (g n))) (∀ (m n : Nat), LT.lt m n → Not (r (f (g m)) (f (g n))))","decl":"/-- This is the infinitary Erdős–Szekeres theorem, and an important lemma in the usual proof of\n    Bolzano-Weierstrass for `ℝ`. -/\ntheorem exists_increasing_or_nonincreasing_subseq (r : α → α → Prop) [IsTrans α r] (f : ℕ → α) :\n    ∃ g : ℕ ↪o ℕ,\n      (∀ m n : ℕ, m < n → r (f (g m)) (f (g n))) ∨ ∀ m n : ℕ, m < n → ¬r (f (g m)) (f (g n)) := by\n  obtain ⟨g, hr | hnr⟩ := exists_increasing_or_nonincreasing_subseq' r f\n  · refine ⟨g, Or.intro_left _ fun m n mn => ?_⟩\n    obtain ⟨x, rfl⟩ := Nat.exists_eq_add_of_le (Nat.succ_le_iff.2 mn)\n    induction' x with x ih\n    · apply hr\n    · apply IsTrans.trans _ _ _ _ (hr _)\n      exact ih (lt_of_lt_of_le m.lt_succ_self (Nat.le_add_right _ _))\n  · exact ⟨g, Or.intro_right _ hnr⟩\n\n"}
{"name":"WellFounded.monotone_chain_condition'","module":"Mathlib.Order.OrderIsoNat","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Iff (WellFounded fun x1 x2 => GT.gt x1 x2) (∀ (a : OrderHom Nat α), Exists fun n => ∀ (m : Nat), LE.le n m → Not (LT.lt (a n) (a m)))","decl":"theorem WellFounded.monotone_chain_condition' [Preorder α] :\n    WellFounded ((· > ·) : α → α → Prop) ↔ ∀ a : ℕ →o α, ∃ n, ∀ m, n ≤ m → ¬a n < a m := by\n  refine ⟨fun h a => ?_, fun h => ?_⟩\n  · have hne : (Set.range a).Nonempty := ⟨a 0, by simp⟩\n    obtain ⟨x, ⟨n, rfl⟩, H⟩ := h.has_min _ hne\n    exact ⟨n, fun m _ => H _ (Set.mem_range_self _)⟩\n  · refine RelEmbedding.wellFounded_iff_no_descending_seq.2 ⟨fun a => ?_⟩\n    obtain ⟨n, hn⟩ := h (a.swap : ((· < ·) : ℕ → ℕ → Prop) →r ((· < ·) : α → α → Prop)).toOrderHom\n    exact hn n.succ n.lt_succ_self.le ((RelEmbedding.map_rel_iff _).2 n.lt_succ_self)\n\n"}
{"name":"WellFounded.monotone_chain_condition","module":"Mathlib.Order.OrderIsoNat","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ Iff (WellFounded fun x1 x2 => GT.gt x1 x2) (∀ (a : OrderHom Nat α), Exists fun n => ∀ (m : Nat), LE.le n m → Eq (a n) (a m))","decl":"/-- The \"monotone chain condition\" below is sometimes a convenient form of well foundedness. -/\ntheorem WellFounded.monotone_chain_condition [PartialOrder α] :\n    WellFounded ((· > ·) : α → α → Prop) ↔ ∀ a : ℕ →o α, ∃ n, ∀ m, n ≤ m → a n = a m :=\n  WellFounded.monotone_chain_condition'.trans <| by\n  congrm ∀ a, ∃ n, ∀ m h, ?_\n  rw [lt_iff_le_and_ne]\n  simp [a.mono h]\n\n"}
{"name":"WellFounded.iSup_eq_monotonicSequenceLimit","module":"Mathlib.Order.OrderIsoNat","initialProofState":"α : Type u_1\ninst✝ : CompleteLattice α\nh : WellFounded fun x1 x2 => GT.gt x1 x2\na : OrderHom Nat α\n⊢ Eq (iSup ⇑a) (monotonicSequenceLimit a)","decl":"theorem WellFounded.iSup_eq_monotonicSequenceLimit [CompleteLattice α]\n    (h : WellFounded ((· > ·) : α → α → Prop)) (a : ℕ →o α) :\n    iSup a = monotonicSequenceLimit a := by\n  refine (iSup_le fun m => ?_).antisymm (le_iSup a _)\n  rcases le_or_lt m (monotonicSequenceLimitIndex a) with hm | hm\n  · exact a.monotone hm\n  · cases' WellFounded.monotone_chain_condition'.1 h a with n hn\n    have : n ∈ {n | ∀ m, n ≤ m → a n = a m} := fun k hk => (a.mono hk).eq_of_not_lt (hn k hk)\n    exact (Nat.sInf_mem ⟨n, this⟩ m hm.le).ge\n\n"}
{"name":"exists_covBy_seq_of_wellFoundedLT_wellFoundedGT","module":"Mathlib.Order.OrderIsoNat","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Nonempty α\nwfl : WellFoundedLT α\nwfg : WellFoundedGT α\n⊢ Exists fun a => And (IsMin (a 0)) (Exists fun n => And (IsMax (a n)) (∀ (i : Nat), LT.lt i n → CovBy (a i) (a (HAdd.hAdd i 1))))","decl":"theorem exists_covBy_seq_of_wellFoundedLT_wellFoundedGT (α) [Preorder α]\n    [Nonempty α] [wfl : WellFoundedLT α] [wfg : WellFoundedGT α] :\n    ∃ a : ℕ → α, IsMin (a 0) ∧ ∃ n, IsMax (a n) ∧ ∀ i < n, a i ⋖ a (i + 1) := by\n  choose next hnext using exists_covBy_of_wellFoundedLT (α := α)\n  have hα := Set.nonempty_iff_univ_nonempty.mp ‹_›\n  classical\n  let a : ℕ → α := Nat.rec (wfl.wf.min _ hα) fun _n a ↦ if ha : IsMax a then a else next ha\n  refine ⟨a, isMin_iff_forall_not_lt.mpr fun _ ↦ wfl.wf.not_lt_min _ hα trivial, ?_⟩\n  have cov n (hn : ¬ IsMax (a n)) : a n ⋖ a (n + 1) := by\n    change a n ⋖ if ha : IsMax (a n) then a n else _\n    rw [dif_neg hn]\n    exact hnext hn\n  have H : ∃ n, IsMax (a n) := by\n    by_contra!\n    exact (RelEmbedding.natGT a fun n ↦ (cov n (this n)).1).not_wellFounded_of_decreasing_seq wfg.wf\n  exact ⟨_, wellFounded_lt.min_mem _ H, fun i h ↦ cov _ fun h' ↦ wellFounded_lt.not_lt_min _ H h' h⟩\n"}
