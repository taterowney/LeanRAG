{"name":"IsAddQuantale.sSup_add_distrib","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\ninst✝¹ : AddSemigroup α\ninst✝ : CompleteLattice α\nself : IsAddQuantale α\ns : Set α\ny : α\n⊢ Eq (HAdd.hAdd (SupSet.sSup s) y) (iSup fun x => iSup fun h => HAdd.hAdd x y)","decl":"/-- An additive quantale is an additive semigroup distributing over a complete lattice. -/\nclass IsAddQuantale (α : Type*) [AddSemigroup α] [CompleteLattice α] where\n  /-- Addition is distributive over join in a quantale -/\n  protected add_sSup_distrib (x : α) (s : Set α) : x + sSup s = ⨆ y ∈ s, x + y\n  /-- Addition is distributive over join in a quantale -/\n  protected sSup_add_distrib (s : Set α) (y : α) : sSup s + y = ⨆ x ∈ s, x + y\n\n"}
{"name":"IsAddQuantale.add_sSup_distrib","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\ninst✝¹ : AddSemigroup α\ninst✝ : CompleteLattice α\nself : IsAddQuantale α\nx : α\ns : Set α\n⊢ Eq (HAdd.hAdd x (SupSet.sSup s)) (iSup fun y => iSup fun h => HAdd.hAdd x y)","decl":"/-- An additive quantale is an additive semigroup distributing over a complete lattice. -/\nclass IsAddQuantale (α : Type*) [AddSemigroup α] [CompleteLattice α] where\n  /-- Addition is distributive over join in a quantale -/\n  protected add_sSup_distrib (x : α) (s : Set α) : x + sSup s = ⨆ y ∈ s, x + y\n  /-- Addition is distributive over join in a quantale -/\n  protected sSup_add_distrib (s : Set α) (y : α) : sSup s + y = ⨆ x ∈ s, x + y\n\n"}
{"name":"AddQuantale.mk.sizeOf_spec","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\ninst✝³ : AddSemigroup α\ninst✝² : CompleteLattice α\ninst✝¹ : IsAddQuantale α\ninst✝ : SizeOf α\n⊢ Eq (SizeOf.sizeOf { }) 1","decl":"/-- A quantale is a semigroup distributing over a complete lattice. -/\n@[variable_alias]\nstructure AddQuantale (α : Type*)\n  [AddSemigroup α] [CompleteLattice α] [IsAddQuantale α]\n\n"}
{"name":"IsQuantale.mul_sSup_distrib","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\ninst✝¹ : Semigroup α\ninst✝ : CompleteLattice α\nself : IsQuantale α\nx : α\ns : Set α\n⊢ Eq (HMul.hMul x (SupSet.sSup s)) (iSup fun y => iSup fun h => HMul.hMul x y)","decl":"/-- A quantale is a semigroup distributing over a complete lattice. -/\n@[to_additive]\nclass IsQuantale (α : Type*) [Semigroup α] [CompleteLattice α] where\n  /-- Multiplication is distributive over join in a quantale -/\n  protected mul_sSup_distrib (x : α) (s : Set α) : x * sSup s = ⨆ y ∈ s, x * y\n  /-- Multiplication is distributive over join in a quantale -/\n  protected sSup_mul_distrib (s : Set α) (y : α) : sSup s * y = ⨆ x ∈ s, x * y\n\n"}
{"name":"IsQuantale.sSup_mul_distrib","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\ninst✝¹ : Semigroup α\ninst✝ : CompleteLattice α\nself : IsQuantale α\ns : Set α\ny : α\n⊢ Eq (HMul.hMul (SupSet.sSup s) y) (iSup fun x => iSup fun h => HMul.hMul x y)","decl":"/-- A quantale is a semigroup distributing over a complete lattice. -/\n@[to_additive]\nclass IsQuantale (α : Type*) [Semigroup α] [CompleteLattice α] where\n  /-- Multiplication is distributive over join in a quantale -/\n  protected mul_sSup_distrib (x : α) (s : Set α) : x * sSup s = ⨆ y ∈ s, x * y\n  /-- Multiplication is distributive over join in a quantale -/\n  protected sSup_mul_distrib (s : Set α) (y : α) : sSup s * y = ⨆ x ∈ s, x * y\n\n"}
{"name":"Quantale.mk.sizeOf_spec","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\ninst✝³ : Semigroup α\ninst✝² : CompleteLattice α\ninst✝¹ : IsQuantale α\ninst✝ : SizeOf α\n⊢ Eq (SizeOf.sizeOf { }) 1","decl":"/-- A quantale is a semigroup distributing over a complete lattice. -/\n@[variable_alias, to_additive]\nstructure Quantale (α : Type*)\n  [Semigroup α] [CompleteLattice α] [IsQuantale α]\n\n"}
{"name":"mul_sSup_distrib","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\nx : α\ns : Set α\ninst✝² : Semigroup α\ninst✝¹ : CompleteLattice α\ninst✝ : IsQuantale α\n⊢ Eq (HMul.hMul x (SupSet.sSup s)) (iSup fun y => iSup fun h => HMul.hMul x y)","decl":"@[to_additive]\ntheorem mul_sSup_distrib : x * sSup s = ⨆ y ∈ s, x * y := IsQuantale.mul_sSup_distrib _ _\n\n"}
{"name":"add_sSup_distrib","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\nx : α\ns : Set α\ninst✝² : AddSemigroup α\ninst✝¹ : CompleteLattice α\ninst✝ : IsAddQuantale α\n⊢ Eq (HAdd.hAdd x (SupSet.sSup s)) (iSup fun y => iSup fun h => HAdd.hAdd x y)","decl":"@[to_additive]\ntheorem mul_sSup_distrib : x * sSup s = ⨆ y ∈ s, x * y := IsQuantale.mul_sSup_distrib _ _\n\n"}
{"name":"sSup_add_distrib","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\nx : α\ns : Set α\ninst✝² : AddSemigroup α\ninst✝¹ : CompleteLattice α\ninst✝ : IsAddQuantale α\n⊢ Eq (HAdd.hAdd (SupSet.sSup s) x) (iSup fun y => iSup fun h => HAdd.hAdd y x)","decl":"@[to_additive]\ntheorem sSup_mul_distrib : sSup s * x = ⨆ y ∈ s, y * x := IsQuantale.sSup_mul_distrib _ _\n\n"}
{"name":"sSup_mul_distrib","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\nx : α\ns : Set α\ninst✝² : Semigroup α\ninst✝¹ : CompleteLattice α\ninst✝ : IsQuantale α\n⊢ Eq (HMul.hMul (SupSet.sSup s) x) (iSup fun y => iSup fun h => HMul.hMul y x)","decl":"@[to_additive]\ntheorem sSup_mul_distrib : sSup s * x = ⨆ y ∈ s, y * x := IsQuantale.sSup_mul_distrib _ _\n\n"}
{"name":"Quantale.mul_iSup_distrib","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\nι : Type u_2\nx : α\nf : ι → α\ninst✝² : Semigroup α\ninst✝¹ : CompleteLattice α\ninst✝ : IsQuantale α\n⊢ Eq (HMul.hMul x (iSup fun i => f i)) (iSup fun i => HMul.hMul x (f i))","decl":"@[to_additive]\ntheorem mul_iSup_distrib : x * ⨆ i, f i = ⨆ i, x * f i := by\n  rw [iSup, mul_sSup_distrib, iSup_range]\n\n"}
{"name":"AddQuantale.add_iSup_distrib","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\nι : Type u_2\nx : α\nf : ι → α\ninst✝² : AddSemigroup α\ninst✝¹ : CompleteLattice α\ninst✝ : IsAddQuantale α\n⊢ Eq (HAdd.hAdd x (iSup fun i => f i)) (iSup fun i => HAdd.hAdd x (f i))","decl":"@[to_additive]\ntheorem mul_iSup_distrib : x * ⨆ i, f i = ⨆ i, x * f i := by\n  rw [iSup, mul_sSup_distrib, iSup_range]\n\n"}
{"name":"AddQuantale.iSup_add_distrib","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\nι : Type u_2\nx : α\nf : ι → α\ninst✝² : AddSemigroup α\ninst✝¹ : CompleteLattice α\ninst✝ : IsAddQuantale α\n⊢ Eq (HAdd.hAdd (iSup fun i => f i) x) (iSup fun i => HAdd.hAdd (f i) x)","decl":"@[to_additive]\ntheorem iSup_mul_distrib : (⨆ i, f i) * x = ⨆ i, f i * x := by\n  rw [iSup, sSup_mul_distrib, iSup_range]\n\n"}
{"name":"Quantale.iSup_mul_distrib","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\nι : Type u_2\nx : α\nf : ι → α\ninst✝² : Semigroup α\ninst✝¹ : CompleteLattice α\ninst✝ : IsQuantale α\n⊢ Eq (HMul.hMul (iSup fun i => f i) x) (iSup fun i => HMul.hMul (f i) x)","decl":"@[to_additive]\ntheorem iSup_mul_distrib : (⨆ i, f i) * x = ⨆ i, f i * x := by\n  rw [iSup, sSup_mul_distrib, iSup_range]\n\n"}
{"name":"AddQuantale.add_sup_distrib","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\nx y z : α\ninst✝² : AddSemigroup α\ninst✝¹ : CompleteLattice α\ninst✝ : IsAddQuantale α\n⊢ Eq (HAdd.hAdd x (Max.max y z)) (Max.max (HAdd.hAdd x y) (HAdd.hAdd x z))","decl":"@[to_additive]\ntheorem mul_sup_distrib : x * (y ⊔ z) = (x * y) ⊔ (x * z) := by\n  rw [← iSup_pair, ← sSup_pair, mul_sSup_distrib]\n\n"}
{"name":"Quantale.mul_sup_distrib","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\nx y z : α\ninst✝² : Semigroup α\ninst✝¹ : CompleteLattice α\ninst✝ : IsQuantale α\n⊢ Eq (HMul.hMul x (Max.max y z)) (Max.max (HMul.hMul x y) (HMul.hMul x z))","decl":"@[to_additive]\ntheorem mul_sup_distrib : x * (y ⊔ z) = (x * y) ⊔ (x * z) := by\n  rw [← iSup_pair, ← sSup_pair, mul_sSup_distrib]\n\n"}
{"name":"AddQuantale.sup_add_distrib","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\nx y z : α\ninst✝² : AddSemigroup α\ninst✝¹ : CompleteLattice α\ninst✝ : IsAddQuantale α\n⊢ Eq (HAdd.hAdd (Max.max x y) z) (Max.max (HAdd.hAdd x z) (HAdd.hAdd y z))","decl":"@[to_additive]\ntheorem sup_mul_distrib : (x ⊔ y) * z = (x * z) ⊔ (y * z) := by\n  rw [← (@iSup_pair _ _ _ (fun _? => _? * z) _ _), ← sSup_pair, sSup_mul_distrib]\n\n"}
{"name":"Quantale.sup_mul_distrib","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\nx y z : α\ninst✝² : Semigroup α\ninst✝¹ : CompleteLattice α\ninst✝ : IsQuantale α\n⊢ Eq (HMul.hMul (Max.max x y) z) (Max.max (HMul.hMul x z) (HMul.hMul y z))","decl":"@[to_additive]\ntheorem sup_mul_distrib : (x ⊔ y) * z = (x * z) ⊔ (y * z) := by\n  rw [← (@iSup_pair _ _ _ (fun _? => _? * z) _ _), ← sSup_pair, sSup_mul_distrib]\n\n"}
{"name":"AddQuantale.instAddLeftMono","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\ninst✝¹ : AddSemigroup α\ninst✝ : CompleteLattice α\n⊢ AddLeftMono α","decl":"@[to_additive]\ninstance : MulLeftMono α where\n  elim := by\n    intro _ _ _; simp only; intro\n    rwa [← left_eq_sup, ← mul_sup_distrib, sup_of_le_left]\n\n"}
{"name":"Quantale.instMulLeftMono","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\ninst✝¹ : Semigroup α\ninst✝ : CompleteLattice α\n⊢ MulLeftMono α","decl":"@[to_additive]\ninstance : MulLeftMono α where\n  elim := by\n    intro _ _ _; simp only; intro\n    rwa [← left_eq_sup, ← mul_sup_distrib, sup_of_le_left]\n\n"}
{"name":"AddQuantale.instAddRightMono","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\ninst✝¹ : AddSemigroup α\ninst✝ : CompleteLattice α\n⊢ AddRightMono α","decl":"@[to_additive]\ninstance : MulRightMono α where\n  elim := by\n    intro _ _ _; simp only; intro\n    rwa [← left_eq_sup, ← sup_mul_distrib, sup_of_le_left]\n\n"}
{"name":"Quantale.instMulRightMono","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\ninst✝¹ : Semigroup α\ninst✝ : CompleteLattice α\n⊢ MulRightMono α","decl":"@[to_additive]\ninstance : MulRightMono α where\n  elim := by\n    intro _ _ _; simp only; intro\n    rwa [← left_eq_sup, ← sup_mul_distrib, sup_of_le_left]\n\n"}
{"name":"Quantale.leftMulResiduation_le_iff_mul_le","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\nx y z : α\ninst✝² : Semigroup α\ninst✝¹ : CompleteLattice α\ninst✝ : IsQuantale α\n⊢ Iff (LE.le x (Quantale.leftMulResiduation y z)) (LE.le (HMul.hMul x y) z)","decl":"@[to_additive]\ntheorem leftMulResiduation_le_iff_mul_le : x ≤ y ⇨ₗ z ↔ x * y ≤ z where\n  mp h1 := by\n    apply le_trans (mul_le_mul_right' h1 _)\n    simp_all only [leftMulResiduation, sSup_mul_distrib, Set.mem_setOf_eq,\n      iSup_le_iff, implies_true]\n  mpr h1 := le_sSup h1\n\n"}
{"name":"AddQuantale.leftAddResiduation_le_iff_add_le","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\nx y z : α\ninst✝² : AddSemigroup α\ninst✝¹ : CompleteLattice α\ninst✝ : IsAddQuantale α\n⊢ Iff (LE.le x (AddQuantale.leftAddResiduation y z)) (LE.le (HAdd.hAdd x y) z)","decl":"@[to_additive]\ntheorem leftMulResiduation_le_iff_mul_le : x ≤ y ⇨ₗ z ↔ x * y ≤ z where\n  mp h1 := by\n    apply le_trans (mul_le_mul_right' h1 _)\n    simp_all only [leftMulResiduation, sSup_mul_distrib, Set.mem_setOf_eq,\n      iSup_le_iff, implies_true]\n  mpr h1 := le_sSup h1\n\n"}
{"name":"AddQuantale.rightAddResiduation_le_iff_add_le","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\nx y z : α\ninst✝² : AddSemigroup α\ninst✝¹ : CompleteLattice α\ninst✝ : IsAddQuantale α\n⊢ Iff (LE.le x (AddQuantale.rightAddResiduation y z)) (LE.le (HAdd.hAdd y x) z)","decl":"@[to_additive]\ntheorem rightMulResiduation_le_iff_mul_le : x ≤ y ⇨ᵣ z ↔ y * x ≤ z where\n  mp h1 := by\n    apply le_trans (mul_le_mul_left' h1 _)\n    simp_all only [rightMulResiduation, mul_sSup_distrib, Set.mem_setOf_eq,\n      iSup_le_iff, implies_true]\n  mpr h1 := le_sSup h1\n\n"}
{"name":"Quantale.rightMulResiduation_le_iff_mul_le","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_1\nx y z : α\ninst✝² : Semigroup α\ninst✝¹ : CompleteLattice α\ninst✝ : IsQuantale α\n⊢ Iff (LE.le x (Quantale.rightMulResiduation y z)) (LE.le (HMul.hMul y x) z)","decl":"@[to_additive]\ntheorem rightMulResiduation_le_iff_mul_le : x ≤ y ⇨ᵣ z ↔ y * x ≤ z where\n  mp h1 := by\n    apply le_trans (mul_le_mul_left' h1 _)\n    simp_all only [rightMulResiduation, mul_sSup_distrib, Set.mem_setOf_eq,\n      iSup_le_iff, implies_true]\n  mpr h1 := le_sSup h1\n\n"}
{"name":"Quantale.bot_mul","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_3\ninst✝² : Semigroup α\ninst✝¹ : CompleteLattice α\ninst✝ : IsQuantale α\nx : α\n⊢ Eq (HMul.hMul Bot.bot x) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem bot_mul : ⊥ * x = ⊥ := by\n  rw [← sSup_empty, sSup_mul_distrib]\n  simp only [Set.mem_empty_iff_false, not_false_eq_true, iSup_neg, iSup_bot, sSup_empty]\n\n"}
{"name":"AddQuantale.bot_add","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_3\ninst✝² : AddSemigroup α\ninst✝¹ : CompleteLattice α\ninst✝ : IsAddQuantale α\nx : α\n⊢ Eq (HAdd.hAdd Bot.bot x) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem bot_mul : ⊥ * x = ⊥ := by\n  rw [← sSup_empty, sSup_mul_distrib]\n  simp only [Set.mem_empty_iff_false, not_false_eq_true, iSup_neg, iSup_bot, sSup_empty]\n\n"}
{"name":"AddQuantale.add_bot","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_3\ninst✝² : AddSemigroup α\ninst✝¹ : CompleteLattice α\ninst✝ : IsAddQuantale α\nx : α\n⊢ Eq (HAdd.hAdd x Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem mul_bot : x * ⊥ = ⊥ := by\n  rw [← sSup_empty, mul_sSup_distrib]\n  simp only [Set.mem_empty_iff_false, not_false_eq_true, iSup_neg, iSup_bot, sSup_empty]\n\n"}
{"name":"Quantale.mul_bot","module":"Mathlib.Algebra.Order.Quantale","initialProofState":"α : Type u_3\ninst✝² : Semigroup α\ninst✝¹ : CompleteLattice α\ninst✝ : IsQuantale α\nx : α\n⊢ Eq (HMul.hMul x Bot.bot) Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem mul_bot : x * ⊥ = ⊥ := by\n  rw [← sSup_empty, mul_sSup_distrib]\n  simp only [Set.mem_empty_iff_false, not_false_eq_true, iSup_neg, iSup_bot, sSup_empty]\n\n"}
