{"name":"mk_eq_mk_of_basis","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nι : Type w\nι' : Type w'\ninst✝ : InvariantBasisNumber R\nv : Basis ι R M\nv' : Basis ι' R M\n⊢ Eq (Cardinal.lift.{w', w} (Cardinal.mk ι)) (Cardinal.lift.{w, w'} (Cardinal.mk ι'))","decl":"/-- The dimension theorem: if `v` and `v'` are two bases, their index types\nhave the same cardinalities. -/\ntheorem mk_eq_mk_of_basis (v : Basis ι R M) (v' : Basis ι' R M) :\n    Cardinal.lift.{w'} #ι = Cardinal.lift.{w} #ι' := by\n  classical\n  haveI := nontrivial_of_invariantBasisNumber R\n  cases fintypeOrInfinite ι\n  · -- `v` is a finite basis, so by `basis_finite_of_finite_spans` so is `v'`.\n    -- haveI : Finite (range v) := Set.finite_range v\n    haveI := basis_finite_of_finite_spans _ (Set.finite_range v) v.span_eq v'\n    cases nonempty_fintype ι'\n    -- We clean up a little:\n    rw [Cardinal.mk_fintype, Cardinal.mk_fintype]\n    simp only [Cardinal.lift_natCast, Nat.cast_inj]\n    -- Now we can use invariant basis number to show they have the same cardinality.\n    apply card_eq_of_linearEquiv R\n    exact\n      (Finsupp.linearEquivFunOnFinite R R ι).symm.trans v.repr.symm ≪≫ₗ v'.repr ≪≫ₗ\n        Finsupp.linearEquivFunOnFinite R R ι'\n  · -- `v` is an infinite basis,\n    -- so by `infinite_basis_le_maximal_linearIndependent`, `v'` is at least as big,\n    -- and then applying `infinite_basis_le_maximal_linearIndependent` again\n    -- we see they have the same cardinality.\n    have w₁ := infinite_basis_le_maximal_linearIndependent' v _ v'.linearIndependent v'.maximal\n    rcases Cardinal.lift_mk_le'.mp w₁ with ⟨f⟩\n    haveI : Infinite ι' := Infinite.of_injective f f.2\n    have w₂ := infinite_basis_le_maximal_linearIndependent' v' _ v.linearIndependent v.maximal\n    exact le_antisymm w₁ w₂\n\n"}
{"name":"mk_eq_mk_of_basis'","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nι : Type w\ninst✝ : InvariantBasisNumber R\nι' : Type w\nv : Basis ι R M\nv' : Basis ι' R M\n⊢ Eq (Cardinal.mk ι) (Cardinal.mk ι')","decl":"theorem mk_eq_mk_of_basis' {ι' : Type w} (v : Basis ι R M) (v' : Basis ι' R M) : #ι = #ι' :=\n  Cardinal.lift_inj.1 <| mk_eq_mk_of_basis v v'\n\n"}
{"name":"Basis.le_span''","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : RankCondition R\nι : Type u_1\ninst✝¹ : Fintype ι\nb : Basis ι R M\nw : Set M\ninst✝ : Fintype ↑w\ns : Eq (Submodule.span R w) Top.top\n⊢ LE.le (Fintype.card ι) (Fintype.card ↑w)","decl":"/-- An auxiliary lemma for `Basis.le_span`.\n\nIf `R` satisfies the rank condition,\nthen for any finite basis `b : Basis ι R M`,\nand any finite spanning set `w : Set M`,\nthe cardinality of `ι` is bounded by the cardinality of `w`.\n-/\ntheorem Basis.le_span'' {ι : Type*} [Fintype ι] (b : Basis ι R M) {w : Set M} [Fintype w]\n    (s : span R w = ⊤) : Fintype.card ι ≤ Fintype.card w := by\n  -- We construct a surjective linear map `(w → R) →ₗ[R] (ι → R)`,\n  -- by expressing a linear combination in `w` as a linear combination in `ι`.\n  fapply card_le_of_surjective' R\n  · exact b.repr.toLinearMap.comp (Finsupp.linearCombination R (↑))\n  · apply Surjective.comp (g := b.repr.toLinearMap)\n    · apply LinearEquiv.surjective\n    rw [← LinearMap.range_eq_top, Finsupp.range_linearCombination]\n    simpa using s\n\n"}
{"name":"basis_le_span'","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : RankCondition R\nι : Type u_1\nb : Basis ι R M\nw : Set M\ninst✝ : Fintype ↑w\ns : Eq (Submodule.span R w) Top.top\n⊢ LE.le (Cardinal.mk ι) ↑(Fintype.card ↑w)","decl":"/--\nAnother auxiliary lemma for `Basis.le_span`, which does not require assuming the basis is finite,\nbut still assumes we have a finite spanning set.\n-/\ntheorem basis_le_span' {ι : Type*} (b : Basis ι R M) {w : Set M} [Fintype w] (s : span R w = ⊤) :\n    #ι ≤ Fintype.card w := by\n  haveI := nontrivial_of_invariantBasisNumber R\n  haveI := basis_finite_of_finite_spans w (toFinite _) s b\n  cases nonempty_fintype ι\n  rw [Cardinal.mk_fintype ι]\n  simp only [Nat.cast_le]\n  exact Basis.le_span'' b s\n\n-- Note that if `R` satisfies the strong rank condition,\n-- this also follows from `linearIndependent_le_span` below.\n"}
{"name":"Basis.le_span","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nι : Type w\ninst✝ : RankCondition R\nJ : Set M\nv : Basis ι R M\nhJ : Eq (Submodule.span R J) Top.top\n⊢ LE.le (Cardinal.mk ↑(Set.range ⇑v)) (Cardinal.mk ↑J)","decl":"/-- If `R` satisfies the rank condition,\nthen the cardinality of any basis is bounded by the cardinality of any spanning set.\n-/\ntheorem Basis.le_span {J : Set M} (v : Basis ι R M) (hJ : span R J = ⊤) : #(range v) ≤ #J := by\n  haveI := nontrivial_of_invariantBasisNumber R\n  cases fintypeOrInfinite J\n  · rw [← Cardinal.lift_le, Cardinal.mk_range_eq_of_injective v.injective, Cardinal.mk_fintype J]\n    convert Cardinal.lift_le.{v}.2 (basis_le_span' v hJ)\n    simp\n  · let S : J → Set ι := fun j => ↑(v.repr j).support\n    let S' : J → Set M := fun j => v '' S j\n    have hs : range v ⊆ ⋃ j, S' j := by\n      intro b hb\n      rcases mem_range.1 hb with ⟨i, hi⟩\n      have : span R J ≤ comap v.repr.toLinearMap (Finsupp.supported R R (⋃ j, S j)) :=\n        span_le.2 fun j hj x hx => ⟨_, ⟨⟨j, hj⟩, rfl⟩, hx⟩\n      rw [hJ] at this\n      replace : v.repr (v i) ∈ Finsupp.supported R R (⋃ j, S j) := this trivial\n      rw [v.repr_self, Finsupp.mem_supported, Finsupp.support_single_ne_zero _ one_ne_zero] at this\n      · subst b\n        rcases mem_iUnion.1 (this (Finset.mem_singleton_self _)) with ⟨j, hj⟩\n        exact mem_iUnion.2 ⟨j, (mem_image _ _ _).2 ⟨i, hj, rfl⟩⟩\n    refine le_of_not_lt fun IJ => ?_\n    suffices #(⋃ j, S' j) < #(range v) by exact not_le_of_lt this ⟨Set.embeddingOfSubset _ _ hs⟩\n    refine lt_of_le_of_lt (le_trans Cardinal.mk_iUnion_le_sum_mk\n      (Cardinal.sum_le_sum _ (fun _ => ℵ₀) ?_)) ?_\n    · exact fun j => (Cardinal.lt_aleph0_of_finite _).le\n    · simpa\n\n"}
{"name":"linearIndependent_le_span_aux'","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : StrongRankCondition R\nι : Type u_1\ninst✝¹ : Fintype ι\nv : ι → M\ni : LinearIndependent R v\nw : Set M\ninst✝ : Fintype ↑w\ns : LE.le (Set.range v) ↑(Submodule.span R w)\n⊢ LE.le (Fintype.card ι) (Fintype.card ↑w)","decl":"theorem linearIndependent_le_span_aux' {ι : Type*} [Fintype ι] (v : ι → M)\n    (i : LinearIndependent R v) (w : Set M) [Fintype w] (s : range v ≤ span R w) :\n    Fintype.card ι ≤ Fintype.card w := by\n  -- We construct an injective linear map `(ι → R) →ₗ[R] (w → R)`,\n  -- by thinking of `f : ι → R` as a linear combination of the finite family `v`,\n  -- and expressing that (using the axiom of choice) as a linear combination over `w`.\n  -- We can do this linearly by constructing the map on a basis.\n  fapply card_le_of_injective' R\n  · apply Finsupp.linearCombination\n    exact fun i => Span.repr R w ⟨v i, s (mem_range_self i)⟩\n  · intro f g h\n    apply_fun linearCombination R ((↑) : w → M) at h\n    simp only [linearCombination_linearCombination, Submodule.coe_mk,\n               Span.finsupp_linearCombination_repr] at h\n    exact i h\n\n"}
{"name":"LinearIndependent.finite_of_le_span_finite","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\nι : Type u_1\nv : ι → M\ni : LinearIndependent R v\nw : Set M\ninst✝ : Finite ↑w\ns : LE.le (Set.range v) ↑(Submodule.span R w)\n⊢ Finite ι","decl":"/-- If `R` satisfies the strong rank condition,\nthen any linearly independent family `v : ι → M`\ncontained in the span of some finite `w : Set M`,\nis itself finite.\n-/\nlemma LinearIndependent.finite_of_le_span_finite {ι : Type*} (v : ι → M) (i : LinearIndependent R v)\n    (w : Set M) [Finite w] (s : range v ≤ span R w) : Finite ι :=\n  letI := Fintype.ofFinite w\n  Fintype.finite <| fintypeOfFinsetCardLe (Fintype.card w) fun t => by\n    let v' := fun x : (t : Set ι) => v x\n    have i' : LinearIndependent R v' := i.comp _ Subtype.val_injective\n    have s' : range v' ≤ span R w := (range_comp_subset_range _ _).trans s\n    simpa using linearIndependent_le_span_aux' v' i' w s'\n\n"}
{"name":"linearIndependent_le_span'","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\nι : Type u_1\nv : ι → M\ni : LinearIndependent R v\nw : Set M\ninst✝ : Fintype ↑w\ns : LE.le (Set.range v) ↑(Submodule.span R w)\n⊢ LE.le (Cardinal.mk ι) ↑(Fintype.card ↑w)","decl":"/-- If `R` satisfies the strong rank condition,\nthen for any linearly independent family `v : ι → M`\ncontained in the span of some finite `w : Set M`,\nthe cardinality of `ι` is bounded by the cardinality of `w`.\n-/\ntheorem linearIndependent_le_span' {ι : Type*} (v : ι → M) (i : LinearIndependent R v) (w : Set M)\n    [Fintype w] (s : range v ≤ span R w) : #ι ≤ Fintype.card w := by\n  haveI : Finite ι := i.finite_of_le_span_finite v w s\n  letI := Fintype.ofFinite ι\n  rw [Cardinal.mk_fintype]\n  simp only [Nat.cast_le]\n  exact linearIndependent_le_span_aux' v i w s\n\n"}
{"name":"linearIndependent_le_span","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\nι : Type u_1\nv : ι → M\ni : LinearIndependent R v\nw : Set M\ninst✝ : Fintype ↑w\ns : Eq (Submodule.span R w) Top.top\n⊢ LE.le (Cardinal.mk ι) ↑(Fintype.card ↑w)","decl":"/-- If `R` satisfies the strong rank condition,\nthen for any linearly independent family `v : ι → M`\nand any finite spanning set `w : Set M`,\nthe cardinality of `ι` is bounded by the cardinality of `w`.\n-/\ntheorem linearIndependent_le_span {ι : Type*} (v : ι → M) (i : LinearIndependent R v) (w : Set M)\n    [Fintype w] (s : span R w = ⊤) : #ι ≤ Fintype.card w := by\n  apply linearIndependent_le_span' v i w\n  rw [s]\n  exact le_top\n\n"}
{"name":"linearIndependent_le_span_finset","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : StrongRankCondition R\nι : Type u_1\nv : ι → M\ni : LinearIndependent R v\nw : Finset M\ns : Eq (Submodule.span R ↑w) Top.top\n⊢ LE.le (Cardinal.mk ι) ↑w.card","decl":"/-- A version of `linearIndependent_le_span` for `Finset`. -/\ntheorem linearIndependent_le_span_finset {ι : Type*} (v : ι → M) (i : LinearIndependent R v)\n    (w : Finset M) (s : span R (w : Set M) = ⊤) : #ι ≤ w.card := by\n  simpa only [Finset.coe_sort_coe, Fintype.card_coe] using linearIndependent_le_span v i w s\n\n"}
{"name":"linearIndependent_le_infinite_basis","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\nι : Type w\nb : Basis ι R M\ninst✝ : Infinite ι\nκ : Type w\nv : κ → M\ni : LinearIndependent R v\n⊢ LE.le (Cardinal.mk κ) (Cardinal.mk ι)","decl":"/-- An auxiliary lemma for `linearIndependent_le_basis`:\nwe handle the case where the basis `b` is infinite.\n-/\ntheorem linearIndependent_le_infinite_basis {ι : Type w} (b : Basis ι R M) [Infinite ι] {κ : Type w}\n    (v : κ → M) (i : LinearIndependent R v) : #κ ≤ #ι := by\n  classical\n  by_contra h\n  rw [not_le, ← Cardinal.mk_finset_of_infinite ι] at h\n  let Φ := fun k : κ => (b.repr (v k)).support\n  obtain ⟨s, w : Infinite ↑(Φ ⁻¹' {s})⟩ := Cardinal.exists_infinite_fiber Φ h (by infer_instance)\n  let v' := fun k : Φ ⁻¹' {s} => v k\n  have i' : LinearIndependent R v' := i.comp _ Subtype.val_injective\n  have w' : Finite (Φ ⁻¹' {s}) := by\n    apply i'.finite_of_le_span_finite v' (s.image b)\n    rintro m ⟨⟨p, ⟨rfl⟩⟩, rfl⟩\n    simp only [SetLike.mem_coe, Subtype.coe_mk, Finset.coe_image]\n    apply Basis.mem_span_repr_support\n  exact w.false\n\n"}
{"name":"linearIndependent_le_basis","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : StrongRankCondition R\nι : Type w\nb : Basis ι R M\nκ : Type w\nv : κ → M\ni : LinearIndependent R v\n⊢ LE.le (Cardinal.mk κ) (Cardinal.mk ι)","decl":"/-- Over any ring `R` satisfying the strong rank condition,\nif `b` is a basis for a module `M`,\nand `s` is a linearly independent set,\nthen the cardinality of `s` is bounded by the cardinality of `b`.\n-/\ntheorem linearIndependent_le_basis {ι : Type w} (b : Basis ι R M) {κ : Type w} (v : κ → M)\n    (i : LinearIndependent R v) : #κ ≤ #ι := by\n  classical\n  -- We split into cases depending on whether `ι` is infinite.\n  cases fintypeOrInfinite ι\n  · rw [Cardinal.mk_fintype ι] -- When `ι` is finite, we have `linearIndependent_le_span`,\n    haveI : Nontrivial R := nontrivial_of_invariantBasisNumber R\n    rw [Fintype.card_congr (Equiv.ofInjective b b.injective)]\n    exact linearIndependent_le_span v i (range b) b.span_eq\n  · -- and otherwise we have `linearIndependent_le_infinite_basis`.\n    exact linearIndependent_le_infinite_basis b v i\n\n"}
{"name":"Basis.card_le_card_of_linearIndependent_aux","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : StrongRankCondition R\nn m : Nat\nv : Fin m → Fin n → R\na✝ : LinearIndependent R v\n⊢ LE.le m n","decl":"/-- Let `R` satisfy the strong rank condition. If `m` elements of a free rank `n` `R`-module are\nlinearly independent, then `m ≤ n`. -/\ntheorem Basis.card_le_card_of_linearIndependent_aux {R : Type*} [Ring R] [StrongRankCondition R]\n    (n : ℕ) {m : ℕ} (v : Fin m → Fin n → R) : LinearIndependent R v → m ≤ n := fun h => by\n  simpa using linearIndependent_le_basis (Pi.basisFun R (Fin n)) v h\n\n-- When the basis is not infinite this need not be true!\n"}
{"name":"maximal_linearIndependent_eq_infinite_basis","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\nι : Type w\nb : Basis ι R M\ninst✝ : Infinite ι\nκ : Type w\nv : κ → M\ni : LinearIndependent R v\nm : i.Maximal\n⊢ Eq (Cardinal.mk κ) (Cardinal.mk ι)","decl":"/-- Over any ring `R` satisfying the strong rank condition,\nif `b` is an infinite basis for a module `M`,\nthen every maximal linearly independent set has the same cardinality as `b`.\n\nThis proof (along with some of the lemmas above) comes from\n[Les familles libres maximales d'un module ont-elles le meme cardinal?][lazarus1973]\n-/\ntheorem maximal_linearIndependent_eq_infinite_basis {ι : Type w} (b : Basis ι R M) [Infinite ι]\n    {κ : Type w} (v : κ → M) (i : LinearIndependent R v) (m : i.Maximal) : #κ = #ι := by\n  apply le_antisymm\n  · exact linearIndependent_le_basis b v i\n  · haveI : Nontrivial R := nontrivial_of_invariantBasisNumber R\n    exact infinite_basis_le_maximal_linearIndependent b v i m\n\n"}
{"name":"Basis.mk_eq_rank''","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : StrongRankCondition R\nι : Type v\nv : Basis ι R M\n⊢ Eq (Cardinal.mk ι) (Module.rank R M)","decl":"theorem Basis.mk_eq_rank'' {ι : Type v} (v : Basis ι R M) : #ι = Module.rank R M := by\n  haveI := nontrivial_of_invariantBasisNumber R\n  rw [Module.rank_def]\n  apply le_antisymm\n  · trans\n    swap\n    · apply le_ciSup (Cardinal.bddAbove_range _)\n      exact\n        ⟨Set.range v, by\n          convert v.reindexRange.linearIndependent\n          ext\n          simp⟩\n    · exact (Cardinal.mk_range_eq v v.injective).ge\n  · apply ciSup_le'\n    rintro ⟨s, li⟩\n    apply linearIndependent_le_basis v _ li\n\n"}
{"name":"Basis.mk_range_eq_rank","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nι : Type w\ninst✝ : StrongRankCondition R\nv : Basis ι R M\n⊢ Eq (Cardinal.mk ↑(Set.range ⇑v)) (Module.rank R M)","decl":"theorem Basis.mk_range_eq_rank (v : Basis ι R M) : #(range v) = Module.rank R M :=\n  v.reindexRange.mk_eq_rank''\n\n"}
{"name":"rank_eq_card_basis","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\nι : Type w\ninst✝ : Fintype ι\nh : Basis ι R M\n⊢ Eq (Module.rank R M) ↑(Fintype.card ι)","decl":"/-- If a vector space has a finite basis, then its dimension (seen as a cardinal) is equal to the\ncardinality of the basis. -/\ntheorem rank_eq_card_basis {ι : Type w} [Fintype ι] (h : Basis ι R M) :\n    Module.rank R M = Fintype.card ι := by\n  classical\n  haveI := nontrivial_of_invariantBasisNumber R\n  rw [← h.mk_range_eq_rank, Cardinal.mk_fintype, Set.card_range_of_injective h.injective]\n\n"}
{"name":"Basis.card_le_card_of_linearIndependent","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : StrongRankCondition R\nι : Type u_1\ninst✝¹ : Fintype ι\nb : Basis ι R M\nι' : Type u_2\ninst✝ : Fintype ι'\nv : ι' → M\nhv : LinearIndependent R v\n⊢ LE.le (Fintype.card ι') (Fintype.card ι)","decl":"theorem Basis.card_le_card_of_linearIndependent {ι : Type*} [Fintype ι] (b : Basis ι R M)\n    {ι' : Type*} [Fintype ι'] {v : ι' → M} (hv : LinearIndependent R v) :\n    Fintype.card ι' ≤ Fintype.card ι := by\n  letI := nontrivial_of_invariantBasisNumber R\n  simpa [rank_eq_card_basis b, Cardinal.mk_fintype] using hv.cardinal_lift_le_rank\n\n"}
{"name":"Basis.card_le_card_of_submodule","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nι : Type w\nι' : Type w'\ninst✝² : StrongRankCondition R\nN : Submodule R M\ninst✝¹ : Fintype ι\nb : Basis ι R M\ninst✝ : Fintype ι'\nb' : Basis ι' R (Subtype fun x => Membership.mem N x)\n⊢ LE.le (Fintype.card ι') (Fintype.card ι)","decl":"theorem Basis.card_le_card_of_submodule (N : Submodule R M) [Fintype ι] (b : Basis ι R M)\n    [Fintype ι'] (b' : Basis ι' R N) : Fintype.card ι' ≤ Fintype.card ι :=\n  b.card_le_card_of_linearIndependent\n    (b'.linearIndependent.map_injOn N.subtype N.injective_subtype.injOn)\n\n"}
{"name":"Basis.card_le_card_of_le","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nι : Type w\nι' : Type w'\ninst✝² : StrongRankCondition R\nN O : Submodule R M\nhNO : LE.le N O\ninst✝¹ : Fintype ι\nb : Basis ι R (Subtype fun x => Membership.mem O x)\ninst✝ : Fintype ι'\nb' : Basis ι' R (Subtype fun x => Membership.mem N x)\n⊢ LE.le (Fintype.card ι') (Fintype.card ι)","decl":"theorem Basis.card_le_card_of_le {N O : Submodule R M} (hNO : N ≤ O) [Fintype ι] (b : Basis ι R O)\n    [Fintype ι'] (b' : Basis ι' R N) : Fintype.card ι' ≤ Fintype.card ι :=\n  b.card_le_card_of_linearIndependent\n    (b'.linearIndependent.map_injOn (inclusion hNO) (N.inclusion_injective _).injOn)\n\n"}
{"name":"Basis.mk_eq_rank","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nι : Type w\ninst✝ : StrongRankCondition R\nv : Basis ι R M\n⊢ Eq (Cardinal.lift.{v, w} (Cardinal.mk ι)) (Cardinal.lift.{w, v} (Module.rank R M))","decl":"theorem Basis.mk_eq_rank (v : Basis ι R M) :\n    Cardinal.lift.{v} #ι = Cardinal.lift.{w} (Module.rank R M) := by\n  haveI := nontrivial_of_invariantBasisNumber R\n  rw [← v.mk_range_eq_rank, Cardinal.mk_range_eq_of_injective v.injective]\n\n"}
{"name":"Basis.mk_eq_rank'","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nι : Type w\ninst✝ : StrongRankCondition R\nv : Basis ι R M\n⊢ Eq (Cardinal.lift.{max v m, w} (Cardinal.mk ι)) (Cardinal.lift.{max w m, v} (Module.rank R M))","decl":"theorem Basis.mk_eq_rank'.{m} (v : Basis ι R M) :\n    Cardinal.lift.{max v m} #ι = Cardinal.lift.{max w m} (Module.rank R M) :=\n  Cardinal.lift_umax_eq.{w, v, m}.mpr v.mk_eq_rank\n\n"}
{"name":"rank_span","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nι : Type w\ninst✝ : StrongRankCondition R\nv : ι → M\nhv : LinearIndependent R v\n⊢ Eq (Module.rank R (Subtype fun x => Membership.mem (Submodule.span R (Set.range v)) x)) (Cardinal.mk ↑(Set.range v))","decl":"theorem rank_span {v : ι → M} (hv : LinearIndependent R v) :\n    Module.rank R ↑(span R (range v)) = #(range v) := by\n  haveI := nontrivial_of_invariantBasisNumber R\n  rw [← Cardinal.lift_inj, ← (Basis.span hv).mk_eq_rank,\n    Cardinal.mk_range_eq_of_injective (@LinearIndependent.injective ι R M v _ _ _ _ hv)]\n\n"}
{"name":"rank_span_set","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : StrongRankCondition R\ns : Set M\nhs : LinearIndependent R fun x => ↑x\n⊢ Eq (Module.rank R (Subtype fun x => Membership.mem (Submodule.span R s) x)) (Cardinal.mk ↑s)","decl":"theorem rank_span_set {s : Set M} (hs : LinearIndependent R (fun x => x : s → M)) :\n    Module.rank R ↑(span R s) = #s := by\n  rw [← @setOf_mem_eq _ s, ← Subtype.range_coe_subtype]\n  exact rank_span hs\n\n"}
{"name":"Ideal.rank_eq","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : StrongRankCondition R\ninst✝⁴ : Ring S\ninst✝³ : IsDomain S\ninst✝² : Algebra R S\nn : Type u_3\nm : Type u_4\ninst✝¹ : Fintype n\ninst✝ : Fintype m\nb : Basis n R S\nI : Ideal S\nhI : Ne I Bot.bot\nc : Basis m R (Subtype fun x => Membership.mem I x)\n⊢ Eq (Fintype.card m) (Fintype.card n)","decl":"/-- If `S` a module-finite free `R`-algebra, then the `R`-rank of a nonzero `R`-free\nideal `I` of `S` is the same as the rank of `S`. -/\ntheorem Ideal.rank_eq {R S : Type*} [CommRing R] [StrongRankCondition R] [Ring S] [IsDomain S]\n    [Algebra R S] {n m : Type*} [Fintype n] [Fintype m] (b : Basis n R S) {I : Ideal S}\n    (hI : I ≠ ⊥) (c : Basis m R I) : Fintype.card m = Fintype.card n := by\n  obtain ⟨a, ha⟩ := Submodule.nonzero_mem_of_bot_lt (bot_lt_iff_ne_bot.mpr hI)\n  have : LinearIndependent R fun i => b i • a := by\n    have hb := b.linearIndependent\n    rw [Fintype.linearIndependent_iff] at hb ⊢\n    intro g hg\n    apply hb g\n    simp only [← smul_assoc, ← Finset.sum_smul, smul_eq_zero] at hg\n    exact hg.resolve_right ha\n  exact le_antisymm\n    (b.card_le_card_of_linearIndependent (c.linearIndependent.map' (Submodule.subtype I)\n      ((LinearMap.ker_eq_bot (f := (Submodule.subtype I : I →ₗ[R] S))).mpr Subtype.coe_injective)))\n    (c.card_le_card_of_linearIndependent this)\n\n"}
{"name":"Module.finrank_eq_nat_card_basis","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nι : Type w\ninst✝ : StrongRankCondition R\nh : Basis ι R M\n⊢ Eq (Module.finrank R M) (Nat.card ι)","decl":"theorem finrank_eq_nat_card_basis (h : Basis ι R M) :\n    finrank R M = Nat.card ι := by\n  rw [Nat.card, ← toNat_lift.{v}, h.mk_eq_rank, toNat_lift, finrank]\n\n"}
{"name":"Module.finrank_eq_card_basis","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\nι : Type w\ninst✝ : Fintype ι\nh : Basis ι R M\n⊢ Eq (Module.finrank R M) (Fintype.card ι)","decl":"/-- If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\ncardinality of the basis. -/\ntheorem finrank_eq_card_basis {ι : Type w} [Fintype ι] (h : Basis ι R M) :\n    finrank R M = Fintype.card ι :=\n  finrank_eq_of_rank_eq (rank_eq_card_basis h)\n\n"}
{"name":"Module.mk_finrank_eq_card_basis","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\ninst✝ : Module.Finite R M\nι : Type w\nh : Basis ι R M\n⊢ Eq (↑(Module.finrank R M)) (Cardinal.mk ι)","decl":"/-- If a free module is of finite rank, then the cardinality of any basis is equal to its\n`finrank`. -/\ntheorem mk_finrank_eq_card_basis [Module.Finite R M] {ι : Type w} (h : Basis ι R M) :\n    (finrank R M : Cardinal.{w}) = #ι := by\n  cases @nonempty_fintype _ (Module.Finite.finite_basis h)\n  rw [Cardinal.mk_fintype, finrank_eq_card_basis h]\n\n"}
{"name":"Module.finrank_eq_card_finset_basis","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : StrongRankCondition R\nι : Type w\nb : Finset ι\nh : Basis (Subtype fun x => Membership.mem b x) R M\n⊢ Eq (Module.finrank R M) b.card","decl":"/-- If a vector space (or module) has a finite basis, then its dimension (or rank) is equal to the\ncardinality of the basis. This lemma uses a `Finset` instead of indexed types. -/\ntheorem finrank_eq_card_finset_basis {ι : Type w} {b : Finset ι} (h : Basis b R M) :\n    finrank R M = Finset.card b := by rw [finrank_eq_card_basis h, Fintype.card_coe]\n\n"}
{"name":"Module.rank_self","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : StrongRankCondition R\n⊢ Eq (Module.rank R R) 1","decl":"@[simp]\ntheorem rank_self : Module.rank R R = 1 := by\n  rw [← Cardinal.lift_inj, ← (Basis.singleton PUnit R).mk_eq_rank, Cardinal.mk_punit]\n\n"}
{"name":"Module.finrank_self","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\ninst✝¹ : Semiring R\ninst✝ : StrongRankCondition R\n⊢ Eq (Module.finrank R R) 1","decl":"/-- A ring satisfying `StrongRankCondition` (such as a `DivisionRing`) is one-dimensional as a\nmodule over itself. -/\n@[simp]\ntheorem finrank_self : finrank R R = 1 :=\n  finrank_eq_of_rank_eq (by simp)\n\n"}
{"name":"Module.rank_lt_aleph0","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\ninst✝ : Module.Finite R M\n⊢ LT.lt (Module.rank R M) Cardinal.aleph0","decl":"/-- The rank of a finite module is finite. -/\ntheorem rank_lt_aleph0 [Module.Finite R M] : Module.rank R M < ℵ₀ := by\n  simp only [Module.rank_def]\n  -- Porting note: can't use `‹_›` as that pulls the unused `N` into the context\n  obtain ⟨S, hS⟩ := Module.finite_def.mp ‹Module.Finite R M›\n  refine (ciSup_le' fun i => ?_).trans_lt (nat_lt_aleph0 S.card)\n  exact linearIndependent_le_span_finset _ i.prop S hS\n\n"}
{"name":"Module.finrank_eq_rank","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\ninst✝ : Module.Finite R M\n⊢ Eq (↑(Module.finrank R M)) (Module.rank R M)","decl":"/-- If `M` is finite, `finrank M = rank M`. -/\n@[simp]\ntheorem finrank_eq_rank [Module.Finite R M] : ↑(finrank R M) = Module.rank R M := by\n  rw [Module.finrank, cast_toNat_of_lt_aleph0 (rank_lt_aleph0 R M)]\n\n"}
{"name":"Submodule.finrank_eq_rank","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : StrongRankCondition R\ninst✝ : Module.Finite R M\nN : Submodule R M\n⊢ Eq (↑(Module.finrank R (Subtype fun x => Membership.mem N x))) (Module.rank R (Subtype fun x => Membership.mem N x))","decl":"/-- If `M` is finite, then `finrank N = rank N` for all `N : Submodule M`. Note that\nsuch an `N` need not be finitely generated. -/\nprotected theorem _root_.Submodule.finrank_eq_rank [Module.Finite R M] (N : Submodule R M) :\n    finrank R N = Module.rank R N := by\n  rw [finrank, Cardinal.cast_toNat_of_lt_aleph0]\n  exact lt_of_le_of_lt (Submodule.rank_le N) (rank_lt_aleph0 R M)\n\n"}
{"name":"LinearMap.finrank_le_finrank_of_injective","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : StrongRankCondition R\nM' : Type u_1\ninst✝² : AddCommMonoid M'\ninst✝¹ : Module R M'\ninst✝ : Module.Finite R M'\nf : LinearMap (RingHom.id R) M M'\nhf : Function.Injective ⇑f\n⊢ LE.le (Module.finrank R M) (Module.finrank R M')","decl":"theorem LinearMap.finrank_le_finrank_of_injective [Module.Finite R M'] {f : M →ₗ[R] M'}\n    (hf : Function.Injective f) : finrank R M ≤ finrank R M' :=\n  finrank_le_finrank_of_rank_le_rank (LinearMap.lift_rank_le_of_injective _ hf) (rank_lt_aleph0 _ _)\n\n"}
{"name":"LinearMap.finrank_range_le","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : StrongRankCondition R\nM' : Type u_1\ninst✝² : AddCommMonoid M'\ninst✝¹ : Module R M'\ninst✝ : Module.Finite R M\nf : LinearMap (RingHom.id R) M M'\n⊢ LE.le (Module.finrank R (Subtype fun x => Membership.mem (LinearMap.range f) x)) (Module.finrank R M)","decl":"theorem LinearMap.finrank_range_le [Module.Finite R M] (f : M →ₗ[R] M') :\n    finrank R (LinearMap.range f) ≤ finrank R M :=\n  finrank_le_finrank_of_rank_le_rank (lift_rank_range_le f) (rank_lt_aleph0 _ _)\n\n"}
{"name":"LinearMap.finrank_le_of_isSMulRegular","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : StrongRankCondition R\nS : Type u_1\ninst✝⁴ : CommSemiring S\ninst✝³ : Algebra S R\ninst✝² : Module S M\ninst✝¹ : IsScalarTower S R M\nL L' : Submodule R M\ninst✝ : Module.Finite R (Subtype fun x => Membership.mem L' x)\ns : S\nhr : IsSMulRegular M s\nh : ∀ (x : M), Membership.mem L x → Membership.mem L' (HSMul.hSMul s x)\n⊢ LE.le (Module.finrank R (Subtype fun x => Membership.mem L x)) (Module.finrank R (Subtype fun x => Membership.mem L' x))","decl":"theorem LinearMap.finrank_le_of_isSMulRegular {S : Type*} [CommSemiring S] [Algebra S R]\n    [Module S M] [IsScalarTower S R M] (L L' : Submodule R M) [Module.Finite R L'] {s : S}\n    (hr : IsSMulRegular M s) (h : ∀ x ∈ L, s • x ∈ L') :\n    Module.finrank R L ≤ Module.finrank R L' := by\n  refine finrank_le_finrank_of_rank_le_rank (lift_le.mpr <| rank_le_of_isSMulRegular L L' hr h) ?_\n  rw [← Module.finrank_eq_rank R L']\n  exact nat_lt_aleph0 (finrank R ↥L')\n\n"}
{"name":"LinearMap.finrank_le_of_smul_regular","module":"Mathlib.LinearAlgebra.Dimension.StrongRankCondition","initialProofState":"R : Type u\nM : Type v\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : StrongRankCondition R\nS : Type u_1\ninst✝⁴ : CommSemiring S\ninst✝³ : Algebra S R\ninst✝² : Module S M\ninst✝¹ : IsScalarTower S R M\nL L' : Submodule R M\ninst✝ : Module.Finite R (Subtype fun x => Membership.mem L' x)\ns : S\nhr : IsSMulRegular M s\nh : ∀ (x : M), Membership.mem L x → Membership.mem L' (HSMul.hSMul s x)\n⊢ LE.le (Module.finrank R (Subtype fun x => Membership.mem L x)) (Module.finrank R (Subtype fun x => Membership.mem L' x))","decl":"@[deprecated (since := \"2024-11-21\")]\nalias LinearMap.finrank_le_of_smul_regular := LinearMap.finrank_le_of_isSMulRegular\n\n"}
