{"name":"Nat.irreducible_iff_nat_prime","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"a : Nat\n⊢ Iff (Irreducible a) (Nat.Prime a)","decl":"theorem irreducible_iff_nat_prime (a : ℕ) : Irreducible a ↔ Nat.Prime a :=\n  Iff.rfl\n\n"}
{"name":"Nat.not_prime_zero","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"⊢ Not (Nat.Prime 0)","decl":"@[aesop safe destruct] theorem not_prime_zero : ¬Prime 0\n  | h => h.ne_zero rfl\n\n"}
{"name":"Nat.not_prime_one","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"⊢ Not (Nat.Prime 1)","decl":"@[aesop safe destruct] theorem not_prime_one : ¬Prime 1\n  | h => h.ne_one rfl\n\n"}
{"name":"Nat.Prime.ne_zero","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"n : Nat\nh : Nat.Prime n\n⊢ Ne n 0","decl":"theorem Prime.ne_zero {n : ℕ} (h : Prime n) : n ≠ 0 :=\n  Irreducible.ne_zero h\n\n"}
{"name":"Nat.Prime.pos","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p : Nat\npp : Nat.Prime p\n⊢ LT.lt 0 p","decl":"theorem Prime.pos {p : ℕ} (pp : Prime p) : 0 < p :=\n  Nat.pos_of_ne_zero pp.ne_zero\n\n"}
{"name":"Nat.Prime.two_le","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p : Nat\na✝ : Nat.Prime p\n⊢ LE.le 2 p","decl":"theorem Prime.two_le : ∀ {p : ℕ}, Prime p → 2 ≤ p\n  | 0, h => (not_prime_zero h).elim\n  | 1, h => (not_prime_one h).elim\n  | _ + 2, _ => le_add_left 2 _\n\n"}
{"name":"Nat.Prime.one_lt","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p : Nat\na✝ : Nat.Prime p\n⊢ LT.lt 1 p","decl":"theorem Prime.one_lt {p : ℕ} : Prime p → 1 < p :=\n  Prime.two_le\n\n"}
{"name":"Nat.Prime.one_le","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p : Nat\nhp : Nat.Prime p\n⊢ LE.le 1 p","decl":"lemma Prime.one_le {p : ℕ} (hp : p.Prime) : 1 ≤ p := hp.one_lt.le\n\n"}
{"name":"Nat.Prime.one_lt'","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n⊢ Fact (LT.lt 1 p)","decl":"instance Prime.one_lt' (p : ℕ) [hp : Fact p.Prime] : Fact (1 < p) :=\n  ⟨hp.1.one_lt⟩\n\n"}
{"name":"Nat.Prime.ne_one","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p : Nat\nhp : Nat.Prime p\n⊢ Ne p 1","decl":"theorem Prime.ne_one {p : ℕ} (hp : p.Prime) : p ≠ 1 :=\n  hp.one_lt.ne'\n\n"}
{"name":"Nat.Prime.eq_one_or_self_of_dvd","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p : Nat\npp : Nat.Prime p\nm : Nat\nhm : Dvd.dvd m p\n⊢ Or (Eq m 1) (Eq m p)","decl":"theorem Prime.eq_one_or_self_of_dvd {p : ℕ} (pp : p.Prime) (m : ℕ) (hm : m ∣ p) :\n    m = 1 ∨ m = p := by\n  obtain ⟨n, hn⟩ := hm\n  have := pp.isUnit_or_isUnit hn\n  rw [Nat.isUnit_iff, Nat.isUnit_iff] at this\n  apply Or.imp_right _ this\n  rintro rfl\n  rw [hn, mul_one]\n\n"}
{"name":"Nat.prime_def","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p : Nat\n⊢ Iff (Nat.Prime p) (And (LE.le 2 p) (∀ (m : Nat), Dvd.dvd m p → Or (Eq m 1) (Eq m p)))","decl":"@[inherit_doc Nat.Prime]\ntheorem prime_def {p : ℕ} : Prime p ↔ 2 ≤ p ∧ ∀ m, m ∣ p → m = 1 ∨ m = p := by\n  refine ⟨fun h => ⟨h.two_le, h.eq_one_or_self_of_dvd⟩, fun h => ?_⟩\n  have h1 := Nat.one_lt_two.trans_le h.1\n  refine ⟨mt Nat.isUnit_iff.mp h1.ne', fun a b hab => ?_⟩\n  simp only [Nat.isUnit_iff]\n  apply Or.imp_right _ (h.2 a _)\n  · rintro rfl\n    rw [← mul_right_inj' (not_eq_zero_of_lt h1), ← hab, mul_one]\n  · rw [hab]\n    exact dvd_mul_right _ _\n\n"}
{"name":"Nat.prime_def_lt''","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p : Nat\n⊢ Iff (Nat.Prime p) (And (LE.le 2 p) (∀ (m : Nat), Dvd.dvd m p → Or (Eq m 1) (Eq m p)))","decl":"@[deprecated (since := \"2024-11-19\")]\nalias prime_def_lt'' := prime_def\n\n"}
{"name":"Nat.prime_def_lt","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p : Nat\n⊢ Iff (Nat.Prime p) (And (LE.le 2 p) (∀ (m : Nat), LT.lt m p → Dvd.dvd m p → Eq m 1))","decl":"theorem prime_def_lt {p : ℕ} : Prime p ↔ 2 ≤ p ∧ ∀ m < p, m ∣ p → m = 1 :=\n  prime_def.trans <|\n    and_congr_right fun p2 =>\n      forall_congr' fun _ =>\n        ⟨fun h l d => (h d).resolve_right (ne_of_lt l), fun h d =>\n          (le_of_dvd (le_of_succ_le p2) d).lt_or_eq_dec.imp_left fun l => h l d⟩\n\n"}
{"name":"Nat.prime_def_lt'","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p : Nat\n⊢ Iff (Nat.Prime p) (And (LE.le 2 p) (∀ (m : Nat), LE.le 2 m → LT.lt m p → Not (Dvd.dvd m p)))","decl":"theorem prime_def_lt' {p : ℕ} : Prime p ↔ 2 ≤ p ∧ ∀ m, 2 ≤ m → m < p → ¬m ∣ p :=\n  prime_def_lt.trans <|\n    and_congr_right fun p2 =>\n      forall_congr' fun m =>\n        ⟨fun h m2 l d => not_lt_of_ge m2 ((h l d).symm ▸ by decide), fun h l d => by\n          rcases m with (_ | _ | m)\n          · rw [eq_zero_of_zero_dvd d] at p2\n            revert p2\n            decide\n          · rfl\n          · exact (h (le_add_left 2 m) l).elim d⟩\n\n"}
{"name":"Nat.prime_def_le_sqrt","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p : Nat\n⊢ Iff (Nat.Prime p) (And (LE.le 2 p) (∀ (m : Nat), LE.le 2 m → LE.le m p.sqrt → Not (Dvd.dvd m p)))","decl":"theorem prime_def_le_sqrt {p : ℕ} : Prime p ↔ 2 ≤ p ∧ ∀ m, 2 ≤ m → m ≤ sqrt p → ¬m ∣ p :=\n  prime_def_lt'.trans <|\n    and_congr_right fun p2 =>\n      ⟨fun a m m2 l => a m m2 <| lt_of_le_of_lt l <| sqrt_lt_self p2, fun a =>\n        have : ∀ {m k : ℕ}, m ≤ k → 1 < m → p ≠ m * k := fun {m k} mk m1 e =>\n          a m m1 (le_sqrt.2 (e.symm ▸ Nat.mul_le_mul_left m mk)) ⟨k, e⟩\n        fun m m2 l ⟨k, e⟩ => by\n        rcases le_total m k with mk | km\n        · exact this mk m2 e\n        · rw [mul_comm] at e\n          refine this km (Nat.lt_of_mul_lt_mul_right (a := m) ?_) e\n          rwa [one_mul, ← e]⟩\n\n"}
{"name":"Nat.prime_of_coprime","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"n : Nat\nh1 : LT.lt 1 n\nh : ∀ (m : Nat), LT.lt m n → Ne m 0 → n.Coprime m\n⊢ Nat.Prime n","decl":"theorem prime_of_coprime (n : ℕ) (h1 : 1 < n) (h : ∀ m < n, m ≠ 0 → n.Coprime m) : Prime n := by\n  refine prime_def_lt.mpr ⟨h1, fun m mlt mdvd => ?_⟩\n  have hm : m ≠ 0 := by\n    rintro rfl\n    rw [zero_dvd_iff] at mdvd\n    exact mlt.ne' mdvd\n  exact (h m mlt hm).symm.eq_one_of_dvd mdvd\n\n"}
{"name":"Nat.prime_two","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"⊢ Nat.Prime 2","decl":"theorem prime_two : Prime 2 := by decide\n\n"}
{"name":"Nat.prime_three","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"⊢ Nat.Prime 3","decl":"theorem prime_three : Prime 3 := by decide\n\n"}
{"name":"Nat.prime_five","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"⊢ Nat.Prime 5","decl":"theorem prime_five : Prime 5 := by decide\n\n"}
{"name":"Nat.dvd_prime","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p m : Nat\npp : Nat.Prime p\n⊢ Iff (Dvd.dvd m p) (Or (Eq m 1) (Eq m p))","decl":"theorem dvd_prime {p m : ℕ} (pp : Prime p) : m ∣ p ↔ m = 1 ∨ m = p :=\n  ⟨fun d => pp.eq_one_or_self_of_dvd m d, fun h =>\n    h.elim (fun e => e.symm ▸ one_dvd _) fun e => e.symm ▸ dvd_rfl⟩\n\n"}
{"name":"Nat.dvd_prime_two_le","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p m : Nat\npp : Nat.Prime p\nH : LE.le 2 m\n⊢ Iff (Dvd.dvd m p) (Eq m p)","decl":"theorem dvd_prime_two_le {p m : ℕ} (pp : Prime p) (H : 2 ≤ m) : m ∣ p ↔ m = p :=\n  (dvd_prime pp).trans <| or_iff_right_of_imp <| Not.elim <| ne_of_gt H\n\n"}
{"name":"Nat.prime_dvd_prime_iff_eq","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p q : Nat\npp : Nat.Prime p\nqp : Nat.Prime q\n⊢ Iff (Dvd.dvd p q) (Eq p q)","decl":"theorem prime_dvd_prime_iff_eq {p q : ℕ} (pp : p.Prime) (qp : q.Prime) : p ∣ q ↔ p = q :=\n  dvd_prime_two_le qp (Prime.two_le pp)\n\n"}
{"name":"Nat.Prime.not_dvd_one","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p : Nat\npp : Nat.Prime p\n⊢ Not (Dvd.dvd p 1)","decl":"theorem Prime.not_dvd_one {p : ℕ} (pp : Prime p) : ¬p ∣ 1 :=\n  Irreducible.not_dvd_one pp\n\n"}
{"name":"Nat.minFac_lemma","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"n k : Nat\nh : Not (LT.lt n (HMul.hMul k k))\n⊢ LT.lt (HSub.hSub n.sqrt k) (HSub.hSub (HAdd.hAdd n.sqrt 2) k)","decl":"theorem minFac_lemma (n k : ℕ) (h : ¬n < k * k) : sqrt n - k < sqrt n + 2 - k :=\n  (Nat.sub_lt_sub_right <| le_sqrt.2 <| le_of_not_gt h) <| Nat.lt_add_of_pos_right (by decide)\n\n"}
{"name":"Nat.minFac_zero","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"⊢ Eq (Nat.minFac 0) 2","decl":"@[simp]\ntheorem minFac_zero : minFac 0 = 2 :=\n  rfl\n\n"}
{"name":"Nat.minFac_one","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"⊢ Eq (Nat.minFac 1) 1","decl":"@[simp]\ntheorem minFac_one : minFac 1 = 1 := by\n  simp [minFac, minFacAux]\n\n"}
{"name":"Nat.minFac_two","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"⊢ Eq (Nat.minFac 2) 2","decl":"@[simp]\ntheorem minFac_two : minFac 2 = 2 := by\n  simp [minFac, minFacAux]\n\n"}
{"name":"Nat.minFac_eq","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"n : Nat\n⊢ Eq n.minFac (ite (Dvd.dvd 2 n) 2 (n.minFacAux 3))","decl":"theorem minFac_eq (n : ℕ) : minFac n = if 2 ∣ n then 2 else minFacAux n 3 := rfl\n\n"}
{"name":"Nat.minFacAux_has_prop","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"n : Nat\nn2 : LE.le 2 n\nk i : Nat\na✝¹ : Eq k (HAdd.hAdd (HMul.hMul 2 i) 3)\na✝ : ∀ (m : Nat), LE.le 2 m → Dvd.dvd m n → LE.le k m\n⊢ Nat.minFacProp n (n.minFacAux k)","decl":"theorem minFacAux_has_prop {n : ℕ} (n2 : 2 ≤ n) :\n    ∀ k i, k = 2 * i + 3 → (∀ m, 2 ≤ m → m ∣ n → k ≤ m) → minFacProp n (minFacAux n k)\n  | k => fun i e a => by\n    rw [minFacAux]\n    by_cases h : n < k * k\n    · have pp : Prime n :=\n        prime_def_le_sqrt.2\n          ⟨n2, fun m m2 l d => not_lt_of_ge l <| lt_of_lt_of_le (sqrt_lt.2 h) (a m m2 d)⟩\n      simpa only [k, h] using\n        ⟨n2, dvd_rfl, fun m m2 d => le_of_eq ((dvd_prime_two_le pp m2).1 d).symm⟩\n    have k2 : 2 ≤ k := by\n      subst e\n      apply Nat.le_add_left\n    simp only [k, h, ↓reduceIte]\n    by_cases dk : k ∣ n <;> simp only [k, dk, ↓reduceIte]\n    · exact ⟨k2, dk, a⟩\n    · refine\n        have := minFac_lemma n k h\n        minFacAux_has_prop n2 (k + 2) (i + 1) (by simp [k, e, Nat.left_distrib, add_right_comm])\n          fun m m2 d => ?_\n      rcases Nat.eq_or_lt_of_le (a m m2 d) with me | ml\n      · subst me\n        contradiction\n      apply (Nat.eq_or_lt_of_le ml).resolve_left\n      intro me\n      rw [← me, e] at d\n      have d' : 2 * (i + 2) ∣ n := d\n      have := a _ le_rfl (dvd_of_mul_right_dvd d')\n      rw [e] at this\n      exact absurd this (by contradiction)\n  termination_by k => sqrt n + 2 - k\n\n"}
{"name":"Nat.minFac_has_prop","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"n : Nat\nn1 : Ne n 1\n⊢ Nat.minFacProp n n.minFac","decl":"theorem minFac_has_prop {n : ℕ} (n1 : n ≠ 1) : minFacProp n (minFac n) := by\n  by_cases n0 : n = 0\n  · simp [n0, minFacProp, GE.ge]\n  have n2 : 2 ≤ n := by\n    revert n0 n1\n    rcases n with (_ | _ | _) <;> simp [succ_le_succ]\n  simp only [minFac_eq, Nat.isUnit_iff]\n  by_cases d2 : 2 ∣ n <;> simp only [d2, ↓reduceIte]\n  · exact ⟨le_rfl, d2, fun k k2 _ => k2⟩\n  · refine\n      minFacAux_has_prop n2 3 0 rfl fun m m2 d => (Nat.eq_or_lt_of_le m2).resolve_left (mt ?_ d2)\n    exact fun e => e.symm ▸ d\n\n"}
{"name":"Nat.minFac_dvd","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"n : Nat\n⊢ Dvd.dvd n.minFac n","decl":"theorem minFac_dvd (n : ℕ) : minFac n ∣ n :=\n  if n1 : n = 1 then by simp [n1] else (minFac_has_prop n1).2.1\n\n"}
{"name":"Nat.minFac_prime","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"n : Nat\nn1 : Ne n 1\n⊢ Nat.Prime n.minFac","decl":"theorem minFac_prime {n : ℕ} (n1 : n ≠ 1) : Prime (minFac n) :=\n  let ⟨f2, fd, a⟩ := minFac_has_prop n1\n  prime_def_lt'.2 ⟨f2, fun m m2 l d => not_le_of_gt l (a m m2 (d.trans fd))⟩\n\n"}
{"name":"Nat.minFac_le_of_dvd","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"n m : Nat\na✝¹ : LE.le 2 m\na✝ : Dvd.dvd m n\n⊢ LE.le n.minFac m","decl":"theorem minFac_le_of_dvd {n : ℕ} : ∀ {m : ℕ}, 2 ≤ m → m ∣ n → minFac n ≤ m := by\n  by_cases n1 : n = 1\n  · exact fun m2 _ => n1.symm ▸ le_trans (by simp) m2\n  · apply (minFac_has_prop n1).2.2\n\n"}
{"name":"Nat.minFac_pos","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"n : Nat\n⊢ LT.lt 0 n.minFac","decl":"theorem minFac_pos (n : ℕ) : 0 < minFac n := by\n  by_cases n1 : n = 1\n  · simp [n1]\n  · exact (minFac_prime n1).pos\n\n"}
{"name":"Nat.minFac_le","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"n : Nat\nH : LT.lt 0 n\n⊢ LE.le n.minFac n","decl":"theorem minFac_le {n : ℕ} (H : 0 < n) : minFac n ≤ n :=\n  le_of_dvd H (minFac_dvd n)\n\n"}
{"name":"Nat.le_minFac","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"m n : Nat\n⊢ Iff (Or (Eq n 1) (LE.le m n.minFac)) (∀ (p : Nat), Nat.Prime p → Dvd.dvd p n → LE.le m p)","decl":"theorem le_minFac {m n : ℕ} : n = 1 ∨ m ≤ minFac n ↔ ∀ p, Prime p → p ∣ n → m ≤ p :=\n  ⟨fun h p pp d =>\n    h.elim (by rintro rfl; cases pp.not_dvd_one d) fun h =>\n      le_trans h <| minFac_le_of_dvd pp.two_le d,\n    fun H => or_iff_not_imp_left.2 fun n1 => H _ (minFac_prime n1) (minFac_dvd _)⟩\n\n"}
{"name":"Nat.le_minFac'","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"m n : Nat\n⊢ Iff (Or (Eq n 1) (LE.le m n.minFac)) (∀ (p : Nat), LE.le 2 p → Dvd.dvd p n → LE.le m p)","decl":"theorem le_minFac' {m n : ℕ} : n = 1 ∨ m ≤ minFac n ↔ ∀ p, 2 ≤ p → p ∣ n → m ≤ p :=\n  ⟨fun h p (pp : 1 < p) d =>\n    h.elim (by rintro rfl; cases not_le_of_lt pp (le_of_dvd (by decide) d)) fun h =>\n      le_trans h <| minFac_le_of_dvd pp d,\n    fun H => le_minFac.2 fun p pp d => H p pp.two_le d⟩\n\n"}
{"name":"Nat.prime_def_minFac","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p : Nat\n⊢ Iff (Nat.Prime p) (And (LE.le 2 p) (Eq p.minFac p))","decl":"theorem prime_def_minFac {p : ℕ} : Prime p ↔ 2 ≤ p ∧ minFac p = p :=\n  ⟨fun pp =>\n    ⟨pp.two_le,\n      let ⟨f2, fd, _⟩ := minFac_has_prop <| ne_of_gt pp.one_lt\n      ((dvd_prime pp).1 fd).resolve_left (ne_of_gt f2)⟩,\n    fun ⟨p2, e⟩ => e ▸ minFac_prime (ne_of_gt p2)⟩\n\n"}
{"name":"Nat.Prime.minFac_eq","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p : Nat\nhp : Nat.Prime p\n⊢ Eq p.minFac p","decl":"@[simp]\ntheorem Prime.minFac_eq {p : ℕ} (hp : Prime p) : minFac p = p :=\n  (prime_def_minFac.1 hp).2\n\n"}
{"name":"Nat.decidablePrime_csimp","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"⊢ Eq Nat.decidablePrime Nat.decidablePrime'","decl":"@[csimp] theorem decidablePrime_csimp :\n    @decidablePrime = @decidablePrime' := by\n  funext; apply Subsingleton.elim\n\n"}
{"name":"Nat.not_prime_iff_minFac_lt","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"n : Nat\nn2 : LE.le 2 n\n⊢ Iff (Not (Nat.Prime n)) (LT.lt n.minFac n)","decl":"theorem not_prime_iff_minFac_lt {n : ℕ} (n2 : 2 ≤ n) : ¬Prime n ↔ minFac n < n :=\n  (not_congr <| prime_def_minFac.trans <| and_iff_right n2).trans <|\n    (lt_iff_le_and_ne.trans <| and_iff_right <| minFac_le <| le_of_succ_le n2).symm\n\n"}
{"name":"Nat.minFac_le_div","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"n : Nat\npos : LT.lt 0 n\nnp : Not (Nat.Prime n)\n⊢ LE.le n.minFac (HDiv.hDiv n n.minFac)","decl":"theorem minFac_le_div {n : ℕ} (pos : 0 < n) (np : ¬Prime n) : minFac n ≤ n / minFac n :=\n  match minFac_dvd n with\n  | ⟨0, h0⟩ => absurd pos <| by rw [h0, mul_zero]; decide\n  | ⟨1, h1⟩ => by\n    rw [mul_one] at h1\n    rw [prime_def_minFac, not_and_or, ← h1, eq_self_iff_true, _root_.not_true, _root_.or_false,\n      not_le] at np\n    rw [le_antisymm (le_of_lt_succ np) (succ_le_of_lt pos), minFac_one, Nat.div_one]\n  | ⟨x + 2, hx⟩ => by\n    conv_rhs =>\n      congr\n      rw [hx]\n    rw [Nat.mul_div_cancel_left _ (minFac_pos _)]\n    exact minFac_le_of_dvd (le_add_left 2 x) ⟨minFac n, by rwa [mul_comm]⟩\n\n"}
{"name":"Nat.minFac_sq_le_self","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"n : Nat\nw : LT.lt 0 n\nh : Not (Nat.Prime n)\n⊢ LE.le (HPow.hPow n.minFac 2) n","decl":"/-- The square of the smallest prime factor of a composite number `n` is at most `n`.\n-/\ntheorem minFac_sq_le_self {n : ℕ} (w : 0 < n) (h : ¬Prime n) : minFac n ^ 2 ≤ n :=\n  have t : minFac n ≤ n / minFac n := minFac_le_div w h\n  calc\n    minFac n ^ 2 = minFac n * minFac n := sq (minFac n)\n    _ ≤ n / minFac n * minFac n := Nat.mul_le_mul_right (minFac n) t\n    _ ≤ n := div_mul_le_self n (minFac n)\n\n"}
{"name":"Nat.minFac_eq_one_iff","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"n : Nat\n⊢ Iff (Eq n.minFac 1) (Eq n 1)","decl":"@[simp]\ntheorem minFac_eq_one_iff {n : ℕ} : minFac n = 1 ↔ n = 1 := by\n  constructor\n  · intro h\n    by_contra hn\n    have := minFac_prime hn\n    rw [h] at this\n    exact not_prime_one this\n  · rintro rfl\n    rfl\n\n"}
{"name":"Nat.minFac_eq_two_iff","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"n : Nat\n⊢ Iff (Eq n.minFac 2) (Dvd.dvd 2 n)","decl":"@[simp]\ntheorem minFac_eq_two_iff (n : ℕ) : minFac n = 2 ↔ 2 ∣ n := by\n  constructor\n  · intro h\n    rw [← h]\n    exact minFac_dvd n\n  · intro h\n    have ub := minFac_le_of_dvd (le_refl 2) h\n    have lb := minFac_pos n\n    refine ub.eq_or_lt.resolve_right fun h' => ?_\n    have := le_antisymm (Nat.succ_le_of_lt lb) (Nat.lt_succ_iff.mp h')\n    rw [eq_comm, Nat.minFac_eq_one_iff] at this\n    subst this\n    exact not_lt_of_le (le_of_dvd lb h) h'\n\n"}
{"name":"Nat.factors_lemma","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"k : Nat\n⊢ LT.lt (HDiv.hDiv (HAdd.hAdd k 2) (HAdd.hAdd k 2).minFac) (HAdd.hAdd k 2)","decl":"theorem factors_lemma {k} : (k + 2) / minFac (k + 2) < k + 2 :=\n  div_lt_self (Nat.zero_lt_succ _) (minFac_prime (by\n      apply Nat.ne_of_gt\n      apply Nat.succ_lt_succ\n      apply Nat.zero_lt_succ\n      )).one_lt\n\n"}
{"name":"Nat.exists_prime_and_dvd","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"n : Nat\nhn : Ne n 1\n⊢ Exists fun p => And (Nat.Prime p) (Dvd.dvd p n)","decl":"theorem exists_prime_and_dvd {n : ℕ} (hn : n ≠ 1) : ∃ p, Prime p ∧ p ∣ n :=\n  ⟨minFac n, minFac_prime hn, minFac_dvd _⟩\n\n"}
{"name":"Nat.coprime_of_dvd","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"m n : Nat\nH : ∀ (k : Nat), Nat.Prime k → Dvd.dvd k m → Not (Dvd.dvd k n)\n⊢ m.Coprime n","decl":"theorem coprime_of_dvd {m n : ℕ} (H : ∀ k, Prime k → k ∣ m → ¬k ∣ n) : Coprime m n := by\n  rw [coprime_iff_gcd_eq_one]\n  by_contra g2\n  obtain ⟨p, hp, hpdvd⟩ := exists_prime_and_dvd g2\n  apply H p hp <;> apply dvd_trans hpdvd\n  · exact gcd_dvd_left _ _\n  · exact gcd_dvd_right _ _\n\n"}
{"name":"Nat.Prime.coprime_iff_not_dvd","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p n : Nat\npp : Nat.Prime p\n⊢ Iff (p.Coprime n) (Not (Dvd.dvd p n))","decl":"theorem Prime.coprime_iff_not_dvd {p n : ℕ} (pp : Prime p) : Coprime p n ↔ ¬p ∣ n :=\n  ⟨fun co d => pp.not_dvd_one <| co.dvd_of_dvd_mul_left (by simp [d]), fun nd =>\n    coprime_of_dvd fun _ m2 mp => ((prime_dvd_prime_iff_eq m2 pp).1 mp).symm ▸ nd⟩\n\n"}
{"name":"Nat.Prime.dvd_mul","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p m n : Nat\npp : Nat.Prime p\n⊢ Iff (Dvd.dvd p (HMul.hMul m n)) (Or (Dvd.dvd p m) (Dvd.dvd p n))","decl":"theorem Prime.dvd_mul {p m n : ℕ} (pp : Prime p) : p ∣ m * n ↔ p ∣ m ∨ p ∣ n :=\n  ⟨fun H => or_iff_not_imp_left.2 fun h => (pp.coprime_iff_not_dvd.2 h).dvd_of_dvd_mul_left H,\n    Or.rec (fun h : p ∣ m => h.mul_right _) fun h : p ∣ n => h.mul_left _⟩\n\n"}
{"name":"Nat.prime_iff","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p : Nat\n⊢ Iff (Nat.Prime p) (Prime p)","decl":"theorem prime_iff {p : ℕ} : p.Prime ↔ _root_.Prime p :=\n  ⟨fun h => ⟨h.ne_zero, h.not_unit, fun _ _ => h.dvd_mul.mp⟩, Prime.irreducible⟩\n\n"}
{"name":"Nat.Prime.prime","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p : Nat\na✝ : Nat.Prime p\n⊢ Prime p","decl":"alias ⟨Prime.prime, _root_.Prime.nat_prime⟩ := prime_iff\n\n"}
{"name":"Prime.nat_prime","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p : Nat\na✝ : Prime p\n⊢ Nat.Prime p","decl":"alias ⟨Prime.prime, _root_.Prime.nat_prime⟩ := prime_iff\n\n"}
{"name":"Nat.irreducible_iff_prime","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p : Nat\n⊢ Iff (Irreducible p) (Prime p)","decl":"theorem irreducible_iff_prime {p : ℕ} : Irreducible p ↔ _root_.Prime p :=\n  prime_iff\n\n"}
{"name":"Nat.Primes.coe_nat_injective","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"⊢ Function.Injective fun a => ↑a","decl":"theorem coe_nat_injective : Function.Injective (fun (a : Nat.Primes) ↦ (a : ℕ)) :=\n  Subtype.coe_injective\n\n"}
{"name":"Nat.Primes.coe_nat_inj","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"p q : Nat.Primes\n⊢ Iff (Eq ↑p ↑q) (Eq p q)","decl":"theorem coe_nat_inj (p q : Nat.Primes) : (p : ℕ) = (q : ℕ) ↔ p = q :=\n  Subtype.ext_iff.symm\n\n"}
{"name":"Nat.fact_prime_two","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"⊢ Fact (Nat.Prime 2)","decl":"instance fact_prime_two : Fact (Prime 2) :=\n  ⟨prime_two⟩\n\n"}
{"name":"Nat.fact_prime_three","module":"Mathlib.Data.Nat.Prime.Defs","initialProofState":"⊢ Fact (Nat.Prime 3)","decl":"instance fact_prime_three : Fact (Prime 3) :=\n  ⟨prime_three⟩\n\n"}
