{"name":"List.Nat.mem_antidiagonal","module":"Mathlib.Data.List.NatAntidiagonal","initialProofState":"n : Nat\nx : Prod Nat Nat\n⊢ Iff (Membership.mem (List.Nat.antidiagonal n) x) (Eq (HAdd.hAdd x.1 x.2) n)","decl":"/-- A pair (i, j) is contained in the antidiagonal of `n` if and only if `i + j = n`. -/\n@[simp]\ntheorem mem_antidiagonal {n : ℕ} {x : ℕ × ℕ} : x ∈ antidiagonal n ↔ x.1 + x.2 = n := by\n  rw [antidiagonal, mem_map]; constructor\n  · rintro ⟨i, hi, rfl⟩\n    rw [mem_range, Nat.lt_succ_iff] at hi\n    exact Nat.add_sub_cancel' hi\n  · rintro rfl\n    refine ⟨x.fst, ?_, ?_⟩\n    · rw [mem_range]\n      omega\n    · exact Prod.ext rfl (by simp only [Nat.add_sub_cancel_left])\n\n"}
{"name":"List.Nat.length_antidiagonal","module":"Mathlib.Data.List.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (List.Nat.antidiagonal n).length (HAdd.hAdd n 1)","decl":"/-- The length of the antidiagonal of `n` is `n + 1`. -/\n@[simp]\ntheorem length_antidiagonal (n : ℕ) : (antidiagonal n).length = n + 1 := by\n  rw [antidiagonal, length_map, length_range]\n\n"}
{"name":"List.Nat.antidiagonal_zero","module":"Mathlib.Data.List.NatAntidiagonal","initialProofState":"⊢ Eq (List.Nat.antidiagonal 0) (List.cons { fst := 0, snd := 0 } List.nil)","decl":"/-- The antidiagonal of `0` is the list `[(0, 0)]` -/\n@[simp]\ntheorem antidiagonal_zero : antidiagonal 0 = [(0, 0)] :=\n  rfl\n\n"}
{"name":"List.Nat.nodup_antidiagonal","module":"Mathlib.Data.List.NatAntidiagonal","initialProofState":"n : Nat\n⊢ (List.Nat.antidiagonal n).Nodup","decl":"/-- The antidiagonal of `n` does not contain duplicate entries. -/\ntheorem nodup_antidiagonal (n : ℕ) : Nodup (antidiagonal n) :=\n  (nodup_range _).map ((@LeftInverse.injective ℕ (ℕ × ℕ) Prod.fst fun i ↦ (i, n - i)) fun _ ↦ rfl)\n\n"}
{"name":"List.Nat.antidiagonal_succ","module":"Mathlib.Data.List.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (List.Nat.antidiagonal (HAdd.hAdd n 1)) (List.cons { fst := 0, snd := HAdd.hAdd n 1 } (List.map (Prod.map Nat.succ id) (List.Nat.antidiagonal n)))","decl":"@[simp]\ntheorem antidiagonal_succ {n : ℕ} :\n    antidiagonal (n + 1) = (0, n + 1) :: (antidiagonal n).map (Prod.map Nat.succ id) := by\n  simp only [antidiagonal, range_succ_eq_map, map_cons, Nat.add_succ_sub_one,\n    Nat.add_zero, id, eq_self_iff_true, Nat.sub_zero, map_map, Prod.map_apply]\n  apply congr rfl (congr rfl _)\n  ext; simp\n\n"}
{"name":"List.Nat.antidiagonal_succ'","module":"Mathlib.Data.List.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (List.Nat.antidiagonal (HAdd.hAdd n 1)) (HAppend.hAppend (List.map (Prod.map id Nat.succ) (List.Nat.antidiagonal n)) (List.cons { fst := HAdd.hAdd n 1, snd := 0 } List.nil))","decl":"theorem antidiagonal_succ' {n : ℕ} :\n    antidiagonal (n + 1) = (antidiagonal n).map (Prod.map id Nat.succ) ++ [(n + 1, 0)] := by\n  simp only [antidiagonal, range_succ, Nat.add_sub_cancel_left, map_append, append_assoc,\n    Nat.sub_self, singleton_append, map_map, map]\n  congr 1\n  apply map_congr_left\n  simp +contextual [le_of_lt, Nat.sub_add_comm]\n\n"}
{"name":"List.Nat.antidiagonal_succ_succ'","module":"Mathlib.Data.List.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (List.Nat.antidiagonal (HAdd.hAdd n 2)) (HAppend.hAppend (List.cons { fst := 0, snd := HAdd.hAdd n 2 } (List.map (Prod.map Nat.succ Nat.succ) (List.Nat.antidiagonal n))) (List.cons { fst := HAdd.hAdd n 2, snd := 0 } List.nil))","decl":"theorem antidiagonal_succ_succ' {n : ℕ} :\n    antidiagonal (n + 2) =\n      (0, n + 2) :: (antidiagonal n).map (Prod.map Nat.succ Nat.succ) ++ [(n + 2, 0)] := by\n  rw [antidiagonal_succ']\n  simp only [antidiagonal_succ, map_cons, Prod.map_apply, id_eq, map_map, cons_append, cons.injEq,\n    append_cancel_right_eq, true_and]\n  ext\n  simp\n\n"}
{"name":"List.Nat.map_swap_antidiagonal","module":"Mathlib.Data.List.NatAntidiagonal","initialProofState":"n : Nat\n⊢ Eq (List.map Prod.swap (List.Nat.antidiagonal n)) (List.Nat.antidiagonal n).reverse","decl":"theorem map_swap_antidiagonal {n : ℕ} :\n    (antidiagonal n).map Prod.swap = (antidiagonal n).reverse := by\n  rw [antidiagonal, map_map, ← List.map_reverse, range_eq_range', reverse_range', ←\n    range_eq_range', map_map]\n  apply map_congr_left\n  simp +contextual [Nat.sub_sub_self, Nat.lt_succ_iff]\n\n"}
