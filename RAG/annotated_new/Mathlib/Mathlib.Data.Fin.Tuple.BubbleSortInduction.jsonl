{"name":"Tuple.bubble_sort_induction'","module":"Mathlib.Data.Fin.Tuple.BubbleSortInduction","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : LinearOrder α\nf : Fin n → α\nP : (Fin n → α) → Prop\nhf : P f\nh : ∀ (σ : Equiv.Perm (Fin n)) (i j : Fin n), LT.lt i j → LT.lt (Function.comp f (⇑σ) j) (Function.comp f (⇑σ) i) → P (Function.comp f ⇑σ) → P (Function.comp f (Function.comp ⇑σ ⇑(Equiv.swap i j)))\n⊢ P (Function.comp f ⇑(Tuple.sort f))","decl":"/-- *Bubble sort induction*: Prove that the sorted version of `f` has some property `P`\nif `f` satisfies `P` and `P` is preserved on permutations of `f` when swapping two\nantitone values. -/\ntheorem bubble_sort_induction' {n : ℕ} {α : Type*} [LinearOrder α] {f : Fin n → α}\n    {P : (Fin n → α) → Prop} (hf : P f)\n    (h : ∀ (σ : Equiv.Perm (Fin n)) (i j : Fin n),\n      i < j → (f ∘ σ) j < (f ∘ σ) i → P (f ∘ σ) → P (f ∘ σ ∘ Equiv.swap i j)) :\n    P (f ∘ sort f) := by\n  letI := @Preorder.lift _ (Lex (Fin n → α)) _ fun σ : Equiv.Perm (Fin n) => toLex (f ∘ σ)\n  refine\n    @WellFounded.induction_bot' _ _ _ (IsWellFounded.wf : WellFounded (· < ·))\n      (Equiv.refl _) (sort f) P (fun σ => f ∘ σ) (fun σ hσ hfσ => ?_) hf\n  obtain ⟨i, j, hij₁, hij₂⟩ := antitone_pair_of_not_sorted' hσ\n  exact ⟨σ * Equiv.swap i j, Pi.lex_desc hij₁.le hij₂, h σ i j hij₁ hij₂ hfσ⟩\n\n"}
{"name":"Tuple.bubble_sort_induction","module":"Mathlib.Data.Fin.Tuple.BubbleSortInduction","initialProofState":"n : Nat\nα : Type u_1\ninst✝ : LinearOrder α\nf : Fin n → α\nP : (Fin n → α) → Prop\nhf : P f\nh : ∀ (g : Fin n → α) (i j : Fin n), LT.lt i j → LT.lt (g j) (g i) → P g → P (Function.comp g ⇑(Equiv.swap i j))\n⊢ P (Function.comp f ⇑(Tuple.sort f))","decl":"/-- *Bubble sort induction*: Prove that the sorted version of `f` has some property `P`\nif `f` satisfies `P` and `P` is preserved when swapping two antitone values. -/\ntheorem bubble_sort_induction {n : ℕ} {α : Type*} [LinearOrder α] {f : Fin n → α}\n    {P : (Fin n → α) → Prop} (hf : P f)\n    (h : ∀ (g : Fin n → α) (i j : Fin n), i < j → g j < g i → P g → P (g ∘ Equiv.swap i j)) :\n    P (f ∘ sort f) :=\n  bubble_sort_induction' hf fun _ => h _\n\n"}
