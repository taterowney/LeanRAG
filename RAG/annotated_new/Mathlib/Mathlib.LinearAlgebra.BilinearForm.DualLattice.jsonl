{"name":"LinearMap.BilinForm.mem_dualSubmodule","module":"Mathlib.LinearAlgebra.BilinearForm.DualLattice","initialProofState":"R : Type u_1\nS : Type u_3\nM : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : Field S\ninst✝⁴ : AddCommGroup M\ninst✝³ : Algebra R S\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nB : LinearMap.BilinForm S M\nN : Submodule R M\nx : M\n⊢ Iff (Membership.mem (B.dualSubmodule N) x) (∀ (y : M), Membership.mem N y → Membership.mem 1 ((B x) y))","decl":"lemma mem_dualSubmodule {N : Submodule R M} {x} :\n    x ∈ B.dualSubmodule N ↔ ∀ y ∈ N, B x y ∈ (1 : Submodule R S) := Iff.rfl\n\n"}
{"name":"LinearMap.BilinForm.le_flip_dualSubmodule","module":"Mathlib.LinearAlgebra.BilinearForm.DualLattice","initialProofState":"R : Type u_1\nS : Type u_3\nM : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : Field S\ninst✝⁴ : AddCommGroup M\ninst✝³ : Algebra R S\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nB : LinearMap.BilinForm S M\nN₁ N₂ : Submodule R M\n⊢ Iff (LE.le N₁ (B.flip.dualSubmodule N₂)) (LE.le N₂ (B.dualSubmodule N₁))","decl":"lemma le_flip_dualSubmodule {N₁ N₂ : Submodule R M} :\n    N₁ ≤ B.flip.dualSubmodule N₂ ↔ N₂ ≤ B.dualSubmodule N₁ := by\n  show (∀ (x : M), x ∈ N₁ → _) ↔ ∀ (x : M), x ∈ N₂ → _\n  simp only [mem_dualSubmodule, Submodule.mem_one, flip_apply]\n  exact forall₂_swap\n\n"}
{"name":"LinearMap.BilinForm.dualSubmoduleParing_spec","module":"Mathlib.LinearAlgebra.BilinearForm.DualLattice","initialProofState":"R : Type u_1\nS : Type u_3\nM : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : Field S\ninst✝⁴ : AddCommGroup M\ninst✝³ : Algebra R S\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nB : LinearMap.BilinForm S M\nN : Submodule R M\nx : Subtype fun x => Membership.mem (B.dualSubmodule N) x\ny : Subtype fun x => Membership.mem N x\n⊢ Eq ((algebraMap R S) (B.dualSubmoduleParing x y)) ((B ↑x) ↑y)","decl":"@[simp]\nlemma dualSubmoduleParing_spec {N : Submodule R M} (x : B.dualSubmodule N) (y : N) :\n    algebraMap R S (B.dualSubmoduleParing x y) = B x y :=\n  (Submodule.mem_one.mp <| x.prop y y.prop).choose_spec\n\n"}
{"name":"LinearMap.BilinForm.dualSubmoduleToDual_apply_apply","module":"Mathlib.LinearAlgebra.BilinearForm.DualLattice","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : Field S\ninst✝⁴ : AddCommGroup M\ninst✝³ : Algebra R S\ninst✝² : Module R M\ninst✝¹ : Module S M\nB : LinearMap.BilinForm S M\ninst✝ : NoZeroSMulDivisors R S\nN : Submodule R M\nx : Subtype fun x => Membership.mem (B.dualSubmodule N) x\ny : Subtype fun x => Membership.mem N x\n⊢ Eq (((B.dualSubmoduleToDual N) x) y) (B.dualSubmoduleParing x y)","decl":"/-- The natural paring of `B.dualSubmodule N` and `N`. -/\n-- TODO: Show that this is perfect when `N` is a lattice and `B` is nondegenerate.\n@[simps]\nnoncomputable\ndef dualSubmoduleToDual [NoZeroSMulDivisors R S] (N : Submodule R M) :\n    B.dualSubmodule N →ₗ[R] Module.Dual R N :=\n  { toFun := fun x ↦\n    { toFun := B.dualSubmoduleParing x\n      map_add' := fun x y ↦ NoZeroSMulDivisors.algebraMap_injective R S (by simp)\n      map_smul' := fun r m ↦ NoZeroSMulDivisors.algebraMap_injective R S\n        (by simp [← Algebra.smul_def]) }\n    map_add' := fun x y ↦ LinearMap.ext fun z ↦ NoZeroSMulDivisors.algebraMap_injective R S\n      (by simp)\n    map_smul' := fun r x ↦ LinearMap.ext fun y ↦ NoZeroSMulDivisors.algebraMap_injective R S\n      (by simp [← Algebra.smul_def]) }\n\n"}
{"name":"LinearMap.BilinForm.dualSubmoduleToDual_injective","module":"Mathlib.LinearAlgebra.BilinearForm.DualLattice","initialProofState":"R : Type u_3\nS : Type u_1\nM : Type u_2\ninst✝⁷ : CommRing R\ninst✝⁶ : Field S\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Algebra R S\ninst✝³ : Module R M\ninst✝² : Module S M\ninst✝¹ : IsScalarTower R S M\nB : LinearMap.BilinForm S M\nhB : B.Nondegenerate\ninst✝ : NoZeroSMulDivisors R S\nN : Submodule R M\nhN : Eq (Submodule.span S ↑N) Top.top\n⊢ Function.Injective ⇑(B.dualSubmoduleToDual N)","decl":"lemma dualSubmoduleToDual_injective (hB : B.Nondegenerate) [NoZeroSMulDivisors R S]\n    (N : Submodule R M) (hN : Submodule.span S (N : Set M) = ⊤) :\n    Function.Injective (B.dualSubmoduleToDual N) := by\n  intro x y e\n  ext\n  apply LinearMap.ker_eq_bot.mp hB.ker_eq_bot\n  apply LinearMap.ext_on hN\n  intro z hz\n  simpa using congr_arg (algebraMap R S) (LinearMap.congr_fun e ⟨z, hz⟩)\n\n"}
{"name":"LinearMap.BilinForm.dualSubmodule_span_of_basis","module":"Mathlib.LinearAlgebra.BilinearForm.DualLattice","initialProofState":"R : Type u_4\nS : Type u_2\nM : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : Field S\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Algebra R S\ninst✝⁴ : Module R M\ninst✝³ : Module S M\ninst✝² : IsScalarTower R S M\nB : LinearMap.BilinForm S M\nι : Type u_1\ninst✝¹ : Finite ι\ninst✝ : DecidableEq ι\nhB : B.Nondegenerate\nb : Basis ι S M\n⊢ Eq (B.dualSubmodule (Submodule.span R (Set.range ⇑b))) (Submodule.span R (Set.range ⇑(B.dualBasis hB b)))","decl":"lemma dualSubmodule_span_of_basis {ι} [Finite ι] [DecidableEq ι]\n    (hB : B.Nondegenerate) (b : Basis ι S M) :\n    B.dualSubmodule (Submodule.span R (Set.range b)) =\n      Submodule.span R (Set.range <| B.dualBasis hB b) := by\n  cases nonempty_fintype ι\n  apply le_antisymm\n  · intro x hx\n    rw [← (B.dualBasis hB b).sum_repr x]\n    apply sum_mem\n    rintro i -\n    obtain ⟨r, hr⟩ := Submodule.mem_one.mp <| hx (b i) (Submodule.subset_span ⟨_, rfl⟩)\n    simp only [dualBasis_repr_apply, ← hr, Algebra.linearMap_apply, algebraMap_smul]\n    apply Submodule.smul_mem\n    exact Submodule.subset_span ⟨_, rfl⟩\n  · rw [Submodule.span_le]\n    rintro _ ⟨i, rfl⟩ y hy\n    obtain ⟨f, rfl⟩ := (mem_span_range_iff_exists_fun _).mp hy\n    simp only [map_sum, map_smul]\n    apply sum_mem\n    rintro j -\n    rw [← IsScalarTower.algebraMap_smul S (f j), map_smul]\n    simp_rw [apply_dualBasis_left]\n    rw [smul_eq_mul, mul_ite, mul_one, mul_zero, ← (algebraMap R S).map_zero, ← apply_ite]\n    exact Submodule.mem_one.mpr ⟨_, rfl⟩\n\n"}
{"name":"LinearMap.BilinForm.dualSubmodule_dualSubmodule_flip_of_basis","module":"Mathlib.LinearAlgebra.BilinearForm.DualLattice","initialProofState":"R : Type u_4\nS : Type u_2\nM : Type u_3\ninst✝⁷ : CommRing R\ninst✝⁶ : Field S\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Algebra R S\ninst✝³ : Module R M\ninst✝² : Module S M\ninst✝¹ : IsScalarTower R S M\nB : LinearMap.BilinForm S M\nι : Type u_1\ninst✝ : Finite ι\nhB : B.Nondegenerate\nb : Basis ι S M\n⊢ Eq (B.dualSubmodule (B.flip.dualSubmodule (Submodule.span R (Set.range ⇑b)))) (Submodule.span R (Set.range ⇑b))","decl":"lemma dualSubmodule_dualSubmodule_flip_of_basis {ι : Type*} [Finite ι]\n    (hB : B.Nondegenerate) (b : Basis ι S M) :\n    B.dualSubmodule (B.flip.dualSubmodule (Submodule.span R (Set.range b))) =\n      Submodule.span R (Set.range b) := by\n  classical\n  letI := FiniteDimensional.of_fintype_basis b\n  rw [dualSubmodule_span_of_basis _ hB.flip, dualSubmodule_span_of_basis B hB,\n    dualBasis_dualBasis_flip B hB]\n\n"}
{"name":"LinearMap.BilinForm.dualSubmodule_flip_dualSubmodule_of_basis","module":"Mathlib.LinearAlgebra.BilinearForm.DualLattice","initialProofState":"R : Type u_4\nS : Type u_2\nM : Type u_3\ninst✝⁷ : CommRing R\ninst✝⁶ : Field S\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Algebra R S\ninst✝³ : Module R M\ninst✝² : Module S M\ninst✝¹ : IsScalarTower R S M\nB : LinearMap.BilinForm S M\nι : Type u_1\ninst✝ : Finite ι\nhB : B.Nondegenerate\nb : Basis ι S M\n⊢ Eq (B.flip.dualSubmodule (B.dualSubmodule (Submodule.span R (Set.range ⇑b)))) (Submodule.span R (Set.range ⇑b))","decl":"lemma dualSubmodule_flip_dualSubmodule_of_basis {ι : Type*} [Finite ι]\n    (hB : B.Nondegenerate) (b : Basis ι S M) :\n    B.flip.dualSubmodule (B.dualSubmodule (Submodule.span R (Set.range b))) =\n      Submodule.span R (Set.range b) := by\n  classical\n  letI := FiniteDimensional.of_fintype_basis b\n  rw [dualSubmodule_span_of_basis B hB, dualSubmodule_span_of_basis _ hB.flip,\n    dualBasis_flip_dualBasis B hB]\n\n"}
{"name":"LinearMap.BilinForm.dualSubmodule_dualSubmodule_of_basis","module":"Mathlib.LinearAlgebra.BilinearForm.DualLattice","initialProofState":"R : Type u_4\nS : Type u_2\nM : Type u_3\ninst✝⁷ : CommRing R\ninst✝⁶ : Field S\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Algebra R S\ninst✝³ : Module R M\ninst✝² : Module S M\ninst✝¹ : IsScalarTower R S M\nB : LinearMap.BilinForm S M\nι : Type u_1\ninst✝ : Finite ι\nhB : B.Nondegenerate\nhB' : B.IsSymm\nb : Basis ι S M\n⊢ Eq (B.dualSubmodule (B.dualSubmodule (Submodule.span R (Set.range ⇑b)))) (Submodule.span R (Set.range ⇑b))","decl":"lemma dualSubmodule_dualSubmodule_of_basis\n    {ι} [Finite ι] (hB : B.Nondegenerate) (hB' : B.IsSymm) (b : Basis ι S M) :\n    B.dualSubmodule (B.dualSubmodule (Submodule.span R (Set.range b))) =\n      Submodule.span R (Set.range b) := by\n  classical\n  letI := FiniteDimensional.of_fintype_basis b\n  rw [dualSubmodule_span_of_basis B hB, dualSubmodule_span_of_basis B hB,\n    dualBasis_dualBasis B hB hB']\n\n"}
