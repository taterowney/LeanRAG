{"name":"IsLeftRegular.pow","module":"Mathlib.Algebra.Regular.Pow","initialProofState":"R : Type u_1\na : R\ninst✝ : Monoid R\nn : Nat\nrla : IsLeftRegular a\n⊢ IsLeftRegular (HPow.hPow a n)","decl":"/-- Any power of a left-regular element is left-regular. -/\ntheorem IsLeftRegular.pow (n : ℕ) (rla : IsLeftRegular a) : IsLeftRegular (a ^ n) := by\n  simp only [IsLeftRegular, ← mul_left_iterate, rla.iterate n]\n\n"}
{"name":"IsRightRegular.pow","module":"Mathlib.Algebra.Regular.Pow","initialProofState":"R : Type u_1\na : R\ninst✝ : Monoid R\nn : Nat\nrra : IsRightRegular a\n⊢ IsRightRegular (HPow.hPow a n)","decl":"/-- Any power of a right-regular element is right-regular. -/\ntheorem IsRightRegular.pow (n : ℕ) (rra : IsRightRegular a) : IsRightRegular (a ^ n) := by\n  rw [IsRightRegular, ← mul_right_iterate]\n  exact rra.iterate n\n\n"}
{"name":"IsRegular.pow","module":"Mathlib.Algebra.Regular.Pow","initialProofState":"R : Type u_1\na : R\ninst✝ : Monoid R\nn : Nat\nra : IsRegular a\n⊢ IsRegular (HPow.hPow a n)","decl":"/-- Any power of a regular element is regular. -/\ntheorem IsRegular.pow (n : ℕ) (ra : IsRegular a) : IsRegular (a ^ n) :=\n  ⟨IsLeftRegular.pow n ra.left, IsRightRegular.pow n ra.right⟩\n\n"}
{"name":"IsLeftRegular.pow_iff","module":"Mathlib.Algebra.Regular.Pow","initialProofState":"R : Type u_1\na : R\ninst✝ : Monoid R\nn : Nat\nn0 : LT.lt 0 n\n⊢ Iff (IsLeftRegular (HPow.hPow a n)) (IsLeftRegular a)","decl":"/-- An element `a` is left-regular if and only if a positive power of `a` is left-regular. -/\ntheorem IsLeftRegular.pow_iff {n : ℕ} (n0 : 0 < n) : IsLeftRegular (a ^ n) ↔ IsLeftRegular a := by\n  refine ⟨?_, IsLeftRegular.pow n⟩\n  rw [← Nat.succ_pred_eq_of_pos n0, pow_succ]\n  exact IsLeftRegular.of_mul\n\n"}
{"name":"IsRightRegular.pow_iff","module":"Mathlib.Algebra.Regular.Pow","initialProofState":"R : Type u_1\na : R\ninst✝ : Monoid R\nn : Nat\nn0 : LT.lt 0 n\n⊢ Iff (IsRightRegular (HPow.hPow a n)) (IsRightRegular a)","decl":"/-- An element `a` is right-regular if and only if a positive power of `a` is right-regular. -/\ntheorem IsRightRegular.pow_iff {n : ℕ} (n0 : 0 < n) :\n    IsRightRegular (a ^ n) ↔ IsRightRegular a := by\n  refine ⟨?_, IsRightRegular.pow n⟩\n  rw [← Nat.succ_pred_eq_of_pos n0, pow_succ']\n  exact IsRightRegular.of_mul\n\n"}
{"name":"IsRegular.pow_iff","module":"Mathlib.Algebra.Regular.Pow","initialProofState":"R : Type u_1\na : R\ninst✝ : Monoid R\nn : Nat\nn0 : LT.lt 0 n\n⊢ Iff (IsRegular (HPow.hPow a n)) (IsRegular a)","decl":"/-- An element `a` is regular if and only if a positive power of `a` is regular. -/\ntheorem IsRegular.pow_iff {n : ℕ} (n0 : 0 < n) : IsRegular (a ^ n) ↔ IsRegular a :=\n  ⟨fun h => ⟨(IsLeftRegular.pow_iff n0).mp h.left, (IsRightRegular.pow_iff n0).mp h.right⟩, fun h =>\n    ⟨IsLeftRegular.pow n h.left, IsRightRegular.pow n h.right⟩⟩\n\n"}
{"name":"IsLeftRegular.prod","module":"Mathlib.Algebra.Regular.Pow","initialProofState":"ι : Type u_2\nR : Type u_3\ninst✝ : CommMonoid R\ns : Finset ι\nf : ι → R\nh : ∀ (i : ι), Membership.mem s i → IsLeftRegular (f i)\n⊢ IsLeftRegular (s.prod fun i => f i)","decl":"lemma IsLeftRegular.prod (h : ∀ i ∈ s, IsLeftRegular (f i)) :\n    IsLeftRegular (∏ i ∈ s, f i) :=\n  s.prod_induction _ _ (@IsLeftRegular.mul R _) isRegular_one.left h\n\n"}
{"name":"IsRightRegular.prod","module":"Mathlib.Algebra.Regular.Pow","initialProofState":"ι : Type u_2\nR : Type u_3\ninst✝ : CommMonoid R\ns : Finset ι\nf : ι → R\nh : ∀ (i : ι), Membership.mem s i → IsRightRegular (f i)\n⊢ IsRightRegular (s.prod fun i => f i)","decl":"lemma IsRightRegular.prod (h : ∀ i ∈ s, IsRightRegular (f i)) :\n    IsRightRegular (∏ i ∈ s, f i) :=\n  s.prod_induction _ _ (@IsRightRegular.mul R _) isRegular_one.right h\n\n"}
{"name":"IsRegular.prod","module":"Mathlib.Algebra.Regular.Pow","initialProofState":"ι : Type u_2\nR : Type u_3\ninst✝ : CommMonoid R\ns : Finset ι\nf : ι → R\nh : ∀ (i : ι), Membership.mem s i → IsRegular (f i)\n⊢ IsRegular (s.prod fun i => f i)","decl":"lemma IsRegular.prod (h : ∀ i ∈ s, IsRegular (f i)) :\n    IsRegular (∏ i ∈ s, f i) :=\n  ⟨IsLeftRegular.prod fun a ha ↦ (h a ha).left,\n   IsRightRegular.prod fun a ha ↦ (h a ha).right⟩\n\n"}
