{"name":"IsNonarchimedean.add_le","module":"Mathlib.Data.Real.IsNonarchimedean","initialProofState":"α : Type u_1\ninst✝ : Add α\nf : α → Real\nhf : ∀ (x : α), LE.le 0 (f x)\nhna : IsNonarchimedean f\na b : α\n⊢ LE.le (f (HAdd.hAdd a b)) (HAdd.hAdd (f a) (f b))","decl":"/-- A nonarchimedean function satisfies the triangle inequality. -/\ntheorem add_le {α : Type*} [Add α] {f : α → ℝ} (hf : ∀ x : α, 0 ≤ f x)\n    (hna : IsNonarchimedean f) {a b : α} : f (a + b) ≤ f a + f b := by\n  apply le_trans (hna _ _)\n  rw [max_le_iff, le_add_iff_nonneg_right, le_add_iff_nonneg_left]\n  exact ⟨hf _, hf _⟩\n\n"}
{"name":"IsNonarchimedean.nsmul_le","module":"Mathlib.Data.Real.IsNonarchimedean","initialProofState":"F : Type u_1\nα : Type u_2\ninst✝² : AddGroup α\ninst✝¹ : FunLike F α Real\ninst✝ : AddGroupSeminormClass F α Real\nf : F\nhna : IsNonarchimedean ⇑f\nn : Nat\na : α\n⊢ LE.le (f (HSMul.hSMul n a)) (f a)","decl":"/-- If `f` is a nonarchimedean additive group seminorm on `α`, then for every `n : ℕ` and `a : α`,\n  we have `f (n • a) ≤ (f a)`. -/\ntheorem nsmul_le {F α : Type*} [AddGroup α] [FunLike F α ℝ]\n    [AddGroupSeminormClass F α ℝ] {f : F} (hna : IsNonarchimedean f) {n : ℕ} {a : α} :\n    f (n • a) ≤ f a := by\n  let _ := AddGroupSeminormClass.toSeminormedAddGroup f\n  have := AddGroupSeminormClass.isUltrametricDist hna\n  simp only [← AddGroupSeminormClass.toSeminormedAddGroup_norm_eq]\n  exact norm_nsmul_le _ _\n\n"}
{"name":"IsNonarchimedean.nmul_le","module":"Mathlib.Data.Real.IsNonarchimedean","initialProofState":"F : Type u_1\nα : Type u_2\ninst✝² : Ring α\ninst✝¹ : FunLike F α Real\ninst✝ : AddGroupSeminormClass F α Real\nf : F\nhna : IsNonarchimedean ⇑f\nn : Nat\na : α\n⊢ LE.le (f (HMul.hMul (↑n) a)) (f a)","decl":"/-- If `f` is a nonarchimedean additive group seminorm on `α`, then for every `n : ℕ` and `a : α`,\n  we have `f (n * a) ≤ (f a)`. -/\ntheorem nmul_le {F α : Type*} [Ring α] [FunLike F α ℝ] [AddGroupSeminormClass F α ℝ]\n    {f : F} (hna : IsNonarchimedean f) {n : ℕ} {a : α} : f (n * a) ≤ f a := by\n  rw [← nsmul_eq_mul]\n  exact nsmul_le hna\n\n"}
{"name":"IsNonarchimedean.add_eq_max_of_ne","module":"Mathlib.Data.Real.IsNonarchimedean","initialProofState":"F : Type u_1\nα : Type u_2\ninst✝² : AddGroup α\ninst✝¹ : FunLike F α Real\ninst✝ : AddGroupSeminormClass F α Real\nf : F\nhna : IsNonarchimedean ⇑f\nx y : α\nhne : Ne (f x) (f y)\n⊢ Eq (f (HAdd.hAdd x y)) (Max.max (f x) (f y))","decl":"/-- If `f` is a nonarchimedean additive group seminorm on `α` and `x y : α` are such that\n  `f x ≠ f y`, then `f (x + y) = max (f x) (f y)`. -/\ntheorem add_eq_max_of_ne {F α : Type*} [AddGroup α] [FunLike F α ℝ]\n    [AddGroupSeminormClass F α ℝ] {f : F} (hna : IsNonarchimedean f) {x y : α} (hne : f x ≠ f y) :\n    f (x + y) = max (f x) (f y) := by\n  let _ := AddGroupSeminormClass.toSeminormedAddGroup f\n  have := AddGroupSeminormClass.isUltrametricDist hna\n  simp only [← AddGroupSeminormClass.toSeminormedAddGroup_norm_eq] at hne ⊢\n  exact norm_add_eq_max_of_norm_ne_norm hne\n\n"}
{"name":"IsNonarchimedean.finset_image_add","module":"Mathlib.Data.Real.IsNonarchimedean","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddCommGroup α\ninst✝² : FunLike F α Real\ninst✝¹ : AddGroupSeminormClass F α Real\ninst✝ : Nonempty β\nf : F\nhna : IsNonarchimedean ⇑f\ng : β → α\nt : Finset β\n⊢ Exists fun b => And (t.Nonempty → Membership.mem t b) (LE.le (f (t.sum g)) (f (g b)))","decl":"/-- Given a nonarchimedean additive group seminorm `f` on `α`, a function `g : β → α` and a finset\n  `t : Finset β`, we can always find `b : β`, belonging to `t` if `t` is nonempty, such that\n  `f (t.sum g) ≤ f (g b)` . -/\ntheorem finset_image_add {F α β : Type*} [AddCommGroup α] [FunLike F α ℝ]\n    [AddGroupSeminormClass F α ℝ] [Nonempty β] {f : F} (hna : IsNonarchimedean f)\n    (g : β → α) (t : Finset β) :\n    ∃ b : β, (t.Nonempty → b ∈ t) ∧ f (t.sum g) ≤ f (g b) := by\n  let _ := AddGroupSeminormClass.toSeminormedAddCommGroup f\n  have := AddGroupSeminormClass.isUltrametricDist hna\n  simp only [← AddGroupSeminormClass.toSeminormedAddCommGroup_norm_eq]\n  apply exists_norm_finset_sum_le\n\n"}
{"name":"IsNonarchimedean.finset_image_add_of_nonempty","module":"Mathlib.Data.Real.IsNonarchimedean","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddCommGroup α\ninst✝² : FunLike F α Real\ninst✝¹ : AddGroupSeminormClass F α Real\ninst✝ : Nonempty β\nf : F\nhna : IsNonarchimedean ⇑f\ng : β → α\nt : Finset β\nht : t.Nonempty\n⊢ Exists fun b => And (Membership.mem t b) (LE.le (f (t.sum g)) (f (g b)))","decl":"/-- Given a nonarchimedean additive group seminorm `f` on `α`, a function `g : β → α` and a\n  nonempty finset `t : Finset β`, we can always find `b : β` belonging to `t` such that\n  `f (t.sum g) ≤ f (g b)` . -/\ntheorem finset_image_add_of_nonempty {F α β : Type*} [AddCommGroup α] [FunLike F α ℝ]\n    [AddGroupSeminormClass F α ℝ] [Nonempty β] {f : F} (hna : IsNonarchimedean f)\n    (g : β → α) {t : Finset β} (ht : t.Nonempty) :\n    ∃ b : β, (b ∈ t) ∧ f (t.sum g) ≤ f (g b) := by\n  obtain ⟨b, hbt, hbf⟩ := finset_image_add hna g t\n  exact ⟨b, hbt ht, hbf⟩\n\n"}
{"name":"IsNonarchimedean.multiset_image_add","module":"Mathlib.Data.Real.IsNonarchimedean","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddCommGroup α\ninst✝² : FunLike F α Real\ninst✝¹ : AddGroupSeminormClass F α Real\ninst✝ : Nonempty β\nf : F\nhna : IsNonarchimedean ⇑f\ng : β → α\ns : Multiset β\n⊢ Exists fun b => And (Ne s 0 → Membership.mem s b) (LE.le (f (Multiset.map g s).sum) (f (g b)))","decl":"/-- Given a nonarchimedean additive group seminorm `f` on `α`, a function `g : β → α` and a\n  multiset `s : Multiset β`, we can always find `b : β`, belonging to `s` if `s` is nonempty,\n  such that `f (t.sum g) ≤ f (g b)` . -/\ntheorem multiset_image_add {F α β : Type*} [AddCommGroup α] [FunLike F α ℝ]\n    [AddGroupSeminormClass F α ℝ] [Nonempty β] {f : F} (hna : IsNonarchimedean f)\n    (g : β → α) (s : Multiset β) :\n    ∃ b : β, (s ≠ 0 → b ∈ s) ∧ f (Multiset.map g s).sum ≤ f (g b) := by\n  let _ := AddGroupSeminormClass.toSeminormedAddCommGroup f\n  have := AddGroupSeminormClass.isUltrametricDist hna\n  simp only [← AddGroupSeminormClass.toSeminormedAddCommGroup_norm_eq]\n  apply exists_norm_multiset_sum_le\n\n"}
{"name":"IsNonarchimedean.multiset_image_add_of_nonempty","module":"Mathlib.Data.Real.IsNonarchimedean","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddCommGroup α\ninst✝² : FunLike F α Real\ninst✝¹ : AddGroupSeminormClass F α Real\ninst✝ : Nonempty β\nf : F\nhna : IsNonarchimedean ⇑f\ng : β → α\ns : Multiset β\nhs : Ne s 0\n⊢ Exists fun b => And (Membership.mem s b) (LE.le (f (Multiset.map g s).sum) (f (g b)))","decl":"/-- Given a nonarchimedean additive group seminorm `f` on `α`, a function `g : β → α` and a\n  nonempty multiset `s : Multiset β`, we can always find `b : β` belonging to `s` such that\n  `f (t.sum g) ≤ f (g b)` . -/\ntheorem multiset_image_add_of_nonempty {F α β : Type*} [AddCommGroup α] [FunLike F α ℝ]\n    [AddGroupSeminormClass F α ℝ] [Nonempty β] {f : F} (hna : IsNonarchimedean f)\n    (g : β → α) {s : Multiset β} (hs : s ≠ 0) :\n    ∃ b : β, (b ∈ s) ∧ f (Multiset.map g s).sum ≤ f (g b) := by\n  obtain ⟨b, hbs, hbf⟩ := multiset_image_add hna g s\n  exact ⟨b, hbs hs, hbf⟩\n\n"}
{"name":"IsNonarchimedean.add_pow_le","module":"Mathlib.Data.Real.IsNonarchimedean","initialProofState":"F : Type u_1\nα : Type u_2\ninst✝² : CommRing α\ninst✝¹ : FunLike F α Real\ninst✝ : RingSeminormClass F α Real\nf : F\nhna : IsNonarchimedean ⇑f\nn : Nat\na b : α\n⊢ Exists fun m => And (LT.lt m (HAdd.hAdd n 1)) (LE.le (f (HPow.hPow (HAdd.hAdd a b) n)) (HMul.hMul (f (HPow.hPow a m)) (f (HPow.hPow b (HSub.hSub n m)))))","decl":"/-- If `f` is a nonarchimedean additive group seminorm on a commutative ring `α`, `n : ℕ`, and\n  `a b : α`, then we can find `m : ℕ` such that `m ≤ n` and\n  `f ((a + b) ^ n) ≤ (f (a ^ m)) * (f (b ^ (n - m)))`. -/\ntheorem add_pow_le {F α : Type*} [CommRing α] [FunLike F α ℝ]\n    [RingSeminormClass F α ℝ] {f : F} (hna : IsNonarchimedean f) (n : ℕ) (a b : α) :\n    ∃ m < n + 1, f ((a + b) ^ n) ≤ f (a ^ m) * f (b ^ (n - m)) := by\n  obtain ⟨m, hm_lt, hM⟩ := finset_image_add hna\n    (fun m => a ^ m * b ^ (n - m) * ↑(n.choose m)) (Finset.range (n + 1))\n  simp only [Finset.nonempty_range_iff, ne_eq, Nat.succ_ne_zero, not_false_iff, Finset.mem_range,\n    if_true, forall_true_left] at hm_lt\n  refine ⟨m, hm_lt, ?_⟩\n  simp only [← add_pow] at hM\n  rw [mul_comm] at hM\n  exact le_trans hM (le_trans (nmul_le hna) (map_mul_le_mul _ _ _))\n\n"}
