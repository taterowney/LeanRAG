{"name":"CategoryTheory.RepresentablyFlat.cofiltered","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.RepresentablyFlat F\nX : D\n‚ä¢ CategoryTheory.IsCofiltered (CategoryTheory.StructuredArrow X F)","decl":"/-- A functor `F : C ‚•§ D` is representably flat if the comma category `(X/F)` is cofiltered for\neach `X : D`.\n-/\nclass RepresentablyFlat (F : C ‚•§ D) : Prop where\n  cofiltered : ‚àÄ X : D, IsCofiltered (StructuredArrow X F)\n\n"}
{"name":"CategoryTheory.RepresentablyCoflat.filtered","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nself : CategoryTheory.RepresentablyCoflat F\nX : D\n‚ä¢ CategoryTheory.IsFiltered (CategoryTheory.CostructuredArrow F X)","decl":"/-- A functor `F : C ‚•§ D` is representably coflat if the comma category `(F/X)` is filtered for\neach `X : D`. -/\nclass RepresentablyCoflat (F : C ‚•§ D) : Prop where\n  filtered : ‚àÄ X : D, IsFiltered (CostructuredArrow F X)\n\n"}
{"name":"CategoryTheory.RepresentablyFlat.of_isRightAdjoint","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.IsRightAdjoint\n‚ä¢ CategoryTheory.RepresentablyFlat F","decl":"instance RepresentablyFlat.of_isRightAdjoint [F.IsRightAdjoint] : RepresentablyFlat F where\n  cofiltered _ := IsCofiltered.of_isInitial _ (mkInitialOfLeftAdjoint _ (.ofIsRightAdjoint F) _)\n\n"}
{"name":"CategoryTheory.RepresentablyCoflat.of_isLeftAdjoint","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.IsLeftAdjoint\n‚ä¢ CategoryTheory.RepresentablyCoflat F","decl":"instance RepresentablyCoflat.of_isLeftAdjoint [F.IsLeftAdjoint] : RepresentablyCoflat F where\n  filtered _ := IsFiltered.of_isTerminal _ (mkTerminalOfRightAdjoint _ (.ofIsLeftAdjoint F) _)\n\n"}
{"name":"CategoryTheory.RepresentablyFlat.id","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ CategoryTheory.RepresentablyFlat (CategoryTheory.Functor.id C)","decl":"theorem RepresentablyFlat.id : RepresentablyFlat (ùü≠ C) := inferInstance\n\n"}
{"name":"CategoryTheory.RepresentablyCoflat.id","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ CategoryTheory.RepresentablyCoflat (CategoryTheory.Functor.id C)","decl":"theorem RepresentablyCoflat.id : RepresentablyCoflat (ùü≠ C) := inferInstance\n\n-- this slow simp lemma causes a maxHeartbeats exception\n"}
{"name":"CategoryTheory.RepresentablyFlat.comp","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.RepresentablyFlat F\ninst‚úù : CategoryTheory.RepresentablyFlat G\n‚ä¢ CategoryTheory.RepresentablyFlat (F.comp G)","decl":"attribute [-simp] CostructuredArrow.right_eq_id in\n\ninstance RepresentablyFlat.comp (G : D ‚•§ E) [RepresentablyFlat F]\n    [RepresentablyFlat G] : RepresentablyFlat (F ‚ãô G) := by\n  refine ‚ü®fun X => IsCofiltered.of_cone_nonempty.{0} _ (fun {J} _ _ H => ?_)‚ü©\n  obtain ‚ü®c‚ÇÅ‚ü© := IsCofiltered.cone_nonempty (H ‚ãô StructuredArrow.pre X F G)\n  let H‚ÇÇ : J ‚•§ StructuredArrow c‚ÇÅ.pt.right F :=\n    { obj := fun j => StructuredArrow.mk (c‚ÇÅ.œÄ.app j).right\n      map := fun {j j'} f =>\n        StructuredArrow.homMk (H.map f).right (congrArg CommaMorphism.right (c‚ÇÅ.w f)) }\n  obtain ‚ü®c‚ÇÇ‚ü© := IsCofiltered.cone_nonempty H‚ÇÇ\n  simp only [H‚ÇÇ] at c‚ÇÇ\n  exact ‚ü®‚ü®StructuredArrow.mk (c‚ÇÅ.pt.hom ‚â´ G.map c‚ÇÇ.pt.hom),\n    ‚ü®fun j => StructuredArrow.homMk (c‚ÇÇ.œÄ.app j).right (by simp [‚Üê G.map_comp]),\n     fun j j' f => by simpa using (c‚ÇÇ.w f).symm‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.RepresentablyFlat.of_iso","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.RepresentablyFlat F\nG : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F G\n‚ä¢ CategoryTheory.RepresentablyFlat G","decl":"/-- Being a representably flat functor is closed under natural isomorphisms. -/\ntheorem RepresentablyFlat.of_iso [RepresentablyFlat F] {G : C ‚•§ D} (Œ± : F ‚âÖ G) :\n    RepresentablyFlat G where\n  cofiltered _ := IsCofiltered.of_equivalence (StructuredArrow.mapNatIso Œ±)\n\n"}
{"name":"CategoryTheory.RepresentablyCoflat.of_iso","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.RepresentablyCoflat F\nG : CategoryTheory.Functor C D\nŒ± : CategoryTheory.Iso F G\n‚ä¢ CategoryTheory.RepresentablyCoflat G","decl":"theorem RepresentablyCoflat.of_iso [RepresentablyCoflat F] {G : C ‚•§ D} (Œ± : F ‚âÖ G) :\n    RepresentablyCoflat G where\n  filtered _ := IsFiltered.of_equivalence (CostructuredArrow.mapNatIso Œ±)\n\n"}
{"name":"CategoryTheory.representablyCoflat_op_iff","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\n‚ä¢ Iff (CategoryTheory.RepresentablyCoflat F.op) (CategoryTheory.RepresentablyFlat F)","decl":"theorem representablyCoflat_op_iff : RepresentablyCoflat F.op ‚Üî RepresentablyFlat F := by\n  refine ‚ü®fun _ => ‚ü®fun X => ?_‚ü©, fun _ => ‚ü®fun ‚ü®X‚ü© => ?_‚ü©‚ü©\n  ¬∑ suffices IsFiltered (StructuredArrow X F)·µí·µñ from isCofiltered_of_isFiltered_op _\n    apply IsFiltered.of_equivalence (structuredArrowOpEquivalence _ _).symm\n  ¬∑ suffices IsCofiltered (CostructuredArrow F.op (op X))·µí·µñ from isFiltered_of_isCofiltered_op _\n    suffices IsCofiltered (StructuredArrow X F)·µí·µñ·µí·µñ from\n      IsCofiltered.of_equivalence (structuredArrowOpEquivalence _ _).op\n    apply IsCofiltered.of_equivalence (opOpEquivalence _)\n\n"}
{"name":"CategoryTheory.representablyFlat_op_iff","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\n‚ä¢ Iff (CategoryTheory.RepresentablyFlat F.op) (CategoryTheory.RepresentablyCoflat F)","decl":"theorem representablyFlat_op_iff : RepresentablyFlat F.op ‚Üî RepresentablyCoflat F := by\n  refine ‚ü®fun _ => ‚ü®fun X => ?_‚ü©, fun _ => ‚ü®fun ‚ü®X‚ü© => ?_‚ü©‚ü©\n  ¬∑ suffices IsCofiltered (CostructuredArrow F X)·µí·µñ from isFiltered_of_isCofiltered_op _\n    apply IsCofiltered.of_equivalence (costructuredArrowOpEquivalence _ _).symm\n  ¬∑ suffices IsFiltered (StructuredArrow (op X) F.op)·µí·µñ from isCofiltered_of_isFiltered_op _\n    suffices IsFiltered (CostructuredArrow F X)·µí·µñ·µí·µñ from\n      IsFiltered.of_equivalence (costructuredArrowOpEquivalence _ _).op\n    apply IsFiltered.of_equivalence (opOpEquivalence _)\n\n"}
{"name":"CategoryTheory.instRepresentablyCoflatOppositeOpOfRepresentablyFlat","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.RepresentablyFlat F\n‚ä¢ CategoryTheory.RepresentablyCoflat F.op","decl":"instance [RepresentablyFlat F] : RepresentablyCoflat F.op :=\n  (representablyCoflat_op_iff F).2 inferInstance\n\n"}
{"name":"CategoryTheory.instRepresentablyFlatOppositeOpOfRepresentablyCoflat","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.RepresentablyCoflat F\n‚ä¢ CategoryTheory.RepresentablyFlat F.op","decl":"instance [RepresentablyCoflat F] : RepresentablyFlat F.op :=\n  (representablyFlat_op_iff F).2 inferInstance\n\n"}
{"name":"CategoryTheory.RepresentablyCoflat.comp","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.RepresentablyCoflat F\ninst‚úù : CategoryTheory.RepresentablyCoflat G\n‚ä¢ CategoryTheory.RepresentablyCoflat (F.comp G)","decl":"instance RepresentablyCoflat.comp (G : D ‚•§ E) [RepresentablyCoflat F] [RepresentablyCoflat G] :\n    RepresentablyCoflat (F ‚ãô G) :=\n  (representablyFlat_op_iff _).1 <| inferInstanceAs <| RepresentablyFlat (F.op ‚ãô G.op)\n\n"}
{"name":"CategoryTheory.final_of_representablyFlat","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nh : CategoryTheory.RepresentablyFlat F\n‚ä¢ F.Final","decl":"lemma final_of_representablyFlat [h : RepresentablyFlat F] : F.Final where\n  out _ := IsCofiltered.isConnected _\n\n"}
{"name":"CategoryTheory.initial_of_representablyCoflat","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nh : CategoryTheory.RepresentablyCoflat F\n‚ä¢ F.Initial","decl":"lemma initial_of_representablyCoflat [h : RepresentablyCoflat F] : F.Initial where\n  out _ := IsFiltered.isConnected _\n\n"}
{"name":"CategoryTheory.flat_of_preservesFiniteLimits","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteLimits C\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.PreservesFiniteLimits F\n‚ä¢ CategoryTheory.RepresentablyFlat F","decl":"theorem flat_of_preservesFiniteLimits [HasFiniteLimits C] (F : C ‚•§ D) [PreservesFiniteLimits F] :\n    RepresentablyFlat F :=\n  ‚ü®fun X =>\n    haveI : HasFiniteLimits (StructuredArrow X F) := by\n      apply hasFiniteLimits_of_hasFiniteLimits_of_size.{v‚ÇÅ} (StructuredArrow X F)\n      intro J sJ fJ\n      constructor\n      -- Porting note: instance was inferred automatically in Lean 3\n      infer_instance\n    IsCofiltered.of_hasFiniteLimits _‚ü©\n\n"}
{"name":"CategoryTheory.coflat_of_preservesFiniteColimits","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteColimits C\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.PreservesFiniteColimits F\n‚ä¢ CategoryTheory.RepresentablyCoflat F","decl":"theorem coflat_of_preservesFiniteColimits [HasFiniteColimits C] (F : C ‚•§ D)\n    [PreservesFiniteColimits F] : RepresentablyCoflat F :=\n  let _ := preservesFiniteLimits_op F\n  (representablyFlat_op_iff _).1 (flat_of_preservesFiniteLimits _)\n\n"}
{"name":"CategoryTheory.PreservesFiniteLimitsOfFlat.fac","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type v‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.SmallCategory J\ninst‚úù¬π : CategoryTheory.FinCategory J\nK : CategoryTheory.Functor J C\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.RepresentablyFlat F\nc : CategoryTheory.Limits.Cone K\nhc : CategoryTheory.Limits.IsLimit c\ns : CategoryTheory.Limits.Cone (K.comp F)\nx : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.PreservesFiniteLimitsOfFlat.lift F hc s) ((F.mapCone c).œÄ.app x)) (s.œÄ.app x)","decl":"theorem fac (x : J) : lift F hc s ‚â´ (F.mapCone c).œÄ.app x = s.œÄ.app x := by\n  simp [lift, ‚Üê Functor.map_comp]\n\n"}
{"name":"CategoryTheory.PreservesFiniteLimitsOfFlat.uniq","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : Type v‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.SmallCategory J\ninst‚úù¬π : CategoryTheory.FinCategory J\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.RepresentablyFlat F\nK : CategoryTheory.Functor J C\nc : CategoryTheory.Limits.Cone K\nhc : CategoryTheory.Limits.IsLimit c\ns : CategoryTheory.Limits.Cone (K.comp F)\nf‚ÇÅ f‚ÇÇ : Quiver.Hom s.pt (F.obj c.pt)\nh‚ÇÅ : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp f‚ÇÅ ((F.mapCone c).œÄ.app j)) (s.œÄ.app j)\nh‚ÇÇ : ‚àÄ (j : J), Eq (CategoryTheory.CategoryStruct.comp f‚ÇÇ ((F.mapCone c).œÄ.app j)) (s.œÄ.app j)\n‚ä¢ Eq f‚ÇÅ f‚ÇÇ","decl":"theorem uniq {K : J ‚•§ C} {c : Cone K} (hc : IsLimit c) (s : Cone (K ‚ãô F))\n    (f‚ÇÅ f‚ÇÇ : s.pt ‚ü∂ F.obj c.pt) (h‚ÇÅ : ‚àÄ j : J, f‚ÇÅ ‚â´ (F.mapCone c).œÄ.app j = s.œÄ.app j)\n    (h‚ÇÇ : ‚àÄ j : J, f‚ÇÇ ‚â´ (F.mapCone c).œÄ.app j = s.œÄ.app j) : f‚ÇÅ = f‚ÇÇ := by\n  -- We can make two cones over the diagram of `s` via `f‚ÇÅ` and `f‚ÇÇ`.\n  let Œ±‚ÇÅ : (F.mapCone c).toStructuredArrow ‚ãô map f‚ÇÅ ‚ü∂ s.toStructuredArrow :=\n    { app := fun X => eqToHom (by simp [‚Üê h‚ÇÅ]) }\n  let Œ±‚ÇÇ : (F.mapCone c).toStructuredArrow ‚ãô map f‚ÇÇ ‚ü∂ s.toStructuredArrow :=\n    { app := fun X => eqToHom (by simp [‚Üê h‚ÇÇ]) }\n  let c‚ÇÅ : Cone (s.toStructuredArrow ‚ãô pre s.pt K F) :=\n    (Cones.postcompose (whiskerRight Œ±‚ÇÅ (pre s.pt K F) :)).obj (c.toStructuredArrowCone F f‚ÇÅ)\n  let c‚ÇÇ : Cone (s.toStructuredArrow ‚ãô pre s.pt K F) :=\n    (Cones.postcompose (whiskerRight Œ±‚ÇÇ (pre s.pt K F) :)).obj (c.toStructuredArrowCone F f‚ÇÇ)\n  -- The two cones can then be combined and we may obtain a cone over the two cones since\n  -- `StructuredArrow s.pt F` is cofiltered.\n  let c‚ÇÄ := IsCofiltered.cone (biconeMk _ c‚ÇÅ c‚ÇÇ)\n  let g‚ÇÅ : c‚ÇÄ.pt ‚ü∂ c‚ÇÅ.pt := c‚ÇÄ.œÄ.app Bicone.left\n  let g‚ÇÇ : c‚ÇÄ.pt ‚ü∂ c‚ÇÇ.pt := c‚ÇÄ.œÄ.app Bicone.right\n  -- Then `g‚ÇÅ.right` and `g‚ÇÇ.right` are two maps from the same cone into the `c`.\n  have : ‚àÄ j : J, g‚ÇÅ.right ‚â´ c.œÄ.app j = g‚ÇÇ.right ‚â´ c.œÄ.app j := by\n    intro j\n    injection c‚ÇÄ.œÄ.naturality (BiconeHom.left j) with _ e‚ÇÅ\n    injection c‚ÇÄ.œÄ.naturality (BiconeHom.right j) with _ e‚ÇÇ\n    convert e‚ÇÅ.symm.trans e‚ÇÇ <;> simp [c‚ÇÅ, c‚ÇÇ]\n  have : c.extend g‚ÇÅ.right = c.extend g‚ÇÇ.right := by\n    unfold Cone.extend\n    congr 1\n    ext x\n    apply this\n  -- And thus they are equal as `c` is the limit.\n  have : g‚ÇÅ.right = g‚ÇÇ.right := calc\n    g‚ÇÅ.right = hc.lift (c.extend g‚ÇÅ.right) := by\n      apply hc.uniq (c.extend _)\n      -- Porting note: was `by tidy`, but `aesop` only works if max heartbeats\n      -- is increased, so we replace it by the output of `tidy?`\n      intro j; rfl\n    _ = hc.lift (c.extend g‚ÇÇ.right) := by\n      congr\n    _ = g‚ÇÇ.right := by\n      symm\n      apply hc.uniq (c.extend _)\n      -- Porting note: was `by tidy`, but `aesop` only works if max heartbeats\n      -- is increased, so we replace it by the output of `tidy?`\n      intro _; rfl\n\n  -- Finally, since `f·µ¢` factors through `F(g·µ¢)`, the result follows.\n  calc\n    f‚ÇÅ = ùüô _ ‚â´ f‚ÇÅ := by simp\n    _ = c‚ÇÄ.pt.hom ‚â´ F.map g‚ÇÅ.right := g‚ÇÅ.w\n    _ = c‚ÇÄ.pt.hom ‚â´ F.map g‚ÇÇ.right := by rw [this]\n    _ = ùüô _ ‚â´ f‚ÇÇ := g‚ÇÇ.w.symm\n    _ = f‚ÇÇ := by simp\n\n"}
{"name":"CategoryTheory.preservesFiniteLimits_of_flat","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.RepresentablyFlat F\n‚ä¢ CategoryTheory.Limits.PreservesFiniteLimits F","decl":"/-- Representably flat functors preserve finite limits. -/\nlemma preservesFiniteLimits_of_flat (F : C ‚•§ D) [RepresentablyFlat F] :\n    PreservesFiniteLimits F := by\n  apply preservesFiniteLimits_of_preservesFiniteLimitsOfSize\n  intro J _ _; constructor\n  intro K; constructor\n  intro c hc\n  constructor\n  exact\n    { lift := PreservesFiniteLimitsOfFlat.lift F hc\n      fac := PreservesFiniteLimitsOfFlat.fac F hc\n      uniq := fun s m h => by\n        apply PreservesFiniteLimitsOfFlat.uniq F hc\n        ¬∑ exact h\n        ¬∑ exact PreservesFiniteLimitsOfFlat.fac F hc s }\n\n"}
{"name":"CategoryTheory.preservesFiniteColimits_of_coflat","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.RepresentablyCoflat F\n‚ä¢ CategoryTheory.Limits.PreservesFiniteColimits F","decl":"/-- Representably coflat functors preserve finite colimits. -/\nlemma preservesFiniteColimits_of_coflat (F : C ‚•§ D) [RepresentablyCoflat F] :\n    PreservesFiniteColimits F :=\n  letI _ := preservesFiniteLimits_of_flat F.op\n  preservesFiniteColimits_of_op _\n\n"}
{"name":"CategoryTheory.preservesFiniteLimits_iff_flat","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.Limits.HasFiniteLimits C\nF : CategoryTheory.Functor C D\n‚ä¢ Iff (CategoryTheory.RepresentablyFlat F) (CategoryTheory.Limits.PreservesFiniteLimits F)","decl":"/-- If `C` is finitely complete, then `F : C ‚•§ D` is representably flat iff it preserves\nfinite limits.\n-/\nlemma preservesFiniteLimits_iff_flat [HasFiniteLimits C] (F : C ‚•§ D) :\n    RepresentablyFlat F ‚Üî PreservesFiniteLimits F :=\n  ‚ü®fun _ ‚Ü¶ preservesFiniteLimits_of_flat F, fun _ ‚Ü¶ flat_of_preservesFiniteLimits F‚ü©\n\n"}
{"name":"CategoryTheory.preservesFiniteColimits_iff_coflat","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù : CategoryTheory.Limits.HasFiniteColimits C\nF : CategoryTheory.Functor C D\n‚ä¢ Iff (CategoryTheory.RepresentablyCoflat F) (CategoryTheory.Limits.PreservesFiniteColimits F)","decl":"/-- If `C` is finitely cocomplete, then `F : C ‚•§ D` is representably coflat iff it preserves\nfinite colmits. -/\nlemma preservesFiniteColimits_iff_coflat [HasFiniteColimits C] (F : C ‚•§ D) :\n    RepresentablyCoflat F ‚Üî PreservesFiniteColimits F :=\n  ‚ü®fun _ => preservesFiniteColimits_of_coflat F, fun _ => coflat_of_preservesFiniteColimits F‚ü©\n\n"}
{"name":"CategoryTheory.lan_preservesFiniteLimits_of_flat","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C D : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.SmallCategory C\ninst‚úù¬≥ : CategoryTheory.SmallCategory D\nE : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÅ, u‚ÇÇ} E\ninst‚úù¬π : CategoryTheory.Limits.HasColimits E\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.RepresentablyFlat F\n‚ä¢ CategoryTheory.Limits.PreservesFiniteLimits F.op.lan","decl":"/-- If `F : C ‚•§ D` is a representably flat functor between small categories, then the functor\n`Lan F.op` that takes presheaves over `C` to presheaves over `D` preserves finite limits.\n-/\nnoncomputable instance lan_preservesFiniteLimits_of_flat (F : C ‚•§ D) [RepresentablyFlat F] :\n    PreservesFiniteLimits (F.op.lan : _ ‚•§ D·µí·µñ ‚•§ E) := by\n  apply preservesFiniteLimits_of_preservesFiniteLimitsOfSize.{u‚ÇÅ}\n  intro J _ _\n  apply preservesLimitsOfShape_of_evaluation (F.op.lan : (C·µí·µñ ‚•§ E) ‚•§ D·µí·µñ ‚•§ E) J\n  intro K\n  haveI : IsFiltered (CostructuredArrow F.op K) :=\n    IsFiltered.of_equivalence (structuredArrowOpEquivalence F (unop K))\n  exact preservesLimitsOfShape_of_natIso (lanEvaluationIsoColim _ _ _).symm\n\n"}
{"name":"CategoryTheory.lan_flat_of_flat","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C D : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.SmallCategory C\ninst‚úù‚Å¥ : CategoryTheory.SmallCategory D\nE : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{u‚ÇÅ, u‚ÇÇ} E\ninst‚úù¬≤ : CategoryTheory.Limits.HasLimits E\ninst‚úù¬π : CategoryTheory.Limits.HasColimits E\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.RepresentablyFlat F\n‚ä¢ CategoryTheory.RepresentablyFlat F.op.lan","decl":"instance lan_flat_of_flat (F : C ‚•§ D) [RepresentablyFlat F] :\n    RepresentablyFlat (F.op.lan : _ ‚•§ D·µí·µñ ‚•§ E) :=\n  flat_of_preservesFiniteLimits _\n\n"}
{"name":"CategoryTheory.lan_preservesFiniteLimits_of_preservesFiniteLimits","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C D : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.SmallCategory C\ninst‚úù¬≥ : CategoryTheory.SmallCategory D\nE : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{u‚ÇÅ, u‚ÇÇ} E\ninst‚úù¬π : CategoryTheory.Limits.HasColimits E\nF : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.Limits.PreservesFiniteLimits F\n‚ä¢ CategoryTheory.Limits.PreservesFiniteLimits F.op.lan","decl":"instance lan_preservesFiniteLimits_of_preservesFiniteLimits (F : C ‚•§ D)\n    [PreservesFiniteLimits F] : PreservesFiniteLimits (F.op.lan : _ ‚•§ D·µí·µñ ‚•§ E) := by\n  haveI := flat_of_preservesFiniteLimits F\n  infer_instance\n\n"}
{"name":"CategoryTheory.flat_iff_lan_flat","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C D : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.SmallCategory C\ninst‚úù¬π : CategoryTheory.SmallCategory D\ninst‚úù : CategoryTheory.Limits.HasFiniteLimits C\nF : CategoryTheory.Functor C D\n‚ä¢ Iff (CategoryTheory.RepresentablyFlat F) (CategoryTheory.RepresentablyFlat F.op.lan)","decl":"theorem flat_iff_lan_flat (F : C ‚•§ D) :\n    RepresentablyFlat F ‚Üî RepresentablyFlat (F.op.lan : _ ‚•§ D·µí·µñ ‚•§ Type u‚ÇÅ) :=\n  ‚ü®fun _ => inferInstance, fun H => by\n    haveI := preservesFiniteLimits_of_flat (F.op.lan : _ ‚•§ D·µí·µñ ‚•§ Type u‚ÇÅ)\n    haveI : PreservesFiniteLimits F := by\n      apply preservesFiniteLimits_of_preservesFiniteLimitsOfSize.{u‚ÇÅ}\n      intros; apply preservesLimit_of_lan_preservesLimit\n    apply flat_of_preservesFiniteLimits‚ü©\n\n"}
{"name":"CategoryTheory.preservesFiniteLimits_iff_lan_preservesFiniteLimits","module":"Mathlib.CategoryTheory.Functor.Flat","initialProofState":"C D : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.SmallCategory C\ninst‚úù¬π : CategoryTheory.SmallCategory D\ninst‚úù : CategoryTheory.Limits.HasFiniteLimits C\nF : CategoryTheory.Functor C D\n‚ä¢ Iff (CategoryTheory.Limits.PreservesFiniteLimits F) (CategoryTheory.Limits.PreservesFiniteLimits F.op.lan)","decl":"/-- If `C` is finitely complete, then `F : C ‚•§ D` preserves finite limits iff\n`Lan F.op : (C·µí·µñ ‚•§ Type*) ‚•§ (D·µí·µñ ‚•§ Type*)` preserves finite limits.\n-/\nlemma preservesFiniteLimits_iff_lan_preservesFiniteLimits (F : C ‚•§ D) :\n    PreservesFiniteLimits F ‚Üî PreservesFiniteLimits (F.op.lan : _ ‚•§ D·µí·µñ ‚•§ Type u‚ÇÅ) :=\n  ‚ü®fun _ ‚Ü¶ inferInstance,\n    fun _ ‚Ü¶ preservesFiniteLimits_of_preservesFiniteLimitsOfSize.{u‚ÇÅ} _\n      (fun _ _ _ ‚Ü¶ preservesLimit_of_lan_preservesLimit _ _)‚ü©\n\n"}
