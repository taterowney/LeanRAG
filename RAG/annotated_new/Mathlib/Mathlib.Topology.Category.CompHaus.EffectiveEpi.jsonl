{"name":"CompHaus.effectiveEpi_tfae","module":"Mathlib.Topology.Category.CompHaus.EffectiveEpi","initialProofState":"B X : CompHaus\nπ : Quiver.Hom X B\n⊢ (List.cons (CategoryTheory.EffectiveEpi π) (List.cons (CategoryTheory.Epi π) (List.cons (Function.Surjective ⇑π) List.nil))).TFAE","decl":"open List in\ntheorem effectiveEpi_tfae\n    {B X : CompHaus.{u}} (π : X ⟶ B) :\n    TFAE\n    [ EffectiveEpi π\n    , Epi π\n    , Function.Surjective π\n    ] := by\n  tfae_have 1 → 2 := fun _ ↦ inferInstance\n  tfae_have 2 ↔ 3 := epi_iff_surjective π\n  tfae_have 3 → 1 := fun hπ ↦ ⟨⟨effectiveEpiStruct π hπ⟩⟩\n  tfae_finish\n\n"}
{"name":"CompHaus.instPreregular","module":"Mathlib.Topology.Category.CompHaus.EffectiveEpi","initialProofState":"⊢ CategoryTheory.Preregular CompHaus","decl":"instance : Preregular CompHaus :=\n  preregular fun _ _ _ ↦ ((effectiveEpi_tfae _).out 0 2).mp\n\n"}
{"name":"CompHaus.effectiveEpiFamily_tfae","module":"Mathlib.Topology.Category.CompHaus.EffectiveEpi","initialProofState":"α : Type\ninst✝ : Finite α\nB : CompHaus\nX : α → CompHaus\nπ : (a : α) → Quiver.Hom (X a) B\n⊢ (List.cons (CategoryTheory.EffectiveEpiFamily X π) (List.cons (CategoryTheory.Epi (CategoryTheory.Limits.Sigma.desc π)) (List.cons (∀ (b : ↑B.toTop), Exists fun a => Exists fun x => Eq ((π a) x) b) List.nil))).TFAE","decl":"open List in\ntheorem effectiveEpiFamily_tfae\n    {α : Type} [Finite α] {B : CompHaus.{u}}\n    (X : α → CompHaus.{u}) (π : (a : α) → (X a ⟶ B)) :\n    TFAE\n    [ EffectiveEpiFamily X π\n    , Epi (Sigma.desc π)\n    , ∀ b : B, ∃ (a : α) (x : X a), π a x = b\n    ] := by\n  tfae_have 2 → 1\n  | _ => by\n    simpa [← effectiveEpi_desc_iff_effectiveEpiFamily, (effectiveEpi_tfae (Sigma.desc π)).out 0 1]\n  tfae_have 1 → 2\n  | _ => inferInstance\n  tfae_have 3 → 2\n  | e => by\n    rw [epi_iff_surjective]\n    intro b\n    obtain ⟨t, x, h⟩ := e b\n    refine ⟨Sigma.ι X t x, ?_⟩\n    change (Sigma.ι X t ≫ Sigma.desc π) x = _\n    simpa using h\n  tfae_have 2 → 3\n  | e => by\n    rw [epi_iff_surjective] at e\n    let i : ∐ X ≅ finiteCoproduct X :=\n      (colimit.isColimit _).coconePointUniqueUpToIso (finiteCoproduct.isColimit _)\n    intro b\n    obtain ⟨t, rfl⟩ := e b\n    let q := i.hom t\n    refine ⟨q.1,q.2,?_⟩\n    have : t = i.inv (i.hom t) := show t = (i.hom ≫ i.inv) t by simp only [i.hom_inv_id]; rfl\n    rw [this]\n    show _ = (i.inv ≫ Sigma.desc π) (i.hom t)\n    suffices i.inv ≫ Sigma.desc π = finiteCoproduct.desc X π by\n      rw [this]; rfl\n    rw [Iso.inv_comp_eq]\n    apply colimit.hom_ext\n    rintro ⟨a⟩\n    simp only [i, Discrete.functor_obj, colimit.ι_desc, Cofan.mk_pt, Cofan.mk_ι_app,\n      colimit.comp_coconePointUniqueUpToIso_hom_assoc]\n    ext; rfl\n  tfae_finish\n\n"}
{"name":"CompHaus.effectiveEpiFamily_of_jointly_surjective","module":"Mathlib.Topology.Category.CompHaus.EffectiveEpi","initialProofState":"α : Type\ninst✝ : Finite α\nB : CompHaus\nX : α → CompHaus\nπ : (a : α) → Quiver.Hom (X a) B\nsurj : ∀ (b : ↑B.toTop), Exists fun a => Exists fun x => Eq ((π a) x) b\n⊢ CategoryTheory.EffectiveEpiFamily X π","decl":"theorem effectiveEpiFamily_of_jointly_surjective\n    {α : Type} [Finite α] {B : CompHaus.{u}}\n    (X : α → CompHaus.{u}) (π : (a : α) → (X a ⟶ B))\n    (surj : ∀ b : B, ∃ (a : α) (x : X a), π a x = b) :\n    EffectiveEpiFamily X π :=\n  ((effectiveEpiFamily_tfae X π).out 2 0).mp surj\n\n"}
