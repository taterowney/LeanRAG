{"name":"AlternatingMap.domCoprod.summand_mk''","module":"Mathlib.LinearAlgebra.Alternating.DomCoprod","initialProofState":"ιa : Type u_1\nιb : Type u_2\ninst✝¹⁰ : Fintype ιa\ninst✝⁹ : Fintype ιb\nR' : Type u_3\nMᵢ : Type u_4\nN₁ : Type u_5\nN₂ : Type u_6\ninst✝⁸ : CommSemiring R'\ninst✝⁷ : AddCommGroup N₁\ninst✝⁶ : Module R' N₁\ninst✝⁵ : AddCommGroup N₂\ninst✝⁴ : Module R' N₂\ninst✝³ : AddCommMonoid Mᵢ\ninst✝² : Module R' Mᵢ\ninst✝¹ : DecidableEq ιa\ninst✝ : DecidableEq ιb\na : AlternatingMap R' Mᵢ N₁ ιa\nb : AlternatingMap R' Mᵢ N₂ ιb\nσ : Equiv.Perm (Sum ιa ιb)\n⊢ Eq (AlternatingMap.domCoprod.summand a b (Quotient.mk'' σ)) (HSMul.hSMul (Equiv.Perm.sign σ) (MultilinearMap.domDomCongr σ ((↑a).domCoprod ↑b)))","decl":"theorem domCoprod.summand_mk'' (a : Mᵢ [⋀^ιa]→ₗ[R'] N₁) (b : Mᵢ [⋀^ιb]→ₗ[R'] N₂)\n    (σ : Equiv.Perm (ιa ⊕ ιb)) :\n    domCoprod.summand a b (Quotient.mk'' σ) =\n      Equiv.Perm.sign σ •\n        (MultilinearMap.domCoprod ↑a ↑b : MultilinearMap R' (fun _ => Mᵢ) (N₁ ⊗ N₂)).domDomCongr\n          σ :=\n  rfl\n\n"}
{"name":"AlternatingMap.domCoprod.summand_add_swap_smul_eq_zero","module":"Mathlib.LinearAlgebra.Alternating.DomCoprod","initialProofState":"ιa : Type u_1\nιb : Type u_2\ninst✝¹⁰ : Fintype ιa\ninst✝⁹ : Fintype ιb\nR' : Type u_3\nMᵢ : Type u_4\nN₁ : Type u_5\nN₂ : Type u_6\ninst✝⁸ : CommSemiring R'\ninst✝⁷ : AddCommGroup N₁\ninst✝⁶ : Module R' N₁\ninst✝⁵ : AddCommGroup N₂\ninst✝⁴ : Module R' N₂\ninst✝³ : AddCommMonoid Mᵢ\ninst✝² : Module R' Mᵢ\ninst✝¹ : DecidableEq ιa\ninst✝ : DecidableEq ιb\na : AlternatingMap R' Mᵢ N₁ ιa\nb : AlternatingMap R' Mᵢ N₂ ιb\nσ : Equiv.Perm.ModSumCongr ιa ιb\nv : Sum ιa ιb → Mᵢ\ni j : Sum ιa ιb\nhv : Eq (v i) (v j)\nhij : Ne i j\n⊢ Eq (HAdd.hAdd ((AlternatingMap.domCoprod.summand a b σ) v) ((AlternatingMap.domCoprod.summand a b (HSMul.hSMul (Equiv.swap i j) σ)) v)) 0","decl":"/-- Swapping elements in `σ` with equal values in `v` results in an addition that cancels -/\ntheorem domCoprod.summand_add_swap_smul_eq_zero (a : Mᵢ [⋀^ιa]→ₗ[R'] N₁)\n    (b : Mᵢ [⋀^ιb]→ₗ[R'] N₂) (σ : Perm.ModSumCongr ιa ιb) {v : ιa ⊕ ιb → Mᵢ}\n    {i j : ιa ⊕ ιb} (hv : v i = v j) (hij : i ≠ j) :\n    domCoprod.summand a b σ v + domCoprod.summand a b (swap i j • σ) v = 0 := by\n  refine Quotient.inductionOn' σ fun σ => ?_\n  dsimp only [Quotient.liftOn'_mk'', Quotient.map'_mk'', MulAction.Quotient.smul_mk,\n    domCoprod.summand]\n  rw [smul_eq_mul, Perm.sign_mul, Perm.sign_swap hij]\n  simp only [one_mul, neg_mul, Function.comp_apply, Units.neg_smul, Perm.coe_mul, Units.val_neg,\n    MultilinearMap.smul_apply, MultilinearMap.neg_apply, MultilinearMap.domDomCongr_apply,\n    MultilinearMap.domCoprod_apply]\n  convert add_neg_cancel (G := N₁ ⊗[R'] N₂) _ using 6 <;>\n    · ext k\n      rw [Equiv.apply_swap_eq_self hv]\n\n"}
{"name":"AlternatingMap.domCoprod.summand_eq_zero_of_smul_invariant","module":"Mathlib.LinearAlgebra.Alternating.DomCoprod","initialProofState":"ιa : Type u_1\nιb : Type u_2\ninst✝¹⁰ : Fintype ιa\ninst✝⁹ : Fintype ιb\nR' : Type u_3\nMᵢ : Type u_4\nN₁ : Type u_5\nN₂ : Type u_6\ninst✝⁸ : CommSemiring R'\ninst✝⁷ : AddCommGroup N₁\ninst✝⁶ : Module R' N₁\ninst✝⁵ : AddCommGroup N₂\ninst✝⁴ : Module R' N₂\ninst✝³ : AddCommMonoid Mᵢ\ninst✝² : Module R' Mᵢ\ninst✝¹ : DecidableEq ιa\ninst✝ : DecidableEq ιb\na : AlternatingMap R' Mᵢ N₁ ιa\nb : AlternatingMap R' Mᵢ N₂ ιb\nσ : Equiv.Perm.ModSumCongr ιa ιb\nv : Sum ιa ιb → Mᵢ\ni j : Sum ιa ιb\nhv : Eq (v i) (v j)\nhij : Ne i j\na✝ : Eq (HSMul.hSMul (Equiv.swap i j) σ) σ\n⊢ Eq ((AlternatingMap.domCoprod.summand a b σ) v) 0","decl":"/-- Swapping elements in `σ` with equal values in `v` result in zero if the swap has no effect\non the quotient. -/\ntheorem domCoprod.summand_eq_zero_of_smul_invariant (a : Mᵢ [⋀^ιa]→ₗ[R'] N₁)\n    (b : Mᵢ [⋀^ιb]→ₗ[R'] N₂) (σ : Perm.ModSumCongr ιa ιb) {v : ιa ⊕ ιb → Mᵢ}\n    {i j : ιa ⊕ ιb} (hv : v i = v j) (hij : i ≠ j) :\n    swap i j • σ = σ → domCoprod.summand a b σ v = 0 := by\n  refine Quotient.inductionOn' σ fun σ => ?_\n  dsimp only [Quotient.liftOn'_mk'', Quotient.map'_mk'', MultilinearMap.smul_apply,\n    MultilinearMap.domDomCongr_apply, MultilinearMap.domCoprod_apply, domCoprod.summand]\n  intro hσ\n  cases' hi : σ⁻¹ i with val val <;> cases' hj : σ⁻¹ j with val_1 val_1 <;>\n    rw [Perm.inv_eq_iff_eq] at hi hj <;> substs hi hj <;> revert val val_1\n  -- Porting note: `on_goal` is not available in `case _ | _ =>`, so the proof gets tedious.\n  -- the term pairs with and cancels another term\n  case inl.inr =>\n    intro i' j' _ _ hσ\n    obtain ⟨⟨sl, sr⟩, hσ⟩ := QuotientGroup.leftRel_apply.mp (Quotient.exact' hσ)\n    replace hσ := Equiv.congr_fun hσ (Sum.inl i')\n    dsimp only at hσ\n    rw [smul_eq_mul, ← mul_swap_eq_swap_mul, mul_inv_rev, swap_inv, inv_mul_cancel_right] at hσ\n    simp at hσ\n  case inr.inl =>\n    intro i' j' _ _ hσ\n    obtain ⟨⟨sl, sr⟩, hσ⟩ := QuotientGroup.leftRel_apply.mp (Quotient.exact' hσ)\n    replace hσ := Equiv.congr_fun hσ (Sum.inr i')\n    dsimp only at hσ\n    rw [smul_eq_mul, ← mul_swap_eq_swap_mul, mul_inv_rev, swap_inv, inv_mul_cancel_right] at hσ\n    simp at hσ\n  -- the term does not pair but is zero\n  case inr.inr =>\n    intro i' j' hv hij _\n    convert smul_zero (M := ℤˣ) (A := N₁ ⊗[R'] N₂) _\n    convert TensorProduct.tmul_zero (R := R') (M := N₁) N₂ _\n    exact AlternatingMap.map_eq_zero_of_eq _ _ hv fun hij' => hij (hij' ▸ rfl)\n  case inl.inl =>\n    intro i' j' hv hij _\n    convert smul_zero (M := ℤˣ) (A := N₁ ⊗[R'] N₂) _\n    convert TensorProduct.zero_tmul (R := R') N₁ (N := N₂) _\n    exact AlternatingMap.map_eq_zero_of_eq _ _ hv fun hij' => hij (hij' ▸ rfl)\n\n"}
{"name":"AlternatingMap.domCoprod_apply","module":"Mathlib.LinearAlgebra.Alternating.DomCoprod","initialProofState":"ιa : Type u_1\nιb : Type u_2\ninst✝¹⁰ : Fintype ιa\ninst✝⁹ : Fintype ιb\nR' : Type u_3\nMᵢ : Type u_4\nN₁ : Type u_5\nN₂ : Type u_6\ninst✝⁸ : CommSemiring R'\ninst✝⁷ : AddCommGroup N₁\ninst✝⁶ : Module R' N₁\ninst✝⁵ : AddCommGroup N₂\ninst✝⁴ : Module R' N₂\ninst✝³ : AddCommMonoid Mᵢ\ninst✝² : Module R' Mᵢ\ninst✝¹ : DecidableEq ιa\ninst✝ : DecidableEq ιb\na : AlternatingMap R' Mᵢ N₁ ιa\nb : AlternatingMap R' Mᵢ N₂ ιb\nv : Sum ιa ιb → Mᵢ\n⊢ Eq ((a.domCoprod b) v) ((Finset.univ.sum fun σ => AlternatingMap.domCoprod.summand a b σ) v)","decl":"/-- Like `MultilinearMap.domCoprod`, but ensures the result is also alternating.\n\nNote that this is usually defined (for instance, as used in Proposition 22.24 in [Gallier2011Notes])\nover integer indices `ιa = Fin n` and `ιb = Fin m`, as\n$$\n(f \\wedge g)(u_1, \\ldots, u_{m+n}) =\n  \\sum_{\\operatorname{shuffle}(m, n)} \\operatorname{sign}(\\sigma)\n    f(u_{\\sigma(1)}, \\ldots, u_{\\sigma(m)}) g(u_{\\sigma(m+1)}, \\ldots, u_{\\sigma(m+n)}),\n$$\nwhere $\\operatorname{shuffle}(m, n)$ consists of all permutations of $[1, m+n]$ such that\n$\\sigma(1) < \\cdots < \\sigma(m)$ and $\\sigma(m+1) < \\cdots < \\sigma(m+n)$.\n\nHere, we generalize this by replacing:\n* the product in the sum with a tensor product\n* the filtering of $[1, m+n]$ to shuffles with an isomorphic quotient\n* the additions in the subscripts of $\\sigma$ with an index of type `Sum`\n\nThe specialized version can be obtained by combining this definition with `finSumFinEquiv` and\n`LinearMap.mul'`.\n-/\n@[simps]\ndef domCoprod (a : Mᵢ [⋀^ιa]→ₗ[R'] N₁) (b : Mᵢ [⋀^ιb]→ₗ[R'] N₂) :\n    Mᵢ [⋀^ιa ⊕ ιb]→ₗ[R'] (N₁ ⊗[R'] N₂) :=\n  { ∑ σ : Perm.ModSumCongr ιa ιb, domCoprod.summand a b σ with\n    toFun := fun v => (⇑(∑ σ : Perm.ModSumCongr ιa ιb, domCoprod.summand a b σ)) v\n    map_eq_zero_of_eq' := fun v i j hv hij => by\n      dsimp only\n      rw [MultilinearMap.sum_apply]\n      exact\n        Finset.sum_involution (fun σ _ => Equiv.swap i j • σ)\n          (fun σ _ => domCoprod.summand_add_swap_smul_eq_zero a b σ hv hij)\n          (fun σ _ => mt <| domCoprod.summand_eq_zero_of_smul_invariant a b σ hv hij)\n          (fun σ _ => Finset.mem_univ _) fun σ _ =>\n          Equiv.swap_smul_involutive i j σ }\n\n"}
{"name":"AlternatingMap.domCoprod_coe","module":"Mathlib.LinearAlgebra.Alternating.DomCoprod","initialProofState":"ιa : Type u_1\nιb : Type u_2\ninst✝¹⁰ : Fintype ιa\ninst✝⁹ : Fintype ιb\nR' : Type u_3\nMᵢ : Type u_4\nN₁ : Type u_5\nN₂ : Type u_6\ninst✝⁸ : CommSemiring R'\ninst✝⁷ : AddCommGroup N₁\ninst✝⁶ : Module R' N₁\ninst✝⁵ : AddCommGroup N₂\ninst✝⁴ : Module R' N₂\ninst✝³ : AddCommMonoid Mᵢ\ninst✝² : Module R' Mᵢ\ninst✝¹ : DecidableEq ιa\ninst✝ : DecidableEq ιb\na : AlternatingMap R' Mᵢ N₁ ιa\nb : AlternatingMap R' Mᵢ N₂ ιb\n⊢ Eq (↑(a.domCoprod b)) (Finset.univ.sum fun σ => AlternatingMap.domCoprod.summand a b σ)","decl":"theorem domCoprod_coe (a : Mᵢ [⋀^ιa]→ₗ[R'] N₁) (b : Mᵢ [⋀^ιb]→ₗ[R'] N₂) :\n    (↑(a.domCoprod b) : MultilinearMap R' (fun _ => Mᵢ) _) =\n      ∑ σ : Perm.ModSumCongr ιa ιb, domCoprod.summand a b σ :=\n  MultilinearMap.ext fun _ => rfl\n\n"}
{"name":"AlternatingMap.domCoprod'_apply","module":"Mathlib.LinearAlgebra.Alternating.DomCoprod","initialProofState":"ιa : Type u_1\nιb : Type u_2\ninst✝¹⁰ : Fintype ιa\ninst✝⁹ : Fintype ιb\nR' : Type u_3\nMᵢ : Type u_4\nN₁ : Type u_5\nN₂ : Type u_6\ninst✝⁸ : CommSemiring R'\ninst✝⁷ : AddCommGroup N₁\ninst✝⁶ : Module R' N₁\ninst✝⁵ : AddCommGroup N₂\ninst✝⁴ : Module R' N₂\ninst✝³ : AddCommMonoid Mᵢ\ninst✝² : Module R' Mᵢ\ninst✝¹ : DecidableEq ιa\ninst✝ : DecidableEq ιb\na : AlternatingMap R' Mᵢ N₁ ιa\nb : AlternatingMap R' Mᵢ N₂ ιb\n⊢ Eq (AlternatingMap.domCoprod' (TensorProduct.tmul R' a b)) (a.domCoprod b)","decl":"@[simp]\ntheorem domCoprod'_apply (a : Mᵢ [⋀^ιa]→ₗ[R'] N₁) (b : Mᵢ [⋀^ιb]→ₗ[R'] N₂) :\n    domCoprod' (a ⊗ₜ[R'] b) = domCoprod a b :=\n  rfl\n\n"}
{"name":"MultilinearMap.domCoprod_alternization_coe","module":"Mathlib.LinearAlgebra.Alternating.DomCoprod","initialProofState":"ιa : Type u_1\nιb : Type u_2\ninst✝¹⁰ : Fintype ιa\ninst✝⁹ : Fintype ιb\nR' : Type u_3\nMᵢ : Type u_4\nN₁ : Type u_5\nN₂ : Type u_6\ninst✝⁸ : CommSemiring R'\ninst✝⁷ : AddCommGroup N₁\ninst✝⁶ : Module R' N₁\ninst✝⁵ : AddCommGroup N₂\ninst✝⁴ : Module R' N₂\ninst✝³ : AddCommMonoid Mᵢ\ninst✝² : Module R' Mᵢ\ninst✝¹ : DecidableEq ιa\ninst✝ : DecidableEq ιb\na : MultilinearMap R' (fun x => Mᵢ) N₁\nb : MultilinearMap R' (fun x => Mᵢ) N₂\n⊢ Eq ((↑(MultilinearMap.alternatization a)).domCoprod ↑(MultilinearMap.alternatization b)) (Finset.univ.sum fun σa => Finset.univ.sum fun σb => HSMul.hSMul (Equiv.Perm.sign σa) (HSMul.hSMul (Equiv.Perm.sign σb) ((MultilinearMap.domDomCongr σa a).domCoprod (MultilinearMap.domDomCongr σb b))))","decl":"/-- A helper lemma for `MultilinearMap.domCoprod_alternization`. -/\ntheorem MultilinearMap.domCoprod_alternization_coe [DecidableEq ιa] [DecidableEq ιb]\n    (a : MultilinearMap R' (fun _ : ιa => Mᵢ) N₁) (b : MultilinearMap R' (fun _ : ιb => Mᵢ) N₂) :\n    MultilinearMap.domCoprod (MultilinearMap.alternatization a)\n      (MultilinearMap.alternatization b) =\n      ∑ σa : Perm ιa, ∑ σb : Perm ιb,\n        Equiv.Perm.sign σa • Equiv.Perm.sign σb •\n          MultilinearMap.domCoprod (a.domDomCongr σa) (b.domDomCongr σb) := by\n  simp_rw [← MultilinearMap.domCoprod'_apply, MultilinearMap.alternatization_coe]\n  simp_rw [TensorProduct.sum_tmul, TensorProduct.tmul_sum, _root_.map_sum,\n    ← TensorProduct.smul_tmul', TensorProduct.tmul_smul]\n  rfl\n\n"}
{"name":"MultilinearMap.domCoprod_alternization","module":"Mathlib.LinearAlgebra.Alternating.DomCoprod","initialProofState":"ιa : Type u_1\nιb : Type u_2\ninst✝¹⁰ : Fintype ιa\ninst✝⁹ : Fintype ιb\nR' : Type u_3\nMᵢ : Type u_4\nN₁ : Type u_5\nN₂ : Type u_6\ninst✝⁸ : CommSemiring R'\ninst✝⁷ : AddCommGroup N₁\ninst✝⁶ : Module R' N₁\ninst✝⁵ : AddCommGroup N₂\ninst✝⁴ : Module R' N₂\ninst✝³ : AddCommMonoid Mᵢ\ninst✝² : Module R' Mᵢ\ninst✝¹ : DecidableEq ιa\ninst✝ : DecidableEq ιb\na : MultilinearMap R' (fun x => Mᵢ) N₁\nb : MultilinearMap R' (fun x => Mᵢ) N₂\n⊢ Eq (MultilinearMap.alternatization (a.domCoprod b)) ((MultilinearMap.alternatization a).domCoprod (MultilinearMap.alternatization b))","decl":"/-- Computing the `MultilinearMap.alternatization` of the `MultilinearMap.domCoprod` is the same\nas computing the `AlternatingMap.domCoprod` of the `MultilinearMap.alternatization`s.\n-/\ntheorem MultilinearMap.domCoprod_alternization [DecidableEq ιa] [DecidableEq ιb]\n    (a : MultilinearMap R' (fun _ : ιa => Mᵢ) N₁) (b : MultilinearMap R' (fun _ : ιb => Mᵢ) N₂) :\n    MultilinearMap.alternatization (MultilinearMap.domCoprod a b) =\n      a.alternatization.domCoprod (MultilinearMap.alternatization b) := by\n  apply coe_multilinearMap_injective\n  rw [domCoprod_coe, MultilinearMap.alternatization_coe,\n    Finset.sum_partition (QuotientGroup.leftRel (Perm.sumCongrHom ιa ιb).range)]\n  congr 1\n  ext1 σ\n  refine Quotient.inductionOn' σ fun σ => ?_\n  -- unfold the quotient mess left by `Finset.sum_partition`\n  -- Porting note: Was `conv in .. => ..`.\n  rw\n    [@Finset.filter_congr _ _ _ (fun a => @Quotient.decidableEq _ _\n      (QuotientGroup.leftRelDecidable (MonoidHom.range (Perm.sumCongrHom ιa ιb)))\n      (Quotient.mk (QuotientGroup.leftRel (MonoidHom.range (Perm.sumCongrHom ιa ιb))) a)\n      (Quotient.mk'' σ)) _ (s := Finset.univ)\n    fun x _ => QuotientGroup.eq (s := MonoidHom.range (Perm.sumCongrHom ιa ιb)) (a := x) (b := σ)]\n  -- eliminate a multiplication\n  rw [← Finset.map_univ_equiv (Equiv.mulLeft σ), Finset.filter_map, Finset.sum_map]\n  simp_rw [Equiv.coe_toEmbedding, Equiv.coe_mulLeft, Function.comp_def, mul_inv_rev,\n    inv_mul_cancel_right, Subgroup.inv_mem_iff, MonoidHom.mem_range, Finset.univ_filter_exists,\n    Finset.sum_image Perm.sumCongrHom_injective.injOn]\n  -- now we're ready to clean up the RHS, pulling out the summation\n  rw [domCoprod.summand_mk'', MultilinearMap.domCoprod_alternization_coe, ← Finset.sum_product',\n    Finset.univ_product_univ, ← MultilinearMap.domDomCongrEquiv_apply, _root_.map_sum,\n    Finset.smul_sum]\n  congr 1\n  ext1 ⟨al, ar⟩\n  dsimp only\n  -- pull out the pair of smuls on the RHS, by rewriting to `_ →ₗ[ℤ] _` and back\n  rw [← AddEquiv.coe_toAddMonoidHom, ← AddMonoidHom.coe_toIntLinearMap, LinearMap.map_smul_of_tower,\n    LinearMap.map_smul_of_tower, AddMonoidHom.coe_toIntLinearMap, AddEquiv.coe_toAddMonoidHom,\n    MultilinearMap.domDomCongrEquiv_apply]\n  -- pick up the pieces\n  rw [MultilinearMap.domDomCongr_mul, Perm.sign_mul, Perm.sumCongrHom_apply,\n    MultilinearMap.domCoprod_domDomCongr_sumCongr, Perm.sign_sumCongr, mul_smul, mul_smul]\n\n"}
{"name":"MultilinearMap.domCoprod_alternization_eq","module":"Mathlib.LinearAlgebra.Alternating.DomCoprod","initialProofState":"ιa : Type u_1\nιb : Type u_2\ninst✝¹⁰ : Fintype ιa\ninst✝⁹ : Fintype ιb\nR' : Type u_3\nMᵢ : Type u_4\nN₁ : Type u_5\nN₂ : Type u_6\ninst✝⁸ : CommSemiring R'\ninst✝⁷ : AddCommGroup N₁\ninst✝⁶ : Module R' N₁\ninst✝⁵ : AddCommGroup N₂\ninst✝⁴ : Module R' N₂\ninst✝³ : AddCommMonoid Mᵢ\ninst✝² : Module R' Mᵢ\ninst✝¹ : DecidableEq ιa\ninst✝ : DecidableEq ιb\na : AlternatingMap R' Mᵢ N₁ ιa\nb : AlternatingMap R' Mᵢ N₂ ιb\n⊢ Eq (MultilinearMap.alternatization ((↑a).domCoprod ↑b)) (HSMul.hSMul (HMul.hMul (Fintype.card ιa).factorial (Fintype.card ιb).factorial) (a.domCoprod b))","decl":"/-- Taking the `MultilinearMap.alternatization` of the `MultilinearMap.domCoprod` of two\n`AlternatingMap`s gives a scaled version of the `AlternatingMap.coprod` of those maps.\n-/\ntheorem MultilinearMap.domCoprod_alternization_eq [DecidableEq ιa] [DecidableEq ιb]\n    (a : Mᵢ [⋀^ιa]→ₗ[R'] N₁) (b : Mᵢ [⋀^ιb]→ₗ[R'] N₂) :\n    MultilinearMap.alternatization\n      (MultilinearMap.domCoprod a b : MultilinearMap R' (fun _ : ιa ⊕ ιb => Mᵢ) (N₁ ⊗ N₂)) =\n      ((Fintype.card ιa).factorial * (Fintype.card ιb).factorial) • a.domCoprod b := by\n  rw [MultilinearMap.domCoprod_alternization, coe_alternatization, coe_alternatization, mul_smul,\n    ← AlternatingMap.domCoprod'_apply, ← AlternatingMap.domCoprod'_apply,\n    ← TensorProduct.smul_tmul', TensorProduct.tmul_smul,\n    LinearMap.map_smul_of_tower AlternatingMap.domCoprod',\n    LinearMap.map_smul_of_tower AlternatingMap.domCoprod']\n"}
