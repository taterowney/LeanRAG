{"name":"CategoryTheory.Kleisli.Adjunction.toKleisli_obj","module":"Mathlib.CategoryTheory.Monad.Kleisli","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nT : CategoryTheory.Monad C\nX : C\n⊢ Eq ((CategoryTheory.Kleisli.Adjunction.toKleisli T).obj X) X","decl":"/-- The left adjoint of the adjunction which induces the monad `(T, η_ T, μ_ T)`. -/\n@[simps]\ndef toKleisli : C ⥤ Kleisli T where\n  obj X := (X : Kleisli T)\n  map {X} {Y} f := (f ≫ T.η.app Y : X ⟶ T.obj Y)\n  map_comp {X} {Y} {Z} f g := by\n    -- Porting note: hack for missing unfold_projs tactic\n    change _ = (f ≫ (Monad.η T).app Y) ≫ T.map (g ≫ (Monad.η T).app Z) ≫ T.μ.app Z\n    simp [← T.η.naturality g]\n\n"}
{"name":"CategoryTheory.Kleisli.Adjunction.toKleisli_map","module":"Mathlib.CategoryTheory.Monad.Kleisli","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nT : CategoryTheory.Monad C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.Kleisli.Adjunction.toKleisli T).map f) (CategoryTheory.CategoryStruct.comp f (T.η.app Y))","decl":"/-- The left adjoint of the adjunction which induces the monad `(T, η_ T, μ_ T)`. -/\n@[simps]\ndef toKleisli : C ⥤ Kleisli T where\n  obj X := (X : Kleisli T)\n  map {X} {Y} f := (f ≫ T.η.app Y : X ⟶ T.obj Y)\n  map_comp {X} {Y} {Z} f g := by\n    -- Porting note: hack for missing unfold_projs tactic\n    change _ = (f ≫ (Monad.η T).app Y) ≫ T.map (g ≫ (Monad.η T).app Z) ≫ T.μ.app Z\n    simp [← T.η.naturality g]\n\n"}
{"name":"CategoryTheory.Kleisli.Adjunction.fromKleisli_obj","module":"Mathlib.CategoryTheory.Monad.Kleisli","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nT : CategoryTheory.Monad C\nX : CategoryTheory.Kleisli T\n⊢ Eq ((CategoryTheory.Kleisli.Adjunction.fromKleisli T).obj X) (T.obj X)","decl":"/-- The right adjoint of the adjunction which induces the monad `(T, η_ T, μ_ T)`. -/\n@[simps]\ndef fromKleisli : Kleisli T ⥤ C where\n  obj X := T.obj X\n  map {_} {Y} f := T.map f ≫ T.μ.app Y\n  map_id _ := T.right_unit _\n  map_comp {X} {Y} {Z} f g := by\n    -- Porting note: hack for missing unfold_projs tactic\n    change T.map (f ≫ T.map g ≫ T.μ.app Z) ≫ T.μ.app Z = _\n    simp only [Functor.map_comp, Category.assoc]\n    rw [← T.μ.naturality_assoc g, T.assoc]\n    rfl\n\n"}
{"name":"CategoryTheory.Kleisli.Adjunction.fromKleisli_map","module":"Mathlib.CategoryTheory.Monad.Kleisli","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nT : CategoryTheory.Monad C\nx✝ Y : CategoryTheory.Kleisli T\nf : Quiver.Hom x✝ Y\n⊢ Eq ((CategoryTheory.Kleisli.Adjunction.fromKleisli T).map f) (CategoryTheory.CategoryStruct.comp (T.map f) (T.μ.app Y))","decl":"/-- The right adjoint of the adjunction which induces the monad `(T, η_ T, μ_ T)`. -/\n@[simps]\ndef fromKleisli : Kleisli T ⥤ C where\n  obj X := T.obj X\n  map {_} {Y} f := T.map f ≫ T.μ.app Y\n  map_id _ := T.right_unit _\n  map_comp {X} {Y} {Z} f g := by\n    -- Porting note: hack for missing unfold_projs tactic\n    change T.map (f ≫ T.map g ≫ T.μ.app Z) ≫ T.μ.app Z = _\n    simp only [Functor.map_comp, Category.assoc]\n    rw [← T.μ.naturality_assoc g, T.assoc]\n    rfl\n\n"}
{"name":"CategoryTheory.Cokleisli.Adjunction.toCokleisli_map","module":"Mathlib.CategoryTheory.Monad.Kleisli","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nU : CategoryTheory.Comonad C\nX x✝ : C\nf : Quiver.Hom X x✝\n⊢ Eq ((CategoryTheory.Cokleisli.Adjunction.toCokleisli U).map f) (CategoryTheory.CategoryStruct.comp (U.ε.app X) f)","decl":"/-- The right adjoint of the adjunction which induces the comonad `(U, ε_ U, δ_ U)`. -/\n@[simps]\ndef toCokleisli : C ⥤ Cokleisli U where\n  obj X := (X : Cokleisli U)\n  map {X} {_} f := (U.ε.app X ≫ f :)\n  map_comp {X} {Y} {_} f g := by\n    -- Porting note: working around lack of unfold_projs\n    change U.ε.app X ≫ f ≫ g = U.δ.app X ≫ U.map (U.ε.app X ≫ f) ≫ U.ε.app Y ≫ g\n    simp [← U.ε.naturality g]\n\n"}
{"name":"CategoryTheory.Cokleisli.Adjunction.toCokleisli_obj","module":"Mathlib.CategoryTheory.Monad.Kleisli","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nU : CategoryTheory.Comonad C\nX : C\n⊢ Eq ((CategoryTheory.Cokleisli.Adjunction.toCokleisli U).obj X) X","decl":"/-- The right adjoint of the adjunction which induces the comonad `(U, ε_ U, δ_ U)`. -/\n@[simps]\ndef toCokleisli : C ⥤ Cokleisli U where\n  obj X := (X : Cokleisli U)\n  map {X} {_} f := (U.ε.app X ≫ f :)\n  map_comp {X} {Y} {_} f g := by\n    -- Porting note: working around lack of unfold_projs\n    change U.ε.app X ≫ f ≫ g = U.δ.app X ≫ U.map (U.ε.app X ≫ f) ≫ U.ε.app Y ≫ g\n    simp [← U.ε.naturality g]\n\n"}
{"name":"CategoryTheory.Cokleisli.Adjunction.fromCokleisli_map","module":"Mathlib.CategoryTheory.Monad.Kleisli","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nU : CategoryTheory.Comonad C\nX x✝ : CategoryTheory.Cokleisli U\nf : Quiver.Hom X x✝\n⊢ Eq ((CategoryTheory.Cokleisli.Adjunction.fromCokleisli U).map f) (CategoryTheory.CategoryStruct.comp (U.δ.app X) (U.map f))","decl":"/-- The left adjoint of the adjunction which induces the comonad `(U, ε_ U, δ_ U)`. -/\n@[simps]\ndef fromCokleisli : Cokleisli U ⥤ C where\n  obj X := U.obj X\n  map {X} {_} f := U.δ.app X ≫ U.map f\n  map_id _ := U.right_counit _\n  map_comp {X} {Y} {_} f g := by\n    -- Porting note: working around lack of unfold_projs\n    change U.δ.app X ≫ U.map (U.δ.app X ≫ U.map f ≫ g) =\n      (U.δ.app X ≫ U.map f) ≫ (U.δ.app Y ≫ U.map g)\n    simp only [Functor.map_comp, ← Category.assoc]\n    rw [Comonad.coassoc]\n    simp only [Category.assoc, NatTrans.naturality, Functor.comp_map]\n\n"}
{"name":"CategoryTheory.Cokleisli.Adjunction.fromCokleisli_obj","module":"Mathlib.CategoryTheory.Monad.Kleisli","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nU : CategoryTheory.Comonad C\nX : CategoryTheory.Cokleisli U\n⊢ Eq ((CategoryTheory.Cokleisli.Adjunction.fromCokleisli U).obj X) (U.obj X)","decl":"/-- The left adjoint of the adjunction which induces the comonad `(U, ε_ U, δ_ U)`. -/\n@[simps]\ndef fromCokleisli : Cokleisli U ⥤ C where\n  obj X := U.obj X\n  map {X} {_} f := U.δ.app X ≫ U.map f\n  map_id _ := U.right_counit _\n  map_comp {X} {Y} {_} f g := by\n    -- Porting note: working around lack of unfold_projs\n    change U.δ.app X ≫ U.map (U.δ.app X ≫ U.map f ≫ g) =\n      (U.δ.app X ≫ U.map f) ≫ (U.δ.app Y ≫ U.map g)\n    simp only [Functor.map_comp, ← Category.assoc]\n    rw [Comonad.coassoc]\n    simp only [Category.assoc, NatTrans.naturality, Functor.comp_map]\n\n"}
