{"name":"CategoryTheory.Limits.PullbackCone.mono_snd_of_is_pullback_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nt : CategoryTheory.Limits.PullbackCone f g\nht : CategoryTheory.Limits.IsLimit t\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.Mono t.snd","decl":"/-- Monomorphisms are stable under pullback in the first argument. -/\ntheorem mono_snd_of_is_pullback_of_mono {t : PullbackCone f g} (ht : IsLimit t) [Mono f] :\n    Mono t.snd := by\n  refine ⟨fun {W} h k i => IsLimit.hom_ext ht ?_ i⟩\n  rw [← cancel_mono f, Category.assoc, Category.assoc, condition]\n  apply reassoc_of% i\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.mono_fst_of_is_pullback_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nt : CategoryTheory.Limits.PullbackCone f g\nht : CategoryTheory.Limits.IsLimit t\ninst✝ : CategoryTheory.Mono g\n⊢ CategoryTheory.Mono t.fst","decl":"/-- Monomorphisms are stable under pullback in the second argument. -/\ntheorem mono_fst_of_is_pullback_of_mono {t : PullbackCone f g} (ht : IsLimit t) [Mono g] :\n    Mono t.fst := by\n  refine ⟨fun {W} h k i => IsLimit.hom_ext ht i ?_⟩\n  rw [← cancel_mono g, Category.assoc, Category.assoc, ← condition]\n  apply reassoc_of% i\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.mono_of_isLimitMkIdId","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nt : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.PullbackCone.mk (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X) ⋯)\n⊢ CategoryTheory.Mono f","decl":"/--\n`f` is a mono if the pullback cone `(𝟙 X, 𝟙 X)` is a limit for the pair `(f, f)`. The converse is\ngiven in `PullbackCone.is_id_of_mono`.\n-/\ntheorem mono_of_isLimitMkIdId (f : X ⟶ Y) (t : IsLimit (mk (𝟙 X) (𝟙 X) rfl : PullbackCone f f)) :\n    Mono f :=\n  ⟨fun {Z} g h eq => by\n    rcases PullbackCone.IsLimit.lift' t _ _ eq with ⟨_, rfl, rfl⟩\n    rfl⟩\n\n"}
{"name":"CategoryTheory.Limits.pullback.fst_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Mono g\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.pullback.fst f g)","decl":"/-- The pullback of a monomorphism is a monomorphism -/\ninstance pullback.fst_of_mono {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} [HasPullback f g] [Mono g] :\n    Mono (pullback.fst f g) :=\n  PullbackCone.mono_fst_of_is_pullback_of_mono (limit.isLimit _)\n\n"}
{"name":"CategoryTheory.Limits.pullback.snd_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.pullback.snd f g)","decl":"/-- The pullback of a monomorphism is a monomorphism -/\ninstance pullback.snd_of_mono {X Y Z : C} {f : X ⟶ Z} {g : Y ⟶ Z} [HasPullback f g] [Mono f] :\n    Mono (pullback.snd f g) :=\n  PullbackCone.mono_snd_of_is_pullback_of_mono (limit.isLimit _)\n\n"}
{"name":"CategoryTheory.Limits.mono_pullback_to_prod","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasBinaryProduct X Y\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.snd f g))","decl":"/-- The map `X ×[Z] Y ⟶ X × Y` is mono. -/\ninstance mono_pullback_to_prod {C : Type*} [Category C] {X Y Z : C} (f : X ⟶ Z) (g : Y ⟶ Z)\n    [HasPullback f g] [HasBinaryProduct X Y] :\n    Mono (prod.lift (pullback.fst f g) (pullback.snd f g)) :=\n  ⟨fun {W} i₁ i₂ h => by\n    ext\n    · simpa using congrArg (fun f => f ≫ prod.fst) h\n    · simpa using congrArg (fun f => f ≫ prod.snd) h⟩\n\n"}
{"name":"CategoryTheory.Limits.hasPullback_of_comp_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\ni : Quiver.Hom W Z\ninst✝¹ : CategoryTheory.Mono i\ninst✝ : CategoryTheory.Limits.HasPullback f g\n⊢ CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)","decl":"instance hasPullback_of_comp_mono (f : X ⟶ W) (g : Y ⟶ W) (i : W ⟶ Z) [Mono i] [HasPullback f g] :\n    HasPullback (f ≫ i) (g ≫ i) :=\n  ⟨⟨⟨_, pullbackIsPullbackOfCompMono f g i⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.hasPullback_of_right_factors_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nW X Z : C\nf : Quiver.Hom X Z\ni : Quiver.Hom Z W\n⊢ CategoryTheory.Limits.HasPullback i (CategoryTheory.CategoryStruct.comp f i)","decl":"instance hasPullback_of_right_factors_mono : HasPullback i (f ≫ i) := by\n  simpa only [Category.id_comp] using hasPullback_of_comp_mono (𝟙 Z) f i\n\n"}
{"name":"CategoryTheory.Limits.pullback_snd_iso_of_right_factors_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nW X Z : C\nf : Quiver.Hom X Z\ni : Quiver.Hom Z W\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.pullback.snd i (CategoryTheory.CategoryStruct.comp f i))","decl":"instance pullback_snd_iso_of_right_factors_mono :\n    IsIso (pullback.snd i (f ≫ i)) := by\n  have := limit.isoLimitCone_hom_π ⟨_, pullbackIsPullbackOfCompMono (𝟙 _) f i⟩ WalkingCospan.right\n  convert (congrArg IsIso (show _ ≫ pullback.snd (𝟙 Z) f = _ from this)).mp inferInstance\n  · exact (Category.id_comp _).symm\n  · exact (Category.id_comp _).symm\n\n"}
{"name":"CategoryTheory.Limits.hasPullback_of_left_factors_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nW X Z : C\nf : Quiver.Hom X Z\ni : Quiver.Hom Z W\n⊢ CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp f i) i","decl":"instance hasPullback_of_left_factors_mono : HasPullback (f ≫ i) i := by\n  simpa only [Category.id_comp] using hasPullback_of_comp_mono f (𝟙 Z) i\n\n"}
{"name":"CategoryTheory.Limits.pullback_snd_iso_of_left_factors_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nW X Z : C\nf : Quiver.Hom X Z\ni : Quiver.Hom Z W\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp f i) i)","decl":"instance pullback_snd_iso_of_left_factors_mono :\n    IsIso (pullback.fst (f ≫ i) i) := by\n  have := limit.isoLimitCone_hom_π ⟨_, pullbackIsPullbackOfCompMono f (𝟙 _) i⟩ WalkingCospan.left\n  convert (congrArg IsIso (show _ ≫ pullback.fst f (𝟙 Z) = _ from this)).mp inferInstance\n  · exact (Category.id_comp _).symm\n  · exact (Category.id_comp _).symm\n\n"}
{"name":"CategoryTheory.Limits.has_kernel_pair_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.Limits.HasPullback f f","decl":"instance has_kernel_pair_of_mono : HasPullback f f :=\n  ⟨⟨⟨_, PullbackCone.isLimitMkIdId f⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.fst_eq_snd_of_mono_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\nt : CategoryTheory.Limits.PullbackCone f f\n⊢ Eq t.fst t.snd","decl":"theorem PullbackCone.fst_eq_snd_of_mono_eq {f : X ⟶ Y} [Mono f] (t : PullbackCone f f) :\n    t.fst = t.snd :=\n  (cancel_mono f).1 t.condition\n\n"}
{"name":"CategoryTheory.Limits.fst_eq_snd_of_mono_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\n⊢ Eq (CategoryTheory.Limits.pullback.fst f f) (CategoryTheory.Limits.pullback.snd f f)","decl":"theorem fst_eq_snd_of_mono_eq : pullback.fst f f = pullback.snd f f :=\n  PullbackCone.fst_eq_snd_of_mono_eq (getLimitCone (cospan f f)).cone\n\n"}
{"name":"CategoryTheory.Limits.pullbackSymmetry_hom_of_mono_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\n⊢ Eq (CategoryTheory.Limits.pullbackSymmetry f f).hom (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback f f))","decl":"@[simp]\ntheorem pullbackSymmetry_hom_of_mono_eq : (pullbackSymmetry f f).hom = 𝟙 _ := by\n  ext\n  · simp [fst_eq_snd_of_mono_eq]\n  · simp [fst_eq_snd_of_mono_eq]\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.isIso_fst_of_mono_of_isLimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\nt : CategoryTheory.Limits.PullbackCone f f\nht : CategoryTheory.Limits.IsLimit t\n⊢ CategoryTheory.IsIso t.fst","decl":"variable {f} in\nlemma PullbackCone.isIso_fst_of_mono_of_isLimit {t : PullbackCone f f} (ht : IsLimit t) :\n    IsIso t.fst := by\n  refine ⟨⟨PullbackCone.IsLimit.lift ht (𝟙 _) (𝟙 _) (by simp), ?_, by simp⟩⟩\n  apply PullbackCone.IsLimit.hom_ext ht\n  · simp\n  · simp [fst_eq_snd_of_mono_eq]\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.isIso_snd_of_mono_of_isLimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\nt : CategoryTheory.Limits.PullbackCone f f\nht : CategoryTheory.Limits.IsLimit t\n⊢ CategoryTheory.IsIso t.snd","decl":"variable {f} in\nlemma PullbackCone.isIso_snd_of_mono_of_isLimit {t : PullbackCone f f} (ht : IsLimit t) :\n    IsIso t.snd :=\n  t.fst_eq_snd_of_mono_eq ▸ t.isIso_fst_of_mono_of_isLimit ht\n\n"}
{"name":"CategoryTheory.Limits.isIso_fst_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.pullback.fst f f)","decl":"instance isIso_fst_of_mono : IsIso (pullback.fst f f) :=\n  PullbackCone.isIso_fst_of_mono_of_isLimit (getLimitCone (cospan f f)).isLimit\n\n"}
{"name":"CategoryTheory.Limits.isIso_snd_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.pullback.snd f f)","decl":"instance isIso_snd_of_mono : IsIso (pullback.snd f f) :=\n  PullbackCone.isIso_snd_of_mono_of_isLimit (getLimitCone (cospan f f)).isLimit\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.epi_inr_of_is_pushout_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nt : CategoryTheory.Limits.PushoutCocone f g\nht : CategoryTheory.Limits.IsColimit t\ninst✝ : CategoryTheory.Epi f\n⊢ CategoryTheory.Epi t.inr","decl":"theorem epi_inr_of_is_pushout_of_epi {t : PushoutCocone f g} (ht : IsColimit t) [Epi f] :\n    Epi t.inr :=\n  ⟨fun {W} h k i => IsColimit.hom_ext ht (by simp [← cancel_epi f, t.condition_assoc, i]) i⟩\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.epi_inl_of_is_pushout_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nt : CategoryTheory.Limits.PushoutCocone f g\nht : CategoryTheory.Limits.IsColimit t\ninst✝ : CategoryTheory.Epi g\n⊢ CategoryTheory.Epi t.inl","decl":"theorem epi_inl_of_is_pushout_of_epi {t : PushoutCocone f g} (ht : IsColimit t) [Epi g] :\n    Epi t.inl :=\n  ⟨fun {W} h k i => IsColimit.hom_ext ht i (by simp [← cancel_epi g, ← t.condition_assoc, i])⟩\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.epi_of_isColimitMkIdId","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nt : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.PushoutCocone.mk (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Y) ⋯)\n⊢ CategoryTheory.Epi f","decl":"/-- `f` is an epi if the pushout cocone `(𝟙 X, 𝟙 X)` is a colimit for the pair `(f, f)`.\nThe converse is given in `PushoutCocone.isColimitMkIdId`.\n-/\ntheorem epi_of_isColimitMkIdId (f : X ⟶ Y)\n    (t : IsColimit (mk (𝟙 Y) (𝟙 Y) rfl : PushoutCocone f f)) : Epi f :=\n  ⟨fun {Z} g h eq => by\n    rcases PushoutCocone.IsColimit.desc' t _ _ eq with ⟨_, rfl, rfl⟩\n    rfl⟩\n\n"}
{"name":"CategoryTheory.Limits.pushout.inl_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Epi g\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.pushout.inl f g)","decl":"/-- The pushout of an epimorphism is an epimorphism -/\ninstance pushout.inl_of_epi {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} [HasPushout f g] [Epi g] :\n    Epi (pushout.inl f g) :=\n  PushoutCocone.epi_inl_of_is_pushout_of_epi (colimit.isColimit _)\n\n"}
{"name":"CategoryTheory.Limits.pushout.inr_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Epi f\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.pushout.inr f g)","decl":"/-- The pushout of an epimorphism is an epimorphism -/\ninstance pushout.inr_of_epi {X Y Z : C} {f : X ⟶ Y} {g : X ⟶ Z} [HasPushout f g] [Epi f] :\n    Epi (pushout.inr _ _ : Z ⟶ pushout f g) :=\n  PushoutCocone.epi_inr_of_is_pushout_of_epi (colimit.isColimit _)\n\n"}
{"name":"CategoryTheory.Limits.epi_coprod_to_pushout","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasBinaryCoproduct Y Z\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.coprod.desc (CategoryTheory.Limits.pushout.inl f g) (CategoryTheory.Limits.pushout.inr f g))","decl":"/-- The map `X ⨿ Y ⟶ X ⨿[Z] Y` is epi. -/\ninstance epi_coprod_to_pushout {C : Type*} [Category C] {X Y Z : C} (f : X ⟶ Y) (g : X ⟶ Z)\n    [HasPushout f g] [HasBinaryCoproduct Y Z] :\n    Epi (coprod.desc (pushout.inl f g) (pushout.inr f g)) :=\n  ⟨fun {W} i₁ i₂ h => by\n    ext\n    · simpa using congrArg (fun f => coprod.inl ≫ f) h\n    · simpa using congrArg (fun f => coprod.inr ≫ f) h⟩\n\n"}
{"name":"CategoryTheory.Limits.hasPushout_of_epi_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nh : Quiver.Hom W X\ninst✝¹ : CategoryTheory.Epi h\ninst✝ : CategoryTheory.Limits.HasPushout f g\n⊢ CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp h g)","decl":"instance hasPushout_of_epi_comp (f : X ⟶ Y) (g : X ⟶ Z) (h : W ⟶ X) [Epi h] [HasPushout f g] :\n    HasPushout (h ≫ f) (h ≫ g) :=\n  ⟨⟨⟨_, pushoutIsPushoutOfEpiComp f g h⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.hasPushout_of_right_factors_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nW X Z : C\nf : Quiver.Hom X Z\nh : Quiver.Hom W X\n⊢ CategoryTheory.Limits.HasPushout h (CategoryTheory.CategoryStruct.comp h f)","decl":"instance hasPushout_of_right_factors_epi : HasPushout h (h ≫ f) := by\n  simpa only [Category.comp_id] using hasPushout_of_epi_comp (𝟙 X) f h\n\n"}
{"name":"CategoryTheory.Limits.pushout_inr_iso_of_right_factors_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nW X Z : C\nf : Quiver.Hom X Z\nh : Quiver.Hom W X\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.pushout.inr h (CategoryTheory.CategoryStruct.comp h f))","decl":"instance pushout_inr_iso_of_right_factors_epi :\n    IsIso (pushout.inr _ _ : _ ⟶ pushout h (h ≫ f)) := by\n  convert (congrArg IsIso (show pushout.inr _ _ ≫ _ = _ from colimit.isoColimitCocone_ι_inv\n    ⟨_, pushoutIsPushoutOfEpiComp (𝟙 _) f h⟩ WalkingSpan.right)).mp\n    inferInstance\n  · apply (Category.comp_id _).symm\n  · apply (Category.comp_id _).symm\n\n"}
{"name":"CategoryTheory.Limits.hasPushout_of_left_factors_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nW X Y : C\nh : Quiver.Hom W X\nf : Quiver.Hom X Y\n⊢ CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp h f) h","decl":"instance hasPushout_of_left_factors_epi (f : X ⟶ Y) : HasPushout (h ≫ f) h := by\n  simpa only [Category.comp_id] using hasPushout_of_epi_comp f (𝟙 X) h\n\n"}
{"name":"CategoryTheory.Limits.pushout_inl_iso_of_left_factors_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nW X Y : C\nh : Quiver.Hom W X\nf : Quiver.Hom X Y\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.pushout.inl (CategoryTheory.CategoryStruct.comp h f) h)","decl":"instance pushout_inl_iso_of_left_factors_epi (f : X ⟶ Y) :\n    IsIso (pushout.inl _ _ : _ ⟶ pushout (h ≫ f) h) := by\n  convert (congrArg IsIso (show pushout.inl _ _ ≫ _ = _ from colimit.isoColimitCocone_ι_inv\n    ⟨_, pushoutIsPushoutOfEpiComp f (𝟙 _) h⟩ WalkingSpan.left)).mp\n        inferInstance\n  · exact (Category.comp_id _).symm\n  · exact (Category.comp_id _).symm\n\n"}
{"name":"CategoryTheory.Limits.has_cokernel_pair_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Epi f\n⊢ CategoryTheory.Limits.HasPushout f f","decl":"instance has_cokernel_pair_of_epi : HasPushout f f :=\n  ⟨⟨⟨_, PushoutCocone.isColimitMkIdId f⟩⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.inl_eq_inr_of_epi_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Epi f\nt : CategoryTheory.Limits.PushoutCocone f f\n⊢ Eq t.inl t.inr","decl":"theorem PushoutCocone.inl_eq_inr_of_epi_eq {f : X ⟶ Y} [Epi f] (t : PushoutCocone f f) :\n    t.inl = t.inr :=\n  (cancel_epi f).1 t.condition\n\n"}
{"name":"CategoryTheory.Limits.inl_eq_inr_of_epi_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Epi f\n⊢ Eq (CategoryTheory.Limits.pushout.inl f f) (CategoryTheory.Limits.pushout.inr f f)","decl":"theorem inl_eq_inr_of_epi_eq : pushout.inl f f = pushout.inr f f :=\n  PushoutCocone.inl_eq_inr_of_epi_eq (getColimitCocone (span f f)).cocone\n\n"}
{"name":"CategoryTheory.Limits.pullback_symmetry_hom_of_epi_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Epi f\n⊢ Eq (CategoryTheory.Limits.pushoutSymmetry f f).hom (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pushout f f))","decl":"@[simp]\ntheorem pullback_symmetry_hom_of_epi_eq : (pushoutSymmetry f f).hom = 𝟙 _ := by\n  ext <;> simp [inl_eq_inr_of_epi_eq]\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.isIso_inl_of_epi_of_isColimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Epi f\nt : CategoryTheory.Limits.PushoutCocone f f\nht : CategoryTheory.Limits.IsColimit t\n⊢ CategoryTheory.IsIso t.inl","decl":"variable {f} in\nlemma PushoutCocone.isIso_inl_of_epi_of_isColimit {t : PushoutCocone f f} (ht : IsColimit t) :\n    IsIso t.inl := by\n  refine ⟨⟨PushoutCocone.IsColimit.desc ht (𝟙 _) (𝟙 _) (by simp), by simp, ?_⟩⟩\n  apply PushoutCocone.IsColimit.hom_ext ht\n  · simp\n  · simp [inl_eq_inr_of_epi_eq]\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.isIso_inr_of_epi_of_isColimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Epi f\nt : CategoryTheory.Limits.PushoutCocone f f\nht : CategoryTheory.Limits.IsColimit t\n⊢ CategoryTheory.IsIso t.inr","decl":"variable {f} in\nlemma PushoutCocone.isIso_inr_of_epi_of_isColimit {t : PushoutCocone f f} (ht : IsColimit t) :\n    IsIso t.inr :=\n  t.inl_eq_inr_of_epi_eq ▸ t.isIso_inl_of_epi_of_isColimit ht\n\n"}
{"name":"CategoryTheory.Limits.isIso_inl_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Epi f\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.pushout.inl f f)","decl":"instance isIso_inl_of_epi : IsIso (pushout.inl f f) :=\n  PushoutCocone.isIso_inl_of_epi_of_isColimit (getColimitCocone (span f f)).isColimit\n\n"}
{"name":"CategoryTheory.Limits.isIso_inr_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Epi f\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.pushout.inr f f)","decl":"instance isIso_inr_of_epi : IsIso (pushout.inr f f) :=\n  PushoutCocone.isIso_inr_of_epi_of_isColimit (getColimitCocone (span f f)).isColimit\n\n"}
