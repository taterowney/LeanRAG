{"name":"CategoryTheory.Limits.PullbackCone.mono_snd_of_is_pullback_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nt : CategoryTheory.Limits.PullbackCone f g\nht : CategoryTheory.Limits.IsLimit t\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ CategoryTheory.Mono t.snd","decl":"/-- Monomorphisms are stable under pullback in the first argument. -/\ntheorem mono_snd_of_is_pullback_of_mono {t : PullbackCone f g} (ht : IsLimit t) [Mono f] :\n    Mono t.snd := by\n  refine ‚ü®fun {W} h k i => IsLimit.hom_ext ht ?_ i‚ü©\n  rw [‚Üê cancel_mono f, Category.assoc, Category.assoc, condition]\n  apply reassoc_of% i\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.mono_fst_of_is_pullback_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nt : CategoryTheory.Limits.PullbackCone f g\nht : CategoryTheory.Limits.IsLimit t\ninst‚úù : CategoryTheory.Mono g\n‚ä¢ CategoryTheory.Mono t.fst","decl":"/-- Monomorphisms are stable under pullback in the second argument. -/\ntheorem mono_fst_of_is_pullback_of_mono {t : PullbackCone f g} (ht : IsLimit t) [Mono g] :\n    Mono t.fst := by\n  refine ‚ü®fun {W} h k i => IsLimit.hom_ext ht i ?_‚ü©\n  rw [‚Üê cancel_mono g, Category.assoc, Category.assoc, ‚Üê condition]\n  apply reassoc_of% i\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.mono_of_isLimitMkIdId","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nt : CategoryTheory.Limits.IsLimit (CategoryTheory.Limits.PullbackCone.mk (CategoryTheory.CategoryStruct.id X) (CategoryTheory.CategoryStruct.id X) ‚ãØ)\n‚ä¢ CategoryTheory.Mono f","decl":"/--\n`f` is a mono if the pullback cone `(ùüô X, ùüô X)` is a limit for the pair `(f, f)`. The converse is\ngiven in `PullbackCone.is_id_of_mono`.\n-/\ntheorem mono_of_isLimitMkIdId (f : X ‚ü∂ Y) (t : IsLimit (mk (ùüô X) (ùüô X) rfl : PullbackCone f f)) :\n    Mono f :=\n  ‚ü®fun {Z} g h eq => by\n    rcases PullbackCone.IsLimit.lift' t _ _ eq with ‚ü®_, rfl, rfl‚ü©\n    rfl‚ü©\n\n"}
{"name":"CategoryTheory.Limits.pullback.fst_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Limits.HasPullback f g\ninst‚úù : CategoryTheory.Mono g\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Limits.pullback.fst f g)","decl":"/-- The pullback of a monomorphism is a monomorphism -/\ninstance pullback.fst_of_mono {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [HasPullback f g] [Mono g] :\n    Mono (pullback.fst f g) :=\n  PullbackCone.mono_fst_of_is_pullback_of_mono (limit.isLimit _)\n\n"}
{"name":"CategoryTheory.Limits.pullback.snd_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Limits.HasPullback f g\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Limits.pullback.snd f g)","decl":"/-- The pullback of a monomorphism is a monomorphism -/\ninstance pullback.snd_of_mono {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [HasPullback f g] [Mono f] :\n    Mono (pullback.snd f g) :=\n  PullbackCone.mono_snd_of_is_pullback_of_mono (limit.isLimit _)\n\n"}
{"name":"CategoryTheory.Limits.mono_pullback_to_prod","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.Limits.HasPullback f g\ninst‚úù : CategoryTheory.Limits.HasBinaryProduct X Y\n‚ä¢ CategoryTheory.Mono (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.pullback.fst f g) (CategoryTheory.Limits.pullback.snd f g))","decl":"/-- The map `X √ó[Z] Y ‚ü∂ X √ó Y` is mono. -/\ninstance mono_pullback_to_prod {C : Type*} [Category C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z)\n    [HasPullback f g] [HasBinaryProduct X Y] :\n    Mono (prod.lift (pullback.fst f g) (pullback.snd f g)) :=\n  ‚ü®fun {W} i‚ÇÅ i‚ÇÇ h => by\n    ext\n    ¬∑ simpa using congrArg (fun f => f ‚â´ prod.fst) h\n    ¬∑ simpa using congrArg (fun f => f ‚â´ prod.snd) h‚ü©\n\n"}
{"name":"CategoryTheory.Limits.hasPullback_of_comp_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X W\ng : Quiver.Hom Y W\ni : Quiver.Hom W Z\ninst‚úù¬π : CategoryTheory.Mono i\ninst‚úù : CategoryTheory.Limits.HasPullback f g\n‚ä¢ CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp f i) (CategoryTheory.CategoryStruct.comp g i)","decl":"instance hasPullback_of_comp_mono (f : X ‚ü∂ W) (g : Y ‚ü∂ W) (i : W ‚ü∂ Z) [Mono i] [HasPullback f g] :\n    HasPullback (f ‚â´ i) (g ‚â´ i) :=\n  ‚ü®‚ü®‚ü®_, pullbackIsPullbackOfCompMono f g i‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.hasPullback_of_right_factors_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW X Z : C\nf : Quiver.Hom X Z\ni : Quiver.Hom Z W\n‚ä¢ CategoryTheory.Limits.HasPullback i (CategoryTheory.CategoryStruct.comp f i)","decl":"instance hasPullback_of_right_factors_mono : HasPullback i (f ‚â´ i) := by\n  simpa only [Category.id_comp] using hasPullback_of_comp_mono (ùüô Z) f i\n\n"}
{"name":"CategoryTheory.Limits.pullback_snd_iso_of_right_factors_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW X Z : C\nf : Quiver.Hom X Z\ni : Quiver.Hom Z W\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.pullback.snd i (CategoryTheory.CategoryStruct.comp f i))","decl":"instance pullback_snd_iso_of_right_factors_mono :\n    IsIso (pullback.snd i (f ‚â´ i)) := by\n  have := limit.isoLimitCone_hom_œÄ ‚ü®_, pullbackIsPullbackOfCompMono (ùüô _) f i‚ü© WalkingCospan.right\n  convert (congrArg IsIso (show _ ‚â´ pullback.snd (ùüô Z) f = _ from this)).mp inferInstance\n  ¬∑ exact (Category.id_comp _).symm\n  ¬∑ exact (Category.id_comp _).symm\n\n"}
{"name":"CategoryTheory.Limits.hasPullback_of_left_factors_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW X Z : C\nf : Quiver.Hom X Z\ni : Quiver.Hom Z W\n‚ä¢ CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp f i) i","decl":"instance hasPullback_of_left_factors_mono : HasPullback (f ‚â´ i) i := by\n  simpa only [Category.id_comp] using hasPullback_of_comp_mono f (ùüô Z) i\n\n"}
{"name":"CategoryTheory.Limits.pullback_snd_iso_of_left_factors_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW X Z : C\nf : Quiver.Hom X Z\ni : Quiver.Hom Z W\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp f i) i)","decl":"instance pullback_snd_iso_of_left_factors_mono :\n    IsIso (pullback.fst (f ‚â´ i) i) := by\n  have := limit.isoLimitCone_hom_œÄ ‚ü®_, pullbackIsPullbackOfCompMono f (ùüô _) i‚ü© WalkingCospan.left\n  convert (congrArg IsIso (show _ ‚â´ pullback.fst f (ùüô Z) = _ from this)).mp inferInstance\n  ¬∑ exact (Category.id_comp _).symm\n  ¬∑ exact (Category.id_comp _).symm\n\n"}
{"name":"CategoryTheory.Limits.has_kernel_pair_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ CategoryTheory.Limits.HasPullback f f","decl":"instance has_kernel_pair_of_mono : HasPullback f f :=\n  ‚ü®‚ü®‚ü®_, PullbackCone.isLimitMkIdId f‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.fst_eq_snd_of_mono_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\nt : CategoryTheory.Limits.PullbackCone f f\n‚ä¢ Eq t.fst t.snd","decl":"theorem PullbackCone.fst_eq_snd_of_mono_eq {f : X ‚ü∂ Y} [Mono f] (t : PullbackCone f f) :\n    t.fst = t.snd :=\n  (cancel_mono f).1 t.condition\n\n"}
{"name":"CategoryTheory.Limits.fst_eq_snd_of_mono_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ Eq (CategoryTheory.Limits.pullback.fst f f) (CategoryTheory.Limits.pullback.snd f f)","decl":"theorem fst_eq_snd_of_mono_eq : pullback.fst f f = pullback.snd f f :=\n  PullbackCone.fst_eq_snd_of_mono_eq (getLimitCone (cospan f f)).cone\n\n"}
{"name":"CategoryTheory.Limits.pullbackSymmetry_hom_of_mono_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ Eq (CategoryTheory.Limits.pullbackSymmetry f f).hom (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pullback f f))","decl":"@[simp]\ntheorem pullbackSymmetry_hom_of_mono_eq : (pullbackSymmetry f f).hom = ùüô _ := by\n  ext\n  ¬∑ simp [fst_eq_snd_of_mono_eq]\n  ¬∑ simp [fst_eq_snd_of_mono_eq]\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.isIso_fst_of_mono_of_isLimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\nt : CategoryTheory.Limits.PullbackCone f f\nht : CategoryTheory.Limits.IsLimit t\n‚ä¢ CategoryTheory.IsIso t.fst","decl":"variable {f} in\nlemma PullbackCone.isIso_fst_of_mono_of_isLimit {t : PullbackCone f f} (ht : IsLimit t) :\n    IsIso t.fst := by\n  refine ‚ü®‚ü®PullbackCone.IsLimit.lift ht (ùüô _) (ùüô _) (by simp), ?_, by simp‚ü©‚ü©\n  apply PullbackCone.IsLimit.hom_ext ht\n  ¬∑ simp\n  ¬∑ simp [fst_eq_snd_of_mono_eq]\n\n"}
{"name":"CategoryTheory.Limits.PullbackCone.isIso_snd_of_mono_of_isLimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\nt : CategoryTheory.Limits.PullbackCone f f\nht : CategoryTheory.Limits.IsLimit t\n‚ä¢ CategoryTheory.IsIso t.snd","decl":"variable {f} in\nlemma PullbackCone.isIso_snd_of_mono_of_isLimit {t : PullbackCone f f} (ht : IsLimit t) :\n    IsIso t.snd :=\n  t.fst_eq_snd_of_mono_eq ‚ñ∏ t.isIso_fst_of_mono_of_isLimit ht\n\n"}
{"name":"CategoryTheory.Limits.isIso_fst_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.pullback.fst f f)","decl":"instance isIso_fst_of_mono : IsIso (pullback.fst f f) :=\n  PullbackCone.isIso_fst_of_mono_of_isLimit (getLimitCone (cospan f f)).isLimit\n\n"}
{"name":"CategoryTheory.Limits.isIso_snd_of_mono","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Mono f\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.pullback.snd f f)","decl":"instance isIso_snd_of_mono : IsIso (pullback.snd f f) :=\n  PullbackCone.isIso_snd_of_mono_of_isLimit (getLimitCone (cospan f f)).isLimit\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.epi_inr_of_is_pushout_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nt : CategoryTheory.Limits.PushoutCocone f g\nht : CategoryTheory.Limits.IsColimit t\ninst‚úù : CategoryTheory.Epi f\n‚ä¢ CategoryTheory.Epi t.inr","decl":"theorem epi_inr_of_is_pushout_of_epi {t : PushoutCocone f g} (ht : IsColimit t) [Epi f] :\n    Epi t.inr :=\n  ‚ü®fun {W} h k i => IsColimit.hom_ext ht (by simp [‚Üê cancel_epi f, t.condition_assoc, i]) i‚ü©\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.epi_inl_of_is_pushout_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nt : CategoryTheory.Limits.PushoutCocone f g\nht : CategoryTheory.Limits.IsColimit t\ninst‚úù : CategoryTheory.Epi g\n‚ä¢ CategoryTheory.Epi t.inl","decl":"theorem epi_inl_of_is_pushout_of_epi {t : PushoutCocone f g} (ht : IsColimit t) [Epi g] :\n    Epi t.inl :=\n  ‚ü®fun {W} h k i => IsColimit.hom_ext ht i (by simp [‚Üê cancel_epi g, ‚Üê t.condition_assoc, i])‚ü©\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.epi_of_isColimitMkIdId","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nt : CategoryTheory.Limits.IsColimit (CategoryTheory.Limits.PushoutCocone.mk (CategoryTheory.CategoryStruct.id Y) (CategoryTheory.CategoryStruct.id Y) ‚ãØ)\n‚ä¢ CategoryTheory.Epi f","decl":"/-- `f` is an epi if the pushout cocone `(ùüô X, ùüô X)` is a colimit for the pair `(f, f)`.\nThe converse is given in `PushoutCocone.isColimitMkIdId`.\n-/\ntheorem epi_of_isColimitMkIdId (f : X ‚ü∂ Y)\n    (t : IsColimit (mk (ùüô Y) (ùüô Y) rfl : PushoutCocone f f)) : Epi f :=\n  ‚ü®fun {Z} g h eq => by\n    rcases PushoutCocone.IsColimit.desc' t _ _ eq with ‚ü®_, rfl, rfl‚ü©\n    rfl‚ü©\n\n"}
{"name":"CategoryTheory.Limits.pushout.inl_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst‚úù¬π : CategoryTheory.Limits.HasPushout f g\ninst‚úù : CategoryTheory.Epi g\n‚ä¢ CategoryTheory.Epi (CategoryTheory.Limits.pushout.inl f g)","decl":"/-- The pushout of an epimorphism is an epimorphism -/\ninstance pushout.inl_of_epi {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [HasPushout f g] [Epi g] :\n    Epi (pushout.inl f g) :=\n  PushoutCocone.epi_inl_of_is_pushout_of_epi (colimit.isColimit _)\n\n"}
{"name":"CategoryTheory.Limits.pushout.inr_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst‚úù¬π : CategoryTheory.Limits.HasPushout f g\ninst‚úù : CategoryTheory.Epi f\n‚ä¢ CategoryTheory.Epi (CategoryTheory.Limits.pushout.inr f g)","decl":"/-- The pushout of an epimorphism is an epimorphism -/\ninstance pushout.inr_of_epi {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [HasPushout f g] [Epi f] :\n    Epi (pushout.inr _ _ : Z ‚ü∂ pushout f g) :=\n  PushoutCocone.epi_inr_of_is_pushout_of_epi (colimit.isColimit _)\n\n"}
{"name":"CategoryTheory.Limits.epi_coprod_to_pushout","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst‚úù¬π : CategoryTheory.Limits.HasPushout f g\ninst‚úù : CategoryTheory.Limits.HasBinaryCoproduct Y Z\n‚ä¢ CategoryTheory.Epi (CategoryTheory.Limits.coprod.desc (CategoryTheory.Limits.pushout.inl f g) (CategoryTheory.Limits.pushout.inr f g))","decl":"/-- The map `X ‚®ø Y ‚ü∂ X ‚®ø[Z] Y` is epi. -/\ninstance epi_coprod_to_pushout {C : Type*} [Category C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z)\n    [HasPushout f g] [HasBinaryCoproduct Y Z] :\n    Epi (coprod.desc (pushout.inl f g) (pushout.inr f g)) :=\n  ‚ü®fun {W} i‚ÇÅ i‚ÇÇ h => by\n    ext\n    ¬∑ simpa using congrArg (fun f => coprod.inl ‚â´ f) h\n    ¬∑ simpa using congrArg (fun f => coprod.inr ‚â´ f) h‚ü©\n\n"}
{"name":"CategoryTheory.Limits.hasPushout_of_epi_comp","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nh : Quiver.Hom W X\ninst‚úù¬π : CategoryTheory.Epi h\ninst‚úù : CategoryTheory.Limits.HasPushout f g\n‚ä¢ CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp h f) (CategoryTheory.CategoryStruct.comp h g)","decl":"instance hasPushout_of_epi_comp (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) (h : W ‚ü∂ X) [Epi h] [HasPushout f g] :\n    HasPushout (h ‚â´ f) (h ‚â´ g) :=\n  ‚ü®‚ü®‚ü®_, pushoutIsPushoutOfEpiComp f g h‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.hasPushout_of_right_factors_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW X Z : C\nf : Quiver.Hom X Z\nh : Quiver.Hom W X\n‚ä¢ CategoryTheory.Limits.HasPushout h (CategoryTheory.CategoryStruct.comp h f)","decl":"instance hasPushout_of_right_factors_epi : HasPushout h (h ‚â´ f) := by\n  simpa only [Category.comp_id] using hasPushout_of_epi_comp (ùüô X) f h\n\n"}
{"name":"CategoryTheory.Limits.pushout_inr_iso_of_right_factors_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW X Z : C\nf : Quiver.Hom X Z\nh : Quiver.Hom W X\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.pushout.inr h (CategoryTheory.CategoryStruct.comp h f))","decl":"instance pushout_inr_iso_of_right_factors_epi :\n    IsIso (pushout.inr _ _ : _ ‚ü∂ pushout h (h ‚â´ f)) := by\n  convert (congrArg IsIso (show pushout.inr _ _ ‚â´ _ = _ from colimit.isoColimitCocone_Œπ_inv\n    ‚ü®_, pushoutIsPushoutOfEpiComp (ùüô _) f h‚ü© WalkingSpan.right)).mp\n    inferInstance\n  ¬∑ apply (Category.comp_id _).symm\n  ¬∑ apply (Category.comp_id _).symm\n\n"}
{"name":"CategoryTheory.Limits.hasPushout_of_left_factors_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW X Y : C\nh : Quiver.Hom W X\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp h f) h","decl":"instance hasPushout_of_left_factors_epi (f : X ‚ü∂ Y) : HasPushout (h ‚â´ f) h := by\n  simpa only [Category.comp_id] using hasPushout_of_epi_comp f (ùüô X) h\n\n"}
{"name":"CategoryTheory.Limits.pushout_inl_iso_of_left_factors_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW X Y : C\nh : Quiver.Hom W X\nf : Quiver.Hom X Y\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.pushout.inl (CategoryTheory.CategoryStruct.comp h f) h)","decl":"instance pushout_inl_iso_of_left_factors_epi (f : X ‚ü∂ Y) :\n    IsIso (pushout.inl _ _ : _ ‚ü∂ pushout (h ‚â´ f) h) := by\n  convert (congrArg IsIso (show pushout.inl _ _ ‚â´ _ = _ from colimit.isoColimitCocone_Œπ_inv\n    ‚ü®_, pushoutIsPushoutOfEpiComp f (ùüô _) h‚ü© WalkingSpan.left)).mp\n        inferInstance\n  ¬∑ exact (Category.comp_id _).symm\n  ¬∑ exact (Category.comp_id _).symm\n\n"}
{"name":"CategoryTheory.Limits.has_cokernel_pair_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Epi f\n‚ä¢ CategoryTheory.Limits.HasPushout f f","decl":"instance has_cokernel_pair_of_epi : HasPushout f f :=\n  ‚ü®‚ü®‚ü®_, PushoutCocone.isColimitMkIdId f‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.inl_eq_inr_of_epi_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Epi f\nt : CategoryTheory.Limits.PushoutCocone f f\n‚ä¢ Eq t.inl t.inr","decl":"theorem PushoutCocone.inl_eq_inr_of_epi_eq {f : X ‚ü∂ Y} [Epi f] (t : PushoutCocone f f) :\n    t.inl = t.inr :=\n  (cancel_epi f).1 t.condition\n\n"}
{"name":"CategoryTheory.Limits.inl_eq_inr_of_epi_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Epi f\n‚ä¢ Eq (CategoryTheory.Limits.pushout.inl f f) (CategoryTheory.Limits.pushout.inr f f)","decl":"theorem inl_eq_inr_of_epi_eq : pushout.inl f f = pushout.inr f f :=\n  PushoutCocone.inl_eq_inr_of_epi_eq (getColimitCocone (span f f)).cocone\n\n"}
{"name":"CategoryTheory.Limits.pullback_symmetry_hom_of_epi_eq","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Epi f\n‚ä¢ Eq (CategoryTheory.Limits.pushoutSymmetry f f).hom (CategoryTheory.CategoryStruct.id (CategoryTheory.Limits.pushout f f))","decl":"@[simp]\ntheorem pullback_symmetry_hom_of_epi_eq : (pushoutSymmetry f f).hom = ùüô _ := by\n  ext <;> simp [inl_eq_inr_of_epi_eq]\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.isIso_inl_of_epi_of_isColimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Epi f\nt : CategoryTheory.Limits.PushoutCocone f f\nht : CategoryTheory.Limits.IsColimit t\n‚ä¢ CategoryTheory.IsIso t.inl","decl":"variable {f} in\nlemma PushoutCocone.isIso_inl_of_epi_of_isColimit {t : PushoutCocone f f} (ht : IsColimit t) :\n    IsIso t.inl := by\n  refine ‚ü®‚ü®PushoutCocone.IsColimit.desc ht (ùüô _) (ùüô _) (by simp), by simp, ?_‚ü©‚ü©\n  apply PushoutCocone.IsColimit.hom_ext ht\n  ¬∑ simp\n  ¬∑ simp [inl_eq_inr_of_epi_eq]\n\n"}
{"name":"CategoryTheory.Limits.PushoutCocone.isIso_inr_of_epi_of_isColimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Epi f\nt : CategoryTheory.Limits.PushoutCocone f f\nht : CategoryTheory.Limits.IsColimit t\n‚ä¢ CategoryTheory.IsIso t.inr","decl":"variable {f} in\nlemma PushoutCocone.isIso_inr_of_epi_of_isColimit {t : PushoutCocone f f} (ht : IsColimit t) :\n    IsIso t.inr :=\n  t.inl_eq_inr_of_epi_eq ‚ñ∏ t.isIso_inl_of_epi_of_isColimit ht\n\n"}
{"name":"CategoryTheory.Limits.isIso_inl_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Epi f\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.pushout.inl f f)","decl":"instance isIso_inl_of_epi : IsIso (pushout.inl f f) :=\n  PushoutCocone.isIso_inl_of_epi_of_isColimit (getColimitCocone (span f f)).isColimit\n\n"}
{"name":"CategoryTheory.Limits.isIso_inr_of_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Mono","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Epi f\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.Limits.pushout.inr f f)","decl":"instance isIso_inr_of_epi : IsIso (pushout.inr f f) :=\n  PushoutCocone.isIso_inr_of_epi_of_isColimit (getColimitCocone (span f f)).isColimit\n\n"}
