{"name":"OrderTop.le_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝ : LE α\nself : OrderTop α\na : α\n⊢ LE.le a Top.top","decl":"/-- An order is an `OrderTop` if it has a greatest element.\nWe state this using a data mixin, holding the value of `⊤` and the greatest element constraint. -/\nclass OrderTop (α : Type u) [LE α] extends Top α where\n  /-- `⊤` is the greatest element -/\n  le_top : ∀ a : α, a ≤ ⊤\n\n"}
{"name":"le_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : LE α\ninst✝ : OrderTop α\na : α\n⊢ LE.le a Top.top","decl":"@[simp]\ntheorem le_top : a ≤ ⊤ :=\n  OrderTop.le_top a\n\n"}
{"name":"isTop_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : LE α\ninst✝ : OrderTop α\n⊢ IsTop Top.top","decl":"@[simp]\ntheorem isTop_top : IsTop (⊤ : α) := fun _ => le_top\n\n"}
{"name":"isMax_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\n⊢ IsMax Top.top","decl":"@[simp]\ntheorem isMax_top : IsMax (⊤ : α) :=\n  isTop_top.isMax\n\n"}
{"name":"not_top_lt","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\na : α\n⊢ Not (LT.lt Top.top a)","decl":"@[simp]\ntheorem not_top_lt : ¬⊤ < a :=\n  isMax_top.not_lt\n\n"}
{"name":"ne_top_of_lt","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\na b : α\nh : LT.lt a b\n⊢ Ne a Top.top","decl":"theorem ne_top_of_lt (h : a < b) : a ≠ ⊤ :=\n  (h.trans_le le_top).ne\n\n"}
{"name":"LT.lt.ne_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\na b : α\nh : LT.lt a b\n⊢ Ne a Top.top","decl":"alias LT.lt.ne_top := ne_top_of_lt\n\n"}
{"name":"lt_top_of_lt","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\na b : α\nh : LT.lt a b\n⊢ LT.lt a Top.top","decl":"theorem lt_top_of_lt (h : a < b) : a < ⊤ :=\n  lt_of_lt_of_le h le_top\n\n"}
{"name":"LT.lt.lt_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\na b : α\nh : LT.lt a b\n⊢ LT.lt a Top.top","decl":"alias LT.lt.lt_top := lt_top_of_lt\n\n"}
{"name":"isMax_iff_eq_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na : α\n⊢ Iff (IsMax a) (Eq a Top.top)","decl":"@[simp]\ntheorem isMax_iff_eq_top : IsMax a ↔ a = ⊤ :=\n  ⟨fun h => h.eq_of_le le_top, fun h _ _ => h.symm ▸ le_top⟩\n\n"}
{"name":"isTop_iff_eq_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na : α\n⊢ Iff (IsTop a) (Eq a Top.top)","decl":"@[simp]\ntheorem isTop_iff_eq_top : IsTop a ↔ a = ⊤ :=\n  ⟨fun h => h.isMax.eq_of_le le_top, fun h _ => h.symm ▸ le_top⟩\n\n"}
{"name":"not_isMax_iff_ne_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na : α\n⊢ Iff (Not (IsMax a)) (Ne a Top.top)","decl":"theorem not_isMax_iff_ne_top : ¬IsMax a ↔ a ≠ ⊤ :=\n  isMax_iff_eq_top.not\n\n"}
{"name":"not_isTop_iff_ne_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na : α\n⊢ Iff (Not (IsTop a)) (Ne a Top.top)","decl":"theorem not_isTop_iff_ne_top : ¬IsTop a ↔ a ≠ ⊤ :=\n  isTop_iff_eq_top.not\n\n"}
{"name":"IsMax.eq_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na : α\na✝ : IsMax a\n⊢ Eq a Top.top","decl":"alias ⟨IsMax.eq_top, _⟩ := isMax_iff_eq_top\n\n"}
{"name":"IsTop.eq_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na : α\na✝ : IsTop a\n⊢ Eq a Top.top","decl":"alias ⟨IsTop.eq_top, _⟩ := isTop_iff_eq_top\n\n"}
{"name":"top_le_iff","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na : α\n⊢ Iff (LE.le Top.top a) (Eq a Top.top)","decl":"@[simp]\ntheorem top_le_iff : ⊤ ≤ a ↔ a = ⊤ :=\n  le_top.le_iff_eq.trans eq_comm\n\n"}
{"name":"top_unique","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na : α\nh : LE.le Top.top a\n⊢ Eq a Top.top","decl":"theorem top_unique (h : ⊤ ≤ a) : a = ⊤ :=\n  le_top.antisymm h\n\n"}
{"name":"eq_top_iff","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na : α\n⊢ Iff (Eq a Top.top) (LE.le Top.top a)","decl":"theorem eq_top_iff : a = ⊤ ↔ ⊤ ≤ a :=\n  top_le_iff.symm\n\n"}
{"name":"eq_top_mono","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na b : α\nh : LE.le a b\nh₂ : Eq a Top.top\n⊢ Eq b Top.top","decl":"theorem eq_top_mono (h : a ≤ b) (h₂ : a = ⊤) : b = ⊤ :=\n  top_unique <| h₂ ▸ h\n\n"}
{"name":"lt_top_iff_ne_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na : α\n⊢ Iff (LT.lt a Top.top) (Ne a Top.top)","decl":"theorem lt_top_iff_ne_top : a < ⊤ ↔ a ≠ ⊤ :=\n  le_top.lt_iff_ne\n\n"}
{"name":"not_lt_top_iff","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na : α\n⊢ Iff (Not (LT.lt a Top.top)) (Eq a Top.top)","decl":"@[simp]\ntheorem not_lt_top_iff : ¬a < ⊤ ↔ a = ⊤ :=\n  lt_top_iff_ne_top.not_left\n\n"}
{"name":"eq_top_or_lt_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na : α\n⊢ Or (Eq a Top.top) (LT.lt a Top.top)","decl":"theorem eq_top_or_lt_top (a : α) : a = ⊤ ∨ a < ⊤ :=\n  le_top.eq_or_lt\n\n"}
{"name":"Ne.lt_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na : α\nh : Ne a Top.top\n⊢ LT.lt a Top.top","decl":"@[aesop (rule_sets := [finiteness]) safe apply]\ntheorem Ne.lt_top (h : a ≠ ⊤) : a < ⊤ :=\n  lt_top_iff_ne_top.mpr h\n\n"}
{"name":"Ne.lt_top'","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na : α\nh : Ne Top.top a\n⊢ LT.lt a Top.top","decl":"theorem Ne.lt_top' (h : ⊤ ≠ a) : a < ⊤ :=\n  h.symm.lt_top\n\n"}
{"name":"ne_top_of_le_ne_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\na b : α\nhb : Ne b Top.top\nhab : LE.le a b\n⊢ Ne a Top.top","decl":"theorem ne_top_of_le_ne_top (hb : b ≠ ⊤) (hab : a ≤ b) : a ≠ ⊤ :=\n  (hab.trans_lt hb.lt_top).ne\n\n"}
{"name":"top_not_mem_iff","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\ns : Set α\n⊢ Iff (Not (Membership.mem s Top.top)) (∀ (x : α), Membership.mem s x → LT.lt x Top.top)","decl":"lemma top_not_mem_iff {s : Set α} : ⊤ ∉ s ↔ ∀ x ∈ s, x < ⊤ :=\n  ⟨fun h x hx ↦ Ne.lt_top (fun hx' : x = ⊤ ↦ h (hx' ▸ hx)), fun h h₀ ↦ (h ⊤ h₀).false⟩\n\n"}
{"name":"not_isMin_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝² : PartialOrder α\ninst✝¹ : OrderTop α\ninst✝ : Nontrivial α\n⊢ Not (IsMin Top.top)","decl":"theorem not_isMin_top : ¬IsMin (⊤ : α) := fun h =>\n  let ⟨_, ha⟩ := exists_ne (⊤ : α)\n  ha <| top_le_iff.1 <| h le_top\n\n"}
{"name":"OrderTop.ext_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u_1\nhA : PartialOrder α\nA : OrderTop α\nhB : PartialOrder α\nB : OrderTop α\nH : ∀ (x y : α), Iff (LE.le x y) (LE.le x y)\n⊢ Eq Top.top Top.top","decl":"theorem OrderTop.ext_top {α} {hA : PartialOrder α} (A : OrderTop α) {hB : PartialOrder α}\n    (B : OrderTop α) (H : ∀ x y : α, (haveI := hA; x ≤ y) ↔ x ≤ y) :\n    (@Top.top α (@OrderTop.toTop α hA.toLE A)) = (@Top.top α (@OrderTop.toTop α hB.toLE B)) := by\n  cases PartialOrder.ext H\n  apply top_unique\n  exact @le_top _ _ A _\n\n"}
{"name":"OrderBot.bot_le","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝ : LE α\nself : OrderBot α\na : α\n⊢ LE.le Bot.bot a","decl":"/-- An order is an `OrderBot` if it has a least element.\nWe state this using a data mixin, holding the value of `⊥` and the least element constraint. -/\nclass OrderBot (α : Type u) [LE α] extends Bot α where\n  /-- `⊥` is the least element -/\n  bot_le : ∀ a : α, ⊥ ≤ a\n\n"}
{"name":"bot_le","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : LE α\ninst✝ : OrderBot α\na : α\n⊢ LE.le Bot.bot a","decl":"@[simp]\ntheorem bot_le : ⊥ ≤ a :=\n  OrderBot.bot_le a\n\n"}
{"name":"isBot_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : LE α\ninst✝ : OrderBot α\n⊢ IsBot Bot.bot","decl":"@[simp]\ntheorem isBot_bot : IsBot (⊥ : α) := fun _ => bot_le\n\n"}
{"name":"OrderDual.ofDual_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝ : Top α\n⊢ Eq (OrderDual.ofDual Bot.bot) Top.top","decl":"@[simp]\ntheorem ofDual_bot [Top α] : ofDual ⊥ = (⊤ : α) :=\n  rfl\n\n"}
{"name":"OrderDual.ofDual_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝ : Bot α\n⊢ Eq (OrderDual.ofDual Top.top) Bot.bot","decl":"@[simp]\ntheorem ofDual_top [Bot α] : ofDual ⊤ = (⊥ : α) :=\n  rfl\n\n"}
{"name":"OrderDual.toDual_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝ : Bot α\n⊢ Eq (OrderDual.toDual Bot.bot) Top.top","decl":"@[simp]\ntheorem toDual_bot [Bot α] : toDual (⊥ : α) = ⊤ :=\n  rfl\n\n"}
{"name":"OrderDual.toDual_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝ : Top α\n⊢ Eq (OrderDual.toDual Top.top) Bot.bot","decl":"@[simp]\ntheorem toDual_top [Top α] : toDual (⊤ : α) = ⊥ :=\n  rfl\n\n"}
{"name":"isMin_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\n⊢ IsMin Bot.bot","decl":"@[simp]\ntheorem isMin_bot : IsMin (⊥ : α) :=\n  isBot_bot.isMin\n\n"}
{"name":"not_lt_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\na : α\n⊢ Not (LT.lt a Bot.bot)","decl":"@[simp]\ntheorem not_lt_bot : ¬a < ⊥ :=\n  isMin_bot.not_lt\n\n"}
{"name":"ne_bot_of_gt","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\na b : α\nh : LT.lt a b\n⊢ Ne b Bot.bot","decl":"theorem ne_bot_of_gt (h : a < b) : b ≠ ⊥ :=\n  (bot_le.trans_lt h).ne'\n\n"}
{"name":"LT.lt.ne_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\na b : α\nh : LT.lt a b\n⊢ Ne b Bot.bot","decl":"alias LT.lt.ne_bot := ne_bot_of_gt\n\n"}
{"name":"bot_lt_of_lt","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\na b : α\nh : LT.lt a b\n⊢ LT.lt Bot.bot b","decl":"theorem bot_lt_of_lt (h : a < b) : ⊥ < b :=\n  lt_of_le_of_lt bot_le h\n\n"}
{"name":"LT.lt.bot_lt","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\na b : α\nh : LT.lt a b\n⊢ LT.lt Bot.bot b","decl":"alias LT.lt.bot_lt := bot_lt_of_lt\n\n"}
{"name":"isMin_iff_eq_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na : α\n⊢ Iff (IsMin a) (Eq a Bot.bot)","decl":"@[simp]\ntheorem isMin_iff_eq_bot : IsMin a ↔ a = ⊥ :=\n  ⟨fun h => h.eq_of_ge bot_le, fun h _ _ => h.symm ▸ bot_le⟩\n\n"}
{"name":"isBot_iff_eq_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na : α\n⊢ Iff (IsBot a) (Eq a Bot.bot)","decl":"@[simp]\ntheorem isBot_iff_eq_bot : IsBot a ↔ a = ⊥ :=\n  ⟨fun h => h.isMin.eq_of_ge bot_le, fun h _ => h.symm ▸ bot_le⟩\n\n"}
{"name":"not_isMin_iff_ne_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na : α\n⊢ Iff (Not (IsMin a)) (Ne a Bot.bot)","decl":"theorem not_isMin_iff_ne_bot : ¬IsMin a ↔ a ≠ ⊥ :=\n  isMin_iff_eq_bot.not\n\n"}
{"name":"not_isBot_iff_ne_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na : α\n⊢ Iff (Not (IsBot a)) (Ne a Bot.bot)","decl":"theorem not_isBot_iff_ne_bot : ¬IsBot a ↔ a ≠ ⊥ :=\n  isBot_iff_eq_bot.not\n\n"}
{"name":"IsMin.eq_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na : α\na✝ : IsMin a\n⊢ Eq a Bot.bot","decl":"alias ⟨IsMin.eq_bot, _⟩ := isMin_iff_eq_bot\n\n"}
{"name":"IsBot.eq_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na : α\na✝ : IsBot a\n⊢ Eq a Bot.bot","decl":"alias ⟨IsBot.eq_bot, _⟩ := isBot_iff_eq_bot\n\n"}
{"name":"le_bot_iff","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na : α\n⊢ Iff (LE.le a Bot.bot) (Eq a Bot.bot)","decl":"@[simp]\ntheorem le_bot_iff : a ≤ ⊥ ↔ a = ⊥ :=\n  bot_le.le_iff_eq\n\n"}
{"name":"bot_unique","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na : α\nh : LE.le a Bot.bot\n⊢ Eq a Bot.bot","decl":"theorem bot_unique (h : a ≤ ⊥) : a = ⊥ :=\n  h.antisymm bot_le\n\n"}
{"name":"eq_bot_iff","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na : α\n⊢ Iff (Eq a Bot.bot) (LE.le a Bot.bot)","decl":"theorem eq_bot_iff : a = ⊥ ↔ a ≤ ⊥ :=\n  le_bot_iff.symm\n\n"}
{"name":"eq_bot_mono","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na b : α\nh : LE.le a b\nh₂ : Eq b Bot.bot\n⊢ Eq a Bot.bot","decl":"theorem eq_bot_mono (h : a ≤ b) (h₂ : b = ⊥) : a = ⊥ :=\n  bot_unique <| h₂ ▸ h\n\n"}
{"name":"bot_lt_iff_ne_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na : α\n⊢ Iff (LT.lt Bot.bot a) (Ne a Bot.bot)","decl":"theorem bot_lt_iff_ne_bot : ⊥ < a ↔ a ≠ ⊥ :=\n  bot_le.lt_iff_ne.trans ne_comm\n\n"}
{"name":"not_bot_lt_iff","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na : α\n⊢ Iff (Not (LT.lt Bot.bot a)) (Eq a Bot.bot)","decl":"@[simp]\ntheorem not_bot_lt_iff : ¬⊥ < a ↔ a = ⊥ :=\n  bot_lt_iff_ne_bot.not_left\n\n"}
{"name":"eq_bot_or_bot_lt","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na : α\n⊢ Or (Eq a Bot.bot) (LT.lt Bot.bot a)","decl":"theorem eq_bot_or_bot_lt (a : α) : a = ⊥ ∨ ⊥ < a :=\n  bot_le.eq_or_gt\n\n"}
{"name":"eq_bot_of_minimal","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na : α\nh : ∀ (b : α), Not (LT.lt b a)\n⊢ Eq a Bot.bot","decl":"theorem eq_bot_of_minimal (h : ∀ b, ¬b < a) : a = ⊥ :=\n  (eq_bot_or_bot_lt a).resolve_right (h ⊥)\n\n"}
{"name":"Ne.bot_lt","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na : α\nh : Ne a Bot.bot\n⊢ LT.lt Bot.bot a","decl":"theorem Ne.bot_lt (h : a ≠ ⊥) : ⊥ < a :=\n  bot_lt_iff_ne_bot.mpr h\n\n"}
{"name":"Ne.bot_lt'","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na : α\nh : Ne Bot.bot a\n⊢ LT.lt Bot.bot a","decl":"theorem Ne.bot_lt' (h : ⊥ ≠ a) : ⊥ < a :=\n  h.symm.bot_lt\n\n"}
{"name":"ne_bot_of_le_ne_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\na b : α\nhb : Ne b Bot.bot\nhab : LE.le b a\n⊢ Ne a Bot.bot","decl":"theorem ne_bot_of_le_ne_bot (hb : b ≠ ⊥) (hab : b ≤ a) : a ≠ ⊥ :=\n  (hb.bot_lt.trans_le hab).ne'\n\n"}
{"name":"bot_not_mem_iff","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\ns : Set α\n⊢ Iff (Not (Membership.mem s Bot.bot)) (∀ (x : α), Membership.mem s x → LT.lt Bot.bot x)","decl":"lemma bot_not_mem_iff {s : Set α} : ⊥ ∉ s ↔ ∀ x ∈ s, ⊥ < x :=\n  top_not_mem_iff (α := αᵒᵈ)\n\n"}
{"name":"not_isMax_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝² : PartialOrder α\ninst✝¹ : OrderBot α\ninst✝ : Nontrivial α\n⊢ Not (IsMax Bot.bot)","decl":"theorem not_isMax_bot : ¬IsMax (⊥ : α) :=\n  @not_isMin_top αᵒᵈ _ _ _\n\n"}
{"name":"OrderBot.ext_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u_1\nhA : PartialOrder α\nA : OrderBot α\nhB : PartialOrder α\nB : OrderBot α\nH : ∀ (x y : α), Iff (LE.le x y) (LE.le x y)\n⊢ Eq Bot.bot Bot.bot","decl":"theorem OrderBot.ext_bot {α} {hA : PartialOrder α} (A : OrderBot α) {hB : PartialOrder α}\n    (B : OrderBot α) (H : ∀ x y : α, (haveI := hA; x ≤ y) ↔ x ≤ y) :\n    (@Bot.bot α (@OrderBot.toBot α hA.toLE A)) = (@Bot.bot α (@OrderBot.toBot α hB.toLE B)) := by\n  cases PartialOrder.ext H\n  apply bot_unique\n  exact @bot_le _ _ A _\n\n"}
{"name":"OrderBot.instSubsingleton","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝ : PartialOrder α\n⊢ Subsingleton (OrderBot α)","decl":"instance OrderBot.instSubsingleton : Subsingleton (OrderBot α) where\n  allEq := by rintro @⟨⟨a⟩, ha⟩ @⟨⟨b⟩, hb⟩; congr; exact le_antisymm (ha _) (hb _)\n\n"}
{"name":"OrderTop.instSubsingleton","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝ : PartialOrder α\n⊢ Subsingleton (OrderTop α)","decl":"instance OrderTop.instSubsingleton : Subsingleton (OrderTop α) where\n  allEq := by rintro @⟨⟨a⟩, ha⟩ @⟨⟨b⟩, hb⟩; congr; exact le_antisymm (hb _) (ha _)\n\n"}
{"name":"BoundedOrder.instSubsingleton","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝ : PartialOrder α\n⊢ Subsingleton (BoundedOrder α)","decl":"instance BoundedOrder.instSubsingleton : Subsingleton (BoundedOrder α) where\n  allEq := by rintro ⟨⟩ ⟨⟩; congr <;> exact Subsingleton.elim _ _\n\n"}
{"name":"Pi.bot_apply","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"ι : Type u_1\nα' : ι → Type u_2\ninst✝ : (i : ι) → Bot (α' i)\ni : ι\n⊢ Eq (Bot.bot i) Bot.bot","decl":"@[simp]\ntheorem bot_apply [∀ i, Bot (α' i)] (i : ι) : (⊥ : ∀ i, α' i) i = ⊥ :=\n  rfl\n\n"}
{"name":"Pi.bot_def","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"ι : Type u_1\nα' : ι → Type u_2\ninst✝ : (i : ι) → Bot (α' i)\n⊢ Eq Bot.bot fun x => Bot.bot","decl":"theorem bot_def [∀ i, Bot (α' i)] : (⊥ : ∀ i, α' i) = fun _ => ⊥ :=\n  rfl\n\n"}
{"name":"Pi.top_apply","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"ι : Type u_1\nα' : ι → Type u_2\ninst✝ : (i : ι) → Top (α' i)\ni : ι\n⊢ Eq (Top.top i) Top.top","decl":"@[simp]\ntheorem top_apply [∀ i, Top (α' i)] (i : ι) : (⊤ : ∀ i, α' i) i = ⊤ :=\n  rfl\n\n"}
{"name":"Pi.top_def","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"ι : Type u_1\nα' : ι → Type u_2\ninst✝ : (i : ι) → Top (α' i)\n⊢ Eq Top.top fun x => Top.top","decl":"theorem top_def [∀ i, Top (α' i)] : (⊤ : ∀ i, α' i) = fun _ => ⊤ :=\n  rfl\n\n"}
{"name":"eq_bot_of_bot_eq_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : BoundedOrder α\nhα : Eq Bot.bot Top.top\nx : α\n⊢ Eq x Bot.bot","decl":"theorem eq_bot_of_bot_eq_top (hα : (⊥ : α) = ⊤) (x : α) : x = (⊥ : α) :=\n  eq_bot_mono le_top (Eq.symm hα)\n\n"}
{"name":"eq_top_of_bot_eq_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : BoundedOrder α\nhα : Eq Bot.bot Top.top\nx : α\n⊢ Eq x Top.top","decl":"theorem eq_top_of_bot_eq_top (hα : (⊥ : α) = ⊤) (x : α) : x = (⊤ : α) :=\n  eq_top_mono bot_le hα\n\n"}
{"name":"subsingleton_of_top_le_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : BoundedOrder α\nh : LE.le Top.top Bot.bot\n⊢ Subsingleton α","decl":"theorem subsingleton_of_top_le_bot (h : (⊤ : α) ≤ (⊥ : α)) : Subsingleton α :=\n  ⟨fun _ _ => le_antisymm\n    (le_trans le_top <| le_trans h bot_le) (le_trans le_top <| le_trans h bot_le)⟩\n\n"}
{"name":"subsingleton_of_bot_eq_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : BoundedOrder α\nhα : Eq Bot.bot Top.top\n⊢ Subsingleton α","decl":"theorem subsingleton_of_bot_eq_top (hα : (⊥ : α) = (⊤ : α)) : Subsingleton α :=\n  subsingleton_of_top_le_bot (ge_of_eq hα)\n\n"}
{"name":"subsingleton_iff_bot_eq_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝¹ : PartialOrder α\ninst✝ : BoundedOrder α\n⊢ Iff (Eq Bot.bot Top.top) (Subsingleton α)","decl":"theorem subsingleton_iff_bot_eq_top : (⊥ : α) = (⊤ : α) ↔ Subsingleton α :=\n  ⟨subsingleton_of_bot_eq_top, fun _ => Subsingleton.elim ⊥ ⊤⟩\n\n"}
{"name":"Subtype.mk_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝² : PartialOrder α\ninst✝¹ : OrderBot α\ninst✝ : OrderBot (Subtype p)\nhbot : p Bot.bot\n⊢ Eq ⟨Bot.bot, hbot⟩ Bot.bot","decl":"@[simp]\ntheorem mk_bot [OrderBot α] [OrderBot (Subtype p)] (hbot : p ⊥) : mk ⊥ hbot = ⊥ :=\n  le_bot_iff.1 <| coe_le_coe.1 bot_le\n\n"}
{"name":"Subtype.mk_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝² : PartialOrder α\ninst✝¹ : OrderTop α\ninst✝ : OrderTop (Subtype p)\nhtop : p Top.top\n⊢ Eq ⟨Top.top, htop⟩ Top.top","decl":"@[simp]\ntheorem mk_top [OrderTop α] [OrderTop (Subtype p)] (htop : p ⊤) : mk ⊤ htop = ⊤ :=\n  top_le_iff.1 <| coe_le_coe.1 le_top\n\n"}
{"name":"Subtype.coe_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝² : PartialOrder α\ninst✝¹ : OrderBot α\ninst✝ : OrderBot (Subtype p)\nhbot : p Bot.bot\n⊢ Eq (↑Bot.bot) Bot.bot","decl":"theorem coe_bot [OrderBot α] [OrderBot (Subtype p)] (hbot : p ⊥) : ((⊥ : Subtype p) : α) = ⊥ :=\n  congr_arg Subtype.val (mk_bot hbot).symm\n\n"}
{"name":"Subtype.coe_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝² : PartialOrder α\ninst✝¹ : OrderTop α\ninst✝ : OrderTop (Subtype p)\nhtop : p Top.top\n⊢ Eq (↑Top.top) Top.top","decl":"theorem coe_top [OrderTop α] [OrderTop (Subtype p)] (htop : p ⊤) : ((⊤ : Subtype p) : α) = ⊤ :=\n  congr_arg Subtype.val (mk_top htop).symm\n\n"}
{"name":"Subtype.coe_eq_bot_iff","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝² : PartialOrder α\ninst✝¹ : OrderBot α\ninst✝ : OrderBot (Subtype p)\nhbot : p Bot.bot\nx : Subtype fun x => p x\n⊢ Iff (Eq (↑x) Bot.bot) (Eq x Bot.bot)","decl":"@[simp]\ntheorem coe_eq_bot_iff [OrderBot α] [OrderBot (Subtype p)] (hbot : p ⊥) {x : { x // p x }} :\n    (x : α) = ⊥ ↔ x = ⊥ := by\n  rw [← coe_bot hbot, Subtype.ext_iff]\n\n"}
{"name":"Subtype.coe_eq_top_iff","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝² : PartialOrder α\ninst✝¹ : OrderTop α\ninst✝ : OrderTop (Subtype p)\nhtop : p Top.top\nx : Subtype fun x => p x\n⊢ Iff (Eq (↑x) Top.top) (Eq x Top.top)","decl":"@[simp]\ntheorem coe_eq_top_iff [OrderTop α] [OrderTop (Subtype p)] (htop : p ⊤) {x : { x // p x }} :\n    (x : α) = ⊤ ↔ x = ⊤ := by\n  rw [← coe_top htop, Subtype.ext_iff]\n\n"}
{"name":"Subtype.mk_eq_bot_iff","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝² : PartialOrder α\ninst✝¹ : OrderBot α\ninst✝ : OrderBot (Subtype p)\nhbot : p Bot.bot\nx : α\nhx : p x\n⊢ Iff (Eq ⟨x, hx⟩ Bot.bot) (Eq x Bot.bot)","decl":"@[simp]\ntheorem mk_eq_bot_iff [OrderBot α] [OrderBot (Subtype p)] (hbot : p ⊥) {x : α} (hx : p x) :\n    (⟨x, hx⟩ : Subtype p) = ⊥ ↔ x = ⊥ :=\n  (coe_eq_bot_iff hbot).symm\n\n"}
{"name":"Subtype.mk_eq_top_iff","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝² : PartialOrder α\ninst✝¹ : OrderTop α\ninst✝ : OrderTop (Subtype p)\nhtop : p Top.top\nx : α\nhx : p x\n⊢ Iff (Eq ⟨x, hx⟩ Top.top) (Eq x Top.top)","decl":"@[simp]\ntheorem mk_eq_top_iff [OrderTop α] [OrderTop (Subtype p)] (htop : p ⊤) {x : α} (hx : p x) :\n    (⟨x, hx⟩ : Subtype p) = ⊤ ↔ x = ⊤ :=\n  (coe_eq_top_iff htop).symm\n\n"}
{"name":"Prod.fst_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Top α\ninst✝ : Top β\n⊢ Eq Top.top.fst Top.top","decl":"@[simp] lemma fst_top [Top α] [Top β] : (⊤ : α × β).fst = ⊤ := rfl\n"}
{"name":"Prod.snd_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Top α\ninst✝ : Top β\n⊢ Eq Top.top.snd Top.top","decl":"@[simp] lemma snd_top [Top α] [Top β] : (⊤ : α × β).snd = ⊤ := rfl\n"}
{"name":"Prod.fst_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Bot α\ninst✝ : Bot β\n⊢ Eq Bot.bot.fst Bot.bot","decl":"@[simp] lemma fst_bot [Bot α] [Bot β] : (⊥ : α × β).fst = ⊥ := rfl\n"}
{"name":"Prod.snd_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Bot α\ninst✝ : Bot β\n⊢ Eq Bot.bot.snd Bot.bot","decl":"@[simp] lemma snd_bot [Bot α] [Bot β] : (⊥ : α × β).snd = ⊥ := rfl\n\n"}
{"name":"ULift.up_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝ : Top α\n⊢ Eq { down := Top.top } Top.top","decl":"@[simp] theorem up_top [Top α] : up (⊤ : α) = ⊤ := rfl\n"}
{"name":"ULift.down_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝ : Top α\n⊢ Eq Top.top.down Top.top","decl":"@[simp] theorem down_top [Top α] : down (⊤ : ULift α) = ⊤ := rfl\n\n"}
{"name":"ULift.up_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝ : Bot α\n⊢ Eq { down := Bot.bot } Bot.bot","decl":"@[simp] theorem up_bot [Bot α] : up (⊥ : α) = ⊥ := rfl\n"}
{"name":"ULift.down_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝ : Bot α\n⊢ Eq Bot.bot.down Bot.bot","decl":"@[simp] theorem down_bot [Bot α] : down (⊥ : ULift α) = ⊥ := rfl\n\n"}
{"name":"bot_ne_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝² : PartialOrder α\ninst✝¹ : BoundedOrder α\ninst✝ : Nontrivial α\n⊢ Ne Bot.bot Top.top","decl":"@[simp]\ntheorem bot_ne_top : (⊥ : α) ≠ ⊤ := fun h => not_subsingleton _ <| subsingleton_of_bot_eq_top h\n\n"}
{"name":"top_ne_bot","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝² : PartialOrder α\ninst✝¹ : BoundedOrder α\ninst✝ : Nontrivial α\n⊢ Ne Top.top Bot.bot","decl":"@[simp]\ntheorem top_ne_bot : (⊤ : α) ≠ ⊥ :=\n  bot_ne_top.symm\n\n"}
{"name":"bot_lt_top","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"α : Type u\ninst✝² : PartialOrder α\ninst✝¹ : BoundedOrder α\ninst✝ : Nontrivial α\n⊢ LT.lt Bot.bot Top.top","decl":"@[simp]\ntheorem bot_lt_top : (⊥ : α) < ⊤ :=\n  lt_top_iff_ne_top.2 bot_ne_top\n\n"}
{"name":"top_eq_true","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"⊢ Eq Top.top Bool.true","decl":"@[simp]\ntheorem top_eq_true : ⊤ = true :=\n  rfl\n\n"}
{"name":"bot_eq_false","module":"Mathlib.Order.BoundedOrder.Basic","initialProofState":"⊢ Eq Bot.bot Bool.false","decl":"@[simp]\ntheorem bot_eq_false : ⊥ = false :=\n  rfl\n\n"}
