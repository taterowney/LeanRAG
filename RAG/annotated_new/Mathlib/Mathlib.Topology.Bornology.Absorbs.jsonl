{"name":"Absorbs.empty","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : Bornology M\ninst✝ : SMul M α\ns : Set α\n⊢ Absorbs M s EmptyCollection.emptyCollection","decl":"protected lemma empty : Absorbs M s ∅ := by simp [Absorbs]\n\n"}
{"name":"Absorbs.eventually","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : Bornology M\ninst✝ : SMul M α\ns t : Set α\nh : Absorbs M s t\n⊢ Filter.Eventually (fun a => HasSubset.Subset t (HSMul.hSMul a s)) (Bornology.cobounded M)","decl":"protected lemma eventually (h : Absorbs M s t) : ∀ᶠ a in cobounded M, t ⊆ a • s := h\n\n"}
{"name":"Absorbs.of_boundedSpace","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝² : Bornology M\ninst✝¹ : SMul M α\ns t : Set α\ninst✝ : BoundedSpace M\n⊢ Absorbs M s t","decl":"@[simp] lemma of_boundedSpace [BoundedSpace M] : Absorbs M s t := by simp [Absorbs]\n\n"}
{"name":"Absorbs.mono_left","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : Bornology M\ninst✝ : SMul M α\ns₁ s₂ t : Set α\nh : Absorbs M s₁ t\nhs : HasSubset.Subset s₁ s₂\n⊢ Absorbs M s₂ t","decl":"lemma mono_left (h : Absorbs M s₁ t) (hs : s₁ ⊆ s₂) : Absorbs M s₂ t :=\n  h.mono fun _a ha ↦ ha.trans <| smul_set_mono hs\n\n"}
{"name":"Absorbs.mono_right","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : Bornology M\ninst✝ : SMul M α\ns t₁ t₂ : Set α\nh : Absorbs M s t₁\nht : HasSubset.Subset t₂ t₁\n⊢ Absorbs M s t₂","decl":"lemma mono_right (h : Absorbs M s t₁) (ht : t₂ ⊆ t₁) : Absorbs M s t₂ :=\n  h.mono fun _ ↦ ht.trans\n\n"}
{"name":"Absorbs.mono","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : Bornology M\ninst✝ : SMul M α\ns₁ s₂ t₁ t₂ : Set α\nh : Absorbs M s₁ t₁\nhs : HasSubset.Subset s₁ s₂\nht : HasSubset.Subset t₂ t₁\n⊢ Absorbs M s₂ t₂","decl":"lemma mono (h : Absorbs M s₁ t₁) (hs : s₁ ⊆ s₂) (ht : t₂ ⊆ t₁) : Absorbs M s₂ t₂ :=\n  (h.mono_left hs).mono_right ht\n\n"}
{"name":"absorbs_union","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : Bornology M\ninst✝ : SMul M α\ns t₁ t₂ : Set α\n⊢ Iff (Absorbs M s (Union.union t₁ t₂)) (And (Absorbs M s t₁) (Absorbs M s t₂))","decl":"@[simp]\nlemma _root_.absorbs_union : Absorbs M s (t₁ ∪ t₂) ↔ Absorbs M s t₁ ∧ Absorbs M s t₂ := by\n  simp [Absorbs]\n\n"}
{"name":"Absorbs.union","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : Bornology M\ninst✝ : SMul M α\ns t₁ t₂ : Set α\nh₁ : Absorbs M s t₁\nh₂ : Absorbs M s t₂\n⊢ Absorbs M s (Union.union t₁ t₂)","decl":"protected lemma union (h₁ : Absorbs M s t₁) (h₂ : Absorbs M s t₂) : Absorbs M s (t₁ ∪ t₂) :=\n  absorbs_union.2 ⟨h₁, h₂⟩\n\n"}
{"name":"Set.Finite.absorbs_sUnion","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : Bornology M\ninst✝ : SMul M α\ns : Set α\nT : Set (Set α)\nhT : T.Finite\n⊢ Iff (Absorbs M s T.sUnion) (∀ (t : Set α), Membership.mem T t → Absorbs M s t)","decl":"lemma _root_.Set.Finite.absorbs_sUnion {T : Set (Set α)} (hT : T.Finite) :\n    Absorbs M s (⋃₀ T) ↔ ∀ t ∈ T, Absorbs M s t := by\n  simp [Absorbs, hT]\n\n"}
{"name":"Absorbs.sUnion","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : Bornology M\ninst✝ : SMul M α\ns : Set α\nT : Set (Set α)\nhT : T.Finite\nhs : ∀ (t : Set α), Membership.mem T t → Absorbs M s t\n⊢ Absorbs M s T.sUnion","decl":"protected lemma sUnion (hT : T.Finite) (hs : ∀ t ∈ T, Absorbs M s t) :\n    Absorbs M s (⋃₀ T) :=\n  hT.absorbs_sUnion.2 hs\n\n"}
{"name":"absorbs_iUnion","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝² : Bornology M\ninst✝¹ : SMul M α\ns : Set α\nι : Sort u_3\ninst✝ : Finite ι\nt : ι → Set α\n⊢ Iff (Absorbs M s (Set.iUnion fun i => t i)) (∀ (i : ι), Absorbs M s (t i))","decl":"@[simp]\nlemma _root_.absorbs_iUnion {ι : Sort*} [Finite ι] {t : ι → Set α} :\n    Absorbs M s (⋃ i, t i) ↔ ∀ i, Absorbs M s (t i) :=\n  (finite_range t).absorbs_sUnion.trans forall_mem_range\n\n"}
{"name":"Absorbs.iUnion","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝² : Bornology M\ninst✝¹ : SMul M α\ns : Set α\nι : Sort u_3\ninst✝ : Finite ι\nt : ι → Set α\na✝ : ∀ (i : ι), Absorbs M s (t i)\n⊢ Absorbs M s (Set.iUnion fun i => t i)","decl":"protected alias ⟨_, iUnion⟩ := absorbs_iUnion\n\n"}
{"name":"Set.Finite.absorbs_biUnion","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : Bornology M\ninst✝ : SMul M α\ns : Set α\nι : Type u_3\nt : ι → Set α\nI : Set ι\nhI : I.Finite\n⊢ Iff (Absorbs M s (Set.iUnion fun i => Set.iUnion fun h => t i)) (∀ (i : ι), Membership.mem I i → Absorbs M s (t i))","decl":"lemma _root_.Set.Finite.absorbs_biUnion {ι : Type*} {t : ι → Set α} {I : Set ι} (hI : I.Finite) :\n    Absorbs M s (⋃ i ∈ I, t i) ↔ ∀ i ∈ I, Absorbs M s (t i) := by\n  simp [Absorbs, hI]\n\n"}
{"name":"Absorbs.biUnion","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : Bornology M\ninst✝ : SMul M α\ns : Set α\nι : Type u_3\nt : ι → Set α\nI : Set ι\nhI : I.Finite\na✝ : ∀ (i : ι), Membership.mem I i → Absorbs M s (t i)\n⊢ Absorbs M s (Set.iUnion fun i => Set.iUnion fun h => t i)","decl":"protected alias ⟨_, biUnion⟩ := Set.Finite.absorbs_biUnion\n\n"}
{"name":"absorbs_biUnion_finset","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : Bornology M\ninst✝ : SMul M α\ns : Set α\nι : Type u_3\nt : ι → Set α\nI : Finset ι\n⊢ Iff (Absorbs M s (Set.iUnion fun i => Set.iUnion fun h => t i)) (∀ (i : ι), Membership.mem I i → Absorbs M s (t i))","decl":"@[simp]\nlemma _root_.absorbs_biUnion_finset {ι : Type*} {t : ι → Set α} {I : Finset ι} :\n    Absorbs M s (⋃ i ∈ I, t i) ↔ ∀ i ∈ I, Absorbs M s (t i) :=\n  I.finite_toSet.absorbs_biUnion\n\n"}
{"name":"Absorbs.biUnion_finset","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : Bornology M\ninst✝ : SMul M α\ns : Set α\nι : Type u_3\nt : ι → Set α\nI : Finset ι\na✝ : ∀ (i : ι), Membership.mem I i → Absorbs M s (t i)\n⊢ Absorbs M s (Set.iUnion fun i => Set.iUnion fun h => t i)","decl":"protected alias ⟨_, biUnion_finset⟩ := absorbs_biUnion_finset\n\n"}
{"name":"Absorbs.add","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nE : Type u_2\ninst✝² : Bornology M\ns₁ s₂ t₁ t₂ : Set E\ninst✝¹ : AddZeroClass E\ninst✝ : DistribSMul M E\nh₁ : Absorbs M s₁ t₁\nh₂ : Absorbs M s₂ t₂\n⊢ Absorbs M (HAdd.hAdd s₁ s₂) (HAdd.hAdd t₁ t₂)","decl":"protected lemma add [AddZeroClass E] [DistribSMul M E]\n    (h₁ : Absorbs M s₁ t₁) (h₂ : Absorbs M s₂ t₂) : Absorbs M (s₁ + s₂) (t₁ + t₂) :=\n  h₂.mp <| h₁.eventually.mono fun x hx₁ hx₂ ↦ by rw [smul_add]; exact add_subset_add hx₁ hx₂\n\n"}
{"name":"Absorbs.zero","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nE : Type u_2\ninst✝² : Bornology M\ninst✝¹ : Zero E\ninst✝ : SMulZeroClass M E\ns : Set E\nhs : Membership.mem s 0\n⊢ Absorbs M s 0","decl":"protected lemma zero [Zero E] [SMulZeroClass M E] {s : Set E} (hs : 0 ∈ s) : Absorbs M s 0 :=\n  Eventually.of_forall fun _ ↦ zero_subset.2 <| zero_mem_smul_set hs\n\n"}
{"name":"Absorbs.univ","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"G₀ : Type u_1\nα : Type u_2\ninst✝² : GroupWithZero G₀\ninst✝¹ : Bornology G₀\ninst✝ : MulAction G₀ α\ns : Set α\n⊢ Absorbs G₀ Set.univ s","decl":"@[simp]\nprotected lemma Absorbs.univ : Absorbs G₀ univ s :=\n  (eventually_ne_cobounded 0).mono fun a ha ↦ by rw [smul_set_univ₀ ha]; apply subset_univ\n\n"}
{"name":"absorbs_iff_eventually_cobounded_mapsTo","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"G₀ : Type u_1\nα : Type u_2\ninst✝² : GroupWithZero G₀\ninst✝¹ : Bornology G₀\ninst✝ : MulAction G₀ α\ns t : Set α\n⊢ Iff (Absorbs G₀ s t) (Filter.Eventually (fun c => Set.MapsTo (fun x => HSMul.hSMul (Inv.inv c) x) t s) (Bornology.cobounded G₀))","decl":"lemma absorbs_iff_eventually_cobounded_mapsTo :\n    Absorbs G₀ s t ↔ ∀ᶠ c in cobounded G₀, MapsTo (c⁻¹ • ·) t s :=\n  eventually_congr <| (eventually_ne_cobounded 0).mono fun c hc ↦ by\n    rw [← preimage_smul_inv₀ hc]; rfl\n\n"}
{"name":"eventually_cobounded_mapsTo","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"G₀ : Type u_1\nα : Type u_2\ninst✝² : GroupWithZero G₀\ninst✝¹ : Bornology G₀\ninst✝ : MulAction G₀ α\ns t : Set α\na✝ : Absorbs G₀ s t\n⊢ Filter.Eventually (fun c => Set.MapsTo (fun x => HSMul.hSMul (Inv.inv c) x) t s) (Bornology.cobounded G₀)","decl":"alias ⟨eventually_cobounded_mapsTo, _⟩ := absorbs_iff_eventually_cobounded_mapsTo\n\n"}
{"name":"absorbs_inter","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"G₀ : Type u_1\nα : Type u_2\ninst✝² : GroupWithZero G₀\ninst✝¹ : Bornology G₀\ninst✝ : MulAction G₀ α\ns t u : Set α\n⊢ Iff (Absorbs G₀ (Inter.inter s t) u) (And (Absorbs G₀ s u) (Absorbs G₀ t u))","decl":"@[simp]\nlemma absorbs_inter : Absorbs G₀ (s ∩ t) u ↔ Absorbs G₀ s u ∧ Absorbs G₀ t u := by\n  simp only [absorbs_iff_eventually_cobounded_mapsTo, mapsTo_inter, eventually_and]\n\n"}
{"name":"Absorbs.inter","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"G₀ : Type u_1\nα : Type u_2\ninst✝² : GroupWithZero G₀\ninst✝¹ : Bornology G₀\ninst✝ : MulAction G₀ α\ns t u : Set α\nhs : Absorbs G₀ s u\nht : Absorbs G₀ t u\n⊢ Absorbs G₀ (Inter.inter s t) u","decl":"protected lemma Absorbs.inter (hs : Absorbs G₀ s u) (ht : Absorbs G₀ t u) : Absorbs G₀ (s ∩ t) u :=\n  absorbs_inter.2 ⟨hs, ht⟩\n\n"}
{"name":"Filter.mem_absorbing","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"G₀ : Type u_1\nα : Type u_2\ninst✝² : GroupWithZero G₀\ninst✝¹ : Bornology G₀\ninst✝ : MulAction G₀ α\ns u : Set α\n⊢ Iff (Membership.mem (Filter.absorbing G₀ u) s) (Absorbs G₀ s u)","decl":"@[simp]\nlemma Filter.mem_absorbing : s ∈ absorbing G₀ u ↔ Absorbs G₀ s u := .rfl\n\n"}
{"name":"Set.Finite.absorbs_sInter","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"G₀ : Type u_1\nα : Type u_2\ninst✝² : GroupWithZero G₀\ninst✝¹ : Bornology G₀\ninst✝ : MulAction G₀ α\nt : Set α\nS : Set (Set α)\nhS : S.Finite\n⊢ Iff (Absorbs G₀ S.sInter t) (∀ (s : Set α), Membership.mem S s → Absorbs G₀ s t)","decl":"lemma Set.Finite.absorbs_sInter (hS : S.Finite) :\n    Absorbs G₀ (⋂₀ S) t ↔ ∀ s ∈ S, Absorbs G₀ s t :=\n  sInter_mem (f := absorbing G₀ t) hS\n\n"}
{"name":"Absorbs.sInter","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"G₀ : Type u_1\nα : Type u_2\ninst✝² : GroupWithZero G₀\ninst✝¹ : Bornology G₀\ninst✝ : MulAction G₀ α\nt : Set α\nS : Set (Set α)\nhS : S.Finite\na✝ : ∀ (s : Set α), Membership.mem S s → Absorbs G₀ s t\n⊢ Absorbs G₀ S.sInter t","decl":"protected alias ⟨_, Absorbs.sInter⟩ := Set.Finite.absorbs_sInter\n\n"}
{"name":"absorbs_iInter","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"G₀ : Type u_1\nα : Type u_2\ninst✝³ : GroupWithZero G₀\ninst✝² : Bornology G₀\ninst✝¹ : MulAction G₀ α\nt : Set α\nι : Sort u_3\ninst✝ : Finite ι\ns : ι → Set α\n⊢ Iff (Absorbs G₀ (Set.iInter fun i => s i) t) (∀ (i : ι), Absorbs G₀ (s i) t)","decl":"@[simp]\nlemma absorbs_iInter {ι : Sort*} [Finite ι] {s : ι → Set α} :\n    Absorbs G₀ (⋂ i, s i) t ↔ ∀ i, Absorbs G₀ (s i) t :=\n  iInter_mem (f := absorbing G₀ t)\n\n"}
{"name":"Absorbs.iInter","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"G₀ : Type u_1\nα : Type u_2\ninst✝³ : GroupWithZero G₀\ninst✝² : Bornology G₀\ninst✝¹ : MulAction G₀ α\nt : Set α\nι : Sort u_3\ninst✝ : Finite ι\ns : ι → Set α\na✝ : ∀ (i : ι), Absorbs G₀ (s i) t\n⊢ Absorbs G₀ (Set.iInter fun i => s i) t","decl":"protected alias ⟨_, Absorbs.iInter⟩ := absorbs_iInter\n\n"}
{"name":"Set.Finite.absorbs_biInter","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"G₀ : Type u_1\nα : Type u_2\ninst✝² : GroupWithZero G₀\ninst✝¹ : Bornology G₀\ninst✝ : MulAction G₀ α\nt : Set α\nι : Type u_3\nI : Set ι\nhI : I.Finite\ns : ι → Set α\n⊢ Iff (Absorbs G₀ (Set.iInter fun i => Set.iInter fun h => s i) t) (∀ (i : ι), Membership.mem I i → Absorbs G₀ (s i) t)","decl":"lemma Set.Finite.absorbs_biInter {ι : Type*} {I : Set ι} (hI : I.Finite) {s : ι → Set α} :\n    Absorbs G₀ (⋂ i ∈ I, s i) t ↔ ∀ i ∈ I, Absorbs G₀ (s i) t :=\n  biInter_mem (f := absorbing G₀ t) hI\n\n"}
{"name":"Absorbs.biInter","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"G₀ : Type u_1\nα : Type u_2\ninst✝² : GroupWithZero G₀\ninst✝¹ : Bornology G₀\ninst✝ : MulAction G₀ α\nt : Set α\nι : Type u_3\nI : Set ι\nhI : I.Finite\ns : ι → Set α\na✝ : ∀ (i : ι), Membership.mem I i → Absorbs G₀ (s i) t\n⊢ Absorbs G₀ (Set.iInter fun i => Set.iInter fun h => s i) t","decl":"protected alias ⟨_, Absorbs.biInter⟩ := Set.Finite.absorbs_biInter\n\n"}
{"name":"absorbs_zero_iff","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"G₀ : Type u_1\ninst✝⁴ : GroupWithZero G₀\ninst✝³ : Bornology G₀\ninst✝² : (Bornology.cobounded G₀).NeBot\nE : Type u_3\ninst✝¹ : AddMonoid E\ninst✝ : DistribMulAction G₀ E\ns : Set E\n⊢ Iff (Absorbs G₀ s 0) (Membership.mem s 0)","decl":"@[simp]\nlemma absorbs_zero_iff [NeBot (cobounded G₀)]\n    {E : Type*} [AddMonoid E] [DistribMulAction G₀ E] {s : Set E} :\n    Absorbs G₀ s 0 ↔ 0 ∈ s := by\n  simp only [absorbs_iff_eventually_cobounded_mapsTo, ← singleton_zero,\n    mapsTo_singleton, smul_zero, eventually_const]\n\n"}
{"name":"absorbs_neg_neg","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nE : Type u_2\ninst✝³ : Monoid M\ninst✝² : AddGroup E\ninst✝¹ : DistribMulAction M E\ninst✝ : Bornology M\ns t : Set E\n⊢ Iff (Absorbs M (Neg.neg s) (Neg.neg t)) (Absorbs M s t)","decl":"@[simp]\nlemma absorbs_neg_neg {s t : Set E} : Absorbs M (-s) (-t) ↔ Absorbs M s t := by simp [Absorbs]\n\n"}
{"name":"Absorbs.neg_neg","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nE : Type u_2\ninst✝³ : Monoid M\ninst✝² : AddGroup E\ninst✝¹ : DistribMulAction M E\ninst✝ : Bornology M\ns t : Set E\na✝ : Absorbs M s t\n⊢ Absorbs M (Neg.neg s) (Neg.neg t)","decl":"alias ⟨Absorbs.of_neg_neg, Absorbs.neg_neg⟩ := absorbs_neg_neg\n\n"}
{"name":"Absorbs.of_neg_neg","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nE : Type u_2\ninst✝³ : Monoid M\ninst✝² : AddGroup E\ninst✝¹ : DistribMulAction M E\ninst✝ : Bornology M\ns t : Set E\na✝ : Absorbs M (Neg.neg s) (Neg.neg t)\n⊢ Absorbs M s t","decl":"alias ⟨Absorbs.of_neg_neg, Absorbs.neg_neg⟩ := absorbs_neg_neg\n\n"}
{"name":"Absorbs.sub","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nE : Type u_2\ninst✝³ : Monoid M\ninst✝² : AddGroup E\ninst✝¹ : DistribMulAction M E\ninst✝ : Bornology M\ns₁ s₂ t₁ t₂ : Set E\nh₁ : Absorbs M s₁ t₁\nh₂ : Absorbs M s₂ t₂\n⊢ Absorbs M (HSub.hSub s₁ s₂) (HSub.hSub t₁ t₂)","decl":"lemma Absorbs.sub {s₁ s₂ t₁ t₂ : Set E} (h₁ : Absorbs M s₁ t₁) (h₂ : Absorbs M s₂ t₂) :\n    Absorbs M (s₁ - s₂) (t₁ - t₂) := by\n  simpa only [sub_eq_add_neg] using h₁.add h₂.neg_neg\n\n"}
{"name":"Absorbent.mono","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : Bornology M\ninst✝ : SMul M α\ns t : Set α\nht : Absorbent M s\nhsub : HasSubset.Subset s t\n⊢ Absorbent M t","decl":"protected theorem mono (ht : Absorbent M s) (hsub : s ⊆ t) : Absorbent M t := fun x ↦\n  (ht x).mono_left hsub\n\n"}
{"name":"absorbent_iff_forall_absorbs_singleton","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : Bornology M\ninst✝ : SMul M α\ns : Set α\n⊢ Iff (Absorbent M s) (∀ (x : α), Absorbs M s (Singleton.singleton x))","decl":"theorem _root_.absorbent_iff_forall_absorbs_singleton : Absorbent M s ↔ ∀ x, Absorbs M s {x} := .rfl\n\n"}
{"name":"Absorbent.absorbs","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : Bornology M\ninst✝ : SMul M α\ns : Set α\nhs : Absorbent M s\nx : α\n⊢ Absorbs M s (Singleton.singleton x)","decl":"protected theorem absorbs (hs : Absorbent M s) {x : α} : Absorbs M s {x} := hs x\n\n"}
{"name":"Absorbent.absorbs_finite","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nα : Type u_2\ninst✝¹ : Bornology M\ninst✝ : SMul M α\ns t : Set α\nhs : Absorbent M s\nht : t.Finite\n⊢ Absorbs M s t","decl":"theorem absorbs_finite (hs : Absorbent M s) (ht : t.Finite) : Absorbs M s t := by\n  rw [← Set.biUnion_of_singleton t]\n  exact .biUnion ht fun _ _ => hs.absorbs\n\n"}
{"name":"Absorbent.vadd_absorbs","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nE : Type u_2\ninst✝² : Bornology M\ninst✝¹ : AddZeroClass E\ninst✝ : DistribSMul M E\ns₁ s₂ t : Set E\nx : E\nh₁ : Absorbent M s₁\nh₂ : Absorbs M s₂ t\n⊢ Absorbs M (HAdd.hAdd s₁ s₂) (HVAdd.hVAdd x t)","decl":"theorem vadd_absorbs {M E : Type*} [Bornology M] [AddZeroClass E] [DistribSMul M E]\n    {s₁ s₂ t : Set E} {x : E} (h₁ : Absorbent M s₁) (h₂ : Absorbs M s₂ t) :\n    Absorbs M (s₁ + s₂) (x +ᵥ t) := by\n  rw [← singleton_vadd]; exact (h₁ x).add h₂\n\n"}
{"name":"absorbent_univ","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"G₀ : Type u_1\nα : Type u_2\ninst✝² : GroupWithZero G₀\ninst✝¹ : Bornology G₀\ninst✝ : MulAction G₀ α\n⊢ Absorbent G₀ Set.univ","decl":"lemma absorbent_univ : Absorbent G₀ (univ : Set α) := fun _ ↦ .univ\n\n"}
{"name":"absorbent_iff_inv_smul","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"G₀ : Type u_1\nα : Type u_2\ninst✝² : GroupWithZero G₀\ninst✝¹ : Bornology G₀\ninst✝ : MulAction G₀ α\ns : Set α\n⊢ Iff (Absorbent G₀ s) (∀ (x : α), Filter.Eventually (fun c => Membership.mem s (HSMul.hSMul (Inv.inv c) x)) (Bornology.cobounded G₀))","decl":"lemma absorbent_iff_inv_smul {s : Set α} :\n    Absorbent G₀ s ↔ ∀ x, ∀ᶠ c in cobounded G₀, c⁻¹ • x ∈ s :=\n  forall_congr' fun x ↦ by simp only [absorbs_iff_eventually_cobounded_mapsTo, mapsTo_singleton]\n\n"}
{"name":"Absorbent.zero_mem","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"G₀ : Type u_1\nE : Type u_3\ninst✝⁴ : GroupWithZero G₀\ninst✝³ : Bornology G₀\ninst✝² : (Bornology.cobounded G₀).NeBot\ninst✝¹ : AddMonoid E\ninst✝ : DistribMulAction G₀ E\ns : Set E\nhs : Absorbent G₀ s\n⊢ Membership.mem s 0","decl":"lemma Absorbent.zero_mem [NeBot (cobounded G₀)] [AddMonoid E] [DistribMulAction G₀ E]\n    {s : Set E} (hs : Absorbent G₀ s) : (0 : E) ∈ s :=\n  absorbs_zero_iff.1 (hs 0)\n\n"}
{"name":"Absorbs.restrict_scalars","module":"Mathlib.Topology.Bornology.Absorbs","initialProofState":"M : Type u_1\nN : Type u_2\nα : Type u_3\ninst✝⁶ : Monoid N\ninst✝⁵ : SMul M N\ninst✝⁴ : SMul M α\ninst✝³ : MulAction N α\ninst✝² : IsScalarTower M N α\ninst✝¹ : Bornology M\ninst✝ : Bornology N\ns t : Set α\nh : Absorbs N s t\nhbdd : Filter.Tendsto (fun x => HSMul.hSMul x 1) (Bornology.cobounded M) (Bornology.cobounded N)\n⊢ Absorbs M s t","decl":"protected theorem Absorbs.restrict_scalars\n    {M N α : Type*} [Monoid N] [SMul M N] [SMul M α] [MulAction N α]\n    [IsScalarTower M N α] [Bornology M] [Bornology N] {s t : Set α} (h : Absorbs N s t)\n    (hbdd : Tendsto (· • 1 : M → N) (cobounded M) (cobounded N)) :\n    Absorbs M s t :=\n  (hbdd.eventually h).mono <| fun x hx ↦ by rwa [smul_one_smul N x s] at hx\n"}
