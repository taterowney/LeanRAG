{"name":"IsApproximateAddSubgroup.zero_mem","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nK : Real\nA : Set G\nself : IsApproximateAddSubgroup K A\n⊢ Membership.mem A 0","decl":"/--\nAn approximate subgroup in a group is a symmetric set `A` containing the identity and such that\n`A + A` can be covered by a small number of translates of `A`.\n\nIn practice, we will take `K` fixed and `A` large but finite.\n-/\nstructure IsApproximateAddSubgroup {G : Type*} [AddGroup G] (K : ℝ) (A : Set G) : Prop where\n  zero_mem : 0 ∈ A\n  neg_eq_self : -A = A\n  two_nsmul_covByVAdd : CovByVAdd G K (2 • A) A\n\n"}
{"name":"IsApproximateAddSubgroup.two_nsmul_covByVAdd","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nK : Real\nA : Set G\nself : IsApproximateAddSubgroup K A\n⊢ CovByVAdd G K (HSMul.hSMul 2 A) A","decl":"/--\nAn approximate subgroup in a group is a symmetric set `A` containing the identity and such that\n`A + A` can be covered by a small number of translates of `A`.\n\nIn practice, we will take `K` fixed and `A` large but finite.\n-/\nstructure IsApproximateAddSubgroup {G : Type*} [AddGroup G] (K : ℝ) (A : Set G) : Prop where\n  zero_mem : 0 ∈ A\n  neg_eq_self : -A = A\n  two_nsmul_covByVAdd : CovByVAdd G K (2 • A) A\n\n"}
{"name":"IsApproximateAddSubgroup.neg_eq_self","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_2\ninst✝ : AddGroup G\nK : Real\nA : Set G\nself : IsApproximateAddSubgroup K A\n⊢ Eq (Neg.neg A) A","decl":"/--\nAn approximate subgroup in a group is a symmetric set `A` containing the identity and such that\n`A + A` can be covered by a small number of translates of `A`.\n\nIn practice, we will take `K` fixed and `A` large but finite.\n-/\nstructure IsApproximateAddSubgroup {G : Type*} [AddGroup G] (K : ℝ) (A : Set G) : Prop where\n  zero_mem : 0 ∈ A\n  neg_eq_self : -A = A\n  two_nsmul_covByVAdd : CovByVAdd G K (2 • A) A\n\n"}
{"name":"IsApproximateSubgroup.inv_eq_self","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Real\nA : Set G\nself : IsApproximateSubgroup K A\n⊢ Eq (Inv.inv A) A","decl":"/--\nAn approximate subgroup in a group is a symmetric set `A` containing the identity and such that\n`A * A` can be covered by a small number of translates of `A`.\n\nIn practice, we will take `K` fixed and `A` large but finite.\n-/\n@[to_additive]\nstructure IsApproximateSubgroup (K : ℝ) (A : Set G) : Prop where\n  one_mem : 1 ∈ A\n  inv_eq_self : A⁻¹ = A\n  sq_covBySMul : CovBySMul G K (A ^ 2) A\n\n"}
{"name":"IsApproximateSubgroup.sq_covBySMul","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Real\nA : Set G\nself : IsApproximateSubgroup K A\n⊢ CovBySMul G K (HPow.hPow A 2) A","decl":"/--\nAn approximate subgroup in a group is a symmetric set `A` containing the identity and such that\n`A * A` can be covered by a small number of translates of `A`.\n\nIn practice, we will take `K` fixed and `A` large but finite.\n-/\n@[to_additive]\nstructure IsApproximateSubgroup (K : ℝ) (A : Set G) : Prop where\n  one_mem : 1 ∈ A\n  inv_eq_self : A⁻¹ = A\n  sq_covBySMul : CovBySMul G K (A ^ 2) A\n\n"}
{"name":"IsApproximateSubgroup.one_mem","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝ : Group G\nK : Real\nA : Set G\nself : IsApproximateSubgroup K A\n⊢ Membership.mem A 1","decl":"/--\nAn approximate subgroup in a group is a symmetric set `A` containing the identity and such that\n`A * A` can be covered by a small number of translates of `A`.\n\nIn practice, we will take `K` fixed and `A` large but finite.\n-/\n@[to_additive]\nstructure IsApproximateSubgroup (K : ℝ) (A : Set G) : Prop where\n  one_mem : 1 ∈ A\n  inv_eq_self : A⁻¹ = A\n  sq_covBySMul : CovBySMul G K (A ^ 2) A\n\n"}
{"name":"IsApproximateSubgroup.nonempty","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝ : Group G\nA : Set G\nK : Real\nhA : IsApproximateSubgroup K A\n⊢ A.Nonempty","decl":"@[to_additive] lemma nonempty (hA : IsApproximateSubgroup K A) : A.Nonempty := ⟨1, hA.one_mem⟩\n\n"}
{"name":"IsApproximateAddSubgroup.nonempty","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nA : Set G\nK : Real\nhA : IsApproximateAddSubgroup K A\n⊢ A.Nonempty","decl":"@[to_additive] lemma nonempty (hA : IsApproximateSubgroup K A) : A.Nonempty := ⟨1, hA.one_mem⟩\n\n"}
{"name":"IsApproximateAddSubgroup.one_le","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nA : Set G\nK : Real\nhA : IsApproximateAddSubgroup K A\n⊢ LE.le 1 K","decl":"@[to_additive one_le]\nlemma one_le (hA : IsApproximateSubgroup K A) : 1 ≤ K := by\n  obtain ⟨F, hF, hSF⟩ := hA.sq_covBySMul\n  have hF₀ : F ≠ ∅ := by rintro rfl; simp [hA.nonempty.pow.ne_empty] at hSF\n  exact hF.trans' <| by simpa [Finset.nonempty_iff_ne_empty]\n\n"}
{"name":"IsApproximateSubgroup.one_le","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝ : Group G\nA : Set G\nK : Real\nhA : IsApproximateSubgroup K A\n⊢ LE.le 1 K","decl":"@[to_additive one_le]\nlemma one_le (hA : IsApproximateSubgroup K A) : 1 ≤ K := by\n  obtain ⟨F, hF, hSF⟩ := hA.sq_covBySMul\n  have hF₀ : F ≠ ∅ := by rintro rfl; simp [hA.nonempty.pow.ne_empty] at hSF\n  exact hF.trans' <| by simpa [Finset.nonempty_iff_ne_empty]\n\n"}
{"name":"IsApproximateAddSubgroup.mono","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nA : Set G\nK L : Real\nhKL : LE.le K L\nhA : IsApproximateAddSubgroup K A\n⊢ IsApproximateAddSubgroup L A","decl":"@[to_additive]\nlemma mono (hKL : K ≤ L) (hA : IsApproximateSubgroup K A) : IsApproximateSubgroup L A where\n  one_mem := hA.one_mem\n  inv_eq_self := hA.inv_eq_self\n  sq_covBySMul := hA.sq_covBySMul.mono hKL\n\n"}
{"name":"IsApproximateSubgroup.mono","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝ : Group G\nA : Set G\nK L : Real\nhKL : LE.le K L\nhA : IsApproximateSubgroup K A\n⊢ IsApproximateSubgroup L A","decl":"@[to_additive]\nlemma mono (hKL : K ≤ L) (hA : IsApproximateSubgroup K A) : IsApproximateSubgroup L A where\n  one_mem := hA.one_mem\n  inv_eq_self := hA.inv_eq_self\n  sq_covBySMul := hA.sq_covBySMul.mono hKL\n\n"}
{"name":"IsApproximateSubgroup.card_pow_le","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nK : Real\ninst✝ : DecidableEq G\nA : Finset G\nhA : IsApproximateSubgroup K ↑A\nn : Nat\n⊢ LE.le (↑(HPow.hPow A n).card) (HMul.hMul (HPow.hPow K (HSub.hSub n 1)) ↑A.card)","decl":"@[to_additive]\nlemma card_pow_le [DecidableEq G] {A : Finset G} (hA : IsApproximateSubgroup K (A : Set G)) :\n    ∀ {n}, #(A ^ n) ≤ K ^ (n - 1) * #A\n  | 0 => by simpa using hA.nonempty\n  | 1 => by simp\n  | n + 2 => by\n    obtain ⟨F, hF, hSF⟩ := hA.sq_covBySMul\n    calc\n      (#(A ^ (n + 2)) : ℝ) ≤ #(F ^ (n + 1) * A) := by\n        gcongr; exact mod_cast Set.pow_subset_pow_mul_of_sq_subset_mul hSF (by omega)\n      _ ≤ #(F ^ (n + 1)) * #A := mod_cast Finset.card_mul_le\n      _ ≤ #F ^ (n + 1) * #A := by gcongr; exact mod_cast Finset.card_pow_le\n      _ ≤ K ^ (n + 1) * #A := by gcongr\n\n"}
{"name":"IsApproximateAddSubgroup.card_nsmul_le","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nK : Real\ninst✝ : DecidableEq G\nA : Finset G\nhA : IsApproximateAddSubgroup K ↑A\nn : Nat\n⊢ LE.le (↑(HSMul.hSMul n A).card) (HMul.hMul (HPow.hPow K (HSub.hSub n 1)) ↑A.card)","decl":"@[to_additive]\nlemma card_pow_le [DecidableEq G] {A : Finset G} (hA : IsApproximateSubgroup K (A : Set G)) :\n    ∀ {n}, #(A ^ n) ≤ K ^ (n - 1) * #A\n  | 0 => by simpa using hA.nonempty\n  | 1 => by simp\n  | n + 2 => by\n    obtain ⟨F, hF, hSF⟩ := hA.sq_covBySMul\n    calc\n      (#(A ^ (n + 2)) : ℝ) ≤ #(F ^ (n + 1) * A) := by\n        gcongr; exact mod_cast Set.pow_subset_pow_mul_of_sq_subset_mul hSF (by omega)\n      _ ≤ #(F ^ (n + 1)) * #A := mod_cast Finset.card_mul_le\n      _ ≤ #F ^ (n + 1) * #A := by gcongr; exact mod_cast Finset.card_pow_le\n      _ ≤ K ^ (n + 1) * #A := by gcongr\n\n"}
{"name":"IsApproximateSubgroup.card_mul_self_le","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nK : Real\ninst✝ : DecidableEq G\nA : Finset G\nhA : IsApproximateSubgroup K ↑A\n⊢ LE.le (↑(HMul.hMul A A).card) (HMul.hMul K ↑A.card)","decl":"@[to_additive]\nlemma card_mul_self_le [DecidableEq G] {A : Finset G} (hA : IsApproximateSubgroup K (A : Set G)) :\n    #(A * A) ≤ K * #A := by simpa [sq] using hA.card_pow_le (n := 2)\n\n"}
{"name":"IsApproximateAddSubgroup.card_add_self_le","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nK : Real\ninst✝ : DecidableEq G\nA : Finset G\nhA : IsApproximateAddSubgroup K ↑A\n⊢ LE.le (↑(HAdd.hAdd A A).card) (HMul.hMul K ↑A.card)","decl":"@[to_additive]\nlemma card_mul_self_le [DecidableEq G] {A : Finset G} (hA : IsApproximateSubgroup K (A : Set G)) :\n    #(A * A) ≤ K * #A := by simpa [sq] using hA.card_pow_le (n := 2)\n\n"}
{"name":"IsApproximateAddSubgroup.image","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\nA : Set G\nK : Real\nF : Type u_2\nH : Type u_3\ninst✝² : AddGroup H\ninst✝¹ : FunLike F G H\ninst✝ : AddMonoidHomClass F G H\nf : F\nhA : IsApproximateAddSubgroup K A\n⊢ IsApproximateAddSubgroup K (Set.image (⇑f) A)","decl":"@[to_additive]\nlemma image {F H : Type*} [Group H] [FunLike F G H] [MonoidHomClass F G H] (f : F)\n    (hA : IsApproximateSubgroup K A) : IsApproximateSubgroup K (f '' A) where\n  one_mem := ⟨1, hA.one_mem, map_one _⟩\n  inv_eq_self := by simp [← Set.image_inv, hA.inv_eq_self]\n  sq_covBySMul := by\n    classical\n    obtain ⟨F, hF, hAF⟩ := hA.sq_covBySMul\n    refine ⟨F.image f, ?_, ?_⟩\n    · calc\n        (#(F.image f) : ℝ) ≤ #F := mod_cast F.card_image_le\n        _ ≤ K := hF\n    · simp only [← Set.image_pow, Finset.coe_image, ← Set.image_mul, smul_eq_mul] at hAF ⊢\n      gcongr\n\n"}
{"name":"IsApproximateSubgroup.image","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝³ : Group G\nA : Set G\nK : Real\nF : Type u_2\nH : Type u_3\ninst✝² : Group H\ninst✝¹ : FunLike F G H\ninst✝ : MonoidHomClass F G H\nf : F\nhA : IsApproximateSubgroup K A\n⊢ IsApproximateSubgroup K (Set.image (⇑f) A)","decl":"@[to_additive]\nlemma image {F H : Type*} [Group H] [FunLike F G H] [MonoidHomClass F G H] (f : F)\n    (hA : IsApproximateSubgroup K A) : IsApproximateSubgroup K (f '' A) where\n  one_mem := ⟨1, hA.one_mem, map_one _⟩\n  inv_eq_self := by simp [← Set.image_inv, hA.inv_eq_self]\n  sq_covBySMul := by\n    classical\n    obtain ⟨F, hF, hAF⟩ := hA.sq_covBySMul\n    refine ⟨F.image f, ?_, ?_⟩\n    · calc\n        (#(F.image f) : ℝ) ≤ #F := mod_cast F.card_image_le\n        _ ≤ K := hF\n    · simp only [← Set.image_pow, Finset.coe_image, ← Set.image_mul, smul_eq_mul] at hAF ⊢\n      gcongr\n\n"}
{"name":"IsApproximateAddSubgroup.addSubgroup","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝² : AddGroup G\nS : Type u_2\ninst✝¹ : SetLike S G\ninst✝ : AddSubgroupClass S G\nH : S\n⊢ IsApproximateAddSubgroup 1 ↑H","decl":"@[to_additive]\nlemma subgroup {S : Type*} [SetLike S G] [SubgroupClass S G] {H : S} :\n    IsApproximateSubgroup 1 (H : Set G) where\n  one_mem := OneMemClass.one_mem H\n  inv_eq_self := inv_coe_set\n  sq_covBySMul := ⟨{1}, by simp⟩\n\n"}
{"name":"IsApproximateSubgroup.subgroup","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝² : Group G\nS : Type u_2\ninst✝¹ : SetLike S G\ninst✝ : SubgroupClass S G\nH : S\n⊢ IsApproximateSubgroup 1 ↑H","decl":"@[to_additive]\nlemma subgroup {S : Type*} [SetLike S G] [SubgroupClass S G] {H : S} :\n    IsApproximateSubgroup 1 (H : Set G) where\n  one_mem := OneMemClass.one_mem H\n  inv_eq_self := inv_coe_set\n  sq_covBySMul := ⟨{1}, by simp⟩\n\n"}
{"name":"IsApproximateSubgroup.of_small_tripling","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝¹ : Group G\nK : Real\ninst✝ : DecidableEq G\nA : Finset G\nhA₁ : Membership.mem A 1\nhAsymm : Eq (Inv.inv A) A\nhA : LE.le (↑(HPow.hPow A 3).card) (HMul.hMul K ↑A.card)\n⊢ IsApproximateSubgroup (HPow.hPow K 3) (HPow.hPow (↑A) 2)","decl":"open Finset in\n@[to_additive]\nlemma of_small_tripling [DecidableEq G] {A : Finset G} (hA₁ : 1 ∈ A) (hAsymm : A⁻¹ = A)\n    (hA : #(A ^ 3) ≤ K * #A) : IsApproximateSubgroup (K ^ 3) (A ^ 2 : Set G) where\n  one_mem := by rw [sq, ← one_mul 1]; exact Set.mul_mem_mul hA₁ hA₁\n  inv_eq_self := by simp [← inv_pow, hAsymm, ← coe_inv]\n  sq_covBySMul := by\n    replace hA := calc (#(A ^ 4 * A) : ℝ)\n      _ = #(A ^ 5) := by rw [← pow_succ]\n      _ ≤ K ^ 3 * #A := small_pow_of_small_tripling (by omega) hA hAsymm\n    have hA₀ : A.Nonempty := ⟨1, hA₁⟩\n    obtain ⟨F, -, hF, hAF⟩ := ruzsa_covering_mul hA₀ hA\n    exact ⟨F, hF, by norm_cast; simpa [div_eq_mul_inv, pow_succ, mul_assoc, hAsymm] using hAF⟩\n\n"}
{"name":"IsApproximateAddSubgroup.of_small_tripling","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\nK : Real\ninst✝ : DecidableEq G\nA : Finset G\nhA₁ : Membership.mem A 0\nhAsymm : Eq (Neg.neg A) A\nhA : LE.le (↑(HSMul.hSMul 3 A).card) (HMul.hMul K ↑A.card)\n⊢ IsApproximateAddSubgroup (HPow.hPow K 3) (HSMul.hSMul 2 ↑A)","decl":"open Finset in\n@[to_additive]\nlemma of_small_tripling [DecidableEq G] {A : Finset G} (hA₁ : 1 ∈ A) (hAsymm : A⁻¹ = A)\n    (hA : #(A ^ 3) ≤ K * #A) : IsApproximateSubgroup (K ^ 3) (A ^ 2 : Set G) where\n  one_mem := by rw [sq, ← one_mul 1]; exact Set.mul_mem_mul hA₁ hA₁\n  inv_eq_self := by simp [← inv_pow, hAsymm, ← coe_inv]\n  sq_covBySMul := by\n    replace hA := calc (#(A ^ 4 * A) : ℝ)\n      _ = #(A ^ 5) := by rw [← pow_succ]\n      _ ≤ K ^ 3 * #A := small_pow_of_small_tripling (by omega) hA hAsymm\n    have hA₀ : A.Nonempty := ⟨1, hA₁⟩\n    obtain ⟨F, -, hF, hAF⟩ := ruzsa_covering_mul hA₀ hA\n    exact ⟨F, hF, by norm_cast; simpa [div_eq_mul_inv, pow_succ, mul_assoc, hAsymm] using hAF⟩\n\n"}
{"name":"IsApproximateAddSubgroup.nsmul_inter_nsmul_covByVAdd_sq_inter_sq","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nA B : Set G\nK L : Real\nm n : Nat\nhA : IsApproximateAddSubgroup K A\nhB : IsApproximateAddSubgroup L B\nhm : LE.le 2 m\nhn : LE.le 2 n\n⊢ CovByVAdd G (HMul.hMul (HPow.hPow K (HSub.hSub m 1)) (HPow.hPow L (HSub.hSub n 1))) (Inter.inter (HSMul.hSMul m A) (HSMul.hSMul n B)) (Inter.inter (HSMul.hSMul 2 A) (HSMul.hSMul 2 B))","decl":"open Set in\n@[to_additive]\nlemma pow_inter_pow_covBySMul_sq_inter_sq\n    (hA : IsApproximateSubgroup K A) (hB : IsApproximateSubgroup L B) (hm : 2 ≤ m) (hn : 2 ≤ n) :\n    CovBySMul G (K ^ (m - 1) * L ^ (n - 1)) (A ^ m ∩ B ^ n) (A ^ 2 ∩ B ^ 2) := by\n  classical\n  obtain ⟨F₁, hF₁, hAF₁⟩ := hA.sq_covBySMul\n  obtain ⟨F₂, hF₂, hBF₂⟩ := hB.sq_covBySMul\n  have := hA.one_le\n  choose f hf using exists_smul_inter_smul_subset_smul_inv_mul_inter_inv_mul A B\n  refine ⟨.image₂ f (F₁ ^ (m - 1)) (F₂ ^ (n - 1)), ?_, ?_⟩\n  · calc\n      (#(.image₂ f (F₁ ^ (m - 1)) (F₂ ^ (n - 1))) : ℝ)\n      _ ≤ #(F₁ ^ (m - 1)) * #(F₂ ^ (n - 1)) := mod_cast Finset.card_image₂_le ..\n      _ ≤ #F₁ ^ (m - 1) * #F₂ ^ (n - 1) := by gcongr <;> exact mod_cast Finset.card_pow_le\n      _ ≤ K ^ (m - 1) * L ^ (n - 1) := by gcongr\n  · calc\n      A ^ m ∩ B ^ n ⊆ (F₁ ^ (m - 1) * A) ∩ (F₂ ^ (n - 1) * B) := by\n        gcongr <;> apply pow_subset_pow_mul_of_sq_subset_mul <;> norm_cast <;> omega\n      _ = ⋃ (a ∈ F₁ ^ (m - 1)) (b ∈ F₂ ^ (n - 1)), a • A ∩ b • B := by\n        simp_rw [← smul_eq_mul, ← iUnion_smul_set, iUnion₂_inter_iUnion₂]; norm_cast\n      _ ⊆ ⋃ (a ∈ F₁ ^ (m - 1)) (b ∈ F₂ ^ (n - 1)), f a b • (A⁻¹ * A ∩ (B⁻¹ * B)) := by\n        gcongr; exact hf ..\n      _ = (Finset.image₂ f (F₁ ^ (m - 1)) (F₂ ^ (n - 1))) * (A ^ 2 ∩ B ^ 2) := by\n        simp_rw [hA.inv_eq_self, hB.inv_eq_self, ← sq]\n        rw [Finset.coe_image₂, ← smul_eq_mul, ← iUnion_smul_set, biUnion_image2]\n        simp_rw [Finset.mem_coe]\n\n"}
{"name":"IsApproximateSubgroup.pow_inter_pow_covBySMul_sq_inter_sq","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Set G\nK L : Real\nm n : Nat\nhA : IsApproximateSubgroup K A\nhB : IsApproximateSubgroup L B\nhm : LE.le 2 m\nhn : LE.le 2 n\n⊢ CovBySMul G (HMul.hMul (HPow.hPow K (HSub.hSub m 1)) (HPow.hPow L (HSub.hSub n 1))) (Inter.inter (HPow.hPow A m) (HPow.hPow B n)) (Inter.inter (HPow.hPow A 2) (HPow.hPow B 2))","decl":"open Set in\n@[to_additive]\nlemma pow_inter_pow_covBySMul_sq_inter_sq\n    (hA : IsApproximateSubgroup K A) (hB : IsApproximateSubgroup L B) (hm : 2 ≤ m) (hn : 2 ≤ n) :\n    CovBySMul G (K ^ (m - 1) * L ^ (n - 1)) (A ^ m ∩ B ^ n) (A ^ 2 ∩ B ^ 2) := by\n  classical\n  obtain ⟨F₁, hF₁, hAF₁⟩ := hA.sq_covBySMul\n  obtain ⟨F₂, hF₂, hBF₂⟩ := hB.sq_covBySMul\n  have := hA.one_le\n  choose f hf using exists_smul_inter_smul_subset_smul_inv_mul_inter_inv_mul A B\n  refine ⟨.image₂ f (F₁ ^ (m - 1)) (F₂ ^ (n - 1)), ?_, ?_⟩\n  · calc\n      (#(.image₂ f (F₁ ^ (m - 1)) (F₂ ^ (n - 1))) : ℝ)\n      _ ≤ #(F₁ ^ (m - 1)) * #(F₂ ^ (n - 1)) := mod_cast Finset.card_image₂_le ..\n      _ ≤ #F₁ ^ (m - 1) * #F₂ ^ (n - 1) := by gcongr <;> exact mod_cast Finset.card_pow_le\n      _ ≤ K ^ (m - 1) * L ^ (n - 1) := by gcongr\n  · calc\n      A ^ m ∩ B ^ n ⊆ (F₁ ^ (m - 1) * A) ∩ (F₂ ^ (n - 1) * B) := by\n        gcongr <;> apply pow_subset_pow_mul_of_sq_subset_mul <;> norm_cast <;> omega\n      _ = ⋃ (a ∈ F₁ ^ (m - 1)) (b ∈ F₂ ^ (n - 1)), a • A ∩ b • B := by\n        simp_rw [← smul_eq_mul, ← iUnion_smul_set, iUnion₂_inter_iUnion₂]; norm_cast\n      _ ⊆ ⋃ (a ∈ F₁ ^ (m - 1)) (b ∈ F₂ ^ (n - 1)), f a b • (A⁻¹ * A ∩ (B⁻¹ * B)) := by\n        gcongr; exact hf ..\n      _ = (Finset.image₂ f (F₁ ^ (m - 1)) (F₂ ^ (n - 1))) * (A ^ 2 ∩ B ^ 2) := by\n        simp_rw [hA.inv_eq_self, hB.inv_eq_self, ← sq]\n        rw [Finset.coe_image₂, ← smul_eq_mul, ← iUnion_smul_set, biUnion_image2]\n        simp_rw [Finset.mem_coe]\n\n"}
{"name":"IsApproximateAddSubgroup.nsmul_inter_nsmul","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nA B : Set G\nK L : Real\nm n : Nat\nhA : IsApproximateAddSubgroup K A\nhB : IsApproximateAddSubgroup L B\nhm : LE.le 2 m\nhn : LE.le 2 n\n⊢ IsApproximateAddSubgroup (HMul.hMul (HPow.hPow K (HSub.hSub (HMul.hMul 2 m) 1)) (HPow.hPow L (HSub.hSub (HMul.hMul 2 n) 1))) (Inter.inter (HSMul.hSMul m A) (HSMul.hSMul n B))","decl":"open Set in\n@[to_additive]\nlemma pow_inter_pow (hA : IsApproximateSubgroup K A) (hB : IsApproximateSubgroup L B) (hm : 2 ≤ m)\n    (hn : 2 ≤ n) :\n    IsApproximateSubgroup (K ^ (2 * m - 1) * L ^ (2 * n - 1)) (A ^ m ∩ B ^ n) where\n  one_mem := ⟨Set.one_mem_pow hA.one_mem, Set.one_mem_pow hB.one_mem⟩\n  inv_eq_self := by simp_rw [inter_inv, ← inv_pow, hA.inv_eq_self, hB.inv_eq_self]\n  sq_covBySMul := by\n    refine (hA.pow_inter_pow_covBySMul_sq_inter_sq hB (by omega) (by omega)).subset ?_\n      (by gcongr; exacts [hA.one_mem, hB.one_mem])\n    calc\n      (A ^ m ∩ B ^ n) ^ 2 ⊆ (A ^ m) ^ 2 ∩ (B ^ n) ^ 2 := Set.inter_pow_subset\n      _ = A ^ (2 * m) ∩ B ^ (2 * n) := by simp [pow_mul']\n\n"}
{"name":"IsApproximateSubgroup.pow_inter_pow","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝ : Group G\nA B : Set G\nK L : Real\nm n : Nat\nhA : IsApproximateSubgroup K A\nhB : IsApproximateSubgroup L B\nhm : LE.le 2 m\nhn : LE.le 2 n\n⊢ IsApproximateSubgroup (HMul.hMul (HPow.hPow K (HSub.hSub (HMul.hMul 2 m) 1)) (HPow.hPow L (HSub.hSub (HMul.hMul 2 n) 1))) (Inter.inter (HPow.hPow A m) (HPow.hPow B n))","decl":"open Set in\n@[to_additive]\nlemma pow_inter_pow (hA : IsApproximateSubgroup K A) (hB : IsApproximateSubgroup L B) (hm : 2 ≤ m)\n    (hn : 2 ≤ n) :\n    IsApproximateSubgroup (K ^ (2 * m - 1) * L ^ (2 * n - 1)) (A ^ m ∩ B ^ n) where\n  one_mem := ⟨Set.one_mem_pow hA.one_mem, Set.one_mem_pow hB.one_mem⟩\n  inv_eq_self := by simp_rw [inter_inv, ← inv_pow, hA.inv_eq_self, hB.inv_eq_self]\n  sq_covBySMul := by\n    refine (hA.pow_inter_pow_covBySMul_sq_inter_sq hB (by omega) (by omega)).subset ?_\n      (by gcongr; exacts [hA.one_mem, hB.one_mem])\n    calc\n      (A ^ m ∩ B ^ n) ^ 2 ⊆ (A ^ m) ^ 2 ∩ (B ^ n) ^ 2 := Set.inter_pow_subset\n      _ = A ^ (2 * m) ∩ B ^ (2 * n) := by simp [pow_mul']\n\n"}
{"name":"isApproximateAddSubgroup_zero","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nA : Set G\n⊢ Iff (IsApproximateAddSubgroup 1 A) (Exists fun H => Eq (↑H) A)","decl":"open Set in\n/-- A `1`-approximate subgroup is the same thing as a subgroup. -/\n@[to_additive (attr := simp)\n\"A `1`-approximate subgroup is the same thing as a subgroup.\"]\nlemma isApproximateSubgroup_one {A : Set G} :\n    IsApproximateSubgroup 1 (A : Set G) ↔ ∃ H : Subgroup G, H = A where\n  mp hA := by\n    suffices A * A ⊆ A from\n      let H : Subgroup G :=\n        { carrier := A\n          one_mem' := hA.one_mem\n          inv_mem' hx := by dsimp; rwa [← hA.inv_eq_self, inv_mem_inv]\n          mul_mem' hx hy := this (mul_mem_mul hx hy) }\n      ⟨H, rfl⟩\n    obtain ⟨x, hx⟩ : ∃ x : G, A * A ⊆ x • A := by\n      obtain ⟨K, hK, hKA⟩ := hA.sq_covBySMul\n      simp only [Nat.cast_le_one, Finset.card_le_one_iff_subset_singleton,\n        Finset.subset_singleton_iff] at hK\n      obtain ⟨x, rfl | rfl⟩ := hK\n      · simp [hA.nonempty.ne_empty] at hKA\n      · rw [Finset.coe_singleton, singleton_smul, sq] at hKA\n        use x\n    have hx' : x ⁻¹ • (A * A) ⊆ A := by rwa [← subset_smul_set_iff]\n    have hx_inv : x⁻¹ ∈ A := by\n      simpa using hx' (smul_mem_smul_set (mul_mem_mul hA.one_mem hA.one_mem))\n    have hx_sq : x * x ∈ A := by\n      rw [← hA.inv_eq_self]\n      simpa using hx' (smul_mem_smul_set (mul_mem_mul hx_inv hA.one_mem))\n    calc A * A ⊆ x • A := by assumption\n      _ = x⁻¹ • (x * x) • A := by simp [sq, smul_smul]\n      _ ⊆ x⁻¹ • (A • A) := smul_set_mono (smul_set_subset_smul hx_sq)\n      _ ⊆ A := hx'\n  mpr := by rintro ⟨H, rfl⟩; exact .subgroup\n"}
{"name":"isApproximateSubgroup_one","module":"Mathlib.Combinatorics.Additive.ApproximateSubgroup","initialProofState":"G : Type u_1\ninst✝ : Group G\nA : Set G\n⊢ Iff (IsApproximateSubgroup 1 A) (Exists fun H => Eq (↑H) A)","decl":"open Set in\n/-- A `1`-approximate subgroup is the same thing as a subgroup. -/\n@[to_additive (attr := simp)\n\"A `1`-approximate subgroup is the same thing as a subgroup.\"]\nlemma isApproximateSubgroup_one {A : Set G} :\n    IsApproximateSubgroup 1 (A : Set G) ↔ ∃ H : Subgroup G, H = A where\n  mp hA := by\n    suffices A * A ⊆ A from\n      let H : Subgroup G :=\n        { carrier := A\n          one_mem' := hA.one_mem\n          inv_mem' hx := by dsimp; rwa [← hA.inv_eq_self, inv_mem_inv]\n          mul_mem' hx hy := this (mul_mem_mul hx hy) }\n      ⟨H, rfl⟩\n    obtain ⟨x, hx⟩ : ∃ x : G, A * A ⊆ x • A := by\n      obtain ⟨K, hK, hKA⟩ := hA.sq_covBySMul\n      simp only [Nat.cast_le_one, Finset.card_le_one_iff_subset_singleton,\n        Finset.subset_singleton_iff] at hK\n      obtain ⟨x, rfl | rfl⟩ := hK\n      · simp [hA.nonempty.ne_empty] at hKA\n      · rw [Finset.coe_singleton, singleton_smul, sq] at hKA\n        use x\n    have hx' : x ⁻¹ • (A * A) ⊆ A := by rwa [← subset_smul_set_iff]\n    have hx_inv : x⁻¹ ∈ A := by\n      simpa using hx' (smul_mem_smul_set (mul_mem_mul hA.one_mem hA.one_mem))\n    have hx_sq : x * x ∈ A := by\n      rw [← hA.inv_eq_self]\n      simpa using hx' (smul_mem_smul_set (mul_mem_mul hx_inv hA.one_mem))\n    calc A * A ⊆ x • A := by assumption\n      _ = x⁻¹ • (x * x) • A := by simp [sq, smul_smul]\n      _ ⊆ x⁻¹ • (A • A) := smul_set_mono (smul_set_subset_smul hx_sq)\n      _ ⊆ A := hx'\n  mpr := by rintro ⟨H, rfl⟩; exact .subgroup\n"}
