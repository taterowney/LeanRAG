{"name":"TopCat.GlueData.mk.inj","module":"Mathlib.Topology.Gluing","initialProofState":"toGlueData✝ : CategoryTheory.GlueData TopCat\nf_open✝ : ∀ (i j : toGlueData✝.J), Topology.IsOpenEmbedding ⇑(toGlueData✝.f i j)\ntoGlueData : CategoryTheory.GlueData TopCat\nf_open : ∀ (i j : toGlueData.J), Topology.IsOpenEmbedding ⇑(toGlueData.f i j)\nx✝ : Eq { toGlueData := toGlueData✝, f_open := f_open✝ } { toGlueData := toGlueData, f_open := f_open }\n⊢ Eq toGlueData✝ toGlueData","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n  (Note that this is `J × J → TopCat` rather than `J → J → TopCat` to connect to the\n  limits library easier.)\n4. An open embedding `f i j : V i j ⟶ U i` for each `i j : ι`.\n5. A transition map `t i j : V i j ⟶ V j i` for each `i j : ι`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some\n    `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`.\n    (This merely means that `V i j ∩ V i k ⊆ t i j ⁻¹' (V j i ∩ V j k)`.)\n9. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subspaces of the glued space.\n\nMost of the times it would be easier to use the constructor `TopCat.GlueData.mk'` where the\nconditions are stated in a less categorical way.\n-/\nstructure GlueData extends CategoryTheory.GlueData TopCat where\n  f_open : ∀ i j, IsOpenEmbedding (f i j)\n  f_mono i j := (TopCat.mono_iff_injective _).mpr (f_open i j).isEmbedding.injective\n\n"}
{"name":"TopCat.GlueData.mk.injEq","module":"Mathlib.Topology.Gluing","initialProofState":"toGlueData✝ : CategoryTheory.GlueData TopCat\nf_open✝ : ∀ (i j : toGlueData✝.J), Topology.IsOpenEmbedding ⇑(toGlueData✝.f i j)\ntoGlueData : CategoryTheory.GlueData TopCat\nf_open : ∀ (i j : toGlueData.J), Topology.IsOpenEmbedding ⇑(toGlueData.f i j)\n⊢ Eq (Eq { toGlueData := toGlueData✝, f_open := f_open✝ } { toGlueData := toGlueData, f_open := f_open }) (Eq toGlueData✝ toGlueData)","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n  (Note that this is `J × J → TopCat` rather than `J → J → TopCat` to connect to the\n  limits library easier.)\n4. An open embedding `f i j : V i j ⟶ U i` for each `i j : ι`.\n5. A transition map `t i j : V i j ⟶ V j i` for each `i j : ι`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some\n    `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`.\n    (This merely means that `V i j ∩ V i k ⊆ t i j ⁻¹' (V j i ∩ V j k)`.)\n9. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subspaces of the glued space.\n\nMost of the times it would be easier to use the constructor `TopCat.GlueData.mk'` where the\nconditions are stated in a less categorical way.\n-/\nstructure GlueData extends CategoryTheory.GlueData TopCat where\n  f_open : ∀ i j, IsOpenEmbedding (f i j)\n  f_mono i j := (TopCat.mono_iff_injective _).mpr (f_open i j).isEmbedding.injective\n\n"}
{"name":"TopCat.GlueData.f_open","module":"Mathlib.Topology.Gluing","initialProofState":"self : TopCat.GlueData\ni j : self.J\n⊢ Topology.IsOpenEmbedding ⇑(self.f i j)","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n  (Note that this is `J × J → TopCat` rather than `J → J → TopCat` to connect to the\n  limits library easier.)\n4. An open embedding `f i j : V i j ⟶ U i` for each `i j : ι`.\n5. A transition map `t i j : V i j ⟶ V j i` for each `i j : ι`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some\n    `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`.\n    (This merely means that `V i j ∩ V i k ⊆ t i j ⁻¹' (V j i ∩ V j k)`.)\n9. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subspaces of the glued space.\n\nMost of the times it would be easier to use the constructor `TopCat.GlueData.mk'` where the\nconditions are stated in a less categorical way.\n-/\nstructure GlueData extends CategoryTheory.GlueData TopCat where\n  f_open : ∀ i j, IsOpenEmbedding (f i j)\n  f_mono i j := (TopCat.mono_iff_injective _).mpr (f_open i j).isEmbedding.injective\n\n"}
{"name":"TopCat.GlueData.mk.sizeOf_spec","module":"Mathlib.Topology.Gluing","initialProofState":"toGlueData : CategoryTheory.GlueData TopCat\nf_open : ∀ (i j : toGlueData.J), Topology.IsOpenEmbedding ⇑(toGlueData.f i j)\n⊢ Eq (SizeOf.sizeOf { toGlueData := toGlueData, f_open := f_open }) (HAdd.hAdd 1 (SizeOf.sizeOf toGlueData))","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n  (Note that this is `J × J → TopCat` rather than `J → J → TopCat` to connect to the\n  limits library easier.)\n4. An open embedding `f i j : V i j ⟶ U i` for each `i j : ι`.\n5. A transition map `t i j : V i j ⟶ V j i` for each `i j : ι`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j ×[U i] V i k ⟶ V i j ⟶ V j i` factors through `V j k ×[U j] V j i ⟶ V j i` via some\n    `t' : V i j ×[U i] V i k ⟶ V j k ×[U j] V j i`.\n    (This merely means that `V i j ∩ V i k ⊆ t i j ⁻¹' (V j i ∩ V j k)`.)\n9. `t' i j k ≫ t' j k i ≫ t' k i j = 𝟙 _`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subspaces of the glued space.\n\nMost of the times it would be easier to use the constructor `TopCat.GlueData.mk'` where the\nconditions are stated in a less categorical way.\n-/\nstructure GlueData extends CategoryTheory.GlueData TopCat where\n  f_open : ∀ i j, IsOpenEmbedding (f i j)\n  f_mono i j := (TopCat.mono_iff_injective _).mpr (f_open i j).isEmbedding.injective\n\n"}
{"name":"TopCat.GlueData.π_surjective","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\n⊢ Function.Surjective ⇑D.π","decl":"theorem π_surjective : Function.Surjective 𝖣.π :=\n  (TopCat.epi_iff_surjective 𝖣.π).mp inferInstance\n\n"}
{"name":"TopCat.GlueData.isOpen_iff","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\nU : Set ↑D.glued\n⊢ Iff (IsOpen U) (∀ (i : D.J), IsOpen (Set.preimage (⇑(D.ι i)) U))","decl":"theorem isOpen_iff (U : Set 𝖣.glued) : IsOpen U ↔ ∀ i, IsOpen (𝖣.ι i ⁻¹' U) := by\n  delta CategoryTheory.GlueData.ι\n  simp_rw [← Multicoequalizer.ι_sigmaπ 𝖣.diagram]\n  rw [← (homeoOfIso (Multicoequalizer.isoCoequalizer 𝖣.diagram).symm).isOpen_preimage]\n  rw [coequalizer_isOpen_iff, colimit_isOpen_iff.{u}]\n  tauto\n\n"}
{"name":"TopCat.GlueData.ι_jointly_surjective","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\nx : ↑D.glued\n⊢ Exists fun i => Exists fun y => Eq ((D.ι i) y) x","decl":"theorem ι_jointly_surjective (x : 𝖣.glued) : ∃ (i : _) (y : D.U i), 𝖣.ι i y = x :=\n  𝖣.ι_jointly_surjective (forget TopCat) x\n\n"}
{"name":"TopCat.GlueData.rel_equiv","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\n⊢ Equivalence D.Rel","decl":"theorem rel_equiv : Equivalence D.Rel :=\n  ⟨fun x => ⟨inv (D.f _ _) x.2, IsIso.inv_hom_id_apply _ _,\n    by simp [IsIso.inv_hom_id_apply _ _]⟩, by\n    rintro a b ⟨x, e₁, e₂⟩\n    exact ⟨D.t _ _ x, e₂, by rw [← e₁, D.t_inv_apply]⟩, by\n    rintro ⟨i, a⟩ ⟨j, b⟩ ⟨k, c⟩ ⟨x, e₁, e₂⟩\n    rintro ⟨y, e₃, e₄⟩\n    let z := (pullbackIsoProdSubtype (D.f j i) (D.f j k)).inv ⟨⟨_, _⟩, e₂.trans e₃.symm⟩\n    have eq₁ : (D.t j i) ((pullback.fst _ _ : _ /-(D.f j k)-/ ⟶ D.V (j, i)) z) = x := by\n      dsimp only [coe_of, z]\n      erw [pullbackIsoProdSubtype_inv_fst_apply, D.t_inv_apply]-- now `erw` after https://github.com/leanprover-community/mathlib4/pull/13170\n    have eq₂ : (pullback.snd _ _ : _ ⟶ D.V _) z = y := pullbackIsoProdSubtype_inv_snd_apply _ _ _\n    clear_value z\n    use (pullback.fst _ _ : _ ⟶ D.V (i, k)) (D.t' _ _ _ z)\n    dsimp only at *\n    substs eq₁ eq₂ e₁ e₃ e₄\n    have h₁ : D.t' j i k ≫ pullback.fst _ _ ≫ D.f i k = pullback.fst _ _ ≫ D.t j i ≫ D.f i j := by\n      rw [← 𝖣.t_fac_assoc]; congr 1; exact pullback.condition\n    have h₂ : D.t' j i k ≫ pullback.fst _ _ ≫ D.t i k ≫ D.f k i =\n        pullback.snd _ _ ≫ D.t j k ≫ D.f k j := by\n      rw [← 𝖣.t_fac_assoc]\n      apply @Epi.left_cancellation _ _ _ _ (D.t' k j i)\n      rw [𝖣.cocycle_assoc, 𝖣.t_fac_assoc, 𝖣.t_inv_assoc]\n      exact pullback.condition.symm\n    exact ⟨ContinuousMap.congr_fun h₁ z, ContinuousMap.congr_fun h₂ z⟩⟩\n\n"}
{"name":"TopCat.GlueData.eqvGen_of_π_eq","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\nx y : ↑(CategoryTheory.Limits.sigmaObj D.U)\nh : Eq (D.π x) (D.π y)\n⊢ Relation.EqvGen (CategoryTheory.Limits.Types.CoequalizerRel ⇑D.diagram.fstSigmaMap ⇑D.diagram.sndSigmaMap) x y","decl":"theorem eqvGen_of_π_eq\n    -- Porting note: was `{x y : ∐ D.U} (h : 𝖣.π x = 𝖣.π y)`\n    {x y : sigmaObj (β := D.toGlueData.J) (C := TopCat) D.toGlueData.U}\n    (h : 𝖣.π x = 𝖣.π y) :\n    Relation.EqvGen\n      -- Porting note: was (Types.CoequalizerRel 𝖣.diagram.fstSigmaMap 𝖣.diagram.sndSigmaMap)\n      (Types.CoequalizerRel\n        (X := sigmaObj (β := D.toGlueData.diagram.L) (C := TopCat) (D.toGlueData.diagram).left)\n        (Y := sigmaObj (β := D.toGlueData.diagram.R) (C := TopCat) (D.toGlueData.diagram).right)\n        𝖣.diagram.fstSigmaMap 𝖣.diagram.sndSigmaMap)\n      x y := by\n  delta GlueData.π Multicoequalizer.sigmaπ at h\n  -- Porting note: inlined `inferInstance` instead of leaving as a side goal.\n  replace h := (TopCat.mono_iff_injective (Multicoequalizer.isoCoequalizer 𝖣.diagram).inv).mp\n    inferInstance h\n  let diagram := parallelPair 𝖣.diagram.fstSigmaMap 𝖣.diagram.sndSigmaMap ⋙ forget _\n  have : colimit.ι diagram one x = colimit.ι diagram one y := by\n    dsimp only [coequalizer.π, ContinuousMap.toFun_eq_coe] at h\n    rw [← ι_preservesColimitIso_hom, forget_map_eq_coe, types_comp_apply, h]\n    simp\n  have :\n    (colimit.ι diagram _ ≫ colim.map _ ≫ (colimit.isoColimitCocone _).hom) _ =\n      (colimit.ι diagram _ ≫ colim.map _ ≫ (colimit.isoColimitCocone _).hom) _ :=\n    (congr_arg\n        (colim.map (diagramIsoParallelPair diagram).hom ≫\n          (colimit.isoColimitCocone (Types.coequalizerColimit _ _)).hom)\n        this :\n      _)\n  -- Porting note: was\n  -- simp only [eqToHom_refl, types_comp_apply, colimit.ι_map_assoc,\n  --   diagramIsoParallelPair_hom_app, colimit.isoColimitCocone_ι_hom, types_id_apply] at this\n  -- See https://github.com/leanprover-community/mathlib4/issues/5026\n  rw [colimit.ι_map_assoc, diagramIsoParallelPair_hom_app, eqToHom_refl,\n    colimit.isoColimitCocone_ι_hom, types_comp_apply, types_id_apply, types_comp_apply,\n    types_id_apply] at this\n  exact Quot.eq.1 this\n\n"}
{"name":"TopCat.GlueData.ι_eq_iff_rel","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\ni j : D.J\nx : ↑(D.U i)\ny : ↑(D.U j)\n⊢ Iff (Eq ((D.ι i) x) ((D.ι j) y)) (D.Rel ⟨i, x⟩ ⟨j, y⟩)","decl":"theorem ι_eq_iff_rel (i j : D.J) (x : D.U i) (y : D.U j) :\n    𝖣.ι i x = 𝖣.ι j y ↔ D.Rel ⟨i, x⟩ ⟨j, y⟩ := by\n  constructor\n  · delta GlueData.ι\n    simp_rw [← Multicoequalizer.ι_sigmaπ]\n    intro h\n    rw [←\n      show _ = Sigma.mk i x from ConcreteCategory.congr_hom (sigmaIsoSigma.{_, u} D.U).inv_hom_id _]\n    rw [←\n      show _ = Sigma.mk j y from ConcreteCategory.congr_hom (sigmaIsoSigma.{_, u} D.U).inv_hom_id _]\n    change InvImage D.Rel (sigmaIsoSigma.{_, u} D.U).hom _ _\n    rw [← (InvImage.equivalence _ _ D.rel_equiv).eqvGen_iff]\n    refine Relation.EqvGen.mono ?_ (D.eqvGen_of_π_eq h :)\n    rintro _ _ ⟨x⟩\n    obtain ⟨⟨⟨i, j⟩, y⟩, rfl⟩ :=\n      (ConcreteCategory.bijective_of_isIso (sigmaIsoSigma.{u, u} _).inv).2 x\n    unfold InvImage MultispanIndex.fstSigmaMap MultispanIndex.sndSigmaMap\n    simp only [forget_map_eq_coe]\n    erw [TopCat.comp_app, sigmaIsoSigma_inv_apply, ← CategoryTheory.comp_apply,\n      ← CategoryTheory.comp_apply, colimit.ι_desc_assoc, ← CategoryTheory.comp_apply,\n      ← CategoryTheory.comp_apply, colimit.ι_desc_assoc]\n      -- previous line now `erw` after https://github.com/leanprover-community/mathlib4/pull/13170\n    erw [sigmaIsoSigma_hom_ι_apply, sigmaIsoSigma_hom_ι_apply]\n    exact ⟨y, ⟨rfl, rfl⟩⟩\n  · rintro ⟨z, e₁, e₂⟩\n    dsimp only at *\n    -- Porting note: there were `subst e₁` and `subst e₂`, instead of the `rw`\n    rw [← e₁, ← e₂] at *\n    rw [D.glue_condition_apply]\n\n"}
{"name":"TopCat.GlueData.ι_injective","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\ni : D.J\n⊢ Function.Injective ⇑(D.ι i)","decl":"theorem ι_injective (i : D.J) : Function.Injective (𝖣.ι i) := by\n  intro x y h\n  rcases (D.ι_eq_iff_rel _ _ _ _).mp h with ⟨_, e₁, e₂⟩\n  · dsimp only at *\n    -- Porting note: there were `cases e₁` and `cases e₂`, instead of the `rw`\n    rw [← e₁, ← e₂]\n    simp\n\n"}
{"name":"TopCat.GlueData.ι_mono","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\ni : D.J\n⊢ CategoryTheory.Mono (D.ι i)","decl":"instance ι_mono (i : D.J) : Mono (𝖣.ι i) :=\n  (TopCat.mono_iff_injective _).mpr (D.ι_injective _)\n\n"}
{"name":"TopCat.GlueData.image_inter","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\ni j : D.J\n⊢ Eq (Inter.inter (Set.range ⇑(D.ι i)) (Set.range ⇑(D.ι j))) (Set.range ⇑(CategoryTheory.CategoryStruct.comp (D.f i j) (D.ι i)))","decl":"theorem image_inter (i j : D.J) :\n    Set.range (𝖣.ι i) ∩ Set.range (𝖣.ι j) = Set.range (D.f i j ≫ 𝖣.ι _) := by\n  ext x\n  constructor\n  · rintro ⟨⟨x₁, eq₁⟩, ⟨x₂, eq₂⟩⟩\n    obtain ⟨y, e₁, -⟩ := (D.ι_eq_iff_rel _ _ _ _).mp (eq₁.trans eq₂.symm)\n    · substs eq₁\n      exact ⟨y, by simp [e₁]⟩\n  · rintro ⟨x, hx⟩\n    refine ⟨⟨D.f i j x, hx⟩, ⟨D.f j i (D.t _ _ x), ?_⟩⟩\n    rw [D.glue_condition_apply]\n    exact hx\n\n"}
{"name":"TopCat.GlueData.preimage_range","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\ni j : D.J\n⊢ Eq (Set.preimage (⇑(D.ι j)) (Set.range ⇑(D.ι i))) (Set.range ⇑(D.f j i))","decl":"theorem preimage_range (i j : D.J) : 𝖣.ι j ⁻¹' Set.range (𝖣.ι i) = Set.range (D.f j i) := by\n  rw [← Set.preimage_image_eq (Set.range (D.f j i)) (D.ι_injective j), ← Set.image_univ, ←\n    Set.image_univ, ← Set.image_comp, ← coe_comp, Set.image_univ, Set.image_univ, ← image_inter,\n    Set.preimage_range_inter]\n\n"}
{"name":"TopCat.GlueData.preimage_image_eq_image","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\ni j : D.J\nU : Set ↑(D.U i)\n⊢ Eq (Set.preimage (⇑(D.ι j)) (Set.image (⇑(D.ι i)) U)) (Set.image (⇑(D.f j i)) (Set.preimage (⇑(CategoryTheory.CategoryStruct.comp (D.t j i) (D.f i j))) U))","decl":"theorem preimage_image_eq_image (i j : D.J) (U : Set (𝖣.U i)) :\n    𝖣.ι j ⁻¹' (𝖣.ι i '' U) = D.f _ _ '' ((D.t j i ≫ D.f _ _) ⁻¹' U) := by\n  have : D.f _ _ ⁻¹' (𝖣.ι j ⁻¹' (𝖣.ι i '' U)) = (D.t j i ≫ D.f _ _) ⁻¹' U := by\n    ext x\n    conv_rhs => rw [← Set.preimage_image_eq U (D.ι_injective _)]\n    generalize 𝖣.ι i '' U = U' -- next 4 lines were `simp` before https://github.com/leanprover-community/mathlib4/pull/13170\n    simp only [GlueData.diagram_l, GlueData.diagram_r, Set.mem_preimage, coe_comp,\n      Function.comp_apply]\n    rw [D.glue_condition_apply]\n  rw [← this, Set.image_preimage_eq_inter_range]\n  symm\n  apply Set.inter_eq_self_of_subset_left\n  rw [← D.preimage_range i j]\n  exact Set.preimage_mono (Set.image_subset_range _ _)\n\n"}
{"name":"TopCat.GlueData.preimage_image_eq_image'","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\ni j : D.J\nU : Set ↑(D.U i)\n⊢ Eq (Set.preimage (⇑(D.ι j)) (Set.image (⇑(D.ι i)) U)) (Set.image (⇑(CategoryTheory.CategoryStruct.comp (D.t i j) (D.f j i))) (Set.preimage (⇑(D.f i j)) U))","decl":"theorem preimage_image_eq_image' (i j : D.J) (U : Set (𝖣.U i)) :\n    𝖣.ι j ⁻¹' (𝖣.ι i '' U) = (D.t i j ≫ D.f _ _) '' (D.f _ _ ⁻¹' U) := by\n  convert D.preimage_image_eq_image i j U using 1\n  rw [coe_comp, coe_comp]\n  -- Porting note: `show` was not needed, since `rw [← Set.image_image]` worked.\n  show (fun x => ((forget TopCat).map _ ((forget TopCat).map _ x))) '' _ = _\n  rw [← Set.image_image]\n  congr! 1\n  rw [← Set.eq_preimage_iff_image_eq, Set.preimage_preimage]\n  · change _ = (D.t i j ≫ D.t j i ≫ _) ⁻¹' _\n    rw [𝖣.t_inv_assoc]\n  rw [← isIso_iff_bijective]\n  apply (forget TopCat).map_isIso\n\n"}
{"name":"TopCat.GlueData.open_image_open","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\ni : D.J\nU : TopologicalSpace.Opens ↑(D.U i)\n⊢ IsOpen (Set.image ⇑(D.ι i) ↑U)","decl":"theorem open_image_open (i : D.J) (U : Opens (𝖣.U i)) : IsOpen (𝖣.ι i '' U) := by\n  rw [isOpen_iff]\n  intro j\n  rw [preimage_image_eq_image]\n  apply (D.f_open _ _).isOpenMap\n  apply (D.t j i ≫ D.f i j).continuous_toFun.isOpen_preimage\n  exact U.isOpen\n\n"}
{"name":"TopCat.GlueData.ι_isOpenEmbedding","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\ni : D.J\n⊢ Topology.IsOpenEmbedding ⇑(D.ι i)","decl":"theorem ι_isOpenEmbedding (i : D.J) : IsOpenEmbedding (𝖣.ι i) :=\n  .of_continuous_injective_isOpenMap (𝖣.ι i).continuous_toFun (D.ι_injective i) fun U h =>\n    D.open_image_open i ⟨U, h⟩\n\n"}
{"name":"TopCat.GlueData.ι_openEmbedding","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\ni : D.J\n⊢ Topology.IsOpenEmbedding ⇑(D.ι i)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias ι_openEmbedding := ι_isOpenEmbedding\n\n"}
{"name":"TopCat.GlueData.MkCore.mk.sizeOf_spec","module":"Mathlib.Topology.Gluing","initialProofState":"J : Type u\nU : J → TopCat\nV : (i : J) → J → TopologicalSpace.Opens ↑(U i)\nt : (i j : J) → Quiver.Hom ((TopologicalSpace.Opens.toTopCat (U i)).obj (V i j)) ((TopologicalSpace.Opens.toTopCat (U j)).obj (V j i))\nV_id : ∀ (i : J), Eq (V i i) Top.top\nt_id : ∀ (i : J), Eq (⇑(t i i)) id\nt_inter : ∀ ⦃i j : J⦄ (k : J) (x : Subtype fun x => Membership.mem (V i j) x), Membership.mem (V i k) ↑x → Membership.mem (V j k) ↑((t i j) x)\ncocycle : ∀ (i j k : J) (x : Subtype fun x => Membership.mem (V i j) x) (h : Membership.mem (V i k) ↑x), Eq ↑((t j k) ⟨↑((t i j) x), ⋯⟩) ↑((t i k) ⟨↑x, h⟩)\n⊢ Eq (SizeOf.sizeOf (TopCat.GlueData.MkCore.mk U V t V_id t_id t_inter cocycle)) (HAdd.hAdd 1 (SizeOf.sizeOf J))","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A bundled topological space `U i` for each `i : J`.\n3. An open set `V i j ⊆ U i` for each `i j : J`.\n4. A transition map `t i j : V i j ⟶ V j i` for each `i j : ι`.\nsuch that\n6. `V i i = U i`.\n7. `t i i` is the identity.\n8. For each `x ∈ V i j ∩ V i k`, `t i j x ∈ V j k`.\n9. `t j k (t i j x) = t i k x`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`.\n-/\nstructure MkCore where\n  {J : Type u}\n  U : J → TopCat.{u}\n  V : ∀ i, J → Opens (U i)\n  t : ∀ i j, (Opens.toTopCat _).obj (V i j) ⟶ (Opens.toTopCat _).obj (V j i)\n  V_id : ∀ i, V i i = ⊤\n  t_id : ∀ i, ⇑(t i i) = id\n  t_inter : ∀ ⦃i j⦄ (k) (x : V i j), ↑x ∈ V i k → (((↑) : (V j i) → (U j)) (t i j x)) ∈ V j k\n  cocycle :\n    ∀ (i j k) (x : V i j) (h : ↑x ∈ V i k),\n      -- Porting note: the underscore in the next line was `↑(t i j x)`, but Lean type-mismatched\n      (((↑) : (V k j) → (U k)) (t j k ⟨_, t_inter k x h⟩)) = ((↑) : (V k i) → (U k)) (t i k ⟨x, h⟩)\n\n"}
{"name":"TopCat.GlueData.MkCore.cocycle","module":"Mathlib.Topology.Gluing","initialProofState":"self : TopCat.GlueData.MkCore\ni j k : self.J\nx : Subtype fun x => Membership.mem (self.V i j) x\nh : Membership.mem (self.V i k) ↑x\n⊢ Eq ↑((self.t j k) ⟨↑((self.t i j) x), ⋯⟩) ↑((self.t i k) ⟨↑x, h⟩)","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A bundled topological space `U i` for each `i : J`.\n3. An open set `V i j ⊆ U i` for each `i j : J`.\n4. A transition map `t i j : V i j ⟶ V j i` for each `i j : ι`.\nsuch that\n6. `V i i = U i`.\n7. `t i i` is the identity.\n8. For each `x ∈ V i j ∩ V i k`, `t i j x ∈ V j k`.\n9. `t j k (t i j x) = t i k x`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`.\n-/\nstructure MkCore where\n  {J : Type u}\n  U : J → TopCat.{u}\n  V : ∀ i, J → Opens (U i)\n  t : ∀ i j, (Opens.toTopCat _).obj (V i j) ⟶ (Opens.toTopCat _).obj (V j i)\n  V_id : ∀ i, V i i = ⊤\n  t_id : ∀ i, ⇑(t i i) = id\n  t_inter : ∀ ⦃i j⦄ (k) (x : V i j), ↑x ∈ V i k → (((↑) : (V j i) → (U j)) (t i j x)) ∈ V j k\n  cocycle :\n    ∀ (i j k) (x : V i j) (h : ↑x ∈ V i k),\n      -- Porting note: the underscore in the next line was `↑(t i j x)`, but Lean type-mismatched\n      (((↑) : (V k j) → (U k)) (t j k ⟨_, t_inter k x h⟩)) = ((↑) : (V k i) → (U k)) (t i k ⟨x, h⟩)\n\n"}
{"name":"TopCat.GlueData.MkCore.mk.inj","module":"Mathlib.Topology.Gluing","initialProofState":"J✝ : Type u\nU✝ : J✝ → TopCat\nV✝ : (i : J✝) → J✝ → TopologicalSpace.Opens ↑(U✝ i)\nt✝ : (i j : J✝) → Quiver.Hom ((TopologicalSpace.Opens.toTopCat (U✝ i)).obj (V✝ i j)) ((TopologicalSpace.Opens.toTopCat (U✝ j)).obj (V✝ j i))\nV_id✝ : ∀ (i : J✝), Eq (V✝ i i) Top.top\nt_id✝ : ∀ (i : J✝), Eq (⇑(t✝ i i)) id\nt_inter✝ : ∀ ⦃i j : J✝⦄ (k : J✝) (x : Subtype fun x => Membership.mem (V✝ i j) x), Membership.mem (V✝ i k) ↑x → Membership.mem (V✝ j k) ↑((t✝ i j) x)\ncocycle✝ : ∀ (i j k : J✝) (x : Subtype fun x => Membership.mem (V✝ i j) x) (h : Membership.mem (V✝ i k) ↑x), Eq ↑((t✝ j k) ⟨↑((t✝ i j) x), ⋯⟩) ↑((t✝ i k) ⟨↑x, h⟩)\nJ : Type u\nU : J → TopCat\nV : (i : J) → J → TopologicalSpace.Opens ↑(U i)\nt : (i j : J) → Quiver.Hom ((TopologicalSpace.Opens.toTopCat (U i)).obj (V i j)) ((TopologicalSpace.Opens.toTopCat (U j)).obj (V j i))\nV_id : ∀ (i : J), Eq (V i i) Top.top\nt_id : ∀ (i : J), Eq (⇑(t i i)) id\nt_inter : ∀ ⦃i j : J⦄ (k : J) (x : Subtype fun x => Membership.mem (V i j) x), Membership.mem (V i k) ↑x → Membership.mem (V j k) ↑((t i j) x)\ncocycle : ∀ (i j k : J) (x : Subtype fun x => Membership.mem (V i j) x) (h : Membership.mem (V i k) ↑x), Eq ↑((t j k) ⟨↑((t i j) x), ⋯⟩) ↑((t i k) ⟨↑x, h⟩)\nx✝ : Eq (TopCat.GlueData.MkCore.mk U✝ V✝ t✝ V_id✝ t_id✝ t_inter✝ cocycle✝) (TopCat.GlueData.MkCore.mk U V t V_id t_id t_inter cocycle)\n⊢ And (Eq J✝ J) (And (HEq U✝ U) (And (HEq V✝ V) (HEq t✝ t)))","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A bundled topological space `U i` for each `i : J`.\n3. An open set `V i j ⊆ U i` for each `i j : J`.\n4. A transition map `t i j : V i j ⟶ V j i` for each `i j : ι`.\nsuch that\n6. `V i i = U i`.\n7. `t i i` is the identity.\n8. For each `x ∈ V i j ∩ V i k`, `t i j x ∈ V j k`.\n9. `t j k (t i j x) = t i k x`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`.\n-/\nstructure MkCore where\n  {J : Type u}\n  U : J → TopCat.{u}\n  V : ∀ i, J → Opens (U i)\n  t : ∀ i j, (Opens.toTopCat _).obj (V i j) ⟶ (Opens.toTopCat _).obj (V j i)\n  V_id : ∀ i, V i i = ⊤\n  t_id : ∀ i, ⇑(t i i) = id\n  t_inter : ∀ ⦃i j⦄ (k) (x : V i j), ↑x ∈ V i k → (((↑) : (V j i) → (U j)) (t i j x)) ∈ V j k\n  cocycle :\n    ∀ (i j k) (x : V i j) (h : ↑x ∈ V i k),\n      -- Porting note: the underscore in the next line was `↑(t i j x)`, but Lean type-mismatched\n      (((↑) : (V k j) → (U k)) (t j k ⟨_, t_inter k x h⟩)) = ((↑) : (V k i) → (U k)) (t i k ⟨x, h⟩)\n\n"}
{"name":"TopCat.GlueData.MkCore.V_id","module":"Mathlib.Topology.Gluing","initialProofState":"self : TopCat.GlueData.MkCore\ni : self.J\n⊢ Eq (self.V i i) Top.top","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A bundled topological space `U i` for each `i : J`.\n3. An open set `V i j ⊆ U i` for each `i j : J`.\n4. A transition map `t i j : V i j ⟶ V j i` for each `i j : ι`.\nsuch that\n6. `V i i = U i`.\n7. `t i i` is the identity.\n8. For each `x ∈ V i j ∩ V i k`, `t i j x ∈ V j k`.\n9. `t j k (t i j x) = t i k x`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`.\n-/\nstructure MkCore where\n  {J : Type u}\n  U : J → TopCat.{u}\n  V : ∀ i, J → Opens (U i)\n  t : ∀ i j, (Opens.toTopCat _).obj (V i j) ⟶ (Opens.toTopCat _).obj (V j i)\n  V_id : ∀ i, V i i = ⊤\n  t_id : ∀ i, ⇑(t i i) = id\n  t_inter : ∀ ⦃i j⦄ (k) (x : V i j), ↑x ∈ V i k → (((↑) : (V j i) → (U j)) (t i j x)) ∈ V j k\n  cocycle :\n    ∀ (i j k) (x : V i j) (h : ↑x ∈ V i k),\n      -- Porting note: the underscore in the next line was `↑(t i j x)`, but Lean type-mismatched\n      (((↑) : (V k j) → (U k)) (t j k ⟨_, t_inter k x h⟩)) = ((↑) : (V k i) → (U k)) (t i k ⟨x, h⟩)\n\n"}
{"name":"TopCat.GlueData.MkCore.mk.injEq","module":"Mathlib.Topology.Gluing","initialProofState":"J✝ : Type u\nU✝ : J✝ → TopCat\nV✝ : (i : J✝) → J✝ → TopologicalSpace.Opens ↑(U✝ i)\nt✝ : (i j : J✝) → Quiver.Hom ((TopologicalSpace.Opens.toTopCat (U✝ i)).obj (V✝ i j)) ((TopologicalSpace.Opens.toTopCat (U✝ j)).obj (V✝ j i))\nV_id✝ : ∀ (i : J✝), Eq (V✝ i i) Top.top\nt_id✝ : ∀ (i : J✝), Eq (⇑(t✝ i i)) id\nt_inter✝ : ∀ ⦃i j : J✝⦄ (k : J✝) (x : Subtype fun x => Membership.mem (V✝ i j) x), Membership.mem (V✝ i k) ↑x → Membership.mem (V✝ j k) ↑((t✝ i j) x)\ncocycle✝ : ∀ (i j k : J✝) (x : Subtype fun x => Membership.mem (V✝ i j) x) (h : Membership.mem (V✝ i k) ↑x), Eq ↑((t✝ j k) ⟨↑((t✝ i j) x), ⋯⟩) ↑((t✝ i k) ⟨↑x, h⟩)\nJ : Type u\nU : J → TopCat\nV : (i : J) → J → TopologicalSpace.Opens ↑(U i)\nt : (i j : J) → Quiver.Hom ((TopologicalSpace.Opens.toTopCat (U i)).obj (V i j)) ((TopologicalSpace.Opens.toTopCat (U j)).obj (V j i))\nV_id : ∀ (i : J), Eq (V i i) Top.top\nt_id : ∀ (i : J), Eq (⇑(t i i)) id\nt_inter : ∀ ⦃i j : J⦄ (k : J) (x : Subtype fun x => Membership.mem (V i j) x), Membership.mem (V i k) ↑x → Membership.mem (V j k) ↑((t i j) x)\ncocycle : ∀ (i j k : J) (x : Subtype fun x => Membership.mem (V i j) x) (h : Membership.mem (V i k) ↑x), Eq ↑((t j k) ⟨↑((t i j) x), ⋯⟩) ↑((t i k) ⟨↑x, h⟩)\n⊢ Eq (Eq (TopCat.GlueData.MkCore.mk U✝ V✝ t✝ V_id✝ t_id✝ t_inter✝ cocycle✝) (TopCat.GlueData.MkCore.mk U V t V_id t_id t_inter cocycle)) (And (Eq J✝ J) (And (HEq U✝ U) (And (HEq V✝ V) (HEq t✝ t))))","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A bundled topological space `U i` for each `i : J`.\n3. An open set `V i j ⊆ U i` for each `i j : J`.\n4. A transition map `t i j : V i j ⟶ V j i` for each `i j : ι`.\nsuch that\n6. `V i i = U i`.\n7. `t i i` is the identity.\n8. For each `x ∈ V i j ∩ V i k`, `t i j x ∈ V j k`.\n9. `t j k (t i j x) = t i k x`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`.\n-/\nstructure MkCore where\n  {J : Type u}\n  U : J → TopCat.{u}\n  V : ∀ i, J → Opens (U i)\n  t : ∀ i j, (Opens.toTopCat _).obj (V i j) ⟶ (Opens.toTopCat _).obj (V j i)\n  V_id : ∀ i, V i i = ⊤\n  t_id : ∀ i, ⇑(t i i) = id\n  t_inter : ∀ ⦃i j⦄ (k) (x : V i j), ↑x ∈ V i k → (((↑) : (V j i) → (U j)) (t i j x)) ∈ V j k\n  cocycle :\n    ∀ (i j k) (x : V i j) (h : ↑x ∈ V i k),\n      -- Porting note: the underscore in the next line was `↑(t i j x)`, but Lean type-mismatched\n      (((↑) : (V k j) → (U k)) (t j k ⟨_, t_inter k x h⟩)) = ((↑) : (V k i) → (U k)) (t i k ⟨x, h⟩)\n\n"}
{"name":"TopCat.GlueData.MkCore.t_inter","module":"Mathlib.Topology.Gluing","initialProofState":"self : TopCat.GlueData.MkCore\ni j k : self.J\nx : Subtype fun x => Membership.mem (self.V i j) x\na✝ : Membership.mem (self.V i k) ↑x\n⊢ Membership.mem (self.V j k) ↑((self.t i j) x)","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A bundled topological space `U i` for each `i : J`.\n3. An open set `V i j ⊆ U i` for each `i j : J`.\n4. A transition map `t i j : V i j ⟶ V j i` for each `i j : ι`.\nsuch that\n6. `V i i = U i`.\n7. `t i i` is the identity.\n8. For each `x ∈ V i j ∩ V i k`, `t i j x ∈ V j k`.\n9. `t j k (t i j x) = t i k x`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`.\n-/\nstructure MkCore where\n  {J : Type u}\n  U : J → TopCat.{u}\n  V : ∀ i, J → Opens (U i)\n  t : ∀ i j, (Opens.toTopCat _).obj (V i j) ⟶ (Opens.toTopCat _).obj (V j i)\n  V_id : ∀ i, V i i = ⊤\n  t_id : ∀ i, ⇑(t i i) = id\n  t_inter : ∀ ⦃i j⦄ (k) (x : V i j), ↑x ∈ V i k → (((↑) : (V j i) → (U j)) (t i j x)) ∈ V j k\n  cocycle :\n    ∀ (i j k) (x : V i j) (h : ↑x ∈ V i k),\n      -- Porting note: the underscore in the next line was `↑(t i j x)`, but Lean type-mismatched\n      (((↑) : (V k j) → (U k)) (t j k ⟨_, t_inter k x h⟩)) = ((↑) : (V k i) → (U k)) (t i k ⟨x, h⟩)\n\n"}
{"name":"TopCat.GlueData.MkCore.t_id","module":"Mathlib.Topology.Gluing","initialProofState":"self : TopCat.GlueData.MkCore\ni : self.J\n⊢ Eq (⇑(self.t i i)) id","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A bundled topological space `U i` for each `i : J`.\n3. An open set `V i j ⊆ U i` for each `i j : J`.\n4. A transition map `t i j : V i j ⟶ V j i` for each `i j : ι`.\nsuch that\n6. `V i i = U i`.\n7. `t i i` is the identity.\n8. For each `x ∈ V i j ∩ V i k`, `t i j x ∈ V j k`.\n9. `t j k (t i j x) = t i k x`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`.\n-/\nstructure MkCore where\n  {J : Type u}\n  U : J → TopCat.{u}\n  V : ∀ i, J → Opens (U i)\n  t : ∀ i j, (Opens.toTopCat _).obj (V i j) ⟶ (Opens.toTopCat _).obj (V j i)\n  V_id : ∀ i, V i i = ⊤\n  t_id : ∀ i, ⇑(t i i) = id\n  t_inter : ∀ ⦃i j⦄ (k) (x : V i j), ↑x ∈ V i k → (((↑) : (V j i) → (U j)) (t i j x)) ∈ V j k\n  cocycle :\n    ∀ (i j k) (x : V i j) (h : ↑x ∈ V i k),\n      -- Porting note: the underscore in the next line was `↑(t i j x)`, but Lean type-mismatched\n      (((↑) : (V k j) → (U k)) (t j k ⟨_, t_inter k x h⟩)) = ((↑) : (V k i) → (U k)) (t i k ⟨x, h⟩)\n\n"}
{"name":"TopCat.GlueData.MkCore.t_inv","module":"Mathlib.Topology.Gluing","initialProofState":"h : TopCat.GlueData.MkCore\ni j : h.J\nx : Subtype fun x => Membership.mem (h.V j i) x\n⊢ Eq ((h.t i j) ((h.t j i) x)) x","decl":"theorem MkCore.t_inv (h : MkCore) (i j : h.J) (x : h.V j i) : h.t i j ((h.t j i) x) = x := by\n  have := h.cocycle j i j x ?_\n  · rw [h.t_id] at this\n    · convert Subtype.eq this\n  rw [h.V_id]\n  trivial\n\n"}
{"name":"TopCat.GlueData.instIsIsoT","module":"Mathlib.Topology.Gluing","initialProofState":"h : TopCat.GlueData.MkCore\ni j : h.J\n⊢ CategoryTheory.IsIso (h.t i j)","decl":"instance (h : MkCore.{u}) (i j : h.J) : IsIso (h.t i j) := by\n  use h.t j i; constructor <;> ext1; exacts [h.t_inv _ _ _, h.t_inv _ _ _]\n\n"}
{"name":"TopCat.GlueData.ofOpenSubsets_toGlueData_t","module":"Mathlib.Topology.Gluing","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nJ : Type u\nU : J → TopologicalSpace.Opens α\ni j : (TopCat.GlueData.MkCore.mk (fun i => (TopologicalSpace.Opens.toTopCat (TopCat.of α)).obj (U i)) (fun x j => (TopologicalSpace.Opens.map (U x).inclusion').obj (U j)) (fun i j => { toFun := fun x => ⟨⟨↑↑x, ⋯⟩, ⋯⟩, continuous_toFun := ⋯ }) ⋯ ⋯ ⋯ ⋯).J\n⊢ Eq ((TopCat.GlueData.ofOpenSubsets U).t i j) { toFun := fun x => ⟨⟨↑↑x, ⋯⟩, ⋯⟩, continuous_toFun := ⋯ }","decl":"/-- We may construct a glue data from a family of open sets. -/\n@[simps! toGlueData_J toGlueData_U toGlueData_V toGlueData_t toGlueData_f]\ndef ofOpenSubsets : TopCat.GlueData.{u} :=\n  mk'.{u}\n    { J\n      U := fun i => (Opens.toTopCat <| TopCat.of α).obj (U i)\n      V := fun _ j => (Opens.map <| Opens.inclusion' _).obj (U j)\n      t := fun i j => ⟨fun x => ⟨⟨x.1.1, x.2⟩, x.1.2⟩, by fun_prop⟩\n      V_id := fun i => by ext; simp\n      t_id := fun i => by ext; rfl\n      t_inter := fun _ _ _ _ hx => hx\n      cocycle := fun _ _ _ _ _ => rfl }\n\n"}
{"name":"TopCat.GlueData.ofOpenSubsets_toGlueData_f","module":"Mathlib.Topology.Gluing","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nJ : Type u\nU : J → TopologicalSpace.Opens α\ni j : (TopCat.GlueData.MkCore.mk (fun i => (TopologicalSpace.Opens.toTopCat (TopCat.of α)).obj (U i)) (fun x j => (TopologicalSpace.Opens.map (U x).inclusion').obj (U j)) (fun i j => { toFun := fun x => ⟨⟨↑↑x, ⋯⟩, ⋯⟩, continuous_toFun := ⋯ }) ⋯ ⋯ ⋯ ⋯).J\n⊢ Eq ((TopCat.GlueData.ofOpenSubsets U).f i j) ((TopologicalSpace.Opens.map (U i).inclusion').obj (U j)).inclusion'","decl":"/-- We may construct a glue data from a family of open sets. -/\n@[simps! toGlueData_J toGlueData_U toGlueData_V toGlueData_t toGlueData_f]\ndef ofOpenSubsets : TopCat.GlueData.{u} :=\n  mk'.{u}\n    { J\n      U := fun i => (Opens.toTopCat <| TopCat.of α).obj (U i)\n      V := fun _ j => (Opens.map <| Opens.inclusion' _).obj (U j)\n      t := fun i j => ⟨fun x => ⟨⟨x.1.1, x.2⟩, x.1.2⟩, by fun_prop⟩\n      V_id := fun i => by ext; simp\n      t_id := fun i => by ext; rfl\n      t_inter := fun _ _ _ _ hx => hx\n      cocycle := fun _ _ _ _ _ => rfl }\n\n"}
{"name":"TopCat.GlueData.ofOpenSubsets_toGlueData_U","module":"Mathlib.Topology.Gluing","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nJ : Type u\nU : J → TopologicalSpace.Opens α\na✝ : (TopCat.GlueData.MkCore.mk (fun i => (TopologicalSpace.Opens.toTopCat (TopCat.of α)).obj (U i)) (fun x j => (TopologicalSpace.Opens.map (U x).inclusion').obj (U j)) (fun i j => { toFun := fun x => ⟨⟨↑↑x, ⋯⟩, ⋯⟩, continuous_toFun := ⋯ }) ⋯ ⋯ ⋯ ⋯).J\n⊢ Eq ((TopCat.GlueData.ofOpenSubsets U).U a✝) ((TopologicalSpace.Opens.toTopCat (TopCat.of α)).obj (U a✝))","decl":"/-- We may construct a glue data from a family of open sets. -/\n@[simps! toGlueData_J toGlueData_U toGlueData_V toGlueData_t toGlueData_f]\ndef ofOpenSubsets : TopCat.GlueData.{u} :=\n  mk'.{u}\n    { J\n      U := fun i => (Opens.toTopCat <| TopCat.of α).obj (U i)\n      V := fun _ j => (Opens.map <| Opens.inclusion' _).obj (U j)\n      t := fun i j => ⟨fun x => ⟨⟨x.1.1, x.2⟩, x.1.2⟩, by fun_prop⟩\n      V_id := fun i => by ext; simp\n      t_id := fun i => by ext; rfl\n      t_inter := fun _ _ _ _ hx => hx\n      cocycle := fun _ _ _ _ _ => rfl }\n\n"}
{"name":"TopCat.GlueData.ofOpenSubsets_toGlueData_V","module":"Mathlib.Topology.Gluing","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nJ : Type u\nU : J → TopologicalSpace.Opens α\ni : Prod (TopCat.GlueData.MkCore.mk (fun i => (TopologicalSpace.Opens.toTopCat (TopCat.of α)).obj (U i)) (fun x j => (TopologicalSpace.Opens.map (U x).inclusion').obj (U j)) (fun i j => { toFun := fun x => ⟨⟨↑↑x, ⋯⟩, ⋯⟩, continuous_toFun := ⋯ }) ⋯ ⋯ ⋯ ⋯).J (TopCat.GlueData.MkCore.mk (fun i => (TopologicalSpace.Opens.toTopCat (TopCat.of α)).obj (U i)) (fun x j => (TopologicalSpace.Opens.map (U x).inclusion').obj (U j)) (fun i j => { toFun := fun x => ⟨⟨↑↑x, ⋯⟩, ⋯⟩, continuous_toFun := ⋯ }) ⋯ ⋯ ⋯ ⋯).J\n⊢ Eq ((TopCat.GlueData.ofOpenSubsets U).V i) ((TopologicalSpace.Opens.toTopCat ((TopologicalSpace.Opens.toTopCat (TopCat.of α)).obj (U i.1))).obj ((TopologicalSpace.Opens.map (U i.1).inclusion').obj (U i.2)))","decl":"/-- We may construct a glue data from a family of open sets. -/\n@[simps! toGlueData_J toGlueData_U toGlueData_V toGlueData_t toGlueData_f]\ndef ofOpenSubsets : TopCat.GlueData.{u} :=\n  mk'.{u}\n    { J\n      U := fun i => (Opens.toTopCat <| TopCat.of α).obj (U i)\n      V := fun _ j => (Opens.map <| Opens.inclusion' _).obj (U j)\n      t := fun i j => ⟨fun x => ⟨⟨x.1.1, x.2⟩, x.1.2⟩, by fun_prop⟩\n      V_id := fun i => by ext; simp\n      t_id := fun i => by ext; rfl\n      t_inter := fun _ _ _ _ hx => hx\n      cocycle := fun _ _ _ _ _ => rfl }\n\n"}
{"name":"TopCat.GlueData.ofOpenSubsets_toGlueData_J","module":"Mathlib.Topology.Gluing","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nJ : Type u\nU : J → TopologicalSpace.Opens α\n⊢ Eq (TopCat.GlueData.ofOpenSubsets U).J J","decl":"/-- We may construct a glue data from a family of open sets. -/\n@[simps! toGlueData_J toGlueData_U toGlueData_V toGlueData_t toGlueData_f]\ndef ofOpenSubsets : TopCat.GlueData.{u} :=\n  mk'.{u}\n    { J\n      U := fun i => (Opens.toTopCat <| TopCat.of α).obj (U i)\n      V := fun _ j => (Opens.map <| Opens.inclusion' _).obj (U j)\n      t := fun i j => ⟨fun x => ⟨⟨x.1.1, x.2⟩, x.1.2⟩, by fun_prop⟩\n      V_id := fun i => by ext; simp\n      t_id := fun i => by ext; rfl\n      t_inter := fun _ _ _ _ hx => hx\n      cocycle := fun _ _ _ _ _ => rfl }\n\n"}
{"name":"TopCat.GlueData.ι_fromOpenSubsetsGlue","module":"Mathlib.Topology.Gluing","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nJ : Type u\nU : J → TopologicalSpace.Opens α\ni : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((TopCat.GlueData.ofOpenSubsets U).ι i) (TopCat.GlueData.fromOpenSubsetsGlue U)) (U i).inclusion'","decl":"@[simp, elementwise nosimp]\ntheorem ι_fromOpenSubsetsGlue (i : J) :\n    (ofOpenSubsets U).toGlueData.ι i ≫ fromOpenSubsetsGlue U = Opens.inclusion' _ :=\n  Multicoequalizer.π_desc _ _ _ _ _\n\n"}
{"name":"TopCat.GlueData.ι_fromOpenSubsetsGlue_apply","module":"Mathlib.Topology.Gluing","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nJ : Type u\nU : J → TopologicalSpace.Opens α\ni : J\nx : (CategoryTheory.forget TopCat).obj ((TopCat.GlueData.ofOpenSubsets U).U i)\n⊢ Eq ((TopCat.GlueData.fromOpenSubsetsGlue U) (((TopCat.GlueData.ofOpenSubsets U).ι i) x)) ((U i).inclusion' x)","decl":"@[simp, elementwise nosimp]\ntheorem ι_fromOpenSubsetsGlue (i : J) :\n    (ofOpenSubsets U).toGlueData.ι i ≫ fromOpenSubsetsGlue U = Opens.inclusion' _ :=\n  Multicoequalizer.π_desc _ _ _ _ _\n\n"}
{"name":"TopCat.GlueData.fromOpenSubsetsGlue_injective","module":"Mathlib.Topology.Gluing","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nJ : Type u\nU : J → TopologicalSpace.Opens α\n⊢ Function.Injective ⇑(TopCat.GlueData.fromOpenSubsetsGlue U)","decl":"theorem fromOpenSubsetsGlue_injective : Function.Injective (fromOpenSubsetsGlue U) := by\n  intro x y e\n  obtain ⟨i, ⟨x, hx⟩, rfl⟩ := (ofOpenSubsets U).ι_jointly_surjective x\n  obtain ⟨j, ⟨y, hy⟩, rfl⟩ := (ofOpenSubsets U).ι_jointly_surjective y\n  -- see the porting note on `ι_fromOpenSubsetsGlue`\n  rw [ι_fromOpenSubsetsGlue_apply, ι_fromOpenSubsetsGlue_apply] at e\n  change x = y at e\n  subst e\n  rw [(ofOpenSubsets U).ι_eq_iff_rel]\n  exact ⟨⟨⟨x, hx⟩, hy⟩, rfl, rfl⟩\n\n"}
{"name":"TopCat.GlueData.fromOpenSubsetsGlue_isOpenMap","module":"Mathlib.Topology.Gluing","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nJ : Type u\nU : J → TopologicalSpace.Opens α\n⊢ IsOpenMap ⇑(TopCat.GlueData.fromOpenSubsetsGlue U)","decl":"theorem fromOpenSubsetsGlue_isOpenMap : IsOpenMap (fromOpenSubsetsGlue U) := by\n  intro s hs\n  rw [(ofOpenSubsets U).isOpen_iff] at hs\n  rw [isOpen_iff_forall_mem_open]\n  rintro _ ⟨x, hx, rfl⟩\n  obtain ⟨i, ⟨x, hx'⟩, rfl⟩ := (ofOpenSubsets U).ι_jointly_surjective x\n  use fromOpenSubsetsGlue U '' s ∩ Set.range (@Opens.inclusion' (TopCat.of α) (U i))\n  use Set.inter_subset_left\n  constructor\n  · rw [← Set.image_preimage_eq_inter_range]\n    apply (Opens.isOpenEmbedding (X := TopCat.of α) (U i)).isOpenMap\n    convert hs i using 1\n    erw [← ι_fromOpenSubsetsGlue, coe_comp, Set.preimage_comp]\n    congr! 1\n    exact Set.preimage_image_eq _ (fromOpenSubsetsGlue_injective U)\n  · refine ⟨Set.mem_image_of_mem _ hx, ?_⟩\n    rw [ι_fromOpenSubsetsGlue_apply]\n    exact Set.mem_range_self _\n\n"}
{"name":"TopCat.GlueData.fromOpenSubsetsGlue_isOpenEmbedding","module":"Mathlib.Topology.Gluing","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nJ : Type u\nU : J → TopologicalSpace.Opens α\n⊢ Topology.IsOpenEmbedding ⇑(TopCat.GlueData.fromOpenSubsetsGlue U)","decl":"theorem fromOpenSubsetsGlue_isOpenEmbedding : IsOpenEmbedding (fromOpenSubsetsGlue U) :=\n  .of_continuous_injective_isOpenMap (ContinuousMap.continuous_toFun _)\n    (fromOpenSubsetsGlue_injective U) (fromOpenSubsetsGlue_isOpenMap U)\n\n"}
{"name":"TopCat.GlueData.fromOpenSubsetsGlue_openEmbedding","module":"Mathlib.Topology.Gluing","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nJ : Type u\nU : J → TopologicalSpace.Opens α\n⊢ Topology.IsOpenEmbedding ⇑(TopCat.GlueData.fromOpenSubsetsGlue U)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias fromOpenSubsetsGlue_openEmbedding := fromOpenSubsetsGlue_isOpenEmbedding\n\n"}
{"name":"TopCat.GlueData.range_fromOpenSubsetsGlue","module":"Mathlib.Topology.Gluing","initialProofState":"α : Type u\ninst✝ : TopologicalSpace α\nJ : Type u\nU : J → TopologicalSpace.Opens α\n⊢ Eq (Set.range ⇑(TopCat.GlueData.fromOpenSubsetsGlue U)) (Set.iUnion fun i => ↑(U i))","decl":"theorem range_fromOpenSubsetsGlue : Set.range (fromOpenSubsetsGlue U) = ⋃ i, (U i : Set α) := by\n  ext\n  constructor\n  · rintro ⟨x, rfl⟩\n    obtain ⟨i, ⟨x, hx'⟩, rfl⟩ := (ofOpenSubsets U).ι_jointly_surjective x\n    rw [ι_fromOpenSubsetsGlue_apply]\n    exact Set.subset_iUnion _ i hx'\n  · rintro ⟨_, ⟨i, rfl⟩, hx⟩\n    rename_i x\n    exact ⟨(ofOpenSubsets U).toGlueData.ι i ⟨x, hx⟩, ι_fromOpenSubsetsGlue_apply _ _ _⟩\n\n"}
