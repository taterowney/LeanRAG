{"name":"TopCat.GlueData.mk.inj","module":"Mathlib.Topology.Gluing","initialProofState":"toGlueData‚úù : CategoryTheory.GlueData TopCat\nf_open‚úù : ‚àÄ (i j : toGlueData‚úù.J), Topology.IsOpenEmbedding ‚áë(toGlueData‚úù.f i j)\ntoGlueData : CategoryTheory.GlueData TopCat\nf_open : ‚àÄ (i j : toGlueData.J), Topology.IsOpenEmbedding ‚áë(toGlueData.f i j)\nx‚úù : Eq { toGlueData := toGlueData‚úù, f_open := f_open‚úù } { toGlueData := toGlueData, f_open := f_open }\n‚ä¢ Eq toGlueData‚úù toGlueData","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n  (Note that this is `J √ó J ‚Üí TopCat` rather than `J ‚Üí J ‚Üí TopCat` to connect to the\n  limits library easier.)\n4. An open embedding `f i j : V i j ‚ü∂ U i` for each `i j : Œπ`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n    (This merely means that `V i j ‚à© V i k ‚äÜ t i j ‚Åª¬π' (V j i ‚à© V j k)`.)\n9. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subspaces of the glued space.\n\nMost of the times it would be easier to use the constructor `TopCat.GlueData.mk'` where the\nconditions are stated in a less categorical way.\n-/\nstructure GlueData extends CategoryTheory.GlueData TopCat where\n  f_open : ‚àÄ i j, IsOpenEmbedding (f i j)\n  f_mono i j := (TopCat.mono_iff_injective _).mpr (f_open i j).isEmbedding.injective\n\n"}
{"name":"TopCat.GlueData.mk.injEq","module":"Mathlib.Topology.Gluing","initialProofState":"toGlueData‚úù : CategoryTheory.GlueData TopCat\nf_open‚úù : ‚àÄ (i j : toGlueData‚úù.J), Topology.IsOpenEmbedding ‚áë(toGlueData‚úù.f i j)\ntoGlueData : CategoryTheory.GlueData TopCat\nf_open : ‚àÄ (i j : toGlueData.J), Topology.IsOpenEmbedding ‚áë(toGlueData.f i j)\n‚ä¢ Eq (Eq { toGlueData := toGlueData‚úù, f_open := f_open‚úù } { toGlueData := toGlueData, f_open := f_open }) (Eq toGlueData‚úù toGlueData)","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n  (Note that this is `J √ó J ‚Üí TopCat` rather than `J ‚Üí J ‚Üí TopCat` to connect to the\n  limits library easier.)\n4. An open embedding `f i j : V i j ‚ü∂ U i` for each `i j : Œπ`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n    (This merely means that `V i j ‚à© V i k ‚äÜ t i j ‚Åª¬π' (V j i ‚à© V j k)`.)\n9. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subspaces of the glued space.\n\nMost of the times it would be easier to use the constructor `TopCat.GlueData.mk'` where the\nconditions are stated in a less categorical way.\n-/\nstructure GlueData extends CategoryTheory.GlueData TopCat where\n  f_open : ‚àÄ i j, IsOpenEmbedding (f i j)\n  f_mono i j := (TopCat.mono_iff_injective _).mpr (f_open i j).isEmbedding.injective\n\n"}
{"name":"TopCat.GlueData.f_open","module":"Mathlib.Topology.Gluing","initialProofState":"self : TopCat.GlueData\ni j : self.J\n‚ä¢ Topology.IsOpenEmbedding ‚áë(self.f i j)","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n  (Note that this is `J √ó J ‚Üí TopCat` rather than `J ‚Üí J ‚Üí TopCat` to connect to the\n  limits library easier.)\n4. An open embedding `f i j : V i j ‚ü∂ U i` for each `i j : Œπ`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n    (This merely means that `V i j ‚à© V i k ‚äÜ t i j ‚Åª¬π' (V j i ‚à© V j k)`.)\n9. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subspaces of the glued space.\n\nMost of the times it would be easier to use the constructor `TopCat.GlueData.mk'` where the\nconditions are stated in a less categorical way.\n-/\nstructure GlueData extends CategoryTheory.GlueData TopCat where\n  f_open : ‚àÄ i j, IsOpenEmbedding (f i j)\n  f_mono i j := (TopCat.mono_iff_injective _).mpr (f_open i j).isEmbedding.injective\n\n"}
{"name":"TopCat.GlueData.mk.sizeOf_spec","module":"Mathlib.Topology.Gluing","initialProofState":"toGlueData : CategoryTheory.GlueData TopCat\nf_open : ‚àÄ (i j : toGlueData.J), Topology.IsOpenEmbedding ‚áë(toGlueData.f i j)\n‚ä¢ Eq (SizeOf.sizeOf { toGlueData := toGlueData, f_open := f_open }) (HAdd.hAdd 1 (SizeOf.sizeOf toGlueData))","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. An object `U i` for each `i : J`.\n3. An object `V i j` for each `i j : J`.\n  (Note that this is `J √ó J ‚Üí TopCat` rather than `J ‚Üí J ‚Üí TopCat` to connect to the\n  limits library easier.)\n4. An open embedding `f i j : V i j ‚ü∂ U i` for each `i j : Œπ`.\n5. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `f i i` is an isomorphism.\n7. `t i i` is the identity.\n8. `V i j √ó[U i] V i k ‚ü∂ V i j ‚ü∂ V j i` factors through `V j k √ó[U j] V j i ‚ü∂ V j i` via some\n    `t' : V i j √ó[U i] V i k ‚ü∂ V j k √ó[U j] V j i`.\n    (This merely means that `V i j ‚à© V i k ‚äÜ t i j ‚Åª¬π' (V j i ‚à© V j k)`.)\n9. `t' i j k ‚â´ t' j k i ‚â´ t' k i j = ùüô _`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`, such\nthat the `U i`'s are open subspaces of the glued space.\n\nMost of the times it would be easier to use the constructor `TopCat.GlueData.mk'` where the\nconditions are stated in a less categorical way.\n-/\nstructure GlueData extends CategoryTheory.GlueData TopCat where\n  f_open : ‚àÄ i j, IsOpenEmbedding (f i j)\n  f_mono i j := (TopCat.mono_iff_injective _).mpr (f_open i j).isEmbedding.injective\n\n"}
{"name":"TopCat.GlueData.œÄ_surjective","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\n‚ä¢ Function.Surjective ‚áëD.œÄ","decl":"theorem œÄ_surjective : Function.Surjective ùñ£.œÄ :=\n  (TopCat.epi_iff_surjective ùñ£.œÄ).mp inferInstance\n\n"}
{"name":"TopCat.GlueData.isOpen_iff","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\nU : Set ‚ÜëD.glued\n‚ä¢ Iff (IsOpen U) (‚àÄ (i : D.J), IsOpen (Set.preimage (‚áë(D.Œπ i)) U))","decl":"theorem isOpen_iff (U : Set ùñ£.glued) : IsOpen U ‚Üî ‚àÄ i, IsOpen (ùñ£.Œπ i ‚Åª¬π' U) := by\n  delta CategoryTheory.GlueData.Œπ\n  simp_rw [‚Üê Multicoequalizer.Œπ_sigmaœÄ ùñ£.diagram]\n  rw [‚Üê (homeoOfIso (Multicoequalizer.isoCoequalizer ùñ£.diagram).symm).isOpen_preimage]\n  rw [coequalizer_isOpen_iff, colimit_isOpen_iff.{u}]\n  tauto\n\n"}
{"name":"TopCat.GlueData.Œπ_jointly_surjective","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\nx : ‚ÜëD.glued\n‚ä¢ Exists fun i => Exists fun y => Eq ((D.Œπ i) y) x","decl":"theorem Œπ_jointly_surjective (x : ùñ£.glued) : ‚àÉ (i : _) (y : D.U i), ùñ£.Œπ i y = x :=\n  ùñ£.Œπ_jointly_surjective (forget TopCat) x\n\n"}
{"name":"TopCat.GlueData.rel_equiv","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\n‚ä¢ Equivalence D.Rel","decl":"theorem rel_equiv : Equivalence D.Rel :=\n  ‚ü®fun x => ‚ü®inv (D.f _ _) x.2, IsIso.inv_hom_id_apply _ _,\n    by simp [IsIso.inv_hom_id_apply _ _]‚ü©, by\n    rintro a b ‚ü®x, e‚ÇÅ, e‚ÇÇ‚ü©\n    exact ‚ü®D.t _ _ x, e‚ÇÇ, by rw [‚Üê e‚ÇÅ, D.t_inv_apply]‚ü©, by\n    rintro ‚ü®i, a‚ü© ‚ü®j, b‚ü© ‚ü®k, c‚ü© ‚ü®x, e‚ÇÅ, e‚ÇÇ‚ü©\n    rintro ‚ü®y, e‚ÇÉ, e‚ÇÑ‚ü©\n    let z := (pullbackIsoProdSubtype (D.f j i) (D.f j k)).inv ‚ü®‚ü®_, _‚ü©, e‚ÇÇ.trans e‚ÇÉ.symm‚ü©\n    have eq‚ÇÅ : (D.t j i) ((pullback.fst _ _ : _ /-(D.f j k)-/ ‚ü∂ D.V (j, i)) z) = x := by\n      dsimp only [coe_of, z]\n      erw [pullbackIsoProdSubtype_inv_fst_apply, D.t_inv_apply]-- now `erw` after https://github.com/leanprover-community/mathlib4/pull/13170\n    have eq‚ÇÇ : (pullback.snd _ _ : _ ‚ü∂ D.V _) z = y := pullbackIsoProdSubtype_inv_snd_apply _ _ _\n    clear_value z\n    use (pullback.fst _ _ : _ ‚ü∂ D.V (i, k)) (D.t' _ _ _ z)\n    dsimp only at *\n    substs eq‚ÇÅ eq‚ÇÇ e‚ÇÅ e‚ÇÉ e‚ÇÑ\n    have h‚ÇÅ : D.t' j i k ‚â´ pullback.fst _ _ ‚â´ D.f i k = pullback.fst _ _ ‚â´ D.t j i ‚â´ D.f i j := by\n      rw [‚Üê ùñ£.t_fac_assoc]; congr 1; exact pullback.condition\n    have h‚ÇÇ : D.t' j i k ‚â´ pullback.fst _ _ ‚â´ D.t i k ‚â´ D.f k i =\n        pullback.snd _ _ ‚â´ D.t j k ‚â´ D.f k j := by\n      rw [‚Üê ùñ£.t_fac_assoc]\n      apply @Epi.left_cancellation _ _ _ _ (D.t' k j i)\n      rw [ùñ£.cocycle_assoc, ùñ£.t_fac_assoc, ùñ£.t_inv_assoc]\n      exact pullback.condition.symm\n    exact ‚ü®ContinuousMap.congr_fun h‚ÇÅ z, ContinuousMap.congr_fun h‚ÇÇ z‚ü©‚ü©\n\n"}
{"name":"TopCat.GlueData.eqvGen_of_œÄ_eq","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\nx y : ‚Üë(CategoryTheory.Limits.sigmaObj D.U)\nh : Eq (D.œÄ x) (D.œÄ y)\n‚ä¢ Relation.EqvGen (CategoryTheory.Limits.Types.CoequalizerRel ‚áëD.diagram.fstSigmaMap ‚áëD.diagram.sndSigmaMap) x y","decl":"theorem eqvGen_of_œÄ_eq\n    -- Porting note: was `{x y : ‚àê D.U} (h : ùñ£.œÄ x = ùñ£.œÄ y)`\n    {x y : sigmaObj (Œ≤ := D.toGlueData.J) (C := TopCat) D.toGlueData.U}\n    (h : ùñ£.œÄ x = ùñ£.œÄ y) :\n    Relation.EqvGen\n      -- Porting note: was (Types.CoequalizerRel ùñ£.diagram.fstSigmaMap ùñ£.diagram.sndSigmaMap)\n      (Types.CoequalizerRel\n        (X := sigmaObj (Œ≤ := D.toGlueData.diagram.L) (C := TopCat) (D.toGlueData.diagram).left)\n        (Y := sigmaObj (Œ≤ := D.toGlueData.diagram.R) (C := TopCat) (D.toGlueData.diagram).right)\n        ùñ£.diagram.fstSigmaMap ùñ£.diagram.sndSigmaMap)\n      x y := by\n  delta GlueData.œÄ Multicoequalizer.sigmaœÄ at h\n  -- Porting note: inlined `inferInstance` instead of leaving as a side goal.\n  replace h := (TopCat.mono_iff_injective (Multicoequalizer.isoCoequalizer ùñ£.diagram).inv).mp\n    inferInstance h\n  let diagram := parallelPair ùñ£.diagram.fstSigmaMap ùñ£.diagram.sndSigmaMap ‚ãô forget _\n  have : colimit.Œπ diagram one x = colimit.Œπ diagram one y := by\n    dsimp only [coequalizer.œÄ, ContinuousMap.toFun_eq_coe] at h\n    rw [‚Üê Œπ_preservesColimitIso_hom, forget_map_eq_coe, types_comp_apply, h]\n    simp\n  have :\n    (colimit.Œπ diagram _ ‚â´ colim.map _ ‚â´ (colimit.isoColimitCocone _).hom) _ =\n      (colimit.Œπ diagram _ ‚â´ colim.map _ ‚â´ (colimit.isoColimitCocone _).hom) _ :=\n    (congr_arg\n        (colim.map (diagramIsoParallelPair diagram).hom ‚â´\n          (colimit.isoColimitCocone (Types.coequalizerColimit _ _)).hom)\n        this :\n      _)\n  -- Porting note: was\n  -- simp only [eqToHom_refl, types_comp_apply, colimit.Œπ_map_assoc,\n  --   diagramIsoParallelPair_hom_app, colimit.isoColimitCocone_Œπ_hom, types_id_apply] at this\n  -- See https://github.com/leanprover-community/mathlib4/issues/5026\n  rw [colimit.Œπ_map_assoc, diagramIsoParallelPair_hom_app, eqToHom_refl,\n    colimit.isoColimitCocone_Œπ_hom, types_comp_apply, types_id_apply, types_comp_apply,\n    types_id_apply] at this\n  exact Quot.eq.1 this\n\n"}
{"name":"TopCat.GlueData.Œπ_eq_iff_rel","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\ni j : D.J\nx : ‚Üë(D.U i)\ny : ‚Üë(D.U j)\n‚ä¢ Iff (Eq ((D.Œπ i) x) ((D.Œπ j) y)) (D.Rel ‚ü®i, x‚ü© ‚ü®j, y‚ü©)","decl":"theorem Œπ_eq_iff_rel (i j : D.J) (x : D.U i) (y : D.U j) :\n    ùñ£.Œπ i x = ùñ£.Œπ j y ‚Üî D.Rel ‚ü®i, x‚ü© ‚ü®j, y‚ü© := by\n  constructor\n  ¬∑ delta GlueData.Œπ\n    simp_rw [‚Üê Multicoequalizer.Œπ_sigmaœÄ]\n    intro h\n    rw [‚Üê\n      show _ = Sigma.mk i x from ConcreteCategory.congr_hom (sigmaIsoSigma.{_, u} D.U).inv_hom_id _]\n    rw [‚Üê\n      show _ = Sigma.mk j y from ConcreteCategory.congr_hom (sigmaIsoSigma.{_, u} D.U).inv_hom_id _]\n    change InvImage D.Rel (sigmaIsoSigma.{_, u} D.U).hom _ _\n    rw [‚Üê (InvImage.equivalence _ _ D.rel_equiv).eqvGen_iff]\n    refine Relation.EqvGen.mono ?_ (D.eqvGen_of_œÄ_eq h :)\n    rintro _ _ ‚ü®x‚ü©\n    obtain ‚ü®‚ü®‚ü®i, j‚ü©, y‚ü©, rfl‚ü© :=\n      (ConcreteCategory.bijective_of_isIso (sigmaIsoSigma.{u, u} _).inv).2 x\n    unfold InvImage MultispanIndex.fstSigmaMap MultispanIndex.sndSigmaMap\n    simp only [forget_map_eq_coe]\n    erw [TopCat.comp_app, sigmaIsoSigma_inv_apply, ‚Üê CategoryTheory.comp_apply,\n      ‚Üê CategoryTheory.comp_apply, colimit.Œπ_desc_assoc, ‚Üê CategoryTheory.comp_apply,\n      ‚Üê CategoryTheory.comp_apply, colimit.Œπ_desc_assoc]\n      -- previous line now `erw` after https://github.com/leanprover-community/mathlib4/pull/13170\n    erw [sigmaIsoSigma_hom_Œπ_apply, sigmaIsoSigma_hom_Œπ_apply]\n    exact ‚ü®y, ‚ü®rfl, rfl‚ü©‚ü©\n  ¬∑ rintro ‚ü®z, e‚ÇÅ, e‚ÇÇ‚ü©\n    dsimp only at *\n    -- Porting note: there were `subst e‚ÇÅ` and `subst e‚ÇÇ`, instead of the `rw`\n    rw [‚Üê e‚ÇÅ, ‚Üê e‚ÇÇ] at *\n    rw [D.glue_condition_apply]\n\n"}
{"name":"TopCat.GlueData.Œπ_injective","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\ni : D.J\n‚ä¢ Function.Injective ‚áë(D.Œπ i)","decl":"theorem Œπ_injective (i : D.J) : Function.Injective (ùñ£.Œπ i) := by\n  intro x y h\n  rcases (D.Œπ_eq_iff_rel _ _ _ _).mp h with ‚ü®_, e‚ÇÅ, e‚ÇÇ‚ü©\n  ¬∑ dsimp only at *\n    -- Porting note: there were `cases e‚ÇÅ` and `cases e‚ÇÇ`, instead of the `rw`\n    rw [‚Üê e‚ÇÅ, ‚Üê e‚ÇÇ]\n    simp\n\n"}
{"name":"TopCat.GlueData.Œπ_mono","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\ni : D.J\n‚ä¢ CategoryTheory.Mono (D.Œπ i)","decl":"instance Œπ_mono (i : D.J) : Mono (ùñ£.Œπ i) :=\n  (TopCat.mono_iff_injective _).mpr (D.Œπ_injective _)\n\n"}
{"name":"TopCat.GlueData.image_inter","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\ni j : D.J\n‚ä¢ Eq (Inter.inter (Set.range ‚áë(D.Œπ i)) (Set.range ‚áë(D.Œπ j))) (Set.range ‚áë(CategoryTheory.CategoryStruct.comp (D.f i j) (D.Œπ i)))","decl":"theorem image_inter (i j : D.J) :\n    Set.range (ùñ£.Œπ i) ‚à© Set.range (ùñ£.Œπ j) = Set.range (D.f i j ‚â´ ùñ£.Œπ _) := by\n  ext x\n  constructor\n  ¬∑ rintro ‚ü®‚ü®x‚ÇÅ, eq‚ÇÅ‚ü©, ‚ü®x‚ÇÇ, eq‚ÇÇ‚ü©‚ü©\n    obtain ‚ü®y, e‚ÇÅ, -‚ü© := (D.Œπ_eq_iff_rel _ _ _ _).mp (eq‚ÇÅ.trans eq‚ÇÇ.symm)\n    ¬∑ substs eq‚ÇÅ\n      exact ‚ü®y, by simp [e‚ÇÅ]‚ü©\n  ¬∑ rintro ‚ü®x, hx‚ü©\n    refine ‚ü®‚ü®D.f i j x, hx‚ü©, ‚ü®D.f j i (D.t _ _ x), ?_‚ü©‚ü©\n    rw [D.glue_condition_apply]\n    exact hx\n\n"}
{"name":"TopCat.GlueData.preimage_range","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\ni j : D.J\n‚ä¢ Eq (Set.preimage (‚áë(D.Œπ j)) (Set.range ‚áë(D.Œπ i))) (Set.range ‚áë(D.f j i))","decl":"theorem preimage_range (i j : D.J) : ùñ£.Œπ j ‚Åª¬π' Set.range (ùñ£.Œπ i) = Set.range (D.f j i) := by\n  rw [‚Üê Set.preimage_image_eq (Set.range (D.f j i)) (D.Œπ_injective j), ‚Üê Set.image_univ, ‚Üê\n    Set.image_univ, ‚Üê Set.image_comp, ‚Üê coe_comp, Set.image_univ, Set.image_univ, ‚Üê image_inter,\n    Set.preimage_range_inter]\n\n"}
{"name":"TopCat.GlueData.preimage_image_eq_image","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\ni j : D.J\nU : Set ‚Üë(D.U i)\n‚ä¢ Eq (Set.preimage (‚áë(D.Œπ j)) (Set.image (‚áë(D.Œπ i)) U)) (Set.image (‚áë(D.f j i)) (Set.preimage (‚áë(CategoryTheory.CategoryStruct.comp (D.t j i) (D.f i j))) U))","decl":"theorem preimage_image_eq_image (i j : D.J) (U : Set (ùñ£.U i)) :\n    ùñ£.Œπ j ‚Åª¬π' (ùñ£.Œπ i '' U) = D.f _ _ '' ((D.t j i ‚â´ D.f _ _) ‚Åª¬π' U) := by\n  have : D.f _ _ ‚Åª¬π' (ùñ£.Œπ j ‚Åª¬π' (ùñ£.Œπ i '' U)) = (D.t j i ‚â´ D.f _ _) ‚Åª¬π' U := by\n    ext x\n    conv_rhs => rw [‚Üê Set.preimage_image_eq U (D.Œπ_injective _)]\n    generalize ùñ£.Œπ i '' U = U' -- next 4 lines were `simp` before https://github.com/leanprover-community/mathlib4/pull/13170\n    simp only [GlueData.diagram_l, GlueData.diagram_r, Set.mem_preimage, coe_comp,\n      Function.comp_apply]\n    rw [D.glue_condition_apply]\n  rw [‚Üê this, Set.image_preimage_eq_inter_range]\n  symm\n  apply Set.inter_eq_self_of_subset_left\n  rw [‚Üê D.preimage_range i j]\n  exact Set.preimage_mono (Set.image_subset_range _ _)\n\n"}
{"name":"TopCat.GlueData.preimage_image_eq_image'","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\ni j : D.J\nU : Set ‚Üë(D.U i)\n‚ä¢ Eq (Set.preimage (‚áë(D.Œπ j)) (Set.image (‚áë(D.Œπ i)) U)) (Set.image (‚áë(CategoryTheory.CategoryStruct.comp (D.t i j) (D.f j i))) (Set.preimage (‚áë(D.f i j)) U))","decl":"theorem preimage_image_eq_image' (i j : D.J) (U : Set (ùñ£.U i)) :\n    ùñ£.Œπ j ‚Åª¬π' (ùñ£.Œπ i '' U) = (D.t i j ‚â´ D.f _ _) '' (D.f _ _ ‚Åª¬π' U) := by\n  convert D.preimage_image_eq_image i j U using 1\n  rw [coe_comp, coe_comp]\n  -- Porting note: `show` was not needed, since `rw [‚Üê Set.image_image]` worked.\n  show (fun x => ((forget TopCat).map _ ((forget TopCat).map _ x))) '' _ = _\n  rw [‚Üê Set.image_image]\n  congr! 1\n  rw [‚Üê Set.eq_preimage_iff_image_eq, Set.preimage_preimage]\n  ¬∑ change _ = (D.t i j ‚â´ D.t j i ‚â´ _) ‚Åª¬π' _\n    rw [ùñ£.t_inv_assoc]\n  rw [‚Üê isIso_iff_bijective]\n  apply (forget TopCat).map_isIso\n\n"}
{"name":"TopCat.GlueData.open_image_open","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\ni : D.J\nU : TopologicalSpace.Opens ‚Üë(D.U i)\n‚ä¢ IsOpen (Set.image ‚áë(D.Œπ i) ‚ÜëU)","decl":"theorem open_image_open (i : D.J) (U : Opens (ùñ£.U i)) : IsOpen (ùñ£.Œπ i '' U) := by\n  rw [isOpen_iff]\n  intro j\n  rw [preimage_image_eq_image]\n  apply (D.f_open _ _).isOpenMap\n  apply (D.t j i ‚â´ D.f i j).continuous_toFun.isOpen_preimage\n  exact U.isOpen\n\n"}
{"name":"TopCat.GlueData.Œπ_isOpenEmbedding","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\ni : D.J\n‚ä¢ Topology.IsOpenEmbedding ‚áë(D.Œπ i)","decl":"theorem Œπ_isOpenEmbedding (i : D.J) : IsOpenEmbedding (ùñ£.Œπ i) :=\n  .of_continuous_injective_isOpenMap (ùñ£.Œπ i).continuous_toFun (D.Œπ_injective i) fun U h =>\n    D.open_image_open i ‚ü®U, h‚ü©\n\n"}
{"name":"TopCat.GlueData.Œπ_openEmbedding","module":"Mathlib.Topology.Gluing","initialProofState":"D : TopCat.GlueData\ni : D.J\n‚ä¢ Topology.IsOpenEmbedding ‚áë(D.Œπ i)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias Œπ_openEmbedding := Œπ_isOpenEmbedding\n\n"}
{"name":"TopCat.GlueData.MkCore.mk.sizeOf_spec","module":"Mathlib.Topology.Gluing","initialProofState":"J : Type u\nU : J ‚Üí TopCat\nV : (i : J) ‚Üí J ‚Üí TopologicalSpace.Opens ‚Üë(U i)\nt : (i j : J) ‚Üí Quiver.Hom ((TopologicalSpace.Opens.toTopCat (U i)).obj (V i j)) ((TopologicalSpace.Opens.toTopCat (U j)).obj (V j i))\nV_id : ‚àÄ (i : J), Eq (V i i) Top.top\nt_id : ‚àÄ (i : J), Eq (‚áë(t i i)) id\nt_inter : ‚àÄ ‚¶Éi j : J‚¶Ñ (k : J) (x : Subtype fun x => Membership.mem (V i j) x), Membership.mem (V i k) ‚Üëx ‚Üí Membership.mem (V j k) ‚Üë((t i j) x)\ncocycle : ‚àÄ (i j k : J) (x : Subtype fun x => Membership.mem (V i j) x) (h : Membership.mem (V i k) ‚Üëx), Eq ‚Üë((t j k) ‚ü®‚Üë((t i j) x), ‚ãØ‚ü©) ‚Üë((t i k) ‚ü®‚Üëx, h‚ü©)\n‚ä¢ Eq (SizeOf.sizeOf (TopCat.GlueData.MkCore.mk U V t V_id t_id t_inter cocycle)) (HAdd.hAdd 1 (SizeOf.sizeOf J))","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A bundled topological space `U i` for each `i : J`.\n3. An open set `V i j ‚äÜ U i` for each `i j : J`.\n4. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `V i i = U i`.\n7. `t i i` is the identity.\n8. For each `x ‚àà V i j ‚à© V i k`, `t i j x ‚àà V j k`.\n9. `t j k (t i j x) = t i k x`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`.\n-/\nstructure MkCore where\n  {J : Type u}\n  U : J ‚Üí TopCat.{u}\n  V : ‚àÄ i, J ‚Üí Opens (U i)\n  t : ‚àÄ i j, (Opens.toTopCat _).obj (V i j) ‚ü∂ (Opens.toTopCat _).obj (V j i)\n  V_id : ‚àÄ i, V i i = ‚ä§\n  t_id : ‚àÄ i, ‚áë(t i i) = id\n  t_inter : ‚àÄ ‚¶Éi j‚¶Ñ (k) (x : V i j), ‚Üëx ‚àà V i k ‚Üí (((‚Üë) : (V j i) ‚Üí (U j)) (t i j x)) ‚àà V j k\n  cocycle :\n    ‚àÄ (i j k) (x : V i j) (h : ‚Üëx ‚àà V i k),\n      -- Porting note: the underscore in the next line was `‚Üë(t i j x)`, but Lean type-mismatched\n      (((‚Üë) : (V k j) ‚Üí (U k)) (t j k ‚ü®_, t_inter k x h‚ü©)) = ((‚Üë) : (V k i) ‚Üí (U k)) (t i k ‚ü®x, h‚ü©)\n\n"}
{"name":"TopCat.GlueData.MkCore.cocycle","module":"Mathlib.Topology.Gluing","initialProofState":"self : TopCat.GlueData.MkCore\ni j k : self.J\nx : Subtype fun x => Membership.mem (self.V i j) x\nh : Membership.mem (self.V i k) ‚Üëx\n‚ä¢ Eq ‚Üë((self.t j k) ‚ü®‚Üë((self.t i j) x), ‚ãØ‚ü©) ‚Üë((self.t i k) ‚ü®‚Üëx, h‚ü©)","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A bundled topological space `U i` for each `i : J`.\n3. An open set `V i j ‚äÜ U i` for each `i j : J`.\n4. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `V i i = U i`.\n7. `t i i` is the identity.\n8. For each `x ‚àà V i j ‚à© V i k`, `t i j x ‚àà V j k`.\n9. `t j k (t i j x) = t i k x`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`.\n-/\nstructure MkCore where\n  {J : Type u}\n  U : J ‚Üí TopCat.{u}\n  V : ‚àÄ i, J ‚Üí Opens (U i)\n  t : ‚àÄ i j, (Opens.toTopCat _).obj (V i j) ‚ü∂ (Opens.toTopCat _).obj (V j i)\n  V_id : ‚àÄ i, V i i = ‚ä§\n  t_id : ‚àÄ i, ‚áë(t i i) = id\n  t_inter : ‚àÄ ‚¶Éi j‚¶Ñ (k) (x : V i j), ‚Üëx ‚àà V i k ‚Üí (((‚Üë) : (V j i) ‚Üí (U j)) (t i j x)) ‚àà V j k\n  cocycle :\n    ‚àÄ (i j k) (x : V i j) (h : ‚Üëx ‚àà V i k),\n      -- Porting note: the underscore in the next line was `‚Üë(t i j x)`, but Lean type-mismatched\n      (((‚Üë) : (V k j) ‚Üí (U k)) (t j k ‚ü®_, t_inter k x h‚ü©)) = ((‚Üë) : (V k i) ‚Üí (U k)) (t i k ‚ü®x, h‚ü©)\n\n"}
{"name":"TopCat.GlueData.MkCore.mk.inj","module":"Mathlib.Topology.Gluing","initialProofState":"J‚úù : Type u\nU‚úù : J‚úù ‚Üí TopCat\nV‚úù : (i : J‚úù) ‚Üí J‚úù ‚Üí TopologicalSpace.Opens ‚Üë(U‚úù i)\nt‚úù : (i j : J‚úù) ‚Üí Quiver.Hom ((TopologicalSpace.Opens.toTopCat (U‚úù i)).obj (V‚úù i j)) ((TopologicalSpace.Opens.toTopCat (U‚úù j)).obj (V‚úù j i))\nV_id‚úù : ‚àÄ (i : J‚úù), Eq (V‚úù i i) Top.top\nt_id‚úù : ‚àÄ (i : J‚úù), Eq (‚áë(t‚úù i i)) id\nt_inter‚úù : ‚àÄ ‚¶Éi j : J‚úù‚¶Ñ (k : J‚úù) (x : Subtype fun x => Membership.mem (V‚úù i j) x), Membership.mem (V‚úù i k) ‚Üëx ‚Üí Membership.mem (V‚úù j k) ‚Üë((t‚úù i j) x)\ncocycle‚úù : ‚àÄ (i j k : J‚úù) (x : Subtype fun x => Membership.mem (V‚úù i j) x) (h : Membership.mem (V‚úù i k) ‚Üëx), Eq ‚Üë((t‚úù j k) ‚ü®‚Üë((t‚úù i j) x), ‚ãØ‚ü©) ‚Üë((t‚úù i k) ‚ü®‚Üëx, h‚ü©)\nJ : Type u\nU : J ‚Üí TopCat\nV : (i : J) ‚Üí J ‚Üí TopologicalSpace.Opens ‚Üë(U i)\nt : (i j : J) ‚Üí Quiver.Hom ((TopologicalSpace.Opens.toTopCat (U i)).obj (V i j)) ((TopologicalSpace.Opens.toTopCat (U j)).obj (V j i))\nV_id : ‚àÄ (i : J), Eq (V i i) Top.top\nt_id : ‚àÄ (i : J), Eq (‚áë(t i i)) id\nt_inter : ‚àÄ ‚¶Éi j : J‚¶Ñ (k : J) (x : Subtype fun x => Membership.mem (V i j) x), Membership.mem (V i k) ‚Üëx ‚Üí Membership.mem (V j k) ‚Üë((t i j) x)\ncocycle : ‚àÄ (i j k : J) (x : Subtype fun x => Membership.mem (V i j) x) (h : Membership.mem (V i k) ‚Üëx), Eq ‚Üë((t j k) ‚ü®‚Üë((t i j) x), ‚ãØ‚ü©) ‚Üë((t i k) ‚ü®‚Üëx, h‚ü©)\nx‚úù : Eq (TopCat.GlueData.MkCore.mk U‚úù V‚úù t‚úù V_id‚úù t_id‚úù t_inter‚úù cocycle‚úù) (TopCat.GlueData.MkCore.mk U V t V_id t_id t_inter cocycle)\n‚ä¢ And (Eq J‚úù J) (And (HEq U‚úù U) (And (HEq V‚úù V) (HEq t‚úù t)))","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A bundled topological space `U i` for each `i : J`.\n3. An open set `V i j ‚äÜ U i` for each `i j : J`.\n4. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `V i i = U i`.\n7. `t i i` is the identity.\n8. For each `x ‚àà V i j ‚à© V i k`, `t i j x ‚àà V j k`.\n9. `t j k (t i j x) = t i k x`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`.\n-/\nstructure MkCore where\n  {J : Type u}\n  U : J ‚Üí TopCat.{u}\n  V : ‚àÄ i, J ‚Üí Opens (U i)\n  t : ‚àÄ i j, (Opens.toTopCat _).obj (V i j) ‚ü∂ (Opens.toTopCat _).obj (V j i)\n  V_id : ‚àÄ i, V i i = ‚ä§\n  t_id : ‚àÄ i, ‚áë(t i i) = id\n  t_inter : ‚àÄ ‚¶Éi j‚¶Ñ (k) (x : V i j), ‚Üëx ‚àà V i k ‚Üí (((‚Üë) : (V j i) ‚Üí (U j)) (t i j x)) ‚àà V j k\n  cocycle :\n    ‚àÄ (i j k) (x : V i j) (h : ‚Üëx ‚àà V i k),\n      -- Porting note: the underscore in the next line was `‚Üë(t i j x)`, but Lean type-mismatched\n      (((‚Üë) : (V k j) ‚Üí (U k)) (t j k ‚ü®_, t_inter k x h‚ü©)) = ((‚Üë) : (V k i) ‚Üí (U k)) (t i k ‚ü®x, h‚ü©)\n\n"}
{"name":"TopCat.GlueData.MkCore.V_id","module":"Mathlib.Topology.Gluing","initialProofState":"self : TopCat.GlueData.MkCore\ni : self.J\n‚ä¢ Eq (self.V i i) Top.top","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A bundled topological space `U i` for each `i : J`.\n3. An open set `V i j ‚äÜ U i` for each `i j : J`.\n4. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `V i i = U i`.\n7. `t i i` is the identity.\n8. For each `x ‚àà V i j ‚à© V i k`, `t i j x ‚àà V j k`.\n9. `t j k (t i j x) = t i k x`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`.\n-/\nstructure MkCore where\n  {J : Type u}\n  U : J ‚Üí TopCat.{u}\n  V : ‚àÄ i, J ‚Üí Opens (U i)\n  t : ‚àÄ i j, (Opens.toTopCat _).obj (V i j) ‚ü∂ (Opens.toTopCat _).obj (V j i)\n  V_id : ‚àÄ i, V i i = ‚ä§\n  t_id : ‚àÄ i, ‚áë(t i i) = id\n  t_inter : ‚àÄ ‚¶Éi j‚¶Ñ (k) (x : V i j), ‚Üëx ‚àà V i k ‚Üí (((‚Üë) : (V j i) ‚Üí (U j)) (t i j x)) ‚àà V j k\n  cocycle :\n    ‚àÄ (i j k) (x : V i j) (h : ‚Üëx ‚àà V i k),\n      -- Porting note: the underscore in the next line was `‚Üë(t i j x)`, but Lean type-mismatched\n      (((‚Üë) : (V k j) ‚Üí (U k)) (t j k ‚ü®_, t_inter k x h‚ü©)) = ((‚Üë) : (V k i) ‚Üí (U k)) (t i k ‚ü®x, h‚ü©)\n\n"}
{"name":"TopCat.GlueData.MkCore.mk.injEq","module":"Mathlib.Topology.Gluing","initialProofState":"J‚úù : Type u\nU‚úù : J‚úù ‚Üí TopCat\nV‚úù : (i : J‚úù) ‚Üí J‚úù ‚Üí TopologicalSpace.Opens ‚Üë(U‚úù i)\nt‚úù : (i j : J‚úù) ‚Üí Quiver.Hom ((TopologicalSpace.Opens.toTopCat (U‚úù i)).obj (V‚úù i j)) ((TopologicalSpace.Opens.toTopCat (U‚úù j)).obj (V‚úù j i))\nV_id‚úù : ‚àÄ (i : J‚úù), Eq (V‚úù i i) Top.top\nt_id‚úù : ‚àÄ (i : J‚úù), Eq (‚áë(t‚úù i i)) id\nt_inter‚úù : ‚àÄ ‚¶Éi j : J‚úù‚¶Ñ (k : J‚úù) (x : Subtype fun x => Membership.mem (V‚úù i j) x), Membership.mem (V‚úù i k) ‚Üëx ‚Üí Membership.mem (V‚úù j k) ‚Üë((t‚úù i j) x)\ncocycle‚úù : ‚àÄ (i j k : J‚úù) (x : Subtype fun x => Membership.mem (V‚úù i j) x) (h : Membership.mem (V‚úù i k) ‚Üëx), Eq ‚Üë((t‚úù j k) ‚ü®‚Üë((t‚úù i j) x), ‚ãØ‚ü©) ‚Üë((t‚úù i k) ‚ü®‚Üëx, h‚ü©)\nJ : Type u\nU : J ‚Üí TopCat\nV : (i : J) ‚Üí J ‚Üí TopologicalSpace.Opens ‚Üë(U i)\nt : (i j : J) ‚Üí Quiver.Hom ((TopologicalSpace.Opens.toTopCat (U i)).obj (V i j)) ((TopologicalSpace.Opens.toTopCat (U j)).obj (V j i))\nV_id : ‚àÄ (i : J), Eq (V i i) Top.top\nt_id : ‚àÄ (i : J), Eq (‚áë(t i i)) id\nt_inter : ‚àÄ ‚¶Éi j : J‚¶Ñ (k : J) (x : Subtype fun x => Membership.mem (V i j) x), Membership.mem (V i k) ‚Üëx ‚Üí Membership.mem (V j k) ‚Üë((t i j) x)\ncocycle : ‚àÄ (i j k : J) (x : Subtype fun x => Membership.mem (V i j) x) (h : Membership.mem (V i k) ‚Üëx), Eq ‚Üë((t j k) ‚ü®‚Üë((t i j) x), ‚ãØ‚ü©) ‚Üë((t i k) ‚ü®‚Üëx, h‚ü©)\n‚ä¢ Eq (Eq (TopCat.GlueData.MkCore.mk U‚úù V‚úù t‚úù V_id‚úù t_id‚úù t_inter‚úù cocycle‚úù) (TopCat.GlueData.MkCore.mk U V t V_id t_id t_inter cocycle)) (And (Eq J‚úù J) (And (HEq U‚úù U) (And (HEq V‚úù V) (HEq t‚úù t))))","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A bundled topological space `U i` for each `i : J`.\n3. An open set `V i j ‚äÜ U i` for each `i j : J`.\n4. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `V i i = U i`.\n7. `t i i` is the identity.\n8. For each `x ‚àà V i j ‚à© V i k`, `t i j x ‚àà V j k`.\n9. `t j k (t i j x) = t i k x`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`.\n-/\nstructure MkCore where\n  {J : Type u}\n  U : J ‚Üí TopCat.{u}\n  V : ‚àÄ i, J ‚Üí Opens (U i)\n  t : ‚àÄ i j, (Opens.toTopCat _).obj (V i j) ‚ü∂ (Opens.toTopCat _).obj (V j i)\n  V_id : ‚àÄ i, V i i = ‚ä§\n  t_id : ‚àÄ i, ‚áë(t i i) = id\n  t_inter : ‚àÄ ‚¶Éi j‚¶Ñ (k) (x : V i j), ‚Üëx ‚àà V i k ‚Üí (((‚Üë) : (V j i) ‚Üí (U j)) (t i j x)) ‚àà V j k\n  cocycle :\n    ‚àÄ (i j k) (x : V i j) (h : ‚Üëx ‚àà V i k),\n      -- Porting note: the underscore in the next line was `‚Üë(t i j x)`, but Lean type-mismatched\n      (((‚Üë) : (V k j) ‚Üí (U k)) (t j k ‚ü®_, t_inter k x h‚ü©)) = ((‚Üë) : (V k i) ‚Üí (U k)) (t i k ‚ü®x, h‚ü©)\n\n"}
{"name":"TopCat.GlueData.MkCore.t_inter","module":"Mathlib.Topology.Gluing","initialProofState":"self : TopCat.GlueData.MkCore\ni j k : self.J\nx : Subtype fun x => Membership.mem (self.V i j) x\na‚úù : Membership.mem (self.V i k) ‚Üëx\n‚ä¢ Membership.mem (self.V j k) ‚Üë((self.t i j) x)","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A bundled topological space `U i` for each `i : J`.\n3. An open set `V i j ‚äÜ U i` for each `i j : J`.\n4. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `V i i = U i`.\n7. `t i i` is the identity.\n8. For each `x ‚àà V i j ‚à© V i k`, `t i j x ‚àà V j k`.\n9. `t j k (t i j x) = t i k x`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`.\n-/\nstructure MkCore where\n  {J : Type u}\n  U : J ‚Üí TopCat.{u}\n  V : ‚àÄ i, J ‚Üí Opens (U i)\n  t : ‚àÄ i j, (Opens.toTopCat _).obj (V i j) ‚ü∂ (Opens.toTopCat _).obj (V j i)\n  V_id : ‚àÄ i, V i i = ‚ä§\n  t_id : ‚àÄ i, ‚áë(t i i) = id\n  t_inter : ‚àÄ ‚¶Éi j‚¶Ñ (k) (x : V i j), ‚Üëx ‚àà V i k ‚Üí (((‚Üë) : (V j i) ‚Üí (U j)) (t i j x)) ‚àà V j k\n  cocycle :\n    ‚àÄ (i j k) (x : V i j) (h : ‚Üëx ‚àà V i k),\n      -- Porting note: the underscore in the next line was `‚Üë(t i j x)`, but Lean type-mismatched\n      (((‚Üë) : (V k j) ‚Üí (U k)) (t j k ‚ü®_, t_inter k x h‚ü©)) = ((‚Üë) : (V k i) ‚Üí (U k)) (t i k ‚ü®x, h‚ü©)\n\n"}
{"name":"TopCat.GlueData.MkCore.t_id","module":"Mathlib.Topology.Gluing","initialProofState":"self : TopCat.GlueData.MkCore\ni : self.J\n‚ä¢ Eq (‚áë(self.t i i)) id","decl":"/-- A family of gluing data consists of\n1. An index type `J`\n2. A bundled topological space `U i` for each `i : J`.\n3. An open set `V i j ‚äÜ U i` for each `i j : J`.\n4. A transition map `t i j : V i j ‚ü∂ V j i` for each `i j : Œπ`.\nsuch that\n6. `V i i = U i`.\n7. `t i i` is the identity.\n8. For each `x ‚àà V i j ‚à© V i k`, `t i j x ‚àà V j k`.\n9. `t j k (t i j x) = t i k x`.\n\nWe can then glue the topological spaces `U i` together by identifying `V i j` with `V j i`.\n-/\nstructure MkCore where\n  {J : Type u}\n  U : J ‚Üí TopCat.{u}\n  V : ‚àÄ i, J ‚Üí Opens (U i)\n  t : ‚àÄ i j, (Opens.toTopCat _).obj (V i j) ‚ü∂ (Opens.toTopCat _).obj (V j i)\n  V_id : ‚àÄ i, V i i = ‚ä§\n  t_id : ‚àÄ i, ‚áë(t i i) = id\n  t_inter : ‚àÄ ‚¶Éi j‚¶Ñ (k) (x : V i j), ‚Üëx ‚àà V i k ‚Üí (((‚Üë) : (V j i) ‚Üí (U j)) (t i j x)) ‚àà V j k\n  cocycle :\n    ‚àÄ (i j k) (x : V i j) (h : ‚Üëx ‚àà V i k),\n      -- Porting note: the underscore in the next line was `‚Üë(t i j x)`, but Lean type-mismatched\n      (((‚Üë) : (V k j) ‚Üí (U k)) (t j k ‚ü®_, t_inter k x h‚ü©)) = ((‚Üë) : (V k i) ‚Üí (U k)) (t i k ‚ü®x, h‚ü©)\n\n"}
{"name":"TopCat.GlueData.MkCore.t_inv","module":"Mathlib.Topology.Gluing","initialProofState":"h : TopCat.GlueData.MkCore\ni j : h.J\nx : Subtype fun x => Membership.mem (h.V j i) x\n‚ä¢ Eq ((h.t i j) ((h.t j i) x)) x","decl":"theorem MkCore.t_inv (h : MkCore) (i j : h.J) (x : h.V j i) : h.t i j ((h.t j i) x) = x := by\n  have := h.cocycle j i j x ?_\n  ¬∑ rw [h.t_id] at this\n    ¬∑ convert Subtype.eq this\n  rw [h.V_id]\n  trivial\n\n"}
{"name":"TopCat.GlueData.instIsIsoT","module":"Mathlib.Topology.Gluing","initialProofState":"h : TopCat.GlueData.MkCore\ni j : h.J\n‚ä¢ CategoryTheory.IsIso (h.t i j)","decl":"instance (h : MkCore.{u}) (i j : h.J) : IsIso (h.t i j) := by\n  use h.t j i; constructor <;> ext1; exacts [h.t_inv _ _ _, h.t_inv _ _ _]\n\n"}
{"name":"TopCat.GlueData.ofOpenSubsets_toGlueData_t","module":"Mathlib.Topology.Gluing","initialProofState":"Œ± : Type u\ninst‚úù : TopologicalSpace Œ±\nJ : Type u\nU : J ‚Üí TopologicalSpace.Opens Œ±\ni j : (TopCat.GlueData.MkCore.mk (fun i => (TopologicalSpace.Opens.toTopCat (TopCat.of Œ±)).obj (U i)) (fun x j => (TopologicalSpace.Opens.map (U x).inclusion').obj (U j)) (fun i j => { toFun := fun x => ‚ü®‚ü®‚Üë‚Üëx, ‚ãØ‚ü©, ‚ãØ‚ü©, continuous_toFun := ‚ãØ }) ‚ãØ ‚ãØ ‚ãØ ‚ãØ).J\n‚ä¢ Eq ((TopCat.GlueData.ofOpenSubsets U).t i j) { toFun := fun x => ‚ü®‚ü®‚Üë‚Üëx, ‚ãØ‚ü©, ‚ãØ‚ü©, continuous_toFun := ‚ãØ }","decl":"/-- We may construct a glue data from a family of open sets. -/\n@[simps! toGlueData_J toGlueData_U toGlueData_V toGlueData_t toGlueData_f]\ndef ofOpenSubsets : TopCat.GlueData.{u} :=\n  mk'.{u}\n    { J\n      U := fun i => (Opens.toTopCat <| TopCat.of Œ±).obj (U i)\n      V := fun _ j => (Opens.map <| Opens.inclusion' _).obj (U j)\n      t := fun i j => ‚ü®fun x => ‚ü®‚ü®x.1.1, x.2‚ü©, x.1.2‚ü©, by fun_prop‚ü©\n      V_id := fun i => by ext; simp\n      t_id := fun i => by ext; rfl\n      t_inter := fun _ _ _ _ hx => hx\n      cocycle := fun _ _ _ _ _ => rfl }\n\n"}
{"name":"TopCat.GlueData.ofOpenSubsets_toGlueData_f","module":"Mathlib.Topology.Gluing","initialProofState":"Œ± : Type u\ninst‚úù : TopologicalSpace Œ±\nJ : Type u\nU : J ‚Üí TopologicalSpace.Opens Œ±\ni j : (TopCat.GlueData.MkCore.mk (fun i => (TopologicalSpace.Opens.toTopCat (TopCat.of Œ±)).obj (U i)) (fun x j => (TopologicalSpace.Opens.map (U x).inclusion').obj (U j)) (fun i j => { toFun := fun x => ‚ü®‚ü®‚Üë‚Üëx, ‚ãØ‚ü©, ‚ãØ‚ü©, continuous_toFun := ‚ãØ }) ‚ãØ ‚ãØ ‚ãØ ‚ãØ).J\n‚ä¢ Eq ((TopCat.GlueData.ofOpenSubsets U).f i j) ((TopologicalSpace.Opens.map (U i).inclusion').obj (U j)).inclusion'","decl":"/-- We may construct a glue data from a family of open sets. -/\n@[simps! toGlueData_J toGlueData_U toGlueData_V toGlueData_t toGlueData_f]\ndef ofOpenSubsets : TopCat.GlueData.{u} :=\n  mk'.{u}\n    { J\n      U := fun i => (Opens.toTopCat <| TopCat.of Œ±).obj (U i)\n      V := fun _ j => (Opens.map <| Opens.inclusion' _).obj (U j)\n      t := fun i j => ‚ü®fun x => ‚ü®‚ü®x.1.1, x.2‚ü©, x.1.2‚ü©, by fun_prop‚ü©\n      V_id := fun i => by ext; simp\n      t_id := fun i => by ext; rfl\n      t_inter := fun _ _ _ _ hx => hx\n      cocycle := fun _ _ _ _ _ => rfl }\n\n"}
{"name":"TopCat.GlueData.ofOpenSubsets_toGlueData_U","module":"Mathlib.Topology.Gluing","initialProofState":"Œ± : Type u\ninst‚úù : TopologicalSpace Œ±\nJ : Type u\nU : J ‚Üí TopologicalSpace.Opens Œ±\na‚úù : (TopCat.GlueData.MkCore.mk (fun i => (TopologicalSpace.Opens.toTopCat (TopCat.of Œ±)).obj (U i)) (fun x j => (TopologicalSpace.Opens.map (U x).inclusion').obj (U j)) (fun i j => { toFun := fun x => ‚ü®‚ü®‚Üë‚Üëx, ‚ãØ‚ü©, ‚ãØ‚ü©, continuous_toFun := ‚ãØ }) ‚ãØ ‚ãØ ‚ãØ ‚ãØ).J\n‚ä¢ Eq ((TopCat.GlueData.ofOpenSubsets U).U a‚úù) ((TopologicalSpace.Opens.toTopCat (TopCat.of Œ±)).obj (U a‚úù))","decl":"/-- We may construct a glue data from a family of open sets. -/\n@[simps! toGlueData_J toGlueData_U toGlueData_V toGlueData_t toGlueData_f]\ndef ofOpenSubsets : TopCat.GlueData.{u} :=\n  mk'.{u}\n    { J\n      U := fun i => (Opens.toTopCat <| TopCat.of Œ±).obj (U i)\n      V := fun _ j => (Opens.map <| Opens.inclusion' _).obj (U j)\n      t := fun i j => ‚ü®fun x => ‚ü®‚ü®x.1.1, x.2‚ü©, x.1.2‚ü©, by fun_prop‚ü©\n      V_id := fun i => by ext; simp\n      t_id := fun i => by ext; rfl\n      t_inter := fun _ _ _ _ hx => hx\n      cocycle := fun _ _ _ _ _ => rfl }\n\n"}
{"name":"TopCat.GlueData.ofOpenSubsets_toGlueData_V","module":"Mathlib.Topology.Gluing","initialProofState":"Œ± : Type u\ninst‚úù : TopologicalSpace Œ±\nJ : Type u\nU : J ‚Üí TopologicalSpace.Opens Œ±\ni : Prod (TopCat.GlueData.MkCore.mk (fun i => (TopologicalSpace.Opens.toTopCat (TopCat.of Œ±)).obj (U i)) (fun x j => (TopologicalSpace.Opens.map (U x).inclusion').obj (U j)) (fun i j => { toFun := fun x => ‚ü®‚ü®‚Üë‚Üëx, ‚ãØ‚ü©, ‚ãØ‚ü©, continuous_toFun := ‚ãØ }) ‚ãØ ‚ãØ ‚ãØ ‚ãØ).J (TopCat.GlueData.MkCore.mk (fun i => (TopologicalSpace.Opens.toTopCat (TopCat.of Œ±)).obj (U i)) (fun x j => (TopologicalSpace.Opens.map (U x).inclusion').obj (U j)) (fun i j => { toFun := fun x => ‚ü®‚ü®‚Üë‚Üëx, ‚ãØ‚ü©, ‚ãØ‚ü©, continuous_toFun := ‚ãØ }) ‚ãØ ‚ãØ ‚ãØ ‚ãØ).J\n‚ä¢ Eq ((TopCat.GlueData.ofOpenSubsets U).V i) ((TopologicalSpace.Opens.toTopCat ((TopologicalSpace.Opens.toTopCat (TopCat.of Œ±)).obj (U i.1))).obj ((TopologicalSpace.Opens.map (U i.1).inclusion').obj (U i.2)))","decl":"/-- We may construct a glue data from a family of open sets. -/\n@[simps! toGlueData_J toGlueData_U toGlueData_V toGlueData_t toGlueData_f]\ndef ofOpenSubsets : TopCat.GlueData.{u} :=\n  mk'.{u}\n    { J\n      U := fun i => (Opens.toTopCat <| TopCat.of Œ±).obj (U i)\n      V := fun _ j => (Opens.map <| Opens.inclusion' _).obj (U j)\n      t := fun i j => ‚ü®fun x => ‚ü®‚ü®x.1.1, x.2‚ü©, x.1.2‚ü©, by fun_prop‚ü©\n      V_id := fun i => by ext; simp\n      t_id := fun i => by ext; rfl\n      t_inter := fun _ _ _ _ hx => hx\n      cocycle := fun _ _ _ _ _ => rfl }\n\n"}
{"name":"TopCat.GlueData.ofOpenSubsets_toGlueData_J","module":"Mathlib.Topology.Gluing","initialProofState":"Œ± : Type u\ninst‚úù : TopologicalSpace Œ±\nJ : Type u\nU : J ‚Üí TopologicalSpace.Opens Œ±\n‚ä¢ Eq (TopCat.GlueData.ofOpenSubsets U).J J","decl":"/-- We may construct a glue data from a family of open sets. -/\n@[simps! toGlueData_J toGlueData_U toGlueData_V toGlueData_t toGlueData_f]\ndef ofOpenSubsets : TopCat.GlueData.{u} :=\n  mk'.{u}\n    { J\n      U := fun i => (Opens.toTopCat <| TopCat.of Œ±).obj (U i)\n      V := fun _ j => (Opens.map <| Opens.inclusion' _).obj (U j)\n      t := fun i j => ‚ü®fun x => ‚ü®‚ü®x.1.1, x.2‚ü©, x.1.2‚ü©, by fun_prop‚ü©\n      V_id := fun i => by ext; simp\n      t_id := fun i => by ext; rfl\n      t_inter := fun _ _ _ _ hx => hx\n      cocycle := fun _ _ _ _ _ => rfl }\n\n"}
{"name":"TopCat.GlueData.Œπ_fromOpenSubsetsGlue","module":"Mathlib.Topology.Gluing","initialProofState":"Œ± : Type u\ninst‚úù : TopologicalSpace Œ±\nJ : Type u\nU : J ‚Üí TopologicalSpace.Opens Œ±\ni : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((TopCat.GlueData.ofOpenSubsets U).Œπ i) (TopCat.GlueData.fromOpenSubsetsGlue U)) (U i).inclusion'","decl":"@[simp, elementwise nosimp]\ntheorem Œπ_fromOpenSubsetsGlue (i : J) :\n    (ofOpenSubsets U).toGlueData.Œπ i ‚â´ fromOpenSubsetsGlue U = Opens.inclusion' _ :=\n  Multicoequalizer.œÄ_desc _ _ _ _ _\n\n"}
{"name":"TopCat.GlueData.Œπ_fromOpenSubsetsGlue_apply","module":"Mathlib.Topology.Gluing","initialProofState":"Œ± : Type u\ninst‚úù : TopologicalSpace Œ±\nJ : Type u\nU : J ‚Üí TopologicalSpace.Opens Œ±\ni : J\nx : (CategoryTheory.forget TopCat).obj ((TopCat.GlueData.ofOpenSubsets U).U i)\n‚ä¢ Eq ((TopCat.GlueData.fromOpenSubsetsGlue U) (((TopCat.GlueData.ofOpenSubsets U).Œπ i) x)) ((U i).inclusion' x)","decl":"@[simp, elementwise nosimp]\ntheorem Œπ_fromOpenSubsetsGlue (i : J) :\n    (ofOpenSubsets U).toGlueData.Œπ i ‚â´ fromOpenSubsetsGlue U = Opens.inclusion' _ :=\n  Multicoequalizer.œÄ_desc _ _ _ _ _\n\n"}
{"name":"TopCat.GlueData.fromOpenSubsetsGlue_injective","module":"Mathlib.Topology.Gluing","initialProofState":"Œ± : Type u\ninst‚úù : TopologicalSpace Œ±\nJ : Type u\nU : J ‚Üí TopologicalSpace.Opens Œ±\n‚ä¢ Function.Injective ‚áë(TopCat.GlueData.fromOpenSubsetsGlue U)","decl":"theorem fromOpenSubsetsGlue_injective : Function.Injective (fromOpenSubsetsGlue U) := by\n  intro x y e\n  obtain ‚ü®i, ‚ü®x, hx‚ü©, rfl‚ü© := (ofOpenSubsets U).Œπ_jointly_surjective x\n  obtain ‚ü®j, ‚ü®y, hy‚ü©, rfl‚ü© := (ofOpenSubsets U).Œπ_jointly_surjective y\n  -- see the porting note on `Œπ_fromOpenSubsetsGlue`\n  rw [Œπ_fromOpenSubsetsGlue_apply, Œπ_fromOpenSubsetsGlue_apply] at e\n  change x = y at e\n  subst e\n  rw [(ofOpenSubsets U).Œπ_eq_iff_rel]\n  exact ‚ü®‚ü®‚ü®x, hx‚ü©, hy‚ü©, rfl, rfl‚ü©\n\n"}
{"name":"TopCat.GlueData.fromOpenSubsetsGlue_isOpenMap","module":"Mathlib.Topology.Gluing","initialProofState":"Œ± : Type u\ninst‚úù : TopologicalSpace Œ±\nJ : Type u\nU : J ‚Üí TopologicalSpace.Opens Œ±\n‚ä¢ IsOpenMap ‚áë(TopCat.GlueData.fromOpenSubsetsGlue U)","decl":"theorem fromOpenSubsetsGlue_isOpenMap : IsOpenMap (fromOpenSubsetsGlue U) := by\n  intro s hs\n  rw [(ofOpenSubsets U).isOpen_iff] at hs\n  rw [isOpen_iff_forall_mem_open]\n  rintro _ ‚ü®x, hx, rfl‚ü©\n  obtain ‚ü®i, ‚ü®x, hx'‚ü©, rfl‚ü© := (ofOpenSubsets U).Œπ_jointly_surjective x\n  use fromOpenSubsetsGlue U '' s ‚à© Set.range (@Opens.inclusion' (TopCat.of Œ±) (U i))\n  use Set.inter_subset_left\n  constructor\n  ¬∑ rw [‚Üê Set.image_preimage_eq_inter_range]\n    apply (Opens.isOpenEmbedding (X := TopCat.of Œ±) (U i)).isOpenMap\n    convert hs i using 1\n    erw [‚Üê Œπ_fromOpenSubsetsGlue, coe_comp, Set.preimage_comp]\n    congr! 1\n    exact Set.preimage_image_eq _ (fromOpenSubsetsGlue_injective U)\n  ¬∑ refine ‚ü®Set.mem_image_of_mem _ hx, ?_‚ü©\n    rw [Œπ_fromOpenSubsetsGlue_apply]\n    exact Set.mem_range_self _\n\n"}
{"name":"TopCat.GlueData.fromOpenSubsetsGlue_isOpenEmbedding","module":"Mathlib.Topology.Gluing","initialProofState":"Œ± : Type u\ninst‚úù : TopologicalSpace Œ±\nJ : Type u\nU : J ‚Üí TopologicalSpace.Opens Œ±\n‚ä¢ Topology.IsOpenEmbedding ‚áë(TopCat.GlueData.fromOpenSubsetsGlue U)","decl":"theorem fromOpenSubsetsGlue_isOpenEmbedding : IsOpenEmbedding (fromOpenSubsetsGlue U) :=\n  .of_continuous_injective_isOpenMap (ContinuousMap.continuous_toFun _)\n    (fromOpenSubsetsGlue_injective U) (fromOpenSubsetsGlue_isOpenMap U)\n\n"}
{"name":"TopCat.GlueData.fromOpenSubsetsGlue_openEmbedding","module":"Mathlib.Topology.Gluing","initialProofState":"Œ± : Type u\ninst‚úù : TopologicalSpace Œ±\nJ : Type u\nU : J ‚Üí TopologicalSpace.Opens Œ±\n‚ä¢ Topology.IsOpenEmbedding ‚áë(TopCat.GlueData.fromOpenSubsetsGlue U)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias fromOpenSubsetsGlue_openEmbedding := fromOpenSubsetsGlue_isOpenEmbedding\n\n"}
{"name":"TopCat.GlueData.range_fromOpenSubsetsGlue","module":"Mathlib.Topology.Gluing","initialProofState":"Œ± : Type u\ninst‚úù : TopologicalSpace Œ±\nJ : Type u\nU : J ‚Üí TopologicalSpace.Opens Œ±\n‚ä¢ Eq (Set.range ‚áë(TopCat.GlueData.fromOpenSubsetsGlue U)) (Set.iUnion fun i => ‚Üë(U i))","decl":"theorem range_fromOpenSubsetsGlue : Set.range (fromOpenSubsetsGlue U) = ‚ãÉ i, (U i : Set Œ±) := by\n  ext\n  constructor\n  ¬∑ rintro ‚ü®x, rfl‚ü©\n    obtain ‚ü®i, ‚ü®x, hx'‚ü©, rfl‚ü© := (ofOpenSubsets U).Œπ_jointly_surjective x\n    rw [Œπ_fromOpenSubsetsGlue_apply]\n    exact Set.subset_iUnion _ i hx'\n  ¬∑ rintro ‚ü®_, ‚ü®i, rfl‚ü©, hx‚ü©\n    rename_i x\n    exact ‚ü®(ofOpenSubsets U).toGlueData.Œπ i ‚ü®x, hx‚ü©, Œπ_fromOpenSubsetsGlue_apply _ _ _‚ü©\n\n"}
