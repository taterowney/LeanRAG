{"name":"SSet.Truncated.rightExtensionInclusion_left","module":"Mathlib.AlgebraicTopology.SimplicialSet.Coskeletal","initialProofState":"X : SSet\nn : Nat\n‚ä¢ Eq (SSet.Truncated.rightExtensionInclusion X n).left X","decl":"/-- The identity natural transformation exhibits a simplicial set as a right extension of its\nrestriction along `(Truncated.inclusion (n := n)).op`.-/\n@[simps!]\ndef rightExtensionInclusion (X : SSet.{u}) (n : ‚Ñï) :\n    RightExtension (Truncated.inclusion (n := n)).op\n      ((Truncated.inclusion n).op ‚ãô X) := RightExtension.mk _ (ùüô _)\n\n"}
{"name":"SSet.Truncated.rightExtensionInclusion_hom_app","module":"Mathlib.AlgebraicTopology.SimplicialSet.Coskeletal","initialProofState":"X‚úù : SSet\nn : Nat\nX : Opposite (SimplexCategory.Truncated n)\na‚úù : ((SimplexCategory.Truncated.inclusion n).op.comp X‚úù).obj X\n‚ä¢ Eq ((SSet.Truncated.rightExtensionInclusion X‚úù n).hom.app X a‚úù) a‚úù","decl":"/-- The identity natural transformation exhibits a simplicial set as a right extension of its\nrestriction along `(Truncated.inclusion (n := n)).op`.-/\n@[simps!]\ndef rightExtensionInclusion (X : SSet.{u}) (n : ‚Ñï) :\n    RightExtension (Truncated.inclusion (n := n)).op\n      ((Truncated.inclusion n).op ‚ãô X) := RightExtension.mk _ (ùüô _)\n\n"}
{"name":"SSet.Truncated.rightExtensionInclusion_right_as","module":"Mathlib.AlgebraicTopology.SimplicialSet.Coskeletal","initialProofState":"X : SSet\nn : Nat\n‚ä¢ Eq (SSet.Truncated.rightExtensionInclusion X n).right.as PUnit.unit","decl":"/-- The identity natural transformation exhibits a simplicial set as a right extension of its\nrestriction along `(Truncated.inclusion (n := n)).op`.-/\n@[simps!]\ndef rightExtensionInclusion (X : SSet.{u}) (n : ‚Ñï) :\n    RightExtension (Truncated.inclusion (n := n)).op\n      ((Truncated.inclusion n).op ‚ãô X) := RightExtension.mk _ (ùüô _)\n\n"}
{"name":"SSet.StrictSegal.isPointwiseRightKanExtensionAt.fac_aux‚ÇÅ","module":"Mathlib.AlgebraicTopology.SimplicialSet.Coskeletal","initialProofState":"X : SSet\ninst‚úù : X.StrictSegal\nn : Nat\ns : CategoryTheory.Limits.Cone ((CategoryTheory.StructuredArrow.proj { unop := SimplexCategory.mk n } (SimplexCategory.Truncated.inclusion 2).op).comp ((SimplexCategory.Truncated.inclusion 2).op.comp X))\nx : s.pt\ni : Nat\nhi : LT.lt i n\n‚ä¢ Eq (X.map (SimplexCategory.mkOfSucc ‚ü®i, hi‚ü©).op (SSet.StrictSegal.isPointwiseRightKanExtensionAt.lift s x)) (s.œÄ.app (SSet.StrictSegal.isPointwiseRightKanExtensionAt.strArrowMk‚ÇÇ (SimplexCategory.mkOfSucc ‚ü®i, hi‚ü©) ‚ãØ) x)","decl":"lemma fac_aux‚ÇÅ {n : ‚Ñï}\n    (s : Cone (proj (op [n]) (Truncated.inclusion 2).op ‚ãô (Truncated.inclusion 2).op ‚ãô X))\n    (x : s.pt) (i : ‚Ñï) (hi : i < n) :\n    X.map (mkOfSucc ‚ü®i, hi‚ü©).op (lift s x) =\n      s.œÄ.app (strArrowMk‚ÇÇ (mkOfSucc ‚ü®i, hi‚ü©) (by omega)) x := by\n  dsimp [lift]\n  rw [spineToSimplex_arrow]\n  rfl\n\n"}
{"name":"SSet.StrictSegal.isPointwiseRightKanExtensionAt.fac_aux‚ÇÇ","module":"Mathlib.AlgebraicTopology.SimplicialSet.Coskeletal","initialProofState":"X : SSet\ninst‚úù : X.StrictSegal\nn : Nat\ns : CategoryTheory.Limits.Cone ((CategoryTheory.StructuredArrow.proj { unop := SimplexCategory.mk n } (SimplexCategory.Truncated.inclusion 2).op).comp ((SimplexCategory.Truncated.inclusion 2).op.comp X))\nx : s.pt\ni j : Nat\nhij : LE.le i j\nhj : LE.le j n\n‚ä¢ Eq (X.map (SimplexCategory.mkOfLe ‚ü®i, ‚ãØ‚ü© ‚ü®j, ‚ãØ‚ü© hij).op (SSet.StrictSegal.isPointwiseRightKanExtensionAt.lift s x)) (s.œÄ.app (SSet.StrictSegal.isPointwiseRightKanExtensionAt.strArrowMk‚ÇÇ (SimplexCategory.mkOfLe ‚ü®i, ‚ãØ‚ü© ‚ü®j, ‚ãØ‚ü© hij) ‚ãØ) x)","decl":"lemma fac_aux‚ÇÇ {n : ‚Ñï}\n    (s : Cone (proj (op [n]) (Truncated.inclusion 2).op ‚ãô (Truncated.inclusion 2).op ‚ãô X))\n    (x : s.pt) (i j : ‚Ñï) (hij : i ‚â§ j) (hj : j ‚â§ n) :\n    X.map (mkOfLe ‚ü®i, by omega‚ü© ‚ü®j, by omega‚ü© hij).op (lift s x) =\n      s.œÄ.app (strArrowMk‚ÇÇ (mkOfLe ‚ü®i, by omega‚ü© ‚ü®j, by omega‚ü© hij) (by omega)) x := by\n  obtain ‚ü®k, hk‚ü© := Nat.le.dest hij\n  revert i j\n  induction k with\n  | zero =>\n      rintro i j hij hj hik\n      obtain rfl : i = j := by omega\n      have : mkOfLe ‚ü®i, Nat.lt_add_one_of_le hj‚ü© ‚ü®i, Nat.lt_add_one_of_le hj‚ü© (by omega) =\n        [1].const [0] 0 ‚â´ [0].const [n] ‚ü®i, Nat.lt_add_one_of_le hj‚ü© := Hom.ext_one_left _ _\n      rw [this]\n      let Œ± : (strArrowMk‚ÇÇ ([0].const [n] ‚ü®i, Nat.lt_add_one_of_le hj‚ü©) (by omega)) ‚ü∂\n        (strArrowMk‚ÇÇ ([1].const [0] 0 ‚â´ [0].const [n] ‚ü®i, Nat.lt_add_one_of_le hj‚ü©) (by omega)) :=\n            StructuredArrow.homMk (([1].const [0] 0).op) (by simp; rfl)\n      have nat := congr_fun (s.œÄ.naturality Œ±) x\n      dsimp only [Fin.val_zero, Nat.add_zero, id_eq, Int.reduceNeg, Int.Nat.cast_ofNat_Int,\n        Int.reduceAdd, Fin.eta, comp_obj, StructuredArrow.proj_obj, op_obj, const_obj_obj,\n        const_obj_map, types_comp_apply, types_id_apply, Functor.comp_map, StructuredArrow.proj_map,\n        op_map] at nat\n      rw [nat, op_comp, Functor.map_comp]\n      simp only [types_comp_apply]\n      refine congrArg (X.map ([1].const [0] 0).op) ?_\n      unfold strArrowMk‚ÇÇ\n      rw [lift, StrictSegal.spineToSimplex_vertex]\n      congr\n  | succ k hk =>\n      intro i j hij hj hik\n      let Œ± := strArrowMk‚ÇÇ (mkOfLeComp (n := n) ‚ü®i, by omega‚ü© ‚ü®i + k, by omega‚ü©\n          ‚ü®j, by omega‚ü© (by simp)\n        (by simp only [Fin.mk_le_mk]; omega)) (by rfl)\n      let Œ±‚ÇÄ := strArrowMk‚ÇÇ (mkOfLe (n := n) ‚ü®i + k, by omega‚ü© ‚ü®j, by omega‚ü©\n        (by simp only [Fin.mk_le_mk]; omega)) (by simp)\n      let Œ±‚ÇÅ := strArrowMk‚ÇÇ (mkOfLe (n := n) ‚ü®i, by omega‚ü© ‚ü®j, by omega‚ü©\n        (by simp only [Fin.mk_le_mk]; omega)) (by simp)\n      let Œ±‚ÇÇ := strArrowMk‚ÇÇ (mkOfLe (n := n) ‚ü®i, by omega‚ü© ‚ü®i + k, by omega‚ü© (by simp)) (by simp)\n      let Œ≤‚ÇÄ : Œ± ‚ü∂ Œ±‚ÇÄ := StructuredArrow.homMk ((mkOfSucc 1).op) (Quiver.Hom.unop_inj\n        (by ext x; fin_cases x <;> rfl))\n      let Œ≤‚ÇÅ : Œ± ‚ü∂ Œ±‚ÇÅ := StructuredArrow.homMk ((Œ¥ 1).op) (Quiver.Hom.unop_inj\n        (by ext x; fin_cases x <;> rfl))\n      let Œ≤‚ÇÇ : Œ± ‚ü∂ Œ±‚ÇÇ := StructuredArrow.homMk ((mkOfSucc 0).op) (Quiver.Hom.unop_inj\n        (by ext x; fin_cases x <;> rfl))\n      have h‚ÇÄ : X.map Œ±‚ÇÄ.hom (lift s x) = s.œÄ.app Œ±‚ÇÄ x := by\n        obtain rfl : j = (i + k) + 1 := by omega\n        exact fac_aux‚ÇÅ _ _ _ _ (by omega)\n      have h‚ÇÇ : X.map Œ±‚ÇÇ.hom (lift s x) = s.œÄ.app Œ±‚ÇÇ x :=\n        hk i (i + k) (by simp) (by omega) rfl\n      change X.map Œ±‚ÇÅ.hom (lift s x) = s.œÄ.app Œ±‚ÇÅ x\n      have : X.map Œ±.hom (lift s x) = s.œÄ.app Œ± x := by\n        apply StrictSegal.spineInjective\n        apply Path.ext'\n        intro t\n        dsimp only [spineEquiv]\n        rw [Equiv.coe_fn_mk, spine_arrow, spine_arrow,\n            ‚Üê FunctorToTypes.map_comp_apply]\n        match t with\n        | 0 =>\n            have : Œ±.hom ‚â´ (mkOfSucc 0).op = Œ±‚ÇÇ.hom :=\n              Quiver.Hom.unop_inj (by ext x ; fin_cases x <;> rfl)\n            rw [this, h‚ÇÇ, ‚Üê congr_fun (s.w Œ≤‚ÇÇ) x]\n            rfl\n        | 1 =>\n            have : Œ±.hom ‚â´ (mkOfSucc 1).op = Œ±‚ÇÄ.hom :=\n              Quiver.Hom.unop_inj (by ext x ; fin_cases x <;> rfl)\n            rw [this, h‚ÇÄ, ‚Üê congr_fun (s.w Œ≤‚ÇÄ) x]\n            rfl\n      rw [‚Üê StructuredArrow.w Œ≤‚ÇÅ, FunctorToTypes.map_comp_apply, this, ‚Üê s.w Œ≤‚ÇÅ]\n      dsimp\n\n"}
{"name":"SSet.StrictSegal.isPointwiseRightKanExtensionAt.fac_aux‚ÇÉ","module":"Mathlib.AlgebraicTopology.SimplicialSet.Coskeletal","initialProofState":"X : SSet\ninst‚úù : X.StrictSegal\nn : Nat\ns : CategoryTheory.Limits.Cone ((CategoryTheory.StructuredArrow.proj { unop := SimplexCategory.mk n } (SimplexCategory.Truncated.inclusion 2).op).comp ((SimplexCategory.Truncated.inclusion 2).op.comp X))\nx : s.pt\nœÜ : Quiver.Hom (SimplexCategory.mk 1) (SimplexCategory.mk n)\n‚ä¢ Eq (X.map œÜ.op (SSet.StrictSegal.isPointwiseRightKanExtensionAt.lift s x)) (s.œÄ.app (SSet.StrictSegal.isPointwiseRightKanExtensionAt.strArrowMk‚ÇÇ œÜ ‚ãØ) x)","decl":"lemma fac_aux‚ÇÉ {n : ‚Ñï}\n    (s : Cone (proj (op [n]) (Truncated.inclusion 2).op ‚ãô (Truncated.inclusion 2).op ‚ãô X))\n    (x : s.pt) (œÜ : [1] ‚ü∂ [n]) :\n    X.map œÜ.op (lift s x) = s.œÄ.app (strArrowMk‚ÇÇ œÜ (by omega)) x := by\n  obtain ‚ü®i, j, hij, rfl‚ü© : ‚àÉ i j hij, œÜ = mkOfLe i j hij :=\n    ‚ü®œÜ.toOrderHom 0, œÜ.toOrderHom 1, œÜ.toOrderHom.monotone (by simp),\n      Hom.ext_one_left _ _ rfl rfl‚ü©\n  exact fac_aux‚ÇÇ _ _ _ _ _ _ (by omega)\n\n"}
{"name":"SSet.StrictSegal.isRightKanExtension","module":"Mathlib.AlgebraicTopology.SimplicialSet.Coskeletal","initialProofState":"X : SSet\ninst‚úù : X.StrictSegal\n‚ä¢ CategoryTheory.Functor.IsRightKanExtension X (CategoryTheory.CategoryStruct.id ((SimplexCategory.Truncated.inclusion 2).op.comp X))","decl":"theorem isRightKanExtension :\n    X.IsRightKanExtension (ùüô ((inclusion 2).op ‚ãô X)) :=\n  RightExtension.IsPointwiseRightKanExtension.isRightKanExtension\n    (isPointwiseRightKanExtension X)\n\n"}
{"name":"SSet.StrictSegal.isCoskeletal","module":"Mathlib.AlgebraicTopology.SimplicialSet.Coskeletal","initialProofState":"X : SSet\ninst‚úù : X.StrictSegal\n‚ä¢ CategoryTheory.SimplicialObject.IsCoskeletal X 2","decl":"/-- When `X` is `StrictSegal`, `X` is 2-coskeletal. -/\ninstance isCoskeletal : SimplicialObject.IsCoskeletal X 2 where\n  isRightKanExtension := isRightKanExtension X\n\n"}
