{"name":"Dynamics.dynEntourage_eq_inter_Ico","module":"Mathlib.Dynamics.TopologicalEntropy.DynamicalEntourage","initialProofState":"X : Type u_1\nT : X → X\nU : Set (Prod X X)\nn : Nat\n⊢ Eq (Dynamics.dynEntourage T U n) (Set.iInter fun k => Set.preimage (Nat.iterate (Prod.map T T) ↑k) U)","decl":"lemma dynEntourage_eq_inter_Ico (T : X → X) (U : Set (X × X)) (n : ℕ) :\n    dynEntourage T U n = ⋂ k : Ico 0 n, (map T T)^[k] ⁻¹' U := by\n  simp [dynEntourage]\n\n"}
{"name":"Dynamics.mem_dynEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.DynamicalEntourage","initialProofState":"X : Type u_1\nT : X → X\nU : Set (Prod X X)\nn : Nat\nx y : X\n⊢ Iff (Membership.mem (Dynamics.dynEntourage T U n) { fst := x, snd := y }) (∀ (k : Nat), LT.lt k n → Membership.mem U { fst := Nat.iterate T k x, snd := Nat.iterate T k y })","decl":"lemma mem_dynEntourage {T : X → X} {U : Set (X × X)} {n : ℕ} {x y : X} :\n    (x, y) ∈ dynEntourage T U n ↔ ∀ k < n, (T^[k] x, T^[k] y) ∈ U := by\n  simp [dynEntourage]\n\n"}
{"name":"Dynamics.mem_ball_dynEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.DynamicalEntourage","initialProofState":"X : Type u_1\nT : X → X\nU : Set (Prod X X)\nn : Nat\nx y : X\n⊢ Iff (Membership.mem (UniformSpace.ball x (Dynamics.dynEntourage T U n)) y) (∀ (k : Nat), LT.lt k n → Membership.mem (UniformSpace.ball (Nat.iterate T k x) U) (Nat.iterate T k y))","decl":"lemma mem_ball_dynEntourage {T : X → X} {U : Set (X × X)} {n : ℕ} {x y : X} :\n    y ∈ ball x (dynEntourage T U n) ↔ ∀ k < n, T^[k] y ∈ ball (T^[k] x) U := by\n  simp only [ball, mem_preimage]; exact mem_dynEntourage\n\n"}
{"name":"Dynamics.dynEntourage_mem_uniformity","module":"Mathlib.Dynamics.TopologicalEntropy.DynamicalEntourage","initialProofState":"X : Type u_1\ninst✝ : UniformSpace X\nT : X → X\nh : UniformContinuous T\nU : Set (Prod X X)\nU_uni : Membership.mem (uniformity X) U\nn : Nat\n⊢ Membership.mem (uniformity X) (Dynamics.dynEntourage T U n)","decl":"lemma dynEntourage_mem_uniformity [UniformSpace X] {T : X → X} (h : UniformContinuous T)\n    {U : Set (X × X)} (U_uni : U ∈ 𝓤 X) (n : ℕ) :\n    dynEntourage T U n ∈ 𝓤 X := by\n  rw [dynEntourage_eq_inter_Ico T U n]\n  refine Filter.iInter_mem.2 fun k ↦ ?_\n  rw [map_iterate T T k]\n  exact uniformContinuous_def.1 (UniformContinuous.iterate T k h) U U_uni\n\n"}
{"name":"Dynamics.idRel_subset_dynEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.DynamicalEntourage","initialProofState":"X : Type u_1\nT : X → X\nU : Set (Prod X X)\nh : HasSubset.Subset idRel U\nn : Nat\n⊢ HasSubset.Subset idRel (Dynamics.dynEntourage T U n)","decl":"lemma idRel_subset_dynEntourage (T : X → X) {U : Set (X × X)} (h : idRel ⊆ U) (n : ℕ) :\n    idRel ⊆ (dynEntourage T U n) := by\n  simp only [dynEntourage, map_iterate, subset_iInter_iff, idRel_subset, mem_preimage, map_apply]\n  exact fun _ _ _ ↦ h rfl\n\n"}
{"name":"SymmetricRel.dynEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.DynamicalEntourage","initialProofState":"X : Type u_1\nT : X → X\nU : Set (Prod X X)\nh : SymmetricRel U\nn : Nat\n⊢ SymmetricRel (Dynamics.dynEntourage T U n)","decl":"lemma _root_.SymmetricRel.dynEntourage (T : X → X) {U : Set (X × X)} (h : SymmetricRel U) (n : ℕ) :\n    SymmetricRel (dynEntourage T U n) := by\n  ext xy\n  simp only [Dynamics.dynEntourage, map_iterate, mem_preimage, mem_iInter]\n  refine forall₂_congr fun k _ ↦ ?_\n  exact map_apply' _ _ _ ▸ SymmetricRel.mk_mem_comm h\n\n"}
{"name":"Dynamics.dynEntourage_comp_subset","module":"Mathlib.Dynamics.TopologicalEntropy.DynamicalEntourage","initialProofState":"X : Type u_1\nT : X → X\nU V : Set (Prod X X)\nn : Nat\n⊢ HasSubset.Subset (compRel (Dynamics.dynEntourage T U n) (Dynamics.dynEntourage T V n)) (Dynamics.dynEntourage T (compRel U V) n)","decl":"lemma dynEntourage_comp_subset (T : X → X) (U V : Set (X × X)) (n : ℕ) :\n    (dynEntourage T U n) ○ (dynEntourage T V n) ⊆ dynEntourage T (U ○ V) n := by\n  simp only [dynEntourage, map_iterate, subset_iInter_iff]\n  intro k k_n xy xy_comp\n  simp only [compRel, mem_iInter, mem_preimage, map_apply, mem_setOf_eq] at xy_comp ⊢\n  rcases xy_comp with ⟨z, hz1, hz2⟩\n  exact mem_ball_comp (hz1 k k_n) (hz2 k k_n)\n\n"}
{"name":"isOpen.dynEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.DynamicalEntourage","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nT : X → X\nT_cont : Continuous T\nU : Set (Prod X X)\nU_open : IsOpen U\nn : Nat\n⊢ IsOpen (Dynamics.dynEntourage T U n)","decl":"lemma _root_.isOpen.dynEntourage [TopologicalSpace X] {T : X → X} (T_cont : Continuous T)\n    {U : Set (X × X)} (U_open : IsOpen U) (n : ℕ) :\n    IsOpen (dynEntourage T U n) := by\n  rw [dynEntourage_eq_inter_Ico T U n]\n  refine isOpen_iInter_of_finite fun k ↦ ?_\n  exact U_open.preimage ((T_cont.prodMap T_cont).iterate k)\n\n"}
{"name":"Dynamics.dynEntourage_monotone","module":"Mathlib.Dynamics.TopologicalEntropy.DynamicalEntourage","initialProofState":"X : Type u_1\nT : X → X\nn : Nat\n⊢ Monotone fun U => Dynamics.dynEntourage T U n","decl":"lemma dynEntourage_monotone (T : X → X) (n : ℕ) :\n    Monotone (fun U : Set (X × X) ↦ dynEntourage T U n) :=\n  fun _ _ h ↦ iInter₂_mono fun _ _ ↦ preimage_mono h\n\n"}
{"name":"Dynamics.dynEntourage_antitone","module":"Mathlib.Dynamics.TopologicalEntropy.DynamicalEntourage","initialProofState":"X : Type u_1\nT : X → X\nU : Set (Prod X X)\n⊢ Antitone fun n => Dynamics.dynEntourage T U n","decl":"lemma dynEntourage_antitone (T : X → X) (U : Set (X × X)) :\n    Antitone (fun n : ℕ ↦ dynEntourage T U n) :=\n  fun m n m_n ↦ iInter₂_mono' fun k k_m ↦ by use k, lt_of_lt_of_le k_m m_n\n\n"}
{"name":"Dynamics.dynEntourage_zero","module":"Mathlib.Dynamics.TopologicalEntropy.DynamicalEntourage","initialProofState":"X : Type u_1\nT : X → X\nU : Set (Prod X X)\n⊢ Eq (Dynamics.dynEntourage T U 0) Set.univ","decl":"@[simp]\nlemma dynEntourage_zero {T : X → X} {U : Set (X × X)} :\n    dynEntourage T U 0 = univ := by simp [dynEntourage]\n\n"}
{"name":"Dynamics.dynEntourage_one","module":"Mathlib.Dynamics.TopologicalEntropy.DynamicalEntourage","initialProofState":"X : Type u_1\nT : X → X\nU : Set (Prod X X)\n⊢ Eq (Dynamics.dynEntourage T U 1) U","decl":"@[simp]\nlemma dynEntourage_one {T : X → X} {U : Set (X × X)} :\n    dynEntourage T U 1 = U := by simp [dynEntourage]\n\n"}
{"name":"Dynamics.dynEntourage_univ","module":"Mathlib.Dynamics.TopologicalEntropy.DynamicalEntourage","initialProofState":"X : Type u_1\nT : X → X\nn : Nat\n⊢ Eq (Dynamics.dynEntourage T Set.univ n) Set.univ","decl":"@[simp]\nlemma dynEntourage_univ {T : X → X} {n : ℕ} :\n    dynEntourage T univ n = univ := by simp [dynEntourage]\n\n"}
{"name":"Dynamics.mem_ball_dynEntourage_comp","module":"Mathlib.Dynamics.TopologicalEntropy.DynamicalEntourage","initialProofState":"X : Type u_1\nT : X → X\nn : Nat\nU : Set (Prod X X)\nU_symm : SymmetricRel U\nx y : X\nh : (Inter.inter (UniformSpace.ball x (Dynamics.dynEntourage T U n)) (UniformSpace.ball y (Dynamics.dynEntourage T U n))).Nonempty\n⊢ Membership.mem (UniformSpace.ball y (Dynamics.dynEntourage T (compRel U U) n)) x","decl":"lemma mem_ball_dynEntourage_comp (T : X → X) (n : ℕ) {U : Set (X × X)} (U_symm : SymmetricRel U)\n    (x y : X) (h : (ball x (dynEntourage T U n) ∩ ball y (dynEntourage T U n)).Nonempty) :\n    x ∈ ball y (dynEntourage T (U ○ U) n) := by\n  rcases h with ⟨z, z_Bx, z_By⟩\n  rw [mem_ball_symmetry (SymmetricRel.dynEntourage T U_symm n)] at z_Bx\n  exact dynEntourage_comp_subset T U U n (mem_ball_comp z_By z_Bx)\n\n"}
{"name":"Function.Semiconj.preimage_dynEntourage","module":"Mathlib.Dynamics.TopologicalEntropy.DynamicalEntourage","initialProofState":"X : Type u_1\nY : Type u_2\nS : X → X\nT : Y → Y\nφ : X → Y\nh : Function.Semiconj φ S T\nU : Set (Prod Y Y)\nn : Nat\n⊢ Eq (Set.preimage (Prod.map φ φ) (Dynamics.dynEntourage T U n)) (Dynamics.dynEntourage S (Set.preimage (Prod.map φ φ) U) n)","decl":"lemma _root_.Function.Semiconj.preimage_dynEntourage {Y : Type*} {S : X → X} {T : Y → Y} {φ : X → Y}\n    (h : Function.Semiconj φ S T) (U : Set (Y × Y)) (n : ℕ) :\n    (map φ φ)⁻¹' (dynEntourage T U n) = dynEntourage S ((map φ φ)⁻¹' U) n := by\n  rw [dynEntourage, preimage_iInter₂]\n  refine iInter₂_congr fun k _ ↦ ?_\n  rw [← preimage_comp, ← preimage_comp, map_iterate S S k, map_iterate T T k, map_comp_map,\n    map_comp_map, (Function.Semiconj.iterate_right h k).comp_eq]\n\n"}
