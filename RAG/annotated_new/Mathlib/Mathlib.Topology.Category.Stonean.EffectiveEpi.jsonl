{"name":"Stonean.effectiveEpi_tfae","module":"Mathlib.Topology.Category.Stonean.EffectiveEpi","initialProofState":"B X : Stonean\nπ : Quiver.Hom X B\n⊢ (List.cons (CategoryTheory.EffectiveEpi π) (List.cons (CategoryTheory.Epi π) (List.cons (Function.Surjective ⇑π) List.nil))).TFAE","decl":"open List in\ntheorem effectiveEpi_tfae\n    {B X : Stonean.{u}} (π : X ⟶ B) :\n    TFAE\n    [ EffectiveEpi π\n    , Epi π\n    , Function.Surjective π\n    ] := by\n  tfae_have 1 → 2 := fun _ ↦ inferInstance\n  tfae_have 2 ↔ 3 := epi_iff_surjective π\n  tfae_have 3 → 1 := fun hπ ↦ ⟨⟨effectiveEpiStruct π hπ⟩⟩\n  tfae_finish\n\n"}
{"name":"Stonean.instPreservesEffectiveEpisCompHausToCompHaus","module":"Mathlib.Topology.Category.Stonean.EffectiveEpi","initialProofState":"⊢ Stonean.toCompHaus.PreservesEffectiveEpis","decl":"instance : Stonean.toCompHaus.PreservesEffectiveEpis where\n  preserves f h :=\n    ((CompHaus.effectiveEpi_tfae (Stonean.toCompHaus.map f)).out 0 2).mpr\n      (((Stonean.effectiveEpi_tfae f).out 0 2).mp h)\n\n"}
{"name":"Stonean.instReflectsEffectiveEpisCompHausToCompHaus","module":"Mathlib.Topology.Category.Stonean.EffectiveEpi","initialProofState":"⊢ Stonean.toCompHaus.ReflectsEffectiveEpis","decl":"instance : Stonean.toCompHaus.ReflectsEffectiveEpis where\n  reflects f h :=\n    ((Stonean.effectiveEpi_tfae f).out 0 2).mpr\n      (((CompHaus.effectiveEpi_tfae (Stonean.toCompHaus.map f)).out 0 2).mp h)\n\n"}
{"name":"Stonean.instEffectivelyEnoughCompHausToCompHaus","module":"Mathlib.Topology.Category.Stonean.EffectiveEpi","initialProofState":"⊢ Stonean.toCompHaus.EffectivelyEnough","decl":"instance : Stonean.toCompHaus.EffectivelyEnough where\n  presentation X := ⟨stoneanToCompHausEffectivePresentation X⟩\n\n"}
{"name":"Stonean.instPreregular","module":"Mathlib.Topology.Category.Stonean.EffectiveEpi","initialProofState":"⊢ CategoryTheory.Preregular Stonean","decl":"instance : Preregular Stonean := Stonean.toCompHaus.reflects_preregular\n\n"}
{"name":"Stonean.effectiveEpiFamily_tfae","module":"Mathlib.Topology.Category.Stonean.EffectiveEpi","initialProofState":"α : Type\ninst✝ : Finite α\nB : Stonean\nX : α → Stonean\nπ : (a : α) → Quiver.Hom (X a) B\n⊢ (List.cons (CategoryTheory.EffectiveEpiFamily X π) (List.cons (CategoryTheory.Epi (CategoryTheory.Limits.Sigma.desc π)) (List.cons (∀ (b : ↑B.toTop), Exists fun a => Exists fun x => Eq ((π a) x) b) List.nil))).TFAE","decl":"open List in\ntheorem effectiveEpiFamily_tfae\n    {α : Type} [Finite α] {B : Stonean.{u}}\n    (X : α → Stonean.{u}) (π : (a : α) → (X a ⟶ B)) :\n    TFAE\n    [ EffectiveEpiFamily X π\n    , Epi (Sigma.desc π)\n    , ∀ b : B, ∃ (a : α) (x : X a), π a x = b\n    ] := by\n  tfae_have 2 → 1\n  | _ => by\n    simpa [← effectiveEpi_desc_iff_effectiveEpiFamily, (effectiveEpi_tfae (Sigma.desc π)).out 0 1]\n  tfae_have 1 → 2 := fun _ ↦ inferInstance\n  tfae_have 3 ↔ 1 := by\n    erw [((CompHaus.effectiveEpiFamily_tfae\n      (fun a ↦ Stonean.toCompHaus.obj (X a)) (fun a ↦ Stonean.toCompHaus.map (π a))).out 2 0 : )]\n    exact ⟨fun h ↦ Stonean.toCompHaus.finite_effectiveEpiFamily_of_map _ _ h,\n      fun _ ↦ inferInstance⟩\n  tfae_finish\n\n"}
{"name":"Stonean.effectiveEpiFamily_of_jointly_surjective","module":"Mathlib.Topology.Category.Stonean.EffectiveEpi","initialProofState":"α : Type\ninst✝ : Finite α\nB : Stonean\nX : α → Stonean\nπ : (a : α) → Quiver.Hom (X a) B\nsurj : ∀ (b : ↑B.toTop), Exists fun a => Exists fun x => Eq ((π a) x) b\n⊢ CategoryTheory.EffectiveEpiFamily X π","decl":"theorem effectiveEpiFamily_of_jointly_surjective\n    {α : Type} [Finite α] {B : Stonean.{u}}\n    (X : α → Stonean.{u}) (π : (a : α) → (X a ⟶ B))\n    (surj : ∀ b : B, ∃ (a : α) (x : X a), π a x = b) :\n    EffectiveEpiFamily X π :=\n  ((effectiveEpiFamily_tfae X π).out 2 0).mp surj\n\n"}
