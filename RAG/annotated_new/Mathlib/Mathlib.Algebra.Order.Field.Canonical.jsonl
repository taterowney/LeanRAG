{"name":"CanonicallyLinearOrderedSemifield.le_of_add_le_add_left","module":"Mathlib.Algebra.Order.Field.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedSemifield α\na b c : α\na✝ : LE.le (HAdd.hAdd a b) (HAdd.hAdd a c)\n⊢ LE.le b c","decl":"set_option linter.deprecated false in\n/-- A canonically linear ordered field is a linear ordered field in which `a ≤ b` iff there exists\n`c` with `b = a + c`. -/\n@[deprecated \"Use `[LinearOrderedSemifield α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedSemifield (α : Type*) extends CanonicallyOrderedCommSemiring α,\n  LinearOrderedSemifield α\n\n"}
{"name":"CanonicallyLinearOrderedSemifield.zpow_neg'","module":"Mathlib.Algebra.Order.Field.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedSemifield α\nn : Nat\na : α\n⊢ Eq (self.zpow (Int.negSucc n) a) (Inv.inv (self.zpow (↑n.succ) a))","decl":"set_option linter.deprecated false in\n/-- A canonically linear ordered field is a linear ordered field in which `a ≤ b` iff there exists\n`c` with `b = a + c`. -/\n@[deprecated \"Use `[LinearOrderedSemifield α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedSemifield (α : Type*) extends CanonicallyOrderedCommSemiring α,\n  LinearOrderedSemifield α\n\n"}
{"name":"CanonicallyLinearOrderedSemifield.compare_eq_compareOfLessAndEq","module":"Mathlib.Algebra.Order.Field.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedSemifield α\na b : α\n⊢ Eq (Ord.compare a b) (compareOfLessAndEq a b)","decl":"set_option linter.deprecated false in\n/-- A canonically linear ordered field is a linear ordered field in which `a ≤ b` iff there exists\n`c` with `b = a + c`. -/\n@[deprecated \"Use `[LinearOrderedSemifield α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedSemifield (α : Type*) extends CanonicallyOrderedCommSemiring α,\n  LinearOrderedSemifield α\n\n"}
{"name":"CanonicallyLinearOrderedSemifield.nnqsmul_def","module":"Mathlib.Algebra.Order.Field.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedSemifield α\nq : NNRat\na : α\n⊢ Eq (self.nnqsmul q a) (HMul.hMul (↑q) a)","decl":"set_option linter.deprecated false in\n/-- A canonically linear ordered field is a linear ordered field in which `a ≤ b` iff there exists\n`c` with `b = a + c`. -/\n@[deprecated \"Use `[LinearOrderedSemifield α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedSemifield (α : Type*) extends CanonicallyOrderedCommSemiring α,\n  LinearOrderedSemifield α\n\n"}
{"name":"CanonicallyLinearOrderedSemifield.mk.sizeOf_spec","module":"Mathlib.Algebra.Order.Field.Canonical","initialProofState":"α : Type u_1\ninst✝ : SizeOf α\ntoCanonicallyOrderedCommSemiring : CanonicallyOrderedCommSemiring α\nle_of_add_le_add_left : ∀ (a b c : α), LE.le (HAdd.hAdd a b) (HAdd.hAdd a c) → LE.le b c\ntoNontrivial : Nontrivial α\nzero_le_one : LE.le 0 1\nmul_lt_mul_of_pos_left : ∀ (a b c : α), LT.lt a b → LT.lt 0 c → LT.lt (HMul.hMul c a) (HMul.hMul c b)\nmul_lt_mul_of_pos_right : ∀ (a b c : α), LT.lt a b → LT.lt 0 c → LT.lt (HMul.hMul a c) (HMul.hMul b c)\ntoMin : Min α\ntoMax : Max α\ntoOrd : Ord α\nle_total : ∀ (a b : α), Or (LE.le a b) (LE.le b a)\ndecidableLE : DecidableRel fun x1 x2 => LE.le x1 x2\ndecidableEq : DecidableEq α\ndecidableLT : DecidableRel fun x1 x2 => LT.lt x1 x2\nmin_def : autoParam (∀ (a b : α), Eq (Min.min a b) (ite (LE.le a b) a b)) _auto✝\nmax_def : autoParam (∀ (a b : α), Eq (Max.max a b) (ite (LE.le a b) b a)) _auto✝\ncompare_eq_compareOfLessAndEq : autoParam (∀ (a b : α), Eq (Ord.compare a b) (compareOfLessAndEq a b)) _auto✝\ntoInv : Inv α\ntoDiv : Div α\ndiv_eq_mul_inv : autoParam (∀ (a b : α), Eq (HDiv.hDiv a b) (HMul.hMul a (Inv.inv b))) _auto✝\nzpow : Int → α → α\nzpow_zero' : autoParam (∀ (a : α), Eq (zpow 0 a) 1) _auto✝\nzpow_succ' : autoParam (∀ (n : Nat) (a : α), Eq (zpow (↑n.succ) a) (HMul.hMul (zpow (↑n) a) a)) _auto✝\nzpow_neg' : autoParam (∀ (n : Nat) (a : α), Eq (zpow (Int.negSucc n) a) (Inv.inv (zpow (↑n.succ) a))) _auto✝\ninv_zero : Eq (Inv.inv 0) 0\nmul_inv_cancel : ∀ (a : α), Ne a 0 → Eq (HMul.hMul a (Inv.inv a)) 1\ntoNNRatCast : NNRatCast α\nnnratCast_def : autoParam (∀ (q : NNRat), Eq (↑q) (HDiv.hDiv ↑q.num ↑q.den)) _auto✝\nnnqsmul : NNRat → α → α\nnnqsmul_def : autoParam (∀ (q : NNRat) (a : α), Eq (nnqsmul q a) (HMul.hMul (↑q) a)) _auto✝\n⊢ Eq (SizeOf.sizeOf (CanonicallyLinearOrderedSemifield.mk toCanonicallyOrderedCommSemiring le_of_add_le_add_left zero_le_one mul_lt_mul_of_pos_left mul_lt_mul_of_pos_right le_total decidableLE decidableEq decidableLT min_def max_def compare_eq_compareOfLessAndEq div_eq_mul_inv zpow zpow_zero' zpow_succ' zpow_neg' inv_zero mul_inv_cancel nnratCast_def nnqsmul nnqsmul_def)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toCanonicallyOrderedCommSemiring)) (SizeOf.sizeOf toNontrivial)) (SizeOf.sizeOf zero_le_one)) (SizeOf.sizeOf toMin)) (SizeOf.sizeOf toMax)) (SizeOf.sizeOf toOrd)) (SizeOf.sizeOf toInv)) (SizeOf.sizeOf toDiv)) (SizeOf.sizeOf inv_zero)) (SizeOf.sizeOf toNNRatCast))","decl":"set_option linter.deprecated false in\n/-- A canonically linear ordered field is a linear ordered field in which `a ≤ b` iff there exists\n`c` with `b = a + c`. -/\n@[deprecated \"Use `[LinearOrderedSemifield α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedSemifield (α : Type*) extends CanonicallyOrderedCommSemiring α,\n  LinearOrderedSemifield α\n\n"}
{"name":"CanonicallyLinearOrderedSemifield.zpow_zero'","module":"Mathlib.Algebra.Order.Field.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedSemifield α\na : α\n⊢ Eq (self.zpow 0 a) 1","decl":"set_option linter.deprecated false in\n/-- A canonically linear ordered field is a linear ordered field in which `a ≤ b` iff there exists\n`c` with `b = a + c`. -/\n@[deprecated \"Use `[LinearOrderedSemifield α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedSemifield (α : Type*) extends CanonicallyOrderedCommSemiring α,\n  LinearOrderedSemifield α\n\n"}
{"name":"CanonicallyLinearOrderedSemifield.toNontrivial","module":"Mathlib.Algebra.Order.Field.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedSemifield α\n⊢ Nontrivial α","decl":"set_option linter.deprecated false in\n/-- A canonically linear ordered field is a linear ordered field in which `a ≤ b` iff there exists\n`c` with `b = a + c`. -/\n@[deprecated \"Use `[LinearOrderedSemifield α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedSemifield (α : Type*) extends CanonicallyOrderedCommSemiring α,\n  LinearOrderedSemifield α\n\n"}
{"name":"CanonicallyLinearOrderedSemifield.zpow_succ'","module":"Mathlib.Algebra.Order.Field.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedSemifield α\nn : Nat\na : α\n⊢ Eq (self.zpow (↑n.succ) a) (HMul.hMul (self.zpow (↑n) a) a)","decl":"set_option linter.deprecated false in\n/-- A canonically linear ordered field is a linear ordered field in which `a ≤ b` iff there exists\n`c` with `b = a + c`. -/\n@[deprecated \"Use `[LinearOrderedSemifield α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedSemifield (α : Type*) extends CanonicallyOrderedCommSemiring α,\n  LinearOrderedSemifield α\n\n"}
{"name":"CanonicallyLinearOrderedSemifield.div_eq_mul_inv","module":"Mathlib.Algebra.Order.Field.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedSemifield α\na b : α\n⊢ Eq (HDiv.hDiv a b) (HMul.hMul a (Inv.inv b))","decl":"set_option linter.deprecated false in\n/-- A canonically linear ordered field is a linear ordered field in which `a ≤ b` iff there exists\n`c` with `b = a + c`. -/\n@[deprecated \"Use `[LinearOrderedSemifield α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedSemifield (α : Type*) extends CanonicallyOrderedCommSemiring α,\n  LinearOrderedSemifield α\n\n"}
{"name":"CanonicallyLinearOrderedSemifield.mk.inj","module":"Mathlib.Algebra.Order.Field.Canonical","initialProofState":"α : Type u_1\ntoCanonicallyOrderedCommSemiring✝ : CanonicallyOrderedCommSemiring α\nle_of_add_le_add_left✝ : ∀ (a b c : α), LE.le (HAdd.hAdd a b) (HAdd.hAdd a c) → LE.le b c\ntoNontrivial✝ : Nontrivial α\nzero_le_one✝ : LE.le 0 1\nmul_lt_mul_of_pos_left✝ : ∀ (a b c : α), LT.lt a b → LT.lt 0 c → LT.lt (HMul.hMul c a) (HMul.hMul c b)\nmul_lt_mul_of_pos_right✝ : ∀ (a b c : α), LT.lt a b → LT.lt 0 c → LT.lt (HMul.hMul a c) (HMul.hMul b c)\ntoMin✝ : Min α\ntoMax✝ : Max α\ntoOrd✝ : Ord α\nle_total✝ : ∀ (a b : α), Or (LE.le a b) (LE.le b a)\ndecidableLE✝ : DecidableRel fun x1 x2 => LE.le x1 x2\ndecidableEq✝ : DecidableEq α\ndecidableLT✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nmin_def✝ : autoParam (∀ (a b : α), Eq (Min.min a b) (ite (LE.le a b) a b)) _auto✝\nmax_def✝ : autoParam (∀ (a b : α), Eq (Max.max a b) (ite (LE.le a b) b a)) _auto✝\ncompare_eq_compareOfLessAndEq✝ : autoParam (∀ (a b : α), Eq (Ord.compare a b) (compareOfLessAndEq a b)) _auto✝\ntoInv✝ : Inv α\ntoDiv✝ : Div α\ndiv_eq_mul_inv✝ : autoParam (∀ (a b : α), Eq (HDiv.hDiv a b) (HMul.hMul a (Inv.inv b))) _auto✝\nzpow✝ : Int → α → α\nzpow_zero'✝ : autoParam (∀ (a : α), Eq (zpow✝ 0 a) 1) _auto✝\nzpow_succ'✝ : autoParam (∀ (n : Nat) (a : α), Eq (zpow✝ (↑n.succ) a) (HMul.hMul (zpow✝ (↑n) a) a)) _auto✝\nzpow_neg'✝ : autoParam (∀ (n : Nat) (a : α), Eq (zpow✝ (Int.negSucc n) a) (Inv.inv (zpow✝ (↑n.succ) a))) _auto✝\ninv_zero✝ : Eq (Inv.inv 0) 0\nmul_inv_cancel✝ : ∀ (a : α), Ne a 0 → Eq (HMul.hMul a (Inv.inv a)) 1\ntoNNRatCast✝ : NNRatCast α\nnnratCast_def✝ : autoParam (∀ (q : NNRat), Eq (↑q) (HDiv.hDiv ↑q.num ↑q.den)) _auto✝\nnnqsmul✝ : NNRat → α → α\nnnqsmul_def✝ : autoParam (∀ (q : NNRat) (a : α), Eq (nnqsmul✝ q a) (HMul.hMul (↑q) a)) _auto✝\ntoCanonicallyOrderedCommSemiring : CanonicallyOrderedCommSemiring α\nle_of_add_le_add_left : ∀ (a b c : α), LE.le (HAdd.hAdd a b) (HAdd.hAdd a c) → LE.le b c\ntoNontrivial : Nontrivial α\nzero_le_one : LE.le 0 1\nmul_lt_mul_of_pos_left : ∀ (a b c : α), LT.lt a b → LT.lt 0 c → LT.lt (HMul.hMul c a) (HMul.hMul c b)\nmul_lt_mul_of_pos_right : ∀ (a b c : α), LT.lt a b → LT.lt 0 c → LT.lt (HMul.hMul a c) (HMul.hMul b c)\ntoMin : Min α\ntoMax : Max α\ntoOrd : Ord α\nle_total : ∀ (a b : α), Or (LE.le a b) (LE.le b a)\ndecidableLE : DecidableRel fun x1 x2 => LE.le x1 x2\ndecidableEq : DecidableEq α\ndecidableLT : DecidableRel fun x1 x2 => LT.lt x1 x2\nmin_def : autoParam (∀ (a b : α), Eq (Min.min a b) (ite (LE.le a b) a b)) _auto✝\nmax_def : autoParam (∀ (a b : α), Eq (Max.max a b) (ite (LE.le a b) b a)) _auto✝\ncompare_eq_compareOfLessAndEq : autoParam (∀ (a b : α), Eq (Ord.compare a b) (compareOfLessAndEq a b)) _auto✝\ntoInv : Inv α\ntoDiv : Div α\ndiv_eq_mul_inv : autoParam (∀ (a b : α), Eq (HDiv.hDiv a b) (HMul.hMul a (Inv.inv b))) _auto✝\nzpow : Int → α → α\nzpow_zero' : autoParam (∀ (a : α), Eq (zpow 0 a) 1) _auto✝\nzpow_succ' : autoParam (∀ (n : Nat) (a : α), Eq (zpow (↑n.succ) a) (HMul.hMul (zpow (↑n) a) a)) _auto✝\nzpow_neg' : autoParam (∀ (n : Nat) (a : α), Eq (zpow (Int.negSucc n) a) (Inv.inv (zpow (↑n.succ) a))) _auto✝\ninv_zero : Eq (Inv.inv 0) 0\nmul_inv_cancel : ∀ (a : α), Ne a 0 → Eq (HMul.hMul a (Inv.inv a)) 1\ntoNNRatCast : NNRatCast α\nnnratCast_def : autoParam (∀ (q : NNRat), Eq (↑q) (HDiv.hDiv ↑q.num ↑q.den)) _auto✝\nnnqsmul : NNRat → α → α\nnnqsmul_def : autoParam (∀ (q : NNRat) (a : α), Eq (nnqsmul q a) (HMul.hMul (↑q) a)) _auto✝\nx✝ : Eq (CanonicallyLinearOrderedSemifield.mk toCanonicallyOrderedCommSemiring✝ le_of_add_le_add_left✝ zero_le_one✝ mul_lt_mul_of_pos_left✝ mul_lt_mul_of_pos_right✝ le_total✝ decidableLE✝ decidableEq✝ decidableLT✝ min_def✝ max_def✝ compare_eq_compareOfLessAndEq✝ div_eq_mul_inv✝ zpow✝ zpow_zero'✝ zpow_succ'✝ zpow_neg'✝ inv_zero✝ mul_inv_cancel✝ nnratCast_def✝ nnqsmul✝ nnqsmul_def✝) (CanonicallyLinearOrderedSemifield.mk toCanonicallyOrderedCommSemiring le_of_add_le_add_left zero_le_one mul_lt_mul_of_pos_left mul_lt_mul_of_pos_right le_total decidableLE decidableEq decidableLT min_def max_def compare_eq_compareOfLessAndEq div_eq_mul_inv zpow zpow_zero' zpow_succ' zpow_neg' inv_zero mul_inv_cancel nnratCast_def nnqsmul nnqsmul_def)\n⊢ And (Eq toCanonicallyOrderedCommSemiring✝ toCanonicallyOrderedCommSemiring) (And (Eq toMin✝ toMin) (And (Eq toMax✝ toMax) (And (Eq toOrd✝ toOrd) (And (HEq decidableLE✝ decidableLE) (And (Eq decidableEq✝ decidableEq) (And (HEq decidableLT✝ decidableLT) (And (Eq toInv✝ toInv) (And (Eq toDiv✝ toDiv) (And (Eq zpow✝ zpow) (And (Eq toNNRatCast✝ toNNRatCast) (Eq nnqsmul✝ nnqsmul)))))))))))","decl":"set_option linter.deprecated false in\n/-- A canonically linear ordered field is a linear ordered field in which `a ≤ b` iff there exists\n`c` with `b = a + c`. -/\n@[deprecated \"Use `[LinearOrderedSemifield α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedSemifield (α : Type*) extends CanonicallyOrderedCommSemiring α,\n  LinearOrderedSemifield α\n\n"}
{"name":"CanonicallyLinearOrderedSemifield.nnratCast_def","module":"Mathlib.Algebra.Order.Field.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedSemifield α\nq : NNRat\n⊢ Eq (↑q) (HDiv.hDiv ↑q.num ↑q.den)","decl":"set_option linter.deprecated false in\n/-- A canonically linear ordered field is a linear ordered field in which `a ≤ b` iff there exists\n`c` with `b = a + c`. -/\n@[deprecated \"Use `[LinearOrderedSemifield α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedSemifield (α : Type*) extends CanonicallyOrderedCommSemiring α,\n  LinearOrderedSemifield α\n\n"}
{"name":"CanonicallyLinearOrderedSemifield.mk.injEq","module":"Mathlib.Algebra.Order.Field.Canonical","initialProofState":"α : Type u_1\ntoCanonicallyOrderedCommSemiring✝ : CanonicallyOrderedCommSemiring α\nle_of_add_le_add_left✝ : ∀ (a b c : α), LE.le (HAdd.hAdd a b) (HAdd.hAdd a c) → LE.le b c\ntoNontrivial✝ : Nontrivial α\nzero_le_one✝ : LE.le 0 1\nmul_lt_mul_of_pos_left✝ : ∀ (a b c : α), LT.lt a b → LT.lt 0 c → LT.lt (HMul.hMul c a) (HMul.hMul c b)\nmul_lt_mul_of_pos_right✝ : ∀ (a b c : α), LT.lt a b → LT.lt 0 c → LT.lt (HMul.hMul a c) (HMul.hMul b c)\ntoMin✝ : Min α\ntoMax✝ : Max α\ntoOrd✝ : Ord α\nle_total✝ : ∀ (a b : α), Or (LE.le a b) (LE.le b a)\ndecidableLE✝ : DecidableRel fun x1 x2 => LE.le x1 x2\ndecidableEq✝ : DecidableEq α\ndecidableLT✝ : DecidableRel fun x1 x2 => LT.lt x1 x2\nmin_def✝ : autoParam (∀ (a b : α), Eq (Min.min a b) (ite (LE.le a b) a b)) _auto✝\nmax_def✝ : autoParam (∀ (a b : α), Eq (Max.max a b) (ite (LE.le a b) b a)) _auto✝\ncompare_eq_compareOfLessAndEq✝ : autoParam (∀ (a b : α), Eq (Ord.compare a b) (compareOfLessAndEq a b)) _auto✝\ntoInv✝ : Inv α\ntoDiv✝ : Div α\ndiv_eq_mul_inv✝ : autoParam (∀ (a b : α), Eq (HDiv.hDiv a b) (HMul.hMul a (Inv.inv b))) _auto✝\nzpow✝ : Int → α → α\nzpow_zero'✝ : autoParam (∀ (a : α), Eq (zpow✝ 0 a) 1) _auto✝\nzpow_succ'✝ : autoParam (∀ (n : Nat) (a : α), Eq (zpow✝ (↑n.succ) a) (HMul.hMul (zpow✝ (↑n) a) a)) _auto✝\nzpow_neg'✝ : autoParam (∀ (n : Nat) (a : α), Eq (zpow✝ (Int.negSucc n) a) (Inv.inv (zpow✝ (↑n.succ) a))) _auto✝\ninv_zero✝ : Eq (Inv.inv 0) 0\nmul_inv_cancel✝ : ∀ (a : α), Ne a 0 → Eq (HMul.hMul a (Inv.inv a)) 1\ntoNNRatCast✝ : NNRatCast α\nnnratCast_def✝ : autoParam (∀ (q : NNRat), Eq (↑q) (HDiv.hDiv ↑q.num ↑q.den)) _auto✝\nnnqsmul✝ : NNRat → α → α\nnnqsmul_def✝ : autoParam (∀ (q : NNRat) (a : α), Eq (nnqsmul✝ q a) (HMul.hMul (↑q) a)) _auto✝\ntoCanonicallyOrderedCommSemiring : CanonicallyOrderedCommSemiring α\nle_of_add_le_add_left : ∀ (a b c : α), LE.le (HAdd.hAdd a b) (HAdd.hAdd a c) → LE.le b c\ntoNontrivial : Nontrivial α\nzero_le_one : LE.le 0 1\nmul_lt_mul_of_pos_left : ∀ (a b c : α), LT.lt a b → LT.lt 0 c → LT.lt (HMul.hMul c a) (HMul.hMul c b)\nmul_lt_mul_of_pos_right : ∀ (a b c : α), LT.lt a b → LT.lt 0 c → LT.lt (HMul.hMul a c) (HMul.hMul b c)\ntoMin : Min α\ntoMax : Max α\ntoOrd : Ord α\nle_total : ∀ (a b : α), Or (LE.le a b) (LE.le b a)\ndecidableLE : DecidableRel fun x1 x2 => LE.le x1 x2\ndecidableEq : DecidableEq α\ndecidableLT : DecidableRel fun x1 x2 => LT.lt x1 x2\nmin_def : autoParam (∀ (a b : α), Eq (Min.min a b) (ite (LE.le a b) a b)) _auto✝\nmax_def : autoParam (∀ (a b : α), Eq (Max.max a b) (ite (LE.le a b) b a)) _auto✝\ncompare_eq_compareOfLessAndEq : autoParam (∀ (a b : α), Eq (Ord.compare a b) (compareOfLessAndEq a b)) _auto✝\ntoInv : Inv α\ntoDiv : Div α\ndiv_eq_mul_inv : autoParam (∀ (a b : α), Eq (HDiv.hDiv a b) (HMul.hMul a (Inv.inv b))) _auto✝\nzpow : Int → α → α\nzpow_zero' : autoParam (∀ (a : α), Eq (zpow 0 a) 1) _auto✝\nzpow_succ' : autoParam (∀ (n : Nat) (a : α), Eq (zpow (↑n.succ) a) (HMul.hMul (zpow (↑n) a) a)) _auto✝\nzpow_neg' : autoParam (∀ (n : Nat) (a : α), Eq (zpow (Int.negSucc n) a) (Inv.inv (zpow (↑n.succ) a))) _auto✝\ninv_zero : Eq (Inv.inv 0) 0\nmul_inv_cancel : ∀ (a : α), Ne a 0 → Eq (HMul.hMul a (Inv.inv a)) 1\ntoNNRatCast : NNRatCast α\nnnratCast_def : autoParam (∀ (q : NNRat), Eq (↑q) (HDiv.hDiv ↑q.num ↑q.den)) _auto✝\nnnqsmul : NNRat → α → α\nnnqsmul_def : autoParam (∀ (q : NNRat) (a : α), Eq (nnqsmul q a) (HMul.hMul (↑q) a)) _auto✝\n⊢ Eq (Eq (CanonicallyLinearOrderedSemifield.mk toCanonicallyOrderedCommSemiring✝ le_of_add_le_add_left✝ zero_le_one✝ mul_lt_mul_of_pos_left✝ mul_lt_mul_of_pos_right✝ le_total✝ decidableLE✝ decidableEq✝ decidableLT✝ min_def✝ max_def✝ compare_eq_compareOfLessAndEq✝ div_eq_mul_inv✝ zpow✝ zpow_zero'✝ zpow_succ'✝ zpow_neg'✝ inv_zero✝ mul_inv_cancel✝ nnratCast_def✝ nnqsmul✝ nnqsmul_def✝) (CanonicallyLinearOrderedSemifield.mk toCanonicallyOrderedCommSemiring le_of_add_le_add_left zero_le_one mul_lt_mul_of_pos_left mul_lt_mul_of_pos_right le_total decidableLE decidableEq decidableLT min_def max_def compare_eq_compareOfLessAndEq div_eq_mul_inv zpow zpow_zero' zpow_succ' zpow_neg' inv_zero mul_inv_cancel nnratCast_def nnqsmul nnqsmul_def)) (And (Eq toCanonicallyOrderedCommSemiring✝ toCanonicallyOrderedCommSemiring) (And (Eq toMin✝ toMin) (And (Eq toMax✝ toMax) (And (Eq toOrd✝ toOrd) (And (HEq decidableLE✝ decidableLE) (And (Eq decidableEq✝ decidableEq) (And (HEq decidableLT✝ decidableLT) (And (Eq toInv✝ toInv) (And (Eq toDiv✝ toDiv) (And (Eq zpow✝ zpow) (And (Eq toNNRatCast✝ toNNRatCast) (Eq nnqsmul✝ nnqsmul))))))))))))","decl":"set_option linter.deprecated false in\n/-- A canonically linear ordered field is a linear ordered field in which `a ≤ b` iff there exists\n`c` with `b = a + c`. -/\n@[deprecated \"Use `[LinearOrderedSemifield α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedSemifield (α : Type*) extends CanonicallyOrderedCommSemiring α,\n  LinearOrderedSemifield α\n\n"}
{"name":"CanonicallyLinearOrderedSemifield.inv_zero","module":"Mathlib.Algebra.Order.Field.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedSemifield α\n⊢ Eq (Inv.inv 0) 0","decl":"set_option linter.deprecated false in\n/-- A canonically linear ordered field is a linear ordered field in which `a ≤ b` iff there exists\n`c` with `b = a + c`. -/\n@[deprecated \"Use `[LinearOrderedSemifield α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedSemifield (α : Type*) extends CanonicallyOrderedCommSemiring α,\n  LinearOrderedSemifield α\n\n"}
{"name":"CanonicallyLinearOrderedSemifield.max_def","module":"Mathlib.Algebra.Order.Field.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedSemifield α\na b : α\n⊢ Eq (Max.max a b) (ite (LE.le a b) b a)","decl":"set_option linter.deprecated false in\n/-- A canonically linear ordered field is a linear ordered field in which `a ≤ b` iff there exists\n`c` with `b = a + c`. -/\n@[deprecated \"Use `[LinearOrderedSemifield α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedSemifield (α : Type*) extends CanonicallyOrderedCommSemiring α,\n  LinearOrderedSemifield α\n\n"}
{"name":"CanonicallyLinearOrderedSemifield.mul_lt_mul_of_pos_left","module":"Mathlib.Algebra.Order.Field.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedSemifield α\na b c : α\na✝¹ : LT.lt a b\na✝ : LT.lt 0 c\n⊢ LT.lt (HMul.hMul c a) (HMul.hMul c b)","decl":"set_option linter.deprecated false in\n/-- A canonically linear ordered field is a linear ordered field in which `a ≤ b` iff there exists\n`c` with `b = a + c`. -/\n@[deprecated \"Use `[LinearOrderedSemifield α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedSemifield (α : Type*) extends CanonicallyOrderedCommSemiring α,\n  LinearOrderedSemifield α\n\n"}
{"name":"CanonicallyLinearOrderedSemifield.mul_lt_mul_of_pos_right","module":"Mathlib.Algebra.Order.Field.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedSemifield α\na b c : α\na✝¹ : LT.lt a b\na✝ : LT.lt 0 c\n⊢ LT.lt (HMul.hMul a c) (HMul.hMul b c)","decl":"set_option linter.deprecated false in\n/-- A canonically linear ordered field is a linear ordered field in which `a ≤ b` iff there exists\n`c` with `b = a + c`. -/\n@[deprecated \"Use `[LinearOrderedSemifield α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedSemifield (α : Type*) extends CanonicallyOrderedCommSemiring α,\n  LinearOrderedSemifield α\n\n"}
{"name":"CanonicallyLinearOrderedSemifield.zero_le_one","module":"Mathlib.Algebra.Order.Field.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedSemifield α\n⊢ LE.le 0 1","decl":"set_option linter.deprecated false in\n/-- A canonically linear ordered field is a linear ordered field in which `a ≤ b` iff there exists\n`c` with `b = a + c`. -/\n@[deprecated \"Use `[LinearOrderedSemifield α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedSemifield (α : Type*) extends CanonicallyOrderedCommSemiring α,\n  LinearOrderedSemifield α\n\n"}
{"name":"CanonicallyLinearOrderedSemifield.min_def","module":"Mathlib.Algebra.Order.Field.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedSemifield α\na b : α\n⊢ Eq (Min.min a b) (ite (LE.le a b) a b)","decl":"set_option linter.deprecated false in\n/-- A canonically linear ordered field is a linear ordered field in which `a ≤ b` iff there exists\n`c` with `b = a + c`. -/\n@[deprecated \"Use `[LinearOrderedSemifield α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedSemifield (α : Type*) extends CanonicallyOrderedCommSemiring α,\n  LinearOrderedSemifield α\n\n"}
{"name":"CanonicallyLinearOrderedSemifield.le_total","module":"Mathlib.Algebra.Order.Field.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedSemifield α\na b : α\n⊢ Or (LE.le a b) (LE.le b a)","decl":"set_option linter.deprecated false in\n/-- A canonically linear ordered field is a linear ordered field in which `a ≤ b` iff there exists\n`c` with `b = a + c`. -/\n@[deprecated \"Use `[LinearOrderedSemifield α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedSemifield (α : Type*) extends CanonicallyOrderedCommSemiring α,\n  LinearOrderedSemifield α\n\n"}
{"name":"CanonicallyLinearOrderedSemifield.mul_inv_cancel","module":"Mathlib.Algebra.Order.Field.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyLinearOrderedSemifield α\na : α\na✝ : Ne a 0\n⊢ Eq (HMul.hMul a (Inv.inv a)) 1","decl":"set_option linter.deprecated false in\n/-- A canonically linear ordered field is a linear ordered field in which `a ≤ b` iff there exists\n`c` with `b = a + c`. -/\n@[deprecated \"Use `[LinearOrderedSemifield α] [CanonicallyOrderedAdd α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyLinearOrderedSemifield (α : Type*) extends CanonicallyOrderedCommSemiring α,\n  LinearOrderedSemifield α\n\n"}
{"name":"tsub_div","module":"Mathlib.Algebra.Order.Field.Canonical","initialProofState":"α : Type u_1\ninst✝³ : LinearOrderedSemifield α\ninst✝² : CanonicallyOrderedAdd α\ninst✝¹ : Sub α\ninst✝ : OrderedSub α\na b c : α\n⊢ Eq (HDiv.hDiv (HSub.hSub a b) c) (HSub.hSub (HDiv.hDiv a c) (HDiv.hDiv b c))","decl":"theorem tsub_div (a b c : α) : (a - b) / c = a / c - b / c := by simp_rw [div_eq_mul_inv, tsub_mul]\n"}
