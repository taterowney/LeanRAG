{"name":"ArithmeticFunction.log_apply","module":"Mathlib.NumberTheory.VonMangoldt","initialProofState":"n : Nat\n⊢ Eq (ArithmeticFunction.log n) (Real.log ↑n)","decl":"@[simp]\ntheorem log_apply {n : ℕ} : log n = Real.log n :=\n  rfl\n\n"}
{"name":"ArithmeticFunction.vonMangoldt_apply","module":"Mathlib.NumberTheory.VonMangoldt","initialProofState":"n : Nat\n⊢ Eq (ArithmeticFunction.vonMangoldt n) (ite (IsPrimePow n) (Real.log ↑n.minFac) 0)","decl":"theorem vonMangoldt_apply {n : ℕ} : Λ n = if IsPrimePow n then Real.log (minFac n) else 0 :=\n  rfl\n\n"}
{"name":"ArithmeticFunction.vonMangoldt_apply_one","module":"Mathlib.NumberTheory.VonMangoldt","initialProofState":"⊢ Eq (ArithmeticFunction.vonMangoldt 1) 0","decl":"@[simp]\ntheorem vonMangoldt_apply_one : Λ 1 = 0 := by simp [vonMangoldt_apply]\n\n"}
{"name":"ArithmeticFunction.vonMangoldt_nonneg","module":"Mathlib.NumberTheory.VonMangoldt","initialProofState":"n : Nat\n⊢ LE.le 0 (ArithmeticFunction.vonMangoldt n)","decl":"@[simp]\ntheorem vonMangoldt_nonneg {n : ℕ} : 0 ≤ Λ n := by\n  rw [vonMangoldt_apply]\n  split_ifs\n  · exact Real.log_nonneg (one_le_cast.2 (Nat.minFac_pos n))\n  rfl\n\n"}
{"name":"ArithmeticFunction.vonMangoldt_apply_pow","module":"Mathlib.NumberTheory.VonMangoldt","initialProofState":"n k : Nat\nhk : Ne k 0\n⊢ Eq (ArithmeticFunction.vonMangoldt (HPow.hPow n k)) (ArithmeticFunction.vonMangoldt n)","decl":"theorem vonMangoldt_apply_pow {n k : ℕ} (hk : k ≠ 0) : Λ (n ^ k) = Λ n := by\n  simp only [vonMangoldt_apply, isPrimePow_pow_iff hk, pow_minFac hk]\n\n"}
{"name":"ArithmeticFunction.vonMangoldt_apply_prime","module":"Mathlib.NumberTheory.VonMangoldt","initialProofState":"p : Nat\nhp : Nat.Prime p\n⊢ Eq (ArithmeticFunction.vonMangoldt p) (Real.log ↑p)","decl":"theorem vonMangoldt_apply_prime {p : ℕ} (hp : p.Prime) : Λ p = Real.log p := by\n  rw [vonMangoldt_apply, Prime.minFac_eq hp, if_pos hp.prime.isPrimePow]\n\n"}
{"name":"ArithmeticFunction.vonMangoldt_ne_zero_iff","module":"Mathlib.NumberTheory.VonMangoldt","initialProofState":"n : Nat\n⊢ Iff (Ne (ArithmeticFunction.vonMangoldt n) 0) (IsPrimePow n)","decl":"theorem vonMangoldt_ne_zero_iff {n : ℕ} : Λ n ≠ 0 ↔ IsPrimePow n := by\n  rcases eq_or_ne n 1 with (rfl | hn); · simp [not_isPrimePow_one]\n  exact (Real.log_pos (one_lt_cast.2 (minFac_prime hn).one_lt)).ne'.ite_ne_right_iff\n\n"}
{"name":"ArithmeticFunction.vonMangoldt_pos_iff","module":"Mathlib.NumberTheory.VonMangoldt","initialProofState":"n : Nat\n⊢ Iff (LT.lt 0 (ArithmeticFunction.vonMangoldt n)) (IsPrimePow n)","decl":"theorem vonMangoldt_pos_iff {n : ℕ} : 0 < Λ n ↔ IsPrimePow n :=\n  vonMangoldt_nonneg.lt_iff_ne.trans (ne_comm.trans vonMangoldt_ne_zero_iff)\n\n"}
{"name":"ArithmeticFunction.vonMangoldt_eq_zero_iff","module":"Mathlib.NumberTheory.VonMangoldt","initialProofState":"n : Nat\n⊢ Iff (Eq (ArithmeticFunction.vonMangoldt n) 0) (Not (IsPrimePow n))","decl":"theorem vonMangoldt_eq_zero_iff {n : ℕ} : Λ n = 0 ↔ ¬IsPrimePow n :=\n  vonMangoldt_ne_zero_iff.not_right\n\n"}
{"name":"ArithmeticFunction.vonMangoldt_sum","module":"Mathlib.NumberTheory.VonMangoldt","initialProofState":"n : Nat\n⊢ Eq (n.divisors.sum fun i => ArithmeticFunction.vonMangoldt i) (Real.log ↑n)","decl":"theorem vonMangoldt_sum {n : ℕ} : ∑ i ∈ n.divisors, Λ i = Real.log n := by\n  refine recOnPrimeCoprime ?_ ?_ ?_ n\n  · simp\n  · intro p k hp\n    rw [sum_divisors_prime_pow hp, cast_pow, Real.log_pow, Finset.sum_range_succ', Nat.pow_zero,\n      vonMangoldt_apply_one]\n    simp [vonMangoldt_apply_pow (Nat.succ_ne_zero _), vonMangoldt_apply_prime hp]\n  intro a b ha' hb' hab ha hb\n  simp only [vonMangoldt_apply, ← sum_filter] at ha hb ⊢\n  rw [mul_divisors_filter_prime_pow hab, filter_union,\n    sum_union (disjoint_divisors_filter_isPrimePow hab), ha, hb, Nat.cast_mul,\n    Real.log_mul (cast_ne_zero.2 (pos_of_gt ha').ne') (cast_ne_zero.2 (pos_of_gt hb').ne')]\n\n"}
{"name":"ArithmeticFunction.vonMangoldt_mul_zeta","module":"Mathlib.NumberTheory.VonMangoldt","initialProofState":"⊢ Eq (HMul.hMul ArithmeticFunction.vonMangoldt ↑ArithmeticFunction.zeta) ArithmeticFunction.log","decl":"@[simp]\ntheorem vonMangoldt_mul_zeta : Λ * ζ = log := by\n  ext n; rw [coe_mul_zeta_apply, vonMangoldt_sum]; rfl\n\n"}
{"name":"ArithmeticFunction.zeta_mul_vonMangoldt","module":"Mathlib.NumberTheory.VonMangoldt","initialProofState":"⊢ Eq (HMul.hMul (↑ArithmeticFunction.zeta) ArithmeticFunction.vonMangoldt) ArithmeticFunction.log","decl":"@[simp]\ntheorem zeta_mul_vonMangoldt : (ζ : ArithmeticFunction ℝ) * Λ = log := by rw [mul_comm]; simp\n\n"}
{"name":"ArithmeticFunction.log_mul_moebius_eq_vonMangoldt","module":"Mathlib.NumberTheory.VonMangoldt","initialProofState":"⊢ Eq (HMul.hMul ArithmeticFunction.log ↑ArithmeticFunction.moebius) ArithmeticFunction.vonMangoldt","decl":"@[simp]\ntheorem log_mul_moebius_eq_vonMangoldt : log * μ = Λ := by\n  rw [← vonMangoldt_mul_zeta, mul_assoc, coe_zeta_mul_coe_moebius, mul_one]\n\n"}
{"name":"ArithmeticFunction.moebius_mul_log_eq_vonMangoldt","module":"Mathlib.NumberTheory.VonMangoldt","initialProofState":"⊢ Eq (HMul.hMul (↑ArithmeticFunction.moebius) ArithmeticFunction.log) ArithmeticFunction.vonMangoldt","decl":"@[simp]\ntheorem moebius_mul_log_eq_vonMangoldt : (μ : ArithmeticFunction ℝ) * log = Λ := by\n  rw [mul_comm]; simp\n\n"}
{"name":"ArithmeticFunction.sum_moebius_mul_log_eq","module":"Mathlib.NumberTheory.VonMangoldt","initialProofState":"n : Nat\n⊢ Eq (n.divisors.sum fun d => HMul.hMul (↑(ArithmeticFunction.moebius d)) (ArithmeticFunction.log d)) (Neg.neg (ArithmeticFunction.vonMangoldt n))","decl":"theorem sum_moebius_mul_log_eq {n : ℕ} : (∑ d ∈ n.divisors, (μ d : ℝ) * log d) = -Λ n := by\n  simp only [← log_mul_moebius_eq_vonMangoldt, mul_comm log, mul_apply, log_apply, intCoe_apply, ←\n    Finset.sum_neg_distrib, neg_mul_eq_mul_neg]\n  rw [sum_divisorsAntidiagonal fun i j => (μ i : ℝ) * -Real.log j]\n  have : (∑ i ∈ n.divisors, (μ i : ℝ) * -Real.log (n / i : ℕ)) =\n      ∑ i ∈ n.divisors, ((μ i : ℝ) * Real.log i - μ i * Real.log n) := by\n    apply sum_congr rfl\n    simp only [and_imp, Int.cast_eq_zero, mul_eq_mul_left_iff, Ne, neg_inj, mem_divisors]\n    intro m mn hn\n    have : (m : ℝ) ≠ 0 := by\n      rw [cast_ne_zero]\n      rintro rfl\n      exact hn (by simpa using mn)\n    rw [Nat.cast_div mn this, Real.log_div (cast_ne_zero.2 hn) this, neg_sub, mul_sub]\n  rw [this, sum_sub_distrib, ← sum_mul, ← Int.cast_sum, ← coe_mul_zeta_apply, eq_comm, sub_eq_self,\n    moebius_mul_coe_zeta]\n  rcases eq_or_ne n 1 with (hn | hn) <;> simp [hn]\n\n"}
{"name":"ArithmeticFunction.vonMangoldt_le_log","module":"Mathlib.NumberTheory.VonMangoldt","initialProofState":"n : Nat\n⊢ LE.le (ArithmeticFunction.vonMangoldt n) (Real.log ↑n)","decl":"theorem vonMangoldt_le_log : ∀ {n : ℕ}, Λ n ≤ Real.log (n : ℝ)\n  | 0 => by simp\n  | n + 1 => by\n    rw [← vonMangoldt_sum]\n    exact single_le_sum (by exact fun _ _ => vonMangoldt_nonneg)\n      (mem_divisors_self _ n.succ_ne_zero)\n\n"}
