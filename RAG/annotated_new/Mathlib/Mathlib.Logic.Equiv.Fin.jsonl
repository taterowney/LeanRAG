{"name":"Fin.preimage_apply_01_prod","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"α : Fin 2 → Type u\ns : Set (α 0)\nt : Set (α 1)\n⊢ Eq (Set.preimage (fun f => { fst := f 0, snd := f 1 }) (SProd.sprod s t)) (Set.univ.pi (Fin.cons s (Fin.cons t finZeroElim)))","decl":"theorem Fin.preimage_apply_01_prod {α : Fin 2 → Type u} (s : Set (α 0)) (t : Set (α 1)) :\n    (fun f : ∀ i, α i => (f 0, f 1)) ⁻¹' s ×ˢ t =\n      Set.pi Set.univ (Fin.cons s <| Fin.cons t finZeroElim) := by\n  ext f\n  simp [Fin.forall_fin_two]\n\n"}
{"name":"Fin.preimage_apply_01_prod'","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"α : Type u\ns t : Set α\n⊢ Eq (Set.preimage (fun f => { fst := f 0, snd := f 1 }) (SProd.sprod s t)) (Set.univ.pi (Matrix.vecCons s (Matrix.vecCons t Matrix.vecEmpty)))","decl":"theorem Fin.preimage_apply_01_prod' {α : Type u} (s t : Set α) :\n    (fun f : Fin 2 → α => (f 0, f 1)) ⁻¹' s ×ˢ t = Set.pi Set.univ ![s, t] :=\n  @Fin.preimage_apply_01_prod (fun _ => α) s t\n\n"}
{"name":"prodEquivPiFinTwo_apply","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"α β : Type u\n⊢ Eq ⇑(prodEquivPiFinTwo α β) fun p => Fin.cons p.1 (Fin.cons p.2 finZeroElim)","decl":"/-- A product space `α × β` is equivalent to the space `Π i : Fin 2, γ i`, where\n`γ = Fin.cons α (Fin.cons β finZeroElim)`. See also `piFinTwoEquiv` and\n`finTwoArrowEquiv`. -/\n@[simps! (config := .asFn)]\ndef prodEquivPiFinTwo (α β : Type u) : α × β ≃ ∀ i : Fin 2, ![α, β] i :=\n  (piFinTwoEquiv (Fin.cons α (Fin.cons β finZeroElim))).symm\n\n"}
{"name":"prodEquivPiFinTwo_symm_apply","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"α β : Type u\n⊢ Eq ⇑(prodEquivPiFinTwo α β).symm fun f => { fst := f 0, snd := f 1 }","decl":"/-- A product space `α × β` is equivalent to the space `Π i : Fin 2, γ i`, where\n`γ = Fin.cons α (Fin.cons β finZeroElim)`. See also `piFinTwoEquiv` and\n`finTwoArrowEquiv`. -/\n@[simps! (config := .asFn)]\ndef prodEquivPiFinTwo (α β : Type u) : α × β ≃ ∀ i : Fin 2, ![α, β] i :=\n  (piFinTwoEquiv (Fin.cons α (Fin.cons β finZeroElim))).symm\n\n"}
{"name":"finTwoArrowEquiv_symm_apply","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"α : Type u_1\n⊢ Eq ⇑(finTwoArrowEquiv α).symm fun x => Matrix.vecCons x.1 (Matrix.vecCons x.2 Matrix.vecEmpty)","decl":"/-- The space of functions `Fin 2 → α` is equivalent to `α × α`. See also `piFinTwoEquiv` and\n`prodEquivPiFinTwo`. -/\n@[simps (config := .asFn)]\ndef finTwoArrowEquiv (α : Type*) : (Fin 2 → α) ≃ α × α :=\n  { piFinTwoEquiv fun _ => α with invFun := fun x => ![x.1, x.2] }\n\n"}
{"name":"finTwoArrowEquiv_apply","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"α : Type u_1\n⊢ Eq (⇑(finTwoArrowEquiv α)) (piFinTwoEquiv fun x => α).toFun","decl":"/-- The space of functions `Fin 2 → α` is equivalent to `α × α`. See also `piFinTwoEquiv` and\n`prodEquivPiFinTwo`. -/\n@[simps (config := .asFn)]\ndef finTwoArrowEquiv (α : Type*) : (Fin 2 → α) ≃ α × α :=\n  { piFinTwoEquiv fun _ => α with invFun := fun x => ![x.1, x.2] }\n\n"}
{"name":"finSuccEquiv'_at","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq ((finSuccEquiv' i) i) Option.none","decl":"@[simp]\ntheorem finSuccEquiv'_at (i : Fin (n + 1)) : (finSuccEquiv' i) i = none := by\n  simp [finSuccEquiv']\n\n"}
{"name":"finSuccEquiv'_succAbove","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nj : Fin n\n⊢ Eq ((finSuccEquiv' i) (i.succAbove j)) (Option.some j)","decl":"@[simp]\ntheorem finSuccEquiv'_succAbove (i : Fin (n + 1)) (j : Fin n) :\n    finSuccEquiv' i (i.succAbove j) = some j :=\n  @Fin.insertNth_apply_succAbove n (fun _ => Option (Fin n)) i _ _ _\n\n"}
{"name":"finSuccEquiv'_below","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nm : Fin n\nh : LT.lt m.castSucc i\n⊢ Eq ((finSuccEquiv' i) m.castSucc) (Option.some m)","decl":"theorem finSuccEquiv'_below {i : Fin (n + 1)} {m : Fin n} (h : Fin.castSucc m < i) :\n    (finSuccEquiv' i) (Fin.castSucc m) = m := by\n  rw [← Fin.succAbove_of_castSucc_lt _ _ h, finSuccEquiv'_succAbove]\n\n"}
{"name":"finSuccEquiv'_above","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nm : Fin n\nh : LE.le i m.castSucc\n⊢ Eq ((finSuccEquiv' i) m.succ) (Option.some m)","decl":"theorem finSuccEquiv'_above {i : Fin (n + 1)} {m : Fin n} (h : i ≤ Fin.castSucc m) :\n    (finSuccEquiv' i) m.succ = some m := by\n  rw [← Fin.succAbove_of_le_castSucc _ _ h, finSuccEquiv'_succAbove]\n\n"}
{"name":"finSuccEquiv'_symm_none","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq ((finSuccEquiv' i).symm Option.none) i","decl":"@[simp]\ntheorem finSuccEquiv'_symm_none (i : Fin (n + 1)) : (finSuccEquiv' i).symm none = i :=\n  rfl\n\n"}
{"name":"finSuccEquiv'_symm_some","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nj : Fin n\n⊢ Eq ((finSuccEquiv' i).symm (Option.some j)) (i.succAbove j)","decl":"@[simp]\ntheorem finSuccEquiv'_symm_some (i : Fin (n + 1)) (j : Fin n) :\n    (finSuccEquiv' i).symm (some j) = i.succAbove j :=\n  rfl\n\n"}
{"name":"finSuccEquiv'_symm_some_below","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nm : Fin n\nh : LT.lt m.castSucc i\n⊢ Eq ((finSuccEquiv' i).symm (Option.some m)) m.castSucc","decl":"theorem finSuccEquiv'_symm_some_below {i : Fin (n + 1)} {m : Fin n} (h : Fin.castSucc m < i) :\n    (finSuccEquiv' i).symm (some m) = Fin.castSucc m :=\n  Fin.succAbove_of_castSucc_lt i m h\n\n"}
{"name":"finSuccEquiv'_symm_some_above","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nm : Fin n\nh : LE.le i m.castSucc\n⊢ Eq ((finSuccEquiv' i).symm (Option.some m)) m.succ","decl":"theorem finSuccEquiv'_symm_some_above {i : Fin (n + 1)} {m : Fin n} (h : i ≤ Fin.castSucc m) :\n    (finSuccEquiv' i).symm (some m) = m.succ :=\n  Fin.succAbove_of_le_castSucc i m h\n\n"}
{"name":"finSuccEquiv'_symm_coe_below","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nm : Fin n\nh : LT.lt m.castSucc i\n⊢ Eq ((finSuccEquiv' i).symm (Option.some m)) m.castSucc","decl":"theorem finSuccEquiv'_symm_coe_below {i : Fin (n + 1)} {m : Fin n} (h : Fin.castSucc m < i) :\n    (finSuccEquiv' i).symm m = Fin.castSucc m :=\n  finSuccEquiv'_symm_some_below h\n\n"}
{"name":"finSuccEquiv'_symm_coe_above","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nm : Fin n\nh : LE.le i m.castSucc\n⊢ Eq ((finSuccEquiv' i).symm (Option.some m)) m.succ","decl":"theorem finSuccEquiv'_symm_coe_above {i : Fin (n + 1)} {m : Fin n} (h : i ≤ Fin.castSucc m) :\n    (finSuccEquiv' i).symm m = m.succ :=\n  finSuccEquiv'_symm_some_above h\n\n"}
{"name":"finSuccEquiv_zero","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\n⊢ Eq ((finSuccEquiv n) 0) Option.none","decl":"@[simp]\ntheorem finSuccEquiv_zero : (finSuccEquiv n) 0 = none :=\n  rfl\n\n"}
{"name":"finSuccEquiv_succ","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\nm : Fin n\n⊢ Eq ((finSuccEquiv n) m.succ) (Option.some m)","decl":"@[simp]\ntheorem finSuccEquiv_succ (m : Fin n) : (finSuccEquiv n) m.succ = some m :=\n  finSuccEquiv'_above (Fin.zero_le _)\n\n"}
{"name":"finSuccEquiv_symm_none","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\n⊢ Eq ((finSuccEquiv n).symm Option.none) 0","decl":"@[simp]\ntheorem finSuccEquiv_symm_none : (finSuccEquiv n).symm none = 0 :=\n  finSuccEquiv'_symm_none _\n\n"}
{"name":"finSuccEquiv_symm_some","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\nm : Fin n\n⊢ Eq ((finSuccEquiv n).symm (Option.some m)) m.succ","decl":"@[simp]\ntheorem finSuccEquiv_symm_some (m : Fin n) : (finSuccEquiv n).symm (some m) = m.succ :=\n  congr_fun Fin.succAbove_zero m\n\n"}
{"name":"finSuccEquiv'_zero","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\n⊢ Eq (finSuccEquiv' 0) (finSuccEquiv n)","decl":"/-- The equiv version of `Fin.predAbove_zero`. -/\ntheorem finSuccEquiv'_zero : finSuccEquiv' (0 : Fin (n + 1)) = finSuccEquiv n :=\n  rfl\n\n"}
{"name":"finSuccEquiv'_last_apply_castSucc","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ni : Fin n\n⊢ Eq ((finSuccEquiv' (Fin.last n)) i.castSucc) (Option.some i)","decl":"theorem finSuccEquiv'_last_apply_castSucc (i : Fin n) :\n    finSuccEquiv' (Fin.last n) (Fin.castSucc i) = i := by\n  rw [← Fin.succAbove_last, finSuccEquiv'_succAbove]\n\n"}
{"name":"finSuccEquiv'_last_apply","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nh : Ne i (Fin.last n)\n⊢ Eq ((finSuccEquiv' (Fin.last n)) i) (Option.some (i.castLT ⋯))","decl":"theorem finSuccEquiv'_last_apply {i : Fin (n + 1)} (h : i ≠ Fin.last n) :\n    finSuccEquiv' (Fin.last n) i = Fin.castLT i (Fin.val_lt_last h) := by\n  rcases Fin.exists_castSucc_eq.2 h with ⟨i, rfl⟩\n  rw [finSuccEquiv'_last_apply_castSucc]\n  rfl\n\n"}
{"name":"finSuccEquiv'_ne_last_apply","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ni j : Fin (HAdd.hAdd n 1)\nhi : Ne i (Fin.last n)\nhj : Ne j i\n⊢ Eq ((finSuccEquiv' i) j) (Option.some ((i.castLT ⋯).predAbove j))","decl":"theorem finSuccEquiv'_ne_last_apply {i j : Fin (n + 1)} (hi : i ≠ Fin.last n) (hj : j ≠ i) :\n    finSuccEquiv' i j = (i.castLT (Fin.val_lt_last hi)).predAbove j := by\n  rcases Fin.exists_succAbove_eq hj with ⟨j, rfl⟩\n  rcases Fin.exists_castSucc_eq.2 hi with ⟨i, rfl⟩\n  simp\n\n"}
{"name":"finSuccAboveEquiv_apply","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\ni : Fin n\n⊢ Eq ((finSuccAboveEquiv p) i) ⟨p.succAbove i, ⋯⟩","decl":"theorem finSuccAboveEquiv_apply (p : Fin (n + 1)) (i : Fin n) :\n    finSuccAboveEquiv p i = ⟨p.succAbove i, p.succAbove_ne i⟩ :=\n  rfl\n\n"}
{"name":"finSuccAboveEquiv_symm_apply_last","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\nx : Subtype fun x => Ne x (Fin.last n)\n⊢ Eq ((finSuccAboveEquiv (Fin.last n)).symm x) ((↑x).castLT ⋯)","decl":"theorem finSuccAboveEquiv_symm_apply_last (x : { x : Fin (n + 1) // x ≠ Fin.last n }) :\n    (finSuccAboveEquiv (Fin.last n)).symm x = Fin.castLT x.1 (Fin.val_lt_last x.2) := by\n  rw [← Option.some_inj]\n  simpa [finSuccAboveEquiv] using finSuccEquiv'_last_apply x.property\n\n"}
{"name":"finSuccAboveEquiv_symm_apply_ne_last","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\np : Fin (HAdd.hAdd n 1)\nh : Ne p (Fin.last n)\nx : Subtype fun x => Ne x p\n⊢ Eq ((finSuccAboveEquiv p).symm x) ((p.castLT ⋯).predAbove ↑x)","decl":"theorem finSuccAboveEquiv_symm_apply_ne_last {p : Fin (n + 1)} (h : p ≠ Fin.last n)\n    (x : { x : Fin (n + 1) // x ≠ p }) :\n    (finSuccAboveEquiv p).symm x = (p.castLT (Fin.val_lt_last h)).predAbove x := by\n  rw [← Option.some_inj]\n  simpa [finSuccAboveEquiv] using finSuccEquiv'_ne_last_apply h x.property\n\n"}
{"name":"finSuccEquivLast_castSucc","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ni : Fin n\n⊢ Eq (finSuccEquivLast i.castSucc) (Option.some i)","decl":"@[simp]\ntheorem finSuccEquivLast_castSucc (i : Fin n) : finSuccEquivLast (Fin.castSucc i) = some i :=\n  finSuccEquiv'_below i.2\n\n"}
{"name":"finSuccEquivLast_last","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\n⊢ Eq (finSuccEquivLast (Fin.last n)) Option.none","decl":"@[simp]\ntheorem finSuccEquivLast_last : finSuccEquivLast (Fin.last n) = none := by\n  simp [finSuccEquivLast]\n\n"}
{"name":"finSuccEquivLast_symm_some","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ni : Fin n\n⊢ Eq (finSuccEquivLast.symm (Option.some i)) i.castSucc","decl":"@[simp]\ntheorem finSuccEquivLast_symm_some (i : Fin n) :\n    finSuccEquivLast.symm (some i) = Fin.castSucc i :=\n  finSuccEquiv'_symm_some_below i.2\n\n"}
{"name":"finSuccEquivLast_symm_none","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\n⊢ Eq (finSuccEquivLast.symm Option.none) (Fin.last n)","decl":"@[simp] theorem finSuccEquivLast_symm_none : finSuccEquivLast.symm none = Fin.last n :=\n  finSuccEquiv'_symm_none _\n\n"}
{"name":"Equiv.embeddingFinSucc_fst","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\nι : Type u_1\ne : Function.Embedding (Fin (HAdd.hAdd n 1)) ι\n⊢ Eq (⇑((Equiv.embeddingFinSucc n ι) e).fst) (Function.comp (⇑e) Fin.succ)","decl":"@[simp] lemma Equiv.embeddingFinSucc_fst {n : ℕ} {ι : Type*} (e : Fin (n+1) ↪ ι) :\n    ((Equiv.embeddingFinSucc n ι e).1 : Fin n → ι) = e ∘ Fin.succ := rfl\n\n"}
{"name":"Equiv.embeddingFinSucc_snd","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\nι : Type u_1\ne : Function.Embedding (Fin (HAdd.hAdd n 1)) ι\n⊢ Eq (↑((Equiv.embeddingFinSucc n ι) e).snd) (e 0)","decl":"@[simp] lemma Equiv.embeddingFinSucc_snd {n : ℕ} {ι : Type*} (e : Fin (n+1) ↪ ι) :\n    ((Equiv.embeddingFinSucc n ι e).2 : ι) = e 0 := rfl\n\n"}
{"name":"Equiv.coe_embeddingFinSucc_symm","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\nι : Type u_1\nf : Sigma fun e => Subtype fun i => Not (Membership.mem (Set.range ⇑e) i)\n⊢ Eq (⇑((Equiv.embeddingFinSucc n ι).symm f)) (Fin.cons ↑f.snd ⇑f.fst)","decl":"@[simp] lemma Equiv.coe_embeddingFinSucc_symm {n : ℕ} {ι : Type*}\n    (f : Σ (e : Fin n ↪ ι), {i // i ∉ Set.range e}) :\n    ((Equiv.embeddingFinSucc n ι).symm f : Fin (n + 1) → ι) = Fin.cons f.2.1 f.1 := by\n  ext i\n  exact Fin.cases rfl (fun j ↦ rfl) i\n\n"}
{"name":"finSumFinEquiv_apply_left","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"m n : Nat\ni : Fin m\n⊢ Eq (finSumFinEquiv (Sum.inl i)) (Fin.castAdd n i)","decl":"@[simp]\ntheorem finSumFinEquiv_apply_left (i : Fin m) :\n    (finSumFinEquiv (Sum.inl i) : Fin (m + n)) = Fin.castAdd n i :=\n  rfl\n\n"}
{"name":"finSumFinEquiv_apply_right","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"m n : Nat\ni : Fin n\n⊢ Eq (finSumFinEquiv (Sum.inr i)) (Fin.natAdd m i)","decl":"@[simp]\ntheorem finSumFinEquiv_apply_right (i : Fin n) :\n    (finSumFinEquiv (Sum.inr i) : Fin (m + n)) = Fin.natAdd m i :=\n  rfl\n\n"}
{"name":"finSumFinEquiv_symm_apply_castAdd","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"m n : Nat\nx : Fin m\n⊢ Eq (finSumFinEquiv.symm (Fin.castAdd n x)) (Sum.inl x)","decl":"@[simp]\ntheorem finSumFinEquiv_symm_apply_castAdd (x : Fin m) :\n    finSumFinEquiv.symm (Fin.castAdd n x) = Sum.inl x :=\n  finSumFinEquiv.symm_apply_apply (Sum.inl x)\n\n"}
{"name":"finSumFinEquiv_symm_apply_natAdd","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"m n : Nat\nx : Fin n\n⊢ Eq (finSumFinEquiv.symm (Fin.natAdd m x)) (Sum.inr x)","decl":"@[simp]\ntheorem finSumFinEquiv_symm_apply_natAdd (x : Fin n) :\n    finSumFinEquiv.symm (Fin.natAdd m x) = Sum.inr x :=\n  finSumFinEquiv.symm_apply_apply (Sum.inr x)\n\n"}
{"name":"finSumFinEquiv_symm_last","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\n⊢ Eq (finSumFinEquiv.symm (Fin.last n)) (Sum.inr 0)","decl":"@[simp]\ntheorem finSumFinEquiv_symm_last : finSumFinEquiv.symm (Fin.last n) = Sum.inr 0 :=\n  finSumFinEquiv_symm_apply_natAdd 0\n\n"}
{"name":"finAddFlip_apply_castAdd","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"m : Nat\nk : Fin m\nn : Nat\n⊢ Eq (finAddFlip (Fin.castAdd n k)) (Fin.natAdd n k)","decl":"@[simp]\ntheorem finAddFlip_apply_castAdd (k : Fin m) (n : ℕ) :\n    finAddFlip (Fin.castAdd n k) = Fin.natAdd n k := by simp [finAddFlip]\n\n"}
{"name":"finAddFlip_apply_natAdd","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\nk : Fin n\nm : Nat\n⊢ Eq (finAddFlip (Fin.natAdd m k)) (Fin.castAdd m k)","decl":"@[simp]\ntheorem finAddFlip_apply_natAdd (k : Fin n) (m : ℕ) :\n    finAddFlip (Fin.natAdd m k) = Fin.castAdd m k := by simp [finAddFlip]\n\n"}
{"name":"finAddFlip_apply_mk_left","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"m n k : Nat\nh : LT.lt k m\nhk : optParam (LT.lt k (HAdd.hAdd m n)) ⋯\nhnk : optParam (LT.lt (HAdd.hAdd n k) (HAdd.hAdd n m)) ⋯\n⊢ Eq (finAddFlip ⟨k, hk⟩) ⟨HAdd.hAdd n k, hnk⟩","decl":"@[simp]\ntheorem finAddFlip_apply_mk_left {k : ℕ} (h : k < m) (hk : k < m + n := Nat.lt_add_right n h)\n    (hnk : n + k < n + m := Nat.add_lt_add_left h n) :\n    finAddFlip (⟨k, hk⟩ : Fin (m + n)) = ⟨n + k, hnk⟩ := by\n  convert finAddFlip_apply_castAdd ⟨k, h⟩ n\n\n"}
{"name":"finAddFlip_apply_mk_right","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"m n k : Nat\nh₁ : LE.le m k\nh₂ : LT.lt k (HAdd.hAdd m n)\n⊢ Eq (finAddFlip ⟨k, h₂⟩) ⟨HSub.hSub k m, ⋯⟩","decl":"@[simp]\ntheorem finAddFlip_apply_mk_right {k : ℕ} (h₁ : m ≤ k) (h₂ : k < m + n) :\n    finAddFlip (⟨k, h₂⟩ : Fin (m + n)) = ⟨k - m, by omega⟩ := by\n  convert @finAddFlip_apply_natAdd n ⟨k - m, by omega⟩ m\n  simp [Nat.add_sub_cancel' h₁]\n\n"}
{"name":"finRotate_zero","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"⊢ Eq (finRotate 0) (Equiv.refl (Fin 0))","decl":"@[simp] lemma finRotate_zero : finRotate 0 = Equiv.refl _ := rfl\n\n"}
{"name":"finRotate_succ","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\n⊢ Eq (finRotate (HAdd.hAdd n 1)) (finAddFlip.trans (finCongr ⋯))","decl":"lemma finRotate_succ (n : ℕ) :\n    finRotate (n + 1) = finAddFlip.trans (finCongr (Nat.add_comm 1 n)) := rfl\n\n"}
{"name":"finRotate_of_lt","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n k : Nat\nh : LT.lt k n\n⊢ Eq ((finRotate (HAdd.hAdd n 1)) ⟨k, ⋯⟩) ⟨HAdd.hAdd k 1, ⋯⟩","decl":"theorem finRotate_of_lt {k : ℕ} (h : k < n) :\n    finRotate (n + 1) ⟨k, h.trans_le n.le_succ⟩ = ⟨k + 1, Nat.succ_lt_succ h⟩ := by\n  ext\n  dsimp [finRotate_succ]\n  simp [finAddFlip_apply_mk_left h, Nat.add_comm]\n\n"}
{"name":"finRotate_last'","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\n⊢ Eq ((finRotate (HAdd.hAdd n 1)) ⟨n, ⋯⟩) ⟨0, ⋯⟩","decl":"theorem finRotate_last' : finRotate (n + 1) ⟨n, by omega⟩ = ⟨0, Nat.zero_lt_succ _⟩ := by\n  dsimp [finRotate_succ]\n  rw [finAddFlip_apply_mk_right le_rfl]\n  simp\n\n"}
{"name":"finRotate_last","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\n⊢ Eq ((finRotate (HAdd.hAdd n 1)) (Fin.last n)) 0","decl":"theorem finRotate_last : finRotate (n + 1) (Fin.last _) = 0 :=\n  finRotate_last'\n\n"}
{"name":"Fin.snoc_eq_cons_rotate","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\nα : Type u_1\nv : Fin n → α\na : α\n⊢ Eq (Fin.snoc v a) fun i => Fin.cons a v ((finRotate (HAdd.hAdd n 1)) i)","decl":"theorem Fin.snoc_eq_cons_rotate {α : Type*} (v : Fin n → α) (a : α) :\n    @Fin.snoc _ (fun _ => α) v a = fun i => @Fin.cons _ (fun _ => α) a v (finRotate _ i) := by\n  ext ⟨i, h⟩\n  by_cases h' : i < n\n  · rw [finRotate_of_lt h', Fin.snoc, Fin.cons, dif_pos h']\n    rfl\n  · have h'' : n = i := by\n      simp only [not_lt] at h'\n      exact (Nat.eq_of_le_of_lt_succ h' h).symm\n    subst h''\n    rw [finRotate_last', Fin.snoc, Fin.cons, dif_neg (lt_irrefl _)]\n    rfl\n\n"}
{"name":"finRotate_one","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"⊢ Eq (finRotate 1) (Equiv.refl (Fin 1))","decl":"@[simp]\ntheorem finRotate_one : finRotate 1 = Equiv.refl _ :=\n  Subsingleton.elim _ _\n\n"}
{"name":"finRotate_succ_apply","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq ((finRotate (HAdd.hAdd n 1)) i) (HAdd.hAdd i 1)","decl":"@[simp] theorem finRotate_succ_apply (i : Fin (n + 1)) : finRotate (n + 1) i = i + 1 := by\n  cases n\n  · exact @Subsingleton.elim (Fin 1) _ _ _\n  obtain rfl | h := Fin.eq_or_lt_of_le i.le_last\n  · simp [finRotate_last]\n  · cases i\n    simp only [Fin.lt_iff_val_lt_val, Fin.val_last, Fin.val_mk] at h\n    simp [finRotate_of_lt h, Fin.ext_iff, Fin.add_def, Nat.mod_eq_of_lt (Nat.succ_lt_succ h)]\n\n-- Porting note: was a @[simp]\n"}
{"name":"finRotate_apply_zero","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\n⊢ Eq ((finRotate n.succ) 0) 1","decl":"theorem finRotate_apply_zero : finRotate n.succ 0 = 1 := by\n  rw [finRotate_succ_apply, Fin.zero_add]\n\n"}
{"name":"coe_finRotate_of_ne_last","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ni : Fin n.succ\nh : Ne i (Fin.last n)\n⊢ Eq (↑((finRotate (HAdd.hAdd n 1)) i)) (HAdd.hAdd (↑i) 1)","decl":"theorem coe_finRotate_of_ne_last {i : Fin n.succ} (h : i ≠ Fin.last n) :\n    (finRotate (n + 1) i : ℕ) = i + 1 := by\n  rw [finRotate_succ_apply]\n  have : (i : ℕ) < n := Fin.val_lt_last h\n  exact Fin.val_add_one_of_lt this\n\n"}
{"name":"coe_finRotate","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ni : Fin n.succ\n⊢ Eq (↑((finRotate n.succ) i)) (ite (Eq i (Fin.last n)) 0 (HAdd.hAdd (↑i) 1))","decl":"theorem coe_finRotate (i : Fin n.succ) :\n    (finRotate n.succ i : ℕ) = if i = Fin.last n then (0 : ℕ) else i + 1 := by\n  rw [finRotate_succ_apply, Fin.val_add_one i]\n\n"}
{"name":"finProdFinEquiv_symm_apply","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"m n : Nat\nx : Fin (HMul.hMul m n)\n⊢ Eq (finProdFinEquiv.symm x) { fst := x.divNat, snd := x.modNat }","decl":"/-- Equivalence between `Fin m × Fin n` and `Fin (m * n)` -/\n@[simps]\ndef finProdFinEquiv : Fin m × Fin n ≃ Fin (m * n) where\n  toFun x :=\n    ⟨x.2 + n * x.1,\n      calc\n        x.2.1 + n * x.1.1 + 1 = x.1.1 * n + x.2.1 + 1 := by ac_rfl\n        _ ≤ x.1.1 * n + n := Nat.add_le_add_left x.2.2 _\n        _ = (x.1.1 + 1) * n := Eq.symm <| Nat.succ_mul _ _\n        _ ≤ m * n := Nat.mul_le_mul_right _ x.1.2\n        ⟩\n  invFun x := (x.divNat, x.modNat)\n  left_inv := fun ⟨x, y⟩ =>\n    have H : 0 < n := Nat.pos_of_ne_zero fun H => Nat.not_lt_zero y.1 <| H ▸ y.2\n    Prod.ext\n      (Fin.eq_of_val_eq <|\n        calc\n          (y.1 + n * x.1) / n = y.1 / n + x.1 := Nat.add_mul_div_left _ _ H\n          _ = 0 + x.1 := by rw [Nat.div_eq_of_lt y.2]\n          _ = x.1 := Nat.zero_add x.1\n          )\n      (Fin.eq_of_val_eq <|\n        calc\n          (y.1 + n * x.1) % n = y.1 % n := Nat.add_mul_mod_self_left _ _ _\n          _ = y.1 := Nat.mod_eq_of_lt y.2\n          )\n  right_inv _ := Fin.eq_of_val_eq <| Nat.mod_add_div _ _\n\n"}
{"name":"finProdFinEquiv_apply_val","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"m n : Nat\nx : Prod (Fin m) (Fin n)\n⊢ Eq (↑(finProdFinEquiv x)) (HAdd.hAdd (↑x.2) (HMul.hMul n ↑x.1))","decl":"/-- Equivalence between `Fin m × Fin n` and `Fin (m * n)` -/\n@[simps]\ndef finProdFinEquiv : Fin m × Fin n ≃ Fin (m * n) where\n  toFun x :=\n    ⟨x.2 + n * x.1,\n      calc\n        x.2.1 + n * x.1.1 + 1 = x.1.1 * n + x.2.1 + 1 := by ac_rfl\n        _ ≤ x.1.1 * n + n := Nat.add_le_add_left x.2.2 _\n        _ = (x.1.1 + 1) * n := Eq.symm <| Nat.succ_mul _ _\n        _ ≤ m * n := Nat.mul_le_mul_right _ x.1.2\n        ⟩\n  invFun x := (x.divNat, x.modNat)\n  left_inv := fun ⟨x, y⟩ =>\n    have H : 0 < n := Nat.pos_of_ne_zero fun H => Nat.not_lt_zero y.1 <| H ▸ y.2\n    Prod.ext\n      (Fin.eq_of_val_eq <|\n        calc\n          (y.1 + n * x.1) / n = y.1 / n + x.1 := Nat.add_mul_div_left _ _ H\n          _ = 0 + x.1 := by rw [Nat.div_eq_of_lt y.2]\n          _ = x.1 := Nat.zero_add x.1\n          )\n      (Fin.eq_of_val_eq <|\n        calc\n          (y.1 + n * x.1) % n = y.1 % n := Nat.add_mul_mod_self_left _ _ _\n          _ = y.1 := Nat.mod_eq_of_lt y.2\n          )\n  right_inv _ := Fin.eq_of_val_eq <| Nat.mod_add_div _ _\n\n"}
{"name":"Nat.divModEquiv_apply","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ninst✝ : NeZero n\na : Nat\n⊢ Eq (n.divModEquiv a) { fst := HDiv.hDiv a n, snd := ↑a }","decl":"/-- The equivalence induced by `a ↦ (a / n, a % n)` for nonzero `n`.\nThis is like `finProdFinEquiv.symm` but with `m` infinite.\nSee `Nat.div_mod_unique` for a similar propositional statement. -/\n@[simps]\ndef Nat.divModEquiv (n : ℕ) [NeZero n] : ℕ ≃ ℕ × Fin n where\n  toFun a := (a / n, ↑a)\n  invFun p := p.1 * n + ↑p.2\n  -- TODO: is there a canonical order of `*` and `+` here?\n  left_inv _ := Nat.div_add_mod' _ _\n  right_inv p := by\n    refine Prod.ext ?_ (Fin.ext <| Nat.mul_add_mod_of_lt p.2.is_lt)\n    dsimp only\n    rw [Nat.add_comm, Nat.add_mul_div_right _ _ n.pos_of_neZero, Nat.div_eq_of_lt p.2.is_lt,\n      Nat.zero_add]\n\n"}
{"name":"Nat.divModEquiv_symm_apply","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ninst✝ : NeZero n\np : Prod Nat (Fin n)\n⊢ Eq (n.divModEquiv.symm p) (HAdd.hAdd (HMul.hMul p.1 n) ↑p.2)","decl":"/-- The equivalence induced by `a ↦ (a / n, a % n)` for nonzero `n`.\nThis is like `finProdFinEquiv.symm` but with `m` infinite.\nSee `Nat.div_mod_unique` for a similar propositional statement. -/\n@[simps]\ndef Nat.divModEquiv (n : ℕ) [NeZero n] : ℕ ≃ ℕ × Fin n where\n  toFun a := (a / n, ↑a)\n  invFun p := p.1 * n + ↑p.2\n  -- TODO: is there a canonical order of `*` and `+` here?\n  left_inv _ := Nat.div_add_mod' _ _\n  right_inv p := by\n    refine Prod.ext ?_ (Fin.ext <| Nat.mul_add_mod_of_lt p.2.is_lt)\n    dsimp only\n    rw [Nat.add_comm, Nat.add_mul_div_right _ _ n.pos_of_neZero, Nat.div_eq_of_lt p.2.is_lt,\n      Nat.zero_add]\n\n"}
{"name":"Int.divModEquiv_apply","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ninst✝ : NeZero n\na : Int\n⊢ Eq ((Int.divModEquiv n) a) { fst := HDiv.hDiv a ↑n, snd := ↑(a.natMod ↑n) }","decl":"/-- The equivalence induced by `a ↦ (a / n, a % n)` for nonzero `n`.\nSee `Int.ediv_emod_unique` for a similar propositional statement. -/\n@[simps]\ndef Int.divModEquiv (n : ℕ) [NeZero n] : ℤ ≃ ℤ × Fin n where\n  -- TODO: could cast from int directly if we import `Data.ZMod.Defs`, though there are few lemmas\n  -- about that coercion.\n  toFun a := (a / n, ↑(a.natMod n))\n  invFun p := p.1 * n + ↑p.2\n  left_inv a := by\n    simp_rw [Fin.coe_natCast_eq_mod, natCast_mod, natMod,\n      toNat_of_nonneg (emod_nonneg _ <| natCast_eq_zero.not.2 (NeZero.ne n)), emod_emod,\n      ediv_add_emod']\n  right_inv := fun ⟨q, r, hrn⟩ => by\n    simp only [Fin.val_mk, Prod.mk.inj_iff, Fin.ext_iff]\n    obtain ⟨h1, h2⟩ := Int.natCast_nonneg r, Int.ofNat_lt.2 hrn\n    rw [Int.add_comm, add_mul_ediv_right _ _ (natCast_eq_zero.not.2 (NeZero.ne n)),\n      ediv_eq_zero_of_lt h1 h2, natMod, add_mul_emod_self, emod_eq_of_lt h1 h2, toNat_natCast]\n    exact ⟨q.zero_add, Fin.val_cast_of_lt hrn⟩\n\n"}
{"name":"Int.divModEquiv_symm_apply","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n : Nat\ninst✝ : NeZero n\np : Prod Int (Fin n)\n⊢ Eq ((Int.divModEquiv n).symm p) (HAdd.hAdd (HMul.hMul p.1 ↑n) ↑↑p.2)","decl":"/-- The equivalence induced by `a ↦ (a / n, a % n)` for nonzero `n`.\nSee `Int.ediv_emod_unique` for a similar propositional statement. -/\n@[simps]\ndef Int.divModEquiv (n : ℕ) [NeZero n] : ℤ ≃ ℤ × Fin n where\n  -- TODO: could cast from int directly if we import `Data.ZMod.Defs`, though there are few lemmas\n  -- about that coercion.\n  toFun a := (a / n, ↑(a.natMod n))\n  invFun p := p.1 * n + ↑p.2\n  left_inv a := by\n    simp_rw [Fin.coe_natCast_eq_mod, natCast_mod, natMod,\n      toNat_of_nonneg (emod_nonneg _ <| natCast_eq_zero.not.2 (NeZero.ne n)), emod_emod,\n      ediv_add_emod']\n  right_inv := fun ⟨q, r, hrn⟩ => by\n    simp only [Fin.val_mk, Prod.mk.inj_iff, Fin.ext_iff]\n    obtain ⟨h1, h2⟩ := Int.natCast_nonneg r, Int.ofNat_lt.2 hrn\n    rw [Int.add_comm, add_mul_ediv_right _ _ (natCast_eq_zero.not.2 (NeZero.ne n)),\n      ediv_eq_zero_of_lt h1 h2, natMod, add_mul_emod_self, emod_eq_of_lt h1 h2, toNat_natCast]\n    exact ⟨q.zero_add, Fin.val_cast_of_lt hrn⟩\n\n"}
{"name":"Fin.castLEquiv_apply","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n m : Nat\nh : LE.le n m\ni : Fin n\n⊢ Eq ((Fin.castLEquiv h) i) ⟨Fin.castLE h i, ⋯⟩","decl":"/-- Promote a `Fin n` into a larger `Fin m`, as a subtype where the underlying\nvalues are retained.\n\nThis is the `Equiv` version of `Fin.castLE`. -/\n@[simps apply symm_apply]\ndef Fin.castLEquiv {n m : ℕ} (h : n ≤ m) : Fin n ≃ { i : Fin m // (i : ℕ) < n } where\n  toFun i := ⟨Fin.castLE h i, by simp⟩\n  invFun i := ⟨i, i.prop⟩\n  left_inv _ := by simp\n  right_inv _ := by simp\n\n"}
{"name":"Fin.castLEquiv_symm_apply","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"n m : Nat\nh : LE.le n m\ni : Subtype fun i => LT.lt (↑i) n\n⊢ Eq ((Fin.castLEquiv h).symm i) ⟨↑↑i, ⋯⟩","decl":"/-- Promote a `Fin n` into a larger `Fin m`, as a subtype where the underlying\nvalues are retained.\n\nThis is the `Equiv` version of `Fin.castLE`. -/\n@[simps apply symm_apply]\ndef Fin.castLEquiv {n m : ℕ} (h : n ≤ m) : Fin n ≃ { i : Fin m // (i : ℕ) < n } where\n  toFun i := ⟨Fin.castLE h i, by simp⟩\n  invFun i := ⟨i, i.prop⟩\n  left_inv _ := by simp\n  right_inv _ := by simp\n\n"}
{"name":"subsingleton_fin_zero","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"⊢ Subsingleton (Fin 0)","decl":"/-- `Fin 0` is a subsingleton. -/\ninstance subsingleton_fin_zero : Subsingleton (Fin 0) :=\n  finZeroEquiv.subsingleton\n\n"}
{"name":"subsingleton_fin_one","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"⊢ Subsingleton (Fin 1)","decl":"/-- `Fin 1` is a subsingleton. -/\ninstance subsingleton_fin_one : Subsingleton (Fin 1) :=\n  finOneEquiv.subsingleton\n\n"}
{"name":"Fin.appendEquiv_apply","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"α : Type u_1\nm n : Nat\nfg : Prod (Fin m → α) (Fin n → α)\na✝ : Fin (HAdd.hAdd m n)\n⊢ Eq ((Fin.appendEquiv m n) fg a✝) (Fin.append fg.1 fg.2 a✝)","decl":"/-- The natural `Equiv` between `(Fin m → α) × (Fin n → α)` and `Fin (m + n) → α`.-/\n@[simps]\ndef Fin.appendEquiv {α : Type*} (m n : ℕ) :\n    (Fin m → α) × (Fin n → α) ≃ (Fin (m + n) → α) where\n  toFun fg := Fin.append fg.1 fg.2\n  invFun f := ⟨fun i ↦ f (Fin.castAdd n i), fun i ↦ f (Fin.natAdd m i)⟩\n  left_inv fg := by simp\n  right_inv f := by simp [Fin.append_castAdd_natAdd]\n"}
{"name":"Fin.appendEquiv_symm_apply","module":"Mathlib.Logic.Equiv.Fin","initialProofState":"α : Type u_1\nm n : Nat\nf : Fin (HAdd.hAdd m n) → α\n⊢ Eq ((Fin.appendEquiv m n).symm f) { fst := fun i => f (Fin.castAdd n i), snd := fun i => f (Fin.natAdd m i) }","decl":"/-- The natural `Equiv` between `(Fin m → α) × (Fin n → α)` and `Fin (m + n) → α`.-/\n@[simps]\ndef Fin.appendEquiv {α : Type*} (m n : ℕ) :\n    (Fin m → α) × (Fin n → α) ≃ (Fin (m + n) → α) where\n  toFun fg := Fin.append fg.1 fg.2\n  invFun f := ⟨fun i ↦ f (Fin.castAdd n i), fun i ↦ f (Fin.natAdd m i)⟩\n  left_inv fg := by simp\n  right_inv f := by simp [Fin.append_castAdd_natAdd]\n"}
