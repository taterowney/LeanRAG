{"name":"CanonicallyOrderedCommSemiring.zero_mul","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyOrderedCommSemiring α\na : α\n⊢ Eq (HMul.hMul 0 a) 0","decl":"set_option linter.deprecated false in\n/-- A canonically ordered commutative semiring is an ordered, commutative semiring in which `a ≤ b`\niff there exists `c` with `b = a + c`. This is satisfied by the natural numbers, for example, but\nnot the integers or other ordered groups. -/\n@[deprecated \"Use `[OrderedCommSemiring α] [CanonicallyOrderedAdd α] [NoZeroDivisors α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommSemiring (α : Type*) extends CanonicallyOrderedAddCommMonoid α,\n    CommSemiring α where\n  /-- No zero divisors. -/\n  protected eq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : α}, a * b = 0 → a = 0 ∨ b = 0\n\n"}
{"name":"CanonicallyOrderedCommSemiring.natCast_zero","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyOrderedCommSemiring α\n⊢ Eq (NatCast.natCast 0) 0","decl":"set_option linter.deprecated false in\n/-- A canonically ordered commutative semiring is an ordered, commutative semiring in which `a ≤ b`\niff there exists `c` with `b = a + c`. This is satisfied by the natural numbers, for example, but\nnot the integers or other ordered groups. -/\n@[deprecated \"Use `[OrderedCommSemiring α] [CanonicallyOrderedAdd α] [NoZeroDivisors α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommSemiring (α : Type*) extends CanonicallyOrderedAddCommMonoid α,\n    CommSemiring α where\n  /-- No zero divisors. -/\n  protected eq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : α}, a * b = 0 → a = 0 ∨ b = 0\n\n"}
{"name":"CanonicallyOrderedCommSemiring.mk.sizeOf_spec","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u_1\ninst✝ : SizeOf α\ntoCanonicallyOrderedAddCommMonoid : CanonicallyOrderedAddCommMonoid α\ntoMul : Mul α\nleft_distrib : ∀ (a b c : α), Eq (HMul.hMul a (HAdd.hAdd b c)) (HAdd.hAdd (HMul.hMul a b) (HMul.hMul a c))\nright_distrib : ∀ (a b c : α), Eq (HMul.hMul (HAdd.hAdd a b) c) (HAdd.hAdd (HMul.hMul a c) (HMul.hMul b c))\nzero_mul : ∀ (a : α), Eq (HMul.hMul 0 a) 0\nmul_zero : ∀ (a : α), Eq (HMul.hMul a 0) 0\nmul_assoc : ∀ (a b c : α), Eq (HMul.hMul (HMul.hMul a b) c) (HMul.hMul a (HMul.hMul b c))\ntoOne : One α\none_mul : ∀ (a : α), Eq (HMul.hMul 1 a) a\nmul_one : ∀ (a : α), Eq (HMul.hMul a 1) a\ntoNatCast : NatCast α\nnatCast_zero : autoParam (Eq (NatCast.natCast 0) 0) _auto✝\nnatCast_succ : autoParam (∀ (n : Nat), Eq (NatCast.natCast (HAdd.hAdd n 1)) (HAdd.hAdd (NatCast.natCast n) 1)) _auto✝\nnpow : Nat → α → α\nnpow_zero : autoParam (∀ (x : α), Eq (npow 0 x) 1) _auto✝\nnpow_succ : autoParam (∀ (n : Nat) (x : α), Eq (npow (HAdd.hAdd n 1) x) (HMul.hMul (npow n x) x)) _auto✝\nmul_comm : ∀ (a b : α), Eq (HMul.hMul a b) (HMul.hMul b a)\neq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : α}, Eq (HMul.hMul a b) 0 → Or (Eq a 0) (Eq b 0)\n⊢ Eq (SizeOf.sizeOf (CanonicallyOrderedCommSemiring.mk toCanonicallyOrderedAddCommMonoid left_distrib right_distrib zero_mul mul_zero mul_assoc one_mul mul_one natCast_zero natCast_succ npow npow_zero npow_succ mul_comm eq_zero_or_eq_zero_of_mul_eq_zero)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toCanonicallyOrderedAddCommMonoid)) (SizeOf.sizeOf toMul)) (SizeOf.sizeOf toOne)) (SizeOf.sizeOf toNatCast)) (SizeOf.sizeOf natCast_zero))","decl":"set_option linter.deprecated false in\n/-- A canonically ordered commutative semiring is an ordered, commutative semiring in which `a ≤ b`\niff there exists `c` with `b = a + c`. This is satisfied by the natural numbers, for example, but\nnot the integers or other ordered groups. -/\n@[deprecated \"Use `[OrderedCommSemiring α] [CanonicallyOrderedAdd α] [NoZeroDivisors α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommSemiring (α : Type*) extends CanonicallyOrderedAddCommMonoid α,\n    CommSemiring α where\n  /-- No zero divisors. -/\n  protected eq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : α}, a * b = 0 → a = 0 ∨ b = 0\n\n"}
{"name":"CanonicallyOrderedCommSemiring.one_mul","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyOrderedCommSemiring α\na : α\n⊢ Eq (HMul.hMul 1 a) a","decl":"set_option linter.deprecated false in\n/-- A canonically ordered commutative semiring is an ordered, commutative semiring in which `a ≤ b`\niff there exists `c` with `b = a + c`. This is satisfied by the natural numbers, for example, but\nnot the integers or other ordered groups. -/\n@[deprecated \"Use `[OrderedCommSemiring α] [CanonicallyOrderedAdd α] [NoZeroDivisors α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommSemiring (α : Type*) extends CanonicallyOrderedAddCommMonoid α,\n    CommSemiring α where\n  /-- No zero divisors. -/\n  protected eq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : α}, a * b = 0 → a = 0 ∨ b = 0\n\n"}
{"name":"CanonicallyOrderedCommSemiring.mul_assoc","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyOrderedCommSemiring α\na b c : α\n⊢ Eq (HMul.hMul (HMul.hMul a b) c) (HMul.hMul a (HMul.hMul b c))","decl":"set_option linter.deprecated false in\n/-- A canonically ordered commutative semiring is an ordered, commutative semiring in which `a ≤ b`\niff there exists `c` with `b = a + c`. This is satisfied by the natural numbers, for example, but\nnot the integers or other ordered groups. -/\n@[deprecated \"Use `[OrderedCommSemiring α] [CanonicallyOrderedAdd α] [NoZeroDivisors α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommSemiring (α : Type*) extends CanonicallyOrderedAddCommMonoid α,\n    CommSemiring α where\n  /-- No zero divisors. -/\n  protected eq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : α}, a * b = 0 → a = 0 ∨ b = 0\n\n"}
{"name":"CanonicallyOrderedCommSemiring.eq_zero_or_eq_zero_of_mul_eq_zero","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyOrderedCommSemiring α\na b : α\na✝ : Eq (HMul.hMul a b) 0\n⊢ Or (Eq a 0) (Eq b 0)","decl":"set_option linter.deprecated false in\n/-- A canonically ordered commutative semiring is an ordered, commutative semiring in which `a ≤ b`\niff there exists `c` with `b = a + c`. This is satisfied by the natural numbers, for example, but\nnot the integers or other ordered groups. -/\n@[deprecated \"Use `[OrderedCommSemiring α] [CanonicallyOrderedAdd α] [NoZeroDivisors α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommSemiring (α : Type*) extends CanonicallyOrderedAddCommMonoid α,\n    CommSemiring α where\n  /-- No zero divisors. -/\n  protected eq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : α}, a * b = 0 → a = 0 ∨ b = 0\n\n"}
{"name":"CanonicallyOrderedCommSemiring.left_distrib","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyOrderedCommSemiring α\na b c : α\n⊢ Eq (HMul.hMul a (HAdd.hAdd b c)) (HAdd.hAdd (HMul.hMul a b) (HMul.hMul a c))","decl":"set_option linter.deprecated false in\n/-- A canonically ordered commutative semiring is an ordered, commutative semiring in which `a ≤ b`\niff there exists `c` with `b = a + c`. This is satisfied by the natural numbers, for example, but\nnot the integers or other ordered groups. -/\n@[deprecated \"Use `[OrderedCommSemiring α] [CanonicallyOrderedAdd α] [NoZeroDivisors α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommSemiring (α : Type*) extends CanonicallyOrderedAddCommMonoid α,\n    CommSemiring α where\n  /-- No zero divisors. -/\n  protected eq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : α}, a * b = 0 → a = 0 ∨ b = 0\n\n"}
{"name":"CanonicallyOrderedCommSemiring.mk.injEq","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u_1\ntoCanonicallyOrderedAddCommMonoid✝ : CanonicallyOrderedAddCommMonoid α\ntoMul✝ : Mul α\nleft_distrib✝ : ∀ (a b c : α), Eq (HMul.hMul a (HAdd.hAdd b c)) (HAdd.hAdd (HMul.hMul a b) (HMul.hMul a c))\nright_distrib✝ : ∀ (a b c : α), Eq (HMul.hMul (HAdd.hAdd a b) c) (HAdd.hAdd (HMul.hMul a c) (HMul.hMul b c))\nzero_mul✝ : ∀ (a : α), Eq (HMul.hMul 0 a) 0\nmul_zero✝ : ∀ (a : α), Eq (HMul.hMul a 0) 0\nmul_assoc✝ : ∀ (a b c : α), Eq (HMul.hMul (HMul.hMul a b) c) (HMul.hMul a (HMul.hMul b c))\ntoOne✝ : One α\none_mul✝ : ∀ (a : α), Eq (HMul.hMul 1 a) a\nmul_one✝ : ∀ (a : α), Eq (HMul.hMul a 1) a\ntoNatCast✝ : NatCast α\nnatCast_zero✝ : autoParam (Eq (NatCast.natCast 0) 0) _auto✝\nnatCast_succ✝ : autoParam (∀ (n : Nat), Eq (NatCast.natCast (HAdd.hAdd n 1)) (HAdd.hAdd (NatCast.natCast n) 1)) _auto✝\nnpow✝ : Nat → α → α\nnpow_zero✝ : autoParam (∀ (x : α), Eq (npow✝ 0 x) 1) _auto✝\nnpow_succ✝ : autoParam (∀ (n : Nat) (x : α), Eq (npow✝ (HAdd.hAdd n 1) x) (HMul.hMul (npow✝ n x) x)) _auto✝\nmul_comm✝ : ∀ (a b : α), Eq (HMul.hMul a b) (HMul.hMul b a)\neq_zero_or_eq_zero_of_mul_eq_zero✝ : ∀ {a b : α}, Eq (HMul.hMul a b) 0 → Or (Eq a 0) (Eq b 0)\ntoCanonicallyOrderedAddCommMonoid : CanonicallyOrderedAddCommMonoid α\ntoMul : Mul α\nleft_distrib : ∀ (a b c : α), Eq (HMul.hMul a (HAdd.hAdd b c)) (HAdd.hAdd (HMul.hMul a b) (HMul.hMul a c))\nright_distrib : ∀ (a b c : α), Eq (HMul.hMul (HAdd.hAdd a b) c) (HAdd.hAdd (HMul.hMul a c) (HMul.hMul b c))\nzero_mul : ∀ (a : α), Eq (HMul.hMul 0 a) 0\nmul_zero : ∀ (a : α), Eq (HMul.hMul a 0) 0\nmul_assoc : ∀ (a b c : α), Eq (HMul.hMul (HMul.hMul a b) c) (HMul.hMul a (HMul.hMul b c))\ntoOne : One α\none_mul : ∀ (a : α), Eq (HMul.hMul 1 a) a\nmul_one : ∀ (a : α), Eq (HMul.hMul a 1) a\ntoNatCast : NatCast α\nnatCast_zero : autoParam (Eq (NatCast.natCast 0) 0) _auto✝\nnatCast_succ : autoParam (∀ (n : Nat), Eq (NatCast.natCast (HAdd.hAdd n 1)) (HAdd.hAdd (NatCast.natCast n) 1)) _auto✝\nnpow : Nat → α → α\nnpow_zero : autoParam (∀ (x : α), Eq (npow 0 x) 1) _auto✝\nnpow_succ : autoParam (∀ (n : Nat) (x : α), Eq (npow (HAdd.hAdd n 1) x) (HMul.hMul (npow n x) x)) _auto✝\nmul_comm : ∀ (a b : α), Eq (HMul.hMul a b) (HMul.hMul b a)\neq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : α}, Eq (HMul.hMul a b) 0 → Or (Eq a 0) (Eq b 0)\n⊢ Eq (Eq (CanonicallyOrderedCommSemiring.mk toCanonicallyOrderedAddCommMonoid✝ left_distrib✝ right_distrib✝ zero_mul✝ mul_zero✝ mul_assoc✝ one_mul✝ mul_one✝ natCast_zero✝ natCast_succ✝ npow✝ npow_zero✝ npow_succ✝ mul_comm✝ eq_zero_or_eq_zero_of_mul_eq_zero✝) (CanonicallyOrderedCommSemiring.mk toCanonicallyOrderedAddCommMonoid left_distrib right_distrib zero_mul mul_zero mul_assoc one_mul mul_one natCast_zero natCast_succ npow npow_zero npow_succ mul_comm eq_zero_or_eq_zero_of_mul_eq_zero)) (And (Eq toCanonicallyOrderedAddCommMonoid✝ toCanonicallyOrderedAddCommMonoid) (And (Eq toMul✝ toMul) (And (Eq toOne✝ toOne) (And (Eq toNatCast✝ toNatCast) (Eq npow✝ npow)))))","decl":"set_option linter.deprecated false in\n/-- A canonically ordered commutative semiring is an ordered, commutative semiring in which `a ≤ b`\niff there exists `c` with `b = a + c`. This is satisfied by the natural numbers, for example, but\nnot the integers or other ordered groups. -/\n@[deprecated \"Use `[OrderedCommSemiring α] [CanonicallyOrderedAdd α] [NoZeroDivisors α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommSemiring (α : Type*) extends CanonicallyOrderedAddCommMonoid α,\n    CommSemiring α where\n  /-- No zero divisors. -/\n  protected eq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : α}, a * b = 0 → a = 0 ∨ b = 0\n\n"}
{"name":"CanonicallyOrderedCommSemiring.npow_succ","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyOrderedCommSemiring α\nn : Nat\nx : α\n⊢ Eq (self.npow (HAdd.hAdd n 1) x) (HMul.hMul (self.npow n x) x)","decl":"set_option linter.deprecated false in\n/-- A canonically ordered commutative semiring is an ordered, commutative semiring in which `a ≤ b`\niff there exists `c` with `b = a + c`. This is satisfied by the natural numbers, for example, but\nnot the integers or other ordered groups. -/\n@[deprecated \"Use `[OrderedCommSemiring α] [CanonicallyOrderedAdd α] [NoZeroDivisors α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommSemiring (α : Type*) extends CanonicallyOrderedAddCommMonoid α,\n    CommSemiring α where\n  /-- No zero divisors. -/\n  protected eq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : α}, a * b = 0 → a = 0 ∨ b = 0\n\n"}
{"name":"CanonicallyOrderedCommSemiring.mul_zero","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyOrderedCommSemiring α\na : α\n⊢ Eq (HMul.hMul a 0) 0","decl":"set_option linter.deprecated false in\n/-- A canonically ordered commutative semiring is an ordered, commutative semiring in which `a ≤ b`\niff there exists `c` with `b = a + c`. This is satisfied by the natural numbers, for example, but\nnot the integers or other ordered groups. -/\n@[deprecated \"Use `[OrderedCommSemiring α] [CanonicallyOrderedAdd α] [NoZeroDivisors α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommSemiring (α : Type*) extends CanonicallyOrderedAddCommMonoid α,\n    CommSemiring α where\n  /-- No zero divisors. -/\n  protected eq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : α}, a * b = 0 → a = 0 ∨ b = 0\n\n"}
{"name":"CanonicallyOrderedCommSemiring.mul_one","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyOrderedCommSemiring α\na : α\n⊢ Eq (HMul.hMul a 1) a","decl":"set_option linter.deprecated false in\n/-- A canonically ordered commutative semiring is an ordered, commutative semiring in which `a ≤ b`\niff there exists `c` with `b = a + c`. This is satisfied by the natural numbers, for example, but\nnot the integers or other ordered groups. -/\n@[deprecated \"Use `[OrderedCommSemiring α] [CanonicallyOrderedAdd α] [NoZeroDivisors α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommSemiring (α : Type*) extends CanonicallyOrderedAddCommMonoid α,\n    CommSemiring α where\n  /-- No zero divisors. -/\n  protected eq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : α}, a * b = 0 → a = 0 ∨ b = 0\n\n"}
{"name":"CanonicallyOrderedCommSemiring.mk.inj","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u_1\ntoCanonicallyOrderedAddCommMonoid✝ : CanonicallyOrderedAddCommMonoid α\ntoMul✝ : Mul α\nleft_distrib✝ : ∀ (a b c : α), Eq (HMul.hMul a (HAdd.hAdd b c)) (HAdd.hAdd (HMul.hMul a b) (HMul.hMul a c))\nright_distrib✝ : ∀ (a b c : α), Eq (HMul.hMul (HAdd.hAdd a b) c) (HAdd.hAdd (HMul.hMul a c) (HMul.hMul b c))\nzero_mul✝ : ∀ (a : α), Eq (HMul.hMul 0 a) 0\nmul_zero✝ : ∀ (a : α), Eq (HMul.hMul a 0) 0\nmul_assoc✝ : ∀ (a b c : α), Eq (HMul.hMul (HMul.hMul a b) c) (HMul.hMul a (HMul.hMul b c))\ntoOne✝ : One α\none_mul✝ : ∀ (a : α), Eq (HMul.hMul 1 a) a\nmul_one✝ : ∀ (a : α), Eq (HMul.hMul a 1) a\ntoNatCast✝ : NatCast α\nnatCast_zero✝ : autoParam (Eq (NatCast.natCast 0) 0) _auto✝\nnatCast_succ✝ : autoParam (∀ (n : Nat), Eq (NatCast.natCast (HAdd.hAdd n 1)) (HAdd.hAdd (NatCast.natCast n) 1)) _auto✝\nnpow✝ : Nat → α → α\nnpow_zero✝ : autoParam (∀ (x : α), Eq (npow✝ 0 x) 1) _auto✝\nnpow_succ✝ : autoParam (∀ (n : Nat) (x : α), Eq (npow✝ (HAdd.hAdd n 1) x) (HMul.hMul (npow✝ n x) x)) _auto✝\nmul_comm✝ : ∀ (a b : α), Eq (HMul.hMul a b) (HMul.hMul b a)\neq_zero_or_eq_zero_of_mul_eq_zero✝ : ∀ {a b : α}, Eq (HMul.hMul a b) 0 → Or (Eq a 0) (Eq b 0)\ntoCanonicallyOrderedAddCommMonoid : CanonicallyOrderedAddCommMonoid α\ntoMul : Mul α\nleft_distrib : ∀ (a b c : α), Eq (HMul.hMul a (HAdd.hAdd b c)) (HAdd.hAdd (HMul.hMul a b) (HMul.hMul a c))\nright_distrib : ∀ (a b c : α), Eq (HMul.hMul (HAdd.hAdd a b) c) (HAdd.hAdd (HMul.hMul a c) (HMul.hMul b c))\nzero_mul : ∀ (a : α), Eq (HMul.hMul 0 a) 0\nmul_zero : ∀ (a : α), Eq (HMul.hMul a 0) 0\nmul_assoc : ∀ (a b c : α), Eq (HMul.hMul (HMul.hMul a b) c) (HMul.hMul a (HMul.hMul b c))\ntoOne : One α\none_mul : ∀ (a : α), Eq (HMul.hMul 1 a) a\nmul_one : ∀ (a : α), Eq (HMul.hMul a 1) a\ntoNatCast : NatCast α\nnatCast_zero : autoParam (Eq (NatCast.natCast 0) 0) _auto✝\nnatCast_succ : autoParam (∀ (n : Nat), Eq (NatCast.natCast (HAdd.hAdd n 1)) (HAdd.hAdd (NatCast.natCast n) 1)) _auto✝\nnpow : Nat → α → α\nnpow_zero : autoParam (∀ (x : α), Eq (npow 0 x) 1) _auto✝\nnpow_succ : autoParam (∀ (n : Nat) (x : α), Eq (npow (HAdd.hAdd n 1) x) (HMul.hMul (npow n x) x)) _auto✝\nmul_comm : ∀ (a b : α), Eq (HMul.hMul a b) (HMul.hMul b a)\neq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : α}, Eq (HMul.hMul a b) 0 → Or (Eq a 0) (Eq b 0)\nx✝ : Eq (CanonicallyOrderedCommSemiring.mk toCanonicallyOrderedAddCommMonoid✝ left_distrib✝ right_distrib✝ zero_mul✝ mul_zero✝ mul_assoc✝ one_mul✝ mul_one✝ natCast_zero✝ natCast_succ✝ npow✝ npow_zero✝ npow_succ✝ mul_comm✝ eq_zero_or_eq_zero_of_mul_eq_zero✝) (CanonicallyOrderedCommSemiring.mk toCanonicallyOrderedAddCommMonoid left_distrib right_distrib zero_mul mul_zero mul_assoc one_mul mul_one natCast_zero natCast_succ npow npow_zero npow_succ mul_comm eq_zero_or_eq_zero_of_mul_eq_zero)\n⊢ And (Eq toCanonicallyOrderedAddCommMonoid✝ toCanonicallyOrderedAddCommMonoid) (And (Eq toMul✝ toMul) (And (Eq toOne✝ toOne) (And (Eq toNatCast✝ toNatCast) (Eq npow✝ npow))))","decl":"set_option linter.deprecated false in\n/-- A canonically ordered commutative semiring is an ordered, commutative semiring in which `a ≤ b`\niff there exists `c` with `b = a + c`. This is satisfied by the natural numbers, for example, but\nnot the integers or other ordered groups. -/\n@[deprecated \"Use `[OrderedCommSemiring α] [CanonicallyOrderedAdd α] [NoZeroDivisors α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommSemiring (α : Type*) extends CanonicallyOrderedAddCommMonoid α,\n    CommSemiring α where\n  /-- No zero divisors. -/\n  protected eq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : α}, a * b = 0 → a = 0 ∨ b = 0\n\n"}
{"name":"CanonicallyOrderedCommSemiring.npow_zero","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyOrderedCommSemiring α\nx : α\n⊢ Eq (self.npow 0 x) 1","decl":"set_option linter.deprecated false in\n/-- A canonically ordered commutative semiring is an ordered, commutative semiring in which `a ≤ b`\niff there exists `c` with `b = a + c`. This is satisfied by the natural numbers, for example, but\nnot the integers or other ordered groups. -/\n@[deprecated \"Use `[OrderedCommSemiring α] [CanonicallyOrderedAdd α] [NoZeroDivisors α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommSemiring (α : Type*) extends CanonicallyOrderedAddCommMonoid α,\n    CommSemiring α where\n  /-- No zero divisors. -/\n  protected eq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : α}, a * b = 0 → a = 0 ∨ b = 0\n\n"}
{"name":"CanonicallyOrderedCommSemiring.mul_comm","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyOrderedCommSemiring α\na b : α\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"set_option linter.deprecated false in\n/-- A canonically ordered commutative semiring is an ordered, commutative semiring in which `a ≤ b`\niff there exists `c` with `b = a + c`. This is satisfied by the natural numbers, for example, but\nnot the integers or other ordered groups. -/\n@[deprecated \"Use `[OrderedCommSemiring α] [CanonicallyOrderedAdd α] [NoZeroDivisors α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommSemiring (α : Type*) extends CanonicallyOrderedAddCommMonoid α,\n    CommSemiring α where\n  /-- No zero divisors. -/\n  protected eq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : α}, a * b = 0 → a = 0 ∨ b = 0\n\n"}
{"name":"CanonicallyOrderedCommSemiring.right_distrib","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyOrderedCommSemiring α\na b c : α\n⊢ Eq (HMul.hMul (HAdd.hAdd a b) c) (HAdd.hAdd (HMul.hMul a c) (HMul.hMul b c))","decl":"set_option linter.deprecated false in\n/-- A canonically ordered commutative semiring is an ordered, commutative semiring in which `a ≤ b`\niff there exists `c` with `b = a + c`. This is satisfied by the natural numbers, for example, but\nnot the integers or other ordered groups. -/\n@[deprecated \"Use `[OrderedCommSemiring α] [CanonicallyOrderedAdd α] [NoZeroDivisors α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommSemiring (α : Type*) extends CanonicallyOrderedAddCommMonoid α,\n    CommSemiring α where\n  /-- No zero divisors. -/\n  protected eq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : α}, a * b = 0 → a = 0 ∨ b = 0\n\n"}
{"name":"CanonicallyOrderedCommSemiring.natCast_succ","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u_1\nself : CanonicallyOrderedCommSemiring α\nn : Nat\n⊢ Eq (NatCast.natCast (HAdd.hAdd n 1)) (HAdd.hAdd (NatCast.natCast n) 1)","decl":"set_option linter.deprecated false in\n/-- A canonically ordered commutative semiring is an ordered, commutative semiring in which `a ≤ b`\niff there exists `c` with `b = a + c`. This is satisfied by the natural numbers, for example, but\nnot the integers or other ordered groups. -/\n@[deprecated \"Use `[OrderedCommSemiring α] [CanonicallyOrderedAdd α] [NoZeroDivisors α]` instead.\"\n  (since := \"2025-01-13\")]\nstructure CanonicallyOrderedCommSemiring (α : Type*) extends CanonicallyOrderedAddCommMonoid α,\n    CommSemiring α where\n  /-- No zero divisors. -/\n  protected eq_zero_or_eq_zero_of_mul_eq_zero : ∀ {a b : α}, a * b = 0 → a = 0 ∨ b = 0\n\n"}
{"name":"CanonicallyOrderedAdd.toZeroLEOneClass","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u\ninst✝³ : AddZeroClass α\ninst✝² : One α\ninst✝¹ : LE α\ninst✝ : CanonicallyOrderedAdd α\n⊢ ZeroLEOneClass α","decl":"instance (priority := 10) CanonicallyOrderedAdd.toZeroLEOneClass\n    [AddZeroClass α] [One α] [LE α] [CanonicallyOrderedAdd α] : ZeroLEOneClass α where\n  zero_le_one := zero_le _\n\n-- this holds more generally if we refactor `Odd` to use\n-- either `2 • t` or `t + t` instead of `2 * t`.\n"}
{"name":"Odd.pos","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u\ninst✝³ : Semiring α\ninst✝² : PartialOrder α\ninst✝¹ : CanonicallyOrderedAdd α\ninst✝ : Nontrivial α\na : α\na✝ : Odd a\n⊢ LT.lt 0 a","decl":"lemma Odd.pos [Semiring α] [PartialOrder α] [CanonicallyOrderedAdd α] [Nontrivial α] {a : α} :\n    Odd a → 0 < a := by\n  rintro ⟨k, rfl⟩; simp\n\n"}
{"name":"CanonicallyOrderedAdd.toMulLeftMono","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u\ninst✝² : NonUnitalNonAssocSemiring α\ninst✝¹ : LE α\ninst✝ : CanonicallyOrderedAdd α\n⊢ MulLeftMono α","decl":"instance (priority := 100) toMulLeftMono [NonUnitalNonAssocSemiring α]\n    [LE α] [CanonicallyOrderedAdd α] : MulLeftMono α := by\n  refine ⟨fun a b c h => ?_⟩; dsimp\n  rcases exists_add_of_le h with ⟨c, rfl⟩\n  rw [mul_add]\n  apply self_le_add_right\n\n"}
{"name":"CanonicallyOrderedAdd.mul_pos","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u\ninst✝³ : CommSemiring α\ninst✝² : PartialOrder α\ninst✝¹ : CanonicallyOrderedAdd α\ninst✝ : NoZeroDivisors α\na b : α\n⊢ Iff (LT.lt 0 (HMul.hMul a b)) (And (LT.lt 0 a) (LT.lt 0 b))","decl":"@[simp]\nprotected theorem mul_pos [NoZeroDivisors α] {a b : α} :\n    0 < a * b ↔ 0 < a ∧ 0 < b := by\n  simp only [pos_iff_ne_zero, ne_eq, mul_eq_zero, not_or]\n\n"}
{"name":"CanonicallyOrderedAdd.pow_pos","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u\ninst✝³ : CommSemiring α\ninst✝² : PartialOrder α\ninst✝¹ : CanonicallyOrderedAdd α\ninst✝ : NoZeroDivisors α\na : α\nha : LT.lt 0 a\nn : Nat\n⊢ LT.lt 0 (HPow.hPow a n)","decl":"lemma pow_pos [NoZeroDivisors α] {a : α} (ha : 0 < a) (n : ℕ) : 0 < a ^ n :=\n  pos_iff_ne_zero.2 <| pow_ne_zero _ ha.ne'\n\n"}
{"name":"CanonicallyOrderedAdd.mul_lt_mul_of_lt_of_lt","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u\ninst✝³ : CommSemiring α\ninst✝² : PartialOrder α\ninst✝¹ : CanonicallyOrderedAdd α\ninst✝ : PosMulStrictMono α\na b c d : α\nhab : LT.lt a b\nhcd : LT.lt c d\n⊢ LT.lt (HMul.hMul a c) (HMul.hMul b d)","decl":"protected lemma mul_lt_mul_of_lt_of_lt\n    [PosMulStrictMono α] {a b c d : α} (hab : a < b) (hcd : c < d) :\n    a * c < b * d := by\n  -- TODO: This should be an instance but it currently times out\n  have := posMulStrictMono_iff_mulPosStrictMono.1 ‹_›\n  obtain rfl | hc := eq_zero_or_pos c\n  · rw [mul_zero]\n    exact mul_pos ((zero_le _).trans_lt hab) hcd\n  · exact mul_lt_mul_of_pos' hab hcd hc ((zero_le _).trans_lt hab)\n\n"}
{"name":"AddLECancellable.mul_tsub","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u\ninst✝⁵ : NonUnitalNonAssocSemiring α\ninst✝⁴ : PartialOrder α\ninst✝³ : CanonicallyOrderedAdd α\ninst✝² : Sub α\ninst✝¹ : OrderedSub α\ninst✝ : IsTotal α fun x1 x2 => LE.le x1 x2\na b c : α\nh : AddLECancellable (HMul.hMul a c)\n⊢ Eq (HMul.hMul a (HSub.hSub b c)) (HSub.hSub (HMul.hMul a b) (HMul.hMul a c))","decl":"protected theorem mul_tsub {a b c : α}\n    (h : AddLECancellable (a * c)) : a * (b - c) = a * b - a * c := by\n  obtain (hbc | hcb) := total_of (· ≤ ·) b c\n  · rw [tsub_eq_zero_iff_le.2 hbc, mul_zero, tsub_eq_zero_iff_le.2 (mul_le_mul_left' hbc a)]\n  · apply h.eq_tsub_of_add_eq\n    rw [← mul_add, tsub_add_cancel_of_le hcb]\n\n"}
{"name":"AddLECancellable.tsub_mul","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u\ninst✝⁶ : NonUnitalNonAssocSemiring α\ninst✝⁵ : PartialOrder α\ninst✝⁴ : CanonicallyOrderedAdd α\ninst✝³ : Sub α\ninst✝² : OrderedSub α\ninst✝¹ : IsTotal α fun x1 x2 => LE.le x1 x2\ninst✝ : MulRightMono α\na b c : α\nh : AddLECancellable (HMul.hMul b c)\n⊢ Eq (HMul.hMul (HSub.hSub a b) c) (HSub.hSub (HMul.hMul a c) (HMul.hMul b c))","decl":"protected theorem tsub_mul [MulRightMono α] {a b c : α}\n    (h : AddLECancellable (b * c)) : (a - b) * c = a * c - b * c := by\n  obtain (hab | hba) := total_of (· ≤ ·) a b\n  · rw [tsub_eq_zero_iff_le.2 hab, zero_mul, tsub_eq_zero_iff_le.2 (mul_le_mul_right' hab c)]\n  · apply h.eq_tsub_of_add_eq\n    rw [← add_mul, tsub_add_cancel_of_le hba]\n\n"}
{"name":"mul_tsub","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u\ninst✝⁶ : NonUnitalNonAssocSemiring α\ninst✝⁵ : PartialOrder α\ninst✝⁴ : CanonicallyOrderedAdd α\ninst✝³ : Sub α\ninst✝² : OrderedSub α\ninst✝¹ : IsTotal α fun x1 x2 => LE.le x1 x2\ninst✝ : AddLeftReflectLE α\na b c : α\n⊢ Eq (HMul.hMul a (HSub.hSub b c)) (HSub.hSub (HMul.hMul a b) (HMul.hMul a c))","decl":"theorem mul_tsub (a b c : α) : a * (b - c) = a * b - a * c :=\n  Contravariant.AddLECancellable.mul_tsub\n\n"}
{"name":"tsub_mul","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u\ninst✝⁷ : NonUnitalNonAssocSemiring α\ninst✝⁶ : PartialOrder α\ninst✝⁵ : CanonicallyOrderedAdd α\ninst✝⁴ : Sub α\ninst✝³ : OrderedSub α\ninst✝² : IsTotal α fun x1 x2 => LE.le x1 x2\ninst✝¹ : AddLeftReflectLE α\ninst✝ : MulRightMono α\na b c : α\n⊢ Eq (HMul.hMul (HSub.hSub a b) c) (HSub.hSub (HMul.hMul a c) (HMul.hMul b c))","decl":"theorem tsub_mul [MulRightMono α] (a b c : α) :\n    (a - b) * c = a * c - b * c :=\n  Contravariant.AddLECancellable.tsub_mul\n\n"}
{"name":"mul_tsub_one","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u\ninst✝⁶ : NonAssocSemiring α\ninst✝⁵ : PartialOrder α\ninst✝⁴ : CanonicallyOrderedAdd α\ninst✝³ : Sub α\ninst✝² : OrderedSub α\ninst✝¹ : IsTotal α fun x1 x2 => LE.le x1 x2\ninst✝ : AddLeftReflectLE α\na b : α\n⊢ Eq (HMul.hMul a (HSub.hSub b 1)) (HSub.hSub (HMul.hMul a b) a)","decl":"lemma mul_tsub_one [AddLeftReflectLE α] (a b : α) :\n    a * (b - 1) = a * b - a := by rw [mul_tsub, mul_one]\n"}
{"name":"tsub_one_mul","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u\ninst✝⁷ : NonAssocSemiring α\ninst✝⁶ : PartialOrder α\ninst✝⁵ : CanonicallyOrderedAdd α\ninst✝⁴ : Sub α\ninst✝³ : OrderedSub α\ninst✝² : IsTotal α fun x1 x2 => LE.le x1 x2\ninst✝¹ : MulRightMono α\ninst✝ : AddLeftReflectLE α\na b : α\n⊢ Eq (HMul.hMul (HSub.hSub a 1) b) (HSub.hSub (HMul.hMul a b) b)","decl":"lemma tsub_one_mul [MulRightMono α] [AddLeftReflectLE α] (a b : α) :\n    (a - 1) * b = a * b - b := by rw [tsub_mul, one_mul]\n\n"}
{"name":"mul_self_tsub_mul_self","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u\ninst✝⁶ : CommSemiring α\ninst✝⁵ : PartialOrder α\ninst✝⁴ : CanonicallyOrderedAdd α\ninst✝³ : Sub α\ninst✝² : OrderedSub α\ninst✝¹ : IsTotal α fun x1 x2 => LE.le x1 x2\ninst✝ : AddLeftReflectLE α\na b : α\n⊢ Eq (HSub.hSub (HMul.hMul a a) (HMul.hMul b b)) (HMul.hMul (HAdd.hAdd a b) (HSub.hSub a b))","decl":"/-- The `tsub` version of `mul_self_sub_mul_self`. Notably, this holds for `Nat` and `NNReal`. -/\ntheorem mul_self_tsub_mul_self (a b : α) :\n    a * a - b * b = (a + b) * (a - b) := by\n  rw [mul_tsub, add_mul, add_mul, tsub_add_eq_tsub_tsub, mul_comm b a, add_tsub_cancel_right]\n\n"}
{"name":"sq_tsub_sq","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u\ninst✝⁶ : CommSemiring α\ninst✝⁵ : PartialOrder α\ninst✝⁴ : CanonicallyOrderedAdd α\ninst✝³ : Sub α\ninst✝² : OrderedSub α\ninst✝¹ : IsTotal α fun x1 x2 => LE.le x1 x2\ninst✝ : AddLeftReflectLE α\na b : α\n⊢ Eq (HSub.hSub (HPow.hPow a 2) (HPow.hPow b 2)) (HMul.hMul (HAdd.hAdd a b) (HSub.hSub a b))","decl":"/-- The `tsub` version of `sq_sub_sq`. Notably, this holds for `Nat` and `NNReal`. -/\ntheorem sq_tsub_sq (a b : α) : a ^ 2 - b ^ 2 = (a + b) * (a - b) := by\n  rw [sq, sq, mul_self_tsub_mul_self]\n\n"}
{"name":"mul_self_tsub_one","module":"Mathlib.Algebra.Order.Ring.Canonical","initialProofState":"α : Type u\ninst✝⁶ : CommSemiring α\ninst✝⁵ : PartialOrder α\ninst✝⁴ : CanonicallyOrderedAdd α\ninst✝³ : Sub α\ninst✝² : OrderedSub α\ninst✝¹ : IsTotal α fun x1 x2 => LE.le x1 x2\ninst✝ : AddLeftReflectLE α\na : α\n⊢ Eq (HSub.hSub (HMul.hMul a a) 1) (HMul.hMul (HAdd.hAdd a 1) (HSub.hSub a 1))","decl":"theorem mul_self_tsub_one (a : α) : a * a - 1 = (a + 1) * (a - 1) := by\n  rw [← mul_self_tsub_mul_self, mul_one]\n\n"}
