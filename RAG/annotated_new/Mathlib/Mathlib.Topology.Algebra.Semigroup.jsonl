{"name":"exists_idempotent_of_compact_t2_of_continuous_add_left","module":"Mathlib.Topology.Algebra.Semigroup","initialProofState":"M : Type u_1\ninst✝⁴ : Nonempty M\ninst✝³ : AddSemigroup M\ninst✝² : TopologicalSpace M\ninst✝¹ : CompactSpace M\ninst✝ : T2Space M\ncontinuous_mul_left : ∀ (r : M), Continuous fun x => HAdd.hAdd x r\n⊢ Exists fun m => Eq (HAdd.hAdd m m) m","decl":"/-- Any nonempty compact Hausdorff semigroup where right-multiplication is continuous contains\nan idempotent, i.e. an `m` such that `m * m = m`. -/\n@[to_additive\n      \"Any nonempty compact Hausdorff additive semigroup where right-addition is continuous\n      contains an idempotent, i.e. an `m` such that `m + m = m`\"]\ntheorem exists_idempotent_of_compact_t2_of_continuous_mul_left {M} [Nonempty M] [Semigroup M]\n    [TopologicalSpace M] [CompactSpace M] [T2Space M]\n    (continuous_mul_left : ∀ r : M, Continuous (· * r)) : ∃ m : M, m * m = m := by\n  /- We apply Zorn's lemma to the poset of nonempty closed subsemigroups of `M`.\n     It will turn out that any minimal element is `{m}` for an idempotent `m : M`. -/\n  let S : Set (Set M) :=\n    { N | IsClosed N ∧ N.Nonempty ∧ ∀ (m) (_ : m ∈ N) (m') (_ : m' ∈ N), m * m' ∈ N }\n  rsuffices ⟨N, hN⟩ : ∃ N', Minimal (· ∈ S) N'\n  · obtain ⟨N_closed, ⟨m, hm⟩, N_mul⟩ := hN.prop\n    use m\n    /- We now have an element `m : M` of a minimal subsemigroup `N`, and want to show `m + m = m`.\n    We first show that every element of `N` is of the form `m' + m`. -/\n    have scaling_eq_self : (· * m) '' N = N := by\n      apply hN.eq_of_subset\n      · refine ⟨(continuous_mul_left m).isClosedMap _ N_closed, ⟨_, ⟨m, hm, rfl⟩⟩, ?_⟩\n        rintro _ ⟨m'', hm'', rfl⟩ _ ⟨m', hm', rfl⟩\n        exact ⟨m'' * m * m', N_mul _ (N_mul _ hm'' _ hm) _ hm', mul_assoc _ _ _⟩\n      · rintro _ ⟨m', hm', rfl⟩\n        exact N_mul _ hm' _ hm\n    /- In particular, this means that `m' * m = m` for some `m'`. We now use minimality again\n       to show that this holds for all `m' ∈ N`. -/\n    have absorbing_eq_self : N ∩ { m' | m' * m = m } = N := by\n      apply hN.eq_of_subset\n      · refine ⟨N_closed.inter ((T1Space.t1 m).preimage (continuous_mul_left m)), ?_, ?_⟩\n        · rwa [← scaling_eq_self] at hm\n        · rintro m'' ⟨mem'', eq'' : _ = m⟩ m' ⟨mem', eq' : _ = m⟩\n          refine ⟨N_mul _ mem'' _ mem', ?_⟩\n          rw [Set.mem_setOf_eq, mul_assoc, eq', eq'']\n      apply Set.inter_subset_left\n    rw [← absorbing_eq_self] at hm\n    exact hm.2\n  refine zorn_superset _ fun c hcs hc => ?_\n  refine\n    ⟨⋂₀ c, ⟨isClosed_sInter fun t ht => (hcs ht).1, ?_, fun m hm m' hm' => ?_⟩, fun s hs =>\n      Set.sInter_subset_of_mem hs⟩\n  · obtain rfl | hcnemp := c.eq_empty_or_nonempty\n    · rw [Set.sInter_empty]\n      apply Set.univ_nonempty\n    convert\n      @IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed _ _ _ hcnemp.coe_sort\n        ((↑) : c → Set M) ?_ ?_ ?_ ?_\n    · exact Set.sInter_eq_iInter\n    · refine DirectedOn.directed_val (IsChain.directedOn hc.symm)\n    exacts [fun i => (hcs i.prop).2.1, fun i => (hcs i.prop).1.isCompact, fun i => (hcs i.prop).1]\n  · rw [Set.mem_sInter]\n    exact fun t ht => (hcs ht).2.2 m (Set.mem_sInter.mp hm t ht) m' (Set.mem_sInter.mp hm' t ht)\n\n"}
{"name":"exists_idempotent_of_compact_t2_of_continuous_mul_left","module":"Mathlib.Topology.Algebra.Semigroup","initialProofState":"M : Type u_1\ninst✝⁴ : Nonempty M\ninst✝³ : Semigroup M\ninst✝² : TopologicalSpace M\ninst✝¹ : CompactSpace M\ninst✝ : T2Space M\ncontinuous_mul_left : ∀ (r : M), Continuous fun x => HMul.hMul x r\n⊢ Exists fun m => Eq (HMul.hMul m m) m","decl":"/-- Any nonempty compact Hausdorff semigroup where right-multiplication is continuous contains\nan idempotent, i.e. an `m` such that `m * m = m`. -/\n@[to_additive\n      \"Any nonempty compact Hausdorff additive semigroup where right-addition is continuous\n      contains an idempotent, i.e. an `m` such that `m + m = m`\"]\ntheorem exists_idempotent_of_compact_t2_of_continuous_mul_left {M} [Nonempty M] [Semigroup M]\n    [TopologicalSpace M] [CompactSpace M] [T2Space M]\n    (continuous_mul_left : ∀ r : M, Continuous (· * r)) : ∃ m : M, m * m = m := by\n  /- We apply Zorn's lemma to the poset of nonempty closed subsemigroups of `M`.\n     It will turn out that any minimal element is `{m}` for an idempotent `m : M`. -/\n  let S : Set (Set M) :=\n    { N | IsClosed N ∧ N.Nonempty ∧ ∀ (m) (_ : m ∈ N) (m') (_ : m' ∈ N), m * m' ∈ N }\n  rsuffices ⟨N, hN⟩ : ∃ N', Minimal (· ∈ S) N'\n  · obtain ⟨N_closed, ⟨m, hm⟩, N_mul⟩ := hN.prop\n    use m\n    /- We now have an element `m : M` of a minimal subsemigroup `N`, and want to show `m + m = m`.\n    We first show that every element of `N` is of the form `m' + m`. -/\n    have scaling_eq_self : (· * m) '' N = N := by\n      apply hN.eq_of_subset\n      · refine ⟨(continuous_mul_left m).isClosedMap _ N_closed, ⟨_, ⟨m, hm, rfl⟩⟩, ?_⟩\n        rintro _ ⟨m'', hm'', rfl⟩ _ ⟨m', hm', rfl⟩\n        exact ⟨m'' * m * m', N_mul _ (N_mul _ hm'' _ hm) _ hm', mul_assoc _ _ _⟩\n      · rintro _ ⟨m', hm', rfl⟩\n        exact N_mul _ hm' _ hm\n    /- In particular, this means that `m' * m = m` for some `m'`. We now use minimality again\n       to show that this holds for all `m' ∈ N`. -/\n    have absorbing_eq_self : N ∩ { m' | m' * m = m } = N := by\n      apply hN.eq_of_subset\n      · refine ⟨N_closed.inter ((T1Space.t1 m).preimage (continuous_mul_left m)), ?_, ?_⟩\n        · rwa [← scaling_eq_self] at hm\n        · rintro m'' ⟨mem'', eq'' : _ = m⟩ m' ⟨mem', eq' : _ = m⟩\n          refine ⟨N_mul _ mem'' _ mem', ?_⟩\n          rw [Set.mem_setOf_eq, mul_assoc, eq', eq'']\n      apply Set.inter_subset_left\n    rw [← absorbing_eq_self] at hm\n    exact hm.2\n  refine zorn_superset _ fun c hcs hc => ?_\n  refine\n    ⟨⋂₀ c, ⟨isClosed_sInter fun t ht => (hcs ht).1, ?_, fun m hm m' hm' => ?_⟩, fun s hs =>\n      Set.sInter_subset_of_mem hs⟩\n  · obtain rfl | hcnemp := c.eq_empty_or_nonempty\n    · rw [Set.sInter_empty]\n      apply Set.univ_nonempty\n    convert\n      @IsCompact.nonempty_iInter_of_directed_nonempty_isCompact_isClosed _ _ _ hcnemp.coe_sort\n        ((↑) : c → Set M) ?_ ?_ ?_ ?_\n    · exact Set.sInter_eq_iInter\n    · refine DirectedOn.directed_val (IsChain.directedOn hc.symm)\n    exacts [fun i => (hcs i.prop).2.1, fun i => (hcs i.prop).1.isCompact, fun i => (hcs i.prop).1]\n  · rw [Set.mem_sInter]\n    exact fun t ht => (hcs ht).2.2 m (Set.mem_sInter.mp hm t ht) m' (Set.mem_sInter.mp hm' t ht)\n\n"}
{"name":"exists_idempotent_in_compact_add_subsemigroup","module":"Mathlib.Topology.Algebra.Semigroup","initialProofState":"M : Type u_1\ninst✝² : AddSemigroup M\ninst✝¹ : TopologicalSpace M\ninst✝ : T2Space M\ncontinuous_mul_left : ∀ (r : M), Continuous fun x => HAdd.hAdd x r\ns : Set M\nsnemp : s.Nonempty\ns_compact : IsCompact s\ns_add : ∀ (x : M), Membership.mem s x → ∀ (y : M), Membership.mem s y → Membership.mem s (HAdd.hAdd x y)\n⊢ Exists fun m => And (Membership.mem s m) (Eq (HAdd.hAdd m m) m)","decl":"/-- A version of `exists_idempotent_of_compact_t2_of_continuous_mul_left` where the idempotent lies\nin some specified nonempty compact subsemigroup. -/\n@[to_additive exists_idempotent_in_compact_add_subsemigroup\n      \"A version of\n      `exists_idempotent_of_compact_t2_of_continuous_add_left` where the idempotent lies in\n      some specified nonempty compact additive subsemigroup.\"]\ntheorem exists_idempotent_in_compact_subsemigroup {M} [Semigroup M] [TopologicalSpace M] [T2Space M]\n    (continuous_mul_left : ∀ r : M, Continuous (· * r)) (s : Set M) (snemp : s.Nonempty)\n    (s_compact : IsCompact s) (s_add : ∀ᵉ (x ∈ s) (y ∈ s), x * y ∈ s) :\n    ∃ m ∈ s, m * m = m := by\n  let M' := { m // m ∈ s }\n  letI : Semigroup M' :=\n    { mul := fun p q => ⟨p.1 * q.1, s_add _ p.2 _ q.2⟩\n      mul_assoc := fun p q r => Subtype.eq (mul_assoc _ _ _) }\n  haveI : CompactSpace M' := isCompact_iff_compactSpace.mp s_compact\n  haveI : Nonempty M' := nonempty_subtype.mpr snemp\n  have : ∀ p : M', Continuous (· * p) := fun p =>\n    ((continuous_mul_left p.1).comp continuous_subtype_val).subtype_mk _\n  obtain ⟨⟨m, hm⟩, idem⟩ := exists_idempotent_of_compact_t2_of_continuous_mul_left this\n  exact ⟨m, hm, Subtype.ext_iff.mp idem⟩\n"}
{"name":"exists_idempotent_in_compact_subsemigroup","module":"Mathlib.Topology.Algebra.Semigroup","initialProofState":"M : Type u_1\ninst✝² : Semigroup M\ninst✝¹ : TopologicalSpace M\ninst✝ : T2Space M\ncontinuous_mul_left : ∀ (r : M), Continuous fun x => HMul.hMul x r\ns : Set M\nsnemp : s.Nonempty\ns_compact : IsCompact s\ns_add : ∀ (x : M), Membership.mem s x → ∀ (y : M), Membership.mem s y → Membership.mem s (HMul.hMul x y)\n⊢ Exists fun m => And (Membership.mem s m) (Eq (HMul.hMul m m) m)","decl":"/-- A version of `exists_idempotent_of_compact_t2_of_continuous_mul_left` where the idempotent lies\nin some specified nonempty compact subsemigroup. -/\n@[to_additive exists_idempotent_in_compact_add_subsemigroup\n      \"A version of\n      `exists_idempotent_of_compact_t2_of_continuous_add_left` where the idempotent lies in\n      some specified nonempty compact additive subsemigroup.\"]\ntheorem exists_idempotent_in_compact_subsemigroup {M} [Semigroup M] [TopologicalSpace M] [T2Space M]\n    (continuous_mul_left : ∀ r : M, Continuous (· * r)) (s : Set M) (snemp : s.Nonempty)\n    (s_compact : IsCompact s) (s_add : ∀ᵉ (x ∈ s) (y ∈ s), x * y ∈ s) :\n    ∃ m ∈ s, m * m = m := by\n  let M' := { m // m ∈ s }\n  letI : Semigroup M' :=\n    { mul := fun p q => ⟨p.1 * q.1, s_add _ p.2 _ q.2⟩\n      mul_assoc := fun p q r => Subtype.eq (mul_assoc _ _ _) }\n  haveI : CompactSpace M' := isCompact_iff_compactSpace.mp s_compact\n  haveI : Nonempty M' := nonempty_subtype.mpr snemp\n  have : ∀ p : M', Continuous (· * p) := fun p =>\n    ((continuous_mul_left p.1).comp continuous_subtype_val).subtype_mk _\n  obtain ⟨⟨m, hm⟩, idem⟩ := exists_idempotent_of_compact_t2_of_continuous_mul_left this\n  exact ⟨m, hm, Subtype.ext_iff.mp idem⟩\n"}
