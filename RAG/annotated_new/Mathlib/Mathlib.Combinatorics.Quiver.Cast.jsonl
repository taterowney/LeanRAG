{"name":"Quiver.Hom.cast_eq_cast","module":"Mathlib.Combinatorics.Quiver.Cast","initialProofState":"U : Type u_1\ninst✝ : Quiver U\nu v u' v' : U\nhu : Eq u u'\nhv : Eq v v'\ne : Quiver.Hom u v\n⊢ Eq (Quiver.Hom.cast hu hv e) (cast ⋯ e)","decl":"theorem Hom.cast_eq_cast {u v u' v' : U} (hu : u = u') (hv : v = v') (e : u ⟶ v) :\n    e.cast hu hv = _root_.cast (by {rw [hu, hv]}) e := by\n  subst_vars\n  rfl\n\n"}
{"name":"Quiver.Hom.cast_rfl_rfl","module":"Mathlib.Combinatorics.Quiver.Cast","initialProofState":"U : Type u_1\ninst✝ : Quiver U\nu v : U\ne : Quiver.Hom u v\n⊢ Eq (Quiver.Hom.cast ⋯ ⋯ e) e","decl":"@[simp]\ntheorem Hom.cast_rfl_rfl {u v : U} (e : u ⟶ v) : e.cast rfl rfl = e :=\n  rfl\n\n"}
{"name":"Quiver.Hom.cast_cast","module":"Mathlib.Combinatorics.Quiver.Cast","initialProofState":"U : Type u_1\ninst✝ : Quiver U\nu v u' v' u'' v'' : U\ne : Quiver.Hom u v\nhu : Eq u u'\nhv : Eq v v'\nhu' : Eq u' u''\nhv' : Eq v' v''\n⊢ Eq (Quiver.Hom.cast hu' hv' (Quiver.Hom.cast hu hv e)) (Quiver.Hom.cast ⋯ ⋯ e)","decl":"@[simp]\ntheorem Hom.cast_cast {u v u' v' u'' v'' : U} (e : u ⟶ v) (hu : u = u') (hv : v = v')\n    (hu' : u' = u'') (hv' : v' = v'') :\n    (e.cast hu hv).cast hu' hv' = e.cast (hu.trans hu') (hv.trans hv') := by\n  subst_vars\n  rfl\n\n"}
{"name":"Quiver.Hom.cast_heq","module":"Mathlib.Combinatorics.Quiver.Cast","initialProofState":"U : Type u_1\ninst✝ : Quiver U\nu v u' v' : U\nhu : Eq u u'\nhv : Eq v v'\ne : Quiver.Hom u v\n⊢ HEq (Quiver.Hom.cast hu hv e) e","decl":"theorem Hom.cast_heq {u v u' v' : U} (hu : u = u') (hv : v = v') (e : u ⟶ v) :\n    HEq (e.cast hu hv) e := by\n  subst_vars\n  rfl\n\n"}
{"name":"Quiver.Hom.cast_eq_iff_heq","module":"Mathlib.Combinatorics.Quiver.Cast","initialProofState":"U : Type u_1\ninst✝ : Quiver U\nu v u' v' : U\nhu : Eq u u'\nhv : Eq v v'\ne : Quiver.Hom u v\ne' : Quiver.Hom u' v'\n⊢ Iff (Eq (Quiver.Hom.cast hu hv e) e') (HEq e e')","decl":"theorem Hom.cast_eq_iff_heq {u v u' v' : U} (hu : u = u') (hv : v = v') (e : u ⟶ v) (e' : u' ⟶ v') :\n    e.cast hu hv = e' ↔ HEq e e' := by\n  rw [Hom.cast_eq_cast]\n  exact _root_.cast_eq_iff_heq\n\n"}
{"name":"Quiver.Hom.eq_cast_iff_heq","module":"Mathlib.Combinatorics.Quiver.Cast","initialProofState":"U : Type u_1\ninst✝ : Quiver U\nu v u' v' : U\nhu : Eq u u'\nhv : Eq v v'\ne : Quiver.Hom u v\ne' : Quiver.Hom u' v'\n⊢ Iff (Eq e' (Quiver.Hom.cast hu hv e)) (HEq e' e)","decl":"theorem Hom.eq_cast_iff_heq {u v u' v' : U} (hu : u = u') (hv : v = v') (e : u ⟶ v) (e' : u' ⟶ v') :\n    e' = e.cast hu hv ↔ HEq e' e := by\n  rw [eq_comm, Hom.cast_eq_iff_heq]\n  exact ⟨HEq.symm, HEq.symm⟩\n\n"}
{"name":"Quiver.Path.cast_eq_cast","module":"Mathlib.Combinatorics.Quiver.Cast","initialProofState":"U : Type u_1\ninst✝ : Quiver U\nu v u' v' : U\nhu : Eq u u'\nhv : Eq v v'\np : Quiver.Path u v\n⊢ Eq (Quiver.Path.cast hu hv p) (cast ⋯ p)","decl":"theorem Path.cast_eq_cast {u v u' v' : U} (hu : u = u') (hv : v = v') (p : Path u v) :\n    p.cast hu hv = _root_.cast (by rw [hu, hv]) p := by\n  subst_vars\n  rfl\n\n"}
{"name":"Quiver.Path.cast_rfl_rfl","module":"Mathlib.Combinatorics.Quiver.Cast","initialProofState":"U : Type u_1\ninst✝ : Quiver U\nu v : U\np : Quiver.Path u v\n⊢ Eq (Quiver.Path.cast ⋯ ⋯ p) p","decl":"@[simp]\ntheorem Path.cast_rfl_rfl {u v : U} (p : Path u v) : p.cast rfl rfl = p :=\n  rfl\n\n"}
{"name":"Quiver.Path.cast_cast","module":"Mathlib.Combinatorics.Quiver.Cast","initialProofState":"U : Type u_1\ninst✝ : Quiver U\nu v u' v' u'' v'' : U\np : Quiver.Path u v\nhu : Eq u u'\nhv : Eq v v'\nhu' : Eq u' u''\nhv' : Eq v' v''\n⊢ Eq (Quiver.Path.cast hu' hv' (Quiver.Path.cast hu hv p)) (Quiver.Path.cast ⋯ ⋯ p)","decl":"@[simp]\ntheorem Path.cast_cast {u v u' v' u'' v'' : U} (p : Path u v) (hu : u = u') (hv : v = v')\n    (hu' : u' = u'') (hv' : v' = v'') :\n    (p.cast hu hv).cast hu' hv' = p.cast (hu.trans hu') (hv.trans hv') := by\n  subst_vars\n  rfl\n\n"}
{"name":"Quiver.Path.cast_nil","module":"Mathlib.Combinatorics.Quiver.Cast","initialProofState":"U : Type u_1\ninst✝ : Quiver U\nu u' : U\nhu : Eq u u'\n⊢ Eq (Quiver.Path.cast hu hu Quiver.Path.nil) Quiver.Path.nil","decl":"@[simp]\ntheorem Path.cast_nil {u u' : U} (hu : u = u') : (Path.nil : Path u u).cast hu hu = Path.nil := by\n  subst_vars\n  rfl\n\n"}
{"name":"Quiver.Path.cast_heq","module":"Mathlib.Combinatorics.Quiver.Cast","initialProofState":"U : Type u_1\ninst✝ : Quiver U\nu v u' v' : U\nhu : Eq u u'\nhv : Eq v v'\np : Quiver.Path u v\n⊢ HEq (Quiver.Path.cast hu hv p) p","decl":"theorem Path.cast_heq {u v u' v' : U} (hu : u = u') (hv : v = v') (p : Path u v) :\n    HEq (p.cast hu hv) p := by\n  rw [Path.cast_eq_cast]\n  exact _root_.cast_heq _ _\n\n"}
{"name":"Quiver.Path.cast_eq_iff_heq","module":"Mathlib.Combinatorics.Quiver.Cast","initialProofState":"U : Type u_1\ninst✝ : Quiver U\nu v u' v' : U\nhu : Eq u u'\nhv : Eq v v'\np : Quiver.Path u v\np' : Quiver.Path u' v'\n⊢ Iff (Eq (Quiver.Path.cast hu hv p) p') (HEq p p')","decl":"theorem Path.cast_eq_iff_heq {u v u' v' : U} (hu : u = u') (hv : v = v') (p : Path u v)\n    (p' : Path u' v') : p.cast hu hv = p' ↔ HEq p p' := by\n  rw [Path.cast_eq_cast]\n  exact _root_.cast_eq_iff_heq\n\n"}
{"name":"Quiver.Path.eq_cast_iff_heq","module":"Mathlib.Combinatorics.Quiver.Cast","initialProofState":"U : Type u_1\ninst✝ : Quiver U\nu v u' v' : U\nhu : Eq u u'\nhv : Eq v v'\np : Quiver.Path u v\np' : Quiver.Path u' v'\n⊢ Iff (Eq p' (Quiver.Path.cast hu hv p)) (HEq p' p)","decl":"theorem Path.eq_cast_iff_heq {u v u' v' : U} (hu : u = u') (hv : v = v') (p : Path u v)\n    (p' : Path u' v') : p' = p.cast hu hv ↔ HEq p' p :=\n  ⟨fun h => ((p.cast_eq_iff_heq hu hv p').1 h.symm).symm, fun h =>\n    ((p.cast_eq_iff_heq hu hv p').2 h.symm).symm⟩\n\n"}
{"name":"Quiver.Path.cast_cons","module":"Mathlib.Combinatorics.Quiver.Cast","initialProofState":"U : Type u_1\ninst✝ : Quiver U\nu v w u' w' : U\np : Quiver.Path u v\ne : Quiver.Hom v w\nhu : Eq u u'\nhw : Eq w w'\n⊢ Eq (Quiver.Path.cast hu hw (p.cons e)) ((Quiver.Path.cast hu ⋯ p).cons (Quiver.Hom.cast ⋯ hw e))","decl":"theorem Path.cast_cons {u v w u' w' : U} (p : Path u v) (e : v ⟶ w) (hu : u = u') (hw : w = w') :\n    (p.cons e).cast hu hw = (p.cast hu rfl).cons (e.cast rfl hw) := by\n  subst_vars\n  rfl\n\n"}
{"name":"Quiver.cast_eq_of_cons_eq_cons","module":"Mathlib.Combinatorics.Quiver.Cast","initialProofState":"U : Type u_1\ninst✝ : Quiver U\nu v v' w : U\np : Quiver.Path u v\np' : Quiver.Path u v'\ne : Quiver.Hom v w\ne' : Quiver.Hom v' w\nh : Eq (p.cons e) (p'.cons e')\n⊢ Eq (Quiver.Path.cast ⋯ ⋯ p) p'","decl":"theorem cast_eq_of_cons_eq_cons {u v v' w : U} {p : Path u v} {p' : Path u v'} {e : v ⟶ w}\n    {e' : v' ⟶ w} (h : p.cons e = p'.cons e') : p.cast rfl (obj_eq_of_cons_eq_cons h) = p' := by\n  rw [Path.cast_eq_iff_heq]\n  exact heq_of_cons_eq_cons h\n\n"}
{"name":"Quiver.hom_cast_eq_of_cons_eq_cons","module":"Mathlib.Combinatorics.Quiver.Cast","initialProofState":"U : Type u_1\ninst✝ : Quiver U\nu v v' w : U\np : Quiver.Path u v\np' : Quiver.Path u v'\ne : Quiver.Hom v w\ne' : Quiver.Hom v' w\nh : Eq (p.cons e) (p'.cons e')\n⊢ Eq (Quiver.Hom.cast ⋯ ⋯ e) e'","decl":"theorem hom_cast_eq_of_cons_eq_cons {u v v' w : U} {p : Path u v} {p' : Path u v'} {e : v ⟶ w}\n    {e' : v' ⟶ w} (h : p.cons e = p'.cons e') : e.cast (obj_eq_of_cons_eq_cons h) rfl = e' := by\n  rw [Hom.cast_eq_iff_heq]\n  exact hom_heq_of_cons_eq_cons h\n\n"}
{"name":"Quiver.eq_nil_of_length_zero","module":"Mathlib.Combinatorics.Quiver.Cast","initialProofState":"U : Type u_1\ninst✝ : Quiver U\nu v : U\np : Quiver.Path u v\nhzero : Eq p.length 0\n⊢ Eq (Quiver.Path.cast ⋯ ⋯ p) Quiver.Path.nil","decl":"theorem eq_nil_of_length_zero {u v : U} (p : Path u v) (hzero : p.length = 0) :\n    p.cast (eq_of_length_zero p hzero) rfl = Path.nil := by\n  cases p\n  · rfl\n  · simp only [Nat.succ_ne_zero, length_cons] at hzero\n\n"}
