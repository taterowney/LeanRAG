{"name":"ModuleCat.forget‚ÇÇ_addCommGroup_full","module":"Mathlib.Algebra.Category.Grp.ZModuleEquivalence","initialProofState":"‚ä¢ (CategoryTheory.forget‚ÇÇ (ModuleCat Int) AddCommGrp).Full","decl":"/-- The forgetful functor from `‚Ñ§` modules to `AddCommGrp` is full. -/\ninstance forget‚ÇÇ_addCommGroup_full : (forget‚ÇÇ (ModuleCat ‚Ñ§) AddCommGrp.{u}).Full where\n  map_surjective {A B}\n    -- `AddMonoidHom.toIntLinearMap` doesn't work here because `A` and `B` are not\n    -- definitionally equal to the canonical `AddCommGroup.toIntModule` module\n    -- instances it expects.\n    f := ‚ü®@ModuleCat.ofHom _ _ _ _ _ A.isModule _ B.isModule <|\n            @LinearMap.mk _ _ _ _ _ _ _ _ _ A.isModule B.isModule\n            { toFun := f,\n              map_add' := AddMonoidHom.map_add f.hom }\n            (fun n x => by\n              convert AddMonoidHom.map_zsmul f.hom x n <;>\n                ext <;> apply int_smul_eq_zsmul), rfl‚ü©\n\n"}
{"name":"ModuleCat.forget‚ÇÇ_addCommGrp_essSurj","module":"Mathlib.Algebra.Category.Grp.ZModuleEquivalence","initialProofState":"‚ä¢ (CategoryTheory.forget‚ÇÇ (ModuleCat Int) AddCommGrp).EssSurj","decl":"/-- The forgetful functor from `‚Ñ§` modules to `AddCommGrp` is essentially surjective. -/\ninstance forget‚ÇÇ_addCommGrp_essSurj : (forget‚ÇÇ (ModuleCat ‚Ñ§) AddCommGrp.{u}).EssSurj where\n  mem_essImage A :=\n    ‚ü®ModuleCat.of ‚Ñ§ A,\n      ‚ü®{  hom := ùüô A\n          inv := ùüô A }‚ü©‚ü©\n\n"}
{"name":"ModuleCat.forget‚ÇÇAddCommGroupIsEquivalence","module":"Mathlib.Algebra.Category.Grp.ZModuleEquivalence","initialProofState":"‚ä¢ (CategoryTheory.forget‚ÇÇ (ModuleCat Int) AddCommGrp).IsEquivalence","decl":"noncomputable instance forget‚ÇÇAddCommGroupIsEquivalence :\n    (forget‚ÇÇ (ModuleCat ‚Ñ§) AddCommGrp.{u}).IsEquivalence where\n\n"}
