{"name":"CategoryTheory.Limits.KernelFork.map_condition","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.KernelFork f\nG : CategoryTheory.Functor C D\ninst✝ : G.PreservesZeroMorphisms\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.Fork.ι c)) (G.map f)) 0","decl":"@[reassoc (attr := simp)]\nlemma map_condition : G.map c.ι ≫ G.map f = 0 := by\n  rw [← G.map_comp, c.condition, G.map_zero]\n\n"}
{"name":"CategoryTheory.Limits.KernelFork.map_condition_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.KernelFork f\nG : CategoryTheory.Functor C D\ninst✝ : G.PreservesZeroMorphisms\nZ : D\nh : Quiver.Hom (G.obj Y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.Fork.ι c)) (CategoryTheory.CategoryStruct.comp (G.map f) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma map_condition : G.map c.ι ≫ G.map f = 0 := by\n  rw [← G.map_comp, c.condition, G.map_zero]\n\n"}
{"name":"CategoryTheory.Limits.KernelFork.map_ι","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.KernelFork f\nG : CategoryTheory.Functor C D\ninst✝ : G.PreservesZeroMorphisms\n⊢ Eq (CategoryTheory.Limits.Fork.ι (c.map G)) (G.map (CategoryTheory.Limits.Fork.ι c))","decl":"@[simp]\nlemma map_ι : (c.map G).ι = G.map c.ι := rfl\n\n"}
{"name":"CategoryTheory.Limits.instHasKernelMapOfPreservesLimitWalkingParallelPairParallelPairOfNatHom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst✝² : G.PreservesZeroMorphisms\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasKernel f\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f 0) G\n⊢ CategoryTheory.Limits.HasKernel (G.map f)","decl":"instance [PreservesLimit (parallelPair f 0) G] : HasKernel (G.map f) where\n  exists_limit := ⟨⟨_, isLimitOfHasKernelOfPreservesLimit G f⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.PreservesKernel.of_iso_comparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst✝² : G.PreservesZeroMorphisms\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasKernel f\ninst✝ : CategoryTheory.Limits.HasKernel (G.map f)\ni : CategoryTheory.IsIso (CategoryTheory.Limits.kernelComparison f G)\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f 0) G","decl":"/-- If the kernel comparison map for `G` at `f` is an isomorphism, then `G` preserves the\nkernel of `f`.\n-/\nlemma PreservesKernel.of_iso_comparison [i : IsIso (kernelComparison f G)] :\n    PreservesLimit (parallelPair f 0) G := by\n  apply preservesLimit_of_preserves_limit_cone (kernelIsKernel f)\n  apply (isLimitMapConeForkEquiv' G (kernel.condition f)).symm _\n  exact @IsLimit.ofPointIso _ _ _ _ _ _ _ (kernelIsKernel (G.map f)) i\n\n"}
{"name":"CategoryTheory.Limits.PreservesKernel.iso_inv_ι_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst✝³ : G.PreservesZeroMorphisms\nX Y : C\nf : Quiver.Hom X Y\ninst✝² : CategoryTheory.Limits.HasKernel f\ninst✝¹ : CategoryTheory.Limits.HasKernel (G.map f)\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f 0) G\nZ : D\nh : Quiver.Hom (G.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesKernel.iso G f).inv (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.kernel.ι f)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.ι (G.map f)) h)","decl":"@[reassoc (attr := simp)]\ntheorem PreservesKernel.iso_inv_ι :\n    (PreservesKernel.iso G f).inv ≫ G.map (kernel.ι f) = kernel.ι (G.map f) :=\n  IsLimit.conePointUniqueUpToIso_inv_comp (isLimitOfHasKernelOfPreservesLimit G f)\n    (limit.isLimit _) (WalkingParallelPair.zero)\n\n"}
{"name":"CategoryTheory.Limits.PreservesKernel.iso_inv_ι","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst✝³ : G.PreservesZeroMorphisms\nX Y : C\nf : Quiver.Hom X Y\ninst✝² : CategoryTheory.Limits.HasKernel f\ninst✝¹ : CategoryTheory.Limits.HasKernel (G.map f)\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f 0) G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesKernel.iso G f).inv (G.map (CategoryTheory.Limits.kernel.ι f))) (CategoryTheory.Limits.kernel.ι (G.map f))","decl":"@[reassoc (attr := simp)]\ntheorem PreservesKernel.iso_inv_ι :\n    (PreservesKernel.iso G f).inv ≫ G.map (kernel.ι f) = kernel.ι (G.map f) :=\n  IsLimit.conePointUniqueUpToIso_inv_comp (isLimitOfHasKernelOfPreservesLimit G f)\n    (limit.isLimit _) (WalkingParallelPair.zero)\n\n"}
{"name":"CategoryTheory.Limits.PreservesKernel.iso_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst✝³ : G.PreservesZeroMorphisms\nX Y : C\nf : Quiver.Hom X Y\ninst✝² : CategoryTheory.Limits.HasKernel f\ninst✝¹ : CategoryTheory.Limits.HasKernel (G.map f)\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f 0) G\n⊢ Eq (CategoryTheory.Limits.PreservesKernel.iso G f).hom (CategoryTheory.Limits.kernelComparison f G)","decl":"@[simp]\ntheorem PreservesKernel.iso_hom : (PreservesKernel.iso G f).hom = kernelComparison f G := by\n  rw [← cancel_mono (kernel.ι _)]\n  simp [PreservesKernel.iso]\n\n"}
{"name":"CategoryTheory.Limits.instIsIsoKernelComparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst✝² : G.PreservesZeroMorphisms\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasKernel f\ninst✝ : CategoryTheory.Limits.HasKernel (G.map f)\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.kernelComparison f G)","decl":"instance : IsIso (kernelComparison f G) := by\n  rw [← PreservesKernel.iso_hom]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.kernel_map_comp_preserves_kernel_iso_inv","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝⁸ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst✝⁶ : G.PreservesZeroMorphisms\nX Y : C\nf : Quiver.Hom X Y\ninst✝⁵ : CategoryTheory.Limits.HasKernel f\ninst✝⁴ : CategoryTheory.Limits.HasKernel (G.map f)\ninst✝³ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f 0) G\nX' Y' : C\ng : Quiver.Hom X' Y'\ninst✝² : CategoryTheory.Limits.HasKernel g\ninst✝¹ : CategoryTheory.Limits.HasKernel (G.map g)\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair g 0) G\np : Quiver.Hom X X'\nq : Quiver.Hom Y Y'\nhpq : Eq (CategoryTheory.CategoryStruct.comp f q) (CategoryTheory.CategoryStruct.comp p g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.map (G.map f) (G.map g) (G.map p) (G.map q) ⋯) (CategoryTheory.Limits.PreservesKernel.iso G g).inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesKernel.iso G f).inv (G.map (CategoryTheory.Limits.kernel.map f g p q hpq)))","decl":"@[reassoc]\ntheorem kernel_map_comp_preserves_kernel_iso_inv {X' Y' : C} (g : X' ⟶ Y') [HasKernel g]\n    [HasKernel (G.map g)] [PreservesLimit (parallelPair g 0) G] (p : X ⟶ X') (q : Y ⟶ Y')\n    (hpq : f ≫ q = p ≫ g) :\n    kernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [← G.map_comp, hpq, G.map_comp]) ≫\n        (PreservesKernel.iso G _).inv =\n      (PreservesKernel.iso G _).inv ≫ G.map (kernel.map f g p q hpq) := by\n  rw [Iso.comp_inv_eq, Category.assoc, PreservesKernel.iso_hom, Iso.eq_inv_comp,\n    PreservesKernel.iso_hom, kernelComparison_comp_kernel_map]\n\n"}
{"name":"CategoryTheory.Limits.kernel_map_comp_preserves_kernel_iso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝⁸ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst✝⁶ : G.PreservesZeroMorphisms\nX Y : C\nf : Quiver.Hom X Y\ninst✝⁵ : CategoryTheory.Limits.HasKernel f\ninst✝⁴ : CategoryTheory.Limits.HasKernel (G.map f)\ninst✝³ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f 0) G\nX' Y' : C\ng : Quiver.Hom X' Y'\ninst✝² : CategoryTheory.Limits.HasKernel g\ninst✝¹ : CategoryTheory.Limits.HasKernel (G.map g)\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair g 0) G\np : Quiver.Hom X X'\nq : Quiver.Hom Y Y'\nhpq : Eq (CategoryTheory.CategoryStruct.comp f q) (CategoryTheory.CategoryStruct.comp p g)\nZ : D\nh : Quiver.Hom (G.obj (CategoryTheory.Limits.kernel g)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.map (G.map f) (G.map g) (G.map p) (G.map q) ⋯) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesKernel.iso G g).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesKernel.iso G f).inv (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.kernel.map f g p q hpq)) h))","decl":"@[reassoc]\ntheorem kernel_map_comp_preserves_kernel_iso_inv {X' Y' : C} (g : X' ⟶ Y') [HasKernel g]\n    [HasKernel (G.map g)] [PreservesLimit (parallelPair g 0) G] (p : X ⟶ X') (q : Y ⟶ Y')\n    (hpq : f ≫ q = p ≫ g) :\n    kernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [← G.map_comp, hpq, G.map_comp]) ≫\n        (PreservesKernel.iso G _).inv =\n      (PreservesKernel.iso G _).inv ≫ G.map (kernel.map f g p q hpq) := by\n  rw [Iso.comp_inv_eq, Category.assoc, PreservesKernel.iso_hom, Iso.eq_inv_comp,\n    PreservesKernel.iso_hom, kernelComparison_comp_kernel_map]\n\n"}
{"name":"CategoryTheory.Limits.CokernelCofork.map_condition","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.CokernelCofork f\nG : CategoryTheory.Functor C D\ninst✝ : G.PreservesZeroMorphisms\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map f) (G.map (CategoryTheory.Limits.Cofork.π c))) 0","decl":"@[reassoc (attr := simp)]\nlemma map_condition : G.map f ≫ G.map c.π = 0 := by\n  rw [← G.map_comp, c.condition, G.map_zero]\n\n"}
{"name":"CategoryTheory.Limits.CokernelCofork.map_condition_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.CokernelCofork f\nG : CategoryTheory.Functor C D\ninst✝ : G.PreservesZeroMorphisms\nZ : D\nh : Quiver.Hom (G.obj (((CategoryTheory.Functor.const CategoryTheory.Limits.WalkingParallelPair).obj c.pt).obj CategoryTheory.Limits.WalkingParallelPair.one)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map f) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.Cofork.π c)) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma map_condition : G.map f ≫ G.map c.π = 0 := by\n  rw [← G.map_comp, c.condition, G.map_zero]\n\n"}
{"name":"CategoryTheory.Limits.CokernelCofork.map_π","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nX Y : C\nf : Quiver.Hom X Y\nc : CategoryTheory.Limits.CokernelCofork f\nG : CategoryTheory.Functor C D\ninst✝ : G.PreservesZeroMorphisms\n⊢ Eq (CategoryTheory.Limits.Cofork.π (c.map G)) (G.map (CategoryTheory.Limits.Cofork.π c))","decl":"@[simp]\nlemma map_π : (c.map G).π = G.map c.π := rfl\n\n"}
{"name":"CategoryTheory.Limits.instHasCokernelMapOfPreservesColimitWalkingParallelPairParallelPairOfNatHom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst✝² : G.PreservesZeroMorphisms\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasCokernel f\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f 0) G\n⊢ CategoryTheory.Limits.HasCokernel (G.map f)","decl":"instance [PreservesColimit (parallelPair f 0) G] : HasCokernel (G.map f) where\n  exists_colimit := ⟨⟨_, isColimitOfHasCokernelOfPreservesColimit G f⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.PreservesCokernel.of_iso_comparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst✝² : G.PreservesZeroMorphisms\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasCokernel f\ninst✝ : CategoryTheory.Limits.HasCokernel (G.map f)\ni : CategoryTheory.IsIso (CategoryTheory.Limits.cokernelComparison f G)\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f 0) G","decl":"/-- If the cokernel comparison map for `G` at `f` is an isomorphism, then `G` preserves the\ncokernel of `f`.\n-/\nlemma PreservesCokernel.of_iso_comparison [i : IsIso (cokernelComparison f G)] :\n    PreservesColimit (parallelPair f 0) G := by\n  apply preservesColimit_of_preserves_colimit_cocone (cokernelIsCokernel f)\n  apply (isColimitMapCoconeCoforkEquiv' G (cokernel.condition f)).symm _\n  exact @IsColimit.ofPointIso _ _ _ _ _ _ _ (cokernelIsCokernel (G.map f)) i\n\n"}
{"name":"CategoryTheory.Limits.PreservesCokernel.π_iso_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst✝³ : G.PreservesZeroMorphisms\nX Y : C\nf : Quiver.Hom X Y\ninst✝² : CategoryTheory.Limits.HasCokernel f\ninst✝¹ : CategoryTheory.Limits.HasCokernel (G.map f)\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f 0) G\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.cokernel.π f)) (CategoryTheory.Limits.PreservesCokernel.iso G f).hom) (CategoryTheory.Limits.cokernel.π (G.map f))","decl":"@[reassoc (attr := simp)]\ntheorem PreservesCokernel.π_iso_hom : G.map (cokernel.π f) ≫ (iso G f).hom = cokernel.π (G.map f) :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom (isColimitOfHasCokernelOfPreservesColimit G f)\n    (colimit.isColimit _) (WalkingParallelPair.one)\n\n"}
{"name":"CategoryTheory.Limits.PreservesCokernel.π_iso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst✝³ : G.PreservesZeroMorphisms\nX Y : C\nf : Quiver.Hom X Y\ninst✝² : CategoryTheory.Limits.HasCokernel f\ninst✝¹ : CategoryTheory.Limits.HasCokernel (G.map f)\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f 0) G\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.cokernel (G.map f)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.cokernel.π f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesCokernel.iso G f).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.π (G.map f)) h)","decl":"@[reassoc (attr := simp)]\ntheorem PreservesCokernel.π_iso_hom : G.map (cokernel.π f) ≫ (iso G f).hom = cokernel.π (G.map f) :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom (isColimitOfHasCokernelOfPreservesColimit G f)\n    (colimit.isColimit _) (WalkingParallelPair.one)\n\n"}
{"name":"CategoryTheory.Limits.PreservesCokernel.iso_inv","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁷ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁶ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst✝³ : G.PreservesZeroMorphisms\nX Y : C\nf : Quiver.Hom X Y\ninst✝² : CategoryTheory.Limits.HasCokernel f\ninst✝¹ : CategoryTheory.Limits.HasCokernel (G.map f)\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f 0) G\n⊢ Eq (CategoryTheory.Limits.PreservesCokernel.iso G f).inv (CategoryTheory.Limits.cokernelComparison f G)","decl":"@[simp]\ntheorem PreservesCokernel.iso_inv : (PreservesCokernel.iso G f).inv = cokernelComparison f G := by\n  rw [← cancel_epi (cokernel.π _)]\n  simp [PreservesCokernel.iso]\n\n"}
{"name":"CategoryTheory.Limits.instIsIsoCokernelComparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst✝² : G.PreservesZeroMorphisms\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Limits.HasCokernel f\ninst✝ : CategoryTheory.Limits.HasCokernel (G.map f)\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.cokernelComparison f G)","decl":"instance : IsIso (cokernelComparison f G) := by\n  rw [← PreservesCokernel.iso_inv]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.preserves_cokernel_iso_comp_cokernel_map","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝⁸ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst✝⁶ : G.PreservesZeroMorphisms\nX Y : C\nf : Quiver.Hom X Y\ninst✝⁵ : CategoryTheory.Limits.HasCokernel f\ninst✝⁴ : CategoryTheory.Limits.HasCokernel (G.map f)\ninst✝³ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f 0) G\nX' Y' : C\ng : Quiver.Hom X' Y'\ninst✝² : CategoryTheory.Limits.HasCokernel g\ninst✝¹ : CategoryTheory.Limits.HasCokernel (G.map g)\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair g 0) G\np : Quiver.Hom X X'\nq : Quiver.Hom Y Y'\nhpq : Eq (CategoryTheory.CategoryStruct.comp f q) (CategoryTheory.CategoryStruct.comp p g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesCokernel.iso G f).hom (CategoryTheory.Limits.cokernel.map (G.map f) (G.map g) (G.map p) (G.map q) ⋯)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.cokernel.map f g p q hpq)) (CategoryTheory.Limits.PreservesCokernel.iso G g).hom)","decl":"@[reassoc]\ntheorem preserves_cokernel_iso_comp_cokernel_map {X' Y' : C} (g : X' ⟶ Y') [HasCokernel g]\n    [HasCokernel (G.map g)] [PreservesColimit (parallelPair g 0) G] (p : X ⟶ X') (q : Y ⟶ Y')\n    (hpq : f ≫ q = p ≫ g) :\n    (PreservesCokernel.iso G _).hom ≫\n        cokernel.map (G.map f) (G.map g) (G.map p) (G.map q)\n          (by rw [← G.map_comp, hpq, G.map_comp]) =\n      G.map (cokernel.map f g p q hpq) ≫ (PreservesCokernel.iso G _).hom := by\n  rw [← Iso.comp_inv_eq, Category.assoc, ← Iso.eq_inv_comp, PreservesCokernel.iso_inv,\n    cokernel_map_comp_cokernelComparison, PreservesCokernel.iso_inv]\n\n"}
{"name":"CategoryTheory.Limits.preserves_cokernel_iso_comp_cokernel_map_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝⁸ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁷ : CategoryTheory.Limits.HasZeroMorphisms D\nG : CategoryTheory.Functor C D\ninst✝⁶ : G.PreservesZeroMorphisms\nX Y : C\nf : Quiver.Hom X Y\ninst✝⁵ : CategoryTheory.Limits.HasCokernel f\ninst✝⁴ : CategoryTheory.Limits.HasCokernel (G.map f)\ninst✝³ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f 0) G\nX' Y' : C\ng : Quiver.Hom X' Y'\ninst✝² : CategoryTheory.Limits.HasCokernel g\ninst✝¹ : CategoryTheory.Limits.HasCokernel (G.map g)\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair g 0) G\np : Quiver.Hom X X'\nq : Quiver.Hom Y Y'\nhpq : Eq (CategoryTheory.CategoryStruct.comp f q) (CategoryTheory.CategoryStruct.comp p g)\nZ : D\nh : Quiver.Hom (CategoryTheory.Limits.cokernel (G.map g)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesCokernel.iso G f).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.map (G.map f) (G.map g) (G.map p) (G.map q) ⋯) h)) (CategoryTheory.CategoryStruct.comp (G.map (CategoryTheory.Limits.cokernel.map f g p q hpq)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesCokernel.iso G g).hom h))","decl":"@[reassoc]\ntheorem preserves_cokernel_iso_comp_cokernel_map {X' Y' : C} (g : X' ⟶ Y') [HasCokernel g]\n    [HasCokernel (G.map g)] [PreservesColimit (parallelPair g 0) G] (p : X ⟶ X') (q : Y ⟶ Y')\n    (hpq : f ≫ q = p ≫ g) :\n    (PreservesCokernel.iso G _).hom ≫\n        cokernel.map (G.map f) (G.map g) (G.map p) (G.map q)\n          (by rw [← G.map_comp, hpq, G.map_comp]) =\n      G.map (cokernel.map f g p q hpq) ≫ (PreservesCokernel.iso G _).hom := by\n  rw [← Iso.comp_inv_eq, Category.assoc, ← Iso.eq_inv_comp, PreservesCokernel.iso_inv,\n    cokernel_map_comp_cokernelComparison, PreservesCokernel.iso_inv]\n\n"}
{"name":"CategoryTheory.Limits.preservesKernel_zero","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nX Y : C\nG : CategoryTheory.Functor C D\ninst✝ : G.PreservesZeroMorphisms\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair 0 0) G","decl":"instance preservesKernel_zero :\n    PreservesLimit (parallelPair (0 : X ⟶ Y) 0) G where\n  preserves {c} hc := ⟨by\n    have := KernelFork.IsLimit.isIso_ι c hc rfl\n    refine (KernelFork.isLimitMapConeEquiv c G).symm ?_\n    refine IsLimit.ofIsoLimit (KernelFork.IsLimit.ofId _ (G.map_zero _ _)) ?_\n    exact (Fork.ext (G.mapIso (asIso (Fork.ι c))).symm (by simp))⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesCokernel_zero","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nX Y : C\nG : CategoryTheory.Functor C D\ninst✝ : G.PreservesZeroMorphisms\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair 0 0) G","decl":"noncomputable instance preservesCokernel_zero :\n    PreservesColimit (parallelPair (0 : X ⟶ Y) 0) G where\n  preserves {c} hc := ⟨by\n    have := CokernelCofork.IsColimit.isIso_π c hc rfl\n    refine (CokernelCofork.isColimitMapCoconeEquiv c G).symm ?_\n    refine IsColimit.ofIsoColimit (CokernelCofork.IsColimit.ofId _ (G.map_zero _ _)) ?_\n    exact (Cofork.ext (G.mapIso (asIso (Cofork.π c))) (by simp))⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesKernel_zero'","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nX Y : C\nG : CategoryTheory.Functor C D\ninst✝ : G.PreservesZeroMorphisms\nf : Quiver.Hom X Y\nhf : Eq f 0\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f 0) G","decl":"/-- The kernel of a zero map is preserved by any functor which preserves zero morphisms. -/\nlemma preservesKernel_zero' (f : X ⟶ Y) (hf : f = 0) :\n    PreservesLimit (parallelPair f 0) G := by\n  rw [hf]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.preservesCokernel_zero'","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Kernels","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\nX Y : C\nG : CategoryTheory.Functor C D\ninst✝ : G.PreservesZeroMorphisms\nf : Quiver.Hom X Y\nhf : Eq f 0\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f 0) G","decl":"/-- The cokernel of a zero map is preserved by any functor which preserves zero morphisms. -/\nlemma preservesCokernel_zero' (f : X ⟶ Y) (hf : f = 0) :\n    PreservesColimit (parallelPair f 0) G := by\n  rw [hf]\n  infer_instance\n\n"}
