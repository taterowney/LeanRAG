{"name":"MeasureTheory.Measure.measurable_coe","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : Set α\nhs : MeasurableSet s\n⊢ Measurable fun μ => μ s","decl":"theorem measurable_coe {s : Set α} (hs : MeasurableSet s) : Measurable fun μ : Measure α => μ s :=\n  Measurable.of_comap_le <| le_iSup_of_le s <| le_iSup_of_le hs <| le_rfl\n\n"}
{"name":"MeasureTheory.Measure.measurable_of_measurable_coe","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : β → MeasureTheory.Measure α\nh : ∀ (s : Set α), MeasurableSet s → Measurable fun b => (f b) s\n⊢ Measurable f","decl":"theorem measurable_of_measurable_coe (f : β → Measure α)\n    (h : ∀ (s : Set α), MeasurableSet s → Measurable fun b => f b s) : Measurable f :=\n  Measurable.of_le_map <|\n    iSup₂_le fun s hs =>\n      MeasurableSpace.comap_le_iff_le_map.2 <| by rw [MeasurableSpace.map_comp]; exact h s hs\n\n"}
{"name":"MeasureTheory.Measure.instMeasurableAdd₂","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_3\nm : MeasurableSpace α\n⊢ MeasurableAdd₂ (MeasureTheory.Measure α)","decl":"instance instMeasurableAdd₂ {α : Type*} {m : MeasurableSpace α} : MeasurableAdd₂ (Measure α) := by\n  refine ⟨Measure.measurable_of_measurable_coe _ fun s hs => ?_⟩\n  simp_rw [Measure.coe_add, Pi.add_apply]\n  refine Measurable.add ?_ ?_\n  · exact (Measure.measurable_coe hs).comp measurable_fst\n  · exact (Measure.measurable_coe hs).comp measurable_snd\n\n"}
{"name":"MeasureTheory.Measure.measurable_measure","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nμ : α → MeasureTheory.Measure β\n⊢ Iff (Measurable μ) (∀ (s : Set β), MeasurableSet s → Measurable fun b => (μ b) s)","decl":"theorem measurable_measure {μ : α → Measure β} :\n    Measurable μ ↔ ∀ (s : Set β), MeasurableSet s → Measurable fun b => μ b s :=\n  ⟨fun hμ _s hs => (measurable_coe hs).comp hμ, measurable_of_measurable_coe μ⟩\n\n"}
{"name":"Measurable.measure_of_isPiSystem","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : α → MeasureTheory.Measure β\ninst✝ : ∀ (a : α), MeasureTheory.IsFiniteMeasure (μ a)\nS : Set (Set β)\nhgen : Eq inst✝¹ (MeasurableSpace.generateFrom S)\nhpi : IsPiSystem S\nh_basic : ∀ (s : Set β), Membership.mem S s → Measurable fun a => (μ a) s\nh_univ : Measurable fun a => (μ a) Set.univ\n⊢ Measurable μ","decl":"theorem _root_.Measurable.measure_of_isPiSystem {μ : α → Measure β} [∀ a, IsFiniteMeasure (μ a)]\n    {S : Set (Set β)} (hgen : ‹MeasurableSpace β› = .generateFrom S) (hpi : IsPiSystem S)\n    (h_basic : ∀ s ∈ S, Measurable fun a ↦ μ a s) (h_univ : Measurable fun a ↦ μ a univ) :\n    Measurable μ := by\n  rw [measurable_measure]\n  intro s hs\n  induction s, hs using MeasurableSpace.induction_on_inter hgen hpi with\n  | empty => simp\n  | basic s hs => exact h_basic s hs\n  | compl s hsm ihs =>\n    simp only [measure_compl hsm (measure_ne_top _ _)]\n    exact h_univ.sub ihs\n  | iUnion f hfd hfm ihf =>\n    simpa only [measure_iUnion hfd hfm] using .ennreal_tsum ihf\n\n"}
{"name":"Measurable.measure_of_isPiSystem_of_isProbabilityMeasure","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nμ : α → MeasureTheory.Measure β\ninst✝ : ∀ (a : α), MeasureTheory.IsProbabilityMeasure (μ a)\nS : Set (Set β)\nhgen : Eq inst✝¹ (MeasurableSpace.generateFrom S)\nhpi : IsPiSystem S\nh_basic : ∀ (s : Set β), Membership.mem S s → Measurable fun a => (μ a) s\n⊢ Measurable μ","decl":"theorem _root_.Measurable.measure_of_isPiSystem_of_isProbabilityMeasure {μ : α → Measure β}\n    [∀ a, IsProbabilityMeasure (μ a)]\n    {S : Set (Set β)} (hgen : ‹MeasurableSpace β› = .generateFrom S) (hpi : IsPiSystem S)\n    (h_basic : ∀ s ∈ S, Measurable fun a ↦ μ a s) : Measurable μ :=\n  .measure_of_isPiSystem hgen hpi h_basic <| by simp\n\n"}
{"name":"MeasureTheory.Measure.measurable_map","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nhf : Measurable f\n⊢ Measurable fun μ => MeasureTheory.Measure.map f μ","decl":"theorem measurable_map (f : α → β) (hf : Measurable f) :\n    Measurable fun μ : Measure α => map f μ := by\n  refine measurable_of_measurable_coe _ fun s hs => ?_\n  simp_rw [map_apply hf hs]\n  exact measurable_coe (hf hs)\n\n"}
{"name":"MeasureTheory.Measure.measurable_dirac","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Measurable MeasureTheory.Measure.dirac","decl":"theorem measurable_dirac : Measurable (Measure.dirac : α → Measure α) := by\n  refine measurable_of_measurable_coe _ fun s hs => ?_\n  simp_rw [dirac_apply' _ hs]\n  exact measurable_one.indicator hs\n\n"}
{"name":"MeasureTheory.Measure.measurable_lintegral","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → ENNReal\nhf : Measurable f\n⊢ Measurable fun μ => MeasureTheory.lintegral μ fun x => f x","decl":"theorem measurable_lintegral {f : α → ℝ≥0∞} (hf : Measurable f) :\n    Measurable fun μ : Measure α => ∫⁻ x, f x ∂μ := by\n  simp only [lintegral_eq_iSup_eapprox_lintegral, hf, SimpleFunc.lintegral]\n  refine .iSup fun n => Finset.measurable_sum _ fun i _ => ?_\n  refine Measurable.const_mul ?_ _\n  exact measurable_coe ((SimpleFunc.eapprox f n).measurableSet_preimage _)\n\n"}
{"name":"MeasureTheory.Measure.join_apply","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm : MeasureTheory.Measure (MeasureTheory.Measure α)\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (m.join s) (MeasureTheory.lintegral m fun μ => μ s)","decl":"@[simp]\ntheorem join_apply {m : Measure (Measure α)} {s : Set α} (hs : MeasurableSet s) :\n    join m s = ∫⁻ μ, μ s ∂m :=\n  Measure.ofMeasurable_apply s hs\n\n"}
{"name":"MeasureTheory.Measure.join_zero","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Eq (MeasureTheory.Measure.join 0) 0","decl":"@[simp]\ntheorem join_zero : (0 : Measure (Measure α)).join = 0 := by\n  ext1 s hs\n  simp only [hs, join_apply, lintegral_zero_measure, coe_zero, Pi.zero_apply]\n\n"}
{"name":"MeasureTheory.Measure.measurable_join","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\n⊢ Measurable MeasureTheory.Measure.join","decl":"theorem measurable_join : Measurable (join : Measure (Measure α) → Measure α) :=\n  measurable_of_measurable_coe _ fun s hs => by\n    simp only [join_apply hs]; exact measurable_lintegral (measurable_coe hs)\n\n"}
{"name":"MeasureTheory.Measure.lintegral_join","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm : MeasureTheory.Measure (MeasureTheory.Measure α)\nf : α → ENNReal\nhf : Measurable f\n⊢ Eq (MeasureTheory.lintegral m.join fun x => f x) (MeasureTheory.lintegral m fun μ => MeasureTheory.lintegral μ fun x => f x)","decl":"theorem lintegral_join {m : Measure (Measure α)} {f : α → ℝ≥0∞} (hf : Measurable f) :\n    ∫⁻ x, f x ∂join m = ∫⁻ μ, ∫⁻ x, f x ∂μ ∂m := by\n  simp_rw [lintegral_eq_iSup_eapprox_lintegral hf, SimpleFunc.lintegral,\n    join_apply (SimpleFunc.measurableSet_preimage _ _)]\n  suffices\n    ∀ (s : ℕ → Finset ℝ≥0∞) (f : ℕ → ℝ≥0∞ → Measure α → ℝ≥0∞), (∀ n r, Measurable (f n r)) →\n      Monotone (fun n μ => ∑ r ∈ s n, r * f n r μ) →\n      ⨆ n, ∑ r ∈ s n, r * ∫⁻ μ, f n r μ ∂m = ∫⁻ μ, ⨆ n, ∑ r ∈ s n, r * f n r μ ∂m by\n    refine\n      this (fun n => SimpleFunc.range (SimpleFunc.eapprox f n))\n        (fun n r μ => μ (SimpleFunc.eapprox f n ⁻¹' {r})) ?_ ?_\n    · exact fun n r => measurable_coe (SimpleFunc.measurableSet_preimage _ _)\n    · exact fun n m h μ => SimpleFunc.lintegral_mono (SimpleFunc.monotone_eapprox _ h) le_rfl\n  intro s f hf hm\n  rw [lintegral_iSup _ hm]\n  swap\n  · exact fun n => Finset.measurable_sum _ fun r _ => (hf _ _).const_mul _\n  congr\n  funext n\n  rw [lintegral_finset_sum (s n)]\n  · simp_rw [lintegral_const_mul _ (hf _ _)]\n  · exact fun r _ => (hf _ _).const_mul _\n\n"}
{"name":"MeasureTheory.Measure.bind_zero_left","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → MeasureTheory.Measure β\n⊢ Eq (MeasureTheory.Measure.bind 0 f) 0","decl":"@[simp]\ntheorem bind_zero_left (f : α → Measure β) : bind 0 f = 0 := by simp [bind]\n\n"}
{"name":"MeasureTheory.Measure.bind_zero_right","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nm : MeasureTheory.Measure α\n⊢ Eq (m.bind 0) 0","decl":"@[simp]\ntheorem bind_zero_right (m : Measure α) : bind m (0 : α → Measure β) = 0 := by\n  ext1 s hs\n  simp only [bind, hs, join_apply, coe_zero, Pi.zero_apply]\n  rw [lintegral_map (measurable_coe hs) measurable_zero]\n  simp only [Pi.zero_apply, coe_zero, lintegral_const, zero_mul]\n\n"}
{"name":"MeasureTheory.Measure.bind_zero_right'","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nm : MeasureTheory.Measure α\n⊢ Eq (m.bind fun x => 0) 0","decl":"@[simp]\ntheorem bind_zero_right' (m : Measure α) : bind m (fun _ => 0 : α → Measure β) = 0 :=\n  bind_zero_right m\n\n"}
{"name":"MeasureTheory.Measure.bind_apply","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nm : MeasureTheory.Measure α\nf : α → MeasureTheory.Measure β\ns : Set β\nhs : MeasurableSet s\nhf : Measurable f\n⊢ Eq ((m.bind f) s) (MeasureTheory.lintegral m fun a => (f a) s)","decl":"@[simp]\ntheorem bind_apply {m : Measure α} {f : α → Measure β} {s : Set β} (hs : MeasurableSet s)\n    (hf : Measurable f) : bind m f s = ∫⁻ a, f a s ∂m := by\n  rw [bind, join_apply hs, lintegral_map (measurable_coe hs) hf]\n\n"}
{"name":"MeasureTheory.Measure.bind_const","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nm : MeasureTheory.Measure α\nν : MeasureTheory.Measure β\n⊢ Eq (m.bind fun x => ν) (HSMul.hSMul (m Set.univ) ν)","decl":"@[simp]\nlemma bind_const {m : Measure α} {ν : Measure β} : m.bind (fun _ ↦ ν) = m Set.univ • ν := by\n  ext s hs\n  rw [bind_apply hs measurable_const, lintegral_const, smul_apply, smul_eq_mul, mul_comm]\n\n"}
{"name":"MeasureTheory.Measure.measurable_bind'","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ng : α → MeasureTheory.Measure β\nhg : Measurable g\n⊢ Measurable fun m => m.bind g","decl":"theorem measurable_bind' {g : α → Measure β} (hg : Measurable g) : Measurable fun m => bind m g :=\n  measurable_join.comp (measurable_map _ hg)\n\n"}
{"name":"MeasureTheory.Measure.lintegral_bind","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nm : MeasureTheory.Measure α\nμ : α → MeasureTheory.Measure β\nf : β → ENNReal\nhμ : Measurable μ\nhf : Measurable f\n⊢ Eq (MeasureTheory.lintegral (m.bind μ) fun x => f x) (MeasureTheory.lintegral m fun a => MeasureTheory.lintegral (μ a) fun x => f x)","decl":"theorem lintegral_bind {m : Measure α} {μ : α → Measure β} {f : β → ℝ≥0∞} (hμ : Measurable μ)\n    (hf : Measurable f) : ∫⁻ x, f x ∂bind m μ = ∫⁻ a, ∫⁻ x, f x ∂μ a ∂m :=\n  (lintegral_join hf).trans (lintegral_map (measurable_lintegral hf) hμ)\n\n"}
{"name":"MeasureTheory.Measure.bind_bind","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : MeasurableSpace α\ninst✝¹ : MeasurableSpace β\nγ : Type u_3\ninst✝ : MeasurableSpace γ\nm : MeasureTheory.Measure α\nf : α → MeasureTheory.Measure β\ng : β → MeasureTheory.Measure γ\nhf : Measurable f\nhg : Measurable g\n⊢ Eq ((m.bind f).bind g) (m.bind fun a => (f a).bind g)","decl":"theorem bind_bind {γ} [MeasurableSpace γ] {m : Measure α} {f : α → Measure β} {g : β → Measure γ}\n    (hf : Measurable f) (hg : Measurable g) : bind (bind m f) g = bind m fun a => bind (f a) g := by\n  ext1 s hs\n  erw [bind_apply hs hg, bind_apply hs ((measurable_bind' hg).comp hf),\n    lintegral_bind hf ((measurable_coe hs).comp hg)]\n  conv_rhs => enter [2, a]; erw [bind_apply hs hg]\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.dirac_bind","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → MeasureTheory.Measure β\nhf : Measurable f\na : α\n⊢ Eq ((MeasureTheory.Measure.dirac a).bind f) (f a)","decl":"theorem dirac_bind {f : α → Measure β} (hf : Measurable f) (a : α) : bind (dirac a) f = f a := by\n  ext1 s hs\n  erw [bind_apply hs hf, lintegral_dirac' a ((measurable_coe hs).comp hf)]\n  rfl\n\n"}
{"name":"MeasureTheory.Measure.bind_dirac","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nm : MeasureTheory.Measure α\n⊢ Eq (m.bind MeasureTheory.Measure.dirac) m","decl":"@[simp]\ntheorem bind_dirac {m : Measure α} : bind m dirac = m := by\n  ext1 s hs\n  simp only [bind_apply hs measurable_dirac, dirac_apply' _ hs, lintegral_indicator hs,\n    Pi.one_apply, lintegral_one, restrict_apply, MeasurableSet.univ, univ_inter]\n\n"}
{"name":"MeasureTheory.Measure.bind_dirac_eq_map","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nm : MeasureTheory.Measure α\nf : α → β\nhf : Measurable f\n⊢ Eq (m.bind fun x => MeasureTheory.Measure.dirac (f x)) (MeasureTheory.Measure.map f m)","decl":"@[simp]\nlemma bind_dirac_eq_map (m : Measure α) {f : α → β} (hf : Measurable f) :\n    m.bind (fun x ↦ Measure.dirac (f x)) = m.map f := by\n  ext s hs\n  rw [bind_apply hs]\n  swap; · exact measurable_dirac.comp hf\n  simp_rw [dirac_apply' _ hs]\n  rw [← lintegral_map _ hf, lintegral_indicator_one hs]\n  exact measurable_const.indicator hs\n\n"}
{"name":"MeasureTheory.Measure.join_eq_bind","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure (MeasureTheory.Measure α)\n⊢ Eq μ.join (μ.bind id)","decl":"theorem join_eq_bind (μ : Measure (Measure α)) : join μ = bind μ id := by rw [bind, map_id]\n\n"}
{"name":"MeasureTheory.Measure.join_map_map","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nf : α → β\nhf : Measurable f\nμ : MeasureTheory.Measure (MeasureTheory.Measure α)\n⊢ Eq (MeasureTheory.Measure.map (MeasureTheory.Measure.map f) μ).join (MeasureTheory.Measure.map f μ.join)","decl":"theorem join_map_map {f : α → β} (hf : Measurable f) (μ : Measure (Measure α)) :\n    join (map (map f) μ) = map f (join μ) := by\n  ext1 s hs\n  rw [join_apply hs, map_apply hf hs, join_apply (hf hs),\n    lintegral_map (measurable_coe hs) (measurable_map f hf)]\n  simp_rw [map_apply hf hs]\n\n"}
{"name":"MeasureTheory.Measure.join_map_join","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure (MeasureTheory.Measure (MeasureTheory.Measure α))\n⊢ Eq (MeasureTheory.Measure.map MeasureTheory.Measure.join μ).join μ.join.join","decl":"theorem join_map_join (μ : Measure (Measure (Measure α))) : join (map join μ) = join (join μ) := by\n  show bind μ join = join (join μ)\n  rw [join_eq_bind, join_eq_bind, bind_bind measurable_id measurable_id]\n  apply congr_arg (bind μ)\n  funext ν\n  exact join_eq_bind ν\n\n"}
{"name":"MeasureTheory.Measure.join_map_dirac","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.Measure.map MeasureTheory.Measure.dirac μ).join μ","decl":"theorem join_map_dirac (μ : Measure α) : join (map dirac μ) = μ := bind_dirac\n\n"}
{"name":"MeasureTheory.Measure.join_dirac","module":"Mathlib.MeasureTheory.Measure.GiryMonad","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.Measure.dirac μ).join μ","decl":"theorem join_dirac (μ : Measure α) : join (dirac μ) = μ :=\n  (join_eq_bind (dirac μ)).trans (dirac_bind measurable_id _)\n\n"}
