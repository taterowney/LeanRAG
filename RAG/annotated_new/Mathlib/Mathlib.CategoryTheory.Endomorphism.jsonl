{"name":"CategoryTheory.End.one_def","module":"Mathlib.CategoryTheory.Endomorphism","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.CategoryStruct.{v, u} C\nX : C\n‚ä¢ Eq 1 (CategoryTheory.CategoryStruct.id X)","decl":"@[simp, nolint simpNF] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: use `of`/`asHom`?\ntheorem one_def : (1 : End X) = ùüô X := rfl\n\n"}
{"name":"CategoryTheory.End.mul_def","module":"Mathlib.CategoryTheory.Endomorphism","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.CategoryStruct.{v, u} C\nX : C\nxs ys : CategoryTheory.End X\n‚ä¢ Eq (HMul.hMul xs ys) (CategoryTheory.CategoryStruct.comp ys xs)","decl":"@[simp] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: use `of`/`asHom`?\ntheorem mul_def (xs ys : End X) : xs * ys = ys ‚â´ xs := rfl\n\n"}
{"name":"CategoryTheory.End.smul_right","module":"Mathlib.CategoryTheory.Endomorphism","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nr : CategoryTheory.End Y\nf : Quiver.Hom X Y\n‚ä¢ Eq (HSMul.hSMul r f) (CategoryTheory.CategoryStruct.comp f r)","decl":"theorem smul_right {X Y : C} {r : End Y} {f : X ‚ü∂ Y} : r ‚Ä¢ f = f ‚â´ r :=\n  rfl\n\n"}
{"name":"CategoryTheory.End.smul_left","module":"Mathlib.CategoryTheory.Endomorphism","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : Opposite C\nY : C\nr : CategoryTheory.End X\nf : Quiver.Hom (Opposite.unop X) Y\n‚ä¢ Eq (HSMul.hSMul r f) (CategoryTheory.CategoryStruct.comp (Quiver.Hom.unop r) f)","decl":"theorem smul_left {X : C·µí·µñ} {Y : C} {r : End X} {f : unop X ‚ü∂ Y} : r ‚Ä¢ f = r.unop ‚â´ f :=\n  rfl\n\n"}
{"name":"CategoryTheory.isUnit_iff_isIso","module":"Mathlib.CategoryTheory.Endomorphism","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nf : CategoryTheory.End X\n‚ä¢ Iff (IsUnit f) (CategoryTheory.IsIso f)","decl":"theorem isUnit_iff_isIso {C : Type u} [Category.{v} C] {X : C} (f : End X) :\n    IsUnit (f : End X) ‚Üî IsIso f :=\n  ‚ü®fun h => { out := ‚ü®h.unit.inv, ‚ü®h.unit.inv_val, h.unit.val_inv‚ü©‚ü© }, fun h =>\n    ‚ü®‚ü®f, inv f, by simp, by simp‚ü©, rfl‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Aut.ext_iff","module":"Mathlib.CategoryTheory.Endomorphism","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nœÜ‚ÇÅ œÜ‚ÇÇ : CategoryTheory.Aut X\n‚ä¢ Iff (Eq œÜ‚ÇÅ œÜ‚ÇÇ) (Eq œÜ‚ÇÅ.hom œÜ‚ÇÇ.hom)","decl":"@[ext]\nlemma ext {X : C} {œÜ‚ÇÅ œÜ‚ÇÇ : Aut X} (h : œÜ‚ÇÅ.hom = œÜ‚ÇÇ.hom) : œÜ‚ÇÅ = œÜ‚ÇÇ :=\n  Iso.ext h\n\n"}
{"name":"CategoryTheory.Aut.ext","module":"Mathlib.CategoryTheory.Endomorphism","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nœÜ‚ÇÅ œÜ‚ÇÇ : CategoryTheory.Aut X\nh : Eq œÜ‚ÇÅ.hom œÜ‚ÇÇ.hom\n‚ä¢ Eq œÜ‚ÇÅ œÜ‚ÇÇ","decl":"@[ext]\nlemma ext {X : C} {œÜ‚ÇÅ œÜ‚ÇÇ : Aut X} (h : œÜ‚ÇÅ.hom = œÜ‚ÇÇ.hom) : œÜ‚ÇÅ = œÜ‚ÇÇ :=\n  Iso.ext h\n\n"}
{"name":"CategoryTheory.Aut.Aut_mul_def","module":"Mathlib.CategoryTheory.Endomorphism","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nf g : CategoryTheory.Aut X\n‚ä¢ Eq (HMul.hMul f g) (CategoryTheory.Iso.trans g f)","decl":"theorem Aut_mul_def (f g : Aut X) : f * g = g.trans f := rfl\n\n"}
{"name":"CategoryTheory.Aut.Aut_inv_def","module":"Mathlib.CategoryTheory.Endomorphism","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nf : CategoryTheory.Aut X\n‚ä¢ Eq (Inv.inv f) (CategoryTheory.Iso.symm f)","decl":"theorem Aut_inv_def (f : Aut X) : f‚Åª¬π = f.symm := rfl\n\n"}
{"name":"CategoryTheory.Aut.toEnd_apply","module":"Mathlib.CategoryTheory.Endomorphism","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\na‚úù : CategoryTheory.Aut X\n‚ä¢ Eq ((CategoryTheory.Aut.toEnd X) a‚úù) ‚Üë((CategoryTheory.Aut.unitsEndEquivAut X).symm a‚úù)","decl":"/-- The inclusion of `Aut X` to `End X` as a monoid homomorphism. -/\n@[simps!]\ndef toEnd (X : C) : Aut X ‚Üí* End X := (Units.coeHom (End X)).comp (Aut.unitsEndEquivAut X).symm\n\n"}
{"name":"CategoryTheory.Functor.mapEnd_apply","module":"Mathlib.CategoryTheory.Endomorphism","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX : C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nf : CategoryTheory.Functor C D\na‚úù : Quiver.Hom X X\n‚ä¢ Eq ((CategoryTheory.Functor.mapEnd X f) a‚úù) (f.map a‚úù)","decl":"/-- `f.map` as a monoid hom between endomorphism monoids. -/\n@[simps]\ndef mapEnd : End X ‚Üí* End (f.obj X) where\n  toFun := f.map\n  map_mul' x y := f.map_comp y x\n  map_one' := f.map_id X\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.mulEquivEnd_apply","module":"Mathlib.CategoryTheory.Endomorphism","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nf : CategoryTheory.Functor C D\nhf : f.FullyFaithful\nX : C\na‚úù : Quiver.Hom X X\n‚ä¢ Eq ((hf.mulEquivEnd X) a‚úù) (f.map a‚úù)","decl":"/-- `mulEquivEnd` as an isomorphism between endomorphism monoids. -/\n@[simps!]\nnoncomputable def mulEquivEnd (X : C) :\n    End X ‚âÉ* End (f.obj X) where\n  toEquiv := hf.homEquiv\n  __ := mapEnd X f\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.mulEquivEnd_symm_apply","module":"Mathlib.CategoryTheory.Endomorphism","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nf‚úù : CategoryTheory.Functor C D\nhf : f‚úù.FullyFaithful\nX : C\nf : Quiver.Hom (f‚úù.obj X) (f‚úù.obj X)\n‚ä¢ Eq ((hf.mulEquivEnd X).symm f) (hf.preimage f)","decl":"/-- `mulEquivEnd` as an isomorphism between endomorphism monoids. -/\n@[simps!]\nnoncomputable def mulEquivEnd (X : C) :\n    End X ‚âÉ* End (f.obj X) where\n  toEquiv := hf.homEquiv\n  __ := mapEnd X f\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.autMulEquivOfFullyFaithful_apply_hom","module":"Mathlib.CategoryTheory.Endomorphism","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nf : CategoryTheory.Functor C D\nhf : f.FullyFaithful\nX : C\ni : CategoryTheory.Iso X X\n‚ä¢ Eq ((hf.autMulEquivOfFullyFaithful X) i).hom (f.map i.hom)","decl":"/-- `mulEquivAut` as an isomorphism between automorphism groups. -/\n@[simps!]\nnoncomputable def autMulEquivOfFullyFaithful (X : C) :\n    Aut X ‚âÉ* Aut (f.obj X) where\n  toEquiv := hf.isoEquiv\n  __ := mapAut X f\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.autMulEquivOfFullyFaithful_symm_apply_hom","module":"Mathlib.CategoryTheory.Endomorphism","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nf : CategoryTheory.Functor C D\nhf : f.FullyFaithful\nX : C\ne : CategoryTheory.Iso (f.obj X) (f.obj X)\n‚ä¢ Eq ((hf.autMulEquivOfFullyFaithful X).symm e).hom (hf.preimage e.hom)","decl":"/-- `mulEquivAut` as an isomorphism between automorphism groups. -/\n@[simps!]\nnoncomputable def autMulEquivOfFullyFaithful (X : C) :\n    Aut X ‚âÉ* Aut (f.obj X) where\n  toEquiv := hf.isoEquiv\n  __ := mapAut X f\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.autMulEquivOfFullyFaithful_symm_apply_inv","module":"Mathlib.CategoryTheory.Endomorphism","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nf : CategoryTheory.Functor C D\nhf : f.FullyFaithful\nX : C\ne : CategoryTheory.Iso (f.obj X) (f.obj X)\n‚ä¢ Eq ((hf.autMulEquivOfFullyFaithful X).symm e).inv (hf.preimage e.inv)","decl":"/-- `mulEquivAut` as an isomorphism between automorphism groups. -/\n@[simps!]\nnoncomputable def autMulEquivOfFullyFaithful (X : C) :\n    Aut X ‚âÉ* Aut (f.obj X) where\n  toEquiv := hf.isoEquiv\n  __ := mapAut X f\n\n"}
{"name":"CategoryTheory.Functor.FullyFaithful.autMulEquivOfFullyFaithful_apply_inv","module":"Mathlib.CategoryTheory.Endomorphism","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nf : CategoryTheory.Functor C D\nhf : f.FullyFaithful\nX : C\ni : CategoryTheory.Iso X X\n‚ä¢ Eq ((hf.autMulEquivOfFullyFaithful X) i).inv (f.map i.inv)","decl":"/-- `mulEquivAut` as an isomorphism between automorphism groups. -/\n@[simps!]\nnoncomputable def autMulEquivOfFullyFaithful (X : C) :\n    Aut X ‚âÉ* Aut (f.obj X) where\n  toEquiv := hf.isoEquiv\n  __ := mapAut X f\n\n"}
