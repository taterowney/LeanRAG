{"name":"IsLocalization.isInteger_zero","module":"Mathlib.RingTheory.Localization.Integer","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\n⊢ IsLocalization.IsInteger R 0","decl":"theorem isInteger_zero : IsInteger R (0 : S) :=\n  Subsemiring.zero_mem _\n\n"}
{"name":"IsLocalization.isInteger_one","module":"Mathlib.RingTheory.Localization.Integer","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\n⊢ IsLocalization.IsInteger R 1","decl":"theorem isInteger_one : IsInteger R (1 : S) :=\n  Subsemiring.one_mem _\n\n"}
{"name":"IsLocalization.isInteger_add","module":"Mathlib.RingTheory.Localization.Integer","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\na b : S\nha : IsLocalization.IsInteger R a\nhb : IsLocalization.IsInteger R b\n⊢ IsLocalization.IsInteger R (HAdd.hAdd a b)","decl":"theorem isInteger_add {a b : S} (ha : IsInteger R a) (hb : IsInteger R b) : IsInteger R (a + b) :=\n  Subsemiring.add_mem _ ha hb\n\n"}
{"name":"IsLocalization.isInteger_mul","module":"Mathlib.RingTheory.Localization.Integer","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\na b : S\nha : IsLocalization.IsInteger R a\nhb : IsLocalization.IsInteger R b\n⊢ IsLocalization.IsInteger R (HMul.hMul a b)","decl":"theorem isInteger_mul {a b : S} (ha : IsInteger R a) (hb : IsInteger R b) : IsInteger R (a * b) :=\n  Subsemiring.mul_mem _ ha hb\n\n"}
{"name":"IsLocalization.isInteger_smul","module":"Mathlib.RingTheory.Localization.Integer","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\na : R\nb : S\nhb : IsLocalization.IsInteger R b\n⊢ IsLocalization.IsInteger R (HSMul.hSMul a b)","decl":"theorem isInteger_smul {a : R} {b : S} (hb : IsInteger R b) : IsInteger R (a • b) := by\n  rcases hb with ⟨b', hb⟩\n  use a * b'\n  rw [← hb, (algebraMap R S).map_mul, Algebra.smul_def]\n\n"}
{"name":"IsLocalization.exists_integer_multiple'","module":"Mathlib.RingTheory.Localization.Integer","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\na : S\n⊢ Exists fun b => IsLocalization.IsInteger R (HMul.hMul a ((algebraMap R S) ↑b))","decl":"/-- Each element `a : S` has an `M`-multiple which is an integer.\n\nThis version multiplies `a` on the right, matching the argument order in `LocalizationMap.surj`.\n-/\ntheorem exists_integer_multiple' (a : S) : ∃ b : M, IsInteger R (a * algebraMap R S b) :=\n  let ⟨⟨Num, denom⟩, h⟩ := IsLocalization.surj _ a\n  ⟨denom, Set.mem_range.mpr ⟨Num, h.symm⟩⟩\n\n"}
{"name":"IsLocalization.exists_integer_multiple","module":"Mathlib.RingTheory.Localization.Integer","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\na : S\n⊢ Exists fun b => IsLocalization.IsInteger R (HSMul.hSMul (↑b) a)","decl":"/-- Each element `a : S` has an `M`-multiple which is an integer.\n\nThis version multiplies `a` on the left, matching the argument order in the `SMul` instance.\n-/\ntheorem exists_integer_multiple (a : S) : ∃ b : M, IsInteger R ((b : R) • a) := by\n  simp_rw [Algebra.smul_def, mul_comm _ a]\n  apply exists_integer_multiple'\n\n"}
{"name":"IsLocalization.exist_integer_multiples","module":"Mathlib.RingTheory.Localization.Integer","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nι : Type u_4\ns : Finset ι\nf : ι → S\n⊢ Exists fun b => ∀ (i : ι), Membership.mem s i → IsLocalization.IsInteger R (HSMul.hSMul (↑b) (f i))","decl":"/-- We can clear the denominators of a `Finset`-indexed family of fractions. -/\ntheorem exist_integer_multiples {ι : Type*} (s : Finset ι) (f : ι → S) :\n    ∃ b : M, ∀ i ∈ s, IsLocalization.IsInteger R ((b : R) • f i) := by\n  haveI := Classical.propDecidable\n  refine ⟨∏ i ∈ s, (sec M (f i)).2, fun i hi => ⟨?_, ?_⟩⟩\n  · exact (∏ j ∈ s.erase i, (sec M (f j)).2) * (sec M (f i)).1\n  rw [RingHom.map_mul, sec_spec', ← mul_assoc, ← (algebraMap R S).map_mul, ← Algebra.smul_def]\n  congr 2\n  refine _root_.trans ?_ (map_prod (Submonoid.subtype M) _ _).symm\n  rw [mul_comm,Submonoid.coe_finset_prod,\n    -- Porting note: explicitly supplied `f`\n    ← Finset.prod_insert (f := fun i => ((sec M (f i)).snd : R)) (s.not_mem_erase i),\n    Finset.insert_erase hi]\n  rfl\n\n"}
{"name":"IsLocalization.exist_integer_multiples_of_finite","module":"Mathlib.RingTheory.Localization.Integer","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\ninst✝¹ : IsLocalization M S\nι : Type u_4\ninst✝ : Finite ι\nf : ι → S\n⊢ Exists fun b => ∀ (i : ι), IsLocalization.IsInteger R (HSMul.hSMul (↑b) (f i))","decl":"/-- We can clear the denominators of a finite indexed family of fractions. -/\ntheorem exist_integer_multiples_of_finite {ι : Type*} [Finite ι] (f : ι → S) :\n    ∃ b : M, ∀ i, IsLocalization.IsInteger R ((b : R) • f i) := by\n  cases nonempty_fintype ι\n  obtain ⟨b, hb⟩ := exist_integer_multiples M Finset.univ f\n  exact ⟨b, fun i => hb i (Finset.mem_univ _)⟩\n\n"}
{"name":"IsLocalization.exist_integer_multiples_of_finset","module":"Mathlib.RingTheory.Localization.Integer","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\ns : Finset S\n⊢ Exists fun b => ∀ (a : S), Membership.mem s a → IsLocalization.IsInteger R (HSMul.hSMul (↑b) a)","decl":"/-- We can clear the denominators of a finite set of fractions. -/\ntheorem exist_integer_multiples_of_finset (s : Finset S) :\n    ∃ b : M, ∀ a ∈ s, IsInteger R ((b : R) • a) :=\n  exist_integer_multiples M s id\n\n"}
{"name":"IsLocalization.map_integerMultiple","module":"Mathlib.RingTheory.Localization.Integer","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nι : Type u_4\ns : Finset ι\nf : ι → S\ni : Subtype fun x => Membership.mem s x\n⊢ Eq ((algebraMap R S) (IsLocalization.integerMultiple M s f i)) (HSMul.hSMul (IsLocalization.commonDenom M s f) (f ↑i))","decl":"@[simp]\ntheorem map_integerMultiple {ι : Type*} (s : Finset ι) (f : ι → S) (i : s) :\n    algebraMap R S (integerMultiple M s f i) = commonDenom M s f • f i :=\n  ((exist_integer_multiples M s f).choose_spec _ i.prop).choose_spec\n\n"}
{"name":"IsLocalization.finsetIntegerMultiple_image","module":"Mathlib.RingTheory.Localization.Integer","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\ninst✝¹ : IsLocalization M S\ninst✝ : DecidableEq R\ns : Finset S\n⊢ Eq (Set.image ⇑(algebraMap R S) ↑(IsLocalization.finsetIntegerMultiple M s)) (HSMul.hSMul (IsLocalization.commonDenomOfFinset M s) ↑s)","decl":"theorem finsetIntegerMultiple_image [DecidableEq R] (s : Finset S) :\n    algebraMap R S '' finsetIntegerMultiple M s = commonDenomOfFinset M s • (s : Set S) := by\n  delta finsetIntegerMultiple commonDenom\n  rw [Finset.coe_image]\n  ext\n  constructor\n  · rintro ⟨_, ⟨x, -, rfl⟩, rfl⟩\n    rw [map_integerMultiple]\n    exact Set.mem_image_of_mem _ x.prop\n  · rintro ⟨x, hx, rfl⟩\n    exact ⟨_, ⟨⟨x, hx⟩, s.mem_attach _, rfl⟩, map_integerMultiple M s id _⟩\n\n"}
