{"name":"List.dedup_nil","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\n⊢ Eq List.nil.dedup List.nil","decl":"@[simp]\ntheorem dedup_nil : dedup [] = ([] : List α) :=\n  rfl\n\n"}
{"name":"List.dedup_cons_of_mem'","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nl : List α\nh : Membership.mem l.dedup a\n⊢ Eq (List.cons a l).dedup l.dedup","decl":"theorem dedup_cons_of_mem' {a : α} {l : List α} (h : a ∈ dedup l) : dedup (a :: l) = dedup l :=\n  pwFilter_cons_of_neg <| by simpa only [forall_mem_ne, not_not] using h\n\n"}
{"name":"List.dedup_cons_of_not_mem'","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nl : List α\nh : Not (Membership.mem l.dedup a)\n⊢ Eq (List.cons a l).dedup (List.cons a l.dedup)","decl":"theorem dedup_cons_of_not_mem' {a : α} {l : List α} (h : a ∉ dedup l) :\n    dedup (a :: l) = a :: dedup l :=\n  pwFilter_cons_of_pos <| by simpa only [forall_mem_ne] using h\n\n"}
{"name":"List.mem_dedup","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nl : List α\n⊢ Iff (Membership.mem l.dedup a) (Membership.mem l a)","decl":"@[simp]\ntheorem mem_dedup {a : α} {l : List α} : a ∈ dedup l ↔ a ∈ l := by\n  have := not_congr (@forall_mem_pwFilter α (· ≠ ·) _ ?_ a l)\n  · simpa only [dedup, forall_mem_ne, not_not] using this\n  · intros x y z xz\n    exact not_and_or.1 <| mt (fun h ↦ h.1.trans h.2) xz\n\n"}
{"name":"List.dedup_cons_of_mem","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nl : List α\nh : Membership.mem l a\n⊢ Eq (List.cons a l).dedup l.dedup","decl":"@[simp]\ntheorem dedup_cons_of_mem {a : α} {l : List α} (h : a ∈ l) : dedup (a :: l) = dedup l :=\n  dedup_cons_of_mem' <| mem_dedup.2 h\n\n"}
{"name":"List.dedup_cons_of_not_mem","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\na : α\nl : List α\nh : Not (Membership.mem l a)\n⊢ Eq (List.cons a l).dedup (List.cons a l.dedup)","decl":"@[simp]\ntheorem dedup_cons_of_not_mem {a : α} {l : List α} (h : a ∉ l) : dedup (a :: l) = a :: dedup l :=\n  dedup_cons_of_not_mem' <| mt mem_dedup.1 h\n\n"}
{"name":"List.dedup_sublist","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ l.dedup.Sublist l","decl":"theorem dedup_sublist : ∀ l : List α, dedup l <+ l :=\n  pwFilter_sublist\n\n"}
{"name":"List.dedup_subset","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ HasSubset.Subset l.dedup l","decl":"theorem dedup_subset : ∀ l : List α, dedup l ⊆ l :=\n  pwFilter_subset\n\n"}
{"name":"List.subset_dedup","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ HasSubset.Subset l l.dedup","decl":"theorem subset_dedup (l : List α) : l ⊆ dedup l := fun _ => mem_dedup.2\n\n"}
{"name":"List.nodup_dedup","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ l.dedup.Nodup","decl":"theorem nodup_dedup : ∀ l : List α, Nodup (dedup l) :=\n  pairwise_pwFilter\n\n"}
{"name":"List.headI_dedup","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Inhabited α\nl : List α\n⊢ Eq l.dedup.headI (ite (Membership.mem l.tail l.headI) l.tail.dedup.headI l.headI)","decl":"theorem headI_dedup [Inhabited α] (l : List α) :\n    l.dedup.headI = if l.headI ∈ l.tail then l.tail.dedup.headI else l.headI :=\n  match l with\n  | [] => rfl\n  | a :: l => by by_cases ha : a ∈ l <;> simp [ha, List.dedup_cons_of_mem]\n\n"}
{"name":"List.tail_dedup","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Inhabited α\nl : List α\n⊢ Eq l.dedup.tail (ite (Membership.mem l.tail l.headI) l.tail.dedup.tail l.tail.dedup)","decl":"theorem tail_dedup [Inhabited α] (l : List α) :\n    l.dedup.tail = if l.headI ∈ l.tail then l.tail.dedup.tail else l.tail.dedup :=\n  match l with\n  | [] => rfl\n  | a :: l => by by_cases ha : a ∈ l <;> simp [ha, List.dedup_cons_of_mem]\n\n"}
{"name":"List.dedup_eq_self","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ Iff (Eq l.dedup l) l.Nodup","decl":"theorem dedup_eq_self {l : List α} : dedup l = l ↔ Nodup l :=\n  pwFilter_eq_self\n\n"}
{"name":"List.dedup_eq_cons","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\na : α\nl' : List α\n⊢ Iff (Eq l.dedup (List.cons a l')) (And (Membership.mem l a) (And (Not (Membership.mem l' a)) (Eq l.dedup.tail l')))","decl":"theorem dedup_eq_cons (l : List α) (a : α) (l' : List α) :\n    l.dedup = a :: l' ↔ a ∈ l ∧ a ∉ l' ∧ l.dedup.tail = l' := by\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · refine ⟨mem_dedup.1 (h.symm ▸ mem_cons_self _ _), fun ha => ?_, by rw [h, tail_cons]⟩\n    have := count_pos_iff.2 ha\n    have : count a l.dedup ≤ 1 := nodup_iff_count_le_one.1 (nodup_dedup l) a\n    rw [h, count_cons_self] at this\n    omega\n  · have := @List.cons_head!_tail α ⟨a⟩ _ (ne_nil_of_mem (mem_dedup.2 h.1))\n    have hal : a ∈ l.dedup := mem_dedup.2 h.1\n    rw [← this, mem_cons, or_iff_not_imp_right] at hal\n    exact this ▸ h.2.2.symm ▸ cons_eq_cons.2 ⟨(hal (h.2.2.symm ▸ h.2.1)).symm, rfl⟩\n\n"}
{"name":"List.dedup_eq_nil","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ Iff (Eq l.dedup List.nil) (Eq l List.nil)","decl":"@[simp]\ntheorem dedup_eq_nil (l : List α) : l.dedup = [] ↔ l = [] := by\n  induction' l with a l hl\n  · exact Iff.rfl\n  · by_cases h : a ∈ l\n    · simp only [List.dedup_cons_of_mem h, hl, List.ne_nil_of_mem h, reduceCtorEq]\n    · simp only [List.dedup_cons_of_not_mem h, List.cons_ne_nil]\n\n"}
{"name":"List.Nodup.dedup","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\nh : l.Nodup\n⊢ Eq l.dedup l","decl":"protected theorem Nodup.dedup {l : List α} (h : l.Nodup) : l.dedup = l :=\n  List.dedup_eq_self.2 h\n\n"}
{"name":"List.dedup_idem","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\n⊢ Eq l.dedup.dedup l.dedup","decl":"@[simp]\ntheorem dedup_idem {l : List α} : dedup (dedup l) = dedup l :=\n  pwFilter_idem\n\n"}
{"name":"List.dedup_append","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl₁ l₂ : List α\n⊢ Eq (HAppend.hAppend l₁ l₂).dedup (Union.union l₁ l₂.dedup)","decl":"theorem dedup_append (l₁ l₂ : List α) : dedup (l₁ ++ l₂) = l₁ ∪ dedup l₂ := by\n  induction' l₁ with a l₁ IH; · rfl\n  simp only [cons_union] at *\n  rw [← IH, cons_append]\n  by_cases h : a ∈ dedup (l₁ ++ l₂)\n  · rw [dedup_cons_of_mem' h, insert_of_mem h]\n  · rw [dedup_cons_of_not_mem' h, insert_of_not_mem h]\n\n"}
{"name":"List.dedup_map_of_injective","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\nf : α → β\nhf : Function.Injective f\nxs : List α\n⊢ Eq (List.map f xs).dedup (List.map f xs.dedup)","decl":"theorem dedup_map_of_injective [DecidableEq β] {f : α → β} (hf : Function.Injective f)\n    (xs : List α) :\n    (xs.map f).dedup = xs.dedup.map f := by\n  induction xs with\n  | nil => simp\n  | cons x xs ih =>\n    rw [map_cons]\n    by_cases h : x ∈ xs\n    · rw [dedup_cons_of_mem h, dedup_cons_of_mem (mem_map_of_mem f h), ih]\n    · rw [dedup_cons_of_not_mem h, dedup_cons_of_not_mem <| (mem_map_of_injective hf).not.mpr h, ih,\n        map_cons]\n\n"}
{"name":"List.Subset.dedup_append_right","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nxs ys : List α\nh : HasSubset.Subset xs ys\n⊢ Eq (HAppend.hAppend xs ys).dedup ys.dedup","decl":"/-- Note that the weaker `List.Subset.dedup_append_left` is proved later. -/\ntheorem Subset.dedup_append_right {xs ys : List α} (h : xs ⊆ ys) :\n    dedup (xs ++ ys) = dedup ys := by\n  rw [List.dedup_append, Subset.union_eq_right (h.trans <| subset_dedup _)]\n\n"}
{"name":"List.Disjoint.union_eq","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nxs ys : List α\nh : xs.Disjoint ys\n⊢ Eq (Union.union xs ys) (HAppend.hAppend xs.dedup ys)","decl":"theorem Disjoint.union_eq {xs ys : List α} (h : Disjoint xs ys) :\n    xs ∪ ys = xs.dedup ++ ys := by\n  induction xs with\n  | nil => simp\n  | cons x xs ih =>\n    rw [cons_union]\n    rw [disjoint_cons_left] at h\n    by_cases hx : x ∈ xs\n    · rw [dedup_cons_of_mem hx, insert_of_mem (mem_union_left hx _), ih h.2]\n    · rw [dedup_cons_of_not_mem hx, insert_of_not_mem, ih h.2, cons_append]\n      rw [mem_union_iff, not_or]\n      exact ⟨hx, h.1⟩\n\n"}
{"name":"List.Disjoint.dedup_append","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nxs ys : List α\nh : xs.Disjoint ys\n⊢ Eq (HAppend.hAppend xs ys).dedup (HAppend.hAppend xs.dedup ys.dedup)","decl":"theorem Disjoint.dedup_append {xs ys : List α} (h : Disjoint xs ys) :\n    dedup (xs ++ ys) = dedup xs ++ dedup ys := by\n  rw [List.dedup_append, Disjoint.union_eq]\n  intro a hx hy\n  exact h hx (mem_dedup.mp hy)\n\n"}
{"name":"List.replicate_dedup","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nx : α\nk : Nat\na✝ : Ne k 0\n⊢ Eq (List.replicate k x).dedup (List.cons x List.nil)","decl":"theorem replicate_dedup {x : α} : ∀ {k}, k ≠ 0 → (replicate k x).dedup = [x]\n  | 0, h => (h rfl).elim\n  | 1, _ => rfl\n  | n + 2, _ => by\n    rw [replicate_succ, dedup_cons_of_mem (mem_replicate.2 ⟨n.succ_ne_zero, rfl⟩),\n      replicate_dedup n.succ_ne_zero]\n\n"}
{"name":"List.count_dedup","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl : List α\na : α\n⊢ Eq (List.count a l.dedup) (ite (Membership.mem l a) 1 0)","decl":"theorem count_dedup (l : List α) (a : α) : l.dedup.count a = if a ∈ l then 1 else 0 := by\n  simp_rw [count_eq_of_nodup <| nodup_dedup l, mem_dedup]\n\n"}
{"name":"List.Perm.dedup","module":"Mathlib.Data.List.Dedup","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nl₁ l₂ : List α\np : l₁.Perm l₂\n⊢ l₁.dedup.Perm l₂.dedup","decl":"theorem Perm.dedup {l₁ l₂ : List α} (p : l₁ ~ l₂) : dedup l₁ ~ dedup l₂ :=\n  perm_iff_count.2 fun a =>\n    if h : a ∈ l₁ then by\n      simp [h, nodup_dedup, p.subset h]\n    else by\n      simp [h, count_eq_zero_of_not_mem, mt p.mem_iff.2]\n\n"}
