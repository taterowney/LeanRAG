{"name":"norm_image_of_norm_zero","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\n𝓕 : Type u_8\ninst✝⁷ : SeminormedAddCommGroup E\ninst✝⁶ : SeminormedAddCommGroup F\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NontriviallyNormedField 𝕜₂\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝¹ : FunLike 𝓕 E F\ninst✝ : SemilinearMapClass 𝓕 σ₁₂ E F\nf : 𝓕\nhf : Continuous ⇑f\nx : E\nhx : Eq (Norm.norm x) 0\n⊢ Eq (Norm.norm (f x)) 0","decl":"/-- If `‖x‖ = 0` and `f` is continuous then `‖f x‖ = 0`. -/\ntheorem norm_image_of_norm_zero [SemilinearMapClass 𝓕 σ₁₂ E F] (f : 𝓕) (hf : Continuous f) {x : E}\n    (hx : ‖x‖ = 0) : ‖f x‖ = 0 := by\n  rw [← mem_closure_zero_iff_norm, ← specializes_iff_mem_closure, ← map_zero f] at *\n  exact hx.map hf\n\n"}
{"name":"SemilinearMapClass.bound_of_shell_semi_normed","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\n𝓕 : Type u_8\ninst✝⁸ : SeminormedAddCommGroup E\ninst✝⁷ : SeminormedAddCommGroup F\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NontriviallyNormedField 𝕜₂\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝² : FunLike 𝓕 E F\ninst✝¹ : RingHomIsometric σ₁₂\ninst✝ : SemilinearMapClass 𝓕 σ₁₂ E F\nf : 𝓕\nε C : Real\nε_pos : LT.lt 0 ε\nc : 𝕜\nhc : LT.lt 1 (Norm.norm c)\nhf : ∀ (x : E), LE.le (HDiv.hDiv ε (Norm.norm c)) (Norm.norm x) → LT.lt (Norm.norm x) ε → LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\nx : E\nhx : Ne (Norm.norm x) 0\n⊢ LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))","decl":"theorem SemilinearMapClass.bound_of_shell_semi_normed [SemilinearMapClass 𝓕 σ₁₂ E F] (f : 𝓕)\n    {ε C : ℝ} (ε_pos : 0 < ε) {c : 𝕜} (hc : 1 < ‖c‖)\n    (hf : ∀ x, ε / ‖c‖ ≤ ‖x‖ → ‖x‖ < ε → ‖f x‖ ≤ C * ‖x‖) {x : E} (hx : ‖x‖ ≠ 0) :\n    ‖f x‖ ≤ C * ‖x‖ :=\n  (normSeminorm 𝕜 E).bound_of_shell ((normSeminorm 𝕜₂ F).comp ⟨⟨f, map_add f⟩, map_smulₛₗ f⟩)\n    ε_pos hc hf hx\n\n"}
{"name":"SemilinearMapClass.bound_of_continuous","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\n𝓕 : Type u_8\ninst✝⁸ : SeminormedAddCommGroup E\ninst✝⁷ : SeminormedAddCommGroup F\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NontriviallyNormedField 𝕜₂\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝² : FunLike 𝓕 E F\ninst✝¹ : RingHomIsometric σ₁₂\ninst✝ : SemilinearMapClass 𝓕 σ₁₂ E F\nf : 𝓕\nhf : Continuous ⇑f\n⊢ Exists fun C => And (LT.lt 0 C) (∀ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x)))","decl":"/-- A continuous linear map between seminormed spaces is bounded when the field is nontrivially\nnormed. The continuity ensures boundedness on a ball of some radius `ε`. The nontriviality of the\nnorm is then used to rescale any element into an element of norm in `[ε/C, ε]`, whose image has a\ncontrolled norm. The norm control for the original element follows by rescaling. -/\ntheorem SemilinearMapClass.bound_of_continuous [SemilinearMapClass 𝓕 σ₁₂ E F] (f : 𝓕)\n    (hf : Continuous f) : ∃ C, 0 < C ∧ ∀ x : E, ‖f x‖ ≤ C * ‖x‖ :=\n  let φ : E →ₛₗ[σ₁₂] F := ⟨⟨f, map_add f⟩, map_smulₛₗ f⟩\n  ((normSeminorm 𝕜₂ F).comp φ).bound_of_continuous_normedSpace (continuous_norm.comp hf)\n\n"}
{"name":"ContinuousLinearMap.bound","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\n⊢ Exists fun C => And (LT.lt 0 C) (∀ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x)))","decl":"theorem bound [RingHomIsometric σ₁₂] (f : E →SL[σ₁₂] F) : ∃ C, 0 < C ∧ ∀ x : E, ‖f x‖ ≤ C * ‖x‖ :=\n  SemilinearMapClass.bound_of_continuous f f.2\n\n"}
{"name":"LinearIsometry.toSpanSingleton_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_4\ninst✝² : SeminormedAddCommGroup E\ninst✝¹ : NontriviallyNormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\nv : E\nhv : Eq (Norm.norm v) 1\na : 𝕜\n⊢ Eq ((LinearIsometry.toSpanSingleton 𝕜 E hv) a) (HSMul.hSMul a v)","decl":"@[simp]\ntheorem _root_.LinearIsometry.toSpanSingleton_apply {v : E} (hv : ‖v‖ = 1) (a : 𝕜) :\n    LinearIsometry.toSpanSingleton 𝕜 E hv a = a • v :=\n  rfl\n\n"}
{"name":"LinearIsometry.coe_toSpanSingleton","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_4\ninst✝² : SeminormedAddCommGroup E\ninst✝¹ : NontriviallyNormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\nv : E\nhv : Eq (Norm.norm v) 1\n⊢ Eq (LinearIsometry.toSpanSingleton 𝕜 E hv).toLinearMap (LinearMap.toSpanSingleton 𝕜 E v)","decl":"@[simp]\ntheorem _root_.LinearIsometry.coe_toSpanSingleton {v : E} (hv : ‖v‖ = 1) :\n    (LinearIsometry.toSpanSingleton 𝕜 E hv).toLinearMap = LinearMap.toSpanSingleton 𝕜 E v :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.norm_def","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : SeminormedAddCommGroup F\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NontriviallyNormedField 𝕜₂\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nf : ContinuousLinearMap σ₁₂ E F\n⊢ Eq (Norm.norm f) (InfSet.sInf (setOf fun c => And (LE.le 0 c) (∀ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul c (Norm.norm x)))))","decl":"theorem norm_def (f : E →SL[σ₁₂] F) : ‖f‖ = sInf { c | 0 ≤ c ∧ ∀ x, ‖f x‖ ≤ c * ‖x‖ } :=\n  rfl\n\n-- So that invocations of `le_csInf` make sense: we show that the set of\n-- bounds is nonempty and bounded below.\n"}
{"name":"ContinuousLinearMap.bounds_nonempty","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\n⊢ Exists fun c => Membership.mem (setOf fun c => And (LE.le 0 c) (∀ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul c (Norm.norm x)))) c","decl":"theorem bounds_nonempty [RingHomIsometric σ₁₂] {f : E →SL[σ₁₂] F} :\n    ∃ c, c ∈ { c | 0 ≤ c ∧ ∀ x, ‖f x‖ ≤ c * ‖x‖ } :=\n  let ⟨M, hMp, hMb⟩ := f.bound\n  ⟨M, le_of_lt hMp, hMb⟩\n\n"}
{"name":"ContinuousLinearMap.bounds_bddBelow","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : SeminormedAddCommGroup F\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NontriviallyNormedField 𝕜₂\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nf : ContinuousLinearMap σ₁₂ E F\n⊢ BddBelow (setOf fun c => And (LE.le 0 c) (∀ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul c (Norm.norm x))))","decl":"theorem bounds_bddBelow {f : E →SL[σ₁₂] F} : BddBelow { c | 0 ≤ c ∧ ∀ x, ‖f x‖ ≤ c * ‖x‖ } :=\n  ⟨0, fun _ ⟨hn, _⟩ => hn⟩\n\n"}
{"name":"ContinuousLinearMap.isLeast_opNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\n⊢ IsLeast (setOf fun c => And (LE.le 0 c) (∀ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul c (Norm.norm x)))) (Norm.norm f)","decl":"theorem isLeast_opNorm [RingHomIsometric σ₁₂] (f : E →SL[σ₁₂] F) :\n    IsLeast {c | 0 ≤ c ∧ ∀ x, ‖f x‖ ≤ c * ‖x‖} ‖f‖ := by\n  refine IsClosed.isLeast_csInf ?_ bounds_nonempty bounds_bddBelow\n  simp only [setOf_and, setOf_forall]\n  refine isClosed_Ici.inter <| isClosed_iInter fun _ ↦ isClosed_le ?_ ?_ <;> continuity\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_le_bound","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : SeminormedAddCommGroup F\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NontriviallyNormedField 𝕜₂\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nf : ContinuousLinearMap σ₁₂ E F\nM : Real\nhMp : LE.le 0 M\nhM : ∀ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul M (Norm.norm x))\n⊢ LE.le (Norm.norm f) M","decl":"/-- If one controls the norm of every `A x`, then one controls the norm of `A`. -/\ntheorem opNorm_le_bound (f : E →SL[σ₁₂] F) {M : ℝ} (hMp : 0 ≤ M) (hM : ∀ x, ‖f x‖ ≤ M * ‖x‖) :\n    ‖f‖ ≤ M :=\n  csInf_le bounds_bddBelow ⟨hMp, hM⟩\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_le_bound'","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : SeminormedAddCommGroup F\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NontriviallyNormedField 𝕜₂\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nf : ContinuousLinearMap σ₁₂ E F\nM : Real\nhMp : LE.le 0 M\nhM : ∀ (x : E), Ne (Norm.norm x) 0 → LE.le (Norm.norm (f x)) (HMul.hMul M (Norm.norm x))\n⊢ LE.le (Norm.norm f) M","decl":"/-- If one controls the norm of every `A x`, `‖x‖ ≠ 0`, then one controls the norm of `A`. -/\ntheorem opNorm_le_bound' (f : E →SL[σ₁₂] F) {M : ℝ} (hMp : 0 ≤ M)\n    (hM : ∀ x, ‖x‖ ≠ 0 → ‖f x‖ ≤ M * ‖x‖) : ‖f‖ ≤ M :=\n  opNorm_le_bound f hMp fun x =>\n    (ne_or_eq ‖x‖ 0).elim (hM x) fun h => by\n      simp only [h, mul_zero, norm_image_of_norm_zero f f.2 h, le_refl]\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_le_of_lipschitz","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : SeminormedAddCommGroup F\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NontriviallyNormedField 𝕜₂\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nf : ContinuousLinearMap σ₁₂ E F\nK : NNReal\nhf : LipschitzWith K ⇑f\n⊢ LE.le (Norm.norm f) ↑K","decl":"theorem opNorm_le_of_lipschitz {f : E →SL[σ₁₂] F} {K : ℝ≥0} (hf : LipschitzWith K f) : ‖f‖ ≤ K :=\n  f.opNorm_le_bound K.2 fun x => by\n    simpa only [dist_zero_right, f.map_zero] using hf.dist_le_mul x 0\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_eq_of_bounds","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : SeminormedAddCommGroup F\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NontriviallyNormedField 𝕜₂\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nφ : ContinuousLinearMap σ₁₂ E F\nM : Real\nM_nonneg : LE.le 0 M\nh_above : ∀ (x : E), LE.le (Norm.norm (φ x)) (HMul.hMul M (Norm.norm x))\nh_below : ∀ (N : Real), GE.ge N 0 → (∀ (x : E), LE.le (Norm.norm (φ x)) (HMul.hMul N (Norm.norm x))) → LE.le M N\n⊢ Eq (Norm.norm φ) M","decl":"theorem opNorm_eq_of_bounds {φ : E →SL[σ₁₂] F} {M : ℝ} (M_nonneg : 0 ≤ M)\n    (h_above : ∀ x, ‖φ x‖ ≤ M * ‖x‖) (h_below : ∀ N ≥ 0, (∀ x, ‖φ x‖ ≤ N * ‖x‖) → M ≤ N) :\n    ‖φ‖ = M :=\n  le_antisymm (φ.opNorm_le_bound M_nonneg h_above)\n    ((le_csInf_iff ContinuousLinearMap.bounds_bddBelow ⟨M, M_nonneg, h_above⟩).mpr\n      fun N ⟨N_nonneg, hN⟩ => h_below N N_nonneg hN)\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_neg","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : SeminormedAddCommGroup F\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NontriviallyNormedField 𝕜₂\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nf : ContinuousLinearMap σ₁₂ E F\n⊢ Eq (Norm.norm (Neg.neg f)) (Norm.norm f)","decl":"theorem opNorm_neg (f : E →SL[σ₁₂] F) : ‖-f‖ = ‖f‖ := by simp only [norm_def, neg_apply, norm_neg]\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_nonneg","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : SeminormedAddCommGroup F\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NontriviallyNormedField 𝕜₂\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nf : ContinuousLinearMap σ₁₂ E F\n⊢ LE.le 0 (Norm.norm f)","decl":"theorem opNorm_nonneg (f : E →SL[σ₁₂] F) : 0 ≤ ‖f‖ :=\n  Real.sInf_nonneg fun _ ↦ And.left\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_zero","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : SeminormedAddCommGroup F\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NontriviallyNormedField 𝕜₂\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\n⊢ Eq (Norm.norm 0) 0","decl":"/-- The norm of the `0` operator is `0`. -/\ntheorem opNorm_zero : ‖(0 : E →SL[σ₁₂] F)‖ = 0 :=\n  le_antisymm (opNorm_le_bound _ le_rfl fun _ ↦ by simp) (opNorm_nonneg _)\n\n\n"}
{"name":"ContinuousLinearMap.norm_id_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_4\ninst✝² : SeminormedAddCommGroup E\ninst✝¹ : NontriviallyNormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\n⊢ LE.le (Norm.norm (ContinuousLinearMap.id 𝕜 E)) 1","decl":"/-- The norm of the identity is at most `1`. It is in fact `1`, except when the space is trivial\nwhere it is `0`. It means that one can not do better than an inequality in general. -/\ntheorem norm_id_le : ‖id 𝕜 E‖ ≤ 1 :=\n  opNorm_le_bound _ zero_le_one fun x => by simp\n\n"}
{"name":"ContinuousLinearMap.le_opNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nx : E\n⊢ LE.le (Norm.norm (f x)) (HMul.hMul (Norm.norm f) (Norm.norm x))","decl":"/-- The fundamental property of the operator norm: `‖f x‖ ≤ ‖f‖ * ‖x‖`. -/\ntheorem le_opNorm : ‖f x‖ ≤ ‖f‖ * ‖x‖ := (isLeast_opNorm f).1.2 x\n\n\n"}
{"name":"ContinuousLinearMap.dist_le_opNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nx y : E\n⊢ LE.le (Dist.dist (f x) (f y)) (HMul.hMul (Norm.norm f) (Dist.dist x y))","decl":"theorem dist_le_opNorm (x y : E) : dist (f x) (f y) ≤ ‖f‖ * dist x y := by\n  simp_rw [dist_eq_norm, ← map_sub, f.le_opNorm]\n\n\n"}
{"name":"ContinuousLinearMap.le_of_opNorm_le_of_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nx : E\na b : Real\nhf : LE.le (Norm.norm f) a\nhx : LE.le (Norm.norm x) b\n⊢ LE.le (Norm.norm (f x)) (HMul.hMul a b)","decl":"theorem le_of_opNorm_le_of_le {x} {a b : ℝ} (hf : ‖f‖ ≤ a) (hx : ‖x‖ ≤ b) :\n    ‖f x‖ ≤ a * b :=\n  (f.le_opNorm x).trans <| by gcongr; exact (opNorm_nonneg f).trans hf\n\n\n"}
{"name":"ContinuousLinearMap.le_opNorm_of_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nc : Real\nx : E\nh : LE.le (Norm.norm x) c\n⊢ LE.le (Norm.norm (f x)) (HMul.hMul (Norm.norm f) c)","decl":"theorem le_opNorm_of_le {c : ℝ} {x} (h : ‖x‖ ≤ c) : ‖f x‖ ≤ ‖f‖ * c :=\n  f.le_of_opNorm_le_of_le le_rfl h\n\n\n"}
{"name":"ContinuousLinearMap.le_of_opNorm_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nc : Real\nh : LE.le (Norm.norm f) c\nx : E\n⊢ LE.le (Norm.norm (f x)) (HMul.hMul c (Norm.norm x))","decl":"theorem le_of_opNorm_le {c : ℝ} (h : ‖f‖ ≤ c) (x : E) : ‖f x‖ ≤ c * ‖x‖ :=\n  f.le_of_opNorm_le_of_le h le_rfl\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_le_iff","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nM : Real\nhMp : LE.le 0 M\n⊢ Iff (LE.le (Norm.norm f) M) (∀ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul M (Norm.norm x)))","decl":"theorem opNorm_le_iff {f : E →SL[σ₁₂] F} {M : ℝ} (hMp : 0 ≤ M) :\n    ‖f‖ ≤ M ↔ ∀ x, ‖f x‖ ≤ M * ‖x‖ :=\n  ⟨f.le_of_opNorm_le, opNorm_le_bound f hMp⟩\n\n\n"}
{"name":"ContinuousLinearMap.ratio_le_opNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nx : E\n⊢ LE.le (HDiv.hDiv (Norm.norm (f x)) (Norm.norm x)) (Norm.norm f)","decl":"theorem ratio_le_opNorm : ‖f x‖ / ‖x‖ ≤ ‖f‖ :=\n  div_le_of_le_mul₀ (norm_nonneg _) f.opNorm_nonneg (le_opNorm _ _)\n\n\n"}
{"name":"ContinuousLinearMap.unit_le_opNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nx : E\na✝ : LE.le (Norm.norm x) 1\n⊢ LE.le (Norm.norm (f x)) (Norm.norm f)","decl":"/-- The image of the unit ball under a continuous linear map is bounded. -/\ntheorem unit_le_opNorm : ‖x‖ ≤ 1 → ‖f x‖ ≤ ‖f‖ :=\n  mul_one ‖f‖ ▸ f.le_opNorm_of_le\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_le_of_shell","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nε C : Real\nε_pos : LT.lt 0 ε\nhC : LE.le 0 C\nc : 𝕜\nhc : LT.lt 1 (Norm.norm c)\nhf : ∀ (x : E), LE.le (HDiv.hDiv ε (Norm.norm c)) (Norm.norm x) → LT.lt (Norm.norm x) ε → LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\n⊢ LE.le (Norm.norm f) C","decl":"theorem opNorm_le_of_shell {f : E →SL[σ₁₂] F} {ε C : ℝ} (ε_pos : 0 < ε) (hC : 0 ≤ C) {c : 𝕜}\n    (hc : 1 < ‖c‖) (hf : ∀ x, ε / ‖c‖ ≤ ‖x‖ → ‖x‖ < ε → ‖f x‖ ≤ C * ‖x‖) : ‖f‖ ≤ C :=\n  f.opNorm_le_bound' hC fun _ hx => SemilinearMapClass.bound_of_shell_semi_normed f ε_pos hc hf hx\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_le_of_ball","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nε C : Real\nε_pos : LT.lt 0 ε\nhC : LE.le 0 C\nhf : ∀ (x : E), Membership.mem (Metric.ball 0 ε) x → LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\n⊢ LE.le (Norm.norm f) C","decl":"theorem opNorm_le_of_ball {f : E →SL[σ₁₂] F} {ε : ℝ} {C : ℝ} (ε_pos : 0 < ε) (hC : 0 ≤ C)\n    (hf : ∀ x ∈ ball (0 : E) ε, ‖f x‖ ≤ C * ‖x‖) : ‖f‖ ≤ C := by\n  rcases NormedField.exists_one_lt_norm 𝕜 with ⟨c, hc⟩\n  refine opNorm_le_of_shell ε_pos hC hc fun x _ hx => hf x ?_\n  rwa [ball_zero_eq]\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_le_of_nhds_zero","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nC : Real\nhC : LE.le 0 C\nhf : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))) (nhds 0)\n⊢ LE.le (Norm.norm f) C","decl":"theorem opNorm_le_of_nhds_zero {f : E →SL[σ₁₂] F} {C : ℝ} (hC : 0 ≤ C)\n    (hf : ∀ᶠ x in 𝓝 (0 : E), ‖f x‖ ≤ C * ‖x‖) : ‖f‖ ≤ C :=\n  let ⟨_, ε0, hε⟩ := Metric.eventually_nhds_iff_ball.1 hf\n  opNorm_le_of_ball ε0 hC hε\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_le_of_shell'","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\nε C : Real\nε_pos : LT.lt 0 ε\nhC : LE.le 0 C\nc : 𝕜\nhc : LT.lt (Norm.norm c) 1\nhf : ∀ (x : E), LE.le (HMul.hMul ε (Norm.norm c)) (Norm.norm x) → LT.lt (Norm.norm x) ε → LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\n⊢ LE.le (Norm.norm f) C","decl":"theorem opNorm_le_of_shell' {f : E →SL[σ₁₂] F} {ε C : ℝ} (ε_pos : 0 < ε) (hC : 0 ≤ C) {c : 𝕜}\n    (hc : ‖c‖ < 1) (hf : ∀ x, ε * ‖c‖ ≤ ‖x‖ → ‖x‖ < ε → ‖f x‖ ≤ C * ‖x‖) : ‖f‖ ≤ C := by\n  by_cases h0 : c = 0\n  · refine opNorm_le_of_ball ε_pos hC fun x hx => hf x ?_ ?_\n    · simp [h0]\n    · rwa [ball_zero_eq] at hx\n  · rw [← inv_inv c, norm_inv, inv_lt_one₀ (norm_pos_iff.2 <| inv_ne_zero h0)] at hc\n    refine opNorm_le_of_shell ε_pos hC hc ?_\n    rwa [norm_inv, div_eq_mul_inv, inv_inv]\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_le_of_unit_norm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"E : Type u_4\nF : Type u_5\ninst✝³ : SeminormedAddCommGroup E\ninst✝² : SeminormedAddCommGroup F\ninst✝¹ : NormedSpace Real E\ninst✝ : NormedSpace Real F\nf : ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhC : LE.le 0 C\nhf : ∀ (x : E), Eq (Norm.norm x) 1 → LE.le (Norm.norm (f x)) C\n⊢ LE.le (Norm.norm f) C","decl":"/-- For a continuous real linear map `f`, if one controls the norm of every `f x`, `‖x‖ = 1`, then\none controls the norm of `f`. -/\ntheorem opNorm_le_of_unit_norm [NormedSpace ℝ E] [NormedSpace ℝ F] {f : E →L[ℝ] F} {C : ℝ}\n    (hC : 0 ≤ C) (hf : ∀ x, ‖x‖ = 1 → ‖f x‖ ≤ C) : ‖f‖ ≤ C := by\n  refine opNorm_le_bound' f hC fun x hx => ?_\n  have H₁ : ‖‖x‖⁻¹ • x‖ = 1 := by rw [norm_smul, norm_inv, norm_norm, inv_mul_cancel₀ hx]\n  have H₂ := hf _ H₁\n  rwa [map_smul, norm_smul, norm_inv, norm_norm, ← div_eq_inv_mul, div_le_iff₀] at H₂\n  exact (norm_nonneg x).lt_of_ne' hx\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_add_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁶ : SeminormedAddCommGroup E\ninst✝⁵ : SeminormedAddCommGroup F\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NontriviallyNormedField 𝕜₂\ninst✝² : NormedSpace 𝕜 E\ninst✝¹ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\nf g : ContinuousLinearMap σ₁₂ E F\n⊢ LE.le (Norm.norm (HAdd.hAdd f g)) (HAdd.hAdd (Norm.norm f) (Norm.norm g))","decl":"/-- The operator norm satisfies the triangle inequality. -/\ntheorem opNorm_add_le : ‖f + g‖ ≤ ‖f‖ + ‖g‖ :=\n  (f + g).opNorm_le_bound (add_nonneg f.opNorm_nonneg g.opNorm_nonneg) fun x =>\n    (norm_add_le_of_le (f.le_opNorm x) (g.le_opNorm x)).trans_eq (add_mul _ _ _).symm\n\n\n"}
{"name":"ContinuousLinearMap.norm_id_of_nontrivial_seminorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_4\ninst✝² : SeminormedAddCommGroup E\ninst✝¹ : NontriviallyNormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\nh : Exists fun x => Ne (Norm.norm x) 0\n⊢ Eq (Norm.norm (ContinuousLinearMap.id 𝕜 E)) 1","decl":"/-- If there is an element with norm different from `0`, then the norm of the identity equals `1`.\n(Since we are working with seminorms supposing that the space is non-trivial is not enough.) -/\ntheorem norm_id_of_nontrivial_seminorm (h : ∃ x : E, ‖x‖ ≠ 0) : ‖id 𝕜 E‖ = 1 :=\n  le_antisymm norm_id_le <| by\n    let ⟨x, hx⟩ := h\n    have := (id 𝕜 E).ratio_le_opNorm x\n    rwa [id_apply, div_self hx] at this\n\n"}
{"name":"ContinuousLinearMap.opNorm_smul_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁹ : SeminormedAddCommGroup E\ninst✝⁸ : SeminormedAddCommGroup F\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NontriviallyNormedField 𝕜₂\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝³ : RingHomIsometric σ₁₂\n𝕜' : Type u_9\ninst✝² : NormedField 𝕜'\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : SMulCommClass 𝕜₂ 𝕜' F\nc : 𝕜'\nf : ContinuousLinearMap σ₁₂ E F\n⊢ LE.le (Norm.norm (HSMul.hSMul c f)) (HMul.hMul (Norm.norm c) (Norm.norm f))","decl":"theorem opNorm_smul_le {𝕜' : Type*} [NormedField 𝕜'] [NormedSpace 𝕜' F] [SMulCommClass 𝕜₂ 𝕜' F]\n    (c : 𝕜') (f : E →SL[σ₁₂] F) : ‖c • f‖ ≤ ‖c‖ * ‖f‖ :=\n  (c • f).opNorm_le_bound (mul_nonneg (norm_nonneg _) (opNorm_nonneg _)) fun _ => by\n    rw [smul_apply, norm_smul, mul_assoc]\n    exact mul_le_mul_of_nonneg_left (le_opNorm _ _) (norm_nonneg _)\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_comp_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\n𝕜₃ : Type u_3\nE : Type u_4\nF : Type u_5\nG : Type u_7\ninst✝¹¹ : SeminormedAddCommGroup E\ninst✝¹⁰ : SeminormedAddCommGroup F\ninst✝⁹ : SeminormedAddCommGroup G\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NontriviallyNormedField 𝕜₂\ninst✝⁶ : NontriviallyNormedField 𝕜₃\ninst✝⁵ : NormedSpace 𝕜 E\ninst✝⁴ : NormedSpace 𝕜₂ F\ninst✝³ : NormedSpace 𝕜₃ G\nσ₁₂ : RingHom 𝕜 𝕜₂\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝² : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\ninst✝¹ : RingHomIsometric σ₁₂\ninst✝ : RingHomIsometric σ₂₃\nh : ContinuousLinearMap σ₂₃ F G\nf : ContinuousLinearMap σ₁₂ E F\n⊢ LE.le (Norm.norm (h.comp f)) (HMul.hMul (Norm.norm h) (Norm.norm f))","decl":"/-- The operator norm is submultiplicative. -/\ntheorem opNorm_comp_le (f : E →SL[σ₁₂] F) : ‖h.comp f‖ ≤ ‖h‖ * ‖f‖ :=\n  csInf_le bounds_bddBelow\n    ⟨mul_nonneg (opNorm_nonneg _) (opNorm_nonneg _), fun x => by\n      rw [mul_assoc]\n      exact h.le_opNorm_of_le (f.le_opNorm x)⟩\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_subsingleton","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁷ : SeminormedAddCommGroup E\ninst✝⁶ : SeminormedAddCommGroup F\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NontriviallyNormedField 𝕜₂\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝¹ : RingHomIsometric σ₁₂\nf : ContinuousLinearMap σ₁₂ E F\ninst✝ : Subsingleton E\n⊢ Eq (Norm.norm f) 0","decl":"@[simp, nontriviality]\ntheorem opNorm_subsingleton [Subsingleton E] : ‖f‖ = 0 := by\n  refine le_antisymm ?_ (norm_nonneg _)\n  apply opNorm_le_bound _ rfl.ge\n  intro x\n  simp [Subsingleton.elim x 0]\n\n\n"}
{"name":"ContinuousLinearMap.norm_restrictScalars","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nFₗ : Type u_6\ninst✝¹⁰ : SeminormedAddCommGroup E\ninst✝⁹ : SeminormedAddCommGroup Fₗ\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NormedSpace 𝕜 E\ninst✝⁶ : NormedSpace 𝕜 Fₗ\n𝕜' : Type u_9\ninst✝⁵ : NontriviallyNormedField 𝕜'\ninst✝⁴ : NormedAlgebra 𝕜' 𝕜\ninst✝³ : NormedSpace 𝕜' E\ninst✝² : IsScalarTower 𝕜' 𝕜 E\ninst✝¹ : NormedSpace 𝕜' Fₗ\ninst✝ : IsScalarTower 𝕜' 𝕜 Fₗ\nf : ContinuousLinearMap (RingHom.id 𝕜) E Fₗ\n⊢ Eq (Norm.norm (ContinuousLinearMap.restrictScalars 𝕜' f)) (Norm.norm f)","decl":"@[simp]\ntheorem norm_restrictScalars (f : E →L[𝕜] Fₗ) : ‖f.restrictScalars 𝕜'‖ = ‖f‖ :=\n  le_antisymm (opNorm_le_bound _ (norm_nonneg _) fun x => f.le_opNorm x)\n    (opNorm_le_bound _ (norm_nonneg _) fun x => f.le_opNorm x)\n\n"}
{"name":"ContinuousLinearMap.coe_restrictScalarsIsometry","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nFₗ : Type u_6\ninst✝¹⁵ : SeminormedAddCommGroup E\ninst✝¹⁴ : SeminormedAddCommGroup Fₗ\ninst✝¹³ : NontriviallyNormedField 𝕜\ninst✝¹² : NormedSpace 𝕜 E\ninst✝¹¹ : NormedSpace 𝕜 Fₗ\n𝕜' : Type u_9\ninst✝¹⁰ : NontriviallyNormedField 𝕜'\ninst✝⁹ : NormedAlgebra 𝕜' 𝕜\ninst✝⁸ : NormedSpace 𝕜' E\ninst✝⁷ : IsScalarTower 𝕜' 𝕜 E\ninst✝⁶ : NormedSpace 𝕜' Fₗ\ninst✝⁵ : IsScalarTower 𝕜' 𝕜 Fₗ\n𝕜'' : Type u_10\ninst✝⁴ : Ring 𝕜''\ninst✝³ : Module 𝕜'' Fₗ\ninst✝² : ContinuousConstSMul 𝕜'' Fₗ\ninst✝¹ : SMulCommClass 𝕜 𝕜'' Fₗ\ninst✝ : SMulCommClass 𝕜' 𝕜'' Fₗ\n⊢ Eq (⇑(ContinuousLinearMap.restrictScalarsIsometry 𝕜 E Fₗ 𝕜' 𝕜'')) (ContinuousLinearMap.restrictScalars 𝕜')","decl":"@[simp]\ntheorem coe_restrictScalarsIsometry :\n    ⇑(restrictScalarsIsometry 𝕜 E Fₗ 𝕜' 𝕜'') = restrictScalars 𝕜' :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.restrictScalarsIsometry_toLinearMap","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_4\nFₗ : Type u_6\ninst✝¹⁵ : SeminormedAddCommGroup E\ninst✝¹⁴ : SeminormedAddCommGroup Fₗ\ninst✝¹³ : NontriviallyNormedField 𝕜\ninst✝¹² : NormedSpace 𝕜 E\ninst✝¹¹ : NormedSpace 𝕜 Fₗ\n𝕜' : Type u_9\ninst✝¹⁰ : NontriviallyNormedField 𝕜'\ninst✝⁹ : NormedAlgebra 𝕜' 𝕜\ninst✝⁸ : NormedSpace 𝕜' E\ninst✝⁷ : IsScalarTower 𝕜' 𝕜 E\ninst✝⁶ : NormedSpace 𝕜' Fₗ\ninst✝⁵ : IsScalarTower 𝕜' 𝕜 Fₗ\n𝕜'' : Type u_10\ninst✝⁴ : Ring 𝕜''\ninst✝³ : Module 𝕜'' Fₗ\ninst✝² : ContinuousConstSMul 𝕜'' Fₗ\ninst✝¹ : SMulCommClass 𝕜 𝕜'' Fₗ\ninst✝ : SMulCommClass 𝕜' 𝕜'' Fₗ\n⊢ Eq (ContinuousLinearMap.restrictScalarsIsometry 𝕜 E Fₗ 𝕜' 𝕜'').toLinearMap (ContinuousLinearMap.restrictScalarsₗ 𝕜 E Fₗ 𝕜' 𝕜'')","decl":"@[simp]\ntheorem restrictScalarsIsometry_toLinearMap :\n    (restrictScalarsIsometry 𝕜 E Fₗ 𝕜' 𝕜'').toLinearMap = restrictScalarsₗ 𝕜 E Fₗ 𝕜' 𝕜'' :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.norm_pi_le_of_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_4\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedSpace 𝕜 E\nι : Type u_9\ninst✝² : Fintype ι\nM : ι → Type u_10\ninst✝¹ : (i : ι) → SeminormedAddCommGroup (M i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (M i)\nC : Real\nL : (i : ι) → ContinuousLinearMap (RingHom.id 𝕜) E (M i)\nhL : ∀ (i : ι), LE.le (Norm.norm (L i)) C\nhC : LE.le 0 C\n⊢ LE.le (Norm.norm (ContinuousLinearMap.pi L)) C","decl":"lemma norm_pi_le_of_le {ι : Type*} [Fintype ι]\n    {M : ι → Type*} [∀ i, SeminormedAddCommGroup (M i)] [∀ i, NormedSpace 𝕜 (M i)] {C : ℝ}\n    {L : (i : ι) → (E →L[𝕜] M i)} (hL : ∀ i, ‖L i‖ ≤ C) (hC : 0 ≤ C) :\n    ‖pi L‖ ≤ C := by\n  refine opNorm_le_bound _ hC (fun x ↦ ?_)\n  refine (pi_norm_le_iff_of_nonneg (by positivity)).mpr (fun i ↦ ?_)\n  exact (L i).le_of_opNorm_le (hL i) _\n\n"}
{"name":"LinearMap.mkContinuous_norm_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : SeminormedAddCommGroup F\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NontriviallyNormedField 𝕜₂\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nf : LinearMap σ₁₂ E F\nC : Real\nhC : LE.le 0 C\nh : ∀ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\n⊢ LE.le (Norm.norm (f.mkContinuous C h)) C","decl":"/-- If a continuous linear map is constructed from a linear map via the constructor `mkContinuous`,\nthen its norm is bounded by the bound given to the constructor if it is nonnegative. -/\ntheorem mkContinuous_norm_le (f : E →ₛₗ[σ₁₂] F) {C : ℝ} (hC : 0 ≤ C) (h : ∀ x, ‖f x‖ ≤ C * ‖x‖) :\n    ‖f.mkContinuous C h‖ ≤ C :=\n  ContinuousLinearMap.opNorm_le_bound _ hC h\n\n"}
{"name":"LinearMap.mkContinuous_norm_le'","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : SeminormedAddCommGroup F\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NontriviallyNormedField 𝕜₂\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nf : LinearMap σ₁₂ E F\nC : Real\nh : ∀ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\n⊢ LE.le (Norm.norm (f.mkContinuous C h)) (Max.max C 0)","decl":"/-- If a continuous linear map is constructed from a linear map via the constructor `mkContinuous`,\nthen its norm is bounded by the bound or zero if bound is negative. -/\ntheorem mkContinuous_norm_le' (f : E →ₛₗ[σ₁₂] F) {C : ℝ} (h : ∀ x, ‖f x‖ ≤ C * ‖x‖) :\n    ‖f.mkContinuous C h‖ ≤ max C 0 :=\n  ContinuousLinearMap.opNorm_le_bound _ (le_max_right _ _) fun x =>\n    (h x).trans <| mul_le_mul_of_nonneg_right (le_max_left _ _) (norm_nonneg x)\n\n"}
{"name":"LinearIsometry.norm_toContinuousLinearMap_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\n𝕜₂ : Type u_2\nE : Type u_4\nF : Type u_5\ninst✝⁵ : SeminormedAddCommGroup E\ninst✝⁴ : SeminormedAddCommGroup F\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NontriviallyNormedField 𝕜₂\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : NormedSpace 𝕜₂ F\nσ₁₂ : RingHom 𝕜 𝕜₂\nf : LinearIsometry σ₁₂ E F\n⊢ LE.le (Norm.norm f.toContinuousLinearMap) 1","decl":"theorem norm_toContinuousLinearMap_le (f : E →ₛₗᵢ[σ₁₂] F) : ‖f.toContinuousLinearMap‖ ≤ 1 :=\n  f.toContinuousLinearMap.opNorm_le_bound zero_le_one fun x => by simp\n\n"}
{"name":"Submodule.norm_subtypeL_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"𝕜 : Type u_1\nE : Type u_4\ninst✝² : SeminormedAddCommGroup E\ninst✝¹ : NontriviallyNormedField 𝕜\ninst✝ : NormedSpace 𝕜 E\nK : Submodule 𝕜 E\n⊢ LE.le (Norm.norm K.subtypeL) 1","decl":"theorem norm_subtypeL_le (K : Submodule 𝕜 E) : ‖K.subtypeL‖ ≤ 1 :=\n  K.subtypeₗᵢ.norm_toContinuousLinearMap_le\n\n"}
