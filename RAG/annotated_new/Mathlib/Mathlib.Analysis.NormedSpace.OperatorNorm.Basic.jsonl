{"name":"norm_image_of_norm_zero","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\nğ“• : Type u_8\ninstâœâ· : SeminormedAddCommGroup E\ninstâœâ¶ : SeminormedAddCommGroup F\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœÂ¹ : FunLike ğ“• E F\ninstâœ : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F\nf : ğ“•\nhf : Continuous â‡‘f\nx : E\nhx : Eq (Norm.norm x) 0\nâŠ¢ Eq (Norm.norm (f x)) 0","decl":"/-- If `â€–xâ€– = 0` and `f` is continuous then `â€–f xâ€– = 0`. -/\ntheorem norm_image_of_norm_zero [SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F] (f : ğ“•) (hf : Continuous f) {x : E}\n    (hx : â€–xâ€– = 0) : â€–f xâ€– = 0 := by\n  rw [â† mem_closure_zero_iff_norm, â† specializes_iff_mem_closure, â† map_zero f] at *\n  exact hx.map hf\n\n"}
{"name":"SemilinearMapClass.bound_of_shell_semi_normed","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\nğ“• : Type u_8\ninstâœâ¸ : SeminormedAddCommGroup E\ninstâœâ· : SeminormedAddCommGroup F\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœÂ² : FunLike ğ“• E F\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœ : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F\nf : ğ“•\nÎµ C : Real\nÎµ_pos : LT.lt 0 Îµ\nc : ğ•œ\nhc : LT.lt 1 (Norm.norm c)\nhf : âˆ€ (x : E), LE.le (HDiv.hDiv Îµ (Norm.norm c)) (Norm.norm x) â†’ LT.lt (Norm.norm x) Îµ â†’ LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\nx : E\nhx : Ne (Norm.norm x) 0\nâŠ¢ LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))","decl":"theorem SemilinearMapClass.bound_of_shell_semi_normed [SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F] (f : ğ“•)\n    {Îµ C : â„} (Îµ_pos : 0 < Îµ) {c : ğ•œ} (hc : 1 < â€–câ€–)\n    (hf : âˆ€ x, Îµ / â€–câ€– â‰¤ â€–xâ€– â†’ â€–xâ€– < Îµ â†’ â€–f xâ€– â‰¤ C * â€–xâ€–) {x : E} (hx : â€–xâ€– â‰  0) :\n    â€–f xâ€– â‰¤ C * â€–xâ€– :=\n  (normSeminorm ğ•œ E).bound_of_shell ((normSeminorm ğ•œâ‚‚ F).comp âŸ¨âŸ¨f, map_add fâŸ©, map_smulâ‚›â‚— fâŸ©)\n    Îµ_pos hc hf hx\n\n"}
{"name":"SemilinearMapClass.bound_of_continuous","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\nğ“• : Type u_8\ninstâœâ¸ : SeminormedAddCommGroup E\ninstâœâ· : SeminormedAddCommGroup F\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœÂ² : FunLike ğ“• E F\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœ : SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F\nf : ğ“•\nhf : Continuous â‡‘f\nâŠ¢ Exists fun C => And (LT.lt 0 C) (âˆ€ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x)))","decl":"/-- A continuous linear map between seminormed spaces is bounded when the field is nontrivially\nnormed. The continuity ensures boundedness on a ball of some radius `Îµ`. The nontriviality of the\nnorm is then used to rescale any element into an element of norm in `[Îµ/C, Îµ]`, whose image has a\ncontrolled norm. The norm control for the original element follows by rescaling. -/\ntheorem SemilinearMapClass.bound_of_continuous [SemilinearMapClass ğ“• Ïƒâ‚â‚‚ E F] (f : ğ“•)\n    (hf : Continuous f) : âˆƒ C, 0 < C âˆ§ âˆ€ x : E, â€–f xâ€– â‰¤ C * â€–xâ€– :=\n  let Ï† : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F := âŸ¨âŸ¨f, map_add fâŸ©, map_smulâ‚›â‚— fâŸ©\n  ((normSeminorm ğ•œâ‚‚ F).comp Ï†).bound_of_continuous_normedSpace (continuous_norm.comp hf)\n\n"}
{"name":"ContinuousLinearMap.bound","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Exists fun C => And (LT.lt 0 C) (âˆ€ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x)))","decl":"theorem bound [RingHomIsometric Ïƒâ‚â‚‚] (f : E â†’SL[Ïƒâ‚â‚‚] F) : âˆƒ C, 0 < C âˆ§ âˆ€ x : E, â€–f xâ€– â‰¤ C * â€–xâ€– :=\n  SemilinearMapClass.bound_of_continuous f f.2\n\n"}
{"name":"LinearIsometry.toSpanSingleton_apply","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : NontriviallyNormedField ğ•œ\ninstâœ : NormedSpace ğ•œ E\nv : E\nhv : Eq (Norm.norm v) 1\na : ğ•œ\nâŠ¢ Eq ((LinearIsometry.toSpanSingleton ğ•œ E hv) a) (HSMul.hSMul a v)","decl":"@[simp]\ntheorem _root_.LinearIsometry.toSpanSingleton_apply {v : E} (hv : â€–vâ€– = 1) (a : ğ•œ) :\n    LinearIsometry.toSpanSingleton ğ•œ E hv a = a â€¢ v :=\n  rfl\n\n"}
{"name":"LinearIsometry.coe_toSpanSingleton","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : NontriviallyNormedField ğ•œ\ninstâœ : NormedSpace ğ•œ E\nv : E\nhv : Eq (Norm.norm v) 1\nâŠ¢ Eq (LinearIsometry.toSpanSingleton ğ•œ E hv).toLinearMap (LinearMap.toSpanSingleton ğ•œ E v)","decl":"@[simp]\ntheorem _root_.LinearIsometry.coe_toSpanSingleton {v : E} (hv : â€–vâ€– = 1) :\n    (LinearIsometry.toSpanSingleton ğ•œ E hv).toLinearMap = LinearMap.toSpanSingleton ğ•œ E v :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.norm_def","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : SeminormedAddCommGroup F\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Eq (Norm.norm f) (InfSet.sInf (setOf fun c => And (LE.le 0 c) (âˆ€ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul c (Norm.norm x)))))","decl":"theorem norm_def (f : E â†’SL[Ïƒâ‚â‚‚] F) : â€–fâ€– = sInf { c | 0 â‰¤ c âˆ§ âˆ€ x, â€–f xâ€– â‰¤ c * â€–xâ€– } :=\n  rfl\n\n-- So that invocations of `le_csInf` make sense: we show that the set of\n-- bounds is nonempty and bounded below.\n"}
{"name":"ContinuousLinearMap.bounds_nonempty","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Exists fun c => Membership.mem (setOf fun c => And (LE.le 0 c) (âˆ€ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul c (Norm.norm x)))) c","decl":"theorem bounds_nonempty [RingHomIsometric Ïƒâ‚â‚‚] {f : E â†’SL[Ïƒâ‚â‚‚] F} :\n    âˆƒ c, c âˆˆ { c | 0 â‰¤ c âˆ§ âˆ€ x, â€–f xâ€– â‰¤ c * â€–xâ€– } :=\n  let âŸ¨M, hMp, hMbâŸ© := f.bound\n  âŸ¨M, le_of_lt hMp, hMbâŸ©\n\n"}
{"name":"ContinuousLinearMap.bounds_bddBelow","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : SeminormedAddCommGroup F\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ BddBelow (setOf fun c => And (LE.le 0 c) (âˆ€ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul c (Norm.norm x))))","decl":"theorem bounds_bddBelow {f : E â†’SL[Ïƒâ‚â‚‚] F} : BddBelow { c | 0 â‰¤ c âˆ§ âˆ€ x, â€–f xâ€– â‰¤ c * â€–xâ€– } :=\n  âŸ¨0, fun _ âŸ¨hn, _âŸ© => hnâŸ©\n\n"}
{"name":"ContinuousLinearMap.isLeast_opNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ IsLeast (setOf fun c => And (LE.le 0 c) (âˆ€ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul c (Norm.norm x)))) (Norm.norm f)","decl":"theorem isLeast_opNorm [RingHomIsometric Ïƒâ‚â‚‚] (f : E â†’SL[Ïƒâ‚â‚‚] F) :\n    IsLeast {c | 0 â‰¤ c âˆ§ âˆ€ x, â€–f xâ€– â‰¤ c * â€–xâ€–} â€–fâ€– := by\n  refine IsClosed.isLeast_csInf ?_ bounds_nonempty bounds_bddBelow\n  simp only [setOf_and, setOf_forall]\n  refine isClosed_Ici.inter <| isClosed_iInter fun _ â†¦ isClosed_le ?_ ?_ <;> continuity\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_le_bound","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : SeminormedAddCommGroup F\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nM : Real\nhMp : LE.le 0 M\nhM : âˆ€ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul M (Norm.norm x))\nâŠ¢ LE.le (Norm.norm f) M","decl":"/-- If one controls the norm of every `A x`, then one controls the norm of `A`. -/\ntheorem opNorm_le_bound (f : E â†’SL[Ïƒâ‚â‚‚] F) {M : â„} (hMp : 0 â‰¤ M) (hM : âˆ€ x, â€–f xâ€– â‰¤ M * â€–xâ€–) :\n    â€–fâ€– â‰¤ M :=\n  csInf_le bounds_bddBelow âŸ¨hMp, hMâŸ©\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_le_bound'","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : SeminormedAddCommGroup F\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nM : Real\nhMp : LE.le 0 M\nhM : âˆ€ (x : E), Ne (Norm.norm x) 0 â†’ LE.le (Norm.norm (f x)) (HMul.hMul M (Norm.norm x))\nâŠ¢ LE.le (Norm.norm f) M","decl":"/-- If one controls the norm of every `A x`, `â€–xâ€– â‰  0`, then one controls the norm of `A`. -/\ntheorem opNorm_le_bound' (f : E â†’SL[Ïƒâ‚â‚‚] F) {M : â„} (hMp : 0 â‰¤ M)\n    (hM : âˆ€ x, â€–xâ€– â‰  0 â†’ â€–f xâ€– â‰¤ M * â€–xâ€–) : â€–fâ€– â‰¤ M :=\n  opNorm_le_bound f hMp fun x =>\n    (ne_or_eq â€–xâ€– 0).elim (hM x) fun h => by\n      simp only [h, mul_zero, norm_image_of_norm_zero f f.2 h, le_refl]\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_le_of_lipschitz","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : SeminormedAddCommGroup F\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nK : NNReal\nhf : LipschitzWith K â‡‘f\nâŠ¢ LE.le (Norm.norm f) â†‘K","decl":"theorem opNorm_le_of_lipschitz {f : E â†’SL[Ïƒâ‚â‚‚] F} {K : â„â‰¥0} (hf : LipschitzWith K f) : â€–fâ€– â‰¤ K :=\n  f.opNorm_le_bound K.2 fun x => by\n    simpa only [dist_zero_right, f.map_zero] using hf.dist_le_mul x 0\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_eq_of_bounds","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : SeminormedAddCommGroup F\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏ† : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nM : Real\nM_nonneg : LE.le 0 M\nh_above : âˆ€ (x : E), LE.le (Norm.norm (Ï† x)) (HMul.hMul M (Norm.norm x))\nh_below : âˆ€ (N : Real), GE.ge N 0 â†’ (âˆ€ (x : E), LE.le (Norm.norm (Ï† x)) (HMul.hMul N (Norm.norm x))) â†’ LE.le M N\nâŠ¢ Eq (Norm.norm Ï†) M","decl":"theorem opNorm_eq_of_bounds {Ï† : E â†’SL[Ïƒâ‚â‚‚] F} {M : â„} (M_nonneg : 0 â‰¤ M)\n    (h_above : âˆ€ x, â€–Ï† xâ€– â‰¤ M * â€–xâ€–) (h_below : âˆ€ N â‰¥ 0, (âˆ€ x, â€–Ï† xâ€– â‰¤ N * â€–xâ€–) â†’ M â‰¤ N) :\n    â€–Ï†â€– = M :=\n  le_antisymm (Ï†.opNorm_le_bound M_nonneg h_above)\n    ((le_csInf_iff ContinuousLinearMap.bounds_bddBelow âŸ¨M, M_nonneg, h_aboveâŸ©).mpr\n      fun N âŸ¨N_nonneg, hNâŸ© => h_below N N_nonneg hN)\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_neg","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : SeminormedAddCommGroup F\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ Eq (Norm.norm (Neg.neg f)) (Norm.norm f)","decl":"theorem opNorm_neg (f : E â†’SL[Ïƒâ‚â‚‚] F) : â€–-fâ€– = â€–fâ€– := by simp only [norm_def, neg_apply, norm_neg]\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_nonneg","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : SeminormedAddCommGroup F\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ LE.le 0 (Norm.norm f)","decl":"theorem opNorm_nonneg (f : E â†’SL[Ïƒâ‚â‚‚] F) : 0 â‰¤ â€–fâ€– :=\n  Real.sInf_nonneg fun _ â†¦ And.left\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_zero","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : SeminormedAddCommGroup F\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nâŠ¢ Eq (Norm.norm 0) 0","decl":"/-- The norm of the `0` operator is `0`. -/\ntheorem opNorm_zero : â€–(0 : E â†’SL[Ïƒâ‚â‚‚] F)â€– = 0 :=\n  le_antisymm (opNorm_le_bound _ le_rfl fun _ â†¦ by simp) (opNorm_nonneg _)\n\n\n"}
{"name":"ContinuousLinearMap.norm_id_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : NontriviallyNormedField ğ•œ\ninstâœ : NormedSpace ğ•œ E\nâŠ¢ LE.le (Norm.norm (ContinuousLinearMap.id ğ•œ E)) 1","decl":"/-- The norm of the identity is at most `1`. It is in fact `1`, except when the space is trivial\nwhere it is `0`. It means that one can not do better than an inequality in general. -/\ntheorem norm_id_le : â€–id ğ•œ Eâ€– â‰¤ 1 :=\n  opNorm_le_bound _ zero_le_one fun x => by simp\n\n"}
{"name":"ContinuousLinearMap.le_opNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nx : E\nâŠ¢ LE.le (Norm.norm (f x)) (HMul.hMul (Norm.norm f) (Norm.norm x))","decl":"/-- The fundamental property of the operator norm: `â€–f xâ€– â‰¤ â€–fâ€– * â€–xâ€–`. -/\ntheorem le_opNorm : â€–f xâ€– â‰¤ â€–fâ€– * â€–xâ€– := (isLeast_opNorm f).1.2 x\n\n\n"}
{"name":"ContinuousLinearMap.dist_le_opNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nx y : E\nâŠ¢ LE.le (Dist.dist (f x) (f y)) (HMul.hMul (Norm.norm f) (Dist.dist x y))","decl":"theorem dist_le_opNorm (x y : E) : dist (f x) (f y) â‰¤ â€–fâ€– * dist x y := by\n  simp_rw [dist_eq_norm, â† map_sub, f.le_opNorm]\n\n\n"}
{"name":"ContinuousLinearMap.le_of_opNorm_le_of_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nx : E\na b : Real\nhf : LE.le (Norm.norm f) a\nhx : LE.le (Norm.norm x) b\nâŠ¢ LE.le (Norm.norm (f x)) (HMul.hMul a b)","decl":"theorem le_of_opNorm_le_of_le {x} {a b : â„} (hf : â€–fâ€– â‰¤ a) (hx : â€–xâ€– â‰¤ b) :\n    â€–f xâ€– â‰¤ a * b :=\n  (f.le_opNorm x).trans <| by gcongr; exact (opNorm_nonneg f).trans hf\n\n\n"}
{"name":"ContinuousLinearMap.le_opNorm_of_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nc : Real\nx : E\nh : LE.le (Norm.norm x) c\nâŠ¢ LE.le (Norm.norm (f x)) (HMul.hMul (Norm.norm f) c)","decl":"theorem le_opNorm_of_le {c : â„} {x} (h : â€–xâ€– â‰¤ c) : â€–f xâ€– â‰¤ â€–fâ€– * c :=\n  f.le_of_opNorm_le_of_le le_rfl h\n\n\n"}
{"name":"ContinuousLinearMap.le_of_opNorm_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nc : Real\nh : LE.le (Norm.norm f) c\nx : E\nâŠ¢ LE.le (Norm.norm (f x)) (HMul.hMul c (Norm.norm x))","decl":"theorem le_of_opNorm_le {c : â„} (h : â€–fâ€– â‰¤ c) (x : E) : â€–f xâ€– â‰¤ c * â€–xâ€– :=\n  f.le_of_opNorm_le_of_le h le_rfl\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_le_iff","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nM : Real\nhMp : LE.le 0 M\nâŠ¢ Iff (LE.le (Norm.norm f) M) (âˆ€ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul M (Norm.norm x)))","decl":"theorem opNorm_le_iff {f : E â†’SL[Ïƒâ‚â‚‚] F} {M : â„} (hMp : 0 â‰¤ M) :\n    â€–fâ€– â‰¤ M â†” âˆ€ x, â€–f xâ€– â‰¤ M * â€–xâ€– :=\n  âŸ¨f.le_of_opNorm_le, opNorm_le_bound f hMpâŸ©\n\n\n"}
{"name":"ContinuousLinearMap.ratio_le_opNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nx : E\nâŠ¢ LE.le (HDiv.hDiv (Norm.norm (f x)) (Norm.norm x)) (Norm.norm f)","decl":"theorem ratio_le_opNorm : â€–f xâ€– / â€–xâ€– â‰¤ â€–fâ€– :=\n  div_le_of_le_mulâ‚€ (norm_nonneg _) f.opNorm_nonneg (le_opNorm _ _)\n\n\n"}
{"name":"ContinuousLinearMap.unit_le_opNorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nx : E\naâœ : LE.le (Norm.norm x) 1\nâŠ¢ LE.le (Norm.norm (f x)) (Norm.norm f)","decl":"/-- The image of the unit ball under a continuous linear map is bounded. -/\ntheorem unit_le_opNorm : â€–xâ€– â‰¤ 1 â†’ â€–f xâ€– â‰¤ â€–fâ€– :=\n  mul_one â€–fâ€– â–¸ f.le_opNorm_of_le\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_le_of_shell","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nÎµ C : Real\nÎµ_pos : LT.lt 0 Îµ\nhC : LE.le 0 C\nc : ğ•œ\nhc : LT.lt 1 (Norm.norm c)\nhf : âˆ€ (x : E), LE.le (HDiv.hDiv Îµ (Norm.norm c)) (Norm.norm x) â†’ LT.lt (Norm.norm x) Îµ â†’ LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\nâŠ¢ LE.le (Norm.norm f) C","decl":"theorem opNorm_le_of_shell {f : E â†’SL[Ïƒâ‚â‚‚] F} {Îµ C : â„} (Îµ_pos : 0 < Îµ) (hC : 0 â‰¤ C) {c : ğ•œ}\n    (hc : 1 < â€–câ€–) (hf : âˆ€ x, Îµ / â€–câ€– â‰¤ â€–xâ€– â†’ â€–xâ€– < Îµ â†’ â€–f xâ€– â‰¤ C * â€–xâ€–) : â€–fâ€– â‰¤ C :=\n  f.opNorm_le_bound' hC fun _ hx => SemilinearMapClass.bound_of_shell_semi_normed f Îµ_pos hc hf hx\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_le_of_ball","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nÎµ C : Real\nÎµ_pos : LT.lt 0 Îµ\nhC : LE.le 0 C\nhf : âˆ€ (x : E), Membership.mem (Metric.ball 0 Îµ) x â†’ LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\nâŠ¢ LE.le (Norm.norm f) C","decl":"theorem opNorm_le_of_ball {f : E â†’SL[Ïƒâ‚â‚‚] F} {Îµ : â„} {C : â„} (Îµ_pos : 0 < Îµ) (hC : 0 â‰¤ C)\n    (hf : âˆ€ x âˆˆ ball (0 : E) Îµ, â€–f xâ€– â‰¤ C * â€–xâ€–) : â€–fâ€– â‰¤ C := by\n  rcases NormedField.exists_one_lt_norm ğ•œ with âŸ¨c, hcâŸ©\n  refine opNorm_le_of_shell Îµ_pos hC hc fun x _ hx => hf x ?_\n  rwa [ball_zero_eq]\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_le_of_nhds_zero","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nC : Real\nhC : LE.le 0 C\nhf : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))) (nhds 0)\nâŠ¢ LE.le (Norm.norm f) C","decl":"theorem opNorm_le_of_nhds_zero {f : E â†’SL[Ïƒâ‚â‚‚] F} {C : â„} (hC : 0 â‰¤ C)\n    (hf : âˆ€á¶  x in ğ“ (0 : E), â€–f xâ€– â‰¤ C * â€–xâ€–) : â€–fâ€– â‰¤ C :=\n  let âŸ¨_, Îµ0, hÎµâŸ© := Metric.eventually_nhds_iff_ball.1 hf\n  opNorm_le_of_ball Îµ0 hC hÎµ\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_le_of_shell'","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nÎµ C : Real\nÎµ_pos : LT.lt 0 Îµ\nhC : LE.le 0 C\nc : ğ•œ\nhc : LT.lt (Norm.norm c) 1\nhf : âˆ€ (x : E), LE.le (HMul.hMul Îµ (Norm.norm c)) (Norm.norm x) â†’ LT.lt (Norm.norm x) Îµ â†’ LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\nâŠ¢ LE.le (Norm.norm f) C","decl":"theorem opNorm_le_of_shell' {f : E â†’SL[Ïƒâ‚â‚‚] F} {Îµ C : â„} (Îµ_pos : 0 < Îµ) (hC : 0 â‰¤ C) {c : ğ•œ}\n    (hc : â€–câ€– < 1) (hf : âˆ€ x, Îµ * â€–câ€– â‰¤ â€–xâ€– â†’ â€–xâ€– < Îµ â†’ â€–f xâ€– â‰¤ C * â€–xâ€–) : â€–fâ€– â‰¤ C := by\n  by_cases h0 : c = 0\n  Â· refine opNorm_le_of_ball Îµ_pos hC fun x hx => hf x ?_ ?_\n    Â· simp [h0]\n    Â· rwa [ball_zero_eq] at hx\n  Â· rw [â† inv_inv c, norm_inv, inv_lt_oneâ‚€ (norm_pos_iff.2 <| inv_ne_zero h0)] at hc\n    refine opNorm_le_of_shell Îµ_pos hC hc ?_\n    rwa [norm_inv, div_eq_mul_inv, inv_inv]\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_le_of_unit_norm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"E : Type u_4\nF : Type u_5\ninstâœÂ³ : SeminormedAddCommGroup E\ninstâœÂ² : SeminormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : NormedSpace Real F\nf : ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhC : LE.le 0 C\nhf : âˆ€ (x : E), Eq (Norm.norm x) 1 â†’ LE.le (Norm.norm (f x)) C\nâŠ¢ LE.le (Norm.norm f) C","decl":"/-- For a continuous real linear map `f`, if one controls the norm of every `f x`, `â€–xâ€– = 1`, then\none controls the norm of `f`. -/\ntheorem opNorm_le_of_unit_norm [NormedSpace â„ E] [NormedSpace â„ F] {f : E â†’L[â„] F} {C : â„}\n    (hC : 0 â‰¤ C) (hf : âˆ€ x, â€–xâ€– = 1 â†’ â€–f xâ€– â‰¤ C) : â€–fâ€– â‰¤ C := by\n  refine opNorm_le_bound' f hC fun x hx => ?_\n  have Hâ‚ : â€–â€–xâ€–â»Â¹ â€¢ xâ€– = 1 := by rw [norm_smul, norm_inv, norm_norm, inv_mul_cancelâ‚€ hx]\n  have Hâ‚‚ := hf _ Hâ‚\n  rwa [map_smul, norm_smul, norm_inv, norm_norm, â† div_eq_inv_mul, div_le_iffâ‚€] at Hâ‚‚\n  exact (norm_nonneg x).lt_of_ne' hx\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_add_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¶ : SeminormedAddCommGroup E\ninstâœâµ : SeminormedAddCommGroup F\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\nf g : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ LE.le (Norm.norm (HAdd.hAdd f g)) (HAdd.hAdd (Norm.norm f) (Norm.norm g))","decl":"/-- The operator norm satisfies the triangle inequality. -/\ntheorem opNorm_add_le : â€–f + gâ€– â‰¤ â€–fâ€– + â€–gâ€– :=\n  (f + g).opNorm_le_bound (add_nonneg f.opNorm_nonneg g.opNorm_nonneg) fun x =>\n    (norm_add_le_of_le (f.le_opNorm x) (g.le_opNorm x)).trans_eq (add_mul _ _ _).symm\n\n\n"}
{"name":"ContinuousLinearMap.norm_id_of_nontrivial_seminorm","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : NontriviallyNormedField ğ•œ\ninstâœ : NormedSpace ğ•œ E\nh : Exists fun x => Ne (Norm.norm x) 0\nâŠ¢ Eq (Norm.norm (ContinuousLinearMap.id ğ•œ E)) 1","decl":"/-- If there is an element with norm different from `0`, then the norm of the identity equals `1`.\n(Since we are working with seminorms supposing that the space is non-trivial is not enough.) -/\ntheorem norm_id_of_nontrivial_seminorm (h : âˆƒ x : E, â€–xâ€– â‰  0) : â€–id ğ•œ Eâ€– = 1 :=\n  le_antisymm norm_id_le <| by\n    let âŸ¨x, hxâŸ© := h\n    have := (id ğ•œ E).ratio_le_opNorm x\n    rwa [id_apply, div_self hx] at this\n\n"}
{"name":"ContinuousLinearMap.opNorm_smul_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ¹ : SeminormedAddCommGroup E\ninstâœâ¸ : SeminormedAddCommGroup F\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NontriviallyNormedField ğ•œâ‚‚\ninstâœâµ : NormedSpace ğ•œ E\ninstâœâ´ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœÂ³ : RingHomIsometric Ïƒâ‚â‚‚\nğ•œ' : Type u_9\ninstâœÂ² : NormedField ğ•œ'\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : SMulCommClass ğ•œâ‚‚ ğ•œ' F\nc : ğ•œ'\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ LE.le (Norm.norm (HSMul.hSMul c f)) (HMul.hMul (Norm.norm c) (Norm.norm f))","decl":"theorem opNorm_smul_le {ğ•œ' : Type*} [NormedField ğ•œ'] [NormedSpace ğ•œ' F] [SMulCommClass ğ•œâ‚‚ ğ•œ' F]\n    (c : ğ•œ') (f : E â†’SL[Ïƒâ‚â‚‚] F) : â€–c â€¢ fâ€– â‰¤ â€–câ€– * â€–fâ€– :=\n  (c â€¢ f).opNorm_le_bound (mul_nonneg (norm_nonneg _) (opNorm_nonneg _)) fun _ => by\n    rw [smul_apply, norm_smul, mul_assoc]\n    exact mul_le_mul_of_nonneg_left (le_opNorm _ _) (norm_nonneg _)\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_comp_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nğ•œâ‚ƒ : Type u_3\nE : Type u_4\nF : Type u_5\nG : Type u_7\ninstâœÂ¹Â¹ : SeminormedAddCommGroup E\ninstâœÂ¹â° : SeminormedAddCommGroup F\ninstâœâ¹ : SeminormedAddCommGroup G\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NontriviallyNormedField ğ•œâ‚‚\ninstâœâ¶ : NontriviallyNormedField ğ•œâ‚ƒ\ninstâœâµ : NormedSpace ğ•œ E\ninstâœâ´ : NormedSpace ğ•œâ‚‚ F\ninstâœÂ³ : NormedSpace ğ•œâ‚ƒ G\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœÂ² : RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœ : RingHomIsometric Ïƒâ‚‚â‚ƒ\nh : ContinuousLinearMap Ïƒâ‚‚â‚ƒ F G\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\nâŠ¢ LE.le (Norm.norm (h.comp f)) (HMul.hMul (Norm.norm h) (Norm.norm f))","decl":"/-- The operator norm is submultiplicative. -/\ntheorem opNorm_comp_le (f : E â†’SL[Ïƒâ‚â‚‚] F) : â€–h.comp fâ€– â‰¤ â€–hâ€– * â€–fâ€– :=\n  csInf_le bounds_bddBelow\n    âŸ¨mul_nonneg (opNorm_nonneg _) (opNorm_nonneg _), fun x => by\n      rw [mul_assoc]\n      exact h.le_opNorm_of_le (f.le_opNorm x)âŸ©\n\n\n"}
{"name":"ContinuousLinearMap.opNorm_subsingleton","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâ· : SeminormedAddCommGroup E\ninstâœâ¶ : SeminormedAddCommGroup F\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœÂ¹ : RingHomIsometric Ïƒâ‚â‚‚\nf : ContinuousLinearMap Ïƒâ‚â‚‚ E F\ninstâœ : Subsingleton E\nâŠ¢ Eq (Norm.norm f) 0","decl":"@[simp, nontriviality]\ntheorem opNorm_subsingleton [Subsingleton E] : â€–fâ€– = 0 := by\n  refine le_antisymm ?_ (norm_nonneg _)\n  apply opNorm_le_bound _ rfl.ge\n  intro x\n  simp [Subsingleton.elim x 0]\n\n\n"}
{"name":"ContinuousLinearMap.norm_restrictScalars","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nFâ‚— : Type u_6\ninstâœÂ¹â° : SeminormedAddCommGroup E\ninstâœâ¹ : SeminormedAddCommGroup Fâ‚—\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NormedSpace ğ•œ E\ninstâœâ¶ : NormedSpace ğ•œ Fâ‚—\nğ•œ' : Type u_9\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ' ğ•œ\ninstâœÂ³ : NormedSpace ğ•œ' E\ninstâœÂ² : IsScalarTower ğ•œ' ğ•œ E\ninstâœÂ¹ : NormedSpace ğ•œ' Fâ‚—\ninstâœ : IsScalarTower ğ•œ' ğ•œ Fâ‚—\nf : ContinuousLinearMap (RingHom.id ğ•œ) E Fâ‚—\nâŠ¢ Eq (Norm.norm (ContinuousLinearMap.restrictScalars ğ•œ' f)) (Norm.norm f)","decl":"@[simp]\ntheorem norm_restrictScalars (f : E â†’L[ğ•œ] Fâ‚—) : â€–f.restrictScalars ğ•œ'â€– = â€–fâ€– :=\n  le_antisymm (opNorm_le_bound _ (norm_nonneg _) fun x => f.le_opNorm x)\n    (opNorm_le_bound _ (norm_nonneg _) fun x => f.le_opNorm x)\n\n"}
{"name":"ContinuousLinearMap.coe_restrictScalarsIsometry","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nFâ‚— : Type u_6\ninstâœÂ¹âµ : SeminormedAddCommGroup E\ninstâœÂ¹â´ : SeminormedAddCommGroup Fâ‚—\ninstâœÂ¹Â³ : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â² : NormedSpace ğ•œ E\ninstâœÂ¹Â¹ : NormedSpace ğ•œ Fâ‚—\nğ•œ' : Type u_9\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ'\ninstâœâ¹ : NormedAlgebra ğ•œ' ğ•œ\ninstâœâ¸ : NormedSpace ğ•œ' E\ninstâœâ· : IsScalarTower ğ•œ' ğ•œ E\ninstâœâ¶ : NormedSpace ğ•œ' Fâ‚—\ninstâœâµ : IsScalarTower ğ•œ' ğ•œ Fâ‚—\nğ•œ'' : Type u_10\ninstâœâ´ : Ring ğ•œ''\ninstâœÂ³ : Module ğ•œ'' Fâ‚—\ninstâœÂ² : ContinuousConstSMul ğ•œ'' Fâ‚—\ninstâœÂ¹ : SMulCommClass ğ•œ ğ•œ'' Fâ‚—\ninstâœ : SMulCommClass ğ•œ' ğ•œ'' Fâ‚—\nâŠ¢ Eq (â‡‘(ContinuousLinearMap.restrictScalarsIsometry ğ•œ E Fâ‚— ğ•œ' ğ•œ'')) (ContinuousLinearMap.restrictScalars ğ•œ')","decl":"@[simp]\ntheorem coe_restrictScalarsIsometry :\n    â‡‘(restrictScalarsIsometry ğ•œ E Fâ‚— ğ•œ' ğ•œ'') = restrictScalars ğ•œ' :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.restrictScalarsIsometry_toLinearMap","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\nFâ‚— : Type u_6\ninstâœÂ¹âµ : SeminormedAddCommGroup E\ninstâœÂ¹â´ : SeminormedAddCommGroup Fâ‚—\ninstâœÂ¹Â³ : NontriviallyNormedField ğ•œ\ninstâœÂ¹Â² : NormedSpace ğ•œ E\ninstâœÂ¹Â¹ : NormedSpace ğ•œ Fâ‚—\nğ•œ' : Type u_9\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ'\ninstâœâ¹ : NormedAlgebra ğ•œ' ğ•œ\ninstâœâ¸ : NormedSpace ğ•œ' E\ninstâœâ· : IsScalarTower ğ•œ' ğ•œ E\ninstâœâ¶ : NormedSpace ğ•œ' Fâ‚—\ninstâœâµ : IsScalarTower ğ•œ' ğ•œ Fâ‚—\nğ•œ'' : Type u_10\ninstâœâ´ : Ring ğ•œ''\ninstâœÂ³ : Module ğ•œ'' Fâ‚—\ninstâœÂ² : ContinuousConstSMul ğ•œ'' Fâ‚—\ninstâœÂ¹ : SMulCommClass ğ•œ ğ•œ'' Fâ‚—\ninstâœ : SMulCommClass ğ•œ' ğ•œ'' Fâ‚—\nâŠ¢ Eq (ContinuousLinearMap.restrictScalarsIsometry ğ•œ E Fâ‚— ğ•œ' ğ•œ'').toLinearMap (ContinuousLinearMap.restrictScalarsâ‚— ğ•œ E Fâ‚— ğ•œ' ğ•œ'')","decl":"@[simp]\ntheorem restrictScalarsIsometry_toLinearMap :\n    (restrictScalarsIsometry ğ•œ E Fâ‚— ğ•œ' ğ•œ'').toLinearMap = restrictScalarsâ‚— ğ•œ E Fâ‚— ğ•œ' ğ•œ'' :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.norm_pi_le_of_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedSpace ğ•œ E\nÎ¹ : Type u_9\ninstâœÂ² : Fintype Î¹\nM : Î¹ â†’ Type u_10\ninstâœÂ¹ : (i : Î¹) â†’ SeminormedAddCommGroup (M i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (M i)\nC : Real\nL : (i : Î¹) â†’ ContinuousLinearMap (RingHom.id ğ•œ) E (M i)\nhL : âˆ€ (i : Î¹), LE.le (Norm.norm (L i)) C\nhC : LE.le 0 C\nâŠ¢ LE.le (Norm.norm (ContinuousLinearMap.pi L)) C","decl":"lemma norm_pi_le_of_le {Î¹ : Type*} [Fintype Î¹]\n    {M : Î¹ â†’ Type*} [âˆ€ i, SeminormedAddCommGroup (M i)] [âˆ€ i, NormedSpace ğ•œ (M i)] {C : â„}\n    {L : (i : Î¹) â†’ (E â†’L[ğ•œ] M i)} (hL : âˆ€ i, â€–L iâ€– â‰¤ C) (hC : 0 â‰¤ C) :\n    â€–pi Lâ€– â‰¤ C := by\n  refine opNorm_le_bound _ hC (fun x â†¦ ?_)\n  refine (pi_norm_le_iff_of_nonneg (by positivity)).mpr (fun i â†¦ ?_)\n  exact (L i).le_of_opNorm_le (hL i) _\n\n"}
{"name":"LinearMap.mkContinuous_norm_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : SeminormedAddCommGroup F\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ E F\nC : Real\nhC : LE.le 0 C\nh : âˆ€ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\nâŠ¢ LE.le (Norm.norm (f.mkContinuous C h)) C","decl":"/-- If a continuous linear map is constructed from a linear map via the constructor `mkContinuous`,\nthen its norm is bounded by the bound given to the constructor if it is nonnegative. -/\ntheorem mkContinuous_norm_le (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) {C : â„} (hC : 0 â‰¤ C) (h : âˆ€ x, â€–f xâ€– â‰¤ C * â€–xâ€–) :\n    â€–f.mkContinuous C hâ€– â‰¤ C :=\n  ContinuousLinearMap.opNorm_le_bound _ hC h\n\n"}
{"name":"LinearMap.mkContinuous_norm_le'","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : SeminormedAddCommGroup F\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ E F\nC : Real\nh : âˆ€ (x : E), LE.le (Norm.norm (f x)) (HMul.hMul C (Norm.norm x))\nâŠ¢ LE.le (Norm.norm (f.mkContinuous C h)) (Max.max C 0)","decl":"/-- If a continuous linear map is constructed from a linear map via the constructor `mkContinuous`,\nthen its norm is bounded by the bound or zero if bound is negative. -/\ntheorem mkContinuous_norm_le' (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] F) {C : â„} (h : âˆ€ x, â€–f xâ€– â‰¤ C * â€–xâ€–) :\n    â€–f.mkContinuous C hâ€– â‰¤ max C 0 :=\n  ContinuousLinearMap.opNorm_le_bound _ (le_max_right _ _) fun x =>\n    (h x).trans <| mul_le_mul_of_nonneg_right (le_max_left _ _) (norm_nonneg x)\n\n"}
{"name":"LinearIsometry.norm_toContinuousLinearMap_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nğ•œâ‚‚ : Type u_2\nE : Type u_4\nF : Type u_5\ninstâœâµ : SeminormedAddCommGroup E\ninstâœâ´ : SeminormedAddCommGroup F\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NontriviallyNormedField ğ•œâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : NormedSpace ğ•œâ‚‚ F\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\nf : LinearIsometry Ïƒâ‚â‚‚ E F\nâŠ¢ LE.le (Norm.norm f.toContinuousLinearMap) 1","decl":"theorem norm_toContinuousLinearMap_le (f : E â†’â‚›â‚—áµ¢[Ïƒâ‚â‚‚] F) : â€–f.toContinuousLinearMapâ€– â‰¤ 1 :=\n  f.toContinuousLinearMap.opNorm_le_bound zero_le_one fun x => by simp\n\n"}
{"name":"Submodule.norm_subtypeL_le","module":"Mathlib.Analysis.NormedSpace.OperatorNorm.Basic","initialProofState":"ğ•œ : Type u_1\nE : Type u_4\ninstâœÂ² : SeminormedAddCommGroup E\ninstâœÂ¹ : NontriviallyNormedField ğ•œ\ninstâœ : NormedSpace ğ•œ E\nK : Submodule ğ•œ E\nâŠ¢ LE.le (Norm.norm K.subtypeL) 1","decl":"theorem norm_subtypeL_le (K : Submodule ğ•œ E) : â€–K.subtypeLâ€– â‰¤ 1 :=\n  K.subtypeâ‚—áµ¢.norm_toContinuousLinearMap_le\n\n"}
