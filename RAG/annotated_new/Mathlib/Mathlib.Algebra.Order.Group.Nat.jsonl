{"name":"Nat.instCanonicallyOrderedAdd","module":"Mathlib.Algebra.Order.Group.Nat","initialProofState":"⊢ CanonicallyOrderedAdd Nat","decl":"instance instCanonicallyOrderedAdd : CanonicallyOrderedAdd ℕ where\n  le_self_add := Nat.le_add_right\n  exists_add_of_le := Nat.exists_eq_add_of_le\n\n"}
{"name":"Nat.instOrderedSub","module":"Mathlib.Algebra.Order.Group.Nat","initialProofState":"⊢ OrderedSub Nat","decl":"instance instOrderedSub : OrderedSub ℕ := by\n  refine ⟨fun m n k ↦ ?_⟩\n  induction n generalizing k with\n  | zero => simp\n  | succ n ih => simp only [sub_succ, pred_le_iff, ih, succ_add, add_succ]\n\n"}
{"name":"Nat.pow_left_strictMono","module":"Mathlib.Algebra.Order.Group.Nat","initialProofState":"n : Nat\nhn : Ne n 0\n⊢ StrictMono fun x => HPow.hPow x n","decl":"/-- See also `pow_left_strictMonoOn₀`. -/\nprotected lemma pow_left_strictMono (hn : n ≠ 0) : StrictMono (· ^ n : ℕ → ℕ) :=\n  fun _ _ h ↦ Nat.pow_lt_pow_left h hn\n\n"}
{"name":"StrictMono.nat_pow","module":"Mathlib.Algebra.Order.Group.Nat","initialProofState":"α : Type u_1\nn : Nat\nf : α → Nat\ninst✝ : Preorder α\nhn : Ne n 0\nhf : StrictMono f\n⊢ StrictMono fun x => HPow.hPow (f x) n","decl":"lemma _root_.StrictMono.nat_pow [Preorder α] (hn : n ≠ 0) (hf : StrictMono f) :\n    StrictMono (f · ^ n) := (Nat.pow_left_strictMono hn).comp hf\n\n"}
