{"name":"FirstOrder.Language.orderRel.le.sizeOf_spec","module":"Mathlib.ModelTheory.Order","initialProofState":"⊢ Eq (SizeOf.sizeOf FirstOrder.Language.orderRel.le) 1","decl":"/-- The type of relations for the language of orders, consisting of a single binary relation `le`.\n-/\ninductive orderRel : ℕ → Type\n  | le : orderRel 2\n  deriving DecidableEq\n\n"}
{"name":"FirstOrder.Language.order.forall_relations","module":"Mathlib.ModelTheory.Order","initialProofState":"P : (n : Nat) → FirstOrder.Language.order.Relations n → Prop\n⊢ Iff (∀ {n : Nat} (R : FirstOrder.Language.order.Relations n), P n R) (P 2 FirstOrder.Language.orderRel.le)","decl":"@[simp]\nlemma forall_relations {P : ∀ (n) (_ : Language.order.Relations n), Prop} :\n    (∀ {n} (R), P n R) ↔ P 2 .le := ⟨fun h => h _, fun h n R =>\n      match n, R with\n      | 2, .le => h⟩\n\n"}
{"name":"FirstOrder.Language.order.instSubsingleton","module":"Mathlib.ModelTheory.Order","initialProofState":"n : Nat\n⊢ Subsingleton (FirstOrder.Language.order.Relations n)","decl":"instance instSubsingleton : Subsingleton (Language.order.Relations n) :=\n  ⟨by rintro ⟨⟩ ⟨⟩; rfl⟩\n\n"}
{"name":"FirstOrder.Language.order.instIsEmptyRelationsOfNatNat","module":"Mathlib.ModelTheory.Order","initialProofState":"⊢ IsEmpty (FirstOrder.Language.order.Relations 0)","decl":"instance : IsEmpty (Language.order.Relations 0) := ⟨fun x => by cases x⟩\n\n"}
{"name":"FirstOrder.Language.order.card_eq_one","module":"Mathlib.ModelTheory.Order","initialProofState":"⊢ Eq FirstOrder.Language.order.card 1","decl":"@[simp]\nlemma card_eq_one : Language.order.card = 1 := by simp [card]\n\n"}
{"name":"FirstOrder.Language.order.relation_eq_leSymb","module":"Mathlib.ModelTheory.Order","initialProofState":"R : FirstOrder.Language.order.Relations 2\n⊢ Eq R FirstOrder.Language.IsOrdered.leSymb","decl":"lemma order.relation_eq_leSymb : (R : Language.order.Relations 2) → R = leSymb\n  | .le => rfl\n\n"}
{"name":"FirstOrder.Language.orderLHom_onRelation","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\ninst✝ : L.IsOrdered\nx✝¹ : Nat\nx✝ : FirstOrder.Language.order.Relations x✝¹\n⊢ Eq (L.orderLHom.onRelation x✝) (FirstOrder.Language.orderLHom.match_1 (fun x x_1 => L.Relations x) x✝¹ x✝ fun _ => FirstOrder.Language.IsOrdered.leSymb)","decl":"/-- The language homomorphism sending the unique symbol `≤` of `Language.order` to `≤` in an ordered\n language. -/\n@[simps] def orderLHom : Language.order →ᴸ L where\n  onRelation | _, .le => leSymb\n\n"}
{"name":"FirstOrder.Language.orderLHom_onFunction","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\ninst✝ : L.IsOrdered\nn : Nat\na : FirstOrder.Language.order.Functions n\n⊢ Eq (L.orderLHom.onFunction a) (isEmptyElim a)","decl":"/-- The language homomorphism sending the unique symbol `≤` of `Language.order` to `≤` in an ordered\n language. -/\n@[simps] def orderLHom : Language.order →ᴸ L where\n  onRelation | _, .le => leSymb\n\n"}
{"name":"FirstOrder.Language.orderLHom_leSymb","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\ninst✝ : L.IsOrdered\n⊢ Eq (L.orderLHom.onRelation FirstOrder.Language.IsOrdered.leSymb) FirstOrder.Language.IsOrdered.leSymb","decl":"@[simp]\ntheorem orderLHom_leSymb :\n    (orderLHom L).onRelation leSymb = (leSymb : L.Relations 2) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.orderLHom_order","module":"Mathlib.ModelTheory.Order","initialProofState":"⊢ Eq FirstOrder.Language.order.orderLHom (FirstOrder.Language.LHom.id FirstOrder.Language.order)","decl":"@[simp]\ntheorem orderLHom_order : orderLHom Language.order = LHom.id Language.order :=\n  LHom.funext (Subsingleton.elim _ _) (Subsingleton.elim _ _)\n\n"}
{"name":"FirstOrder.Language.instIsUniversalPreorderTheory","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\ninst✝ : L.IsOrdered\n⊢ L.preorderTheory.IsUniversal","decl":"instance : Theory.IsUniversal L.preorderTheory := ⟨by\n  simp only [preorderTheory, Set.mem_insert_iff, Set.mem_singleton_iff, forall_eq_or_imp, forall_eq]\n  exact ⟨leSymb.isUniversal_reflexive, leSymb.isUniversal_transitive⟩⟩\n\n"}
{"name":"FirstOrder.Language.instIsUniversalPartialOrderTheory","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\ninst✝ : L.IsOrdered\n⊢ L.partialOrderTheory.IsUniversal","decl":"instance : Theory.IsUniversal L.partialOrderTheory :=\n  Theory.IsUniversal.insert leSymb.isUniversal_antisymmetric\n\n"}
{"name":"FirstOrder.Language.instIsUniversalLinearOrderTheory","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\ninst✝ : L.IsOrdered\n⊢ L.linearOrderTheory.IsUniversal","decl":"instance : Theory.IsUniversal L.linearOrderTheory :=\n  Theory.IsUniversal.insert leSymb.isUniversal_total\n\n"}
{"name":"FirstOrder.Language.instModelLinearOrderTheoryOfDlo","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝¹ : L.IsOrdered\ninst✝ : L.Structure M\nh : FirstOrder.Language.Theory.Model M L.dlo\n⊢ FirstOrder.Language.Theory.Model M L.linearOrderTheory","decl":"instance [h : M ⊨ L.dlo] : M ⊨ L.linearOrderTheory := h.mono Set.subset_union_left\n\n"}
{"name":"FirstOrder.Language.instModelPartialOrderTheoryOfLinearOrderTheory","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝¹ : L.IsOrdered\ninst✝ : L.Structure M\nh : FirstOrder.Language.Theory.Model M L.linearOrderTheory\n⊢ FirstOrder.Language.Theory.Model M L.partialOrderTheory","decl":"instance [h : M ⊨ L.linearOrderTheory] : M ⊨ L.partialOrderTheory := h.mono (Set.subset_insert _ _)\n\n"}
{"name":"FirstOrder.Language.instModelPreorderTheoryOfPartialOrderTheory","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝¹ : L.IsOrdered\ninst✝ : L.Structure M\nh : FirstOrder.Language.Theory.Model M L.partialOrderTheory\n⊢ FirstOrder.Language.Theory.Model M L.preorderTheory","decl":"instance [h : M ⊨ L.partialOrderTheory] : M ⊨ L.preorderTheory := h.mono (Set.subset_insert _ _)\n\n"}
{"name":"FirstOrder.Language.OrderedStructure.relMap_leSymb","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝² : L.IsOrdered\ninst✝¹ : LE M\ninst✝ : L.Structure M\nself : L.OrderedStructure M\nx : Fin 2 → M\n⊢ Iff (FirstOrder.Language.Structure.RelMap FirstOrder.Language.IsOrdered.leSymb x) (LE.le (x 0) (x 1))","decl":"/-- A structure is ordered if its language has a `≤` symbol whose interpretation is `≤`. -/\nclass OrderedStructure [L.IsOrdered] [LE M] [L.Structure M] : Prop where\n  relMap_leSymb : ∀ (x : Fin 2 → M), RelMap (leSymb : L.Relations 2) x ↔ (x 0 ≤ x 1)\n\n"}
{"name":"FirstOrder.Language.instOrderedStructureOfOrderOfIsExpansionOnOrderLHom","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝⁵ : L.IsOrdered\ninst✝⁴ : L.Structure M\ninst✝³ : LE M\ninst✝² : FirstOrder.Language.order.Structure M\ninst✝¹ : FirstOrder.Language.order.OrderedStructure M\ninst✝ : L.orderLHom.IsExpansionOn M\n⊢ L.OrderedStructure M","decl":"instance [Language.order.Structure M] [Language.order.OrderedStructure M]\n    [(orderLHom L).IsExpansionOn M] : L.OrderedStructure M where\n  relMap_leSymb x := by\n    rw [← orderLHom_leSymb L, LHom.IsExpansionOn.map_onRelation, relMap_leSymb]\n\n"}
{"name":"FirstOrder.Language.instIsExpansionOnOrderLHomOfOrderedStructureOrder","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝⁴ : L.IsOrdered\ninst✝³ : L.Structure M\ninst✝² : LE M\ninst✝¹ : FirstOrder.Language.order.Structure M\ninst✝ : FirstOrder.Language.order.OrderedStructure M\n⊢ L.orderLHom.IsExpansionOn M","decl":"instance [Language.order.Structure M] [Language.order.OrderedStructure M] :\n    LHom.IsExpansionOn (orderLHom L) M where\n  map_onRelation := by simp [order.relation_eq_leSymb]\n\n"}
{"name":"FirstOrder.Language.instOrderedStructureSubtypeMemSubstructure","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝³ : L.IsOrdered\ninst✝² : L.Structure M\ninst✝¹ : LE M\ninst✝ : L.OrderedStructure M\nS : L.Substructure M\n⊢ L.OrderedStructure (Subtype fun x => Membership.mem S x)","decl":"instance (S : L.Substructure M) : L.OrderedStructure S := ⟨fun x => relMap_leSymb (S.subtype ∘ x)⟩\n\n"}
{"name":"FirstOrder.Language.Term.realize_le","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nα : Type w\nM : Type w'\nn : Nat\ninst✝³ : L.IsOrdered\ninst✝² : L.Structure M\ninst✝¹ : LE M\ninst✝ : L.OrderedStructure M\nt₁ t₂ : L.Term (Sum α (Fin n))\nv : α → M\nxs : Fin n → M\n⊢ Iff ((t₁.le t₂).Realize v xs) (LE.le (FirstOrder.Language.Term.realize (Sum.elim v xs) t₁) (FirstOrder.Language.Term.realize (Sum.elim v xs) t₂))","decl":"@[simp]\ntheorem Term.realize_le {t₁ t₂ : L.Term (α ⊕ (Fin n))} {v : α → M}\n    {xs : Fin n → M} :\n    (t₁.le t₂).Realize v xs ↔ t₁.realize (Sum.elim v xs) ≤ t₂.realize (Sum.elim v xs) := by\n  simp [Term.le]\n\n"}
{"name":"FirstOrder.Language.realize_noTopOrder_iff","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝³ : L.IsOrdered\ninst✝² : L.Structure M\ninst✝¹ : LE M\ninst✝ : L.OrderedStructure M\n⊢ Iff (FirstOrder.Language.Sentence.Realize M L.noTopOrderSentence) (NoTopOrder M)","decl":"theorem realize_noTopOrder_iff : M ⊨ L.noTopOrderSentence ↔ NoTopOrder M := by\n  simp only [noTopOrderSentence, Sentence.Realize, Formula.Realize, BoundedFormula.realize_all,\n    BoundedFormula.realize_ex, BoundedFormula.realize_not, Term.realize, Term.realize_le,\n    Sum.elim_inr]\n  refine ⟨fun h => ⟨fun a => h a⟩, ?_⟩\n  intro h a\n  exact exists_not_le a\n\n"}
{"name":"FirstOrder.Language.realize_noBotOrder_iff","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝³ : L.IsOrdered\ninst✝² : L.Structure M\ninst✝¹ : LE M\ninst✝ : L.OrderedStructure M\n⊢ Iff (FirstOrder.Language.Sentence.Realize M L.noBotOrderSentence) (NoBotOrder M)","decl":"theorem realize_noBotOrder_iff : M ⊨ L.noBotOrderSentence ↔ NoBotOrder M := by\n  simp only [noBotOrderSentence, Sentence.Realize, Formula.Realize, BoundedFormula.realize_all,\n    BoundedFormula.realize_ex, BoundedFormula.realize_not, Term.realize, Term.realize_le,\n    Sum.elim_inr]\n  refine ⟨fun h => ⟨fun a => h a⟩, ?_⟩\n  intro h a\n  exact exists_not_ge a\n\n"}
{"name":"FirstOrder.Language.realize_noTopOrder","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝³ : L.IsOrdered\ninst✝² : L.Structure M\ninst✝¹ : LE M\ninst✝ : L.OrderedStructure M\nh : NoTopOrder M\n⊢ FirstOrder.Language.Sentence.Realize M L.noTopOrderSentence","decl":"@[simp]\ntheorem realize_noTopOrder [h : NoTopOrder M] : M ⊨ L.noTopOrderSentence :=\n  realize_noTopOrder_iff.2 h\n\n"}
{"name":"FirstOrder.Language.realize_noBotOrder","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝³ : L.IsOrdered\ninst✝² : L.Structure M\ninst✝¹ : LE M\ninst✝ : L.OrderedStructure M\nh : NoBotOrder M\n⊢ FirstOrder.Language.Sentence.Realize M L.noBotOrderSentence","decl":"@[simp]\ntheorem realize_noBotOrder [h : NoBotOrder M] : M ⊨ L.noBotOrderSentence :=\n  realize_noBotOrder_iff.2 h\n\n"}
{"name":"FirstOrder.Language.noTopOrder_of_dlo","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝⁴ : L.IsOrdered\ninst✝³ : L.Structure M\ninst✝² : LE M\ninst✝¹ : L.OrderedStructure M\ninst✝ : FirstOrder.Language.Theory.Model M L.dlo\n⊢ NoTopOrder M","decl":"theorem noTopOrder_of_dlo [M ⊨ L.dlo] : NoTopOrder M :=\n  realize_noTopOrder_iff.1 (L.dlo.realize_sentence_of_mem (by\n    simp only [dlo, Set.union_insert, Set.union_singleton, Set.mem_insert_iff, true_or]))\n\n"}
{"name":"FirstOrder.Language.noBotOrder_of_dlo","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝⁴ : L.IsOrdered\ninst✝³ : L.Structure M\ninst✝² : LE M\ninst✝¹ : L.OrderedStructure M\ninst✝ : FirstOrder.Language.Theory.Model M L.dlo\n⊢ NoBotOrder M","decl":"theorem noBotOrder_of_dlo [M ⊨ L.dlo] : NoBotOrder M :=\n  realize_noBotOrder_iff.1 (L.dlo.realize_sentence_of_mem (by\n    simp only [dlo, Set.union_insert, Set.union_singleton, Set.mem_insert_iff, true_or, or_true]))\n\n"}
{"name":"FirstOrder.Language.orderedStructure_iff","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝⁴ : L.IsOrdered\ninst✝³ : L.Structure M\ninst✝² : LE M\ninst✝¹ : FirstOrder.Language.order.Structure M\ninst✝ : FirstOrder.Language.order.OrderedStructure M\n⊢ Iff (L.OrderedStructure M) (L.orderLHom.IsExpansionOn M)","decl":"@[simp]\ntheorem orderedStructure_iff\n    [LE M] [Language.order.Structure M] [Language.order.OrderedStructure M] :\n    L.OrderedStructure M ↔ LHom.IsExpansionOn (orderLHom L) M :=\n  ⟨fun _ => inferInstance, fun _ => inferInstance⟩\n\n"}
{"name":"FirstOrder.Language.model_preorder","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝¹ : L.IsOrdered\ninst✝ : L.Structure M\n⊢ FirstOrder.Language.Theory.Model M L.preorderTheory","decl":"instance model_preorder : M ⊨ L.preorderTheory := by\n  simp only [preorderTheory, Theory.model_insert_iff, Relations.realize_reflexive, relMap_leSymb,\n    Theory.model_singleton_iff, Relations.realize_transitive]\n  exact ⟨le_refl, fun _ _ _ => le_trans⟩\n\n"}
{"name":"FirstOrder.Language.Term.realize_lt","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nα : Type w\nM : Type w'\nn : Nat\ninst✝³ : L.IsOrdered\ninst✝² : L.Structure M\ninst✝¹ : Preorder M\ninst✝ : L.OrderedStructure M\nt₁ t₂ : L.Term (Sum α (Fin n))\nv : α → M\nxs : Fin n → M\n⊢ Iff ((t₁.lt t₂).Realize v xs) (LT.lt (FirstOrder.Language.Term.realize (Sum.elim v xs) t₁) (FirstOrder.Language.Term.realize (Sum.elim v xs) t₂))","decl":"@[simp]\ntheorem Term.realize_lt {t₁ t₂ : L.Term (α ⊕ (Fin n))}\n    {v : α → M} {xs : Fin n → M} :\n    (t₁.lt t₂).Realize v xs ↔ t₁.realize (Sum.elim v xs) < t₂.realize (Sum.elim v xs) := by\n  simp [Term.lt, lt_iff_le_not_le]\n\n"}
{"name":"FirstOrder.Language.realize_denselyOrdered_iff","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝³ : L.IsOrdered\ninst✝² : L.Structure M\ninst✝¹ : Preorder M\ninst✝ : L.OrderedStructure M\n⊢ Iff (FirstOrder.Language.Sentence.Realize M L.denselyOrderedSentence) (DenselyOrdered M)","decl":"theorem realize_denselyOrdered_iff :\n    M ⊨ L.denselyOrderedSentence ↔ DenselyOrdered M := by\n  simp only [denselyOrderedSentence, Sentence.Realize, Formula.Realize,\n    BoundedFormula.realize_imp, BoundedFormula.realize_all, Term.realize, Term.realize_lt,\n    Sum.elim_inr, BoundedFormula.realize_ex, BoundedFormula.realize_inf]\n  refine ⟨fun h => ⟨fun a b ab => h a b ab⟩, ?_⟩\n  intro h a b ab\n  exact exists_between ab\n\n"}
{"name":"FirstOrder.Language.realize_denselyOrdered","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝³ : L.IsOrdered\ninst✝² : L.Structure M\ninst✝¹ : Preorder M\ninst✝ : L.OrderedStructure M\nh : DenselyOrdered M\n⊢ FirstOrder.Language.Sentence.Realize M L.denselyOrderedSentence","decl":"@[simp]\ntheorem realize_denselyOrdered [h : DenselyOrdered M] :\n    M ⊨ L.denselyOrderedSentence :=\n  realize_denselyOrdered_iff.2 h\n\n"}
{"name":"FirstOrder.Language.denselyOrdered_of_dlo","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝⁴ : L.IsOrdered\ninst✝³ : L.Structure M\ninst✝² : Preorder M\ninst✝¹ : L.OrderedStructure M\ninst✝ : FirstOrder.Language.Theory.Model M L.dlo\n⊢ DenselyOrdered M","decl":"theorem denselyOrdered_of_dlo [M ⊨ L.dlo] : DenselyOrdered M :=\n  realize_denselyOrdered_iff.1 (L.dlo.realize_sentence_of_mem (by\n    simp only [dlo, Set.union_insert, Set.union_singleton, Set.mem_insert_iff, true_or, or_true]))\n\n"}
{"name":"FirstOrder.Language.model_partialOrder","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝³ : L.IsOrdered\ninst✝² : L.Structure M\ninst✝¹ : PartialOrder M\ninst✝ : L.OrderedStructure M\n⊢ FirstOrder.Language.Theory.Model M L.partialOrderTheory","decl":"instance model_partialOrder [PartialOrder M] [L.OrderedStructure M] :\n    M ⊨ L.partialOrderTheory := by\n  simp only [partialOrderTheory, Theory.model_insert_iff, Relations.realize_antisymmetric,\n    relMap_leSymb, Fin.isValue, Matrix.cons_val_zero, Matrix.cons_val_one, Matrix.head_cons,\n    model_preorder, and_true]\n  exact fun _ _ => le_antisymm\n\n"}
{"name":"FirstOrder.Language.model_linearOrder","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝¹ : L.IsOrdered\ninst✝ : L.Structure M\n⊢ FirstOrder.Language.Theory.Model M L.linearOrderTheory","decl":"instance model_linearOrder : M ⊨ L.linearOrderTheory := by\n  simp only [linearOrderTheory, Theory.model_insert_iff, Relations.realize_total, relMap_leSymb,\n    Fin.isValue, Matrix.cons_val_zero, Matrix.cons_val_one, Matrix.head_cons, model_partialOrder,\n    and_true]\n  exact le_total\n\n"}
{"name":"FirstOrder.Language.model_dlo","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝⁵ : L.IsOrdered\ninst✝⁴ : L.Structure M\ninst✝³ : LinearOrder M\ninst✝² : DenselyOrdered M\ninst✝¹ : NoTopOrder M\ninst✝ : NoBotOrder M\n⊢ FirstOrder.Language.Theory.Model M L.dlo","decl":"instance model_dlo [DenselyOrdered M] [NoTopOrder M] [NoBotOrder M] :\n    M ⊨ L.dlo := by\n  simp [dlo, model_linearOrder, Theory.model_insert_iff]\n\n"}
{"name":"FirstOrder.Language.instOrderedStructure","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝¹ : L.IsOrdered\ninst✝ : L.Structure M\n⊢ L.OrderedStructure M","decl":"instance : @OrderedStructure L M _ (L.leOfStructure M) _ := by\n  letI := L.leOfStructure M\n  constructor\n  simp only [Fin.forall_fin_succ_pi, Fin.cons_zero, Fin.forall_fin_zero_pi]\n  intros\n  rfl\n\n"}
{"name":"FirstOrder.Language.order.instHomClassOfOrderHomClass","module":"Mathlib.ModelTheory.Order","initialProofState":"M : Type w'\ninst✝⁵ : FirstOrder.Language.order.Structure M\ninst✝⁴ : LE M\nN : Type u_1\ninst✝³ : FirstOrder.Language.order.Structure N\ninst✝² : LE N\nF : Type u_2\ninst✝¹ : FunLike F M N\ninst✝ : OrderHomClass F M N\n⊢ FirstOrder.Language.order.HomClass F M N","decl":"instance [FunLike F M N] [OrderHomClass F M N] : Language.order.HomClass F M N :=\n  ⟨fun _ => isEmptyElim, by\n    simp only [forall_relations, relation_eq_leSymb, relMap_leSymb, Fin.isValue,\n      Function.comp_apply]\n    exact fun φ x => map_rel φ⟩\n\n-- If `OrderEmbeddingClass` or `RelEmbeddingClass` is defined, this should be generalized.\n"}
{"name":"FirstOrder.Language.order.instStrongHomClassOrderEmbedding","module":"Mathlib.ModelTheory.Order","initialProofState":"M : Type w'\ninst✝³ : FirstOrder.Language.order.Structure M\ninst✝² : LE M\nN : Type u_1\ninst✝¹ : FirstOrder.Language.order.Structure N\ninst✝ : LE N\n⊢ FirstOrder.Language.order.StrongHomClass (OrderEmbedding M N) M N","decl":"instance : Language.order.StrongHomClass (M ↪o N) M N :=\n  ⟨fun _ => isEmptyElim,\n    by simp only [order.forall_relations, order.relation_eq_leSymb, relMap_leSymb, Fin.isValue,\n    Function.comp_apply, RelEmbedding.map_rel_iff, implies_true]⟩\n\n"}
{"name":"FirstOrder.Language.order.instStrongHomClassOfOrderIsoClass","module":"Mathlib.ModelTheory.Order","initialProofState":"M : Type w'\ninst✝⁵ : FirstOrder.Language.order.Structure M\ninst✝⁴ : LE M\nN : Type u_1\ninst✝³ : FirstOrder.Language.order.Structure N\ninst✝² : LE N\nF : Type u_2\ninst✝¹ : EquivLike F M N\ninst✝ : OrderIsoClass F M N\n⊢ FirstOrder.Language.order.StrongHomClass F M N","decl":"instance [EquivLike F M N] [OrderIsoClass F M N] : Language.order.StrongHomClass F M N :=\n  ⟨fun _ => isEmptyElim,\n    by simp only [order.forall_relations, order.relation_eq_leSymb, relMap_leSymb, Fin.isValue,\n      Function.comp_apply, map_le_map_iff, implies_true]⟩\n\n"}
{"name":"FirstOrder.Language.HomClass.monotone","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝⁸ : L.IsOrdered\ninst✝⁷ : L.Structure M\nN : Type u_1\ninst✝⁶ : L.Structure N\nF : Type u_2\ninst✝⁵ : FunLike F M N\ninst✝⁴ : L.HomClass F M N\ninst✝³ : Preorder M\ninst✝² : L.OrderedStructure M\ninst✝¹ : Preorder N\ninst✝ : L.OrderedStructure N\nf : F\n⊢ Monotone ⇑f","decl":"lemma monotone [Preorder M] [L.OrderedStructure M] [Preorder N] [L.OrderedStructure N] (f : F) :\n    Monotone f := fun a b => by\n  have h := HomClass.map_rel f leSymb ![a,b]\n  simp only [relMap_leSymb, Fin.isValue, Matrix.cons_val_zero, Matrix.cons_val_one,\n    Matrix.head_cons, Function.comp_apply] at h\n  exact h\n\n"}
{"name":"FirstOrder.Language.HomClass.strictMono","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\nM : Type w'\ninst✝⁹ : L.IsOrdered\ninst✝⁸ : L.Structure M\nN : Type u_1\ninst✝⁷ : L.Structure N\nF : Type u_2\ninst✝⁶ : FunLike F M N\ninst✝⁵ : L.HomClass F M N\ninst✝⁴ : EmbeddingLike F M N\ninst✝³ : PartialOrder M\ninst✝² : L.OrderedStructure M\ninst✝¹ : PartialOrder N\ninst✝ : L.OrderedStructure N\nf : F\n⊢ StrictMono ⇑f","decl":"lemma strictMono [EmbeddingLike F M N] [PartialOrder M] [L.OrderedStructure M]\n    [PartialOrder N] [L.OrderedStructure N] (f : F) :\n    StrictMono f :=\n  (HomClass.monotone f).strictMono_of_injective (EmbeddingLike.injective f)\n\n"}
{"name":"FirstOrder.Language.StrongHomClass.toOrderIsoClass","module":"Mathlib.ModelTheory.Order","initialProofState":"L : FirstOrder.Language\ninst✝⁸ : L.IsOrdered\nM : Type u_1\ninst✝⁷ : L.Structure M\ninst✝⁶ : LE M\ninst✝⁵ : L.OrderedStructure M\nN : Type u_2\ninst✝⁴ : L.Structure N\ninst✝³ : LE N\ninst✝² : L.OrderedStructure N\nF : Type u_3\ninst✝¹ : EquivLike F M N\ninst✝ : L.StrongHomClass F M N\n⊢ OrderIsoClass F M N","decl":"/-- This is not an instance because it would form a loop with\n  `FirstOrder.Language.order.instStrongHomClassOfOrderIsoClass`.\n  As both types are `Prop`s, it would only cause a slowdown.  -/\nlemma StrongHomClass.toOrderIsoClass\n    (L : Language) [L.IsOrdered] (M : Type*) [L.Structure M] [LE M] [L.OrderedStructure M]\n    (N : Type*) [L.Structure N] [LE N] [L.OrderedStructure N]\n    (F : Type*) [EquivLike F M N] [L.StrongHomClass F M N] :\n    OrderIsoClass F M N where\n  map_le_map_iff f a b := by\n    have h := StrongHomClass.map_rel f leSymb ![a,b]\n    simp only [relMap_leSymb, Fin.isValue, Function.comp_apply, Matrix.cons_val_zero,\n      Matrix.cons_val_one, Matrix.head_cons] at h\n    exact h\n\n"}
{"name":"FirstOrder.Language.dlo_isExtensionPair","module":"Mathlib.ModelTheory.Order","initialProofState":"M : Type w\ninst✝⁴ : FirstOrder.Language.order.Structure M\ninst✝³ : FirstOrder.Language.Theory.Model M FirstOrder.Language.order.linearOrderTheory\nN : Type w'\ninst✝² : FirstOrder.Language.order.Structure N\ninst✝¹ : FirstOrder.Language.Theory.Model N FirstOrder.Language.order.dlo\ninst✝ : Nonempty N\n⊢ FirstOrder.Language.order.IsExtensionPair M N","decl":"lemma dlo_isExtensionPair\n    (M : Type w) [Language.order.Structure M] [M ⊨ Language.order.linearOrderTheory]\n    (N : Type w') [Language.order.Structure N] [N ⊨ Language.order.dlo] [Nonempty N] :\n    Language.order.IsExtensionPair M N := by\n  classical\n  rw [isExtensionPair_iff_exists_embedding_closure_singleton_sup]\n  intro S S_fg f m\n  letI := Language.order.linearOrderOfModels M\n  letI := Language.order.linearOrderOfModels N\n  have := Language.order.denselyOrdered_of_dlo N\n  have := Language.order.noBotOrder_of_dlo N\n  have := Language.order.noTopOrder_of_dlo N\n  have := NoBotOrder.to_noMinOrder N\n  have := NoTopOrder.to_noMaxOrder N\n  have hS : Set.Finite (S : Set M) := (S.fg_iff_structure_fg.1 S_fg).finite\n  obtain ⟨g, hg⟩ := Order.exists_orderEmbedding_insert hS.toFinset\n    ((OrderIso.setCongr hS.toFinset (S : Set M) hS.coe_toFinset).toOrderEmbedding.trans\n      (OrderEmbedding.ofStrictMono f (HomClass.strictMono f))) m\n  let g' :\n    ((Substructure.closure Language.order).toFun {m} ⊔ S : Language.order.Substructure M) ↪o N :=\n    ((OrderIso.setCongr _ _ (by\n      convert LowerAdjoint.closure_eq_self_of_mem_closed _\n        (Substructure.mem_closed_of_isRelational Language.order\n        ((insert m hS.toFinset : Finset M) : Set M))\n      simp only [Finset.coe_insert, Set.Finite.coe_toFinset, Substructure.closure_insert,\n        Substructure.closure_eq])).toOrderEmbedding.trans g)\n  use StrongHomClass.toEmbedding g'\n  ext ⟨x, xS⟩\n  refine congr_fun hg.symm ⟨x, (?_ : x ∈ hS.toFinset)⟩\n  simp only [Set.Finite.mem_toFinset, SetLike.mem_coe, xS]\n\n"}
{"name":"FirstOrder.Language.instInfiniteOfModelDloOrderOfNonempty","module":"Mathlib.ModelTheory.Order","initialProofState":"M : Type w\ninst✝² : FirstOrder.Language.order.Structure M\ninst✝¹ : FirstOrder.Language.Theory.Model M FirstOrder.Language.order.dlo\ninst✝ : Nonempty M\n⊢ Infinite M","decl":"instance (M : Type w) [Language.order.Structure M] [M ⊨ Language.order.dlo] [Nonempty M] :\n    Infinite M := by\n  letI := orderStructure ℚ\n  obtain ⟨f, _⟩ := embedding_from_cg cg_of_countable default (dlo_isExtensionPair ℚ M)\n  exact Infinite.of_injective f f.injective\n\n"}
{"name":"FirstOrder.Language.dlo_age","module":"Mathlib.ModelTheory.Order","initialProofState":"M : Type w'\ninst✝¹ : FirstOrder.Language.order.Structure M\nMdlo : FirstOrder.Language.Theory.Model M FirstOrder.Language.order.dlo\ninst✝ : Nonempty M\n⊢ Eq (FirstOrder.Language.order.age M) (setOf fun M => And (Finite ↑M) (FirstOrder.Language.Theory.Model (↑M) FirstOrder.Language.order.linearOrderTheory))","decl":"lemma dlo_age [Language.order.Structure M] [Mdlo : M ⊨ Language.order.dlo] [Nonempty M] :\n    Language.order.age M = {M : CategoryTheory.Bundled.{w'} Language.order.Structure |\n      Finite M ∧ M ⊨ Language.order.linearOrderTheory} := by\n  classical\n  rw [age]\n  ext N\n  refine ⟨fun ⟨hF, h⟩ => ⟨hF.finite, Theory.IsUniversal.models_of_embedding h.some⟩,\n    fun ⟨hF, h⟩ => ⟨FG.of_finite, ?_⟩⟩\n  letI := Language.order.linearOrderOfModels M\n  letI := Language.order.linearOrderOfModels N\n  exact ⟨StrongHomClass.toEmbedding (nonempty_orderEmbedding_of_finite_infinite N M).some⟩\n\n"}
{"name":"FirstOrder.Language.isFraisseLimit_of_countable_nonempty_dlo","module":"Mathlib.ModelTheory.Order","initialProofState":"M : Type w\ninst✝³ : FirstOrder.Language.order.Structure M\ninst✝² : Countable M\ninst✝¹ : Nonempty M\ninst✝ : FirstOrder.Language.Theory.Model M FirstOrder.Language.order.dlo\n⊢ FirstOrder.Language.IsFraisseLimit (setOf fun M => And (Finite ↑M) (FirstOrder.Language.Theory.Model (↑M) FirstOrder.Language.order.linearOrderTheory)) M","decl":"/-- Any countable nonempty model of the theory of dense linear orders is a Fraïssé limit of the\nclass of finite models of the theory of linear orders. -/\ntheorem isFraisseLimit_of_countable_nonempty_dlo (M : Type w)\n    [Language.order.Structure M] [Countable M] [Nonempty M] [M ⊨ Language.order.dlo] :\n    IsFraisseLimit {M : CategoryTheory.Bundled.{w} Language.order.Structure |\n      Finite M ∧ M ⊨ Language.order.linearOrderTheory} M :=\n  ⟨(isUltrahomogeneous_iff_IsExtensionPair cg_of_countable).2 (dlo_isExtensionPair M M), dlo_age M⟩\n\n"}
{"name":"FirstOrder.Language.isFraisse_finite_linear_order","module":"Mathlib.ModelTheory.Order","initialProofState":"⊢ FirstOrder.Language.IsFraisse (setOf fun M => And (Finite ↑M) (FirstOrder.Language.Theory.Model (↑M) FirstOrder.Language.order.linearOrderTheory))","decl":"/-- The class of finite models of the theory of linear orders is Fraïssé. -/\ntheorem isFraisse_finite_linear_order :\n    IsFraisse {M : CategoryTheory.Bundled.{0} Language.order.Structure |\n      Finite M ∧ M ⊨ Language.order.linearOrderTheory} := by\n  letI : Language.order.Structure ℚ := orderStructure _\n  exact (isFraisseLimit_of_countable_nonempty_dlo ℚ).isFraisse\n\n"}
{"name":"FirstOrder.Language.aleph0_categorical_dlo","module":"Mathlib.ModelTheory.Order","initialProofState":"⊢ Cardinal.aleph0.Categorical FirstOrder.Language.order.dlo","decl":"/-- The theory of dense linear orders is `ℵ₀`-categorical. -/\ntheorem aleph0_categorical_dlo : (ℵ₀).Categorical Language.order.dlo := fun M₁ M₂ h₁ h₂ => by\n  obtain ⟨_⟩ := denumerable_iff.2 h₁\n  obtain ⟨_⟩ := denumerable_iff.2 h₂\n  exact (isFraisseLimit_of_countable_nonempty_dlo M₁).nonempty_equiv\n    (isFraisseLimit_of_countable_nonempty_dlo M₂)\n\n"}
{"name":"FirstOrder.Language.dlo_isComplete","module":"Mathlib.ModelTheory.Order","initialProofState":"⊢ FirstOrder.Language.order.dlo.IsComplete","decl":"/-- The theory of dense linear orders is `ℵ₀`-complete. -/\ntheorem dlo_isComplete : Language.order.dlo.IsComplete :=\n  aleph0_categorical_dlo.{0}.isComplete ℵ₀ _ le_rfl (by simp [one_le_aleph0])\n    ⟨by\n      letI : Language.order.Structure ℚ := orderStructure ℚ\n      exact Theory.ModelType.of _ ℚ⟩\n    fun _ => inferInstance\n\n"}
