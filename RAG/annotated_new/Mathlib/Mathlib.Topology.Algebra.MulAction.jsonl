{"name":"ContinuousSMul.continuous_smul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù¬≤ : SMul M X\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : TopologicalSpace X\nself : ContinuousSMul M X\n‚ä¢ Continuous fun p => HSMul.hSMul p.1 p.2","decl":"/-- Class `ContinuousSMul M X` says that the scalar multiplication `(‚Ä¢) : M ‚Üí X ‚Üí X`\nis continuous in both arguments. We use the same class for all kinds of multiplicative actions,\nincluding (semi)modules and algebras. -/\nclass ContinuousSMul (M X : Type*) [SMul M X] [TopologicalSpace M] [TopologicalSpace X] :\n    Prop where\n  /-- The scalar multiplication `(‚Ä¢)` is continuous. -/\n  continuous_smul : Continuous fun p : M √ó X => p.1 ‚Ä¢ p.2\n\n"}
{"name":"ContinuousVAdd.continuous_vadd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù¬≤ : VAdd M X\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : TopologicalSpace X\nself : ContinuousVAdd M X\n‚ä¢ Continuous fun p => HVAdd.hVAdd p.1 p.2","decl":"/-- Class `ContinuousVAdd M X` says that the additive action `(+·µ•) : M ‚Üí X ‚Üí X`\nis continuous in both arguments. We use the same class for all kinds of additive actions,\nincluding (semi)modules and algebras. -/\nclass ContinuousVAdd (M X : Type*) [VAdd M X] [TopologicalSpace M] [TopologicalSpace X] :\n    Prop where\n  /-- The additive action `(+·µ•)` is continuous. -/\n  continuous_vadd : Continuous fun p : M √ó X => p.1 +·µ• p.2\n\n"}
{"name":"IsScalarTower.continuousSMul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_5\nN : Type u_6\nŒ± : Type u_7\ninst‚úù‚Åπ : Monoid N\ninst‚úù‚Å∏ : SMul M N\ninst‚úù‚Å∑ : MulAction N Œ±\ninst‚úù‚Å∂ : SMul M Œ±\ninst‚úù‚Åµ : IsScalarTower M N Œ±\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : TopologicalSpace N\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : ContinuousSMul M N\ninst‚úù : ContinuousSMul N Œ±\n‚ä¢ ContinuousSMul M Œ±","decl":"lemma IsScalarTower.continuousSMul {M : Type*} (N : Type*) {Œ± : Type*} [Monoid N] [SMul M N]\n    [MulAction N Œ±] [SMul M Œ±] [IsScalarTower M N Œ±] [TopologicalSpace M] [TopologicalSpace N]\n    [TopologicalSpace Œ±] [ContinuousSMul M N] [ContinuousSMul N Œ±] : ContinuousSMul M Œ± :=\n  { continuous_smul := by\n      suffices Continuous (fun p : M √ó Œ± ‚Ü¶ (p.1 ‚Ä¢ (1 : N)) ‚Ä¢ p.2) by simpa\n      fun_prop }\n\n"}
{"name":"instContinuousSMulULift","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : SMul M X\ninst‚úù : ContinuousSMul M X\n‚ä¢ ContinuousSMul (ULift.{u_5, u_1} M) X","decl":"@[to_additive]\ninstance : ContinuousSMul (ULift M) X :=\n  ‚ü®(continuous_smul (M := M)).comp‚ÇÇ (continuous_uLift_down.comp continuous_fst) continuous_snd‚ü©\n\n"}
{"name":"instContinuousVAddULift","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : VAdd M X\ninst‚úù : ContinuousVAdd M X\n‚ä¢ ContinuousVAdd (ULift.{u_5, u_1} M) X","decl":"@[to_additive]\ninstance : ContinuousSMul (ULift M) X :=\n  ‚ü®(continuous_smul (M := M)).comp‚ÇÇ (continuous_uLift_down.comp continuous_fst) continuous_snd‚ü©\n\n"}
{"name":"ContinuousVAdd.continuousConstVAdd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : VAdd M X\ninst‚úù : ContinuousVAdd M X\n‚ä¢ ContinuousConstVAdd M X","decl":"@[to_additive]\ninstance (priority := 100) ContinuousSMul.continuousConstSMul : ContinuousConstSMul M X where\n  continuous_const_smul _ := continuous_smul.comp (continuous_const.prod_mk continuous_id)\n\n"}
{"name":"ContinuousSMul.continuousConstSMul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : SMul M X\ninst‚úù : ContinuousSMul M X\n‚ä¢ ContinuousConstSMul M X","decl":"@[to_additive]\ninstance (priority := 100) ContinuousSMul.continuousConstSMul : ContinuousConstSMul M X where\n  continuous_const_smul _ := continuous_smul.comp (continuous_const.prod_mk continuous_id)\n\n"}
{"name":"ContinuousSMul.induced","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"R : Type u_5\nŒ± : Type u_6\nŒ≤ : Type u_7\nF : Type u_8\ninst‚úù‚Å∏ : FunLike F Œ± Œ≤\ninst‚úù‚Å∑ : Semiring R\ninst‚úù‚Å∂ : AddCommMonoid Œ±\ninst‚úù‚Åµ : AddCommMonoid Œ≤\ninst‚úù‚Å¥ : Module R Œ±\ninst‚úù¬≥ : Module R Œ≤\ninst‚úù¬≤ : TopologicalSpace R\ninst‚úù¬π : LinearMapClass F R Œ± Œ≤\ntŒ≤ : TopologicalSpace Œ≤\ninst‚úù : ContinuousSMul R Œ≤\nf : F\n‚ä¢ ContinuousSMul R Œ±","decl":"theorem ContinuousSMul.induced {R : Type*} {Œ± : Type*} {Œ≤ : Type*} {F : Type*} [FunLike F Œ± Œ≤]\n    [Semiring R] [AddCommMonoid Œ±] [AddCommMonoid Œ≤] [Module R Œ±] [Module R Œ≤]\n    [TopologicalSpace R] [LinearMapClass F R Œ± Œ≤] [tŒ≤ : TopologicalSpace Œ≤] [ContinuousSMul R Œ≤]\n    (f : F) : @ContinuousSMul R Œ± _ _ (tŒ≤.induced f) := by\n  let tŒ± := tŒ≤.induced f\n  refine ‚ü®continuous_induced_rng.2 ?_‚ü©\n  simp only [Function.comp_def, map_smul]\n  fun_prop\n\n"}
{"name":"Filter.Tendsto.vadd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nŒ± : Type u_4\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : VAdd M X\ninst‚úù : ContinuousVAdd M X\nf : Œ± ‚Üí M\ng : Œ± ‚Üí X\nl : Filter Œ±\nc : M\na : X\nhf : Filter.Tendsto f l (nhds c)\nhg : Filter.Tendsto g l (nhds a)\n‚ä¢ Filter.Tendsto (fun x => HVAdd.hVAdd (f x) (g x)) l (nhds (HVAdd.hVAdd c a))","decl":"@[to_additive]\ntheorem Filter.Tendsto.smul {f : Œ± ‚Üí M} {g : Œ± ‚Üí X} {l : Filter Œ±} {c : M} {a : X}\n    (hf : Tendsto f l (ùìù c)) (hg : Tendsto g l (ùìù a)) :\n    Tendsto (fun x => f x ‚Ä¢ g x) l (ùìù <| c ‚Ä¢ a) :=\n  (continuous_smul.tendsto _).comp (hf.prod_mk_nhds hg)\n\n"}
{"name":"Filter.Tendsto.smul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nŒ± : Type u_4\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : SMul M X\ninst‚úù : ContinuousSMul M X\nf : Œ± ‚Üí M\ng : Œ± ‚Üí X\nl : Filter Œ±\nc : M\na : X\nhf : Filter.Tendsto f l (nhds c)\nhg : Filter.Tendsto g l (nhds a)\n‚ä¢ Filter.Tendsto (fun x => HSMul.hSMul (f x) (g x)) l (nhds (HSMul.hSMul c a))","decl":"@[to_additive]\ntheorem Filter.Tendsto.smul {f : Œ± ‚Üí M} {g : Œ± ‚Üí X} {l : Filter Œ±} {c : M} {a : X}\n    (hf : Tendsto f l (ùìù c)) (hg : Tendsto g l (ùìù a)) :\n    Tendsto (fun x => f x ‚Ä¢ g x) l (ùìù <| c ‚Ä¢ a) :=\n  (continuous_smul.tendsto _).comp (hf.prod_mk_nhds hg)\n\n"}
{"name":"Filter.Tendsto.smul_const","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nŒ± : Type u_4\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : SMul M X\ninst‚úù : ContinuousSMul M X\nf : Œ± ‚Üí M\nl : Filter Œ±\nc : M\nhf : Filter.Tendsto f l (nhds c)\na : X\n‚ä¢ Filter.Tendsto (fun x => HSMul.hSMul (f x) a) l (nhds (HSMul.hSMul c a))","decl":"@[to_additive]\ntheorem Filter.Tendsto.smul_const {f : Œ± ‚Üí M} {l : Filter Œ±} {c : M} (hf : Tendsto f l (ùìù c))\n    (a : X) : Tendsto (fun x => f x ‚Ä¢ a) l (ùìù (c ‚Ä¢ a)) :=\n  hf.smul tendsto_const_nhds\n\n"}
{"name":"Filter.Tendsto.vadd_const","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nŒ± : Type u_4\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : VAdd M X\ninst‚úù : ContinuousVAdd M X\nf : Œ± ‚Üí M\nl : Filter Œ±\nc : M\nhf : Filter.Tendsto f l (nhds c)\na : X\n‚ä¢ Filter.Tendsto (fun x => HVAdd.hVAdd (f x) a) l (nhds (HVAdd.hVAdd c a))","decl":"@[to_additive]\ntheorem Filter.Tendsto.smul_const {f : Œ± ‚Üí M} {l : Filter Œ±} {c : M} (hf : Tendsto f l (ùìù c))\n    (a : X) : Tendsto (fun x => f x ‚Ä¢ a) l (ùìù (c ‚Ä¢ a)) :=\n  hf.smul tendsto_const_nhds\n\n"}
{"name":"ContinuousWithinAt.smul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : SMul M X\ninst‚úù : ContinuousSMul M X\nf : Y ‚Üí M\ng : Y ‚Üí X\nb : Y\ns : Set Y\nhf : ContinuousWithinAt f s b\nhg : ContinuousWithinAt g s b\n‚ä¢ ContinuousWithinAt (fun x => HSMul.hSMul (f x) (g x)) s b","decl":"@[to_additive]\ntheorem ContinuousWithinAt.smul (hf : ContinuousWithinAt f s b) (hg : ContinuousWithinAt g s b) :\n    ContinuousWithinAt (fun x => f x ‚Ä¢ g x) s b :=\n  Filter.Tendsto.smul hf hg\n\n"}
{"name":"ContinuousWithinAt.vadd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : VAdd M X\ninst‚úù : ContinuousVAdd M X\nf : Y ‚Üí M\ng : Y ‚Üí X\nb : Y\ns : Set Y\nhf : ContinuousWithinAt f s b\nhg : ContinuousWithinAt g s b\n‚ä¢ ContinuousWithinAt (fun x => HVAdd.hVAdd (f x) (g x)) s b","decl":"@[to_additive]\ntheorem ContinuousWithinAt.smul (hf : ContinuousWithinAt f s b) (hg : ContinuousWithinAt g s b) :\n    ContinuousWithinAt (fun x => f x ‚Ä¢ g x) s b :=\n  Filter.Tendsto.smul hf hg\n\n"}
{"name":"ContinuousAt.smul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : SMul M X\ninst‚úù : ContinuousSMul M X\nf : Y ‚Üí M\ng : Y ‚Üí X\nb : Y\nhf : ContinuousAt f b\nhg : ContinuousAt g b\n‚ä¢ ContinuousAt (fun x => HSMul.hSMul (f x) (g x)) b","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousAt.smul (hf : ContinuousAt f b) (hg : ContinuousAt g b) :\n    ContinuousAt (fun x => f x ‚Ä¢ g x) b :=\n  Filter.Tendsto.smul hf hg\n\n"}
{"name":"ContinuousAt.vadd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : VAdd M X\ninst‚úù : ContinuousVAdd M X\nf : Y ‚Üí M\ng : Y ‚Üí X\nb : Y\nhf : ContinuousAt f b\nhg : ContinuousAt g b\n‚ä¢ ContinuousAt (fun x => HVAdd.hVAdd (f x) (g x)) b","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousAt.smul (hf : ContinuousAt f b) (hg : ContinuousAt g b) :\n    ContinuousAt (fun x => f x ‚Ä¢ g x) b :=\n  Filter.Tendsto.smul hf hg\n\n"}
{"name":"ContinuousOn.vadd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : VAdd M X\ninst‚úù : ContinuousVAdd M X\nf : Y ‚Üí M\ng : Y ‚Üí X\ns : Set Y\nhf : ContinuousOn f s\nhg : ContinuousOn g s\n‚ä¢ ContinuousOn (fun x => HVAdd.hVAdd (f x) (g x)) s","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousOn.smul (hf : ContinuousOn f s) (hg : ContinuousOn g s) :\n    ContinuousOn (fun x => f x ‚Ä¢ g x) s := fun x hx => (hf x hx).smul (hg x hx)\n\n"}
{"name":"ContinuousOn.smul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : SMul M X\ninst‚úù : ContinuousSMul M X\nf : Y ‚Üí M\ng : Y ‚Üí X\ns : Set Y\nhf : ContinuousOn f s\nhg : ContinuousOn g s\n‚ä¢ ContinuousOn (fun x => HSMul.hSMul (f x) (g x)) s","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousOn.smul (hf : ContinuousOn f s) (hg : ContinuousOn g s) :\n    ContinuousOn (fun x => f x ‚Ä¢ g x) s := fun x hx => (hf x hx).smul (hg x hx)\n\n"}
{"name":"Continuous.smul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : SMul M X\ninst‚úù : ContinuousSMul M X\nf : Y ‚Üí M\ng : Y ‚Üí X\nhf : Continuous f\nhg : Continuous g\n‚ä¢ Continuous fun x => HSMul.hSMul (f x) (g x)","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem Continuous.smul (hf : Continuous f) (hg : Continuous g) : Continuous fun x => f x ‚Ä¢ g x :=\n  continuous_smul.comp (hf.prod_mk hg)\n\n"}
{"name":"Continuous.vadd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : VAdd M X\ninst‚úù : ContinuousVAdd M X\nf : Y ‚Üí M\ng : Y ‚Üí X\nhf : Continuous f\nhg : Continuous g\n‚ä¢ Continuous fun x => HVAdd.hVAdd (f x) (g x)","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem Continuous.smul (hf : Continuous f) (hg : Continuous g) : Continuous fun x => f x ‚Ä¢ g x :=\n  continuous_smul.comp (hf.prod_mk hg)\n\n"}
{"name":"ContinuousSMul.op","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : SMul M X\ninst‚úù¬π : SMul (MulOpposite M) X\ninst‚úù : IsCentralScalar M X\n‚ä¢ ContinuousSMul (MulOpposite M) X","decl":"/-- If a scalar action is central, then its right action is continuous when its left action is. -/\n@[to_additive \"If an additive action is central, then its right action is continuous when its left\naction is.\"]\ninstance ContinuousSMul.op [SMul M·µê·µí·µñ X] [IsCentralScalar M X] : ContinuousSMul M·µê·µí·µñ X :=\n  ‚ü®by\n    suffices Continuous fun p : M √ó X => MulOpposite.op p.fst ‚Ä¢ p.snd from\n      this.comp (MulOpposite.continuous_unop.prodMap continuous_id)\n    simpa only [op_smul_eq_smul] using (continuous_smul : Continuous fun p : M √ó X => _)‚ü©\n\n"}
{"name":"ContinuousVAdd.op","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : VAdd M X\ninst‚úù¬π : VAdd (AddOpposite M) X\ninst‚úù : IsCentralVAdd M X\n‚ä¢ ContinuousVAdd (AddOpposite M) X","decl":"/-- If a scalar action is central, then its right action is continuous when its left action is. -/\n@[to_additive \"If an additive action is central, then its right action is continuous when its left\naction is.\"]\ninstance ContinuousSMul.op [SMul M·µê·µí·µñ X] [IsCentralScalar M X] : ContinuousSMul M·µê·µí·µñ X :=\n  ‚ü®by\n    suffices Continuous fun p : M √ó X => MulOpposite.op p.fst ‚Ä¢ p.snd from\n      this.comp (MulOpposite.continuous_unop.prodMap continuous_id)\n    simpa only [op_smul_eq_smul] using (continuous_smul : Continuous fun p : M √ó X => _)‚ü©\n\n"}
{"name":"AddOpposite.continuousVAdd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : VAdd M X\ninst‚úù : ContinuousVAdd M X\n‚ä¢ ContinuousVAdd M (AddOpposite X)","decl":"@[to_additive]\ninstance MulOpposite.continuousSMul : ContinuousSMul M X·µê·µí·µñ :=\n  ‚ü®MulOpposite.continuous_op.comp <|\n      continuous_smul.comp <| continuous_id.prodMap MulOpposite.continuous_unop‚ü©\n\n"}
{"name":"MulOpposite.continuousSMul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : SMul M X\ninst‚úù : ContinuousSMul M X\n‚ä¢ ContinuousSMul M (MulOpposite X)","decl":"@[to_additive]\ninstance MulOpposite.continuousSMul : ContinuousSMul M X·µê·µí·µñ :=\n  ‚ü®MulOpposite.continuous_op.comp <|\n      continuous_smul.comp <| continuous_id.prodMap MulOpposite.continuous_unop‚ü©\n\n"}
{"name":"Specializes.vadd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : VAdd M X\ninst‚úù : ContinuousVAdd M X\na b : M\nx y : X\nh‚ÇÅ : Specializes a b\nh‚ÇÇ : Specializes x y\n‚ä¢ Specializes (HVAdd.hVAdd a x) (HVAdd.hVAdd b y)","decl":"@[to_additive]\nprotected theorem Specializes.smul {a b : M} {x y : X} (h‚ÇÅ : a ‚§≥ b) (h‚ÇÇ : x ‚§≥ y) :\n    (a ‚Ä¢ x) ‚§≥ (b ‚Ä¢ y) :=\n  (h‚ÇÅ.prod h‚ÇÇ).map continuous_smul\n\n"}
{"name":"Specializes.smul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : SMul M X\ninst‚úù : ContinuousSMul M X\na b : M\nx y : X\nh‚ÇÅ : Specializes a b\nh‚ÇÇ : Specializes x y\n‚ä¢ Specializes (HSMul.hSMul a x) (HSMul.hSMul b y)","decl":"@[to_additive]\nprotected theorem Specializes.smul {a b : M} {x y : X} (h‚ÇÅ : a ‚§≥ b) (h‚ÇÇ : x ‚§≥ y) :\n    (a ‚Ä¢ x) ‚§≥ (b ‚Ä¢ y) :=\n  (h‚ÇÅ.prod h‚ÇÇ).map continuous_smul\n\n"}
{"name":"Inseparable.smul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : SMul M X\ninst‚úù : ContinuousSMul M X\na b : M\nx y : X\nh‚ÇÅ : Inseparable a b\nh‚ÇÇ : Inseparable x y\n‚ä¢ Inseparable (HSMul.hSMul a x) (HSMul.hSMul b y)","decl":"@[to_additive]\nprotected theorem Inseparable.smul {a b : M} {x y : X} (h‚ÇÅ : Inseparable a b)\n    (h‚ÇÇ : Inseparable x y) : Inseparable (a ‚Ä¢ x) (b ‚Ä¢ y) :=\n  (h‚ÇÅ.prod h‚ÇÇ).map continuous_smul\n\n"}
{"name":"Inseparable.vadd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : VAdd M X\ninst‚úù : ContinuousVAdd M X\na b : M\nx y : X\nh‚ÇÅ : Inseparable a b\nh‚ÇÇ : Inseparable x y\n‚ä¢ Inseparable (HVAdd.hVAdd a x) (HVAdd.hVAdd b y)","decl":"@[to_additive]\nprotected theorem Inseparable.smul {a b : M} {x y : X} (h‚ÇÅ : Inseparable a b)\n    (h‚ÇÇ : Inseparable x y) : Inseparable (a ‚Ä¢ x) (b ‚Ä¢ y) :=\n  (h‚ÇÅ.prod h‚ÇÇ).map continuous_smul\n\n"}
{"name":"IsCompact.smul_set","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : SMul M X\ninst‚úù : ContinuousSMul M X\nk : Set M\nu : Set X\nhk : IsCompact k\nhu : IsCompact u\n‚ä¢ IsCompact (HSMul.hSMul k u)","decl":"@[to_additive]\nlemma IsCompact.smul_set {k : Set M} {u : Set X} (hk : IsCompact k) (hu : IsCompact u) :\n    IsCompact (k ‚Ä¢ u) := by\n  rw [‚Üê Set.image_smul_prod]\n  exact IsCompact.image (hk.prod hu) continuous_smul\n\n"}
{"name":"IsCompact.vadd_set","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : VAdd M X\ninst‚úù : ContinuousVAdd M X\nk : Set M\nu : Set X\nhk : IsCompact k\nhu : IsCompact u\n‚ä¢ IsCompact (HVAdd.hVAdd k u)","decl":"@[to_additive]\nlemma IsCompact.smul_set {k : Set M} {u : Set X} (hk : IsCompact k) (hu : IsCompact u) :\n    IsCompact (k ‚Ä¢ u) := by\n  rw [‚Üê Set.image_smul_prod]\n  exact IsCompact.image (hk.prod hu) continuous_smul\n\n"}
{"name":"vadd_set_closure_subset","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : VAdd M X\ninst‚úù : ContinuousVAdd M X\nK : Set M\nL : Set X\n‚ä¢ HasSubset.Subset (HVAdd.hVAdd (closure K) (closure L)) (closure (HVAdd.hVAdd K L))","decl":"@[to_additive]\nlemma smul_set_closure_subset (K : Set M) (L : Set X) :\n    closure K ‚Ä¢ closure L ‚äÜ closure (K ‚Ä¢ L) :=\n  Set.smul_subset_iff.2 fun _x hx _y hy ‚Ü¶ map_mem_closure‚ÇÇ continuous_smul hx hy fun _a ha _b hb ‚Ü¶\n    Set.smul_mem_smul ha hb\n\n"}
{"name":"smul_set_closure_subset","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : SMul M X\ninst‚úù : ContinuousSMul M X\nK : Set M\nL : Set X\n‚ä¢ HasSubset.Subset (HSMul.hSMul (closure K) (closure L)) (closure (HSMul.hSMul K L))","decl":"@[to_additive]\nlemma smul_set_closure_subset (K : Set M) (L : Set X) :\n    closure K ‚Ä¢ closure L ‚äÜ closure (K ‚Ä¢ L) :=\n  Set.smul_subset_iff.2 fun _x hx _y hy ‚Ü¶ map_mem_closure‚ÇÇ continuous_smul hx hy fun _a ha _b hb ‚Ü¶\n    Set.smul_mem_smul ha hb\n\n"}
{"name":"Topology.IsInducing.continuousSMul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst‚úù‚Å∂ : TopologicalSpace M\ninst‚úù‚Åµ : TopologicalSpace X\ninst‚úù‚Å¥ : TopologicalSpace Y\ninst‚úù¬≥ : SMul M X\ninst‚úù¬≤ : ContinuousSMul M X\ng : Y ‚Üí X\nN : Type u_5\ninst‚úù¬π : SMul N Y\ninst‚úù : TopologicalSpace N\nf : N ‚Üí M\nhg : Topology.IsInducing g\nhf : Continuous f\nhsmul : ‚àÄ {c : N} {x : Y}, Eq (g (HSMul.hSMul c x)) (HSMul.hSMul (f c) (g x))\n‚ä¢ ContinuousSMul N Y","decl":"/-- Suppose that `N` acts on `X` and `M` continuously acts on `Y`.\nSuppose that `g : Y ‚Üí X` is an action homomorphism in the following sense:\nthere exists a continuous function `f : N ‚Üí M` such that `g (c ‚Ä¢ x) = f c ‚Ä¢ g x`.\nThen the action of `N` on `X` is continuous as well.\n\nIn many cases, `f = id` so that `g` is an action homomorphism in the sense of `MulActionHom`.\nHowever, this version also works for semilinear maps and `f = Units.val`. -/\n@[to_additive\n  \"Suppose that `N` additively acts on `X` and `M` continuously additively acts on `Y`.\nSuppose that `g : Y ‚Üí X` is an additive action homomorphism in the following sense:\nthere exists a continuous function `f : N ‚Üí M` such that `g (c +·µ• x) = f c +·µ• g x`.\nThen the action of `N` on `X` is continuous as well.\n\nIn many cases, `f = id` so that `g` is an action homomorphism in the sense of `AddActionHom`.\nHowever, this version also works for `f = AddUnits.val`.\"]\nlemma Topology.IsInducing.continuousSMul {N : Type*} [SMul N Y] [TopologicalSpace N] {f : N ‚Üí M}\n    (hg : IsInducing g) (hf : Continuous f) (hsmul : ‚àÄ {c x}, g (c ‚Ä¢ x) = f c ‚Ä¢ g x) :\n    ContinuousSMul N Y where\n  continuous_smul := by\n    simpa only [hg.continuous_iff, Function.comp_def, hsmul]\n      using (hf.comp continuous_fst).smul <| hg.continuous.comp continuous_snd\n\n"}
{"name":"Topology.IsInducing.continuousVAdd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst‚úù‚Å∂ : TopologicalSpace M\ninst‚úù‚Åµ : TopologicalSpace X\ninst‚úù‚Å¥ : TopologicalSpace Y\ninst‚úù¬≥ : VAdd M X\ninst‚úù¬≤ : ContinuousVAdd M X\ng : Y ‚Üí X\nN : Type u_5\ninst‚úù¬π : VAdd N Y\ninst‚úù : TopologicalSpace N\nf : N ‚Üí M\nhg : Topology.IsInducing g\nhf : Continuous f\nhsmul : ‚àÄ {c : N} {x : Y}, Eq (g (HVAdd.hVAdd c x)) (HVAdd.hVAdd (f c) (g x))\n‚ä¢ ContinuousVAdd N Y","decl":"/-- Suppose that `N` acts on `X` and `M` continuously acts on `Y`.\nSuppose that `g : Y ‚Üí X` is an action homomorphism in the following sense:\nthere exists a continuous function `f : N ‚Üí M` such that `g (c ‚Ä¢ x) = f c ‚Ä¢ g x`.\nThen the action of `N` on `X` is continuous as well.\n\nIn many cases, `f = id` so that `g` is an action homomorphism in the sense of `MulActionHom`.\nHowever, this version also works for semilinear maps and `f = Units.val`. -/\n@[to_additive\n  \"Suppose that `N` additively acts on `X` and `M` continuously additively acts on `Y`.\nSuppose that `g : Y ‚Üí X` is an additive action homomorphism in the following sense:\nthere exists a continuous function `f : N ‚Üí M` such that `g (c +·µ• x) = f c +·µ• g x`.\nThen the action of `N` on `X` is continuous as well.\n\nIn many cases, `f = id` so that `g` is an action homomorphism in the sense of `AddActionHom`.\nHowever, this version also works for `f = AddUnits.val`.\"]\nlemma Topology.IsInducing.continuousSMul {N : Type*} [SMul N Y] [TopologicalSpace N] {f : N ‚Üí M}\n    (hg : IsInducing g) (hf : Continuous f) (hsmul : ‚àÄ {c x}, g (c ‚Ä¢ x) = f c ‚Ä¢ g x) :\n    ContinuousSMul N Y where\n  continuous_smul := by\n    simpa only [hg.continuous_iff, Function.comp_def, hsmul]\n      using (hf.comp continuous_fst).smul <| hg.continuous.comp continuous_snd\n\n"}
{"name":"Inducing.continuousSMul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst‚úù‚Å∂ : TopologicalSpace M\ninst‚úù‚Åµ : TopologicalSpace X\ninst‚úù‚Å¥ : TopologicalSpace Y\ninst‚úù¬≥ : SMul M X\ninst‚úù¬≤ : ContinuousSMul M X\ng : Y ‚Üí X\nN : Type u_5\ninst‚úù¬π : SMul N Y\ninst‚úù : TopologicalSpace N\nf : N ‚Üí M\nhg : Topology.IsInducing g\nhf : Continuous f\nhsmul : ‚àÄ {c : N} {x : Y}, Eq (g (HSMul.hSMul c x)) (HSMul.hSMul (f c) (g x))\n‚ä¢ ContinuousSMul N Y","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.continuousSMul := IsInducing.continuousSMul\n\n"}
{"name":"SMulMemClass.continuousSMul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù‚Åµ : TopologicalSpace M\ninst‚úù‚Å¥ : TopologicalSpace X\ninst‚úù¬≥ : SMul M X\ninst‚úù¬≤ : ContinuousSMul M X\nS : Type u_5\ninst‚úù¬π : SetLike S X\ninst‚úù : SMulMemClass S M X\ns : S\n‚ä¢ ContinuousSMul M (Subtype fun x => Membership.mem s x)","decl":"@[to_additive]\ninstance SMulMemClass.continuousSMul {S : Type*} [SetLike S X] [SMulMemClass S M X] (s : S) :\n    ContinuousSMul M s :=\n  IsInducing.subtypeVal.continuousSMul continuous_id rfl\n\n"}
{"name":"VAddMemClass.continuousVAdd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù‚Åµ : TopologicalSpace M\ninst‚úù‚Å¥ : TopologicalSpace X\ninst‚úù¬≥ : VAdd M X\ninst‚úù¬≤ : ContinuousVAdd M X\nS : Type u_5\ninst‚úù¬π : SetLike S X\ninst‚úù : VAddMemClass S M X\ns : S\n‚ä¢ ContinuousVAdd M (Subtype fun x => Membership.mem s x)","decl":"@[to_additive]\ninstance SMulMemClass.continuousSMul {S : Type*} [SetLike S X] [SMulMemClass S M X] (s : S) :\n    ContinuousSMul M s :=\n  IsInducing.subtypeVal.continuousSMul continuous_id rfl\n\n"}
{"name":"Units.continuousSMul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : Monoid M\ninst‚úù¬π : MulAction M X\ninst‚úù : ContinuousSMul M X\n‚ä¢ ContinuousSMul (Units M) X","decl":"@[to_additive]\ninstance Units.continuousSMul : ContinuousSMul MÀ£ X :=\n  IsInducing.id.continuousSMul Units.continuous_val rfl\n\n"}
{"name":"AddUnits.continuousVAdd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : AddMonoid M\ninst‚úù¬π : AddAction M X\ninst‚úù : ContinuousVAdd M X\n‚ä¢ ContinuousVAdd (AddUnits M) X","decl":"@[to_additive]\ninstance Units.continuousSMul : ContinuousSMul MÀ£ X :=\n  IsInducing.id.continuousSMul Units.continuous_val rfl\n\n"}
{"name":"AddAction.continuousVAdd_compHom","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù‚Å∂ : TopologicalSpace M\ninst‚úù‚Åµ : TopologicalSpace X\ninst‚úù‚Å¥ : AddMonoid M\ninst‚úù¬≥ : AddAction M X\ninst‚úù¬≤ : ContinuousVAdd M X\nN : Type u_5\ninst‚úù¬π : TopologicalSpace N\ninst‚úù : AddMonoid N\nf : AddMonoidHom N M\nhf : Continuous ‚áëf\n‚ä¢ ContinuousVAdd N X","decl":"/-- If an action is continuous, then composing this action with a continuous homomorphism gives\nagain a continuous action. -/\n@[to_additive]\ntheorem MulAction.continuousSMul_compHom\n    {N : Type*} [TopologicalSpace N] [Monoid N] {f : N ‚Üí* M} (hf : Continuous f) :\n    letI : MulAction N X := MulAction.compHom _ f\n    ContinuousSMul N X := by\n  let _ : MulAction N X := MulAction.compHom _ f\n  exact ‚ü®(hf.comp continuous_fst).smul continuous_snd‚ü©\n\n"}
{"name":"MulAction.continuousSMul_compHom","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù‚Å∂ : TopologicalSpace M\ninst‚úù‚Åµ : TopologicalSpace X\ninst‚úù‚Å¥ : Monoid M\ninst‚úù¬≥ : MulAction M X\ninst‚úù¬≤ : ContinuousSMul M X\nN : Type u_5\ninst‚úù¬π : TopologicalSpace N\ninst‚úù : Monoid N\nf : MonoidHom N M\nhf : Continuous ‚áëf\n‚ä¢ ContinuousSMul N X","decl":"/-- If an action is continuous, then composing this action with a continuous homomorphism gives\nagain a continuous action. -/\n@[to_additive]\ntheorem MulAction.continuousSMul_compHom\n    {N : Type*} [TopologicalSpace N] [Monoid N] {f : N ‚Üí* M} (hf : Continuous f) :\n    letI : MulAction N X := MulAction.compHom _ f\n    ContinuousSMul N X := by\n  let _ : MulAction N X := MulAction.compHom _ f\n  exact ‚ü®(hf.comp continuous_fst).smul continuous_snd‚ü©\n\n"}
{"name":"Submonoid.continuousSMul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : Monoid M\ninst‚úù¬π : MulAction M X\ninst‚úù : ContinuousSMul M X\nS : Submonoid M\n‚ä¢ ContinuousSMul (Subtype fun x => Membership.mem S x) X","decl":"@[to_additive]\ninstance Submonoid.continuousSMul {S : Submonoid M} : ContinuousSMul S X :=\n  IsInducing.id.continuousSMul continuous_subtype_val rfl\n\n"}
{"name":"AddSubmonoid.continuousVAdd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : AddMonoid M\ninst‚úù¬π : AddAction M X\ninst‚úù : ContinuousVAdd M X\nS : AddSubmonoid M\n‚ä¢ ContinuousVAdd (Subtype fun x => Membership.mem S x) X","decl":"@[to_additive]\ninstance Submonoid.continuousSMul {S : Submonoid M} : ContinuousSMul S X :=\n  IsInducing.id.continuousSMul continuous_subtype_val rfl\n\n"}
{"name":"AddSubgroup.continuousVAdd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : AddGroup M\ninst‚úù¬π : AddAction M X\ninst‚úù : ContinuousVAdd M X\nS : AddSubgroup M\n‚ä¢ ContinuousVAdd (Subtype fun x => Membership.mem S x) X","decl":"@[to_additive]\ninstance Subgroup.continuousSMul {S : Subgroup M} : ContinuousSMul S X :=\n  S.toSubmonoid.continuousSMul\n\n"}
{"name":"Subgroup.continuousSMul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù‚Å¥ : TopologicalSpace M\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : Group M\ninst‚úù¬π : MulAction M X\ninst‚úù : ContinuousSMul M X\nS : Subgroup M\n‚ä¢ ContinuousSMul (Subtype fun x => Membership.mem S x) X","decl":"@[to_additive]\ninstance Subgroup.continuousSMul {S : Subgroup M} : ContinuousSMul S X :=\n  S.toSubmonoid.continuousSMul\n\n"}
{"name":"stabilizer_isOpen","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst‚úù‚Åµ : TopologicalSpace M\ninst‚úù‚Å¥ : TopologicalSpace X\ninst‚úù¬≥ : Group M\ninst‚úù¬≤ : MulAction M X\ninst‚úù¬π : ContinuousSMul M X\ninst‚úù : DiscreteTopology X\nx : X\n‚ä¢ IsOpen ‚Üë(MulAction.stabilizer M x)","decl":"/-- The stabilizer of a continuous group action on a discrete space is an open subgroup. -/\nlemma stabilizer_isOpen [DiscreteTopology X] (x : X) : IsOpen (MulAction.stabilizer M x : Set M) :=\n  IsOpen.preimage (f := fun g ‚Ü¶ g ‚Ä¢ x) (by fun_prop) (isOpen_discrete {x})\n\n"}
{"name":"Prod.continuousVAdd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst‚úù‚Å∂ : TopologicalSpace M\ninst‚úù‚Åµ : TopologicalSpace X\ninst‚úù‚Å¥ : TopologicalSpace Y\ninst‚úù¬≥ : VAdd M X\ninst‚úù¬≤ : VAdd M Y\ninst‚úù¬π : ContinuousVAdd M X\ninst‚úù : ContinuousVAdd M Y\n‚ä¢ ContinuousVAdd M (Prod X Y)","decl":"@[to_additive]\ninstance Prod.continuousSMul [SMul M X] [SMul M Y] [ContinuousSMul M X] [ContinuousSMul M Y] :\n    ContinuousSMul M (X √ó Y) :=\n  ‚ü®(continuous_fst.smul (continuous_fst.comp continuous_snd)).prod_mk\n      (continuous_fst.smul (continuous_snd.comp continuous_snd))‚ü©\n\n"}
{"name":"Prod.continuousSMul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst‚úù‚Å∂ : TopologicalSpace M\ninst‚úù‚Åµ : TopologicalSpace X\ninst‚úù‚Å¥ : TopologicalSpace Y\ninst‚úù¬≥ : SMul M X\ninst‚úù¬≤ : SMul M Y\ninst‚úù¬π : ContinuousSMul M X\ninst‚úù : ContinuousSMul M Y\n‚ä¢ ContinuousSMul M (Prod X Y)","decl":"@[to_additive]\ninstance Prod.continuousSMul [SMul M X] [SMul M Y] [ContinuousSMul M X] [ContinuousSMul M Y] :\n    ContinuousSMul M (X √ó Y) :=\n  ‚ü®(continuous_fst.smul (continuous_fst.comp continuous_snd)).prod_mk\n      (continuous_fst.smul (continuous_snd.comp continuous_snd))‚ü©\n\n"}
{"name":"instContinuousSMulForall","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\ninst‚úù¬≥ : TopologicalSpace M\nŒπ : Type u_5\nŒ≥ : Œπ ‚Üí Type u_6\ninst‚úù¬≤ : (i : Œπ) ‚Üí TopologicalSpace (Œ≥ i)\ninst‚úù¬π : (i : Œπ) ‚Üí SMul M (Œ≥ i)\ninst‚úù : ‚àÄ (i : Œπ), ContinuousSMul M (Œ≥ i)\n‚ä¢ ContinuousSMul M ((i : Œπ) ‚Üí Œ≥ i)","decl":"@[to_additive]\ninstance {Œπ : Type*} {Œ≥ : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (Œ≥ i)] [‚àÄ i, SMul M (Œ≥ i)]\n    [‚àÄ i, ContinuousSMul M (Œ≥ i)] : ContinuousSMul M (‚àÄ i, Œ≥ i) :=\n  ‚ü®continuous_pi fun i =>\n      (continuous_fst.smul continuous_snd).comp <|\n        continuous_fst.prod_mk ((continuous_apply i).comp continuous_snd)‚ü©\n\n"}
{"name":"instContinuousVAddForall","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\ninst‚úù¬≥ : TopologicalSpace M\nŒπ : Type u_5\nŒ≥ : Œπ ‚Üí Type u_6\ninst‚úù¬≤ : (i : Œπ) ‚Üí TopologicalSpace (Œ≥ i)\ninst‚úù¬π : (i : Œπ) ‚Üí VAdd M (Œ≥ i)\ninst‚úù : ‚àÄ (i : Œπ), ContinuousVAdd M (Œ≥ i)\n‚ä¢ ContinuousVAdd M ((i : Œπ) ‚Üí Œ≥ i)","decl":"@[to_additive]\ninstance {Œπ : Type*} {Œ≥ : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (Œ≥ i)] [‚àÄ i, SMul M (Œ≥ i)]\n    [‚àÄ i, ContinuousSMul M (Œ≥ i)] : ContinuousSMul M (‚àÄ i, Œ≥ i) :=\n  ‚ü®continuous_pi fun i =>\n      (continuous_fst.smul continuous_snd).comp <|\n        continuous_fst.prod_mk ((continuous_apply i).comp continuous_snd)‚ü©\n\n"}
{"name":"continuousSMul_sInf","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_2\nX : Type u_3\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : SMul M X\nts : Set (TopologicalSpace X)\nh : ‚àÄ (t : TopologicalSpace X), Membership.mem ts t ‚Üí ContinuousSMul M X\n‚ä¢ ContinuousSMul M X","decl":"@[to_additive]\ntheorem continuousSMul_sInf {ts : Set (TopologicalSpace X)}\n    (h : ‚àÄ t ‚àà ts, @ContinuousSMul M X _ _ t) : @ContinuousSMul M X _ _ (sInf ts) :=\n  -- Porting note: {} doesn't work because `sInf ts` isn't found by TC search. `(_)` finds it by\n  -- unification instead.\n  @ContinuousSMul.mk M X _ _ (_) <| by\n      -- Porting note: needs `( :)`\n      rw [‚Üê (@sInf_singleton _ _ ‚ÄπTopologicalSpace M‚Ä∫:)]\n      exact\n        continuous_sInf_rng.2 fun t ht =>\n          continuous_sInf_dom‚ÇÇ (Eq.refl _) ht\n            (@ContinuousSMul.continuous_smul _ _ _ _ t (h t ht))\n\n"}
{"name":"continuousVAdd_sInf","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_2\nX : Type u_3\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : VAdd M X\nts : Set (TopologicalSpace X)\nh : ‚àÄ (t : TopologicalSpace X), Membership.mem ts t ‚Üí ContinuousVAdd M X\n‚ä¢ ContinuousVAdd M X","decl":"@[to_additive]\ntheorem continuousSMul_sInf {ts : Set (TopologicalSpace X)}\n    (h : ‚àÄ t ‚àà ts, @ContinuousSMul M X _ _ t) : @ContinuousSMul M X _ _ (sInf ts) :=\n  -- Porting note: {} doesn't work because `sInf ts` isn't found by TC search. `(_)` finds it by\n  -- unification instead.\n  @ContinuousSMul.mk M X _ _ (_) <| by\n      -- Porting note: needs `( :)`\n      rw [‚Üê (@sInf_singleton _ _ ‚ÄπTopologicalSpace M‚Ä∫:)]\n      exact\n        continuous_sInf_rng.2 fun t ht =>\n          continuous_sInf_dom‚ÇÇ (Eq.refl _) ht\n            (@ContinuousSMul.continuous_smul _ _ _ _ t (h t ht))\n\n"}
{"name":"continuousSMul_iInf","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"Œπ : Sort u_1\nM : Type u_2\nX : Type u_3\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : SMul M X\nts' : Œπ ‚Üí TopologicalSpace X\nh : ‚àÄ (i : Œπ), ContinuousSMul M X\n‚ä¢ ContinuousSMul M X","decl":"@[to_additive]\ntheorem continuousSMul_iInf {ts' : Œπ ‚Üí TopologicalSpace X}\n    (h : ‚àÄ i, @ContinuousSMul M X _ _ (ts' i)) : @ContinuousSMul M X _ _ (‚®Ö i, ts' i) :=\n  continuousSMul_sInf <| Set.forall_mem_range.mpr h\n\n"}
{"name":"continuousVAdd_iInf","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"Œπ : Sort u_1\nM : Type u_2\nX : Type u_3\ninst‚úù¬π : TopologicalSpace M\ninst‚úù : VAdd M X\nts' : Œπ ‚Üí TopologicalSpace X\nh : ‚àÄ (i : Œπ), ContinuousVAdd M X\n‚ä¢ ContinuousVAdd M X","decl":"@[to_additive]\ntheorem continuousSMul_iInf {ts' : Œπ ‚Üí TopologicalSpace X}\n    (h : ‚àÄ i, @ContinuousSMul M X _ _ (ts' i)) : @ContinuousSMul M X _ _ (‚®Ö i, ts' i) :=\n  continuousSMul_sInf <| Set.forall_mem_range.mpr h\n\n"}
{"name":"continuousVAdd_inf","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_2\nX : Type u_3\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : VAdd M X\nt‚ÇÅ t‚ÇÇ : TopologicalSpace X\ninst‚úù¬π : ContinuousVAdd M X\ninst‚úù : ContinuousVAdd M X\n‚ä¢ ContinuousVAdd M X","decl":"@[to_additive]\ntheorem continuousSMul_inf {t‚ÇÅ t‚ÇÇ : TopologicalSpace X} [@ContinuousSMul M X _ _ t‚ÇÅ]\n    [@ContinuousSMul M X _ _ t‚ÇÇ] : @ContinuousSMul M X _ _ (t‚ÇÅ ‚äì t‚ÇÇ) := by\n  rw [inf_eq_iInf]\n  refine continuousSMul_iInf fun b => ?_\n  cases b <;> assumption\n\n"}
{"name":"continuousSMul_inf","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_2\nX : Type u_3\ninst‚úù¬≥ : TopologicalSpace M\ninst‚úù¬≤ : SMul M X\nt‚ÇÅ t‚ÇÇ : TopologicalSpace X\ninst‚úù¬π : ContinuousSMul M X\ninst‚úù : ContinuousSMul M X\n‚ä¢ ContinuousSMul M X","decl":"@[to_additive]\ntheorem continuousSMul_inf {t‚ÇÅ t‚ÇÇ : TopologicalSpace X} [@ContinuousSMul M X _ _ t‚ÇÅ]\n    [@ContinuousSMul M X _ _ t‚ÇÇ] : @ContinuousSMul M X _ _ (t‚ÇÅ ‚äì t‚ÇÇ) := by\n  rw [inf_eq_iInf]\n  refine continuousSMul_iInf fun b => ?_\n  cases b <;> assumption\n\n"}
{"name":"AddTorsor.connectedSpace","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"G : Type u_1\nP : Type u_2\ninst‚úù‚Åµ : AddGroup G\ninst‚úù‚Å¥ : AddTorsor G P\ninst‚úù¬≥ : TopologicalSpace G\ninst‚úù¬≤ : PreconnectedSpace G\ninst‚úù¬π : TopologicalSpace P\ninst‚úù : ContinuousVAdd G P\n‚ä¢ ConnectedSpace P","decl":"include G in\n/-- An `AddTorsor` for a connected space is a connected space. This is not an instance because\nit loops for a group as a torsor over itself. -/\nprotected theorem AddTorsor.connectedSpace : ConnectedSpace P :=\n  { isPreconnected_univ := by\n      convert\n        isPreconnected_univ.image (Equiv.vaddConst (Classical.arbitrary P) : G ‚Üí P)\n          (continuous_id.vadd continuous_const).continuousOn\n      rw [Set.image_univ, Equiv.range_eq_univ]\n    toNonempty := inferInstance }\n\n"}
