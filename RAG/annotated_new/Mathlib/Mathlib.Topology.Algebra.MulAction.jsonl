{"name":"ContinuousSMul.continuous_smul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝² : SMul M X\ninst✝¹ : TopologicalSpace M\ninst✝ : TopologicalSpace X\nself : ContinuousSMul M X\n⊢ Continuous fun p => HSMul.hSMul p.1 p.2","decl":"/-- Class `ContinuousSMul M X` says that the scalar multiplication `(•) : M → X → X`\nis continuous in both arguments. We use the same class for all kinds of multiplicative actions,\nincluding (semi)modules and algebras. -/\nclass ContinuousSMul (M X : Type*) [SMul M X] [TopologicalSpace M] [TopologicalSpace X] :\n    Prop where\n  /-- The scalar multiplication `(•)` is continuous. -/\n  continuous_smul : Continuous fun p : M × X => p.1 • p.2\n\n"}
{"name":"ContinuousVAdd.continuous_vadd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝² : VAdd M X\ninst✝¹ : TopologicalSpace M\ninst✝ : TopologicalSpace X\nself : ContinuousVAdd M X\n⊢ Continuous fun p => HVAdd.hVAdd p.1 p.2","decl":"/-- Class `ContinuousVAdd M X` says that the additive action `(+ᵥ) : M → X → X`\nis continuous in both arguments. We use the same class for all kinds of additive actions,\nincluding (semi)modules and algebras. -/\nclass ContinuousVAdd (M X : Type*) [VAdd M X] [TopologicalSpace M] [TopologicalSpace X] :\n    Prop where\n  /-- The additive action `(+ᵥ)` is continuous. -/\n  continuous_vadd : Continuous fun p : M × X => p.1 +ᵥ p.2\n\n"}
{"name":"IsScalarTower.continuousSMul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_5\nN : Type u_6\nα : Type u_7\ninst✝⁹ : Monoid N\ninst✝⁸ : SMul M N\ninst✝⁷ : MulAction N α\ninst✝⁶ : SMul M α\ninst✝⁵ : IsScalarTower M N α\ninst✝⁴ : TopologicalSpace M\ninst✝³ : TopologicalSpace N\ninst✝² : TopologicalSpace α\ninst✝¹ : ContinuousSMul M N\ninst✝ : ContinuousSMul N α\n⊢ ContinuousSMul M α","decl":"lemma IsScalarTower.continuousSMul {M : Type*} (N : Type*) {α : Type*} [Monoid N] [SMul M N]\n    [MulAction N α] [SMul M α] [IsScalarTower M N α] [TopologicalSpace M] [TopologicalSpace N]\n    [TopologicalSpace α] [ContinuousSMul M N] [ContinuousSMul N α] : ContinuousSMul M α :=\n  { continuous_smul := by\n      suffices Continuous (fun p : M × α ↦ (p.1 • (1 : N)) • p.2) by simpa\n      fun_prop }\n\n"}
{"name":"instContinuousSMulULift","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace X\ninst✝¹ : SMul M X\ninst✝ : ContinuousSMul M X\n⊢ ContinuousSMul (ULift.{u_5, u_1} M) X","decl":"@[to_additive]\ninstance : ContinuousSMul (ULift M) X :=\n  ⟨(continuous_smul (M := M)).comp₂ (continuous_uLift_down.comp continuous_fst) continuous_snd⟩\n\n"}
{"name":"instContinuousVAddULift","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace X\ninst✝¹ : VAdd M X\ninst✝ : ContinuousVAdd M X\n⊢ ContinuousVAdd (ULift.{u_5, u_1} M) X","decl":"@[to_additive]\ninstance : ContinuousSMul (ULift M) X :=\n  ⟨(continuous_smul (M := M)).comp₂ (continuous_uLift_down.comp continuous_fst) continuous_snd⟩\n\n"}
{"name":"ContinuousVAdd.continuousConstVAdd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace X\ninst✝¹ : VAdd M X\ninst✝ : ContinuousVAdd M X\n⊢ ContinuousConstVAdd M X","decl":"@[to_additive]\ninstance (priority := 100) ContinuousSMul.continuousConstSMul : ContinuousConstSMul M X where\n  continuous_const_smul _ := continuous_smul.comp (continuous_const.prod_mk continuous_id)\n\n"}
{"name":"ContinuousSMul.continuousConstSMul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace X\ninst✝¹ : SMul M X\ninst✝ : ContinuousSMul M X\n⊢ ContinuousConstSMul M X","decl":"@[to_additive]\ninstance (priority := 100) ContinuousSMul.continuousConstSMul : ContinuousConstSMul M X where\n  continuous_const_smul _ := continuous_smul.comp (continuous_const.prod_mk continuous_id)\n\n"}
{"name":"ContinuousSMul.induced","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"R : Type u_5\nα : Type u_6\nβ : Type u_7\nF : Type u_8\ninst✝⁸ : FunLike F α β\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid α\ninst✝⁵ : AddCommMonoid β\ninst✝⁴ : Module R α\ninst✝³ : Module R β\ninst✝² : TopologicalSpace R\ninst✝¹ : LinearMapClass F R α β\ntβ : TopologicalSpace β\ninst✝ : ContinuousSMul R β\nf : F\n⊢ ContinuousSMul R α","decl":"theorem ContinuousSMul.induced {R : Type*} {α : Type*} {β : Type*} {F : Type*} [FunLike F α β]\n    [Semiring R] [AddCommMonoid α] [AddCommMonoid β] [Module R α] [Module R β]\n    [TopologicalSpace R] [LinearMapClass F R α β] [tβ : TopologicalSpace β] [ContinuousSMul R β]\n    (f : F) : @ContinuousSMul R α _ _ (tβ.induced f) := by\n  let tα := tβ.induced f\n  refine ⟨continuous_induced_rng.2 ?_⟩\n  simp only [Function.comp_def, map_smul]\n  fun_prop\n\n"}
{"name":"Filter.Tendsto.vadd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nα : Type u_4\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace X\ninst✝¹ : VAdd M X\ninst✝ : ContinuousVAdd M X\nf : α → M\ng : α → X\nl : Filter α\nc : M\na : X\nhf : Filter.Tendsto f l (nhds c)\nhg : Filter.Tendsto g l (nhds a)\n⊢ Filter.Tendsto (fun x => HVAdd.hVAdd (f x) (g x)) l (nhds (HVAdd.hVAdd c a))","decl":"@[to_additive]\ntheorem Filter.Tendsto.smul {f : α → M} {g : α → X} {l : Filter α} {c : M} {a : X}\n    (hf : Tendsto f l (𝓝 c)) (hg : Tendsto g l (𝓝 a)) :\n    Tendsto (fun x => f x • g x) l (𝓝 <| c • a) :=\n  (continuous_smul.tendsto _).comp (hf.prod_mk_nhds hg)\n\n"}
{"name":"Filter.Tendsto.smul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nα : Type u_4\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace X\ninst✝¹ : SMul M X\ninst✝ : ContinuousSMul M X\nf : α → M\ng : α → X\nl : Filter α\nc : M\na : X\nhf : Filter.Tendsto f l (nhds c)\nhg : Filter.Tendsto g l (nhds a)\n⊢ Filter.Tendsto (fun x => HSMul.hSMul (f x) (g x)) l (nhds (HSMul.hSMul c a))","decl":"@[to_additive]\ntheorem Filter.Tendsto.smul {f : α → M} {g : α → X} {l : Filter α} {c : M} {a : X}\n    (hf : Tendsto f l (𝓝 c)) (hg : Tendsto g l (𝓝 a)) :\n    Tendsto (fun x => f x • g x) l (𝓝 <| c • a) :=\n  (continuous_smul.tendsto _).comp (hf.prod_mk_nhds hg)\n\n"}
{"name":"Filter.Tendsto.smul_const","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nα : Type u_4\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace X\ninst✝¹ : SMul M X\ninst✝ : ContinuousSMul M X\nf : α → M\nl : Filter α\nc : M\nhf : Filter.Tendsto f l (nhds c)\na : X\n⊢ Filter.Tendsto (fun x => HSMul.hSMul (f x) a) l (nhds (HSMul.hSMul c a))","decl":"@[to_additive]\ntheorem Filter.Tendsto.smul_const {f : α → M} {l : Filter α} {c : M} (hf : Tendsto f l (𝓝 c))\n    (a : X) : Tendsto (fun x => f x • a) l (𝓝 (c • a)) :=\n  hf.smul tendsto_const_nhds\n\n"}
{"name":"Filter.Tendsto.vadd_const","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nα : Type u_4\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace X\ninst✝¹ : VAdd M X\ninst✝ : ContinuousVAdd M X\nf : α → M\nl : Filter α\nc : M\nhf : Filter.Tendsto f l (nhds c)\na : X\n⊢ Filter.Tendsto (fun x => HVAdd.hVAdd (f x) a) l (nhds (HVAdd.hVAdd c a))","decl":"@[to_additive]\ntheorem Filter.Tendsto.smul_const {f : α → M} {l : Filter α} {c : M} (hf : Tendsto f l (𝓝 c))\n    (a : X) : Tendsto (fun x => f x • a) l (𝓝 (c • a)) :=\n  hf.smul tendsto_const_nhds\n\n"}
{"name":"ContinuousWithinAt.smul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst✝⁴ : TopologicalSpace M\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : SMul M X\ninst✝ : ContinuousSMul M X\nf : Y → M\ng : Y → X\nb : Y\ns : Set Y\nhf : ContinuousWithinAt f s b\nhg : ContinuousWithinAt g s b\n⊢ ContinuousWithinAt (fun x => HSMul.hSMul (f x) (g x)) s b","decl":"@[to_additive]\ntheorem ContinuousWithinAt.smul (hf : ContinuousWithinAt f s b) (hg : ContinuousWithinAt g s b) :\n    ContinuousWithinAt (fun x => f x • g x) s b :=\n  Filter.Tendsto.smul hf hg\n\n"}
{"name":"ContinuousWithinAt.vadd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst✝⁴ : TopologicalSpace M\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : VAdd M X\ninst✝ : ContinuousVAdd M X\nf : Y → M\ng : Y → X\nb : Y\ns : Set Y\nhf : ContinuousWithinAt f s b\nhg : ContinuousWithinAt g s b\n⊢ ContinuousWithinAt (fun x => HVAdd.hVAdd (f x) (g x)) s b","decl":"@[to_additive]\ntheorem ContinuousWithinAt.smul (hf : ContinuousWithinAt f s b) (hg : ContinuousWithinAt g s b) :\n    ContinuousWithinAt (fun x => f x • g x) s b :=\n  Filter.Tendsto.smul hf hg\n\n"}
{"name":"ContinuousAt.smul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst✝⁴ : TopologicalSpace M\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : SMul M X\ninst✝ : ContinuousSMul M X\nf : Y → M\ng : Y → X\nb : Y\nhf : ContinuousAt f b\nhg : ContinuousAt g b\n⊢ ContinuousAt (fun x => HSMul.hSMul (f x) (g x)) b","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousAt.smul (hf : ContinuousAt f b) (hg : ContinuousAt g b) :\n    ContinuousAt (fun x => f x • g x) b :=\n  Filter.Tendsto.smul hf hg\n\n"}
{"name":"ContinuousAt.vadd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst✝⁴ : TopologicalSpace M\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : VAdd M X\ninst✝ : ContinuousVAdd M X\nf : Y → M\ng : Y → X\nb : Y\nhf : ContinuousAt f b\nhg : ContinuousAt g b\n⊢ ContinuousAt (fun x => HVAdd.hVAdd (f x) (g x)) b","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousAt.smul (hf : ContinuousAt f b) (hg : ContinuousAt g b) :\n    ContinuousAt (fun x => f x • g x) b :=\n  Filter.Tendsto.smul hf hg\n\n"}
{"name":"ContinuousOn.vadd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst✝⁴ : TopologicalSpace M\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : VAdd M X\ninst✝ : ContinuousVAdd M X\nf : Y → M\ng : Y → X\ns : Set Y\nhf : ContinuousOn f s\nhg : ContinuousOn g s\n⊢ ContinuousOn (fun x => HVAdd.hVAdd (f x) (g x)) s","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousOn.smul (hf : ContinuousOn f s) (hg : ContinuousOn g s) :\n    ContinuousOn (fun x => f x • g x) s := fun x hx => (hf x hx).smul (hg x hx)\n\n"}
{"name":"ContinuousOn.smul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst✝⁴ : TopologicalSpace M\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : SMul M X\ninst✝ : ContinuousSMul M X\nf : Y → M\ng : Y → X\ns : Set Y\nhf : ContinuousOn f s\nhg : ContinuousOn g s\n⊢ ContinuousOn (fun x => HSMul.hSMul (f x) (g x)) s","decl":"@[to_additive (attr := fun_prop)]\ntheorem ContinuousOn.smul (hf : ContinuousOn f s) (hg : ContinuousOn g s) :\n    ContinuousOn (fun x => f x • g x) s := fun x hx => (hf x hx).smul (hg x hx)\n\n"}
{"name":"Continuous.smul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst✝⁴ : TopologicalSpace M\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : SMul M X\ninst✝ : ContinuousSMul M X\nf : Y → M\ng : Y → X\nhf : Continuous f\nhg : Continuous g\n⊢ Continuous fun x => HSMul.hSMul (f x) (g x)","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem Continuous.smul (hf : Continuous f) (hg : Continuous g) : Continuous fun x => f x • g x :=\n  continuous_smul.comp (hf.prod_mk hg)\n\n"}
{"name":"Continuous.vadd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst✝⁴ : TopologicalSpace M\ninst✝³ : TopologicalSpace X\ninst✝² : TopologicalSpace Y\ninst✝¹ : VAdd M X\ninst✝ : ContinuousVAdd M X\nf : Y → M\ng : Y → X\nhf : Continuous f\nhg : Continuous g\n⊢ Continuous fun x => HVAdd.hVAdd (f x) (g x)","decl":"@[to_additive (attr := continuity, fun_prop)]\ntheorem Continuous.smul (hf : Continuous f) (hg : Continuous g) : Continuous fun x => f x • g x :=\n  continuous_smul.comp (hf.prod_mk hg)\n\n"}
{"name":"ContinuousSMul.op","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝⁴ : TopologicalSpace M\ninst✝³ : TopologicalSpace X\ninst✝² : SMul M X\ninst✝¹ : SMul (MulOpposite M) X\ninst✝ : IsCentralScalar M X\n⊢ ContinuousSMul (MulOpposite M) X","decl":"/-- If a scalar action is central, then its right action is continuous when its left action is. -/\n@[to_additive \"If an additive action is central, then its right action is continuous when its left\naction is.\"]\ninstance ContinuousSMul.op [SMul Mᵐᵒᵖ X] [IsCentralScalar M X] : ContinuousSMul Mᵐᵒᵖ X :=\n  ⟨by\n    suffices Continuous fun p : M × X => MulOpposite.op p.fst • p.snd from\n      this.comp (MulOpposite.continuous_unop.prodMap continuous_id)\n    simpa only [op_smul_eq_smul] using (continuous_smul : Continuous fun p : M × X => _)⟩\n\n"}
{"name":"ContinuousVAdd.op","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝⁴ : TopologicalSpace M\ninst✝³ : TopologicalSpace X\ninst✝² : VAdd M X\ninst✝¹ : VAdd (AddOpposite M) X\ninst✝ : IsCentralVAdd M X\n⊢ ContinuousVAdd (AddOpposite M) X","decl":"/-- If a scalar action is central, then its right action is continuous when its left action is. -/\n@[to_additive \"If an additive action is central, then its right action is continuous when its left\naction is.\"]\ninstance ContinuousSMul.op [SMul Mᵐᵒᵖ X] [IsCentralScalar M X] : ContinuousSMul Mᵐᵒᵖ X :=\n  ⟨by\n    suffices Continuous fun p : M × X => MulOpposite.op p.fst • p.snd from\n      this.comp (MulOpposite.continuous_unop.prodMap continuous_id)\n    simpa only [op_smul_eq_smul] using (continuous_smul : Continuous fun p : M × X => _)⟩\n\n"}
{"name":"AddOpposite.continuousVAdd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace X\ninst✝¹ : VAdd M X\ninst✝ : ContinuousVAdd M X\n⊢ ContinuousVAdd M (AddOpposite X)","decl":"@[to_additive]\ninstance MulOpposite.continuousSMul : ContinuousSMul M Xᵐᵒᵖ :=\n  ⟨MulOpposite.continuous_op.comp <|\n      continuous_smul.comp <| continuous_id.prodMap MulOpposite.continuous_unop⟩\n\n"}
{"name":"MulOpposite.continuousSMul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace X\ninst✝¹ : SMul M X\ninst✝ : ContinuousSMul M X\n⊢ ContinuousSMul M (MulOpposite X)","decl":"@[to_additive]\ninstance MulOpposite.continuousSMul : ContinuousSMul M Xᵐᵒᵖ :=\n  ⟨MulOpposite.continuous_op.comp <|\n      continuous_smul.comp <| continuous_id.prodMap MulOpposite.continuous_unop⟩\n\n"}
{"name":"Specializes.vadd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace X\ninst✝¹ : VAdd M X\ninst✝ : ContinuousVAdd M X\na b : M\nx y : X\nh₁ : Specializes a b\nh₂ : Specializes x y\n⊢ Specializes (HVAdd.hVAdd a x) (HVAdd.hVAdd b y)","decl":"@[to_additive]\nprotected theorem Specializes.smul {a b : M} {x y : X} (h₁ : a ⤳ b) (h₂ : x ⤳ y) :\n    (a • x) ⤳ (b • y) :=\n  (h₁.prod h₂).map continuous_smul\n\n"}
{"name":"Specializes.smul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace X\ninst✝¹ : SMul M X\ninst✝ : ContinuousSMul M X\na b : M\nx y : X\nh₁ : Specializes a b\nh₂ : Specializes x y\n⊢ Specializes (HSMul.hSMul a x) (HSMul.hSMul b y)","decl":"@[to_additive]\nprotected theorem Specializes.smul {a b : M} {x y : X} (h₁ : a ⤳ b) (h₂ : x ⤳ y) :\n    (a • x) ⤳ (b • y) :=\n  (h₁.prod h₂).map continuous_smul\n\n"}
{"name":"Inseparable.smul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace X\ninst✝¹ : SMul M X\ninst✝ : ContinuousSMul M X\na b : M\nx y : X\nh₁ : Inseparable a b\nh₂ : Inseparable x y\n⊢ Inseparable (HSMul.hSMul a x) (HSMul.hSMul b y)","decl":"@[to_additive]\nprotected theorem Inseparable.smul {a b : M} {x y : X} (h₁ : Inseparable a b)\n    (h₂ : Inseparable x y) : Inseparable (a • x) (b • y) :=\n  (h₁.prod h₂).map continuous_smul\n\n"}
{"name":"Inseparable.vadd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace X\ninst✝¹ : VAdd M X\ninst✝ : ContinuousVAdd M X\na b : M\nx y : X\nh₁ : Inseparable a b\nh₂ : Inseparable x y\n⊢ Inseparable (HVAdd.hVAdd a x) (HVAdd.hVAdd b y)","decl":"@[to_additive]\nprotected theorem Inseparable.smul {a b : M} {x y : X} (h₁ : Inseparable a b)\n    (h₂ : Inseparable x y) : Inseparable (a • x) (b • y) :=\n  (h₁.prod h₂).map continuous_smul\n\n"}
{"name":"IsCompact.smul_set","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace X\ninst✝¹ : SMul M X\ninst✝ : ContinuousSMul M X\nk : Set M\nu : Set X\nhk : IsCompact k\nhu : IsCompact u\n⊢ IsCompact (HSMul.hSMul k u)","decl":"@[to_additive]\nlemma IsCompact.smul_set {k : Set M} {u : Set X} (hk : IsCompact k) (hu : IsCompact u) :\n    IsCompact (k • u) := by\n  rw [← Set.image_smul_prod]\n  exact IsCompact.image (hk.prod hu) continuous_smul\n\n"}
{"name":"IsCompact.vadd_set","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace X\ninst✝¹ : VAdd M X\ninst✝ : ContinuousVAdd M X\nk : Set M\nu : Set X\nhk : IsCompact k\nhu : IsCompact u\n⊢ IsCompact (HVAdd.hVAdd k u)","decl":"@[to_additive]\nlemma IsCompact.smul_set {k : Set M} {u : Set X} (hk : IsCompact k) (hu : IsCompact u) :\n    IsCompact (k • u) := by\n  rw [← Set.image_smul_prod]\n  exact IsCompact.image (hk.prod hu) continuous_smul\n\n"}
{"name":"vadd_set_closure_subset","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace X\ninst✝¹ : VAdd M X\ninst✝ : ContinuousVAdd M X\nK : Set M\nL : Set X\n⊢ HasSubset.Subset (HVAdd.hVAdd (closure K) (closure L)) (closure (HVAdd.hVAdd K L))","decl":"@[to_additive]\nlemma smul_set_closure_subset (K : Set M) (L : Set X) :\n    closure K • closure L ⊆ closure (K • L) :=\n  Set.smul_subset_iff.2 fun _x hx _y hy ↦ map_mem_closure₂ continuous_smul hx hy fun _a ha _b hb ↦\n    Set.smul_mem_smul ha hb\n\n"}
{"name":"smul_set_closure_subset","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝³ : TopologicalSpace M\ninst✝² : TopologicalSpace X\ninst✝¹ : SMul M X\ninst✝ : ContinuousSMul M X\nK : Set M\nL : Set X\n⊢ HasSubset.Subset (HSMul.hSMul (closure K) (closure L)) (closure (HSMul.hSMul K L))","decl":"@[to_additive]\nlemma smul_set_closure_subset (K : Set M) (L : Set X) :\n    closure K • closure L ⊆ closure (K • L) :=\n  Set.smul_subset_iff.2 fun _x hx _y hy ↦ map_mem_closure₂ continuous_smul hx hy fun _a ha _b hb ↦\n    Set.smul_mem_smul ha hb\n\n"}
{"name":"Topology.IsInducing.continuousSMul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : TopologicalSpace Y\ninst✝³ : SMul M X\ninst✝² : ContinuousSMul M X\ng : Y → X\nN : Type u_5\ninst✝¹ : SMul N Y\ninst✝ : TopologicalSpace N\nf : N → M\nhg : Topology.IsInducing g\nhf : Continuous f\nhsmul : ∀ {c : N} {x : Y}, Eq (g (HSMul.hSMul c x)) (HSMul.hSMul (f c) (g x))\n⊢ ContinuousSMul N Y","decl":"/-- Suppose that `N` acts on `X` and `M` continuously acts on `Y`.\nSuppose that `g : Y → X` is an action homomorphism in the following sense:\nthere exists a continuous function `f : N → M` such that `g (c • x) = f c • g x`.\nThen the action of `N` on `X` is continuous as well.\n\nIn many cases, `f = id` so that `g` is an action homomorphism in the sense of `MulActionHom`.\nHowever, this version also works for semilinear maps and `f = Units.val`. -/\n@[to_additive\n  \"Suppose that `N` additively acts on `X` and `M` continuously additively acts on `Y`.\nSuppose that `g : Y → X` is an additive action homomorphism in the following sense:\nthere exists a continuous function `f : N → M` such that `g (c +ᵥ x) = f c +ᵥ g x`.\nThen the action of `N` on `X` is continuous as well.\n\nIn many cases, `f = id` so that `g` is an action homomorphism in the sense of `AddActionHom`.\nHowever, this version also works for `f = AddUnits.val`.\"]\nlemma Topology.IsInducing.continuousSMul {N : Type*} [SMul N Y] [TopologicalSpace N] {f : N → M}\n    (hg : IsInducing g) (hf : Continuous f) (hsmul : ∀ {c x}, g (c • x) = f c • g x) :\n    ContinuousSMul N Y where\n  continuous_smul := by\n    simpa only [hg.continuous_iff, Function.comp_def, hsmul]\n      using (hf.comp continuous_fst).smul <| hg.continuous.comp continuous_snd\n\n"}
{"name":"Topology.IsInducing.continuousVAdd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : TopologicalSpace Y\ninst✝³ : VAdd M X\ninst✝² : ContinuousVAdd M X\ng : Y → X\nN : Type u_5\ninst✝¹ : VAdd N Y\ninst✝ : TopologicalSpace N\nf : N → M\nhg : Topology.IsInducing g\nhf : Continuous f\nhsmul : ∀ {c : N} {x : Y}, Eq (g (HVAdd.hVAdd c x)) (HVAdd.hVAdd (f c) (g x))\n⊢ ContinuousVAdd N Y","decl":"/-- Suppose that `N` acts on `X` and `M` continuously acts on `Y`.\nSuppose that `g : Y → X` is an action homomorphism in the following sense:\nthere exists a continuous function `f : N → M` such that `g (c • x) = f c • g x`.\nThen the action of `N` on `X` is continuous as well.\n\nIn many cases, `f = id` so that `g` is an action homomorphism in the sense of `MulActionHom`.\nHowever, this version also works for semilinear maps and `f = Units.val`. -/\n@[to_additive\n  \"Suppose that `N` additively acts on `X` and `M` continuously additively acts on `Y`.\nSuppose that `g : Y → X` is an additive action homomorphism in the following sense:\nthere exists a continuous function `f : N → M` such that `g (c +ᵥ x) = f c +ᵥ g x`.\nThen the action of `N` on `X` is continuous as well.\n\nIn many cases, `f = id` so that `g` is an action homomorphism in the sense of `AddActionHom`.\nHowever, this version also works for `f = AddUnits.val`.\"]\nlemma Topology.IsInducing.continuousSMul {N : Type*} [SMul N Y] [TopologicalSpace N] {f : N → M}\n    (hg : IsInducing g) (hf : Continuous f) (hsmul : ∀ {c x}, g (c • x) = f c • g x) :\n    ContinuousSMul N Y where\n  continuous_smul := by\n    simpa only [hg.continuous_iff, Function.comp_def, hsmul]\n      using (hf.comp continuous_fst).smul <| hg.continuous.comp continuous_snd\n\n"}
{"name":"Inducing.continuousSMul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : TopologicalSpace Y\ninst✝³ : SMul M X\ninst✝² : ContinuousSMul M X\ng : Y → X\nN : Type u_5\ninst✝¹ : SMul N Y\ninst✝ : TopologicalSpace N\nf : N → M\nhg : Topology.IsInducing g\nhf : Continuous f\nhsmul : ∀ {c : N} {x : Y}, Eq (g (HSMul.hSMul c x)) (HSMul.hSMul (f c) (g x))\n⊢ ContinuousSMul N Y","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.continuousSMul := IsInducing.continuousSMul\n\n"}
{"name":"SMulMemClass.continuousSMul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : TopologicalSpace X\ninst✝³ : SMul M X\ninst✝² : ContinuousSMul M X\nS : Type u_5\ninst✝¹ : SetLike S X\ninst✝ : SMulMemClass S M X\ns : S\n⊢ ContinuousSMul M (Subtype fun x => Membership.mem s x)","decl":"@[to_additive]\ninstance SMulMemClass.continuousSMul {S : Type*} [SetLike S X] [SMulMemClass S M X] (s : S) :\n    ContinuousSMul M s :=\n  IsInducing.subtypeVal.continuousSMul continuous_id rfl\n\n"}
{"name":"VAddMemClass.continuousVAdd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : TopologicalSpace X\ninst✝³ : VAdd M X\ninst✝² : ContinuousVAdd M X\nS : Type u_5\ninst✝¹ : SetLike S X\ninst✝ : VAddMemClass S M X\ns : S\n⊢ ContinuousVAdd M (Subtype fun x => Membership.mem s x)","decl":"@[to_additive]\ninstance SMulMemClass.continuousSMul {S : Type*} [SetLike S X] [SMulMemClass S M X] (s : S) :\n    ContinuousSMul M s :=\n  IsInducing.subtypeVal.continuousSMul continuous_id rfl\n\n"}
{"name":"Units.continuousSMul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝⁴ : TopologicalSpace M\ninst✝³ : TopologicalSpace X\ninst✝² : Monoid M\ninst✝¹ : MulAction M X\ninst✝ : ContinuousSMul M X\n⊢ ContinuousSMul (Units M) X","decl":"@[to_additive]\ninstance Units.continuousSMul : ContinuousSMul Mˣ X :=\n  IsInducing.id.continuousSMul Units.continuous_val rfl\n\n"}
{"name":"AddUnits.continuousVAdd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝⁴ : TopologicalSpace M\ninst✝³ : TopologicalSpace X\ninst✝² : AddMonoid M\ninst✝¹ : AddAction M X\ninst✝ : ContinuousVAdd M X\n⊢ ContinuousVAdd (AddUnits M) X","decl":"@[to_additive]\ninstance Units.continuousSMul : ContinuousSMul Mˣ X :=\n  IsInducing.id.continuousSMul Units.continuous_val rfl\n\n"}
{"name":"AddAction.continuousVAdd_compHom","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : AddMonoid M\ninst✝³ : AddAction M X\ninst✝² : ContinuousVAdd M X\nN : Type u_5\ninst✝¹ : TopologicalSpace N\ninst✝ : AddMonoid N\nf : AddMonoidHom N M\nhf : Continuous ⇑f\n⊢ ContinuousVAdd N X","decl":"/-- If an action is continuous, then composing this action with a continuous homomorphism gives\nagain a continuous action. -/\n@[to_additive]\ntheorem MulAction.continuousSMul_compHom\n    {N : Type*} [TopologicalSpace N] [Monoid N] {f : N →* M} (hf : Continuous f) :\n    letI : MulAction N X := MulAction.compHom _ f\n    ContinuousSMul N X := by\n  let _ : MulAction N X := MulAction.compHom _ f\n  exact ⟨(hf.comp continuous_fst).smul continuous_snd⟩\n\n"}
{"name":"MulAction.continuousSMul_compHom","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : Monoid M\ninst✝³ : MulAction M X\ninst✝² : ContinuousSMul M X\nN : Type u_5\ninst✝¹ : TopologicalSpace N\ninst✝ : Monoid N\nf : MonoidHom N M\nhf : Continuous ⇑f\n⊢ ContinuousSMul N X","decl":"/-- If an action is continuous, then composing this action with a continuous homomorphism gives\nagain a continuous action. -/\n@[to_additive]\ntheorem MulAction.continuousSMul_compHom\n    {N : Type*} [TopologicalSpace N] [Monoid N] {f : N →* M} (hf : Continuous f) :\n    letI : MulAction N X := MulAction.compHom _ f\n    ContinuousSMul N X := by\n  let _ : MulAction N X := MulAction.compHom _ f\n  exact ⟨(hf.comp continuous_fst).smul continuous_snd⟩\n\n"}
{"name":"Submonoid.continuousSMul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝⁴ : TopologicalSpace M\ninst✝³ : TopologicalSpace X\ninst✝² : Monoid M\ninst✝¹ : MulAction M X\ninst✝ : ContinuousSMul M X\nS : Submonoid M\n⊢ ContinuousSMul (Subtype fun x => Membership.mem S x) X","decl":"@[to_additive]\ninstance Submonoid.continuousSMul {S : Submonoid M} : ContinuousSMul S X :=\n  IsInducing.id.continuousSMul continuous_subtype_val rfl\n\n"}
{"name":"AddSubmonoid.continuousVAdd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝⁴ : TopologicalSpace M\ninst✝³ : TopologicalSpace X\ninst✝² : AddMonoid M\ninst✝¹ : AddAction M X\ninst✝ : ContinuousVAdd M X\nS : AddSubmonoid M\n⊢ ContinuousVAdd (Subtype fun x => Membership.mem S x) X","decl":"@[to_additive]\ninstance Submonoid.continuousSMul {S : Submonoid M} : ContinuousSMul S X :=\n  IsInducing.id.continuousSMul continuous_subtype_val rfl\n\n"}
{"name":"AddSubgroup.continuousVAdd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝⁴ : TopologicalSpace M\ninst✝³ : TopologicalSpace X\ninst✝² : AddGroup M\ninst✝¹ : AddAction M X\ninst✝ : ContinuousVAdd M X\nS : AddSubgroup M\n⊢ ContinuousVAdd (Subtype fun x => Membership.mem S x) X","decl":"@[to_additive]\ninstance Subgroup.continuousSMul {S : Subgroup M} : ContinuousSMul S X :=\n  S.toSubmonoid.continuousSMul\n\n"}
{"name":"Subgroup.continuousSMul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝⁴ : TopologicalSpace M\ninst✝³ : TopologicalSpace X\ninst✝² : Group M\ninst✝¹ : MulAction M X\ninst✝ : ContinuousSMul M X\nS : Subgroup M\n⊢ ContinuousSMul (Subtype fun x => Membership.mem S x) X","decl":"@[to_additive]\ninstance Subgroup.continuousSMul {S : Subgroup M} : ContinuousSMul S X :=\n  S.toSubmonoid.continuousSMul\n\n"}
{"name":"stabilizer_isOpen","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : TopologicalSpace X\ninst✝³ : Group M\ninst✝² : MulAction M X\ninst✝¹ : ContinuousSMul M X\ninst✝ : DiscreteTopology X\nx : X\n⊢ IsOpen ↑(MulAction.stabilizer M x)","decl":"/-- The stabilizer of a continuous group action on a discrete space is an open subgroup. -/\nlemma stabilizer_isOpen [DiscreteTopology X] (x : X) : IsOpen (MulAction.stabilizer M x : Set M) :=\n  IsOpen.preimage (f := fun g ↦ g • x) (by fun_prop) (isOpen_discrete {x})\n\n"}
{"name":"Prod.continuousVAdd","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : TopologicalSpace Y\ninst✝³ : VAdd M X\ninst✝² : VAdd M Y\ninst✝¹ : ContinuousVAdd M X\ninst✝ : ContinuousVAdd M Y\n⊢ ContinuousVAdd M (Prod X Y)","decl":"@[to_additive]\ninstance Prod.continuousSMul [SMul M X] [SMul M Y] [ContinuousSMul M X] [ContinuousSMul M Y] :\n    ContinuousSMul M (X × Y) :=\n  ⟨(continuous_fst.smul (continuous_fst.comp continuous_snd)).prod_mk\n      (continuous_fst.smul (continuous_snd.comp continuous_snd))⟩\n\n"}
{"name":"Prod.continuousSMul","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\nX : Type u_2\nY : Type u_3\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : TopologicalSpace X\ninst✝⁴ : TopologicalSpace Y\ninst✝³ : SMul M X\ninst✝² : SMul M Y\ninst✝¹ : ContinuousSMul M X\ninst✝ : ContinuousSMul M Y\n⊢ ContinuousSMul M (Prod X Y)","decl":"@[to_additive]\ninstance Prod.continuousSMul [SMul M X] [SMul M Y] [ContinuousSMul M X] [ContinuousSMul M Y] :\n    ContinuousSMul M (X × Y) :=\n  ⟨(continuous_fst.smul (continuous_fst.comp continuous_snd)).prod_mk\n      (continuous_fst.smul (continuous_snd.comp continuous_snd))⟩\n\n"}
{"name":"instContinuousSMulForall","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\ninst✝³ : TopologicalSpace M\nι : Type u_5\nγ : ι → Type u_6\ninst✝² : (i : ι) → TopologicalSpace (γ i)\ninst✝¹ : (i : ι) → SMul M (γ i)\ninst✝ : ∀ (i : ι), ContinuousSMul M (γ i)\n⊢ ContinuousSMul M ((i : ι) → γ i)","decl":"@[to_additive]\ninstance {ι : Type*} {γ : ι → Type*} [∀ i, TopologicalSpace (γ i)] [∀ i, SMul M (γ i)]\n    [∀ i, ContinuousSMul M (γ i)] : ContinuousSMul M (∀ i, γ i) :=\n  ⟨continuous_pi fun i =>\n      (continuous_fst.smul continuous_snd).comp <|\n        continuous_fst.prod_mk ((continuous_apply i).comp continuous_snd)⟩\n\n"}
{"name":"instContinuousVAddForall","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_1\ninst✝³ : TopologicalSpace M\nι : Type u_5\nγ : ι → Type u_6\ninst✝² : (i : ι) → TopologicalSpace (γ i)\ninst✝¹ : (i : ι) → VAdd M (γ i)\ninst✝ : ∀ (i : ι), ContinuousVAdd M (γ i)\n⊢ ContinuousVAdd M ((i : ι) → γ i)","decl":"@[to_additive]\ninstance {ι : Type*} {γ : ι → Type*} [∀ i, TopologicalSpace (γ i)] [∀ i, SMul M (γ i)]\n    [∀ i, ContinuousSMul M (γ i)] : ContinuousSMul M (∀ i, γ i) :=\n  ⟨continuous_pi fun i =>\n      (continuous_fst.smul continuous_snd).comp <|\n        continuous_fst.prod_mk ((continuous_apply i).comp continuous_snd)⟩\n\n"}
{"name":"continuousSMul_sInf","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_2\nX : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : SMul M X\nts : Set (TopologicalSpace X)\nh : ∀ (t : TopologicalSpace X), Membership.mem ts t → ContinuousSMul M X\n⊢ ContinuousSMul M X","decl":"@[to_additive]\ntheorem continuousSMul_sInf {ts : Set (TopologicalSpace X)}\n    (h : ∀ t ∈ ts, @ContinuousSMul M X _ _ t) : @ContinuousSMul M X _ _ (sInf ts) :=\n  -- Porting note: {} doesn't work because `sInf ts` isn't found by TC search. `(_)` finds it by\n  -- unification instead.\n  @ContinuousSMul.mk M X _ _ (_) <| by\n      -- Porting note: needs `( :)`\n      rw [← (@sInf_singleton _ _ ‹TopologicalSpace M›:)]\n      exact\n        continuous_sInf_rng.2 fun t ht =>\n          continuous_sInf_dom₂ (Eq.refl _) ht\n            (@ContinuousSMul.continuous_smul _ _ _ _ t (h t ht))\n\n"}
{"name":"continuousVAdd_sInf","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_2\nX : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : VAdd M X\nts : Set (TopologicalSpace X)\nh : ∀ (t : TopologicalSpace X), Membership.mem ts t → ContinuousVAdd M X\n⊢ ContinuousVAdd M X","decl":"@[to_additive]\ntheorem continuousSMul_sInf {ts : Set (TopologicalSpace X)}\n    (h : ∀ t ∈ ts, @ContinuousSMul M X _ _ t) : @ContinuousSMul M X _ _ (sInf ts) :=\n  -- Porting note: {} doesn't work because `sInf ts` isn't found by TC search. `(_)` finds it by\n  -- unification instead.\n  @ContinuousSMul.mk M X _ _ (_) <| by\n      -- Porting note: needs `( :)`\n      rw [← (@sInf_singleton _ _ ‹TopologicalSpace M›:)]\n      exact\n        continuous_sInf_rng.2 fun t ht =>\n          continuous_sInf_dom₂ (Eq.refl _) ht\n            (@ContinuousSMul.continuous_smul _ _ _ _ t (h t ht))\n\n"}
{"name":"continuousSMul_iInf","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"ι : Sort u_1\nM : Type u_2\nX : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : SMul M X\nts' : ι → TopologicalSpace X\nh : ∀ (i : ι), ContinuousSMul M X\n⊢ ContinuousSMul M X","decl":"@[to_additive]\ntheorem continuousSMul_iInf {ts' : ι → TopologicalSpace X}\n    (h : ∀ i, @ContinuousSMul M X _ _ (ts' i)) : @ContinuousSMul M X _ _ (⨅ i, ts' i) :=\n  continuousSMul_sInf <| Set.forall_mem_range.mpr h\n\n"}
{"name":"continuousVAdd_iInf","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"ι : Sort u_1\nM : Type u_2\nX : Type u_3\ninst✝¹ : TopologicalSpace M\ninst✝ : VAdd M X\nts' : ι → TopologicalSpace X\nh : ∀ (i : ι), ContinuousVAdd M X\n⊢ ContinuousVAdd M X","decl":"@[to_additive]\ntheorem continuousSMul_iInf {ts' : ι → TopologicalSpace X}\n    (h : ∀ i, @ContinuousSMul M X _ _ (ts' i)) : @ContinuousSMul M X _ _ (⨅ i, ts' i) :=\n  continuousSMul_sInf <| Set.forall_mem_range.mpr h\n\n"}
{"name":"continuousVAdd_inf","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_2\nX : Type u_3\ninst✝³ : TopologicalSpace M\ninst✝² : VAdd M X\nt₁ t₂ : TopologicalSpace X\ninst✝¹ : ContinuousVAdd M X\ninst✝ : ContinuousVAdd M X\n⊢ ContinuousVAdd M X","decl":"@[to_additive]\ntheorem continuousSMul_inf {t₁ t₂ : TopologicalSpace X} [@ContinuousSMul M X _ _ t₁]\n    [@ContinuousSMul M X _ _ t₂] : @ContinuousSMul M X _ _ (t₁ ⊓ t₂) := by\n  rw [inf_eq_iInf]\n  refine continuousSMul_iInf fun b => ?_\n  cases b <;> assumption\n\n"}
{"name":"continuousSMul_inf","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"M : Type u_2\nX : Type u_3\ninst✝³ : TopologicalSpace M\ninst✝² : SMul M X\nt₁ t₂ : TopologicalSpace X\ninst✝¹ : ContinuousSMul M X\ninst✝ : ContinuousSMul M X\n⊢ ContinuousSMul M X","decl":"@[to_additive]\ntheorem continuousSMul_inf {t₁ t₂ : TopologicalSpace X} [@ContinuousSMul M X _ _ t₁]\n    [@ContinuousSMul M X _ _ t₂] : @ContinuousSMul M X _ _ (t₁ ⊓ t₂) := by\n  rw [inf_eq_iInf]\n  refine continuousSMul_iInf fun b => ?_\n  cases b <;> assumption\n\n"}
{"name":"AddTorsor.connectedSpace","module":"Mathlib.Topology.Algebra.MulAction","initialProofState":"G : Type u_1\nP : Type u_2\ninst✝⁵ : AddGroup G\ninst✝⁴ : AddTorsor G P\ninst✝³ : TopologicalSpace G\ninst✝² : PreconnectedSpace G\ninst✝¹ : TopologicalSpace P\ninst✝ : ContinuousVAdd G P\n⊢ ConnectedSpace P","decl":"include G in\n/-- An `AddTorsor` for a connected space is a connected space. This is not an instance because\nit loops for a group as a torsor over itself. -/\nprotected theorem AddTorsor.connectedSpace : ConnectedSpace P :=\n  { isPreconnected_univ := by\n      convert\n        isPreconnected_univ.image (Equiv.vaddConst (Classical.arbitrary P) : G → P)\n          (continuous_id.vadd continuous_const).continuousOn\n      rw [Set.image_univ, Equiv.range_eq_univ]\n    toNonempty := inferInstance }\n\n"}
