{"name":"DFunLike.coe_injective'","module":"Mathlib.Data.FunLike.Basic","initialProofState":"F : Sort u_1\nα : outParam (Sort u_2)\nβ : outParam (α → Sort u_3)\nself : DFunLike F α β\n⊢ Function.Injective DFunLike.coe","decl":"/-- The class `DFunLike F α β` expresses that terms of type `F` have an\ninjective coercion to (dependent) functions from `α` to `β`.\n\nFor non-dependent functions you can also use the abbreviation `FunLike`.\n\nThis typeclass is used in the definition of the homomorphism typeclasses,\nsuch as `ZeroHomClass`, `MulHomClass`, `MonoidHomClass`, ....\n-/\n@[notation_class * toFun Simps.findCoercionArgs]\nclass DFunLike (F : Sort*) (α : outParam (Sort*)) (β : outParam <| α → Sort*) where\n  /-- The coercion from `F` to a function. -/\n  coe : F → ∀ a : α, β a\n  /-- The coercion to functions must be injective. -/\n  coe_injective' : Function.Injective coe\n\n-- https://github.com/leanprover/lean4/issues/2096\n"}
{"name":"DFunLike.coe_eq_coe_fn","module":"Mathlib.Data.FunLike.Basic","initialProofState":"F : Sort u_1\nα : Sort u_2\nβ : α → Sort u_3\ni : DFunLike F α β\n⊢ Eq DFunLike.coe fun f => ⇑f","decl":"theorem coe_eq_coe_fn : (DFunLike.coe (F := F)) = (fun f => ↑f) := rfl\n\n"}
{"name":"DFunLike.coe_injective","module":"Mathlib.Data.FunLike.Basic","initialProofState":"F : Sort u_1\nα : Sort u_2\nβ : α → Sort u_3\ni : DFunLike F α β\n⊢ Function.Injective fun f => ⇑f","decl":"theorem coe_injective : Function.Injective (fun f : F ↦ (f : ∀ a : α, β a)) :=\n  DFunLike.coe_injective'\n\n"}
{"name":"DFunLike.coe_fn_eq","module":"Mathlib.Data.FunLike.Basic","initialProofState":"F : Sort u_1\nα : Sort u_2\nβ : α → Sort u_3\ni : DFunLike F α β\nf g : F\n⊢ Iff (Eq ⇑f ⇑g) (Eq f g)","decl":"@[simp]\ntheorem coe_fn_eq {f g : F} : (f : ∀ a : α, β a) = (g : ∀ a : α, β a) ↔ f = g :=\n  ⟨fun h ↦ DFunLike.coe_injective' h, fun h ↦ by cases h; rfl⟩\n\n"}
{"name":"DFunLike.ext'","module":"Mathlib.Data.FunLike.Basic","initialProofState":"F : Sort u_1\nα : Sort u_2\nβ : α → Sort u_3\ni : DFunLike F α β\nf g : F\nh : Eq ⇑f ⇑g\n⊢ Eq f g","decl":"theorem ext' {f g : F} (h : (f : ∀ a : α, β a) = (g : ∀ a : α, β a)) : f = g :=\n  DFunLike.coe_injective' h\n\n"}
{"name":"DFunLike.ext'_iff","module":"Mathlib.Data.FunLike.Basic","initialProofState":"F : Sort u_1\nα : Sort u_2\nβ : α → Sort u_3\ni : DFunLike F α β\nf g : F\n⊢ Iff (Eq f g) (Eq ⇑f ⇑g)","decl":"theorem ext'_iff {f g : F} : f = g ↔ (f : ∀ a : α, β a) = (g : ∀ a : α, β a) :=\n  coe_fn_eq.symm\n\n"}
{"name":"DFunLike.ext","module":"Mathlib.Data.FunLike.Basic","initialProofState":"F : Sort u_1\nα : Sort u_2\nβ : α → Sort u_3\ni : DFunLike F α β\nf g : F\nh : ∀ (x : α), Eq (f x) (g x)\n⊢ Eq f g","decl":"theorem ext (f g : F) (h : ∀ x : α, f x = g x) : f = g :=\n  DFunLike.coe_injective' (funext h)\n\n"}
{"name":"DFunLike.ext_iff","module":"Mathlib.Data.FunLike.Basic","initialProofState":"F : Sort u_1\nα : Sort u_2\nβ : α → Sort u_3\ni : DFunLike F α β\nf g : F\n⊢ Iff (Eq f g) (∀ (x : α), Eq (f x) (g x))","decl":"theorem ext_iff {f g : F} : f = g ↔ ∀ x, f x = g x :=\n  coe_fn_eq.symm.trans funext_iff\n\n"}
{"name":"DFunLike.congr_fun","module":"Mathlib.Data.FunLike.Basic","initialProofState":"F : Sort u_1\nα : Sort u_2\nβ : α → Sort u_3\ni : DFunLike F α β\nf g : F\nh₁ : Eq f g\nx : α\n⊢ Eq (f x) (g x)","decl":"protected theorem congr_fun {f g : F} (h₁ : f = g) (x : α) : f x = g x :=\n  congr_fun (congr_arg _ h₁) x\n\n"}
{"name":"DFunLike.ne_iff","module":"Mathlib.Data.FunLike.Basic","initialProofState":"F : Sort u_1\nα : Sort u_2\nβ : α → Sort u_3\ni : DFunLike F α β\nf g : F\n⊢ Iff (Ne f g) (Exists fun a => Ne (f a) (g a))","decl":"theorem ne_iff {f g : F} : f ≠ g ↔ ∃ a, f a ≠ g a :=\n  ext_iff.not.trans not_forall\n\n"}
{"name":"DFunLike.exists_ne","module":"Mathlib.Data.FunLike.Basic","initialProofState":"F : Sort u_1\nα : Sort u_2\nβ : α → Sort u_3\ni : DFunLike F α β\nf g : F\nh : Ne f g\n⊢ Exists fun x => Ne (f x) (g x)","decl":"theorem exists_ne {f g : F} (h : f ≠ g) : ∃ x, f x ≠ g x :=\n  ne_iff.mp h\n\n"}
{"name":"DFunLike.subsingleton_cod","module":"Mathlib.Data.FunLike.Basic","initialProofState":"F : Sort u_1\nα : Sort u_2\nβ : α → Sort u_3\ni : DFunLike F α β\ninst✝ : ∀ (a : α), Subsingleton (β a)\n⊢ Subsingleton F","decl":"/-- This is not an instance to avoid slowing down every single `Subsingleton` typeclass search. -/\nlemma subsingleton_cod [∀ a, Subsingleton (β a)] : Subsingleton F :=\n  ⟨fun _ _ ↦ coe_injective <| Subsingleton.elim _ _⟩\n\n"}
{"name":"DFunLike.congr","module":"Mathlib.Data.FunLike.Basic","initialProofState":"F : Sort u_1\nα : Sort u_2\nβ : Sort u_3\ni : FunLike F α β\nf g : F\nx y : α\nh₁ : Eq f g\nh₂ : Eq x y\n⊢ Eq (f x) (g y)","decl":"protected theorem congr {f g : F} {x y : α} (h₁ : f = g) (h₂ : x = y) : f x = g y :=\n  congr (congr_arg _ h₁) h₂\n\n"}
{"name":"DFunLike.congr_arg","module":"Mathlib.Data.FunLike.Basic","initialProofState":"F : Sort u_1\nα : Sort u_2\nβ : Sort u_3\ni : FunLike F α β\nf : F\nx y : α\nh₂ : Eq x y\n⊢ Eq (f x) (f y)","decl":"protected theorem congr_arg (f : F) {x y : α} (h₂ : x = y) : f x = f y :=\n  congr_arg _ h₂\n\n"}
