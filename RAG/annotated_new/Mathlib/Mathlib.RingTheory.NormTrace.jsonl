{"name":"Algebra.norm_one_add_smul","module":"Mathlib.RingTheory.NormTrace","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝⁴ : CommRing A\ninst✝³ : CommRing B\ninst✝² : Algebra A B\ninst✝¹ : Module.Free A B\ninst✝ : Module.Finite A B\na : A\nx : B\n⊢ Exists fun r => Eq ((Algebra.norm A) (HAdd.hAdd 1 (HSMul.hSMul a x))) (HAdd.hAdd (HAdd.hAdd 1 (HMul.hMul ((Algebra.trace A B) x) a)) (HMul.hMul r (HPow.hPow a 2)))","decl":"lemma Algebra.norm_one_add_smul {A B} [CommRing A] [CommRing B] [Algebra A B]\n    [Module.Free A B] [Module.Finite A B] (a : A) (x : B) :\n    ∃ r : A, Algebra.norm A (1 + a • x) = 1 + Algebra.trace A B x * a + r * a ^ 2 := by\n  classical\n  let ι := Module.Free.ChooseBasisIndex A B\n  let b : Basis ι A B := Module.Free.chooseBasis _ _\n  haveI : Fintype ι := inferInstance\n  clear_value ι b\n  simp_rw [Algebra.norm_eq_matrix_det b, Algebra.trace_eq_matrix_trace b]\n  simp only [map_add, map_one, map_smul, Matrix.det_one_add_smul a]\n  exact ⟨_, rfl⟩\n"}
