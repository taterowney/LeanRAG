{"name":"StrictMono.apply_eq_top_iff","module":"Mathlib.Order.BoundedOrder.Monotone","initialProofState":"α : Type u\nβ : Type v\ninst✝² : PartialOrder α\ninst✝¹ : OrderTop α\ninst✝ : Preorder β\nf : α → β\na : α\nhf : StrictMono f\n⊢ Iff (Eq (f a) (f Top.top)) (Eq a Top.top)","decl":"theorem StrictMono.apply_eq_top_iff (hf : StrictMono f) : f a = f ⊤ ↔ a = ⊤ :=\n  ⟨fun h => not_lt_top_iff.1 fun ha => (hf ha).ne h, congr_arg _⟩\n\n"}
{"name":"StrictAnti.apply_eq_top_iff","module":"Mathlib.Order.BoundedOrder.Monotone","initialProofState":"α : Type u\nβ : Type v\ninst✝² : PartialOrder α\ninst✝¹ : OrderTop α\ninst✝ : Preorder β\nf : α → β\na : α\nhf : StrictAnti f\n⊢ Iff (Eq (f a) (f Top.top)) (Eq a Top.top)","decl":"theorem StrictAnti.apply_eq_top_iff (hf : StrictAnti f) : f a = f ⊤ ↔ a = ⊤ :=\n  ⟨fun h => not_lt_top_iff.1 fun ha => (hf ha).ne' h, congr_arg _⟩\n\n"}
{"name":"StrictMono.maximal_preimage_top","module":"Mathlib.Order.BoundedOrder.Monotone","initialProofState":"α : Type u\nβ : Type v\ninst✝² : LinearOrder α\ninst✝¹ : Preorder β\ninst✝ : OrderTop β\nf : α → β\nH : StrictMono f\na : α\nh_top : Eq (f a) Top.top\nx : α\n⊢ LE.le x a","decl":"theorem StrictMono.maximal_preimage_top [LinearOrder α] [Preorder β] [OrderTop β] {f : α → β}\n    (H : StrictMono f) {a} (h_top : f a = ⊤) (x : α) : x ≤ a :=\n  H.maximal_of_maximal_image\n    (fun p => by\n      rw [h_top]\n      exact le_top)\n    x\n\n"}
{"name":"StrictMono.apply_eq_bot_iff","module":"Mathlib.Order.BoundedOrder.Monotone","initialProofState":"α : Type u\nβ : Type v\ninst✝² : PartialOrder α\ninst✝¹ : OrderBot α\ninst✝ : Preorder β\nf : α → β\na : α\nhf : StrictMono f\n⊢ Iff (Eq (f a) (f Bot.bot)) (Eq a Bot.bot)","decl":"theorem StrictMono.apply_eq_bot_iff (hf : StrictMono f) : f a = f ⊥ ↔ a = ⊥ :=\n  hf.dual.apply_eq_top_iff\n\n"}
{"name":"StrictAnti.apply_eq_bot_iff","module":"Mathlib.Order.BoundedOrder.Monotone","initialProofState":"α : Type u\nβ : Type v\ninst✝² : PartialOrder α\ninst✝¹ : OrderBot α\ninst✝ : Preorder β\nf : α → β\na : α\nhf : StrictAnti f\n⊢ Iff (Eq (f a) (f Bot.bot)) (Eq a Bot.bot)","decl":"theorem StrictAnti.apply_eq_bot_iff (hf : StrictAnti f) : f a = f ⊥ ↔ a = ⊥ :=\n  hf.dual.apply_eq_top_iff\n\n"}
{"name":"StrictMono.minimal_preimage_bot","module":"Mathlib.Order.BoundedOrder.Monotone","initialProofState":"α : Type u\nβ : Type v\ninst✝² : LinearOrder α\ninst✝¹ : PartialOrder β\ninst✝ : OrderBot β\nf : α → β\nH : StrictMono f\na : α\nh_bot : Eq (f a) Bot.bot\nx : α\n⊢ LE.le a x","decl":"theorem StrictMono.minimal_preimage_bot [LinearOrder α] [PartialOrder β] [OrderBot β] {f : α → β}\n    (H : StrictMono f) {a} (h_bot : f a = ⊥) (x : α) : a ≤ x :=\n  H.minimal_of_minimal_image\n    (fun p => by\n      rw [h_bot]\n      exact bot_le)\n    x\n\n"}
{"name":"monotone_and","module":"Mathlib.Order.BoundedOrder.Monotone","initialProofState":"α : Type u\ninst✝ : Preorder α\np q : α → Prop\nm_p : Monotone p\nm_q : Monotone q\n⊢ Monotone fun x => And (p x) (q x)","decl":"theorem monotone_and {p q : α → Prop} (m_p : Monotone p) (m_q : Monotone q) :\n    Monotone fun x => p x ∧ q x :=\n  fun _ _ h => And.imp (m_p h) (m_q h)\n\n-- Note: by finish [monotone] doesn't work\n"}
{"name":"monotone_or","module":"Mathlib.Order.BoundedOrder.Monotone","initialProofState":"α : Type u\ninst✝ : Preorder α\np q : α → Prop\nm_p : Monotone p\nm_q : Monotone q\n⊢ Monotone fun x => Or (p x) (q x)","decl":"theorem monotone_or {p q : α → Prop} (m_p : Monotone p) (m_q : Monotone q) :\n    Monotone fun x => p x ∨ q x :=\n  fun _ _ h => Or.imp (m_p h) (m_q h)\n\n"}
{"name":"monotone_le","module":"Mathlib.Order.BoundedOrder.Monotone","initialProofState":"α : Type u\ninst✝ : Preorder α\nx : α\n⊢ Monotone fun x_1 => LE.le x x_1","decl":"theorem monotone_le {x : α} : Monotone (x ≤ ·) := fun _ _ h' h => h.trans h'\n\n"}
{"name":"monotone_lt","module":"Mathlib.Order.BoundedOrder.Monotone","initialProofState":"α : Type u\ninst✝ : Preorder α\nx : α\n⊢ Monotone fun x_1 => LT.lt x x_1","decl":"theorem monotone_lt {x : α} : Monotone (x < ·) := fun _ _ h' h => h.trans_le h'\n\n"}
{"name":"antitone_le","module":"Mathlib.Order.BoundedOrder.Monotone","initialProofState":"α : Type u\ninst✝ : Preorder α\nx : α\n⊢ Antitone fun x_1 => LE.le x_1 x","decl":"theorem antitone_le {x : α} : Antitone (· ≤ x) := fun _ _ h' h => h'.trans h\n\n"}
{"name":"antitone_lt","module":"Mathlib.Order.BoundedOrder.Monotone","initialProofState":"α : Type u\ninst✝ : Preorder α\nx : α\n⊢ Antitone fun x_1 => LT.lt x_1 x","decl":"theorem antitone_lt {x : α} : Antitone (· < x) := fun _ _ h' h => h'.trans_lt h\n\n"}
{"name":"Monotone.forall","module":"Mathlib.Order.BoundedOrder.Monotone","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder α\nP : β → α → Prop\nhP : ∀ (x : β), Monotone (P x)\n⊢ Monotone fun y => ∀ (x : β), P x y","decl":"theorem Monotone.forall {P : β → α → Prop} (hP : ∀ x, Monotone (P x)) :\n    Monotone fun y => ∀ x, P x y :=\n  fun _ _ hy h x => hP x hy <| h x\n\n"}
{"name":"Antitone.forall","module":"Mathlib.Order.BoundedOrder.Monotone","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder α\nP : β → α → Prop\nhP : ∀ (x : β), Antitone (P x)\n⊢ Antitone fun y => ∀ (x : β), P x y","decl":"theorem Antitone.forall {P : β → α → Prop} (hP : ∀ x, Antitone (P x)) :\n    Antitone fun y => ∀ x, P x y :=\n  fun _ _ hy h x => hP x hy (h x)\n\n"}
{"name":"Monotone.ball","module":"Mathlib.Order.BoundedOrder.Monotone","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder α\nP : β → α → Prop\ns : Set β\nhP : ∀ (x : β), Membership.mem s x → Monotone (P x)\n⊢ Monotone fun y => ∀ (x : β), Membership.mem s x → P x y","decl":"theorem Monotone.ball {P : β → α → Prop} {s : Set β} (hP : ∀ x ∈ s, Monotone (P x)) :\n    Monotone fun y => ∀ x ∈ s, P x y := fun _ _ hy h x hx => hP x hx hy (h x hx)\n\n"}
{"name":"Antitone.ball","module":"Mathlib.Order.BoundedOrder.Monotone","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder α\nP : β → α → Prop\ns : Set β\nhP : ∀ (x : β), Membership.mem s x → Antitone (P x)\n⊢ Antitone fun y => ∀ (x : β), Membership.mem s x → P x y","decl":"theorem Antitone.ball {P : β → α → Prop} {s : Set β} (hP : ∀ x ∈ s, Antitone (P x)) :\n    Antitone fun y => ∀ x ∈ s, P x y := fun _ _ hy h x hx => hP x hx hy (h x hx)\n\n"}
{"name":"Monotone.exists","module":"Mathlib.Order.BoundedOrder.Monotone","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder α\nP : β → α → Prop\nhP : ∀ (x : β), Monotone (P x)\n⊢ Monotone fun y => Exists fun x => P x y","decl":"theorem Monotone.exists {P : β → α → Prop} (hP : ∀ x, Monotone (P x)) :\n    Monotone fun y => ∃ x, P x y :=\n  fun _ _ hy ⟨x, hx⟩ ↦ ⟨x, hP x hy hx⟩\n\n"}
{"name":"Antitone.exists","module":"Mathlib.Order.BoundedOrder.Monotone","initialProofState":"α : Type u\nβ : Type v\ninst✝ : Preorder α\nP : β → α → Prop\nhP : ∀ (x : β), Antitone (P x)\n⊢ Antitone fun y => Exists fun x => P x y","decl":"theorem Antitone.exists {P : β → α → Prop} (hP : ∀ x, Antitone (P x)) :\n    Antitone fun y => ∃ x, P x y :=\n  fun _ _ hy ⟨x, hx⟩ ↦ ⟨x, hP x hy hx⟩\n\n"}
{"name":"forall_ge_iff","module":"Mathlib.Order.BoundedOrder.Monotone","initialProofState":"α : Type u\ninst✝ : Preorder α\nP : α → Prop\nx₀ : α\nhP : Monotone P\n⊢ Iff (∀ (x : α), GE.ge x x₀ → P x) (P x₀)","decl":"theorem forall_ge_iff {P : α → Prop} {x₀ : α} (hP : Monotone P) :\n    (∀ x ≥ x₀, P x) ↔ P x₀ :=\n  ⟨fun H ↦ H x₀ le_rfl, fun H _ hx ↦ hP hx H⟩\n\n"}
{"name":"forall_le_iff","module":"Mathlib.Order.BoundedOrder.Monotone","initialProofState":"α : Type u\ninst✝ : Preorder α\nP : α → Prop\nx₀ : α\nhP : Antitone P\n⊢ Iff (∀ (x : α), LE.le x x₀ → P x) (P x₀)","decl":"theorem forall_le_iff {P : α → Prop} {x₀ : α} (hP : Antitone P) :\n    (∀ x ≤ x₀, P x) ↔ P x₀ :=\n  ⟨fun H ↦ H x₀ le_rfl, fun H _ hx ↦ hP hx H⟩\n\n"}
