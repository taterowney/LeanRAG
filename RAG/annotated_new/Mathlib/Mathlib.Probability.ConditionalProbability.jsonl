{"name":"ProbabilityTheory.cond_isProbabilityMeasure_of_finite","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ns : Set Ω\nhcs : Ne (μ s) 0\nhs : Ne (μ s) Top.top\n⊢ MeasureTheory.IsProbabilityMeasure (ProbabilityTheory.cond μ s)","decl":"/-- The conditional probability measure of any measure on any set of finite positive measure\nis a probability measure. -/\ntheorem cond_isProbabilityMeasure_of_finite (hcs : μ s ≠ 0) (hs : μ s ≠ ∞) :\n    IsProbabilityMeasure μ[|s] :=\n  ⟨by\n    unfold ProbabilityTheory.cond\n    simp only [Measure.coe_smul, Pi.smul_apply, MeasurableSet.univ, Measure.restrict_apply,\n      Set.univ_inter, smul_eq_mul]\n    exact ENNReal.inv_mul_cancel hcs hs⟩\n\n"}
{"name":"ProbabilityTheory.cond_isProbabilityMeasure","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ns : Set Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhcs : Ne (μ s) 0\n⊢ MeasureTheory.IsProbabilityMeasure (ProbabilityTheory.cond μ s)","decl":"/-- The conditional probability measure of any finite measure on any set of positive measure\nis a probability measure. -/\ntheorem cond_isProbabilityMeasure [IsFiniteMeasure μ] (hcs : μ s ≠ 0) :\n    IsProbabilityMeasure μ[|s] := cond_isProbabilityMeasure_of_finite hcs (measure_ne_top μ s)\n\n"}
{"name":"ProbabilityTheory.instIsZeroOrProbabilityMeasureCond","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ns : Set Ω\n⊢ MeasureTheory.IsZeroOrProbabilityMeasure (ProbabilityTheory.cond μ s)","decl":"instance : IsZeroOrProbabilityMeasure μ[|s] := by\n  constructor\n  simp only [cond, Measure.coe_smul, Pi.smul_apply, MeasurableSet.univ, Measure.restrict_apply,\n    univ_inter, smul_eq_mul, ← ENNReal.div_eq_inv_mul]\n  rcases eq_or_ne (μ s) 0 with h | h\n  · simp [h]\n  rcases eq_or_ne (μ s) ∞ with h' | h'\n  · simp [h']\n  simp [ENNReal.div_self h h']\n\n"}
{"name":"ProbabilityTheory.cond_toMeasurable_eq","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ns : Set Ω\n⊢ Eq (ProbabilityTheory.cond μ (MeasureTheory.toMeasurable μ s)) (ProbabilityTheory.cond μ s)","decl":"variable (μ) in\ntheorem cond_toMeasurable_eq :\n    μ[|(toMeasurable μ s)] = μ[|s] := by\n  unfold cond\n  by_cases hnt : μ s = ∞\n  · simp [hnt]\n  · simp [Measure.restrict_toMeasurable hnt]\n\n"}
{"name":"ProbabilityTheory.cond_absolutelyContinuous","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ns : Set Ω\n⊢ (ProbabilityTheory.cond μ s).AbsolutelyContinuous μ","decl":"lemma cond_absolutelyContinuous : μ[|s] ≪ μ :=\n  smul_absolutelyContinuous.trans restrict_le_self.absolutelyContinuous\n\n"}
{"name":"ProbabilityTheory.absolutelyContinuous_cond_univ","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ μ.AbsolutelyContinuous (ProbabilityTheory.cond μ Set.univ)","decl":"lemma absolutelyContinuous_cond_univ [IsFiniteMeasure μ] : μ ≪ μ[|univ] := by\n  rw [cond, restrict_univ]\n  refine absolutelyContinuous_smul ?_\n  simp [measure_ne_top]\n\n"}
{"name":"ProbabilityTheory.ae_cond_mem₀","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ns : Set Ω\nhs : MeasureTheory.NullMeasurableSet s μ\n⊢ Filter.Eventually (fun x => Membership.mem s x) (MeasureTheory.ae (ProbabilityTheory.cond μ s))","decl":"lemma ae_cond_mem₀ (hs : NullMeasurableSet s μ) : ∀ᵐ x ∂μ[|s], x ∈ s :=\n  ae_smul_measure (ae_restrict_mem₀ hs) _\n\n"}
{"name":"ProbabilityTheory.ae_cond_mem","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ns : Set Ω\nhs : MeasurableSet s\n⊢ Filter.Eventually (fun x => Membership.mem s x) (MeasureTheory.ae (ProbabilityTheory.cond μ s))","decl":"lemma ae_cond_mem (hs : MeasurableSet s) : ∀ᵐ x ∂μ[|s], x ∈ s :=\n  ae_smul_measure (ae_restrict_mem hs) _\n\n"}
{"name":"ProbabilityTheory.cond_empty","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\n⊢ Eq (ProbabilityTheory.cond μ EmptyCollection.emptyCollection) 0","decl":"variable (μ) in\n@[simp] lemma cond_empty : μ[|∅] = 0 := by simp [cond]\n\n"}
{"name":"ProbabilityTheory.cond_univ","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\n⊢ Eq (ProbabilityTheory.cond μ Set.univ) μ","decl":"variable (μ) in\n@[simp] lemma cond_univ [IsProbabilityMeasure μ] : μ[|Set.univ] = μ := by\n  simp [cond, measure_univ, Measure.restrict_univ]\n\n"}
{"name":"ProbabilityTheory.cond_eq_zero","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ns : Set Ω\n⊢ Iff (Eq (ProbabilityTheory.cond μ s) 0) (Or (Eq (μ s) Top.top) (Eq (μ s) 0))","decl":"@[simp] lemma cond_eq_zero : μ[|s] = 0 ↔ μ s = ∞ ∨ μ s = 0 := by simp [cond]\n\n"}
{"name":"ProbabilityTheory.cond_eq_zero_of_meas_eq_zero","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ns : Set Ω\nhμs : Eq (μ s) 0\n⊢ Eq (ProbabilityTheory.cond μ s) 0","decl":"lemma cond_eq_zero_of_meas_eq_zero (hμs : μ s = 0) : μ[|s] = 0 := by simp [hμs]\n\n"}
{"name":"ProbabilityTheory.cond_apply","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\ns : Set Ω\nhms : MeasurableSet s\nμ : MeasureTheory.Measure Ω\nt : Set Ω\n⊢ Eq ((ProbabilityTheory.cond μ s) t) (HMul.hMul (Inv.inv (μ s)) (μ (Inter.inter s t)))","decl":"/-- The axiomatic definition of conditional probability derived from a measure-theoretic one. -/\ntheorem cond_apply (hms : MeasurableSet s) (μ : Measure Ω) (t : Set Ω) :\n    μ[t|s] = (μ s)⁻¹ * μ (s ∩ t) := by\n  rw [cond, Measure.smul_apply, Measure.restrict_apply' hms, Set.inter_comm, smul_eq_mul]\n\n"}
{"name":"ProbabilityTheory.cond_apply'","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\ns t : Set Ω\nht : MeasurableSet t\nμ : MeasureTheory.Measure Ω\n⊢ Eq ((ProbabilityTheory.cond μ s) t) (HMul.hMul (Inv.inv (μ s)) (μ (Inter.inter s t)))","decl":"theorem cond_apply' (ht : MeasurableSet t) (μ : Measure Ω) : μ[t|s] = (μ s)⁻¹ * μ (s ∩ t) := by\n  rw [cond, Measure.smul_apply, Measure.restrict_apply ht, Set.inter_comm, smul_eq_mul]\n\n"}
{"name":"ProbabilityTheory.cond_apply_self","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ns : Set Ω\nhs₀ : Ne (μ s) 0\nhs : Ne (μ s) Top.top\n⊢ Eq ((ProbabilityTheory.cond μ s) s) 1","decl":"@[simp] lemma cond_apply_self (hs₀ : μ s ≠ 0) (hs : μ s ≠ ∞) : μ[s|s] = 1 := by\n  simpa [cond] using ENNReal.inv_mul_cancel hs₀ hs\n\n"}
{"name":"ProbabilityTheory.cond_inter_self","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\ns : Set Ω\nhms : MeasurableSet s\nt : Set Ω\nμ : MeasureTheory.Measure Ω\n⊢ Eq ((ProbabilityTheory.cond μ s) (Inter.inter s t)) ((ProbabilityTheory.cond μ s) t)","decl":"theorem cond_inter_self (hms : MeasurableSet s) (t : Set Ω) (μ : Measure Ω) :\n    μ[s ∩ t|s] = μ[t|s] := by\n  rw [cond_apply hms, ← Set.inter_assoc, Set.inter_self, ← cond_apply hms]\n\n"}
{"name":"ProbabilityTheory.inter_pos_of_cond_ne_zero","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ns t : Set Ω\nhms : MeasurableSet s\nhcst : Ne ((ProbabilityTheory.cond μ s) t) 0\n⊢ LT.lt 0 (μ (Inter.inter s t))","decl":"theorem inter_pos_of_cond_ne_zero (hms : MeasurableSet s) (hcst : μ[t|s] ≠ 0) : 0 < μ (s ∩ t) := by\n  refine pos_iff_ne_zero.mpr (right_ne_zero_of_mul (a := (μ s)⁻¹) ?_)\n  convert hcst\n  simp [hms, Set.inter_comm, cond]\n\n"}
{"name":"ProbabilityTheory.cond_pos_of_inter_ne_zero","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ns t : Set Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhms : MeasurableSet s\nhci : Ne (μ (Inter.inter s t)) 0\n⊢ LT.lt 0 ((ProbabilityTheory.cond μ s) t)","decl":"lemma cond_pos_of_inter_ne_zero [IsFiniteMeasure μ] (hms : MeasurableSet s) (hci : μ (s ∩ t) ≠ 0) :\n    0 < μ[t | s] := by\n  rw [cond_apply hms]\n  refine ENNReal.mul_pos ?_ hci\n  exact ENNReal.inv_ne_zero.mpr (measure_ne_top _ _)\n\n"}
{"name":"ProbabilityTheory.cond_cond_eq_cond_inter'","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ns t : Set Ω\nhms : MeasurableSet s\nhmt : MeasurableSet t\nhcs : Ne (μ s) Top.top\n⊢ Eq (ProbabilityTheory.cond (ProbabilityTheory.cond μ s) t) (ProbabilityTheory.cond μ (Inter.inter s t))","decl":"lemma cond_cond_eq_cond_inter' (hms : MeasurableSet s) (hmt : MeasurableSet t) (hcs : μ s ≠ ∞) :\n    μ[|s][|t] = μ[|s ∩ t] := by\n  ext u\n  rw [cond_apply hmt, cond_apply hms, cond_apply hms, cond_apply (hms.inter hmt)]\n  obtain hst | hst := eq_or_ne (μ (s ∩ t)) 0\n  · have : μ (s ∩ t ∩ u) = 0 := measure_mono_null Set.inter_subset_left hst\n    simp [this, ← Set.inter_assoc]\n  · have hcs' : μ s ≠ 0 :=\n      (measure_pos_of_superset Set.inter_subset_left hst).ne'\n    simp [*, ← mul_assoc, ← Set.inter_assoc, ENNReal.mul_inv, ENNReal.mul_inv_cancel,\n      mul_right_comm _ _ (μ s)⁻¹]\n\n"}
{"name":"ProbabilityTheory.cond_cond_eq_cond_inter","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\ns t : Set Ω\nhms : MeasurableSet s\nhmt : MeasurableSet t\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Eq (ProbabilityTheory.cond (ProbabilityTheory.cond μ s) t) (ProbabilityTheory.cond μ (Inter.inter s t))","decl":"/-- Conditioning first on `s` and then on `t` results in the same measure as conditioning\non `s ∩ t`. -/\ntheorem cond_cond_eq_cond_inter (hms : MeasurableSet s) (hmt : MeasurableSet t) (μ : Measure Ω)\n    [IsFiniteMeasure μ] : μ[|s][|t] = μ[|s ∩ t] :=\n  cond_cond_eq_cond_inter' hms hmt (measure_ne_top μ s)\n\n"}
{"name":"ProbabilityTheory.cond_mul_eq_inter'","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ns : Set Ω\nhms : MeasurableSet s\nhcs' : Ne (μ s) Top.top\nt : Set Ω\n⊢ Eq (HMul.hMul ((ProbabilityTheory.cond μ s) t) (μ s)) (μ (Inter.inter s t))","decl":"theorem cond_mul_eq_inter' (hms : MeasurableSet s) (hcs' : μ s ≠ ∞) (t : Set Ω) :\n    μ[t|s] * μ s = μ (s ∩ t) := by\n  obtain hcs | hcs := eq_or_ne (μ s) 0\n  · simp [hcs, measure_inter_null_of_null_left]\n  · rw [cond_apply hms, mul_comm, ← mul_assoc, ENNReal.mul_inv_cancel hcs hcs', one_mul]\n\n"}
{"name":"ProbabilityTheory.cond_mul_eq_inter","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\ns : Set Ω\nhms : MeasurableSet s\nt : Set Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Eq (HMul.hMul ((ProbabilityTheory.cond μ s) t) (μ s)) (μ (Inter.inter s t))","decl":"theorem cond_mul_eq_inter (hms : MeasurableSet s) (t : Set Ω) (μ : Measure Ω) [IsFiniteMeasure μ] :\n    μ[t|s] * μ s = μ (s ∩ t) := cond_mul_eq_inter' hms (measure_ne_top _ s) t\n\n"}
{"name":"ProbabilityTheory.cond_add_cond_compl_eq","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\ns t : Set Ω\nhms : MeasurableSet s\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Eq (HAdd.hAdd (HMul.hMul ((ProbabilityTheory.cond μ s) t) (μ s)) (HMul.hMul ((ProbabilityTheory.cond μ (HasCompl.compl s)) t) (μ (HasCompl.compl s)))) (μ t)","decl":"/-- A version of the law of total probability. -/\ntheorem cond_add_cond_compl_eq (hms : MeasurableSet s) (μ : Measure Ω) [IsFiniteMeasure μ] :\n    μ[t|s] * μ s + μ[t|sᶜ] * μ sᶜ = μ t := by\n  rw [cond_mul_eq_inter hms, cond_mul_eq_inter hms.compl, Set.inter_comm _ t,\n    Set.inter_comm _ t]\n  exact measure_inter_add_diff t hms\n\n"}
{"name":"ProbabilityTheory.cond_eq_inv_mul_cond_mul","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\ns t : Set Ω\nhms : MeasurableSet s\nhmt : MeasurableSet t\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Eq ((ProbabilityTheory.cond μ s) t) (HMul.hMul (HMul.hMul (Inv.inv (μ s)) ((ProbabilityTheory.cond μ t) s)) (μ t))","decl":"/-- **Bayes' Theorem** -/\ntheorem cond_eq_inv_mul_cond_mul (hms : MeasurableSet s) (hmt : MeasurableSet t) (μ : Measure Ω)\n    [IsFiniteMeasure μ] : μ[t|s] = (μ s)⁻¹ * μ[s|t] * μ t := by\n  rw [mul_assoc, cond_mul_eq_inter hmt s, Set.inter_comm, cond_apply hms]\n\n"}
{"name":"ProbabilityTheory.comap_cond","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nΩ' : Type u_2\nm : MeasurableSpace Ω\nm' : MeasurableSpace Ω'\nμ : MeasureTheory.Measure Ω\ns : Set Ω\ni : Ω' → Ω\nhi : MeasurableEmbedding i\nhi' : Filter.Eventually (fun ω => Membership.mem (Set.range i) ω) (MeasureTheory.ae μ)\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.Measure.comap i (ProbabilityTheory.cond μ s)) (ProbabilityTheory.cond (MeasureTheory.Measure.comap i μ) (Set.preimage i s))","decl":"lemma comap_cond {i : Ω' → Ω} (hi : MeasurableEmbedding i) (hi' : ∀ᵐ ω ∂μ, ω ∈ range i)\n    (hs : MeasurableSet s) : comap i μ[|s] = (comap i μ)[|i in s] := by\n  ext t ht\n  change μ (range i)ᶜ = 0 at hi'\n  rw [cond_apply, comap_apply, cond_apply, comap_apply, comap_apply, image_inter,\n    image_preimage_eq_inter_range, inter_right_comm, measure_inter_conull hi',\n    measure_inter_conull hi']\n  all_goals first\n  | exact hi.injective\n  | exact hi.measurableSet_image'\n  | exact hs\n  | exact ht\n  | exact hi.measurable hs\n  | exact (hi.measurable hs).inter ht\n\n"}
{"name":"ProbabilityTheory.sum_meas_smul_cond_fiber","module":"Mathlib.Probability.ConditionalProbability","initialProofState":"Ω : Type u_1\nα : Type u_3\nm : MeasurableSpace Ω\ninst✝³ : Fintype α\ninst✝² : MeasurableSpace α\ninst✝¹ : DiscreteMeasurableSpace α\nX : Ω → α\nhX : Measurable X\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ Eq (Finset.univ.sum fun x => HSMul.hSMul (μ (Set.preimage X (Singleton.singleton x))) (ProbabilityTheory.cond μ (Set.preimage X (Singleton.singleton x)))) μ","decl":"/-- The **law of total probability** for a random variable taking finitely many values: a measure\n`μ` can be expressed as a linear combination of its conditional measures `μ[|X ← x]` on fibers of a\nrandom variable `X` valued in a fintype. -/\nlemma sum_meas_smul_cond_fiber {X : Ω → α} (hX : Measurable X) (μ : Measure Ω) [IsFiniteMeasure μ] :\n    ∑ x, μ (X ⁻¹' {x}) • μ[|X ← x] = μ := by\n  ext E hE\n  calc\n    _ = ∑ x, μ (X ⁻¹' {x} ∩ E) := by\n      simp only [Measure.coe_finset_sum, Measure.coe_smul, Finset.sum_apply,\n        Pi.smul_apply, smul_eq_mul]\n      simp_rw [mul_comm (μ _), cond_mul_eq_inter (hX (.singleton _))]\n    _ = _ := by\n      have : ⋃ x ∈ Finset.univ, X ⁻¹' {x} ∩ E = E := by ext; simp\n      rw [← measure_biUnion_finset _ fun _ _ ↦ (hX (.singleton _)).inter hE, this]\n      aesop (add simp [PairwiseDisjoint, Set.Pairwise, Function.onFun, disjoint_left])\n\n"}
