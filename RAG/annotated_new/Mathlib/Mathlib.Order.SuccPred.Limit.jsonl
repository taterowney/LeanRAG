{"name":"Order.not_isSuccPrelimit_iff_exists_covBy","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝ : LT α\na : α\n⊢ Iff (Not (Order.IsSuccPrelimit a)) (Exists fun b => CovBy b a)","decl":"theorem not_isSuccPrelimit_iff_exists_covBy (a : α) : ¬IsSuccPrelimit a ↔ ∃ b, b ⋖ a := by\n  simp [IsSuccPrelimit]\n\n"}
{"name":"Order.not_isSuccLimit_iff_exists_covBy","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝ : LT α\na : α\n⊢ Iff (Not (Order.IsSuccPrelimit a)) (Exists fun b => CovBy b a)","decl":"@[deprecated not_isSuccPrelimit_iff_exists_covBy (since := \"2024-09-05\")]\nalias not_isSuccLimit_iff_exists_covBy := not_isSuccPrelimit_iff_exists_covBy\n\n"}
{"name":"Order.IsSuccPrelimit.of_dense","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : DenselyOrdered α\na : α\n⊢ Order.IsSuccPrelimit a","decl":"@[simp]\ntheorem IsSuccPrelimit.of_dense [DenselyOrdered α] (a : α) : IsSuccPrelimit a := fun _ => not_covBy\n\n"}
{"name":"Order.isSuccPrelimit_of_dense","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : DenselyOrdered α\na : α\n⊢ Order.IsSuccPrelimit a","decl":"@[deprecated (since := \"2024-09-30\")] alias isSuccPrelimit_of_dense := IsSuccPrelimit.of_dense\n"}
{"name":"Order.isSuccLimit_of_dense","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : DenselyOrdered α\na : α\n⊢ Order.IsSuccPrelimit a","decl":"@[deprecated (since := \"2024-09-05\")] alias isSuccLimit_of_dense := IsSuccPrelimit.of_dense\n\n"}
{"name":"Order.IsSuccLimit.not_isMin","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : Preorder α\nh : Order.IsSuccLimit a\n⊢ Not (IsMin a)","decl":"protected theorem IsSuccLimit.not_isMin (h : IsSuccLimit a) : ¬ IsMin a := h.1\n"}
{"name":"Order.IsSuccLimit.isSuccPrelimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : Preorder α\nh : Order.IsSuccLimit a\n⊢ Order.IsSuccPrelimit a","decl":"protected theorem IsSuccLimit.isSuccPrelimit (h : IsSuccLimit a) : IsSuccPrelimit a := h.2\n\n"}
{"name":"Order.IsSuccPrelimit.isSuccLimit_of_not_isMin","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : Preorder α\nh : Order.IsSuccPrelimit a\nha : Not (IsMin a)\n⊢ Order.IsSuccLimit a","decl":"theorem IsSuccPrelimit.isSuccLimit_of_not_isMin (h : IsSuccPrelimit a) (ha : ¬ IsMin a) :\n    IsSuccLimit a :=\n  ⟨ha, h⟩\n\n"}
{"name":"Order.IsSuccPrelimit.isSuccLimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : Preorder α\ninst✝ : NoMinOrder α\nh : Order.IsSuccPrelimit a\n⊢ Order.IsSuccLimit a","decl":"theorem IsSuccPrelimit.isSuccLimit [NoMinOrder α] (h : IsSuccPrelimit a) : IsSuccLimit a :=\n  h.isSuccLimit_of_not_isMin (not_isMin a)\n\n"}
{"name":"Order.isSuccPrelimit_iff_isSuccLimit_of_not_isMin","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : Preorder α\nh : Not (IsMin a)\n⊢ Iff (Order.IsSuccPrelimit a) (Order.IsSuccLimit a)","decl":"theorem isSuccPrelimit_iff_isSuccLimit_of_not_isMin (h : ¬ IsMin a) :\n    IsSuccPrelimit a ↔ IsSuccLimit a :=\n  ⟨fun ha ↦ ha.isSuccLimit_of_not_isMin h, IsSuccLimit.isSuccPrelimit⟩\n\n"}
{"name":"Order.isSuccPrelimit_iff_isSuccLimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : Preorder α\ninst✝ : NoMinOrder α\n⊢ Iff (Order.IsSuccPrelimit a) (Order.IsSuccLimit a)","decl":"theorem isSuccPrelimit_iff_isSuccLimit [NoMinOrder α] : IsSuccPrelimit a ↔ IsSuccLimit a :=\n  isSuccPrelimit_iff_isSuccLimit_of_not_isMin (not_isMin a)\n\n"}
{"name":"IsMin.not_isSuccLimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : Preorder α\nh : IsMin a\n⊢ Not (Order.IsSuccLimit a)","decl":"protected theorem _root_.IsMin.not_isSuccLimit (h : IsMin a) : ¬ IsSuccLimit a :=\n  fun ha ↦ ha.not_isMin h\n\n"}
{"name":"IsMin.isSuccPrelimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : Preorder α\na✝ : IsMin a\n⊢ Order.IsSuccPrelimit a","decl":"protected theorem _root_.IsMin.isSuccPrelimit : IsMin a → IsSuccPrelimit a := fun h _ hab =>\n  not_isMin_of_lt hab.lt h\n\n"}
{"name":"IsMin.isSuccLimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : Preorder α\na✝ : IsMin a\n⊢ Order.IsSuccPrelimit a","decl":"@[deprecated _root_.IsMin.isSuccPrelimit (since := \"2024-09-05\")]\nalias _root_.IsMin.isSuccLimit := _root_.IsMin.isSuccPrelimit\n\n"}
{"name":"Order.isSuccPrelimit_bot","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\n⊢ Order.IsSuccPrelimit Bot.bot","decl":"theorem isSuccPrelimit_bot [OrderBot α] : IsSuccPrelimit (⊥ : α) :=\n  isMin_bot.isSuccPrelimit\n\n"}
{"name":"Order.not_isSuccLimit_bot","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\n⊢ Not (Order.IsSuccLimit Bot.bot)","decl":"theorem not_isSuccLimit_bot [OrderBot α] : ¬ IsSuccLimit (⊥ : α) :=\n  isMin_bot.not_isSuccLimit\n\n"}
{"name":"Order.IsSuccLimit.ne_bot","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\nh : Order.IsSuccLimit a\n⊢ Ne a Bot.bot","decl":"theorem IsSuccLimit.ne_bot [OrderBot α] (h : IsSuccLimit a) : a ≠ ⊥ := by\n  rintro rfl\n  exact not_isSuccLimit_bot h\n\n"}
{"name":"Order.isSuccLimit_bot","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\n⊢ Order.IsSuccPrelimit Bot.bot","decl":"@[deprecated isSuccPrelimit_bot (since := \"2024-09-05\")]\nalias isSuccLimit_bot := isSuccPrelimit_bot\n\n"}
{"name":"Order.not_isSuccLimit_iff","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : Preorder α\n⊢ Iff (Not (Order.IsSuccLimit a)) (Or (IsMin a) (Not (Order.IsSuccPrelimit a)))","decl":"theorem not_isSuccLimit_iff : ¬ IsSuccLimit a ↔ IsMin a ∨ ¬ IsSuccPrelimit a := by\n  rw [IsSuccLimit, not_and_or, not_not]\n\n"}
{"name":"Order.IsSuccPrelimit.isMax","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\nh : Order.IsSuccPrelimit (Order.succ a)\n⊢ IsMax a","decl":"protected theorem IsSuccPrelimit.isMax (h : IsSuccPrelimit (succ a)) : IsMax a := by\n  by_contra H\n  exact h a (covBy_succ_of_not_isMax H)\n\n"}
{"name":"Order.IsSuccLimit.isMax","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\nh : Order.IsSuccLimit (Order.succ a)\n⊢ IsMax a","decl":"protected theorem IsSuccLimit.isMax (h : IsSuccLimit (succ a)) : IsMax a :=\n  h.isSuccPrelimit.isMax\n\n"}
{"name":"Order.not_isSuccPrelimit_succ_of_not_isMax","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\nha : Not (IsMax a)\n⊢ Not (Order.IsSuccPrelimit (Order.succ a))","decl":"theorem not_isSuccPrelimit_succ_of_not_isMax (ha : ¬ IsMax a) : ¬ IsSuccPrelimit (succ a) :=\n  mt IsSuccPrelimit.isMax ha\n\n"}
{"name":"Order.not_isSuccLimit_succ_of_not_isMax","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\nha : Not (IsMax a)\n⊢ Not (Order.IsSuccLimit (Order.succ a))","decl":"theorem not_isSuccLimit_succ_of_not_isMax (ha : ¬ IsMax a) : ¬ IsSuccLimit (succ a) :=\n  mt IsSuccLimit.isMax ha\n\n"}
{"name":"Order.IsSuccPrelimit.succ_ne","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\nh : Order.IsSuccPrelimit a\nb : α\n⊢ Ne (Order.succ b) a","decl":"theorem IsSuccPrelimit.succ_ne (h : IsSuccPrelimit a) (b : α) : succ b ≠ a := by\n  rintro rfl\n  exact not_isMax _ h.isMax\n\n"}
{"name":"Order.IsSuccLimit.succ_ne","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\nh : Order.IsSuccLimit a\nb : α\n⊢ Ne (Order.succ b) a","decl":"theorem IsSuccLimit.succ_ne (h : IsSuccLimit a) (b : α) : succ b ≠ a :=\n  h.isSuccPrelimit.succ_ne b\n\n"}
{"name":"Order.not_isSuccPrelimit_succ","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\na : α\n⊢ Not (Order.IsSuccPrelimit (Order.succ a))","decl":"@[simp]\ntheorem not_isSuccPrelimit_succ (a : α) : ¬IsSuccPrelimit (succ a) := fun h => h.succ_ne _ rfl\n\n"}
{"name":"Order.not_isSuccLimit_succ","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\na : α\n⊢ Not (Order.IsSuccLimit (Order.succ a))","decl":"@[simp]\ntheorem not_isSuccLimit_succ (a : α) : ¬IsSuccLimit (succ a) := fun h => h.succ_ne _ rfl\n\n"}
{"name":"Order.IsSuccPrelimit.isMin_of_noMax","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝³ : Preorder α\ninst✝² : SuccOrder α\ninst✝¹ : IsSuccArchimedean α\ninst✝ : NoMaxOrder α\nh : Order.IsSuccPrelimit a\n⊢ IsMin a","decl":"theorem IsSuccPrelimit.isMin_of_noMax (h : IsSuccPrelimit a) : IsMin a := by\n  intro b hb\n  rcases hb.exists_succ_iterate with ⟨_ | n, rfl⟩\n  · exact le_rfl\n  · rw [iterate_succ_apply'] at h\n    exact (not_isSuccPrelimit_succ _ h).elim\n\n"}
{"name":"Order.IsSuccLimit.isMin_of_noMax","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝³ : Preorder α\ninst✝² : SuccOrder α\ninst✝¹ : IsSuccArchimedean α\ninst✝ : NoMaxOrder α\nh : Order.IsSuccPrelimit a\n⊢ IsMin a","decl":"@[deprecated IsSuccPrelimit.isMin_of_noMax (since := \"2024-09-05\")]\nalias IsSuccLimit.isMin_of_noMax := IsSuccPrelimit.isMin_of_noMax\n\n"}
{"name":"Order.isSuccPrelimit_iff_of_noMax","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝³ : Preorder α\ninst✝² : SuccOrder α\ninst✝¹ : IsSuccArchimedean α\ninst✝ : NoMaxOrder α\n⊢ Iff (Order.IsSuccPrelimit a) (IsMin a)","decl":"@[simp]\ntheorem isSuccPrelimit_iff_of_noMax : IsSuccPrelimit a ↔ IsMin a :=\n  ⟨IsSuccPrelimit.isMin_of_noMax, IsMin.isSuccPrelimit⟩\n\n"}
{"name":"Order.isSuccLimit_iff_of_noMax","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝³ : Preorder α\ninst✝² : SuccOrder α\ninst✝¹ : IsSuccArchimedean α\ninst✝ : NoMaxOrder α\n⊢ Iff (Order.IsSuccPrelimit a) (IsMin a)","decl":"@[deprecated isSuccPrelimit_iff_of_noMax (since := \"2024-09-05\")]\nalias isSuccLimit_iff_of_noMax := isSuccPrelimit_iff_of_noMax\n\n"}
{"name":"Order.not_isSuccLimit_of_noMax","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝³ : Preorder α\ninst✝² : SuccOrder α\ninst✝¹ : IsSuccArchimedean α\ninst✝ : NoMaxOrder α\n⊢ Not (Order.IsSuccLimit a)","decl":"@[simp]\ntheorem not_isSuccLimit_of_noMax : ¬ IsSuccLimit a :=\n  fun h ↦ h.not_isMin h.isSuccPrelimit.isMin_of_noMax\n\n"}
{"name":"Order.not_isSuccPrelimit_of_noMax","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝⁴ : Preorder α\ninst✝³ : SuccOrder α\ninst✝² : IsSuccArchimedean α\ninst✝¹ : NoMaxOrder α\ninst✝ : NoMinOrder α\n⊢ Not (Order.IsSuccPrelimit a)","decl":"theorem not_isSuccPrelimit_of_noMax [NoMinOrder α] : ¬ IsSuccPrelimit a := by simp\n\n"}
{"name":"Order.isSuccLimit_iff","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\n⊢ Iff (Order.IsSuccLimit a) (And (Ne a Bot.bot) (Order.IsSuccPrelimit a))","decl":"theorem isSuccLimit_iff [OrderBot α] : IsSuccLimit a ↔ a ≠ ⊥ ∧ IsSuccPrelimit a := by\n  rw [IsSuccLimit, isMin_iff_eq_bot]\n\n"}
{"name":"Order.IsSuccLimit.bot_lt","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\nh : Order.IsSuccLimit a\n⊢ LT.lt Bot.bot a","decl":"theorem IsSuccLimit.bot_lt [OrderBot α] (h : IsSuccLimit a) : ⊥ < a :=\n  h.ne_bot.bot_lt\n\n"}
{"name":"Order.isSuccPrelimit_of_succ_ne","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\nh : ∀ (b : α), Ne (Order.succ b) a\n⊢ Order.IsSuccPrelimit a","decl":"theorem isSuccPrelimit_of_succ_ne (h : ∀ b, succ b ≠ a) : IsSuccPrelimit a := fun b hba =>\n  h b (CovBy.succ_eq hba)\n\n"}
{"name":"Order.isSuccLimit_of_succ_ne","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\nh : ∀ (b : α), Ne (Order.succ b) a\n⊢ Order.IsSuccPrelimit a","decl":"@[deprecated isSuccPrelimit_of_succ_ne (since := \"2024-09-05\")]\nalias isSuccLimit_of_succ_ne := isSuccPrelimit_of_succ_ne\n\n"}
{"name":"Order.not_isSuccPrelimit_iff","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\n⊢ Iff (Not (Order.IsSuccPrelimit a)) (Exists fun b => And (Not (IsMax b)) (Eq (Order.succ b) a))","decl":"theorem not_isSuccPrelimit_iff : ¬ IsSuccPrelimit a ↔ ∃ b, ¬ IsMax b ∧ succ b = a := by\n  rw [not_isSuccPrelimit_iff_exists_covBy]\n  refine exists_congr fun b => ⟨fun hba => ⟨hba.lt.not_isMax, (CovBy.succ_eq hba)⟩, ?_⟩\n  rintro ⟨h, rfl⟩\n  exact covBy_succ_of_not_isMax h\n\n"}
{"name":"Order.mem_range_succ_of_not_isSuccPrelimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\nh : Not (Order.IsSuccPrelimit a)\n⊢ Membership.mem (Set.range Order.succ) a","decl":"/-- See `not_isSuccPrelimit_iff` for a version that states that `a` is a successor of a value other\nthan itself. -/\ntheorem mem_range_succ_of_not_isSuccPrelimit (h : ¬ IsSuccPrelimit a) :\n    a ∈ range (succ : α → α) := by\n  obtain ⟨b, hb⟩ := not_isSuccPrelimit_iff.1 h\n  exact ⟨b, hb.2⟩\n\n"}
{"name":"Order.mem_range_succ_of_not_isSuccLimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\nh : Not (Order.IsSuccPrelimit a)\n⊢ Membership.mem (Set.range Order.succ) a","decl":"@[deprecated mem_range_succ_of_not_isSuccPrelimit (since := \"2024-09-05\")]\nalias mem_range_succ_of_not_isSuccLimit := mem_range_succ_of_not_isSuccPrelimit\n\n"}
{"name":"Order.mem_range_succ_or_isSuccPrelimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\na : α\n⊢ Or (Membership.mem (Set.range Order.succ) a) (Order.IsSuccPrelimit a)","decl":"theorem mem_range_succ_or_isSuccPrelimit (a) : a ∈ range (succ : α → α) ∨ IsSuccPrelimit a :=\n  or_iff_not_imp_right.2 <| mem_range_succ_of_not_isSuccPrelimit\n\n"}
{"name":"Order.mem_range_succ_or_isSuccLimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\na : α\n⊢ Or (Membership.mem (Set.range Order.succ) a) (Order.IsSuccPrelimit a)","decl":"@[deprecated mem_range_succ_or_isSuccPrelimit (since := \"2024-09-05\")]\nalias mem_range_succ_or_isSuccLimit := mem_range_succ_or_isSuccPrelimit\n\n"}
{"name":"Order.isMin_or_mem_range_succ_or_isSuccLimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\na : α\n⊢ Or (IsMin a) (Or (Membership.mem (Set.range Order.succ) a) (Order.IsSuccLimit a))","decl":"theorem isMin_or_mem_range_succ_or_isSuccLimit (a) :\n    IsMin a ∨ a ∈ range (succ : α → α) ∨ IsSuccLimit a := by\n  rw [IsSuccLimit]\n  have := mem_range_succ_or_isSuccPrelimit a\n  tauto\n\n"}
{"name":"Order.isSuccPrelimit_of_succ_lt","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\nH : ∀ (a : α), LT.lt a b → LT.lt (Order.succ a) b\n⊢ Order.IsSuccPrelimit b","decl":"theorem isSuccPrelimit_of_succ_lt (H : ∀ a < b, succ a < b) : IsSuccPrelimit b := fun a hab =>\n  (H a hab.lt).ne (CovBy.succ_eq hab)\n\n"}
{"name":"Order.isSuccLimit_of_succ_lt","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\nH : ∀ (a : α), LT.lt a b → LT.lt (Order.succ a) b\n⊢ Order.IsSuccPrelimit b","decl":"@[deprecated isSuccPrelimit_of_succ_lt (since := \"2024-09-05\")]\nalias isSuccLimit_of_succ_lt := isSuccPrelimit_of_succ_lt\n\n"}
{"name":"Order.IsSuccPrelimit.succ_lt","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na b : α\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\nhb : Order.IsSuccPrelimit b\nha : LT.lt a b\n⊢ LT.lt (Order.succ a) b","decl":"theorem IsSuccPrelimit.succ_lt (hb : IsSuccPrelimit b) (ha : a < b) : succ a < b := by\n  by_cases h : IsMax a\n  · rwa [h.succ_eq]\n  · rw [lt_iff_le_and_ne, succ_le_iff_of_not_isMax h]\n    refine ⟨ha, fun hab => ?_⟩\n    subst hab\n    exact (h hb.isMax).elim\n\n"}
{"name":"Order.IsSuccLimit.succ_lt","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na b : α\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\nhb : Order.IsSuccLimit b\nha : LT.lt a b\n⊢ LT.lt (Order.succ a) b","decl":"theorem IsSuccLimit.succ_lt (hb : IsSuccLimit b) (ha : a < b) : succ a < b :=\n  hb.isSuccPrelimit.succ_lt ha\n\n"}
{"name":"Order.IsSuccPrelimit.succ_lt_iff","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na b : α\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\nhb : Order.IsSuccPrelimit b\n⊢ Iff (LT.lt (Order.succ a) b) (LT.lt a b)","decl":"theorem IsSuccPrelimit.succ_lt_iff (hb : IsSuccPrelimit b) : succ a < b ↔ a < b :=\n  ⟨fun h => (le_succ a).trans_lt h, hb.succ_lt⟩\n\n"}
{"name":"Order.IsSuccLimit.succ_lt_iff","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na b : α\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\nhb : Order.IsSuccLimit b\n⊢ Iff (LT.lt (Order.succ a) b) (LT.lt a b)","decl":"theorem IsSuccLimit.succ_lt_iff (hb : IsSuccLimit b) : succ a < b ↔ a < b :=\n  hb.isSuccPrelimit.succ_lt_iff\n\n"}
{"name":"Order.isSuccPrelimit_iff_succ_lt","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\n⊢ Iff (Order.IsSuccPrelimit b) (∀ (a : α), LT.lt a b → LT.lt (Order.succ a) b)","decl":"theorem isSuccPrelimit_iff_succ_lt : IsSuccPrelimit b ↔ ∀ a < b, succ a < b :=\n  ⟨fun hb _ => hb.succ_lt, isSuccPrelimit_of_succ_lt⟩\n\n"}
{"name":"Order.isSuccLimit_iff_succ_lt","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\n⊢ Iff (Order.IsSuccPrelimit b) (∀ (a : α), LT.lt a b → LT.lt (Order.succ a) b)","decl":"@[deprecated isSuccPrelimit_iff_succ_lt (since := \"2024-09-05\")]\nalias isSuccLimit_iff_succ_lt := isSuccPrelimit_iff_succ_lt\n\n"}
{"name":"Order.isSuccPrelimit_iff_succ_ne","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\n⊢ Iff (Order.IsSuccPrelimit a) (∀ (b : α), Ne (Order.succ b) a)","decl":"theorem isSuccPrelimit_iff_succ_ne : IsSuccPrelimit a ↔ ∀ b, succ b ≠ a :=\n  ⟨IsSuccPrelimit.succ_ne, isSuccPrelimit_of_succ_ne⟩\n\n"}
{"name":"Order.isSuccLimit_iff_succ_ne","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\n⊢ Iff (Order.IsSuccPrelimit a) (∀ (b : α), Ne (Order.succ b) a)","decl":"@[deprecated isSuccPrelimit_iff_succ_ne (since := \"2024-09-05\")]\nalias isSuccLimit_iff_succ_ne := isSuccPrelimit_iff_succ_ne\n\n"}
{"name":"Order.not_isSuccPrelimit_iff'","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\n⊢ Iff (Not (Order.IsSuccPrelimit a)) (Membership.mem (Set.range Order.succ) a)","decl":"theorem not_isSuccPrelimit_iff' : ¬ IsSuccPrelimit a ↔ a ∈ range (succ : α → α) := by\n  simp_rw [isSuccPrelimit_iff_succ_ne, not_forall, not_ne_iff, mem_range]\n\n"}
{"name":"Order.not_isSuccLimit_iff'","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\n⊢ Iff (Not (Order.IsSuccPrelimit a)) (Membership.mem (Set.range Order.succ) a)","decl":"@[deprecated not_isSuccPrelimit_iff' (since := \"2024-09-05\")]\nalias not_isSuccLimit_iff' := not_isSuccPrelimit_iff'\n\n"}
{"name":"Order.IsSuccPrelimit.isMin","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\nh : Order.IsSuccPrelimit a\n⊢ IsMin a","decl":"protected theorem IsSuccPrelimit.isMin (h : IsSuccPrelimit a) : IsMin a := fun b hb => by\n  revert h\n  refine Succ.rec (fun _ => le_rfl) (fun c _ H hc => ?_) hb\n  have := hc.isMax.succ_eq\n  rw [this] at hc ⊢\n  exact H hc\n\n"}
{"name":"Order.isSuccPrelimit_iff","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\n⊢ Iff (Order.IsSuccPrelimit a) (IsMin a)","decl":"@[simp]\ntheorem isSuccPrelimit_iff : IsSuccPrelimit a ↔ IsMin a :=\n  ⟨IsSuccPrelimit.isMin, IsMin.isSuccPrelimit⟩\n\n"}
{"name":"Order.not_isSuccLimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\n⊢ Not (Order.IsSuccLimit a)","decl":"@[simp]\ntheorem not_isSuccLimit : ¬ IsSuccLimit a :=\n  fun h ↦ h.not_isMin <| h.isSuccPrelimit.isMin\n\n"}
{"name":"Order.not_isSuccPrelimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝³ : PartialOrder α\ninst✝² : SuccOrder α\ninst✝¹ : IsSuccArchimedean α\ninst✝ : NoMinOrder α\n⊢ Not (Order.IsSuccPrelimit a)","decl":"theorem not_isSuccPrelimit [NoMinOrder α] : ¬ IsSuccPrelimit a := by simp\n\n"}
{"name":"Order.IsSuccPrelimit.le_iff_forall_le","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na b : α\ninst✝ : LinearOrder α\nh : Order.IsSuccPrelimit a\n⊢ Iff (LE.le a b) (∀ (c : α), LT.lt c a → LE.le c b)","decl":"theorem IsSuccPrelimit.le_iff_forall_le (h : IsSuccPrelimit a) : a ≤ b ↔ ∀ c < a, c ≤ b := by\n  use fun ha c hc ↦ hc.le.trans ha\n  intro H\n  by_contra! ha\n  exact h b ⟨ha, fun c hb hc ↦ (H c hc).not_lt hb⟩\n\n"}
{"name":"Order.IsSuccLimit.le_iff_forall_le","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na b : α\ninst✝ : LinearOrder α\nh : Order.IsSuccLimit a\n⊢ Iff (LE.le a b) (∀ (c : α), LT.lt c a → LE.le c b)","decl":"theorem IsSuccLimit.le_iff_forall_le (h : IsSuccLimit a) : a ≤ b ↔ ∀ c < a, c ≤ b :=\n  h.isSuccPrelimit.le_iff_forall_le\n\n"}
{"name":"Order.IsSuccPrelimit.lt_iff_exists_lt","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na b : α\ninst✝ : LinearOrder α\nh : Order.IsSuccPrelimit b\n⊢ Iff (LT.lt a b) (Exists fun c => And (LT.lt c b) (LT.lt a c))","decl":"theorem IsSuccPrelimit.lt_iff_exists_lt (h : IsSuccPrelimit b) : a < b ↔ ∃ c < b, a < c := by\n  rw [← not_iff_not]\n  simp [h.le_iff_forall_le]\n\n"}
{"name":"Order.IsSuccLimit.lt_iff_exists_lt","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na b : α\ninst✝ : LinearOrder α\nh : Order.IsSuccLimit b\n⊢ Iff (LT.lt a b) (Exists fun c => And (LT.lt c b) (LT.lt a c))","decl":"theorem IsSuccLimit.lt_iff_exists_lt (h : IsSuccLimit b) : a < b ↔ ∃ c < b, a < c :=\n  h.isSuccPrelimit.lt_iff_exists_lt\n\n"}
{"name":"Order.IsSuccPrelimit.isLUB_Iio","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : LinearOrder α\nha : Order.IsSuccPrelimit a\n⊢ IsLUB (Set.Iio a) a","decl":"theorem IsSuccPrelimit.isLUB_Iio (ha : IsSuccPrelimit a) : IsLUB (Iio a) a := by\n  refine ⟨fun _ ↦ le_of_lt, fun b hb ↦ le_of_forall_lt fun c hc ↦ ?_⟩\n  obtain ⟨d, hd, hd'⟩ := ha.lt_iff_exists_lt.1 hc\n  exact hd'.trans_le (hb hd)\n\n"}
{"name":"Order.IsSuccLimit.isLUB_Iio","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : LinearOrder α\nha : Order.IsSuccLimit a\n⊢ IsLUB (Set.Iio a) a","decl":"theorem IsSuccLimit.isLUB_Iio (ha : IsSuccLimit a) : IsLUB (Iio a) a :=\n  ha.isSuccPrelimit.isLUB_Iio\n\n"}
{"name":"Order.isLUB_Iio_iff_isSuccPrelimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : LinearOrder α\n⊢ Iff (IsLUB (Set.Iio a) a) (Order.IsSuccPrelimit a)","decl":"theorem isLUB_Iio_iff_isSuccPrelimit : IsLUB (Iio a) a ↔ IsSuccPrelimit a := by\n  refine ⟨fun ha b hb ↦ ?_, IsSuccPrelimit.isLUB_Iio⟩\n  rw [hb.Iio_eq] at ha\n  obtain rfl := isLUB_Iic.unique ha\n  cases hb.lt.false\n\n"}
{"name":"Order.IsSuccPrelimit.le_succ_iff","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na b : α\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\nhb : Order.IsSuccPrelimit b\n⊢ Iff (LE.le b (Order.succ a)) (LE.le b a)","decl":"theorem IsSuccPrelimit.le_succ_iff (hb : IsSuccPrelimit b) : b ≤ succ a ↔ b ≤ a :=\n  le_iff_le_iff_lt_iff_lt.2 hb.succ_lt_iff\n\n"}
{"name":"Order.IsSuccLimit.le_succ_iff","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na b : α\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\nhb : Order.IsSuccLimit b\n⊢ Iff (LE.le b (Order.succ a)) (LE.le b a)","decl":"theorem IsSuccLimit.le_succ_iff (hb : IsSuccLimit b) : b ≤ succ a ↔ b ≤ a :=\n  hb.isSuccPrelimit.le_succ_iff\n\n"}
{"name":"Order.not_isPredPrelimit_iff_exists_covBy","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝ : LT α\na : α\n⊢ Iff (Not (Order.IsPredPrelimit a)) (Exists fun b => CovBy a b)","decl":"theorem not_isPredPrelimit_iff_exists_covBy (a : α) : ¬IsPredPrelimit a ↔ ∃ b, a ⋖ b := by\n  simp [IsPredPrelimit]\n\n"}
{"name":"Order.not_isPredLimit_iff_exists_covBy","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝ : LT α\na : α\n⊢ Iff (Not (Order.IsPredPrelimit a)) (Exists fun b => CovBy a b)","decl":"@[deprecated not_isPredPrelimit_iff_exists_covBy (since := \"2024-09-05\")]\nalias not_isPredLimit_iff_exists_covBy := not_isPredPrelimit_iff_exists_covBy\n\n"}
{"name":"Order.IsPredPrelimit.of_dense","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : DenselyOrdered α\na : α\n⊢ Order.IsPredPrelimit a","decl":"@[simp]\ntheorem IsPredPrelimit.of_dense [DenselyOrdered α] (a : α) : IsPredPrelimit a := fun _ => not_covBy\n\n"}
{"name":"Order.isPredPrelimit_of_dense","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : DenselyOrdered α\na : α\n⊢ Order.IsPredPrelimit a","decl":"@[deprecated (since := \"2024-09-30\")] alias isPredPrelimit_of_dense := IsPredPrelimit.of_dense\n"}
{"name":"Order.isPredLimit_of_dense","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝¹ : LT α\ninst✝ : DenselyOrdered α\na : α\n⊢ Order.IsPredPrelimit a","decl":"@[deprecated (since := \"2024-09-05\")] alias isPredLimit_of_dense := IsPredPrelimit.of_dense\n\n"}
{"name":"Order.isSuccPrelimit_toDual_iff","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : LT α\n⊢ Iff (Order.IsSuccPrelimit (OrderDual.toDual a)) (Order.IsPredPrelimit a)","decl":"@[simp]\ntheorem isSuccPrelimit_toDual_iff : IsSuccPrelimit (toDual a) ↔ IsPredPrelimit a := by\n  simp [IsSuccPrelimit, IsPredPrelimit]\n\n"}
{"name":"Order.isPredPrelimit_toDual_iff","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : LT α\n⊢ Iff (Order.IsPredPrelimit (OrderDual.toDual a)) (Order.IsSuccPrelimit a)","decl":"@[simp]\ntheorem isPredPrelimit_toDual_iff : IsPredPrelimit (toDual a) ↔ IsSuccPrelimit a := by\n  simp [IsSuccPrelimit, IsPredPrelimit]\n\n"}
{"name":"Order.IsPredPrelimit.dual","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : LT α\na✝ : Order.IsPredPrelimit a\n⊢ Order.IsSuccPrelimit (OrderDual.toDual a)","decl":"alias ⟨_, IsPredPrelimit.dual⟩ := isSuccPrelimit_toDual_iff\n"}
{"name":"Order.IsSuccPrelimit.dual","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : LT α\na✝ : Order.IsSuccPrelimit a\n⊢ Order.IsPredPrelimit (OrderDual.toDual a)","decl":"alias ⟨_, IsSuccPrelimit.dual⟩ := isPredPrelimit_toDual_iff\n"}
{"name":"Order.isPredLimit.dual","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : LT α\na✝ : Order.IsPredPrelimit a\n⊢ Order.IsSuccPrelimit (OrderDual.toDual a)","decl":"@[deprecated IsPredPrelimit.dual (since := \"2024-09-05\")]\nalias isPredLimit.dual := IsPredPrelimit.dual\n"}
{"name":"Order.isSuccLimit.dual","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : LT α\na✝ : Order.IsSuccPrelimit a\n⊢ Order.IsPredPrelimit (OrderDual.toDual a)","decl":"@[deprecated IsSuccPrelimit.dual (since := \"2024-09-05\")]\nalias isSuccLimit.dual := IsSuccPrelimit.dual\n\n"}
{"name":"Order.IsPredLimit.not_isMax","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : Preorder α\nh : Order.IsPredLimit a\n⊢ Not (IsMax a)","decl":"protected theorem IsPredLimit.not_isMax (h : IsPredLimit a) : ¬ IsMax a := h.1\n"}
{"name":"Order.IsPredLimit.isPredPrelimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : Preorder α\nh : Order.IsPredLimit a\n⊢ Order.IsPredPrelimit a","decl":"protected theorem IsPredLimit.isPredPrelimit (h : IsPredLimit a) : IsPredPrelimit a := h.2\n\n"}
{"name":"Order.isSuccLimit_toDual_iff","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : Preorder α\n⊢ Iff (Order.IsSuccLimit (OrderDual.toDual a)) (Order.IsPredLimit a)","decl":"@[simp]\ntheorem isSuccLimit_toDual_iff : IsSuccLimit (toDual a) ↔ IsPredLimit a := by\n  simp [IsSuccLimit, IsPredLimit]\n\n"}
{"name":"Order.isPredLimit_toDual_iff","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : Preorder α\n⊢ Iff (Order.IsPredLimit (OrderDual.toDual a)) (Order.IsSuccLimit a)","decl":"@[simp]\ntheorem isPredLimit_toDual_iff : IsPredLimit (toDual a) ↔ IsSuccLimit a := by\n  simp [IsSuccLimit, IsPredLimit]\n\n"}
{"name":"Order.IsPredLimit.dual","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : Preorder α\na✝ : Order.IsPredLimit a\n⊢ Order.IsSuccLimit (OrderDual.toDual a)","decl":"alias ⟨_, IsPredLimit.dual⟩ := isSuccLimit_toDual_iff\n"}
{"name":"Order.IsSuccLimit.dual","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : Preorder α\na✝ : Order.IsSuccLimit a\n⊢ Order.IsPredLimit (OrderDual.toDual a)","decl":"alias ⟨_, IsSuccLimit.dual⟩ := isPredLimit_toDual_iff\n\n"}
{"name":"Order.IsPredPrelimit.isPredLimit_of_not_isMax","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : Preorder α\nh : Order.IsPredPrelimit a\nha : Not (IsMax a)\n⊢ Order.IsPredLimit a","decl":"theorem IsPredPrelimit.isPredLimit_of_not_isMax (h : IsPredPrelimit a) (ha : ¬ IsMax a) :\n    IsPredLimit a :=\n  ⟨ha, h⟩\n\n"}
{"name":"Order.IsPredPrelimit.isPredLimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : Preorder α\ninst✝ : NoMaxOrder α\nh : Order.IsPredPrelimit a\n⊢ Order.IsPredLimit a","decl":"theorem IsPredPrelimit.isPredLimit [NoMaxOrder α] (h : IsPredPrelimit a) : IsPredLimit a :=\n  h.isPredLimit_of_not_isMax (not_isMax a)\n\n"}
{"name":"Order.isPredPrelimit_iff_isPredLimit_of_not_isMax","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : Preorder α\nh : Not (IsMax a)\n⊢ Iff (Order.IsPredPrelimit a) (Order.IsPredLimit a)","decl":"theorem isPredPrelimit_iff_isPredLimit_of_not_isMax (h : ¬ IsMax a) :\n    IsPredPrelimit a ↔ IsPredLimit a :=\n  ⟨fun ha ↦ ha.isPredLimit_of_not_isMax h, IsPredLimit.isPredPrelimit⟩\n\n"}
{"name":"Order.isPredPrelimit_iff_isPredLimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : Preorder α\ninst✝ : NoMaxOrder α\n⊢ Iff (Order.IsPredPrelimit a) (Order.IsPredLimit a)","decl":"theorem isPredPrelimit_iff_isPredLimit [NoMaxOrder α] : IsPredPrelimit a ↔ IsPredLimit a :=\n  isPredPrelimit_iff_isPredLimit_of_not_isMax (not_isMax a)\n\n"}
{"name":"IsMax.not_isPredLimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : Preorder α\nh : IsMax a\n⊢ Not (Order.IsPredLimit a)","decl":"protected theorem _root_.IsMax.not_isPredLimit (h : IsMax a) : ¬ IsPredLimit a :=\n  fun ha ↦ ha.not_isMax h\n\n"}
{"name":"IsMax.isPredPrelimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : Preorder α\na✝ : IsMax a\n⊢ Order.IsPredPrelimit a","decl":"protected theorem _root_.IsMax.isPredPrelimit : IsMax a → IsPredPrelimit a := fun h _ hab =>\n  not_isMax_of_lt hab.lt h\n\n"}
{"name":"IsMax.isPredLimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : Preorder α\na✝ : IsMax a\n⊢ Order.IsPredPrelimit a","decl":"@[deprecated _root_.IsMax.isPredPrelimit (since := \"2024-09-05\")]\nalias _root_.IsMax.isPredLimit := _root_.IsMax.isPredPrelimit\n\n"}
{"name":"Order.isPredPrelimit_top","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\n⊢ Order.IsPredPrelimit Top.top","decl":"theorem isPredPrelimit_top [OrderTop α] : IsPredPrelimit (⊤ : α) :=\n  isMax_top.isPredPrelimit\n\n"}
{"name":"Order.isPredLimit_top","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\n⊢ Order.IsPredPrelimit Top.top","decl":"@[deprecated isPredPrelimit_top (since := \"2024-09-05\")]\nalias isPredLimit_top := isPredPrelimit_top\n\n"}
{"name":"Order.not_isPredLimit_top","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\n⊢ Not (Order.IsPredLimit Top.top)","decl":"theorem not_isPredLimit_top [OrderTop α] : ¬ IsPredLimit (⊤ : α) :=\n  isMax_top.not_isPredLimit\n\n"}
{"name":"Order.IsPredLimit.ne_top","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\nh : Order.IsPredLimit a\n⊢ Ne a Top.top","decl":"theorem IsPredLimit.ne_top [OrderTop α] (h : IsPredLimit a) : a ≠ ⊤ :=\n  h.dual.ne_bot\n\n"}
{"name":"Order.not_isPredLimit_iff","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : Preorder α\n⊢ Iff (Not (Order.IsPredLimit a)) (Or (IsMax a) (Not (Order.IsPredPrelimit a)))","decl":"theorem not_isPredLimit_iff : ¬ IsPredLimit a ↔ IsMax a ∨ ¬ IsPredPrelimit a := by\n  rw [IsPredLimit, not_and_or, not_not]\n\n"}
{"name":"Order.not_isPredLimit_of_not_isPredPrelimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : Preorder α\nh : Not (Order.IsPredPrelimit a)\n⊢ Not (Order.IsPredLimit a)","decl":"theorem not_isPredLimit_of_not_isPredPrelimit (h : ¬ IsPredPrelimit a) : ¬ IsPredLimit a :=\n  not_isPredLimit_iff.2 (Or.inr h)\n\n"}
{"name":"Order.IsPredPrelimit.isMin","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\nh : Order.IsPredPrelimit (Order.pred a)\n⊢ IsMin a","decl":"protected theorem IsPredPrelimit.isMin (h : IsPredPrelimit (pred a)) : IsMin a :=\n  h.dual.isMax\n\n"}
{"name":"Order.IsPredLimit.isMin","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\nh : Order.IsPredLimit (Order.pred a)\n⊢ IsMin a","decl":"protected theorem IsPredLimit.isMin (h : IsPredLimit (pred a)) : IsMin a :=\n  h.dual.isMax\n\n"}
{"name":"Order.not_isPredPrelimit_pred_of_not_isMin","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\nha : Not (IsMin a)\n⊢ Not (Order.IsPredPrelimit (Order.pred a))","decl":"theorem not_isPredPrelimit_pred_of_not_isMin (ha : ¬ IsMin a) : ¬ IsPredPrelimit (pred a) :=\n  mt IsPredPrelimit.isMin ha\n\n"}
{"name":"Order.not_isPredLimit_pred_of_not_isMin","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\nha : Not (IsMin a)\n⊢ Not (Order.IsPredLimit (Order.pred a))","decl":"theorem not_isPredLimit_pred_of_not_isMin (ha : ¬ IsMin a) : ¬ IsPredLimit (pred a) :=\n  mt IsPredLimit.isMin ha\n\n"}
{"name":"Order.IsPredPrelimit.pred_ne","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\nh : Order.IsPredPrelimit a\nb : α\n⊢ Ne (Order.pred b) a","decl":"theorem IsPredPrelimit.pred_ne (h : IsPredPrelimit a) (b : α) : pred b ≠ a :=\n  h.dual.succ_ne b\n\n"}
{"name":"Order.IsPredLimit.pred_ne","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\nh : Order.IsPredLimit a\nb : α\n⊢ Ne (Order.pred b) a","decl":"theorem IsPredLimit.pred_ne (h : IsPredLimit a) (b : α) : pred b ≠ a :=\n  h.isPredPrelimit.pred_ne b\n\n"}
{"name":"Order.not_isPredPrelimit_pred","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\na : α\n⊢ Not (Order.IsPredPrelimit (Order.pred a))","decl":"@[simp]\ntheorem not_isPredPrelimit_pred (a : α) : ¬ IsPredPrelimit (pred a) := fun h => h.pred_ne _ rfl\n\n"}
{"name":"Order.not_isPredLimit_pred","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\na : α\n⊢ Not (Order.IsPredLimit (Order.pred a))","decl":"@[simp]\ntheorem not_isPredLimit_pred (a : α) : ¬ IsPredLimit (pred a) := fun h => h.pred_ne _ rfl\n\n"}
{"name":"Order.IsPredPrelimit.isMax_of_noMin","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝³ : Preorder α\ninst✝² : PredOrder α\ninst✝¹ : IsPredArchimedean α\ninst✝ : NoMinOrder α\nh : Order.IsPredPrelimit a\n⊢ IsMax a","decl":"theorem IsPredPrelimit.isMax_of_noMin (h : IsPredPrelimit a) : IsMax a :=\n  h.dual.isMin_of_noMax\n\n"}
{"name":"Order.IsPredLimit.isMax_of_noMin","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝³ : Preorder α\ninst✝² : PredOrder α\ninst✝¹ : IsPredArchimedean α\ninst✝ : NoMinOrder α\nh : Order.IsPredPrelimit a\n⊢ IsMax a","decl":"@[deprecated IsPredPrelimit.isMax_of_noMin (since := \"2024-09-05\")]\nalias IsPredLimit.isMax_of_noMin := IsPredPrelimit.isMax_of_noMin\n\n"}
{"name":"Order.isPredPrelimit_iff_of_noMin","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝³ : Preorder α\ninst✝² : PredOrder α\ninst✝¹ : IsPredArchimedean α\ninst✝ : NoMinOrder α\n⊢ Iff (Order.IsPredPrelimit a) (IsMax a)","decl":"@[simp]\ntheorem isPredPrelimit_iff_of_noMin : IsPredPrelimit a ↔ IsMax a :=\n  ⟨IsPredPrelimit.isMax_of_noMin, IsMax.isPredPrelimit⟩\n\n"}
{"name":"Order.isPredLimit_iff_of_noMin","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝³ : Preorder α\ninst✝² : PredOrder α\ninst✝¹ : IsPredArchimedean α\ninst✝ : NoMinOrder α\n⊢ Iff (Order.IsPredPrelimit a) (IsMax a)","decl":"@[deprecated isPredPrelimit_iff_of_noMin (since := \"2024-09-05\")]\nalias isPredLimit_iff_of_noMin := isPredPrelimit_iff_of_noMin\n\n"}
{"name":"Order.not_isPredPrelimit_of_noMin","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝⁴ : Preorder α\ninst✝³ : PredOrder α\ninst✝² : IsPredArchimedean α\ninst✝¹ : NoMinOrder α\ninst✝ : NoMaxOrder α\n⊢ Not (Order.IsPredPrelimit a)","decl":"theorem not_isPredPrelimit_of_noMin [NoMaxOrder α] : ¬ IsPredPrelimit a := by simp\n\n"}
{"name":"Order.not_isPredLimit_of_noMin","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝³ : Preorder α\ninst✝² : PredOrder α\ninst✝¹ : IsPredArchimedean α\ninst✝ : NoMinOrder α\n⊢ Not (Order.IsPredLimit a)","decl":"@[simp]\ntheorem not_isPredLimit_of_noMin : ¬ IsPredLimit a :=\n  fun h ↦ h.not_isMax h.isPredPrelimit.isMax_of_noMin\n\n"}
{"name":"Order.isPredLimit_iff","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\n⊢ Iff (Order.IsPredLimit a) (And (Ne a Top.top) (Order.IsPredPrelimit a))","decl":"theorem isPredLimit_iff [OrderTop α] : IsPredLimit a ↔ a ≠ ⊤ ∧ IsPredPrelimit a := by\n  rw [IsPredLimit, isMax_iff_eq_top]\n\n"}
{"name":"Order.IsPredLimit.lt_top","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\nh : Order.IsPredLimit a\n⊢ LT.lt a Top.top","decl":"theorem IsPredLimit.lt_top [OrderTop α] (h : IsPredLimit a) : a < ⊤ :=\n  h.ne_top.lt_top\n\n"}
{"name":"Order.isPredPrelimit_of_pred_ne","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\nh : ∀ (b : α), Ne (Order.pred b) a\n⊢ Order.IsPredPrelimit a","decl":"theorem isPredPrelimit_of_pred_ne (h : ∀ b, pred b ≠ a) : IsPredPrelimit a := fun b hba =>\n  h b (CovBy.pred_eq hba)\n\n"}
{"name":"Order.isPredLimit_of_pred_ne","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\nh : ∀ (b : α), Ne (Order.pred b) a\n⊢ Order.IsPredPrelimit a","decl":"@[deprecated isPredPrelimit_of_pred_ne (since := \"2024-09-05\")]\nalias isPredLimit_of_pred_ne := isPredPrelimit_of_pred_ne\n\n"}
{"name":"Order.not_isPredPrelimit_iff","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\n⊢ Iff (Not (Order.IsPredPrelimit a)) (Exists fun b => And (Not (IsMin b)) (Eq (Order.pred b) a))","decl":"theorem not_isPredPrelimit_iff : ¬ IsPredPrelimit a ↔ ∃ b, ¬ IsMin b ∧ pred b = a := by\n  rw [← isSuccPrelimit_toDual_iff]\n  exact not_isSuccPrelimit_iff\n\n"}
{"name":"Order.mem_range_pred_of_not_isPredPrelimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\nh : Not (Order.IsPredPrelimit a)\n⊢ Membership.mem (Set.range Order.pred) a","decl":"/-- See `not_isPredPrelimit_iff` for a version that states that `a` is a successor of a value other\nthan itself. -/\ntheorem mem_range_pred_of_not_isPredPrelimit (h : ¬ IsPredPrelimit a) :\n    a ∈ range (pred : α → α) := by\n  obtain ⟨b, hb⟩ := not_isPredPrelimit_iff.1 h\n  exact ⟨b, hb.2⟩\n\n"}
{"name":"Order.mem_range_pred_of_not_isPredLimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\nh : Not (Order.IsPredPrelimit a)\n⊢ Membership.mem (Set.range Order.pred) a","decl":"@[deprecated mem_range_pred_of_not_isPredPrelimit (since := \"2024-09-05\")]\nalias mem_range_pred_of_not_isPredLimit := mem_range_pred_of_not_isPredPrelimit\n\n"}
{"name":"Order.mem_range_pred_or_isPredPrelimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\na : α\n⊢ Or (Membership.mem (Set.range Order.pred) a) (Order.IsPredPrelimit a)","decl":"theorem mem_range_pred_or_isPredPrelimit (a) : a ∈ range (pred : α → α) ∨ IsPredPrelimit a :=\n  or_iff_not_imp_right.2 <| mem_range_pred_of_not_isPredPrelimit\n\n"}
{"name":"Order.mem_range_pred_or_isPredLimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\na : α\n⊢ Or (Membership.mem (Set.range Order.pred) a) (Order.IsPredPrelimit a)","decl":"@[deprecated mem_range_pred_or_isPredPrelimit (since := \"2024-09-05\")]\nalias mem_range_pred_or_isPredLimit := mem_range_pred_or_isPredPrelimit\n\n"}
{"name":"Order.isPredPrelimit_of_pred_lt","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\nH : ∀ (b : α), GT.gt b a → LT.lt a (Order.pred b)\n⊢ Order.IsPredPrelimit a","decl":"theorem isPredPrelimit_of_pred_lt (H : ∀ b > a, a < pred b) : IsPredPrelimit a := fun a hab =>\n  (H a hab.lt).ne (CovBy.pred_eq hab).symm\n\n"}
{"name":"Order.isPredLimit_of_pred_lt","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\nH : ∀ (b : α), GT.gt b a → LT.lt a (Order.pred b)\n⊢ Order.IsPredPrelimit a","decl":"@[deprecated isPredPrelimit_of_pred_lt (since := \"2024-09-05\")]\nalias isPredLimit_of_pred_lt := isPredPrelimit_of_pred_lt\n\n"}
{"name":"Order.IsPredPrelimit.lt_pred","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na b : α\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\nha : Order.IsPredPrelimit a\nhb : LT.lt a b\n⊢ LT.lt a (Order.pred b)","decl":"theorem IsPredPrelimit.lt_pred (ha : IsPredPrelimit a) (hb : a < b) : a < pred b :=\n  ha.dual.succ_lt hb\n\n"}
{"name":"Order.IsPredLimit.lt_pred","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na b : α\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\nha : Order.IsPredLimit a\nhb : LT.lt a b\n⊢ LT.lt a (Order.pred b)","decl":"theorem IsPredLimit.lt_pred (ha : IsPredLimit a) (hb : a < b) : a < pred b :=\n  ha.isPredPrelimit.lt_pred hb\n\n"}
{"name":"Order.IsPredPrelimit.lt_pred_iff","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na b : α\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\nha : Order.IsPredPrelimit a\n⊢ Iff (LT.lt a (Order.pred b)) (LT.lt a b)","decl":"theorem IsPredPrelimit.lt_pred_iff (ha : IsPredPrelimit a) : a < pred b ↔ a < b :=\n  ha.dual.succ_lt_iff\n\n"}
{"name":"Order.IsPredLimit.lt_pred_iff","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na b : α\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\nha : Order.IsPredLimit a\n⊢ Iff (LT.lt a (Order.pred b)) (LT.lt a b)","decl":"theorem IsPredLimit.lt_pred_iff (ha : IsPredLimit a) : a < pred b ↔ a < b :=\n  ha.dual.succ_lt_iff\n\n"}
{"name":"Order.isPredPrelimit_iff_lt_pred","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\n⊢ Iff (Order.IsPredPrelimit a) (∀ (b : α), GT.gt b a → LT.lt a (Order.pred b))","decl":"theorem isPredPrelimit_iff_lt_pred : IsPredPrelimit a ↔ ∀ b > a, a < pred b :=\n  ⟨fun hb _ => hb.lt_pred, isPredPrelimit_of_pred_lt⟩\n\n"}
{"name":"Order.isPredLimit_iff_lt_pred","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\n⊢ Iff (Order.IsPredPrelimit a) (∀ (b : α), GT.gt b a → LT.lt a (Order.pred b))","decl":"@[deprecated isPredPrelimit_iff_lt_pred (since := \"2024-09-05\")]\nalias isPredLimit_iff_lt_pred := isPredPrelimit_iff_lt_pred\n\n"}
{"name":"Order.isPredPrelimit_iff_pred_ne","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\n⊢ Iff (Order.IsPredPrelimit a) (∀ (b : α), Ne (Order.pred b) a)","decl":"theorem isPredPrelimit_iff_pred_ne : IsPredPrelimit a ↔ ∀ b, pred b ≠ a :=\n  ⟨IsPredPrelimit.pred_ne, isPredPrelimit_of_pred_ne⟩\n\n"}
{"name":"Order.not_isPredPrelimit_iff'","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\n⊢ Iff (Not (Order.IsPredPrelimit a)) (Membership.mem (Set.range Order.pred) a)","decl":"theorem not_isPredPrelimit_iff' : ¬ IsPredPrelimit a ↔ a ∈ range (pred : α → α) := by\n  simp_rw [isPredPrelimit_iff_pred_ne, not_forall, not_ne_iff, mem_range]\n\n"}
{"name":"Order.IsPredPrelimit.isMax","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\nh : Order.IsPredPrelimit a\n⊢ IsMax a","decl":"protected theorem IsPredPrelimit.isMax (h : IsPredPrelimit a) : IsMax a :=\n  h.dual.isMin\n\n"}
{"name":"Order.IsPredLimit.isMax","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\nh : Order.IsPredPrelimit a\n⊢ IsMax a","decl":"@[deprecated IsPredPrelimit.isMax (since := \"2024-09-05\")]\nalias IsPredLimit.isMax := IsPredPrelimit.isMax\n\n"}
{"name":"Order.isPredPrelimit_iff","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\n⊢ Iff (Order.IsPredPrelimit a) (IsMax a)","decl":"@[simp]\ntheorem isPredPrelimit_iff : IsPredPrelimit a ↔ IsMax a :=\n  ⟨IsPredPrelimit.isMax, IsMax.isPredPrelimit⟩\n\n"}
{"name":"Order.not_isPredLimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\n⊢ Not (Order.IsPredLimit a)","decl":"@[simp]\ntheorem not_isPredLimit : ¬ IsPredLimit a :=\n  fun h ↦ h.not_isMax <| h.isPredPrelimit.isMax\n\n"}
{"name":"Order.not_isPredPrelimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝³ : PartialOrder α\ninst✝² : PredOrder α\ninst✝¹ : IsPredArchimedean α\ninst✝ : NoMaxOrder α\n⊢ Not (Order.IsPredPrelimit a)","decl":"theorem not_isPredPrelimit [NoMaxOrder α] : ¬ IsPredPrelimit a := by simp\n\n"}
{"name":"Order.IsPredPrelimit.le_iff_forall_le","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na b : α\ninst✝ : LinearOrder α\nh : Order.IsPredPrelimit a\n⊢ Iff (LE.le b a) (∀ ⦃c : α⦄, LT.lt a c → LE.le b c)","decl":"theorem IsPredPrelimit.le_iff_forall_le (h : IsPredPrelimit a) : b ≤ a ↔ ∀ ⦃c⦄, a < c → b ≤ c :=\n  h.dual.le_iff_forall_le\n\n"}
{"name":"Order.IsPredLimit.le_iff_forall_le","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na b : α\ninst✝ : LinearOrder α\nh : Order.IsPredLimit a\n⊢ Iff (LE.le b a) (∀ ⦃c : α⦄, LT.lt a c → LE.le b c)","decl":"theorem IsPredLimit.le_iff_forall_le (h : IsPredLimit a) : b ≤ a ↔ ∀ ⦃c⦄, a < c → b ≤ c :=\n  h.dual.le_iff_forall_le\n\n"}
{"name":"Order.IsPredPrelimit.lt_iff_exists_lt","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na b : α\ninst✝ : LinearOrder α\nh : Order.IsPredPrelimit b\n⊢ Iff (LT.lt b a) (Exists fun c => And (LT.lt b c) (LT.lt c a))","decl":"theorem IsPredPrelimit.lt_iff_exists_lt (h : IsPredPrelimit b) : b < a ↔ ∃ c, b < c ∧ c < a :=\n  h.dual.lt_iff_exists_lt\n\n"}
{"name":"Order.IsPredLimit.lt_iff_exists_lt","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na b : α\ninst✝ : LinearOrder α\nh : Order.IsPredLimit b\n⊢ Iff (LT.lt b a) (Exists fun c => And (LT.lt b c) (LT.lt c a))","decl":"theorem IsPredLimit.lt_iff_exists_lt (h : IsPredLimit b) : b < a ↔ ∃ c, b < c ∧ c < a :=\n  h.dual.lt_iff_exists_lt\n\n"}
{"name":"Order.IsPredPrelimit.isGLB_Ioi","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : LinearOrder α\nha : Order.IsPredPrelimit a\n⊢ IsGLB (Set.Ioi a) a","decl":"theorem IsPredPrelimit.isGLB_Ioi (ha : IsPredPrelimit a) : IsGLB (Ioi a) a :=\n  ha.dual.isLUB_Iio\n\n"}
{"name":"Order.IsPredLimit.isGLB_Ioi","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : LinearOrder α\nha : Order.IsPredLimit a\n⊢ IsGLB (Set.Ioi a) a","decl":"theorem IsPredLimit.isGLB_Ioi (ha : IsPredLimit a) : IsGLB (Ioi a) a :=\n  ha.dual.isLUB_Iio\n\n"}
{"name":"Order.isGLB_Ioi_iff_isPredPrelimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na : α\ninst✝ : LinearOrder α\n⊢ Iff (IsGLB (Set.Ioi a) a) (Order.IsPredPrelimit a)","decl":"theorem isGLB_Ioi_iff_isPredPrelimit : IsGLB (Ioi a) a ↔ IsPredPrelimit a := by\n  simpa using isLUB_Iio_iff_isSuccPrelimit (a := toDual a)\n\n"}
{"name":"Order.IsPredPrelimit.pred_le_iff","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na b : α\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\nhb : Order.IsPredPrelimit b\n⊢ Iff (LE.le (Order.pred a) b) (LE.le a b)","decl":"theorem IsPredPrelimit.pred_le_iff (hb : IsPredPrelimit b) : pred a ≤ b ↔ a ≤ b :=\n  hb.dual.le_succ_iff\n\n"}
{"name":"Order.IsPredLimit.pred_le_iff","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\na b : α\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\nhb : Order.IsPredLimit b\n⊢ Iff (LE.le (Order.pred a) b) (LE.le a b)","decl":"theorem IsPredLimit.pred_le_iff (hb : IsPredLimit b) : pred a ≤ b ↔ a ≤ b :=\n  hb.dual.le_succ_iff\n\n"}
{"name":"Order.isSuccPrelimitRecOn_of_isSuccPrelimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\nhs : (a : α) → Not (IsMax a) → C (Order.succ a)\nhl : (a : α) → Order.IsSuccPrelimit a → C a\nhb : Order.IsSuccPrelimit b\n⊢ Eq (Order.isSuccPrelimitRecOn b hs hl) (hl b hb)","decl":"theorem isSuccPrelimitRecOn_of_isSuccPrelimit (hb : IsSuccPrelimit b) :\n    isSuccPrelimitRecOn b hs hl = hl b hb :=\n  dif_pos hb\n\n"}
{"name":"Order.isSuccLimitRecOn_limit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\nhs : (a : α) → Not (IsMax a) → C (Order.succ a)\nhl : (a : α) → Order.IsSuccPrelimit a → C a\nhb : Order.IsSuccPrelimit b\n⊢ Eq (Order.isSuccPrelimitRecOn b hs hl) (hl b hb)","decl":"@[deprecated isSuccPrelimitRecOn_of_isSuccPrelimit (since := \"2024-09-05\")]\nalias isSuccLimitRecOn_limit := isSuccPrelimitRecOn_of_isSuccPrelimit\n"}
{"name":"Order.isSuccPrelimitRecOn_limit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\nhs : (a : α) → Not (IsMax a) → C (Order.succ a)\nhl : (a : α) → Order.IsSuccPrelimit a → C a\nhb : Order.IsSuccPrelimit b\n⊢ Eq (Order.isSuccPrelimitRecOn b hs hl) (hl b hb)","decl":"@[deprecated isSuccPrelimitRecOn_of_isSuccPrelimit (since := \"2024-09-14\")]\nalias isSuccPrelimitRecOn_limit := isSuccPrelimitRecOn_of_isSuccPrelimit\n\n"}
{"name":"Order.isSuccPrelimitRecOn_succ_of_not_isMax","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\nhs : (a : α) → Not (IsMax a) → C (Order.succ a)\nhl : (a : α) → Order.IsSuccPrelimit a → C a\nhb : Not (IsMax b)\n⊢ Eq (Order.isSuccPrelimitRecOn (Order.succ b) hs hl) (hs b hb)","decl":"theorem isSuccPrelimitRecOn_succ_of_not_isMax (hb : ¬ IsMax b) :\n    isSuccPrelimitRecOn (succ b) hs hl = hs b hb := by\n  have hb' := not_isSuccPrelimit_succ_of_not_isMax hb\n  have H := Classical.choose_spec (not_isSuccPrelimit_iff.1 hb')\n  rw [isSuccPrelimitRecOn, dif_neg hb', cast_eq_iff_heq]\n  congr\n  exacts [(succ_eq_succ_iff_of_not_isMax H.1 hb).1 H.2, proof_irrel_heq _ _]\n\n"}
{"name":"Order.isSuccLimitRecOn_succ'","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\nhs : (a : α) → Not (IsMax a) → C (Order.succ a)\nhl : (a : α) → Order.IsSuccPrelimit a → C a\nhb : Not (IsMax b)\n⊢ Eq (Order.isSuccPrelimitRecOn (Order.succ b) hs hl) (hs b hb)","decl":"@[deprecated isSuccPrelimitRecOn_succ_of_not_isMax (since := \"2024-09-05\")]\nalias isSuccLimitRecOn_succ' := isSuccPrelimitRecOn_succ_of_not_isMax\n"}
{"name":"Order.isSuccPrelimitRecOn_succ'","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\nhs : (a : α) → Not (IsMax a) → C (Order.succ a)\nhl : (a : α) → Order.IsSuccPrelimit a → C a\nhb : Not (IsMax b)\n⊢ Eq (Order.isSuccPrelimitRecOn (Order.succ b) hs hl) (hs b hb)","decl":"@[deprecated isSuccPrelimitRecOn_succ_of_not_isMax (since := \"2024-09-14\")]\nalias isSuccPrelimitRecOn_succ' := isSuccPrelimitRecOn_succ_of_not_isMax\n\n"}
{"name":"Order.isSuccPrelimitRecOn_succ","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nC : α → Sort u_2\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\nhs : (a : α) → Not (IsMax a) → C (Order.succ a)\nhl : (a : α) → Order.IsSuccPrelimit a → C a\ninst✝ : NoMaxOrder α\nb : α\n⊢ Eq (Order.isSuccPrelimitRecOn (Order.succ b) hs hl) (hs b ⋯)","decl":"@[simp]\ntheorem isSuccPrelimitRecOn_succ [NoMaxOrder α] (b : α) :\n    isSuccPrelimitRecOn (succ b) hs hl = hs b (not_isMax b) :=\n  isSuccPrelimitRecOn_succ_of_not_isMax _ _ _\n\n"}
{"name":"Order.isPredPrelimitRecOn_of_isPredPrelimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\nhs : (a : α) → Not (IsMin a) → C (Order.pred a)\nhl : (a : α) → Order.IsPredPrelimit a → C a\nhb : Order.IsPredPrelimit b\n⊢ Eq (Order.isPredPrelimitRecOn b hs hl) (hl b hb)","decl":"theorem isPredPrelimitRecOn_of_isPredPrelimit (hb : IsPredPrelimit b) :\n    isPredPrelimitRecOn b hs hl = hl b hb :=\n  isSuccPrelimitRecOn_of_isSuccPrelimit _ _ hb.dual\n\n"}
{"name":"Order.isPredLimitRecOn_limit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\nhs : (a : α) → Not (IsMin a) → C (Order.pred a)\nhl : (a : α) → Order.IsPredPrelimit a → C a\nhb : Order.IsPredPrelimit b\n⊢ Eq (Order.isPredPrelimitRecOn b hs hl) (hl b hb)","decl":"@[deprecated isPredPrelimitRecOn_of_isPredPrelimit (since := \"2024-09-05\")]\nalias isPredLimitRecOn_limit := isPredPrelimitRecOn_of_isPredPrelimit\n"}
{"name":"Order.isPredPrelimitRecOn_limit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\nhs : (a : α) → Not (IsMin a) → C (Order.pred a)\nhl : (a : α) → Order.IsPredPrelimit a → C a\nhb : Order.IsPredPrelimit b\n⊢ Eq (Order.isPredPrelimitRecOn b hs hl) (hl b hb)","decl":"@[deprecated isPredPrelimitRecOn_of_isPredPrelimit (since := \"2024-09-14\")]\nalias isPredPrelimitRecOn_limit := isPredPrelimitRecOn_of_isPredPrelimit\n\n"}
{"name":"Order.isPredPrelimitRecOn_pred_of_not_isMin","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\nhs : (a : α) → Not (IsMin a) → C (Order.pred a)\nhl : (a : α) → Order.IsPredPrelimit a → C a\nhb : Not (IsMin b)\n⊢ Eq (Order.isPredPrelimitRecOn (Order.pred b) hs hl) (hs b hb)","decl":"theorem isPredPrelimitRecOn_pred_of_not_isMin (hb : ¬ IsMin b) :\n    isPredPrelimitRecOn (pred b) hs hl = hs b hb :=\n  isSuccPrelimitRecOn_succ_of_not_isMax (α := αᵒᵈ) _ _ _\n\n"}
{"name":"Order.isPredLimitRecOn_pred'","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\nhs : (a : α) → Not (IsMin a) → C (Order.pred a)\nhl : (a : α) → Order.IsPredPrelimit a → C a\nhb : Not (IsMin b)\n⊢ Eq (Order.isPredPrelimitRecOn (Order.pred b) hs hl) (hs b hb)","decl":"@[deprecated isPredPrelimitRecOn_pred_of_not_isMin (since := \"2024-09-05\")]\nalias isPredLimitRecOn_pred' := isPredPrelimitRecOn_pred_of_not_isMin\n"}
{"name":"Order.isPredPrelimitRecOn_pred'","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\nhs : (a : α) → Not (IsMin a) → C (Order.pred a)\nhl : (a : α) → Order.IsPredPrelimit a → C a\nhb : Not (IsMin b)\n⊢ Eq (Order.isPredPrelimitRecOn (Order.pred b) hs hl) (hs b hb)","decl":"@[deprecated isPredPrelimitRecOn_pred_of_not_isMin (since := \"2024-09-14\")]\nalias isPredPrelimitRecOn_pred' := isPredPrelimitRecOn_pred_of_not_isMin\n\n"}
{"name":"Order.isPredPrelimitRecOn_pred","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nC : α → Sort u_2\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\nhs : (a : α) → Not (IsMin a) → C (Order.pred a)\nhl : (a : α) → Order.IsPredPrelimit a → C a\ninst✝ : NoMinOrder α\nb : α\n⊢ Eq (Order.isPredPrelimitRecOn (Order.pred b) hs hl) (hs b ⋯)","decl":"@[simp]\ntheorem isPredPrelimitRecOn_pred [NoMinOrder α] (b : α) :\n    isPredPrelimitRecOn (pred b) hs hl = hs b (not_isMin b) :=\n  isPredPrelimitRecOn_pred_of_not_isMin _ _ _\n\n"}
{"name":"Order.isSuccLimitRecOn_of_isSuccLimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\nhm : (a : α) → IsMin a → C a\nhs : (a : α) → Not (IsMax a) → C (Order.succ a)\nhl : (a : α) → Order.IsSuccLimit a → C a\nhb : Order.IsSuccLimit b\n⊢ Eq (Order.isSuccLimitRecOn b hm hs hl) (hl b hb)","decl":"@[simp]\ntheorem isSuccLimitRecOn_of_isSuccLimit (hb : IsSuccLimit b) :\n    isSuccLimitRecOn b hm hs hl = hl b hb := by\n  rw [isSuccLimitRecOn, isSuccPrelimitRecOn_of_isSuccPrelimit _ _ hb.isSuccPrelimit,\n    dif_neg hb.not_isMin]\n\n"}
{"name":"Order.isSuccLimitRecOn_succ_of_not_isMax","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\nhm : (a : α) → IsMin a → C a\nhs : (a : α) → Not (IsMax a) → C (Order.succ a)\nhl : (a : α) → Order.IsSuccLimit a → C a\nhb : Not (IsMax b)\n⊢ Eq (Order.isSuccLimitRecOn (Order.succ b) hm hs hl) (hs b hb)","decl":"theorem isSuccLimitRecOn_succ_of_not_isMax (hb : ¬ IsMax b) :\n    isSuccLimitRecOn (succ b) hm hs hl = hs b hb := by\n  rw [isSuccLimitRecOn, isSuccPrelimitRecOn_succ_of_not_isMax]\n\n"}
{"name":"Order.isSuccLimitRecOn_succ","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nC : α → Sort u_2\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\nhm : (a : α) → IsMin a → C a\nhs : (a : α) → Not (IsMax a) → C (Order.succ a)\nhl : (a : α) → Order.IsSuccLimit a → C a\ninst✝ : NoMaxOrder α\nb : α\n⊢ Eq (Order.isSuccLimitRecOn (Order.succ b) hm hs hl) (hs b ⋯)","decl":"@[simp]\ntheorem isSuccLimitRecOn_succ [NoMaxOrder α] (b : α) :\n    isSuccLimitRecOn (succ b) hm hs hl = hs b (not_isMax b) :=\n  isSuccLimitRecOn_succ_of_not_isMax hm hs hl _\n\n"}
{"name":"Order.isSuccLimitRecOn_of_isMin","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\nhm : (a : α) → IsMin a → C a\nhs : (a : α) → Not (IsMax a) → C (Order.succ a)\nhl : (a : α) → Order.IsSuccLimit a → C a\nhb : IsMin b\n⊢ Eq (Order.isSuccLimitRecOn b hm hs hl) (hm b hb)","decl":"theorem isSuccLimitRecOn_of_isMin (hb : IsMin b) : isSuccLimitRecOn b hm hs hl = hm b hb := by\n  rw [isSuccLimitRecOn, isSuccPrelimitRecOn_of_isSuccPrelimit _ _ hb.isSuccPrelimit, dif_pos hb]\n\n"}
{"name":"Order.isPredLimitRecOn_of_isPredLimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\nhm : (a : α) → IsMax a → C a\nhs : (a : α) → Not (IsMin a) → C (Order.pred a)\nhl : (a : α) → Order.IsPredLimit a → C a\nhb : Order.IsPredLimit b\n⊢ Eq (Order.isPredLimitRecOn b hm hs hl) (hl b hb)","decl":"@[simp]\ntheorem isPredLimitRecOn_of_isPredLimit (hb : IsPredLimit b) :\n    isPredLimitRecOn b hm hs hl = hl b hb :=\n  isSuccLimitRecOn_of_isSuccLimit (α := αᵒᵈ) hm hs _ hb.dual\n\n"}
{"name":"Order.isPredLimitRecOn_pred_of_not_isMin","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\nhm : (a : α) → IsMax a → C a\nhs : (a : α) → Not (IsMin a) → C (Order.pred a)\nhl : (a : α) → Order.IsPredLimit a → C a\nhb : Not (IsMin b)\n⊢ Eq (Order.isPredLimitRecOn (Order.pred b) hm hs hl) (hs b hb)","decl":"theorem isPredLimitRecOn_pred_of_not_isMin (hb : ¬ IsMin b) :\n    isPredLimitRecOn (pred b) hm hs hl = hs b hb :=\n  isSuccLimitRecOn_succ_of_not_isMax (α := αᵒᵈ) hm hs _ hb\n\n"}
{"name":"Order.isPredLimitRecOn_pred","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\nhm : (a : α) → IsMax a → C a\nhs : (a : α) → Not (IsMin a) → C (Order.pred a)\nhl : (a : α) → Order.IsPredLimit a → C a\ninst✝ : NoMinOrder α\n⊢ Eq (Order.isPredLimitRecOn (Order.pred b) hm hs hl) (hs b ⋯)","decl":"@[simp]\ntheorem isPredLimitRecOn_pred [NoMinOrder α] :\n    isPredLimitRecOn (pred b) hm hs hl = hs b (not_isMin b) :=\n  isSuccLimitRecOn_succ (α := αᵒᵈ) hm hs _ b\n\n"}
{"name":"Order.isPredLimitRecOn_of_isMax","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\nhm : (a : α) → IsMax a → C a\nhs : (a : α) → Not (IsMin a) → C (Order.pred a)\nhl : (a : α) → Order.IsPredLimit a → C a\nhb : IsMax b\n⊢ Eq (Order.isPredLimitRecOn b hm hs hl) (hm b hb)","decl":"theorem isPredLimitRecOn_of_isMax (hb : IsMax b) : isPredLimitRecOn b hm hs hl = hm b hb :=\n  isSuccLimitRecOn_of_isMin (α := αᵒᵈ) hm hs _ hb\n\n"}
{"name":"SuccOrder.prelimitRecOn_of_isSuccPrelimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : WellFoundedLT α\nhs : (a : α) → Not (IsMax a) → C a → C (Order.succ a)\nhl : (a : α) → Order.IsSuccPrelimit a → ((b : α) → LT.lt b a → C b) → C a\nhb : Order.IsSuccPrelimit b\n⊢ Eq (SuccOrder.prelimitRecOn b hs hl) (hl b hb fun x x_1 => SuccOrder.prelimitRecOn x hs hl)","decl":"@[simp]\ntheorem prelimitRecOn_of_isSuccPrelimit (hb : IsSuccPrelimit b) :\n    prelimitRecOn b hs hl = hl b hb fun x _ ↦ SuccOrder.prelimitRecOn x hs hl := by\n  rw [prelimitRecOn, WellFounded.fix_eq, dif_pos hb]; rfl\n\n"}
{"name":"SuccOrder.limitRecOn_limit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : WellFoundedLT α\nhs : (a : α) → Not (IsMax a) → C a → C (Order.succ a)\nhl : (a : α) → Order.IsSuccPrelimit a → ((b : α) → LT.lt b a → C b) → C a\nhb : Order.IsSuccPrelimit b\n⊢ Eq (SuccOrder.prelimitRecOn b hs hl) (hl b hb fun x x_1 => SuccOrder.prelimitRecOn x hs hl)","decl":"@[deprecated prelimitRecOn_of_isSuccPrelimit (since := \"2024-09-05\")]\nalias limitRecOn_limit := prelimitRecOn_of_isSuccPrelimit\n"}
{"name":"SuccOrder.prelimitRecOn_limit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : WellFoundedLT α\nhs : (a : α) → Not (IsMax a) → C a → C (Order.succ a)\nhl : (a : α) → Order.IsSuccPrelimit a → ((b : α) → LT.lt b a → C b) → C a\nhb : Order.IsSuccPrelimit b\n⊢ Eq (SuccOrder.prelimitRecOn b hs hl) (hl b hb fun x x_1 => SuccOrder.prelimitRecOn x hs hl)","decl":"@[deprecated prelimitRecOn_of_isSuccPrelimit (since := \"2024-09-14\")]\nalias prelimitRecOn_limit := prelimitRecOn_of_isSuccPrelimit\n\n"}
{"name":"SuccOrder.prelimitRecOn_succ_of_not_isMax","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\ninst✝ : WellFoundedLT α\nhs : (a : α) → Not (IsMax a) → C a → C (Order.succ a)\nhl : (a : α) → Order.IsSuccPrelimit a → ((b : α) → LT.lt b a → C b) → C a\nhb : Not (IsMax b)\n⊢ Eq (SuccOrder.prelimitRecOn (Order.succ b) hs hl) (hs b hb (SuccOrder.prelimitRecOn b hs hl))","decl":"theorem prelimitRecOn_succ_of_not_isMax (hb : ¬ IsMax b) :\n    prelimitRecOn (Order.succ b) hs hl = hs b hb (prelimitRecOn b hs hl) := by\n  have h := not_isSuccPrelimit_succ_of_not_isMax hb\n  have H := Classical.choose_spec (not_isSuccPrelimit_iff.1 h)\n  rw [prelimitRecOn, WellFounded.fix_eq, dif_neg h]\n  have {a c : α} {ha hc} {x : ∀ a, C a} (h : a = c) :\n    cast (congr_arg (C ∘ succ) h) (hs a ha (x a)) = hs c hc (x c) := by subst h; rfl\n  exact this <| (succ_eq_succ_iff_of_not_isMax H.1 hb).1 H.2\n\n"}
{"name":"SuccOrder.limitRecOn_succ'","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\ninst✝ : WellFoundedLT α\nhs : (a : α) → Not (IsMax a) → C a → C (Order.succ a)\nhl : (a : α) → Order.IsSuccPrelimit a → ((b : α) → LT.lt b a → C b) → C a\nhb : Not (IsMax b)\n⊢ Eq (SuccOrder.prelimitRecOn (Order.succ b) hs hl) (hs b hb (SuccOrder.prelimitRecOn b hs hl))","decl":"@[deprecated prelimitRecOn_succ_of_not_isMax (since := \"2024-09-05\")]\nalias limitRecOn_succ' := prelimitRecOn_succ_of_not_isMax\n"}
{"name":"SuccOrder.prelimitRecOn_succ'","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\ninst✝ : WellFoundedLT α\nhs : (a : α) → Not (IsMax a) → C a → C (Order.succ a)\nhl : (a : α) → Order.IsSuccPrelimit a → ((b : α) → LT.lt b a → C b) → C a\nhb : Not (IsMax b)\n⊢ Eq (SuccOrder.prelimitRecOn (Order.succ b) hs hl) (hs b hb (SuccOrder.prelimitRecOn b hs hl))","decl":"@[deprecated prelimitRecOn_succ_of_not_isMax (since := \"2024-09-14\")]\nalias prelimitRecOn_succ' := prelimitRecOn_succ_of_not_isMax\n\n"}
{"name":"SuccOrder.prelimitRecOn_succ","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nC : α → Sort u_2\ninst✝³ : LinearOrder α\ninst✝² : SuccOrder α\ninst✝¹ : WellFoundedLT α\nhs : (a : α) → Not (IsMax a) → C a → C (Order.succ a)\nhl : (a : α) → Order.IsSuccPrelimit a → ((b : α) → LT.lt b a → C b) → C a\ninst✝ : NoMaxOrder α\nb : α\n⊢ Eq (SuccOrder.prelimitRecOn (Order.succ b) hs hl) (hs b ⋯ (SuccOrder.prelimitRecOn b hs hl))","decl":"@[simp]\ntheorem prelimitRecOn_succ [NoMaxOrder α] (b : α) :\n    prelimitRecOn (Order.succ b) hs hl = hs b (not_isMax b) (prelimitRecOn b hs hl) :=\n  prelimitRecOn_succ_of_not_isMax _ _ _\n\n"}
{"name":"SuccOrder.limitRecOn_isMin","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : WellFoundedLT α\nhm : (a : α) → IsMin a → C a\nhs : (a : α) → Not (IsMax a) → C a → C (Order.succ a)\nhl : (a : α) → Order.IsSuccLimit a → ((b : α) → LT.lt b a → C b) → C a\nhb : IsMin b\n⊢ Eq (SuccOrder.limitRecOn b hm hs hl) (hm b hb)","decl":"@[simp]\ntheorem limitRecOn_isMin (hb : IsMin b) : limitRecOn b hm hs hl = hm b hb := by\n  rw [limitRecOn, prelimitRecOn_of_isSuccPrelimit _ _ hb.isSuccPrelimit, dif_pos hb]\n\n"}
{"name":"SuccOrder.limitRecOn_of_isSuccLimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : WellFoundedLT α\nhm : (a : α) → IsMin a → C a\nhs : (a : α) → Not (IsMax a) → C a → C (Order.succ a)\nhl : (a : α) → Order.IsSuccLimit a → ((b : α) → LT.lt b a → C b) → C a\nhb : Order.IsSuccLimit b\n⊢ Eq (SuccOrder.limitRecOn b hm hs hl) (hl b hb fun x x_1 => SuccOrder.limitRecOn x hm hs hl)","decl":"@[simp]\ntheorem limitRecOn_of_isSuccLimit (hb : IsSuccLimit b) :\n    limitRecOn b hm hs hl = hl b hb fun x _ ↦ limitRecOn x hm hs hl := by\n  rw [limitRecOn, prelimitRecOn_of_isSuccPrelimit _ _ hb.isSuccPrelimit, dif_neg hb.not_isMin]; rfl\n\n"}
{"name":"SuccOrder.limitRecOn_succ_of_not_isMax","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\ninst✝ : WellFoundedLT α\nhm : (a : α) → IsMin a → C a\nhs : (a : α) → Not (IsMax a) → C a → C (Order.succ a)\nhl : (a : α) → Order.IsSuccLimit a → ((b : α) → LT.lt b a → C b) → C a\nhb : Not (IsMax b)\n⊢ Eq (SuccOrder.limitRecOn (Order.succ b) hm hs hl) (hs b hb (SuccOrder.limitRecOn b hm hs hl))","decl":"theorem limitRecOn_succ_of_not_isMax (hb : ¬ IsMax b) :\n    limitRecOn (Order.succ b) hm hs hl = hs b hb (limitRecOn b hm hs hl) := by\n  rw [limitRecOn, prelimitRecOn_succ_of_not_isMax]; rfl\n\n"}
{"name":"SuccOrder.limitRecOn_succ","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nC : α → Sort u_2\ninst✝³ : LinearOrder α\ninst✝² : SuccOrder α\ninst✝¹ : WellFoundedLT α\nhm : (a : α) → IsMin a → C a\nhs : (a : α) → Not (IsMax a) → C a → C (Order.succ a)\nhl : (a : α) → Order.IsSuccLimit a → ((b : α) → LT.lt b a → C b) → C a\ninst✝ : NoMaxOrder α\nb : α\n⊢ Eq (SuccOrder.limitRecOn (Order.succ b) hm hs hl) (hs b ⋯ (SuccOrder.limitRecOn b hm hs hl))","decl":"@[simp]\ntheorem limitRecOn_succ [NoMaxOrder α] (b : α) :\n    limitRecOn (Order.succ b) hm hs hl = hs b (not_isMax b) (limitRecOn b hm hs hl) :=\n  limitRecOn_succ_of_not_isMax hm hs hl _\n\n"}
{"name":"PredOrder.prelimitRecOn_of_isPredPrelimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\ninst✝ : WellFoundedGT α\nhp : (a : α) → Not (IsMin a) → C a → C (Order.pred a)\nhl : (a : α) → Order.IsPredPrelimit a → ((b : α) → GT.gt b a → C b) → C a\nhb : Order.IsPredPrelimit b\n⊢ Eq (PredOrder.prelimitRecOn b hp hl) (hl b hb fun x x_1 => PredOrder.prelimitRecOn x hp hl)","decl":"@[simp]\ntheorem prelimitRecOn_of_isPredPrelimit (hb : IsPredPrelimit b) :\n    prelimitRecOn b hp hl = hl b hb fun x _ ↦ prelimitRecOn x hp hl :=\n  SuccOrder.prelimitRecOn_of_isSuccPrelimit _ _ hb.dual\n\n"}
{"name":"PredOrder.limitRecOn_limit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\ninst✝ : WellFoundedGT α\nhp : (a : α) → Not (IsMin a) → C a → C (Order.pred a)\nhl : (a : α) → Order.IsPredPrelimit a → ((b : α) → GT.gt b a → C b) → C a\nhb : Order.IsPredPrelimit b\n⊢ Eq (PredOrder.prelimitRecOn b hp hl) (hl b hb fun x x_1 => PredOrder.prelimitRecOn x hp hl)","decl":"@[deprecated prelimitRecOn_of_isPredPrelimit (since := \"2024-09-05\")]\nalias limitRecOn_limit := prelimitRecOn_of_isPredPrelimit\n"}
{"name":"PredOrder.prelimitRecOn_limit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\ninst✝ : WellFoundedGT α\nhp : (a : α) → Not (IsMin a) → C a → C (Order.pred a)\nhl : (a : α) → Order.IsPredPrelimit a → ((b : α) → GT.gt b a → C b) → C a\nhb : Order.IsPredPrelimit b\n⊢ Eq (PredOrder.prelimitRecOn b hp hl) (hl b hb fun x x_1 => PredOrder.prelimitRecOn x hp hl)","decl":"@[deprecated prelimitRecOn_of_isPredPrelimit (since := \"2024-09-14\")]\nalias prelimitRecOn_limit := prelimitRecOn_of_isPredPrelimit\n\n"}
{"name":"PredOrder.prelimitRecOn_pred_of_not_isMin","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\ninst✝ : WellFoundedGT α\nhp : (a : α) → Not (IsMin a) → C a → C (Order.pred a)\nhl : (a : α) → Order.IsPredPrelimit a → ((b : α) → GT.gt b a → C b) → C a\nhb : Not (IsMin b)\n⊢ Eq (PredOrder.prelimitRecOn (Order.pred b) hp hl) (hp b hb (PredOrder.prelimitRecOn b hp hl))","decl":"theorem prelimitRecOn_pred_of_not_isMin (hb : ¬ IsMin b) :\n    prelimitRecOn (Order.pred b) hp hl = hp b hb (prelimitRecOn b hp hl) :=\n  SuccOrder.prelimitRecOn_succ_of_not_isMax _ _ _\n\n"}
{"name":"PredOrder.limitRecOn_pred'","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\ninst✝ : WellFoundedGT α\nhp : (a : α) → Not (IsMin a) → C a → C (Order.pred a)\nhl : (a : α) → Order.IsPredPrelimit a → ((b : α) → GT.gt b a → C b) → C a\nhb : Not (IsMin b)\n⊢ Eq (PredOrder.prelimitRecOn (Order.pred b) hp hl) (hp b hb (PredOrder.prelimitRecOn b hp hl))","decl":"@[deprecated prelimitRecOn_pred_of_not_isMin (since := \"2024-09-05\")]\nalias limitRecOn_pred' := prelimitRecOn_pred_of_not_isMin\n"}
{"name":"PredOrder.prelimitRecOn_pred'","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\ninst✝ : WellFoundedGT α\nhp : (a : α) → Not (IsMin a) → C a → C (Order.pred a)\nhl : (a : α) → Order.IsPredPrelimit a → ((b : α) → GT.gt b a → C b) → C a\nhb : Not (IsMin b)\n⊢ Eq (PredOrder.prelimitRecOn (Order.pred b) hp hl) (hp b hb (PredOrder.prelimitRecOn b hp hl))","decl":"@[deprecated prelimitRecOn_pred_of_not_isMin (since := \"2024-09-14\")]\nalias prelimitRecOn_pred' := prelimitRecOn_pred_of_not_isMin\n\n"}
{"name":"PredOrder.prelimitRecOn_pred","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nC : α → Sort u_2\ninst✝³ : LinearOrder α\ninst✝² : PredOrder α\ninst✝¹ : WellFoundedGT α\nhp : (a : α) → Not (IsMin a) → C a → C (Order.pred a)\nhl : (a : α) → Order.IsPredPrelimit a → ((b : α) → GT.gt b a → C b) → C a\ninst✝ : NoMinOrder α\nb : α\n⊢ Eq (PredOrder.prelimitRecOn (Order.pred b) hp hl) (hp b ⋯ (PredOrder.prelimitRecOn b hp hl))","decl":"@[simp]\ntheorem prelimitRecOn_pred [NoMinOrder α] (b : α) :\n    prelimitRecOn (Order.pred b) hp hl = hp b (not_isMin b) (prelimitRecOn b hp hl) :=\n  prelimitRecOn_pred_of_not_isMin _ _ _\n\n"}
{"name":"PredOrder.limitRecOn_isMax","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\ninst✝ : WellFoundedGT α\nhm : (a : α) → IsMax a → C a\nhs : (a : α) → Not (IsMin a) → C a → C (Order.pred a)\nhl : (a : α) → Order.IsPredLimit a → ((b : α) → GT.gt b a → C b) → C a\nhb : IsMax b\n⊢ Eq (PredOrder.limitRecOn b hm hs hl) (hm b hb)","decl":"@[simp]\ntheorem limitRecOn_isMax (hb : IsMax b) : limitRecOn b hm hs hl = hm b hb :=\n  SuccOrder.limitRecOn_isMin (α := αᵒᵈ) hm hs _ hb\n\n"}
{"name":"PredOrder.limitRecOn_of_isPredLimit","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\ninst✝ : WellFoundedGT α\nhm : (a : α) → IsMax a → C a\nhs : (a : α) → Not (IsMin a) → C a → C (Order.pred a)\nhl : (a : α) → Order.IsPredLimit a → ((b : α) → GT.gt b a → C b) → C a\nhb : Order.IsPredLimit b\n⊢ Eq (PredOrder.limitRecOn b hm hs hl) (hl b hb fun x x_1 => PredOrder.limitRecOn x hm hs hl)","decl":"@[simp]\ntheorem limitRecOn_of_isPredLimit (hb : IsPredLimit b) :\n    limitRecOn b hm hs hl = hl b hb fun x _ ↦ limitRecOn x hm hs hl :=\n  SuccOrder.limitRecOn_of_isSuccLimit (α := αᵒᵈ) hm hs _ hb.dual\n\n"}
{"name":"PredOrder.limitRecOn_pred_of_not_isMin","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nb : α\nC : α → Sort u_2\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\ninst✝ : WellFoundedGT α\nhm : (a : α) → IsMax a → C a\nhs : (a : α) → Not (IsMin a) → C a → C (Order.pred a)\nhl : (a : α) → Order.IsPredLimit a → ((b : α) → GT.gt b a → C b) → C a\nhb : Not (IsMin b)\n⊢ Eq (PredOrder.limitRecOn (Order.pred b) hm hs hl) (hs b hb (PredOrder.limitRecOn b hm hs hl))","decl":"theorem limitRecOn_pred_of_not_isMin (hb : ¬ IsMin b) :\n    limitRecOn (Order.pred b) hm hs hl = hs b hb (limitRecOn b hm hs hl) :=\n  SuccOrder.limitRecOn_succ_of_not_isMax (α := αᵒᵈ) hm hs _ hb\n\n"}
{"name":"PredOrder.limitRecOn_pred","module":"Mathlib.Order.SuccPred.Limit","initialProofState":"α : Type u_1\nC : α → Sort u_2\ninst✝³ : LinearOrder α\ninst✝² : PredOrder α\ninst✝¹ : WellFoundedGT α\nhm : (a : α) → IsMax a → C a\nhs : (a : α) → Not (IsMin a) → C a → C (Order.pred a)\nhl : (a : α) → Order.IsPredLimit a → ((b : α) → GT.gt b a → C b) → C a\ninst✝ : NoMinOrder α\nb : α\n⊢ Eq (PredOrder.limitRecOn (Order.pred b) hm hs hl) (hs b ⋯ (PredOrder.limitRecOn b hm hs hl))","decl":"@[simp]\ntheorem limitRecOn_pred [NoMinOrder α] (b : α) :\n    limitRecOn (Order.pred b) hm hs hl = hs b (not_isMin b) (limitRecOn b hm hs hl) :=\n  SuccOrder.limitRecOn_succ (α := αᵒᵈ) hm hs _ b\n\n"}
