{"name":"Nat.cast_sub","module":"Mathlib.Data.Int.Cast.Basic","initialProofState":"R : Type u\ninst✝ : AddGroupWithOne R\nm n : Nat\nh : LE.le m n\n⊢ Eq (↑(HSub.hSub n m)) (HSub.hSub ↑n ↑m)","decl":"@[simp, norm_cast]\ntheorem cast_sub {m n} (h : m ≤ n) : ((n - m : ℕ) : R) = n - m :=\n  eq_sub_of_add_eq <| by rw [← cast_add, Nat.sub_add_cancel h]\n-- `HasLiftT` appeared in the type signature\n\n"}
{"name":"Nat.cast_pred","module":"Mathlib.Data.Int.Cast.Basic","initialProofState":"R : Type u\ninst✝ : AddGroupWithOne R\nn : Nat\na✝ : LT.lt 0 n\n⊢ Eq (↑(HSub.hSub n 1)) (HSub.hSub (↑n) 1)","decl":"@[simp, norm_cast]\ntheorem cast_pred : ∀ {n}, 0 < n → ((n - 1 : ℕ) : R) = n - 1\n  | 0, h => by cases h\n  | n + 1, _ => by rw [cast_succ, add_sub_cancel_right]; rfl\n\n"}
{"name":"Int.cast_negSucc","module":"Mathlib.Data.Int.Cast.Basic","initialProofState":"R : Type u\ninst✝ : AddGroupWithOne R\nn : Nat\n⊢ Eq (↑(Int.negSucc n)) (Neg.neg ↑(HAdd.hAdd n 1))","decl":"@[simp, norm_cast squash]\ntheorem cast_negSucc (n : ℕ) : (-[n+1] : R) = -(n + 1 : ℕ) :=\n  AddGroupWithOne.intCast_negSucc n\n-- expected `n` to be implicit, and `HasLiftT`\n\n"}
{"name":"Int.cast_zero","module":"Mathlib.Data.Int.Cast.Basic","initialProofState":"R : Type u\ninst✝ : AddGroupWithOne R\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem cast_zero : ((0 : ℤ) : R) = 0 :=\n  (AddGroupWithOne.intCast_ofNat 0).trans Nat.cast_zero\n-- type had `HasLiftT`\n\n-- This lemma competes with `Int.ofNat_eq_natCast` to come later\n"}
{"name":"Int.cast_natCast","module":"Mathlib.Data.Int.Cast.Basic","initialProofState":"R : Type u\ninst✝ : AddGroupWithOne R\nn : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[simp high, nolint simpNF, norm_cast]\ntheorem cast_natCast (n : ℕ) : ((n : ℤ) : R) = n :=\n  AddGroupWithOne.intCast_ofNat _\n-- expected `n` to be implicit, and `HasLiftT`\n\n"}
{"name":"Int.cast_ofNat","module":"Mathlib.Data.Int.Cast.Basic","initialProofState":"R : Type u\ninst✝¹ : AddGroupWithOne R\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (↑(OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp, norm_cast]\ntheorem cast_ofNat (n : ℕ) [n.AtLeastTwo] :\n    ((ofNat(n) : ℤ) : R) = ofNat(n) := by\n  simpa only [OfNat.ofNat] using AddGroupWithOne.intCast_ofNat (R := R) n\n\n"}
{"name":"Int.cast_one","module":"Mathlib.Data.Int.Cast.Basic","initialProofState":"R : Type u\ninst✝ : AddGroupWithOne R\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem cast_one : ((1 : ℤ) : R) = 1 := by\n  erw [cast_natCast, Nat.cast_one]\n-- type had `HasLiftT`\n\n"}
{"name":"Int.cast_neg","module":"Mathlib.Data.Int.Cast.Basic","initialProofState":"R : Type u\ninst✝ : AddGroupWithOne R\nn : Int\n⊢ Eq (↑(Neg.neg n)) (Neg.neg ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_neg : ∀ n, ((-n : ℤ) : R) = -n\n  | (0 : ℕ) => by simp\n  | (n + 1 : ℕ) => by erw [cast_natCast, cast_negSucc]\n  | -[n+1] => by erw [cast_natCast, cast_negSucc, neg_neg]\n-- type had `HasLiftT`\n\n"}
{"name":"Int.cast_subNatNat","module":"Mathlib.Data.Int.Cast.Basic","initialProofState":"R : Type u\ninst✝ : AddGroupWithOne R\nm n : Nat\n⊢ Eq (↑(Int.subNatNat m n)) (HSub.hSub ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_subNatNat (m n) : ((Int.subNatNat m n : ℤ) : R) = m - n := by\n  unfold subNatNat\n  cases e : n - m\n  · simp only [ofNat_eq_coe]\n    simp [e, Nat.le_of_sub_eq_zero e]\n  · rw [cast_negSucc, ← e, Nat.cast_sub <| _root_.le_of_lt <| Nat.lt_of_sub_eq_succ e, neg_sub]\n-- type had `HasLiftT`\n\n"}
{"name":"Int.cast_negOfNat","module":"Mathlib.Data.Int.Cast.Basic","initialProofState":"R : Type u\ninst✝ : AddGroupWithOne R\nn : Nat\n⊢ Eq (↑(Int.negOfNat n)) (Neg.neg ↑n)","decl":"@[simp]\ntheorem cast_negOfNat (n : ℕ) : ((negOfNat n : ℤ) : R) = -n := by simp [Int.cast_neg, negOfNat_eq]\n\n"}
{"name":"Int.cast_add","module":"Mathlib.Data.Int.Cast.Basic","initialProofState":"R : Type u\ninst✝ : AddGroupWithOne R\nm n : Int\n⊢ Eq (↑(HAdd.hAdd m n)) (HAdd.hAdd ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_add : ∀ m n, ((m + n : ℤ) : R) = m + n\n  | (m : ℕ), (n : ℕ) => by simp [-Int.natCast_add, ← Int.ofNat_add]\n  | (m : ℕ), -[n+1] => by erw [cast_subNatNat, cast_natCast, cast_negSucc, sub_eq_add_neg]\n  | -[m+1], (n : ℕ) => by\n    erw [cast_subNatNat, cast_natCast, cast_negSucc, sub_eq_iff_eq_add, add_assoc,\n      eq_neg_add_iff_add_eq, ← Nat.cast_add, ← Nat.cast_add, Nat.add_comm]\n  | -[m+1], -[n+1] =>\n    show (-[m + n + 1+1] : R) = _ by\n      rw [cast_negSucc, cast_negSucc, cast_negSucc, ← neg_add_rev, ← Nat.cast_add,\n        Nat.add_right_comm m n 1, Nat.add_assoc, Nat.add_comm]\n-- type had `HasLiftT`\n\n"}
{"name":"Int.cast_sub","module":"Mathlib.Data.Int.Cast.Basic","initialProofState":"R : Type u\ninst✝ : AddGroupWithOne R\nm n : Int\n⊢ Eq (↑(HSub.hSub m n)) (HSub.hSub ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem cast_sub (m n) : ((m - n : ℤ) : R) = m - n := by\n  simp [Int.sub_eq_add_neg, sub_eq_add_neg, Int.cast_neg, Int.cast_add]\n-- type had `HasLiftT`\n\n"}
{"name":"Int.cast_two","module":"Mathlib.Data.Int.Cast.Basic","initialProofState":"R : Type u\ninst✝ : AddGroupWithOne R\n⊢ Eq (↑2) 2","decl":"theorem cast_two : ((2 : ℤ) : R) = 2 := cast_ofNat _\n\n"}
{"name":"Int.cast_three","module":"Mathlib.Data.Int.Cast.Basic","initialProofState":"R : Type u\ninst✝ : AddGroupWithOne R\n⊢ Eq (↑3) 3","decl":"theorem cast_three : ((3 : ℤ) : R) = 3 := cast_ofNat _\n\n"}
{"name":"Int.cast_four","module":"Mathlib.Data.Int.Cast.Basic","initialProofState":"R : Type u\ninst✝ : AddGroupWithOne R\n⊢ Eq (↑4) 4","decl":"theorem cast_four : ((4 : ℤ) : R) = 4 := cast_ofNat _\n\n"}
{"name":"zsmul_one","module":"Mathlib.Data.Int.Cast.Basic","initialProofState":"R : Type u_1\ninst✝ : AddGroupWithOne R\nn : Int\n⊢ Eq (HSMul.hSMul n 1) ↑n","decl":"@[simp] lemma zsmul_one [AddGroupWithOne R] (n : ℤ) : n • (1 : R) = n := by cases n <;> simp\n\n"}
