{"name":"Module.FinitePresentation.exists_basis_localizedModule_powers","module":"Mathlib.RingTheory.Localization.Free","initialProofState":"R : Type u_4\nM : Type u_5\ninst✝¹² : CommRing R\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : Module R M\nS : Submonoid R\nM' : Type u_1\ninst✝⁹ : AddCommGroup M'\ninst✝⁸ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝⁷ : IsLocalizedModule S f\nRₛ : Type u_3\ninst✝⁶ : CommRing Rₛ\ninst✝⁵ : Algebra R Rₛ\ninst✝⁴ : Module Rₛ M'\ninst✝³ : IsScalarTower R Rₛ M'\ninst✝² : IsLocalization S Rₛ\ninst✝¹ : Module.FinitePresentation R M\nI : Type u_6\ninst✝ : Finite I\nb : Basis I Rₛ M'\n⊢ Exists fun r => Exists fun hr => Exists fun b' => ∀ (i : I), Eq ((LocalizedModule.lift (Submonoid.powers r) f ⋯) (b' i)) (b i)","decl":"include f in\n/--\nIf `M` is a finitely presented `R`-module,\nthen any `Rₛ`-basis of `Mₛ` for some `S : Submonoid R` can be lifted to\na `Rᵣ`-basis of `Mᵣ` for some `r ∈ S`.\n-/\nlemma Module.FinitePresentation.exists_basis_localizedModule_powers\n    (Rₛ) [CommRing Rₛ] [Algebra R Rₛ] [Module Rₛ M'] [IsScalarTower R Rₛ M']\n    [IsLocalization S Rₛ] [Module.FinitePresentation R M]\n    {I} [Finite I] (b : Basis I Rₛ M') :\n    ∃ (r : R) (hr : r ∈ S)\n      (b' : Basis I (Localization (.powers r)) (LocalizedModule (.powers r) M)),\n      ∀ i, (LocalizedModule.lift (.powers r) f fun s ↦ IsLocalizedModule.map_units f\n        ⟨s.1, SetLike.le_def.mp (Submonoid.powers_le.mpr hr) s.2⟩) (b' i) = b i := by\n  have : Module.FinitePresentation R (I →₀ R) := Module.finitePresentation_of_projective _ _\n  obtain ⟨r, hr, e, he⟩ := Module.FinitePresentation.exists_lift_equiv_of_isLocalizedModule S f\n    (Finsupp.mapRange.linearMap (Algebra.linearMap R Rₛ)) (b.repr.restrictScalars R)\n  let e' := IsLocalizedModule.iso (.powers r) (Finsupp.mapRange.linearMap (α := I)\n    (Algebra.linearMap R (Localization (.powers r))))\n  refine ⟨r, hr, .ofRepr (e ≪≫ₗ ?_), ?_⟩\n  · exact\n    { __ := e',\n      toLinearMap := e'.extendScalarsOfIsLocalization (.powers r) (Localization (.powers r)) }\n  · intro i\n    have : e'.symm _ = _ := LinearMap.congr_fun (IsLocalizedModule.iso_symm_comp (.powers r)\n      (Finsupp.mapRange.linearMap (Algebra.linearMap R (Localization (.powers r)))))\n      (Finsupp.single i 1)\n    simp only [Finsupp.mapRange.linearMap_apply, Finsupp.mapRange_single, Algebra.linearMap_apply,\n      map_one, LocalizedModule.mkLinearMap_apply] at this\n    show LocalizedModule.lift _ _ _ (e.symm (e'.symm _)) = _\n    replace he := LinearMap.congr_fun he (e.symm (e'.symm (Finsupp.single i 1)))\n    simp only [LinearMap.coe_comp, LinearMap.coe_restrictScalars, LinearEquiv.coe_coe,\n      Function.comp_apply, LinearEquiv.apply_symm_apply, LinearEquiv.restrictScalars_apply] at he\n    apply b.repr.injective\n    rw [← he, Basis.repr_self, this, LocalizedModule.lift_mk]\n    simp\n\n"}
{"name":"Module.FinitePresentation.exists_free_localizedModule_powers","module":"Mathlib.RingTheory.Localization.Free","initialProofState":"R : Type u_4\nM : Type u_5\ninst✝¹³ : CommRing R\ninst✝¹² : AddCommGroup M\ninst✝¹¹ : Module R M\nS : Submonoid R\nM' : Type u_1\ninst✝¹⁰ : AddCommGroup M'\ninst✝⁹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝⁸ : IsLocalizedModule S f\nRₛ : Type u_3\ninst✝⁷ : CommRing Rₛ\ninst✝⁶ : Algebra R Rₛ\ninst✝⁵ : Module Rₛ M'\ninst✝⁴ : IsScalarTower R Rₛ M'\ninst✝³ : Nontrivial Rₛ\ninst✝² : IsLocalization S Rₛ\ninst✝¹ : Module.FinitePresentation R M\ninst✝ : Module.Free Rₛ M'\n⊢ Exists fun r => And (Membership.mem S r) (And (Module.Free (Localization (Submonoid.powers r)) (LocalizedModule (Submonoid.powers r) M)) (Eq (Module.finrank (Localization (Submonoid.powers r)) (LocalizedModule (Submonoid.powers r) M)) (Module.finrank Rₛ M')))","decl":"include f in\n/--\nIf `M` is a finitely presented `R`-module\nsuch that `Mₛ` is free over `Rₛ` for some `S : Submonoid R`,\nthen `Mᵣ` is already free over `Rᵣ` for some `r ∈ S`.\n-/\nlemma Module.FinitePresentation.exists_free_localizedModule_powers\n    (Rₛ) [CommRing Rₛ] [Algebra R Rₛ] [Module Rₛ M'] [IsScalarTower R Rₛ M'] [Nontrivial Rₛ]\n    [IsLocalization S Rₛ] [Module.FinitePresentation R M] [Module.Free Rₛ M'] :\n    ∃ r, r ∈ S ∧\n      Module.Free (Localization (.powers r)) (LocalizedModule (.powers r) M) ∧\n      Module.finrank (Localization (.powers r)) (LocalizedModule (.powers r) M) =\n        Module.finrank Rₛ M' := by\n  let I := Module.Free.ChooseBasisIndex Rₛ M'\n  let b : Basis I Rₛ M' := Module.Free.chooseBasis Rₛ M'\n  have : Module.Finite Rₛ M' := Module.Finite.of_isLocalizedModule S (Rₚ := Rₛ) f\n  obtain ⟨r, hr, b', _⟩ := Module.FinitePresentation.exists_basis_localizedModule_powers S f Rₛ b\n  have := (show Localization (.powers r) →+* Rₛ from IsLocalization.map (M := .powers r) (T := S) _\n    (RingHom.id _) (Submonoid.powers_le.mpr hr)).domain_nontrivial\n  refine ⟨r, hr, .of_basis b', ?_⟩\n  rw [Module.finrank_eq_nat_card_basis b, Module.finrank_eq_nat_card_basis b']\n"}
