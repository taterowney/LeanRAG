{"name":"GradedMonoid.fst_smul","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nα : Type u_3\nA : ι → Type u_2\ninst✝ : (i : ι) → SMul α (A i)\na : α\nx : GradedMonoid A\n⊢ Eq (HSMul.hSMul a x).fst x.fst","decl":"@[simp] theorem fst_smul [∀ i, SMul α (A i)] (a : α) (x : GradedMonoid A) :\n    (a • x).fst = x.fst := rfl\n\n"}
{"name":"GradedMonoid.snd_smul","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nα : Type u_3\nA : ι → Type u_2\ninst✝ : (i : ι) → SMul α (A i)\na : α\nx : GradedMonoid A\n⊢ Eq (HSMul.hSMul a x).snd (HSMul.hSMul a x.snd)","decl":"@[simp] theorem snd_smul [∀ i, SMul α (A i)] (a : α) (x : GradedMonoid A) :\n    (a • x).snd = a • x.snd := rfl\n\n"}
{"name":"GradedMonoid.smul_mk","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nα : Type u_3\nA : ι → Type u_2\ninst✝ : (i : ι) → SMul α (A i)\ni : ι\nc : α\na : A i\n⊢ Eq (HSMul.hSMul c (GradedMonoid.mk i a)) (GradedMonoid.mk i (HSMul.hSMul c a))","decl":"theorem smul_mk [∀ i, SMul α (A i)] {i} (c : α) (a : A i) :\n    c • mk i a = mk i (c • a) :=\n  rfl\n\n"}
{"name":"GradedMonoid.instSMulCommClass","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\nA : ι → Type u_2\ninst✝² : (i : ι) → SMul α (A i)\ninst✝¹ : (i : ι) → SMul β (A i)\ninst✝ : ∀ (i : ι), SMulCommClass α β (A i)\n⊢ SMulCommClass α β (GradedMonoid A)","decl":"instance [∀ i, SMul α (A i)] [∀ i, SMul β (A i)]\n    [∀ i, SMulCommClass α β (A i)] :\n    SMulCommClass α β (GradedMonoid A) where\n  smul_comm a b g := Sigma.ext rfl <| heq_of_eq <| smul_comm a b g.2\n\n"}
{"name":"GradedMonoid.instIsScalarTower","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nα : Type u_3\nβ : Type u_4\nA : ι → Type u_2\ninst✝³ : SMul α β\ninst✝² : (i : ι) → SMul α (A i)\ninst✝¹ : (i : ι) → SMul β (A i)\ninst✝ : ∀ (i : ι), IsScalarTower α β (A i)\n⊢ IsScalarTower α β (GradedMonoid A)","decl":"instance [SMul α β] [∀ i, SMul α (A i)] [∀ i, SMul β (A i)]\n    [∀ i, IsScalarTower α β (A i)] :\n    IsScalarTower α β (GradedMonoid A) where\n  smul_assoc a b g := Sigma.ext rfl <| heq_of_eq <| smul_assoc a b g.2\n\n"}
{"name":"GradedMonoid.fst_one","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : Zero ι\ninst✝ : GradedMonoid.GOne A\n⊢ Eq (Sigma.fst 1) 0","decl":"@[simp] theorem fst_one [Zero ι] [GOne A] : (1 : GradedMonoid A).fst = 0 := rfl\n\n"}
{"name":"GradedMonoid.snd_one","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : Zero ι\ninst✝ : GradedMonoid.GOne A\n⊢ Eq (Sigma.snd 1) GradedMonoid.GOne.one","decl":"@[simp] theorem snd_one [Zero ι] [GOne A] : (1 : GradedMonoid A).snd = GOne.one := rfl\n\n"}
{"name":"GradedMonoid.fst_mul","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : Add ι\ninst✝ : GradedMonoid.GMul A\nx y : GradedMonoid A\n⊢ Eq (HMul.hMul x y).fst (HAdd.hAdd x.fst y.fst)","decl":"@[simp] theorem fst_mul [Add ι] [GMul A] (x y : GradedMonoid A) :\n    (x * y).fst = x.fst + y.fst := rfl\n\n"}
{"name":"GradedMonoid.snd_mul","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : Add ι\ninst✝ : GradedMonoid.GMul A\nx y : GradedMonoid A\n⊢ Eq (HMul.hMul x y).snd (GradedMonoid.GMul.mul x.snd y.snd)","decl":"@[simp] theorem snd_mul [Add ι] [GMul A] (x y : GradedMonoid A) :\n    (x * y).snd = GMul.mul x.snd y.snd := rfl\n\n"}
{"name":"GradedMonoid.mk_mul_mk","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : Add ι\ninst✝ : GradedMonoid.GMul A\ni j : ι\na : A i\nb : A j\n⊢ Eq (HMul.hMul (GradedMonoid.mk i a) (GradedMonoid.mk j b)) (GradedMonoid.mk (HAdd.hAdd i j) (GradedMonoid.GMul.mul a b))","decl":"theorem mk_mul_mk [Add ι] [GMul A] {i j} (a : A i) (b : A j) :\n    mk i a * mk j b = mk (i + j) (GMul.mul a b) :=\n  rfl\n\n"}
{"name":"GradedMonoid.GMonoid.gnpowRec_zero","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝² : AddMonoid ι\ninst✝¹ : GradedMonoid.GMul A\ninst✝ : GradedMonoid.GOne A\na : GradedMonoid A\n⊢ Eq (GradedMonoid.mk (HSMul.hSMul 0 a.fst) (GradedMonoid.GMonoid.gnpowRec 0 a.snd)) 1","decl":"@[simp]\ntheorem gnpowRec_zero (a : GradedMonoid A) : GradedMonoid.mk _ (gnpowRec 0 a.snd) = 1 :=\n  Sigma.ext (zero_nsmul _) (heq_of_cast_eq _ rfl).symm\n\n"}
{"name":"GradedMonoid.GMonoid.gnpowRec_succ","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝² : AddMonoid ι\ninst✝¹ : GradedMonoid.GMul A\ninst✝ : GradedMonoid.GOne A\nn : Nat\na : GradedMonoid A\n⊢ Eq (GradedMonoid.mk (HSMul.hSMul n.succ a.fst) (GradedMonoid.GMonoid.gnpowRec n.succ a.snd)) (HMul.hMul ⟨HSMul.hSMul n a.fst, GradedMonoid.GMonoid.gnpowRec n a.snd⟩ a)","decl":"@[simp]\ntheorem gnpowRec_succ (n : ℕ) (a : GradedMonoid A) :\n    (GradedMonoid.mk _ <| gnpowRec n.succ a.snd) = ⟨_, gnpowRec n a.snd⟩ * a :=\n  Sigma.ext (succ_nsmul _ _) (heq_of_cast_eq _ rfl).symm\n\n"}
{"name":"GradedMonoid.GMonoid.mul_assoc","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝ : AddMonoid ι\nself : GradedMonoid.GMonoid A\na b c : GradedMonoid A\n⊢ Eq (HMul.hMul (HMul.hMul a b) c) (HMul.hMul a (HMul.hMul b c))","decl":"/-- A graded version of `Monoid`\n\nLike `Monoid.npow`, this has an optional `GMonoid.gnpow` field to allow definitional control of\nnatural powers of a graded monoid. -/\nclass GMonoid [AddMonoid ι] extends GMul A, GOne A where\n  /-- Multiplication by `one` on the left is the identity -/\n  one_mul (a : GradedMonoid A) : 1 * a = a\n  /-- Multiplication by `one` on the right is the identity -/\n  mul_one (a : GradedMonoid A) : a * 1 = a\n  /-- Multiplication is associative -/\n  mul_assoc (a b c : GradedMonoid A) : a * b * c = a * (b * c)\n  /-- Optional field to allow definitional control of natural powers -/\n  gnpow : ∀ (n : ℕ) {i}, A i → A (n • i) := GMonoid.gnpowRec\n  /-- The zeroth power will yield 1 -/\n  gnpow_zero' : ∀ a : GradedMonoid A, GradedMonoid.mk _ (gnpow 0 a.snd) = 1 := by\n    apply_gmonoid_gnpowRec_zero_tac\n  /-- Successor powers behave as expected -/\n  gnpow_succ' :\n    ∀ (n : ℕ) (a : GradedMonoid A),\n      (GradedMonoid.mk _ <| gnpow n.succ a.snd) = ⟨_, gnpow n a.snd⟩ * a := by\n    apply_gmonoid_gnpowRec_succ_tac\n\n"}
{"name":"GradedMonoid.GMonoid.gnpow_zero'","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝ : AddMonoid ι\nself : GradedMonoid.GMonoid A\na : GradedMonoid A\n⊢ Eq (GradedMonoid.mk (HSMul.hSMul 0 a.fst) (GradedMonoid.GMonoid.gnpow 0 a.snd)) 1","decl":"/-- A graded version of `Monoid`\n\nLike `Monoid.npow`, this has an optional `GMonoid.gnpow` field to allow definitional control of\nnatural powers of a graded monoid. -/\nclass GMonoid [AddMonoid ι] extends GMul A, GOne A where\n  /-- Multiplication by `one` on the left is the identity -/\n  one_mul (a : GradedMonoid A) : 1 * a = a\n  /-- Multiplication by `one` on the right is the identity -/\n  mul_one (a : GradedMonoid A) : a * 1 = a\n  /-- Multiplication is associative -/\n  mul_assoc (a b c : GradedMonoid A) : a * b * c = a * (b * c)\n  /-- Optional field to allow definitional control of natural powers -/\n  gnpow : ∀ (n : ℕ) {i}, A i → A (n • i) := GMonoid.gnpowRec\n  /-- The zeroth power will yield 1 -/\n  gnpow_zero' : ∀ a : GradedMonoid A, GradedMonoid.mk _ (gnpow 0 a.snd) = 1 := by\n    apply_gmonoid_gnpowRec_zero_tac\n  /-- Successor powers behave as expected -/\n  gnpow_succ' :\n    ∀ (n : ℕ) (a : GradedMonoid A),\n      (GradedMonoid.mk _ <| gnpow n.succ a.snd) = ⟨_, gnpow n a.snd⟩ * a := by\n    apply_gmonoid_gnpowRec_succ_tac\n\n"}
{"name":"GradedMonoid.GMonoid.gnpow_succ'","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝ : AddMonoid ι\nself : GradedMonoid.GMonoid A\nn : Nat\na : GradedMonoid A\n⊢ Eq (GradedMonoid.mk (HSMul.hSMul n.succ a.fst) (GradedMonoid.GMonoid.gnpow n.succ a.snd)) (HMul.hMul ⟨HSMul.hSMul n a.fst, GradedMonoid.GMonoid.gnpow n a.snd⟩ a)","decl":"/-- A graded version of `Monoid`\n\nLike `Monoid.npow`, this has an optional `GMonoid.gnpow` field to allow definitional control of\nnatural powers of a graded monoid. -/\nclass GMonoid [AddMonoid ι] extends GMul A, GOne A where\n  /-- Multiplication by `one` on the left is the identity -/\n  one_mul (a : GradedMonoid A) : 1 * a = a\n  /-- Multiplication by `one` on the right is the identity -/\n  mul_one (a : GradedMonoid A) : a * 1 = a\n  /-- Multiplication is associative -/\n  mul_assoc (a b c : GradedMonoid A) : a * b * c = a * (b * c)\n  /-- Optional field to allow definitional control of natural powers -/\n  gnpow : ∀ (n : ℕ) {i}, A i → A (n • i) := GMonoid.gnpowRec\n  /-- The zeroth power will yield 1 -/\n  gnpow_zero' : ∀ a : GradedMonoid A, GradedMonoid.mk _ (gnpow 0 a.snd) = 1 := by\n    apply_gmonoid_gnpowRec_zero_tac\n  /-- Successor powers behave as expected -/\n  gnpow_succ' :\n    ∀ (n : ℕ) (a : GradedMonoid A),\n      (GradedMonoid.mk _ <| gnpow n.succ a.snd) = ⟨_, gnpow n a.snd⟩ * a := by\n    apply_gmonoid_gnpowRec_succ_tac\n\n"}
{"name":"GradedMonoid.GMonoid.mul_one","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝ : AddMonoid ι\nself : GradedMonoid.GMonoid A\na : GradedMonoid A\n⊢ Eq (HMul.hMul a 1) a","decl":"/-- A graded version of `Monoid`\n\nLike `Monoid.npow`, this has an optional `GMonoid.gnpow` field to allow definitional control of\nnatural powers of a graded monoid. -/\nclass GMonoid [AddMonoid ι] extends GMul A, GOne A where\n  /-- Multiplication by `one` on the left is the identity -/\n  one_mul (a : GradedMonoid A) : 1 * a = a\n  /-- Multiplication by `one` on the right is the identity -/\n  mul_one (a : GradedMonoid A) : a * 1 = a\n  /-- Multiplication is associative -/\n  mul_assoc (a b c : GradedMonoid A) : a * b * c = a * (b * c)\n  /-- Optional field to allow definitional control of natural powers -/\n  gnpow : ∀ (n : ℕ) {i}, A i → A (n • i) := GMonoid.gnpowRec\n  /-- The zeroth power will yield 1 -/\n  gnpow_zero' : ∀ a : GradedMonoid A, GradedMonoid.mk _ (gnpow 0 a.snd) = 1 := by\n    apply_gmonoid_gnpowRec_zero_tac\n  /-- Successor powers behave as expected -/\n  gnpow_succ' :\n    ∀ (n : ℕ) (a : GradedMonoid A),\n      (GradedMonoid.mk _ <| gnpow n.succ a.snd) = ⟨_, gnpow n a.snd⟩ * a := by\n    apply_gmonoid_gnpowRec_succ_tac\n\n"}
{"name":"GradedMonoid.GMonoid.one_mul","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝ : AddMonoid ι\nself : GradedMonoid.GMonoid A\na : GradedMonoid A\n⊢ Eq (HMul.hMul 1 a) a","decl":"/-- A graded version of `Monoid`\n\nLike `Monoid.npow`, this has an optional `GMonoid.gnpow` field to allow definitional control of\nnatural powers of a graded monoid. -/\nclass GMonoid [AddMonoid ι] extends GMul A, GOne A where\n  /-- Multiplication by `one` on the left is the identity -/\n  one_mul (a : GradedMonoid A) : 1 * a = a\n  /-- Multiplication by `one` on the right is the identity -/\n  mul_one (a : GradedMonoid A) : a * 1 = a\n  /-- Multiplication is associative -/\n  mul_assoc (a b c : GradedMonoid A) : a * b * c = a * (b * c)\n  /-- Optional field to allow definitional control of natural powers -/\n  gnpow : ∀ (n : ℕ) {i}, A i → A (n • i) := GMonoid.gnpowRec\n  /-- The zeroth power will yield 1 -/\n  gnpow_zero' : ∀ a : GradedMonoid A, GradedMonoid.mk _ (gnpow 0 a.snd) = 1 := by\n    apply_gmonoid_gnpowRec_zero_tac\n  /-- Successor powers behave as expected -/\n  gnpow_succ' :\n    ∀ (n : ℕ) (a : GradedMonoid A),\n      (GradedMonoid.mk _ <| gnpow n.succ a.snd) = ⟨_, gnpow n a.snd⟩ * a := by\n    apply_gmonoid_gnpowRec_succ_tac\n\n"}
{"name":"GradedMonoid.fst_pow","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : AddMonoid ι\ninst✝ : GradedMonoid.GMonoid A\nx : GradedMonoid A\nn : Nat\n⊢ Eq (HPow.hPow x n).fst (HSMul.hSMul n x.fst)","decl":"@[simp] theorem fst_pow [AddMonoid ι] [GMonoid A] (x : GradedMonoid A) (n : ℕ) :\n    (x ^ n).fst = n • x.fst := rfl\n\n"}
{"name":"GradedMonoid.snd_pow","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : AddMonoid ι\ninst✝ : GradedMonoid.GMonoid A\nx : GradedMonoid A\nn : Nat\n⊢ Eq (HPow.hPow x n).snd (GradedMonoid.GMonoid.gnpow n x.snd)","decl":"@[simp] theorem snd_pow [AddMonoid ι] [GMonoid A] (x : GradedMonoid A) (n : ℕ) :\n    (x ^ n).snd = GMonoid.gnpow n x.snd := rfl\n\n"}
{"name":"GradedMonoid.mk_pow","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : AddMonoid ι\ninst✝ : GradedMonoid.GMonoid A\ni : ι\na : A i\nn : Nat\n⊢ Eq (HPow.hPow (GradedMonoid.mk i a) n) (GradedMonoid.mk (HSMul.hSMul n i) (GradedMonoid.GMonoid.gnpow n a))","decl":"theorem mk_pow [AddMonoid ι] [GMonoid A] {i} (a : A i) (n : ℕ) :\n    mk i a ^ n = mk (n • i) (GMonoid.gnpow _ a) := rfl\n\n"}
{"name":"GradedMonoid.GCommMonoid.mul_comm","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝ : AddCommMonoid ι\nself : GradedMonoid.GCommMonoid A\na b : GradedMonoid A\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"/-- A graded version of `CommMonoid`. -/\nclass GCommMonoid [AddCommMonoid ι] extends GMonoid A where\n  /-- Multiplication is commutative -/\n  mul_comm (a : GradedMonoid A) (b : GradedMonoid A) : a * b = b * a\n\n"}
{"name":"GradedMonoid.mk_zero_smul","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : AddZeroClass ι\ninst✝ : GradedMonoid.GMul A\ni : ι\na : A 0\nb : A i\n⊢ Eq (GradedMonoid.mk i (HSMul.hSMul a b)) (HMul.hMul (GradedMonoid.mk 0 a) (GradedMonoid.mk i b))","decl":"@[simp]\ntheorem mk_zero_smul {i} (a : A 0) (b : A i) : mk _ (a • b) = mk _ a * mk _ b :=\n  Sigma.ext (zero_add _).symm <| eqRec_heq _ _\n\n"}
{"name":"GradedMonoid.GradeZero.smul_eq_mul","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : AddZeroClass ι\ninst✝ : GradedMonoid.GMul A\na b : A 0\n⊢ Eq (HSMul.hSMul a b) (HMul.hMul a b)","decl":"@[scoped simp]\ntheorem GradeZero.smul_eq_mul (a b : A 0) : a • b = a * b :=\n  rfl\n\n"}
{"name":"GradedMonoid.mk_zero_pow","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : AddMonoid ι\ninst✝ : GradedMonoid.GMonoid A\na : A 0\nn : Nat\n⊢ Eq (GradedMonoid.mk 0 (HPow.hPow a n)) (HPow.hPow (GradedMonoid.mk 0 a) n)","decl":"@[simp]\ntheorem mk_zero_pow (a : A 0) (n : ℕ) : mk _ (a ^ n) = mk _ a ^ n :=\n  Sigma.ext (nsmul_zero n).symm <| eqRec_heq _ _\n\n"}
{"name":"List.dProdIndex_nil","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : AddMonoid ι\nfι : α → ι\n⊢ Eq (List.nil.dProdIndex fι) 0","decl":"@[simp]\ntheorem List.dProdIndex_nil (fι : α → ι) : ([] : List α).dProdIndex fι = 0 :=\n  rfl\n\n"}
{"name":"List.dProdIndex_cons","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : AddMonoid ι\na : α\nl : List α\nfι : α → ι\n⊢ Eq ((List.cons a l).dProdIndex fι) (HAdd.hAdd (fι a) (l.dProdIndex fι))","decl":"@[simp]\ntheorem List.dProdIndex_cons (a : α) (l : List α) (fι : α → ι) :\n    (a :: l).dProdIndex fι = fι a + l.dProdIndex fι :=\n  rfl\n\n"}
{"name":"List.dProdIndex_eq_map_sum","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : AddMonoid ι\nl : List α\nfι : α → ι\n⊢ Eq (l.dProdIndex fι) (List.map fι l).sum","decl":"theorem List.dProdIndex_eq_map_sum (l : List α) (fι : α → ι) :\n    l.dProdIndex fι = (l.map fι).sum := by\n  match l with\n  | [] => simp\n  | head::tail => simp [List.dProdIndex_eq_map_sum tail fι]\n\n"}
{"name":"List.dProd_nil","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nα : Type u_2\nA : ι → Type u_3\ninst✝¹ : AddMonoid ι\ninst✝ : GradedMonoid.GMonoid A\nfι : α → ι\nfA : (a : α) → A (fι a)\n⊢ Eq (List.nil.dProd fι fA) GradedMonoid.GOne.one","decl":"@[simp]\ntheorem List.dProd_nil (fι : α → ι) (fA : ∀ a, A (fι a)) :\n    (List.nil : List α).dProd fι fA = GradedMonoid.GOne.one :=\n  rfl\n\n-- the `( :)` in this lemma statement results in the type on the RHS not being unfolded, which\n-- is nicer in the goal view.\n"}
{"name":"List.dProd_cons","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nα : Type u_2\nA : ι → Type u_3\ninst✝¹ : AddMonoid ι\ninst✝ : GradedMonoid.GMonoid A\nfι : α → ι\nfA : (a : α) → A (fι a)\na : α\nl : List α\n⊢ Eq ((List.cons a l).dProd fι fA) (GradedMonoid.GMul.mul (fA a) (l.dProd fι fA))","decl":"@[simp]\ntheorem List.dProd_cons (fι : α → ι) (fA : ∀ a, A (fι a)) (a : α) (l : List α) :\n    (a :: l).dProd fι fA = (GradedMonoid.GMul.mul (fA a) (l.dProd fι fA) :) :=\n  rfl\n\n"}
{"name":"GradedMonoid.mk_list_dProd","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nα : Type u_2\nA : ι → Type u_3\ninst✝¹ : AddMonoid ι\ninst✝ : GradedMonoid.GMonoid A\nl : List α\nfι : α → ι\nfA : (a : α) → A (fι a)\n⊢ Eq (GradedMonoid.mk (l.dProdIndex fι) (l.dProd fι fA)) (List.map (fun a => GradedMonoid.mk (fι a) (fA a)) l).prod","decl":"theorem GradedMonoid.mk_list_dProd (l : List α) (fι : α → ι) (fA : ∀ a, A (fι a)) :\n    GradedMonoid.mk _ (l.dProd fι fA) = (l.map fun a => GradedMonoid.mk (fι a) (fA a)).prod := by\n  match l with\n  | [] => simp only [List.dProdIndex_nil, List.dProd_nil, List.map_nil, List.prod_nil]; rfl\n  | head::tail =>\n    simp [← GradedMonoid.mk_list_dProd tail _ _, GradedMonoid.mk_mul_mk, List.prod_cons]\n\n"}
{"name":"GradedMonoid.list_prod_map_eq_dProd","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nα : Type u_2\nA : ι → Type u_3\ninst✝¹ : AddMonoid ι\ninst✝ : GradedMonoid.GMonoid A\nl : List α\nf : α → GradedMonoid A\n⊢ Eq (List.map f l).prod (GradedMonoid.mk (l.dProdIndex fun i => (f i).fst) (l.dProd (fun i => (f i).fst) fun i => (f i).snd))","decl":"/-- A variant of `GradedMonoid.mk_list_dProd` for rewriting in the other direction. -/\ntheorem GradedMonoid.list_prod_map_eq_dProd (l : List α) (f : α → GradedMonoid A) :\n    (l.map f).prod = GradedMonoid.mk _ (l.dProd (fun i => (f i).1) fun i => (f i).2) := by\n  rw [GradedMonoid.mk_list_dProd, GradedMonoid.mk]\n  simp_rw [Sigma.eta]\n\n"}
{"name":"GradedMonoid.list_prod_ofFn_eq_dProd","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nA : ι → Type u_3\ninst✝¹ : AddMonoid ι\ninst✝ : GradedMonoid.GMonoid A\nn : Nat\nf : Fin n → GradedMonoid A\n⊢ Eq (List.ofFn f).prod (GradedMonoid.mk ((List.finRange n).dProdIndex fun i => (f i).fst) ((List.finRange n).dProd (fun i => (f i).fst) fun i => (f i).snd))","decl":"theorem GradedMonoid.list_prod_ofFn_eq_dProd {n : ℕ} (f : Fin n → GradedMonoid A) :\n    (List.ofFn f).prod =\n      GradedMonoid.mk _ ((List.finRange n).dProd (fun i => (f i).1) fun i => (f i).2) := by\n  rw [List.ofFn_eq_map, GradedMonoid.list_prod_map_eq_dProd]\n\n"}
{"name":"One.gOne_one","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝¹ : Zero ι\ninst✝ : One R\n⊢ Eq GradedMonoid.GOne.one 1","decl":"@[simps one]\ninstance One.gOne [Zero ι] [One R] : GradedMonoid.GOne fun _ : ι => R where one := 1\n\n"}
{"name":"Mul.gMul_mul","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝¹ : Add ι\ninst✝ : Mul R\ni✝ j✝ : ι\nx y : R\n⊢ Eq (GradedMonoid.GMul.mul x y) (HMul.hMul x y)","decl":"@[simps mul]\ninstance Mul.gMul [Add ι] [Mul R] : GradedMonoid.GMul fun _ : ι => R where mul x y := x * y\n\n"}
{"name":"Monoid.gMonoid_gnpow","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝¹ : AddMonoid ι\ninst✝ : Monoid R\nn : Nat\nx✝ : ι\na : R\n⊢ Eq (GradedMonoid.GMonoid.gnpow n a) (HPow.hPow a n)","decl":"/-- If all grades are the same type and themselves form a monoid, then there is a trivial grading\nstructure. -/\n@[simps gnpow]\ninstance Monoid.gMonoid [AddMonoid ι] [Monoid R] : GradedMonoid.GMonoid fun _ : ι => R :=\n  -- { Mul.gMul ι, One.gOne ι with\n  { One.gOne ι with\n    mul := fun x y => x * y\n    one_mul := fun _ => Sigma.ext (zero_add _) (heq_of_eq (one_mul _))\n    mul_one := fun _ => Sigma.ext (add_zero _) (heq_of_eq (mul_one _))\n    mul_assoc := fun _ _ _ => Sigma.ext (add_assoc _ _ _) (heq_of_eq (mul_assoc _ _ _))\n    gnpow := fun n _ a => a ^ n\n    gnpow_zero' := fun _ => Sigma.ext (zero_nsmul _) (heq_of_eq (Monoid.npow_zero _))\n    gnpow_succ' := fun _ ⟨_, _⟩ => Sigma.ext (succ_nsmul _ _) (heq_of_eq (Monoid.npow_succ _ _)) }\n\n"}
{"name":"List.dProd_monoid","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nα : Type u_3\ninst✝¹ : AddMonoid ι\ninst✝ : Monoid R\nl : List α\nfι : α → ι\nfA : α → R\n⊢ Eq (l.dProd fι fA) (List.map fA l).prod","decl":"/-- When all the indexed types are the same, the dependent product is just the regular product. -/\n@[simp]\ntheorem List.dProd_monoid {α} [AddMonoid ι] [Monoid R] (l : List α) (fι : α → ι) (fA : α → R) :\n    @List.dProd _ _ (fun _ : ι => R) _ _ l fι fA = (l.map fA).prod := by\n  match l with\n  | [] =>\n    rw [List.dProd_nil, List.map_nil, List.prod_nil]\n    rfl\n  | head::tail =>\n    rw [List.dProd_cons, List.map_cons, List.prod_cons, List.dProd_monoid tail _ _]\n    rfl\n\n"}
{"name":"SetLike.GradedOne.one_mem","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝² : SetLike S R\ninst✝¹ : One R\ninst✝ : Zero ι\nA : ι → S\nself : SetLike.GradedOne A\n⊢ Membership.mem (A 0) 1","decl":"/-- A version of `GradedMonoid.GOne` for internally graded objects. -/\nclass SetLike.GradedOne {S : Type*} [SetLike S R] [One R] [Zero ι] (A : ι → S) : Prop where\n  /-- One has grade zero -/\n  one_mem : (1 : R) ∈ A 0\n\n"}
{"name":"SetLike.one_mem_graded","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝³ : SetLike S R\ninst✝² : One R\ninst✝¹ : Zero ι\nA : ι → S\ninst✝ : SetLike.GradedOne A\n⊢ Membership.mem (A 0) 1","decl":"theorem SetLike.one_mem_graded {S : Type*} [SetLike S R] [One R] [Zero ι] (A : ι → S)\n    [SetLike.GradedOne A] : (1 : R) ∈ A 0 :=\n  SetLike.GradedOne.one_mem\n\n"}
{"name":"SetLike.coe_gOne","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝³ : SetLike S R\ninst✝² : One R\ninst✝¹ : Zero ι\nA : ι → S\ninst✝ : SetLike.GradedOne A\n⊢ Eq (↑GradedMonoid.GOne.one) 1","decl":"@[simp]\ntheorem SetLike.coe_gOne {S : Type*} [SetLike S R] [One R] [Zero ι] (A : ι → S)\n    [SetLike.GradedOne A] : ↑(@GradedMonoid.GOne.one _ (fun i => A i) _ _) = (1 : R) :=\n  rfl\n\n"}
{"name":"SetLike.GradedMul.mul_mem","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝² : SetLike S R\ninst✝¹ : Mul R\ninst✝ : Add ι\nA : ι → S\nself : SetLike.GradedMul A\ni j : ι\ngi gj : R\na✝¹ : Membership.mem (A i) gi\na✝ : Membership.mem (A j) gj\n⊢ Membership.mem (A (HAdd.hAdd i j)) (HMul.hMul gi gj)","decl":"/-- A version of `GradedMonoid.ghas_one` for internally graded objects. -/\nclass SetLike.GradedMul {S : Type*} [SetLike S R] [Mul R] [Add ι] (A : ι → S) : Prop where\n  /-- Multiplication is homogeneous -/\n  mul_mem : ∀ ⦃i j⦄ {gi gj}, gi ∈ A i → gj ∈ A j → gi * gj ∈ A (i + j)\n\n"}
{"name":"SetLike.mul_mem_graded","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝³ : SetLike S R\ninst✝² : Mul R\ninst✝¹ : Add ι\nA : ι → S\ninst✝ : SetLike.GradedMul A\ni j : ι\ngi gj : R\nhi : Membership.mem (A i) gi\nhj : Membership.mem (A j) gj\n⊢ Membership.mem (A (HAdd.hAdd i j)) (HMul.hMul gi gj)","decl":"theorem SetLike.mul_mem_graded {S : Type*} [SetLike S R] [Mul R] [Add ι] {A : ι → S}\n    [SetLike.GradedMul A] ⦃i j⦄ {gi gj} (hi : gi ∈ A i) (hj : gj ∈ A j) : gi * gj ∈ A (i + j) :=\n  SetLike.GradedMul.mul_mem hi hj\n\n"}
{"name":"SetLike.coe_gMul","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝³ : SetLike S R\ninst✝² : Mul R\ninst✝¹ : Add ι\nA : ι → S\ninst✝ : SetLike.GradedMul A\ni j : ι\nx : Subtype fun x => Membership.mem (A i) x\ny : Subtype fun x => Membership.mem (A j) x\n⊢ Eq (↑(GradedMonoid.GMul.mul x y)) (HMul.hMul ↑x ↑y)","decl":"@[simp]\ntheorem SetLike.coe_gMul {S : Type*} [SetLike S R] [Mul R] [Add ι] (A : ι → S)\n    [SetLike.GradedMul A] {i j : ι} (x : A i) (y : A j) :\n    ↑(@GradedMonoid.GMul.mul _ (fun i => A i) _ _ _ _ x y) = (x * y : R) :=\n  rfl\n\n"}
{"name":"SetLike.GradedMonoid.toGradedOne","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝² : SetLike S R\ninst✝¹ : Monoid R\ninst✝ : AddMonoid ι\nA : ι → S\nself : SetLike.GradedMonoid A\n⊢ SetLike.GradedOne A","decl":"/-- A version of `GradedMonoid.GMonoid` for internally graded objects. -/\nclass SetLike.GradedMonoid {S : Type*} [SetLike S R] [Monoid R] [AddMonoid ι] (A : ι → S) extends\n  SetLike.GradedOne A, SetLike.GradedMul A : Prop\n\n"}
{"name":"SetLike.GradedMonoid.toGradedMul","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝² : SetLike S R\ninst✝¹ : Monoid R\ninst✝ : AddMonoid ι\nA : ι → S\nself : SetLike.GradedMonoid A\n⊢ SetLike.GradedMul A","decl":"/-- A version of `GradedMonoid.GMonoid` for internally graded objects. -/\nclass SetLike.GradedMonoid {S : Type*} [SetLike S R] [Monoid R] [AddMonoid ι] (A : ι → S) extends\n  SetLike.GradedOne A, SetLike.GradedMul A : Prop\n\n"}
{"name":"SetLike.GradeZero.coe_submonoid","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝³ : SetLike S R\ninst✝² : Monoid R\ninst✝¹ : AddMonoid ι\nA : ι → S\ninst✝ : SetLike.GradedMonoid A\n⊢ Eq ↑(SetLike.GradeZero.submonoid A) ↑(A 0)","decl":"variable (A) in\n\n/-- The submonoid `A 0` of `R`. -/\n@[simps]\ndef submonoid : Submonoid R where\n  carrier := A 0\n  mul_mem' ha hb := add_zero (0 : ι) ▸ SetLike.mul_mem_graded ha hb\n  one_mem' := SetLike.one_mem_graded A\n\n-- TODO: it might be expensive to unify `A` in this instances in practice\n"}
{"name":"SetLike.GradeZero.coe_one","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝³ : SetLike S R\ninst✝² : Monoid R\ninst✝¹ : AddMonoid ι\nA : ι → S\ninst✝ : SetLike.GradedMonoid A\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast] theorem coe_one : ↑(1 : A 0) = (1 : R) := rfl\n\n"}
{"name":"SetLike.GradeZero.coe_mul","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝³ : SetLike S R\ninst✝² : Monoid R\ninst✝¹ : AddMonoid ι\nA : ι → S\ninst✝ : SetLike.GradedMonoid A\na b : Subtype fun x => Membership.mem (A 0) x\n⊢ Eq (↑(HMul.hMul a b)) (HMul.hMul ↑a ↑b)","decl":"@[simp, norm_cast] theorem coe_mul (a b : A 0) : ↑(a * b) = (↑a * ↑b : R) := rfl\n\n"}
{"name":"SetLike.GradeZero.coe_pow","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝³ : SetLike S R\ninst✝² : Monoid R\ninst✝¹ : AddMonoid ι\nA : ι → S\ninst✝ : SetLike.GradedMonoid A\na : Subtype fun x => Membership.mem (A 0) x\nn : Nat\n⊢ Eq (↑(HPow.hPow a n)) (HPow.hPow (↑a) n)","decl":"@[simp, norm_cast] theorem coe_pow (a : A 0) (n : ℕ) : ↑(a ^ n) = (↑a : R) ^ n := rfl\n\n"}
{"name":"SetLike.pow_mem_graded","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝³ : SetLike S R\ninst✝² : Monoid R\ninst✝¹ : AddMonoid ι\nA : ι → S\ninst✝ : SetLike.GradedMonoid A\nn : Nat\nr : R\ni : ι\nh : Membership.mem (A i) r\n⊢ Membership.mem (A (HSMul.hSMul n i)) (HPow.hPow r n)","decl":"theorem pow_mem_graded (n : ℕ) {r : R} {i : ι} (h : r ∈ A i) : r ^ n ∈ A (n • i) := by\n  match n with\n  | 0 =>\n    rw [pow_zero, zero_nsmul]\n    exact one_mem_graded _\n  | n+1 =>\n    rw [pow_succ', succ_nsmul']\n    exact mul_mem_graded h (pow_mem_graded n h)\n\n"}
{"name":"SetLike.list_prod_map_mem_graded","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝³ : SetLike S R\ninst✝² : Monoid R\ninst✝¹ : AddMonoid ι\nA : ι → S\ninst✝ : SetLike.GradedMonoid A\nι' : Type u_4\nl : List ι'\ni : ι' → ι\nr : ι' → R\nh : ∀ (j : ι'), Membership.mem l j → Membership.mem (A (i j)) (r j)\n⊢ Membership.mem (A (List.map i l).sum) (List.map r l).prod","decl":"theorem list_prod_map_mem_graded {ι'} (l : List ι') (i : ι' → ι) (r : ι' → R)\n    (h : ∀ j ∈ l, r j ∈ A (i j)) : (l.map r).prod ∈ A (l.map i).sum := by\n  match l with\n  | [] =>\n    rw [List.map_nil, List.map_nil, List.prod_nil, List.sum_nil]\n    exact one_mem_graded _\n  | head::tail =>\n    rw [List.map_cons, List.map_cons, List.prod_cons, List.sum_cons]\n    exact\n      mul_mem_graded (h _ <| List.mem_cons_self _ _)\n        (list_prod_map_mem_graded tail _ _ fun j hj => h _ <| List.mem_cons_of_mem _ hj)\n\n"}
{"name":"SetLike.list_prod_ofFn_mem_graded","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝³ : SetLike S R\ninst✝² : Monoid R\ninst✝¹ : AddMonoid ι\nA : ι → S\ninst✝ : SetLike.GradedMonoid A\nn : Nat\ni : Fin n → ι\nr : Fin n → R\nh : ∀ (j : Fin n), Membership.mem (A (i j)) (r j)\n⊢ Membership.mem (A (List.ofFn i).sum) (List.ofFn r).prod","decl":"theorem list_prod_ofFn_mem_graded {n} (i : Fin n → ι) (r : Fin n → R) (h : ∀ j, r j ∈ A (i j)) :\n    (List.ofFn r).prod ∈ A (List.ofFn i).sum := by\n  rw [List.ofFn_eq_map, List.ofFn_eq_map]\n  exact list_prod_map_mem_graded _ _ _ fun _ _ => h _\n\n"}
{"name":"SetLike.coe_gnpow","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝³ : SetLike S R\ninst✝² : Monoid R\ninst✝¹ : AddMonoid ι\nA : ι → S\ninst✝ : SetLike.GradedMonoid A\ni : ι\nx : Subtype fun x => Membership.mem (A i) x\nn : Nat\n⊢ Eq (↑(GradedMonoid.GMonoid.gnpow n x)) (HPow.hPow (↑x) n)","decl":"@[simp]\ntheorem SetLike.coe_gnpow {S : Type*} [SetLike S R] [Monoid R] [AddMonoid ι] (A : ι → S)\n    [SetLike.GradedMonoid A] {i : ι} (x : A i) (n : ℕ) :\n    ↑(@GradedMonoid.GMonoid.gnpow _ (fun i => A i) _ _ n _ x) = (x:R)^n :=\n  rfl\n\n"}
{"name":"SetLike.coe_list_dProd","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nα : Type u_3\nS : Type u_4\ninst✝³ : SetLike S R\ninst✝² : Monoid R\ninst✝¹ : AddMonoid ι\nA : ι → S\ninst✝ : SetLike.GradedMonoid A\nfι : α → ι\nfA : (a : α) → Subtype fun x => Membership.mem (A (fι a)) x\nl : List α\n⊢ Eq (↑(l.dProd fι fA)) (List.map (fun a => ↑(fA a)) l).prod","decl":"@[simp]\ntheorem SetLike.coe_list_dProd (A : ι → S) [SetLike.GradedMonoid A] (fι : α → ι)\n    (fA : ∀ a, A (fι a)) (l : List α) : ↑(@List.dProd _ _ (fun i => ↥(A i)) _ _ l fι fA)\n    = (List.prod (l.map fun a => fA a) : R) := by\n  match l with\n  | [] =>\n    rw [List.dProd_nil, coe_gOne, List.map_nil, List.prod_nil]\n  | head::tail =>\n    rw [List.dProd_cons, coe_gMul, List.map_cons, List.prod_cons,\n      SetLike.coe_list_dProd _ _ _ tail]\n\n"}
{"name":"SetLike.list_dProd_eq","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nα : Type u_3\nS : Type u_4\ninst✝³ : SetLike S R\ninst✝² : Monoid R\ninst✝¹ : AddMonoid ι\nA : ι → S\ninst✝ : SetLike.GradedMonoid A\nfι : α → ι\nfA : (a : α) → Subtype fun x => Membership.mem (A (fι a)) x\nl : List α\n⊢ Eq (l.dProd fι fA) ⟨(List.map (fun a => ↑(fA a)) l).prod, ⋯⟩","decl":"/-- A version of `List.coe_dProd_set_like` with `Subtype.mk`. -/\ntheorem SetLike.list_dProd_eq (A : ι → S) [SetLike.GradedMonoid A] (fι : α → ι) (fA : ∀ a, A (fι a))\n    (l : List α) :\n    (@List.dProd _ _ (fun i => ↥(A i)) _ _ l fι fA) =\n      ⟨List.prod (l.map fun a => fA a),\n        (l.dProdIndex_eq_map_sum fι).symm ▸\n          list_prod_map_mem_graded l _ _ fun i _ => (fA i).prop⟩ :=\n  Subtype.ext <| SetLike.coe_list_dProd _ _ _ _\n\n"}
{"name":"SetLike.homogeneous_coe","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝ : SetLike S R\nA : ι → S\ni : ι\nx : Subtype fun x => Membership.mem (A i) x\n⊢ SetLike.Homogeneous A ↑x","decl":"@[simp]\ntheorem SetLike.homogeneous_coe {A : ι → S} {i} (x : A i) : SetLike.Homogeneous A (x : R) :=\n  ⟨i, x.prop⟩\n\n"}
{"name":"SetLike.homogeneous_one","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝³ : SetLike S R\ninst✝² : Zero ι\ninst✝¹ : One R\nA : ι → S\ninst✝ : SetLike.GradedOne A\n⊢ SetLike.Homogeneous A 1","decl":"theorem SetLike.homogeneous_one [Zero ι] [One R] (A : ι → S) [SetLike.GradedOne A] :\n    SetLike.Homogeneous A (1 : R) :=\n  ⟨0, SetLike.one_mem_graded _⟩\n\n"}
{"name":"SetLike.homogeneous_mul","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝³ : SetLike S R\ninst✝² : Add ι\ninst✝¹ : Mul R\nA : ι → S\ninst✝ : SetLike.GradedMul A\na b : R\na✝¹ : SetLike.Homogeneous A a\na✝ : SetLike.Homogeneous A b\n⊢ SetLike.Homogeneous A (HMul.hMul a b)","decl":"theorem SetLike.homogeneous_mul [Add ι] [Mul R] {A : ι → S} [SetLike.GradedMul A] {a b : R} :\n    SetLike.Homogeneous A a → SetLike.Homogeneous A b → SetLike.Homogeneous A (a * b)\n  | ⟨i, hi⟩, ⟨j, hj⟩ => ⟨i + j, SetLike.mul_mem_graded hi hj⟩\n\n"}
{"name":"SetLike.prod_mem_graded","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_2\nR : Type u_3\nS : Type u_4\ninst✝³ : SetLike S R\ninst✝² : CommMonoid R\ninst✝¹ : AddCommMonoid ι\nA : ι → S\ninst✝ : SetLike.GradedMonoid A\nκ : Type u_5\ni : κ → ι\ng : κ → R\nF : Finset κ\nhF : ∀ (k : κ), Membership.mem F k → Membership.mem (A (i k)) (g k)\n⊢ Membership.mem (A (F.sum fun k => i k)) (F.prod fun k => g k)","decl":"theorem prod_mem_graded (hF : ∀ k ∈ F, g k ∈ A (i k)) : ∏ k ∈ F, g k ∈ A (∑ k ∈ F, i k) := by\n  classical\n  induction F using Finset.induction_on\n  · simp [GradedOne.one_mem]\n  · case insert j F' hF2 h3 =>\n    rw [Finset.prod_insert hF2, Finset.sum_insert hF2]\n    apply SetLike.mul_mem_graded (hF j <| Finset.mem_insert_self j F')\n    apply h3\n    intro k hk\n    apply hF k\n    exact Finset.mem_insert_of_mem hk\n\n"}
{"name":"SetLike.prod_pow_mem_graded","module":"Mathlib.Algebra.GradedMonoid","initialProofState":"ι : Type u_2\nR : Type u_3\nS : Type u_4\ninst✝³ : SetLike S R\ninst✝² : CommMonoid R\ninst✝¹ : AddCommMonoid ι\nA : ι → S\ninst✝ : SetLike.GradedMonoid A\nκ : Type u_5\ni : κ → ι\ng : κ → R\nF : Finset κ\nn : κ → Nat\nhF : ∀ (k : κ), Membership.mem F k → Membership.mem (A (i k)) (g k)\n⊢ Membership.mem (A (F.sum fun k => HSMul.hSMul (n k) (i k))) (F.prod fun k => HPow.hPow (g k) (n k))","decl":"theorem prod_pow_mem_graded (n : κ → ℕ) (hF : ∀ k ∈ F, g k ∈ A (i k)) :\n    ∏ k ∈ F, g k ^ n k ∈ A (∑ k ∈ F, n k • i k) :=\n  prod_mem_graded A _ _ fun k hk ↦ pow_mem_graded _ (hF k hk)\n\n"}
