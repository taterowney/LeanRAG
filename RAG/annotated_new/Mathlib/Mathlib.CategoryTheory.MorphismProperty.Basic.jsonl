{"name":"CategoryTheory.MorphismProperty.le_def","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\n‚ä¢ Iff (LE.le P Q) (‚àÄ {X Y : C} (f : Quiver.Hom X Y), P f ‚Üí Q f)","decl":"lemma MorphismProperty.le_def {P Q : MorphismProperty C} :\n    P ‚â§ Q ‚Üî ‚àÄ {X Y : C} (f : X ‚ü∂ Y), P f ‚Üí Q f := Iff.rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.top_eq","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Eq Top.top fun x x_1 x => True","decl":"lemma MorphismProperty.top_eq : (‚ä§ : MorphismProperty C) = fun _ _ _ => True := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.ext","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW W' : CategoryTheory.MorphismProperty C\nh : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : Quiver.Hom X Y), Iff (W f) (W' f)\n‚ä¢ Eq W W'","decl":"@[ext]\nlemma ext (W W' : MorphismProperty C) (h : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : X ‚ü∂ Y), W f ‚Üî W' f) :\n    W = W' := by\n  funext X Y f\n  rw [h]\n\n"}
{"name":"CategoryTheory.MorphismProperty.ext_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nW W' : CategoryTheory.MorphismProperty C\n‚ä¢ Iff (Eq W W') (‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : Quiver.Hom X Y), Iff (W f) (W' f))","decl":"@[ext]\nlemma ext (W W' : MorphismProperty C) (h : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : X ‚ü∂ Y), W f ‚Üî W' f) :\n    W = W' := by\n  funext X Y f\n  rw [h]\n\n"}
{"name":"CategoryTheory.MorphismProperty.top_apply","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Top.top f","decl":"@[simp]\nlemma top_apply {X Y : C} (f : X ‚ü∂ Y) : (‚ä§ : MorphismProperty C) f := by\n  simp only [top_eq]\n\n"}
{"name":"CategoryTheory.MorphismProperty.sSup_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nS : Set (CategoryTheory.MorphismProperty C)\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Iff (SupSet.sSup S f) (Exists fun W => ‚ÜëW f)","decl":"@[simp]\nlemma sSup_iff (S : Set (MorphismProperty C)) {X Y : C} (f : X ‚ü∂ Y) :\n    sSup S f ‚Üî ‚àÉ (W : S), W.1 f := by\n  dsimp [sSup, iSup]\n  constructor\n  ¬∑ rintro ‚ü®_, ‚ü®‚ü®_, ‚ü®‚ü®_, ‚ü®_, h‚ü©, rfl‚ü©, rfl‚ü©‚ü©, rfl‚ü©, hf‚ü©\n    exact ‚ü®‚ü®_, h‚ü©, hf‚ü©\n  ¬∑ rintro ‚ü®‚ü®W, hW‚ü©, hf‚ü©\n    exact ‚ü®_, ‚ü®‚ü®_, ‚ü®_, ‚ü®‚ü®W, hW‚ü©, rfl‚ü©‚ü©, rfl‚ü©, rfl‚ü©, hf‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.iSup_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒπ : Type u_2\nW : Œπ ‚Üí CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Iff (iSup W f) (Exists fun i => W i f)","decl":"@[simp]\nlemma iSup_iff {Œπ : Type*} (W : Œπ ‚Üí MorphismProperty C) {X Y : C} (f : X ‚ü∂ Y) :\n    iSup W f ‚Üî ‚àÉ i, W i f := by\n  apply (sSup_iff (Set.range W) f).trans\n  constructor\n  ¬∑ rintro ‚ü®‚ü®_, i, rfl‚ü©, hf‚ü©\n    exact ‚ü®i, hf‚ü©\n  ¬∑ rintro ‚ü®i, hf‚ü©\n    exact ‚ü®‚ü®_, i, rfl‚ü©, hf‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.unop_op","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n‚ä¢ Eq P.op.unop P","decl":"theorem unop_op (P : MorphismProperty C) : P.op.unop = P :=\n  rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.op_unop","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty (Opposite C)\n‚ä¢ Eq P.unop.op P","decl":"theorem op_unop (P : MorphismProperty C·µí·µñ) : P.unop.op = P :=\n  rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.inverseImage_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty D\nF : CategoryTheory.Functor C D\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Iff (P.inverseImage F f) (P (F.map f))","decl":"@[simp]\nlemma inverseImage_iff (P : MorphismProperty D) (F : C ‚•§ D) {X Y : C} (f : X ‚ü∂ Y) :\n    P.inverseImage F f ‚Üî P (F.map f) := by rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.map_mem_map","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty C\nF : CategoryTheory.Functor C D\nX Y : C\nf : Quiver.Hom X Y\nhf : P f\n‚ä¢ P.map F (F.map f)","decl":"lemma map_mem_map (P : MorphismProperty C) (F : C ‚•§ D) {X Y : C} (f : X ‚ü∂ Y) (hf : P f) :\n    (P.map F) (F.map f) := ‚ü®X, Y, f, hf, ‚ü®Iso.refl _‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.monotone_map","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nF : CategoryTheory.Functor C D\n‚ä¢ Monotone fun x => x.map F","decl":"lemma monotone_map (F : C ‚•§ D) :\n    Monotone (map ¬∑ F) := by\n  intro P Q h X Y f ‚ü®X', Y', f', hf', ‚ü®e‚ü©‚ü©\n  exact ‚ü®X', Y', f', h _ hf', ‚ü®e‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.homFamily_apply","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nf : ‚ÜëP.toSet\n‚ä¢ Eq (P.homFamily f) (‚Üëf).hom","decl":"lemma homFamily_apply (f : P.toSet) : P.homFamily f = f.1.hom := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.homFamily_arrow_mk","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\nhf : P f\n‚ä¢ Eq (P.homFamily ‚ü®CategoryTheory.Arrow.mk f, hf‚ü©) f","decl":"@[simp]\nlemma homFamily_arrow_mk {X Y : C} (f : X ‚ü∂ Y) (hf : P f) :\n    P.homFamily ‚ü®Arrow.mk f, hf‚ü© = f := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.arrow_mk_mem_toSet_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Iff (Membership.mem P.toSet (CategoryTheory.Arrow.mk f)) (P f)","decl":"@[simp]\nlemma arrow_mk_mem_toSet_iff {X Y : C} (f : X ‚ü∂ Y) : Arrow.mk f ‚àà P.toSet ‚Üî P f := Iff.rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.of_eq","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\nhf : P f\nX' Y' : C\nf' : Quiver.Hom X' Y'\nhX : Eq X X'\nhY : Eq Y Y'\nh : Eq f' (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom hY)))\n‚ä¢ P f'","decl":"lemma of_eq {X Y : C} {f : X ‚ü∂ Y} (hf : P f)\n    {X' Y' : C} {f' : X' ‚ü∂ Y'}\n    (hX : X = X') (hY : Y = Y') (h : f' = eqToHom hX.symm ‚â´ f ‚â´ eqToHom hY) :\n    P f' := by\n  rw [‚Üê P.arrow_mk_mem_toSet_iff] at hf ‚ä¢\n  rwa [(Arrow.mk_eq_mk_iff f' f).2 ‚ü®hX.symm, hY.symm, h‚ü©]\n\n"}
{"name":"CategoryTheory.MorphismProperty.ofHoms_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒπ : Type u_2\nX Y : Œπ ‚Üí C\nf : (i : Œπ) ‚Üí Quiver.Hom (X i) (Y i)\nA B : C\ng : Quiver.Hom A B\n‚ä¢ Iff (CategoryTheory.MorphismProperty.ofHoms f g) (Exists fun i => Eq (CategoryTheory.Arrow.mk g) (CategoryTheory.Arrow.mk (f i)))","decl":"lemma ofHoms_iff {Œπ : Type*} {X Y : Œπ ‚Üí C} (f : ‚àÄ i, X i ‚ü∂ Y i) {A B : C} (g : A ‚ü∂ B) :\n    ofHoms f g ‚Üî ‚àÉ i, Arrow.mk g = Arrow.mk (f i) := by\n  constructor\n  ¬∑ rintro ‚ü®i‚ü©\n    exact ‚ü®i, rfl‚ü©\n  ¬∑ rintro ‚ü®i, h‚ü©\n    rw [‚Üê (ofHoms f).arrow_mk_mem_toSet_iff, h, arrow_mk_mem_toSet_iff]\n    constructor\n\n"}
{"name":"CategoryTheory.MorphismProperty.ofHoms_homFamily","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n‚ä¢ Eq (CategoryTheory.MorphismProperty.ofHoms P.homFamily) P","decl":"@[simp]\nlemma ofHoms_homFamily (P : MorphismProperty C) : ofHoms P.homFamily = P := by\n  ext _ _ f\n  constructor\n  ¬∑ intro hf\n    rw [ofHoms_iff] at hf\n    obtain ‚ü®‚ü®f, hf‚ü©, ‚ü®_, _‚ü©‚ü© := hf\n    exact hf\n  ¬∑ intro hf\n    exact ‚ü®(‚ü®f, hf‚ü© : P.toSet)‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsRight.postcomp","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\nself : P.RespectsRight Q\nX Y Z : C\ni : Quiver.Hom Y Z\nhi : Q i\nf : Quiver.Hom X Y\nhf : P f\n‚ä¢ P (CategoryTheory.CategoryStruct.comp f i)","decl":"/-- A morphism property `P` satisfies `P.RespectsRight Q` if it is stable under post-composition\nwith morphisms satisfying `Q`, i.e. whenever `P` holds for `f` and `Q` holds for `i` then `P`\nholds for `f ‚â´ i`. -/\nclass RespectsRight (P Q : MorphismProperty C) : Prop where\n  postcomp {X Y Z : C} (i : Y ‚ü∂ Z) (hi : Q i) (f : X ‚ü∂ Y) (hf : P f) : P (f ‚â´ i)\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsLeft.precomp","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\nself : P.RespectsLeft Q\nX Y Z : C\ni : Quiver.Hom X Y\nhi : Q i\nf : Quiver.Hom Y Z\nhf : P f\n‚ä¢ P (CategoryTheory.CategoryStruct.comp i f)","decl":"/-- A morphism property `P` satisfies `P.RespectsLeft Q` if it is stable under\npre-composition with morphisms satisfying `Q`, i.e. whenever `P` holds for `f`\nand `Q` holds for `i` then `P` holds for `i ‚â´ f`. -/\nclass RespectsLeft (P Q : MorphismProperty C) : Prop where\n  precomp {X Y Z : C} (i : X ‚ü∂ Y) (hi : Q i) (f : Y ‚ü∂ Z) (hf : P f) : P (i ‚â´ f)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Respects.toRespectsLeft","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\nself : P.Respects Q\n‚ä¢ P.RespectsLeft Q","decl":"/-- A morphism property `P` satisfies `P.Respects Q` if it is stable under composition on the\nleft and right by morphisms satisfying `Q`. -/\nclass Respects (P Q : MorphismProperty C) extends P.RespectsLeft Q, P.RespectsRight Q : Prop where\n\n"}
{"name":"CategoryTheory.MorphismProperty.Respects.toRespectsRight","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\nself : P.Respects Q\n‚ä¢ P.RespectsRight Q","decl":"/-- A morphism property `P` satisfies `P.Respects Q` if it is stable under composition on the\nleft and right by morphisms satisfying `Q`. -/\nclass Respects (P Q : MorphismProperty C) extends P.RespectsLeft Q, P.RespectsRight Q : Prop where\n\n"}
{"name":"CategoryTheory.MorphismProperty.instRespectsOfRespectsLeftOfRespectsRight","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\ninst‚úù¬π : P.RespectsLeft Q\ninst‚úù : P.RespectsRight Q\n‚ä¢ P.Respects Q","decl":"instance (P Q : MorphismProperty C) [P.RespectsLeft Q] [P.RespectsRight Q] : P.Respects Q where\n\n"}
{"name":"CategoryTheory.MorphismProperty.instRespectsRightOppositeOpOfRespectsLeft","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\ninst‚úù : P.RespectsLeft Q\n‚ä¢ P.op.RespectsRight Q.op","decl":"instance (P Q : MorphismProperty C) [P.RespectsLeft Q] : P.op.RespectsRight Q.op where\n  postcomp i hi f hf := RespectsLeft.precomp (Q := Q) i.unop hi f.unop hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.instRespectsLeftOppositeOpOfRespectsRight","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\ninst‚úù : P.RespectsRight Q\n‚ä¢ P.op.RespectsLeft Q.op","decl":"instance (P Q : MorphismProperty C) [P.RespectsRight Q] : P.op.RespectsLeft Q.op where\n  precomp i hi f hf := RespectsRight.postcomp (Q := Q) i.unop hi f.unop hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsLeft.inf","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP‚ÇÅ P‚ÇÇ Q : CategoryTheory.MorphismProperty C\ninst‚úù¬π : P‚ÇÅ.RespectsLeft Q\ninst‚úù : P‚ÇÇ.RespectsLeft Q\n‚ä¢ (Min.min P‚ÇÅ P‚ÇÇ).RespectsLeft Q","decl":"instance RespectsLeft.inf (P‚ÇÅ P‚ÇÇ Q : MorphismProperty C) [P‚ÇÅ.RespectsLeft Q]\n    [P‚ÇÇ.RespectsLeft Q] : (P‚ÇÅ ‚äì P‚ÇÇ).RespectsLeft Q where\n  precomp i hi f hf := ‚ü®precomp i hi f hf.left, precomp i hi f hf.right‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsRight.inf","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP‚ÇÅ P‚ÇÇ Q : CategoryTheory.MorphismProperty C\ninst‚úù¬π : P‚ÇÅ.RespectsRight Q\ninst‚úù : P‚ÇÇ.RespectsRight Q\n‚ä¢ (Min.min P‚ÇÅ P‚ÇÇ).RespectsRight Q","decl":"instance RespectsRight.inf (P‚ÇÅ P‚ÇÇ Q : MorphismProperty C) [P‚ÇÅ.RespectsRight Q]\n    [P‚ÇÇ.RespectsRight Q] : (P‚ÇÅ ‚äì P‚ÇÇ).RespectsRight Q where\n  postcomp i hi f hf := ‚ü®postcomp i hi f hf.left, postcomp i hi f hf.right‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsIso.mk","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nhprecomp : ‚àÄ {X Y Z : C} (e : CategoryTheory.Iso X Y) (f : Quiver.Hom Y Z), P f ‚Üí P (CategoryTheory.CategoryStruct.comp e.hom f)\nhpostcomp : ‚àÄ {X Y Z : C} (e : CategoryTheory.Iso Y Z) (f : Quiver.Hom X Y), P f ‚Üí P (CategoryTheory.CategoryStruct.comp f e.hom)\n‚ä¢ P.RespectsIso","decl":"lemma RespectsIso.mk (P : MorphismProperty C)\n    (hprecomp : ‚àÄ {X Y Z : C} (e : X ‚âÖ Y) (f : Y ‚ü∂ Z) (_ : P f), P (e.hom ‚â´ f))\n    (hpostcomp : ‚àÄ {X Y Z : C} (e : Y ‚âÖ Z) (f : X ‚ü∂ Y) (_ : P f), P (f ‚â´ e.hom)) :\n    P.RespectsIso where\n  precomp e (_ : IsIso e) f hf := hprecomp (asIso e) f hf\n  postcomp e (_ : IsIso e) f hf := hpostcomp (asIso e) f hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsIso.precomp","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬π : P.RespectsIso\nX Y Z : C\ne : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso e\nf : Quiver.Hom Y Z\nhf : P f\n‚ä¢ P (CategoryTheory.CategoryStruct.comp e f)","decl":"lemma RespectsIso.precomp (P : MorphismProperty C) [P.RespectsIso] {X Y Z : C} (e : X ‚ü∂ Y)\n    [IsIso e] (f : Y ‚ü∂ Z) (hf : P f) : P (e ‚â´ f) :=\n  RespectsLeft.precomp (Q := isomorphisms C) e ‚ÄπIsIso e‚Ä∫ f hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.instRespectsIsoTop","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Top.top.RespectsIso","decl":"instance : RespectsIso (‚ä§ : MorphismProperty C) where\n  precomp _ _ _ _ := trivial\n  postcomp _ _ _ _ := trivial\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsIso.postcomp","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬π : P.RespectsIso\nX Y Z : C\ne : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.IsIso e\nf : Quiver.Hom X Y\nhf : P f\n‚ä¢ P (CategoryTheory.CategoryStruct.comp f e)","decl":"lemma RespectsIso.postcomp (P : MorphismProperty C) [P.RespectsIso] {X Y Z : C} (e : Y ‚ü∂ Z)\n    [IsIso e] (f : X ‚ü∂ Y) (hf : P f) : P (f ‚â´ e) :=\n  RespectsRight.postcomp (Q := isomorphisms C) e ‚ÄπIsIso e‚Ä∫ f hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsIso.op","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù : P.RespectsIso\n‚ä¢ P.op.RespectsIso","decl":"instance RespectsIso.op (P : MorphismProperty C) [RespectsIso P] : RespectsIso P.op where\n  precomp e (_ : IsIso e) f hf := postcomp P e.unop f.unop hf\n  postcomp e (_ : IsIso e) f hf := precomp P e.unop f.unop hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsIso.unop","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty (Opposite C)\ninst‚úù : P.RespectsIso\n‚ä¢ P.unop.RespectsIso","decl":"instance RespectsIso.unop (P : MorphismProperty C·µí·µñ) [RespectsIso P] : RespectsIso P.unop where\n  precomp e (_ : IsIso e) f hf := postcomp P e.op f.op hf\n  postcomp e (_ : IsIso e) f hf := precomp P e.op f.op hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.le_isoClosure","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n‚ä¢ LE.le P P.isoClosure","decl":"lemma le_isoClosure (P : MorphismProperty C) : P ‚â§ P.isoClosure :=\n  fun _ _ f hf => ‚ü®_, _, f, hf, ‚ü®Iso.refl _‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.isoClosure_respectsIso","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n‚ä¢ P.isoClosure.RespectsIso","decl":"instance isoClosure_respectsIso (P : MorphismProperty C) :\n    RespectsIso P.isoClosure where\n  precomp := fun e (he : IsIso e) f ‚ü®_, _, f', hf', ‚ü®iso‚ü©‚ü© => ‚ü®_, _, f', hf',\n      ‚ü®Arrow.isoMk (asIso iso.hom.left ‚â™‚â´ asIso (inv e)) (asIso iso.hom.right) (by simp)‚ü©‚ü©\n  postcomp := fun e (he : IsIso e) f ‚ü®_, _, f', hf', ‚ü®iso‚ü©‚ü© => ‚ü®_, _, f', hf',\n      ‚ü®Arrow.isoMk (asIso iso.hom.left) (asIso iso.hom.right ‚â™‚â´ asIso e) (by simp)‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.monotone_isoClosure","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Monotone CategoryTheory.MorphismProperty.isoClosure","decl":"lemma monotone_isoClosure : Monotone (isoClosure (C := C)) := by\n  intro P Q h X Y f ‚ü®X', Y', f', hf', ‚ü®e‚ü©‚ü©\n  exact ‚ü®X', Y', f', h _ hf', ‚ü®e‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.cancel_left_of_respectsIso","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nhP : P.RespectsIso\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.IsIso f\n‚ä¢ Iff (P (CategoryTheory.CategoryStruct.comp f g)) (P g)","decl":"theorem cancel_left_of_respectsIso (P : MorphismProperty C) [hP : RespectsIso P] {X Y Z : C}\n    (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsIso f] : P (f ‚â´ g) ‚Üî P g :=\n  ‚ü®fun h => by simpa using RespectsIso.precomp P (inv f) (f ‚â´ g) h, RespectsIso.precomp P f g‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.cancel_right_of_respectsIso","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nhP : P.RespectsIso\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.IsIso g\n‚ä¢ Iff (P (CategoryTheory.CategoryStruct.comp f g)) (P f)","decl":"theorem cancel_right_of_respectsIso (P : MorphismProperty C) [hP : RespectsIso P] {X Y Z : C}\n    (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsIso g] : P (f ‚â´ g) ‚Üî P f :=\n  ‚ü®fun h => by simpa using RespectsIso.postcomp P (inv g) (f ‚â´ g) h, RespectsIso.postcomp P g f‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.comma_iso_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬≤ : P.RespectsIso\nA : Type u_2\nB : Type u_3\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_2} A\ninst‚úù : CategoryTheory.Category.{u_5, u_3} B\nL : CategoryTheory.Functor A C\nR : CategoryTheory.Functor B C\nf g : CategoryTheory.Comma L R\ne : CategoryTheory.Iso f g\n‚ä¢ Iff (P f.hom) (P g.hom)","decl":"lemma comma_iso_iff (P : MorphismProperty C) [P.RespectsIso] {A B : Type*} [Category A] [Category B]\n    {L : A ‚•§ C} {R : B ‚•§ C} {f g : Comma L R} (e : f ‚âÖ g) :\n    P f.hom ‚Üî P g.hom := by\n  simp [‚Üê Comma.inv_left_hom_right e.hom, cancel_left_of_respectsIso, cancel_right_of_respectsIso]\n\n"}
{"name":"CategoryTheory.MorphismProperty.arrow_iso_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù : P.RespectsIso\nf g : CategoryTheory.Arrow C\ne : CategoryTheory.Iso f g\n‚ä¢ Iff (P f.hom) (P g.hom)","decl":"theorem arrow_iso_iff (P : MorphismProperty C) [RespectsIso P] {f g : Arrow C}\n    (e : f ‚âÖ g) : P f.hom ‚Üî P g.hom :=\n  P.comma_iso_iff e\n\n"}
{"name":"CategoryTheory.MorphismProperty.arrow_mk_iso_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù : P.RespectsIso\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom Y Z\ne : CategoryTheory.Iso (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\n‚ä¢ Iff (P f) (P g)","decl":"theorem arrow_mk_iso_iff (P : MorphismProperty C) [RespectsIso P] {W X Y Z : C}\n    {f : W ‚ü∂ X} {g : Y ‚ü∂ Z} (e : Arrow.mk f ‚âÖ Arrow.mk g) : P f ‚Üî P g :=\n  P.arrow_iso_iff e\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsIso.of_respects_arrow_iso","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nhP : ‚àÄ (f g : CategoryTheory.Arrow C), CategoryTheory.Iso f g ‚Üí P f.hom ‚Üí P g.hom\n‚ä¢ P.RespectsIso","decl":"theorem RespectsIso.of_respects_arrow_iso (P : MorphismProperty C)\n    (hP : ‚àÄ (f g : Arrow C) (_ : f ‚âÖ g) (_ : P f.hom), P g.hom) : RespectsIso P where\n  precomp {X Y Z} e (he : IsIso e) f hf := by\n    refine hP (Arrow.mk f) (Arrow.mk (e ‚â´ f)) (Arrow.isoMk (asIso (inv e)) (Iso.refl _) ?_) hf\n    simp\n  postcomp {X Y Z} e (he : IsIso e) f hf := by\n    refine hP (Arrow.mk f) (Arrow.mk (f ‚â´ e)) (Arrow.isoMk (Iso.refl _) (asIso e) ?_) hf\n    simp\n\n"}
{"name":"CategoryTheory.MorphismProperty.isoClosure_eq_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n‚ä¢ Iff (Eq P.isoClosure P) P.RespectsIso","decl":"lemma isoClosure_eq_iff (P : MorphismProperty C) :\n    P.isoClosure = P ‚Üî P.RespectsIso := by\n  refine ‚ü®(¬∑ ‚ñ∏ P.isoClosure_respectsIso), fun hP ‚Ü¶ le_antisymm ?_ (P.le_isoClosure)‚ü©\n  intro X Y f ‚ü®X', Y', f', hf', ‚ü®e‚ü©‚ü©\n  exact (P.arrow_mk_iso_iff e).1 hf'\n\n"}
{"name":"CategoryTheory.MorphismProperty.isoClosure_eq_self","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù : P.RespectsIso\n‚ä¢ Eq P.isoClosure P","decl":"lemma isoClosure_eq_self (P : MorphismProperty C) [P.RespectsIso] :\n    P.isoClosure = P := by rwa [isoClosure_eq_iff]\n\n"}
{"name":"CategoryTheory.MorphismProperty.isoClosure_isoClosure","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n‚ä¢ Eq P.isoClosure.isoClosure P.isoClosure","decl":"@[simp]\nlemma isoClosure_isoClosure (P : MorphismProperty C) :\n    P.isoClosure.isoClosure = P.isoClosure :=\n  P.isoClosure.isoClosure_eq_self\n\n"}
{"name":"CategoryTheory.MorphismProperty.isoClosure_le_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\ninst‚úù : Q.RespectsIso\n‚ä¢ Iff (LE.le P.isoClosure Q) (LE.le P Q)","decl":"lemma isoClosure_le_iff (P Q : MorphismProperty C) [Q.RespectsIso] :\n    P.isoClosure ‚â§ Q ‚Üî P ‚â§ Q := by\n  constructor\n  ¬∑ exact P.le_isoClosure.trans\n  ¬∑ intro h\n    exact (monotone_isoClosure h).trans (by rw [Q.isoClosure_eq_self])\n\n"}
{"name":"CategoryTheory.MorphismProperty.map_respectsIso","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty C\nF : CategoryTheory.Functor C D\n‚ä¢ (P.map F).RespectsIso","decl":"instance map_respectsIso (P : MorphismProperty C) (F : C ‚•§ D) :\n    (P.map F).RespectsIso := by\n  apply RespectsIso.of_respects_arrow_iso\n  intro f g e ‚ü®X', Y', f', hf', ‚ü®e'‚ü©‚ü©\n  exact ‚ü®X', Y', f', hf', ‚ü®e' ‚â™‚â´ e‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.map_le_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty C\nF : CategoryTheory.Functor C D\nQ : CategoryTheory.MorphismProperty D\ninst‚úù : Q.RespectsIso\n‚ä¢ Iff (LE.le (P.map F) Q) (LE.le P (Q.inverseImage F))","decl":"lemma map_le_iff (P : MorphismProperty C) {F : C ‚•§ D} (Q : MorphismProperty D)\n    [RespectsIso Q] :\n    P.map F ‚â§ Q ‚Üî P ‚â§ Q.inverseImage F := by\n  constructor\n  ¬∑ intro h X Y f hf\n    exact h (F.map f) (map_mem_map P F f hf)\n  ¬∑ intro h X Y f ‚ü®X', Y', f', hf', ‚ü®e‚ü©‚ü©\n    exact (Q.arrow_mk_iso_iff e).1 (h _ hf')\n\n"}
{"name":"CategoryTheory.MorphismProperty.map_isoClosure","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty C\nF : CategoryTheory.Functor C D\n‚ä¢ Eq (P.isoClosure.map F) (P.map F)","decl":"@[simp]\nlemma map_isoClosure (P : MorphismProperty C) (F : C ‚•§ D) :\n    P.isoClosure.map F = P.map F := by\n  apply le_antisymm\n  ¬∑ rw [map_le_iff]\n    intro X Y f ‚ü®X', Y', f', hf', ‚ü®e‚ü©‚ü©\n    exact ‚ü®_, _, f', hf', ‚ü®F.mapArrow.mapIso e‚ü©‚ü©\n  ¬∑ exact monotone_map _ (le_isoClosure P)\n\n"}
{"name":"CategoryTheory.MorphismProperty.map_id_eq_isoClosure","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n‚ä¢ Eq (P.map (CategoryTheory.Functor.id C)) P.isoClosure","decl":"lemma map_id_eq_isoClosure (P : MorphismProperty C) :\n    P.map (ùü≠ _) = P.isoClosure := by\n  apply le_antisymm\n  ¬∑ rw [map_le_iff]\n    intro X Y f hf\n    exact P.le_isoClosure _ hf\n  ¬∑ intro X Y f hf\n    exact hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.map_id","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst‚úù : P.RespectsIso\n‚ä¢ Eq (P.map (CategoryTheory.Functor.id C)) P","decl":"lemma map_id (P : MorphismProperty C) [RespectsIso P] :\n    P.map (ùü≠ _) = P := by\n  rw [map_id_eq_isoClosure, P.isoClosure_eq_self]\n\n"}
{"name":"CategoryTheory.MorphismProperty.map_map","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} D\nP : CategoryTheory.MorphismProperty C\nF : CategoryTheory.Functor C D\nE : Type u_2\ninst‚úù : CategoryTheory.Category.{u_4, u_2} E\nG : CategoryTheory.Functor D E\n‚ä¢ Eq ((P.map F).map G) (P.map (F.comp G))","decl":"@[simp]\nlemma map_map (P : MorphismProperty C) (F : C ‚•§ D) {E : Type*} [Category E] (G : D ‚•§ E) :\n    (P.map F).map G = P.map (F ‚ãô G) := by\n  apply le_antisymm\n  ¬∑ rw [map_le_iff]\n    intro X Y f ‚ü®X', Y', f', hf', ‚ü®e‚ü©‚ü©\n    exact ‚ü®X', Y', f', hf', ‚ü®G.mapArrow.mapIso e‚ü©‚ü©\n  ¬∑ rw [map_le_iff]\n    intro X Y f hf\n    exact map_mem_map _ _ _ (map_mem_map _ _ _ hf)\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsIso.inverseImage","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty D\ninst‚úù : P.RespectsIso\nF : CategoryTheory.Functor C D\n‚ä¢ (P.inverseImage F).RespectsIso","decl":"instance RespectsIso.inverseImage (P : MorphismProperty D) [RespectsIso P] (F : C ‚•§ D) :\n    RespectsIso (P.inverseImage F) where\n  precomp {X Y Z} e (he : IsIso e) f hf := by\n    simpa [MorphismProperty.inverseImage, cancel_left_of_respectsIso] using hf\n  postcomp {X Y Z} e (he : IsIso e) f hf := by\n    simpa [MorphismProperty.inverseImage, cancel_right_of_respectsIso] using hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.map_eq_of_iso","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty C\nF G : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F G\n‚ä¢ Eq (P.map F) (P.map G)","decl":"lemma map_eq_of_iso (P : MorphismProperty C) {F G : C ‚•§ D} (e : F ‚âÖ G) :\n    P.map F = P.map G := by\n  revert F G e\n  suffices ‚àÄ {F G : C ‚•§ D} (_ : F ‚âÖ G), P.map F ‚â§ P.map G from\n    fun F G e => le_antisymm (this e) (this e.symm)\n  intro F G e X Y f ‚ü®X', Y', f', hf', ‚ü®e'‚ü©‚ü©\n  exact ‚ü®X', Y', f', hf', ‚ü®((Functor.mapArrowFunctor _ _).mapIso e.symm).app (Arrow.mk f') ‚â™‚â´ e'‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.map_inverseImage_le","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty D\nF : CategoryTheory.Functor C D\n‚ä¢ LE.le ((P.inverseImage F).map F) P.isoClosure","decl":"lemma map_inverseImage_le (P : MorphismProperty D) (F : C ‚•§ D) :\n    (P.inverseImage F).map F ‚â§ P.isoClosure :=\n  fun _ _ _ ‚ü®_, _, f, hf, ‚ü®e‚ü©‚ü© => ‚ü®_, _, F.map f, hf, ‚ü®e‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.inverseImage_equivalence_inverse_eq_map_functor","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty D\ninst‚úù : P.RespectsIso\nE : CategoryTheory.Equivalence C D\n‚ä¢ Eq (P.inverseImage E.functor) (P.map E.inverse)","decl":"lemma inverseImage_equivalence_inverse_eq_map_functor\n    (P : MorphismProperty D) [RespectsIso P] (E : C ‚âå D) :\n    P.inverseImage E.functor = P.map E.inverse := by\n  apply le_antisymm\n  ¬∑ intro X Y f hf\n    refine ‚ü®_, _, _, hf, ‚ü®?_‚ü©‚ü©\n    exact ((Functor.mapArrowFunctor _ _).mapIso E.unitIso.symm).app (Arrow.mk f)\n  ¬∑ rw [map_le_iff]\n    intro X Y f hf\n    exact (P.arrow_mk_iso_iff\n      (((Functor.mapArrowFunctor _ _).mapIso E.counitIso).app (Arrow.mk f))).2 hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.inverseImage_equivalence_functor_eq_map_inverse","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} D\nQ : CategoryTheory.MorphismProperty C\ninst‚úù : Q.RespectsIso\nE : CategoryTheory.Equivalence C D\n‚ä¢ Eq (Q.inverseImage E.inverse) (Q.map E.functor)","decl":"lemma inverseImage_equivalence_functor_eq_map_inverse\n    (Q : MorphismProperty C) [RespectsIso Q] (E : C ‚âå D) :\n    Q.inverseImage E.inverse = Q.map E.functor :=\n  inverseImage_equivalence_inverse_eq_map_functor Q E.symm\n\n"}
{"name":"CategoryTheory.MorphismProperty.map_inverseImage_eq_of_isEquivalence","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty D\ninst‚úù¬π : P.RespectsIso\nF : CategoryTheory.Functor C D\ninst‚úù : F.IsEquivalence\n‚ä¢ Eq ((P.inverseImage F).map F) P","decl":"lemma map_inverseImage_eq_of_isEquivalence\n    (P : MorphismProperty D) [P.RespectsIso] (F : C ‚•§ D) [F.IsEquivalence] :\n    (P.inverseImage F).map F = P := by\n  erw [P.inverseImage_equivalence_inverse_eq_map_functor F.asEquivalence, map_map,\n    P.map_eq_of_iso F.asEquivalence.counitIso, map_id]\n\n"}
{"name":"CategoryTheory.MorphismProperty.inverseImage_map_eq_of_isEquivalence","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty C\ninst‚úù¬π : P.RespectsIso\nF : CategoryTheory.Functor C D\ninst‚úù : F.IsEquivalence\n‚ä¢ Eq ((P.map F).inverseImage F) P","decl":"lemma inverseImage_map_eq_of_isEquivalence\n    (P : MorphismProperty C) [P.RespectsIso] (F : C ‚•§ D) [F.IsEquivalence] :\n    (P.map F).inverseImage F = P := by\n  erw [((P.map F).inverseImage_equivalence_inverse_eq_map_functor (F.asEquivalence)), map_map,\n    P.map_eq_of_iso F.asEquivalence.unitIso.symm, map_id]\n\n"}
{"name":"CategoryTheory.MorphismProperty.isomorphisms.iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Iff (CategoryTheory.MorphismProperty.isomorphisms C f) (CategoryTheory.IsIso f)","decl":"@[simp]\ntheorem isomorphisms.iff : (isomorphisms C) f ‚Üî IsIso f := by rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.monomorphisms.iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Iff (CategoryTheory.MorphismProperty.monomorphisms C f) (CategoryTheory.Mono f)","decl":"@[simp]\ntheorem monomorphisms.iff : (monomorphisms C) f ‚Üî Mono f := by rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.epimorphisms.iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Iff (CategoryTheory.MorphismProperty.epimorphisms C f) (CategoryTheory.Epi f)","decl":"@[simp]\ntheorem epimorphisms.iff : (epimorphisms C) f ‚Üî Epi f := by rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.isomorphisms.infer_property","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nhf : CategoryTheory.IsIso f\n‚ä¢ CategoryTheory.MorphismProperty.isomorphisms C f","decl":"theorem isomorphisms.infer_property [hf : IsIso f] : (isomorphisms C) f :=\n  hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.monomorphisms.infer_property","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nhf : CategoryTheory.Mono f\n‚ä¢ CategoryTheory.MorphismProperty.monomorphisms C f","decl":"theorem monomorphisms.infer_property [hf : Mono f] : (monomorphisms C) f :=\n  hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.epimorphisms.infer_property","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nhf : CategoryTheory.Epi f\n‚ä¢ CategoryTheory.MorphismProperty.epimorphisms C f","decl":"theorem epimorphisms.infer_property [hf : Epi f] : (epimorphisms C) f :=\n  hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsIso.monomorphisms","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ (CategoryTheory.MorphismProperty.monomorphisms C).RespectsIso","decl":"instance RespectsIso.monomorphisms : RespectsIso (monomorphisms C) := by\n  apply RespectsIso.mk <;>\n    ¬∑ intro X Y Z e f\n      simp only [monomorphisms.iff]\n      intro\n      apply mono_comp\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsIso.epimorphisms","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ (CategoryTheory.MorphismProperty.epimorphisms C).RespectsIso","decl":"instance RespectsIso.epimorphisms : RespectsIso (epimorphisms C) := by\n  apply RespectsIso.mk <;>\n    ¬∑ intro X Y Z e f\n      simp only [epimorphisms.iff]\n      intro\n      apply epi_comp\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsIso.isomorphisms","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ (CategoryTheory.MorphismProperty.isomorphisms C).RespectsIso","decl":"instance RespectsIso.isomorphisms : RespectsIso (isomorphisms C) := by\n  apply RespectsIso.mk <;>\n    ¬∑ intro X Y Z e f\n      simp only [isomorphisms.iff]\n      intro\n      exact IsIso.comp_isIso\n\n"}
{"name":"CategoryTheory.NatTrans.isIso_app_iff_of_iso","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nF G : CategoryTheory.Functor C D\nŒ± : Quiver.Hom F G\nX Y : C\ne : CategoryTheory.Iso X Y\n‚ä¢ Iff (CategoryTheory.IsIso (Œ±.app X)) (CategoryTheory.IsIso (Œ±.app Y))","decl":"lemma isIso_app_iff_of_iso {F G : C ‚•§ D} (Œ± : F ‚ü∂ G) {X Y : C} (e : X ‚âÖ Y) :\n    IsIso (Œ±.app X) ‚Üî IsIso (Œ±.app Y) :=\n  (MorphismProperty.isomorphisms D).arrow_mk_iso_iff\n    (Arrow.isoMk (F.mapIso e) (G.mapIso e) (by simp))\n\n"}
