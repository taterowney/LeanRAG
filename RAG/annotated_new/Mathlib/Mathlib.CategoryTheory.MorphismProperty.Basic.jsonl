{"name":"CategoryTheory.MorphismProperty.le_def","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\n⊢ Iff (LE.le P Q) (∀ {X Y : C} (f : Quiver.Hom X Y), P f → Q f)","decl":"lemma MorphismProperty.le_def {P Q : MorphismProperty C} :\n    P ≤ Q ↔ ∀ {X Y : C} (f : X ⟶ Y), P f → Q f := Iff.rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.top_eq","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq Top.top fun x x_1 x => True","decl":"lemma MorphismProperty.top_eq : (⊤ : MorphismProperty C) = fun _ _ _ => True := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.ext","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nW W' : CategoryTheory.MorphismProperty C\nh : ∀ ⦃X Y : C⦄ (f : Quiver.Hom X Y), Iff (W f) (W' f)\n⊢ Eq W W'","decl":"@[ext]\nlemma ext (W W' : MorphismProperty C) (h : ∀ ⦃X Y : C⦄ (f : X ⟶ Y), W f ↔ W' f) :\n    W = W' := by\n  funext X Y f\n  rw [h]\n\n"}
{"name":"CategoryTheory.MorphismProperty.ext_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nW W' : CategoryTheory.MorphismProperty C\n⊢ Iff (Eq W W') (∀ ⦃X Y : C⦄ (f : Quiver.Hom X Y), Iff (W f) (W' f))","decl":"@[ext]\nlemma ext (W W' : MorphismProperty C) (h : ∀ ⦃X Y : C⦄ (f : X ⟶ Y), W f ↔ W' f) :\n    W = W' := by\n  funext X Y f\n  rw [h]\n\n"}
{"name":"CategoryTheory.MorphismProperty.top_apply","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Top.top f","decl":"@[simp]\nlemma top_apply {X Y : C} (f : X ⟶ Y) : (⊤ : MorphismProperty C) f := by\n  simp only [top_eq]\n\n"}
{"name":"CategoryTheory.MorphismProperty.sSup_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nS : Set (CategoryTheory.MorphismProperty C)\nX Y : C\nf : Quiver.Hom X Y\n⊢ Iff (SupSet.sSup S f) (Exists fun W => ↑W f)","decl":"@[simp]\nlemma sSup_iff (S : Set (MorphismProperty C)) {X Y : C} (f : X ⟶ Y) :\n    sSup S f ↔ ∃ (W : S), W.1 f := by\n  dsimp [sSup, iSup]\n  constructor\n  · rintro ⟨_, ⟨⟨_, ⟨⟨_, ⟨_, h⟩, rfl⟩, rfl⟩⟩, rfl⟩, hf⟩\n    exact ⟨⟨_, h⟩, hf⟩\n  · rintro ⟨⟨W, hW⟩, hf⟩\n    exact ⟨_, ⟨⟨_, ⟨_, ⟨⟨W, hW⟩, rfl⟩⟩, rfl⟩, rfl⟩, hf⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.iSup_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nι : Type u_2\nW : ι → CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Iff (iSup W f) (Exists fun i => W i f)","decl":"@[simp]\nlemma iSup_iff {ι : Type*} (W : ι → MorphismProperty C) {X Y : C} (f : X ⟶ Y) :\n    iSup W f ↔ ∃ i, W i f := by\n  apply (sSup_iff (Set.range W) f).trans\n  constructor\n  · rintro ⟨⟨_, i, rfl⟩, hf⟩\n    exact ⟨i, hf⟩\n  · rintro ⟨i, hf⟩\n    exact ⟨⟨_, i, rfl⟩, hf⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.unop_op","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n⊢ Eq P.op.unop P","decl":"theorem unop_op (P : MorphismProperty C) : P.op.unop = P :=\n  rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.op_unop","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty (Opposite C)\n⊢ Eq P.unop.op P","decl":"theorem op_unop (P : MorphismProperty Cᵒᵖ) : P.unop.op = P :=\n  rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.inverseImage_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty D\nF : CategoryTheory.Functor C D\nX Y : C\nf : Quiver.Hom X Y\n⊢ Iff (P.inverseImage F f) (P (F.map f))","decl":"@[simp]\nlemma inverseImage_iff (P : MorphismProperty D) (F : C ⥤ D) {X Y : C} (f : X ⟶ Y) :\n    P.inverseImage F f ↔ P (F.map f) := by rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.map_mem_map","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty C\nF : CategoryTheory.Functor C D\nX Y : C\nf : Quiver.Hom X Y\nhf : P f\n⊢ P.map F (F.map f)","decl":"lemma map_mem_map (P : MorphismProperty C) (F : C ⥤ D) {X Y : C} (f : X ⟶ Y) (hf : P f) :\n    (P.map F) (F.map f) := ⟨X, Y, f, hf, ⟨Iso.refl _⟩⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.monotone_map","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nF : CategoryTheory.Functor C D\n⊢ Monotone fun x => x.map F","decl":"lemma monotone_map (F : C ⥤ D) :\n    Monotone (map · F) := by\n  intro P Q h X Y f ⟨X', Y', f', hf', ⟨e⟩⟩\n  exact ⟨X', Y', f', h _ hf', ⟨e⟩⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.homFamily_apply","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nf : ↑P.toSet\n⊢ Eq (P.homFamily f) (↑f).hom","decl":"lemma homFamily_apply (f : P.toSet) : P.homFamily f = f.1.hom := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.homFamily_arrow_mk","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\nhf : P f\n⊢ Eq (P.homFamily ⟨CategoryTheory.Arrow.mk f, hf⟩) f","decl":"@[simp]\nlemma homFamily_arrow_mk {X Y : C} (f : X ⟶ Y) (hf : P f) :\n    P.homFamily ⟨Arrow.mk f, hf⟩ = f := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.arrow_mk_mem_toSet_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Iff (Membership.mem P.toSet (CategoryTheory.Arrow.mk f)) (P f)","decl":"@[simp]\nlemma arrow_mk_mem_toSet_iff {X Y : C} (f : X ⟶ Y) : Arrow.mk f ∈ P.toSet ↔ P f := Iff.rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.of_eq","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\nhf : P f\nX' Y' : C\nf' : Quiver.Hom X' Y'\nhX : Eq X X'\nhY : Eq Y Y'\nh : Eq f' (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.eqToHom hY)))\n⊢ P f'","decl":"lemma of_eq {X Y : C} {f : X ⟶ Y} (hf : P f)\n    {X' Y' : C} {f' : X' ⟶ Y'}\n    (hX : X = X') (hY : Y = Y') (h : f' = eqToHom hX.symm ≫ f ≫ eqToHom hY) :\n    P f' := by\n  rw [← P.arrow_mk_mem_toSet_iff] at hf ⊢\n  rwa [(Arrow.mk_eq_mk_iff f' f).2 ⟨hX.symm, hY.symm, h⟩]\n\n"}
{"name":"CategoryTheory.MorphismProperty.ofHoms_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nι : Type u_2\nX Y : ι → C\nf : (i : ι) → Quiver.Hom (X i) (Y i)\nA B : C\ng : Quiver.Hom A B\n⊢ Iff (CategoryTheory.MorphismProperty.ofHoms f g) (Exists fun i => Eq (CategoryTheory.Arrow.mk g) (CategoryTheory.Arrow.mk (f i)))","decl":"lemma ofHoms_iff {ι : Type*} {X Y : ι → C} (f : ∀ i, X i ⟶ Y i) {A B : C} (g : A ⟶ B) :\n    ofHoms f g ↔ ∃ i, Arrow.mk g = Arrow.mk (f i) := by\n  constructor\n  · rintro ⟨i⟩\n    exact ⟨i, rfl⟩\n  · rintro ⟨i, h⟩\n    rw [← (ofHoms f).arrow_mk_mem_toSet_iff, h, arrow_mk_mem_toSet_iff]\n    constructor\n\n"}
{"name":"CategoryTheory.MorphismProperty.ofHoms_homFamily","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n⊢ Eq (CategoryTheory.MorphismProperty.ofHoms P.homFamily) P","decl":"@[simp]\nlemma ofHoms_homFamily (P : MorphismProperty C) : ofHoms P.homFamily = P := by\n  ext _ _ f\n  constructor\n  · intro hf\n    rw [ofHoms_iff] at hf\n    obtain ⟨⟨f, hf⟩, ⟨_, _⟩⟩ := hf\n    exact hf\n  · intro hf\n    exact ⟨(⟨f, hf⟩ : P.toSet)⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsRight.postcomp","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\nself : P.RespectsRight Q\nX Y Z : C\ni : Quiver.Hom Y Z\nhi : Q i\nf : Quiver.Hom X Y\nhf : P f\n⊢ P (CategoryTheory.CategoryStruct.comp f i)","decl":"/-- A morphism property `P` satisfies `P.RespectsRight Q` if it is stable under post-composition\nwith morphisms satisfying `Q`, i.e. whenever `P` holds for `f` and `Q` holds for `i` then `P`\nholds for `f ≫ i`. -/\nclass RespectsRight (P Q : MorphismProperty C) : Prop where\n  postcomp {X Y Z : C} (i : Y ⟶ Z) (hi : Q i) (f : X ⟶ Y) (hf : P f) : P (f ≫ i)\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsLeft.precomp","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\nself : P.RespectsLeft Q\nX Y Z : C\ni : Quiver.Hom X Y\nhi : Q i\nf : Quiver.Hom Y Z\nhf : P f\n⊢ P (CategoryTheory.CategoryStruct.comp i f)","decl":"/-- A morphism property `P` satisfies `P.RespectsLeft Q` if it is stable under\npre-composition with morphisms satisfying `Q`, i.e. whenever `P` holds for `f`\nand `Q` holds for `i` then `P` holds for `i ≫ f`. -/\nclass RespectsLeft (P Q : MorphismProperty C) : Prop where\n  precomp {X Y Z : C} (i : X ⟶ Y) (hi : Q i) (f : Y ⟶ Z) (hf : P f) : P (i ≫ f)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Respects.toRespectsLeft","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\nself : P.Respects Q\n⊢ P.RespectsLeft Q","decl":"/-- A morphism property `P` satisfies `P.Respects Q` if it is stable under composition on the\nleft and right by morphisms satisfying `Q`. -/\nclass Respects (P Q : MorphismProperty C) extends P.RespectsLeft Q, P.RespectsRight Q : Prop where\n\n"}
{"name":"CategoryTheory.MorphismProperty.Respects.toRespectsRight","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\nself : P.Respects Q\n⊢ P.RespectsRight Q","decl":"/-- A morphism property `P` satisfies `P.Respects Q` if it is stable under composition on the\nleft and right by morphisms satisfying `Q`. -/\nclass Respects (P Q : MorphismProperty C) extends P.RespectsLeft Q, P.RespectsRight Q : Prop where\n\n"}
{"name":"CategoryTheory.MorphismProperty.instRespectsOfRespectsLeftOfRespectsRight","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\ninst✝¹ : P.RespectsLeft Q\ninst✝ : P.RespectsRight Q\n⊢ P.Respects Q","decl":"instance (P Q : MorphismProperty C) [P.RespectsLeft Q] [P.RespectsRight Q] : P.Respects Q where\n\n"}
{"name":"CategoryTheory.MorphismProperty.instRespectsRightOppositeOpOfRespectsLeft","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\ninst✝ : P.RespectsLeft Q\n⊢ P.op.RespectsRight Q.op","decl":"instance (P Q : MorphismProperty C) [P.RespectsLeft Q] : P.op.RespectsRight Q.op where\n  postcomp i hi f hf := RespectsLeft.precomp (Q := Q) i.unop hi f.unop hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.instRespectsLeftOppositeOpOfRespectsRight","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\ninst✝ : P.RespectsRight Q\n⊢ P.op.RespectsLeft Q.op","decl":"instance (P Q : MorphismProperty C) [P.RespectsRight Q] : P.op.RespectsLeft Q.op where\n  precomp i hi f hf := RespectsRight.postcomp (Q := Q) i.unop hi f.unop hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsLeft.inf","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nP₁ P₂ Q : CategoryTheory.MorphismProperty C\ninst✝¹ : P₁.RespectsLeft Q\ninst✝ : P₂.RespectsLeft Q\n⊢ (Min.min P₁ P₂).RespectsLeft Q","decl":"instance RespectsLeft.inf (P₁ P₂ Q : MorphismProperty C) [P₁.RespectsLeft Q]\n    [P₂.RespectsLeft Q] : (P₁ ⊓ P₂).RespectsLeft Q where\n  precomp i hi f hf := ⟨precomp i hi f hf.left, precomp i hi f hf.right⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsRight.inf","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nP₁ P₂ Q : CategoryTheory.MorphismProperty C\ninst✝¹ : P₁.RespectsRight Q\ninst✝ : P₂.RespectsRight Q\n⊢ (Min.min P₁ P₂).RespectsRight Q","decl":"instance RespectsRight.inf (P₁ P₂ Q : MorphismProperty C) [P₁.RespectsRight Q]\n    [P₂.RespectsRight Q] : (P₁ ⊓ P₂).RespectsRight Q where\n  postcomp i hi f hf := ⟨postcomp i hi f hf.left, postcomp i hi f hf.right⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsIso.mk","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nhprecomp : ∀ {X Y Z : C} (e : CategoryTheory.Iso X Y) (f : Quiver.Hom Y Z), P f → P (CategoryTheory.CategoryStruct.comp e.hom f)\nhpostcomp : ∀ {X Y Z : C} (e : CategoryTheory.Iso Y Z) (f : Quiver.Hom X Y), P f → P (CategoryTheory.CategoryStruct.comp f e.hom)\n⊢ P.RespectsIso","decl":"lemma RespectsIso.mk (P : MorphismProperty C)\n    (hprecomp : ∀ {X Y Z : C} (e : X ≅ Y) (f : Y ⟶ Z) (_ : P f), P (e.hom ≫ f))\n    (hpostcomp : ∀ {X Y Z : C} (e : Y ≅ Z) (f : X ⟶ Y) (_ : P f), P (f ≫ e.hom)) :\n    P.RespectsIso where\n  precomp e (_ : IsIso e) f hf := hprecomp (asIso e) f hf\n  postcomp e (_ : IsIso e) f hf := hpostcomp (asIso e) f hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsIso.precomp","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst✝¹ : P.RespectsIso\nX Y Z : C\ne : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso e\nf : Quiver.Hom Y Z\nhf : P f\n⊢ P (CategoryTheory.CategoryStruct.comp e f)","decl":"lemma RespectsIso.precomp (P : MorphismProperty C) [P.RespectsIso] {X Y Z : C} (e : X ⟶ Y)\n    [IsIso e] (f : Y ⟶ Z) (hf : P f) : P (e ≫ f) :=\n  RespectsLeft.precomp (Q := isomorphisms C) e ‹IsIso e› f hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.instRespectsIsoTop","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Top.top.RespectsIso","decl":"instance : RespectsIso (⊤ : MorphismProperty C) where\n  precomp _ _ _ _ := trivial\n  postcomp _ _ _ _ := trivial\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsIso.postcomp","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst✝¹ : P.RespectsIso\nX Y Z : C\ne : Quiver.Hom Y Z\ninst✝ : CategoryTheory.IsIso e\nf : Quiver.Hom X Y\nhf : P f\n⊢ P (CategoryTheory.CategoryStruct.comp f e)","decl":"lemma RespectsIso.postcomp (P : MorphismProperty C) [P.RespectsIso] {X Y Z : C} (e : Y ⟶ Z)\n    [IsIso e] (f : X ⟶ Y) (hf : P f) : P (f ≫ e) :=\n  RespectsRight.postcomp (Q := isomorphisms C) e ‹IsIso e› f hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsIso.op","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst✝ : P.RespectsIso\n⊢ P.op.RespectsIso","decl":"instance RespectsIso.op (P : MorphismProperty C) [RespectsIso P] : RespectsIso P.op where\n  precomp e (_ : IsIso e) f hf := postcomp P e.unop f.unop hf\n  postcomp e (_ : IsIso e) f hf := precomp P e.unop f.unop hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsIso.unop","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty (Opposite C)\ninst✝ : P.RespectsIso\n⊢ P.unop.RespectsIso","decl":"instance RespectsIso.unop (P : MorphismProperty Cᵒᵖ) [RespectsIso P] : RespectsIso P.unop where\n  precomp e (_ : IsIso e) f hf := postcomp P e.op f.op hf\n  postcomp e (_ : IsIso e) f hf := precomp P e.op f.op hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.le_isoClosure","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n⊢ LE.le P P.isoClosure","decl":"lemma le_isoClosure (P : MorphismProperty C) : P ≤ P.isoClosure :=\n  fun _ _ f hf => ⟨_, _, f, hf, ⟨Iso.refl _⟩⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.isoClosure_respectsIso","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n⊢ P.isoClosure.RespectsIso","decl":"instance isoClosure_respectsIso (P : MorphismProperty C) :\n    RespectsIso P.isoClosure where\n  precomp := fun e (he : IsIso e) f ⟨_, _, f', hf', ⟨iso⟩⟩ => ⟨_, _, f', hf',\n      ⟨Arrow.isoMk (asIso iso.hom.left ≪≫ asIso (inv e)) (asIso iso.hom.right) (by simp)⟩⟩\n  postcomp := fun e (he : IsIso e) f ⟨_, _, f', hf', ⟨iso⟩⟩ => ⟨_, _, f', hf',\n      ⟨Arrow.isoMk (asIso iso.hom.left) (asIso iso.hom.right ≪≫ asIso e) (by simp)⟩⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.monotone_isoClosure","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Monotone CategoryTheory.MorphismProperty.isoClosure","decl":"lemma monotone_isoClosure : Monotone (isoClosure (C := C)) := by\n  intro P Q h X Y f ⟨X', Y', f', hf', ⟨e⟩⟩\n  exact ⟨X', Y', f', h _ hf', ⟨e⟩⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.cancel_left_of_respectsIso","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nhP : P.RespectsIso\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.IsIso f\n⊢ Iff (P (CategoryTheory.CategoryStruct.comp f g)) (P g)","decl":"theorem cancel_left_of_respectsIso (P : MorphismProperty C) [hP : RespectsIso P] {X Y Z : C}\n    (f : X ⟶ Y) (g : Y ⟶ Z) [IsIso f] : P (f ≫ g) ↔ P g :=\n  ⟨fun h => by simpa using RespectsIso.precomp P (inv f) (f ≫ g) h, RespectsIso.precomp P f g⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.cancel_right_of_respectsIso","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nhP : P.RespectsIso\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.IsIso g\n⊢ Iff (P (CategoryTheory.CategoryStruct.comp f g)) (P f)","decl":"theorem cancel_right_of_respectsIso (P : MorphismProperty C) [hP : RespectsIso P] {X Y Z : C}\n    (f : X ⟶ Y) (g : Y ⟶ Z) [IsIso g] : P (f ≫ g) ↔ P f :=\n  ⟨fun h => by simpa using RespectsIso.postcomp P (inv g) (f ≫ g) h, RespectsIso.postcomp P g f⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.comma_iso_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst✝² : P.RespectsIso\nA : Type u_2\nB : Type u_3\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} A\ninst✝ : CategoryTheory.Category.{u_5, u_3} B\nL : CategoryTheory.Functor A C\nR : CategoryTheory.Functor B C\nf g : CategoryTheory.Comma L R\ne : CategoryTheory.Iso f g\n⊢ Iff (P f.hom) (P g.hom)","decl":"lemma comma_iso_iff (P : MorphismProperty C) [P.RespectsIso] {A B : Type*} [Category A] [Category B]\n    {L : A ⥤ C} {R : B ⥤ C} {f g : Comma L R} (e : f ≅ g) :\n    P f.hom ↔ P g.hom := by\n  simp [← Comma.inv_left_hom_right e.hom, cancel_left_of_respectsIso, cancel_right_of_respectsIso]\n\n"}
{"name":"CategoryTheory.MorphismProperty.arrow_iso_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst✝ : P.RespectsIso\nf g : CategoryTheory.Arrow C\ne : CategoryTheory.Iso f g\n⊢ Iff (P f.hom) (P g.hom)","decl":"theorem arrow_iso_iff (P : MorphismProperty C) [RespectsIso P] {f g : Arrow C}\n    (e : f ≅ g) : P f.hom ↔ P g.hom :=\n  P.comma_iso_iff e\n\n"}
{"name":"CategoryTheory.MorphismProperty.arrow_mk_iso_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst✝ : P.RespectsIso\nW X Y Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom Y Z\ne : CategoryTheory.Iso (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\n⊢ Iff (P f) (P g)","decl":"theorem arrow_mk_iso_iff (P : MorphismProperty C) [RespectsIso P] {W X Y Z : C}\n    {f : W ⟶ X} {g : Y ⟶ Z} (e : Arrow.mk f ≅ Arrow.mk g) : P f ↔ P g :=\n  P.arrow_iso_iff e\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsIso.of_respects_arrow_iso","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\nhP : ∀ (f g : CategoryTheory.Arrow C), CategoryTheory.Iso f g → P f.hom → P g.hom\n⊢ P.RespectsIso","decl":"theorem RespectsIso.of_respects_arrow_iso (P : MorphismProperty C)\n    (hP : ∀ (f g : Arrow C) (_ : f ≅ g) (_ : P f.hom), P g.hom) : RespectsIso P where\n  precomp {X Y Z} e (he : IsIso e) f hf := by\n    refine hP (Arrow.mk f) (Arrow.mk (e ≫ f)) (Arrow.isoMk (asIso (inv e)) (Iso.refl _) ?_) hf\n    simp\n  postcomp {X Y Z} e (he : IsIso e) f hf := by\n    refine hP (Arrow.mk f) (Arrow.mk (f ≫ e)) (Arrow.isoMk (Iso.refl _) (asIso e) ?_) hf\n    simp\n\n"}
{"name":"CategoryTheory.MorphismProperty.isoClosure_eq_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n⊢ Iff (Eq P.isoClosure P) P.RespectsIso","decl":"lemma isoClosure_eq_iff (P : MorphismProperty C) :\n    P.isoClosure = P ↔ P.RespectsIso := by\n  refine ⟨(· ▸ P.isoClosure_respectsIso), fun hP ↦ le_antisymm ?_ (P.le_isoClosure)⟩\n  intro X Y f ⟨X', Y', f', hf', ⟨e⟩⟩\n  exact (P.arrow_mk_iso_iff e).1 hf'\n\n"}
{"name":"CategoryTheory.MorphismProperty.isoClosure_eq_self","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst✝ : P.RespectsIso\n⊢ Eq P.isoClosure P","decl":"lemma isoClosure_eq_self (P : MorphismProperty C) [P.RespectsIso] :\n    P.isoClosure = P := by rwa [isoClosure_eq_iff]\n\n"}
{"name":"CategoryTheory.MorphismProperty.isoClosure_isoClosure","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n⊢ Eq P.isoClosure.isoClosure P.isoClosure","decl":"@[simp]\nlemma isoClosure_isoClosure (P : MorphismProperty C) :\n    P.isoClosure.isoClosure = P.isoClosure :=\n  P.isoClosure.isoClosure_eq_self\n\n"}
{"name":"CategoryTheory.MorphismProperty.isoClosure_le_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP Q : CategoryTheory.MorphismProperty C\ninst✝ : Q.RespectsIso\n⊢ Iff (LE.le P.isoClosure Q) (LE.le P Q)","decl":"lemma isoClosure_le_iff (P Q : MorphismProperty C) [Q.RespectsIso] :\n    P.isoClosure ≤ Q ↔ P ≤ Q := by\n  constructor\n  · exact P.le_isoClosure.trans\n  · intro h\n    exact (monotone_isoClosure h).trans (by rw [Q.isoClosure_eq_self])\n\n"}
{"name":"CategoryTheory.MorphismProperty.map_respectsIso","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty C\nF : CategoryTheory.Functor C D\n⊢ (P.map F).RespectsIso","decl":"instance map_respectsIso (P : MorphismProperty C) (F : C ⥤ D) :\n    (P.map F).RespectsIso := by\n  apply RespectsIso.of_respects_arrow_iso\n  intro f g e ⟨X', Y', f', hf', ⟨e'⟩⟩\n  exact ⟨X', Y', f', hf', ⟨e' ≪≫ e⟩⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.map_le_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty C\nF : CategoryTheory.Functor C D\nQ : CategoryTheory.MorphismProperty D\ninst✝ : Q.RespectsIso\n⊢ Iff (LE.le (P.map F) Q) (LE.le P (Q.inverseImage F))","decl":"lemma map_le_iff (P : MorphismProperty C) {F : C ⥤ D} (Q : MorphismProperty D)\n    [RespectsIso Q] :\n    P.map F ≤ Q ↔ P ≤ Q.inverseImage F := by\n  constructor\n  · intro h X Y f hf\n    exact h (F.map f) (map_mem_map P F f hf)\n  · intro h X Y f ⟨X', Y', f', hf', ⟨e⟩⟩\n    exact (Q.arrow_mk_iso_iff e).1 (h _ hf')\n\n"}
{"name":"CategoryTheory.MorphismProperty.map_isoClosure","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty C\nF : CategoryTheory.Functor C D\n⊢ Eq (P.isoClosure.map F) (P.map F)","decl":"@[simp]\nlemma map_isoClosure (P : MorphismProperty C) (F : C ⥤ D) :\n    P.isoClosure.map F = P.map F := by\n  apply le_antisymm\n  · rw [map_le_iff]\n    intro X Y f ⟨X', Y', f', hf', ⟨e⟩⟩\n    exact ⟨_, _, f', hf', ⟨F.mapArrow.mapIso e⟩⟩\n  · exact monotone_map _ (le_isoClosure P)\n\n"}
{"name":"CategoryTheory.MorphismProperty.map_id_eq_isoClosure","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\n⊢ Eq (P.map (CategoryTheory.Functor.id C)) P.isoClosure","decl":"lemma map_id_eq_isoClosure (P : MorphismProperty C) :\n    P.map (𝟭 _) = P.isoClosure := by\n  apply le_antisymm\n  · rw [map_le_iff]\n    intro X Y f hf\n    exact P.le_isoClosure _ hf\n  · intro X Y f hf\n    exact hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.map_id","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP : CategoryTheory.MorphismProperty C\ninst✝ : P.RespectsIso\n⊢ Eq (P.map (CategoryTheory.Functor.id C)) P","decl":"lemma map_id (P : MorphismProperty C) [RespectsIso P] :\n    P.map (𝟭 _) = P := by\n  rw [map_id_eq_isoClosure, P.isoClosure_eq_self]\n\n"}
{"name":"CategoryTheory.MorphismProperty.map_map","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} D\nP : CategoryTheory.MorphismProperty C\nF : CategoryTheory.Functor C D\nE : Type u_2\ninst✝ : CategoryTheory.Category.{u_4, u_2} E\nG : CategoryTheory.Functor D E\n⊢ Eq ((P.map F).map G) (P.map (F.comp G))","decl":"@[simp]\nlemma map_map (P : MorphismProperty C) (F : C ⥤ D) {E : Type*} [Category E] (G : D ⥤ E) :\n    (P.map F).map G = P.map (F ⋙ G) := by\n  apply le_antisymm\n  · rw [map_le_iff]\n    intro X Y f ⟨X', Y', f', hf', ⟨e⟩⟩\n    exact ⟨X', Y', f', hf', ⟨G.mapArrow.mapIso e⟩⟩\n  · rw [map_le_iff]\n    intro X Y f hf\n    exact map_mem_map _ _ _ (map_mem_map _ _ _ hf)\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsIso.inverseImage","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty D\ninst✝ : P.RespectsIso\nF : CategoryTheory.Functor C D\n⊢ (P.inverseImage F).RespectsIso","decl":"instance RespectsIso.inverseImage (P : MorphismProperty D) [RespectsIso P] (F : C ⥤ D) :\n    RespectsIso (P.inverseImage F) where\n  precomp {X Y Z} e (he : IsIso e) f hf := by\n    simpa [MorphismProperty.inverseImage, cancel_left_of_respectsIso] using hf\n  postcomp {X Y Z} e (he : IsIso e) f hf := by\n    simpa [MorphismProperty.inverseImage, cancel_right_of_respectsIso] using hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.map_eq_of_iso","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty C\nF G : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F G\n⊢ Eq (P.map F) (P.map G)","decl":"lemma map_eq_of_iso (P : MorphismProperty C) {F G : C ⥤ D} (e : F ≅ G) :\n    P.map F = P.map G := by\n  revert F G e\n  suffices ∀ {F G : C ⥤ D} (_ : F ≅ G), P.map F ≤ P.map G from\n    fun F G e => le_antisymm (this e) (this e.symm)\n  intro F G e X Y f ⟨X', Y', f', hf', ⟨e'⟩⟩\n  exact ⟨X', Y', f', hf', ⟨((Functor.mapArrowFunctor _ _).mapIso e.symm).app (Arrow.mk f') ≪≫ e'⟩⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.map_inverseImage_le","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty D\nF : CategoryTheory.Functor C D\n⊢ LE.le ((P.inverseImage F).map F) P.isoClosure","decl":"lemma map_inverseImage_le (P : MorphismProperty D) (F : C ⥤ D) :\n    (P.inverseImage F).map F ≤ P.isoClosure :=\n  fun _ _ _ ⟨_, _, f, hf, ⟨e⟩⟩ => ⟨_, _, F.map f, hf, ⟨e⟩⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.inverseImage_equivalence_inverse_eq_map_functor","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty D\ninst✝ : P.RespectsIso\nE : CategoryTheory.Equivalence C D\n⊢ Eq (P.inverseImage E.functor) (P.map E.inverse)","decl":"lemma inverseImage_equivalence_inverse_eq_map_functor\n    (P : MorphismProperty D) [RespectsIso P] (E : C ≌ D) :\n    P.inverseImage E.functor = P.map E.inverse := by\n  apply le_antisymm\n  · intro X Y f hf\n    refine ⟨_, _, _, hf, ⟨?_⟩⟩\n    exact ((Functor.mapArrowFunctor _ _).mapIso E.unitIso.symm).app (Arrow.mk f)\n  · rw [map_le_iff]\n    intro X Y f hf\n    exact (P.arrow_mk_iso_iff\n      (((Functor.mapArrowFunctor _ _).mapIso E.counitIso).app (Arrow.mk f))).2 hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.inverseImage_equivalence_functor_eq_map_inverse","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} D\nQ : CategoryTheory.MorphismProperty C\ninst✝ : Q.RespectsIso\nE : CategoryTheory.Equivalence C D\n⊢ Eq (Q.inverseImage E.inverse) (Q.map E.functor)","decl":"lemma inverseImage_equivalence_functor_eq_map_inverse\n    (Q : MorphismProperty C) [RespectsIso Q] (E : C ≌ D) :\n    Q.inverseImage E.inverse = Q.map E.functor :=\n  inverseImage_equivalence_inverse_eq_map_functor Q E.symm\n\n"}
{"name":"CategoryTheory.MorphismProperty.map_inverseImage_eq_of_isEquivalence","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty D\ninst✝¹ : P.RespectsIso\nF : CategoryTheory.Functor C D\ninst✝ : F.IsEquivalence\n⊢ Eq ((P.inverseImage F).map F) P","decl":"lemma map_inverseImage_eq_of_isEquivalence\n    (P : MorphismProperty D) [P.RespectsIso] (F : C ⥤ D) [F.IsEquivalence] :\n    (P.inverseImage F).map F = P := by\n  erw [P.inverseImage_equivalence_inverse_eq_map_functor F.asEquivalence, map_map,\n    P.map_eq_of_iso F.asEquivalence.counitIso, map_id]\n\n"}
{"name":"CategoryTheory.MorphismProperty.inverseImage_map_eq_of_isEquivalence","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} D\nP : CategoryTheory.MorphismProperty C\ninst✝¹ : P.RespectsIso\nF : CategoryTheory.Functor C D\ninst✝ : F.IsEquivalence\n⊢ Eq ((P.map F).inverseImage F) P","decl":"lemma inverseImage_map_eq_of_isEquivalence\n    (P : MorphismProperty C) [P.RespectsIso] (F : C ⥤ D) [F.IsEquivalence] :\n    (P.map F).inverseImage F = P := by\n  erw [((P.map F).inverseImage_equivalence_inverse_eq_map_functor (F.asEquivalence)), map_map,\n    P.map_eq_of_iso F.asEquivalence.unitIso.symm, map_id]\n\n"}
{"name":"CategoryTheory.MorphismProperty.isomorphisms.iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.MorphismProperty.isomorphisms C f) (CategoryTheory.IsIso f)","decl":"@[simp]\ntheorem isomorphisms.iff : (isomorphisms C) f ↔ IsIso f := by rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.monomorphisms.iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.MorphismProperty.monomorphisms C f) (CategoryTheory.Mono f)","decl":"@[simp]\ntheorem monomorphisms.iff : (monomorphisms C) f ↔ Mono f := by rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.epimorphisms.iff","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.MorphismProperty.epimorphisms C f) (CategoryTheory.Epi f)","decl":"@[simp]\ntheorem epimorphisms.iff : (epimorphisms C) f ↔ Epi f := by rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.isomorphisms.infer_property","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nhf : CategoryTheory.IsIso f\n⊢ CategoryTheory.MorphismProperty.isomorphisms C f","decl":"theorem isomorphisms.infer_property [hf : IsIso f] : (isomorphisms C) f :=\n  hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.monomorphisms.infer_property","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nhf : CategoryTheory.Mono f\n⊢ CategoryTheory.MorphismProperty.monomorphisms C f","decl":"theorem monomorphisms.infer_property [hf : Mono f] : (monomorphisms C) f :=\n  hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.epimorphisms.infer_property","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : C\nf : Quiver.Hom X Y\nhf : CategoryTheory.Epi f\n⊢ CategoryTheory.MorphismProperty.epimorphisms C f","decl":"theorem epimorphisms.infer_property [hf : Epi f] : (epimorphisms C) f :=\n  hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsIso.monomorphisms","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ (CategoryTheory.MorphismProperty.monomorphisms C).RespectsIso","decl":"instance RespectsIso.monomorphisms : RespectsIso (monomorphisms C) := by\n  apply RespectsIso.mk <;>\n    · intro X Y Z e f\n      simp only [monomorphisms.iff]\n      intro\n      apply mono_comp\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsIso.epimorphisms","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ (CategoryTheory.MorphismProperty.epimorphisms C).RespectsIso","decl":"instance RespectsIso.epimorphisms : RespectsIso (epimorphisms C) := by\n  apply RespectsIso.mk <;>\n    · intro X Y Z e f\n      simp only [epimorphisms.iff]\n      intro\n      apply epi_comp\n\n"}
{"name":"CategoryTheory.MorphismProperty.RespectsIso.isomorphisms","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ (CategoryTheory.MorphismProperty.isomorphisms C).RespectsIso","decl":"instance RespectsIso.isomorphisms : RespectsIso (isomorphisms C) := by\n  apply RespectsIso.mk <;>\n    · intro X Y Z e f\n      simp only [isomorphisms.iff]\n      intro\n      exact IsIso.comp_isIso\n\n"}
{"name":"CategoryTheory.NatTrans.isIso_app_iff_of_iso","module":"Mathlib.CategoryTheory.MorphismProperty.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nF G : CategoryTheory.Functor C D\nα : Quiver.Hom F G\nX Y : C\ne : CategoryTheory.Iso X Y\n⊢ Iff (CategoryTheory.IsIso (α.app X)) (CategoryTheory.IsIso (α.app Y))","decl":"lemma isIso_app_iff_of_iso {F G : C ⥤ D} (α : F ⟶ G) {X Y : C} (e : X ≅ Y) :\n    IsIso (α.app X) ↔ IsIso (α.app Y) :=\n  (MorphismProperty.isomorphisms D).arrow_mk_iso_iff\n    (Arrow.isoMk (F.mapIso e) (G.mapIso e) (by simp))\n\n"}
