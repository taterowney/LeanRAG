{"name":"ModuleCat.Derivation.d_add","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Basic","initialProofState":"A B : CommRingCat\nM : ModuleCat ↑B\nf : Quiver.Hom A B\nD : M.Derivation f\nb b' : ↑B\n⊢ Eq (D.d (HAdd.hAdd b b')) (HAdd.hAdd (D.d b) (D.d b'))","decl":"@[simp]\nlemma d_add (b b' : B) : D.d (b + b') = D.d b + D.d b' := by simp [d]\n\n"}
{"name":"ModuleCat.Derivation.d_mul","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Basic","initialProofState":"A B : CommRingCat\nM : ModuleCat ↑B\nf : Quiver.Hom A B\nD : M.Derivation f\nb b' : ↑B\n⊢ Eq (D.d (HMul.hMul b b')) (HAdd.hAdd (HSMul.hSMul b (D.d b')) (HSMul.hSMul b' (D.d b)))","decl":"@[simp]\nlemma d_mul (b b' : B) : D.d (b * b') = b • D.d b' + b' • D.d b := by simp [d]\n\n"}
{"name":"ModuleCat.Derivation.d_map","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Basic","initialProofState":"A B : CommRingCat\nM : ModuleCat ↑B\nf : Quiver.Hom A B\nD : M.Derivation f\na : ↑A\n⊢ Eq (D.d ((CategoryTheory.ConcreteCategory.hom f) a)) 0","decl":"@[simp]\nlemma d_map (a : A) : D.d (f a) = 0 :=\n  letI := f.hom.toAlgebra\n  letI := Module.compHom M f.hom\n  D.map_algebraMap a\n\n"}
{"name":"CommRingCat.KaehlerDifferential.ext_iff","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Basic","initialProofState":"A B : CommRingCat\nf : Quiver.Hom A B\nM : ModuleCat ↑B\nα β : Quiver.Hom (CommRingCat.KaehlerDifferential f) M\n⊢ Iff (Eq α β) (∀ (b : ↑B), Eq ((CategoryTheory.ConcreteCategory.hom α) (CommRingCat.KaehlerDifferential.d b)) ((CategoryTheory.ConcreteCategory.hom β) (CommRingCat.KaehlerDifferential.d b)))","decl":"@[ext]\nlemma ext {M : ModuleCat B} {α β : KaehlerDifferential f ⟶ M}\n    (h : ∀ (b : B), α (d b) = β (d b)) : α = β := by\n  rw [← sub_eq_zero]\n  have : ⊤ ≤ LinearMap.ker (α - β).hom := by\n    rw [← KaehlerDifferential.span_range_derivation, Submodule.span_le]\n    rintro _ ⟨y, rfl⟩\n    rw [SetLike.mem_coe, LinearMap.mem_ker, ModuleCat.hom_sub, LinearMap.sub_apply, sub_eq_zero]\n    apply h\n  rw [top_le_iff, LinearMap.ker_eq_top] at this\n  ext : 1\n  exact this\n\n"}
{"name":"CommRingCat.KaehlerDifferential.ext","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Basic","initialProofState":"A B : CommRingCat\nf : Quiver.Hom A B\nM : ModuleCat ↑B\nα β : Quiver.Hom (CommRingCat.KaehlerDifferential f) M\nh : ∀ (b : ↑B), Eq ((CategoryTheory.ConcreteCategory.hom α) (CommRingCat.KaehlerDifferential.d b)) ((CategoryTheory.ConcreteCategory.hom β) (CommRingCat.KaehlerDifferential.d b))\n⊢ Eq α β","decl":"@[ext]\nlemma ext {M : ModuleCat B} {α β : KaehlerDifferential f ⟶ M}\n    (h : ∀ (b : B), α (d b) = β (d b)) : α = β := by\n  rw [← sub_eq_zero]\n  have : ⊤ ≤ LinearMap.ker (α - β).hom := by\n    rw [← KaehlerDifferential.span_range_derivation, Submodule.span_le]\n    rintro _ ⟨y, rfl⟩\n    rw [SetLike.mem_coe, LinearMap.mem_ker, ModuleCat.hom_sub, LinearMap.sub_apply, sub_eq_zero]\n    apply h\n  rw [top_le_iff, LinearMap.ker_eq_top] at this\n  ext : 1\n  exact this\n\n"}
{"name":"CommRingCat.KaehlerDifferential.map_d","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Basic","initialProofState":"A B A' B' : CommRingCat\nf : Quiver.Hom A B\nf' : Quiver.Hom A' B'\ng : Quiver.Hom A A'\ng' : Quiver.Hom B B'\nfac : Eq (CategoryTheory.CategoryStruct.comp g f') (CategoryTheory.CategoryStruct.comp f g')\nb : ↑B\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (CommRingCat.KaehlerDifferential.map fac)) (CommRingCat.KaehlerDifferential.d b)) (CommRingCat.KaehlerDifferential.d ((CategoryTheory.ConcreteCategory.hom g') b))","decl":"@[simp]\nlemma map_d (b : B) : map fac (d b) = d (g' b) := by\n  algebraize [f.hom, f'.hom, g.hom, g'.hom, f'.hom.comp g.hom]\n  have := IsScalarTower.of_algebraMap_eq' (congrArg Hom.hom fac)\n  exact _root_.KaehlerDifferential.map_D A A' B B' b\n\n"}
{"name":"ModuleCat.Derivation.desc_d","module":"Mathlib.Algebra.Category.ModuleCat.Differentials.Basic","initialProofState":"A B : CommRingCat\nf : Quiver.Hom A B\nM : ModuleCat ↑B\nD : M.Derivation f\nb : ↑B\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom D.desc) (CommRingCat.KaehlerDifferential.d b)) (D.d b)","decl":"@[simp]\nlemma desc_d (b : B) : D.desc (CommRingCat.KaehlerDifferential.d b) = D.d b := by\n  letI := f.hom.toAlgebra\n  letI := Module.compHom M f.hom\n  apply D.liftKaehlerDifferential_comp_D\n\n"}
