{"name":"Filter.prod_mem_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : Filter α\ng : Filter β\nhs : Membership.mem f s\nht : Membership.mem g t\n⊢ Membership.mem (SProd.sprod f g) (SProd.sprod s t)","decl":"theorem prod_mem_prod (hs : s ∈ f) (ht : t ∈ g) : s ×ˢ t ∈ f ×ˢ g :=\n  inter_mem_inf (preimage_mem_comap hs) (preimage_mem_comap ht)\n\n"}
{"name":"Filter.mem_prod_iff","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set (Prod α β)\nf : Filter α\ng : Filter β\n⊢ Iff (Membership.mem (SProd.sprod f g) s) (Exists fun t₁ => And (Membership.mem f t₁) (Exists fun t₂ => And (Membership.mem g t₂) (HasSubset.Subset (SProd.sprod t₁ t₂) s)))","decl":"theorem mem_prod_iff {s : Set (α × β)} {f : Filter α} {g : Filter β} :\n    s ∈ f ×ˢ g ↔ ∃ t₁ ∈ f, ∃ t₂ ∈ g, t₁ ×ˢ t₂ ⊆ s := by\n  constructor\n  · rintro ⟨t₁, ⟨s₁, hs₁, hts₁⟩, t₂, ⟨s₂, hs₂, hts₂⟩, rfl⟩\n    exact ⟨s₁, hs₁, s₂, hs₂, fun p ⟨h, h'⟩ => ⟨hts₁ h, hts₂ h'⟩⟩\n  · rintro ⟨t₁, ht₁, t₂, ht₂, h⟩\n    exact mem_inf_of_inter (preimage_mem_comap ht₁) (preimage_mem_comap ht₂) h\n\n"}
{"name":"Filter.compl_diagonal_mem_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nl₁ l₂ : Filter α\n⊢ Iff (Membership.mem (SProd.sprod l₁ l₂) (HasCompl.compl (Set.diagonal α))) (Disjoint l₁ l₂)","decl":"@[simp]\ntheorem compl_diagonal_mem_prod {l₁ l₂ : Filter α} : (diagonal α)ᶜ ∈ l₁ ×ˢ l₂ ↔ Disjoint l₁ l₂ := by\n  simp only [mem_prod_iff, Filter.disjoint_iff, prod_subset_compl_diagonal_iff_disjoint]\n\n"}
{"name":"Filter.prod_mem_prod_iff","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\nf : Filter α\ng : Filter β\ninst✝¹ : f.NeBot\ninst✝ : g.NeBot\n⊢ Iff (Membership.mem (SProd.sprod f g) (SProd.sprod s t)) (And (Membership.mem f s) (Membership.mem g t))","decl":"@[simp]\ntheorem prod_mem_prod_iff [f.NeBot] [g.NeBot] : s ×ˢ t ∈ f ×ˢ g ↔ s ∈ f ∧ t ∈ g :=\n  ⟨fun h =>\n    let ⟨_s', hs', _t', ht', H⟩ := mem_prod_iff.1 h\n    (prod_subset_prod_iff.1 H).elim\n      (fun ⟨hs's, ht't⟩ => ⟨mem_of_superset hs' hs's, mem_of_superset ht' ht't⟩) fun h =>\n      h.elim (fun hs'e => absurd hs'e (nonempty_of_mem hs').ne_empty) fun ht'e =>\n        absurd ht'e (nonempty_of_mem ht').ne_empty,\n    fun h => prod_mem_prod h.1 h.2⟩\n\n"}
{"name":"Filter.mem_prod_principal","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nt : Set β\nf : Filter α\ns : Set (Prod α β)\n⊢ Iff (Membership.mem (SProd.sprod f (Filter.principal t)) s) (Membership.mem f (setOf fun a => ∀ (b : β), Membership.mem t b → Membership.mem s { fst := a, snd := b }))","decl":"theorem mem_prod_principal {s : Set (α × β)} :\n    s ∈ f ×ˢ 𝓟 t ↔ { a | ∀ b ∈ t, (a, b) ∈ s } ∈ f := by\n  rw [← @exists_mem_subset_iff _ f, mem_prod_iff]\n  refine exists_congr fun u => Iff.rfl.and ⟨?_, fun h => ⟨t, mem_principal_self t, ?_⟩⟩\n  · rintro ⟨v, v_in, hv⟩ a a_in b b_in\n    exact hv (mk_mem_prod a_in <| v_in b_in)\n  · rintro ⟨x, y⟩ ⟨hx, hy⟩\n    exact h hx y hy\n\n"}
{"name":"Filter.mem_prod_top","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ns : Set (Prod α β)\n⊢ Iff (Membership.mem (SProd.sprod f Top.top) s) (Membership.mem f (setOf fun a => ∀ (b : β), Membership.mem s { fst := a, snd := b }))","decl":"theorem mem_prod_top {s : Set (α × β)} :\n    s ∈ f ×ˢ (⊤ : Filter β) ↔ { a | ∀ b, (a, b) ∈ s } ∈ f := by\n  rw [← principal_univ, mem_prod_principal]\n  simp only [mem_univ, forall_true_left]\n\n"}
{"name":"Filter.eventually_prod_principal_iff","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\np : Prod α β → Prop\ns : Set β\n⊢ Iff (Filter.Eventually (fun x => p x) (SProd.sprod f (Filter.principal s))) (Filter.Eventually (fun x => ∀ (y : β), Membership.mem s y → p { fst := x, snd := y }) f)","decl":"theorem eventually_prod_principal_iff {p : α × β → Prop} {s : Set β} :\n    (∀ᶠ x : α × β in f ×ˢ 𝓟 s, p x) ↔ ∀ᶠ x : α in f, ∀ y : β, y ∈ s → p (x, y) := by\n  rw [eventually_iff, eventually_iff, mem_prod_principal]\n  simp only [mem_setOf_eq]\n\n"}
{"name":"Filter.comap_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → Prod β γ\nb : Filter β\nc : Filter γ\n⊢ Eq (Filter.comap f (SProd.sprod b c)) (Min.min (Filter.comap (Function.comp Prod.fst f) b) (Filter.comap (Function.comp Prod.snd f) c))","decl":"theorem comap_prod (f : α → β × γ) (b : Filter β) (c : Filter γ) :\n    comap f (b ×ˢ c) = comap (Prod.fst ∘ f) b ⊓ comap (Prod.snd ∘ f) c := by\n  rw [prod_eq_inf, comap_inf, Filter.comap_comap, Filter.comap_comap]\n\n"}
{"name":"Filter.comap_prodMap_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : α → β\ng : γ → δ\nlb : Filter β\nld : Filter δ\n⊢ Eq (Filter.comap (Prod.map f g) (SProd.sprod lb ld)) (SProd.sprod (Filter.comap f lb) (Filter.comap g ld))","decl":"theorem comap_prodMap_prod (f : α → β) (g : γ → δ) (lb : Filter β) (ld : Filter δ) :\n    comap (Prod.map f g) (lb ×ˢ ld) = comap f lb ×ˢ comap g ld := by\n  simp [prod_eq_inf, comap_comap, Function.comp_def]\n\n"}
{"name":"Filter.prod_top","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\n⊢ Eq (SProd.sprod f Top.top) (Filter.comap Prod.fst f)","decl":"theorem prod_top : f ×ˢ (⊤ : Filter β) = f.comap Prod.fst := by\n  rw [prod_eq_inf, comap_top, inf_top_eq]\n\n"}
{"name":"Filter.top_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ng : Filter β\n⊢ Eq (SProd.sprod Top.top g) (Filter.comap Prod.snd g)","decl":"theorem top_prod : (⊤ : Filter α) ×ˢ g = g.comap Prod.snd := by\n  rw [prod_eq_inf, comap_top, top_inf_eq]\n\n"}
{"name":"Filter.sup_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf₁ f₂ : Filter α\ng : Filter β\n⊢ Eq (SProd.sprod (Max.max f₁ f₂) g) (Max.max (SProd.sprod f₁ g) (SProd.sprod f₂ g))","decl":"theorem sup_prod (f₁ f₂ : Filter α) (g : Filter β) : (f₁ ⊔ f₂) ×ˢ g = (f₁ ×ˢ g) ⊔ (f₂ ×ˢ g) := by\n  simp only [prod_eq_inf, comap_sup, inf_sup_right]\n\n"}
{"name":"Filter.prod_sup","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng₁ g₂ : Filter β\n⊢ Eq (SProd.sprod f (Max.max g₁ g₂)) (Max.max (SProd.sprod f g₁) (SProd.sprod f g₂))","decl":"theorem prod_sup (f : Filter α) (g₁ g₂ : Filter β) : f ×ˢ (g₁ ⊔ g₂) = (f ×ˢ g₁) ⊔ (f ×ˢ g₂) := by\n  simp only [prod_eq_inf, comap_sup, inf_sup_left]\n\n"}
{"name":"Filter.eventually_prod_iff","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\np : Prod α β → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) (SProd.sprod f g)) (Exists fun pa => And (Filter.Eventually (fun x => pa x) f) (Exists fun pb => And (Filter.Eventually (fun y => pb y) g) (∀ {x : α}, pa x → ∀ {y : β}, pb y → p { fst := x, snd := y })))","decl":"theorem eventually_prod_iff {p : α × β → Prop} :\n    (∀ᶠ x in f ×ˢ g, p x) ↔\n      ∃ pa : α → Prop, (∀ᶠ x in f, pa x) ∧ ∃ pb : β → Prop, (∀ᶠ y in g, pb y) ∧\n        ∀ {x}, pa x → ∀ {y}, pb y → p (x, y) := by\n  simpa only [Set.prod_subset_iff] using @mem_prod_iff α β p f g\n\n"}
{"name":"Filter.tendsto_fst","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\n⊢ Filter.Tendsto Prod.fst (SProd.sprod f g) f","decl":"theorem tendsto_fst : Tendsto Prod.fst (f ×ˢ g) f :=\n  tendsto_inf_left tendsto_comap\n\n"}
{"name":"Filter.tendsto_snd","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\n⊢ Filter.Tendsto Prod.snd (SProd.sprod f g) g","decl":"theorem tendsto_snd : Tendsto Prod.snd (f ×ˢ g) g :=\n  tendsto_inf_right tendsto_comap\n\n"}
{"name":"Filter.Tendsto.fst","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\ng : Filter β\nh : Filter γ\nm : α → Prod β γ\nH : Filter.Tendsto m f (SProd.sprod g h)\n⊢ Filter.Tendsto (fun a => (m a).1) f g","decl":"/-- If a function tends to a product `g ×ˢ h` of filters, then its first component tends to\n`g`. See also `Filter.Tendsto.fst_nhds` for the special case of converging to a point in a\nproduct of two topological spaces. -/\ntheorem Tendsto.fst {h : Filter γ} {m : α → β × γ} (H : Tendsto m f (g ×ˢ h)) :\n    Tendsto (fun a ↦ (m a).1) f g :=\n  tendsto_fst.comp H\n\n"}
{"name":"Filter.Tendsto.snd","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\ng : Filter β\nh : Filter γ\nm : α → Prod β γ\nH : Filter.Tendsto m f (SProd.sprod g h)\n⊢ Filter.Tendsto (fun a => (m a).2) f h","decl":"/-- If a function tends to a product `g ×ˢ h` of filters, then its second component tends to\n`h`. See also `Filter.Tendsto.snd_nhds` for the special case of converging to a point in a\nproduct of two topological spaces. -/\ntheorem Tendsto.snd {h : Filter γ} {m : α → β × γ} (H : Tendsto m f (g ×ˢ h)) :\n    Tendsto (fun a ↦ (m a).2) f h :=\n  tendsto_snd.comp H\n\n"}
{"name":"Filter.Tendsto.prod_mk","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\ng : Filter β\nh : Filter γ\nm₁ : α → β\nm₂ : α → γ\nh₁ : Filter.Tendsto m₁ f g\nh₂ : Filter.Tendsto m₂ f h\n⊢ Filter.Tendsto (fun x => { fst := m₁ x, snd := m₂ x }) f (SProd.sprod g h)","decl":"theorem Tendsto.prod_mk {h : Filter γ} {m₁ : α → β} {m₂ : α → γ}\n    (h₁ : Tendsto m₁ f g) (h₂ : Tendsto m₂ f h) : Tendsto (fun x => (m₁ x, m₂ x)) f (g ×ˢ h) :=\n  tendsto_inf.2 ⟨tendsto_comap_iff.2 h₁, tendsto_comap_iff.2 h₂⟩\n\n"}
{"name":"Filter.tendsto_prod_swap","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\n⊢ Filter.Tendsto Prod.swap (SProd.sprod f g) (SProd.sprod g f)","decl":"theorem tendsto_prod_swap : Tendsto (Prod.swap : α × β → β × α) (f ×ˢ g) (g ×ˢ f) :=\n  tendsto_snd.prod_mk tendsto_fst\n\n"}
{"name":"Filter.Eventually.prod_inl","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nla : Filter α\np : α → Prop\nh : Filter.Eventually (fun x => p x) la\nlb : Filter β\n⊢ Filter.Eventually (fun x => p x.1) (SProd.sprod la lb)","decl":"theorem Eventually.prod_inl {la : Filter α} {p : α → Prop} (h : ∀ᶠ x in la, p x) (lb : Filter β) :\n    ∀ᶠ x in la ×ˢ lb, p (x : α × β).1 :=\n  tendsto_fst.eventually h\n\n"}
{"name":"Filter.Eventually.prod_inr","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nlb : Filter β\np : β → Prop\nh : Filter.Eventually (fun x => p x) lb\nla : Filter α\n⊢ Filter.Eventually (fun x => p x.2) (SProd.sprod la lb)","decl":"theorem Eventually.prod_inr {lb : Filter β} {p : β → Prop} (h : ∀ᶠ x in lb, p x) (la : Filter α) :\n    ∀ᶠ x in la ×ˢ lb, p (x : α × β).2 :=\n  tendsto_snd.eventually h\n\n"}
{"name":"Filter.Eventually.prod_mk","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nla : Filter α\npa : α → Prop\nha : Filter.Eventually (fun x => pa x) la\nlb : Filter β\npb : β → Prop\nhb : Filter.Eventually (fun y => pb y) lb\n⊢ Filter.Eventually (fun p => And (pa p.1) (pb p.2)) (SProd.sprod la lb)","decl":"theorem Eventually.prod_mk {la : Filter α} {pa : α → Prop} (ha : ∀ᶠ x in la, pa x) {lb : Filter β}\n    {pb : β → Prop} (hb : ∀ᶠ y in lb, pb y) : ∀ᶠ p in la ×ˢ lb, pa (p : α × β).1 ∧ pb p.2 :=\n  (ha.prod_inl lb).and (hb.prod_inr la)\n\n"}
{"name":"Filter.EventuallyEq.prod_map","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_6\nla : Filter α\nfa ga : α → γ\nha : la.EventuallyEq fa ga\nlb : Filter β\nfb gb : β → δ\nhb : lb.EventuallyEq fb gb\n⊢ (SProd.sprod la lb).EventuallyEq (Prod.map fa fb) (Prod.map ga gb)","decl":"theorem EventuallyEq.prod_map {δ} {la : Filter α} {fa ga : α → γ} (ha : fa =ᶠ[la] ga)\n    {lb : Filter β} {fb gb : β → δ} (hb : fb =ᶠ[lb] gb) :\n    Prod.map fa fb =ᶠ[la ×ˢ lb] Prod.map ga gb :=\n  (Eventually.prod_mk ha hb).mono fun _ h => Prod.ext h.1 h.2\n\n"}
{"name":"Filter.EventuallyLE.prod_map","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_6\ninst✝¹ : LE γ\ninst✝ : LE δ\nla : Filter α\nfa ga : α → γ\nha : la.EventuallyLE fa ga\nlb : Filter β\nfb gb : β → δ\nhb : lb.EventuallyLE fb gb\n⊢ (SProd.sprod la lb).EventuallyLE (Prod.map fa fb) (Prod.map ga gb)","decl":"theorem EventuallyLE.prod_map {δ} [LE γ] [LE δ] {la : Filter α} {fa ga : α → γ} (ha : fa ≤ᶠ[la] ga)\n    {lb : Filter β} {fb gb : β → δ} (hb : fb ≤ᶠ[lb] gb) :\n    Prod.map fa fb ≤ᶠ[la ×ˢ lb] Prod.map ga gb :=\n  Eventually.prod_mk ha hb\n\n"}
{"name":"Filter.Eventually.curry","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nla : Filter α\nlb : Filter β\np : Prod α β → Prop\nh : Filter.Eventually (fun x => p x) (SProd.sprod la lb)\n⊢ Filter.Eventually (fun x => Filter.Eventually (fun y => p { fst := x, snd := y }) lb) la","decl":"theorem Eventually.curry {la : Filter α} {lb : Filter β} {p : α × β → Prop}\n    (h : ∀ᶠ x in la ×ˢ lb, p x) : ∀ᶠ x in la, ∀ᶠ y in lb, p (x, y) := by\n  rcases eventually_prod_iff.1 h with ⟨pa, ha, pb, hb, h⟩\n  exact ha.mono fun a ha => hb.mono fun b hb => h ha hb\n\n"}
{"name":"Filter.Frequently.uncurry","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nla : Filter α\nlb : Filter β\np : α → β → Prop\nh : Filter.Frequently (fun x => Filter.Frequently (fun y => p x y) lb) la\n⊢ Filter.Frequently (fun xy => p xy.1 xy.2) (SProd.sprod la lb)","decl":"protected lemma Frequently.uncurry {la : Filter α} {lb : Filter β} {p : α → β → Prop}\n    (h : ∃ᶠ x in la, ∃ᶠ y in lb, p x y) : ∃ᶠ xy in la ×ˢ lb, p xy.1 xy.2 :=\n  mt (fun h ↦ by simpa only [not_frequently] using h.curry) h\n\n"}
{"name":"Filter.Eventually.diag_of_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nf : Filter α\np : Prod α α → Prop\nh : Filter.Eventually (fun i => p i) (SProd.sprod f f)\n⊢ Filter.Eventually (fun i => p { fst := i, snd := i }) f","decl":"/-- A fact that is eventually true about all pairs `l ×ˢ l` is eventually true about\nall diagonal pairs `(i, i)` -/\ntheorem Eventually.diag_of_prod {p : α × α → Prop} (h : ∀ᶠ i in f ×ˢ f, p i) :\n    ∀ᶠ i in f, p (i, i) := by\n  obtain ⟨t, ht, s, hs, hst⟩ := eventually_prod_iff.1 h\n  apply (ht.and hs).mono fun x hx => hst hx.1 hx.2\n\n"}
{"name":"Filter.Eventually.diag_of_prod_left","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nγ : Type u_3\nf : Filter α\ng : Filter γ\np : Prod (Prod α α) γ → Prop\na✝ : Filter.Eventually (fun x => p x) (SProd.sprod (SProd.sprod f f) g)\n⊢ Filter.Eventually (fun x => p { fst := { fst := x.1, snd := x.1 }, snd := x.2 }) (SProd.sprod f g)","decl":"theorem Eventually.diag_of_prod_left {f : Filter α} {g : Filter γ} {p : (α × α) × γ → Prop} :\n    (∀ᶠ x in (f ×ˢ f) ×ˢ g, p x) → ∀ᶠ x : α × γ in f ×ˢ g, p ((x.1, x.1), x.2) := by\n  intro h\n  obtain ⟨t, ht, s, hs, hst⟩ := eventually_prod_iff.1 h\n  exact (ht.diag_of_prod.prod_mk hs).mono fun x hx => by simp only [hst hx.1 hx.2]\n\n"}
{"name":"Filter.Eventually.diag_of_prod_right","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nγ : Type u_3\nf : Filter α\ng : Filter γ\np : Prod α (Prod γ γ) → Prop\na✝ : Filter.Eventually (fun x => p x) (SProd.sprod f (SProd.sprod g g))\n⊢ Filter.Eventually (fun x => p { fst := x.1, snd := { fst := x.2, snd := x.2 } }) (SProd.sprod f g)","decl":"theorem Eventually.diag_of_prod_right {f : Filter α} {g : Filter γ} {p : α × γ × γ → Prop} :\n    (∀ᶠ x in f ×ˢ (g ×ˢ g), p x) → ∀ᶠ x : α × γ in f ×ˢ g, p (x.1, x.2, x.2) := by\n  intro h\n  obtain ⟨t, ht, s, hs, hst⟩ := eventually_prod_iff.1 h\n  exact (ht.prod_mk hs.diag_of_prod).mono fun x hx => by simp only [hst hx.1 hx.2]\n\n"}
{"name":"Filter.tendsto_diag","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nf : Filter α\n⊢ Filter.Tendsto (fun i => { fst := i, snd := i }) f (SProd.sprod f f)","decl":"theorem tendsto_diag : Tendsto (fun i => (i, i)) f (f ×ˢ f) :=\n  tendsto_iff_eventually.mpr fun _ hpr => hpr.diag_of_prod\n\n"}
{"name":"Filter.prod_iInf_left","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ninst✝ : Nonempty ι\nf : ι → Filter α\ng : Filter β\n⊢ Eq (SProd.sprod (iInf fun i => f i) g) (iInf fun i => SProd.sprod (f i) g)","decl":"theorem prod_iInf_left [Nonempty ι] {f : ι → Filter α} {g : Filter β} :\n    (⨅ i, f i) ×ˢ g = ⨅ i, f i ×ˢ g := by\n  simp only [prod_eq_inf, comap_iInf, iInf_inf]\n\n"}
{"name":"Filter.prod_iInf_right","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_5\ninst✝ : Nonempty ι\nf : Filter α\ng : ι → Filter β\n⊢ Eq (SProd.sprod f (iInf fun i => g i)) (iInf fun i => SProd.sprod f (g i))","decl":"theorem prod_iInf_right [Nonempty ι] {f : Filter α} {g : ι → Filter β} :\n    (f ×ˢ ⨅ i, g i) = ⨅ i, f ×ˢ g i := by\n  simp only [prod_eq_inf, comap_iInf, inf_iInf]\n\n"}
{"name":"Filter.prod_mono","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf₁ f₂ : Filter α\ng₁ g₂ : Filter β\nhf : LE.le f₁ f₂\nhg : LE.le g₁ g₂\n⊢ LE.le (SProd.sprod f₁ g₁) (SProd.sprod f₂ g₂)","decl":"@[mono, gcongr]\ntheorem prod_mono {f₁ f₂ : Filter α} {g₁ g₂ : Filter β} (hf : f₁ ≤ f₂) (hg : g₁ ≤ g₂) :\n    f₁ ×ˢ g₁ ≤ f₂ ×ˢ g₂ :=\n  inf_le_inf (comap_mono hf) (comap_mono hg)\n\n"}
{"name":"Filter.prod_mono_left","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ng : Filter β\nf₁ f₂ : Filter α\nhf : LE.le f₁ f₂\n⊢ LE.le (SProd.sprod f₁ g) (SProd.sprod f₂ g)","decl":"@[gcongr]\ntheorem prod_mono_left (g : Filter β) {f₁ f₂ : Filter α} (hf : f₁ ≤ f₂) : f₁ ×ˢ g ≤ f₂ ×ˢ g :=\n  Filter.prod_mono hf rfl.le\n\n"}
{"name":"Filter.prod_mono_right","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng₁ g₂ : Filter β\nhf : LE.le g₁ g₂\n⊢ LE.le (SProd.sprod f g₁) (SProd.sprod f g₂)","decl":"@[gcongr]\ntheorem prod_mono_right (f : Filter α) {g₁ g₂ : Filter β} (hf : g₁ ≤ g₂) : f ×ˢ g₁ ≤ f ×ˢ g₂ :=\n  Filter.prod_mono rfl.le hf\n\n"}
{"name":"Filter.prod_comap_comap_eq","module":"Mathlib.Order.Filter.Prod","initialProofState":"α₁ : Type u\nα₂ : Type v\nβ₁ : Type w\nβ₂ : Type x\nf₁ : Filter α₁\nf₂ : Filter α₂\nm₁ : β₁ → α₁\nm₂ : β₂ → α₂\n⊢ Eq (SProd.sprod (Filter.comap m₁ f₁) (Filter.comap m₂ f₂)) (Filter.comap (fun p => { fst := m₁ p.1, snd := m₂ p.2 }) (SProd.sprod f₁ f₂))","decl":"theorem prod_comap_comap_eq.{u, v, w, x} {α₁ : Type u} {α₂ : Type v} {β₁ : Type w} {β₂ : Type x}\n    {f₁ : Filter α₁} {f₂ : Filter α₂} {m₁ : β₁ → α₁} {m₂ : β₂ → α₂} :\n    comap m₁ f₁ ×ˢ comap m₂ f₂ = comap (fun p : β₁ × β₂ => (m₁ p.1, m₂ p.2)) (f₁ ×ˢ f₂) := by\n  simp only [prod_eq_inf, comap_comap, comap_inf, Function.comp_def]\n\n"}
{"name":"Filter.prod_comm'","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\n⊢ Eq (SProd.sprod f g) (Filter.comap Prod.swap (SProd.sprod g f))","decl":"theorem prod_comm' : f ×ˢ g = comap Prod.swap (g ×ˢ f) := by\n  simp only [prod_eq_inf, comap_comap, Function.comp_def, inf_comm, Prod.swap, comap_inf]\n\n"}
{"name":"Filter.prod_comm","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\n⊢ Eq (SProd.sprod f g) (Filter.map (fun p => { fst := p.2, snd := p.1 }) (SProd.sprod g f))","decl":"theorem prod_comm : f ×ˢ g = map (fun p : β × α => (p.2, p.1)) (g ×ˢ f) := by\n  rw [prod_comm', ← map_swap_eq_comap_swap]\n  rfl\n\n"}
{"name":"Filter.mem_prod_iff_left","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\ns : Set (Prod α β)\n⊢ Iff (Membership.mem (SProd.sprod f g) s) (Exists fun t => And (Membership.mem f t) (Filter.Eventually (fun y => ∀ (x : α), Membership.mem t x → Membership.mem s { fst := x, snd := y }) g))","decl":"theorem mem_prod_iff_left {s : Set (α × β)} :\n    s ∈ f ×ˢ g ↔ ∃ t ∈ f, ∀ᶠ y in g, ∀ x ∈ t, (x, y) ∈ s := by\n  simp only [mem_prod_iff, prod_subset_iff]\n  refine exists_congr fun _ => Iff.rfl.and <| Iff.trans ?_ exists_mem_subset_iff\n  exact exists_congr fun _ => Iff.rfl.and forall₂_swap\n\n"}
{"name":"Filter.mem_prod_iff_right","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\ns : Set (Prod α β)\n⊢ Iff (Membership.mem (SProd.sprod f g) s) (Exists fun t => And (Membership.mem g t) (Filter.Eventually (fun x => ∀ (y : β), Membership.mem t y → Membership.mem s { fst := x, snd := y }) f))","decl":"theorem mem_prod_iff_right {s : Set (α × β)} :\n    s ∈ f ×ˢ g ↔ ∃ t ∈ g, ∀ᶠ x in f, ∀ y ∈ t, (x, y) ∈ s := by\n  rw [prod_comm, mem_map, mem_prod_iff_left]; rfl\n\n"}
{"name":"Filter.map_fst_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\ninst✝ : g.NeBot\n⊢ Eq (Filter.map Prod.fst (SProd.sprod f g)) f","decl":"@[simp]\ntheorem map_fst_prod (f : Filter α) (g : Filter β) [NeBot g] : map Prod.fst (f ×ˢ g) = f := by\n  ext s\n  simp only [mem_map, mem_prod_iff_left, mem_preimage, eventually_const, ← subset_def,\n    exists_mem_subset_iff]\n\n"}
{"name":"Filter.map_snd_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\ninst✝ : f.NeBot\n⊢ Eq (Filter.map Prod.snd (SProd.sprod f g)) g","decl":"@[simp]\ntheorem map_snd_prod (f : Filter α) (g : Filter β) [NeBot f] : map Prod.snd (f ×ˢ g) = g := by\n  rw [prod_comm, map_map]; apply map_fst_prod\n\n"}
{"name":"Filter.prod_le_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf₁ f₂ : Filter α\ng₁ g₂ : Filter β\ninst✝¹ : f₁.NeBot\ninst✝ : g₁.NeBot\n⊢ Iff (LE.le (SProd.sprod f₁ g₁) (SProd.sprod f₂ g₂)) (And (LE.le f₁ f₂) (LE.le g₁ g₂))","decl":"@[simp]\ntheorem prod_le_prod {f₁ f₂ : Filter α} {g₁ g₂ : Filter β} [NeBot f₁] [NeBot g₁] :\n    f₁ ×ˢ g₁ ≤ f₂ ×ˢ g₂ ↔ f₁ ≤ f₂ ∧ g₁ ≤ g₂ :=\n  ⟨fun h =>\n    ⟨map_fst_prod f₁ g₁ ▸ tendsto_fst.mono_left h, map_snd_prod f₁ g₁ ▸ tendsto_snd.mono_left h⟩,\n    fun h => prod_mono h.1 h.2⟩\n\n"}
{"name":"Filter.prod_inj","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf₁ f₂ : Filter α\ng₁ g₂ : Filter β\ninst✝¹ : f₁.NeBot\ninst✝ : g₁.NeBot\n⊢ Iff (Eq (SProd.sprod f₁ g₁) (SProd.sprod f₂ g₂)) (And (Eq f₁ f₂) (Eq g₁ g₂))","decl":"@[simp]\ntheorem prod_inj {f₁ f₂ : Filter α} {g₁ g₂ : Filter β} [NeBot f₁] [NeBot g₁] :\n    f₁ ×ˢ g₁ = f₂ ×ˢ g₂ ↔ f₁ = f₂ ∧ g₁ = g₂ := by\n  refine ⟨fun h => ?_, fun h => h.1 ▸ h.2 ▸ rfl⟩\n  have hle : f₁ ≤ f₂ ∧ g₁ ≤ g₂ := prod_le_prod.1 h.le\n  haveI := neBot_of_le hle.1; haveI := neBot_of_le hle.2\n  exact ⟨hle.1.antisymm <| (prod_le_prod.1 h.ge).1, hle.2.antisymm <| (prod_le_prod.1 h.ge).2⟩\n\n"}
{"name":"Filter.eventually_swap_iff","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\np : Prod α β → Prop\n⊢ Iff (Filter.Eventually (fun x => p x) (SProd.sprod f g)) (Filter.Eventually (fun y => p y.swap) (SProd.sprod g f))","decl":"theorem eventually_swap_iff {p : α × β → Prop} :\n    (∀ᶠ x : α × β in f ×ˢ g, p x) ↔ ∀ᶠ y : β × α in g ×ˢ f, p y.swap := by\n  rw [prod_comm]; rfl\n\n"}
{"name":"Filter.prod_assoc","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\ng : Filter β\nh : Filter γ\n⊢ Eq (Filter.map (⇑(Equiv.prodAssoc α β γ)) (SProd.sprod (SProd.sprod f g) h)) (SProd.sprod f (SProd.sprod g h))","decl":"theorem prod_assoc (f : Filter α) (g : Filter β) (h : Filter γ) :\n    map (Equiv.prodAssoc α β γ) ((f ×ˢ g) ×ˢ h) = f ×ˢ (g ×ˢ h) := by\n  simp_rw [← comap_equiv_symm, prod_eq_inf, comap_inf, comap_comap, inf_assoc,\n    Function.comp_def, Equiv.prodAssoc_symm_apply]\n\n"}
{"name":"Filter.prod_assoc_symm","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\ng : Filter β\nh : Filter γ\n⊢ Eq (Filter.map (⇑(Equiv.prodAssoc α β γ).symm) (SProd.sprod f (SProd.sprod g h))) (SProd.sprod (SProd.sprod f g) h)","decl":"theorem prod_assoc_symm (f : Filter α) (g : Filter β) (h : Filter γ) :\n    map (Equiv.prodAssoc α β γ).symm (f ×ˢ (g ×ˢ h)) = (f ×ˢ g) ×ˢ h := by\n  simp_rw [map_equiv_symm, prod_eq_inf, comap_inf, comap_comap, inf_assoc,\n    Function.comp_def, Equiv.prodAssoc_apply]\n\n"}
{"name":"Filter.tendsto_prodAssoc","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\ng : Filter β\nh : Filter γ\n⊢ Filter.Tendsto (⇑(Equiv.prodAssoc α β γ)) (SProd.sprod (SProd.sprod f g) h) (SProd.sprod f (SProd.sprod g h))","decl":"theorem tendsto_prodAssoc {h : Filter γ} :\n    Tendsto (Equiv.prodAssoc α β γ) ((f ×ˢ g) ×ˢ h) (f ×ˢ (g ×ˢ h)) :=\n  (prod_assoc f g h).le\n\n"}
{"name":"Filter.tendsto_prodAssoc_symm","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\ng : Filter β\nh : Filter γ\n⊢ Filter.Tendsto (⇑(Equiv.prodAssoc α β γ).symm) (SProd.sprod f (SProd.sprod g h)) (SProd.sprod (SProd.sprod f g) h)","decl":"theorem tendsto_prodAssoc_symm {h : Filter γ} :\n    Tendsto (Equiv.prodAssoc α β γ).symm (f ×ˢ (g ×ˢ h)) ((f ×ˢ g) ×ˢ h) :=\n  (prod_assoc_symm f g h).le\n\n"}
{"name":"Filter.map_swap4_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : Filter α\ng : Filter β\nh : Filter γ\nk : Filter δ\n⊢ Eq (Filter.map (fun p => { fst := { fst := p.1.1, snd := p.2.1 }, snd := { fst := p.1.2, snd := p.2.2 } }) (SProd.sprod (SProd.sprod f g) (SProd.sprod h k))) (SProd.sprod (SProd.sprod f h) (SProd.sprod g k))","decl":"/-- A useful lemma when dealing with uniformities. -/\ntheorem map_swap4_prod {h : Filter γ} {k : Filter δ} :\n    map (fun p : (α × β) × γ × δ => ((p.1.1, p.2.1), (p.1.2, p.2.2))) ((f ×ˢ g) ×ˢ (h ×ˢ k)) =\n      (f ×ˢ h) ×ˢ (g ×ˢ k) := by\n  simp_rw [map_swap4_eq_comap, prod_eq_inf, comap_inf, comap_comap]; ac_rfl\n\n"}
{"name":"Filter.tendsto_swap4_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_4\nf : Filter α\ng : Filter β\nh : Filter γ\nk : Filter δ\n⊢ Filter.Tendsto (fun p => { fst := { fst := p.1.1, snd := p.2.1 }, snd := { fst := p.1.2, snd := p.2.2 } }) (SProd.sprod (SProd.sprod f g) (SProd.sprod h k)) (SProd.sprod (SProd.sprod f h) (SProd.sprod g k))","decl":"theorem tendsto_swap4_prod {h : Filter γ} {k : Filter δ} :\n    Tendsto (fun p : (α × β) × γ × δ => ((p.1.1, p.2.1), (p.1.2, p.2.2))) ((f ×ˢ g) ×ˢ (h ×ˢ k))\n      ((f ×ˢ h) ×ˢ (g ×ˢ k)) :=\n  map_swap4_prod.le\n\n"}
{"name":"Filter.prod_map_map_eq","module":"Mathlib.Order.Filter.Prod","initialProofState":"α₁ : Type u\nα₂ : Type v\nβ₁ : Type w\nβ₂ : Type x\nf₁ : Filter α₁\nf₂ : Filter α₂\nm₁ : α₁ → β₁\nm₂ : α₂ → β₂\n⊢ Eq (SProd.sprod (Filter.map m₁ f₁) (Filter.map m₂ f₂)) (Filter.map (fun p => { fst := m₁ p.1, snd := m₂ p.2 }) (SProd.sprod f₁ f₂))","decl":"theorem prod_map_map_eq.{u, v, w, x} {α₁ : Type u} {α₂ : Type v} {β₁ : Type w} {β₂ : Type x}\n    {f₁ : Filter α₁} {f₂ : Filter α₂} {m₁ : α₁ → β₁} {m₂ : α₂ → β₂} :\n    map m₁ f₁ ×ˢ map m₂ f₂ = map (fun p : α₁ × α₂ => (m₁ p.1, m₂ p.2)) (f₁ ×ˢ f₂) :=\n  le_antisymm\n    (fun s hs =>\n      let ⟨s₁, hs₁, s₂, hs₂, h⟩ := mem_prod_iff.mp hs\n      mem_of_superset (prod_mem_prod (image_mem_map hs₁) (image_mem_map hs₂)) <|\n        by rwa [prod_image_image_eq, image_subset_iff])\n    ((tendsto_map.comp tendsto_fst).prod_mk (tendsto_map.comp tendsto_snd))\n\n"}
{"name":"Filter.prod_map_map_eq'","module":"Mathlib.Order.Filter.Prod","initialProofState":"α₁ : Type u_6\nα₂ : Type u_7\nβ₁ : Type u_8\nβ₂ : Type u_9\nf : α₁ → α₂\ng : β₁ → β₂\nF : Filter α₁\nG : Filter β₁\n⊢ Eq (SProd.sprod (Filter.map f F) (Filter.map g G)) (Filter.map (Prod.map f g) (SProd.sprod F G))","decl":"theorem prod_map_map_eq' {α₁ : Type*} {α₂ : Type*} {β₁ : Type*} {β₂ : Type*} (f : α₁ → α₂)\n    (g : β₁ → β₂) (F : Filter α₁) (G : Filter β₁) :\n    map f F ×ˢ map g G = map (Prod.map f g) (F ×ˢ G) :=\n  prod_map_map_eq\n\n"}
{"name":"Filter.prod_map_left","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\nF : Filter α\nG : Filter γ\n⊢ Eq (SProd.sprod (Filter.map f F) G) (Filter.map (Prod.map f id) (SProd.sprod F G))","decl":"theorem prod_map_left (f : α → β) (F : Filter α) (G : Filter γ) :\n    map f F ×ˢ G = map (Prod.map f id) (F ×ˢ G) := by\n  rw [← prod_map_map_eq', map_id]\n\n"}
{"name":"Filter.prod_map_right","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : β → γ\nF : Filter α\nG : Filter β\n⊢ Eq (SProd.sprod F (Filter.map f G)) (Filter.map (Prod.map id f) (SProd.sprod F G))","decl":"theorem prod_map_right (f : β → γ) (F : Filter α) (G : Filter β) :\n    F ×ˢ map f G = map (Prod.map id f) (F ×ˢ G) := by\n  rw [← prod_map_map_eq', map_id]\n\n"}
{"name":"Filter.le_prod_map_fst_snd","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter (Prod α β)\n⊢ LE.le f (SProd.sprod (Filter.map Prod.fst f) (Filter.map Prod.snd f))","decl":"theorem le_prod_map_fst_snd {f : Filter (α × β)} : f ≤ map Prod.fst f ×ˢ map Prod.snd f :=\n  le_inf le_comap_map le_comap_map\n\n"}
{"name":"Filter.Tendsto.prod_map","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_6\nf : α → γ\ng : β → δ\na : Filter α\nb : Filter β\nc : Filter γ\nd : Filter δ\nhf : Filter.Tendsto f a c\nhg : Filter.Tendsto g b d\n⊢ Filter.Tendsto (Prod.map f g) (SProd.sprod a b) (SProd.sprod c d)","decl":"theorem Tendsto.prod_map {δ : Type*} {f : α → γ} {g : β → δ} {a : Filter α} {b : Filter β}\n    {c : Filter γ} {d : Filter δ} (hf : Tendsto f a c) (hg : Tendsto g b d) :\n    Tendsto (Prod.map f g) (a ×ˢ b) (c ×ˢ d) := by\n  rw [Tendsto, Prod.map_def, ← prod_map_map_eq]\n  exact Filter.prod_mono hf hg\n\n"}
{"name":"Filter.map_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : Prod α β → γ\nf : Filter α\ng : Filter β\n⊢ Eq (Filter.map m (SProd.sprod f g)) ((Filter.map (fun a b => m { fst := a, snd := b }) f).seq g)","decl":"protected theorem map_prod (m : α × β → γ) (f : Filter α) (g : Filter β) :\n    map m (f ×ˢ g) = (f.map fun a b => m (a, b)).seq g := by\n  simp only [Filter.ext_iff, mem_map, mem_prod_iff, mem_map_seq_iff, exists_and_left]\n  intro s\n  constructor\n  · exact fun ⟨t, ht, s, hs, h⟩ => ⟨s, hs, t, ht, fun x hx y hy => @h ⟨x, y⟩ ⟨hx, hy⟩⟩\n  · exact fun ⟨s, hs, t, ht, h⟩ => ⟨t, ht, s, hs, fun ⟨x, y⟩ ⟨hx, hy⟩ => h x hx y hy⟩\n\n"}
{"name":"Filter.prod_eq","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\n⊢ Eq (SProd.sprod f g) ((Filter.map Prod.mk f).seq g)","decl":"theorem prod_eq : f ×ˢ g = (f.map Prod.mk).seq g := f.map_prod id g\n\n"}
{"name":"Filter.prod_inf_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf₁ f₂ : Filter α\ng₁ g₂ : Filter β\n⊢ Eq (Min.min (SProd.sprod f₁ g₁) (SProd.sprod f₂ g₂)) (SProd.sprod (Min.min f₁ f₂) (Min.min g₁ g₂))","decl":"theorem prod_inf_prod {f₁ f₂ : Filter α} {g₁ g₂ : Filter β} :\n    (f₁ ×ˢ g₁) ⊓ (f₂ ×ˢ g₂) = (f₁ ⊓ f₂) ×ˢ (g₁ ⊓ g₂) := by\n  simp only [prod_eq_inf, comap_inf, inf_comm, inf_assoc, inf_left_comm]\n\n"}
{"name":"Filter.inf_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ng : Filter β\nf₁ f₂ : Filter α\n⊢ Eq (SProd.sprod (Min.min f₁ f₂) g) (Min.min (SProd.sprod f₁ g) (SProd.sprod f₂ g))","decl":"theorem inf_prod {f₁ f₂ : Filter α} : (f₁ ⊓ f₂) ×ˢ g = (f₁ ×ˢ g) ⊓ (f₂ ×ˢ g) := by\n  rw [prod_inf_prod, inf_idem]\n\n"}
{"name":"Filter.prod_inf","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng₁ g₂ : Filter β\n⊢ Eq (SProd.sprod f (Min.min g₁ g₂)) (Min.min (SProd.sprod f g₁) (SProd.sprod f g₂))","decl":"theorem prod_inf {g₁ g₂ : Filter β} : f ×ˢ (g₁ ⊓ g₂) = (f ×ˢ g₁) ⊓ (f ×ˢ g₂) := by\n  rw [prod_inf_prod, inf_idem]\n\n"}
{"name":"Filter.prod_principal_principal","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\n⊢ Eq (SProd.sprod (Filter.principal s) (Filter.principal t)) (Filter.principal (SProd.sprod s t))","decl":"@[simp]\ntheorem prod_principal_principal {s : Set α} {t : Set β} : 𝓟 s ×ˢ 𝓟 t = 𝓟 (s ×ˢ t) := by\n  simp only [prod_eq_inf, comap_principal, principal_eq_iff_eq, comap_principal, inf_principal]; rfl\n\n"}
{"name":"Filter.pure_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\nf : Filter β\n⊢ Eq (SProd.sprod (Pure.pure a) f) (Filter.map (Prod.mk a) f)","decl":"@[simp]\ntheorem pure_prod {a : α} {f : Filter β} : pure a ×ˢ f = map (Prod.mk a) f := by\n  rw [prod_eq, map_pure, pure_seq_eq_map]\n\n"}
{"name":"Filter.map_pure_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β → γ\na : α\nB : Filter β\n⊢ Eq (Filter.map (Function.uncurry f) (SProd.sprod (Pure.pure a) B)) (Filter.map (f a) B)","decl":"theorem map_pure_prod (f : α → β → γ) (a : α) (B : Filter β) :\n    map (Function.uncurry f) (pure a ×ˢ B) = map (f a) B := by\n  rw [Filter.pure_prod]; rfl\n\n"}
{"name":"Filter.prod_pure","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\nb : β\n⊢ Eq (SProd.sprod f (Pure.pure b)) (Filter.map (fun a => { fst := a, snd := b }) f)","decl":"@[simp]\ntheorem prod_pure {b : β} : f ×ˢ pure b = map (fun a => (a, b)) f := by\n  rw [prod_eq, seq_pure, map_map]; rfl\n\n"}
{"name":"Filter.prod_pure_pure","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\na : α\nb : β\n⊢ Eq (SProd.sprod (Pure.pure a) (Pure.pure b)) (Pure.pure { fst := a, snd := b })","decl":"theorem prod_pure_pure {a : α} {b : β} :\n    (pure a : Filter α) ×ˢ (pure b : Filter β) = pure (a, b) := by simp\n\n"}
{"name":"Filter.prod_eq_bot","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\n⊢ Iff (Eq (SProd.sprod f g) Bot.bot) (Or (Eq f Bot.bot) (Eq g Bot.bot))","decl":"@[simp]\ntheorem prod_eq_bot : f ×ˢ g = ⊥ ↔ f = ⊥ ∨ g = ⊥ := by\n  simp_rw [← empty_mem_iff_bot, mem_prod_iff, subset_empty_iff, prod_eq_empty_iff, ← exists_prop,\n    Subtype.exists', exists_or, exists_const, Subtype.exists, exists_prop, exists_eq_right]\n\n"}
{"name":"Filter.prod_bot","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\n⊢ Eq (SProd.sprod f Bot.bot) Bot.bot","decl":"@[simp] theorem prod_bot : f ×ˢ (⊥ : Filter β) = ⊥ := prod_eq_bot.2 <| Or.inr rfl\n\n"}
{"name":"Filter.bot_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ng : Filter β\n⊢ Eq (SProd.sprod Bot.bot g) Bot.bot","decl":"@[simp] theorem bot_prod : (⊥ : Filter α) ×ˢ g = ⊥ := prod_eq_bot.2 <| Or.inl rfl\n\n"}
{"name":"Filter.prod_neBot","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\n⊢ Iff (SProd.sprod f g).NeBot (And f.NeBot g.NeBot)","decl":"theorem prod_neBot : NeBot (f ×ˢ g) ↔ NeBot f ∧ NeBot g := by\n  simp only [neBot_iff, Ne, prod_eq_bot, not_or]\n\n"}
{"name":"Filter.NeBot.prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\nhf : f.NeBot\nhg : g.NeBot\n⊢ (SProd.sprod f g).NeBot","decl":"protected theorem NeBot.prod (hf : NeBot f) (hg : NeBot g) : NeBot (f ×ˢ g) := prod_neBot.2 ⟨hf, hg⟩\n\n"}
{"name":"Filter.prod.instNeBot","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\nhf : f.NeBot\nhg : g.NeBot\n⊢ (SProd.sprod f g).NeBot","decl":"instance prod.instNeBot [hf : NeBot f] [hg : NeBot g] : NeBot (f ×ˢ g) := hf.prod hg\n\n"}
{"name":"Filter.disjoint_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\nf' : Filter α\ng' : Filter β\n⊢ Iff (Disjoint (SProd.sprod f g) (SProd.sprod f' g')) (Or (Disjoint f f') (Disjoint g g'))","decl":"@[simp]\nlemma disjoint_prod {f' : Filter α} {g' : Filter β} :\n    Disjoint (f ×ˢ g) (f' ×ˢ g') ↔ Disjoint f f' ∨ Disjoint g g' := by\n  simp only [disjoint_iff, prod_inf_prod, prod_eq_bot]\n\n"}
{"name":"Filter.frequently_prod_and","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\np : α → Prop\nq : β → Prop\n⊢ Iff (Filter.Frequently (fun x => And (p x.1) (q x.2)) (SProd.sprod f g)) (And (Filter.Frequently (fun a => p a) f) (Filter.Frequently (fun b => q b) g))","decl":"/-- `p ∧ q` occurs frequently along the product of two filters\niff both `p` and `q` occur frequently along the corresponding filters. -/\ntheorem frequently_prod_and {p : α → Prop} {q : β → Prop} :\n    (∃ᶠ x in f ×ˢ g, p x.1 ∧ q x.2) ↔ (∃ᶠ a in f, p a) ∧ ∃ᶠ b in g, q b := by\n  simp only [frequently_iff_neBot, ← prod_neBot, ← prod_inf_prod, prod_principal_principal]\n  rfl\n\n"}
{"name":"Filter.tendsto_prod_iff","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Prod α β → γ\nx : Filter α\ny : Filter β\nz : Filter γ\n⊢ Iff (Filter.Tendsto f (SProd.sprod x y) z) (∀ (W : Set γ), Membership.mem z W → Exists fun U => And (Membership.mem x U) (Exists fun V => And (Membership.mem y V) (∀ (x : α) (y : β), Membership.mem U x → Membership.mem V y → Membership.mem W (f { fst := x, snd := y }))))","decl":"theorem tendsto_prod_iff {f : α × β → γ} {x : Filter α} {y : Filter β} {z : Filter γ} :\n    Tendsto f (x ×ˢ y) z ↔ ∀ W ∈ z, ∃ U ∈ x, ∃ V ∈ y, ∀ x y, x ∈ U → y ∈ V → f (x, y) ∈ W := by\n  simp only [tendsto_def, mem_prod_iff, prod_sub_preimage_iff, exists_prop]\n\n"}
{"name":"Filter.tendsto_prod_iff'","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\ng : Filter β\ng' : Filter γ\ns : α → Prod β γ\n⊢ Iff (Filter.Tendsto s f (SProd.sprod g g')) (And (Filter.Tendsto (fun n => (s n).1) f g) (Filter.Tendsto (fun n => (s n).2) f g'))","decl":"theorem tendsto_prod_iff' {g' : Filter γ} {s : α → β × γ} :\n    Tendsto s f (g ×ˢ g') ↔ Tendsto (fun n => (s n).1) f g ∧ Tendsto (fun n => (s n).2) f g' := by\n  simp only [prod_eq_inf, tendsto_inf, tendsto_comap_iff, Function.comp_def]\n\n"}
{"name":"Filter.le_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter (Prod α β)\ng : Filter α\ng' : Filter β\n⊢ Iff (LE.le f (SProd.sprod g g')) (And (Filter.Tendsto Prod.fst f g) (Filter.Tendsto Prod.snd f g'))","decl":"theorem le_prod {f : Filter (α × β)} {g : Filter α} {g' : Filter β} :\n    (f ≤ g ×ˢ g') ↔ Tendsto Prod.fst f g ∧ Tendsto Prod.snd f g' :=\n  tendsto_prod_iff'\n\n"}
{"name":"Filter.coprod_eq_prod_top_sup_top_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\n⊢ Eq (f.coprod g) (Max.max (SProd.sprod f Top.top) (SProd.sprod Top.top g))","decl":"theorem coprod_eq_prod_top_sup_top_prod (f : Filter α) (g : Filter β) :\n    Filter.coprod f g = f ×ˢ ⊤ ⊔ ⊤ ×ˢ g := by\n  rw [prod_top, top_prod]\n  rfl\n\n"}
{"name":"Filter.mem_coprod_iff","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set (Prod α β)\nf : Filter α\ng : Filter β\n⊢ Iff (Membership.mem (f.coprod g) s) (And (Exists fun t₁ => And (Membership.mem f t₁) (HasSubset.Subset (Set.preimage Prod.fst t₁) s)) (Exists fun t₂ => And (Membership.mem g t₂) (HasSubset.Subset (Set.preimage Prod.snd t₂) s)))","decl":"theorem mem_coprod_iff {s : Set (α × β)} {f : Filter α} {g : Filter β} :\n    s ∈ f.coprod g ↔ (∃ t₁ ∈ f, Prod.fst ⁻¹' t₁ ⊆ s) ∧ ∃ t₂ ∈ g, Prod.snd ⁻¹' t₂ ⊆ s := by\n  simp [Filter.coprod]\n\n"}
{"name":"Filter.bot_coprod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter β\n⊢ Eq (Bot.bot.coprod l) (Filter.comap Prod.snd l)","decl":"@[simp]\ntheorem bot_coprod (l : Filter β) : (⊥ : Filter α).coprod l = comap Prod.snd l := by\n  simp [Filter.coprod]\n\n"}
{"name":"Filter.coprod_bot","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nl : Filter α\n⊢ Eq (l.coprod Bot.bot) (Filter.comap Prod.fst l)","decl":"@[simp]\ntheorem coprod_bot (l : Filter α) : l.coprod (⊥ : Filter β) = comap Prod.fst l := by\n  simp [Filter.coprod]\n\n"}
{"name":"Filter.bot_coprod_bot","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq (Bot.bot.coprod Bot.bot) Bot.bot","decl":"theorem bot_coprod_bot : (⊥ : Filter α).coprod (⊥ : Filter β) = ⊥ := by simp\n\n"}
{"name":"Filter.compl_mem_coprod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set (Prod α β)\nla : Filter α\nlb : Filter β\n⊢ Iff (Membership.mem (la.coprod lb) (HasCompl.compl s)) (And (Membership.mem la (HasCompl.compl (Set.image Prod.fst s))) (Membership.mem lb (HasCompl.compl (Set.image Prod.snd s))))","decl":"theorem compl_mem_coprod {s : Set (α × β)} {la : Filter α} {lb : Filter β} :\n    sᶜ ∈ la.coprod lb ↔ (Prod.fst '' s)ᶜ ∈ la ∧ (Prod.snd '' s)ᶜ ∈ lb := by\n  simp only [Filter.coprod, mem_sup, compl_mem_comap]\n\n"}
{"name":"Filter.coprod_mono","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf₁ f₂ : Filter α\ng₁ g₂ : Filter β\nhf : LE.le f₁ f₂\nhg : LE.le g₁ g₂\n⊢ LE.le (f₁.coprod g₁) (f₂.coprod g₂)","decl":"@[mono]\ntheorem coprod_mono {f₁ f₂ : Filter α} {g₁ g₂ : Filter β} (hf : f₁ ≤ f₂) (hg : g₁ ≤ g₂) :\n    f₁.coprod g₁ ≤ f₂.coprod g₂ :=\n  sup_le_sup (comap_mono hf) (comap_mono hg)\n\n"}
{"name":"Filter.coprod_neBot_iff","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\n⊢ Iff (f.coprod g).NeBot (Or (And f.NeBot (Nonempty β)) (And (Nonempty α) g.NeBot))","decl":"theorem coprod_neBot_iff : (f.coprod g).NeBot ↔ f.NeBot ∧ Nonempty β ∨ Nonempty α ∧ g.NeBot := by\n  simp [Filter.coprod]\n\n"}
{"name":"Filter.coprod_neBot_left","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\ninst✝¹ : f.NeBot\ninst✝ : Nonempty β\n⊢ (f.coprod g).NeBot","decl":"@[instance]\ntheorem coprod_neBot_left [NeBot f] [Nonempty β] : (f.coprod g).NeBot :=\n  coprod_neBot_iff.2 (Or.inl ⟨‹_›, ‹_›⟩)\n\n"}
{"name":"Filter.coprod_neBot_right","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\ninst✝¹ : g.NeBot\ninst✝ : Nonempty α\n⊢ (f.coprod g).NeBot","decl":"@[instance]\ntheorem coprod_neBot_right [NeBot g] [Nonempty α] : (f.coprod g).NeBot :=\n  coprod_neBot_iff.2 (Or.inr ⟨‹_›, ‹_›⟩)\n\n"}
{"name":"Filter.coprod_inf_prod_le","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nf₁ f₂ : Filter α\ng₁ g₂ : Filter β\n⊢ LE.le (Min.min (f₁.coprod g₁) (SProd.sprod f₂ g₂)) (Max.max (SProd.sprod f₁ g₂) (SProd.sprod f₂ g₁))","decl":"theorem coprod_inf_prod_le (f₁ f₂ : Filter α) (g₁ g₂ : Filter β) :\n    f₁.coprod g₁ ⊓ f₂ ×ˢ g₂ ≤ f₁ ×ˢ g₂ ⊔ f₂ ×ˢ g₁ := calc\n  f₁.coprod g₁ ⊓ f₂ ×ˢ g₂\n  _ = (f₁ ×ˢ ⊤ ⊔ ⊤ ×ˢ g₁) ⊓ f₂ ×ˢ g₂            := by rw [coprod_eq_prod_top_sup_top_prod]\n  _ = f₁ ×ˢ ⊤ ⊓ f₂ ×ˢ g₂ ⊔ ⊤ ×ˢ g₁ ⊓ f₂ ×ˢ g₂   := inf_sup_right _ _ _\n  _ = (f₁ ⊓ f₂) ×ˢ g₂ ⊔ f₂ ×ˢ (g₁ ⊓ g₂)         := by simp [prod_inf_prod]\n  _ ≤ f₁ ×ˢ g₂ ⊔ f₂ ×ˢ g₁                       :=\n    sup_le_sup (prod_mono inf_le_left le_rfl) (prod_mono le_rfl inf_le_left)\n\n"}
{"name":"Filter.principal_coprod_principal","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nt : Set β\n⊢ Eq ((Filter.principal s).coprod (Filter.principal t)) (Filter.principal (HasCompl.compl (SProd.sprod (HasCompl.compl s) (HasCompl.compl t))))","decl":"theorem principal_coprod_principal (s : Set α) (t : Set β) :\n    (𝓟 s).coprod (𝓟 t) = 𝓟 (sᶜ ×ˢ tᶜ)ᶜ := by\n  rw [Filter.coprod, comap_principal, comap_principal, sup_principal, Set.prod_eq, compl_inter,\n    preimage_compl, preimage_compl, compl_compl, compl_compl]\n\n-- this inequality can be strict; see `map_const_principal_coprod_map_id_principal` and\n-- `map_prod_map_const_id_principal_coprod_principal` below.\n"}
{"name":"Filter.map_prod_map_coprod_le","module":"Mathlib.Order.Filter.Prod","initialProofState":"α₁ : Type u\nα₂ : Type v\nβ₁ : Type w\nβ₂ : Type x\nf₁ : Filter α₁\nf₂ : Filter α₂\nm₁ : α₁ → β₁\nm₂ : α₂ → β₂\n⊢ LE.le (Filter.map (Prod.map m₁ m₂) (f₁.coprod f₂)) ((Filter.map m₁ f₁).coprod (Filter.map m₂ f₂))","decl":"theorem map_prod_map_coprod_le.{u, v, w, x} {α₁ : Type u} {α₂ : Type v} {β₁ : Type w} {β₂ : Type x}\n    {f₁ : Filter α₁} {f₂ : Filter α₂} {m₁ : α₁ → β₁} {m₂ : α₂ → β₂} :\n    map (Prod.map m₁ m₂) (f₁.coprod f₂) ≤ (map m₁ f₁).coprod (map m₂ f₂) := by\n  intro s\n  simp only [mem_map, mem_coprod_iff]\n  rintro ⟨⟨u₁, hu₁, h₁⟩, u₂, hu₂, h₂⟩\n  refine ⟨⟨m₁ ⁻¹' u₁, hu₁, fun _ hx => h₁ ?_⟩, ⟨m₂ ⁻¹' u₂, hu₂, fun _ hx => h₂ ?_⟩⟩ <;> convert hx\n\n"}
{"name":"Filter.map_const_principal_coprod_map_id_principal","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_6\nβ : Type u_7\nι : Type u_8\na : α\nb : β\ni : ι\n⊢ Eq ((Filter.map (fun x => b) (Filter.principal (Singleton.singleton a))).coprod (Filter.map id (Filter.principal (Singleton.singleton i)))) (Filter.principal (Union.union (SProd.sprod (Singleton.singleton b) Set.univ) (SProd.sprod Set.univ (Singleton.singleton i))))","decl":"/-- Characterization of the coproduct of the `Filter.map`s of two principal filters `𝓟 {a}` and\n`𝓟 {i}`, the first under the constant function `fun a => b` and the second under the identity\nfunction. Together with the next lemma, `map_prod_map_const_id_principal_coprod_principal`, this\nprovides an example showing that the inequality in the lemma `map_prod_map_coprod_le` can be strict.\n-/\ntheorem map_const_principal_coprod_map_id_principal {α β ι : Type*} (a : α) (b : β) (i : ι) :\n    (map (fun _ => b) (𝓟 {a})).coprod (map id (𝓟 {i})) =\n      𝓟 ((({b} : Set β) ×ˢ univ) ∪ (univ ×ˢ ({i} : Set ι))) := by\n  simp only [map_principal, Filter.coprod, comap_principal, sup_principal, image_singleton,\n    image_id, prod_univ, univ_prod, id]\n\n"}
{"name":"Filter.map_prod_map_const_id_principal_coprod_principal","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_6\nβ : Type u_7\nι : Type u_8\na : α\nb : β\ni : ι\n⊢ Eq (Filter.map (Prod.map (fun x => b) id) ((Filter.principal (Singleton.singleton a)).coprod (Filter.principal (Singleton.singleton i)))) (Filter.principal (SProd.sprod (Singleton.singleton b) Set.univ))","decl":"/-- Characterization of the `Filter.map` of the coproduct of two principal filters `𝓟 {a}` and\n`𝓟 {i}`, under the `Prod.map` of two functions, respectively the constant function `fun a => b` and\nthe identity function.  Together with the previous lemma,\n`map_const_principal_coprod_map_id_principal`, this provides an example showing that the inequality\nin the lemma `map_prod_map_coprod_le` can be strict. -/\ntheorem map_prod_map_const_id_principal_coprod_principal {α β ι : Type*} (a : α) (b : β) (i : ι) :\n    map (Prod.map (fun _ : α => b) id) ((𝓟 {a}).coprod (𝓟 {i})) =\n      𝓟 (({b} : Set β) ×ˢ (univ : Set ι)) := by\n  rw [principal_coprod_principal, map_principal]\n  congr\n  ext ⟨b', i'⟩\n  constructor\n  · rintro ⟨⟨a'', i''⟩, _, h₂, h₃⟩\n    simp\n  · rintro ⟨h₁, _⟩\n    use (a, i')\n    simpa using h₁.symm\n\n"}
{"name":"Filter.Tendsto.prod_map_coprod","module":"Mathlib.Order.Filter.Prod","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nδ : Type u_6\nf : α → γ\ng : β → δ\na : Filter α\nb : Filter β\nc : Filter γ\nd : Filter δ\nhf : Filter.Tendsto f a c\nhg : Filter.Tendsto g b d\n⊢ Filter.Tendsto (Prod.map f g) (a.coprod b) (c.coprod d)","decl":"theorem Tendsto.prod_map_coprod {δ : Type*} {f : α → γ} {g : β → δ} {a : Filter α} {b : Filter β}\n    {c : Filter γ} {d : Filter δ} (hf : Tendsto f a c) (hg : Tendsto g b d) :\n    Tendsto (Prod.map f g) (a.coprod b) (c.coprod d) :=\n  map_prod_map_coprod_le.trans (coprod_mono hf hg)\n\n"}
