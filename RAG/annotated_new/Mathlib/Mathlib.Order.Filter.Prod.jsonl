{"name":"Filter.prod_mem_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ns : Set Œ±\nt : Set Œ≤\nf : Filter Œ±\ng : Filter Œ≤\nhs : Membership.mem f s\nht : Membership.mem g t\n‚ä¢ Membership.mem (SProd.sprod f g) (SProd.sprod s t)","decl":"theorem prod_mem_prod (hs : s ‚àà f) (ht : t ‚àà g) : s √óÀ¢ t ‚àà f √óÀ¢ g :=\n  inter_mem_inf (preimage_mem_comap hs) (preimage_mem_comap ht)\n\n"}
{"name":"Filter.mem_prod_iff","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ns : Set (Prod Œ± Œ≤)\nf : Filter Œ±\ng : Filter Œ≤\n‚ä¢ Iff (Membership.mem (SProd.sprod f g) s) (Exists fun t‚ÇÅ => And (Membership.mem f t‚ÇÅ) (Exists fun t‚ÇÇ => And (Membership.mem g t‚ÇÇ) (HasSubset.Subset (SProd.sprod t‚ÇÅ t‚ÇÇ) s)))","decl":"theorem mem_prod_iff {s : Set (Œ± √ó Œ≤)} {f : Filter Œ±} {g : Filter Œ≤} :\n    s ‚àà f √óÀ¢ g ‚Üî ‚àÉ t‚ÇÅ ‚àà f, ‚àÉ t‚ÇÇ ‚àà g, t‚ÇÅ √óÀ¢ t‚ÇÇ ‚äÜ s := by\n  constructor\n  ¬∑ rintro ‚ü®t‚ÇÅ, ‚ü®s‚ÇÅ, hs‚ÇÅ, hts‚ÇÅ‚ü©, t‚ÇÇ, ‚ü®s‚ÇÇ, hs‚ÇÇ, hts‚ÇÇ‚ü©, rfl‚ü©\n    exact ‚ü®s‚ÇÅ, hs‚ÇÅ, s‚ÇÇ, hs‚ÇÇ, fun p ‚ü®h, h'‚ü© => ‚ü®hts‚ÇÅ h, hts‚ÇÇ h'‚ü©‚ü©\n  ¬∑ rintro ‚ü®t‚ÇÅ, ht‚ÇÅ, t‚ÇÇ, ht‚ÇÇ, h‚ü©\n    exact mem_inf_of_inter (preimage_mem_comap ht‚ÇÅ) (preimage_mem_comap ht‚ÇÇ) h\n\n"}
{"name":"Filter.compl_diagonal_mem_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nl‚ÇÅ l‚ÇÇ : Filter Œ±\n‚ä¢ Iff (Membership.mem (SProd.sprod l‚ÇÅ l‚ÇÇ) (HasCompl.compl (Set.diagonal Œ±))) (Disjoint l‚ÇÅ l‚ÇÇ)","decl":"@[simp]\ntheorem compl_diagonal_mem_prod {l‚ÇÅ l‚ÇÇ : Filter Œ±} : (diagonal Œ±)·∂ú ‚àà l‚ÇÅ √óÀ¢ l‚ÇÇ ‚Üî Disjoint l‚ÇÅ l‚ÇÇ := by\n  simp only [mem_prod_iff, Filter.disjoint_iff, prod_subset_compl_diagonal_iff_disjoint]\n\n"}
{"name":"Filter.prod_mem_prod_iff","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ns : Set Œ±\nt : Set Œ≤\nf : Filter Œ±\ng : Filter Œ≤\ninst‚úù¬π : f.NeBot\ninst‚úù : g.NeBot\n‚ä¢ Iff (Membership.mem (SProd.sprod f g) (SProd.sprod s t)) (And (Membership.mem f s) (Membership.mem g t))","decl":"@[simp]\ntheorem prod_mem_prod_iff [f.NeBot] [g.NeBot] : s √óÀ¢ t ‚àà f √óÀ¢ g ‚Üî s ‚àà f ‚àß t ‚àà g :=\n  ‚ü®fun h =>\n    let ‚ü®_s', hs', _t', ht', H‚ü© := mem_prod_iff.1 h\n    (prod_subset_prod_iff.1 H).elim\n      (fun ‚ü®hs's, ht't‚ü© => ‚ü®mem_of_superset hs' hs's, mem_of_superset ht' ht't‚ü©) fun h =>\n      h.elim (fun hs'e => absurd hs'e (nonempty_of_mem hs').ne_empty) fun ht'e =>\n        absurd ht'e (nonempty_of_mem ht').ne_empty,\n    fun h => prod_mem_prod h.1 h.2‚ü©\n\n"}
{"name":"Filter.mem_prod_principal","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nt : Set Œ≤\nf : Filter Œ±\ns : Set (Prod Œ± Œ≤)\n‚ä¢ Iff (Membership.mem (SProd.sprod f (Filter.principal t)) s) (Membership.mem f (setOf fun a => ‚àÄ (b : Œ≤), Membership.mem t b ‚Üí Membership.mem s { fst := a, snd := b }))","decl":"theorem mem_prod_principal {s : Set (Œ± √ó Œ≤)} :\n    s ‚àà f √óÀ¢ ùìü t ‚Üî { a | ‚àÄ b ‚àà t, (a, b) ‚àà s } ‚àà f := by\n  rw [‚Üê @exists_mem_subset_iff _ f, mem_prod_iff]\n  refine exists_congr fun u => Iff.rfl.and ‚ü®?_, fun h => ‚ü®t, mem_principal_self t, ?_‚ü©‚ü©\n  ¬∑ rintro ‚ü®v, v_in, hv‚ü© a a_in b b_in\n    exact hv (mk_mem_prod a_in <| v_in b_in)\n  ¬∑ rintro ‚ü®x, y‚ü© ‚ü®hx, hy‚ü©\n    exact h hx y hy\n\n"}
{"name":"Filter.mem_prod_top","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ns : Set (Prod Œ± Œ≤)\n‚ä¢ Iff (Membership.mem (SProd.sprod f Top.top) s) (Membership.mem f (setOf fun a => ‚àÄ (b : Œ≤), Membership.mem s { fst := a, snd := b }))","decl":"theorem mem_prod_top {s : Set (Œ± √ó Œ≤)} :\n    s ‚àà f √óÀ¢ (‚ä§ : Filter Œ≤) ‚Üî { a | ‚àÄ b, (a, b) ‚àà s } ‚àà f := by\n  rw [‚Üê principal_univ, mem_prod_principal]\n  simp only [mem_univ, forall_true_left]\n\n"}
{"name":"Filter.eventually_prod_principal_iff","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\np : Prod Œ± Œ≤ ‚Üí Prop\ns : Set Œ≤\n‚ä¢ Iff (Filter.Eventually (fun x => p x) (SProd.sprod f (Filter.principal s))) (Filter.Eventually (fun x => ‚àÄ (y : Œ≤), Membership.mem s y ‚Üí p { fst := x, snd := y }) f)","decl":"theorem eventually_prod_principal_iff {p : Œ± √ó Œ≤ ‚Üí Prop} {s : Set Œ≤} :\n    (‚àÄ·∂† x : Œ± √ó Œ≤ in f √óÀ¢ ùìü s, p x) ‚Üî ‚àÄ·∂† x : Œ± in f, ‚àÄ y : Œ≤, y ‚àà s ‚Üí p (x, y) := by\n  rw [eventually_iff, eventually_iff, mem_prod_principal]\n  simp only [mem_setOf_eq]\n\n"}
{"name":"Filter.comap_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nf : Œ± ‚Üí Prod Œ≤ Œ≥\nb : Filter Œ≤\nc : Filter Œ≥\n‚ä¢ Eq (Filter.comap f (SProd.sprod b c)) (Min.min (Filter.comap (Function.comp Prod.fst f) b) (Filter.comap (Function.comp Prod.snd f) c))","decl":"theorem comap_prod (f : Œ± ‚Üí Œ≤ √ó Œ≥) (b : Filter Œ≤) (c : Filter Œ≥) :\n    comap f (b √óÀ¢ c) = comap (Prod.fst ‚àò f) b ‚äì comap (Prod.snd ‚àò f) c := by\n  rw [prod_eq_inf, comap_inf, Filter.comap_comap, Filter.comap_comap]\n\n"}
{"name":"Filter.comap_prodMap_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nŒ¥ : Type u_4\nf : Œ± ‚Üí Œ≤\ng : Œ≥ ‚Üí Œ¥\nlb : Filter Œ≤\nld : Filter Œ¥\n‚ä¢ Eq (Filter.comap (Prod.map f g) (SProd.sprod lb ld)) (SProd.sprod (Filter.comap f lb) (Filter.comap g ld))","decl":"theorem comap_prodMap_prod (f : Œ± ‚Üí Œ≤) (g : Œ≥ ‚Üí Œ¥) (lb : Filter Œ≤) (ld : Filter Œ¥) :\n    comap (Prod.map f g) (lb √óÀ¢ ld) = comap f lb √óÀ¢ comap g ld := by\n  simp [prod_eq_inf, comap_comap, Function.comp_def]\n\n"}
{"name":"Filter.prod_top","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\n‚ä¢ Eq (SProd.sprod f Top.top) (Filter.comap Prod.fst f)","decl":"theorem prod_top : f √óÀ¢ (‚ä§ : Filter Œ≤) = f.comap Prod.fst := by\n  rw [prod_eq_inf, comap_top, inf_top_eq]\n\n"}
{"name":"Filter.top_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ng : Filter Œ≤\n‚ä¢ Eq (SProd.sprod Top.top g) (Filter.comap Prod.snd g)","decl":"theorem top_prod : (‚ä§ : Filter Œ±) √óÀ¢ g = g.comap Prod.snd := by\n  rw [prod_eq_inf, comap_top, top_inf_eq]\n\n"}
{"name":"Filter.sup_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf‚ÇÅ f‚ÇÇ : Filter Œ±\ng : Filter Œ≤\n‚ä¢ Eq (SProd.sprod (Max.max f‚ÇÅ f‚ÇÇ) g) (Max.max (SProd.sprod f‚ÇÅ g) (SProd.sprod f‚ÇÇ g))","decl":"theorem sup_prod (f‚ÇÅ f‚ÇÇ : Filter Œ±) (g : Filter Œ≤) : (f‚ÇÅ ‚äî f‚ÇÇ) √óÀ¢ g = (f‚ÇÅ √óÀ¢ g) ‚äî (f‚ÇÇ √óÀ¢ g) := by\n  simp only [prod_eq_inf, comap_sup, inf_sup_right]\n\n"}
{"name":"Filter.prod_sup","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng‚ÇÅ g‚ÇÇ : Filter Œ≤\n‚ä¢ Eq (SProd.sprod f (Max.max g‚ÇÅ g‚ÇÇ)) (Max.max (SProd.sprod f g‚ÇÅ) (SProd.sprod f g‚ÇÇ))","decl":"theorem prod_sup (f : Filter Œ±) (g‚ÇÅ g‚ÇÇ : Filter Œ≤) : f √óÀ¢ (g‚ÇÅ ‚äî g‚ÇÇ) = (f √óÀ¢ g‚ÇÅ) ‚äî (f √óÀ¢ g‚ÇÇ) := by\n  simp only [prod_eq_inf, comap_sup, inf_sup_left]\n\n"}
{"name":"Filter.eventually_prod_iff","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\np : Prod Œ± Œ≤ ‚Üí Prop\n‚ä¢ Iff (Filter.Eventually (fun x => p x) (SProd.sprod f g)) (Exists fun pa => And (Filter.Eventually (fun x => pa x) f) (Exists fun pb => And (Filter.Eventually (fun y => pb y) g) (‚àÄ {x : Œ±}, pa x ‚Üí ‚àÄ {y : Œ≤}, pb y ‚Üí p { fst := x, snd := y })))","decl":"theorem eventually_prod_iff {p : Œ± √ó Œ≤ ‚Üí Prop} :\n    (‚àÄ·∂† x in f √óÀ¢ g, p x) ‚Üî\n      ‚àÉ pa : Œ± ‚Üí Prop, (‚àÄ·∂† x in f, pa x) ‚àß ‚àÉ pb : Œ≤ ‚Üí Prop, (‚àÄ·∂† y in g, pb y) ‚àß\n        ‚àÄ {x}, pa x ‚Üí ‚àÄ {y}, pb y ‚Üí p (x, y) := by\n  simpa only [Set.prod_subset_iff] using @mem_prod_iff Œ± Œ≤ p f g\n\n"}
{"name":"Filter.tendsto_fst","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\n‚ä¢ Filter.Tendsto Prod.fst (SProd.sprod f g) f","decl":"theorem tendsto_fst : Tendsto Prod.fst (f √óÀ¢ g) f :=\n  tendsto_inf_left tendsto_comap\n\n"}
{"name":"Filter.tendsto_snd","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\n‚ä¢ Filter.Tendsto Prod.snd (SProd.sprod f g) g","decl":"theorem tendsto_snd : Tendsto Prod.snd (f √óÀ¢ g) g :=\n  tendsto_inf_right tendsto_comap\n\n"}
{"name":"Filter.Tendsto.fst","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nf : Filter Œ±\ng : Filter Œ≤\nh : Filter Œ≥\nm : Œ± ‚Üí Prod Œ≤ Œ≥\nH : Filter.Tendsto m f (SProd.sprod g h)\n‚ä¢ Filter.Tendsto (fun a => (m a).1) f g","decl":"/-- If a function tends to a product `g √óÀ¢ h` of filters, then its first component tends to\n`g`. See also `Filter.Tendsto.fst_nhds` for the special case of converging to a point in a\nproduct of two topological spaces. -/\ntheorem Tendsto.fst {h : Filter Œ≥} {m : Œ± ‚Üí Œ≤ √ó Œ≥} (H : Tendsto m f (g √óÀ¢ h)) :\n    Tendsto (fun a ‚Ü¶ (m a).1) f g :=\n  tendsto_fst.comp H\n\n"}
{"name":"Filter.Tendsto.snd","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nf : Filter Œ±\ng : Filter Œ≤\nh : Filter Œ≥\nm : Œ± ‚Üí Prod Œ≤ Œ≥\nH : Filter.Tendsto m f (SProd.sprod g h)\n‚ä¢ Filter.Tendsto (fun a => (m a).2) f h","decl":"/-- If a function tends to a product `g √óÀ¢ h` of filters, then its second component tends to\n`h`. See also `Filter.Tendsto.snd_nhds` for the special case of converging to a point in a\nproduct of two topological spaces. -/\ntheorem Tendsto.snd {h : Filter Œ≥} {m : Œ± ‚Üí Œ≤ √ó Œ≥} (H : Tendsto m f (g √óÀ¢ h)) :\n    Tendsto (fun a ‚Ü¶ (m a).2) f h :=\n  tendsto_snd.comp H\n\n"}
{"name":"Filter.Tendsto.prod_mk","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nf : Filter Œ±\ng : Filter Œ≤\nh : Filter Œ≥\nm‚ÇÅ : Œ± ‚Üí Œ≤\nm‚ÇÇ : Œ± ‚Üí Œ≥\nh‚ÇÅ : Filter.Tendsto m‚ÇÅ f g\nh‚ÇÇ : Filter.Tendsto m‚ÇÇ f h\n‚ä¢ Filter.Tendsto (fun x => { fst := m‚ÇÅ x, snd := m‚ÇÇ x }) f (SProd.sprod g h)","decl":"theorem Tendsto.prod_mk {h : Filter Œ≥} {m‚ÇÅ : Œ± ‚Üí Œ≤} {m‚ÇÇ : Œ± ‚Üí Œ≥}\n    (h‚ÇÅ : Tendsto m‚ÇÅ f g) (h‚ÇÇ : Tendsto m‚ÇÇ f h) : Tendsto (fun x => (m‚ÇÅ x, m‚ÇÇ x)) f (g √óÀ¢ h) :=\n  tendsto_inf.2 ‚ü®tendsto_comap_iff.2 h‚ÇÅ, tendsto_comap_iff.2 h‚ÇÇ‚ü©\n\n"}
{"name":"Filter.tendsto_prod_swap","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\n‚ä¢ Filter.Tendsto Prod.swap (SProd.sprod f g) (SProd.sprod g f)","decl":"theorem tendsto_prod_swap : Tendsto (Prod.swap : Œ± √ó Œ≤ ‚Üí Œ≤ √ó Œ±) (f √óÀ¢ g) (g √óÀ¢ f) :=\n  tendsto_snd.prod_mk tendsto_fst\n\n"}
{"name":"Filter.Eventually.prod_inl","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nla : Filter Œ±\np : Œ± ‚Üí Prop\nh : Filter.Eventually (fun x => p x) la\nlb : Filter Œ≤\n‚ä¢ Filter.Eventually (fun x => p x.1) (SProd.sprod la lb)","decl":"theorem Eventually.prod_inl {la : Filter Œ±} {p : Œ± ‚Üí Prop} (h : ‚àÄ·∂† x in la, p x) (lb : Filter Œ≤) :\n    ‚àÄ·∂† x in la √óÀ¢ lb, p (x : Œ± √ó Œ≤).1 :=\n  tendsto_fst.eventually h\n\n"}
{"name":"Filter.Eventually.prod_inr","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nlb : Filter Œ≤\np : Œ≤ ‚Üí Prop\nh : Filter.Eventually (fun x => p x) lb\nla : Filter Œ±\n‚ä¢ Filter.Eventually (fun x => p x.2) (SProd.sprod la lb)","decl":"theorem Eventually.prod_inr {lb : Filter Œ≤} {p : Œ≤ ‚Üí Prop} (h : ‚àÄ·∂† x in lb, p x) (la : Filter Œ±) :\n    ‚àÄ·∂† x in la √óÀ¢ lb, p (x : Œ± √ó Œ≤).2 :=\n  tendsto_snd.eventually h\n\n"}
{"name":"Filter.Eventually.prod_mk","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nla : Filter Œ±\npa : Œ± ‚Üí Prop\nha : Filter.Eventually (fun x => pa x) la\nlb : Filter Œ≤\npb : Œ≤ ‚Üí Prop\nhb : Filter.Eventually (fun y => pb y) lb\n‚ä¢ Filter.Eventually (fun p => And (pa p.1) (pb p.2)) (SProd.sprod la lb)","decl":"theorem Eventually.prod_mk {la : Filter Œ±} {pa : Œ± ‚Üí Prop} (ha : ‚àÄ·∂† x in la, pa x) {lb : Filter Œ≤}\n    {pb : Œ≤ ‚Üí Prop} (hb : ‚àÄ·∂† y in lb, pb y) : ‚àÄ·∂† p in la √óÀ¢ lb, pa (p : Œ± √ó Œ≤).1 ‚àß pb p.2 :=\n  (ha.prod_inl lb).and (hb.prod_inr la)\n\n"}
{"name":"Filter.EventuallyEq.prod_map","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nŒ¥ : Type u_6\nla : Filter Œ±\nfa ga : Œ± ‚Üí Œ≥\nha : la.EventuallyEq fa ga\nlb : Filter Œ≤\nfb gb : Œ≤ ‚Üí Œ¥\nhb : lb.EventuallyEq fb gb\n‚ä¢ (SProd.sprod la lb).EventuallyEq (Prod.map fa fb) (Prod.map ga gb)","decl":"theorem EventuallyEq.prod_map {Œ¥} {la : Filter Œ±} {fa ga : Œ± ‚Üí Œ≥} (ha : fa =·∂†[la] ga)\n    {lb : Filter Œ≤} {fb gb : Œ≤ ‚Üí Œ¥} (hb : fb =·∂†[lb] gb) :\n    Prod.map fa fb =·∂†[la √óÀ¢ lb] Prod.map ga gb :=\n  (Eventually.prod_mk ha hb).mono fun _ h => Prod.ext h.1 h.2\n\n"}
{"name":"Filter.EventuallyLE.prod_map","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nŒ¥ : Type u_6\ninst‚úù¬π : LE Œ≥\ninst‚úù : LE Œ¥\nla : Filter Œ±\nfa ga : Œ± ‚Üí Œ≥\nha : la.EventuallyLE fa ga\nlb : Filter Œ≤\nfb gb : Œ≤ ‚Üí Œ¥\nhb : lb.EventuallyLE fb gb\n‚ä¢ (SProd.sprod la lb).EventuallyLE (Prod.map fa fb) (Prod.map ga gb)","decl":"theorem EventuallyLE.prod_map {Œ¥} [LE Œ≥] [LE Œ¥] {la : Filter Œ±} {fa ga : Œ± ‚Üí Œ≥} (ha : fa ‚â§·∂†[la] ga)\n    {lb : Filter Œ≤} {fb gb : Œ≤ ‚Üí Œ¥} (hb : fb ‚â§·∂†[lb] gb) :\n    Prod.map fa fb ‚â§·∂†[la √óÀ¢ lb] Prod.map ga gb :=\n  Eventually.prod_mk ha hb\n\n"}
{"name":"Filter.Eventually.curry","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nla : Filter Œ±\nlb : Filter Œ≤\np : Prod Œ± Œ≤ ‚Üí Prop\nh : Filter.Eventually (fun x => p x) (SProd.sprod la lb)\n‚ä¢ Filter.Eventually (fun x => Filter.Eventually (fun y => p { fst := x, snd := y }) lb) la","decl":"theorem Eventually.curry {la : Filter Œ±} {lb : Filter Œ≤} {p : Œ± √ó Œ≤ ‚Üí Prop}\n    (h : ‚àÄ·∂† x in la √óÀ¢ lb, p x) : ‚àÄ·∂† x in la, ‚àÄ·∂† y in lb, p (x, y) := by\n  rcases eventually_prod_iff.1 h with ‚ü®pa, ha, pb, hb, h‚ü©\n  exact ha.mono fun a ha => hb.mono fun b hb => h ha hb\n\n"}
{"name":"Filter.Frequently.uncurry","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nla : Filter Œ±\nlb : Filter Œ≤\np : Œ± ‚Üí Œ≤ ‚Üí Prop\nh : Filter.Frequently (fun x => Filter.Frequently (fun y => p x y) lb) la\n‚ä¢ Filter.Frequently (fun xy => p xy.1 xy.2) (SProd.sprod la lb)","decl":"protected lemma Frequently.uncurry {la : Filter Œ±} {lb : Filter Œ≤} {p : Œ± ‚Üí Œ≤ ‚Üí Prop}\n    (h : ‚àÉ·∂† x in la, ‚àÉ·∂† y in lb, p x y) : ‚àÉ·∂† xy in la √óÀ¢ lb, p xy.1 xy.2 :=\n  mt (fun h ‚Ü¶ by simpa only [not_frequently] using h.curry) h\n\n"}
{"name":"Filter.Eventually.diag_of_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nf : Filter Œ±\np : Prod Œ± Œ± ‚Üí Prop\nh : Filter.Eventually (fun i => p i) (SProd.sprod f f)\n‚ä¢ Filter.Eventually (fun i => p { fst := i, snd := i }) f","decl":"/-- A fact that is eventually true about all pairs `l √óÀ¢ l` is eventually true about\nall diagonal pairs `(i, i)` -/\ntheorem Eventually.diag_of_prod {p : Œ± √ó Œ± ‚Üí Prop} (h : ‚àÄ·∂† i in f √óÀ¢ f, p i) :\n    ‚àÄ·∂† i in f, p (i, i) := by\n  obtain ‚ü®t, ht, s, hs, hst‚ü© := eventually_prod_iff.1 h\n  apply (ht.and hs).mono fun x hx => hst hx.1 hx.2\n\n"}
{"name":"Filter.Eventually.diag_of_prod_left","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≥ : Type u_3\nf : Filter Œ±\ng : Filter Œ≥\np : Prod (Prod Œ± Œ±) Œ≥ ‚Üí Prop\na‚úù : Filter.Eventually (fun x => p x) (SProd.sprod (SProd.sprod f f) g)\n‚ä¢ Filter.Eventually (fun x => p { fst := { fst := x.1, snd := x.1 }, snd := x.2 }) (SProd.sprod f g)","decl":"theorem Eventually.diag_of_prod_left {f : Filter Œ±} {g : Filter Œ≥} {p : (Œ± √ó Œ±) √ó Œ≥ ‚Üí Prop} :\n    (‚àÄ·∂† x in (f √óÀ¢ f) √óÀ¢ g, p x) ‚Üí ‚àÄ·∂† x : Œ± √ó Œ≥ in f √óÀ¢ g, p ((x.1, x.1), x.2) := by\n  intro h\n  obtain ‚ü®t, ht, s, hs, hst‚ü© := eventually_prod_iff.1 h\n  exact (ht.diag_of_prod.prod_mk hs).mono fun x hx => by simp only [hst hx.1 hx.2]\n\n"}
{"name":"Filter.Eventually.diag_of_prod_right","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≥ : Type u_3\nf : Filter Œ±\ng : Filter Œ≥\np : Prod Œ± (Prod Œ≥ Œ≥) ‚Üí Prop\na‚úù : Filter.Eventually (fun x => p x) (SProd.sprod f (SProd.sprod g g))\n‚ä¢ Filter.Eventually (fun x => p { fst := x.1, snd := { fst := x.2, snd := x.2 } }) (SProd.sprod f g)","decl":"theorem Eventually.diag_of_prod_right {f : Filter Œ±} {g : Filter Œ≥} {p : Œ± √ó Œ≥ √ó Œ≥ ‚Üí Prop} :\n    (‚àÄ·∂† x in f √óÀ¢ (g √óÀ¢ g), p x) ‚Üí ‚àÄ·∂† x : Œ± √ó Œ≥ in f √óÀ¢ g, p (x.1, x.2, x.2) := by\n  intro h\n  obtain ‚ü®t, ht, s, hs, hst‚ü© := eventually_prod_iff.1 h\n  exact (ht.prod_mk hs.diag_of_prod).mono fun x hx => by simp only [hst hx.1 hx.2]\n\n"}
{"name":"Filter.tendsto_diag","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nf : Filter Œ±\n‚ä¢ Filter.Tendsto (fun i => { fst := i, snd := i }) f (SProd.sprod f f)","decl":"theorem tendsto_diag : Tendsto (fun i => (i, i)) f (f √óÀ¢ f) :=\n  tendsto_iff_eventually.mpr fun _ hpr => hpr.diag_of_prod\n\n"}
{"name":"Filter.prod_iInf_left","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Sort u_5\ninst‚úù : Nonempty Œπ\nf : Œπ ‚Üí Filter Œ±\ng : Filter Œ≤\n‚ä¢ Eq (SProd.sprod (iInf fun i => f i) g) (iInf fun i => SProd.sprod (f i) g)","decl":"theorem prod_iInf_left [Nonempty Œπ] {f : Œπ ‚Üí Filter Œ±} {g : Filter Œ≤} :\n    (‚®Ö i, f i) √óÀ¢ g = ‚®Ö i, f i √óÀ¢ g := by\n  simp only [prod_eq_inf, comap_iInf, iInf_inf]\n\n"}
{"name":"Filter.prod_iInf_right","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Sort u_5\ninst‚úù : Nonempty Œπ\nf : Filter Œ±\ng : Œπ ‚Üí Filter Œ≤\n‚ä¢ Eq (SProd.sprod f (iInf fun i => g i)) (iInf fun i => SProd.sprod f (g i))","decl":"theorem prod_iInf_right [Nonempty Œπ] {f : Filter Œ±} {g : Œπ ‚Üí Filter Œ≤} :\n    (f √óÀ¢ ‚®Ö i, g i) = ‚®Ö i, f √óÀ¢ g i := by\n  simp only [prod_eq_inf, comap_iInf, inf_iInf]\n\n"}
{"name":"Filter.prod_mono","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf‚ÇÅ f‚ÇÇ : Filter Œ±\ng‚ÇÅ g‚ÇÇ : Filter Œ≤\nhf : LE.le f‚ÇÅ f‚ÇÇ\nhg : LE.le g‚ÇÅ g‚ÇÇ\n‚ä¢ LE.le (SProd.sprod f‚ÇÅ g‚ÇÅ) (SProd.sprod f‚ÇÇ g‚ÇÇ)","decl":"@[mono, gcongr]\ntheorem prod_mono {f‚ÇÅ f‚ÇÇ : Filter Œ±} {g‚ÇÅ g‚ÇÇ : Filter Œ≤} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) (hg : g‚ÇÅ ‚â§ g‚ÇÇ) :\n    f‚ÇÅ √óÀ¢ g‚ÇÅ ‚â§ f‚ÇÇ √óÀ¢ g‚ÇÇ :=\n  inf_le_inf (comap_mono hf) (comap_mono hg)\n\n"}
{"name":"Filter.prod_mono_left","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ng : Filter Œ≤\nf‚ÇÅ f‚ÇÇ : Filter Œ±\nhf : LE.le f‚ÇÅ f‚ÇÇ\n‚ä¢ LE.le (SProd.sprod f‚ÇÅ g) (SProd.sprod f‚ÇÇ g)","decl":"@[gcongr]\ntheorem prod_mono_left (g : Filter Œ≤) {f‚ÇÅ f‚ÇÇ : Filter Œ±} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) : f‚ÇÅ √óÀ¢ g ‚â§ f‚ÇÇ √óÀ¢ g :=\n  Filter.prod_mono hf rfl.le\n\n"}
{"name":"Filter.prod_mono_right","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng‚ÇÅ g‚ÇÇ : Filter Œ≤\nhf : LE.le g‚ÇÅ g‚ÇÇ\n‚ä¢ LE.le (SProd.sprod f g‚ÇÅ) (SProd.sprod f g‚ÇÇ)","decl":"@[gcongr]\ntheorem prod_mono_right (f : Filter Œ±) {g‚ÇÅ g‚ÇÇ : Filter Œ≤} (hf : g‚ÇÅ ‚â§ g‚ÇÇ) : f √óÀ¢ g‚ÇÅ ‚â§ f √óÀ¢ g‚ÇÇ :=\n  Filter.prod_mono rfl.le hf\n\n"}
{"name":"Filter.prod_comap_comap_eq","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ±‚ÇÅ : Type u\nŒ±‚ÇÇ : Type v\nŒ≤‚ÇÅ : Type w\nŒ≤‚ÇÇ : Type x\nf‚ÇÅ : Filter Œ±‚ÇÅ\nf‚ÇÇ : Filter Œ±‚ÇÇ\nm‚ÇÅ : Œ≤‚ÇÅ ‚Üí Œ±‚ÇÅ\nm‚ÇÇ : Œ≤‚ÇÇ ‚Üí Œ±‚ÇÇ\n‚ä¢ Eq (SProd.sprod (Filter.comap m‚ÇÅ f‚ÇÅ) (Filter.comap m‚ÇÇ f‚ÇÇ)) (Filter.comap (fun p => { fst := m‚ÇÅ p.1, snd := m‚ÇÇ p.2 }) (SProd.sprod f‚ÇÅ f‚ÇÇ))","decl":"theorem prod_comap_comap_eq.{u, v, w, x} {Œ±‚ÇÅ : Type u} {Œ±‚ÇÇ : Type v} {Œ≤‚ÇÅ : Type w} {Œ≤‚ÇÇ : Type x}\n    {f‚ÇÅ : Filter Œ±‚ÇÅ} {f‚ÇÇ : Filter Œ±‚ÇÇ} {m‚ÇÅ : Œ≤‚ÇÅ ‚Üí Œ±‚ÇÅ} {m‚ÇÇ : Œ≤‚ÇÇ ‚Üí Œ±‚ÇÇ} :\n    comap m‚ÇÅ f‚ÇÅ √óÀ¢ comap m‚ÇÇ f‚ÇÇ = comap (fun p : Œ≤‚ÇÅ √ó Œ≤‚ÇÇ => (m‚ÇÅ p.1, m‚ÇÇ p.2)) (f‚ÇÅ √óÀ¢ f‚ÇÇ) := by\n  simp only [prod_eq_inf, comap_comap, comap_inf, Function.comp_def]\n\n"}
{"name":"Filter.prod_comm'","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\n‚ä¢ Eq (SProd.sprod f g) (Filter.comap Prod.swap (SProd.sprod g f))","decl":"theorem prod_comm' : f √óÀ¢ g = comap Prod.swap (g √óÀ¢ f) := by\n  simp only [prod_eq_inf, comap_comap, Function.comp_def, inf_comm, Prod.swap, comap_inf]\n\n"}
{"name":"Filter.prod_comm","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\n‚ä¢ Eq (SProd.sprod f g) (Filter.map (fun p => { fst := p.2, snd := p.1 }) (SProd.sprod g f))","decl":"theorem prod_comm : f √óÀ¢ g = map (fun p : Œ≤ √ó Œ± => (p.2, p.1)) (g √óÀ¢ f) := by\n  rw [prod_comm', ‚Üê map_swap_eq_comap_swap]\n  rfl\n\n"}
{"name":"Filter.mem_prod_iff_left","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\ns : Set (Prod Œ± Œ≤)\n‚ä¢ Iff (Membership.mem (SProd.sprod f g) s) (Exists fun t => And (Membership.mem f t) (Filter.Eventually (fun y => ‚àÄ (x : Œ±), Membership.mem t x ‚Üí Membership.mem s { fst := x, snd := y }) g))","decl":"theorem mem_prod_iff_left {s : Set (Œ± √ó Œ≤)} :\n    s ‚àà f √óÀ¢ g ‚Üî ‚àÉ t ‚àà f, ‚àÄ·∂† y in g, ‚àÄ x ‚àà t, (x, y) ‚àà s := by\n  simp only [mem_prod_iff, prod_subset_iff]\n  refine exists_congr fun _ => Iff.rfl.and <| Iff.trans ?_ exists_mem_subset_iff\n  exact exists_congr fun _ => Iff.rfl.and forall‚ÇÇ_swap\n\n"}
{"name":"Filter.mem_prod_iff_right","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\ns : Set (Prod Œ± Œ≤)\n‚ä¢ Iff (Membership.mem (SProd.sprod f g) s) (Exists fun t => And (Membership.mem g t) (Filter.Eventually (fun x => ‚àÄ (y : Œ≤), Membership.mem t y ‚Üí Membership.mem s { fst := x, snd := y }) f))","decl":"theorem mem_prod_iff_right {s : Set (Œ± √ó Œ≤)} :\n    s ‚àà f √óÀ¢ g ‚Üî ‚àÉ t ‚àà g, ‚àÄ·∂† x in f, ‚àÄ y ‚àà t, (x, y) ‚àà s := by\n  rw [prod_comm, mem_map, mem_prod_iff_left]; rfl\n\n"}
{"name":"Filter.map_fst_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\ninst‚úù : g.NeBot\n‚ä¢ Eq (Filter.map Prod.fst (SProd.sprod f g)) f","decl":"@[simp]\ntheorem map_fst_prod (f : Filter Œ±) (g : Filter Œ≤) [NeBot g] : map Prod.fst (f √óÀ¢ g) = f := by\n  ext s\n  simp only [mem_map, mem_prod_iff_left, mem_preimage, eventually_const, ‚Üê subset_def,\n    exists_mem_subset_iff]\n\n"}
{"name":"Filter.map_snd_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\ninst‚úù : f.NeBot\n‚ä¢ Eq (Filter.map Prod.snd (SProd.sprod f g)) g","decl":"@[simp]\ntheorem map_snd_prod (f : Filter Œ±) (g : Filter Œ≤) [NeBot f] : map Prod.snd (f √óÀ¢ g) = g := by\n  rw [prod_comm, map_map]; apply map_fst_prod\n\n"}
{"name":"Filter.prod_le_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf‚ÇÅ f‚ÇÇ : Filter Œ±\ng‚ÇÅ g‚ÇÇ : Filter Œ≤\ninst‚úù¬π : f‚ÇÅ.NeBot\ninst‚úù : g‚ÇÅ.NeBot\n‚ä¢ Iff (LE.le (SProd.sprod f‚ÇÅ g‚ÇÅ) (SProd.sprod f‚ÇÇ g‚ÇÇ)) (And (LE.le f‚ÇÅ f‚ÇÇ) (LE.le g‚ÇÅ g‚ÇÇ))","decl":"@[simp]\ntheorem prod_le_prod {f‚ÇÅ f‚ÇÇ : Filter Œ±} {g‚ÇÅ g‚ÇÇ : Filter Œ≤} [NeBot f‚ÇÅ] [NeBot g‚ÇÅ] :\n    f‚ÇÅ √óÀ¢ g‚ÇÅ ‚â§ f‚ÇÇ √óÀ¢ g‚ÇÇ ‚Üî f‚ÇÅ ‚â§ f‚ÇÇ ‚àß g‚ÇÅ ‚â§ g‚ÇÇ :=\n  ‚ü®fun h =>\n    ‚ü®map_fst_prod f‚ÇÅ g‚ÇÅ ‚ñ∏ tendsto_fst.mono_left h, map_snd_prod f‚ÇÅ g‚ÇÅ ‚ñ∏ tendsto_snd.mono_left h‚ü©,\n    fun h => prod_mono h.1 h.2‚ü©\n\n"}
{"name":"Filter.prod_inj","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf‚ÇÅ f‚ÇÇ : Filter Œ±\ng‚ÇÅ g‚ÇÇ : Filter Œ≤\ninst‚úù¬π : f‚ÇÅ.NeBot\ninst‚úù : g‚ÇÅ.NeBot\n‚ä¢ Iff (Eq (SProd.sprod f‚ÇÅ g‚ÇÅ) (SProd.sprod f‚ÇÇ g‚ÇÇ)) (And (Eq f‚ÇÅ f‚ÇÇ) (Eq g‚ÇÅ g‚ÇÇ))","decl":"@[simp]\ntheorem prod_inj {f‚ÇÅ f‚ÇÇ : Filter Œ±} {g‚ÇÅ g‚ÇÇ : Filter Œ≤} [NeBot f‚ÇÅ] [NeBot g‚ÇÅ] :\n    f‚ÇÅ √óÀ¢ g‚ÇÅ = f‚ÇÇ √óÀ¢ g‚ÇÇ ‚Üî f‚ÇÅ = f‚ÇÇ ‚àß g‚ÇÅ = g‚ÇÇ := by\n  refine ‚ü®fun h => ?_, fun h => h.1 ‚ñ∏ h.2 ‚ñ∏ rfl‚ü©\n  have hle : f‚ÇÅ ‚â§ f‚ÇÇ ‚àß g‚ÇÅ ‚â§ g‚ÇÇ := prod_le_prod.1 h.le\n  haveI := neBot_of_le hle.1; haveI := neBot_of_le hle.2\n  exact ‚ü®hle.1.antisymm <| (prod_le_prod.1 h.ge).1, hle.2.antisymm <| (prod_le_prod.1 h.ge).2‚ü©\n\n"}
{"name":"Filter.eventually_swap_iff","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\np : Prod Œ± Œ≤ ‚Üí Prop\n‚ä¢ Iff (Filter.Eventually (fun x => p x) (SProd.sprod f g)) (Filter.Eventually (fun y => p y.swap) (SProd.sprod g f))","decl":"theorem eventually_swap_iff {p : Œ± √ó Œ≤ ‚Üí Prop} :\n    (‚àÄ·∂† x : Œ± √ó Œ≤ in f √óÀ¢ g, p x) ‚Üî ‚àÄ·∂† y : Œ≤ √ó Œ± in g √óÀ¢ f, p y.swap := by\n  rw [prod_comm]; rfl\n\n"}
{"name":"Filter.prod_assoc","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nf : Filter Œ±\ng : Filter Œ≤\nh : Filter Œ≥\n‚ä¢ Eq (Filter.map (‚áë(Equiv.prodAssoc Œ± Œ≤ Œ≥)) (SProd.sprod (SProd.sprod f g) h)) (SProd.sprod f (SProd.sprod g h))","decl":"theorem prod_assoc (f : Filter Œ±) (g : Filter Œ≤) (h : Filter Œ≥) :\n    map (Equiv.prodAssoc Œ± Œ≤ Œ≥) ((f √óÀ¢ g) √óÀ¢ h) = f √óÀ¢ (g √óÀ¢ h) := by\n  simp_rw [‚Üê comap_equiv_symm, prod_eq_inf, comap_inf, comap_comap, inf_assoc,\n    Function.comp_def, Equiv.prodAssoc_symm_apply]\n\n"}
{"name":"Filter.prod_assoc_symm","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nf : Filter Œ±\ng : Filter Œ≤\nh : Filter Œ≥\n‚ä¢ Eq (Filter.map (‚áë(Equiv.prodAssoc Œ± Œ≤ Œ≥).symm) (SProd.sprod f (SProd.sprod g h))) (SProd.sprod (SProd.sprod f g) h)","decl":"theorem prod_assoc_symm (f : Filter Œ±) (g : Filter Œ≤) (h : Filter Œ≥) :\n    map (Equiv.prodAssoc Œ± Œ≤ Œ≥).symm (f √óÀ¢ (g √óÀ¢ h)) = (f √óÀ¢ g) √óÀ¢ h := by\n  simp_rw [map_equiv_symm, prod_eq_inf, comap_inf, comap_comap, inf_assoc,\n    Function.comp_def, Equiv.prodAssoc_apply]\n\n"}
{"name":"Filter.tendsto_prodAssoc","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nf : Filter Œ±\ng : Filter Œ≤\nh : Filter Œ≥\n‚ä¢ Filter.Tendsto (‚áë(Equiv.prodAssoc Œ± Œ≤ Œ≥)) (SProd.sprod (SProd.sprod f g) h) (SProd.sprod f (SProd.sprod g h))","decl":"theorem tendsto_prodAssoc {h : Filter Œ≥} :\n    Tendsto (Equiv.prodAssoc Œ± Œ≤ Œ≥) ((f √óÀ¢ g) √óÀ¢ h) (f √óÀ¢ (g √óÀ¢ h)) :=\n  (prod_assoc f g h).le\n\n"}
{"name":"Filter.tendsto_prodAssoc_symm","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nf : Filter Œ±\ng : Filter Œ≤\nh : Filter Œ≥\n‚ä¢ Filter.Tendsto (‚áë(Equiv.prodAssoc Œ± Œ≤ Œ≥).symm) (SProd.sprod f (SProd.sprod g h)) (SProd.sprod (SProd.sprod f g) h)","decl":"theorem tendsto_prodAssoc_symm {h : Filter Œ≥} :\n    Tendsto (Equiv.prodAssoc Œ± Œ≤ Œ≥).symm (f √óÀ¢ (g √óÀ¢ h)) ((f √óÀ¢ g) √óÀ¢ h) :=\n  (prod_assoc_symm f g h).le\n\n"}
{"name":"Filter.map_swap4_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nŒ¥ : Type u_4\nf : Filter Œ±\ng : Filter Œ≤\nh : Filter Œ≥\nk : Filter Œ¥\n‚ä¢ Eq (Filter.map (fun p => { fst := { fst := p.1.1, snd := p.2.1 }, snd := { fst := p.1.2, snd := p.2.2 } }) (SProd.sprod (SProd.sprod f g) (SProd.sprod h k))) (SProd.sprod (SProd.sprod f h) (SProd.sprod g k))","decl":"/-- A useful lemma when dealing with uniformities. -/\ntheorem map_swap4_prod {h : Filter Œ≥} {k : Filter Œ¥} :\n    map (fun p : (Œ± √ó Œ≤) √ó Œ≥ √ó Œ¥ => ((p.1.1, p.2.1), (p.1.2, p.2.2))) ((f √óÀ¢ g) √óÀ¢ (h √óÀ¢ k)) =\n      (f √óÀ¢ h) √óÀ¢ (g √óÀ¢ k) := by\n  simp_rw [map_swap4_eq_comap, prod_eq_inf, comap_inf, comap_comap]; ac_rfl\n\n"}
{"name":"Filter.tendsto_swap4_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nŒ¥ : Type u_4\nf : Filter Œ±\ng : Filter Œ≤\nh : Filter Œ≥\nk : Filter Œ¥\n‚ä¢ Filter.Tendsto (fun p => { fst := { fst := p.1.1, snd := p.2.1 }, snd := { fst := p.1.2, snd := p.2.2 } }) (SProd.sprod (SProd.sprod f g) (SProd.sprod h k)) (SProd.sprod (SProd.sprod f h) (SProd.sprod g k))","decl":"theorem tendsto_swap4_prod {h : Filter Œ≥} {k : Filter Œ¥} :\n    Tendsto (fun p : (Œ± √ó Œ≤) √ó Œ≥ √ó Œ¥ => ((p.1.1, p.2.1), (p.1.2, p.2.2))) ((f √óÀ¢ g) √óÀ¢ (h √óÀ¢ k))\n      ((f √óÀ¢ h) √óÀ¢ (g √óÀ¢ k)) :=\n  map_swap4_prod.le\n\n"}
{"name":"Filter.prod_map_map_eq","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ±‚ÇÅ : Type u\nŒ±‚ÇÇ : Type v\nŒ≤‚ÇÅ : Type w\nŒ≤‚ÇÇ : Type x\nf‚ÇÅ : Filter Œ±‚ÇÅ\nf‚ÇÇ : Filter Œ±‚ÇÇ\nm‚ÇÅ : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÅ\nm‚ÇÇ : Œ±‚ÇÇ ‚Üí Œ≤‚ÇÇ\n‚ä¢ Eq (SProd.sprod (Filter.map m‚ÇÅ f‚ÇÅ) (Filter.map m‚ÇÇ f‚ÇÇ)) (Filter.map (fun p => { fst := m‚ÇÅ p.1, snd := m‚ÇÇ p.2 }) (SProd.sprod f‚ÇÅ f‚ÇÇ))","decl":"theorem prod_map_map_eq.{u, v, w, x} {Œ±‚ÇÅ : Type u} {Œ±‚ÇÇ : Type v} {Œ≤‚ÇÅ : Type w} {Œ≤‚ÇÇ : Type x}\n    {f‚ÇÅ : Filter Œ±‚ÇÅ} {f‚ÇÇ : Filter Œ±‚ÇÇ} {m‚ÇÅ : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÅ} {m‚ÇÇ : Œ±‚ÇÇ ‚Üí Œ≤‚ÇÇ} :\n    map m‚ÇÅ f‚ÇÅ √óÀ¢ map m‚ÇÇ f‚ÇÇ = map (fun p : Œ±‚ÇÅ √ó Œ±‚ÇÇ => (m‚ÇÅ p.1, m‚ÇÇ p.2)) (f‚ÇÅ √óÀ¢ f‚ÇÇ) :=\n  le_antisymm\n    (fun s hs =>\n      let ‚ü®s‚ÇÅ, hs‚ÇÅ, s‚ÇÇ, hs‚ÇÇ, h‚ü© := mem_prod_iff.mp hs\n      mem_of_superset (prod_mem_prod (image_mem_map hs‚ÇÅ) (image_mem_map hs‚ÇÇ)) <|\n        by rwa [prod_image_image_eq, image_subset_iff])\n    ((tendsto_map.comp tendsto_fst).prod_mk (tendsto_map.comp tendsto_snd))\n\n"}
{"name":"Filter.prod_map_map_eq'","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ±‚ÇÅ : Type u_6\nŒ±‚ÇÇ : Type u_7\nŒ≤‚ÇÅ : Type u_8\nŒ≤‚ÇÇ : Type u_9\nf : Œ±‚ÇÅ ‚Üí Œ±‚ÇÇ\ng : Œ≤‚ÇÅ ‚Üí Œ≤‚ÇÇ\nF : Filter Œ±‚ÇÅ\nG : Filter Œ≤‚ÇÅ\n‚ä¢ Eq (SProd.sprod (Filter.map f F) (Filter.map g G)) (Filter.map (Prod.map f g) (SProd.sprod F G))","decl":"theorem prod_map_map_eq' {Œ±‚ÇÅ : Type*} {Œ±‚ÇÇ : Type*} {Œ≤‚ÇÅ : Type*} {Œ≤‚ÇÇ : Type*} (f : Œ±‚ÇÅ ‚Üí Œ±‚ÇÇ)\n    (g : Œ≤‚ÇÅ ‚Üí Œ≤‚ÇÇ) (F : Filter Œ±‚ÇÅ) (G : Filter Œ≤‚ÇÅ) :\n    map f F √óÀ¢ map g G = map (Prod.map f g) (F √óÀ¢ G) :=\n  prod_map_map_eq\n\n"}
{"name":"Filter.prod_map_left","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nf : Œ± ‚Üí Œ≤\nF : Filter Œ±\nG : Filter Œ≥\n‚ä¢ Eq (SProd.sprod (Filter.map f F) G) (Filter.map (Prod.map f id) (SProd.sprod F G))","decl":"theorem prod_map_left (f : Œ± ‚Üí Œ≤) (F : Filter Œ±) (G : Filter Œ≥) :\n    map f F √óÀ¢ G = map (Prod.map f id) (F √óÀ¢ G) := by\n  rw [‚Üê prod_map_map_eq', map_id]\n\n"}
{"name":"Filter.prod_map_right","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nf : Œ≤ ‚Üí Œ≥\nF : Filter Œ±\nG : Filter Œ≤\n‚ä¢ Eq (SProd.sprod F (Filter.map f G)) (Filter.map (Prod.map id f) (SProd.sprod F G))","decl":"theorem prod_map_right (f : Œ≤ ‚Üí Œ≥) (F : Filter Œ±) (G : Filter Œ≤) :\n    F √óÀ¢ map f G = map (Prod.map id f) (F √óÀ¢ G) := by\n  rw [‚Üê prod_map_map_eq', map_id]\n\n"}
{"name":"Filter.le_prod_map_fst_snd","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter (Prod Œ± Œ≤)\n‚ä¢ LE.le f (SProd.sprod (Filter.map Prod.fst f) (Filter.map Prod.snd f))","decl":"theorem le_prod_map_fst_snd {f : Filter (Œ± √ó Œ≤)} : f ‚â§ map Prod.fst f √óÀ¢ map Prod.snd f :=\n  le_inf le_comap_map le_comap_map\n\n"}
{"name":"Filter.Tendsto.prod_map","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nŒ¥ : Type u_6\nf : Œ± ‚Üí Œ≥\ng : Œ≤ ‚Üí Œ¥\na : Filter Œ±\nb : Filter Œ≤\nc : Filter Œ≥\nd : Filter Œ¥\nhf : Filter.Tendsto f a c\nhg : Filter.Tendsto g b d\n‚ä¢ Filter.Tendsto (Prod.map f g) (SProd.sprod a b) (SProd.sprod c d)","decl":"theorem Tendsto.prod_map {Œ¥ : Type*} {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ¥} {a : Filter Œ±} {b : Filter Œ≤}\n    {c : Filter Œ≥} {d : Filter Œ¥} (hf : Tendsto f a c) (hg : Tendsto g b d) :\n    Tendsto (Prod.map f g) (a √óÀ¢ b) (c √óÀ¢ d) := by\n  rw [Tendsto, Prod.map_def, ‚Üê prod_map_map_eq]\n  exact Filter.prod_mono hf hg\n\n"}
{"name":"Filter.map_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nm : Prod Œ± Œ≤ ‚Üí Œ≥\nf : Filter Œ±\ng : Filter Œ≤\n‚ä¢ Eq (Filter.map m (SProd.sprod f g)) ((Filter.map (fun a b => m { fst := a, snd := b }) f).seq g)","decl":"protected theorem map_prod (m : Œ± √ó Œ≤ ‚Üí Œ≥) (f : Filter Œ±) (g : Filter Œ≤) :\n    map m (f √óÀ¢ g) = (f.map fun a b => m (a, b)).seq g := by\n  simp only [Filter.ext_iff, mem_map, mem_prod_iff, mem_map_seq_iff, exists_and_left]\n  intro s\n  constructor\n  ¬∑ exact fun ‚ü®t, ht, s, hs, h‚ü© => ‚ü®s, hs, t, ht, fun x hx y hy => @h ‚ü®x, y‚ü© ‚ü®hx, hy‚ü©‚ü©\n  ¬∑ exact fun ‚ü®s, hs, t, ht, h‚ü© => ‚ü®t, ht, s, hs, fun ‚ü®x, y‚ü© ‚ü®hx, hy‚ü© => h x hx y hy‚ü©\n\n"}
{"name":"Filter.prod_eq","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\n‚ä¢ Eq (SProd.sprod f g) ((Filter.map Prod.mk f).seq g)","decl":"theorem prod_eq : f √óÀ¢ g = (f.map Prod.mk).seq g := f.map_prod id g\n\n"}
{"name":"Filter.prod_inf_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf‚ÇÅ f‚ÇÇ : Filter Œ±\ng‚ÇÅ g‚ÇÇ : Filter Œ≤\n‚ä¢ Eq (Min.min (SProd.sprod f‚ÇÅ g‚ÇÅ) (SProd.sprod f‚ÇÇ g‚ÇÇ)) (SProd.sprod (Min.min f‚ÇÅ f‚ÇÇ) (Min.min g‚ÇÅ g‚ÇÇ))","decl":"theorem prod_inf_prod {f‚ÇÅ f‚ÇÇ : Filter Œ±} {g‚ÇÅ g‚ÇÇ : Filter Œ≤} :\n    (f‚ÇÅ √óÀ¢ g‚ÇÅ) ‚äì (f‚ÇÇ √óÀ¢ g‚ÇÇ) = (f‚ÇÅ ‚äì f‚ÇÇ) √óÀ¢ (g‚ÇÅ ‚äì g‚ÇÇ) := by\n  simp only [prod_eq_inf, comap_inf, inf_comm, inf_assoc, inf_left_comm]\n\n"}
{"name":"Filter.inf_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ng : Filter Œ≤\nf‚ÇÅ f‚ÇÇ : Filter Œ±\n‚ä¢ Eq (SProd.sprod (Min.min f‚ÇÅ f‚ÇÇ) g) (Min.min (SProd.sprod f‚ÇÅ g) (SProd.sprod f‚ÇÇ g))","decl":"theorem inf_prod {f‚ÇÅ f‚ÇÇ : Filter Œ±} : (f‚ÇÅ ‚äì f‚ÇÇ) √óÀ¢ g = (f‚ÇÅ √óÀ¢ g) ‚äì (f‚ÇÇ √óÀ¢ g) := by\n  rw [prod_inf_prod, inf_idem]\n\n"}
{"name":"Filter.prod_inf","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng‚ÇÅ g‚ÇÇ : Filter Œ≤\n‚ä¢ Eq (SProd.sprod f (Min.min g‚ÇÅ g‚ÇÇ)) (Min.min (SProd.sprod f g‚ÇÅ) (SProd.sprod f g‚ÇÇ))","decl":"theorem prod_inf {g‚ÇÅ g‚ÇÇ : Filter Œ≤} : f √óÀ¢ (g‚ÇÅ ‚äì g‚ÇÇ) = (f √óÀ¢ g‚ÇÅ) ‚äì (f √óÀ¢ g‚ÇÇ) := by\n  rw [prod_inf_prod, inf_idem]\n\n"}
{"name":"Filter.prod_principal_principal","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ns : Set Œ±\nt : Set Œ≤\n‚ä¢ Eq (SProd.sprod (Filter.principal s) (Filter.principal t)) (Filter.principal (SProd.sprod s t))","decl":"@[simp]\ntheorem prod_principal_principal {s : Set Œ±} {t : Set Œ≤} : ùìü s √óÀ¢ ùìü t = ùìü (s √óÀ¢ t) := by\n  simp only [prod_eq_inf, comap_principal, principal_eq_iff_eq, comap_principal, inf_principal]; rfl\n\n"}
{"name":"Filter.pure_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\na : Œ±\nf : Filter Œ≤\n‚ä¢ Eq (SProd.sprod (Pure.pure a) f) (Filter.map (Prod.mk a) f)","decl":"@[simp]\ntheorem pure_prod {a : Œ±} {f : Filter Œ≤} : pure a √óÀ¢ f = map (Prod.mk a) f := by\n  rw [prod_eq, map_pure, pure_seq_eq_map]\n\n"}
{"name":"Filter.map_pure_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nf : Œ± ‚Üí Œ≤ ‚Üí Œ≥\na : Œ±\nB : Filter Œ≤\n‚ä¢ Eq (Filter.map (Function.uncurry f) (SProd.sprod (Pure.pure a) B)) (Filter.map (f a) B)","decl":"theorem map_pure_prod (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (a : Œ±) (B : Filter Œ≤) :\n    map (Function.uncurry f) (pure a √óÀ¢ B) = map (f a) B := by\n  rw [Filter.pure_prod]; rfl\n\n"}
{"name":"Filter.prod_pure","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\nb : Œ≤\n‚ä¢ Eq (SProd.sprod f (Pure.pure b)) (Filter.map (fun a => { fst := a, snd := b }) f)","decl":"@[simp]\ntheorem prod_pure {b : Œ≤} : f √óÀ¢ pure b = map (fun a => (a, b)) f := by\n  rw [prod_eq, seq_pure, map_map]; rfl\n\n"}
{"name":"Filter.prod_pure_pure","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\na : Œ±\nb : Œ≤\n‚ä¢ Eq (SProd.sprod (Pure.pure a) (Pure.pure b)) (Pure.pure { fst := a, snd := b })","decl":"theorem prod_pure_pure {a : Œ±} {b : Œ≤} :\n    (pure a : Filter Œ±) √óÀ¢ (pure b : Filter Œ≤) = pure (a, b) := by simp\n\n"}
{"name":"Filter.prod_eq_bot","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\n‚ä¢ Iff (Eq (SProd.sprod f g) Bot.bot) (Or (Eq f Bot.bot) (Eq g Bot.bot))","decl":"@[simp]\ntheorem prod_eq_bot : f √óÀ¢ g = ‚ä• ‚Üî f = ‚ä• ‚à® g = ‚ä• := by\n  simp_rw [‚Üê empty_mem_iff_bot, mem_prod_iff, subset_empty_iff, prod_eq_empty_iff, ‚Üê exists_prop,\n    Subtype.exists', exists_or, exists_const, Subtype.exists, exists_prop, exists_eq_right]\n\n"}
{"name":"Filter.prod_bot","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\n‚ä¢ Eq (SProd.sprod f Bot.bot) Bot.bot","decl":"@[simp] theorem prod_bot : f √óÀ¢ (‚ä• : Filter Œ≤) = ‚ä• := prod_eq_bot.2 <| Or.inr rfl\n\n"}
{"name":"Filter.bot_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ng : Filter Œ≤\n‚ä¢ Eq (SProd.sprod Bot.bot g) Bot.bot","decl":"@[simp] theorem bot_prod : (‚ä• : Filter Œ±) √óÀ¢ g = ‚ä• := prod_eq_bot.2 <| Or.inl rfl\n\n"}
{"name":"Filter.prod_neBot","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\n‚ä¢ Iff (SProd.sprod f g).NeBot (And f.NeBot g.NeBot)","decl":"theorem prod_neBot : NeBot (f √óÀ¢ g) ‚Üî NeBot f ‚àß NeBot g := by\n  simp only [neBot_iff, Ne, prod_eq_bot, not_or]\n\n"}
{"name":"Filter.NeBot.prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\nhf : f.NeBot\nhg : g.NeBot\n‚ä¢ (SProd.sprod f g).NeBot","decl":"protected theorem NeBot.prod (hf : NeBot f) (hg : NeBot g) : NeBot (f √óÀ¢ g) := prod_neBot.2 ‚ü®hf, hg‚ü©\n\n"}
{"name":"Filter.prod.instNeBot","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\nhf : f.NeBot\nhg : g.NeBot\n‚ä¢ (SProd.sprod f g).NeBot","decl":"instance prod.instNeBot [hf : NeBot f] [hg : NeBot g] : NeBot (f √óÀ¢ g) := hf.prod hg\n\n"}
{"name":"Filter.disjoint_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\nf' : Filter Œ±\ng' : Filter Œ≤\n‚ä¢ Iff (Disjoint (SProd.sprod f g) (SProd.sprod f' g')) (Or (Disjoint f f') (Disjoint g g'))","decl":"@[simp]\nlemma disjoint_prod {f' : Filter Œ±} {g' : Filter Œ≤} :\n    Disjoint (f √óÀ¢ g) (f' √óÀ¢ g') ‚Üî Disjoint f f' ‚à® Disjoint g g' := by\n  simp only [disjoint_iff, prod_inf_prod, prod_eq_bot]\n\n"}
{"name":"Filter.frequently_prod_and","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\np : Œ± ‚Üí Prop\nq : Œ≤ ‚Üí Prop\n‚ä¢ Iff (Filter.Frequently (fun x => And (p x.1) (q x.2)) (SProd.sprod f g)) (And (Filter.Frequently (fun a => p a) f) (Filter.Frequently (fun b => q b) g))","decl":"/-- `p ‚àß q` occurs frequently along the product of two filters\niff both `p` and `q` occur frequently along the corresponding filters. -/\ntheorem frequently_prod_and {p : Œ± ‚Üí Prop} {q : Œ≤ ‚Üí Prop} :\n    (‚àÉ·∂† x in f √óÀ¢ g, p x.1 ‚àß q x.2) ‚Üî (‚àÉ·∂† a in f, p a) ‚àß ‚àÉ·∂† b in g, q b := by\n  simp only [frequently_iff_neBot, ‚Üê prod_neBot, ‚Üê prod_inf_prod, prod_principal_principal]\n  rfl\n\n"}
{"name":"Filter.tendsto_prod_iff","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nf : Prod Œ± Œ≤ ‚Üí Œ≥\nx : Filter Œ±\ny : Filter Œ≤\nz : Filter Œ≥\n‚ä¢ Iff (Filter.Tendsto f (SProd.sprod x y) z) (‚àÄ (W : Set Œ≥), Membership.mem z W ‚Üí Exists fun U => And (Membership.mem x U) (Exists fun V => And (Membership.mem y V) (‚àÄ (x : Œ±) (y : Œ≤), Membership.mem U x ‚Üí Membership.mem V y ‚Üí Membership.mem W (f { fst := x, snd := y }))))","decl":"theorem tendsto_prod_iff {f : Œ± √ó Œ≤ ‚Üí Œ≥} {x : Filter Œ±} {y : Filter Œ≤} {z : Filter Œ≥} :\n    Tendsto f (x √óÀ¢ y) z ‚Üî ‚àÄ W ‚àà z, ‚àÉ U ‚àà x, ‚àÉ V ‚àà y, ‚àÄ x y, x ‚àà U ‚Üí y ‚àà V ‚Üí f (x, y) ‚àà W := by\n  simp only [tendsto_def, mem_prod_iff, prod_sub_preimage_iff, exists_prop]\n\n"}
{"name":"Filter.tendsto_prod_iff'","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nf : Filter Œ±\ng : Filter Œ≤\ng' : Filter Œ≥\ns : Œ± ‚Üí Prod Œ≤ Œ≥\n‚ä¢ Iff (Filter.Tendsto s f (SProd.sprod g g')) (And (Filter.Tendsto (fun n => (s n).1) f g) (Filter.Tendsto (fun n => (s n).2) f g'))","decl":"theorem tendsto_prod_iff' {g' : Filter Œ≥} {s : Œ± ‚Üí Œ≤ √ó Œ≥} :\n    Tendsto s f (g √óÀ¢ g') ‚Üî Tendsto (fun n => (s n).1) f g ‚àß Tendsto (fun n => (s n).2) f g' := by\n  simp only [prod_eq_inf, tendsto_inf, tendsto_comap_iff, Function.comp_def]\n\n"}
{"name":"Filter.le_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter (Prod Œ± Œ≤)\ng : Filter Œ±\ng' : Filter Œ≤\n‚ä¢ Iff (LE.le f (SProd.sprod g g')) (And (Filter.Tendsto Prod.fst f g) (Filter.Tendsto Prod.snd f g'))","decl":"theorem le_prod {f : Filter (Œ± √ó Œ≤)} {g : Filter Œ±} {g' : Filter Œ≤} :\n    (f ‚â§ g √óÀ¢ g') ‚Üî Tendsto Prod.fst f g ‚àß Tendsto Prod.snd f g' :=\n  tendsto_prod_iff'\n\n"}
{"name":"Filter.coprod_eq_prod_top_sup_top_prod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\n‚ä¢ Eq (f.coprod g) (Max.max (SProd.sprod f Top.top) (SProd.sprod Top.top g))","decl":"theorem coprod_eq_prod_top_sup_top_prod (f : Filter Œ±) (g : Filter Œ≤) :\n    Filter.coprod f g = f √óÀ¢ ‚ä§ ‚äî ‚ä§ √óÀ¢ g := by\n  rw [prod_top, top_prod]\n  rfl\n\n"}
{"name":"Filter.mem_coprod_iff","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ns : Set (Prod Œ± Œ≤)\nf : Filter Œ±\ng : Filter Œ≤\n‚ä¢ Iff (Membership.mem (f.coprod g) s) (And (Exists fun t‚ÇÅ => And (Membership.mem f t‚ÇÅ) (HasSubset.Subset (Set.preimage Prod.fst t‚ÇÅ) s)) (Exists fun t‚ÇÇ => And (Membership.mem g t‚ÇÇ) (HasSubset.Subset (Set.preimage Prod.snd t‚ÇÇ) s)))","decl":"theorem mem_coprod_iff {s : Set (Œ± √ó Œ≤)} {f : Filter Œ±} {g : Filter Œ≤} :\n    s ‚àà f.coprod g ‚Üî (‚àÉ t‚ÇÅ ‚àà f, Prod.fst ‚Åª¬π' t‚ÇÅ ‚äÜ s) ‚àß ‚àÉ t‚ÇÇ ‚àà g, Prod.snd ‚Åª¬π' t‚ÇÇ ‚äÜ s := by\n  simp [Filter.coprod]\n\n"}
{"name":"Filter.bot_coprod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nl : Filter Œ≤\n‚ä¢ Eq (Bot.bot.coprod l) (Filter.comap Prod.snd l)","decl":"@[simp]\ntheorem bot_coprod (l : Filter Œ≤) : (‚ä• : Filter Œ±).coprod l = comap Prod.snd l := by\n  simp [Filter.coprod]\n\n"}
{"name":"Filter.coprod_bot","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nl : Filter Œ±\n‚ä¢ Eq (l.coprod Bot.bot) (Filter.comap Prod.fst l)","decl":"@[simp]\ntheorem coprod_bot (l : Filter Œ±) : l.coprod (‚ä• : Filter Œ≤) = comap Prod.fst l := by\n  simp [Filter.coprod]\n\n"}
{"name":"Filter.bot_coprod_bot","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\n‚ä¢ Eq (Bot.bot.coprod Bot.bot) Bot.bot","decl":"theorem bot_coprod_bot : (‚ä• : Filter Œ±).coprod (‚ä• : Filter Œ≤) = ‚ä• := by simp\n\n"}
{"name":"Filter.compl_mem_coprod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ns : Set (Prod Œ± Œ≤)\nla : Filter Œ±\nlb : Filter Œ≤\n‚ä¢ Iff (Membership.mem (la.coprod lb) (HasCompl.compl s)) (And (Membership.mem la (HasCompl.compl (Set.image Prod.fst s))) (Membership.mem lb (HasCompl.compl (Set.image Prod.snd s))))","decl":"theorem compl_mem_coprod {s : Set (Œ± √ó Œ≤)} {la : Filter Œ±} {lb : Filter Œ≤} :\n    s·∂ú ‚àà la.coprod lb ‚Üî (Prod.fst '' s)·∂ú ‚àà la ‚àß (Prod.snd '' s)·∂ú ‚àà lb := by\n  simp only [Filter.coprod, mem_sup, compl_mem_comap]\n\n"}
{"name":"Filter.coprod_mono","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf‚ÇÅ f‚ÇÇ : Filter Œ±\ng‚ÇÅ g‚ÇÇ : Filter Œ≤\nhf : LE.le f‚ÇÅ f‚ÇÇ\nhg : LE.le g‚ÇÅ g‚ÇÇ\n‚ä¢ LE.le (f‚ÇÅ.coprod g‚ÇÅ) (f‚ÇÇ.coprod g‚ÇÇ)","decl":"@[mono]\ntheorem coprod_mono {f‚ÇÅ f‚ÇÇ : Filter Œ±} {g‚ÇÅ g‚ÇÇ : Filter Œ≤} (hf : f‚ÇÅ ‚â§ f‚ÇÇ) (hg : g‚ÇÅ ‚â§ g‚ÇÇ) :\n    f‚ÇÅ.coprod g‚ÇÅ ‚â§ f‚ÇÇ.coprod g‚ÇÇ :=\n  sup_le_sup (comap_mono hf) (comap_mono hg)\n\n"}
{"name":"Filter.coprod_neBot_iff","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\n‚ä¢ Iff (f.coprod g).NeBot (Or (And f.NeBot (Nonempty Œ≤)) (And (Nonempty Œ±) g.NeBot))","decl":"theorem coprod_neBot_iff : (f.coprod g).NeBot ‚Üî f.NeBot ‚àß Nonempty Œ≤ ‚à® Nonempty Œ± ‚àß g.NeBot := by\n  simp [Filter.coprod]\n\n"}
{"name":"Filter.coprod_neBot_left","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\ninst‚úù¬π : f.NeBot\ninst‚úù : Nonempty Œ≤\n‚ä¢ (f.coprod g).NeBot","decl":"@[instance]\ntheorem coprod_neBot_left [NeBot f] [Nonempty Œ≤] : (f.coprod g).NeBot :=\n  coprod_neBot_iff.2 (Or.inl ‚ü®‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü©)\n\n"}
{"name":"Filter.coprod_neBot_right","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf : Filter Œ±\ng : Filter Œ≤\ninst‚úù¬π : g.NeBot\ninst‚úù : Nonempty Œ±\n‚ä¢ (f.coprod g).NeBot","decl":"@[instance]\ntheorem coprod_neBot_right [NeBot g] [Nonempty Œ±] : (f.coprod g).NeBot :=\n  coprod_neBot_iff.2 (Or.inr ‚ü®‚Äπ_‚Ä∫, ‚Äπ_‚Ä∫‚ü©)\n\n"}
{"name":"Filter.coprod_inf_prod_le","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nf‚ÇÅ f‚ÇÇ : Filter Œ±\ng‚ÇÅ g‚ÇÇ : Filter Œ≤\n‚ä¢ LE.le (Min.min (f‚ÇÅ.coprod g‚ÇÅ) (SProd.sprod f‚ÇÇ g‚ÇÇ)) (Max.max (SProd.sprod f‚ÇÅ g‚ÇÇ) (SProd.sprod f‚ÇÇ g‚ÇÅ))","decl":"theorem coprod_inf_prod_le (f‚ÇÅ f‚ÇÇ : Filter Œ±) (g‚ÇÅ g‚ÇÇ : Filter Œ≤) :\n    f‚ÇÅ.coprod g‚ÇÅ ‚äì f‚ÇÇ √óÀ¢ g‚ÇÇ ‚â§ f‚ÇÅ √óÀ¢ g‚ÇÇ ‚äî f‚ÇÇ √óÀ¢ g‚ÇÅ := calc\n  f‚ÇÅ.coprod g‚ÇÅ ‚äì f‚ÇÇ √óÀ¢ g‚ÇÇ\n  _ = (f‚ÇÅ √óÀ¢ ‚ä§ ‚äî ‚ä§ √óÀ¢ g‚ÇÅ) ‚äì f‚ÇÇ √óÀ¢ g‚ÇÇ            := by rw [coprod_eq_prod_top_sup_top_prod]\n  _ = f‚ÇÅ √óÀ¢ ‚ä§ ‚äì f‚ÇÇ √óÀ¢ g‚ÇÇ ‚äî ‚ä§ √óÀ¢ g‚ÇÅ ‚äì f‚ÇÇ √óÀ¢ g‚ÇÇ   := inf_sup_right _ _ _\n  _ = (f‚ÇÅ ‚äì f‚ÇÇ) √óÀ¢ g‚ÇÇ ‚äî f‚ÇÇ √óÀ¢ (g‚ÇÅ ‚äì g‚ÇÇ)         := by simp [prod_inf_prod]\n  _ ‚â§ f‚ÇÅ √óÀ¢ g‚ÇÇ ‚äî f‚ÇÇ √óÀ¢ g‚ÇÅ                       :=\n    sup_le_sup (prod_mono inf_le_left le_rfl) (prod_mono le_rfl inf_le_left)\n\n"}
{"name":"Filter.principal_coprod_principal","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ns : Set Œ±\nt : Set Œ≤\n‚ä¢ Eq ((Filter.principal s).coprod (Filter.principal t)) (Filter.principal (HasCompl.compl (SProd.sprod (HasCompl.compl s) (HasCompl.compl t))))","decl":"theorem principal_coprod_principal (s : Set Œ±) (t : Set Œ≤) :\n    (ùìü s).coprod (ùìü t) = ùìü (s·∂ú √óÀ¢ t·∂ú)·∂ú := by\n  rw [Filter.coprod, comap_principal, comap_principal, sup_principal, Set.prod_eq, compl_inter,\n    preimage_compl, preimage_compl, compl_compl, compl_compl]\n\n-- this inequality can be strict; see `map_const_principal_coprod_map_id_principal` and\n-- `map_prod_map_const_id_principal_coprod_principal` below.\n"}
{"name":"Filter.map_prod_map_coprod_le","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ±‚ÇÅ : Type u\nŒ±‚ÇÇ : Type v\nŒ≤‚ÇÅ : Type w\nŒ≤‚ÇÇ : Type x\nf‚ÇÅ : Filter Œ±‚ÇÅ\nf‚ÇÇ : Filter Œ±‚ÇÇ\nm‚ÇÅ : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÅ\nm‚ÇÇ : Œ±‚ÇÇ ‚Üí Œ≤‚ÇÇ\n‚ä¢ LE.le (Filter.map (Prod.map m‚ÇÅ m‚ÇÇ) (f‚ÇÅ.coprod f‚ÇÇ)) ((Filter.map m‚ÇÅ f‚ÇÅ).coprod (Filter.map m‚ÇÇ f‚ÇÇ))","decl":"theorem map_prod_map_coprod_le.{u, v, w, x} {Œ±‚ÇÅ : Type u} {Œ±‚ÇÇ : Type v} {Œ≤‚ÇÅ : Type w} {Œ≤‚ÇÇ : Type x}\n    {f‚ÇÅ : Filter Œ±‚ÇÅ} {f‚ÇÇ : Filter Œ±‚ÇÇ} {m‚ÇÅ : Œ±‚ÇÅ ‚Üí Œ≤‚ÇÅ} {m‚ÇÇ : Œ±‚ÇÇ ‚Üí Œ≤‚ÇÇ} :\n    map (Prod.map m‚ÇÅ m‚ÇÇ) (f‚ÇÅ.coprod f‚ÇÇ) ‚â§ (map m‚ÇÅ f‚ÇÅ).coprod (map m‚ÇÇ f‚ÇÇ) := by\n  intro s\n  simp only [mem_map, mem_coprod_iff]\n  rintro ‚ü®‚ü®u‚ÇÅ, hu‚ÇÅ, h‚ÇÅ‚ü©, u‚ÇÇ, hu‚ÇÇ, h‚ÇÇ‚ü©\n  refine ‚ü®‚ü®m‚ÇÅ ‚Åª¬π' u‚ÇÅ, hu‚ÇÅ, fun _ hx => h‚ÇÅ ?_‚ü©, ‚ü®m‚ÇÇ ‚Åª¬π' u‚ÇÇ, hu‚ÇÇ, fun _ hx => h‚ÇÇ ?_‚ü©‚ü© <;> convert hx\n\n"}
{"name":"Filter.map_const_principal_coprod_map_id_principal","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_6\nŒ≤ : Type u_7\nŒπ : Type u_8\na : Œ±\nb : Œ≤\ni : Œπ\n‚ä¢ Eq ((Filter.map (fun x => b) (Filter.principal (Singleton.singleton a))).coprod (Filter.map id (Filter.principal (Singleton.singleton i)))) (Filter.principal (Union.union (SProd.sprod (Singleton.singleton b) Set.univ) (SProd.sprod Set.univ (Singleton.singleton i))))","decl":"/-- Characterization of the coproduct of the `Filter.map`s of two principal filters `ùìü {a}` and\n`ùìü {i}`, the first under the constant function `fun a => b` and the second under the identity\nfunction. Together with the next lemma, `map_prod_map_const_id_principal_coprod_principal`, this\nprovides an example showing that the inequality in the lemma `map_prod_map_coprod_le` can be strict.\n-/\ntheorem map_const_principal_coprod_map_id_principal {Œ± Œ≤ Œπ : Type*} (a : Œ±) (b : Œ≤) (i : Œπ) :\n    (map (fun _ => b) (ùìü {a})).coprod (map id (ùìü {i})) =\n      ùìü ((({b} : Set Œ≤) √óÀ¢ univ) ‚à™ (univ √óÀ¢ ({i} : Set Œπ))) := by\n  simp only [map_principal, Filter.coprod, comap_principal, sup_principal, image_singleton,\n    image_id, prod_univ, univ_prod, id]\n\n"}
{"name":"Filter.map_prod_map_const_id_principal_coprod_principal","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_6\nŒ≤ : Type u_7\nŒπ : Type u_8\na : Œ±\nb : Œ≤\ni : Œπ\n‚ä¢ Eq (Filter.map (Prod.map (fun x => b) id) ((Filter.principal (Singleton.singleton a)).coprod (Filter.principal (Singleton.singleton i)))) (Filter.principal (SProd.sprod (Singleton.singleton b) Set.univ))","decl":"/-- Characterization of the `Filter.map` of the coproduct of two principal filters `ùìü {a}` and\n`ùìü {i}`, under the `Prod.map` of two functions, respectively the constant function `fun a => b` and\nthe identity function.  Together with the previous lemma,\n`map_const_principal_coprod_map_id_principal`, this provides an example showing that the inequality\nin the lemma `map_prod_map_coprod_le` can be strict. -/\ntheorem map_prod_map_const_id_principal_coprod_principal {Œ± Œ≤ Œπ : Type*} (a : Œ±) (b : Œ≤) (i : Œπ) :\n    map (Prod.map (fun _ : Œ± => b) id) ((ùìü {a}).coprod (ùìü {i})) =\n      ùìü (({b} : Set Œ≤) √óÀ¢ (univ : Set Œπ)) := by\n  rw [principal_coprod_principal, map_principal]\n  congr\n  ext ‚ü®b', i'‚ü©\n  constructor\n  ¬∑ rintro ‚ü®‚ü®a'', i''‚ü©, _, h‚ÇÇ, h‚ÇÉ‚ü©\n    simp\n  ¬∑ rintro ‚ü®h‚ÇÅ, _‚ü©\n    use (a, i')\n    simpa using h‚ÇÅ.symm\n\n"}
{"name":"Filter.Tendsto.prod_map_coprod","module":"Mathlib.Order.Filter.Prod","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\nŒ¥ : Type u_6\nf : Œ± ‚Üí Œ≥\ng : Œ≤ ‚Üí Œ¥\na : Filter Œ±\nb : Filter Œ≤\nc : Filter Œ≥\nd : Filter Œ¥\nhf : Filter.Tendsto f a c\nhg : Filter.Tendsto g b d\n‚ä¢ Filter.Tendsto (Prod.map f g) (a.coprod b) (c.coprod d)","decl":"theorem Tendsto.prod_map_coprod {Œ¥ : Type*} {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ¥} {a : Filter Œ±} {b : Filter Œ≤}\n    {c : Filter Œ≥} {d : Filter Œ¥} (hf : Tendsto f a c) (hg : Tendsto g b d) :\n    Tendsto (Prod.map f g) (a.coprod b) (c.coprod d) :=\n  map_prod_map_coprod_le.trans (coprod_mono hf hg)\n\n"}
