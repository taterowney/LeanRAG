{"name":"LinearEquiv.coe_ofEq_apply","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np q : Submodule R M\nh : Eq p q\nx : Subtype fun x => Membership.mem p x\n⊢ Eq ↑((LinearEquiv.ofEq p q h) x) ↑x","decl":"@[simp]\ntheorem coe_ofEq_apply (h : p = q) (x : p) : (ofEq p q h x : M) = x :=\n  rfl\n\n"}
{"name":"LinearEquiv.ofEq_symm","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np q : Submodule R M\nh : Eq p q\n⊢ Eq (LinearEquiv.ofEq p q h).symm (LinearEquiv.ofEq q p ⋯)","decl":"@[simp]\ntheorem ofEq_symm (h : p = q) : (ofEq p q h).symm = ofEq q p h.symm :=\n  rfl\n\n"}
{"name":"LinearEquiv.ofEq_rfl","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\n⊢ Eq (LinearEquiv.ofEq p p ⋯) (LinearEquiv.refl R (Subtype fun x => Membership.mem p x))","decl":"@[simp]\ntheorem ofEq_rfl : ofEq p p rfl = LinearEquiv.refl R p := by ext; rfl\n\n"}
{"name":"LinearEquiv.ofSubmodules_apply","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝³ : Semiring R\ninst✝² : Semiring R₂\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ne : LinearEquiv σ₁₂ M M₂\np : Submodule R M\nq : Submodule R₂ M₂\nh : Eq (Submodule.map e p) q\nx : Subtype fun x => Membership.mem p x\n⊢ Eq (↑((e.ofSubmodules p q h) x)) (e ↑x)","decl":"@[simp]\ntheorem ofSubmodules_apply {p : Submodule R M} {q : Submodule R₂ M₂} (h : p.map ↑e = q) (x : p) :\n    ↑(e.ofSubmodules p q h x) = e x :=\n  rfl\n\n"}
{"name":"LinearEquiv.ofSubmodules_symm_apply","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝³ : Semiring R\ninst✝² : Semiring R₂\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ne : LinearEquiv σ₁₂ M M₂\np : Submodule R M\nq : Submodule R₂ M₂\nh : Eq (Submodule.map e p) q\nx : Subtype fun x => Membership.mem q x\n⊢ Eq (↑((e.ofSubmodules p q h).symm x)) (e.symm ↑x)","decl":"@[simp]\ntheorem ofSubmodules_symm_apply {p : Submodule R M} {q : Submodule R₂ M₂} (h : p.map ↑e = q)\n    (x : q) : ↑((e.ofSubmodules p q h).symm x) = e.symm x :=\n  rfl\n\n"}
{"name":"LinearEquiv.ofSubmodule'_toLinearMap","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ninst✝¹ : Module R M\ninst✝ : Module R₂ M₂\nf : LinearEquiv σ₁₂ M M₂\nU : Submodule R₂ M₂\n⊢ Eq (↑(f.ofSubmodule' U)) (LinearMap.codRestrict U ((↑f).domRestrict (Submodule.comap (↑f) U)) ⋯)","decl":"theorem ofSubmodule'_toLinearMap [Module R M] [Module R₂ M₂] (f : M ≃ₛₗ[σ₁₂] M₂)\n    (U : Submodule R₂ M₂) :\n    (f.ofSubmodule' U).toLinearMap = (f.toLinearMap.domRestrict _).codRestrict _ Subtype.prop := by\n  ext\n  rfl\n\n"}
{"name":"LinearEquiv.ofSubmodule'_apply","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ninst✝¹ : Module R M\ninst✝ : Module R₂ M₂\nf : LinearEquiv σ₁₂ M M₂\nU : Submodule R₂ M₂\nx : Subtype fun x => Membership.mem (Submodule.comap (↑f) U) x\n⊢ Eq (↑((f.ofSubmodule' U) x)) (f ↑x)","decl":"@[simp]\ntheorem ofSubmodule'_apply [Module R M] [Module R₂ M₂] (f : M ≃ₛₗ[σ₁₂] M₂) (U : Submodule R₂ M₂)\n    (x : U.comap (f : M →ₛₗ[σ₁₂] M₂)) : (f.ofSubmodule' U x : M₂) = f (x : M) :=\n  rfl\n\n"}
{"name":"LinearEquiv.ofSubmodule'_symm_apply","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ninst✝¹ : Module R M\ninst✝ : Module R₂ M₂\nf : LinearEquiv σ₁₂ M M₂\nU : Submodule R₂ M₂\nx : Subtype fun x => Membership.mem U x\n⊢ Eq (↑((f.ofSubmodule' U).symm x)) (f.symm ↑x)","decl":"@[simp]\ntheorem ofSubmodule'_symm_apply [Module R M] [Module R₂ M₂] (f : M ≃ₛₗ[σ₁₂] M₂)\n    (U : Submodule R₂ M₂) (x : U) : ((f.ofSubmodule' U).symm x : M) = f.symm (x : M₂) :=\n  rfl\n\n"}
{"name":"LinearEquiv.ofTop_apply","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nh : Eq p Top.top\nx : Subtype fun x => Membership.mem p x\n⊢ Eq ((LinearEquiv.ofTop p h) x) ↑x","decl":"@[simp]\ntheorem ofTop_apply {h} (x : p) : ofTop p h x = x :=\n  rfl\n\n"}
{"name":"LinearEquiv.coe_ofTop_symm_apply","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nh : Eq p Top.top\nx : M\n⊢ Eq (↑((LinearEquiv.ofTop p h).symm x)) x","decl":"@[simp]\ntheorem coe_ofTop_symm_apply {h} (x : M) : ((ofTop p h).symm x : M) = x :=\n  rfl\n\n"}
{"name":"LinearEquiv.ofTop_symm_apply","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝¹ : Semiring R\ninst✝ : AddCommMonoid M\nmodule_M : Module R M\np : Submodule R M\nh : Eq p Top.top\nx : M\n⊢ Eq ((LinearEquiv.ofTop p h).symm x) ⟨x, ⋯⟩","decl":"theorem ofTop_symm_apply {h} (x : M) : (ofTop p h).symm x = ⟨x, h.symm ▸ trivial⟩ :=\n  rfl\n\n"}
{"name":"LinearEquiv.range","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝³ : Semiring R\ninst✝² : Semiring R₂\ninst✝¹ : AddCommMonoid M\ninst✝ : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ne : LinearEquiv σ₁₂ M M₂\n⊢ Eq (LinearMap.range ↑e) Top.top","decl":"@[simp]\nprotected theorem range : LinearMap.range (e : M →ₛₗ[σ₁₂] M₂) = ⊤ :=\n  LinearMap.range_eq_top.2 e.toEquiv.surjective\n\n"}
{"name":"LinearEquivClass.range","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : Semiring R₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ninst✝³ : Module R M\ninst✝² : Module R₂ M₂\nF : Type u_10\ninst✝¹ : EquivLike F M M₂\ninst✝ : SemilinearEquivClass F σ₁₂ M M₂\ne : F\n⊢ Eq (LinearMap.range e) Top.top","decl":"@[simp]\nprotected theorem _root_.LinearEquivClass.range [Module R M] [Module R₂ M₂] {F : Type*}\n    [EquivLike F M M₂] [SemilinearEquivClass F σ₁₂ M M₂] (e : F) : LinearMap.range e = ⊤ :=\n  LinearMap.range_eq_top.2 (EquivLike.surjective e)\n\n"}
{"name":"LinearEquiv.eq_bot_of_equiv","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁴ : Semiring R\ninst✝³ : Semiring R₂\ninst✝² : AddCommMonoid M\ninst✝¹ : AddCommMonoid M₂\nmodule_M : Module R M\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\np : Submodule R M\ninst✝ : Module R₂ M₂\ne : LinearEquiv σ₁₂ (Subtype fun x => Membership.mem p x) (Subtype fun x => Membership.mem Bot.bot x)\n⊢ Eq p Bot.bot","decl":"theorem eq_bot_of_equiv [Module R₂ M₂] (e : p ≃ₛₗ[σ₁₂] (⊥ : Submodule R₂ M₂)) : p = ⊥ := by\n  refine bot_unique (SetLike.le_def.2 fun b hb => (Submodule.mem_bot R).2 ?_)\n  rw [← p.mk_eq_zero hb, ← e.map_eq_zero_iff]\n  apply Submodule.eq_zero_of_bot_submodule\n\n-- Porting note: `RingHomSurjective σ₁₂` is an unused argument.\n"}
{"name":"LinearEquiv.range_comp","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nR₂ : Type u_3\nR₃ : Type u_4\nM : Type u_5\nM₂ : Type u_7\nM₃ : Type u_8\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring R₂\ninst✝⁶ : Semiring R₃\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\nmodule_M : Module R M\nmodule_M₂ : Module R₂ M₂\nmodule_M₃ : Module R₃ M₃\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nσ₂₃ : RingHom R₂ R₃\nσ₁₃ : RingHom R R₃\ninst✝² : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\nre₁₂ : RingHomInvPair σ₁₂ σ₂₁\nre₂₁ : RingHomInvPair σ₂₁ σ₁₂\ne : LinearEquiv σ₁₂ M M₂\nh : LinearMap σ₂₃ M₂ M₃\ninst✝¹ : RingHomSurjective σ₂₃\ninst✝ : RingHomSurjective σ₁₃\n⊢ Eq (LinearMap.range (h.comp ↑e)) (LinearMap.range h)","decl":"@[simp]\ntheorem range_comp [RingHomSurjective σ₂₃] [RingHomSurjective σ₁₃] :\n    LinearMap.range (h.comp (e : M →ₛₗ[σ₁₂] M₂) : M →ₛₗ[σ₁₃] M₃) = LinearMap.range h :=\n  LinearMap.range_comp_of_range_eq_top _ e.range\n\n"}
{"name":"LinearEquiv.ofLeftInverse_apply","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nf : LinearMap σ₁₂ M M₂\ng : LinearMap σ₂₁ M₂ M\ninst✝¹ : RingHomInvPair σ₁₂ σ₂₁\ninst✝ : RingHomInvPair σ₂₁ σ₁₂\nh : Function.LeftInverse ⇑g ⇑f\nx : M\n⊢ Eq (↑((LinearEquiv.ofLeftInverse h) x)) (f x)","decl":"@[simp]\ntheorem ofLeftInverse_apply [RingHomInvPair σ₁₂ σ₂₁] [RingHomInvPair σ₂₁ σ₁₂]\n    (h : Function.LeftInverse g f) (x : M) : ↑(ofLeftInverse h x) = f x :=\n  rfl\n\n"}
{"name":"LinearEquiv.ofLeftInverse_symm_apply","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nf : LinearMap σ₁₂ M M₂\ng : LinearMap σ₂₁ M₂ M\ninst✝¹ : RingHomInvPair σ₁₂ σ₂₁\ninst✝ : RingHomInvPair σ₂₁ σ₁₂\nh : Function.LeftInverse ⇑g ⇑f\nx : Subtype fun x => Membership.mem (LinearMap.range f) x\n⊢ Eq ((LinearEquiv.ofLeftInverse h).symm x) (g ↑x)","decl":"@[simp]\ntheorem ofLeftInverse_symm_apply [RingHomInvPair σ₁₂ σ₂₁] [RingHomInvPair σ₂₁ σ₁₂]\n    (h : Function.LeftInverse g f) (x : LinearMap.range f) : (ofLeftInverse h).symm x = g x :=\n  rfl\n\n"}
{"name":"LinearEquiv.ofInjective_apply","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nf : LinearMap σ₁₂ M M₂\ninst✝¹ : RingHomInvPair σ₁₂ σ₂₁\ninst✝ : RingHomInvPair σ₂₁ σ₁₂\nh : Function.Injective ⇑f\nx : M\n⊢ Eq (↑((LinearEquiv.ofInjective f h) x)) (f x)","decl":"@[simp]\ntheorem ofInjective_apply [RingHomInvPair σ₁₂ σ₂₁] [RingHomInvPair σ₂₁ σ₁₂] {h : Injective f}\n    (x : M) : ↑(ofInjective f h x) = f x :=\n  rfl\n\n"}
{"name":"LinearEquiv.ofInjective_symm_apply","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nf : LinearMap σ₁₂ M M₂\ninst✝¹ : RingHomInvPair σ₁₂ σ₂₁\ninst✝ : RingHomInvPair σ₂₁ σ₁₂\nh : Function.Injective ⇑f\nx : Subtype fun x => Membership.mem (LinearMap.range f) x\n⊢ Eq (f ((LinearEquiv.ofInjective f h).symm x)) ↑x","decl":"@[simp]\nlemma ofInjective_symm_apply [RingHomInvPair σ₁₂ σ₂₁] [RingHomInvPair σ₂₁ σ₁₂] {h : Injective f}\n    (x : LinearMap.range f) :\n    f ((ofInjective f h).symm x) = x := by\n  obtain ⟨-, ⟨y, rfl⟩⟩ := x\n  have : ⟨f y, LinearMap.mem_range_self f y⟩ = LinearEquiv.ofInjective f h y := rfl\n  simp [this]\n\n"}
{"name":"LinearEquiv.ofBijective_apply","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nf : LinearMap σ₁₂ M M₂\ninst✝¹ : RingHomInvPair σ₁₂ σ₂₁\ninst✝ : RingHomInvPair σ₂₁ σ₁₂\nhf : Function.Bijective ⇑f\nx : M\n⊢ Eq ((LinearEquiv.ofBijective f hf) x) (f x)","decl":"@[simp]\ntheorem ofBijective_apply [RingHomInvPair σ₁₂ σ₂₁] [RingHomInvPair σ₂₁ σ₁₂] {hf} (x : M) :\n    ofBijective f hf x = f x :=\n  rfl\n\n"}
{"name":"LinearEquiv.ofBijective_symm_apply_apply","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nf : LinearMap σ₁₂ M M₂\ninst✝¹ : RingHomInvPair σ₁₂ σ₂₁\ninst✝ : RingHomInvPair σ₂₁ σ₁₂\nh : Function.Bijective ⇑f\nx : M\n⊢ Eq ((LinearEquiv.ofBijective f h).symm (f x)) x","decl":"@[simp]\ntheorem ofBijective_symm_apply_apply [RingHomInvPair σ₁₂ σ₂₁] [RingHomInvPair σ₂₁ σ₁₂] {h} (x : M) :\n    (ofBijective f h).symm (f x) = x := by\n  simp [LinearEquiv.symm_apply_eq]\n\n"}
{"name":"LinearEquiv.apply_ofBijective_symm_apply","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nR₂ : Type u_3\nM : Type u_5\nM₂ : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : Semiring R₂\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\nmodule_M : Module R M\nmodule_M₂ : Module R₂ M₂\nσ₁₂ : RingHom R R₂\nσ₂₁ : RingHom R₂ R\nf : LinearMap σ₁₂ M M₂\ninst✝¹ : RingHomInvPair σ₁₂ σ₂₁\ninst✝ : RingHomInvPair σ₂₁ σ₁₂\nh : Function.Bijective ⇑f\nx : M₂\n⊢ Eq (f ((LinearEquiv.ofBijective f h).symm x)) x","decl":"@[simp]\ntheorem apply_ofBijective_symm_apply [RingHomInvPair σ₁₂ σ₂₁] [RingHomInvPair σ₂₁ σ₁₂] {h}\n    (x : M₂) : f ((ofBijective f h).symm x) = x := by\n  rw [← ofBijective_apply f ((ofBijective f h).symm x), apply_symm_apply]\n\n"}
{"name":"Submodule.equivSubtypeMap_apply","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\nq : Submodule R (Subtype fun x => Membership.mem p x)\nx : Subtype fun x => Membership.mem q x\n⊢ Eq (↑((p.equivSubtypeMap q) x)) ((p.subtype.domRestrict q) x)","decl":"@[simp]\ntheorem equivSubtypeMap_apply {p : Submodule R M} {q : Submodule R p} (x : q) :\n    (p.equivSubtypeMap q x : M) = p.subtype.domRestrict q x :=\n  rfl\n\n"}
{"name":"Submodule.equivSubtypeMap_symm_apply","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Submodule R M\nq : Submodule R (Subtype fun x => Membership.mem p x)\nx : Subtype fun x => Membership.mem (Submodule.map p.subtype q) x\n⊢ Eq ↑↑((p.equivSubtypeMap q).symm x) ↑x","decl":"@[simp]\ntheorem equivSubtypeMap_symm_apply {p : Submodule R M} {q : Submodule R p} (x : q.map p.subtype) :\n    ((p.equivSubtypeMap q).symm x : M) = x := by\n  cases x\n  rfl\n\n"}
{"name":"Submodule.comap_equiv_self_of_inj_of_le_apply","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nM : Type u_5\nN : Type u_9\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nf : LinearMap (RingHom.id R) M N\np : Submodule R N\nhf : Function.Injective ⇑f\nh : LE.le p (LinearMap.range f)\na✝ : Subtype fun x => Membership.mem (Submodule.comap f p) x\n⊢ Eq ((Submodule.comap_equiv_self_of_inj_of_le hf h) a✝) ((LinearMap.codRestrict p (f.comp (Submodule.comap f p).subtype) ⋯) a✝)","decl":"/-- A linear injection `M ↪ N` restricts to an equivalence `f⁻¹ p ≃ p` for any submodule `p`\ncontained in its range. -/\n@[simps! apply]\nnoncomputable def comap_equiv_self_of_inj_of_le {f : M →ₗ[R] N} {p : Submodule R N}\n    (hf : Injective f) (h : p ≤ LinearMap.range f) :\n    p.comap f ≃ₗ[R] p :=\n  LinearEquiv.ofBijective\n  ((f ∘ₗ (p.comap f).subtype).codRestrict p <| fun ⟨_, hx⟩ ↦ mem_comap.mp hx)\n  (⟨fun x y hxy ↦ by simpa using hf (Subtype.ext_iff.mp hxy),\n    fun ⟨x, hx⟩ ↦ by obtain ⟨y, rfl⟩ := h hx; exact ⟨⟨y, hx⟩, by simp [Subtype.ext_iff]⟩⟩)\n\n"}
{"name":"LinearMap.codRestrictOfInjective_comp_apply","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nM₁ : Type u_6\nM₂ : Type u_7\nM₃ : Type u_8\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M₁ M₂\ni : LinearMap (RingHom.id R) M₃ M₂\nhi : Function.Injective ⇑i\nhf : ∀ (x : M₁), Membership.mem (LinearMap.range i) (f x)\nx : M₁\n⊢ Eq (i ((f.codRestrictOfInjective i hi hf) x)) (f x)","decl":"@[simp]\nlemma codRestrictOfInjective_comp_apply (x : M₁) :\n    i (LinearMap.codRestrictOfInjective f i hi hf x) = f x := by\n  simp [LinearMap.codRestrictOfInjective]\n\n"}
{"name":"LinearMap.codRestrictOfInjective_comp","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nM₁ : Type u_6\nM₂ : Type u_7\nM₃ : Type u_8\ninst✝⁶ : CommSemiring R\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M₁ M₂\ni : LinearMap (RingHom.id R) M₃ M₂\nhi : Function.Injective ⇑i\nhf : ∀ (x : M₁), Membership.mem (LinearMap.range i) (f x)\n⊢ Eq (i.comp (f.codRestrictOfInjective i hi hf)) f","decl":"@[simp]\nlemma codRestrictOfInjective_comp :\n    i ∘ₗ LinearMap.codRestrictOfInjective f i hi hf = f := by\n  ext\n  simp\n\n"}
{"name":"LinearMap.codRestrict₂_apply","module":"Mathlib.Algebra.Module.Submodule.Equiv","initialProofState":"R : Type u_1\nM : Type u_5\nM₁ : Type u_6\nM₂ : Type u_7\nM₃ : Type u_8\ninst✝⁸ : CommSemiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid M₁\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : AddCommMonoid M₃\ninst✝³ : Module R M\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R M₃\nf : LinearMap (RingHom.id R) M₁ (LinearMap (RingHom.id R) M₂ M)\ni : LinearMap (RingHom.id R) M₃ M\nhi : Function.Injective ⇑i\nhf : ∀ (x : M₁) (y : M₂), Membership.mem (LinearMap.range i) ((f x) y)\nx : M₁\ny : M₂\n⊢ Eq (i (((f.codRestrict₂ i hi hf) x) y)) ((f x) y)","decl":"@[simp]\nlemma codRestrict₂_apply (x : M₁) (y : M₂) :\n    i (codRestrict₂ f i hi hf x y) = f x y := by\n  simp [codRestrict₂]\n\n"}
