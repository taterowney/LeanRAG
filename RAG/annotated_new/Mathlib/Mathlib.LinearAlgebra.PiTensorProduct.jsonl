{"name":"PiTensorProduct.zero_tprodCoeff","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\nf : (i : ι) → s i\n⊢ Eq (PiTensorProduct.tprodCoeff R 0 f) 0","decl":"theorem zero_tprodCoeff (f : Π i, s i) : tprodCoeff R 0 f = 0 :=\n  Quotient.sound' <| AddConGen.Rel.of _ _ <| Eqv.of_zero_scalar _\n\n"}
{"name":"PiTensorProduct.zero_tprodCoeff'","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\nz : R\nf : (i : ι) → s i\ni : ι\nhf : Eq (f i) 0\n⊢ Eq (PiTensorProduct.tprodCoeff R z f) 0","decl":"theorem zero_tprodCoeff' (z : R) (f : Π i, s i) (i : ι) (hf : f i = 0) : tprodCoeff R z f = 0 :=\n  Quotient.sound' <| AddConGen.Rel.of _ _ <| Eqv.of_zero _ _ i hf\n\n"}
{"name":"PiTensorProduct.add_tprodCoeff","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝³ : CommSemiring R\ns : ι → Type u_7\ninst✝² : (i : ι) → AddCommMonoid (s i)\ninst✝¹ : (i : ι) → Module R (s i)\ninst✝ : DecidableEq ι\nz : R\nf : (i : ι) → s i\ni : ι\nm₁ m₂ : s i\n⊢ Eq (HAdd.hAdd (PiTensorProduct.tprodCoeff R z (Function.update f i m₁)) (PiTensorProduct.tprodCoeff R z (Function.update f i m₂))) (PiTensorProduct.tprodCoeff R z (Function.update f i (HAdd.hAdd m₁ m₂)))","decl":"theorem add_tprodCoeff [DecidableEq ι] (z : R) (f : Π i, s i) (i : ι) (m₁ m₂ : s i) :\n    tprodCoeff R z (update f i m₁) + tprodCoeff R z (update f i m₂) =\n      tprodCoeff R z (update f i (m₁ + m₂)) :=\n  Quotient.sound' <| AddConGen.Rel.of _ _ (Eqv.of_add _ z f i m₁ m₂)\n\n"}
{"name":"PiTensorProduct.add_tprodCoeff'","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\nz₁ z₂ : R\nf : (i : ι) → s i\n⊢ Eq (HAdd.hAdd (PiTensorProduct.tprodCoeff R z₁ f) (PiTensorProduct.tprodCoeff R z₂ f)) (PiTensorProduct.tprodCoeff R (HAdd.hAdd z₁ z₂) f)","decl":"theorem add_tprodCoeff' (z₁ z₂ : R) (f : Π i, s i) :\n    tprodCoeff R z₁ f + tprodCoeff R z₂ f = tprodCoeff R (z₁ + z₂) f :=\n  Quotient.sound' <| AddConGen.Rel.of _ _ (Eqv.of_add_scalar z₁ z₂ f)\n\n"}
{"name":"PiTensorProduct.smul_tprodCoeff_aux","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝³ : CommSemiring R\ns : ι → Type u_7\ninst✝² : (i : ι) → AddCommMonoid (s i)\ninst✝¹ : (i : ι) → Module R (s i)\ninst✝ : DecidableEq ι\nz : R\nf : (i : ι) → s i\ni : ι\nr : R\n⊢ Eq (PiTensorProduct.tprodCoeff R z (Function.update f i (HSMul.hSMul r (f i)))) (PiTensorProduct.tprodCoeff R (HMul.hMul r z) f)","decl":"theorem smul_tprodCoeff_aux [DecidableEq ι] (z : R) (f : Π i, s i) (i : ι) (r : R) :\n    tprodCoeff R z (update f i (r • f i)) = tprodCoeff R (r * z) f :=\n  Quotient.sound' <| AddConGen.Rel.of _ _ <| Eqv.of_smul _ _ _ _ _\n\n"}
{"name":"PiTensorProduct.smul_tprodCoeff","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁷ : CommSemiring R\nR₁ : Type u_5\ns : ι → Type u_7\ninst✝⁶ : (i : ι) → AddCommMonoid (s i)\ninst✝⁵ : (i : ι) → Module R (s i)\ninst✝⁴ : DecidableEq ι\nz : R\nf : (i : ι) → s i\ni : ι\nr : R₁\ninst✝³ : SMul R₁ R\ninst✝² : IsScalarTower R₁ R R\ninst✝¹ : SMul R₁ (s i)\ninst✝ : IsScalarTower R₁ R (s i)\n⊢ Eq (PiTensorProduct.tprodCoeff R z (Function.update f i (HSMul.hSMul r (f i)))) (PiTensorProduct.tprodCoeff R (HSMul.hSMul r z) f)","decl":"theorem smul_tprodCoeff [DecidableEq ι] (z : R) (f : Π i, s i) (i : ι) (r : R₁) [SMul R₁ R]\n    [IsScalarTower R₁ R R] [SMul R₁ (s i)] [IsScalarTower R₁ R (s i)] :\n    tprodCoeff R z (update f i (r • f i)) = tprodCoeff R (r • z) f := by\n  have h₁ : r • z = r • (1 : R) * z := by rw [smul_mul_assoc, one_mul]\n  have h₂ : r • f i = (r • (1 : R)) • f i := (smul_one_smul _ _ _).symm\n  rw [h₁, h₂]\n  exact smul_tprodCoeff_aux z f i _\n\n"}
{"name":"PiTensorProduct.induction_on'","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\nmotive : (PiTensorProduct R fun i => s i) → Prop\nz : PiTensorProduct R fun i => s i\ntprodCoeff : ∀ (r : R) (f : (i : ι) → s i), motive (PiTensorProduct.tprodCoeff R r f)\nadd : ∀ (x y : PiTensorProduct R fun i => s i), motive x → motive y → motive (HAdd.hAdd x y)\n⊢ motive z","decl":"/-- Induct using `tprodCoeff` -/\n@[elab_as_elim]\nprotected theorem induction_on' {motive : (⨂[R] i, s i) → Prop} (z : ⨂[R] i, s i)\n    (tprodCoeff : ∀ (r : R) (f : Π i, s i), motive (tprodCoeff R r f))\n    (add : ∀ x y, motive x → motive y → motive (x + y)) :\n    motive z := by\n  have C0 : motive 0 := by\n    have h₁ := tprodCoeff 0 0\n    rwa [zero_tprodCoeff] at h₁\n  refine AddCon.induction_on z fun x ↦ FreeAddMonoid.recOn x C0 ?_\n  simp_rw [AddCon.coe_add]\n  refine fun f y ih ↦ add _ _ ?_ ih\n  convert tprodCoeff f.1 f.2\n\n"}
{"name":"PiTensorProduct.smul_tprodCoeff'","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁵ : CommSemiring R\nR₁ : Type u_5\ns : ι → Type u_7\ninst✝⁴ : (i : ι) → AddCommMonoid (s i)\ninst✝³ : (i : ι) → Module R (s i)\ninst✝² : Monoid R₁\ninst✝¹ : DistribMulAction R₁ R\ninst✝ : SMulCommClass R₁ R R\nr : R₁\nz : R\nf : (i : ι) → s i\n⊢ Eq (HSMul.hSMul r (PiTensorProduct.tprodCoeff R z f)) (PiTensorProduct.tprodCoeff R (HSMul.hSMul r z) f)","decl":"theorem smul_tprodCoeff' (r : R₁) (z : R) (f : Π i, s i) :\n    r • tprodCoeff R z f = tprodCoeff R (r • z) f := rfl\n\n"}
{"name":"PiTensorProduct.smul_add","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁵ : CommSemiring R\nR₁ : Type u_5\ns : ι → Type u_7\ninst✝⁴ : (i : ι) → AddCommMonoid (s i)\ninst✝³ : (i : ι) → Module R (s i)\ninst✝² : Monoid R₁\ninst✝¹ : DistribMulAction R₁ R\ninst✝ : SMulCommClass R₁ R R\nr : R₁\nx y : PiTensorProduct R fun i => s i\n⊢ Eq (HSMul.hSMul r (HAdd.hAdd x y)) (HAdd.hAdd (HSMul.hSMul r x) (HSMul.hSMul r y))","decl":"protected theorem smul_add (r : R₁) (x y : ⨂[R] i, s i) : r • (x + y) = r • x + r • y :=\n  AddMonoidHom.map_add _ _ _\n\n"}
{"name":"PiTensorProduct.smulCommClass'","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁷ : CommSemiring R\nR₁ : Type u_5\nR₂ : Type u_6\ns : ι → Type u_7\ninst✝⁶ : (i : ι) → AddCommMonoid (s i)\ninst✝⁵ : (i : ι) → Module R (s i)\ninst✝⁴ : Monoid R₁\ninst✝³ : DistribMulAction R₁ R\ninst✝² : Monoid R₂\ninst✝¹ : DistribMulAction R₂ R\ninst✝ : SMulCommClass R₁ R₂ R\n⊢ SMulCommClass R₁ R₂ (PiTensorProduct R fun i => s i)","decl":"instance smulCommClass' [SMulCommClass R₁ R₂ R] : SMulCommClass R₁ R₂ (⨂[R] i, s i) :=\n  ⟨fun {r' r''} x ↦\n    PiTensorProduct.induction_on' x (fun {xr xf} ↦ by simp only [smul_tprodCoeff', smul_comm])\n      fun {z y} ihz ihy ↦ by simp_rw [PiTensorProduct.smul_add, ihz, ihy]⟩\n\n"}
{"name":"PiTensorProduct.isScalarTower'","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁸ : CommSemiring R\nR₁ : Type u_5\nR₂ : Type u_6\ns : ι → Type u_7\ninst✝⁷ : (i : ι) → AddCommMonoid (s i)\ninst✝⁶ : (i : ι) → Module R (s i)\ninst✝⁵ : Monoid R₁\ninst✝⁴ : DistribMulAction R₁ R\ninst✝³ : Monoid R₂\ninst✝² : DistribMulAction R₂ R\ninst✝¹ : SMul R₁ R₂\ninst✝ : IsScalarTower R₁ R₂ R\n⊢ IsScalarTower R₁ R₂ (PiTensorProduct R fun i => s i)","decl":"instance isScalarTower' [SMul R₁ R₂] [IsScalarTower R₁ R₂ R] :\n    IsScalarTower R₁ R₂ (⨂[R] i, s i) :=\n  ⟨fun {r' r''} x ↦\n    PiTensorProduct.induction_on' x (fun {xr xf} ↦ by simp only [smul_tprodCoeff', smul_assoc])\n      fun {z y} ihz ihy ↦ by simp_rw [PiTensorProduct.smul_add, ihz, ihy]⟩\n\n"}
{"name":"PiTensorProduct.instSMulCommClass","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\n⊢ SMulCommClass R R (PiTensorProduct R fun i => s i)","decl":"instance : SMulCommClass R R (⨂[R] i, s i) :=\n  PiTensorProduct.smulCommClass'\n\n"}
{"name":"PiTensorProduct.instIsScalarTower","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\n⊢ IsScalarTower R R (PiTensorProduct R fun i => s i)","decl":"instance : IsScalarTower R R (⨂[R] i, s i) :=\n  PiTensorProduct.isScalarTower'\n\n"}
{"name":"PiTensorProduct.tprod_eq_tprodCoeff_one","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\n⊢ Eq (⇑(PiTensorProduct.tprod R)) (PiTensorProduct.tprodCoeff R 1)","decl":"theorem tprod_eq_tprodCoeff_one :\n    ⇑(tprod R : MultilinearMap R s (⨂[R] i, s i)) = tprodCoeff R 1 := rfl\n\n"}
{"name":"PiTensorProduct.tprodCoeff_eq_smul_tprod","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\nz : R\nf : (i : ι) → s i\n⊢ Eq (PiTensorProduct.tprodCoeff R z f) (HSMul.hSMul z ((PiTensorProduct.tprod R) f))","decl":"@[simp]\ntheorem tprodCoeff_eq_smul_tprod (z : R) (f : Π i, s i) : tprodCoeff R z f = z • tprod R f := by\n  have : z = z • (1 : R) := by simp only [mul_one, Algebra.id.smul_eq_mul]\n  conv_lhs => rw [this]\n  rfl\n\n"}
{"name":"FreeAddMonoid.toPiTensorProduct","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\np : FreeAddMonoid (Prod R ((i : ι) → s i))\n⊢ Eq (↑p) (List.map (fun x => HSMul.hSMul x.1 ((PiTensorProduct.tprod R) fun i => x.2 i)) p).sum","decl":"/-- The image of an element `p` of `FreeAddMonoid (R × Π i, s i)` in the `PiTensorProduct` is\nequal to the sum of `a • ⨂ₜ[R] i, m i` over all the entries `(a, m)` of `p`.\n-/\nlemma _root_.FreeAddMonoid.toPiTensorProduct (p : FreeAddMonoid (R × Π i, s i)) :\n    AddCon.toQuotient (c := addConGen (PiTensorProduct.Eqv R s)) p =\n    List.sum (List.map (fun x ↦ x.1 • ⨂ₜ[R] i, x.2 i) p) := by\n  match p with\n  | [] => rw [List.map_nil, List.sum_nil]; rfl\n  | x :: ps => rw [List.map_cons, List.sum_cons, ← List.singleton_append, ← toPiTensorProduct ps,\n                 ← tprodCoeff_eq_smul_tprod]; rfl\n\n"}
{"name":"PiTensorProduct.mem_lifts_iff","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\nx : PiTensorProduct R fun i => s i\np : FreeAddMonoid (Prod R ((i : ι) → s i))\n⊢ Iff (Membership.mem x.lifts p) (Eq (List.map (fun x => HSMul.hSMul x.1 ((PiTensorProduct.tprod R) fun i => x.2 i)) p).sum x)","decl":"/-- An element `p` of `FreeAddMonoid (R × Π i, s i)` lifts an element `x` of `⨂[R] i, s i`\nif and only if `x` is equal to the sum of `a • ⨂ₜ[R] i, m i` over all the entries\n`(a, m)` of `p`.\n-/\nlemma mem_lifts_iff (x : ⨂[R] i, s i) (p : FreeAddMonoid (R × Π i, s i)) :\n    p ∈ lifts x ↔ List.sum (List.map (fun x ↦ x.1 • ⨂ₜ[R] i, x.2 i) p) = x := by\n  simp only [lifts, Set.mem_setOf_eq, FreeAddMonoid.toPiTensorProduct]\n\n"}
{"name":"PiTensorProduct.nonempty_lifts","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\nx : PiTensorProduct R fun i => s i\n⊢ x.lifts.Nonempty","decl":"/-- Every element of `⨂[R] i, s i` has a lift in `FreeAddMonoid (R × Π i, s i)`.\n-/\nlemma nonempty_lifts (x : ⨂[R] i, s i) : Set.Nonempty (lifts x) := by\n  existsi @Quotient.out _ (addConGen (PiTensorProduct.Eqv R s)).toSetoid x\n  simp only [lifts, Set.mem_setOf_eq]\n  rw [← AddCon.quot_mk_eq_coe]\n  erw [Quot.out_eq]\n\n"}
{"name":"PiTensorProduct.lifts_zero","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\n⊢ Membership.mem (PiTensorProduct.lifts 0) 0","decl":"/-- The empty list lifts the element `0` of `⨂[R] i, s i`.\n-/\nlemma lifts_zero : 0 ∈ lifts (0 : ⨂[R] i, s i) := by\n  rw [mem_lifts_iff]; erw [List.map_nil]; rw [List.sum_nil]\n\n"}
{"name":"PiTensorProduct.lifts_add","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\nx y : PiTensorProduct R fun i => s i\np q : FreeAddMonoid (Prod R ((i : ι) → s i))\nhp : Membership.mem x.lifts p\nhq : Membership.mem y.lifts q\n⊢ Membership.mem (HAdd.hAdd x y).lifts (HAdd.hAdd p q)","decl":"/-- If elements `p,q` of `FreeAddMonoid (R × Π i, s i)` lift elements `x,y` of `⨂[R] i, s i`\nrespectively, then `p + q` lifts `x + y`.\n-/\nlemma lifts_add {x y : ⨂[R] i, s i} {p q : FreeAddMonoid (R × Π i, s i)}\n    (hp : p ∈ lifts x) (hq : q ∈ lifts y) : p + q ∈ lifts (x + y) := by\n  simp only [lifts, Set.mem_setOf_eq, AddCon.coe_add]\n  rw [hp, hq]\n\n"}
{"name":"PiTensorProduct.lifts_smul","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\nx : PiTensorProduct R fun i => s i\np : FreeAddMonoid (Prod R ((i : ι) → s i))\nh : Membership.mem x.lifts p\na : R\n⊢ Membership.mem (HSMul.hSMul a x).lifts (List.map (fun y => { fst := HMul.hMul a y.1, snd := y.2 }) p)","decl":"/-- If an element `p` of `FreeAddMonoid (R × Π i, s i)` lifts an element `x` of `⨂[R] i, s i`,\nand if `a` is an element of `R`, then the list obtained by multiplying the first entry of each\nelement of `p` by `a` lifts `a • x`.\n-/\nlemma lifts_smul {x : ⨂[R] i, s i} {p : FreeAddMonoid (R × Π i, s i)} (h : p ∈ lifts x) (a : R) :\n    List.map (fun (y : R × Π i, s i) ↦ (a * y.1, y.2)) p ∈ lifts (a • x) := by\n  rw [mem_lifts_iff] at h ⊢\n  rw [← List.comp_map, ← h, List.smul_sum, ← List.comp_map]\n  congr 2\n  ext _\n  simp only [comp_apply, smul_smul]\n\n"}
{"name":"PiTensorProduct.induction_on","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\nmotive : (PiTensorProduct R fun i => s i) → Prop\nz : PiTensorProduct R fun i => s i\nsmul_tprod : ∀ (r : R) (f : (i : ι) → s i), motive (HSMul.hSMul r ((PiTensorProduct.tprod R) f))\nadd : ∀ (x y : PiTensorProduct R fun i => s i), motive x → motive y → motive (HAdd.hAdd x y)\n⊢ motive z","decl":"/-- Induct using scaled versions of `PiTensorProduct.tprod`. -/\n@[elab_as_elim]\nprotected theorem induction_on {motive : (⨂[R] i, s i) → Prop} (z : ⨂[R] i, s i)\n    (smul_tprod : ∀ (r : R) (f : Π i, s i), motive (r • tprod R f))\n    (add : ∀ x y, motive x → motive y → motive (x + y)) :\n    motive z := by\n  simp_rw [← tprodCoeff_eq_smul_tprod] at smul_tprod\n  exact PiTensorProduct.induction_on' z smul_tprod add\n\n"}
{"name":"PiTensorProduct.ext_iff","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nE : Type u_9\ninst✝¹ : AddCommMonoid E\ninst✝ : Module R E\nφ₁ φ₂ : LinearMap (RingHom.id R) (PiTensorProduct R fun i => s i) E\n⊢ Iff (Eq φ₁ φ₂) (Eq (φ₁.compMultilinearMap (PiTensorProduct.tprod R)) (φ₂.compMultilinearMap (PiTensorProduct.tprod R)))","decl":"@[ext]\ntheorem ext {φ₁ φ₂ : (⨂[R] i, s i) →ₗ[R] E}\n    (H : φ₁.compMultilinearMap (tprod R) = φ₂.compMultilinearMap (tprod R)) : φ₁ = φ₂ := by\n  refine LinearMap.ext ?_\n  refine fun z ↦\n    PiTensorProduct.induction_on' z ?_ fun {x y} hx hy ↦ by rw [φ₁.map_add, φ₂.map_add, hx, hy]\n  · intro r f\n    rw [tprodCoeff_eq_smul_tprod, φ₁.map_smul, φ₂.map_smul]\n    apply congr_arg\n    exact MultilinearMap.congr_fun H f\n\n"}
{"name":"PiTensorProduct.ext","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nE : Type u_9\ninst✝¹ : AddCommMonoid E\ninst✝ : Module R E\nφ₁ φ₂ : LinearMap (RingHom.id R) (PiTensorProduct R fun i => s i) E\nH : Eq (φ₁.compMultilinearMap (PiTensorProduct.tprod R)) (φ₂.compMultilinearMap (PiTensorProduct.tprod R))\n⊢ Eq φ₁ φ₂","decl":"@[ext]\ntheorem ext {φ₁ φ₂ : (⨂[R] i, s i) →ₗ[R] E}\n    (H : φ₁.compMultilinearMap (tprod R) = φ₂.compMultilinearMap (tprod R)) : φ₁ = φ₂ := by\n  refine LinearMap.ext ?_\n  refine fun z ↦\n    PiTensorProduct.induction_on' z ?_ fun {x y} hx hy ↦ by rw [φ₁.map_add, φ₂.map_add, hx, hy]\n  · intro r f\n    rw [tprodCoeff_eq_smul_tprod, φ₁.map_smul, φ₂.map_smul]\n    apply congr_arg\n    exact MultilinearMap.congr_fun H f\n\n"}
{"name":"PiTensorProduct.span_tprod_eq_top","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\n⊢ Eq (Submodule.span R (Set.range ⇑(PiTensorProduct.tprod R))) Top.top","decl":"/-- The pure tensors (i.e. the elements of the image of `PiTensorProduct.tprod`) span\nthe tensor product. -/\ntheorem span_tprod_eq_top :\n    Submodule.span R (Set.range (tprod R)) = (⊤ : Submodule R (⨂[R] i, s i)) :=\n  Submodule.eq_top_iff'.mpr fun t ↦ t.induction_on\n    (fun _ _ ↦ Submodule.smul_mem _ _\n      (Submodule.subset_span (by simp only [Set.mem_range, exists_apply_eq_apply])))\n    (fun _ _ hx hy ↦ Submodule.add_mem _ hx hy)\n\n"}
{"name":"PiTensorProduct.liftAux_tprod","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nE : Type u_9\ninst✝¹ : AddCommMonoid E\ninst✝ : Module R E\nφ : MultilinearMap R s E\nf : (i : ι) → s i\n⊢ Eq ((PiTensorProduct.liftAux φ) ((PiTensorProduct.tprod R) f)) (φ f)","decl":"theorem liftAux_tprod (φ : MultilinearMap R s E) (f : Π i, s i) : liftAux φ (tprod R f) = φ f := by\n  simp only [liftAux, liftAddHom, tprod_eq_tprodCoeff_one, tprodCoeff, AddCon.coe_mk']\n  -- The end of this proof was very different before https://github.com/leanprover/lean4/pull/2644:\n  -- rw [FreeAddMonoid.of, FreeAddMonoid.ofList, Equiv.refl_apply, AddCon.lift_coe]\n  -- dsimp [FreeAddMonoid.lift, FreeAddMonoid.sumAux]\n  -- show _ • _ = _\n  -- rw [one_smul]\n  erw [AddCon.lift_coe]\n  rw [FreeAddMonoid.of]\n  dsimp [FreeAddMonoid.ofList]\n  rw [← one_smul R (φ f)]\n  erw [Equiv.refl_apply]\n  convert one_smul R (φ f)\n  simp\n\n"}
{"name":"PiTensorProduct.liftAux_tprodCoeff","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nE : Type u_9\ninst✝¹ : AddCommMonoid E\ninst✝ : Module R E\nφ : MultilinearMap R s E\nz : R\nf : (i : ι) → s i\n⊢ Eq ((PiTensorProduct.liftAux φ) (PiTensorProduct.tprodCoeff R z f)) (HSMul.hSMul z (φ f))","decl":"theorem liftAux_tprodCoeff (φ : MultilinearMap R s E) (z : R) (f : Π i, s i) :\n    liftAux φ (tprodCoeff R z f) = z • φ f := rfl\n\n"}
{"name":"PiTensorProduct.liftAux.smul","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nE : Type u_9\ninst✝¹ : AddCommMonoid E\ninst✝ : Module R E\nφ : MultilinearMap R s E\nr : R\nx : PiTensorProduct R fun i => s i\n⊢ Eq ((PiTensorProduct.liftAux φ) (HSMul.hSMul r x)) (HSMul.hSMul r ((PiTensorProduct.liftAux φ) x))","decl":"theorem liftAux.smul {φ : MultilinearMap R s E} (r : R) (x : ⨂[R] i, s i) :\n    liftAux φ (r • x) = r • liftAux φ x := by\n  refine PiTensorProduct.induction_on' x ?_ ?_\n  · intro z f\n    rw [smul_tprodCoeff' r z f, liftAux_tprodCoeff, liftAux_tprodCoeff, smul_assoc]\n  · intro z y ihz ihy\n    rw [smul_add, (liftAux φ).map_add, ihz, ihy, (liftAux φ).map_add, smul_add]\n\n"}
{"name":"PiTensorProduct.lift.tprod","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nE : Type u_9\ninst✝¹ : AddCommMonoid E\ninst✝ : Module R E\nφ : MultilinearMap R s E\nf : (i : ι) → s i\n⊢ Eq ((PiTensorProduct.lift φ) ((PiTensorProduct.tprod R) f)) (φ f)","decl":"@[simp]\ntheorem lift.tprod (f : Π i, s i) : lift φ (tprod R f) = φ f :=\n  liftAux_tprod φ f\n\n"}
{"name":"PiTensorProduct.lift.unique'","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nE : Type u_9\ninst✝¹ : AddCommMonoid E\ninst✝ : Module R E\nφ : MultilinearMap R s E\nφ' : LinearMap (RingHom.id R) (PiTensorProduct R fun i => s i) E\nH : Eq (φ'.compMultilinearMap (PiTensorProduct.tprod R)) φ\n⊢ Eq φ' (PiTensorProduct.lift φ)","decl":"theorem lift.unique' {φ' : (⨂[R] i, s i) →ₗ[R] E}\n    (H : φ'.compMultilinearMap (PiTensorProduct.tprod R) = φ) : φ' = lift φ :=\n  ext <| H.symm ▸ (lift.symm_apply_apply φ).symm\n\n"}
{"name":"PiTensorProduct.lift.unique","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nE : Type u_9\ninst✝¹ : AddCommMonoid E\ninst✝ : Module R E\nφ : MultilinearMap R s E\nφ' : LinearMap (RingHom.id R) (PiTensorProduct R fun i => s i) E\nH : ∀ (f : (i : ι) → s i), Eq (φ' ((PiTensorProduct.tprod R) f)) (φ f)\n⊢ Eq φ' (PiTensorProduct.lift φ)","decl":"theorem lift.unique {φ' : (⨂[R] i, s i) →ₗ[R] E} (H : ∀ f, φ' (PiTensorProduct.tprod R f) = φ f) :\n    φ' = lift φ :=\n  lift.unique' (MultilinearMap.ext H)\n\n"}
{"name":"PiTensorProduct.lift_symm","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nE : Type u_9\ninst✝¹ : AddCommMonoid E\ninst✝ : Module R E\nφ' : LinearMap (RingHom.id R) (PiTensorProduct R fun i => s i) E\n⊢ Eq (PiTensorProduct.lift.symm φ') (φ'.compMultilinearMap (PiTensorProduct.tprod R))","decl":"@[simp]\ntheorem lift_symm (φ' : (⨂[R] i, s i) →ₗ[R] E) : lift.symm φ' = φ'.compMultilinearMap (tprod R) :=\n  rfl\n\n"}
{"name":"PiTensorProduct.lift_tprod","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\n⊢ Eq (PiTensorProduct.lift (PiTensorProduct.tprod R)) LinearMap.id","decl":"@[simp]\ntheorem lift_tprod : lift (tprod R : MultilinearMap R s _) = LinearMap.id :=\n  Eq.symm <| lift.unique' rfl\n\n"}
{"name":"PiTensorProduct.map_tprod","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nt : ι → Type u_11\ninst✝¹ : (i : ι) → AddCommMonoid (t i)\ninst✝ : (i : ι) → Module R (t i)\nf : (i : ι) → LinearMap (RingHom.id R) (s i) (t i)\nx : (i : ι) → s i\n⊢ Eq ((PiTensorProduct.map f) ((PiTensorProduct.tprod R) x)) ((PiTensorProduct.tprod R) fun i => (f i) (x i))","decl":"@[simp] lemma map_tprod (x : Π i, s i) :\n    map f (tprod R x) = tprod R fun i ↦ f i (x i) :=\n  lift.tprod _\n\n-- No lemmas about associativity, because we don't have associativity of `PiTensorProduct` yet.\n\n"}
{"name":"PiTensorProduct.map_range_eq_span_tprod","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nt : ι → Type u_11\ninst✝¹ : (i : ι) → AddCommMonoid (t i)\ninst✝ : (i : ι) → Module R (t i)\nf : (i : ι) → LinearMap (RingHom.id R) (s i) (t i)\n⊢ Eq (LinearMap.range (PiTensorProduct.map f)) (Submodule.span R (setOf fun t_1 => Exists fun m => Eq ((PiTensorProduct.tprod R) fun i => (f i) (m i)) t_1))","decl":"theorem map_range_eq_span_tprod :\n    LinearMap.range (map f) =\n      Submodule.span R {t | ∃ (m : Π i, s i), tprod R (fun i ↦ f i (m i)) = t} := by\n  rw [← Submodule.map_top, ← span_tprod_eq_top, Submodule.map_span, ← Set.range_comp]\n  apply congrArg; ext x\n  simp only [Set.mem_range, comp_apply, map_tprod, Set.mem_setOf_eq]\n\n"}
{"name":"PiTensorProduct.map_comp","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁶ : CommSemiring R\ns : ι → Type u_7\ninst✝⁵ : (i : ι) → AddCommMonoid (s i)\ninst✝⁴ : (i : ι) → Module R (s i)\nt : ι → Type u_11\nt' : ι → Type u_12\ninst✝³ : (i : ι) → AddCommMonoid (t i)\ninst✝² : (i : ι) → Module R (t i)\ninst✝¹ : (i : ι) → AddCommMonoid (t' i)\ninst✝ : (i : ι) → Module R (t' i)\ng : (i : ι) → LinearMap (RingHom.id R) (t i) (t' i)\nf : (i : ι) → LinearMap (RingHom.id R) (s i) (t i)\n⊢ Eq (PiTensorProduct.map fun i => (g i).comp (f i)) ((PiTensorProduct.map g).comp (PiTensorProduct.map f))","decl":"theorem map_comp : map (fun (i : ι) ↦ g i ∘ₗ f i) = map g ∘ₗ map f := by\n  ext\n  simp only [LinearMap.compMultilinearMap_apply, map_tprod, LinearMap.coe_comp, Function.comp_apply]\n\n"}
{"name":"PiTensorProduct.lift_comp_map","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁶ : CommSemiring R\ns : ι → Type u_7\ninst✝⁵ : (i : ι) → AddCommMonoid (s i)\ninst✝⁴ : (i : ι) → Module R (s i)\nE : Type u_9\ninst✝³ : AddCommMonoid E\ninst✝² : Module R E\nt : ι → Type u_11\ninst✝¹ : (i : ι) → AddCommMonoid (t i)\ninst✝ : (i : ι) → Module R (t i)\nf : (i : ι) → LinearMap (RingHom.id R) (s i) (t i)\nh : MultilinearMap R t E\n⊢ Eq ((PiTensorProduct.lift h).comp (PiTensorProduct.map f)) (PiTensorProduct.lift (h.compLinearMap f))","decl":"theorem lift_comp_map (h : MultilinearMap R t E) :\n    lift h ∘ₗ map f = lift (h.compLinearMap f) := by\n  ext\n  simp only [LinearMap.compMultilinearMap_apply, LinearMap.coe_comp, Function.comp_apply,\n    map_tprod, lift.tprod, MultilinearMap.compLinearMap_apply]\n\n"}
{"name":"PiTensorProduct.map_id","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\n⊢ Eq (PiTensorProduct.map fun i => LinearMap.id) LinearMap.id","decl":"@[simp]\ntheorem map_id : map (fun i ↦ (LinearMap.id : s i →ₗ[R] s i)) = .id := by\n  ext\n  simp only [LinearMap.compMultilinearMap_apply, map_tprod, LinearMap.id_coe, id_eq]\n\n"}
{"name":"PiTensorProduct.map_one","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\n⊢ Eq (PiTensorProduct.map fun i => 1) 1","decl":"@[simp]\ntheorem map_one : map (fun (i : ι) ↦ (1 : s i →ₗ[R] s i)) = 1 :=\n  map_id\n\n"}
{"name":"PiTensorProduct.map_mul","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\nf₁ f₂ : (i : ι) → LinearMap (RingHom.id R) (s i) (s i)\n⊢ Eq (PiTensorProduct.map fun i => HMul.hMul (f₁ i) (f₂ i)) (HMul.hMul (PiTensorProduct.map f₁) (PiTensorProduct.map f₂))","decl":"theorem map_mul (f₁ f₂ : Π i, s i →ₗ[R] s i) :\n    map (fun i ↦ f₁ i * f₂ i) = map f₁ * map f₂ :=\n  map_comp f₁ f₂\n\n"}
{"name":"PiTensorProduct.mapMonoidHom_apply","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\nf : (i : ι) → LinearMap (RingHom.id R) (s i) (s i)\n⊢ Eq (PiTensorProduct.mapMonoidHom f) (PiTensorProduct.map f)","decl":"/-- Upgrading `PiTensorProduct.map` to a `MonoidHom` when `s = t`. -/\n@[simps]\ndef mapMonoidHom : (Π i, s i →ₗ[R] s i) →* ((⨂[R] i, s i) →ₗ[R] ⨂[R] i, s i) where\n  toFun := map\n  map_one' := map_one\n  map_mul' := map_mul\n\n"}
{"name":"PiTensorProduct.map_pow","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\nf : (i : ι) → LinearMap (RingHom.id R) (s i) (s i)\nn : Nat\n⊢ Eq (PiTensorProduct.map (HPow.hPow f n)) (HPow.hPow (PiTensorProduct.map f) n)","decl":"@[simp]\nprotected theorem map_pow (f : Π i, s i →ₗ[R] s i) (n : ℕ) :\n    map (f ^ n) = map f ^ n := MonoidHom.map_pow mapMonoidHom _ _\n\n"}
{"name":"PiTensorProduct.map_update_add","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁵ : CommSemiring R\ns : ι → Type u_7\ninst✝⁴ : (i : ι) → AddCommMonoid (s i)\ninst✝³ : (i : ι) → Module R (s i)\nt : ι → Type u_11\ninst✝² : (i : ι) → AddCommMonoid (t i)\ninst✝¹ : (i : ι) → Module R (t i)\nf : (i : ι) → LinearMap (RingHom.id R) (s i) (t i)\ninst✝ : DecidableEq ι\ni : ι\nu v : LinearMap (RingHom.id R) (s i) (t i)\n⊢ Eq (PiTensorProduct.map (Function.update f i (HAdd.hAdd u v))) (HAdd.hAdd (PiTensorProduct.map (Function.update f i u)) (PiTensorProduct.map (Function.update f i v)))","decl":"open Function in\nprotected theorem map_update_add [DecidableEq ι] (i : ι) (u v : s i →ₗ[R] t i) :\n    map (update f i (u + v)) = map (update f i u) + map (update f i v) := by\n  ext x\n  simp only [LinearMap.compMultilinearMap_apply, map_tprod, map_add_smul_aux, LinearMap.add_apply,\n    MultilinearMap.map_update_add]\n\n"}
{"name":"PiTensorProduct.map_add","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁵ : CommSemiring R\ns : ι → Type u_7\ninst✝⁴ : (i : ι) → AddCommMonoid (s i)\ninst✝³ : (i : ι) → Module R (s i)\nt : ι → Type u_11\ninst✝² : (i : ι) → AddCommMonoid (t i)\ninst✝¹ : (i : ι) → Module R (t i)\nf : (i : ι) → LinearMap (RingHom.id R) (s i) (t i)\ninst✝ : DecidableEq ι\ni : ι\nu v : LinearMap (RingHom.id R) (s i) (t i)\n⊢ Eq (PiTensorProduct.map (Function.update f i (HAdd.hAdd u v))) (HAdd.hAdd (PiTensorProduct.map (Function.update f i u)) (PiTensorProduct.map (Function.update f i v)))","decl":"@[deprecated (since := \"2024-11-03\")] protected alias map_add := PiTensorProduct.map_update_add\n\n"}
{"name":"PiTensorProduct.map_update_smul","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁵ : CommSemiring R\ns : ι → Type u_7\ninst✝⁴ : (i : ι) → AddCommMonoid (s i)\ninst✝³ : (i : ι) → Module R (s i)\nt : ι → Type u_11\ninst✝² : (i : ι) → AddCommMonoid (t i)\ninst✝¹ : (i : ι) → Module R (t i)\nf : (i : ι) → LinearMap (RingHom.id R) (s i) (t i)\ninst✝ : DecidableEq ι\ni : ι\nc : R\nu : LinearMap (RingHom.id R) (s i) (t i)\n⊢ Eq (PiTensorProduct.map (Function.update f i (HSMul.hSMul c u))) (HSMul.hSMul c (PiTensorProduct.map (Function.update f i u)))","decl":"open Function in\nprotected theorem map_update_smul [DecidableEq ι] (i : ι) (c : R) (u : s i →ₗ[R] t i) :\n    map (update f i (c • u)) = c • map (update f i u) := by\n  ext x\n  simp only [LinearMap.compMultilinearMap_apply, map_tprod, map_add_smul_aux, LinearMap.smul_apply,\n    MultilinearMap.map_update_smul]\n\n"}
{"name":"PiTensorProduct.map_smul","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁵ : CommSemiring R\ns : ι → Type u_7\ninst✝⁴ : (i : ι) → AddCommMonoid (s i)\ninst✝³ : (i : ι) → Module R (s i)\nt : ι → Type u_11\ninst✝² : (i : ι) → AddCommMonoid (t i)\ninst✝¹ : (i : ι) → Module R (t i)\nf : (i : ι) → LinearMap (RingHom.id R) (s i) (t i)\ninst✝ : DecidableEq ι\ni : ι\nc : R\nu : LinearMap (RingHom.id R) (s i) (t i)\n⊢ Eq (PiTensorProduct.map (Function.update f i (HSMul.hSMul c u))) (HSMul.hSMul c (PiTensorProduct.map (Function.update f i u)))","decl":"@[deprecated (since := \"2024-11-03\")] protected alias map_smul := PiTensorProduct.map_update_smul\n\n"}
{"name":"PiTensorProduct.mapMultilinear_apply","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nt : ι → Type u_11\ninst✝¹ : (i : ι) → AddCommMonoid (t i)\ninst✝ : (i : ι) → Module R (t i)\nf : (i : ι) → LinearMap (RingHom.id R) (s i) (t i)\n⊢ Eq ((PiTensorProduct.mapMultilinear R s t) f) (PiTensorProduct.map f)","decl":"/-- The tensor of a family of linear maps from `sᵢ` to `tᵢ`, as a multilinear map of\nthe family.\n-/\n@[simps]\nnoncomputable def mapMultilinear :\n    MultilinearMap R (fun (i : ι) ↦ s i →ₗ[R] t i) ((⨂[R] i, s i) →ₗ[R] ⨂[R] i, t i) where\n  toFun := map\n  map_update_smul' _ _ _ _ := PiTensorProduct.map_update_smul _ _ _ _\n  map_update_add' _ _ _ _ := PiTensorProduct.map_update_add _ _ _ _\n\n"}
{"name":"PiTensorProduct.piTensorHomMap_tprod_tprod","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nt : ι → Type u_11\ninst✝¹ : (i : ι) → AddCommMonoid (t i)\ninst✝ : (i : ι) → Module R (t i)\nf : (i : ι) → LinearMap (RingHom.id R) (s i) (t i)\nx : (i : ι) → s i\n⊢ Eq ((PiTensorProduct.piTensorHomMap ((PiTensorProduct.tprod R) f)) ((PiTensorProduct.tprod R) x)) ((PiTensorProduct.tprod R) fun i => (f i) (x i))","decl":"@[simp] lemma piTensorHomMap_tprod_tprod (f : Π i, s i →ₗ[R] t i) (x : Π i, s i) :\n    piTensorHomMap (tprod R f) (tprod R x) = tprod R fun i ↦ f i (x i) := by\n  simp [piTensorHomMap]\n\n"}
{"name":"PiTensorProduct.piTensorHomMap_tprod_eq_map","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nt : ι → Type u_11\ninst✝¹ : (i : ι) → AddCommMonoid (t i)\ninst✝ : (i : ι) → Module R (t i)\nf : (i : ι) → LinearMap (RingHom.id R) (s i) (t i)\n⊢ Eq (PiTensorProduct.piTensorHomMap ((PiTensorProduct.tprod R) f)) (PiTensorProduct.map f)","decl":"lemma piTensorHomMap_tprod_eq_map (f : Π i, s i →ₗ[R] t i) :\n    piTensorHomMap (tprod R f) = map f := by\n  ext; simp\n\n"}
{"name":"PiTensorProduct.congr_tprod","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nt : ι → Type u_11\ninst✝¹ : (i : ι) → AddCommMonoid (t i)\ninst✝ : (i : ι) → Module R (t i)\nf : (i : ι) → LinearEquiv (RingHom.id R) (s i) (t i)\nm : (i : ι) → s i\n⊢ Eq ((PiTensorProduct.congr f) ((PiTensorProduct.tprod R) m)) ((PiTensorProduct.tprod R) fun i => (f i) (m i))","decl":"@[simp]\ntheorem congr_tprod (f : Π i, s i ≃ₗ[R] t i) (m : Π i, s i) :\n    congr f (tprod R m) = tprod R (fun (i : ι) ↦ (f i) (m i)) := by\n  simp only [congr, LinearEquiv.ofLinear_apply, map_tprod, LinearEquiv.coe_coe]\n\n"}
{"name":"PiTensorProduct.congr_symm_tprod","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nt : ι → Type u_11\ninst✝¹ : (i : ι) → AddCommMonoid (t i)\ninst✝ : (i : ι) → Module R (t i)\nf : (i : ι) → LinearEquiv (RingHom.id R) (s i) (t i)\np : (i : ι) → t i\n⊢ Eq ((PiTensorProduct.congr f).symm ((PiTensorProduct.tprod R) p)) ((PiTensorProduct.tprod R) fun i => (f i).symm (p i))","decl":"@[simp]\ntheorem congr_symm_tprod (f : Π i, s i ≃ₗ[R] t i) (p : Π i, t i) :\n    (congr f).symm (tprod R p) = tprod R (fun (i : ι) ↦ (f i).symm (p i)) := by\n  simp only [congr, LinearEquiv.ofLinear_symm_apply, map_tprod, LinearEquiv.coe_coe]\n\n"}
{"name":"PiTensorProduct.map₂_tprod_tprod","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁶ : CommSemiring R\ns : ι → Type u_7\ninst✝⁵ : (i : ι) → AddCommMonoid (s i)\ninst✝⁴ : (i : ι) → Module R (s i)\nt : ι → Type u_11\nt' : ι → Type u_12\ninst✝³ : (i : ι) → AddCommMonoid (t i)\ninst✝² : (i : ι) → Module R (t i)\ninst✝¹ : (i : ι) → AddCommMonoid (t' i)\ninst✝ : (i : ι) → Module R (t' i)\nf : (i : ι) → LinearMap (RingHom.id R) (s i) (LinearMap (RingHom.id R) (t i) (t' i))\nx : (i : ι) → s i\ny : (i : ι) → t i\n⊢ Eq (((PiTensorProduct.map₂ f) ((PiTensorProduct.tprod R) x)) ((PiTensorProduct.tprod R) y)) ((PiTensorProduct.tprod R) fun i => ((f i) (x i)) (y i))","decl":"lemma map₂_tprod_tprod (f : Π i, s i →ₗ[R] t i →ₗ[R] t' i) (x : Π i, s i) (y : Π i, t i) :\n    map₂ f (tprod R x) (tprod R y) = tprod R fun i ↦ f i (x i) (y i) := by\n  simp [map₂]\n\n"}
{"name":"PiTensorProduct.piTensorHomMapFun₂_add","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁶ : CommSemiring R\ns : ι → Type u_7\ninst✝⁵ : (i : ι) → AddCommMonoid (s i)\ninst✝⁴ : (i : ι) → Module R (s i)\nt : ι → Type u_11\nt' : ι → Type u_12\ninst✝³ : (i : ι) → AddCommMonoid (t i)\ninst✝² : (i : ι) → Module R (t i)\ninst✝¹ : (i : ι) → AddCommMonoid (t' i)\ninst✝ : (i : ι) → Module R (t' i)\nφ ψ : PiTensorProduct R fun i => LinearMap (RingHom.id R) (s i) (LinearMap (RingHom.id R) (t i) (t' i))\n⊢ Eq (HAdd.hAdd φ ψ).piTensorHomMapFun₂ (HAdd.hAdd φ.piTensorHomMapFun₂ ψ.piTensorHomMapFun₂)","decl":"theorem piTensorHomMapFun₂_add (φ ψ : ⨂[R] i, s i →ₗ[R] t i →ₗ[R] t' i) :\n    piTensorHomMapFun₂ (φ + ψ) = piTensorHomMapFun₂ φ + piTensorHomMapFun₂ ψ := by\n  dsimp [piTensorHomMapFun₂]; ext; simp only [map_add, LinearMap.compMultilinearMap_apply,\n    lift.tprod, add_apply, LinearMap.add_apply]\n\n"}
{"name":"PiTensorProduct.piTensorHomMapFun₂_smul","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁶ : CommSemiring R\ns : ι → Type u_7\ninst✝⁵ : (i : ι) → AddCommMonoid (s i)\ninst✝⁴ : (i : ι) → Module R (s i)\nt : ι → Type u_11\nt' : ι → Type u_12\ninst✝³ : (i : ι) → AddCommMonoid (t i)\ninst✝² : (i : ι) → Module R (t i)\ninst✝¹ : (i : ι) → AddCommMonoid (t' i)\ninst✝ : (i : ι) → Module R (t' i)\nr : R\nφ : PiTensorProduct R fun i => LinearMap (RingHom.id R) (s i) (LinearMap (RingHom.id R) (t i) (t' i))\n⊢ Eq (HSMul.hSMul r φ).piTensorHomMapFun₂ (HSMul.hSMul r φ.piTensorHomMapFun₂)","decl":"theorem piTensorHomMapFun₂_smul (r : R) (φ : ⨂[R] i, s i →ₗ[R] t i →ₗ[R] t' i) :\n    piTensorHomMapFun₂ (r • φ) = r • piTensorHomMapFun₂ φ := by\n  dsimp [piTensorHomMapFun₂]; ext; simp only [map_smul, LinearMap.compMultilinearMap_apply,\n    lift.tprod, smul_apply, LinearMap.smul_apply]\n\n"}
{"name":"PiTensorProduct.piTensorHomMap₂_tprod_tprod_tprod","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝⁶ : CommSemiring R\ns : ι → Type u_7\ninst✝⁵ : (i : ι) → AddCommMonoid (s i)\ninst✝⁴ : (i : ι) → Module R (s i)\nt : ι → Type u_11\nt' : ι → Type u_12\ninst✝³ : (i : ι) → AddCommMonoid (t i)\ninst✝² : (i : ι) → Module R (t i)\ninst✝¹ : (i : ι) → AddCommMonoid (t' i)\ninst✝ : (i : ι) → Module R (t' i)\nf : (i : ι) → LinearMap (RingHom.id R) (s i) (LinearMap (RingHom.id R) (t i) (t' i))\na : (i : ι) → s i\nb : (i : ι) → t i\n⊢ Eq (((PiTensorProduct.piTensorHomMap₂ ((PiTensorProduct.tprod R) f)) ((PiTensorProduct.tprod R) a)) ((PiTensorProduct.tprod R) b)) ((PiTensorProduct.tprod R) fun i => ((f i) (a i)) (b i))","decl":"@[simp] lemma piTensorHomMap₂_tprod_tprod_tprod\n    (f : ∀ i, s i →ₗ[R] t i →ₗ[R] t' i) (a : ∀ i, s i) (b : ∀ i, t i) :\n    piTensorHomMap₂ (tprod R f) (tprod R a) (tprod R b) = tprod R (fun i ↦ f i (a i) (b i)) := by\n  simp [piTensorHomMapFun₂, piTensorHomMap₂]\n\n"}
{"name":"PiTensorProduct.reindex_tprod","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nι₂ : Type u_2\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\ne : Equiv ι ι₂\nf : (i : ι) → s i\n⊢ Eq ((PiTensorProduct.reindex R s e) ((PiTensorProduct.tprod R) f)) ((PiTensorProduct.tprod R) fun i => f (e.symm i))","decl":"@[simp]\ntheorem reindex_tprod (e : ι ≃ ι₂) (f : Π i, s i) :\n    reindex R s e (tprod R f) = tprod R fun i ↦ f (e.symm i) := by\n  dsimp [reindex]\n  exact liftAux_tprod _ f\n\n"}
{"name":"PiTensorProduct.reindex_comp_tprod","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nι₂ : Type u_2\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\ne : Equiv ι ι₂\n⊢ Eq ((↑(PiTensorProduct.reindex R s e)).compMultilinearMap (PiTensorProduct.tprod R)) ((MultilinearMap.domDomCongrLinearEquiv' R R s (PiTensorProduct R fun i => s (e.symm i)) e).symm (PiTensorProduct.tprod R))","decl":"@[simp]\ntheorem reindex_comp_tprod (e : ι ≃ ι₂) :\n    (reindex R s e).compMultilinearMap (tprod R) =\n    (domDomCongrLinearEquiv' R R s _ e).symm (tprod R) :=\n  MultilinearMap.ext <| reindex_tprod e\n\n"}
{"name":"PiTensorProduct.lift_comp_reindex","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nι₂ : Type u_2\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nE : Type u_9\ninst✝¹ : AddCommMonoid E\ninst✝ : Module R E\ne : Equiv ι ι₂\nφ : MultilinearMap R (fun i => s (e.symm i)) E\n⊢ Eq ((PiTensorProduct.lift φ).comp ↑(PiTensorProduct.reindex R s e)) (PiTensorProduct.lift ((MultilinearMap.domDomCongrLinearEquiv' R R s E e).symm φ))","decl":"theorem lift_comp_reindex (e : ι ≃ ι₂) (φ : MultilinearMap R (fun i ↦ s (e.symm i)) E) :\n    lift φ ∘ₗ (reindex R s e) = lift ((domDomCongrLinearEquiv' R R s _ e).symm φ) := by\n  ext; simp [reindex]\n\n"}
{"name":"PiTensorProduct.lift_comp_reindex_symm","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nι₂ : Type u_2\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nE : Type u_9\ninst✝¹ : AddCommMonoid E\ninst✝ : Module R E\ne : Equiv ι ι₂\nφ : MultilinearMap R s E\n⊢ Eq ((PiTensorProduct.lift φ).comp ↑(PiTensorProduct.reindex R s e).symm) (PiTensorProduct.lift ((MultilinearMap.domDomCongrLinearEquiv' R R s E e) φ))","decl":"@[simp]\ntheorem lift_comp_reindex_symm (e : ι ≃ ι₂) (φ : MultilinearMap R s E) :\n    lift φ ∘ₗ (reindex R s e).symm = lift (domDomCongrLinearEquiv' R R s _ e φ) := by\n  ext; simp [reindex]\n\n"}
{"name":"PiTensorProduct.lift_reindex","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nι₂ : Type u_2\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nE : Type u_9\ninst✝¹ : AddCommMonoid E\ninst✝ : Module R E\ne : Equiv ι ι₂\nφ : MultilinearMap R (fun i => s (e.symm i)) E\nx : PiTensorProduct R fun i => s i\n⊢ Eq ((PiTensorProduct.lift φ) ((PiTensorProduct.reindex R s e) x)) ((PiTensorProduct.lift ((MultilinearMap.domDomCongrLinearEquiv' R R s E e).symm φ)) x)","decl":"theorem lift_reindex\n    (e : ι ≃ ι₂) (φ : MultilinearMap R (fun i ↦ s (e.symm i)) E) (x : ⨂[R] i, s i) :\n    lift φ (reindex R s e x) = lift ((domDomCongrLinearEquiv' R R s _ e).symm φ) x :=\n  LinearMap.congr_fun (lift_comp_reindex e φ) x\n\n"}
{"name":"PiTensorProduct.lift_reindex_symm","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nι₂ : Type u_2\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nE : Type u_9\ninst✝¹ : AddCommMonoid E\ninst✝ : Module R E\ne : Equiv ι ι₂\nφ : MultilinearMap R s E\nx : PiTensorProduct R fun i => s (e.symm i)\n⊢ Eq ((PiTensorProduct.lift φ) ((PiTensorProduct.reindex R s e).symm x)) ((PiTensorProduct.lift ((MultilinearMap.domDomCongrLinearEquiv' R R s E e) φ)) x)","decl":"@[simp]\ntheorem lift_reindex_symm\n    (e : ι ≃ ι₂) (φ : MultilinearMap R s E) (x : ⨂[R] i, s (e.symm i)) :\n    lift φ (reindex R s e |>.symm x) = lift (domDomCongrLinearEquiv' R R s _ e φ) x :=\n  LinearMap.congr_fun (lift_comp_reindex_symm e φ) x\n\n"}
{"name":"PiTensorProduct.reindex_trans","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nι₂ : Type u_2\nι₃ : Type u_3\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\ne : Equiv ι ι₂\ne' : Equiv ι₂ ι₃\n⊢ Eq ((PiTensorProduct.reindex R s e).trans (PiTensorProduct.reindex R (fun i => s (e.symm i)) e')) (PiTensorProduct.reindex R s (e.trans e'))","decl":"@[simp]\ntheorem reindex_trans (e : ι ≃ ι₂) (e' : ι₂ ≃ ι₃) :\n    (reindex R s e).trans (reindex R _ e') = reindex R s (e.trans e') := by\n  apply LinearEquiv.toLinearMap_injective\n  ext f\n  simp only [LinearEquiv.trans_apply, LinearEquiv.coe_coe, reindex_tprod,\n    LinearMap.coe_compMultilinearMap, Function.comp_apply, MultilinearMap.domDomCongr_apply,\n    reindex_comp_tprod]\n  congr\n\n"}
{"name":"PiTensorProduct.reindex_reindex","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nι₂ : Type u_2\nι₃ : Type u_3\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\ne : Equiv ι ι₂\ne' : Equiv ι₂ ι₃\nx : PiTensorProduct R fun i => s i\n⊢ Eq ((PiTensorProduct.reindex R (fun i => s (e.symm i)) e') ((PiTensorProduct.reindex R s e) x)) ((PiTensorProduct.reindex R s (e.trans e')) x)","decl":"theorem reindex_reindex (e : ι ≃ ι₂) (e' : ι₂ ≃ ι₃) (x : ⨂[R] i, s i) :\n    reindex R _ e' (reindex R s e x) = reindex R s (e.trans e') x :=\n  LinearEquiv.congr_fun (reindex_trans e e' : _ = reindex R s (e.trans e')) x\n\n"}
{"name":"PiTensorProduct.reindex_symm","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nι₂ : Type u_2\nR : Type u_4\ninst✝² : CommSemiring R\nM : Type u_8\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ne : Equiv ι ι₂\n⊢ Eq (PiTensorProduct.reindex R (fun x => M) e).symm (PiTensorProduct.reindex R (fun x => M) e.symm)","decl":"/-- This lemma is impractical to state in the dependent case. -/\n@[simp]\ntheorem reindex_symm (e : ι ≃ ι₂) :\n    (reindex R (fun _ ↦ M) e).symm = reindex R (fun _ ↦ M) e.symm := by\n  ext x\n  simp only [reindex, domDomCongrLinearEquiv', LinearEquiv.coe_symm_mk, LinearEquiv.coe_mk,\n    LinearEquiv.ofLinear_symm_apply, Equiv.symm_symm_apply, LinearEquiv.ofLinear_apply,\n    Equiv.piCongrLeft'_symm]\n\n"}
{"name":"PiTensorProduct.reindex_refl","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝² : CommSemiring R\ns : ι → Type u_7\ninst✝¹ : (i : ι) → AddCommMonoid (s i)\ninst✝ : (i : ι) → Module R (s i)\n⊢ Eq (PiTensorProduct.reindex R s (Equiv.refl ι)) (LinearEquiv.refl R (PiTensorProduct R fun i => s i))","decl":"@[simp]\ntheorem reindex_refl : reindex R s (Equiv.refl ι) = LinearEquiv.refl R _ := by\n  apply LinearEquiv.toLinearMap_injective\n  ext\n  simp only [Equiv.refl_symm, Equiv.refl_apply, reindex, domDomCongrLinearEquiv',\n    LinearEquiv.coe_symm_mk, LinearMap.compMultilinearMap_apply, LinearEquiv.coe_coe,\n    LinearEquiv.refl_toLinearMap, LinearMap.id_coe, id_eq]\n  erw [lift.tprod]\n  congr\n\n"}
{"name":"PiTensorProduct.map_comp_reindex_eq","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nι₂ : Type u_2\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nt : ι → Type u_11\ninst✝¹ : (i : ι) → AddCommMonoid (t i)\ninst✝ : (i : ι) → Module R (t i)\nf : (i : ι) → LinearMap (RingHom.id R) (s i) (t i)\ne : Equiv ι ι₂\n⊢ Eq ((PiTensorProduct.map fun i => f (e.symm i)).comp ↑(PiTensorProduct.reindex R s e)) ((↑(PiTensorProduct.reindex R t e)).comp (PiTensorProduct.map f))","decl":"/-- Re-indexing the components of the tensor product by an equivalence `e` is compatible\nwith `PiTensorProduct.map`. -/\ntheorem map_comp_reindex_eq (f : Π i, s i →ₗ[R] t i) (e : ι ≃ ι₂) :\n    map (fun i ↦ f (e.symm i)) ∘ₗ reindex R s e = reindex R t e ∘ₗ map f := by\n  ext m\n  simp only [LinearMap.compMultilinearMap_apply, LinearMap.coe_comp, LinearEquiv.coe_coe,\n    LinearMap.comp_apply, reindex_tprod, map_tprod]\n\n"}
{"name":"PiTensorProduct.map_reindex","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nι₂ : Type u_2\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nt : ι → Type u_11\ninst✝¹ : (i : ι) → AddCommMonoid (t i)\ninst✝ : (i : ι) → Module R (t i)\nf : (i : ι) → LinearMap (RingHom.id R) (s i) (t i)\ne : Equiv ι ι₂\nx : PiTensorProduct R fun i => s i\n⊢ Eq ((PiTensorProduct.map fun i => f (e.symm i)) ((PiTensorProduct.reindex R s e) x)) ((PiTensorProduct.reindex R t e) ((PiTensorProduct.map f) x))","decl":"theorem map_reindex (f : Π i, s i →ₗ[R] t i) (e : ι ≃ ι₂) (x : ⨂[R] i, s i) :\n    map (fun i ↦ f (e.symm i)) (reindex R s e x) = reindex R t e (map f x) :=\n  DFunLike.congr_fun (map_comp_reindex_eq _ _) _\n\n"}
{"name":"PiTensorProduct.map_comp_reindex_symm","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nι₂ : Type u_2\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nt : ι → Type u_11\ninst✝¹ : (i : ι) → AddCommMonoid (t i)\ninst✝ : (i : ι) → Module R (t i)\nf : (i : ι) → LinearMap (RingHom.id R) (s i) (t i)\ne : Equiv ι ι₂\n⊢ Eq ((PiTensorProduct.map f).comp ↑(PiTensorProduct.reindex R s e).symm) ((↑(PiTensorProduct.reindex R t e).symm).comp (PiTensorProduct.map fun i => f (e.symm i)))","decl":"theorem map_comp_reindex_symm (f : Π i, s i →ₗ[R] t i) (e : ι ≃ ι₂) :\n    map f ∘ₗ (reindex R s e).symm = (reindex R t e).symm ∘ₗ map (fun i => f (e.symm i)) := by\n  ext m\n  apply LinearEquiv.injective (reindex R t e)\n  simp only [LinearMap.compMultilinearMap_apply, LinearMap.coe_comp, LinearEquiv.coe_coe,\n    comp_apply, ← map_reindex, LinearEquiv.apply_symm_apply, map_tprod]\n\n"}
{"name":"PiTensorProduct.map_reindex_symm","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nι₂ : Type u_2\nR : Type u_4\ninst✝⁴ : CommSemiring R\ns : ι → Type u_7\ninst✝³ : (i : ι) → AddCommMonoid (s i)\ninst✝² : (i : ι) → Module R (s i)\nt : ι → Type u_11\ninst✝¹ : (i : ι) → AddCommMonoid (t i)\ninst✝ : (i : ι) → Module R (t i)\nf : (i : ι) → LinearMap (RingHom.id R) (s i) (t i)\ne : Equiv ι ι₂\nx : PiTensorProduct R fun i => s (e.symm i)\n⊢ Eq ((PiTensorProduct.map f) ((PiTensorProduct.reindex R s e).symm x)) ((PiTensorProduct.reindex R t e).symm ((PiTensorProduct.map fun i => f (e.symm i)) x))","decl":"theorem map_reindex_symm (f : Π i, s i →ₗ[R] t i) (e : ι ≃ ι₂) (x : ⨂[R] i, s (e.symm i)) :\n    map f ((reindex R s e).symm x) = (reindex R t e).symm (map (fun i ↦ f (e.symm i)) x) :=\n  DFunLike.congr_fun (map_comp_reindex_symm _ _) _\n\n"}
{"name":"PiTensorProduct.isEmptyEquiv_symm_apply","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝³ : CommSemiring R\ns : ι → Type u_7\ninst✝² : (i : ι) → AddCommMonoid (s i)\ninst✝¹ : (i : ι) → Module R (s i)\ninst✝ : IsEmpty ι\nr : R\n⊢ Eq ((PiTensorProduct.isEmptyEquiv ι).symm r) (HSMul.hSMul r ((PiTensorProduct.tprod R) isEmptyElim))","decl":"attribute [local simp] eq_iff_true_of_subsingleton in\n/-- The tensor product over an empty index type `ι` is isomorphic to the base ring. -/\n@[simps symm_apply]\ndef isEmptyEquiv [IsEmpty ι] : (⨂[R] i : ι, s i) ≃ₗ[R] R where\n  toFun := lift (constOfIsEmpty R _ 1)\n  invFun r := r • tprod R (@isEmptyElim _ _ _)\n  left_inv x := by\n    refine x.induction_on ?_ ?_\n    · intro x y\n      -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 had to change `map_smulₛₗ` into `map_smulₛₗ _`\n      simp only [map_smulₛₗ _, RingHom.id_apply, lift.tprod, constOfIsEmpty_apply, const_apply,\n        smul_eq_mul, mul_one]\n      congr\n      aesop\n    · simp only\n      intro x y hx hy\n      rw [map_add, add_smul, hx, hy]\n  right_inv t := by simp\n  map_add' := LinearMap.map_add _\n  map_smul' := fun r x => by\n    simp only\n    exact LinearMap.map_smul _ r x\n\n"}
{"name":"PiTensorProduct.isEmptyEquiv_apply_tprod","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝³ : CommSemiring R\ns : ι → Type u_7\ninst✝² : (i : ι) → AddCommMonoid (s i)\ninst✝¹ : (i : ι) → Module R (s i)\ninst✝ : IsEmpty ι\nf : (i : ι) → s i\n⊢ Eq ((PiTensorProduct.isEmptyEquiv ι) ((PiTensorProduct.tprod R) f)) 1","decl":"@[simp]\ntheorem isEmptyEquiv_apply_tprod [IsEmpty ι] (f : Π i, s i) :\n    isEmptyEquiv ι (tprod R f) = 1 :=\n  lift.tprod _\n\n"}
{"name":"PiTensorProduct.subsingletonEquiv_symm_apply","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝³ : CommSemiring R\nM : Type u_8\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Subsingleton ι\ni₀ : ι\nm : M\n⊢ Eq ((PiTensorProduct.subsingletonEquiv i₀).symm m) ((PiTensorProduct.tprod R) fun x => m)","decl":"/--\nTensor product of `M` over a singleton set is equivalent to `M`\n-/\n@[simps symm_apply]\ndef subsingletonEquiv [Subsingleton ι] (i₀ : ι) : (⨂[R] _ : ι, M) ≃ₗ[R] M where\n  toFun := lift (MultilinearMap.ofSubsingleton R M M i₀ .id)\n  invFun m := tprod R fun _ ↦ m\n  left_inv x := by\n    dsimp only\n    have : ∀ (f : ι → M) (z : M), (fun _ : ι ↦ z) = update f i₀ z := fun f z ↦ by\n      ext i\n      rw [Subsingleton.elim i i₀, Function.update_self]\n    refine x.induction_on ?_ ?_\n    · intro r f\n      simp only [LinearMap.map_smul, LinearMap.id_apply, lift.tprod, ofSubsingleton_apply_apply,\n        this f, MultilinearMap.map_update_smul, update_eq_self]\n    · intro x y hx hy\n      rw [LinearMap.map_add, this 0 (_ + _), MultilinearMap.map_update_add, ← this 0 (lift _ _), hx,\n        ← this 0 (lift _ _), hy]\n  right_inv t := by simp only [ofSubsingleton_apply_apply, LinearMap.id_apply, lift.tprod]\n  map_add' := LinearMap.map_add _\n  map_smul' := fun r x => by\n    simp only\n    exact LinearMap.map_smul _ r x\n\n"}
{"name":"PiTensorProduct.subsingletonEquiv_apply_tprod","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_4\ninst✝³ : CommSemiring R\nM : Type u_8\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Subsingleton ι\ni : ι\nf : ι → M\n⊢ Eq ((PiTensorProduct.subsingletonEquiv i) ((PiTensorProduct.tprod R) f)) (f i)","decl":"@[simp]\ntheorem subsingletonEquiv_apply_tprod [Subsingleton ι] (i : ι) (f : ι → M) :\n    subsingletonEquiv i (tprod R f) = f i :=\n  lift.tprod _\n\n"}
{"name":"PiTensorProduct.tmulEquiv_apply","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nι₂ : Type u_2\nR : Type u_4\ninst✝² : CommSemiring R\nM : Type u_8\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : ι → M\nb : ι₂ → M\n⊢ Eq ((PiTensorProduct.tmulEquiv R M) (TensorProduct.tmul R ((PiTensorProduct.tprod R) fun i => a i) ((PiTensorProduct.tprod R) fun i => b i))) ((PiTensorProduct.tprod R) fun i => Sum.elim a b i)","decl":"@[simp]\ntheorem tmulEquiv_apply (a : ι → M) (b : ι₂ → M) :\n    tmulEquiv (ι := ι) (ι₂ := ι₂) R M ((⨂ₜ[R] i, a i) ⊗ₜ[R] ⨂ₜ[R] i, b i) =\n    ⨂ₜ[R] i, Sum.elim a b i :=\n  tmul_apply a b\n\n"}
{"name":"PiTensorProduct.tmulEquiv_symm_apply","module":"Mathlib.LinearAlgebra.PiTensorProduct","initialProofState":"ι : Type u_1\nι₂ : Type u_2\nR : Type u_4\ninst✝² : CommSemiring R\nM : Type u_8\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\na : Sum ι ι₂ → M\n⊢ Eq ((PiTensorProduct.tmulEquiv R M).symm ((PiTensorProduct.tprod R) fun i => a i)) (TensorProduct.tmul R ((PiTensorProduct.tprod R) fun i => a (Sum.inl i)) ((PiTensorProduct.tprod R) fun i => a (Sum.inr i)))","decl":"@[simp]\ntheorem tmulEquiv_symm_apply (a : ι ⊕ ι₂ → M) :\n    (tmulEquiv (ι := ι) (ι₂ := ι₂) R M).symm (⨂ₜ[R] i, a i) =\n    (⨂ₜ[R] i, a (Sum.inl i)) ⊗ₜ[R] ⨂ₜ[R] i, a (Sum.inr i) :=\n  tmulSymm_apply a\n\n"}
