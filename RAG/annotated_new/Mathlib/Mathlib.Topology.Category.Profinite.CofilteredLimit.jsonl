{"name":"Profinite.exists_isClopen_of_cofiltered","module":"Mathlib.Topology.Category.Profinite.CofilteredLimit","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.IsCofiltered J\nF : CategoryTheory.Functor J Profinite\nC : CategoryTheory.Limits.Cone F\nU : Set ↑C.pt.toTop\nhC : CategoryTheory.Limits.IsLimit C\nhU : IsClopen U\n⊢ Exists fun j => Exists fun V => And (IsClopen V) (Eq U (Set.preimage (⇑(C.π.app j)) V))","decl":"/-- If `X` is a cofiltered limit of profinite sets, then any clopen subset of `X` arises from\na clopen set in one of the terms in the limit.\n-/\ntheorem exists_isClopen_of_cofiltered {U : Set C.pt} (hC : IsLimit C) (hU : IsClopen U) :\n    ∃ (j : J) (V : Set (F.obj j)), IsClopen V ∧ U = C.π.app j ⁻¹' V := by\n  -- First, we have the topological basis of the cofiltered limit obtained by pulling back\n  -- clopen sets from the factors in the limit. By continuity, all such sets are again clopen.\n  have hB := TopCat.isTopologicalBasis_cofiltered_limit.{u, v} (F ⋙ Profinite.toTopCat)\n      (Profinite.toTopCat.mapCone C) (isLimitOfPreserves _ hC) (fun j => {W | IsClopen W}) ?_\n      (fun i => isClopen_univ) (fun i U1 U2 hU1 hU2 => hU1.inter hU2) ?_\n  rotate_left\n  · intro i\n    change TopologicalSpace.IsTopologicalBasis {W : Set (F.obj i) | IsClopen W}\n    apply isTopologicalBasis_isClopen\n  · rintro i j f V (hV : IsClopen _)\n    exact ⟨hV.1.preimage ((F ⋙ toTopCat).map f).continuous,\n      hV.2.preimage ((F ⋙ toTopCat).map f).continuous⟩\n    -- Porting note: `<;> continuity` fails\n  -- Using this, since `U` is open, we can write `U` as a union of clopen sets all of which\n  -- are preimages of clopens from the factors in the limit.\n  obtain ⟨S, hS, h⟩ := hB.open_eq_sUnion hU.2\n  clear hB\n  let j : S → J := fun s => (hS s.2).choose\n  let V : ∀ s : S, Set (F.obj (j s)) := fun s => (hS s.2).choose_spec.choose\n  have hV : ∀ s : S, IsClopen (V s) ∧ s.1 = C.π.app (j s) ⁻¹' V s := fun s =>\n    (hS s.2).choose_spec.choose_spec\n\n  -- Since `U` is also closed, hence compact, it is covered by finitely many of the\n  -- clopens constructed in the previous step.\n  have hUo : ∀ (i : ↑S), IsOpen ((fun s ↦ (forget Profinite).map (C.π.app (j s)) ⁻¹' V s) i) := by\n    intro s\n    exact (hV s).1.2.preimage (C.π.app (j s)).continuous\n  have hsU : U ⊆ ⋃ (i : ↑S), (fun s ↦ (forget Profinite).map (C.π.app (j s)) ⁻¹' V s) i := by\n    dsimp only\n    rw [h]\n    rintro x ⟨T, hT, hx⟩\n    refine ⟨_, ⟨⟨T, hT⟩, rfl⟩, ?_⟩\n    dsimp only [forget_map_eq_coe]\n    rwa [← (hV ⟨T, hT⟩).2]\n  have := hU.1.isCompact.elim_finite_subcover (fun s : S => C.π.app (j s) ⁻¹' V s) hUo hsU\n  -- Porting note: same remark as after `hB`\n  -- We thus obtain a finite set `G : Finset J` and a clopen set of `F.obj j` for each\n  -- `j ∈ G` such that `U` is the union of the preimages of these clopen sets.\n  obtain ⟨G, hG⟩ := this\n  -- Since `J` is cofiltered, we can find a single `j0` dominating all the `j ∈ G`.\n  -- Pulling back all of the sets from the previous step to `F.obj j0` and taking a union,\n  -- we obtain a clopen set in `F.obj j0` which works.\n  classical\n  obtain ⟨j0, hj0⟩ := IsCofiltered.inf_objs_exists (G.image j)\n  let f : ∀ s ∈ G, j0 ⟶ j s := fun s hs => (hj0 (Finset.mem_image.mpr ⟨s, hs, rfl⟩)).some\n  let W : S → Set (F.obj j0) := fun s => if hs : s ∈ G then F.map (f s hs) ⁻¹' V s else Set.univ\n  -- Conclude, using the `j0` and the clopen set of `F.obj j0` obtained above.\n  refine ⟨j0, ⋃ (s : S) (_ : s ∈ G), W s, ?_, ?_⟩\n  · apply isClopen_biUnion_finset\n    intro s hs\n    dsimp [W]\n    rw [dif_pos hs]\n    exact ⟨(hV s).1.1.preimage (F.map _).continuous, (hV s).1.2.preimage (F.map _).continuous⟩\n  · ext x\n    constructor\n    · intro hx\n      simp_rw [W, Set.preimage_iUnion, Set.mem_iUnion]\n      obtain ⟨_, ⟨s, rfl⟩, _, ⟨hs, rfl⟩, hh⟩ := hG hx\n      refine ⟨s, hs, ?_⟩\n      rwa [dif_pos hs, ← Set.preimage_comp, ← CompHausLike.coe_comp, ← Functor.map_comp, C.w]\n    · intro hx\n      simp_rw [W, Set.preimage_iUnion, Set.mem_iUnion] at hx\n      obtain ⟨s, hs, hx⟩ := hx\n      rw [h]\n      refine ⟨s.1, s.2, ?_⟩\n      rw [(hV s).2]\n      rwa [dif_pos hs, ← Set.preimage_comp, ← CompHausLike.coe_comp, ← Functor.map_comp, C.w] at hx\n\n"}
{"name":"Profinite.exists_locallyConstant_fin_two","module":"Mathlib.Topology.Category.Profinite.CofilteredLimit","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.IsCofiltered J\nF : CategoryTheory.Functor J Profinite\nC : CategoryTheory.Limits.Cone F\nhC : CategoryTheory.Limits.IsLimit C\nf : LocallyConstant (↑C.pt.toTop) (Fin 2)\n⊢ Exists fun j => Exists fun g => Eq f (LocallyConstant.comap (C.π.app j) g)","decl":"theorem exists_locallyConstant_fin_two (hC : IsLimit C) (f : LocallyConstant C.pt (Fin 2)) :\n    ∃ (j : J) (g : LocallyConstant (F.obj j) (Fin 2)), f = g.comap (C.π.app _) := by\n  let U := f ⁻¹' {0}\n  have hU : IsClopen U := f.isLocallyConstant.isClopen_fiber _\n  obtain ⟨j, V, hV, h⟩ := exists_isClopen_of_cofiltered C hC hU\n  classical\n  use j, LocallyConstant.ofIsClopen hV\n  apply LocallyConstant.locallyConstant_eq_of_fiber_zero_eq\n  simp only [Fin.isValue, Functor.const_obj_obj, LocallyConstant.coe_comap, Set.preimage_comp,\n    LocallyConstant.ofIsClopen_fiber_zero]\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [← h]\n\n"}
{"name":"Profinite.exists_locallyConstant_finite_aux","module":"Mathlib.Topology.Category.Profinite.CofilteredLimit","initialProofState":"J : Type v\ninst✝² : CategoryTheory.SmallCategory J\ninst✝¹ : CategoryTheory.IsCofiltered J\nF : CategoryTheory.Functor J Profinite\nC : CategoryTheory.Limits.Cone F\nα : Type u_1\ninst✝ : Finite α\nhC : CategoryTheory.Limits.IsLimit C\nf : LocallyConstant (↑C.pt.toTop) α\n⊢ Exists fun j => Exists fun g => Eq (LocallyConstant.map (fun a b => ite (Eq a b) 0 1) f) (LocallyConstant.comap (C.π.app j) g)","decl":"open Classical in\ntheorem exists_locallyConstant_finite_aux {α : Type*} [Finite α] (hC : IsLimit C)\n    (f : LocallyConstant C.pt α) : ∃ (j : J) (g : LocallyConstant (F.obj j) (α → Fin 2)),\n      (f.map fun a b => if a = b then (0 : Fin 2) else 1) = g.comap (C.π.app _) := by\n  cases nonempty_fintype α\n  let ι : α → α → Fin 2 := fun x y => if x = y then 0 else 1\n  let ff := (f.map ι).flip\n  have hff := fun a : α => exists_locallyConstant_fin_two _ hC (ff a)\n  choose j g h using hff\n  let G : Finset J := Finset.univ.image j\n  obtain ⟨j0, hj0⟩ := IsCofiltered.inf_objs_exists G\n  have hj : ∀ a, j a ∈ (Finset.univ.image j : Finset J) := by\n    intro a\n    simp only [Finset.mem_image, Finset.mem_univ, true_and, exists_apply_eq_apply]\n  let fs : ∀ a : α, j0 ⟶ j a := fun a => (hj0 (hj a)).some\n  let gg : α → LocallyConstant (F.obj j0) (Fin 2) := fun a => (g a).comap (F.map (fs _))\n  let ggg := LocallyConstant.unflip gg\n  refine ⟨j0, ggg, ?_⟩\n  have : f.map ι = LocallyConstant.unflip (f.map ι).flip := by simp\n  rw [this]; clear this\n  have :\n    LocallyConstant.comap (C.π.app j0) ggg =\n      LocallyConstant.unflip (LocallyConstant.comap (C.π.app j0) ggg).flip := by\n    simp\n  rw [this]; clear this\n  congr 1\n  ext1 a\n  change ff a = _\n  rw [h]\n  dsimp\n  ext1 x\n  change _ = (g a) ((C.π.app j0 ≫ F.map (fs a)) x)\n  rw [C.w]; rfl\n\n"}
{"name":"Profinite.exists_locallyConstant_finite_nonempty","module":"Mathlib.Topology.Category.Profinite.CofilteredLimit","initialProofState":"J : Type v\ninst✝³ : CategoryTheory.SmallCategory J\ninst✝² : CategoryTheory.IsCofiltered J\nF : CategoryTheory.Functor J Profinite\nC : CategoryTheory.Limits.Cone F\nα : Type u_1\ninst✝¹ : Finite α\ninst✝ : Nonempty α\nhC : CategoryTheory.Limits.IsLimit C\nf : LocallyConstant (↑C.pt.toTop) α\n⊢ Exists fun j => Exists fun g => Eq f (LocallyConstant.comap (C.π.app j) g)","decl":"theorem exists_locallyConstant_finite_nonempty {α : Type*} [Finite α] [Nonempty α]\n    (hC : IsLimit C) (f : LocallyConstant C.pt α) :\n    ∃ (j : J) (g : LocallyConstant (F.obj j) α), f = g.comap (C.π.app _) := by\n  inhabit α\n  obtain ⟨j, gg, h⟩ := exists_locallyConstant_finite_aux _ hC f\n  classical\n  let ι : α → α → Fin 2 := fun a b => if a = b then 0 else 1\n  let σ : (α → Fin 2) → α := fun f => if h : ∃ a : α, ι a = f then h.choose else default\n  refine ⟨j, gg.map σ, ?_⟩\n  ext x\n  simp only [Functor.const_obj_obj, LocallyConstant.coe_comap, LocallyConstant.map_apply,\n    Function.comp_apply]\n  dsimp [σ]\n  have h1 : ι (f x) = gg (C.π.app j x) := by\n    change f.map (fun a b => if a = b then (0 : Fin 2) else 1) x = _\n    rw [h]\n    rfl\n  have h2 : ∃ a : α, ι a = gg (C.π.app j x) := ⟨f x, h1⟩\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [dif_pos h2]\n  apply_fun ι\n  · rw [h2.choose_spec]\n    exact h1\n  · intro a b hh\n    have hhh := congr_fun hh a\n    dsimp [ι] at hhh\n    rw [if_pos rfl] at hhh\n    split_ifs at hhh with hh1\n    · exact hh1.symm\n    · exact False.elim (bot_ne_top hhh)\n\n"}
{"name":"Profinite.exists_locallyConstant","module":"Mathlib.Topology.Category.Profinite.CofilteredLimit","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.IsCofiltered J\nF : CategoryTheory.Functor J Profinite\nC : CategoryTheory.Limits.Cone F\nα : Type u_1\nhC : CategoryTheory.Limits.IsLimit C\nf : LocallyConstant (↑C.pt.toTop) α\n⊢ Exists fun j => Exists fun g => Eq f (LocallyConstant.comap (C.π.app j) g)","decl":"/-- Any locally constant function from a cofiltered limit of profinite sets factors through\none of the components. -/\ntheorem exists_locallyConstant {α : Type*} (hC : IsLimit C) (f : LocallyConstant C.pt α) :\n    ∃ (j : J) (g : LocallyConstant (F.obj j) α), f = g.comap (C.π.app _) := by\n  let S := f.discreteQuotient\n  let ff : S → α := f.lift\n  cases isEmpty_or_nonempty S\n  · suffices ∃ j, IsEmpty (F.obj j) by\n      refine this.imp fun j hj => ?_\n      refine ⟨⟨hj.elim, fun A => ?_⟩, ?_⟩\n      · suffices (fun a ↦ IsEmpty.elim hj a) ⁻¹' A = ∅ by\n          rw [this]\n          exact isOpen_empty\n        exact @Set.eq_empty_of_isEmpty _ hj _\n      · ext x\n        exact hj.elim' (C.π.app j x)\n    simp only [← not_nonempty_iff, ← not_forall]\n    intro h\n    haveI : ∀ j : J, Nonempty ((F ⋙ Profinite.toTopCat).obj j) := h\n    haveI : ∀ j : J, T2Space ((F ⋙ Profinite.toTopCat).obj j) := fun j =>\n      (inferInstance : T2Space (F.obj j))\n    haveI : ∀ j : J, CompactSpace ((F ⋙ Profinite.toTopCat).obj j) := fun j =>\n      (inferInstance : CompactSpace (F.obj j))\n    have cond := TopCat.nonempty_limitCone_of_compact_t2_cofiltered_system.{u}\n      (F ⋙ Profinite.toTopCat)\n    suffices Nonempty C.pt from IsEmpty.false (S.proj this.some)\n    let D := Profinite.toTopCat.mapCone C\n    have hD : IsLimit D := isLimitOfPreserves Profinite.toTopCat hC\n    have CD := (hD.conePointUniqueUpToIso (TopCat.limitConeIsLimit.{v, max u v} _)).inv\n    exact cond.map CD\n  · let f' : LocallyConstant C.pt S := ⟨S.proj, S.proj_isLocallyConstant⟩\n    obtain ⟨j, g', hj⟩ := exists_locallyConstant_finite_nonempty _ hC f'\n    refine ⟨j, ⟨ff ∘ g', g'.isLocallyConstant.comp _⟩, ?_⟩\n    ext1 t\n    apply_fun fun e => e t at hj\n    dsimp at hj ⊢\n    rw [← hj]\n    rfl\n\n"}
