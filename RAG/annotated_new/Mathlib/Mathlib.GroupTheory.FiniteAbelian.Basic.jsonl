{"name":"Module.finite_of_fg_torsion","module":"Mathlib.GroupTheory.FiniteAbelian.Basic","initialProofState":"M : Type u\ninst✝² : AddCommGroup M\ninst✝¹ : Module Int M\ninst✝ : Module.Finite Int M\nhM : Module.IsTorsion Int M\n⊢ Finite M","decl":"theorem finite_of_fg_torsion [AddCommGroup M] [Module ℤ M] [Module.Finite ℤ M]\n    (hM : Module.IsTorsion ℤ M) : _root_.Finite M := by\n  rcases Module.equiv_directSum_of_isTorsion hM with ⟨ι, _, p, h, e, ⟨l⟩⟩\n  haveI : ∀ i : ι, NeZero (p i ^ e i).natAbs := fun i =>\n    ⟨Int.natAbs_ne_zero.mpr <| pow_ne_zero (e i) (h i).ne_zero⟩\n  haveI : ∀ i : ι, _root_.Finite <| ℤ ⧸ Submodule.span ℤ {p i ^ e i} := fun i =>\n    Finite.of_equiv _ (p i ^ e i).quotientSpanEquivZMod.symm.toEquiv\n  haveI : _root_.Finite (⨁ i, ℤ ⧸ (Submodule.span ℤ {p i ^ e i} : Submodule ℤ ℤ)) :=\n    Finite.of_equiv _ DFinsupp.equivFunOnFintype.symm\n  exact Finite.of_equiv _ l.symm.toEquiv\n\n"}
{"name":"AddCommGroup.equiv_free_prod_directSum_zmod","module":"Mathlib.GroupTheory.FiniteAbelian.Basic","initialProofState":"G : Type u\ninst✝ : AddCommGroup G\nhG : AddGroup.FG G\n⊢ Exists fun n => Exists fun ι => Exists fun x => Exists fun p => Exists fun x => Exists fun e => Nonempty (AddEquiv G (Prod (Finsupp (Fin n) Int) (DirectSum ι fun i => ZMod (HPow.hPow (p i) (e i)))))","decl":"/-- **Structure theorem of finitely generated abelian groups** : Any finitely generated abelian\ngroup is the product of a power of `ℤ` and a direct sum of some `ZMod (p i ^ e i)` for some\nprime powers `p i ^ e i`. -/\ntheorem equiv_free_prod_directSum_zmod [hG : AddGroup.FG G] :\n    ∃ (n : ℕ) (ι : Type) (_ : Fintype ι) (p : ι → ℕ) (_ : ∀ i, Nat.Prime <| p i) (e : ι → ℕ),\n      Nonempty <| G ≃+ (Fin n →₀ ℤ) × ⨁ i : ι, ZMod (p i ^ e i) := by\n  obtain ⟨n, ι, fι, p, hp, e, ⟨f⟩⟩ :=\n    @Module.equiv_free_prod_directSum _ _ _ _ _ _ _ (Module.Finite.iff_addGroup_fg.mpr hG)\n  refine ⟨n, ι, fι, fun i => (p i).natAbs, fun i => ?_, e, ⟨?_⟩⟩\n  · rw [← Int.prime_iff_natAbs_prime, ← irreducible_iff_prime]; exact hp i\n  exact\n    f.toAddEquiv.trans\n      ((AddEquiv.refl _).prodCongr <|\n        DFinsupp.mapRange.addEquiv fun i =>\n          ((Int.quotientSpanEquivZMod _).trans <|\n              ZMod.ringEquivCongr <| (p i).natAbs_pow _).toAddEquiv)\n\n"}
{"name":"AddCommGroup.equiv_directSum_zmod_of_finite","module":"Mathlib.GroupTheory.FiniteAbelian.Basic","initialProofState":"G : Type u\ninst✝¹ : AddCommGroup G\ninst✝ : Finite G\n⊢ Exists fun ι => Exists fun x => Exists fun p => Exists fun x => Exists fun e => Nonempty (AddEquiv G (DirectSum ι fun i => ZMod (HPow.hPow (p i) (e i))))","decl":"/-- **Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\nsome `ZMod (p i ^ e i)` for some prime powers `p i ^ e i`. -/\ntheorem equiv_directSum_zmod_of_finite [Finite G] :\n    ∃ (ι : Type) (_ : Fintype ι) (p : ι → ℕ) (_ : ∀ i, Nat.Prime <| p i) (e : ι → ℕ),\n      Nonempty <| G ≃+ ⨁ i : ι, ZMod (p i ^ e i) := by\n  cases nonempty_fintype G\n  obtain ⟨n, ι, fι, p, hp, e, ⟨f⟩⟩ := equiv_free_prod_directSum_zmod G\n  cases' n with n\n  · have : Unique (Fin Nat.zero →₀ ℤ) :=\n      { uniq := by simp only [eq_iff_true_of_subsingleton]; trivial }\n    exact ⟨ι, fι, p, hp, e, ⟨f.trans AddEquiv.uniqueProd⟩⟩\n  · haveI := @Fintype.prodLeft _ _ _ (Fintype.ofEquiv G f.toEquiv) _\n    exact\n      (Fintype.ofSurjective (fun f : Fin n.succ →₀ ℤ => f 0) fun a =>\n            ⟨Finsupp.single 0 a, Finsupp.single_eq_same⟩).false.elim\n\n"}
{"name":"AddCommGroup.equiv_directSum_zmod_of_finite'","module":"Mathlib.GroupTheory.FiniteAbelian.Basic","initialProofState":"G : Type u_1\ninst✝¹ : AddCommGroup G\ninst✝ : Finite G\n⊢ Exists fun ι => Exists fun x => Exists fun n => And (∀ (i : ι), LT.lt 1 (n i)) (Nonempty (AddEquiv G (DirectSum ι fun i => ZMod (n i))))","decl":"/-- **Structure theorem of finite abelian groups** : Any finite abelian group is a direct sum of\nsome `ZMod (n i)` for some natural numbers `n i > 1`. -/\nlemma equiv_directSum_zmod_of_finite' (G : Type*) [AddCommGroup G] [Finite G] :\n    ∃ (ι : Type) (_ : Fintype ι) (n : ι → ℕ),\n      (∀ i, 1 < n i) ∧ Nonempty (G ≃+ ⨁ i, ZMod (n i)) := by\n  classical\n  obtain ⟨ι, hι, p, hp, n, ⟨e⟩⟩ := AddCommGroup.equiv_directSum_zmod_of_finite G\n  refine ⟨{i : ι // n i ≠ 0}, inferInstance, fun i ↦ p i ^ n i, ?_,\n    ⟨e.trans (directSumNeZeroMulEquiv ι _ _).symm⟩⟩\n  rintro ⟨i, hi⟩\n  exact one_lt_pow₀ (hp _).one_lt hi\n\n"}
{"name":"AddCommGroup.finite_of_fg_torsion","module":"Mathlib.GroupTheory.FiniteAbelian.Basic","initialProofState":"G : Type u\ninst✝ : AddCommGroup G\nhG' : AddGroup.FG G\nhG : AddMonoid.IsTorsion G\n⊢ Finite G","decl":"theorem finite_of_fg_torsion [hG' : AddGroup.FG G] (hG : AddMonoid.IsTorsion G) : Finite G :=\n  @Module.finite_of_fg_torsion _ _ _ (Module.Finite.iff_addGroup_fg.mpr hG') <|\n    AddMonoid.isTorsion_iff_isTorsion_int.mp hG\n\n"}
{"name":"CommGroup.finite_of_fg_torsion","module":"Mathlib.GroupTheory.FiniteAbelian.Basic","initialProofState":"G : Type u\ninst✝¹ : CommGroup G\ninst✝ : Group.FG G\nhG : Monoid.IsTorsion G\n⊢ Finite G","decl":"theorem finite_of_fg_torsion [CommGroup G] [Group.FG G] (hG : Monoid.IsTorsion G) : Finite G :=\n  @Finite.of_equiv _ _ (AddCommGroup.finite_of_fg_torsion (Additive G) hG) Multiplicative.ofAdd\n\n"}
{"name":"CommGroup.equiv_prod_multiplicative_zmod_of_finite","module":"Mathlib.GroupTheory.FiniteAbelian.Basic","initialProofState":"G : Type u_1\ninst✝¹ : CommGroup G\ninst✝ : Finite G\n⊢ Exists fun ι => Exists fun x => Exists fun n => And (∀ (i : ι), LT.lt 1 (n i)) (Nonempty (MulEquiv G ((i : ι) → Multiplicative (ZMod (n i)))))","decl":"/-- The **Structure Theorem For Finite Abelian Groups** in a multiplicative version:\nA finite commutative group `G` is isomorphic to a finite product of finite cyclic groups. -/\ntheorem equiv_prod_multiplicative_zmod_of_finite (G : Type*) [CommGroup G] [Finite G] :\n    ∃ (ι : Type) (_ : Fintype ι) (n : ι → ℕ),\n       (∀ (i : ι), 1 < n i) ∧ Nonempty (G ≃* ((i : ι) → Multiplicative (ZMod (n i)))) := by\n  obtain ⟨ι, inst, n, h₁, h₂⟩ := AddCommGroup.equiv_directSum_zmod_of_finite' (Additive G)\n  exact ⟨ι, inst, n, h₁, ⟨MulEquiv.toAdditive.symm <| h₂.some.trans <|\n    (DirectSum.addEquivProd _).trans <| MulEquiv.toAdditive'' <| MulEquiv.piMultiplicative _⟩⟩\n\n"}
