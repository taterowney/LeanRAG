{"name":"MeasureTheory.weightedSMul_apply","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nx : F\n‚ä¢ Eq ((MeasureTheory.weightedSMul Œº s) x) (HSMul.hSMul (Œº s).toReal x)","decl":"theorem weightedSMul_apply {m : MeasurableSpace Œ±} (Œº : Measure Œ±) (s : Set Œ±) (x : F) :\n    weightedSMul Œº s x = (Œº s).toReal ‚Ä¢ x := by simp [weightedSMul]\n\n"}
{"name":"MeasureTheory.weightedSMul_zero_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\n‚ä¢ Eq (MeasureTheory.weightedSMul 0) 0","decl":"@[simp]\ntheorem weightedSMul_zero_measure {m : MeasurableSpace Œ±} :\n    weightedSMul (0 : Measure Œ±) = (0 : Set Œ± ‚Üí F ‚ÜíL[‚Ñù] F) := by ext1; simp [weightedSMul]\n\n"}
{"name":"MeasureTheory.weightedSMul_empty","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\n‚ä¢ Eq (MeasureTheory.weightedSMul Œº EmptyCollection.emptyCollection) 0","decl":"@[simp]\ntheorem weightedSMul_empty {m : MeasurableSpace Œ±} (Œº : Measure Œ±) :\n    weightedSMul Œº ‚àÖ = (0 : F ‚ÜíL[‚Ñù] F) := by ext1 x; rw [weightedSMul_apply]; simp\n\n"}
{"name":"MeasureTheory.weightedSMul_add_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº ŒΩ : MeasureTheory.Measure Œ±\ns : Set Œ±\nhŒºs : Ne (Œº s) Top.top\nhŒΩs : Ne (ŒΩ s) Top.top\n‚ä¢ Eq (MeasureTheory.weightedSMul (HAdd.hAdd Œº ŒΩ) s) (HAdd.hAdd (MeasureTheory.weightedSMul Œº s) (MeasureTheory.weightedSMul ŒΩ s))","decl":"theorem weightedSMul_add_measure {m : MeasurableSpace Œ±} (Œº ŒΩ : Measure Œ±) {s : Set Œ±}\n    (hŒºs : Œº s ‚â† ‚àû) (hŒΩs : ŒΩ s ‚â† ‚àû) :\n    (weightedSMul (Œº + ŒΩ) s : F ‚ÜíL[‚Ñù] F) = weightedSMul Œº s + weightedSMul ŒΩ s := by\n  ext1 x\n  push_cast\n  simp_rw [Pi.add_apply, weightedSMul_apply]\n  push_cast\n  rw [Pi.add_apply, ENNReal.toReal_add hŒºs hŒΩs, add_smul]\n\n"}
{"name":"MeasureTheory.weightedSMul_smul_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nc : ENNReal\ns : Set Œ±\n‚ä¢ Eq (MeasureTheory.weightedSMul (HSMul.hSMul c Œº) s) (HSMul.hSMul c.toReal (MeasureTheory.weightedSMul Œº s))","decl":"theorem weightedSMul_smul_measure {m : MeasurableSpace Œ±} (Œº : Measure Œ±) (c : ‚Ñù‚â•0‚àû) {s : Set Œ±} :\n    (weightedSMul (c ‚Ä¢ Œº) s : F ‚ÜíL[‚Ñù] F) = c.toReal ‚Ä¢ weightedSMul Œº s := by\n  ext1 x\n  push_cast\n  simp_rw [Pi.smul_apply, weightedSMul_apply]\n  push_cast\n  simp_rw [Pi.smul_apply, smul_eq_mul, toReal_mul, smul_smul]\n\n"}
{"name":"MeasureTheory.weightedSMul_congr","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns t : Set Œ±\nhst : Eq (Œº s) (Œº t)\n‚ä¢ Eq (MeasureTheory.weightedSMul Œº s) (MeasureTheory.weightedSMul Œº t)","decl":"theorem weightedSMul_congr (s t : Set Œ±) (hst : Œº s = Œº t) :\n    (weightedSMul Œº s : F ‚ÜíL[‚Ñù] F) = weightedSMul Œº t := by\n  ext1 x; simp_rw [weightedSMul_apply]; congr 2\n\n"}
{"name":"MeasureTheory.weightedSMul_null","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nh_zero : Eq (Œº s) 0\n‚ä¢ Eq (MeasureTheory.weightedSMul Œº s) 0","decl":"theorem weightedSMul_null {s : Set Œ±} (h_zero : Œº s = 0) : (weightedSMul Œº s : F ‚ÜíL[‚Ñù] F) = 0 := by\n  ext1 x; rw [weightedSMul_apply, h_zero]; simp\n\n"}
{"name":"MeasureTheory.weightedSMul_union'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns t : Set Œ±\nht : MeasurableSet t\nhs_finite : Ne (Œº s) Top.top\nht_finite : Ne (Œº t) Top.top\nhdisj : Disjoint s t\n‚ä¢ Eq (MeasureTheory.weightedSMul Œº (Union.union s t)) (HAdd.hAdd (MeasureTheory.weightedSMul Œº s) (MeasureTheory.weightedSMul Œº t))","decl":"theorem weightedSMul_union' (s t : Set Œ±) (ht : MeasurableSet t) (hs_finite : Œº s ‚â† ‚àû)\n    (ht_finite : Œº t ‚â† ‚àû) (hdisj : Disjoint s t) :\n    (weightedSMul Œº (s ‚à™ t) : F ‚ÜíL[‚Ñù] F) = weightedSMul Œº s + weightedSMul Œº t := by\n  ext1 x\n  simp_rw [add_apply, weightedSMul_apply, measure_union hdisj ht,\n    ENNReal.toReal_add hs_finite ht_finite, add_smul]\n\n"}
{"name":"MeasureTheory.weightedSMul_union","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns t : Set Œ±\n_hs : MeasurableSet s\nht : MeasurableSet t\nhs_finite : Ne (Œº s) Top.top\nht_finite : Ne (Œº t) Top.top\nhdisj : Disjoint s t\n‚ä¢ Eq (MeasureTheory.weightedSMul Œº (Union.union s t)) (HAdd.hAdd (MeasureTheory.weightedSMul Œº s) (MeasureTheory.weightedSMul Œº t))","decl":"@[nolint unusedArguments]\ntheorem weightedSMul_union (s t : Set Œ±) (_hs : MeasurableSet s) (ht : MeasurableSet t)\n    (hs_finite : Œº s ‚â† ‚àû) (ht_finite : Œº t ‚â† ‚àû) (hdisj : Disjoint s t) :\n    (weightedSMul Œº (s ‚à™ t) : F ‚ÜíL[‚Ñù] F) = weightedSMul Œº s + weightedSMul Œº t :=\n  weightedSMul_union' s t ht hs_finite ht_finite hdisj\n\n"}
{"name":"MeasureTheory.weightedSMul_smul","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nF : Type u_3\nùïú : Type u_4\ninst‚úù‚Å¥ : NormedAddCommGroup F\ninst‚úù¬≥ : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : NormedField ùïú\ninst‚úù¬π : NormedSpace ùïú F\ninst‚úù : SMulCommClass Real ùïú F\nc : ùïú\ns : Set Œ±\nx : F\n‚ä¢ Eq ((MeasureTheory.weightedSMul Œº s) (HSMul.hSMul c x)) (HSMul.hSMul c ((MeasureTheory.weightedSMul Œº s) x))","decl":"theorem weightedSMul_smul [NormedField ùïú] [NormedSpace ùïú F] [SMulCommClass ‚Ñù ùïú F] (c : ùïú)\n    (s : Set Œ±) (x : F) : weightedSMul Œº s (c ‚Ä¢ x) = c ‚Ä¢ weightedSMul Œº s x := by\n  simp_rw [weightedSMul_apply, smul_comm]\n\n"}
{"name":"MeasureTheory.norm_weightedSMul_le","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\n‚ä¢ LE.le (Norm.norm (MeasureTheory.weightedSMul Œº s)) (Œº s).toReal","decl":"theorem norm_weightedSMul_le (s : Set Œ±) : ‚Äñ(weightedSMul Œº s : F ‚ÜíL[‚Ñù] F)‚Äñ ‚â§ (Œº s).toReal :=\n  calc\n    ‚Äñ(weightedSMul Œº s : F ‚ÜíL[‚Ñù] F)‚Äñ = ‚Äñ(Œº s).toReal‚Äñ * ‚ÄñContinuousLinearMap.id ‚Ñù F‚Äñ :=\n      norm_smul (Œº s).toReal (ContinuousLinearMap.id ‚Ñù F)\n    _ ‚â§ ‚Äñ(Œº s).toReal‚Äñ :=\n      ((mul_le_mul_of_nonneg_left norm_id_le (norm_nonneg _)).trans (mul_one _).le)\n    _ = abs (Œº s).toReal := Real.norm_eq_abs _\n    _ = (Œº s).toReal := abs_eq_self.mpr ENNReal.toReal_nonneg\n\n"}
{"name":"MeasureTheory.dominatedFinMeasAdditive_weightedSMul","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nx‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\n‚ä¢ MeasureTheory.DominatedFinMeasAdditive Œº (MeasureTheory.weightedSMul Œº) 1","decl":"theorem dominatedFinMeasAdditive_weightedSMul {_ : MeasurableSpace Œ±} (Œº : Measure Œ±) :\n    DominatedFinMeasAdditive Œº (weightedSMul Œº : Set Œ± ‚Üí F ‚ÜíL[‚Ñù] F) 1 :=\n  ‚ü®weightedSMul_union, fun s _ _ => (norm_weightedSMul_le s).trans (one_mul _).symm.le‚ü©\n\n"}
{"name":"MeasureTheory.weightedSMul_nonneg","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nx : Real\nhx : LE.le 0 x\n‚ä¢ LE.le 0 ((MeasureTheory.weightedSMul Œº s) x)","decl":"theorem weightedSMul_nonneg (s : Set Œ±) (x : ‚Ñù) (hx : 0 ‚â§ x) : 0 ‚â§ weightedSMul Œº s x := by\n  simp only [weightedSMul, Algebra.id.smul_eq_mul, coe_smul', _root_.id, coe_id', Pi.smul_apply]\n  exact mul_nonneg toReal_nonneg hx\n\n"}
{"name":"MeasureTheory.SimpleFunc.posPart_map_norm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nf : MeasureTheory.SimpleFunc Œ± Real\n‚ä¢ Eq (MeasureTheory.SimpleFunc.map Norm.norm f.posPart) f.posPart","decl":"theorem posPart_map_norm (f : Œ± ‚Üí‚Çõ ‚Ñù) : (posPart f).map norm = posPart f := by\n  ext; rw [map_apply, Real.norm_eq_abs, abs_of_nonneg]; exact le_max_right _ _\n\n"}
{"name":"MeasureTheory.SimpleFunc.negPart_map_norm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nf : MeasureTheory.SimpleFunc Œ± Real\n‚ä¢ Eq (MeasureTheory.SimpleFunc.map Norm.norm f.negPart) f.negPart","decl":"theorem negPart_map_norm (f : Œ± ‚Üí‚Çõ ‚Ñù) : (negPart f).map norm = negPart f := by\n  rw [negPart]; exact posPart_map_norm _\n\n"}
{"name":"MeasureTheory.SimpleFunc.posPart_sub_negPart","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nf : MeasureTheory.SimpleFunc Œ± Real\n‚ä¢ Eq (HSub.hSub f.posPart f.negPart) f","decl":"theorem posPart_sub_negPart (f : Œ± ‚Üí‚Çõ ‚Ñù) : f.posPart - f.negPart = f := by\n  simp only [posPart, negPart]\n  ext a\n  rw [coe_sub]\n  exact max_zero_sub_eq_self (f a)\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_def","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nx‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : MeasureTheory.SimpleFunc Œ± F\n‚ä¢ Eq (MeasureTheory.SimpleFunc.integral Œº f) (MeasureTheory.SimpleFunc.setToSimpleFunc (MeasureTheory.weightedSMul Œº) f)","decl":"theorem integral_def {_ : MeasurableSpace Œ±} (Œº : Measure Œ±) (f : Œ± ‚Üí‚Çõ F) :\n    f.integral Œº = f.setToSimpleFunc (weightedSMul Œº) := rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_eq","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : MeasureTheory.SimpleFunc Œ± F\n‚ä¢ Eq (MeasureTheory.SimpleFunc.integral Œº f) (f.range.sum fun x => HSMul.hSMul (Œº (Set.preimage (‚áëf) (Singleton.singleton x))).toReal x)","decl":"theorem integral_eq {m : MeasurableSpace Œ±} (Œº : Measure Œ±) (f : Œ± ‚Üí‚Çõ F) :\n    f.integral Œº = ‚àë x ‚àà f.range, (Œº (f ‚Åª¬π' {x})).toReal ‚Ä¢ x := by\n  simp [integral, setToSimpleFunc, weightedSMul_apply]\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_eq_sum_filter","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nF : Type u_3\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\ninst‚úù : DecidablePred fun x => Ne x 0\nm : MeasurableSpace Œ±\nf : MeasureTheory.SimpleFunc Œ± F\nŒº : MeasureTheory.Measure Œ±\n‚ä¢ Eq (MeasureTheory.SimpleFunc.integral Œº f) ((Finset.filter (fun x => Ne x 0) f.range).sum fun x => HSMul.hSMul (Œº (Set.preimage (‚áëf) (Singleton.singleton x))).toReal x)","decl":"theorem integral_eq_sum_filter [DecidablePred fun x : F => x ‚â† 0] {m : MeasurableSpace Œ±}\n    (f : Œ± ‚Üí‚Çõ F) (Œº : Measure Œ±) :\n    f.integral Œº = ‚àë x ‚àà {x ‚àà f.range | x ‚â† 0}, (Œº (f ‚Åª¬π' {x})).toReal ‚Ä¢ x := by\n  simp_rw [integral_def, setToSimpleFunc_eq_sum_filter, weightedSMul_apply]\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_eq_sum_of_subset","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nF : Type u_3\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : DecidablePred fun x => Ne x 0\nf : MeasureTheory.SimpleFunc Œ± F\ns : Finset F\nhs : HasSubset.Subset (Finset.filter (fun x => Ne x 0) f.range) s\n‚ä¢ Eq (MeasureTheory.SimpleFunc.integral Œº f) (s.sum fun x => HSMul.hSMul (Œº (Set.preimage (‚áëf) (Singleton.singleton x))).toReal x)","decl":"/-- The Bochner integral is equal to a sum over any set that includes `f.range` (except `0`). -/\ntheorem integral_eq_sum_of_subset [DecidablePred fun x : F => x ‚â† 0] {f : Œ± ‚Üí‚Çõ F} {s : Finset F}\n    (hs : {x ‚àà f.range | x ‚â† 0} ‚äÜ s) :\n    f.integral Œº = ‚àë x ‚àà s, (Œº (f ‚Åª¬π' {x})).toReal ‚Ä¢ x := by\n  rw [SimpleFunc.integral_eq_sum_filter, Finset.sum_subset hs]\n  rintro x - hx; rw [Finset.mem_filter, not_and_or, Ne, Classical.not_not] at hx\n  -- Porting note: reordered for clarity\n  rcases hx.symm with (rfl | hx)\n  ¬∑ simp\n  rw [SimpleFunc.mem_range] at hx\n  -- Porting note: added\n  simp only [Set.mem_range, not_exists] at hx\n  rw [preimage_eq_empty] <;> simp [Set.disjoint_singleton_left, hx]\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_const","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ny : F\n‚ä¢ Eq (MeasureTheory.SimpleFunc.integral Œº (MeasureTheory.SimpleFunc.const Œ± y)) (HSMul.hSMul (Œº Set.univ).toReal y)","decl":"@[simp]\ntheorem integral_const {m : MeasurableSpace Œ±} (Œº : Measure Œ±) (y : F) :\n    (const Œ± y).integral Œº = (Œº univ).toReal ‚Ä¢ y := by\n  classical\n  calc\n    (const Œ± y).integral Œº = ‚àë z ‚àà {y}, (Œº (const Œ± y ‚Åª¬π' {z})).toReal ‚Ä¢ z :=\n      integral_eq_sum_of_subset <| (filter_subset _ _).trans (range_const_subset _ _)\n    _ = (Œº univ).toReal ‚Ä¢ y := by simp [Set.preimage] -- Porting note: added `Set.preimage`\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_piecewise_zero","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nF : Type u_3\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nf : MeasureTheory.SimpleFunc Œ± F\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nhs : MeasurableSet s\n‚ä¢ Eq (MeasureTheory.SimpleFunc.integral Œº (MeasureTheory.SimpleFunc.piecewise s hs f 0)) (MeasureTheory.SimpleFunc.integral (Œº.restrict s) f)","decl":"@[simp]\ntheorem integral_piecewise_zero {m : MeasurableSpace Œ±} (f : Œ± ‚Üí‚Çõ F) (Œº : Measure Œ±) {s : Set Œ±}\n    (hs : MeasurableSet s) : (piecewise s hs f 0).integral Œº = f.integral (Œº.restrict s) := by\n  classical\n  refine (integral_eq_sum_of_subset ?_).trans\n      ((sum_congr rfl fun y hy => ?_).trans (integral_eq_sum_filter _ _).symm)\n  ¬∑ intro y hy\n    simp only [mem_filter, mem_range, coe_piecewise, coe_zero, piecewise_eq_indicator,\n      mem_range_indicator] at *\n    rcases hy with ‚ü®‚ü®rfl, -‚ü© | ‚ü®x, -, rfl‚ü©, h‚ÇÄ‚ü©\n    exacts [(h‚ÇÄ rfl).elim, ‚ü®Set.mem_range_self _, h‚ÇÄ‚ü©]\n  ¬∑ dsimp\n    rw [Set.piecewise_eq_indicator, indicator_preimage_of_not_mem,\n      Measure.restrict_apply (f.measurableSet_preimage _)]\n    exact fun h‚ÇÄ => (mem_filter.1 hy).2 (Eq.symm h‚ÇÄ)\n\n"}
{"name":"MeasureTheory.SimpleFunc.map_integral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : MeasureTheory.SimpleFunc Œ± E\ng : E ‚Üí F\nhf : MeasureTheory.Integrable (‚áëf) Œº\nhg : Eq (g 0) 0\n‚ä¢ Eq (MeasureTheory.SimpleFunc.integral Œº (MeasureTheory.SimpleFunc.map g f)) (f.range.sum fun x => HSMul.hSMul (Œº (Set.preimage (‚áëf) (Singleton.singleton x))).toReal (g x))","decl":"/-- Calculate the integral of `g ‚àò f : Œ± ‚Üí‚Çõ F`, where `f` is an integrable function from `Œ±` to `E`\n    and `g` is a function from `E` to `F`. We require `g 0 = 0` so that `g ‚àò f` is integrable. -/\ntheorem map_integral (f : Œ± ‚Üí‚Çõ E) (g : E ‚Üí F) (hf : Integrable f Œº) (hg : g 0 = 0) :\n    (f.map g).integral Œº = ‚àë x ‚àà f.range, ENNReal.toReal (Œº (f ‚Åª¬π' {x})) ‚Ä¢ g x :=\n  map_setToSimpleFunc _ weightedSMul_union hf hg\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_eq_lintegral'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : MeasureTheory.SimpleFunc Œ± E\ng : E ‚Üí ENNReal\nhf : MeasureTheory.Integrable (‚áëf) Œº\nhg0 : Eq (g 0) 0\nht : ‚àÄ (b : E), Ne (g b) Top.top\n‚ä¢ Eq (MeasureTheory.SimpleFunc.integral Œº (MeasureTheory.SimpleFunc.map (Function.comp ENNReal.toReal g) f)) (MeasureTheory.lintegral Œº fun a => g (f a)).toReal","decl":"/-- `SimpleFunc.integral` and `SimpleFunc.lintegral` agree when the integrand has type\n    `Œ± ‚Üí‚Çõ ‚Ñù‚â•0‚àû`. But since `‚Ñù‚â•0‚àû` is not a `NormedSpace`, we need some form of coercion.\n    See `integral_eq_lintegral` for a simpler version. -/\ntheorem integral_eq_lintegral' {f : Œ± ‚Üí‚Çõ E} {g : E ‚Üí ‚Ñù‚â•0‚àû} (hf : Integrable f Œº) (hg0 : g 0 = 0)\n    (ht : ‚àÄ b, g b ‚â† ‚àû) :\n    (f.map (ENNReal.toReal ‚àò g)).integral Œº = ENNReal.toReal (‚à´‚Åª a, g (f a) ‚àÇŒº) := by\n  have hf' : f.FinMeasSupp Œº := integrable_iff_finMeasSupp.1 hf\n  simp only [‚Üê map_apply g f, lintegral_eq_lintegral]\n  rw [map_integral f _ hf, map_lintegral, ENNReal.toReal_sum]\n  ¬∑ refine Finset.sum_congr rfl fun b _ => ?_\n    -- Porting note: added `Function.comp_apply`\n    rw [smul_eq_mul, toReal_mul, mul_comm, Function.comp_apply]\n  ¬∑ rintro a -\n    by_cases a0 : a = 0\n    ¬∑ rw [a0, hg0, zero_mul]; exact WithTop.zero_ne_top\n    ¬∑ apply mul_ne_top (ht a) (hf'.meas_preimage_singleton_ne_zero a0).ne\n  ¬∑ simp [hg0]\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_congr","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedSpace Real E\nf g : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\nh : (MeasureTheory.ae Œº).EventuallyEq ‚áëf ‚áëg\n‚ä¢ Eq (MeasureTheory.SimpleFunc.integral Œº f) (MeasureTheory.SimpleFunc.integral Œº g)","decl":"theorem integral_congr {f g : Œ± ‚Üí‚Çõ E} (hf : Integrable f Œº) (h : f =·µê[Œº] g) :\n    f.integral Œº = g.integral Œº :=\n  setToSimpleFunc_congr (weightedSMul Œº) (fun _ _ => weightedSMul_null) weightedSMul_union hf h\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_eq_lintegral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : MeasureTheory.SimpleFunc Œ± Real\nhf : MeasureTheory.Integrable (‚áëf) Œº\nh_pos : (MeasureTheory.ae Œº).EventuallyLE 0 ‚áëf\n‚ä¢ Eq (MeasureTheory.SimpleFunc.integral Œº f) (MeasureTheory.lintegral Œº fun a => ENNReal.ofReal (f a)).toReal","decl":"/-- `SimpleFunc.bintegral` and `SimpleFunc.integral` agree when the integrand has type\n    `Œ± ‚Üí‚Çõ ‚Ñù‚â•0‚àû`. But since `‚Ñù‚â•0‚àû` is not a `NormedSpace`, we need some form of coercion. -/\ntheorem integral_eq_lintegral {f : Œ± ‚Üí‚Çõ ‚Ñù} (hf : Integrable f Œº) (h_pos : 0 ‚â§·µê[Œº] f) :\n    f.integral Œº = ENNReal.toReal (‚à´‚Åª a, ENNReal.ofReal (f a) ‚àÇŒº) := by\n  have : f =·µê[Œº] f.map (ENNReal.toReal ‚àò ENNReal.ofReal) :=\n    h_pos.mono fun a h => (ENNReal.toReal_ofReal h).symm\n  rw [‚Üê integral_eq_lintegral' hf]\n  exacts [integral_congr hf this, ENNReal.ofReal_zero, fun b => ENNReal.ofReal_ne_top]\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_add","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedSpace Real E\nf g : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\nhg : MeasureTheory.Integrable (‚áëg) Œº\n‚ä¢ Eq (MeasureTheory.SimpleFunc.integral Œº (HAdd.hAdd f g)) (HAdd.hAdd (MeasureTheory.SimpleFunc.integral Œº f) (MeasureTheory.SimpleFunc.integral Œº g))","decl":"theorem integral_add {f g : Œ± ‚Üí‚Çõ E} (hf : Integrable f Œº) (hg : Integrable g Œº) :\n    integral Œº (f + g) = integral Œº f + integral Œº g :=\n  setToSimpleFunc_add _ weightedSMul_union hf hg\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_neg","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedSpace Real E\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\n‚ä¢ Eq (MeasureTheory.SimpleFunc.integral Œº (Neg.neg f)) (Neg.neg (MeasureTheory.SimpleFunc.integral Œº f))","decl":"theorem integral_neg {f : Œ± ‚Üí‚Çõ E} (hf : Integrable f Œº) : integral Œº (-f) = -integral Œº f :=\n  setToSimpleFunc_neg _ weightedSMul_union hf\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_sub","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedSpace Real E\nf g : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\nhg : MeasureTheory.Integrable (‚áëg) Œº\n‚ä¢ Eq (MeasureTheory.SimpleFunc.integral Œº (HSub.hSub f g)) (HSub.hSub (MeasureTheory.SimpleFunc.integral Œº f) (MeasureTheory.SimpleFunc.integral Œº g))","decl":"theorem integral_sub {f g : Œ± ‚Üí‚Çõ E} (hf : Integrable f Œº) (hg : Integrable g Œº) :\n    integral Œº (f - g) = integral Œº f - integral Œº g :=\n  setToSimpleFunc_sub _ weightedSMul_union hf hg\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_smul","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\nùïú : Type u_4\ninst‚úù‚Å¥ : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : NormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : SMulCommClass Real ùïú E\nc : ùïú\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\n‚ä¢ Eq (MeasureTheory.SimpleFunc.integral Œº (HSMul.hSMul c f)) (HSMul.hSMul c (MeasureTheory.SimpleFunc.integral Œº f))","decl":"theorem integral_smul (c : ùïú) {f : Œ± ‚Üí‚Çõ E} (hf : Integrable f Œº) :\n    integral Œº (c ‚Ä¢ f) = c ‚Ä¢ integral Œº f :=\n  setToSimpleFunc_smul _ weightedSMul_union weightedSMul_smul c hf\n\n"}
{"name":"MeasureTheory.SimpleFunc.norm_setToSimpleFunc_le_integral_norm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\nF : Type u_3\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedSpace Real E\nT : Set Œ± ‚Üí ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT_norm : ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LT.lt (Œº s) Top.top ‚Üí LE.le (Norm.norm (T s)) (HMul.hMul C (Œº s).toReal)\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\n‚ä¢ LE.le (Norm.norm (MeasureTheory.SimpleFunc.setToSimpleFunc T f)) (HMul.hMul C (MeasureTheory.SimpleFunc.integral Œº (MeasureTheory.SimpleFunc.map Norm.norm f)))","decl":"theorem norm_setToSimpleFunc_le_integral_norm (T : Set Œ± ‚Üí E ‚ÜíL[‚Ñù] F) {C : ‚Ñù}\n    (hT_norm : ‚àÄ s, MeasurableSet s ‚Üí Œº s < ‚àû ‚Üí ‚ÄñT s‚Äñ ‚â§ C * (Œº s).toReal) {f : Œ± ‚Üí‚Çõ E}\n    (hf : Integrable f Œº) : ‚Äñf.setToSimpleFunc T‚Äñ ‚â§ C * (f.map norm).integral Œº :=\n  calc\n    ‚Äñf.setToSimpleFunc T‚Äñ ‚â§ C * ‚àë x ‚àà f.range, ENNReal.toReal (Œº (f ‚Åª¬π' {x})) * ‚Äñx‚Äñ :=\n      norm_setToSimpleFunc_le_sum_mul_norm_of_integrable T hT_norm f hf\n    _ = C * (f.map norm).integral Œº := by\n      rw [map_integral f norm hf norm_zero]; simp_rw [smul_eq_mul]\n\n"}
{"name":"MeasureTheory.SimpleFunc.norm_integral_le_integral_norm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedSpace Real E\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) Œº\n‚ä¢ LE.le (Norm.norm (MeasureTheory.SimpleFunc.integral Œº f)) (MeasureTheory.SimpleFunc.integral Œº (MeasureTheory.SimpleFunc.map Norm.norm f))","decl":"theorem norm_integral_le_integral_norm (f : Œ± ‚Üí‚Çõ E) (hf : Integrable f Œº) :\n    ‚Äñf.integral Œº‚Äñ ‚â§ (f.map norm).integral Œº := by\n  refine (norm_setToSimpleFunc_le_integral_norm _ (fun s _ _ => ?_) hf).trans (one_mul _).le\n  exact (norm_weightedSMul_le s).trans (one_mul _).symm.le\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_add_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedSpace Real E\nŒΩ : MeasureTheory.Measure Œ±\nf : MeasureTheory.SimpleFunc Œ± E\nhf : MeasureTheory.Integrable (‚áëf) (HAdd.hAdd Œº ŒΩ)\n‚ä¢ Eq (MeasureTheory.SimpleFunc.integral (HAdd.hAdd Œº ŒΩ) f) (HAdd.hAdd (MeasureTheory.SimpleFunc.integral Œº f) (MeasureTheory.SimpleFunc.integral ŒΩ f))","decl":"theorem integral_add_measure {ŒΩ} (f : Œ± ‚Üí‚Çõ E) (hf : Integrable f (Œº + ŒΩ)) :\n    f.integral (Œº + ŒΩ) = f.integral Œº + f.integral ŒΩ := by\n  simp_rw [integral_def]\n  refine setToSimpleFunc_add_left'\n    (weightedSMul Œº) (weightedSMul ŒΩ) (weightedSMul (Œº + ŒΩ)) (fun s _ hŒºŒΩs => ?_) hf\n  rw [lt_top_iff_ne_top, Measure.coe_add, Pi.add_apply, ENNReal.add_ne_top] at hŒºŒΩs\n  rw [weightedSMul_add_measure _ _ hŒºŒΩs.1 hŒºŒΩs.2]\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.norm_eq_integral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq (Norm.norm f) (MeasureTheory.SimpleFunc.integral Œº (MeasureTheory.SimpleFunc.map Norm.norm (MeasureTheory.Lp.simpleFunc.toSimpleFunc f)))","decl":"theorem norm_eq_integral (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) : ‚Äñf‚Äñ = ((toSimpleFunc f).map norm).integral Œº := by\n  rw [norm_eq_sum_mul f, (toSimpleFunc f).map_integral norm (SimpleFunc.integrable f) norm_zero]\n  simp_rw [smul_eq_mul]\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.coe_posPart","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc Real 1 Œº) x\n‚ä¢ Eq (‚Üë(MeasureTheory.L1.SimpleFunc.posPart f)) (MeasureTheory.Lp.posPart ‚Üëf)","decl":"@[norm_cast]\ntheorem coe_posPart (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] ‚Ñù) : (posPart f : Œ± ‚Üí‚ÇÅ[Œº] ‚Ñù) = Lp.posPart (f : Œ± ‚Üí‚ÇÅ[Œº] ‚Ñù) := rfl\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.coe_negPart","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc Real 1 Œº) x\n‚ä¢ Eq (‚Üë(MeasureTheory.L1.SimpleFunc.negPart f)) (MeasureTheory.Lp.negPart ‚Üëf)","decl":"@[norm_cast]\ntheorem coe_negPart (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] ‚Ñù) : (negPart f : Œ± ‚Üí‚ÇÅ[Œº] ‚Ñù) = Lp.negPart (f : Œ± ‚Üí‚ÇÅ[Œº] ‚Ñù) := rfl\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.integral_eq_integral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedSpace Real E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.integral f) (MeasureTheory.SimpleFunc.integral Œº (MeasureTheory.Lp.simpleFunc.toSimpleFunc f))","decl":"theorem integral_eq_integral (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) : integral f = (toSimpleFunc f).integral Œº := rfl\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.integral_eq_lintegral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc Real 1 Œº) x\nh_pos : (MeasureTheory.ae Œº).EventuallyLE 0 ‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc f)\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.integral f) (MeasureTheory.lintegral Œº fun a => ENNReal.ofReal ((MeasureTheory.Lp.simpleFunc.toSimpleFunc f) a)).toReal","decl":"nonrec theorem integral_eq_lintegral {f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] ‚Ñù} (h_pos : 0 ‚â§·µê[Œº] toSimpleFunc f) :\n    integral f = ENNReal.toReal (‚à´‚Åª a, ENNReal.ofReal ((toSimpleFunc f) a) ‚àÇŒº) := by\n  rw [integral, SimpleFunc.integral_eq_lintegral (SimpleFunc.integrable f) h_pos]\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.integral_eq_setToL1S","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedSpace Real E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.integral f) (MeasureTheory.L1.SimpleFunc.setToL1S (MeasureTheory.weightedSMul Œº) f)","decl":"theorem integral_eq_setToL1S (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) : integral f = setToL1S (weightedSMul Œº) f := rfl\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.integral_congr","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedSpace Real E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\nh : (MeasureTheory.ae Œº).EventuallyEq ‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc f) ‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc g)\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.integral f) (MeasureTheory.L1.SimpleFunc.integral g)","decl":"nonrec theorem integral_congr {f g : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E} (h : toSimpleFunc f =·µê[Œº] toSimpleFunc g) :\n    integral f = integral g :=\n  SimpleFunc.integral_congr (SimpleFunc.integrable f) h\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.integral_add","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedSpace Real E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.integral (HAdd.hAdd f g)) (HAdd.hAdd (MeasureTheory.L1.SimpleFunc.integral f) (MeasureTheory.L1.SimpleFunc.integral g))","decl":"theorem integral_add (f g : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) : integral (f + g) = integral f + integral g :=\n  setToL1S_add _ (fun _ _ => weightedSMul_null) weightedSMul_union _ _\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.integral_smul","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\nùïú : Type u_4\ninst‚úù‚Å¥ : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≥ : NormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : SMulCommClass Real ùïú E\nc : ùïú\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.integral (HSMul.hSMul c f)) (HSMul.hSMul c (MeasureTheory.L1.SimpleFunc.integral f))","decl":"theorem integral_smul (c : ùïú) (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) : integral (c ‚Ä¢ f) = c ‚Ä¢ integral f :=\n  setToL1S_smul _ (fun _ _ => weightedSMul_null) weightedSMul_union weightedSMul_smul c f\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.norm_integral_le_norm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedSpace Real E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ LE.le (Norm.norm (MeasureTheory.L1.SimpleFunc.integral f)) (Norm.norm f)","decl":"theorem norm_integral_le_norm (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) : ‚Äñintegral f‚Äñ ‚â§ ‚Äñf‚Äñ := by\n  rw [integral, norm_eq_integral]\n  exact (toSimpleFunc f).norm_integral_le_integral_norm (SimpleFunc.integrable f)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.norm_Integral_le_one","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedSpace Real E\n‚ä¢ LE.le (Norm.norm (MeasureTheory.L1.SimpleFunc.integralCLM Œ± E Œº)) 1","decl":"theorem norm_Integral_le_one : ‚ÄñIntegral‚Äñ ‚â§ 1 :=\n  -- Porting note: Old proof was `LinearMap.mkContinuous_norm_le _ zero_le_one _`\n  LinearMap.mkContinuous_norm_le _ zero_le_one (fun f => by\n    rw [one_mul]\n    exact norm_integral_le_norm f)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.posPart_toSimpleFunc","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc Real 1 Œº) x\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq ‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc (MeasureTheory.L1.SimpleFunc.posPart f)) ‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc f).posPart","decl":"theorem posPart_toSimpleFunc (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] ‚Ñù) :\n    toSimpleFunc (posPart f) =·µê[Œº] (toSimpleFunc f).posPart := by\n  have eq : ‚àÄ a, (toSimpleFunc f).posPart a = max ((toSimpleFunc f) a) 0 := fun a => rfl\n  have ae_eq : ‚àÄ·µê a ‚àÇŒº, toSimpleFunc (posPart f) a = max ((toSimpleFunc f) a) 0 := by\n    filter_upwards [toSimpleFunc_eq_toFun (posPart f), Lp.coeFn_posPart (f : Œ± ‚Üí‚ÇÅ[Œº] ‚Ñù),\n      toSimpleFunc_eq_toFun f] with _ _ h‚ÇÇ h‚ÇÉ\n    convert h‚ÇÇ using 1\n    -- Porting note: added\n    rw [h‚ÇÉ]\n  refine ae_eq.mono fun a h => ?_\n  rw [h, eq]\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.negPart_toSimpleFunc","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc Real 1 Œº) x\n‚ä¢ (MeasureTheory.ae Œº).EventuallyEq ‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc (MeasureTheory.L1.SimpleFunc.negPart f)) ‚áë(MeasureTheory.Lp.simpleFunc.toSimpleFunc f).negPart","decl":"theorem negPart_toSimpleFunc (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] ‚Ñù) :\n    toSimpleFunc (negPart f) =·µê[Œº] (toSimpleFunc f).negPart := by\n  rw [SimpleFunc.negPart, MeasureTheory.SimpleFunc.negPart]\n  filter_upwards [posPart_toSimpleFunc (-f), neg_toSimpleFunc f]\n  intro a h‚ÇÅ h‚ÇÇ\n  rw [h‚ÇÅ]\n  show max _ _ = max _ _\n  rw [h‚ÇÇ]\n  rfl\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.integral_eq_norm_posPart_sub","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc Real 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.SimpleFunc.integral f) (HSub.hSub (Norm.norm (MeasureTheory.L1.SimpleFunc.posPart f)) (Norm.norm (MeasureTheory.L1.SimpleFunc.negPart f)))","decl":"theorem integral_eq_norm_posPart_sub (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] ‚Ñù) : integral f = ‚ÄñposPart f‚Äñ - ‚ÄñnegPart f‚Äñ := by\n  -- Convert things in `L¬π` to their `SimpleFunc` counterpart\n  have ae_eq‚ÇÅ : (toSimpleFunc f).posPart =·µê[Œº] (toSimpleFunc (posPart f)).map norm := by\n    filter_upwards [posPart_toSimpleFunc f] with _ h\n    rw [SimpleFunc.map_apply, h]\n    conv_lhs => rw [‚Üê SimpleFunc.posPart_map_norm, SimpleFunc.map_apply]\n  -- Convert things in `L¬π` to their `SimpleFunc` counterpart\n  have ae_eq‚ÇÇ : (toSimpleFunc f).negPart =·µê[Œº] (toSimpleFunc (negPart f)).map norm := by\n    filter_upwards [negPart_toSimpleFunc f] with _ h\n    rw [SimpleFunc.map_apply, h]\n    conv_lhs => rw [‚Üê SimpleFunc.negPart_map_norm, SimpleFunc.map_apply]\n  rw [integral, norm_eq_integral, norm_eq_integral, ‚Üê SimpleFunc.integral_sub]\n  ¬∑ show (toSimpleFunc f).integral Œº =\n      ((toSimpleFunc (posPart f)).map norm - (toSimpleFunc (negPart f)).map norm).integral Œº\n    apply MeasureTheory.SimpleFunc.integral_congr (SimpleFunc.integrable f)\n    filter_upwards [ae_eq‚ÇÅ, ae_eq‚ÇÇ] with _ h‚ÇÅ h‚ÇÇ\n    rw [SimpleFunc.sub_apply, ‚Üê h‚ÇÅ, ‚Üê h‚ÇÇ]\n    exact DFunLike.congr_fun (toSimpleFunc f).posPart_sub_negPart.symm _\n  ¬∑ exact (SimpleFunc.integrable f).pos_part.congr ae_eq‚ÇÅ\n  ¬∑ exact (SimpleFunc.integrable f).neg_part.congr ae_eq‚ÇÇ\n\n"}
{"name":"MeasureTheory.L1.integral_def","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_5\nE : Type u_6\ninst‚úù¬≤ : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : CompleteSpace E\n‚ä¢ Eq MeasureTheory.L1.integral ‚áëMeasureTheory.L1.integralCLM","decl":"/-- The Bochner integral in L1 space -/\nirreducible_def integral : (Œ± ‚Üí‚ÇÅ[Œº] E) ‚Üí E :=\n  integralCLM (E := E)\n\n"}
{"name":"MeasureTheory.L1.integral_eq","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : CompleteSpace E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.integral f) (MeasureTheory.L1.integralCLM f)","decl":"theorem integral_eq (f : Œ± ‚Üí‚ÇÅ[Œº] E) : integral f = integralCLM (E := E) f := by\n  simp only [integral]\n\n"}
{"name":"MeasureTheory.L1.integral_eq_setToL1","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : CompleteSpace E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.integral f) ((MeasureTheory.L1.setToL1 ‚ãØ) f)","decl":"theorem integral_eq_setToL1 (f : Œ± ‚Üí‚ÇÅ[Œº] E) :\n    integral f = setToL1 (E := E) (dominatedFinMeasAdditive_weightedSMul Œº) f := by\n  simp only [integral]; rfl\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.integral_L1_eq_integral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : CompleteSpace E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.integral ‚Üëf) (MeasureTheory.L1.SimpleFunc.integral f)","decl":"@[norm_cast]\ntheorem SimpleFunc.integral_L1_eq_integral (f : Œ± ‚Üí‚ÇÅ‚Çõ[Œº] E) :\n    L1.integral (f : Œ± ‚Üí‚ÇÅ[Œº] E) = SimpleFunc.integral f := by\n  simp only [integral, L1.integral]\n  exact setToL1_eq_setToL1SCLM (dominatedFinMeasAdditive_weightedSMul Œº) f\n\n"}
{"name":"MeasureTheory.L1.integral_zero","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : CompleteSpace E\n‚ä¢ Eq (MeasureTheory.L1.integral 0) 0","decl":"@[simp]\ntheorem integral_zero : integral (0 : Œ± ‚Üí‚ÇÅ[Œº] E) = 0 := by\n  simp only [integral]\n  exact map_zero integralCLM\n\n"}
{"name":"MeasureTheory.L1.integral_add","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : CompleteSpace E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.integral (HAdd.hAdd f g)) (HAdd.hAdd (MeasureTheory.L1.integral f) (MeasureTheory.L1.integral g))","decl":"@[integral_simps]\ntheorem integral_add (f g : Œ± ‚Üí‚ÇÅ[Œº] E) : integral (f + g) = integral f + integral g := by\n  simp only [integral]\n  exact map_add integralCLM f g\n\n"}
{"name":"MeasureTheory.L1.integral_neg","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : CompleteSpace E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.integral (Neg.neg f)) (Neg.neg (MeasureTheory.L1.integral f))","decl":"@[integral_simps]\ntheorem integral_neg (f : Œ± ‚Üí‚ÇÅ[Œº] E) : integral (-f) = -integral f := by\n  simp only [integral]\n  exact map_neg integralCLM f\n\n"}
{"name":"MeasureTheory.L1.integral_sub","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : CompleteSpace E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.integral (HSub.hSub f g)) (HSub.hSub (MeasureTheory.L1.integral f) (MeasureTheory.L1.integral g))","decl":"@[integral_simps]\ntheorem integral_sub (f g : Œ± ‚Üí‚ÇÅ[Œº] E) : integral (f - g) = integral f - integral g := by\n  simp only [integral]\n  exact map_sub integralCLM f g\n\n"}
{"name":"MeasureTheory.L1.integral_smul","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\nùïú : Type u_4\ninst‚úù‚Åµ : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù‚Å¥ : NormedSpace Real E\ninst‚úù¬≥ : NontriviallyNormedField ùïú\ninst‚úù¬≤ : NormedSpace ùïú E\ninst‚úù¬π : SMulCommClass Real ùïú E\ninst‚úù : CompleteSpace E\nc : ùïú\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.integral (HSMul.hSMul c f)) (HSMul.hSMul c (MeasureTheory.L1.integral f))","decl":"@[integral_simps]\ntheorem integral_smul (c : ùïú) (f : Œ± ‚Üí‚ÇÅ[Œº] E) : integral (c ‚Ä¢ f) = c ‚Ä¢ integral f := by\n  simp only [integral]\n  show (integralCLM' (E := E) ùïú) (c ‚Ä¢ f) = c ‚Ä¢ (integralCLM' (E := E) ùïú) f\n  exact _root_.map_smul (integralCLM' (E := E) ùïú) c f\n\n"}
{"name":"MeasureTheory.L1.norm_Integral_le_one","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : CompleteSpace E\n‚ä¢ LE.le (Norm.norm MeasureTheory.L1.integralCLM) 1","decl":"theorem norm_Integral_le_one : ‚ÄñintegralCLM (Œ± := Œ±) (E := E) (Œº := Œº)‚Äñ ‚â§ 1 :=\n  norm_setToL1_le (dominatedFinMeasAdditive_weightedSMul Œº) zero_le_one\n\n"}
{"name":"MeasureTheory.L1.nnnorm_Integral_le_one","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : CompleteSpace E\n‚ä¢ LE.le (NNNorm.nnnorm MeasureTheory.L1.integralCLM) 1","decl":"theorem nnnorm_Integral_le_one : ‚ÄñintegralCLM (Œ± := Œ±) (E := E) (Œº := Œº)‚Äñ‚Çä ‚â§ 1 :=\n  norm_Integral_le_one\n\n"}
{"name":"MeasureTheory.L1.norm_integral_le","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : CompleteSpace E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ LE.le (Norm.norm (MeasureTheory.L1.integral f)) (Norm.norm f)","decl":"theorem norm_integral_le (f : Œ± ‚Üí‚ÇÅ[Œº] E) : ‚Äñintegral f‚Äñ ‚â§ ‚Äñf‚Äñ :=\n  calc\n    ‚Äñintegral f‚Äñ = ‚ÄñintegralCLM (E := E) f‚Äñ := by simp only [integral]\n    _ ‚â§ ‚ÄñintegralCLM (Œ± := Œ±) (E := E) (Œº := Œº)‚Äñ * ‚Äñf‚Äñ := le_opNorm _ _\n    _ ‚â§ 1 * ‚Äñf‚Äñ := mul_le_mul_of_nonneg_right norm_Integral_le_one <| norm_nonneg _\n    _ = ‚Äñf‚Äñ := one_mul _\n\n"}
{"name":"MeasureTheory.L1.nnnorm_integral_le","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : CompleteSpace E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ LE.le (NNNorm.nnnorm (MeasureTheory.L1.integral f)) (NNNorm.nnnorm f)","decl":"theorem nnnorm_integral_le (f : Œ± ‚Üí‚ÇÅ[Œº] E) : ‚Äñintegral f‚Äñ‚Çä ‚â§ ‚Äñf‚Äñ‚Çä :=\n  norm_integral_le f\n\n"}
{"name":"MeasureTheory.L1.continuous_integral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : CompleteSpace E\n‚ä¢ Continuous fun f => MeasureTheory.L1.integral f","decl":"@[continuity]\ntheorem continuous_integral : Continuous fun f : Œ± ‚Üí‚ÇÅ[Œº] E => integral f := by\n  simp only [integral]\n  exact L1.integralCLM.continuous\n\n"}
{"name":"MeasureTheory.L1.integral_eq_norm_posPart_sub","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp Real 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.integral f) (HSub.hSub (Norm.norm (MeasureTheory.Lp.posPart f)) (Norm.norm (MeasureTheory.Lp.negPart f)))","decl":"theorem integral_eq_norm_posPart_sub (f : Œ± ‚Üí‚ÇÅ[Œº] ‚Ñù) :\n    integral f = ‚ÄñLp.posPart f‚Äñ - ‚ÄñLp.negPart f‚Äñ := by\n  -- Use `isClosed_property` and `isClosed_eq`\n  refine @isClosed_property _ _ _ ((‚Üë) : (Œ± ‚Üí‚ÇÅ‚Çõ[Œº] ‚Ñù) ‚Üí Œ± ‚Üí‚ÇÅ[Œº] ‚Ñù)\n      (fun f : Œ± ‚Üí‚ÇÅ[Œº] ‚Ñù => integral f = ‚ÄñLp.posPart f‚Äñ - ‚ÄñLp.negPart f‚Äñ)\n      (simpleFunc.denseRange one_ne_top) (isClosed_eq ?_ ?_) ?_ f\n  ¬∑ simp only [integral]\n    exact cont _\n  ¬∑ refine Continuous.sub (continuous_norm.comp Lp.continuous_posPart)\n      (continuous_norm.comp Lp.continuous_negPart)\n  -- Show that the property holds for all simple functions in the `L¬π` space.\n  ¬∑ intro s\n    norm_cast\n    exact SimpleFunc.integral_eq_norm_posPart_sub _\n\n"}
{"name":"MeasureTheory.integral_def","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_6\nG : Type u_7\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nx‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí G\n‚ä¢ Eq (MeasureTheory.integral Œº f) (dite (CompleteSpace G) (fun x => dite (MeasureTheory.Integrable f Œº) (fun hf => MeasureTheory.L1.integral (MeasureTheory.Integrable.toL1 f hf)) fun hf => 0) fun x => 0)","decl":"open Classical in\n/-- The Bochner integral -/\nirreducible_def integral {_ : MeasurableSpace Œ±} (Œº : Measure Œ±) (f : Œ± ‚Üí G) : G :=\n  if _ : CompleteSpace G then\n    if hf : Integrable f Œº then L1.integral (hf.toL1 f) else 0\n  else 0\n\n"}
{"name":"MeasureTheory.integral_eq","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\nhE : CompleteSpace E\ninst‚úù : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí E\nhf : MeasureTheory.Integrable f Œº\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => f a) (MeasureTheory.L1.integral (MeasureTheory.Integrable.toL1 f hf))","decl":"theorem integral_eq (f : Œ± ‚Üí E) (hf : Integrable f Œº) : ‚à´ a, f a ‚àÇŒº = L1.integral (hf.toL1 f) := by\n  simp [integral, hE, hf]\n\n"}
{"name":"MeasureTheory.integral_eq_setToFun","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\nhE : CompleteSpace E\ninst‚úù : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí E\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => f a) (MeasureTheory.setToFun Œº (MeasureTheory.weightedSMul Œº) ‚ãØ f)","decl":"theorem integral_eq_setToFun (f : Œ± ‚Üí E) :\n    ‚à´ a, f a ‚àÇŒº = setToFun Œº (weightedSMul Œº) (dominatedFinMeasAdditive_weightedSMul Œº) f := by\n  simp only [integral, hE, L1.integral]; rfl\n\n"}
{"name":"MeasureTheory.L1.integral_eq_integral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\nhE : CompleteSpace E\ninst‚úù : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Œº) x\n‚ä¢ Eq (MeasureTheory.L1.integral f) (MeasureTheory.integral Œº fun a => ‚Üë‚Üëf a)","decl":"theorem L1.integral_eq_integral (f : Œ± ‚Üí‚ÇÅ[Œº] E) : L1.integral f = ‚à´ a, f a ‚àÇŒº := by\n  simp only [integral, L1.integral, integral_eq_setToFun]\n  exact (L1.setToFun_eq_setToL1 (dominatedFinMeasAdditive_weightedSMul Œº) f).symm\n\n"}
{"name":"MeasureTheory.integral_undef","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí G\nh : Not (MeasureTheory.Integrable f Œº)\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => f a) 0","decl":"theorem integral_undef {f : Œ± ‚Üí G} (h : ¬¨Integrable f Œº) : ‚à´ a, f a ‚àÇŒº = 0 := by\n  by_cases hG : CompleteSpace G\n  ¬∑ simp [integral, hG, h]\n  ¬∑ simp [integral, hG]\n\n"}
{"name":"MeasureTheory.Integrable.of_integral_ne_zero","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí G\nh : Ne (MeasureTheory.integral Œº fun a => f a) 0\n‚ä¢ MeasureTheory.Integrable f Œº","decl":"theorem Integrable.of_integral_ne_zero {f : Œ± ‚Üí G} (h : ‚à´ a, f a ‚àÇŒº ‚â† 0) : Integrable f Œº :=\n  Not.imp_symm integral_undef h\n\n"}
{"name":"MeasureTheory.integral_non_aestronglyMeasurable","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí G\nh : Not (MeasureTheory.AEStronglyMeasurable f Œº)\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => f a) 0","decl":"theorem integral_non_aestronglyMeasurable {f : Œ± ‚Üí G} (h : ¬¨AEStronglyMeasurable f Œº) :\n    ‚à´ a, f a ‚àÇŒº = 0 :=\n  integral_undef <| not_and_of_not_left _ h\n\n"}
{"name":"MeasureTheory.integral_zero","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\n‚ä¢ Eq (MeasureTheory.integral Œº fun x => 0) 0","decl":"@[simp]\ntheorem integral_zero : ‚à´ _ : Œ±, (0 : G) ‚àÇŒº = 0 := by\n  by_cases hG : CompleteSpace G\n  ¬∑ simp only [integral, hG, L1.integral]\n    exact setToFun_zero (dominatedFinMeasAdditive_weightedSMul Œº)\n  ¬∑ simp [integral, hG]\n\n"}
{"name":"MeasureTheory.integral_zero'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\n‚ä¢ Eq (MeasureTheory.integral Œº 0) 0","decl":"@[simp]\ntheorem integral_zero' : integral Œº (0 : Œ± ‚Üí G) = 0 :=\n  integral_zero Œ± G\n\n"}
{"name":"MeasureTheory.integrable_of_integral_eq_one","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Real\nh : Eq (MeasureTheory.integral Œº fun x => f x) 1\n‚ä¢ MeasureTheory.Integrable f Œº","decl":"theorem integrable_of_integral_eq_one {f : Œ± ‚Üí ‚Ñù} (h : ‚à´ x, f x ‚àÇŒº = 1) : Integrable f Œº :=\n  .of_integral_ne_zero <| h ‚ñ∏ one_ne_zero\n\n"}
{"name":"MeasureTheory.integral_add","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí G\nhf : MeasureTheory.Integrable f Œº\nhg : MeasureTheory.Integrable g Œº\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => HAdd.hAdd (f a) (g a)) (HAdd.hAdd (MeasureTheory.integral Œº fun a => f a) (MeasureTheory.integral Œº fun a => g a))","decl":"theorem integral_add {f g : Œ± ‚Üí G} (hf : Integrable f Œº) (hg : Integrable g Œº) :\n    ‚à´ a, f a + g a ‚àÇŒº = ‚à´ a, f a ‚àÇŒº + ‚à´ a, g a ‚àÇŒº := by\n  by_cases hG : CompleteSpace G\n  ¬∑ simp only [integral, hG, L1.integral]\n    exact setToFun_add (dominatedFinMeasAdditive_weightedSMul Œº) hf hg\n  ¬∑ simp [integral, hG]\n\n"}
{"name":"MeasureTheory.integral_add'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí G\nhf : MeasureTheory.Integrable f Œº\nhg : MeasureTheory.Integrable g Œº\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => HAdd.hAdd f g a) (HAdd.hAdd (MeasureTheory.integral Œº fun a => f a) (MeasureTheory.integral Œº fun a => g a))","decl":"theorem integral_add' {f g : Œ± ‚Üí G} (hf : Integrable f Œº) (hg : Integrable g Œº) :\n    ‚à´ a, (f + g) a ‚àÇŒº = ‚à´ a, f a ‚àÇŒº + ‚à´ a, g a ‚àÇŒº :=\n  integral_add hf hg\n\n"}
{"name":"MeasureTheory.integral_finset_sum","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒπ : Type u_6\ns : Finset Œπ\nf : Œπ ‚Üí Œ± ‚Üí G\nhf : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí MeasureTheory.Integrable (f i) Œº\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => s.sum fun i => f i a) (s.sum fun i => MeasureTheory.integral Œº fun a => f i a)","decl":"theorem integral_finset_sum {Œπ} (s : Finset Œπ) {f : Œπ ‚Üí Œ± ‚Üí G} (hf : ‚àÄ i ‚àà s, Integrable (f i) Œº) :\n    ‚à´ a, ‚àë i ‚àà s, f i a ‚àÇŒº = ‚àë i ‚àà s, ‚à´ a, f i a ‚àÇŒº := by\n  by_cases hG : CompleteSpace G\n  ¬∑ simp only [integral, hG, L1.integral]\n    exact setToFun_finset_sum (dominatedFinMeasAdditive_weightedSMul _) s hf\n  ¬∑ simp [integral, hG]\n\n"}
{"name":"MeasureTheory.integral_neg","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí G\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => Neg.neg (f a)) (Neg.neg (MeasureTheory.integral Œº fun a => f a))","decl":"@[integral_simps]\ntheorem integral_neg (f : Œ± ‚Üí G) : ‚à´ a, -f a ‚àÇŒº = -‚à´ a, f a ‚àÇŒº := by\n  by_cases hG : CompleteSpace G\n  ¬∑ simp only [integral, hG, L1.integral]\n    exact setToFun_neg (dominatedFinMeasAdditive_weightedSMul Œº) f\n  ¬∑ simp [integral, hG]\n\n"}
{"name":"MeasureTheory.integral_neg'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí G\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => Neg.neg f a) (Neg.neg (MeasureTheory.integral Œº fun a => f a))","decl":"theorem integral_neg' (f : Œ± ‚Üí G) : ‚à´ a, (-f) a ‚àÇŒº = -‚à´ a, f a ‚àÇŒº :=\n  integral_neg f\n\n"}
{"name":"MeasureTheory.integral_sub","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí G\nhf : MeasureTheory.Integrable f Œº\nhg : MeasureTheory.Integrable g Œº\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => HSub.hSub (f a) (g a)) (HSub.hSub (MeasureTheory.integral Œº fun a => f a) (MeasureTheory.integral Œº fun a => g a))","decl":"theorem integral_sub {f g : Œ± ‚Üí G} (hf : Integrable f Œº) (hg : Integrable g Œº) :\n    ‚à´ a, f a - g a ‚àÇŒº = ‚à´ a, f a ‚àÇŒº - ‚à´ a, g a ‚àÇŒº := by\n  by_cases hG : CompleteSpace G\n  ¬∑ simp only [integral, hG, L1.integral]\n    exact setToFun_sub (dominatedFinMeasAdditive_weightedSMul Œº) hf hg\n  ¬∑ simp [integral, hG]\n\n"}
{"name":"MeasureTheory.integral_sub'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí G\nhf : MeasureTheory.Integrable f Œº\nhg : MeasureTheory.Integrable g Œº\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => HSub.hSub f g a) (HSub.hSub (MeasureTheory.integral Œº fun a => f a) (MeasureTheory.integral Œº fun a => g a))","decl":"theorem integral_sub' {f g : Œ± ‚Üí G} (hf : Integrable f Œº) (hg : Integrable g Œº) :\n    ‚à´ a, (f - g) a ‚àÇŒº = ‚à´ a, f a ‚àÇŒº - ‚à´ a, g a ‚àÇŒº :=\n  integral_sub hf hg\n\n"}
{"name":"MeasureTheory.integral_smul","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nùïú : Type u_4\ninst‚úù‚Å¥ : NontriviallyNormedField ùïú\nG : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup G\ninst‚úù¬≤ : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedSpace ùïú G\ninst‚úù : SMulCommClass Real ùïú G\nc : ùïú\nf : Œ± ‚Üí G\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => HSMul.hSMul c (f a)) (HSMul.hSMul c (MeasureTheory.integral Œº fun a => f a))","decl":"@[integral_simps]\ntheorem integral_smul [NormedSpace ùïú G] [SMulCommClass ‚Ñù ùïú G] (c : ùïú) (f : Œ± ‚Üí G) :\n    ‚à´ a, c ‚Ä¢ f a ‚àÇŒº = c ‚Ä¢ ‚à´ a, f a ‚àÇŒº := by\n  by_cases hG : CompleteSpace G\n  ¬∑ simp only [integral, hG, L1.integral]\n    exact setToFun_smul (dominatedFinMeasAdditive_weightedSMul Œº) weightedSMul_smul c f\n  ¬∑ simp [integral, hG]\n\n"}
{"name":"MeasureTheory.integral_mul_left","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nL : Type u_6\ninst‚úù : RCLike L\nr : L\nf : Œ± ‚Üí L\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => HMul.hMul r (f a)) (HMul.hMul r (MeasureTheory.integral Œº fun a => f a))","decl":"theorem integral_mul_left {L : Type*} [RCLike L] (r : L) (f : Œ± ‚Üí L) :\n    ‚à´ a, r * f a ‚àÇŒº = r * ‚à´ a, f a ‚àÇŒº :=\n  integral_smul r f\n\n"}
{"name":"MeasureTheory.integral_mul_right","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nL : Type u_6\ninst‚úù : RCLike L\nr : L\nf : Œ± ‚Üí L\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => HMul.hMul (f a) r) (HMul.hMul (MeasureTheory.integral Œº fun a => f a) r)","decl":"theorem integral_mul_right {L : Type*} [RCLike L] (r : L) (f : Œ± ‚Üí L) :\n    ‚à´ a, f a * r ‚àÇŒº = (‚à´ a, f a ‚àÇŒº) * r := by\n  simp only [mul_comm]; exact integral_mul_left r f\n\n"}
{"name":"MeasureTheory.integral_div","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nL : Type u_6\ninst‚úù : RCLike L\nr : L\nf : Œ± ‚Üí L\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => HDiv.hDiv (f a) r) (HDiv.hDiv (MeasureTheory.integral Œº fun a => f a) r)","decl":"theorem integral_div {L : Type*} [RCLike L] (r : L) (f : Œ± ‚Üí L) :\n    ‚à´ a, f a / r ‚àÇŒº = (‚à´ a, f a ‚àÇŒº) / r := by\n  simpa only [‚Üê div_eq_mul_inv] using integral_mul_right r‚Åª¬π f\n\n"}
{"name":"MeasureTheory.integral_congr_ae","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí G\nh : (MeasureTheory.ae Œº).EventuallyEq f g\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => f a) (MeasureTheory.integral Œº fun a => g a)","decl":"theorem integral_congr_ae {f g : Œ± ‚Üí G} (h : f =·µê[Œº] g) : ‚à´ a, f a ‚àÇŒº = ‚à´ a, g a ‚àÇŒº := by\n  by_cases hG : CompleteSpace G\n  ¬∑ simp only [integral, hG, L1.integral]\n    exact setToFun_congr_ae (dominatedFinMeasAdditive_weightedSMul Œº) h\n  ¬∑ simp [integral, hG]\n\n"}
{"name":"MeasureTheory.integral_congr_ae‚ÇÇ","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_6\nx‚úù : MeasurableSpace Œ≤\nŒΩ : MeasureTheory.Measure Œ≤\nf g : Œ± ‚Üí Œ≤ ‚Üí G\nh : Filter.Eventually (fun a => (MeasureTheory.ae ŒΩ).EventuallyEq (f a) (g a)) (MeasureTheory.ae Œº)\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => MeasureTheory.integral ŒΩ fun b => f a b) (MeasureTheory.integral Œº fun a => MeasureTheory.integral ŒΩ fun b => g a b)","decl":"lemma integral_congr_ae‚ÇÇ {Œ≤ : Type*} {_ : MeasurableSpace Œ≤} {ŒΩ : Measure Œ≤} {f g : Œ± ‚Üí Œ≤ ‚Üí G}\n    (h : ‚àÄ·µê a ‚àÇŒº, f a =·µê[ŒΩ] g a) :\n    ‚à´ a, ‚à´ b, f a b ‚àÇŒΩ ‚àÇŒº = ‚à´ a, ‚à´ b, g a b ‚àÇŒΩ ‚àÇŒº := by\n  apply integral_congr_ae\n  filter_upwards [h] with _ ha\n  apply integral_congr_ae\n  filter_upwards [ha] with _ hb using hb\n\n-- Porting note: `nolint simpNF` added because simplify fails on left-hand side\n"}
{"name":"MeasureTheory.L1.integral_of_fun_eq_integral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí G\nhf : MeasureTheory.Integrable f Œº\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => ‚Üë‚Üë(MeasureTheory.Integrable.toL1 f hf) a) (MeasureTheory.integral Œº fun a => f a)","decl":"@[simp, nolint simpNF]\ntheorem L1.integral_of_fun_eq_integral {f : Œ± ‚Üí G} (hf : Integrable f Œº) :\n    ‚à´ a, (hf.toL1 f) a ‚àÇŒº = ‚à´ a, f a ‚àÇŒº := by\n  by_cases hG : CompleteSpace G\n  ¬∑ simp only [MeasureTheory.integral, hG, L1.integral]\n    exact setToFun_toL1 (dominatedFinMeasAdditive_weightedSMul Œº) hf\n  ¬∑ simp [MeasureTheory.integral, hG]\n\n"}
{"name":"MeasureTheory.continuous_integral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\n‚ä¢ Continuous fun f => MeasureTheory.integral Œº fun a => ‚Üë‚Üëf a","decl":"@[continuity]\ntheorem continuous_integral : Continuous fun f : Œ± ‚Üí‚ÇÅ[Œº] G => ‚à´ a, f a ‚àÇŒº := by\n  by_cases hG : CompleteSpace G\n  ¬∑ simp only [integral, hG, L1.integral]\n    exact continuous_setToFun (dominatedFinMeasAdditive_weightedSMul Œº)\n  ¬∑ simp [integral, hG, continuous_const]\n\n"}
{"name":"MeasureTheory.norm_integral_le_lintegral_norm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí G\n‚ä¢ LE.le (Norm.norm (MeasureTheory.integral Œº fun a => f a)) (MeasureTheory.lintegral Œº fun a => ENNReal.ofReal (Norm.norm (f a))).toReal","decl":"theorem norm_integral_le_lintegral_norm (f : Œ± ‚Üí G) :\n    ‚Äñ‚à´ a, f a ‚àÇŒº‚Äñ ‚â§ ENNReal.toReal (‚à´‚Åª a, ENNReal.ofReal ‚Äñf a‚Äñ ‚àÇŒº) := by\n  by_cases hG : CompleteSpace G\n  ¬∑ by_cases hf : Integrable f Œº\n    ¬∑ rw [integral_eq f hf, ‚Üê Integrable.norm_toL1_eq_lintegral_norm f hf]\n      exact L1.norm_integral_le _\n    ¬∑ rw [integral_undef hf, norm_zero]; exact toReal_nonneg\n  ¬∑ simp [integral, hG]\n\n"}
{"name":"MeasureTheory.enorm_integral_le_lintegral_enorm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí G\n‚ä¢ LE.le (ENorm.enorm (MeasureTheory.integral Œº fun a => f a)) (MeasureTheory.lintegral Œº fun a => ENorm.enorm (f a))","decl":"theorem enorm_integral_le_lintegral_enorm (f : Œ± ‚Üí G) : ‚Äñ‚à´ a, f a ‚àÇŒº‚Äñ‚Çë ‚â§ ‚à´‚Åª a, ‚Äñf a‚Äñ‚Çë ‚àÇŒº := by\n  simp_rw [‚Üê ofReal_norm_eq_enorm]\n  apply ENNReal.ofReal_le_of_le_toReal\n  exact norm_integral_le_lintegral_norm f\n\n"}
{"name":"MeasureTheory.ennnorm_integral_le_lintegral_ennnorm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí G\n‚ä¢ LE.le (ENorm.enorm (MeasureTheory.integral Œº fun a => f a)) (MeasureTheory.lintegral Œº fun a => ENorm.enorm (f a))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias ennnorm_integral_le_lintegral_ennnorm := enorm_integral_le_lintegral_enorm\n\n"}
{"name":"MeasureTheory.integral_eq_zero_of_ae","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí G\nhf : (MeasureTheory.ae Œº).EventuallyEq f 0\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => f a) 0","decl":"theorem integral_eq_zero_of_ae {f : Œ± ‚Üí G} (hf : f =·µê[Œº] 0) : ‚à´ a, f a ‚àÇŒº = 0 := by\n  simp [integral_congr_ae hf, integral_zero]\n\n"}
{"name":"MeasureTheory.HasFiniteIntegral.tendsto_setIntegral_nhds_zero","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒπ : Type u_6\nf : Œ± ‚Üí G\nhf : MeasureTheory.HasFiniteIntegral f Œº\nl : Filter Œπ\ns : Œπ ‚Üí Set Œ±\nhs : Filter.Tendsto (Function.comp (‚áëŒº) s) l (nhds 0)\n‚ä¢ Filter.Tendsto (fun i => MeasureTheory.integral (Œº.restrict (s i)) fun x => f x) l (nhds 0)","decl":"/-- If `f` has finite integral, then `‚à´ x in s, f x ‚àÇŒº` is absolutely continuous in `s`: it tends\nto zero as `Œº s` tends to zero. -/\ntheorem HasFiniteIntegral.tendsto_setIntegral_nhds_zero {Œπ} {f : Œ± ‚Üí G}\n    (hf : HasFiniteIntegral f Œº) {l : Filter Œπ} {s : Œπ ‚Üí Set Œ±} (hs : Tendsto (Œº ‚àò s) l (ùìù 0)) :\n    Tendsto (fun i => ‚à´ x in s i, f x ‚àÇŒº) l (ùìù 0) := by\n  rw [tendsto_zero_iff_norm_tendsto_zero]\n  simp_rw [‚Üê coe_nnnorm, ‚Üê NNReal.coe_zero, NNReal.tendsto_coe, ‚Üê ENNReal.tendsto_coe,\n    ENNReal.coe_zero]\n  exact tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds\n    (tendsto_setLIntegral_zero (ne_of_lt hf) hs) (fun i => zero_le _)\n    fun i => enorm_integral_le_lintegral_enorm _\n\n"}
{"name":"MeasureTheory.Integrable.tendsto_setIntegral_nhds_zero","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒπ : Type u_6\nf : Œ± ‚Üí G\nhf : MeasureTheory.Integrable f Œº\nl : Filter Œπ\ns : Œπ ‚Üí Set Œ±\nhs : Filter.Tendsto (Function.comp (‚áëŒº) s) l (nhds 0)\n‚ä¢ Filter.Tendsto (fun i => MeasureTheory.integral (Œº.restrict (s i)) fun x => f x) l (nhds 0)","decl":"/-- If `f` is integrable, then `‚à´ x in s, f x ‚àÇŒº` is absolutely continuous in `s`: it tends\nto zero as `Œº s` tends to zero. -/\ntheorem Integrable.tendsto_setIntegral_nhds_zero {Œπ} {f : Œ± ‚Üí G} (hf : Integrable f Œº)\n    {l : Filter Œπ} {s : Œπ ‚Üí Set Œ±} (hs : Tendsto (Œº ‚àò s) l (ùìù 0)) :\n    Tendsto (fun i => ‚à´ x in s i, f x ‚àÇŒº) l (ùìù 0) :=\n  hf.2.tendsto_setIntegral_nhds_zero hs\n\n"}
{"name":"MeasureTheory.tendsto_integral_of_L1","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒπ : Type u_6\nf : Œ± ‚Üí G\nhfi : MeasureTheory.Integrable f Œº\nF : Œπ ‚Üí Œ± ‚Üí G\nl : Filter Œπ\nhFi : Filter.Eventually (fun i => MeasureTheory.Integrable (F i) Œº) l\nhF : Filter.Tendsto (fun i => MeasureTheory.lintegral Œº fun x => ENorm.enorm (HSub.hSub (F i x) (f x))) l (nhds 0)\n‚ä¢ Filter.Tendsto (fun i => MeasureTheory.integral Œº fun x => F i x) l (nhds (MeasureTheory.integral Œº fun x => f x))","decl":"/-- If `F i ‚Üí f` in `L1`, then `‚à´ x, F i x ‚àÇŒº ‚Üí ‚à´ x, f x ‚àÇŒº`. -/\ntheorem tendsto_integral_of_L1 {Œπ} (f : Œ± ‚Üí G) (hfi : Integrable f Œº) {F : Œπ ‚Üí Œ± ‚Üí G} {l : Filter Œπ}\n    (hFi : ‚àÄ·∂† i in l, Integrable (F i) Œº)\n    (hF : Tendsto (fun i => ‚à´‚Åª x, ‚ÄñF i x - f x‚Äñ‚Çë ‚àÇŒº) l (ùìù 0)) :\n    Tendsto (fun i => ‚à´ x, F i x ‚àÇŒº) l (ùìù <| ‚à´ x, f x ‚àÇŒº) := by\n  by_cases hG : CompleteSpace G\n  ¬∑ simp only [integral, hG, L1.integral]\n    exact tendsto_setToFun_of_L1 (dominatedFinMeasAdditive_weightedSMul Œº) f hfi hFi hF\n  ¬∑ simp [integral, hG, tendsto_const_nhds]\n\n"}
{"name":"MeasureTheory.tendsto_integral_of_L1'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒπ : Type u_6\nf : Œ± ‚Üí G\nhfi : MeasureTheory.Integrable f Œº\nF : Œπ ‚Üí Œ± ‚Üí G\nl : Filter Œπ\nhFi : Filter.Eventually (fun i => MeasureTheory.Integrable (F i) Œº) l\nhF : Filter.Tendsto (fun i => MeasureTheory.eLpNorm (HSub.hSub (F i) f) 1 Œº) l (nhds 0)\n‚ä¢ Filter.Tendsto (fun i => MeasureTheory.integral Œº fun x => F i x) l (nhds (MeasureTheory.integral Œº fun x => f x))","decl":"/-- If `F i ‚Üí f` in `L1`, then `‚à´ x, F i x ‚àÇŒº ‚Üí ‚à´ x, f x ‚àÇŒº`. -/\nlemma tendsto_integral_of_L1' {Œπ} (f : Œ± ‚Üí G) (hfi : Integrable f Œº) {F : Œπ ‚Üí Œ± ‚Üí G} {l : Filter Œπ}\n    (hFi : ‚àÄ·∂† i in l, Integrable (F i) Œº) (hF : Tendsto (fun i ‚Ü¶ eLpNorm (F i - f) 1 Œº) l (ùìù 0)) :\n    Tendsto (fun i ‚Ü¶ ‚à´ x, F i x ‚àÇŒº) l (ùìù (‚à´ x, f x ‚àÇŒº)) := by\n  refine tendsto_integral_of_L1 f hfi hFi ?_\n  simp_rw [eLpNorm_one_eq_lintegral_enorm, Pi.sub_apply] at hF\n  exact hF\n\n"}
{"name":"MeasureTheory.tendsto_setIntegral_of_L1","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒπ : Type u_6\nf : Œ± ‚Üí G\nhfi : MeasureTheory.Integrable f Œº\nF : Œπ ‚Üí Œ± ‚Üí G\nl : Filter Œπ\nhFi : Filter.Eventually (fun i => MeasureTheory.Integrable (F i) Œº) l\nhF : Filter.Tendsto (fun i => MeasureTheory.lintegral Œº fun x => ENorm.enorm (HSub.hSub (F i x) (f x))) l (nhds 0)\ns : Set Œ±\n‚ä¢ Filter.Tendsto (fun i => MeasureTheory.integral (Œº.restrict s) fun x => F i x) l (nhds (MeasureTheory.integral (Œº.restrict s) fun x => f x))","decl":"/-- If `F i ‚Üí f` in `L1`, then `‚à´ x in s, F i x ‚àÇŒº ‚Üí ‚à´ x in s, f x ‚àÇŒº`. -/\nlemma tendsto_setIntegral_of_L1 {Œπ} (f : Œ± ‚Üí G) (hfi : Integrable f Œº) {F : Œπ ‚Üí Œ± ‚Üí G}\n    {l : Filter Œπ}\n    (hFi : ‚àÄ·∂† i in l, Integrable (F i) Œº) (hF : Tendsto (fun i ‚Ü¶ ‚à´‚Åª x, ‚ÄñF i x - f x‚Äñ‚Çë ‚àÇŒº) l (ùìù 0))\n    (s : Set Œ±) :\n    Tendsto (fun i ‚Ü¶ ‚à´ x in s, F i x ‚àÇŒº) l (ùìù (‚à´ x in s, f x ‚àÇŒº)) := by\n  refine tendsto_integral_of_L1 f hfi.restrict ?_ ?_\n  ¬∑ filter_upwards [hFi] with i hi using hi.restrict\n  ¬∑ simp_rw [‚Üê eLpNorm_one_eq_lintegral_enorm] at hF ‚ä¢\n    exact tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds hF (fun _ ‚Ü¶ zero_le')\n      (fun _ ‚Ü¶ eLpNorm_mono_measure _ Measure.restrict_le_self)\n\n"}
{"name":"MeasureTheory.tendsto_setIntegral_of_L1'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒπ : Type u_6\nf : Œ± ‚Üí G\nhfi : MeasureTheory.Integrable f Œº\nF : Œπ ‚Üí Œ± ‚Üí G\nl : Filter Œπ\nhFi : Filter.Eventually (fun i => MeasureTheory.Integrable (F i) Œº) l\nhF : Filter.Tendsto (fun i => MeasureTheory.eLpNorm (HSub.hSub (F i) f) 1 Œº) l (nhds 0)\ns : Set Œ±\n‚ä¢ Filter.Tendsto (fun i => MeasureTheory.integral (Œº.restrict s) fun x => F i x) l (nhds (MeasureTheory.integral (Œº.restrict s) fun x => f x))","decl":"/-- If `F i ‚Üí f` in `L1`, then `‚à´ x in s, F i x ‚àÇŒº ‚Üí ‚à´ x in s, f x ‚àÇŒº`. -/\nlemma tendsto_setIntegral_of_L1' {Œπ} (f : Œ± ‚Üí G) (hfi : Integrable f Œº) {F : Œπ ‚Üí Œ± ‚Üí G}\n    {l : Filter Œπ}\n    (hFi : ‚àÄ·∂† i in l, Integrable (F i) Œº) (hF : Tendsto (fun i ‚Ü¶ eLpNorm (F i - f) 1 Œº) l (ùìù 0))\n    (s : Set Œ±) :\n    Tendsto (fun i ‚Ü¶ ‚à´ x in s, F i x ‚àÇŒº) l (ùìù (‚à´ x in s, f x ‚àÇŒº)) := by\n  refine tendsto_setIntegral_of_L1 f hfi hFi ?_ s\n  simp_rw [eLpNorm_one_eq_lintegral_enorm, Pi.sub_apply] at hF\n  exact hF\n\n"}
{"name":"MeasureTheory.continuousWithinAt_of_dominated","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup G\ninst‚úù¬≤ : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nX : Type u_6\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : FirstCountableTopology X\nF : X ‚Üí Œ± ‚Üí G\nx‚ÇÄ : X\nbound : Œ± ‚Üí Real\ns : Set X\nhF_meas : Filter.Eventually (fun x => MeasureTheory.AEStronglyMeasurable (F x) Œº) (nhdsWithin x‚ÇÄ s)\nh_bound : Filter.Eventually (fun x => Filter.Eventually (fun a => LE.le (Norm.norm (F x a)) (bound a)) (MeasureTheory.ae Œº)) (nhdsWithin x‚ÇÄ s)\nbound_integrable : MeasureTheory.Integrable bound Œº\nh_cont : Filter.Eventually (fun a => ContinuousWithinAt (fun x => F x a) s x‚ÇÄ) (MeasureTheory.ae Œº)\n‚ä¢ ContinuousWithinAt (fun x => MeasureTheory.integral Œº fun a => F x a) s x‚ÇÄ","decl":"theorem continuousWithinAt_of_dominated {F : X ‚Üí Œ± ‚Üí G} {x‚ÇÄ : X} {bound : Œ± ‚Üí ‚Ñù} {s : Set X}\n    (hF_meas : ‚àÄ·∂† x in ùìù[s] x‚ÇÄ, AEStronglyMeasurable (F x) Œº)\n    (h_bound : ‚àÄ·∂† x in ùìù[s] x‚ÇÄ, ‚àÄ·µê a ‚àÇŒº, ‚ÄñF x a‚Äñ ‚â§ bound a) (bound_integrable : Integrable bound Œº)\n    (h_cont : ‚àÄ·µê a ‚àÇŒº, ContinuousWithinAt (fun x => F x a) s x‚ÇÄ) :\n    ContinuousWithinAt (fun x => ‚à´ a, F x a ‚àÇŒº) s x‚ÇÄ := by\n  by_cases hG : CompleteSpace G\n  ¬∑ simp only [integral, hG, L1.integral]\n    exact continuousWithinAt_setToFun_of_dominated (dominatedFinMeasAdditive_weightedSMul Œº)\n      hF_meas h_bound bound_integrable h_cont\n  ¬∑ simp [integral, hG, continuousWithinAt_const]\n\n"}
{"name":"MeasureTheory.continuousAt_of_dominated","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup G\ninst‚úù¬≤ : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nX : Type u_6\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : FirstCountableTopology X\nF : X ‚Üí Œ± ‚Üí G\nx‚ÇÄ : X\nbound : Œ± ‚Üí Real\nhF_meas : Filter.Eventually (fun x => MeasureTheory.AEStronglyMeasurable (F x) Œº) (nhds x‚ÇÄ)\nh_bound : Filter.Eventually (fun x => Filter.Eventually (fun a => LE.le (Norm.norm (F x a)) (bound a)) (MeasureTheory.ae Œº)) (nhds x‚ÇÄ)\nbound_integrable : MeasureTheory.Integrable bound Œº\nh_cont : Filter.Eventually (fun a => ContinuousAt (fun x => F x a) x‚ÇÄ) (MeasureTheory.ae Œº)\n‚ä¢ ContinuousAt (fun x => MeasureTheory.integral Œº fun a => F x a) x‚ÇÄ","decl":"theorem continuousAt_of_dominated {F : X ‚Üí Œ± ‚Üí G} {x‚ÇÄ : X} {bound : Œ± ‚Üí ‚Ñù}\n    (hF_meas : ‚àÄ·∂† x in ùìù x‚ÇÄ, AEStronglyMeasurable (F x) Œº)\n    (h_bound : ‚àÄ·∂† x in ùìù x‚ÇÄ, ‚àÄ·µê a ‚àÇŒº, ‚ÄñF x a‚Äñ ‚â§ bound a) (bound_integrable : Integrable bound Œº)\n    (h_cont : ‚àÄ·µê a ‚àÇŒº, ContinuousAt (fun x => F x a) x‚ÇÄ) :\n    ContinuousAt (fun x => ‚à´ a, F x a ‚àÇŒº) x‚ÇÄ := by\n  by_cases hG : CompleteSpace G\n  ¬∑ simp only [integral, hG, L1.integral]\n    exact continuousAt_setToFun_of_dominated (dominatedFinMeasAdditive_weightedSMul Œº)\n      hF_meas h_bound bound_integrable h_cont\n  ¬∑ simp [integral, hG, continuousAt_const]\n\n"}
{"name":"MeasureTheory.continuousOn_of_dominated","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup G\ninst‚úù¬≤ : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nX : Type u_6\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : FirstCountableTopology X\nF : X ‚Üí Œ± ‚Üí G\nbound : Œ± ‚Üí Real\ns : Set X\nhF_meas : ‚àÄ (x : X), Membership.mem s x ‚Üí MeasureTheory.AEStronglyMeasurable (F x) Œº\nh_bound : ‚àÄ (x : X), Membership.mem s x ‚Üí Filter.Eventually (fun a => LE.le (Norm.norm (F x a)) (bound a)) (MeasureTheory.ae Œº)\nbound_integrable : MeasureTheory.Integrable bound Œº\nh_cont : Filter.Eventually (fun a => ContinuousOn (fun x => F x a) s) (MeasureTheory.ae Œº)\n‚ä¢ ContinuousOn (fun x => MeasureTheory.integral Œº fun a => F x a) s","decl":"theorem continuousOn_of_dominated {F : X ‚Üí Œ± ‚Üí G} {bound : Œ± ‚Üí ‚Ñù} {s : Set X}\n    (hF_meas : ‚àÄ x ‚àà s, AEStronglyMeasurable (F x) Œº)\n    (h_bound : ‚àÄ x ‚àà s, ‚àÄ·µê a ‚àÇŒº, ‚ÄñF x a‚Äñ ‚â§ bound a) (bound_integrable : Integrable bound Œº)\n    (h_cont : ‚àÄ·µê a ‚àÇŒº, ContinuousOn (fun x => F x a) s) :\n    ContinuousOn (fun x => ‚à´ a, F x a ‚àÇŒº) s := by\n  by_cases hG : CompleteSpace G\n  ¬∑ simp only [integral, hG, L1.integral]\n    exact continuousOn_setToFun_of_dominated (dominatedFinMeasAdditive_weightedSMul Œº)\n      hF_meas h_bound bound_integrable h_cont\n  ¬∑ simp [integral, hG, continuousOn_const]\n\n"}
{"name":"MeasureTheory.continuous_of_dominated","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬≥ : NormedAddCommGroup G\ninst‚úù¬≤ : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nX : Type u_6\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : FirstCountableTopology X\nF : X ‚Üí Œ± ‚Üí G\nbound : Œ± ‚Üí Real\nhF_meas : ‚àÄ (x : X), MeasureTheory.AEStronglyMeasurable (F x) Œº\nh_bound : ‚àÄ (x : X), Filter.Eventually (fun a => LE.le (Norm.norm (F x a)) (bound a)) (MeasureTheory.ae Œº)\nbound_integrable : MeasureTheory.Integrable bound Œº\nh_cont : Filter.Eventually (fun a => Continuous fun x => F x a) (MeasureTheory.ae Œº)\n‚ä¢ Continuous fun x => MeasureTheory.integral Œº fun a => F x a","decl":"theorem continuous_of_dominated {F : X ‚Üí Œ± ‚Üí G} {bound : Œ± ‚Üí ‚Ñù}\n    (hF_meas : ‚àÄ x, AEStronglyMeasurable (F x) Œº) (h_bound : ‚àÄ x, ‚àÄ·µê a ‚àÇŒº, ‚ÄñF x a‚Äñ ‚â§ bound a)\n    (bound_integrable : Integrable bound Œº) (h_cont : ‚àÄ·µê a ‚àÇŒº, Continuous fun x => F x a) :\n    Continuous fun x => ‚à´ a, F x a ‚àÇŒº := by\n  by_cases hG : CompleteSpace G\n  ¬∑ simp only [integral, hG, L1.integral]\n    exact continuous_setToFun_of_dominated (dominatedFinMeasAdditive_weightedSMul Œº)\n      hF_meas h_bound bound_integrable h_cont\n  ¬∑ simp [integral, hG, continuous_const]\n\n"}
{"name":"MeasureTheory.integral_eq_lintegral_pos_part_sub_lintegral_neg_part","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Real\nhf : MeasureTheory.Integrable f Œº\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => f a) (HSub.hSub (MeasureTheory.lintegral Œº fun a => ENNReal.ofReal (f a)).toReal (MeasureTheory.lintegral Œº fun a => ENNReal.ofReal (Neg.neg (f a))).toReal)","decl":"/-- The Bochner integral of a real-valued function `f : Œ± ‚Üí ‚Ñù` is the difference between the\n  integral of the positive part of `f` and the integral of the negative part of `f`. -/\ntheorem integral_eq_lintegral_pos_part_sub_lintegral_neg_part {f : Œ± ‚Üí ‚Ñù} (hf : Integrable f Œº) :\n    ‚à´ a, f a ‚àÇŒº =\n      ENNReal.toReal (‚à´‚Åª a, .ofReal (f a) ‚àÇŒº) - ENNReal.toReal (‚à´‚Åª a, .ofReal (-f a) ‚àÇŒº) := by\n  let f‚ÇÅ := hf.toL1 f\n  -- Go to the `L¬π` space\n  have eq‚ÇÅ : ENNReal.toReal (‚à´‚Åª a, ENNReal.ofReal (f a) ‚àÇŒº) = ‚ÄñLp.posPart f‚ÇÅ‚Äñ := by\n    rw [L1.norm_def]\n    congr 1\n    apply lintegral_congr_ae\n    filter_upwards [Lp.coeFn_posPart f‚ÇÅ, hf.coeFn_toL1] with _ h‚ÇÅ h‚ÇÇ\n    rw [h‚ÇÅ, h‚ÇÇ, ENNReal.ofReal]\n    congr 1\n    apply NNReal.eq\n    rw [Real.nnnorm_of_nonneg (le_max_right _ _)]\n    rw [Real.coe_toNNReal', NNReal.coe_mk]\n  -- Go to the `L¬π` space\n  have eq‚ÇÇ : ENNReal.toReal (‚à´‚Åª a, ENNReal.ofReal (-f a) ‚àÇŒº) = ‚ÄñLp.negPart f‚ÇÅ‚Äñ := by\n    rw [L1.norm_def]\n    congr 1\n    apply lintegral_congr_ae\n    filter_upwards [Lp.coeFn_negPart f‚ÇÅ, hf.coeFn_toL1] with _ h‚ÇÅ h‚ÇÇ\n    rw [h‚ÇÅ, h‚ÇÇ, ENNReal.ofReal]\n    congr 1\n    apply NNReal.eq\n    simp only [Real.coe_toNNReal', coe_nnnorm, nnnorm_neg]\n    rw [Real.norm_of_nonpos (min_le_right _ _), ‚Üê max_neg_neg, neg_zero]\n  rw [eq‚ÇÅ, eq‚ÇÇ, integral, dif_pos, dif_pos]\n  exact L1.integral_eq_norm_posPart_sub _\n\n"}
{"name":"MeasureTheory.integral_eq_lintegral_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Real\nhf : (MeasureTheory.ae Œº).EventuallyLE 0 f\nhfm : MeasureTheory.AEStronglyMeasurable f Œº\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => f a) (MeasureTheory.lintegral Œº fun a => ENNReal.ofReal (f a)).toReal","decl":"theorem integral_eq_lintegral_of_nonneg_ae {f : Œ± ‚Üí ‚Ñù} (hf : 0 ‚â§·µê[Œº] f)\n    (hfm : AEStronglyMeasurable f Œº) :\n    ‚à´ a, f a ‚àÇŒº = ENNReal.toReal (‚à´‚Åª a, ENNReal.ofReal (f a) ‚àÇŒº) := by\n  by_cases hfi : Integrable f Œº\n  ¬∑ rw [integral_eq_lintegral_pos_part_sub_lintegral_neg_part hfi]\n    have h_min : ‚à´‚Åª a, ENNReal.ofReal (-f a) ‚àÇŒº = 0 := by\n      rw [lintegral_eq_zero_iff']\n      ¬∑ refine hf.mono ?_\n        simp only [Pi.zero_apply]\n        intro a h\n        simp only [h, neg_nonpos, ofReal_eq_zero]\n      ¬∑ exact measurable_ofReal.comp_aemeasurable hfm.aemeasurable.neg\n    rw [h_min, zero_toReal, _root_.sub_zero]\n  ¬∑ rw [integral_undef hfi]\n    simp_rw [Integrable, hfm, hasFiniteIntegral_iff_norm, lt_top_iff_ne_top, Ne, true_and,\n      Classical.not_not] at hfi\n    have : ‚à´‚Åª a : Œ±, ENNReal.ofReal (f a) ‚àÇŒº = ‚à´‚Åª a, ENNReal.ofReal ‚Äñf a‚Äñ ‚àÇŒº := by\n      refine lintegral_congr_ae (hf.mono fun a h => ?_)\n      dsimp only\n      rw [Real.norm_eq_abs, abs_of_nonneg h]\n    rw [this, hfi]; rfl\n\n"}
{"name":"MeasureTheory.integral_norm_eq_lintegral_enorm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nP : Type u_7\ninst‚úù : NormedAddCommGroup P\nf : Œ± ‚Üí P\nhf : MeasureTheory.AEStronglyMeasurable f Œº\n‚ä¢ Eq (MeasureTheory.integral Œº fun x => Norm.norm (f x)) (MeasureTheory.lintegral Œº fun x => ENorm.enorm (f x)).toReal","decl":"theorem integral_norm_eq_lintegral_enorm {P : Type*} [NormedAddCommGroup P] {f : Œ± ‚Üí P}\n    (hf : AEStronglyMeasurable f Œº) : ‚à´ x, ‚Äñf x‚Äñ ‚àÇŒº = (‚à´‚Åª x, ‚Äñf x‚Äñ‚Çë ‚àÇŒº).toReal := by\n  rw [integral_eq_lintegral_of_nonneg_ae _ hf.norm]\n  ¬∑ simp_rw [ofReal_norm_eq_enorm]\n  ¬∑ filter_upwards; simp_rw [Pi.zero_apply, norm_nonneg, imp_true_iff]\n\n"}
{"name":"MeasureTheory.integral_norm_eq_lintegral_nnnorm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nP : Type u_7\ninst‚úù : NormedAddCommGroup P\nf : Œ± ‚Üí P\nhf : MeasureTheory.AEStronglyMeasurable f Œº\n‚ä¢ Eq (MeasureTheory.integral Œº fun x => Norm.norm (f x)) (MeasureTheory.lintegral Œº fun x => ENorm.enorm (f x)).toReal","decl":"@[deprecated (since := \"2025-01-21\")]\nalias integral_norm_eq_lintegral_nnnorm := integral_norm_eq_lintegral_enorm\n\n"}
{"name":"MeasureTheory.ofReal_integral_norm_eq_lintegral_enorm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nP : Type u_7\ninst‚úù : NormedAddCommGroup P\nf : Œ± ‚Üí P\nhf : MeasureTheory.Integrable f Œº\n‚ä¢ Eq (ENNReal.ofReal (MeasureTheory.integral Œº fun x => Norm.norm (f x))) (MeasureTheory.lintegral Œº fun x => ENorm.enorm (f x))","decl":"theorem ofReal_integral_norm_eq_lintegral_enorm {P : Type*} [NormedAddCommGroup P] {f : Œ± ‚Üí P}\n    (hf : Integrable f Œº) : ENNReal.ofReal (‚à´ x, ‚Äñf x‚Äñ ‚àÇŒº) = ‚à´‚Åª x, ‚Äñf x‚Äñ‚Çë ‚àÇŒº := by\n  rw [integral_norm_eq_lintegral_enorm hf.aestronglyMeasurable, ENNReal.ofReal_toReal]\n  exact lt_top_iff_ne_top.mp (hasFiniteIntegral_iff_enorm.mpr hf.2)\n\n"}
{"name":"MeasureTheory.ofReal_integral_norm_eq_lintegral_nnnorm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nP : Type u_7\ninst‚úù : NormedAddCommGroup P\nf : Œ± ‚Üí P\nhf : MeasureTheory.Integrable f Œº\n‚ä¢ Eq (ENNReal.ofReal (MeasureTheory.integral Œº fun x => Norm.norm (f x))) (MeasureTheory.lintegral Œº fun x => ENorm.enorm (f x))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias ofReal_integral_norm_eq_lintegral_nnnorm := ofReal_integral_norm_eq_lintegral_enorm\n\n"}
{"name":"MeasureTheory.integral_eq_integral_pos_part_sub_integral_neg_part","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Real\nhf : MeasureTheory.Integrable f Œº\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => f a) (HSub.hSub (MeasureTheory.integral Œº fun a => ‚Üë(f a).toNNReal) (MeasureTheory.integral Œº fun a => ‚Üë(Neg.neg (f a)).toNNReal))","decl":"theorem integral_eq_integral_pos_part_sub_integral_neg_part {f : Œ± ‚Üí ‚Ñù} (hf : Integrable f Œº) :\n    ‚à´ a, f a ‚àÇŒº = ‚à´ a, (Real.toNNReal (f a) : ‚Ñù) ‚àÇŒº - ‚à´ a, (Real.toNNReal (-f a) : ‚Ñù) ‚àÇŒº := by\n  rw [‚Üê integral_sub hf.real_toNNReal]\n  ¬∑ simp\n  ¬∑ exact hf.neg.real_toNNReal\n\n"}
{"name":"MeasureTheory.integral_nonneg_of_ae","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Real\nhf : (MeasureTheory.ae Œº).EventuallyLE 0 f\n‚ä¢ LE.le 0 (MeasureTheory.integral Œº fun a => f a)","decl":"theorem integral_nonneg_of_ae {f : Œ± ‚Üí ‚Ñù} (hf : 0 ‚â§·µê[Œº] f) : 0 ‚â§ ‚à´ a, f a ‚àÇŒº := by\n  have A : CompleteSpace ‚Ñù := by infer_instance\n  simp only [integral_def, A, L1.integral_def, dite_true]\n  exact setToFun_nonneg (dominatedFinMeasAdditive_weightedSMul Œº)\n    (fun s _ _ => weightedSMul_nonneg s) hf\n\n"}
{"name":"MeasureTheory.lintegral_coe_eq_integral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí NNReal\nhfi : MeasureTheory.Integrable (fun x => ‚Üë(f x)) Œº\n‚ä¢ Eq (MeasureTheory.lintegral Œº fun a => ‚Üë(f a)) (ENNReal.ofReal (MeasureTheory.integral Œº fun a => ‚Üë(f a)))","decl":"theorem lintegral_coe_eq_integral (f : Œ± ‚Üí ‚Ñù‚â•0) (hfi : Integrable (fun x => (f x : ‚Ñù)) Œº) :\n    ‚à´‚Åª a, f a ‚àÇŒº = ENNReal.ofReal (‚à´ a, f a ‚àÇŒº) := by\n  simp_rw [integral_eq_lintegral_of_nonneg_ae (Eventually.of_forall fun x => (f x).coe_nonneg)\n      hfi.aestronglyMeasurable, ‚Üê ENNReal.coe_nnreal_eq]\n  rw [ENNReal.ofReal_toReal]\n  rw [‚Üê lt_top_iff_ne_top]\n  convert hfi.hasFiniteIntegral\n  -- Porting note: `convert` no longer unfolds `HasFiniteIntegral`\n  simp_rw [hasFiniteIntegral_iff_enorm, NNReal.enorm_eq]\n\n"}
{"name":"MeasureTheory.ofReal_integral_eq_lintegral_ofReal","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Real\nhfi : MeasureTheory.Integrable f Œº\nf_nn : (MeasureTheory.ae Œº).EventuallyLE 0 f\n‚ä¢ Eq (ENNReal.ofReal (MeasureTheory.integral Œº fun x => f x)) (MeasureTheory.lintegral Œº fun x => ENNReal.ofReal (f x))","decl":"theorem ofReal_integral_eq_lintegral_ofReal {f : Œ± ‚Üí ‚Ñù} (hfi : Integrable f Œº) (f_nn : 0 ‚â§·µê[Œº] f) :\n    ENNReal.ofReal (‚à´ x, f x ‚àÇŒº) = ‚à´‚Åª x, ENNReal.ofReal (f x) ‚àÇŒº := by\n  have : f =·µê[Œº] (‚Äñf ¬∑‚Äñ) := f_nn.mono fun _x hx ‚Ü¶ (abs_of_nonneg hx).symm\n  simp_rw [integral_congr_ae this, ofReal_integral_norm_eq_lintegral_enorm hfi,\n    ‚Üê ofReal_norm_eq_enorm]\n  exact lintegral_congr_ae (this.symm.fun_comp ENNReal.ofReal)\n\n"}
{"name":"MeasureTheory.integral_toReal","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí ENNReal\nhfm : AEMeasurable f Œº\nhf : Filter.Eventually (fun x => LT.lt (f x) Top.top) (MeasureTheory.ae Œº)\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => (f a).toReal) (MeasureTheory.lintegral Œº fun a => f a).toReal","decl":"theorem integral_toReal {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} (hfm : AEMeasurable f Œº) (hf : ‚àÄ·µê x ‚àÇŒº, f x < ‚àû) :\n    ‚à´ a, (f a).toReal ‚àÇŒº = (‚à´‚Åª a, f a ‚àÇŒº).toReal := by\n  rw [integral_eq_lintegral_of_nonneg_ae _ hfm.ennreal_toReal.aestronglyMeasurable,\n    lintegral_congr_ae (ofReal_toReal_ae_eq hf)]\n  exact Eventually.of_forall fun x => ENNReal.toReal_nonneg\n\n"}
{"name":"MeasureTheory.lintegral_coe_le_coe_iff_integral_le","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí NNReal\nhfi : MeasureTheory.Integrable (fun x => ‚Üë(f x)) Œº\nb : NNReal\n‚ä¢ Iff (LE.le (MeasureTheory.lintegral Œº fun a => ‚Üë(f a)) ‚Üëb) (LE.le (MeasureTheory.integral Œº fun a => ‚Üë(f a)) ‚Üëb)","decl":"theorem lintegral_coe_le_coe_iff_integral_le {f : Œ± ‚Üí ‚Ñù‚â•0} (hfi : Integrable (fun x => (f x : ‚Ñù)) Œº)\n    {b : ‚Ñù‚â•0} : ‚à´‚Åª a, f a ‚àÇŒº ‚â§ b ‚Üî ‚à´ a, (f a : ‚Ñù) ‚àÇŒº ‚â§ b := by\n  rw [lintegral_coe_eq_integral f hfi, ENNReal.ofReal, ENNReal.coe_le_coe,\n    Real.toNNReal_le_iff_le_coe]\n\n"}
{"name":"MeasureTheory.integral_coe_le_of_lintegral_coe_le","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí NNReal\nb : NNReal\nh : LE.le (MeasureTheory.lintegral Œº fun a => ‚Üë(f a)) ‚Üëb\n‚ä¢ LE.le (MeasureTheory.integral Œº fun a => ‚Üë(f a)) ‚Üëb","decl":"theorem integral_coe_le_of_lintegral_coe_le {f : Œ± ‚Üí ‚Ñù‚â•0} {b : ‚Ñù‚â•0} (h : ‚à´‚Åª a, f a ‚àÇŒº ‚â§ b) :\n    ‚à´ a, (f a : ‚Ñù) ‚àÇŒº ‚â§ b := by\n  by_cases hf : Integrable (fun a => (f a : ‚Ñù)) Œº\n  ¬∑ exact (lintegral_coe_le_coe_iff_integral_le hf).1 h\n  ¬∑ rw [integral_undef hf]; exact b.2\n\n"}
{"name":"MeasureTheory.integral_nonneg","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Real\nhf : LE.le 0 f\n‚ä¢ LE.le 0 (MeasureTheory.integral Œº fun a => f a)","decl":"theorem integral_nonneg {f : Œ± ‚Üí ‚Ñù} (hf : 0 ‚â§ f) : 0 ‚â§ ‚à´ a, f a ‚àÇŒº :=\n  integral_nonneg_of_ae <| Eventually.of_forall hf\n\n"}
{"name":"MeasureTheory.integral_nonpos_of_ae","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Real\nhf : (MeasureTheory.ae Œº).EventuallyLE f 0\n‚ä¢ LE.le (MeasureTheory.integral Œº fun a => f a) 0","decl":"theorem integral_nonpos_of_ae {f : Œ± ‚Üí ‚Ñù} (hf : f ‚â§·µê[Œº] 0) : ‚à´ a, f a ‚àÇŒº ‚â§ 0 := by\n  have hf : 0 ‚â§·µê[Œº] -f := hf.mono fun a h => by rwa [Pi.neg_apply, Pi.zero_apply, neg_nonneg]\n  have : 0 ‚â§ ‚à´ a, -f a ‚àÇŒº := integral_nonneg_of_ae hf\n  rwa [integral_neg, neg_nonneg] at this\n\n"}
{"name":"MeasureTheory.integral_nonpos","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Real\nhf : LE.le f 0\n‚ä¢ LE.le (MeasureTheory.integral Œº fun a => f a) 0","decl":"theorem integral_nonpos {f : Œ± ‚Üí ‚Ñù} (hf : f ‚â§ 0) : ‚à´ a, f a ‚àÇŒº ‚â§ 0 :=\n  integral_nonpos_of_ae <| Eventually.of_forall hf\n\n"}
{"name":"MeasureTheory.integral_eq_zero_iff_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Real\nhf : (MeasureTheory.ae Œº).EventuallyLE 0 f\nhfi : MeasureTheory.Integrable f Œº\n‚ä¢ Iff (Eq (MeasureTheory.integral Œº fun x => f x) 0) ((MeasureTheory.ae Œº).EventuallyEq f 0)","decl":"theorem integral_eq_zero_iff_of_nonneg_ae {f : Œ± ‚Üí ‚Ñù} (hf : 0 ‚â§·µê[Œº] f) (hfi : Integrable f Œº) :\n    ‚à´ x, f x ‚àÇŒº = 0 ‚Üî f =·µê[Œº] 0 := by\n  simp_rw [integral_eq_lintegral_of_nonneg_ae hf hfi.1, ENNReal.toReal_eq_zero_iff,\n    ‚Üê ENNReal.not_lt_top, ‚Üê hasFiniteIntegral_iff_ofReal hf, hfi.2, not_true_eq_false, or_false]\n  -- Porting note: split into parts, to make `rw` and `simp` work\n  rw [lintegral_eq_zero_iff']\n  ¬∑ rw [‚Üê hf.le_iff_eq, Filter.EventuallyEq, Filter.EventuallyLE]\n    simp only [Pi.zero_apply, ofReal_eq_zero]\n  ¬∑ exact (ENNReal.measurable_ofReal.comp_aemeasurable hfi.1.aemeasurable)\n\n"}
{"name":"MeasureTheory.integral_eq_zero_iff_of_nonneg","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Real\nhf : LE.le 0 f\nhfi : MeasureTheory.Integrable f Œº\n‚ä¢ Iff (Eq (MeasureTheory.integral Œº fun x => f x) 0) ((MeasureTheory.ae Œº).EventuallyEq f 0)","decl":"theorem integral_eq_zero_iff_of_nonneg {f : Œ± ‚Üí ‚Ñù} (hf : 0 ‚â§ f) (hfi : Integrable f Œº) :\n    ‚à´ x, f x ‚àÇŒº = 0 ‚Üî f =·µê[Œº] 0 :=\n  integral_eq_zero_iff_of_nonneg_ae (Eventually.of_forall hf) hfi\n\n"}
{"name":"MeasureTheory.integral_eq_iff_of_ae_le","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí Real\nhf : MeasureTheory.Integrable f Œº\nhg : MeasureTheory.Integrable g Œº\nhfg : (MeasureTheory.ae Œº).EventuallyLE f g\n‚ä¢ Iff (Eq (MeasureTheory.integral Œº fun a => f a) (MeasureTheory.integral Œº fun a => g a)) ((MeasureTheory.ae Œº).EventuallyEq f g)","decl":"lemma integral_eq_iff_of_ae_le {f g : Œ± ‚Üí ‚Ñù}\n    (hf : Integrable f Œº) (hg : Integrable g Œº) (hfg : f ‚â§·µê[Œº] g) :\n    ‚à´ a, f a ‚àÇŒº = ‚à´ a, g a ‚àÇŒº ‚Üî f =·µê[Œº] g := by\n  refine ‚ü®fun h_le ‚Ü¶ EventuallyEq.symm ?_, fun h ‚Ü¶ integral_congr_ae h‚ü©\n  rw [‚Üê sub_ae_eq_zero,\n    ‚Üê integral_eq_zero_iff_of_nonneg_ae ((sub_nonneg_ae _ _).mpr hfg) (hg.sub hf)]\n  simpa [Pi.sub_apply, integral_sub hg hf, sub_eq_zero, eq_comm]\n\n"}
{"name":"MeasureTheory.integral_pos_iff_support_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Real\nhf : (MeasureTheory.ae Œº).EventuallyLE 0 f\nhfi : MeasureTheory.Integrable f Œº\n‚ä¢ Iff (LT.lt 0 (MeasureTheory.integral Œº fun x => f x)) (LT.lt 0 (Œº (Function.support f)))","decl":"theorem integral_pos_iff_support_of_nonneg_ae {f : Œ± ‚Üí ‚Ñù} (hf : 0 ‚â§·µê[Œº] f) (hfi : Integrable f Œº) :\n    (0 < ‚à´ x, f x ‚àÇŒº) ‚Üî 0 < Œº (Function.support f) := by\n  simp_rw [(integral_nonneg_of_ae hf).lt_iff_ne, pos_iff_ne_zero, Ne, @eq_comm ‚Ñù 0,\n    integral_eq_zero_iff_of_nonneg_ae hf hfi, Filter.EventuallyEq, ae_iff, Pi.zero_apply,\n    Function.support]\n\n"}
{"name":"MeasureTheory.integral_pos_iff_support_of_nonneg","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Real\nhf : LE.le 0 f\nhfi : MeasureTheory.Integrable f Œº\n‚ä¢ Iff (LT.lt 0 (MeasureTheory.integral Œº fun x => f x)) (LT.lt 0 (Œº (Function.support f)))","decl":"theorem integral_pos_iff_support_of_nonneg {f : Œ± ‚Üí ‚Ñù} (hf : 0 ‚â§ f) (hfi : Integrable f Œº) :\n    (0 < ‚à´ x, f x ‚àÇŒº) ‚Üî 0 < Œº (Function.support f) :=\n  integral_pos_iff_support_of_nonneg_ae (Eventually.of_forall hf) hfi\n\n"}
{"name":"MeasureTheory.integral_exp_pos","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Real\nhŒº : NeZero Œº\nhf : MeasureTheory.Integrable (fun x => Real.exp (f x)) Œº\n‚ä¢ LT.lt 0 (MeasureTheory.integral Œº fun x => Real.exp (f x))","decl":"lemma integral_exp_pos {Œº : Measure Œ±} {f : Œ± ‚Üí ‚Ñù} [hŒº : NeZero Œº]\n    (hf : Integrable (fun x ‚Ü¶ Real.exp (f x)) Œº) :\n    0 < ‚à´ x, Real.exp (f x) ‚àÇŒº := by\n  rw [integral_pos_iff_support_of_nonneg (fun x ‚Ü¶ (Real.exp_pos _).le) hf]\n  suffices (Function.support fun x ‚Ü¶ Real.exp (f x)) = Set.univ by simp [this, hŒº.out]\n  ext1 x\n  simp only [Function.mem_support, ne_eq, (Real.exp_pos _).ne', not_false_eq_true, Set.mem_univ]\n\n"}
{"name":"MeasureTheory.integral_tendsto_of_tendsto_of_monotone","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Nat ‚Üí Œ± ‚Üí Real\nF : Œ± ‚Üí Real\nhf : ‚àÄ (n : Nat), MeasureTheory.Integrable (f n) Œº\nhF : MeasureTheory.Integrable F Œº\nh_mono : Filter.Eventually (fun x => Monotone fun n => f n x) (MeasureTheory.ae Œº)\nh_tendsto : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) (MeasureTheory.ae Œº)\n‚ä¢ Filter.Tendsto (fun n => MeasureTheory.integral Œº fun x => f n x) Filter.atTop (nhds (MeasureTheory.integral Œº fun x => F x))","decl":"/-- Monotone convergence theorem for real-valued functions and Bochner integrals -/\nlemma integral_tendsto_of_tendsto_of_monotone {Œº : Measure Œ±} {f : ‚Ñï ‚Üí Œ± ‚Üí ‚Ñù} {F : Œ± ‚Üí ‚Ñù}\n    (hf : ‚àÄ n, Integrable (f n) Œº) (hF : Integrable F Œº) (h_mono : ‚àÄ·µê x ‚àÇŒº, Monotone fun n ‚Ü¶ f n x)\n    (h_tendsto : ‚àÄ·µê x ‚àÇŒº, Tendsto (fun n ‚Ü¶ f n x) atTop (ùìù (F x))) :\n    Tendsto (fun n ‚Ü¶ ‚à´ x, f n x ‚àÇŒº) atTop (ùìù (‚à´ x, F x ‚àÇŒº)) := by\n  -- switch from the Bochner to the Lebesgue integral\n  let f' := fun n x ‚Ü¶ f n x - f 0 x\n  have hf'_nonneg : ‚àÄ·µê x ‚àÇŒº, ‚àÄ n, 0 ‚â§ f' n x := by\n    filter_upwards [h_mono] with a ha n\n    simp [f', ha (zero_le n)]\n  have hf'_meas : ‚àÄ n, Integrable (f' n) Œº := fun n ‚Ü¶ (hf n).sub (hf 0)\n  suffices Tendsto (fun n ‚Ü¶ ‚à´ x, f' n x ‚àÇŒº) atTop (ùìù (‚à´ x, (F - f 0) x ‚àÇŒº)) by\n    simp_rw [f', integral_sub (hf _) (hf _), integral_sub' hF (hf 0),\n      tendsto_sub_const_iff] at this\n    exact this\n  have hF_ge : 0 ‚â§·µê[Œº] fun x ‚Ü¶ (F - f 0) x := by\n    filter_upwards [h_tendsto, h_mono] with x hx_tendsto hx_mono\n    simp only [Pi.zero_apply, Pi.sub_apply, sub_nonneg]\n    exact ge_of_tendsto' hx_tendsto (fun n ‚Ü¶ hx_mono (zero_le _))\n  rw [ae_all_iff] at hf'_nonneg\n  simp_rw [integral_eq_lintegral_of_nonneg_ae (hf'_nonneg _) (hf'_meas _).1]\n  rw [integral_eq_lintegral_of_nonneg_ae hF_ge (hF.1.sub (hf 0).1)]\n  have h_cont := ENNReal.continuousAt_toReal (x := ‚à´‚Åª a, ENNReal.ofReal ((F - f 0) a) ‚àÇŒº) ?_\n  swap\n  ¬∑ rw [‚Üê ofReal_integral_eq_lintegral_ofReal (hF.sub (hf 0)) hF_ge]\n    exact ENNReal.ofReal_ne_top\n  refine h_cont.tendsto.comp ?_\n  -- use the result for the Lebesgue integral\n  refine lintegral_tendsto_of_tendsto_of_monotone ?_ ?_ ?_\n  ¬∑ exact fun n ‚Ü¶ ((hf n).sub (hf 0)).aemeasurable.ennreal_ofReal\n  ¬∑ filter_upwards [h_mono] with x hx n m hnm\n    refine ENNReal.ofReal_le_ofReal ?_\n    simp only [f', tsub_le_iff_right, sub_add_cancel]\n    exact hx hnm\n  ¬∑ filter_upwards [h_tendsto] with x hx\n    refine (ENNReal.continuous_ofReal.tendsto _).comp ?_\n    simp only [Pi.sub_apply]\n    exact Tendsto.sub hx tendsto_const_nhds\n\n"}
{"name":"MeasureTheory.integral_tendsto_of_tendsto_of_antitone","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Nat ‚Üí Œ± ‚Üí Real\nF : Œ± ‚Üí Real\nhf : ‚àÄ (n : Nat), MeasureTheory.Integrable (f n) Œº\nhF : MeasureTheory.Integrable F Œº\nh_mono : Filter.Eventually (fun x => Antitone fun n => f n x) (MeasureTheory.ae Œº)\nh_tendsto : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) (MeasureTheory.ae Œº)\n‚ä¢ Filter.Tendsto (fun n => MeasureTheory.integral Œº fun x => f n x) Filter.atTop (nhds (MeasureTheory.integral Œº fun x => F x))","decl":"/-- Monotone convergence theorem for real-valued functions and Bochner integrals -/\nlemma integral_tendsto_of_tendsto_of_antitone {Œº : Measure Œ±} {f : ‚Ñï ‚Üí Œ± ‚Üí ‚Ñù} {F : Œ± ‚Üí ‚Ñù}\n    (hf : ‚àÄ n, Integrable (f n) Œº) (hF : Integrable F Œº) (h_mono : ‚àÄ·µê x ‚àÇŒº, Antitone fun n ‚Ü¶ f n x)\n    (h_tendsto : ‚àÄ·µê x ‚àÇŒº, Tendsto (fun n ‚Ü¶ f n x) atTop (ùìù (F x))) :\n    Tendsto (fun n ‚Ü¶ ‚à´ x, f n x ‚àÇŒº) atTop (ùìù (‚à´ x, F x ‚àÇŒº)) := by\n  suffices Tendsto (fun n ‚Ü¶ ‚à´ x, -f n x ‚àÇŒº) atTop (ùìù (‚à´ x, -F x ‚àÇŒº)) by\n    suffices Tendsto (fun n ‚Ü¶ ‚à´ x, - -f n x ‚àÇŒº) atTop (ùìù (‚à´ x, - -F x ‚àÇŒº)) by\n      simpa [neg_neg] using this\n    convert this.neg <;> rw [integral_neg]\n  refine integral_tendsto_of_tendsto_of_monotone (fun n ‚Ü¶ (hf n).neg) hF.neg ?_ ?_\n  ¬∑ filter_upwards [h_mono] with x hx n m hnm using neg_le_neg_iff.mpr <| hx hnm\n  ¬∑ filter_upwards [h_tendsto] with x hx using hx.neg\n\n"}
{"name":"MeasureTheory.tendsto_of_integral_tendsto_of_monotone","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Nat ‚Üí Œ± ‚Üí Real\nF : Œ± ‚Üí Real\nhf_int : ‚àÄ (n : Nat), MeasureTheory.Integrable (f n) Œº\nhF_int : MeasureTheory.Integrable F Œº\nhf_tendsto : Filter.Tendsto (fun i => MeasureTheory.integral Œº fun a => f i a) Filter.atTop (nhds (MeasureTheory.integral Œº fun a => F a))\nhf_mono : Filter.Eventually (fun a => Monotone fun i => f i a) (MeasureTheory.ae Œº)\nhf_bound : Filter.Eventually (fun a => ‚àÄ (i : Nat), LE.le (f i a) (F a)) (MeasureTheory.ae Œº)\n‚ä¢ Filter.Eventually (fun a => Filter.Tendsto (fun i => f i a) Filter.atTop (nhds (F a))) (MeasureTheory.ae Œº)","decl":"/-- If a monotone sequence of functions has an upper bound and the sequence of integrals of these\nfunctions tends to the integral of the upper bound, then the sequence of functions converges\nalmost everywhere to the upper bound. -/\nlemma tendsto_of_integral_tendsto_of_monotone {Œº : Measure Œ±} {f : ‚Ñï ‚Üí Œ± ‚Üí ‚Ñù} {F : Œ± ‚Üí ‚Ñù}\n    (hf_int : ‚àÄ n, Integrable (f n) Œº) (hF_int : Integrable F Œº)\n    (hf_tendsto : Tendsto (fun i ‚Ü¶ ‚à´ a, f i a ‚àÇŒº) atTop (ùìù (‚à´ a, F a ‚àÇŒº)))\n    (hf_mono : ‚àÄ·µê a ‚àÇŒº, Monotone (fun i ‚Ü¶ f i a))\n    (hf_bound : ‚àÄ·µê a ‚àÇŒº, ‚àÄ i, f i a ‚â§ F a) :\n    ‚àÄ·µê a ‚àÇŒº, Tendsto (fun i ‚Ü¶ f i a) atTop (ùìù (F a)) := by\n  -- reduce to the `‚Ñù‚â•0‚àû` case\n  let f' : ‚Ñï ‚Üí Œ± ‚Üí ‚Ñù‚â•0‚àû := fun n a ‚Ü¶ ENNReal.ofReal (f n a - f 0 a)\n  let F' : Œ± ‚Üí ‚Ñù‚â•0‚àû := fun a ‚Ü¶ ENNReal.ofReal (F a - f 0 a)\n  have hf'_int_eq : ‚àÄ i, ‚à´‚Åª a, f' i a ‚àÇŒº = ENNReal.ofReal (‚à´ a, f i a ‚àÇŒº - ‚à´ a, f 0 a ‚àÇŒº) := by\n    intro i\n    unfold f'\n    rw [‚Üê ofReal_integral_eq_lintegral_ofReal, integral_sub (hf_int i) (hf_int 0)]\n    ¬∑ exact (hf_int i).sub (hf_int 0)\n    ¬∑ filter_upwards [hf_mono] with a h_mono\n      simp [h_mono (zero_le i)]\n  have hF'_int_eq : ‚à´‚Åª a, F' a ‚àÇŒº = ENNReal.ofReal (‚à´ a, F a ‚àÇŒº - ‚à´ a, f 0 a ‚àÇŒº) := by\n    unfold F'\n    rw [‚Üê ofReal_integral_eq_lintegral_ofReal, integral_sub hF_int (hf_int 0)]\n    ¬∑ exact hF_int.sub (hf_int 0)\n    ¬∑ filter_upwards [hf_bound] with a h_bound\n      simp [h_bound 0]\n  have h_tendsto : Tendsto (fun i ‚Ü¶ ‚à´‚Åª a, f' i a ‚àÇŒº) atTop (ùìù (‚à´‚Åª a, F' a ‚àÇŒº)) := by\n    simp_rw [hf'_int_eq, hF'_int_eq]\n    refine (ENNReal.continuous_ofReal.tendsto _).comp ?_\n    rwa [tendsto_sub_const_iff]\n  have h_mono : ‚àÄ·µê a ‚àÇŒº, Monotone (fun i ‚Ü¶ f' i a) := by\n    filter_upwards [hf_mono] with a ha_mono i j hij\n    refine ENNReal.ofReal_le_ofReal ?_\n    simp [ha_mono hij]\n  have h_bound : ‚àÄ·µê a ‚àÇŒº, ‚àÄ i, f' i a ‚â§ F' a := by\n    filter_upwards [hf_bound] with a ha_bound i\n    refine ENNReal.ofReal_le_ofReal ?_\n    simp only [tsub_le_iff_right, sub_add_cancel, ha_bound i]\n  -- use the corresponding lemma for `‚Ñù‚â•0‚àû`\n  have h := tendsto_of_lintegral_tendsto_of_monotone ?_ h_tendsto h_mono h_bound ?_\n  rotate_left\n  ¬∑ exact (hF_int.1.aemeasurable.sub (hf_int 0).1.aemeasurable).ennreal_ofReal\n  ¬∑ exact ((lintegral_ofReal_le_lintegral_enorm _).trans_lt (hF_int.sub (hf_int 0)).2).ne\n  filter_upwards [h, hf_mono, hf_bound] with a ha ha_mono ha_bound\n  have h1 : (fun i ‚Ü¶ f i a) = fun i ‚Ü¶ (f' i a).toReal + f 0 a := by\n    unfold f'\n    ext i\n    rw [ENNReal.toReal_ofReal]\n    ¬∑ abel\n    ¬∑ simp [ha_mono (zero_le i)]\n  have h2 : F a = (F' a).toReal + f 0 a := by\n    unfold F'\n    rw [ENNReal.toReal_ofReal]\n    ¬∑ abel\n    ¬∑ simp [ha_bound 0]\n  rw [h1, h2]\n  refine Filter.Tendsto.add ?_ tendsto_const_nhds\n  exact (ENNReal.continuousAt_toReal ENNReal.ofReal_ne_top).tendsto.comp ha\n\n"}
{"name":"MeasureTheory.tendsto_of_integral_tendsto_of_antitone","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Nat ‚Üí Œ± ‚Üí Real\nF : Œ± ‚Üí Real\nhf_int : ‚àÄ (n : Nat), MeasureTheory.Integrable (f n) Œº\nhF_int : MeasureTheory.Integrable F Œº\nhf_tendsto : Filter.Tendsto (fun i => MeasureTheory.integral Œº fun a => f i a) Filter.atTop (nhds (MeasureTheory.integral Œº fun a => F a))\nhf_mono : Filter.Eventually (fun a => Antitone fun i => f i a) (MeasureTheory.ae Œº)\nhf_bound : Filter.Eventually (fun a => ‚àÄ (i : Nat), LE.le (F a) (f i a)) (MeasureTheory.ae Œº)\n‚ä¢ Filter.Eventually (fun a => Filter.Tendsto (fun i => f i a) Filter.atTop (nhds (F a))) (MeasureTheory.ae Œº)","decl":"/-- If an antitone sequence of functions has a lower bound and the sequence of integrals of these\nfunctions tends to the integral of the lower bound, then the sequence of functions converges\nalmost everywhere to the lower bound. -/\nlemma tendsto_of_integral_tendsto_of_antitone {Œº : Measure Œ±} {f : ‚Ñï ‚Üí Œ± ‚Üí ‚Ñù} {F : Œ± ‚Üí ‚Ñù}\n    (hf_int : ‚àÄ n, Integrable (f n) Œº) (hF_int : Integrable F Œº)\n    (hf_tendsto : Tendsto (fun i ‚Ü¶ ‚à´ a, f i a ‚àÇŒº) atTop (ùìù (‚à´ a, F a ‚àÇŒº)))\n    (hf_mono : ‚àÄ·µê a ‚àÇŒº, Antitone (fun i ‚Ü¶ f i a))\n    (hf_bound : ‚àÄ·µê a ‚àÇŒº, ‚àÄ i, F a ‚â§ f i a) :\n    ‚àÄ·µê a ‚àÇŒº, Tendsto (fun i ‚Ü¶ f i a) atTop (ùìù (F a)) := by\n  let f' : ‚Ñï ‚Üí Œ± ‚Üí ‚Ñù := fun i a ‚Ü¶ - f i a\n  let F' : Œ± ‚Üí ‚Ñù := fun a ‚Ü¶ - F a\n  suffices ‚àÄ·µê a ‚àÇŒº, Tendsto (fun i ‚Ü¶ f' i a) atTop (ùìù (F' a)) by\n    filter_upwards [this] with a ha_tendsto\n    convert ha_tendsto.neg\n    ¬∑ simp [f']\n    ¬∑ simp [F']\n  refine tendsto_of_integral_tendsto_of_monotone (fun n ‚Ü¶ (hf_int n).neg) hF_int.neg ?_ ?_ ?_\n  ¬∑ convert hf_tendsto.neg\n    ¬∑ rw [integral_neg]\n    ¬∑ rw [integral_neg]\n  ¬∑ filter_upwards [hf_mono] with a ha i j hij\n    simp [f', ha hij]\n  ¬∑ filter_upwards [hf_bound] with a ha i\n    simp [f', F', ha i]\n\n"}
{"name":"MeasureTheory.L1.norm_eq_integral_norm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nH : Type u_7\ninst‚úù : NormedAddCommGroup H\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp H 1 Œº) x\n‚ä¢ Eq (Norm.norm f) (MeasureTheory.integral Œº fun a => Norm.norm (‚Üë‚Üëf a))","decl":"theorem L1.norm_eq_integral_norm (f : Œ± ‚Üí‚ÇÅ[Œº] H) : ‚Äñf‚Äñ = ‚à´ a, ‚Äñf a‚Äñ ‚àÇŒº := by\n  simp only [eLpNorm, eLpNorm'_eq_lintegral_enorm, ENNReal.one_toReal, ENNReal.rpow_one,\n    Lp.norm_def, if_false, ENNReal.one_ne_top, one_ne_zero, _root_.div_one]\n  rw [integral_eq_lintegral_of_nonneg_ae (Eventually.of_forall (by simp [norm_nonneg]))\n      (Lp.aestronglyMeasurable f).norm]\n  simp [ofReal_norm_eq_enorm]\n\n"}
{"name":"MeasureTheory.L1.dist_eq_integral_dist","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nH : Type u_7\ninst‚úù : NormedAddCommGroup H\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp H 1 Œº) x\n‚ä¢ Eq (Dist.dist f g) (MeasureTheory.integral Œº fun a => Dist.dist (‚Üë‚Üëf a) (‚Üë‚Üëg a))","decl":"theorem L1.dist_eq_integral_dist (f g : Œ± ‚Üí‚ÇÅ[Œº] H) : dist f g = ‚à´ a, dist (f a) (g a) ‚àÇŒº := by\n  simp only [dist_eq_norm, L1.norm_eq_integral_norm]\n  exact integral_congr_ae <| (Lp.coeFn_sub _ _).fun_comp norm\n\n"}
{"name":"MeasureTheory.L1.norm_of_fun_eq_integral_norm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nH : Type u_7\ninst‚úù : NormedAddCommGroup H\nf : Œ± ‚Üí H\nhf : MeasureTheory.Integrable f Œº\n‚ä¢ Eq (Norm.norm (MeasureTheory.Integrable.toL1 f hf)) (MeasureTheory.integral Œº fun a => Norm.norm (f a))","decl":"theorem L1.norm_of_fun_eq_integral_norm {f : Œ± ‚Üí H} (hf : Integrable f Œº) :\n    ‚Äñhf.toL1 f‚Äñ = ‚à´ a, ‚Äñf a‚Äñ ‚àÇŒº := by\n  rw [L1.norm_eq_integral_norm]\n  exact integral_congr_ae <| hf.coeFn_toL1.fun_comp _\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.eLpNorm_eq_integral_rpow_norm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nH : Type u_7\ninst‚úù : NormedAddCommGroup H\nf : Œ± ‚Üí H\np : ENNReal\nhp1 : Ne p 0\nhp2 : Ne p Top.top\nhf : MeasureTheory.Mem‚Ñíp f p Œº\n‚ä¢ Eq (MeasureTheory.eLpNorm f p Œº) (ENNReal.ofReal (HPow.hPow (MeasureTheory.integral Œº fun a => HPow.hPow (Norm.norm (f a)) p.toReal) (Inv.inv p.toReal)))","decl":"theorem Mem‚Ñíp.eLpNorm_eq_integral_rpow_norm {f : Œ± ‚Üí H} {p : ‚Ñù‚â•0‚àû} (hp1 : p ‚â† 0) (hp2 : p ‚â† ‚àû)\n    (hf : Mem‚Ñíp f p Œº) :\n    eLpNorm f p Œº = ENNReal.ofReal ((‚à´ a, ‚Äñf a‚Äñ ^ p.toReal ‚àÇŒº) ^ p.toReal‚Åª¬π) := by\n  have A : ‚à´‚Åª a : Œ±, ENNReal.ofReal (‚Äñf a‚Äñ ^ p.toReal) ‚àÇŒº = ‚à´‚Åª a : Œ±, ‚Äñf a‚Äñ‚Çë ^ p.toReal ‚àÇŒº := by\n    simp_rw [‚Üê ofReal_rpow_of_nonneg (norm_nonneg _) toReal_nonneg, ofReal_norm_eq_enorm]\n  simp only [eLpNorm_eq_lintegral_rpow_enorm hp1 hp2, one_div]\n  rw [integral_eq_lintegral_of_nonneg_ae]; rotate_left\n  ¬∑ exact ae_of_all _ fun x => by positivity\n  ¬∑ exact (hf.aestronglyMeasurable.norm.aemeasurable.pow_const _).aestronglyMeasurable\n  rw [A, ‚Üê ofReal_rpow_of_nonneg toReal_nonneg (inv_nonneg.2 toReal_nonneg), ofReal_toReal]\n  exact (lintegral_rpow_enorm_lt_top_of_eLpNorm_lt_top hp1 hp2 hf.2).ne\n\n"}
{"name":"MeasureTheory.integral_mono_ae","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí Real\nhf : MeasureTheory.Integrable f Œº\nhg : MeasureTheory.Integrable g Œº\nh : (MeasureTheory.ae Œº).EventuallyLE f g\n‚ä¢ LE.le (MeasureTheory.integral Œº fun a => f a) (MeasureTheory.integral Œº fun a => g a)","decl":"theorem integral_mono_ae {f g : Œ± ‚Üí ‚Ñù} (hf : Integrable f Œº) (hg : Integrable g Œº) (h : f ‚â§·µê[Œº] g) :\n    ‚à´ a, f a ‚àÇŒº ‚â§ ‚à´ a, g a ‚àÇŒº := by\n  have A : CompleteSpace ‚Ñù := by infer_instance\n  simp only [integral, A, L1.integral]\n  exact setToFun_mono (dominatedFinMeasAdditive_weightedSMul Œº)\n    (fun s _ _ => weightedSMul_nonneg s) hf hg h\n\n"}
{"name":"MeasureTheory.integral_mono","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí Real\nhf : MeasureTheory.Integrable f Œº\nhg : MeasureTheory.Integrable g Œº\nh : LE.le f g\n‚ä¢ LE.le (MeasureTheory.integral Œº fun a => f a) (MeasureTheory.integral Œº fun a => g a)","decl":"@[gcongr, mono]\ntheorem integral_mono {f g : Œ± ‚Üí ‚Ñù} (hf : Integrable f Œº) (hg : Integrable g Œº) (h : f ‚â§ g) :\n    ‚à´ a, f a ‚àÇŒº ‚â§ ‚à´ a, g a ‚àÇŒº :=\n  integral_mono_ae hf hg <| Eventually.of_forall h\n\n"}
{"name":"MeasureTheory.integral_mono_of_nonneg","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí Real\nhf : (MeasureTheory.ae Œº).EventuallyLE 0 f\nhgi : MeasureTheory.Integrable g Œº\nh : (MeasureTheory.ae Œº).EventuallyLE f g\n‚ä¢ LE.le (MeasureTheory.integral Œº fun a => f a) (MeasureTheory.integral Œº fun a => g a)","decl":"theorem integral_mono_of_nonneg {f g : Œ± ‚Üí ‚Ñù} (hf : 0 ‚â§·µê[Œº] f) (hgi : Integrable g Œº)\n    (h : f ‚â§·µê[Œº] g) : ‚à´ a, f a ‚àÇŒº ‚â§ ‚à´ a, g a ‚àÇŒº := by\n  by_cases hfm : AEStronglyMeasurable f Œº\n  ¬∑ refine integral_mono_ae ‚ü®hfm, ?_‚ü© hgi h\n    refine hgi.hasFiniteIntegral.mono <| h.mp <| hf.mono fun x hf hfg => ?_\n    simpa [abs_of_nonneg hf, abs_of_nonneg (le_trans hf hfg)]\n  ¬∑ rw [integral_non_aestronglyMeasurable hfm]\n    exact integral_nonneg_of_ae (hf.trans h)\n\n"}
{"name":"MeasureTheory.integral_mono_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Real\nŒΩ : MeasureTheory.Measure Œ±\nhle : LE.le Œº ŒΩ\nhf : (MeasureTheory.ae ŒΩ).EventuallyLE 0 f\nhfi : MeasureTheory.Integrable f ŒΩ\n‚ä¢ LE.le (MeasureTheory.integral Œº fun a => f a) (MeasureTheory.integral ŒΩ fun a => f a)","decl":"theorem integral_mono_measure {f : Œ± ‚Üí ‚Ñù} {ŒΩ} (hle : Œº ‚â§ ŒΩ) (hf : 0 ‚â§·µê[ŒΩ] f)\n    (hfi : Integrable f ŒΩ) : ‚à´ a, f a ‚àÇŒº ‚â§ ‚à´ a, f a ‚àÇŒΩ := by\n  have hfi' : Integrable f Œº := hfi.mono_measure hle\n  have hf' : 0 ‚â§·µê[Œº] f := hle.absolutelyContinuous hf\n  rw [integral_eq_lintegral_of_nonneg_ae hf' hfi'.1, integral_eq_lintegral_of_nonneg_ae hf hfi.1]\n  refine ENNReal.toReal_mono ?_ (lintegral_mono' hle le_rfl)\n  exact ((hasFiniteIntegral_iff_ofReal hf).1 hfi.2).ne\n\n"}
{"name":"MeasureTheory.norm_integral_le_integral_norm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí G\n‚ä¢ LE.le (Norm.norm (MeasureTheory.integral Œº fun a => f a)) (MeasureTheory.integral Œº fun a => Norm.norm (f a))","decl":"theorem norm_integral_le_integral_norm (f : Œ± ‚Üí G) : ‚Äñ‚à´ a, f a ‚àÇŒº‚Äñ ‚â§ ‚à´ a, ‚Äñf a‚Äñ ‚àÇŒº := by\n  have le_ae : ‚àÄ·µê a ‚àÇŒº, 0 ‚â§ ‚Äñf a‚Äñ := Eventually.of_forall fun a => norm_nonneg _\n  by_cases h : AEStronglyMeasurable f Œº\n  ¬∑ calc\n      ‚Äñ‚à´ a, f a ‚àÇŒº‚Äñ ‚â§ ENNReal.toReal (‚à´‚Åª a, ENNReal.ofReal ‚Äñf a‚Äñ ‚àÇŒº) :=\n        norm_integral_le_lintegral_norm _\n      _ = ‚à´ a, ‚Äñf a‚Äñ ‚àÇŒº := (integral_eq_lintegral_of_nonneg_ae le_ae <| h.norm).symm\n  ¬∑ rw [integral_non_aestronglyMeasurable h, norm_zero]\n    exact integral_nonneg_of_ae le_ae\n\n"}
{"name":"MeasureTheory.abs_integral_le_integral_abs","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Real\n‚ä¢ LE.le (abs (MeasureTheory.integral Œº fun a => f a)) (MeasureTheory.integral Œº fun a => abs (f a))","decl":"lemma abs_integral_le_integral_abs {f : Œ± ‚Üí ‚Ñù} : |‚à´ a, f a ‚àÇŒº| ‚â§ ‚à´ a, |f a| ‚àÇŒº :=\n  norm_integral_le_integral_norm f\n\n"}
{"name":"MeasureTheory.norm_integral_le_of_norm_le","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí G\ng : Œ± ‚Üí Real\nhg : MeasureTheory.Integrable g Œº\nh : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) (g x)) (MeasureTheory.ae Œº)\n‚ä¢ LE.le (Norm.norm (MeasureTheory.integral Œº fun x => f x)) (MeasureTheory.integral Œº fun x => g x)","decl":"theorem norm_integral_le_of_norm_le {f : Œ± ‚Üí G} {g : Œ± ‚Üí ‚Ñù} (hg : Integrable g Œº)\n    (h : ‚àÄ·µê x ‚àÇŒº, ‚Äñf x‚Äñ ‚â§ g x) : ‚Äñ‚à´ x, f x ‚àÇŒº‚Äñ ‚â§ ‚à´ x, g x ‚àÇŒº :=\n  calc\n    ‚Äñ‚à´ x, f x ‚àÇŒº‚Äñ ‚â§ ‚à´ x, ‚Äñf x‚Äñ ‚àÇŒº := norm_integral_le_integral_norm f\n    _ ‚â§ ‚à´ x, g x ‚àÇŒº := integral_mono_of_nonneg (Eventually.of_forall fun _ => norm_nonneg _) hg h\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_eq_integral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\nhE : CompleteSpace E\ninst‚úù : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : MeasureTheory.SimpleFunc Œ± E\nhfi : MeasureTheory.Integrable (‚áëf) Œº\n‚ä¢ Eq (MeasureTheory.SimpleFunc.integral Œº f) (MeasureTheory.integral Œº fun x => f x)","decl":"theorem SimpleFunc.integral_eq_integral (f : Œ± ‚Üí‚Çõ E) (hfi : Integrable f Œº) :\n    f.integral Œº = ‚à´ x, f x ‚àÇŒº := by\n  rw [MeasureTheory.integral_eq f hfi, ‚Üê L1.SimpleFunc.toLp_one_eq_toL1,\n    L1.SimpleFunc.integral_L1_eq_integral, L1.SimpleFunc.integral_eq_integral]\n  exact SimpleFunc.integral_congr hfi (Lp.simpleFunc.toSimpleFunc_toLp _ _).symm\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_eq_sum","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\nhE : CompleteSpace E\ninst‚úù : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : MeasureTheory.SimpleFunc Œ± E\nhfi : MeasureTheory.Integrable (‚áëf) Œº\n‚ä¢ Eq (MeasureTheory.integral Œº fun x => f x) (f.range.sum fun x => HSMul.hSMul (Œº (Set.preimage (‚áëf) (Singleton.singleton x))).toReal x)","decl":"theorem SimpleFunc.integral_eq_sum (f : Œ± ‚Üí‚Çõ E) (hfi : Integrable f Œº) :\n    ‚à´ x, f x ‚àÇŒº = ‚àë x ‚àà f.range, ENNReal.toReal (Œº (f ‚Åª¬π' {x})) ‚Ä¢ x := by\n  rw [‚Üê f.integral_eq_integral hfi, SimpleFunc.integral, ‚Üê SimpleFunc.integral_eq]; rfl\n\n"}
{"name":"MeasureTheory.integral_const","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\nhE : CompleteSpace E\ninst‚úù : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nc : E\n‚ä¢ Eq (MeasureTheory.integral Œº fun x => c) (HSMul.hSMul (Œº Set.univ).toReal c)","decl":"@[simp]\ntheorem integral_const (c : E) : ‚à´ _ : Œ±, c ‚àÇŒº = (Œº univ).toReal ‚Ä¢ c := by\n  by_cases hŒº : IsFiniteMeasure Œº\n  ¬∑ simp only [integral, hE, L1.integral]\n    exact setToFun_const (dominatedFinMeasAdditive_weightedSMul _) _\n  by_cases hc : c = 0\n  ¬∑ simp [hc, integral_zero]\n  ¬∑ simp [integral_undef, (integrable_const_iff_isFiniteMeasure hc).not.2 hŒº, *]\n    simp only [isFiniteMeasure_iff, not_lt, top_le_iff] at hŒº\n    simp [hŒº]\n\n"}
{"name":"MeasureTheory.norm_integral_le_of_norm_le_const","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬≤ : NormedAddCommGroup G\ninst‚úù¬π : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nf : Œ± ‚Üí G\nC : Real\nh : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) C) (MeasureTheory.ae Œº)\n‚ä¢ LE.le (Norm.norm (MeasureTheory.integral Œº fun x => f x)) (HMul.hMul C (Œº Set.univ).toReal)","decl":"theorem norm_integral_le_of_norm_le_const [IsFiniteMeasure Œº] {f : Œ± ‚Üí G} {C : ‚Ñù}\n    (h : ‚àÄ·µê x ‚àÇŒº, ‚Äñf x‚Äñ ‚â§ C) : ‚Äñ‚à´ x, f x ‚àÇŒº‚Äñ ‚â§ C * (Œº univ).toReal :=\n  calc\n    ‚Äñ‚à´ x, f x ‚àÇŒº‚Äñ ‚â§ ‚à´ _, C ‚àÇŒº := norm_integral_le_of_norm_le (integrable_const C) h\n    _ = C * (Œº univ).toReal := by rw [integral_const, smul_eq_mul, mul_comm]\n\n"}
{"name":"MeasureTheory.tendsto_integral_approxOn_of_measurable","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : NormedAddCommGroup E\nhE : CompleteSpace E\ninst‚úù¬≥ : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : MeasurableSpace E\ninst‚úù¬π : BorelSpace E\nf : Œ± ‚Üí E\ns : Set E\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üës\nhfi : MeasureTheory.Integrable f Œº\nhfm : Measurable f\nhs : Filter.Eventually (fun x => Membership.mem (closure s) (f x)) (MeasureTheory.ae Œº)\ny‚ÇÄ : E\nh‚ÇÄ : Membership.mem s y‚ÇÄ\nh‚ÇÄi : MeasureTheory.Integrable (fun x => y‚ÇÄ) Œº\n‚ä¢ Filter.Tendsto (fun n => MeasureTheory.SimpleFunc.integral Œº (MeasureTheory.SimpleFunc.approxOn f hfm s y‚ÇÄ h‚ÇÄ n)) Filter.atTop (nhds (MeasureTheory.integral Œº fun x => f x))","decl":"theorem tendsto_integral_approxOn_of_measurable [MeasurableSpace E] [BorelSpace E] {f : Œ± ‚Üí E}\n    {s : Set E} [SeparableSpace s] (hfi : Integrable f Œº) (hfm : Measurable f)\n    (hs : ‚àÄ·µê x ‚àÇŒº, f x ‚àà closure s) {y‚ÇÄ : E} (h‚ÇÄ : y‚ÇÄ ‚àà s) (h‚ÇÄi : Integrable (fun _ => y‚ÇÄ) Œº) :\n    Tendsto (fun n => (SimpleFunc.approxOn f hfm s y‚ÇÄ h‚ÇÄ n).integral Œº)\n      atTop (ùìù <| ‚à´ x, f x ‚àÇŒº) := by\n  have hfi' := SimpleFunc.integrable_approxOn hfm hfi h‚ÇÄ h‚ÇÄi\n  simp only [SimpleFunc.integral_eq_integral _ (hfi' _), integral, hE, L1.integral]\n  exact tendsto_setToFun_approxOn_of_measurable (dominatedFinMeasAdditive_weightedSMul Œº)\n    hfi hfm hs h‚ÇÄ h‚ÇÄi\n\n"}
{"name":"MeasureTheory.tendsto_integral_approxOn_of_measurable_of_range_subset","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : NormedAddCommGroup E\nhE : CompleteSpace E\ninst‚úù¬≥ : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬≤ : MeasurableSpace E\ninst‚úù¬π : BorelSpace E\nf : Œ± ‚Üí E\nfmeas : Measurable f\nhf : MeasureTheory.Integrable f Œº\ns : Set E\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üës\nhs : HasSubset.Subset (Union.union (Set.range f) (Singleton.singleton 0)) s\n‚ä¢ Filter.Tendsto (fun n => MeasureTheory.SimpleFunc.integral Œº (MeasureTheory.SimpleFunc.approxOn f fmeas s 0 ‚ãØ n)) Filter.atTop (nhds (MeasureTheory.integral Œº fun x => f x))","decl":"theorem tendsto_integral_approxOn_of_measurable_of_range_subset [MeasurableSpace E] [BorelSpace E]\n    {f : Œ± ‚Üí E} (fmeas : Measurable f) (hf : Integrable f Œº) (s : Set E) [SeparableSpace s]\n    (hs : range f ‚à™ {0} ‚äÜ s) :\n    Tendsto (fun n => (SimpleFunc.approxOn f fmeas s 0 (hs <| by simp) n).integral Œº) atTop\n      (ùìù <| ‚à´ x, f x ‚àÇŒº) := by\n  apply tendsto_integral_approxOn_of_measurable hf fmeas _ _ (integrable_zero _ _ _)\n  exact Eventually.of_forall fun x => subset_closure (hs (Set.mem_union_left _ (mem_range_self _)))\n\n-- We redeclare `E` here to temporarily avoid\n-- the `[CompleteSpace E]` and `[NormedSpace ‚Ñù E]` instances.\n"}
{"name":"MeasureTheory.tendsto_integral_norm_approxOn_sub","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nE : Type u_7\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : MeasurableSpace E\ninst‚úù¬π : BorelSpace E\nf : Œ± ‚Üí E\nfmeas : Measurable f\nhf : MeasureTheory.Integrable f Œº\ninst‚úù : TopologicalSpace.SeparableSpace ‚Üë(Union.union (Set.range f) (Singleton.singleton 0))\n‚ä¢ Filter.Tendsto (fun n => MeasureTheory.integral Œº fun x => Norm.norm (HSub.hSub ((MeasureTheory.SimpleFunc.approxOn f fmeas (Union.union (Set.range f) (Singleton.singleton 0)) 0 ‚ãØ n) x) (f x))) Filter.atTop (nhds 0)","decl":"theorem tendsto_integral_norm_approxOn_sub\n    {E : Type*} [NormedAddCommGroup E] [MeasurableSpace E] [BorelSpace E] {f : Œ± ‚Üí E}\n    (fmeas : Measurable f) (hf : Integrable f Œº) [SeparableSpace (range f ‚à™ {0} : Set E)] :\n    Tendsto (fun n ‚Ü¶ ‚à´ x, ‚ÄñSimpleFunc.approxOn f fmeas (range f ‚à™ {0}) 0 (by simp) n x - f x‚Äñ ‚àÇŒº)\n      atTop (ùìù 0) := by\n  convert (tendsto_toReal zero_ne_top).comp (tendsto_approxOn_range_L1_enorm fmeas hf) with n\n  rw [integral_norm_eq_lintegral_enorm]\n  ¬∑ simp\n  ¬∑ apply (SimpleFunc.aestronglyMeasurable _).sub\n    apply (stronglyMeasurable_iff_measurable_separable.2 ‚ü®fmeas, ?_‚ü© ).aestronglyMeasurable\n    exact .mono (.of_subtype (range f ‚à™ {0})) subset_union_left\n\n"}
{"name":"MeasureTheory.integral_add_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº ŒΩ : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí G\nhŒº : MeasureTheory.Integrable f Œº\nhŒΩ : MeasureTheory.Integrable f ŒΩ\n‚ä¢ Eq (MeasureTheory.integral (HAdd.hAdd Œº ŒΩ) fun x => f x) (HAdd.hAdd (MeasureTheory.integral Œº fun x => f x) (MeasureTheory.integral ŒΩ fun x => f x))","decl":"theorem integral_add_measure {f : Œ± ‚Üí G} (hŒº : Integrable f Œº) (hŒΩ : Integrable f ŒΩ) :\n    ‚à´ x, f x ‚àÇ(Œº + ŒΩ) = ‚à´ x, f x ‚àÇŒº + ‚à´ x, f x ‚àÇŒΩ := by\n  by_cases hG : CompleteSpace G; swap\n  ¬∑ simp [integral, hG]\n  have hfi := hŒº.add_measure hŒΩ\n  simp_rw [integral_eq_setToFun]\n  have hŒº_dfma : DominatedFinMeasAdditive (Œº + ŒΩ) (weightedSMul Œº : Set Œ± ‚Üí G ‚ÜíL[‚Ñù] G) 1 :=\n    DominatedFinMeasAdditive.add_measure_right Œº ŒΩ (dominatedFinMeasAdditive_weightedSMul Œº)\n      zero_le_one\n  have hŒΩ_dfma : DominatedFinMeasAdditive (Œº + ŒΩ) (weightedSMul ŒΩ : Set Œ± ‚Üí G ‚ÜíL[‚Ñù] G) 1 :=\n    DominatedFinMeasAdditive.add_measure_left Œº ŒΩ (dominatedFinMeasAdditive_weightedSMul ŒΩ)\n      zero_le_one\n  rw [‚Üê setToFun_congr_measure_of_add_right hŒº_dfma\n        (dominatedFinMeasAdditive_weightedSMul Œº) f hfi,\n    ‚Üê setToFun_congr_measure_of_add_left hŒΩ_dfma (dominatedFinMeasAdditive_weightedSMul ŒΩ) f hfi]\n  refine setToFun_add_left' _ _ _ (fun s _ hŒºŒΩs => ?_) f\n  rw [Measure.coe_add, Pi.add_apply, add_lt_top] at hŒºŒΩs\n  rw [weightedSMul, weightedSMul, weightedSMul, ‚Üê add_smul, Measure.coe_add, Pi.add_apply,\n  toReal_add hŒºŒΩs.1.ne hŒºŒΩs.2.ne]\n\n"}
{"name":"MeasureTheory.integral_zero_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nf : Œ± ‚Üí G\n‚ä¢ Eq (MeasureTheory.integral 0 fun x => f x) 0","decl":"@[simp]\ntheorem integral_zero_measure {m : MeasurableSpace Œ±} (f : Œ± ‚Üí G) :\n    (‚à´ x, f x ‚àÇ(0 : Measure Œ±)) = 0 := by\n  by_cases hG : CompleteSpace G\n  ¬∑ simp only [integral, hG, L1.integral]\n    exact setToFun_measure_zero (dominatedFinMeasAdditive_weightedSMul _) rfl\n  ¬∑ simp [integral, hG]\n\n"}
{"name":"MeasureTheory.setIntegral_zero_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nf : Œ± ‚Üí G\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nhs : Eq (Œº s) 0\n‚ä¢ Eq (MeasureTheory.integral (Œº.restrict s) fun x => f x) 0","decl":"@[simp]\ntheorem setIntegral_zero_measure (f : Œ± ‚Üí G) {Œº : Measure Œ±} {s : Set Œ±} (hs : Œº s = 0) :\n    ‚à´ x in s, f x ‚àÇŒº = 0 := Measure.restrict_eq_zero.mpr hs ‚ñ∏ integral_zero_measure f\n\n"}
{"name":"MeasureTheory.integral_of_isEmpty","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬≤ : NormedAddCommGroup G\ninst‚úù¬π : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : IsEmpty Œ±\nf : Œ± ‚Üí G\n‚ä¢ Eq (MeasureTheory.integral Œº fun x => f x) 0","decl":"lemma integral_of_isEmpty [IsEmpty Œ±] {f : Œ± ‚Üí G} : ‚à´ x, f x ‚àÇŒº = 0 :=\n    Œº.eq_zero_of_isEmpty ‚ñ∏ integral_zero_measure _\n\n"}
{"name":"MeasureTheory.integral_finset_sum_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nŒπ : Type u_7\nm : MeasurableSpace Œ±\nf : Œ± ‚Üí G\nŒº : Œπ ‚Üí MeasureTheory.Measure Œ±\ns : Finset Œπ\nhf : ‚àÄ (i : Œπ), Membership.mem s i ‚Üí MeasureTheory.Integrable f (Œº i)\n‚ä¢ Eq (MeasureTheory.integral (s.sum fun i => Œº i) fun a => f a) (s.sum fun i => MeasureTheory.integral (Œº i) fun a => f a)","decl":"theorem integral_finset_sum_measure {Œπ} {m : MeasurableSpace Œ±} {f : Œ± ‚Üí G} {Œº : Œπ ‚Üí Measure Œ±}\n    {s : Finset Œπ} (hf : ‚àÄ i ‚àà s, Integrable f (Œº i)) :\n    ‚à´ a, f a ‚àÇ(‚àë i ‚àà s, Œº i) = ‚àë i ‚àà s, ‚à´ a, f a ‚àÇŒº i := by\n  induction s using Finset.cons_induction_on with\n  | h‚ÇÅ => simp\n  | h‚ÇÇ h ih =>\n    rw [Finset.forall_mem_cons] at hf\n    rw [Finset.sum_cons, Finset.sum_cons, ‚Üê ih hf.2]\n    exact integral_add_measure hf.1 (integrable_finset_sum_measure.2 hf.2)\n\n"}
{"name":"MeasureTheory.nndist_integral_add_measure_le_lintegral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº ŒΩ : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí G\nh‚ÇÅ : MeasureTheory.Integrable f Œº\nh‚ÇÇ : MeasureTheory.Integrable f ŒΩ\n‚ä¢ LE.le (‚Üë(NNDist.nndist (MeasureTheory.integral Œº fun x => f x) (MeasureTheory.integral (HAdd.hAdd Œº ŒΩ) fun x => f x))) (MeasureTheory.lintegral ŒΩ fun x => ENorm.enorm (f x))","decl":"theorem nndist_integral_add_measure_le_lintegral\n    {f : Œ± ‚Üí G} (h‚ÇÅ : Integrable f Œº) (h‚ÇÇ : Integrable f ŒΩ) :\n    (nndist (‚à´ x, f x ‚àÇŒº) (‚à´ x, f x ‚àÇ(Œº + ŒΩ)) : ‚Ñù‚â•0‚àû) ‚â§ ‚à´‚Åª x, ‚Äñf x‚Äñ‚Çë ‚àÇŒΩ := by\n  rw [integral_add_measure h‚ÇÅ h‚ÇÇ, nndist_comm, nndist_eq_nnnorm, add_sub_cancel_left]\n  exact enorm_integral_le_lintegral_enorm _\n\n"}
{"name":"MeasureTheory.hasSum_integral_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nŒπ : Type u_7\nm : MeasurableSpace Œ±\nf : Œ± ‚Üí G\nŒº : Œπ ‚Üí MeasureTheory.Measure Œ±\nhf : MeasureTheory.Integrable f (MeasureTheory.Measure.sum Œº)\n‚ä¢ HasSum (fun i => MeasureTheory.integral (Œº i) fun a => f a) (MeasureTheory.integral (MeasureTheory.Measure.sum Œº) fun a => f a)","decl":"theorem hasSum_integral_measure {Œπ} {m : MeasurableSpace Œ±} {f : Œ± ‚Üí G} {Œº : Œπ ‚Üí Measure Œ±}\n    (hf : Integrable f (Measure.sum Œº)) :\n    HasSum (fun i => ‚à´ a, f a ‚àÇŒº i) (‚à´ a, f a ‚àÇMeasure.sum Œº) := by\n  have hfi : ‚àÄ i, Integrable f (Œº i) := fun i => hf.mono_measure (Measure.le_sum _ _)\n  simp only [HasSum, ‚Üê integral_finset_sum_measure fun i _ => hfi i]\n  refine Metric.nhds_basis_ball.tendsto_right_iff.mpr fun Œµ Œµ0 => ?_\n  lift Œµ to ‚Ñù‚â•0 using Œµ0.le\n  have hf_lt : (‚à´‚Åª x, ‚Äñf x‚Äñ‚Çë ‚àÇMeasure.sum Œº) < ‚àû := hf.2\n  have hmem : ‚àÄ·∂† y in ùìù (‚à´‚Åª x, ‚Äñf x‚Äñ‚Çë ‚àÇMeasure.sum Œº), (‚à´‚Åª x, ‚Äñf x‚Äñ‚Çë ‚àÇMeasure.sum Œº) < y + Œµ := by\n    refine tendsto_id.add tendsto_const_nhds (lt_mem_nhds (Œ± := ‚Ñù‚â•0‚àû) <| ENNReal.lt_add_right ?_ ?_)\n    exacts [hf_lt.ne, ENNReal.coe_ne_zero.2 (NNReal.coe_ne_zero.1 Œµ0.ne')]\n  refine ((hasSum_lintegral_measure (fun x => ‚Äñf x‚Äñ‚Çë) Œº).eventually hmem).mono fun s hs => ?_\n  obtain ‚ü®ŒΩ, hŒΩ‚ü© : ‚àÉ ŒΩ, (‚àë i ‚àà s, Œº i) + ŒΩ = Measure.sum Œº := by\n    refine ‚ü®Measure.sum fun i : ‚Ü•(s·∂ú : Set Œπ) => Œº i, ?_‚ü©\n    simpa only [‚Üê Measure.sum_coe_finset] using Measure.sum_add_sum_compl (s : Set Œπ) Œº\n  rw [Metric.mem_ball, ‚Üê coe_nndist, NNReal.coe_lt_coe, ‚Üê ENNReal.coe_lt_coe, ‚Üê hŒΩ]\n  rw [‚Üê hŒΩ, integrable_add_measure] at hf\n  refine (nndist_integral_add_measure_le_lintegral hf.1 hf.2).trans_lt ?_\n  rw [‚Üê hŒΩ, lintegral_add_measure, lintegral_finset_sum_measure] at hs\n  exact lt_of_add_lt_add_left hs\n\n"}
{"name":"MeasureTheory.integral_sum_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nŒπ : Type u_7\nx‚úù : MeasurableSpace Œ±\nf : Œ± ‚Üí G\nŒº : Œπ ‚Üí MeasureTheory.Measure Œ±\nhf : MeasureTheory.Integrable f (MeasureTheory.Measure.sum Œº)\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.Measure.sum Œº) fun a => f a) (tsum fun i => MeasureTheory.integral (Œº i) fun a => f a)","decl":"theorem integral_sum_measure {Œπ} {_ : MeasurableSpace Œ±} {f : Œ± ‚Üí G} {Œº : Œπ ‚Üí Measure Œ±}\n    (hf : Integrable f (Measure.sum Œº)) : ‚à´ a, f a ‚àÇMeasure.sum Œº = ‚àë' i, ‚à´ a, f a ‚àÇŒº i :=\n  (hasSum_integral_measure hf).tsum_eq.symm\n\n"}
{"name":"MeasureTheory.integral_smul_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí G\nc : ENNReal\n‚ä¢ Eq (MeasureTheory.integral (HSMul.hSMul c Œº) fun x => f x) (HSMul.hSMul c.toReal (MeasureTheory.integral Œº fun x => f x))","decl":"@[simp]\ntheorem integral_smul_measure (f : Œ± ‚Üí G) (c : ‚Ñù‚â•0‚àû) :\n    ‚à´ x, f x ‚àÇc ‚Ä¢ Œº = c.toReal ‚Ä¢ ‚à´ x, f x ‚àÇŒº := by\n  by_cases hG : CompleteSpace G; swap\n  ¬∑ simp [integral, hG]\n  -- First we consider the ‚Äúdegenerate‚Äù case `c = ‚àû`\n  rcases eq_or_ne c ‚àû with (rfl | hc)\n  ¬∑ rw [ENNReal.top_toReal, zero_smul, integral_eq_setToFun, setToFun_top_smul_measure]\n  -- Main case: `c ‚â† ‚àû`\n  simp_rw [integral_eq_setToFun, ‚Üê setToFun_smul_left]\n  have hdfma : DominatedFinMeasAdditive Œº (weightedSMul (c ‚Ä¢ Œº) : Set Œ± ‚Üí G ‚ÜíL[‚Ñù] G) c.toReal :=\n    mul_one c.toReal ‚ñ∏ (dominatedFinMeasAdditive_weightedSMul (c ‚Ä¢ Œº)).of_smul_measure c hc\n  have hdfma_smul := dominatedFinMeasAdditive_weightedSMul (F := G) (c ‚Ä¢ Œº)\n  rw [‚Üê setToFun_congr_smul_measure c hc hdfma hdfma_smul f]\n  exact setToFun_congr_left' _ _ (fun s _ _ => weightedSMul_smul_measure Œº c) f\n\n"}
{"name":"MeasureTheory.integral_smul_nnreal_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí G\nc : NNReal\n‚ä¢ Eq (MeasureTheory.integral (HSMul.hSMul c Œº) fun x => f x) (HSMul.hSMul c (MeasureTheory.integral Œº fun x => f x))","decl":"@[simp]\ntheorem integral_smul_nnreal_measure (f : Œ± ‚Üí G) (c : ‚Ñù‚â•0) :\n    ‚à´ x, f x ‚àÇ(c ‚Ä¢ Œº) = c ‚Ä¢ ‚à´ x, f x ‚àÇŒº :=\n  integral_smul_measure f (c : ‚Ñù‚â•0‚àû)\n\n"}
{"name":"MeasureTheory.integral_map_of_stronglyMeasurable","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬≤ : NormedAddCommGroup G\ninst‚úù¬π : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_7\ninst‚úù : MeasurableSpace Œ≤\nœÜ : Œ± ‚Üí Œ≤\nhœÜ : Measurable œÜ\nf : Œ≤ ‚Üí G\nhfm : MeasureTheory.StronglyMeasurable f\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.Measure.map œÜ Œº) fun y => f y) (MeasureTheory.integral Œº fun x => f (œÜ x))","decl":"theorem integral_map_of_stronglyMeasurable {Œ≤} [MeasurableSpace Œ≤] {œÜ : Œ± ‚Üí Œ≤} (hœÜ : Measurable œÜ)\n    {f : Œ≤ ‚Üí G} (hfm : StronglyMeasurable f) : ‚à´ y, f y ‚àÇMeasure.map œÜ Œº = ‚à´ x, f (œÜ x) ‚àÇŒº := by\n  by_cases hG : CompleteSpace G; swap\n  ¬∑ simp [integral, hG]\n  by_cases hfi : Integrable f (Measure.map œÜ Œº); swap\n  ¬∑ rw [integral_undef hfi, integral_undef]\n    exact fun hfœÜ => hfi ((integrable_map_measure hfm.aestronglyMeasurable hœÜ.aemeasurable).2 hfœÜ)\n  borelize G\n  have : SeparableSpace (range f ‚à™ {0} : Set G) := hfm.separableSpace_range_union_singleton\n  refine tendsto_nhds_unique\n    (tendsto_integral_approxOn_of_measurable_of_range_subset hfm.measurable hfi _ Subset.rfl) ?_\n  convert tendsto_integral_approxOn_of_measurable_of_range_subset (hfm.measurable.comp hœÜ)\n    ((integrable_map_measure hfm.aestronglyMeasurable hœÜ.aemeasurable).1 hfi) (range f ‚à™ {0})\n    (by simp [insert_subset_insert, Set.range_comp_subset_range]) using 1\n  ext1 i\n  simp only [SimpleFunc.approxOn_comp, SimpleFunc.integral_eq, Measure.map_apply, hœÜ,\n    SimpleFunc.measurableSet_preimage, ‚Üê preimage_comp, SimpleFunc.coe_comp]\n  refine (Finset.sum_subset (SimpleFunc.range_comp_subset_range _ hœÜ) fun y _ hy => ?_).symm\n  rw [SimpleFunc.mem_range, ‚Üê Set.preimage_singleton_eq_empty, SimpleFunc.coe_comp] at hy\n  rw [hy]\n  simp\n\n"}
{"name":"MeasureTheory.integral_map","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬≤ : NormedAddCommGroup G\ninst‚úù¬π : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_7\ninst‚úù : MeasurableSpace Œ≤\nœÜ : Œ± ‚Üí Œ≤\nhœÜ : AEMeasurable œÜ Œº\nf : Œ≤ ‚Üí G\nhfm : MeasureTheory.AEStronglyMeasurable f (MeasureTheory.Measure.map œÜ Œº)\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.Measure.map œÜ Œº) fun y => f y) (MeasureTheory.integral Œº fun x => f (œÜ x))","decl":"theorem integral_map {Œ≤} [MeasurableSpace Œ≤] {œÜ : Œ± ‚Üí Œ≤} (hœÜ : AEMeasurable œÜ Œº) {f : Œ≤ ‚Üí G}\n    (hfm : AEStronglyMeasurable f (Measure.map œÜ Œº)) :\n    ‚à´ y, f y ‚àÇMeasure.map œÜ Œº = ‚à´ x, f (œÜ x) ‚àÇŒº :=\n  let g := hfm.mk f\n  calc\n    ‚à´ y, f y ‚àÇMeasure.map œÜ Œº = ‚à´ y, g y ‚àÇMeasure.map œÜ Œº := integral_congr_ae hfm.ae_eq_mk\n    _ = ‚à´ y, g y ‚àÇMeasure.map (hœÜ.mk œÜ) Œº := by congr 1; exact Measure.map_congr hœÜ.ae_eq_mk\n    _ = ‚à´ x, g (hœÜ.mk œÜ x) ‚àÇŒº :=\n      (integral_map_of_stronglyMeasurable hœÜ.measurable_mk hfm.stronglyMeasurable_mk)\n    _ = ‚à´ x, g (œÜ x) ‚àÇŒº := integral_congr_ae (hœÜ.ae_eq_mk.symm.fun_comp _)\n    _ = ‚à´ x, f (œÜ x) ‚àÇŒº := integral_congr_ae <| ae_eq_comp hœÜ hfm.ae_eq_mk.symm\n\n"}
{"name":"MeasurableEmbedding.integral_map","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_7\nx‚úù : MeasurableSpace Œ≤\nf : Œ± ‚Üí Œ≤\nhf : MeasurableEmbedding f\ng : Œ≤ ‚Üí G\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.Measure.map f Œº) fun y => g y) (MeasureTheory.integral Œº fun x => g (f x))","decl":"theorem _root_.MeasurableEmbedding.integral_map {Œ≤} {_ : MeasurableSpace Œ≤} {f : Œ± ‚Üí Œ≤}\n    (hf : MeasurableEmbedding f) (g : Œ≤ ‚Üí G) : ‚à´ y, g y ‚àÇMeasure.map f Œº = ‚à´ x, g (f x) ‚àÇŒº := by\n  by_cases hgm : AEStronglyMeasurable g (Measure.map f Œº)\n  ¬∑ exact MeasureTheory.integral_map hf.measurable.aemeasurable hgm\n  ¬∑ rw [integral_non_aestronglyMeasurable hgm, integral_non_aestronglyMeasurable]\n    exact fun hgf => hgm (hf.aestronglyMeasurable_map_iff.2 hgf)\n\n"}
{"name":"Topology.IsClosedEmbedding.integral_map","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup G\ninst‚úù‚Åµ : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_7\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : BorelSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : MeasurableSpace Œ≤\ninst‚úù : BorelSpace Œ≤\nœÜ : Œ± ‚Üí Œ≤\nhœÜ : Topology.IsClosedEmbedding œÜ\nf : Œ≤ ‚Üí G\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.Measure.map œÜ Œº) fun y => f y) (MeasureTheory.integral Œº fun x => f (œÜ x))","decl":"theorem _root_.Topology.IsClosedEmbedding.integral_map {Œ≤} [TopologicalSpace Œ±] [BorelSpace Œ±]\n    [TopologicalSpace Œ≤] [MeasurableSpace Œ≤] [BorelSpace Œ≤] {œÜ : Œ± ‚Üí Œ≤} (hœÜ : IsClosedEmbedding œÜ)\n    (f : Œ≤ ‚Üí G) : ‚à´ y, f y ‚àÇMeasure.map œÜ Œº = ‚à´ x, f (œÜ x) ‚àÇŒº :=\n  hœÜ.measurableEmbedding.integral_map _\n\n"}
{"name":"ClosedEmbedding.integral_map","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù‚Å∂ : NormedAddCommGroup G\ninst‚úù‚Åµ : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_7\ninst‚úù‚Å¥ : TopologicalSpace Œ±\ninst‚úù¬≥ : BorelSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : MeasurableSpace Œ≤\ninst‚úù : BorelSpace Œ≤\nœÜ : Œ± ‚Üí Œ≤\nhœÜ : Topology.IsClosedEmbedding œÜ\nf : Œ≤ ‚Üí G\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.Measure.map œÜ Œº) fun y => f y) (MeasureTheory.integral Œº fun x => f (œÜ x))","decl":"@[deprecated (since := \"2024-10-20\")]\nalias _root_.ClosedEmbedding.integral_map := IsClosedEmbedding.integral_map\n\n"}
{"name":"MeasureTheory.integral_map_equiv","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬≤ : NormedAddCommGroup G\ninst‚úù¬π : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_7\ninst‚úù : MeasurableSpace Œ≤\ne : MeasurableEquiv Œ± Œ≤\nf : Œ≤ ‚Üí G\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.Measure.map (‚áëe) Œº) fun y => f y) (MeasureTheory.integral Œº fun x => f (e x))","decl":"theorem integral_map_equiv {Œ≤} [MeasurableSpace Œ≤] (e : Œ± ‚âÉ·µê Œ≤) (f : Œ≤ ‚Üí G) :\n    ‚à´ y, f y ‚àÇMeasure.map e Œº = ‚à´ x, f (e x) ‚àÇŒº :=\n  e.measurableEmbedding.integral_map f\n\n"}
{"name":"MeasureTheory.MeasurePreserving.integral_comp","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_7\nx‚úù : MeasurableSpace Œ≤\nf : Œ± ‚Üí Œ≤\nŒΩ : MeasureTheory.Measure Œ≤\nh‚ÇÅ : MeasureTheory.MeasurePreserving f Œº ŒΩ\nh‚ÇÇ : MeasurableEmbedding f\ng : Œ≤ ‚Üí G\n‚ä¢ Eq (MeasureTheory.integral Œº fun x => g (f x)) (MeasureTheory.integral ŒΩ fun y => g y)","decl":"theorem MeasurePreserving.integral_comp {Œ≤} {_ : MeasurableSpace Œ≤} {f : Œ± ‚Üí Œ≤} {ŒΩ}\n    (h‚ÇÅ : MeasurePreserving f Œº ŒΩ) (h‚ÇÇ : MeasurableEmbedding f) (g : Œ≤ ‚Üí G) :\n    ‚à´ x, g (f x) ‚àÇŒº = ‚à´ y, g y ‚àÇŒΩ :=\n  h‚ÇÅ.map_eq ‚ñ∏ (h‚ÇÇ.integral_map g).symm\n\n"}
{"name":"MeasureTheory.MeasurePreserving.integral_comp'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nG : Type u_5\ninst‚úù¬≤ : NormedAddCommGroup G\ninst‚úù¬π : NormedSpace Real G\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nŒ≤ : Type u_7\ninst‚úù : MeasurableSpace Œ≤\nŒΩ : MeasureTheory.Measure Œ≤\nf : MeasurableEquiv Œ± Œ≤\nh : MeasureTheory.MeasurePreserving (‚áëf) Œº ŒΩ\ng : Œ≤ ‚Üí G\n‚ä¢ Eq (MeasureTheory.integral Œº fun x => g (f x)) (MeasureTheory.integral ŒΩ fun y => g y)","decl":"theorem MeasurePreserving.integral_comp' {Œ≤} [MeasurableSpace Œ≤] {ŒΩ} {f : Œ± ‚âÉ·µê Œ≤}\n    (h : MeasurePreserving f Œº ŒΩ) (g : Œ≤ ‚Üí G) :\n    ‚à´ x, g (f x) ‚àÇŒº = ‚à´ y, g y ‚àÇŒΩ := MeasurePreserving.integral_comp h f.measurableEmbedding _\n\n"}
{"name":"MeasureTheory.integral_subtype_comap","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"G : Type u_5\ninst‚úù¬≤ : NormedAddCommGroup G\ninst‚úù¬π : NormedSpace Real G\nŒ± : Type u_7\ninst‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ns : Set Œ±\nhs : MeasurableSet s\nf : Œ± ‚Üí G\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.Measure.comap Subtype.val Œº) fun x => f ‚Üëx) (MeasureTheory.integral (Œº.restrict s) fun x => f x)","decl":"theorem integral_subtype_comap {Œ±} [MeasurableSpace Œ±] {Œº : Measure Œ±} {s : Set Œ±}\n    (hs : MeasurableSet s) (f : Œ± ‚Üí G) :\n    ‚à´ x : s, f (x : Œ±) ‚àÇ(Measure.comap Subtype.val Œº) = ‚à´ x in s, f x ‚àÇŒº := by\n  rw [‚Üê map_comap_subtype_coe hs]\n  exact ((MeasurableEmbedding.subtype_coe hs).integral_map _).symm\n\n"}
{"name":"MeasureTheory.integral_subtype","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"G : Type u_5\ninst‚úù¬≤ : NormedAddCommGroup G\ninst‚úù¬π : NormedSpace Real G\nŒ± : Type u_7\ninst‚úù : MeasureTheory.MeasureSpace Œ±\ns : Set Œ±\nhs : MeasurableSet s\nf : Œ± ‚Üí G\n‚ä¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => f ‚Üëx) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict s) fun x => f x)","decl":"attribute [local instance] Measure.Subtype.measureSpace in\ntheorem integral_subtype {Œ±} [MeasureSpace Œ±] {s : Set Œ±} (hs : MeasurableSet s) (f : Œ± ‚Üí G) :\n    ‚à´ x : s, f x = ‚à´ x in s, f x := integral_subtype_comap hs f\n\n"}
{"name":"MeasureTheory.integral_dirac'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nhE : CompleteSpace E\ninst‚úù¬π : NormedSpace Real E\ninst‚úù : MeasurableSpace Œ±\nf : Œ± ‚Üí E\na : Œ±\nhfm : MeasureTheory.StronglyMeasurable f\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.Measure.dirac a) fun x => f x) (f a)","decl":"@[simp]\ntheorem integral_dirac' [MeasurableSpace Œ±] (f : Œ± ‚Üí E) (a : Œ±) (hfm : StronglyMeasurable f) :\n    ‚à´ x, f x ‚àÇMeasure.dirac a = f a := by\n  borelize E\n  calc\n    ‚à´ x, f x ‚àÇMeasure.dirac a = ‚à´ _, f a ‚àÇMeasure.dirac a :=\n      integral_congr_ae <| ae_eq_dirac' hfm.measurable\n    _ = f a := by simp [Measure.dirac_apply_of_mem]\n\n"}
{"name":"MeasureTheory.integral_dirac","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\nhE : CompleteSpace E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : MeasurableSpace Œ±\ninst‚úù : MeasurableSingletonClass Œ±\nf : Œ± ‚Üí E\na : Œ±\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.Measure.dirac a) fun x => f x) (f a)","decl":"@[simp]\ntheorem integral_dirac [MeasurableSpace Œ±] [MeasurableSingletonClass Œ±] (f : Œ± ‚Üí E) (a : Œ±) :\n    ‚à´ x, f x ‚àÇMeasure.dirac a = f a :=\n  calc\n    ‚à´ x, f x ‚àÇMeasure.dirac a = ‚à´ _, f a ‚àÇMeasure.dirac a := integral_congr_ae <| ae_eq_dirac f\n    _ = f a := by simp [Measure.dirac_apply_of_mem]\n\n"}
{"name":"MeasureTheory.setIntegral_dirac'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nhE : CompleteSpace E\ninst‚úù¬π : NormedSpace Real E\nmŒ± : MeasurableSpace Œ±\nf : Œ± ‚Üí E\nhf : MeasureTheory.StronglyMeasurable f\na : Œ±\ns : Set Œ±\nhs : MeasurableSet s\ninst‚úù : Decidable (Membership.mem s a)\n‚ä¢ Eq (MeasureTheory.integral ((MeasureTheory.Measure.dirac a).restrict s) fun x => f x) (ite (Membership.mem s a) (f a) 0)","decl":"theorem setIntegral_dirac' {mŒ± : MeasurableSpace Œ±} {f : Œ± ‚Üí E} (hf : StronglyMeasurable f) (a : Œ±)\n    {s : Set Œ±} (hs : MeasurableSet s) [Decidable (a ‚àà s)] :\n    ‚à´ x in s, f x ‚àÇMeasure.dirac a = if a ‚àà s then f a else 0 := by\n  rw [restrict_dirac' hs]\n  split_ifs\n  ¬∑ exact integral_dirac' _ _ hf\n  ¬∑ exact integral_zero_measure _\n\n"}
{"name":"MeasureTheory.setIntegral_dirac","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù‚Å¥ : NormedAddCommGroup E\nhE : CompleteSpace E\ninst‚úù¬≥ : NormedSpace Real E\ninst‚úù¬≤ : MeasurableSpace Œ±\ninst‚úù¬π : MeasurableSingletonClass Œ±\nf : Œ± ‚Üí E\na : Œ±\ns : Set Œ±\ninst‚úù : Decidable (Membership.mem s a)\n‚ä¢ Eq (MeasureTheory.integral ((MeasureTheory.Measure.dirac a).restrict s) fun x => f x) (ite (Membership.mem s a) (f a) 0)","decl":"theorem setIntegral_dirac [MeasurableSpace Œ±] [MeasurableSingletonClass Œ±] (f : Œ± ‚Üí E) (a : Œ±)\n    (s : Set Œ±) [Decidable (a ‚àà s)] :\n    ‚à´ x in s, f x ‚àÇMeasure.dirac a = if a ‚àà s then f a else 0 := by\n  rw [restrict_dirac]\n  split_ifs\n  ¬∑ exact integral_dirac _ _\n  ¬∑ exact integral_zero_measure _\n\n"}
{"name":"MeasureTheory.mul_meas_ge_le_integral_of_nonneg","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Real\nhf_nonneg : (MeasureTheory.ae Œº).EventuallyLE 0 f\nhf_int : MeasureTheory.Integrable f Œº\nŒµ : Real\n‚ä¢ LE.le (HMul.hMul Œµ (Œº (setOf fun x => LE.le Œµ (f x))).toReal) (MeasureTheory.integral Œº fun x => f x)","decl":"/-- **Markov's inequality** also known as **Chebyshev's first inequality**. -/\ntheorem mul_meas_ge_le_integral_of_nonneg {f : Œ± ‚Üí ‚Ñù} (hf_nonneg : 0 ‚â§·µê[Œº] f)\n    (hf_int : Integrable f Œº) (Œµ : ‚Ñù) : Œµ * (Œº { x | Œµ ‚â§ f x }).toReal ‚â§ ‚à´ x, f x ‚àÇŒº := by\n  cases' eq_top_or_lt_top (Œº {x | Œµ ‚â§ f x}) with hŒº hŒº\n  ¬∑ simpa [hŒº] using integral_nonneg_of_ae hf_nonneg\n  ¬∑ have := Fact.mk hŒº\n    calc\n      Œµ * (Œº { x | Œµ ‚â§ f x }).toReal = ‚à´ _ in {x | Œµ ‚â§ f x}, Œµ ‚àÇŒº := by simp [mul_comm]\n      _ ‚â§ ‚à´ x in {x | Œµ ‚â§ f x}, f x ‚àÇŒº :=\n        integral_mono_ae (integrable_const _) (hf_int.mono_measure Œº.restrict_le_self) <|\n          ae_restrict_mem‚ÇÄ <| hf_int.aemeasurable.nullMeasurable measurableSet_Ici\n      _ ‚â§ _ := integral_mono_measure Œº.restrict_le_self hf_nonneg hf_int\n\n"}
{"name":"MeasureTheory.integral_mul_norm_le_Lp_mul_Lq","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nE : Type u_7\ninst‚úù : NormedAddCommGroup E\nf g : Œ± ‚Üí E\np q : Real\nhpq : p.IsConjExponent q\nhf : MeasureTheory.Mem‚Ñíp f (ENNReal.ofReal p) Œº\nhg : MeasureTheory.Mem‚Ñíp g (ENNReal.ofReal q) Œº\n‚ä¢ LE.le (MeasureTheory.integral Œº fun a => HMul.hMul (Norm.norm (f a)) (Norm.norm (g a))) (HMul.hMul (HPow.hPow (MeasureTheory.integral Œº fun a => HPow.hPow (Norm.norm (f a)) p) (HDiv.hDiv 1 p)) (HPow.hPow (MeasureTheory.integral Œº fun a => HPow.hPow (Norm.norm (g a)) q) (HDiv.hDiv 1 q)))","decl":"/-- H√∂lder's inequality for the integral of a product of norms. The integral of the product of two\nnorms of functions is bounded by the product of their `‚Ñíp` and `‚Ñíq` seminorms when `p` and `q` are\nconjugate exponents. -/\ntheorem integral_mul_norm_le_Lp_mul_Lq {E} [NormedAddCommGroup E] {f g : Œ± ‚Üí E} {p q : ‚Ñù}\n    (hpq : p.IsConjExponent q) (hf : Mem‚Ñíp f (ENNReal.ofReal p) Œº)\n    (hg : Mem‚Ñíp g (ENNReal.ofReal q) Œº) :\n    ‚à´ a, ‚Äñf a‚Äñ * ‚Äñg a‚Äñ ‚àÇŒº ‚â§ (‚à´ a, ‚Äñf a‚Äñ ^ p ‚àÇŒº) ^ (1 / p) * (‚à´ a, ‚Äñg a‚Äñ ^ q ‚àÇŒº) ^ (1 / q) := by\n  -- translate the Bochner integrals into Lebesgue integrals.\n  rw [integral_eq_lintegral_of_nonneg_ae, integral_eq_lintegral_of_nonneg_ae,\n    integral_eq_lintegral_of_nonneg_ae]\n  rotate_left\n  ¬∑ exact Eventually.of_forall fun x => Real.rpow_nonneg (norm_nonneg _) _\n  ¬∑ exact (hg.1.norm.aemeasurable.pow aemeasurable_const).aestronglyMeasurable\n  ¬∑ exact Eventually.of_forall fun x => Real.rpow_nonneg (norm_nonneg _) _\n  ¬∑ exact (hf.1.norm.aemeasurable.pow aemeasurable_const).aestronglyMeasurable\n  ¬∑ exact Eventually.of_forall fun x => mul_nonneg (norm_nonneg _) (norm_nonneg _)\n  ¬∑ exact hf.1.norm.mul hg.1.norm\n  rw [ENNReal.toReal_rpow, ENNReal.toReal_rpow, ‚Üê ENNReal.toReal_mul]\n  -- replace norms by nnnorm\n  have h_left : ‚à´‚Åª a, ENNReal.ofReal (‚Äñf a‚Äñ * ‚Äñg a‚Äñ) ‚àÇŒº =\n      ‚à´‚Åª a, ((‚Äñf ¬∑‚Äñ‚Çë) * (‚Äñg ¬∑‚Äñ‚Çë)) a ‚àÇŒº := by\n    simp_rw [Pi.mul_apply, ‚Üê ofReal_norm_eq_enorm, ENNReal.ofReal_mul (norm_nonneg _)]\n  have h_right_f : ‚à´‚Åª a, .ofReal (‚Äñf a‚Äñ ^ p) ‚àÇŒº = ‚à´‚Åª a, ‚Äñf a‚Äñ‚Çë ^ p ‚àÇŒº := by\n    refine lintegral_congr fun x => ?_\n    rw [‚Üê ofReal_norm_eq_enorm, ENNReal.ofReal_rpow_of_nonneg (norm_nonneg _) hpq.nonneg]\n  have h_right_g : ‚à´‚Åª a, .ofReal (‚Äñg a‚Äñ ^ q) ‚àÇŒº = ‚à´‚Åª a, ‚Äñg a‚Äñ‚Çë ^ q ‚àÇŒº := by\n    refine lintegral_congr fun x => ?_\n    rw [‚Üê ofReal_norm_eq_enorm, ENNReal.ofReal_rpow_of_nonneg (norm_nonneg _) hpq.symm.nonneg]\n  rw [h_left, h_right_f, h_right_g]\n  -- we can now apply `ENNReal.lintegral_mul_le_Lp_mul_Lq` (up to the `toReal` application)\n  refine ENNReal.toReal_mono ?_ ?_\n  ¬∑ refine ENNReal.mul_ne_top ?_ ?_\n    ¬∑ convert hf.eLpNorm_ne_top\n      rw [eLpNorm_eq_lintegral_rpow_enorm]\n      ¬∑ rw [ENNReal.toReal_ofReal hpq.nonneg]\n      ¬∑ rw [Ne, ENNReal.ofReal_eq_zero, not_le]\n        exact hpq.pos\n      ¬∑ exact ENNReal.coe_ne_top\n    ¬∑ convert hg.eLpNorm_ne_top\n      rw [eLpNorm_eq_lintegral_rpow_enorm]\n      ¬∑ rw [ENNReal.toReal_ofReal hpq.symm.nonneg]\n      ¬∑ rw [Ne, ENNReal.ofReal_eq_zero, not_le]\n        exact hpq.symm.pos\n      ¬∑ exact ENNReal.coe_ne_top\n  ¬∑ exact ENNReal.lintegral_mul_le_Lp_mul_Lq Œº hpq hf.1.nnnorm.aemeasurable.coe_nnreal_ennreal\n      hg.1.nnnorm.aemeasurable.coe_nnreal_ennreal\n\n"}
{"name":"MeasureTheory.integral_mul_le_Lp_mul_Lq_of_nonneg","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\np q : Real\nhpq : p.IsConjExponent q\nf g : Œ± ‚Üí Real\nhf_nonneg : (MeasureTheory.ae Œº).EventuallyLE 0 f\nhg_nonneg : (MeasureTheory.ae Œº).EventuallyLE 0 g\nhf : MeasureTheory.Mem‚Ñíp f (ENNReal.ofReal p) Œº\nhg : MeasureTheory.Mem‚Ñíp g (ENNReal.ofReal q) Œº\n‚ä¢ LE.le (MeasureTheory.integral Œº fun a => HMul.hMul (f a) (g a)) (HMul.hMul (HPow.hPow (MeasureTheory.integral Œº fun a => HPow.hPow (f a) p) (HDiv.hDiv 1 p)) (HPow.hPow (MeasureTheory.integral Œº fun a => HPow.hPow (g a) q) (HDiv.hDiv 1 q)))","decl":"/-- H√∂lder's inequality for functions `Œ± ‚Üí ‚Ñù`. The integral of the product of two nonnegative\nfunctions is bounded by the product of their `‚Ñíp` and `‚Ñíq` seminorms when `p` and `q` are conjugate\nexponents. -/\ntheorem integral_mul_le_Lp_mul_Lq_of_nonneg {p q : ‚Ñù} (hpq : p.IsConjExponent q) {f g : Œ± ‚Üí ‚Ñù}\n    (hf_nonneg : 0 ‚â§·µê[Œº] f) (hg_nonneg : 0 ‚â§·µê[Œº] g) (hf : Mem‚Ñíp f (ENNReal.ofReal p) Œº)\n    (hg : Mem‚Ñíp g (ENNReal.ofReal q) Œº) :\n    ‚à´ a, f a * g a ‚àÇŒº ‚â§ (‚à´ a, f a ^ p ‚àÇŒº) ^ (1 / p) * (‚à´ a, g a ^ q ‚àÇŒº) ^ (1 / q) := by\n  have h_left : ‚à´ a, f a * g a ‚àÇŒº = ‚à´ a, ‚Äñf a‚Äñ * ‚Äñg a‚Äñ ‚àÇŒº := by\n    refine integral_congr_ae ?_\n    filter_upwards [hf_nonneg, hg_nonneg] with x hxf hxg\n    rw [Real.norm_of_nonneg hxf, Real.norm_of_nonneg hxg]\n  have h_right_f : ‚à´ a, f a ^ p ‚àÇŒº = ‚à´ a, ‚Äñf a‚Äñ ^ p ‚àÇŒº := by\n    refine integral_congr_ae ?_\n    filter_upwards [hf_nonneg] with x hxf\n    rw [Real.norm_of_nonneg hxf]\n  have h_right_g : ‚à´ a, g a ^ q ‚àÇŒº = ‚à´ a, ‚Äñg a‚Äñ ^ q ‚àÇŒº := by\n    refine integral_congr_ae ?_\n    filter_upwards [hg_nonneg] with x hxg\n    rw [Real.norm_of_nonneg hxg]\n  rw [h_left, h_right_f, h_right_g]\n  exact integral_mul_norm_le_Lp_mul_Lq hpq hf hg\n\n"}
{"name":"MeasureTheory.integral_countable'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\nhE : CompleteSpace E\ninst‚úù¬≤ : NormedSpace Real E\nm : MeasurableSpace Œ±\ninst‚úù¬π : Countable Œ±\ninst‚úù : MeasurableSingletonClass Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí E\nhf : MeasureTheory.Integrable f Œº\n‚ä¢ Eq (MeasureTheory.integral Œº fun a => f a) (tsum fun a => HSMul.hSMul (Œº (Singleton.singleton a)).toReal (f a))","decl":"theorem integral_countable' [Countable Œ±] [MeasurableSingletonClass Œ±] {Œº : Measure Œ±}\n    {f : Œ± ‚Üí E} (hf : Integrable f Œº) :\n    ‚à´ a, f a ‚àÇŒº = ‚àë' a, (Œº {a}).toReal ‚Ä¢ f a := by\n  rw [‚Üê Measure.sum_smul_dirac Œº] at hf\n  rw [‚Üê Measure.sum_smul_dirac Œº, integral_sum_measure hf]\n  congr 1 with a : 1\n  rw [integral_smul_measure, integral_dirac, Measure.sum_smul_dirac]\n\n"}
{"name":"MeasureTheory.integral_singleton'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\nhE : CompleteSpace E\ninst‚úù : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí E\nhf : MeasureTheory.StronglyMeasurable f\na : Œ±\n‚ä¢ Eq (MeasureTheory.integral (Œº.restrict (Singleton.singleton a)) fun a => f a) (HSMul.hSMul (Œº (Singleton.singleton a)).toReal (f a))","decl":"theorem integral_singleton' {Œº : Measure Œ±} {f : Œ± ‚Üí E} (hf : StronglyMeasurable f) (a : Œ±) :\n    ‚à´ a in {a}, f a ‚àÇŒº = (Œº {a}).toReal ‚Ä¢ f a := by\n  simp only [Measure.restrict_singleton, integral_smul_measure, integral_dirac' f a hf, smul_eq_mul,\n    mul_comm]\n\n"}
{"name":"MeasureTheory.integral_singleton","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nhE : CompleteSpace E\ninst‚úù¬π : NormedSpace Real E\nm : MeasurableSpace Œ±\ninst‚úù : MeasurableSingletonClass Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí E\na : Œ±\n‚ä¢ Eq (MeasureTheory.integral (Œº.restrict (Singleton.singleton a)) fun a => f a) (HSMul.hSMul (Œº (Singleton.singleton a)).toReal (f a))","decl":"theorem integral_singleton [MeasurableSingletonClass Œ±] {Œº : Measure Œ±} (f : Œ± ‚Üí E) (a : Œ±) :\n    ‚à´ a in {a}, f a ‚àÇŒº = (Œº {a}).toReal ‚Ä¢ f a := by\n  simp only [Measure.restrict_singleton, integral_smul_measure, integral_dirac, smul_eq_mul,\n    mul_comm]\n\n"}
{"name":"MeasureTheory.integral_countable","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nhE : CompleteSpace E\ninst‚úù¬π : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasurableSingletonClass Œ±\nf : Œ± ‚Üí E\ns : Set Œ±\nhs : s.Countable\nhf : MeasureTheory.IntegrableOn f s Œº\n‚ä¢ Eq (MeasureTheory.integral (Œº.restrict s) fun a => f a) (tsum fun a => HSMul.hSMul (Œº (Singleton.singleton ‚Üëa)).toReal (f ‚Üëa))","decl":"theorem integral_countable [MeasurableSingletonClass Œ±] (f : Œ± ‚Üí E) {s : Set Œ±} (hs : s.Countable)\n    (hf : IntegrableOn f s Œº) :\n    ‚à´ a in s, f a ‚àÇŒº = ‚àë' a : s, (Œº {(a : Œ±)}).toReal ‚Ä¢ f a := by\n  have hi : Countable { x // x ‚àà s } := Iff.mpr countable_coe_iff hs\n  have hf' : Integrable (fun (x : s) => f x) (Measure.comap Subtype.val Œº) := by\n    rw [IntegrableOn, ‚Üê map_comap_subtype_coe, integrable_map_measure] at hf\n    ¬∑ apply hf\n    ¬∑ exact Integrable.aestronglyMeasurable hf\n    ¬∑ exact Measurable.aemeasurable measurable_subtype_coe\n    ¬∑ exact Countable.measurableSet hs\n  rw [‚Üê integral_subtype_comap hs.measurableSet, integral_countable' hf']\n  congr 1 with a : 1\n  rw [Measure.comap_apply Subtype.val Subtype.coe_injective\n    (fun s' hs' => MeasurableSet.subtype_image (Countable.measurableSet hs) hs') _\n    (MeasurableSet.singleton a)]\n  simp\n\n"}
{"name":"MeasureTheory.integral_finset","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nhE : CompleteSpace E\ninst‚úù¬π : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : MeasurableSingletonClass Œ±\ns : Finset Œ±\nf : Œ± ‚Üí E\nhf : MeasureTheory.IntegrableOn f (‚Üës) Œº\n‚ä¢ Eq (MeasureTheory.integral (Œº.restrict ‚Üës) fun x => f x) (s.sum fun x => HSMul.hSMul (Œº (Singleton.singleton x)).toReal (f x))","decl":"theorem integral_finset [MeasurableSingletonClass Œ±] (s : Finset Œ±) (f : Œ± ‚Üí E)\n    (hf : IntegrableOn f s Œº) :\n    ‚à´ x in s, f x ‚àÇŒº = ‚àë x ‚àà s, (Œº {x}).toReal ‚Ä¢ f x := by\n  rw [integral_countable _ s.countable_toSet hf, ‚Üê Finset.tsum_subtype']\n\n"}
{"name":"MeasureTheory.integral_fintype","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\nhE : CompleteSpace E\ninst‚úù¬≤ : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : MeasurableSingletonClass Œ±\ninst‚úù : Fintype Œ±\nf : Œ± ‚Üí E\nhf : MeasureTheory.Integrable f Œº\n‚ä¢ Eq (MeasureTheory.integral Œº fun x => f x) (Finset.univ.sum fun x => HSMul.hSMul (Œº (Singleton.singleton x)).toReal (f x))","decl":"theorem integral_fintype [MeasurableSingletonClass Œ±] [Fintype Œ±] (f : Œ± ‚Üí E)\n    (hf : Integrable f Œº) :\n    ‚à´ x, f x ‚àÇŒº = ‚àë x, (Œº {x}).toReal ‚Ä¢ f x := by\n  -- NB: Integrable f does not follow from Fintype, because the measure itself could be non-finite\n  rw [‚Üê integral_finset .univ, Finset.coe_univ, Measure.restrict_univ]\n  simp [Finset.coe_univ, Measure.restrict_univ, hf]\n\n"}
{"name":"MeasureTheory.integral_unique","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\nhE : CompleteSpace E\ninst‚úù¬π : NormedSpace Real E\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : Unique Œ±\nf : Œ± ‚Üí E\n‚ä¢ Eq (MeasureTheory.integral Œº fun x => f x) (HSMul.hSMul (Œº Set.univ).toReal (f Inhabited.default))","decl":"theorem integral_unique [Unique Œ±] (f : Œ± ‚Üí E) : ‚à´ x, f x ‚àÇŒº = (Œº univ).toReal ‚Ä¢ f default :=\n  calc\n    ‚à´ x, f x ‚àÇŒº = ‚à´ _, f default ‚àÇŒº := by congr with x; congr; exact Unique.uniq _ x\n    _ = (Œº univ).toReal ‚Ä¢ f default := by rw [integral_const]\n\n"}
{"name":"MeasureTheory.integral_pos_of_integrable_nonneg_nonzero","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : Œº.IsOpenPosMeasure\nf : Œ± ‚Üí Real\nx : Œ±\nf_cont : Continuous f\nf_int : MeasureTheory.Integrable f Œº\nf_nonneg : LE.le 0 f\nf_x : Ne (f x) 0\n‚ä¢ LT.lt 0 (MeasureTheory.integral Œº fun x => f x)","decl":"theorem integral_pos_of_integrable_nonneg_nonzero [TopologicalSpace Œ±] [Measure.IsOpenPosMeasure Œº]\n    {f : Œ± ‚Üí ‚Ñù} {x : Œ±} (f_cont : Continuous f) (f_int : Integrable f Œº) (f_nonneg : 0 ‚â§ f)\n    (f_x : f x ‚â† 0) : 0 < ‚à´ x, f x ‚àÇŒº :=\n  (integral_pos_iff_support_of_nonneg f_nonneg f_int).2\n    (IsOpen.measure_pos Œº f_cont.isOpen_support ‚ü®x, f_x‚ü©)\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_toLargerSpace_eq","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ≤ : Type u_6\nŒ≥ : Type u_7\nm m0 : MeasurableSpace Œ≤\nhm : LE.le m m0\nf : MeasureTheory.SimpleFunc Œ≤ Œ≥\n‚ä¢ Eq ‚áë(MeasureTheory.SimpleFunc.toLargerSpace hm f) ‚áëf","decl":"theorem SimpleFunc.coe_toLargerSpace_eq (hm : m ‚â§ m0) (f : @SimpleFunc Œ≤ m Œ≥) :\n    ‚áë(f.toLargerSpace hm) = f := rfl\n\n"}
{"name":"MeasureTheory.integral_simpleFunc_larger_space","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"F : Type u_3\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\ninst‚úù : CompleteSpace F\nŒ≤ : Type u_6\nm m0 : MeasurableSpace Œ≤\nŒº : MeasureTheory.Measure Œ≤\nhm : LE.le m m0\nf : MeasureTheory.SimpleFunc Œ≤ F\nhf_int : MeasureTheory.Integrable (‚áëf) Œº\n‚ä¢ Eq (MeasureTheory.integral Œº fun x => f x) (f.range.sum fun x => HSMul.hSMul (Œº (Set.preimage (‚áëf) (Singleton.singleton x))).toReal x)","decl":"theorem integral_simpleFunc_larger_space (hm : m ‚â§ m0) (f : @SimpleFunc Œ≤ m F)\n    (hf_int : Integrable f Œº) :\n    ‚à´ x, f x ‚àÇŒº = ‚àë x ‚àà @SimpleFunc.range Œ≤ F m f, ENNReal.toReal (Œº (f ‚Åª¬π' {x})) ‚Ä¢ x := by\n  simp_rw [‚Üê f.coe_toLargerSpace_eq hm]\n  have hf_int : Integrable (f.toLargerSpace hm) Œº := by rwa [SimpleFunc.coe_toLargerSpace_eq]\n  rw [SimpleFunc.integral_eq_sum _ hf_int]\n  congr 1\n\n"}
{"name":"MeasureTheory.integral_trim_simpleFunc","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"F : Type u_3\ninst‚úù¬≤ : NormedAddCommGroup F\ninst‚úù¬π : NormedSpace Real F\ninst‚úù : CompleteSpace F\nŒ≤ : Type u_6\nm m0 : MeasurableSpace Œ≤\nŒº : MeasureTheory.Measure Œ≤\nhm : LE.le m m0\nf : MeasureTheory.SimpleFunc Œ≤ F\nhf_int : MeasureTheory.Integrable (‚áëf) Œº\n‚ä¢ Eq (MeasureTheory.integral Œº fun x => f x) (MeasureTheory.integral (Œº.trim hm) fun x => f x)","decl":"theorem integral_trim_simpleFunc (hm : m ‚â§ m0) (f : @SimpleFunc Œ≤ m F) (hf_int : Integrable f Œº) :\n    ‚à´ x, f x ‚àÇŒº = ‚à´ x, f x ‚àÇŒº.trim hm := by\n  have hf : StronglyMeasurable[m] f := @SimpleFunc.stronglyMeasurable Œ≤ F m _ f\n  have hf_int_m := hf_int.trim hm hf\n  rw [integral_simpleFunc_larger_space (le_refl m) f hf_int_m,\n    integral_simpleFunc_larger_space hm f hf_int]\n  congr with x\n  congr 2\n  exact (trim_measurableSet_eq hm (@SimpleFunc.measurableSet_fiber Œ≤ F m f x)).symm\n\n"}
{"name":"MeasureTheory.integral_trim","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"G : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nŒ≤ : Type u_6\nm m0 : MeasurableSpace Œ≤\nŒº : MeasureTheory.Measure Œ≤\nhm : LE.le m m0\nf : Œ≤ ‚Üí G\nhf : MeasureTheory.StronglyMeasurable f\n‚ä¢ Eq (MeasureTheory.integral Œº fun x => f x) (MeasureTheory.integral (Œº.trim hm) fun x => f x)","decl":"theorem integral_trim (hm : m ‚â§ m0) {f : Œ≤ ‚Üí G} (hf : StronglyMeasurable[m] f) :\n    ‚à´ x, f x ‚àÇŒº = ‚à´ x, f x ‚àÇŒº.trim hm := by\n  by_cases hG : CompleteSpace G; swap\n  ¬∑ simp [integral, hG]\n  borelize G\n  by_cases hf_int : Integrable f Œº\n  swap\n  ¬∑ have hf_int_m : ¬¨Integrable f (Œº.trim hm) := fun hf_int_m =>\n      hf_int (integrable_of_integrable_trim hm hf_int_m)\n    rw [integral_undef hf_int, integral_undef hf_int_m]\n  haveI : SeparableSpace (range f ‚à™ {0} : Set G) := hf.separableSpace_range_union_singleton\n  let f_seq := @SimpleFunc.approxOn G Œ≤ _ _ _ m _ hf.measurable (range f ‚à™ {0}) 0 (by simp) _\n  have hf_seq_meas : ‚àÄ n, StronglyMeasurable[m] (f_seq n) := fun n =>\n    @SimpleFunc.stronglyMeasurable Œ≤ G m _ (f_seq n)\n  have hf_seq_int : ‚àÄ n, Integrable (f_seq n) Œº :=\n    SimpleFunc.integrable_approxOn_range (hf.mono hm).measurable hf_int\n  have hf_seq_int_m : ‚àÄ n, Integrable (f_seq n) (Œº.trim hm) := fun n =>\n    (hf_seq_int n).trim hm (hf_seq_meas n)\n  have hf_seq_eq : ‚àÄ n, ‚à´ x, f_seq n x ‚àÇŒº = ‚à´ x, f_seq n x ‚àÇŒº.trim hm := fun n =>\n    integral_trim_simpleFunc hm (f_seq n) (hf_seq_int n)\n  have h_lim_1 : atTop.Tendsto (fun n => ‚à´ x, f_seq n x ‚àÇŒº) (ùìù (‚à´ x, f x ‚àÇŒº)) := by\n    refine tendsto_integral_of_L1 f hf_int (Eventually.of_forall hf_seq_int) ?_\n    exact SimpleFunc.tendsto_approxOn_range_L1_enorm (hf.mono hm).measurable hf_int\n  have h_lim_2 : atTop.Tendsto (fun n => ‚à´ x, f_seq n x ‚àÇŒº) (ùìù (‚à´ x, f x ‚àÇŒº.trim hm)) := by\n    simp_rw [hf_seq_eq]\n    refine @tendsto_integral_of_L1 Œ≤ G _ _ m (Œº.trim hm) _ f (hf_int.trim hm hf) _ _\n      (Eventually.of_forall hf_seq_int_m) ?_\n    exact @SimpleFunc.tendsto_approxOn_range_L1_enorm Œ≤ G m _ _ _ f _ _ hf.measurable\n      (hf_int.trim hm hf)\n  exact tendsto_nhds_unique h_lim_1 h_lim_2\n\n"}
{"name":"MeasureTheory.integral_trim_ae","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"G : Type u_5\ninst‚úù¬π : NormedAddCommGroup G\ninst‚úù : NormedSpace Real G\nŒ≤ : Type u_6\nm m0 : MeasurableSpace Œ≤\nŒº : MeasureTheory.Measure Œ≤\nhm : LE.le m m0\nf : Œ≤ ‚Üí G\nhf : MeasureTheory.AEStronglyMeasurable f (Œº.trim hm)\n‚ä¢ Eq (MeasureTheory.integral Œº fun x => f x) (MeasureTheory.integral (Œº.trim hm) fun x => f x)","decl":"theorem integral_trim_ae (hm : m ‚â§ m0) {f : Œ≤ ‚Üí G} (hf : AEStronglyMeasurable[m] f (Œº.trim hm)) :\n    ‚à´ x, f x ‚àÇŒº = ‚à´ x, f x ‚àÇŒº.trim hm := by\n  rw [integral_congr_ae (ae_eq_of_ae_eq_trim hf.ae_eq_mk), integral_congr_ae hf.ae_eq_mk]\n  exact integral_trim hm hf.stronglyMeasurable_mk\n\n"}
{"name":"MeasureTheory.eLpNorm_one_le_of_le","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Real\nr : NNReal\nhfint : MeasureTheory.Integrable f Œº\nhfint' : LE.le 0 (MeasureTheory.integral Œº fun x => f x)\nhf : Filter.Eventually (fun œâ => LE.le (f œâ) ‚Üër) (MeasureTheory.ae Œº)\n‚ä¢ LE.le (MeasureTheory.eLpNorm f 1 Œº) (HMul.hMul (HMul.hMul 2 (Œº Set.univ)) ‚Üër)","decl":"theorem eLpNorm_one_le_of_le {r : ‚Ñù‚â•0} (hfint : Integrable f Œº) (hfint' : 0 ‚â§ ‚à´ x, f x ‚àÇŒº)\n    (hf : ‚àÄ·µê œâ ‚àÇŒº, f œâ ‚â§ r) : eLpNorm f 1 Œº ‚â§ 2 * Œº Set.univ * r := by\n  by_cases hr : r = 0\n  ¬∑ suffices f =·µê[Œº] 0 by\n      rw [eLpNorm_congr_ae this, eLpNorm_zero, hr, ENNReal.coe_zero, mul_zero]\n    rw [hr] at hf\n    norm_cast at hf\n    -- Porting note: two lines above were\n    --rw [hr, Nonneg.coe_zero] at hf\n    have hnegf : ‚à´ x, -f x ‚àÇŒº = 0 := by\n      rw [integral_neg, neg_eq_zero]\n      exact le_antisymm (integral_nonpos_of_ae hf) hfint'\n    have := (integral_eq_zero_iff_of_nonneg_ae ?_ hfint.neg).1 hnegf\n    ¬∑ filter_upwards [this] with œâ hœâ\n      rwa [Pi.neg_apply, Pi.zero_apply, neg_eq_zero] at hœâ\n    ¬∑ filter_upwards [hf] with œâ hœâ\n      rwa [Pi.zero_apply, Pi.neg_apply, Right.nonneg_neg_iff]\n  by_cases hŒº : IsFiniteMeasure Œº\n  swap\n  ¬∑ have : Œº Set.univ = ‚àû := by\n      by_contra hŒº'\n      exact hŒº (IsFiniteMeasure.mk <| lt_top_iff_ne_top.2 hŒº')\n    rw [this, ENNReal.mul_top', if_neg, ENNReal.top_mul', if_neg]\n    ¬∑ exact le_top\n    ¬∑ simp [hr]\n    ¬∑ norm_num\n  haveI := hŒº\n  rw [integral_eq_integral_pos_part_sub_integral_neg_part hfint, sub_nonneg] at hfint'\n  have hposbdd : ‚à´ œâ, max (f œâ) 0 ‚àÇŒº ‚â§ (Œº Set.univ).toReal ‚Ä¢ (r : ‚Ñù) := by\n    rw [‚Üê integral_const]\n    refine integral_mono_ae hfint.real_toNNReal (integrable_const (r : ‚Ñù)) ?_\n    filter_upwards [hf] with œâ hœâ using Real.toNNReal_le_iff_le_coe.2 hœâ\n  rw [Mem‚Ñíp.eLpNorm_eq_integral_rpow_norm one_ne_zero ENNReal.one_ne_top\n      (mem‚Ñíp_one_iff_integrable.2 hfint),\n    ENNReal.ofReal_le_iff_le_toReal\n      (ENNReal.mul_ne_top (ENNReal.mul_ne_top ENNReal.ofNat_ne_top <| @measure_ne_top _ _ _ hŒº _)\n        ENNReal.coe_ne_top)]\n  simp_rw [ENNReal.one_toReal, _root_.inv_one, Real.rpow_one, Real.norm_eq_abs, ‚Üê\n    max_zero_add_max_neg_zero_eq_abs_self, ‚Üê Real.coe_toNNReal']\n  rw [integral_add hfint.real_toNNReal]\n  ¬∑ simp only [Real.coe_toNNReal', ENNReal.toReal_mul, ENNReal.one_toReal, ENNReal.coe_toReal,\n      Left.nonneg_neg_iff, Left.neg_nonpos_iff, toReal_ofNat] at hfint' ‚ä¢\n    refine (add_le_add_left hfint' _).trans ?_\n    rwa [‚Üê two_mul, mul_assoc, mul_le_mul_left (two_pos : (0 : ‚Ñù) < 2)]\n  ¬∑ exact hfint.neg.sup (integrable_zero _ _ Œº)\n\n"}
{"name":"MeasureTheory.eLpNorm_one_le_of_le'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Œ± : Type u_1\nm0 : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf : Œ± ‚Üí Real\nr : Real\nhfint : MeasureTheory.Integrable f Œº\nhfint' : LE.le 0 (MeasureTheory.integral Œº fun x => f x)\nhf : Filter.Eventually (fun œâ => LE.le (f œâ) r) (MeasureTheory.ae Œº)\n‚ä¢ LE.le (MeasureTheory.eLpNorm f 1 Œº) (HMul.hMul (HMul.hMul 2 (Œº Set.univ)) (ENNReal.ofReal r))","decl":"theorem eLpNorm_one_le_of_le' {r : ‚Ñù} (hfint : Integrable f Œº) (hfint' : 0 ‚â§ ‚à´ x, f x ‚àÇŒº)\n    (hf : ‚àÄ·µê œâ ‚àÇŒº, f œâ ‚â§ r) : eLpNorm f 1 Œº ‚â§ 2 * Œº Set.univ * ENNReal.ofReal r := by\n  refine eLpNorm_one_le_of_le hfint hfint' ?_\n  simp only [Real.coe_toNNReal', le_max_iff]\n  filter_upwards [hf] with œâ hœâ using Or.inl hœâ\n\n"}
