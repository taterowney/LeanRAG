{"name":"MeasureTheory.weightedSMul_apply","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nx : F\nâŠ¢ Eq ((MeasureTheory.weightedSMul Î¼ s) x) (HSMul.hSMul (Î¼ s).toReal x)","decl":"theorem weightedSMul_apply {m : MeasurableSpace Î±} (Î¼ : Measure Î±) (s : Set Î±) (x : F) :\n    weightedSMul Î¼ s x = (Î¼ s).toReal â€¢ x := by simp [weightedSMul]\n\n"}
{"name":"MeasureTheory.weightedSMul_zero_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nâŠ¢ Eq (MeasureTheory.weightedSMul 0) 0","decl":"@[simp]\ntheorem weightedSMul_zero_measure {m : MeasurableSpace Î±} :\n    weightedSMul (0 : Measure Î±) = (0 : Set Î± â†’ F â†’L[â„] F) := by ext1; simp [weightedSMul]\n\n"}
{"name":"MeasureTheory.weightedSMul_empty","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ Eq (MeasureTheory.weightedSMul Î¼ EmptyCollection.emptyCollection) 0","decl":"@[simp]\ntheorem weightedSMul_empty {m : MeasurableSpace Î±} (Î¼ : Measure Î±) :\n    weightedSMul Î¼ âˆ… = (0 : F â†’L[â„] F) := by ext1 x; rw [weightedSMul_apply]; simp\n\n"}
{"name":"MeasureTheory.weightedSMul_add_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\ns : Set Î±\nhÎ¼s : Ne (Î¼ s) Top.top\nhÎ½s : Ne (Î½ s) Top.top\nâŠ¢ Eq (MeasureTheory.weightedSMul (HAdd.hAdd Î¼ Î½) s) (HAdd.hAdd (MeasureTheory.weightedSMul Î¼ s) (MeasureTheory.weightedSMul Î½ s))","decl":"theorem weightedSMul_add_measure {m : MeasurableSpace Î±} (Î¼ Î½ : Measure Î±) {s : Set Î±}\n    (hÎ¼s : Î¼ s â‰  âˆ) (hÎ½s : Î½ s â‰  âˆ) :\n    (weightedSMul (Î¼ + Î½) s : F â†’L[â„] F) = weightedSMul Î¼ s + weightedSMul Î½ s := by\n  ext1 x\n  push_cast\n  simp_rw [Pi.add_apply, weightedSMul_apply]\n  push_cast\n  rw [Pi.add_apply, ENNReal.toReal_add hÎ¼s hÎ½s, add_smul]\n\n"}
{"name":"MeasureTheory.weightedSMul_smul_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nc : ENNReal\ns : Set Î±\nâŠ¢ Eq (MeasureTheory.weightedSMul (HSMul.hSMul c Î¼) s) (HSMul.hSMul c.toReal (MeasureTheory.weightedSMul Î¼ s))","decl":"theorem weightedSMul_smul_measure {m : MeasurableSpace Î±} (Î¼ : Measure Î±) (c : â„â‰¥0âˆ) {s : Set Î±} :\n    (weightedSMul (c â€¢ Î¼) s : F â†’L[â„] F) = c.toReal â€¢ weightedSMul Î¼ s := by\n  ext1 x\n  push_cast\n  simp_rw [Pi.smul_apply, weightedSMul_apply]\n  push_cast\n  simp_rw [Pi.smul_apply, smul_eq_mul, toReal_mul, smul_smul]\n\n"}
{"name":"MeasureTheory.weightedSMul_congr","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns t : Set Î±\nhst : Eq (Î¼ s) (Î¼ t)\nâŠ¢ Eq (MeasureTheory.weightedSMul Î¼ s) (MeasureTheory.weightedSMul Î¼ t)","decl":"theorem weightedSMul_congr (s t : Set Î±) (hst : Î¼ s = Î¼ t) :\n    (weightedSMul Î¼ s : F â†’L[â„] F) = weightedSMul Î¼ t := by\n  ext1 x; simp_rw [weightedSMul_apply]; congr 2\n\n"}
{"name":"MeasureTheory.weightedSMul_null","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nh_zero : Eq (Î¼ s) 0\nâŠ¢ Eq (MeasureTheory.weightedSMul Î¼ s) 0","decl":"theorem weightedSMul_null {s : Set Î±} (h_zero : Î¼ s = 0) : (weightedSMul Î¼ s : F â†’L[â„] F) = 0 := by\n  ext1 x; rw [weightedSMul_apply, h_zero]; simp\n\n"}
{"name":"MeasureTheory.weightedSMul_union'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns t : Set Î±\nht : MeasurableSet t\nhs_finite : Ne (Î¼ s) Top.top\nht_finite : Ne (Î¼ t) Top.top\nhdisj : Disjoint s t\nâŠ¢ Eq (MeasureTheory.weightedSMul Î¼ (Union.union s t)) (HAdd.hAdd (MeasureTheory.weightedSMul Î¼ s) (MeasureTheory.weightedSMul Î¼ t))","decl":"theorem weightedSMul_union' (s t : Set Î±) (ht : MeasurableSet t) (hs_finite : Î¼ s â‰  âˆ)\n    (ht_finite : Î¼ t â‰  âˆ) (hdisj : Disjoint s t) :\n    (weightedSMul Î¼ (s âˆª t) : F â†’L[â„] F) = weightedSMul Î¼ s + weightedSMul Î¼ t := by\n  ext1 x\n  simp_rw [add_apply, weightedSMul_apply, measure_union hdisj ht,\n    ENNReal.toReal_add hs_finite ht_finite, add_smul]\n\n"}
{"name":"MeasureTheory.weightedSMul_union","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns t : Set Î±\n_hs : MeasurableSet s\nht : MeasurableSet t\nhs_finite : Ne (Î¼ s) Top.top\nht_finite : Ne (Î¼ t) Top.top\nhdisj : Disjoint s t\nâŠ¢ Eq (MeasureTheory.weightedSMul Î¼ (Union.union s t)) (HAdd.hAdd (MeasureTheory.weightedSMul Î¼ s) (MeasureTheory.weightedSMul Î¼ t))","decl":"@[nolint unusedArguments]\ntheorem weightedSMul_union (s t : Set Î±) (_hs : MeasurableSet s) (ht : MeasurableSet t)\n    (hs_finite : Î¼ s â‰  âˆ) (ht_finite : Î¼ t â‰  âˆ) (hdisj : Disjoint s t) :\n    (weightedSMul Î¼ (s âˆª t) : F â†’L[â„] F) = weightedSMul Î¼ s + weightedSMul Î¼ t :=\n  weightedSMul_union' s t ht hs_finite ht_finite hdisj\n\n"}
{"name":"MeasureTheory.weightedSMul_smul","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nF : Type u_3\nğ•œ : Type u_4\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : SMulCommClass Real ğ•œ F\nc : ğ•œ\ns : Set Î±\nx : F\nâŠ¢ Eq ((MeasureTheory.weightedSMul Î¼ s) (HSMul.hSMul c x)) (HSMul.hSMul c ((MeasureTheory.weightedSMul Î¼ s) x))","decl":"theorem weightedSMul_smul [NormedField ğ•œ] [NormedSpace ğ•œ F] [SMulCommClass â„ ğ•œ F] (c : ğ•œ)\n    (s : Set Î±) (x : F) : weightedSMul Î¼ s (c â€¢ x) = c â€¢ weightedSMul Î¼ s x := by\n  simp_rw [weightedSMul_apply, smul_comm]\n\n"}
{"name":"MeasureTheory.norm_weightedSMul_le","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nâŠ¢ LE.le (Norm.norm (MeasureTheory.weightedSMul Î¼ s)) (Î¼ s).toReal","decl":"theorem norm_weightedSMul_le (s : Set Î±) : â€–(weightedSMul Î¼ s : F â†’L[â„] F)â€– â‰¤ (Î¼ s).toReal :=\n  calc\n    â€–(weightedSMul Î¼ s : F â†’L[â„] F)â€– = â€–(Î¼ s).toRealâ€– * â€–ContinuousLinearMap.id â„ Fâ€– :=\n      norm_smul (Î¼ s).toReal (ContinuousLinearMap.id â„ F)\n    _ â‰¤ â€–(Î¼ s).toRealâ€– :=\n      ((mul_le_mul_of_nonneg_left norm_id_le (norm_nonneg _)).trans (mul_one _).le)\n    _ = abs (Î¼ s).toReal := Real.norm_eq_abs _\n    _ = (Î¼ s).toReal := abs_eq_self.mpr ENNReal.toReal_nonneg\n\n"}
{"name":"MeasureTheory.dominatedFinMeasAdditive_weightedSMul","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nxâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ MeasureTheory.DominatedFinMeasAdditive Î¼ (MeasureTheory.weightedSMul Î¼) 1","decl":"theorem dominatedFinMeasAdditive_weightedSMul {_ : MeasurableSpace Î±} (Î¼ : Measure Î±) :\n    DominatedFinMeasAdditive Î¼ (weightedSMul Î¼ : Set Î± â†’ F â†’L[â„] F) 1 :=\n  âŸ¨weightedSMul_union, fun s _ _ => (norm_weightedSMul_le s).trans (one_mul _).symm.leâŸ©\n\n"}
{"name":"MeasureTheory.weightedSMul_nonneg","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nx : Real\nhx : LE.le 0 x\nâŠ¢ LE.le 0 ((MeasureTheory.weightedSMul Î¼ s) x)","decl":"theorem weightedSMul_nonneg (s : Set Î±) (x : â„) (hx : 0 â‰¤ x) : 0 â‰¤ weightedSMul Î¼ s x := by\n  simp only [weightedSMul, Algebra.id.smul_eq_mul, coe_smul', _root_.id, coe_id', Pi.smul_apply]\n  exact mul_nonneg toReal_nonneg hx\n\n"}
{"name":"MeasureTheory.SimpleFunc.posPart_map_norm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\ninstâœ : MeasurableSpace Î±\nf : MeasureTheory.SimpleFunc Î± Real\nâŠ¢ Eq (MeasureTheory.SimpleFunc.map Norm.norm f.posPart) f.posPart","decl":"theorem posPart_map_norm (f : Î± â†’â‚› â„) : (posPart f).map norm = posPart f := by\n  ext; rw [map_apply, Real.norm_eq_abs, abs_of_nonneg]; exact le_max_right _ _\n\n"}
{"name":"MeasureTheory.SimpleFunc.negPart_map_norm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\ninstâœ : MeasurableSpace Î±\nf : MeasureTheory.SimpleFunc Î± Real\nâŠ¢ Eq (MeasureTheory.SimpleFunc.map Norm.norm f.negPart) f.negPart","decl":"theorem negPart_map_norm (f : Î± â†’â‚› â„) : (negPart f).map norm = negPart f := by\n  rw [negPart]; exact posPart_map_norm _\n\n"}
{"name":"MeasureTheory.SimpleFunc.posPart_sub_negPart","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\ninstâœ : MeasurableSpace Î±\nf : MeasureTheory.SimpleFunc Î± Real\nâŠ¢ Eq (HSub.hSub f.posPart f.negPart) f","decl":"theorem posPart_sub_negPart (f : Î± â†’â‚› â„) : f.posPart - f.negPart = f := by\n  simp only [posPart, negPart]\n  ext a\n  rw [coe_sub]\n  exact max_zero_sub_eq_self (f a)\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_def","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nxâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : MeasureTheory.SimpleFunc Î± F\nâŠ¢ Eq (MeasureTheory.SimpleFunc.integral Î¼ f) (MeasureTheory.SimpleFunc.setToSimpleFunc (MeasureTheory.weightedSMul Î¼) f)","decl":"theorem integral_def {_ : MeasurableSpace Î±} (Î¼ : Measure Î±) (f : Î± â†’â‚› F) :\n    f.integral Î¼ = f.setToSimpleFunc (weightedSMul Î¼) := rfl\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_eq","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : MeasureTheory.SimpleFunc Î± F\nâŠ¢ Eq (MeasureTheory.SimpleFunc.integral Î¼ f) (f.range.sum fun x => HSMul.hSMul (Î¼ (Set.preimage (â‡‘f) (Singleton.singleton x))).toReal x)","decl":"theorem integral_eq {m : MeasurableSpace Î±} (Î¼ : Measure Î±) (f : Î± â†’â‚› F) :\n    f.integral Î¼ = âˆ‘ x âˆˆ f.range, (Î¼ (f â»Â¹' {x})).toReal â€¢ x := by\n  simp [integral, setToSimpleFunc, weightedSMul_apply]\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_eq_sum_filter","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : DecidablePred fun x => Ne x 0\nm : MeasurableSpace Î±\nf : MeasureTheory.SimpleFunc Î± F\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ Eq (MeasureTheory.SimpleFunc.integral Î¼ f) ((Finset.filter (fun x => Ne x 0) f.range).sum fun x => HSMul.hSMul (Î¼ (Set.preimage (â‡‘f) (Singleton.singleton x))).toReal x)","decl":"theorem integral_eq_sum_filter [DecidablePred fun x : F => x â‰  0] {m : MeasurableSpace Î±}\n    (f : Î± â†’â‚› F) (Î¼ : Measure Î±) :\n    f.integral Î¼ = âˆ‘ x âˆˆ {x âˆˆ f.range | x â‰  0}, (Î¼ (f â»Â¹' {x})).toReal â€¢ x := by\n  simp_rw [integral_def, setToSimpleFunc_eq_sum_filter, weightedSMul_apply]\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_eq_sum_of_subset","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : DecidablePred fun x => Ne x 0\nf : MeasureTheory.SimpleFunc Î± F\ns : Finset F\nhs : HasSubset.Subset (Finset.filter (fun x => Ne x 0) f.range) s\nâŠ¢ Eq (MeasureTheory.SimpleFunc.integral Î¼ f) (s.sum fun x => HSMul.hSMul (Î¼ (Set.preimage (â‡‘f) (Singleton.singleton x))).toReal x)","decl":"/-- The Bochner integral is equal to a sum over any set that includes `f.range` (except `0`). -/\ntheorem integral_eq_sum_of_subset [DecidablePred fun x : F => x â‰  0] {f : Î± â†’â‚› F} {s : Finset F}\n    (hs : {x âˆˆ f.range | x â‰  0} âŠ† s) :\n    f.integral Î¼ = âˆ‘ x âˆˆ s, (Î¼ (f â»Â¹' {x})).toReal â€¢ x := by\n  rw [SimpleFunc.integral_eq_sum_filter, Finset.sum_subset hs]\n  rintro x - hx; rw [Finset.mem_filter, not_and_or, Ne, Classical.not_not] at hx\n  -- Porting note: reordered for clarity\n  rcases hx.symm with (rfl | hx)\n  Â· simp\n  rw [SimpleFunc.mem_range] at hx\n  -- Porting note: added\n  simp only [Set.mem_range, not_exists] at hx\n  rw [preimage_eq_empty] <;> simp [Set.disjoint_singleton_left, hx]\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_const","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ny : F\nâŠ¢ Eq (MeasureTheory.SimpleFunc.integral Î¼ (MeasureTheory.SimpleFunc.const Î± y)) (HSMul.hSMul (Î¼ Set.univ).toReal y)","decl":"@[simp]\ntheorem integral_const {m : MeasurableSpace Î±} (Î¼ : Measure Î±) (y : F) :\n    (const Î± y).integral Î¼ = (Î¼ univ).toReal â€¢ y := by\n  classical\n  calc\n    (const Î± y).integral Î¼ = âˆ‘ z âˆˆ {y}, (Î¼ (const Î± y â»Â¹' {z})).toReal â€¢ z :=\n      integral_eq_sum_of_subset <| (filter_subset _ _).trans (range_const_subset _ _)\n    _ = (Î¼ univ).toReal â€¢ y := by simp [Set.preimage] -- Porting note: added `Set.preimage`\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_piecewise_zero","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nF : Type u_3\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nf : MeasureTheory.SimpleFunc Î± F\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhs : MeasurableSet s\nâŠ¢ Eq (MeasureTheory.SimpleFunc.integral Î¼ (MeasureTheory.SimpleFunc.piecewise s hs f 0)) (MeasureTheory.SimpleFunc.integral (Î¼.restrict s) f)","decl":"@[simp]\ntheorem integral_piecewise_zero {m : MeasurableSpace Î±} (f : Î± â†’â‚› F) (Î¼ : Measure Î±) {s : Set Î±}\n    (hs : MeasurableSet s) : (piecewise s hs f 0).integral Î¼ = f.integral (Î¼.restrict s) := by\n  classical\n  refine (integral_eq_sum_of_subset ?_).trans\n      ((sum_congr rfl fun y hy => ?_).trans (integral_eq_sum_filter _ _).symm)\n  Â· intro y hy\n    simp only [mem_filter, mem_range, coe_piecewise, coe_zero, piecewise_eq_indicator,\n      mem_range_indicator] at *\n    rcases hy with âŸ¨âŸ¨rfl, -âŸ© | âŸ¨x, -, rflâŸ©, hâ‚€âŸ©\n    exacts [(hâ‚€ rfl).elim, âŸ¨Set.mem_range_self _, hâ‚€âŸ©]\n  Â· dsimp\n    rw [Set.piecewise_eq_indicator, indicator_preimage_of_not_mem,\n      Measure.restrict_apply (f.measurableSet_preimage _)]\n    exact fun hâ‚€ => (mem_filter.1 hy).2 (Eq.symm hâ‚€)\n\n"}
{"name":"MeasureTheory.SimpleFunc.map_integral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : MeasureTheory.SimpleFunc Î± E\ng : E â†’ F\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nhg : Eq (g 0) 0\nâŠ¢ Eq (MeasureTheory.SimpleFunc.integral Î¼ (MeasureTheory.SimpleFunc.map g f)) (f.range.sum fun x => HSMul.hSMul (Î¼ (Set.preimage (â‡‘f) (Singleton.singleton x))).toReal (g x))","decl":"/-- Calculate the integral of `g âˆ˜ f : Î± â†’â‚› F`, where `f` is an integrable function from `Î±` to `E`\n    and `g` is a function from `E` to `F`. We require `g 0 = 0` so that `g âˆ˜ f` is integrable. -/\ntheorem map_integral (f : Î± â†’â‚› E) (g : E â†’ F) (hf : Integrable f Î¼) (hg : g 0 = 0) :\n    (f.map g).integral Î¼ = âˆ‘ x âˆˆ f.range, ENNReal.toReal (Î¼ (f â»Â¹' {x})) â€¢ g x :=\n  map_setToSimpleFunc _ weightedSMul_union hf hg\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_eq_lintegral'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœ : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : MeasureTheory.SimpleFunc Î± E\ng : E â†’ ENNReal\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nhg0 : Eq (g 0) 0\nht : âˆ€ (b : E), Ne (g b) Top.top\nâŠ¢ Eq (MeasureTheory.SimpleFunc.integral Î¼ (MeasureTheory.SimpleFunc.map (Function.comp ENNReal.toReal g) f)) (MeasureTheory.lintegral Î¼ fun a => g (f a)).toReal","decl":"/-- `SimpleFunc.integral` and `SimpleFunc.lintegral` agree when the integrand has type\n    `Î± â†’â‚› â„â‰¥0âˆ`. But since `â„â‰¥0âˆ` is not a `NormedSpace`, we need some form of coercion.\n    See `integral_eq_lintegral` for a simpler version. -/\ntheorem integral_eq_lintegral' {f : Î± â†’â‚› E} {g : E â†’ â„â‰¥0âˆ} (hf : Integrable f Î¼) (hg0 : g 0 = 0)\n    (ht : âˆ€ b, g b â‰  âˆ) :\n    (f.map (ENNReal.toReal âˆ˜ g)).integral Î¼ = ENNReal.toReal (âˆ«â» a, g (f a) âˆ‚Î¼) := by\n  have hf' : f.FinMeasSupp Î¼ := integrable_iff_finMeasSupp.1 hf\n  simp only [â† map_apply g f, lintegral_eq_lintegral]\n  rw [map_integral f _ hf, map_lintegral, ENNReal.toReal_sum]\n  Â· refine Finset.sum_congr rfl fun b _ => ?_\n    -- Porting note: added `Function.comp_apply`\n    rw [smul_eq_mul, toReal_mul, mul_comm, Function.comp_apply]\n  Â· rintro a -\n    by_cases a0 : a = 0\n    Â· rw [a0, hg0, zero_mul]; exact WithTop.zero_ne_top\n    Â· apply mul_ne_top (ht a) (hf'.meas_preimage_singleton_ne_zero a0).ne\n  Â· simp [hg0]\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_congr","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedSpace Real E\nf g : MeasureTheory.SimpleFunc Î± E\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nh : (MeasureTheory.ae Î¼).EventuallyEq â‡‘f â‡‘g\nâŠ¢ Eq (MeasureTheory.SimpleFunc.integral Î¼ f) (MeasureTheory.SimpleFunc.integral Î¼ g)","decl":"theorem integral_congr {f g : Î± â†’â‚› E} (hf : Integrable f Î¼) (h : f =áµ[Î¼] g) :\n    f.integral Î¼ = g.integral Î¼ :=\n  setToSimpleFunc_congr (weightedSMul Î¼) (fun _ _ => weightedSMul_null) weightedSMul_union hf h\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_eq_lintegral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : MeasureTheory.SimpleFunc Î± Real\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nh_pos : (MeasureTheory.ae Î¼).EventuallyLE 0 â‡‘f\nâŠ¢ Eq (MeasureTheory.SimpleFunc.integral Î¼ f) (MeasureTheory.lintegral Î¼ fun a => ENNReal.ofReal (f a)).toReal","decl":"/-- `SimpleFunc.bintegral` and `SimpleFunc.integral` agree when the integrand has type\n    `Î± â†’â‚› â„â‰¥0âˆ`. But since `â„â‰¥0âˆ` is not a `NormedSpace`, we need some form of coercion. -/\ntheorem integral_eq_lintegral {f : Î± â†’â‚› â„} (hf : Integrable f Î¼) (h_pos : 0 â‰¤áµ[Î¼] f) :\n    f.integral Î¼ = ENNReal.toReal (âˆ«â» a, ENNReal.ofReal (f a) âˆ‚Î¼) := by\n  have : f =áµ[Î¼] f.map (ENNReal.toReal âˆ˜ ENNReal.ofReal) :=\n    h_pos.mono fun a h => (ENNReal.toReal_ofReal h).symm\n  rw [â† integral_eq_lintegral' hf]\n  exacts [integral_congr hf this, ENNReal.ofReal_zero, fun b => ENNReal.ofReal_ne_top]\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_add","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedSpace Real E\nf g : MeasureTheory.SimpleFunc Î± E\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nhg : MeasureTheory.Integrable (â‡‘g) Î¼\nâŠ¢ Eq (MeasureTheory.SimpleFunc.integral Î¼ (HAdd.hAdd f g)) (HAdd.hAdd (MeasureTheory.SimpleFunc.integral Î¼ f) (MeasureTheory.SimpleFunc.integral Î¼ g))","decl":"theorem integral_add {f g : Î± â†’â‚› E} (hf : Integrable f Î¼) (hg : Integrable g Î¼) :\n    integral Î¼ (f + g) = integral Î¼ f + integral Î¼ g :=\n  setToSimpleFunc_add _ weightedSMul_union hf hg\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_neg","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedSpace Real E\nf : MeasureTheory.SimpleFunc Î± E\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nâŠ¢ Eq (MeasureTheory.SimpleFunc.integral Î¼ (Neg.neg f)) (Neg.neg (MeasureTheory.SimpleFunc.integral Î¼ f))","decl":"theorem integral_neg {f : Î± â†’â‚› E} (hf : Integrable f Î¼) : integral Î¼ (-f) = -integral Î¼ f :=\n  setToSimpleFunc_neg _ weightedSMul_union hf\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_sub","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedSpace Real E\nf g : MeasureTheory.SimpleFunc Î± E\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nhg : MeasureTheory.Integrable (â‡‘g) Î¼\nâŠ¢ Eq (MeasureTheory.SimpleFunc.integral Î¼ (HSub.hSub f g)) (HSub.hSub (MeasureTheory.SimpleFunc.integral Î¼ f) (MeasureTheory.SimpleFunc.integral Î¼ g))","decl":"theorem integral_sub {f g : Î± â†’â‚› E} (hf : Integrable f Î¼) (hg : Integrable g Î¼) :\n    integral Î¼ (f - g) = integral Î¼ f - integral Î¼ g :=\n  setToSimpleFunc_sub _ weightedSMul_union hf hg\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_smul","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\nğ•œ : Type u_4\ninstâœâ´ : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : SMulCommClass Real ğ•œ E\nc : ğ•œ\nf : MeasureTheory.SimpleFunc Î± E\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nâŠ¢ Eq (MeasureTheory.SimpleFunc.integral Î¼ (HSMul.hSMul c f)) (HSMul.hSMul c (MeasureTheory.SimpleFunc.integral Î¼ f))","decl":"theorem integral_smul (c : ğ•œ) {f : Î± â†’â‚› E} (hf : Integrable f Î¼) :\n    integral Î¼ (c â€¢ f) = c â€¢ integral Î¼ f :=\n  setToSimpleFunc_smul _ weightedSMul_union weightedSMul_smul c hf\n\n"}
{"name":"MeasureTheory.SimpleFunc.norm_setToSimpleFunc_le_integral_norm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedSpace Real E\nT : Set Î± â†’ ContinuousLinearMap (RingHom.id Real) E F\nC : Real\nhT_norm : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ LE.le (Norm.norm (T s)) (HMul.hMul C (Î¼ s).toReal)\nf : MeasureTheory.SimpleFunc Î± E\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nâŠ¢ LE.le (Norm.norm (MeasureTheory.SimpleFunc.setToSimpleFunc T f)) (HMul.hMul C (MeasureTheory.SimpleFunc.integral Î¼ (MeasureTheory.SimpleFunc.map Norm.norm f)))","decl":"theorem norm_setToSimpleFunc_le_integral_norm (T : Set Î± â†’ E â†’L[â„] F) {C : â„}\n    (hT_norm : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ â€–T sâ€– â‰¤ C * (Î¼ s).toReal) {f : Î± â†’â‚› E}\n    (hf : Integrable f Î¼) : â€–f.setToSimpleFunc Tâ€– â‰¤ C * (f.map norm).integral Î¼ :=\n  calc\n    â€–f.setToSimpleFunc Tâ€– â‰¤ C * âˆ‘ x âˆˆ f.range, ENNReal.toReal (Î¼ (f â»Â¹' {x})) * â€–xâ€– :=\n      norm_setToSimpleFunc_le_sum_mul_norm_of_integrable T hT_norm f hf\n    _ = C * (f.map norm).integral Î¼ := by\n      rw [map_integral f norm hf norm_zero]; simp_rw [smul_eq_mul]\n\n"}
{"name":"MeasureTheory.SimpleFunc.norm_integral_le_integral_norm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedSpace Real E\nf : MeasureTheory.SimpleFunc Î± E\nhf : MeasureTheory.Integrable (â‡‘f) Î¼\nâŠ¢ LE.le (Norm.norm (MeasureTheory.SimpleFunc.integral Î¼ f)) (MeasureTheory.SimpleFunc.integral Î¼ (MeasureTheory.SimpleFunc.map Norm.norm f))","decl":"theorem norm_integral_le_integral_norm (f : Î± â†’â‚› E) (hf : Integrable f Î¼) :\n    â€–f.integral Î¼â€– â‰¤ (f.map norm).integral Î¼ := by\n  refine (norm_setToSimpleFunc_le_integral_norm _ (fun s _ _ => ?_) hf).trans (one_mul _).le\n  exact (norm_weightedSMul_le s).trans (one_mul _).symm.le\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_add_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedSpace Real E\nÎ½ : MeasureTheory.Measure Î±\nf : MeasureTheory.SimpleFunc Î± E\nhf : MeasureTheory.Integrable (â‡‘f) (HAdd.hAdd Î¼ Î½)\nâŠ¢ Eq (MeasureTheory.SimpleFunc.integral (HAdd.hAdd Î¼ Î½) f) (HAdd.hAdd (MeasureTheory.SimpleFunc.integral Î¼ f) (MeasureTheory.SimpleFunc.integral Î½ f))","decl":"theorem integral_add_measure {Î½} (f : Î± â†’â‚› E) (hf : Integrable f (Î¼ + Î½)) :\n    f.integral (Î¼ + Î½) = f.integral Î¼ + f.integral Î½ := by\n  simp_rw [integral_def]\n  refine setToSimpleFunc_add_left'\n    (weightedSMul Î¼) (weightedSMul Î½) (weightedSMul (Î¼ + Î½)) (fun s _ hÎ¼Î½s => ?_) hf\n  rw [lt_top_iff_ne_top, Measure.coe_add, Pi.add_apply, ENNReal.add_ne_top] at hÎ¼Î½s\n  rw [weightedSMul_add_measure _ _ hÎ¼Î½s.1 hÎ¼Î½s.2]\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.norm_eq_integral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœ : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq (Norm.norm f) (MeasureTheory.SimpleFunc.integral Î¼ (MeasureTheory.SimpleFunc.map Norm.norm (MeasureTheory.Lp.simpleFunc.toSimpleFunc f)))","decl":"theorem norm_eq_integral (f : Î± â†’â‚â‚›[Î¼] E) : â€–fâ€– = ((toSimpleFunc f).map norm).integral Î¼ := by\n  rw [norm_eq_sum_mul f, (toSimpleFunc f).map_integral norm (SimpleFunc.integrable f) norm_zero]\n  simp_rw [smul_eq_mul]\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.coe_posPart","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc Real 1 Î¼) x\nâŠ¢ Eq (â†‘(MeasureTheory.L1.SimpleFunc.posPart f)) (MeasureTheory.Lp.posPart â†‘f)","decl":"@[norm_cast]\ntheorem coe_posPart (f : Î± â†’â‚â‚›[Î¼] â„) : (posPart f : Î± â†’â‚[Î¼] â„) = Lp.posPart (f : Î± â†’â‚[Î¼] â„) := rfl\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.coe_negPart","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc Real 1 Î¼) x\nâŠ¢ Eq (â†‘(MeasureTheory.L1.SimpleFunc.negPart f)) (MeasureTheory.Lp.negPart â†‘f)","decl":"@[norm_cast]\ntheorem coe_negPart (f : Î± â†’â‚â‚›[Î¼] â„) : (negPart f : Î± â†’â‚[Î¼] â„) = Lp.negPart (f : Î± â†’â‚[Î¼] â„) := rfl\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.integral_eq_integral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedSpace Real E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.integral f) (MeasureTheory.SimpleFunc.integral Î¼ (MeasureTheory.Lp.simpleFunc.toSimpleFunc f))","decl":"theorem integral_eq_integral (f : Î± â†’â‚â‚›[Î¼] E) : integral f = (toSimpleFunc f).integral Î¼ := rfl\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.integral_eq_lintegral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc Real 1 Î¼) x\nh_pos : (MeasureTheory.ae Î¼).EventuallyLE 0 â‡‘(MeasureTheory.Lp.simpleFunc.toSimpleFunc f)\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.integral f) (MeasureTheory.lintegral Î¼ fun a => ENNReal.ofReal ((MeasureTheory.Lp.simpleFunc.toSimpleFunc f) a)).toReal","decl":"nonrec theorem integral_eq_lintegral {f : Î± â†’â‚â‚›[Î¼] â„} (h_pos : 0 â‰¤áµ[Î¼] toSimpleFunc f) :\n    integral f = ENNReal.toReal (âˆ«â» a, ENNReal.ofReal ((toSimpleFunc f) a) âˆ‚Î¼) := by\n  rw [integral, SimpleFunc.integral_eq_lintegral (SimpleFunc.integrable f) h_pos]\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.integral_eq_setToL1S","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedSpace Real E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.integral f) (MeasureTheory.L1.SimpleFunc.setToL1S (MeasureTheory.weightedSMul Î¼) f)","decl":"theorem integral_eq_setToL1S (f : Î± â†’â‚â‚›[Î¼] E) : integral f = setToL1S (weightedSMul Î¼) f := rfl\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.integral_congr","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedSpace Real E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nh : (MeasureTheory.ae Î¼).EventuallyEq â‡‘(MeasureTheory.Lp.simpleFunc.toSimpleFunc f) â‡‘(MeasureTheory.Lp.simpleFunc.toSimpleFunc g)\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.integral f) (MeasureTheory.L1.SimpleFunc.integral g)","decl":"nonrec theorem integral_congr {f g : Î± â†’â‚â‚›[Î¼] E} (h : toSimpleFunc f =áµ[Î¼] toSimpleFunc g) :\n    integral f = integral g :=\n  SimpleFunc.integral_congr (SimpleFunc.integrable f) h\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.integral_add","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedSpace Real E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.integral (HAdd.hAdd f g)) (HAdd.hAdd (MeasureTheory.L1.SimpleFunc.integral f) (MeasureTheory.L1.SimpleFunc.integral g))","decl":"theorem integral_add (f g : Î± â†’â‚â‚›[Î¼] E) : integral (f + g) = integral f + integral g :=\n  setToL1S_add _ (fun _ _ => weightedSMul_null) weightedSMul_union _ _\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.integral_smul","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\nğ•œ : Type u_4\ninstâœâ´ : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : SMulCommClass Real ğ•œ E\nc : ğ•œ\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.integral (HSMul.hSMul c f)) (HSMul.hSMul c (MeasureTheory.L1.SimpleFunc.integral f))","decl":"theorem integral_smul (c : ğ•œ) (f : Î± â†’â‚â‚›[Î¼] E) : integral (c â€¢ f) = c â€¢ integral f :=\n  setToL1S_smul _ (fun _ _ => weightedSMul_null) weightedSMul_union weightedSMul_smul c f\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.norm_integral_le_norm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedSpace Real E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ LE.le (Norm.norm (MeasureTheory.L1.SimpleFunc.integral f)) (Norm.norm f)","decl":"theorem norm_integral_le_norm (f : Î± â†’â‚â‚›[Î¼] E) : â€–integral fâ€– â‰¤ â€–fâ€– := by\n  rw [integral, norm_eq_integral]\n  exact (toSimpleFunc f).norm_integral_le_integral_norm (SimpleFunc.integrable f)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.norm_Integral_le_one","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedSpace Real E\nâŠ¢ LE.le (Norm.norm (MeasureTheory.L1.SimpleFunc.integralCLM Î± E Î¼)) 1","decl":"theorem norm_Integral_le_one : â€–Integralâ€– â‰¤ 1 :=\n  -- Porting note: Old proof was `LinearMap.mkContinuous_norm_le _ zero_le_one _`\n  LinearMap.mkContinuous_norm_le _ zero_le_one (fun f => by\n    rw [one_mul]\n    exact norm_integral_le_norm f)\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.posPart_toSimpleFunc","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc Real 1 Î¼) x\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq â‡‘(MeasureTheory.Lp.simpleFunc.toSimpleFunc (MeasureTheory.L1.SimpleFunc.posPart f)) â‡‘(MeasureTheory.Lp.simpleFunc.toSimpleFunc f).posPart","decl":"theorem posPart_toSimpleFunc (f : Î± â†’â‚â‚›[Î¼] â„) :\n    toSimpleFunc (posPart f) =áµ[Î¼] (toSimpleFunc f).posPart := by\n  have eq : âˆ€ a, (toSimpleFunc f).posPart a = max ((toSimpleFunc f) a) 0 := fun a => rfl\n  have ae_eq : âˆ€áµ a âˆ‚Î¼, toSimpleFunc (posPart f) a = max ((toSimpleFunc f) a) 0 := by\n    filter_upwards [toSimpleFunc_eq_toFun (posPart f), Lp.coeFn_posPart (f : Î± â†’â‚[Î¼] â„),\n      toSimpleFunc_eq_toFun f] with _ _ hâ‚‚ hâ‚ƒ\n    convert hâ‚‚ using 1\n    -- Porting note: added\n    rw [hâ‚ƒ]\n  refine ae_eq.mono fun a h => ?_\n  rw [h, eq]\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.negPart_toSimpleFunc","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc Real 1 Î¼) x\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq â‡‘(MeasureTheory.Lp.simpleFunc.toSimpleFunc (MeasureTheory.L1.SimpleFunc.negPart f)) â‡‘(MeasureTheory.Lp.simpleFunc.toSimpleFunc f).negPart","decl":"theorem negPart_toSimpleFunc (f : Î± â†’â‚â‚›[Î¼] â„) :\n    toSimpleFunc (negPart f) =áµ[Î¼] (toSimpleFunc f).negPart := by\n  rw [SimpleFunc.negPart, MeasureTheory.SimpleFunc.negPart]\n  filter_upwards [posPart_toSimpleFunc (-f), neg_toSimpleFunc f]\n  intro a hâ‚ hâ‚‚\n  rw [hâ‚]\n  show max _ _ = max _ _\n  rw [hâ‚‚]\n  rfl\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.integral_eq_norm_posPart_sub","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc Real 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.SimpleFunc.integral f) (HSub.hSub (Norm.norm (MeasureTheory.L1.SimpleFunc.posPart f)) (Norm.norm (MeasureTheory.L1.SimpleFunc.negPart f)))","decl":"theorem integral_eq_norm_posPart_sub (f : Î± â†’â‚â‚›[Î¼] â„) : integral f = â€–posPart fâ€– - â€–negPart fâ€– := by\n  -- Convert things in `LÂ¹` to their `SimpleFunc` counterpart\n  have ae_eqâ‚ : (toSimpleFunc f).posPart =áµ[Î¼] (toSimpleFunc (posPart f)).map norm := by\n    filter_upwards [posPart_toSimpleFunc f] with _ h\n    rw [SimpleFunc.map_apply, h]\n    conv_lhs => rw [â† SimpleFunc.posPart_map_norm, SimpleFunc.map_apply]\n  -- Convert things in `LÂ¹` to their `SimpleFunc` counterpart\n  have ae_eqâ‚‚ : (toSimpleFunc f).negPart =áµ[Î¼] (toSimpleFunc (negPart f)).map norm := by\n    filter_upwards [negPart_toSimpleFunc f] with _ h\n    rw [SimpleFunc.map_apply, h]\n    conv_lhs => rw [â† SimpleFunc.negPart_map_norm, SimpleFunc.map_apply]\n  rw [integral, norm_eq_integral, norm_eq_integral, â† SimpleFunc.integral_sub]\n  Â· show (toSimpleFunc f).integral Î¼ =\n      ((toSimpleFunc (posPart f)).map norm - (toSimpleFunc (negPart f)).map norm).integral Î¼\n    apply MeasureTheory.SimpleFunc.integral_congr (SimpleFunc.integrable f)\n    filter_upwards [ae_eqâ‚, ae_eqâ‚‚] with _ hâ‚ hâ‚‚\n    rw [SimpleFunc.sub_apply, â† hâ‚, â† hâ‚‚]\n    exact DFunLike.congr_fun (toSimpleFunc f).posPart_sub_negPart.symm _\n  Â· exact (SimpleFunc.integrable f).pos_part.congr ae_eqâ‚\n  Â· exact (SimpleFunc.integrable f).neg_part.congr ae_eqâ‚‚\n\n"}
{"name":"MeasureTheory.L1.integral_def","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_5\nE : Type u_6\ninstâœÂ² : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nâŠ¢ Eq MeasureTheory.L1.integral â‡‘MeasureTheory.L1.integralCLM","decl":"/-- The Bochner integral in L1 space -/\nirreducible_def integral : (Î± â†’â‚[Î¼] E) â†’ E :=\n  integralCLM (E := E)\n\n"}
{"name":"MeasureTheory.L1.integral_eq","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.integral f) (MeasureTheory.L1.integralCLM f)","decl":"theorem integral_eq (f : Î± â†’â‚[Î¼] E) : integral f = integralCLM (E := E) f := by\n  simp only [integral]\n\n"}
{"name":"MeasureTheory.L1.integral_eq_setToL1","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.integral f) ((MeasureTheory.L1.setToL1 â‹¯) f)","decl":"theorem integral_eq_setToL1 (f : Î± â†’â‚[Î¼] E) :\n    integral f = setToL1 (E := E) (dominatedFinMeasAdditive_weightedSMul Î¼) f := by\n  simp only [integral]; rfl\n\n"}
{"name":"MeasureTheory.L1.SimpleFunc.integral_L1_eq_integral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp.simpleFunc E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.integral â†‘f) (MeasureTheory.L1.SimpleFunc.integral f)","decl":"@[norm_cast]\ntheorem SimpleFunc.integral_L1_eq_integral (f : Î± â†’â‚â‚›[Î¼] E) :\n    L1.integral (f : Î± â†’â‚[Î¼] E) = SimpleFunc.integral f := by\n  simp only [integral, L1.integral]\n  exact setToL1_eq_setToL1SCLM (dominatedFinMeasAdditive_weightedSMul Î¼) f\n\n"}
{"name":"MeasureTheory.L1.integral_zero","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nâŠ¢ Eq (MeasureTheory.L1.integral 0) 0","decl":"@[simp]\ntheorem integral_zero : integral (0 : Î± â†’â‚[Î¼] E) = 0 := by\n  simp only [integral]\n  exact map_zero integralCLM\n\n"}
{"name":"MeasureTheory.L1.integral_add","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.integral (HAdd.hAdd f g)) (HAdd.hAdd (MeasureTheory.L1.integral f) (MeasureTheory.L1.integral g))","decl":"@[integral_simps]\ntheorem integral_add (f g : Î± â†’â‚[Î¼] E) : integral (f + g) = integral f + integral g := by\n  simp only [integral]\n  exact map_add integralCLM f g\n\n"}
{"name":"MeasureTheory.L1.integral_neg","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.integral (Neg.neg f)) (Neg.neg (MeasureTheory.L1.integral f))","decl":"@[integral_simps]\ntheorem integral_neg (f : Î± â†’â‚[Î¼] E) : integral (-f) = -integral f := by\n  simp only [integral]\n  exact map_neg integralCLM f\n\n"}
{"name":"MeasureTheory.L1.integral_sub","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.integral (HSub.hSub f g)) (HSub.hSub (MeasureTheory.L1.integral f) (MeasureTheory.L1.integral g))","decl":"@[integral_simps]\ntheorem integral_sub (f g : Î± â†’â‚[Î¼] E) : integral (f - g) = integral f - integral g := by\n  simp only [integral]\n  exact map_sub integralCLM f g\n\n"}
{"name":"MeasureTheory.L1.integral_smul","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\nğ•œ : Type u_4\ninstâœâµ : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedSpace ğ•œ E\ninstâœÂ¹ : SMulCommClass Real ğ•œ E\ninstâœ : CompleteSpace E\nc : ğ•œ\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.integral (HSMul.hSMul c f)) (HSMul.hSMul c (MeasureTheory.L1.integral f))","decl":"@[integral_simps]\ntheorem integral_smul (c : ğ•œ) (f : Î± â†’â‚[Î¼] E) : integral (c â€¢ f) = c â€¢ integral f := by\n  simp only [integral]\n  show (integralCLM' (E := E) ğ•œ) (c â€¢ f) = c â€¢ (integralCLM' (E := E) ğ•œ) f\n  exact _root_.map_smul (integralCLM' (E := E) ğ•œ) c f\n\n"}
{"name":"MeasureTheory.L1.norm_Integral_le_one","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nâŠ¢ LE.le (Norm.norm MeasureTheory.L1.integralCLM) 1","decl":"theorem norm_Integral_le_one : â€–integralCLM (Î± := Î±) (E := E) (Î¼ := Î¼)â€– â‰¤ 1 :=\n  norm_setToL1_le (dominatedFinMeasAdditive_weightedSMul Î¼) zero_le_one\n\n"}
{"name":"MeasureTheory.L1.nnnorm_Integral_le_one","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nâŠ¢ LE.le (NNNorm.nnnorm MeasureTheory.L1.integralCLM) 1","decl":"theorem nnnorm_Integral_le_one : â€–integralCLM (Î± := Î±) (E := E) (Î¼ := Î¼)â€–â‚Š â‰¤ 1 :=\n  norm_Integral_le_one\n\n"}
{"name":"MeasureTheory.L1.norm_integral_le","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ LE.le (Norm.norm (MeasureTheory.L1.integral f)) (Norm.norm f)","decl":"theorem norm_integral_le (f : Î± â†’â‚[Î¼] E) : â€–integral fâ€– â‰¤ â€–fâ€– :=\n  calc\n    â€–integral fâ€– = â€–integralCLM (E := E) fâ€– := by simp only [integral]\n    _ â‰¤ â€–integralCLM (Î± := Î±) (E := E) (Î¼ := Î¼)â€– * â€–fâ€– := le_opNorm _ _\n    _ â‰¤ 1 * â€–fâ€– := mul_le_mul_of_nonneg_right norm_Integral_le_one <| norm_nonneg _\n    _ = â€–fâ€– := one_mul _\n\n"}
{"name":"MeasureTheory.L1.nnnorm_integral_le","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ LE.le (NNNorm.nnnorm (MeasureTheory.L1.integral f)) (NNNorm.nnnorm f)","decl":"theorem nnnorm_integral_le (f : Î± â†’â‚[Î¼] E) : â€–integral fâ€–â‚Š â‰¤ â€–fâ€–â‚Š :=\n  norm_integral_le f\n\n"}
{"name":"MeasureTheory.L1.continuous_integral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nâŠ¢ Continuous fun f => MeasureTheory.L1.integral f","decl":"@[continuity]\ntheorem continuous_integral : Continuous fun f : Î± â†’â‚[Î¼] E => integral f := by\n  simp only [integral]\n  exact L1.integralCLM.continuous\n\n"}
{"name":"MeasureTheory.L1.integral_eq_norm_posPart_sub","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp Real 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.integral f) (HSub.hSub (Norm.norm (MeasureTheory.Lp.posPart f)) (Norm.norm (MeasureTheory.Lp.negPart f)))","decl":"theorem integral_eq_norm_posPart_sub (f : Î± â†’â‚[Î¼] â„) :\n    integral f = â€–Lp.posPart fâ€– - â€–Lp.negPart fâ€– := by\n  -- Use `isClosed_property` and `isClosed_eq`\n  refine @isClosed_property _ _ _ ((â†‘) : (Î± â†’â‚â‚›[Î¼] â„) â†’ Î± â†’â‚[Î¼] â„)\n      (fun f : Î± â†’â‚[Î¼] â„ => integral f = â€–Lp.posPart fâ€– - â€–Lp.negPart fâ€–)\n      (simpleFunc.denseRange one_ne_top) (isClosed_eq ?_ ?_) ?_ f\n  Â· simp only [integral]\n    exact cont _\n  Â· refine Continuous.sub (continuous_norm.comp Lp.continuous_posPart)\n      (continuous_norm.comp Lp.continuous_negPart)\n  -- Show that the property holds for all simple functions in the `LÂ¹` space.\n  Â· intro s\n    norm_cast\n    exact SimpleFunc.integral_eq_norm_posPart_sub _\n\n"}
{"name":"MeasureTheory.integral_def","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_6\nG : Type u_7\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nxâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ G\nâŠ¢ Eq (MeasureTheory.integral Î¼ f) (dite (CompleteSpace G) (fun x => dite (MeasureTheory.Integrable f Î¼) (fun hf => MeasureTheory.L1.integral (MeasureTheory.Integrable.toL1 f hf)) fun hf => 0) fun x => 0)","decl":"open Classical in\n/-- The Bochner integral -/\nirreducible_def integral {_ : MeasurableSpace Î±} (Î¼ : Measure Î±) (f : Î± â†’ G) : G :=\n  if _ : CompleteSpace G then\n    if hf : Integrable f Î¼ then L1.integral (hf.toL1 f) else 0\n  else 0\n\n"}
{"name":"MeasureTheory.integral_eq","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\nhE : CompleteSpace E\ninstâœ : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => f a) (MeasureTheory.L1.integral (MeasureTheory.Integrable.toL1 f hf))","decl":"theorem integral_eq (f : Î± â†’ E) (hf : Integrable f Î¼) : âˆ« a, f a âˆ‚Î¼ = L1.integral (hf.toL1 f) := by\n  simp [integral, hE, hf]\n\n"}
{"name":"MeasureTheory.integral_eq_setToFun","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\nhE : CompleteSpace E\ninstâœ : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => f a) (MeasureTheory.setToFun Î¼ (MeasureTheory.weightedSMul Î¼) â‹¯ f)","decl":"theorem integral_eq_setToFun (f : Î± â†’ E) :\n    âˆ« a, f a âˆ‚Î¼ = setToFun Î¼ (weightedSMul Î¼) (dominatedFinMeasAdditive_weightedSMul Î¼) f := by\n  simp only [integral, hE, L1.integral]; rfl\n\n"}
{"name":"MeasureTheory.L1.integral_eq_integral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\nhE : CompleteSpace E\ninstâœ : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.L1.integral f) (MeasureTheory.integral Î¼ fun a => â†‘â†‘f a)","decl":"theorem L1.integral_eq_integral (f : Î± â†’â‚[Î¼] E) : L1.integral f = âˆ« a, f a âˆ‚Î¼ := by\n  simp only [integral, L1.integral, integral_eq_setToFun]\n  exact (L1.setToFun_eq_setToL1 (dominatedFinMeasAdditive_weightedSMul Î¼) f).symm\n\n"}
{"name":"MeasureTheory.integral_undef","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ G\nh : Not (MeasureTheory.Integrable f Î¼)\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => f a) 0","decl":"theorem integral_undef {f : Î± â†’ G} (h : Â¬Integrable f Î¼) : âˆ« a, f a âˆ‚Î¼ = 0 := by\n  by_cases hG : CompleteSpace G\n  Â· simp [integral, hG, h]\n  Â· simp [integral, hG]\n\n"}
{"name":"MeasureTheory.Integrable.of_integral_ne_zero","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ G\nh : Ne (MeasureTheory.integral Î¼ fun a => f a) 0\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"theorem Integrable.of_integral_ne_zero {f : Î± â†’ G} (h : âˆ« a, f a âˆ‚Î¼ â‰  0) : Integrable f Î¼ :=\n  Not.imp_symm integral_undef h\n\n"}
{"name":"MeasureTheory.integral_non_aestronglyMeasurable","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ G\nh : Not (MeasureTheory.AEStronglyMeasurable f Î¼)\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => f a) 0","decl":"theorem integral_non_aestronglyMeasurable {f : Î± â†’ G} (h : Â¬AEStronglyMeasurable f Î¼) :\n    âˆ« a, f a âˆ‚Î¼ = 0 :=\n  integral_undef <| not_and_of_not_left _ h\n\n"}
{"name":"MeasureTheory.integral_zero","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => 0) 0","decl":"@[simp]\ntheorem integral_zero : âˆ« _ : Î±, (0 : G) âˆ‚Î¼ = 0 := by\n  by_cases hG : CompleteSpace G\n  Â· simp only [integral, hG, L1.integral]\n    exact setToFun_zero (dominatedFinMeasAdditive_weightedSMul Î¼)\n  Â· simp [integral, hG]\n\n"}
{"name":"MeasureTheory.integral_zero'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ Eq (MeasureTheory.integral Î¼ 0) 0","decl":"@[simp]\ntheorem integral_zero' : integral Î¼ (0 : Î± â†’ G) = 0 :=\n  integral_zero Î± G\n\n"}
{"name":"MeasureTheory.integrable_of_integral_eq_one","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nh : Eq (MeasureTheory.integral Î¼ fun x => f x) 1\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"theorem integrable_of_integral_eq_one {f : Î± â†’ â„} (h : âˆ« x, f x âˆ‚Î¼ = 1) : Integrable f Î¼ :=\n  .of_integral_ne_zero <| h â–¸ one_ne_zero\n\n"}
{"name":"MeasureTheory.integral_add","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ G\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => HAdd.hAdd (f a) (g a)) (HAdd.hAdd (MeasureTheory.integral Î¼ fun a => f a) (MeasureTheory.integral Î¼ fun a => g a))","decl":"theorem integral_add {f g : Î± â†’ G} (hf : Integrable f Î¼) (hg : Integrable g Î¼) :\n    âˆ« a, f a + g a âˆ‚Î¼ = âˆ« a, f a âˆ‚Î¼ + âˆ« a, g a âˆ‚Î¼ := by\n  by_cases hG : CompleteSpace G\n  Â· simp only [integral, hG, L1.integral]\n    exact setToFun_add (dominatedFinMeasAdditive_weightedSMul Î¼) hf hg\n  Â· simp [integral, hG]\n\n"}
{"name":"MeasureTheory.integral_add'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ G\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => HAdd.hAdd f g a) (HAdd.hAdd (MeasureTheory.integral Î¼ fun a => f a) (MeasureTheory.integral Î¼ fun a => g a))","decl":"theorem integral_add' {f g : Î± â†’ G} (hf : Integrable f Î¼) (hg : Integrable g Î¼) :\n    âˆ« a, (f + g) a âˆ‚Î¼ = âˆ« a, f a âˆ‚Î¼ + âˆ« a, g a âˆ‚Î¼ :=\n  integral_add hf hg\n\n"}
{"name":"MeasureTheory.integral_finset_sum","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¹ : Type u_6\ns : Finset Î¹\nf : Î¹ â†’ Î± â†’ G\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ MeasureTheory.Integrable (f i) Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => s.sum fun i => f i a) (s.sum fun i => MeasureTheory.integral Î¼ fun a => f i a)","decl":"theorem integral_finset_sum {Î¹} (s : Finset Î¹) {f : Î¹ â†’ Î± â†’ G} (hf : âˆ€ i âˆˆ s, Integrable (f i) Î¼) :\n    âˆ« a, âˆ‘ i âˆˆ s, f i a âˆ‚Î¼ = âˆ‘ i âˆˆ s, âˆ« a, f i a âˆ‚Î¼ := by\n  by_cases hG : CompleteSpace G\n  Â· simp only [integral, hG, L1.integral]\n    exact setToFun_finset_sum (dominatedFinMeasAdditive_weightedSMul _) s hf\n  Â· simp [integral, hG]\n\n"}
{"name":"MeasureTheory.integral_neg","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ G\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => Neg.neg (f a)) (Neg.neg (MeasureTheory.integral Î¼ fun a => f a))","decl":"@[integral_simps]\ntheorem integral_neg (f : Î± â†’ G) : âˆ« a, -f a âˆ‚Î¼ = -âˆ« a, f a âˆ‚Î¼ := by\n  by_cases hG : CompleteSpace G\n  Â· simp only [integral, hG, L1.integral]\n    exact setToFun_neg (dominatedFinMeasAdditive_weightedSMul Î¼) f\n  Â· simp [integral, hG]\n\n"}
{"name":"MeasureTheory.integral_neg'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ G\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => Neg.neg f a) (Neg.neg (MeasureTheory.integral Î¼ fun a => f a))","decl":"theorem integral_neg' (f : Î± â†’ G) : âˆ« a, (-f) a âˆ‚Î¼ = -âˆ« a, f a âˆ‚Î¼ :=\n  integral_neg f\n\n"}
{"name":"MeasureTheory.integral_sub","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ G\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => HSub.hSub (f a) (g a)) (HSub.hSub (MeasureTheory.integral Î¼ fun a => f a) (MeasureTheory.integral Î¼ fun a => g a))","decl":"theorem integral_sub {f g : Î± â†’ G} (hf : Integrable f Î¼) (hg : Integrable g Î¼) :\n    âˆ« a, f a - g a âˆ‚Î¼ = âˆ« a, f a âˆ‚Î¼ - âˆ« a, g a âˆ‚Î¼ := by\n  by_cases hG : CompleteSpace G\n  Â· simp only [integral, hG, L1.integral]\n    exact setToFun_sub (dominatedFinMeasAdditive_weightedSMul Î¼) hf hg\n  Â· simp [integral, hG]\n\n"}
{"name":"MeasureTheory.integral_sub'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ G\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => HSub.hSub f g a) (HSub.hSub (MeasureTheory.integral Î¼ fun a => f a) (MeasureTheory.integral Î¼ fun a => g a))","decl":"theorem integral_sub' {f g : Î± â†’ G} (hf : Integrable f Î¼) (hg : Integrable g Î¼) :\n    âˆ« a, (f - g) a âˆ‚Î¼ = âˆ« a, f a âˆ‚Î¼ - âˆ« a, g a âˆ‚Î¼ :=\n  integral_sub hf hg\n\n"}
{"name":"MeasureTheory.integral_smul","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nğ•œ : Type u_4\ninstâœâ´ : NontriviallyNormedField ğ•œ\nG : Type u_5\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : SMulCommClass Real ğ•œ G\nc : ğ•œ\nf : Î± â†’ G\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => HSMul.hSMul c (f a)) (HSMul.hSMul c (MeasureTheory.integral Î¼ fun a => f a))","decl":"@[integral_simps]\ntheorem integral_smul [NormedSpace ğ•œ G] [SMulCommClass â„ ğ•œ G] (c : ğ•œ) (f : Î± â†’ G) :\n    âˆ« a, c â€¢ f a âˆ‚Î¼ = c â€¢ âˆ« a, f a âˆ‚Î¼ := by\n  by_cases hG : CompleteSpace G\n  Â· simp only [integral, hG, L1.integral]\n    exact setToFun_smul (dominatedFinMeasAdditive_weightedSMul Î¼) weightedSMul_smul c f\n  Â· simp [integral, hG]\n\n"}
{"name":"MeasureTheory.integral_mul_left","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nL : Type u_6\ninstâœ : RCLike L\nr : L\nf : Î± â†’ L\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => HMul.hMul r (f a)) (HMul.hMul r (MeasureTheory.integral Î¼ fun a => f a))","decl":"theorem integral_mul_left {L : Type*} [RCLike L] (r : L) (f : Î± â†’ L) :\n    âˆ« a, r * f a âˆ‚Î¼ = r * âˆ« a, f a âˆ‚Î¼ :=\n  integral_smul r f\n\n"}
{"name":"MeasureTheory.integral_mul_right","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nL : Type u_6\ninstâœ : RCLike L\nr : L\nf : Î± â†’ L\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => HMul.hMul (f a) r) (HMul.hMul (MeasureTheory.integral Î¼ fun a => f a) r)","decl":"theorem integral_mul_right {L : Type*} [RCLike L] (r : L) (f : Î± â†’ L) :\n    âˆ« a, f a * r âˆ‚Î¼ = (âˆ« a, f a âˆ‚Î¼) * r := by\n  simp only [mul_comm]; exact integral_mul_left r f\n\n"}
{"name":"MeasureTheory.integral_div","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nL : Type u_6\ninstâœ : RCLike L\nr : L\nf : Î± â†’ L\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => HDiv.hDiv (f a) r) (HDiv.hDiv (MeasureTheory.integral Î¼ fun a => f a) r)","decl":"theorem integral_div {L : Type*} [RCLike L] (r : L) (f : Î± â†’ L) :\n    âˆ« a, f a / r âˆ‚Î¼ = (âˆ« a, f a âˆ‚Î¼) / r := by\n  simpa only [â† div_eq_mul_inv] using integral_mul_right râ»Â¹ f\n\n"}
{"name":"MeasureTheory.integral_congr_ae","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ G\nh : (MeasureTheory.ae Î¼).EventuallyEq f g\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => f a) (MeasureTheory.integral Î¼ fun a => g a)","decl":"theorem integral_congr_ae {f g : Î± â†’ G} (h : f =áµ[Î¼] g) : âˆ« a, f a âˆ‚Î¼ = âˆ« a, g a âˆ‚Î¼ := by\n  by_cases hG : CompleteSpace G\n  Â· simp only [integral, hG, L1.integral]\n    exact setToFun_congr_ae (dominatedFinMeasAdditive_weightedSMul Î¼) h\n  Â· simp [integral, hG]\n\n"}
{"name":"MeasureTheory.integral_congr_aeâ‚‚","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_6\nxâœ : MeasurableSpace Î²\nÎ½ : MeasureTheory.Measure Î²\nf g : Î± â†’ Î² â†’ G\nh : Filter.Eventually (fun a => (MeasureTheory.ae Î½).EventuallyEq (f a) (g a)) (MeasureTheory.ae Î¼)\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => MeasureTheory.integral Î½ fun b => f a b) (MeasureTheory.integral Î¼ fun a => MeasureTheory.integral Î½ fun b => g a b)","decl":"lemma integral_congr_aeâ‚‚ {Î² : Type*} {_ : MeasurableSpace Î²} {Î½ : Measure Î²} {f g : Î± â†’ Î² â†’ G}\n    (h : âˆ€áµ a âˆ‚Î¼, f a =áµ[Î½] g a) :\n    âˆ« a, âˆ« b, f a b âˆ‚Î½ âˆ‚Î¼ = âˆ« a, âˆ« b, g a b âˆ‚Î½ âˆ‚Î¼ := by\n  apply integral_congr_ae\n  filter_upwards [h] with _ ha\n  apply integral_congr_ae\n  filter_upwards [ha] with _ hb using hb\n\n-- Porting note: `nolint simpNF` added because simplify fails on left-hand side\n"}
{"name":"MeasureTheory.L1.integral_of_fun_eq_integral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ G\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => â†‘â†‘(MeasureTheory.Integrable.toL1 f hf) a) (MeasureTheory.integral Î¼ fun a => f a)","decl":"@[simp, nolint simpNF]\ntheorem L1.integral_of_fun_eq_integral {f : Î± â†’ G} (hf : Integrable f Î¼) :\n    âˆ« a, (hf.toL1 f) a âˆ‚Î¼ = âˆ« a, f a âˆ‚Î¼ := by\n  by_cases hG : CompleteSpace G\n  Â· simp only [MeasureTheory.integral, hG, L1.integral]\n    exact setToFun_toL1 (dominatedFinMeasAdditive_weightedSMul Î¼) hf\n  Â· simp [MeasureTheory.integral, hG]\n\n"}
{"name":"MeasureTheory.continuous_integral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nâŠ¢ Continuous fun f => MeasureTheory.integral Î¼ fun a => â†‘â†‘f a","decl":"@[continuity]\ntheorem continuous_integral : Continuous fun f : Î± â†’â‚[Î¼] G => âˆ« a, f a âˆ‚Î¼ := by\n  by_cases hG : CompleteSpace G\n  Â· simp only [integral, hG, L1.integral]\n    exact continuous_setToFun (dominatedFinMeasAdditive_weightedSMul Î¼)\n  Â· simp [integral, hG, continuous_const]\n\n"}
{"name":"MeasureTheory.norm_integral_le_lintegral_norm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ G\nâŠ¢ LE.le (Norm.norm (MeasureTheory.integral Î¼ fun a => f a)) (MeasureTheory.lintegral Î¼ fun a => ENNReal.ofReal (Norm.norm (f a))).toReal","decl":"theorem norm_integral_le_lintegral_norm (f : Î± â†’ G) :\n    â€–âˆ« a, f a âˆ‚Î¼â€– â‰¤ ENNReal.toReal (âˆ«â» a, ENNReal.ofReal â€–f aâ€– âˆ‚Î¼) := by\n  by_cases hG : CompleteSpace G\n  Â· by_cases hf : Integrable f Î¼\n    Â· rw [integral_eq f hf, â† Integrable.norm_toL1_eq_lintegral_norm f hf]\n      exact L1.norm_integral_le _\n    Â· rw [integral_undef hf, norm_zero]; exact toReal_nonneg\n  Â· simp [integral, hG]\n\n"}
{"name":"MeasureTheory.enorm_integral_le_lintegral_enorm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ G\nâŠ¢ LE.le (ENorm.enorm (MeasureTheory.integral Î¼ fun a => f a)) (MeasureTheory.lintegral Î¼ fun a => ENorm.enorm (f a))","decl":"theorem enorm_integral_le_lintegral_enorm (f : Î± â†’ G) : â€–âˆ« a, f a âˆ‚Î¼â€–â‚‘ â‰¤ âˆ«â» a, â€–f aâ€–â‚‘ âˆ‚Î¼ := by\n  simp_rw [â† ofReal_norm_eq_enorm]\n  apply ENNReal.ofReal_le_of_le_toReal\n  exact norm_integral_le_lintegral_norm f\n\n"}
{"name":"MeasureTheory.ennnorm_integral_le_lintegral_ennnorm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ G\nâŠ¢ LE.le (ENorm.enorm (MeasureTheory.integral Î¼ fun a => f a)) (MeasureTheory.lintegral Î¼ fun a => ENorm.enorm (f a))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias ennnorm_integral_le_lintegral_ennnorm := enorm_integral_le_lintegral_enorm\n\n"}
{"name":"MeasureTheory.integral_eq_zero_of_ae","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ G\nhf : (MeasureTheory.ae Î¼).EventuallyEq f 0\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => f a) 0","decl":"theorem integral_eq_zero_of_ae {f : Î± â†’ G} (hf : f =áµ[Î¼] 0) : âˆ« a, f a âˆ‚Î¼ = 0 := by\n  simp [integral_congr_ae hf, integral_zero]\n\n"}
{"name":"MeasureTheory.HasFiniteIntegral.tendsto_setIntegral_nhds_zero","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¹ : Type u_6\nf : Î± â†’ G\nhf : MeasureTheory.HasFiniteIntegral f Î¼\nl : Filter Î¹\ns : Î¹ â†’ Set Î±\nhs : Filter.Tendsto (Function.comp (â‡‘Î¼) s) l (nhds 0)\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.integral (Î¼.restrict (s i)) fun x => f x) l (nhds 0)","decl":"/-- If `f` has finite integral, then `âˆ« x in s, f x âˆ‚Î¼` is absolutely continuous in `s`: it tends\nto zero as `Î¼ s` tends to zero. -/\ntheorem HasFiniteIntegral.tendsto_setIntegral_nhds_zero {Î¹} {f : Î± â†’ G}\n    (hf : HasFiniteIntegral f Î¼) {l : Filter Î¹} {s : Î¹ â†’ Set Î±} (hs : Tendsto (Î¼ âˆ˜ s) l (ğ“ 0)) :\n    Tendsto (fun i => âˆ« x in s i, f x âˆ‚Î¼) l (ğ“ 0) := by\n  rw [tendsto_zero_iff_norm_tendsto_zero]\n  simp_rw [â† coe_nnnorm, â† NNReal.coe_zero, NNReal.tendsto_coe, â† ENNReal.tendsto_coe,\n    ENNReal.coe_zero]\n  exact tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds\n    (tendsto_setLIntegral_zero (ne_of_lt hf) hs) (fun i => zero_le _)\n    fun i => enorm_integral_le_lintegral_enorm _\n\n"}
{"name":"MeasureTheory.Integrable.tendsto_setIntegral_nhds_zero","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¹ : Type u_6\nf : Î± â†’ G\nhf : MeasureTheory.Integrable f Î¼\nl : Filter Î¹\ns : Î¹ â†’ Set Î±\nhs : Filter.Tendsto (Function.comp (â‡‘Î¼) s) l (nhds 0)\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.integral (Î¼.restrict (s i)) fun x => f x) l (nhds 0)","decl":"/-- If `f` is integrable, then `âˆ« x in s, f x âˆ‚Î¼` is absolutely continuous in `s`: it tends\nto zero as `Î¼ s` tends to zero. -/\ntheorem Integrable.tendsto_setIntegral_nhds_zero {Î¹} {f : Î± â†’ G} (hf : Integrable f Î¼)\n    {l : Filter Î¹} {s : Î¹ â†’ Set Î±} (hs : Tendsto (Î¼ âˆ˜ s) l (ğ“ 0)) :\n    Tendsto (fun i => âˆ« x in s i, f x âˆ‚Î¼) l (ğ“ 0) :=\n  hf.2.tendsto_setIntegral_nhds_zero hs\n\n"}
{"name":"MeasureTheory.tendsto_integral_of_L1","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¹ : Type u_6\nf : Î± â†’ G\nhfi : MeasureTheory.Integrable f Î¼\nF : Î¹ â†’ Î± â†’ G\nl : Filter Î¹\nhFi : Filter.Eventually (fun i => MeasureTheory.Integrable (F i) Î¼) l\nhF : Filter.Tendsto (fun i => MeasureTheory.lintegral Î¼ fun x => ENorm.enorm (HSub.hSub (F i x) (f x))) l (nhds 0)\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.integral Î¼ fun x => F i x) l (nhds (MeasureTheory.integral Î¼ fun x => f x))","decl":"/-- If `F i â†’ f` in `L1`, then `âˆ« x, F i x âˆ‚Î¼ â†’ âˆ« x, f x âˆ‚Î¼`. -/\ntheorem tendsto_integral_of_L1 {Î¹} (f : Î± â†’ G) (hfi : Integrable f Î¼) {F : Î¹ â†’ Î± â†’ G} {l : Filter Î¹}\n    (hFi : âˆ€á¶  i in l, Integrable (F i) Î¼)\n    (hF : Tendsto (fun i => âˆ«â» x, â€–F i x - f xâ€–â‚‘ âˆ‚Î¼) l (ğ“ 0)) :\n    Tendsto (fun i => âˆ« x, F i x âˆ‚Î¼) l (ğ“ <| âˆ« x, f x âˆ‚Î¼) := by\n  by_cases hG : CompleteSpace G\n  Â· simp only [integral, hG, L1.integral]\n    exact tendsto_setToFun_of_L1 (dominatedFinMeasAdditive_weightedSMul Î¼) f hfi hFi hF\n  Â· simp [integral, hG, tendsto_const_nhds]\n\n"}
{"name":"MeasureTheory.tendsto_integral_of_L1'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¹ : Type u_6\nf : Î± â†’ G\nhfi : MeasureTheory.Integrable f Î¼\nF : Î¹ â†’ Î± â†’ G\nl : Filter Î¹\nhFi : Filter.Eventually (fun i => MeasureTheory.Integrable (F i) Î¼) l\nhF : Filter.Tendsto (fun i => MeasureTheory.eLpNorm (HSub.hSub (F i) f) 1 Î¼) l (nhds 0)\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.integral Î¼ fun x => F i x) l (nhds (MeasureTheory.integral Î¼ fun x => f x))","decl":"/-- If `F i â†’ f` in `L1`, then `âˆ« x, F i x âˆ‚Î¼ â†’ âˆ« x, f x âˆ‚Î¼`. -/\nlemma tendsto_integral_of_L1' {Î¹} (f : Î± â†’ G) (hfi : Integrable f Î¼) {F : Î¹ â†’ Î± â†’ G} {l : Filter Î¹}\n    (hFi : âˆ€á¶  i in l, Integrable (F i) Î¼) (hF : Tendsto (fun i â†¦ eLpNorm (F i - f) 1 Î¼) l (ğ“ 0)) :\n    Tendsto (fun i â†¦ âˆ« x, F i x âˆ‚Î¼) l (ğ“ (âˆ« x, f x âˆ‚Î¼)) := by\n  refine tendsto_integral_of_L1 f hfi hFi ?_\n  simp_rw [eLpNorm_one_eq_lintegral_enorm, Pi.sub_apply] at hF\n  exact hF\n\n"}
{"name":"MeasureTheory.tendsto_setIntegral_of_L1","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¹ : Type u_6\nf : Î± â†’ G\nhfi : MeasureTheory.Integrable f Î¼\nF : Î¹ â†’ Î± â†’ G\nl : Filter Î¹\nhFi : Filter.Eventually (fun i => MeasureTheory.Integrable (F i) Î¼) l\nhF : Filter.Tendsto (fun i => MeasureTheory.lintegral Î¼ fun x => ENorm.enorm (HSub.hSub (F i x) (f x))) l (nhds 0)\ns : Set Î±\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.integral (Î¼.restrict s) fun x => F i x) l (nhds (MeasureTheory.integral (Î¼.restrict s) fun x => f x))","decl":"/-- If `F i â†’ f` in `L1`, then `âˆ« x in s, F i x âˆ‚Î¼ â†’ âˆ« x in s, f x âˆ‚Î¼`. -/\nlemma tendsto_setIntegral_of_L1 {Î¹} (f : Î± â†’ G) (hfi : Integrable f Î¼) {F : Î¹ â†’ Î± â†’ G}\n    {l : Filter Î¹}\n    (hFi : âˆ€á¶  i in l, Integrable (F i) Î¼) (hF : Tendsto (fun i â†¦ âˆ«â» x, â€–F i x - f xâ€–â‚‘ âˆ‚Î¼) l (ğ“ 0))\n    (s : Set Î±) :\n    Tendsto (fun i â†¦ âˆ« x in s, F i x âˆ‚Î¼) l (ğ“ (âˆ« x in s, f x âˆ‚Î¼)) := by\n  refine tendsto_integral_of_L1 f hfi.restrict ?_ ?_\n  Â· filter_upwards [hFi] with i hi using hi.restrict\n  Â· simp_rw [â† eLpNorm_one_eq_lintegral_enorm] at hF âŠ¢\n    exact tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds hF (fun _ â†¦ zero_le')\n      (fun _ â†¦ eLpNorm_mono_measure _ Measure.restrict_le_self)\n\n"}
{"name":"MeasureTheory.tendsto_setIntegral_of_L1'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ¹ : Type u_6\nf : Î± â†’ G\nhfi : MeasureTheory.Integrable f Î¼\nF : Î¹ â†’ Î± â†’ G\nl : Filter Î¹\nhFi : Filter.Eventually (fun i => MeasureTheory.Integrable (F i) Î¼) l\nhF : Filter.Tendsto (fun i => MeasureTheory.eLpNorm (HSub.hSub (F i) f) 1 Î¼) l (nhds 0)\ns : Set Î±\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.integral (Î¼.restrict s) fun x => F i x) l (nhds (MeasureTheory.integral (Î¼.restrict s) fun x => f x))","decl":"/-- If `F i â†’ f` in `L1`, then `âˆ« x in s, F i x âˆ‚Î¼ â†’ âˆ« x in s, f x âˆ‚Î¼`. -/\nlemma tendsto_setIntegral_of_L1' {Î¹} (f : Î± â†’ G) (hfi : Integrable f Î¼) {F : Î¹ â†’ Î± â†’ G}\n    {l : Filter Î¹}\n    (hFi : âˆ€á¶  i in l, Integrable (F i) Î¼) (hF : Tendsto (fun i â†¦ eLpNorm (F i - f) 1 Î¼) l (ğ“ 0))\n    (s : Set Î±) :\n    Tendsto (fun i â†¦ âˆ« x in s, F i x âˆ‚Î¼) l (ğ“ (âˆ« x in s, f x âˆ‚Î¼)) := by\n  refine tendsto_setIntegral_of_L1 f hfi hFi ?_ s\n  simp_rw [eLpNorm_one_eq_lintegral_enorm, Pi.sub_apply] at hF\n  exact hF\n\n"}
{"name":"MeasureTheory.continuousWithinAt_of_dominated","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nX : Type u_6\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : FirstCountableTopology X\nF : X â†’ Î± â†’ G\nxâ‚€ : X\nbound : Î± â†’ Real\ns : Set X\nhF_meas : Filter.Eventually (fun x => MeasureTheory.AEStronglyMeasurable (F x) Î¼) (nhdsWithin xâ‚€ s)\nh_bound : Filter.Eventually (fun x => Filter.Eventually (fun a => LE.le (Norm.norm (F x a)) (bound a)) (MeasureTheory.ae Î¼)) (nhdsWithin xâ‚€ s)\nbound_integrable : MeasureTheory.Integrable bound Î¼\nh_cont : Filter.Eventually (fun a => ContinuousWithinAt (fun x => F x a) s xâ‚€) (MeasureTheory.ae Î¼)\nâŠ¢ ContinuousWithinAt (fun x => MeasureTheory.integral Î¼ fun a => F x a) s xâ‚€","decl":"theorem continuousWithinAt_of_dominated {F : X â†’ Î± â†’ G} {xâ‚€ : X} {bound : Î± â†’ â„} {s : Set X}\n    (hF_meas : âˆ€á¶  x in ğ“[s] xâ‚€, AEStronglyMeasurable (F x) Î¼)\n    (h_bound : âˆ€á¶  x in ğ“[s] xâ‚€, âˆ€áµ a âˆ‚Î¼, â€–F x aâ€– â‰¤ bound a) (bound_integrable : Integrable bound Î¼)\n    (h_cont : âˆ€áµ a âˆ‚Î¼, ContinuousWithinAt (fun x => F x a) s xâ‚€) :\n    ContinuousWithinAt (fun x => âˆ« a, F x a âˆ‚Î¼) s xâ‚€ := by\n  by_cases hG : CompleteSpace G\n  Â· simp only [integral, hG, L1.integral]\n    exact continuousWithinAt_setToFun_of_dominated (dominatedFinMeasAdditive_weightedSMul Î¼)\n      hF_meas h_bound bound_integrable h_cont\n  Â· simp [integral, hG, continuousWithinAt_const]\n\n"}
{"name":"MeasureTheory.continuousAt_of_dominated","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nX : Type u_6\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : FirstCountableTopology X\nF : X â†’ Î± â†’ G\nxâ‚€ : X\nbound : Î± â†’ Real\nhF_meas : Filter.Eventually (fun x => MeasureTheory.AEStronglyMeasurable (F x) Î¼) (nhds xâ‚€)\nh_bound : Filter.Eventually (fun x => Filter.Eventually (fun a => LE.le (Norm.norm (F x a)) (bound a)) (MeasureTheory.ae Î¼)) (nhds xâ‚€)\nbound_integrable : MeasureTheory.Integrable bound Î¼\nh_cont : Filter.Eventually (fun a => ContinuousAt (fun x => F x a) xâ‚€) (MeasureTheory.ae Î¼)\nâŠ¢ ContinuousAt (fun x => MeasureTheory.integral Î¼ fun a => F x a) xâ‚€","decl":"theorem continuousAt_of_dominated {F : X â†’ Î± â†’ G} {xâ‚€ : X} {bound : Î± â†’ â„}\n    (hF_meas : âˆ€á¶  x in ğ“ xâ‚€, AEStronglyMeasurable (F x) Î¼)\n    (h_bound : âˆ€á¶  x in ğ“ xâ‚€, âˆ€áµ a âˆ‚Î¼, â€–F x aâ€– â‰¤ bound a) (bound_integrable : Integrable bound Î¼)\n    (h_cont : âˆ€áµ a âˆ‚Î¼, ContinuousAt (fun x => F x a) xâ‚€) :\n    ContinuousAt (fun x => âˆ« a, F x a âˆ‚Î¼) xâ‚€ := by\n  by_cases hG : CompleteSpace G\n  Â· simp only [integral, hG, L1.integral]\n    exact continuousAt_setToFun_of_dominated (dominatedFinMeasAdditive_weightedSMul Î¼)\n      hF_meas h_bound bound_integrable h_cont\n  Â· simp [integral, hG, continuousAt_const]\n\n"}
{"name":"MeasureTheory.continuousOn_of_dominated","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nX : Type u_6\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : FirstCountableTopology X\nF : X â†’ Î± â†’ G\nbound : Î± â†’ Real\ns : Set X\nhF_meas : âˆ€ (x : X), Membership.mem s x â†’ MeasureTheory.AEStronglyMeasurable (F x) Î¼\nh_bound : âˆ€ (x : X), Membership.mem s x â†’ Filter.Eventually (fun a => LE.le (Norm.norm (F x a)) (bound a)) (MeasureTheory.ae Î¼)\nbound_integrable : MeasureTheory.Integrable bound Î¼\nh_cont : Filter.Eventually (fun a => ContinuousOn (fun x => F x a) s) (MeasureTheory.ae Î¼)\nâŠ¢ ContinuousOn (fun x => MeasureTheory.integral Î¼ fun a => F x a) s","decl":"theorem continuousOn_of_dominated {F : X â†’ Î± â†’ G} {bound : Î± â†’ â„} {s : Set X}\n    (hF_meas : âˆ€ x âˆˆ s, AEStronglyMeasurable (F x) Î¼)\n    (h_bound : âˆ€ x âˆˆ s, âˆ€áµ a âˆ‚Î¼, â€–F x aâ€– â‰¤ bound a) (bound_integrable : Integrable bound Î¼)\n    (h_cont : âˆ€áµ a âˆ‚Î¼, ContinuousOn (fun x => F x a) s) :\n    ContinuousOn (fun x => âˆ« a, F x a âˆ‚Î¼) s := by\n  by_cases hG : CompleteSpace G\n  Â· simp only [integral, hG, L1.integral]\n    exact continuousOn_setToFun_of_dominated (dominatedFinMeasAdditive_weightedSMul Î¼)\n      hF_meas h_bound bound_integrable h_cont\n  Â· simp [integral, hG, continuousOn_const]\n\n"}
{"name":"MeasureTheory.continuous_of_dominated","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nX : Type u_6\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : FirstCountableTopology X\nF : X â†’ Î± â†’ G\nbound : Î± â†’ Real\nhF_meas : âˆ€ (x : X), MeasureTheory.AEStronglyMeasurable (F x) Î¼\nh_bound : âˆ€ (x : X), Filter.Eventually (fun a => LE.le (Norm.norm (F x a)) (bound a)) (MeasureTheory.ae Î¼)\nbound_integrable : MeasureTheory.Integrable bound Î¼\nh_cont : Filter.Eventually (fun a => Continuous fun x => F x a) (MeasureTheory.ae Î¼)\nâŠ¢ Continuous fun x => MeasureTheory.integral Î¼ fun a => F x a","decl":"theorem continuous_of_dominated {F : X â†’ Î± â†’ G} {bound : Î± â†’ â„}\n    (hF_meas : âˆ€ x, AEStronglyMeasurable (F x) Î¼) (h_bound : âˆ€ x, âˆ€áµ a âˆ‚Î¼, â€–F x aâ€– â‰¤ bound a)\n    (bound_integrable : Integrable bound Î¼) (h_cont : âˆ€áµ a âˆ‚Î¼, Continuous fun x => F x a) :\n    Continuous fun x => âˆ« a, F x a âˆ‚Î¼ := by\n  by_cases hG : CompleteSpace G\n  Â· simp only [integral, hG, L1.integral]\n    exact continuous_setToFun_of_dominated (dominatedFinMeasAdditive_weightedSMul Î¼)\n      hF_meas h_bound bound_integrable h_cont\n  Â· simp [integral, hG, continuous_const]\n\n"}
{"name":"MeasureTheory.integral_eq_lintegral_pos_part_sub_lintegral_neg_part","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => f a) (HSub.hSub (MeasureTheory.lintegral Î¼ fun a => ENNReal.ofReal (f a)).toReal (MeasureTheory.lintegral Î¼ fun a => ENNReal.ofReal (Neg.neg (f a))).toReal)","decl":"/-- The Bochner integral of a real-valued function `f : Î± â†’ â„` is the difference between the\n  integral of the positive part of `f` and the integral of the negative part of `f`. -/\ntheorem integral_eq_lintegral_pos_part_sub_lintegral_neg_part {f : Î± â†’ â„} (hf : Integrable f Î¼) :\n    âˆ« a, f a âˆ‚Î¼ =\n      ENNReal.toReal (âˆ«â» a, .ofReal (f a) âˆ‚Î¼) - ENNReal.toReal (âˆ«â» a, .ofReal (-f a) âˆ‚Î¼) := by\n  let fâ‚ := hf.toL1 f\n  -- Go to the `LÂ¹` space\n  have eqâ‚ : ENNReal.toReal (âˆ«â» a, ENNReal.ofReal (f a) âˆ‚Î¼) = â€–Lp.posPart fâ‚â€– := by\n    rw [L1.norm_def]\n    congr 1\n    apply lintegral_congr_ae\n    filter_upwards [Lp.coeFn_posPart fâ‚, hf.coeFn_toL1] with _ hâ‚ hâ‚‚\n    rw [hâ‚, hâ‚‚, ENNReal.ofReal]\n    congr 1\n    apply NNReal.eq\n    rw [Real.nnnorm_of_nonneg (le_max_right _ _)]\n    rw [Real.coe_toNNReal', NNReal.coe_mk]\n  -- Go to the `LÂ¹` space\n  have eqâ‚‚ : ENNReal.toReal (âˆ«â» a, ENNReal.ofReal (-f a) âˆ‚Î¼) = â€–Lp.negPart fâ‚â€– := by\n    rw [L1.norm_def]\n    congr 1\n    apply lintegral_congr_ae\n    filter_upwards [Lp.coeFn_negPart fâ‚, hf.coeFn_toL1] with _ hâ‚ hâ‚‚\n    rw [hâ‚, hâ‚‚, ENNReal.ofReal]\n    congr 1\n    apply NNReal.eq\n    simp only [Real.coe_toNNReal', coe_nnnorm, nnnorm_neg]\n    rw [Real.norm_of_nonpos (min_le_right _ _), â† max_neg_neg, neg_zero]\n  rw [eqâ‚, eqâ‚‚, integral, dif_pos, dif_pos]\n  exact L1.integral_eq_norm_posPart_sub _\n\n"}
{"name":"MeasureTheory.integral_eq_lintegral_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nhfm : MeasureTheory.AEStronglyMeasurable f Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => f a) (MeasureTheory.lintegral Î¼ fun a => ENNReal.ofReal (f a)).toReal","decl":"theorem integral_eq_lintegral_of_nonneg_ae {f : Î± â†’ â„} (hf : 0 â‰¤áµ[Î¼] f)\n    (hfm : AEStronglyMeasurable f Î¼) :\n    âˆ« a, f a âˆ‚Î¼ = ENNReal.toReal (âˆ«â» a, ENNReal.ofReal (f a) âˆ‚Î¼) := by\n  by_cases hfi : Integrable f Î¼\n  Â· rw [integral_eq_lintegral_pos_part_sub_lintegral_neg_part hfi]\n    have h_min : âˆ«â» a, ENNReal.ofReal (-f a) âˆ‚Î¼ = 0 := by\n      rw [lintegral_eq_zero_iff']\n      Â· refine hf.mono ?_\n        simp only [Pi.zero_apply]\n        intro a h\n        simp only [h, neg_nonpos, ofReal_eq_zero]\n      Â· exact measurable_ofReal.comp_aemeasurable hfm.aemeasurable.neg\n    rw [h_min, zero_toReal, _root_.sub_zero]\n  Â· rw [integral_undef hfi]\n    simp_rw [Integrable, hfm, hasFiniteIntegral_iff_norm, lt_top_iff_ne_top, Ne, true_and,\n      Classical.not_not] at hfi\n    have : âˆ«â» a : Î±, ENNReal.ofReal (f a) âˆ‚Î¼ = âˆ«â» a, ENNReal.ofReal â€–f aâ€– âˆ‚Î¼ := by\n      refine lintegral_congr_ae (hf.mono fun a h => ?_)\n      dsimp only\n      rw [Real.norm_eq_abs, abs_of_nonneg h]\n    rw [this, hfi]; rfl\n\n"}
{"name":"MeasureTheory.integral_norm_eq_lintegral_enorm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nP : Type u_7\ninstâœ : NormedAddCommGroup P\nf : Î± â†’ P\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => Norm.norm (f x)) (MeasureTheory.lintegral Î¼ fun x => ENorm.enorm (f x)).toReal","decl":"theorem integral_norm_eq_lintegral_enorm {P : Type*} [NormedAddCommGroup P] {f : Î± â†’ P}\n    (hf : AEStronglyMeasurable f Î¼) : âˆ« x, â€–f xâ€– âˆ‚Î¼ = (âˆ«â» x, â€–f xâ€–â‚‘ âˆ‚Î¼).toReal := by\n  rw [integral_eq_lintegral_of_nonneg_ae _ hf.norm]\n  Â· simp_rw [ofReal_norm_eq_enorm]\n  Â· filter_upwards; simp_rw [Pi.zero_apply, norm_nonneg, imp_true_iff]\n\n"}
{"name":"MeasureTheory.integral_norm_eq_lintegral_nnnorm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nP : Type u_7\ninstâœ : NormedAddCommGroup P\nf : Î± â†’ P\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => Norm.norm (f x)) (MeasureTheory.lintegral Î¼ fun x => ENorm.enorm (f x)).toReal","decl":"@[deprecated (since := \"2025-01-21\")]\nalias integral_norm_eq_lintegral_nnnorm := integral_norm_eq_lintegral_enorm\n\n"}
{"name":"MeasureTheory.ofReal_integral_norm_eq_lintegral_enorm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nP : Type u_7\ninstâœ : NormedAddCommGroup P\nf : Î± â†’ P\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (ENNReal.ofReal (MeasureTheory.integral Î¼ fun x => Norm.norm (f x))) (MeasureTheory.lintegral Î¼ fun x => ENorm.enorm (f x))","decl":"theorem ofReal_integral_norm_eq_lintegral_enorm {P : Type*} [NormedAddCommGroup P] {f : Î± â†’ P}\n    (hf : Integrable f Î¼) : ENNReal.ofReal (âˆ« x, â€–f xâ€– âˆ‚Î¼) = âˆ«â» x, â€–f xâ€–â‚‘ âˆ‚Î¼ := by\n  rw [integral_norm_eq_lintegral_enorm hf.aestronglyMeasurable, ENNReal.ofReal_toReal]\n  exact lt_top_iff_ne_top.mp (hasFiniteIntegral_iff_enorm.mpr hf.2)\n\n"}
{"name":"MeasureTheory.ofReal_integral_norm_eq_lintegral_nnnorm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nP : Type u_7\ninstâœ : NormedAddCommGroup P\nf : Î± â†’ P\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (ENNReal.ofReal (MeasureTheory.integral Î¼ fun x => Norm.norm (f x))) (MeasureTheory.lintegral Î¼ fun x => ENorm.enorm (f x))","decl":"@[deprecated (since := \"2025-01-21\")]\nalias ofReal_integral_norm_eq_lintegral_nnnorm := ofReal_integral_norm_eq_lintegral_enorm\n\n"}
{"name":"MeasureTheory.integral_eq_integral_pos_part_sub_integral_neg_part","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => f a) (HSub.hSub (MeasureTheory.integral Î¼ fun a => â†‘(f a).toNNReal) (MeasureTheory.integral Î¼ fun a => â†‘(Neg.neg (f a)).toNNReal))","decl":"theorem integral_eq_integral_pos_part_sub_integral_neg_part {f : Î± â†’ â„} (hf : Integrable f Î¼) :\n    âˆ« a, f a âˆ‚Î¼ = âˆ« a, (Real.toNNReal (f a) : â„) âˆ‚Î¼ - âˆ« a, (Real.toNNReal (-f a) : â„) âˆ‚Î¼ := by\n  rw [â† integral_sub hf.real_toNNReal]\n  Â· simp\n  Â· exact hf.neg.real_toNNReal\n\n"}
{"name":"MeasureTheory.integral_nonneg_of_ae","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nâŠ¢ LE.le 0 (MeasureTheory.integral Î¼ fun a => f a)","decl":"theorem integral_nonneg_of_ae {f : Î± â†’ â„} (hf : 0 â‰¤áµ[Î¼] f) : 0 â‰¤ âˆ« a, f a âˆ‚Î¼ := by\n  have A : CompleteSpace â„ := by infer_instance\n  simp only [integral_def, A, L1.integral_def, dite_true]\n  exact setToFun_nonneg (dominatedFinMeasAdditive_weightedSMul Î¼)\n    (fun s _ _ => weightedSMul_nonneg s) hf\n\n"}
{"name":"MeasureTheory.lintegral_coe_eq_integral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ NNReal\nhfi : MeasureTheory.Integrable (fun x => â†‘(f x)) Î¼\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun a => â†‘(f a)) (ENNReal.ofReal (MeasureTheory.integral Î¼ fun a => â†‘(f a)))","decl":"theorem lintegral_coe_eq_integral (f : Î± â†’ â„â‰¥0) (hfi : Integrable (fun x => (f x : â„)) Î¼) :\n    âˆ«â» a, f a âˆ‚Î¼ = ENNReal.ofReal (âˆ« a, f a âˆ‚Î¼) := by\n  simp_rw [integral_eq_lintegral_of_nonneg_ae (Eventually.of_forall fun x => (f x).coe_nonneg)\n      hfi.aestronglyMeasurable, â† ENNReal.coe_nnreal_eq]\n  rw [ENNReal.ofReal_toReal]\n  rw [â† lt_top_iff_ne_top]\n  convert hfi.hasFiniteIntegral\n  -- Porting note: `convert` no longer unfolds `HasFiniteIntegral`\n  simp_rw [hasFiniteIntegral_iff_enorm, NNReal.enorm_eq]\n\n"}
{"name":"MeasureTheory.ofReal_integral_eq_lintegral_ofReal","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhfi : MeasureTheory.Integrable f Î¼\nf_nn : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nâŠ¢ Eq (ENNReal.ofReal (MeasureTheory.integral Î¼ fun x => f x)) (MeasureTheory.lintegral Î¼ fun x => ENNReal.ofReal (f x))","decl":"theorem ofReal_integral_eq_lintegral_ofReal {f : Î± â†’ â„} (hfi : Integrable f Î¼) (f_nn : 0 â‰¤áµ[Î¼] f) :\n    ENNReal.ofReal (âˆ« x, f x âˆ‚Î¼) = âˆ«â» x, ENNReal.ofReal (f x) âˆ‚Î¼ := by\n  have : f =áµ[Î¼] (â€–f Â·â€–) := f_nn.mono fun _x hx â†¦ (abs_of_nonneg hx).symm\n  simp_rw [integral_congr_ae this, ofReal_integral_norm_eq_lintegral_enorm hfi,\n    â† ofReal_norm_eq_enorm]\n  exact lintegral_congr_ae (this.symm.fun_comp ENNReal.ofReal)\n\n"}
{"name":"MeasureTheory.integral_toReal","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhfm : AEMeasurable f Î¼\nhf : Filter.Eventually (fun x => LT.lt (f x) Top.top) (MeasureTheory.ae Î¼)\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => (f a).toReal) (MeasureTheory.lintegral Î¼ fun a => f a).toReal","decl":"theorem integral_toReal {f : Î± â†’ â„â‰¥0âˆ} (hfm : AEMeasurable f Î¼) (hf : âˆ€áµ x âˆ‚Î¼, f x < âˆ) :\n    âˆ« a, (f a).toReal âˆ‚Î¼ = (âˆ«â» a, f a âˆ‚Î¼).toReal := by\n  rw [integral_eq_lintegral_of_nonneg_ae _ hfm.ennreal_toReal.aestronglyMeasurable,\n    lintegral_congr_ae (ofReal_toReal_ae_eq hf)]\n  exact Eventually.of_forall fun x => ENNReal.toReal_nonneg\n\n"}
{"name":"MeasureTheory.lintegral_coe_le_coe_iff_integral_le","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ NNReal\nhfi : MeasureTheory.Integrable (fun x => â†‘(f x)) Î¼\nb : NNReal\nâŠ¢ Iff (LE.le (MeasureTheory.lintegral Î¼ fun a => â†‘(f a)) â†‘b) (LE.le (MeasureTheory.integral Î¼ fun a => â†‘(f a)) â†‘b)","decl":"theorem lintegral_coe_le_coe_iff_integral_le {f : Î± â†’ â„â‰¥0} (hfi : Integrable (fun x => (f x : â„)) Î¼)\n    {b : â„â‰¥0} : âˆ«â» a, f a âˆ‚Î¼ â‰¤ b â†” âˆ« a, (f a : â„) âˆ‚Î¼ â‰¤ b := by\n  rw [lintegral_coe_eq_integral f hfi, ENNReal.ofReal, ENNReal.coe_le_coe,\n    Real.toNNReal_le_iff_le_coe]\n\n"}
{"name":"MeasureTheory.integral_coe_le_of_lintegral_coe_le","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ NNReal\nb : NNReal\nh : LE.le (MeasureTheory.lintegral Î¼ fun a => â†‘(f a)) â†‘b\nâŠ¢ LE.le (MeasureTheory.integral Î¼ fun a => â†‘(f a)) â†‘b","decl":"theorem integral_coe_le_of_lintegral_coe_le {f : Î± â†’ â„â‰¥0} {b : â„â‰¥0} (h : âˆ«â» a, f a âˆ‚Î¼ â‰¤ b) :\n    âˆ« a, (f a : â„) âˆ‚Î¼ â‰¤ b := by\n  by_cases hf : Integrable (fun a => (f a : â„)) Î¼\n  Â· exact (lintegral_coe_le_coe_iff_integral_le hf).1 h\n  Â· rw [integral_undef hf]; exact b.2\n\n"}
{"name":"MeasureTheory.integral_nonneg","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : LE.le 0 f\nâŠ¢ LE.le 0 (MeasureTheory.integral Î¼ fun a => f a)","decl":"theorem integral_nonneg {f : Î± â†’ â„} (hf : 0 â‰¤ f) : 0 â‰¤ âˆ« a, f a âˆ‚Î¼ :=\n  integral_nonneg_of_ae <| Eventually.of_forall hf\n\n"}
{"name":"MeasureTheory.integral_nonpos_of_ae","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : (MeasureTheory.ae Î¼).EventuallyLE f 0\nâŠ¢ LE.le (MeasureTheory.integral Î¼ fun a => f a) 0","decl":"theorem integral_nonpos_of_ae {f : Î± â†’ â„} (hf : f â‰¤áµ[Î¼] 0) : âˆ« a, f a âˆ‚Î¼ â‰¤ 0 := by\n  have hf : 0 â‰¤áµ[Î¼] -f := hf.mono fun a h => by rwa [Pi.neg_apply, Pi.zero_apply, neg_nonneg]\n  have : 0 â‰¤ âˆ« a, -f a âˆ‚Î¼ := integral_nonneg_of_ae hf\n  rwa [integral_neg, neg_nonneg] at this\n\n"}
{"name":"MeasureTheory.integral_nonpos","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : LE.le f 0\nâŠ¢ LE.le (MeasureTheory.integral Î¼ fun a => f a) 0","decl":"theorem integral_nonpos {f : Î± â†’ â„} (hf : f â‰¤ 0) : âˆ« a, f a âˆ‚Î¼ â‰¤ 0 :=\n  integral_nonpos_of_ae <| Eventually.of_forall hf\n\n"}
{"name":"MeasureTheory.integral_eq_zero_iff_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nhfi : MeasureTheory.Integrable f Î¼\nâŠ¢ Iff (Eq (MeasureTheory.integral Î¼ fun x => f x) 0) ((MeasureTheory.ae Î¼).EventuallyEq f 0)","decl":"theorem integral_eq_zero_iff_of_nonneg_ae {f : Î± â†’ â„} (hf : 0 â‰¤áµ[Î¼] f) (hfi : Integrable f Î¼) :\n    âˆ« x, f x âˆ‚Î¼ = 0 â†” f =áµ[Î¼] 0 := by\n  simp_rw [integral_eq_lintegral_of_nonneg_ae hf hfi.1, ENNReal.toReal_eq_zero_iff,\n    â† ENNReal.not_lt_top, â† hasFiniteIntegral_iff_ofReal hf, hfi.2, not_true_eq_false, or_false]\n  -- Porting note: split into parts, to make `rw` and `simp` work\n  rw [lintegral_eq_zero_iff']\n  Â· rw [â† hf.le_iff_eq, Filter.EventuallyEq, Filter.EventuallyLE]\n    simp only [Pi.zero_apply, ofReal_eq_zero]\n  Â· exact (ENNReal.measurable_ofReal.comp_aemeasurable hfi.1.aemeasurable)\n\n"}
{"name":"MeasureTheory.integral_eq_zero_iff_of_nonneg","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : LE.le 0 f\nhfi : MeasureTheory.Integrable f Î¼\nâŠ¢ Iff (Eq (MeasureTheory.integral Î¼ fun x => f x) 0) ((MeasureTheory.ae Î¼).EventuallyEq f 0)","decl":"theorem integral_eq_zero_iff_of_nonneg {f : Î± â†’ â„} (hf : 0 â‰¤ f) (hfi : Integrable f Î¼) :\n    âˆ« x, f x âˆ‚Î¼ = 0 â†” f =áµ[Î¼] 0 :=\n  integral_eq_zero_iff_of_nonneg_ae (Eventually.of_forall hf) hfi\n\n"}
{"name":"MeasureTheory.integral_eq_iff_of_ae_le","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ Real\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nhfg : (MeasureTheory.ae Î¼).EventuallyLE f g\nâŠ¢ Iff (Eq (MeasureTheory.integral Î¼ fun a => f a) (MeasureTheory.integral Î¼ fun a => g a)) ((MeasureTheory.ae Î¼).EventuallyEq f g)","decl":"lemma integral_eq_iff_of_ae_le {f g : Î± â†’ â„}\n    (hf : Integrable f Î¼) (hg : Integrable g Î¼) (hfg : f â‰¤áµ[Î¼] g) :\n    âˆ« a, f a âˆ‚Î¼ = âˆ« a, g a âˆ‚Î¼ â†” f =áµ[Î¼] g := by\n  refine âŸ¨fun h_le â†¦ EventuallyEq.symm ?_, fun h â†¦ integral_congr_ae hâŸ©\n  rw [â† sub_ae_eq_zero,\n    â† integral_eq_zero_iff_of_nonneg_ae ((sub_nonneg_ae _ _).mpr hfg) (hg.sub hf)]\n  simpa [Pi.sub_apply, integral_sub hg hf, sub_eq_zero, eq_comm]\n\n"}
{"name":"MeasureTheory.integral_pos_iff_support_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nhfi : MeasureTheory.Integrable f Î¼\nâŠ¢ Iff (LT.lt 0 (MeasureTheory.integral Î¼ fun x => f x)) (LT.lt 0 (Î¼ (Function.support f)))","decl":"theorem integral_pos_iff_support_of_nonneg_ae {f : Î± â†’ â„} (hf : 0 â‰¤áµ[Î¼] f) (hfi : Integrable f Î¼) :\n    (0 < âˆ« x, f x âˆ‚Î¼) â†” 0 < Î¼ (Function.support f) := by\n  simp_rw [(integral_nonneg_of_ae hf).lt_iff_ne, pos_iff_ne_zero, Ne, @eq_comm â„ 0,\n    integral_eq_zero_iff_of_nonneg_ae hf hfi, Filter.EventuallyEq, ae_iff, Pi.zero_apply,\n    Function.support]\n\n"}
{"name":"MeasureTheory.integral_pos_iff_support_of_nonneg","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : LE.le 0 f\nhfi : MeasureTheory.Integrable f Î¼\nâŠ¢ Iff (LT.lt 0 (MeasureTheory.integral Î¼ fun x => f x)) (LT.lt 0 (Î¼ (Function.support f)))","decl":"theorem integral_pos_iff_support_of_nonneg {f : Î± â†’ â„} (hf : 0 â‰¤ f) (hfi : Integrable f Î¼) :\n    (0 < âˆ« x, f x âˆ‚Î¼) â†” 0 < Î¼ (Function.support f) :=\n  integral_pos_iff_support_of_nonneg_ae (Eventually.of_forall hf) hfi\n\n"}
{"name":"MeasureTheory.integral_exp_pos","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhÎ¼ : NeZero Î¼\nhf : MeasureTheory.Integrable (fun x => Real.exp (f x)) Î¼\nâŠ¢ LT.lt 0 (MeasureTheory.integral Î¼ fun x => Real.exp (f x))","decl":"lemma integral_exp_pos {Î¼ : Measure Î±} {f : Î± â†’ â„} [hÎ¼ : NeZero Î¼]\n    (hf : Integrable (fun x â†¦ Real.exp (f x)) Î¼) :\n    0 < âˆ« x, Real.exp (f x) âˆ‚Î¼ := by\n  rw [integral_pos_iff_support_of_nonneg (fun x â†¦ (Real.exp_pos _).le) hf]\n  suffices (Function.support fun x â†¦ Real.exp (f x)) = Set.univ by simp [this, hÎ¼.out]\n  ext1 x\n  simp only [Function.mem_support, ne_eq, (Real.exp_pos _).ne', not_false_eq_true, Set.mem_univ]\n\n"}
{"name":"MeasureTheory.integral_tendsto_of_tendsto_of_monotone","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Nat â†’ Î± â†’ Real\nF : Î± â†’ Real\nhf : âˆ€ (n : Nat), MeasureTheory.Integrable (f n) Î¼\nhF : MeasureTheory.Integrable F Î¼\nh_mono : Filter.Eventually (fun x => Monotone fun n => f n x) (MeasureTheory.ae Î¼)\nh_tendsto : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.integral Î¼ fun x => f n x) Filter.atTop (nhds (MeasureTheory.integral Î¼ fun x => F x))","decl":"/-- Monotone convergence theorem for real-valued functions and Bochner integrals -/\nlemma integral_tendsto_of_tendsto_of_monotone {Î¼ : Measure Î±} {f : â„• â†’ Î± â†’ â„} {F : Î± â†’ â„}\n    (hf : âˆ€ n, Integrable (f n) Î¼) (hF : Integrable F Î¼) (h_mono : âˆ€áµ x âˆ‚Î¼, Monotone fun n â†¦ f n x)\n    (h_tendsto : âˆ€áµ x âˆ‚Î¼, Tendsto (fun n â†¦ f n x) atTop (ğ“ (F x))) :\n    Tendsto (fun n â†¦ âˆ« x, f n x âˆ‚Î¼) atTop (ğ“ (âˆ« x, F x âˆ‚Î¼)) := by\n  -- switch from the Bochner to the Lebesgue integral\n  let f' := fun n x â†¦ f n x - f 0 x\n  have hf'_nonneg : âˆ€áµ x âˆ‚Î¼, âˆ€ n, 0 â‰¤ f' n x := by\n    filter_upwards [h_mono] with a ha n\n    simp [f', ha (zero_le n)]\n  have hf'_meas : âˆ€ n, Integrable (f' n) Î¼ := fun n â†¦ (hf n).sub (hf 0)\n  suffices Tendsto (fun n â†¦ âˆ« x, f' n x âˆ‚Î¼) atTop (ğ“ (âˆ« x, (F - f 0) x âˆ‚Î¼)) by\n    simp_rw [f', integral_sub (hf _) (hf _), integral_sub' hF (hf 0),\n      tendsto_sub_const_iff] at this\n    exact this\n  have hF_ge : 0 â‰¤áµ[Î¼] fun x â†¦ (F - f 0) x := by\n    filter_upwards [h_tendsto, h_mono] with x hx_tendsto hx_mono\n    simp only [Pi.zero_apply, Pi.sub_apply, sub_nonneg]\n    exact ge_of_tendsto' hx_tendsto (fun n â†¦ hx_mono (zero_le _))\n  rw [ae_all_iff] at hf'_nonneg\n  simp_rw [integral_eq_lintegral_of_nonneg_ae (hf'_nonneg _) (hf'_meas _).1]\n  rw [integral_eq_lintegral_of_nonneg_ae hF_ge (hF.1.sub (hf 0).1)]\n  have h_cont := ENNReal.continuousAt_toReal (x := âˆ«â» a, ENNReal.ofReal ((F - f 0) a) âˆ‚Î¼) ?_\n  swap\n  Â· rw [â† ofReal_integral_eq_lintegral_ofReal (hF.sub (hf 0)) hF_ge]\n    exact ENNReal.ofReal_ne_top\n  refine h_cont.tendsto.comp ?_\n  -- use the result for the Lebesgue integral\n  refine lintegral_tendsto_of_tendsto_of_monotone ?_ ?_ ?_\n  Â· exact fun n â†¦ ((hf n).sub (hf 0)).aemeasurable.ennreal_ofReal\n  Â· filter_upwards [h_mono] with x hx n m hnm\n    refine ENNReal.ofReal_le_ofReal ?_\n    simp only [f', tsub_le_iff_right, sub_add_cancel]\n    exact hx hnm\n  Â· filter_upwards [h_tendsto] with x hx\n    refine (ENNReal.continuous_ofReal.tendsto _).comp ?_\n    simp only [Pi.sub_apply]\n    exact Tendsto.sub hx tendsto_const_nhds\n\n"}
{"name":"MeasureTheory.integral_tendsto_of_tendsto_of_antitone","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Nat â†’ Î± â†’ Real\nF : Î± â†’ Real\nhf : âˆ€ (n : Nat), MeasureTheory.Integrable (f n) Î¼\nhF : MeasureTheory.Integrable F Î¼\nh_mono : Filter.Eventually (fun x => Antitone fun n => f n x) (MeasureTheory.ae Î¼)\nh_tendsto : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (F x))) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.integral Î¼ fun x => f n x) Filter.atTop (nhds (MeasureTheory.integral Î¼ fun x => F x))","decl":"/-- Monotone convergence theorem for real-valued functions and Bochner integrals -/\nlemma integral_tendsto_of_tendsto_of_antitone {Î¼ : Measure Î±} {f : â„• â†’ Î± â†’ â„} {F : Î± â†’ â„}\n    (hf : âˆ€ n, Integrable (f n) Î¼) (hF : Integrable F Î¼) (h_mono : âˆ€áµ x âˆ‚Î¼, Antitone fun n â†¦ f n x)\n    (h_tendsto : âˆ€áµ x âˆ‚Î¼, Tendsto (fun n â†¦ f n x) atTop (ğ“ (F x))) :\n    Tendsto (fun n â†¦ âˆ« x, f n x âˆ‚Î¼) atTop (ğ“ (âˆ« x, F x âˆ‚Î¼)) := by\n  suffices Tendsto (fun n â†¦ âˆ« x, -f n x âˆ‚Î¼) atTop (ğ“ (âˆ« x, -F x âˆ‚Î¼)) by\n    suffices Tendsto (fun n â†¦ âˆ« x, - -f n x âˆ‚Î¼) atTop (ğ“ (âˆ« x, - -F x âˆ‚Î¼)) by\n      simpa [neg_neg] using this\n    convert this.neg <;> rw [integral_neg]\n  refine integral_tendsto_of_tendsto_of_monotone (fun n â†¦ (hf n).neg) hF.neg ?_ ?_\n  Â· filter_upwards [h_mono] with x hx n m hnm using neg_le_neg_iff.mpr <| hx hnm\n  Â· filter_upwards [h_tendsto] with x hx using hx.neg\n\n"}
{"name":"MeasureTheory.tendsto_of_integral_tendsto_of_monotone","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Nat â†’ Î± â†’ Real\nF : Î± â†’ Real\nhf_int : âˆ€ (n : Nat), MeasureTheory.Integrable (f n) Î¼\nhF_int : MeasureTheory.Integrable F Î¼\nhf_tendsto : Filter.Tendsto (fun i => MeasureTheory.integral Î¼ fun a => f i a) Filter.atTop (nhds (MeasureTheory.integral Î¼ fun a => F a))\nhf_mono : Filter.Eventually (fun a => Monotone fun i => f i a) (MeasureTheory.ae Î¼)\nhf_bound : Filter.Eventually (fun a => âˆ€ (i : Nat), LE.le (f i a) (F a)) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Eventually (fun a => Filter.Tendsto (fun i => f i a) Filter.atTop (nhds (F a))) (MeasureTheory.ae Î¼)","decl":"/-- If a monotone sequence of functions has an upper bound and the sequence of integrals of these\nfunctions tends to the integral of the upper bound, then the sequence of functions converges\nalmost everywhere to the upper bound. -/\nlemma tendsto_of_integral_tendsto_of_monotone {Î¼ : Measure Î±} {f : â„• â†’ Î± â†’ â„} {F : Î± â†’ â„}\n    (hf_int : âˆ€ n, Integrable (f n) Î¼) (hF_int : Integrable F Î¼)\n    (hf_tendsto : Tendsto (fun i â†¦ âˆ« a, f i a âˆ‚Î¼) atTop (ğ“ (âˆ« a, F a âˆ‚Î¼)))\n    (hf_mono : âˆ€áµ a âˆ‚Î¼, Monotone (fun i â†¦ f i a))\n    (hf_bound : âˆ€áµ a âˆ‚Î¼, âˆ€ i, f i a â‰¤ F a) :\n    âˆ€áµ a âˆ‚Î¼, Tendsto (fun i â†¦ f i a) atTop (ğ“ (F a)) := by\n  -- reduce to the `â„â‰¥0âˆ` case\n  let f' : â„• â†’ Î± â†’ â„â‰¥0âˆ := fun n a â†¦ ENNReal.ofReal (f n a - f 0 a)\n  let F' : Î± â†’ â„â‰¥0âˆ := fun a â†¦ ENNReal.ofReal (F a - f 0 a)\n  have hf'_int_eq : âˆ€ i, âˆ«â» a, f' i a âˆ‚Î¼ = ENNReal.ofReal (âˆ« a, f i a âˆ‚Î¼ - âˆ« a, f 0 a âˆ‚Î¼) := by\n    intro i\n    unfold f'\n    rw [â† ofReal_integral_eq_lintegral_ofReal, integral_sub (hf_int i) (hf_int 0)]\n    Â· exact (hf_int i).sub (hf_int 0)\n    Â· filter_upwards [hf_mono] with a h_mono\n      simp [h_mono (zero_le i)]\n  have hF'_int_eq : âˆ«â» a, F' a âˆ‚Î¼ = ENNReal.ofReal (âˆ« a, F a âˆ‚Î¼ - âˆ« a, f 0 a âˆ‚Î¼) := by\n    unfold F'\n    rw [â† ofReal_integral_eq_lintegral_ofReal, integral_sub hF_int (hf_int 0)]\n    Â· exact hF_int.sub (hf_int 0)\n    Â· filter_upwards [hf_bound] with a h_bound\n      simp [h_bound 0]\n  have h_tendsto : Tendsto (fun i â†¦ âˆ«â» a, f' i a âˆ‚Î¼) atTop (ğ“ (âˆ«â» a, F' a âˆ‚Î¼)) := by\n    simp_rw [hf'_int_eq, hF'_int_eq]\n    refine (ENNReal.continuous_ofReal.tendsto _).comp ?_\n    rwa [tendsto_sub_const_iff]\n  have h_mono : âˆ€áµ a âˆ‚Î¼, Monotone (fun i â†¦ f' i a) := by\n    filter_upwards [hf_mono] with a ha_mono i j hij\n    refine ENNReal.ofReal_le_ofReal ?_\n    simp [ha_mono hij]\n  have h_bound : âˆ€áµ a âˆ‚Î¼, âˆ€ i, f' i a â‰¤ F' a := by\n    filter_upwards [hf_bound] with a ha_bound i\n    refine ENNReal.ofReal_le_ofReal ?_\n    simp only [tsub_le_iff_right, sub_add_cancel, ha_bound i]\n  -- use the corresponding lemma for `â„â‰¥0âˆ`\n  have h := tendsto_of_lintegral_tendsto_of_monotone ?_ h_tendsto h_mono h_bound ?_\n  rotate_left\n  Â· exact (hF_int.1.aemeasurable.sub (hf_int 0).1.aemeasurable).ennreal_ofReal\n  Â· exact ((lintegral_ofReal_le_lintegral_enorm _).trans_lt (hF_int.sub (hf_int 0)).2).ne\n  filter_upwards [h, hf_mono, hf_bound] with a ha ha_mono ha_bound\n  have h1 : (fun i â†¦ f i a) = fun i â†¦ (f' i a).toReal + f 0 a := by\n    unfold f'\n    ext i\n    rw [ENNReal.toReal_ofReal]\n    Â· abel\n    Â· simp [ha_mono (zero_le i)]\n  have h2 : F a = (F' a).toReal + f 0 a := by\n    unfold F'\n    rw [ENNReal.toReal_ofReal]\n    Â· abel\n    Â· simp [ha_bound 0]\n  rw [h1, h2]\n  refine Filter.Tendsto.add ?_ tendsto_const_nhds\n  exact (ENNReal.continuousAt_toReal ENNReal.ofReal_ne_top).tendsto.comp ha\n\n"}
{"name":"MeasureTheory.tendsto_of_integral_tendsto_of_antitone","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Nat â†’ Î± â†’ Real\nF : Î± â†’ Real\nhf_int : âˆ€ (n : Nat), MeasureTheory.Integrable (f n) Î¼\nhF_int : MeasureTheory.Integrable F Î¼\nhf_tendsto : Filter.Tendsto (fun i => MeasureTheory.integral Î¼ fun a => f i a) Filter.atTop (nhds (MeasureTheory.integral Î¼ fun a => F a))\nhf_mono : Filter.Eventually (fun a => Antitone fun i => f i a) (MeasureTheory.ae Î¼)\nhf_bound : Filter.Eventually (fun a => âˆ€ (i : Nat), LE.le (F a) (f i a)) (MeasureTheory.ae Î¼)\nâŠ¢ Filter.Eventually (fun a => Filter.Tendsto (fun i => f i a) Filter.atTop (nhds (F a))) (MeasureTheory.ae Î¼)","decl":"/-- If an antitone sequence of functions has a lower bound and the sequence of integrals of these\nfunctions tends to the integral of the lower bound, then the sequence of functions converges\nalmost everywhere to the lower bound. -/\nlemma tendsto_of_integral_tendsto_of_antitone {Î¼ : Measure Î±} {f : â„• â†’ Î± â†’ â„} {F : Î± â†’ â„}\n    (hf_int : âˆ€ n, Integrable (f n) Î¼) (hF_int : Integrable F Î¼)\n    (hf_tendsto : Tendsto (fun i â†¦ âˆ« a, f i a âˆ‚Î¼) atTop (ğ“ (âˆ« a, F a âˆ‚Î¼)))\n    (hf_mono : âˆ€áµ a âˆ‚Î¼, Antitone (fun i â†¦ f i a))\n    (hf_bound : âˆ€áµ a âˆ‚Î¼, âˆ€ i, F a â‰¤ f i a) :\n    âˆ€áµ a âˆ‚Î¼, Tendsto (fun i â†¦ f i a) atTop (ğ“ (F a)) := by\n  let f' : â„• â†’ Î± â†’ â„ := fun i a â†¦ - f i a\n  let F' : Î± â†’ â„ := fun a â†¦ - F a\n  suffices âˆ€áµ a âˆ‚Î¼, Tendsto (fun i â†¦ f' i a) atTop (ğ“ (F' a)) by\n    filter_upwards [this] with a ha_tendsto\n    convert ha_tendsto.neg\n    Â· simp [f']\n    Â· simp [F']\n  refine tendsto_of_integral_tendsto_of_monotone (fun n â†¦ (hf_int n).neg) hF_int.neg ?_ ?_ ?_\n  Â· convert hf_tendsto.neg\n    Â· rw [integral_neg]\n    Â· rw [integral_neg]\n  Â· filter_upwards [hf_mono] with a ha i j hij\n    simp [f', ha hij]\n  Â· filter_upwards [hf_bound] with a ha i\n    simp [f', F', ha i]\n\n"}
{"name":"MeasureTheory.L1.norm_eq_integral_norm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nH : Type u_7\ninstâœ : NormedAddCommGroup H\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp H 1 Î¼) x\nâŠ¢ Eq (Norm.norm f) (MeasureTheory.integral Î¼ fun a => Norm.norm (â†‘â†‘f a))","decl":"theorem L1.norm_eq_integral_norm (f : Î± â†’â‚[Î¼] H) : â€–fâ€– = âˆ« a, â€–f aâ€– âˆ‚Î¼ := by\n  simp only [eLpNorm, eLpNorm'_eq_lintegral_enorm, ENNReal.one_toReal, ENNReal.rpow_one,\n    Lp.norm_def, if_false, ENNReal.one_ne_top, one_ne_zero, _root_.div_one]\n  rw [integral_eq_lintegral_of_nonneg_ae (Eventually.of_forall (by simp [norm_nonneg]))\n      (Lp.aestronglyMeasurable f).norm]\n  simp [ofReal_norm_eq_enorm]\n\n"}
{"name":"MeasureTheory.L1.dist_eq_integral_dist","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nH : Type u_7\ninstâœ : NormedAddCommGroup H\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp H 1 Î¼) x\nâŠ¢ Eq (Dist.dist f g) (MeasureTheory.integral Î¼ fun a => Dist.dist (â†‘â†‘f a) (â†‘â†‘g a))","decl":"theorem L1.dist_eq_integral_dist (f g : Î± â†’â‚[Î¼] H) : dist f g = âˆ« a, dist (f a) (g a) âˆ‚Î¼ := by\n  simp only [dist_eq_norm, L1.norm_eq_integral_norm]\n  exact integral_congr_ae <| (Lp.coeFn_sub _ _).fun_comp norm\n\n"}
{"name":"MeasureTheory.L1.norm_of_fun_eq_integral_norm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nH : Type u_7\ninstâœ : NormedAddCommGroup H\nf : Î± â†’ H\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (Norm.norm (MeasureTheory.Integrable.toL1 f hf)) (MeasureTheory.integral Î¼ fun a => Norm.norm (f a))","decl":"theorem L1.norm_of_fun_eq_integral_norm {f : Î± â†’ H} (hf : Integrable f Î¼) :\n    â€–hf.toL1 fâ€– = âˆ« a, â€–f aâ€– âˆ‚Î¼ := by\n  rw [L1.norm_eq_integral_norm]\n  exact integral_congr_ae <| hf.coeFn_toL1.fun_comp _\n\n"}
{"name":"MeasureTheory.Memâ„’p.eLpNorm_eq_integral_rpow_norm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nH : Type u_7\ninstâœ : NormedAddCommGroup H\nf : Î± â†’ H\np : ENNReal\nhp1 : Ne p 0\nhp2 : Ne p Top.top\nhf : MeasureTheory.Memâ„’p f p Î¼\nâŠ¢ Eq (MeasureTheory.eLpNorm f p Î¼) (ENNReal.ofReal (HPow.hPow (MeasureTheory.integral Î¼ fun a => HPow.hPow (Norm.norm (f a)) p.toReal) (Inv.inv p.toReal)))","decl":"theorem Memâ„’p.eLpNorm_eq_integral_rpow_norm {f : Î± â†’ H} {p : â„â‰¥0âˆ} (hp1 : p â‰  0) (hp2 : p â‰  âˆ)\n    (hf : Memâ„’p f p Î¼) :\n    eLpNorm f p Î¼ = ENNReal.ofReal ((âˆ« a, â€–f aâ€– ^ p.toReal âˆ‚Î¼) ^ p.toRealâ»Â¹) := by\n  have A : âˆ«â» a : Î±, ENNReal.ofReal (â€–f aâ€– ^ p.toReal) âˆ‚Î¼ = âˆ«â» a : Î±, â€–f aâ€–â‚‘ ^ p.toReal âˆ‚Î¼ := by\n    simp_rw [â† ofReal_rpow_of_nonneg (norm_nonneg _) toReal_nonneg, ofReal_norm_eq_enorm]\n  simp only [eLpNorm_eq_lintegral_rpow_enorm hp1 hp2, one_div]\n  rw [integral_eq_lintegral_of_nonneg_ae]; rotate_left\n  Â· exact ae_of_all _ fun x => by positivity\n  Â· exact (hf.aestronglyMeasurable.norm.aemeasurable.pow_const _).aestronglyMeasurable\n  rw [A, â† ofReal_rpow_of_nonneg toReal_nonneg (inv_nonneg.2 toReal_nonneg), ofReal_toReal]\n  exact (lintegral_rpow_enorm_lt_top_of_eLpNorm_lt_top hp1 hp2 hf.2).ne\n\n"}
{"name":"MeasureTheory.integral_mono_ae","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ Real\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nh : (MeasureTheory.ae Î¼).EventuallyLE f g\nâŠ¢ LE.le (MeasureTheory.integral Î¼ fun a => f a) (MeasureTheory.integral Î¼ fun a => g a)","decl":"theorem integral_mono_ae {f g : Î± â†’ â„} (hf : Integrable f Î¼) (hg : Integrable g Î¼) (h : f â‰¤áµ[Î¼] g) :\n    âˆ« a, f a âˆ‚Î¼ â‰¤ âˆ« a, g a âˆ‚Î¼ := by\n  have A : CompleteSpace â„ := by infer_instance\n  simp only [integral, A, L1.integral]\n  exact setToFun_mono (dominatedFinMeasAdditive_weightedSMul Î¼)\n    (fun s _ _ => weightedSMul_nonneg s) hf hg h\n\n"}
{"name":"MeasureTheory.integral_mono","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ Real\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nh : LE.le f g\nâŠ¢ LE.le (MeasureTheory.integral Î¼ fun a => f a) (MeasureTheory.integral Î¼ fun a => g a)","decl":"@[gcongr, mono]\ntheorem integral_mono {f g : Î± â†’ â„} (hf : Integrable f Î¼) (hg : Integrable g Î¼) (h : f â‰¤ g) :\n    âˆ« a, f a âˆ‚Î¼ â‰¤ âˆ« a, g a âˆ‚Î¼ :=\n  integral_mono_ae hf hg <| Eventually.of_forall h\n\n"}
{"name":"MeasureTheory.integral_mono_of_nonneg","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ Real\nhf : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nhgi : MeasureTheory.Integrable g Î¼\nh : (MeasureTheory.ae Î¼).EventuallyLE f g\nâŠ¢ LE.le (MeasureTheory.integral Î¼ fun a => f a) (MeasureTheory.integral Î¼ fun a => g a)","decl":"theorem integral_mono_of_nonneg {f g : Î± â†’ â„} (hf : 0 â‰¤áµ[Î¼] f) (hgi : Integrable g Î¼)\n    (h : f â‰¤áµ[Î¼] g) : âˆ« a, f a âˆ‚Î¼ â‰¤ âˆ« a, g a âˆ‚Î¼ := by\n  by_cases hfm : AEStronglyMeasurable f Î¼\n  Â· refine integral_mono_ae âŸ¨hfm, ?_âŸ© hgi h\n    refine hgi.hasFiniteIntegral.mono <| h.mp <| hf.mono fun x hf hfg => ?_\n    simpa [abs_of_nonneg hf, abs_of_nonneg (le_trans hf hfg)]\n  Â· rw [integral_non_aestronglyMeasurable hfm]\n    exact integral_nonneg_of_ae (hf.trans h)\n\n"}
{"name":"MeasureTheory.integral_mono_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nÎ½ : MeasureTheory.Measure Î±\nhle : LE.le Î¼ Î½\nhf : (MeasureTheory.ae Î½).EventuallyLE 0 f\nhfi : MeasureTheory.Integrable f Î½\nâŠ¢ LE.le (MeasureTheory.integral Î¼ fun a => f a) (MeasureTheory.integral Î½ fun a => f a)","decl":"theorem integral_mono_measure {f : Î± â†’ â„} {Î½} (hle : Î¼ â‰¤ Î½) (hf : 0 â‰¤áµ[Î½] f)\n    (hfi : Integrable f Î½) : âˆ« a, f a âˆ‚Î¼ â‰¤ âˆ« a, f a âˆ‚Î½ := by\n  have hfi' : Integrable f Î¼ := hfi.mono_measure hle\n  have hf' : 0 â‰¤áµ[Î¼] f := hle.absolutelyContinuous hf\n  rw [integral_eq_lintegral_of_nonneg_ae hf' hfi'.1, integral_eq_lintegral_of_nonneg_ae hf hfi.1]\n  refine ENNReal.toReal_mono ?_ (lintegral_mono' hle le_rfl)\n  exact ((hasFiniteIntegral_iff_ofReal hf).1 hfi.2).ne\n\n"}
{"name":"MeasureTheory.norm_integral_le_integral_norm","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ G\nâŠ¢ LE.le (Norm.norm (MeasureTheory.integral Î¼ fun a => f a)) (MeasureTheory.integral Î¼ fun a => Norm.norm (f a))","decl":"theorem norm_integral_le_integral_norm (f : Î± â†’ G) : â€–âˆ« a, f a âˆ‚Î¼â€– â‰¤ âˆ« a, â€–f aâ€– âˆ‚Î¼ := by\n  have le_ae : âˆ€áµ a âˆ‚Î¼, 0 â‰¤ â€–f aâ€– := Eventually.of_forall fun a => norm_nonneg _\n  by_cases h : AEStronglyMeasurable f Î¼\n  Â· calc\n      â€–âˆ« a, f a âˆ‚Î¼â€– â‰¤ ENNReal.toReal (âˆ«â» a, ENNReal.ofReal â€–f aâ€– âˆ‚Î¼) :=\n        norm_integral_le_lintegral_norm _\n      _ = âˆ« a, â€–f aâ€– âˆ‚Î¼ := (integral_eq_lintegral_of_nonneg_ae le_ae <| h.norm).symm\n  Â· rw [integral_non_aestronglyMeasurable h, norm_zero]\n    exact integral_nonneg_of_ae le_ae\n\n"}
{"name":"MeasureTheory.abs_integral_le_integral_abs","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nâŠ¢ LE.le (abs (MeasureTheory.integral Î¼ fun a => f a)) (MeasureTheory.integral Î¼ fun a => abs (f a))","decl":"lemma abs_integral_le_integral_abs {f : Î± â†’ â„} : |âˆ« a, f a âˆ‚Î¼| â‰¤ âˆ« a, |f a| âˆ‚Î¼ :=\n  norm_integral_le_integral_norm f\n\n"}
{"name":"MeasureTheory.norm_integral_le_of_norm_le","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ G\ng : Î± â†’ Real\nhg : MeasureTheory.Integrable g Î¼\nh : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) (g x)) (MeasureTheory.ae Î¼)\nâŠ¢ LE.le (Norm.norm (MeasureTheory.integral Î¼ fun x => f x)) (MeasureTheory.integral Î¼ fun x => g x)","decl":"theorem norm_integral_le_of_norm_le {f : Î± â†’ G} {g : Î± â†’ â„} (hg : Integrable g Î¼)\n    (h : âˆ€áµ x âˆ‚Î¼, â€–f xâ€– â‰¤ g x) : â€–âˆ« x, f x âˆ‚Î¼â€– â‰¤ âˆ« x, g x âˆ‚Î¼ :=\n  calc\n    â€–âˆ« x, f x âˆ‚Î¼â€– â‰¤ âˆ« x, â€–f xâ€– âˆ‚Î¼ := norm_integral_le_integral_norm f\n    _ â‰¤ âˆ« x, g x âˆ‚Î¼ := integral_mono_of_nonneg (Eventually.of_forall fun _ => norm_nonneg _) hg h\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_eq_integral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\nhE : CompleteSpace E\ninstâœ : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : MeasureTheory.SimpleFunc Î± E\nhfi : MeasureTheory.Integrable (â‡‘f) Î¼\nâŠ¢ Eq (MeasureTheory.SimpleFunc.integral Î¼ f) (MeasureTheory.integral Î¼ fun x => f x)","decl":"theorem SimpleFunc.integral_eq_integral (f : Î± â†’â‚› E) (hfi : Integrable f Î¼) :\n    f.integral Î¼ = âˆ« x, f x âˆ‚Î¼ := by\n  rw [MeasureTheory.integral_eq f hfi, â† L1.SimpleFunc.toLp_one_eq_toL1,\n    L1.SimpleFunc.integral_L1_eq_integral, L1.SimpleFunc.integral_eq_integral]\n  exact SimpleFunc.integral_congr hfi (Lp.simpleFunc.toSimpleFunc_toLp _ _).symm\n\n"}
{"name":"MeasureTheory.SimpleFunc.integral_eq_sum","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\nhE : CompleteSpace E\ninstâœ : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : MeasureTheory.SimpleFunc Î± E\nhfi : MeasureTheory.Integrable (â‡‘f) Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f x) (f.range.sum fun x => HSMul.hSMul (Î¼ (Set.preimage (â‡‘f) (Singleton.singleton x))).toReal x)","decl":"theorem SimpleFunc.integral_eq_sum (f : Î± â†’â‚› E) (hfi : Integrable f Î¼) :\n    âˆ« x, f x âˆ‚Î¼ = âˆ‘ x âˆˆ f.range, ENNReal.toReal (Î¼ (f â»Â¹' {x})) â€¢ x := by\n  rw [â† f.integral_eq_integral hfi, SimpleFunc.integral, â† SimpleFunc.integral_eq]; rfl\n\n"}
{"name":"MeasureTheory.integral_const","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\nhE : CompleteSpace E\ninstâœ : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nc : E\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => c) (HSMul.hSMul (Î¼ Set.univ).toReal c)","decl":"@[simp]\ntheorem integral_const (c : E) : âˆ« _ : Î±, c âˆ‚Î¼ = (Î¼ univ).toReal â€¢ c := by\n  by_cases hÎ¼ : IsFiniteMeasure Î¼\n  Â· simp only [integral, hE, L1.integral]\n    exact setToFun_const (dominatedFinMeasAdditive_weightedSMul _) _\n  by_cases hc : c = 0\n  Â· simp [hc, integral_zero]\n  Â· simp [integral_undef, (integrable_const_iff_isFiniteMeasure hc).not.2 hÎ¼, *]\n    simp only [isFiniteMeasure_iff, not_lt, top_le_iff] at hÎ¼\n    simp [hÎ¼]\n\n"}
{"name":"MeasureTheory.norm_integral_le_of_norm_le_const","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nf : Î± â†’ G\nC : Real\nh : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) C) (MeasureTheory.ae Î¼)\nâŠ¢ LE.le (Norm.norm (MeasureTheory.integral Î¼ fun x => f x)) (HMul.hMul C (Î¼ Set.univ).toReal)","decl":"theorem norm_integral_le_of_norm_le_const [IsFiniteMeasure Î¼] {f : Î± â†’ G} {C : â„}\n    (h : âˆ€áµ x âˆ‚Î¼, â€–f xâ€– â‰¤ C) : â€–âˆ« x, f x âˆ‚Î¼â€– â‰¤ C * (Î¼ univ).toReal :=\n  calc\n    â€–âˆ« x, f x âˆ‚Î¼â€– â‰¤ âˆ« _, C âˆ‚Î¼ := norm_integral_le_of_norm_le (integrable_const C) h\n    _ = C * (Î¼ univ).toReal := by rw [integral_const, smul_eq_mul, mul_comm]\n\n"}
{"name":"MeasureTheory.tendsto_integral_approxOn_of_measurable","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\nhE : CompleteSpace E\ninstâœÂ³ : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nf : Î± â†’ E\ns : Set E\ninstâœ : TopologicalSpace.SeparableSpace â†‘s\nhfi : MeasureTheory.Integrable f Î¼\nhfm : Measurable f\nhs : Filter.Eventually (fun x => Membership.mem (closure s) (f x)) (MeasureTheory.ae Î¼)\nyâ‚€ : E\nhâ‚€ : Membership.mem s yâ‚€\nhâ‚€i : MeasureTheory.Integrable (fun x => yâ‚€) Î¼\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.SimpleFunc.integral Î¼ (MeasureTheory.SimpleFunc.approxOn f hfm s yâ‚€ hâ‚€ n)) Filter.atTop (nhds (MeasureTheory.integral Î¼ fun x => f x))","decl":"theorem tendsto_integral_approxOn_of_measurable [MeasurableSpace E] [BorelSpace E] {f : Î± â†’ E}\n    {s : Set E} [SeparableSpace s] (hfi : Integrable f Î¼) (hfm : Measurable f)\n    (hs : âˆ€áµ x âˆ‚Î¼, f x âˆˆ closure s) {yâ‚€ : E} (hâ‚€ : yâ‚€ âˆˆ s) (hâ‚€i : Integrable (fun _ => yâ‚€) Î¼) :\n    Tendsto (fun n => (SimpleFunc.approxOn f hfm s yâ‚€ hâ‚€ n).integral Î¼)\n      atTop (ğ“ <| âˆ« x, f x âˆ‚Î¼) := by\n  have hfi' := SimpleFunc.integrable_approxOn hfm hfi hâ‚€ hâ‚€i\n  simp only [SimpleFunc.integral_eq_integral _ (hfi' _), integral, hE, L1.integral]\n  exact tendsto_setToFun_approxOn_of_measurable (dominatedFinMeasAdditive_weightedSMul Î¼)\n    hfi hfm hs hâ‚€ hâ‚€i\n\n"}
{"name":"MeasureTheory.tendsto_integral_approxOn_of_measurable_of_range_subset","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\nhE : CompleteSpace E\ninstâœÂ³ : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nf : Î± â†’ E\nfmeas : Measurable f\nhf : MeasureTheory.Integrable f Î¼\ns : Set E\ninstâœ : TopologicalSpace.SeparableSpace â†‘s\nhs : HasSubset.Subset (Union.union (Set.range f) (Singleton.singleton 0)) s\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.SimpleFunc.integral Î¼ (MeasureTheory.SimpleFunc.approxOn f fmeas s 0 â‹¯ n)) Filter.atTop (nhds (MeasureTheory.integral Î¼ fun x => f x))","decl":"theorem tendsto_integral_approxOn_of_measurable_of_range_subset [MeasurableSpace E] [BorelSpace E]\n    {f : Î± â†’ E} (fmeas : Measurable f) (hf : Integrable f Î¼) (s : Set E) [SeparableSpace s]\n    (hs : range f âˆª {0} âŠ† s) :\n    Tendsto (fun n => (SimpleFunc.approxOn f fmeas s 0 (hs <| by simp) n).integral Î¼) atTop\n      (ğ“ <| âˆ« x, f x âˆ‚Î¼) := by\n  apply tendsto_integral_approxOn_of_measurable hf fmeas _ _ (integrable_zero _ _ _)\n  exact Eventually.of_forall fun x => subset_closure (hs (Set.mem_union_left _ (mem_range_self _)))\n\n-- We redeclare `E` here to temporarily avoid\n-- the `[CompleteSpace E]` and `[NormedSpace â„ E]` instances.\n"}
{"name":"MeasureTheory.tendsto_integral_norm_approxOn_sub","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_7\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nf : Î± â†’ E\nfmeas : Measurable f\nhf : MeasureTheory.Integrable f Î¼\ninstâœ : TopologicalSpace.SeparableSpace â†‘(Union.union (Set.range f) (Singleton.singleton 0))\nâŠ¢ Filter.Tendsto (fun n => MeasureTheory.integral Î¼ fun x => Norm.norm (HSub.hSub ((MeasureTheory.SimpleFunc.approxOn f fmeas (Union.union (Set.range f) (Singleton.singleton 0)) 0 â‹¯ n) x) (f x))) Filter.atTop (nhds 0)","decl":"theorem tendsto_integral_norm_approxOn_sub\n    {E : Type*} [NormedAddCommGroup E] [MeasurableSpace E] [BorelSpace E] {f : Î± â†’ E}\n    (fmeas : Measurable f) (hf : Integrable f Î¼) [SeparableSpace (range f âˆª {0} : Set E)] :\n    Tendsto (fun n â†¦ âˆ« x, â€–SimpleFunc.approxOn f fmeas (range f âˆª {0}) 0 (by simp) n x - f xâ€– âˆ‚Î¼)\n      atTop (ğ“ 0) := by\n  convert (tendsto_toReal zero_ne_top).comp (tendsto_approxOn_range_L1_enorm fmeas hf) with n\n  rw [integral_norm_eq_lintegral_enorm]\n  Â· simp\n  Â· apply (SimpleFunc.aestronglyMeasurable _).sub\n    apply (stronglyMeasurable_iff_measurable_separable.2 âŸ¨fmeas, ?_âŸ© ).aestronglyMeasurable\n    exact .mono (.of_subtype (range f âˆª {0})) subset_union_left\n\n"}
{"name":"MeasureTheory.integral_add_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\nf : Î± â†’ G\nhÎ¼ : MeasureTheory.Integrable f Î¼\nhÎ½ : MeasureTheory.Integrable f Î½\nâŠ¢ Eq (MeasureTheory.integral (HAdd.hAdd Î¼ Î½) fun x => f x) (HAdd.hAdd (MeasureTheory.integral Î¼ fun x => f x) (MeasureTheory.integral Î½ fun x => f x))","decl":"theorem integral_add_measure {f : Î± â†’ G} (hÎ¼ : Integrable f Î¼) (hÎ½ : Integrable f Î½) :\n    âˆ« x, f x âˆ‚(Î¼ + Î½) = âˆ« x, f x âˆ‚Î¼ + âˆ« x, f x âˆ‚Î½ := by\n  by_cases hG : CompleteSpace G; swap\n  Â· simp [integral, hG]\n  have hfi := hÎ¼.add_measure hÎ½\n  simp_rw [integral_eq_setToFun]\n  have hÎ¼_dfma : DominatedFinMeasAdditive (Î¼ + Î½) (weightedSMul Î¼ : Set Î± â†’ G â†’L[â„] G) 1 :=\n    DominatedFinMeasAdditive.add_measure_right Î¼ Î½ (dominatedFinMeasAdditive_weightedSMul Î¼)\n      zero_le_one\n  have hÎ½_dfma : DominatedFinMeasAdditive (Î¼ + Î½) (weightedSMul Î½ : Set Î± â†’ G â†’L[â„] G) 1 :=\n    DominatedFinMeasAdditive.add_measure_left Î¼ Î½ (dominatedFinMeasAdditive_weightedSMul Î½)\n      zero_le_one\n  rw [â† setToFun_congr_measure_of_add_right hÎ¼_dfma\n        (dominatedFinMeasAdditive_weightedSMul Î¼) f hfi,\n    â† setToFun_congr_measure_of_add_left hÎ½_dfma (dominatedFinMeasAdditive_weightedSMul Î½) f hfi]\n  refine setToFun_add_left' _ _ _ (fun s _ hÎ¼Î½s => ?_) f\n  rw [Measure.coe_add, Pi.add_apply, add_lt_top] at hÎ¼Î½s\n  rw [weightedSMul, weightedSMul, weightedSMul, â† add_smul, Measure.coe_add, Pi.add_apply,\n  toReal_add hÎ¼Î½s.1.ne hÎ¼Î½s.2.ne]\n\n"}
{"name":"MeasureTheory.integral_zero_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nf : Î± â†’ G\nâŠ¢ Eq (MeasureTheory.integral 0 fun x => f x) 0","decl":"@[simp]\ntheorem integral_zero_measure {m : MeasurableSpace Î±} (f : Î± â†’ G) :\n    (âˆ« x, f x âˆ‚(0 : Measure Î±)) = 0 := by\n  by_cases hG : CompleteSpace G\n  Â· simp only [integral, hG, L1.integral]\n    exact setToFun_measure_zero (dominatedFinMeasAdditive_weightedSMul _) rfl\n  Â· simp [integral, hG]\n\n"}
{"name":"MeasureTheory.setIntegral_zero_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nf : Î± â†’ G\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhs : Eq (Î¼ s) 0\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) 0","decl":"@[simp]\ntheorem setIntegral_zero_measure (f : Î± â†’ G) {Î¼ : Measure Î±} {s : Set Î±} (hs : Î¼ s = 0) :\n    âˆ« x in s, f x âˆ‚Î¼ = 0 := Measure.restrict_eq_zero.mpr hs â–¸ integral_zero_measure f\n\n"}
{"name":"MeasureTheory.integral_of_isEmpty","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : IsEmpty Î±\nf : Î± â†’ G\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f x) 0","decl":"lemma integral_of_isEmpty [IsEmpty Î±] {f : Î± â†’ G} : âˆ« x, f x âˆ‚Î¼ = 0 :=\n    Î¼.eq_zero_of_isEmpty â–¸ integral_zero_measure _\n\n"}
{"name":"MeasureTheory.integral_finset_sum_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nÎ¹ : Type u_7\nm : MeasurableSpace Î±\nf : Î± â†’ G\nÎ¼ : Î¹ â†’ MeasureTheory.Measure Î±\ns : Finset Î¹\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ MeasureTheory.Integrable f (Î¼ i)\nâŠ¢ Eq (MeasureTheory.integral (s.sum fun i => Î¼ i) fun a => f a) (s.sum fun i => MeasureTheory.integral (Î¼ i) fun a => f a)","decl":"theorem integral_finset_sum_measure {Î¹} {m : MeasurableSpace Î±} {f : Î± â†’ G} {Î¼ : Î¹ â†’ Measure Î±}\n    {s : Finset Î¹} (hf : âˆ€ i âˆˆ s, Integrable f (Î¼ i)) :\n    âˆ« a, f a âˆ‚(âˆ‘ i âˆˆ s, Î¼ i) = âˆ‘ i âˆˆ s, âˆ« a, f a âˆ‚Î¼ i := by\n  induction s using Finset.cons_induction_on with\n  | hâ‚ => simp\n  | hâ‚‚ h ih =>\n    rw [Finset.forall_mem_cons] at hf\n    rw [Finset.sum_cons, Finset.sum_cons, â† ih hf.2]\n    exact integral_add_measure hf.1 (integrable_finset_sum_measure.2 hf.2)\n\n"}
{"name":"MeasureTheory.nndist_integral_add_measure_le_lintegral","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\nf : Î± â†’ G\nhâ‚ : MeasureTheory.Integrable f Î¼\nhâ‚‚ : MeasureTheory.Integrable f Î½\nâŠ¢ LE.le (â†‘(NNDist.nndist (MeasureTheory.integral Î¼ fun x => f x) (MeasureTheory.integral (HAdd.hAdd Î¼ Î½) fun x => f x))) (MeasureTheory.lintegral Î½ fun x => ENorm.enorm (f x))","decl":"theorem nndist_integral_add_measure_le_lintegral\n    {f : Î± â†’ G} (hâ‚ : Integrable f Î¼) (hâ‚‚ : Integrable f Î½) :\n    (nndist (âˆ« x, f x âˆ‚Î¼) (âˆ« x, f x âˆ‚(Î¼ + Î½)) : â„â‰¥0âˆ) â‰¤ âˆ«â» x, â€–f xâ€–â‚‘ âˆ‚Î½ := by\n  rw [integral_add_measure hâ‚ hâ‚‚, nndist_comm, nndist_eq_nnnorm, add_sub_cancel_left]\n  exact enorm_integral_le_lintegral_enorm _\n\n"}
{"name":"MeasureTheory.hasSum_integral_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nÎ¹ : Type u_7\nm : MeasurableSpace Î±\nf : Î± â†’ G\nÎ¼ : Î¹ â†’ MeasureTheory.Measure Î±\nhf : MeasureTheory.Integrable f (MeasureTheory.Measure.sum Î¼)\nâŠ¢ HasSum (fun i => MeasureTheory.integral (Î¼ i) fun a => f a) (MeasureTheory.integral (MeasureTheory.Measure.sum Î¼) fun a => f a)","decl":"theorem hasSum_integral_measure {Î¹} {m : MeasurableSpace Î±} {f : Î± â†’ G} {Î¼ : Î¹ â†’ Measure Î±}\n    (hf : Integrable f (Measure.sum Î¼)) :\n    HasSum (fun i => âˆ« a, f a âˆ‚Î¼ i) (âˆ« a, f a âˆ‚Measure.sum Î¼) := by\n  have hfi : âˆ€ i, Integrable f (Î¼ i) := fun i => hf.mono_measure (Measure.le_sum _ _)\n  simp only [HasSum, â† integral_finset_sum_measure fun i _ => hfi i]\n  refine Metric.nhds_basis_ball.tendsto_right_iff.mpr fun Îµ Îµ0 => ?_\n  lift Îµ to â„â‰¥0 using Îµ0.le\n  have hf_lt : (âˆ«â» x, â€–f xâ€–â‚‘ âˆ‚Measure.sum Î¼) < âˆ := hf.2\n  have hmem : âˆ€á¶  y in ğ“ (âˆ«â» x, â€–f xâ€–â‚‘ âˆ‚Measure.sum Î¼), (âˆ«â» x, â€–f xâ€–â‚‘ âˆ‚Measure.sum Î¼) < y + Îµ := by\n    refine tendsto_id.add tendsto_const_nhds (lt_mem_nhds (Î± := â„â‰¥0âˆ) <| ENNReal.lt_add_right ?_ ?_)\n    exacts [hf_lt.ne, ENNReal.coe_ne_zero.2 (NNReal.coe_ne_zero.1 Îµ0.ne')]\n  refine ((hasSum_lintegral_measure (fun x => â€–f xâ€–â‚‘) Î¼).eventually hmem).mono fun s hs => ?_\n  obtain âŸ¨Î½, hÎ½âŸ© : âˆƒ Î½, (âˆ‘ i âˆˆ s, Î¼ i) + Î½ = Measure.sum Î¼ := by\n    refine âŸ¨Measure.sum fun i : â†¥(sá¶œ : Set Î¹) => Î¼ i, ?_âŸ©\n    simpa only [â† Measure.sum_coe_finset] using Measure.sum_add_sum_compl (s : Set Î¹) Î¼\n  rw [Metric.mem_ball, â† coe_nndist, NNReal.coe_lt_coe, â† ENNReal.coe_lt_coe, â† hÎ½]\n  rw [â† hÎ½, integrable_add_measure] at hf\n  refine (nndist_integral_add_measure_le_lintegral hf.1 hf.2).trans_lt ?_\n  rw [â† hÎ½, lintegral_add_measure, lintegral_finset_sum_measure] at hs\n  exact lt_of_add_lt_add_left hs\n\n"}
{"name":"MeasureTheory.integral_sum_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nÎ¹ : Type u_7\nxâœ : MeasurableSpace Î±\nf : Î± â†’ G\nÎ¼ : Î¹ â†’ MeasureTheory.Measure Î±\nhf : MeasureTheory.Integrable f (MeasureTheory.Measure.sum Î¼)\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.Measure.sum Î¼) fun a => f a) (tsum fun i => MeasureTheory.integral (Î¼ i) fun a => f a)","decl":"theorem integral_sum_measure {Î¹} {_ : MeasurableSpace Î±} {f : Î± â†’ G} {Î¼ : Î¹ â†’ Measure Î±}\n    (hf : Integrable f (Measure.sum Î¼)) : âˆ« a, f a âˆ‚Measure.sum Î¼ = âˆ‘' i, âˆ« a, f a âˆ‚Î¼ i :=\n  (hasSum_integral_measure hf).tsum_eq.symm\n\n"}
{"name":"MeasureTheory.integral_smul_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ G\nc : ENNReal\nâŠ¢ Eq (MeasureTheory.integral (HSMul.hSMul c Î¼) fun x => f x) (HSMul.hSMul c.toReal (MeasureTheory.integral Î¼ fun x => f x))","decl":"@[simp]\ntheorem integral_smul_measure (f : Î± â†’ G) (c : â„â‰¥0âˆ) :\n    âˆ« x, f x âˆ‚c â€¢ Î¼ = c.toReal â€¢ âˆ« x, f x âˆ‚Î¼ := by\n  by_cases hG : CompleteSpace G; swap\n  Â· simp [integral, hG]\n  -- First we consider the â€œdegenerateâ€ case `c = âˆ`\n  rcases eq_or_ne c âˆ with (rfl | hc)\n  Â· rw [ENNReal.top_toReal, zero_smul, integral_eq_setToFun, setToFun_top_smul_measure]\n  -- Main case: `c â‰  âˆ`\n  simp_rw [integral_eq_setToFun, â† setToFun_smul_left]\n  have hdfma : DominatedFinMeasAdditive Î¼ (weightedSMul (c â€¢ Î¼) : Set Î± â†’ G â†’L[â„] G) c.toReal :=\n    mul_one c.toReal â–¸ (dominatedFinMeasAdditive_weightedSMul (c â€¢ Î¼)).of_smul_measure c hc\n  have hdfma_smul := dominatedFinMeasAdditive_weightedSMul (F := G) (c â€¢ Î¼)\n  rw [â† setToFun_congr_smul_measure c hc hdfma hdfma_smul f]\n  exact setToFun_congr_left' _ _ (fun s _ _ => weightedSMul_smul_measure Î¼ c) f\n\n"}
{"name":"MeasureTheory.integral_smul_nnreal_measure","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ G\nc : NNReal\nâŠ¢ Eq (MeasureTheory.integral (HSMul.hSMul c Î¼) fun x => f x) (HSMul.hSMul c (MeasureTheory.integral Î¼ fun x => f x))","decl":"@[simp]\ntheorem integral_smul_nnreal_measure (f : Î± â†’ G) (c : â„â‰¥0) :\n    âˆ« x, f x âˆ‚(c â€¢ Î¼) = c â€¢ âˆ« x, f x âˆ‚Î¼ :=\n  integral_smul_measure f (c : â„â‰¥0âˆ)\n\n"}
{"name":"MeasureTheory.integral_map_of_stronglyMeasurable","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\ninstâœ : MeasurableSpace Î²\nÏ† : Î± â†’ Î²\nhÏ† : Measurable Ï†\nf : Î² â†’ G\nhfm : MeasureTheory.StronglyMeasurable f\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.Measure.map Ï† Î¼) fun y => f y) (MeasureTheory.integral Î¼ fun x => f (Ï† x))","decl":"theorem integral_map_of_stronglyMeasurable {Î²} [MeasurableSpace Î²] {Ï† : Î± â†’ Î²} (hÏ† : Measurable Ï†)\n    {f : Î² â†’ G} (hfm : StronglyMeasurable f) : âˆ« y, f y âˆ‚Measure.map Ï† Î¼ = âˆ« x, f (Ï† x) âˆ‚Î¼ := by\n  by_cases hG : CompleteSpace G; swap\n  Â· simp [integral, hG]\n  by_cases hfi : Integrable f (Measure.map Ï† Î¼); swap\n  Â· rw [integral_undef hfi, integral_undef]\n    exact fun hfÏ† => hfi ((integrable_map_measure hfm.aestronglyMeasurable hÏ†.aemeasurable).2 hfÏ†)\n  borelize G\n  have : SeparableSpace (range f âˆª {0} : Set G) := hfm.separableSpace_range_union_singleton\n  refine tendsto_nhds_unique\n    (tendsto_integral_approxOn_of_measurable_of_range_subset hfm.measurable hfi _ Subset.rfl) ?_\n  convert tendsto_integral_approxOn_of_measurable_of_range_subset (hfm.measurable.comp hÏ†)\n    ((integrable_map_measure hfm.aestronglyMeasurable hÏ†.aemeasurable).1 hfi) (range f âˆª {0})\n    (by simp [insert_subset_insert, Set.range_comp_subset_range]) using 1\n  ext1 i\n  simp only [SimpleFunc.approxOn_comp, SimpleFunc.integral_eq, Measure.map_apply, hÏ†,\n    SimpleFunc.measurableSet_preimage, â† preimage_comp, SimpleFunc.coe_comp]\n  refine (Finset.sum_subset (SimpleFunc.range_comp_subset_range _ hÏ†) fun y _ hy => ?_).symm\n  rw [SimpleFunc.mem_range, â† Set.preimage_singleton_eq_empty, SimpleFunc.coe_comp] at hy\n  rw [hy]\n  simp\n\n"}
{"name":"MeasureTheory.integral_map","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\ninstâœ : MeasurableSpace Î²\nÏ† : Î± â†’ Î²\nhÏ† : AEMeasurable Ï† Î¼\nf : Î² â†’ G\nhfm : MeasureTheory.AEStronglyMeasurable f (MeasureTheory.Measure.map Ï† Î¼)\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.Measure.map Ï† Î¼) fun y => f y) (MeasureTheory.integral Î¼ fun x => f (Ï† x))","decl":"theorem integral_map {Î²} [MeasurableSpace Î²] {Ï† : Î± â†’ Î²} (hÏ† : AEMeasurable Ï† Î¼) {f : Î² â†’ G}\n    (hfm : AEStronglyMeasurable f (Measure.map Ï† Î¼)) :\n    âˆ« y, f y âˆ‚Measure.map Ï† Î¼ = âˆ« x, f (Ï† x) âˆ‚Î¼ :=\n  let g := hfm.mk f\n  calc\n    âˆ« y, f y âˆ‚Measure.map Ï† Î¼ = âˆ« y, g y âˆ‚Measure.map Ï† Î¼ := integral_congr_ae hfm.ae_eq_mk\n    _ = âˆ« y, g y âˆ‚Measure.map (hÏ†.mk Ï†) Î¼ := by congr 1; exact Measure.map_congr hÏ†.ae_eq_mk\n    _ = âˆ« x, g (hÏ†.mk Ï† x) âˆ‚Î¼ :=\n      (integral_map_of_stronglyMeasurable hÏ†.measurable_mk hfm.stronglyMeasurable_mk)\n    _ = âˆ« x, g (Ï† x) âˆ‚Î¼ := integral_congr_ae (hÏ†.ae_eq_mk.symm.fun_comp _)\n    _ = âˆ« x, f (Ï† x) âˆ‚Î¼ := integral_congr_ae <| ae_eq_comp hÏ† hfm.ae_eq_mk.symm\n\n"}
{"name":"MeasurableEmbedding.integral_map","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\nxâœ : MeasurableSpace Î²\nf : Î± â†’ Î²\nhf : MeasurableEmbedding f\ng : Î² â†’ G\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.Measure.map f Î¼) fun y => g y) (MeasureTheory.integral Î¼ fun x => g (f x))","decl":"theorem _root_.MeasurableEmbedding.integral_map {Î²} {_ : MeasurableSpace Î²} {f : Î± â†’ Î²}\n    (hf : MeasurableEmbedding f) (g : Î² â†’ G) : âˆ« y, g y âˆ‚Measure.map f Î¼ = âˆ« x, g (f x) âˆ‚Î¼ := by\n  by_cases hgm : AEStronglyMeasurable g (Measure.map f Î¼)\n  Â· exact MeasureTheory.integral_map hf.measurable.aemeasurable hgm\n  Â· rw [integral_non_aestronglyMeasurable hgm, integral_non_aestronglyMeasurable]\n    exact fun hgf => hgm (hf.aestronglyMeasurable_map_iff.2 hgf)\n\n"}
{"name":"Topology.IsClosedEmbedding.integral_map","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœâ¶ : NormedAddCommGroup G\ninstâœâµ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : BorelSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : BorelSpace Î²\nÏ† : Î± â†’ Î²\nhÏ† : Topology.IsClosedEmbedding Ï†\nf : Î² â†’ G\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.Measure.map Ï† Î¼) fun y => f y) (MeasureTheory.integral Î¼ fun x => f (Ï† x))","decl":"theorem _root_.Topology.IsClosedEmbedding.integral_map {Î²} [TopologicalSpace Î±] [BorelSpace Î±]\n    [TopologicalSpace Î²] [MeasurableSpace Î²] [BorelSpace Î²] {Ï† : Î± â†’ Î²} (hÏ† : IsClosedEmbedding Ï†)\n    (f : Î² â†’ G) : âˆ« y, f y âˆ‚Measure.map Ï† Î¼ = âˆ« x, f (Ï† x) âˆ‚Î¼ :=\n  hÏ†.measurableEmbedding.integral_map _\n\n"}
{"name":"ClosedEmbedding.integral_map","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœâ¶ : NormedAddCommGroup G\ninstâœâµ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\ninstâœâ´ : TopologicalSpace Î±\ninstâœÂ³ : BorelSpace Î±\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : BorelSpace Î²\nÏ† : Î± â†’ Î²\nhÏ† : Topology.IsClosedEmbedding Ï†\nf : Î² â†’ G\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.Measure.map Ï† Î¼) fun y => f y) (MeasureTheory.integral Î¼ fun x => f (Ï† x))","decl":"@[deprecated (since := \"2024-10-20\")]\nalias _root_.ClosedEmbedding.integral_map := IsClosedEmbedding.integral_map\n\n"}
{"name":"MeasureTheory.integral_map_equiv","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\ninstâœ : MeasurableSpace Î²\ne : MeasurableEquiv Î± Î²\nf : Î² â†’ G\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.Measure.map (â‡‘e) Î¼) fun y => f y) (MeasureTheory.integral Î¼ fun x => f (e x))","decl":"theorem integral_map_equiv {Î²} [MeasurableSpace Î²] (e : Î± â‰ƒáµ Î²) (f : Î² â†’ G) :\n    âˆ« y, f y âˆ‚Measure.map e Î¼ = âˆ« x, f (e x) âˆ‚Î¼ :=\n  e.measurableEmbedding.integral_map f\n\n"}
{"name":"MeasureTheory.MeasurePreserving.integral_comp","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\nxâœ : MeasurableSpace Î²\nf : Î± â†’ Î²\nÎ½ : MeasureTheory.Measure Î²\nhâ‚ : MeasureTheory.MeasurePreserving f Î¼ Î½\nhâ‚‚ : MeasurableEmbedding f\ng : Î² â†’ G\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => g (f x)) (MeasureTheory.integral Î½ fun y => g y)","decl":"theorem MeasurePreserving.integral_comp {Î²} {_ : MeasurableSpace Î²} {f : Î± â†’ Î²} {Î½}\n    (hâ‚ : MeasurePreserving f Î¼ Î½) (hâ‚‚ : MeasurableEmbedding f) (g : Î² â†’ G) :\n    âˆ« x, g (f x) âˆ‚Î¼ = âˆ« y, g y âˆ‚Î½ :=\n  hâ‚.map_eq â–¸ (hâ‚‚.integral_map g).symm\n\n"}
{"name":"MeasureTheory.MeasurePreserving.integral_comp'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nG : Type u_5\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace Real G\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_7\ninstâœ : MeasurableSpace Î²\nÎ½ : MeasureTheory.Measure Î²\nf : MeasurableEquiv Î± Î²\nh : MeasureTheory.MeasurePreserving (â‡‘f) Î¼ Î½\ng : Î² â†’ G\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => g (f x)) (MeasureTheory.integral Î½ fun y => g y)","decl":"theorem MeasurePreserving.integral_comp' {Î²} [MeasurableSpace Î²] {Î½} {f : Î± â‰ƒáµ Î²}\n    (h : MeasurePreserving f Î¼ Î½) (g : Î² â†’ G) :\n    âˆ« x, g (f x) âˆ‚Î¼ = âˆ« y, g y âˆ‚Î½ := MeasurePreserving.integral_comp h f.measurableEmbedding _\n\n"}
{"name":"MeasureTheory.integral_subtype_comap","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"G : Type u_5\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace Real G\nÎ± : Type u_7\ninstâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ns : Set Î±\nhs : MeasurableSet s\nf : Î± â†’ G\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.Measure.comap Subtype.val Î¼) fun x => f â†‘x) (MeasureTheory.integral (Î¼.restrict s) fun x => f x)","decl":"theorem integral_subtype_comap {Î±} [MeasurableSpace Î±] {Î¼ : Measure Î±} {s : Set Î±}\n    (hs : MeasurableSet s) (f : Î± â†’ G) :\n    âˆ« x : s, f (x : Î±) âˆ‚(Measure.comap Subtype.val Î¼) = âˆ« x in s, f x âˆ‚Î¼ := by\n  rw [â† map_comap_subtype_coe hs]\n  exact ((MeasurableEmbedding.subtype_coe hs).integral_map _).symm\n\n"}
{"name":"MeasureTheory.integral_subtype","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"G : Type u_5\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace Real G\nÎ± : Type u_7\ninstâœ : MeasureTheory.MeasureSpace Î±\ns : Set Î±\nhs : MeasurableSet s\nf : Î± â†’ G\nâŠ¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => f â†‘x) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict s) fun x => f x)","decl":"attribute [local instance] Measure.Subtype.measureSpace in\ntheorem integral_subtype {Î±} [MeasureSpace Î±] {s : Set Î±} (hs : MeasurableSet s) (f : Î± â†’ G) :\n    âˆ« x : s, f x = âˆ« x in s, f x := integral_subtype_comap hs f\n\n"}
{"name":"MeasureTheory.integral_dirac'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\nhE : CompleteSpace E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasurableSpace Î±\nf : Î± â†’ E\na : Î±\nhfm : MeasureTheory.StronglyMeasurable f\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.Measure.dirac a) fun x => f x) (f a)","decl":"@[simp]\ntheorem integral_dirac' [MeasurableSpace Î±] (f : Î± â†’ E) (a : Î±) (hfm : StronglyMeasurable f) :\n    âˆ« x, f x âˆ‚Measure.dirac a = f a := by\n  borelize E\n  calc\n    âˆ« x, f x âˆ‚Measure.dirac a = âˆ« _, f a âˆ‚Measure.dirac a :=\n      integral_congr_ae <| ae_eq_dirac' hfm.measurable\n    _ = f a := by simp [Measure.dirac_apply_of_mem]\n\n"}
{"name":"MeasureTheory.integral_dirac","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\nhE : CompleteSpace E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : MeasurableSpace Î±\ninstâœ : MeasurableSingletonClass Î±\nf : Î± â†’ E\na : Î±\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.Measure.dirac a) fun x => f x) (f a)","decl":"@[simp]\ntheorem integral_dirac [MeasurableSpace Î±] [MeasurableSingletonClass Î±] (f : Î± â†’ E) (a : Î±) :\n    âˆ« x, f x âˆ‚Measure.dirac a = f a :=\n  calc\n    âˆ« x, f x âˆ‚Measure.dirac a = âˆ« _, f a âˆ‚Measure.dirac a := integral_congr_ae <| ae_eq_dirac f\n    _ = f a := by simp [Measure.dirac_apply_of_mem]\n\n"}
{"name":"MeasureTheory.setIntegral_dirac'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\nhE : CompleteSpace E\ninstâœÂ¹ : NormedSpace Real E\nmÎ± : MeasurableSpace Î±\nf : Î± â†’ E\nhf : MeasureTheory.StronglyMeasurable f\na : Î±\ns : Set Î±\nhs : MeasurableSet s\ninstâœ : Decidable (Membership.mem s a)\nâŠ¢ Eq (MeasureTheory.integral ((MeasureTheory.Measure.dirac a).restrict s) fun x => f x) (ite (Membership.mem s a) (f a) 0)","decl":"theorem setIntegral_dirac' {mÎ± : MeasurableSpace Î±} {f : Î± â†’ E} (hf : StronglyMeasurable f) (a : Î±)\n    {s : Set Î±} (hs : MeasurableSet s) [Decidable (a âˆˆ s)] :\n    âˆ« x in s, f x âˆ‚Measure.dirac a = if a âˆˆ s then f a else 0 := by\n  rw [restrict_dirac' hs]\n  split_ifs\n  Â· exact integral_dirac' _ _ hf\n  Â· exact integral_zero_measure _\n\n"}
{"name":"MeasureTheory.setIntegral_dirac","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\nhE : CompleteSpace E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : MeasurableSpace Î±\ninstâœÂ¹ : MeasurableSingletonClass Î±\nf : Î± â†’ E\na : Î±\ns : Set Î±\ninstâœ : Decidable (Membership.mem s a)\nâŠ¢ Eq (MeasureTheory.integral ((MeasureTheory.Measure.dirac a).restrict s) fun x => f x) (ite (Membership.mem s a) (f a) 0)","decl":"theorem setIntegral_dirac [MeasurableSpace Î±] [MeasurableSingletonClass Î±] (f : Î± â†’ E) (a : Î±)\n    (s : Set Î±) [Decidable (a âˆˆ s)] :\n    âˆ« x in s, f x âˆ‚Measure.dirac a = if a âˆˆ s then f a else 0 := by\n  rw [restrict_dirac]\n  split_ifs\n  Â· exact integral_dirac _ _\n  Â· exact integral_zero_measure _\n\n"}
{"name":"MeasureTheory.mul_meas_ge_le_integral_of_nonneg","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf_nonneg : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nhf_int : MeasureTheory.Integrable f Î¼\nÎµ : Real\nâŠ¢ LE.le (HMul.hMul Îµ (Î¼ (setOf fun x => LE.le Îµ (f x))).toReal) (MeasureTheory.integral Î¼ fun x => f x)","decl":"/-- **Markov's inequality** also known as **Chebyshev's first inequality**. -/\ntheorem mul_meas_ge_le_integral_of_nonneg {f : Î± â†’ â„} (hf_nonneg : 0 â‰¤áµ[Î¼] f)\n    (hf_int : Integrable f Î¼) (Îµ : â„) : Îµ * (Î¼ { x | Îµ â‰¤ f x }).toReal â‰¤ âˆ« x, f x âˆ‚Î¼ := by\n  cases' eq_top_or_lt_top (Î¼ {x | Îµ â‰¤ f x}) with hÎ¼ hÎ¼\n  Â· simpa [hÎ¼] using integral_nonneg_of_ae hf_nonneg\n  Â· have := Fact.mk hÎ¼\n    calc\n      Îµ * (Î¼ { x | Îµ â‰¤ f x }).toReal = âˆ« _ in {x | Îµ â‰¤ f x}, Îµ âˆ‚Î¼ := by simp [mul_comm]\n      _ â‰¤ âˆ« x in {x | Îµ â‰¤ f x}, f x âˆ‚Î¼ :=\n        integral_mono_ae (integrable_const _) (hf_int.mono_measure Î¼.restrict_le_self) <|\n          ae_restrict_memâ‚€ <| hf_int.aemeasurable.nullMeasurable measurableSet_Ici\n      _ â‰¤ _ := integral_mono_measure Î¼.restrict_le_self hf_nonneg hf_int\n\n"}
{"name":"MeasureTheory.integral_mul_norm_le_Lp_mul_Lq","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_7\ninstâœ : NormedAddCommGroup E\nf g : Î± â†’ E\np q : Real\nhpq : p.IsConjExponent q\nhf : MeasureTheory.Memâ„’p f (ENNReal.ofReal p) Î¼\nhg : MeasureTheory.Memâ„’p g (ENNReal.ofReal q) Î¼\nâŠ¢ LE.le (MeasureTheory.integral Î¼ fun a => HMul.hMul (Norm.norm (f a)) (Norm.norm (g a))) (HMul.hMul (HPow.hPow (MeasureTheory.integral Î¼ fun a => HPow.hPow (Norm.norm (f a)) p) (HDiv.hDiv 1 p)) (HPow.hPow (MeasureTheory.integral Î¼ fun a => HPow.hPow (Norm.norm (g a)) q) (HDiv.hDiv 1 q)))","decl":"/-- HÃ¶lder's inequality for the integral of a product of norms. The integral of the product of two\nnorms of functions is bounded by the product of their `â„’p` and `â„’q` seminorms when `p` and `q` are\nconjugate exponents. -/\ntheorem integral_mul_norm_le_Lp_mul_Lq {E} [NormedAddCommGroup E] {f g : Î± â†’ E} {p q : â„}\n    (hpq : p.IsConjExponent q) (hf : Memâ„’p f (ENNReal.ofReal p) Î¼)\n    (hg : Memâ„’p g (ENNReal.ofReal q) Î¼) :\n    âˆ« a, â€–f aâ€– * â€–g aâ€– âˆ‚Î¼ â‰¤ (âˆ« a, â€–f aâ€– ^ p âˆ‚Î¼) ^ (1 / p) * (âˆ« a, â€–g aâ€– ^ q âˆ‚Î¼) ^ (1 / q) := by\n  -- translate the Bochner integrals into Lebesgue integrals.\n  rw [integral_eq_lintegral_of_nonneg_ae, integral_eq_lintegral_of_nonneg_ae,\n    integral_eq_lintegral_of_nonneg_ae]\n  rotate_left\n  Â· exact Eventually.of_forall fun x => Real.rpow_nonneg (norm_nonneg _) _\n  Â· exact (hg.1.norm.aemeasurable.pow aemeasurable_const).aestronglyMeasurable\n  Â· exact Eventually.of_forall fun x => Real.rpow_nonneg (norm_nonneg _) _\n  Â· exact (hf.1.norm.aemeasurable.pow aemeasurable_const).aestronglyMeasurable\n  Â· exact Eventually.of_forall fun x => mul_nonneg (norm_nonneg _) (norm_nonneg _)\n  Â· exact hf.1.norm.mul hg.1.norm\n  rw [ENNReal.toReal_rpow, ENNReal.toReal_rpow, â† ENNReal.toReal_mul]\n  -- replace norms by nnnorm\n  have h_left : âˆ«â» a, ENNReal.ofReal (â€–f aâ€– * â€–g aâ€–) âˆ‚Î¼ =\n      âˆ«â» a, ((â€–f Â·â€–â‚‘) * (â€–g Â·â€–â‚‘)) a âˆ‚Î¼ := by\n    simp_rw [Pi.mul_apply, â† ofReal_norm_eq_enorm, ENNReal.ofReal_mul (norm_nonneg _)]\n  have h_right_f : âˆ«â» a, .ofReal (â€–f aâ€– ^ p) âˆ‚Î¼ = âˆ«â» a, â€–f aâ€–â‚‘ ^ p âˆ‚Î¼ := by\n    refine lintegral_congr fun x => ?_\n    rw [â† ofReal_norm_eq_enorm, ENNReal.ofReal_rpow_of_nonneg (norm_nonneg _) hpq.nonneg]\n  have h_right_g : âˆ«â» a, .ofReal (â€–g aâ€– ^ q) âˆ‚Î¼ = âˆ«â» a, â€–g aâ€–â‚‘ ^ q âˆ‚Î¼ := by\n    refine lintegral_congr fun x => ?_\n    rw [â† ofReal_norm_eq_enorm, ENNReal.ofReal_rpow_of_nonneg (norm_nonneg _) hpq.symm.nonneg]\n  rw [h_left, h_right_f, h_right_g]\n  -- we can now apply `ENNReal.lintegral_mul_le_Lp_mul_Lq` (up to the `toReal` application)\n  refine ENNReal.toReal_mono ?_ ?_\n  Â· refine ENNReal.mul_ne_top ?_ ?_\n    Â· convert hf.eLpNorm_ne_top\n      rw [eLpNorm_eq_lintegral_rpow_enorm]\n      Â· rw [ENNReal.toReal_ofReal hpq.nonneg]\n      Â· rw [Ne, ENNReal.ofReal_eq_zero, not_le]\n        exact hpq.pos\n      Â· exact ENNReal.coe_ne_top\n    Â· convert hg.eLpNorm_ne_top\n      rw [eLpNorm_eq_lintegral_rpow_enorm]\n      Â· rw [ENNReal.toReal_ofReal hpq.symm.nonneg]\n      Â· rw [Ne, ENNReal.ofReal_eq_zero, not_le]\n        exact hpq.symm.pos\n      Â· exact ENNReal.coe_ne_top\n  Â· exact ENNReal.lintegral_mul_le_Lp_mul_Lq Î¼ hpq hf.1.nnnorm.aemeasurable.coe_nnreal_ennreal\n      hg.1.nnnorm.aemeasurable.coe_nnreal_ennreal\n\n"}
{"name":"MeasureTheory.integral_mul_le_Lp_mul_Lq_of_nonneg","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\np q : Real\nhpq : p.IsConjExponent q\nf g : Î± â†’ Real\nhf_nonneg : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nhg_nonneg : (MeasureTheory.ae Î¼).EventuallyLE 0 g\nhf : MeasureTheory.Memâ„’p f (ENNReal.ofReal p) Î¼\nhg : MeasureTheory.Memâ„’p g (ENNReal.ofReal q) Î¼\nâŠ¢ LE.le (MeasureTheory.integral Î¼ fun a => HMul.hMul (f a) (g a)) (HMul.hMul (HPow.hPow (MeasureTheory.integral Î¼ fun a => HPow.hPow (f a) p) (HDiv.hDiv 1 p)) (HPow.hPow (MeasureTheory.integral Î¼ fun a => HPow.hPow (g a) q) (HDiv.hDiv 1 q)))","decl":"/-- HÃ¶lder's inequality for functions `Î± â†’ â„`. The integral of the product of two nonnegative\nfunctions is bounded by the product of their `â„’p` and `â„’q` seminorms when `p` and `q` are conjugate\nexponents. -/\ntheorem integral_mul_le_Lp_mul_Lq_of_nonneg {p q : â„} (hpq : p.IsConjExponent q) {f g : Î± â†’ â„}\n    (hf_nonneg : 0 â‰¤áµ[Î¼] f) (hg_nonneg : 0 â‰¤áµ[Î¼] g) (hf : Memâ„’p f (ENNReal.ofReal p) Î¼)\n    (hg : Memâ„’p g (ENNReal.ofReal q) Î¼) :\n    âˆ« a, f a * g a âˆ‚Î¼ â‰¤ (âˆ« a, f a ^ p âˆ‚Î¼) ^ (1 / p) * (âˆ« a, g a ^ q âˆ‚Î¼) ^ (1 / q) := by\n  have h_left : âˆ« a, f a * g a âˆ‚Î¼ = âˆ« a, â€–f aâ€– * â€–g aâ€– âˆ‚Î¼ := by\n    refine integral_congr_ae ?_\n    filter_upwards [hf_nonneg, hg_nonneg] with x hxf hxg\n    rw [Real.norm_of_nonneg hxf, Real.norm_of_nonneg hxg]\n  have h_right_f : âˆ« a, f a ^ p âˆ‚Î¼ = âˆ« a, â€–f aâ€– ^ p âˆ‚Î¼ := by\n    refine integral_congr_ae ?_\n    filter_upwards [hf_nonneg] with x hxf\n    rw [Real.norm_of_nonneg hxf]\n  have h_right_g : âˆ« a, g a ^ q âˆ‚Î¼ = âˆ« a, â€–g aâ€– ^ q âˆ‚Î¼ := by\n    refine integral_congr_ae ?_\n    filter_upwards [hg_nonneg] with x hxg\n    rw [Real.norm_of_nonneg hxg]\n  rw [h_left, h_right_f, h_right_g]\n  exact integral_mul_norm_le_Lp_mul_Lq hpq hf hg\n\n"}
{"name":"MeasureTheory.integral_countable'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\nhE : CompleteSpace E\ninstâœÂ² : NormedSpace Real E\nm : MeasurableSpace Î±\ninstâœÂ¹ : Countable Î±\ninstâœ : MeasurableSingletonClass Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun a => f a) (tsum fun a => HSMul.hSMul (Î¼ (Singleton.singleton a)).toReal (f a))","decl":"theorem integral_countable' [Countable Î±] [MeasurableSingletonClass Î±] {Î¼ : Measure Î±}\n    {f : Î± â†’ E} (hf : Integrable f Î¼) :\n    âˆ« a, f a âˆ‚Î¼ = âˆ‘' a, (Î¼ {a}).toReal â€¢ f a := by\n  rw [â† Measure.sum_smul_dirac Î¼] at hf\n  rw [â† Measure.sum_smul_dirac Î¼, integral_sum_measure hf]\n  congr 1 with a : 1\n  rw [integral_smul_measure, integral_dirac, Measure.sum_smul_dirac]\n\n"}
{"name":"MeasureTheory.integral_singleton'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\nhE : CompleteSpace E\ninstâœ : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\nhf : MeasureTheory.StronglyMeasurable f\na : Î±\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Singleton.singleton a)) fun a => f a) (HSMul.hSMul (Î¼ (Singleton.singleton a)).toReal (f a))","decl":"theorem integral_singleton' {Î¼ : Measure Î±} {f : Î± â†’ E} (hf : StronglyMeasurable f) (a : Î±) :\n    âˆ« a in {a}, f a âˆ‚Î¼ = (Î¼ {a}).toReal â€¢ f a := by\n  simp only [Measure.restrict_singleton, integral_smul_measure, integral_dirac' f a hf, smul_eq_mul,\n    mul_comm]\n\n"}
{"name":"MeasureTheory.integral_singleton","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\nhE : CompleteSpace E\ninstâœÂ¹ : NormedSpace Real E\nm : MeasurableSpace Î±\ninstâœ : MeasurableSingletonClass Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ E\na : Î±\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Singleton.singleton a)) fun a => f a) (HSMul.hSMul (Î¼ (Singleton.singleton a)).toReal (f a))","decl":"theorem integral_singleton [MeasurableSingletonClass Î±] {Î¼ : Measure Î±} (f : Î± â†’ E) (a : Î±) :\n    âˆ« a in {a}, f a âˆ‚Î¼ = (Î¼ {a}).toReal â€¢ f a := by\n  simp only [Measure.restrict_singleton, integral_smul_measure, integral_dirac, smul_eq_mul,\n    mul_comm]\n\n"}
{"name":"MeasureTheory.integral_countable","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\nhE : CompleteSpace E\ninstâœÂ¹ : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasurableSingletonClass Î±\nf : Î± â†’ E\ns : Set Î±\nhs : s.Countable\nhf : MeasureTheory.IntegrableOn f s Î¼\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict s) fun a => f a) (tsum fun a => HSMul.hSMul (Î¼ (Singleton.singleton â†‘a)).toReal (f â†‘a))","decl":"theorem integral_countable [MeasurableSingletonClass Î±] (f : Î± â†’ E) {s : Set Î±} (hs : s.Countable)\n    (hf : IntegrableOn f s Î¼) :\n    âˆ« a in s, f a âˆ‚Î¼ = âˆ‘' a : s, (Î¼ {(a : Î±)}).toReal â€¢ f a := by\n  have hi : Countable { x // x âˆˆ s } := Iff.mpr countable_coe_iff hs\n  have hf' : Integrable (fun (x : s) => f x) (Measure.comap Subtype.val Î¼) := by\n    rw [IntegrableOn, â† map_comap_subtype_coe, integrable_map_measure] at hf\n    Â· apply hf\n    Â· exact Integrable.aestronglyMeasurable hf\n    Â· exact Measurable.aemeasurable measurable_subtype_coe\n    Â· exact Countable.measurableSet hs\n  rw [â† integral_subtype_comap hs.measurableSet, integral_countable' hf']\n  congr 1 with a : 1\n  rw [Measure.comap_apply Subtype.val Subtype.coe_injective\n    (fun s' hs' => MeasurableSet.subtype_image (Countable.measurableSet hs) hs') _\n    (MeasurableSet.singleton a)]\n  simp\n\n"}
{"name":"MeasureTheory.integral_finset","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\nhE : CompleteSpace E\ninstâœÂ¹ : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasurableSingletonClass Î±\ns : Finset Î±\nf : Î± â†’ E\nhf : MeasureTheory.IntegrableOn f (â†‘s) Î¼\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict â†‘s) fun x => f x) (s.sum fun x => HSMul.hSMul (Î¼ (Singleton.singleton x)).toReal (f x))","decl":"theorem integral_finset [MeasurableSingletonClass Î±] (s : Finset Î±) (f : Î± â†’ E)\n    (hf : IntegrableOn f s Î¼) :\n    âˆ« x in s, f x âˆ‚Î¼ = âˆ‘ x âˆˆ s, (Î¼ {x}).toReal â€¢ f x := by\n  rw [integral_countable _ s.countable_toSet hf, â† Finset.tsum_subtype']\n\n"}
{"name":"MeasureTheory.integral_fintype","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ³ : NormedAddCommGroup E\nhE : CompleteSpace E\ninstâœÂ² : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : MeasurableSingletonClass Î±\ninstâœ : Fintype Î±\nf : Î± â†’ E\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f x) (Finset.univ.sum fun x => HSMul.hSMul (Î¼ (Singleton.singleton x)).toReal (f x))","decl":"theorem integral_fintype [MeasurableSingletonClass Î±] [Fintype Î±] (f : Î± â†’ E)\n    (hf : Integrable f Î¼) :\n    âˆ« x, f x âˆ‚Î¼ = âˆ‘ x, (Î¼ {x}).toReal â€¢ f x := by\n  -- NB: Integrable f does not follow from Fintype, because the measure itself could be non-finite\n  rw [â† integral_finset .univ, Finset.coe_univ, Measure.restrict_univ]\n  simp [Finset.coe_univ, Measure.restrict_univ, hf]\n\n"}
{"name":"MeasureTheory.integral_unique","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\nhE : CompleteSpace E\ninstâœÂ¹ : NormedSpace Real E\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : Unique Î±\nf : Î± â†’ E\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f x) (HSMul.hSMul (Î¼ Set.univ).toReal (f Inhabited.default))","decl":"theorem integral_unique [Unique Î±] (f : Î± â†’ E) : âˆ« x, f x âˆ‚Î¼ = (Î¼ univ).toReal â€¢ f default :=\n  calc\n    âˆ« x, f x âˆ‚Î¼ = âˆ« _, f default âˆ‚Î¼ := by congr with x; congr; exact Unique.uniq _ x\n    _ = (Î¼ univ).toReal â€¢ f default := by rw [integral_const]\n\n"}
{"name":"MeasureTheory.integral_pos_of_integrable_nonneg_nonzero","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : TopologicalSpace Î±\ninstâœ : Î¼.IsOpenPosMeasure\nf : Î± â†’ Real\nx : Î±\nf_cont : Continuous f\nf_int : MeasureTheory.Integrable f Î¼\nf_nonneg : LE.le 0 f\nf_x : Ne (f x) 0\nâŠ¢ LT.lt 0 (MeasureTheory.integral Î¼ fun x => f x)","decl":"theorem integral_pos_of_integrable_nonneg_nonzero [TopologicalSpace Î±] [Measure.IsOpenPosMeasure Î¼]\n    {f : Î± â†’ â„} {x : Î±} (f_cont : Continuous f) (f_int : Integrable f Î¼) (f_nonneg : 0 â‰¤ f)\n    (f_x : f x â‰  0) : 0 < âˆ« x, f x âˆ‚Î¼ :=\n  (integral_pos_iff_support_of_nonneg f_nonneg f_int).2\n    (IsOpen.measure_pos Î¼ f_cont.isOpen_support âŸ¨x, f_xâŸ©)\n\n"}
{"name":"MeasureTheory.SimpleFunc.coe_toLargerSpace_eq","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î² : Type u_6\nÎ³ : Type u_7\nm m0 : MeasurableSpace Î²\nhm : LE.le m m0\nf : MeasureTheory.SimpleFunc Î² Î³\nâŠ¢ Eq â‡‘(MeasureTheory.SimpleFunc.toLargerSpace hm f) â‡‘f","decl":"theorem SimpleFunc.coe_toLargerSpace_eq (hm : m â‰¤ m0) (f : @SimpleFunc Î² m Î³) :\n    â‡‘(f.toLargerSpace hm) = f := rfl\n\n"}
{"name":"MeasureTheory.integral_simpleFunc_larger_space","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"F : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : CompleteSpace F\nÎ² : Type u_6\nm m0 : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î²\nhm : LE.le m m0\nf : MeasureTheory.SimpleFunc Î² F\nhf_int : MeasureTheory.Integrable (â‡‘f) Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f x) (f.range.sum fun x => HSMul.hSMul (Î¼ (Set.preimage (â‡‘f) (Singleton.singleton x))).toReal x)","decl":"theorem integral_simpleFunc_larger_space (hm : m â‰¤ m0) (f : @SimpleFunc Î² m F)\n    (hf_int : Integrable f Î¼) :\n    âˆ« x, f x âˆ‚Î¼ = âˆ‘ x âˆˆ @SimpleFunc.range Î² F m f, ENNReal.toReal (Î¼ (f â»Â¹' {x})) â€¢ x := by\n  simp_rw [â† f.coe_toLargerSpace_eq hm]\n  have hf_int : Integrable (f.toLargerSpace hm) Î¼ := by rwa [SimpleFunc.coe_toLargerSpace_eq]\n  rw [SimpleFunc.integral_eq_sum _ hf_int]\n  congr 1\n\n"}
{"name":"MeasureTheory.integral_trim_simpleFunc","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"F : Type u_3\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : CompleteSpace F\nÎ² : Type u_6\nm m0 : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î²\nhm : LE.le m m0\nf : MeasureTheory.SimpleFunc Î² F\nhf_int : MeasureTheory.Integrable (â‡‘f) Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f x) (MeasureTheory.integral (Î¼.trim hm) fun x => f x)","decl":"theorem integral_trim_simpleFunc (hm : m â‰¤ m0) (f : @SimpleFunc Î² m F) (hf_int : Integrable f Î¼) :\n    âˆ« x, f x âˆ‚Î¼ = âˆ« x, f x âˆ‚Î¼.trim hm := by\n  have hf : StronglyMeasurable[m] f := @SimpleFunc.stronglyMeasurable Î² F m _ f\n  have hf_int_m := hf_int.trim hm hf\n  rw [integral_simpleFunc_larger_space (le_refl m) f hf_int_m,\n    integral_simpleFunc_larger_space hm f hf_int]\n  congr with x\n  congr 2\n  exact (trim_measurableSet_eq hm (@SimpleFunc.measurableSet_fiber Î² F m f x)).symm\n\n"}
{"name":"MeasureTheory.integral_trim","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"G : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nÎ² : Type u_6\nm m0 : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î²\nhm : LE.le m m0\nf : Î² â†’ G\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f x) (MeasureTheory.integral (Î¼.trim hm) fun x => f x)","decl":"theorem integral_trim (hm : m â‰¤ m0) {f : Î² â†’ G} (hf : StronglyMeasurable[m] f) :\n    âˆ« x, f x âˆ‚Î¼ = âˆ« x, f x âˆ‚Î¼.trim hm := by\n  by_cases hG : CompleteSpace G; swap\n  Â· simp [integral, hG]\n  borelize G\n  by_cases hf_int : Integrable f Î¼\n  swap\n  Â· have hf_int_m : Â¬Integrable f (Î¼.trim hm) := fun hf_int_m =>\n      hf_int (integrable_of_integrable_trim hm hf_int_m)\n    rw [integral_undef hf_int, integral_undef hf_int_m]\n  haveI : SeparableSpace (range f âˆª {0} : Set G) := hf.separableSpace_range_union_singleton\n  let f_seq := @SimpleFunc.approxOn G Î² _ _ _ m _ hf.measurable (range f âˆª {0}) 0 (by simp) _\n  have hf_seq_meas : âˆ€ n, StronglyMeasurable[m] (f_seq n) := fun n =>\n    @SimpleFunc.stronglyMeasurable Î² G m _ (f_seq n)\n  have hf_seq_int : âˆ€ n, Integrable (f_seq n) Î¼ :=\n    SimpleFunc.integrable_approxOn_range (hf.mono hm).measurable hf_int\n  have hf_seq_int_m : âˆ€ n, Integrable (f_seq n) (Î¼.trim hm) := fun n =>\n    (hf_seq_int n).trim hm (hf_seq_meas n)\n  have hf_seq_eq : âˆ€ n, âˆ« x, f_seq n x âˆ‚Î¼ = âˆ« x, f_seq n x âˆ‚Î¼.trim hm := fun n =>\n    integral_trim_simpleFunc hm (f_seq n) (hf_seq_int n)\n  have h_lim_1 : atTop.Tendsto (fun n => âˆ« x, f_seq n x âˆ‚Î¼) (ğ“ (âˆ« x, f x âˆ‚Î¼)) := by\n    refine tendsto_integral_of_L1 f hf_int (Eventually.of_forall hf_seq_int) ?_\n    exact SimpleFunc.tendsto_approxOn_range_L1_enorm (hf.mono hm).measurable hf_int\n  have h_lim_2 : atTop.Tendsto (fun n => âˆ« x, f_seq n x âˆ‚Î¼) (ğ“ (âˆ« x, f x âˆ‚Î¼.trim hm)) := by\n    simp_rw [hf_seq_eq]\n    refine @tendsto_integral_of_L1 Î² G _ _ m (Î¼.trim hm) _ f (hf_int.trim hm hf) _ _\n      (Eventually.of_forall hf_seq_int_m) ?_\n    exact @SimpleFunc.tendsto_approxOn_range_L1_enorm Î² G m _ _ _ f _ _ hf.measurable\n      (hf_int.trim hm hf)\n  exact tendsto_nhds_unique h_lim_1 h_lim_2\n\n"}
{"name":"MeasureTheory.integral_trim_ae","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"G : Type u_5\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace Real G\nÎ² : Type u_6\nm m0 : MeasurableSpace Î²\nÎ¼ : MeasureTheory.Measure Î²\nhm : LE.le m m0\nf : Î² â†’ G\nhf : MeasureTheory.AEStronglyMeasurable f (Î¼.trim hm)\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f x) (MeasureTheory.integral (Î¼.trim hm) fun x => f x)","decl":"theorem integral_trim_ae (hm : m â‰¤ m0) {f : Î² â†’ G} (hf : AEStronglyMeasurable[m] f (Î¼.trim hm)) :\n    âˆ« x, f x âˆ‚Î¼ = âˆ« x, f x âˆ‚Î¼.trim hm := by\n  rw [integral_congr_ae (ae_eq_of_ae_eq_trim hf.ae_eq_mk), integral_congr_ae hf.ae_eq_mk]\n  exact integral_trim hm hf.stronglyMeasurable_mk\n\n"}
{"name":"MeasureTheory.eLpNorm_one_le_of_le","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nr : NNReal\nhfint : MeasureTheory.Integrable f Î¼\nhfint' : LE.le 0 (MeasureTheory.integral Î¼ fun x => f x)\nhf : Filter.Eventually (fun Ï‰ => LE.le (f Ï‰) â†‘r) (MeasureTheory.ae Î¼)\nâŠ¢ LE.le (MeasureTheory.eLpNorm f 1 Î¼) (HMul.hMul (HMul.hMul 2 (Î¼ Set.univ)) â†‘r)","decl":"theorem eLpNorm_one_le_of_le {r : â„â‰¥0} (hfint : Integrable f Î¼) (hfint' : 0 â‰¤ âˆ« x, f x âˆ‚Î¼)\n    (hf : âˆ€áµ Ï‰ âˆ‚Î¼, f Ï‰ â‰¤ r) : eLpNorm f 1 Î¼ â‰¤ 2 * Î¼ Set.univ * r := by\n  by_cases hr : r = 0\n  Â· suffices f =áµ[Î¼] 0 by\n      rw [eLpNorm_congr_ae this, eLpNorm_zero, hr, ENNReal.coe_zero, mul_zero]\n    rw [hr] at hf\n    norm_cast at hf\n    -- Porting note: two lines above were\n    --rw [hr, Nonneg.coe_zero] at hf\n    have hnegf : âˆ« x, -f x âˆ‚Î¼ = 0 := by\n      rw [integral_neg, neg_eq_zero]\n      exact le_antisymm (integral_nonpos_of_ae hf) hfint'\n    have := (integral_eq_zero_iff_of_nonneg_ae ?_ hfint.neg).1 hnegf\n    Â· filter_upwards [this] with Ï‰ hÏ‰\n      rwa [Pi.neg_apply, Pi.zero_apply, neg_eq_zero] at hÏ‰\n    Â· filter_upwards [hf] with Ï‰ hÏ‰\n      rwa [Pi.zero_apply, Pi.neg_apply, Right.nonneg_neg_iff]\n  by_cases hÎ¼ : IsFiniteMeasure Î¼\n  swap\n  Â· have : Î¼ Set.univ = âˆ := by\n      by_contra hÎ¼'\n      exact hÎ¼ (IsFiniteMeasure.mk <| lt_top_iff_ne_top.2 hÎ¼')\n    rw [this, ENNReal.mul_top', if_neg, ENNReal.top_mul', if_neg]\n    Â· exact le_top\n    Â· simp [hr]\n    Â· norm_num\n  haveI := hÎ¼\n  rw [integral_eq_integral_pos_part_sub_integral_neg_part hfint, sub_nonneg] at hfint'\n  have hposbdd : âˆ« Ï‰, max (f Ï‰) 0 âˆ‚Î¼ â‰¤ (Î¼ Set.univ).toReal â€¢ (r : â„) := by\n    rw [â† integral_const]\n    refine integral_mono_ae hfint.real_toNNReal (integrable_const (r : â„)) ?_\n    filter_upwards [hf] with Ï‰ hÏ‰ using Real.toNNReal_le_iff_le_coe.2 hÏ‰\n  rw [Memâ„’p.eLpNorm_eq_integral_rpow_norm one_ne_zero ENNReal.one_ne_top\n      (memâ„’p_one_iff_integrable.2 hfint),\n    ENNReal.ofReal_le_iff_le_toReal\n      (ENNReal.mul_ne_top (ENNReal.mul_ne_top ENNReal.ofNat_ne_top <| @measure_ne_top _ _ _ hÎ¼ _)\n        ENNReal.coe_ne_top)]\n  simp_rw [ENNReal.one_toReal, _root_.inv_one, Real.rpow_one, Real.norm_eq_abs, â†\n    max_zero_add_max_neg_zero_eq_abs_self, â† Real.coe_toNNReal']\n  rw [integral_add hfint.real_toNNReal]\n  Â· simp only [Real.coe_toNNReal', ENNReal.toReal_mul, ENNReal.one_toReal, ENNReal.coe_toReal,\n      Left.nonneg_neg_iff, Left.neg_nonpos_iff, toReal_ofNat] at hfint' âŠ¢\n    refine (add_le_add_left hfint' _).trans ?_\n    rwa [â† two_mul, mul_assoc, mul_le_mul_left (two_pos : (0 : â„) < 2)]\n  Â· exact hfint.neg.sup (integrable_zero _ _ Î¼)\n\n"}
{"name":"MeasureTheory.eLpNorm_one_le_of_le'","module":"Mathlib.MeasureTheory.Integral.Bochner","initialProofState":"Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nr : Real\nhfint : MeasureTheory.Integrable f Î¼\nhfint' : LE.le 0 (MeasureTheory.integral Î¼ fun x => f x)\nhf : Filter.Eventually (fun Ï‰ => LE.le (f Ï‰) r) (MeasureTheory.ae Î¼)\nâŠ¢ LE.le (MeasureTheory.eLpNorm f 1 Î¼) (HMul.hMul (HMul.hMul 2 (Î¼ Set.univ)) (ENNReal.ofReal r))","decl":"theorem eLpNorm_one_le_of_le' {r : â„} (hfint : Integrable f Î¼) (hfint' : 0 â‰¤ âˆ« x, f x âˆ‚Î¼)\n    (hf : âˆ€áµ Ï‰ âˆ‚Î¼, f Ï‰ â‰¤ r) : eLpNorm f 1 Î¼ â‰¤ 2 * Î¼ Set.univ * ENNReal.ofReal r := by\n  refine eLpNorm_one_le_of_le hfint hfint' ?_\n  simp only [Real.coe_toNNReal', le_max_iff]\n  filter_upwards [hf] with Ï‰ hÏ‰ using Or.inl hÏ‰\n\n"}
