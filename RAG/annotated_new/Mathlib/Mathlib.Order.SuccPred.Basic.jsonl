{"name":"SuccOrder.le_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_3\ninst✝ : Preorder α\nself : SuccOrder α\na : α\n⊢ LE.le a (SuccOrder.succ a)","decl":"/-- Order equipped with a sensible successor function. -/\n@[ext]\nclass SuccOrder (α : Type*) [Preorder α] where\n  /-- Successor function -/\n  succ : α → α\n  /-- Proof of basic ordering with respect to `succ`-/\n  le_succ : ∀ a, a ≤ succ a\n  /-- Proof of interaction between `succ` and maximal element -/\n  max_of_succ_le {a} : succ a ≤ a → IsMax a\n  /-- Proof that `succ a` is the least element greater than `a`-/\n  succ_le_of_lt {a b} : a < b → succ a ≤ b\n\n"}
{"name":"SuccOrder.ext_iff","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_3\ninst✝ : Preorder α\nx y : SuccOrder α\n⊢ Iff (Eq x y) (Eq SuccOrder.succ SuccOrder.succ)","decl":"/-- Order equipped with a sensible successor function. -/\n@[ext]\nclass SuccOrder (α : Type*) [Preorder α] where\n  /-- Successor function -/\n  succ : α → α\n  /-- Proof of basic ordering with respect to `succ`-/\n  le_succ : ∀ a, a ≤ succ a\n  /-- Proof of interaction between `succ` and maximal element -/\n  max_of_succ_le {a} : succ a ≤ a → IsMax a\n  /-- Proof that `succ a` is the least element greater than `a`-/\n  succ_le_of_lt {a b} : a < b → succ a ≤ b\n\n"}
{"name":"SuccOrder.succ_le_of_lt","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_3\ninst✝ : Preorder α\nself : SuccOrder α\na b : α\na✝ : LT.lt a b\n⊢ LE.le (SuccOrder.succ a) b","decl":"/-- Order equipped with a sensible successor function. -/\n@[ext]\nclass SuccOrder (α : Type*) [Preorder α] where\n  /-- Successor function -/\n  succ : α → α\n  /-- Proof of basic ordering with respect to `succ`-/\n  le_succ : ∀ a, a ≤ succ a\n  /-- Proof of interaction between `succ` and maximal element -/\n  max_of_succ_le {a} : succ a ≤ a → IsMax a\n  /-- Proof that `succ a` is the least element greater than `a`-/\n  succ_le_of_lt {a b} : a < b → succ a ≤ b\n\n"}
{"name":"SuccOrder.ext","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_3\ninst✝ : Preorder α\nx y : SuccOrder α\nsucc : Eq SuccOrder.succ SuccOrder.succ\n⊢ Eq x y","decl":"/-- Order equipped with a sensible successor function. -/\n@[ext]\nclass SuccOrder (α : Type*) [Preorder α] where\n  /-- Successor function -/\n  succ : α → α\n  /-- Proof of basic ordering with respect to `succ`-/\n  le_succ : ∀ a, a ≤ succ a\n  /-- Proof of interaction between `succ` and maximal element -/\n  max_of_succ_le {a} : succ a ≤ a → IsMax a\n  /-- Proof that `succ a` is the least element greater than `a`-/\n  succ_le_of_lt {a b} : a < b → succ a ≤ b\n\n"}
{"name":"SuccOrder.max_of_succ_le","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_3\ninst✝ : Preorder α\nself : SuccOrder α\na : α\na✝ : LE.le (SuccOrder.succ a) a\n⊢ IsMax a","decl":"/-- Order equipped with a sensible successor function. -/\n@[ext]\nclass SuccOrder (α : Type*) [Preorder α] where\n  /-- Successor function -/\n  succ : α → α\n  /-- Proof of basic ordering with respect to `succ`-/\n  le_succ : ∀ a, a ≤ succ a\n  /-- Proof of interaction between `succ` and maximal element -/\n  max_of_succ_le {a} : succ a ≤ a → IsMax a\n  /-- Proof that `succ a` is the least element greater than `a`-/\n  succ_le_of_lt {a b} : a < b → succ a ≤ b\n\n"}
{"name":"PredOrder.min_of_le_pred","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_3\ninst✝ : Preorder α\nself : PredOrder α\na : α\na✝ : LE.le a (PredOrder.pred a)\n⊢ IsMin a","decl":"/-- Order equipped with a sensible predecessor function. -/\n@[ext]\nclass PredOrder (α : Type*) [Preorder α] where\n  /-- Predecessor function -/\n  pred : α → α\n  /-- Proof of basic ordering with respect to `pred`-/\n  pred_le : ∀ a, pred a ≤ a\n  /-- Proof of interaction between `pred` and minimal element -/\n  min_of_le_pred {a} : a ≤ pred a → IsMin a\n  /-- Proof that `pred b` is the greatest element less than `b`-/\n  le_pred_of_lt {a b} : a < b → a ≤ pred b\n\n"}
{"name":"PredOrder.le_pred_of_lt","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_3\ninst✝ : Preorder α\nself : PredOrder α\na b : α\na✝ : LT.lt a b\n⊢ LE.le a (PredOrder.pred b)","decl":"/-- Order equipped with a sensible predecessor function. -/\n@[ext]\nclass PredOrder (α : Type*) [Preorder α] where\n  /-- Predecessor function -/\n  pred : α → α\n  /-- Proof of basic ordering with respect to `pred`-/\n  pred_le : ∀ a, pred a ≤ a\n  /-- Proof of interaction between `pred` and minimal element -/\n  min_of_le_pred {a} : a ≤ pred a → IsMin a\n  /-- Proof that `pred b` is the greatest element less than `b`-/\n  le_pred_of_lt {a b} : a < b → a ≤ pred b\n\n"}
{"name":"PredOrder.ext","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_3\ninst✝ : Preorder α\nx y : PredOrder α\npred : Eq PredOrder.pred PredOrder.pred\n⊢ Eq x y","decl":"/-- Order equipped with a sensible predecessor function. -/\n@[ext]\nclass PredOrder (α : Type*) [Preorder α] where\n  /-- Predecessor function -/\n  pred : α → α\n  /-- Proof of basic ordering with respect to `pred`-/\n  pred_le : ∀ a, pred a ≤ a\n  /-- Proof of interaction between `pred` and minimal element -/\n  min_of_le_pred {a} : a ≤ pred a → IsMin a\n  /-- Proof that `pred b` is the greatest element less than `b`-/\n  le_pred_of_lt {a b} : a < b → a ≤ pred b\n\n"}
{"name":"PredOrder.pred_le","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_3\ninst✝ : Preorder α\nself : PredOrder α\na : α\n⊢ LE.le (PredOrder.pred a) a","decl":"/-- Order equipped with a sensible predecessor function. -/\n@[ext]\nclass PredOrder (α : Type*) [Preorder α] where\n  /-- Predecessor function -/\n  pred : α → α\n  /-- Proof of basic ordering with respect to `pred`-/\n  pred_le : ∀ a, pred a ≤ a\n  /-- Proof of interaction between `pred` and minimal element -/\n  min_of_le_pred {a} : a ≤ pred a → IsMin a\n  /-- Proof that `pred b` is the greatest element less than `b`-/\n  le_pred_of_lt {a b} : a < b → a ≤ pred b\n\n"}
{"name":"PredOrder.ext_iff","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_3\ninst✝ : Preorder α\nx y : PredOrder α\n⊢ Iff (Eq x y) (Eq PredOrder.pred PredOrder.pred)","decl":"/-- Order equipped with a sensible predecessor function. -/\n@[ext]\nclass PredOrder (α : Type*) [Preorder α] where\n  /-- Predecessor function -/\n  pred : α → α\n  /-- Proof of basic ordering with respect to `pred`-/\n  pred_le : ∀ a, pred a ≤ a\n  /-- Proof of interaction between `pred` and minimal element -/\n  min_of_le_pred {a} : a ≤ pred a → IsMin a\n  /-- Proof that `pred b` is the greatest element less than `b`-/\n  le_pred_of_lt {a b} : a < b → a ≤ pred b\n\n"}
{"name":"SuccOrder.ofCore_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nsucc : α → α\nhn : ∀ {a : α}, Not (IsMax a) → ∀ (b : α), Iff (LT.lt a b) (LE.le (succ a) b)\nhm : ∀ (a : α), IsMax a → Eq (succ a) a\na✝ : α\n⊢ Eq (SuccOrder.succ a✝) (succ a✝)","decl":"/-- A constructor for `SuccOrder α` for `α` a linear order. -/\n@[simps]\ndef SuccOrder.ofCore (succ : α → α) (hn : ∀ {a}, ¬IsMax a → ∀ b, a < b ↔ succ a ≤ b)\n    (hm : ∀ a, IsMax a → succ a = a) : SuccOrder α :=\n  { succ\n    succ_le_of_lt := fun {a b} =>\n      by_cases (fun h hab => (hm a h).symm ▸ hab.le) fun h => (hn h b).mp\n    le_succ := fun a =>\n      by_cases (fun h => (hm a h).symm.le) fun h => le_of_lt <| by simpa using (hn h a).not\n    max_of_succ_le := fun {a} => not_imp_not.mp fun h => by simpa using (hn h a).not }\n\n"}
{"name":"PredOrder.ofCore_pred","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\npred : α → α\nhn : ∀ {a : α}, Not (IsMin a) → ∀ (b : α), Iff (LE.le b (pred a)) (LT.lt b a)\nhm : ∀ (a : α), IsMin a → Eq (pred a) a\na✝ : α\n⊢ Eq (PredOrder.pred a✝) (pred a✝)","decl":"/-- A constructor for `PredOrder α` for `α` a linear order. -/\n@[simps]\ndef PredOrder.ofCore (pred : α → α)\n    (hn : ∀ {a}, ¬IsMin a → ∀ b, b ≤ pred a ↔ b < a) (hm : ∀ a, IsMin a → pred a = a) :\n    PredOrder α :=\n  { pred\n    le_pred_of_lt := fun {a b} =>\n      by_cases (fun h hab => (hm b h).symm ▸ hab.le) fun h => (hn h a).mpr\n    pred_le := fun a =>\n      by_cases (fun h => (hm a h).le) fun h => le_of_lt <| by simpa using (hn h a).not\n    min_of_le_pred := fun {a} => not_imp_not.mp fun h => by simpa using (hn h a).not }\n\n"}
{"name":"Order.le_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na : α\n⊢ LE.le a (Order.succ a)","decl":"theorem le_succ : ∀ a : α, a ≤ succ a :=\n  SuccOrder.le_succ\n\n"}
{"name":"Order.max_of_succ_le","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na : α\na✝ : LE.le (Order.succ a) a\n⊢ IsMax a","decl":"theorem max_of_succ_le {a : α} : succ a ≤ a → IsMax a :=\n  SuccOrder.max_of_succ_le\n\n"}
{"name":"Order.succ_le_of_lt","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na b : α\na✝ : LT.lt a b\n⊢ LE.le (Order.succ a) b","decl":"theorem succ_le_of_lt {a b : α} : a < b → succ a ≤ b :=\n  SuccOrder.succ_le_of_lt\n\n"}
{"name":"LT.lt.succ_le","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na b : α\na✝ : LT.lt a b\n⊢ LE.le (Order.succ a) b","decl":"alias _root_.LT.lt.succ_le := succ_le_of_lt\n\n"}
{"name":"Order.succ_le_iff_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na : α\n⊢ Iff (LE.le (Order.succ a) a) (IsMax a)","decl":"@[simp]\ntheorem succ_le_iff_isMax : succ a ≤ a ↔ IsMax a :=\n  ⟨max_of_succ_le, fun h => h <| le_succ _⟩\n\n"}
{"name":"IsMax.of_succ_le","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na : α\na✝ : LE.le (Order.succ a) a\n⊢ IsMax a","decl":"alias ⟨_root_.IsMax.of_succ_le, _root_.IsMax.succ_le⟩ := succ_le_iff_isMax\n\n"}
{"name":"IsMax.succ_le","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na : α\na✝ : IsMax a\n⊢ LE.le (Order.succ a) a","decl":"alias ⟨_root_.IsMax.of_succ_le, _root_.IsMax.succ_le⟩ := succ_le_iff_isMax\n\n"}
{"name":"Order.lt_succ_iff_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na : α\n⊢ Iff (LT.lt a (Order.succ a)) (Not (IsMax a))","decl":"@[simp]\ntheorem lt_succ_iff_not_isMax : a < succ a ↔ ¬IsMax a :=\n  ⟨not_isMax_of_lt, fun ha => (le_succ a).lt_of_not_le fun h => ha <| max_of_succ_le h⟩\n\n"}
{"name":"Order.lt_succ_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na : α\na✝ : Not (IsMax a)\n⊢ LT.lt a (Order.succ a)","decl":"alias ⟨_, lt_succ_of_not_isMax⟩ := lt_succ_iff_not_isMax\n\n"}
{"name":"Order.wcovBy_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na : α\n⊢ WCovBy a (Order.succ a)","decl":"theorem wcovBy_succ (a : α) : a ⩿ succ a :=\n  ⟨le_succ a, fun _ hb => (succ_le_of_lt hb).not_lt⟩\n\n"}
{"name":"Order.covBy_succ_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na : α\nh : Not (IsMax a)\n⊢ CovBy a (Order.succ a)","decl":"theorem covBy_succ_of_not_isMax (h : ¬IsMax a) : a ⋖ succ a :=\n  (wcovBy_succ a).covBy_of_lt <| lt_succ_of_not_isMax h\n\n"}
{"name":"Order.lt_succ_of_le_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na b : α\nhab : LE.le b a\nha : Not (IsMax a)\n⊢ LT.lt b (Order.succ a)","decl":"theorem lt_succ_of_le_of_not_isMax (hab : b ≤ a) (ha : ¬IsMax a) : b < succ a :=\n  hab.trans_lt <| lt_succ_of_not_isMax ha\n\n"}
{"name":"Order.succ_le_iff_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na b : α\nha : Not (IsMax a)\n⊢ Iff (LE.le (Order.succ a) b) (LT.lt a b)","decl":"theorem succ_le_iff_of_not_isMax (ha : ¬IsMax a) : succ a ≤ b ↔ a < b :=\n  ⟨(lt_succ_of_not_isMax ha).trans_le, succ_le_of_lt⟩\n\n"}
{"name":"Order.succ_lt_succ_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na b : α\nh : LT.lt a b\nhb : Not (IsMax b)\n⊢ LT.lt (Order.succ a) (Order.succ b)","decl":"lemma succ_lt_succ_of_not_isMax (h : a < b) (hb : ¬ IsMax b) : succ a < succ b :=\n  lt_succ_of_le_of_not_isMax (succ_le_of_lt h) hb\n\n"}
{"name":"Order.succ_le_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na b : α\nh : LE.le a b\n⊢ LE.le (Order.succ a) (Order.succ b)","decl":"@[simp, mono]\ntheorem succ_le_succ (h : a ≤ b) : succ a ≤ succ b := by\n  by_cases hb : IsMax b\n  · by_cases hba : b ≤ a\n    · exact (hb <| hba.trans <| le_succ _).trans (le_succ _)\n    · exact succ_le_of_lt ((h.lt_of_not_le hba).trans_le <| le_succ b)\n  · rw [succ_le_iff_of_not_isMax fun ha => hb <| ha.mono h]\n    apply lt_succ_of_le_of_not_isMax h hb\n\n"}
{"name":"Order.succ_mono","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\n⊢ Monotone Order.succ","decl":"theorem succ_mono : Monotone (succ : α → α) := fun _ _ => succ_le_succ\n\n"}
{"name":"Order.le_succ_of_wcovBy","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na b : α\nh : WCovBy a b\n⊢ LE.le b (Order.succ a)","decl":"/-- See also `Order.succ_eq_of_covBy`. -/\nlemma le_succ_of_wcovBy (h : a ⩿ b) : b ≤ succ a := by\n  obtain hab | ⟨-, hba⟩ := h.covBy_or_le_and_le\n  · by_contra hba\n    exact h.2 (lt_succ_of_not_isMax hab.lt.not_isMax) <| hab.lt.succ_le.lt_of_not_le hba\n  · exact hba.trans (le_succ _)\n\n"}
{"name":"WCovBy.le_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na b : α\nh : WCovBy a b\n⊢ LE.le b (Order.succ a)","decl":"alias _root_.WCovBy.le_succ := le_succ_of_wcovBy\n\n"}
{"name":"Order.le_succ_iterate","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\nk : Nat\nx : α\n⊢ LE.le x (Nat.iterate Order.succ k x)","decl":"theorem le_succ_iterate (k : ℕ) (x : α) : x ≤ succ^[k] x :=\n  id_le_iterate_of_id_le le_succ _ _\n\n"}
{"name":"Order.isMax_iterate_succ_of_eq_of_lt","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na : α\nn m : Nat\nh_eq : Eq (Nat.iterate Order.succ n a) (Nat.iterate Order.succ m a)\nh_lt : LT.lt n m\n⊢ IsMax (Nat.iterate Order.succ n a)","decl":"theorem isMax_iterate_succ_of_eq_of_lt {n m : ℕ} (h_eq : succ^[n] a = succ^[m] a)\n    (h_lt : n < m) : IsMax (succ^[n] a) := by\n  refine max_of_succ_le (le_trans ?_ h_eq.symm.le)\n  rw [← iterate_succ_apply' succ]\n  have h_le : n + 1 ≤ m := Nat.succ_le_of_lt h_lt\n  exact Monotone.monotone_iterate_of_le_map succ_mono (le_succ a) h_le\n\n"}
{"name":"Order.isMax_iterate_succ_of_eq_of_ne","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na : α\nn m : Nat\nh_eq : Eq (Nat.iterate Order.succ n a) (Nat.iterate Order.succ m a)\nh_ne : Ne n m\n⊢ IsMax (Nat.iterate Order.succ n a)","decl":"theorem isMax_iterate_succ_of_eq_of_ne {n m : ℕ} (h_eq : succ^[n] a = succ^[m] a)\n    (h_ne : n ≠ m) : IsMax (succ^[n] a) := by\n  rcases le_total n m with h | h\n  · exact isMax_iterate_succ_of_eq_of_lt h_eq (lt_of_le_of_ne h h_ne)\n  · rw [h_eq]\n    exact isMax_iterate_succ_of_eq_of_lt h_eq.symm (lt_of_le_of_ne h h_ne.symm)\n\n"}
{"name":"Order.Iic_subset_Iio_succ_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na : α\nha : Not (IsMax a)\n⊢ HasSubset.Subset (Set.Iic a) (Set.Iio (Order.succ a))","decl":"theorem Iic_subset_Iio_succ_of_not_isMax (ha : ¬IsMax a) : Iic a ⊆ Iio (succ a) :=\n  fun _ => (lt_succ_of_le_of_not_isMax · ha)\n\n"}
{"name":"Order.Ici_succ_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na : α\nha : Not (IsMax a)\n⊢ Eq (Set.Ici (Order.succ a)) (Set.Ioi a)","decl":"theorem Ici_succ_of_not_isMax (ha : ¬IsMax a) : Ici (succ a) = Ioi a :=\n  Set.ext fun _ => succ_le_iff_of_not_isMax ha\n\n"}
{"name":"Order.Icc_subset_Ico_succ_right_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na b : α\nhb : Not (IsMax b)\n⊢ HasSubset.Subset (Set.Icc a b) (Set.Ico a (Order.succ b))","decl":"theorem Icc_subset_Ico_succ_right_of_not_isMax (hb : ¬IsMax b) : Icc a b ⊆ Ico a (succ b) := by\n  rw [← Ici_inter_Iio, ← Ici_inter_Iic]\n  gcongr\n  intro _ h\n  apply lt_succ_of_le_of_not_isMax h hb\n\n"}
{"name":"Order.Ioc_subset_Ioo_succ_right_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na b : α\nhb : Not (IsMax b)\n⊢ HasSubset.Subset (Set.Ioc a b) (Set.Ioo a (Order.succ b))","decl":"theorem Ioc_subset_Ioo_succ_right_of_not_isMax (hb : ¬IsMax b) : Ioc a b ⊆ Ioo a (succ b) := by\n  rw [← Ioi_inter_Iio, ← Ioi_inter_Iic]\n  gcongr\n  intro _ h\n  apply Iic_subset_Iio_succ_of_not_isMax hb h\n\n"}
{"name":"Order.Icc_succ_left_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na b : α\nha : Not (IsMax a)\n⊢ Eq (Set.Icc (Order.succ a) b) (Set.Ioc a b)","decl":"theorem Icc_succ_left_of_not_isMax (ha : ¬IsMax a) : Icc (succ a) b = Ioc a b := by\n  rw [← Ici_inter_Iic, Ici_succ_of_not_isMax ha, Ioi_inter_Iic]\n\n"}
{"name":"Order.Ico_succ_left_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : SuccOrder α\na b : α\nha : Not (IsMax a)\n⊢ Eq (Set.Ico (Order.succ a) b) (Set.Ioo a b)","decl":"theorem Ico_succ_left_of_not_isMax (ha : ¬IsMax a) : Ico (succ a) b = Ioo a b := by\n  rw [← Ici_inter_Iio, Ici_succ_of_not_isMax ha, Ioi_inter_Iio]\n\n"}
{"name":"Order.lt_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\na : α\n⊢ LT.lt a (Order.succ a)","decl":"theorem lt_succ (a : α) : a < succ a :=\n  lt_succ_of_not_isMax <| not_isMax a\n\n"}
{"name":"Order.lt_succ_of_le","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\na b : α\ninst✝ : NoMaxOrder α\na✝ : LE.le a b\n⊢ LT.lt a (Order.succ b)","decl":"@[simp]\ntheorem lt_succ_of_le : a ≤ b → a < succ b :=\n  (lt_succ_of_le_of_not_isMax · <| not_isMax b)\n\n"}
{"name":"Order.succ_le_iff","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\na b : α\ninst✝ : NoMaxOrder α\n⊢ Iff (LE.le (Order.succ a) b) (LT.lt a b)","decl":"@[simp]\ntheorem succ_le_iff : succ a ≤ b ↔ a < b :=\n  succ_le_iff_of_not_isMax <| not_isMax a\n\n"}
{"name":"Order.succ_lt_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\na b : α\ninst✝ : NoMaxOrder α\nhab : LT.lt a b\n⊢ LT.lt (Order.succ a) (Order.succ b)","decl":"@[gcongr] theorem succ_lt_succ (hab : a < b) : succ a < succ b := by simp [hab]\n\n"}
{"name":"Order.succ_strictMono","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\n⊢ StrictMono Order.succ","decl":"theorem succ_strictMono : StrictMono (succ : α → α) := fun _ _ => succ_lt_succ\n\n"}
{"name":"Order.covBy_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\na : α\n⊢ CovBy a (Order.succ a)","decl":"theorem covBy_succ (a : α) : a ⋖ succ a :=\n  covBy_succ_of_not_isMax <| not_isMax a\n\n"}
{"name":"Order.Iic_subset_Iio_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\na : α\n⊢ HasSubset.Subset (Set.Iic a) (Set.Iio (Order.succ a))","decl":"@[simp]\ntheorem Iic_subset_Iio_succ (a : α) : Iic a ⊆ Iio (succ a) :=\n  Iic_subset_Iio_succ_of_not_isMax <| not_isMax _\n\n"}
{"name":"Order.Ici_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\na : α\n⊢ Eq (Set.Ici (Order.succ a)) (Set.Ioi a)","decl":"@[simp]\ntheorem Ici_succ (a : α) : Ici (succ a) = Ioi a :=\n  Ici_succ_of_not_isMax <| not_isMax _\n\n"}
{"name":"Order.Icc_subset_Ico_succ_right","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\na b : α\n⊢ HasSubset.Subset (Set.Icc a b) (Set.Ico a (Order.succ b))","decl":"@[simp]\ntheorem Icc_subset_Ico_succ_right (a b : α) : Icc a b ⊆ Ico a (succ b) :=\n  Icc_subset_Ico_succ_right_of_not_isMax <| not_isMax _\n\n"}
{"name":"Order.Ioc_subset_Ioo_succ_right","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\na b : α\n⊢ HasSubset.Subset (Set.Ioc a b) (Set.Ioo a (Order.succ b))","decl":"@[simp]\ntheorem Ioc_subset_Ioo_succ_right (a b : α) : Ioc a b ⊆ Ioo a (succ b) :=\n  Ioc_subset_Ioo_succ_right_of_not_isMax <| not_isMax _\n\n"}
{"name":"Order.Icc_succ_left","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\na b : α\n⊢ Eq (Set.Icc (Order.succ a) b) (Set.Ioc a b)","decl":"@[simp]\ntheorem Icc_succ_left (a b : α) : Icc (succ a) b = Ioc a b :=\n  Icc_succ_left_of_not_isMax <| not_isMax _\n\n"}
{"name":"Order.Ico_succ_left","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\na b : α\n⊢ Eq (Set.Ico (Order.succ a) b) (Set.Ioo a b)","decl":"@[simp]\ntheorem Ico_succ_left (a b : α) : Ico (succ a) b = Ioo a b :=\n  Ico_succ_left_of_not_isMax <| not_isMax _\n\n"}
{"name":"Order.succ_eq_iff_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\na : α\n⊢ Iff (Eq (Order.succ a) a) (IsMax a)","decl":"@[simp]\ntheorem succ_eq_iff_isMax : succ a = a ↔ IsMax a :=\n  ⟨fun h => max_of_succ_le h.le, fun h => h.eq_of_ge <| le_succ _⟩\n\n"}
{"name":"IsMax.succ_eq","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\na : α\na✝ : IsMax a\n⊢ Eq (Order.succ a) a","decl":"alias ⟨_, _root_.IsMax.succ_eq⟩ := succ_eq_iff_isMax\n\n"}
{"name":"Order.le_le_succ_iff","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\na b : α\n⊢ Iff (And (LE.le a b) (LE.le b (Order.succ a))) (Or (Eq b a) (Eq b (Order.succ a)))","decl":"theorem le_le_succ_iff : a ≤ b ∧ b ≤ succ a ↔ b = a ∨ b = succ a := by\n  refine\n    ⟨fun h =>\n      or_iff_not_imp_left.2 fun hba : b ≠ a =>\n        h.2.antisymm (succ_le_of_lt <| h.1.lt_of_ne <| hba.symm),\n      ?_⟩\n  rintro (rfl | rfl)\n  · exact ⟨le_rfl, le_succ b⟩\n  · exact ⟨le_succ a, le_rfl⟩\n\n"}
{"name":"Order.succ_eq_of_covBy","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\na b : α\nh : CovBy a b\n⊢ Eq (Order.succ a) b","decl":"/-- See also `Order.le_succ_of_wcovBy`. -/\nlemma succ_eq_of_covBy (h : a ⋖ b) : succ a = b := (succ_le_of_lt h.lt).antisymm h.wcovBy.le_succ\n\n"}
{"name":"CovBy.succ_eq","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : SuccOrder α\na b : α\nh : CovBy a b\n⊢ Eq (Order.succ a) b","decl":"alias _root_.CovBy.succ_eq := succ_eq_of_covBy\n\n"}
{"name":"OrderIso.map_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : PartialOrder α\ninst✝² : SuccOrder α\ninst✝¹ : PartialOrder β\ninst✝ : SuccOrder β\nf : OrderIso α β\na : α\n⊢ Eq (f (Order.succ a)) (Order.succ (f a))","decl":"theorem _root_.OrderIso.map_succ [PartialOrder β] [SuccOrder β] (f : α ≃o β) (a : α) :\n    f (succ a) = succ (f a) := by\n  by_cases h : IsMax a\n  · rw [h.succ_eq, (f.isMax_apply.2 h).succ_eq]\n  · exact (f.map_covBy.2 <| covBy_succ_of_not_isMax h).succ_eq.symm\n\n"}
{"name":"Order.succ_eq_iff_covBy","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\na b : α\ninst✝ : NoMaxOrder α\n⊢ Iff (Eq (Order.succ a) b) (CovBy a b)","decl":"theorem succ_eq_iff_covBy : succ a = b ↔ a ⋖ b :=\n  ⟨by rintro rfl; exact covBy_succ _, CovBy.succ_eq⟩\n\n"}
{"name":"Order.succ_top","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : OrderTop α\n⊢ Eq (Order.succ Top.top) Top.top","decl":"@[simp]\ntheorem succ_top : succ (⊤ : α) = ⊤ := by\n  rw [succ_eq_iff_isMax, isMax_iff_eq_top]\n\n"}
{"name":"Order.succ_le_iff_eq_top","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\na : α\ninst✝ : OrderTop α\n⊢ Iff (LE.le (Order.succ a) a) (Eq a Top.top)","decl":"theorem succ_le_iff_eq_top : succ a ≤ a ↔ a = ⊤ :=\n  succ_le_iff_isMax.trans isMax_iff_eq_top\n\n"}
{"name":"Order.lt_succ_iff_ne_top","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\na : α\ninst✝ : OrderTop α\n⊢ Iff (LT.lt a (Order.succ a)) (Ne a Top.top)","decl":"theorem lt_succ_iff_ne_top : a < succ a ↔ a ≠ ⊤ :=\n  lt_succ_iff_not_isMax.trans not_isMax_iff_ne_top\n\n"}
{"name":"Order.bot_lt_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝³ : PartialOrder α\ninst✝² : SuccOrder α\ninst✝¹ : OrderBot α\ninst✝ : Nontrivial α\na : α\n⊢ LT.lt Bot.bot (Order.succ a)","decl":"theorem bot_lt_succ (a : α) : ⊥ < succ a :=\n  (lt_succ_of_not_isMax not_isMax_bot).trans_le <| succ_mono bot_le\n\n"}
{"name":"Order.succ_ne_bot","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝³ : PartialOrder α\ninst✝² : SuccOrder α\ninst✝¹ : OrderBot α\ninst✝ : Nontrivial α\na : α\n⊢ Ne (Order.succ a) Bot.bot","decl":"theorem succ_ne_bot (a : α) : succ a ≠ ⊥ :=\n  (bot_lt_succ a).ne'\n\n"}
{"name":"Order.le_of_lt_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\na b : α\na✝ : LT.lt a (Order.succ b)\n⊢ LE.le a b","decl":"theorem le_of_lt_succ {a b : α} : a < succ b → a ≤ b := fun h ↦ by\n  by_contra! nh\n  exact (h.trans_le (succ_le_of_lt nh)).false\n\n"}
{"name":"Order.lt_succ_iff_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\na b : α\nha : Not (IsMax a)\n⊢ Iff (LT.lt b (Order.succ a)) (LE.le b a)","decl":"theorem lt_succ_iff_of_not_isMax (ha : ¬IsMax a) : b < succ a ↔ b ≤ a :=\n  ⟨le_of_lt_succ, fun h => h.trans_lt <| lt_succ_of_not_isMax ha⟩\n\n"}
{"name":"Order.succ_lt_succ_iff_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\na b : α\nha : Not (IsMax a)\nhb : Not (IsMax b)\n⊢ Iff (LT.lt (Order.succ a) (Order.succ b)) (LT.lt a b)","decl":"theorem succ_lt_succ_iff_of_not_isMax (ha : ¬IsMax a) (hb : ¬IsMax b) :\n    succ a < succ b ↔ a < b := by\n  rw [lt_succ_iff_of_not_isMax hb, succ_le_iff_of_not_isMax ha]\n\n"}
{"name":"Order.succ_le_succ_iff_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\na b : α\nha : Not (IsMax a)\nhb : Not (IsMax b)\n⊢ Iff (LE.le (Order.succ a) (Order.succ b)) (LE.le a b)","decl":"theorem succ_le_succ_iff_of_not_isMax (ha : ¬IsMax a) (hb : ¬IsMax b) :\n    succ a ≤ succ b ↔ a ≤ b := by\n  rw [succ_le_iff_of_not_isMax ha, lt_succ_iff_of_not_isMax hb]\n\n"}
{"name":"Order.Iio_succ_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\na : α\nha : Not (IsMax a)\n⊢ Eq (Set.Iio (Order.succ a)) (Set.Iic a)","decl":"theorem Iio_succ_of_not_isMax (ha : ¬IsMax a) : Iio (succ a) = Iic a :=\n  Set.ext fun _ => lt_succ_iff_of_not_isMax ha\n\n"}
{"name":"Order.Ico_succ_right_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\na b : α\nhb : Not (IsMax b)\n⊢ Eq (Set.Ico a (Order.succ b)) (Set.Icc a b)","decl":"theorem Ico_succ_right_of_not_isMax (hb : ¬IsMax b) : Ico a (succ b) = Icc a b := by\n  rw [← Ici_inter_Iio, Iio_succ_of_not_isMax hb, Ici_inter_Iic]\n\n"}
{"name":"Order.Ioo_succ_right_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\na b : α\nhb : Not (IsMax b)\n⊢ Eq (Set.Ioo a (Order.succ b)) (Set.Ioc a b)","decl":"theorem Ioo_succ_right_of_not_isMax (hb : ¬IsMax b) : Ioo a (succ b) = Ioc a b := by\n  rw [← Ioi_inter_Iio, Iio_succ_of_not_isMax hb, Ioi_inter_Iic]\n\n"}
{"name":"Order.succ_eq_succ_iff_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\na b : α\nha : Not (IsMax a)\nhb : Not (IsMax b)\n⊢ Iff (Eq (Order.succ a) (Order.succ b)) (Eq a b)","decl":"theorem succ_eq_succ_iff_of_not_isMax (ha : ¬IsMax a) (hb : ¬IsMax b) :\n    succ a = succ b ↔ a = b := by\n  rw [eq_iff_le_not_lt, eq_iff_le_not_lt, succ_le_succ_iff_of_not_isMax ha hb,\n    succ_lt_succ_iff_of_not_isMax ha hb]\n\n"}
{"name":"Order.le_succ_iff_eq_or_le","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\na b : α\n⊢ Iff (LE.le a (Order.succ b)) (Or (Eq a (Order.succ b)) (LE.le a b))","decl":"theorem le_succ_iff_eq_or_le : a ≤ succ b ↔ a = succ b ∨ a ≤ b := by\n  by_cases hb : IsMax b\n  · rw [hb.succ_eq, or_iff_right_of_imp le_of_eq]\n  · rw [← lt_succ_iff_of_not_isMax hb, le_iff_eq_or_lt]\n\n"}
{"name":"Order.lt_succ_iff_eq_or_lt_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\na b : α\nhb : Not (IsMax b)\n⊢ Iff (LT.lt a (Order.succ b)) (Or (Eq a b) (LT.lt a b))","decl":"theorem lt_succ_iff_eq_or_lt_of_not_isMax (hb : ¬IsMax b) : a < succ b ↔ a = b ∨ a < b :=\n  (lt_succ_iff_of_not_isMax hb).trans le_iff_eq_or_lt\n\n"}
{"name":"Order.not_isMin_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\ninst✝ : Nontrivial α\na : α\n⊢ Not (IsMin (Order.succ a))","decl":"theorem not_isMin_succ [Nontrivial α] (a : α) : ¬ IsMin (succ a) := by\n  obtain ha | ha := (le_succ a).eq_or_lt\n  · exact (ha ▸ succ_eq_iff_isMax.1 ha.symm).not_isMin\n  · exact not_isMin_of_lt ha\n\n"}
{"name":"Order.Iic_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\na : α\n⊢ Eq (Set.Iic (Order.succ a)) (Insert.insert (Order.succ a) (Set.Iic a))","decl":"theorem Iic_succ (a : α) : Iic (succ a) = insert (succ a) (Iic a) :=\n  ext fun _ => le_succ_iff_eq_or_le\n\n"}
{"name":"Order.Icc_succ_right","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\na b : α\nh : LE.le a (Order.succ b)\n⊢ Eq (Set.Icc a (Order.succ b)) (Insert.insert (Order.succ b) (Set.Icc a b))","decl":"theorem Icc_succ_right (h : a ≤ succ b) : Icc a (succ b) = insert (succ b) (Icc a b) := by\n  simp_rw [← Ici_inter_Iic, Iic_succ, inter_insert_of_mem (mem_Ici.2 h)]\n\n"}
{"name":"Order.Ioc_succ_right","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\na b : α\nh : LT.lt a (Order.succ b)\n⊢ Eq (Set.Ioc a (Order.succ b)) (Insert.insert (Order.succ b) (Set.Ioc a b))","decl":"theorem Ioc_succ_right (h : a < succ b) : Ioc a (succ b) = insert (succ b) (Ioc a b) := by\n  simp_rw [← Ioi_inter_Iic, Iic_succ, inter_insert_of_mem (mem_Ioi.2 h)]\n\n"}
{"name":"Order.Iio_succ_eq_insert_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\na : α\nh : Not (IsMax a)\n⊢ Eq (Set.Iio (Order.succ a)) (Insert.insert a (Set.Iio a))","decl":"theorem Iio_succ_eq_insert_of_not_isMax (h : ¬IsMax a) : Iio (succ a) = insert a (Iio a) :=\n  ext fun _ => lt_succ_iff_eq_or_lt_of_not_isMax h\n\n"}
{"name":"Order.Ico_succ_right_eq_insert_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\na b : α\nh₁ : LE.le a b\nh₂ : Not (IsMax b)\n⊢ Eq (Set.Ico a (Order.succ b)) (Insert.insert b (Set.Ico a b))","decl":"theorem Ico_succ_right_eq_insert_of_not_isMax (h₁ : a ≤ b) (h₂ : ¬IsMax b) :\n    Ico a (succ b) = insert b (Ico a b) := by\n  simp_rw [← Iio_inter_Ici, Iio_succ_eq_insert_of_not_isMax h₂, insert_inter_of_mem (mem_Ici.2 h₁)]\n\n"}
{"name":"Order.Ioo_succ_right_eq_insert_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : SuccOrder α\na b : α\nh₁ : LT.lt a b\nh₂ : Not (IsMax b)\n⊢ Eq (Set.Ioo a (Order.succ b)) (Insert.insert b (Set.Ioo a b))","decl":"theorem Ioo_succ_right_eq_insert_of_not_isMax (h₁ : a < b) (h₂ : ¬IsMax b) :\n    Ioo a (succ b) = insert b (Ioo a b) := by\n  simp_rw [← Iio_inter_Ioi, Iio_succ_eq_insert_of_not_isMax h₂, insert_inter_of_mem (mem_Ioi.2 h₁)]\n\n"}
{"name":"Order.lt_succ_iff","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\na b : α\ninst✝ : NoMaxOrder α\n⊢ Iff (LT.lt a (Order.succ b)) (LE.le a b)","decl":"@[simp]\ntheorem lt_succ_iff : a < succ b ↔ a ≤ b :=\n  lt_succ_iff_of_not_isMax <| not_isMax b\n\n"}
{"name":"Order.succ_le_succ_iff","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\na b : α\ninst✝ : NoMaxOrder α\n⊢ Iff (LE.le (Order.succ a) (Order.succ b)) (LE.le a b)","decl":"theorem succ_le_succ_iff : succ a ≤ succ b ↔ a ≤ b := by simp\n"}
{"name":"Order.succ_lt_succ_iff","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\na b : α\ninst✝ : NoMaxOrder α\n⊢ Iff (LT.lt (Order.succ a) (Order.succ b)) (LT.lt a b)","decl":"theorem succ_lt_succ_iff : succ a < succ b ↔ a < b := by simp\n\n"}
{"name":"Order.le_of_succ_le_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\na b : α\ninst✝ : NoMaxOrder α\na✝ : LE.le (Order.succ a) (Order.succ b)\n⊢ LE.le a b","decl":"alias ⟨le_of_succ_le_succ, _⟩ := succ_le_succ_iff\n"}
{"name":"Order.lt_of_succ_lt_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\na b : α\ninst✝ : NoMaxOrder α\na✝ : LT.lt (Order.succ a) (Order.succ b)\n⊢ LT.lt a b","decl":"alias ⟨lt_of_succ_lt_succ, _⟩ := succ_lt_succ_iff\n\n-- TODO: prove for a succ-archimedean non-linear order with bottom\n"}
{"name":"Order.Iio_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\na : α\n⊢ Eq (Set.Iio (Order.succ a)) (Set.Iic a)","decl":"@[simp]\ntheorem Iio_succ (a : α) : Iio (succ a) = Iic a :=\n  Iio_succ_of_not_isMax <| not_isMax _\n\n"}
{"name":"Order.Ico_succ_right","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\na b : α\n⊢ Eq (Set.Ico a (Order.succ b)) (Set.Icc a b)","decl":"@[simp]\ntheorem Ico_succ_right (a b : α) : Ico a (succ b) = Icc a b :=\n  Ico_succ_right_of_not_isMax <| not_isMax _\n\n-- TODO: prove for a succ-archimedean non-linear order\n"}
{"name":"Order.Ioo_succ_right","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\na b : α\n⊢ Eq (Set.Ioo a (Order.succ b)) (Set.Ioc a b)","decl":"@[simp]\ntheorem Ioo_succ_right (a b : α) : Ioo a (succ b) = Ioc a b :=\n  Ioo_succ_right_of_not_isMax <| not_isMax _\n\n"}
{"name":"Order.succ_eq_succ_iff","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\na b : α\ninst✝ : NoMaxOrder α\n⊢ Iff (Eq (Order.succ a) (Order.succ b)) (Eq a b)","decl":"@[simp]\ntheorem succ_eq_succ_iff : succ a = succ b ↔ a = b :=\n  succ_eq_succ_iff_of_not_isMax (not_isMax a) (not_isMax b)\n\n"}
{"name":"Order.succ_injective","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\n⊢ Function.Injective Order.succ","decl":"theorem succ_injective : Injective (succ : α → α) := fun _ _ => succ_eq_succ_iff.1\n\n"}
{"name":"Order.succ_ne_succ_iff","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\na b : α\ninst✝ : NoMaxOrder α\n⊢ Iff (Ne (Order.succ a) (Order.succ b)) (Ne a b)","decl":"theorem succ_ne_succ_iff : succ a ≠ succ b ↔ a ≠ b :=\n  succ_injective.ne_iff\n\n"}
{"name":"Order.succ_ne_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\na b : α\ninst✝ : NoMaxOrder α\na✝ : Ne a b\n⊢ Ne (Order.succ a) (Order.succ b)","decl":"alias ⟨_, succ_ne_succ⟩ := succ_ne_succ_iff\n\n"}
{"name":"Order.lt_succ_iff_eq_or_lt","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\na b : α\ninst✝ : NoMaxOrder α\n⊢ Iff (LT.lt a (Order.succ b)) (Or (Eq a b) (LT.lt a b))","decl":"theorem lt_succ_iff_eq_or_lt : a < succ b ↔ a = b ∨ a < b :=\n  lt_succ_iff.trans le_iff_eq_or_lt\n\n"}
{"name":"Order.Iio_succ_eq_insert","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\na : α\n⊢ Eq (Set.Iio (Order.succ a)) (Insert.insert a (Set.Iio a))","decl":"theorem Iio_succ_eq_insert (a : α) : Iio (succ a) = insert a (Iio a) :=\n  Iio_succ_eq_insert_of_not_isMax <| not_isMax a\n\n"}
{"name":"Order.Ico_succ_right_eq_insert","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\na b : α\ninst✝ : NoMaxOrder α\nh : LE.le a b\n⊢ Eq (Set.Ico a (Order.succ b)) (Insert.insert b (Set.Ico a b))","decl":"theorem Ico_succ_right_eq_insert (h : a ≤ b) : Ico a (succ b) = insert b (Ico a b) :=\n  Ico_succ_right_eq_insert_of_not_isMax h <| not_isMax b\n\n"}
{"name":"Order.Ioo_succ_right_eq_insert","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\na b : α\ninst✝ : NoMaxOrder α\nh : LT.lt a b\n⊢ Eq (Set.Ioo a (Order.succ b)) (Insert.insert b (Set.Ioo a b))","decl":"theorem Ioo_succ_right_eq_insert (h : a < b) : Ioo a (succ b) = insert b (Ioo a b) :=\n  Ioo_succ_right_eq_insert_of_not_isMax h <| not_isMax b\n\n"}
{"name":"Order.lt_succ_bot_iff","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝³ : LinearOrder α\ninst✝² : SuccOrder α\na : α\ninst✝¹ : OrderBot α\ninst✝ : NoMaxOrder α\n⊢ Iff (LT.lt a (Order.succ Bot.bot)) (Eq a Bot.bot)","decl":"theorem lt_succ_bot_iff [NoMaxOrder α] : a < succ ⊥ ↔ a = ⊥ := by rw [lt_succ_iff, le_bot_iff]\n\n"}
{"name":"Order.le_succ_bot_iff","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\na : α\ninst✝ : OrderBot α\n⊢ Iff (LE.le a (Order.succ Bot.bot)) (Or (Eq a Bot.bot) (Eq a (Order.succ Bot.bot)))","decl":"theorem le_succ_bot_iff : a ≤ succ ⊥ ↔ a = ⊥ ∨ a = succ ⊥ := by\n  rw [le_succ_iff_eq_or_le, le_bot_iff, or_comm]\n\n"}
{"name":"Order.instSubsingletonSuccOrder","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ Subsingleton (SuccOrder α)","decl":"/-- There is at most one way to define the successors in a `PartialOrder`. -/\ninstance [PartialOrder α] : Subsingleton (SuccOrder α) :=\n  ⟨by\n    intro h₀ h₁\n    ext a\n    by_cases ha : IsMax a\n    · exact (@IsMax.succ_eq _ _ h₀ _ ha).trans ha.succ_eq.symm\n    · exact @CovBy.succ_eq _ _ h₀ _ _ (covBy_succ_of_not_isMax ha)⟩\n\n"}
{"name":"Order.succ_eq_sInf","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CompleteLattice α\ninst✝ : SuccOrder α\na : α\n⊢ Eq (Order.succ a) (InfSet.sInf (Set.Ioi a))","decl":"theorem succ_eq_sInf [CompleteLattice α] [SuccOrder α] (a : α) :\n    succ a = sInf (Set.Ioi a) := by\n  apply (le_sInf fun b => succ_le_of_lt).antisymm\n  obtain rfl | ha := eq_or_ne a ⊤\n  · rw [succ_top]\n    exact le_top\n  · exact sInf_le (lt_succ_iff_ne_top.2 ha)\n\n"}
{"name":"Order.succ_eq_iInf","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CompleteLattice α\ninst✝ : SuccOrder α\na : α\n⊢ Eq (Order.succ a) (iInf fun b => iInf fun h => b)","decl":"theorem succ_eq_iInf [CompleteLattice α] [SuccOrder α] (a : α) : succ a = ⨅ b > a, b := by\n  rw [succ_eq_sInf, iInf_subtype', iInf, Subtype.range_coe_subtype, Ioi]\n\n"}
{"name":"Order.succ_eq_csInf","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\na : α\n⊢ Eq (Order.succ a) (InfSet.sInf (Set.Ioi a))","decl":"theorem succ_eq_csInf [ConditionallyCompleteLattice α] [SuccOrder α] [NoMaxOrder α] (a : α) :\n    succ a = sInf (Set.Ioi a) := by\n  apply (le_csInf nonempty_Ioi fun b => succ_le_of_lt).antisymm\n  exact csInf_le ⟨a, fun b => le_of_lt⟩ <| lt_succ a\n\n"}
{"name":"Order.pred_le","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na : α\n⊢ LE.le (Order.pred a) a","decl":"theorem pred_le : ∀ a : α, pred a ≤ a :=\n  PredOrder.pred_le\n\n"}
{"name":"Order.min_of_le_pred","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na : α\na✝ : LE.le a (Order.pred a)\n⊢ IsMin a","decl":"theorem min_of_le_pred {a : α} : a ≤ pred a → IsMin a :=\n  PredOrder.min_of_le_pred\n\n"}
{"name":"Order.le_pred_of_lt","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na b : α\na✝ : LT.lt a b\n⊢ LE.le a (Order.pred b)","decl":"theorem le_pred_of_lt {a b : α} : a < b → a ≤ pred b :=\n  PredOrder.le_pred_of_lt\n\n"}
{"name":"LT.lt.le_pred","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na b : α\na✝ : LT.lt a b\n⊢ LE.le a (Order.pred b)","decl":"alias _root_.LT.lt.le_pred := le_pred_of_lt\n\n"}
{"name":"Order.le_pred_iff_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na : α\n⊢ Iff (LE.le a (Order.pred a)) (IsMin a)","decl":"@[simp]\ntheorem le_pred_iff_isMin : a ≤ pred a ↔ IsMin a :=\n  ⟨min_of_le_pred, fun h => h <| pred_le _⟩\n\n"}
{"name":"IsMin.le_pred","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na : α\na✝ : IsMin a\n⊢ LE.le a (Order.pred a)","decl":"alias ⟨_root_.IsMin.of_le_pred, _root_.IsMin.le_pred⟩ := le_pred_iff_isMin\n\n"}
{"name":"IsMin.of_le_pred","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na : α\na✝ : LE.le a (Order.pred a)\n⊢ IsMin a","decl":"alias ⟨_root_.IsMin.of_le_pred, _root_.IsMin.le_pred⟩ := le_pred_iff_isMin\n\n"}
{"name":"Order.pred_lt_iff_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na : α\n⊢ Iff (LT.lt (Order.pred a) a) (Not (IsMin a))","decl":"@[simp]\ntheorem pred_lt_iff_not_isMin : pred a < a ↔ ¬IsMin a :=\n  ⟨not_isMin_of_lt, fun ha => (pred_le a).lt_of_not_le fun h => ha <| min_of_le_pred h⟩\n\n"}
{"name":"Order.pred_lt_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na : α\na✝ : Not (IsMin a)\n⊢ LT.lt (Order.pred a) a","decl":"alias ⟨_, pred_lt_of_not_isMin⟩ := pred_lt_iff_not_isMin\n\n"}
{"name":"Order.pred_wcovBy","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na : α\n⊢ WCovBy (Order.pred a) a","decl":"theorem pred_wcovBy (a : α) : pred a ⩿ a :=\n  ⟨pred_le a, fun _ hb nh => (le_pred_of_lt nh).not_lt hb⟩\n\n"}
{"name":"Order.pred_covBy_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na : α\nh : Not (IsMin a)\n⊢ CovBy (Order.pred a) a","decl":"theorem pred_covBy_of_not_isMin (h : ¬IsMin a) : pred a ⋖ a :=\n  (pred_wcovBy a).covBy_of_lt <| pred_lt_of_not_isMin h\n\n"}
{"name":"Order.pred_lt_of_not_isMin_of_le","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na b : α\nha : Not (IsMin a)\na✝ : LE.le a b\n⊢ LT.lt (Order.pred a) b","decl":"theorem pred_lt_of_not_isMin_of_le (ha : ¬IsMin a) : a ≤ b → pred a < b :=\n  (pred_lt_of_not_isMin ha).trans_le\n\n"}
{"name":"Order.le_pred_iff_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na b : α\nha : Not (IsMin a)\n⊢ Iff (LE.le b (Order.pred a)) (LT.lt b a)","decl":"theorem le_pred_iff_of_not_isMin (ha : ¬IsMin a) : b ≤ pred a ↔ b < a :=\n  ⟨fun h => h.trans_lt <| pred_lt_of_not_isMin ha, le_pred_of_lt⟩\n\n"}
{"name":"Order.pred_lt_pred_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na b : α\nh : LT.lt a b\nha : Not (IsMin a)\n⊢ LT.lt (Order.pred a) (Order.pred b)","decl":"lemma pred_lt_pred_of_not_isMin (h : a < b) (ha : ¬ IsMin a) : pred a < pred b :=\n  pred_lt_of_not_isMin_of_le ha <| le_pred_of_lt h\n\n"}
{"name":"Order.pred_le_pred_of_not_isMin_of_le","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na b : α\nha : Not (IsMin a)\nhb : Not (IsMin b)\na✝ : LE.le a b\n⊢ LE.le (Order.pred a) (Order.pred b)","decl":"theorem pred_le_pred_of_not_isMin_of_le (ha : ¬IsMin a) (hb : ¬IsMin b) :\n    a ≤ b → pred a ≤ pred b := by\n  rw [le_pred_iff_of_not_isMin hb]\n  apply pred_lt_of_not_isMin_of_le ha\n\n"}
{"name":"Order.pred_le_pred","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na b : α\nh : LE.le a b\n⊢ LE.le (Order.pred a) (Order.pred b)","decl":"@[simp, mono]\ntheorem pred_le_pred {a b : α} (h : a ≤ b) : pred a ≤ pred b :=\n  succ_le_succ h.dual\n\n"}
{"name":"Order.pred_mono","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\n⊢ Monotone Order.pred","decl":"theorem pred_mono : Monotone (pred : α → α) := fun _ _ => pred_le_pred\n\n"}
{"name":"Order.pred_le_of_wcovBy","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na b : α\nh : WCovBy a b\n⊢ LE.le (Order.pred b) a","decl":"/-- See also `Order.pred_eq_of_covBy`. -/\nlemma pred_le_of_wcovBy (h : a ⩿ b) : pred b ≤ a := by\n  obtain hab | ⟨-, hba⟩ := h.covBy_or_le_and_le\n  · by_contra hba\n    exact h.2 (hab.lt.le_pred.lt_of_not_le hba) (pred_lt_of_not_isMin hab.lt.not_isMin)\n  · exact (pred_le _).trans hba\n\n"}
{"name":"WCovBy.pred_le","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na b : α\nh : WCovBy a b\n⊢ LE.le (Order.pred b) a","decl":"alias _root_.WCovBy.pred_le := pred_le_of_wcovBy\n\n"}
{"name":"Order.pred_iterate_le","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\nk : Nat\nx : α\n⊢ LE.le (Nat.iterate Order.pred k x) x","decl":"theorem pred_iterate_le (k : ℕ) (x : α) : pred^[k] x ≤ x := by\n  conv_rhs => rw [(by simp only [Function.iterate_id, id] : x = id^[k] x)]\n  exact Monotone.iterate_le_of_le pred_mono pred_le k x\n\n"}
{"name":"Order.isMin_iterate_pred_of_eq_of_lt","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na : α\nn m : Nat\nh_eq : Eq (Nat.iterate Order.pred n a) (Nat.iterate Order.pred m a)\nh_lt : LT.lt n m\n⊢ IsMin (Nat.iterate Order.pred n a)","decl":"theorem isMin_iterate_pred_of_eq_of_lt {n m : ℕ} (h_eq : pred^[n] a = pred^[m] a)\n    (h_lt : n < m) : IsMin (pred^[n] a) :=\n  @isMax_iterate_succ_of_eq_of_lt αᵒᵈ _ _ _ _ _ h_eq h_lt\n\n"}
{"name":"Order.isMin_iterate_pred_of_eq_of_ne","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na : α\nn m : Nat\nh_eq : Eq (Nat.iterate Order.pred n a) (Nat.iterate Order.pred m a)\nh_ne : Ne n m\n⊢ IsMin (Nat.iterate Order.pred n a)","decl":"theorem isMin_iterate_pred_of_eq_of_ne {n m : ℕ} (h_eq : pred^[n] a = pred^[m] a)\n    (h_ne : n ≠ m) : IsMin (pred^[n] a) :=\n  @isMax_iterate_succ_of_eq_of_ne αᵒᵈ _ _ _ _ _ h_eq h_ne\n\n"}
{"name":"Order.Ici_subset_Ioi_pred_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na : α\nha : Not (IsMin a)\n⊢ HasSubset.Subset (Set.Ici a) (Set.Ioi (Order.pred a))","decl":"theorem Ici_subset_Ioi_pred_of_not_isMin (ha : ¬IsMin a) : Ici a ⊆ Ioi (pred a) :=\n  fun _ ↦ pred_lt_of_not_isMin_of_le ha\n\n"}
{"name":"Order.Iic_pred_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na : α\nha : Not (IsMin a)\n⊢ Eq (Set.Iic (Order.pred a)) (Set.Iio a)","decl":"theorem Iic_pred_of_not_isMin (ha : ¬IsMin a) : Iic (pred a) = Iio a :=\n  Set.ext fun _ => le_pred_iff_of_not_isMin ha\n\n"}
{"name":"Order.Icc_subset_Ioc_pred_left_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na b : α\nha : Not (IsMin a)\n⊢ HasSubset.Subset (Set.Icc a b) (Set.Ioc (Order.pred a) b)","decl":"theorem Icc_subset_Ioc_pred_left_of_not_isMin (ha : ¬IsMin a) : Icc a b ⊆ Ioc (pred a) b := by\n rw [← Ioi_inter_Iic, ← Ici_inter_Iic]\n gcongr\n apply Ici_subset_Ioi_pred_of_not_isMin ha\n\n"}
{"name":"Order.Ico_subset_Ioo_pred_left_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na b : α\nha : Not (IsMin a)\n⊢ HasSubset.Subset (Set.Ico a b) (Set.Ioo (Order.pred a) b)","decl":"theorem Ico_subset_Ioo_pred_left_of_not_isMin (ha : ¬IsMin a) : Ico a b ⊆ Ioo (pred a) b  := by\n  rw [← Ioi_inter_Iio, ← Ici_inter_Iio]\n  gcongr\n  apply Ici_subset_Ioi_pred_of_not_isMin ha\n\n"}
{"name":"Order.Icc_pred_right_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na b : α\nha : Not (IsMin b)\n⊢ Eq (Set.Icc a (Order.pred b)) (Set.Ico a b)","decl":"theorem Icc_pred_right_of_not_isMin (ha : ¬IsMin b) : Icc a (pred b) = Ico a b := by\n  rw [← Ici_inter_Iic, Iic_pred_of_not_isMin ha, Ici_inter_Iio]\n\n"}
{"name":"Order.Ioc_pred_right_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : PredOrder α\na b : α\nha : Not (IsMin b)\n⊢ Eq (Set.Ioc a (Order.pred b)) (Set.Ioo a b)","decl":"theorem Ioc_pred_right_of_not_isMin (ha : ¬IsMin b) : Ioc a (pred b) = Ioo a b := by\n  rw [← Ioi_inter_Iic, Iic_pred_of_not_isMin ha, Ioi_inter_Iio]\n\n"}
{"name":"Order.pred_lt","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\na : α\n⊢ LT.lt (Order.pred a) a","decl":"theorem pred_lt (a : α) : pred a < a :=\n  pred_lt_of_not_isMin <| not_isMin a\n\n"}
{"name":"Order.pred_lt_of_le","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\na b : α\ninst✝ : NoMinOrder α\na✝ : LE.le a b\n⊢ LT.lt (Order.pred a) b","decl":"@[simp]\ntheorem pred_lt_of_le : a ≤ b → pred a < b :=\n  pred_lt_of_not_isMin_of_le <| not_isMin a\n\n"}
{"name":"Order.le_pred_iff","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\na b : α\ninst✝ : NoMinOrder α\n⊢ Iff (LE.le a (Order.pred b)) (LT.lt a b)","decl":"@[simp]\ntheorem le_pred_iff : a ≤ pred b ↔ a < b :=\n  le_pred_iff_of_not_isMin <| not_isMin b\n\n"}
{"name":"Order.pred_le_pred_of_le","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\na b : α\ninst✝ : NoMinOrder α\na✝ : LE.le a b\n⊢ LE.le (Order.pred a) (Order.pred b)","decl":"theorem pred_le_pred_of_le : a ≤ b → pred a ≤ pred b := by intro; simp_all\n\n"}
{"name":"Order.pred_lt_pred","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\na b : α\ninst✝ : NoMinOrder α\na✝ : LT.lt a b\n⊢ LT.lt (Order.pred a) (Order.pred b)","decl":"theorem pred_lt_pred : a < b → pred a < pred b := by intro; simp_all\n\n"}
{"name":"Order.pred_strictMono","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\n⊢ StrictMono Order.pred","decl":"theorem pred_strictMono : StrictMono (pred : α → α) := fun _ _ => pred_lt_pred\n\n"}
{"name":"Order.pred_covBy","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\na : α\n⊢ CovBy (Order.pred a) a","decl":"theorem pred_covBy (a : α) : pred a ⋖ a :=\n  pred_covBy_of_not_isMin <| not_isMin a\n\n"}
{"name":"Order.Ici_subset_Ioi_pred","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\na : α\n⊢ HasSubset.Subset (Set.Ici a) (Set.Ioi (Order.pred a))","decl":"@[simp]\ntheorem Ici_subset_Ioi_pred (a : α) : Ici a ⊆ Ioi (pred a) :=\n  Ici_subset_Ioi_pred_of_not_isMin <| not_isMin a\n\n"}
{"name":"Order.Iic_pred","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\na : α\n⊢ Eq (Set.Iic (Order.pred a)) (Set.Iio a)","decl":"@[simp]\ntheorem Iic_pred (a : α) : Iic (pred a) = Iio a :=\n  Iic_pred_of_not_isMin <| not_isMin a\n\n"}
{"name":"Order.Icc_subset_Ioc_pred_left","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\na b : α\n⊢ HasSubset.Subset (Set.Icc a b) (Set.Ioc (Order.pred a) b)","decl":"@[simp]\ntheorem Icc_subset_Ioc_pred_left (a b : α) : Icc a b ⊆ Ioc (pred a) b :=\n  Icc_subset_Ioc_pred_left_of_not_isMin <| not_isMin _\n\n"}
{"name":"Order.Ico_subset_Ioo_pred_left","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\na b : α\n⊢ HasSubset.Subset (Set.Ico a b) (Set.Ioo (Order.pred a) b)","decl":"@[simp]\ntheorem Ico_subset_Ioo_pred_left (a b : α) : Ico a b ⊆ Ioo (pred a) b :=\n  Ico_subset_Ioo_pred_left_of_not_isMin <| not_isMin _\n\n"}
{"name":"Order.Icc_pred_right","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\na b : α\n⊢ Eq (Set.Icc a (Order.pred b)) (Set.Ico a b)","decl":"@[simp]\ntheorem Icc_pred_right (a b : α) : Icc a (pred b) = Ico a b :=\n  Icc_pred_right_of_not_isMin <| not_isMin _\n\n"}
{"name":"Order.Ioc_pred_right","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\na b : α\n⊢ Eq (Set.Ioc a (Order.pred b)) (Set.Ioo a b)","decl":"@[simp]\ntheorem Ioc_pred_right (a b : α) : Ioc a (pred b) = Ioo a b :=\n  Ioc_pred_right_of_not_isMin <| not_isMin _\n\n"}
{"name":"Order.pred_eq_iff_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\na : α\n⊢ Iff (Eq (Order.pred a) a) (IsMin a)","decl":"@[simp]\ntheorem pred_eq_iff_isMin : pred a = a ↔ IsMin a :=\n  ⟨fun h => min_of_le_pred h.ge, fun h => h.eq_of_le <| pred_le _⟩\n\n"}
{"name":"IsMin.pred_eq","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\na : α\na✝ : IsMin a\n⊢ Eq (Order.pred a) a","decl":"alias ⟨_, _root_.IsMin.pred_eq⟩ := pred_eq_iff_isMin\n\n"}
{"name":"Order.pred_le_le_iff","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\na b : α\n⊢ Iff (And (LE.le (Order.pred a) b) (LE.le b a)) (Or (Eq b a) (Eq b (Order.pred a)))","decl":"theorem pred_le_le_iff {a b : α} : pred a ≤ b ∧ b ≤ a ↔ b = a ∨ b = pred a := by\n  refine\n    ⟨fun h =>\n      or_iff_not_imp_left.2 fun hba : b ≠ a => (le_pred_of_lt <| h.2.lt_of_ne hba).antisymm h.1, ?_⟩\n  rintro (rfl | rfl)\n  · exact ⟨pred_le b, le_rfl⟩\n  · exact ⟨le_rfl, pred_le a⟩\n\n"}
{"name":"Order.pred_eq_of_covBy","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\na b : α\nh : CovBy a b\n⊢ Eq (Order.pred b) a","decl":"/-- See also `Order.pred_le_of_wcovBy`. -/\nlemma pred_eq_of_covBy (h : a ⋖ b) : pred b = a := h.wcovBy.pred_le.antisymm (le_pred_of_lt h.lt)\n\n"}
{"name":"CovBy.pred_eq","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : PredOrder α\na b : α\nh : CovBy a b\n⊢ Eq (Order.pred b) a","decl":"alias _root_.CovBy.pred_eq := pred_eq_of_covBy\n\n"}
{"name":"OrderIso.map_pred","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝³ : PartialOrder α\ninst✝² : PredOrder α\nβ : Type u_3\ninst✝¹ : PartialOrder β\ninst✝ : PredOrder β\nf : OrderIso α β\na : α\n⊢ Eq (f (Order.pred a)) (Order.pred (f a))","decl":"theorem _root_.OrderIso.map_pred {β : Type*} [PartialOrder β] [PredOrder β] (f : α ≃o β) (a : α) :\n    f (pred a) = pred (f a) :=\n  f.dual.map_succ a\n\n"}
{"name":"Order.pred_eq_iff_covBy","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\na b : α\ninst✝ : NoMinOrder α\n⊢ Iff (Eq (Order.pred b) a) (CovBy a b)","decl":"theorem pred_eq_iff_covBy : pred b = a ↔ a ⋖ b :=\n  ⟨by\n    rintro rfl\n    exact pred_covBy _, CovBy.pred_eq⟩\n\n"}
{"name":"Order.pred_bot","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\ninst✝ : OrderBot α\n⊢ Eq (Order.pred Bot.bot) Bot.bot","decl":"@[simp]\ntheorem pred_bot : pred (⊥ : α) = ⊥ :=\n  isMin_bot.pred_eq\n\n"}
{"name":"Order.le_pred_iff_eq_bot","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\na : α\ninst✝ : OrderBot α\n⊢ Iff (LE.le a (Order.pred a)) (Eq a Bot.bot)","decl":"theorem le_pred_iff_eq_bot : a ≤ pred a ↔ a = ⊥ :=\n  @succ_le_iff_eq_top αᵒᵈ _ _ _ _\n\n"}
{"name":"Order.pred_lt_iff_ne_bot","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\na : α\ninst✝ : OrderBot α\n⊢ Iff (LT.lt (Order.pred a) a) (Ne a Bot.bot)","decl":"theorem pred_lt_iff_ne_bot : pred a < a ↔ a ≠ ⊥ :=\n  @lt_succ_iff_ne_top αᵒᵈ _ _ _ _\n\n"}
{"name":"Order.pred_lt_top","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝³ : PartialOrder α\ninst✝² : PredOrder α\ninst✝¹ : OrderTop α\ninst✝ : Nontrivial α\na : α\n⊢ LT.lt (Order.pred a) Top.top","decl":"theorem pred_lt_top (a : α) : pred a < ⊤ :=\n  (pred_mono le_top).trans_lt <| pred_lt_of_not_isMin not_isMin_top\n\n"}
{"name":"Order.pred_ne_top","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝³ : PartialOrder α\ninst✝² : PredOrder α\ninst✝¹ : OrderTop α\ninst✝ : Nontrivial α\na : α\n⊢ Ne (Order.pred a) Top.top","decl":"theorem pred_ne_top (a : α) : pred a ≠ ⊤ :=\n  (pred_lt_top a).ne\n\n"}
{"name":"Order.le_of_pred_lt","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\na b : α\na✝ : LT.lt (Order.pred a) b\n⊢ LE.le a b","decl":"theorem le_of_pred_lt {a b : α} : pred a < b → a ≤ b := fun h ↦ by\n  by_contra! nh\n  exact le_pred_of_lt nh |>.trans_lt h |>.false\n\n"}
{"name":"Order.pred_lt_iff_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\na b : α\nha : Not (IsMin a)\n⊢ Iff (LT.lt (Order.pred a) b) (LE.le a b)","decl":"theorem pred_lt_iff_of_not_isMin (ha : ¬IsMin a) : pred a < b ↔ a ≤ b :=\n  ⟨le_of_pred_lt, (pred_lt_of_not_isMin ha).trans_le⟩\n\n"}
{"name":"Order.pred_lt_pred_iff_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\na b : α\nha : Not (IsMin a)\nhb : Not (IsMin b)\n⊢ Iff (LT.lt (Order.pred a) (Order.pred b)) (LT.lt a b)","decl":"theorem pred_lt_pred_iff_of_not_isMin (ha : ¬IsMin a) (hb : ¬IsMin b) :\n    pred a < pred b ↔ a < b := by\n  rw [pred_lt_iff_of_not_isMin ha, le_pred_iff_of_not_isMin hb]\n\n"}
{"name":"Order.pred_le_pred_iff_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\na b : α\nha : Not (IsMin a)\nhb : Not (IsMin b)\n⊢ Iff (LE.le (Order.pred a) (Order.pred b)) (LE.le a b)","decl":"theorem pred_le_pred_iff_of_not_isMin (ha : ¬IsMin a) (hb : ¬IsMin b) :\n    pred a ≤ pred b ↔ a ≤ b := by\n  rw [le_pred_iff_of_not_isMin hb, pred_lt_iff_of_not_isMin ha]\n\n"}
{"name":"Order.Ioi_pred_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\na : α\nha : Not (IsMin a)\n⊢ Eq (Set.Ioi (Order.pred a)) (Set.Ici a)","decl":"theorem Ioi_pred_of_not_isMin (ha : ¬IsMin a) : Ioi (pred a) = Ici a :=\n  Set.ext fun _ => pred_lt_iff_of_not_isMin ha\n\n"}
{"name":"Order.Ioc_pred_left_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\na b : α\nha : Not (IsMin a)\n⊢ Eq (Set.Ioc (Order.pred a) b) (Set.Icc a b)","decl":"theorem Ioc_pred_left_of_not_isMin (ha : ¬IsMin a) : Ioc (pred a) b = Icc a b := by\n  rw [← Ioi_inter_Iic, Ioi_pred_of_not_isMin ha, Ici_inter_Iic]\n\n"}
{"name":"Order.Ioo_pred_left_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\na b : α\nha : Not (IsMin a)\n⊢ Eq (Set.Ioo (Order.pred a) b) (Set.Ico a b)","decl":"theorem Ioo_pred_left_of_not_isMin (ha : ¬IsMin a) : Ioo (pred a) b = Ico a b := by\n  rw [← Ioi_inter_Iio, Ioi_pred_of_not_isMin ha, Ici_inter_Iio]\n\n"}
{"name":"Order.pred_eq_pred_iff_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\na b : α\nha : Not (IsMin a)\nhb : Not (IsMin b)\n⊢ Iff (Eq (Order.pred a) (Order.pred b)) (Eq a b)","decl":"theorem pred_eq_pred_iff_of_not_isMin (ha : ¬IsMin a) (hb : ¬IsMin b) :\n    pred a = pred b ↔ a = b := by\n  rw [eq_iff_le_not_lt, eq_iff_le_not_lt, pred_le_pred_iff_of_not_isMin ha hb,\n    pred_lt_pred_iff_of_not_isMin ha hb]\n\n"}
{"name":"Order.pred_le_iff_eq_or_le","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\na b : α\n⊢ Iff (LE.le (Order.pred a) b) (Or (Eq b (Order.pred a)) (LE.le a b))","decl":"theorem pred_le_iff_eq_or_le : pred a ≤ b ↔ b = pred a ∨ a ≤ b := by\n  by_cases ha : IsMin a\n  · rw [ha.pred_eq, or_iff_right_of_imp ge_of_eq]\n  · rw [← pred_lt_iff_of_not_isMin ha, le_iff_eq_or_lt, eq_comm]\n\n"}
{"name":"Order.pred_lt_iff_eq_or_lt_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\na b : α\nha : Not (IsMin a)\n⊢ Iff (LT.lt (Order.pred a) b) (Or (Eq a b) (LT.lt a b))","decl":"theorem pred_lt_iff_eq_or_lt_of_not_isMin (ha : ¬IsMin a) : pred a < b ↔ a = b ∨ a < b :=\n  (pred_lt_iff_of_not_isMin ha).trans le_iff_eq_or_lt\n\n"}
{"name":"Order.not_isMax_pred","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\ninst✝ : Nontrivial α\na : α\n⊢ Not (IsMax (Order.pred a))","decl":"theorem not_isMax_pred [Nontrivial α] (a : α) : ¬ IsMax (pred a) :=\n  not_isMin_succ (α := αᵒᵈ) a\n\n"}
{"name":"Order.Ici_pred","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\na : α\n⊢ Eq (Set.Ici (Order.pred a)) (Insert.insert (Order.pred a) (Set.Ici a))","decl":"theorem Ici_pred (a : α) : Ici (pred a) = insert (pred a) (Ici a) :=\n  ext fun _ => pred_le_iff_eq_or_le\n\n"}
{"name":"Order.Ioi_pred_eq_insert_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\na : α\nha : Not (IsMin a)\n⊢ Eq (Set.Ioi (Order.pred a)) (Insert.insert a (Set.Ioi a))","decl":"theorem Ioi_pred_eq_insert_of_not_isMin (ha : ¬IsMin a) : Ioi (pred a) = insert a (Ioi a) := by\n  ext x; simp only [insert, mem_setOf, @eq_comm _ x a, mem_Ioi, Set.insert]\n  exact pred_lt_iff_eq_or_lt_of_not_isMin ha\n\n"}
{"name":"Order.Icc_pred_left","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\na b : α\nh : LE.le (Order.pred a) b\n⊢ Eq (Set.Icc (Order.pred a) b) (Insert.insert (Order.pred a) (Set.Icc a b))","decl":"theorem Icc_pred_left (h : pred a ≤ b) : Icc (pred a) b = insert (pred a) (Icc a b) := by\n  simp_rw [← Ici_inter_Iic, Ici_pred, insert_inter_of_mem (mem_Iic.2 h)]\n\n"}
{"name":"Order.Ico_pred_left","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\ninst✝ : PredOrder α\na b : α\nh : LT.lt (Order.pred a) b\n⊢ Eq (Set.Ico (Order.pred a) b) (Insert.insert (Order.pred a) (Set.Ico a b))","decl":"theorem Ico_pred_left (h : pred a < b) : Ico (pred a) b = insert (pred a) (Ico a b) := by\n  simp_rw [← Ici_inter_Iio, Ici_pred, insert_inter_of_mem (mem_Iio.2 h)]\n\n"}
{"name":"Order.pred_lt_iff","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\na b : α\ninst✝ : NoMinOrder α\n⊢ Iff (LT.lt (Order.pred a) b) (LE.le a b)","decl":"@[simp]\ntheorem pred_lt_iff : pred a < b ↔ a ≤ b :=\n  pred_lt_iff_of_not_isMin <| not_isMin a\n\n"}
{"name":"Order.pred_le_pred_iff","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\na b : α\ninst✝ : NoMinOrder α\n⊢ Iff (LE.le (Order.pred a) (Order.pred b)) (LE.le a b)","decl":"theorem pred_le_pred_iff : pred a ≤ pred b ↔ a ≤ b := by simp\n\n"}
{"name":"Order.pred_lt_pred_iff","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\na b : α\ninst✝ : NoMinOrder α\n⊢ Iff (LT.lt (Order.pred a) (Order.pred b)) (LT.lt a b)","decl":"theorem pred_lt_pred_iff : pred a < pred b ↔ a < b := by simp\n\n"}
{"name":"Order.le_of_pred_le_pred","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\na b : α\ninst✝ : NoMinOrder α\na✝ : LE.le (Order.pred a) (Order.pred b)\n⊢ LE.le a b","decl":"alias ⟨le_of_pred_le_pred, _⟩ := pred_le_pred_iff\n\n"}
{"name":"Order.lt_of_pred_lt_pred","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\na b : α\ninst✝ : NoMinOrder α\na✝ : LT.lt (Order.pred a) (Order.pred b)\n⊢ LT.lt a b","decl":"alias ⟨lt_of_pred_lt_pred, _⟩ := pred_lt_pred_iff\n\n-- TODO: prove for a pred-archimedean non-linear order with top\n"}
{"name":"Order.Ioi_pred","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\na : α\n⊢ Eq (Set.Ioi (Order.pred a)) (Set.Ici a)","decl":"@[simp]\ntheorem Ioi_pred (a : α) : Ioi (pred a) = Ici a :=\n  Ioi_pred_of_not_isMin <| not_isMin a\n\n"}
{"name":"Order.Ioc_pred_left","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\na b : α\n⊢ Eq (Set.Ioc (Order.pred a) b) (Set.Icc a b)","decl":"@[simp]\ntheorem Ioc_pred_left (a b : α) : Ioc (pred a) b = Icc a b :=\n  Ioc_pred_left_of_not_isMin <| not_isMin _\n\n-- TODO: prove for a pred-archimedean non-linear order\n"}
{"name":"Order.Ioo_pred_left","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\na b : α\n⊢ Eq (Set.Ioo (Order.pred a) b) (Set.Ico a b)","decl":"@[simp]\ntheorem Ioo_pred_left (a b : α) : Ioo (pred a) b = Ico a b :=\n  Ioo_pred_left_of_not_isMin <| not_isMin _\n\n"}
{"name":"Order.pred_eq_pred_iff","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\na b : α\ninst✝ : NoMinOrder α\n⊢ Iff (Eq (Order.pred a) (Order.pred b)) (Eq a b)","decl":"@[simp]\ntheorem pred_eq_pred_iff : pred a = pred b ↔ a = b := by\n  simp_rw [eq_iff_le_not_lt, pred_le_pred_iff, pred_lt_pred_iff]\n\n"}
{"name":"Order.pred_injective","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\n⊢ Function.Injective Order.pred","decl":"theorem pred_injective : Injective (pred : α → α) := fun _ _ => pred_eq_pred_iff.1\n\n"}
{"name":"Order.pred_ne_pred_iff","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\na b : α\ninst✝ : NoMinOrder α\n⊢ Iff (Ne (Order.pred a) (Order.pred b)) (Ne a b)","decl":"theorem pred_ne_pred_iff : pred a ≠ pred b ↔ a ≠ b :=\n  pred_injective.ne_iff\n\n"}
{"name":"Order.pred_ne_pred","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\na b : α\ninst✝ : NoMinOrder α\na✝ : Ne a b\n⊢ Ne (Order.pred a) (Order.pred b)","decl":"alias ⟨_, pred_ne_pred⟩ := pred_ne_pred_iff\n\n"}
{"name":"Order.pred_lt_iff_eq_or_lt","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\na b : α\ninst✝ : NoMinOrder α\n⊢ Iff (LT.lt (Order.pred a) b) (Or (Eq a b) (LT.lt a b))","decl":"theorem pred_lt_iff_eq_or_lt : pred a < b ↔ a = b ∨ a < b :=\n  pred_lt_iff.trans le_iff_eq_or_lt\n\n"}
{"name":"Order.Ioi_pred_eq_insert","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\na : α\n⊢ Eq (Set.Ioi (Order.pred a)) (Insert.insert a (Set.Ioi a))","decl":"theorem Ioi_pred_eq_insert (a : α) : Ioi (pred a) = insert a (Ioi a) :=\n  ext fun _ => pred_lt_iff_eq_or_lt.trans <| or_congr_left eq_comm\n\n"}
{"name":"Order.Ico_pred_right_eq_insert","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\na b : α\ninst✝ : NoMinOrder α\nh : LE.le a b\n⊢ Eq (Set.Ioc (Order.pred a) b) (Insert.insert a (Set.Ioc a b))","decl":"theorem Ico_pred_right_eq_insert (h : a ≤ b) : Ioc (pred a) b = insert a (Ioc a b) := by\n  simp_rw [← Ioi_inter_Iic, Ioi_pred_eq_insert, insert_inter_of_mem (mem_Iic.2 h)]\n\n"}
{"name":"Order.Ioo_pred_right_eq_insert","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\na b : α\ninst✝ : NoMinOrder α\nh : LT.lt a b\n⊢ Eq (Set.Ioo (Order.pred a) b) (Insert.insert a (Set.Ioo a b))","decl":"theorem Ioo_pred_right_eq_insert (h : a < b) : Ioo (pred a) b = insert a (Ioo a b) := by\n  simp_rw [← Ioi_inter_Iio, Ioi_pred_eq_insert, insert_inter_of_mem (mem_Iio.2 h)]\n\n"}
{"name":"Order.pred_top_lt_iff","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝³ : LinearOrder α\ninst✝² : PredOrder α\na : α\ninst✝¹ : OrderTop α\ninst✝ : NoMinOrder α\n⊢ Iff (LT.lt (Order.pred Top.top) a) (Eq a Top.top)","decl":"theorem pred_top_lt_iff [NoMinOrder α] : pred ⊤ < a ↔ a = ⊤ :=\n  @lt_succ_bot_iff αᵒᵈ _ _ _ _ _\n\n"}
{"name":"Order.pred_top_le_iff","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\na : α\ninst✝ : OrderTop α\n⊢ Iff (LE.le (Order.pred Top.top) a) (Or (Eq a Top.top) (Eq a (Order.pred Top.top)))","decl":"theorem pred_top_le_iff : pred ⊤ ≤ a ↔ a = ⊤ ∨ a = pred ⊤ :=\n  @le_succ_bot_iff αᵒᵈ _ _ _ _\n\n"}
{"name":"Order.instSubsingletonPredOrder","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ Subsingleton (PredOrder α)","decl":"/-- There is at most one way to define the predecessors in a `PartialOrder`. -/\ninstance [PartialOrder α] : Subsingleton (PredOrder α) :=\n  ⟨by\n    intro h₀ h₁\n    ext a\n    by_cases ha : IsMin a\n    · exact (@IsMin.pred_eq _ _ h₀ _ ha).trans ha.pred_eq.symm\n    · exact @CovBy.pred_eq _ _ h₀ _ _ (pred_covBy_of_not_isMin ha)⟩\n\n"}
{"name":"Order.pred_eq_sSup","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CompleteLattice α\ninst✝ : PredOrder α\na : α\n⊢ Eq (Order.pred a) (SupSet.sSup (Set.Iio a))","decl":"theorem pred_eq_sSup [CompleteLattice α] [PredOrder α] :\n    ∀ a : α, pred a = sSup (Set.Iio a) :=\n  succ_eq_sInf (α := αᵒᵈ)\n\n"}
{"name":"Order.pred_eq_iSup","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CompleteLattice α\ninst✝ : PredOrder α\na : α\n⊢ Eq (Order.pred a) (iSup fun b => iSup fun h => b)","decl":"theorem pred_eq_iSup [CompleteLattice α] [PredOrder α] (a : α) : pred a = ⨆ b < a, b :=\n  succ_eq_iInf (α := αᵒᵈ) a\n\n"}
{"name":"Order.pred_eq_csSup","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : ConditionallyCompleteLattice α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\na : α\n⊢ Eq (Order.pred a) (SupSet.sSup (Set.Iio a))","decl":"theorem pred_eq_csSup [ConditionallyCompleteLattice α] [PredOrder α] [NoMinOrder α] (a : α) :\n    pred a = sSup (Set.Iio a) :=\n  succ_eq_csInf (α := αᵒᵈ) a\n\n"}
{"name":"Order.le_succ_pred","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : PredOrder α\na : α\n⊢ LE.le a (Order.succ (Order.pred a))","decl":"lemma le_succ_pred (a : α) : a ≤ succ (pred a) := (pred_wcovBy _).le_succ\n"}
{"name":"Order.pred_succ_le","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : PredOrder α\na : α\n⊢ LE.le (Order.pred (Order.succ a)) a","decl":"lemma pred_succ_le (a : α) : pred (succ a) ≤ a := (wcovBy_succ _).pred_le\n\n"}
{"name":"Order.pred_le_iff_le_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : PredOrder α\na b : α\n⊢ Iff (LE.le (Order.pred a) b) (LE.le a (Order.succ b))","decl":"lemma pred_le_iff_le_succ : pred a ≤ b ↔ a ≤ succ b where\n  mp hab := (le_succ_pred _).trans (succ_mono hab)\n  mpr hab := (pred_mono hab).trans (pred_succ_le _)\n\n"}
{"name":"Order.gc_pred_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : SuccOrder α\ninst✝ : PredOrder α\n⊢ GaloisConnection Order.pred Order.succ","decl":"lemma gc_pred_succ : GaloisConnection (pred : α → α) succ := fun _ _ ↦ pred_le_iff_le_succ\n\n"}
{"name":"Order.succ_pred_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : PredOrder α\na : α\nh : Not (IsMin a)\n⊢ Eq (Order.succ (Order.pred a)) a","decl":"@[simp]\ntheorem succ_pred_of_not_isMin (h : ¬IsMin a) : succ (pred a) = a :=\n  CovBy.succ_eq (pred_covBy_of_not_isMin h)\n\n"}
{"name":"Order.pred_succ_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : PredOrder α\na : α\nh : Not (IsMax a)\n⊢ Eq (Order.pred (Order.succ a)) a","decl":"@[simp]\ntheorem pred_succ_of_not_isMax (h : ¬IsMax a) : pred (succ a) = a :=\n  CovBy.pred_eq (covBy_succ_of_not_isMax h)\n\n"}
{"name":"Order.succ_pred","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝³ : PartialOrder α\ninst✝² : SuccOrder α\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\na : α\n⊢ Eq (Order.succ (Order.pred a)) a","decl":"theorem succ_pred [NoMinOrder α] (a : α) : succ (pred a) = a :=\n  CovBy.succ_eq (pred_covBy _)\n\n"}
{"name":"Order.pred_succ","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝³ : PartialOrder α\ninst✝² : SuccOrder α\ninst✝¹ : PredOrder α\ninst✝ : NoMaxOrder α\na : α\n⊢ Eq (Order.pred (Order.succ a)) a","decl":"theorem pred_succ [NoMaxOrder α] (a : α) : pred (succ a) = a :=\n  CovBy.pred_eq (covBy_succ _)\n\n"}
{"name":"Order.pred_succ_iterate_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : PredOrder α\ni : α\nn : Nat\nhin : Not (IsMax (Nat.iterate Order.succ (HSub.hSub n 1) i))\n⊢ Eq (Nat.iterate Order.pred n (Nat.iterate Order.succ n i)) i","decl":"theorem pred_succ_iterate_of_not_isMax (i : α) (n : ℕ) (hin : ¬IsMax (succ^[n - 1] i)) :\n    pred^[n] (succ^[n] i) = i := by\n  induction' n with n hn\n  · simp only [Nat.zero_eq, Function.iterate_zero, id]\n  rw [Nat.succ_sub_succ_eq_sub, Nat.sub_zero] at hin\n  have h_not_max : ¬IsMax (succ^[n - 1] i) := by\n    cases' n with n\n    · simpa using hin\n    rw [Nat.succ_sub_succ_eq_sub, Nat.sub_zero] at hn ⊢\n    have h_sub_le : succ^[n] i ≤ succ^[n.succ] i := by\n      rw [Function.iterate_succ']\n      exact le_succ _\n    refine fun h_max => hin fun j hj => ?_\n    have hj_le : j ≤ succ^[n] i := h_max (h_sub_le.trans hj)\n    exact hj_le.trans h_sub_le\n  rw [Function.iterate_succ, Function.iterate_succ']\n  simp only [Function.comp_apply]\n  rw [pred_succ_of_not_isMax hin]\n  exact hn h_not_max\n\n"}
{"name":"Order.succ_pred_iterate_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : PredOrder α\ni : α\nn : Nat\nhin : Not (IsMin (Nat.iterate Order.pred (HSub.hSub n 1) i))\n⊢ Eq (Nat.iterate Order.succ n (Nat.iterate Order.pred n i)) i","decl":"theorem succ_pred_iterate_of_not_isMin (i : α) (n : ℕ) (hin : ¬IsMin (pred^[n - 1] i)) :\n    succ^[n] (pred^[n] i) = i :=\n  @pred_succ_iterate_of_not_isMax αᵒᵈ _ _ _ i n hin\n\n"}
{"name":"WithTop.succ_coe_of_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : (a : α) → Decidable (Eq (Order.succ a) a)\na : α\nh : IsMax a\n⊢ Eq (Order.succ ↑a) Top.top","decl":"@[simp]\ntheorem succ_coe_of_isMax {a : α} (h : IsMax a) : succ ↑a = (⊤ : WithTop α) :=\n  dif_pos (succ_eq_iff_isMax.2 h)\n\n"}
{"name":"WithTop.succ_coe_of_not_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : (a : α) → Decidable (Eq (Order.succ a) a)\na : α\nh : Not (IsMax a)\n⊢ Eq (Order.succ ↑a) ↑(Order.succ a)","decl":"theorem succ_coe_of_not_isMax {a : α} (h : ¬ IsMax a) : succ (↑a : WithTop α) = ↑(succ a) :=\n  dif_neg (succ_eq_iff_isMax.not.2 h)\n\n"}
{"name":"WithTop.succ_coe","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝³ : PartialOrder α\ninst✝² : SuccOrder α\ninst✝¹ : (a : α) → Decidable (Eq (Order.succ a) a)\ninst✝ : NoMaxOrder α\na : α\n⊢ Eq (Order.succ ↑a) ↑(Order.succ a)","decl":"@[simp]\ntheorem succ_coe [NoMaxOrder α] {a : α} : succ (↑a : WithTop α) = ↑(succ a) :=\n  succ_coe_of_not_isMax <| not_isMax a\n\n"}
{"name":"WithTop.orderPred_top","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : OrderTop α\ninst✝ : PredOrder α\n⊢ Eq (Order.pred Top.top) ↑Top.top","decl":"/-- Not to be confused with `WithTop.pred_bot`, which is about `WithTop.pred`. -/\n@[simp] lemma orderPred_top : pred (⊤ : WithTop α) = ↑(⊤ : α) := rfl\n\n"}
{"name":"WithTop.orderPred_coe","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : OrderTop α\ninst✝ : PredOrder α\na : α\n⊢ Eq (Order.pred ↑a) ↑(Order.pred a)","decl":"/-- Not to be confused with `WithTop.pred_coe`, which is about `WithTop.pred`. -/\n@[simp] lemma orderPred_coe (a : α) : pred (↑a : WithTop α) = ↑(pred a) := rfl\n\n"}
{"name":"WithTop.pred_untop","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : OrderTop α\ninst✝ : PredOrder α\na : WithTop α\nha : Ne a Top.top\n⊢ Eq (Order.pred (a.untop ha)) ((Order.pred a).untop ⋯)","decl":"@[simp]\ntheorem pred_untop :\n    ∀ (a : WithTop α) (ha : a ≠ ⊤),\n      pred (a.untop ha) = (pred a).untop (by induction a <;> simp)\n  | ⊤, ha => (ha rfl).elim\n  | (a : α), _ => rfl\n\n"}
{"name":"WithTop.instIsEmptyPredOrderOfNonempty","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nhα : Nonempty α\n⊢ IsEmpty (PredOrder (WithTop α))","decl":"instance [hα : Nonempty α] : IsEmpty (PredOrder (WithTop α)) :=\n  ⟨by\n    intro\n    cases' h : pred (⊤ : WithTop α) with a ha\n    · exact hα.elim fun a => (min_of_le_pred h.ge).not_lt <| coe_lt_top a\n    · obtain ⟨c, hc⟩ := exists_gt a\n      rw [← coe_lt_coe, ← h] at hc\n      exact (le_pred_of_lt (coe_lt_top c)).not_lt hc⟩\n\n"}
{"name":"WithBot.orderSucc_bot","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : OrderBot α\ninst✝ : SuccOrder α\n⊢ Eq (Order.succ Bot.bot) ↑Bot.bot","decl":"/-- Not to be confused with `WithBot.succ_bot`, which is about `WithBot.succ`. -/\n@[simp] lemma orderSucc_bot : succ (⊥ : WithBot α) = ↑(⊥ : α) := rfl\n\n"}
{"name":"WithBot.orderSucc_coe","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : OrderBot α\ninst✝ : SuccOrder α\na : α\n⊢ Eq (Order.succ ↑a) ↑(Order.succ a)","decl":"/-- Not to be confused with `WithBot.succ_coe`, which is about `WithBot.succ`. -/\n@[simp] lemma orderSucc_coe (a : α) : succ (↑a : WithBot α) = ↑(succ a) := rfl\n\n"}
{"name":"WithBot.succ_unbot","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : OrderBot α\ninst✝ : SuccOrder α\na : WithBot α\nha : Ne a Bot.bot\n⊢ Eq (Order.succ (a.unbot ha)) ((Order.succ a).unbot ⋯)","decl":"@[simp]\ntheorem succ_unbot :\n    ∀ (a : WithBot α) (ha : a ≠ ⊥),\n      succ (a.unbot ha) = (succ a).unbot (by induction a <;> simp)\n  | ⊥, ha => (ha rfl).elim\n  | (a : α), _ => rfl\n\n"}
{"name":"WithBot.pred_coe_of_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\ninst✝ : (a : α) → Decidable (Eq (Order.pred a) a)\na : α\nh : IsMin a\n⊢ Eq (Order.pred ↑a) Bot.bot","decl":"@[simp]\ntheorem pred_coe_of_isMin {a : α} (h : IsMin a) : pred ↑a = (⊥ : WithBot α) :=\n  dif_pos (pred_eq_iff_isMin.2 h)\n\n"}
{"name":"WithBot.pred_coe_of_not_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\ninst✝ : (a : α) → Decidable (Eq (Order.pred a) a)\na : α\nh : Not (IsMin a)\n⊢ Eq (Order.pred ↑a) ↑(Order.pred a)","decl":"theorem pred_coe_of_not_isMin {a : α} (h : ¬ IsMin a) : pred (↑a : WithBot α) = ↑(pred a) :=\n  dif_neg (pred_eq_iff_isMin.not.2 h)\n\n"}
{"name":"WithBot.pred_coe","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝³ : PartialOrder α\ninst✝² : PredOrder α\ninst✝¹ : (a : α) → Decidable (Eq (Order.pred a) a)\ninst✝ : NoMinOrder α\na : α\n⊢ Eq (Order.pred ↑a) ↑(Order.pred a)","decl":"theorem pred_coe [NoMinOrder α] {a : α} : pred (↑a : WithBot α) = ↑(pred a) :=\n  pred_coe_of_not_isMin <| not_isMin a\n\n"}
{"name":"WithBot.instIsEmptySuccOrderOfNonempty","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nhα : Nonempty α\n⊢ IsEmpty (SuccOrder (WithBot α))","decl":"instance [hα : Nonempty α] : IsEmpty (SuccOrder (WithBot α)) :=\n  ⟨by\n    intro\n    cases' h : succ (⊥ : WithBot α) with a ha\n    · exact hα.elim fun a => (max_of_succ_le h.le).not_lt <| bot_lt_coe a\n    · obtain ⟨c, hc⟩ := exists_lt a\n      rw [← coe_lt_coe, ← h] at hc\n      exact (succ_le_of_lt (bot_lt_coe _)).not_lt hc⟩\n\n"}
{"name":"coe_pred_of_mem","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_3\ninst✝² : PartialOrder α\ns : Set α\ninst✝¹ : s.OrdConnected\ninst✝ : PredOrder α\na : ↑s\nh : Membership.mem s (Order.pred ↑a)\n⊢ Eq (↑(Order.pred a)) (Order.pred ↑a)","decl":"@[simp, norm_cast]\nlemma coe_pred_of_mem [PredOrder α] {a : s} (h : pred a.1 ∈ s) :\n    (pred a).1 = pred ↑a := by classical\n  change Subtype.val (dite ..) = _\n  simp [h]\n\n"}
{"name":"isMin_of_not_pred_mem","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_3\ninst✝² : PartialOrder α\ns : Set α\ninst✝¹ : s.OrdConnected\ninst✝ : PredOrder α\na : ↑s\nh : Not (Membership.mem s (Order.pred ↑a))\n⊢ IsMin a","decl":"lemma isMin_of_not_pred_mem [PredOrder α] {a : s} (h : pred ↑a ∉ s) : IsMin a := by classical\n  rw [← pred_eq_iff_isMin]\n  change dite .. = _\n  simp [h]\n\n"}
{"name":"not_pred_mem_iff_isMin","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_3\ninst✝³ : PartialOrder α\ns : Set α\ninst✝² : s.OrdConnected\ninst✝¹ : PredOrder α\ninst✝ : NoMinOrder α\na : ↑s\n⊢ Iff (Not (Membership.mem s (Order.pred ↑a))) (IsMin a)","decl":"lemma not_pred_mem_iff_isMin [PredOrder α] [NoMinOrder α] {a : s} :\n    pred ↑a ∉ s ↔ IsMin a where\n  mp := isMin_of_not_pred_mem\n  mpr h nh := by\n    replace h := congr($h.pred_eq.1)\n    rw [coe_pred_of_mem nh] at h\n    simp at h\n\n"}
{"name":"coe_succ_of_mem","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_3\ninst✝² : PartialOrder α\ns : Set α\ninst✝¹ : s.OrdConnected\ninst✝ : SuccOrder α\na : ↑s\nh : Membership.mem s (Order.succ ↑a)\n⊢ Eq (↑(Order.succ a)) (Order.succ ↑a)","decl":"@[simp, norm_cast]\nlemma coe_succ_of_mem [SuccOrder α] {a : s} (h : succ ↑a ∈ s) :\n    (succ a).1 = succ ↑a := by classical\n  change Subtype.val (dite ..) = _\n  split_ifs <;> trivial\n\n"}
{"name":"isMax_of_not_succ_mem","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_3\ninst✝² : PartialOrder α\ns : Set α\ninst✝¹ : s.OrdConnected\ninst✝ : SuccOrder α\na : ↑s\nh : Not (Membership.mem s (Order.succ ↑a))\n⊢ IsMax a","decl":"lemma isMax_of_not_succ_mem [SuccOrder α] {a : s} (h : succ ↑a ∉ s) : IsMax a := by classical\n  rw [← succ_eq_iff_isMax]\n  change dite .. = _\n  split_ifs <;> trivial\n\n"}
{"name":"not_succ_mem_iff_isMax","module":"Mathlib.Order.SuccPred.Basic","initialProofState":"α : Type u_3\ninst✝³ : PartialOrder α\ns : Set α\ninst✝² : s.OrdConnected\ninst✝¹ : SuccOrder α\ninst✝ : NoMaxOrder α\na : ↑s\n⊢ Iff (Not (Membership.mem s (Order.succ ↑a))) (IsMax a)","decl":"lemma not_succ_mem_iff_isMax [SuccOrder α] [NoMaxOrder α] {a : s} :\n    succ ↑a ∉ s ↔ IsMax a where\n  mp := isMax_of_not_succ_mem\n  mpr h nh := by\n    replace h := congr($h.succ_eq.1)\n    rw [coe_succ_of_mem nh] at h\n    simp at h\n\n"}
