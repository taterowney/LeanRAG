{"name":"Nat.Partition.mk.sizeOf_spec","module":"Mathlib.Combinatorics.Enumerative.Partition","initialProofState":"n : Nat\nparts : Multiset Nat\nparts_pos : ∀ {i : Nat}, Membership.mem parts i → LT.lt 0 i\nparts_sum : Eq parts.sum n\n⊢ Eq (SizeOf.sizeOf { parts := parts, parts_pos := parts_pos, parts_sum := parts_sum }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf parts)) (SizeOf.sizeOf parts_sum))","decl":"/-- A partition of `n` is a multiset of positive integers summing to `n`. -/\n@[ext]\nstructure Partition (n : ℕ) where\n  /-- positive integers summing to `n`-/\n  parts : Multiset ℕ\n  /-- proof that the `parts` are positive -/\n  parts_pos : ∀ {i}, i ∈ parts → 0 < i\n  /-- proof that the `parts` sum to `n`-/\n  parts_sum : parts.sum = n\nderiving DecidableEq\n\n"}
{"name":"Nat.Partition.ext","module":"Mathlib.Combinatorics.Enumerative.Partition","initialProofState":"n : Nat\nx y : n.Partition\nparts : Eq x.parts y.parts\n⊢ Eq x y","decl":"/-- A partition of `n` is a multiset of positive integers summing to `n`. -/\n@[ext]\nstructure Partition (n : ℕ) where\n  /-- positive integers summing to `n`-/\n  parts : Multiset ℕ\n  /-- proof that the `parts` are positive -/\n  parts_pos : ∀ {i}, i ∈ parts → 0 < i\n  /-- proof that the `parts` sum to `n`-/\n  parts_sum : parts.sum = n\nderiving DecidableEq\n\n"}
{"name":"Nat.Partition.ext_iff","module":"Mathlib.Combinatorics.Enumerative.Partition","initialProofState":"n : Nat\nx y : n.Partition\n⊢ Iff (Eq x y) (Eq x.parts y.parts)","decl":"/-- A partition of `n` is a multiset of positive integers summing to `n`. -/\n@[ext]\nstructure Partition (n : ℕ) where\n  /-- positive integers summing to `n`-/\n  parts : Multiset ℕ\n  /-- proof that the `parts` are positive -/\n  parts_pos : ∀ {i}, i ∈ parts → 0 < i\n  /-- proof that the `parts` sum to `n`-/\n  parts_sum : parts.sum = n\nderiving DecidableEq\n\n"}
{"name":"Nat.Partition.mk.inj","module":"Mathlib.Combinatorics.Enumerative.Partition","initialProofState":"n : Nat\nparts✝ : Multiset Nat\nparts_pos✝ : ∀ {i : Nat}, Membership.mem parts✝ i → LT.lt 0 i\nparts_sum✝ : Eq parts✝.sum n\nparts : Multiset Nat\nparts_pos : ∀ {i : Nat}, Membership.mem parts i → LT.lt 0 i\nparts_sum : Eq parts.sum n\nx✝ : Eq { parts := parts✝, parts_pos := parts_pos✝, parts_sum := parts_sum✝ } { parts := parts, parts_pos := parts_pos, parts_sum := parts_sum }\n⊢ Eq parts✝ parts","decl":"/-- A partition of `n` is a multiset of positive integers summing to `n`. -/\n@[ext]\nstructure Partition (n : ℕ) where\n  /-- positive integers summing to `n`-/\n  parts : Multiset ℕ\n  /-- proof that the `parts` are positive -/\n  parts_pos : ∀ {i}, i ∈ parts → 0 < i\n  /-- proof that the `parts` sum to `n`-/\n  parts_sum : parts.sum = n\nderiving DecidableEq\n\n"}
{"name":"Nat.Partition.parts_pos","module":"Mathlib.Combinatorics.Enumerative.Partition","initialProofState":"n : Nat\nself : n.Partition\ni : Nat\na✝ : Membership.mem self.parts i\n⊢ LT.lt 0 i","decl":"/-- A partition of `n` is a multiset of positive integers summing to `n`. -/\n@[ext]\nstructure Partition (n : ℕ) where\n  /-- positive integers summing to `n`-/\n  parts : Multiset ℕ\n  /-- proof that the `parts` are positive -/\n  parts_pos : ∀ {i}, i ∈ parts → 0 < i\n  /-- proof that the `parts` sum to `n`-/\n  parts_sum : parts.sum = n\nderiving DecidableEq\n\n"}
{"name":"Nat.Partition.mk.injEq","module":"Mathlib.Combinatorics.Enumerative.Partition","initialProofState":"n : Nat\nparts✝ : Multiset Nat\nparts_pos✝ : ∀ {i : Nat}, Membership.mem parts✝ i → LT.lt 0 i\nparts_sum✝ : Eq parts✝.sum n\nparts : Multiset Nat\nparts_pos : ∀ {i : Nat}, Membership.mem parts i → LT.lt 0 i\nparts_sum : Eq parts.sum n\n⊢ Eq (Eq { parts := parts✝, parts_pos := parts_pos✝, parts_sum := parts_sum✝ } { parts := parts, parts_pos := parts_pos, parts_sum := parts_sum }) (Eq parts✝ parts)","decl":"/-- A partition of `n` is a multiset of positive integers summing to `n`. -/\n@[ext]\nstructure Partition (n : ℕ) where\n  /-- positive integers summing to `n`-/\n  parts : Multiset ℕ\n  /-- proof that the `parts` are positive -/\n  parts_pos : ∀ {i}, i ∈ parts → 0 < i\n  /-- proof that the `parts` sum to `n`-/\n  parts_sum : parts.sum = n\nderiving DecidableEq\n\n"}
{"name":"Nat.Partition.parts_sum","module":"Mathlib.Combinatorics.Enumerative.Partition","initialProofState":"n : Nat\nself : n.Partition\n⊢ Eq self.parts.sum n","decl":"/-- A partition of `n` is a multiset of positive integers summing to `n`. -/\n@[ext]\nstructure Partition (n : ℕ) where\n  /-- positive integers summing to `n`-/\n  parts : Multiset ℕ\n  /-- proof that the `parts` are positive -/\n  parts_pos : ∀ {i}, i ∈ parts → 0 < i\n  /-- proof that the `parts` sum to `n`-/\n  parts_sum : parts.sum = n\nderiving DecidableEq\n\n"}
{"name":"Nat.Partition.ofComposition_parts","module":"Mathlib.Combinatorics.Enumerative.Partition","initialProofState":"n : Nat\nc : Composition n\n⊢ Eq (Nat.Partition.ofComposition n c).parts ↑c.blocks","decl":"/-- A composition induces a partition (just convert the list to a multiset). -/\n@[simps]\ndef ofComposition (n : ℕ) (c : Composition n) : Partition n where\n  parts := c.blocks\n  parts_pos hi := c.blocks_pos hi\n  parts_sum := by rw [Multiset.sum_coe, c.blocks_sum]\n\n"}
{"name":"Nat.Partition.ofComposition_surj","module":"Mathlib.Combinatorics.Enumerative.Partition","initialProofState":"n : Nat\n⊢ Function.Surjective (Nat.Partition.ofComposition n)","decl":"theorem ofComposition_surj {n : ℕ} : Function.Surjective (ofComposition n) := by\n  rintro ⟨b, hb₁, hb₂⟩\n  induction b using Quotient.inductionOn with | _ b => ?_\n  exact ⟨⟨b, hb₁, by simpa using hb₂⟩, Partition.ext rfl⟩\n\n-- The argument `n` is kept explicit here since it is useful in tactic mode proofs to generate the\n-- proof obligation `l.sum = n`.\n"}
{"name":"Nat.Partition.ofSums_parts","module":"Mathlib.Combinatorics.Enumerative.Partition","initialProofState":"n : Nat\nl : Multiset Nat\nhl : Eq l.sum n\n⊢ Eq (Nat.Partition.ofSums n l hl).parts (Multiset.filter (fun x => Ne x 0) l)","decl":"/-- Given a multiset which sums to `n`, construct a partition of `n` with the same multiset, but\nwithout the zeros.\n-/\n@[simps]\ndef ofSums (n : ℕ) (l : Multiset ℕ) (hl : l.sum = n) : Partition n where\n  parts := l.filter (· ≠ 0)\n  parts_pos hi := (of_mem_filter hi).bot_lt\n  parts_sum := by\n    have lz : (l.filter (· = 0)).sum = 0 := by simp [sum_eq_zero_iff]\n    rwa [← filter_add_not (· = 0) l, sum_add, lz, zero_add] at hl\n\n"}
{"name":"Nat.Partition.ofMultiset_parts","module":"Mathlib.Combinatorics.Enumerative.Partition","initialProofState":"l : Multiset Nat\n⊢ Eq (Nat.Partition.ofMultiset l).parts (Multiset.filter (fun x => Not (Eq x 0)) l)","decl":"/-- A `Multiset ℕ` induces a partition on its sum. -/\n@[simps!]\ndef ofMultiset (l : Multiset ℕ) : Partition l.sum := ofSums _ l rfl\n\n"}
{"name":"Nat.Partition.ofSym_map","module":"Mathlib.Combinatorics.Enumerative.Partition","initialProofState":"n : Nat\nσ : Type u_1\nτ : Type u_2\ninst✝¹ : DecidableEq σ\ninst✝ : DecidableEq τ\ne : Equiv σ τ\ns : Sym σ n\n⊢ Eq (Nat.Partition.ofSym (Sym.map (⇑e) s)) (Nat.Partition.ofSym s)","decl":"@[simp] lemma ofSym_map (e : σ ≃ τ) (s : Sym σ n) :\n    ofSym (s.map e) = ofSym s := by\n  simp only [ofSym, Sym.val_eq_coe, Sym.coe_map, toFinset_val, mk.injEq]\n  rw [Multiset.dedup_map_of_injective e.injective]\n  simp only [map_map, Function.comp_apply]\n  congr; funext i\n  rw [← Multiset.count_map_eq_count' e _ e.injective]\n\n"}
{"name":"Nat.Partition.indiscrete_parts","module":"Mathlib.Combinatorics.Enumerative.Partition","initialProofState":"n : Nat\nhn : Ne n 0\n⊢ Eq (Nat.Partition.indiscrete n).parts (Singleton.singleton n)","decl":"@[simp] lemma indiscrete_parts {n : ℕ} (hn : n ≠ 0) : (indiscrete n).parts = {n} := by\n  simp [indiscrete, filter_eq_self, hn]\n\n"}
{"name":"Nat.Partition.partition_zero_parts","module":"Mathlib.Combinatorics.Enumerative.Partition","initialProofState":"p : Nat.Partition 0\n⊢ Eq p.parts 0","decl":"@[simp] lemma partition_zero_parts (p : Partition 0) : p.parts = 0 :=\n  eq_zero_of_forall_not_mem fun _ h => (p.parts_pos h).ne' <| sum_eq_zero_iff.1 p.parts_sum _ h\n\n"}
{"name":"Nat.Partition.partition_one_parts","module":"Mathlib.Combinatorics.Enumerative.Partition","initialProofState":"p : Nat.Partition 1\n⊢ Eq p.parts (Singleton.singleton 1)","decl":"@[simp] lemma partition_one_parts (p : Partition 1) : p.parts = {1} := by\n  have h : p.parts = replicate (card p.parts) 1 := eq_replicate_card.2 fun x hx =>\n    ((le_sum_of_mem hx).trans_eq p.parts_sum).antisymm (p.parts_pos hx)\n  have h' : card p.parts = 1 := by simpa using (congrArg sum h.symm).trans p.parts_sum\n  rw [h, h', replicate_one]\n\n"}
{"name":"Nat.Partition.ofSym_one","module":"Mathlib.Combinatorics.Enumerative.Partition","initialProofState":"σ : Type u_1\ninst✝ : DecidableEq σ\ns : Sym σ 1\n⊢ Eq (Nat.Partition.ofSym s) (Nat.Partition.indiscrete 1)","decl":"@[simp] lemma ofSym_one (s : Sym σ 1) : ofSym s = indiscrete 1 := by\n  ext; simp\n\n"}
{"name":"Nat.Partition.count_ofSums_of_ne_zero","module":"Mathlib.Combinatorics.Enumerative.Partition","initialProofState":"n : Nat\nl : Multiset Nat\nhl : Eq l.sum n\ni : Nat\nhi : Ne i 0\n⊢ Eq (Multiset.count i (Nat.Partition.ofSums n l hl).parts) (Multiset.count i l)","decl":"/-- The number of times a positive integer `i` appears in the partition `ofSums n l hl` is the same\nas the number of times it appears in the multiset `l`.\n(For `i = 0`, `Partition.non_zero` combined with `Multiset.count_eq_zero_of_not_mem` gives that\nthis is `0` instead.)\n-/\ntheorem count_ofSums_of_ne_zero {n : ℕ} {l : Multiset ℕ} (hl : l.sum = n) {i : ℕ} (hi : i ≠ 0) :\n    (ofSums n l hl).parts.count i = l.count i :=\n  count_filter_of_pos hi\n\n"}
{"name":"Nat.Partition.count_ofSums_zero","module":"Mathlib.Combinatorics.Enumerative.Partition","initialProofState":"n : Nat\nl : Multiset Nat\nhl : Eq l.sum n\n⊢ Eq (Multiset.count 0 (Nat.Partition.ofSums n l hl).parts) 0","decl":"theorem count_ofSums_zero {n : ℕ} {l : Multiset ℕ} (hl : l.sum = n) :\n    (ofSums n l hl).parts.count 0 = 0 :=\n  count_filter_of_neg fun h => h rfl\n\n"}
