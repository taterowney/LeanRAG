{"name":"LipschitzAdd.lipschitz_add","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"β : Type u_2\ninst✝¹ : PseudoMetricSpace β\ninst✝ : AddMonoid β\nself : LipschitzAdd β\n⊢ Exists fun C => LipschitzWith C fun p => HAdd.hAdd p.1 p.2","decl":"/-- Class `LipschitzAdd M` says that the addition `(+) : X × X → X` is Lipschitz jointly in\nthe two arguments. -/\nclass LipschitzAdd [AddMonoid β] : Prop where\n  lipschitz_add : ∃ C, LipschitzWith C fun p : β × β => p.1 + p.2\n\n"}
{"name":"LipschitzMul.lipschitz_mul","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"β : Type u_2\ninst✝¹ : PseudoMetricSpace β\ninst✝ : Monoid β\nself : LipschitzMul β\n⊢ Exists fun C => LipschitzWith C fun p => HMul.hMul p.1 p.2","decl":"/-- Class `LipschitzMul M` says that the multiplication `(*) : X × X → X` is Lipschitz jointly\nin the two arguments. -/\n@[to_additive]\nclass LipschitzMul [Monoid β] : Prop where\n  lipschitz_mul : ∃ C, LipschitzWith C fun p : β × β => p.1 * p.2\n\n"}
{"name":"lipschitzWith_lipschitz_const_add_edist","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"β : Type u_2\ninst✝¹ : PseudoMetricSpace β\ninst✝ : AddMonoid β\n_i : LipschitzAdd β\n⊢ LipschitzWith (LipschitzAdd.C β) fun p => HAdd.hAdd p.1 p.2","decl":"@[to_additive]\ntheorem lipschitzWith_lipschitz_const_mul_edist [_i : LipschitzMul β] :\n    LipschitzWith (LipschitzMul.C β) fun p : β × β => p.1 * p.2 :=\n  Classical.choose_spec _i.lipschitz_mul\n\n"}
{"name":"lipschitzWith_lipschitz_const_mul_edist","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"β : Type u_2\ninst✝¹ : PseudoMetricSpace β\ninst✝ : Monoid β\n_i : LipschitzMul β\n⊢ LipschitzWith (LipschitzMul.C β) fun p => HMul.hMul p.1 p.2","decl":"@[to_additive]\ntheorem lipschitzWith_lipschitz_const_mul_edist [_i : LipschitzMul β] :\n    LipschitzWith (LipschitzMul.C β) fun p : β × β => p.1 * p.2 :=\n  Classical.choose_spec _i.lipschitz_mul\n\n"}
{"name":"lipschitz_with_lipschitz_const_add","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"β : Type u_2\ninst✝² : PseudoMetricSpace β\ninst✝¹ : AddMonoid β\ninst✝ : LipschitzAdd β\np q : Prod β β\n⊢ LE.le (Dist.dist (HAdd.hAdd p.1 p.2) (HAdd.hAdd q.1 q.2)) (HMul.hMul (↑(LipschitzAdd.C β)) (Dist.dist p q))","decl":"@[to_additive]\ntheorem lipschitz_with_lipschitz_const_mul :\n    ∀ p q : β × β, dist (p.1 * p.2) (q.1 * q.2) ≤ LipschitzMul.C β * dist p q := by\n  rw [← lipschitzWith_iff_dist_le_mul]\n  exact lipschitzWith_lipschitz_const_mul_edist\n\n-- see Note [lower instance priority]\n"}
{"name":"lipschitz_with_lipschitz_const_mul","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"β : Type u_2\ninst✝² : PseudoMetricSpace β\ninst✝¹ : Monoid β\ninst✝ : LipschitzMul β\np q : Prod β β\n⊢ LE.le (Dist.dist (HMul.hMul p.1 p.2) (HMul.hMul q.1 q.2)) (HMul.hMul (↑(LipschitzMul.C β)) (Dist.dist p q))","decl":"@[to_additive]\ntheorem lipschitz_with_lipschitz_const_mul :\n    ∀ p q : β × β, dist (p.1 * p.2) (q.1 * q.2) ≤ LipschitzMul.C β * dist p q := by\n  rw [← lipschitzWith_iff_dist_le_mul]\n  exact lipschitzWith_lipschitz_const_mul_edist\n\n-- see Note [lower instance priority]\n"}
{"name":"LipschitzMul.continuousMul","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"β : Type u_2\ninst✝² : PseudoMetricSpace β\ninst✝¹ : Monoid β\ninst✝ : LipschitzMul β\n⊢ ContinuousMul β","decl":"@[to_additive]\ninstance (priority := 100) LipschitzMul.continuousMul : ContinuousMul β :=\n  ⟨lipschitzWith_lipschitz_const_mul_edist.continuous⟩\n\n"}
{"name":"LipschitzAdd.continuousAdd","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"β : Type u_2\ninst✝² : PseudoMetricSpace β\ninst✝¹ : AddMonoid β\ninst✝ : LipschitzAdd β\n⊢ ContinuousAdd β","decl":"@[to_additive]\ninstance (priority := 100) LipschitzMul.continuousMul : ContinuousMul β :=\n  ⟨lipschitzWith_lipschitz_const_mul_edist.continuous⟩\n\n"}
{"name":"Submonoid.lipschitzMul","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"β : Type u_2\ninst✝² : PseudoMetricSpace β\ninst✝¹ : Monoid β\ninst✝ : LipschitzMul β\ns : Submonoid β\n⊢ LipschitzMul (Subtype fun x => Membership.mem s x)","decl":"@[to_additive]\ninstance Submonoid.lipschitzMul (s : Submonoid β) : LipschitzMul s where\n  lipschitz_mul := ⟨LipschitzMul.C β, by\n    rintro ⟨x₁, x₂⟩ ⟨y₁, y₂⟩\n    convert lipschitzWith_lipschitz_const_mul_edist ⟨(x₁ : β), x₂⟩ ⟨y₁, y₂⟩ using 1⟩\n\n"}
{"name":"AddSubmonoid.lipschitzAdd","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"β : Type u_2\ninst✝² : PseudoMetricSpace β\ninst✝¹ : AddMonoid β\ninst✝ : LipschitzAdd β\ns : AddSubmonoid β\n⊢ LipschitzAdd (Subtype fun x => Membership.mem s x)","decl":"@[to_additive]\ninstance Submonoid.lipschitzMul (s : Submonoid β) : LipschitzMul s where\n  lipschitz_mul := ⟨LipschitzMul.C β, by\n    rintro ⟨x₁, x₂⟩ ⟨y₁, y₂⟩\n    convert lipschitzWith_lipschitz_const_mul_edist ⟨(x₁ : β), x₂⟩ ⟨y₁, y₂⟩ using 1⟩\n\n"}
{"name":"AddOpposite.lipschitzAdd","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"β : Type u_2\ninst✝² : PseudoMetricSpace β\ninst✝¹ : AddMonoid β\ninst✝ : LipschitzAdd β\n⊢ LipschitzAdd (AddOpposite β)","decl":"@[to_additive]\ninstance MulOpposite.lipschitzMul : LipschitzMul βᵐᵒᵖ where\n  lipschitz_mul := ⟨LipschitzMul.C β, fun ⟨x₁, x₂⟩ ⟨y₁, y₂⟩ =>\n    (lipschitzWith_lipschitz_const_mul_edist ⟨x₂.unop, x₁.unop⟩ ⟨y₂.unop, y₁.unop⟩).trans_eq\n      (congr_arg _ <| max_comm _ _)⟩\n\n-- this instance could be deduced from `NormedAddCommGroup.lipschitzAdd`, but we prove it\n-- separately here so that it is available earlier in the hierarchy\n"}
{"name":"MulOpposite.lipschitzMul","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"β : Type u_2\ninst✝² : PseudoMetricSpace β\ninst✝¹ : Monoid β\ninst✝ : LipschitzMul β\n⊢ LipschitzMul (MulOpposite β)","decl":"@[to_additive]\ninstance MulOpposite.lipschitzMul : LipschitzMul βᵐᵒᵖ where\n  lipschitz_mul := ⟨LipschitzMul.C β, fun ⟨x₁, x₂⟩ ⟨y₁, y₂⟩ =>\n    (lipschitzWith_lipschitz_const_mul_edist ⟨x₂.unop, x₁.unop⟩ ⟨y₂.unop, y₁.unop⟩).trans_eq\n      (congr_arg _ <| max_comm _ _)⟩\n\n-- this instance could be deduced from `NormedAddCommGroup.lipschitzAdd`, but we prove it\n-- separately here so that it is available earlier in the hierarchy\n"}
{"name":"Real.hasLipschitzAdd","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"⊢ LipschitzAdd Real","decl":"instance Real.hasLipschitzAdd : LipschitzAdd ℝ where\n  lipschitz_add := ⟨2, LipschitzWith.of_dist_le_mul fun p q => by\n    simp only [Real.dist_eq, Prod.dist_eq, Prod.fst_sub, Prod.snd_sub, NNReal.coe_ofNat,\n      add_sub_add_comm, two_mul]\n    refine le_trans (abs_add (p.1 - q.1) (p.2 - q.2)) ?_\n    exact add_le_add (le_max_left _ _) (le_max_right _ _)⟩\n\n-- this instance has the same proof as `AddSubmonoid.lipschitzAdd`, but the former can't\n-- directly be applied here since `ℝ≥0` is a subtype of `ℝ`, not an additive submonoid.\n"}
{"name":"NNReal.hasLipschitzAdd","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"⊢ LipschitzAdd NNReal","decl":"instance NNReal.hasLipschitzAdd : LipschitzAdd ℝ≥0 where\n  lipschitz_add := ⟨LipschitzAdd.C ℝ, by\n    rintro ⟨x₁, x₂⟩ ⟨y₁, y₂⟩\n    exact lipschitzWith_lipschitz_const_add_edist ⟨(x₁ : ℝ), x₂⟩ ⟨y₁, y₂⟩⟩\n\n"}
{"name":"BoundedSMul.dist_pair_smul'","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : PseudoMetricSpace α\ninst✝³ : PseudoMetricSpace β\ninst✝² : Zero α\ninst✝¹ : Zero β\ninst✝ : SMul α β\nself : BoundedSMul α β\nx₁ x₂ : α\ny : β\n⊢ LE.le (Dist.dist (HSMul.hSMul x₁ y) (HSMul.hSMul x₂ y)) (HMul.hMul (Dist.dist x₁ x₂) (Dist.dist y 0))","decl":"/-- Mixin typeclass on a scalar action of a metric space `α` on a metric space `β` both with\ndistinguished points `0`, requiring compatibility of the action in the sense that\n`dist (x • y₁) (x • y₂) ≤ dist x 0 * dist y₁ y₂` and\n`dist (x₁ • y) (x₂ • y) ≤ dist x₁ x₂ * dist y 0`. -/\nclass BoundedSMul : Prop where\n  dist_smul_pair' : ∀ x : α, ∀ y₁ y₂ : β, dist (x • y₁) (x • y₂) ≤ dist x 0 * dist y₁ y₂\n  dist_pair_smul' : ∀ x₁ x₂ : α, ∀ y : β, dist (x₁ • y) (x₂ • y) ≤ dist x₁ x₂ * dist y 0\n\n"}
{"name":"BoundedSMul.dist_smul_pair'","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : PseudoMetricSpace α\ninst✝³ : PseudoMetricSpace β\ninst✝² : Zero α\ninst✝¹ : Zero β\ninst✝ : SMul α β\nself : BoundedSMul α β\nx : α\ny₁ y₂ : β\n⊢ LE.le (Dist.dist (HSMul.hSMul x y₁) (HSMul.hSMul x y₂)) (HMul.hMul (Dist.dist x 0) (Dist.dist y₁ y₂))","decl":"/-- Mixin typeclass on a scalar action of a metric space `α` on a metric space `β` both with\ndistinguished points `0`, requiring compatibility of the action in the sense that\n`dist (x • y₁) (x • y₂) ≤ dist x 0 * dist y₁ y₂` and\n`dist (x₁ • y) (x₂ • y) ≤ dist x₁ x₂ * dist y 0`. -/\nclass BoundedSMul : Prop where\n  dist_smul_pair' : ∀ x : α, ∀ y₁ y₂ : β, dist (x • y₁) (x • y₂) ≤ dist x 0 * dist y₁ y₂\n  dist_pair_smul' : ∀ x₁ x₂ : α, ∀ y : β, dist (x₁ • y) (x₂ • y) ≤ dist x₁ x₂ * dist y 0\n\n"}
{"name":"dist_smul_pair","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : PseudoMetricSpace α\ninst✝⁴ : PseudoMetricSpace β\ninst✝³ : Zero α\ninst✝² : Zero β\ninst✝¹ : SMul α β\ninst✝ : BoundedSMul α β\nx : α\ny₁ y₂ : β\n⊢ LE.le (Dist.dist (HSMul.hSMul x y₁) (HSMul.hSMul x y₂)) (HMul.hMul (Dist.dist x 0) (Dist.dist y₁ y₂))","decl":"theorem dist_smul_pair (x : α) (y₁ y₂ : β) : dist (x • y₁) (x • y₂) ≤ dist x 0 * dist y₁ y₂ :=\n  BoundedSMul.dist_smul_pair' x y₁ y₂\n\n"}
{"name":"dist_pair_smul","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : PseudoMetricSpace α\ninst✝⁴ : PseudoMetricSpace β\ninst✝³ : Zero α\ninst✝² : Zero β\ninst✝¹ : SMul α β\ninst✝ : BoundedSMul α β\nx₁ x₂ : α\ny : β\n⊢ LE.le (Dist.dist (HSMul.hSMul x₁ y) (HSMul.hSMul x₂ y)) (HMul.hMul (Dist.dist x₁ x₂) (Dist.dist y 0))","decl":"theorem dist_pair_smul (x₁ x₂ : α) (y : β) : dist (x₁ • y) (x₂ • y) ≤ dist x₁ x₂ * dist y 0 :=\n  BoundedSMul.dist_pair_smul' x₁ x₂ y\n\n-- see Note [lower instance priority]\n"}
{"name":"BoundedSMul.continuousSMul","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : PseudoMetricSpace α\ninst✝¹ : PseudoMetricSpace β\ninst✝ : SMul α β\n⊢ ContinuousSMul α β","decl":"/-- The typeclass `BoundedSMul` on a metric-space scalar action implies continuity of the action. -/\ninstance (priority := 100) BoundedSMul.continuousSMul : ContinuousSMul α β where\n  continuous_smul := by\n    rw [Metric.continuous_iff]\n    rintro ⟨a, b⟩ ε ε0\n    obtain ⟨δ, δ0, hδε⟩ : ∃ δ > 0, δ * (δ + dist b 0) + dist a 0 * δ < ε := by\n      have : Continuous fun δ ↦ δ * (δ + dist b 0) + dist a 0 * δ := by fun_prop\n      refine ((this.tendsto' _ _ ?_).eventually (gt_mem_nhds ε0)).exists_gt\n      simp\n    refine ⟨δ, δ0, fun (a', b') hab' => ?_⟩\n    obtain ⟨ha, hb⟩ := max_lt_iff.1 hab'\n    calc dist (a' • b') (a • b)\n        ≤ dist (a' • b') (a • b') + dist (a • b') (a • b) := dist_triangle ..\n      _ ≤ dist a' a * dist b' 0 + dist a 0 * dist b' b :=\n        add_le_add (dist_pair_smul _ _ _) (dist_smul_pair _ _ _)\n      _ ≤ δ * (δ + dist b 0) + dist a 0 * δ := by\n          have : dist b' 0 ≤ δ + dist b 0 := (dist_triangle _ _ _).trans <| add_le_add_right hb.le _\n          gcongr\n      _ < ε := hδε\n\n"}
{"name":"BoundedSMul.toUniformContinuousConstSMul","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : PseudoMetricSpace α\ninst✝⁴ : PseudoMetricSpace β\ninst✝³ : Zero α\ninst✝² : Zero β\ninst✝¹ : SMul α β\ninst✝ : BoundedSMul α β\n⊢ UniformContinuousConstSMul α β","decl":"instance (priority := 100) BoundedSMul.toUniformContinuousConstSMul :\n    UniformContinuousConstSMul α β :=\n  ⟨fun c => ((lipschitzWith_iff_dist_le_mul (K := nndist c 0)).2 fun _ _ =>\n    dist_smul_pair c _ _).uniformContinuous⟩\n\n-- this instance could be deduced from `NormedSpace.boundedSMul`, but we prove it separately\n-- here so that it is available earlier in the hierarchy\n"}
{"name":"Real.boundedSMul","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"⊢ BoundedSMul Real Real","decl":"instance Real.boundedSMul : BoundedSMul ℝ ℝ where\n  dist_smul_pair' x y₁ y₂ := by simpa [Real.dist_eq, mul_sub] using (abs_mul x (y₁ - y₂)).le\n  dist_pair_smul' x₁ x₂ y := by simpa [Real.dist_eq, sub_mul] using (abs_mul (x₁ - x₂) y).le\n\n"}
{"name":"NNReal.boundedSMul","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"⊢ BoundedSMul NNReal NNReal","decl":"instance NNReal.boundedSMul : BoundedSMul ℝ≥0 ℝ≥0 where\n  dist_smul_pair' x y₁ y₂ := by convert dist_smul_pair (x : ℝ) (y₁ : ℝ) y₂ using 1\n  dist_pair_smul' x₁ x₂ y := by convert dist_pair_smul (x₁ : ℝ) x₂ (y : ℝ) using 1\n\n"}
{"name":"BoundedSMul.op","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁶ : PseudoMetricSpace α\ninst✝⁵ : PseudoMetricSpace β\ninst✝⁴ : Zero α\ninst✝³ : Zero β\ninst✝² : SMul α β\ninst✝¹ : SMul (MulOpposite α) β\ninst✝ : IsCentralScalar α β\n⊢ BoundedSMul (MulOpposite α) β","decl":"/-- If a scalar is central, then its right action is bounded when its left action is. -/\ninstance BoundedSMul.op [SMul αᵐᵒᵖ β] [IsCentralScalar α β] : BoundedSMul αᵐᵒᵖ β where\n  dist_smul_pair' :=\n    MulOpposite.rec' fun x y₁ y₂ => by simpa only [op_smul_eq_smul] using dist_smul_pair x y₁ y₂\n  dist_pair_smul' :=\n    MulOpposite.rec' fun x₁ =>\n      MulOpposite.rec' fun x₂ y => by simpa only [op_smul_eq_smul] using dist_pair_smul x₁ x₂ y\n\n"}
{"name":"instLipschitzAddAdditiveOfLipschitzMul","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"α : Type u_1\ninst✝² : PseudoMetricSpace α\ninst✝¹ : Monoid α\ninst✝ : LipschitzMul α\n⊢ LipschitzAdd (Additive α)","decl":"instance [Monoid α] [LipschitzMul α] : LipschitzAdd (Additive α) :=\n  ⟨@LipschitzMul.lipschitz_mul α _ _ _⟩\n\n"}
{"name":"instLipschitzMulMultiplicativeOfLipschitzAdd","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"α : Type u_1\ninst✝² : PseudoMetricSpace α\ninst✝¹ : AddMonoid α\ninst✝ : LipschitzAdd α\n⊢ LipschitzMul (Multiplicative α)","decl":"instance [AddMonoid α] [LipschitzAdd α] : LipschitzMul (Multiplicative α) :=\n  ⟨@LipschitzAdd.lipschitz_add α _ _ _⟩\n\n"}
{"name":"instLipschitzAddOrderDual","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"α : Type u_1\ninst✝² : PseudoMetricSpace α\ninst✝¹ : AddMonoid α\ninst✝ : LipschitzAdd α\n⊢ LipschitzAdd (OrderDual α)","decl":"@[to_additive]\ninstance [Monoid α] [LipschitzMul α] : LipschitzMul αᵒᵈ :=\n  ‹LipschitzMul α›\n\n"}
{"name":"instLipschitzMulOrderDual","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"α : Type u_1\ninst✝² : PseudoMetricSpace α\ninst✝¹ : Monoid α\ninst✝ : LipschitzMul α\n⊢ LipschitzMul (OrderDual α)","decl":"@[to_additive]\ninstance [Monoid α] [LipschitzMul α] : LipschitzMul αᵒᵈ :=\n  ‹LipschitzMul α›\n\n"}
{"name":"Pi.instBoundedSMul","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"ι : Type u_3\ninst✝⁶ : Fintype ι\nα : Type u_4\nβ : ι → Type u_5\ninst✝⁵ : PseudoMetricSpace α\ninst✝⁴ : (i : ι) → PseudoMetricSpace (β i)\ninst✝³ : Zero α\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : (i : ι) → SMul α (β i)\ninst✝ : ∀ (i : ι), BoundedSMul α (β i)\n⊢ BoundedSMul α ((i : ι) → β i)","decl":"instance Pi.instBoundedSMul {α : Type*} {β : ι → Type*} [PseudoMetricSpace α]\n    [∀ i, PseudoMetricSpace (β i)] [Zero α] [∀ i, Zero (β i)] [∀ i, SMul α (β i)]\n    [∀ i, BoundedSMul α (β i)] : BoundedSMul α (∀ i, β i) where\n  dist_smul_pair' x y₁ y₂ :=\n    (dist_pi_le_iff <| by positivity).2 fun _ ↦\n      (dist_smul_pair _ _ _).trans <| mul_le_mul_of_nonneg_left (dist_le_pi_dist _ _ _) dist_nonneg\n  dist_pair_smul' x₁ x₂ y :=\n    (dist_pi_le_iff <| by positivity).2 fun _ ↦\n      (dist_pair_smul _ _ _).trans <| mul_le_mul_of_nonneg_left (dist_le_pi_dist _ 0 _) dist_nonneg\n\n"}
{"name":"Pi.instBoundedSMul'","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"ι : Type u_3\ninst✝⁶ : Fintype ι\nα : ι → Type u_4\nβ : ι → Type u_5\ninst✝⁵ : (i : ι) → PseudoMetricSpace (α i)\ninst✝⁴ : (i : ι) → PseudoMetricSpace (β i)\ninst✝³ : (i : ι) → Zero (α i)\ninst✝² : (i : ι) → Zero (β i)\ninst✝¹ : (i : ι) → SMul (α i) (β i)\ninst✝ : ∀ (i : ι), BoundedSMul (α i) (β i)\n⊢ BoundedSMul ((i : ι) → α i) ((i : ι) → β i)","decl":"instance Pi.instBoundedSMul' {α β : ι → Type*} [∀ i, PseudoMetricSpace (α i)]\n    [∀ i, PseudoMetricSpace (β i)] [∀ i, Zero (α i)] [∀ i, Zero (β i)] [∀ i, SMul (α i) (β i)]\n    [∀ i, BoundedSMul (α i) (β i)] : BoundedSMul (∀ i, α i) (∀ i, β i) where\n  dist_smul_pair' x y₁ y₂ :=\n    (dist_pi_le_iff <| by positivity).2 fun _ ↦\n      (dist_smul_pair _ _ _).trans <|\n        mul_le_mul (dist_le_pi_dist _ 0 _) (dist_le_pi_dist _ _ _) dist_nonneg dist_nonneg\n  dist_pair_smul' x₁ x₂ y :=\n    (dist_pi_le_iff <| by positivity).2 fun _ ↦\n      (dist_pair_smul _ _ _).trans <|\n        mul_le_mul (dist_le_pi_dist _ _ _) (dist_le_pi_dist _ 0 _) dist_nonneg dist_nonneg\n\n"}
{"name":"Prod.instBoundedSMul","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"α : Type u_4\nβ : Type u_5\nγ : Type u_6\ninst✝⁹ : PseudoMetricSpace α\ninst✝⁸ : PseudoMetricSpace β\ninst✝⁷ : PseudoMetricSpace γ\ninst✝⁶ : Zero α\ninst✝⁵ : Zero β\ninst✝⁴ : Zero γ\ninst✝³ : SMul α β\ninst✝² : SMul α γ\ninst✝¹ : BoundedSMul α β\ninst✝ : BoundedSMul α γ\n⊢ BoundedSMul α (Prod β γ)","decl":"instance Prod.instBoundedSMul {α β γ : Type*} [PseudoMetricSpace α] [PseudoMetricSpace β]\n    [PseudoMetricSpace γ] [Zero α] [Zero β] [Zero γ] [SMul α β] [SMul α γ] [BoundedSMul α β]\n    [BoundedSMul α γ] : BoundedSMul α (β × γ) where\n  dist_smul_pair' _x _y₁ _y₂ :=\n    max_le ((dist_smul_pair _ _ _).trans <| mul_le_mul_of_nonneg_left (le_max_left _ _) dist_nonneg)\n      ((dist_smul_pair _ _ _).trans <| mul_le_mul_of_nonneg_left (le_max_right _ _) dist_nonneg)\n  dist_pair_smul' _x₁ _x₂ _y :=\n    max_le ((dist_pair_smul _ _ _).trans <| mul_le_mul_of_nonneg_left (le_max_left _ _) dist_nonneg)\n      ((dist_pair_smul _ _ _).trans <| mul_le_mul_of_nonneg_left (le_max_right _ _) dist_nonneg)\n\n"}
{"name":"instBoundedSMulSeparationQuotient","module":"Mathlib.Topology.MetricSpace.Algebra","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝⁵ : PseudoMetricSpace α\ninst✝⁴ : PseudoMetricSpace β\ninst✝³ : Zero α\ninst✝² : Zero β\ninst✝¹ : SMul α β\ninst✝ : BoundedSMul α β\n⊢ BoundedSMul α (SeparationQuotient β)","decl":"instance {α β : Type*}\n    [PseudoMetricSpace α] [PseudoMetricSpace β] [Zero α] [Zero β] [SMul α β] [BoundedSMul α β] :\n    BoundedSMul α (SeparationQuotient β) where\n  dist_smul_pair' _ := Quotient.ind₂ <| dist_smul_pair _\n  dist_pair_smul' _ _ := Quotient.ind <| dist_pair_smul _ _\n\n-- We don't have the `SMul α γ → SMul β δ → SMul (α × β) (γ × δ)` instance, but if we did, then\n-- `BoundedSMul α γ → BoundedSMul β δ → BoundedSMul (α × β) (γ × δ)` would hold\n"}
