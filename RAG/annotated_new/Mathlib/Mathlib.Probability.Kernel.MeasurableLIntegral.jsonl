{"name":"ProbabilityTheory.Kernel.measurable_kernel_prod_mk_left_of_finite","module":"Mathlib.Probability.Kernel.MeasurableLIntegral","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nt : Set (Prod α β)\nht : MeasurableSet t\nhκs : ∀ (a : α), MeasureTheory.IsFiniteMeasure (κ a)\n⊢ Measurable fun a => (κ a) (Set.preimage (Prod.mk a) t)","decl":"/-- This is an auxiliary lemma for `measurable_kernel_prod_mk_left`. -/\ntheorem measurable_kernel_prod_mk_left_of_finite {t : Set (α × β)} (ht : MeasurableSet t)\n    (hκs : ∀ a, IsFiniteMeasure (κ a)) : Measurable fun a => κ a (Prod.mk a ⁻¹' t) := by\n  -- `t` is a measurable set in the product `α × β`: we use that the product σ-algebra is generated\n  -- by boxes to prove the result by induction.\n  induction t, ht\n    using MeasurableSpace.induction_on_inter generateFrom_prod.symm isPiSystem_prod with\n  | empty =>\n    simp only [preimage_empty, measure_empty, measurable_const]\n  | basic t ht =>\n    simp only [Set.mem_image2, Set.mem_setOf_eq] at ht\n    obtain ⟨t₁, ht₁, t₂, ht₂, rfl⟩ := ht\n    classical\n    simp_rw [mk_preimage_prod_right_eq_if]\n    have h_eq_ite : (fun a => κ a (ite (a ∈ t₁) t₂ ∅)) = fun a => ite (a ∈ t₁) (κ a t₂) 0 := by\n      ext1 a\n      split_ifs\n      exacts [rfl, measure_empty]\n    rw [h_eq_ite]\n    exact Measurable.ite ht₁ (Kernel.measurable_coe κ ht₂) measurable_const\n  | compl t htm iht =>\n    have h_eq_sdiff : ∀ a, Prod.mk a ⁻¹' tᶜ = Set.univ \\ Prod.mk a ⁻¹' t := by\n      intro a\n      ext1 b\n      simp only [mem_compl_iff, mem_preimage, mem_diff, mem_univ, true_and]\n    simp_rw [h_eq_sdiff]\n    have :\n      (fun a => κ a (Set.univ \\ Prod.mk a ⁻¹' t)) = fun a =>\n        κ a Set.univ - κ a (Prod.mk a ⁻¹' t) := by\n      ext1 a\n      rw [← Set.diff_inter_self_eq_diff, Set.inter_univ, measure_diff (Set.subset_univ _)]\n      · exact (measurable_prod_mk_left htm).nullMeasurableSet\n      · exact measure_ne_top _ _\n    rw [this]\n    exact Measurable.sub (Kernel.measurable_coe κ MeasurableSet.univ) iht\n  | iUnion f h_disj hf_meas hf =>\n    have (a : α) : κ a (Prod.mk a ⁻¹' ⋃ i, f i) = ∑' i, κ a (Prod.mk a ⁻¹' f i) := by\n      rw [preimage_iUnion, measure_iUnion]\n      · exact h_disj.mono fun _ _ ↦ .preimage _\n      · exact fun i ↦ measurable_prod_mk_left (hf_meas i)\n    simpa only [this] using Measurable.ennreal_tsum hf\n\n"}
{"name":"ProbabilityTheory.Kernel.measurable_kernel_prod_mk_left","module":"Mathlib.Probability.Kernel.MeasurableLIntegral","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nt : Set (Prod α β)\nht : MeasurableSet t\n⊢ Measurable fun a => (κ a) (Set.preimage (Prod.mk a) t)","decl":"theorem measurable_kernel_prod_mk_left [IsSFiniteKernel κ] {t : Set (α × β)}\n    (ht : MeasurableSet t) : Measurable fun a => κ a (Prod.mk a ⁻¹' t) := by\n  rw [← Kernel.kernel_sum_seq κ]\n  have : ∀ a, Kernel.sum (Kernel.seq κ) a (Prod.mk a ⁻¹' t) =\n      ∑' n, Kernel.seq κ n a (Prod.mk a ⁻¹' t) := fun a =>\n    Kernel.sum_apply' _ _ (measurable_prod_mk_left ht)\n  simp_rw [this]\n  refine Measurable.ennreal_tsum fun n => ?_\n  exact measurable_kernel_prod_mk_left_of_finite ht inferInstance\n\n"}
{"name":"ProbabilityTheory.Kernel.measurable_kernel_prod_mk_left'","module":"Mathlib.Probability.Kernel.MeasurableLIntegral","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nmγ : MeasurableSpace γ\nη : ProbabilityTheory.Kernel (Prod α β) γ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\ns : Set (Prod β γ)\nhs : MeasurableSet s\na : α\n⊢ Measurable fun b => (η { fst := a, snd := b }) (Set.preimage (Prod.mk b) s)","decl":"theorem measurable_kernel_prod_mk_left' [IsSFiniteKernel η] {s : Set (β × γ)} (hs : MeasurableSet s)\n    (a : α) : Measurable fun b => η (a, b) (Prod.mk b ⁻¹' s) := by\n  have : ∀ b, Prod.mk b ⁻¹' s = {c | ((a, b), c) ∈ {p : (α × β) × γ | (p.1.2, p.2) ∈ s}} := by\n    intro b; rfl\n  simp_rw [this]\n  refine (measurable_kernel_prod_mk_left ?_).comp measurable_prod_mk_left\n  exact (measurable_fst.snd.prod_mk measurable_snd) hs\n\n"}
{"name":"ProbabilityTheory.Kernel.measurable_kernel_prod_mk_right","module":"Mathlib.Probability.Kernel.MeasurableLIntegral","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\ns : Set (Prod β α)\nhs : MeasurableSet s\n⊢ Measurable fun y => (κ y) (Set.preimage (fun x => { fst := x, snd := y }) s)","decl":"theorem measurable_kernel_prod_mk_right [IsSFiniteKernel κ] {s : Set (β × α)}\n    (hs : MeasurableSet s) : Measurable fun y => κ y ((fun x => (x, y)) ⁻¹' s) :=\n  measurable_kernel_prod_mk_left (measurableSet_swap_iff.mpr hs)\n\n"}
{"name":"ProbabilityTheory.Kernel.measurable_lintegral_indicator_const","module":"Mathlib.Probability.Kernel.MeasurableLIntegral","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nt : Set (Prod α β)\nht : MeasurableSet t\nc : ENNReal\n⊢ Measurable fun a => MeasureTheory.lintegral (κ a) fun b => t.indicator (Function.const (Prod α β) c) { fst := a, snd := b }","decl":"/-- Auxiliary lemma for `Measurable.lintegral_kernel_prod_right`. -/\ntheorem Kernel.measurable_lintegral_indicator_const {t : Set (α × β)} (ht : MeasurableSet t)\n    (c : ℝ≥0∞) : Measurable fun a => ∫⁻ b, t.indicator (Function.const (α × β) c) (a, b) ∂κ a := by\n  -- Porting note: was originally by\n  -- `simp_rw [lintegral_indicator_const_comp measurable_prod_mk_left ht _]`\n  -- but this has no effect, so added the `conv` below\n  conv =>\n    congr\n    ext\n    erw [lintegral_indicator_const_comp measurable_prod_mk_left ht _]\n  exact Measurable.const_mul (measurable_kernel_prod_mk_left ht) c\n\n"}
{"name":"Measurable.lintegral_kernel_prod_right","module":"Mathlib.Probability.Kernel.MeasurableLIntegral","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nf : α → β → ENNReal\nhf : Measurable (Function.uncurry f)\n⊢ Measurable fun a => MeasureTheory.lintegral (κ a) fun b => f a b","decl":"/-- For an s-finite kernel `κ` and a function `f : α → β → ℝ≥0∞` which is measurable when seen as a\nmap from `α × β` (hypothesis `Measurable (uncurry f)`), the integral `a ↦ ∫⁻ b, f a b ∂(κ a)` is\nmeasurable. -/\ntheorem _root_.Measurable.lintegral_kernel_prod_right {f : α → β → ℝ≥0∞}\n    (hf : Measurable (uncurry f)) : Measurable fun a => ∫⁻ b, f a b ∂κ a := by\n  let F : ℕ → SimpleFunc (α × β) ℝ≥0∞ := SimpleFunc.eapprox (uncurry f)\n  have h : ∀ a, ⨆ n, F n a = uncurry f a := SimpleFunc.iSup_eapprox_apply hf\n  simp only [Prod.forall, uncurry_apply_pair] at h\n  simp_rw [← h]\n  have : ∀ a, (∫⁻ b, ⨆ n, F n (a, b) ∂κ a) = ⨆ n, ∫⁻ b, F n (a, b) ∂κ a := by\n    intro a\n    rw [lintegral_iSup]\n    · exact fun n => (F n).measurable.comp measurable_prod_mk_left\n    · exact fun i j hij b => SimpleFunc.monotone_eapprox (uncurry f) hij _\n  simp_rw [this]\n  refine .iSup fun n => ?_\n  refine SimpleFunc.induction\n    (P := fun f => Measurable (fun (a : α) => ∫⁻ (b : β), f (a, b) ∂κ a)) ?_ ?_ (F n)\n  · intro c t ht\n    simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_const,\n      SimpleFunc.coe_zero, Set.piecewise_eq_indicator]\n    exact Kernel.measurable_lintegral_indicator_const (κ := κ) ht c\n  · intro g₁ g₂ _ hm₁ hm₂\n    simp only [SimpleFunc.coe_add, Pi.add_apply]\n    have h_add :\n      (fun a => ∫⁻ b, g₁ (a, b) + g₂ (a, b) ∂κ a) =\n        (fun a => ∫⁻ b, g₁ (a, b) ∂κ a) + fun a => ∫⁻ b, g₂ (a, b) ∂κ a := by\n      ext1 a\n      rw [Pi.add_apply]\n      -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11224): was `rw` (`Function.comp` reducibility)\n      erw [lintegral_add_left (g₁.measurable.comp measurable_prod_mk_left)]\n      simp_rw [Function.comp_apply]\n    rw [h_add]\n    exact Measurable.add hm₁ hm₂\n\n"}
{"name":"Measurable.lintegral_kernel_prod_right'","module":"Mathlib.Probability.Kernel.MeasurableLIntegral","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nf : Prod α β → ENNReal\nhf : Measurable f\n⊢ Measurable fun a => MeasureTheory.lintegral (κ a) fun b => f { fst := a, snd := b }","decl":"theorem _root_.Measurable.lintegral_kernel_prod_right' {f : α × β → ℝ≥0∞} (hf : Measurable f) :\n    Measurable fun a => ∫⁻ b, f (a, b) ∂κ a := by\n  refine Measurable.lintegral_kernel_prod_right ?_\n  have : (uncurry fun (a : α) (b : β) => f (a, b)) = f := by\n    ext x; rw [uncurry_apply_pair]\n  rwa [this]\n\n"}
{"name":"Measurable.lintegral_kernel_prod_right''","module":"Mathlib.Probability.Kernel.MeasurableLIntegral","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nmγ : MeasurableSpace γ\nη : ProbabilityTheory.Kernel (Prod α β) γ\na : α\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\nf : Prod β γ → ENNReal\nhf : Measurable f\n⊢ Measurable fun x => MeasureTheory.lintegral (η { fst := a, snd := x }) fun y => f { fst := x, snd := y }","decl":"theorem _root_.Measurable.lintegral_kernel_prod_right'' {f : β × γ → ℝ≥0∞} (hf : Measurable f) :\n    Measurable fun x => ∫⁻ y, f (x, y) ∂η (a, x) := by\n  -- Porting note: used `Prod.mk a` instead of `fun x => (a, x)` below\n  change\n    Measurable\n      ((fun x => ∫⁻ y, (fun u : (α × β) × γ => f (u.1.2, u.2)) (x, y) ∂η x) ∘ Prod.mk a)\n  -- Porting note: specified `κ`, `f`.\n  refine (Measurable.lintegral_kernel_prod_right' (κ := η)\n    (f := (fun u ↦ f (u.fst.snd, u.snd))) ?_).comp measurable_prod_mk_left\n  exact hf.comp (measurable_fst.snd.prod_mk measurable_snd)\n\n"}
{"name":"Measurable.setLIntegral_kernel_prod_right","module":"Mathlib.Probability.Kernel.MeasurableLIntegral","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nf : α → β → ENNReal\nhf : Measurable (Function.uncurry f)\ns : Set β\nhs : MeasurableSet s\n⊢ Measurable fun a => MeasureTheory.lintegral ((κ a).restrict s) fun b => f a b","decl":"theorem _root_.Measurable.setLIntegral_kernel_prod_right {f : α → β → ℝ≥0∞}\n    (hf : Measurable (uncurry f)) {s : Set β} (hs : MeasurableSet s) :\n    Measurable fun a => ∫⁻ b in s, f a b ∂κ a := by\n  simp_rw [← lintegral_restrict κ hs]; exact hf.lintegral_kernel_prod_right\n\n"}
{"name":"Measurable.lintegral_kernel_prod_left'","module":"Mathlib.Probability.Kernel.MeasurableLIntegral","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nf : Prod β α → ENNReal\nhf : Measurable f\n⊢ Measurable fun y => MeasureTheory.lintegral (κ y) fun x => f { fst := x, snd := y }","decl":"theorem _root_.Measurable.lintegral_kernel_prod_left' {f : β × α → ℝ≥0∞} (hf : Measurable f) :\n    Measurable fun y => ∫⁻ x, f (x, y) ∂κ y :=\n  (measurable_swap_iff.mpr hf).lintegral_kernel_prod_right'\n\n"}
{"name":"Measurable.lintegral_kernel_prod_left","module":"Mathlib.Probability.Kernel.MeasurableLIntegral","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nf : β → α → ENNReal\nhf : Measurable (Function.uncurry f)\n⊢ Measurable fun y => MeasureTheory.lintegral (κ y) fun x => f x y","decl":"theorem _root_.Measurable.lintegral_kernel_prod_left {f : β → α → ℝ≥0∞}\n    (hf : Measurable (uncurry f)) : Measurable fun y => ∫⁻ x, f x y ∂κ y :=\n  hf.lintegral_kernel_prod_left'\n\n"}
{"name":"Measurable.setLIntegral_kernel_prod_left","module":"Mathlib.Probability.Kernel.MeasurableLIntegral","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nf : β → α → ENNReal\nhf : Measurable (Function.uncurry f)\ns : Set β\nhs : MeasurableSet s\n⊢ Measurable fun b => MeasureTheory.lintegral ((κ b).restrict s) fun a => f a b","decl":"theorem _root_.Measurable.setLIntegral_kernel_prod_left {f : β → α → ℝ≥0∞}\n    (hf : Measurable (uncurry f)) {s : Set β} (hs : MeasurableSet s) :\n    Measurable fun b => ∫⁻ a in s, f a b ∂κ b := by\n  simp_rw [← lintegral_restrict κ hs]; exact hf.lintegral_kernel_prod_left\n\n"}
{"name":"Measurable.lintegral_kernel","module":"Mathlib.Probability.Kernel.MeasurableLIntegral","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nf : β → ENNReal\nhf : Measurable f\n⊢ Measurable fun a => MeasureTheory.lintegral (κ a) fun b => f b","decl":"theorem _root_.Measurable.lintegral_kernel {f : β → ℝ≥0∞} (hf : Measurable f) :\n    Measurable fun a => ∫⁻ b, f b ∂κ a :=\n  Measurable.lintegral_kernel_prod_right (hf.comp measurable_snd)\n\n"}
{"name":"Measurable.setLIntegral_kernel","module":"Mathlib.Probability.Kernel.MeasurableLIntegral","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nf : β → ENNReal\nhf : Measurable f\ns : Set β\nhs : MeasurableSet s\n⊢ Measurable fun a => MeasureTheory.lintegral ((κ a).restrict s) fun b => f b","decl":"theorem _root_.Measurable.setLIntegral_kernel {f : β → ℝ≥0∞} (hf : Measurable f) {s : Set β}\n    (hs : MeasurableSet s) : Measurable fun a => ∫⁻ b in s, f b ∂κ a := by\n  -- Porting note: was term mode proof (`Function.comp` reducibility)\n  refine Measurable.setLIntegral_kernel_prod_right ?_ hs\n  convert hf.comp measurable_snd\n\n"}
