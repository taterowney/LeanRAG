{"name":"PMF.monad_map_eq_map","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α β : Type u\nf : α → β\np : PMF α\n⊢ Eq (Functor.map f p) (PMF.map f p)","decl":"theorem monad_map_eq_map {α β : Type u} (f : α → β) (p : PMF α) : f <$> p = p.map f := rfl\n\n"}
{"name":"PMF.map_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\np : PMF α\nb : β\n⊢ Eq ((PMF.map f p) b) (tsum fun a => ite (Eq b (f a)) (p a) 0)","decl":"open scoped Classical in\n@[simp]\ntheorem map_apply : (map f p) b = ∑' a, if b = f a then p a else 0 := by simp [map]\n\n"}
{"name":"PMF.support_map","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\np : PMF α\n⊢ Eq (PMF.map f p).support (Set.image f p.support)","decl":"@[simp]\ntheorem support_map : (map f p).support = f '' p.support :=\n  Set.ext fun b => by simp [map, @eq_comm β b]\n\n"}
{"name":"PMF.mem_support_map_iff","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\np : PMF α\nb : β\n⊢ Iff (Membership.mem (PMF.map f p).support b) (Exists fun a => And (Membership.mem p.support a) (Eq (f a) b))","decl":"theorem mem_support_map_iff : b ∈ (map f p).support ↔ ∃ a ∈ p.support, f a = b := by simp\n\n"}
{"name":"PMF.bind_pure_comp","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\np : PMF α\n⊢ Eq (p.bind (Function.comp PMF.pure f)) (PMF.map f p)","decl":"theorem bind_pure_comp : bind p (pure ∘ f) = map f p := rfl\n\n"}
{"name":"PMF.map_id","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\np : PMF α\n⊢ Eq (PMF.map id p) p","decl":"theorem map_id : map id p = p :=\n  bind_pure _\n\n"}
{"name":"PMF.map_comp","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\np : PMF α\ng : β → γ\n⊢ Eq (PMF.map g (PMF.map f p)) (PMF.map (Function.comp g f) p)","decl":"theorem map_comp (g : β → γ) : (p.map f).map g = p.map (g ∘ f) := by simp [map, Function.comp_def]\n\n"}
{"name":"PMF.pure_map","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\na : α\n⊢ Eq (PMF.map f (PMF.pure a)) (PMF.pure (f a))","decl":"theorem pure_map (a : α) : (pure a).map f = pure (f a) :=\n  pure_bind _ _\n\n"}
{"name":"PMF.map_bind","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\np : PMF α\nq : α → PMF β\nf : β → γ\n⊢ Eq (PMF.map f (p.bind q)) (p.bind fun a => PMF.map f (q a))","decl":"theorem map_bind (q : α → PMF β) (f : β → γ) : (p.bind q).map f = p.bind fun a => (q a).map f :=\n  bind_bind _ _ _\n\n"}
{"name":"PMF.bind_map","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\np : PMF α\nf : α → β\nq : β → PMF γ\n⊢ Eq ((PMF.map f p).bind q) (p.bind (Function.comp q f))","decl":"@[simp]\ntheorem bind_map (p : PMF α) (f : α → β) (q : β → PMF γ) : (p.map f).bind q = p.bind (q ∘ f) :=\n  (bind_bind _ _ _).trans (congr_arg _ (funext fun _ => pure_bind _ _))\n\n"}
{"name":"PMF.map_const","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\np : PMF α\nb : β\n⊢ Eq (PMF.map (Function.const α b) p) (PMF.pure b)","decl":"@[simp]\ntheorem map_const : p.map (Function.const α b) = pure b := by\n  simp only [map, Function.comp_def, bind_const, Function.const]\n\n"}
{"name":"PMF.toOuterMeasure_map_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\np : PMF α\ns : Set β\n⊢ Eq ((PMF.map f p).toOuterMeasure s) (p.toOuterMeasure (Set.preimage f s))","decl":"@[simp]\ntheorem toOuterMeasure_map_apply : (p.map f).toOuterMeasure s = p.toOuterMeasure (f ⁻¹' s) := by\n  simp [map, Set.indicator, toOuterMeasure_apply p (f ⁻¹' s)]\n  rfl\n\n"}
{"name":"PMF.toMeasure_map_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\np : PMF α\ns : Set β\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nhf : Measurable f\nhs : MeasurableSet s\n⊢ Eq ((PMF.map f p).toMeasure s) (p.toMeasure (Set.preimage f s))","decl":"@[simp]\ntheorem toMeasure_map_apply (hf : Measurable f)\n    (hs : MeasurableSet s) : (p.map f).toMeasure s = p.toMeasure (f ⁻¹' s) := by\n  rw [toMeasure_apply_eq_toOuterMeasure_apply _ s hs,\n    toMeasure_apply_eq_toOuterMeasure_apply _ (f ⁻¹' s) (measurableSet_preimage hf hs)]\n  exact toOuterMeasure_map_apply f p s\n\n"}
{"name":"PMF.toMeasure_map","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\np : PMF α\nhf : Measurable f\n⊢ Eq (MeasureTheory.Measure.map f p.toMeasure) (PMF.map f p).toMeasure","decl":"@[simp]\nlemma toMeasure_map (p : PMF α) (hf : Measurable f) : p.toMeasure.map f = (p.map f).toMeasure := by\n  ext s hs : 1; rw [PMF.toMeasure_map_apply _ _ _ hf hs, Measure.map_apply hf hs]\n\n"}
{"name":"PMF.monad_seq_eq_seq","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α β : Type u\nq : PMF (α → β)\np : PMF α\n⊢ Eq (Seq.seq q fun x => p) (q.seq p)","decl":"theorem monad_seq_eq_seq {α β : Type u} (q : PMF (α → β)) (p : PMF α) : q <*> p = q.seq p := rfl\n\n"}
{"name":"PMF.seq_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nq : PMF (α → β)\np : PMF α\nb : β\n⊢ Eq ((q.seq p) b) (tsum fun f => tsum fun a => ite (Eq b (f a)) (HMul.hMul (q f) (p a)) 0)","decl":"open scoped Classical in\n@[simp]\ntheorem seq_apply : (seq q p) b = ∑' (f : α → β) (a : α), if b = f a then q f * p a else 0 := by\n  simp only [seq, mul_boole, bind_apply, pure_apply]\n  refine tsum_congr fun f => ENNReal.tsum_mul_left.symm.trans (tsum_congr fun a => ?_)\n  simpa only [mul_zero] using mul_ite (b = f a) (q f) (p a) 0\n\n"}
{"name":"PMF.support_seq","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nq : PMF (α → β)\np : PMF α\n⊢ Eq (q.seq p).support (Set.iUnion fun f => Set.iUnion fun h => Set.image f p.support)","decl":"@[simp]\ntheorem support_seq : (seq q p).support = ⋃ f ∈ q.support, f '' p.support :=\n  Set.ext fun b => by simp [-mem_support_iff, seq, @eq_comm β b]\n\n"}
{"name":"PMF.mem_support_seq_iff","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\nq : PMF (α → β)\np : PMF α\nb : β\n⊢ Iff (Membership.mem (q.seq p).support b) (Exists fun f => And (Membership.mem q.support f) (Membership.mem (Set.image f p.support) b))","decl":"theorem mem_support_seq_iff : b ∈ (seq q p).support ↔ ∃ f ∈ q.support, b ∈ f '' p.support := by simp\n\n"}
{"name":"PMF.instLawfulFunctor","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"⊢ LawfulFunctor PMF","decl":"instance : LawfulFunctor PMF where\n  map_const := rfl\n  id_map := bind_pure\n  comp_map _ _ _ := (map_comp _ _ _).symm\n\n"}
{"name":"PMF.instLawfulMonad","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"⊢ LawfulMonad PMF","decl":"instance : LawfulMonad PMF := LawfulMonad.mk'\n  (bind_pure_comp := fun _ _ => rfl)\n  (id_map := id_map)\n  (pure_bind := pure_bind)\n  (bind_assoc := bind_bind)\n\n"}
{"name":"PMF.ofFinset_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nf : α → ENNReal\ns : Finset α\nh : Eq (s.sum fun a => f a) 1\nh' : ∀ (a : α), Not (Membership.mem s a) → Eq (f a) 0\na : α\n⊢ Eq ((PMF.ofFinset f s h h') a) (f a)","decl":"@[simp]\ntheorem ofFinset_apply (a : α) : ofFinset f s h h' a = f a := rfl\n\n"}
{"name":"PMF.support_ofFinset","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nf : α → ENNReal\ns : Finset α\nh : Eq (s.sum fun a => f a) 1\nh' : ∀ (a : α), Not (Membership.mem s a) → Eq (f a) 0\n⊢ Eq (PMF.ofFinset f s h h').support (Inter.inter (↑s) (Function.support f))","decl":"@[simp]\ntheorem support_ofFinset : (ofFinset f s h h').support = ↑s ∩ Function.support f :=\n  Set.ext fun a => by simpa [mem_support_iff] using mt (h' a)\n\n"}
{"name":"PMF.mem_support_ofFinset_iff","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nf : α → ENNReal\ns : Finset α\nh : Eq (s.sum fun a => f a) 1\nh' : ∀ (a : α), Not (Membership.mem s a) → Eq (f a) 0\na : α\n⊢ Iff (Membership.mem (PMF.ofFinset f s h h').support a) (And (Membership.mem s a) (Ne (f a) 0))","decl":"theorem mem_support_ofFinset_iff (a : α) : a ∈ (ofFinset f s h h').support ↔ a ∈ s ∧ f a ≠ 0 := by\n  simp\n\n"}
{"name":"PMF.ofFinset_apply_of_not_mem","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nf : α → ENNReal\ns : Finset α\nh : Eq (s.sum fun a => f a) 1\nh' : ∀ (a : α), Not (Membership.mem s a) → Eq (f a) 0\na : α\nha : Not (Membership.mem s a)\n⊢ Eq ((PMF.ofFinset f s h h') a) 0","decl":"theorem ofFinset_apply_of_not_mem {a : α} (ha : a ∉ s) : ofFinset f s h h' a = 0 :=\n  h' a ha\n\n"}
{"name":"PMF.toOuterMeasure_ofFinset_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nf : α → ENNReal\ns : Finset α\nh : Eq (s.sum fun a => f a) 1\nh' : ∀ (a : α), Not (Membership.mem s a) → Eq (f a) 0\nt : Set α\n⊢ Eq ((PMF.ofFinset f s h h').toOuterMeasure t) (tsum fun x => t.indicator f x)","decl":"@[simp]\ntheorem toOuterMeasure_ofFinset_apply :\n    (ofFinset f s h h').toOuterMeasure t = ∑' x, t.indicator f x :=\n  toOuterMeasure_apply (ofFinset f s h h') t\n\n"}
{"name":"PMF.toMeasure_ofFinset_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nf : α → ENNReal\ns : Finset α\nh : Eq (s.sum fun a => f a) 1\nh' : ∀ (a : α), Not (Membership.mem s a) → Eq (f a) 0\nt : Set α\ninst✝ : MeasurableSpace α\nht : MeasurableSet t\n⊢ Eq ((PMF.ofFinset f s h h').toMeasure t) (tsum fun x => t.indicator f x)","decl":"@[simp]\ntheorem toMeasure_ofFinset_apply [MeasurableSpace α] (ht : MeasurableSet t) :\n    (ofFinset f s h h').toMeasure t = ∑' x, t.indicator f x :=\n  (toMeasure_apply_eq_toOuterMeasure_apply _ t ht).trans (toOuterMeasure_ofFinset_apply h h' t)\n\n"}
{"name":"PMF.ofFintype_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\ninst✝ : Fintype α\nf : α → ENNReal\nh : Eq (Finset.univ.sum fun a => f a) 1\na : α\n⊢ Eq ((PMF.ofFintype f h) a) (f a)","decl":"@[simp]\ntheorem ofFintype_apply (a : α) : ofFintype f h a = f a := rfl\n\n"}
{"name":"PMF.support_ofFintype","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\ninst✝ : Fintype α\nf : α → ENNReal\nh : Eq (Finset.univ.sum fun a => f a) 1\n⊢ Eq (PMF.ofFintype f h).support (Function.support f)","decl":"@[simp]\ntheorem support_ofFintype : (ofFintype f h).support = Function.support f := rfl\n\n"}
{"name":"PMF.mem_support_ofFintype_iff","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\ninst✝ : Fintype α\nf : α → ENNReal\nh : Eq (Finset.univ.sum fun a => f a) 1\na : α\n⊢ Iff (Membership.mem (PMF.ofFintype f h).support a) (Ne (f a) 0)","decl":"theorem mem_support_ofFintype_iff (a : α) : a ∈ (ofFintype f h).support ↔ f a ≠ 0 := Iff.rfl\n\n"}
{"name":"PMF.map_ofFintype","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : α → ENNReal\nh : Eq (Finset.univ.sum fun a => f a) 1\ng : α → β\n⊢ Eq (PMF.map g (PMF.ofFintype f h)) (PMF.ofFintype (fun b => (Finset.filter (fun a => Eq (g a) b) Finset.univ).sum fun a => f a) ⋯)","decl":"open scoped Classical in\n@[simp]\nlemma map_ofFintype [Fintype β] (f : α → ℝ≥0∞) (h : ∑ a, f a = 1) (g : α → β) :\n    (ofFintype f h).map g = ofFintype (fun b ↦ ∑ a with g a = b, f a)\n      (by simpa [Finset.sum_fiberwise_eq_sum_filter univ univ g f]) := by\n  ext b : 1\n  simp only [sum_filter, eq_comm, map_apply, ofFintype_apply]\n  exact tsum_eq_sum fun _ h ↦ (h <| mem_univ _).elim\n\n"}
{"name":"PMF.toOuterMeasure_ofFintype_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\ninst✝ : Fintype α\nf : α → ENNReal\nh : Eq (Finset.univ.sum fun a => f a) 1\ns : Set α\n⊢ Eq ((PMF.ofFintype f h).toOuterMeasure s) (tsum fun x => s.indicator f x)","decl":"@[simp high]\ntheorem toOuterMeasure_ofFintype_apply : (ofFintype f h).toOuterMeasure s = ∑' x, s.indicator f x :=\n  toOuterMeasure_apply (ofFintype f h) s\n\n"}
{"name":"PMF.toMeasure_ofFintype_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\nf : α → ENNReal\nh : Eq (Finset.univ.sum fun a => f a) 1\ns : Set α\ninst✝ : MeasurableSpace α\nhs : MeasurableSet s\n⊢ Eq ((PMF.ofFintype f h).toMeasure s) (tsum fun x => s.indicator f x)","decl":"@[simp]\ntheorem toMeasure_ofFintype_apply [MeasurableSpace α] (hs : MeasurableSet s) :\n    (ofFintype f h).toMeasure s = ∑' x, s.indicator f x :=\n  (toMeasure_apply_eq_toOuterMeasure_apply _ s hs).trans (toOuterMeasure_ofFintype_apply h s)\n\n"}
{"name":"PMF.normalize_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nf : α → ENNReal\nhf0 : Ne (tsum f) 0\nhf : Ne (tsum f) Top.top\na : α\n⊢ Eq ((PMF.normalize f hf0 hf) a) (HMul.hMul (f a) (Inv.inv (tsum fun x => f x)))","decl":"@[simp]\ntheorem normalize_apply (a : α) : (normalize f hf0 hf) a = f a * (∑' x, f x)⁻¹ := rfl\n\n"}
{"name":"PMF.support_normalize","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nf : α → ENNReal\nhf0 : Ne (tsum f) 0\nhf : Ne (tsum f) Top.top\n⊢ Eq (PMF.normalize f hf0 hf).support (Function.support f)","decl":"@[simp]\ntheorem support_normalize : (normalize f hf0 hf).support = Function.support f :=\n  Set.ext fun a => by simp [hf, mem_support_iff]\n\n"}
{"name":"PMF.mem_support_normalize_iff","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\nf : α → ENNReal\nhf0 : Ne (tsum f) 0\nhf : Ne (tsum f) Top.top\na : α\n⊢ Iff (Membership.mem (PMF.normalize f hf0 hf).support a) (Ne (f a) 0)","decl":"theorem mem_support_normalize_iff (a : α) : a ∈ (normalize f hf0 hf).support ↔ f a ≠ 0 := by simp\n\n"}
{"name":"PMF.filter_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\np : PMF α\ns : Set α\nh : Exists fun a => And (Membership.mem s a) (Membership.mem p.support a)\na : α\n⊢ Eq ((p.filter s h) a) (HMul.hMul (s.indicator (⇑p) a) (Inv.inv (tsum fun a' => s.indicator (⇑p) a')))","decl":"@[simp]\ntheorem filter_apply (a : α) :\n    (p.filter s h) a = s.indicator p a * (∑' a', (s.indicator p) a')⁻¹ := by\n  rw [filter, normalize_apply]\n\n"}
{"name":"PMF.filter_apply_eq_zero_of_not_mem","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\np : PMF α\ns : Set α\nh : Exists fun a => And (Membership.mem s a) (Membership.mem p.support a)\na : α\nha : Not (Membership.mem s a)\n⊢ Eq ((p.filter s h) a) 0","decl":"theorem filter_apply_eq_zero_of_not_mem {a : α} (ha : a ∉ s) : (p.filter s h) a = 0 := by\n  rw [filter_apply, Set.indicator_apply_eq_zero.mpr fun ha' => absurd ha' ha, zero_mul]\n\n"}
{"name":"PMF.mem_support_filter_iff","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\np : PMF α\ns : Set α\nh : Exists fun a => And (Membership.mem s a) (Membership.mem p.support a)\na : α\n⊢ Iff (Membership.mem (p.filter s h).support a) (And (Membership.mem s a) (Membership.mem p.support a))","decl":"theorem mem_support_filter_iff {a : α} : a ∈ (p.filter s h).support ↔ a ∈ s ∧ a ∈ p.support :=\n  (mem_support_normalize_iff _ _ _).trans Set.indicator_apply_ne_zero\n\n"}
{"name":"PMF.support_filter","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\np : PMF α\ns : Set α\nh : Exists fun a => And (Membership.mem s a) (Membership.mem p.support a)\n⊢ Eq (p.filter s h).support (Inter.inter s p.support)","decl":"@[simp]\ntheorem support_filter : (p.filter s h).support = s ∩ p.support :=\n  Set.ext fun _ => mem_support_filter_iff _\n\n"}
{"name":"PMF.filter_apply_eq_zero_iff","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\np : PMF α\ns : Set α\nh : Exists fun a => And (Membership.mem s a) (Membership.mem p.support a)\na : α\n⊢ Iff (Eq ((p.filter s h) a) 0) (Or (Not (Membership.mem s a)) (Not (Membership.mem p.support a)))","decl":"theorem filter_apply_eq_zero_iff (a : α) : (p.filter s h) a = 0 ↔ a ∉ s ∨ a ∉ p.support := by\n  rw [apply_eq_zero_iff, support_filter, Set.mem_inter_iff, not_and_or]\n\n"}
{"name":"PMF.filter_apply_ne_zero_iff","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"α : Type u_1\np : PMF α\ns : Set α\nh : Exists fun a => And (Membership.mem s a) (Membership.mem p.support a)\na : α\n⊢ Iff (Ne ((p.filter s h) a) 0) (And (Membership.mem s a) (Membership.mem p.support a))","decl":"theorem filter_apply_ne_zero_iff (a : α) : (p.filter s h) a ≠ 0 ↔ a ∈ s ∧ a ∈ p.support := by\n  rw [Ne, filter_apply_eq_zero_iff, not_or, Classical.not_not, Classical.not_not]\n\n"}
{"name":"PMF.bernoulli_apply","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"p : ENNReal\nh : LE.le p 1\nb : Bool\n⊢ Eq ((PMF.bernoulli p h) b) (cond b p (HSub.hSub 1 p))","decl":"@[simp]\ntheorem bernoulli_apply : bernoulli p h b = cond b p (1 - p) := rfl\n\n"}
{"name":"PMF.support_bernoulli","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"p : ENNReal\nh : LE.le p 1\n⊢ Eq (PMF.bernoulli p h).support (setOf fun b => cond b (Ne p 0) (Ne p 1))","decl":"@[simp]\ntheorem support_bernoulli : (bernoulli p h).support = { b | cond b (p ≠ 0) (p ≠ 1) } := by\n  refine Set.ext fun b => ?_\n  induction b\n  · simp_rw [mem_support_iff, bernoulli_apply, Bool.cond_false, Ne, tsub_eq_zero_iff_le, not_le]\n    exact ⟨ne_of_lt, lt_of_le_of_ne h⟩\n  · simp only [mem_support_iff, bernoulli_apply, Bool.cond_true, Set.mem_setOf_eq]\n\n"}
{"name":"PMF.mem_support_bernoulli_iff","module":"Mathlib.Probability.ProbabilityMassFunction.Constructions","initialProofState":"p : ENNReal\nh : LE.le p 1\nb : Bool\n⊢ Iff (Membership.mem (PMF.bernoulli p h).support b) (cond b (Ne p 0) (Ne p 1))","decl":"theorem mem_support_bernoulli_iff : b ∈ (bernoulli p h).support ↔ cond b (p ≠ 0) (p ≠ 1) := by simp\n\n"}
