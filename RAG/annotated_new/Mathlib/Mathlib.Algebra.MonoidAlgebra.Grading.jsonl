{"name":"AddMonoidAlgebra.gradeBy_id","module":"Mathlib.Algebra.MonoidAlgebra.Grading","initialProofState":"M : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\n⊢ Eq (AddMonoidAlgebra.gradeBy R id) (AddMonoidAlgebra.grade R)","decl":"theorem gradeBy_id : gradeBy R (id : M → M) = grade R := rfl\n\n"}
{"name":"AddMonoidAlgebra.mem_gradeBy_iff","module":"Mathlib.Algebra.MonoidAlgebra.Grading","initialProofState":"M : Type u_1\nι : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\nf : M → ι\ni : ι\na : AddMonoidAlgebra R M\n⊢ Iff (Membership.mem (AddMonoidAlgebra.gradeBy R f i) a) (HasSubset.Subset (↑a.support) (Set.preimage f (Singleton.singleton i)))","decl":"theorem mem_gradeBy_iff (f : M → ι) (i : ι) (a : R[M]) :\n    a ∈ gradeBy R f i ↔ (a.support : Set M) ⊆ f ⁻¹' {i} := by rfl\n\n"}
{"name":"AddMonoidAlgebra.mem_grade_iff","module":"Mathlib.Algebra.MonoidAlgebra.Grading","initialProofState":"M : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nm : M\na : AddMonoidAlgebra R M\n⊢ Iff (Membership.mem (AddMonoidAlgebra.grade R m) a) (HasSubset.Subset a.support (Singleton.singleton m))","decl":"theorem mem_grade_iff (m : M) (a : R[M]) : a ∈ grade R m ↔ a.support ⊆ {m} := by\n  rw [← Finset.coe_subset, Finset.coe_singleton]\n  rfl\n\n"}
{"name":"AddMonoidAlgebra.mem_grade_iff'","module":"Mathlib.Algebra.MonoidAlgebra.Grading","initialProofState":"M : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nm : M\na : AddMonoidAlgebra R M\n⊢ Iff (Membership.mem (AddMonoidAlgebra.grade R m) a) (Membership.mem (LinearMap.range (Finsupp.lsingle m)) a)","decl":"theorem mem_grade_iff' (m : M) (a : R[M]) :\n    a ∈ grade R m ↔ a ∈ (LinearMap.range (Finsupp.lsingle m : R →ₗ[R] M →₀ R) :\n      Submodule R R[M]) := by\n  rw [mem_grade_iff, Finsupp.support_subset_singleton']\n  apply exists_congr\n  intro r\n  constructor <;> exact Eq.symm\n\n"}
{"name":"AddMonoidAlgebra.grade_eq_lsingle_range","module":"Mathlib.Algebra.MonoidAlgebra.Grading","initialProofState":"M : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nm : M\n⊢ Eq (AddMonoidAlgebra.grade R m) (LinearMap.range (Finsupp.lsingle m))","decl":"theorem grade_eq_lsingle_range (m : M) :\n    grade R m = LinearMap.range (Finsupp.lsingle m : R →ₗ[R] M →₀ R) :=\n  Submodule.ext (mem_grade_iff' R m)\n\n"}
{"name":"AddMonoidAlgebra.single_mem_gradeBy","module":"Mathlib.Algebra.MonoidAlgebra.Grading","initialProofState":"M : Type u_1\nι : Type u_2\nR : Type u_4\ninst✝ : CommSemiring R\nf : M → ι\nm : M\nr : R\n⊢ Membership.mem (AddMonoidAlgebra.gradeBy R f (f m)) (Finsupp.single m r)","decl":"theorem single_mem_gradeBy {R} [CommSemiring R] (f : M → ι) (m : M) (r : R) :\n    Finsupp.single m r ∈ gradeBy R f (f m) := by\n  intro x hx\n  rw [Finset.mem_singleton.mp (Finsupp.support_single_subset hx)]\n\n"}
{"name":"AddMonoidAlgebra.single_mem_grade","module":"Mathlib.Algebra.MonoidAlgebra.Grading","initialProofState":"M : Type u_1\nR : Type u_4\ninst✝ : CommSemiring R\ni : M\nr : R\n⊢ Membership.mem (AddMonoidAlgebra.grade R i) (Finsupp.single i r)","decl":"theorem single_mem_grade {R} [CommSemiring R] (i : M) (r : R) : Finsupp.single i r ∈ grade R i :=\n  single_mem_gradeBy _ _ _\n\n"}
{"name":"AddMonoidAlgebra.gradeBy.gradedMonoid","module":"Mathlib.Algebra.MonoidAlgebra.Grading","initialProofState":"M : Type u_1\nι : Type u_2\nR : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : AddMonoid ι\ninst✝ : CommSemiring R\nf : AddMonoidHom M ι\n⊢ SetLike.GradedMonoid (AddMonoidAlgebra.gradeBy R ⇑f)","decl":"instance gradeBy.gradedMonoid [AddMonoid M] [AddMonoid ι] [CommSemiring R] (f : M →+ ι) :\n    SetLike.GradedMonoid (gradeBy R f : ι → Submodule R R[M]) where\n  one_mem m h := by\n    rw [one_def] at h\n    obtain rfl : m = 0 := Finset.mem_singleton.1 <| Finsupp.support_single_subset h\n    apply map_zero\n  mul_mem i j a b ha hb c hc := by\n    classical\n    obtain ⟨ma, hma, mb, hmb, rfl⟩ : ∃ y ∈ a.support, ∃ z ∈ b.support, y + z = c :=\n      Finset.mem_add.1 <| support_mul a b hc\n    rw [map_add, ha ma hma, hb mb hmb]\n\n"}
{"name":"AddMonoidAlgebra.grade.gradedMonoid","module":"Mathlib.Algebra.MonoidAlgebra.Grading","initialProofState":"M : Type u_1\nR : Type u_3\ninst✝¹ : AddMonoid M\ninst✝ : CommSemiring R\n⊢ SetLike.GradedMonoid (AddMonoidAlgebra.grade R)","decl":"instance grade.gradedMonoid [AddMonoid M] [CommSemiring R] :\n    SetLike.GradedMonoid (grade R : M → Submodule R R[M]) := by\n  apply gradeBy.gradedMonoid (AddMonoidHom.id _)\n\n"}
{"name":"AddMonoidAlgebra.decomposeAux_single","module":"Mathlib.Algebra.MonoidAlgebra.Grading","initialProofState":"M : Type u_1\nι : Type u_2\nR : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : DecidableEq ι\ninst✝¹ : AddMonoid ι\ninst✝ : CommSemiring R\nf : AddMonoidHom M ι\nm : M\nr : R\n⊢ Eq ((AddMonoidAlgebra.decomposeAux f) (Finsupp.single m r)) ((DirectSum.of (fun i => Subtype fun x => Membership.mem (AddMonoidAlgebra.gradeBy R (⇑f) i) x) (f m)) ⟨Finsupp.single m r, ⋯⟩)","decl":"theorem decomposeAux_single (m : M) (r : R) :\n    decomposeAux f (Finsupp.single m r) =\n      DirectSum.of (fun i : ι => gradeBy R f i) (f m)\n        ⟨Finsupp.single m r, single_mem_gradeBy _ _ _⟩ := by\n  refine (lift_single _ _ _).trans ?_\n  refine (DirectSum.of_smul R _ _ _).symm.trans ?_\n  apply DirectSum.of_eq_of_gradedMonoid_eq\n  refine Sigma.subtype_ext rfl ?_\n  refine (smul_single' _ _ _).trans ?_\n  rw [mul_one]\n  rfl\n\n"}
{"name":"AddMonoidAlgebra.decomposeAux_coe","module":"Mathlib.Algebra.MonoidAlgebra.Grading","initialProofState":"M : Type u_1\nι : Type u_2\nR : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : DecidableEq ι\ninst✝¹ : AddMonoid ι\ninst✝ : CommSemiring R\nf : AddMonoidHom M ι\ni : ι\nx : Subtype fun x => Membership.mem (AddMonoidAlgebra.gradeBy R (⇑f) i) x\n⊢ Eq ((AddMonoidAlgebra.decomposeAux f) ↑x) ((DirectSum.of (fun i => Subtype fun x => Membership.mem (AddMonoidAlgebra.gradeBy R (⇑f) i) x) i) x)","decl":"theorem decomposeAux_coe {i : ι} (x : gradeBy R f i) :\n    decomposeAux f ↑x = DirectSum.of (fun i => gradeBy R f i) i x := by\n  classical\n  obtain ⟨x, hx⟩ := x\n  revert hx\n  refine Finsupp.induction x ?_ ?_\n  · intro hx\n    symm\n    exact AddMonoidHom.map_zero _\n  · intro m b y hmy hb ih hmby\n    have : Disjoint (Finsupp.single m b).support y.support := by\n      simpa only [Finsupp.support_single_ne_zero _ hb, Finset.disjoint_singleton_left]\n    rw [mem_gradeBy_iff, Finsupp.support_add_eq this, Finset.coe_union, Set.union_subset_iff]\n      at hmby\n    cases' hmby with h1 h2\n    have : f m = i := by\n      rwa [Finsupp.support_single_ne_zero _ hb, Finset.coe_singleton, Set.singleton_subset_iff]\n        at h1\n    subst this\n    simp only [map_add, Submodule.coe_mk, decomposeAux_single f m]\n    let ih' := ih h2\n    dsimp at ih'\n    rw [ih', ← AddMonoidHom.map_add]\n    apply DirectSum.of_eq_of_gradedMonoid_eq\n    congr 2\n\n"}
{"name":"AddMonoidAlgebra.decomposeAux_eq_decompose","module":"Mathlib.Algebra.MonoidAlgebra.Grading","initialProofState":"M : Type u_1\nι : Type u_2\nR : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : DecidableEq ι\ninst✝¹ : AddMonoid ι\ninst✝ : CommSemiring R\nf : AddMonoidHom M ι\n⊢ Eq ⇑(AddMonoidAlgebra.decomposeAux f) ⇑(DirectSum.decompose (AddMonoidAlgebra.gradeBy R ⇑f))","decl":"@[simp]\ntheorem decomposeAux_eq_decompose :\n    ⇑(decomposeAux f : R[M] →ₐ[R] ⨁ i : ι, gradeBy R f i) =\n      DirectSum.decompose (gradeBy R f) :=\n  rfl\n\n"}
{"name":"AddMonoidAlgebra.GradesBy.decompose_single","module":"Mathlib.Algebra.MonoidAlgebra.Grading","initialProofState":"M : Type u_1\nι : Type u_2\nR : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : DecidableEq ι\ninst✝¹ : AddMonoid ι\ninst✝ : CommSemiring R\nf : AddMonoidHom M ι\nm : M\nr : R\n⊢ Eq ((DirectSum.decompose (AddMonoidAlgebra.gradeBy R ⇑f)) (Finsupp.single m r)) ((DirectSum.of (fun i => Subtype fun x => Membership.mem (AddMonoidAlgebra.gradeBy R (⇑f) i) x) (f m)) ⟨Finsupp.single m r, ⋯⟩)","decl":"theorem GradesBy.decompose_single (m : M) (r : R) :\n    DirectSum.decompose (gradeBy R f) (Finsupp.single m r : R[M]) =\n      DirectSum.of (fun i : ι => gradeBy R f i) (f m)\n        ⟨Finsupp.single m r, single_mem_gradeBy _ _ _⟩ :=\n  decomposeAux_single _ _ _\n\n"}
{"name":"AddMonoidAlgebra.grade.decompose_single","module":"Mathlib.Algebra.MonoidAlgebra.Grading","initialProofState":"ι : Type u_2\nR : Type u_3\ninst✝² : DecidableEq ι\ninst✝¹ : AddMonoid ι\ninst✝ : CommSemiring R\ni : ι\nr : R\n⊢ Eq ((DirectSum.decompose (AddMonoidAlgebra.grade R)) (Finsupp.single i r)) ((DirectSum.of (fun i => Subtype fun x => Membership.mem (AddMonoidAlgebra.grade R i) x) i) ⟨Finsupp.single i r, ⋯⟩)","decl":"theorem grade.decompose_single (i : ι) (r : R) :\n    DirectSum.decompose (grade R : ι → Submodule _ _) (Finsupp.single i r : AddMonoidAlgebra _ _) =\n      DirectSum.of (fun i : ι => grade R i) i ⟨Finsupp.single i r, single_mem_grade _ _⟩ :=\n  decomposeAux_single _ _ _\n\n"}
{"name":"AddMonoidAlgebra.gradeBy.isInternal","module":"Mathlib.Algebra.MonoidAlgebra.Grading","initialProofState":"M : Type u_1\nι : Type u_2\nR : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : DecidableEq ι\ninst✝¹ : AddMonoid ι\ninst✝ : CommSemiring R\nf : AddMonoidHom M ι\n⊢ DirectSum.IsInternal (AddMonoidAlgebra.gradeBy R ⇑f)","decl":"/-- `AddMonoidAlgebra.gradeBy` describe an internally graded algebra. -/\ntheorem gradeBy.isInternal : DirectSum.IsInternal (gradeBy R f) :=\n  DirectSum.Decomposition.isInternal _\n\n"}
{"name":"AddMonoidAlgebra.grade.isInternal","module":"Mathlib.Algebra.MonoidAlgebra.Grading","initialProofState":"ι : Type u_2\nR : Type u_3\ninst✝² : DecidableEq ι\ninst✝¹ : AddMonoid ι\ninst✝ : CommSemiring R\n⊢ DirectSum.IsInternal (AddMonoidAlgebra.grade R)","decl":"/-- `AddMonoidAlgebra.grade` describe an internally graded algebra. -/\ntheorem grade.isInternal : DirectSum.IsInternal (grade R : ι → Submodule R _) :=\n  DirectSum.Decomposition.isInternal _\n\n"}
