{"name":"CategoryTheory.Functor.Additive.map_add","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\nself : F.Additive\nX Y : C\nf g : Quiver.Hom X Y\n⊢ Eq (F.map (HAdd.hAdd f g)) (HAdd.hAdd (F.map f) (F.map g))","decl":"/-- A functor `F` is additive provided `F.map` is an additive homomorphism. -/\nclass Functor.Additive {C D : Type*} [Category C] [Category D] [Preadditive C] [Preadditive D]\n  (F : C ⥤ D) : Prop where\n  /-- the addition of two morphisms is mapped to the sum of their images -/\n  map_add : ∀ {X Y : C} {f g : X ⟶ Y}, F.map (f + g) = F.map f + F.map g := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.map_add","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nX Y : C\nf g : Quiver.Hom X Y\n⊢ Eq (F.map (HAdd.hAdd f g)) (HAdd.hAdd (F.map f) (F.map g))","decl":"@[simp]\ntheorem map_add {X Y : C} {f g : X ⟶ Y} : F.map (f + g) = F.map f + F.map g :=\n  Functor.Additive.map_add\n\n"}
{"name":"CategoryTheory.Functor.mapAddHom_apply","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (F.mapAddHom f) (F.map f)","decl":"/-- `F.mapAddHom` is an additive homomorphism whose underlying function is `F.map`. -/\n@[simps!]\ndef mapAddHom {X Y : C} : (X ⟶ Y) →+ (F.obj X ⟶ F.obj Y) :=\n  AddMonoidHom.mk' (fun f => F.map f) fun _ _ => F.map_add\n\n"}
{"name":"CategoryTheory.Functor.coe_mapAddHom","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nX Y : C\n⊢ Eq (⇑F.mapAddHom) F.map","decl":"theorem coe_mapAddHom {X Y : C} : ⇑(F.mapAddHom : (X ⟶ Y) →+ _) = F.map :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.preservesZeroMorphisms_of_additive","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ F.PreservesZeroMorphisms","decl":"instance (priority := 100) preservesZeroMorphisms_of_additive : PreservesZeroMorphisms F where\n  map_zero _ _ := F.mapAddHom.map_zero\n\n"}
{"name":"CategoryTheory.Functor.instAdditiveId","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝ : CategoryTheory.Preadditive C\n⊢ (CategoryTheory.Functor.id C).Additive","decl":"instance : Additive (𝟭 C) where\n\n"}
{"name":"CategoryTheory.Functor.instAdditiveComp","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_7, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_6, u_2} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\nE : Type u_4\ninst✝² : CategoryTheory.Category.{u_5, u_4} E\ninst✝¹ : CategoryTheory.Preadditive E\nG : CategoryTheory.Functor D E\ninst✝ : G.Additive\n⊢ (F.comp G).Additive","decl":"instance {E : Type*} [Category E] [Preadditive E] (G : D ⥤ E) [Functor.Additive G] :\n    Additive (F ⋙ G) where\n\n"}
{"name":"CategoryTheory.Functor.instAdditiveObjEvaluation","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_6, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\nJ : Type u_4\ninst✝ : CategoryTheory.Category.{u_5, u_4} J\nj : J\n⊢ ((CategoryTheory.evaluation J C).obj j).Additive","decl":"instance {J : Type*} [Category J] (j : J) : ((evaluation J C).obj j).Additive where\n\n"}
{"name":"CategoryTheory.Functor.map_neg","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (F.map (Neg.neg f)) (Neg.neg (F.map f))","decl":"@[simp]\ntheorem map_neg {X Y : C} {f : X ⟶ Y} : F.map (-f) = -F.map f :=\n  (F.mapAddHom : (X ⟶ Y) →+ (F.obj X ⟶ F.obj Y)).map_neg _\n\n"}
{"name":"CategoryTheory.Functor.map_sub","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nX Y : C\nf g : Quiver.Hom X Y\n⊢ Eq (F.map (HSub.hSub f g)) (HSub.hSub (F.map f) (F.map g))","decl":"@[simp]\ntheorem map_sub {X Y : C} {f g : X ⟶ Y} : F.map (f - g) = F.map f - F.map g :=\n  (F.mapAddHom : (X ⟶ Y) →+ (F.obj X ⟶ F.obj Y)).map_sub _ _\n\n"}
{"name":"CategoryTheory.Functor.map_nsmul","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nX Y : C\nf : Quiver.Hom X Y\nn : Nat\n⊢ Eq (F.map (HSMul.hSMul n f)) (HSMul.hSMul n (F.map f))","decl":"theorem map_nsmul {X Y : C} {f : X ⟶ Y} {n : ℕ} : F.map (n • f) = n • F.map f :=\n  (F.mapAddHom : (X ⟶ Y) →+ (F.obj X ⟶ F.obj Y)).map_nsmul _ _\n\n-- You can alternatively just use `Functor.map_smul` here, with an explicit `(r : ℤ)` argument.\n"}
{"name":"CategoryTheory.Functor.map_zsmul","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nX Y : C\nf : Quiver.Hom X Y\nr : Int\n⊢ Eq (F.map (HSMul.hSMul r f)) (HSMul.hSMul r (F.map f))","decl":"theorem map_zsmul {X Y : C} {f : X ⟶ Y} {r : ℤ} : F.map (r • f) = r • F.map f :=\n  (F.mapAddHom : (X ⟶ Y) →+ (F.obj X ⟶ F.obj Y)).map_zsmul _ _\n\n"}
{"name":"CategoryTheory.Functor.map_sum","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_5, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_2} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nX Y : C\nα : Type u_4\nf : α → Quiver.Hom X Y\ns : Finset α\n⊢ Eq (F.map (s.sum fun a => f a)) (s.sum fun a => F.map (f a))","decl":"@[simp]\nnonrec theorem map_sum {X Y : C} {α : Type*} (f : α → (X ⟶ Y)) (s : Finset α) :\n    F.map (∑ a ∈ s, f a) = ∑ a ∈ s, F.map (f a) :=\n  map_sum F.mapAddHom f s\n\n"}
{"name":"CategoryTheory.Functor.additive_of_iso","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_5, u_2} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\nG : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F G\n⊢ G.Additive","decl":"lemma additive_of_iso {G : C ⥤ D} (e : F ≅ G) : G.Additive := by\n  constructor\n  intro X Y f g\n  simp only [← NatIso.naturality_1 e (f + g), map_add, Preadditive.add_comp,\n    NatTrans.naturality, Preadditive.comp_add, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"CategoryTheory.Functor.additive_of_full_essSurj_comp","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁸ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁷ : CategoryTheory.Category.{u_6, u_3} E\ninst✝⁶ : CategoryTheory.Preadditive C\ninst✝⁵ : CategoryTheory.Preadditive D\ninst✝⁴ : CategoryTheory.Preadditive E\nF : CategoryTheory.Functor C D\ninst✝³ : F.Additive\ninst✝² : F.Full\ninst✝¹ : F.EssSurj\nG : CategoryTheory.Functor D E\ninst✝ : (F.comp G).Additive\n⊢ G.Additive","decl":"lemma additive_of_full_essSurj_comp [Full F] [EssSurj F] (G : D ⥤ E)\n    [(F ⋙ G).Additive] : G.Additive where\n  map_add {X Y f g} := by\n    obtain ⟨f', hf'⟩ := F.map_surjective ((F.objObjPreimageIso X).hom ≫ f ≫\n      (F.objObjPreimageIso Y).inv)\n    obtain ⟨g', hg'⟩ := F.map_surjective ((F.objObjPreimageIso X).hom ≫ g ≫\n      (F.objObjPreimageIso Y).inv)\n    simp only [← cancel_mono (G.map (F.objObjPreimageIso Y).inv),\n      ← cancel_epi (G.map (F.objObjPreimageIso X).hom),\n      Preadditive.add_comp, Preadditive.comp_add, ← Functor.map_comp]\n    erw [← hf', ← hg', ← (F ⋙ G).map_add]\n    dsimp\n    rw [F.map_add]\n\n"}
{"name":"CategoryTheory.Functor.additive_of_comp_faithful","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝⁸ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_5, u_2} D\ninst✝⁶ : CategoryTheory.Category.{u_6, u_3} E\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : CategoryTheory.Preadditive D\ninst✝³ : CategoryTheory.Preadditive E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst✝² : G.Additive\ninst✝¹ : (F.comp G).Additive\ninst✝ : G.Faithful\n⊢ F.Additive","decl":"lemma additive_of_comp_faithful\n    (F : C ⥤ D) (G : D ⥤ E) [G.Additive] [(F ⋙ G).Additive] [Faithful G] :\n    F.Additive where\n  map_add {_ _ f₁ f₂} := G.map_injective (by\n    rw [← Functor.comp_map, G.map_add, (F ⋙ G).map_add, Functor.comp_map, Functor.comp_map])\n\n"}
{"name":"CategoryTheory.Functor.hasZeroObject_of_additive","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} D\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Additive\ninst✝ : CategoryTheory.Limits.HasZeroObject C\n⊢ CategoryTheory.Limits.HasZeroObject D","decl":"open ZeroObject Limits in\ninclude F in\nlemma hasZeroObject_of_additive [HasZeroObject C] :\n    HasZeroObject D where\n  zero := ⟨F.obj 0, by rw [IsZero.iff_id_eq_zero, ← F.map_id, id_zero, F.map_zero]⟩\n\n"}
{"name":"CategoryTheory.Functor.inducedFunctor_additive","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} D\ninst✝ : CategoryTheory.Preadditive D\nF : C → D\n⊢ (CategoryTheory.inducedFunctor F).Additive","decl":"instance inducedFunctor_additive : Functor.Additive (inducedFunctor F) where\n\n"}
{"name":"CategoryTheory.Functor.fullSubcategoryInclusion_additive","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nZ : C → Prop\n⊢ (CategoryTheory.fullSubcategoryInclusion Z).Additive","decl":"instance fullSubcategoryInclusion_additive {C : Type*} [Category C] [Preadditive C]\n    (Z : C → Prop) : (fullSubcategoryInclusion Z).Additive where\n\n"}
{"name":"CategoryTheory.Functor.preservesFiniteBiproductsOfAdditive","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ CategoryTheory.Limits.PreservesFiniteBiproducts F","decl":"instance (priority := 100) preservesFiniteBiproductsOfAdditive [Additive F] :\n    PreservesFiniteBiproducts F where\n  preserves :=\n    { preserves :=\n      { preserves := fun hb =>\n          ⟨isBilimitOfTotal _ (by\n            simp_rw [F.mapBicone_π, F.mapBicone_ι, ← F.map_comp]\n            erw [← F.map_sum, ← F.map_id, IsBilimit.total hb])⟩ } }\n\n"}
{"name":"CategoryTheory.Functor.additive_of_preservesBinaryBiproducts","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.Limits.HasBinaryBiproducts C\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : CategoryTheory.Limits.PreservesBinaryBiproducts F\n⊢ F.Additive","decl":"theorem additive_of_preservesBinaryBiproducts [HasBinaryBiproducts C] [PreservesZeroMorphisms F]\n    [PreservesBinaryBiproducts F] : Additive F where\n  map_add {X Y f g} := by\n    rw [biprod.add_eq_lift_id_desc, F.map_comp, ← biprod.lift_mapBiprod,\n      ← biprod.mapBiprod_hom_desc, Category.assoc, Iso.inv_hom_id_assoc, F.map_id,\n      biprod.add_eq_lift_id_desc]\n\n"}
{"name":"CategoryTheory.Functor.additive_of_preserves_binary_products","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.Limits.HasBinaryProducts C\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\ninst✝ : F.PreservesZeroMorphisms\n⊢ F.Additive","decl":"lemma additive_of_preserves_binary_products\n    [HasBinaryProducts C] [PreservesLimitsOfShape (Discrete WalkingPair) F]\n    [F.PreservesZeroMorphisms] : F.Additive := by\n  have : HasBinaryBiproducts C := HasBinaryBiproducts.of_hasBinaryProducts\n  have := preservesBinaryBiproducts_of_preservesBinaryProducts F\n  exact Functor.additive_of_preservesBinaryBiproducts F\n\n"}
{"name":"CategoryTheory.Equivalence.inverse_additive","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\ne : CategoryTheory.Equivalence C D\ninst✝ : e.functor.Additive\n⊢ e.inverse.Additive","decl":"instance inverse_additive (e : C ≌ D) [e.functor.Additive] : e.inverse.Additive where\n  map_add {f g} := e.functor.map_injective (by simp)\n\n"}
{"name":"CategoryTheory.instFullAdditiveFunctorFunctorForget","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝² : CategoryTheory.Category.{u_3, u_2} D\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Preadditive D\n⊢ (CategoryTheory.AdditiveFunctor.forget C D).Full","decl":"instance : (AdditiveFunctor.forget C D).Full :=\n  FullSubcategory.full _\n\n"}
{"name":"CategoryTheory.AdditiveFunctor.of_fst","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ Eq (CategoryTheory.AdditiveFunctor.of F).obj F","decl":"@[simp]\ntheorem AdditiveFunctor.of_fst (F : C ⥤ D) [F.Additive] : (AdditiveFunctor.of F).1 = F :=\n  rfl\n\n"}
{"name":"CategoryTheory.AdditiveFunctor.forget_obj","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Preadditive D\nF : CategoryTheory.AdditiveFunctor C D\n⊢ Eq ((CategoryTheory.AdditiveFunctor.forget C D).obj F) F.obj","decl":"@[simp]\ntheorem AdditiveFunctor.forget_obj (F : C ⥤+ D) : (AdditiveFunctor.forget C D).obj F = F.1 :=\n  rfl\n\n"}
{"name":"CategoryTheory.AdditiveFunctor.forget_obj_of","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ Eq ((CategoryTheory.AdditiveFunctor.forget C D).obj (CategoryTheory.AdditiveFunctor.of F)) F","decl":"theorem AdditiveFunctor.forget_obj_of (F : C ⥤ D) [F.Additive] :\n    (AdditiveFunctor.forget C D).obj (AdditiveFunctor.of F) = F :=\n  rfl\n\n"}
{"name":"CategoryTheory.AdditiveFunctor.forget_map","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Preadditive D\nF G : CategoryTheory.AdditiveFunctor C D\nα : Quiver.Hom F G\n⊢ Eq ((CategoryTheory.AdditiveFunctor.forget C D).map α) α","decl":"@[simp]\ntheorem AdditiveFunctor.forget_map (F G : C ⥤+ D) (α : F ⟶ G) :\n    (AdditiveFunctor.forget C D).map α = α :=\n  rfl\n\n"}
{"name":"CategoryTheory.instAdditiveAdditiveFunctorFunctorForget","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Preadditive D\n⊢ (CategoryTheory.AdditiveFunctor.forget C D).Additive","decl":"instance : Functor.Additive (AdditiveFunctor.forget C D) where map_add := rfl\n\n"}
{"name":"CategoryTheory.instAdditiveObjFunctor","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Preadditive D\nF : CategoryTheory.AdditiveFunctor C D\n⊢ F.obj.Additive","decl":"instance (F : C ⥤+ D) : Functor.Additive F.1 :=\n  F.2\n\n"}
{"name":"CategoryTheory.instFullLeftExactFunctorAdditiveFunctorOfLeftExact","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Preadditive D\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject D\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\n⊢ (CategoryTheory.AdditiveFunctor.ofLeftExact C D).Full","decl":"instance : (AdditiveFunctor.ofLeftExact C D).Full := FullSubcategory.full_map _\n"}
{"name":"CategoryTheory.instFaithfulLeftExactFunctorAdditiveFunctorOfLeftExact","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Preadditive D\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject D\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\n⊢ (CategoryTheory.AdditiveFunctor.ofLeftExact C D).Faithful","decl":"instance : (AdditiveFunctor.ofLeftExact C D).Faithful := FullSubcategory.faithful_map _\n\n"}
{"name":"CategoryTheory.instFullRightExactFunctorAdditiveFunctorOfRightExact","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Preadditive D\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject D\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\n⊢ (CategoryTheory.AdditiveFunctor.ofRightExact C D).Full","decl":"instance : (AdditiveFunctor.ofRightExact C D).Full := FullSubcategory.full_map _\n"}
{"name":"CategoryTheory.instFaithfulRightExactFunctorAdditiveFunctorOfRightExact","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Preadditive D\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject D\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\n⊢ (CategoryTheory.AdditiveFunctor.ofRightExact C D).Faithful","decl":"instance : (AdditiveFunctor.ofRightExact C D).Faithful := FullSubcategory.faithful_map _\n\n"}
{"name":"CategoryTheory.instFullExactFunctorAdditiveFunctorOfExact","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Preadditive D\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject D\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\n⊢ (CategoryTheory.AdditiveFunctor.ofExact C D).Full","decl":"instance : (AdditiveFunctor.ofExact C D).Full := FullSubcategory.full_map _\n"}
{"name":"CategoryTheory.instFaithfulExactFunctorAdditiveFunctorOfExact","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Preadditive D\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject D\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\n⊢ (CategoryTheory.AdditiveFunctor.ofExact C D).Faithful","decl":"instance : (AdditiveFunctor.ofExact C D).Faithful := FullSubcategory.faithful_map _\n\n"}
{"name":"CategoryTheory.AdditiveFunctor.ofLeftExact_obj_fst","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Preadditive D\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject D\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nF : CategoryTheory.LeftExactFunctor C D\n⊢ Eq ((CategoryTheory.AdditiveFunctor.ofLeftExact C D).obj F).obj F.obj","decl":"@[simp]\ntheorem AdditiveFunctor.ofLeftExact_obj_fst (F : C ⥤ₗ D) :\n    ((AdditiveFunctor.ofLeftExact C D).obj F).obj = F.obj :=\n  rfl\n\n"}
{"name":"CategoryTheory.AdditiveFunctor.ofRightExact_obj_fst","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Preadditive D\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject D\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nF : CategoryTheory.RightExactFunctor C D\n⊢ Eq ((CategoryTheory.AdditiveFunctor.ofRightExact C D).obj F).obj F.obj","decl":"@[simp]\ntheorem AdditiveFunctor.ofRightExact_obj_fst (F : C ⥤ᵣ D) :\n    ((AdditiveFunctor.ofRightExact C D).obj F).obj = F.obj :=\n  rfl\n\n"}
{"name":"CategoryTheory.AdditiveFunctor.ofExact_obj_fst","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Preadditive D\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject D\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nF : CategoryTheory.ExactFunctor C D\n⊢ Eq ((CategoryTheory.AdditiveFunctor.ofExact C D).obj F).obj F.obj","decl":"@[simp]\ntheorem AdditiveFunctor.ofExact_obj_fst (F : C ⥤ₑ D) :\n    ((AdditiveFunctor.ofExact C D).obj F).obj = F.obj :=\n  rfl\n\n"}
{"name":"CategoryTheory.AdditiveFunctor.ofLeftExact_map","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Preadditive D\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject D\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nF G : CategoryTheory.LeftExactFunctor C D\nα : Quiver.Hom F G\n⊢ Eq ((CategoryTheory.AdditiveFunctor.ofLeftExact C D).map α) α","decl":"@[simp]\ntheorem AdditiveFunctor.ofLeftExact_map {F G : C ⥤ₗ D} (α : F ⟶ G) :\n    (AdditiveFunctor.ofLeftExact C D).map α = α :=\n  rfl\n\n"}
{"name":"CategoryTheory.AdditiveFunctor.ofRightExact_map","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Preadditive D\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject D\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nF G : CategoryTheory.RightExactFunctor C D\nα : Quiver.Hom F G\n⊢ Eq ((CategoryTheory.AdditiveFunctor.ofRightExact C D).map α) α","decl":"@[simp]\ntheorem AdditiveFunctor.ofRightExact_map {F G : C ⥤ᵣ D} (α : F ⟶ G) :\n    (AdditiveFunctor.ofRightExact C D).map α = α :=\n  rfl\n\n"}
{"name":"CategoryTheory.AdditiveFunctor.ofExact_map","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Preadditive D\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject D\ninst✝ : CategoryTheory.Limits.HasBinaryBiproducts C\nF G : CategoryTheory.ExactFunctor C D\nα : Quiver.Hom F G\n⊢ Eq ((CategoryTheory.AdditiveFunctor.ofExact C D).map α) α","decl":"@[simp]\ntheorem AdditiveFunctor.ofExact_map {F G : C ⥤ₑ D} (α : F ⟶ G) :\n    (AdditiveFunctor.ofExact C D).map α = α :=\n  rfl\n\n"}
