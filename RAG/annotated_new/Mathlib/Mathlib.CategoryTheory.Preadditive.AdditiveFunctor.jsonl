{"name":"CategoryTheory.Functor.Additive.map_add","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\nself : F.Additive\nX Y : C\nf g : Quiver.Hom X Y\n‚ä¢ Eq (F.map (HAdd.hAdd f g)) (HAdd.hAdd (F.map f) (F.map g))","decl":"/-- A functor `F` is additive provided `F.map` is an additive homomorphism. -/\nclass Functor.Additive {C D : Type*} [Category C] [Category D] [Preadditive C] [Preadditive D]\n  (F : C ‚•§ D) : Prop where\n  /-- the addition of two morphisms is mapped to the sum of their images -/\n  map_add : ‚àÄ {X Y : C} {f g : X ‚ü∂ Y}, F.map (f + g) = F.map f + F.map g := by aesop_cat\n\n"}
{"name":"CategoryTheory.Functor.map_add","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nX Y : C\nf g : Quiver.Hom X Y\n‚ä¢ Eq (F.map (HAdd.hAdd f g)) (HAdd.hAdd (F.map f) (F.map g))","decl":"@[simp]\ntheorem map_add {X Y : C} {f g : X ‚ü∂ Y} : F.map (f + g) = F.map f + F.map g :=\n  Functor.Additive.map_add\n\n"}
{"name":"CategoryTheory.Functor.mapAddHom_apply","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (F.mapAddHom f) (F.map f)","decl":"/-- `F.mapAddHom` is an additive homomorphism whose underlying function is `F.map`. -/\n@[simps!]\ndef mapAddHom {X Y : C} : (X ‚ü∂ Y) ‚Üí+ (F.obj X ‚ü∂ F.obj Y) :=\n  AddMonoidHom.mk' (fun f => F.map f) fun _ _ => F.map_add\n\n"}
{"name":"CategoryTheory.Functor.coe_mapAddHom","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nX Y : C\n‚ä¢ Eq (‚áëF.mapAddHom) F.map","decl":"theorem coe_mapAddHom {X Y : C} : ‚áë(F.mapAddHom : (X ‚ü∂ Y) ‚Üí+ _) = F.map :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.preservesZeroMorphisms_of_additive","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ F.PreservesZeroMorphisms","decl":"instance (priority := 100) preservesZeroMorphisms_of_additive : PreservesZeroMorphisms F where\n  map_zero _ _ := F.mapAddHom.map_zero\n\n"}
{"name":"CategoryTheory.Functor.instAdditiveId","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù : CategoryTheory.Preadditive C\n‚ä¢ (CategoryTheory.Functor.id C).Additive","decl":"instance : Additive (ùü≠ C) where\n\n"}
{"name":"CategoryTheory.Functor.instAdditiveComp","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_7, u_1} C\ninst‚úù‚Åµ : CategoryTheory.Category.{u_6, u_2} D\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\nE : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_4} E\ninst‚úù¬π : CategoryTheory.Preadditive E\nG : CategoryTheory.Functor D E\ninst‚úù : G.Additive\n‚ä¢ (F.comp G).Additive","decl":"instance {E : Type*} [Category E] [Preadditive E] (G : D ‚•§ E) [Functor.Additive G] :\n    Additive (F ‚ãô G) where\n\n"}
{"name":"CategoryTheory.Functor.instAdditiveObjEvaluation","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_1} C\ninst‚úù¬π : CategoryTheory.Preadditive C\nJ : Type u_4\ninst‚úù : CategoryTheory.Category.{u_5, u_4} J\nj : J\n‚ä¢ ((CategoryTheory.evaluation J C).obj j).Additive","decl":"instance {J : Type*} [Category J] (j : J) : ((evaluation J C).obj j).Additive where\n\n"}
{"name":"CategoryTheory.Functor.map_neg","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (F.map (Neg.neg f)) (Neg.neg (F.map f))","decl":"@[simp]\ntheorem map_neg {X Y : C} {f : X ‚ü∂ Y} : F.map (-f) = -F.map f :=\n  (F.mapAddHom : (X ‚ü∂ Y) ‚Üí+ (F.obj X ‚ü∂ F.obj Y)).map_neg _\n\n"}
{"name":"CategoryTheory.Functor.map_sub","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nX Y : C\nf g : Quiver.Hom X Y\n‚ä¢ Eq (F.map (HSub.hSub f g)) (HSub.hSub (F.map f) (F.map g))","decl":"@[simp]\ntheorem map_sub {X Y : C} {f g : X ‚ü∂ Y} : F.map (f - g) = F.map f - F.map g :=\n  (F.mapAddHom : (X ‚ü∂ Y) ‚Üí+ (F.obj X ‚ü∂ F.obj Y)).map_sub _ _\n\n"}
{"name":"CategoryTheory.Functor.map_nsmul","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nX Y : C\nf : Quiver.Hom X Y\nn : Nat\n‚ä¢ Eq (F.map (HSMul.hSMul n f)) (HSMul.hSMul n (F.map f))","decl":"theorem map_nsmul {X Y : C} {f : X ‚ü∂ Y} {n : ‚Ñï} : F.map (n ‚Ä¢ f) = n ‚Ä¢ F.map f :=\n  (F.mapAddHom : (X ‚ü∂ Y) ‚Üí+ (F.obj X ‚ü∂ F.obj Y)).map_nsmul _ _\n\n-- You can alternatively just use `Functor.map_smul` here, with an explicit `(r : ‚Ñ§)` argument.\n"}
{"name":"CategoryTheory.Functor.map_zsmul","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nX Y : C\nf : Quiver.Hom X Y\nr : Int\n‚ä¢ Eq (F.map (HSMul.hSMul r f)) (HSMul.hSMul r (F.map f))","decl":"theorem map_zsmul {X Y : C} {f : X ‚ü∂ Y} {r : ‚Ñ§} : F.map (r ‚Ä¢ f) = r ‚Ä¢ F.map f :=\n  (F.mapAddHom : (X ‚ü∂ Y) ‚Üí+ (F.obj X ‚ü∂ F.obj Y)).map_zsmul _ _\n\n"}
{"name":"CategoryTheory.Functor.map_sum","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_6, u_2} D\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nX Y : C\nŒ± : Type u_4\nf : Œ± ‚Üí Quiver.Hom X Y\ns : Finset Œ±\n‚ä¢ Eq (F.map (s.sum fun a => f a)) (s.sum fun a => F.map (f a))","decl":"@[simp]\nnonrec theorem map_sum {X Y : C} {Œ± : Type*} (f : Œ± ‚Üí (X ‚ü∂ Y)) (s : Finset Œ±) :\n    F.map (‚àë a ‚àà s, f a) = ‚àë a ‚àà s, F.map (f a) :=\n  map_sum F.mapAddHom f s\n\n"}
{"name":"CategoryTheory.Functor.additive_of_iso","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\nG : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F G\n‚ä¢ G.Additive","decl":"lemma additive_of_iso {G : C ‚•§ D} (e : F ‚âÖ G) : G.Additive := by\n  constructor\n  intro X Y f g\n  simp only [‚Üê NatIso.naturality_1 e (f + g), map_add, Preadditive.add_comp,\n    NatTrans.naturality, Preadditive.comp_add, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"CategoryTheory.Functor.additive_of_full_essSurj_comp","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst‚úù‚Åπ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å∏ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_6, u_3} E\ninst‚úù‚Å∂ : CategoryTheory.Preadditive C\ninst‚úù‚Åµ : CategoryTheory.Preadditive D\ninst‚úù‚Å¥ : CategoryTheory.Preadditive E\nF : CategoryTheory.Functor C D\ninst‚úù¬≥ : F.Additive\ninst‚úù¬≤ : F.Full\ninst‚úù¬π : F.EssSurj\nG : CategoryTheory.Functor D E\ninst‚úù : (F.comp G).Additive\n‚ä¢ G.Additive","decl":"lemma additive_of_full_essSurj_comp [Full F] [EssSurj F] (G : D ‚•§ E)\n    [(F ‚ãô G).Additive] : G.Additive where\n  map_add {X Y f g} := by\n    obtain ‚ü®f', hf'‚ü© := F.map_surjective ((F.objObjPreimageIso X).hom ‚â´ f ‚â´\n      (F.objObjPreimageIso Y).inv)\n    obtain ‚ü®g', hg'‚ü© := F.map_surjective ((F.objObjPreimageIso X).hom ‚â´ g ‚â´\n      (F.objObjPreimageIso Y).inv)\n    simp only [‚Üê cancel_mono (G.map (F.objObjPreimageIso Y).inv),\n      ‚Üê cancel_epi (G.map (F.objObjPreimageIso X).hom),\n      Preadditive.add_comp, Preadditive.comp_add, ‚Üê Functor.map_comp]\n    erw [‚Üê hf', ‚Üê hg', ‚Üê (F ‚ãô G).map_add]\n    dsimp\n    rw [F.map_add]\n\n"}
{"name":"CategoryTheory.Functor.additive_of_comp_faithful","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst‚úù‚Å∏ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_6, u_3} E\ninst‚úù‚Åµ : CategoryTheory.Preadditive C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive D\ninst‚úù¬≥ : CategoryTheory.Preadditive E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬≤ : G.Additive\ninst‚úù¬π : (F.comp G).Additive\ninst‚úù : G.Faithful\n‚ä¢ F.Additive","decl":"lemma additive_of_comp_faithful\n    (F : C ‚•§ D) (G : D ‚•§ E) [G.Additive] [(F ‚ãô G).Additive] [Faithful G] :\n    F.Additive where\n  map_add {_ _ f‚ÇÅ f‚ÇÇ} := G.map_injective (by\n    rw [‚Üê Functor.comp_map, G.map_add, (F ‚ãô G).map_add, Functor.comp_map, Functor.comp_map])\n\n"}
{"name":"CategoryTheory.Functor.hasZeroObject_of_additive","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Åµ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_2} D\ninst‚úù¬≥ : CategoryTheory.Preadditive C\ninst‚úù¬≤ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Additive\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\n‚ä¢ CategoryTheory.Limits.HasZeroObject D","decl":"open ZeroObject Limits in\ninclude F in\nlemma hasZeroObject_of_additive [HasZeroObject C] :\n    HasZeroObject D where\n  zero := ‚ü®F.obj 0, by rw [IsZero.iff_id_eq_zero, ‚Üê F.map_id, id_zero, F.map_zero]‚ü©\n\n"}
{"name":"CategoryTheory.Functor.inducedFunctor_additive","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_2} D\ninst‚úù : CategoryTheory.Preadditive D\nF : C ‚Üí D\n‚ä¢ (CategoryTheory.inducedFunctor F).Additive","decl":"instance inducedFunctor_additive : Functor.Additive (inducedFunctor F) where\n\n"}
{"name":"CategoryTheory.Functor.fullSubcategoryInclusion_additive","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Preadditive C\nZ : C ‚Üí Prop\n‚ä¢ (CategoryTheory.fullSubcategoryInclusion Z).Additive","decl":"instance fullSubcategoryInclusion_additive {C : Type*} [Category C] [Preadditive C]\n    (Z : C ‚Üí Prop) : (fullSubcategoryInclusion Z).Additive where\n\n"}
{"name":"CategoryTheory.Functor.preservesFiniteBiproductsOfAdditive","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ CategoryTheory.Limits.PreservesFiniteBiproducts F","decl":"instance (priority := 100) preservesFiniteBiproductsOfAdditive [Additive F] :\n    PreservesFiniteBiproducts F where\n  preserves :=\n    { preserves :=\n      { preserves := fun hb =>\n          ‚ü®isBilimitOfTotal _ (by\n            simp_rw [F.mapBicone_œÄ, F.mapBicone_Œπ, ‚Üê F.map_comp]\n            erw [‚Üê F.map_sum, ‚Üê F.map_id, IsBilimit.total hb])‚ü© } }\n\n"}
{"name":"CategoryTheory.Functor.additive_of_preservesBinaryBiproducts","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryBiproducts C\ninst‚úù¬π : F.PreservesZeroMorphisms\ninst‚úù : CategoryTheory.Limits.PreservesBinaryBiproducts F\n‚ä¢ F.Additive","decl":"theorem additive_of_preservesBinaryBiproducts [HasBinaryBiproducts C] [PreservesZeroMorphisms F]\n    [PreservesBinaryBiproducts F] : Additive F where\n  map_add {X Y f g} := by\n    rw [biprod.add_eq_lift_id_desc, F.map_comp, ‚Üê biprod.lift_mapBiprod,\n      ‚Üê biprod.mapBiprod_hom_desc, Category.assoc, Iso.inv_hom_id_assoc, F.map_id,\n      biprod.add_eq_lift_id_desc]\n\n"}
{"name":"CategoryTheory.Functor.additive_of_preserves_binary_products","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryProducts C\ninst‚úù¬π : CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F\ninst‚úù : F.PreservesZeroMorphisms\n‚ä¢ F.Additive","decl":"lemma additive_of_preserves_binary_products\n    [HasBinaryProducts C] [PreservesLimitsOfShape (Discrete WalkingPair) F]\n    [F.PreservesZeroMorphisms] : F.Additive := by\n  have : HasBinaryBiproducts C := HasBinaryBiproducts.of_hasBinaryProducts\n  have := preservesBinaryBiproducts_of_preservesBinaryProducts F\n  exact Functor.additive_of_preservesBinaryBiproducts F\n\n"}
{"name":"CategoryTheory.Equivalence.inverse_additive","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_2} D\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.Preadditive D\ne : CategoryTheory.Equivalence C D\ninst‚úù : e.functor.Additive\n‚ä¢ e.inverse.Additive","decl":"instance inverse_additive (e : C ‚âå D) [e.functor.Additive] : e.inverse.Additive where\n  map_add {f g} := e.functor.map_injective (by simp)\n\n"}
{"name":"CategoryTheory.instFullAdditiveFunctorFunctorForget","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} D\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Preadditive D\n‚ä¢ (CategoryTheory.AdditiveFunctor.forget C D).Full","decl":"instance : (AdditiveFunctor.forget C D).Full :=\n  FullSubcategory.full _\n\n"}
{"name":"CategoryTheory.AdditiveFunctor.of_fst","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_2} D\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ Eq (CategoryTheory.AdditiveFunctor.of F).obj F","decl":"@[simp]\ntheorem AdditiveFunctor.of_fst (F : C ‚•§ D) [F.Additive] : (AdditiveFunctor.of F).1 = F :=\n  rfl\n\n"}
{"name":"CategoryTheory.AdditiveFunctor.forget_obj","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Preadditive D\nF : CategoryTheory.AdditiveFunctor C D\n‚ä¢ Eq ((CategoryTheory.AdditiveFunctor.forget C D).obj F) F.obj","decl":"@[simp]\ntheorem AdditiveFunctor.forget_obj (F : C ‚•§+ D) : (AdditiveFunctor.forget C D).obj F = F.1 :=\n  rfl\n\n"}
{"name":"CategoryTheory.AdditiveFunctor.forget_obj_of","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_2} D\ninst‚úù¬≤ : CategoryTheory.Preadditive C\ninst‚úù¬π : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Additive\n‚ä¢ Eq ((CategoryTheory.AdditiveFunctor.forget C D).obj (CategoryTheory.AdditiveFunctor.of F)) F","decl":"theorem AdditiveFunctor.forget_obj_of (F : C ‚•§ D) [F.Additive] :\n    (AdditiveFunctor.forget C D).obj (AdditiveFunctor.of F) = F :=\n  rfl\n\n"}
{"name":"CategoryTheory.AdditiveFunctor.forget_map","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Preadditive D\nF G : CategoryTheory.AdditiveFunctor C D\nŒ± : Quiver.Hom F G\n‚ä¢ Eq ((CategoryTheory.AdditiveFunctor.forget C D).map Œ±) Œ±","decl":"@[simp]\ntheorem AdditiveFunctor.forget_map (F G : C ‚•§+ D) (Œ± : F ‚ü∂ G) :\n    (AdditiveFunctor.forget C D).map Œ± = Œ± :=\n  rfl\n\n"}
{"name":"CategoryTheory.instAdditiveAdditiveFunctorFunctorForget","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Preadditive D\n‚ä¢ (CategoryTheory.AdditiveFunctor.forget C D).Additive","decl":"instance : Functor.Additive (AdditiveFunctor.forget C D) where map_add := rfl\n\n"}
{"name":"CategoryTheory.instAdditiveObjFunctor","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u_1\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_2} D\ninst‚úù¬π : CategoryTheory.Preadditive C\ninst‚úù : CategoryTheory.Preadditive D\nF : CategoryTheory.AdditiveFunctor C D\n‚ä¢ F.obj.Additive","decl":"instance (F : C ‚•§+ D) : Functor.Additive F.1 :=\n  F.2\n\n"}
{"name":"CategoryTheory.instFullLeftExactFunctorAdditiveFunctorOfLeftExact","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.Preadditive D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject D\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\n‚ä¢ (CategoryTheory.AdditiveFunctor.ofLeftExact C D).Full","decl":"instance : (AdditiveFunctor.ofLeftExact C D).Full := FullSubcategory.full_map _\n"}
{"name":"CategoryTheory.instFaithfulLeftExactFunctorAdditiveFunctorOfLeftExact","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.Preadditive D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject D\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\n‚ä¢ (CategoryTheory.AdditiveFunctor.ofLeftExact C D).Faithful","decl":"instance : (AdditiveFunctor.ofLeftExact C D).Faithful := FullSubcategory.faithful_map _\n\n"}
{"name":"CategoryTheory.instFullRightExactFunctorAdditiveFunctorOfRightExact","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.Preadditive D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject D\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\n‚ä¢ (CategoryTheory.AdditiveFunctor.ofRightExact C D).Full","decl":"instance : (AdditiveFunctor.ofRightExact C D).Full := FullSubcategory.full_map _\n"}
{"name":"CategoryTheory.instFaithfulRightExactFunctorAdditiveFunctorOfRightExact","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.Preadditive D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject D\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\n‚ä¢ (CategoryTheory.AdditiveFunctor.ofRightExact C D).Faithful","decl":"instance : (AdditiveFunctor.ofRightExact C D).Faithful := FullSubcategory.faithful_map _\n\n"}
{"name":"CategoryTheory.instFullExactFunctorAdditiveFunctorOfExact","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.Preadditive D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject D\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\n‚ä¢ (CategoryTheory.AdditiveFunctor.ofExact C D).Full","decl":"instance : (AdditiveFunctor.ofExact C D).Full := FullSubcategory.full_map _\n"}
{"name":"CategoryTheory.instFaithfulExactFunctorAdditiveFunctorOfExact","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.Preadditive D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject D\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\n‚ä¢ (CategoryTheory.AdditiveFunctor.ofExact C D).Faithful","decl":"instance : (AdditiveFunctor.ofExact C D).Faithful := FullSubcategory.faithful_map _\n\n"}
{"name":"CategoryTheory.AdditiveFunctor.ofLeftExact_obj_fst","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.Preadditive D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject D\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nF : CategoryTheory.LeftExactFunctor C D\n‚ä¢ Eq ((CategoryTheory.AdditiveFunctor.ofLeftExact C D).obj F).obj F.obj","decl":"@[simp]\ntheorem AdditiveFunctor.ofLeftExact_obj_fst (F : C ‚•§‚Çó D) :\n    ((AdditiveFunctor.ofLeftExact C D).obj F).obj = F.obj :=\n  rfl\n\n"}
{"name":"CategoryTheory.AdditiveFunctor.ofRightExact_obj_fst","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.Preadditive D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject D\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nF : CategoryTheory.RightExactFunctor C D\n‚ä¢ Eq ((CategoryTheory.AdditiveFunctor.ofRightExact C D).obj F).obj F.obj","decl":"@[simp]\ntheorem AdditiveFunctor.ofRightExact_obj_fst (F : C ‚•§·µ£ D) :\n    ((AdditiveFunctor.ofRightExact C D).obj F).obj = F.obj :=\n  rfl\n\n"}
{"name":"CategoryTheory.AdditiveFunctor.ofExact_obj_fst","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.Preadditive D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject D\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nF : CategoryTheory.ExactFunctor C D\n‚ä¢ Eq ((CategoryTheory.AdditiveFunctor.ofExact C D).obj F).obj F.obj","decl":"@[simp]\ntheorem AdditiveFunctor.ofExact_obj_fst (F : C ‚•§‚Çë D) :\n    ((AdditiveFunctor.ofExact C D).obj F).obj = F.obj :=\n  rfl\n\n"}
{"name":"CategoryTheory.AdditiveFunctor.ofLeftExact_map","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.Preadditive D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject D\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nF G : CategoryTheory.LeftExactFunctor C D\nŒ± : Quiver.Hom F G\n‚ä¢ Eq ((CategoryTheory.AdditiveFunctor.ofLeftExact C D).map Œ±) Œ±","decl":"@[simp]\ntheorem AdditiveFunctor.ofLeftExact_map {F G : C ‚•§‚Çó D} (Œ± : F ‚ü∂ G) :\n    (AdditiveFunctor.ofLeftExact C D).map Œ± = Œ± :=\n  rfl\n\n"}
{"name":"CategoryTheory.AdditiveFunctor.ofRightExact_map","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.Preadditive D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject D\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nF G : CategoryTheory.RightExactFunctor C D\nŒ± : Quiver.Hom F G\n‚ä¢ Eq ((CategoryTheory.AdditiveFunctor.ofRightExact C D).map Œ±) Œ±","decl":"@[simp]\ntheorem AdditiveFunctor.ofRightExact_map {F G : C ‚•§·µ£ D} (Œ± : F ‚ü∂ G) :\n    (AdditiveFunctor.ofRightExact C D).map Œ± = Œ± :=\n  rfl\n\n"}
{"name":"CategoryTheory.AdditiveFunctor.ofExact_map","module":"Mathlib.CategoryTheory.Preadditive.AdditiveFunctor","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù‚Å∂ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.Preadditive D\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject D\ninst‚úù : CategoryTheory.Limits.HasBinaryBiproducts C\nF G : CategoryTheory.ExactFunctor C D\nŒ± : Quiver.Hom F G\n‚ä¢ Eq ((CategoryTheory.AdditiveFunctor.ofExact C D).map Œ±) Œ±","decl":"@[simp]\ntheorem AdditiveFunctor.ofExact_map {F G : C ‚•§‚Çë D} (Œ± : F ‚ü∂ G) :\n    (AdditiveFunctor.ofExact C D).map Œ± = Œ± :=\n  rfl\n\n"}
