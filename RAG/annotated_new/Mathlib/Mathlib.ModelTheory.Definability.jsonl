{"name":"Set.Definable.map_expansion","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nA : Set M\nL : FirstOrder.Language\ninst✝² : L.Structure M\nα : Type u₁\ns : Set (α → M)\nL' : FirstOrder.Language\ninst✝¹ : L'.Structure M\nh : A.Definable L s\nφ : L.LHom L'\ninst✝ : φ.IsExpansionOn M\n⊢ A.Definable L' s","decl":"theorem Definable.map_expansion {L' : FirstOrder.Language} [L'.Structure M] (h : A.Definable L s)\n    (φ : L →ᴸ L') [φ.IsExpansionOn M] : A.Definable L' s := by\n  obtain ⟨ψ, rfl⟩ := h\n  refine ⟨(φ.addConstants A).onFormula ψ, ?_⟩\n  ext x\n  simp only [mem_setOf_eq, LHom.realize_onFormula]\n\n"}
{"name":"Set.definable_iff_exists_formula_sum","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nA : Set M\nL : FirstOrder.Language\ninst✝ : L.Structure M\nα : Type u₁\ns : Set (α → M)\n⊢ Iff (A.Definable L s) (Exists fun φ => Eq s (setOf fun v => φ.Realize (Sum.elim Subtype.val v)))","decl":"theorem definable_iff_exists_formula_sum :\n    A.Definable L s ↔ ∃ φ : L.Formula (A ⊕ α), s = {v | φ.Realize (Sum.elim (↑) v)} := by\n  rw [Definable, Equiv.exists_congr_left (BoundedFormula.constantsVarsEquiv)]\n  refine exists_congr (fun φ => iff_iff_eq.2 (congr_arg (s = ·) ?_))\n  ext\n  simp only [BoundedFormula.constantsVarsEquiv, constantsOn,\n    BoundedFormula.mapTermRelEquiv_symm_apply, mem_setOf_eq, Formula.Realize]\n  refine BoundedFormula.realize_mapTermRel_id ?_ (fun _ _ _ => rfl)\n  intros\n  simp only [Term.constantsVarsEquivLeft_symm_apply, Term.realize_varsToConstants,\n    coe_con, Term.realize_relabel]\n  congr\n  ext a\n  rcases a with (_ | _) | _ <;> rfl\n\n"}
{"name":"Set.empty_definable_iff","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nL : FirstOrder.Language\ninst✝ : L.Structure M\nα : Type u₁\ns : Set (α → M)\n⊢ Iff (EmptyCollection.emptyCollection.Definable L s) (Exists fun φ => Eq s (setOf φ.Realize))","decl":"theorem empty_definable_iff :\n    (∅ : Set M).Definable L s ↔ ∃ φ : L.Formula α, s = setOf φ.Realize := by\n  rw [Definable, Equiv.exists_congr_left (LEquiv.addEmptyConstants L (∅ : Set M)).onFormula]\n  simp\n\n"}
{"name":"Set.definable_iff_empty_definable_with_params","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nA : Set M\nL : FirstOrder.Language\ninst✝ : L.Structure M\nα : Type u₁\ns : Set (α → M)\n⊢ Iff (A.Definable L s) (EmptyCollection.emptyCollection.Definable (L.withConstants ↑A) s)","decl":"theorem definable_iff_empty_definable_with_params :\n    A.Definable L s ↔ (∅ : Set M).Definable (L[[A]]) s :=\n  empty_definable_iff.symm\n\n"}
{"name":"Set.Definable.mono","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nA : Set M\nL : FirstOrder.Language\ninst✝ : L.Structure M\nα : Type u₁\nB : Set M\ns : Set (α → M)\nhAs : A.Definable L s\nhAB : HasSubset.Subset A B\n⊢ B.Definable L s","decl":"theorem Definable.mono (hAs : A.Definable L s) (hAB : A ⊆ B) : B.Definable L s := by\n  rw [definable_iff_empty_definable_with_params] at *\n  exact hAs.map_expansion (L.lhomWithConstantsMap (Set.inclusion hAB))\n\n"}
{"name":"Set.definable_empty","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nA : Set M\nL : FirstOrder.Language\ninst✝ : L.Structure M\nα : Type u₁\n⊢ A.Definable L EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem definable_empty : A.Definable L (∅ : Set (α → M)) :=\n  ⟨⊥, by\n    ext\n    simp⟩\n\n"}
{"name":"Set.definable_univ","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nA : Set M\nL : FirstOrder.Language\ninst✝ : L.Structure M\nα : Type u₁\n⊢ A.Definable L Set.univ","decl":"@[simp]\ntheorem definable_univ : A.Definable L (univ : Set (α → M)) :=\n  ⟨⊤, by\n    ext\n    simp⟩\n\n"}
{"name":"Set.Definable.inter","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nA : Set M\nL : FirstOrder.Language\ninst✝ : L.Structure M\nα : Type u₁\nf g : Set (α → M)\nhf : A.Definable L f\nhg : A.Definable L g\n⊢ A.Definable L (Inter.inter f g)","decl":"@[simp]\ntheorem Definable.inter {f g : Set (α → M)} (hf : A.Definable L f) (hg : A.Definable L g) :\n    A.Definable L (f ∩ g) := by\n  rcases hf with ⟨φ, rfl⟩\n  rcases hg with ⟨θ, rfl⟩\n  refine ⟨φ ⊓ θ, ?_⟩\n  ext\n  simp\n\n"}
{"name":"Set.Definable.union","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nA : Set M\nL : FirstOrder.Language\ninst✝ : L.Structure M\nα : Type u₁\nf g : Set (α → M)\nhf : A.Definable L f\nhg : A.Definable L g\n⊢ A.Definable L (Union.union f g)","decl":"@[simp]\ntheorem Definable.union {f g : Set (α → M)} (hf : A.Definable L f) (hg : A.Definable L g) :\n    A.Definable L (f ∪ g) := by\n  rcases hf with ⟨φ, hφ⟩\n  rcases hg with ⟨θ, hθ⟩\n  refine ⟨φ ⊔ θ, ?_⟩\n  ext\n  rw [hφ, hθ, mem_setOf_eq, Formula.realize_sup, mem_union, mem_setOf_eq, mem_setOf_eq]\n\n"}
{"name":"Set.definable_finset_inf","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nA : Set M\nL : FirstOrder.Language\ninst✝ : L.Structure M\nα : Type u₁\nι : Type u_2\nf : ι → Set (α → M)\nhf : ∀ (i : ι), A.Definable L (f i)\ns : Finset ι\n⊢ A.Definable L (s.inf f)","decl":"theorem definable_finset_inf {ι : Type*} {f : ι → Set (α → M)} (hf : ∀ i, A.Definable L (f i))\n    (s : Finset ι) : A.Definable L (s.inf f) := by\n  classical\n    refine Finset.induction definable_univ (fun i s _ h => ?_) s\n    rw [Finset.inf_insert]\n    exact (hf i).inter h\n\n"}
{"name":"Set.definable_finset_sup","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nA : Set M\nL : FirstOrder.Language\ninst✝ : L.Structure M\nα : Type u₁\nι : Type u_2\nf : ι → Set (α → M)\nhf : ∀ (i : ι), A.Definable L (f i)\ns : Finset ι\n⊢ A.Definable L (s.sup f)","decl":"theorem definable_finset_sup {ι : Type*} {f : ι → Set (α → M)} (hf : ∀ i, A.Definable L (f i))\n    (s : Finset ι) : A.Definable L (s.sup f) := by\n  classical\n    refine Finset.induction definable_empty (fun i s _ h => ?_) s\n    rw [Finset.sup_insert]\n    exact (hf i).union h\n\n"}
{"name":"Set.definable_finset_biInter","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nA : Set M\nL : FirstOrder.Language\ninst✝ : L.Structure M\nα : Type u₁\nι : Type u_2\nf : ι → Set (α → M)\nhf : ∀ (i : ι), A.Definable L (f i)\ns : Finset ι\n⊢ A.Definable L (Set.iInter fun i => Set.iInter fun h => f i)","decl":"theorem definable_finset_biInter {ι : Type*} {f : ι → Set (α → M)}\n    (hf : ∀ i, A.Definable L (f i)) (s : Finset ι) : A.Definable L (⋂ i ∈ s, f i) := by\n  rw [← Finset.inf_set_eq_iInter]\n  exact definable_finset_inf hf s\n\n"}
{"name":"Set.definable_finset_biUnion","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nA : Set M\nL : FirstOrder.Language\ninst✝ : L.Structure M\nα : Type u₁\nι : Type u_2\nf : ι → Set (α → M)\nhf : ∀ (i : ι), A.Definable L (f i)\ns : Finset ι\n⊢ A.Definable L (Set.iUnion fun i => Set.iUnion fun h => f i)","decl":"theorem definable_finset_biUnion {ι : Type*} {f : ι → Set (α → M)}\n    (hf : ∀ i, A.Definable L (f i)) (s : Finset ι) : A.Definable L (⋃ i ∈ s, f i) := by\n  rw [← Finset.sup_set_eq_biUnion]\n  exact definable_finset_sup hf s\n\n"}
{"name":"Set.Definable.compl","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nA : Set M\nL : FirstOrder.Language\ninst✝ : L.Structure M\nα : Type u₁\ns : Set (α → M)\nhf : A.Definable L s\n⊢ A.Definable L (HasCompl.compl s)","decl":"@[simp]\ntheorem Definable.compl {s : Set (α → M)} (hf : A.Definable L s) : A.Definable L sᶜ := by\n  rcases hf with ⟨φ, hφ⟩\n  refine ⟨φ.not, ?_⟩\n  ext v\n  rw [hφ, compl_setOf, mem_setOf, mem_setOf, Formula.realize_not]\n\n"}
{"name":"Set.Definable.sdiff","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nA : Set M\nL : FirstOrder.Language\ninst✝ : L.Structure M\nα : Type u₁\ns t : Set (α → M)\nhs : A.Definable L s\nht : A.Definable L t\n⊢ A.Definable L (SDiff.sdiff s t)","decl":"@[simp]\ntheorem Definable.sdiff {s t : Set (α → M)} (hs : A.Definable L s) (ht : A.Definable L t) :\n    A.Definable L (s \\ t) :=\n  hs.inter ht.compl\n\n"}
{"name":"Set.Definable.himp","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nA : Set M\nL : FirstOrder.Language\ninst✝ : L.Structure M\nα : Type u₁\ns t : Set (α → M)\nhs : A.Definable L s\nht : A.Definable L t\n⊢ A.Definable L (HImp.himp s t)","decl":"@[simp] lemma Definable.himp {s t : Set (α → M)} (hs : A.Definable L s) (ht : A.Definable L t) :\n    A.Definable L (s ⇨ t) := by rw [himp_eq]; exact ht.union hs.compl\n\n"}
{"name":"Set.Definable.preimage_comp","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nA : Set M\nL : FirstOrder.Language\ninst✝ : L.Structure M\nα : Type u₁\nβ : Type u_1\nf : α → β\ns : Set (α → M)\nh : A.Definable L s\n⊢ A.Definable L (Set.preimage (fun g => Function.comp g f) s)","decl":"theorem Definable.preimage_comp (f : α → β) {s : Set (α → M)} (h : A.Definable L s) :\n    A.Definable L ((fun g : β → M => g ∘ f) ⁻¹' s) := by\n  obtain ⟨φ, rfl⟩ := h\n  refine ⟨φ.relabel f, ?_⟩\n  ext\n  simp only [Set.preimage_setOf_eq, mem_setOf_eq, Formula.realize_relabel]\n\n"}
{"name":"Set.Definable.image_comp_equiv","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nA : Set M\nL : FirstOrder.Language\ninst✝ : L.Structure M\nα : Type u₁\nβ : Type u_1\ns : Set (β → M)\nh : A.Definable L s\nf : Equiv α β\n⊢ A.Definable L (Set.image (fun g => Function.comp g ⇑f) s)","decl":"theorem Definable.image_comp_equiv {s : Set (β → M)} (h : A.Definable L s) (f : α ≃ β) :\n    A.Definable L ((fun g : β → M => g ∘ f) '' s) := by\n  refine (congr rfl ?_).mp (h.preimage_comp f.symm)\n  rw [image_eq_preimage_of_inverse]\n  · intro i\n    ext b\n    simp only [Function.comp_apply, Equiv.apply_symm_apply]\n  · intro i\n    ext a\n    simp\n\n"}
{"name":"Set.definable_iff_finitely_definable","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nA : Set M\nL : FirstOrder.Language\ninst✝ : L.Structure M\nα : Type u₁\ns : Set (α → M)\n⊢ Iff (A.Definable L s) (Exists fun A0 => And (HasSubset.Subset (↑A0) A) ((↑A0).Definable L s))","decl":"theorem definable_iff_finitely_definable :\n    A.Definable L s ↔ ∃ (A0 : Finset M), (A0 : Set M) ⊆ A ∧\n      (A0 : Set M).Definable L s := by\n  classical\n  constructor\n  · simp only [definable_iff_exists_formula_sum]\n    rintro ⟨φ, rfl⟩\n    let A0 := (φ.freeVarFinset.toLeft).image Subtype.val\n    refine ⟨A0, by simp [A0], (φ.restrictFreeVar <| fun x => Sum.casesOn x.1\n        (fun x hx => Sum.inl ⟨x, by simp [A0, hx]⟩) (fun x _ => Sum.inr x) x.2), ?_⟩\n    ext\n    simp only [Formula.Realize, mem_setOf_eq, Finset.coe_sort_coe]\n    exact iff_comm.1 <| BoundedFormula.realize_restrictFreeVar _ (by simp)\n  · rintro ⟨A0, hA0, hd⟩\n    exact Definable.mono hd hA0\n\n"}
{"name":"Set.Definable.image_comp_sum_inl_fin","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nA : Set M\nL : FirstOrder.Language\ninst✝ : L.Structure M\nα : Type u₁\nm : Nat\ns : Set (Sum α (Fin m) → M)\nh : A.Definable L s\n⊢ A.Definable L (Set.image (fun g => Function.comp g Sum.inl) s)","decl":"/-- This lemma is only intended as a helper for `Definable.image_comp`. -/\ntheorem Definable.image_comp_sum_inl_fin (m : ℕ) {s : Set (Sum α (Fin m) → M)}\n    (h : A.Definable L s) : A.Definable L ((fun g : Sum α (Fin m) → M => g ∘ Sum.inl) '' s) := by\n  obtain ⟨φ, rfl⟩ := h\n  refine ⟨(BoundedFormula.relabel id φ).exs, ?_⟩\n  ext x\n  simp only [Set.mem_image, mem_setOf_eq, BoundedFormula.realize_exs,\n    BoundedFormula.realize_relabel, Function.comp_id, Fin.castAdd_zero, Fin.cast_refl]\n  constructor\n  · rintro ⟨y, hy, rfl⟩\n    exact\n      ⟨y ∘ Sum.inr, (congr (congr rfl (Sum.elim_comp_inl_inr y).symm) (funext finZeroElim)).mp hy⟩\n  · rintro ⟨y, hy⟩\n    exact ⟨Sum.elim x y, (congr rfl (funext finZeroElim)).mp hy, Sum.elim_comp_inl _ _⟩\n\n"}
{"name":"Set.Definable.image_comp_embedding","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nA : Set M\nL : FirstOrder.Language\ninst✝¹ : L.Structure M\nα : Type u₁\nβ : Type u_1\ns : Set (β → M)\nh : A.Definable L s\nf : Function.Embedding α β\ninst✝ : Finite β\n⊢ A.Definable L (Set.image (fun g => Function.comp g ⇑f) s)","decl":"/-- Shows that definability is closed under finite projections. -/\ntheorem Definable.image_comp_embedding {s : Set (β → M)} (h : A.Definable L s) (f : α ↪ β)\n    [Finite β] : A.Definable L ((fun g : β → M => g ∘ f) '' s) := by\n  classical\n    cases nonempty_fintype β\n    refine\n      (congr rfl (ext fun x => ?_)).mp\n        (((h.image_comp_equiv (Equiv.Set.sumCompl (range f))).image_comp_equiv\n              (Equiv.sumCongr (Equiv.ofInjective f f.injective)\n                (Fintype.equivFin (↥(range f)ᶜ)).symm)).image_comp_sum_inl_fin\n          _)\n    simp only [mem_preimage, mem_image, exists_exists_and_eq_and]\n    refine exists_congr fun y => and_congr_right fun _ => Eq.congr_left (funext fun a => ?_)\n    simp\n\n"}
{"name":"Set.Definable.image_comp","module":"Mathlib.ModelTheory.Definability","initialProofState":"M : Type w\nA : Set M\nL : FirstOrder.Language\ninst✝² : L.Structure M\nα : Type u₁\nβ : Type u_1\ns : Set (β → M)\nh : A.Definable L s\nf : α → β\ninst✝¹ : Finite α\ninst✝ : Finite β\n⊢ A.Definable L (Set.image (fun g => Function.comp g f) s)","decl":"/-- Shows that definability is closed under finite projections. -/\ntheorem Definable.image_comp {s : Set (β → M)} (h : A.Definable L s) (f : α → β) [Finite α]\n    [Finite β] : A.Definable L ((fun g : β → M => g ∘ f) '' s) := by\n  classical\n    cases nonempty_fintype α\n    cases nonempty_fintype β\n    have h :=\n      (((h.image_comp_equiv (Equiv.Set.sumCompl (range f))).image_comp_equiv\n                (Equiv.sumCongr (_root_.Equiv.refl _)\n                  (Fintype.equivFin _).symm)).image_comp_sum_inl_fin\n            _).preimage_comp\n        (rangeSplitting f)\n    have h' :\n      A.Definable L { x : α → M | ∀ a, x a = x (rangeSplitting f (rangeFactorization f a)) } := by\n      have h' : ∀ a,\n        A.Definable L { x : α → M | x a = x (rangeSplitting f (rangeFactorization f a)) } := by\n          refine fun a => ⟨(var a).equal (var (rangeSplitting f (rangeFactorization f a))), ext ?_⟩\n          simp\n      refine (congr rfl (ext ?_)).mp (definable_finset_biInter h' Finset.univ)\n      simp\n    refine (congr rfl (ext fun x => ?_)).mp (h.inter h')\n    simp only [Equiv.coe_trans, mem_inter_iff, mem_preimage, mem_image, exists_exists_and_eq_and,\n      mem_setOf_eq]\n    constructor\n    · rintro ⟨⟨y, ys, hy⟩, hx⟩\n      refine ⟨y, ys, ?_⟩\n      ext a\n      rw [hx a, ← Function.comp_apply (f := x), ← hy]\n      simp\n    · rintro ⟨y, ys, rfl⟩\n      refine ⟨⟨y, ys, ?_⟩, fun a => ?_⟩\n      · ext\n        simp [Set.apply_rangeSplitting f]\n      · rw [Function.comp_apply, Function.comp_apply, apply_rangeSplitting f,\n          rangeFactorization_coe]\n\n"}
{"name":"FirstOrder.Language.DefinableSet.le_iff","module":"Mathlib.ModelTheory.Definability","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nA : Set M\nα : Type u₁\ns t : L.DefinableSet A α\n⊢ Iff (LE.le s t) (LE.le ↑s ↑t)","decl":"theorem le_iff : s ≤ t ↔ (s : Set (α → M)) ≤ (t : Set (α → M)) :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.DefinableSet.mem_top","module":"Mathlib.ModelTheory.Definability","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nA : Set M\nα : Type u₁\nx : α → M\n⊢ Membership.mem Top.top x","decl":"@[simp]\ntheorem mem_top : x ∈ (⊤ : L.DefinableSet A α) :=\n  mem_univ x\n\n"}
{"name":"FirstOrder.Language.DefinableSet.not_mem_bot","module":"Mathlib.ModelTheory.Definability","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nA : Set M\nα : Type u₁\nx : α → M\n⊢ Not (Membership.mem Bot.bot x)","decl":"@[simp]\ntheorem not_mem_bot {x : α → M} : ¬x ∈ (⊥ : L.DefinableSet A α) :=\n  not_mem_empty x\n\n"}
{"name":"FirstOrder.Language.DefinableSet.mem_sup","module":"Mathlib.ModelTheory.Definability","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nA : Set M\nα : Type u₁\ns t : L.DefinableSet A α\nx : α → M\n⊢ Iff (Membership.mem (Max.max s t) x) (Or (Membership.mem s x) (Membership.mem t x))","decl":"@[simp]\ntheorem mem_sup : x ∈ s ⊔ t ↔ x ∈ s ∨ x ∈ t :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.DefinableSet.mem_inf","module":"Mathlib.ModelTheory.Definability","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nA : Set M\nα : Type u₁\ns t : L.DefinableSet A α\nx : α → M\n⊢ Iff (Membership.mem (Min.min s t) x) (And (Membership.mem s x) (Membership.mem t x))","decl":"@[simp]\ntheorem mem_inf : x ∈ s ⊓ t ↔ x ∈ s ∧ x ∈ t :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.DefinableSet.mem_compl","module":"Mathlib.ModelTheory.Definability","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nA : Set M\nα : Type u₁\ns : L.DefinableSet A α\nx : α → M\n⊢ Iff (Membership.mem (HasCompl.compl s) x) (Not (Membership.mem s x))","decl":"@[simp]\ntheorem mem_compl : x ∈ sᶜ ↔ ¬x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.DefinableSet.mem_sdiff","module":"Mathlib.ModelTheory.Definability","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nA : Set M\nα : Type u₁\ns t : L.DefinableSet A α\nx : α → M\n⊢ Iff (Membership.mem (SDiff.sdiff s t) x) (And (Membership.mem s x) (Not (Membership.mem t x)))","decl":"@[simp]\ntheorem mem_sdiff : x ∈ s \\ t ↔ x ∈ s ∧ ¬x ∈ t :=\n  Iff.rfl\n\n"}
{"name":"FirstOrder.Language.DefinableSet.coe_top","module":"Mathlib.ModelTheory.Definability","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nA : Set M\nα : Type u₁\n⊢ Eq (↑Top.top) Set.univ","decl":"@[simp, norm_cast]\ntheorem coe_top : ((⊤ : L.DefinableSet A α) : Set (α → M)) = univ :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.DefinableSet.coe_bot","module":"Mathlib.ModelTheory.Definability","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nA : Set M\nα : Type u₁\n⊢ Eq (↑Bot.bot) EmptyCollection.emptyCollection","decl":"@[simp, norm_cast]\ntheorem coe_bot : ((⊥ : L.DefinableSet A α) : Set (α → M)) = ∅ :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.DefinableSet.coe_sup","module":"Mathlib.ModelTheory.Definability","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nA : Set M\nα : Type u₁\ns t : L.DefinableSet A α\n⊢ Eq (↑(Max.max s t)) (Union.union ↑s ↑t)","decl":"@[simp, norm_cast]\ntheorem coe_sup (s t : L.DefinableSet A α) :\n    ((s ⊔ t : L.DefinableSet A α) : Set (α → M)) = (s : Set (α → M)) ∪ (t : Set (α → M)) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.DefinableSet.coe_inf","module":"Mathlib.ModelTheory.Definability","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nA : Set M\nα : Type u₁\ns t : L.DefinableSet A α\n⊢ Eq (↑(Min.min s t)) (Inter.inter ↑s ↑t)","decl":"@[simp, norm_cast]\ntheorem coe_inf (s t : L.DefinableSet A α) :\n    ((s ⊓ t : L.DefinableSet A α) : Set (α → M)) = (s : Set (α → M)) ∩ (t : Set (α → M)) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.DefinableSet.coe_compl","module":"Mathlib.ModelTheory.Definability","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nA : Set M\nα : Type u₁\ns : L.DefinableSet A α\n⊢ Eq (↑(HasCompl.compl s)) (HasCompl.compl ↑s)","decl":"@[simp, norm_cast]\ntheorem coe_compl (s : L.DefinableSet A α) :\n    ((sᶜ : L.DefinableSet A α) : Set (α → M)) = (s : Set (α → M))ᶜ :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.DefinableSet.coe_sdiff","module":"Mathlib.ModelTheory.Definability","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nA : Set M\nα : Type u₁\ns t : L.DefinableSet A α\n⊢ Eq (↑(SDiff.sdiff s t)) (SDiff.sdiff ↑s ↑t)","decl":"@[simp, norm_cast]\ntheorem coe_sdiff (s t : L.DefinableSet A α) :\n    ((s \\ t : L.DefinableSet A α) : Set (α → M)) = (s : Set (α → M)) \\ (t : Set (α → M)) :=\n  rfl\n\n"}
{"name":"FirstOrder.Language.DefinableSet.coe_himp","module":"Mathlib.ModelTheory.Definability","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nA : Set M\nα : Type u₁\ns t : L.DefinableSet A α\n⊢ Eq (↑(HImp.himp s t)) (HImp.himp ↑s ↑t)","decl":"@[simp, norm_cast]\nlemma coe_himp (s t : L.DefinableSet A α) : ↑(s ⇨ t) = (s ⇨ t : Set (α → M)) := rfl\n\n"}
