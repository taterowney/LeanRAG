{"name":"MeasureTheory.IsProjectiveMeasureFamily.eq_zero_of_isEmpty","module":"Mathlib.MeasureTheory.Constructions.Projective","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → MeasurableSpace (α i)\nP : (J : Finset ι) → MeasureTheory.Measure ((j : Subtype fun x => Membership.mem J x) → α ↑j)\nh : IsEmpty ((i : ι) → α i)\nhP : MeasureTheory.IsProjectiveMeasureFamily P\nI : Finset ι\n⊢ Eq (P I) 0","decl":"lemma eq_zero_of_isEmpty [h : IsEmpty (Π i, α i)]\n    (hP : IsProjectiveMeasureFamily P) (I : Finset ι) :\n    P I = 0 := by\n  classical\n  obtain ⟨i, hi⟩ := isEmpty_pi.mp h\n  rw [hP (insert i I) I (I.subset_insert i)]\n  have : IsEmpty (Π j : ↑(insert i I), α j) := by simp [hi]\n  rw [(P (insert i I)).eq_zero_of_isEmpty]\n  simp\n\n"}
{"name":"MeasureTheory.IsProjectiveMeasureFamily.measure_univ_eq_of_subset","module":"Mathlib.MeasureTheory.Constructions.Projective","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → MeasurableSpace (α i)\nP : (J : Finset ι) → MeasureTheory.Measure ((j : Subtype fun x => Membership.mem J x) → α ↑j)\nI J : Finset ι\nhP : MeasureTheory.IsProjectiveMeasureFamily P\nhJI : HasSubset.Subset J I\n⊢ Eq ((P I) Set.univ) ((P J) Set.univ)","decl":"/-- Auxiliary lemma for `measure_univ_eq`. -/\nlemma measure_univ_eq_of_subset (hP : IsProjectiveMeasureFamily P) (hJI : J ⊆ I) :\n    P I univ = P J univ := by\n  classical\n  have : (univ : Set (∀ i : I, α i)) =\n      Finset.restrict₂ hJI ⁻¹' (univ : Set (∀ i : J, α i)) := by\n    rw [preimage_univ]\n  rw [this, ← Measure.map_apply _ MeasurableSet.univ]\n  · rw [hP I J hJI]\n  · exact measurable_pi_lambda _ (fun _ ↦ measurable_pi_apply _)\n\n"}
{"name":"MeasureTheory.IsProjectiveMeasureFamily.measure_univ_eq","module":"Mathlib.MeasureTheory.Constructions.Projective","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → MeasurableSpace (α i)\nP : (J : Finset ι) → MeasureTheory.Measure ((j : Subtype fun x => Membership.mem J x) → α ↑j)\nhP : MeasureTheory.IsProjectiveMeasureFamily P\nI J : Finset ι\n⊢ Eq ((P I) Set.univ) ((P J) Set.univ)","decl":"lemma measure_univ_eq (hP : IsProjectiveMeasureFamily P) (I J : Finset ι) :\n    P I univ = P J univ := by\n  classical\n  rw [← hP.measure_univ_eq_of_subset I.subset_union_left,\n    ← hP.measure_univ_eq_of_subset (I.subset_union_right (s₂ := J))]\n\n"}
{"name":"MeasureTheory.IsProjectiveMeasureFamily.congr_cylinder_of_subset","module":"Mathlib.MeasureTheory.Constructions.Projective","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → MeasurableSpace (α i)\nP : (J : Finset ι) → MeasureTheory.Measure ((j : Subtype fun x => Membership.mem J x) → α ↑j)\nI J : Finset ι\nhP : MeasureTheory.IsProjectiveMeasureFamily P\nS : Set ((i : Subtype fun x => Membership.mem I x) → α ↑i)\nT : Set ((i : Subtype fun x => Membership.mem J x) → α ↑i)\nhT : MeasurableSet T\nh_eq : Eq (MeasureTheory.cylinder I S) (MeasureTheory.cylinder J T)\nhJI : HasSubset.Subset J I\n⊢ Eq ((P I) S) ((P J) T)","decl":"lemma congr_cylinder_of_subset (hP : IsProjectiveMeasureFamily P)\n    {S : Set (∀ i : I, α i)} {T : Set (∀ i : J, α i)} (hT : MeasurableSet T)\n    (h_eq : cylinder I S = cylinder J T) (hJI : J ⊆ I) :\n    P I S = P J T := by\n  cases isEmpty_or_nonempty (∀ i, α i) with\n  | inl h =>\n    suffices ∀ I, P I univ = 0 by\n      simp only [Measure.measure_univ_eq_zero] at this\n      simp [this]\n    intro I\n    simp only [isEmpty_pi] at h\n    obtain ⟨i, hi_empty⟩ := h\n    rw [measure_univ_eq hP I {i}]\n    have : (univ : Set ((j : {x // x ∈ ({i} : Finset ι)}) → α j)) = ∅ := by simp [hi_empty]\n    simp [this]\n  | inr h =>\n    have : S = Finset.restrict₂ hJI ⁻¹' T :=\n      eq_of_cylinder_eq_of_subset h_eq hJI\n    rw [hP I J hJI, Measure.map_apply _ hT, this]\n    exact measurable_pi_lambda _ (fun _ ↦ measurable_pi_apply _)\n\n"}
{"name":"MeasureTheory.IsProjectiveMeasureFamily.congr_cylinder","module":"Mathlib.MeasureTheory.Constructions.Projective","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → MeasurableSpace (α i)\nP : (J : Finset ι) → MeasureTheory.Measure ((j : Subtype fun x => Membership.mem J x) → α ↑j)\nI J : Finset ι\nhP : MeasureTheory.IsProjectiveMeasureFamily P\nS : Set ((i : Subtype fun x => Membership.mem I x) → α ↑i)\nT : Set ((i : Subtype fun x => Membership.mem J x) → α ↑i)\nhS : MeasurableSet S\nhT : MeasurableSet T\nh_eq : Eq (MeasureTheory.cylinder I S) (MeasureTheory.cylinder J T)\n⊢ Eq ((P I) S) ((P J) T)","decl":"lemma congr_cylinder (hP : IsProjectiveMeasureFamily P)\n    {S : Set (∀ i : I, α i)} {T : Set (∀ i : J, α i)} (hS : MeasurableSet S) (hT : MeasurableSet T)\n    (h_eq : cylinder I S = cylinder J T) :\n    P I S = P J T := by\n  classical\n  let U := Finset.restrict₂ Finset.subset_union_left ⁻¹' S ∩\n      Finset.restrict₂ Finset.subset_union_right ⁻¹' T\n  suffices P (I ∪ J) U = P I S ∧ P (I ∪ J) U = P J T from this.1.symm.trans this.2\n  constructor\n  · have h_eq_union : cylinder I S = cylinder (I ∪ J) U := by\n      rw [← inter_cylinder, h_eq, inter_self]\n    exact hP.congr_cylinder_of_subset hS h_eq_union.symm Finset.subset_union_left\n  · have h_eq_union : cylinder J T = cylinder (I ∪ J) U := by\n      rw [← inter_cylinder, h_eq, inter_self]\n    exact hP.congr_cylinder_of_subset hT h_eq_union.symm Finset.subset_union_right\n\n"}
{"name":"MeasureTheory.IsProjectiveLimit.measure_cylinder","module":"Mathlib.MeasureTheory.Constructions.Projective","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → MeasurableSpace (α i)\nP : (J : Finset ι) → MeasureTheory.Measure ((j : Subtype fun x => Membership.mem J x) → α ↑j)\nμ : MeasureTheory.Measure ((i : ι) → α i)\nh : MeasureTheory.IsProjectiveLimit μ P\nI : Finset ι\ns : Set ((i : Subtype fun x => Membership.mem I x) → α ↑i)\nhs : MeasurableSet s\n⊢ Eq (μ (MeasureTheory.cylinder I s)) ((P I) s)","decl":"lemma measure_cylinder (h : IsProjectiveLimit μ P)\n    (I : Finset ι) {s : Set (∀ i : I, α i)} (hs : MeasurableSet s) :\n    μ (cylinder I s) = P I s := by\n  rw [cylinder, ← Measure.map_apply _ hs, h I]\n  exact measurable_pi_lambda _ (fun _ ↦ measurable_pi_apply _)\n\n"}
{"name":"MeasureTheory.IsProjectiveLimit.measure_univ_eq","module":"Mathlib.MeasureTheory.Constructions.Projective","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → MeasurableSpace (α i)\nP : (J : Finset ι) → MeasureTheory.Measure ((j : Subtype fun x => Membership.mem J x) → α ↑j)\nμ : MeasureTheory.Measure ((i : ι) → α i)\nhμ : MeasureTheory.IsProjectiveLimit μ P\nI : Finset ι\n⊢ Eq (μ Set.univ) ((P I) Set.univ)","decl":"lemma measure_univ_eq (hμ : IsProjectiveLimit μ P) (I : Finset ι) :\n    μ univ = P I univ := by\n  rw [← cylinder_univ I, hμ.measure_cylinder _ MeasurableSet.univ]\n\n"}
{"name":"MeasureTheory.IsProjectiveLimit.isFiniteMeasure","module":"Mathlib.MeasureTheory.Constructions.Projective","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\nP : (J : Finset ι) → MeasureTheory.Measure ((j : Subtype fun x => Membership.mem J x) → α ↑j)\nμ : MeasureTheory.Measure ((i : ι) → α i)\ninst✝ : ∀ (i : Finset ι), MeasureTheory.IsFiniteMeasure (P i)\nhμ : MeasureTheory.IsProjectiveLimit μ P\n⊢ MeasureTheory.IsFiniteMeasure μ","decl":"lemma isFiniteMeasure [∀ i, IsFiniteMeasure (P i)] (hμ : IsProjectiveLimit μ P) :\n    IsFiniteMeasure μ := by\n  constructor\n  rw [hμ.measure_univ_eq (∅ : Finset ι)]\n  exact measure_lt_top _ _\n\n"}
{"name":"MeasureTheory.IsProjectiveLimit.isProbabilityMeasure","module":"Mathlib.MeasureTheory.Constructions.Projective","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\nP : (J : Finset ι) → MeasureTheory.Measure ((j : Subtype fun x => Membership.mem J x) → α ↑j)\nμ : MeasureTheory.Measure ((i : ι) → α i)\ninst✝ : ∀ (i : Finset ι), MeasureTheory.IsProbabilityMeasure (P i)\nhμ : MeasureTheory.IsProjectiveLimit μ P\n⊢ MeasureTheory.IsProbabilityMeasure μ","decl":"lemma isProbabilityMeasure [∀ i, IsProbabilityMeasure (P i)] (hμ : IsProjectiveLimit μ P) :\n    IsProbabilityMeasure μ := by\n  constructor\n  rw [hμ.measure_univ_eq (∅ : Finset ι)]\n  exact measure_univ\n\n"}
{"name":"MeasureTheory.IsProjectiveLimit.measure_univ_unique","module":"Mathlib.MeasureTheory.Constructions.Projective","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝ : (i : ι) → MeasurableSpace (α i)\nP : (J : Finset ι) → MeasureTheory.Measure ((j : Subtype fun x => Membership.mem J x) → α ↑j)\nμ ν : MeasureTheory.Measure ((i : ι) → α i)\nhμ : MeasureTheory.IsProjectiveLimit μ P\nhν : MeasureTheory.IsProjectiveLimit ν P\n⊢ Eq (μ Set.univ) (ν Set.univ)","decl":"lemma measure_univ_unique (hμ : IsProjectiveLimit μ P) (hν : IsProjectiveLimit ν P) :\n    μ univ = ν univ := by\n  rw [hμ.measure_univ_eq (∅ : Finset ι), hν.measure_univ_eq (∅ : Finset ι)]\n\n"}
{"name":"MeasureTheory.IsProjectiveLimit.unique","module":"Mathlib.MeasureTheory.Constructions.Projective","initialProofState":"ι : Type u_1\nα : ι → Type u_2\ninst✝¹ : (i : ι) → MeasurableSpace (α i)\nP : (J : Finset ι) → MeasureTheory.Measure ((j : Subtype fun x => Membership.mem J x) → α ↑j)\nμ ν : MeasureTheory.Measure ((i : ι) → α i)\ninst✝ : ∀ (i : Finset ι), MeasureTheory.IsFiniteMeasure (P i)\nhμ : MeasureTheory.IsProjectiveLimit μ P\nhν : MeasureTheory.IsProjectiveLimit ν P\n⊢ Eq μ ν","decl":"/-- The projective limit of a family of finite measures is unique. -/\ntheorem unique [∀ i, IsFiniteMeasure (P i)]\n    (hμ : IsProjectiveLimit μ P) (hν : IsProjectiveLimit ν P) :\n    μ = ν := by\n  haveI : IsFiniteMeasure μ := hμ.isFiniteMeasure\n  refine ext_of_generate_finite (measurableCylinders α) generateFrom_measurableCylinders.symm\n    isPiSystem_measurableCylinders (fun s hs ↦ ?_) (hμ.measure_univ_unique hν)\n  obtain ⟨I, S, hS, rfl⟩ := (mem_measurableCylinders _).mp hs\n  rw [hμ.measure_cylinder _ hS, hν.measure_cylinder _ hS]\n\n"}
