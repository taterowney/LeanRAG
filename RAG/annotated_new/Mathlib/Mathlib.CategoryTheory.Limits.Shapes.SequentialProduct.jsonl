{"name":"CategoryTheory.Limits.SequentialProduct.functorObj_eq_pos","module":"Mathlib.CategoryTheory.Limits.Shapes.SequentialProduct","initialProofState":"C : Type u_1\nM N : Nat → C\nn m : Nat\nh : LT.lt m n\n⊢ Eq ((fun i => dite (LT.lt i n) (fun x => M i) fun x => N i) m) (M m)","decl":"lemma functorObj_eq_pos {n m : ℕ} (h : m < n) :\n    (fun i ↦ if _ : i < n then M i else N i) m = M m := dif_pos h\n\n"}
{"name":"CategoryTheory.Limits.SequentialProduct.functorObj_eq_neg","module":"Mathlib.CategoryTheory.Limits.Shapes.SequentialProduct","initialProofState":"C : Type u_1\nM N : Nat → C\nn m : Nat\nh : Not (LT.lt m n)\n⊢ Eq ((fun i => dite (LT.lt i n) (fun x => M i) fun x => N i) m) (N m)","decl":"lemma functorObj_eq_neg {n m : ℕ} (h : ¬(m < n)) :\n    (fun i ↦ if _ : i < n then M i else N i) m = N m := dif_neg h\n\n"}
{"name":"CategoryTheory.Limits.SequentialProduct.functorMap_commSq_succ","module":"Mathlib.CategoryTheory.Limits.Shapes.SequentialProduct","initialProofState":"C : Type u_1\nM N : Nat → C\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nf : (n : Nat) → Quiver.Hom (M n) (N n)\ninst✝ : CategoryTheory.Limits.HasProductsOfShape Nat C\nn : Nat\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.ofOpSequence (CategoryTheory.Limits.SequentialProduct.functorMap f)).map (CategoryTheory.homOfLE ⋯).op) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π (fun m => dite (LT.lt m (Opposite.unop { unop := n })) (fun x => M m) fun x => N m) n) (CategoryTheory.eqToHom ⋯))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π (fun i => dite (LT.lt i (HAdd.hAdd n 1)) (fun x => M i) fun x => N i) n) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (f n)))","decl":"lemma functorMap_commSq_succ (n : ℕ) :\n    (Functor.ofOpSequence (functorMap f)).map (homOfLE (by omega : n ≤ n+1)).op ≫ Pi.π _ n ≫\n      eqToHom (functorObj_eq_neg (by omega : ¬(n < n))) =\n        (Pi.π (fun i ↦ if _ : i < (n + 1) then M i else N i) n) ≫\n          eqToHom (functorObj_eq_pos (by omega)) ≫ f n := by\n  simp [functorMap]\n\n"}
{"name":"CategoryTheory.Limits.SequentialProduct.functorMap_commSq_aux","module":"Mathlib.CategoryTheory.Limits.Shapes.SequentialProduct","initialProofState":"C : Type u_1\nM N : Nat → C\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nf : (n : Nat) → Quiver.Hom (M n) (N n)\ninst✝ : CategoryTheory.Limits.HasProductsOfShape Nat C\nn m k : Nat\nh : LE.le n m\nhh : Not (LT.lt k m)\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.ofOpSequence (CategoryTheory.Limits.SequentialProduct.functorMap f)).map (CategoryTheory.homOfLE h).op) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π (fun m => dite (LT.lt m (Opposite.unop { unop := n })) (fun x => M m) fun x => N m) k) (CategoryTheory.eqToHom ⋯))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π (fun i => dite (LT.lt i m) (fun x => M i) fun x => N i) k) (CategoryTheory.eqToHom ⋯))","decl":"lemma functorMap_commSq_aux {n m k : ℕ} (h : n ≤ m) (hh : ¬(k < m)) :\n    (Functor.ofOpSequence (functorMap f)).map (homOfLE h).op ≫ Pi.π _ k ≫\n      eqToHom (functorObj_eq_neg (by omega : ¬(k < n))) =\n        (Pi.π (fun i ↦ if _ : i < m then M i else N i) k) ≫\n          eqToHom (functorObj_eq_neg hh) := by\n  induction' h using Nat.leRec with m h ih\n  · simp\n  · specialize ih (by omega)\n    have : homOfLE (by omega : n ≤ m + 1) =\n        homOfLE (by omega : n ≤ m) ≫ homOfLE (by omega : m ≤ m + 1) := by simp\n    rw [this, op_comp, Functor.map_comp]\n    slice_lhs 2 4 => rw [ih]\n    simp only [Functor.ofOpSequence_obj, homOfLE_leOfHom, Functor.ofOpSequence_map_homOfLE_succ,\n      functorMap, dite_eq_ite, limMap_π_assoc, Discrete.functor_obj_eq_as, Discrete.natTrans_app]\n    split_ifs\n    simp [dif_neg (by omega : ¬(k < m))]\n\n"}
{"name":"CategoryTheory.Limits.SequentialProduct.functorMap_commSq","module":"Mathlib.CategoryTheory.Limits.Shapes.SequentialProduct","initialProofState":"C : Type u_1\nM N : Nat → C\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nf : (n : Nat) → Quiver.Hom (M n) (N n)\ninst✝ : CategoryTheory.Limits.HasProductsOfShape Nat C\nn m : Nat\nh : Not (LT.lt m n)\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.ofOpSequence (CategoryTheory.Limits.SequentialProduct.functorMap f)).map (CategoryTheory.homOfLE ⋯).op) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π (fun m => dite (LT.lt m (Opposite.unop { unop := n })) (fun x => M m) fun x => N m) m) (CategoryTheory.eqToHom ⋯))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π (fun i => dite (LT.lt i (HAdd.hAdd m 1)) (fun x => M i) fun x => N i) m) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (f m)))","decl":"lemma functorMap_commSq {n m : ℕ} (h : ¬(m < n)) :\n    (Functor.ofOpSequence (functorMap f)).map (homOfLE (by omega : n ≤ m + 1)).op ≫ Pi.π _ m ≫\n      eqToHom (functorObj_eq_neg (by omega : ¬(m < n))) =\n        (Pi.π (fun i ↦ if _ : i < m + 1 then M i else N i) m) ≫\n          eqToHom (functorObj_eq_pos (by omega)) ≫ f m := by\n  cases m with\n  | zero =>\n      have : n = 0 := by omega\n      subst this\n      simp [functorMap]\n  | succ m =>\n      rw [← functorMap_commSq_succ f (m + 1)]\n      simp only [Functor.ofOpSequence_obj, homOfLE_leOfHom, dite_eq_ite,\n        Functor.ofOpSequence_map_homOfLE_succ, add_le_iff_nonpos_right, nonpos_iff_eq_zero,\n        one_ne_zero]\n      have : homOfLE (by omega : n ≤ m + 1 + 1) =\n          homOfLE (by omega : n ≤ m + 1) ≫ homOfLE (by omega : m + 1 ≤ m + 1 + 1) := by simp\n      rw [this, op_comp, Functor.map_comp]\n      simp only [Functor.ofOpSequence_obj, homOfLE_leOfHom, Functor.ofOpSequence_map_homOfLE_succ,\n        Category.assoc, add_le_iff_nonpos_right, nonpos_iff_eq_zero, one_ne_zero]\n      congr 1\n      exact functorMap_commSq_aux f (by omega) (by omega)\n\n"}
{"name":"CategoryTheory.Limits.SequentialProduct.cone_π_app","module":"Mathlib.CategoryTheory.Limits.Shapes.SequentialProduct","initialProofState":"C : Type u_1\nM N : Nat → C\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nf : (n : Nat) → Quiver.Hom (M n) (N n)\ninst✝ : CategoryTheory.Limits.HasProductsOfShape Nat C\nn : Nat\n⊢ Eq ((CategoryTheory.Limits.SequentialProduct.cone f).π.app { unop := n }) (CategoryTheory.Limits.Pi.map fun m => dite (LT.lt m n) (fun h => CategoryTheory.eqToHom ⋯) fun h => CategoryTheory.CategoryStruct.comp (f m) (CategoryTheory.eqToHom ⋯))","decl":"lemma cone_π_app (n : ℕ) : (cone f).π.app ⟨n⟩ =\n  Limits.Pi.map fun m ↦ if h : m < n then eqToHom (functorObj_eq_pos h).symm else\n    f m ≫ eqToHom (functorObj_eq_neg h).symm := rfl\n\n"}
{"name":"CategoryTheory.Limits.SequentialProduct.cone_π_app_comp_Pi_π_pos","module":"Mathlib.CategoryTheory.Limits.Shapes.SequentialProduct","initialProofState":"C : Type u_1\nM N : Nat → C\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nf : (n : Nat) → Quiver.Hom (M n) (N n)\ninst✝ : CategoryTheory.Limits.HasProductsOfShape Nat C\nm n : Nat\nh : LT.lt n m\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.SequentialProduct.cone f).π.app { unop := m }) (CategoryTheory.Limits.Pi.π (fun i => dite (LT.lt i m) (fun x => M i) fun x => N i) n)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π M n) (CategoryTheory.eqToHom ⋯))","decl":"@[reassoc]\nlemma cone_π_app_comp_Pi_π_pos (m n : ℕ) (h : n < m) : (cone f).π.app ⟨m⟩ ≫\n    Pi.π (fun i ↦ if _ : i < m then M i else N i) n =\n    Pi.π _ n ≫ eqToHom (functorObj_eq_pos h).symm := by\n  simp only [Functor.const_obj_obj, dite_eq_ite, Functor.ofOpSequence_obj, cone_π_app, limMap_π,\n    Discrete.functor_obj_eq_as, Discrete.natTrans_app]\n  rw [dif_pos h]\n\n"}
{"name":"CategoryTheory.Limits.SequentialProduct.cone_π_app_comp_Pi_π_pos_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.SequentialProduct","initialProofState":"C : Type u_1\nM N : Nat → C\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nf : (n : Nat) → Quiver.Hom (M n) (N n)\ninst✝ : CategoryTheory.Limits.HasProductsOfShape Nat C\nm n : Nat\nh✝ : LT.lt n m\nZ : C\nh : Quiver.Hom (dite (LT.lt n m) (fun x => M n) fun x => N n) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.SequentialProduct.cone f).π.app { unop := m }) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π (fun i => dite (LT.lt i m) (fun x => M i) fun x => N i) n) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π M n) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) h))","decl":"@[reassoc]\nlemma cone_π_app_comp_Pi_π_pos (m n : ℕ) (h : n < m) : (cone f).π.app ⟨m⟩ ≫\n    Pi.π (fun i ↦ if _ : i < m then M i else N i) n =\n    Pi.π _ n ≫ eqToHom (functorObj_eq_pos h).symm := by\n  simp only [Functor.const_obj_obj, dite_eq_ite, Functor.ofOpSequence_obj, cone_π_app, limMap_π,\n    Discrete.functor_obj_eq_as, Discrete.natTrans_app]\n  rw [dif_pos h]\n\n"}
{"name":"CategoryTheory.Limits.SequentialProduct.cone_π_app_comp_Pi_π_neg","module":"Mathlib.CategoryTheory.Limits.Shapes.SequentialProduct","initialProofState":"C : Type u_1\nM N : Nat → C\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nf : (n : Nat) → Quiver.Hom (M n) (N n)\ninst✝ : CategoryTheory.Limits.HasProductsOfShape Nat C\nm n : Nat\nh : Not (LT.lt n m)\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.SequentialProduct.cone f).π.app { unop := m }) (CategoryTheory.Limits.Pi.π (fun m_1 => dite (LT.lt m_1 (Opposite.unop { unop := m })) (fun x => M m_1) fun x => N m_1) n)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π M n) (CategoryTheory.CategoryStruct.comp (f n) (CategoryTheory.eqToHom ⋯)))","decl":"@[reassoc]\nlemma cone_π_app_comp_Pi_π_neg (m n : ℕ) (h : ¬(n < m)) : (cone f).π.app ⟨m⟩ ≫ Pi.π _ n =\n    Pi.π _ n ≫ f n ≫ eqToHom (functorObj_eq_neg h).symm := by\n  simp only [Functor.const_obj_obj, dite_eq_ite, Functor.ofOpSequence_obj, cone_π_app, limMap_π,\n    Discrete.functor_obj_eq_as, Discrete.natTrans_app]\n  rw [dif_neg h]\n\n"}
{"name":"CategoryTheory.Limits.SequentialProduct.cone_π_app_comp_Pi_π_neg_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.SequentialProduct","initialProofState":"C : Type u_1\nM N : Nat → C\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nf : (n : Nat) → Quiver.Hom (M n) (N n)\ninst✝ : CategoryTheory.Limits.HasProductsOfShape Nat C\nm n : Nat\nh✝ : Not (LT.lt n m)\nZ : C\nh : Quiver.Hom (dite (LT.lt n m) (fun x => M n) fun x => N n) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.SequentialProduct.cone f).π.app { unop := m }) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π (fun m_1 => dite (LT.lt m_1 m) (fun x => M m_1) fun x => N m_1) n) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π M n) (CategoryTheory.CategoryStruct.comp (f n) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) h)))","decl":"@[reassoc]\nlemma cone_π_app_comp_Pi_π_neg (m n : ℕ) (h : ¬(n < m)) : (cone f).π.app ⟨m⟩ ≫ Pi.π _ n =\n    Pi.π _ n ≫ f n ≫ eqToHom (functorObj_eq_neg h).symm := by\n  simp only [Functor.const_obj_obj, dite_eq_ite, Functor.ofOpSequence_obj, cone_π_app, limMap_π,\n    Discrete.functor_obj_eq_as, Discrete.natTrans_app]\n  rw [dif_neg h]\n\n"}
{"name":"CategoryTheory.Limits.SequentialProduct.functorMap_epi","module":"Mathlib.CategoryTheory.Limits.Shapes.SequentialProduct","initialProofState":"C : Type u_1\nM N : Nat → C\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\nf : (n : Nat) → Quiver.Hom (M n) (N n)\ninst✝⁴ : CategoryTheory.Limits.HasProductsOfShape Nat C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasFiniteBiproducts C\ninst✝¹ : CategoryTheory.Limits.HasCountableProducts C\ninst✝ : ∀ (n : Nat), CategoryTheory.Epi (f n)\nn : Nat\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.SequentialProduct.functorMap f n)","decl":"lemma functorMap_epi (n : ℕ) : Epi (functorMap f n) := by\n  rw [functorMap, Pi.map_eq_prod_map (P := fun m : ℕ ↦ m < n + 1)]\n  apply ( config := { allowSynthFailures := true } ) epi_comp\n  apply ( config := { allowSynthFailures := true } ) epi_comp\n  apply ( config := { allowSynthFailures := true } ) prod.map_epi\n  · apply ( config := { allowSynthFailures := true } ) Pi.map_epi\n    intro ⟨_, _⟩\n    split\n    all_goals infer_instance\n  · apply ( config := { allowSynthFailures := true } ) IsIso.epi_of_iso\n    apply ( config := { allowSynthFailures := true } ) Pi.map_isIso\n    intro ⟨_, _⟩\n    split\n    all_goals infer_instance\n"}
