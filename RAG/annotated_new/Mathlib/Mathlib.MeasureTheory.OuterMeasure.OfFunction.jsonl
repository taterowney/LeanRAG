{"name":"MeasureTheory.OuterMeasure.ofFunction_apply","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\nm_empty : Eq (m EmptyCollection.emptyCollection) 0\ns : Set α\n⊢ Eq ((MeasureTheory.OuterMeasure.ofFunction m m_empty) s) (iInf fun t => iInf fun x => tsum fun n => m (t n))","decl":"/-- `ofFunction` of a set `s` is the infimum of `∑ᵢ, m (tᵢ)` for all collections of sets\n`tᵢ` that cover `s`. -/\ntheorem ofFunction_apply (s : Set α) :\n    OuterMeasure.ofFunction m m_empty s = ⨅ (t : ℕ → Set α) (_ : s ⊆ iUnion t), ∑' n, m (t n) :=\n  rfl\n\n"}
{"name":"MeasureTheory.OuterMeasure.ofFunction_eq_iInf_mem","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\nm_empty : Eq (m EmptyCollection.emptyCollection) 0\nP : Set α → Prop\nm_top : ∀ (s : Set α), Not (P s) → Eq (m s) Top.top\ns : Set α\n⊢ Eq ((MeasureTheory.OuterMeasure.ofFunction m m_empty) s) (iInf fun t => iInf fun x => iInf fun x => tsum fun i => m (t i))","decl":"/-- `ofFunction` of a set `s` is the infimum of `∑ᵢ, m (tᵢ)` for all collections of sets\n`tᵢ` that cover `s`, with all `tᵢ` satisfying a predicate `P` such that `m` is infinite for sets\nthat don't satisfy `P`.\nThis is similar to `ofFunction_apply`, except that the sets `tᵢ` satisfy `P`.\nThe hypothesis `m_top` applies in particular to a function of the form `extend m'`. -/\ntheorem ofFunction_eq_iInf_mem {P : Set α → Prop} (m_top : ∀ s, ¬ P s → m s = ∞) (s : Set α) :\n    OuterMeasure.ofFunction m m_empty s =\n      ⨅ (t : ℕ → Set α) (_ : ∀ i, P (t i)) (_ : s ⊆ ⋃ i, t i), ∑' i, m (t i) := by\n  rw [OuterMeasure.ofFunction_apply]\n  apply le_antisymm\n  · exact le_iInf fun t ↦ le_iInf fun _ ↦ le_iInf fun h ↦ iInf₂_le _ (by exact h)\n  · simp_rw [le_iInf_iff]\n    refine fun t ht_subset ↦ iInf_le_of_le t ?_\n    by_cases ht : ∀ i, P (t i)\n    · exact iInf_le_of_le ht (iInf_le_of_le ht_subset le_rfl)\n    · simp only [ht, not_false_eq_true, iInf_neg, top_le_iff]\n      push_neg at ht\n      obtain ⟨i, hti_not_mem⟩ := ht\n      have hfi_top : m (t i) = ∞ := m_top _ hti_not_mem\n      exact ENNReal.tsum_eq_top_of_eq_top ⟨i, hfi_top⟩\n\n"}
{"name":"MeasureTheory.OuterMeasure.ofFunction_le","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\nm_empty : Eq (m EmptyCollection.emptyCollection) 0\ns : Set α\n⊢ LE.le ((MeasureTheory.OuterMeasure.ofFunction m m_empty) s) (m s)","decl":"theorem ofFunction_le (s : Set α) : OuterMeasure.ofFunction m m_empty s ≤ m s :=\n  let f : ℕ → Set α := fun i => Nat.casesOn i s fun _ => ∅\n  iInf_le_of_le f <|\n    iInf_le_of_le (subset_iUnion f 0) <|\n      le_of_eq <| tsum_eq_single 0 <| by\n        rintro (_ | i)\n        · simp\n        · simp [f, m_empty]\n\n"}
{"name":"MeasureTheory.OuterMeasure.ofFunction_eq","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\nm_empty : Eq (m EmptyCollection.emptyCollection) 0\ns : Set α\nm_mono : ∀ ⦃t : Set α⦄, HasSubset.Subset s t → LE.le (m s) (m t)\nm_subadd : ∀ (s : Nat → Set α), LE.le (m (Set.iUnion fun i => s i)) (tsum fun i => m (s i))\n⊢ Eq ((MeasureTheory.OuterMeasure.ofFunction m m_empty) s) (m s)","decl":"theorem ofFunction_eq (s : Set α) (m_mono : ∀ ⦃t : Set α⦄, s ⊆ t → m s ≤ m t)\n    (m_subadd : ∀ s : ℕ → Set α, m (⋃ i, s i) ≤ ∑' i, m (s i)) :\n    OuterMeasure.ofFunction m m_empty s = m s :=\n  le_antisymm (ofFunction_le s) <|\n    le_iInf fun f => le_iInf fun hf => le_trans (m_mono hf) (m_subadd f)\n\n"}
{"name":"MeasureTheory.OuterMeasure.le_ofFunction","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\nm_empty : Eq (m EmptyCollection.emptyCollection) 0\nμ : MeasureTheory.OuterMeasure α\n⊢ Iff (LE.le μ (MeasureTheory.OuterMeasure.ofFunction m m_empty)) (∀ (s : Set α), LE.le (μ s) (m s))","decl":"theorem le_ofFunction {μ : OuterMeasure α} :\n    μ ≤ OuterMeasure.ofFunction m m_empty ↔ ∀ s, μ s ≤ m s :=\n  ⟨fun H s => le_trans (H s) (ofFunction_le s), fun H _ =>\n    le_iInf fun f =>\n      le_iInf fun hs =>\n        le_trans (μ.mono hs) <| le_trans (measure_iUnion_le f) <| ENNReal.tsum_le_tsum fun _ => H _⟩\n\n"}
{"name":"MeasureTheory.OuterMeasure.isGreatest_ofFunction","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\nm_empty : Eq (m EmptyCollection.emptyCollection) 0\n⊢ IsGreatest (setOf fun μ => ∀ (s : Set α), LE.le (μ s) (m s)) (MeasureTheory.OuterMeasure.ofFunction m m_empty)","decl":"theorem isGreatest_ofFunction :\n    IsGreatest { μ : OuterMeasure α | ∀ s, μ s ≤ m s } (OuterMeasure.ofFunction m m_empty) :=\n  ⟨fun _ => ofFunction_le _, fun _ => le_ofFunction.2⟩\n\n"}
{"name":"MeasureTheory.OuterMeasure.ofFunction_eq_sSup","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\nm_empty : Eq (m EmptyCollection.emptyCollection) 0\n⊢ Eq (MeasureTheory.OuterMeasure.ofFunction m m_empty) (SupSet.sSup (setOf fun μ => ∀ (s : Set α), LE.le (μ s) (m s)))","decl":"theorem ofFunction_eq_sSup : OuterMeasure.ofFunction m m_empty = sSup { μ | ∀ s, μ s ≤ m s } :=\n  (@isGreatest_ofFunction α m m_empty).isLUB.sSup_eq.symm\n\n"}
{"name":"MeasureTheory.OuterMeasure.ofFunction_union_of_top_of_nonempty_inter","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\nm_empty : Eq (m EmptyCollection.emptyCollection) 0\ns t : Set α\nh : ∀ (u : Set α), (Inter.inter s u).Nonempty → (Inter.inter t u).Nonempty → Eq (m u) Top.top\n⊢ Eq ((MeasureTheory.OuterMeasure.ofFunction m m_empty) (Union.union s t)) (HAdd.hAdd ((MeasureTheory.OuterMeasure.ofFunction m m_empty) s) ((MeasureTheory.OuterMeasure.ofFunction m m_empty) t))","decl":"/-- If `m u = ∞` for any set `u` that has nonempty intersection both with `s` and `t`, then\n`μ (s ∪ t) = μ s + μ t`, where `μ = MeasureTheory.OuterMeasure.ofFunction m m_empty`.\n\nE.g., if `α` is an (e)metric space and `m u = ∞` on any set of diameter `≥ r`, then this lemma\nimplies that `μ (s ∪ t) = μ s + μ t` on any two sets such that `r ≤ edist x y` for all `x ∈ s`\nand `y ∈ t`. -/\ntheorem ofFunction_union_of_top_of_nonempty_inter {s t : Set α}\n    (h : ∀ u, (s ∩ u).Nonempty → (t ∩ u).Nonempty → m u = ∞) :\n    OuterMeasure.ofFunction m m_empty (s ∪ t) =\n      OuterMeasure.ofFunction m m_empty s + OuterMeasure.ofFunction m m_empty t := by\n  refine le_antisymm (measure_union_le _ _) (le_iInf₂ fun f hf ↦ ?_)\n  set μ := OuterMeasure.ofFunction m m_empty\n  rcases Classical.em (∃ i, (s ∩ f i).Nonempty ∧ (t ∩ f i).Nonempty) with (⟨i, hs, ht⟩ | he)\n  · calc\n      μ s + μ t ≤ ∞ := le_top\n      _ = m (f i) := (h (f i) hs ht).symm\n      _ ≤ ∑' i, m (f i) := ENNReal.le_tsum i\n\n  set I := fun s => { i : ℕ | (s ∩ f i).Nonempty }\n  have hd : Disjoint (I s) (I t) := disjoint_iff_inf_le.mpr fun i hi => he ⟨i, hi⟩\n  have hI : ∀ u ⊆ s ∪ t, μ u ≤ ∑' i : I u, μ (f i) := fun u hu =>\n    calc\n      μ u ≤ μ (⋃ i : I u, f i) :=\n        μ.mono fun x hx =>\n          let ⟨i, hi⟩ := mem_iUnion.1 (hf (hu hx))\n          mem_iUnion.2 ⟨⟨i, ⟨x, hx, hi⟩⟩, hi⟩\n      _ ≤ ∑' i : I u, μ (f i) := measure_iUnion_le _\n\n  calc\n    μ s + μ t ≤ (∑' i : I s, μ (f i)) + ∑' i : I t, μ (f i) :=\n      add_le_add (hI _ subset_union_left) (hI _ subset_union_right)\n    _ = ∑' i : ↑(I s ∪ I t), μ (f i) :=\n      (tsum_union_disjoint (f := fun i => μ (f i)) hd ENNReal.summable ENNReal.summable).symm\n    _ ≤ ∑' i, μ (f i) :=\n      (tsum_le_tsum_of_inj (↑) Subtype.coe_injective (fun _ _ => zero_le _) (fun _ => le_rfl)\n        ENNReal.summable ENNReal.summable)\n    _ ≤ ∑' i, m (f i) := ENNReal.tsum_le_tsum fun i => ofFunction_le _\n\n"}
{"name":"MeasureTheory.OuterMeasure.comap_ofFunction","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\nm_empty : Eq (m EmptyCollection.emptyCollection) 0\nβ : Type u_2\nf : β → α\nh : Or (Monotone m) (Function.Surjective f)\n⊢ Eq ((MeasureTheory.OuterMeasure.comap f) (MeasureTheory.OuterMeasure.ofFunction m m_empty)) (MeasureTheory.OuterMeasure.ofFunction (fun s => m (Set.image f s)) ⋯)","decl":"theorem comap_ofFunction {β} (f : β → α) (h : Monotone m ∨ Surjective f) :\n    comap f (OuterMeasure.ofFunction m m_empty) =\n      OuterMeasure.ofFunction (fun s => m (f '' s)) (by simp; simp [m_empty]) := by\n  refine le_antisymm (le_ofFunction.2 fun s => ?_) fun s => ?_\n  · rw [comap_apply]\n    apply ofFunction_le\n  · rw [comap_apply, ofFunction_apply, ofFunction_apply]\n    refine iInf_mono' fun t => ⟨fun k => f ⁻¹' t k, ?_⟩\n    refine iInf_mono' fun ht => ?_\n    rw [Set.image_subset_iff, preimage_iUnion] at ht\n    refine ⟨ht, ENNReal.tsum_le_tsum fun n => ?_⟩\n    cases' h with hl hr\n    exacts [hl (image_preimage_subset _ _), (congr_arg m (hr.image_preimage (t n))).le]\n\n"}
{"name":"MeasureTheory.OuterMeasure.map_ofFunction_le","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\nm_empty : Eq (m EmptyCollection.emptyCollection) 0\nβ : Type u_2\nf : α → β\n⊢ LE.le ((MeasureTheory.OuterMeasure.map f) (MeasureTheory.OuterMeasure.ofFunction m m_empty)) (MeasureTheory.OuterMeasure.ofFunction (fun s => m (Set.preimage f s)) m_empty)","decl":"theorem map_ofFunction_le {β} (f : α → β) :\n    map f (OuterMeasure.ofFunction m m_empty) ≤\n      OuterMeasure.ofFunction (fun s => m (f ⁻¹' s)) m_empty :=\n  le_ofFunction.2 fun s => by\n    rw [map_apply]\n    apply ofFunction_le\n\n"}
{"name":"MeasureTheory.OuterMeasure.map_ofFunction","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\nm_empty : Eq (m EmptyCollection.emptyCollection) 0\nβ : Type u_2\nf : α → β\nhf : Function.Injective f\n⊢ Eq ((MeasureTheory.OuterMeasure.map f) (MeasureTheory.OuterMeasure.ofFunction m m_empty)) (MeasureTheory.OuterMeasure.ofFunction (fun s => m (Set.preimage f s)) m_empty)","decl":"theorem map_ofFunction {β} {f : α → β} (hf : Injective f) :\n    map f (OuterMeasure.ofFunction m m_empty) =\n      OuterMeasure.ofFunction (fun s => m (f ⁻¹' s)) m_empty := by\n  refine (map_ofFunction_le _).antisymm fun s => ?_\n  simp only [ofFunction_apply, map_apply, le_iInf_iff]\n  intro t ht\n  refine iInf_le_of_le (fun n => (range f)ᶜ ∪ f '' t n) (iInf_le_of_le ?_ ?_)\n  · rw [← union_iUnion, ← inter_subset, ← image_preimage_eq_inter_range, ← image_iUnion]\n    exact image_subset _ ht\n  · refine ENNReal.tsum_le_tsum fun n => le_of_eq ?_\n    simp [hf.preimage_image]\n\n-- TODO (kmill): change `m (t ∩ s)` to `m (s ∩ t)`\n"}
{"name":"MeasureTheory.OuterMeasure.restrict_ofFunction","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\nm_empty : Eq (m EmptyCollection.emptyCollection) 0\ns : Set α\nhm : Monotone m\n⊢ Eq ((MeasureTheory.OuterMeasure.restrict s) (MeasureTheory.OuterMeasure.ofFunction m m_empty)) (MeasureTheory.OuterMeasure.ofFunction (fun t => m (Inter.inter t s)) ⋯)","decl":"theorem restrict_ofFunction (s : Set α) (hm : Monotone m) :\n    restrict s (OuterMeasure.ofFunction m m_empty) =\n      OuterMeasure.ofFunction (fun t => m (t ∩ s)) (by simp; simp [m_empty]) := by\n      rw [restrict]\n      simp only [inter_comm _ s, LinearMap.comp_apply]\n      rw [comap_ofFunction _ (Or.inl hm)]\n      simp only [map_ofFunction Subtype.coe_injective, Subtype.image_preimage_coe]\n\n"}
{"name":"MeasureTheory.OuterMeasure.smul_ofFunction","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\nm_empty : Eq (m EmptyCollection.emptyCollection) 0\nc : ENNReal\nhc : Ne c Top.top\n⊢ Eq (HSMul.hSMul c (MeasureTheory.OuterMeasure.ofFunction m m_empty)) (MeasureTheory.OuterMeasure.ofFunction (HSMul.hSMul c m) ⋯)","decl":"theorem smul_ofFunction {c : ℝ≥0∞} (hc : c ≠ ∞) : c • OuterMeasure.ofFunction m m_empty =\n    OuterMeasure.ofFunction (c • m) (by simp [m_empty]) := by\n  ext1 s\n  haveI : Nonempty { t : ℕ → Set α // s ⊆ ⋃ i, t i } := ⟨⟨fun _ => s, subset_iUnion (fun _ => s) 0⟩⟩\n  simp only [smul_apply, ofFunction_apply, ENNReal.tsum_mul_left, Pi.smul_apply, smul_eq_mul,\n  iInf_subtype']\n  rw [ENNReal.mul_iInf fun h => (hc h).elim]\n\n"}
{"name":"MeasureTheory.OuterMeasure.boundedBy_le","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\ns : Set α\n⊢ LE.le ((MeasureTheory.OuterMeasure.boundedBy m) s) (m s)","decl":"theorem boundedBy_le (s : Set α) : boundedBy m s ≤ m s :=\n  (ofFunction_le _).trans iSup_const_le\n\n"}
{"name":"MeasureTheory.OuterMeasure.boundedBy_eq_ofFunction","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\nm_empty : Eq (m EmptyCollection.emptyCollection) 0\ns : Set α\n⊢ Eq ((MeasureTheory.OuterMeasure.boundedBy m) s) ((MeasureTheory.OuterMeasure.ofFunction m m_empty) s)","decl":"theorem boundedBy_eq_ofFunction (m_empty : m ∅ = 0) (s : Set α) :\n    boundedBy m s = OuterMeasure.ofFunction m m_empty s := by\n  have : (fun s : Set α => ⨆ _ : s.Nonempty, m s) = m := by\n    ext1 t\n    rcases t.eq_empty_or_nonempty with h | h <;> simp [h, Set.not_nonempty_empty, m_empty]\n  simp [boundedBy, this]\n\n"}
{"name":"MeasureTheory.OuterMeasure.boundedBy_apply","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\ns : Set α\n⊢ Eq ((MeasureTheory.OuterMeasure.boundedBy m) s) (iInf fun t => iInf fun x => tsum fun n => iSup fun x => m (t n))","decl":"theorem boundedBy_apply (s : Set α) :\n    boundedBy m s = ⨅ (t : ℕ → Set α) (_ : s ⊆ iUnion t),\n                      ∑' n, ⨆ _ : (t n).Nonempty, m (t n) := by\n  simp [boundedBy, ofFunction_apply]\n\n"}
{"name":"MeasureTheory.OuterMeasure.boundedBy_eq","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\ns : Set α\nm_empty : Eq (m EmptyCollection.emptyCollection) 0\nm_mono : ∀ ⦃t : Set α⦄, HasSubset.Subset s t → LE.le (m s) (m t)\nm_subadd : ∀ (s : Nat → Set α), LE.le (m (Set.iUnion fun i => s i)) (tsum fun i => m (s i))\n⊢ Eq ((MeasureTheory.OuterMeasure.boundedBy m) s) (m s)","decl":"theorem boundedBy_eq (s : Set α) (m_empty : m ∅ = 0) (m_mono : ∀ ⦃t : Set α⦄, s ⊆ t → m s ≤ m t)\n    (m_subadd : ∀ s : ℕ → Set α, m (⋃ i, s i) ≤ ∑' i, m (s i)) : boundedBy m s = m s := by\n  rw [boundedBy_eq_ofFunction m_empty, ofFunction_eq s m_mono m_subadd]\n\n"}
{"name":"MeasureTheory.OuterMeasure.boundedBy_eq_self","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : MeasureTheory.OuterMeasure α\n⊢ Eq (MeasureTheory.OuterMeasure.boundedBy ⇑m) m","decl":"@[simp]\ntheorem boundedBy_eq_self (m : OuterMeasure α) : boundedBy m = m :=\n  ext fun _ => boundedBy_eq _ measure_empty (fun _ ht => measure_mono ht) measure_iUnion_le\n\n"}
{"name":"MeasureTheory.OuterMeasure.le_boundedBy","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\nμ : MeasureTheory.OuterMeasure α\n⊢ Iff (LE.le μ (MeasureTheory.OuterMeasure.boundedBy m)) (∀ (s : Set α), LE.le (μ s) (m s))","decl":"theorem le_boundedBy {μ : OuterMeasure α} : μ ≤ boundedBy m ↔ ∀ s, μ s ≤ m s := by\n  rw [boundedBy , le_ofFunction, forall_congr']; intro s\n  rcases s.eq_empty_or_nonempty with h | h <;> simp [h, Set.not_nonempty_empty]\n\n"}
{"name":"MeasureTheory.OuterMeasure.le_boundedBy'","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\nμ : MeasureTheory.OuterMeasure α\n⊢ Iff (LE.le μ (MeasureTheory.OuterMeasure.boundedBy m)) (∀ (s : Set α), s.Nonempty → LE.le (μ s) (m s))","decl":"theorem le_boundedBy' {μ : OuterMeasure α} :\n    μ ≤ boundedBy m ↔ ∀ s : Set α, s.Nonempty → μ s ≤ m s := by\n  rw [le_boundedBy, forall_congr']\n  intro s\n  rcases s.eq_empty_or_nonempty with h | h <;> simp [h]\n\n"}
{"name":"MeasureTheory.OuterMeasure.boundedBy_top","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\n⊢ Eq (MeasureTheory.OuterMeasure.boundedBy Top.top) Top.top","decl":"@[simp]\ntheorem boundedBy_top : boundedBy (⊤ : Set α → ℝ≥0∞) = ⊤ := by\n  rw [eq_top_iff, le_boundedBy']\n  intro s hs\n  rw [top_apply hs]\n  exact le_rfl\n\n"}
{"name":"MeasureTheory.OuterMeasure.boundedBy_zero","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\n⊢ Eq (MeasureTheory.OuterMeasure.boundedBy 0) 0","decl":"@[simp]\ntheorem boundedBy_zero : boundedBy (0 : Set α → ℝ≥0∞) = 0 := by\n  rw [← coe_bot, eq_bot_iff]\n  apply boundedBy_le\n\n"}
{"name":"MeasureTheory.OuterMeasure.smul_boundedBy","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\nc : ENNReal\nhc : Ne c Top.top\n⊢ Eq (HSMul.hSMul c (MeasureTheory.OuterMeasure.boundedBy m)) (MeasureTheory.OuterMeasure.boundedBy (HSMul.hSMul c m))","decl":"theorem smul_boundedBy {c : ℝ≥0∞} (hc : c ≠ ∞) : c • boundedBy m = boundedBy (c • m) := by\n  simp only [boundedBy , smul_ofFunction hc]\n  congr 1 with s : 1\n  rcases s.eq_empty_or_nonempty with (rfl | hs) <;> simp [*]\n\n"}
{"name":"MeasureTheory.OuterMeasure.comap_boundedBy","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\nβ : Type u_2\nf : β → α\nh : Or (Monotone fun s => m ↑s) (Function.Surjective f)\n⊢ Eq ((MeasureTheory.OuterMeasure.comap f) (MeasureTheory.OuterMeasure.boundedBy m)) (MeasureTheory.OuterMeasure.boundedBy fun s => m (Set.image f s))","decl":"theorem comap_boundedBy {β} (f : β → α)\n    (h : (Monotone fun s : { s : Set α // s.Nonempty } => m s) ∨ Surjective f) :\n    comap f (boundedBy m) = boundedBy fun s => m (f '' s) := by\n  refine (comap_ofFunction _ ?_).trans ?_\n  · refine h.imp (fun H s t hst => iSup_le fun hs => ?_) id\n    have ht : t.Nonempty := hs.mono hst\n    exact (@H ⟨s, hs⟩ ⟨t, ht⟩ hst).trans (le_iSup (fun _ : t.Nonempty => m t) ht)\n  · dsimp only [boundedBy]\n    congr with s : 1\n    rw [image_nonempty]\n\n"}
{"name":"MeasureTheory.OuterMeasure.boundedBy_union_of_top_of_nonempty_inter","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set α → ENNReal\ns t : Set α\nh : ∀ (u : Set α), (Inter.inter s u).Nonempty → (Inter.inter t u).Nonempty → Eq (m u) Top.top\n⊢ Eq ((MeasureTheory.OuterMeasure.boundedBy m) (Union.union s t)) (HAdd.hAdd ((MeasureTheory.OuterMeasure.boundedBy m) s) ((MeasureTheory.OuterMeasure.boundedBy m) t))","decl":"/-- If `m u = ∞` for any set `u` that has nonempty intersection both with `s` and `t`, then\n`μ (s ∪ t) = μ s + μ t`, where `μ = MeasureTheory.OuterMeasure.boundedBy m`.\n\nE.g., if `α` is an (e)metric space and `m u = ∞` on any set of diameter `≥ r`, then this lemma\nimplies that `μ (s ∪ t) = μ s + μ t` on any two sets such that `r ≤ edist x y` for all `x ∈ s`\nand `y ∈ t`. -/\ntheorem boundedBy_union_of_top_of_nonempty_inter {s t : Set α}\n    (h : ∀ u, (s ∩ u).Nonempty → (t ∩ u).Nonempty → m u = ∞) :\n    boundedBy m (s ∪ t) = boundedBy m s + boundedBy m t :=\n  ofFunction_union_of_top_of_nonempty_inter fun u hs ht =>\n    top_unique <| (h u hs ht).ge.trans <| le_iSup (fun _ => m u) (hs.mono inter_subset_right)\n\n"}
{"name":"MeasureTheory.OuterMeasure.sInfGen_def","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set (MeasureTheory.OuterMeasure α)\nt : Set α\n⊢ Eq (MeasureTheory.OuterMeasure.sInfGen m t) (iInf fun μ => iInf fun x => μ t)","decl":"theorem sInfGen_def (m : Set (OuterMeasure α)) (t : Set α) :\n    sInfGen m t = ⨅ (μ : OuterMeasure α) (_ : μ ∈ m), μ t :=\n  rfl\n\n"}
{"name":"MeasureTheory.OuterMeasure.sInf_eq_boundedBy_sInfGen","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set (MeasureTheory.OuterMeasure α)\n⊢ Eq (InfSet.sInf m) (MeasureTheory.OuterMeasure.boundedBy (MeasureTheory.OuterMeasure.sInfGen m))","decl":"theorem sInf_eq_boundedBy_sInfGen (m : Set (OuterMeasure α)) :\n    sInf m = OuterMeasure.boundedBy (sInfGen m) := by\n  refine le_antisymm ?_ ?_\n  · refine le_boundedBy.2 fun s => le_iInf₂ fun μ hμ => ?_\n    apply sInf_le hμ\n  · refine le_sInf ?_\n    intro μ hμ t\n    exact le_trans (boundedBy_le t) (iInf₂_le μ hμ)\n\n"}
{"name":"MeasureTheory.OuterMeasure.iSup_sInfGen_nonempty","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set (MeasureTheory.OuterMeasure α)\nh : m.Nonempty\nt : Set α\n⊢ Eq (iSup fun x => MeasureTheory.OuterMeasure.sInfGen m t) (iInf fun μ => iInf fun x => μ t)","decl":"theorem iSup_sInfGen_nonempty {m : Set (OuterMeasure α)} (h : m.Nonempty) (t : Set α) :\n    ⨆ _ : t.Nonempty, sInfGen m t = ⨅ (μ : OuterMeasure α) (_ : μ ∈ m), μ t := by\n  rcases t.eq_empty_or_nonempty with (rfl | ht)\n  · simp [biInf_const h]\n  · simp [ht, sInfGen_def]\n\n"}
{"name":"MeasureTheory.OuterMeasure.sInf_apply","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set (MeasureTheory.OuterMeasure α)\ns : Set α\nh : m.Nonempty\n⊢ Eq ((InfSet.sInf m) s) (iInf fun t => iInf fun x => tsum fun n => iInf fun μ => iInf fun x => μ (t n))","decl":"/-- The value of the Infimum of a nonempty set of outer measures on a set is not simply\nthe minimum value of a measure on that set: it is the infimum sum of measures of countable set of\nsets that covers that set, where a different measure can be used for each set in the cover. -/\ntheorem sInf_apply {m : Set (OuterMeasure α)} {s : Set α} (h : m.Nonempty) :\n    sInf m s =\n      ⨅ (t : ℕ → Set α) (_ : s ⊆ iUnion t), ∑' n, ⨅ (μ : OuterMeasure α) (_ : μ ∈ m), μ (t n) := by\n  simp_rw [sInf_eq_boundedBy_sInfGen, boundedBy_apply, iSup_sInfGen_nonempty h]\n\n"}
{"name":"MeasureTheory.OuterMeasure.sInf_apply'","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set (MeasureTheory.OuterMeasure α)\ns : Set α\nh : s.Nonempty\n⊢ Eq ((InfSet.sInf m) s) (iInf fun t => iInf fun x => tsum fun n => iInf fun μ => iInf fun x => μ (t n))","decl":"/-- The value of the Infimum of a set of outer measures on a nonempty set is not simply\nthe minimum value of a measure on that set: it is the infimum sum of measures of countable set of\nsets that covers that set, where a different measure can be used for each set in the cover. -/\ntheorem sInf_apply' {m : Set (OuterMeasure α)} {s : Set α} (h : s.Nonempty) :\n    sInf m s =\n      ⨅ (t : ℕ → Set α) (_ : s ⊆ iUnion t), ∑' n, ⨅ (μ : OuterMeasure α) (_ : μ ∈ m), μ (t n) :=\n  m.eq_empty_or_nonempty.elim (fun hm => by simp [hm, h]) sInf_apply\n\n"}
{"name":"MeasureTheory.OuterMeasure.iInf_apply","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nι : Sort u_2\ninst✝ : Nonempty ι\nm : ι → MeasureTheory.OuterMeasure α\ns : Set α\n⊢ Eq ((iInf fun i => m i) s) (iInf fun t => iInf fun x => tsum fun n => iInf fun i => (m i) (t n))","decl":"/-- The value of the Infimum of a nonempty family of outer measures on a set is not simply\nthe minimum value of a measure on that set: it is the infimum sum of measures of countable set of\nsets that covers that set, where a different measure can be used for each set in the cover. -/\ntheorem iInf_apply {ι} [Nonempty ι] (m : ι → OuterMeasure α) (s : Set α) :\n    (⨅ i, m i) s = ⨅ (t : ℕ → Set α) (_ : s ⊆ iUnion t), ∑' n, ⨅ i, m i (t n) := by\n  rw [iInf, sInf_apply (range_nonempty m)]\n  simp only [iInf_range]\n\n"}
{"name":"MeasureTheory.OuterMeasure.iInf_apply'","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nι : Sort u_2\nm : ι → MeasureTheory.OuterMeasure α\ns : Set α\nhs : s.Nonempty\n⊢ Eq ((iInf fun i => m i) s) (iInf fun t => iInf fun x => tsum fun n => iInf fun i => (m i) (t n))","decl":"/-- The value of the Infimum of a family of outer measures on a nonempty set is not simply\nthe minimum value of a measure on that set: it is the infimum sum of measures of countable set of\nsets that covers that set, where a different measure can be used for each set in the cover. -/\ntheorem iInf_apply' {ι} (m : ι → OuterMeasure α) {s : Set α} (hs : s.Nonempty) :\n    (⨅ i, m i) s = ⨅ (t : ℕ → Set α) (_ : s ⊆ iUnion t), ∑' n, ⨅ i, m i (t n) := by\n  rw [iInf, sInf_apply' hs]\n  simp only [iInf_range]\n\n"}
{"name":"MeasureTheory.OuterMeasure.biInf_apply","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nι : Type u_2\nI : Set ι\nhI : I.Nonempty\nm : ι → MeasureTheory.OuterMeasure α\ns : Set α\n⊢ Eq ((iInf fun i => iInf fun h => m i) s) (iInf fun t => iInf fun x => tsum fun n => iInf fun i => iInf fun h => (m i) (t n))","decl":"/-- The value of the Infimum of a nonempty family of outer measures on a set is not simply\nthe minimum value of a measure on that set: it is the infimum sum of measures of countable set of\nsets that covers that set, where a different measure can be used for each set in the cover. -/\ntheorem biInf_apply {ι} {I : Set ι} (hI : I.Nonempty) (m : ι → OuterMeasure α) (s : Set α) :\n    (⨅ i ∈ I, m i) s = ⨅ (t : ℕ → Set α) (_ : s ⊆ iUnion t), ∑' n, ⨅ i ∈ I, m i (t n) := by\n  haveI := hI.to_subtype\n  simp only [← iInf_subtype'', iInf_apply]\n\n"}
{"name":"MeasureTheory.OuterMeasure.biInf_apply'","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nι : Type u_2\nI : Set ι\nm : ι → MeasureTheory.OuterMeasure α\ns : Set α\nhs : s.Nonempty\n⊢ Eq ((iInf fun i => iInf fun h => m i) s) (iInf fun t => iInf fun x => tsum fun n => iInf fun i => iInf fun h => (m i) (t n))","decl":"/-- The value of the Infimum of a nonempty family of outer measures on a set is not simply\nthe minimum value of a measure on that set: it is the infimum sum of measures of countable set of\nsets that covers that set, where a different measure can be used for each set in the cover. -/\ntheorem biInf_apply' {ι} (I : Set ι) (m : ι → OuterMeasure α) {s : Set α} (hs : s.Nonempty) :\n    (⨅ i ∈ I, m i) s = ⨅ (t : ℕ → Set α) (_ : s ⊆ iUnion t), ∑' n, ⨅ i ∈ I, m i (t n) := by\n  simp only [← iInf_subtype'', iInf_apply' _ hs]\n\n"}
{"name":"MeasureTheory.OuterMeasure.map_iInf_le","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nι : Sort u_2\nβ : Type u_3\nf : α → β\nm : ι → MeasureTheory.OuterMeasure α\n⊢ LE.le ((MeasureTheory.OuterMeasure.map f) (iInf fun i => m i)) (iInf fun i => (MeasureTheory.OuterMeasure.map f) (m i))","decl":"theorem map_iInf_le {ι β} (f : α → β) (m : ι → OuterMeasure α) :\n    map f (⨅ i, m i) ≤ ⨅ i, map f (m i) :=\n  (map_mono f).map_iInf_le\n\n"}
{"name":"MeasureTheory.OuterMeasure.comap_iInf","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nι : Sort u_2\nβ : Type u_3\nf : α → β\nm : ι → MeasureTheory.OuterMeasure β\n⊢ Eq ((MeasureTheory.OuterMeasure.comap f) (iInf fun i => m i)) (iInf fun i => (MeasureTheory.OuterMeasure.comap f) (m i))","decl":"theorem comap_iInf {ι β} (f : α → β) (m : ι → OuterMeasure β) :\n    comap f (⨅ i, m i) = ⨅ i, comap f (m i) := by\n  refine ext_nonempty fun s hs => ?_\n  refine ((comap_mono f).map_iInf_le s).antisymm ?_\n  simp only [comap_apply, iInf_apply' _ hs, iInf_apply' _ (hs.image _), le_iInf_iff,\n    Set.image_subset_iff, preimage_iUnion]\n  refine fun t ht => iInf_le_of_le _ (iInf_le_of_le ht <| ENNReal.tsum_le_tsum fun k => ?_)\n  exact iInf_mono fun i => (m i).mono (image_preimage_subset _ _)\n\n"}
{"name":"MeasureTheory.OuterMeasure.map_iInf","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nι : Sort u_2\nβ : Type u_3\nf : α → β\nhf : Function.Injective f\nm : ι → MeasureTheory.OuterMeasure α\n⊢ Eq ((MeasureTheory.OuterMeasure.map f) (iInf fun i => m i)) ((MeasureTheory.OuterMeasure.restrict (Set.range f)) (iInf fun i => (MeasureTheory.OuterMeasure.map f) (m i)))","decl":"theorem map_iInf {ι β} {f : α → β} (hf : Injective f) (m : ι → OuterMeasure α) :\n    map f (⨅ i, m i) = restrict (range f) (⨅ i, map f (m i)) := by\n  refine Eq.trans ?_ (map_comap _ _)\n  simp only [comap_iInf, comap_map hf]\n\n"}
{"name":"MeasureTheory.OuterMeasure.map_iInf_comap","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nι : Sort u_2\nβ : Type u_3\ninst✝ : Nonempty ι\nf : α → β\nm : ι → MeasureTheory.OuterMeasure β\n⊢ Eq ((MeasureTheory.OuterMeasure.map f) (iInf fun i => (MeasureTheory.OuterMeasure.comap f) (m i))) (iInf fun i => (MeasureTheory.OuterMeasure.map f) ((MeasureTheory.OuterMeasure.comap f) (m i)))","decl":"theorem map_iInf_comap {ι β} [Nonempty ι] {f : α → β} (m : ι → OuterMeasure β) :\n    map f (⨅ i, comap f (m i)) = ⨅ i, map f (comap f (m i)) := by\n  refine (map_iInf_le _ _).antisymm fun s => ?_\n  simp only [map_apply, comap_apply, iInf_apply, le_iInf_iff]\n  refine fun t ht => iInf_le_of_le (fun n => f '' t n ∪ (range f)ᶜ) (iInf_le_of_le ?_ ?_)\n  · rw [← iUnion_union, Set.union_comm, ← inter_subset, ← image_iUnion, ←\n      image_preimage_eq_inter_range]\n    exact image_subset _ ht\n  · refine ENNReal.tsum_le_tsum fun n => iInf_mono fun i => (m i).mono ?_\n    simp only [preimage_union, preimage_compl, preimage_range, compl_univ, union_empty,\n      image_subset_iff]\n    exact subset_refl _\n\n"}
{"name":"MeasureTheory.OuterMeasure.map_biInf_comap","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nι : Type u_2\nβ : Type u_3\nI : Set ι\nhI : I.Nonempty\nf : α → β\nm : ι → MeasureTheory.OuterMeasure β\n⊢ Eq ((MeasureTheory.OuterMeasure.map f) (iInf fun i => iInf fun h => (MeasureTheory.OuterMeasure.comap f) (m i))) (iInf fun i => iInf fun h => (MeasureTheory.OuterMeasure.map f) ((MeasureTheory.OuterMeasure.comap f) (m i)))","decl":"theorem map_biInf_comap {ι β} {I : Set ι} (hI : I.Nonempty) {f : α → β} (m : ι → OuterMeasure β) :\n    map f (⨅ i ∈ I, comap f (m i)) = ⨅ i ∈ I, map f (comap f (m i)) := by\n  haveI := hI.to_subtype\n  rw [← iInf_subtype'', ← iInf_subtype'']\n  exact map_iInf_comap _\n\n"}
{"name":"MeasureTheory.OuterMeasure.restrict_iInf_restrict","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nι : Sort u_2\ns : Set α\nm : ι → MeasureTheory.OuterMeasure α\n⊢ Eq ((MeasureTheory.OuterMeasure.restrict s) (iInf fun i => (MeasureTheory.OuterMeasure.restrict s) (m i))) ((MeasureTheory.OuterMeasure.restrict s) (iInf fun i => m i))","decl":"theorem restrict_iInf_restrict {ι} (s : Set α) (m : ι → OuterMeasure α) :\n    restrict s (⨅ i, restrict s (m i)) = restrict s (⨅ i, m i) :=\n  calc restrict s (⨅ i, restrict s (m i))\n    _ = restrict (range ((↑) : s → α)) (⨅ i, restrict s (m i)) := by rw [Subtype.range_coe]\n    _ = map ((↑) : s → α) (⨅ i, comap (↑) (m i)) := (map_iInf Subtype.coe_injective _).symm\n    _ = restrict s (⨅ i, m i) := congr_arg (map ((↑) : s → α)) (comap_iInf _ _).symm\n\n"}
{"name":"MeasureTheory.OuterMeasure.restrict_iInf","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nι : Sort u_2\ninst✝ : Nonempty ι\ns : Set α\nm : ι → MeasureTheory.OuterMeasure α\n⊢ Eq ((MeasureTheory.OuterMeasure.restrict s) (iInf fun i => m i)) (iInf fun i => (MeasureTheory.OuterMeasure.restrict s) (m i))","decl":"theorem restrict_iInf {ι} [Nonempty ι] (s : Set α) (m : ι → OuterMeasure α) :\n    restrict s (⨅ i, m i) = ⨅ i, restrict s (m i) :=\n  (congr_arg (map ((↑) : s → α)) (comap_iInf _ _)).trans (map_iInf_comap _)\n\n"}
{"name":"MeasureTheory.OuterMeasure.restrict_biInf","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nι : Type u_2\nI : Set ι\nhI : I.Nonempty\ns : Set α\nm : ι → MeasureTheory.OuterMeasure α\n⊢ Eq ((MeasureTheory.OuterMeasure.restrict s) (iInf fun i => iInf fun h => m i)) (iInf fun i => iInf fun h => (MeasureTheory.OuterMeasure.restrict s) (m i))","decl":"theorem restrict_biInf {ι} {I : Set ι} (hI : I.Nonempty) (s : Set α) (m : ι → OuterMeasure α) :\n    restrict s (⨅ i ∈ I, m i) = ⨅ i ∈ I, restrict s (m i) := by\n  haveI := hI.to_subtype\n  rw [← iInf_subtype'', ← iInf_subtype'']\n  exact restrict_iInf _ _\n\n"}
{"name":"MeasureTheory.OuterMeasure.restrict_sInf_eq_sInf_restrict","module":"Mathlib.MeasureTheory.OuterMeasure.OfFunction","initialProofState":"α : Type u_1\nm : Set (MeasureTheory.OuterMeasure α)\ns : Set α\nhm : m.Nonempty\n⊢ Eq ((MeasureTheory.OuterMeasure.restrict s) (InfSet.sInf m)) (InfSet.sInf (Set.image (⇑(MeasureTheory.OuterMeasure.restrict s)) m))","decl":"/-- This proves that Inf and restrict commute for outer measures, so long as the set of\nouter measures is nonempty. -/\ntheorem restrict_sInf_eq_sInf_restrict (m : Set (OuterMeasure α)) {s : Set α} (hm : m.Nonempty) :\n    restrict s (sInf m) = sInf (restrict s '' m) := by\n  simp only [sInf_eq_iInf, restrict_biInf, hm, iInf_image]\n\n"}
