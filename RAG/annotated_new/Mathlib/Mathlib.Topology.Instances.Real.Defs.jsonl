{"name":"instNoncompactSpaceReal","module":"Mathlib.Topology.Instances.Real.Defs","initialProofState":"⊢ NoncompactSpace Real","decl":"instance : NoncompactSpace ℝ := Int.isClosedEmbedding_coe_real.noncompactSpace\n\n"}
{"name":"Real.uniformContinuous_add","module":"Mathlib.Topology.Instances.Real.Defs","initialProofState":"⊢ UniformContinuous fun p => HAdd.hAdd p.1 p.2","decl":"theorem Real.uniformContinuous_add : UniformContinuous fun p : ℝ × ℝ => p.1 + p.2 :=\n  Metric.uniformContinuous_iff.2 fun _ε ε0 =>\n    let ⟨δ, δ0, Hδ⟩ := rat_add_continuous_lemma abs ε0\n    ⟨δ, δ0, fun _ _ h =>\n      let ⟨h₁, h₂⟩ := max_lt_iff.1 h\n      Hδ h₁ h₂⟩\n\n"}
{"name":"Real.uniformContinuous_neg","module":"Mathlib.Topology.Instances.Real.Defs","initialProofState":"⊢ UniformContinuous Neg.neg","decl":"theorem Real.uniformContinuous_neg : UniformContinuous (@Neg.neg ℝ _) :=\n  Metric.uniformContinuous_iff.2 fun ε ε0 =>\n    ⟨_, ε0, fun _ _ h => by simpa only [abs_sub_comm, Real.dist_eq, neg_sub_neg] using h⟩\n\n"}
{"name":"instUniformAddGroupReal","module":"Mathlib.Topology.Instances.Real.Defs","initialProofState":"⊢ UniformAddGroup Real","decl":"instance : UniformAddGroup ℝ :=\n  UniformAddGroup.mk' Real.uniformContinuous_add Real.uniformContinuous_neg\n\n"}
{"name":"Real.uniformContinuous_const_mul","module":"Mathlib.Topology.Instances.Real.Defs","initialProofState":"x : Real\n⊢ UniformContinuous fun x_1 => HMul.hMul x x_1","decl":"theorem Real.uniformContinuous_const_mul {x : ℝ} : UniformContinuous (x * ·) :=\n  uniformContinuous_of_continuousAt_zero (DistribMulAction.toAddMonoidHom ℝ x)\n    (continuous_const_smul x).continuousAt\n\n-- short-circuit type class inference\n"}
{"name":"instTopologicalAddGroupReal","module":"Mathlib.Topology.Instances.Real.Defs","initialProofState":"⊢ TopologicalAddGroup Real","decl":"instance : TopologicalAddGroup ℝ := by infer_instance\n"}
{"name":"instTopologicalRingReal","module":"Mathlib.Topology.Instances.Real.Defs","initialProofState":"⊢ TopologicalRing Real","decl":"instance : TopologicalRing ℝ := inferInstance\n"}
{"name":"instTopologicalDivisionRingReal","module":"Mathlib.Topology.Instances.Real.Defs","initialProofState":"⊢ TopologicalDivisionRing Real","decl":"instance : TopologicalDivisionRing ℝ := inferInstance\n\n"}
{"name":"instProperSpaceReal","module":"Mathlib.Topology.Instances.Real.Defs","initialProofState":"⊢ ProperSpace Real","decl":"instance : ProperSpace ℝ where\n  isCompact_closedBall x r := by\n    rw [Real.closedBall_eq_Icc]\n    apply isCompact_Icc\n\n"}
{"name":"instSecondCountableTopologyReal","module":"Mathlib.Topology.Instances.Real.Defs","initialProofState":"⊢ SecondCountableTopology Real","decl":"instance : SecondCountableTopology ℝ := secondCountable_of_proper\n\n"}
{"name":"Real.instCompleteSpace","module":"Mathlib.Topology.Instances.Real.Defs","initialProofState":"⊢ CompleteSpace Real","decl":"instance Real.instCompleteSpace : CompleteSpace ℝ := by\n  apply complete_of_cauchySeq_tendsto\n  intro u hu\n  let c : CauSeq ℝ abs := ⟨u, Metric.cauchySeq_iff'.1 hu⟩\n  refine ⟨c.lim, fun s h => ?_⟩\n  rcases Metric.mem_nhds_iff.1 h with ⟨ε, ε0, hε⟩\n  have := c.equiv_lim ε ε0\n  simp only [mem_map, mem_atTop_sets, mem_setOf_eq]\n  exact this.imp fun N hN n hn => hε (hN n hn)\n\n"}
{"name":"instIsOrderBornology","module":"Mathlib.Topology.Instances.Real.Defs","initialProofState":"⊢ IsOrderBornology Real","decl":"instance instIsOrderBornology : IsOrderBornology ℝ where\n  isBounded_iff_bddBelow_bddAbove s := by\n    refine ⟨fun bdd ↦ ?_, fun h ↦ isBounded_of_bddAbove_of_bddBelow h.2 h.1⟩\n    obtain ⟨r, hr⟩ : ∃ r : ℝ, s ⊆ Icc (-r) r := by\n      simpa [Real.closedBall_eq_Icc] using bdd.subset_closedBall 0\n    exact ⟨bddBelow_Icc.mono hr, bddAbove_Icc.mono hr⟩\n\n"}
{"name":"instContinuousStarReal","module":"Mathlib.Topology.Instances.Real.Defs","initialProofState":"⊢ ContinuousStar Real","decl":"instance : ContinuousStar ℝ := ⟨continuous_id⟩\n"}
