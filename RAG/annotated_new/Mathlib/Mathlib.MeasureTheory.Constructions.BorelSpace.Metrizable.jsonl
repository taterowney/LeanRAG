{"name":"measurable_of_tendsto_metrizable'","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Metrizable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ¶ : MeasurableSpace Î±\ninstâœâµ : TopologicalSpace Î²\ninstâœâ´ : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœÂ³ : MeasurableSpace Î²\ninstâœÂ² : BorelSpace Î²\nÎ¹ : Type u_3\nf : Î¹ â†’ Î± â†’ Î²\ng : Î± â†’ Î²\nu : Filter Î¹\ninstâœÂ¹ : u.NeBot\ninstâœ : u.IsCountablyGenerated\nhf : âˆ€ (i : Î¹), Measurable (f i)\nlim : Filter.Tendsto f u (nhds g)\nâŠ¢ Measurable g","decl":"/-- A limit (over a general filter) of measurable functions valued in a (pseudo) metrizable space is\nmeasurable. -/\ntheorem measurable_of_tendsto_metrizable' {Î¹} {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (u : Filter Î¹) [NeBot u]\n    [IsCountablyGenerated u] (hf : âˆ€ i, Measurable (f i)) (lim : Tendsto f u (ğ“ g)) :\n    Measurable g := by\n  letI : PseudoMetricSpace Î² := pseudoMetrizableSpacePseudoMetric Î²\n  apply measurable_of_isClosed'\n  intro s h1s h2s h3s\n  have : Measurable fun x => infNndist (g x) s := by\n    suffices Tendsto (fun i x => infNndist (f i x) s) u (ğ“ fun x => infNndist (g x) s) from\n      NNReal.measurable_of_tendsto' u (fun i => (hf i).infNndist) this\n    rw [tendsto_pi_nhds] at lim âŠ¢\n    intro x\n    exact ((continuous_infNndist_pt s).tendsto (g x)).comp (lim x)\n  have h4s : g â»Â¹' s = (fun x => infNndist (g x) s) â»Â¹' {0} := by\n    ext x\n    simp [h1s, â† h1s.mem_iff_infDist_zero h2s, â† NNReal.coe_eq_zero]\n  rw [h4s]\n  exact this (measurableSet_singleton 0)\n\n"}
{"name":"measurable_of_tendsto_metrizable","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Metrizable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : BorelSpace Î²\nf : Nat â†’ Î± â†’ Î²\ng : Î± â†’ Î²\nhf : âˆ€ (i : Nat), Measurable (f i)\nlim : Filter.Tendsto f Filter.atTop (nhds g)\nâŠ¢ Measurable g","decl":"/-- A sequential limit of measurable functions valued in a (pseudo) metrizable space is\nmeasurable. -/\ntheorem measurable_of_tendsto_metrizable {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²} (hf : âˆ€ i, Measurable (f i))\n    (lim : Tendsto f atTop (ğ“ g)) : Measurable g :=\n  measurable_of_tendsto_metrizable' atTop hf lim\n\n"}
{"name":"aemeasurable_of_tendsto_metrizable_ae","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Metrizable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : TopologicalSpace Î²\ninstâœÂ³ : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœÂ² : MeasurableSpace Î²\ninstâœÂ¹ : BorelSpace Î²\nÎ¹ : Type u_3\nÎ¼ : MeasureTheory.Measure Î±\nf : Î¹ â†’ Î± â†’ Î²\ng : Î± â†’ Î²\nu : Filter Î¹\nhu : u.NeBot\ninstâœ : u.IsCountablyGenerated\nhf : âˆ€ (n : Î¹), AEMeasurable (f n) Î¼\nh_tendsto : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) u (nhds (g x))) (MeasureTheory.ae Î¼)\nâŠ¢ AEMeasurable g Î¼","decl":"theorem aemeasurable_of_tendsto_metrizable_ae {Î¹} {Î¼ : Measure Î±} {f : Î¹ â†’ Î± â†’ Î²} {g : Î± â†’ Î²}\n    (u : Filter Î¹) [hu : NeBot u] [IsCountablyGenerated u] (hf : âˆ€ n, AEMeasurable (f n) Î¼)\n    (h_tendsto : âˆ€áµ x âˆ‚Î¼, Tendsto (fun n => f n x) u (ğ“ (g x))) : AEMeasurable g Î¼ := by\n  classical\n  rcases u.exists_seq_tendsto with âŸ¨v, hvâŸ©\n  have h'f : âˆ€ n, AEMeasurable (f (v n)) Î¼ := fun n => hf (v n)\n  set p : Î± â†’ (â„• â†’ Î²) â†’ Prop := fun x f' => Tendsto (fun n => f' n) atTop (ğ“ (g x))\n  have hp : âˆ€áµ x âˆ‚Î¼, p x fun n => f (v n) x := by\n    filter_upwards [h_tendsto] with x hx using hx.comp hv\n  set aeSeqLim := fun x => ite (x âˆˆ aeSeqSet h'f p) (g x) (âŸ¨f (v 0) xâŸ© : Nonempty Î²).some\n  refine\n    âŸ¨aeSeqLim,\n      measurable_of_tendsto_metrizable' atTop (aeSeq.measurable h'f p)\n        (tendsto_pi_nhds.mpr fun x => ?_),\n      ?_âŸ©\n  Â· simp_rw [aeSeqLim, aeSeq]\n    split_ifs with hx\n    Â· simp_rw [aeSeq.mk_eq_fun_of_mem_aeSeqSet h'f hx]\n      exact @aeSeq.fun_prop_of_mem_aeSeqSet _ Î± Î² _ _ _ _ _ h'f x hx\n    Â· exact tendsto_const_nhds\n  Â· exact\n      (ite_ae_eq_of_measure_compl_zero g (fun x => (âŸ¨f (v 0) xâŸ© : Nonempty Î²).some) (aeSeqSet h'f p)\n          (aeSeq.measure_compl_aeSeqSet_eq_zero h'f hp)).symm\n\n"}
{"name":"aemeasurable_of_tendsto_metrizable_ae'","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Metrizable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ´ : MeasurableSpace Î±\ninstâœÂ³ : TopologicalSpace Î²\ninstâœÂ² : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : BorelSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\nf : Nat â†’ Î± â†’ Î²\ng : Î± â†’ Î²\nhf : âˆ€ (n : Nat), AEMeasurable (f n) Î¼\nh_ae_tendsto : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) (MeasureTheory.ae Î¼)\nâŠ¢ AEMeasurable g Î¼","decl":"theorem aemeasurable_of_tendsto_metrizable_ae' {Î¼ : Measure Î±} {f : â„• â†’ Î± â†’ Î²} {g : Î± â†’ Î²}\n    (hf : âˆ€ n, AEMeasurable (f n) Î¼)\n    (h_ae_tendsto : âˆ€áµ x âˆ‚Î¼, Tendsto (fun n => f n x) atTop (ğ“ (g x))) : AEMeasurable g Î¼ :=\n  aemeasurable_of_tendsto_metrizable_ae atTop hf h_ae_tendsto\n\n"}
{"name":"aemeasurable_of_unif_approx","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Metrizable","initialProofState":"Î± : Type u_1\ninstâœÂ³ : MeasurableSpace Î±\nÎ² : Type u_3\ninstâœÂ² : MeasurableSpace Î²\ninstâœÂ¹ : PseudoMetricSpace Î²\ninstâœ : BorelSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\ng : Î± â†’ Î²\nhf : âˆ€ (Îµ : Real), GT.gt Îµ 0 â†’ Exists fun f => And (AEMeasurable f Î¼) (Filter.Eventually (fun x => LE.le (Dist.dist (f x) (g x)) Îµ) (MeasureTheory.ae Î¼))\nâŠ¢ AEMeasurable g Î¼","decl":"theorem aemeasurable_of_unif_approx {Î²} [MeasurableSpace Î²] [PseudoMetricSpace Î²] [BorelSpace Î²]\n    {Î¼ : Measure Î±} {g : Î± â†’ Î²}\n    (hf : âˆ€ Îµ > (0 : â„), âˆƒ f : Î± â†’ Î², AEMeasurable f Î¼ âˆ§ âˆ€áµ x âˆ‚Î¼, dist (f x) (g x) â‰¤ Îµ) :\n    AEMeasurable g Î¼ := by\n  obtain âŸ¨u, -, u_pos, u_limâŸ© :\n    âˆƒ u : â„• â†’ â„, StrictAnti u âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Tendsto u atTop (ğ“ 0) :=\n    exists_seq_strictAnti_tendsto (0 : â„)\n  choose f Hf using fun n : â„• => hf (u n) (u_pos n)\n  have : âˆ€áµ x âˆ‚Î¼, Tendsto (fun n => f n x) atTop (ğ“ (g x)) := by\n    have : âˆ€áµ x âˆ‚Î¼, âˆ€ n, dist (f n x) (g x) â‰¤ u n := ae_all_iff.2 fun n => (Hf n).2\n    filter_upwards [this]\n    intro x hx\n    rw [tendsto_iff_dist_tendsto_zero]\n    exact squeeze_zero (fun n => dist_nonneg) hx u_lim\n  exact aemeasurable_of_tendsto_metrizable_ae' (fun n => (Hf n).1) this\n\n"}
{"name":"measurable_of_tendsto_metrizable_ae","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Metrizable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâµ : MeasurableSpace Î±\ninstâœâ´ : TopologicalSpace Î²\ninstâœÂ³ : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœÂ² : MeasurableSpace Î²\ninstâœÂ¹ : BorelSpace Î²\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : Î¼.IsComplete\nf : Nat â†’ Î± â†’ Î²\ng : Î± â†’ Î²\nhf : âˆ€ (n : Nat), Measurable (f n)\nh_ae_tendsto : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) (MeasureTheory.ae Î¼)\nâŠ¢ Measurable g","decl":"theorem measurable_of_tendsto_metrizable_ae {Î¼ : Measure Î±} [Î¼.IsComplete] {f : â„• â†’ Î± â†’ Î²}\n    {g : Î± â†’ Î²} (hf : âˆ€ n, Measurable (f n))\n    (h_ae_tendsto : âˆ€áµ x âˆ‚Î¼, Tendsto (fun n => f n x) atTop (ğ“ (g x))) : Measurable g :=\n  aemeasurable_iff_measurable.mp\n    (aemeasurable_of_tendsto_metrizable_ae' (fun i => (hf i).aemeasurable) h_ae_tendsto)\n\n"}
{"name":"measurable_limit_of_tendsto_metrizable_ae","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Metrizable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœâ· : MeasurableSpace Î±\ninstâœâ¶ : TopologicalSpace Î²\ninstâœâµ : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœâ´ : MeasurableSpace Î²\ninstâœÂ³ : BorelSpace Î²\nÎ¹ : Type u_3\ninstâœÂ² : Countable Î¹\ninstâœÂ¹ : Nonempty Î¹\nÎ¼ : MeasureTheory.Measure Î±\nf : Î¹ â†’ Î± â†’ Î²\nL : Filter Î¹\ninstâœ : L.IsCountablyGenerated\nhf : âˆ€ (n : Î¹), AEMeasurable (f n) Î¼\nh_ae_tendsto : Filter.Eventually (fun x => Exists fun l => Filter.Tendsto (fun n => f n x) L (nhds l)) (MeasureTheory.ae Î¼)\nâŠ¢ Exists fun f_lim => And (Measurable f_lim) (Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) L (nhds (f_lim x))) (MeasureTheory.ae Î¼))","decl":"theorem measurable_limit_of_tendsto_metrizable_ae {Î¹} [Countable Î¹] [Nonempty Î¹] {Î¼ : Measure Î±}\n    {f : Î¹ â†’ Î± â†’ Î²} {L : Filter Î¹} [L.IsCountablyGenerated] (hf : âˆ€ n, AEMeasurable (f n) Î¼)\n    (h_ae_tendsto : âˆ€áµ x âˆ‚Î¼, âˆƒ l : Î², Tendsto (fun n => f n x) L (ğ“ l)) :\n    âˆƒ f_lim : Î± â†’ Î², Measurable f_lim âˆ§ âˆ€áµ x âˆ‚Î¼, Tendsto (fun n => f n x) L (ğ“ (f_lim x)) := by\n  classical\n  inhabit Î¹\n  rcases eq_or_neBot L with (rfl | hL)\n  Â· exact âŸ¨(hf default).mk _, (hf default).measurable_mk, Eventually.of_forall fun x => tendsto_botâŸ©\n  let p : Î± â†’ (Î¹ â†’ Î²) â†’ Prop := fun x f' => âˆƒ l : Î², Tendsto (fun n => f' n) L (ğ“ l)\n  have hp_mem : âˆ€ x âˆˆ aeSeqSet hf p, p x fun n => f n x := fun x hx =>\n    aeSeq.fun_prop_of_mem_aeSeqSet hf hx\n  have h_ae_eq : âˆ€áµ x âˆ‚Î¼, âˆ€ n, aeSeq hf p n x = f n x := aeSeq.aeSeq_eq_fun_ae hf h_ae_tendsto\n  set f_lim : Î± â†’ Î² := fun x => dite (x âˆˆ aeSeqSet hf p) (fun h => (hp_mem x h).choose)\n    fun _ => (âŸ¨f default xâŸ© : Nonempty Î²).some\n  have hf_lim : âˆ€ x, Tendsto (fun n => aeSeq hf p n x) L (ğ“ (f_lim x)) := by\n    intro x\n    simp only [aeSeq, f_lim]\n    split_ifs with h\n    Â· refine (hp_mem x h).choose_spec.congr fun n => ?_\n      exact (aeSeq.mk_eq_fun_of_mem_aeSeqSet hf h n).symm\n    Â· exact tendsto_const_nhds\n  have h_ae_tendsto_f_lim : âˆ€áµ x âˆ‚Î¼, Tendsto (fun n => f n x) L (ğ“ (f_lim x)) :=\n    h_ae_eq.mono fun x hx => (hf_lim x).congr hx\n  have h_f_lim_meas : Measurable f_lim :=\n    measurable_of_tendsto_metrizable' L (aeSeq.measurable hf p)\n      (tendsto_pi_nhds.mpr fun x => hf_lim x)\n  exact âŸ¨f_lim, h_f_lim_meas, h_ae_tendsto_f_limâŸ©\n\n"}
{"name":"measurableSet_of_tendsto_indicator","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Metrizable","initialProofState":"Î± : Type u_3\ninstâœÂ² : MeasurableSpace Î±\nA : Set Î±\nÎ¹ : Type u_4\nL : Filter Î¹\ninstâœÂ¹ : L.IsCountablyGenerated\nAs : Î¹ â†’ Set Î±\ninstâœ : L.NeBot\nAs_mble : âˆ€ (i : Î¹), MeasurableSet (As i)\nh_lim : âˆ€ (x : Î±), Filter.Eventually (fun i => Iff (Membership.mem (As i) x) (Membership.mem A x)) L\nâŠ¢ MeasurableSet A","decl":"/-- If the indicator functions of measurable sets `Aáµ¢` converge to the indicator function of\na set `A` along a nontrivial countably generated filter, then `A` is also measurable. -/\nlemma measurableSet_of_tendsto_indicator [NeBot L] (As_mble : âˆ€ i, MeasurableSet (As i))\n    (h_lim : âˆ€ x, âˆ€á¶  i in L, x âˆˆ As i â†” x âˆˆ A) :\n    MeasurableSet A := by\n  simp_rw [â† measurable_indicator_const_iff (1 : â„â‰¥0âˆ)] at As_mble âŠ¢\n  exact ENNReal.measurable_of_tendsto' L As_mble\n    ((tendsto_indicator_const_iff_forall_eventually L (1 : â„â‰¥0âˆ)).mpr h_lim)\n\n"}
{"name":"nullMeasurableSet_of_tendsto_indicator","module":"Mathlib.MeasureTheory.Constructions.BorelSpace.Metrizable","initialProofState":"Î± : Type u_3\ninstâœÂ² : MeasurableSpace Î±\nA : Set Î±\nÎ¹ : Type u_4\nL : Filter Î¹\ninstâœÂ¹ : L.IsCountablyGenerated\nAs : Î¹ â†’ Set Î±\ninstâœ : L.NeBot\nÎ¼ : MeasureTheory.Measure Î±\nAs_mble : âˆ€ (i : Î¹), MeasureTheory.NullMeasurableSet (As i) Î¼\nh_lim : Filter.Eventually (fun x => Filter.Eventually (fun i => Iff (Membership.mem (As i) x) (Membership.mem A x)) L) (MeasureTheory.ae Î¼)\nâŠ¢ MeasureTheory.NullMeasurableSet A Î¼","decl":"/-- If the indicator functions of a.e.-measurable sets `Aáµ¢` converge a.e. to the indicator function\nof a set `A` along a nontrivial countably generated filter, then `A` is also a.e.-measurable. -/\nlemma nullMeasurableSet_of_tendsto_indicator [NeBot L] {Î¼ : Measure Î±}\n    (As_mble : âˆ€ i, NullMeasurableSet (As i) Î¼)\n    (h_lim : âˆ€áµ x âˆ‚Î¼, âˆ€á¶  i in L, x âˆˆ As i â†” x âˆˆ A) :\n    NullMeasurableSet A Î¼ := by\n  simp_rw [â† aemeasurable_indicator_const_iff (1 : â„â‰¥0âˆ)] at As_mble âŠ¢\n  apply aemeasurable_of_tendsto_metrizable_ae L As_mble\n  simpa [tendsto_indicator_const_apply_iff_eventually] using h_lim\n\n"}
