{"name":"CategoryTheory.Functor.chosenProd_obj","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF₁ F₂ : CategoryTheory.Functor J C\nj : J\n⊢ Eq ((F₁.chosenProd F₂).obj j) (CategoryTheory.MonoidalCategoryStruct.tensorObj (F₁.obj j) (F₂.obj j))","decl":"/-- The chosen binary product on `J ⥤ C`. -/\n@[simps]\ndef chosenProd : J ⥤ C where\n  obj j := F₁.obj j ⊗ F₂.obj j\n  map φ := F₁.map φ ⊗ F₂.map φ\n\n"}
{"name":"CategoryTheory.Functor.chosenProd_map","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF₁ F₂ : CategoryTheory.Functor J C\nX✝ Y✝ : J\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq ((F₁.chosenProd F₂).map φ) (CategoryTheory.MonoidalCategoryStruct.tensorHom (F₁.map φ) (F₂.map φ))","decl":"/-- The chosen binary product on `J ⥤ C`. -/\n@[simps]\ndef chosenProd : J ⥤ C where\n  obj j := F₁.obj j ⊗ F₂.obj j\n  map φ := F₁.map φ ⊗ F₂.map φ\n\n"}
{"name":"CategoryTheory.Functor.chosenProd.fst_app","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF₁ F₂ : CategoryTheory.Functor J C\nx✝ : J\n⊢ Eq ((CategoryTheory.Functor.chosenProd.fst F₁ F₂).app x✝) (CategoryTheory.ChosenFiniteProducts.fst (F₁.obj x✝) (F₂.obj x✝))","decl":"/-- The first projection `chosenProd F₁ F₂ ⟶ F₁`. -/\n@[simps]\ndef fst : chosenProd F₁ F₂ ⟶ F₁ where\n  app _ := ChosenFiniteProducts.fst _ _\n\n"}
{"name":"CategoryTheory.Functor.chosenProd.snd_app","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF₁ F₂ : CategoryTheory.Functor J C\nx✝ : J\n⊢ Eq ((CategoryTheory.Functor.chosenProd.snd F₁ F₂).app x✝) (CategoryTheory.ChosenFiniteProducts.snd (F₁.obj x✝) (F₂.obj x✝))","decl":"/-- The second projection `chosenProd F₁ F₂ ⟶ F₂`. -/\n@[simps]\ndef snd : chosenProd F₁ F₂ ⟶ F₂ where\n  app _ := ChosenFiniteProducts.snd _ _\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.leftUnitor_hom_app","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF : CategoryTheory.Functor J C\nj : J\n⊢ Eq ((CategoryTheory.MonoidalCategoryStruct.leftUnitor F).hom.app j) (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj j)).hom","decl":"@[simp]\nlemma leftUnitor_hom_app (F : J ⥤ C) (j : J) :\n    (λ_ F).hom.app j = (λ_ (F.obj j)).hom := rfl\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.leftUnitor_inv_app","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF : CategoryTheory.Functor J C\nj : J\n⊢ Eq ((CategoryTheory.MonoidalCategoryStruct.leftUnitor F).inv.app j) (CategoryTheory.MonoidalCategoryStruct.leftUnitor (F.obj j)).inv","decl":"@[simp]\nlemma leftUnitor_inv_app (F : J ⥤ C) (j : J) :\n    (λ_ F).inv.app j = (λ_ (F.obj j)).inv := by\n  rw [← cancel_mono ((λ_ (F.obj j)).hom), Iso.inv_hom_id, ← leftUnitor_hom_app,\n    Iso.inv_hom_id_app]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.rightUnitor_hom_app","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF : CategoryTheory.Functor J C\nj : J\n⊢ Eq ((CategoryTheory.MonoidalCategoryStruct.rightUnitor F).hom.app j) (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj j)).hom","decl":"@[simp]\nlemma rightUnitor_hom_app (F : J ⥤ C) (j : J) :\n    (ρ_ F).hom.app j = (ρ_ (F.obj j)).hom := rfl\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.rightUnitor_inv_app","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF : CategoryTheory.Functor J C\nj : J\n⊢ Eq ((CategoryTheory.MonoidalCategoryStruct.rightUnitor F).inv.app j) (CategoryTheory.MonoidalCategoryStruct.rightUnitor (F.obj j)).inv","decl":"@[simp]\nlemma rightUnitor_inv_app (F : J ⥤ C) (j : J) :\n    (ρ_ F).inv.app j = (ρ_ (F.obj j)).inv := by\n  rw [← cancel_mono ((ρ_ (F.obj j)).hom), Iso.inv_hom_id, ← rightUnitor_hom_app,\n    Iso.inv_hom_id_app]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.tensorHom_app_fst_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF₁ F₁' F₂ F₂' : CategoryTheory.Functor J C\nf : Quiver.Hom F₁ F₁'\ng : Quiver.Hom F₂ F₂'\nj : J\nZ : C\nh : Quiver.Hom (F₁'.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.MonoidalCategoryStruct.tensorHom f g).app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst (F₁'.obj j) (F₂'.obj j)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst (F₁.obj j) (F₂.obj j)) (CategoryTheory.CategoryStruct.comp (f.app j) h))","decl":"@[reassoc (attr := simp)]\nlemma tensorHom_app_fst {F₁ F₁' F₂ F₂' : J ⥤ C} (f : F₁ ⟶ F₁') (g : F₂ ⟶ F₂') (j : J) :\n    (f ⊗ g).app j ≫ fst _ _ = fst _ _ ≫ f.app j := by\n  change (f ⊗ g).app j ≫ (fst F₁' F₂').app j = _\n  rw [← NatTrans.comp_app, tensorHom_fst, NatTrans.comp_app]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.tensorHom_app_fst","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF₁ F₁' F₂ F₂' : CategoryTheory.Functor J C\nf : Quiver.Hom F₁ F₁'\ng : Quiver.Hom F₂ F₂'\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.MonoidalCategoryStruct.tensorHom f g).app j) (CategoryTheory.ChosenFiniteProducts.fst (F₁'.obj j) (F₂'.obj j))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst (F₁.obj j) (F₂.obj j)) (f.app j))","decl":"@[reassoc (attr := simp)]\nlemma tensorHom_app_fst {F₁ F₁' F₂ F₂' : J ⥤ C} (f : F₁ ⟶ F₁') (g : F₂ ⟶ F₂') (j : J) :\n    (f ⊗ g).app j ≫ fst _ _ = fst _ _ ≫ f.app j := by\n  change (f ⊗ g).app j ≫ (fst F₁' F₂').app j = _\n  rw [← NatTrans.comp_app, tensorHom_fst, NatTrans.comp_app]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.tensorHom_app_snd_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF₁ F₁' F₂ F₂' : CategoryTheory.Functor J C\nf : Quiver.Hom F₁ F₁'\ng : Quiver.Hom F₂ F₂'\nj : J\nZ : C\nh : Quiver.Hom (F₂'.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.MonoidalCategoryStruct.tensorHom f g).app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd (F₁'.obj j) (F₂'.obj j)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd (F₁.obj j) (F₂.obj j)) (CategoryTheory.CategoryStruct.comp (g.app j) h))","decl":"@[reassoc (attr := simp)]\nlemma tensorHom_app_snd {F₁ F₁' F₂ F₂' : J ⥤ C} (f : F₁ ⟶ F₁') (g : F₂ ⟶ F₂') (j : J) :\n    (f ⊗ g).app j ≫ snd _ _ = snd _ _ ≫ g.app j := by\n  change (f ⊗ g).app j ≫ (snd F₁' F₂').app j = _\n  rw [← NatTrans.comp_app, tensorHom_snd, NatTrans.comp_app]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.tensorHom_app_snd","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF₁ F₁' F₂ F₂' : CategoryTheory.Functor J C\nf : Quiver.Hom F₁ F₁'\ng : Quiver.Hom F₂ F₂'\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.MonoidalCategoryStruct.tensorHom f g).app j) (CategoryTheory.ChosenFiniteProducts.snd (F₁'.obj j) (F₂'.obj j))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd (F₁.obj j) (F₂.obj j)) (g.app j))","decl":"@[reassoc (attr := simp)]\nlemma tensorHom_app_snd {F₁ F₁' F₂ F₂' : J ⥤ C} (f : F₁ ⟶ F₁') (g : F₂ ⟶ F₂') (j : J) :\n    (f ⊗ g).app j ≫ snd _ _ = snd _ _ ≫ g.app j := by\n  change (f ⊗ g).app j ≫ (snd F₁' F₂').app j = _\n  rw [← NatTrans.comp_app, tensorHom_snd, NatTrans.comp_app]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerLeft_app_fst_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF₁ F₂ F₂' : CategoryTheory.Functor J C\ng : Quiver.Hom F₂ F₂'\nj : J\nZ : C\nh : Quiver.Hom (F₁.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.MonoidalCategoryStruct.whiskerLeft F₁ g).app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst (F₁.obj j) (F₂'.obj j)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst (F₁.obj j) (F₂.obj j)) h)","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_app_fst (F₁ : J ⥤ C) {F₂ F₂' : J ⥤ C} (g : F₂ ⟶ F₂') (j : J) :\n    (F₁ ◁ g).app j ≫ fst _ _ = fst _ _ :=\n  (tensorHom_app_fst (𝟙 F₁) g j).trans (by simp)\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerLeft_app_fst","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF₁ F₂ F₂' : CategoryTheory.Functor J C\ng : Quiver.Hom F₂ F₂'\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.MonoidalCategoryStruct.whiskerLeft F₁ g).app j) (CategoryTheory.ChosenFiniteProducts.fst (F₁.obj j) (F₂'.obj j))) (CategoryTheory.ChosenFiniteProducts.fst (F₁.obj j) (F₂.obj j))","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_app_fst (F₁ : J ⥤ C) {F₂ F₂' : J ⥤ C} (g : F₂ ⟶ F₂') (j : J) :\n    (F₁ ◁ g).app j ≫ fst _ _ = fst _ _ :=\n  (tensorHom_app_fst (𝟙 F₁) g j).trans (by simp)\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerLeft_app_snd","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF₁ F₂ F₂' : CategoryTheory.Functor J C\ng : Quiver.Hom F₂ F₂'\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.MonoidalCategoryStruct.whiskerLeft F₁ g).app j) (CategoryTheory.ChosenFiniteProducts.snd (F₁.obj j) (F₂'.obj j))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd (F₁.obj j) (F₂.obj j)) (g.app j))","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_app_snd (F₁ : J ⥤ C) {F₂ F₂' : J ⥤ C} (g : F₂ ⟶ F₂') (j : J) :\n    (F₁ ◁ g).app j ≫ snd _ _ = snd _ _ ≫ g.app j :=\n  (tensorHom_app_snd (𝟙 F₁) g j)\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerLeft_app_snd_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF₁ F₂ F₂' : CategoryTheory.Functor J C\ng : Quiver.Hom F₂ F₂'\nj : J\nZ : C\nh : Quiver.Hom (F₂'.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.MonoidalCategoryStruct.whiskerLeft F₁ g).app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd (F₁.obj j) (F₂'.obj j)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd (F₁.obj j) (F₂.obj j)) (CategoryTheory.CategoryStruct.comp (g.app j) h))","decl":"@[reassoc (attr := simp)]\nlemma whiskerLeft_app_snd (F₁ : J ⥤ C) {F₂ F₂' : J ⥤ C} (g : F₂ ⟶ F₂') (j : J) :\n    (F₁ ◁ g).app j ≫ snd _ _ = snd _ _ ≫ g.app j :=\n  (tensorHom_app_snd (𝟙 F₁) g j)\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerRight_app_fst","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF₁ F₁' : CategoryTheory.Functor J C\nf : Quiver.Hom F₁ F₁'\nF₂ : CategoryTheory.Functor J C\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.MonoidalCategoryStruct.whiskerRight f F₂).app j) (CategoryTheory.ChosenFiniteProducts.fst (F₁'.obj j) (F₂.obj j))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst (F₁.obj j) (F₂.obj j)) (f.app j))","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_app_fst {F₁ F₁' : J ⥤ C} (f : F₁ ⟶ F₁') (F₂ : J ⥤ C) (j : J) :\n    (f ▷ F₂).app j ≫ fst _ _ = fst _ _ ≫ f.app j :=\n  (tensorHom_app_fst f (𝟙 F₂) j)\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerRight_app_fst_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF₁ F₁' : CategoryTheory.Functor J C\nf : Quiver.Hom F₁ F₁'\nF₂ : CategoryTheory.Functor J C\nj : J\nZ : C\nh : Quiver.Hom (F₁'.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.MonoidalCategoryStruct.whiskerRight f F₂).app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst (F₁'.obj j) (F₂.obj j)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.fst (F₁.obj j) (F₂.obj j)) (CategoryTheory.CategoryStruct.comp (f.app j) h))","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_app_fst {F₁ F₁' : J ⥤ C} (f : F₁ ⟶ F₁') (F₂ : J ⥤ C) (j : J) :\n    (f ▷ F₂).app j ≫ fst _ _ = fst _ _ ≫ f.app j :=\n  (tensorHom_app_fst f (𝟙 F₂) j)\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerRight_app_snd","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF₁ F₁' : CategoryTheory.Functor J C\nf : Quiver.Hom F₁ F₁'\nF₂ : CategoryTheory.Functor J C\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.MonoidalCategoryStruct.whiskerRight f F₂).app j) (CategoryTheory.ChosenFiniteProducts.snd (F₁'.obj j) (F₂.obj j))) (CategoryTheory.ChosenFiniteProducts.snd (F₁.obj j) (F₂.obj j))","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_app_snd {F₁ F₁' : J ⥤ C} (f : F₁ ⟶ F₁') (F₂ : J ⥤ C) (j : J) :\n    (f ▷ F₂).app j ≫ snd _ _ = snd _ _ :=\n  (tensorHom_app_snd f (𝟙 F₂) j).trans (by simp)\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.whiskerRight_app_snd_assoc","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF₁ F₁' : CategoryTheory.Functor J C\nf : Quiver.Hom F₁ F₁'\nF₂ : CategoryTheory.Functor J C\nj : J\nZ : C\nh : Quiver.Hom (F₂.obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.MonoidalCategoryStruct.whiskerRight f F₂).app j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd (F₁'.obj j) (F₂.obj j)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ChosenFiniteProducts.snd (F₁.obj j) (F₂.obj j)) h)","decl":"@[reassoc (attr := simp)]\nlemma whiskerRight_app_snd {F₁ F₁' : J ⥤ C} (f : F₁ ⟶ F₁') (F₂ : J ⥤ C) (j : J) :\n    (f ▷ F₂).app j ≫ snd _ _ = snd _ _ :=\n  (tensorHom_app_snd f (𝟙 F₂) j).trans (by simp)\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.associator_hom_app","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF₁ F₂ F₃ : CategoryTheory.Functor J C\nj : J\n⊢ Eq ((CategoryTheory.MonoidalCategoryStruct.associator F₁ F₂ F₃).hom.app j) (CategoryTheory.MonoidalCategoryStruct.associator (F₁.obj j) (F₂.obj j) (F₃.obj j)).hom","decl":"@[simp]\nlemma associator_hom_app (F₁ F₂ F₃ : J ⥤ C) (j : J) :\n    (α_ F₁ F₂ F₃).hom.app j = (α_ _ _ _).hom := by\n  apply hom_ext\n  · change _ ≫ (fst F₁ (F₂ ⊗ F₃)).app j = _\n    rw [← NatTrans.comp_app, associator_hom_fst]\n    erw [associator_hom_fst]\n    rfl\n  · apply hom_ext\n    · change (_ ≫ (snd F₁ (F₂ ⊗ F₃)).app j) ≫ (fst F₂ F₃).app j = _\n      rw [← NatTrans.comp_app, ← NatTrans.comp_app, assoc, associator_hom_snd_fst, assoc]\n      erw [associator_hom_snd_fst]\n      rfl\n    · change (_ ≫ (snd F₁ (F₂ ⊗ F₃)).app j) ≫ (snd F₂ F₃).app j = _\n      rw [← NatTrans.comp_app, ← NatTrans.comp_app, assoc, associator_hom_snd_snd, assoc]\n      erw [associator_hom_snd_snd]\n      rfl\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.associator_inv_app","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_1} J\ninst✝¹ : CategoryTheory.Category.{u_4, u_2} C\ninst✝ : CategoryTheory.ChosenFiniteProducts C\nF₁ F₂ F₃ : CategoryTheory.Functor J C\nj : J\n⊢ Eq ((CategoryTheory.MonoidalCategoryStruct.associator F₁ F₂ F₃).inv.app j) (CategoryTheory.MonoidalCategoryStruct.associator (F₁.obj j) (F₂.obj j) (F₃.obj j)).inv","decl":"@[simp]\nlemma associator_inv_app (F₁ F₂ F₃ : J ⥤ C) (j : J) :\n    (α_ F₁ F₂ F₃).inv.app j = (α_ _ _ _).inv := by\n  rw [← cancel_mono ((α_ _ _ _).hom), Iso.inv_hom_id, ← associator_hom_app, Iso.inv_hom_id_app]\n\n"}
{"name":"CategoryTheory.Functor.Monoidal.instPreservesColimitsOfShapeTensorLeftOfHasColimitsOfShape","module":"Mathlib.CategoryTheory.ChosenFiniteProducts.FunctorCategory","initialProofState":"J : Type u_1\nC : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_6, u_1} J\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} C\ninst✝³ : CategoryTheory.ChosenFiniteProducts C\nK : Type u_3\ninst✝² : CategoryTheory.Category.{u_4, u_3} K\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape K C\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfShape K (CategoryTheory.MonoidalCategory.tensorLeft X)\nF : CategoryTheory.Functor J C\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape K (CategoryTheory.MonoidalCategory.tensorLeft F)","decl":"noncomputable instance {K : Type*} [Category K] [HasColimitsOfShape K C]\n    [∀ X : C, PreservesColimitsOfShape K (tensorLeft X)] {F : J ⥤ C} :\n    PreservesColimitsOfShape K (tensorLeft F) := by\n  apply preservesColimitsOfShape_of_evaluation\n  intro k\n  haveI : tensorLeft F ⋙ (evaluation J C).obj k ≅ (evaluation J C).obj k ⋙ tensorLeft (F.obj k) :=\n    NatIso.ofComponents (fun _ ↦ Iso.refl _)\n  exact preservesColimitsOfShape_of_natIso this.symm\n\n"}
