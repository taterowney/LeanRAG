{"name":"iteratedDerivWithin_congr","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nn : Nat\ns : Set ð•œ\nf g : ð•œ â†’ F\nhfg : Set.EqOn f g s\nâŠ¢ Set.EqOn (iteratedDerivWithin n f s) (iteratedDerivWithin n g s) s","decl":"theorem iteratedDerivWithin_congr (hfg : Set.EqOn f g s) :\n    Set.EqOn (iteratedDerivWithin n f s) (iteratedDerivWithin n g s) s := by\n  induction n generalizing f g with\n  | zero => rwa [iteratedDerivWithin_zero]\n  | succ n IH =>\n    intro y hy\n    rw [iteratedDerivWithin_succ, iteratedDerivWithin_succ]\n    exact derivWithin_congr (IH hfg) (IH hfg hy)\n\n"}
{"name":"iteratedDerivWithin_add","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nn : Nat\nx : ð•œ\ns : Set ð•œ\nhx : Membership.mem s x\nh : UniqueDiffOn ð•œ s\nf g : ð•œ â†’ F\nhf : ContDiffOn ð•œ (â†‘n) f s\nhg : ContDiffOn ð•œ (â†‘n) g s\nâŠ¢ Eq (iteratedDerivWithin n (HAdd.hAdd f g) s x) (HAdd.hAdd (iteratedDerivWithin n f s x) (iteratedDerivWithin n g s x))","decl":"include h hx in\ntheorem iteratedDerivWithin_add (hf : ContDiffOn ð•œ n f s) (hg : ContDiffOn ð•œ n g s) :\n    iteratedDerivWithin n (f + g) s x =\n      iteratedDerivWithin n f s x + iteratedDerivWithin n g s x := by\n  simp_rw [iteratedDerivWithin, iteratedFDerivWithin_add_apply hf hg h hx,\n    ContinuousMultilinearMap.add_apply]\n\n"}
{"name":"iteratedDerivWithin_const_add","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nn : Nat\nx : ð•œ\ns : Set ð•œ\nf : ð•œ â†’ F\nhn : LT.lt 0 n\nc : F\nâŠ¢ Eq (iteratedDerivWithin n (fun z => HAdd.hAdd c (f z)) s x) (iteratedDerivWithin n f s x)","decl":"theorem iteratedDerivWithin_const_add (hn : 0 < n) (c : F) :\n    iteratedDerivWithin n (fun z => c + f z) s x = iteratedDerivWithin n f s x := by\n  obtain âŸ¨n, rflâŸ© := n.exists_eq_succ_of_ne_zero hn.ne'\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs; swap\n  Â· simp [iteratedDerivWithin_succ, derivWithin_zero_of_isolated hxs]\n  rw [iteratedDerivWithin_succ', iteratedDerivWithin_succ']\n  congr with y\n  exact derivWithin_const_add _\n\n"}
{"name":"iteratedDerivWithin_const_sub","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nn : Nat\nx : ð•œ\ns : Set ð•œ\nf : ð•œ â†’ F\nhn : LT.lt 0 n\nc : F\nâŠ¢ Eq (iteratedDerivWithin n (fun z => HSub.hSub c (f z)) s x) (iteratedDerivWithin n (fun z => Neg.neg (f z)) s x)","decl":"theorem iteratedDerivWithin_const_sub (hn : 0 < n) (c : F) :\n    iteratedDerivWithin n (fun z => c - f z) s x = iteratedDerivWithin n (fun z => -f z) s x := by\n  obtain âŸ¨n, rflâŸ© := n.exists_eq_succ_of_ne_zero hn.ne'\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs; swap\n  Â· simp [iteratedDerivWithin_succ, derivWithin_zero_of_isolated hxs]\n  rw [iteratedDerivWithin_succ', iteratedDerivWithin_succ']\n  congr with y\n  rw [derivWithin.neg]\n  exact derivWithin_const_sub _\n\n"}
{"name":"iteratedDerivWithin_const_neg","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nn : Nat\nx : ð•œ\ns : Set ð•œ\nf : ð•œ â†’ F\nhn : LT.lt 0 n\nc : F\nâŠ¢ Eq (iteratedDerivWithin n (fun z => HSub.hSub c (f z)) s x) (iteratedDerivWithin n (fun z => Neg.neg (f z)) s x)","decl":"@[deprecated (since := \"2024-12-10\")]\nalias iteratedDerivWithin_const_neg := iteratedDerivWithin_const_sub\n\n"}
{"name":"iteratedDerivWithin_const_smul","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ð•œ\nF : Type u_2\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ð•œ F\nR : Type u_3\ninstâœÂ³ : Semiring R\ninstâœÂ² : Module R F\ninstâœÂ¹ : SMulCommClass ð•œ R F\ninstâœ : ContinuousConstSMul R F\nn : Nat\nx : ð•œ\ns : Set ð•œ\nhx : Membership.mem s x\nh : UniqueDiffOn ð•œ s\nf : ð•œ â†’ F\nc : R\nhf : ContDiffWithinAt ð•œ (â†‘n) f s x\nâŠ¢ Eq (iteratedDerivWithin n (HSMul.hSMul c f) s x) (HSMul.hSMul c (iteratedDerivWithin n f s x))","decl":"include h hx in\ntheorem iteratedDerivWithin_const_smul (c : R) (hf : ContDiffWithinAt ð•œ n f s x) :\n    iteratedDerivWithin n (c â€¢ f) s x = c â€¢ iteratedDerivWithin n f s x := by\n  simp_rw [iteratedDerivWithin]\n  rw [iteratedFDerivWithin_const_smul_apply hf h hx]\n  simp only [ContinuousMultilinearMap.smul_apply]\n\n"}
{"name":"iteratedDerivWithin_const_mul","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœ : NontriviallyNormedField ð•œ\nn : Nat\nx : ð•œ\ns : Set ð•œ\nhx : Membership.mem s x\nh : UniqueDiffOn ð•œ s\nc : ð•œ\nf : ð•œ â†’ ð•œ\nhf : ContDiffWithinAt ð•œ (â†‘n) f s x\nâŠ¢ Eq (iteratedDerivWithin n (fun z => HMul.hMul c (f z)) s x) (HMul.hMul c (iteratedDerivWithin n f s x))","decl":"include h hx in\ntheorem iteratedDerivWithin_const_mul (c : ð•œ) {f : ð•œ â†’ ð•œ} (hf : ContDiffWithinAt ð•œ n f s x) :\n    iteratedDerivWithin n (fun z => c * f z) s x = c * iteratedDerivWithin n f s x := by\n  simpa using iteratedDerivWithin_const_smul (F := ð•œ) hx h c hf\n\n"}
{"name":"iteratedDerivWithin_neg","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nn : Nat\nx : ð•œ\ns : Set ð•œ\nf : ð•œ â†’ F\nâŠ¢ Eq (iteratedDerivWithin n (Neg.neg f) s x) (Neg.neg (iteratedDerivWithin n f s x))","decl":"variable (f) in\nomit h hx in\ntheorem iteratedDerivWithin_neg :\n    iteratedDerivWithin n (-f) s x = -iteratedDerivWithin n f s x := by\n  induction n generalizing x with\n  | zero => simp\n  | succ n IH =>\n    simp only [iteratedDerivWithin_succ, derivWithin_neg]\n    rw [â† derivWithin.neg]\n    congr with y\n    exact IH\n\n"}
{"name":"iteratedDerivWithin_neg'","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nn : Nat\nx : ð•œ\ns : Set ð•œ\nf : ð•œ â†’ F\nâŠ¢ Eq (iteratedDerivWithin n (fun z => Neg.neg (f z)) s x) (Neg.neg (iteratedDerivWithin n f s x))","decl":"variable (f) in\ntheorem iteratedDerivWithin_neg' :\n    iteratedDerivWithin n (fun z => -f z) s x = -iteratedDerivWithin n f s x :=\n  iteratedDerivWithin_neg f\n\n"}
{"name":"iteratedDerivWithin_sub","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nn : Nat\nx : ð•œ\ns : Set ð•œ\nhx : Membership.mem s x\nh : UniqueDiffOn ð•œ s\nf g : ð•œ â†’ F\nhf : ContDiffOn ð•œ (â†‘n) f s\nhg : ContDiffOn ð•œ (â†‘n) g s\nâŠ¢ Eq (iteratedDerivWithin n (HSub.hSub f g) s x) (HSub.hSub (iteratedDerivWithin n f s x) (iteratedDerivWithin n g s x))","decl":"theorem iteratedDerivWithin_sub (hf : ContDiffOn ð•œ n f s) (hg : ContDiffOn ð•œ n g s) :\n    iteratedDerivWithin n (f - g) s x =\n      iteratedDerivWithin n f s x - iteratedDerivWithin n g s x := by\n  rw [sub_eq_add_neg, sub_eq_add_neg, Pi.neg_def, iteratedDerivWithin_add hx h hf hg.neg,\n    iteratedDerivWithin_neg']\n\n"}
{"name":"iteratedDerivWithin_comp_const_smul","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nn : Nat\nx : ð•œ\ns : Set ð•œ\nhx : Membership.mem s x\nh : UniqueDiffOn ð•œ s\nf : ð•œ â†’ F\nhf : ContDiffOn ð•œ (â†‘n) f s\nc : ð•œ\nhs : Set.MapsTo (fun x => HMul.hMul c x) s s\nâŠ¢ Eq (iteratedDerivWithin n (fun x => f (HMul.hMul c x)) s x) (HSMul.hSMul (HPow.hPow c n) (iteratedDerivWithin n f s (HMul.hMul c x)))","decl":"theorem iteratedDerivWithin_comp_const_smul (hf : ContDiffOn ð•œ n f s) (c : ð•œ)\n    (hs : Set.MapsTo (c * Â·) s s) :\n    iteratedDerivWithin n (fun x => f (c * x)) s x = c ^ n â€¢ iteratedDerivWithin n f s (c * x) := by\n  induction n generalizing x with\n  | zero => simp\n  | succ n ih =>\n    have hcx : c * x âˆˆ s := hs hx\n    have hâ‚€ : s.EqOn\n        (iteratedDerivWithin n (fun x â†¦ f (c * x)) s)\n        (fun x => c ^ n â€¢ iteratedDerivWithin n f s (c * x)) :=\n      fun x hx => ih hx hf.of_succ\n    have hâ‚ : DifferentiableWithinAt ð•œ (iteratedDerivWithin n f s) s (c * x) :=\n      hf.differentiableOn_iteratedDerivWithin (Nat.cast_lt.mpr n.lt_succ_self) h _ hcx\n    have hâ‚‚ : DifferentiableWithinAt ð•œ (fun x => iteratedDerivWithin n f s (c * x)) s x := by\n      rw [â† Function.comp_def]\n      apply DifferentiableWithinAt.comp\n      Â· exact hf.differentiableOn_iteratedDerivWithin (Nat.cast_lt.mpr n.lt_succ_self) h _ hcx\n      Â· exact differentiableWithinAt_id'.const_mul _\n      Â· exact hs\n    rw [iteratedDerivWithin_succ, derivWithin_congr hâ‚€ (ih hx hf.of_succ),\n      derivWithin_const_smul (c ^ n) hâ‚‚, iteratedDerivWithin_succ,\n      â† Function.comp_def,\n      derivWithin.scomp x hâ‚ (differentiableWithinAt_id'.const_mul _) hs,\n      derivWithin_const_mul _ differentiableWithinAt_id', derivWithin_id' _ _ (h _ hx),\n      smul_smul, mul_one, pow_succ]\n\n"}
{"name":"iteratedDeriv_add","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nn : Nat\nx : ð•œ\nf g : ð•œ â†’ F\nhf : ContDiff ð•œ (â†‘n) f\nhg : ContDiff ð•œ (â†‘n) g\nâŠ¢ Eq (iteratedDeriv n (HAdd.hAdd f g) x) (HAdd.hAdd (iteratedDeriv n f x) (iteratedDeriv n g x))","decl":"lemma iteratedDeriv_add (hf : ContDiff ð•œ n f) (hg : ContDiff ð•œ n g) :\n    iteratedDeriv n (f + g) x = iteratedDeriv n f x + iteratedDeriv n g x := by\n  simpa only [iteratedDerivWithin_univ] using\n    iteratedDerivWithin_add (Set.mem_univ _) uniqueDiffOn_univ\n      (contDiffOn_univ.mpr hf) (contDiffOn_univ.mpr hg)\n\n"}
{"name":"iteratedDeriv_const_add","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nn : Nat\nx : ð•œ\nf : ð•œ â†’ F\nhn : LT.lt 0 n\nc : F\nâŠ¢ Eq (iteratedDeriv n (fun z => HAdd.hAdd c (f z)) x) (iteratedDeriv n f x)","decl":"theorem iteratedDeriv_const_add (hn : 0 < n) (c : F) :\n    iteratedDeriv n (fun z => c + f z) x = iteratedDeriv n f x := by\n  simpa only [â† iteratedDerivWithin_univ] using iteratedDerivWithin_const_add hn c\n\n"}
{"name":"iteratedDeriv_const_sub","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nn : Nat\nx : ð•œ\nf : ð•œ â†’ F\nhn : LT.lt 0 n\nc : F\nâŠ¢ Eq (iteratedDeriv n (fun z => HSub.hSub c (f z)) x) (iteratedDeriv n (Neg.neg f) x)","decl":"theorem iteratedDeriv_const_sub (hn : 0 < n) (c : F) :\n    iteratedDeriv n (fun z => c - f z) x = iteratedDeriv n (-f) x := by\n  simpa only [â† iteratedDerivWithin_univ] using iteratedDerivWithin_const_sub hn c\n\n"}
{"name":"iteratedDeriv_neg","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nn : Nat\nf : ð•œ â†’ F\na : ð•œ\nâŠ¢ Eq (iteratedDeriv n (fun x => Neg.neg (f x)) a) (Neg.neg (iteratedDeriv n f a))","decl":"lemma iteratedDeriv_neg (n : â„•) (f : ð•œ â†’ F) (a : ð•œ) :\n    iteratedDeriv n (fun x â†¦ -(f x)) a = -(iteratedDeriv n f a) := by\n  simpa only [â† iteratedDerivWithin_univ] using iteratedDerivWithin_neg f\n\n"}
{"name":"iteratedDeriv_sub","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nn : Nat\nx : ð•œ\nf g : ð•œ â†’ F\nhf : ContDiff ð•œ (â†‘n) f\nhg : ContDiff ð•œ (â†‘n) g\nâŠ¢ Eq (iteratedDeriv n (HSub.hSub f g) x) (HSub.hSub (iteratedDeriv n f x) (iteratedDeriv n g x))","decl":"lemma iteratedDeriv_sub (hf : ContDiff ð•œ n f) (hg : ContDiff ð•œ n g) :\n    iteratedDeriv n (f - g) x = iteratedDeriv n f x - iteratedDeriv n g x := by\n  simpa only [iteratedDerivWithin_univ] using\n    iteratedDerivWithin_sub (Set.mem_univ _) uniqueDiffOn_univ\n      (contDiffOn_univ.mpr hf) (contDiffOn_univ.mpr hg)\n\n"}
{"name":"iteratedDeriv_const_smul","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nx : ð•œ\nn : Nat\nf : ð•œ â†’ F\nh : ContDiffAt ð•œ (â†‘n) f x\nc : ð•œ\nâŠ¢ Eq (iteratedDeriv n (HSMul.hSMul c f) x) (HSMul.hSMul c (iteratedDeriv n f x))","decl":"theorem iteratedDeriv_const_smul {n : â„•} {f : ð•œ â†’ F} (h : ContDiffAt ð•œ n f x) (c : ð•œ) :\n    iteratedDeriv n (c â€¢ f) x = c â€¢ iteratedDeriv n f x := by\n  simpa only [iteratedDerivWithin_univ] using\n    iteratedDerivWithin_const_smul (Set.mem_univ x) uniqueDiffOn_univ\n      c (contDiffWithinAt_univ.mpr h)\n\n"}
{"name":"iteratedDeriv_const_mul","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœ : NontriviallyNormedField ð•œ\nx : ð•œ\nn : Nat\nf : ð•œ â†’ ð•œ\nh : ContDiffAt ð•œ (â†‘n) f x\nc : ð•œ\nâŠ¢ Eq (iteratedDeriv n (fun z => HMul.hMul c (f z)) x) (HMul.hMul c (iteratedDeriv n f x))","decl":"theorem iteratedDeriv_const_mul {n : â„•} {f : ð•œ â†’ ð•œ} (h : ContDiffAt ð•œ n f x) (c : ð•œ) :\n    iteratedDeriv n (fun z => c * f z) x = c * iteratedDeriv n f x := by\n  simpa only [iteratedDerivWithin_univ] using\n    iteratedDerivWithin_const_mul (Set.mem_univ x) uniqueDiffOn_univ\n      c (contDiffWithinAt_univ.mpr h)\n\n"}
{"name":"iteratedDeriv_comp_const_smul","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nn : Nat\nf : ð•œ â†’ F\nh : ContDiff ð•œ (â†‘n) f\nc : ð•œ\nâŠ¢ Eq (iteratedDeriv n fun x => f (HMul.hMul c x)) fun x => HSMul.hSMul (HPow.hPow c n) (iteratedDeriv n f (HMul.hMul c x))","decl":"theorem iteratedDeriv_comp_const_smul {n : â„•} {f : ð•œ â†’ F} (h : ContDiff ð•œ n f) (c : ð•œ) :\n    iteratedDeriv n (fun x => f (c * x)) = fun x => c ^ n â€¢ iteratedDeriv n f (c * x) := by\n  funext x\n  simpa only [iteratedDerivWithin_univ] using\n    iteratedDerivWithin_comp_const_smul (Set.mem_univ x) uniqueDiffOn_univ (contDiffOn_univ.mpr h)\n      c (Set.mapsTo_univ _ _)\n\n"}
{"name":"iteratedDeriv_comp_const_mul","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœ : NontriviallyNormedField ð•œ\nn : Nat\nf : ð•œ â†’ ð•œ\nh : ContDiff ð•œ (â†‘n) f\nc : ð•œ\nâŠ¢ Eq (iteratedDeriv n fun x => f (HMul.hMul c x)) fun x => HMul.hMul (HPow.hPow c n) (iteratedDeriv n f (HMul.hMul c x))","decl":"theorem iteratedDeriv_comp_const_mul {n : â„•} {f : ð•œ â†’ ð•œ} (h : ContDiff ð•œ n f) (c : ð•œ) :\n    iteratedDeriv n (fun x => f (c * x)) = fun x => c ^ n * iteratedDeriv n f (c * x) := by\n  simpa only [smul_eq_mul] using iteratedDeriv_comp_const_smul h c\n\n"}
{"name":"iteratedDeriv_comp_neg","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nn : Nat\nf : ð•œ â†’ F\na : ð•œ\nâŠ¢ Eq (iteratedDeriv n (fun x => f (Neg.neg x)) a) (HSMul.hSMul (HPow.hPow (-1) n) (iteratedDeriv n f (Neg.neg a)))","decl":"lemma iteratedDeriv_comp_neg (n : â„•) (f : ð•œ â†’ F) (a : ð•œ) :\n    iteratedDeriv n (fun x â†¦ f (-x)) a = (-1 : ð•œ) ^ n â€¢ iteratedDeriv n f (-a) := by\n  induction' n with n ih generalizing a\n  Â· simp only [iteratedDeriv_zero, pow_zero, one_smul]\n  Â· have ih' : iteratedDeriv n (fun x â†¦ f (-x)) = fun x â†¦ (-1 : ð•œ) ^ n â€¢ iteratedDeriv n f (-x) :=\n      funext ih\n    rw [iteratedDeriv_succ, iteratedDeriv_succ, ih', pow_succ', neg_mul, one_mul,\n      deriv_comp_neg (f := fun x â†¦ (-1 : ð•œ) ^ n â€¢ iteratedDeriv n f x), deriv_const_smul',\n      neg_smul]\n\n"}
{"name":"Filter.EventuallyEq.iteratedDeriv_eq","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nn : Nat\nf g : ð•œ â†’ F\nx : ð•œ\nhfg : (nhds x).EventuallyEq f g\nâŠ¢ Eq (iteratedDeriv n f x) (iteratedDeriv n g x)","decl":"open Topology in\nlemma Filter.EventuallyEq.iteratedDeriv_eq (n : â„•) {f g : ð•œ â†’ F} {x : ð•œ} (hfg : f =á¶ [ð“ x] g) :\n    iteratedDeriv n f x = iteratedDeriv n g x := by\n  simp only [â† iteratedDerivWithin_univ, iteratedDerivWithin_eq_iteratedFDerivWithin]\n  rw [(hfg.filter_mono nhdsWithin_le_nhds).iteratedFDerivWithin_eq hfg.eq_of_nhds n]\n\n"}
{"name":"Set.EqOn.iteratedDeriv_of_isOpen","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ð•œ\nF : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\ns : Set ð•œ\nf g : ð•œ â†’ F\nhfg : Set.EqOn f g s\nhs : IsOpen s\nn : Nat\nâŠ¢ Set.EqOn (iteratedDeriv n f) (iteratedDeriv n g) s","decl":"lemma Set.EqOn.iteratedDeriv_of_isOpen (hfg : Set.EqOn f g s) (hs : IsOpen s) (n : â„•) :\n    Set.EqOn (iteratedDeriv n f) (iteratedDeriv n g) s := by\n  refine fun x hx â†¦ Filter.EventuallyEq.iteratedDeriv_eq n ?_\n  filter_upwards [IsOpen.mem_nhds hs hx] with a ha\n  exact hfg ha\n\n"}
{"name":"iteratedDeriv_comp_const_add","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\nF : Type u_2\ninstâœÂ² : NontriviallyNormedField ð•œ\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nn : Nat\nf : ð•œ â†’ F\ns : ð•œ\nâŠ¢ Eq (iteratedDeriv n fun z => f (HAdd.hAdd s z)) fun t => iteratedDeriv n f (HAdd.hAdd s t)","decl":"/-- The iterated derivative commutes with shifting the function by a constant on the left. -/\nlemma iteratedDeriv_comp_const_add (n : â„•) (f : ð•œ â†’ F) (s : ð•œ) :\n    iteratedDeriv n (fun z â†¦ f (s + z)) = fun t â†¦ iteratedDeriv n f (s + t) := by\n  induction n with\n  | zero => simp only [iteratedDeriv_zero]\n  | succ n IH =>\n    simpa only [iteratedDeriv_succ, IH] using funext <| deriv_comp_const_add _ s\n\n"}
{"name":"iteratedDeriv_comp_add_const","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ð•œ : Type u_1\nF : Type u_2\ninstâœÂ² : NontriviallyNormedField ð•œ\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ð•œ F\nn : Nat\nf : ð•œ â†’ F\ns : ð•œ\nâŠ¢ Eq (iteratedDeriv n fun z => f (HAdd.hAdd z s)) fun t => iteratedDeriv n f (HAdd.hAdd t s)","decl":"/-- The iterated derivative commutes with shifting the function by a constant on the right. -/\nlemma iteratedDeriv_comp_add_const (n : â„•) (f : ð•œ â†’ F) (s : ð•œ) :\n    iteratedDeriv n (fun z â†¦ f (z + s)) = fun t â†¦ iteratedDeriv n f (t + s) := by\n  induction n with\n  | zero => simp only [iteratedDeriv_zero]\n  | succ n IH =>\n    simpa only [iteratedDeriv_succ, IH] using funext <| deriv_comp_add_const _ s\n\n"}
