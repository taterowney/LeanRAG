{"name":"iteratedDerivWithin_congr","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nF : Type u_2\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\ns : Set ùïú\nf g : ùïú ‚Üí F\nhfg : Set.EqOn f g s\n‚ä¢ Set.EqOn (iteratedDerivWithin n f s) (iteratedDerivWithin n g s) s","decl":"theorem iteratedDerivWithin_congr (hfg : Set.EqOn f g s) :\n    Set.EqOn (iteratedDerivWithin n f s) (iteratedDerivWithin n g s) s := by\n  induction n generalizing f g with\n  | zero => rwa [iteratedDerivWithin_zero]\n  | succ n IH =>\n    intro y hy\n    rw [iteratedDerivWithin_succ, iteratedDerivWithin_succ]\n    exact derivWithin_congr (IH hfg) (IH hfg hy)\n\n"}
{"name":"iteratedDerivWithin_add","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nF : Type u_2\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nx : ùïú\ns : Set ùïú\nhx : Membership.mem s x\nh : UniqueDiffOn ùïú s\nf g : ùïú ‚Üí F\nhf : ContDiffOn ùïú (‚Üën) f s\nhg : ContDiffOn ùïú (‚Üën) g s\n‚ä¢ Eq (iteratedDerivWithin n (HAdd.hAdd f g) s x) (HAdd.hAdd (iteratedDerivWithin n f s x) (iteratedDerivWithin n g s x))","decl":"include h hx in\ntheorem iteratedDerivWithin_add (hf : ContDiffOn ùïú n f s) (hg : ContDiffOn ùïú n g s) :\n    iteratedDerivWithin n (f + g) s x =\n      iteratedDerivWithin n f s x + iteratedDerivWithin n g s x := by\n  simp_rw [iteratedDerivWithin, iteratedFDerivWithin_add_apply hf hg h hx,\n    ContinuousMultilinearMap.add_apply]\n\n"}
{"name":"iteratedDerivWithin_const_add","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nF : Type u_2\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nx : ùïú\ns : Set ùïú\nf : ùïú ‚Üí F\nhn : LT.lt 0 n\nc : F\n‚ä¢ Eq (iteratedDerivWithin n (fun z => HAdd.hAdd c (f z)) s x) (iteratedDerivWithin n f s x)","decl":"theorem iteratedDerivWithin_const_add (hn : 0 < n) (c : F) :\n    iteratedDerivWithin n (fun z => c + f z) s x = iteratedDerivWithin n f s x := by\n  obtain ‚ü®n, rfl‚ü© := n.exists_eq_succ_of_ne_zero hn.ne'\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs; swap\n  ¬∑ simp [iteratedDerivWithin_succ, derivWithin_zero_of_isolated hxs]\n  rw [iteratedDerivWithin_succ', iteratedDerivWithin_succ']\n  congr with y\n  exact derivWithin_const_add _\n\n"}
{"name":"iteratedDerivWithin_const_sub","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nF : Type u_2\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nx : ùïú\ns : Set ùïú\nf : ùïú ‚Üí F\nhn : LT.lt 0 n\nc : F\n‚ä¢ Eq (iteratedDerivWithin n (fun z => HSub.hSub c (f z)) s x) (iteratedDerivWithin n (fun z => Neg.neg (f z)) s x)","decl":"theorem iteratedDerivWithin_const_sub (hn : 0 < n) (c : F) :\n    iteratedDerivWithin n (fun z => c - f z) s x = iteratedDerivWithin n (fun z => -f z) s x := by\n  obtain ‚ü®n, rfl‚ü© := n.exists_eq_succ_of_ne_zero hn.ne'\n  rcases uniqueDiffWithinAt_or_nhdsWithin_eq_bot s x with hxs | hxs; swap\n  ¬∑ simp [iteratedDerivWithin_succ, derivWithin_zero_of_isolated hxs]\n  rw [iteratedDerivWithin_succ', iteratedDerivWithin_succ']\n  congr with y\n  rw [derivWithin.neg]\n  exact derivWithin_const_sub _\n\n"}
{"name":"iteratedDerivWithin_const_neg","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nF : Type u_2\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nx : ùïú\ns : Set ùïú\nf : ùïú ‚Üí F\nhn : LT.lt 0 n\nc : F\n‚ä¢ Eq (iteratedDerivWithin n (fun z => HSub.hSub c (f z)) s x) (iteratedDerivWithin n (fun z => Neg.neg (f z)) s x)","decl":"@[deprecated (since := \"2024-12-10\")]\nalias iteratedDerivWithin_const_neg := iteratedDerivWithin_const_sub\n\n"}
{"name":"iteratedDerivWithin_const_smul","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù‚Å∂ : NontriviallyNormedField ùïú\nF : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup F\ninst‚úù‚Å¥ : NormedSpace ùïú F\nR : Type u_3\ninst‚úù¬≥ : Semiring R\ninst‚úù¬≤ : Module R F\ninst‚úù¬π : SMulCommClass ùïú R F\ninst‚úù : ContinuousConstSMul R F\nn : Nat\nx : ùïú\ns : Set ùïú\nhx : Membership.mem s x\nh : UniqueDiffOn ùïú s\nf : ùïú ‚Üí F\nc : R\nhf : ContDiffWithinAt ùïú (‚Üën) f s x\n‚ä¢ Eq (iteratedDerivWithin n (HSMul.hSMul c f) s x) (HSMul.hSMul c (iteratedDerivWithin n f s x))","decl":"include h hx in\ntheorem iteratedDerivWithin_const_smul (c : R) (hf : ContDiffWithinAt ùïú n f s x) :\n    iteratedDerivWithin n (c ‚Ä¢ f) s x = c ‚Ä¢ iteratedDerivWithin n f s x := by\n  simp_rw [iteratedDerivWithin]\n  rw [iteratedFDerivWithin_const_smul_apply hf h hx]\n  simp only [ContinuousMultilinearMap.smul_apply]\n\n"}
{"name":"iteratedDerivWithin_const_mul","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù : NontriviallyNormedField ùïú\nn : Nat\nx : ùïú\ns : Set ùïú\nhx : Membership.mem s x\nh : UniqueDiffOn ùïú s\nc : ùïú\nf : ùïú ‚Üí ùïú\nhf : ContDiffWithinAt ùïú (‚Üën) f s x\n‚ä¢ Eq (iteratedDerivWithin n (fun z => HMul.hMul c (f z)) s x) (HMul.hMul c (iteratedDerivWithin n f s x))","decl":"include h hx in\ntheorem iteratedDerivWithin_const_mul (c : ùïú) {f : ùïú ‚Üí ùïú} (hf : ContDiffWithinAt ùïú n f s x) :\n    iteratedDerivWithin n (fun z => c * f z) s x = c * iteratedDerivWithin n f s x := by\n  simpa using iteratedDerivWithin_const_smul (F := ùïú) hx h c hf\n\n"}
{"name":"iteratedDerivWithin_neg","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nF : Type u_2\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nx : ùïú\ns : Set ùïú\nf : ùïú ‚Üí F\n‚ä¢ Eq (iteratedDerivWithin n (Neg.neg f) s x) (Neg.neg (iteratedDerivWithin n f s x))","decl":"variable (f) in\nomit h hx in\ntheorem iteratedDerivWithin_neg :\n    iteratedDerivWithin n (-f) s x = -iteratedDerivWithin n f s x := by\n  induction n generalizing x with\n  | zero => simp\n  | succ n IH =>\n    simp only [iteratedDerivWithin_succ, derivWithin_neg]\n    rw [‚Üê derivWithin.neg]\n    congr with y\n    exact IH\n\n"}
{"name":"iteratedDerivWithin_neg'","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nF : Type u_2\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nx : ùïú\ns : Set ùïú\nf : ùïú ‚Üí F\n‚ä¢ Eq (iteratedDerivWithin n (fun z => Neg.neg (f z)) s x) (Neg.neg (iteratedDerivWithin n f s x))","decl":"variable (f) in\ntheorem iteratedDerivWithin_neg' :\n    iteratedDerivWithin n (fun z => -f z) s x = -iteratedDerivWithin n f s x :=\n  iteratedDerivWithin_neg f\n\n"}
{"name":"iteratedDerivWithin_sub","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nF : Type u_2\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nx : ùïú\ns : Set ùïú\nhx : Membership.mem s x\nh : UniqueDiffOn ùïú s\nf g : ùïú ‚Üí F\nhf : ContDiffOn ùïú (‚Üën) f s\nhg : ContDiffOn ùïú (‚Üën) g s\n‚ä¢ Eq (iteratedDerivWithin n (HSub.hSub f g) s x) (HSub.hSub (iteratedDerivWithin n f s x) (iteratedDerivWithin n g s x))","decl":"theorem iteratedDerivWithin_sub (hf : ContDiffOn ùïú n f s) (hg : ContDiffOn ùïú n g s) :\n    iteratedDerivWithin n (f - g) s x =\n      iteratedDerivWithin n f s x - iteratedDerivWithin n g s x := by\n  rw [sub_eq_add_neg, sub_eq_add_neg, Pi.neg_def, iteratedDerivWithin_add hx h hf hg.neg,\n    iteratedDerivWithin_neg']\n\n"}
{"name":"iteratedDerivWithin_comp_const_smul","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nF : Type u_2\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nx : ùïú\ns : Set ùïú\nhx : Membership.mem s x\nh : UniqueDiffOn ùïú s\nf : ùïú ‚Üí F\nhf : ContDiffOn ùïú (‚Üën) f s\nc : ùïú\nhs : Set.MapsTo (fun x => HMul.hMul c x) s s\n‚ä¢ Eq (iteratedDerivWithin n (fun x => f (HMul.hMul c x)) s x) (HSMul.hSMul (HPow.hPow c n) (iteratedDerivWithin n f s (HMul.hMul c x)))","decl":"theorem iteratedDerivWithin_comp_const_smul (hf : ContDiffOn ùïú n f s) (c : ùïú)\n    (hs : Set.MapsTo (c * ¬∑) s s) :\n    iteratedDerivWithin n (fun x => f (c * x)) s x = c ^ n ‚Ä¢ iteratedDerivWithin n f s (c * x) := by\n  induction n generalizing x with\n  | zero => simp\n  | succ n ih =>\n    have hcx : c * x ‚àà s := hs hx\n    have h‚ÇÄ : s.EqOn\n        (iteratedDerivWithin n (fun x ‚Ü¶ f (c * x)) s)\n        (fun x => c ^ n ‚Ä¢ iteratedDerivWithin n f s (c * x)) :=\n      fun x hx => ih hx hf.of_succ\n    have h‚ÇÅ : DifferentiableWithinAt ùïú (iteratedDerivWithin n f s) s (c * x) :=\n      hf.differentiableOn_iteratedDerivWithin (Nat.cast_lt.mpr n.lt_succ_self) h _ hcx\n    have h‚ÇÇ : DifferentiableWithinAt ùïú (fun x => iteratedDerivWithin n f s (c * x)) s x := by\n      rw [‚Üê Function.comp_def]\n      apply DifferentiableWithinAt.comp\n      ¬∑ exact hf.differentiableOn_iteratedDerivWithin (Nat.cast_lt.mpr n.lt_succ_self) h _ hcx\n      ¬∑ exact differentiableWithinAt_id'.const_mul _\n      ¬∑ exact hs\n    rw [iteratedDerivWithin_succ, derivWithin_congr h‚ÇÄ (ih hx hf.of_succ),\n      derivWithin_const_smul (c ^ n) h‚ÇÇ, iteratedDerivWithin_succ,\n      ‚Üê Function.comp_def,\n      derivWithin.scomp x h‚ÇÅ (differentiableWithinAt_id'.const_mul _) hs,\n      derivWithin_const_mul _ differentiableWithinAt_id', derivWithin_id' _ _ (h _ hx),\n      smul_smul, mul_one, pow_succ]\n\n"}
{"name":"iteratedDeriv_add","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nF : Type u_2\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nx : ùïú\nf g : ùïú ‚Üí F\nhf : ContDiff ùïú (‚Üën) f\nhg : ContDiff ùïú (‚Üën) g\n‚ä¢ Eq (iteratedDeriv n (HAdd.hAdd f g) x) (HAdd.hAdd (iteratedDeriv n f x) (iteratedDeriv n g x))","decl":"lemma iteratedDeriv_add (hf : ContDiff ùïú n f) (hg : ContDiff ùïú n g) :\n    iteratedDeriv n (f + g) x = iteratedDeriv n f x + iteratedDeriv n g x := by\n  simpa only [iteratedDerivWithin_univ] using\n    iteratedDerivWithin_add (Set.mem_univ _) uniqueDiffOn_univ\n      (contDiffOn_univ.mpr hf) (contDiffOn_univ.mpr hg)\n\n"}
{"name":"iteratedDeriv_const_add","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nF : Type u_2\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nx : ùïú\nf : ùïú ‚Üí F\nhn : LT.lt 0 n\nc : F\n‚ä¢ Eq (iteratedDeriv n (fun z => HAdd.hAdd c (f z)) x) (iteratedDeriv n f x)","decl":"theorem iteratedDeriv_const_add (hn : 0 < n) (c : F) :\n    iteratedDeriv n (fun z => c + f z) x = iteratedDeriv n f x := by\n  simpa only [‚Üê iteratedDerivWithin_univ] using iteratedDerivWithin_const_add hn c\n\n"}
{"name":"iteratedDeriv_const_sub","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nF : Type u_2\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nx : ùïú\nf : ùïú ‚Üí F\nhn : LT.lt 0 n\nc : F\n‚ä¢ Eq (iteratedDeriv n (fun z => HSub.hSub c (f z)) x) (iteratedDeriv n (Neg.neg f) x)","decl":"theorem iteratedDeriv_const_sub (hn : 0 < n) (c : F) :\n    iteratedDeriv n (fun z => c - f z) x = iteratedDeriv n (-f) x := by\n  simpa only [‚Üê iteratedDerivWithin_univ] using iteratedDerivWithin_const_sub hn c\n\n"}
{"name":"iteratedDeriv_neg","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nF : Type u_2\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nf : ùïú ‚Üí F\na : ùïú\n‚ä¢ Eq (iteratedDeriv n (fun x => Neg.neg (f x)) a) (Neg.neg (iteratedDeriv n f a))","decl":"lemma iteratedDeriv_neg (n : ‚Ñï) (f : ùïú ‚Üí F) (a : ùïú) :\n    iteratedDeriv n (fun x ‚Ü¶ -(f x)) a = -(iteratedDeriv n f a) := by\n  simpa only [‚Üê iteratedDerivWithin_univ] using iteratedDerivWithin_neg f\n\n"}
{"name":"iteratedDeriv_sub","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nF : Type u_2\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nx : ùïú\nf g : ùïú ‚Üí F\nhf : ContDiff ùïú (‚Üën) f\nhg : ContDiff ùïú (‚Üën) g\n‚ä¢ Eq (iteratedDeriv n (HSub.hSub f g) x) (HSub.hSub (iteratedDeriv n f x) (iteratedDeriv n g x))","decl":"lemma iteratedDeriv_sub (hf : ContDiff ùïú n f) (hg : ContDiff ùïú n g) :\n    iteratedDeriv n (f - g) x = iteratedDeriv n f x - iteratedDeriv n g x := by\n  simpa only [iteratedDerivWithin_univ] using\n    iteratedDerivWithin_sub (Set.mem_univ _) uniqueDiffOn_univ\n      (contDiffOn_univ.mpr hf) (contDiffOn_univ.mpr hg)\n\n"}
{"name":"iteratedDeriv_const_smul","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nF : Type u_2\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nx : ùïú\nn : Nat\nf : ùïú ‚Üí F\nh : ContDiffAt ùïú (‚Üën) f x\nc : ùïú\n‚ä¢ Eq (iteratedDeriv n (HSMul.hSMul c f) x) (HSMul.hSMul c (iteratedDeriv n f x))","decl":"theorem iteratedDeriv_const_smul {n : ‚Ñï} {f : ùïú ‚Üí F} (h : ContDiffAt ùïú n f x) (c : ùïú) :\n    iteratedDeriv n (c ‚Ä¢ f) x = c ‚Ä¢ iteratedDeriv n f x := by\n  simpa only [iteratedDerivWithin_univ] using\n    iteratedDerivWithin_const_smul (Set.mem_univ x) uniqueDiffOn_univ\n      c (contDiffWithinAt_univ.mpr h)\n\n"}
{"name":"iteratedDeriv_const_mul","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù : NontriviallyNormedField ùïú\nx : ùïú\nn : Nat\nf : ùïú ‚Üí ùïú\nh : ContDiffAt ùïú (‚Üën) f x\nc : ùïú\n‚ä¢ Eq (iteratedDeriv n (fun z => HMul.hMul c (f z)) x) (HMul.hMul c (iteratedDeriv n f x))","decl":"theorem iteratedDeriv_const_mul {n : ‚Ñï} {f : ùïú ‚Üí ùïú} (h : ContDiffAt ùïú n f x) (c : ùïú) :\n    iteratedDeriv n (fun z => c * f z) x = c * iteratedDeriv n f x := by\n  simpa only [iteratedDerivWithin_univ] using\n    iteratedDerivWithin_const_mul (Set.mem_univ x) uniqueDiffOn_univ\n      c (contDiffWithinAt_univ.mpr h)\n\n"}
{"name":"iteratedDeriv_comp_const_smul","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nF : Type u_2\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nf : ùïú ‚Üí F\nh : ContDiff ùïú (‚Üën) f\nc : ùïú\n‚ä¢ Eq (iteratedDeriv n fun x => f (HMul.hMul c x)) fun x => HSMul.hSMul (HPow.hPow c n) (iteratedDeriv n f (HMul.hMul c x))","decl":"theorem iteratedDeriv_comp_const_smul {n : ‚Ñï} {f : ùïú ‚Üí F} (h : ContDiff ùïú n f) (c : ùïú) :\n    iteratedDeriv n (fun x => f (c * x)) = fun x => c ^ n ‚Ä¢ iteratedDeriv n f (c * x) := by\n  funext x\n  simpa only [iteratedDerivWithin_univ] using\n    iteratedDerivWithin_comp_const_smul (Set.mem_univ x) uniqueDiffOn_univ (contDiffOn_univ.mpr h)\n      c (Set.mapsTo_univ _ _)\n\n"}
{"name":"iteratedDeriv_comp_const_mul","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù : NontriviallyNormedField ùïú\nn : Nat\nf : ùïú ‚Üí ùïú\nh : ContDiff ùïú (‚Üën) f\nc : ùïú\n‚ä¢ Eq (iteratedDeriv n fun x => f (HMul.hMul c x)) fun x => HMul.hMul (HPow.hPow c n) (iteratedDeriv n f (HMul.hMul c x))","decl":"theorem iteratedDeriv_comp_const_mul {n : ‚Ñï} {f : ùïú ‚Üí ùïú} (h : ContDiff ùïú n f) (c : ùïú) :\n    iteratedDeriv n (fun x => f (c * x)) = fun x => c ^ n * iteratedDeriv n f (c * x) := by\n  simpa only [smul_eq_mul] using iteratedDeriv_comp_const_smul h c\n\n"}
{"name":"iteratedDeriv_comp_neg","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nF : Type u_2\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nf : ùïú ‚Üí F\na : ùïú\n‚ä¢ Eq (iteratedDeriv n (fun x => f (Neg.neg x)) a) (HSMul.hSMul (HPow.hPow (-1) n) (iteratedDeriv n f (Neg.neg a)))","decl":"lemma iteratedDeriv_comp_neg (n : ‚Ñï) (f : ùïú ‚Üí F) (a : ùïú) :\n    iteratedDeriv n (fun x ‚Ü¶ f (-x)) a = (-1 : ùïú) ^ n ‚Ä¢ iteratedDeriv n f (-a) := by\n  induction' n with n ih generalizing a\n  ¬∑ simp only [iteratedDeriv_zero, pow_zero, one_smul]\n  ¬∑ have ih' : iteratedDeriv n (fun x ‚Ü¶ f (-x)) = fun x ‚Ü¶ (-1 : ùïú) ^ n ‚Ä¢ iteratedDeriv n f (-x) :=\n      funext ih\n    rw [iteratedDeriv_succ, iteratedDeriv_succ, ih', pow_succ', neg_mul, one_mul,\n      deriv_comp_neg (f := fun x ‚Ü¶ (-1 : ùïú) ^ n ‚Ä¢ iteratedDeriv n f x), deriv_const_smul',\n      neg_smul]\n\n"}
{"name":"Filter.EventuallyEq.iteratedDeriv_eq","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nF : Type u_2\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nf g : ùïú ‚Üí F\nx : ùïú\nhfg : (nhds x).EventuallyEq f g\n‚ä¢ Eq (iteratedDeriv n f x) (iteratedDeriv n g x)","decl":"open Topology in\nlemma Filter.EventuallyEq.iteratedDeriv_eq (n : ‚Ñï) {f g : ùïú ‚Üí F} {x : ùïú} (hfg : f =·∂†[ùìù x] g) :\n    iteratedDeriv n f x = iteratedDeriv n g x := by\n  simp only [‚Üê iteratedDerivWithin_univ, iteratedDerivWithin_eq_iteratedFDerivWithin]\n  rw [(hfg.filter_mono nhdsWithin_le_nhds).iteratedFDerivWithin_eq hfg.eq_of_nhds n]\n\n"}
{"name":"Set.EqOn.iteratedDeriv_of_isOpen","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : NontriviallyNormedField ùïú\nF : Type u_2\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\ns : Set ùïú\nf g : ùïú ‚Üí F\nhfg : Set.EqOn f g s\nhs : IsOpen s\nn : Nat\n‚ä¢ Set.EqOn (iteratedDeriv n f) (iteratedDeriv n g) s","decl":"lemma Set.EqOn.iteratedDeriv_of_isOpen (hfg : Set.EqOn f g s) (hs : IsOpen s) (n : ‚Ñï) :\n    Set.EqOn (iteratedDeriv n f) (iteratedDeriv n g) s := by\n  refine fun x hx ‚Ü¶ Filter.EventuallyEq.iteratedDeriv_eq n ?_\n  filter_upwards [IsOpen.mem_nhds hs hx] with a ha\n  exact hfg ha\n\n"}
{"name":"iteratedDeriv_comp_const_add","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\nF : Type u_2\ninst‚úù¬≤ : NontriviallyNormedField ùïú\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nf : ùïú ‚Üí F\ns : ùïú\n‚ä¢ Eq (iteratedDeriv n fun z => f (HAdd.hAdd s z)) fun t => iteratedDeriv n f (HAdd.hAdd s t)","decl":"/-- The iterated derivative commutes with shifting the function by a constant on the left. -/\nlemma iteratedDeriv_comp_const_add (n : ‚Ñï) (f : ùïú ‚Üí F) (s : ùïú) :\n    iteratedDeriv n (fun z ‚Ü¶ f (s + z)) = fun t ‚Ü¶ iteratedDeriv n f (s + t) := by\n  induction n with\n  | zero => simp only [iteratedDeriv_zero]\n  | succ n IH =>\n    simpa only [iteratedDeriv_succ, IH] using funext <| deriv_comp_const_add _ s\n\n"}
{"name":"iteratedDeriv_comp_add_const","module":"Mathlib.Analysis.Calculus.IteratedDeriv.Lemmas","initialProofState":"ùïú : Type u_1\nF : Type u_2\ninst‚úù¬≤ : NontriviallyNormedField ùïú\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : NormedSpace ùïú F\nn : Nat\nf : ùïú ‚Üí F\ns : ùïú\n‚ä¢ Eq (iteratedDeriv n fun z => f (HAdd.hAdd z s)) fun t => iteratedDeriv n f (HAdd.hAdd t s)","decl":"/-- The iterated derivative commutes with shifting the function by a constant on the right. -/\nlemma iteratedDeriv_comp_add_const (n : ‚Ñï) (f : ùïú ‚Üí F) (s : ùïú) :\n    iteratedDeriv n (fun z ‚Ü¶ f (z + s)) = fun t ‚Ü¶ iteratedDeriv n f (t + s) := by\n  induction n with\n  | zero => simp only [iteratedDeriv_zero]\n  | succ n IH =>\n    simpa only [iteratedDeriv_succ, IH] using funext <| deriv_comp_add_const _ s\n\n"}
