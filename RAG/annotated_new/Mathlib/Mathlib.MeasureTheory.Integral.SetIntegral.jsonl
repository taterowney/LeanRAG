{"name":"MeasureTheory.setIntegral_congr_aeâ‚€","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf g : X â†’ E\ns : Set X\nÎ¼ : MeasureTheory.Measure X\nhs : MeasureTheory.NullMeasurableSet s Î¼\nh : Filter.Eventually (fun x => Membership.mem s x â†’ Eq (f x) (g x)) (MeasureTheory.ae Î¼)\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => g x)","decl":"theorem setIntegral_congr_aeâ‚€ (hs : NullMeasurableSet s Î¼) (h : âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ f x = g x) :\n    âˆ« x in s, f x âˆ‚Î¼ = âˆ« x in s, g x âˆ‚Î¼ :=\n  integral_congr_ae ((ae_restrict_iff'â‚€ hs).2 h)\n\n"}
{"name":"MeasureTheory.setIntegral_congr_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf g : X â†’ E\ns : Set X\nÎ¼ : MeasureTheory.Measure X\nhs : MeasurableSet s\nh : Filter.Eventually (fun x => Membership.mem s x â†’ Eq (f x) (g x)) (MeasureTheory.ae Î¼)\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => g x)","decl":"theorem setIntegral_congr_ae (hs : MeasurableSet s) (h : âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ f x = g x) :\n    âˆ« x in s, f x âˆ‚Î¼ = âˆ« x in s, g x âˆ‚Î¼ :=\n  integral_congr_ae ((ae_restrict_iff' hs).2 h)\n\n"}
{"name":"MeasureTheory.setIntegral_congr_funâ‚€","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf g : X â†’ E\ns : Set X\nÎ¼ : MeasureTheory.Measure X\nhs : MeasureTheory.NullMeasurableSet s Î¼\nh : Set.EqOn f g s\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => g x)","decl":"theorem setIntegral_congr_funâ‚€ (hs : NullMeasurableSet s Î¼) (h : EqOn f g s) :\n    âˆ« x in s, f x âˆ‚Î¼ = âˆ« x in s, g x âˆ‚Î¼ :=\n  setIntegral_congr_aeâ‚€ hs <| Eventually.of_forall h\n\n"}
{"name":"MeasureTheory.setIntegral_congrâ‚€","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf g : X â†’ E\ns : Set X\nÎ¼ : MeasureTheory.Measure X\nhs : MeasureTheory.NullMeasurableSet s Î¼\nh : Set.EqOn f g s\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => g x)","decl":"@[deprecated (since := \"2024-10-12\")]\nalias setIntegral_congrâ‚€ := setIntegral_congr_funâ‚€\n\n"}
{"name":"MeasureTheory.setIntegral_congr_fun","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf g : X â†’ E\ns : Set X\nÎ¼ : MeasureTheory.Measure X\nhs : MeasurableSet s\nh : Set.EqOn f g s\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => g x)","decl":"theorem setIntegral_congr_fun (hs : MeasurableSet s) (h : EqOn f g s) :\n    âˆ« x in s, f x âˆ‚Î¼ = âˆ« x in s, g x âˆ‚Î¼ :=\n  setIntegral_congr_ae hs <| Eventually.of_forall h\n\n"}
{"name":"MeasureTheory.setIntegral_congr","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf g : X â†’ E\ns : Set X\nÎ¼ : MeasureTheory.Measure X\nhs : MeasurableSet s\nh : Set.EqOn f g s\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => g x)","decl":"@[deprecated (since := \"2024-10-12\")]\nalias setIntegral_congr := setIntegral_congr_fun\n\n"}
{"name":"MeasureTheory.setIntegral_congr_set","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns t : Set X\nÎ¼ : MeasureTheory.Measure X\nhst : (MeasureTheory.ae Î¼).EventuallyEq s t\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict t) fun x => f x)","decl":"theorem setIntegral_congr_set (hst : s =áµ[Î¼] t) : âˆ« x in s, f x âˆ‚Î¼ = âˆ« x in t, f x âˆ‚Î¼ := by\n  rw [Measure.restrict_congr_set hst]\n\n"}
{"name":"MeasureTheory.setIntegral_congr_set_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns t : Set X\nÎ¼ : MeasureTheory.Measure X\nhst : (MeasureTheory.ae Î¼).EventuallyEq s t\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict t) fun x => f x)","decl":"@[deprecated (since := \"2024-10-12\")]\nalias setIntegral_congr_set_ae := setIntegral_congr_set\n\n"}
{"name":"MeasureTheory.integral_union_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns t : Set X\nÎ¼ : MeasureTheory.Measure X\nhst : MeasureTheory.AEDisjoint Î¼ s t\nht : MeasureTheory.NullMeasurableSet t Î¼\nhfs : MeasureTheory.IntegrableOn f s Î¼\nhft : MeasureTheory.IntegrableOn f t Î¼\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Union.union s t)) fun x => f x) (HAdd.hAdd (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict t) fun x => f x))","decl":"theorem integral_union_ae (hst : AEDisjoint Î¼ s t) (ht : NullMeasurableSet t Î¼)\n    (hfs : IntegrableOn f s Î¼) (hft : IntegrableOn f t Î¼) :\n    âˆ« x in s âˆª t, f x âˆ‚Î¼ = âˆ« x in s, f x âˆ‚Î¼ + âˆ« x in t, f x âˆ‚Î¼ := by\n  simp only [IntegrableOn, Measure.restrict_unionâ‚€ hst ht, integral_add_measure hfs hft]\n\n"}
{"name":"MeasureTheory.setIntegral_union","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns t : Set X\nÎ¼ : MeasureTheory.Measure X\nhst : Disjoint s t\nht : MeasurableSet t\nhfs : MeasureTheory.IntegrableOn f s Î¼\nhft : MeasureTheory.IntegrableOn f t Î¼\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Union.union s t)) fun x => f x) (HAdd.hAdd (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict t) fun x => f x))","decl":"theorem setIntegral_union (hst : Disjoint s t) (ht : MeasurableSet t) (hfs : IntegrableOn f s Î¼)\n    (hft : IntegrableOn f t Î¼) : âˆ« x in s âˆª t, f x âˆ‚Î¼ = âˆ« x in s, f x âˆ‚Î¼ + âˆ« x in t, f x âˆ‚Î¼ :=\n  integral_union_ae hst.aedisjoint ht.nullMeasurableSet hfs hft\n\n"}
{"name":"MeasureTheory.integral_union","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns t : Set X\nÎ¼ : MeasureTheory.Measure X\nhst : Disjoint s t\nht : MeasurableSet t\nhfs : MeasureTheory.IntegrableOn f s Î¼\nhft : MeasureTheory.IntegrableOn f t Î¼\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Union.union s t)) fun x => f x) (HAdd.hAdd (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict t) fun x => f x))","decl":"@[deprecated (since := \"2024-10-12\")]\nalias integral_union := setIntegral_union\n\n"}
{"name":"MeasureTheory.integral_diff","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns t : Set X\nÎ¼ : MeasureTheory.Measure X\nht : MeasurableSet t\nhfs : MeasureTheory.IntegrableOn f s Î¼\nhts : HasSubset.Subset t s\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (SDiff.sdiff s t)) fun x => f x) (HSub.hSub (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict t) fun x => f x))","decl":"theorem integral_diff (ht : MeasurableSet t) (hfs : IntegrableOn f s Î¼) (hts : t âŠ† s) :\n    âˆ« x in s \\ t, f x âˆ‚Î¼ = âˆ« x in s, f x âˆ‚Î¼ - âˆ« x in t, f x âˆ‚Î¼ := by\n  rw [eq_sub_iff_add_eq, â† setIntegral_union, diff_union_of_subset hts]\n  exacts [disjoint_sdiff_self_left, ht, hfs.mono_set diff_subset, hfs.mono_set hts]\n\n"}
{"name":"MeasureTheory.integral_inter_add_diffâ‚€","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns t : Set X\nÎ¼ : MeasureTheory.Measure X\nht : MeasureTheory.NullMeasurableSet t Î¼\nhfs : MeasureTheory.IntegrableOn f s Î¼\nâŠ¢ Eq (HAdd.hAdd (MeasureTheory.integral (Î¼.restrict (Inter.inter s t)) fun x => f x) (MeasureTheory.integral (Î¼.restrict (SDiff.sdiff s t)) fun x => f x)) (MeasureTheory.integral (Î¼.restrict s) fun x => f x)","decl":"theorem integral_inter_add_diffâ‚€ (ht : NullMeasurableSet t Î¼) (hfs : IntegrableOn f s Î¼) :\n    âˆ« x in s âˆ© t, f x âˆ‚Î¼ + âˆ« x in s \\ t, f x âˆ‚Î¼ = âˆ« x in s, f x âˆ‚Î¼ := by\n  rw [â† Measure.restrict_inter_add_diffâ‚€ s ht, integral_add_measure]\n  Â· exact Integrable.mono_measure hfs (Measure.restrict_mono inter_subset_left le_rfl)\n  Â· exact Integrable.mono_measure hfs (Measure.restrict_mono diff_subset le_rfl)\n\n"}
{"name":"MeasureTheory.integral_inter_add_diff","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns t : Set X\nÎ¼ : MeasureTheory.Measure X\nht : MeasurableSet t\nhfs : MeasureTheory.IntegrableOn f s Î¼\nâŠ¢ Eq (HAdd.hAdd (MeasureTheory.integral (Î¼.restrict (Inter.inter s t)) fun x => f x) (MeasureTheory.integral (Î¼.restrict (SDiff.sdiff s t)) fun x => f x)) (MeasureTheory.integral (Î¼.restrict s) fun x => f x)","decl":"theorem integral_inter_add_diff (ht : MeasurableSet t) (hfs : IntegrableOn f s Î¼) :\n    âˆ« x in s âˆ© t, f x âˆ‚Î¼ + âˆ« x in s \\ t, f x âˆ‚Î¼ = âˆ« x in s, f x âˆ‚Î¼ :=\n  integral_inter_add_diffâ‚€ ht.nullMeasurableSet hfs\n\n"}
{"name":"MeasureTheory.integral_finset_biUnion","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\nÎ¹ : Type u_5\nt : Finset Î¹\ns : Î¹ â†’ Set X\nhs : âˆ€ (i : Î¹), Membership.mem t i â†’ MeasurableSet (s i)\nh's : (â†‘t).Pairwise (Function.onFun Disjoint s)\nhf : âˆ€ (i : Î¹), Membership.mem t i â†’ MeasureTheory.IntegrableOn f (s i) Î¼\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Set.iUnion fun i => Set.iUnion fun h => s i)) fun x => f x) (t.sum fun i => MeasureTheory.integral (Î¼.restrict (s i)) fun x => f x)","decl":"theorem integral_finset_biUnion {Î¹ : Type*} (t : Finset Î¹) {s : Î¹ â†’ Set X}\n    (hs : âˆ€ i âˆˆ t, MeasurableSet (s i)) (h's : Set.Pairwise (â†‘t) (Disjoint on s))\n    (hf : âˆ€ i âˆˆ t, IntegrableOn f (s i) Î¼) :\n    âˆ« x in â‹ƒ i âˆˆ t, s i, f x âˆ‚Î¼ = âˆ‘ i âˆˆ t, âˆ« x in s i, f x âˆ‚Î¼ := by\n  classical\n  induction' t using Finset.induction_on with a t hat IH hs h's\n  Â· simp\n  Â· simp only [Finset.coe_insert, Finset.forall_mem_insert, Set.pairwise_insert,\n      Finset.set_biUnion_insert] at hs hf h's âŠ¢\n    rw [setIntegral_union _ _ hf.1 (integrableOn_finset_iUnion.2 hf.2)]\n    Â· rw [Finset.sum_insert hat, IH hs.2 h's.1 hf.2]\n    Â· simp only [disjoint_iUnion_right]\n      exact fun i hi => (h's.2 i hi (ne_of_mem_of_not_mem hi hat).symm).1\n    Â· exact Finset.measurableSet_biUnion _ hs.2\n\n"}
{"name":"MeasureTheory.integral_fintype_iUnion","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\nÎ¹ : Type u_5\ninstâœ : Fintype Î¹\ns : Î¹ â†’ Set X\nhs : âˆ€ (i : Î¹), MeasurableSet (s i)\nh's : Pairwise (Function.onFun Disjoint s)\nhf : âˆ€ (i : Î¹), MeasureTheory.IntegrableOn f (s i) Î¼\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Set.iUnion fun i => s i)) fun x => f x) (Finset.univ.sum fun i => MeasureTheory.integral (Î¼.restrict (s i)) fun x => f x)","decl":"theorem integral_fintype_iUnion {Î¹ : Type*} [Fintype Î¹] {s : Î¹ â†’ Set X}\n    (hs : âˆ€ i, MeasurableSet (s i)) (h's : Pairwise (Disjoint on s))\n    (hf : âˆ€ i, IntegrableOn f (s i) Î¼) : âˆ« x in â‹ƒ i, s i, f x âˆ‚Î¼ = âˆ‘ i, âˆ« x in s i, f x âˆ‚Î¼ := by\n  convert integral_finset_biUnion Finset.univ (fun i _ => hs i) _ fun i _ => hf i\n  Â· simp\n  Â· simp [pairwise_univ, h's]\n\n"}
{"name":"MeasureTheory.setIntegral_empty","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict EmptyCollection.emptyCollection) fun x => f x) 0","decl":"theorem setIntegral_empty : âˆ« x in âˆ…, f x âˆ‚Î¼ = 0 := by\n  rw [Measure.restrict_empty, integral_zero_measure]\n\n"}
{"name":"MeasureTheory.integral_empty","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict EmptyCollection.emptyCollection) fun x => f x) 0","decl":"@[deprecated (since := \"2024-10-12\")]\nalias integral_empty := setIntegral_empty\n\n"}
{"name":"MeasureTheory.setIntegral_univ","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict Set.univ) fun x => f x) (MeasureTheory.integral Î¼ fun x => f x)","decl":"theorem setIntegral_univ : âˆ« x in univ, f x âˆ‚Î¼ = âˆ« x, f x âˆ‚Î¼ := by rw [Measure.restrict_univ]\n\n"}
{"name":"MeasureTheory.integral_univ","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict Set.univ) fun x => f x) (MeasureTheory.integral Î¼ fun x => f x)","decl":"@[deprecated (since := \"2024-10-12\")]\nalias integral_univ := setIntegral_univ\n\n"}
{"name":"MeasureTheory.integral_add_complâ‚€","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns : Set X\nÎ¼ : MeasureTheory.Measure X\nhs : MeasureTheory.NullMeasurableSet s Î¼\nhfi : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (HAdd.hAdd (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict (HasCompl.compl s)) fun x => f x)) (MeasureTheory.integral Î¼ fun x => f x)","decl":"theorem integral_add_complâ‚€ (hs : NullMeasurableSet s Î¼) (hfi : Integrable f Î¼) :\n    âˆ« x in s, f x âˆ‚Î¼ + âˆ« x in sá¶œ, f x âˆ‚Î¼ = âˆ« x, f x âˆ‚Î¼ := by\n  rw [\n    â† integral_union_ae disjoint_compl_right.aedisjoint hs.compl hfi.integrableOn hfi.integrableOn,\n    union_compl_self, setIntegral_univ]\n\n"}
{"name":"MeasureTheory.integral_add_compl","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns : Set X\nÎ¼ : MeasureTheory.Measure X\nhs : MeasurableSet s\nhfi : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (HAdd.hAdd (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict (HasCompl.compl s)) fun x => f x)) (MeasureTheory.integral Î¼ fun x => f x)","decl":"theorem integral_add_compl (hs : MeasurableSet s) (hfi : Integrable f Î¼) :\n    âˆ« x in s, f x âˆ‚Î¼ + âˆ« x in sá¶œ, f x âˆ‚Î¼ = âˆ« x, f x âˆ‚Î¼ :=\n  integral_add_complâ‚€ hs.nullMeasurableSet hfi\n\n"}
{"name":"MeasureTheory.setIntegral_compl","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns : Set X\nÎ¼ : MeasureTheory.Measure X\nhs : MeasurableSet s\nhfi : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (HasCompl.compl s)) fun x => f x) (HSub.hSub (MeasureTheory.integral Î¼ fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => f x))","decl":"theorem setIntegral_compl (hs : MeasurableSet s) (hfi : Integrable f Î¼) :\n    âˆ« x in sá¶œ, f x âˆ‚Î¼ = âˆ« x, f x âˆ‚Î¼ - âˆ« x in s, f x âˆ‚Î¼ := by\n  rw [â† integral_add_compl (Î¼ := Î¼) hs hfi, add_sub_cancel_left]\n\n"}
{"name":"MeasureTheory.integral_indicator","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns : Set X\nÎ¼ : MeasureTheory.Measure X\nhs : MeasurableSet s\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => s.indicator f x) (MeasureTheory.integral (Î¼.restrict s) fun x => f x)","decl":"/-- For a function `f` and a measurable set `s`, the integral of `indicator s f`\nover the whole space is equal to `âˆ« x in s, f x âˆ‚Î¼` defined as `âˆ« x, f x âˆ‚(Î¼.restrict s)`. -/\ntheorem integral_indicator (hs : MeasurableSet s) :\n    âˆ« x, indicator s f x âˆ‚Î¼ = âˆ« x in s, f x âˆ‚Î¼ := by\n  by_cases hfi : IntegrableOn f s Î¼; swap\n  Â· rw [integral_undef hfi, integral_undef]\n    rwa [integrable_indicator_iff hs]\n  calc\n    âˆ« x, indicator s f x âˆ‚Î¼ = âˆ« x in s, indicator s f x âˆ‚Î¼ + âˆ« x in sá¶œ, indicator s f x âˆ‚Î¼ :=\n      (integral_add_compl hs (hfi.integrable_indicator hs)).symm\n    _ = âˆ« x in s, f x âˆ‚Î¼ + âˆ« x in sá¶œ, 0 âˆ‚Î¼ :=\n      (congr_argâ‚‚ (Â· + Â·) (integral_congr_ae (indicator_ae_eq_restrict hs))\n        (integral_congr_ae (indicator_ae_eq_restrict_compl hs)))\n    _ = âˆ« x in s, f x âˆ‚Î¼ := by simp\n\n"}
{"name":"MeasureTheory.setIntegral_indicator","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns t : Set X\nÎ¼ : MeasureTheory.Measure X\nht : MeasurableSet t\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => t.indicator f x) (MeasureTheory.integral (Î¼.restrict (Inter.inter s t)) fun x => f x)","decl":"theorem setIntegral_indicator (ht : MeasurableSet t) :\n    âˆ« x in s, t.indicator f x âˆ‚Î¼ = âˆ« x in s âˆ© t, f x âˆ‚Î¼ := by\n  rw [integral_indicator ht, Measure.restrict_restrict ht, Set.inter_comm]\n\n"}
{"name":"MeasureTheory.ofReal_setIntegral_one_of_measure_ne_top","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_5\nm : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ns : Set X\nhs : Ne (Î¼ s) Top.top\nâŠ¢ Eq (ENNReal.ofReal (MeasureTheory.integral (Î¼.restrict s) fun x => 1)) (Î¼ s)","decl":"theorem ofReal_setIntegral_one_of_measure_ne_top {X : Type*} {m : MeasurableSpace X}\n    {Î¼ : Measure X} {s : Set X} (hs : Î¼ s â‰  âˆ) : ENNReal.ofReal (âˆ« _ in s, (1 : â„) âˆ‚Î¼) = Î¼ s :=\n  calc\n    ENNReal.ofReal (âˆ« _ in s, (1 : â„) âˆ‚Î¼) = ENNReal.ofReal (âˆ« _ in s, â€–(1 : â„)â€– âˆ‚Î¼) := by\n      simp only [norm_one]\n    _ = âˆ«â» _ in s, 1 âˆ‚Î¼ := by\n      simpa [ofReal_integral_norm_eq_lintegral_enorm (integrableOn_const.2 (.inr hs.lt_top))]\n    _ = Î¼ s := setLIntegral_one _\n\n"}
{"name":"MeasureTheory.ofReal_setIntegral_one","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_5\nxâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\ns : Set X\nâŠ¢ Eq (ENNReal.ofReal (MeasureTheory.integral (Î¼.restrict s) fun x => 1)) (Î¼ s)","decl":"theorem ofReal_setIntegral_one {X : Type*} {_ : MeasurableSpace X} (Î¼ : Measure X)\n    [IsFiniteMeasure Î¼] (s : Set X) : ENNReal.ofReal (âˆ« _ in s, (1 : â„) âˆ‚Î¼) = Î¼ s :=\n  ofReal_setIntegral_one_of_measure_ne_top (measure_ne_top Î¼ s)\n\n"}
{"name":"MeasureTheory.integral_piecewise","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nf g : X â†’ E\ns : Set X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : DecidablePred fun x => Membership.mem s x\nhs : MeasurableSet s\nhf : MeasureTheory.IntegrableOn f s Î¼\nhg : MeasureTheory.IntegrableOn g (HasCompl.compl s) Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => s.piecewise f g x) (HAdd.hAdd (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict (HasCompl.compl s)) fun x => g x))","decl":"theorem integral_piecewise [DecidablePred (Â· âˆˆ s)] (hs : MeasurableSet s) (hf : IntegrableOn f s Î¼)\n    (hg : IntegrableOn g sá¶œ Î¼) :\n    âˆ« x, s.piecewise f g x âˆ‚Î¼ = âˆ« x in s, f x âˆ‚Î¼ + âˆ« x in sá¶œ, g x âˆ‚Î¼ := by\n  rw [â† Set.indicator_add_compl_eq_piecewise,\n    integral_add' (hf.integrable_indicator hs) (hg.integrable_indicator hs.compl),\n    integral_indicator hs, integral_indicator hs.compl]\n\n"}
{"name":"MeasureTheory.tendsto_setIntegral_of_monotone","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœâ´ : MeasurableSpace X\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\nÎ¹ : Type u_5\ninstâœÂ¹ : Preorder Î¹\ninstâœ : Filter.atTop.IsCountablyGenerated\ns : Î¹ â†’ Set X\nhsm : âˆ€ (i : Î¹), MeasurableSet (s i)\nh_mono : Monotone s\nhfi : MeasureTheory.IntegrableOn f (Set.iUnion fun n => s n) Î¼\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.integral (Î¼.restrict (s i)) fun x => f x) Filter.atTop (nhds (MeasureTheory.integral (Î¼.restrict (Set.iUnion fun n => s n)) fun x => f x))","decl":"theorem tendsto_setIntegral_of_monotone\n    {Î¹ : Type*} [Preorder Î¹] [(atTop : Filter Î¹).IsCountablyGenerated]\n    {s : Î¹ â†’ Set X} (hsm : âˆ€ i, MeasurableSet (s i)) (h_mono : Monotone s)\n    (hfi : IntegrableOn f (â‹ƒ n, s n) Î¼) :\n    Tendsto (fun i => âˆ« x in s i, f x âˆ‚Î¼) atTop (ğ“ (âˆ« x in â‹ƒ n, s n, f x âˆ‚Î¼)) := by\n  refine .of_neBot_imp fun hne â†¦ ?_\n  have := (atTop_neBot_iff.mp hne).2\n  have hfi' : âˆ«â» x in â‹ƒ n, s n, â€–f xâ€–â‚Š âˆ‚Î¼ < âˆ := hfi.2\n  set S := â‹ƒ i, s i\n  have hSm : MeasurableSet S := MeasurableSet.iUnion_of_monotone h_mono hsm\n  have hsub {i} : s i âŠ† S := subset_iUnion s i\n  rw [â† withDensity_apply _ hSm] at hfi'\n  set Î½ := Î¼.withDensity (â€–f Â·â€–â‚‘) with hÎ½\n  refine Metric.nhds_basis_closedBall.tendsto_right_iff.2 fun Îµ Îµ0 => ?_\n  lift Îµ to â„â‰¥0 using Îµ0.le\n  have : âˆ€á¶  i in atTop, Î½ (s i) âˆˆ Icc (Î½ S - Îµ) (Î½ S + Îµ) :=\n    tendsto_measure_iUnion_atTop h_mono (ENNReal.Icc_mem_nhds hfi'.ne (ENNReal.coe_pos.2 Îµ0).ne')\n  filter_upwards [this] with i hi\n  rw [mem_closedBall_iff_norm', â† integral_diff (hsm i) hfi hsub, â† coe_nnnorm, NNReal.coe_le_coe, â†\n    ENNReal.coe_le_coe]\n  refine (enorm_integral_le_lintegral_enorm _).trans ?_\n  rw [â† withDensity_apply _ (hSm.diff (hsm _)), â† hÎ½, measure_diff hsub (hsm _).nullMeasurableSet]\n  exacts [tsub_le_iff_tsub_le.mp hi.1,\n    (hi.2.trans_lt <| ENNReal.add_lt_top.2 âŸ¨hfi', ENNReal.coe_lt_topâŸ©).ne]\n\n"}
{"name":"MeasureTheory.tendsto_setIntegral_of_antitone","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœâ´ : MeasurableSpace X\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\nÎ¹ : Type u_5\ninstâœÂ¹ : Preorder Î¹\ninstâœ : Filter.atTop.IsCountablyGenerated\ns : Î¹ â†’ Set X\nhsm : âˆ€ (i : Î¹), MeasurableSet (s i)\nh_anti : Antitone s\nhfi : Exists fun i => MeasureTheory.IntegrableOn f (s i) Î¼\nâŠ¢ Filter.Tendsto (fun i => MeasureTheory.integral (Î¼.restrict (s i)) fun x => f x) Filter.atTop (nhds (MeasureTheory.integral (Î¼.restrict (Set.iInter fun n => s n)) fun x => f x))","decl":"theorem tendsto_setIntegral_of_antitone\n    {Î¹ : Type*} [Preorder Î¹] [(atTop : Filter Î¹).IsCountablyGenerated]\n    {s : Î¹ â†’ Set X} (hsm : âˆ€ i, MeasurableSet (s i)) (h_anti : Antitone s)\n    (hfi : âˆƒ i, IntegrableOn f (s i) Î¼) :\n    Tendsto (fun i â†¦ âˆ« x in s i, f x âˆ‚Î¼) atTop (ğ“ (âˆ« x in â‹‚ n, s n, f x âˆ‚Î¼)) := by\n  refine .of_neBot_imp fun hne â†¦ ?_\n  have := (atTop_neBot_iff.mp hne).2\n  rcases hfi with âŸ¨iâ‚€, hiâ‚€âŸ©\n  suffices Tendsto (âˆ« x in s iâ‚€, f x âˆ‚Î¼ - âˆ« x in s iâ‚€ \\ s Â·, f x âˆ‚Î¼) atTop\n      (ğ“ (âˆ« x in s iâ‚€, f x âˆ‚Î¼ - âˆ« x in â‹ƒ i, s iâ‚€ \\ s i, f x âˆ‚Î¼)) by\n    convert this.congr' <| (eventually_ge_atTop iâ‚€).mono fun i hi â†¦ ?_\n    Â· rw [â† diff_iInter, integral_diff _ hiâ‚€ (iInter_subset _ _), sub_sub_cancel]\n      exact .iInter_of_antitone h_anti hsm\n    Â· rw [integral_diff (hsm i) hiâ‚€ (h_anti hi), sub_sub_cancel]\n  apply tendsto_const_nhds.sub\n  refine tendsto_setIntegral_of_monotone (by measurability) ?_ ?_\n  Â· exact fun i j h â†¦ diff_subset_diff_right (h_anti h)\n  Â· rw [â† diff_iInter]\n    exact hiâ‚€.mono_set diff_subset\n\n"}
{"name":"MeasureTheory.hasSum_integral_iUnion_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\nÎ¹ : Type u_5\ninstâœ : Countable Î¹\ns : Î¹ â†’ Set X\nhm : âˆ€ (i : Î¹), MeasureTheory.NullMeasurableSet (s i) Î¼\nhd : Pairwise (Function.onFun (MeasureTheory.AEDisjoint Î¼) s)\nhfi : MeasureTheory.IntegrableOn f (Set.iUnion fun i => s i) Î¼\nâŠ¢ HasSum (fun n => MeasureTheory.integral (Î¼.restrict (s n)) fun x => f x) (MeasureTheory.integral (Î¼.restrict (Set.iUnion fun n => s n)) fun x => f x)","decl":"theorem hasSum_integral_iUnion_ae {Î¹ : Type*} [Countable Î¹] {s : Î¹ â†’ Set X}\n    (hm : âˆ€ i, NullMeasurableSet (s i) Î¼) (hd : Pairwise (AEDisjoint Î¼ on s))\n    (hfi : IntegrableOn f (â‹ƒ i, s i) Î¼) :\n    HasSum (fun n => âˆ« x in s n, f x âˆ‚Î¼) (âˆ« x in â‹ƒ n, s n, f x âˆ‚Î¼) := by\n  simp only [IntegrableOn, Measure.restrict_iUnion_ae hd hm] at hfi âŠ¢\n  exact hasSum_integral_measure hfi\n\n"}
{"name":"MeasureTheory.hasSum_integral_iUnion","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\nÎ¹ : Type u_5\ninstâœ : Countable Î¹\ns : Î¹ â†’ Set X\nhm : âˆ€ (i : Î¹), MeasurableSet (s i)\nhd : Pairwise (Function.onFun Disjoint s)\nhfi : MeasureTheory.IntegrableOn f (Set.iUnion fun i => s i) Î¼\nâŠ¢ HasSum (fun n => MeasureTheory.integral (Î¼.restrict (s n)) fun x => f x) (MeasureTheory.integral (Î¼.restrict (Set.iUnion fun n => s n)) fun x => f x)","decl":"theorem hasSum_integral_iUnion {Î¹ : Type*} [Countable Î¹] {s : Î¹ â†’ Set X}\n    (hm : âˆ€ i, MeasurableSet (s i)) (hd : Pairwise (Disjoint on s))\n    (hfi : IntegrableOn f (â‹ƒ i, s i) Î¼) :\n    HasSum (fun n => âˆ« x in s n, f x âˆ‚Î¼) (âˆ« x in â‹ƒ n, s n, f x âˆ‚Î¼) :=\n  hasSum_integral_iUnion_ae (fun i => (hm i).nullMeasurableSet) (hd.mono fun _ _ h => h.aedisjoint)\n    hfi\n\n"}
{"name":"MeasureTheory.integral_iUnion","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\nÎ¹ : Type u_5\ninstâœ : Countable Î¹\ns : Î¹ â†’ Set X\nhm : âˆ€ (i : Î¹), MeasurableSet (s i)\nhd : Pairwise (Function.onFun Disjoint s)\nhfi : MeasureTheory.IntegrableOn f (Set.iUnion fun i => s i) Î¼\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Set.iUnion fun n => s n)) fun x => f x) (tsum fun n => MeasureTheory.integral (Î¼.restrict (s n)) fun x => f x)","decl":"theorem integral_iUnion {Î¹ : Type*} [Countable Î¹] {s : Î¹ â†’ Set X} (hm : âˆ€ i, MeasurableSet (s i))\n    (hd : Pairwise (Disjoint on s)) (hfi : IntegrableOn f (â‹ƒ i, s i) Î¼) :\n    âˆ« x in â‹ƒ n, s n, f x âˆ‚Î¼ = âˆ‘' n, âˆ« x in s n, f x âˆ‚Î¼ :=\n  (HasSum.tsum_eq (hasSum_integral_iUnion hm hd hfi)).symm\n\n"}
{"name":"MeasureTheory.integral_iUnion_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\nÎ¹ : Type u_5\ninstâœ : Countable Î¹\ns : Î¹ â†’ Set X\nhm : âˆ€ (i : Î¹), MeasureTheory.NullMeasurableSet (s i) Î¼\nhd : Pairwise (Function.onFun (MeasureTheory.AEDisjoint Î¼) s)\nhfi : MeasureTheory.IntegrableOn f (Set.iUnion fun i => s i) Î¼\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Set.iUnion fun n => s n)) fun x => f x) (tsum fun n => MeasureTheory.integral (Î¼.restrict (s n)) fun x => f x)","decl":"theorem integral_iUnion_ae {Î¹ : Type*} [Countable Î¹] {s : Î¹ â†’ Set X}\n    (hm : âˆ€ i, NullMeasurableSet (s i) Î¼) (hd : Pairwise (AEDisjoint Î¼ on s))\n    (hfi : IntegrableOn f (â‹ƒ i, s i) Î¼) : âˆ« x in â‹ƒ n, s n, f x âˆ‚Î¼ = âˆ‘' n, âˆ« x in s n, f x âˆ‚Î¼ :=\n  (HasSum.tsum_eq (hasSum_integral_iUnion_ae hm hd hfi)).symm\n\n"}
{"name":"MeasureTheory.setIntegral_eq_zero_of_ae_eq_zero","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\nt : Set X\nÎ¼ : MeasureTheory.Measure X\nht_eq : Filter.Eventually (fun x => Membership.mem t x â†’ Eq (f x) 0) (MeasureTheory.ae Î¼)\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict t) fun x => f x) 0","decl":"theorem setIntegral_eq_zero_of_ae_eq_zero (ht_eq : âˆ€áµ x âˆ‚Î¼, x âˆˆ t â†’ f x = 0) :\n    âˆ« x in t, f x âˆ‚Î¼ = 0 := by\n  by_cases hf : AEStronglyMeasurable f (Î¼.restrict t); swap\n  Â· rw [integral_undef]\n    contrapose! hf\n    exact hf.1\n  have : âˆ« x in t, hf.mk f x âˆ‚Î¼ = 0 := by\n    refine integral_eq_zero_of_ae ?_\n    rw [EventuallyEq,\n      ae_restrict_iff (hf.stronglyMeasurable_mk.measurableSet_eq_fun stronglyMeasurable_zero)]\n    filter_upwards [ae_imp_of_ae_restrict hf.ae_eq_mk, ht_eq] with x hx h'x h''x\n    rw [â† hx h''x]\n    exact h'x h''x\n  rw [â† this]\n  exact integral_congr_ae hf.ae_eq_mk\n\n"}
{"name":"MeasureTheory.setIntegral_eq_zero_of_forall_eq_zero","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\nt : Set X\nÎ¼ : MeasureTheory.Measure X\nht_eq : âˆ€ (x : X), Membership.mem t x â†’ Eq (f x) 0\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict t) fun x => f x) 0","decl":"theorem setIntegral_eq_zero_of_forall_eq_zero (ht_eq : âˆ€ x âˆˆ t, f x = 0) :\n    âˆ« x in t, f x âˆ‚Î¼ = 0 :=\n  setIntegral_eq_zero_of_ae_eq_zero (Eventually.of_forall ht_eq)\n\n"}
{"name":"MeasureTheory.integral_union_eq_left_of_ae_aux","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns t : Set X\nÎ¼ : MeasureTheory.Measure X\nht_eq : Filter.Eventually (fun x => Eq (f x) 0) (MeasureTheory.ae (Î¼.restrict t))\nhaux : MeasureTheory.StronglyMeasurable f\nH : MeasureTheory.IntegrableOn f (Union.union s t) Î¼\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Union.union s t)) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => f x)","decl":"theorem integral_union_eq_left_of_ae_aux (ht_eq : âˆ€áµ x âˆ‚Î¼.restrict t, f x = 0)\n    (haux : StronglyMeasurable f) (H : IntegrableOn f (s âˆª t) Î¼) :\n    âˆ« x in s âˆª t, f x âˆ‚Î¼ = âˆ« x in s, f x âˆ‚Î¼ := by\n  let k := f â»Â¹' {0}\n  have hk : MeasurableSet k := by borelize E; exact haux.measurable (measurableSet_singleton _)\n  have h's : IntegrableOn f s Î¼ := H.mono subset_union_left le_rfl\n  have A : âˆ€ u : Set X, âˆ« x in u âˆ© k, f x âˆ‚Î¼ = 0 := fun u =>\n    setIntegral_eq_zero_of_forall_eq_zero fun x hx => hx.2\n  rw [â† integral_inter_add_diff hk h's, â† integral_inter_add_diff hk H, A, A, zero_add, zero_add,\n    union_diff_distrib, union_comm]\n  apply setIntegral_congr_set\n  rw [union_ae_eq_right]\n  apply measure_mono_null diff_subset\n  rw [measure_zero_iff_ae_nmem]\n  filter_upwards [ae_imp_of_ae_restrict ht_eq] with x hx h'x using h'x.2 (hx h'x.1)\n\n"}
{"name":"MeasureTheory.integral_union_eq_left_of_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns t : Set X\nÎ¼ : MeasureTheory.Measure X\nht_eq : Filter.Eventually (fun x => Eq (f x) 0) (MeasureTheory.ae (Î¼.restrict t))\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Union.union s t)) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => f x)","decl":"theorem integral_union_eq_left_of_ae (ht_eq : âˆ€áµ x âˆ‚Î¼.restrict t, f x = 0) :\n    âˆ« x in s âˆª t, f x âˆ‚Î¼ = âˆ« x in s, f x âˆ‚Î¼ := by\n  have ht : IntegrableOn f t Î¼ := by apply integrableOn_zero.congr_fun_ae; symm; exact ht_eq\n  by_cases H : IntegrableOn f (s âˆª t) Î¼; swap\n  Â· rw [integral_undef H, integral_undef]; simpa [integrableOn_union, ht] using H\n  let f' := H.1.mk f\n  calc\n    âˆ« x : X in s âˆª t, f x âˆ‚Î¼ = âˆ« x : X in s âˆª t, f' x âˆ‚Î¼ := integral_congr_ae H.1.ae_eq_mk\n    _ = âˆ« x in s, f' x âˆ‚Î¼ := by\n      apply\n        integral_union_eq_left_of_ae_aux _ H.1.stronglyMeasurable_mk (H.congr_fun_ae H.1.ae_eq_mk)\n      filter_upwards [ht_eq,\n        ae_mono (Measure.restrict_mono subset_union_right le_rfl) H.1.ae_eq_mk] with x hx h'x\n      rw [â† h'x, hx]\n    _ = âˆ« x in s, f x âˆ‚Î¼ :=\n      integral_congr_ae\n        (ae_mono (Measure.restrict_mono subset_union_left le_rfl) H.1.ae_eq_mk.symm)\n\n"}
{"name":"MeasureTheory.integral_union_eq_left_of_forallâ‚€","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\ns t : Set X\nÎ¼ : MeasureTheory.Measure X\nf : X â†’ E\nht : MeasureTheory.NullMeasurableSet t Î¼\nht_eq : âˆ€ (x : X), Membership.mem t x â†’ Eq (f x) 0\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Union.union s t)) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => f x)","decl":"theorem integral_union_eq_left_of_forallâ‚€ {f : X â†’ E} (ht : NullMeasurableSet t Î¼)\n    (ht_eq : âˆ€ x âˆˆ t, f x = 0) : âˆ« x in s âˆª t, f x âˆ‚Î¼ = âˆ« x in s, f x âˆ‚Î¼ :=\n  integral_union_eq_left_of_ae ((ae_restrict_iff'â‚€ ht).2 (Eventually.of_forall ht_eq))\n\n"}
{"name":"MeasureTheory.integral_union_eq_left_of_forall","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\ns t : Set X\nÎ¼ : MeasureTheory.Measure X\nf : X â†’ E\nht : MeasurableSet t\nht_eq : âˆ€ (x : X), Membership.mem t x â†’ Eq (f x) 0\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Union.union s t)) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => f x)","decl":"theorem integral_union_eq_left_of_forall {f : X â†’ E} (ht : MeasurableSet t)\n    (ht_eq : âˆ€ x âˆˆ t, f x = 0) : âˆ« x in s âˆª t, f x âˆ‚Î¼ = âˆ« x in s, f x âˆ‚Î¼ :=\n  integral_union_eq_left_of_forallâ‚€ ht.nullMeasurableSet ht_eq\n\n"}
{"name":"MeasureTheory.setIntegral_eq_of_subset_of_ae_diff_eq_zero_aux","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns t : Set X\nÎ¼ : MeasureTheory.Measure X\nhts : HasSubset.Subset s t\nh't : Filter.Eventually (fun x => Membership.mem (SDiff.sdiff t s) x â†’ Eq (f x) 0) (MeasureTheory.ae Î¼)\nhaux : MeasureTheory.StronglyMeasurable f\nh'aux : MeasureTheory.IntegrableOn f t Î¼\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict t) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => f x)","decl":"theorem setIntegral_eq_of_subset_of_ae_diff_eq_zero_aux (hts : s âŠ† t)\n    (h't : âˆ€áµ x âˆ‚Î¼, x âˆˆ t \\ s â†’ f x = 0) (haux : StronglyMeasurable f)\n    (h'aux : IntegrableOn f t Î¼) : âˆ« x in t, f x âˆ‚Î¼ = âˆ« x in s, f x âˆ‚Î¼ := by\n  let k := f â»Â¹' {0}\n  have hk : MeasurableSet k := by borelize E; exact haux.measurable (measurableSet_singleton _)\n  calc\n    âˆ« x in t, f x âˆ‚Î¼ = âˆ« x in t âˆ© k, f x âˆ‚Î¼ + âˆ« x in t \\ k, f x âˆ‚Î¼ := by\n      rw [integral_inter_add_diff hk h'aux]\n    _ = âˆ« x in t \\ k, f x âˆ‚Î¼ := by\n      rw [setIntegral_eq_zero_of_forall_eq_zero fun x hx => ?_, zero_add]; exact hx.2\n    _ = âˆ« x in s \\ k, f x âˆ‚Î¼ := by\n      apply setIntegral_congr_set\n      filter_upwards [h't] with x hx\n      change (x âˆˆ t \\ k) = (x âˆˆ s \\ k)\n      simp only [mem_preimage, mem_singleton_iff, eq_iff_iff, and_congr_left_iff, mem_diff]\n      intro h'x\n      by_cases xs : x âˆˆ s\n      Â· simp only [xs, hts xs]\n      Â· simp only [xs, iff_false]\n        intro xt\n        exact h'x (hx âŸ¨xt, xsâŸ©)\n    _ = âˆ« x in s âˆ© k, f x âˆ‚Î¼ + âˆ« x in s \\ k, f x âˆ‚Î¼ := by\n      have : âˆ€ x âˆˆ s âˆ© k, f x = 0 := fun x hx => hx.2\n      rw [setIntegral_eq_zero_of_forall_eq_zero this, zero_add]\n    _ = âˆ« x in s, f x âˆ‚Î¼ := by rw [integral_inter_add_diff hk (h'aux.mono hts le_rfl)]\n\n"}
{"name":"MeasureTheory.setIntegral_eq_of_subset_of_ae_diff_eq_zero","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns t : Set X\nÎ¼ : MeasureTheory.Measure X\nht : MeasureTheory.NullMeasurableSet t Î¼\nhts : HasSubset.Subset s t\nh't : Filter.Eventually (fun x => Membership.mem (SDiff.sdiff t s) x â†’ Eq (f x) 0) (MeasureTheory.ae Î¼)\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict t) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => f x)","decl":"/-- If a function vanishes almost everywhere on `t \\ s` with `s âŠ† t`, then its integrals on `s`\nand `t` coincide if `t` is null-measurable. -/\ntheorem setIntegral_eq_of_subset_of_ae_diff_eq_zero (ht : NullMeasurableSet t Î¼) (hts : s âŠ† t)\n    (h't : âˆ€áµ x âˆ‚Î¼, x âˆˆ t \\ s â†’ f x = 0) : âˆ« x in t, f x âˆ‚Î¼ = âˆ« x in s, f x âˆ‚Î¼ := by\n  by_cases h : IntegrableOn f t Î¼; swap\n  Â· have : Â¬IntegrableOn f s Î¼ := fun H => h (H.of_ae_diff_eq_zero ht h't)\n    rw [integral_undef h, integral_undef this]\n  let f' := h.1.mk f\n  calc\n    âˆ« x in t, f x âˆ‚Î¼ = âˆ« x in t, f' x âˆ‚Î¼ := integral_congr_ae h.1.ae_eq_mk\n    _ = âˆ« x in s, f' x âˆ‚Î¼ := by\n      apply\n        setIntegral_eq_of_subset_of_ae_diff_eq_zero_aux hts _ h.1.stronglyMeasurable_mk\n          (h.congr h.1.ae_eq_mk)\n      filter_upwards [h't, ae_imp_of_ae_restrict h.1.ae_eq_mk] with x hx h'x h''x\n      rw [â† h'x h''x.1, hx h''x]\n    _ = âˆ« x in s, f x âˆ‚Î¼ := by\n      apply integral_congr_ae\n      apply ae_restrict_of_ae_restrict_of_subset hts\n      exact h.1.ae_eq_mk.symm\n\n"}
{"name":"MeasureTheory.setIntegral_eq_of_subset_of_forall_diff_eq_zero","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns t : Set X\nÎ¼ : MeasureTheory.Measure X\nht : MeasurableSet t\nhts : HasSubset.Subset s t\nh't : âˆ€ (x : X), Membership.mem (SDiff.sdiff t s) x â†’ Eq (f x) 0\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict t) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => f x)","decl":"/-- If a function vanishes on `t \\ s` with `s âŠ† t`, then its integrals on `s`\nand `t` coincide if `t` is measurable. -/\ntheorem setIntegral_eq_of_subset_of_forall_diff_eq_zero (ht : MeasurableSet t) (hts : s âŠ† t)\n    (h't : âˆ€ x âˆˆ t \\ s, f x = 0) : âˆ« x in t, f x âˆ‚Î¼ = âˆ« x in s, f x âˆ‚Î¼ :=\n  setIntegral_eq_of_subset_of_ae_diff_eq_zero ht.nullMeasurableSet hts\n    (Eventually.of_forall fun x hx => h't x hx)\n\n"}
{"name":"MeasureTheory.setIntegral_eq_integral_of_ae_compl_eq_zero","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns : Set X\nÎ¼ : MeasureTheory.Measure X\nh : Filter.Eventually (fun x => Not (Membership.mem s x) â†’ Eq (f x) 0) (MeasureTheory.ae Î¼)\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral Î¼ fun x => f x)","decl":"/-- If a function vanishes almost everywhere on `sá¶œ`, then its integral on `s`\ncoincides with its integral on the whole space. -/\ntheorem setIntegral_eq_integral_of_ae_compl_eq_zero (h : âˆ€áµ x âˆ‚Î¼, x âˆ‰ s â†’ f x = 0) :\n    âˆ« x in s, f x âˆ‚Î¼ = âˆ« x, f x âˆ‚Î¼ := by\n  symm\n  nth_rw 1 [â† setIntegral_univ]\n  apply setIntegral_eq_of_subset_of_ae_diff_eq_zero nullMeasurableSet_univ (subset_univ _)\n  filter_upwards [h] with x hx h'x using hx h'x.2\n\n"}
{"name":"MeasureTheory.setIntegral_eq_integral_of_forall_compl_eq_zero","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns : Set X\nÎ¼ : MeasureTheory.Measure X\nh : âˆ€ (x : X), Not (Membership.mem s x) â†’ Eq (f x) 0\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral Î¼ fun x => f x)","decl":"/-- If a function vanishes on `sá¶œ`, then its integral on `s` coincides with its integral on the\nwhole space. -/\ntheorem setIntegral_eq_integral_of_forall_compl_eq_zero (h : âˆ€ x, x âˆ‰ s â†’ f x = 0) :\n    âˆ« x in s, f x âˆ‚Î¼ = âˆ« x, f x âˆ‚Î¼ :=\n  setIntegral_eq_integral_of_ae_compl_eq_zero (Eventually.of_forall h)\n\n"}
{"name":"MeasureTheory.setIntegral_neg_eq_setIntegral_nonpos","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nÎ¼ : MeasureTheory.Measure X\ninstâœ : LinearOrder E\nf : X â†’ E\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (setOf fun x => LT.lt (f x) 0)) fun x => f x) (MeasureTheory.integral (Î¼.restrict (setOf fun x => LE.le (f x) 0)) fun x => f x)","decl":"theorem setIntegral_neg_eq_setIntegral_nonpos [LinearOrder E] {f : X â†’ E}\n    (hf : AEStronglyMeasurable f Î¼) :\n    âˆ« x in {x | f x < 0}, f x âˆ‚Î¼ = âˆ« x in {x | f x â‰¤ 0}, f x âˆ‚Î¼ := by\n  have h_union : {x | f x â‰¤ 0} = {x | f x < 0} âˆª {x | f x = 0} := by\n    simp_rw [le_iff_lt_or_eq, setOf_or]\n  rw [h_union]\n  have B : NullMeasurableSet {x | f x = 0} Î¼ :=\n    hf.nullMeasurableSet_eq_fun aestronglyMeasurable_zero\n  symm\n  refine integral_union_eq_left_of_ae ?_\n  filter_upwards [ae_restrict_memâ‚€ B] with x hx using hx\n\n"}
{"name":"MeasureTheory.integral_norm_eq_pos_sub_neg","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf : X â†’ Real\nhfi : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => Norm.norm (f x)) (HSub.hSub (MeasureTheory.integral (Î¼.restrict (setOf fun x => LE.le 0 (f x))) fun x => f x) (MeasureTheory.integral (Î¼.restrict (setOf fun x => LE.le (f x) 0)) fun x => f x))","decl":"theorem integral_norm_eq_pos_sub_neg {f : X â†’ â„} (hfi : Integrable f Î¼) :\n    âˆ« x, â€–f xâ€– âˆ‚Î¼ = âˆ« x in {x | 0 â‰¤ f x}, f x âˆ‚Î¼ - âˆ« x in {x | f x â‰¤ 0}, f x âˆ‚Î¼ :=\n  have h_meas : NullMeasurableSet {x | 0 â‰¤ f x} Î¼ :=\n    aestronglyMeasurable_const.nullMeasurableSet_le hfi.1\n  calc\n    âˆ« x, â€–f xâ€– âˆ‚Î¼ = âˆ« x in {x | 0 â‰¤ f x}, â€–f xâ€– âˆ‚Î¼ + âˆ« x in {x | 0 â‰¤ f x}á¶œ, â€–f xâ€– âˆ‚Î¼ := by\n      rw [â† integral_add_complâ‚€ h_meas hfi.norm]\n    _ = âˆ« x in {x | 0 â‰¤ f x}, f x âˆ‚Î¼ + âˆ« x in {x | 0 â‰¤ f x}á¶œ, â€–f xâ€– âˆ‚Î¼ := by\n      congr 1\n      refine setIntegral_congr_funâ‚€ h_meas fun x hx => ?_\n      dsimp only\n      rw [Real.norm_eq_abs, abs_eq_self.mpr _]\n      exact hx\n    _ = âˆ« x in {x | 0 â‰¤ f x}, f x âˆ‚Î¼ - âˆ« x in {x | 0 â‰¤ f x}á¶œ, f x âˆ‚Î¼ := by\n      congr 1\n      rw [â† integral_neg]\n      refine setIntegral_congr_funâ‚€ h_meas.compl fun x hx => ?_\n      dsimp only\n      rw [Real.norm_eq_abs, abs_eq_neg_self.mpr _]\n      rw [Set.mem_compl_iff, Set.nmem_setOf_iff] at hx\n      linarith\n    _ = âˆ« x in {x | 0 â‰¤ f x}, f x âˆ‚Î¼ - âˆ« x in {x | f x â‰¤ 0}, f x âˆ‚Î¼ := by\n      rw [â† setIntegral_neg_eq_setIntegral_nonpos hfi.1, compl_setOf]; simp only [not_le]\n\n"}
{"name":"MeasureTheory.setIntegral_const","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ns : Set X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : CompleteSpace E\nc : E\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => c) (HSMul.hSMul (Î¼ s).toReal c)","decl":"theorem setIntegral_const [CompleteSpace E] (c : E) : âˆ« _ in s, c âˆ‚Î¼ = (Î¼ s).toReal â€¢ c := by\n  rw [integral_const, Measure.restrict_apply_univ]\n\n"}
{"name":"MeasureTheory.integral_indicator_const","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nÎ¼ : MeasureTheory.Measure X\ninstâœ : CompleteSpace E\ne : E\ns : Set X\ns_meas : MeasurableSet s\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => s.indicator (fun x => e) x) (HSMul.hSMul (Î¼ s).toReal e)","decl":"@[simp]\ntheorem integral_indicator_const [CompleteSpace E] (e : E) â¦ƒs : Set Xâ¦„ (s_meas : MeasurableSet s) :\n    âˆ« x : X, s.indicator (fun _ : X => e) x âˆ‚Î¼ = (Î¼ s).toReal â€¢ e := by\n  rw [integral_indicator s_meas, â† setIntegral_const]\n\n"}
{"name":"MeasureTheory.integral_indicator_one","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ns : Set X\nhs : MeasurableSet s\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => s.indicator 1 x) (Î¼ s).toReal","decl":"@[simp]\ntheorem integral_indicator_one â¦ƒs : Set Xâ¦„ (hs : MeasurableSet s) :\n    âˆ« x, s.indicator 1 x âˆ‚Î¼ = (Î¼ s).toReal :=\n  (integral_indicator_const 1 hs).trans ((smul_eq_mul _).trans (mul_one _))\n\n"}
{"name":"MeasureTheory.setIntegral_indicatorConstLp","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ns t : Set X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : CompleteSpace E\np : ENNReal\nhs : MeasurableSet s\nht : MeasurableSet t\nhÎ¼t : Ne (Î¼ t) Top.top\ne : E\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => â†‘â†‘(MeasureTheory.indicatorConstLp p ht hÎ¼t e) x) (HSMul.hSMul (Î¼ (Inter.inter t s)).toReal e)","decl":"theorem setIntegral_indicatorConstLp [CompleteSpace E]\n    {p : â„â‰¥0âˆ} (hs : MeasurableSet s) (ht : MeasurableSet t) (hÎ¼t : Î¼ t â‰  âˆ) (e : E) :\n    âˆ« x in s, indicatorConstLp p ht hÎ¼t e x âˆ‚Î¼ = (Î¼ (t âˆ© s)).toReal â€¢ e :=\n  calc\n    âˆ« x in s, indicatorConstLp p ht hÎ¼t e x âˆ‚Î¼ = âˆ« x in s, t.indicator (fun _ => e) x âˆ‚Î¼ := by\n      rw [setIntegral_congr_ae hs (indicatorConstLp_coeFn.mono fun x hx _ => hx)]\n    _ = (Î¼ (t âˆ© s)).toReal â€¢ e := by rw [integral_indicator_const _ ht, Measure.restrict_apply ht]\n\n"}
{"name":"MeasureTheory.integral_indicatorConstLp","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nt : Set X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : CompleteSpace E\np : ENNReal\nht : MeasurableSet t\nhÎ¼t : Ne (Î¼ t) Top.top\ne : E\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => â†‘â†‘(MeasureTheory.indicatorConstLp p ht hÎ¼t e) x) (HSMul.hSMul (Î¼ t).toReal e)","decl":"theorem integral_indicatorConstLp [CompleteSpace E]\n    {p : â„â‰¥0âˆ} (ht : MeasurableSet t) (hÎ¼t : Î¼ t â‰  âˆ) (e : E) :\n    âˆ« x, indicatorConstLp p ht hÎ¼t e x âˆ‚Î¼ = (Î¼ t).toReal â€¢ e :=\n  calc\n    âˆ« x, indicatorConstLp p ht hÎ¼t e x âˆ‚Î¼ = âˆ« x in univ, indicatorConstLp p ht hÎ¼t e x âˆ‚Î¼ := by\n      rw [setIntegral_univ]\n    _ = (Î¼ (t âˆ© univ)).toReal â€¢ e := setIntegral_indicatorConstLp MeasurableSet.univ ht hÎ¼t e\n    _ = (Î¼ t).toReal â€¢ e := by rw [inter_univ]\n\n"}
{"name":"MeasureTheory.setIntegral_map","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nÎ¼ : MeasureTheory.Measure X\nY : Type u_5\ninstâœ : MeasurableSpace Y\ng : X â†’ Y\nf : Y â†’ E\ns : Set Y\nhs : MeasurableSet s\nhf : MeasureTheory.AEStronglyMeasurable f (MeasureTheory.Measure.map g Î¼)\nhg : AEMeasurable g Î¼\nâŠ¢ Eq (MeasureTheory.integral ((MeasureTheory.Measure.map g Î¼).restrict s) fun y => f y) (MeasureTheory.integral (Î¼.restrict (Set.preimage g s)) fun x => f (g x))","decl":"theorem setIntegral_map {Y} [MeasurableSpace Y] {g : X â†’ Y} {f : Y â†’ E} {s : Set Y}\n    (hs : MeasurableSet s) (hf : AEStronglyMeasurable f (Measure.map g Î¼)) (hg : AEMeasurable g Î¼) :\n    âˆ« y in s, f y âˆ‚Measure.map g Î¼ = âˆ« x in g â»Â¹' s, f (g x) âˆ‚Î¼ := by\n  rw [Measure.restrict_map_of_aemeasurable hg hs,\n    integral_map (hg.mono_measure Measure.restrict_le_self) (hf.mono_measure _)]\n  exact Measure.map_mono_of_aemeasurable Measure.restrict_le_self hg\n\n"}
{"name":"MeasurableEmbedding.setIntegral_map","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ¼ : MeasureTheory.Measure X\nY : Type u_5\nxâœ : MeasurableSpace Y\nf : X â†’ Y\nhf : MeasurableEmbedding f\ng : Y â†’ E\ns : Set Y\nâŠ¢ Eq (MeasureTheory.integral ((MeasureTheory.Measure.map f Î¼).restrict s) fun y => g y) (MeasureTheory.integral (Î¼.restrict (Set.preimage f s)) fun x => g (f x))","decl":"theorem _root_.MeasurableEmbedding.setIntegral_map {Y} {_ : MeasurableSpace Y} {f : X â†’ Y}\n    (hf : MeasurableEmbedding f) (g : Y â†’ E) (s : Set Y) :\n    âˆ« y in s, g y âˆ‚Measure.map f Î¼ = âˆ« x in f â»Â¹' s, g (f x) âˆ‚Î¼ := by\n  rw [hf.restrict_map, hf.integral_map]\n\n"}
{"name":"Topology.IsClosedEmbedding.setIntegral_map","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœâ· : MeasurableSpace X\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\nÎ¼ : MeasureTheory.Measure X\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : BorelSpace X\nY : Type u_5\ninstâœÂ² : MeasurableSpace Y\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : BorelSpace Y\ng : X â†’ Y\nf : Y â†’ E\ns : Set Y\nhg : Topology.IsClosedEmbedding g\nâŠ¢ Eq (MeasureTheory.integral ((MeasureTheory.Measure.map g Î¼).restrict s) fun y => f y) (MeasureTheory.integral (Î¼.restrict (Set.preimage g s)) fun x => f (g x))","decl":"theorem _root_.Topology.IsClosedEmbedding.setIntegral_map [TopologicalSpace X] [BorelSpace X] {Y}\n    [MeasurableSpace Y] [TopologicalSpace Y] [BorelSpace Y] {g : X â†’ Y} {f : Y â†’ E} (s : Set Y)\n    (hg : IsClosedEmbedding g) : âˆ« y in s, f y âˆ‚Measure.map g Î¼ = âˆ« x in g â»Â¹' s, f (g x) âˆ‚Î¼ :=\n  hg.measurableEmbedding.setIntegral_map _ _\n\n"}
{"name":"ClosedEmbedding.setIntegral_map","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœâ· : MeasurableSpace X\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\nÎ¼ : MeasureTheory.Measure X\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : BorelSpace X\nY : Type u_5\ninstâœÂ² : MeasurableSpace Y\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : BorelSpace Y\ng : X â†’ Y\nf : Y â†’ E\ns : Set Y\nhg : Topology.IsClosedEmbedding g\nâŠ¢ Eq (MeasureTheory.integral ((MeasureTheory.Measure.map g Î¼).restrict s) fun y => f y) (MeasureTheory.integral (Î¼.restrict (Set.preimage g s)) fun x => f (g x))","decl":"@[deprecated (since := \"2024-10-20\")]\nalias _root_.ClosedEmbedding.setIntegral_map := IsClosedEmbedding.setIntegral_map\n\n"}
{"name":"MeasureTheory.MeasurePreserving.setIntegral_preimage_emb","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ¼ : MeasureTheory.Measure X\nY : Type u_5\nxâœ : MeasurableSpace Y\nf : X â†’ Y\nÎ½ : MeasureTheory.Measure Y\nhâ‚ : MeasureTheory.MeasurePreserving f Î¼ Î½\nhâ‚‚ : MeasurableEmbedding f\ng : Y â†’ E\ns : Set Y\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Set.preimage f s)) fun x => g (f x)) (MeasureTheory.integral (Î½.restrict s) fun y => g y)","decl":"theorem MeasurePreserving.setIntegral_preimage_emb {Y} {_ : MeasurableSpace Y} {f : X â†’ Y} {Î½}\n    (hâ‚ : MeasurePreserving f Î¼ Î½) (hâ‚‚ : MeasurableEmbedding f) (g : Y â†’ E) (s : Set Y) :\n    âˆ« x in f â»Â¹' s, g (f x) âˆ‚Î¼ = âˆ« y in s, g y âˆ‚Î½ :=\n  (hâ‚.restrict_preimage_emb hâ‚‚ s).integral_comp hâ‚‚ _\n\n"}
{"name":"MeasureTheory.MeasurePreserving.setIntegral_image_emb","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nÎ¼ : MeasureTheory.Measure X\nY : Type u_5\nxâœ : MeasurableSpace Y\nf : X â†’ Y\nÎ½ : MeasureTheory.Measure Y\nhâ‚ : MeasureTheory.MeasurePreserving f Î¼ Î½\nhâ‚‚ : MeasurableEmbedding f\ng : Y â†’ E\ns : Set X\nâŠ¢ Eq (MeasureTheory.integral (Î½.restrict (Set.image f s)) fun y => g y) (MeasureTheory.integral (Î¼.restrict s) fun x => g (f x))","decl":"theorem MeasurePreserving.setIntegral_image_emb {Y} {_ : MeasurableSpace Y} {f : X â†’ Y} {Î½}\n    (hâ‚ : MeasurePreserving f Î¼ Î½) (hâ‚‚ : MeasurableEmbedding f) (g : Y â†’ E) (s : Set X) :\n    âˆ« y in f '' s, g y âˆ‚Î½ = âˆ« x in s, g (f x) âˆ‚Î¼ :=\n  Eq.symm <| (hâ‚.restrict_image_emb hâ‚‚ s).integral_comp hâ‚‚ _\n\n"}
{"name":"MeasureTheory.setIntegral_map_equiv","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nÎ¼ : MeasureTheory.Measure X\nY : Type u_5\ninstâœ : MeasurableSpace Y\ne : MeasurableEquiv X Y\nf : Y â†’ E\ns : Set Y\nâŠ¢ Eq (MeasureTheory.integral ((MeasureTheory.Measure.map (â‡‘e) Î¼).restrict s) fun y => f y) (MeasureTheory.integral (Î¼.restrict (Set.preimage (â‡‘e) s)) fun x => f (e x))","decl":"theorem setIntegral_map_equiv {Y} [MeasurableSpace Y] (e : X â‰ƒáµ Y) (f : Y â†’ E) (s : Set Y) :\n    âˆ« y in s, f y âˆ‚Measure.map e Î¼ = âˆ« x in e â»Â¹' s, f (e x) âˆ‚Î¼ :=\n  e.measurableEmbedding.setIntegral_map f s\n\n"}
{"name":"MeasureTheory.norm_setIntegral_le_of_norm_le_const_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns : Set X\nÎ¼ : MeasureTheory.Measure X\nC : Real\nhs : LT.lt (Î¼ s) Top.top\nhC : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) C) (MeasureTheory.ae (Î¼.restrict s))\nâŠ¢ LE.le (Norm.norm (MeasureTheory.integral (Î¼.restrict s) fun x => f x)) (HMul.hMul C (Î¼ s).toReal)","decl":"theorem norm_setIntegral_le_of_norm_le_const_ae {C : â„} (hs : Î¼ s < âˆ)\n    (hC : âˆ€áµ x âˆ‚Î¼.restrict s, â€–f xâ€– â‰¤ C) : â€–âˆ« x in s, f x âˆ‚Î¼â€– â‰¤ C * (Î¼ s).toReal := by\n  rw [â† Measure.restrict_apply_univ] at *\n  haveI : IsFiniteMeasure (Î¼.restrict s) := âŸ¨hsâŸ©\n  exact norm_integral_le_of_norm_le_const hC\n\n"}
{"name":"MeasureTheory.norm_setIntegral_le_of_norm_le_const_ae'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns : Set X\nÎ¼ : MeasureTheory.Measure X\nC : Real\nhs : LT.lt (Î¼ s) Top.top\nhC : Filter.Eventually (fun x => Membership.mem s x â†’ LE.le (Norm.norm (f x)) C) (MeasureTheory.ae Î¼)\nhfm : MeasureTheory.AEStronglyMeasurable f (Î¼.restrict s)\nâŠ¢ LE.le (Norm.norm (MeasureTheory.integral (Î¼.restrict s) fun x => f x)) (HMul.hMul C (Î¼ s).toReal)","decl":"theorem norm_setIntegral_le_of_norm_le_const_ae' {C : â„} (hs : Î¼ s < âˆ)\n    (hC : âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ â€–f xâ€– â‰¤ C) (hfm : AEStronglyMeasurable f (Î¼.restrict s)) :\n    â€–âˆ« x in s, f x âˆ‚Î¼â€– â‰¤ C * (Î¼ s).toReal := by\n  apply norm_setIntegral_le_of_norm_le_const_ae hs\n  have A : âˆ€áµ x : X âˆ‚Î¼, x âˆˆ s â†’ â€–AEStronglyMeasurable.mk f hfm xâ€– â‰¤ C := by\n    filter_upwards [hC, hfm.ae_mem_imp_eq_mk] with _ h1 h2 h3\n    rw [â† h2 h3]\n    exact h1 h3\n  have B : MeasurableSet {x | â€–hfm.mk f xâ€– â‰¤ C} :=\n    hfm.stronglyMeasurable_mk.norm.measurable measurableSet_Iic\n  filter_upwards [hfm.ae_eq_mk, (ae_restrict_iff B).2 A] with _ h1 _\n  rwa [h1]\n\n"}
{"name":"MeasureTheory.norm_setIntegral_le_of_norm_le_const_ae''","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns : Set X\nÎ¼ : MeasureTheory.Measure X\nC : Real\nhs : LT.lt (Î¼ s) Top.top\nhsm : MeasurableSet s\nhC : Filter.Eventually (fun x => Membership.mem s x â†’ LE.le (Norm.norm (f x)) C) (MeasureTheory.ae Î¼)\nâŠ¢ LE.le (Norm.norm (MeasureTheory.integral (Î¼.restrict s) fun x => f x)) (HMul.hMul C (Î¼ s).toReal)","decl":"theorem norm_setIntegral_le_of_norm_le_const_ae'' {C : â„} (hs : Î¼ s < âˆ) (hsm : MeasurableSet s)\n    (hC : âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ â€–f xâ€– â‰¤ C) : â€–âˆ« x in s, f x âˆ‚Î¼â€– â‰¤ C * (Î¼ s).toReal :=\n  norm_setIntegral_le_of_norm_le_const_ae hs <| by\n    rwa [ae_restrict_eq hsm, eventually_inf_principal]\n\n"}
{"name":"MeasureTheory.norm_setIntegral_le_of_norm_le_const","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns : Set X\nÎ¼ : MeasureTheory.Measure X\nC : Real\nhs : LT.lt (Î¼ s) Top.top\nhC : âˆ€ (x : X), Membership.mem s x â†’ LE.le (Norm.norm (f x)) C\nhfm : MeasureTheory.AEStronglyMeasurable f (Î¼.restrict s)\nâŠ¢ LE.le (Norm.norm (MeasureTheory.integral (Î¼.restrict s) fun x => f x)) (HMul.hMul C (Î¼ s).toReal)","decl":"theorem norm_setIntegral_le_of_norm_le_const {C : â„} (hs : Î¼ s < âˆ) (hC : âˆ€ x âˆˆ s, â€–f xâ€– â‰¤ C)\n    (hfm : AEStronglyMeasurable f (Î¼.restrict s)) : â€–âˆ« x in s, f x âˆ‚Î¼â€– â‰¤ C * (Î¼ s).toReal :=\n  norm_setIntegral_le_of_norm_le_const_ae' hs (Eventually.of_forall hC) hfm\n\n"}
{"name":"MeasureTheory.norm_setIntegral_le_of_norm_le_const'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ E\ns : Set X\nÎ¼ : MeasureTheory.Measure X\nC : Real\nhs : LT.lt (Î¼ s) Top.top\nhsm : MeasurableSet s\nhC : âˆ€ (x : X), Membership.mem s x â†’ LE.le (Norm.norm (f x)) C\nâŠ¢ LE.le (Norm.norm (MeasureTheory.integral (Î¼.restrict s) fun x => f x)) (HMul.hMul C (Î¼ s).toReal)","decl":"theorem norm_setIntegral_le_of_norm_le_const' {C : â„} (hs : Î¼ s < âˆ) (hsm : MeasurableSet s)\n    (hC : âˆ€ x âˆˆ s, â€–f xâ€– â‰¤ C) : â€–âˆ« x in s, f x âˆ‚Î¼â€– â‰¤ C * (Î¼ s).toReal :=\n  norm_setIntegral_le_of_norm_le_const_ae'' hs hsm <| Eventually.of_forall hC\n\n"}
{"name":"MeasureTheory.setIntegral_eq_zero_iff_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\ns : Set X\nÎ¼ : MeasureTheory.Measure X\nf : X â†’ Real\nhf : (MeasureTheory.ae (Î¼.restrict s)).EventuallyLE 0 f\nhfi : MeasureTheory.IntegrableOn f s Î¼\nâŠ¢ Iff (Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) 0) ((MeasureTheory.ae (Î¼.restrict s)).EventuallyEq f 0)","decl":"theorem setIntegral_eq_zero_iff_of_nonneg_ae {f : X â†’ â„} (hf : 0 â‰¤áµ[Î¼.restrict s] f)\n    (hfi : IntegrableOn f s Î¼) : âˆ« x in s, f x âˆ‚Î¼ = 0 â†” f =áµ[Î¼.restrict s] 0 :=\n  integral_eq_zero_iff_of_nonneg_ae hf hfi\n\n"}
{"name":"MeasureTheory.setIntegral_pos_iff_support_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\ns : Set X\nÎ¼ : MeasureTheory.Measure X\nf : X â†’ Real\nhf : (MeasureTheory.ae (Î¼.restrict s)).EventuallyLE 0 f\nhfi : MeasureTheory.IntegrableOn f s Î¼\nâŠ¢ Iff (LT.lt 0 (MeasureTheory.integral (Î¼.restrict s) fun x => f x)) (LT.lt 0 (Î¼ (Inter.inter (Function.support f) s)))","decl":"theorem setIntegral_pos_iff_support_of_nonneg_ae {f : X â†’ â„} (hf : 0 â‰¤áµ[Î¼.restrict s] f)\n    (hfi : IntegrableOn f s Î¼) : (0 < âˆ« x in s, f x âˆ‚Î¼) â†” 0 < Î¼ (support f âˆ© s) := by\n  rw [integral_pos_iff_support_of_nonneg_ae hf hfi, Measure.restrict_applyâ‚€]\n  rw [support_eq_preimage]\n  exact hfi.aestronglyMeasurable.aemeasurable.nullMeasurable (measurableSet_singleton 0).compl\n\n"}
{"name":"MeasureTheory.setIntegral_gt_gt","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nR : Real\nf : X â†’ Real\nhR : LE.le 0 R\nhfint : MeasureTheory.IntegrableOn f (setOf fun x => LT.lt R (f x)) Î¼\nhÎ¼ : Ne (Î¼ (setOf fun x => LT.lt R (f x))) 0\nâŠ¢ LT.lt (HMul.hMul (Î¼ (setOf fun x => LT.lt R (f x))).toReal R) (MeasureTheory.integral (Î¼.restrict (setOf fun x => LT.lt R (f x))) fun x => f x)","decl":"theorem setIntegral_gt_gt {R : â„} {f : X â†’ â„} (hR : 0 â‰¤ R)\n    (hfint : IntegrableOn f {x | â†‘R < f x} Î¼) (hÎ¼ : Î¼ {x | â†‘R < f x} â‰  0) :\n    (Î¼ {x | â†‘R < f x}).toReal * R < âˆ« x in {x | â†‘R < f x}, f x âˆ‚Î¼ := by\n  have : IntegrableOn (fun _ => R) {x | â†‘R < f x} Î¼ := by\n    refine âŸ¨aestronglyMeasurable_const, lt_of_le_of_lt ?_ hfint.2âŸ©\n    refine setLIntegral_mono_ae hfint.1.enorm <| ae_of_all _ fun x hx => ?_\n    simp only [ENNReal.coe_le_coe, Real.nnnorm_of_nonneg hR, enorm_eq_nnnorm,\n      Real.nnnorm_of_nonneg (hR.trans <| le_of_lt hx), Subtype.mk_le_mk]\n    exact le_of_lt hx\n  rw [â† sub_pos, â† smul_eq_mul, â† setIntegral_const, â† integral_sub hfint this,\n    setIntegral_pos_iff_support_of_nonneg_ae]\n  Â· rw [â† zero_lt_iff] at hÎ¼\n    rwa [Set.inter_eq_self_of_subset_right]\n    exact fun x hx => Ne.symm (ne_of_lt <| sub_pos.2 hx)\n  Â· rw [Pi.zero_def, EventuallyLE, ae_restrict_iffâ‚€]\n    Â· exact Eventually.of_forall fun x hx => sub_nonneg.2 <| le_of_lt hx\n    Â· exact nullMeasurableSet_le aemeasurable_zero (hfint.1.aemeasurable.sub aemeasurable_const)\n  Â· exact Integrable.sub hfint this\n\n"}
{"name":"MeasureTheory.setIntegral_trim","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"E : Type u_3\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nX : Type u_5\nm m0 : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nhm : LE.le m m0\nf : X â†’ E\nhf_meas : MeasureTheory.StronglyMeasurable f\ns : Set X\nhs : MeasurableSet s\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral ((Î¼.trim hm).restrict s) fun x => f x)","decl":"theorem setIntegral_trim {X} {m m0 : MeasurableSpace X} {Î¼ : Measure X} (hm : m â‰¤ m0) {f : X â†’ E}\n    (hf_meas : StronglyMeasurable[m] f) {s : Set X} (hs : MeasurableSet[m] s) :\n    âˆ« x in s, f x âˆ‚Î¼ = âˆ« x in s, f x âˆ‚Î¼.trim hm := by\n  rwa [integral_trim hm hf_meas, restrict_trim hm Î¼]\n\n"}
{"name":"MeasureTheory.integral_Icc_eq_integral_Ioc'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\ninstâœ : PartialOrder X\nx y : X\nhx : Eq (Î¼ (Singleton.singleton x)) 0\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Set.Icc x y)) fun t => f t) (MeasureTheory.integral (Î¼.restrict (Set.Ioc x y)) fun t => f t)","decl":"theorem integral_Icc_eq_integral_Ioc' (hx : Î¼ {x} = 0) :\n    âˆ« t in Icc x y, f t âˆ‚Î¼ = âˆ« t in Ioc x y, f t âˆ‚Î¼ :=\n  setIntegral_congr_set (Ioc_ae_eq_Icc' hx).symm\n\n"}
{"name":"MeasureTheory.integral_Icc_eq_integral_Ico'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\ninstâœ : PartialOrder X\nx y : X\nhy : Eq (Î¼ (Singleton.singleton y)) 0\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Set.Icc x y)) fun t => f t) (MeasureTheory.integral (Î¼.restrict (Set.Ico x y)) fun t => f t)","decl":"theorem integral_Icc_eq_integral_Ico' (hy : Î¼ {y} = 0) :\n    âˆ« t in Icc x y, f t âˆ‚Î¼ = âˆ« t in Ico x y, f t âˆ‚Î¼ :=\n  setIntegral_congr_set (Ico_ae_eq_Icc' hy).symm\n\n"}
{"name":"MeasureTheory.integral_Ioc_eq_integral_Ioo'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\ninstâœ : PartialOrder X\nx y : X\nhy : Eq (Î¼ (Singleton.singleton y)) 0\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Set.Ioc x y)) fun t => f t) (MeasureTheory.integral (Î¼.restrict (Set.Ioo x y)) fun t => f t)","decl":"theorem integral_Ioc_eq_integral_Ioo' (hy : Î¼ {y} = 0) :\n    âˆ« t in Ioc x y, f t âˆ‚Î¼ = âˆ« t in Ioo x y, f t âˆ‚Î¼ :=\n  setIntegral_congr_set (Ioo_ae_eq_Ioc' hy).symm\n\n"}
{"name":"MeasureTheory.integral_Ico_eq_integral_Ioo'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\ninstâœ : PartialOrder X\nx y : X\nhx : Eq (Î¼ (Singleton.singleton x)) 0\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Set.Ico x y)) fun t => f t) (MeasureTheory.integral (Î¼.restrict (Set.Ioo x y)) fun t => f t)","decl":"theorem integral_Ico_eq_integral_Ioo' (hx : Î¼ {x} = 0) :\n    âˆ« t in Ico x y, f t âˆ‚Î¼ = âˆ« t in Ioo x y, f t âˆ‚Î¼ :=\n  setIntegral_congr_set (Ioo_ae_eq_Ico' hx).symm\n\n"}
{"name":"MeasureTheory.integral_Icc_eq_integral_Ioo'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\ninstâœ : PartialOrder X\nx y : X\nhx : Eq (Î¼ (Singleton.singleton x)) 0\nhy : Eq (Î¼ (Singleton.singleton y)) 0\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Set.Icc x y)) fun t => f t) (MeasureTheory.integral (Î¼.restrict (Set.Ioo x y)) fun t => f t)","decl":"theorem integral_Icc_eq_integral_Ioo' (hx : Î¼ {x} = 0) (hy : Î¼ {y} = 0) :\n    âˆ« t in Icc x y, f t âˆ‚Î¼ = âˆ« t in Ioo x y, f t âˆ‚Î¼ :=\n  setIntegral_congr_set (Ioo_ae_eq_Icc' hx hy).symm\n\n"}
{"name":"MeasureTheory.integral_Iic_eq_integral_Iio'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\ninstâœ : PartialOrder X\nx : X\nhx : Eq (Î¼ (Singleton.singleton x)) 0\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Set.Iic x)) fun t => f t) (MeasureTheory.integral (Î¼.restrict (Set.Iio x)) fun t => f t)","decl":"theorem integral_Iic_eq_integral_Iio' (hx : Î¼ {x} = 0) :\n    âˆ« t in Iic x, f t âˆ‚Î¼ = âˆ« t in Iio x, f t âˆ‚Î¼ :=\n  setIntegral_congr_set (Iio_ae_eq_Iic' hx).symm\n\n"}
{"name":"MeasureTheory.integral_Ici_eq_integral_Ioi'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ³ : MeasurableSpace X\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\ninstâœ : PartialOrder X\nx : X\nhx : Eq (Î¼ (Singleton.singleton x)) 0\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Set.Ici x)) fun t => f t) (MeasureTheory.integral (Î¼.restrict (Set.Ioi x)) fun t => f t)","decl":"theorem integral_Ici_eq_integral_Ioi' (hx : Î¼ {x} = 0) :\n    âˆ« t in Ici x, f t âˆ‚Î¼ = âˆ« t in Ioi x, f t âˆ‚Î¼ :=\n  setIntegral_congr_set (Ioi_ae_eq_Ici' hx).symm\n\n"}
{"name":"MeasureTheory.integral_Icc_eq_integral_Ioc","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœâ´ : MeasurableSpace X\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : PartialOrder X\nx y : X\ninstâœ : MeasureTheory.NoAtoms Î¼\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Set.Icc x y)) fun t => f t) (MeasureTheory.integral (Î¼.restrict (Set.Ioc x y)) fun t => f t)","decl":"theorem integral_Icc_eq_integral_Ioc : âˆ« t in Icc x y, f t âˆ‚Î¼ = âˆ« t in Ioc x y, f t âˆ‚Î¼ :=\n  integral_Icc_eq_integral_Ioc' <| measure_singleton x\n\n"}
{"name":"MeasureTheory.integral_Icc_eq_integral_Ico","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœâ´ : MeasurableSpace X\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : PartialOrder X\nx y : X\ninstâœ : MeasureTheory.NoAtoms Î¼\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Set.Icc x y)) fun t => f t) (MeasureTheory.integral (Î¼.restrict (Set.Ico x y)) fun t => f t)","decl":"theorem integral_Icc_eq_integral_Ico : âˆ« t in Icc x y, f t âˆ‚Î¼ = âˆ« t in Ico x y, f t âˆ‚Î¼ :=\n  integral_Icc_eq_integral_Ico' <| measure_singleton y\n\n"}
{"name":"MeasureTheory.integral_Ioc_eq_integral_Ioo","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœâ´ : MeasurableSpace X\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : PartialOrder X\nx y : X\ninstâœ : MeasureTheory.NoAtoms Î¼\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Set.Ioc x y)) fun t => f t) (MeasureTheory.integral (Î¼.restrict (Set.Ioo x y)) fun t => f t)","decl":"theorem integral_Ioc_eq_integral_Ioo : âˆ« t in Ioc x y, f t âˆ‚Î¼ = âˆ« t in Ioo x y, f t âˆ‚Î¼ :=\n  integral_Ioc_eq_integral_Ioo' <| measure_singleton y\n\n"}
{"name":"MeasureTheory.integral_Ico_eq_integral_Ioo","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœâ´ : MeasurableSpace X\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : PartialOrder X\nx y : X\ninstâœ : MeasureTheory.NoAtoms Î¼\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Set.Ico x y)) fun t => f t) (MeasureTheory.integral (Î¼.restrict (Set.Ioo x y)) fun t => f t)","decl":"theorem integral_Ico_eq_integral_Ioo : âˆ« t in Ico x y, f t âˆ‚Î¼ = âˆ« t in Ioo x y, f t âˆ‚Î¼ :=\n  integral_Ico_eq_integral_Ioo' <| measure_singleton x\n\n"}
{"name":"MeasureTheory.integral_Icc_eq_integral_Ioo","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœâ´ : MeasurableSpace X\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : PartialOrder X\nx y : X\ninstâœ : MeasureTheory.NoAtoms Î¼\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Set.Icc x y)) fun t => f t) (MeasureTheory.integral (Î¼.restrict (Set.Ioo x y)) fun t => f t)","decl":"theorem integral_Icc_eq_integral_Ioo : âˆ« t in Icc x y, f t âˆ‚Î¼ = âˆ« t in Ioo x y, f t âˆ‚Î¼ := by\n  rw [integral_Icc_eq_integral_Ico, integral_Ico_eq_integral_Ioo]\n\n"}
{"name":"MeasureTheory.integral_Iic_eq_integral_Iio","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœâ´ : MeasurableSpace X\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : PartialOrder X\nx : X\ninstâœ : MeasureTheory.NoAtoms Î¼\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Set.Iic x)) fun t => f t) (MeasureTheory.integral (Î¼.restrict (Set.Iio x)) fun t => f t)","decl":"theorem integral_Iic_eq_integral_Iio : âˆ« t in Iic x, f t âˆ‚Î¼ = âˆ« t in Iio x, f t âˆ‚Î¼ :=\n  integral_Iic_eq_integral_Iio' <| measure_singleton x\n\n"}
{"name":"MeasureTheory.integral_Ici_eq_integral_Ioi","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœâ´ : MeasurableSpace X\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\nf : X â†’ E\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : PartialOrder X\nx : X\ninstâœ : MeasureTheory.NoAtoms Î¼\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Set.Ici x)) fun t => f t) (MeasureTheory.integral (Î¼.restrict (Set.Ioi x)) fun t => f t)","decl":"theorem integral_Ici_eq_integral_Ioi : âˆ« t in Ici x, f t âˆ‚Î¼ = âˆ« t in Ioi x, f t âˆ‚Î¼ :=\n  integral_Ici_eq_integral_Ioi' <| measure_singleton x\n\n"}
{"name":"MeasureTheory.setIntegral_mono_ae_restrict","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf g : X â†’ Real\ns : Set X\nhf : MeasureTheory.IntegrableOn f s Î¼\nhg : MeasureTheory.IntegrableOn g s Î¼\nh : (MeasureTheory.ae (Î¼.restrict s)).EventuallyLE f g\nâŠ¢ LE.le (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => g x)","decl":"theorem setIntegral_mono_ae_restrict (h : f â‰¤áµ[Î¼.restrict s] g) :\n    âˆ« x in s, f x âˆ‚Î¼ â‰¤ âˆ« x in s, g x âˆ‚Î¼ :=\n  integral_mono_ae hf hg h\n\n"}
{"name":"MeasureTheory.setIntegral_mono_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf g : X â†’ Real\ns : Set X\nhf : MeasureTheory.IntegrableOn f s Î¼\nhg : MeasureTheory.IntegrableOn g s Î¼\nh : (MeasureTheory.ae Î¼).EventuallyLE f g\nâŠ¢ LE.le (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => g x)","decl":"theorem setIntegral_mono_ae (h : f â‰¤áµ[Î¼] g) : âˆ« x in s, f x âˆ‚Î¼ â‰¤ âˆ« x in s, g x âˆ‚Î¼ :=\n  setIntegral_mono_ae_restrict hf hg (ae_restrict_of_ae h)\n\n"}
{"name":"MeasureTheory.setIntegral_mono_on","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf g : X â†’ Real\ns : Set X\nhf : MeasureTheory.IntegrableOn f s Î¼\nhg : MeasureTheory.IntegrableOn g s Î¼\nhs : MeasurableSet s\nh : âˆ€ (x : X), Membership.mem s x â†’ LE.le (f x) (g x)\nâŠ¢ LE.le (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => g x)","decl":"theorem setIntegral_mono_on (hs : MeasurableSet s) (h : âˆ€ x âˆˆ s, f x â‰¤ g x) :\n    âˆ« x in s, f x âˆ‚Î¼ â‰¤ âˆ« x in s, g x âˆ‚Î¼ :=\n  setIntegral_mono_ae_restrict hf hg\n    (by simp [hs, EventuallyLE, eventually_inf_principal, ae_of_all _ h])\n\n"}
{"name":"MeasureTheory.setIntegral_mono_on_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf g : X â†’ Real\ns : Set X\nhf : MeasureTheory.IntegrableOn f s Î¼\nhg : MeasureTheory.IntegrableOn g s Î¼\nhs : MeasurableSet s\nh : Filter.Eventually (fun x => Membership.mem s x â†’ LE.le (f x) (g x)) (MeasureTheory.ae Î¼)\nâŠ¢ LE.le (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => g x)","decl":"theorem setIntegral_mono_on_ae (hs : MeasurableSet s) (h : âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ f x â‰¤ g x) :\n    âˆ« x in s, f x âˆ‚Î¼ â‰¤ âˆ« x in s, g x âˆ‚Î¼ := by\n  refine setIntegral_mono_ae_restrict hf hg ?_; rwa [EventuallyLE, ae_restrict_iff' hs]\n\n"}
{"name":"MeasureTheory.setIntegral_mono","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf g : X â†’ Real\ns : Set X\nhf : MeasureTheory.IntegrableOn f s Î¼\nhg : MeasureTheory.IntegrableOn g s Î¼\nh : LE.le f g\nâŠ¢ LE.le (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => g x)","decl":"theorem setIntegral_mono (h : f â‰¤ g) : âˆ« x in s, f x âˆ‚Î¼ â‰¤ âˆ« x in s, g x âˆ‚Î¼ :=\n  integral_mono hf hg h\n\n"}
{"name":"MeasureTheory.setIntegral_mono_set","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf : X â†’ Real\ns t : Set X\nhfi : MeasureTheory.IntegrableOn f t Î¼\nhf : (MeasureTheory.ae (Î¼.restrict t)).EventuallyLE 0 f\nhst : (MeasureTheory.ae Î¼).EventuallyLE s t\nâŠ¢ LE.le (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict t) fun x => f x)","decl":"theorem setIntegral_mono_set (hfi : IntegrableOn f t Î¼) (hf : 0 â‰¤áµ[Î¼.restrict t] f)\n    (hst : s â‰¤áµ[Î¼] t) : âˆ« x in s, f x âˆ‚Î¼ â‰¤ âˆ« x in t, f x âˆ‚Î¼ :=\n  integral_mono_measure (Measure.restrict_mono_ae hst) hf hfi\n\n"}
{"name":"MeasureTheory.setIntegral_le_integral","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf : X â†’ Real\ns : Set X\nhfi : MeasureTheory.Integrable f Î¼\nhf : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nâŠ¢ LE.le (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral Î¼ fun x => f x)","decl":"theorem setIntegral_le_integral (hfi : Integrable f Î¼) (hf : 0 â‰¤áµ[Î¼] f) :\n    âˆ« x in s, f x âˆ‚Î¼ â‰¤ âˆ« x, f x âˆ‚Î¼ :=\n  integral_mono_measure (Measure.restrict_le_self) hf hfi\n\n"}
{"name":"MeasureTheory.setIntegral_ge_of_const_le","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf : X â†’ Real\ns : Set X\nc : Real\nhs : MeasurableSet s\nhÎ¼s : Ne (Î¼ s) Top.top\nhf : âˆ€ (x : X), Membership.mem s x â†’ LE.le c (f x)\nhfint : MeasureTheory.IntegrableOn (fun x => f x) s Î¼\nâŠ¢ LE.le (HMul.hMul c (Î¼ s).toReal) (MeasureTheory.integral (Î¼.restrict s) fun x => f x)","decl":"theorem setIntegral_ge_of_const_le {c : â„} (hs : MeasurableSet s) (hÎ¼s : Î¼ s â‰  âˆ)\n    (hf : âˆ€ x âˆˆ s, c â‰¤ f x) (hfint : IntegrableOn (fun x : X => f x) s Î¼) :\n    c * (Î¼ s).toReal â‰¤ âˆ« x in s, f x âˆ‚Î¼ := by\n  rw [mul_comm, â† smul_eq_mul, â† setIntegral_const c]\n  exact setIntegral_mono_on (integrableOn_const.2 (Or.inr hÎ¼s.lt_top)) hfint hs hf\n\n"}
{"name":"MeasureTheory.setIntegral_nonneg_of_ae_restrict","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf : X â†’ Real\ns : Set X\nhf : (MeasureTheory.ae (Î¼.restrict s)).EventuallyLE 0 f\nâŠ¢ LE.le 0 (MeasureTheory.integral (Î¼.restrict s) fun x => f x)","decl":"theorem setIntegral_nonneg_of_ae_restrict (hf : 0 â‰¤áµ[Î¼.restrict s] f) : 0 â‰¤ âˆ« x in s, f x âˆ‚Î¼ :=\n  integral_nonneg_of_ae hf\n\n"}
{"name":"MeasureTheory.setIntegral_nonneg_of_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf : X â†’ Real\ns : Set X\nhf : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nâŠ¢ LE.le 0 (MeasureTheory.integral (Î¼.restrict s) fun x => f x)","decl":"theorem setIntegral_nonneg_of_ae (hf : 0 â‰¤áµ[Î¼] f) : 0 â‰¤ âˆ« x in s, f x âˆ‚Î¼ :=\n  setIntegral_nonneg_of_ae_restrict (ae_restrict_of_ae hf)\n\n"}
{"name":"MeasureTheory.setIntegral_nonneg","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf : X â†’ Real\ns : Set X\nhs : MeasurableSet s\nhf : âˆ€ (x : X), Membership.mem s x â†’ LE.le 0 (f x)\nâŠ¢ LE.le 0 (MeasureTheory.integral (Î¼.restrict s) fun x => f x)","decl":"theorem setIntegral_nonneg (hs : MeasurableSet s) (hf : âˆ€ x, x âˆˆ s â†’ 0 â‰¤ f x) :\n    0 â‰¤ âˆ« x in s, f x âˆ‚Î¼ :=\n  setIntegral_nonneg_of_ae_restrict ((ae_restrict_iff' hs).mpr (ae_of_all Î¼ hf))\n\n"}
{"name":"MeasureTheory.setIntegral_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf : X â†’ Real\ns : Set X\nhs : MeasurableSet s\nhf : Filter.Eventually (fun x => Membership.mem s x â†’ LE.le 0 (f x)) (MeasureTheory.ae Î¼)\nâŠ¢ LE.le 0 (MeasureTheory.integral (Î¼.restrict s) fun x => f x)","decl":"theorem setIntegral_nonneg_ae (hs : MeasurableSet s) (hf : âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ 0 â‰¤ f x) :\n    0 â‰¤ âˆ« x in s, f x âˆ‚Î¼ :=\n  setIntegral_nonneg_of_ae_restrict <| by rwa [EventuallyLE, ae_restrict_iff' hs]\n\n"}
{"name":"MeasureTheory.setIntegral_le_nonneg","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf : X â†’ Real\ns : Set X\nhs : MeasurableSet s\nhf : MeasureTheory.StronglyMeasurable f\nhfi : MeasureTheory.Integrable f Î¼\nâŠ¢ LE.le (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict (setOf fun y => LE.le 0 (f y))) fun x => f x)","decl":"theorem setIntegral_le_nonneg {s : Set X} (hs : MeasurableSet s) (hf : StronglyMeasurable f)\n    (hfi : Integrable f Î¼) : âˆ« x in s, f x âˆ‚Î¼ â‰¤ âˆ« x in {y | 0 â‰¤ f y}, f x âˆ‚Î¼ := by\n  rw [â† integral_indicator hs, â†\n    integral_indicator (stronglyMeasurable_const.measurableSet_le hf)]\n  exact\n    integral_mono (hfi.indicator hs)\n      (hfi.indicator (stronglyMeasurable_const.measurableSet_le hf))\n      (indicator_le_indicator_nonneg s f)\n\n"}
{"name":"MeasureTheory.setIntegral_nonpos_of_ae_restrict","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf : X â†’ Real\ns : Set X\nhf : (MeasureTheory.ae (Î¼.restrict s)).EventuallyLE f 0\nâŠ¢ LE.le (MeasureTheory.integral (Î¼.restrict s) fun x => f x) 0","decl":"theorem setIntegral_nonpos_of_ae_restrict (hf : f â‰¤áµ[Î¼.restrict s] 0) : âˆ« x in s, f x âˆ‚Î¼ â‰¤ 0 :=\n  integral_nonpos_of_ae hf\n\n"}
{"name":"MeasureTheory.setIntegral_nonpos_of_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf : X â†’ Real\ns : Set X\nhf : (MeasureTheory.ae Î¼).EventuallyLE f 0\nâŠ¢ LE.le (MeasureTheory.integral (Î¼.restrict s) fun x => f x) 0","decl":"theorem setIntegral_nonpos_of_ae (hf : f â‰¤áµ[Î¼] 0) : âˆ« x in s, f x âˆ‚Î¼ â‰¤ 0 :=\n  setIntegral_nonpos_of_ae_restrict (ae_restrict_of_ae hf)\n\n"}
{"name":"MeasureTheory.setIntegral_nonpos_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf : X â†’ Real\ns : Set X\nhs : MeasurableSet s\nhf : Filter.Eventually (fun x => Membership.mem s x â†’ LE.le (f x) 0) (MeasureTheory.ae Î¼)\nâŠ¢ LE.le (MeasureTheory.integral (Î¼.restrict s) fun x => f x) 0","decl":"theorem setIntegral_nonpos_ae (hs : MeasurableSet s) (hf : âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ f x â‰¤ 0) :\n    âˆ« x in s, f x âˆ‚Î¼ â‰¤ 0 :=\n  setIntegral_nonpos_of_ae_restrict <| by rwa [EventuallyLE, ae_restrict_iff' hs]\n\n"}
{"name":"MeasureTheory.setIntegral_nonpos","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf : X â†’ Real\ns : Set X\nhs : MeasurableSet s\nhf : âˆ€ (x : X), Membership.mem s x â†’ LE.le (f x) 0\nâŠ¢ LE.le (MeasureTheory.integral (Î¼.restrict s) fun x => f x) 0","decl":"theorem setIntegral_nonpos (hs : MeasurableSet s) (hf : âˆ€ x, x âˆˆ s â†’ f x â‰¤ 0) :\n    âˆ« x in s, f x âˆ‚Î¼ â‰¤ 0 :=\n  setIntegral_nonpos_ae hs <| ae_of_all Î¼ hf\n\n"}
{"name":"MeasureTheory.setIntegral_nonpos_le","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf : X â†’ Real\ns : Set X\nhs : MeasurableSet s\nhf : MeasureTheory.StronglyMeasurable f\nhfi : MeasureTheory.Integrable f Î¼\nâŠ¢ LE.le (MeasureTheory.integral (Î¼.restrict (setOf fun y => LE.le (f y) 0)) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => f x)","decl":"theorem setIntegral_nonpos_le {s : Set X} (hs : MeasurableSet s) (hf : StronglyMeasurable f)\n    (hfi : Integrable f Î¼) : âˆ« x in {y | f y â‰¤ 0}, f x âˆ‚Î¼ â‰¤ âˆ« x in s, f x âˆ‚Î¼ := by\n  rw [â† integral_indicator hs, â†\n    integral_indicator (hf.measurableSet_le stronglyMeasurable_const)]\n  exact\n    integral_mono (hfi.indicator (hf.measurableSet_le stronglyMeasurable_const))\n      (hfi.indicator hs) (indicator_nonpos_le_indicator s f)\n\n"}
{"name":"MeasureTheory.Integrable.measure_le_integral","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf : X â†’ Real\nf_int : MeasureTheory.Integrable f Î¼\nf_nonneg : (MeasureTheory.ae Î¼).EventuallyLE 0 f\ns : Set X\nhs : âˆ€ (x : X), Membership.mem s x â†’ LE.le 1 (f x)\nâŠ¢ LE.le (Î¼ s) (ENNReal.ofReal (MeasureTheory.integral Î¼ fun x => f x))","decl":"lemma Integrable.measure_le_integral {f : X â†’ â„} (f_int : Integrable f Î¼) (f_nonneg : 0 â‰¤áµ[Î¼] f)\n    {s : Set X} (hs : âˆ€ x âˆˆ s, 1 â‰¤ f x) :\n    Î¼ s â‰¤ ENNReal.ofReal (âˆ« x, f x âˆ‚Î¼) := by\n  rw [ofReal_integral_eq_lintegral_ofReal f_int f_nonneg]\n  apply meas_le_lintegralâ‚€\n  Â· exact ENNReal.continuous_ofReal.measurable.comp_aemeasurable f_int.1.aemeasurable\n  Â· intro x hx\n    simpa using ENNReal.ofReal_le_ofReal (hs x hx)\n\n"}
{"name":"MeasureTheory.integral_le_measure","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf : X â†’ Real\ns : Set X\nhs : âˆ€ (x : X), Membership.mem s x â†’ LE.le (f x) 1\nh's : âˆ€ (x : X), Membership.mem (HasCompl.compl s) x â†’ LE.le (f x) 0\nâŠ¢ LE.le (ENNReal.ofReal (MeasureTheory.integral Î¼ fun x => f x)) (Î¼ s)","decl":"lemma integral_le_measure {f : X â†’ â„} {s : Set X}\n    (hs : âˆ€ x âˆˆ s, f x â‰¤ 1) (h's : âˆ€ x âˆˆ sá¶œ, f x â‰¤ 0) :\n    ENNReal.ofReal (âˆ« x, f x âˆ‚Î¼) â‰¤ Î¼ s := by\n  by_cases H : Integrable f Î¼; swap\n  Â· simp [integral_undef H]\n  let g x := max (f x) 0\n  have g_int : Integrable g Î¼ := H.pos_part\n  have : ENNReal.ofReal (âˆ« x, f x âˆ‚Î¼) â‰¤ ENNReal.ofReal (âˆ« x, g x âˆ‚Î¼) := by\n    apply ENNReal.ofReal_le_ofReal\n    exact integral_mono H g_int (fun x â†¦ le_max_left _ _)\n  apply this.trans\n  rw [ofReal_integral_eq_lintegral_ofReal g_int (Eventually.of_forall (fun x â†¦ le_max_right _ _))]\n  apply lintegral_le_meas\n  Â· intro x\n    apply ENNReal.ofReal_le_of_le_toReal\n    by_cases H : x âˆˆ s\n    Â· simpa [g] using hs x H\n    Â· apply le_trans _ zero_le_one\n      simpa [g] using h's x H\n  Â· intro x hx\n    simpa [g] using h's x hx\n\n"}
{"name":"MeasureTheory.integrableOn_iUnion_of_summable_integral_norm","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\nÎ¹ : Type u_5\ninstâœÂ¹ : Countable Î¹\nÎ¼ : MeasureTheory.Measure X\ninstâœ : NormedAddCommGroup E\nf : X â†’ E\ns : Î¹ â†’ Set X\nhs : âˆ€ (i : Î¹), MeasurableSet (s i)\nhi : âˆ€ (i : Î¹), MeasureTheory.IntegrableOn f (s i) Î¼\nh : Summable fun i => MeasureTheory.integral (Î¼.restrict (s i)) fun x => Norm.norm (f x)\nâŠ¢ MeasureTheory.IntegrableOn f (Set.iUnion s) Î¼","decl":"theorem integrableOn_iUnion_of_summable_integral_norm {f : X â†’ E} {s : Î¹ â†’ Set X}\n    (hs : âˆ€ i : Î¹, MeasurableSet (s i)) (hi : âˆ€ i : Î¹, IntegrableOn f (s i) Î¼)\n    (h : Summable fun i : Î¹ => âˆ« x : X in s i, â€–f xâ€– âˆ‚Î¼) : IntegrableOn f (iUnion s) Î¼ := by\n  refine âŸ¨AEStronglyMeasurable.iUnion fun i => (hi i).1, (lintegral_iUnion_le _ _).trans_lt ?_âŸ©\n  have B := fun i => lintegral_coe_eq_integral (fun x : X => â€–f xâ€–â‚Š) (hi i).norm\n  simp_rw [enorm_eq_nnnorm, tsum_congr B]\n  have S' :\n    Summable fun i : Î¹ =>\n      (âŸ¨âˆ« x : X in s i, â€–f xâ€–â‚Š âˆ‚Î¼, setIntegral_nonneg (hs i) fun x _ => NNReal.coe_nonneg _âŸ© :\n        NNReal) := by\n    rw [â† NNReal.summable_coe]; exact h\n  have S'' := ENNReal.tsum_coe_eq S'.hasSum\n  simp_rw [ENNReal.coe_nnreal_eq, NNReal.coe_mk, coe_nnnorm] at S''\n  convert ENNReal.ofReal_lt_top\n\n"}
{"name":"MeasureTheory.integrableOn_iUnion_of_summable_norm_restrict","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœâ¶ : MeasurableSpace X\nÎ¹ : Type u_5\ninstâœâµ : Countable Î¹\nÎ¼ : MeasureTheory.Measure X\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : BorelSpace X\ninstâœÂ¹ : TopologicalSpace.MetrizableSpace X\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nf : ContinuousMap X E\ns : Î¹ â†’ TopologicalSpace.Compacts X\nhf : Summable fun i => HMul.hMul (Norm.norm (ContinuousMap.restrict (â†‘(s i)) f)) (Î¼ â†‘(s i)).toReal\nâŠ¢ MeasureTheory.IntegrableOn (â‡‘f) (Set.iUnion fun i => â†‘(s i)) Î¼","decl":"/-- If `s` is a countable family of compact sets, `f` is a continuous function, and the sequence\n`â€–f.restrict (s i)â€– * Î¼ (s i)` is summable, then `f` is integrable on the union of the `s i`. -/\ntheorem integrableOn_iUnion_of_summable_norm_restrict {f : C(X, E)} {s : Î¹ â†’ Compacts X}\n    (hf : Summable fun i : Î¹ => â€–f.restrict (s i)â€– * ENNReal.toReal (Î¼ <| s i)) :\n    IntegrableOn f (â‹ƒ i : Î¹, s i) Î¼ := by\n  refine\n    integrableOn_iUnion_of_summable_integral_norm (fun i => (s i).isCompact.isClosed.measurableSet)\n      (fun i => (map_continuous f).continuousOn.integrableOn_compact (s i).isCompact)\n      (.of_nonneg_of_le (fun Î¹ => integral_nonneg fun x => norm_nonneg _) (fun i => ?_) hf)\n  rw [â† (Real.norm_of_nonneg (integral_nonneg fun x => norm_nonneg _) : â€–_â€– = âˆ« x in s i, â€–f xâ€– âˆ‚Î¼)]\n  exact\n    norm_setIntegral_le_of_norm_le_const' (s i).isCompact.measure_lt_top\n      (s i).isCompact.isClosed.measurableSet fun x hx =>\n      (norm_norm (f x)).symm â–¸ (f.restrict (s i : Set X)).norm_coe_le_norm âŸ¨x, hxâŸ©\n\n"}
{"name":"MeasureTheory.integrable_of_summable_norm_restrict","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœâ¶ : MeasurableSpace X\nÎ¹ : Type u_5\ninstâœâµ : Countable Î¹\nÎ¼ : MeasureTheory.Measure X\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : BorelSpace X\ninstâœÂ¹ : TopologicalSpace.MetrizableSpace X\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nf : ContinuousMap X E\ns : Î¹ â†’ TopologicalSpace.Compacts X\nhf : Summable fun i => HMul.hMul (Norm.norm (ContinuousMap.restrict (â†‘(s i)) f)) (Î¼ â†‘(s i)).toReal\nhs : Eq (Set.iUnion fun i => â†‘(s i)) Set.univ\nâŠ¢ MeasureTheory.Integrable (â‡‘f) Î¼","decl":"/-- If `s` is a countable family of compact sets covering `X`, `f` is a continuous function, and\nthe sequence `â€–f.restrict (s i)â€– * Î¼ (s i)` is summable, then `f` is integrable. -/\ntheorem integrable_of_summable_norm_restrict {f : C(X, E)} {s : Î¹ â†’ Compacts X}\n    (hf : Summable fun i : Î¹ => â€–f.restrict (s i)â€– * ENNReal.toReal (Î¼ <| s i))\n    (hs : â‹ƒ i : Î¹, â†‘(s i) = (univ : Set X)) : Integrable f Î¼ := by\n  simpa only [hs, integrableOn_univ] using integrableOn_iUnion_of_summable_norm_restrict hf\n\n"}
{"name":"MeasureTheory.Lp_toLp_restrict_add","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : NormedAddCommGroup E\np : ENNReal\nÎ¼ : MeasureTheory.Measure X\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Î¼) x\ns : Set X\nâŠ¢ Eq (MeasureTheory.Memâ„’p.toLp â†‘â†‘(HAdd.hAdd f g) â‹¯) (HAdd.hAdd (MeasureTheory.Memâ„’p.toLp â†‘â†‘f â‹¯) (MeasureTheory.Memâ„’p.toLp â†‘â†‘g â‹¯))","decl":"/-- For `f : Lp E p Î¼`, we can define an element of `Lp E p (Î¼.restrict s)` by\n`(Lp.memâ„’p f).restrict s).toLp f`. This map is additive. -/\ntheorem Lp_toLp_restrict_add (f g : Lp E p Î¼) (s : Set X) :\n    ((Lp.memâ„’p (f + g)).restrict s).toLp (â‡‘(f + g)) =\n      ((Lp.memâ„’p f).restrict s).toLp f + ((Lp.memâ„’p g).restrict s).toLp g := by\n  ext1\n  refine (ae_restrict_of_ae (Lp.coeFn_add f g)).mp ?_\n  refine\n    (Lp.coeFn_add (Memâ„’p.toLp f ((Lp.memâ„’p f).restrict s))\n          (Memâ„’p.toLp g ((Lp.memâ„’p g).restrict s))).mp ?_\n  refine (Memâ„’p.coeFn_toLp ((Lp.memâ„’p f).restrict s)).mp ?_\n  refine (Memâ„’p.coeFn_toLp ((Lp.memâ„’p g).restrict s)).mp ?_\n  refine (Memâ„’p.coeFn_toLp ((Lp.memâ„’p (f + g)).restrict s)).mono fun x hx1 hx2 hx3 hx4 hx5 => ?_\n  rw [hx4, hx1, Pi.add_apply, hx2, hx3, hx5, Pi.add_apply]\n\n"}
{"name":"MeasureTheory.Lp_toLp_restrict_smul","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nF : Type u_4\ninstâœÂ³ : MeasurableSpace X\nğ•œ : Type u_5\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\np : ENNReal\nÎ¼ : MeasureTheory.Measure X\nc : ğ•œ\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp F p Î¼) x\ns : Set X\nâŠ¢ Eq (MeasureTheory.Memâ„’p.toLp â†‘â†‘(HSMul.hSMul c f) â‹¯) (HSMul.hSMul c (MeasureTheory.Memâ„’p.toLp â†‘â†‘f â‹¯))","decl":"/-- For `f : Lp E p Î¼`, we can define an element of `Lp E p (Î¼.restrict s)` by\n`(Lp.memâ„’p f).restrict s).toLp f`. This map commutes with scalar multiplication. -/\ntheorem Lp_toLp_restrict_smul (c : ğ•œ) (f : Lp F p Î¼) (s : Set X) :\n    ((Lp.memâ„’p (c â€¢ f)).restrict s).toLp (â‡‘(c â€¢ f)) = c â€¢ ((Lp.memâ„’p f).restrict s).toLp f := by\n  ext1\n  refine (ae_restrict_of_ae (Lp.coeFn_smul c f)).mp ?_\n  refine (Memâ„’p.coeFn_toLp ((Lp.memâ„’p f).restrict s)).mp ?_\n  refine (Memâ„’p.coeFn_toLp ((Lp.memâ„’p (c â€¢ f)).restrict s)).mp ?_\n  refine\n    (Lp.coeFn_smul c (Memâ„’p.toLp f ((Lp.memâ„’p f).restrict s))).mono fun x hx1 hx2 hx3 hx4 => ?_\n  simp only [hx2, hx1, hx3, hx4, Pi.smul_apply]\n\n"}
{"name":"MeasureTheory.norm_Lp_toLp_restrict_le","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : NormedAddCommGroup E\np : ENNReal\nÎ¼ : MeasureTheory.Measure X\ns : Set X\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Î¼) x\nâŠ¢ LE.le (Norm.norm (MeasureTheory.Memâ„’p.toLp â†‘â†‘f â‹¯)) (Norm.norm f)","decl":"/-- For `f : Lp E p Î¼`, we can define an element of `Lp E p (Î¼.restrict s)` by\n`(Lp.memâ„’p f).restrict s).toLp f`. This map is non-expansive. -/\ntheorem norm_Lp_toLp_restrict_le (s : Set X) (f : Lp E p Î¼) :\n    â€–((Lp.memâ„’p f).restrict s).toLp fâ€– â‰¤ â€–fâ€– := by\n  rw [Lp.norm_def, Lp.norm_def, eLpNorm_congr_ae (Memâ„’p.coeFn_toLp _)]\n  refine ENNReal.toReal_mono (Lp.eLpNorm_ne_top _) ?_\n  exact eLpNorm_mono_measure _ Measure.restrict_le_self\n\n"}
{"name":"MeasureTheory.LpToLpRestrictCLM_coeFn","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nF : Type u_4\ninstâœâ´ : MeasurableSpace X\nğ•œ : Type u_5\ninstâœÂ³ : NormedField ğ•œ\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\np : ENNReal\nÎ¼ : MeasureTheory.Measure X\ninstâœ : Fact (LE.le 1 p)\ns : Set X\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp F p Î¼) x\nâŠ¢ (MeasureTheory.ae (Î¼.restrict s)).EventuallyEq â†‘â†‘((MeasureTheory.LpToLpRestrictCLM X F ğ•œ Î¼ p s) f) â†‘â†‘f","decl":"variable (ğ•œ) in\ntheorem LpToLpRestrictCLM_coeFn [Fact (1 â‰¤ p)] (s : Set X) (f : Lp F p Î¼) :\n    LpToLpRestrictCLM X F ğ•œ Î¼ p s f =áµ[Î¼.restrict s] f :=\n  Memâ„’p.coeFn_toLp ((Lp.memâ„’p f).restrict s)\n\n"}
{"name":"MeasureTheory.continuous_setIntegral","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\ninstâœÂ¹ : NormedAddCommGroup E\nÎ¼ : MeasureTheory.Measure X\ninstâœ : NormedSpace Real E\ns : Set X\nâŠ¢ Continuous fun f => MeasureTheory.integral (Î¼.restrict s) fun x => â†‘â†‘f x","decl":"@[continuity]\ntheorem continuous_setIntegral [NormedSpace â„ E] (s : Set X) :\n    Continuous fun f : X â†’â‚[Î¼] E => âˆ« x in s, f x âˆ‚Î¼ := by\n  haveI : Fact ((1 : â„â‰¥0âˆ) â‰¤ 1) := âŸ¨le_rflâŸ©\n  have h_comp :\n    (fun f : X â†’â‚[Î¼] E => âˆ« x in s, f x âˆ‚Î¼) =\n      integral (Î¼.restrict s) âˆ˜ fun f => LpToLpRestrictCLM X E â„ Î¼ 1 s f := by\n    ext1 f\n    rw [Function.comp_apply, integral_congr_ae (LpToLpRestrictCLM_coeFn â„ s f)]\n  rw [h_comp]\n  exact continuous_integral.comp (LpToLpRestrictCLM X E â„ Î¼ 1 s).continuous\n\n"}
{"name":"Continuous.integral_pos_of_hasCompactSupport_nonneg_nonzero","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœâ´ : MeasurableSpace X\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : OpensMeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : Î¼.IsOpenPosMeasure\ninstâœ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼\nf : X â†’ Real\nx : X\nf_cont : Continuous f\nf_comp : HasCompactSupport f\nf_nonneg : LE.le 0 f\nf_x : Ne (f x) 0\nâŠ¢ LT.lt 0 (MeasureTheory.integral Î¼ fun x => f x)","decl":"theorem Continuous.integral_pos_of_hasCompactSupport_nonneg_nonzero [IsFiniteMeasureOnCompacts Î¼]\n    {f : X â†’ â„} {x : X} (f_cont : Continuous f) (f_comp : HasCompactSupport f) (f_nonneg : 0 â‰¤ f)\n    (f_x : f x â‰  0) : 0 < âˆ« x, f x âˆ‚Î¼ :=\n  integral_pos_of_integrable_nonneg_nonzero f_cont (f_cont.integrable_of_hasCompactSupport f_comp)\n    f_nonneg f_x\n\n"}
{"name":"MeasureTheory.setIntegral_support","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nM : Type u_5\ninstâœÂ¹ : NormedAddCommGroup M\ninstâœ : NormedSpace Real M\nmX : MeasurableSpace X\nÎ½ : MeasureTheory.Measure X\nF : X â†’ M\nâŠ¢ Eq (MeasureTheory.integral (Î½.restrict (Function.support F)) fun x => F x) (MeasureTheory.integral Î½ fun x => F x)","decl":"theorem MeasureTheory.setIntegral_support : âˆ« x in support F, F x âˆ‚Î½ = âˆ« x, F x âˆ‚Î½ := by\n  nth_rw 2 [â† setIntegral_univ]\n  rw [setIntegral_eq_of_subset_of_forall_diff_eq_zero MeasurableSet.univ (subset_univ (support F))]\n  exact fun _ hx => nmem_support.mp <| not_mem_of_mem_diff hx\n\n"}
{"name":"MeasureTheory.setIntegral_tsupport","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nM : Type u_5\ninstâœÂ² : NormedAddCommGroup M\ninstâœÂ¹ : NormedSpace Real M\nmX : MeasurableSpace X\nÎ½ : MeasureTheory.Measure X\nF : X â†’ M\ninstâœ : TopologicalSpace X\nâŠ¢ Eq (MeasureTheory.integral (Î½.restrict (tsupport F)) fun x => F x) (MeasureTheory.integral Î½ fun x => F x)","decl":"theorem MeasureTheory.setIntegral_tsupport [TopologicalSpace X] :\n    âˆ« x in tsupport F, F x âˆ‚Î½ = âˆ« x, F x âˆ‚Î½ := by\n  nth_rw 2 [â† setIntegral_univ]\n  rw [setIntegral_eq_of_subset_of_forall_diff_eq_zero MeasurableSet.univ (subset_univ (tsupport F))]\n  exact fun _ hx => image_eq_zero_of_nmem_tsupport <| not_mem_of_mem_diff hx\n\n"}
{"name":"Filter.Tendsto.integral_sub_linear_isLittleO_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœâ´ : MeasurableSpace X\nÎ¹ : Type u_5\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\nÎ¼ : MeasureTheory.Measure X\nl : Filter X\ninstâœ : l.IsMeasurablyGenerated\nf : X â†’ E\nb : E\nh : Filter.Tendsto f (Min.min l (MeasureTheory.ae Î¼)) (nhds b)\nhfm : StronglyMeasurableAtFilter f l Î¼\nhÎ¼ : Î¼.FiniteAtFilter l\ns : Î¹ â†’ Set X\nli : Filter Î¹\nhs : Filter.Tendsto s li l.smallSets\nm : optParam (Î¹ â†’ Real) fun i => (Î¼ (s i)).toReal\nhsÎ¼ : autoParam (li.EventuallyEq (fun i => (Î¼ (s i)).toReal) m) _autoâœ\nâŠ¢ Asymptotics.IsLittleO li (fun i => HSub.hSub (MeasureTheory.integral (Î¼.restrict (s i)) fun x => f x) (HSMul.hSMul (m i) b)) m","decl":"/-- Fundamental theorem of calculus for set integrals:\nif `Î¼` is a measure that is finite at a filter `l` and\n`f` is a measurable function that has a finite limit `b` at `l âŠ“ ae Î¼`, then\n`âˆ« x in s i, f x âˆ‚Î¼ = Î¼ (s i) â€¢ b + o(Î¼ (s i))` at a filter `li` provided that\n`s i` tends to `l.smallSets` along `li`.\nSince `Î¼ (s i)` is an `â„â‰¥0âˆ` number, we use `(Î¼ (s i)).toReal` in the actual statement.\n\nOften there is a good formula for `(Î¼ (s i)).toReal`, so the formalization can take an optional\nargument `m` with this formula and a proof of `(fun i => (Î¼ (s i)).toReal) =á¶ [li] m`. Without these\narguments, `m i = (Î¼ (s i)).toReal` is used in the output. -/\ntheorem Filter.Tendsto.integral_sub_linear_isLittleO_ae\n    {Î¼ : Measure X} {l : Filter X} [l.IsMeasurablyGenerated] {f : X â†’ E} {b : E}\n    (h : Tendsto f (l âŠ“ ae Î¼) (ğ“ b)) (hfm : StronglyMeasurableAtFilter f l Î¼)\n    (hÎ¼ : Î¼.FiniteAtFilter l) {s : Î¹ â†’ Set X} {li : Filter Î¹} (hs : Tendsto s li l.smallSets)\n    (m : Î¹ â†’ â„ := fun i => (Î¼ (s i)).toReal)\n    (hsÎ¼ : (fun i => (Î¼ (s i)).toReal) =á¶ [li] m := by rfl) :\n    (fun i => (âˆ« x in s i, f x âˆ‚Î¼) - m i â€¢ b) =o[li] m := by\n  suffices\n      (fun s => (âˆ« x in s, f x âˆ‚Î¼) - (Î¼ s).toReal â€¢ b) =o[l.smallSets] fun s => (Î¼ s).toReal from\n    (this.comp_tendsto hs).congr'\n      (hsÎ¼.mono fun a ha => by dsimp only [Function.comp_apply] at ha âŠ¢; rw [ha]) hsÎ¼\n  refine isLittleO_iff.2 fun Îµ Îµâ‚€ => ?_\n  have : âˆ€á¶  s in l.smallSets, âˆ€áµ x âˆ‚Î¼, x âˆˆ s â†’ f x âˆˆ closedBall b Îµ :=\n    eventually_smallSets_eventually.2 (h.eventually <| closedBall_mem_nhds _ Îµâ‚€)\n  filter_upwards [hÎ¼.eventually, (hÎ¼.integrableAtFilter_of_tendsto_ae hfm h).eventually,\n    hfm.eventually, this]\n  simp only [mem_closedBall, dist_eq_norm]\n  intro s hÎ¼s h_integrable hfm h_norm\n  rw [â† setIntegral_const, â† integral_sub h_integrable (integrableOn_const.2 <| Or.inr hÎ¼s),\n    Real.norm_eq_abs, abs_of_nonneg ENNReal.toReal_nonneg]\n  exact norm_setIntegral_le_of_norm_le_const_ae' hÎ¼s h_norm (hfm.sub aestronglyMeasurable_const)\n\n"}
{"name":"ContinuousWithinAt.integral_sub_linear_isLittleO_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœâ¶ : MeasurableSpace X\nÎ¹ : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : CompleteSpace E\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : OpensMeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nx : X\nt : Set X\nf : X â†’ E\nhx : ContinuousWithinAt f t x\nht : MeasurableSet t\nhfm : StronglyMeasurableAtFilter f (nhdsWithin x t) Î¼\ns : Î¹ â†’ Set X\nli : Filter Î¹\nhs : Filter.Tendsto s li (nhdsWithin x t).smallSets\nm : optParam (Î¹ â†’ Real) fun i => (Î¼ (s i)).toReal\nhsÎ¼ : autoParam (li.EventuallyEq (fun i => (Î¼ (s i)).toReal) m) _autoâœ\nâŠ¢ Asymptotics.IsLittleO li (fun i => HSub.hSub (MeasureTheory.integral (Î¼.restrict (s i)) fun x => f x) (HSMul.hSMul (m i) (f x))) m","decl":"/-- Fundamental theorem of calculus for set integrals, `nhdsWithin` version: if `Î¼` is a locally\nfinite measure and `f` is an almost everywhere measurable function that is continuous at a point `a`\nwithin a measurable set `t`, then `âˆ« x in s i, f x âˆ‚Î¼ = Î¼ (s i) â€¢ f a + o(Î¼ (s i))` at a filter `li`\nprovided that `s i` tends to `(ğ“[t] a).smallSets` along `li`.  Since `Î¼ (s i)` is an `â„â‰¥0âˆ`\nnumber, we use `(Î¼ (s i)).toReal` in the actual statement.\n\nOften there is a good formula for `(Î¼ (s i)).toReal`, so the formalization can take an optional\nargument `m` with this formula and a proof of `(fun i => (Î¼ (s i)).toReal) =á¶ [li] m`. Without these\narguments, `m i = (Î¼ (s i)).toReal` is used in the output. -/\ntheorem ContinuousWithinAt.integral_sub_linear_isLittleO_ae [TopologicalSpace X]\n    [OpensMeasurableSpace X] {Î¼ : Measure X}\n    [IsLocallyFiniteMeasure Î¼] {x : X} {t : Set X} {f : X â†’ E} (hx : ContinuousWithinAt f t x)\n    (ht : MeasurableSet t) (hfm : StronglyMeasurableAtFilter f (ğ“[t] x) Î¼) {s : Î¹ â†’ Set X}\n    {li : Filter Î¹} (hs : Tendsto s li (ğ“[t] x).smallSets) (m : Î¹ â†’ â„ := fun i => (Î¼ (s i)).toReal)\n    (hsÎ¼ : (fun i => (Î¼ (s i)).toReal) =á¶ [li] m := by rfl) :\n    (fun i => (âˆ« x in s i, f x âˆ‚Î¼) - m i â€¢ f x) =o[li] m :=\n  haveI : (ğ“[t] x).IsMeasurablyGenerated := ht.nhdsWithin_isMeasurablyGenerated _\n  (hx.mono_left inf_le_left).integral_sub_linear_isLittleO_ae hfm (Î¼.finiteAt_nhdsWithin x t) hs m\n    hsÎ¼\n\n"}
{"name":"ContinuousAt.integral_sub_linear_isLittleO_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœâ¶ : MeasurableSpace X\nÎ¹ : Type u_5\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : CompleteSpace E\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : OpensMeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nx : X\nf : X â†’ E\nhx : ContinuousAt f x\nhfm : StronglyMeasurableAtFilter f (nhds x) Î¼\ns : Î¹ â†’ Set X\nli : Filter Î¹\nhs : Filter.Tendsto s li (nhds x).smallSets\nm : optParam (Î¹ â†’ Real) fun i => (Î¼ (s i)).toReal\nhsÎ¼ : autoParam (li.EventuallyEq (fun i => (Î¼ (s i)).toReal) m) _autoâœ\nâŠ¢ Asymptotics.IsLittleO li (fun i => HSub.hSub (MeasureTheory.integral (Î¼.restrict (s i)) fun x => f x) (HSMul.hSMul (m i) (f x))) m","decl":"/-- Fundamental theorem of calculus for set integrals, `nhds` version: if `Î¼` is a locally finite\nmeasure and `f` is an almost everywhere measurable function that is continuous at a point `a`, then\n`âˆ« x in s i, f x âˆ‚Î¼ = Î¼ (s i) â€¢ f a + o(Î¼ (s i))` at `li` provided that `s` tends to\n`(ğ“ a).smallSets` along `li`. Since `Î¼ (s i)` is an `â„â‰¥0âˆ` number, we use `(Î¼ (s i)).toReal` in\nthe actual statement.\n\nOften there is a good formula for `(Î¼ (s i)).toReal`, so the formalization can take an optional\nargument `m` with this formula and a proof of `(fun i => (Î¼ (s i)).toReal) =á¶ [li] m`. Without these\narguments, `m i = (Î¼ (s i)).toReal` is used in the output. -/\ntheorem ContinuousAt.integral_sub_linear_isLittleO_ae [TopologicalSpace X] [OpensMeasurableSpace X]\n    {Î¼ : Measure X} [IsLocallyFiniteMeasure Î¼] {x : X}\n    {f : X â†’ E} (hx : ContinuousAt f x) (hfm : StronglyMeasurableAtFilter f (ğ“ x) Î¼) {s : Î¹ â†’ Set X}\n    {li : Filter Î¹} (hs : Tendsto s li (ğ“ x).smallSets) (m : Î¹ â†’ â„ := fun i => (Î¼ (s i)).toReal)\n    (hsÎ¼ : (fun i => (Î¼ (s i)).toReal) =á¶ [li] m := by rfl) :\n    (fun i => (âˆ« x in s i, f x âˆ‚Î¼) - m i â€¢ f x) =o[li] m :=\n  (hx.mono_left inf_le_left).integral_sub_linear_isLittleO_ae hfm (Î¼.finiteAt_nhds x) hs m hsÎ¼\n\n"}
{"name":"ContinuousOn.integral_sub_linear_isLittleO_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœâ· : MeasurableSpace X\nÎ¹ : Type u_5\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\ninstâœâ´ : CompleteSpace E\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : OpensMeasurableSpace X\ninstâœÂ¹ : SecondCountableTopologyEither X E\nÎ¼ : MeasureTheory.Measure X\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nx : X\nt : Set X\nf : X â†’ E\nhft : ContinuousOn f t\nhx : Membership.mem t x\nht : MeasurableSet t\ns : Î¹ â†’ Set X\nli : Filter Î¹\nhs : Filter.Tendsto s li (nhdsWithin x t).smallSets\nm : optParam (Î¹ â†’ Real) fun i => (Î¼ (s i)).toReal\nhsÎ¼ : autoParam (li.EventuallyEq (fun i => (Î¼ (s i)).toReal) m) _autoâœ\nâŠ¢ Asymptotics.IsLittleO li (fun i => HSub.hSub (MeasureTheory.integral (Î¼.restrict (s i)) fun x => f x) (HSMul.hSMul (m i) (f x))) m","decl":"/-- Fundamental theorem of calculus for set integrals, `nhdsWithin` version: if `Î¼` is a locally\nfinite measure, `f` is continuous on a measurable set `t`, and `a âˆˆ t`, then `âˆ« x in (s i), f x âˆ‚Î¼ =\nÎ¼ (s i) â€¢ f a + o(Î¼ (s i))` at `li` provided that `s i` tends to `(ğ“[t] a).smallSets` along `li`.\nSince `Î¼ (s i)` is an `â„â‰¥0âˆ` number, we use `(Î¼ (s i)).toReal` in the actual statement.\n\nOften there is a good formula for `(Î¼ (s i)).toReal`, so the formalization can take an optional\nargument `m` with this formula and a proof of `(fun i => (Î¼ (s i)).toReal) =á¶ [li] m`. Without these\narguments, `m i = (Î¼ (s i)).toReal` is used in the output. -/\ntheorem ContinuousOn.integral_sub_linear_isLittleO_ae [TopologicalSpace X] [OpensMeasurableSpace X]\n    [SecondCountableTopologyEither X E] {Î¼ : Measure X}\n    [IsLocallyFiniteMeasure Î¼] {x : X} {t : Set X} {f : X â†’ E} (hft : ContinuousOn f t) (hx : x âˆˆ t)\n    (ht : MeasurableSet t) {s : Î¹ â†’ Set X} {li : Filter Î¹} (hs : Tendsto s li (ğ“[t] x).smallSets)\n    (m : Î¹ â†’ â„ := fun i => (Î¼ (s i)).toReal)\n    (hsÎ¼ : (fun i => (Î¼ (s i)).toReal) =á¶ [li] m := by rfl) :\n    (fun i => (âˆ« x in s i, f x âˆ‚Î¼) - m i â€¢ f x) =o[li] m :=\n  (hft x hx).integral_sub_linear_isLittleO_ae ht\n    âŸ¨t, self_mem_nhdsWithin, hft.aestronglyMeasurable htâŸ© hs m hsÎ¼\n\n"}
{"name":"ContinuousLinearMap.integral_compLp","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ•œ : Type u_5\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\np : ENNReal\ninstâœ : NormedSpace Real F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E F\nÏ† : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Î¼) x\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => â†‘â†‘(L.compLp Ï†) x) (MeasureTheory.integral Î¼ fun x => L (â†‘â†‘Ï† x))","decl":"theorem integral_compLp (L : E â†’L[ğ•œ] F) (Ï† : Lp E p Î¼) :\n    âˆ« x, (L.compLp Ï†) x âˆ‚Î¼ = âˆ« x, L (Ï† x) âˆ‚Î¼ :=\n  integral_congr_ae <| coeFn_compLp _ _\n\n"}
{"name":"ContinuousLinearMap.setIntegral_compLp","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ•œ : Type u_5\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\np : ENNReal\ninstâœ : NormedSpace Real F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E F\nÏ† : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Î¼) x\ns : Set X\nhs : MeasurableSet s\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => â†‘â†‘(L.compLp Ï†) x) (MeasureTheory.integral (Î¼.restrict s) fun x => L (â†‘â†‘Ï† x))","decl":"theorem setIntegral_compLp (L : E â†’L[ğ•œ] F) (Ï† : Lp E p Î¼) {s : Set X} (hs : MeasurableSet s) :\n    âˆ« x in s, (L.compLp Ï†) x âˆ‚Î¼ = âˆ« x in s, L (Ï† x) âˆ‚Î¼ :=\n  setIntegral_congr_ae hs ((L.coeFn_compLp Ï†).mono fun _x hx _ => hx)\n\n"}
{"name":"ContinuousLinearMap.continuous_integral_comp_L1","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ•œ : Type u_5\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ninstâœ : NormedSpace Real F\nL : ContinuousLinearMap (RingHom.id ğ•œ) E F\nâŠ¢ Continuous fun Ï† => MeasureTheory.integral Î¼ fun x => L (â†‘â†‘Ï† x)","decl":"theorem continuous_integral_comp_L1 (L : E â†’L[ğ•œ] F) :\n    Continuous fun Ï† : X â†’â‚[Î¼] E => âˆ« x : X, L (Ï† x) âˆ‚Î¼ := by\n  rw [â† funext L.integral_compLp]; exact continuous_integral.comp (L.compLpL 1 Î¼).continuous\n\n"}
{"name":"ContinuousLinearMap.integral_comp_comm","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninstâœâ¹ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ•œ : Type u_5\ninstâœâ¸ : RCLike ğ•œ\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : NormedSpace Real F\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nL : ContinuousLinearMap (RingHom.id ğ•œ) E F\nÏ† : X â†’ E\nÏ†_int : MeasureTheory.Integrable Ï† Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => L (Ï† x)) (L (MeasureTheory.integral Î¼ fun x => Ï† x))","decl":"theorem integral_comp_comm [CompleteSpace E] (L : E â†’L[ğ•œ] F) {Ï† : X â†’ E} (Ï†_int : Integrable Ï† Î¼) :\n    âˆ« x, L (Ï† x) âˆ‚Î¼ = L (âˆ« x, Ï† x âˆ‚Î¼) := by\n  apply Ï†_int.induction (P := fun Ï† => âˆ« x, L (Ï† x) âˆ‚Î¼ = L (âˆ« x, Ï† x âˆ‚Î¼))\n  Â· intro e s s_meas _\n    rw [integral_indicator_const e s_meas, â† @smul_one_smul E â„ ğ•œ _ _ _ _ _ (Î¼ s).toReal e,\n      ContinuousLinearMap.map_smul, @smul_one_smul F â„ ğ•œ _ _ _ _ _ (Î¼ s).toReal (L e), â†\n      integral_indicator_const (L e) s_meas]\n    congr 1 with a\n    rw [â† Function.comp_def L, Set.indicator_comp_of_zero L.map_zero, Function.comp_apply]\n  Â· intro f g _ f_int g_int hf hg\n    simp [L.map_add, integral_add (Î¼ := Î¼) f_int g_int,\n      integral_add (Î¼ := Î¼) (L.integrable_comp f_int) (L.integrable_comp g_int), hf, hg]\n  Â· exact isClosed_eq L.continuous_integral_comp_L1 (L.continuous.comp continuous_integral)\n  Â· intro f g hfg _ hf\n    convert hf using 1 <;> clear hf\n    Â· exact integral_congr_ae (hfg.fun_comp L).symm\n    Â· rw [integral_congr_ae hfg.symm]\n\n"}
{"name":"ContinuousLinearMap.integral_apply","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœâ¶ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ•œ : Type u_5\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : NormedSpace Real E\nH : Type u_6\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nÏ† : X â†’ ContinuousLinearMap (RingHom.id ğ•œ) H E\nÏ†_int : MeasureTheory.Integrable Ï† Î¼\nv : H\nâŠ¢ Eq ((MeasureTheory.integral Î¼ fun x => Ï† x) v) (MeasureTheory.integral Î¼ fun x => (Ï† x) v)","decl":"theorem integral_apply {H : Type*} [NormedAddCommGroup H] [NormedSpace ğ•œ H] {Ï† : X â†’ H â†’L[ğ•œ] E}\n    (Ï†_int : Integrable Ï† Î¼) (v : H) : (âˆ« x, Ï† x âˆ‚Î¼) v = âˆ« x, Ï† x v âˆ‚Î¼ := by\n  by_cases hE : CompleteSpace E\n  Â· exact ((ContinuousLinearMap.apply ğ•œ E v).integral_comp_comm Ï†_int).symm\n  Â· rcases subsingleton_or_nontrivial H with hH|hH\n    Â· simp [Subsingleton.eq_zero v]\n    Â· have : Â¬(CompleteSpace (H â†’L[ğ•œ] E)) := by\n        rwa [SeparatingDual.completeSpace_continuousLinearMap_iff]\n      simp [integral, hE, this]\n\n"}
{"name":"ContinuousMultilinearMap.integral_apply","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœâ· : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ•œ : Type u_5\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedSpace Real E\nÎ¹ : Type u_6\ninstâœÂ² : Fintype Î¹\nM : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (M i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (M i)\nÏ† : X â†’ ContinuousMultilinearMap ğ•œ M E\nÏ†_int : MeasureTheory.Integrable Ï† Î¼\nm : (i : Î¹) â†’ M i\nâŠ¢ Eq ((MeasureTheory.integral Î¼ fun x => Ï† x) m) (MeasureTheory.integral Î¼ fun x => (Ï† x) m)","decl":"theorem _root_.ContinuousMultilinearMap.integral_apply {Î¹ : Type*} [Fintype Î¹] {M : Î¹ â†’ Type*}\n    [âˆ€ i, NormedAddCommGroup (M i)] [âˆ€ i, NormedSpace ğ•œ (M i)]\n    {Ï† : X â†’ ContinuousMultilinearMap ğ•œ M E} (Ï†_int : Integrable Ï† Î¼) (m : âˆ€ i, M i) :\n    (âˆ« x, Ï† x âˆ‚Î¼) m = âˆ« x, Ï† x m âˆ‚Î¼ := by\n  by_cases hE : CompleteSpace E\n  Â· exact ((ContinuousMultilinearMap.apply ğ•œ M E m).integral_comp_comm Ï†_int).symm\n  Â· by_cases hm : âˆ€ i, m i â‰  0\n    Â· have : Â¬ CompleteSpace (ContinuousMultilinearMap ğ•œ M E) := by\n        rwa [SeparatingDual.completeSpace_continuousMultilinearMap_iff _ _ hm]\n      simp [integral, hE, this]\n    Â· push_neg at hm\n      rcases hm with âŸ¨i, hiâŸ©\n      simp [ContinuousMultilinearMap.map_coord_zero _ i hi]\n\n"}
{"name":"ContinuousLinearMap.integral_comp_comm'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninstâœâ¹ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ•œ : Type u_5\ninstâœâ¸ : RCLike ğ•œ\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : NormedSpace Real F\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nL : ContinuousLinearMap (RingHom.id ğ•œ) E F\nK : NNReal\nhL : AntilipschitzWith K â‡‘L\nÏ† : X â†’ E\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => L (Ï† x)) (L (MeasureTheory.integral Î¼ fun x => Ï† x))","decl":"theorem integral_comp_comm' (L : E â†’L[ğ•œ] F) {K} (hL : AntilipschitzWith K L) (Ï† : X â†’ E) :\n    âˆ« x, L (Ï† x) âˆ‚Î¼ = L (âˆ« x, Ï† x âˆ‚Î¼) := by\n  by_cases h : Integrable Ï† Î¼\n  Â· exact integral_comp_comm L h\n  have : Â¬Integrable (fun x => L (Ï† x)) Î¼ := by\n    rwa [â† Function.comp_def,\n      LipschitzWith.integrable_comp_iff_of_antilipschitz L.lipschitz hL L.map_zero]\n  simp [integral_undef, h, this]\n\n"}
{"name":"ContinuousLinearMap.integral_comp_L1_comm","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninstâœâ¹ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ•œ : Type u_5\ninstâœâ¸ : RCLike ğ•œ\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : NormedSpace Real F\ninstâœÂ² : CompleteSpace F\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nL : ContinuousLinearMap (RingHom.id ğ•œ) E F\nÏ† : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 Î¼) x\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => L (â†‘â†‘Ï† x)) (L (MeasureTheory.integral Î¼ fun x => â†‘â†‘Ï† x))","decl":"theorem integral_comp_L1_comm (L : E â†’L[ğ•œ] F) (Ï† : X â†’â‚[Î¼] E) :\n    âˆ« x, L (Ï† x) âˆ‚Î¼ = L (âˆ« x, Ï† x âˆ‚Î¼) :=\n  L.integral_comp_comm (L1.integrable_coeFn Ï†)\n\n"}
{"name":"LinearIsometry.integral_comp_comm","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninstâœâ¹ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ•œ : Type u_5\ninstâœâ¸ : RCLike ğ•œ\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : CompleteSpace F\ninstâœÂ² : NormedSpace Real F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : NormedSpace Real E\nL : LinearIsometry (RingHom.id ğ•œ) E F\nÏ† : X â†’ E\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => L (Ï† x)) (L (MeasureTheory.integral Î¼ fun x => Ï† x))","decl":"theorem integral_comp_comm (L : E â†’â‚—áµ¢[ğ•œ] F) (Ï† : X â†’ E) : âˆ« x, L (Ï† x) âˆ‚Î¼ = L (âˆ« x, Ï† x âˆ‚Î¼) :=\n  L.toContinuousLinearMap.integral_comp_comm' L.antilipschitz _\n\n"}
{"name":"ContinuousLinearEquiv.integral_comp_comm","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninstâœâ· : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ•œ : Type u_5\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : NormedSpace Real E\nL : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nÏ† : X â†’ E\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => L (Ï† x)) (L (MeasureTheory.integral Î¼ fun x => Ï† x))","decl":"theorem integral_comp_comm (L : E â‰ƒL[ğ•œ] F) (Ï† : X â†’ E) : âˆ« x, L (Ï† x) âˆ‚Î¼ = L (âˆ« x, Ï† x âˆ‚Î¼) := by\n  have : CompleteSpace E â†” CompleteSpace F :=\n    completeSpace_congr (e := L.toEquiv) L.isUniformEmbedding\n  obtain âŸ¨_, _âŸ©|âŸ¨_, _âŸ© := iff_iff_and_or_not_and_not.mp this\n  Â· exact L.toContinuousLinearMap.integral_comp_comm' L.antilipschitz _\n  Â· simp [integral, *]\n\n"}
{"name":"ContinuousMap.integral_apply","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nY : Type u_2\nE : Type u_3\ninstâœâµ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : TopologicalSpace Y\ninstâœÂ² : CompactSpace Y\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nf : X â†’ ContinuousMap Y E\nhf : MeasureTheory.Integrable f Î¼\ny : Y\nâŠ¢ Eq ((MeasureTheory.integral Î¼ fun x => f x) y) (MeasureTheory.integral Î¼ fun x => (f x) y)","decl":"lemma ContinuousMap.integral_apply [NormedSpace â„ E] [CompleteSpace E] {f : X â†’ C(Y, E)}\n    (hf : Integrable f Î¼) (y : Y) : (âˆ« x, f x âˆ‚Î¼) y = âˆ« x, f x y âˆ‚Î¼ := by\n  calc (âˆ« x, f x âˆ‚Î¼) y = ContinuousMap.evalCLM â„ y (âˆ« x, f x âˆ‚Î¼) := rfl\n    _ = âˆ« x, ContinuousMap.evalCLM â„ y (f x) âˆ‚Î¼ :=\n          (ContinuousLinearMap.integral_comp_comm _ hf).symm\n    _ = _ := rfl\n\n"}
{"name":"ContinuousMapZero.integral_apply","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœâ¶ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœâµ : TopologicalSpace Y\ninstâœâ´ : CompactSpace Y\nR : Type u_6\ninstâœÂ³ : NormedCommRing R\ninstâœÂ² : Zero Y\ninstâœÂ¹ : NormedAlgebra Real R\ninstâœ : CompleteSpace R\nf : X â†’ ContinuousMapZero Y R\nhf : MeasureTheory.Integrable f Î¼\ny : Y\nâŠ¢ Eq ((MeasureTheory.integral Î¼ fun x => f x) y) (MeasureTheory.integral Î¼ fun x => (f x) y)","decl":"open scoped ContinuousMapZero in\ntheorem ContinuousMapZero.integral_apply {R : Type*} [NormedCommRing R] [Zero Y]\n    [NormedAlgebra â„ R] [CompleteSpace R] {f : X â†’ C(Y, R)â‚€}\n    (hf : MeasureTheory.Integrable f Î¼) (y : Y) :\n    (âˆ« (x : X), f x âˆ‚Î¼) y = âˆ« (x : X), (f x) y âˆ‚Î¼ := by\n  calc (âˆ« x, f x âˆ‚Î¼) y = ContinuousMapZero.evalCLM â„ y (âˆ« x, f x âˆ‚Î¼) := rfl\n    _ = âˆ« x, ContinuousMapZero.evalCLM â„ y (f x) âˆ‚Î¼ :=\n          (ContinuousLinearMap.integral_comp_comm _ hf).symm\n    _ = _ := rfl\n\n"}
{"name":"integral_ofReal","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœÂ¹ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ•œ : Type u_5\ninstâœ : RCLike ğ•œ\nf : X â†’ Real\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => â†‘(f x)) â†‘(MeasureTheory.integral Î¼ fun x => f x)","decl":"@[norm_cast]\ntheorem integral_ofReal {f : X â†’ â„} : âˆ« x, (f x : ğ•œ) âˆ‚Î¼ = â†‘(âˆ« x, f x âˆ‚Î¼) :=\n  (@RCLike.ofRealLI ğ•œ _).integral_comp_comm f\n\n"}
{"name":"integral_complex_ofReal","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nf : X â†’ Real\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => â†‘(f x)) â†‘(MeasureTheory.integral Î¼ fun x => f x)","decl":"theorem integral_complex_ofReal {f : X â†’ â„} : âˆ« x, (f x : â„‚) âˆ‚Î¼ = âˆ« x, f x âˆ‚Î¼ := integral_ofReal\n\n"}
{"name":"integral_re","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœÂ¹ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ•œ : Type u_5\ninstâœ : RCLike ğ•œ\nf : X â†’ ğ•œ\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => RCLike.re (f x)) (RCLike.re (MeasureTheory.integral Î¼ fun x => f x))","decl":"theorem integral_re {f : X â†’ ğ•œ} (hf : Integrable f Î¼) :\n    âˆ« x, RCLike.re (f x) âˆ‚Î¼ = RCLike.re (âˆ« x, f x âˆ‚Î¼) :=\n  (@RCLike.reCLM ğ•œ _).integral_comp_comm hf\n\n"}
{"name":"integral_im","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœÂ¹ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ•œ : Type u_5\ninstâœ : RCLike ğ•œ\nf : X â†’ ğ•œ\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => RCLike.im (f x)) (RCLike.im (MeasureTheory.integral Î¼ fun x => f x))","decl":"theorem integral_im {f : X â†’ ğ•œ} (hf : Integrable f Î¼) :\n    âˆ« x, RCLike.im (f x) âˆ‚Î¼ = RCLike.im (âˆ« x, f x âˆ‚Î¼) :=\n  (@RCLike.imCLM ğ•œ _).integral_comp_comm hf\n\n"}
{"name":"integral_conj","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœÂ¹ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ•œ : Type u_5\ninstâœ : RCLike ğ•œ\nf : X â†’ ğ•œ\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => (starRingEnd ğ•œ) (f x)) ((starRingEnd ğ•œ) (MeasureTheory.integral Î¼ fun x => f x))","decl":"theorem integral_conj {f : X â†’ ğ•œ} : âˆ« x, conj (f x) âˆ‚Î¼ = conj (âˆ« x, f x âˆ‚Î¼) :=\n  (@RCLike.conjLIE ğ•œ _).toLinearIsometry.integral_comp_comm f\n\n"}
{"name":"integral_coe_re_add_coe_im","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœÂ¹ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ•œ : Type u_5\ninstâœ : RCLike ğ•œ\nf : X â†’ ğ•œ\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (HAdd.hAdd (MeasureTheory.integral Î¼ fun x => â†‘(RCLike.re (f x))) (HMul.hMul (MeasureTheory.integral Î¼ fun x => â†‘(RCLike.im (f x))) RCLike.I)) (MeasureTheory.integral Î¼ fun x => f x)","decl":"theorem integral_coe_re_add_coe_im {f : X â†’ ğ•œ} (hf : Integrable f Î¼) :\n    âˆ« x, (re (f x) : ğ•œ) âˆ‚Î¼ + (âˆ« x, (im (f x) : ğ•œ) âˆ‚Î¼) * RCLike.I = âˆ« x, f x âˆ‚Î¼ := by\n  rw [mul_comm, â† smul_eq_mul, â† integral_smul, â† integral_add]\n  Â· congr\n    ext1 x\n    rw [smul_eq_mul, mul_comm, RCLike.re_add_im]\n  Â· exact hf.re.ofReal\n  Â· exact hf.im.ofReal.smul (ğ•œ := ğ•œ) (Î² := ğ•œ) RCLike.I\n\n"}
{"name":"integral_re_add_im","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœÂ¹ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ•œ : Type u_5\ninstâœ : RCLike ğ•œ\nf : X â†’ ğ•œ\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (HAdd.hAdd (â†‘(MeasureTheory.integral Î¼ fun x => RCLike.re (f x))) (HMul.hMul (â†‘(MeasureTheory.integral Î¼ fun x => RCLike.im (f x))) RCLike.I)) (MeasureTheory.integral Î¼ fun x => f x)","decl":"theorem integral_re_add_im {f : X â†’ ğ•œ} (hf : Integrable f Î¼) :\n    ((âˆ« x, RCLike.re (f x) âˆ‚Î¼ : â„) : ğ•œ) + (âˆ« x, RCLike.im (f x) âˆ‚Î¼ : â„) * RCLike.I =\n      âˆ« x, f x âˆ‚Î¼ := by\n  rw [â† integral_ofReal, â† integral_ofReal, integral_coe_re_add_coe_im hf]\n\n"}
{"name":"setIntegral_re_add_im","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœÂ¹ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nğ•œ : Type u_5\ninstâœ : RCLike ğ•œ\nf : X â†’ ğ•œ\ni : Set X\nhf : MeasureTheory.IntegrableOn f i Î¼\nâŠ¢ Eq (HAdd.hAdd (â†‘(MeasureTheory.integral (Î¼.restrict i) fun x => RCLike.re (f x))) (HMul.hMul (â†‘(MeasureTheory.integral (Î¼.restrict i) fun x => RCLike.im (f x))) RCLike.I)) (MeasureTheory.integral (Î¼.restrict i) fun x => f x)","decl":"theorem setIntegral_re_add_im {f : X â†’ ğ•œ} {i : Set X} (hf : IntegrableOn f i Î¼) :\n    ((âˆ« x in i, RCLike.re (f x) âˆ‚Î¼ : â„) : ğ•œ) + (âˆ« x in i, RCLike.im (f x) âˆ‚Î¼ : â„) * RCLike.I =\n      âˆ« x in i, f x âˆ‚Î¼ :=\n  integral_re_add_im hf\n\n"}
{"name":"swap_integral","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninstâœâ´ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : NormedSpace Real F\nf : X â†’ Prod E F\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f x).swap (MeasureTheory.integral Î¼ fun x => (f x).swap)","decl":"lemma swap_integral (f : X â†’ E Ã— F) : (âˆ« x, f x âˆ‚Î¼).swap = âˆ« x, (f x).swap âˆ‚Î¼ :=\n  .symm <| (ContinuousLinearEquiv.prodComm â„ E F).integral_comp_comm f\n\n"}
{"name":"fst_integral","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninstâœâµ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : CompleteSpace F\nf : X â†’ Prod E F\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f x).1 (MeasureTheory.integral Î¼ fun x => (f x).1)","decl":"theorem fst_integral [CompleteSpace F] {f : X â†’ E Ã— F} (hf : Integrable f Î¼) :\n    (âˆ« x, f x âˆ‚Î¼).1 = âˆ« x, (f x).1 âˆ‚Î¼ := by\n  by_cases hE : CompleteSpace E\n  Â· exact ((ContinuousLinearMap.fst â„ E F).integral_comp_comm hf).symm\n  Â· have : Â¬(CompleteSpace (E Ã— F)) := fun h â†¦ hE <| .fst_of_prod (Î² := F)\n    simp [integral, *]\n\n"}
{"name":"snd_integral","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninstâœâµ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : CompleteSpace E\nf : X â†’ Prod E F\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => f x).2 (MeasureTheory.integral Î¼ fun x => (f x).2)","decl":"theorem snd_integral [CompleteSpace E] {f : X â†’ E Ã— F} (hf : Integrable f Î¼) :\n    (âˆ« x, f x âˆ‚Î¼).2 = âˆ« x, (f x).2 âˆ‚Î¼ := by\n  rw [â† Prod.fst_swap, swap_integral]\n  exact fst_integral <| hf.snd.prod_mk hf.fst\n\n"}
{"name":"integral_pair","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninstâœâ¶ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : NormedSpace Real F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace F\nf : X â†’ E\ng : X â†’ F\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => { fst := f x, snd := g x }) { fst := MeasureTheory.integral Î¼ fun x => f x, snd := MeasureTheory.integral Î¼ fun x => g x }","decl":"theorem integral_pair [CompleteSpace E] [CompleteSpace F] {f : X â†’ E} {g : X â†’ F}\n    (hf : Integrable f Î¼) (hg : Integrable g Î¼) :\n    âˆ« x, (f x, g x) âˆ‚Î¼ = (âˆ« x, f x âˆ‚Î¼, âˆ« x, g x âˆ‚Î¼) :=\n  have := hf.prod_mk hg\n  Prod.ext (fst_integral this) (snd_integral this)\n\n"}
{"name":"integral_smul_const","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœâµ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\nğ•œ : Type u_6\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : CompleteSpace E\nf : X â†’ ğ•œ\nc : E\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun x => HSMul.hSMul (f x) c) (HSMul.hSMul (MeasureTheory.integral Î¼ fun x => f x) c)","decl":"theorem integral_smul_const {ğ•œ : Type*} [RCLike ğ•œ] [NormedSpace ğ•œ E] [CompleteSpace E]\n    (f : X â†’ ğ•œ) (c : E) :\n    âˆ« x, f x â€¢ c âˆ‚Î¼ = (âˆ« x, f x âˆ‚Î¼) â€¢ c := by\n  by_cases hf : Integrable f Î¼\n  Â· exact ((1 : ğ•œ â†’L[ğ•œ] ğ•œ).smulRight c).integral_comp_comm hf\n  Â· by_cases hc : c = 0\n    Â· simp [hc, integral_zero, smul_zero]\n    rw [integral_undef hf, integral_undef, zero_smul]\n    rw [integrable_smul_const hc]\n    simp_rw [hf, not_false_eq_true]\n\n"}
{"name":"integral_withDensity_eq_integral_smul","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ NNReal\nf_meas : Measurable f\ng : X â†’ E\nâŠ¢ Eq (MeasureTheory.integral (Î¼.withDensity fun x => â†‘(f x)) fun x => g x) (MeasureTheory.integral Î¼ fun x => HSMul.hSMul (f x) (g x))","decl":"theorem integral_withDensity_eq_integral_smul {f : X â†’ â„â‰¥0} (f_meas : Measurable f) (g : X â†’ E) :\n    âˆ« x, g x âˆ‚Î¼.withDensity (fun x => f x) = âˆ« x, f x â€¢ g x âˆ‚Î¼ := by\n  by_cases hE : CompleteSpace E; swap; Â· simp [integral, hE]\n  by_cases hg : Integrable g (Î¼.withDensity fun x => f x); swap\n  Â· rw [integral_undef hg, integral_undef]\n    rwa [â† integrable_withDensity_iff_integrable_smul f_meas]\n  refine Integrable.induction\n    (P := fun g => âˆ« x, g x âˆ‚Î¼.withDensity (fun x => f x) = âˆ« x, f x â€¢ g x âˆ‚Î¼) ?_ ?_ ?_ ?_ hg\n  Â· intro c s s_meas hs\n    rw [integral_indicator s_meas]\n    simp_rw [â† indicator_smul_apply, integral_indicator s_meas]\n    simp only [s_meas, integral_const, Measure.restrict_apply', univ_inter, withDensity_apply]\n    rw [lintegral_coe_eq_integral, ENNReal.toReal_ofReal, â† integral_smul_const]\n    Â· rfl\n    Â· exact integral_nonneg fun x => NNReal.coe_nonneg _\n    Â· refine âŸ¨f_meas.coe_nnreal_real.aemeasurable.aestronglyMeasurable, ?_âŸ©\n      simpa [withDensity_apply _ s_meas, hasFiniteIntegral_iff_enorm] using hs\n  Â· intro u u' _ u_int u'_int h h'\n    change\n      (âˆ« x : X, u x + u' x âˆ‚Î¼.withDensity fun x : X => â†‘(f x)) = âˆ« x : X, f x â€¢ (u x + u' x) âˆ‚Î¼\n    simp_rw [smul_add]\n    rw [integral_add u_int u'_int, h, h', integral_add]\n    Â· exact (integrable_withDensity_iff_integrable_smul f_meas).1 u_int\n    Â· exact (integrable_withDensity_iff_integrable_smul f_meas).1 u'_int\n  Â· have C1 :\n      Continuous fun u : Lp E 1 (Î¼.withDensity fun x => f x) =>\n        âˆ« x, u x âˆ‚Î¼.withDensity fun x => f x :=\n      continuous_integral\n    have C2 : Continuous fun u : Lp E 1 (Î¼.withDensity fun x => f x) => âˆ« x, f x â€¢ u x âˆ‚Î¼ := by\n      have : Continuous ((fun u : Lp E 1 Î¼ => âˆ« x, u x âˆ‚Î¼) âˆ˜ withDensitySMulLI (E := E) Î¼ f_meas) :=\n        continuous_integral.comp (withDensitySMulLI (E := E) Î¼ f_meas).continuous\n      convert this with u\n      simp only [Function.comp_apply, withDensitySMulLI_apply]\n      exact integral_congr_ae (memâ„’1_smul_of_L1_withDensity f_meas u).coeFn_toLp.symm\n    exact isClosed_eq C1 C2\n  Â· intro u v huv _ hu\n    rw [â† integral_congr_ae huv, hu]\n    apply integral_congr_ae\n    filter_upwards [(ae_withDensity_iff f_meas.coe_nnreal_ennreal).1 huv] with x hx\n    rcases eq_or_ne (f x) 0 with (h'x | h'x)\n    Â· simp only [h'x, zero_smul]\n    Â· rw [hx _]\n      simpa only [Ne, ENNReal.coe_eq_zero] using h'x\n\n"}
{"name":"integral_withDensity_eq_integral_smulâ‚€","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ NNReal\nhf : AEMeasurable f Î¼\ng : X â†’ E\nâŠ¢ Eq (MeasureTheory.integral (Î¼.withDensity fun x => â†‘(f x)) fun x => g x) (MeasureTheory.integral Î¼ fun x => HSMul.hSMul (f x) (g x))","decl":"theorem integral_withDensity_eq_integral_smulâ‚€ {f : X â†’ â„â‰¥0} (hf : AEMeasurable f Î¼) (g : X â†’ E) :\n    âˆ« x, g x âˆ‚Î¼.withDensity (fun x => f x) = âˆ« x, f x â€¢ g x âˆ‚Î¼ := by\n  let f' := hf.mk _\n  calc\n    âˆ« x, g x âˆ‚Î¼.withDensity (fun x => f x) = âˆ« x, g x âˆ‚Î¼.withDensity fun x => f' x := by\n      congr 1\n      apply withDensity_congr_ae\n      filter_upwards [hf.ae_eq_mk] with x hx\n      rw [hx]\n    _ = âˆ« x, f' x â€¢ g x âˆ‚Î¼ := integral_withDensity_eq_integral_smul hf.measurable_mk _\n    _ = âˆ« x, f x â€¢ g x âˆ‚Î¼ := by\n      apply integral_congr_ae\n      filter_upwards [hf.ae_eq_mk] with x hx\n      rw [hx]\n\n"}
{"name":"setIntegral_withDensity_eq_setIntegral_smul","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ NNReal\nf_meas : Measurable f\ng : X â†’ E\ns : Set X\nhs : MeasurableSet s\nâŠ¢ Eq (MeasureTheory.integral ((Î¼.withDensity fun x => â†‘(f x)).restrict s) fun x => g x) (MeasureTheory.integral (Î¼.restrict s) fun x => HSMul.hSMul (f x) (g x))","decl":"theorem setIntegral_withDensity_eq_setIntegral_smul {f : X â†’ â„â‰¥0} (f_meas : Measurable f)\n    (g : X â†’ E) {s : Set X} (hs : MeasurableSet s) :\n    âˆ« x in s, g x âˆ‚Î¼.withDensity (fun x => f x) = âˆ« x in s, f x â€¢ g x âˆ‚Î¼ := by\n  rw [restrict_withDensity hs, integral_withDensity_eq_integral_smul f_meas]\n\n"}
{"name":"setIntegral_withDensity_eq_setIntegral_smulâ‚€","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ² : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : X â†’ NNReal\ns : Set X\nhf : AEMeasurable f (Î¼.restrict s)\ng : X â†’ E\nhs : MeasurableSet s\nâŠ¢ Eq (MeasureTheory.integral ((Î¼.withDensity fun x => â†‘(f x)).restrict s) fun x => g x) (MeasureTheory.integral (Î¼.restrict s) fun x => HSMul.hSMul (f x) (g x))","decl":"theorem setIntegral_withDensity_eq_setIntegral_smulâ‚€ {f : X â†’ â„â‰¥0} {s : Set X}\n    (hf : AEMeasurable f (Î¼.restrict s)) (g : X â†’ E) (hs : MeasurableSet s) :\n    âˆ« x in s, g x âˆ‚Î¼.withDensity (fun x => f x) = âˆ« x in s, f x â€¢ g x âˆ‚Î¼ := by\n  rw [restrict_withDensity hs, integral_withDensity_eq_integral_smulâ‚€ hf]\n\n"}
{"name":"setIntegral_withDensity_eq_setIntegral_smulâ‚€'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninstâœÂ³ : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : MeasureTheory.SFinite Î¼\nf : X â†’ NNReal\ns : Set X\nhf : AEMeasurable f (Î¼.restrict s)\ng : X â†’ E\nâŠ¢ Eq (MeasureTheory.integral ((Î¼.withDensity fun x => â†‘(f x)).restrict s) fun x => g x) (MeasureTheory.integral (Î¼.restrict s) fun x => HSMul.hSMul (f x) (g x))","decl":"theorem setIntegral_withDensity_eq_setIntegral_smulâ‚€' [SFinite Î¼] {f : X â†’ â„â‰¥0} (s : Set X)\n    (hf : AEMeasurable f (Î¼.restrict s)) (g : X â†’ E)  :\n    âˆ« x in s, g x âˆ‚Î¼.withDensity (fun x => f x) = âˆ« x in s, f x â€¢ g x âˆ‚Î¼ := by\n  rw [restrict_withDensity' s, integral_withDensity_eq_integral_smulâ‚€ hf]\n\n"}
{"name":"measure_le_lintegral_thickenedIndicatorAux","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : PseudoEMetricSpace X\nÎ¼ : MeasureTheory.Measure X\nE : Set X\nE_mble : MeasurableSet E\nÎ´ : Real\nâŠ¢ LE.le (Î¼ E) (MeasureTheory.lintegral Î¼ fun x => thickenedIndicatorAux Î´ E x)","decl":"theorem measure_le_lintegral_thickenedIndicatorAux (Î¼ : Measure X) {E : Set X}\n    (E_mble : MeasurableSet E) (Î´ : â„) : Î¼ E â‰¤ âˆ«â» x, (thickenedIndicatorAux Î´ E x : â„â‰¥0âˆ) âˆ‚Î¼ := by\n  convert_to lintegral Î¼ (E.indicator fun _ => (1 : â„â‰¥0âˆ)) â‰¤ lintegral Î¼ (thickenedIndicatorAux Î´ E)\n  Â· rw [lintegral_indicator E_mble]\n    simp only [lintegral_one, Measure.restrict_apply, MeasurableSet.univ, univ_inter]\n  Â· apply lintegral_mono\n    apply indicator_le_thickenedIndicatorAux\n\n"}
{"name":"measure_le_lintegral_thickenedIndicator","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninstâœÂ¹ : MeasurableSpace X\ninstâœ : PseudoEMetricSpace X\nÎ¼ : MeasureTheory.Measure X\nE : Set X\nE_mble : MeasurableSet E\nÎ´ : Real\nÎ´_pos : LT.lt 0 Î´\nâŠ¢ LE.le (Î¼ E) (MeasureTheory.lintegral Î¼ fun x => â†‘((thickenedIndicator Î´_pos E) x))","decl":"theorem measure_le_lintegral_thickenedIndicator (Î¼ : Measure X) {E : Set X}\n    (E_mble : MeasurableSet E) {Î´ : â„} (Î´_pos : 0 < Î´) :\n    Î¼ E â‰¤ âˆ«â» x, (thickenedIndicator Î´_pos E x : â„â‰¥0âˆ) âˆ‚Î¼ := by\n  convert measure_le_lintegral_thickenedIndicatorAux Î¼ E_mble Î´\n  dsimp\n  simp only [thickenedIndicatorAux_lt_top.ne, ENNReal.coe_toNNReal, Ne, not_false_iff]\n\n"}
{"name":"MeasureTheory.Integrable.simpleFunc_mul","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_6\nf : X â†’ Real\nm0 : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\ng : MeasureTheory.SimpleFunc X Real\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ MeasureTheory.Integrable (HMul.hMul (â‡‘g) f) Î¼","decl":"theorem Integrable.simpleFunc_mul (g : SimpleFunc X â„) (hf : Integrable f Î¼) :\n    Integrable (â‡‘g * f) Î¼ := by\n  refine\n    SimpleFunc.induction (fun c s hs => ?_)\n      (fun gâ‚ gâ‚‚ _ h_intâ‚ h_intâ‚‚ =>\n        (h_intâ‚.add h_intâ‚‚).congr (by rw [SimpleFunc.coe_add, add_mul]))\n      g\n  simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_const,\n    SimpleFunc.coe_zero, Set.piecewise_eq_indicator]\n  have : Set.indicator s (Function.const X c) * f = s.indicator (c â€¢ f) := by\n    ext1 x\n    by_cases hx : x âˆˆ s\n    Â· simp only [hx, Pi.mul_apply, Set.indicator_of_mem, Pi.smul_apply, Algebra.id.smul_eq_mul,\n        â† Function.const_def]\n    Â· simp only [hx, Pi.mul_apply, Set.indicator_of_not_mem, not_false_iff, zero_mul]\n  rw [this, integrable_indicator_iff hs]\n  exact (hf.smul c).integrableOn\n\n"}
{"name":"MeasureTheory.Integrable.simpleFunc_mul'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_6\nf : X â†’ Real\nm m0 : MeasurableSpace X\nÎ¼ : MeasureTheory.Measure X\nhm : LE.le m m0\ng : MeasureTheory.SimpleFunc X Real\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ MeasureTheory.Integrable (HMul.hMul (â‡‘g) f) Î¼","decl":"theorem Integrable.simpleFunc_mul' (hm : m â‰¤ m0) (g : @SimpleFunc X m â„) (hf : Integrable f Î¼) :\n    Integrable (â‡‘g * f) Î¼ := by\n  rw [â† SimpleFunc.coe_toLargerSpace_eq hm g]; exact hf.simpleFunc_mul (g.toLargerSpace hm)\n\n"}
{"name":"continuous_parametric_integral_of_continuous","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"Y : Type u_2\nE : Type u_3\nX : Type u_5\ninstâœâ¹ : TopologicalSpace X\ninstâœâ¸ : TopologicalSpace Y\ninstâœâ· : MeasurableSpace Y\ninstâœâ¶ : OpensMeasurableSpace Y\nÎ¼ : MeasureTheory.Measure Y\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FirstCountableTopology X\ninstâœÂ² : LocallyCompactSpace X\ninstâœÂ¹ : SecondCountableTopologyEither Y E\ninstâœ : MeasureTheory.IsLocallyFiniteMeasure Î¼\nf : X â†’ Y â†’ E\nhf : Continuous (Function.uncurry f)\ns : Set Y\nhs : IsCompact s\nâŠ¢ Continuous fun x => MeasureTheory.integral (Î¼.restrict s) fun y => f x y","decl":"/-- The parametric integral over a continuous function on a compact set is continuous,\n  under mild assumptions on the topologies involved. -/\ntheorem continuous_parametric_integral_of_continuous\n    [FirstCountableTopology X] [LocallyCompactSpace X]\n    [SecondCountableTopologyEither Y E] [IsLocallyFiniteMeasure Î¼]\n    {f : X â†’ Y â†’ E} (hf : Continuous f.uncurry) {s : Set Y} (hs : IsCompact s) :\n    Continuous (âˆ« y in s, f Â· y âˆ‚Î¼) := by\n  rw [continuous_iff_continuousAt]\n  intro xâ‚€\n  rcases exists_compact_mem_nhds xâ‚€ with âŸ¨U, U_cpct, U_nhdsâŸ©\n  rcases (U_cpct.prod hs).bddAbove_image hf.norm.continuousOn with âŸ¨M, hMâŸ©\n  apply continuousAt_of_dominated\n  Â· filter_upwards with x using Continuous.aestronglyMeasurable (by fun_prop)\n  Â· filter_upwards [U_nhds] with x x_in\n    rw [ae_restrict_iff]\n    Â· filter_upwards with t t_in using hM (mem_image_of_mem _ <| mk_mem_prod x_in t_in)\n    Â· exact (isClosed_le (by fun_prop) (by fun_prop)).measurableSet\n  Â· exact integrableOn_const.mpr (Or.inr hs.measure_lt_top)\n  Â· filter_upwards using (by fun_prop)\n\n"}
{"name":"continuousOn_integral_bilinear_of_locally_integrable_of_compact_support","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"Y : Type u_2\nE : Type u_3\nF : Type u_4\nX : Type u_5\nG : Type u_6\nğ•œ : Type u_7\ninstâœÂ¹Â¹ : TopologicalSpace X\ninstâœÂ¹â° : TopologicalSpace Y\ninstâœâ¹ : MeasurableSpace Y\ninstâœâ¸ : OpensMeasurableSpace Y\nÎ¼ : MeasureTheory.Measure Y\ninstâœâ· : NontriviallyNormedField ğ•œ\ninstâœâ¶ : NormedAddCommGroup E\ninstâœâµ : NormedSpace Real E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\ninstâœÂ² : NormedAddCommGroup G\ninstâœÂ¹ : NormedSpace ğ•œ G\ninstâœ : NormedSpace ğ•œ E\nL : ContinuousLinearMap (RingHom.id ğ•œ) F (ContinuousLinearMap (RingHom.id ğ•œ) G E)\nf : X â†’ Y â†’ G\ns : Set X\nk : Set Y\ng : Y â†’ F\nhk : IsCompact k\nhf : ContinuousOn (Function.uncurry f) (SProd.sprod s Set.univ)\nhfs : âˆ€ (p : X) (x : Y), Membership.mem s p â†’ Not (Membership.mem k x) â†’ Eq (f p x) 0\nhg : MeasureTheory.IntegrableOn g k Î¼\nâŠ¢ ContinuousOn (fun x => MeasureTheory.integral Î¼ fun y => (L (g y)) (f x y)) s","decl":"/-- Consider a parameterized integral `x â†¦ âˆ« y, L (g y) (f x y)` where `L` is bilinear,\n`g` is locally integrable and `f` is continuous and uniformly compactly supported. Then the\nintegral depends continuously on `x`. -/\nlemma continuousOn_integral_bilinear_of_locally_integrable_of_compact_support\n    [NormedSpace ğ•œ E] (L : F â†’L[ğ•œ] G â†’L[ğ•œ] E)\n    {f : X â†’ Y â†’ G} {s : Set X} {k : Set Y} {g : Y â†’ F}\n    (hk : IsCompact k) (hf : ContinuousOn f.uncurry (s Ã—Ë¢ univ))\n    (hfs : âˆ€ p, âˆ€ x, p âˆˆ s â†’ x âˆ‰ k â†’ f p x = 0) (hg : IntegrableOn g k Î¼) :\n    ContinuousOn (fun x â†¦ âˆ« y, L (g y) (f x y) âˆ‚Î¼) s := by\n  have A : âˆ€ p âˆˆ s, Continuous (f p) := fun p hp â†¦ by\n    refine hf.comp_continuous (continuous_const.prod_mk continuous_id') fun y => ?_\n    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true] using hp\n  intro q hq\n  apply Metric.continuousWithinAt_iff'.2 (fun Îµ Îµpos â†¦ ?_)\n  obtain âŸ¨Î´, Î´pos, hÎ´âŸ© : âˆƒ (Î´ : â„), 0 < Î´ âˆ§ âˆ« x in k, â€–Lâ€– * â€–g xâ€– * Î´ âˆ‚Î¼ < Îµ := by\n    simpa [integral_mul_right] using exists_pos_mul_lt Îµpos _\n  obtain âŸ¨v, v_mem, hvâŸ© : âˆƒ v âˆˆ ğ“[s] q, âˆ€ p âˆˆ v, âˆ€ x âˆˆ k, dist (f p x) (f q x) < Î´ :=\n    hk.mem_uniformity_of_prod\n      (hf.mono (Set.prod_mono_right (subset_univ k))) hq (dist_mem_uniformity Î´pos)\n  simp_rw [dist_eq_norm] at hv âŠ¢\n  have I : âˆ€ p âˆˆ s, IntegrableOn (fun y â†¦ L (g y) (f p y)) k Î¼ := by\n    intro p hp\n    obtain âŸ¨C, hCâŸ© : âˆƒ C, âˆ€ y, â€–f p yâ€– â‰¤ C := by\n      have : ContinuousOn (f p) k := by\n        have : ContinuousOn (fun y â†¦ (p, y)) k := by fun_prop\n        exact hf.comp this (by simp [MapsTo, hp])\n      rcases IsCompact.exists_bound_of_continuousOn hk this with âŸ¨C, hCâŸ©\n      refine âŸ¨max C 0, fun y â†¦ ?_âŸ©\n      by_cases hx : y âˆˆ k\n      Â· exact (hC y hx).trans (le_max_left _ _)\n      Â· simp [hfs p y hp hx]\n    have : IntegrableOn (fun y â†¦ â€–Lâ€– * â€–g yâ€– * C) k Î¼ :=\n      (hg.norm.const_mul _).mul_const _\n    apply Integrable.mono' this ?_ ?_\n    Â· borelize G\n      apply L.aestronglyMeasurable_compâ‚‚ hg.aestronglyMeasurable\n      apply StronglyMeasurable.aestronglyMeasurable\n      apply Continuous.stronglyMeasurable_of_support_subset_isCompact (A p hp) hk\n      apply support_subset_iff'.2 (fun y hy â†¦ hfs p y hp hy)\n    Â· apply Eventually.of_forall (fun y â†¦ (le_opNormâ‚‚ L (g y) (f p y)).trans ?_)\n      gcongr\n      apply hC\n  filter_upwards [v_mem, self_mem_nhdsWithin] with p hp h'p\n  calc\n  â€–âˆ« x, L (g x) (f p x) âˆ‚Î¼ - âˆ« x, L (g x) (f q x) âˆ‚Î¼â€–\n    = â€–âˆ« x in k, L (g x) (f p x) âˆ‚Î¼ - âˆ« x in k, L (g x) (f q x) âˆ‚Î¼â€– := by\n      congr 2\n      Â· refine (setIntegral_eq_integral_of_forall_compl_eq_zero (fun y hy â†¦ ?_)).symm\n        simp [hfs p y h'p hy]\n      Â· refine (setIntegral_eq_integral_of_forall_compl_eq_zero (fun y hy â†¦ ?_)).symm\n        simp [hfs q y hq hy]\n  _ = â€–âˆ« x in k, L (g x) (f p x) - L (g x) (f q x) âˆ‚Î¼â€– := by rw [integral_sub (I p h'p) (I q hq)]\n  _ â‰¤ âˆ« x in k, â€–L (g x) (f p x) - L (g x) (f q x)â€– âˆ‚Î¼ := norm_integral_le_integral_norm _\n  _ â‰¤ âˆ« x in k, â€–Lâ€– * â€–g xâ€– * Î´ âˆ‚Î¼ := by\n      apply integral_mono_of_nonneg (Eventually.of_forall (fun y â†¦ by positivity))\n      Â· exact (hg.norm.const_mul _).mul_const _\n      Â· filter_upwards with y\n        by_cases hy : y âˆˆ k\n        Â· dsimp only\n          specialize hv p hp y hy\n          calc\n          â€–L (g y) (f p y) - L (g y) (f q y)â€–\n            = â€–L (g y) (f p y - f q y)â€– := by simp only [map_sub]\n          _ â‰¤ â€–Lâ€– * â€–g yâ€– * â€–f p y - f q yâ€– := le_opNormâ‚‚ _ _ _\n          _ â‰¤ â€–Lâ€– * â€–g yâ€– * Î´ := by gcongr\n        Â· simp only [hfs p y h'p hy, hfs q y hq hy, sub_self, norm_zero, mul_zero]\n          positivity\n  _ < Îµ := hÎ´\n\n"}
{"name":"continuousOn_integral_of_compact_support","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"Y : Type u_2\nE : Type u_3\nX : Type u_5\ninstâœâ¶ : TopologicalSpace X\ninstâœâµ : TopologicalSpace Y\ninstâœâ´ : MeasurableSpace Y\ninstâœÂ³ : OpensMeasurableSpace Y\nÎ¼ : MeasureTheory.Measure Y\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\nf : X â†’ Y â†’ E\ns : Set X\nk : Set Y\ninstâœ : MeasureTheory.IsFiniteMeasureOnCompacts Î¼\nhk : IsCompact k\nhf : ContinuousOn (Function.uncurry f) (SProd.sprod s Set.univ)\nhfs : âˆ€ (p : X) (x : Y), Membership.mem s p â†’ Not (Membership.mem k x) â†’ Eq (f p x) 0\nâŠ¢ ContinuousOn (fun x => MeasureTheory.integral Î¼ fun y => f x y) s","decl":"/-- Consider a parameterized integral `x â†¦ âˆ« y, f x y` where `f` is continuous and uniformly\ncompactly supported. Then the integral depends continuously on `x`. -/\nlemma continuousOn_integral_of_compact_support\n    {f : X â†’ Y â†’ E} {s : Set X} {k : Set Y} [IsFiniteMeasureOnCompacts Î¼]\n    (hk : IsCompact k) (hf : ContinuousOn f.uncurry (s Ã—Ë¢ univ))\n    (hfs : âˆ€ p, âˆ€ x, p âˆˆ s â†’ x âˆ‰ k â†’ f p x = 0) :\n    ContinuousOn (fun x â†¦ âˆ« y, f x y âˆ‚Î¼) s := by\n  simpa using continuousOn_integral_bilinear_of_locally_integrable_of_compact_support (lsmul â„ â„)\n    hk hf hfs (integrableOn_const.2 (Or.inr hk.measure_lt_top)) (Î¼ := Î¼) (g := fun _ â†¦ 1)\n\n"}
