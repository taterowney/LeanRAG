{"name":"MeasureTheory.setIntegral_congr_ae₀","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf g : X → E\ns : Set X\nμ : MeasureTheory.Measure X\nhs : MeasureTheory.NullMeasurableSet s μ\nh : Filter.Eventually (fun x => Membership.mem s x → Eq (f x) (g x)) (MeasureTheory.ae μ)\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict s) fun x => g x)","decl":"theorem setIntegral_congr_ae₀ (hs : NullMeasurableSet s μ) (h : ∀ᵐ x ∂μ, x ∈ s → f x = g x) :\n    ∫ x in s, f x ∂μ = ∫ x in s, g x ∂μ :=\n  integral_congr_ae ((ae_restrict_iff'₀ hs).2 h)\n\n"}
{"name":"MeasureTheory.setIntegral_congr_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf g : X → E\ns : Set X\nμ : MeasureTheory.Measure X\nhs : MeasurableSet s\nh : Filter.Eventually (fun x => Membership.mem s x → Eq (f x) (g x)) (MeasureTheory.ae μ)\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict s) fun x => g x)","decl":"theorem setIntegral_congr_ae (hs : MeasurableSet s) (h : ∀ᵐ x ∂μ, x ∈ s → f x = g x) :\n    ∫ x in s, f x ∂μ = ∫ x in s, g x ∂μ :=\n  integral_congr_ae ((ae_restrict_iff' hs).2 h)\n\n"}
{"name":"MeasureTheory.setIntegral_congr_fun₀","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf g : X → E\ns : Set X\nμ : MeasureTheory.Measure X\nhs : MeasureTheory.NullMeasurableSet s μ\nh : Set.EqOn f g s\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict s) fun x => g x)","decl":"theorem setIntegral_congr_fun₀ (hs : NullMeasurableSet s μ) (h : EqOn f g s) :\n    ∫ x in s, f x ∂μ = ∫ x in s, g x ∂μ :=\n  setIntegral_congr_ae₀ hs <| Eventually.of_forall h\n\n"}
{"name":"MeasureTheory.setIntegral_congr₀","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf g : X → E\ns : Set X\nμ : MeasureTheory.Measure X\nhs : MeasureTheory.NullMeasurableSet s μ\nh : Set.EqOn f g s\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict s) fun x => g x)","decl":"@[deprecated (since := \"2024-10-12\")]\nalias setIntegral_congr₀ := setIntegral_congr_fun₀\n\n"}
{"name":"MeasureTheory.setIntegral_congr_fun","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf g : X → E\ns : Set X\nμ : MeasureTheory.Measure X\nhs : MeasurableSet s\nh : Set.EqOn f g s\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict s) fun x => g x)","decl":"theorem setIntegral_congr_fun (hs : MeasurableSet s) (h : EqOn f g s) :\n    ∫ x in s, f x ∂μ = ∫ x in s, g x ∂μ :=\n  setIntegral_congr_ae hs <| Eventually.of_forall h\n\n"}
{"name":"MeasureTheory.setIntegral_congr","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf g : X → E\ns : Set X\nμ : MeasureTheory.Measure X\nhs : MeasurableSet s\nh : Set.EqOn f g s\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict s) fun x => g x)","decl":"@[deprecated (since := \"2024-10-12\")]\nalias setIntegral_congr := setIntegral_congr_fun\n\n"}
{"name":"MeasureTheory.setIntegral_congr_set","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns t : Set X\nμ : MeasureTheory.Measure X\nhst : (MeasureTheory.ae μ).EventuallyEq s t\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict t) fun x => f x)","decl":"theorem setIntegral_congr_set (hst : s =ᵐ[μ] t) : ∫ x in s, f x ∂μ = ∫ x in t, f x ∂μ := by\n  rw [Measure.restrict_congr_set hst]\n\n"}
{"name":"MeasureTheory.setIntegral_congr_set_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns t : Set X\nμ : MeasureTheory.Measure X\nhst : (MeasureTheory.ae μ).EventuallyEq s t\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict t) fun x => f x)","decl":"@[deprecated (since := \"2024-10-12\")]\nalias setIntegral_congr_set_ae := setIntegral_congr_set\n\n"}
{"name":"MeasureTheory.integral_union_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns t : Set X\nμ : MeasureTheory.Measure X\nhst : MeasureTheory.AEDisjoint μ s t\nht : MeasureTheory.NullMeasurableSet t μ\nhfs : MeasureTheory.IntegrableOn f s μ\nhft : MeasureTheory.IntegrableOn f t μ\n⊢ Eq (MeasureTheory.integral (μ.restrict (Union.union s t)) fun x => f x) (HAdd.hAdd (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict t) fun x => f x))","decl":"theorem integral_union_ae (hst : AEDisjoint μ s t) (ht : NullMeasurableSet t μ)\n    (hfs : IntegrableOn f s μ) (hft : IntegrableOn f t μ) :\n    ∫ x in s ∪ t, f x ∂μ = ∫ x in s, f x ∂μ + ∫ x in t, f x ∂μ := by\n  simp only [IntegrableOn, Measure.restrict_union₀ hst ht, integral_add_measure hfs hft]\n\n"}
{"name":"MeasureTheory.setIntegral_union","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns t : Set X\nμ : MeasureTheory.Measure X\nhst : Disjoint s t\nht : MeasurableSet t\nhfs : MeasureTheory.IntegrableOn f s μ\nhft : MeasureTheory.IntegrableOn f t μ\n⊢ Eq (MeasureTheory.integral (μ.restrict (Union.union s t)) fun x => f x) (HAdd.hAdd (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict t) fun x => f x))","decl":"theorem setIntegral_union (hst : Disjoint s t) (ht : MeasurableSet t) (hfs : IntegrableOn f s μ)\n    (hft : IntegrableOn f t μ) : ∫ x in s ∪ t, f x ∂μ = ∫ x in s, f x ∂μ + ∫ x in t, f x ∂μ :=\n  integral_union_ae hst.aedisjoint ht.nullMeasurableSet hfs hft\n\n"}
{"name":"MeasureTheory.integral_union","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns t : Set X\nμ : MeasureTheory.Measure X\nhst : Disjoint s t\nht : MeasurableSet t\nhfs : MeasureTheory.IntegrableOn f s μ\nhft : MeasureTheory.IntegrableOn f t μ\n⊢ Eq (MeasureTheory.integral (μ.restrict (Union.union s t)) fun x => f x) (HAdd.hAdd (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict t) fun x => f x))","decl":"@[deprecated (since := \"2024-10-12\")]\nalias integral_union := setIntegral_union\n\n"}
{"name":"MeasureTheory.integral_diff","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns t : Set X\nμ : MeasureTheory.Measure X\nht : MeasurableSet t\nhfs : MeasureTheory.IntegrableOn f s μ\nhts : HasSubset.Subset t s\n⊢ Eq (MeasureTheory.integral (μ.restrict (SDiff.sdiff s t)) fun x => f x) (HSub.hSub (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict t) fun x => f x))","decl":"theorem integral_diff (ht : MeasurableSet t) (hfs : IntegrableOn f s μ) (hts : t ⊆ s) :\n    ∫ x in s \\ t, f x ∂μ = ∫ x in s, f x ∂μ - ∫ x in t, f x ∂μ := by\n  rw [eq_sub_iff_add_eq, ← setIntegral_union, diff_union_of_subset hts]\n  exacts [disjoint_sdiff_self_left, ht, hfs.mono_set diff_subset, hfs.mono_set hts]\n\n"}
{"name":"MeasureTheory.integral_inter_add_diff₀","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns t : Set X\nμ : MeasureTheory.Measure X\nht : MeasureTheory.NullMeasurableSet t μ\nhfs : MeasureTheory.IntegrableOn f s μ\n⊢ Eq (HAdd.hAdd (MeasureTheory.integral (μ.restrict (Inter.inter s t)) fun x => f x) (MeasureTheory.integral (μ.restrict (SDiff.sdiff s t)) fun x => f x)) (MeasureTheory.integral (μ.restrict s) fun x => f x)","decl":"theorem integral_inter_add_diff₀ (ht : NullMeasurableSet t μ) (hfs : IntegrableOn f s μ) :\n    ∫ x in s ∩ t, f x ∂μ + ∫ x in s \\ t, f x ∂μ = ∫ x in s, f x ∂μ := by\n  rw [← Measure.restrict_inter_add_diff₀ s ht, integral_add_measure]\n  · exact Integrable.mono_measure hfs (Measure.restrict_mono inter_subset_left le_rfl)\n  · exact Integrable.mono_measure hfs (Measure.restrict_mono diff_subset le_rfl)\n\n"}
{"name":"MeasureTheory.integral_inter_add_diff","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns t : Set X\nμ : MeasureTheory.Measure X\nht : MeasurableSet t\nhfs : MeasureTheory.IntegrableOn f s μ\n⊢ Eq (HAdd.hAdd (MeasureTheory.integral (μ.restrict (Inter.inter s t)) fun x => f x) (MeasureTheory.integral (μ.restrict (SDiff.sdiff s t)) fun x => f x)) (MeasureTheory.integral (μ.restrict s) fun x => f x)","decl":"theorem integral_inter_add_diff (ht : MeasurableSet t) (hfs : IntegrableOn f s μ) :\n    ∫ x in s ∩ t, f x ∂μ + ∫ x in s \\ t, f x ∂μ = ∫ x in s, f x ∂μ :=\n  integral_inter_add_diff₀ ht.nullMeasurableSet hfs\n\n"}
{"name":"MeasureTheory.integral_finset_biUnion","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\nι : Type u_5\nt : Finset ι\ns : ι → Set X\nhs : ∀ (i : ι), Membership.mem t i → MeasurableSet (s i)\nh's : (↑t).Pairwise (Function.onFun Disjoint s)\nhf : ∀ (i : ι), Membership.mem t i → MeasureTheory.IntegrableOn f (s i) μ\n⊢ Eq (MeasureTheory.integral (μ.restrict (Set.iUnion fun i => Set.iUnion fun h => s i)) fun x => f x) (t.sum fun i => MeasureTheory.integral (μ.restrict (s i)) fun x => f x)","decl":"theorem integral_finset_biUnion {ι : Type*} (t : Finset ι) {s : ι → Set X}\n    (hs : ∀ i ∈ t, MeasurableSet (s i)) (h's : Set.Pairwise (↑t) (Disjoint on s))\n    (hf : ∀ i ∈ t, IntegrableOn f (s i) μ) :\n    ∫ x in ⋃ i ∈ t, s i, f x ∂μ = ∑ i ∈ t, ∫ x in s i, f x ∂μ := by\n  classical\n  induction' t using Finset.induction_on with a t hat IH hs h's\n  · simp\n  · simp only [Finset.coe_insert, Finset.forall_mem_insert, Set.pairwise_insert,\n      Finset.set_biUnion_insert] at hs hf h's ⊢\n    rw [setIntegral_union _ _ hf.1 (integrableOn_finset_iUnion.2 hf.2)]\n    · rw [Finset.sum_insert hat, IH hs.2 h's.1 hf.2]\n    · simp only [disjoint_iUnion_right]\n      exact fun i hi => (h's.2 i hi (ne_of_mem_of_not_mem hi hat).symm).1\n    · exact Finset.measurableSet_biUnion _ hs.2\n\n"}
{"name":"MeasureTheory.integral_fintype_iUnion","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝³ : MeasurableSpace X\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\nι : Type u_5\ninst✝ : Fintype ι\ns : ι → Set X\nhs : ∀ (i : ι), MeasurableSet (s i)\nh's : Pairwise (Function.onFun Disjoint s)\nhf : ∀ (i : ι), MeasureTheory.IntegrableOn f (s i) μ\n⊢ Eq (MeasureTheory.integral (μ.restrict (Set.iUnion fun i => s i)) fun x => f x) (Finset.univ.sum fun i => MeasureTheory.integral (μ.restrict (s i)) fun x => f x)","decl":"theorem integral_fintype_iUnion {ι : Type*} [Fintype ι] {s : ι → Set X}\n    (hs : ∀ i, MeasurableSet (s i)) (h's : Pairwise (Disjoint on s))\n    (hf : ∀ i, IntegrableOn f (s i) μ) : ∫ x in ⋃ i, s i, f x ∂μ = ∑ i, ∫ x in s i, f x ∂μ := by\n  convert integral_finset_biUnion Finset.univ (fun i _ => hs i) _ fun i _ => hf i\n  · simp\n  · simp [pairwise_univ, h's]\n\n"}
{"name":"MeasureTheory.setIntegral_empty","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\n⊢ Eq (MeasureTheory.integral (μ.restrict EmptyCollection.emptyCollection) fun x => f x) 0","decl":"theorem setIntegral_empty : ∫ x in ∅, f x ∂μ = 0 := by\n  rw [Measure.restrict_empty, integral_zero_measure]\n\n"}
{"name":"MeasureTheory.integral_empty","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\n⊢ Eq (MeasureTheory.integral (μ.restrict EmptyCollection.emptyCollection) fun x => f x) 0","decl":"@[deprecated (since := \"2024-10-12\")]\nalias integral_empty := setIntegral_empty\n\n"}
{"name":"MeasureTheory.setIntegral_univ","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\n⊢ Eq (MeasureTheory.integral (μ.restrict Set.univ) fun x => f x) (MeasureTheory.integral μ fun x => f x)","decl":"theorem setIntegral_univ : ∫ x in univ, f x ∂μ = ∫ x, f x ∂μ := by rw [Measure.restrict_univ]\n\n"}
{"name":"MeasureTheory.integral_univ","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\n⊢ Eq (MeasureTheory.integral (μ.restrict Set.univ) fun x => f x) (MeasureTheory.integral μ fun x => f x)","decl":"@[deprecated (since := \"2024-10-12\")]\nalias integral_univ := setIntegral_univ\n\n"}
{"name":"MeasureTheory.integral_add_compl₀","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns : Set X\nμ : MeasureTheory.Measure X\nhs : MeasureTheory.NullMeasurableSet s μ\nhfi : MeasureTheory.Integrable f μ\n⊢ Eq (HAdd.hAdd (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict (HasCompl.compl s)) fun x => f x)) (MeasureTheory.integral μ fun x => f x)","decl":"theorem integral_add_compl₀ (hs : NullMeasurableSet s μ) (hfi : Integrable f μ) :\n    ∫ x in s, f x ∂μ + ∫ x in sᶜ, f x ∂μ = ∫ x, f x ∂μ := by\n  rw [\n    ← integral_union_ae disjoint_compl_right.aedisjoint hs.compl hfi.integrableOn hfi.integrableOn,\n    union_compl_self, setIntegral_univ]\n\n"}
{"name":"MeasureTheory.integral_add_compl","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns : Set X\nμ : MeasureTheory.Measure X\nhs : MeasurableSet s\nhfi : MeasureTheory.Integrable f μ\n⊢ Eq (HAdd.hAdd (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict (HasCompl.compl s)) fun x => f x)) (MeasureTheory.integral μ fun x => f x)","decl":"theorem integral_add_compl (hs : MeasurableSet s) (hfi : Integrable f μ) :\n    ∫ x in s, f x ∂μ + ∫ x in sᶜ, f x ∂μ = ∫ x, f x ∂μ :=\n  integral_add_compl₀ hs.nullMeasurableSet hfi\n\n"}
{"name":"MeasureTheory.setIntegral_compl","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns : Set X\nμ : MeasureTheory.Measure X\nhs : MeasurableSet s\nhfi : MeasureTheory.Integrable f μ\n⊢ Eq (MeasureTheory.integral (μ.restrict (HasCompl.compl s)) fun x => f x) (HSub.hSub (MeasureTheory.integral μ fun x => f x) (MeasureTheory.integral (μ.restrict s) fun x => f x))","decl":"theorem setIntegral_compl (hs : MeasurableSet s) (hfi : Integrable f μ) :\n    ∫ x in sᶜ, f x ∂μ = ∫ x, f x ∂μ - ∫ x in s, f x ∂μ := by\n  rw [← integral_add_compl (μ := μ) hs hfi, add_sub_cancel_left]\n\n"}
{"name":"MeasureTheory.integral_indicator","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns : Set X\nμ : MeasureTheory.Measure X\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.integral μ fun x => s.indicator f x) (MeasureTheory.integral (μ.restrict s) fun x => f x)","decl":"/-- For a function `f` and a measurable set `s`, the integral of `indicator s f`\nover the whole space is equal to `∫ x in s, f x ∂μ` defined as `∫ x, f x ∂(μ.restrict s)`. -/\ntheorem integral_indicator (hs : MeasurableSet s) :\n    ∫ x, indicator s f x ∂μ = ∫ x in s, f x ∂μ := by\n  by_cases hfi : IntegrableOn f s μ; swap\n  · rw [integral_undef hfi, integral_undef]\n    rwa [integrable_indicator_iff hs]\n  calc\n    ∫ x, indicator s f x ∂μ = ∫ x in s, indicator s f x ∂μ + ∫ x in sᶜ, indicator s f x ∂μ :=\n      (integral_add_compl hs (hfi.integrable_indicator hs)).symm\n    _ = ∫ x in s, f x ∂μ + ∫ x in sᶜ, 0 ∂μ :=\n      (congr_arg₂ (· + ·) (integral_congr_ae (indicator_ae_eq_restrict hs))\n        (integral_congr_ae (indicator_ae_eq_restrict_compl hs)))\n    _ = ∫ x in s, f x ∂μ := by simp\n\n"}
{"name":"MeasureTheory.setIntegral_indicator","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns t : Set X\nμ : MeasureTheory.Measure X\nht : MeasurableSet t\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => t.indicator f x) (MeasureTheory.integral (μ.restrict (Inter.inter s t)) fun x => f x)","decl":"theorem setIntegral_indicator (ht : MeasurableSet t) :\n    ∫ x in s, t.indicator f x ∂μ = ∫ x in s ∩ t, f x ∂μ := by\n  rw [integral_indicator ht, Measure.restrict_restrict ht, Set.inter_comm]\n\n"}
{"name":"MeasureTheory.ofReal_setIntegral_one_of_measure_ne_top","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_5\nm : MeasurableSpace X\nμ : MeasureTheory.Measure X\ns : Set X\nhs : Ne (μ s) Top.top\n⊢ Eq (ENNReal.ofReal (MeasureTheory.integral (μ.restrict s) fun x => 1)) (μ s)","decl":"theorem ofReal_setIntegral_one_of_measure_ne_top {X : Type*} {m : MeasurableSpace X}\n    {μ : Measure X} {s : Set X} (hs : μ s ≠ ∞) : ENNReal.ofReal (∫ _ in s, (1 : ℝ) ∂μ) = μ s :=\n  calc\n    ENNReal.ofReal (∫ _ in s, (1 : ℝ) ∂μ) = ENNReal.ofReal (∫ _ in s, ‖(1 : ℝ)‖ ∂μ) := by\n      simp only [norm_one]\n    _ = ∫⁻ _ in s, 1 ∂μ := by\n      simpa [ofReal_integral_norm_eq_lintegral_enorm (integrableOn_const.2 (.inr hs.lt_top))]\n    _ = μ s := setLIntegral_one _\n\n"}
{"name":"MeasureTheory.ofReal_setIntegral_one","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_5\nx✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝ : MeasureTheory.IsFiniteMeasure μ\ns : Set X\n⊢ Eq (ENNReal.ofReal (MeasureTheory.integral (μ.restrict s) fun x => 1)) (μ s)","decl":"theorem ofReal_setIntegral_one {X : Type*} {_ : MeasurableSpace X} (μ : Measure X)\n    [IsFiniteMeasure μ] (s : Set X) : ENNReal.ofReal (∫ _ in s, (1 : ℝ) ∂μ) = μ s :=\n  ofReal_setIntegral_one_of_measure_ne_top (measure_ne_top μ s)\n\n"}
{"name":"MeasureTheory.integral_piecewise","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝³ : MeasurableSpace X\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nf g : X → E\ns : Set X\nμ : MeasureTheory.Measure X\ninst✝ : DecidablePred fun x => Membership.mem s x\nhs : MeasurableSet s\nhf : MeasureTheory.IntegrableOn f s μ\nhg : MeasureTheory.IntegrableOn g (HasCompl.compl s) μ\n⊢ Eq (MeasureTheory.integral μ fun x => s.piecewise f g x) (HAdd.hAdd (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict (HasCompl.compl s)) fun x => g x))","decl":"theorem integral_piecewise [DecidablePred (· ∈ s)] (hs : MeasurableSet s) (hf : IntegrableOn f s μ)\n    (hg : IntegrableOn g sᶜ μ) :\n    ∫ x, s.piecewise f g x ∂μ = ∫ x in s, f x ∂μ + ∫ x in sᶜ, g x ∂μ := by\n  rw [← Set.indicator_add_compl_eq_piecewise,\n    integral_add' (hf.integrable_indicator hs) (hg.integrable_indicator hs.compl),\n    integral_indicator hs, integral_indicator hs.compl]\n\n"}
{"name":"MeasureTheory.tendsto_setIntegral_of_monotone","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝⁴ : MeasurableSpace X\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\nι : Type u_5\ninst✝¹ : Preorder ι\ninst✝ : Filter.atTop.IsCountablyGenerated\ns : ι → Set X\nhsm : ∀ (i : ι), MeasurableSet (s i)\nh_mono : Monotone s\nhfi : MeasureTheory.IntegrableOn f (Set.iUnion fun n => s n) μ\n⊢ Filter.Tendsto (fun i => MeasureTheory.integral (μ.restrict (s i)) fun x => f x) Filter.atTop (nhds (MeasureTheory.integral (μ.restrict (Set.iUnion fun n => s n)) fun x => f x))","decl":"theorem tendsto_setIntegral_of_monotone\n    {ι : Type*} [Preorder ι] [(atTop : Filter ι).IsCountablyGenerated]\n    {s : ι → Set X} (hsm : ∀ i, MeasurableSet (s i)) (h_mono : Monotone s)\n    (hfi : IntegrableOn f (⋃ n, s n) μ) :\n    Tendsto (fun i => ∫ x in s i, f x ∂μ) atTop (𝓝 (∫ x in ⋃ n, s n, f x ∂μ)) := by\n  refine .of_neBot_imp fun hne ↦ ?_\n  have := (atTop_neBot_iff.mp hne).2\n  have hfi' : ∫⁻ x in ⋃ n, s n, ‖f x‖₊ ∂μ < ∞ := hfi.2\n  set S := ⋃ i, s i\n  have hSm : MeasurableSet S := MeasurableSet.iUnion_of_monotone h_mono hsm\n  have hsub {i} : s i ⊆ S := subset_iUnion s i\n  rw [← withDensity_apply _ hSm] at hfi'\n  set ν := μ.withDensity (‖f ·‖ₑ) with hν\n  refine Metric.nhds_basis_closedBall.tendsto_right_iff.2 fun ε ε0 => ?_\n  lift ε to ℝ≥0 using ε0.le\n  have : ∀ᶠ i in atTop, ν (s i) ∈ Icc (ν S - ε) (ν S + ε) :=\n    tendsto_measure_iUnion_atTop h_mono (ENNReal.Icc_mem_nhds hfi'.ne (ENNReal.coe_pos.2 ε0).ne')\n  filter_upwards [this] with i hi\n  rw [mem_closedBall_iff_norm', ← integral_diff (hsm i) hfi hsub, ← coe_nnnorm, NNReal.coe_le_coe, ←\n    ENNReal.coe_le_coe]\n  refine (enorm_integral_le_lintegral_enorm _).trans ?_\n  rw [← withDensity_apply _ (hSm.diff (hsm _)), ← hν, measure_diff hsub (hsm _).nullMeasurableSet]\n  exacts [tsub_le_iff_tsub_le.mp hi.1,\n    (hi.2.trans_lt <| ENNReal.add_lt_top.2 ⟨hfi', ENNReal.coe_lt_top⟩).ne]\n\n"}
{"name":"MeasureTheory.tendsto_setIntegral_of_antitone","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝⁴ : MeasurableSpace X\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\nι : Type u_5\ninst✝¹ : Preorder ι\ninst✝ : Filter.atTop.IsCountablyGenerated\ns : ι → Set X\nhsm : ∀ (i : ι), MeasurableSet (s i)\nh_anti : Antitone s\nhfi : Exists fun i => MeasureTheory.IntegrableOn f (s i) μ\n⊢ Filter.Tendsto (fun i => MeasureTheory.integral (μ.restrict (s i)) fun x => f x) Filter.atTop (nhds (MeasureTheory.integral (μ.restrict (Set.iInter fun n => s n)) fun x => f x))","decl":"theorem tendsto_setIntegral_of_antitone\n    {ι : Type*} [Preorder ι] [(atTop : Filter ι).IsCountablyGenerated]\n    {s : ι → Set X} (hsm : ∀ i, MeasurableSet (s i)) (h_anti : Antitone s)\n    (hfi : ∃ i, IntegrableOn f (s i) μ) :\n    Tendsto (fun i ↦ ∫ x in s i, f x ∂μ) atTop (𝓝 (∫ x in ⋂ n, s n, f x ∂μ)) := by\n  refine .of_neBot_imp fun hne ↦ ?_\n  have := (atTop_neBot_iff.mp hne).2\n  rcases hfi with ⟨i₀, hi₀⟩\n  suffices Tendsto (∫ x in s i₀, f x ∂μ - ∫ x in s i₀ \\ s ·, f x ∂μ) atTop\n      (𝓝 (∫ x in s i₀, f x ∂μ - ∫ x in ⋃ i, s i₀ \\ s i, f x ∂μ)) by\n    convert this.congr' <| (eventually_ge_atTop i₀).mono fun i hi ↦ ?_\n    · rw [← diff_iInter, integral_diff _ hi₀ (iInter_subset _ _), sub_sub_cancel]\n      exact .iInter_of_antitone h_anti hsm\n    · rw [integral_diff (hsm i) hi₀ (h_anti hi), sub_sub_cancel]\n  apply tendsto_const_nhds.sub\n  refine tendsto_setIntegral_of_monotone (by measurability) ?_ ?_\n  · exact fun i j h ↦ diff_subset_diff_right (h_anti h)\n  · rw [← diff_iInter]\n    exact hi₀.mono_set diff_subset\n\n"}
{"name":"MeasureTheory.hasSum_integral_iUnion_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝³ : MeasurableSpace X\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\nι : Type u_5\ninst✝ : Countable ι\ns : ι → Set X\nhm : ∀ (i : ι), MeasureTheory.NullMeasurableSet (s i) μ\nhd : Pairwise (Function.onFun (MeasureTheory.AEDisjoint μ) s)\nhfi : MeasureTheory.IntegrableOn f (Set.iUnion fun i => s i) μ\n⊢ HasSum (fun n => MeasureTheory.integral (μ.restrict (s n)) fun x => f x) (MeasureTheory.integral (μ.restrict (Set.iUnion fun n => s n)) fun x => f x)","decl":"theorem hasSum_integral_iUnion_ae {ι : Type*} [Countable ι] {s : ι → Set X}\n    (hm : ∀ i, NullMeasurableSet (s i) μ) (hd : Pairwise (AEDisjoint μ on s))\n    (hfi : IntegrableOn f (⋃ i, s i) μ) :\n    HasSum (fun n => ∫ x in s n, f x ∂μ) (∫ x in ⋃ n, s n, f x ∂μ) := by\n  simp only [IntegrableOn, Measure.restrict_iUnion_ae hd hm] at hfi ⊢\n  exact hasSum_integral_measure hfi\n\n"}
{"name":"MeasureTheory.hasSum_integral_iUnion","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝³ : MeasurableSpace X\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\nι : Type u_5\ninst✝ : Countable ι\ns : ι → Set X\nhm : ∀ (i : ι), MeasurableSet (s i)\nhd : Pairwise (Function.onFun Disjoint s)\nhfi : MeasureTheory.IntegrableOn f (Set.iUnion fun i => s i) μ\n⊢ HasSum (fun n => MeasureTheory.integral (μ.restrict (s n)) fun x => f x) (MeasureTheory.integral (μ.restrict (Set.iUnion fun n => s n)) fun x => f x)","decl":"theorem hasSum_integral_iUnion {ι : Type*} [Countable ι] {s : ι → Set X}\n    (hm : ∀ i, MeasurableSet (s i)) (hd : Pairwise (Disjoint on s))\n    (hfi : IntegrableOn f (⋃ i, s i) μ) :\n    HasSum (fun n => ∫ x in s n, f x ∂μ) (∫ x in ⋃ n, s n, f x ∂μ) :=\n  hasSum_integral_iUnion_ae (fun i => (hm i).nullMeasurableSet) (hd.mono fun _ _ h => h.aedisjoint)\n    hfi\n\n"}
{"name":"MeasureTheory.integral_iUnion","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝³ : MeasurableSpace X\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\nι : Type u_5\ninst✝ : Countable ι\ns : ι → Set X\nhm : ∀ (i : ι), MeasurableSet (s i)\nhd : Pairwise (Function.onFun Disjoint s)\nhfi : MeasureTheory.IntegrableOn f (Set.iUnion fun i => s i) μ\n⊢ Eq (MeasureTheory.integral (μ.restrict (Set.iUnion fun n => s n)) fun x => f x) (tsum fun n => MeasureTheory.integral (μ.restrict (s n)) fun x => f x)","decl":"theorem integral_iUnion {ι : Type*} [Countable ι] {s : ι → Set X} (hm : ∀ i, MeasurableSet (s i))\n    (hd : Pairwise (Disjoint on s)) (hfi : IntegrableOn f (⋃ i, s i) μ) :\n    ∫ x in ⋃ n, s n, f x ∂μ = ∑' n, ∫ x in s n, f x ∂μ :=\n  (HasSum.tsum_eq (hasSum_integral_iUnion hm hd hfi)).symm\n\n"}
{"name":"MeasureTheory.integral_iUnion_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝³ : MeasurableSpace X\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\nι : Type u_5\ninst✝ : Countable ι\ns : ι → Set X\nhm : ∀ (i : ι), MeasureTheory.NullMeasurableSet (s i) μ\nhd : Pairwise (Function.onFun (MeasureTheory.AEDisjoint μ) s)\nhfi : MeasureTheory.IntegrableOn f (Set.iUnion fun i => s i) μ\n⊢ Eq (MeasureTheory.integral (μ.restrict (Set.iUnion fun n => s n)) fun x => f x) (tsum fun n => MeasureTheory.integral (μ.restrict (s n)) fun x => f x)","decl":"theorem integral_iUnion_ae {ι : Type*} [Countable ι] {s : ι → Set X}\n    (hm : ∀ i, NullMeasurableSet (s i) μ) (hd : Pairwise (AEDisjoint μ on s))\n    (hfi : IntegrableOn f (⋃ i, s i) μ) : ∫ x in ⋃ n, s n, f x ∂μ = ∑' n, ∫ x in s n, f x ∂μ :=\n  (HasSum.tsum_eq (hasSum_integral_iUnion_ae hm hd hfi)).symm\n\n"}
{"name":"MeasureTheory.setIntegral_eq_zero_of_ae_eq_zero","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\nt : Set X\nμ : MeasureTheory.Measure X\nht_eq : Filter.Eventually (fun x => Membership.mem t x → Eq (f x) 0) (MeasureTheory.ae μ)\n⊢ Eq (MeasureTheory.integral (μ.restrict t) fun x => f x) 0","decl":"theorem setIntegral_eq_zero_of_ae_eq_zero (ht_eq : ∀ᵐ x ∂μ, x ∈ t → f x = 0) :\n    ∫ x in t, f x ∂μ = 0 := by\n  by_cases hf : AEStronglyMeasurable f (μ.restrict t); swap\n  · rw [integral_undef]\n    contrapose! hf\n    exact hf.1\n  have : ∫ x in t, hf.mk f x ∂μ = 0 := by\n    refine integral_eq_zero_of_ae ?_\n    rw [EventuallyEq,\n      ae_restrict_iff (hf.stronglyMeasurable_mk.measurableSet_eq_fun stronglyMeasurable_zero)]\n    filter_upwards [ae_imp_of_ae_restrict hf.ae_eq_mk, ht_eq] with x hx h'x h''x\n    rw [← hx h''x]\n    exact h'x h''x\n  rw [← this]\n  exact integral_congr_ae hf.ae_eq_mk\n\n"}
{"name":"MeasureTheory.setIntegral_eq_zero_of_forall_eq_zero","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\nt : Set X\nμ : MeasureTheory.Measure X\nht_eq : ∀ (x : X), Membership.mem t x → Eq (f x) 0\n⊢ Eq (MeasureTheory.integral (μ.restrict t) fun x => f x) 0","decl":"theorem setIntegral_eq_zero_of_forall_eq_zero (ht_eq : ∀ x ∈ t, f x = 0) :\n    ∫ x in t, f x ∂μ = 0 :=\n  setIntegral_eq_zero_of_ae_eq_zero (Eventually.of_forall ht_eq)\n\n"}
{"name":"MeasureTheory.integral_union_eq_left_of_ae_aux","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns t : Set X\nμ : MeasureTheory.Measure X\nht_eq : Filter.Eventually (fun x => Eq (f x) 0) (MeasureTheory.ae (μ.restrict t))\nhaux : MeasureTheory.StronglyMeasurable f\nH : MeasureTheory.IntegrableOn f (Union.union s t) μ\n⊢ Eq (MeasureTheory.integral (μ.restrict (Union.union s t)) fun x => f x) (MeasureTheory.integral (μ.restrict s) fun x => f x)","decl":"theorem integral_union_eq_left_of_ae_aux (ht_eq : ∀ᵐ x ∂μ.restrict t, f x = 0)\n    (haux : StronglyMeasurable f) (H : IntegrableOn f (s ∪ t) μ) :\n    ∫ x in s ∪ t, f x ∂μ = ∫ x in s, f x ∂μ := by\n  let k := f ⁻¹' {0}\n  have hk : MeasurableSet k := by borelize E; exact haux.measurable (measurableSet_singleton _)\n  have h's : IntegrableOn f s μ := H.mono subset_union_left le_rfl\n  have A : ∀ u : Set X, ∫ x in u ∩ k, f x ∂μ = 0 := fun u =>\n    setIntegral_eq_zero_of_forall_eq_zero fun x hx => hx.2\n  rw [← integral_inter_add_diff hk h's, ← integral_inter_add_diff hk H, A, A, zero_add, zero_add,\n    union_diff_distrib, union_comm]\n  apply setIntegral_congr_set\n  rw [union_ae_eq_right]\n  apply measure_mono_null diff_subset\n  rw [measure_zero_iff_ae_nmem]\n  filter_upwards [ae_imp_of_ae_restrict ht_eq] with x hx h'x using h'x.2 (hx h'x.1)\n\n"}
{"name":"MeasureTheory.integral_union_eq_left_of_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns t : Set X\nμ : MeasureTheory.Measure X\nht_eq : Filter.Eventually (fun x => Eq (f x) 0) (MeasureTheory.ae (μ.restrict t))\n⊢ Eq (MeasureTheory.integral (μ.restrict (Union.union s t)) fun x => f x) (MeasureTheory.integral (μ.restrict s) fun x => f x)","decl":"theorem integral_union_eq_left_of_ae (ht_eq : ∀ᵐ x ∂μ.restrict t, f x = 0) :\n    ∫ x in s ∪ t, f x ∂μ = ∫ x in s, f x ∂μ := by\n  have ht : IntegrableOn f t μ := by apply integrableOn_zero.congr_fun_ae; symm; exact ht_eq\n  by_cases H : IntegrableOn f (s ∪ t) μ; swap\n  · rw [integral_undef H, integral_undef]; simpa [integrableOn_union, ht] using H\n  let f' := H.1.mk f\n  calc\n    ∫ x : X in s ∪ t, f x ∂μ = ∫ x : X in s ∪ t, f' x ∂μ := integral_congr_ae H.1.ae_eq_mk\n    _ = ∫ x in s, f' x ∂μ := by\n      apply\n        integral_union_eq_left_of_ae_aux _ H.1.stronglyMeasurable_mk (H.congr_fun_ae H.1.ae_eq_mk)\n      filter_upwards [ht_eq,\n        ae_mono (Measure.restrict_mono subset_union_right le_rfl) H.1.ae_eq_mk] with x hx h'x\n      rw [← h'x, hx]\n    _ = ∫ x in s, f x ∂μ :=\n      integral_congr_ae\n        (ae_mono (Measure.restrict_mono subset_union_left le_rfl) H.1.ae_eq_mk.symm)\n\n"}
{"name":"MeasureTheory.integral_union_eq_left_of_forall₀","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\ns t : Set X\nμ : MeasureTheory.Measure X\nf : X → E\nht : MeasureTheory.NullMeasurableSet t μ\nht_eq : ∀ (x : X), Membership.mem t x → Eq (f x) 0\n⊢ Eq (MeasureTheory.integral (μ.restrict (Union.union s t)) fun x => f x) (MeasureTheory.integral (μ.restrict s) fun x => f x)","decl":"theorem integral_union_eq_left_of_forall₀ {f : X → E} (ht : NullMeasurableSet t μ)\n    (ht_eq : ∀ x ∈ t, f x = 0) : ∫ x in s ∪ t, f x ∂μ = ∫ x in s, f x ∂μ :=\n  integral_union_eq_left_of_ae ((ae_restrict_iff'₀ ht).2 (Eventually.of_forall ht_eq))\n\n"}
{"name":"MeasureTheory.integral_union_eq_left_of_forall","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\ns t : Set X\nμ : MeasureTheory.Measure X\nf : X → E\nht : MeasurableSet t\nht_eq : ∀ (x : X), Membership.mem t x → Eq (f x) 0\n⊢ Eq (MeasureTheory.integral (μ.restrict (Union.union s t)) fun x => f x) (MeasureTheory.integral (μ.restrict s) fun x => f x)","decl":"theorem integral_union_eq_left_of_forall {f : X → E} (ht : MeasurableSet t)\n    (ht_eq : ∀ x ∈ t, f x = 0) : ∫ x in s ∪ t, f x ∂μ = ∫ x in s, f x ∂μ :=\n  integral_union_eq_left_of_forall₀ ht.nullMeasurableSet ht_eq\n\n"}
{"name":"MeasureTheory.setIntegral_eq_of_subset_of_ae_diff_eq_zero_aux","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns t : Set X\nμ : MeasureTheory.Measure X\nhts : HasSubset.Subset s t\nh't : Filter.Eventually (fun x => Membership.mem (SDiff.sdiff t s) x → Eq (f x) 0) (MeasureTheory.ae μ)\nhaux : MeasureTheory.StronglyMeasurable f\nh'aux : MeasureTheory.IntegrableOn f t μ\n⊢ Eq (MeasureTheory.integral (μ.restrict t) fun x => f x) (MeasureTheory.integral (μ.restrict s) fun x => f x)","decl":"theorem setIntegral_eq_of_subset_of_ae_diff_eq_zero_aux (hts : s ⊆ t)\n    (h't : ∀ᵐ x ∂μ, x ∈ t \\ s → f x = 0) (haux : StronglyMeasurable f)\n    (h'aux : IntegrableOn f t μ) : ∫ x in t, f x ∂μ = ∫ x in s, f x ∂μ := by\n  let k := f ⁻¹' {0}\n  have hk : MeasurableSet k := by borelize E; exact haux.measurable (measurableSet_singleton _)\n  calc\n    ∫ x in t, f x ∂μ = ∫ x in t ∩ k, f x ∂μ + ∫ x in t \\ k, f x ∂μ := by\n      rw [integral_inter_add_diff hk h'aux]\n    _ = ∫ x in t \\ k, f x ∂μ := by\n      rw [setIntegral_eq_zero_of_forall_eq_zero fun x hx => ?_, zero_add]; exact hx.2\n    _ = ∫ x in s \\ k, f x ∂μ := by\n      apply setIntegral_congr_set\n      filter_upwards [h't] with x hx\n      change (x ∈ t \\ k) = (x ∈ s \\ k)\n      simp only [mem_preimage, mem_singleton_iff, eq_iff_iff, and_congr_left_iff, mem_diff]\n      intro h'x\n      by_cases xs : x ∈ s\n      · simp only [xs, hts xs]\n      · simp only [xs, iff_false]\n        intro xt\n        exact h'x (hx ⟨xt, xs⟩)\n    _ = ∫ x in s ∩ k, f x ∂μ + ∫ x in s \\ k, f x ∂μ := by\n      have : ∀ x ∈ s ∩ k, f x = 0 := fun x hx => hx.2\n      rw [setIntegral_eq_zero_of_forall_eq_zero this, zero_add]\n    _ = ∫ x in s, f x ∂μ := by rw [integral_inter_add_diff hk (h'aux.mono hts le_rfl)]\n\n"}
{"name":"MeasureTheory.setIntegral_eq_of_subset_of_ae_diff_eq_zero","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns t : Set X\nμ : MeasureTheory.Measure X\nht : MeasureTheory.NullMeasurableSet t μ\nhts : HasSubset.Subset s t\nh't : Filter.Eventually (fun x => Membership.mem (SDiff.sdiff t s) x → Eq (f x) 0) (MeasureTheory.ae μ)\n⊢ Eq (MeasureTheory.integral (μ.restrict t) fun x => f x) (MeasureTheory.integral (μ.restrict s) fun x => f x)","decl":"/-- If a function vanishes almost everywhere on `t \\ s` with `s ⊆ t`, then its integrals on `s`\nand `t` coincide if `t` is null-measurable. -/\ntheorem setIntegral_eq_of_subset_of_ae_diff_eq_zero (ht : NullMeasurableSet t μ) (hts : s ⊆ t)\n    (h't : ∀ᵐ x ∂μ, x ∈ t \\ s → f x = 0) : ∫ x in t, f x ∂μ = ∫ x in s, f x ∂μ := by\n  by_cases h : IntegrableOn f t μ; swap\n  · have : ¬IntegrableOn f s μ := fun H => h (H.of_ae_diff_eq_zero ht h't)\n    rw [integral_undef h, integral_undef this]\n  let f' := h.1.mk f\n  calc\n    ∫ x in t, f x ∂μ = ∫ x in t, f' x ∂μ := integral_congr_ae h.1.ae_eq_mk\n    _ = ∫ x in s, f' x ∂μ := by\n      apply\n        setIntegral_eq_of_subset_of_ae_diff_eq_zero_aux hts _ h.1.stronglyMeasurable_mk\n          (h.congr h.1.ae_eq_mk)\n      filter_upwards [h't, ae_imp_of_ae_restrict h.1.ae_eq_mk] with x hx h'x h''x\n      rw [← h'x h''x.1, hx h''x]\n    _ = ∫ x in s, f x ∂μ := by\n      apply integral_congr_ae\n      apply ae_restrict_of_ae_restrict_of_subset hts\n      exact h.1.ae_eq_mk.symm\n\n"}
{"name":"MeasureTheory.setIntegral_eq_of_subset_of_forall_diff_eq_zero","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns t : Set X\nμ : MeasureTheory.Measure X\nht : MeasurableSet t\nhts : HasSubset.Subset s t\nh't : ∀ (x : X), Membership.mem (SDiff.sdiff t s) x → Eq (f x) 0\n⊢ Eq (MeasureTheory.integral (μ.restrict t) fun x => f x) (MeasureTheory.integral (μ.restrict s) fun x => f x)","decl":"/-- If a function vanishes on `t \\ s` with `s ⊆ t`, then its integrals on `s`\nand `t` coincide if `t` is measurable. -/\ntheorem setIntegral_eq_of_subset_of_forall_diff_eq_zero (ht : MeasurableSet t) (hts : s ⊆ t)\n    (h't : ∀ x ∈ t \\ s, f x = 0) : ∫ x in t, f x ∂μ = ∫ x in s, f x ∂μ :=\n  setIntegral_eq_of_subset_of_ae_diff_eq_zero ht.nullMeasurableSet hts\n    (Eventually.of_forall fun x hx => h't x hx)\n\n"}
{"name":"MeasureTheory.setIntegral_eq_integral_of_ae_compl_eq_zero","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns : Set X\nμ : MeasureTheory.Measure X\nh : Filter.Eventually (fun x => Not (Membership.mem s x) → Eq (f x) 0) (MeasureTheory.ae μ)\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral μ fun x => f x)","decl":"/-- If a function vanishes almost everywhere on `sᶜ`, then its integral on `s`\ncoincides with its integral on the whole space. -/\ntheorem setIntegral_eq_integral_of_ae_compl_eq_zero (h : ∀ᵐ x ∂μ, x ∉ s → f x = 0) :\n    ∫ x in s, f x ∂μ = ∫ x, f x ∂μ := by\n  symm\n  nth_rw 1 [← setIntegral_univ]\n  apply setIntegral_eq_of_subset_of_ae_diff_eq_zero nullMeasurableSet_univ (subset_univ _)\n  filter_upwards [h] with x hx h'x using hx h'x.2\n\n"}
{"name":"MeasureTheory.setIntegral_eq_integral_of_forall_compl_eq_zero","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns : Set X\nμ : MeasureTheory.Measure X\nh : ∀ (x : X), Not (Membership.mem s x) → Eq (f x) 0\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral μ fun x => f x)","decl":"/-- If a function vanishes on `sᶜ`, then its integral on `s` coincides with its integral on the\nwhole space. -/\ntheorem setIntegral_eq_integral_of_forall_compl_eq_zero (h : ∀ x, x ∉ s → f x = 0) :\n    ∫ x in s, f x ∂μ = ∫ x, f x ∂μ :=\n  setIntegral_eq_integral_of_ae_compl_eq_zero (Eventually.of_forall h)\n\n"}
{"name":"MeasureTheory.setIntegral_neg_eq_setIntegral_nonpos","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝³ : MeasurableSpace X\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nμ : MeasureTheory.Measure X\ninst✝ : LinearOrder E\nf : X → E\nhf : MeasureTheory.AEStronglyMeasurable f μ\n⊢ Eq (MeasureTheory.integral (μ.restrict (setOf fun x => LT.lt (f x) 0)) fun x => f x) (MeasureTheory.integral (μ.restrict (setOf fun x => LE.le (f x) 0)) fun x => f x)","decl":"theorem setIntegral_neg_eq_setIntegral_nonpos [LinearOrder E] {f : X → E}\n    (hf : AEStronglyMeasurable f μ) :\n    ∫ x in {x | f x < 0}, f x ∂μ = ∫ x in {x | f x ≤ 0}, f x ∂μ := by\n  have h_union : {x | f x ≤ 0} = {x | f x < 0} ∪ {x | f x = 0} := by\n    simp_rw [le_iff_lt_or_eq, setOf_or]\n  rw [h_union]\n  have B : NullMeasurableSet {x | f x = 0} μ :=\n    hf.nullMeasurableSet_eq_fun aestronglyMeasurable_zero\n  symm\n  refine integral_union_eq_left_of_ae ?_\n  filter_upwards [ae_restrict_mem₀ B] with x hx using hx\n\n"}
{"name":"MeasureTheory.integral_norm_eq_pos_sub_neg","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf : X → Real\nhfi : MeasureTheory.Integrable f μ\n⊢ Eq (MeasureTheory.integral μ fun x => Norm.norm (f x)) (HSub.hSub (MeasureTheory.integral (μ.restrict (setOf fun x => LE.le 0 (f x))) fun x => f x) (MeasureTheory.integral (μ.restrict (setOf fun x => LE.le (f x) 0)) fun x => f x))","decl":"theorem integral_norm_eq_pos_sub_neg {f : X → ℝ} (hfi : Integrable f μ) :\n    ∫ x, ‖f x‖ ∂μ = ∫ x in {x | 0 ≤ f x}, f x ∂μ - ∫ x in {x | f x ≤ 0}, f x ∂μ :=\n  have h_meas : NullMeasurableSet {x | 0 ≤ f x} μ :=\n    aestronglyMeasurable_const.nullMeasurableSet_le hfi.1\n  calc\n    ∫ x, ‖f x‖ ∂μ = ∫ x in {x | 0 ≤ f x}, ‖f x‖ ∂μ + ∫ x in {x | 0 ≤ f x}ᶜ, ‖f x‖ ∂μ := by\n      rw [← integral_add_compl₀ h_meas hfi.norm]\n    _ = ∫ x in {x | 0 ≤ f x}, f x ∂μ + ∫ x in {x | 0 ≤ f x}ᶜ, ‖f x‖ ∂μ := by\n      congr 1\n      refine setIntegral_congr_fun₀ h_meas fun x hx => ?_\n      dsimp only\n      rw [Real.norm_eq_abs, abs_eq_self.mpr _]\n      exact hx\n    _ = ∫ x in {x | 0 ≤ f x}, f x ∂μ - ∫ x in {x | 0 ≤ f x}ᶜ, f x ∂μ := by\n      congr 1\n      rw [← integral_neg]\n      refine setIntegral_congr_fun₀ h_meas.compl fun x hx => ?_\n      dsimp only\n      rw [Real.norm_eq_abs, abs_eq_neg_self.mpr _]\n      rw [Set.mem_compl_iff, Set.nmem_setOf_iff] at hx\n      linarith\n    _ = ∫ x in {x | 0 ≤ f x}, f x ∂μ - ∫ x in {x | f x ≤ 0}, f x ∂μ := by\n      rw [← setIntegral_neg_eq_setIntegral_nonpos hfi.1, compl_setOf]; simp only [not_le]\n\n"}
{"name":"MeasureTheory.setIntegral_const","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝³ : MeasurableSpace X\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ns : Set X\nμ : MeasureTheory.Measure X\ninst✝ : CompleteSpace E\nc : E\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => c) (HSMul.hSMul (μ s).toReal c)","decl":"theorem setIntegral_const [CompleteSpace E] (c : E) : ∫ _ in s, c ∂μ = (μ s).toReal • c := by\n  rw [integral_const, Measure.restrict_apply_univ]\n\n"}
{"name":"MeasureTheory.integral_indicator_const","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝³ : MeasurableSpace X\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nμ : MeasureTheory.Measure X\ninst✝ : CompleteSpace E\ne : E\ns : Set X\ns_meas : MeasurableSet s\n⊢ Eq (MeasureTheory.integral μ fun x => s.indicator (fun x => e) x) (HSMul.hSMul (μ s).toReal e)","decl":"@[simp]\ntheorem integral_indicator_const [CompleteSpace E] (e : E) ⦃s : Set X⦄ (s_meas : MeasurableSet s) :\n    ∫ x : X, s.indicator (fun _ : X => e) x ∂μ = (μ s).toReal • e := by\n  rw [integral_indicator s_meas, ← setIntegral_const]\n\n"}
{"name":"MeasureTheory.integral_indicator_one","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\ns : Set X\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.integral μ fun x => s.indicator 1 x) (μ s).toReal","decl":"@[simp]\ntheorem integral_indicator_one ⦃s : Set X⦄ (hs : MeasurableSet s) :\n    ∫ x, s.indicator 1 x ∂μ = (μ s).toReal :=\n  (integral_indicator_const 1 hs).trans ((smul_eq_mul _).trans (mul_one _))\n\n"}
{"name":"MeasureTheory.setIntegral_indicatorConstLp","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝³ : MeasurableSpace X\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ns t : Set X\nμ : MeasureTheory.Measure X\ninst✝ : CompleteSpace E\np : ENNReal\nhs : MeasurableSet s\nht : MeasurableSet t\nhμt : Ne (μ t) Top.top\ne : E\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => ↑↑(MeasureTheory.indicatorConstLp p ht hμt e) x) (HSMul.hSMul (μ (Inter.inter t s)).toReal e)","decl":"theorem setIntegral_indicatorConstLp [CompleteSpace E]\n    {p : ℝ≥0∞} (hs : MeasurableSet s) (ht : MeasurableSet t) (hμt : μ t ≠ ∞) (e : E) :\n    ∫ x in s, indicatorConstLp p ht hμt e x ∂μ = (μ (t ∩ s)).toReal • e :=\n  calc\n    ∫ x in s, indicatorConstLp p ht hμt e x ∂μ = ∫ x in s, t.indicator (fun _ => e) x ∂μ := by\n      rw [setIntegral_congr_ae hs (indicatorConstLp_coeFn.mono fun x hx _ => hx)]\n    _ = (μ (t ∩ s)).toReal • e := by rw [integral_indicator_const _ ht, Measure.restrict_apply ht]\n\n"}
{"name":"MeasureTheory.integral_indicatorConstLp","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝³ : MeasurableSpace X\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nt : Set X\nμ : MeasureTheory.Measure X\ninst✝ : CompleteSpace E\np : ENNReal\nht : MeasurableSet t\nhμt : Ne (μ t) Top.top\ne : E\n⊢ Eq (MeasureTheory.integral μ fun x => ↑↑(MeasureTheory.indicatorConstLp p ht hμt e) x) (HSMul.hSMul (μ t).toReal e)","decl":"theorem integral_indicatorConstLp [CompleteSpace E]\n    {p : ℝ≥0∞} (ht : MeasurableSet t) (hμt : μ t ≠ ∞) (e : E) :\n    ∫ x, indicatorConstLp p ht hμt e x ∂μ = (μ t).toReal • e :=\n  calc\n    ∫ x, indicatorConstLp p ht hμt e x ∂μ = ∫ x in univ, indicatorConstLp p ht hμt e x ∂μ := by\n      rw [setIntegral_univ]\n    _ = (μ (t ∩ univ)).toReal • e := setIntegral_indicatorConstLp MeasurableSet.univ ht hμt e\n    _ = (μ t).toReal • e := by rw [inter_univ]\n\n"}
{"name":"MeasureTheory.setIntegral_map","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝³ : MeasurableSpace X\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nμ : MeasureTheory.Measure X\nY : Type u_5\ninst✝ : MeasurableSpace Y\ng : X → Y\nf : Y → E\ns : Set Y\nhs : MeasurableSet s\nhf : MeasureTheory.AEStronglyMeasurable f (MeasureTheory.Measure.map g μ)\nhg : AEMeasurable g μ\n⊢ Eq (MeasureTheory.integral ((MeasureTheory.Measure.map g μ).restrict s) fun y => f y) (MeasureTheory.integral (μ.restrict (Set.preimage g s)) fun x => f (g x))","decl":"theorem setIntegral_map {Y} [MeasurableSpace Y] {g : X → Y} {f : Y → E} {s : Set Y}\n    (hs : MeasurableSet s) (hf : AEStronglyMeasurable f (Measure.map g μ)) (hg : AEMeasurable g μ) :\n    ∫ y in s, f y ∂Measure.map g μ = ∫ x in g ⁻¹' s, f (g x) ∂μ := by\n  rw [Measure.restrict_map_of_aemeasurable hg hs,\n    integral_map (hg.mono_measure Measure.restrict_le_self) (hf.mono_measure _)]\n  exact Measure.map_mono_of_aemeasurable Measure.restrict_le_self hg\n\n"}
{"name":"MeasurableEmbedding.setIntegral_map","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nμ : MeasureTheory.Measure X\nY : Type u_5\nx✝ : MeasurableSpace Y\nf : X → Y\nhf : MeasurableEmbedding f\ng : Y → E\ns : Set Y\n⊢ Eq (MeasureTheory.integral ((MeasureTheory.Measure.map f μ).restrict s) fun y => g y) (MeasureTheory.integral (μ.restrict (Set.preimage f s)) fun x => g (f x))","decl":"theorem _root_.MeasurableEmbedding.setIntegral_map {Y} {_ : MeasurableSpace Y} {f : X → Y}\n    (hf : MeasurableEmbedding f) (g : Y → E) (s : Set Y) :\n    ∫ y in s, g y ∂Measure.map f μ = ∫ x in f ⁻¹' s, g (f x) ∂μ := by\n  rw [hf.restrict_map, hf.integral_map]\n\n"}
{"name":"Topology.IsClosedEmbedding.setIntegral_map","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝⁷ : MeasurableSpace X\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Real E\nμ : MeasureTheory.Measure X\ninst✝⁴ : TopologicalSpace X\ninst✝³ : BorelSpace X\nY : Type u_5\ninst✝² : MeasurableSpace Y\ninst✝¹ : TopologicalSpace Y\ninst✝ : BorelSpace Y\ng : X → Y\nf : Y → E\ns : Set Y\nhg : Topology.IsClosedEmbedding g\n⊢ Eq (MeasureTheory.integral ((MeasureTheory.Measure.map g μ).restrict s) fun y => f y) (MeasureTheory.integral (μ.restrict (Set.preimage g s)) fun x => f (g x))","decl":"theorem _root_.Topology.IsClosedEmbedding.setIntegral_map [TopologicalSpace X] [BorelSpace X] {Y}\n    [MeasurableSpace Y] [TopologicalSpace Y] [BorelSpace Y] {g : X → Y} {f : Y → E} (s : Set Y)\n    (hg : IsClosedEmbedding g) : ∫ y in s, f y ∂Measure.map g μ = ∫ x in g ⁻¹' s, f (g x) ∂μ :=\n  hg.measurableEmbedding.setIntegral_map _ _\n\n"}
{"name":"ClosedEmbedding.setIntegral_map","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝⁷ : MeasurableSpace X\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Real E\nμ : MeasureTheory.Measure X\ninst✝⁴ : TopologicalSpace X\ninst✝³ : BorelSpace X\nY : Type u_5\ninst✝² : MeasurableSpace Y\ninst✝¹ : TopologicalSpace Y\ninst✝ : BorelSpace Y\ng : X → Y\nf : Y → E\ns : Set Y\nhg : Topology.IsClosedEmbedding g\n⊢ Eq (MeasureTheory.integral ((MeasureTheory.Measure.map g μ).restrict s) fun y => f y) (MeasureTheory.integral (μ.restrict (Set.preimage g s)) fun x => f (g x))","decl":"@[deprecated (since := \"2024-10-20\")]\nalias _root_.ClosedEmbedding.setIntegral_map := IsClosedEmbedding.setIntegral_map\n\n"}
{"name":"MeasureTheory.MeasurePreserving.setIntegral_preimage_emb","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nμ : MeasureTheory.Measure X\nY : Type u_5\nx✝ : MeasurableSpace Y\nf : X → Y\nν : MeasureTheory.Measure Y\nh₁ : MeasureTheory.MeasurePreserving f μ ν\nh₂ : MeasurableEmbedding f\ng : Y → E\ns : Set Y\n⊢ Eq (MeasureTheory.integral (μ.restrict (Set.preimage f s)) fun x => g (f x)) (MeasureTheory.integral (ν.restrict s) fun y => g y)","decl":"theorem MeasurePreserving.setIntegral_preimage_emb {Y} {_ : MeasurableSpace Y} {f : X → Y} {ν}\n    (h₁ : MeasurePreserving f μ ν) (h₂ : MeasurableEmbedding f) (g : Y → E) (s : Set Y) :\n    ∫ x in f ⁻¹' s, g (f x) ∂μ = ∫ y in s, g y ∂ν :=\n  (h₁.restrict_preimage_emb h₂ s).integral_comp h₂ _\n\n"}
{"name":"MeasureTheory.MeasurePreserving.setIntegral_image_emb","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nμ : MeasureTheory.Measure X\nY : Type u_5\nx✝ : MeasurableSpace Y\nf : X → Y\nν : MeasureTheory.Measure Y\nh₁ : MeasureTheory.MeasurePreserving f μ ν\nh₂ : MeasurableEmbedding f\ng : Y → E\ns : Set X\n⊢ Eq (MeasureTheory.integral (ν.restrict (Set.image f s)) fun y => g y) (MeasureTheory.integral (μ.restrict s) fun x => g (f x))","decl":"theorem MeasurePreserving.setIntegral_image_emb {Y} {_ : MeasurableSpace Y} {f : X → Y} {ν}\n    (h₁ : MeasurePreserving f μ ν) (h₂ : MeasurableEmbedding f) (g : Y → E) (s : Set X) :\n    ∫ y in f '' s, g y ∂ν = ∫ x in s, g (f x) ∂μ :=\n  Eq.symm <| (h₁.restrict_image_emb h₂ s).integral_comp h₂ _\n\n"}
{"name":"MeasureTheory.setIntegral_map_equiv","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝³ : MeasurableSpace X\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nμ : MeasureTheory.Measure X\nY : Type u_5\ninst✝ : MeasurableSpace Y\ne : MeasurableEquiv X Y\nf : Y → E\ns : Set Y\n⊢ Eq (MeasureTheory.integral ((MeasureTheory.Measure.map (⇑e) μ).restrict s) fun y => f y) (MeasureTheory.integral (μ.restrict (Set.preimage (⇑e) s)) fun x => f (e x))","decl":"theorem setIntegral_map_equiv {Y} [MeasurableSpace Y] (e : X ≃ᵐ Y) (f : Y → E) (s : Set Y) :\n    ∫ y in s, f y ∂Measure.map e μ = ∫ x in e ⁻¹' s, f (e x) ∂μ :=\n  e.measurableEmbedding.setIntegral_map f s\n\n"}
{"name":"MeasureTheory.norm_setIntegral_le_of_norm_le_const_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns : Set X\nμ : MeasureTheory.Measure X\nC : Real\nhs : LT.lt (μ s) Top.top\nhC : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) C) (MeasureTheory.ae (μ.restrict s))\n⊢ LE.le (Norm.norm (MeasureTheory.integral (μ.restrict s) fun x => f x)) (HMul.hMul C (μ s).toReal)","decl":"theorem norm_setIntegral_le_of_norm_le_const_ae {C : ℝ} (hs : μ s < ∞)\n    (hC : ∀ᵐ x ∂μ.restrict s, ‖f x‖ ≤ C) : ‖∫ x in s, f x ∂μ‖ ≤ C * (μ s).toReal := by\n  rw [← Measure.restrict_apply_univ] at *\n  haveI : IsFiniteMeasure (μ.restrict s) := ⟨hs⟩\n  exact norm_integral_le_of_norm_le_const hC\n\n"}
{"name":"MeasureTheory.norm_setIntegral_le_of_norm_le_const_ae'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns : Set X\nμ : MeasureTheory.Measure X\nC : Real\nhs : LT.lt (μ s) Top.top\nhC : Filter.Eventually (fun x => Membership.mem s x → LE.le (Norm.norm (f x)) C) (MeasureTheory.ae μ)\nhfm : MeasureTheory.AEStronglyMeasurable f (μ.restrict s)\n⊢ LE.le (Norm.norm (MeasureTheory.integral (μ.restrict s) fun x => f x)) (HMul.hMul C (μ s).toReal)","decl":"theorem norm_setIntegral_le_of_norm_le_const_ae' {C : ℝ} (hs : μ s < ∞)\n    (hC : ∀ᵐ x ∂μ, x ∈ s → ‖f x‖ ≤ C) (hfm : AEStronglyMeasurable f (μ.restrict s)) :\n    ‖∫ x in s, f x ∂μ‖ ≤ C * (μ s).toReal := by\n  apply norm_setIntegral_le_of_norm_le_const_ae hs\n  have A : ∀ᵐ x : X ∂μ, x ∈ s → ‖AEStronglyMeasurable.mk f hfm x‖ ≤ C := by\n    filter_upwards [hC, hfm.ae_mem_imp_eq_mk] with _ h1 h2 h3\n    rw [← h2 h3]\n    exact h1 h3\n  have B : MeasurableSet {x | ‖hfm.mk f x‖ ≤ C} :=\n    hfm.stronglyMeasurable_mk.norm.measurable measurableSet_Iic\n  filter_upwards [hfm.ae_eq_mk, (ae_restrict_iff B).2 A] with _ h1 _\n  rwa [h1]\n\n"}
{"name":"MeasureTheory.norm_setIntegral_le_of_norm_le_const_ae''","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns : Set X\nμ : MeasureTheory.Measure X\nC : Real\nhs : LT.lt (μ s) Top.top\nhsm : MeasurableSet s\nhC : Filter.Eventually (fun x => Membership.mem s x → LE.le (Norm.norm (f x)) C) (MeasureTheory.ae μ)\n⊢ LE.le (Norm.norm (MeasureTheory.integral (μ.restrict s) fun x => f x)) (HMul.hMul C (μ s).toReal)","decl":"theorem norm_setIntegral_le_of_norm_le_const_ae'' {C : ℝ} (hs : μ s < ∞) (hsm : MeasurableSet s)\n    (hC : ∀ᵐ x ∂μ, x ∈ s → ‖f x‖ ≤ C) : ‖∫ x in s, f x ∂μ‖ ≤ C * (μ s).toReal :=\n  norm_setIntegral_le_of_norm_le_const_ae hs <| by\n    rwa [ae_restrict_eq hsm, eventually_inf_principal]\n\n"}
{"name":"MeasureTheory.norm_setIntegral_le_of_norm_le_const","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns : Set X\nμ : MeasureTheory.Measure X\nC : Real\nhs : LT.lt (μ s) Top.top\nhC : ∀ (x : X), Membership.mem s x → LE.le (Norm.norm (f x)) C\nhfm : MeasureTheory.AEStronglyMeasurable f (μ.restrict s)\n⊢ LE.le (Norm.norm (MeasureTheory.integral (μ.restrict s) fun x => f x)) (HMul.hMul C (μ s).toReal)","decl":"theorem norm_setIntegral_le_of_norm_le_const {C : ℝ} (hs : μ s < ∞) (hC : ∀ x ∈ s, ‖f x‖ ≤ C)\n    (hfm : AEStronglyMeasurable f (μ.restrict s)) : ‖∫ x in s, f x ∂μ‖ ≤ C * (μ s).toReal :=\n  norm_setIntegral_le_of_norm_le_const_ae' hs (Eventually.of_forall hC) hfm\n\n"}
{"name":"MeasureTheory.norm_setIntegral_le_of_norm_le_const'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → E\ns : Set X\nμ : MeasureTheory.Measure X\nC : Real\nhs : LT.lt (μ s) Top.top\nhsm : MeasurableSet s\nhC : ∀ (x : X), Membership.mem s x → LE.le (Norm.norm (f x)) C\n⊢ LE.le (Norm.norm (MeasureTheory.integral (μ.restrict s) fun x => f x)) (HMul.hMul C (μ s).toReal)","decl":"theorem norm_setIntegral_le_of_norm_le_const' {C : ℝ} (hs : μ s < ∞) (hsm : MeasurableSet s)\n    (hC : ∀ x ∈ s, ‖f x‖ ≤ C) : ‖∫ x in s, f x ∂μ‖ ≤ C * (μ s).toReal :=\n  norm_setIntegral_le_of_norm_le_const_ae'' hs hsm <| Eventually.of_forall hC\n\n"}
{"name":"MeasureTheory.setIntegral_eq_zero_iff_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\ns : Set X\nμ : MeasureTheory.Measure X\nf : X → Real\nhf : (MeasureTheory.ae (μ.restrict s)).EventuallyLE 0 f\nhfi : MeasureTheory.IntegrableOn f s μ\n⊢ Iff (Eq (MeasureTheory.integral (μ.restrict s) fun x => f x) 0) ((MeasureTheory.ae (μ.restrict s)).EventuallyEq f 0)","decl":"theorem setIntegral_eq_zero_iff_of_nonneg_ae {f : X → ℝ} (hf : 0 ≤ᵐ[μ.restrict s] f)\n    (hfi : IntegrableOn f s μ) : ∫ x in s, f x ∂μ = 0 ↔ f =ᵐ[μ.restrict s] 0 :=\n  integral_eq_zero_iff_of_nonneg_ae hf hfi\n\n"}
{"name":"MeasureTheory.setIntegral_pos_iff_support_of_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\ns : Set X\nμ : MeasureTheory.Measure X\nf : X → Real\nhf : (MeasureTheory.ae (μ.restrict s)).EventuallyLE 0 f\nhfi : MeasureTheory.IntegrableOn f s μ\n⊢ Iff (LT.lt 0 (MeasureTheory.integral (μ.restrict s) fun x => f x)) (LT.lt 0 (μ (Inter.inter (Function.support f) s)))","decl":"theorem setIntegral_pos_iff_support_of_nonneg_ae {f : X → ℝ} (hf : 0 ≤ᵐ[μ.restrict s] f)\n    (hfi : IntegrableOn f s μ) : (0 < ∫ x in s, f x ∂μ) ↔ 0 < μ (support f ∩ s) := by\n  rw [integral_pos_iff_support_of_nonneg_ae hf hfi, Measure.restrict_apply₀]\n  rw [support_eq_preimage]\n  exact hfi.aestronglyMeasurable.aemeasurable.nullMeasurable (measurableSet_singleton 0).compl\n\n"}
{"name":"MeasureTheory.setIntegral_gt_gt","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nR : Real\nf : X → Real\nhR : LE.le 0 R\nhfint : MeasureTheory.IntegrableOn f (setOf fun x => LT.lt R (f x)) μ\nhμ : Ne (μ (setOf fun x => LT.lt R (f x))) 0\n⊢ LT.lt (HMul.hMul (μ (setOf fun x => LT.lt R (f x))).toReal R) (MeasureTheory.integral (μ.restrict (setOf fun x => LT.lt R (f x))) fun x => f x)","decl":"theorem setIntegral_gt_gt {R : ℝ} {f : X → ℝ} (hR : 0 ≤ R)\n    (hfint : IntegrableOn f {x | ↑R < f x} μ) (hμ : μ {x | ↑R < f x} ≠ 0) :\n    (μ {x | ↑R < f x}).toReal * R < ∫ x in {x | ↑R < f x}, f x ∂μ := by\n  have : IntegrableOn (fun _ => R) {x | ↑R < f x} μ := by\n    refine ⟨aestronglyMeasurable_const, lt_of_le_of_lt ?_ hfint.2⟩\n    refine setLIntegral_mono_ae hfint.1.enorm <| ae_of_all _ fun x hx => ?_\n    simp only [ENNReal.coe_le_coe, Real.nnnorm_of_nonneg hR, enorm_eq_nnnorm,\n      Real.nnnorm_of_nonneg (hR.trans <| le_of_lt hx), Subtype.mk_le_mk]\n    exact le_of_lt hx\n  rw [← sub_pos, ← smul_eq_mul, ← setIntegral_const, ← integral_sub hfint this,\n    setIntegral_pos_iff_support_of_nonneg_ae]\n  · rw [← zero_lt_iff] at hμ\n    rwa [Set.inter_eq_self_of_subset_right]\n    exact fun x hx => Ne.symm (ne_of_lt <| sub_pos.2 hx)\n  · rw [Pi.zero_def, EventuallyLE, ae_restrict_iff₀]\n    · exact Eventually.of_forall fun x hx => sub_nonneg.2 <| le_of_lt hx\n    · exact nullMeasurableSet_le aemeasurable_zero (hfint.1.aemeasurable.sub aemeasurable_const)\n  · exact Integrable.sub hfint this\n\n"}
{"name":"MeasureTheory.setIntegral_trim","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"E : Type u_3\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nX : Type u_5\nm m0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nhm : LE.le m m0\nf : X → E\nhf_meas : MeasureTheory.StronglyMeasurable f\ns : Set X\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral ((μ.trim hm).restrict s) fun x => f x)","decl":"theorem setIntegral_trim {X} {m m0 : MeasurableSpace X} {μ : Measure X} (hm : m ≤ m0) {f : X → E}\n    (hf_meas : StronglyMeasurable[m] f) {s : Set X} (hs : MeasurableSet[m] s) :\n    ∫ x in s, f x ∂μ = ∫ x in s, f x ∂μ.trim hm := by\n  rwa [integral_trim hm hf_meas, restrict_trim hm μ]\n\n"}
{"name":"MeasureTheory.integral_Icc_eq_integral_Ioc'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝³ : MeasurableSpace X\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\ninst✝ : PartialOrder X\nx y : X\nhx : Eq (μ (Singleton.singleton x)) 0\n⊢ Eq (MeasureTheory.integral (μ.restrict (Set.Icc x y)) fun t => f t) (MeasureTheory.integral (μ.restrict (Set.Ioc x y)) fun t => f t)","decl":"theorem integral_Icc_eq_integral_Ioc' (hx : μ {x} = 0) :\n    ∫ t in Icc x y, f t ∂μ = ∫ t in Ioc x y, f t ∂μ :=\n  setIntegral_congr_set (Ioc_ae_eq_Icc' hx).symm\n\n"}
{"name":"MeasureTheory.integral_Icc_eq_integral_Ico'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝³ : MeasurableSpace X\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\ninst✝ : PartialOrder X\nx y : X\nhy : Eq (μ (Singleton.singleton y)) 0\n⊢ Eq (MeasureTheory.integral (μ.restrict (Set.Icc x y)) fun t => f t) (MeasureTheory.integral (μ.restrict (Set.Ico x y)) fun t => f t)","decl":"theorem integral_Icc_eq_integral_Ico' (hy : μ {y} = 0) :\n    ∫ t in Icc x y, f t ∂μ = ∫ t in Ico x y, f t ∂μ :=\n  setIntegral_congr_set (Ico_ae_eq_Icc' hy).symm\n\n"}
{"name":"MeasureTheory.integral_Ioc_eq_integral_Ioo'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝³ : MeasurableSpace X\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\ninst✝ : PartialOrder X\nx y : X\nhy : Eq (μ (Singleton.singleton y)) 0\n⊢ Eq (MeasureTheory.integral (μ.restrict (Set.Ioc x y)) fun t => f t) (MeasureTheory.integral (μ.restrict (Set.Ioo x y)) fun t => f t)","decl":"theorem integral_Ioc_eq_integral_Ioo' (hy : μ {y} = 0) :\n    ∫ t in Ioc x y, f t ∂μ = ∫ t in Ioo x y, f t ∂μ :=\n  setIntegral_congr_set (Ioo_ae_eq_Ioc' hy).symm\n\n"}
{"name":"MeasureTheory.integral_Ico_eq_integral_Ioo'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝³ : MeasurableSpace X\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\ninst✝ : PartialOrder X\nx y : X\nhx : Eq (μ (Singleton.singleton x)) 0\n⊢ Eq (MeasureTheory.integral (μ.restrict (Set.Ico x y)) fun t => f t) (MeasureTheory.integral (μ.restrict (Set.Ioo x y)) fun t => f t)","decl":"theorem integral_Ico_eq_integral_Ioo' (hx : μ {x} = 0) :\n    ∫ t in Ico x y, f t ∂μ = ∫ t in Ioo x y, f t ∂μ :=\n  setIntegral_congr_set (Ioo_ae_eq_Ico' hx).symm\n\n"}
{"name":"MeasureTheory.integral_Icc_eq_integral_Ioo'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝³ : MeasurableSpace X\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\ninst✝ : PartialOrder X\nx y : X\nhx : Eq (μ (Singleton.singleton x)) 0\nhy : Eq (μ (Singleton.singleton y)) 0\n⊢ Eq (MeasureTheory.integral (μ.restrict (Set.Icc x y)) fun t => f t) (MeasureTheory.integral (μ.restrict (Set.Ioo x y)) fun t => f t)","decl":"theorem integral_Icc_eq_integral_Ioo' (hx : μ {x} = 0) (hy : μ {y} = 0) :\n    ∫ t in Icc x y, f t ∂μ = ∫ t in Ioo x y, f t ∂μ :=\n  setIntegral_congr_set (Ioo_ae_eq_Icc' hx hy).symm\n\n"}
{"name":"MeasureTheory.integral_Iic_eq_integral_Iio'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝³ : MeasurableSpace X\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\ninst✝ : PartialOrder X\nx : X\nhx : Eq (μ (Singleton.singleton x)) 0\n⊢ Eq (MeasureTheory.integral (μ.restrict (Set.Iic x)) fun t => f t) (MeasureTheory.integral (μ.restrict (Set.Iio x)) fun t => f t)","decl":"theorem integral_Iic_eq_integral_Iio' (hx : μ {x} = 0) :\n    ∫ t in Iic x, f t ∂μ = ∫ t in Iio x, f t ∂μ :=\n  setIntegral_congr_set (Iio_ae_eq_Iic' hx).symm\n\n"}
{"name":"MeasureTheory.integral_Ici_eq_integral_Ioi'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝³ : MeasurableSpace X\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\ninst✝ : PartialOrder X\nx : X\nhx : Eq (μ (Singleton.singleton x)) 0\n⊢ Eq (MeasureTheory.integral (μ.restrict (Set.Ici x)) fun t => f t) (MeasureTheory.integral (μ.restrict (Set.Ioi x)) fun t => f t)","decl":"theorem integral_Ici_eq_integral_Ioi' (hx : μ {x} = 0) :\n    ∫ t in Ici x, f t ∂μ = ∫ t in Ioi x, f t ∂μ :=\n  setIntegral_congr_set (Ioi_ae_eq_Ici' hx).symm\n\n"}
{"name":"MeasureTheory.integral_Icc_eq_integral_Ioc","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝⁴ : MeasurableSpace X\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\ninst✝¹ : PartialOrder X\nx y : X\ninst✝ : MeasureTheory.NoAtoms μ\n⊢ Eq (MeasureTheory.integral (μ.restrict (Set.Icc x y)) fun t => f t) (MeasureTheory.integral (μ.restrict (Set.Ioc x y)) fun t => f t)","decl":"theorem integral_Icc_eq_integral_Ioc : ∫ t in Icc x y, f t ∂μ = ∫ t in Ioc x y, f t ∂μ :=\n  integral_Icc_eq_integral_Ioc' <| measure_singleton x\n\n"}
{"name":"MeasureTheory.integral_Icc_eq_integral_Ico","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝⁴ : MeasurableSpace X\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\ninst✝¹ : PartialOrder X\nx y : X\ninst✝ : MeasureTheory.NoAtoms μ\n⊢ Eq (MeasureTheory.integral (μ.restrict (Set.Icc x y)) fun t => f t) (MeasureTheory.integral (μ.restrict (Set.Ico x y)) fun t => f t)","decl":"theorem integral_Icc_eq_integral_Ico : ∫ t in Icc x y, f t ∂μ = ∫ t in Ico x y, f t ∂μ :=\n  integral_Icc_eq_integral_Ico' <| measure_singleton y\n\n"}
{"name":"MeasureTheory.integral_Ioc_eq_integral_Ioo","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝⁴ : MeasurableSpace X\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\ninst✝¹ : PartialOrder X\nx y : X\ninst✝ : MeasureTheory.NoAtoms μ\n⊢ Eq (MeasureTheory.integral (μ.restrict (Set.Ioc x y)) fun t => f t) (MeasureTheory.integral (μ.restrict (Set.Ioo x y)) fun t => f t)","decl":"theorem integral_Ioc_eq_integral_Ioo : ∫ t in Ioc x y, f t ∂μ = ∫ t in Ioo x y, f t ∂μ :=\n  integral_Ioc_eq_integral_Ioo' <| measure_singleton y\n\n"}
{"name":"MeasureTheory.integral_Ico_eq_integral_Ioo","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝⁴ : MeasurableSpace X\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\ninst✝¹ : PartialOrder X\nx y : X\ninst✝ : MeasureTheory.NoAtoms μ\n⊢ Eq (MeasureTheory.integral (μ.restrict (Set.Ico x y)) fun t => f t) (MeasureTheory.integral (μ.restrict (Set.Ioo x y)) fun t => f t)","decl":"theorem integral_Ico_eq_integral_Ioo : ∫ t in Ico x y, f t ∂μ = ∫ t in Ioo x y, f t ∂μ :=\n  integral_Ico_eq_integral_Ioo' <| measure_singleton x\n\n"}
{"name":"MeasureTheory.integral_Icc_eq_integral_Ioo","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝⁴ : MeasurableSpace X\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\ninst✝¹ : PartialOrder X\nx y : X\ninst✝ : MeasureTheory.NoAtoms μ\n⊢ Eq (MeasureTheory.integral (μ.restrict (Set.Icc x y)) fun t => f t) (MeasureTheory.integral (μ.restrict (Set.Ioo x y)) fun t => f t)","decl":"theorem integral_Icc_eq_integral_Ioo : ∫ t in Icc x y, f t ∂μ = ∫ t in Ioo x y, f t ∂μ := by\n  rw [integral_Icc_eq_integral_Ico, integral_Ico_eq_integral_Ioo]\n\n"}
{"name":"MeasureTheory.integral_Iic_eq_integral_Iio","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝⁴ : MeasurableSpace X\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\ninst✝¹ : PartialOrder X\nx : X\ninst✝ : MeasureTheory.NoAtoms μ\n⊢ Eq (MeasureTheory.integral (μ.restrict (Set.Iic x)) fun t => f t) (MeasureTheory.integral (μ.restrict (Set.Iio x)) fun t => f t)","decl":"theorem integral_Iic_eq_integral_Iio : ∫ t in Iic x, f t ∂μ = ∫ t in Iio x, f t ∂μ :=\n  integral_Iic_eq_integral_Iio' <| measure_singleton x\n\n"}
{"name":"MeasureTheory.integral_Ici_eq_integral_Ioi","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝⁴ : MeasurableSpace X\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\nf : X → E\nμ : MeasureTheory.Measure X\ninst✝¹ : PartialOrder X\nx : X\ninst✝ : MeasureTheory.NoAtoms μ\n⊢ Eq (MeasureTheory.integral (μ.restrict (Set.Ici x)) fun t => f t) (MeasureTheory.integral (μ.restrict (Set.Ioi x)) fun t => f t)","decl":"theorem integral_Ici_eq_integral_Ioi : ∫ t in Ici x, f t ∂μ = ∫ t in Ioi x, f t ∂μ :=\n  integral_Ici_eq_integral_Ioi' <| measure_singleton x\n\n"}
{"name":"MeasureTheory.setIntegral_mono_ae_restrict","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf g : X → Real\ns : Set X\nhf : MeasureTheory.IntegrableOn f s μ\nhg : MeasureTheory.IntegrableOn g s μ\nh : (MeasureTheory.ae (μ.restrict s)).EventuallyLE f g\n⊢ LE.le (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict s) fun x => g x)","decl":"theorem setIntegral_mono_ae_restrict (h : f ≤ᵐ[μ.restrict s] g) :\n    ∫ x in s, f x ∂μ ≤ ∫ x in s, g x ∂μ :=\n  integral_mono_ae hf hg h\n\n"}
{"name":"MeasureTheory.setIntegral_mono_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf g : X → Real\ns : Set X\nhf : MeasureTheory.IntegrableOn f s μ\nhg : MeasureTheory.IntegrableOn g s μ\nh : (MeasureTheory.ae μ).EventuallyLE f g\n⊢ LE.le (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict s) fun x => g x)","decl":"theorem setIntegral_mono_ae (h : f ≤ᵐ[μ] g) : ∫ x in s, f x ∂μ ≤ ∫ x in s, g x ∂μ :=\n  setIntegral_mono_ae_restrict hf hg (ae_restrict_of_ae h)\n\n"}
{"name":"MeasureTheory.setIntegral_mono_on","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf g : X → Real\ns : Set X\nhf : MeasureTheory.IntegrableOn f s μ\nhg : MeasureTheory.IntegrableOn g s μ\nhs : MeasurableSet s\nh : ∀ (x : X), Membership.mem s x → LE.le (f x) (g x)\n⊢ LE.le (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict s) fun x => g x)","decl":"theorem setIntegral_mono_on (hs : MeasurableSet s) (h : ∀ x ∈ s, f x ≤ g x) :\n    ∫ x in s, f x ∂μ ≤ ∫ x in s, g x ∂μ :=\n  setIntegral_mono_ae_restrict hf hg\n    (by simp [hs, EventuallyLE, eventually_inf_principal, ae_of_all _ h])\n\n"}
{"name":"MeasureTheory.setIntegral_mono_on_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf g : X → Real\ns : Set X\nhf : MeasureTheory.IntegrableOn f s μ\nhg : MeasureTheory.IntegrableOn g s μ\nhs : MeasurableSet s\nh : Filter.Eventually (fun x => Membership.mem s x → LE.le (f x) (g x)) (MeasureTheory.ae μ)\n⊢ LE.le (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict s) fun x => g x)","decl":"theorem setIntegral_mono_on_ae (hs : MeasurableSet s) (h : ∀ᵐ x ∂μ, x ∈ s → f x ≤ g x) :\n    ∫ x in s, f x ∂μ ≤ ∫ x in s, g x ∂μ := by\n  refine setIntegral_mono_ae_restrict hf hg ?_; rwa [EventuallyLE, ae_restrict_iff' hs]\n\n"}
{"name":"MeasureTheory.setIntegral_mono","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf g : X → Real\ns : Set X\nhf : MeasureTheory.IntegrableOn f s μ\nhg : MeasureTheory.IntegrableOn g s μ\nh : LE.le f g\n⊢ LE.le (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict s) fun x => g x)","decl":"theorem setIntegral_mono (h : f ≤ g) : ∫ x in s, f x ∂μ ≤ ∫ x in s, g x ∂μ :=\n  integral_mono hf hg h\n\n"}
{"name":"MeasureTheory.setIntegral_mono_set","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf : X → Real\ns t : Set X\nhfi : MeasureTheory.IntegrableOn f t μ\nhf : (MeasureTheory.ae (μ.restrict t)).EventuallyLE 0 f\nhst : (MeasureTheory.ae μ).EventuallyLE s t\n⊢ LE.le (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict t) fun x => f x)","decl":"theorem setIntegral_mono_set (hfi : IntegrableOn f t μ) (hf : 0 ≤ᵐ[μ.restrict t] f)\n    (hst : s ≤ᵐ[μ] t) : ∫ x in s, f x ∂μ ≤ ∫ x in t, f x ∂μ :=\n  integral_mono_measure (Measure.restrict_mono_ae hst) hf hfi\n\n"}
{"name":"MeasureTheory.setIntegral_le_integral","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf : X → Real\ns : Set X\nhfi : MeasureTheory.Integrable f μ\nhf : (MeasureTheory.ae μ).EventuallyLE 0 f\n⊢ LE.le (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral μ fun x => f x)","decl":"theorem setIntegral_le_integral (hfi : Integrable f μ) (hf : 0 ≤ᵐ[μ] f) :\n    ∫ x in s, f x ∂μ ≤ ∫ x, f x ∂μ :=\n  integral_mono_measure (Measure.restrict_le_self) hf hfi\n\n"}
{"name":"MeasureTheory.setIntegral_ge_of_const_le","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf : X → Real\ns : Set X\nc : Real\nhs : MeasurableSet s\nhμs : Ne (μ s) Top.top\nhf : ∀ (x : X), Membership.mem s x → LE.le c (f x)\nhfint : MeasureTheory.IntegrableOn (fun x => f x) s μ\n⊢ LE.le (HMul.hMul c (μ s).toReal) (MeasureTheory.integral (μ.restrict s) fun x => f x)","decl":"theorem setIntegral_ge_of_const_le {c : ℝ} (hs : MeasurableSet s) (hμs : μ s ≠ ∞)\n    (hf : ∀ x ∈ s, c ≤ f x) (hfint : IntegrableOn (fun x : X => f x) s μ) :\n    c * (μ s).toReal ≤ ∫ x in s, f x ∂μ := by\n  rw [mul_comm, ← smul_eq_mul, ← setIntegral_const c]\n  exact setIntegral_mono_on (integrableOn_const.2 (Or.inr hμs.lt_top)) hfint hs hf\n\n"}
{"name":"MeasureTheory.setIntegral_nonneg_of_ae_restrict","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf : X → Real\ns : Set X\nhf : (MeasureTheory.ae (μ.restrict s)).EventuallyLE 0 f\n⊢ LE.le 0 (MeasureTheory.integral (μ.restrict s) fun x => f x)","decl":"theorem setIntegral_nonneg_of_ae_restrict (hf : 0 ≤ᵐ[μ.restrict s] f) : 0 ≤ ∫ x in s, f x ∂μ :=\n  integral_nonneg_of_ae hf\n\n"}
{"name":"MeasureTheory.setIntegral_nonneg_of_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf : X → Real\ns : Set X\nhf : (MeasureTheory.ae μ).EventuallyLE 0 f\n⊢ LE.le 0 (MeasureTheory.integral (μ.restrict s) fun x => f x)","decl":"theorem setIntegral_nonneg_of_ae (hf : 0 ≤ᵐ[μ] f) : 0 ≤ ∫ x in s, f x ∂μ :=\n  setIntegral_nonneg_of_ae_restrict (ae_restrict_of_ae hf)\n\n"}
{"name":"MeasureTheory.setIntegral_nonneg","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf : X → Real\ns : Set X\nhs : MeasurableSet s\nhf : ∀ (x : X), Membership.mem s x → LE.le 0 (f x)\n⊢ LE.le 0 (MeasureTheory.integral (μ.restrict s) fun x => f x)","decl":"theorem setIntegral_nonneg (hs : MeasurableSet s) (hf : ∀ x, x ∈ s → 0 ≤ f x) :\n    0 ≤ ∫ x in s, f x ∂μ :=\n  setIntegral_nonneg_of_ae_restrict ((ae_restrict_iff' hs).mpr (ae_of_all μ hf))\n\n"}
{"name":"MeasureTheory.setIntegral_nonneg_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf : X → Real\ns : Set X\nhs : MeasurableSet s\nhf : Filter.Eventually (fun x => Membership.mem s x → LE.le 0 (f x)) (MeasureTheory.ae μ)\n⊢ LE.le 0 (MeasureTheory.integral (μ.restrict s) fun x => f x)","decl":"theorem setIntegral_nonneg_ae (hs : MeasurableSet s) (hf : ∀ᵐ x ∂μ, x ∈ s → 0 ≤ f x) :\n    0 ≤ ∫ x in s, f x ∂μ :=\n  setIntegral_nonneg_of_ae_restrict <| by rwa [EventuallyLE, ae_restrict_iff' hs]\n\n"}
{"name":"MeasureTheory.setIntegral_le_nonneg","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf : X → Real\ns : Set X\nhs : MeasurableSet s\nhf : MeasureTheory.StronglyMeasurable f\nhfi : MeasureTheory.Integrable f μ\n⊢ LE.le (MeasureTheory.integral (μ.restrict s) fun x => f x) (MeasureTheory.integral (μ.restrict (setOf fun y => LE.le 0 (f y))) fun x => f x)","decl":"theorem setIntegral_le_nonneg {s : Set X} (hs : MeasurableSet s) (hf : StronglyMeasurable f)\n    (hfi : Integrable f μ) : ∫ x in s, f x ∂μ ≤ ∫ x in {y | 0 ≤ f y}, f x ∂μ := by\n  rw [← integral_indicator hs, ←\n    integral_indicator (stronglyMeasurable_const.measurableSet_le hf)]\n  exact\n    integral_mono (hfi.indicator hs)\n      (hfi.indicator (stronglyMeasurable_const.measurableSet_le hf))\n      (indicator_le_indicator_nonneg s f)\n\n"}
{"name":"MeasureTheory.setIntegral_nonpos_of_ae_restrict","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf : X → Real\ns : Set X\nhf : (MeasureTheory.ae (μ.restrict s)).EventuallyLE f 0\n⊢ LE.le (MeasureTheory.integral (μ.restrict s) fun x => f x) 0","decl":"theorem setIntegral_nonpos_of_ae_restrict (hf : f ≤ᵐ[μ.restrict s] 0) : ∫ x in s, f x ∂μ ≤ 0 :=\n  integral_nonpos_of_ae hf\n\n"}
{"name":"MeasureTheory.setIntegral_nonpos_of_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf : X → Real\ns : Set X\nhf : (MeasureTheory.ae μ).EventuallyLE f 0\n⊢ LE.le (MeasureTheory.integral (μ.restrict s) fun x => f x) 0","decl":"theorem setIntegral_nonpos_of_ae (hf : f ≤ᵐ[μ] 0) : ∫ x in s, f x ∂μ ≤ 0 :=\n  setIntegral_nonpos_of_ae_restrict (ae_restrict_of_ae hf)\n\n"}
{"name":"MeasureTheory.setIntegral_nonpos_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf : X → Real\ns : Set X\nhs : MeasurableSet s\nhf : Filter.Eventually (fun x => Membership.mem s x → LE.le (f x) 0) (MeasureTheory.ae μ)\n⊢ LE.le (MeasureTheory.integral (μ.restrict s) fun x => f x) 0","decl":"theorem setIntegral_nonpos_ae (hs : MeasurableSet s) (hf : ∀ᵐ x ∂μ, x ∈ s → f x ≤ 0) :\n    ∫ x in s, f x ∂μ ≤ 0 :=\n  setIntegral_nonpos_of_ae_restrict <| by rwa [EventuallyLE, ae_restrict_iff' hs]\n\n"}
{"name":"MeasureTheory.setIntegral_nonpos","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf : X → Real\ns : Set X\nhs : MeasurableSet s\nhf : ∀ (x : X), Membership.mem s x → LE.le (f x) 0\n⊢ LE.le (MeasureTheory.integral (μ.restrict s) fun x => f x) 0","decl":"theorem setIntegral_nonpos (hs : MeasurableSet s) (hf : ∀ x, x ∈ s → f x ≤ 0) :\n    ∫ x in s, f x ∂μ ≤ 0 :=\n  setIntegral_nonpos_ae hs <| ae_of_all μ hf\n\n"}
{"name":"MeasureTheory.setIntegral_nonpos_le","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf : X → Real\ns : Set X\nhs : MeasurableSet s\nhf : MeasureTheory.StronglyMeasurable f\nhfi : MeasureTheory.Integrable f μ\n⊢ LE.le (MeasureTheory.integral (μ.restrict (setOf fun y => LE.le (f y) 0)) fun x => f x) (MeasureTheory.integral (μ.restrict s) fun x => f x)","decl":"theorem setIntegral_nonpos_le {s : Set X} (hs : MeasurableSet s) (hf : StronglyMeasurable f)\n    (hfi : Integrable f μ) : ∫ x in {y | f y ≤ 0}, f x ∂μ ≤ ∫ x in s, f x ∂μ := by\n  rw [← integral_indicator hs, ←\n    integral_indicator (hf.measurableSet_le stronglyMeasurable_const)]\n  exact\n    integral_mono (hfi.indicator (hf.measurableSet_le stronglyMeasurable_const))\n      (hfi.indicator hs) (indicator_nonpos_le_indicator s f)\n\n"}
{"name":"MeasureTheory.Integrable.measure_le_integral","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf : X → Real\nf_int : MeasureTheory.Integrable f μ\nf_nonneg : (MeasureTheory.ae μ).EventuallyLE 0 f\ns : Set X\nhs : ∀ (x : X), Membership.mem s x → LE.le 1 (f x)\n⊢ LE.le (μ s) (ENNReal.ofReal (MeasureTheory.integral μ fun x => f x))","decl":"lemma Integrable.measure_le_integral {f : X → ℝ} (f_int : Integrable f μ) (f_nonneg : 0 ≤ᵐ[μ] f)\n    {s : Set X} (hs : ∀ x ∈ s, 1 ≤ f x) :\n    μ s ≤ ENNReal.ofReal (∫ x, f x ∂μ) := by\n  rw [ofReal_integral_eq_lintegral_ofReal f_int f_nonneg]\n  apply meas_le_lintegral₀\n  · exact ENNReal.continuous_ofReal.measurable.comp_aemeasurable f_int.1.aemeasurable\n  · intro x hx\n    simpa using ENNReal.ofReal_le_ofReal (hs x hx)\n\n"}
{"name":"MeasureTheory.integral_le_measure","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf : X → Real\ns : Set X\nhs : ∀ (x : X), Membership.mem s x → LE.le (f x) 1\nh's : ∀ (x : X), Membership.mem (HasCompl.compl s) x → LE.le (f x) 0\n⊢ LE.le (ENNReal.ofReal (MeasureTheory.integral μ fun x => f x)) (μ s)","decl":"lemma integral_le_measure {f : X → ℝ} {s : Set X}\n    (hs : ∀ x ∈ s, f x ≤ 1) (h's : ∀ x ∈ sᶜ, f x ≤ 0) :\n    ENNReal.ofReal (∫ x, f x ∂μ) ≤ μ s := by\n  by_cases H : Integrable f μ; swap\n  · simp [integral_undef H]\n  let g x := max (f x) 0\n  have g_int : Integrable g μ := H.pos_part\n  have : ENNReal.ofReal (∫ x, f x ∂μ) ≤ ENNReal.ofReal (∫ x, g x ∂μ) := by\n    apply ENNReal.ofReal_le_ofReal\n    exact integral_mono H g_int (fun x ↦ le_max_left _ _)\n  apply this.trans\n  rw [ofReal_integral_eq_lintegral_ofReal g_int (Eventually.of_forall (fun x ↦ le_max_right _ _))]\n  apply lintegral_le_meas\n  · intro x\n    apply ENNReal.ofReal_le_of_le_toReal\n    by_cases H : x ∈ s\n    · simpa [g] using hs x H\n    · apply le_trans _ zero_le_one\n      simpa [g] using h's x H\n  · intro x hx\n    simpa [g] using h's x hx\n\n"}
{"name":"MeasureTheory.integrableOn_iUnion_of_summable_integral_norm","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\nι : Type u_5\ninst✝¹ : Countable ι\nμ : MeasureTheory.Measure X\ninst✝ : NormedAddCommGroup E\nf : X → E\ns : ι → Set X\nhs : ∀ (i : ι), MeasurableSet (s i)\nhi : ∀ (i : ι), MeasureTheory.IntegrableOn f (s i) μ\nh : Summable fun i => MeasureTheory.integral (μ.restrict (s i)) fun x => Norm.norm (f x)\n⊢ MeasureTheory.IntegrableOn f (Set.iUnion s) μ","decl":"theorem integrableOn_iUnion_of_summable_integral_norm {f : X → E} {s : ι → Set X}\n    (hs : ∀ i : ι, MeasurableSet (s i)) (hi : ∀ i : ι, IntegrableOn f (s i) μ)\n    (h : Summable fun i : ι => ∫ x : X in s i, ‖f x‖ ∂μ) : IntegrableOn f (iUnion s) μ := by\n  refine ⟨AEStronglyMeasurable.iUnion fun i => (hi i).1, (lintegral_iUnion_le _ _).trans_lt ?_⟩\n  have B := fun i => lintegral_coe_eq_integral (fun x : X => ‖f x‖₊) (hi i).norm\n  simp_rw [enorm_eq_nnnorm, tsum_congr B]\n  have S' :\n    Summable fun i : ι =>\n      (⟨∫ x : X in s i, ‖f x‖₊ ∂μ, setIntegral_nonneg (hs i) fun x _ => NNReal.coe_nonneg _⟩ :\n        NNReal) := by\n    rw [← NNReal.summable_coe]; exact h\n  have S'' := ENNReal.tsum_coe_eq S'.hasSum\n  simp_rw [ENNReal.coe_nnreal_eq, NNReal.coe_mk, coe_nnnorm] at S''\n  convert ENNReal.ofReal_lt_top\n\n"}
{"name":"MeasureTheory.integrableOn_iUnion_of_summable_norm_restrict","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝⁶ : MeasurableSpace X\nι : Type u_5\ninst✝⁵ : Countable ι\nμ : MeasureTheory.Measure X\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : TopologicalSpace X\ninst✝² : BorelSpace X\ninst✝¹ : TopologicalSpace.MetrizableSpace X\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nf : ContinuousMap X E\ns : ι → TopologicalSpace.Compacts X\nhf : Summable fun i => HMul.hMul (Norm.norm (ContinuousMap.restrict (↑(s i)) f)) (μ ↑(s i)).toReal\n⊢ MeasureTheory.IntegrableOn (⇑f) (Set.iUnion fun i => ↑(s i)) μ","decl":"/-- If `s` is a countable family of compact sets, `f` is a continuous function, and the sequence\n`‖f.restrict (s i)‖ * μ (s i)` is summable, then `f` is integrable on the union of the `s i`. -/\ntheorem integrableOn_iUnion_of_summable_norm_restrict {f : C(X, E)} {s : ι → Compacts X}\n    (hf : Summable fun i : ι => ‖f.restrict (s i)‖ * ENNReal.toReal (μ <| s i)) :\n    IntegrableOn f (⋃ i : ι, s i) μ := by\n  refine\n    integrableOn_iUnion_of_summable_integral_norm (fun i => (s i).isCompact.isClosed.measurableSet)\n      (fun i => (map_continuous f).continuousOn.integrableOn_compact (s i).isCompact)\n      (.of_nonneg_of_le (fun ι => integral_nonneg fun x => norm_nonneg _) (fun i => ?_) hf)\n  rw [← (Real.norm_of_nonneg (integral_nonneg fun x => norm_nonneg _) : ‖_‖ = ∫ x in s i, ‖f x‖ ∂μ)]\n  exact\n    norm_setIntegral_le_of_norm_le_const' (s i).isCompact.measure_lt_top\n      (s i).isCompact.isClosed.measurableSet fun x hx =>\n      (norm_norm (f x)).symm ▸ (f.restrict (s i : Set X)).norm_coe_le_norm ⟨x, hx⟩\n\n"}
{"name":"MeasureTheory.integrable_of_summable_norm_restrict","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝⁶ : MeasurableSpace X\nι : Type u_5\ninst✝⁵ : Countable ι\nμ : MeasureTheory.Measure X\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : TopologicalSpace X\ninst✝² : BorelSpace X\ninst✝¹ : TopologicalSpace.MetrizableSpace X\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nf : ContinuousMap X E\ns : ι → TopologicalSpace.Compacts X\nhf : Summable fun i => HMul.hMul (Norm.norm (ContinuousMap.restrict (↑(s i)) f)) (μ ↑(s i)).toReal\nhs : Eq (Set.iUnion fun i => ↑(s i)) Set.univ\n⊢ MeasureTheory.Integrable (⇑f) μ","decl":"/-- If `s` is a countable family of compact sets covering `X`, `f` is a continuous function, and\nthe sequence `‖f.restrict (s i)‖ * μ (s i)` is summable, then `f` is integrable. -/\ntheorem integrable_of_summable_norm_restrict {f : C(X, E)} {s : ι → Compacts X}\n    (hf : Summable fun i : ι => ‖f.restrict (s i)‖ * ENNReal.toReal (μ <| s i))\n    (hs : ⋃ i : ι, ↑(s i) = (univ : Set X)) : Integrable f μ := by\n  simpa only [hs, integrableOn_univ] using integrableOn_iUnion_of_summable_norm_restrict hf\n\n"}
{"name":"MeasureTheory.Lp_toLp_restrict_add","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝¹ : MeasurableSpace X\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure X\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\ns : Set X\n⊢ Eq (MeasureTheory.Memℒp.toLp ↑↑(HAdd.hAdd f g) ⋯) (HAdd.hAdd (MeasureTheory.Memℒp.toLp ↑↑f ⋯) (MeasureTheory.Memℒp.toLp ↑↑g ⋯))","decl":"/-- For `f : Lp E p μ`, we can define an element of `Lp E p (μ.restrict s)` by\n`(Lp.memℒp f).restrict s).toLp f`. This map is additive. -/\ntheorem Lp_toLp_restrict_add (f g : Lp E p μ) (s : Set X) :\n    ((Lp.memℒp (f + g)).restrict s).toLp (⇑(f + g)) =\n      ((Lp.memℒp f).restrict s).toLp f + ((Lp.memℒp g).restrict s).toLp g := by\n  ext1\n  refine (ae_restrict_of_ae (Lp.coeFn_add f g)).mp ?_\n  refine\n    (Lp.coeFn_add (Memℒp.toLp f ((Lp.memℒp f).restrict s))\n          (Memℒp.toLp g ((Lp.memℒp g).restrict s))).mp ?_\n  refine (Memℒp.coeFn_toLp ((Lp.memℒp f).restrict s)).mp ?_\n  refine (Memℒp.coeFn_toLp ((Lp.memℒp g).restrict s)).mp ?_\n  refine (Memℒp.coeFn_toLp ((Lp.memℒp (f + g)).restrict s)).mono fun x hx1 hx2 hx3 hx4 hx5 => ?_\n  rw [hx4, hx1, Pi.add_apply, hx2, hx3, hx5, Pi.add_apply]\n\n"}
{"name":"MeasureTheory.Lp_toLp_restrict_smul","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nF : Type u_4\ninst✝³ : MeasurableSpace X\n𝕜 : Type u_5\ninst✝² : NormedField 𝕜\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\np : ENNReal\nμ : MeasureTheory.Measure X\nc : 𝕜\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp F p μ) x\ns : Set X\n⊢ Eq (MeasureTheory.Memℒp.toLp ↑↑(HSMul.hSMul c f) ⋯) (HSMul.hSMul c (MeasureTheory.Memℒp.toLp ↑↑f ⋯))","decl":"/-- For `f : Lp E p μ`, we can define an element of `Lp E p (μ.restrict s)` by\n`(Lp.memℒp f).restrict s).toLp f`. This map commutes with scalar multiplication. -/\ntheorem Lp_toLp_restrict_smul (c : 𝕜) (f : Lp F p μ) (s : Set X) :\n    ((Lp.memℒp (c • f)).restrict s).toLp (⇑(c • f)) = c • ((Lp.memℒp f).restrict s).toLp f := by\n  ext1\n  refine (ae_restrict_of_ae (Lp.coeFn_smul c f)).mp ?_\n  refine (Memℒp.coeFn_toLp ((Lp.memℒp f).restrict s)).mp ?_\n  refine (Memℒp.coeFn_toLp ((Lp.memℒp (c • f)).restrict s)).mp ?_\n  refine\n    (Lp.coeFn_smul c (Memℒp.toLp f ((Lp.memℒp f).restrict s))).mono fun x hx1 hx2 hx3 hx4 => ?_\n  simp only [hx2, hx1, hx3, hx4, Pi.smul_apply]\n\n"}
{"name":"MeasureTheory.norm_Lp_toLp_restrict_le","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝¹ : MeasurableSpace X\ninst✝ : NormedAddCommGroup E\np : ENNReal\nμ : MeasureTheory.Measure X\ns : Set X\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ LE.le (Norm.norm (MeasureTheory.Memℒp.toLp ↑↑f ⋯)) (Norm.norm f)","decl":"/-- For `f : Lp E p μ`, we can define an element of `Lp E p (μ.restrict s)` by\n`(Lp.memℒp f).restrict s).toLp f`. This map is non-expansive. -/\ntheorem norm_Lp_toLp_restrict_le (s : Set X) (f : Lp E p μ) :\n    ‖((Lp.memℒp f).restrict s).toLp f‖ ≤ ‖f‖ := by\n  rw [Lp.norm_def, Lp.norm_def, eLpNorm_congr_ae (Memℒp.coeFn_toLp _)]\n  refine ENNReal.toReal_mono (Lp.eLpNorm_ne_top _) ?_\n  exact eLpNorm_mono_measure _ Measure.restrict_le_self\n\n"}
{"name":"MeasureTheory.LpToLpRestrictCLM_coeFn","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nF : Type u_4\ninst✝⁴ : MeasurableSpace X\n𝕜 : Type u_5\ninst✝³ : NormedField 𝕜\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\np : ENNReal\nμ : MeasureTheory.Measure X\ninst✝ : Fact (LE.le 1 p)\ns : Set X\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp F p μ) x\n⊢ (MeasureTheory.ae (μ.restrict s)).EventuallyEq ↑↑((MeasureTheory.LpToLpRestrictCLM X F 𝕜 μ p s) f) ↑↑f","decl":"variable (𝕜) in\ntheorem LpToLpRestrictCLM_coeFn [Fact (1 ≤ p)] (s : Set X) (f : Lp F p μ) :\n    LpToLpRestrictCLM X F 𝕜 μ p s f =ᵐ[μ.restrict s] f :=\n  Memℒp.coeFn_toLp ((Lp.memℒp f).restrict s)\n\n"}
{"name":"MeasureTheory.continuous_setIntegral","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\ninst✝¹ : NormedAddCommGroup E\nμ : MeasureTheory.Measure X\ninst✝ : NormedSpace Real E\ns : Set X\n⊢ Continuous fun f => MeasureTheory.integral (μ.restrict s) fun x => ↑↑f x","decl":"@[continuity]\ntheorem continuous_setIntegral [NormedSpace ℝ E] (s : Set X) :\n    Continuous fun f : X →₁[μ] E => ∫ x in s, f x ∂μ := by\n  haveI : Fact ((1 : ℝ≥0∞) ≤ 1) := ⟨le_rfl⟩\n  have h_comp :\n    (fun f : X →₁[μ] E => ∫ x in s, f x ∂μ) =\n      integral (μ.restrict s) ∘ fun f => LpToLpRestrictCLM X E ℝ μ 1 s f := by\n    ext1 f\n    rw [Function.comp_apply, integral_congr_ae (LpToLpRestrictCLM_coeFn ℝ s f)]\n  rw [h_comp]\n  exact continuous_integral.comp (LpToLpRestrictCLM X E ℝ μ 1 s).continuous\n\n"}
{"name":"Continuous.integral_pos_of_hasCompactSupport_nonneg_nonzero","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝⁴ : MeasurableSpace X\ninst✝³ : TopologicalSpace X\ninst✝² : OpensMeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝¹ : μ.IsOpenPosMeasure\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ\nf : X → Real\nx : X\nf_cont : Continuous f\nf_comp : HasCompactSupport f\nf_nonneg : LE.le 0 f\nf_x : Ne (f x) 0\n⊢ LT.lt 0 (MeasureTheory.integral μ fun x => f x)","decl":"theorem Continuous.integral_pos_of_hasCompactSupport_nonneg_nonzero [IsFiniteMeasureOnCompacts μ]\n    {f : X → ℝ} {x : X} (f_cont : Continuous f) (f_comp : HasCompactSupport f) (f_nonneg : 0 ≤ f)\n    (f_x : f x ≠ 0) : 0 < ∫ x, f x ∂μ :=\n  integral_pos_of_integrable_nonneg_nonzero f_cont (f_cont.integrable_of_hasCompactSupport f_comp)\n    f_nonneg f_x\n\n"}
{"name":"MeasureTheory.setIntegral_support","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nM : Type u_5\ninst✝¹ : NormedAddCommGroup M\ninst✝ : NormedSpace Real M\nmX : MeasurableSpace X\nν : MeasureTheory.Measure X\nF : X → M\n⊢ Eq (MeasureTheory.integral (ν.restrict (Function.support F)) fun x => F x) (MeasureTheory.integral ν fun x => F x)","decl":"theorem MeasureTheory.setIntegral_support : ∫ x in support F, F x ∂ν = ∫ x, F x ∂ν := by\n  nth_rw 2 [← setIntegral_univ]\n  rw [setIntegral_eq_of_subset_of_forall_diff_eq_zero MeasurableSet.univ (subset_univ (support F))]\n  exact fun _ hx => nmem_support.mp <| not_mem_of_mem_diff hx\n\n"}
{"name":"MeasureTheory.setIntegral_tsupport","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nM : Type u_5\ninst✝² : NormedAddCommGroup M\ninst✝¹ : NormedSpace Real M\nmX : MeasurableSpace X\nν : MeasureTheory.Measure X\nF : X → M\ninst✝ : TopologicalSpace X\n⊢ Eq (MeasureTheory.integral (ν.restrict (tsupport F)) fun x => F x) (MeasureTheory.integral ν fun x => F x)","decl":"theorem MeasureTheory.setIntegral_tsupport [TopologicalSpace X] :\n    ∫ x in tsupport F, F x ∂ν = ∫ x, F x ∂ν := by\n  nth_rw 2 [← setIntegral_univ]\n  rw [setIntegral_eq_of_subset_of_forall_diff_eq_zero MeasurableSet.univ (subset_univ (tsupport F))]\n  exact fun _ hx => image_eq_zero_of_nmem_tsupport <| not_mem_of_mem_diff hx\n\n"}
{"name":"Filter.Tendsto.integral_sub_linear_isLittleO_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝⁴ : MeasurableSpace X\nι : Type u_5\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : CompleteSpace E\nμ : MeasureTheory.Measure X\nl : Filter X\ninst✝ : l.IsMeasurablyGenerated\nf : X → E\nb : E\nh : Filter.Tendsto f (Min.min l (MeasureTheory.ae μ)) (nhds b)\nhfm : StronglyMeasurableAtFilter f l μ\nhμ : μ.FiniteAtFilter l\ns : ι → Set X\nli : Filter ι\nhs : Filter.Tendsto s li l.smallSets\nm : optParam (ι → Real) fun i => (μ (s i)).toReal\nhsμ : autoParam (li.EventuallyEq (fun i => (μ (s i)).toReal) m) _auto✝\n⊢ Asymptotics.IsLittleO li (fun i => HSub.hSub (MeasureTheory.integral (μ.restrict (s i)) fun x => f x) (HSMul.hSMul (m i) b)) m","decl":"/-- Fundamental theorem of calculus for set integrals:\nif `μ` is a measure that is finite at a filter `l` and\n`f` is a measurable function that has a finite limit `b` at `l ⊓ ae μ`, then\n`∫ x in s i, f x ∂μ = μ (s i) • b + o(μ (s i))` at a filter `li` provided that\n`s i` tends to `l.smallSets` along `li`.\nSince `μ (s i)` is an `ℝ≥0∞` number, we use `(μ (s i)).toReal` in the actual statement.\n\nOften there is a good formula for `(μ (s i)).toReal`, so the formalization can take an optional\nargument `m` with this formula and a proof of `(fun i => (μ (s i)).toReal) =ᶠ[li] m`. Without these\narguments, `m i = (μ (s i)).toReal` is used in the output. -/\ntheorem Filter.Tendsto.integral_sub_linear_isLittleO_ae\n    {μ : Measure X} {l : Filter X} [l.IsMeasurablyGenerated] {f : X → E} {b : E}\n    (h : Tendsto f (l ⊓ ae μ) (𝓝 b)) (hfm : StronglyMeasurableAtFilter f l μ)\n    (hμ : μ.FiniteAtFilter l) {s : ι → Set X} {li : Filter ι} (hs : Tendsto s li l.smallSets)\n    (m : ι → ℝ := fun i => (μ (s i)).toReal)\n    (hsμ : (fun i => (μ (s i)).toReal) =ᶠ[li] m := by rfl) :\n    (fun i => (∫ x in s i, f x ∂μ) - m i • b) =o[li] m := by\n  suffices\n      (fun s => (∫ x in s, f x ∂μ) - (μ s).toReal • b) =o[l.smallSets] fun s => (μ s).toReal from\n    (this.comp_tendsto hs).congr'\n      (hsμ.mono fun a ha => by dsimp only [Function.comp_apply] at ha ⊢; rw [ha]) hsμ\n  refine isLittleO_iff.2 fun ε ε₀ => ?_\n  have : ∀ᶠ s in l.smallSets, ∀ᵐ x ∂μ, x ∈ s → f x ∈ closedBall b ε :=\n    eventually_smallSets_eventually.2 (h.eventually <| closedBall_mem_nhds _ ε₀)\n  filter_upwards [hμ.eventually, (hμ.integrableAtFilter_of_tendsto_ae hfm h).eventually,\n    hfm.eventually, this]\n  simp only [mem_closedBall, dist_eq_norm]\n  intro s hμs h_integrable hfm h_norm\n  rw [← setIntegral_const, ← integral_sub h_integrable (integrableOn_const.2 <| Or.inr hμs),\n    Real.norm_eq_abs, abs_of_nonneg ENNReal.toReal_nonneg]\n  exact norm_setIntegral_le_of_norm_le_const_ae' hμs h_norm (hfm.sub aestronglyMeasurable_const)\n\n"}
{"name":"ContinuousWithinAt.integral_sub_linear_isLittleO_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝⁶ : MeasurableSpace X\nι : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : CompleteSpace E\ninst✝² : TopologicalSpace X\ninst✝¹ : OpensMeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nx : X\nt : Set X\nf : X → E\nhx : ContinuousWithinAt f t x\nht : MeasurableSet t\nhfm : StronglyMeasurableAtFilter f (nhdsWithin x t) μ\ns : ι → Set X\nli : Filter ι\nhs : Filter.Tendsto s li (nhdsWithin x t).smallSets\nm : optParam (ι → Real) fun i => (μ (s i)).toReal\nhsμ : autoParam (li.EventuallyEq (fun i => (μ (s i)).toReal) m) _auto✝\n⊢ Asymptotics.IsLittleO li (fun i => HSub.hSub (MeasureTheory.integral (μ.restrict (s i)) fun x => f x) (HSMul.hSMul (m i) (f x))) m","decl":"/-- Fundamental theorem of calculus for set integrals, `nhdsWithin` version: if `μ` is a locally\nfinite measure and `f` is an almost everywhere measurable function that is continuous at a point `a`\nwithin a measurable set `t`, then `∫ x in s i, f x ∂μ = μ (s i) • f a + o(μ (s i))` at a filter `li`\nprovided that `s i` tends to `(𝓝[t] a).smallSets` along `li`.  Since `μ (s i)` is an `ℝ≥0∞`\nnumber, we use `(μ (s i)).toReal` in the actual statement.\n\nOften there is a good formula for `(μ (s i)).toReal`, so the formalization can take an optional\nargument `m` with this formula and a proof of `(fun i => (μ (s i)).toReal) =ᶠ[li] m`. Without these\narguments, `m i = (μ (s i)).toReal` is used in the output. -/\ntheorem ContinuousWithinAt.integral_sub_linear_isLittleO_ae [TopologicalSpace X]\n    [OpensMeasurableSpace X] {μ : Measure X}\n    [IsLocallyFiniteMeasure μ] {x : X} {t : Set X} {f : X → E} (hx : ContinuousWithinAt f t x)\n    (ht : MeasurableSet t) (hfm : StronglyMeasurableAtFilter f (𝓝[t] x) μ) {s : ι → Set X}\n    {li : Filter ι} (hs : Tendsto s li (𝓝[t] x).smallSets) (m : ι → ℝ := fun i => (μ (s i)).toReal)\n    (hsμ : (fun i => (μ (s i)).toReal) =ᶠ[li] m := by rfl) :\n    (fun i => (∫ x in s i, f x ∂μ) - m i • f x) =o[li] m :=\n  haveI : (𝓝[t] x).IsMeasurablyGenerated := ht.nhdsWithin_isMeasurablyGenerated _\n  (hx.mono_left inf_le_left).integral_sub_linear_isLittleO_ae hfm (μ.finiteAt_nhdsWithin x t) hs m\n    hsμ\n\n"}
{"name":"ContinuousAt.integral_sub_linear_isLittleO_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝⁶ : MeasurableSpace X\nι : Type u_5\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : CompleteSpace E\ninst✝² : TopologicalSpace X\ninst✝¹ : OpensMeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nx : X\nf : X → E\nhx : ContinuousAt f x\nhfm : StronglyMeasurableAtFilter f (nhds x) μ\ns : ι → Set X\nli : Filter ι\nhs : Filter.Tendsto s li (nhds x).smallSets\nm : optParam (ι → Real) fun i => (μ (s i)).toReal\nhsμ : autoParam (li.EventuallyEq (fun i => (μ (s i)).toReal) m) _auto✝\n⊢ Asymptotics.IsLittleO li (fun i => HSub.hSub (MeasureTheory.integral (μ.restrict (s i)) fun x => f x) (HSMul.hSMul (m i) (f x))) m","decl":"/-- Fundamental theorem of calculus for set integrals, `nhds` version: if `μ` is a locally finite\nmeasure and `f` is an almost everywhere measurable function that is continuous at a point `a`, then\n`∫ x in s i, f x ∂μ = μ (s i) • f a + o(μ (s i))` at `li` provided that `s` tends to\n`(𝓝 a).smallSets` along `li`. Since `μ (s i)` is an `ℝ≥0∞` number, we use `(μ (s i)).toReal` in\nthe actual statement.\n\nOften there is a good formula for `(μ (s i)).toReal`, so the formalization can take an optional\nargument `m` with this formula and a proof of `(fun i => (μ (s i)).toReal) =ᶠ[li] m`. Without these\narguments, `m i = (μ (s i)).toReal` is used in the output. -/\ntheorem ContinuousAt.integral_sub_linear_isLittleO_ae [TopologicalSpace X] [OpensMeasurableSpace X]\n    {μ : Measure X} [IsLocallyFiniteMeasure μ] {x : X}\n    {f : X → E} (hx : ContinuousAt f x) (hfm : StronglyMeasurableAtFilter f (𝓝 x) μ) {s : ι → Set X}\n    {li : Filter ι} (hs : Tendsto s li (𝓝 x).smallSets) (m : ι → ℝ := fun i => (μ (s i)).toReal)\n    (hsμ : (fun i => (μ (s i)).toReal) =ᶠ[li] m := by rfl) :\n    (fun i => (∫ x in s i, f x ∂μ) - m i • f x) =o[li] m :=\n  (hx.mono_left inf_le_left).integral_sub_linear_isLittleO_ae hfm (μ.finiteAt_nhds x) hs m hsμ\n\n"}
{"name":"ContinuousOn.integral_sub_linear_isLittleO_ae","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝⁷ : MeasurableSpace X\nι : Type u_5\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Real E\ninst✝⁴ : CompleteSpace E\ninst✝³ : TopologicalSpace X\ninst✝² : OpensMeasurableSpace X\ninst✝¹ : SecondCountableTopologyEither X E\nμ : MeasureTheory.Measure X\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nx : X\nt : Set X\nf : X → E\nhft : ContinuousOn f t\nhx : Membership.mem t x\nht : MeasurableSet t\ns : ι → Set X\nli : Filter ι\nhs : Filter.Tendsto s li (nhdsWithin x t).smallSets\nm : optParam (ι → Real) fun i => (μ (s i)).toReal\nhsμ : autoParam (li.EventuallyEq (fun i => (μ (s i)).toReal) m) _auto✝\n⊢ Asymptotics.IsLittleO li (fun i => HSub.hSub (MeasureTheory.integral (μ.restrict (s i)) fun x => f x) (HSMul.hSMul (m i) (f x))) m","decl":"/-- Fundamental theorem of calculus for set integrals, `nhdsWithin` version: if `μ` is a locally\nfinite measure, `f` is continuous on a measurable set `t`, and `a ∈ t`, then `∫ x in (s i), f x ∂μ =\nμ (s i) • f a + o(μ (s i))` at `li` provided that `s i` tends to `(𝓝[t] a).smallSets` along `li`.\nSince `μ (s i)` is an `ℝ≥0∞` number, we use `(μ (s i)).toReal` in the actual statement.\n\nOften there is a good formula for `(μ (s i)).toReal`, so the formalization can take an optional\nargument `m` with this formula and a proof of `(fun i => (μ (s i)).toReal) =ᶠ[li] m`. Without these\narguments, `m i = (μ (s i)).toReal` is used in the output. -/\ntheorem ContinuousOn.integral_sub_linear_isLittleO_ae [TopologicalSpace X] [OpensMeasurableSpace X]\n    [SecondCountableTopologyEither X E] {μ : Measure X}\n    [IsLocallyFiniteMeasure μ] {x : X} {t : Set X} {f : X → E} (hft : ContinuousOn f t) (hx : x ∈ t)\n    (ht : MeasurableSet t) {s : ι → Set X} {li : Filter ι} (hs : Tendsto s li (𝓝[t] x).smallSets)\n    (m : ι → ℝ := fun i => (μ (s i)).toReal)\n    (hsμ : (fun i => (μ (s i)).toReal) =ᶠ[li] m := by rfl) :\n    (fun i => (∫ x in s i, f x ∂μ) - m i • f x) =o[li] m :=\n  (hft x hx).integral_sub_linear_isLittleO_ae ht\n    ⟨t, self_mem_nhdsWithin, hft.aestronglyMeasurable ht⟩ hs m hsμ\n\n"}
{"name":"ContinuousLinearMap.integral_compLp","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝⁶ : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝕜 : Type u_5\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\np : ENNReal\ninst✝ : NormedSpace Real F\nL : ContinuousLinearMap (RingHom.id 𝕜) E F\nφ : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\n⊢ Eq (MeasureTheory.integral μ fun x => ↑↑(L.compLp φ) x) (MeasureTheory.integral μ fun x => L (↑↑φ x))","decl":"theorem integral_compLp (L : E →L[𝕜] F) (φ : Lp E p μ) :\n    ∫ x, (L.compLp φ) x ∂μ = ∫ x, L (φ x) ∂μ :=\n  integral_congr_ae <| coeFn_compLp _ _\n\n"}
{"name":"ContinuousLinearMap.setIntegral_compLp","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝⁶ : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝕜 : Type u_5\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\np : ENNReal\ninst✝ : NormedSpace Real F\nL : ContinuousLinearMap (RingHom.id 𝕜) E F\nφ : Subtype fun x => Membership.mem (MeasureTheory.Lp E p μ) x\ns : Set X\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.integral (μ.restrict s) fun x => ↑↑(L.compLp φ) x) (MeasureTheory.integral (μ.restrict s) fun x => L (↑↑φ x))","decl":"theorem setIntegral_compLp (L : E →L[𝕜] F) (φ : Lp E p μ) {s : Set X} (hs : MeasurableSet s) :\n    ∫ x in s, (L.compLp φ) x ∂μ = ∫ x in s, L (φ x) ∂μ :=\n  setIntegral_congr_ae hs ((L.coeFn_compLp φ).mono fun _x hx _ => hx)\n\n"}
{"name":"ContinuousLinearMap.continuous_integral_comp_L1","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝⁶ : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝕜 : Type u_5\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ninst✝ : NormedSpace Real F\nL : ContinuousLinearMap (RingHom.id 𝕜) E F\n⊢ Continuous fun φ => MeasureTheory.integral μ fun x => L (↑↑φ x)","decl":"theorem continuous_integral_comp_L1 (L : E →L[𝕜] F) :\n    Continuous fun φ : X →₁[μ] E => ∫ x : X, L (φ x) ∂μ := by\n  rw [← funext L.integral_compLp]; exact continuous_integral.comp (L.compLpL 1 μ).continuous\n\n"}
{"name":"ContinuousLinearMap.integral_comp_comm","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝⁹ : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝕜 : Type u_5\ninst✝⁸ : RCLike 𝕜\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : NormedSpace Real F\ninst✝² : CompleteSpace F\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nL : ContinuousLinearMap (RingHom.id 𝕜) E F\nφ : X → E\nφ_int : MeasureTheory.Integrable φ μ\n⊢ Eq (MeasureTheory.integral μ fun x => L (φ x)) (L (MeasureTheory.integral μ fun x => φ x))","decl":"theorem integral_comp_comm [CompleteSpace E] (L : E →L[𝕜] F) {φ : X → E} (φ_int : Integrable φ μ) :\n    ∫ x, L (φ x) ∂μ = L (∫ x, φ x ∂μ) := by\n  apply φ_int.induction (P := fun φ => ∫ x, L (φ x) ∂μ = L (∫ x, φ x ∂μ))\n  · intro e s s_meas _\n    rw [integral_indicator_const e s_meas, ← @smul_one_smul E ℝ 𝕜 _ _ _ _ _ (μ s).toReal e,\n      ContinuousLinearMap.map_smul, @smul_one_smul F ℝ 𝕜 _ _ _ _ _ (μ s).toReal (L e), ←\n      integral_indicator_const (L e) s_meas]\n    congr 1 with a\n    rw [← Function.comp_def L, Set.indicator_comp_of_zero L.map_zero, Function.comp_apply]\n  · intro f g _ f_int g_int hf hg\n    simp [L.map_add, integral_add (μ := μ) f_int g_int,\n      integral_add (μ := μ) (L.integrable_comp f_int) (L.integrable_comp g_int), hf, hg]\n  · exact isClosed_eq L.continuous_integral_comp_L1 (L.continuous.comp continuous_integral)\n  · intro f g hfg _ hf\n    convert hf using 1 <;> clear hf\n    · exact integral_congr_ae (hfg.fun_comp L).symm\n    · rw [integral_congr_ae hfg.symm]\n\n"}
{"name":"ContinuousLinearMap.integral_apply","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝⁶ : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝕜 : Type u_5\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : NormedSpace Real E\nH : Type u_6\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nφ : X → ContinuousLinearMap (RingHom.id 𝕜) H E\nφ_int : MeasureTheory.Integrable φ μ\nv : H\n⊢ Eq ((MeasureTheory.integral μ fun x => φ x) v) (MeasureTheory.integral μ fun x => (φ x) v)","decl":"theorem integral_apply {H : Type*} [NormedAddCommGroup H] [NormedSpace 𝕜 H] {φ : X → H →L[𝕜] E}\n    (φ_int : Integrable φ μ) (v : H) : (∫ x, φ x ∂μ) v = ∫ x, φ x v ∂μ := by\n  by_cases hE : CompleteSpace E\n  · exact ((ContinuousLinearMap.apply 𝕜 E v).integral_comp_comm φ_int).symm\n  · rcases subsingleton_or_nontrivial H with hH|hH\n    · simp [Subsingleton.eq_zero v]\n    · have : ¬(CompleteSpace (H →L[𝕜] E)) := by\n        rwa [SeparatingDual.completeSpace_continuousLinearMap_iff]\n      simp [integral, hE, this]\n\n"}
{"name":"ContinuousMultilinearMap.integral_apply","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝⁷ : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝕜 : Type u_5\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedSpace Real E\nι : Type u_6\ninst✝² : Fintype ι\nM : ι → Type u_7\ninst✝¹ : (i : ι) → NormedAddCommGroup (M i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (M i)\nφ : X → ContinuousMultilinearMap 𝕜 M E\nφ_int : MeasureTheory.Integrable φ μ\nm : (i : ι) → M i\n⊢ Eq ((MeasureTheory.integral μ fun x => φ x) m) (MeasureTheory.integral μ fun x => (φ x) m)","decl":"theorem _root_.ContinuousMultilinearMap.integral_apply {ι : Type*} [Fintype ι] {M : ι → Type*}\n    [∀ i, NormedAddCommGroup (M i)] [∀ i, NormedSpace 𝕜 (M i)]\n    {φ : X → ContinuousMultilinearMap 𝕜 M E} (φ_int : Integrable φ μ) (m : ∀ i, M i) :\n    (∫ x, φ x ∂μ) m = ∫ x, φ x m ∂μ := by\n  by_cases hE : CompleteSpace E\n  · exact ((ContinuousMultilinearMap.apply 𝕜 M E m).integral_comp_comm φ_int).symm\n  · by_cases hm : ∀ i, m i ≠ 0\n    · have : ¬ CompleteSpace (ContinuousMultilinearMap 𝕜 M E) := by\n        rwa [SeparatingDual.completeSpace_continuousMultilinearMap_iff _ _ hm]\n      simp [integral, hE, this]\n    · push_neg at hm\n      rcases hm with ⟨i, hi⟩\n      simp [ContinuousMultilinearMap.map_coord_zero _ i hi]\n\n"}
{"name":"ContinuousLinearMap.integral_comp_comm'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝⁹ : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝕜 : Type u_5\ninst✝⁸ : RCLike 𝕜\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : NormedSpace Real F\ninst✝² : CompleteSpace F\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nL : ContinuousLinearMap (RingHom.id 𝕜) E F\nK : NNReal\nhL : AntilipschitzWith K ⇑L\nφ : X → E\n⊢ Eq (MeasureTheory.integral μ fun x => L (φ x)) (L (MeasureTheory.integral μ fun x => φ x))","decl":"theorem integral_comp_comm' (L : E →L[𝕜] F) {K} (hL : AntilipschitzWith K L) (φ : X → E) :\n    ∫ x, L (φ x) ∂μ = L (∫ x, φ x ∂μ) := by\n  by_cases h : Integrable φ μ\n  · exact integral_comp_comm L h\n  have : ¬Integrable (fun x => L (φ x)) μ := by\n    rwa [← Function.comp_def,\n      LipschitzWith.integrable_comp_iff_of_antilipschitz L.lipschitz hL L.map_zero]\n  simp [integral_undef, h, this]\n\n"}
{"name":"ContinuousLinearMap.integral_comp_L1_comm","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝⁹ : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝕜 : Type u_5\ninst✝⁸ : RCLike 𝕜\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : NormedSpace Real F\ninst✝² : CompleteSpace F\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nL : ContinuousLinearMap (RingHom.id 𝕜) E F\nφ : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 μ) x\n⊢ Eq (MeasureTheory.integral μ fun x => L (↑↑φ x)) (L (MeasureTheory.integral μ fun x => ↑↑φ x))","decl":"theorem integral_comp_L1_comm (L : E →L[𝕜] F) (φ : X →₁[μ] E) :\n    ∫ x, L (φ x) ∂μ = L (∫ x, φ x ∂μ) :=\n  L.integral_comp_comm (L1.integrable_coeFn φ)\n\n"}
{"name":"LinearIsometry.integral_comp_comm","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝⁹ : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝕜 : Type u_5\ninst✝⁸ : RCLike 𝕜\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : CompleteSpace F\ninst✝² : NormedSpace Real F\ninst✝¹ : CompleteSpace E\ninst✝ : NormedSpace Real E\nL : LinearIsometry (RingHom.id 𝕜) E F\nφ : X → E\n⊢ Eq (MeasureTheory.integral μ fun x => L (φ x)) (L (MeasureTheory.integral μ fun x => φ x))","decl":"theorem integral_comp_comm (L : E →ₗᵢ[𝕜] F) (φ : X → E) : ∫ x, L (φ x) ∂μ = L (∫ x, φ x ∂μ) :=\n  L.toContinuousLinearMap.integral_comp_comm' L.antilipschitz _\n\n"}
{"name":"ContinuousLinearEquiv.integral_comp_comm","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝⁷ : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝕜 : Type u_5\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedSpace Real F\ninst✝ : NormedSpace Real E\nL : ContinuousLinearEquiv (RingHom.id 𝕜) E F\nφ : X → E\n⊢ Eq (MeasureTheory.integral μ fun x => L (φ x)) (L (MeasureTheory.integral μ fun x => φ x))","decl":"theorem integral_comp_comm (L : E ≃L[𝕜] F) (φ : X → E) : ∫ x, L (φ x) ∂μ = L (∫ x, φ x ∂μ) := by\n  have : CompleteSpace E ↔ CompleteSpace F :=\n    completeSpace_congr (e := L.toEquiv) L.isUniformEmbedding\n  obtain ⟨_, _⟩|⟨_, _⟩ := iff_iff_and_or_not_and_not.mp this\n  · exact L.toContinuousLinearMap.integral_comp_comm' L.antilipschitz _\n  · simp [integral, *]\n\n"}
{"name":"ContinuousMap.integral_apply","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nY : Type u_2\nE : Type u_3\ninst✝⁵ : MeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : TopologicalSpace Y\ninst✝² : CompactSpace Y\ninst✝¹ : NormedSpace Real E\ninst✝ : CompleteSpace E\nf : X → ContinuousMap Y E\nhf : MeasureTheory.Integrable f μ\ny : Y\n⊢ Eq ((MeasureTheory.integral μ fun x => f x) y) (MeasureTheory.integral μ fun x => (f x) y)","decl":"lemma ContinuousMap.integral_apply [NormedSpace ℝ E] [CompleteSpace E] {f : X → C(Y, E)}\n    (hf : Integrable f μ) (y : Y) : (∫ x, f x ∂μ) y = ∫ x, f x y ∂μ := by\n  calc (∫ x, f x ∂μ) y = ContinuousMap.evalCLM ℝ y (∫ x, f x ∂μ) := rfl\n    _ = ∫ x, ContinuousMap.evalCLM ℝ y (f x) ∂μ :=\n          (ContinuousLinearMap.integral_comp_comm _ hf).symm\n    _ = _ := rfl\n\n"}
{"name":"ContinuousMapZero.integral_apply","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nY : Type u_2\ninst✝⁶ : MeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝⁵ : TopologicalSpace Y\ninst✝⁴ : CompactSpace Y\nR : Type u_6\ninst✝³ : NormedCommRing R\ninst✝² : Zero Y\ninst✝¹ : NormedAlgebra Real R\ninst✝ : CompleteSpace R\nf : X → ContinuousMapZero Y R\nhf : MeasureTheory.Integrable f μ\ny : Y\n⊢ Eq ((MeasureTheory.integral μ fun x => f x) y) (MeasureTheory.integral μ fun x => (f x) y)","decl":"open scoped ContinuousMapZero in\ntheorem ContinuousMapZero.integral_apply {R : Type*} [NormedCommRing R] [Zero Y]\n    [NormedAlgebra ℝ R] [CompleteSpace R] {f : X → C(Y, R)₀}\n    (hf : MeasureTheory.Integrable f μ) (y : Y) :\n    (∫ (x : X), f x ∂μ) y = ∫ (x : X), (f x) y ∂μ := by\n  calc (∫ x, f x ∂μ) y = ContinuousMapZero.evalCLM ℝ y (∫ x, f x ∂μ) := rfl\n    _ = ∫ x, ContinuousMapZero.evalCLM ℝ y (f x) ∂μ :=\n          (ContinuousLinearMap.integral_comp_comm _ hf).symm\n    _ = _ := rfl\n\n"}
{"name":"integral_ofReal","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝¹ : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝕜 : Type u_5\ninst✝ : RCLike 𝕜\nf : X → Real\n⊢ Eq (MeasureTheory.integral μ fun x => ↑(f x)) ↑(MeasureTheory.integral μ fun x => f x)","decl":"@[norm_cast]\ntheorem integral_ofReal {f : X → ℝ} : ∫ x, (f x : 𝕜) ∂μ = ↑(∫ x, f x ∂μ) :=\n  (@RCLike.ofRealLI 𝕜 _).integral_comp_comm f\n\n"}
{"name":"integral_complex_ofReal","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝ : MeasurableSpace X\nμ : MeasureTheory.Measure X\nf : X → Real\n⊢ Eq (MeasureTheory.integral μ fun x => ↑(f x)) ↑(MeasureTheory.integral μ fun x => f x)","decl":"theorem integral_complex_ofReal {f : X → ℝ} : ∫ x, (f x : ℂ) ∂μ = ∫ x, f x ∂μ := integral_ofReal\n\n"}
{"name":"integral_re","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝¹ : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝕜 : Type u_5\ninst✝ : RCLike 𝕜\nf : X → 𝕜\nhf : MeasureTheory.Integrable f μ\n⊢ Eq (MeasureTheory.integral μ fun x => RCLike.re (f x)) (RCLike.re (MeasureTheory.integral μ fun x => f x))","decl":"theorem integral_re {f : X → 𝕜} (hf : Integrable f μ) :\n    ∫ x, RCLike.re (f x) ∂μ = RCLike.re (∫ x, f x ∂μ) :=\n  (@RCLike.reCLM 𝕜 _).integral_comp_comm hf\n\n"}
{"name":"integral_im","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝¹ : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝕜 : Type u_5\ninst✝ : RCLike 𝕜\nf : X → 𝕜\nhf : MeasureTheory.Integrable f μ\n⊢ Eq (MeasureTheory.integral μ fun x => RCLike.im (f x)) (RCLike.im (MeasureTheory.integral μ fun x => f x))","decl":"theorem integral_im {f : X → 𝕜} (hf : Integrable f μ) :\n    ∫ x, RCLike.im (f x) ∂μ = RCLike.im (∫ x, f x ∂μ) :=\n  (@RCLike.imCLM 𝕜 _).integral_comp_comm hf\n\n"}
{"name":"integral_conj","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝¹ : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝕜 : Type u_5\ninst✝ : RCLike 𝕜\nf : X → 𝕜\n⊢ Eq (MeasureTheory.integral μ fun x => (starRingEnd 𝕜) (f x)) ((starRingEnd 𝕜) (MeasureTheory.integral μ fun x => f x))","decl":"theorem integral_conj {f : X → 𝕜} : ∫ x, conj (f x) ∂μ = conj (∫ x, f x ∂μ) :=\n  (@RCLike.conjLIE 𝕜 _).toLinearIsometry.integral_comp_comm f\n\n"}
{"name":"integral_coe_re_add_coe_im","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝¹ : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝕜 : Type u_5\ninst✝ : RCLike 𝕜\nf : X → 𝕜\nhf : MeasureTheory.Integrable f μ\n⊢ Eq (HAdd.hAdd (MeasureTheory.integral μ fun x => ↑(RCLike.re (f x))) (HMul.hMul (MeasureTheory.integral μ fun x => ↑(RCLike.im (f x))) RCLike.I)) (MeasureTheory.integral μ fun x => f x)","decl":"theorem integral_coe_re_add_coe_im {f : X → 𝕜} (hf : Integrable f μ) :\n    ∫ x, (re (f x) : 𝕜) ∂μ + (∫ x, (im (f x) : 𝕜) ∂μ) * RCLike.I = ∫ x, f x ∂μ := by\n  rw [mul_comm, ← smul_eq_mul, ← integral_smul, ← integral_add]\n  · congr\n    ext1 x\n    rw [smul_eq_mul, mul_comm, RCLike.re_add_im]\n  · exact hf.re.ofReal\n  · exact hf.im.ofReal.smul (𝕜 := 𝕜) (β := 𝕜) RCLike.I\n\n"}
{"name":"integral_re_add_im","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝¹ : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝕜 : Type u_5\ninst✝ : RCLike 𝕜\nf : X → 𝕜\nhf : MeasureTheory.Integrable f μ\n⊢ Eq (HAdd.hAdd (↑(MeasureTheory.integral μ fun x => RCLike.re (f x))) (HMul.hMul (↑(MeasureTheory.integral μ fun x => RCLike.im (f x))) RCLike.I)) (MeasureTheory.integral μ fun x => f x)","decl":"theorem integral_re_add_im {f : X → 𝕜} (hf : Integrable f μ) :\n    ((∫ x, RCLike.re (f x) ∂μ : ℝ) : 𝕜) + (∫ x, RCLike.im (f x) ∂μ : ℝ) * RCLike.I =\n      ∫ x, f x ∂μ := by\n  rw [← integral_ofReal, ← integral_ofReal, integral_coe_re_add_coe_im hf]\n\n"}
{"name":"setIntegral_re_add_im","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝¹ : MeasurableSpace X\nμ : MeasureTheory.Measure X\n𝕜 : Type u_5\ninst✝ : RCLike 𝕜\nf : X → 𝕜\ni : Set X\nhf : MeasureTheory.IntegrableOn f i μ\n⊢ Eq (HAdd.hAdd (↑(MeasureTheory.integral (μ.restrict i) fun x => RCLike.re (f x))) (HMul.hMul (↑(MeasureTheory.integral (μ.restrict i) fun x => RCLike.im (f x))) RCLike.I)) (MeasureTheory.integral (μ.restrict i) fun x => f x)","decl":"theorem setIntegral_re_add_im {f : X → 𝕜} {i : Set X} (hf : IntegrableOn f i μ) :\n    ((∫ x in i, RCLike.re (f x) ∂μ : ℝ) : 𝕜) + (∫ x in i, RCLike.im (f x) ∂μ : ℝ) * RCLike.I =\n      ∫ x in i, f x ∂μ :=\n  integral_re_add_im hf\n\n"}
{"name":"swap_integral","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝⁴ : MeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace Real E\ninst✝ : NormedSpace Real F\nf : X → Prod E F\n⊢ Eq (MeasureTheory.integral μ fun x => f x).swap (MeasureTheory.integral μ fun x => (f x).swap)","decl":"lemma swap_integral (f : X → E × F) : (∫ x, f x ∂μ).swap = ∫ x, (f x).swap ∂μ :=\n  .symm <| (ContinuousLinearEquiv.prodComm ℝ E F).integral_comp_comm f\n\n"}
{"name":"fst_integral","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝⁵ : MeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedSpace Real F\ninst✝ : CompleteSpace F\nf : X → Prod E F\nhf : MeasureTheory.Integrable f μ\n⊢ Eq (MeasureTheory.integral μ fun x => f x).1 (MeasureTheory.integral μ fun x => (f x).1)","decl":"theorem fst_integral [CompleteSpace F] {f : X → E × F} (hf : Integrable f μ) :\n    (∫ x, f x ∂μ).1 = ∫ x, (f x).1 ∂μ := by\n  by_cases hE : CompleteSpace E\n  · exact ((ContinuousLinearMap.fst ℝ E F).integral_comp_comm hf).symm\n  · have : ¬(CompleteSpace (E × F)) := fun h ↦ hE <| .fst_of_prod (β := F)\n    simp [integral, *]\n\n"}
{"name":"snd_integral","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝⁵ : MeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedSpace Real F\ninst✝ : CompleteSpace E\nf : X → Prod E F\nhf : MeasureTheory.Integrable f μ\n⊢ Eq (MeasureTheory.integral μ fun x => f x).2 (MeasureTheory.integral μ fun x => (f x).2)","decl":"theorem snd_integral [CompleteSpace E] {f : X → E × F} (hf : Integrable f μ) :\n    (∫ x, f x ∂μ).2 = ∫ x, (f x).2 ∂μ := by\n  rw [← Prod.fst_swap, swap_integral]\n  exact fst_integral <| hf.snd.prod_mk hf.fst\n\n"}
{"name":"integral_pair","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\nF : Type u_4\ninst✝⁶ : MeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace Real E\ninst✝² : NormedSpace Real F\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace F\nf : X → E\ng : X → F\nhf : MeasureTheory.Integrable f μ\nhg : MeasureTheory.Integrable g μ\n⊢ Eq (MeasureTheory.integral μ fun x => { fst := f x, snd := g x }) { fst := MeasureTheory.integral μ fun x => f x, snd := MeasureTheory.integral μ fun x => g x }","decl":"theorem integral_pair [CompleteSpace E] [CompleteSpace F] {f : X → E} {g : X → F}\n    (hf : Integrable f μ) (hg : Integrable g μ) :\n    ∫ x, (f x, g x) ∂μ = (∫ x, f x ∂μ, ∫ x, g x ∂μ) :=\n  have := hf.prod_mk hg\n  Prod.ext (fst_integral this) (snd_integral this)\n\n"}
{"name":"integral_smul_const","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝⁵ : MeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\n𝕜 : Type u_6\ninst✝² : RCLike 𝕜\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : CompleteSpace E\nf : X → 𝕜\nc : E\n⊢ Eq (MeasureTheory.integral μ fun x => HSMul.hSMul (f x) c) (HSMul.hSMul (MeasureTheory.integral μ fun x => f x) c)","decl":"theorem integral_smul_const {𝕜 : Type*} [RCLike 𝕜] [NormedSpace 𝕜 E] [CompleteSpace E]\n    (f : X → 𝕜) (c : E) :\n    ∫ x, f x • c ∂μ = (∫ x, f x ∂μ) • c := by\n  by_cases hf : Integrable f μ\n  · exact ((1 : 𝕜 →L[𝕜] 𝕜).smulRight c).integral_comp_comm hf\n  · by_cases hc : c = 0\n    · simp [hc, integral_zero, smul_zero]\n    rw [integral_undef hf, integral_undef, zero_smul]\n    rw [integrable_smul_const hc]\n    simp_rw [hf, not_false_eq_true]\n\n"}
{"name":"integral_withDensity_eq_integral_smul","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → NNReal\nf_meas : Measurable f\ng : X → E\n⊢ Eq (MeasureTheory.integral (μ.withDensity fun x => ↑(f x)) fun x => g x) (MeasureTheory.integral μ fun x => HSMul.hSMul (f x) (g x))","decl":"theorem integral_withDensity_eq_integral_smul {f : X → ℝ≥0} (f_meas : Measurable f) (g : X → E) :\n    ∫ x, g x ∂μ.withDensity (fun x => f x) = ∫ x, f x • g x ∂μ := by\n  by_cases hE : CompleteSpace E; swap; · simp [integral, hE]\n  by_cases hg : Integrable g (μ.withDensity fun x => f x); swap\n  · rw [integral_undef hg, integral_undef]\n    rwa [← integrable_withDensity_iff_integrable_smul f_meas]\n  refine Integrable.induction\n    (P := fun g => ∫ x, g x ∂μ.withDensity (fun x => f x) = ∫ x, f x • g x ∂μ) ?_ ?_ ?_ ?_ hg\n  · intro c s s_meas hs\n    rw [integral_indicator s_meas]\n    simp_rw [← indicator_smul_apply, integral_indicator s_meas]\n    simp only [s_meas, integral_const, Measure.restrict_apply', univ_inter, withDensity_apply]\n    rw [lintegral_coe_eq_integral, ENNReal.toReal_ofReal, ← integral_smul_const]\n    · rfl\n    · exact integral_nonneg fun x => NNReal.coe_nonneg _\n    · refine ⟨f_meas.coe_nnreal_real.aemeasurable.aestronglyMeasurable, ?_⟩\n      simpa [withDensity_apply _ s_meas, hasFiniteIntegral_iff_enorm] using hs\n  · intro u u' _ u_int u'_int h h'\n    change\n      (∫ x : X, u x + u' x ∂μ.withDensity fun x : X => ↑(f x)) = ∫ x : X, f x • (u x + u' x) ∂μ\n    simp_rw [smul_add]\n    rw [integral_add u_int u'_int, h, h', integral_add]\n    · exact (integrable_withDensity_iff_integrable_smul f_meas).1 u_int\n    · exact (integrable_withDensity_iff_integrable_smul f_meas).1 u'_int\n  · have C1 :\n      Continuous fun u : Lp E 1 (μ.withDensity fun x => f x) =>\n        ∫ x, u x ∂μ.withDensity fun x => f x :=\n      continuous_integral\n    have C2 : Continuous fun u : Lp E 1 (μ.withDensity fun x => f x) => ∫ x, f x • u x ∂μ := by\n      have : Continuous ((fun u : Lp E 1 μ => ∫ x, u x ∂μ) ∘ withDensitySMulLI (E := E) μ f_meas) :=\n        continuous_integral.comp (withDensitySMulLI (E := E) μ f_meas).continuous\n      convert this with u\n      simp only [Function.comp_apply, withDensitySMulLI_apply]\n      exact integral_congr_ae (memℒ1_smul_of_L1_withDensity f_meas u).coeFn_toLp.symm\n    exact isClosed_eq C1 C2\n  · intro u v huv _ hu\n    rw [← integral_congr_ae huv, hu]\n    apply integral_congr_ae\n    filter_upwards [(ae_withDensity_iff f_meas.coe_nnreal_ennreal).1 huv] with x hx\n    rcases eq_or_ne (f x) 0 with (h'x | h'x)\n    · simp only [h'x, zero_smul]\n    · rw [hx _]\n      simpa only [Ne, ENNReal.coe_eq_zero] using h'x\n\n"}
{"name":"integral_withDensity_eq_integral_smul₀","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → NNReal\nhf : AEMeasurable f μ\ng : X → E\n⊢ Eq (MeasureTheory.integral (μ.withDensity fun x => ↑(f x)) fun x => g x) (MeasureTheory.integral μ fun x => HSMul.hSMul (f x) (g x))","decl":"theorem integral_withDensity_eq_integral_smul₀ {f : X → ℝ≥0} (hf : AEMeasurable f μ) (g : X → E) :\n    ∫ x, g x ∂μ.withDensity (fun x => f x) = ∫ x, f x • g x ∂μ := by\n  let f' := hf.mk _\n  calc\n    ∫ x, g x ∂μ.withDensity (fun x => f x) = ∫ x, g x ∂μ.withDensity fun x => f' x := by\n      congr 1\n      apply withDensity_congr_ae\n      filter_upwards [hf.ae_eq_mk] with x hx\n      rw [hx]\n    _ = ∫ x, f' x • g x ∂μ := integral_withDensity_eq_integral_smul hf.measurable_mk _\n    _ = ∫ x, f x • g x ∂μ := by\n      apply integral_congr_ae\n      filter_upwards [hf.ae_eq_mk] with x hx\n      rw [hx]\n\n"}
{"name":"setIntegral_withDensity_eq_setIntegral_smul","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → NNReal\nf_meas : Measurable f\ng : X → E\ns : Set X\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.integral ((μ.withDensity fun x => ↑(f x)).restrict s) fun x => g x) (MeasureTheory.integral (μ.restrict s) fun x => HSMul.hSMul (f x) (g x))","decl":"theorem setIntegral_withDensity_eq_setIntegral_smul {f : X → ℝ≥0} (f_meas : Measurable f)\n    (g : X → E) {s : Set X} (hs : MeasurableSet s) :\n    ∫ x in s, g x ∂μ.withDensity (fun x => f x) = ∫ x in s, f x • g x ∂μ := by\n  rw [restrict_withDensity hs, integral_withDensity_eq_integral_smul f_meas]\n\n"}
{"name":"setIntegral_withDensity_eq_setIntegral_smul₀","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝² : MeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : X → NNReal\ns : Set X\nhf : AEMeasurable f (μ.restrict s)\ng : X → E\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.integral ((μ.withDensity fun x => ↑(f x)).restrict s) fun x => g x) (MeasureTheory.integral (μ.restrict s) fun x => HSMul.hSMul (f x) (g x))","decl":"theorem setIntegral_withDensity_eq_setIntegral_smul₀ {f : X → ℝ≥0} {s : Set X}\n    (hf : AEMeasurable f (μ.restrict s)) (g : X → E) (hs : MeasurableSet s) :\n    ∫ x in s, g x ∂μ.withDensity (fun x => f x) = ∫ x in s, f x • g x ∂μ := by\n  rw [restrict_withDensity hs, integral_withDensity_eq_integral_smul₀ hf]\n\n"}
{"name":"setIntegral_withDensity_eq_setIntegral_smul₀'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\nE : Type u_3\ninst✝³ : MeasurableSpace X\nμ : MeasureTheory.Measure X\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : MeasureTheory.SFinite μ\nf : X → NNReal\ns : Set X\nhf : AEMeasurable f (μ.restrict s)\ng : X → E\n⊢ Eq (MeasureTheory.integral ((μ.withDensity fun x => ↑(f x)).restrict s) fun x => g x) (MeasureTheory.integral (μ.restrict s) fun x => HSMul.hSMul (f x) (g x))","decl":"theorem setIntegral_withDensity_eq_setIntegral_smul₀' [SFinite μ] {f : X → ℝ≥0} (s : Set X)\n    (hf : AEMeasurable f (μ.restrict s)) (g : X → E)  :\n    ∫ x in s, g x ∂μ.withDensity (fun x => f x) = ∫ x in s, f x • g x ∂μ := by\n  rw [restrict_withDensity' s, integral_withDensity_eq_integral_smul₀ hf]\n\n"}
{"name":"measure_le_lintegral_thickenedIndicatorAux","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝¹ : MeasurableSpace X\ninst✝ : PseudoEMetricSpace X\nμ : MeasureTheory.Measure X\nE : Set X\nE_mble : MeasurableSet E\nδ : Real\n⊢ LE.le (μ E) (MeasureTheory.lintegral μ fun x => thickenedIndicatorAux δ E x)","decl":"theorem measure_le_lintegral_thickenedIndicatorAux (μ : Measure X) {E : Set X}\n    (E_mble : MeasurableSet E) (δ : ℝ) : μ E ≤ ∫⁻ x, (thickenedIndicatorAux δ E x : ℝ≥0∞) ∂μ := by\n  convert_to lintegral μ (E.indicator fun _ => (1 : ℝ≥0∞)) ≤ lintegral μ (thickenedIndicatorAux δ E)\n  · rw [lintegral_indicator E_mble]\n    simp only [lintegral_one, Measure.restrict_apply, MeasurableSet.univ, univ_inter]\n  · apply lintegral_mono\n    apply indicator_le_thickenedIndicatorAux\n\n"}
{"name":"measure_le_lintegral_thickenedIndicator","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_1\ninst✝¹ : MeasurableSpace X\ninst✝ : PseudoEMetricSpace X\nμ : MeasureTheory.Measure X\nE : Set X\nE_mble : MeasurableSet E\nδ : Real\nδ_pos : LT.lt 0 δ\n⊢ LE.le (μ E) (MeasureTheory.lintegral μ fun x => ↑((thickenedIndicator δ_pos E) x))","decl":"theorem measure_le_lintegral_thickenedIndicator (μ : Measure X) {E : Set X}\n    (E_mble : MeasurableSet E) {δ : ℝ} (δ_pos : 0 < δ) :\n    μ E ≤ ∫⁻ x, (thickenedIndicator δ_pos E x : ℝ≥0∞) ∂μ := by\n  convert measure_le_lintegral_thickenedIndicatorAux μ E_mble δ\n  dsimp\n  simp only [thickenedIndicatorAux_lt_top.ne, ENNReal.coe_toNNReal, Ne, not_false_iff]\n\n"}
{"name":"MeasureTheory.Integrable.simpleFunc_mul","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_6\nf : X → Real\nm0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\ng : MeasureTheory.SimpleFunc X Real\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (HMul.hMul (⇑g) f) μ","decl":"theorem Integrable.simpleFunc_mul (g : SimpleFunc X ℝ) (hf : Integrable f μ) :\n    Integrable (⇑g * f) μ := by\n  refine\n    SimpleFunc.induction (fun c s hs => ?_)\n      (fun g₁ g₂ _ h_int₁ h_int₂ =>\n        (h_int₁.add h_int₂).congr (by rw [SimpleFunc.coe_add, add_mul]))\n      g\n  simp only [SimpleFunc.const_zero, SimpleFunc.coe_piecewise, SimpleFunc.coe_const,\n    SimpleFunc.coe_zero, Set.piecewise_eq_indicator]\n  have : Set.indicator s (Function.const X c) * f = s.indicator (c • f) := by\n    ext1 x\n    by_cases hx : x ∈ s\n    · simp only [hx, Pi.mul_apply, Set.indicator_of_mem, Pi.smul_apply, Algebra.id.smul_eq_mul,\n        ← Function.const_def]\n    · simp only [hx, Pi.mul_apply, Set.indicator_of_not_mem, not_false_iff, zero_mul]\n  rw [this, integrable_indicator_iff hs]\n  exact (hf.smul c).integrableOn\n\n"}
{"name":"MeasureTheory.Integrable.simpleFunc_mul'","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"X : Type u_6\nf : X → Real\nm m0 : MeasurableSpace X\nμ : MeasureTheory.Measure X\nhm : LE.le m m0\ng : MeasureTheory.SimpleFunc X Real\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (HMul.hMul (⇑g) f) μ","decl":"theorem Integrable.simpleFunc_mul' (hm : m ≤ m0) (g : @SimpleFunc X m ℝ) (hf : Integrable f μ) :\n    Integrable (⇑g * f) μ := by\n  rw [← SimpleFunc.coe_toLargerSpace_eq hm g]; exact hf.simpleFunc_mul (g.toLargerSpace hm)\n\n"}
{"name":"continuous_parametric_integral_of_continuous","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"Y : Type u_2\nE : Type u_3\nX : Type u_5\ninst✝⁹ : TopologicalSpace X\ninst✝⁸ : TopologicalSpace Y\ninst✝⁷ : MeasurableSpace Y\ninst✝⁶ : OpensMeasurableSpace Y\nμ : MeasureTheory.Measure Y\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : FirstCountableTopology X\ninst✝² : LocallyCompactSpace X\ninst✝¹ : SecondCountableTopologyEither Y E\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\nf : X → Y → E\nhf : Continuous (Function.uncurry f)\ns : Set Y\nhs : IsCompact s\n⊢ Continuous fun x => MeasureTheory.integral (μ.restrict s) fun y => f x y","decl":"/-- The parametric integral over a continuous function on a compact set is continuous,\n  under mild assumptions on the topologies involved. -/\ntheorem continuous_parametric_integral_of_continuous\n    [FirstCountableTopology X] [LocallyCompactSpace X]\n    [SecondCountableTopologyEither Y E] [IsLocallyFiniteMeasure μ]\n    {f : X → Y → E} (hf : Continuous f.uncurry) {s : Set Y} (hs : IsCompact s) :\n    Continuous (∫ y in s, f · y ∂μ) := by\n  rw [continuous_iff_continuousAt]\n  intro x₀\n  rcases exists_compact_mem_nhds x₀ with ⟨U, U_cpct, U_nhds⟩\n  rcases (U_cpct.prod hs).bddAbove_image hf.norm.continuousOn with ⟨M, hM⟩\n  apply continuousAt_of_dominated\n  · filter_upwards with x using Continuous.aestronglyMeasurable (by fun_prop)\n  · filter_upwards [U_nhds] with x x_in\n    rw [ae_restrict_iff]\n    · filter_upwards with t t_in using hM (mem_image_of_mem _ <| mk_mem_prod x_in t_in)\n    · exact (isClosed_le (by fun_prop) (by fun_prop)).measurableSet\n  · exact integrableOn_const.mpr (Or.inr hs.measure_lt_top)\n  · filter_upwards using (by fun_prop)\n\n"}
{"name":"continuousOn_integral_bilinear_of_locally_integrable_of_compact_support","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"Y : Type u_2\nE : Type u_3\nF : Type u_4\nX : Type u_5\nG : Type u_6\n𝕜 : Type u_7\ninst✝¹¹ : TopologicalSpace X\ninst✝¹⁰ : TopologicalSpace Y\ninst✝⁹ : MeasurableSpace Y\ninst✝⁸ : OpensMeasurableSpace Y\nμ : MeasureTheory.Measure Y\ninst✝⁷ : NontriviallyNormedField 𝕜\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : NormedSpace Real E\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\ninst✝² : NormedAddCommGroup G\ninst✝¹ : NormedSpace 𝕜 G\ninst✝ : NormedSpace 𝕜 E\nL : ContinuousLinearMap (RingHom.id 𝕜) F (ContinuousLinearMap (RingHom.id 𝕜) G E)\nf : X → Y → G\ns : Set X\nk : Set Y\ng : Y → F\nhk : IsCompact k\nhf : ContinuousOn (Function.uncurry f) (SProd.sprod s Set.univ)\nhfs : ∀ (p : X) (x : Y), Membership.mem s p → Not (Membership.mem k x) → Eq (f p x) 0\nhg : MeasureTheory.IntegrableOn g k μ\n⊢ ContinuousOn (fun x => MeasureTheory.integral μ fun y => (L (g y)) (f x y)) s","decl":"/-- Consider a parameterized integral `x ↦ ∫ y, L (g y) (f x y)` where `L` is bilinear,\n`g` is locally integrable and `f` is continuous and uniformly compactly supported. Then the\nintegral depends continuously on `x`. -/\nlemma continuousOn_integral_bilinear_of_locally_integrable_of_compact_support\n    [NormedSpace 𝕜 E] (L : F →L[𝕜] G →L[𝕜] E)\n    {f : X → Y → G} {s : Set X} {k : Set Y} {g : Y → F}\n    (hk : IsCompact k) (hf : ContinuousOn f.uncurry (s ×ˢ univ))\n    (hfs : ∀ p, ∀ x, p ∈ s → x ∉ k → f p x = 0) (hg : IntegrableOn g k μ) :\n    ContinuousOn (fun x ↦ ∫ y, L (g y) (f x y) ∂μ) s := by\n  have A : ∀ p ∈ s, Continuous (f p) := fun p hp ↦ by\n    refine hf.comp_continuous (continuous_const.prod_mk continuous_id') fun y => ?_\n    simpa only [prod_mk_mem_set_prod_eq, mem_univ, and_true] using hp\n  intro q hq\n  apply Metric.continuousWithinAt_iff'.2 (fun ε εpos ↦ ?_)\n  obtain ⟨δ, δpos, hδ⟩ : ∃ (δ : ℝ), 0 < δ ∧ ∫ x in k, ‖L‖ * ‖g x‖ * δ ∂μ < ε := by\n    simpa [integral_mul_right] using exists_pos_mul_lt εpos _\n  obtain ⟨v, v_mem, hv⟩ : ∃ v ∈ 𝓝[s] q, ∀ p ∈ v, ∀ x ∈ k, dist (f p x) (f q x) < δ :=\n    hk.mem_uniformity_of_prod\n      (hf.mono (Set.prod_mono_right (subset_univ k))) hq (dist_mem_uniformity δpos)\n  simp_rw [dist_eq_norm] at hv ⊢\n  have I : ∀ p ∈ s, IntegrableOn (fun y ↦ L (g y) (f p y)) k μ := by\n    intro p hp\n    obtain ⟨C, hC⟩ : ∃ C, ∀ y, ‖f p y‖ ≤ C := by\n      have : ContinuousOn (f p) k := by\n        have : ContinuousOn (fun y ↦ (p, y)) k := by fun_prop\n        exact hf.comp this (by simp [MapsTo, hp])\n      rcases IsCompact.exists_bound_of_continuousOn hk this with ⟨C, hC⟩\n      refine ⟨max C 0, fun y ↦ ?_⟩\n      by_cases hx : y ∈ k\n      · exact (hC y hx).trans (le_max_left _ _)\n      · simp [hfs p y hp hx]\n    have : IntegrableOn (fun y ↦ ‖L‖ * ‖g y‖ * C) k μ :=\n      (hg.norm.const_mul _).mul_const _\n    apply Integrable.mono' this ?_ ?_\n    · borelize G\n      apply L.aestronglyMeasurable_comp₂ hg.aestronglyMeasurable\n      apply StronglyMeasurable.aestronglyMeasurable\n      apply Continuous.stronglyMeasurable_of_support_subset_isCompact (A p hp) hk\n      apply support_subset_iff'.2 (fun y hy ↦ hfs p y hp hy)\n    · apply Eventually.of_forall (fun y ↦ (le_opNorm₂ L (g y) (f p y)).trans ?_)\n      gcongr\n      apply hC\n  filter_upwards [v_mem, self_mem_nhdsWithin] with p hp h'p\n  calc\n  ‖∫ x, L (g x) (f p x) ∂μ - ∫ x, L (g x) (f q x) ∂μ‖\n    = ‖∫ x in k, L (g x) (f p x) ∂μ - ∫ x in k, L (g x) (f q x) ∂μ‖ := by\n      congr 2\n      · refine (setIntegral_eq_integral_of_forall_compl_eq_zero (fun y hy ↦ ?_)).symm\n        simp [hfs p y h'p hy]\n      · refine (setIntegral_eq_integral_of_forall_compl_eq_zero (fun y hy ↦ ?_)).symm\n        simp [hfs q y hq hy]\n  _ = ‖∫ x in k, L (g x) (f p x) - L (g x) (f q x) ∂μ‖ := by rw [integral_sub (I p h'p) (I q hq)]\n  _ ≤ ∫ x in k, ‖L (g x) (f p x) - L (g x) (f q x)‖ ∂μ := norm_integral_le_integral_norm _\n  _ ≤ ∫ x in k, ‖L‖ * ‖g x‖ * δ ∂μ := by\n      apply integral_mono_of_nonneg (Eventually.of_forall (fun y ↦ by positivity))\n      · exact (hg.norm.const_mul _).mul_const _\n      · filter_upwards with y\n        by_cases hy : y ∈ k\n        · dsimp only\n          specialize hv p hp y hy\n          calc\n          ‖L (g y) (f p y) - L (g y) (f q y)‖\n            = ‖L (g y) (f p y - f q y)‖ := by simp only [map_sub]\n          _ ≤ ‖L‖ * ‖g y‖ * ‖f p y - f q y‖ := le_opNorm₂ _ _ _\n          _ ≤ ‖L‖ * ‖g y‖ * δ := by gcongr\n        · simp only [hfs p y h'p hy, hfs q y hq hy, sub_self, norm_zero, mul_zero]\n          positivity\n  _ < ε := hδ\n\n"}
{"name":"continuousOn_integral_of_compact_support","module":"Mathlib.MeasureTheory.Integral.SetIntegral","initialProofState":"Y : Type u_2\nE : Type u_3\nX : Type u_5\ninst✝⁶ : TopologicalSpace X\ninst✝⁵ : TopologicalSpace Y\ninst✝⁴ : MeasurableSpace Y\ninst✝³ : OpensMeasurableSpace Y\nμ : MeasureTheory.Measure Y\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\nf : X → Y → E\ns : Set X\nk : Set Y\ninst✝ : MeasureTheory.IsFiniteMeasureOnCompacts μ\nhk : IsCompact k\nhf : ContinuousOn (Function.uncurry f) (SProd.sprod s Set.univ)\nhfs : ∀ (p : X) (x : Y), Membership.mem s p → Not (Membership.mem k x) → Eq (f p x) 0\n⊢ ContinuousOn (fun x => MeasureTheory.integral μ fun y => f x y) s","decl":"/-- Consider a parameterized integral `x ↦ ∫ y, f x y` where `f` is continuous and uniformly\ncompactly supported. Then the integral depends continuously on `x`. -/\nlemma continuousOn_integral_of_compact_support\n    {f : X → Y → E} {s : Set X} {k : Set Y} [IsFiniteMeasureOnCompacts μ]\n    (hk : IsCompact k) (hf : ContinuousOn f.uncurry (s ×ˢ univ))\n    (hfs : ∀ p, ∀ x, p ∈ s → x ∉ k → f p x = 0) :\n    ContinuousOn (fun x ↦ ∫ y, f x y ∂μ) s := by\n  simpa using continuousOn_integral_bilinear_of_locally_integrable_of_compact_support (lsmul ℝ ℝ)\n    hk hf hfs (integrableOn_const.2 (Or.inr hk.measure_lt_top)) (μ := μ) (g := fun _ ↦ 1)\n\n"}
