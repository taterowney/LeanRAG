{"name":"Complex.log_re","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"x : Complex\n‚ä¢ Eq (Complex.log x).re (Real.log (Complex.abs x))","decl":"theorem log_re (x : ‚ÑÇ) : x.log.re = x.abs.log := by simp [log]\n\n"}
{"name":"Complex.log_im","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"x : Complex\n‚ä¢ Eq (Complex.log x).im x.arg","decl":"theorem log_im (x : ‚ÑÇ) : x.log.im = x.arg := by simp [log]\n\n"}
{"name":"Complex.neg_pi_lt_log_im","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"x : Complex\n‚ä¢ LT.lt (Neg.neg Real.pi) (Complex.log x).im","decl":"theorem neg_pi_lt_log_im (x : ‚ÑÇ) : -œÄ < (log x).im := by simp only [log_im, neg_pi_lt_arg]\n\n"}
{"name":"Complex.log_im_le_pi","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"x : Complex\n‚ä¢ LE.le (Complex.log x).im Real.pi","decl":"theorem log_im_le_pi (x : ‚ÑÇ) : (log x).im ‚â§ œÄ := by simp only [log_im, arg_le_pi]\n\n"}
{"name":"Complex.exp_log","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"x : Complex\nhx : Ne x 0\n‚ä¢ Eq (Complex.exp (Complex.log x)) x","decl":"theorem exp_log {x : ‚ÑÇ} (hx : x ‚â† 0) : exp (log x) = x := by\n  rw [log, exp_add_mul_I, ‚Üê ofReal_sin, sin_arg, ‚Üê ofReal_cos, cos_arg hx, ‚Üê ofReal_exp,\n    Real.exp_log (abs.pos hx), mul_add, ofReal_div, ofReal_div,\n    mul_div_cancel‚ÇÄ _ (ofReal_ne_zero.2 <| abs.ne_zero hx), ‚Üê mul_assoc,\n    mul_div_cancel‚ÇÄ _ (ofReal_ne_zero.2 <| abs.ne_zero hx), re_add_im]\n\n"}
{"name":"Complex.range_exp","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"‚ä¢ Eq (Set.range Complex.exp) (HasCompl.compl (Singleton.singleton 0))","decl":"@[simp]\ntheorem range_exp : Set.range exp = {0}·∂ú :=\n  Set.ext fun x =>\n    ‚ü®by\n      rintro ‚ü®x, rfl‚ü©\n      exact exp_ne_zero x, fun hx => ‚ü®log x, exp_log hx‚ü©‚ü©\n\n"}
{"name":"Complex.log_exp","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"x : Complex\nhx‚ÇÅ : LT.lt (Neg.neg Real.pi) x.im\nhx‚ÇÇ : LE.le x.im Real.pi\n‚ä¢ Eq (Complex.log (Complex.exp x)) x","decl":"theorem log_exp {x : ‚ÑÇ} (hx‚ÇÅ : -œÄ < x.im) (hx‚ÇÇ : x.im ‚â§ œÄ) : log (exp x) = x := by\n  rw [log, abs_exp, Real.log_exp, exp_eq_exp_re_mul_sin_add_cos, ‚Üê ofReal_exp,\n    arg_mul_cos_add_sin_mul_I (Real.exp_pos _) ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©, re_add_im]\n\n"}
{"name":"Complex.exp_inj_of_neg_pi_lt_of_le_pi","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"x y : Complex\nhx‚ÇÅ : LT.lt (Neg.neg Real.pi) x.im\nhx‚ÇÇ : LE.le x.im Real.pi\nhy‚ÇÅ : LT.lt (Neg.neg Real.pi) y.im\nhy‚ÇÇ : LE.le y.im Real.pi\nhxy : Eq (Complex.exp x) (Complex.exp y)\n‚ä¢ Eq x y","decl":"theorem exp_inj_of_neg_pi_lt_of_le_pi {x y : ‚ÑÇ} (hx‚ÇÅ : -œÄ < x.im) (hx‚ÇÇ : x.im ‚â§ œÄ) (hy‚ÇÅ : -œÄ < y.im)\n    (hy‚ÇÇ : y.im ‚â§ œÄ) (hxy : exp x = exp y) : x = y := by\n  rw [‚Üê log_exp hx‚ÇÅ hx‚ÇÇ, ‚Üê log_exp hy‚ÇÅ hy‚ÇÇ, hxy]\n\n"}
{"name":"Complex.ofReal_log","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"x : Real\nhx : LE.le 0 x\n‚ä¢ Eq (‚Üë(Real.log x)) (Complex.log ‚Üëx)","decl":"theorem ofReal_log {x : ‚Ñù} (hx : 0 ‚â§ x) : (x.log : ‚ÑÇ) = log x :=\n  Complex.ext (by rw [log_re, ofReal_re, abs_of_nonneg hx])\n    (by rw [ofReal_im, log_im, arg_ofReal_of_nonneg hx])\n\n"}
{"name":"Complex.natCast_log","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"n : Nat\n‚ä¢ Eq (‚Üë(Real.log ‚Üën)) (Complex.log ‚Üën)","decl":"@[simp, norm_cast]\nlemma natCast_log {n : ‚Ñï} : Real.log n = log n := ofReal_natCast n ‚ñ∏ ofReal_log n.cast_nonneg\n\n"}
{"name":"Complex.ofNat_log","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"n : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Eq (‚Üë(Real.log (OfNat.ofNat n))) (Complex.log (OfNat.ofNat n))","decl":"@[simp]\nlemma ofNat_log {n : ‚Ñï} [n.AtLeastTwo] :\n    Real.log ofNat(n) = log (OfNat.ofNat n) :=\n  natCast_log\n\n"}
{"name":"Complex.log_ofReal_re","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"x : Real\n‚ä¢ Eq (Complex.log ‚Üëx).re (Real.log x)","decl":"theorem log_ofReal_re (x : ‚Ñù) : (log (x : ‚ÑÇ)).re = Real.log x := by simp [log_re]\n\n"}
{"name":"Complex.log_ofReal_mul","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"r : Real\nhr : LT.lt 0 r\nx : Complex\nhx : Ne x 0\n‚ä¢ Eq (Complex.log (HMul.hMul (‚Üër) x)) (HAdd.hAdd (‚Üë(Real.log r)) (Complex.log x))","decl":"theorem log_ofReal_mul {r : ‚Ñù} (hr : 0 < r) {x : ‚ÑÇ} (hx : x ‚â† 0) :\n    log (r * x) = Real.log r + log x := by\n  replace hx := Complex.abs.ne_zero_iff.mpr hx\n  simp_rw [log, map_mul, abs_ofReal, arg_real_mul _ hr, abs_of_pos hr, Real.log_mul hr.ne' hx,\n    ofReal_add, add_assoc]\n\n"}
{"name":"Complex.log_mul_ofReal","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"r : Real\nhr : LT.lt 0 r\nx : Complex\nhx : Ne x 0\n‚ä¢ Eq (Complex.log (HMul.hMul x ‚Üër)) (HAdd.hAdd (‚Üë(Real.log r)) (Complex.log x))","decl":"theorem log_mul_ofReal (r : ‚Ñù) (hr : 0 < r) (x : ‚ÑÇ) (hx : x ‚â† 0) :\n    log (x * r) = Real.log r + log x := by rw [mul_comm, log_ofReal_mul hr hx]\n\n"}
{"name":"Complex.log_mul_eq_add_log_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"x y : Complex\nhx‚ÇÄ : Ne x 0\nhy‚ÇÄ : Ne y 0\n‚ä¢ Iff (Eq (Complex.log (HMul.hMul x y)) (HAdd.hAdd (Complex.log x) (Complex.log y))) (Membership.mem (Set.Ioc (Neg.neg Real.pi) Real.pi) (HAdd.hAdd x.arg y.arg))","decl":"lemma log_mul_eq_add_log_iff {x y : ‚ÑÇ} (hx‚ÇÄ : x ‚â† 0) (hy‚ÇÄ : y ‚â† 0) :\n    log (x * y) = log x + log y ‚Üî arg x + arg y ‚àà Set.Ioc (-œÄ) œÄ := by\n  refine Complex.ext_iff.trans <| Iff.trans ?_ <| arg_mul_eq_add_arg_iff hx‚ÇÄ hy‚ÇÄ\n  simp_rw [add_re, add_im, log_re, log_im, AbsoluteValue.map_mul,\n    Real.log_mul (abs.ne_zero hx‚ÇÄ) (abs.ne_zero hy‚ÇÄ), true_and]\n\n"}
{"name":"Complex.log_mul","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"x y : Complex\nhx‚ÇÄ : Ne x 0\nhy‚ÇÄ : Ne y 0\na‚úù : Membership.mem (Set.Ioc (Neg.neg Real.pi) Real.pi) (HAdd.hAdd x.arg y.arg)\n‚ä¢ Eq (Complex.log (HMul.hMul x y)) (HAdd.hAdd (Complex.log x) (Complex.log y))","decl":"alias ‚ü®_, log_mul‚ü© := log_mul_eq_add_log_iff\n\n"}
{"name":"Complex.log_zero","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"‚ä¢ Eq (Complex.log 0) 0","decl":"@[simp]\ntheorem log_zero : log 0 = 0 := by simp [log]\n\n"}
{"name":"Complex.log_one","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"‚ä¢ Eq (Complex.log 1) 0","decl":"@[simp]\ntheorem log_one : log 1 = 0 := by simp [log]\n\n"}
{"name":"Complex.log_div_self","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"x : Complex\n‚ä¢ Eq (Complex.log (HDiv.hDiv x x)) 0","decl":"/-- This holds true for all `x : ‚ÑÇ` because of the junk values `0 / 0 = 0` and `log 0 = 0`. -/\n@[simp] lemma log_div_self (x : ‚ÑÇ) : log (x / x) = 0 := by simp [log]\n\n"}
{"name":"Complex.log_neg_one","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"‚ä¢ Eq (Complex.log (-1)) (HMul.hMul (‚ÜëReal.pi) Complex.I)","decl":"theorem log_neg_one : log (-1) = œÄ * I := by simp [log]\n\n"}
{"name":"Complex.log_I","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"‚ä¢ Eq (Complex.log Complex.I) (HMul.hMul (HDiv.hDiv (‚ÜëReal.pi) 2) Complex.I)","decl":"theorem log_I : log I = œÄ / 2 * I := by simp [log]\n\n"}
{"name":"Complex.log_neg_I","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"‚ä¢ Eq (Complex.log (Neg.neg Complex.I)) (HMul.hMul (Neg.neg (HDiv.hDiv (‚ÜëReal.pi) 2)) Complex.I)","decl":"theorem log_neg_I : log (-I) = -(œÄ / 2) * I := by simp [log]\n\n"}
{"name":"Complex.log_conj_eq_ite","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"x : Complex\n‚ä¢ Eq (Complex.log ((starRingEnd Complex) x)) (ite (Eq x.arg Real.pi) (Complex.log x) ((starRingEnd Complex) (Complex.log x)))","decl":"theorem log_conj_eq_ite (x : ‚ÑÇ) : log (conj x) = if x.arg = œÄ then log x else conj (log x) := by\n  simp_rw [log, abs_conj, arg_conj, map_add, map_mul, conj_ofReal]\n  split_ifs with hx\n  ¬∑ rw [hx]\n  simp_rw [ofReal_neg, conj_I, mul_neg, neg_mul]\n\n"}
{"name":"Complex.log_conj","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"x : Complex\nh : Ne x.arg Real.pi\n‚ä¢ Eq (Complex.log ((starRingEnd Complex) x)) ((starRingEnd Complex) (Complex.log x))","decl":"theorem log_conj (x : ‚ÑÇ) (h : x.arg ‚â† œÄ) : log (conj x) = conj (log x) := by\n  rw [log_conj_eq_ite, if_neg h]\n\n"}
{"name":"Complex.log_inv_eq_ite","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"x : Complex\n‚ä¢ Eq (Complex.log (Inv.inv x)) (ite (Eq x.arg Real.pi) (Neg.neg ((starRingEnd Complex) (Complex.log x))) (Neg.neg (Complex.log x)))","decl":"theorem log_inv_eq_ite (x : ‚ÑÇ) : log x‚Åª¬π = if x.arg = œÄ then -conj (log x) else -log x := by\n  by_cases hx : x = 0\n  ¬∑ simp [hx]\n  rw [inv_def, log_mul_ofReal, Real.log_inv, ofReal_neg, ‚Üê sub_eq_neg_add, log_conj_eq_ite]\n  ¬∑ simp_rw [log, map_add, map_mul, conj_ofReal, conj_I, normSq_eq_abs, Real.log_pow,\n      Nat.cast_two, ofReal_mul, neg_add, mul_neg, neg_neg]\n    norm_num; rw [two_mul] -- Porting note: added to simplify `‚Üë2`\n    split_ifs\n    ¬∑ rw [add_sub_right_comm, sub_add_cancel_left]\n    ¬∑ rw [add_sub_right_comm, sub_add_cancel_left]\n  ¬∑ rwa [inv_pos, Complex.normSq_pos]\n  ¬∑ rwa [map_ne_zero]\n\n"}
{"name":"Complex.log_inv","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"x : Complex\nhx : Ne x.arg Real.pi\n‚ä¢ Eq (Complex.log (Inv.inv x)) (Neg.neg (Complex.log x))","decl":"theorem log_inv (x : ‚ÑÇ) (hx : x.arg ‚â† œÄ) : log x‚Åª¬π = -log x := by rw [log_inv_eq_ite, if_neg hx]\n\n"}
{"name":"Complex.two_pi_I_ne_zero","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"‚ä¢ Ne (HMul.hMul (HMul.hMul 2 ‚ÜëReal.pi) Complex.I) 0","decl":"theorem two_pi_I_ne_zero : (2 * œÄ * I : ‚ÑÇ) ‚â† 0 := by norm_num [Real.pi_ne_zero, I_ne_zero]\n\n"}
{"name":"Complex.exp_eq_one_iff","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"x : Complex\n‚ä¢ Iff (Eq (Complex.exp x) 1) (Exists fun n => Eq x (HMul.hMul (‚Üën) (HMul.hMul (HMul.hMul 2 ‚ÜëReal.pi) Complex.I)))","decl":"theorem exp_eq_one_iff {x : ‚ÑÇ} : exp x = 1 ‚Üî ‚àÉ n : ‚Ñ§, x = n * (2 * œÄ * I) := by\n  constructor\n  ¬∑ intro h\n    rcases existsUnique_add_zsmul_mem_Ioc Real.two_pi_pos x.im (-œÄ) with ‚ü®n, hn, -‚ü©\n    use -n\n    rw [Int.cast_neg, neg_mul, eq_neg_iff_add_eq_zero]\n    have : (x + n * (2 * œÄ * I)).im ‚àà Set.Ioc (-œÄ) œÄ := by simpa [two_mul, mul_add] using hn\n    rw [‚Üê log_exp this.1 this.2, exp_periodic.int_mul n, h, log_one]\n  ¬∑ rintro ‚ü®n, rfl‚ü©\n    exact (exp_periodic.int_mul n).eq.trans exp_zero\n\n"}
{"name":"Complex.exp_eq_exp_iff_exp_sub_eq_one","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"x y : Complex\n‚ä¢ Iff (Eq (Complex.exp x) (Complex.exp y)) (Eq (Complex.exp (HSub.hSub x y)) 1)","decl":"theorem exp_eq_exp_iff_exp_sub_eq_one {x y : ‚ÑÇ} : exp x = exp y ‚Üî exp (x - y) = 1 := by\n  rw [exp_sub, div_eq_one_iff_eq (exp_ne_zero _)]\n\n"}
{"name":"Complex.exp_eq_exp_iff_exists_int","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"x y : Complex\n‚ä¢ Iff (Eq (Complex.exp x) (Complex.exp y)) (Exists fun n => Eq x (HAdd.hAdd y (HMul.hMul (‚Üën) (HMul.hMul (HMul.hMul 2 ‚ÜëReal.pi) Complex.I))))","decl":"theorem exp_eq_exp_iff_exists_int {x y : ‚ÑÇ} : exp x = exp y ‚Üî ‚àÉ n : ‚Ñ§, x = y + n * (2 * œÄ * I) := by\n  simp only [exp_eq_exp_iff_exp_sub_eq_one, exp_eq_one_iff, sub_eq_iff_eq_add']\n\n"}
{"name":"Complex.log_exp_exists","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"z : Complex\n‚ä¢ Exists fun n => Eq (Complex.log (Complex.exp z)) (HAdd.hAdd z (HMul.hMul (‚Üën) (HMul.hMul (HMul.hMul 2 ‚ÜëReal.pi) Complex.I)))","decl":"theorem log_exp_exists (z : ‚ÑÇ) :\n    ‚àÉ n : ‚Ñ§, log (exp z) = z + n * (2 * œÄ * I) := by\n  rw [‚Üê exp_eq_exp_iff_exists_int, exp_log]\n  exact exp_ne_zero z\n\n"}
{"name":"Complex.countable_preimage_exp","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"s : Set Complex\n‚ä¢ Iff (Set.preimage Complex.exp s).Countable s.Countable","decl":"@[simp]\ntheorem countable_preimage_exp {s : Set ‚ÑÇ} : (exp ‚Åª¬π' s).Countable ‚Üî s.Countable := by\n  refine ‚ü®fun hs => ?_, fun hs => ?_‚ü©\n  ¬∑ refine ((hs.image exp).insert 0).mono ?_\n    rw [Set.image_preimage_eq_inter_range, range_exp, ‚Üê Set.diff_eq, ‚Üê Set.union_singleton,\n        Set.diff_union_self]\n    exact Set.subset_union_left\n  ¬∑ rw [‚Üê Set.biUnion_preimage_singleton]\n    refine hs.biUnion fun z hz => ?_\n    rcases em (‚àÉ w, exp w = z) with (‚ü®w, rfl‚ü© | hne)\n    ¬∑ simp only [Set.preimage, Set.mem_singleton_iff, exp_eq_exp_iff_exists_int, Set.setOf_exists]\n      exact Set.countable_iUnion fun m => Set.countable_singleton _\n    ¬∑ push_neg at hne\n      simp [Set.preimage, hne]\n\n"}
{"name":"Set.Countable.preimage_cexp","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"s : Set Complex\na‚úù : s.Countable\n‚ä¢ (Set.preimage Complex.exp s).Countable","decl":"alias ‚ü®_, _root_.Set.Countable.preimage_cexp‚ü© := countable_preimage_exp\n\n"}
{"name":"Complex.tendsto_log_nhdsWithin_im_neg_of_re_neg_of_im_zero","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"z : Complex\nhre : LT.lt z.re 0\nhim : Eq z.im 0\n‚ä¢ Filter.Tendsto Complex.log (nhdsWithin z (setOf fun z => LT.lt z.im 0)) (nhds (HSub.hSub (‚Üë(Real.log (Complex.abs z))) (HMul.hMul (‚ÜëReal.pi) Complex.I)))","decl":"theorem tendsto_log_nhdsWithin_im_neg_of_re_neg_of_im_zero {z : ‚ÑÇ} (hre : z.re < 0)\n    (him : z.im = 0) : Tendsto log (ùìù[{ z : ‚ÑÇ | z.im < 0 }] z) (ùìù <| Real.log (abs z) - œÄ * I) := by\n  convert\n    (continuous_ofReal.continuousAt.comp_continuousWithinAt\n            (continuous_abs.continuousWithinAt.log _)).tendsto.add\n      (((continuous_ofReal.tendsto _).comp <|\n            tendsto_arg_nhdsWithin_im_neg_of_re_neg_of_im_zero hre him).mul\n        tendsto_const_nhds) using 1\n  ¬∑ simp [sub_eq_add_neg]\n  ¬∑ lift z to ‚Ñù using him\n    simpa using hre.ne\n\n"}
{"name":"Complex.continuousWithinAt_log_of_re_neg_of_im_zero","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"z : Complex\nhre : LT.lt z.re 0\nhim : Eq z.im 0\n‚ä¢ ContinuousWithinAt Complex.log (setOf fun z => LE.le 0 z.im) z","decl":"theorem continuousWithinAt_log_of_re_neg_of_im_zero {z : ‚ÑÇ} (hre : z.re < 0) (him : z.im = 0) :\n    ContinuousWithinAt log { z : ‚ÑÇ | 0 ‚â§ z.im } z := by\n  convert\n    (continuous_ofReal.continuousAt.comp_continuousWithinAt\n            (continuous_abs.continuousWithinAt.log _)).tendsto.add\n      ((continuous_ofReal.continuousAt.comp_continuousWithinAt <|\n            continuousWithinAt_arg_of_re_neg_of_im_zero hre him).mul\n        tendsto_const_nhds) using 1\n  lift z to ‚Ñù using him\n  simpa using hre.ne\n\n"}
{"name":"Complex.tendsto_log_nhdsWithin_im_nonneg_of_re_neg_of_im_zero","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"z : Complex\nhre : LT.lt z.re 0\nhim : Eq z.im 0\n‚ä¢ Filter.Tendsto Complex.log (nhdsWithin z (setOf fun z => LE.le 0 z.im)) (nhds (HAdd.hAdd (‚Üë(Real.log (Complex.abs z))) (HMul.hMul (‚ÜëReal.pi) Complex.I)))","decl":"theorem tendsto_log_nhdsWithin_im_nonneg_of_re_neg_of_im_zero {z : ‚ÑÇ} (hre : z.re < 0)\n    (him : z.im = 0) : Tendsto log (ùìù[{ z : ‚ÑÇ | 0 ‚â§ z.im }] z) (ùìù <| Real.log (abs z) + œÄ * I) := by\n  simpa only [log, arg_eq_pi_iff.2 ‚ü®hre, him‚ü©] using\n    (continuousWithinAt_log_of_re_neg_of_im_zero hre him).tendsto\n\n"}
{"name":"Complex.map_exp_comap_re_atBot","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"‚ä¢ Eq (Filter.map Complex.exp (Filter.comap Complex.re Filter.atBot)) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0)))","decl":"@[simp]\ntheorem map_exp_comap_re_atBot : map exp (comap re atBot) = ùìù[‚â†] 0 := by\n  rw [‚Üê comap_exp_nhds_zero, map_comap, range_exp, nhdsWithin]\n\n"}
{"name":"Complex.map_exp_comap_re_atTop","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"‚ä¢ Eq (Filter.map Complex.exp (Filter.comap Complex.re Filter.atTop)) (Bornology.cobounded Complex)","decl":"@[simp]\ntheorem map_exp_comap_re_atTop : map exp (comap re atTop) = cobounded ‚ÑÇ := by\n  rw [‚Üê comap_exp_cobounded, map_comap, range_exp, inf_eq_left, le_principal_iff]\n  exact eventually_ne_cobounded _\n\n"}
{"name":"continuousAt_clog","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"x : Complex\nh : Membership.mem Complex.slitPlane x\n‚ä¢ ContinuousAt Complex.log x","decl":"theorem continuousAt_clog {x : ‚ÑÇ} (h : x ‚àà slitPlane) : ContinuousAt log x := by\n  refine ContinuousAt.add ?_ ?_\n  ¬∑ refine continuous_ofReal.continuousAt.comp ?_\n    refine (Real.continuousAt_log ?_).comp Complex.continuous_abs.continuousAt\n    exact Complex.abs.ne_zero_iff.mpr <| slitPlane_ne_zero h\n  ¬∑ have h_cont_mul : Continuous fun x : ‚ÑÇ => x * I := continuous_id'.mul continuous_const\n    refine h_cont_mul.continuousAt.comp (continuous_ofReal.continuousAt.comp ?_)\n    exact continuousAt_arg h\n\n"}
{"name":"Filter.Tendsto.clog","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"Œ± : Type u_1\nl : Filter Œ±\nf : Œ± ‚Üí Complex\nx : Complex\nh : Filter.Tendsto f l (nhds x)\nhx : Membership.mem Complex.slitPlane x\n‚ä¢ Filter.Tendsto (fun t => Complex.log (f t)) l (nhds (Complex.log x))","decl":"theorem _root_.Filter.Tendsto.clog {l : Filter Œ±} {f : Œ± ‚Üí ‚ÑÇ} {x : ‚ÑÇ} (h : Tendsto f l (ùìù x))\n    (hx : x ‚àà slitPlane) : Tendsto (fun t => log (f t)) l (ùìù <| log x) :=\n  (continuousAt_clog hx).tendsto.comp h\n\n"}
{"name":"ContinuousAt.clog","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Complex\nx : Œ±\nh‚ÇÅ : ContinuousAt f x\nh‚ÇÇ : Membership.mem Complex.slitPlane (f x)\n‚ä¢ ContinuousAt (fun t => Complex.log (f t)) x","decl":"nonrec\ntheorem _root_.ContinuousAt.clog {f : Œ± ‚Üí ‚ÑÇ} {x : Œ±} (h‚ÇÅ : ContinuousAt f x)\n    (h‚ÇÇ : f x ‚àà slitPlane) : ContinuousAt (fun t => log (f t)) x :=\n  h‚ÇÅ.clog h‚ÇÇ\n\n"}
{"name":"ContinuousWithinAt.clog","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Complex\ns : Set Œ±\nx : Œ±\nh‚ÇÅ : ContinuousWithinAt f s x\nh‚ÇÇ : Membership.mem Complex.slitPlane (f x)\n‚ä¢ ContinuousWithinAt (fun t => Complex.log (f t)) s x","decl":"nonrec\ntheorem _root_.ContinuousWithinAt.clog {f : Œ± ‚Üí ‚ÑÇ} {s : Set Œ±} {x : Œ±}\n    (h‚ÇÅ : ContinuousWithinAt f s x) (h‚ÇÇ : f x ‚àà slitPlane) :\n    ContinuousWithinAt (fun t => log (f t)) s x :=\n  h‚ÇÅ.clog h‚ÇÇ\n\n"}
{"name":"ContinuousOn.clog","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Complex\ns : Set Œ±\nh‚ÇÅ : ContinuousOn f s\nh‚ÇÇ : ‚àÄ (x : Œ±), Membership.mem s x ‚Üí Membership.mem Complex.slitPlane (f x)\n‚ä¢ ContinuousOn (fun t => Complex.log (f t)) s","decl":"nonrec\ntheorem _root_.ContinuousOn.clog {f : Œ± ‚Üí ‚ÑÇ} {s : Set Œ±} (h‚ÇÅ : ContinuousOn f s)\n    (h‚ÇÇ : ‚àÄ x ‚àà s, f x ‚àà slitPlane) : ContinuousOn (fun t => log (f t)) s := fun x hx =>\n  (h‚ÇÅ x hx).clog (h‚ÇÇ x hx)\n\n"}
{"name":"Continuous.clog","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Complex\nh‚ÇÅ : Continuous f\nh‚ÇÇ : ‚àÄ (x : Œ±), Membership.mem Complex.slitPlane (f x)\n‚ä¢ Continuous fun t => Complex.log (f t)","decl":"nonrec\ntheorem _root_.Continuous.clog {f : Œ± ‚Üí ‚ÑÇ} (h‚ÇÅ : Continuous f)\n    (h‚ÇÇ : ‚àÄ x, f x ‚àà slitPlane) : Continuous fun t => log (f t) :=\n  continuous_iff_continuousAt.2 fun x => h‚ÇÅ.continuousAt.clog (h‚ÇÇ x)\n\n"}
{"name":"Real.hasProd_of_hasSum_log","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"Œπ : Type u_2\nf : Œπ ‚Üí Real\nhfn : ‚àÄ (n : Œπ), LT.lt 0 (f n)\na : Real\nhf : HasSum (fun n => Real.log (f n)) a\n‚ä¢ HasProd f (Real.exp a)","decl":"lemma Real.hasProd_of_hasSum_log {f : Œπ ‚Üí ‚Ñù} (hfn : ‚àÄ n, 0 < f n) {a : ‚Ñù}\n    (hf : HasSum (fun n => log (f n)) a) : HasProd f (rexp a) :=\n  hf.rexp.congr (by simp [exp_log, hfn])\n\n"}
{"name":"Real.multipliable_of_summable_log","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"Œπ : Type u_2\nf : Œπ ‚Üí Real\nhfn : ‚àÄ (n : Œπ), LT.lt 0 (f n)\nhf : Summable fun n => Real.log (f n)\n‚ä¢ Multipliable f","decl":"lemma Real.multipliable_of_summable_log (f : Œπ ‚Üí ‚Ñù) (hfn : ‚àÄ n, 0 < f n)\n    (hf : Summable fun n => log (f n)) : Multipliable f :=\n  ‚ü®_, Real.hasProd_of_hasSum_log hfn hf.hasSum‚ü©\n\n"}
{"name":"Real.rexp_tsum_eq_tprod","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"Œπ : Type u_2\nf : Œπ ‚Üí Real\nhfn : ‚àÄ (n : Œπ), LT.lt 0 (f n)\nhf : Summable fun n => Real.log (f n)\n‚ä¢ Eq (Real.exp (tsum fun n => Real.log (f n))) (tprod fun n => f n)","decl":"/-- The exponential of a infinite sum of real logs (which converges absolutely) is an infinite\nproduct. -/\nlemma Real.rexp_tsum_eq_tprod (f : Œπ ‚Üí ‚Ñù) (hfn : ‚àÄ n, 0 < f n)\n    (hf : Summable fun n => log (f n)) : rexp (‚àë' n : Œπ, log (f n)) = ‚àè' n : Œπ, f n :=\n  (Real.hasProd_of_hasSum_log hfn hf.hasSum).tprod_eq.symm\n\n"}
{"name":"Complex.hasProd_of_hasSum_log","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"Œπ : Type u_2\nf : Œπ ‚Üí Complex\nhfn : ‚àÄ (n : Œπ), Ne (f n) 0\na : Complex\nhf : HasSum (fun n => Complex.log (f n)) a\n‚ä¢ HasProd (fun b => f b) (Complex.exp a)","decl":"lemma Complex.hasProd_of_hasSum_log (f : Œπ ‚Üí ‚ÑÇ) (hfn : ‚àÄ n, f n ‚â† 0) {a : ‚ÑÇ}\n    (hf : HasSum (fun n => log (f n)) a) : HasProd (fun b ‚Ü¶ f b) (cexp a) :=\n    hf.cexp.congr (by simp [exp_log, hfn])\n\n"}
{"name":"Complex.multipliable_of_summable_log","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"Œπ : Type u_2\nf : Œπ ‚Üí Complex\nhfn : ‚àÄ (n : Œπ), Ne (f n) 0\nhf : Summable fun n => Complex.log (f n)\n‚ä¢ Multipliable fun b => f b","decl":"lemma Complex.multipliable_of_summable_log (f : Œπ ‚Üí ‚ÑÇ) (hfn : ‚àÄ n, f n ‚â† 0)\n    (hf : Summable fun n => log (f n)) : Multipliable fun b ‚Ü¶ f b  :=\n   ‚ü®_, Complex.hasProd_of_hasSum_log _ hfn hf.hasSum‚ü©\n\n"}
{"name":"Complex.cexp_tsum_eq_tprod","module":"Mathlib.Analysis.SpecialFunctions.Complex.Log","initialProofState":"Œπ : Type u_2\nf : Œπ ‚Üí Complex\nhfn : ‚àÄ (n : Œπ), Ne (f n) 0\nhf : Summable fun n => Complex.log (f n)\n‚ä¢ Eq (Complex.exp (tsum fun n => Complex.log (f n))) (tprod fun n => f n)","decl":"/--The exponential of a infinite sum of comples logs (which converges absolutely) is an infinite\nproduct.-/\nlemma Complex.cexp_tsum_eq_tprod (f : Œπ ‚Üí  ‚ÑÇ) (hfn : ‚àÄ n, f n ‚â† 0)\n    (hf : Summable fun n => log (f n)) : (cexp ((‚àë' n : Œπ, log (f n )))) = ‚àè' n : Œπ, f n  :=\n  (Complex.hasProd_of_hasSum_log _ hfn hf.hasSum).tprod_eq.symm\n\n"}
