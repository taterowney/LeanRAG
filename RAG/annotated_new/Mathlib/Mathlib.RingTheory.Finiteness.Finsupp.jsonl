{"name":"Submodule.fg_of_fg_map_of_fg_inf_ker","module":"Mathlib.RingTheory.Finiteness.Finsupp","initialProofState":"R : Type u_4\nM : Type u_5\nP : Type u_6\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup P\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M P\ns : Submodule R M\nhs1 : (Submodule.map f s).FG\nhs2 : (Min.min s (LinearMap.ker f)).FG\n⊢ s.FG","decl":"/-- If 0 → M' → M → M'' → 0 is exact and M' and M'' are\nfinitely generated then so is M. -/\ntheorem fg_of_fg_map_of_fg_inf_ker {R M P : Type*} [Ring R] [AddCommGroup M] [Module R M]\n    [AddCommGroup P] [Module R P] (f : M →ₗ[R] P) {s : Submodule R M}\n    (hs1 : (s.map f).FG)\n    (hs2 : (s ⊓ LinearMap.ker f).FG) : s.FG := by\n  haveI := Classical.decEq R\n  haveI := Classical.decEq M\n  haveI := Classical.decEq P\n  cases' hs1 with t1 ht1\n  cases' hs2 with t2 ht2\n  have : ∀ y ∈ t1, ∃ x ∈ s, f x = y := by\n    intro y hy\n    have : y ∈ s.map f := by\n      rw [← ht1]\n      exact subset_span hy\n    rcases mem_map.1 this with ⟨x, hx1, hx2⟩\n    exact ⟨x, hx1, hx2⟩\n  have : ∃ g : P → M, ∀ y ∈ t1, g y ∈ s ∧ f (g y) = y := by\n    choose g hg1 hg2 using this\n    exists fun y => if H : y ∈ t1 then g y H else 0\n    intro y H\n    constructor\n    · simp only [dif_pos H]\n      apply hg1\n    · simp only [dif_pos H]\n      apply hg2\n  cases' this with g hg\n  clear this\n  exists t1.image g ∪ t2\n  rw [Finset.coe_union, span_union, Finset.coe_image]\n  apply le_antisymm\n  · refine sup_le (span_le.2 <| image_subset_iff.2 ?_) (span_le.2 ?_)\n    · intro y hy\n      exact (hg y hy).1\n    · intro x hx\n      have : x ∈ span R t2 := subset_span hx\n      rw [ht2] at this\n      exact this.1\n  intro x hx\n  have : f x ∈ s.map f := by\n    rw [mem_map]\n    exact ⟨x, hx, rfl⟩\n  rw [← ht1, ← Set.image_id (t1 : Set P), Finsupp.mem_span_image_iff_linearCombination] at this\n  rcases this with ⟨l, hl1, hl2⟩\n  refine\n    mem_sup.2\n      ⟨(linearCombination R id).toFun ((lmapDomain R R g : (P →₀ R) → M →₀ R) l), ?_,\n        x - linearCombination R id ((lmapDomain R R g : (P →₀ R) → M →₀ R) l), ?_,\n        add_sub_cancel _ _⟩\n  · rw [← Set.image_id (g '' ↑t1), Finsupp.mem_span_image_iff_linearCombination]\n    refine ⟨_, ?_, rfl⟩\n    haveI : Inhabited P := ⟨0⟩\n    rw [← Finsupp.lmapDomain_supported _ _ g, mem_map]\n    refine ⟨l, hl1, ?_⟩\n    rfl\n  rw [ht2, mem_inf]\n  constructor\n  · apply s.sub_mem hx\n    rw [Finsupp.linearCombination_apply, Finsupp.lmapDomain_apply, Finsupp.sum_mapDomain_index]\n    · refine s.sum_mem ?_\n      intro y hy\n      exact s.smul_mem _ (hg y (hl1 hy)).1\n    · exact zero_smul _\n    · exact fun _ _ _ => add_smul _ _ _\n  · rw [LinearMap.mem_ker, f.map_sub, ← hl2]\n    rw [Finsupp.linearCombination_apply, Finsupp.linearCombination_apply, Finsupp.lmapDomain_apply]\n    rw [Finsupp.sum_mapDomain_index, Finsupp.sum, Finsupp.sum, map_sum]\n    · rw [sub_eq_zero]\n      refine Finset.sum_congr rfl fun y hy => ?_\n      unfold id\n      rw [f.map_smul, (hg y (hl1 hy)).2]\n    · exact zero_smul _\n    · exact fun _ _ _ => add_smul _ _ _\n\n"}
{"name":"Submodule.fg_ker_comp","module":"Mathlib.RingTheory.Finiteness.Finsupp","initialProofState":"R : Type u_4\nM : Type u_5\nN : Type u_6\nP : Type u_7\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : AddCommGroup P\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nhf1 : (LinearMap.ker f).FG\nhf2 : (LinearMap.ker g).FG\nhsur : Function.Surjective ⇑f\n⊢ (LinearMap.ker (g.comp f)).FG","decl":"/-- The kernel of the composition of two linear maps is finitely generated if both kernels are and\nthe first morphism is surjective. -/\ntheorem fg_ker_comp {R M N P : Type*} [Ring R] [AddCommGroup M] [Module R M] [AddCommGroup N]\n    [Module R N] [AddCommGroup P] [Module R P] (f : M →ₗ[R] N) (g : N →ₗ[R] P)\n    (hf1 : (LinearMap.ker f).FG) (hf2 : (LinearMap.ker g).FG)\n    (hsur : Function.Surjective f) : (g.comp f).ker.FG := by\n  rw [LinearMap.ker_comp]\n  apply fg_of_fg_map_of_fg_inf_ker f\n  · rwa [Submodule.map_comap_eq, LinearMap.range_eq_top.2 hsur, top_inf_eq]\n  · rwa [inf_of_le_right (show (LinearMap.ker f) ≤\n      (LinearMap.ker g).comap f from comap_mono bot_le)]\n\n"}
{"name":"Module.Finite.finsupp","module":"Mathlib.RingTheory.Finiteness.Finsupp","initialProofState":"R : Type u_2\nV : Type u_3\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup V\ninst✝² : Module R V\nι : Type u_1\ninst✝¹ : Finite ι\ninst✝ : Module.Finite R V\n⊢ Module.Finite R (Finsupp ι V)","decl":"instance Module.Finite.finsupp {ι : Type*} [_root_.Finite ι] [Module.Finite R V] :\n    Module.Finite R (ι →₀ V) :=\n  Module.Finite.equiv (Finsupp.linearEquivFunOnFinite R V ι).symm\n\n"}
