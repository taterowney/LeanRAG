{"name":"Matrix.ext_iff","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM N : Matrix m n α\n⊢ Iff (∀ (i : m) (j : n), Eq (M i j) (N i j)) (Eq M N)","decl":"theorem ext_iff : (∀ i j, M i j = N i j) ↔ M = N :=\n  ⟨fun h => funext fun i => funext <| h i, fun h => by simp [h]⟩\n\n"}
{"name":"Matrix.ext","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM N : Matrix m n α\na✝ : ∀ (i : m) (j : n), Eq (M i j) (N i j)\n⊢ Eq M N","decl":"@[ext]\ntheorem ext : (∀ i j, M i j = N i j) → M = N :=\n  ext_iff.mp\n\n"}
{"name":"Matrix.of_apply","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nf : m → n → α\ni : m\nj : n\n⊢ Eq (Matrix.of f i j) (f i j)","decl":"@[simp]\ntheorem of_apply (f : m → n → α) (i j) : of f i j = f i j :=\n  rfl\n\n"}
{"name":"Matrix.of_symm_apply","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nf : Matrix m n α\ni : m\nj : n\n⊢ Eq (Matrix.of.symm f i j) (f i j)","decl":"@[simp]\ntheorem of_symm_apply (f : Matrix m n α) (i j) : of.symm f i j = f i j :=\n  rfl\n\n"}
{"name":"Matrix.map_apply","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\nM : Matrix m n α\nf : α → β\ni : m\nj : n\n⊢ Eq (M.map f i j) (f (M i j))","decl":"@[simp]\ntheorem map_apply {M : Matrix m n α} {f : α → β} {i : m} {j : n} : M.map f i j = f (M i j) :=\n  rfl\n\n"}
{"name":"Matrix.map_id","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM : Matrix m n α\n⊢ Eq (M.map id) M","decl":"@[simp]\ntheorem map_id (M : Matrix m n α) : M.map id = M := by\n  ext\n  rfl\n\n"}
{"name":"Matrix.map_id'","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM : Matrix m n α\n⊢ Eq (M.map fun x => x) M","decl":"@[simp]\ntheorem map_id' (M : Matrix m n α) : M.map (·) = M := map_id M\n\n"}
{"name":"Matrix.map_map","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM : Matrix m n α\nβ : Type u_10\nγ : Type u_11\nf : α → β\ng : β → γ\n⊢ Eq ((M.map f).map g) (M.map (Function.comp g f))","decl":"@[simp]\ntheorem map_map {M : Matrix m n α} {β γ : Type*} {f : α → β} {g : β → γ} :\n    (M.map f).map g = M.map (g ∘ f) := by\n  ext\n  rfl\n\n"}
{"name":"Matrix.map_injective","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\nf : α → β\nhf : Function.Injective f\n⊢ Function.Injective fun M => M.map f","decl":"theorem map_injective {f : α → β} (hf : Function.Injective f) :\n    Function.Injective fun M : Matrix m n α => M.map f := fun _ _ h =>\n  ext fun i j => hf <| ext_iff.mpr h i j\n\n"}
{"name":"Matrix.transpose_apply","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM : Matrix m n α\ni : n\nj : m\n⊢ Eq (M.transpose i j) (M j i)","decl":"@[simp]\ntheorem transpose_apply (M : Matrix m n α) (i j) : transpose M i j = M j i :=\n  rfl\n\n"}
{"name":"Matrix.subsingleton","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Subsingleton α\n⊢ Subsingleton (Matrix m n α)","decl":"instance subsingleton [Subsingleton α] : Subsingleton (Matrix m n α) :=\n  inferInstanceAs <| Subsingleton <| m → n → α\n\n"}
{"name":"Matrix.nonempty","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝² : Nonempty m\ninst✝¹ : Nonempty n\ninst✝ : Nontrivial α\n⊢ Nontrivial (Matrix m n α)","decl":"instance nonempty [Nonempty m] [Nonempty n] [Nontrivial α] : Nontrivial (Matrix m n α) :=\n  Function.nontrivial\n\n"}
{"name":"Matrix.smulCommClass","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nS : Type u_8\nα : Type v\ninst✝² : SMul R α\ninst✝¹ : SMul S α\ninst✝ : SMulCommClass R S α\n⊢ SMulCommClass R S (Matrix m n α)","decl":"instance smulCommClass [SMul R α] [SMul S α] [SMulCommClass R S α] :\n    SMulCommClass R S (Matrix m n α) :=\n  Pi.smulCommClass\n\n"}
{"name":"Matrix.isScalarTower","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nS : Type u_8\nα : Type v\ninst✝³ : SMul R S\ninst✝² : SMul R α\ninst✝¹ : SMul S α\ninst✝ : IsScalarTower R S α\n⊢ IsScalarTower R S (Matrix m n α)","decl":"instance isScalarTower [SMul R S] [SMul R α] [SMul S α] [IsScalarTower R S α] :\n    IsScalarTower R S (Matrix m n α) :=\n  Pi.isScalarTower\n\n"}
{"name":"Matrix.isCentralScalar","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝² : SMul R α\ninst✝¹ : SMul (MulOpposite R) α\ninst✝ : IsCentralScalar R α\n⊢ IsCentralScalar R (Matrix m n α)","decl":"instance isCentralScalar [SMul R α] [SMul Rᵐᵒᵖ α] [IsCentralScalar R α] :\n    IsCentralScalar R (Matrix m n α) :=\n  Pi.isCentralScalar\n\n"}
{"name":"Matrix.zero_apply","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Zero α\ni : m\nj : n\n⊢ Eq (0 i j) 0","decl":"@[simp]\ntheorem zero_apply [Zero α] (i : m) (j : n) : (0 : Matrix m n α) i j = 0 := rfl\n\n"}
{"name":"Matrix.add_apply","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Add α\nA B : Matrix m n α\ni : m\nj : n\n⊢ Eq (HAdd.hAdd A B i j) (HAdd.hAdd (A i j) (B i j))","decl":"@[simp]\ntheorem add_apply [Add α] (A B : Matrix m n α) (i : m) (j : n) :\n    (A + B) i j = (A i j) + (B i j) := rfl\n\n"}
{"name":"Matrix.smul_apply","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\ninst✝ : SMul β α\nr : β\nA : Matrix m n α\ni : m\nj : n\n⊢ Eq (HSMul.hSMul r A i j) (HSMul.hSMul r (A i j))","decl":"@[simp]\ntheorem smul_apply [SMul β α] (r : β) (A : Matrix m n α) (i : m) (j : n) :\n    (r • A) i j = r • (A i j) := rfl\n\n"}
{"name":"Matrix.sub_apply","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Sub α\nA B : Matrix m n α\ni : m\nj : n\n⊢ Eq (HSub.hSub A B i j) (HSub.hSub (A i j) (B i j))","decl":"@[simp]\ntheorem sub_apply [Sub α] (A B : Matrix m n α) (i : m) (j : n) :\n    (A - B) i j = (A i j) - (B i j) := rfl\n\n"}
{"name":"Matrix.neg_apply","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Neg α\nA : Matrix m n α\ni : m\nj : n\n⊢ Eq (Neg.neg A i j) (Neg.neg (A i j))","decl":"@[simp]\ntheorem neg_apply [Neg α] (A : Matrix m n α) (i : m) (j : n) :\n    (-A) i j = -(A i j) := rfl\n\n"}
{"name":"Matrix.dite_apply","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nP : Prop\ninst✝ : Decidable P\nA : P → Matrix m n α\nB : Not P → Matrix m n α\ni : m\nj : n\n⊢ Eq (dite P A B i j) (dite P (fun x => A x i j) fun x => B x i j)","decl":"protected theorem dite_apply (P : Prop) [Decidable P]\n    (A : P → Matrix m n α) (B : ¬P → Matrix m n α) (i : m) (j : n) :\n    dite P A B i j = dite P (A · i j) (B · i j) := by\n  rw [dite_apply, dite_apply]\n\n"}
{"name":"Matrix.ite_apply","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nP : Prop\ninst✝ : Decidable P\nA B : Matrix m n α\ni : m\nj : n\n⊢ Eq (ite P A B i j) (ite P (A i j) (B i j))","decl":"protected theorem ite_apply (P : Prop) [Decidable P]\n    (A : Matrix m n α) (B : Matrix m n α) (i : m) (j : n) :\n    (if P then A else B) i j = if P then A i j else B i j :=\n  Matrix.dite_apply _ _ _ _ _\n\n"}
{"name":"Matrix.of_zero","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Zero α\n⊢ Eq (Matrix.of 0) 0","decl":"@[simp]\ntheorem of_zero [Zero α] : of (0 : m → n → α) = 0 :=\n  rfl\n\n"}
{"name":"Matrix.of_add_of","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Add α\nf g : m → n → α\n⊢ Eq (HAdd.hAdd (Matrix.of f) (Matrix.of g)) (Matrix.of (HAdd.hAdd f g))","decl":"@[simp]\ntheorem of_add_of [Add α] (f g : m → n → α) : of f + of g = of (f + g) :=\n  rfl\n\n"}
{"name":"Matrix.of_sub_of","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Sub α\nf g : m → n → α\n⊢ Eq (HSub.hSub (Matrix.of f) (Matrix.of g)) (Matrix.of (HSub.hSub f g))","decl":"@[simp]\ntheorem of_sub_of [Sub α] (f g : m → n → α) : of f - of g = of (f - g) :=\n  rfl\n\n"}
{"name":"Matrix.neg_of","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Neg α\nf : m → n → α\n⊢ Eq (Neg.neg (Matrix.of f)) (Matrix.of (Neg.neg f))","decl":"@[simp]\ntheorem neg_of [Neg α] (f : m → n → α) : -of f = of (-f) :=\n  rfl\n\n"}
{"name":"Matrix.smul_of","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\ninst✝ : SMul R α\nr : R\nf : m → n → α\n⊢ Eq (HSMul.hSMul r (Matrix.of f)) (Matrix.of (HSMul.hSMul r f))","decl":"@[simp]\ntheorem smul_of [SMul R α] (r : R) (f : m → n → α) : r • of f = of (r • f) :=\n  rfl\n\n"}
{"name":"Matrix.map_zero","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\ninst✝¹ : Zero α\ninst✝ : Zero β\nf : α → β\nh : Eq (f 0) 0\n⊢ Eq (Matrix.map 0 f) 0","decl":"@[simp]\nprotected theorem map_zero [Zero α] [Zero β] (f : α → β) (h : f 0 = 0) :\n    (0 : Matrix m n α).map f = 0 := by\n  ext\n  simp [h]\n\n"}
{"name":"Matrix.map_add","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\ninst✝¹ : Add α\ninst✝ : Add β\nf : α → β\nhf : ∀ (a₁ a₂ : α), Eq (f (HAdd.hAdd a₁ a₂)) (HAdd.hAdd (f a₁) (f a₂))\nM N : Matrix m n α\n⊢ Eq ((HAdd.hAdd M N).map f) (HAdd.hAdd (M.map f) (N.map f))","decl":"protected theorem map_add [Add α] [Add β] (f : α → β) (hf : ∀ a₁ a₂, f (a₁ + a₂) = f a₁ + f a₂)\n    (M N : Matrix m n α) : (M + N).map f = M.map f + N.map f :=\n  ext fun _ _ => hf _ _\n\n"}
{"name":"Matrix.map_sub","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\ninst✝¹ : Sub α\ninst✝ : Sub β\nf : α → β\nhf : ∀ (a₁ a₂ : α), Eq (f (HSub.hSub a₁ a₂)) (HSub.hSub (f a₁) (f a₂))\nM N : Matrix m n α\n⊢ Eq ((HSub.hSub M N).map f) (HSub.hSub (M.map f) (N.map f))","decl":"protected theorem map_sub [Sub α] [Sub β] (f : α → β) (hf : ∀ a₁ a₂, f (a₁ - a₂) = f a₁ - f a₂)\n    (M N : Matrix m n α) : (M - N).map f = M.map f - N.map f :=\n  ext fun _ _ => hf _ _\n\n"}
{"name":"Matrix.map_smul","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nα : Type v\nβ : Type w\ninst✝¹ : SMul R α\ninst✝ : SMul R β\nf : α → β\nr : R\nhf : ∀ (a : α), Eq (f (HSMul.hSMul r a)) (HSMul.hSMul r (f a))\nM : Matrix m n α\n⊢ Eq ((HSMul.hSMul r M).map f) (HSMul.hSMul r (M.map f))","decl":"theorem map_smul [SMul R α] [SMul R β] (f : α → β) (r : R) (hf : ∀ a, f (r • a) = r • f a)\n    (M : Matrix m n α) : (r • M).map f = r • M.map f :=\n  ext fun _ _ => hf _\n\n"}
{"name":"Matrix.map_smul'","module":"Mathlib.Data.Matrix.Defs","initialProofState":"n : Type u_3\nα : Type v\nβ : Type w\ninst✝¹ : Mul α\ninst✝ : Mul β\nf : α → β\nr : α\nA : Matrix n n α\nhf : ∀ (a₁ a₂ : α), Eq (f (HMul.hMul a₁ a₂)) (HMul.hMul (f a₁) (f a₂))\n⊢ Eq ((HSMul.hSMul r A).map f) (HSMul.hSMul (f r) (A.map f))","decl":"/-- The scalar action via `Mul.toSMul` is transformed by the same map as the elements\nof the matrix, when `f` preserves multiplication. -/\ntheorem map_smul' [Mul α] [Mul β] (f : α → β) (r : α) (A : Matrix n n α)\n    (hf : ∀ a₁ a₂, f (a₁ * a₂) = f a₁ * f a₂) : (r • A).map f = f r • A.map f :=\n  ext fun _ _ => hf _ _\n\n"}
{"name":"Matrix.map_op_smul'","module":"Mathlib.Data.Matrix.Defs","initialProofState":"n : Type u_3\nα : Type v\nβ : Type w\ninst✝¹ : Mul α\ninst✝ : Mul β\nf : α → β\nr : α\nA : Matrix n n α\nhf : ∀ (a₁ a₂ : α), Eq (f (HMul.hMul a₁ a₂)) (HMul.hMul (f a₁) (f a₂))\n⊢ Eq ((HSMul.hSMul (MulOpposite.op r) A).map f) (HSMul.hSMul (MulOpposite.op (f r)) (A.map f))","decl":"/-- The scalar action via `mul.toOppositeSMul` is transformed by the same map as the\nelements of the matrix, when `f` preserves multiplication. -/\ntheorem map_op_smul' [Mul α] [Mul β] (f : α → β) (r : α) (A : Matrix n n α)\n    (hf : ∀ a₁ a₂, f (a₁ * a₂) = f a₁ * f a₂) :\n    (MulOpposite.op r • A).map f = MulOpposite.op (f r) • A.map f :=\n  ext fun _ _ => hf _ _\n\n"}
{"name":"IsSMulRegular.matrix","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nR : Type u_7\nS : Type u_8\ninst✝ : SMul R S\nk : R\nhk : IsSMulRegular S k\n⊢ IsSMulRegular (Matrix m n S) k","decl":"theorem _root_.IsSMulRegular.matrix [SMul R S] {k : R} (hk : IsSMulRegular S k) :\n    IsSMulRegular (Matrix m n S) k :=\n  IsSMulRegular.pi fun _ => IsSMulRegular.pi fun _ => hk\n\n"}
{"name":"IsLeftRegular.matrix","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Mul α\nk : α\nhk : IsLeftRegular k\n⊢ IsSMulRegular (Matrix m n α) k","decl":"theorem _root_.IsLeftRegular.matrix [Mul α] {k : α} (hk : IsLeftRegular k) :\n    IsSMulRegular (Matrix m n α) k :=\n  hk.isSMulRegular.matrix\n\n"}
{"name":"Matrix.subsingleton_of_empty_left","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : IsEmpty m\n⊢ Subsingleton (Matrix m n α)","decl":"instance subsingleton_of_empty_left [IsEmpty m] : Subsingleton (Matrix m n α) :=\n  ⟨fun M N => by\n    ext i\n    exact isEmptyElim i⟩\n\n"}
{"name":"Matrix.subsingleton_of_empty_right","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : IsEmpty n\n⊢ Subsingleton (Matrix m n α)","decl":"instance subsingleton_of_empty_right [IsEmpty n] : Subsingleton (Matrix m n α) :=\n  ⟨fun M N => by\n    ext i j\n    exact isEmptyElim j⟩\n\n"}
{"name":"Matrix.coe_ofAddEquiv","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Add α\n⊢ Eq ⇑Matrix.ofAddEquiv ⇑Matrix.of","decl":"@[simp] lemma coe_ofAddEquiv [Add α] :\n    ⇑(ofAddEquiv : (m → n → α) ≃+ Matrix m n α) = of := rfl\n"}
{"name":"Matrix.coe_ofAddEquiv_symm","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Add α\n⊢ Eq ⇑Matrix.ofAddEquiv.symm ⇑Matrix.of.symm","decl":"@[simp] lemma coe_ofAddEquiv_symm [Add α] :\n    ⇑(ofAddEquiv.symm : Matrix m n α ≃+ (m → n → α)) = of.symm := rfl\n\n"}
{"name":"Matrix.isAddUnit_iff","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : AddMonoid α\nA : Matrix m n α\n⊢ Iff (IsAddUnit A) (∀ (i : m) (j : n), IsAddUnit (A i j))","decl":"@[simp] lemma isAddUnit_iff [AddMonoid α] {A : Matrix m n α} :\n    IsAddUnit A ↔ ∀ i j, IsAddUnit (A i j) := by\n  simp_rw [isAddUnit_iff_exists, Classical.skolem, forall_and,\n    ← Matrix.ext_iff, add_apply, zero_apply]\n  rfl\n\n"}
{"name":"Matrix.transpose_transpose","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nM : Matrix m n α\n⊢ Eq M.transpose.transpose M","decl":"@[simp]\ntheorem transpose_transpose (M : Matrix m n α) : Mᵀᵀ = M := by\n  ext\n  rfl\n\n"}
{"name":"Matrix.transpose_injective","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\n⊢ Function.Injective Matrix.transpose","decl":"theorem transpose_injective : Function.Injective (transpose : Matrix m n α → Matrix n m α) :=\n  fun _ _ h => ext fun i j => ext_iff.2 h j i\n\n"}
{"name":"Matrix.transpose_inj","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nA B : Matrix m n α\n⊢ Iff (Eq A.transpose B.transpose) (Eq A B)","decl":"@[simp] theorem transpose_inj {A B : Matrix m n α} : Aᵀ = Bᵀ ↔ A = B := transpose_injective.eq_iff\n\n"}
{"name":"Matrix.transpose_zero","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Zero α\n⊢ Eq (Matrix.transpose 0) 0","decl":"@[simp]\ntheorem transpose_zero [Zero α] : (0 : Matrix m n α)ᵀ = 0 := rfl\n\n"}
{"name":"Matrix.transpose_eq_zero","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Zero α\nM : Matrix m n α\n⊢ Iff (Eq M.transpose 0) (Eq M 0)","decl":"@[simp]\ntheorem transpose_eq_zero [Zero α] {M : Matrix m n α} : Mᵀ = 0 ↔ M = 0 := transpose_inj\n\n"}
{"name":"Matrix.transpose_add","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Add α\nM N : Matrix m n α\n⊢ Eq (HAdd.hAdd M N).transpose (HAdd.hAdd M.transpose N.transpose)","decl":"@[simp]\ntheorem transpose_add [Add α] (M : Matrix m n α) (N : Matrix m n α) : (M + N)ᵀ = Mᵀ + Nᵀ := by\n  ext\n  simp\n\n"}
{"name":"Matrix.transpose_sub","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Sub α\nM N : Matrix m n α\n⊢ Eq (HSub.hSub M N).transpose (HSub.hSub M.transpose N.transpose)","decl":"@[simp]\ntheorem transpose_sub [Sub α] (M : Matrix m n α) (N : Matrix m n α) : (M - N)ᵀ = Mᵀ - Nᵀ := by\n  ext\n  simp\n\n"}
{"name":"Matrix.transpose_smul","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nR : Type u_10\ninst✝ : SMul R α\nc : R\nM : Matrix m n α\n⊢ Eq (HSMul.hSMul c M).transpose (HSMul.hSMul c M.transpose)","decl":"@[simp]\ntheorem transpose_smul {R : Type*} [SMul R α] (c : R) (M : Matrix m n α) : (c • M)ᵀ = c • Mᵀ := by\n  ext\n  rfl\n\n"}
{"name":"Matrix.transpose_neg","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\ninst✝ : Neg α\nM : Matrix m n α\n⊢ Eq (Neg.neg M).transpose (Neg.neg M.transpose)","decl":"@[simp]\ntheorem transpose_neg [Neg α] (M : Matrix m n α) : (-M)ᵀ = -Mᵀ := by\n  ext\n  rfl\n\n"}
{"name":"Matrix.transpose_map","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nβ : Type w\nf : α → β\nM : Matrix m n α\n⊢ Eq (M.transpose.map f) (M.map f).transpose","decl":"theorem transpose_map {f : α → β} {M : Matrix m n α} : Mᵀ.map f = (M.map f)ᵀ := by\n  ext\n  rfl\n\n"}
{"name":"Matrix.submatrix_apply","module":"Mathlib.Data.Matrix.Defs","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\nA : Matrix m n α\nr_reindex : l → m\nc_reindex : o → n\ni : l\nj : o\n⊢ Eq (A.submatrix r_reindex c_reindex i j) (A (r_reindex i) (c_reindex j))","decl":"@[simp]\ntheorem submatrix_apply (A : Matrix m n α) (r_reindex : l → m) (c_reindex : o → n) (i j) :\n    A.submatrix r_reindex c_reindex i j = A (r_reindex i) (c_reindex j) :=\n  rfl\n\n"}
{"name":"Matrix.submatrix_id_id","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nA : Matrix m n α\n⊢ Eq (A.submatrix id id) A","decl":"@[simp]\ntheorem submatrix_id_id (A : Matrix m n α) : A.submatrix id id = A :=\n  ext fun _ _ => rfl\n\n"}
{"name":"Matrix.submatrix_submatrix","module":"Mathlib.Data.Matrix.Defs","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\nl₂ : Type u_10\no₂ : Type u_11\nA : Matrix m n α\nr₁ : l → m\nc₁ : o → n\nr₂ : l₂ → l\nc₂ : o₂ → o\n⊢ Eq ((A.submatrix r₁ c₁).submatrix r₂ c₂) (A.submatrix (Function.comp r₁ r₂) (Function.comp c₁ c₂))","decl":"@[simp]\ntheorem submatrix_submatrix {l₂ o₂ : Type*} (A : Matrix m n α) (r₁ : l → m) (c₁ : o → n)\n    (r₂ : l₂ → l) (c₂ : o₂ → o) :\n    (A.submatrix r₁ c₁).submatrix r₂ c₂ = A.submatrix (r₁ ∘ r₂) (c₁ ∘ c₂) :=\n  ext fun _ _ => rfl\n\n"}
{"name":"Matrix.transpose_submatrix","module":"Mathlib.Data.Matrix.Defs","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\nA : Matrix m n α\nr_reindex : l → m\nc_reindex : o → n\n⊢ Eq (A.submatrix r_reindex c_reindex).transpose (A.transpose.submatrix c_reindex r_reindex)","decl":"@[simp]\ntheorem transpose_submatrix (A : Matrix m n α) (r_reindex : l → m) (c_reindex : o → n) :\n    (A.submatrix r_reindex c_reindex)ᵀ = Aᵀ.submatrix c_reindex r_reindex :=\n  ext fun _ _ => rfl\n\n"}
{"name":"Matrix.submatrix_add","module":"Mathlib.Data.Matrix.Defs","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝ : Add α\nA B : Matrix m n α\n⊢ Eq (HAdd.hAdd A B).submatrix (HAdd.hAdd A.submatrix B.submatrix)","decl":"theorem submatrix_add [Add α] (A B : Matrix m n α) :\n    ((A + B).submatrix : (l → m) → (o → n) → Matrix l o α) = A.submatrix + B.submatrix :=\n  rfl\n\n"}
{"name":"Matrix.submatrix_neg","module":"Mathlib.Data.Matrix.Defs","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝ : Neg α\nA : Matrix m n α\n⊢ Eq (Neg.neg A).submatrix (Neg.neg A.submatrix)","decl":"theorem submatrix_neg [Neg α] (A : Matrix m n α) :\n    ((-A).submatrix : (l → m) → (o → n) → Matrix l o α) = -A.submatrix :=\n  rfl\n\n"}
{"name":"Matrix.submatrix_sub","module":"Mathlib.Data.Matrix.Defs","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝ : Sub α\nA B : Matrix m n α\n⊢ Eq (HSub.hSub A B).submatrix (HSub.hSub A.submatrix B.submatrix)","decl":"theorem submatrix_sub [Sub α] (A B : Matrix m n α) :\n    ((A - B).submatrix : (l → m) → (o → n) → Matrix l o α) = A.submatrix - B.submatrix :=\n  rfl\n\n"}
{"name":"Matrix.submatrix_zero","module":"Mathlib.Data.Matrix.Defs","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\ninst✝ : Zero α\n⊢ Eq (Matrix.submatrix 0) 0","decl":"@[simp]\ntheorem submatrix_zero [Zero α] :\n    ((0 : Matrix m n α).submatrix : (l → m) → (o → n) → Matrix l o α) = 0 :=\n  rfl\n\n"}
{"name":"Matrix.submatrix_smul","module":"Mathlib.Data.Matrix.Defs","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\nR : Type u_10\ninst✝ : SMul R α\nr : R\nA : Matrix m n α\n⊢ Eq (HSMul.hSMul r A).submatrix (HSMul.hSMul r A.submatrix)","decl":"theorem submatrix_smul {R : Type*} [SMul R α] (r : R) (A : Matrix m n α) :\n    ((r • A : Matrix m n α).submatrix : (l → m) → (o → n) → Matrix l o α) = r • A.submatrix :=\n  rfl\n\n"}
{"name":"Matrix.submatrix_map","module":"Mathlib.Data.Matrix.Defs","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\nβ : Type w\nf : α → β\ne₁ : l → m\ne₂ : o → n\nA : Matrix m n α\n⊢ Eq ((A.map f).submatrix e₁ e₂) ((A.submatrix e₁ e₂).map f)","decl":"theorem submatrix_map (f : α → β) (e₁ : l → m) (e₂ : o → n) (A : Matrix m n α) :\n    (A.map f).submatrix e₁ e₂ = (A.submatrix e₁ e₂).map f :=\n  rfl\n\n"}
{"name":"Matrix.reindex_apply","module":"Mathlib.Data.Matrix.Defs","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\neₘ : Equiv m l\neₙ : Equiv n o\nM : Matrix m n α\n⊢ Eq ((Matrix.reindex eₘ eₙ) M) (M.submatrix ⇑eₘ.symm ⇑eₙ.symm)","decl":"@[simp]\ntheorem reindex_apply (eₘ : m ≃ l) (eₙ : n ≃ o) (M : Matrix m n α) :\n    reindex eₘ eₙ M = M.submatrix eₘ.symm eₙ.symm :=\n  rfl\n\n"}
{"name":"Matrix.reindex_refl_refl","module":"Mathlib.Data.Matrix.Defs","initialProofState":"m : Type u_2\nn : Type u_3\nα : Type v\nA : Matrix m n α\n⊢ Eq ((Matrix.reindex (Equiv.refl m) (Equiv.refl n)) A) A","decl":"theorem reindex_refl_refl (A : Matrix m n α) : reindex (Equiv.refl _) (Equiv.refl _) A = A :=\n  A.submatrix_id_id\n\n"}
{"name":"Matrix.reindex_symm","module":"Mathlib.Data.Matrix.Defs","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\neₘ : Equiv m l\neₙ : Equiv n o\n⊢ Eq (Matrix.reindex eₘ eₙ).symm (Matrix.reindex eₘ.symm eₙ.symm)","decl":"@[simp]\ntheorem reindex_symm (eₘ : m ≃ l) (eₙ : n ≃ o) :\n    (reindex eₘ eₙ).symm = (reindex eₘ.symm eₙ.symm : Matrix l o α ≃ _) :=\n  rfl\n\n"}
{"name":"Matrix.reindex_trans","module":"Mathlib.Data.Matrix.Defs","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\nl₂ : Type u_10\no₂ : Type u_11\neₘ : Equiv m l\neₙ : Equiv n o\neₘ₂ : Equiv l l₂\neₙ₂ : Equiv o o₂\n⊢ Eq ((Matrix.reindex eₘ eₙ).trans (Matrix.reindex eₘ₂ eₙ₂)) (Matrix.reindex (eₘ.trans eₘ₂) (eₙ.trans eₙ₂))","decl":"@[simp]\ntheorem reindex_trans {l₂ o₂ : Type*} (eₘ : m ≃ l) (eₙ : n ≃ o) (eₘ₂ : l ≃ l₂) (eₙ₂ : o ≃ o₂) :\n    (reindex eₘ eₙ).trans (reindex eₘ₂ eₙ₂) =\n      (reindex (eₘ.trans eₘ₂) (eₙ.trans eₙ₂) : Matrix m n α ≃ _) :=\n  Equiv.ext fun A => (A.submatrix_submatrix eₘ.symm eₙ.symm eₘ₂.symm eₙ₂.symm :)\n\n"}
{"name":"Matrix.transpose_reindex","module":"Mathlib.Data.Matrix.Defs","initialProofState":"l : Type u_1\nm : Type u_2\nn : Type u_3\no : Type u_4\nα : Type v\neₘ : Equiv m l\neₙ : Equiv n o\nM : Matrix m n α\n⊢ Eq ((Matrix.reindex eₘ eₙ) M).transpose ((Matrix.reindex eₙ eₘ) M.transpose)","decl":"theorem transpose_reindex (eₘ : m ≃ l) (eₙ : n ≃ o) (M : Matrix m n α) :\n    (reindex eₘ eₙ M)ᵀ = reindex eₙ eₘ Mᵀ :=\n  rfl\n\n"}
