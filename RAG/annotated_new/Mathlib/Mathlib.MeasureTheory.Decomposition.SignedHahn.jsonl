{"name":"MeasureTheory.SignedMeasure.exists_subset_restrict_nonpos","module":"Mathlib.MeasureTheory.Decomposition.SignedHahn","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\ni : Set α\nhi : LT.lt (↑s i) 0\n⊢ Exists fun j => And (MeasurableSet j) (And (HasSubset.Subset j i) (And (LE.le (MeasureTheory.VectorMeasure.restrict s j) (MeasureTheory.VectorMeasure.restrict 0 j)) (LT.lt (↑s j) 0)))","decl":"/-- A measurable set of negative measure has a negative subset of negative measure. -/\ntheorem exists_subset_restrict_nonpos (hi : s i < 0) :\n    ∃ j : Set α, MeasurableSet j ∧ j ⊆ i ∧ s ≤[j] 0 ∧ s j < 0 := by\n  have hi₁ : MeasurableSet i := by_contradiction fun h => ne_of_lt hi <| s.not_measurable h\n  by_cases h : s ≤[i] 0; · exact ⟨i, hi₁, Set.Subset.refl _, h, hi⟩\n  by_cases hn : ∀ n : ℕ, ¬s ≤[i \\ ⋃ l < n, restrictNonposSeq s i l] 0\n  swap; · exact exists_subset_restrict_nonpos' hi₁ hi hn\n  set A := i \\ ⋃ l, restrictNonposSeq s i l with hA\n  set bdd : ℕ → ℕ := fun n => findExistsOneDivLT s (i \\ ⋃ k ≤ n, restrictNonposSeq s i k)\n  have hn' : ∀ n : ℕ, ¬s ≤[i \\ ⋃ l ≤ n, restrictNonposSeq s i l] 0 := by\n    intro n\n    convert hn (n + 1) using 5 <;>\n      · ext l\n        simp only [exists_prop, Set.mem_iUnion, and_congr_left_iff]\n        exact fun _ => Nat.lt_succ_iff.symm\n  have h₁ : s i = s A + ∑' l, s (restrictNonposSeq s i l) := by\n    rw [hA, ← s.of_disjoint_iUnion, add_comm, of_add_of_diff]\n    · exact MeasurableSet.iUnion fun _ => restrictNonposSeq_measurableSet _\n    exacts [hi₁, Set.iUnion_subset fun _ => restrictNonposSeq_subset _, fun _ =>\n      restrictNonposSeq_measurableSet _, restrictNonposSeq_disjoint]\n  have h₂ : s A ≤ s i := by\n    rw [h₁]\n    apply le_add_of_nonneg_right\n    exact tsum_nonneg fun n => le_of_lt (measure_of_restrictNonposSeq h _ (hn n))\n  have h₃' : Summable fun n => (1 / (bdd n + 1) : ℝ) := by\n    have : Summable fun l => s (restrictNonposSeq s i l) :=\n      HasSum.summable\n        (s.m_iUnion (fun _ => restrictNonposSeq_measurableSet _) restrictNonposSeq_disjoint)\n    refine .of_nonneg_of_le (fun n => ?_) (fun n => ?_)\n        (this.comp_injective Nat.succ_injective)\n    · exact le_of_lt Nat.one_div_pos_of_nat\n    · exact le_of_lt (restrictNonposSeq_lt n (hn' n))\n  have h₃ : Tendsto (fun n => (bdd n : ℝ) + 1) atTop atTop := by\n    simp only [one_div] at h₃'\n    exact Summable.tendsto_atTop_of_pos h₃' fun n => Nat.cast_add_one_pos (bdd n)\n  have h₄ : Tendsto (fun n => (bdd n : ℝ)) atTop atTop := by\n    convert atTop.tendsto_atTop_add_const_right (-1) h₃; simp\n  have A_meas : MeasurableSet A :=\n    hi₁.diff (MeasurableSet.iUnion fun _ => restrictNonposSeq_measurableSet _)\n  refine ⟨A, A_meas, Set.diff_subset, ?_, h₂.trans_lt hi⟩\n  by_contra hnn\n  rw [restrict_le_restrict_iff _ _ A_meas] at hnn; push_neg at hnn\n  obtain ⟨E, hE₁, hE₂, hE₃⟩ := hnn\n  have : ∃ k, 1 ≤ bdd k ∧ 1 / (bdd k : ℝ) < s E := by\n    rw [tendsto_atTop_atTop] at h₄\n    obtain ⟨k, hk⟩ := h₄ (max (1 / s E + 1) 1)\n    refine ⟨k, ?_, ?_⟩\n    · have hle := le_of_max_le_right (hk k le_rfl)\n      norm_cast at hle\n    · have : 1 / s E < bdd k := by\n        linarith only [le_of_max_le_left (hk k le_rfl)]\n      rw [one_div] at this ⊢\n      exact inv_lt_of_inv_lt₀ hE₃ this\n  obtain ⟨k, hk₁, hk₂⟩ := this\n  have hA' : A ⊆ i \\ ⋃ l ≤ k, restrictNonposSeq s i l := by\n    apply Set.diff_subset_diff_right\n    intro x; simp only [Set.mem_iUnion]\n    rintro ⟨n, _, hn₂⟩\n    exact ⟨n, hn₂⟩\n  refine\n    findExistsOneDivLT_min (hn' k) (Nat.sub_lt hk₁ Nat.zero_lt_one)\n      ⟨E, Set.Subset.trans hE₂ hA', hE₁, ?_⟩\n  convert hk₂; norm_cast\n  exact tsub_add_cancel_of_le hk₁\n\n"}
{"name":"MeasureTheory.SignedMeasure.zero_mem_measureOfNegatives","module":"Mathlib.MeasureTheory.Decomposition.SignedHahn","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\n⊢ Membership.mem s.measureOfNegatives 0","decl":"theorem zero_mem_measureOfNegatives : (0 : ℝ) ∈ s.measureOfNegatives :=\n  ⟨∅, ⟨MeasurableSet.empty, le_restrict_empty _ _⟩, s.empty⟩\n\n"}
{"name":"MeasureTheory.SignedMeasure.bddBelow_measureOfNegatives","module":"Mathlib.MeasureTheory.Decomposition.SignedHahn","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\n⊢ BddBelow s.measureOfNegatives","decl":"theorem bddBelow_measureOfNegatives : BddBelow s.measureOfNegatives := by\n  simp_rw [BddBelow, Set.Nonempty, mem_lowerBounds]\n  by_contra! h\n  have h' : ∀ n : ℕ, ∃ y : ℝ, y ∈ s.measureOfNegatives ∧ y < -n := fun n => h (-n)\n  choose f hf using h'\n  have hf' : ∀ n : ℕ, ∃ B, MeasurableSet B ∧ s ≤[B] 0 ∧ s B < -n := by\n    intro n\n    rcases hf n with ⟨⟨B, ⟨hB₁, hBr⟩, hB₂⟩, hlt⟩\n    exact ⟨B, hB₁, hBr, hB₂.symm ▸ hlt⟩\n  choose B hmeas hr h_lt using hf'\n  set A := ⋃ n, B n with hA\n  have hfalse : ∀ n : ℕ, s A ≤ -n := by\n    intro n\n    refine le_trans ?_ (le_of_lt (h_lt _))\n    rw [hA, ← Set.diff_union_of_subset (Set.subset_iUnion _ n),\n      of_union Set.disjoint_sdiff_left _ (hmeas n)]\n    · refine add_le_of_nonpos_left ?_\n      have : s ≤[A] 0 := restrict_le_restrict_iUnion _ _ hmeas hr\n      refine nonpos_of_restrict_le_zero _ (restrict_le_zero_subset _ ?_ Set.diff_subset this)\n      exact MeasurableSet.iUnion hmeas\n    · exact (MeasurableSet.iUnion hmeas).diff (hmeas n)\n  rcases exists_nat_gt (-s A) with ⟨n, hn⟩\n  exact lt_irrefl _ ((neg_lt.1 hn).trans_le (hfalse n))\n\n"}
{"name":"MeasureTheory.SignedMeasure.exists_compl_positive_negative","module":"Mathlib.MeasureTheory.Decomposition.SignedHahn","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\n⊢ Exists fun i => And (MeasurableSet i) (And (LE.le (MeasureTheory.VectorMeasure.restrict 0 i) (MeasureTheory.VectorMeasure.restrict s i)) (LE.le (MeasureTheory.VectorMeasure.restrict s (HasCompl.compl i)) (MeasureTheory.VectorMeasure.restrict 0 (HasCompl.compl i))))","decl":"/-- Alternative formulation of `MeasureTheory.SignedMeasure.exists_isCompl_positive_negative`\n(the Hahn decomposition theorem) using set complements. -/\ntheorem exists_compl_positive_negative (s : SignedMeasure α) :\n    ∃ i : Set α, MeasurableSet i ∧ 0 ≤[i] s ∧ s ≤[iᶜ] 0 := by\n  obtain ⟨f, _, hf₂, hf₁⟩ :=\n    exists_seq_tendsto_sInf ⟨0, @zero_mem_measureOfNegatives _ _ s⟩ bddBelow_measureOfNegatives\n  choose B hB using hf₁\n  have hB₁ : ∀ n, MeasurableSet (B n) := fun n => (hB n).1.1\n  have hB₂ : ∀ n, s ≤[B n] 0 := fun n => (hB n).1.2\n  set A := ⋃ n, B n with hA\n  have hA₁ : MeasurableSet A := MeasurableSet.iUnion hB₁\n  have hA₂ : s ≤[A] 0 := restrict_le_restrict_iUnion _ _ hB₁ hB₂\n  have hA₃ : s A = sInf s.measureOfNegatives := by\n    apply le_antisymm\n    · refine le_of_tendsto_of_tendsto tendsto_const_nhds hf₂ (Eventually.of_forall fun n => ?_)\n      rw [← (hB n).2, hA, ← Set.diff_union_of_subset (Set.subset_iUnion _ n),\n        of_union Set.disjoint_sdiff_left _ (hB₁ n)]\n      · refine add_le_of_nonpos_left ?_\n        have : s ≤[A] 0 :=\n          restrict_le_restrict_iUnion _ _ hB₁ fun m =>\n            let ⟨_, h⟩ := (hB m).1\n            h\n        refine\n          nonpos_of_restrict_le_zero _ (restrict_le_zero_subset _ ?_ Set.diff_subset this)\n        exact MeasurableSet.iUnion hB₁\n      · exact (MeasurableSet.iUnion hB₁).diff (hB₁ n)\n    · exact csInf_le bddBelow_measureOfNegatives ⟨A, ⟨hA₁, hA₂⟩, rfl⟩\n  refine ⟨Aᶜ, hA₁.compl, ?_, (compl_compl A).symm ▸ hA₂⟩\n  rw [restrict_le_restrict_iff _ _ hA₁.compl]\n  intro C _ hC₁\n  by_contra! hC₂\n  rcases exists_subset_restrict_nonpos hC₂ with ⟨D, hD₁, hD, hD₂, hD₃⟩\n  have : s (A ∪ D) < sInf s.measureOfNegatives := by\n    rw [← hA₃,\n      of_union (Set.disjoint_of_subset_right (Set.Subset.trans hD hC₁) disjoint_compl_right) hA₁\n        hD₁]\n    linarith\n  refine not_le.2 this ?_\n  refine csInf_le bddBelow_measureOfNegatives ⟨A ∪ D, ⟨?_, ?_⟩, rfl⟩\n  · exact hA₁.union hD₁\n  · exact restrict_le_restrict_union _ _ hA₁ hA₂ hD₁ hD₂\n\n"}
{"name":"MeasureTheory.SignedMeasure.exists_isCompl_positive_negative","module":"Mathlib.MeasureTheory.Decomposition.SignedHahn","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\n⊢ Exists fun i => Exists fun j => And (MeasurableSet i) (And (LE.le (MeasureTheory.VectorMeasure.restrict 0 i) (MeasureTheory.VectorMeasure.restrict s i)) (And (MeasurableSet j) (And (LE.le (MeasureTheory.VectorMeasure.restrict s j) (MeasureTheory.VectorMeasure.restrict 0 j)) (IsCompl i j))))","decl":"/-- **The Hahn decomposition theorem**: Given a signed measure `s`, there exist\ncomplement measurable sets `i` and `j` such that `i` is positive, `j` is negative. -/\ntheorem exists_isCompl_positive_negative (s : SignedMeasure α) :\n    ∃ i j : Set α, MeasurableSet i ∧ 0 ≤[i] s ∧ MeasurableSet j ∧ s ≤[j] 0 ∧ IsCompl i j :=\n  let ⟨i, hi₁, hi₂, hi₃⟩ := exists_compl_positive_negative s\n  ⟨i, iᶜ, hi₁, hi₂, hi₁.compl, hi₃, isCompl_compl⟩\n\n"}
{"name":"MeasureTheory.SignedMeasure.of_symmDiff_compl_positive_negative","module":"Mathlib.MeasureTheory.Decomposition.SignedHahn","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\ns : MeasureTheory.SignedMeasure α\ni j : Set α\nhi : MeasurableSet i\nhj : MeasurableSet j\nhi' : And (LE.le (MeasureTheory.VectorMeasure.restrict 0 i) (MeasureTheory.VectorMeasure.restrict s i)) (LE.le (MeasureTheory.VectorMeasure.restrict s (HasCompl.compl i)) (MeasureTheory.VectorMeasure.restrict 0 (HasCompl.compl i)))\nhj' : And (LE.le (MeasureTheory.VectorMeasure.restrict 0 j) (MeasureTheory.VectorMeasure.restrict s j)) (LE.le (MeasureTheory.VectorMeasure.restrict s (HasCompl.compl j)) (MeasureTheory.VectorMeasure.restrict 0 (HasCompl.compl j)))\n⊢ And (Eq (↑s (symmDiff i j)) 0) (Eq (↑s (symmDiff (HasCompl.compl i) (HasCompl.compl j))) 0)","decl":"open scoped symmDiff in\n/-- The symmetric difference of two Hahn decompositions has measure zero. -/\ntheorem of_symmDiff_compl_positive_negative {s : SignedMeasure α} {i j : Set α}\n    (hi : MeasurableSet i) (hj : MeasurableSet j) (hi' : 0 ≤[i] s ∧ s ≤[iᶜ] 0)\n    (hj' : 0 ≤[j] s ∧ s ≤[jᶜ] 0) : s (i ∆ j) = 0 ∧ s (iᶜ ∆ jᶜ) = 0 := by\n  rw [restrict_le_restrict_iff s 0, restrict_le_restrict_iff 0 s] at hi' hj'\n  constructor\n  · rw [Set.symmDiff_def, Set.diff_eq_compl_inter, Set.diff_eq_compl_inter, of_union,\n      le_antisymm (hi'.2 (hi.compl.inter hj) Set.inter_subset_left)\n        (hj'.1 (hi.compl.inter hj) Set.inter_subset_right),\n      le_antisymm (hj'.2 (hj.compl.inter hi) Set.inter_subset_left)\n        (hi'.1 (hj.compl.inter hi) Set.inter_subset_right),\n      zero_apply, zero_apply, zero_add]\n    · exact\n        Set.disjoint_of_subset_left Set.inter_subset_left\n          (Set.disjoint_of_subset_right Set.inter_subset_right\n            (disjoint_comm.1 (IsCompl.disjoint isCompl_compl)))\n    · exact hj.compl.inter hi\n    · exact hi.compl.inter hj\n  · rw [Set.symmDiff_def, Set.diff_eq_compl_inter, Set.diff_eq_compl_inter, compl_compl,\n      compl_compl, of_union,\n      le_antisymm (hi'.2 (hj.inter hi.compl) Set.inter_subset_right)\n        (hj'.1 (hj.inter hi.compl) Set.inter_subset_left),\n      le_antisymm (hj'.2 (hi.inter hj.compl) Set.inter_subset_right)\n        (hi'.1 (hi.inter hj.compl) Set.inter_subset_left),\n      zero_apply, zero_apply, zero_add]\n    · exact\n        Set.disjoint_of_subset_left Set.inter_subset_left\n          (Set.disjoint_of_subset_right Set.inter_subset_right\n            (IsCompl.disjoint isCompl_compl))\n    · exact hj.inter hi.compl\n    · exact hi.inter hj.compl\n  all_goals measurability\n\n"}
