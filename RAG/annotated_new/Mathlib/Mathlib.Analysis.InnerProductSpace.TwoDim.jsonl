{"name":"FiniteDimensional.of_fact_finrank_eq_two","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"K : Type u_1\nV : Type u_2\ninst✝³ : DivisionRing K\ninst✝² : AddCommGroup V\ninst✝¹ : Module K V\ninst✝ : Fact (Eq (Module.finrank K V) 2)\n⊢ FiniteDimensional K V","decl":"lemma FiniteDimensional.of_fact_finrank_eq_two {K V : Type*} [DivisionRing K]\n    [AddCommGroup V] [Module K V] [Fact (finrank K V = 2)] : FiniteDimensional K V :=\n  .of_fact_finrank_eq_succ 1\n\n"}
{"name":"Orientation.areaForm_def","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\n⊢ Eq o.areaForm\n    (let z := AlternatingMap.constLinearEquivOfIsEmpty.symm;\n    let y := ((LinearMap.llcomp Real E (AlternatingMap Real E Real (Fin 0)) Real) ↑z).comp AlternatingMap.curryLeftLinearMap;\n    y.comp (AlternatingMap.curryLeftLinearMap o.volumeForm))","decl":"/-- An antisymmetric bilinear form on an oriented real inner product space of dimension 2 (usual\nnotation `ω`). When evaluated on two vectors, it gives the oriented area of the parallelogram they\nspan. -/\nirreducible_def areaForm : E →ₗ[ℝ] E →ₗ[ℝ] ℝ := by\n  let z : E [⋀^Fin 0]→ₗ[ℝ] ℝ ≃ₗ[ℝ] ℝ :=\n    AlternatingMap.constLinearEquivOfIsEmpty.symm\n  let y : E [⋀^Fin 1]→ₗ[ℝ] ℝ →ₗ[ℝ] E →ₗ[ℝ] ℝ :=\n    LinearMap.llcomp ℝ E (E [⋀^Fin 0]→ₗ[ℝ] ℝ) ℝ z ∘ₗ AlternatingMap.curryLeftLinearMap\n  exact y ∘ₗ AlternatingMap.curryLeftLinearMap (R' := ℝ) o.volumeForm\n\n"}
{"name":"Orientation.areaForm_to_volumeForm","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq ((o.areaForm x) y) (o.volumeForm (Matrix.vecCons x (Matrix.vecCons y Matrix.vecEmpty)))","decl":"theorem areaForm_to_volumeForm (x y : E) : ω x y = o.volumeForm ![x, y] := by simp [areaForm]\n\n"}
{"name":"Orientation.areaForm_apply_self","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx : E\n⊢ Eq ((o.areaForm x) x) 0","decl":"@[simp]\ntheorem areaForm_apply_self (x : E) : ω x x = 0 := by\n  rw [areaForm_to_volumeForm]\n  refine o.volumeForm.map_eq_zero_of_eq ![x, x] ?_ (?_ : (0 : Fin 2) ≠ 1)\n  · simp\n  · norm_num\n\n"}
{"name":"Orientation.areaForm_swap","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq ((o.areaForm x) y) (Neg.neg ((o.areaForm y) x))","decl":"theorem areaForm_swap (x y : E) : ω x y = -ω y x := by\n  simp only [areaForm_to_volumeForm]\n  convert o.volumeForm.map_swap ![y, x] (_ : (0 : Fin 2) ≠ 1)\n  · ext i\n    fin_cases i <;> rfl\n  · norm_num\n\n"}
{"name":"Orientation.areaForm_neg_orientation","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\n⊢ Eq (Neg.neg o).areaForm (Neg.neg o.areaForm)","decl":"@[simp]\ntheorem areaForm_neg_orientation : (-o).areaForm = -o.areaForm := by\n  ext x y\n  simp [areaForm_to_volumeForm]\n\n"}
{"name":"Orientation.areaForm'_apply","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx : E\n⊢ Eq (o.areaForm' x) (LinearMap.toContinuousLinearMap (o.areaForm x))","decl":"@[simp]\ntheorem areaForm'_apply (x : E) :\n    o.areaForm' x = LinearMap.toContinuousLinearMap (o.areaForm x) :=\n  rfl\n\n"}
{"name":"Orientation.abs_areaForm_le","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ LE.le (abs ((o.areaForm x) y)) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"theorem abs_areaForm_le (x y : E) : |ω x y| ≤ ‖x‖ * ‖y‖ := by\n  simpa [areaForm_to_volumeForm, Fin.prod_univ_succ] using o.abs_volumeForm_apply_le ![x, y]\n\n"}
{"name":"Orientation.areaForm_le","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ LE.le ((o.areaForm x) y) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"theorem areaForm_le (x y : E) : ω x y ≤ ‖x‖ * ‖y‖ := by\n  simpa [areaForm_to_volumeForm, Fin.prod_univ_succ] using o.volumeForm_apply_le ![x, y]\n\n"}
{"name":"Orientation.abs_areaForm_of_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\nh : Eq (Inner.inner x y) 0\n⊢ Eq (abs ((o.areaForm x) y)) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"theorem abs_areaForm_of_orthogonal {x y : E} (h : ⟪x, y⟫ = 0) : |ω x y| = ‖x‖ * ‖y‖ := by\n  rw [o.areaForm_to_volumeForm, o.abs_volumeForm_apply_of_pairwise_orthogonal]\n  · simp [Fin.prod_univ_succ]\n  intro i j hij\n  fin_cases i <;> fin_cases j\n  · simp_all\n  · simpa using h\n  · simpa [real_inner_comm] using h\n  · simp_all\n\n"}
{"name":"Orientation.areaForm_map","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace Real E\ninst✝² : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nhF : Fact (Eq (Module.finrank Real F) 2)\nφ : LinearIsometryEquiv (RingHom.id Real) E F\nx y : F\n⊢ Eq ((((Orientation.map (Fin 2) φ.toLinearEquiv) o).areaForm x) y) ((o.areaForm (φ.symm x)) (φ.symm y))","decl":"theorem areaForm_map {F : Type*} [NormedAddCommGroup F] [InnerProductSpace ℝ F]\n    [hF : Fact (finrank ℝ F = 2)] (φ : E ≃ₗᵢ[ℝ] F) (x y : F) :\n    (Orientation.map (Fin 2) φ.toLinearEquiv o).areaForm x y =\n    o.areaForm (φ.symm x) (φ.symm y) := by\n  have : φ.symm ∘ ![x, y] = ![φ.symm x, φ.symm y] := by\n    ext i\n    fin_cases i <;> rfl\n  simp [areaForm_to_volumeForm, volumeForm_map, this]\n\n"}
{"name":"Orientation.areaForm_comp_linearIsometryEquiv","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nφ : LinearIsometryEquiv (RingHom.id Real) E E\nhφ : LT.lt 0 (LinearMap.det ↑φ.toLinearEquiv)\nx y : E\n⊢ Eq ((o.areaForm (φ x)) (φ y)) ((o.areaForm x) y)","decl":"/-- The area form is invariant under pullback by a positively-oriented isometric automorphism. -/\ntheorem areaForm_comp_linearIsometryEquiv (φ : E ≃ₗᵢ[ℝ] E)\n    (hφ : 0 < LinearMap.det (φ.toLinearEquiv : E →ₗ[ℝ] E)) (x y : E) :\n    o.areaForm (φ x) (φ y) = o.areaForm x y := by\n  convert o.areaForm_map φ (φ x) (φ y)\n  · symm\n    rwa [← o.map_eq_iff_det_pos φ.toLinearEquiv] at hφ\n    rw [@Fact.out (finrank ℝ E = 2), Fintype.card_fin]\n  · simp\n  · simp\n\n"}
{"name":"Orientation.rightAngleRotationAux₁_def","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\n⊢ Eq o.rightAngleRotationAux₁\n    (let to_dual := (InnerProductSpace.toDual Real E).trans LinearMap.toContinuousLinearMap.symm;\n    (↑to_dual.symm).comp o.areaForm)","decl":"/-- Auxiliary construction for `Orientation.rightAngleRotation`, rotation by 90 degrees in an\noriented real inner product space of dimension 2. -/\nirreducible_def rightAngleRotationAux₁ : E →ₗ[ℝ] E :=\n  let to_dual : E ≃ₗ[ℝ] E →ₗ[ℝ] ℝ :=\n    (InnerProductSpace.toDual ℝ E).toLinearEquiv ≪≫ₗ LinearMap.toContinuousLinearMap.symm\n  ↑to_dual.symm ∘ₗ ω\n\n"}
{"name":"Orientation.inner_rightAngleRotationAux₁_left","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq (Inner.inner (o.rightAngleRotationAux₁ x) y) ((o.areaForm x) y)","decl":"@[simp]\ntheorem inner_rightAngleRotationAux₁_left (x y : E) : ⟪o.rightAngleRotationAux₁ x, y⟫ = ω x y := by\n  -- Porting note: split `simp only` for greater proof control\n  simp only [rightAngleRotationAux₁, LinearEquiv.trans_symm, LinearIsometryEquiv.toLinearEquiv_symm,\n    LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply, LinearEquiv.trans_apply,\n    LinearIsometryEquiv.coe_toLinearEquiv]\n  rw [InnerProductSpace.toDual_symm_apply]\n  norm_cast\n\n"}
{"name":"Orientation.inner_rightAngleRotationAux₁_right","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq (Inner.inner x (o.rightAngleRotationAux₁ y)) (Neg.neg ((o.areaForm x) y))","decl":"@[simp]\ntheorem inner_rightAngleRotationAux₁_right (x y : E) :\n    ⟪x, o.rightAngleRotationAux₁ y⟫ = -ω x y := by\n  rw [real_inner_comm]\n  simp [o.areaForm_swap y x]\n\n"}
{"name":"Orientation.rightAngleRotationAux₁_rightAngleRotationAux₁","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx : E\n⊢ Eq (o.rightAngleRotationAux₁ (o.rightAngleRotationAux₁ x)) (Neg.neg x)","decl":"@[simp]\ntheorem rightAngleRotationAux₁_rightAngleRotationAux₁ (x : E) :\n    o.rightAngleRotationAux₁ (o.rightAngleRotationAux₁ x) = -x := by\n  apply ext_inner_left ℝ\n  intro y\n  have : ⟪o.rightAngleRotationAux₁ y, o.rightAngleRotationAux₁ x⟫ = ⟪y, x⟫ :=\n    LinearIsometry.inner_map_map o.rightAngleRotationAux₂ y x\n  rw [o.inner_rightAngleRotationAux₁_right, ← o.inner_rightAngleRotationAux₁_left, this,\n    inner_neg_right]\n\n"}
{"name":"Orientation.rightAngleRotation_def","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\n⊢ Eq o.rightAngleRotation (LinearIsometryEquiv.ofLinearIsometry o.rightAngleRotationAux₂ (Neg.neg o.rightAngleRotationAux₁) ⋯ ⋯)","decl":"/-- An isometric automorphism of an oriented real inner product space of dimension 2 (usual notation\n`J`). This automorphism squares to -1. We will define rotations in such a way that this\nautomorphism is equal to rotation by 90 degrees. -/\nirreducible_def rightAngleRotation : E ≃ₗᵢ[ℝ] E :=\n  LinearIsometryEquiv.ofLinearIsometry o.rightAngleRotationAux₂ (-o.rightAngleRotationAux₁)\n    (by ext; simp [rightAngleRotationAux₂]) (by ext; simp [rightAngleRotationAux₂])\n\n"}
{"name":"Orientation.inner_rightAngleRotation_left","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq (Inner.inner (o.rightAngleRotation x) y) ((o.areaForm x) y)","decl":"@[simp]\ntheorem inner_rightAngleRotation_left (x y : E) : ⟪J x, y⟫ = ω x y := by\n  rw [rightAngleRotation]\n  exact o.inner_rightAngleRotationAux₁_left x y\n\n"}
{"name":"Orientation.inner_rightAngleRotation_right","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq (Inner.inner x (o.rightAngleRotation y)) (Neg.neg ((o.areaForm x) y))","decl":"@[simp]\ntheorem inner_rightAngleRotation_right (x y : E) : ⟪x, J y⟫ = -ω x y := by\n  rw [rightAngleRotation]\n  exact o.inner_rightAngleRotationAux₁_right x y\n\n"}
{"name":"Orientation.rightAngleRotation_rightAngleRotation","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx : E\n⊢ Eq (o.rightAngleRotation (o.rightAngleRotation x)) (Neg.neg x)","decl":"@[simp]\ntheorem rightAngleRotation_rightAngleRotation (x : E) : J (J x) = -x := by\n  rw [rightAngleRotation]\n  exact o.rightAngleRotationAux₁_rightAngleRotationAux₁ x\n\n"}
{"name":"Orientation.rightAngleRotation_symm","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\n⊢ Eq o.rightAngleRotation.symm (o.rightAngleRotation.trans (LinearIsometryEquiv.neg Real))","decl":"@[simp]\ntheorem rightAngleRotation_symm :\n    LinearIsometryEquiv.symm J = LinearIsometryEquiv.trans J (LinearIsometryEquiv.neg ℝ) := by\n  rw [rightAngleRotation]\n  exact LinearIsometryEquiv.toLinearIsometry_injective rfl\n\n"}
{"name":"Orientation.inner_rightAngleRotation_self","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx : E\n⊢ Eq (Inner.inner (o.rightAngleRotation x) x) 0","decl":"theorem inner_rightAngleRotation_self (x : E) : ⟪J x, x⟫ = 0 := by simp\n\n"}
{"name":"Orientation.inner_rightAngleRotation_swap","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq (Inner.inner x (o.rightAngleRotation y)) (Neg.neg (Inner.inner (o.rightAngleRotation x) y))","decl":"theorem inner_rightAngleRotation_swap (x y : E) : ⟪x, J y⟫ = -⟪J x, y⟫ := by simp\n\n"}
{"name":"Orientation.inner_rightAngleRotation_swap'","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq (Inner.inner (o.rightAngleRotation x) y) (Neg.neg (Inner.inner x (o.rightAngleRotation y)))","decl":"theorem inner_rightAngleRotation_swap' (x y : E) : ⟪J x, y⟫ = -⟪x, J y⟫ := by\n  simp [o.inner_rightAngleRotation_swap x y]\n\n"}
{"name":"Orientation.inner_comp_rightAngleRotation","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq (Inner.inner (o.rightAngleRotation x) (o.rightAngleRotation y)) (Inner.inner x y)","decl":"theorem inner_comp_rightAngleRotation (x y : E) : ⟪J x, J y⟫ = ⟪x, y⟫ :=\n  LinearIsometryEquiv.inner_map_map J x y\n\n"}
{"name":"Orientation.areaForm_rightAngleRotation_left","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq ((o.areaForm (o.rightAngleRotation x)) y) (Neg.neg (Inner.inner x y))","decl":"@[simp]\ntheorem areaForm_rightAngleRotation_left (x y : E) : ω (J x) y = -⟪x, y⟫ := by\n  rw [← o.inner_comp_rightAngleRotation, o.inner_rightAngleRotation_right, neg_neg]\n\n"}
{"name":"Orientation.areaForm_rightAngleRotation_right","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq ((o.areaForm x) (o.rightAngleRotation y)) (Inner.inner x y)","decl":"@[simp]\ntheorem areaForm_rightAngleRotation_right (x y : E) : ω x (J y) = ⟪x, y⟫ := by\n  rw [← o.inner_rightAngleRotation_left, o.inner_comp_rightAngleRotation]\n\n"}
{"name":"Orientation.areaForm_comp_rightAngleRotation","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq ((o.areaForm (o.rightAngleRotation x)) (o.rightAngleRotation y)) ((o.areaForm x) y)","decl":"theorem areaForm_comp_rightAngleRotation (x y : E) : ω (J x) (J y) = ω x y := by simp\n\n"}
{"name":"Orientation.rightAngleRotation_trans_rightAngleRotation","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\n⊢ Eq (o.rightAngleRotation.trans o.rightAngleRotation) (LinearIsometryEquiv.neg Real)","decl":"@[simp]\ntheorem rightAngleRotation_trans_rightAngleRotation :\n    LinearIsometryEquiv.trans J J = LinearIsometryEquiv.neg ℝ := by ext; simp\n\n"}
{"name":"Orientation.rightAngleRotation_neg_orientation","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx : E\n⊢ Eq ((Neg.neg o).rightAngleRotation x) (Neg.neg (o.rightAngleRotation x))","decl":"theorem rightAngleRotation_neg_orientation (x : E) :\n    (-o).rightAngleRotation x = -o.rightAngleRotation x := by\n  apply ext_inner_right ℝ\n  intro y\n  rw [inner_rightAngleRotation_left]\n  simp\n\n"}
{"name":"Orientation.rightAngleRotation_trans_neg_orientation","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\n⊢ Eq (Neg.neg o).rightAngleRotation (o.rightAngleRotation.trans (LinearIsometryEquiv.neg Real))","decl":"@[simp]\ntheorem rightAngleRotation_trans_neg_orientation :\n    (-o).rightAngleRotation = o.rightAngleRotation.trans (LinearIsometryEquiv.neg ℝ) :=\n  LinearIsometryEquiv.ext <| o.rightAngleRotation_neg_orientation\n\n"}
{"name":"Orientation.rightAngleRotation_map","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace Real E\ninst✝² : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nhF : Fact (Eq (Module.finrank Real F) 2)\nφ : LinearIsometryEquiv (RingHom.id Real) E F\nx : F\n⊢ Eq (((Orientation.map (Fin 2) φ.toLinearEquiv) o).rightAngleRotation x) (φ (o.rightAngleRotation (φ.symm x)))","decl":"theorem rightAngleRotation_map {F : Type*} [NormedAddCommGroup F] [InnerProductSpace ℝ F]\n    [hF : Fact (finrank ℝ F = 2)] (φ : E ≃ₗᵢ[ℝ] F) (x : F) :\n    (Orientation.map (Fin 2) φ.toLinearEquiv o).rightAngleRotation x =\n      φ (o.rightAngleRotation (φ.symm x)) := by\n  apply ext_inner_right ℝ\n  intro y\n  rw [inner_rightAngleRotation_left]\n  trans ⟪J (φ.symm x), φ.symm y⟫\n  · simp [o.areaForm_map]\n  trans ⟪φ (J (φ.symm x)), φ (φ.symm y)⟫\n  · rw [φ.inner_map_map]\n  · simp\n\n"}
{"name":"Orientation.linearIsometryEquiv_comp_rightAngleRotation","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nφ : LinearIsometryEquiv (RingHom.id Real) E E\nhφ : LT.lt 0 (LinearMap.det ↑φ.toLinearEquiv)\nx : E\n⊢ Eq (φ (o.rightAngleRotation x)) (o.rightAngleRotation (φ x))","decl":"/-- `J` commutes with any positively-oriented isometric automorphism. -/\ntheorem linearIsometryEquiv_comp_rightAngleRotation (φ : E ≃ₗᵢ[ℝ] E)\n    (hφ : 0 < LinearMap.det (φ.toLinearEquiv : E →ₗ[ℝ] E)) (x : E) : φ (J x) = J (φ x) := by\n  convert (o.rightAngleRotation_map φ (φ x)).symm\n  · simp\n  · symm\n    rwa [← o.map_eq_iff_det_pos φ.toLinearEquiv] at hφ\n    rw [@Fact.out (finrank ℝ E = 2), Fintype.card_fin]\n\n"}
{"name":"Orientation.rightAngleRotation_map'","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : InnerProductSpace Real E\ninst✝³ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nF : Type u_2\ninst✝² : NormedAddCommGroup F\ninst✝¹ : InnerProductSpace Real F\ninst✝ : Fact (Eq (Module.finrank Real F) 2)\nφ : LinearIsometryEquiv (RingHom.id Real) E F\n⊢ Eq ((Orientation.map (Fin 2) φ.toLinearEquiv) o).rightAngleRotation ((φ.symm.trans o.rightAngleRotation).trans φ)","decl":"theorem rightAngleRotation_map' {F : Type*} [NormedAddCommGroup F] [InnerProductSpace ℝ F]\n    [Fact (finrank ℝ F = 2)] (φ : E ≃ₗᵢ[ℝ] F) :\n    (Orientation.map (Fin 2) φ.toLinearEquiv o).rightAngleRotation =\n      (φ.symm.trans o.rightAngleRotation).trans φ :=\n  LinearIsometryEquiv.ext <| o.rightAngleRotation_map φ\n\n"}
{"name":"Orientation.linearIsometryEquiv_comp_rightAngleRotation'","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nφ : LinearIsometryEquiv (RingHom.id Real) E E\nhφ : LT.lt 0 (LinearMap.det ↑φ.toLinearEquiv)\n⊢ Eq (o.rightAngleRotation.trans φ) (φ.trans o.rightAngleRotation)","decl":"/-- `J` commutes with any positively-oriented isometric automorphism. -/\ntheorem linearIsometryEquiv_comp_rightAngleRotation' (φ : E ≃ₗᵢ[ℝ] E)\n    (hφ : 0 < LinearMap.det (φ.toLinearEquiv : E →ₗ[ℝ] E)) :\n    LinearIsometryEquiv.trans J φ = φ.trans J :=\n  LinearIsometryEquiv.ext <| o.linearIsometryEquiv_comp_rightAngleRotation φ hφ\n\n"}
{"name":"Orientation.coe_basisRightAngleRotation","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx : E\nhx : Ne x 0\n⊢ Eq (⇑(o.basisRightAngleRotation x hx)) (Matrix.vecCons x (Matrix.vecCons (o.rightAngleRotation x) Matrix.vecEmpty))","decl":"@[simp]\ntheorem coe_basisRightAngleRotation (x : E) (hx : x ≠ 0) :\n    ⇑(o.basisRightAngleRotation x hx) = ![x, J x] :=\n  coe_basisOfLinearIndependentOfCardEqFinrank _ _\n\n"}
{"name":"Orientation.inner_mul_inner_add_areaForm_mul_areaForm'","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\na x : E\n⊢ Eq (HAdd.hAdd (HSMul.hSMul (Inner.inner a x) ((innerₛₗ Real) a)) (HSMul.hSMul ((o.areaForm a) x) (o.areaForm a))) (HSMul.hSMul (HPow.hPow (Norm.norm a) 2) ((innerₛₗ Real) x))","decl":"/-- For vectors `a x y : E`, the identity `⟪a, x⟫ * ⟪a, y⟫ + ω a x * ω a y = ‖a‖ ^ 2 * ⟪x, y⟫`. (See\n`Orientation.inner_mul_inner_add_areaForm_mul_areaForm` for the \"applied\" form.)-/\ntheorem inner_mul_inner_add_areaForm_mul_areaForm' (a x : E) :\n    ⟪a, x⟫ • innerₛₗ ℝ a + ω a x • ω a = ‖a‖ ^ 2 • innerₛₗ ℝ x := by\n  by_cases ha : a = 0\n  · simp [ha]\n  apply (o.basisRightAngleRotation a ha).ext\n  intro i\n  fin_cases i\n  · simp only [Fin.zero_eta, Fin.isValue, id_eq, coe_basisRightAngleRotation, Nat.succ_eq_add_one,\n      Nat.reduceAdd, Matrix.cons_val_zero, LinearMap.add_apply, LinearMap.smul_apply, innerₛₗ_apply,\n      real_inner_self_eq_norm_sq, smul_eq_mul, areaForm_apply_self, mul_zero, add_zero,\n      real_inner_comm]\n    ring\n  · simp only [Fin.mk_one, Fin.isValue, id_eq, coe_basisRightAngleRotation, Nat.succ_eq_add_one,\n      Nat.reduceAdd, Matrix.cons_val_one, Matrix.head_cons, LinearMap.add_apply,\n      LinearMap.smul_apply, innerₛₗ_apply, inner_rightAngleRotation_right, areaForm_apply_self,\n      neg_zero, smul_eq_mul, mul_zero, areaForm_rightAngleRotation_right,\n      real_inner_self_eq_norm_sq, zero_add, mul_neg]\n    rw [o.areaForm_swap]\n    ring\n\n"}
{"name":"Orientation.inner_mul_inner_add_areaForm_mul_areaForm","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\na x y : E\n⊢ Eq (HAdd.hAdd (HMul.hMul (Inner.inner a x) (Inner.inner a y)) (HMul.hMul ((o.areaForm a) x) ((o.areaForm a) y))) (HMul.hMul (HPow.hPow (Norm.norm a) 2) (Inner.inner x y))","decl":"/-- For vectors `a x y : E`, the identity `⟪a, x⟫ * ⟪a, y⟫ + ω a x * ω a y = ‖a‖ ^ 2 * ⟪x, y⟫`. -/\ntheorem inner_mul_inner_add_areaForm_mul_areaForm (a x y : E) :\n    ⟪a, x⟫ * ⟪a, y⟫ + ω a x * ω a y = ‖a‖ ^ 2 * ⟪x, y⟫ :=\n  congr_arg (fun f : E →ₗ[ℝ] ℝ => f y) (o.inner_mul_inner_add_areaForm_mul_areaForm' a x)\n\n"}
{"name":"Orientation.inner_sq_add_areaForm_sq","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\na b : E\n⊢ Eq (HAdd.hAdd (HPow.hPow (Inner.inner a b) 2) (HPow.hPow ((o.areaForm a) b) 2)) (HMul.hMul (HPow.hPow (Norm.norm a) 2) (HPow.hPow (Norm.norm b) 2))","decl":"theorem inner_sq_add_areaForm_sq (a b : E) : ⟪a, b⟫ ^ 2 + ω a b ^ 2 = ‖a‖ ^ 2 * ‖b‖ ^ 2 := by\n  simpa [sq, real_inner_self_eq_norm_sq] using o.inner_mul_inner_add_areaForm_mul_areaForm a b b\n\n"}
{"name":"Orientation.inner_mul_areaForm_sub'","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\na x : E\n⊢ Eq (HSub.hSub (HSMul.hSMul (Inner.inner a x) (o.areaForm a)) (HSMul.hSMul ((o.areaForm a) x) ((innerₛₗ Real) a))) (HSMul.hSMul (HPow.hPow (Norm.norm a) 2) (o.areaForm x))","decl":"/-- For vectors `a x y : E`, the identity `⟪a, x⟫ * ω a y - ω a x * ⟪a, y⟫ = ‖a‖ ^ 2 * ω x y`. (See\n`Orientation.inner_mul_areaForm_sub` for the \"applied\" form.) -/\ntheorem inner_mul_areaForm_sub' (a x : E) : ⟪a, x⟫ • ω a - ω a x • innerₛₗ ℝ a = ‖a‖ ^ 2 • ω x := by\n  by_cases ha : a = 0\n  · simp [ha]\n  apply (o.basisRightAngleRotation a ha).ext\n  intro i\n  fin_cases i\n  · simp only [o.areaForm_swap a x, neg_smul, sub_neg_eq_add, Fin.zero_eta, Fin.isValue, id_eq,\n      coe_basisRightAngleRotation, Nat.succ_eq_add_one, Nat.reduceAdd, Matrix.cons_val_zero,\n      LinearMap.add_apply, LinearMap.smul_apply, areaForm_apply_self, smul_eq_mul, mul_zero,\n      innerₛₗ_apply, real_inner_self_eq_norm_sq, zero_add]\n    ring\n  · simp only [Fin.mk_one, Fin.isValue, id_eq, coe_basisRightAngleRotation, Nat.succ_eq_add_one,\n      Nat.reduceAdd, Matrix.cons_val_one, Matrix.head_cons, LinearMap.sub_apply,\n      LinearMap.smul_apply, areaForm_rightAngleRotation_right, real_inner_self_eq_norm_sq,\n      smul_eq_mul, innerₛₗ_apply, inner_rightAngleRotation_right, areaForm_apply_self, neg_zero,\n      mul_zero, sub_zero, real_inner_comm]\n    ring\n\n"}
{"name":"Orientation.inner_mul_areaForm_sub","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\na x y : E\n⊢ Eq (HSub.hSub (HMul.hMul (Inner.inner a x) ((o.areaForm a) y)) (HMul.hMul ((o.areaForm a) x) (Inner.inner a y))) (HMul.hMul (HPow.hPow (Norm.norm a) 2) ((o.areaForm x) y))","decl":"/-- For vectors `a x y : E`, the identity `⟪a, x⟫ * ω a y - ω a x * ⟪a, y⟫ = ‖a‖ ^ 2 * ω x y`. -/\ntheorem inner_mul_areaForm_sub (a x y : E) : ⟪a, x⟫ * ω a y - ω a x * ⟪a, y⟫ = ‖a‖ ^ 2 * ω x y :=\n  congr_arg (fun f : E →ₗ[ℝ] ℝ => f y) (o.inner_mul_areaForm_sub' a x)\n\n"}
{"name":"Orientation.nonneg_inner_and_areaForm_eq_zero_iff_sameRay","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Iff (And (LE.le 0 (Inner.inner x y)) (Eq ((o.areaForm x) y) 0)) (SameRay Real x y)","decl":"theorem nonneg_inner_and_areaForm_eq_zero_iff_sameRay (x y : E) :\n    0 ≤ ⟪x, y⟫ ∧ ω x y = 0 ↔ SameRay ℝ x y := by\n  by_cases hx : x = 0\n  · simp [hx]\n  constructor\n  · let a : ℝ := (o.basisRightAngleRotation x hx).repr y 0\n    let b : ℝ := (o.basisRightAngleRotation x hx).repr y 1\n    suffices ↑0 ≤ a * ‖x‖ ^ 2 ∧ b * ‖x‖ ^ 2 = 0 → SameRay ℝ x (a • x + b • J x) by\n      rw [← (o.basisRightAngleRotation x hx).sum_repr y]\n      simp only [Fin.sum_univ_succ, coe_basisRightAngleRotation, Matrix.cons_val_zero,\n        Fin.succ_zero_eq_one', Finset.univ_eq_empty, Finset.sum_empty, areaForm_apply_self,\n        map_smul, map_add, real_inner_smul_right, inner_add_right, Matrix.cons_val_one,\n        Matrix.head_cons, Algebra.id.smul_eq_mul, areaForm_rightAngleRotation_right,\n        mul_zero, add_zero, zero_add, neg_zero, inner_rightAngleRotation_right,\n        real_inner_self_eq_norm_sq, zero_smul, one_smul]\n      exact this\n    rintro ⟨ha, hb⟩\n    have hx' : 0 < ‖x‖ := by simpa using hx\n    have ha' : 0 ≤ a := nonneg_of_mul_nonneg_left ha (by positivity)\n    have hb' : b = 0 := eq_zero_of_ne_zero_of_mul_right_eq_zero (pow_ne_zero 2 hx'.ne') hb\n    exact (SameRay.sameRay_nonneg_smul_right x ha').add_right <| by simp [hb']\n  · intro h\n    obtain ⟨r, hr, rfl⟩ := h.exists_nonneg_left hx\n    simp only [inner_smul_right, real_inner_self_eq_norm_sq, LinearMap.map_smulₛₗ,\n      areaForm_apply_self, Algebra.id.smul_eq_mul, mul_zero, eq_self_iff_true, and_true]\n    positivity\n\n"}
{"name":"Orientation.kahler_apply_apply","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq ((o.kahler x) y) (HAdd.hAdd (↑(Inner.inner x y)) (HSMul.hSMul ((o.areaForm x) y) Complex.I))","decl":"theorem kahler_apply_apply (x y : E) : o.kahler x y = ⟪x, y⟫ + ω x y • Complex.I :=\n  rfl\n\n"}
{"name":"Orientation.kahler_swap","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq ((o.kahler x) y) ((starRingEnd Complex) ((o.kahler y) x))","decl":"theorem kahler_swap (x y : E) : o.kahler x y = conj (o.kahler y x) := by\n  simp only [kahler_apply_apply]\n  rw [real_inner_comm, areaForm_swap]\n  simp [Complex.conj_ofReal]\n\n"}
{"name":"Orientation.kahler_apply_self","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx : E\n⊢ Eq ((o.kahler x) x) (HPow.hPow (↑(Norm.norm x)) 2)","decl":"@[simp]\ntheorem kahler_apply_self (x : E) : o.kahler x x = ‖x‖ ^ 2 := by\n  simp [kahler_apply_apply, real_inner_self_eq_norm_sq]\n\n"}
{"name":"Orientation.kahler_rightAngleRotation_left","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq ((o.kahler (o.rightAngleRotation x)) y) (HMul.hMul (Neg.neg Complex.I) ((o.kahler x) y))","decl":"@[simp]\ntheorem kahler_rightAngleRotation_left (x y : E) :\n    o.kahler (J x) y = -Complex.I * o.kahler x y := by\n  simp only [o.areaForm_rightAngleRotation_left, o.inner_rightAngleRotation_left,\n    o.kahler_apply_apply, Complex.ofReal_neg, Complex.real_smul]\n  linear_combination ω x y * Complex.I_sq\n\n"}
{"name":"Orientation.kahler_rightAngleRotation_right","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq ((o.kahler x) (o.rightAngleRotation y)) (HMul.hMul Complex.I ((o.kahler x) y))","decl":"@[simp]\ntheorem kahler_rightAngleRotation_right (x y : E) :\n    o.kahler x (J y) = Complex.I * o.kahler x y := by\n  simp only [o.areaForm_rightAngleRotation_right, o.inner_rightAngleRotation_right,\n    o.kahler_apply_apply, Complex.ofReal_neg, Complex.real_smul]\n  linear_combination -ω x y * Complex.I_sq\n\n-- @[simp] -- Porting note: simp normal form is `kahler_comp_rightAngleRotation'`\n"}
{"name":"Orientation.kahler_comp_rightAngleRotation","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq ((o.kahler (o.rightAngleRotation x)) (o.rightAngleRotation y)) ((o.kahler x) y)","decl":"theorem kahler_comp_rightAngleRotation (x y : E) : o.kahler (J x) (J y) = o.kahler x y := by\n  simp only [kahler_rightAngleRotation_left, kahler_rightAngleRotation_right]\n  linear_combination -o.kahler x y * Complex.I_sq\n\n"}
{"name":"Orientation.kahler_comp_rightAngleRotation'","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq (Neg.neg (HMul.hMul Complex.I (HMul.hMul Complex.I ((o.kahler x) y)))) ((o.kahler x) y)","decl":"theorem kahler_comp_rightAngleRotation' (x y : E) :\n    -(Complex.I * (Complex.I * o.kahler x y)) = o.kahler x y := by\n  linear_combination -o.kahler x y * Complex.I_sq\n\n"}
{"name":"Orientation.kahler_neg_orientation","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq (((Neg.neg o).kahler x) y) ((starRingEnd Complex) ((o.kahler x) y))","decl":"@[simp]\ntheorem kahler_neg_orientation (x y : E) : (-o).kahler x y = conj (o.kahler x y) := by\n  simp [kahler_apply_apply, Complex.conj_ofReal]\n\n"}
{"name":"Orientation.kahler_mul","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\na x y : E\n⊢ Eq (HMul.hMul ((o.kahler x) a) ((o.kahler a) y)) (HMul.hMul (HPow.hPow (↑(Norm.norm a)) 2) ((o.kahler x) y))","decl":"theorem kahler_mul (a x y : E) : o.kahler x a * o.kahler a y = ‖a‖ ^ 2 * o.kahler x y := by\n  trans ((‖a‖ ^ 2 :) : ℂ) * o.kahler x y\n  · apply Complex.ext\n    · simp only [o.kahler_apply_apply, Complex.add_im, Complex.add_re, Complex.I_im, Complex.I_re,\n        Complex.mul_im, Complex.mul_re, Complex.ofReal_im, Complex.ofReal_re, Complex.real_smul]\n      rw [real_inner_comm a x, o.areaForm_swap x a]\n      linear_combination o.inner_mul_inner_add_areaForm_mul_areaForm a x y\n    · simp only [o.kahler_apply_apply, Complex.add_im, Complex.add_re, Complex.I_im, Complex.I_re,\n        Complex.mul_im, Complex.mul_re, Complex.ofReal_im, Complex.ofReal_re, Complex.real_smul]\n      rw [real_inner_comm a x, o.areaForm_swap x a]\n      linear_combination o.inner_mul_areaForm_sub a x y\n  · norm_cast\n\n"}
{"name":"Orientation.normSq_kahler","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq (Complex.normSq ((o.kahler x) y)) (HMul.hMul (HPow.hPow (Norm.norm x) 2) (HPow.hPow (Norm.norm y) 2))","decl":"theorem normSq_kahler (x y : E) : Complex.normSq (o.kahler x y) = ‖x‖ ^ 2 * ‖y‖ ^ 2 := by\n  simpa [kahler_apply_apply, Complex.normSq, sq] using o.inner_sq_add_areaForm_sq x y\n\n"}
{"name":"Orientation.abs_kahler","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq (Complex.abs ((o.kahler x) y)) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"theorem abs_kahler (x y : E) : Complex.abs (o.kahler x y) = ‖x‖ * ‖y‖ := by\n  rw [← sq_eq_sq₀, Complex.sq_abs]\n  · linear_combination o.normSq_kahler x y\n  · positivity\n  · positivity\n\n"}
{"name":"Orientation.norm_kahler","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Eq (Norm.norm ((o.kahler x) y)) (HMul.hMul (Norm.norm x) (Norm.norm y))","decl":"theorem norm_kahler (x y : E) : ‖o.kahler x y‖ = ‖x‖ * ‖y‖ := by simpa using o.abs_kahler x y\n\n"}
{"name":"Orientation.eq_zero_or_eq_zero_of_kahler_eq_zero","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\nhx : Eq ((o.kahler x) y) 0\n⊢ Or (Eq x 0) (Eq y 0)","decl":"theorem eq_zero_or_eq_zero_of_kahler_eq_zero {x y : E} (hx : o.kahler x y = 0) : x = 0 ∨ y = 0 := by\n  have : ‖x‖ * ‖y‖ = 0 := by simpa [hx] using (o.norm_kahler x y).symm\n  cases' eq_zero_or_eq_zero_of_mul_eq_zero this with h h\n  · left\n    simpa using h\n  · right\n    simpa using h\n\n"}
{"name":"Orientation.kahler_eq_zero_iff","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Iff (Eq ((o.kahler x) y) 0) (Or (Eq x 0) (Eq y 0))","decl":"theorem kahler_eq_zero_iff (x y : E) : o.kahler x y = 0 ↔ x = 0 ∨ y = 0 := by\n  refine ⟨o.eq_zero_or_eq_zero_of_kahler_eq_zero, ?_⟩\n  rintro (rfl | rfl) <;> simp\n\n"}
{"name":"Orientation.kahler_ne_zero","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\nhx : Ne x 0\nhy : Ne y 0\n⊢ Ne ((o.kahler x) y) 0","decl":"theorem kahler_ne_zero {x y : E} (hx : x ≠ 0) (hy : y ≠ 0) : o.kahler x y ≠ 0 := by\n  apply mt o.eq_zero_or_eq_zero_of_kahler_eq_zero\n  tauto\n\n"}
{"name":"Orientation.kahler_ne_zero_iff","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nx y : E\n⊢ Iff (Ne ((o.kahler x) y) 0) (And (Ne x 0) (Ne y 0))","decl":"theorem kahler_ne_zero_iff (x y : E) : o.kahler x y ≠ 0 ↔ x ≠ 0 ∧ y ≠ 0 := by\n  refine ⟨?_, fun h => o.kahler_ne_zero h.1 h.2⟩\n  contrapose\n  simp only [not_and_or, Classical.not_not, kahler_apply_apply, Complex.real_smul]\n  rintro (rfl | rfl) <;> simp\n\n"}
{"name":"Orientation.kahler_map","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace Real E\ninst✝² : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nF : Type u_2\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace Real F\nhF : Fact (Eq (Module.finrank Real F) 2)\nφ : LinearIsometryEquiv (RingHom.id Real) E F\nx y : F\n⊢ Eq ((((Orientation.map (Fin 2) φ.toLinearEquiv) o).kahler x) y) ((o.kahler (φ.symm x)) (φ.symm y))","decl":"theorem kahler_map {F : Type*} [NormedAddCommGroup F] [InnerProductSpace ℝ F]\n    [hF : Fact (finrank ℝ F = 2)] (φ : E ≃ₗᵢ[ℝ] F) (x y : F) :\n    (Orientation.map (Fin 2) φ.toLinearEquiv o).kahler x y = o.kahler (φ.symm x) (φ.symm y) := by\n  simp [kahler_apply_apply, areaForm_map]\n\n"}
{"name":"Orientation.kahler_comp_linearIsometryEquiv","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nφ : LinearIsometryEquiv (RingHom.id Real) E E\nhφ : LT.lt 0 (LinearMap.det ↑φ.toLinearEquiv)\nx y : E\n⊢ Eq ((o.kahler (φ x)) (φ y)) ((o.kahler x) y)","decl":"/-- The bilinear map `kahler` is invariant under pullback by a positively-oriented isometric\nautomorphism. -/\ntheorem kahler_comp_linearIsometryEquiv (φ : E ≃ₗᵢ[ℝ] E)\n    (hφ : 0 < LinearMap.det (φ.toLinearEquiv : E →ₗ[ℝ] E)) (x y : E) :\n    o.kahler (φ x) (φ y) = o.kahler x y := by\n  simp [kahler_apply_apply, o.areaForm_comp_linearIsometryEquiv φ hφ]\n\n"}
{"name":"Complex.areaForm","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"w z : Complex\n⊢ Eq ((Complex.orientation.areaForm w) z) (HMul.hMul ((starRingEnd Complex) w) z).im","decl":"@[simp]\nprotected theorem areaForm (w z : ℂ) : Complex.orientation.areaForm w z = (conj w * z).im := by\n  let o := Complex.orientation\n  simp only [o, o.areaForm_to_volumeForm,\n    o.volumeForm_robust Complex.orthonormalBasisOneI rfl, Basis.det_apply, Matrix.det_fin_two,\n    Basis.toMatrix_apply, toBasis_orthonormalBasisOneI, Matrix.cons_val_zero, coe_basisOneI_repr,\n    Matrix.cons_val_one, Matrix.head_cons, mul_im, conj_re, conj_im]\n  ring\n\n"}
{"name":"Complex.rightAngleRotation","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"z : Complex\n⊢ Eq (Complex.orientation.rightAngleRotation z) (HMul.hMul Complex.I z)","decl":"@[simp]\nprotected theorem rightAngleRotation (z : ℂ) :\n    Complex.orientation.rightAngleRotation z = I * z := by\n  apply ext_inner_right ℝ\n  intro w\n  rw [Orientation.inner_rightAngleRotation_left]\n  simp only [Complex.areaForm, Complex.inner, mul_re, mul_im, conj_re, conj_im, map_mul, conj_I,\n    neg_re, neg_im, I_re, I_im]\n  ring\n\n"}
{"name":"Complex.kahler","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"w z : Complex\n⊢ Eq ((Complex.orientation.kahler w) z) (HMul.hMul ((starRingEnd Complex) w) z)","decl":"@[simp]\nprotected theorem kahler (w z : ℂ) : Complex.orientation.kahler w z = conj w * z := by\n  rw [Orientation.kahler_apply_apply]\n  apply Complex.ext <;> simp\n\n"}
{"name":"Orientation.areaForm_map_complex","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nf : LinearIsometryEquiv (RingHom.id Real) E Complex\nhf : Eq ((Orientation.map (Fin 2) f.toLinearEquiv) o) Complex.orientation\nx y : E\n⊢ Eq ((o.areaForm x) y) (HMul.hMul ((starRingEnd Complex) (f x)) (f y)).im","decl":"/-- The area form on an oriented real inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem areaForm_map_complex (f : E ≃ₗᵢ[ℝ] ℂ)\n    (hf : Orientation.map (Fin 2) f.toLinearEquiv o = Complex.orientation) (x y : E) :\n    ω x y = (conj (f x) * f y).im := by\n  rw [← Complex.areaForm, ← hf, areaForm_map (hF := _)]\n  iterate 2 rw [LinearIsometryEquiv.symm_apply_apply]\n\n"}
{"name":"Orientation.rightAngleRotation_map_complex","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nf : LinearIsometryEquiv (RingHom.id Real) E Complex\nhf : Eq ((Orientation.map (Fin 2) f.toLinearEquiv) o) Complex.orientation\nx : E\n⊢ Eq (f (o.rightAngleRotation x)) (HMul.hMul Complex.I (f x))","decl":"/-- The rotation by 90 degrees on an oriented real inner product space of dimension 2 can be\nevaluated in terms of a complex-number representation of the space. -/\ntheorem rightAngleRotation_map_complex (f : E ≃ₗᵢ[ℝ] ℂ)\n    (hf : Orientation.map (Fin 2) f.toLinearEquiv o = Complex.orientation) (x : E) :\n    f (J x) = I * f x := by\n  rw [← Complex.rightAngleRotation, ← hf, rightAngleRotation_map (hF := _),\n    LinearIsometryEquiv.symm_apply_apply]\n\n"}
{"name":"Orientation.kahler_map_complex","module":"Mathlib.Analysis.InnerProductSpace.TwoDim","initialProofState":"E : Type u_1\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace Real E\ninst✝ : Fact (Eq (Module.finrank Real E) 2)\no : Orientation Real E (Fin 2)\nf : LinearIsometryEquiv (RingHom.id Real) E Complex\nhf : Eq ((Orientation.map (Fin 2) f.toLinearEquiv) o) Complex.orientation\nx y : E\n⊢ Eq ((o.kahler x) y) (HMul.hMul ((starRingEnd Complex) (f x)) (f y))","decl":"/-- The Kahler form on an oriented real inner product space of dimension 2 can be evaluated in terms\nof a complex-number representation of the space. -/\ntheorem kahler_map_complex (f : E ≃ₗᵢ[ℝ] ℂ)\n    (hf : Orientation.map (Fin 2) f.toLinearEquiv o = Complex.orientation) (x y : E) :\n    o.kahler x y = conj (f x) * f y := by\n  rw [← Complex.kahler, ← hf, kahler_map (hF := _)]\n  iterate 2 rw [LinearIsometryEquiv.symm_apply_apply]\n\n"}
