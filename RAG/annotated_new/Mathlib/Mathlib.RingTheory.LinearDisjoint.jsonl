{"name":"Subalgebra.linearDisjoint_iff","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nA B : Subalgebra R S\n⊢ Iff (A.LinearDisjoint B) ((Subalgebra.toSubmodule A).LinearDisjoint (Subalgebra.toSubmodule B))","decl":"theorem linearDisjoint_iff : A.LinearDisjoint B ↔ (toSubmodule A).LinearDisjoint (toSubmodule B) :=\n  Iff.rfl\n\n"}
{"name":"Subalgebra.LinearDisjoint.of_subsingleton","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommSemiring R\ninst✝² : Semiring S\ninst✝¹ : Algebra R S\nA B : Subalgebra R S\ninst✝ : Subsingleton R\n⊢ A.LinearDisjoint B","decl":"@[nontriviality]\ntheorem LinearDisjoint.of_subsingleton [Subsingleton R] : A.LinearDisjoint B :=\n  Submodule.LinearDisjoint.of_subsingleton\n\n"}
{"name":"Subalgebra.LinearDisjoint.of_subsingleton_top","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommSemiring R\ninst✝² : Semiring S\ninst✝¹ : Algebra R S\nA B : Subalgebra R S\ninst✝ : Subsingleton S\n⊢ A.LinearDisjoint B","decl":"@[nontriviality]\ntheorem LinearDisjoint.of_subsingleton_top [Subsingleton S] : A.LinearDisjoint B :=\n  Submodule.LinearDisjoint.of_subsingleton_top\n\n"}
{"name":"Subalgebra.LinearDisjoint.symm_of_commute","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\nhc : ∀ (a : Subtype fun x => Membership.mem A x) (b : Subtype fun x => Membership.mem B x), Commute ↑a ↑b\n⊢ B.LinearDisjoint A","decl":"/-- Linear disjointness is symmetric if elements in the module commute. -/\ntheorem LinearDisjoint.symm_of_commute (H : A.LinearDisjoint B)\n    (hc : ∀ (a : A) (b : B), Commute a.1 b.1) : B.LinearDisjoint A :=\n  Submodule.LinearDisjoint.symm_of_commute H hc\n\n"}
{"name":"Subalgebra.linearDisjoint_comm_of_commute","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nA B : Subalgebra R S\nhc : ∀ (a : Subtype fun x => Membership.mem A x) (b : Subtype fun x => Membership.mem B x), Commute ↑a ↑b\n⊢ Iff (A.LinearDisjoint B) (B.LinearDisjoint A)","decl":"/-- Linear disjointness is symmetric if elements in the module commute. -/\ntheorem linearDisjoint_comm_of_commute\n    (hc : ∀ (a : A) (b : B), Commute a.1 b.1) : A.LinearDisjoint B ↔ B.LinearDisjoint A :=\n  ⟨fun H ↦ H.symm_of_commute hc, fun H ↦ H.symm_of_commute fun _ _ ↦ (hc _ _).symm⟩\n\n"}
{"name":"Subalgebra.LinearDisjoint.map","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring S\ninst✝² : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\nT : Type w\ninst✝¹ : Semiring T\ninst✝ : Algebra R T\nf : AlgHom R S T\nhf : Function.Injective ⇑f\n⊢ (Subalgebra.map f A).LinearDisjoint (Subalgebra.map f B)","decl":"/-- Linear disjointness is preserved by injective algebra homomorphisms. -/\ntheorem map (H : A.LinearDisjoint B) {T : Type w} [Semiring T] [Algebra R T]\n    (f : S →ₐ[R] T) (hf : Function.Injective f) : (A.map f).LinearDisjoint (B.map f) :=\n  Submodule.LinearDisjoint.map H f hf\n\n"}
{"name":"Subalgebra.LinearDisjoint.bot_left","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nB : Subalgebra R S\n⊢ Bot.bot.LinearDisjoint B","decl":"/-- The image of `R` in `S` is linearly disjoint with any other subalgebras. -/\ntheorem bot_left : (⊥ : Subalgebra R S).LinearDisjoint B := by\n  rw [Subalgebra.LinearDisjoint, Algebra.toSubmodule_bot]\n  exact Submodule.LinearDisjoint.one_left _\n\n"}
{"name":"Subalgebra.LinearDisjoint.bot_right","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nA : Subalgebra R S\n⊢ A.LinearDisjoint Bot.bot","decl":"/-- The image of `R` in `S` is linearly disjoint with any other subalgebras. -/\ntheorem bot_right : A.LinearDisjoint ⊥ := by\n  rw [Subalgebra.LinearDisjoint, Algebra.toSubmodule_bot]\n  exact Submodule.LinearDisjoint.one_right _\n\n"}
{"name":"Subalgebra.LinearDisjoint.include_range","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\ninst✝⁴ : CommSemiring R\nA : Type v\ninst✝³ : Semiring A\nB : Type w\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\n⊢ Algebra.TensorProduct.includeLeft.range.LinearDisjoint Algebra.TensorProduct.includeRight.range","decl":"variable (R) in\n/-- Images of two `R`-algebras `A` and `B` in `A ⊗[R] B` are linearly disjoint. -/\ntheorem include_range (A : Type v) [Semiring A] (B : Type w) [Semiring B]\n    [Algebra R A] [Algebra R B] :\n    (Algebra.TensorProduct.includeLeft : A →ₐ[R] A ⊗[R] B).range.LinearDisjoint\n      (Algebra.TensorProduct.includeRight : B →ₐ[R] A ⊗[R] B).range := by\n  rw [Subalgebra.LinearDisjoint, Submodule.linearDisjoint_iff]\n  change Function.Injective <|\n    Submodule.mulMap (LinearMap.range Algebra.TensorProduct.includeLeft)\n      (LinearMap.range Algebra.TensorProduct.includeRight)\n  rw [← Algebra.TensorProduct.linearEquivIncludeRange_symm_toLinearMap]\n  exact LinearEquiv.injective _\n\n"}
{"name":"Subalgebra.LinearDisjoint.symm","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\n⊢ B.LinearDisjoint A","decl":"/-- Linear disjointness is symmetric in a commutative ring. -/\ntheorem LinearDisjoint.symm (H : A.LinearDisjoint B) : B.LinearDisjoint A :=\n  H.symm_of_commute fun _ _ ↦ mul_comm _ _\n\n"}
{"name":"Subalgebra.linearDisjoint_comm","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nA B : Subalgebra R S\n⊢ Iff (A.LinearDisjoint B) (B.LinearDisjoint A)","decl":"/-- Linear disjointness is symmetric in a commutative ring. -/\ntheorem linearDisjoint_comm : A.LinearDisjoint B ↔ B.LinearDisjoint A :=\n  ⟨LinearDisjoint.symm, LinearDisjoint.symm⟩\n\n"}
{"name":"Subalgebra.linearDisjoint_iff_injective","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nA B : Subalgebra R S\n⊢ Iff (A.LinearDisjoint B) (Function.Injective ⇑(A.mulMap B))","decl":"/-- Two subalgebras `A`, `B` in a commutative ring are linearly disjoint if and only if\n`Subalgebra.mulMap A B` is injective. -/\ntheorem linearDisjoint_iff_injective : A.LinearDisjoint B ↔ Function.Injective (A.mulMap B) := by\n  rw [linearDisjoint_iff, Submodule.linearDisjoint_iff]\n  rfl\n\n"}
{"name":"Subalgebra.LinearDisjoint.val_mulMap_tmul","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\na : Subtype fun x => Membership.mem A x\nb : Subtype fun x => Membership.mem B x\n⊢ Eq (↑(H.mulMap (TensorProduct.tmul R a b))) (HMul.hMul ↑a ↑b)","decl":"@[simp]\ntheorem val_mulMap_tmul (a : A) (b : B) : (H.mulMap (a ⊗ₜ[R] b) : S) = a.1 * b.1 := rfl\n\n"}
{"name":"Subalgebra.LinearDisjoint.sup_free_of_free","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommSemiring R\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\ninst✝¹ : Module.Free R (Subtype fun x => Membership.mem A x)\ninst✝ : Module.Free R (Subtype fun x => Membership.mem B x)\n⊢ Module.Free R (Subtype fun x => Membership.mem (Max.max A B) x)","decl":"include H in\n/-- If `A` and `B` are subalgebras in a commutative algebra `S` over `R`, and if they are\nlinearly disjoint, and if they are free `R`-modules, then `A ⊔ B` is also a free `R`-module. -/\ntheorem sup_free_of_free [Module.Free R A] [Module.Free R B] : Module.Free R ↥(A ⊔ B) :=\n  Module.Free.of_equiv H.mulMap.toLinearEquiv\n\n"}
{"name":"Subalgebra.LinearDisjoint.isDomain","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommSemiring R\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\ninst✝ : IsDomain S\n⊢ IsDomain (TensorProduct R (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x))","decl":"include H in\n/-- If `A` and `B` are subalgebras in a domain `S` over `R`, and if they are\nlinearly disjoint, then `A ⊗[R] B` is also a domain. -/\ntheorem isDomain [IsDomain S] : IsDomain (A ⊗[R] B) :=\n  H.injective.isDomain (A.mulMap B).toRingHom\n\n"}
{"name":"Subalgebra.LinearDisjoint.isDomain_of_injective","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝⁷ : CommSemiring R\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra R S\ninst✝⁴ : IsDomain S\nA : Type u_1\nB : Type u_2\ninst✝³ : Semiring A\ninst✝² : Semiring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nfa : AlgHom R A S\nfb : AlgHom R B S\nhfa : Function.Injective ⇑fa\nhfb : Function.Injective ⇑fb\nH : fa.range.LinearDisjoint fb.range\n⊢ IsDomain (TensorProduct R A B)","decl":"/-- If `A` and `B` are `R`-algebras, such that there exists a domain `S` over `R`\nsuch that `A` and `B` inject into it and their images are linearly disjoint,\nthen `A ⊗[R] B` is also a domain. -/\ntheorem isDomain_of_injective [IsDomain S] {A B : Type*} [Semiring A] [Semiring B]\n    [Algebra R A] [Algebra R B] {fa : A →ₐ[R] S} {fb : B →ₐ[R] S}\n    (hfa : Function.Injective fa) (hfb : Function.Injective fb)\n    (H : fa.range.LinearDisjoint fb.range) : IsDomain (A ⊗[R] B) :=\n  have := H.isDomain\n  (Algebra.TensorProduct.congr\n    (AlgEquiv.ofInjective fa hfa) (AlgEquiv.ofInjective fb hfb)).toMulEquiv.isDomain\n\n"}
{"name":"Subalgebra.LinearDisjoint.mulLeftMap_ker_eq_bot_iff_linearIndependent_op","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nA B : Subalgebra R S\nι : Type u_1\na : ι → Subtype fun x => Membership.mem A x\n⊢ Iff (Eq (LinearMap.ker (Submodule.mulLeftMap (Subalgebra.toSubmodule B) a)) Bot.bot) (LinearIndependent (Subtype fun x => Membership.mem B.op x) (Function.comp MulOpposite.op (Function.comp (⇑A.val) a)))","decl":"set_option maxSynthPendingDepth 2 in\nlemma mulLeftMap_ker_eq_bot_iff_linearIndependent_op {ι : Type*} (a : ι → A) :\n    LinearMap.ker (Submodule.mulLeftMap (M := toSubmodule A) (toSubmodule B) a) = ⊥ ↔\n    LinearIndependent B.op (MulOpposite.op ∘ A.val ∘ a) := by\n  simp_rw [LinearIndependent, LinearMap.ker_eq_bot]\n  let i : (ι →₀ B) →ₗ[R] S := Submodule.mulLeftMap (M := toSubmodule A) (toSubmodule B) a\n  let j : (ι →₀ B) →ₗ[R] S := (MulOpposite.opLinearEquiv _).symm.toLinearMap ∘ₗ\n    (Finsupp.linearCombination B.op (MulOpposite.op ∘ A.val ∘ a)).restrictScalars R ∘ₗ\n    (Finsupp.mapRange.linearEquiv (linearEquivOp B)).toLinearMap\n  suffices i = j by\n    change Function.Injective i ↔ _\n    simp_rw [this, j, LinearMap.coe_comp, LinearEquiv.coe_coe, EquivLike.comp_injective,\n      EquivLike.injective_comp, LinearMap.coe_restrictScalars]\n  ext\n  simp only [LinearMap.coe_comp, Function.comp_apply, Finsupp.lsingle_apply, coe_val,\n    Finsupp.mapRange.linearEquiv_toLinearMap, LinearEquiv.coe_coe,\n    MulOpposite.coe_opLinearEquiv_symm, LinearMap.coe_restrictScalars,\n    Finsupp.mapRange.linearMap_apply, Finsupp.mapRange_single, Finsupp.linearCombination_single,\n    MulOpposite.unop_smul, MulOpposite.unop_op, i, j]\n  exact Submodule.mulLeftMap_apply_single _ _ _\n\n"}
{"name":"Subalgebra.LinearDisjoint.linearIndependent_left_op_of_flat","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem B x)\nι : Type u_1\na : ι → Subtype fun x => Membership.mem A x\nha : LinearIndependent R a\n⊢ LinearIndependent (Subtype fun x => Membership.mem B.op x) (Function.comp MulOpposite.op (Function.comp (⇑A.val) a))","decl":"variable {A B} in\n/-- If `A` and `B` are linearly disjoint, if `B` is a flat `R`-module, then for any family of\n`R`-linearly independent elements of `A`, they are also `B`-linearly independent\nin the opposite ring. -/\ntheorem linearIndependent_left_op_of_flat (H : A.LinearDisjoint B) [Module.Flat R B]\n    {ι : Type*} {a : ι → A} (ha : LinearIndependent R a) :\n    LinearIndependent B.op (MulOpposite.op ∘ A.val ∘ a) := by\n  have h := Submodule.LinearDisjoint.linearIndependent_left_of_flat H ha\n  rwa [mulLeftMap_ker_eq_bot_iff_linearIndependent_op] at h\n\n"}
{"name":"Subalgebra.LinearDisjoint.of_basis_left_op","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nA B : Subalgebra R S\nι : Type u_1\na : Basis ι R (Subtype fun x => Membership.mem A x)\nH : LinearIndependent (Subtype fun x => Membership.mem B.op x) (Function.comp MulOpposite.op (Function.comp ⇑A.val ⇑a))\n⊢ A.LinearDisjoint B","decl":"/-- If a basis of `A` is also `B`-linearly independent in the opposite ring,\nthen `A` and `B` are linearly disjoint. -/\ntheorem of_basis_left_op {ι : Type*} (a : Basis ι R A)\n    (H : LinearIndependent B.op (MulOpposite.op ∘ A.val ∘ a)) :\n    A.LinearDisjoint B := by\n  rw [← mulLeftMap_ker_eq_bot_iff_linearIndependent_op] at H\n  exact Submodule.LinearDisjoint.of_basis_left _ _ a H\n\n"}
{"name":"Subalgebra.LinearDisjoint.mulRightMap_ker_eq_bot_iff_linearIndependent","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nA B : Subalgebra R S\nι : Type u_1\nb : ι → Subtype fun x => Membership.mem B x\n⊢ Iff (Eq (LinearMap.ker ((Subalgebra.toSubmodule A).mulRightMap b)) Bot.bot) (LinearIndependent (Subtype fun x => Membership.mem A x) (Function.comp (⇑B.val) b))","decl":"set_option maxSynthPendingDepth 2 in\nlemma mulRightMap_ker_eq_bot_iff_linearIndependent {ι : Type*} (b : ι → B) :\n    LinearMap.ker (Submodule.mulRightMap (toSubmodule A) (N := toSubmodule B) b) = ⊥ ↔\n    LinearIndependent A (B.val ∘ b) := by\n  simp_rw [LinearIndependent, LinearMap.ker_eq_bot]\n  let i : (ι →₀ A) →ₗ[R] S := Submodule.mulRightMap (toSubmodule A) (N := toSubmodule B) b\n  let j : (ι →₀ A) →ₗ[R] S := (Finsupp.linearCombination A (B.val ∘ b)).restrictScalars R\n  suffices i = j by change Function.Injective i ↔ Function.Injective j; rw [this]\n  ext\n  simp only [LinearMap.coe_comp, Function.comp_apply, Finsupp.lsingle_apply, coe_val,\n    LinearMap.coe_restrictScalars, Finsupp.linearCombination_single, i, j]\n  exact Submodule.mulRightMap_apply_single _ _ _\n\n"}
{"name":"Subalgebra.LinearDisjoint.linearIndependent_right_of_flat","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem A x)\nι : Type u_1\nb : ι → Subtype fun x => Membership.mem B x\nhb : LinearIndependent R b\n⊢ LinearIndependent (Subtype fun x => Membership.mem A x) (Function.comp (⇑B.val) b)","decl":"variable {A B} in\n/-- If `A` and `B` are linearly disjoint, if `A` is a flat `R`-module, then for any family of\n`R`-linearly independent elements of `B`, they are also `A`-linearly independent. -/\ntheorem linearIndependent_right_of_flat (H : A.LinearDisjoint B) [Module.Flat R A]\n    {ι : Type*} {b : ι → B} (hb : LinearIndependent R b) :\n    LinearIndependent A (B.val ∘ b) := by\n  have h := Submodule.LinearDisjoint.linearIndependent_right_of_flat H hb\n  rwa [mulRightMap_ker_eq_bot_iff_linearIndependent] at h\n\n"}
{"name":"Subalgebra.LinearDisjoint.of_basis_right","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nA B : Subalgebra R S\nι : Type u_1\nb : Basis ι R (Subtype fun x => Membership.mem B x)\nH : LinearIndependent (Subtype fun x => Membership.mem A x) (Function.comp ⇑B.val ⇑b)\n⊢ A.LinearDisjoint B","decl":"/-- If a basis of `B` is also `A`-linearly independent, then `A` and `B` are linearly disjoint. -/\ntheorem of_basis_right {ι : Type*} (b : Basis ι R B)\n    (H : LinearIndependent A (B.val ∘ b)) : A.LinearDisjoint B := by\n  rw [← mulRightMap_ker_eq_bot_iff_linearIndependent] at H\n  exact Submodule.LinearDisjoint.of_basis_right _ _ b H\n\n"}
{"name":"Subalgebra.LinearDisjoint.linearIndependent_left_of_flat_of_commute","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem B x)\nι : Type u_1\na : ι → Subtype fun x => Membership.mem A x\nha : LinearIndependent R a\nhc : ∀ (a : Subtype fun x => Membership.mem A x) (b : Subtype fun x => Membership.mem B x), Commute ↑a ↑b\n⊢ LinearIndependent (Subtype fun x => Membership.mem B x) (Function.comp (⇑A.val) a)","decl":"variable {A B} in\n/-- If `A` and `B` are linearly disjoint and their elements commute, if `B` is a flat `R`-module,\nthen for any family of `R`-linearly independent elements of `A`,\nthey are also `B`-linearly independent. -/\ntheorem linearIndependent_left_of_flat_of_commute (H : A.LinearDisjoint B) [Module.Flat R B]\n    {ι : Type*} {a : ι → A} (ha : LinearIndependent R a)\n    (hc : ∀ (a : A) (b : B), Commute a.1 b.1) : LinearIndependent B (A.val ∘ a) :=\n  (H.symm_of_commute hc).linearIndependent_right_of_flat ha\n\n"}
{"name":"Subalgebra.LinearDisjoint.of_basis_left_of_commute","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nA B : Subalgebra R S\nι : Type u_1\na : Basis ι R (Subtype fun x => Membership.mem A x)\nH : LinearIndependent (Subtype fun x => Membership.mem B x) (Function.comp ⇑A.val ⇑a)\nhc : ∀ (a : Subtype fun x => Membership.mem A x) (b : Subtype fun x => Membership.mem B x), Commute ↑a ↑b\n⊢ A.LinearDisjoint B","decl":"/-- If a basis of `A` is also `B`-linearly independent, if elements in `A` and `B` commute,\nthen `A` and `B` are linearly disjoint. -/\ntheorem of_basis_left_of_commute {ι : Type*} (a : Basis ι R A)\n    (H : LinearIndependent B (A.val ∘ a)) (hc : ∀ (a : A) (b : B), Commute a.1 b.1) :\n    A.LinearDisjoint B :=\n  (of_basis_right B A a H).symm_of_commute fun _ _ ↦ (hc _ _).symm\n\n"}
{"name":"Subalgebra.LinearDisjoint.linearIndependent_mul_of_flat_left","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem A x)\nκ : Type u_1\nι : Type u_2\na : κ → Subtype fun x => Membership.mem A x\nb : ι → Subtype fun x => Membership.mem B x\nha : LinearIndependent R a\nhb : LinearIndependent R b\n⊢ LinearIndependent R fun i => HMul.hMul ↑(a i.1) ↑(b i.2)","decl":"variable {A B} in\n/-- If `A` and `B` are linearly disjoint, if `A` is flat, then for any family of\n`R`-linearly independent elements `{ a_i }` of `A`, and any family of\n`R`-linearly independent elements `{ b_j }` of `B`, the family `{ a_i * b_j }` in `S` is\nalso `R`-linearly independent. -/\ntheorem linearIndependent_mul_of_flat_left (H : A.LinearDisjoint B) [Module.Flat R A]\n    {κ ι : Type*} {a : κ → A} {b : ι → B} (ha : LinearIndependent R a)\n    (hb : LinearIndependent R b) : LinearIndependent R fun (i : κ × ι) ↦ (a i.1).1 * (b i.2).1 :=\n  Submodule.LinearDisjoint.linearIndependent_mul_of_flat_left H ha hb\n\n"}
{"name":"Subalgebra.LinearDisjoint.linearIndependent_mul_of_flat_right","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem B x)\nκ : Type u_1\nι : Type u_2\na : κ → Subtype fun x => Membership.mem A x\nb : ι → Subtype fun x => Membership.mem B x\nha : LinearIndependent R a\nhb : LinearIndependent R b\n⊢ LinearIndependent R fun i => HMul.hMul ↑(a i.1) ↑(b i.2)","decl":"variable {A B} in\n/-- If `A` and `B` are linearly disjoint, if `B` is flat, then for any family of\n`R`-linearly independent elements `{ a_i }` of `A`, and any family of\n`R`-linearly independent elements `{ b_j }` of `B`, the family `{ a_i * b_j }` in `S` is\nalso `R`-linearly independent. -/\ntheorem linearIndependent_mul_of_flat_right (H : A.LinearDisjoint B) [Module.Flat R B]\n    {κ ι : Type*} {a : κ → A} {b : ι → B} (ha : LinearIndependent R a)\n    (hb : LinearIndependent R b) : LinearIndependent R fun (i : κ × ι) ↦ (a i.1).1 * (b i.2).1 :=\n  Submodule.LinearDisjoint.linearIndependent_mul_of_flat_right H ha hb\n\n"}
{"name":"Subalgebra.LinearDisjoint.linearIndependent_mul_of_flat","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\nhf : Or (Module.Flat R (Subtype fun x => Membership.mem A x)) (Module.Flat R (Subtype fun x => Membership.mem B x))\nκ : Type u_1\nι : Type u_2\na : κ → Subtype fun x => Membership.mem A x\nb : ι → Subtype fun x => Membership.mem B x\nha : LinearIndependent R a\nhb : LinearIndependent R b\n⊢ LinearIndependent R fun i => HMul.hMul ↑(a i.1) ↑(b i.2)","decl":"variable {A B} in\n/-- If `A` and `B` are linearly disjoint, if one of `A` and `B` is flat, then for any family of\n`R`-linearly independent elements `{ a_i }` of `A`, and any family of\n`R`-linearly independent elements `{ b_j }` of `B`, the family `{ a_i * b_j }` in `S` is\nalso `R`-linearly independent. -/\ntheorem linearIndependent_mul_of_flat (H : A.LinearDisjoint B)\n    (hf : Module.Flat R A ∨ Module.Flat R B)\n    {κ ι : Type*} {a : κ → A} {b : ι → B} (ha : LinearIndependent R a)\n    (hb : LinearIndependent R b) : LinearIndependent R fun (i : κ × ι) ↦ (a i.1).1 * (b i.2).1 :=\n  Submodule.LinearDisjoint.linearIndependent_mul_of_flat H hf ha hb\n\n"}
{"name":"Subalgebra.LinearDisjoint.of_basis_mul","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nA B : Subalgebra R S\nκ : Type u_1\nι : Type u_2\na : Basis κ R (Subtype fun x => Membership.mem A x)\nb : Basis ι R (Subtype fun x => Membership.mem B x)\nH : LinearIndependent R fun i => HMul.hMul ↑(a i.1) ↑(b i.2)\n⊢ A.LinearDisjoint B","decl":"/-- If `{ a_i }` is an `R`-basis of `A`, if `{ b_j }` is an `R`-basis of `B`,\nsuch that the family `{ a_i * b_j }` in `S` is `R`-linearly independent,\nthen `A` and `B` are linearly disjoint. -/\ntheorem of_basis_mul {κ ι : Type*} (a : Basis κ R A) (b : Basis ι R B)\n    (H : LinearIndependent R fun (i : κ × ι) ↦ (a i.1).1 * (b i.2).1) : A.LinearDisjoint B :=\n  Submodule.LinearDisjoint.of_basis_mul _ _ a b H\n\n"}
{"name":"Subalgebra.LinearDisjoint.of_le_left_of_flat","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\nA' : Subalgebra R S\nh : LE.le A' A\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem B x)\n⊢ A'.LinearDisjoint B","decl":"theorem of_le_left_of_flat {A' : Subalgebra R S}\n    (h : A' ≤ A) [Module.Flat R B] : A'.LinearDisjoint B :=\n  Submodule.LinearDisjoint.of_le_left_of_flat H h\n\n"}
{"name":"Subalgebra.LinearDisjoint.of_le_right_of_flat","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\nB' : Subalgebra R S\nh : LE.le B' B\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem A x)\n⊢ A.LinearDisjoint B'","decl":"theorem of_le_right_of_flat {B' : Subalgebra R S}\n    (h : B' ≤ B) [Module.Flat R A] : A.LinearDisjoint B' :=\n  Submodule.LinearDisjoint.of_le_right_of_flat H h\n\n"}
{"name":"Subalgebra.LinearDisjoint.of_le_of_flat_right","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\ninst✝² : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\nA' B' : Subalgebra R S\nha : LE.le A' A\nhb : LE.le B' B\ninst✝¹ : Module.Flat R (Subtype fun x => Membership.mem B x)\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem A' x)\n⊢ A'.LinearDisjoint B'","decl":"theorem of_le_of_flat_right {A' B' : Subalgebra R S}\n    (ha : A' ≤ A) (hb : B' ≤ B) [Module.Flat R B] [Module.Flat R A'] :\n    A'.LinearDisjoint B' := (H.of_le_left_of_flat ha).of_le_right_of_flat hb\n\n"}
{"name":"Subalgebra.LinearDisjoint.of_le_of_flat_left","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\ninst✝² : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\nA' B' : Subalgebra R S\nha : LE.le A' A\nhb : LE.le B' B\ninst✝¹ : Module.Flat R (Subtype fun x => Membership.mem A x)\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem B' x)\n⊢ A'.LinearDisjoint B'","decl":"theorem of_le_of_flat_left {A' B' : Subalgebra R S}\n    (ha : A' ≤ A) (hb : B' ≤ B) [Module.Flat R A] [Module.Flat R B'] :\n    A'.LinearDisjoint B' := (H.of_le_right_of_flat hb).of_le_left_of_flat ha\n\n"}
{"name":"Subalgebra.LinearDisjoint.rank_inf_eq_one_of_commute_of_flat_of_inj","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\nhf : Or (Module.Flat R (Subtype fun x => Membership.mem A x)) (Module.Flat R (Subtype fun x => Membership.mem B x))\nhc : ∀ (a b : Subtype fun x => Membership.mem (Min.min A B) x), Commute ↑a ↑b\nhinj : Function.Injective ⇑(algebraMap R S)\n⊢ Eq (Module.rank R (Subtype fun x => Membership.mem (Min.min A B) x)) 1","decl":"theorem rank_inf_eq_one_of_commute_of_flat_of_inj (hf : Module.Flat R A ∨ Module.Flat R B)\n    (hc : ∀ (a b : ↥(A ⊓ B)), Commute a.1 b.1)\n    (hinj : Function.Injective (algebraMap R S)) : Module.rank R ↥(A ⊓ B) = 1 := by\n  nontriviality R\n  refine le_antisymm (Submodule.LinearDisjoint.rank_inf_le_one_of_commute_of_flat H hf hc) ?_\n  have : Cardinal.lift.{u} (Module.rank R (⊥ : Subalgebra R S)) =\n      Cardinal.lift.{v} (Module.rank R R) :=\n    lift_rank_range_of_injective (Algebra.linearMap R S) hinj\n  rw [Module.rank_self, Cardinal.lift_one, Cardinal.lift_eq_one] at this\n  rw [← this]\n  change Module.rank R (toSubmodule (⊥ : Subalgebra R S)) ≤\n    Module.rank R (toSubmodule (A ⊓ B))\n  exact Submodule.rank_mono (bot_le : (⊥ : Subalgebra R S) ≤ A ⊓ B)\n\n"}
{"name":"Subalgebra.LinearDisjoint.rank_inf_eq_one_of_commute_of_flat_left_of_inj","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem A x)\nhc : ∀ (a b : Subtype fun x => Membership.mem (Min.min A B) x), Commute ↑a ↑b\nhinj : Function.Injective ⇑(algebraMap R S)\n⊢ Eq (Module.rank R (Subtype fun x => Membership.mem (Min.min A B) x)) 1","decl":"theorem rank_inf_eq_one_of_commute_of_flat_left_of_inj [Module.Flat R A]\n    (hc : ∀ (a b : ↥(A ⊓ B)), Commute a.1 b.1)\n    (hinj : Function.Injective (algebraMap R S)) : Module.rank R ↥(A ⊓ B) = 1 :=\n  H.rank_inf_eq_one_of_commute_of_flat_of_inj (Or.inl ‹_›) hc hinj\n\n"}
{"name":"Subalgebra.LinearDisjoint.rank_inf_eq_one_of_commute_of_flat_right_of_inj","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem B x)\nhc : ∀ (a b : Subtype fun x => Membership.mem (Min.min A B) x), Commute ↑a ↑b\nhinj : Function.Injective ⇑(algebraMap R S)\n⊢ Eq (Module.rank R (Subtype fun x => Membership.mem (Min.min A B) x)) 1","decl":"theorem rank_inf_eq_one_of_commute_of_flat_right_of_inj [Module.Flat R B]\n    (hc : ∀ (a b : ↥(A ⊓ B)), Commute a.1 b.1)\n    (hinj : Function.Injective (algebraMap R S)) : Module.rank R ↥(A ⊓ B) = 1 :=\n  H.rank_inf_eq_one_of_commute_of_flat_of_inj (Or.inr ‹_›) hc hinj\n\n"}
{"name":"Subalgebra.LinearDisjoint.rank_eq_one_of_commute_of_flat_of_self_of_inj","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nA : Subalgebra R S\nH : A.LinearDisjoint A\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem A x)\nhc : ∀ (a b : Subtype fun x => Membership.mem A x), Commute ↑a ↑b\nhinj : Function.Injective ⇑(algebraMap R S)\n⊢ Eq (Module.rank R (Subtype fun x => Membership.mem A x)) 1","decl":"theorem rank_eq_one_of_commute_of_flat_of_self_of_inj (H : A.LinearDisjoint A) [Module.Flat R A]\n    (hc : ∀ (a b : A), Commute a.1 b.1)\n    (hinj : Function.Injective (algebraMap R S)) : Module.rank R A = 1 := by\n  rw [← inf_of_le_left (le_refl A)] at hc ⊢\n  exact H.rank_inf_eq_one_of_commute_of_flat_left_of_inj hc hinj\n\n"}
{"name":"Subalgebra.LinearDisjoint.linearIndependent_left_of_flat","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem B x)\nι : Type u_1\na : ι → Subtype fun x => Membership.mem A x\nha : LinearIndependent R a\n⊢ LinearIndependent (Subtype fun x => Membership.mem B x) (Function.comp (⇑A.val) a)","decl":"variable {A B} in\n/-- In a commutative ring, if `A` and `B` are linearly disjoint, if `B` is a flat `R`-module,\nthen for any family of `R`-linearly independent elements of `A`,\nthey are also `B`-linearly independent. -/\ntheorem linearIndependent_left_of_flat (H : A.LinearDisjoint B) [Module.Flat R B]\n    {ι : Type*} {a : ι → A} (ha : LinearIndependent R a) : LinearIndependent B (A.val ∘ a) :=\n  H.linearIndependent_left_of_flat_of_commute ha fun _ _ ↦ mul_comm _ _\n\n"}
{"name":"Subalgebra.LinearDisjoint.of_basis_left","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nA B : Subalgebra R S\nι : Type u_1\na : Basis ι R (Subtype fun x => Membership.mem A x)\nH : LinearIndependent (Subtype fun x => Membership.mem B x) (Function.comp ⇑A.val ⇑a)\n⊢ A.LinearDisjoint B","decl":"/-- In a commutative ring, if a basis of `A` is also `B`-linearly independent,\nthen `A` and `B` are linearly disjoint. -/\ntheorem of_basis_left {ι : Type*} (a : Basis ι R A)\n    (H : LinearIndependent B (A.val ∘ a)) : A.LinearDisjoint B :=\n  of_basis_left_of_commute A B a H fun _ _ ↦ mul_comm _ _\n\n"}
{"name":"Subalgebra.LinearDisjoint.exists_field_of_isDomain_of_injective","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\ninst✝⁷ : CommRing R\nA : Type v\ninst✝⁶ : CommRing A\nB : Type w\ninst✝⁵ : CommRing B\ninst✝⁴ : Algebra R A\ninst✝³ : Algebra R B\ninst✝² : Module.Flat R A\ninst✝¹ : Module.Flat R B\ninst✝ : IsDomain (TensorProduct R A B)\nha : Function.Injective ⇑(algebraMap R A)\nhb : Function.Injective ⇑(algebraMap R B)\n⊢ Exists fun K => Exists fun x => Exists fun x_1 => Exists fun fa => Exists fun fb => And (Function.Injective ⇑fa) (And (Function.Injective ⇑fb) (fa.range.LinearDisjoint fb.range))","decl":"variable (R) in\n/-- If `A` and `B` are flat algebras over `R`, such that `A ⊗[R] B` is a domain, and such that\nthe algebra maps are injective, then there exists an `R`-algebra `K` that is a field that `A`\nand `B` inject into with linearly disjoint images. Note: `K` can chosen to be the\nfraction field of `A ⊗[R] B`, but here we hide this fact. -/\ntheorem exists_field_of_isDomain_of_injective (A : Type v) [CommRing A] (B : Type w) [CommRing B]\n    [Algebra R A] [Algebra R B] [Module.Flat R A] [Module.Flat R B] [IsDomain (A ⊗[R] B)]\n    (ha : Function.Injective (algebraMap R A)) (hb : Function.Injective (algebraMap R B)) :\n    ∃ (K : Type (max v w)) (_ : Field K) (_ : Algebra R K) (fa : A →ₐ[R] K) (fb : B →ₐ[R] K),\n    Function.Injective fa ∧ Function.Injective fb ∧ fa.range.LinearDisjoint fb.range :=\n  let K := FractionRing (A ⊗[R] B)\n  let i := IsScalarTower.toAlgHom R (A ⊗[R] B) K\n  have hi : Function.Injective i := IsFractionRing.injective (A ⊗[R] B) K\n  ⟨K, inferInstance, inferInstance,\n    i.comp Algebra.TensorProduct.includeLeft,\n    i.comp Algebra.TensorProduct.includeRight,\n    hi.comp (Algebra.TensorProduct.includeLeft_injective hb),\n    hi.comp (Algebra.TensorProduct.includeRight_injective ha), by\n      simpa only [AlgHom.range_comp] using (include_range R A B).map i hi⟩\n\n"}
{"name":"Subalgebra.LinearDisjoint.of_isField","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nA B : Subalgebra R S\nH : IsField (TensorProduct R (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x))\n⊢ A.LinearDisjoint B","decl":"/-- If `A ⊗[R] B` is a field, then `A` and `B` are linearly disjoint. -/\ntheorem of_isField (H : IsField (A ⊗[R] B)) : A.LinearDisjoint B := by\n  nontriviality S\n  rw [linearDisjoint_iff_injective]\n  letI : Field (A ⊗[R] B) := H.toField\n  -- need this otherwise `RingHom.injective` does not work\n  letI : NonAssocRing (A ⊗[R] B) := Ring.toNonAssocRing\n  exact RingHom.injective _\n\n"}
{"name":"Subalgebra.LinearDisjoint.of_isField'","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nA : Type v\ninst✝³ : CommRing A\nB : Type w\ninst✝² : CommRing B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nH : IsField (TensorProduct R A B)\nfa : AlgHom R A S\nfb : AlgHom R B S\nhfa : Function.Injective ⇑fa\nhfb : Function.Injective ⇑fb\n⊢ fa.range.LinearDisjoint fb.range","decl":"/-- If `A ⊗[R] B` is a field, then for any `R`-algebra `S`\nand injections of `A` and `B` into `S`, their images are linearly disjoint. -/\ntheorem of_isField' {A : Type v} [CommRing A] {B : Type w} [CommRing B]\n    [Algebra R A] [Algebra R B] (H : IsField (A ⊗[R] B))\n    (fa : A →ₐ[R] S) (fb : B →ₐ[R] S) (hfa : Function.Injective fa) (hfb : Function.Injective fb) :\n    fa.range.LinearDisjoint fb.range := by\n  apply of_isField\n  exact Algebra.TensorProduct.congr (AlgEquiv.ofInjective fa hfa)\n    (AlgEquiv.ofInjective fb hfb) |>.symm.toMulEquiv.isField _ H\n\n-- need to be in this file since it uses linearly disjoint\n"}
{"name":"Algebra.TensorProduct.not_isField_of_transcendental","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\ninst✝⁸ : CommRing R\nA : Type v\ninst✝⁷ : CommRing A\nB : Type w\ninst✝⁶ : CommRing B\ninst✝⁵ : Algebra R A\ninst✝⁴ : Algebra R B\ninst✝³ : Module.Flat R A\ninst✝² : Module.Flat R B\ninst✝¹ : Algebra.Transcendental R A\ninst✝ : Algebra.Transcendental R B\n⊢ Not (IsField (TensorProduct R A B))","decl":"open Cardinal Polynomial in\nvariable (R) in\n/-- If `A` and `B` are flat `R`-algebras, both of them are transcendental, then `A ⊗[R] B` cannot\nbe a field. -/\ntheorem _root_.Algebra.TensorProduct.not_isField_of_transcendental\n    (A : Type v) [CommRing A] (B : Type w) [CommRing B] [Algebra R A] [Algebra R B]\n    [Module.Flat R A] [Module.Flat R B] [Algebra.Transcendental R A] [Algebra.Transcendental R B] :\n    ¬IsField (A ⊗[R] B) := fun H ↦ by\n  letI := H.toField\n  obtain ⟨a, hta⟩ := ‹Algebra.Transcendental R A›\n  obtain ⟨b, htb⟩ := ‹Algebra.Transcendental R B›\n  have ha : Function.Injective (algebraMap R A) := Algebra.injective_of_transcendental\n  have hb : Function.Injective (algebraMap R B) := Algebra.injective_of_transcendental\n  let fa : A →ₐ[R] A ⊗[R] B := Algebra.TensorProduct.includeLeft\n  let fb : B →ₐ[R] A ⊗[R] B := Algebra.TensorProduct.includeRight\n  have hfa : Function.Injective fa := Algebra.TensorProduct.includeLeft_injective hb\n  have hfb : Function.Injective fb := Algebra.TensorProduct.includeRight_injective ha\n  haveI := hfa.isDomain fa.toRingHom\n  haveI := hfb.isDomain fb.toRingHom\n  haveI := ha.isDomain _\n  haveI : Module.Flat R (toSubmodule fa.range) :=\n    .of_linearEquiv (AlgEquiv.ofInjective fa hfa).symm.toLinearEquiv\n  have key1 : Module.rank R ↥(fa.range ⊓ fb.range) ≤ 1 :=\n    (include_range R A B).rank_inf_le_one_of_flat_left\n  let ga : R[X] →ₐ[R] A := aeval a\n  let gb : R[X] →ₐ[R] B := aeval b\n  let gab := fa.comp ga\n  replace hta : Function.Injective ga := transcendental_iff_injective.1 hta\n  replace htb : Function.Injective gb := transcendental_iff_injective.1 htb\n  have htab : Function.Injective gab := hfa.comp hta\n  algebraize_only [ga.toRingHom, gb.toRingHom]\n  let f := Algebra.TensorProduct.mapOfCompatibleSMul R[X] R A B\n  haveI := Algebra.TensorProduct.nontrivial_of_algebraMap_injective_of_isDomain R[X] A B hta htb\n  have hf : Function.Injective f := RingHom.injective _\n  have key2 : gab.range ≤ fa.range ⊓ fb.range := by\n    simp_rw [gab, ga, ← aeval_algHom]\n    rw [Algebra.TensorProduct.includeLeft_apply, ← Algebra.adjoin_singleton_eq_range_aeval]\n    simp_rw [Algebra.adjoin_le_iff, Set.singleton_subset_iff, Algebra.coe_inf, Set.mem_inter_iff,\n      AlgHom.coe_range, Set.mem_range]\n    refine ⟨⟨a, by simp [fa]⟩, ⟨b, hf ?_⟩⟩\n    simp_rw [fb, Algebra.TensorProduct.includeRight_apply, f,\n      Algebra.TensorProduct.mapOfCompatibleSMul_tmul]\n    convert ← (TensorProduct.smul_tmul (R := R[X]) (R' := R[X]) (M := A) (N := B) X 1 1).symm <;>\n      (simp_rw [Algebra.smul_def, mul_one]; exact aeval_X _)\n  have key3 := (Subalgebra.inclusion key2).comp (AlgEquiv.ofInjective gab htab).toAlgHom\n    |>.toLinearMap.lift_rank_le_of_injective\n      ((Subalgebra.inclusion_injective key2).comp (AlgEquiv.injective _))\n  have := lift_uzero.{u} _ ▸ (basisMonomials R).mk_eq_rank.symm\n  simp only [this, mk_eq_aleph0, lift_aleph0, aleph0_le_lift] at key3\n  exact (key3.trans key1).not_lt one_lt_aleph0\n\n"}
{"name":"Algebra.TensorProduct.isAlgebraic_of_isField","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\ninst✝⁶ : CommRing R\nA : Type v\ninst✝⁵ : CommRing A\nB : Type w\ninst✝⁴ : CommRing B\ninst✝³ : Algebra R A\ninst✝² : Algebra R B\ninst✝¹ : Module.Flat R A\ninst✝ : Module.Flat R B\nH : IsField (TensorProduct R A B)\n⊢ Or (Algebra.IsAlgebraic R A) (Algebra.IsAlgebraic R B)","decl":"variable (R) in\n/-- If `A` and `B` are flat `R`-algebras, such that `A ⊗[R] B` is a field, then one of `A` and `B`\nis algebraic over `R`. -/\ntheorem _root_.Algebra.TensorProduct.isAlgebraic_of_isField\n    (A : Type v) [CommRing A] (B : Type w) [CommRing B] [Algebra R A] [Algebra R B]\n    [Module.Flat R A] [Module.Flat R B] (H : IsField (A ⊗[R] B)) :\n    Algebra.IsAlgebraic R A ∨ Algebra.IsAlgebraic R B := by\n  by_contra! h\n  simp_rw [← Algebra.transcendental_iff_not_isAlgebraic] at h\n  obtain ⟨_, _⟩ := h\n  exact Algebra.TensorProduct.not_isField_of_transcendental R A B H\n\n"}
{"name":"Subalgebra.LinearDisjoint.rank_inf_eq_one_of_flat_of_inj","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\nhf : Or (Module.Flat R (Subtype fun x => Membership.mem A x)) (Module.Flat R (Subtype fun x => Membership.mem B x))\nhinj : Function.Injective ⇑(algebraMap R S)\n⊢ Eq (Module.rank R (Subtype fun x => Membership.mem (Min.min A B) x)) 1","decl":"include H in\ntheorem rank_inf_eq_one_of_flat_of_inj (hf : Module.Flat R A ∨ Module.Flat R B)\n    (hinj : Function.Injective (algebraMap R S)) : Module.rank R ↥(A ⊓ B) = 1 :=\n  H.rank_inf_eq_one_of_commute_of_flat_of_inj hf (fun _ _ ↦ mul_comm _ _) hinj\n\n"}
{"name":"Subalgebra.LinearDisjoint.rank_inf_eq_one_of_flat_left_of_inj","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem A x)\nhinj : Function.Injective ⇑(algebraMap R S)\n⊢ Eq (Module.rank R (Subtype fun x => Membership.mem (Min.min A B) x)) 1","decl":"include H in\ntheorem rank_inf_eq_one_of_flat_left_of_inj [Module.Flat R A]\n    (hinj : Function.Injective (algebraMap R S)) : Module.rank R ↥(A ⊓ B) = 1 :=\n  H.rank_inf_eq_one_of_commute_of_flat_left_of_inj (fun _ _ ↦ mul_comm _ _) hinj\n\n"}
{"name":"Subalgebra.LinearDisjoint.rank_inf_eq_one_of_flat_right_of_inj","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem B x)\nhinj : Function.Injective ⇑(algebraMap R S)\n⊢ Eq (Module.rank R (Subtype fun x => Membership.mem (Min.min A B) x)) 1","decl":"include H in\ntheorem rank_inf_eq_one_of_flat_right_of_inj [Module.Flat R B]\n    (hinj : Function.Injective (algebraMap R S)) : Module.rank R ↥(A ⊓ B) = 1 :=\n  H.rank_inf_eq_one_of_commute_of_flat_right_of_inj (fun _ _ ↦ mul_comm _ _) hinj\n\n"}
{"name":"Subalgebra.LinearDisjoint.rank_eq_one_of_flat_of_self_of_inj","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nA : Subalgebra R S\nH : A.LinearDisjoint A\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem A x)\nhinj : Function.Injective ⇑(algebraMap R S)\n⊢ Eq (Module.rank R (Subtype fun x => Membership.mem A x)) 1","decl":"theorem rank_eq_one_of_flat_of_self_of_inj (H : A.LinearDisjoint A) [Module.Flat R A]\n    (hinj : Function.Injective (algebraMap R S)) : Module.rank R A = 1 :=\n  H.rank_eq_one_of_commute_of_flat_of_self_of_inj (fun _ _ ↦ mul_comm _ _) hinj\n\n"}
{"name":"Subalgebra.LinearDisjoint.rank_sup_of_free","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\ninst✝¹ : Module.Free R (Subtype fun x => Membership.mem A x)\ninst✝ : Module.Free R (Subtype fun x => Membership.mem B x)\n⊢ Eq (Module.rank R (Subtype fun x => Membership.mem (Max.max A B) x)) (HMul.hMul (Module.rank R (Subtype fun x => Membership.mem A x)) (Module.rank R (Subtype fun x => Membership.mem B x)))","decl":"include H in\n/-- In a commutative ring, if subalgebras `A` and `B` are linearly disjoint and they are\nfree modules, then the rank of `A ⊔ B` is equal to the product of the rank of `A` and `B`. -/\ntheorem rank_sup_of_free [Module.Free R A] [Module.Free R B] :\n    Module.rank R ↥(A ⊔ B) = Module.rank R A * Module.rank R B := by\n  nontriviality R\n  rw [← rank_tensorProduct', H.mulMap.toLinearEquiv.rank_eq]\n\n"}
{"name":"Subalgebra.LinearDisjoint.finrank_sup_of_free","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\ninst✝¹ : Module.Free R (Subtype fun x => Membership.mem A x)\ninst✝ : Module.Free R (Subtype fun x => Membership.mem B x)\n⊢ Eq (Module.finrank R (Subtype fun x => Membership.mem (Max.max A B) x)) (HMul.hMul (Module.finrank R (Subtype fun x => Membership.mem A x)) (Module.finrank R (Subtype fun x => Membership.mem B x)))","decl":"include H in\n/-- In a commutative ring, if subalgebras `A` and `B` are linearly disjoint and they are\nfree modules, then the rank of `A ⊔ B` is equal to the product of the rank of `A` and `B`. -/\ntheorem finrank_sup_of_free [Module.Free R A] [Module.Free R B] :\n    Module.finrank R ↥(A ⊔ B) = Module.finrank R A * Module.finrank R B := by\n  simpa only [map_mul] using congr(Cardinal.toNat $(H.rank_sup_of_free))\n\n"}
{"name":"Subalgebra.LinearDisjoint.of_finrank_sup_of_free","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nA B : Subalgebra R S\ninst✝³ : Module.Free R (Subtype fun x => Membership.mem A x)\ninst✝² : Module.Free R (Subtype fun x => Membership.mem B x)\ninst✝¹ : Module.Finite R (Subtype fun x => Membership.mem A x)\ninst✝ : Module.Finite R (Subtype fun x => Membership.mem B x)\nH : Eq (Module.finrank R (Subtype fun x => Membership.mem (Max.max A B) x)) (HMul.hMul (Module.finrank R (Subtype fun x => Membership.mem A x)) (Module.finrank R (Subtype fun x => Membership.mem B x)))\n⊢ A.LinearDisjoint B","decl":"/-- In a commutative ring, if `A` and `B` are subalgebras which are free modules of finite rank,\nsuch that rank of `A ⊔ B` is equal to the product of the rank of `A` and `B`,\nthen `A` and `B` are linearly disjoint. -/\ntheorem of_finrank_sup_of_free [Module.Free R A] [Module.Free R B]\n    [Module.Finite R A] [Module.Finite R B]\n    (H : Module.finrank R ↥(A ⊔ B) = Module.finrank R A * Module.finrank R B) :\n    A.LinearDisjoint B := by\n  nontriviality R\n  rw [← Module.finrank_tensorProduct] at H\n  obtain ⟨j, hj⟩ := exists_linearIndependent_of_le_finrank H.ge\n  rw [LinearIndependent] at hj\n  let j' := Finsupp.linearCombination R j ∘ₗ\n    (LinearEquiv.ofFinrankEq (A ⊗[R] B) _ (by simp)).toLinearMap\n  replace hj : Function.Injective j' := by simpa [j']\n  have hf : Function.Surjective (mulMap' A B).toLinearMap := mulMap'_surjective A B\n  haveI := Subalgebra.finite_sup A B\n  rw [linearDisjoint_iff, Submodule.linearDisjoint_iff]\n  exact Subtype.val_injective.comp (OrzechProperty.injective_of_surjective_of_injective j' _ hj hf)\n\n"}
{"name":"Subalgebra.LinearDisjoint.adjoin_rank_eq_rank_left","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\ninst✝³ : Module.Free R (Subtype fun x => Membership.mem A x)\ninst✝² : Module.Flat R (Subtype fun x => Membership.mem B x)\ninst✝¹ : Nontrivial R\ninst✝ : Nontrivial S\n⊢ Eq (Module.rank (Subtype fun x => Membership.mem B x) (Subtype fun x => Membership.mem (Algebra.adjoin (Subtype fun x => Membership.mem B x) ↑A) x)) (Module.rank R (Subtype fun x => Membership.mem A x))","decl":"include H in\n/-- If `A` and `B` are linearly disjoint, if `A` is free and `B` is flat,\nthen `[B[A] : B] = [A : R]`. See also `Subalgebra.adjoin_rank_le`. -/\ntheorem adjoin_rank_eq_rank_left [Module.Free R A] [Module.Flat R B]\n    [Nontrivial R] [Nontrivial S] :\n    Module.rank B (Algebra.adjoin B (A : Set S)) = Module.rank R A := by\n  rw [← rank_toSubmodule, Module.Free.rank_eq_card_chooseBasisIndex R A,\n    A.adjoin_eq_span_basis B (Module.Free.chooseBasis R A)]\n  change Module.rank B (Submodule.span B (Set.range (A.val ∘ Module.Free.chooseBasis R A))) = _\n  have := H.linearIndependent_left_of_flat (Module.Free.chooseBasis R A).linearIndependent\n  rw [rank_span this, Cardinal.mk_range_eq _ this.injective]\n\n"}
{"name":"Subalgebra.LinearDisjoint.adjoin_rank_eq_rank_right","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\ninst✝³ : Module.Free R (Subtype fun x => Membership.mem B x)\ninst✝² : Module.Flat R (Subtype fun x => Membership.mem A x)\ninst✝¹ : Nontrivial R\ninst✝ : Nontrivial S\n⊢ Eq (Module.rank (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem (Algebra.adjoin (Subtype fun x => Membership.mem A x) ↑B) x)) (Module.rank R (Subtype fun x => Membership.mem B x))","decl":"include H in\n/-- If `A` and `B` are linearly disjoint, if `B` is free and `A` is flat,\nthen `[A[B] : A] = [B : R]`. See also `Subalgebra.adjoin_rank_le`. -/\ntheorem adjoin_rank_eq_rank_right [Module.Free R B] [Module.Flat R A]\n    [Nontrivial R] [Nontrivial S] :\n    Module.rank A (Algebra.adjoin A (B : Set S)) = Module.rank R B :=\n  H.symm.adjoin_rank_eq_rank_left\n\n"}
{"name":"Subalgebra.LinearDisjoint.of_finrank_coprime_of_free","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nA B : Subalgebra R S\ninst✝³ : Module.Free R (Subtype fun x => Membership.mem A x)\ninst✝² : Module.Free R (Subtype fun x => Membership.mem B x)\ninst✝¹ : Module.Free (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem (Algebra.adjoin (Subtype fun x => Membership.mem A x) ↑B) x)\ninst✝ : Module.Free (Subtype fun x => Membership.mem B x) (Subtype fun x => Membership.mem (Algebra.adjoin (Subtype fun x => Membership.mem B x) ↑A) x)\nH : (Module.finrank R (Subtype fun x => Membership.mem A x)).Coprime (Module.finrank R (Subtype fun x => Membership.mem B x))\n⊢ A.LinearDisjoint B","decl":"/-- If the rank of `A` and `B` are coprime, and they satisfy some freeness condition,\nthen `A` and `B` are linearly disjoint. -/\ntheorem of_finrank_coprime_of_free [Module.Free R A] [Module.Free R B]\n    [Module.Free A (Algebra.adjoin A (B : Set S))] [Module.Free B (Algebra.adjoin B (A : Set S))]\n    (H : (Module.finrank R A).Coprime (Module.finrank R B)) : A.LinearDisjoint B := by\n  nontriviality R\n  by_cases h1 : Module.finrank R A = 0\n  · rw [h1, Nat.coprime_zero_left] at H\n    rw [eq_bot_of_finrank_one H]\n    exact bot_right _\n  by_cases h2 : Module.finrank R B = 0\n  · rw [h2, Nat.coprime_zero_right] at H\n    rw [eq_bot_of_finrank_one H]\n    exact bot_left _\n  haveI := Module.finite_of_finrank_pos (Nat.pos_of_ne_zero h1)\n  haveI := Module.finite_of_finrank_pos (Nat.pos_of_ne_zero h2)\n  haveI := finite_sup A B\n  have : Module.finrank R A ≤ Module.finrank R ↥(A ⊔ B) :=\n    LinearMap.finrank_le_finrank_of_injective <|\n      Submodule.inclusion_injective (show toSubmodule A ≤ toSubmodule (A ⊔ B) by simp)\n  exact of_finrank_sup_of_free <| (finrank_sup_le_of_free A B).antisymm <|\n    Nat.le_of_dvd (lt_of_lt_of_le (Nat.pos_of_ne_zero h1) this) <| H.mul_dvd_of_dvd_of_dvd\n      (finrank_left_dvd_finrank_sup_of_free A B) (finrank_right_dvd_finrank_sup_of_free A B)\n\n"}
{"name":"Subalgebra.LinearDisjoint.of_linearDisjoint_finite_left","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nA B : Subalgebra R S\ninst✝ : Algebra.IsIntegral R (Subtype fun x => Membership.mem A x)\nH : ∀ (A' : Subalgebra R S), LE.le A' A → ∀ [inst : Module.Finite R (Subtype fun x => Membership.mem A' x)], A'.LinearDisjoint B\n⊢ A.LinearDisjoint B","decl":"/-- If `A/R` is integral, such that `A'` and `B` are linearly disjoint for all subalgebras `A'`\nof `A` which are finitely generated `R`-modules, then `A` and `B` are linearly disjoint. -/\ntheorem of_linearDisjoint_finite_left [Algebra.IsIntegral R A]\n    (H : ∀ A' : Subalgebra R S, A' ≤ A → [Module.Finite R A'] → A'.LinearDisjoint B) :\n    A.LinearDisjoint B := by\n  rw [linearDisjoint_iff, Submodule.linearDisjoint_iff]\n  intro x y hxy\n  obtain ⟨M', hM, hf, h⟩ :=\n    TensorProduct.exists_finite_submodule_left_of_finite' {x, y} (Set.toFinite _)\n  obtain ⟨s, hs⟩ := Module.Finite.iff_fg.1 hf\n  have hs' : (s : Set S) ⊆ A := by rwa [← hs, Submodule.span_le] at hM\n  let A' := Algebra.adjoin R (s : Set S)\n  have hf' : Submodule.FG (toSubmodule A') := fg_adjoin_of_finite s.finite_toSet fun x hx ↦\n    (isIntegral_algHom_iff A.val Subtype.val_injective).2\n      (Algebra.IsIntegral.isIntegral (R := R) (A := A) ⟨x, hs' hx⟩)\n  replace hf' : Module.Finite R A' := Module.Finite.iff_fg.2 hf'\n  have hA : toSubmodule A' ≤ toSubmodule A := Algebra.adjoin_le_iff.2 hs'\n  replace h : {x, y} ⊆ (LinearMap.range (LinearMap.rTensor (toSubmodule B)\n      (Submodule.inclusion hA)) : Set _) := fun _ hx ↦ by\n    have : Submodule.inclusion hM = Submodule.inclusion hA ∘ₗ Submodule.inclusion\n      (show M' ≤ toSubmodule A' by\n        rw [← hs, Submodule.span_le]; exact Algebra.adjoin_le_iff.1 (le_refl _)) := rfl\n    rw [this, LinearMap.rTensor_comp] at h\n    exact LinearMap.range_comp_le_range _ _ (h hx)\n  obtain ⟨x', hx'⟩ := h (show x ∈ {x, y} by simp)\n  obtain ⟨y', hy'⟩ := h (show y ∈ {x, y} by simp)\n  rw [← hx', ← hy']; congr\n  exact (H A' hA).injective (by simp [← Submodule.mulMap_comp_rTensor _ hA, hx', hy', hxy])\n\n"}
{"name":"Subalgebra.LinearDisjoint.of_linearDisjoint_finite_right","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nA B : Subalgebra R S\ninst✝ : Algebra.IsIntegral R (Subtype fun x => Membership.mem B x)\nH : ∀ (B' : Subalgebra R S), LE.le B' B → ∀ [inst : Module.Finite R (Subtype fun x => Membership.mem B' x)], A.LinearDisjoint B'\n⊢ A.LinearDisjoint B","decl":"/-- If `B/R` is integral, such that `A` and `B'` are linearly disjoint for all subalgebras `B'`\nof `B` which are finitely generated `R`-modules, then `A` and `B` are linearly disjoint. -/\ntheorem of_linearDisjoint_finite_right [Algebra.IsIntegral R B]\n    (H : ∀ B' : Subalgebra R S, B' ≤ B → [Module.Finite R B'] → A.LinearDisjoint B') :\n    A.LinearDisjoint B :=\n  (of_linearDisjoint_finite_left B A fun B' hB' _ ↦ (H B' hB').symm).symm\n\n"}
{"name":"Subalgebra.LinearDisjoint.of_linearDisjoint_finite","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nA B : Subalgebra R S\ninst✝¹ : Algebra.IsIntegral R (Subtype fun x => Membership.mem A x)\ninst✝ : Algebra.IsIntegral R (Subtype fun x => Membership.mem B x)\nH : ∀ (A' B' : Subalgebra R S), LE.le A' A → LE.le B' B → ∀ [inst : Module.Finite R (Subtype fun x => Membership.mem A' x)] [inst : Module.Finite R (Subtype fun x => Membership.mem B' x)], A'.LinearDisjoint B'\n⊢ A.LinearDisjoint B","decl":"/-- If `A/R` and `B/R` are integral, such that any finite subalgebras in `A` and `B` are\nlinearly disjoint, then `A` and `B` are linearly disjoint. -/\ntheorem of_linearDisjoint_finite\n    [Algebra.IsIntegral R A] [Algebra.IsIntegral R B]\n    (H : ∀ (A' B' : Subalgebra R S), A' ≤ A → B' ≤ B →\n      [Module.Finite R A'] → [Module.Finite R B'] → A'.LinearDisjoint B') :\n    A.LinearDisjoint B :=\n  of_linearDisjoint_finite_left A B fun _ hA' _ ↦\n    of_linearDisjoint_finite_right _ B fun _ hB' _ ↦ H _ _ hA' hB'\n\n"}
{"name":"Subalgebra.LinearDisjoint.inf_eq_bot_of_commute","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : Field R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\nhc : ∀ (a b : Subtype fun x => Membership.mem (Min.min A B) x), Commute ↑a ↑b\n⊢ Eq (Min.min A B) Bot.bot","decl":"theorem inf_eq_bot_of_commute (H : A.LinearDisjoint B)\n    (hc : ∀ (a b : ↥(A ⊓ B)), Commute a.1 b.1) : A ⊓ B = ⊥ :=\n  eq_bot_of_rank_le_one (Submodule.LinearDisjoint.rank_inf_le_one_of_commute_of_flat_left H hc)\n\n"}
{"name":"Subalgebra.LinearDisjoint.eq_bot_of_commute_of_self","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : Field R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nA : Subalgebra R S\nH : A.LinearDisjoint A\nhc : ∀ (a b : Subtype fun x => Membership.mem A x), Commute ↑a ↑b\n⊢ Eq A Bot.bot","decl":"theorem eq_bot_of_commute_of_self (H : A.LinearDisjoint A)\n    (hc : ∀ (a b : A), Commute a.1 b.1) : A = ⊥ := by\n  rw [← inf_of_le_left (le_refl A)] at hc ⊢\n  exact H.inf_eq_bot_of_commute hc\n\n"}
{"name":"Subalgebra.LinearDisjoint.inf_eq_bot","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : Field R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nA B : Subalgebra R S\nH : A.LinearDisjoint B\n⊢ Eq (Min.min A B) Bot.bot","decl":"theorem inf_eq_bot (H : A.LinearDisjoint B) : A ⊓ B = ⊥ :=\n  H.inf_eq_bot_of_commute fun _ _ ↦ mul_comm _ _\n\n"}
{"name":"Subalgebra.LinearDisjoint.eq_bot_of_self","module":"Mathlib.RingTheory.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : Field R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nA : Subalgebra R S\nH : A.LinearDisjoint A\n⊢ Eq A Bot.bot","decl":"theorem eq_bot_of_self (H : A.LinearDisjoint A) : A = ⊥ :=\n  H.eq_bot_of_commute_of_self fun _ _ ↦ mul_comm _ _\n\n"}
