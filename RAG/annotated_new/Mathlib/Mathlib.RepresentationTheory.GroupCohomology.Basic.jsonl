{"name":"groupCohomology.linearYonedaObjResolution_d_apply","module":"Mathlib.RepresentationTheory.GroupCohomology.Basic","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nA : Rep k G\ni j : Nat\nx : Quiver.Hom ((groupCohomology.resolution k G).X i) A\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom ((groupCohomology.linearYonedaObjResolution A).d i j)) x) (CategoryTheory.CategoryStruct.comp ((groupCohomology.resolution k G).d j i) x)","decl":"theorem linearYonedaObjResolution_d_apply {A : Rep k G} (i j : ℕ) (x : (resolution k G).X i ⟶ A) :\n    (linearYonedaObjResolution A).d i j x = (resolution k G).d j i ≫ x :=\n  rfl\n\n"}
{"name":"inhomogeneousCochains.d_apply","module":"Mathlib.RepresentationTheory.GroupCohomology.Basic","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nn : Nat\nA : Rep k G\nf : (Fin n → G) → CoeSort.coe A\ng : Fin (HAdd.hAdd n 1) → G\n⊢ Eq ((inhomogeneousCochains.d n A) f g) (HAdd.hAdd ((A.ρ (g 0)) (f fun i => g i.succ)) (Finset.univ.sum fun j => HSMul.hSMul (HPow.hPow (-1) (HAdd.hAdd (↑j) 1)) (f (j.contractNth (fun x1 x2 => HMul.hMul x1 x2) g))))","decl":"/-- The differential in the complex of inhomogeneous cochains used to\ncalculate group cohomology. -/\n@[simps]\ndef d [Monoid G] (n : ℕ) (A : Rep k G) : ((Fin n → G) → A) →ₗ[k] (Fin (n + 1) → G) → A where\n  toFun f g :=\n    A.ρ (g 0) (f fun i => g i.succ) +\n      Finset.univ.sum fun j : Fin (n + 1) =>\n        (-1 : k) ^ ((j : ℕ) + 1) • f (Fin.contractNth j (· * ·) g)\n  map_add' f g := by\n    ext x\n/- Porting note: changed from `simp only` which needed extra heartbeats -/\n    simp_rw [Pi.add_apply, map_add, smul_add, Finset.sum_add_distrib, add_add_add_comm]\n  map_smul' r f := by\n    ext x\n/- Porting note: changed from `simp only` which needed extra heartbeats -/\n    simp_rw [Pi.smul_apply, RingHom.id_apply, map_smul, smul_add, Finset.smul_sum, ← smul_assoc,\n      smul_eq_mul, mul_comm r]\n\n"}
{"name":"inhomogeneousCochains.d_eq","module":"Mathlib.RepresentationTheory.GroupCohomology.Basic","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\nn : Nat\ninst✝ : Group G\nA : Rep k G\n⊢ Eq (inhomogeneousCochains.d n A) (ModuleCat.Hom.hom (CategoryTheory.CategoryStruct.comp (Rep.diagonalHomEquiv n A).toModuleIso.inv (CategoryTheory.CategoryStruct.comp ((groupCohomology.linearYonedaObjResolution A).d n (HAdd.hAdd n 1)) (Rep.diagonalHomEquiv (HAdd.hAdd n 1) A).toModuleIso.hom)))","decl":"/-- The theorem that our isomorphism `Fun(Gⁿ, A) ≅ Hom(k[Gⁿ⁺¹], A)` (where the righthand side is\nmorphisms in `Rep k G`) commutes with the differentials in the complex of inhomogeneous cochains\nand the homogeneous `linearYonedaObjResolution`. -/\n@[nolint checkType] theorem d_eq :\n    d n A =\n      ((diagonalHomEquiv n A).toModuleIso.inv ≫\n        (linearYonedaObjResolution A).d n (n + 1) ≫\n          (diagonalHomEquiv (n + 1) A).toModuleIso.hom).hom := by\n  ext f g\n/- Porting note (https://github.com/leanprover-community/mathlib4/issues/11039): broken proof was\n  simp only [ModuleCat.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,\n    LinearEquiv.toModuleIso_inv, linearYonedaObjResolution_d_apply, LinearEquiv.toModuleIso_hom,\n    diagonalHomEquiv_apply, Action.comp_hom, Resolution.d_eq k G n,\n    Resolution.d_of (Fin.partialProd g), LinearMap.map_sum,\n    ← Finsupp.smul_single_one _ ((-1 : k) ^ _), map_smul, d_apply]\n  simp only [@Fin.sum_univ_succ _ _ (n + 1), Fin.val_zero, pow_zero, one_smul, Fin.succAbove_zero,\n    diagonalHomEquiv_symm_apply f (Fin.partialProd g ∘ @Fin.succ (n + 1)), Function.comp_apply,\n    Fin.partialProd_succ, Fin.castSucc_zero, Fin.partialProd_zero, one_mul]\n  congr 1\n  · congr\n    ext\n    have := Fin.partialProd_right_inv g (Fin.castSucc x)\n    simp only [mul_inv_rev, Fin.castSucc_fin_succ] at *\n    rw [mul_assoc, ← mul_assoc _ _ (g x.succ), this, inv_mul_cancel_left]\n  · exact Finset.sum_congr rfl fun j hj => by\n      rw [diagonalHomEquiv_symm_partialProd_succ, Fin.val_succ] -/\n  -- https://github.com/leanprover-community/mathlib4/issues/5026\n  -- https://github.com/leanprover-community/mathlib4/issues/5164\n  change d n A f g = diagonalHomEquiv (n + 1) A\n    ((resolution k G).d (n + 1) n ≫ (diagonalHomEquiv n A).symm f) g\n  rw [diagonalHomEquiv_apply, Action.comp_hom, ConcreteCategory.comp_apply, resolution.d_eq]\n  erw [resolution.d_of (Fin.partialProd g)]\n  simp only [map_sum, ← Finsupp.smul_single_one _ ((-1 : k) ^ _)]\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [d_apply, @Fin.sum_univ_succ _ _ (n + 1), Fin.val_zero, pow_zero, one_smul,\n    Fin.succAbove_zero, diagonalHomEquiv_symm_apply f (Fin.partialProd g ∘ @Fin.succ (n + 1))]\n  simp_rw [Function.comp_apply, Fin.partialProd_succ, Fin.castSucc_zero,\n    Fin.partialProd_zero, one_mul]\n  rcongr x\n  · have := Fin.partialProd_right_inv g (Fin.castSucc x)\n    simp only [mul_inv_rev, Fin.castSucc_fin_succ] at this ⊢\n    rw [mul_assoc, ← mul_assoc _ _ (g x.succ), this, inv_mul_cancel_left]\n  · -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n    erw [map_smul, diagonalHomEquiv_symm_partialProd_succ, Fin.val_succ]\n\n"}
{"name":"groupCohomology.inhomogeneousCochains.d_def","module":"Mathlib.RepresentationTheory.GroupCohomology.Basic","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA : Rep k G\nn : Nat\n⊢ Eq ((groupCohomology.inhomogeneousCochains A).d n (HAdd.hAdd n 1)) (ModuleCat.ofHom (inhomogeneousCochains.d n A))","decl":"@[simp]\ntheorem inhomogeneousCochains.d_def (n : ℕ) :\n    (inhomogeneousCochains A).d n (n + 1) = ModuleCat.ofHom (inhomogeneousCochains.d n A) :=\n  CochainComplex.of_d _ _ _ _\n\n"}
