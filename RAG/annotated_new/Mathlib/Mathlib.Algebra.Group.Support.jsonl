{"name":"Function.mulSupport_eq_preimage","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : One M\nf : α → M\n⊢ Eq (Function.mulSupport f) (Set.preimage f (HasCompl.compl (Singleton.singleton 1)))","decl":"@[to_additive]\ntheorem mulSupport_eq_preimage (f : α → M) : mulSupport f = f ⁻¹' {1}ᶜ :=\n  rfl\n\n"}
{"name":"Function.support_eq_preimage","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : α → M\n⊢ Eq (Function.support f) (Set.preimage f (HasCompl.compl (Singleton.singleton 0)))","decl":"@[to_additive]\ntheorem mulSupport_eq_preimage (f : α → M) : mulSupport f = f ⁻¹' {1}ᶜ :=\n  rfl\n\n"}
{"name":"Function.nmem_support","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : α → M\nx : α\n⊢ Iff (Not (Membership.mem (Function.support f) x)) (Eq (f x) 0)","decl":"@[to_additive]\ntheorem nmem_mulSupport {f : α → M} {x : α} : x ∉ mulSupport f ↔ f x = 1 :=\n  not_not\n\n"}
{"name":"Function.nmem_mulSupport","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : One M\nf : α → M\nx : α\n⊢ Iff (Not (Membership.mem (Function.mulSupport f) x)) (Eq (f x) 1)","decl":"@[to_additive]\ntheorem nmem_mulSupport {f : α → M} {x : α} : x ∉ mulSupport f ↔ f x = 1 :=\n  not_not\n\n"}
{"name":"Function.compl_mulSupport","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : One M\nf : α → M\n⊢ Eq (HasCompl.compl (Function.mulSupport f)) (setOf fun x => Eq (f x) 1)","decl":"@[to_additive]\ntheorem compl_mulSupport {f : α → M} : (mulSupport f)ᶜ = { x | f x = 1 } :=\n  ext fun _ => nmem_mulSupport\n\n"}
{"name":"Function.compl_support","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : α → M\n⊢ Eq (HasCompl.compl (Function.support f)) (setOf fun x => Eq (f x) 0)","decl":"@[to_additive]\ntheorem compl_mulSupport {f : α → M} : (mulSupport f)ᶜ = { x | f x = 1 } :=\n  ext fun _ => nmem_mulSupport\n\n"}
{"name":"Function.mem_support","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : α → M\nx : α\n⊢ Iff (Membership.mem (Function.support f) x) (Ne (f x) 0)","decl":"@[to_additive (attr := simp)]\ntheorem mem_mulSupport {f : α → M} {x : α} : x ∈ mulSupport f ↔ f x ≠ 1 :=\n  Iff.rfl\n\n"}
{"name":"Function.mem_mulSupport","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : One M\nf : α → M\nx : α\n⊢ Iff (Membership.mem (Function.mulSupport f) x) (Ne (f x) 1)","decl":"@[to_additive (attr := simp)]\ntheorem mem_mulSupport {f : α → M} {x : α} : x ∈ mulSupport f ↔ f x ≠ 1 :=\n  Iff.rfl\n\n"}
{"name":"Function.support_subset_iff","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : α → M\ns : Set α\n⊢ Iff (HasSubset.Subset (Function.support f) s) (∀ (x : α), Ne (f x) 0 → Membership.mem s x)","decl":"@[to_additive (attr := simp)]\ntheorem mulSupport_subset_iff {f : α → M} {s : Set α} : mulSupport f ⊆ s ↔ ∀ x, f x ≠ 1 → x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Function.mulSupport_subset_iff","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : One M\nf : α → M\ns : Set α\n⊢ Iff (HasSubset.Subset (Function.mulSupport f) s) (∀ (x : α), Ne (f x) 1 → Membership.mem s x)","decl":"@[to_additive (attr := simp)]\ntheorem mulSupport_subset_iff {f : α → M} {s : Set α} : mulSupport f ⊆ s ↔ ∀ x, f x ≠ 1 → x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Function.mulSupport_subset_iff'","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : One M\nf : α → M\ns : Set α\n⊢ Iff (HasSubset.Subset (Function.mulSupport f) s) (∀ (x : α), Not (Membership.mem s x) → Eq (f x) 1)","decl":"@[to_additive]\ntheorem mulSupport_subset_iff' {f : α → M} {s : Set α} :\n    mulSupport f ⊆ s ↔ ∀ x ∉ s, f x = 1 :=\n  forall_congr' fun _ => not_imp_comm\n\n"}
{"name":"Function.support_subset_iff'","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : α → M\ns : Set α\n⊢ Iff (HasSubset.Subset (Function.support f) s) (∀ (x : α), Not (Membership.mem s x) → Eq (f x) 0)","decl":"@[to_additive]\ntheorem mulSupport_subset_iff' {f : α → M} {s : Set α} :\n    mulSupport f ⊆ s ↔ ∀ x ∉ s, f x = 1 :=\n  forall_congr' fun _ => not_imp_comm\n\n"}
{"name":"Function.mulSupport_eq_iff","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : One M\nf : α → M\ns : Set α\n⊢ Iff (Eq (Function.mulSupport f) s) (And (∀ (x : α), Membership.mem s x → Ne (f x) 1) (∀ (x : α), Not (Membership.mem s x) → Eq (f x) 1))","decl":"@[to_additive]\ntheorem mulSupport_eq_iff {f : α → M} {s : Set α} :\n    mulSupport f = s ↔ (∀ x, x ∈ s → f x ≠ 1) ∧ ∀ x, x ∉ s → f x = 1 := by\n  simp +contextual only [Set.ext_iff, mem_mulSupport, ne_eq, iff_def,\n    not_imp_comm, and_comm, forall_and]\n\n"}
{"name":"Function.support_eq_iff","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : α → M\ns : Set α\n⊢ Iff (Eq (Function.support f) s) (And (∀ (x : α), Membership.mem s x → Ne (f x) 0) (∀ (x : α), Not (Membership.mem s x) → Eq (f x) 0))","decl":"@[to_additive]\ntheorem mulSupport_eq_iff {f : α → M} {s : Set α} :\n    mulSupport f = s ↔ (∀ x, x ∈ s → f x ≠ 1) ∧ ∀ x, x ∉ s → f x = 1 := by\n  simp +contextual only [Set.ext_iff, mem_mulSupport, ne_eq, iff_def,\n    not_imp_comm, and_comm, forall_and]\n\n"}
{"name":"Function.ext_iff_mulSupport","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : One M\nf g : α → M\n⊢ Iff (Eq f g) (And (Eq (Function.mulSupport f) (Function.mulSupport g)) (∀ (x : α), Membership.mem (Function.mulSupport f) x → Eq (f x) (g x)))","decl":"@[to_additive]\ntheorem ext_iff_mulSupport {f g : α → M} :\n    f = g ↔ f.mulSupport = g.mulSupport ∧ ∀ x ∈ f.mulSupport, f x = g x :=\n  ⟨fun h ↦ h ▸ ⟨rfl, fun _ _ ↦ rfl⟩, fun ⟨h₁, h₂⟩ ↦ funext fun x ↦ by\n    if hx : x ∈ f.mulSupport then exact h₂ x hx\n    else rw [nmem_mulSupport.1 hx, nmem_mulSupport.1 (mt (Set.ext_iff.1 h₁ x).2 hx)]⟩\n\n"}
{"name":"Function.ext_iff_support","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf g : α → M\n⊢ Iff (Eq f g) (And (Eq (Function.support f) (Function.support g)) (∀ (x : α), Membership.mem (Function.support f) x → Eq (f x) (g x)))","decl":"@[to_additive]\ntheorem ext_iff_mulSupport {f g : α → M} :\n    f = g ↔ f.mulSupport = g.mulSupport ∧ ∀ x ∈ f.mulSupport, f x = g x :=\n  ⟨fun h ↦ h ▸ ⟨rfl, fun _ _ ↦ rfl⟩, fun ⟨h₁, h₂⟩ ↦ funext fun x ↦ by\n    if hx : x ∈ f.mulSupport then exact h₂ x hx\n    else rw [nmem_mulSupport.1 hx, nmem_mulSupport.1 (mt (Set.ext_iff.1 h₁ x).2 hx)]⟩\n\n"}
{"name":"Function.support_update_of_ne_zero","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\ninst✝ : DecidableEq α\nf : α → M\nx : α\ny : M\nhy : Ne y 0\n⊢ Eq (Function.support (Function.update f x y)) (Insert.insert x (Function.support f))","decl":"@[to_additive]\ntheorem mulSupport_update_of_ne_one [DecidableEq α] (f : α → M) (x : α) {y : M} (hy : y ≠ 1) :\n    mulSupport (update f x y) = insert x (mulSupport f) := by\n  ext a; rcases eq_or_ne a x with rfl | hne <;> simp [*]\n\n"}
{"name":"Function.mulSupport_update_of_ne_one","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : One M\ninst✝ : DecidableEq α\nf : α → M\nx : α\ny : M\nhy : Ne y 1\n⊢ Eq (Function.mulSupport (Function.update f x y)) (Insert.insert x (Function.mulSupport f))","decl":"@[to_additive]\ntheorem mulSupport_update_of_ne_one [DecidableEq α] (f : α → M) (x : α) {y : M} (hy : y ≠ 1) :\n    mulSupport (update f x y) = insert x (mulSupport f) := by\n  ext a; rcases eq_or_ne a x with rfl | hne <;> simp [*]\n\n"}
{"name":"Function.mulSupport_update_one","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : One M\ninst✝ : DecidableEq α\nf : α → M\nx : α\n⊢ Eq (Function.mulSupport (Function.update f x 1)) (SDiff.sdiff (Function.mulSupport f) (Singleton.singleton x))","decl":"@[to_additive]\ntheorem mulSupport_update_one [DecidableEq α] (f : α → M) (x : α) :\n    mulSupport (update f x 1) = mulSupport f \\ {x} := by\n  ext a; rcases eq_or_ne a x with rfl | hne <;> simp [*]\n\n"}
{"name":"Function.support_update_zero","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝¹ : Zero M\ninst✝ : DecidableEq α\nf : α → M\nx : α\n⊢ Eq (Function.support (Function.update f x 0)) (SDiff.sdiff (Function.support f) (Singleton.singleton x))","decl":"@[to_additive]\ntheorem mulSupport_update_one [DecidableEq α] (f : α → M) (x : α) :\n    mulSupport (update f x 1) = mulSupport f \\ {x} := by\n  ext a; rcases eq_or_ne a x with rfl | hne <;> simp [*]\n\n"}
{"name":"Function.support_update_eq_ite","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝² : Zero M\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq M\nf : α → M\nx : α\ny : M\n⊢ Eq (Function.support (Function.update f x y)) (ite (Eq y 0) (SDiff.sdiff (Function.support f) (Singleton.singleton x)) (Insert.insert x (Function.support f)))","decl":"@[to_additive]\ntheorem mulSupport_update_eq_ite [DecidableEq α] [DecidableEq M] (f : α → M) (x : α) (y : M) :\n    mulSupport (update f x y) = if y = 1 then mulSupport f \\ {x} else insert x (mulSupport f) := by\n  rcases eq_or_ne y 1 with rfl | hy <;> simp [mulSupport_update_one, mulSupport_update_of_ne_one, *]\n\n"}
{"name":"Function.mulSupport_update_eq_ite","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝² : One M\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq M\nf : α → M\nx : α\ny : M\n⊢ Eq (Function.mulSupport (Function.update f x y)) (ite (Eq y 1) (SDiff.sdiff (Function.mulSupport f) (Singleton.singleton x)) (Insert.insert x (Function.mulSupport f)))","decl":"@[to_additive]\ntheorem mulSupport_update_eq_ite [DecidableEq α] [DecidableEq M] (f : α → M) (x : α) (y : M) :\n    mulSupport (update f x y) = if y = 1 then mulSupport f \\ {x} else insert x (mulSupport f) := by\n  rcases eq_or_ne y 1 with rfl | hy <;> simp [mulSupport_update_one, mulSupport_update_of_ne_one, *]\n\n"}
{"name":"Function.mulSupport_extend_one_subset","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM' : Type u_6\nN : Type u_7\ninst✝ : One N\nf : α → M'\ng : α → N\n⊢ HasSubset.Subset (Function.mulSupport (Function.extend f g 1)) (Set.image f (Function.mulSupport g))","decl":"@[to_additive]\ntheorem mulSupport_extend_one_subset {f : α → M'} {g : α → N} :\n    mulSupport (f.extend g 1) ⊆ f '' mulSupport g :=\n  mulSupport_subset_iff'.mpr fun x hfg ↦ by\n    by_cases hf : ∃ a, f a = x\n    · rw [extend, dif_pos hf, ← nmem_mulSupport]\n      rw [← Classical.choose_spec hf] at hfg\n      exact fun hg ↦ hfg ⟨_, hg, rfl⟩\n    · rw [extend_apply' _ _ _ hf]; rfl\n\n"}
{"name":"Function.support_extend_zero_subset","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM' : Type u_6\nN : Type u_7\ninst✝ : Zero N\nf : α → M'\ng : α → N\n⊢ HasSubset.Subset (Function.support (Function.extend f g 0)) (Set.image f (Function.support g))","decl":"@[to_additive]\ntheorem mulSupport_extend_one_subset {f : α → M'} {g : α → N} :\n    mulSupport (f.extend g 1) ⊆ f '' mulSupport g :=\n  mulSupport_subset_iff'.mpr fun x hfg ↦ by\n    by_cases hf : ∃ a, f a = x\n    · rw [extend, dif_pos hf, ← nmem_mulSupport]\n      rw [← Classical.choose_spec hf] at hfg\n      exact fun hg ↦ hfg ⟨_, hg, rfl⟩\n    · rw [extend_apply' _ _ _ hf]; rfl\n\n"}
{"name":"Function.mulSupport_extend_one","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM' : Type u_6\nN : Type u_7\ninst✝ : One N\nf : α → M'\ng : α → N\nhf : Function.Injective f\n⊢ Eq (Function.mulSupport (Function.extend f g 1)) (Set.image f (Function.mulSupport g))","decl":"@[to_additive]\ntheorem mulSupport_extend_one {f : α → M'} {g : α → N} (hf : f.Injective) :\n    mulSupport (f.extend g 1) = f '' mulSupport g :=\n  mulSupport_extend_one_subset.antisymm <| by\n    rintro _ ⟨x, hx, rfl⟩; rwa [mem_mulSupport, hf.extend_apply]\n\n"}
{"name":"Function.support_extend_zero","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM' : Type u_6\nN : Type u_7\ninst✝ : Zero N\nf : α → M'\ng : α → N\nhf : Function.Injective f\n⊢ Eq (Function.support (Function.extend f g 0)) (Set.image f (Function.support g))","decl":"@[to_additive]\ntheorem mulSupport_extend_one {f : α → M'} {g : α → N} (hf : f.Injective) :\n    mulSupport (f.extend g 1) = f '' mulSupport g :=\n  mulSupport_extend_one_subset.antisymm <| by\n    rintro _ ⟨x, hx, rfl⟩; rwa [mem_mulSupport, hf.extend_apply]\n\n"}
{"name":"Function.mulSupport_disjoint_iff","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : One M\nf : α → M\ns : Set α\n⊢ Iff (Disjoint (Function.mulSupport f) s) (Set.EqOn f 1 s)","decl":"@[to_additive]\ntheorem mulSupport_disjoint_iff {f : α → M} {s : Set α} :\n    Disjoint (mulSupport f) s ↔ EqOn f 1 s := by\n  simp_rw [← subset_compl_iff_disjoint_right, mulSupport_subset_iff', not_mem_compl_iff, EqOn,\n    Pi.one_apply]\n\n"}
{"name":"Function.support_disjoint_iff","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : α → M\ns : Set α\n⊢ Iff (Disjoint (Function.support f) s) (Set.EqOn f 0 s)","decl":"@[to_additive]\ntheorem mulSupport_disjoint_iff {f : α → M} {s : Set α} :\n    Disjoint (mulSupport f) s ↔ EqOn f 1 s := by\n  simp_rw [← subset_compl_iff_disjoint_right, mulSupport_subset_iff', not_mem_compl_iff, EqOn,\n    Pi.one_apply]\n\n"}
{"name":"Function.disjoint_support_iff","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : α → M\ns : Set α\n⊢ Iff (Disjoint s (Function.support f)) (Set.EqOn f 0 s)","decl":"@[to_additive]\ntheorem disjoint_mulSupport_iff {f : α → M} {s : Set α} :\n    Disjoint s (mulSupport f) ↔ EqOn f 1 s := by\n  rw [disjoint_comm, mulSupport_disjoint_iff]\n\n"}
{"name":"Function.disjoint_mulSupport_iff","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : One M\nf : α → M\ns : Set α\n⊢ Iff (Disjoint s (Function.mulSupport f)) (Set.EqOn f 1 s)","decl":"@[to_additive]\ntheorem disjoint_mulSupport_iff {f : α → M} {s : Set α} :\n    Disjoint s (mulSupport f) ↔ EqOn f 1 s := by\n  rw [disjoint_comm, mulSupport_disjoint_iff]\n\n"}
{"name":"Function.support_eq_empty_iff","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : α → M\n⊢ Iff (Eq (Function.support f) EmptyCollection.emptyCollection) (Eq f 0)","decl":"@[to_additive (attr := simp)]\ntheorem mulSupport_eq_empty_iff {f : α → M} : mulSupport f = ∅ ↔ f = 1 := by\n  rw [← subset_empty_iff, mulSupport_subset_iff', funext_iff]\n  simp\n\n"}
{"name":"Function.mulSupport_eq_empty_iff","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : One M\nf : α → M\n⊢ Iff (Eq (Function.mulSupport f) EmptyCollection.emptyCollection) (Eq f 1)","decl":"@[to_additive (attr := simp)]\ntheorem mulSupport_eq_empty_iff {f : α → M} : mulSupport f = ∅ ↔ f = 1 := by\n  rw [← subset_empty_iff, mulSupport_subset_iff', funext_iff]\n  simp\n\n"}
{"name":"Function.support_nonempty_iff","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : α → M\n⊢ Iff (Function.support f).Nonempty (Ne f 0)","decl":"@[to_additive (attr := simp)]\ntheorem mulSupport_nonempty_iff {f : α → M} : (mulSupport f).Nonempty ↔ f ≠ 1 := by\n  rw [nonempty_iff_ne_empty, Ne, mulSupport_eq_empty_iff]\n\n"}
{"name":"Function.mulSupport_nonempty_iff","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : One M\nf : α → M\n⊢ Iff (Function.mulSupport f).Nonempty (Ne f 1)","decl":"@[to_additive (attr := simp)]\ntheorem mulSupport_nonempty_iff {f : α → M} : (mulSupport f).Nonempty ↔ f ≠ 1 := by\n  rw [nonempty_iff_ne_empty, Ne, mulSupport_eq_empty_iff]\n\n"}
{"name":"Function.range_subset_insert_image_mulSupport","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : One M\nf : α → M\n⊢ HasSubset.Subset (Set.range f) (Insert.insert 1 (Set.image f (Function.mulSupport f)))","decl":"@[to_additive]\ntheorem range_subset_insert_image_mulSupport (f : α → M) :\n    range f ⊆ insert 1 (f '' mulSupport f) := by\n  simpa only [range_subset_iff, mem_insert_iff, or_iff_not_imp_left] using\n    fun x (hx : x ∈ mulSupport f) => mem_image_of_mem f hx\n\n"}
{"name":"Function.range_subset_insert_image_support","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : α → M\n⊢ HasSubset.Subset (Set.range f) (Insert.insert 0 (Set.image f (Function.support f)))","decl":"@[to_additive]\ntheorem range_subset_insert_image_mulSupport (f : α → M) :\n    range f ⊆ insert 1 (f '' mulSupport f) := by\n  simpa only [range_subset_iff, mem_insert_iff, or_iff_not_imp_left] using\n    fun x (hx : x ∈ mulSupport f) => mem_image_of_mem f hx\n\n"}
{"name":"Function.range_eq_image_or_of_support_subset","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nf : α → M\nk : Set α\nh : HasSubset.Subset (Function.support f) k\n⊢ Or (Eq (Set.range f) (Set.image f k)) (Eq (Set.range f) (Insert.insert 0 (Set.image f k)))","decl":"@[to_additive]\nlemma range_eq_image_or_of_mulSupport_subset {f : α → M} {k : Set α} (h : mulSupport f ⊆ k) :\n    range f = f '' k ∨ range f = insert 1 (f '' k) := by\n  apply (wcovBy_insert _ _).eq_or_eq (image_subset_range _ _)\n  exact (range_subset_insert_image_mulSupport f).trans (insert_subset_insert (image_subset f h))\n\n"}
{"name":"Function.range_eq_image_or_of_mulSupport_subset","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : One M\nf : α → M\nk : Set α\nh : HasSubset.Subset (Function.mulSupport f) k\n⊢ Or (Eq (Set.range f) (Set.image f k)) (Eq (Set.range f) (Insert.insert 1 (Set.image f k)))","decl":"@[to_additive]\nlemma range_eq_image_or_of_mulSupport_subset {f : α → M} {k : Set α} (h : mulSupport f ⊆ k) :\n    range f = f '' k ∨ range f = insert 1 (f '' k) := by\n  apply (wcovBy_insert _ _).eq_or_eq (image_subset_range _ _)\n  exact (range_subset_insert_image_mulSupport f).trans (insert_subset_insert (image_subset f h))\n\n"}
{"name":"Function.support_zero'","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\n⊢ Eq (Function.support 0) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem mulSupport_one' : mulSupport (1 : α → M) = ∅ :=\n  mulSupport_eq_empty_iff.2 rfl\n\n"}
{"name":"Function.mulSupport_one'","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : One M\n⊢ Eq (Function.mulSupport 1) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem mulSupport_one' : mulSupport (1 : α → M) = ∅ :=\n  mulSupport_eq_empty_iff.2 rfl\n\n"}
{"name":"Function.support_zero","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\n⊢ Eq (Function.support fun x => 0) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem mulSupport_one : (mulSupport fun _ : α => (1 : M)) = ∅ :=\n  mulSupport_one'\n\n"}
{"name":"Function.mulSupport_one","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : One M\n⊢ Eq (Function.mulSupport fun x => 1) EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem mulSupport_one : (mulSupport fun _ : α => (1 : M)) = ∅ :=\n  mulSupport_one'\n\n"}
{"name":"Function.support_const","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Zero M\nc : M\nhc : Ne c 0\n⊢ Eq (Function.support fun x => c) Set.univ","decl":"@[to_additive]\ntheorem mulSupport_const {c : M} (hc : c ≠ 1) : (mulSupport fun _ : α => c) = Set.univ := by\n  ext x\n  simp [hc]\n\n"}
{"name":"Function.mulSupport_const","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : One M\nc : M\nhc : Ne c 1\n⊢ Eq (Function.mulSupport fun x => c) Set.univ","decl":"@[to_additive]\ntheorem mulSupport_const {c : M} (hc : c ≠ 1) : (mulSupport fun _ : α => c) = Set.univ := by\n  ext x\n  simp [hc]\n\n"}
{"name":"Function.support_binop_subset","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\nP : Type u_8\ninst✝² : Zero M\ninst✝¹ : Zero N\ninst✝ : Zero P\nop : M → N → P\nop1 : Eq (op 0 0) 0\nf : α → M\ng : α → N\n⊢ HasSubset.Subset (Function.support fun x => op (f x) (g x)) (Union.union (Function.support f) (Function.support g))","decl":"@[to_additive]\ntheorem mulSupport_binop_subset (op : M → N → P) (op1 : op 1 1 = 1) (f : α → M) (g : α → N) :\n    (mulSupport fun x => op (f x) (g x)) ⊆ mulSupport f ∪ mulSupport g := fun x hx =>\n  not_or_of_imp fun hf hg => hx <| by simp only [hf, hg, op1]\n\n"}
{"name":"Function.mulSupport_binop_subset","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\nP : Type u_8\ninst✝² : One M\ninst✝¹ : One N\ninst✝ : One P\nop : M → N → P\nop1 : Eq (op 1 1) 1\nf : α → M\ng : α → N\n⊢ HasSubset.Subset (Function.mulSupport fun x => op (f x) (g x)) (Union.union (Function.mulSupport f) (Function.mulSupport g))","decl":"@[to_additive]\ntheorem mulSupport_binop_subset (op : M → N → P) (op1 : op 1 1 = 1) (f : α → M) (g : α → N) :\n    (mulSupport fun x => op (f x) (g x)) ⊆ mulSupport f ∪ mulSupport g := fun x hx =>\n  not_or_of_imp fun hf hg => hx <| by simp only [hf, hg, op1]\n\n"}
{"name":"Function.support_comp_subset","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\ninst✝ : Zero N\ng : M → N\nhg : Eq (g 0) 0\nf : α → M\n⊢ HasSubset.Subset (Function.support (Function.comp g f)) (Function.support f)","decl":"@[to_additive]\ntheorem mulSupport_comp_subset {g : M → N} (hg : g 1 = 1) (f : α → M) :\n    mulSupport (g ∘ f) ⊆ mulSupport f := fun x => mt fun h => by simp only [(· ∘ ·), *]\n\n"}
{"name":"Function.mulSupport_comp_subset","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : One M\ninst✝ : One N\ng : M → N\nhg : Eq (g 1) 1\nf : α → M\n⊢ HasSubset.Subset (Function.mulSupport (Function.comp g f)) (Function.mulSupport f)","decl":"@[to_additive]\ntheorem mulSupport_comp_subset {g : M → N} (hg : g 1 = 1) (f : α → M) :\n    mulSupport (g ∘ f) ⊆ mulSupport f := fun x => mt fun h => by simp only [(· ∘ ·), *]\n\n"}
{"name":"Function.support_subset_comp","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\ninst✝ : Zero N\ng : M → N\nhg : ∀ {x : M}, Eq (g x) 0 → Eq x 0\nf : α → M\n⊢ HasSubset.Subset (Function.support f) (Function.support (Function.comp g f))","decl":"@[to_additive]\ntheorem mulSupport_subset_comp {g : M → N} (hg : ∀ {x}, g x = 1 → x = 1) (f : α → M) :\n    mulSupport f ⊆ mulSupport (g ∘ f) := fun _ => mt hg\n\n"}
{"name":"Function.mulSupport_subset_comp","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : One M\ninst✝ : One N\ng : M → N\nhg : ∀ {x : M}, Eq (g x) 1 → Eq x 1\nf : α → M\n⊢ HasSubset.Subset (Function.mulSupport f) (Function.mulSupport (Function.comp g f))","decl":"@[to_additive]\ntheorem mulSupport_subset_comp {g : M → N} (hg : ∀ {x}, g x = 1 → x = 1) (f : α → M) :\n    mulSupport f ⊆ mulSupport (g ∘ f) := fun _ => mt hg\n\n"}
{"name":"Function.mulSupport_comp_eq","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : One M\ninst✝ : One N\ng : M → N\nhg : ∀ {x : M}, Iff (Eq (g x) 1) (Eq x 1)\nf : α → M\n⊢ Eq (Function.mulSupport (Function.comp g f)) (Function.mulSupport f)","decl":"@[to_additive]\ntheorem mulSupport_comp_eq (g : M → N) (hg : ∀ {x}, g x = 1 ↔ x = 1) (f : α → M) :\n    mulSupport (g ∘ f) = mulSupport f :=\n  Set.ext fun _ => not_congr hg\n\n"}
{"name":"Function.support_comp_eq","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\ninst✝ : Zero N\ng : M → N\nhg : ∀ {x : M}, Iff (Eq (g x) 0) (Eq x 0)\nf : α → M\n⊢ Eq (Function.support (Function.comp g f)) (Function.support f)","decl":"@[to_additive]\ntheorem mulSupport_comp_eq (g : M → N) (hg : ∀ {x}, g x = 1 ↔ x = 1) (f : α → M) :\n    mulSupport (g ∘ f) = mulSupport f :=\n  Set.ext fun _ => not_congr hg\n\n"}
{"name":"Function.support_comp_eq_of_range_subset","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\ninst✝ : Zero N\ng : M → N\nf : α → M\nhg : ∀ {x : M}, Membership.mem (Set.range f) x → Iff (Eq (g x) 0) (Eq x 0)\n⊢ Eq (Function.support (Function.comp g f)) (Function.support f)","decl":"@[to_additive]\ntheorem mulSupport_comp_eq_of_range_subset {g : M → N} {f : α → M}\n    (hg : ∀ {x}, x ∈ range f → (g x = 1 ↔ x = 1)) :\n    mulSupport (g ∘ f) = mulSupport f :=\n  Set.ext fun x ↦ not_congr <| by rw [Function.comp, hg (mem_range_self x)]\n\n"}
{"name":"Function.mulSupport_comp_eq_of_range_subset","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : One M\ninst✝ : One N\ng : M → N\nf : α → M\nhg : ∀ {x : M}, Membership.mem (Set.range f) x → Iff (Eq (g x) 1) (Eq x 1)\n⊢ Eq (Function.mulSupport (Function.comp g f)) (Function.mulSupport f)","decl":"@[to_additive]\ntheorem mulSupport_comp_eq_of_range_subset {g : M → N} {f : α → M}\n    (hg : ∀ {x}, x ∈ range f → (g x = 1 ↔ x = 1)) :\n    mulSupport (g ∘ f) = mulSupport f :=\n  Set.ext fun x ↦ not_congr <| by rw [Function.comp, hg (mem_range_self x)]\n\n"}
{"name":"Function.mulSupport_comp_eq_preimage","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : One M\ng : β → M\nf : α → β\n⊢ Eq (Function.mulSupport (Function.comp g f)) (Set.preimage f (Function.mulSupport g))","decl":"@[to_additive]\ntheorem mulSupport_comp_eq_preimage (g : β → M) (f : α → β) :\n    mulSupport (g ∘ f) = f ⁻¹' mulSupport g :=\n  rfl\n\n"}
{"name":"Function.support_comp_eq_preimage","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\ng : β → M\nf : α → β\n⊢ Eq (Function.support (Function.comp g f)) (Set.preimage f (Function.support g))","decl":"@[to_additive]\ntheorem mulSupport_comp_eq_preimage (g : β → M) (f : α → β) :\n    mulSupport (g ∘ f) = f ⁻¹' mulSupport g :=\n  rfl\n\n"}
{"name":"Function.mulSupport_prod_mk","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : One M\ninst✝ : One N\nf : α → M\ng : α → N\n⊢ Eq (Function.mulSupport fun x => { fst := f x, snd := g x }) (Union.union (Function.mulSupport f) (Function.mulSupport g))","decl":"@[to_additive support_prod_mk]\ntheorem mulSupport_prod_mk (f : α → M) (g : α → N) :\n    (mulSupport fun x => (f x, g x)) = mulSupport f ∪ mulSupport g :=\n  Set.ext fun x => by\n    simp only [mulSupport, not_and_or, mem_union, mem_setOf_eq, Prod.mk_eq_one, Ne]\n\n"}
{"name":"Function.support_prod_mk","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\ninst✝ : Zero N\nf : α → M\ng : α → N\n⊢ Eq (Function.support fun x => { fst := f x, snd := g x }) (Union.union (Function.support f) (Function.support g))","decl":"@[to_additive support_prod_mk]\ntheorem mulSupport_prod_mk (f : α → M) (g : α → N) :\n    (mulSupport fun x => (f x, g x)) = mulSupport f ∪ mulSupport g :=\n  Set.ext fun x => by\n    simp only [mulSupport, not_and_or, mem_union, mem_setOf_eq, Prod.mk_eq_one, Ne]\n\n"}
{"name":"Function.mulSupport_prod_mk'","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : One M\ninst✝ : One N\nf : α → Prod M N\n⊢ Eq (Function.mulSupport f) (Union.union (Function.mulSupport fun x => (f x).1) (Function.mulSupport fun x => (f x).2))","decl":"@[to_additive support_prod_mk']\ntheorem mulSupport_prod_mk' (f : α → M × N) :\n    mulSupport f = (mulSupport fun x => (f x).1) ∪ mulSupport fun x => (f x).2 := by\n  simp only [← mulSupport_prod_mk]\n\n"}
{"name":"Function.support_prod_mk'","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\nN : Type u_7\ninst✝¹ : Zero M\ninst✝ : Zero N\nf : α → Prod M N\n⊢ Eq (Function.support f) (Union.union (Function.support fun x => (f x).1) (Function.support fun x => (f x).2))","decl":"@[to_additive support_prod_mk']\ntheorem mulSupport_prod_mk' (f : α → M × N) :\n    mulSupport f = (mulSupport fun x => (f x).1) ∪ mulSupport fun x => (f x).2 := by\n  simp only [← mulSupport_prod_mk]\n\n"}
{"name":"Function.mulSupport_along_fiber_subset","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : One M\nf : Prod α β → M\na : α\n⊢ HasSubset.Subset (Function.mulSupport fun b => f { fst := a, snd := b }) (Set.image Prod.snd (Function.mulSupport f))","decl":"@[to_additive]\ntheorem mulSupport_along_fiber_subset (f : α × β → M) (a : α) :\n    (mulSupport fun b => f (a, b)) ⊆ (mulSupport f).image Prod.snd :=\n  fun x hx => ⟨(a, x), by simpa using hx⟩\n\n"}
{"name":"Function.support_along_fiber_subset","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : Prod α β → M\na : α\n⊢ HasSubset.Subset (Function.support fun b => f { fst := a, snd := b }) (Set.image Prod.snd (Function.support f))","decl":"@[to_additive]\ntheorem mulSupport_along_fiber_subset (f : α × β → M) (a : α) :\n    (mulSupport fun b => f (a, b)) ⊆ (mulSupport f).image Prod.snd :=\n  fun x hx => ⟨(a, x), by simpa using hx⟩\n\n"}
{"name":"Function.mulSupport_curry","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : One M\nf : Prod α β → M\n⊢ Eq (Function.mulSupport (Function.curry f)) (Set.image Prod.fst (Function.mulSupport f))","decl":"@[to_additive]\ntheorem mulSupport_curry (f : α × β → M) :\n    (mulSupport f.curry) = (mulSupport f).image Prod.fst := by\n  simp [mulSupport, funext_iff, image]\n\n"}
{"name":"Function.support_curry","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : Prod α β → M\n⊢ Eq (Function.support (Function.curry f)) (Set.image Prod.fst (Function.support f))","decl":"@[to_additive]\ntheorem mulSupport_curry (f : α × β → M) :\n    (mulSupport f.curry) = (mulSupport f).image Prod.fst := by\n  simp [mulSupport, funext_iff, image]\n\n"}
{"name":"Function.support_curry'","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : Zero M\nf : Prod α β → M\n⊢ Eq (Function.support fun a b => f { fst := a, snd := b }) (Set.image Prod.fst (Function.support f))","decl":"@[to_additive]\ntheorem mulSupport_curry' (f : α × β → M) :\n    (mulSupport fun a b ↦ f (a, b)) = (mulSupport f).image Prod.fst :=\n  mulSupport_curry f\n\n"}
{"name":"Function.mulSupport_curry'","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_5\ninst✝ : One M\nf : Prod α β → M\n⊢ Eq (Function.mulSupport fun a b => f { fst := a, snd := b }) (Set.image Prod.fst (Function.mulSupport f))","decl":"@[to_additive]\ntheorem mulSupport_curry' (f : α × β → M) :\n    (mulSupport fun a b ↦ f (a, b)) = (mulSupport f).image Prod.fst :=\n  mulSupport_curry f\n\n"}
{"name":"Function.mulSupport_mul","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : MulOneClass M\nf g : α → M\n⊢ HasSubset.Subset (Function.mulSupport fun x => HMul.hMul (f x) (g x)) (Union.union (Function.mulSupport f) (Function.mulSupport g))","decl":"@[to_additive]\ntheorem mulSupport_mul [MulOneClass M] (f g : α → M) :\n    (mulSupport fun x => f x * g x) ⊆ mulSupport f ∪ mulSupport g :=\n  mulSupport_binop_subset (· * ·) (one_mul _) f g\n\n"}
{"name":"Function.support_add","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddZeroClass M\nf g : α → M\n⊢ HasSubset.Subset (Function.support fun x => HAdd.hAdd (f x) (g x)) (Union.union (Function.support f) (Function.support g))","decl":"@[to_additive]\ntheorem mulSupport_mul [MulOneClass M] (f g : α → M) :\n    (mulSupport fun x => f x * g x) ⊆ mulSupport f ∪ mulSupport g :=\n  mulSupport_binop_subset (· * ·) (one_mul _) f g\n\n"}
{"name":"Function.mulSupport_pow","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : Monoid M\nf : α → M\nn : Nat\n⊢ HasSubset.Subset (Function.mulSupport fun x => HPow.hPow (f x) n) (Function.mulSupport f)","decl":"@[to_additive]\ntheorem mulSupport_pow [Monoid M] (f : α → M) (n : ℕ) :\n    (mulSupport fun x => f x ^ n) ⊆ mulSupport f := by\n  induction n with\n  | zero => simp [pow_zero, mulSupport_one]\n  | succ n hfn =>\n    simpa only [pow_succ'] using (mulSupport_mul f _).trans (union_subset Subset.rfl hfn)\n\n"}
{"name":"Function.support_nsmul","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nM : Type u_5\ninst✝ : AddMonoid M\nf : α → M\nn : Nat\n⊢ HasSubset.Subset (Function.support fun x => HSMul.hSMul n (f x)) (Function.support f)","decl":"@[to_additive]\ntheorem mulSupport_pow [Monoid M] (f : α → M) (n : ℕ) :\n    (mulSupport fun x => f x ^ n) ⊆ mulSupport f := by\n  induction n with\n  | zero => simp [pow_zero, mulSupport_one]\n  | succ n hfn =>\n    simpa only [pow_succ'] using (mulSupport_mul f _).trans (union_subset Subset.rfl hfn)\n\n"}
{"name":"Function.mulSupport_inv","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝ : DivisionMonoid G\nf : α → G\n⊢ Eq (Function.mulSupport fun x => Inv.inv (f x)) (Function.mulSupport f)","decl":"@[to_additive (attr := simp)]\ntheorem mulSupport_inv : (mulSupport fun x => (f x)⁻¹) = mulSupport f :=\n  ext fun _ => inv_ne_one\n\n"}
{"name":"Function.support_neg","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝ : SubtractionMonoid G\nf : α → G\n⊢ Eq (Function.support fun x => Neg.neg (f x)) (Function.support f)","decl":"@[to_additive (attr := simp)]\ntheorem mulSupport_inv : (mulSupport fun x => (f x)⁻¹) = mulSupport f :=\n  ext fun _ => inv_ne_one\n\n"}
{"name":"Function.mulSupport_inv'","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝ : DivisionMonoid G\nf : α → G\n⊢ Eq (Function.mulSupport (Inv.inv f)) (Function.mulSupport f)","decl":"@[to_additive (attr := simp)]\ntheorem mulSupport_inv' : mulSupport f⁻¹ = mulSupport f :=\n  mulSupport_inv f\n\n"}
{"name":"Function.support_neg'","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝ : SubtractionMonoid G\nf : α → G\n⊢ Eq (Function.support (Neg.neg f)) (Function.support f)","decl":"@[to_additive (attr := simp)]\ntheorem mulSupport_inv' : mulSupport f⁻¹ = mulSupport f :=\n  mulSupport_inv f\n\n"}
{"name":"Function.mulSupport_mul_inv","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝ : DivisionMonoid G\nf g : α → G\n⊢ HasSubset.Subset (Function.mulSupport fun x => HMul.hMul (f x) (Inv.inv (g x))) (Union.union (Function.mulSupport f) (Function.mulSupport g))","decl":"@[to_additive]\ntheorem mulSupport_mul_inv : (mulSupport fun x => f x * (g x)⁻¹) ⊆ mulSupport f ∪ mulSupport g :=\n  mulSupport_binop_subset (fun a b => a * b⁻¹) (by simp) f g\n\n"}
{"name":"Function.support_add_neg","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝ : SubtractionMonoid G\nf g : α → G\n⊢ HasSubset.Subset (Function.support fun x => HAdd.hAdd (f x) (Neg.neg (g x))) (Union.union (Function.support f) (Function.support g))","decl":"@[to_additive]\ntheorem mulSupport_mul_inv : (mulSupport fun x => f x * (g x)⁻¹) ⊆ mulSupport f ∪ mulSupport g :=\n  mulSupport_binop_subset (fun a b => a * b⁻¹) (by simp) f g\n\n"}
{"name":"Function.mulSupport_div","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝ : DivisionMonoid G\nf g : α → G\n⊢ HasSubset.Subset (Function.mulSupport fun x => HDiv.hDiv (f x) (g x)) (Union.union (Function.mulSupport f) (Function.mulSupport g))","decl":"@[to_additive]\ntheorem mulSupport_div : (mulSupport fun x => f x / g x) ⊆ mulSupport f ∪ mulSupport g :=\n  mulSupport_binop_subset (· / ·) one_div_one f g\n\n"}
{"name":"Function.support_sub","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nG : Type u_9\ninst✝ : SubtractionMonoid G\nf g : α → G\n⊢ HasSubset.Subset (Function.support fun x => HSub.hSub (f x) (g x)) (Union.union (Function.support f) (Function.support g))","decl":"@[to_additive]\ntheorem mulSupport_div : (mulSupport fun x => f x / g x) ⊆ mulSupport f ∪ mulSupport g :=\n  mulSupport_binop_subset (· / ·) one_div_one f g\n\n"}
{"name":"Set.image_inter_support_eq","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_3\ninst✝ : Zero M\nf : α → M\ns : Set β\ng : β → α\n⊢ Eq (Inter.inter (Set.image g s) (Function.support f)) (Set.image g (Inter.inter s (Function.support (Function.comp f g))))","decl":"@[to_additive]\ntheorem image_inter_mulSupport_eq {s : Set β} {g : β → α} :\n    g '' s ∩ mulSupport f = g '' (s ∩ mulSupport (f ∘ g)) := by\n  rw [mulSupport_comp_eq_preimage f g, image_inter_preimage]\n\n"}
{"name":"Set.image_inter_mulSupport_eq","module":"Mathlib.Algebra.Group.Support","initialProofState":"α : Type u_1\nβ : Type u_2\nM : Type u_3\ninst✝ : One M\nf : α → M\ns : Set β\ng : β → α\n⊢ Eq (Inter.inter (Set.image g s) (Function.mulSupport f)) (Set.image g (Inter.inter s (Function.mulSupport (Function.comp f g))))","decl":"@[to_additive]\ntheorem image_inter_mulSupport_eq {s : Set β} {g : β → α} :\n    g '' s ∩ mulSupport f = g '' (s ∩ mulSupport (f ∘ g)) := by\n  rw [mulSupport_comp_eq_preimage f g, image_inter_preimage]\n\n"}
{"name":"Pi.support_single_subset","module":"Mathlib.Algebra.Group.Support","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : DecidableEq A\ninst✝ : Zero B\na : A\nb : B\n⊢ HasSubset.Subset (Function.support (Pi.single a b)) (Singleton.singleton a)","decl":"@[to_additive]\ntheorem mulSupport_mulSingle_subset : mulSupport (mulSingle a b) ⊆ {a} := fun _ hx =>\n  by_contra fun hx' => hx <| mulSingle_eq_of_ne hx' _\n\n"}
{"name":"Pi.mulSupport_mulSingle_subset","module":"Mathlib.Algebra.Group.Support","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : DecidableEq A\ninst✝ : One B\na : A\nb : B\n⊢ HasSubset.Subset (Function.mulSupport (Pi.mulSingle a b)) (Singleton.singleton a)","decl":"@[to_additive]\ntheorem mulSupport_mulSingle_subset : mulSupport (mulSingle a b) ⊆ {a} := fun _ hx =>\n  by_contra fun hx' => hx <| mulSingle_eq_of_ne hx' _\n\n"}
{"name":"Pi.support_single_zero","module":"Mathlib.Algebra.Group.Support","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : DecidableEq A\ninst✝ : Zero B\na : A\n⊢ Eq (Function.support (Pi.single a 0)) EmptyCollection.emptyCollection","decl":"@[to_additive]\ntheorem mulSupport_mulSingle_one : mulSupport (mulSingle a (1 : B)) = ∅ := by simp\n\n"}
{"name":"Pi.mulSupport_mulSingle_one","module":"Mathlib.Algebra.Group.Support","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : DecidableEq A\ninst✝ : One B\na : A\n⊢ Eq (Function.mulSupport (Pi.mulSingle a 1)) EmptyCollection.emptyCollection","decl":"@[to_additive]\ntheorem mulSupport_mulSingle_one : mulSupport (mulSingle a (1 : B)) = ∅ := by simp\n\n"}
{"name":"Pi.mulSupport_mulSingle_of_ne","module":"Mathlib.Algebra.Group.Support","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : DecidableEq A\ninst✝ : One B\na : A\nb : B\nh : Ne b 1\n⊢ Eq (Function.mulSupport (Pi.mulSingle a b)) (Singleton.singleton a)","decl":"@[to_additive (attr := simp)]\ntheorem mulSupport_mulSingle_of_ne (h : b ≠ 1) : mulSupport (mulSingle a b) = {a} :=\n  mulSupport_mulSingle_subset.antisymm fun x (hx : x = a) => by\n    rwa [mem_mulSupport, hx, mulSingle_eq_same]\n\n"}
{"name":"Pi.support_single_of_ne","module":"Mathlib.Algebra.Group.Support","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : DecidableEq A\ninst✝ : Zero B\na : A\nb : B\nh : Ne b 0\n⊢ Eq (Function.support (Pi.single a b)) (Singleton.singleton a)","decl":"@[to_additive (attr := simp)]\ntheorem mulSupport_mulSingle_of_ne (h : b ≠ 1) : mulSupport (mulSingle a b) = {a} :=\n  mulSupport_mulSingle_subset.antisymm fun x (hx : x = a) => by\n    rwa [mem_mulSupport, hx, mulSingle_eq_same]\n\n"}
{"name":"Pi.mulSupport_mulSingle","module":"Mathlib.Algebra.Group.Support","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝² : DecidableEq A\ninst✝¹ : One B\na : A\nb : B\ninst✝ : DecidableEq B\n⊢ Eq (Function.mulSupport (Pi.mulSingle a b)) (ite (Eq b 1) EmptyCollection.emptyCollection (Singleton.singleton a))","decl":"@[to_additive]\ntheorem mulSupport_mulSingle [DecidableEq B] :\n    mulSupport (mulSingle a b) = if b = 1 then ∅ else {a} := by split_ifs with h <;> simp [h]\n\n"}
{"name":"Pi.support_single","module":"Mathlib.Algebra.Group.Support","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝² : DecidableEq A\ninst✝¹ : Zero B\na : A\nb : B\ninst✝ : DecidableEq B\n⊢ Eq (Function.support (Pi.single a b)) (ite (Eq b 0) EmptyCollection.emptyCollection (Singleton.singleton a))","decl":"@[to_additive]\ntheorem mulSupport_mulSingle [DecidableEq B] :\n    mulSupport (mulSingle a b) = if b = 1 then ∅ else {a} := by split_ifs with h <;> simp [h]\n\n"}
{"name":"Pi.support_single_disjoint","module":"Mathlib.Algebra.Group.Support","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : DecidableEq A\ninst✝ : Zero B\nb b' : B\nhb : Ne b 0\nhb' : Ne b' 0\ni j : A\n⊢ Iff (Disjoint (Function.support (Pi.single i b)) (Function.support (Pi.single j b'))) (Ne i j)","decl":"@[to_additive]\ntheorem mulSupport_mulSingle_disjoint {b' : B} (hb : b ≠ 1) (hb' : b' ≠ 1) {i j : A} :\n    Disjoint (mulSupport (mulSingle i b)) (mulSupport (mulSingle j b')) ↔ i ≠ j := by\n  rw [mulSupport_mulSingle_of_ne hb, mulSupport_mulSingle_of_ne hb', disjoint_singleton]\n\n"}
{"name":"Pi.mulSupport_mulSingle_disjoint","module":"Mathlib.Algebra.Group.Support","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : DecidableEq A\ninst✝ : One B\nb b' : B\nhb : Ne b 1\nhb' : Ne b' 1\ni j : A\n⊢ Iff (Disjoint (Function.mulSupport (Pi.mulSingle i b)) (Function.mulSupport (Pi.mulSingle j b'))) (Ne i j)","decl":"@[to_additive]\ntheorem mulSupport_mulSingle_disjoint {b' : B} (hb : b ≠ 1) (hb' : b' ≠ 1) {i j : A} :\n    Disjoint (mulSupport (mulSingle i b)) (mulSupport (mulSingle j b')) ↔ i ≠ j := by\n  rw [mulSupport_mulSingle_of_ne hb, mulSupport_mulSingle_of_ne hb', disjoint_singleton]\n\n"}
