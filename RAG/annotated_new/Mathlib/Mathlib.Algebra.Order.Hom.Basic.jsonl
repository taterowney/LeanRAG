{"name":"NonnegHomClass.apply_nonneg","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : Zero β\ninst✝¹ : LE β\ninst✝ : FunLike F α β\nself : NonnegHomClass F α β\nf : F\na : α\n⊢ LE.le 0 (f a)","decl":"/-- `NonnegHomClass F α β` states that `F` is a type of nonnegative morphisms. -/\nclass NonnegHomClass (F : Type*) (α β : outParam Type*) [Zero β] [LE β] [FunLike F α β] : Prop where\n  /-- the image of any element is non negative. -/\n  apply_nonneg (f : F) : ∀ a, 0 ≤ f a\n\n"}
{"name":"SubadditiveHomClass.map_add_le_add","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝³ : Add α\ninst✝² : Add β\ninst✝¹ : LE β\ninst✝ : FunLike F α β\nself : SubadditiveHomClass F α β\nf : F\na b : α\n⊢ LE.le (f (HAdd.hAdd a b)) (HAdd.hAdd (f a) (f b))","decl":"/-- `SubadditiveHomClass F α β` states that `F` is a type of subadditive morphisms. -/\nclass SubadditiveHomClass (F : Type*) (α β : outParam Type*)\n    [Add α] [Add β] [LE β] [FunLike F α β] : Prop where\n  /-- the image of a sum is less or equal than the sum of the images. -/\n  map_add_le_add (f : F) : ∀ a b, f (a + b) ≤ f a + f b\n\n"}
{"name":"SubmultiplicativeHomClass.map_mul_le_mul","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝³ : Mul α\ninst✝² : Mul β\ninst✝¹ : LE β\ninst✝ : FunLike F α β\nself : SubmultiplicativeHomClass F α β\nf : F\na b : α\n⊢ LE.le (f (HMul.hMul a b)) (HMul.hMul (f a) (f b))","decl":"/-- `SubmultiplicativeHomClass F α β` states that `F` is a type of submultiplicative morphisms. -/\n@[to_additive SubadditiveHomClass]\nclass SubmultiplicativeHomClass (F : Type*) (α β : outParam (Type*)) [Mul α] [Mul β] [LE β]\n    [FunLike F α β] : Prop where\n  /-- the image of a product is less or equal than the product of the images. -/\n  map_mul_le_mul (f : F) : ∀ a b, f (a * b) ≤ f a * f b\n\n"}
{"name":"MulLEAddHomClass.map_mul_le_add","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝³ : Mul α\ninst✝² : Add β\ninst✝¹ : LE β\ninst✝ : FunLike F α β\nself : MulLEAddHomClass F α β\nf : F\na b : α\n⊢ LE.le (f (HMul.hMul a b)) (HAdd.hAdd (f a) (f b))","decl":"/-- `MulLEAddHomClass F α β` states that `F` is a type of subadditive morphisms. -/\n@[to_additive SubadditiveHomClass]\nclass MulLEAddHomClass (F : Type*) (α β : outParam Type*) [Mul α] [Add β] [LE β] [FunLike F α β] :\n    Prop where\n  /-- the image of a product is less or equal than the sum of the images. -/\n  map_mul_le_add (f : F) : ∀ a b, f (a * b) ≤ f a + f b\n\n"}
{"name":"NonarchimedeanHomClass.map_add_le_max","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : Add α\ninst✝¹ : LinearOrder β\ninst✝ : FunLike F α β\nself : NonarchimedeanHomClass F α β\nf : F\na b : α\n⊢ LE.le (f (HAdd.hAdd a b)) (Max.max (f a) (f b))","decl":"/-- `NonarchimedeanHomClass F α β` states that `F` is a type of non-archimedean morphisms. -/\nclass NonarchimedeanHomClass (F : Type*) (α β : outParam Type*)\n    [Add α] [LinearOrder β] [FunLike F α β] : Prop where\n  /-- the image of a sum is less or equal than the maximum of the images. -/\n  map_add_le_max (f : F) : ∀ a b, f (a + b) ≤ max (f a) (f b)\n\n"}
{"name":"le_map_mul_map_div","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝⁴ : FunLike F α β\ninst✝³ : Group α\ninst✝² : CommSemigroup β\ninst✝¹ : LE β\ninst✝ : SubmultiplicativeHomClass F α β\nf : F\na b : α\n⊢ LE.le (f a) (HMul.hMul (f b) (f (HDiv.hDiv a b)))","decl":"@[to_additive]\ntheorem le_map_mul_map_div [Group α] [CommSemigroup β] [LE β] [SubmultiplicativeHomClass F α β]\n    (f : F) (a b : α) : f a ≤ f b * f (a / b) := by\n  simpa only [mul_comm, div_mul_cancel] using map_mul_le_mul f (a / b) b\n\n"}
{"name":"le_map_add_map_sub","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝⁴ : FunLike F α β\ninst✝³ : AddGroup α\ninst✝² : AddCommSemigroup β\ninst✝¹ : LE β\ninst✝ : SubadditiveHomClass F α β\nf : F\na b : α\n⊢ LE.le (f a) (HAdd.hAdd (f b) (f (HSub.hSub a b)))","decl":"@[to_additive]\ntheorem le_map_mul_map_div [Group α] [CommSemigroup β] [LE β] [SubmultiplicativeHomClass F α β]\n    (f : F) (a b : α) : f a ≤ f b * f (a / b) := by\n  simpa only [mul_comm, div_mul_cancel] using map_mul_le_mul f (a / b) b\n\n"}
{"name":"le_map_add_map_div","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝⁴ : FunLike F α β\ninst✝³ : Group α\ninst✝² : AddCommSemigroup β\ninst✝¹ : LE β\ninst✝ : MulLEAddHomClass F α β\nf : F\na b : α\n⊢ LE.le (f a) (HAdd.hAdd (f b) (f (HDiv.hDiv a b)))","decl":"@[to_additive existing]\ntheorem le_map_add_map_div [Group α] [AddCommSemigroup β] [LE β] [MulLEAddHomClass F α β] (f : F)\n    (a b : α) : f a ≤ f b + f (a / b) := by\n  simpa only [add_comm, div_mul_cancel] using map_mul_le_add f (a / b) b\n\n"}
{"name":"le_map_div_mul_map_div","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝⁴ : FunLike F α β\ninst✝³ : Group α\ninst✝² : CommSemigroup β\ninst✝¹ : LE β\ninst✝ : SubmultiplicativeHomClass F α β\nf : F\na b c : α\n⊢ LE.le (f (HDiv.hDiv a c)) (HMul.hMul (f (HDiv.hDiv a b)) (f (HDiv.hDiv b c)))","decl":"@[to_additive]\ntheorem le_map_div_mul_map_div [Group α] [CommSemigroup β] [LE β] [SubmultiplicativeHomClass F α β]\n    (f : F) (a b c : α) : f (a / c) ≤ f (a / b) * f (b / c) := by\n  simpa only [div_mul_div_cancel] using map_mul_le_mul f (a / b) (b / c)\n\n"}
{"name":"le_map_sub_add_map_sub","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝⁴ : FunLike F α β\ninst✝³ : AddGroup α\ninst✝² : AddCommSemigroup β\ninst✝¹ : LE β\ninst✝ : SubadditiveHomClass F α β\nf : F\na b c : α\n⊢ LE.le (f (HSub.hSub a c)) (HAdd.hAdd (f (HSub.hSub a b)) (f (HSub.hSub b c)))","decl":"@[to_additive]\ntheorem le_map_div_mul_map_div [Group α] [CommSemigroup β] [LE β] [SubmultiplicativeHomClass F α β]\n    (f : F) (a b c : α) : f (a / c) ≤ f (a / b) * f (b / c) := by\n  simpa only [div_mul_div_cancel] using map_mul_le_mul f (a / b) (b / c)\n\n"}
{"name":"le_map_div_add_map_div","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝⁴ : FunLike F α β\ninst✝³ : Group α\ninst✝² : AddCommSemigroup β\ninst✝¹ : LE β\ninst✝ : MulLEAddHomClass F α β\nf : F\na b c : α\n⊢ LE.le (f (HDiv.hDiv a c)) (HAdd.hAdd (f (HDiv.hDiv a b)) (f (HDiv.hDiv b c)))","decl":"@[to_additive existing]\ntheorem le_map_div_add_map_div [Group α] [AddCommSemigroup β] [LE β] [MulLEAddHomClass F α β]\n    (f : F) (a b c : α) : f (a / c) ≤ f (a / b) + f (b / c) := by\n    simpa only [div_mul_div_cancel] using map_mul_le_add f (a / b) (b / c)\n\n"}
{"name":"AddGroupSeminormClass.map_zero","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : AddGroup α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : FunLike F α β\nself : AddGroupSeminormClass F α β\nf : F\n⊢ Eq (f 0) 0","decl":"/-- `AddGroupSeminormClass F α` states that `F` is a type of `β`-valued seminorms on the additive\ngroup `α`.\n\nYou should extend this class when you extend `AddGroupSeminorm`. -/\nclass AddGroupSeminormClass (F : Type*) (α β : outParam Type*)\n    [AddGroup α] [OrderedAddCommMonoid β] [FunLike F α β]\n  extends SubadditiveHomClass F α β : Prop where\n  /-- The image of zero is zero. -/\n  map_zero (f : F) : f 0 = 0\n  /-- The map is invariant under negation of its argument. -/\n  map_neg_eq_map (f : F) (a : α) : f (-a) = f a\n\n"}
{"name":"AddGroupSeminormClass.toSubadditiveHomClass","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : AddGroup α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : FunLike F α β\nself : AddGroupSeminormClass F α β\n⊢ SubadditiveHomClass F α β","decl":"/-- `AddGroupSeminormClass F α` states that `F` is a type of `β`-valued seminorms on the additive\ngroup `α`.\n\nYou should extend this class when you extend `AddGroupSeminorm`. -/\nclass AddGroupSeminormClass (F : Type*) (α β : outParam Type*)\n    [AddGroup α] [OrderedAddCommMonoid β] [FunLike F α β]\n  extends SubadditiveHomClass F α β : Prop where\n  /-- The image of zero is zero. -/\n  map_zero (f : F) : f 0 = 0\n  /-- The map is invariant under negation of its argument. -/\n  map_neg_eq_map (f : F) (a : α) : f (-a) = f a\n\n"}
{"name":"AddGroupSeminormClass.map_neg_eq_map","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : AddGroup α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : FunLike F α β\nself : AddGroupSeminormClass F α β\nf : F\na : α\n⊢ Eq (f (Neg.neg a)) (f a)","decl":"/-- `AddGroupSeminormClass F α` states that `F` is a type of `β`-valued seminorms on the additive\ngroup `α`.\n\nYou should extend this class when you extend `AddGroupSeminorm`. -/\nclass AddGroupSeminormClass (F : Type*) (α β : outParam Type*)\n    [AddGroup α] [OrderedAddCommMonoid β] [FunLike F α β]\n  extends SubadditiveHomClass F α β : Prop where\n  /-- The image of zero is zero. -/\n  map_zero (f : F) : f 0 = 0\n  /-- The map is invariant under negation of its argument. -/\n  map_neg_eq_map (f : F) (a : α) : f (-a) = f a\n\n"}
{"name":"GroupSeminormClass.map_one_eq_zero","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : Group α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : FunLike F α β\nself : GroupSeminormClass F α β\nf : F\n⊢ Eq (f 1) 0","decl":"/-- `GroupSeminormClass F α` states that `F` is a type of `β`-valued seminorms on the group `α`.\n\nYou should extend this class when you extend `GroupSeminorm`. -/\n@[to_additive]\nclass GroupSeminormClass (F : Type*) (α β : outParam Type*)\n    [Group α] [OrderedAddCommMonoid β] [FunLike F α β]\n  extends MulLEAddHomClass F α β : Prop where\n  /-- The image of one is zero. -/\n  map_one_eq_zero (f : F) : f 1 = 0\n  /-- The map is invariant under inversion of its argument. -/\n  map_inv_eq_map (f : F) (a : α) : f a⁻¹ = f a\n\n"}
{"name":"GroupSeminormClass.toMulLEAddHomClass","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : Group α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : FunLike F α β\nself : GroupSeminormClass F α β\n⊢ MulLEAddHomClass F α β","decl":"/-- `GroupSeminormClass F α` states that `F` is a type of `β`-valued seminorms on the group `α`.\n\nYou should extend this class when you extend `GroupSeminorm`. -/\n@[to_additive]\nclass GroupSeminormClass (F : Type*) (α β : outParam Type*)\n    [Group α] [OrderedAddCommMonoid β] [FunLike F α β]\n  extends MulLEAddHomClass F α β : Prop where\n  /-- The image of one is zero. -/\n  map_one_eq_zero (f : F) : f 1 = 0\n  /-- The map is invariant under inversion of its argument. -/\n  map_inv_eq_map (f : F) (a : α) : f a⁻¹ = f a\n\n"}
{"name":"GroupSeminormClass.map_inv_eq_map","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : Group α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : FunLike F α β\nself : GroupSeminormClass F α β\nf : F\na : α\n⊢ Eq (f (Inv.inv a)) (f a)","decl":"/-- `GroupSeminormClass F α` states that `F` is a type of `β`-valued seminorms on the group `α`.\n\nYou should extend this class when you extend `GroupSeminorm`. -/\n@[to_additive]\nclass GroupSeminormClass (F : Type*) (α β : outParam Type*)\n    [Group α] [OrderedAddCommMonoid β] [FunLike F α β]\n  extends MulLEAddHomClass F α β : Prop where\n  /-- The image of one is zero. -/\n  map_one_eq_zero (f : F) : f 1 = 0\n  /-- The map is invariant under inversion of its argument. -/\n  map_inv_eq_map (f : F) (a : α) : f a⁻¹ = f a\n\n"}
{"name":"AddGroupNormClass.toAddGroupSeminormClass","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : AddGroup α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : FunLike F α β\nself : AddGroupNormClass F α β\n⊢ AddGroupSeminormClass F α β","decl":"/-- `AddGroupNormClass F α` states that `F` is a type of `β`-valued norms on the additive group\n`α`.\n\nYou should extend this class when you extend `AddGroupNorm`. -/\nclass AddGroupNormClass (F : Type*) (α β : outParam Type*)\n    [AddGroup α] [OrderedAddCommMonoid β] [FunLike F α β]\n  extends AddGroupSeminormClass F α β : Prop where\n  /-- The argument is zero if its image under the map is zero. -/\n  eq_zero_of_map_eq_zero (f : F) {a : α} : f a = 0 → a = 0\n\n"}
{"name":"AddGroupNormClass.eq_zero_of_map_eq_zero","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : AddGroup α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : FunLike F α β\nself : AddGroupNormClass F α β\nf : F\na : α\na✝ : Eq (f a) 0\n⊢ Eq a 0","decl":"/-- `AddGroupNormClass F α` states that `F` is a type of `β`-valued norms on the additive group\n`α`.\n\nYou should extend this class when you extend `AddGroupNorm`. -/\nclass AddGroupNormClass (F : Type*) (α β : outParam Type*)\n    [AddGroup α] [OrderedAddCommMonoid β] [FunLike F α β]\n  extends AddGroupSeminormClass F α β : Prop where\n  /-- The argument is zero if its image under the map is zero. -/\n  eq_zero_of_map_eq_zero (f : F) {a : α} : f a = 0 → a = 0\n\n"}
{"name":"GroupNormClass.eq_one_of_map_eq_zero","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : Group α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : FunLike F α β\nself : GroupNormClass F α β\nf : F\na : α\na✝ : Eq (f a) 0\n⊢ Eq a 1","decl":"/-- `GroupNormClass F α` states that `F` is a type of `β`-valued norms on the group `α`.\n\nYou should extend this class when you extend `GroupNorm`. -/\n@[to_additive]\nclass GroupNormClass (F : Type*) (α β : outParam Type*)\n    [Group α] [OrderedAddCommMonoid β] [FunLike F α β]\n  extends GroupSeminormClass F α β : Prop where\n  /-- The argument is one if its image under the map is zero. -/\n  eq_one_of_map_eq_zero (f : F) {a : α} : f a = 0 → a = 1\n\n"}
{"name":"GroupNormClass.toGroupSeminormClass","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : Group α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : FunLike F α β\nself : GroupNormClass F α β\n⊢ GroupSeminormClass F α β","decl":"/-- `GroupNormClass F α` states that `F` is a type of `β`-valued norms on the group `α`.\n\nYou should extend this class when you extend `GroupNorm`. -/\n@[to_additive]\nclass GroupNormClass (F : Type*) (α β : outParam Type*)\n    [Group α] [OrderedAddCommMonoid β] [FunLike F α β]\n  extends GroupSeminormClass F α β : Prop where\n  /-- The argument is one if its image under the map is zero. -/\n  eq_one_of_map_eq_zero (f : F) {a : α} : f a = 0 → a = 1\n\n"}
{"name":"AddGroupSeminormClass.toAddLEAddHomClass","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : AddGroup α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : FunLike F α β\nself : AddGroupSeminormClass F α β\n⊢ SubadditiveHomClass F α β","decl":"attribute [to_additive] GroupSeminormClass.toMulLEAddHomClass\n\n-- See note [lower instance priority]\n"}
{"name":"AddGroupSeminormClass.toZeroHomClass","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : AddGroup α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : AddGroupSeminormClass F α β\n⊢ ZeroHomClass F α β","decl":"instance (priority := 100) AddGroupSeminormClass.toZeroHomClass [AddGroup α]\n    [OrderedAddCommMonoid β] [AddGroupSeminormClass F α β] : ZeroHomClass F α β :=\n  { ‹AddGroupSeminormClass F α β› with }\n\n"}
{"name":"map_sub_le_add","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : AddGroup α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : AddGroupSeminormClass F α β\nf : F\nx y : α\n⊢ LE.le (f (HSub.hSub x y)) (HAdd.hAdd (f x) (f y))","decl":"@[to_additive]\ntheorem map_div_le_add : f (x / y) ≤ f x + f y := by\n  rw [div_eq_mul_inv, ← map_inv_eq_map f y]\n  exact map_mul_le_add _ _ _\n\n"}
{"name":"map_div_le_add","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : Group α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : GroupSeminormClass F α β\nf : F\nx y : α\n⊢ LE.le (f (HDiv.hDiv x y)) (HAdd.hAdd (f x) (f y))","decl":"@[to_additive]\ntheorem map_div_le_add : f (x / y) ≤ f x + f y := by\n  rw [div_eq_mul_inv, ← map_inv_eq_map f y]\n  exact map_mul_le_add _ _ _\n\n"}
{"name":"map_div_rev","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : Group α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : GroupSeminormClass F α β\nf : F\nx y : α\n⊢ Eq (f (HDiv.hDiv x y)) (f (HDiv.hDiv y x))","decl":"@[to_additive]\ntheorem map_div_rev : f (x / y) = f (y / x) := by rw [← inv_div, map_inv_eq_map]\n\n"}
{"name":"map_sub_rev","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : AddGroup α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : AddGroupSeminormClass F α β\nf : F\nx y : α\n⊢ Eq (f (HSub.hSub x y)) (f (HSub.hSub y x))","decl":"@[to_additive]\ntheorem map_div_rev : f (x / y) = f (y / x) := by rw [← inv_div, map_inv_eq_map]\n\n"}
{"name":"le_map_add_map_sub'","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : AddGroup α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : AddGroupSeminormClass F α β\nf : F\nx y : α\n⊢ LE.le (f x) (HAdd.hAdd (f y) (f (HSub.hSub y x)))","decl":"@[to_additive]\ntheorem le_map_add_map_div' : f x ≤ f y + f (y / x) := by\n  simpa only [add_comm, map_div_rev, div_mul_cancel] using map_mul_le_add f (x / y) y\n\n"}
{"name":"le_map_add_map_div'","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : Group α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : GroupSeminormClass F α β\nf : F\nx y : α\n⊢ LE.le (f x) (HAdd.hAdd (f y) (f (HDiv.hDiv y x)))","decl":"@[to_additive]\ntheorem le_map_add_map_div' : f x ≤ f y + f (y / x) := by\n  simpa only [add_comm, map_div_rev, div_mul_cancel] using map_mul_le_add f (x / y) y\n\n"}
{"name":"abs_sub_map_le_div","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : Group α\ninst✝¹ : LinearOrderedAddCommGroup β\ninst✝ : GroupSeminormClass F α β\nf : F\nx y : α\n⊢ LE.le (abs (HSub.hSub (f x) (f y))) (f (HDiv.hDiv x y))","decl":"@[to_additive]\ntheorem abs_sub_map_le_div [Group α] [LinearOrderedAddCommGroup β] [GroupSeminormClass F α β]\n    (f : F) (x y : α) : |f x - f y| ≤ f (x / y) := by\n  rw [abs_sub_le_iff, sub_le_iff_le_add', sub_le_iff_le_add']\n  exact ⟨le_map_add_map_div _ _ _, le_map_add_map_div' _ _ _⟩\n\n-- See note [lower instance priority]\n"}
{"name":"abs_sub_map_le_sub","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : AddGroup α\ninst✝¹ : LinearOrderedAddCommGroup β\ninst✝ : AddGroupSeminormClass F α β\nf : F\nx y : α\n⊢ LE.le (abs (HSub.hSub (f x) (f y))) (f (HSub.hSub x y))","decl":"@[to_additive]\ntheorem abs_sub_map_le_div [Group α] [LinearOrderedAddCommGroup β] [GroupSeminormClass F α β]\n    (f : F) (x y : α) : |f x - f y| ≤ f (x / y) := by\n  rw [abs_sub_le_iff, sub_le_iff_le_add', sub_le_iff_le_add']\n  exact ⟨le_map_add_map_div _ _ _, le_map_add_map_div' _ _ _⟩\n\n-- See note [lower instance priority]\n"}
{"name":"GroupSeminormClass.toNonnegHomClass","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : Group α\ninst✝¹ : LinearOrderedAddCommMonoid β\ninst✝ : GroupSeminormClass F α β\n⊢ NonnegHomClass F α β","decl":"@[to_additive]\ninstance (priority := 100) GroupSeminormClass.toNonnegHomClass [Group α]\n    [LinearOrderedAddCommMonoid β] [GroupSeminormClass F α β] : NonnegHomClass F α β :=\n  { ‹GroupSeminormClass F α β› with\n    apply_nonneg := fun f a =>\n      (nsmul_nonneg_iff two_ne_zero).1 <| by\n        rw [two_nsmul, ← map_one_eq_zero f, ← div_self' a]\n        exact map_div_le_add _ _ _ }\n\n"}
{"name":"AddGroupSeminormClass.toNonnegHomClass","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : AddGroup α\ninst✝¹ : LinearOrderedAddCommMonoid β\ninst✝ : AddGroupSeminormClass F α β\n⊢ NonnegHomClass F α β","decl":"@[to_additive]\ninstance (priority := 100) GroupSeminormClass.toNonnegHomClass [Group α]\n    [LinearOrderedAddCommMonoid β] [GroupSeminormClass F α β] : NonnegHomClass F α β :=\n  { ‹GroupSeminormClass F α β› with\n    apply_nonneg := fun f a =>\n      (nsmul_nonneg_iff two_ne_zero).1 <| by\n        rw [two_nsmul, ← map_one_eq_zero f, ← div_self' a]\n        exact map_div_le_add _ _ _ }\n\n"}
{"name":"map_eq_zero_iff_eq_one","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : Group α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : GroupNormClass F α β\nf : F\nx : α\n⊢ Iff (Eq (f x) 0) (Eq x 1)","decl":"@[to_additive]\ntheorem map_eq_zero_iff_eq_one : f x = 0 ↔ x = 1 :=\n  ⟨eq_one_of_map_eq_zero _, by\n    rintro rfl\n    exact map_one_eq_zero _⟩\n\n"}
{"name":"map_eq_zero_iff_eq_zero","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : AddGroup α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : AddGroupNormClass F α β\nf : F\nx : α\n⊢ Iff (Eq (f x) 0) (Eq x 0)","decl":"@[to_additive]\ntheorem map_eq_zero_iff_eq_one : f x = 0 ↔ x = 1 :=\n  ⟨eq_one_of_map_eq_zero _, by\n    rintro rfl\n    exact map_one_eq_zero _⟩\n\n"}
{"name":"map_ne_zero_iff_ne_zero","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : AddGroup α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : AddGroupNormClass F α β\nf : F\nx : α\n⊢ Iff (Ne (f x) 0) (Ne x 0)","decl":"@[to_additive]\ntheorem map_ne_zero_iff_ne_one : f x ≠ 0 ↔ x ≠ 1 :=\n  (map_eq_zero_iff_eq_one _).not\n\n"}
{"name":"map_ne_zero_iff_ne_one","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : Group α\ninst✝¹ : OrderedAddCommMonoid β\ninst✝ : GroupNormClass F α β\nf : F\nx : α\n⊢ Iff (Ne (f x) 0) (Ne x 1)","decl":"@[to_additive]\ntheorem map_ne_zero_iff_ne_one : f x ≠ 0 ↔ x ≠ 1 :=\n  (map_eq_zero_iff_eq_one _).not\n\n"}
{"name":"map_pos_of_ne_one","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : Group α\ninst✝¹ : LinearOrderedAddCommMonoid β\ninst✝ : GroupNormClass F α β\nf : F\nx : α\nhx : Ne x 1\n⊢ LT.lt 0 (f x)","decl":"@[to_additive]\ntheorem map_pos_of_ne_one [Group α] [LinearOrderedAddCommMonoid β] [GroupNormClass F α β] (f : F)\n    {x : α} (hx : x ≠ 1) : 0 < f x :=\n  (apply_nonneg _ _).lt_of_ne <| ((map_ne_zero_iff_ne_one _).2 hx).symm\n\n"}
{"name":"map_pos_of_ne_zero","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : AddGroup α\ninst✝¹ : LinearOrderedAddCommMonoid β\ninst✝ : AddGroupNormClass F α β\nf : F\nx : α\nhx : Ne x 0\n⊢ LT.lt 0 (f x)","decl":"@[to_additive]\ntheorem map_pos_of_ne_one [Group α] [LinearOrderedAddCommMonoid β] [GroupNormClass F α β] (f : F)\n    {x : α} (hx : x ≠ 1) : 0 < f x :=\n  (apply_nonneg _ _).lt_of_ne <| ((map_ne_zero_iff_ne_one _).2 hx).symm\n\n"}
{"name":"RingSeminormClass.toAddGroupSeminormClass","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : NonUnitalNonAssocRing α\ninst✝¹ : OrderedSemiring β\ninst✝ : FunLike F α β\nself : RingSeminormClass F α β\n⊢ AddGroupSeminormClass F α β","decl":"/-- `RingSeminormClass F α` states that `F` is a type of `β`-valued seminorms on the ring `α`.\n\nYou should extend this class when you extend `RingSeminorm`. -/\nclass RingSeminormClass (F : Type*) (α β : outParam Type*)\n    [NonUnitalNonAssocRing α] [OrderedSemiring β] [FunLike F α β]\n  extends AddGroupSeminormClass F α β, SubmultiplicativeHomClass F α β : Prop\n\n"}
{"name":"RingSeminormClass.toSubmultiplicativeHomClass","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : NonUnitalNonAssocRing α\ninst✝¹ : OrderedSemiring β\ninst✝ : FunLike F α β\nself : RingSeminormClass F α β\n⊢ SubmultiplicativeHomClass F α β","decl":"/-- `RingSeminormClass F α` states that `F` is a type of `β`-valued seminorms on the ring `α`.\n\nYou should extend this class when you extend `RingSeminorm`. -/\nclass RingSeminormClass (F : Type*) (α β : outParam Type*)\n    [NonUnitalNonAssocRing α] [OrderedSemiring β] [FunLike F α β]\n  extends AddGroupSeminormClass F α β, SubmultiplicativeHomClass F α β : Prop\n\n"}
{"name":"RingNormClass.eq_zero_of_map_eq_zero","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : NonUnitalNonAssocRing α\ninst✝¹ : OrderedSemiring β\ninst✝ : FunLike F α β\nself : RingNormClass F α β\nf : F\na : α\na✝ : Eq (f a) 0\n⊢ Eq a 0","decl":"/-- `RingNormClass F α` states that `F` is a type of `β`-valued norms on the ring `α`.\n\nYou should extend this class when you extend `RingNorm`. -/\nclass RingNormClass (F : Type*) (α β : outParam Type*)\n    [NonUnitalNonAssocRing α] [OrderedSemiring β] [FunLike F α β]\n  extends RingSeminormClass F α β, AddGroupNormClass F α β : Prop\n\n"}
{"name":"RingNormClass.toRingSeminormClass","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : NonUnitalNonAssocRing α\ninst✝¹ : OrderedSemiring β\ninst✝ : FunLike F α β\nself : RingNormClass F α β\n⊢ RingSeminormClass F α β","decl":"/-- `RingNormClass F α` states that `F` is a type of `β`-valued norms on the ring `α`.\n\nYou should extend this class when you extend `RingNorm`. -/\nclass RingNormClass (F : Type*) (α β : outParam Type*)\n    [NonUnitalNonAssocRing α] [OrderedSemiring β] [FunLike F α β]\n  extends RingSeminormClass F α β, AddGroupNormClass F α β : Prop\n\n"}
{"name":"RingNormClass.toAddGroupNormClass","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : NonUnitalNonAssocRing α\ninst✝¹ : OrderedSemiring β\ninst✝ : FunLike F α β\nself : RingNormClass F α β\n⊢ AddGroupNormClass F α β","decl":"/-- `RingNormClass F α` states that `F` is a type of `β`-valued norms on the ring `α`.\n\nYou should extend this class when you extend `RingNorm`. -/\nclass RingNormClass (F : Type*) (α β : outParam Type*)\n    [NonUnitalNonAssocRing α] [OrderedSemiring β] [FunLike F α β]\n  extends RingSeminormClass F α β, AddGroupNormClass F α β : Prop\n\n"}
{"name":"MulRingSeminormClass.toMonoidHomClass","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : NonAssocRing α\ninst✝¹ : OrderedSemiring β\ninst✝ : FunLike F α β\nself : MulRingSeminormClass F α β\n⊢ MonoidHomClass F α β","decl":"/-- `MulRingSeminormClass F α` states that `F` is a type of `β`-valued multiplicative seminorms\non the ring `α`.\n\nYou should extend this class when you extend `MulRingSeminorm`. -/\nclass MulRingSeminormClass (F : Type*) (α β : outParam Type*)\n    [NonAssocRing α] [OrderedSemiring β] [FunLike F α β]\n  extends AddGroupSeminormClass F α β, MonoidWithZeroHomClass F α β : Prop\n\n-- Lower the priority of these instances since they require synthesizing an order structure.\n"}
{"name":"MulRingSeminormClass.toMonoidWithZeroHomClass","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : NonAssocRing α\ninst✝¹ : OrderedSemiring β\ninst✝ : FunLike F α β\nself : MulRingSeminormClass F α β\n⊢ MonoidWithZeroHomClass F α β","decl":"/-- `MulRingSeminormClass F α` states that `F` is a type of `β`-valued multiplicative seminorms\non the ring `α`.\n\nYou should extend this class when you extend `MulRingSeminorm`. -/\nclass MulRingSeminormClass (F : Type*) (α β : outParam Type*)\n    [NonAssocRing α] [OrderedSemiring β] [FunLike F α β]\n  extends AddGroupSeminormClass F α β, MonoidWithZeroHomClass F α β : Prop\n\n-- Lower the priority of these instances since they require synthesizing an order structure.\n"}
{"name":"MulRingSeminormClass.toAddGroupSeminormClass","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : NonAssocRing α\ninst✝¹ : OrderedSemiring β\ninst✝ : FunLike F α β\nself : MulRingSeminormClass F α β\n⊢ AddGroupSeminormClass F α β","decl":"/-- `MulRingSeminormClass F α` states that `F` is a type of `β`-valued multiplicative seminorms\non the ring `α`.\n\nYou should extend this class when you extend `MulRingSeminorm`. -/\nclass MulRingSeminormClass (F : Type*) (α β : outParam Type*)\n    [NonAssocRing α] [OrderedSemiring β] [FunLike F α β]\n  extends AddGroupSeminormClass F α β, MonoidWithZeroHomClass F α β : Prop\n\n-- Lower the priority of these instances since they require synthesizing an order structure.\n"}
{"name":"MulRingNormClass.toMulRingSeminormClass","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : NonAssocRing α\ninst✝¹ : OrderedSemiring β\ninst✝ : FunLike F α β\nself : MulRingNormClass F α β\n⊢ MulRingSeminormClass F α β","decl":"/-- `MulRingNormClass F α` states that `F` is a type of `β`-valued multiplicative norms on the\nring `α`.\n\nYou should extend this class when you extend `MulRingNorm`. -/\nclass MulRingNormClass (F : Type*) (α β : outParam Type*)\n    [NonAssocRing α] [OrderedSemiring β] [FunLike F α β]\n  extends MulRingSeminormClass F α β, AddGroupNormClass F α β : Prop\n\n-- See note [out-param inheritance]\n-- See note [lower instance priority]\n"}
{"name":"MulRingNormClass.toAddGroupNormClass","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : NonAssocRing α\ninst✝¹ : OrderedSemiring β\ninst✝ : FunLike F α β\nself : MulRingNormClass F α β\n⊢ AddGroupNormClass F α β","decl":"/-- `MulRingNormClass F α` states that `F` is a type of `β`-valued multiplicative norms on the\nring `α`.\n\nYou should extend this class when you extend `MulRingNorm`. -/\nclass MulRingNormClass (F : Type*) (α β : outParam Type*)\n    [NonAssocRing α] [OrderedSemiring β] [FunLike F α β]\n  extends MulRingSeminormClass F α β, AddGroupNormClass F α β : Prop\n\n-- See note [out-param inheritance]\n-- See note [lower instance priority]\n"}
{"name":"MulRingNormClass.eq_zero_of_map_eq_zero","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_7\nα : outParam (Type u_8)\nβ : outParam (Type u_9)\ninst✝² : NonAssocRing α\ninst✝¹ : OrderedSemiring β\ninst✝ : FunLike F α β\nself : MulRingNormClass F α β\nf : F\na : α\na✝ : Eq (f a) 0\n⊢ Eq a 0","decl":"/-- `MulRingNormClass F α` states that `F` is a type of `β`-valued multiplicative norms on the\nring `α`.\n\nYou should extend this class when you extend `MulRingNorm`. -/\nclass MulRingNormClass (F : Type*) (α β : outParam Type*)\n    [NonAssocRing α] [OrderedSemiring β] [FunLike F α β]\n  extends MulRingSeminormClass F α β, AddGroupNormClass F α β : Prop\n\n-- See note [out-param inheritance]\n-- See note [lower instance priority]\n"}
{"name":"RingSeminormClass.toNonnegHomClass","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : NonUnitalNonAssocRing α\ninst✝¹ : LinearOrderedSemiring β\ninst✝ : RingSeminormClass F α β\n⊢ NonnegHomClass F α β","decl":"instance (priority := 100) RingSeminormClass.toNonnegHomClass [NonUnitalNonAssocRing α]\n    [LinearOrderedSemiring β] [RingSeminormClass F α β] : NonnegHomClass F α β :=\n  AddGroupSeminormClass.toNonnegHomClass\n\n-- See note [lower instance priority]\n"}
{"name":"MulRingSeminormClass.toRingSeminormClass","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : NonAssocRing α\ninst✝¹ : OrderedSemiring β\ninst✝ : MulRingSeminormClass F α β\n⊢ RingSeminormClass F α β","decl":"instance (priority := 100) MulRingSeminormClass.toRingSeminormClass [NonAssocRing α]\n    [OrderedSemiring β] [MulRingSeminormClass F α β] : RingSeminormClass F α β :=\n  { ‹MulRingSeminormClass F α β› with map_mul_le_mul := fun _ _ _ => (map_mul _ _ _).le }\n\n-- See note [lower instance priority]\n"}
{"name":"MulRingNormClass.toRingNormClass","module":"Mathlib.Algebra.Order.Hom.Basic","initialProofState":"F : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : FunLike F α β\ninst✝² : NonAssocRing α\ninst✝¹ : OrderedSemiring β\ninst✝ : MulRingNormClass F α β\n⊢ RingNormClass F α β","decl":"instance (priority := 100) MulRingNormClass.toRingNormClass [NonAssocRing α]\n    [OrderedSemiring β] [MulRingNormClass F α β] : RingNormClass F α β :=\n  { ‹MulRingNormClass F α β›, MulRingSeminormClass.toRingSeminormClass with }\n"}
