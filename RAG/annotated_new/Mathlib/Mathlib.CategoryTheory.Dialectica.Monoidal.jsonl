{"name":"CategoryTheory.Dial.tensorObj_src","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n‚ä¢ Eq (X.tensorObj Y).src (CategoryTheory.Limits.prod X.src Y.src)","decl":"/-- The object `X ‚äó Y` in the `Dial C` category just tuples the left and right components. -/\n@[simps] def tensorObj (X Y : Dial C) : Dial C where\n  src := X.src ‚®Ø Y.src\n  tgt := X.tgt ‚®Ø Y.tgt\n  rel :=\n    (Subobject.pullback (prod.map œÄ‚ÇÅ œÄ‚ÇÅ)).obj X.rel ‚äì\n    (Subobject.pullback (prod.map œÄ‚ÇÇ œÄ‚ÇÇ)).obj Y.rel\n\n"}
{"name":"CategoryTheory.Dial.tensorObj_rel","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n‚ä¢ Eq (X.tensorObj Y).rel (Min.min ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.fst)).obj X.rel) ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd)).obj Y.rel))","decl":"/-- The object `X ‚äó Y` in the `Dial C` category just tuples the left and right components. -/\n@[simps] def tensorObj (X Y : Dial C) : Dial C where\n  src := X.src ‚®Ø Y.src\n  tgt := X.tgt ‚®Ø Y.tgt\n  rel :=\n    (Subobject.pullback (prod.map œÄ‚ÇÅ œÄ‚ÇÅ)).obj X.rel ‚äì\n    (Subobject.pullback (prod.map œÄ‚ÇÇ œÄ‚ÇÇ)).obj Y.rel\n\n"}
{"name":"CategoryTheory.Dial.tensorObj_tgt","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n‚ä¢ Eq (X.tensorObj Y).tgt (CategoryTheory.Limits.prod X.tgt Y.tgt)","decl":"/-- The object `X ‚äó Y` in the `Dial C` category just tuples the left and right components. -/\n@[simps] def tensorObj (X Y : Dial C) : Dial C where\n  src := X.src ‚®Ø Y.src\n  tgt := X.tgt ‚®Ø Y.tgt\n  rel :=\n    (Subobject.pullback (prod.map œÄ‚ÇÅ œÄ‚ÇÅ)).obj X.rel ‚äì\n    (Subobject.pullback (prod.map œÄ‚ÇÇ œÄ‚ÇÇ)).obj Y.rel\n\n"}
{"name":"CategoryTheory.Dial.tensorHom_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : CategoryTheory.Dial C\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom Y‚ÇÅ Y‚ÇÇ\n‚ä¢ Eq (CategoryTheory.Dial.tensorHom f g).f (CategoryTheory.Limits.prod.map f.f g.f)","decl":"/-- The functorial action of `X ‚äó Y` in `Dial C`. -/\n@[simps] def tensorHom {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : Dial C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) (g : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) :\n    tensorObj X‚ÇÅ Y‚ÇÅ ‚ü∂ tensorObj X‚ÇÇ Y‚ÇÇ where\n  f := prod.map f.f g.f\n  F := œÄ(prod.map œÄ‚ÇÅ œÄ‚ÇÅ ‚â´ f.F, prod.map œÄ‚ÇÇ œÄ‚ÇÇ ‚â´ g.F)\n  le := by\n    simp only [tensorObj, Subobject.inf_pullback]\n    apply inf_le_inf <;> rw [‚Üê Subobject.pullback_comp, ‚Üê Subobject.pullback_comp]\n    ¬∑ have := (Subobject.pullback (prod.map œÄ‚ÇÅ œÄ‚ÇÅ :\n        (X‚ÇÅ.src ‚®Ø Y‚ÇÅ.src) ‚®Ø X‚ÇÇ.tgt ‚®Ø Y‚ÇÇ.tgt ‚ü∂ _)).monotone (Hom.le f)\n      rw [‚Üê Subobject.pullback_comp, ‚Üê Subobject.pullback_comp] at this\n      convert this using 3 <;> simp\n    ¬∑ have := (Subobject.pullback (prod.map œÄ‚ÇÇ œÄ‚ÇÇ :\n        (X‚ÇÅ.src ‚®Ø Y‚ÇÅ.src) ‚®Ø X‚ÇÇ.tgt ‚®Ø Y‚ÇÇ.tgt ‚ü∂ _)).monotone (Hom.le g)\n      rw [‚Üê Subobject.pullback_comp, ‚Üê Subobject.pullback_comp] at this\n      convert this using 3 <;> simp\n\n"}
{"name":"CategoryTheory.Dial.tensorHom_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : CategoryTheory.Dial C\nf : Quiver.Hom X‚ÇÅ X‚ÇÇ\ng : Quiver.Hom Y‚ÇÅ Y‚ÇÇ\n‚ä¢ Eq (CategoryTheory.Dial.tensorHom f g).F (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.fst) f.F) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd) g.F))","decl":"/-- The functorial action of `X ‚äó Y` in `Dial C`. -/\n@[simps] def tensorHom {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ : Dial C} (f : X‚ÇÅ ‚ü∂ X‚ÇÇ) (g : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) :\n    tensorObj X‚ÇÅ Y‚ÇÅ ‚ü∂ tensorObj X‚ÇÇ Y‚ÇÇ where\n  f := prod.map f.f g.f\n  F := œÄ(prod.map œÄ‚ÇÅ œÄ‚ÇÅ ‚â´ f.F, prod.map œÄ‚ÇÇ œÄ‚ÇÇ ‚â´ g.F)\n  le := by\n    simp only [tensorObj, Subobject.inf_pullback]\n    apply inf_le_inf <;> rw [‚Üê Subobject.pullback_comp, ‚Üê Subobject.pullback_comp]\n    ¬∑ have := (Subobject.pullback (prod.map œÄ‚ÇÅ œÄ‚ÇÅ :\n        (X‚ÇÅ.src ‚®Ø Y‚ÇÅ.src) ‚®Ø X‚ÇÇ.tgt ‚®Ø Y‚ÇÇ.tgt ‚ü∂ _)).monotone (Hom.le f)\n      rw [‚Üê Subobject.pullback_comp, ‚Üê Subobject.pullback_comp] at this\n      convert this using 3 <;> simp\n    ¬∑ have := (Subobject.pullback (prod.map œÄ‚ÇÇ œÄ‚ÇÇ :\n        (X‚ÇÅ.src ‚®Ø Y‚ÇÅ.src) ‚®Ø X‚ÇÇ.tgt ‚®Ø Y‚ÇÇ.tgt ‚ü∂ _)).monotone (Hom.le g)\n      rw [‚Üê Subobject.pullback_comp, ‚Üê Subobject.pullback_comp] at this\n      convert this using 3 <;> simp\n\n"}
{"name":"CategoryTheory.Dial.tensorUnit_tgt","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasFiniteProducts C\n‚ä¢ Eq CategoryTheory.Dial.tensorUnit.tgt (CategoryTheory.Limits.terminal C)","decl":"/-- The unit for the tensor `X ‚äó Y` in `Dial C`. -/\n@[simps] def tensorUnit : Dial C := { src := ‚ä§_ _, tgt := ‚ä§_ _, rel := ‚ä§ }\n\n"}
{"name":"CategoryTheory.Dial.tensorUnit_src","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasFiniteProducts C\n‚ä¢ Eq CategoryTheory.Dial.tensorUnit.src (CategoryTheory.Limits.terminal C)","decl":"/-- The unit for the tensor `X ‚äó Y` in `Dial C`. -/\n@[simps] def tensorUnit : Dial C := { src := ‚ä§_ _, tgt := ‚ä§_ _, rel := ‚ä§ }\n\n"}
{"name":"CategoryTheory.Dial.tensorUnit_rel","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasFiniteProducts C\n‚ä¢ Eq CategoryTheory.Dial.tensorUnit.rel Top.top","decl":"/-- The unit for the tensor `X ‚äó Y` in `Dial C`. -/\n@[simps] def tensorUnit : Dial C := { src := ‚ä§_ _, tgt := ‚ä§_ _, rel := ‚ä§ }\n\n"}
{"name":"CategoryTheory.Dial.leftUnitor_hom_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n‚ä¢ Eq X.leftUnitor.hom.F (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.terminal.from (CategoryTheory.Limits.prod (CategoryTheory.Limits.prod (CategoryTheory.Limits.terminal C) X.src) X.tgt)) CategoryTheory.Limits.prod.snd)","decl":"/-- Left unit cancellation `1 ‚äó X ‚âÖ X` in `Dial C`. -/\n@[simps!] def leftUnitor (X : Dial C) : tensorObj tensorUnit X ‚âÖ X :=\n  isoMk (Limits.prod.leftUnitor _) (Limits.prod.leftUnitor _) <| by simp [Subobject.pullback_top]\n\n"}
{"name":"CategoryTheory.Dial.leftUnitor_inv_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n‚ä¢ Eq X.leftUnitor.inv.F (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd)","decl":"/-- Left unit cancellation `1 ‚äó X ‚âÖ X` in `Dial C`. -/\n@[simps!] def leftUnitor (X : Dial C) : tensorObj tensorUnit X ‚âÖ X :=\n  isoMk (Limits.prod.leftUnitor _) (Limits.prod.leftUnitor _) <| by simp [Subobject.pullback_top]\n\n"}
{"name":"CategoryTheory.Dial.leftUnitor_inv_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n‚ä¢ Eq X.leftUnitor.inv.f (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.terminal.from X.src) (CategoryTheory.CategoryStruct.id X.src))","decl":"/-- Left unit cancellation `1 ‚äó X ‚âÖ X` in `Dial C`. -/\n@[simps!] def leftUnitor (X : Dial C) : tensorObj tensorUnit X ‚âÖ X :=\n  isoMk (Limits.prod.leftUnitor _) (Limits.prod.leftUnitor _) <| by simp [Subobject.pullback_top]\n\n"}
{"name":"CategoryTheory.Dial.leftUnitor_hom_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n‚ä¢ Eq X.leftUnitor.hom.f CategoryTheory.Limits.prod.snd","decl":"/-- Left unit cancellation `1 ‚äó X ‚âÖ X` in `Dial C`. -/\n@[simps!] def leftUnitor (X : Dial C) : tensorObj tensorUnit X ‚âÖ X :=\n  isoMk (Limits.prod.leftUnitor _) (Limits.prod.leftUnitor _) <| by simp [Subobject.pullback_top]\n\n"}
{"name":"CategoryTheory.Dial.rightUnitor_hom_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n‚ä¢ Eq X.rightUnitor.hom.F (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.snd (CategoryTheory.Limits.terminal.from (CategoryTheory.Limits.prod (CategoryTheory.Limits.prod X.src (CategoryTheory.Limits.terminal C)) X.tgt)))","decl":"/-- Right unit cancellation `X ‚äó 1 ‚âÖ X` in `Dial C`. -/\n@[simps!] def rightUnitor (X : Dial C) : tensorObj X tensorUnit ‚âÖ X :=\n  isoMk (Limits.prod.rightUnitor _) (Limits.prod.rightUnitor _) <| by simp [Subobject.pullback_top]\n\n"}
{"name":"CategoryTheory.Dial.rightUnitor_inv_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n‚ä¢ Eq X.rightUnitor.inv.F (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst)","decl":"/-- Right unit cancellation `X ‚äó 1 ‚âÖ X` in `Dial C`. -/\n@[simps!] def rightUnitor (X : Dial C) : tensorObj X tensorUnit ‚âÖ X :=\n  isoMk (Limits.prod.rightUnitor _) (Limits.prod.rightUnitor _) <| by simp [Subobject.pullback_top]\n\n"}
{"name":"CategoryTheory.Dial.rightUnitor_hom_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n‚ä¢ Eq X.rightUnitor.hom.f CategoryTheory.Limits.prod.fst","decl":"/-- Right unit cancellation `X ‚äó 1 ‚âÖ X` in `Dial C`. -/\n@[simps!] def rightUnitor (X : Dial C) : tensorObj X tensorUnit ‚âÖ X :=\n  isoMk (Limits.prod.rightUnitor _) (Limits.prod.rightUnitor _) <| by simp [Subobject.pullback_top]\n\n"}
{"name":"CategoryTheory.Dial.rightUnitor_inv_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n‚ä¢ Eq X.rightUnitor.inv.f (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id X.src) (CategoryTheory.Limits.terminal.from X.src))","decl":"/-- Right unit cancellation `X ‚äó 1 ‚âÖ X` in `Dial C`. -/\n@[simps!] def rightUnitor (X : Dial C) : tensorObj X tensorUnit ‚âÖ X :=\n  isoMk (Limits.prod.rightUnitor _) (Limits.prod.rightUnitor _) <| by simp [Subobject.pullback_top]\n\n"}
{"name":"CategoryTheory.Dial.associator_inv_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\n‚ä¢ Eq (X.associator Y Z).inv.F (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.fst)) (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd)))","decl":"/-- The associator for tensor, `(X ‚äó Y) ‚äó Z ‚âÖ X ‚äó (Y ‚äó Z)` in `Dial C`. -/\n@[simps!]\ndef associator (X Y Z : Dial C) : tensorObj (tensorObj X Y) Z ‚âÖ tensorObj X (tensorObj Y Z) :=\n  isoMk (prod.associator ..) (prod.associator ..) <| by\n    simp [Subobject.inf_pullback, ‚Üê Subobject.pullback_comp, inf_assoc]\n\n"}
{"name":"CategoryTheory.Dial.associator_hom_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\n‚ä¢ Eq (X.associator Y Z).hom.F (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst))) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd)))","decl":"/-- The associator for tensor, `(X ‚äó Y) ‚äó Z ‚âÖ X ‚äó (Y ‚äó Z)` in `Dial C`. -/\n@[simps!]\ndef associator (X Y Z : Dial C) : tensorObj (tensorObj X Y) Z ‚âÖ tensorObj X (tensorObj Y Z) :=\n  isoMk (prod.associator ..) (prod.associator ..) <| by\n    simp [Subobject.inf_pullback, ‚Üê Subobject.pullback_comp, inf_assoc]\n\n"}
{"name":"CategoryTheory.Dial.associator_inv_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\n‚ä¢ Eq (X.associator Y Z).inv.f (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd))","decl":"/-- The associator for tensor, `(X ‚äó Y) ‚äó Z ‚âÖ X ‚äó (Y ‚äó Z)` in `Dial C`. -/\n@[simps!]\ndef associator (X Y Z : Dial C) : tensorObj (tensorObj X Y) Z ‚âÖ tensorObj X (tensorObj Y Z) :=\n  isoMk (prod.associator ..) (prod.associator ..) <| by\n    simp [Subobject.inf_pullback, ‚Üê Subobject.pullback_comp, inf_assoc]\n\n"}
{"name":"CategoryTheory.Dial.associator_hom_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\n‚ä¢ Eq (X.associator Y Z).hom.f (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.fst) (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd) CategoryTheory.Limits.prod.snd))","decl":"/-- The associator for tensor, `(X ‚äó Y) ‚äó Z ‚âÖ X ‚äó (Y ‚äó Z)` in `Dial C`. -/\n@[simps!]\ndef associator (X Y Z : Dial C) : tensorObj (tensorObj X Y) Z ‚âÖ tensorObj X (tensorObj Y Z) :=\n  isoMk (prod.associator ..) (prod.associator ..) <| by\n    simp [Subobject.inf_pullback, ‚Üê Subobject.pullback_comp, inf_assoc]\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_tensorUnit_src","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\n‚ä¢ Eq CategoryTheory.MonoidalCategoryStruct.tensorUnit.src (CategoryTheory.Limits.terminal C)","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_tensorUnit_tgt","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\n‚ä¢ Eq CategoryTheory.MonoidalCategoryStruct.tensorUnit.tgt (CategoryTheory.Limits.terminal C)","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_tensorObj_tgt","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).tgt (CategoryTheory.Limits.prod X.tgt Y.tgt)","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_tensorObj_src","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).src (CategoryTheory.Limits.prod X.src Y.src)","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_associator_hom_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom.f (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.fst) (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd) CategoryTheory.Limits.prod.snd))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_associator_inv_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv.F (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.fst)) (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd)))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_whiskerRight_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX‚ÇÅ‚úù X‚ÇÇ‚úù : CategoryTheory.Dial C\nf : Quiver.Hom X‚ÇÅ‚úù X‚ÇÇ‚úù\nY : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y).f (CategoryTheory.Limits.prod.map f.f (CategoryTheory.CategoryStruct.id Y.src))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_tensorObj_rel","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).rel (Min.min ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.fst)).obj X.rel) ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd)).obj Y.rel))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_rightUnitor_inv_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv.f (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id X.src) (CategoryTheory.Limits.terminal.from X.src))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_associator_inv_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv.f (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_associator_hom_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom.F (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst))) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd)))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_rightUnitor_hom_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom.f CategoryTheory.Limits.prod.fst","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_whiskerLeft_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX x‚úù¬π x‚úù : CategoryTheory.Dial C\nf : Quiver.Hom x‚úù¬π x‚úù\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f).f (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id X.src) f.f)","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_whiskerLeft_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX x‚úù¬π x‚úù : CategoryTheory.Dial C\nf : Quiver.Hom x‚úù¬π x‚úù\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f).F (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd) f.F))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_tensorHom_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX‚ÇÅ‚úù Y‚ÇÅ‚úù X‚ÇÇ‚úù Y‚ÇÇ‚úù : CategoryTheory.Dial C\nf : Quiver.Hom X‚ÇÅ‚úù Y‚ÇÅ‚úù\ng : Quiver.Hom X‚ÇÇ‚úù Y‚ÇÇ‚úù\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f g).f (CategoryTheory.Limits.prod.map f.f g.f)","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_leftUnitor_inv_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv.F (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd)","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_leftUnitor_inv_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv.f (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.terminal.from X.src) (CategoryTheory.CategoryStruct.id X.src))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_leftUnitor_hom_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom.F (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.terminal.from (CategoryTheory.Limits.prod (CategoryTheory.Limits.prod (CategoryTheory.Limits.terminal C) X.src) X.tgt)) CategoryTheory.Limits.prod.snd)","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_leftUnitor_hom_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom.f CategoryTheory.Limits.prod.snd","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_whiskerRight_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX‚ÇÅ‚úù X‚ÇÇ‚úù : CategoryTheory.Dial C\nf : Quiver.Hom X‚ÇÅ‚úù X‚ÇÇ‚úù\nY : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y).F (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.fst) f.F) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_rightUnitor_inv_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv.F (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst)","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_tensorHom_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX‚ÇÅ‚úù Y‚ÇÅ‚úù X‚ÇÇ‚úù Y‚ÇÇ‚úù : CategoryTheory.Dial C\nf : Quiver.Hom X‚ÇÅ‚úù Y‚ÇÅ‚úù\ng : Quiver.Hom X‚ÇÇ‚úù Y‚ÇÇ‚úù\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f g).F (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.fst) f.F) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd) g.F))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_rightUnitor_hom_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom.F (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.snd (CategoryTheory.Limits.terminal.from (CategoryTheory.Limits.prod (CategoryTheory.Limits.prod X.src (CategoryTheory.Limits.terminal C)) X.tgt)))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_tensorUnit_rel","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\n‚ä¢ Eq CategoryTheory.MonoidalCategoryStruct.tensorUnit.rel Top.top","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (ùüô X) f\n  whiskerRight f Y := tensorHom f (ùüô Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.tensor_id","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX‚ÇÅ X‚ÇÇ : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id X‚ÇÅ) (CategoryTheory.CategoryStruct.id X‚ÇÇ)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X‚ÇÅ X‚ÇÇ))","decl":"theorem tensor_id (X‚ÇÅ X‚ÇÇ : Dial C) : (ùüô X‚ÇÅ ‚äó ùüô X‚ÇÇ : _ ‚ü∂ _) = ùüô (X‚ÇÅ ‚äó X‚ÇÇ : Dial C) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Dial.tensor_comp","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX‚ÇÅ Y‚ÇÅ Z‚ÇÅ X‚ÇÇ Y‚ÇÇ Z‚ÇÇ : CategoryTheory.Dial C\nf‚ÇÅ : Quiver.Hom X‚ÇÅ Y‚ÇÅ\nf‚ÇÇ : Quiver.Hom X‚ÇÇ Y‚ÇÇ\ng‚ÇÅ : Quiver.Hom Y‚ÇÅ Z‚ÇÅ\ng‚ÇÇ : Quiver.Hom Y‚ÇÇ Z‚ÇÇ\n‚ä¢ Eq (CategoryTheory.Dial.tensorHom (CategoryTheory.CategoryStruct.comp f‚ÇÅ g‚ÇÅ) (CategoryTheory.CategoryStruct.comp f‚ÇÇ g‚ÇÇ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Dial.tensorHom f‚ÇÅ f‚ÇÇ) (CategoryTheory.Dial.tensorHom g‚ÇÅ g‚ÇÇ))","decl":"theorem tensor_comp {X‚ÇÅ Y‚ÇÅ Z‚ÇÅ X‚ÇÇ Y‚ÇÇ Z‚ÇÇ : Dial C}\n    (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (g‚ÇÅ : Y‚ÇÅ ‚ü∂ Z‚ÇÅ) (g‚ÇÇ : Y‚ÇÇ ‚ü∂ Z‚ÇÇ) :\n    tensorHom (f‚ÇÅ ‚â´ g‚ÇÅ) (f‚ÇÇ ‚â´ g‚ÇÇ) = tensorHom f‚ÇÅ f‚ÇÇ ‚â´ tensorHom g‚ÇÅ g‚ÇÇ := by\n  ext <;> simp; ext <;> simp <;> (rw [‚Üê Category.assoc]; congr 1; simp)\n\n"}
{"name":"CategoryTheory.Dial.associator_naturality","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : CategoryTheory.Dial C\nf‚ÇÅ : Quiver.Hom X‚ÇÅ Y‚ÇÅ\nf‚ÇÇ : Quiver.Hom X‚ÇÇ Y‚ÇÇ\nf‚ÇÉ : Quiver.Hom X‚ÇÉ Y‚ÇÉ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Dial.tensorHom (CategoryTheory.Dial.tensorHom f‚ÇÅ f‚ÇÇ) f‚ÇÉ) (Y‚ÇÅ.associator Y‚ÇÇ Y‚ÇÉ).hom) (CategoryTheory.CategoryStruct.comp (X‚ÇÅ.associator X‚ÇÇ X‚ÇÉ).hom (CategoryTheory.Dial.tensorHom f‚ÇÅ (CategoryTheory.Dial.tensorHom f‚ÇÇ f‚ÇÉ)))","decl":"theorem associator_naturality {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : Dial C}\n    (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (f‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ) :\n    tensorHom (tensorHom f‚ÇÅ f‚ÇÇ) f‚ÇÉ ‚â´ (associator Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ).hom =\n    (associator X‚ÇÅ X‚ÇÇ X‚ÇÉ).hom ‚â´ tensorHom f‚ÇÅ (tensorHom f‚ÇÇ f‚ÇÉ) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Dial.leftUnitor_naturality","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit) f) (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom f)","decl":"theorem leftUnitor_naturality {X Y : Dial C} (f : X ‚ü∂ Y) :\n    (ùüô (ùüô_ (Dial C)) ‚äó f) ‚â´ (Œª_ Y).hom = (Œª_ X).hom ‚â´ f := by\n  ext <;> simp; ext; simp; congr 1; ext <;> simp\n\n"}
{"name":"CategoryTheory.Dial.rightUnitor_naturality","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)) (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom f)","decl":"theorem rightUnitor_naturality {X Y : Dial C} (f : X ‚ü∂ Y) :\n    (f ‚äó ùüô (ùüô_ (Dial C))) ‚â´ (œÅ_ Y).hom = (œÅ_ X).hom ‚â´ f := by\n  ext <;> simp; ext; simp; congr 1; ext <;> simp\n\n"}
{"name":"CategoryTheory.Dial.pentagon","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nW X Y Z : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Dial.tensorHom (W.associator X Y).hom (CategoryTheory.CategoryStruct.id Z)) (CategoryTheory.CategoryStruct.comp (W.associator (X.tensorObj Y) Z).hom (CategoryTheory.Dial.tensorHom (CategoryTheory.CategoryStruct.id W) (X.associator Y Z).hom))) (CategoryTheory.CategoryStruct.comp ((W.tensorObj X).associator Y Z).hom (W.associator X (Y.tensorObj Z)).hom)","decl":"theorem pentagon (W X Y Z : Dial C) :\n    (tensorHom (associator W X Y).hom (ùüô Z)) ‚â´ (associator W (tensorObj X Y) Z).hom ‚â´\n      (tensorHom (ùüô W) (associator X Y Z).hom) =\n    (associator (tensorObj W X) Y Z).hom ‚â´ (associator W X (tensorObj Y Z)).hom := by\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.Dial.triangle","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.associator CategoryTheory.MonoidalCategoryStruct.tensorUnit Y).hom (CategoryTheory.Dial.tensorHom (CategoryTheory.CategoryStruct.id X) Y.leftUnitor.hom)) (CategoryTheory.Dial.tensorHom X.rightUnitor.hom (CategoryTheory.CategoryStruct.id Y))","decl":"theorem triangle (X Y : Dial C) :\n    (associator X (ùüô_ (Dial C)) Y).hom ‚â´ tensorHom (ùüô X) (leftUnitor Y).hom =\n    tensorHom (rightUnitor X).hom (ùüô Y) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Dial.braiding_hom_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n‚ä¢ Eq (X.braiding Y).hom.F (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst))","decl":"/-- The braiding isomorphism `X ‚äó Y ‚âÖ Y ‚äó X` in `Dial C`. -/\n@[simps!] def braiding (X Y : Dial C) : tensorObj X Y ‚âÖ tensorObj Y X :=\n  isoMk (prod.braiding ..) (prod.braiding ..) <| by\n    simp [Subobject.inf_pullback, ‚Üê Subobject.pullback_comp, inf_comm]\n\n"}
{"name":"CategoryTheory.Dial.braiding_inv_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n‚ä¢ Eq (X.braiding Y).inv.f (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst)","decl":"/-- The braiding isomorphism `X ‚äó Y ‚âÖ Y ‚äó X` in `Dial C`. -/\n@[simps!] def braiding (X Y : Dial C) : tensorObj X Y ‚âÖ tensorObj Y X :=\n  isoMk (prod.braiding ..) (prod.braiding ..) <| by\n    simp [Subobject.inf_pullback, ‚Üê Subobject.pullback_comp, inf_comm]\n\n"}
{"name":"CategoryTheory.Dial.braiding_hom_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n‚ä¢ Eq (X.braiding Y).hom.f (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst)","decl":"/-- The braiding isomorphism `X ‚äó Y ‚âÖ Y ‚äó X` in `Dial C`. -/\n@[simps!] def braiding (X Y : Dial C) : tensorObj X Y ‚âÖ tensorObj Y X :=\n  isoMk (prod.braiding ..) (prod.braiding ..) <| by\n    simp [Subobject.inf_pullback, ‚Üê Subobject.pullback_comp, inf_comm]\n\n"}
{"name":"CategoryTheory.Dial.braiding_inv_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n‚ä¢ Eq (X.braiding Y).inv.F (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst))","decl":"/-- The braiding isomorphism `X ‚äó Y ‚âÖ Y ‚äó X` in `Dial C`. -/\n@[simps!] def braiding (X Y : Dial C) : tensorObj X Y ‚âÖ tensorObj Y X :=\n  isoMk (prod.braiding ..) (prod.braiding ..) <| by\n    simp [Subobject.inf_pullback, ‚Üê Subobject.pullback_comp, inf_comm]\n\n"}
{"name":"CategoryTheory.Dial.symmetry","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.braiding Y).hom (Y.braiding X).hom) (CategoryTheory.CategoryStruct.id (X.tensorObj Y))","decl":"theorem symmetry (X Y : Dial C) :\n    (braiding X Y).hom ‚â´ (braiding Y X).hom = ùüô (tensorObj X Y) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Dial.braiding_naturality_right","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\nf : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Dial.tensorHom (CategoryTheory.CategoryStruct.id X) f) (X.braiding Z).hom) (CategoryTheory.CategoryStruct.comp (X.braiding Y).hom (CategoryTheory.Dial.tensorHom f (CategoryTheory.CategoryStruct.id X)))","decl":"theorem braiding_naturality_right (X : Dial C) {Y Z : Dial C} (f : Y ‚ü∂ Z) :\n    tensorHom (ùüô X) f ‚â´ (braiding X Z).hom = (braiding X Y).hom ‚â´ tensorHom f (ùüô X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Dial.braiding_naturality_left","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\nf : Quiver.Hom X Y\nZ : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Dial.tensorHom f (CategoryTheory.CategoryStruct.id Z)) (Y.braiding Z).hom) (CategoryTheory.CategoryStruct.comp (X.braiding Z).hom (CategoryTheory.Dial.tensorHom (CategoryTheory.CategoryStruct.id Z) f))","decl":"theorem braiding_naturality_left {X Y : Dial C} (f : X ‚ü∂ Y) (Z : Dial C) :\n    tensorHom f (ùüô Z) ‚â´ (braiding Y Z).hom = (braiding X Z).hom ‚â´ tensorHom (ùüô Z) f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Dial.hexagon_forward","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.associator Y Z).hom (CategoryTheory.CategoryStruct.comp (X.braiding (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).hom (Y.associator Z X).hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Dial.tensorHom (X.braiding Y).hom (CategoryTheory.CategoryStruct.id Z)) (CategoryTheory.CategoryStruct.comp (Y.associator X Z).hom (CategoryTheory.Dial.tensorHom (CategoryTheory.CategoryStruct.id Y) (X.braiding Z).hom)))","decl":"theorem hexagon_forward (X Y Z : Dial C) :\n    (associator X Y Z).hom ‚â´ (braiding X (Y ‚äó Z)).hom ‚â´ (associator Y Z X).hom =\n      tensorHom (braiding X Y).hom (ùüô Z) ‚â´ (associator Y X Z).hom ‚â´\n      tensorHom (ùüô Y) (braiding X Z).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Dial.hexagon_reverse","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasFiniteProducts C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.associator Y Z).inv (CategoryTheory.CategoryStruct.comp ((CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).braiding Z).hom (Z.associator X Y).inv)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Dial.tensorHom (CategoryTheory.CategoryStruct.id X) (Y.braiding Z).hom) (CategoryTheory.CategoryStruct.comp (X.associator Z Y).inv (CategoryTheory.Dial.tensorHom (X.braiding Z).hom (CategoryTheory.CategoryStruct.id Y))))","decl":"theorem hexagon_reverse (X Y Z : Dial C) :\n    (associator X Y Z).inv ‚â´ (braiding (X ‚äó Y) Z).hom ‚â´ (associator Z X Y).inv =\n      tensorHom (ùüô X) (braiding Y Z).hom ‚â´ (associator X Z Y).inv ‚â´\n      tensorHom (braiding X Z).hom (ùüô Y) := by aesop_cat\n\n"}
