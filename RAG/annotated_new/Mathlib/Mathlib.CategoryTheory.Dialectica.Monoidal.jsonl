{"name":"CategoryTheory.Dial.tensorObj_src","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n⊢ Eq (X.tensorObj Y).src (CategoryTheory.Limits.prod X.src Y.src)","decl":"/-- The object `X ⊗ Y` in the `Dial C` category just tuples the left and right components. -/\n@[simps] def tensorObj (X Y : Dial C) : Dial C where\n  src := X.src ⨯ Y.src\n  tgt := X.tgt ⨯ Y.tgt\n  rel :=\n    (Subobject.pullback (prod.map π₁ π₁)).obj X.rel ⊓\n    (Subobject.pullback (prod.map π₂ π₂)).obj Y.rel\n\n"}
{"name":"CategoryTheory.Dial.tensorObj_rel","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n⊢ Eq (X.tensorObj Y).rel (Min.min ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.fst)).obj X.rel) ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd)).obj Y.rel))","decl":"/-- The object `X ⊗ Y` in the `Dial C` category just tuples the left and right components. -/\n@[simps] def tensorObj (X Y : Dial C) : Dial C where\n  src := X.src ⨯ Y.src\n  tgt := X.tgt ⨯ Y.tgt\n  rel :=\n    (Subobject.pullback (prod.map π₁ π₁)).obj X.rel ⊓\n    (Subobject.pullback (prod.map π₂ π₂)).obj Y.rel\n\n"}
{"name":"CategoryTheory.Dial.tensorObj_tgt","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n⊢ Eq (X.tensorObj Y).tgt (CategoryTheory.Limits.prod X.tgt Y.tgt)","decl":"/-- The object `X ⊗ Y` in the `Dial C` category just tuples the left and right components. -/\n@[simps] def tensorObj (X Y : Dial C) : Dial C where\n  src := X.src ⨯ Y.src\n  tgt := X.tgt ⨯ Y.tgt\n  rel :=\n    (Subobject.pullback (prod.map π₁ π₁)).obj X.rel ⊓\n    (Subobject.pullback (prod.map π₂ π₂)).obj Y.rel\n\n"}
{"name":"CategoryTheory.Dial.tensorHom_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX₁ X₂ Y₁ Y₂ : CategoryTheory.Dial C\nf : Quiver.Hom X₁ X₂\ng : Quiver.Hom Y₁ Y₂\n⊢ Eq (CategoryTheory.Dial.tensorHom f g).f (CategoryTheory.Limits.prod.map f.f g.f)","decl":"/-- The functorial action of `X ⊗ Y` in `Dial C`. -/\n@[simps] def tensorHom {X₁ X₂ Y₁ Y₂ : Dial C} (f : X₁ ⟶ X₂) (g : Y₁ ⟶ Y₂) :\n    tensorObj X₁ Y₁ ⟶ tensorObj X₂ Y₂ where\n  f := prod.map f.f g.f\n  F := π(prod.map π₁ π₁ ≫ f.F, prod.map π₂ π₂ ≫ g.F)\n  le := by\n    simp only [tensorObj, Subobject.inf_pullback]\n    apply inf_le_inf <;> rw [← Subobject.pullback_comp, ← Subobject.pullback_comp]\n    · have := (Subobject.pullback (prod.map π₁ π₁ :\n        (X₁.src ⨯ Y₁.src) ⨯ X₂.tgt ⨯ Y₂.tgt ⟶ _)).monotone (Hom.le f)\n      rw [← Subobject.pullback_comp, ← Subobject.pullback_comp] at this\n      convert this using 3 <;> simp\n    · have := (Subobject.pullback (prod.map π₂ π₂ :\n        (X₁.src ⨯ Y₁.src) ⨯ X₂.tgt ⨯ Y₂.tgt ⟶ _)).monotone (Hom.le g)\n      rw [← Subobject.pullback_comp, ← Subobject.pullback_comp] at this\n      convert this using 3 <;> simp\n\n"}
{"name":"CategoryTheory.Dial.tensorHom_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX₁ X₂ Y₁ Y₂ : CategoryTheory.Dial C\nf : Quiver.Hom X₁ X₂\ng : Quiver.Hom Y₁ Y₂\n⊢ Eq (CategoryTheory.Dial.tensorHom f g).F (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.fst) f.F) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd) g.F))","decl":"/-- The functorial action of `X ⊗ Y` in `Dial C`. -/\n@[simps] def tensorHom {X₁ X₂ Y₁ Y₂ : Dial C} (f : X₁ ⟶ X₂) (g : Y₁ ⟶ Y₂) :\n    tensorObj X₁ Y₁ ⟶ tensorObj X₂ Y₂ where\n  f := prod.map f.f g.f\n  F := π(prod.map π₁ π₁ ≫ f.F, prod.map π₂ π₂ ≫ g.F)\n  le := by\n    simp only [tensorObj, Subobject.inf_pullback]\n    apply inf_le_inf <;> rw [← Subobject.pullback_comp, ← Subobject.pullback_comp]\n    · have := (Subobject.pullback (prod.map π₁ π₁ :\n        (X₁.src ⨯ Y₁.src) ⨯ X₂.tgt ⨯ Y₂.tgt ⟶ _)).monotone (Hom.le f)\n      rw [← Subobject.pullback_comp, ← Subobject.pullback_comp] at this\n      convert this using 3 <;> simp\n    · have := (Subobject.pullback (prod.map π₂ π₂ :\n        (X₁.src ⨯ Y₁.src) ⨯ X₂.tgt ⨯ Y₂.tgt ⟶ _)).monotone (Hom.le g)\n      rw [← Subobject.pullback_comp, ← Subobject.pullback_comp] at this\n      convert this using 3 <;> simp\n\n"}
{"name":"CategoryTheory.Dial.tensorUnit_tgt","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasFiniteProducts C\n⊢ Eq CategoryTheory.Dial.tensorUnit.tgt (CategoryTheory.Limits.terminal C)","decl":"/-- The unit for the tensor `X ⊗ Y` in `Dial C`. -/\n@[simps] def tensorUnit : Dial C := { src := ⊤_ _, tgt := ⊤_ _, rel := ⊤ }\n\n"}
{"name":"CategoryTheory.Dial.tensorUnit_src","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasFiniteProducts C\n⊢ Eq CategoryTheory.Dial.tensorUnit.src (CategoryTheory.Limits.terminal C)","decl":"/-- The unit for the tensor `X ⊗ Y` in `Dial C`. -/\n@[simps] def tensorUnit : Dial C := { src := ⊤_ _, tgt := ⊤_ _, rel := ⊤ }\n\n"}
{"name":"CategoryTheory.Dial.tensorUnit_rel","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasFiniteProducts C\n⊢ Eq CategoryTheory.Dial.tensorUnit.rel Top.top","decl":"/-- The unit for the tensor `X ⊗ Y` in `Dial C`. -/\n@[simps] def tensorUnit : Dial C := { src := ⊤_ _, tgt := ⊤_ _, rel := ⊤ }\n\n"}
{"name":"CategoryTheory.Dial.leftUnitor_hom_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n⊢ Eq X.leftUnitor.hom.F (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.terminal.from (CategoryTheory.Limits.prod (CategoryTheory.Limits.prod (CategoryTheory.Limits.terminal C) X.src) X.tgt)) CategoryTheory.Limits.prod.snd)","decl":"/-- Left unit cancellation `1 ⊗ X ≅ X` in `Dial C`. -/\n@[simps!] def leftUnitor (X : Dial C) : tensorObj tensorUnit X ≅ X :=\n  isoMk (Limits.prod.leftUnitor _) (Limits.prod.leftUnitor _) <| by simp [Subobject.pullback_top]\n\n"}
{"name":"CategoryTheory.Dial.leftUnitor_inv_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n⊢ Eq X.leftUnitor.inv.F (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd)","decl":"/-- Left unit cancellation `1 ⊗ X ≅ X` in `Dial C`. -/\n@[simps!] def leftUnitor (X : Dial C) : tensorObj tensorUnit X ≅ X :=\n  isoMk (Limits.prod.leftUnitor _) (Limits.prod.leftUnitor _) <| by simp [Subobject.pullback_top]\n\n"}
{"name":"CategoryTheory.Dial.leftUnitor_inv_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n⊢ Eq X.leftUnitor.inv.f (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.terminal.from X.src) (CategoryTheory.CategoryStruct.id X.src))","decl":"/-- Left unit cancellation `1 ⊗ X ≅ X` in `Dial C`. -/\n@[simps!] def leftUnitor (X : Dial C) : tensorObj tensorUnit X ≅ X :=\n  isoMk (Limits.prod.leftUnitor _) (Limits.prod.leftUnitor _) <| by simp [Subobject.pullback_top]\n\n"}
{"name":"CategoryTheory.Dial.leftUnitor_hom_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n⊢ Eq X.leftUnitor.hom.f CategoryTheory.Limits.prod.snd","decl":"/-- Left unit cancellation `1 ⊗ X ≅ X` in `Dial C`. -/\n@[simps!] def leftUnitor (X : Dial C) : tensorObj tensorUnit X ≅ X :=\n  isoMk (Limits.prod.leftUnitor _) (Limits.prod.leftUnitor _) <| by simp [Subobject.pullback_top]\n\n"}
{"name":"CategoryTheory.Dial.rightUnitor_hom_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n⊢ Eq X.rightUnitor.hom.F (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.snd (CategoryTheory.Limits.terminal.from (CategoryTheory.Limits.prod (CategoryTheory.Limits.prod X.src (CategoryTheory.Limits.terminal C)) X.tgt)))","decl":"/-- Right unit cancellation `X ⊗ 1 ≅ X` in `Dial C`. -/\n@[simps!] def rightUnitor (X : Dial C) : tensorObj X tensorUnit ≅ X :=\n  isoMk (Limits.prod.rightUnitor _) (Limits.prod.rightUnitor _) <| by simp [Subobject.pullback_top]\n\n"}
{"name":"CategoryTheory.Dial.rightUnitor_inv_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n⊢ Eq X.rightUnitor.inv.F (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst)","decl":"/-- Right unit cancellation `X ⊗ 1 ≅ X` in `Dial C`. -/\n@[simps!] def rightUnitor (X : Dial C) : tensorObj X tensorUnit ≅ X :=\n  isoMk (Limits.prod.rightUnitor _) (Limits.prod.rightUnitor _) <| by simp [Subobject.pullback_top]\n\n"}
{"name":"CategoryTheory.Dial.rightUnitor_hom_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n⊢ Eq X.rightUnitor.hom.f CategoryTheory.Limits.prod.fst","decl":"/-- Right unit cancellation `X ⊗ 1 ≅ X` in `Dial C`. -/\n@[simps!] def rightUnitor (X : Dial C) : tensorObj X tensorUnit ≅ X :=\n  isoMk (Limits.prod.rightUnitor _) (Limits.prod.rightUnitor _) <| by simp [Subobject.pullback_top]\n\n"}
{"name":"CategoryTheory.Dial.rightUnitor_inv_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n⊢ Eq X.rightUnitor.inv.f (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id X.src) (CategoryTheory.Limits.terminal.from X.src))","decl":"/-- Right unit cancellation `X ⊗ 1 ≅ X` in `Dial C`. -/\n@[simps!] def rightUnitor (X : Dial C) : tensorObj X tensorUnit ≅ X :=\n  isoMk (Limits.prod.rightUnitor _) (Limits.prod.rightUnitor _) <| by simp [Subobject.pullback_top]\n\n"}
{"name":"CategoryTheory.Dial.associator_inv_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\n⊢ Eq (X.associator Y Z).inv.F (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.fst)) (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd)))","decl":"/-- The associator for tensor, `(X ⊗ Y) ⊗ Z ≅ X ⊗ (Y ⊗ Z)` in `Dial C`. -/\n@[simps!]\ndef associator (X Y Z : Dial C) : tensorObj (tensorObj X Y) Z ≅ tensorObj X (tensorObj Y Z) :=\n  isoMk (prod.associator ..) (prod.associator ..) <| by\n    simp [Subobject.inf_pullback, ← Subobject.pullback_comp, inf_assoc]\n\n"}
{"name":"CategoryTheory.Dial.associator_hom_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\n⊢ Eq (X.associator Y Z).hom.F (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst))) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd)))","decl":"/-- The associator for tensor, `(X ⊗ Y) ⊗ Z ≅ X ⊗ (Y ⊗ Z)` in `Dial C`. -/\n@[simps!]\ndef associator (X Y Z : Dial C) : tensorObj (tensorObj X Y) Z ≅ tensorObj X (tensorObj Y Z) :=\n  isoMk (prod.associator ..) (prod.associator ..) <| by\n    simp [Subobject.inf_pullback, ← Subobject.pullback_comp, inf_assoc]\n\n"}
{"name":"CategoryTheory.Dial.associator_inv_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\n⊢ Eq (X.associator Y Z).inv.f (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd))","decl":"/-- The associator for tensor, `(X ⊗ Y) ⊗ Z ≅ X ⊗ (Y ⊗ Z)` in `Dial C`. -/\n@[simps!]\ndef associator (X Y Z : Dial C) : tensorObj (tensorObj X Y) Z ≅ tensorObj X (tensorObj Y Z) :=\n  isoMk (prod.associator ..) (prod.associator ..) <| by\n    simp [Subobject.inf_pullback, ← Subobject.pullback_comp, inf_assoc]\n\n"}
{"name":"CategoryTheory.Dial.associator_hom_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\n⊢ Eq (X.associator Y Z).hom.f (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.fst) (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd) CategoryTheory.Limits.prod.snd))","decl":"/-- The associator for tensor, `(X ⊗ Y) ⊗ Z ≅ X ⊗ (Y ⊗ Z)` in `Dial C`. -/\n@[simps!]\ndef associator (X Y Z : Dial C) : tensorObj (tensorObj X Y) Z ≅ tensorObj X (tensorObj Y Z) :=\n  isoMk (prod.associator ..) (prod.associator ..) <| by\n    simp [Subobject.inf_pullback, ← Subobject.pullback_comp, inf_assoc]\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_tensorUnit_src","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\n⊢ Eq CategoryTheory.MonoidalCategoryStruct.tensorUnit.src (CategoryTheory.Limits.terminal C)","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_tensorUnit_tgt","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\n⊢ Eq CategoryTheory.MonoidalCategoryStruct.tensorUnit.tgt (CategoryTheory.Limits.terminal C)","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_tensorObj_tgt","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).tgt (CategoryTheory.Limits.prod X.tgt Y.tgt)","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_tensorObj_src","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).src (CategoryTheory.Limits.prod X.src Y.src)","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_associator_hom_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom.f (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.fst) (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd) CategoryTheory.Limits.prod.snd))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_associator_inv_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv.F (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.fst)) (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.snd)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd)))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_whiskerRight_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX₁✝ X₂✝ : CategoryTheory.Dial C\nf : Quiver.Hom X₁✝ X₂✝\nY : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y).f (CategoryTheory.Limits.prod.map f.f (CategoryTheory.CategoryStruct.id Y.src))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_tensorObj_rel","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).rel (Min.min ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.fst)).obj X.rel) ((CategoryTheory.Subobject.pullback (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd)).obj Y.rel))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_rightUnitor_inv_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv.f (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.id X.src) (CategoryTheory.Limits.terminal.from X.src))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_associator_inv_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).inv.f (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.fst (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_associator_hom_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.associator X Y Z).hom.F (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst))) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd)))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_rightUnitor_hom_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom.f CategoryTheory.Limits.prod.fst","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_whiskerLeft_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX x✝¹ x✝ : CategoryTheory.Dial C\nf : Quiver.Hom x✝¹ x✝\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f).f (CategoryTheory.Limits.prod.map (CategoryTheory.CategoryStruct.id X.src) f.f)","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_whiskerLeft_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX x✝¹ x✝ : CategoryTheory.Dial C\nf : Quiver.Hom x✝¹ x✝\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X f).F (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd) f.F))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_tensorHom_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX₁✝ Y₁✝ X₂✝ Y₂✝ : CategoryTheory.Dial C\nf : Quiver.Hom X₁✝ Y₁✝\ng : Quiver.Hom X₂✝ Y₂✝\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f g).f (CategoryTheory.Limits.prod.map f.f g.f)","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_leftUnitor_inv_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv.F (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd)","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_leftUnitor_inv_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).inv.f (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.terminal.from X.src) (CategoryTheory.CategoryStruct.id X.src))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_leftUnitor_hom_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom.F (CategoryTheory.Limits.prod.lift (CategoryTheory.Limits.terminal.from (CategoryTheory.Limits.prod (CategoryTheory.Limits.prod (CategoryTheory.Limits.terminal C) X.src) X.tgt)) CategoryTheory.Limits.prod.snd)","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_leftUnitor_hom_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom.f CategoryTheory.Limits.prod.snd","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_whiskerRight_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX₁✝ X₂✝ : CategoryTheory.Dial C\nf : Quiver.Hom X₁✝ X₂✝\nY : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Y).F (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.fst) f.F) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_rightUnitor_inv_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).inv.F (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst)","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_tensorHom_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX₁✝ Y₁✝ X₂✝ Y₂✝ : CategoryTheory.Dial C\nf : Quiver.Hom X₁✝ Y₁✝\ng : Quiver.Hom X₂✝ Y₂✝\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom f g).F (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.fst CategoryTheory.Limits.prod.fst) f.F) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd) g.F))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_rightUnitor_hom_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom.F (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.snd (CategoryTheory.Limits.terminal.from (CategoryTheory.Limits.prod (CategoryTheory.Limits.prod X.src (CategoryTheory.Limits.terminal C)) X.tgt)))","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.instMonoidalCategoryStruct_tensorUnit_rel","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\n⊢ Eq CategoryTheory.MonoidalCategoryStruct.tensorUnit.rel Top.top","decl":"@[simps!]\ninstance : MonoidalCategoryStruct (Dial C) where\n  tensorUnit := tensorUnit\n  tensorObj := tensorObj\n  whiskerLeft X _ _ f := tensorHom (𝟙 X) f\n  whiskerRight f Y := tensorHom f (𝟙 Y)\n  tensorHom := tensorHom\n  leftUnitor := leftUnitor\n  rightUnitor := rightUnitor\n  associator := associator\n\n"}
{"name":"CategoryTheory.Dial.tensor_id","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX₁ X₂ : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id X₁) (CategoryTheory.CategoryStruct.id X₂)) (CategoryTheory.CategoryStruct.id (CategoryTheory.MonoidalCategoryStruct.tensorObj X₁ X₂))","decl":"theorem tensor_id (X₁ X₂ : Dial C) : (𝟙 X₁ ⊗ 𝟙 X₂ : _ ⟶ _) = 𝟙 (X₁ ⊗ X₂ : Dial C) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Dial.tensor_comp","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX₁ Y₁ Z₁ X₂ Y₂ Z₂ : CategoryTheory.Dial C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₂\ng₁ : Quiver.Hom Y₁ Z₁\ng₂ : Quiver.Hom Y₂ Z₂\n⊢ Eq (CategoryTheory.Dial.tensorHom (CategoryTheory.CategoryStruct.comp f₁ g₁) (CategoryTheory.CategoryStruct.comp f₂ g₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Dial.tensorHom f₁ f₂) (CategoryTheory.Dial.tensorHom g₁ g₂))","decl":"theorem tensor_comp {X₁ Y₁ Z₁ X₂ Y₂ Z₂ : Dial C}\n    (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (g₁ : Y₁ ⟶ Z₁) (g₂ : Y₂ ⟶ Z₂) :\n    tensorHom (f₁ ≫ g₁) (f₂ ≫ g₂) = tensorHom f₁ f₂ ≫ tensorHom g₁ g₂ := by\n  ext <;> simp; ext <;> simp <;> (rw [← Category.assoc]; congr 1; simp)\n\n"}
{"name":"CategoryTheory.Dial.associator_naturality","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX₁ X₂ X₃ Y₁ Y₂ Y₃ : CategoryTheory.Dial C\nf₁ : Quiver.Hom X₁ Y₁\nf₂ : Quiver.Hom X₂ Y₂\nf₃ : Quiver.Hom X₃ Y₃\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Dial.tensorHom (CategoryTheory.Dial.tensorHom f₁ f₂) f₃) (Y₁.associator Y₂ Y₃).hom) (CategoryTheory.CategoryStruct.comp (X₁.associator X₂ X₃).hom (CategoryTheory.Dial.tensorHom f₁ (CategoryTheory.Dial.tensorHom f₂ f₃)))","decl":"theorem associator_naturality {X₁ X₂ X₃ Y₁ Y₂ Y₃ : Dial C}\n    (f₁ : X₁ ⟶ Y₁) (f₂ : X₂ ⟶ Y₂) (f₃ : X₃ ⟶ Y₃) :\n    tensorHom (tensorHom f₁ f₂) f₃ ≫ (associator Y₁ Y₂ Y₃).hom =\n    (associator X₁ X₂ X₃).hom ≫ tensorHom f₁ (tensorHom f₂ f₃) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Dial.leftUnitor_naturality","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit) f) (CategoryTheory.MonoidalCategoryStruct.leftUnitor Y).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom f)","decl":"theorem leftUnitor_naturality {X Y : Dial C} (f : X ⟶ Y) :\n    (𝟙 (𝟙_ (Dial C)) ⊗ f) ≫ (λ_ Y).hom = (λ_ X).hom ≫ f := by\n  ext <;> simp; ext; simp; congr 1; ext <;> simp\n\n"}
{"name":"CategoryTheory.Dial.rightUnitor_naturality","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.tensorHom f (CategoryTheory.CategoryStruct.id CategoryTheory.MonoidalCategoryStruct.tensorUnit)) (CategoryTheory.MonoidalCategoryStruct.rightUnitor Y).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom f)","decl":"theorem rightUnitor_naturality {X Y : Dial C} (f : X ⟶ Y) :\n    (f ⊗ 𝟙 (𝟙_ (Dial C))) ≫ (ρ_ Y).hom = (ρ_ X).hom ≫ f := by\n  ext <;> simp; ext; simp; congr 1; ext <;> simp\n\n"}
{"name":"CategoryTheory.Dial.pentagon","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nW X Y Z : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Dial.tensorHom (W.associator X Y).hom (CategoryTheory.CategoryStruct.id Z)) (CategoryTheory.CategoryStruct.comp (W.associator (X.tensorObj Y) Z).hom (CategoryTheory.Dial.tensorHom (CategoryTheory.CategoryStruct.id W) (X.associator Y Z).hom))) (CategoryTheory.CategoryStruct.comp ((W.tensorObj X).associator Y Z).hom (W.associator X (Y.tensorObj Z)).hom)","decl":"theorem pentagon (W X Y Z : Dial C) :\n    (tensorHom (associator W X Y).hom (𝟙 Z)) ≫ (associator W (tensorObj X Y) Z).hom ≫\n      (tensorHom (𝟙 W) (associator X Y Z).hom) =\n    (associator (tensorObj W X) Y Z).hom ≫ (associator W X (tensorObj Y Z)).hom := by\n  ext <;> simp\n\n"}
{"name":"CategoryTheory.Dial.triangle","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.associator CategoryTheory.MonoidalCategoryStruct.tensorUnit Y).hom (CategoryTheory.Dial.tensorHom (CategoryTheory.CategoryStruct.id X) Y.leftUnitor.hom)) (CategoryTheory.Dial.tensorHom X.rightUnitor.hom (CategoryTheory.CategoryStruct.id Y))","decl":"theorem triangle (X Y : Dial C) :\n    (associator X (𝟙_ (Dial C)) Y).hom ≫ tensorHom (𝟙 X) (leftUnitor Y).hom =\n    tensorHom (rightUnitor X).hom (𝟙 Y) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Dial.braiding_hom_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n⊢ Eq (X.braiding Y).hom.F (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst))","decl":"/-- The braiding isomorphism `X ⊗ Y ≅ Y ⊗ X` in `Dial C`. -/\n@[simps!] def braiding (X Y : Dial C) : tensorObj X Y ≅ tensorObj Y X :=\n  isoMk (prod.braiding ..) (prod.braiding ..) <| by\n    simp [Subobject.inf_pullback, ← Subobject.pullback_comp, inf_comm]\n\n"}
{"name":"CategoryTheory.Dial.braiding_inv_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n⊢ Eq (X.braiding Y).inv.f (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst)","decl":"/-- The braiding isomorphism `X ⊗ Y ≅ Y ⊗ X` in `Dial C`. -/\n@[simps!] def braiding (X Y : Dial C) : tensorObj X Y ≅ tensorObj Y X :=\n  isoMk (prod.braiding ..) (prod.braiding ..) <| by\n    simp [Subobject.inf_pullback, ← Subobject.pullback_comp, inf_comm]\n\n"}
{"name":"CategoryTheory.Dial.braiding_hom_f","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n⊢ Eq (X.braiding Y).hom.f (CategoryTheory.Limits.prod.lift CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst)","decl":"/-- The braiding isomorphism `X ⊗ Y ≅ Y ⊗ X` in `Dial C`. -/\n@[simps!] def braiding (X Y : Dial C) : tensorObj X Y ≅ tensorObj Y X :=\n  isoMk (prod.braiding ..) (prod.braiding ..) <| by\n    simp [Subobject.inf_pullback, ← Subobject.pullback_comp, inf_comm]\n\n"}
{"name":"CategoryTheory.Dial.braiding_inv_F","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n⊢ Eq (X.braiding Y).inv.F (CategoryTheory.Limits.prod.lift (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.snd) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd CategoryTheory.Limits.prod.fst))","decl":"/-- The braiding isomorphism `X ⊗ Y ≅ Y ⊗ X` in `Dial C`. -/\n@[simps!] def braiding (X Y : Dial C) : tensorObj X Y ≅ tensorObj Y X :=\n  isoMk (prod.braiding ..) (prod.braiding ..) <| by\n    simp [Subobject.inf_pullback, ← Subobject.pullback_comp, inf_comm]\n\n"}
{"name":"CategoryTheory.Dial.symmetry","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.braiding Y).hom (Y.braiding X).hom) (CategoryTheory.CategoryStruct.id (X.tensorObj Y))","decl":"theorem symmetry (X Y : Dial C) :\n    (braiding X Y).hom ≫ (braiding Y X).hom = 𝟙 (tensorObj X Y) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Dial.braiding_naturality_right","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\nf : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Dial.tensorHom (CategoryTheory.CategoryStruct.id X) f) (X.braiding Z).hom) (CategoryTheory.CategoryStruct.comp (X.braiding Y).hom (CategoryTheory.Dial.tensorHom f (CategoryTheory.CategoryStruct.id X)))","decl":"theorem braiding_naturality_right (X : Dial C) {Y Z : Dial C} (f : Y ⟶ Z) :\n    tensorHom (𝟙 X) f ≫ (braiding X Z).hom = (braiding X Y).hom ≫ tensorHom f (𝟙 X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Dial.braiding_naturality_left","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y : CategoryTheory.Dial C\nf : Quiver.Hom X Y\nZ : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Dial.tensorHom f (CategoryTheory.CategoryStruct.id Z)) (Y.braiding Z).hom) (CategoryTheory.CategoryStruct.comp (X.braiding Z).hom (CategoryTheory.Dial.tensorHom (CategoryTheory.CategoryStruct.id Z) f))","decl":"theorem braiding_naturality_left {X Y : Dial C} (f : X ⟶ Y) (Z : Dial C) :\n    tensorHom f (𝟙 Z) ≫ (braiding Y Z).hom = (braiding X Z).hom ≫ tensorHom (𝟙 Z) f := by aesop_cat\n\n"}
{"name":"CategoryTheory.Dial.hexagon_forward","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.associator Y Z).hom (CategoryTheory.CategoryStruct.comp (X.braiding (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z)).hom (Y.associator Z X).hom)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Dial.tensorHom (X.braiding Y).hom (CategoryTheory.CategoryStruct.id Z)) (CategoryTheory.CategoryStruct.comp (Y.associator X Z).hom (CategoryTheory.Dial.tensorHom (CategoryTheory.CategoryStruct.id Y) (X.braiding Z).hom)))","decl":"theorem hexagon_forward (X Y Z : Dial C) :\n    (associator X Y Z).hom ≫ (braiding X (Y ⊗ Z)).hom ≫ (associator Y Z X).hom =\n      tensorHom (braiding X Y).hom (𝟙 Z) ≫ (associator Y X Z).hom ≫\n      tensorHom (𝟙 Y) (braiding X Z).hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.Dial.hexagon_reverse","module":"Mathlib.CategoryTheory.Dialectica.Monoidal","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : CategoryTheory.Dial C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.associator Y Z).inv (CategoryTheory.CategoryStruct.comp ((CategoryTheory.MonoidalCategoryStruct.tensorObj X Y).braiding Z).hom (Z.associator X Y).inv)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Dial.tensorHom (CategoryTheory.CategoryStruct.id X) (Y.braiding Z).hom) (CategoryTheory.CategoryStruct.comp (X.associator Z Y).inv (CategoryTheory.Dial.tensorHom (X.braiding Z).hom (CategoryTheory.CategoryStruct.id Y))))","decl":"theorem hexagon_reverse (X Y Z : Dial C) :\n    (associator X Y Z).inv ≫ (braiding (X ⊗ Y) Z).hom ≫ (associator Z X Y).inv =\n      tensorHom (𝟙 X) (braiding Y Z).hom ≫ (associator X Z Y).inv ≫\n      tensorHom (braiding X Z).hom (𝟙 Y) := by aesop_cat\n\n"}
