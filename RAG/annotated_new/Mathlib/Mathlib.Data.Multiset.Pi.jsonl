{"name":"Multiset.Pi.cons_same","module":"Mathlib.Data.Multiset.Pi","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nδ : α → Sort u_2\nm : Multiset α\na : α\nb : δ a\nf : (a : α) → Membership.mem m a → δ a\nh : Membership.mem (Multiset.cons a m) a\n⊢ Eq (Multiset.Pi.cons m a b f a h) b","decl":"theorem cons_same {b : δ a} {f : ∀ a ∈ m, δ a} (h : a ∈ a ::ₘ m) :\n    cons m a b f a h = b :=\n  dif_pos rfl\n\n"}
{"name":"Multiset.Pi.cons_ne","module":"Mathlib.Data.Multiset.Pi","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nδ : α → Sort u_2\nm : Multiset α\na a' : α\nb : δ a\nf : (a : α) → Membership.mem m a → δ a\nh' : Membership.mem (Multiset.cons a m) a'\nh : Ne a' a\n⊢ Eq (Multiset.Pi.cons m a b f a' h') (f a' ⋯)","decl":"theorem cons_ne {a a' : α} {b : δ a} {f : ∀ a ∈ m, δ a} (h' : a' ∈ a ::ₘ m)\n    (h : a' ≠ a) : Pi.cons m a b f a' h' = f a' ((mem_cons.1 h').resolve_left h) :=\n  dif_neg h\n\n"}
{"name":"Multiset.Pi.cons_swap","module":"Mathlib.Data.Multiset.Pi","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nδ : α → Sort u_2\na a' : α\nb : δ a\nb' : δ a'\nm : Multiset α\nf : (a : α) → Membership.mem m a → δ a\nh : Ne a a'\n⊢ HEq (Multiset.Pi.cons (Multiset.cons a' m) a b (Multiset.Pi.cons m a' b' f)) (Multiset.Pi.cons (Multiset.cons a m) a' b' (Multiset.Pi.cons m a b f))","decl":"theorem cons_swap {a a' : α} {b : δ a} {b' : δ a'} {m : Multiset α} {f : ∀ a ∈ m, δ a}\n    (h : a ≠ a') : HEq (Pi.cons (a' ::ₘ m) a b (Pi.cons m a' b' f))\n      (Pi.cons (a ::ₘ m) a' b' (Pi.cons m a b f)) := by\n  apply hfunext rfl\n  simp only [heq_iff_eq]\n  rintro a'' _ rfl\n  refine hfunext (by rw [Multiset.cons_swap]) fun ha₁ ha₂ _ => ?_\n  rcases Decidable.ne_or_eq a'' a with (h₁ | rfl)\n  on_goal 1 => rcases Decidable.eq_or_ne a'' a' with (rfl | h₂)\n  all_goals simp [*, Pi.cons_same, Pi.cons_ne]\n\n"}
{"name":"Multiset.Pi.cons_eta","module":"Mathlib.Data.Multiset.Pi","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nδ : α → Sort u_2\nm : Multiset α\na : α\nf : (a' : α) → Membership.mem (Multiset.cons a m) a' → δ a'\n⊢ Eq (Multiset.Pi.cons m a (f a ⋯) fun a' ha' => f a' ⋯) f","decl":"@[simp]\ntheorem cons_eta {m : Multiset α} {a : α} (f : ∀ a' ∈ a ::ₘ m, δ a') :\n    (cons m a (f _ (mem_cons_self _ _)) fun a' ha' => f a' (mem_cons_of_mem ha')) = f := by\n  ext a' h'\n  by_cases h : a' = a\n  · subst h\n    rw [Pi.cons_same]\n  · rw [Pi.cons_ne _ h]\n\n"}
{"name":"Multiset.Pi.cons_map","module":"Mathlib.Data.Multiset.Pi","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nδ : α → Sort u_2\nm : Multiset α\na : α\nb : δ a\nf : (a' : α) → Membership.mem m a' → δ a'\nδ' : α → Sort u_3\nφ : ⦃a' : α⦄ → δ a' → δ' a'\n⊢ Eq (Multiset.Pi.cons m a (φ b) fun a' ha' => φ (f a' ha')) fun a' ha' => φ (Multiset.Pi.cons m a b f a' ha')","decl":"theorem cons_map (b : δ a) (f : ∀ a' ∈ m, δ a')\n    {δ' : α → Sort*} (φ : ∀ ⦃a'⦄, δ a' → δ' a') :\n    Pi.cons _ _ (φ b) (fun a' ha' ↦ φ (f a' ha')) = (fun a' ha' ↦ φ ((cons _ _ b f) a' ha')) := by\n  ext a' ha'\n  refine (congrArg₂ _ ?_ rfl).trans (apply_dite (@φ _) (a' = a) _ _).symm\n  ext rfl\n  rfl\n\n"}
{"name":"Multiset.Pi.forall_rel_cons_ext","module":"Mathlib.Data.Multiset.Pi","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nδ : α → Sort u_2\nm : Multiset α\na✝ : α\nr : ⦃a : α⦄ → δ a → δ a → Prop\nb₁ b₂ : δ a✝\nf₁ f₂ : (a' : α) → Membership.mem m a' → δ a'\nhb : r b₁ b₂\nhf : ∀ (a : α) (ha : Membership.mem m a), r (f₁ a ha) (f₂ a ha)\na : α\nha : Membership.mem (Multiset.cons a✝ m) a\n⊢ r (Multiset.Pi.cons m a✝ b₁ f₁ a ha) (Multiset.Pi.cons m a✝ b₂ f₂ a ha)","decl":"theorem forall_rel_cons_ext {r : ∀ ⦃a⦄, δ a → δ a → Prop} {b₁ b₂ : δ a} {f₁ f₂ : ∀ a' ∈ m, δ a'}\n    (hb : r b₁ b₂) (hf : ∀ (a : α) (ha : a ∈ m), r (f₁ a ha) (f₂ a ha)) :\n    ∀ a ha, r (cons _ _ b₁ f₁ a ha) (cons _ _ b₂ f₂ a ha) := by\n  intro a ha\n  dsimp [cons]\n  split_ifs with H\n  · cases H\n    exact hb\n  · exact hf _ _\n\n"}
{"name":"Multiset.Pi.cons_injective","module":"Mathlib.Data.Multiset.Pi","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nδ : α → Sort u_2\na : α\nb : δ a\ns : Multiset α\nhs : Not (Membership.mem s a)\n⊢ Function.Injective (Multiset.Pi.cons s a b)","decl":"theorem cons_injective {a : α} {b : δ a} {s : Multiset α} (hs : a ∉ s) :\n    Function.Injective (Pi.cons s a b) := fun f₁ f₂ eq =>\n  funext fun a' =>\n    funext fun h' =>\n      have ne : a ≠ a' := fun h => hs <| h.symm ▸ h'\n      have : a' ∈ a ::ₘ s := mem_cons_of_mem h'\n      calc\n        f₁ a' h' = Pi.cons s a b f₁ a' this := by rw [Pi.cons_ne this ne.symm]\n               _ = Pi.cons s a b f₂ a' this := by rw [eq]\n               _ = f₂ a' h' := by rw [Pi.cons_ne this ne.symm]\n\n"}
{"name":"Multiset.pi_zero","module":"Mathlib.Data.Multiset.Pi","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nβ : α → Type u_2\nt : (a : α) → Multiset (β a)\n⊢ Eq (Multiset.pi 0 t) (Singleton.singleton (Multiset.Pi.empty β))","decl":"@[simp]\ntheorem pi_zero (t : ∀ a, Multiset (β a)) : pi 0 t = {Pi.empty β} :=\n  rfl\n\n"}
{"name":"Multiset.pi_cons","module":"Mathlib.Data.Multiset.Pi","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nβ : α → Type u_2\nm : Multiset α\nt : (a : α) → Multiset (β a)\na : α\n⊢ Eq ((Multiset.cons a m).pi t) ((t a).bind fun b => Multiset.map (Multiset.Pi.cons m a b) (m.pi t))","decl":"@[simp]\ntheorem pi_cons (m : Multiset α) (t : ∀ a, Multiset (β a)) (a : α) :\n    pi (a ::ₘ m) t = (t a).bind fun b => (pi m t).map <| Pi.cons m a b :=\n  recOn_cons a m\n\n"}
{"name":"Multiset.card_pi","module":"Mathlib.Data.Multiset.Pi","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nβ : α → Type u_2\nm : Multiset α\nt : (a : α) → Multiset (β a)\n⊢ Eq (m.pi t).card (Multiset.map (fun a => (t a).card) m).prod","decl":"theorem card_pi (m : Multiset α) (t : ∀ a, Multiset (β a)) :\n    card (pi m t) = prod (m.map fun a => card (t a)) :=\n  Multiset.induction_on m (by simp) (by simp +contextual [mul_comm])\n\n"}
{"name":"Multiset.Nodup.pi","module":"Mathlib.Data.Multiset.Pi","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nβ : α → Type u_2\ns : Multiset α\nt : (a : α) → Multiset (β a)\na✝¹ : s.Nodup\na✝ : ∀ (a : α), Membership.mem s a → (t a).Nodup\n⊢ (s.pi t).Nodup","decl":"protected theorem Nodup.pi {s : Multiset α} {t : ∀ a, Multiset (β a)} :\n    Nodup s → (∀ a ∈ s, Nodup (t a)) → Nodup (pi s t) :=\n  Multiset.induction_on s (fun _ _ => nodup_singleton _)\n    (by\n      intro a s ih hs ht\n      have has : a ∉ s := by simp only [nodup_cons] at hs; exact hs.1\n      have hs : Nodup s := by simp only [nodup_cons] at hs; exact hs.2\n      simp only [pi_cons, nodup_bind]\n      refine\n        ⟨fun b _ => ((ih hs) fun a' h' => ht a' <| mem_cons_of_mem h').map (Pi.cons_injective has),\n          ?_⟩\n      refine (ht a <| mem_cons_self _ _).pairwise ?_\n      exact fun b₁ _ b₂ _ neb =>\n        disjoint_map_map.2 fun f _ g _ eq =>\n          have : Pi.cons s a b₁ f a (mem_cons_self _ _) = Pi.cons s a b₂ g a (mem_cons_self _ _) :=\n            by rw [eq]\n          neb <| show b₁ = b₂ by rwa [Pi.cons_same, Pi.cons_same] at this)\n\n"}
{"name":"Multiset.mem_pi","module":"Mathlib.Data.Multiset.Pi","initialProofState":"α : Type u_1\ninst✝ : DecidableEq α\nβ : α → Type u_2\nm : Multiset α\nt : (a : α) → Multiset (β a)\nf : (a : α) → Membership.mem m a → β a\n⊢ Iff (Membership.mem (m.pi t) f) (∀ (a : α) (h : Membership.mem m a), Membership.mem (t a) (f a h))","decl":"theorem mem_pi (m : Multiset α) (t : ∀ a, Multiset (β a)) :\n    ∀ f : ∀ a ∈ m, β a, f ∈ pi m t ↔ ∀ (a) (h : a ∈ m), f a h ∈ t a := by\n  intro f\n  induction' m using Multiset.induction_on with a m ih\n  · have : f = Pi.empty β := funext (fun _ => funext fun h => (not_mem_zero _ h).elim)\n    simp only [this, pi_zero, mem_singleton, true_iff]\n    intro _ h; exact (not_mem_zero _ h).elim\n  simp_rw [pi_cons, mem_bind, mem_map, ih]\n  constructor\n  · rintro ⟨b, hb, f', hf', rfl⟩ a' ha'\n    by_cases h : a' = a\n    · subst h\n      rwa [Pi.cons_same]\n    · rw [Pi.cons_ne _ h]\n      apply hf'\n  · intro hf\n    refine ⟨_, hf a (mem_cons_self _ _), _, fun a ha => hf a (mem_cons_of_mem ha), ?_⟩\n    rw [Pi.cons_eta]\n\n"}
