{"name":"LSeries.term_def","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\ns : Complex\nn : Nat\n⊢ Eq (LSeries.term f s n) (ite (Eq n 0) 0 (HDiv.hDiv (f n) (HPow.hPow (↑n) s)))","decl":"lemma term_def (f : ℕ → ℂ) (s : ℂ) (n : ℕ) :\n    term f s n = if n = 0 then 0 else f n / n ^ s :=\n  rfl\n\n"}
{"name":"LSeries.term_def₀","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\nhf : Eq (f 0) 0\ns : Complex\nn : Nat\n⊢ Eq (LSeries.term f s n) (HMul.hMul (f n) (HPow.hPow (↑n) (Neg.neg s)))","decl":"/-- An alternate spelling of `term_def` for the case `f 0 = 0`. -/\nlemma term_def₀ {f : ℕ → ℂ} (hf : f 0 = 0) (s : ℂ) (n : ℕ) :\n    LSeries.term f s n = f n * (n : ℂ) ^ (- s) := by\n  rw [LSeries.term]\n  split_ifs with h <;> simp [h, hf, cpow_neg, div_eq_inv_mul, mul_comm]\n\n"}
{"name":"LSeries.term_zero","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\ns : Complex\n⊢ Eq (LSeries.term f s 0) 0","decl":"@[simp]\nlemma term_zero (f : ℕ → ℂ) (s : ℂ) : term f s 0 = 0 := rfl\n\n-- We put `hn` first for convnience, so that we can write `rw [LSeries.term_of_ne_zero hn]` etc.\n"}
{"name":"LSeries.term_of_ne_zero","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"n : Nat\nhn : Ne n 0\nf : Nat → Complex\ns : Complex\n⊢ Eq (LSeries.term f s n) (HDiv.hDiv (f n) (HPow.hPow (↑n) s))","decl":"@[simp]\nlemma term_of_ne_zero {n : ℕ} (hn : n ≠ 0) (f : ℕ → ℂ) (s : ℂ) :\n    term f s n = f n / n ^ s :=\n  if_neg hn\n\n"}
{"name":"LSeries.term_of_ne_zero'","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"s : Complex\nhs : Ne s 0\nf : Nat → Complex\nn : Nat\n⊢ Eq (LSeries.term f s n) (HDiv.hDiv (f n) (HPow.hPow (↑n) s))","decl":"/--\nIf `s ≠ 0`, then the `if .. then .. else` construction in `LSeries.term` isn't needed, since\n`0 ^ s = 0`.\n-/\nlemma term_of_ne_zero' {s : ℂ} (hs : s ≠ 0) (f : ℕ → ℂ) (n : ℕ) :\n    term f s n = f n / n ^ s := by\n  rcases eq_or_ne n 0 with rfl | hn\n  · rw [term_zero, Nat.cast_zero, zero_cpow hs, div_zero]\n  · rw [term_of_ne_zero hn]\n\n"}
{"name":"LSeries.term_congr","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f g : Nat → Complex\nh : ∀ {n : Nat}, Ne n 0 → Eq (f n) (g n)\ns : Complex\nn : Nat\n⊢ Eq (LSeries.term f s n) (LSeries.term g s n)","decl":"lemma term_congr {f g : ℕ → ℂ} (h : ∀ {n}, n ≠ 0 → f n = g n) (s : ℂ) (n : ℕ) :\n    term f s n = term g s n := by\n  rcases eq_or_ne n 0 with hn | hn <;> simp [hn, h]\n\n"}
{"name":"LSeries.pow_mul_term_eq","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\ns : Complex\nn : Nat\n⊢ Eq (HMul.hMul (HPow.hPow (HAdd.hAdd (↑n) 1) s) (LSeries.term f s (HAdd.hAdd n 1))) (f (HAdd.hAdd n 1))","decl":"lemma pow_mul_term_eq (f : ℕ → ℂ) (s : ℂ) (n : ℕ) :\n    (n + 1) ^ s * term f s (n + 1) = f (n + 1) := by\n  simp [term, natCast_add_one_cpow_ne_zero n _, mul_comm (f _), mul_div_assoc']\n\n"}
{"name":"LSeries.norm_term_eq","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\ns : Complex\nn : Nat\n⊢ Eq (Norm.norm (LSeries.term f s n)) (ite (Eq n 0) 0 (HDiv.hDiv (Norm.norm (f n)) (HPow.hPow (↑n) s.re)))","decl":"lemma norm_term_eq (f : ℕ → ℂ) (s : ℂ) (n : ℕ) :\n    ‖term f s n‖ = if n = 0 then 0 else ‖f n‖ / n ^ s.re := by\n  rcases eq_or_ne n 0 with rfl | hn\n  · simp\n  · simp [hn, norm_natCast_cpow_of_pos <| Nat.pos_of_ne_zero hn]\n\n"}
{"name":"LSeries.norm_term_le","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f g : Nat → Complex\ns : Complex\nn : Nat\nh : LE.le (Norm.norm (f n)) (Norm.norm (g n))\n⊢ LE.le (Norm.norm (LSeries.term f s n)) (Norm.norm (LSeries.term g s n))","decl":"lemma norm_term_le {f g : ℕ → ℂ} (s : ℂ) {n : ℕ} (h : ‖f n‖ ≤ ‖g n‖) :\n    ‖term f s n‖ ≤ ‖term g s n‖ := by\n  simp only [norm_term_eq]\n  split\n  · rfl\n  · gcongr\n\n"}
{"name":"LSeries.norm_term_le_of_re_le_re","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\ns s' : Complex\nh : LE.le s.re s'.re\nn : Nat\n⊢ LE.le (Norm.norm (LSeries.term f s' n)) (Norm.norm (LSeries.term f s n))","decl":"lemma norm_term_le_of_re_le_re (f : ℕ → ℂ) {s s' : ℂ} (h : s.re ≤ s'.re) (n : ℕ) :\n    ‖term f s' n‖ ≤ ‖term f s n‖ := by\n  simp only [norm_term_eq]\n  split\n  · next => rfl\n  · next hn => gcongr; exact Nat.one_le_cast.mpr <| Nat.one_le_iff_ne_zero.mpr hn\n\n"}
{"name":"LSeries.term_nonneg","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"a : Nat → Complex\nn : Nat\nh : LE.le 0 (a n)\nx : Real\n⊢ LE.le 0 (LSeries.term a (↑x) n)","decl":"lemma term_nonneg {a : ℕ → ℂ} {n : ℕ} (h : 0 ≤ a n) (x : ℝ) : 0 ≤ term a x n := by\n  rw [term_def]\n  split_ifs with hn\n  exacts [le_rfl, mul_nonneg h (inv_natCast_cpow_ofReal_pos hn x).le]\n\n"}
{"name":"LSeries.term_pos","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"a : Nat → Complex\nn : Nat\nhn : Ne n 0\nh : LT.lt 0 (a n)\nx : Real\n⊢ LT.lt 0 (LSeries.term a (↑x) n)","decl":"lemma term_pos {a : ℕ → ℂ} {n : ℕ} (hn : n ≠ 0) (h : 0 < a n) (x : ℝ) : 0 < term a x n := by\n  simpa only [term_of_ne_zero hn] using mul_pos h <| inv_natCast_cpow_ofReal_pos hn x\n\n"}
{"name":"LSeries_congr","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f g : Nat → Complex\ns : Complex\nh : ∀ {n : Nat}, Ne n 0 → Eq (f n) (g n)\n⊢ Eq (LSeries f s) (LSeries g s)","decl":"lemma LSeries_congr {f g : ℕ → ℂ} (s : ℂ) (h : ∀ {n}, n ≠ 0 → f n = g n) :\n    LSeries f s = LSeries g s :=\n  tsum_congr <| term_congr h s\n\n"}
{"name":"LSeriesSummable_congr","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f g : Nat → Complex\ns : Complex\nh : ∀ {n : Nat}, Ne n 0 → Eq (f n) (g n)\n⊢ Iff (LSeriesSummable f s) (LSeriesSummable g s)","decl":"lemma LSeriesSummable_congr {f g : ℕ → ℂ} (s : ℂ) (h : ∀ {n}, n ≠ 0 → f n = g n) :\n    LSeriesSummable f s ↔ LSeriesSummable g s :=\n  summable_congr <| term_congr h s\n\n"}
{"name":"LSeriesSummable.congr'","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f g : Nat → Complex\ns : Complex\nh : Filter.atTop.EventuallyEq f g\nhf : LSeriesSummable f s\n⊢ LSeriesSummable g s","decl":"open Filter in\n/-- If `f` and `g` agree on large `n : ℕ` and the `LSeries` of `f` converges at `s`,\nthen so does that of `g`. -/\nlemma LSeriesSummable.congr' {f g : ℕ → ℂ} (s : ℂ) (h : f =ᶠ[atTop] g) (hf : LSeriesSummable f s) :\n    LSeriesSummable g s := by\n  rw [← Nat.cofinite_eq_atTop] at h\n  refine (summable_norm_iff.mpr hf).of_norm_bounded_eventually _ ?_\n  have : term f s =ᶠ[cofinite] term g s := by\n    rw [eventuallyEq_iff_exists_mem] at h ⊢\n    obtain ⟨S, hS, hS'⟩ := h\n    refine ⟨S \\ {0}, diff_mem hS <| (Set.finite_singleton 0).compl_mem_cofinite, fun n hn ↦ ?_⟩\n    rw [Set.mem_diff, Set.mem_singleton_iff] at hn\n    simp [hn.2, hS' hn.1]\n  exact this.symm.mono fun n hn ↦ by simp [hn]\n\n"}
{"name":"LSeriesSummable_congr'","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f g : Nat → Complex\ns : Complex\nh : Filter.atTop.EventuallyEq f g\n⊢ Iff (LSeriesSummable f s) (LSeriesSummable g s)","decl":"open Filter in\n/-- If `f` and `g` agree on large `n : ℕ`, then the `LSeries` of `f` converges at `s`\nif and only if that of `g` does. -/\nlemma LSeriesSummable_congr' {f g : ℕ → ℂ} (s : ℂ) (h : f =ᶠ[atTop] g) :\n    LSeriesSummable f s ↔ LSeriesSummable g s :=\n  ⟨fun H ↦ H.congr' s h, fun H ↦ H.congr' s h.symm⟩\n\n"}
{"name":"LSeries.eq_zero_of_not_LSeriesSummable","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\ns : Complex\na✝ : Not (LSeriesSummable f s)\n⊢ Eq (LSeries f s) 0","decl":"theorem LSeries.eq_zero_of_not_LSeriesSummable (f : ℕ → ℂ) (s : ℂ) :\n    ¬ LSeriesSummable f s → LSeries f s = 0 :=\n  tsum_eq_zero_of_not_summable\n\n"}
{"name":"LSeriesSummable_zero","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"s : Complex\n⊢ LSeriesSummable 0 s","decl":"@[simp]\ntheorem LSeriesSummable_zero {s : ℂ} : LSeriesSummable 0 s := by\n  simp [LSeriesSummable, funext (term_def 0 s), summable_zero]\n\n"}
{"name":"LSeriesHasSum.LSeriesSummable","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\ns a : Complex\nh : LSeriesHasSum f s a\n⊢ LSeriesSummable f s","decl":"lemma LSeriesHasSum.LSeriesSummable {f : ℕ → ℂ} {s a : ℂ}\n    (h : LSeriesHasSum f s a) : LSeriesSummable f s :=\n  h.summable\n\n"}
{"name":"LSeriesHasSum.LSeries_eq","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\ns a : Complex\nh : LSeriesHasSum f s a\n⊢ Eq (LSeries f s) a","decl":"lemma LSeriesHasSum.LSeries_eq {f : ℕ → ℂ} {s a : ℂ}\n    (h : LSeriesHasSum f s a) : LSeries f s = a :=\n  h.tsum_eq\n\n"}
{"name":"LSeriesSummable.LSeriesHasSum","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\ns : Complex\nh : LSeriesSummable f s\n⊢ LSeriesHasSum f s (LSeries f s)","decl":"lemma LSeriesSummable.LSeriesHasSum {f : ℕ → ℂ} {s : ℂ} (h : LSeriesSummable f s) :\n    LSeriesHasSum f s (LSeries f s) :=\n  h.hasSum\n\n"}
{"name":"LSeriesHasSum_iff","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\ns a : Complex\n⊢ Iff (LSeriesHasSum f s a) (And (LSeriesSummable f s) (Eq (LSeries f s) a))","decl":"lemma LSeriesHasSum_iff {f : ℕ → ℂ} {s a : ℂ} :\n    LSeriesHasSum f s a ↔ LSeriesSummable f s ∧ LSeries f s = a :=\n  ⟨fun H ↦ ⟨H.LSeriesSummable, H.LSeries_eq⟩, fun ⟨H₁, H₂⟩ ↦ H₂ ▸ H₁.LSeriesHasSum⟩\n\n"}
{"name":"LSeriesHasSum_congr","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f g : Nat → Complex\ns a : Complex\nh : ∀ {n : Nat}, Ne n 0 → Eq (f n) (g n)\n⊢ Iff (LSeriesHasSum f s a) (LSeriesHasSum g s a)","decl":"lemma LSeriesHasSum_congr {f g : ℕ → ℂ} (s a : ℂ) (h : ∀ {n}, n ≠ 0 → f n = g n) :\n    LSeriesHasSum f s a ↔ LSeriesHasSum g s a := by\n  simp [LSeriesHasSum_iff, LSeriesSummable_congr s h, LSeries_congr s h]\n\n"}
{"name":"LSeriesSummable.of_re_le_re","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\ns s' : Complex\nh : LE.le s.re s'.re\nhf : LSeriesSummable f s\n⊢ LSeriesSummable f s'","decl":"lemma LSeriesSummable.of_re_le_re {f : ℕ → ℂ} {s s' : ℂ} (h : s.re ≤ s'.re)\n    (hf : LSeriesSummable f s) : LSeriesSummable f s' := by\n  rw [LSeriesSummable, ← summable_norm_iff] at hf ⊢\n  exact hf.of_nonneg_of_le (fun _ ↦ norm_nonneg _) (norm_term_le_of_re_le_re f h)\n\n"}
{"name":"LSeriesSummable_iff_of_re_eq_re","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\ns s' : Complex\nh : Eq s.re s'.re\n⊢ Iff (LSeriesSummable f s) (LSeriesSummable f s')","decl":"theorem LSeriesSummable_iff_of_re_eq_re {f : ℕ → ℂ} {s s' : ℂ} (h : s.re = s'.re) :\n    LSeriesSummable f s ↔ LSeriesSummable f s' :=\n  ⟨fun H ↦ H.of_re_le_re h.le, fun H ↦ H.of_re_le_re h.symm.le⟩\n\n"}
{"name":"LSeries_zero","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"⊢ Eq (LSeries 0) 0","decl":"@[simp]\nlemma LSeries_zero : LSeries 0 = 0 := by\n  ext\n  simp [LSeries, LSeries.term]\n\n"}
{"name":"LSeries.term_delta","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"s : Complex\nn : Nat\n⊢ Eq (LSeries.term LSeries.delta s n) (ite (Eq n 1) 1 0)","decl":"lemma term_delta (s : ℂ) (n : ℕ) : term δ s n = if n = 1 then 1 else 0 := by\n  rcases eq_or_ne n 0 with rfl | hn\n  · simp\n  · rcases eq_or_ne n 1 with hn' | hn' <;>\n    simp [hn, hn', delta]\n\n"}
{"name":"LSeries.mul_delta_eq_smul_delta","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\n⊢ Eq (HMul.hMul f LSeries.delta) (HSMul.hSMul (f 1) LSeries.delta)","decl":"lemma mul_delta_eq_smul_delta {f : ℕ → ℂ} : f * δ = f 1 • δ := by\n  ext n\n  by_cases hn : n = 1 <;>\n  simp [hn, delta]\n\n"}
{"name":"LSeries.mul_delta","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\nh : Eq (f 1) 1\n⊢ Eq (HMul.hMul f LSeries.delta) LSeries.delta","decl":"lemma mul_delta {f : ℕ → ℂ} (h : f 1 = 1) : f * δ = δ := by\n  rw [mul_delta_eq_smul_delta, h, one_smul]\n\n"}
{"name":"LSeries.delta_mul_eq_smul_delta","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\n⊢ Eq (HMul.hMul LSeries.delta f) (HSMul.hSMul (f 1) LSeries.delta)","decl":"lemma delta_mul_eq_smul_delta {f : ℕ → ℂ} : δ * f = f 1 • δ :=\n  mul_comm δ f ▸ mul_delta_eq_smul_delta\n\n"}
{"name":"LSeries.delta_mul","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\nh : Eq (f 1) 1\n⊢ Eq (HMul.hMul LSeries.delta f) LSeries.delta","decl":"lemma delta_mul {f : ℕ → ℂ} (h : f 1 = 1) : δ * f = δ :=\n  mul_comm δ f ▸ mul_delta h\n\n"}
{"name":"LSeries_delta","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"⊢ Eq (LSeries LSeries.delta) 1","decl":"/-- The L-series of `δ` is the constant function `1`. -/\nlemma LSeries_delta : LSeries δ = 1 := by\n  ext\n  simp [LSeries, LSeries.term_delta]\n\n"}
{"name":"LSeriesSummable.le_const_mul_rpow","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\ns : Complex\nh : LSeriesSummable f s\n⊢ Exists fun C => ∀ (n : Nat), Ne n 0 → LE.le (Norm.norm (f n)) (HMul.hMul C (HPow.hPow (↑n) s.re))","decl":"/-- If the `LSeries` of `f` is summable at `s`, then `f n` is bounded in absolute value\nby a constant times `n^(re s)`. -/\nlemma LSeriesSummable.le_const_mul_rpow {f : ℕ → ℂ} {s : ℂ} (h : LSeriesSummable f s) :\n    ∃ C, ∀ n ≠ 0, ‖f n‖ ≤ C * n ^ s.re := by\n  replace h := h.norm\n  by_contra! H\n  obtain ⟨n, hn₀, hn⟩ := H (tsum fun n ↦ ‖term f s n‖)\n  have := le_tsum h n fun _ _ ↦ norm_nonneg _\n  rw [norm_term_eq, if_neg hn₀,\n    div_le_iff₀ <| Real.rpow_pos_of_pos (Nat.cast_pos.mpr <| Nat.pos_of_ne_zero hn₀) _] at this\n  exact (this.trans_lt hn).false.elim\n\n"}
{"name":"LSeriesSummable.isBigO_rpow","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\ns : Complex\nh : LSeriesSummable f s\n⊢ Asymptotics.IsBigO Filter.atTop f fun n => HPow.hPow (↑n) s.re","decl":"open Filter in\n/-- If the `LSeries` of `f` is summable at `s`, then `f = O(n^(re s))`. -/\nlemma LSeriesSummable.isBigO_rpow {f : ℕ → ℂ} {s : ℂ} (h : LSeriesSummable f s) :\n    f =O[atTop] fun n ↦ (n : ℝ) ^ s.re := by\n  obtain ⟨C, hC⟩ := h.le_const_mul_rpow\n  refine Asymptotics.IsBigO.of_bound C <| eventually_atTop.mpr ⟨1, fun n hn ↦ ?_⟩\n  convert hC n (Nat.pos_iff_ne_zero.mp hn) using 2\n  rw [Real.norm_eq_abs, Real.abs_rpow_of_nonneg n.cast_nonneg, _root_.abs_of_nonneg n.cast_nonneg]\n\n"}
{"name":"LSeriesSummable_of_le_const_mul_rpow","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\nx : Real\ns : Complex\nhs : LT.lt x s.re\nh : Exists fun C => ∀ (n : Nat), Ne n 0 → LE.le (Norm.norm (f n)) (HMul.hMul C (HPow.hPow (↑n) (HSub.hSub x 1)))\n⊢ LSeriesSummable f s","decl":"/-- If `f n` is bounded in absolute value by a constant times `n^(x-1)` and `re s > x`,\nthen the `LSeries` of `f` is summable at `s`. -/\nlemma LSeriesSummable_of_le_const_mul_rpow {f : ℕ → ℂ} {x : ℝ} {s : ℂ} (hs : x < s.re)\n    (h : ∃ C, ∀ n ≠ 0, ‖f n‖ ≤ C * n ^ (x - 1)) :\n    LSeriesSummable f s := by\n  obtain ⟨C, hC⟩ := h\n  have hC₀ : 0 ≤ C := (norm_nonneg <| f 1).trans <| by simpa using hC 1 one_ne_zero\n  have hsum : Summable fun n : ℕ ↦ ‖(C : ℂ) / n ^ (s + (1 - x))‖ := by\n    simp_rw [div_eq_mul_inv, norm_mul, ← cpow_neg]\n    have hsx : -s.re + x - 1 < -1 := by linarith only [hs]\n    refine Summable.mul_left _ <|\n      Summable.of_norm_bounded_eventually_nat (fun n ↦ (n : ℝ) ^ (-s.re + x - 1)) ?_ ?_\n    · simpa\n    · simp only [norm_norm, Filter.eventually_atTop]\n      refine ⟨1, fun n hn ↦ le_of_eq ?_⟩\n      simp only [norm_natCast_cpow_of_pos hn, add_re, sub_re, neg_re, ofReal_re, one_re]\n      ring_nf\n  refine Summable.of_norm <| hsum.of_nonneg_of_le (fun _ ↦ norm_nonneg _) (fun n ↦ ?_)\n  rcases n.eq_zero_or_pos with rfl | hn\n  · simpa only [term_zero, norm_zero] using norm_nonneg _\n  have hn' : 0 < (n : ℝ) ^ s.re := Real.rpow_pos_of_pos (Nat.cast_pos.mpr hn) _\n  simp_rw [term_of_ne_zero hn.ne', norm_div, norm_natCast_cpow_of_pos hn, div_le_iff₀ hn',\n    norm_eq_abs (C : ℂ), abs_ofReal, _root_.abs_of_nonneg hC₀, div_eq_mul_inv, mul_assoc,\n    ← Real.rpow_neg <| Nat.cast_nonneg _, ← Real.rpow_add <| Nat.cast_pos.mpr hn]\n  simpa using hC n <| Nat.pos_iff_ne_zero.mp hn\n\n"}
{"name":"LSeriesSummable_of_isBigO_rpow","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\nx : Real\ns : Complex\nhs : LT.lt x s.re\nh : Asymptotics.IsBigO Filter.atTop f fun n => HPow.hPow (↑n) (HSub.hSub x 1)\n⊢ LSeriesSummable f s","decl":"open Filter Finset Real Nat in\n/-- If `f = O(n^(x-1))` and `re s > x`, then the `LSeries` of `f` is summable at `s`. -/\nlemma LSeriesSummable_of_isBigO_rpow {f : ℕ → ℂ} {x : ℝ} {s : ℂ} (hs : x < s.re)\n    (h : f =O[atTop] fun n ↦ (n : ℝ) ^ (x - 1)) :\n    LSeriesSummable f s := by\n  obtain ⟨C, hC⟩ := Asymptotics.isBigO_iff.mp h\n  obtain ⟨m, hm⟩ := eventually_atTop.mp hC\n  let C' := max C (max' (insert 0 (image (fun n : ℕ ↦ ‖f n‖ / (n : ℝ) ^ (x - 1)) (range m)))\n    (insert_nonempty 0 _))\n  have hC'₀ : 0 ≤ C' := (le_max' _ _ (mem_insert.mpr (Or.inl rfl))).trans <| le_max_right ..\n  have hCC' : C ≤ C' := le_max_left ..\n  refine LSeriesSummable_of_le_const_mul_rpow hs ⟨C', fun n hn₀ ↦ ?_⟩\n  rcases le_or_lt m n with hn | hn\n  · refine (hm n hn).trans ?_\n    have hn₀ : (0 : ℝ) ≤ n := cast_nonneg _\n    gcongr\n    rw [Real.norm_eq_abs, abs_rpow_of_nonneg hn₀, _root_.abs_of_nonneg hn₀]\n  · have hn' : 0 < n := Nat.pos_of_ne_zero hn₀\n    refine (div_le_iff₀ <| rpow_pos_of_pos (cast_pos.mpr hn') _).mp ?_\n    refine (le_max' _ _ <| mem_insert_of_mem ?_).trans <| le_max_right ..\n    exact mem_image.mpr ⟨n, mem_range.mpr hn, rfl⟩\n\n"}
{"name":"LSeriesSummable_of_bounded_of_one_lt_re","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\nm : Real\nh : ∀ (n : Nat), Ne n 0 → LE.le (Complex.abs (f n)) m\ns : Complex\nhs : LT.lt 1 s.re\n⊢ LSeriesSummable f s","decl":"/-- If `f` is bounded, then its `LSeries` is summable at `s` when `re s > 1`. -/\ntheorem LSeriesSummable_of_bounded_of_one_lt_re {f : ℕ → ℂ} {m : ℝ}\n    (h : ∀ n ≠ 0, Complex.abs (f n) ≤ m) {s : ℂ} (hs : 1 < s.re) :\n    LSeriesSummable f s :=\n  LSeriesSummable_of_le_const_mul_rpow hs ⟨m, fun n hn ↦ by simp [h n hn]⟩\n\n"}
{"name":"LSeriesSummable_of_bounded_of_one_lt_real","module":"Mathlib.NumberTheory.LSeries.Basic","initialProofState":"f : Nat → Complex\nm : Real\nh : ∀ (n : Nat), Ne n 0 → LE.le (Complex.abs (f n)) m\ns : Real\nhs : LT.lt 1 s\n⊢ LSeriesSummable f ↑s","decl":"/-- If `f` is bounded, then its `LSeries` is summable at `s : ℝ` when `s > 1`. -/\ntheorem LSeriesSummable_of_bounded_of_one_lt_real {f : ℕ → ℂ} {m : ℝ}\n    (h : ∀ n ≠ 0, Complex.abs (f n) ≤ m) {s : ℝ} (hs : 1 < s) :\n    LSeriesSummable f s :=\n  LSeriesSummable_of_bounded_of_one_lt_re h <| by simp [hs]\n"}
