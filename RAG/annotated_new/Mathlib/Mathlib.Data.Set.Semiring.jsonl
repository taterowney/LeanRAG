{"name":"SetSemiring.down_up","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\ns : Set α\n⊢ Eq (SetSemiring.down (Set.up s)) s","decl":"@[simp]\nprotected theorem down_up (s : Set α) : SetSemiring.down (Set.up s) = s :=\n  rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11036): dot notation no longer works\n"}
{"name":"SetSemiring.up_down","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\ns : SetSemiring α\n⊢ Eq (Set.up (SetSemiring.down s)) s","decl":"@[simp]\nprotected theorem up_down (s : SetSemiring α) : Set.up (SetSemiring.down s) = s :=\n  rfl\n\n-- TODO: These lemmas are not tagged `simp` because `Set.le_eq_subset` simplifies the LHS\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11036): dot notation no longer works\n"}
{"name":"SetSemiring.up_le_up","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Iff (LE.le (Set.up s) (Set.up t)) (HasSubset.Subset s t)","decl":"theorem up_le_up {s t : Set α} : Set.up s ≤ Set.up t ↔ s ⊆ t :=\n  Iff.rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11036): dot notation no longer works\n"}
{"name":"SetSemiring.up_lt_up","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Iff (LT.lt (Set.up s) (Set.up t)) (HasSSubset.SSubset s t)","decl":"theorem up_lt_up {s t : Set α} : Set.up s < Set.up t ↔ s ⊂ t :=\n  Iff.rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11036): dot notation no longer works\n"}
{"name":"SetSemiring.down_subset_down","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\ns t : SetSemiring α\n⊢ Iff (HasSubset.Subset (SetSemiring.down s) (SetSemiring.down t)) (LE.le s t)","decl":"@[simp]\ntheorem down_subset_down {s t : SetSemiring α} : SetSemiring.down s ⊆ SetSemiring.down t ↔ s ≤ t :=\n  Iff.rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11036): dot notation no longer works\n"}
{"name":"SetSemiring.down_ssubset_down","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\ns t : SetSemiring α\n⊢ Iff (HasSSubset.SSubset (SetSemiring.down s) (SetSemiring.down t)) (LT.lt s t)","decl":"@[simp]\ntheorem down_ssubset_down {s t : SetSemiring α} : SetSemiring.down s ⊂ SetSemiring.down t ↔ s < t :=\n  Iff.rfl\n\n"}
{"name":"SetSemiring.zero_def","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\n⊢ Eq 0 (Set.up EmptyCollection.emptyCollection)","decl":"theorem zero_def : (0 : SetSemiring α) = Set.up ∅ :=\n  rfl\n\n"}
{"name":"SetSemiring.down_zero","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\n⊢ Eq (SetSemiring.down 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem down_zero : down (0 : SetSemiring α) = ∅ :=\n  rfl\n\n"}
{"name":"Set.up_empty","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\n⊢ Eq (Set.up EmptyCollection.emptyCollection) 0","decl":"@[simp]\ntheorem _root_.Set.up_empty : Set.up (∅ : Set α) = 0 :=\n  rfl\n\n"}
{"name":"SetSemiring.add_def","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\ns t : SetSemiring α\n⊢ Eq (HAdd.hAdd s t) (Set.up (Union.union (SetSemiring.down s) (SetSemiring.down t)))","decl":"theorem add_def (s t : SetSemiring α) : s + t = up (down s ∪ down t) :=\n  rfl\n\n"}
{"name":"SetSemiring.down_add","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\ns t : SetSemiring α\n⊢ Eq (SetSemiring.down (HAdd.hAdd s t)) (Union.union (SetSemiring.down s) (SetSemiring.down t))","decl":"@[simp]\ntheorem down_add (s t : SetSemiring α) : down (s + t) = down s ∪ down t :=\n  rfl\n\n"}
{"name":"Set.up_union","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\ns t : Set α\n⊢ Eq (Set.up (Union.union s t)) (HAdd.hAdd (Set.up s) (Set.up t))","decl":"@[simp]\ntheorem _root_.Set.up_union (s t : Set α) : up (s ∪ t) = up s + up t :=\n  rfl\n\n/- Since addition on `SetSemiring` is commutative (it is set union), there is no need\nto also have the instance `AddRightMono (SetSemiring α)`. -/\n"}
{"name":"SetSemiring.addLeftMono","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\n⊢ AddLeftMono (SetSemiring α)","decl":"instance addLeftMono : AddLeftMono (SetSemiring α) :=\n  ⟨fun _ _ _ => union_subset_union_right _⟩\n\n"}
{"name":"SetSemiring.mul_def","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\ninst✝ : Mul α\ns t : SetSemiring α\n⊢ Eq (HMul.hMul s t) (Set.up (HMul.hMul (SetSemiring.down s) (SetSemiring.down t)))","decl":"theorem mul_def (s t : SetSemiring α) : s * t = up (down s * down t) :=\n  rfl\n\n"}
{"name":"SetSemiring.down_mul","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\ninst✝ : Mul α\ns t : SetSemiring α\n⊢ Eq (SetSemiring.down (HMul.hMul s t)) (HMul.hMul (SetSemiring.down s) (SetSemiring.down t))","decl":"@[simp]\ntheorem down_mul (s t : SetSemiring α) : down (s * t) = down s * down t :=\n  rfl\n\n"}
{"name":"Set.up_mul","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\ninst✝ : Mul α\ns t : Set α\n⊢ Eq (Set.up (HMul.hMul s t)) (HMul.hMul (Set.up s) (Set.up t))","decl":"@[simp]\ntheorem _root_.Set.up_mul (s t : Set α) : up (s * t) = up s * up t :=\n  rfl\n\n"}
{"name":"SetSemiring.instNoZeroDivisors","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\ninst✝ : Mul α\n⊢ NoZeroDivisors (SetSemiring α)","decl":"instance : NoZeroDivisors (SetSemiring α) :=\n  ⟨fun {a b} ab =>\n    a.eq_empty_or_nonempty.imp_right fun ha =>\n      b.eq_empty_or_nonempty.resolve_right fun hb =>\n        Nonempty.ne_empty ⟨_, mul_mem_mul ha.some_mem hb.some_mem⟩ ab⟩\n\n"}
{"name":"SetSemiring.mulLeftMono","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\ninst✝ : Mul α\n⊢ MulLeftMono (SetSemiring α)","decl":"instance mulLeftMono : MulLeftMono (SetSemiring α) :=\n  ⟨fun _ _ _ => mul_subset_mul_left⟩\n\n"}
{"name":"SetSemiring.mulRightMono","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\ninst✝ : Mul α\n⊢ MulRightMono (SetSemiring α)","decl":"instance mulRightMono : MulRightMono (SetSemiring α) :=\n  ⟨fun _ _ _ => mul_subset_mul_right⟩\n\n"}
{"name":"SetSemiring.one_def","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\ninst✝ : One α\n⊢ Eq 1 (Set.up 1)","decl":"theorem one_def : (1 : SetSemiring α) = Set.up 1 :=\n  rfl\n\n"}
{"name":"SetSemiring.down_one","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\ninst✝ : One α\n⊢ Eq (SetSemiring.down 1) 1","decl":"@[simp]\ntheorem down_one : down (1 : SetSemiring α) = 1 :=\n  rfl\n\n"}
{"name":"Set.up_one","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\ninst✝ : One α\n⊢ Eq (Set.up 1) 1","decl":"@[simp]\ntheorem _root_.Set.up_one : up (1 : Set α) = 1 :=\n  rfl\n\n"}
{"name":"SetSemiring.instCanonicallyOrderedAdd","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\n⊢ CanonicallyOrderedAdd (SetSemiring α)","decl":"instance : CanonicallyOrderedAdd (SetSemiring α) where\n  exists_add_of_le {_ b} ab := ⟨b, (union_eq_right.2 ab).symm⟩\n  le_self_add _ _ := subset_union_left\n\n"}
{"name":"SetSemiring.imageHom_def","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\nf : MonoidHom α β\ns : SetSemiring α\n⊢ Eq ((SetSemiring.imageHom f) s) (Set.up (Set.image (⇑f) (SetSemiring.down s)))","decl":"lemma imageHom_def [MulOneClass α] [MulOneClass β] (f : α →* β) (s : SetSemiring α) :\n    imageHom f s = up (image f (down s)) :=\n  rfl\n\n"}
{"name":"SetSemiring.down_imageHom","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\nf : MonoidHom α β\ns : SetSemiring α\n⊢ Eq (SetSemiring.down ((SetSemiring.imageHom f) s)) (Set.image (⇑f) (SetSemiring.down s))","decl":"@[simp]\nlemma down_imageHom [MulOneClass α] [MulOneClass β] (f : α →* β) (s : SetSemiring α) :\n    down (imageHom f s) = f '' down s :=\n  rfl\n\n"}
{"name":"Set.up_image","module":"Mathlib.Data.Set.Semiring","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MulOneClass α\ninst✝ : MulOneClass β\nf : MonoidHom α β\ns : Set α\n⊢ Eq (Set.up (Set.image (⇑f) s)) ((SetSemiring.imageHom f) (Set.up s))","decl":"@[simp]\nlemma _root_.Set.up_image [MulOneClass α] [MulOneClass β] (f : α →* β) (s : Set α) :\n    up (f '' s) = imageHom f (up s) :=\n  rfl\n\n"}
