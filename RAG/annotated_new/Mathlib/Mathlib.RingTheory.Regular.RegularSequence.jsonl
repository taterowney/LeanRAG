{"name":"Ideal.ofList_nil","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq (Ideal.ofList List.nil) Bot.bot","decl":"@[simp] lemma ofList_nil : (ofList [] : Ideal R) = ⊥ :=\n  have : { r | r ∈ [] } = ∅ := Set.eq_empty_of_forall_not_mem List.not_mem_nil\n  Eq.trans (congrArg span this) span_empty\n\n"}
{"name":"Ideal.ofList_append","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nrs₁ rs₂ : List R\n⊢ Eq (Ideal.ofList (HAppend.hAppend rs₁ rs₂)) (Max.max (Ideal.ofList rs₁) (Ideal.ofList rs₂))","decl":"@[simp] lemma ofList_append (rs₁ rs₂ : List R) :\n    ofList (rs₁ ++ rs₂) = ofList rs₁ ⊔ ofList rs₂ :=\n  have : { r | r ∈ rs₁ ++ rs₂ } = _ := Set.ext (fun _ => List.mem_append)\n  Eq.trans (congrArg span this) (span_union _ _)\n\n"}
{"name":"Ideal.ofList_singleton","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nr : R\n⊢ Eq (Ideal.ofList (List.cons r List.nil)) (Ideal.span (Singleton.singleton r))","decl":"lemma ofList_singleton (r : R) : ofList [r] = span {r} :=\n  congrArg span (Set.ext fun _ => List.mem_singleton)\n\n"}
{"name":"Ideal.ofList_cons","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nr : R\nrs : List R\n⊢ Eq (Ideal.ofList (List.cons r rs)) (Max.max (Ideal.span (Singleton.singleton r)) (Ideal.ofList rs))","decl":"@[simp] lemma ofList_cons (r : R) (rs : List R) :\n    ofList (r::rs) = span {r} ⊔ ofList rs :=\n  Eq.trans (ofList_append [r] rs) (congrArg (· ⊔ _) (ofList_singleton r))\n\n"}
{"name":"Ideal.map_ofList","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Semiring R\ninst✝ : Semiring S\nf : RingHom R S\nrs : List R\n⊢ Eq (Ideal.map f (Ideal.ofList rs)) (Ideal.ofList (List.map (⇑f) rs))","decl":"@[simp] lemma map_ofList (f : R →+* S) (rs : List R) :\n    map f (ofList rs) = ofList (rs.map f) :=\n  Eq.trans (map_span f { r | r ∈ rs }) <| congrArg span <|\n    Set.ext (fun _ => List.mem_map.symm)\n\n"}
{"name":"Ideal.ofList_cons_smul","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_7\ninst✝² : CommSemiring R\nr : R\nrs : List R\nM : Type u_8\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN : Submodule R M\n⊢ Eq (HSMul.hSMul (Ideal.ofList (List.cons r rs)) N) (Max.max (HSMul.hSMul r N) (HSMul.hSMul (Ideal.ofList rs) N))","decl":"lemma ofList_cons_smul {R} [CommSemiring R] (r : R) (rs : List R) {M}\n    [AddCommMonoid M] [Module R M] (N : Submodule R M) :\n    ofList (r :: rs) • N = r • N ⊔ ofList rs • N := by\n  rw [ofList_cons, Submodule.sup_smul, Submodule.ideal_span_singleton_smul]\n\n"}
{"name":"Submodule.smul_top_le_comap_smul_top","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\nM₂ : Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nI : Ideal R\nf : LinearMap (RingHom.id R) M M₂\n⊢ LE.le (HSMul.hSMul I Top.top) (Submodule.comap f (HSMul.hSMul I Top.top))","decl":"lemma smul_top_le_comap_smul_top [CommSemiring R] [AddCommMonoid M]\n    [AddCommMonoid M₂] [Module R M] [Module R M₂] (I : Ideal R)\n    (f : M →ₗ[R] M₂) : I • ⊤ ≤ comap f (I • ⊤) :=\n  map_le_iff_le_comap.mp <| le_of_eq_of_le (map_smul'' _ _ _) <|\n    smul_mono_right _ le_top\n\n"}
{"name":"Submodule.quotOfListConsSMulTopEquivQuotSMulTopInner_naturality","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\nM₂ : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\nr : R\nrs : List R\nf : LinearMap (RingHom.id R) M M₂\n⊢ Eq ((↑(Submodule.quotOfListConsSMulTopEquivQuotSMulTopInner M₂ r rs)).comp ((HSMul.hSMul (Ideal.ofList (List.cons r rs)) Top.top).mapQ (HSMul.hSMul (Ideal.ofList (List.cons r rs)) Top.top) f ⋯)) (((HSMul.hSMul (Ideal.ofList rs) Top.top).mapQ (HSMul.hSMul (Ideal.ofList rs) Top.top) ((QuotSMulTop.map r) f) ⋯).comp ↑(Submodule.quotOfListConsSMulTopEquivQuotSMulTopInner M r rs))","decl":"lemma quotOfListConsSMulTopEquivQuotSMulTopInner_naturality (f : M →ₗ[R] M₂) :\n    (quotOfListConsSMulTopEquivQuotSMulTopInner M₂ r rs).toLinearMap ∘ₗ\n        mapQ _ _ _ (smul_top_le_comap_smul_top (Ideal.ofList (r :: rs)) f) =\n      mapQ _ _ _ (smul_top_le_comap_smul_top _ (QuotSMulTop.map r f)) ∘ₗ\n        (quotOfListConsSMulTopEquivQuotSMulTopInner M r rs).toLinearMap :=\n  quot_hom_ext _ _ _ fun _ => rfl\n\n"}
{"name":"Submodule.top_eq_ofList_cons_smul_iff","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\nrs : List R\n⊢ Iff (Eq Top.top (HSMul.hSMul (Ideal.ofList (List.cons r rs)) Top.top)) (Eq Top.top (HSMul.hSMul (Ideal.ofList rs) Top.top))","decl":"lemma top_eq_ofList_cons_smul_iff :\n    (⊤ : Submodule R M) = Ideal.ofList (r :: rs) • ⊤ ↔\n      (⊤ : Submodule R (QuotSMulTop r M)) = Ideal.ofList rs • ⊤ := by\n  conv => congr <;> rw [eq_comm, ← subsingleton_quotient_iff_eq_top]\n  exact (quotOfListConsSMulTopEquivQuotSMulTopInner M r rs).toEquiv.subsingleton_congr\n\n"}
{"name":"RingTheory.Sequence.IsWeaklyRegular.regular_mod_prev","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nrs : List R\nself : RingTheory.Sequence.IsWeaklyRegular M rs\ni : Nat\nh : LT.lt i rs.length\n⊢ IsSMulRegular (HasQuotient.Quotient M (HSMul.hSMul (Ideal.ofList (List.take i rs)) Top.top)) (GetElem.getElem rs i ⋯)","decl":"/-- A sequence `[r₁, …, rₙ]` is weakly regular on `M` iff `rᵢ` is regular on\n`M⧸(r₁, …, rᵢ₋₁)M` for all `1 ≤ i ≤ n`. -/\n@[mk_iff]\nstructure IsWeaklyRegular (rs : List R) : Prop where\n  regular_mod_prev : ∀ i (h : i < rs.length),\n    IsSMulRegular (M ⧸ (ofList (rs.take i) • ⊤ : Submodule R M)) rs[i]\n\n"}
{"name":"RingTheory.Sequence.isWeaklyRegular_iff","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nrs : List R\n⊢ Iff (RingTheory.Sequence.IsWeaklyRegular M rs) (∀ (i : Nat), LT.lt i rs.length → IsSMulRegular (HasQuotient.Quotient M (HSMul.hSMul (Ideal.ofList (List.take i rs)) Top.top)) (GetElem.getElem rs i ⋯))","decl":"/-- A sequence `[r₁, …, rₙ]` is weakly regular on `M` iff `rᵢ` is regular on\n`M⧸(r₁, …, rᵢ₋₁)M` for all `1 ≤ i ≤ n`. -/\n@[mk_iff]\nstructure IsWeaklyRegular (rs : List R) : Prop where\n  regular_mod_prev : ∀ i (h : i < rs.length),\n    IsSMulRegular (M ⧸ (ofList (rs.take i) • ⊤ : Submodule R M)) rs[i]\n\n"}
{"name":"RingTheory.Sequence.isWeaklyRegular_iff_Fin","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nrs : List R\n⊢ Iff (RingTheory.Sequence.IsWeaklyRegular M rs) (∀ (i : Fin rs.length), IsSMulRegular (HasQuotient.Quotient M (HSMul.hSMul (Ideal.ofList (List.take (↑i) rs)) Top.top)) (GetElem.getElem rs i ⋯))","decl":"lemma isWeaklyRegular_iff_Fin (rs : List R) :\n    IsWeaklyRegular M rs ↔ ∀ (i : Fin rs.length),\n      IsSMulRegular (M ⧸ (ofList (rs.take i) • ⊤ : Submodule R M)) rs[i] :=\n  Iff.trans (isWeaklyRegular_iff M rs) (Iff.symm Fin.forall_iff)\n\n"}
{"name":"RingTheory.Sequence.IsRegular.toIsWeaklyRegular","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nrs : List R\nself : RingTheory.Sequence.IsRegular M rs\n⊢ RingTheory.Sequence.IsWeaklyRegular M rs","decl":"/-- A weakly regular sequence `rs` on `M` is regular if also `M/rsM ≠ 0`. -/\n@[mk_iff]\nstructure IsRegular (rs : List R) extends IsWeaklyRegular M rs : Prop where\n  top_ne_smul : (⊤ : Submodule R M) ≠ Ideal.ofList rs • ⊤\n\n"}
{"name":"RingTheory.Sequence.isRegular_iff","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nrs : List R\n⊢ Iff (RingTheory.Sequence.IsRegular M rs) (And (RingTheory.Sequence.IsWeaklyRegular M rs) (Ne Top.top (HSMul.hSMul (Ideal.ofList rs) Top.top)))","decl":"/-- A weakly regular sequence `rs` on `M` is regular if also `M/rsM ≠ 0`. -/\n@[mk_iff]\nstructure IsRegular (rs : List R) extends IsWeaklyRegular M rs : Prop where\n  top_ne_smul : (⊤ : Submodule R M) ≠ Ideal.ofList rs • ⊤\n\n"}
{"name":"RingTheory.Sequence.IsRegular.top_ne_smul","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nrs : List R\nself : RingTheory.Sequence.IsRegular M rs\n⊢ Ne Top.top (HSMul.hSMul (Ideal.ofList rs) Top.top)","decl":"/-- A weakly regular sequence `rs` on `M` is regular if also `M/rsM ≠ 0`. -/\n@[mk_iff]\nstructure IsRegular (rs : List R) extends IsWeaklyRegular M rs : Prop where\n  top_ne_smul : (⊤ : Submodule R M) ≠ Ideal.ofList rs • ⊤\n\n"}
{"name":"AddEquiv.isWeaklyRegular_congr","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nM₂ : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M\ninst✝ : Module S M₂\ne : AddEquiv M M₂\nas : List R\nbs : List S\nh : List.Forall₂ (fun r s => ∀ (x : M), Eq (e (HSMul.hSMul r x)) (HSMul.hSMul s (e x))) as bs\n⊢ Iff (RingTheory.Sequence.IsWeaklyRegular M as) (RingTheory.Sequence.IsWeaklyRegular M₂ bs)","decl":"lemma _root_.AddEquiv.isWeaklyRegular_congr {e : M ≃+ M₂} {as bs}\n    (h : List.Forall₂ (fun (r : R) (s : S) => ∀ x, e (r • x) = s • e x) as bs) :\n    IsWeaklyRegular M as ↔ IsWeaklyRegular M₂ bs := by\n  conv => congr <;> rw [isWeaklyRegular_iff_Fin]\n  let e' i : (M ⧸ (Ideal.ofList (as.take i) • ⊤ : Submodule R M)) ≃+\n      M₂ ⧸ (Ideal.ofList (bs.take i) • ⊤ : Submodule S M₂) :=\n    QuotientAddGroup.congr _ _ e <|\n      AddHom.map_smul_top_toAddSubgroup_of_surjective e.surjective <|\n        List.forall₂_take i h\n  refine (finCongr h.length_eq).forall_congr @fun _ => (e' _).isSMulRegular_congr ?_\n  exact (mkQ_surjective _).forall.mpr fun _ => congrArg (mkQ _) (h.get _ _ _)\n\n"}
{"name":"LinearEquiv.isWeaklyRegular_congr'","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nM₂ : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : Module R M\ninst✝² : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\ninst✝¹ : RingHomInvPair σ σ'\ninst✝ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\nrs : List R\n⊢ Iff (RingTheory.Sequence.IsWeaklyRegular M rs) (RingTheory.Sequence.IsWeaklyRegular M₂ (List.map (⇑σ) rs))","decl":"lemma _root_.LinearEquiv.isWeaklyRegular_congr' (e : M ≃ₛₗ[σ] M₂) (rs : List R) :\n    IsWeaklyRegular M rs ↔ IsWeaklyRegular M₂ (rs.map σ) :=\n  e.toAddEquiv.isWeaklyRegular_congr <| List.forall₂_map_right_iff.mpr <|\n    List.forall₂_same.mpr fun r _ x => e.map_smul' r x\n\n"}
{"name":"LinearEquiv.isWeaklyRegular_congr","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\nM₂ : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\ne : LinearEquiv (RingHom.id R) M M₂\nrs : List R\n⊢ Iff (RingTheory.Sequence.IsWeaklyRegular M rs) (RingTheory.Sequence.IsWeaklyRegular M₂ rs)","decl":"lemma _root_.LinearEquiv.isWeaklyRegular_congr [Module R M₂] (e : M ≃ₗ[R] M₂) (rs : List R) :\n    IsWeaklyRegular M rs ↔ IsWeaklyRegular M₂ rs :=\n  Iff.trans (e.isWeaklyRegular_congr' rs) <| iff_of_eq <| congrArg _ rs.map_id\n\n"}
{"name":"AddEquiv.isRegular_congr","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nM₂ : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M\ninst✝ : Module S M₂\ne : AddEquiv M M₂\nas : List R\nbs : List S\nh : List.Forall₂ (fun r s => ∀ (x : M), Eq (e (HSMul.hSMul r x)) (HSMul.hSMul s (e x))) as bs\n⊢ Iff (RingTheory.Sequence.IsRegular M as) (RingTheory.Sequence.IsRegular M₂ bs)","decl":"lemma _root_.AddEquiv.isRegular_congr {e : M ≃+ M₂} {as bs}\n    (h : List.Forall₂ (fun (r : R) (s : S) => ∀ x, e (r • x) = s • e x) as bs) :\n    IsRegular M as ↔ IsRegular M₂ bs := by\n  conv => congr <;> rw [isRegular_iff, ne_eq, eq_comm,\n    ← subsingleton_quotient_iff_eq_top]\n  let e' := QuotientAddGroup.congr _ _ e <|\n    AddHom.map_smul_top_toAddSubgroup_of_surjective e.surjective h\n  exact and_congr (e.isWeaklyRegular_congr h) e'.subsingleton_congr.not\n\n"}
{"name":"LinearEquiv.isRegular_congr'","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nM₂ : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : AddCommGroup M₂\ninst✝³ : Module R M\ninst✝² : Module S M₂\nσ : RingHom R S\nσ' : RingHom S R\ninst✝¹ : RingHomInvPair σ σ'\ninst✝ : RingHomInvPair σ' σ\ne : LinearEquiv σ M M₂\nrs : List R\n⊢ Iff (RingTheory.Sequence.IsRegular M rs) (RingTheory.Sequence.IsRegular M₂ (List.map (⇑σ) rs))","decl":"lemma _root_.LinearEquiv.isRegular_congr' (e : M ≃ₛₗ[σ] M₂) (rs : List R) :\n    IsRegular M rs ↔ IsRegular M₂ (rs.map σ) :=\n  e.toAddEquiv.isRegular_congr <| List.forall₂_map_right_iff.mpr <|\n    List.forall₂_same.mpr fun r _ x => e.map_smul' r x\n\n"}
{"name":"LinearEquiv.isRegular_congr","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\nM₂ : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup M₂\ninst✝¹ : Module R M\ninst✝ : Module R M₂\ne : LinearEquiv (RingHom.id R) M M₂\nrs : List R\n⊢ Iff (RingTheory.Sequence.IsRegular M rs) (RingTheory.Sequence.IsRegular M₂ rs)","decl":"lemma _root_.LinearEquiv.isRegular_congr [Module R M₂] (e : M ≃ₗ[R] M₂) (rs : List R) :\n    IsRegular M rs ↔ IsRegular M₂ rs :=\n  Iff.trans (e.isRegular_congr' rs) <| iff_of_eq <| congrArg _ rs.map_id\n\n"}
{"name":"RingTheory.Sequence.isWeaklyRegular_map_algebraMap_iff","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nrs : List R\n⊢ Iff (RingTheory.Sequence.IsWeaklyRegular M (List.map (⇑(algebraMap R S)) rs)) (RingTheory.Sequence.IsWeaklyRegular M rs)","decl":"lemma isWeaklyRegular_map_algebraMap_iff [CommRing R] [CommRing S]\n    [Algebra R S] [AddCommGroup M] [Module R M] [Module S M]\n    [IsScalarTower R S M] (rs : List R) :\n    IsWeaklyRegular M (rs.map (algebraMap R S)) ↔ IsWeaklyRegular M rs :=\n  (AddEquiv.refl M).isWeaklyRegular_congr <| List.forall₂_map_left_iff.mpr <|\n    List.forall₂_same.mpr fun r _ => algebraMap_smul S r\n\n"}
{"name":"RingTheory.Sequence.isWeaklyRegular_cons_iff","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\nrs : List R\n⊢ Iff (RingTheory.Sequence.IsWeaklyRegular M (List.cons r rs)) (And (IsSMulRegular M r) (RingTheory.Sequence.IsWeaklyRegular (QuotSMulTop r M) rs))","decl":"@[simp]\nlemma isWeaklyRegular_cons_iff (r : R) (rs : List R) :\n    IsWeaklyRegular M (r :: rs) ↔\n      IsSMulRegular M r ∧ IsWeaklyRegular (QuotSMulTop r M) rs :=\n  have := Eq.trans (congrArg (· • ⊤) Ideal.ofList_nil) (bot_smul ⊤)\n  let e i := quotOfListConsSMulTopEquivQuotSMulTopInner M r (rs.take i)\n  Iff.trans (isWeaklyRegular_iff_Fin _ _) <| Iff.trans Fin.forall_iff_succ <|\n    and_congr ((quotEquivOfEqBot _ this).isSMulRegular_congr r) <|\n      Iff.trans (forall_congr' fun i => (e i).isSMulRegular_congr (rs.get i))\n        (isWeaklyRegular_iff_Fin _ _).symm\n\n"}
{"name":"RingTheory.Sequence.isWeaklyRegular_cons_iff'","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\nrs : List R\n⊢ Iff (RingTheory.Sequence.IsWeaklyRegular M (List.cons r rs)) (And (IsSMulRegular M r) (RingTheory.Sequence.IsWeaklyRegular (QuotSMulTop r M) (List.map (⇑(Ideal.Quotient.mk (Ideal.span (Singleton.singleton r)))) rs)))","decl":"lemma isWeaklyRegular_cons_iff' (r : R) (rs : List R) :\n    IsWeaklyRegular M (r :: rs) ↔\n      IsSMulRegular M r ∧\n        IsWeaklyRegular (QuotSMulTop r M)\n          (rs.map (Ideal.Quotient.mk (Ideal.span {r}))) :=\n  Iff.trans (isWeaklyRegular_cons_iff M r rs) <| and_congr_right' <|\n    Iff.symm <| isWeaklyRegular_map_algebraMap_iff (R ⧸ Ideal.span {r}) _ rs\n\n"}
{"name":"RingTheory.Sequence.isRegular_cons_iff","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\nrs : List R\n⊢ Iff (RingTheory.Sequence.IsRegular M (List.cons r rs)) (And (IsSMulRegular M r) (RingTheory.Sequence.IsRegular (QuotSMulTop r M) rs))","decl":"@[simp]\nlemma isRegular_cons_iff (r : R) (rs : List R) :\n    IsRegular M (r :: rs) ↔\n      IsSMulRegular M r ∧ IsRegular (QuotSMulTop r M) rs := by\n  rw [isRegular_iff, isRegular_iff, isWeaklyRegular_cons_iff M r rs,\n    ne_eq, top_eq_ofList_cons_smul_iff, and_assoc]\n\n"}
{"name":"RingTheory.Sequence.isRegular_cons_iff'","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\nrs : List R\n⊢ Iff (RingTheory.Sequence.IsRegular M (List.cons r rs)) (And (IsSMulRegular M r) (RingTheory.Sequence.IsRegular (QuotSMulTop r M) (List.map (⇑(Ideal.Quotient.mk (Ideal.span (Singleton.singleton r)))) rs)))","decl":"lemma isRegular_cons_iff' (r : R) (rs : List R) :\n    IsRegular M (r :: rs) ↔\n      IsSMulRegular M r ∧ IsRegular (QuotSMulTop r M)\n          (rs.map (Ideal.Quotient.mk (Ideal.span {r}))) := by\n  conv => congr <;> rw [isRegular_iff, ne_eq]\n  rw [isWeaklyRegular_cons_iff', ← restrictScalars_inj R (R ⧸ _),\n    ← Ideal.map_ofList, ← Ideal.Quotient.algebraMap_eq, Ideal.smul_restrictScalars,\n    restrictScalars_top, top_eq_ofList_cons_smul_iff, and_assoc]\n\n"}
{"name":"RingTheory.Sequence.IsWeaklyRegular.nil","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ RingTheory.Sequence.IsWeaklyRegular M List.nil","decl":"variable (R M) in\n@[simp] lemma nil : IsWeaklyRegular M ([] : List R) :=\n  .mk (False.elim <| Nat.not_lt_zero · ·)\n\n"}
{"name":"RingTheory.Sequence.IsWeaklyRegular.cons","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\nrs : List R\nh1 : IsSMulRegular M r\nh2 : RingTheory.Sequence.IsWeaklyRegular (QuotSMulTop r M) rs\n⊢ RingTheory.Sequence.IsWeaklyRegular M (List.cons r rs)","decl":"lemma cons {r : R} {rs : List R} (h1 : IsSMulRegular M r)\n    (h2 : IsWeaklyRegular (QuotSMulTop r M) rs) : IsWeaklyRegular M (r :: rs) :=\n  (isWeaklyRegular_cons_iff M r rs).mpr ⟨h1, h2⟩\n\n"}
{"name":"RingTheory.Sequence.IsWeaklyRegular.cons'","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\nrs : List R\nh1 : IsSMulRegular M r\nh2 : RingTheory.Sequence.IsWeaklyRegular (QuotSMulTop r M) (List.map (⇑(Ideal.Quotient.mk (Ideal.span (Singleton.singleton r)))) rs)\n⊢ RingTheory.Sequence.IsWeaklyRegular M (List.cons r rs)","decl":"lemma cons' {r : R} {rs : List R} (h1 : IsSMulRegular M r)\n    (h2 : IsWeaklyRegular (QuotSMulTop r M)\n            (rs.map (Ideal.Quotient.mk (Ideal.span {r})))) :\n    IsWeaklyRegular M (r :: rs) :=\n  (isWeaklyRegular_cons_iff' M r rs).mpr ⟨h1, h2⟩\n\n"}
{"name":"RingTheory.Sequence.isWeaklyRegular_singleton_iff","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\n⊢ Iff (RingTheory.Sequence.IsWeaklyRegular M (List.cons r List.nil)) (IsSMulRegular M r)","decl":"lemma isWeaklyRegular_singleton_iff (r : R) :\n    IsWeaklyRegular M [r] ↔ IsSMulRegular M r :=\n  Iff.trans (isWeaklyRegular_cons_iff M r []) (and_iff_left (.nil R _))\n\n"}
{"name":"RingTheory.Sequence.isWeaklyRegular_append_iff","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nrs₁ rs₂ : List R\n⊢ Iff (RingTheory.Sequence.IsWeaklyRegular M (HAppend.hAppend rs₁ rs₂)) (And (RingTheory.Sequence.IsWeaklyRegular M rs₁) (RingTheory.Sequence.IsWeaklyRegular (HasQuotient.Quotient M (HSMul.hSMul (Ideal.ofList rs₁) Top.top)) rs₂))","decl":"lemma isWeaklyRegular_append_iff (rs₁ rs₂ : List R) :\n    IsWeaklyRegular M (rs₁ ++ rs₂) ↔\n      IsWeaklyRegular M rs₁ ∧\n        IsWeaklyRegular (M ⧸ (Ideal.ofList rs₁ • ⊤ : Submodule R M)) rs₂ := by\n  induction rs₁ generalizing M with\n  | nil =>\n    refine Iff.symm <| Iff.trans (and_iff_right (.nil R M)) ?_\n    refine (quotEquivOfEqBot _ ?_).isWeaklyRegular_congr rs₂\n    rw [Ideal.ofList_nil, bot_smul]\n  | cons r rs₁ ih =>\n    let e := quotOfListConsSMulTopEquivQuotSMulTopInner M r rs₁\n    rw [List.cons_append, isWeaklyRegular_cons_iff, isWeaklyRegular_cons_iff,\n      ih, ← and_assoc, ← e.isWeaklyRegular_congr rs₂]\n\n"}
{"name":"RingTheory.Sequence.isWeaklyRegular_append_iff'","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nrs₁ rs₂ : List R\n⊢ Iff (RingTheory.Sequence.IsWeaklyRegular M (HAppend.hAppend rs₁ rs₂)) (And (RingTheory.Sequence.IsWeaklyRegular M rs₁) (RingTheory.Sequence.IsWeaklyRegular (HasQuotient.Quotient M (HSMul.hSMul (Ideal.ofList rs₁) Top.top)) (List.map (⇑(Ideal.Quotient.mk (Ideal.ofList rs₁))) rs₂)))","decl":"lemma isWeaklyRegular_append_iff' (rs₁ rs₂ : List R) :\n    IsWeaklyRegular M (rs₁ ++ rs₂) ↔\n      IsWeaklyRegular M rs₁ ∧\n        IsWeaklyRegular (M ⧸ (Ideal.ofList rs₁ • ⊤ : Submodule R M))\n          (rs₂.map (Ideal.Quotient.mk (Ideal.ofList rs₁))) :=\n  Iff.trans (isWeaklyRegular_append_iff M rs₁ rs₂) <| and_congr_right' <|\n    Iff.symm <| isWeaklyRegular_map_algebraMap_iff (R ⧸ Ideal.ofList rs₁) _ rs₂\n\n"}
{"name":"RingTheory.Sequence.IsRegular.nil","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Nontrivial M\n⊢ RingTheory.Sequence.IsRegular M List.nil","decl":"variable (R M) in\nlemma nil [Nontrivial M] : IsRegular M ([] : List R) where\n  toIsWeaklyRegular := IsWeaklyRegular.nil R M\n  top_ne_smul h := by\n    rw [Ideal.ofList_nil, bot_smul, eq_comm, subsingleton_iff_bot_eq_top] at h\n    exact not_subsingleton M ((Submodule.subsingleton_iff _).mp h)\n\n"}
{"name":"RingTheory.Sequence.IsRegular.cons","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\nrs : List R\nh1 : IsSMulRegular M r\nh2 : RingTheory.Sequence.IsRegular (QuotSMulTop r M) rs\n⊢ RingTheory.Sequence.IsRegular M (List.cons r rs)","decl":"lemma cons {r : R} {rs : List R} (h1 : IsSMulRegular M r)\n    (h2 : IsRegular (QuotSMulTop r M) rs) : IsRegular M (r :: rs) :=\n  (isRegular_cons_iff M r rs).mpr ⟨h1, h2⟩\n\n"}
{"name":"RingTheory.Sequence.IsRegular.cons'","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nr : R\nrs : List R\nh1 : IsSMulRegular M r\nh2 : RingTheory.Sequence.IsRegular (QuotSMulTop r M) (List.map (⇑(Ideal.Quotient.mk (Ideal.span (Singleton.singleton r)))) rs)\n⊢ RingTheory.Sequence.IsRegular M (List.cons r rs)","decl":"lemma cons' {r : R} {rs : List R} (h1 : IsSMulRegular M r)\n    (h2 : IsRegular (QuotSMulTop r M) (rs.map (Ideal.Quotient.mk (Ideal.span {r})))) :\n    IsRegular M (r :: rs) :=\n  (isRegular_cons_iff' M r rs).mpr ⟨h1, h2⟩\n\n"}
{"name":"RingTheory.Sequence.IsRegular.quot_ofList_smul_nontrivial","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nrs : List R\nh : RingTheory.Sequence.IsRegular M rs\nN : Submodule R M\n⊢ Nontrivial (HasQuotient.Quotient M (HSMul.hSMul (Ideal.ofList rs) N))","decl":"lemma quot_ofList_smul_nontrivial {rs : List R} (h : IsRegular M rs)\n    (N : Submodule R M) : Nontrivial (M ⧸ Ideal.ofList rs • N) :=\n  Submodule.Quotient.nontrivial_of_lt_top _ <|\n    lt_of_le_of_lt (smul_mono_right _ le_top) h.top_ne_smul.symm.lt_top\n\n"}
{"name":"RingTheory.Sequence.IsRegular.nontrivial","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nrs : List R\nh : RingTheory.Sequence.IsRegular M rs\n⊢ Nontrivial M","decl":"lemma nontrivial {rs : List R} (h : IsRegular M rs) : Nontrivial M :=\n  haveI := quot_ofList_smul_nontrivial h ⊤\n  (mkQ_surjective (Ideal.ofList rs • ⊤ : Submodule R M)).nontrivial\n\n"}
{"name":"RingTheory.Sequence.isRegular_iff_isWeaklyRegular_of_subset_jacobson_annihilator","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Nontrivial M\ninst✝ : Module.Finite R M\nrs : List R\nh : ∀ (r : R), Membership.mem rs r → Membership.mem (Module.annihilator R M).jacobson r\n⊢ Iff (RingTheory.Sequence.IsRegular M rs) (RingTheory.Sequence.IsWeaklyRegular M rs)","decl":"lemma isRegular_iff_isWeaklyRegular_of_subset_jacobson_annihilator\n    [Nontrivial M] [Module.Finite R M] {rs : List R}\n    (h : ∀ r ∈ rs, r ∈ Ideal.jacobson (Module.annihilator R M)) :\n    IsRegular M rs ↔ IsWeaklyRegular M rs :=\n  Iff.trans (isRegular_iff M rs) <| and_iff_left <|\n    top_ne_ideal_smul_of_le_jacobson_annihilator <| Ideal.span_le.mpr h\n\n"}
{"name":"IsLocalRing.isRegular_iff_isWeaklyRegular_of_subset_maximalIdeal","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : IsLocalRing R\ninst✝¹ : Nontrivial M\ninst✝ : Module.Finite R M\nrs : List R\nh : ∀ (r : R), Membership.mem rs r → Membership.mem (IsLocalRing.maximalIdeal R) r\n⊢ Iff (RingTheory.Sequence.IsRegular M rs) (RingTheory.Sequence.IsWeaklyRegular M rs)","decl":"lemma _root_.IsLocalRing.isRegular_iff_isWeaklyRegular_of_subset_maximalIdeal\n    [IsLocalRing R] [Nontrivial M] [Module.Finite R M] {rs : List R}\n    (h : ∀ r ∈ rs, r ∈ IsLocalRing.maximalIdeal R) :\n    IsRegular M rs ↔ IsWeaklyRegular M rs :=\n  have H h' := bot_ne_top.symm <| annihilator_eq_top_iff.mp <|\n    Eq.trans annihilator_top h'\n  isRegular_iff_isWeaklyRegular_of_subset_jacobson_annihilator fun r hr =>\n    IsLocalRing.jacobson_eq_maximalIdeal (Module.annihilator R M) H ▸ h r hr\n\n"}
{"name":"RingTheory.Sequence.eq_nil_of_isRegular_on_artinian","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsArtinian R M\nrs : List R\na✝ : RingTheory.Sequence.IsRegular M rs\n⊢ Eq rs List.nil","decl":"open IsWeaklyRegular IsArtinian in\nlemma eq_nil_of_isRegular_on_artinian [IsArtinian R M] :\n    {rs : List R} → IsRegular M rs → rs = []\n  | [], _ => rfl\n  | r :: rs, h => by\n    rw [isRegular_iff, ne_comm, ← lt_top_iff_ne_top, Ideal.ofList_cons,\n      sup_smul, ideal_span_singleton_smul, isWeaklyRegular_cons_iff] at h\n    refine absurd ?_ (ne_of_lt (lt_of_le_of_lt le_sup_left h.right))\n    exact Eq.trans (Submodule.map_top _) <| LinearMap.range_eq_top.mpr <|\n      surjective_of_injective_endomorphism (LinearMap.lsmul R M r) h.left.left\n\n"}
{"name":"RingTheory.Sequence.IsWeaklyRegular.isWeaklyRegular_lTensor","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\nM₂ : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module.Flat R M₂\nrs : List R\nh : RingTheory.Sequence.IsWeaklyRegular M rs\n⊢ RingTheory.Sequence.IsWeaklyRegular (TensorProduct R M₂ M) rs","decl":"lemma IsWeaklyRegular.isWeaklyRegular_lTensor [Module.Flat R M₂]\n    {rs : List R} (h : IsWeaklyRegular M rs) :\n    IsWeaklyRegular (M₂ ⊗[R] M) rs := by\n  induction h with\n  | nil N => exact nil R (M₂ ⊗[R] N)\n  | @cons N _ _ r rs' h1 _ ih =>\n    let e := tensorQuotSMulTopEquivQuotSMulTop r M₂ N\n    exact ((e.isWeaklyRegular_congr rs').mp ih).cons (h1.lTensor M₂)\n\n"}
{"name":"RingTheory.Sequence.IsWeaklyRegular.isWeaklyRegular_rTensor","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\nM₂ : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup M₂\ninst✝² : Module R M\ninst✝¹ : Module R M₂\ninst✝ : Module.Flat R M₂\nrs : List R\nh : RingTheory.Sequence.IsWeaklyRegular M rs\n⊢ RingTheory.Sequence.IsWeaklyRegular (TensorProduct R M M₂) rs","decl":"lemma IsWeaklyRegular.isWeaklyRegular_rTensor [Module.Flat R M₂]\n    {rs : List R} (h : IsWeaklyRegular M rs) :\n    IsWeaklyRegular (M ⊗[R] M₂) rs := by\n  induction h with\n  | nil N => exact nil R (N ⊗[R] M₂)\n  | @cons N _ _ r rs' h1 _ ih =>\n    let e := quotSMulTopTensorEquivQuotSMulTop r M₂ N\n    exact ((e.isWeaklyRegular_congr rs').mp ih).cons (h1.rTensor M₂)\n-- TODO: apply the above to localization and completion (Corollary 1.1.3 in B&H)\n\n"}
{"name":"RingTheory.Sequence.map_first_exact_on_four_term_right_exact_of_isSMulRegular_last","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\nM₂ : Type u_4\nM₃ : Type u_5\nM₄ : Type u_6\ninst✝⁸ : CommRing R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup M₂\ninst✝⁵ : AddCommGroup M₃\ninst✝⁴ : AddCommGroup M₄\ninst✝³ : Module R M\ninst✝² : Module R M₂\ninst✝¹ : Module R M₃\ninst✝ : Module R M₄\nrs : List R\nf₁ : LinearMap (RingHom.id R) M M₂\nf₂ : LinearMap (RingHom.id R) M₂ M₃\nf₃ : LinearMap (RingHom.id R) M₃ M₄\nh₁₂ : Function.Exact ⇑f₁ ⇑f₂\nh₂₃ : Function.Exact ⇑f₂ ⇑f₃\nh₃ : Function.Surjective ⇑f₃\nh₄ : RingTheory.Sequence.IsWeaklyRegular M₄ rs\n⊢ Function.Exact ⇑((HSMul.hSMul (Ideal.ofList rs) Top.top).mapQ (HSMul.hSMul (Ideal.ofList rs) Top.top) f₁ ⋯) ⇑((HSMul.hSMul (Ideal.ofList rs) Top.top).mapQ (HSMul.hSMul (Ideal.ofList rs) Top.top) f₂ ⋯)","decl":"lemma map_first_exact_on_four_term_right_exact_of_isSMulRegular_last\n    {rs : List R} {f₁ : M →ₗ[R] M₂} {f₂ : M₂ →ₗ[R] M₃} {f₃ : M₃ →ₗ[R] M₄}\n    (h₁₂ : Exact f₁ f₂) (h₂₃ : Exact f₂ f₃) (h₃ : Surjective f₃)\n    (h₄ : IsWeaklyRegular M₄ rs) :\n    Exact (mapQ _ _ _ (smul_top_le_comap_smul_top (Ideal.ofList rs) f₁))\n          (mapQ _ _ _ (smul_top_le_comap_smul_top (Ideal.ofList rs) f₂)) := by\n  induction h₄ generalizing M M₂ M₃ with\n  | nil =>\n    apply (Exact.iff_of_ladder_linearEquiv ?_ ?_).mp h₁₂\n    any_goals exact quotEquivOfEqBot _ <|\n      Eq.trans (congrArg (· • ⊤) Ideal.ofList_nil) (bot_smul ⊤)\n    all_goals exact quot_hom_ext _ _ _ fun _ => rfl\n  | cons r rs h₄ _ ih =>\n    specialize ih\n      (map_first_exact_on_four_term_exact_of_isSMulRegular_last h₁₂ h₂₃ h₄)\n      (map_exact r h₂₃ h₃) (map_surjective r h₃)\n    have H₁ := quotOfListConsSMulTopEquivQuotSMulTopInner_naturality r rs f₁\n    have H₂ := quotOfListConsSMulTopEquivQuotSMulTopInner_naturality r rs f₂\n    exact (Exact.iff_of_ladder_linearEquiv H₁.symm H₂.symm).mp ih\n\n-- todo: modding out a complex by a regular sequence (prop 1.1.5 in B&H)\n\n"}
{"name":"RingTheory.Sequence.IsWeaklyRegular.prototype_perm","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nrs : List R\nh : RingTheory.Sequence.IsWeaklyRegular M rs\nrs' : List R\nh'' : rs.Perm rs'\nh' :\n  ∀ (a b : R) (rs' : List R),\n    (List.cons a (List.cons b rs')).Subperm rs →\n      let K := Submodule.torsionBy R (HasQuotient.Quotient M (HSMul.hSMul (Ideal.ofList rs') Top.top)) b;\n      Eq K (HSMul.hSMul a K) → Eq K Bot.bot\n⊢ RingTheory.Sequence.IsWeaklyRegular M rs'","decl":"set_option linter.unusedVariables false in\nlemma IsWeaklyRegular.prototype_perm {rs : List R} (h : IsWeaklyRegular M rs)\n    {rs'} (h'' : rs ~ rs') (h' : ∀ a b rs', (a :: b :: rs') <+~ rs →\n      let K := torsionBy R (M ⧸ (Ideal.ofList rs' • ⊤ : Submodule R M)) b\n      K = a • K → K = ⊥) : IsWeaklyRegular M rs' :=\n  have H := LinearEquiv.isWeaklyRegular_congr <| quotEquivOfEqBot _ <|\n    Eq.trans (congrArg (· • ⊤) Ideal.ofList_nil) (bot_smul ⊤)\n  (H rs').mp <| (aux [] h'' (.refl rs) (h''.symm.subperm)) <| (H rs).mpr h\n  where aux {rs₁ rs₂} (rs₀ : List R)\n    (h₁₂ : rs₁ ~ rs₂) (H₁ : rs₀ ++ rs₁ <+~ rs) (H₃ : rs₀ ++ rs₂ <+~ rs)\n    (h : IsWeaklyRegular (M ⧸ (Ideal.ofList rs₀ • ⊤ : Submodule R M)) rs₁) :\n    IsWeaklyRegular (M ⧸ (Ideal.ofList rs₀ • ⊤ : Submodule R M)) rs₂ := by {\n  induction h₁₂ generalizing rs₀ with\n  | nil => exact .nil R _\n  | cons r _ ih =>\n    let e := quotOfListConsSMulTopEquivQuotSMulTopOuter M r rs₀\n    rw [isWeaklyRegular_cons_iff, ← e.isWeaklyRegular_congr] at h ⊢\n    refine h.imp_right (ih (r :: rs₀) ?_ ?_) <;>\n      exact List.perm_middle.subperm_right.mp ‹_›\n  | swap a b t =>\n    rw [show ∀ x y z, x :: y :: z = [x, y] ++ z from fun _ _ _ => rfl,\n      isWeaklyRegular_append_iff] at h ⊢\n    have : Ideal.ofList [b, a] = Ideal.ofList [a, b] :=\n      congrArg Ideal.span <| Set.ext fun _ => (List.Perm.swap a b []).mem_iff\n    rw [(quotEquivOfEq _ _ (congrArg₂ _ this rfl)).isWeaklyRegular_congr] at h\n    rw [List.append_cons, List.append_cons, List.append_assoc _ [b] [a]] at H₁\n    apply (List.sublist_append_left (rs₀ ++ [b, a]) _).subperm.trans at H₁\n    apply List.perm_append_comm.subperm.trans at H₁\n    exact h.imp_left (swap · (h' b a rs₀ H₁))\n  | trans h₁₂ _ ih₁₂ ih₂₃ =>\n    have H₂ := (h₁₂.append_left rs₀).subperm_right.mp H₁\n    exact ih₂₃ rs₀ H₂ H₃ (ih₁₂ rs₀ H₁ H₂ h) }\n\n-- putting `{rs' : List R}` and `h2` after `h3` would be better for partial\n-- application, but this argument order seems nicer overall\n"}
{"name":"RingTheory.Sequence.IsWeaklyRegular.prototype_perm.aux","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nrs rs₁ rs₂ rs₀ : List R\nh₁₂ : rs₁.Perm rs₂\nH₁ : (HAppend.hAppend rs₀ rs₁).Subperm rs\nH₃ : (HAppend.hAppend rs₀ rs₂).Subperm rs\nh : RingTheory.Sequence.IsWeaklyRegular (HasQuotient.Quotient M (HSMul.hSMul (Ideal.ofList rs₀) Top.top)) rs₁\n⊢ RingTheory.Sequence.IsWeaklyRegular (HasQuotient.Quotient M (HSMul.hSMul (Ideal.ofList rs₀) Top.top)) rs₂","decl":"set_option linter.unusedVariables false in\nlemma IsWeaklyRegular.prototype_perm {rs : List R} (h : IsWeaklyRegular M rs)\n    {rs'} (h'' : rs ~ rs') (h' : ∀ a b rs', (a :: b :: rs') <+~ rs →\n      let K := torsionBy R (M ⧸ (Ideal.ofList rs' • ⊤ : Submodule R M)) b\n      K = a • K → K = ⊥) : IsWeaklyRegular M rs' :=\n  have H := LinearEquiv.isWeaklyRegular_congr <| quotEquivOfEqBot _ <|\n    Eq.trans (congrArg (· • ⊤) Ideal.ofList_nil) (bot_smul ⊤)\n  (H rs').mp <| (aux [] h'' (.refl rs) (h''.symm.subperm)) <| (H rs).mpr h\n  where aux {rs₁ rs₂} (rs₀ : List R)\n    (h₁₂ : rs₁ ~ rs₂) (H₁ : rs₀ ++ rs₁ <+~ rs) (H₃ : rs₀ ++ rs₂ <+~ rs)\n    (h : IsWeaklyRegular (M ⧸ (Ideal.ofList rs₀ • ⊤ : Submodule R M)) rs₁) :\n    IsWeaklyRegular (M ⧸ (Ideal.ofList rs₀ • ⊤ : Submodule R M)) rs₂ := by {\n  induction h₁₂ generalizing rs₀ with\n  | nil => exact .nil R _\n  | cons r _ ih =>\n    let e := quotOfListConsSMulTopEquivQuotSMulTopOuter M r rs₀\n    rw [isWeaklyRegular_cons_iff, ← e.isWeaklyRegular_congr] at h ⊢\n    refine h.imp_right (ih (r :: rs₀) ?_ ?_) <;>\n      exact List.perm_middle.subperm_right.mp ‹_›\n  | swap a b t =>\n    rw [show ∀ x y z, x :: y :: z = [x, y] ++ z from fun _ _ _ => rfl,\n      isWeaklyRegular_append_iff] at h ⊢\n    have : Ideal.ofList [b, a] = Ideal.ofList [a, b] :=\n      congrArg Ideal.span <| Set.ext fun _ => (List.Perm.swap a b []).mem_iff\n    rw [(quotEquivOfEq _ _ (congrArg₂ _ this rfl)).isWeaklyRegular_congr] at h\n    rw [List.append_cons, List.append_cons, List.append_assoc _ [b] [a]] at H₁\n    apply (List.sublist_append_left (rs₀ ++ [b, a]) _).subperm.trans at H₁\n    apply List.perm_append_comm.subperm.trans at H₁\n    exact h.imp_left (swap · (h' b a rs₀ H₁))\n  | trans h₁₂ _ ih₁₂ ih₂₃ =>\n    have H₂ := (h₁₂.append_left rs₀).subperm_right.mp H₁\n    exact ih₂₃ rs₀ H₂ H₃ (ih₁₂ rs₀ H₁ H₂ h) }\n\n-- putting `{rs' : List R}` and `h2` after `h3` would be better for partial\n-- application, but this argument order seems nicer overall\n"}
{"name":"RingTheory.Sequence.IsWeaklyRegular.of_perm_of_subset_jacobson_annihilator","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsNoetherian R M\nrs rs' : List R\nh1 : RingTheory.Sequence.IsWeaklyRegular M rs\nh2 : rs.Perm rs'\nh3 : ∀ (r : R), Membership.mem rs r → Membership.mem (Module.annihilator R M).jacobson r\n⊢ RingTheory.Sequence.IsWeaklyRegular M rs'","decl":"lemma IsWeaklyRegular.of_perm_of_subset_jacobson_annihilator [IsNoetherian R M]\n    {rs rs' : List R} (h1 : IsWeaklyRegular M rs) (h2 : List.Perm rs rs')\n    (h3 : ∀ r ∈ rs, r ∈ (Module.annihilator R M).jacobson) :\n    IsWeaklyRegular M rs' :=\n  h1.prototype_perm h2 fun r _ _ h h' =>\n    eq_bot_of_eq_pointwise_smul_of_mem_jacobson_annihilator\n      (IsNoetherian.noetherian _) h'\n      (Ideal.jacobson_mono\n        (le_trans\n          -- The named argument `(R := R)` below isn't necessary, but\n          -- typechecking is much slower without it\n          (LinearMap.annihilator_le_of_surjective (R := R) _ (mkQ_surjective _))\n          (LinearMap.annihilator_le_of_injective _ (injective_subtype _)))\n        (h3 r (h.subset (List.mem_cons_self _ _))))\n\n"}
{"name":"RingTheory.Sequence.IsRegular.of_perm_of_subset_jacobson_annihilator","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsNoetherian R M\nrs rs' : List R\nh1 : RingTheory.Sequence.IsRegular M rs\nh2 : rs.Perm rs'\nh3 : ∀ (r : R), Membership.mem rs r → Membership.mem (Module.annihilator R M).jacobson r\n⊢ RingTheory.Sequence.IsRegular M rs'","decl":"lemma IsRegular.of_perm_of_subset_jacobson_annihilator [IsNoetherian R M]\n    {rs rs' : List R} (h1 : IsRegular M rs) (h2 : List.Perm rs rs')\n    (h3 : ∀ r ∈ rs, r ∈ (Module.annihilator R M).jacobson) : IsRegular M rs' :=\n  ⟨h1.toIsWeaklyRegular.of_perm_of_subset_jacobson_annihilator h2 h3,\n    letI := h1.nontrivial\n    top_ne_ideal_smul_of_le_jacobson_annihilator <|\n      Ideal.span_le.mpr (h3 · <| h2.mem_iff.mpr ·)⟩\n\n"}
{"name":"IsLocalRing.isWeaklyRegular_of_perm_of_subset_maximalIdeal","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : IsLocalRing R\ninst✝ : IsNoetherian R M\nrs rs' : List R\nh1 : RingTheory.Sequence.IsWeaklyRegular M rs\nh2 : rs.Perm rs'\nh3 : ∀ (r : R), Membership.mem rs r → Membership.mem (IsLocalRing.maximalIdeal R) r\n⊢ RingTheory.Sequence.IsWeaklyRegular M rs'","decl":"lemma _root_.IsLocalRing.isWeaklyRegular_of_perm_of_subset_maximalIdeal\n    [IsLocalRing R] [IsNoetherian R M] {rs rs' : List R}\n    (h1 : IsWeaklyRegular M rs) (h2 : List.Perm rs rs')\n    (h3 : ∀ r ∈ rs, r ∈ IsLocalRing.maximalIdeal R) : IsWeaklyRegular M rs' :=\n  IsWeaklyRegular.of_perm_of_subset_jacobson_annihilator h1 h2 fun r hr =>\n    IsLocalRing.maximalIdeal_le_jacobson _ (h3 r hr)\n\n"}
{"name":"IsLocalRing.isRegular_of_perm","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : IsLocalRing R\ninst✝ : IsNoetherian R M\nrs rs' : List R\nh1 : RingTheory.Sequence.IsRegular M rs\nh2 : rs.Perm rs'\n⊢ RingTheory.Sequence.IsRegular M rs'","decl":"lemma _root_.IsLocalRing.isRegular_of_perm [IsLocalRing R] [IsNoetherian R M]\n    {rs rs' : List R} (h1 : IsRegular M rs) (h2 : List.Perm rs rs') :\n    IsRegular M rs' := by\n  obtain ⟨h3, h4⟩ := h1\n  refine ⟨IsLocalRing.isWeaklyRegular_of_perm_of_subset_maximalIdeal h3 h2 ?_, ?_⟩\n  · intro x (h6 : x ∈ { r | r ∈ rs })\n    refine IsLocalRing.le_maximalIdeal ?_ (Ideal.subset_span h6)\n    exact h4 ∘ Eq.trans (top_smul _).symm ∘ Eq.symm ∘ congrArg (· • ⊤)\n  · refine ne_of_ne_of_eq h4 (congrArg (Ideal.span · • ⊤) ?_)\n    exact Set.ext fun _ => h2.mem_iff\n\n"}
{"name":"LocalRing.isRegular_of_perm","module":"Mathlib.RingTheory.Regular.RegularSequence","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : IsLocalRing R\ninst✝ : IsNoetherian R M\nrs rs' : List R\nh1 : RingTheory.Sequence.IsRegular M rs\nh2 : rs.Perm rs'\n⊢ RingTheory.Sequence.IsRegular M rs'","decl":"@[deprecated (since := \"2024-11-09\")]\nalias _root_.LocalRing.isRegular_of_perm := _root_.IsLocalRing.isRegular_of_perm\n\n"}
