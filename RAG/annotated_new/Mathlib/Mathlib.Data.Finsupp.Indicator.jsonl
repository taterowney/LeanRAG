{"name":"Finsupp.indicator_of_mem","module":"Mathlib.Data.Finsupp.Indicator","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Zero α\ns : Finset ι\ni : ι\nhi : Membership.mem s i\nf : (i : ι) → Membership.mem s i → α\n⊢ Eq ((Finsupp.indicator s f) i) (f i hi)","decl":"theorem indicator_of_mem (hi : i ∈ s) (f : ∀ i ∈ s, α) : indicator s f i = f i hi :=\n  @dif_pos _ (id _) hi _ _ _\n\n"}
{"name":"Finsupp.indicator_of_not_mem","module":"Mathlib.Data.Finsupp.Indicator","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Zero α\ns : Finset ι\ni : ι\nhi : Not (Membership.mem s i)\nf : (i : ι) → Membership.mem s i → α\n⊢ Eq ((Finsupp.indicator s f) i) 0","decl":"theorem indicator_of_not_mem (hi : i ∉ s) (f : ∀ i ∈ s, α) : indicator s f i = 0 :=\n  @dif_neg _ (id _) hi _ _ _\n\n"}
{"name":"Finsupp.indicator_apply","module":"Mathlib.Data.Finsupp.Indicator","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : Zero α\ns : Finset ι\nf : (i : ι) → Membership.mem s i → α\ni : ι\ninst✝ : DecidableEq ι\n⊢ Eq ((Finsupp.indicator s f) i) (dite (Membership.mem s i) (fun hi => f i hi) fun hi => 0)","decl":"@[simp]\ntheorem indicator_apply [DecidableEq ι] : indicator s f i = if hi : i ∈ s then f i hi else 0 := by\n  simp only [indicator, ne_eq, coe_mk]\n  congr\n\n"}
{"name":"Finsupp.indicator_injective","module":"Mathlib.Data.Finsupp.Indicator","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Zero α\ns : Finset ι\n⊢ Function.Injective fun f => Finsupp.indicator s f","decl":"theorem indicator_injective : Injective fun f : ∀ i ∈ s, α => indicator s f := by\n  intro a b h\n  ext i hi\n  rw [← indicator_of_mem hi a, ← indicator_of_mem hi b]\n  exact DFunLike.congr_fun h i\n\n"}
{"name":"Finsupp.support_indicator_subset","module":"Mathlib.Data.Finsupp.Indicator","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Zero α\ns : Finset ι\nf : (i : ι) → Membership.mem s i → α\n⊢ HasSubset.Subset ↑(Finsupp.indicator s f).support ↑s","decl":"theorem support_indicator_subset : ((indicator s f).support : Set ι) ⊆ s := by\n  intro i hi\n  rw [mem_coe, mem_support_iff] at hi\n  by_contra h\n  exact hi (indicator_of_not_mem h _)\n\n"}
{"name":"Finsupp.single_eq_indicator","module":"Mathlib.Data.Finsupp.Indicator","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Zero α\ni : ι\nb : α\n⊢ Eq (Finsupp.single i b) (Finsupp.indicator (Singleton.singleton i) fun x x => b)","decl":"lemma single_eq_indicator (b : α) : single i b = indicator {i} (fun _ _ => b) := by\n  classical\n  ext j\n  simp [single_apply, indicator_apply, @eq_comm _ j]\n\n"}
