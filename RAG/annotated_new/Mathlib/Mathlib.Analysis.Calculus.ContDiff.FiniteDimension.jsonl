{"name":"contDiffOn_clm_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FiniteDimension","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nD : Type uD\ninst✝⁷ : NormedAddCommGroup D\ninst✝⁶ : NormedSpace 𝕜 D\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nn : WithTop ENat\ninst✝¹ : CompleteSpace 𝕜\nf : D → ContinuousLinearMap (RingHom.id 𝕜) E F\ns : Set D\ninst✝ : FiniteDimensional 𝕜 E\n⊢ Iff (ContDiffOn 𝕜 n f s) (∀ (y : E), ContDiffOn 𝕜 n (fun x => (f x) y) s)","decl":"/-- A family of continuous linear maps is `C^n` on `s` if all its applications are. -/\ntheorem contDiffOn_clm_apply {f : D → E →L[𝕜] F} {s : Set D} [FiniteDimensional 𝕜 E] :\n    ContDiffOn 𝕜 n f s ↔ ∀ y, ContDiffOn 𝕜 n (fun x => f x y) s := by\n  refine ⟨fun h y => h.clm_apply contDiffOn_const, fun h => ?_⟩\n  let d := finrank 𝕜 E\n  have hd : d = finrank 𝕜 (Fin d → 𝕜) := (finrank_fin_fun 𝕜).symm\n  let e₁ := ContinuousLinearEquiv.ofFinrankEq hd\n  let e₂ := (e₁.arrowCongr (1 : F ≃L[𝕜] F)).trans (ContinuousLinearEquiv.piRing (Fin d))\n  rw [← id_comp f, ← e₂.symm_comp_self]\n  exact e₂.symm.contDiff.comp_contDiffOn (contDiffOn_pi.mpr fun i => h _)\n\n"}
{"name":"contDiff_clm_apply_iff","module":"Mathlib.Analysis.Calculus.ContDiff.FiniteDimension","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nD : Type uD\ninst✝⁷ : NormedAddCommGroup D\ninst✝⁶ : NormedSpace 𝕜 D\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nn : WithTop ENat\ninst✝¹ : CompleteSpace 𝕜\nf : D → ContinuousLinearMap (RingHom.id 𝕜) E F\ninst✝ : FiniteDimensional 𝕜 E\n⊢ Iff (ContDiff 𝕜 n f) (∀ (y : E), ContDiff 𝕜 n fun x => (f x) y)","decl":"theorem contDiff_clm_apply_iff {f : D → E →L[𝕜] F} [FiniteDimensional 𝕜 E] :\n    ContDiff 𝕜 n f ↔ ∀ y, ContDiff 𝕜 n fun x => f x y := by\n  simp_rw [← contDiffOn_univ, contDiffOn_clm_apply]\n\n"}
{"name":"contDiff_succ_iff_fderiv_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FiniteDimension","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nD : Type uD\ninst✝⁵ : NormedAddCommGroup D\ninst✝⁴ : NormedSpace 𝕜 D\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nn : WithTop ENat\nf : D → E\ninst✝¹ : CompleteSpace 𝕜\ninst✝ : FiniteDimensional 𝕜 D\n⊢ Iff (ContDiff 𝕜 (HAdd.hAdd n 1) f) (And (Differentiable 𝕜 f) (And (Eq n Top.top → AnalyticOnNhd 𝕜 f Set.univ) (∀ (y : D), ContDiff 𝕜 n fun x => (fderiv 𝕜 f x) y)))","decl":"/-- This is a useful lemma to prove that a certain operation preserves functions being `C^n`.\nWhen you do induction on `n`, this gives a useful characterization of a function being `C^(n+1)`,\nassuming you have already computed the derivative. The advantage of this version over\n`contDiff_succ_iff_fderiv` is that both occurrences of `ContDiff` are for functions with the same\ndomain and codomain (`D` and `E`). This is not the case for `contDiff_succ_iff_fderiv`, which\noften requires an inconvenient need to generalize `F`, which results in universe issues\n(see the discussion in the section of `ContDiff.comp`).\n\nThis lemma avoids these universe issues, but only applies for finite dimensional `D`. -/\ntheorem contDiff_succ_iff_fderiv_apply [FiniteDimensional 𝕜 D] :\n    ContDiff 𝕜 (n + 1) f ↔ Differentiable 𝕜 f ∧\n      (n = ω → AnalyticOnNhd 𝕜 f Set.univ) ∧ ∀ y, ContDiff 𝕜 n fun x => fderiv 𝕜 f x y := by\n  rw [contDiff_succ_iff_fderiv, contDiff_clm_apply_iff]\n\n"}
{"name":"contDiffOn_succ_of_fderiv_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FiniteDimension","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nD : Type uD\ninst✝⁵ : NormedAddCommGroup D\ninst✝⁴ : NormedSpace 𝕜 D\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nn : WithTop ENat\nf : D → E\ns : Set D\ninst✝¹ : CompleteSpace 𝕜\ninst✝ : FiniteDimensional 𝕜 D\nhf : DifferentiableOn 𝕜 f s\nh'f : Eq n Top.top → AnalyticOn 𝕜 f s\nh : ∀ (y : D), ContDiffOn 𝕜 n (fun x => (fderivWithin 𝕜 f s x) y) s\n⊢ ContDiffOn 𝕜 (HAdd.hAdd n 1) f s","decl":"theorem contDiffOn_succ_of_fderiv_apply [FiniteDimensional 𝕜 D]\n    (hf : DifferentiableOn 𝕜 f s) (h'f : n = ω → AnalyticOn 𝕜 f s)\n    (h : ∀ y, ContDiffOn 𝕜 n (fun x => fderivWithin 𝕜 f s x y) s) :\n    ContDiffOn 𝕜 (n + 1) f s :=\n  contDiffOn_succ_of_fderivWithin hf h'f <| contDiffOn_clm_apply.mpr h\n\n"}
{"name":"contDiffOn_succ_iff_fderiv_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FiniteDimension","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nD : Type uD\ninst✝⁵ : NormedAddCommGroup D\ninst✝⁴ : NormedSpace 𝕜 D\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nn : WithTop ENat\nf : D → E\ns : Set D\ninst✝¹ : CompleteSpace 𝕜\ninst✝ : FiniteDimensional 𝕜 D\nhs : UniqueDiffOn 𝕜 s\n⊢ Iff (ContDiffOn 𝕜 (HAdd.hAdd n 1) f s) (And (DifferentiableOn 𝕜 f s) (And (Eq n Top.top → AnalyticOn 𝕜 f s) (∀ (y : D), ContDiffOn 𝕜 n (fun x => (fderivWithin 𝕜 f s x) y) s)))","decl":"theorem contDiffOn_succ_iff_fderiv_apply [FiniteDimensional 𝕜 D] (hs : UniqueDiffOn 𝕜 s) :\n    ContDiffOn 𝕜 (n + 1) f s ↔\n      DifferentiableOn 𝕜 f s ∧ (n = ω → AnalyticOn 𝕜 f s) ∧\n      ∀ y, ContDiffOn 𝕜 n (fun x => fderivWithin 𝕜 f s x y) s := by\n  rw [contDiffOn_succ_iff_fderivWithin hs, contDiffOn_clm_apply]\n\n"}
