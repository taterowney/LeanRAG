{"name":"contDiffOn_clm_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FiniteDimension","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nD : Type uD\ninstâœâ· : NormedAddCommGroup D\ninstâœâ¶ : NormedSpace ğ•œ D\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nn : WithTop ENat\ninstâœÂ¹ : CompleteSpace ğ•œ\nf : D â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\ns : Set D\ninstâœ : FiniteDimensional ğ•œ E\nâŠ¢ Iff (ContDiffOn ğ•œ n f s) (âˆ€ (y : E), ContDiffOn ğ•œ n (fun x => (f x) y) s)","decl":"/-- A family of continuous linear maps is `C^n` on `s` if all its applications are. -/\ntheorem contDiffOn_clm_apply {f : D â†’ E â†’L[ğ•œ] F} {s : Set D} [FiniteDimensional ğ•œ E] :\n    ContDiffOn ğ•œ n f s â†” âˆ€ y, ContDiffOn ğ•œ n (fun x => f x y) s := by\n  refine âŸ¨fun h y => h.clm_apply contDiffOn_const, fun h => ?_âŸ©\n  let d := finrank ğ•œ E\n  have hd : d = finrank ğ•œ (Fin d â†’ ğ•œ) := (finrank_fin_fun ğ•œ).symm\n  let eâ‚ := ContinuousLinearEquiv.ofFinrankEq hd\n  let eâ‚‚ := (eâ‚.arrowCongr (1 : F â‰ƒL[ğ•œ] F)).trans (ContinuousLinearEquiv.piRing (Fin d))\n  rw [â† id_comp f, â† eâ‚‚.symm_comp_self]\n  exact eâ‚‚.symm.contDiff.comp_contDiffOn (contDiffOn_pi.mpr fun i => h _)\n\n"}
{"name":"contDiff_clm_apply_iff","module":"Mathlib.Analysis.Calculus.ContDiff.FiniteDimension","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nD : Type uD\ninstâœâ· : NormedAddCommGroup D\ninstâœâ¶ : NormedSpace ğ•œ D\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nn : WithTop ENat\ninstâœÂ¹ : CompleteSpace ğ•œ\nf : D â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\ninstâœ : FiniteDimensional ğ•œ E\nâŠ¢ Iff (ContDiff ğ•œ n f) (âˆ€ (y : E), ContDiff ğ•œ n fun x => (f x) y)","decl":"theorem contDiff_clm_apply_iff {f : D â†’ E â†’L[ğ•œ] F} [FiniteDimensional ğ•œ E] :\n    ContDiff ğ•œ n f â†” âˆ€ y, ContDiff ğ•œ n fun x => f x y := by\n  simp_rw [â† contDiffOn_univ, contDiffOn_clm_apply]\n\n"}
{"name":"contDiff_succ_iff_fderiv_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FiniteDimension","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nD : Type uD\ninstâœâµ : NormedAddCommGroup D\ninstâœâ´ : NormedSpace ğ•œ D\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nn : WithTop ENat\nf : D â†’ E\ninstâœÂ¹ : CompleteSpace ğ•œ\ninstâœ : FiniteDimensional ğ•œ D\nâŠ¢ Iff (ContDiff ğ•œ (HAdd.hAdd n 1) f) (And (Differentiable ğ•œ f) (And (Eq n Top.top â†’ AnalyticOnNhd ğ•œ f Set.univ) (âˆ€ (y : D), ContDiff ğ•œ n fun x => (fderiv ğ•œ f x) y)))","decl":"/-- This is a useful lemma to prove that a certain operation preserves functions being `C^n`.\nWhen you do induction on `n`, this gives a useful characterization of a function being `C^(n+1)`,\nassuming you have already computed the derivative. The advantage of this version over\n`contDiff_succ_iff_fderiv` is that both occurrences of `ContDiff` are for functions with the same\ndomain and codomain (`D` and `E`). This is not the case for `contDiff_succ_iff_fderiv`, which\noften requires an inconvenient need to generalize `F`, which results in universe issues\n(see the discussion in the section of `ContDiff.comp`).\n\nThis lemma avoids these universe issues, but only applies for finite dimensional `D`. -/\ntheorem contDiff_succ_iff_fderiv_apply [FiniteDimensional ğ•œ D] :\n    ContDiff ğ•œ (n + 1) f â†” Differentiable ğ•œ f âˆ§\n      (n = Ï‰ â†’ AnalyticOnNhd ğ•œ f Set.univ) âˆ§ âˆ€ y, ContDiff ğ•œ n fun x => fderiv ğ•œ f x y := by\n  rw [contDiff_succ_iff_fderiv, contDiff_clm_apply_iff]\n\n"}
{"name":"contDiffOn_succ_of_fderiv_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FiniteDimension","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nD : Type uD\ninstâœâµ : NormedAddCommGroup D\ninstâœâ´ : NormedSpace ğ•œ D\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nn : WithTop ENat\nf : D â†’ E\ns : Set D\ninstâœÂ¹ : CompleteSpace ğ•œ\ninstâœ : FiniteDimensional ğ•œ D\nhf : DifferentiableOn ğ•œ f s\nh'f : Eq n Top.top â†’ AnalyticOn ğ•œ f s\nh : âˆ€ (y : D), ContDiffOn ğ•œ n (fun x => (fderivWithin ğ•œ f s x) y) s\nâŠ¢ ContDiffOn ğ•œ (HAdd.hAdd n 1) f s","decl":"theorem contDiffOn_succ_of_fderiv_apply [FiniteDimensional ğ•œ D]\n    (hf : DifferentiableOn ğ•œ f s) (h'f : n = Ï‰ â†’ AnalyticOn ğ•œ f s)\n    (h : âˆ€ y, ContDiffOn ğ•œ n (fun x => fderivWithin ğ•œ f s x y) s) :\n    ContDiffOn ğ•œ (n + 1) f s :=\n  contDiffOn_succ_of_fderivWithin hf h'f <| contDiffOn_clm_apply.mpr h\n\n"}
{"name":"contDiffOn_succ_iff_fderiv_apply","module":"Mathlib.Analysis.Calculus.ContDiff.FiniteDimension","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nD : Type uD\ninstâœâµ : NormedAddCommGroup D\ninstâœâ´ : NormedSpace ğ•œ D\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nn : WithTop ENat\nf : D â†’ E\ns : Set D\ninstâœÂ¹ : CompleteSpace ğ•œ\ninstâœ : FiniteDimensional ğ•œ D\nhs : UniqueDiffOn ğ•œ s\nâŠ¢ Iff (ContDiffOn ğ•œ (HAdd.hAdd n 1) f s) (And (DifferentiableOn ğ•œ f s) (And (Eq n Top.top â†’ AnalyticOn ğ•œ f s) (âˆ€ (y : D), ContDiffOn ğ•œ n (fun x => (fderivWithin ğ•œ f s x) y) s)))","decl":"theorem contDiffOn_succ_iff_fderiv_apply [FiniteDimensional ğ•œ D] (hs : UniqueDiffOn ğ•œ s) :\n    ContDiffOn ğ•œ (n + 1) f s â†”\n      DifferentiableOn ğ•œ f s âˆ§ (n = Ï‰ â†’ AnalyticOn ğ•œ f s) âˆ§\n      âˆ€ y, ContDiffOn ğ•œ n (fun x => fderivWithin ğ•œ f s x y) s := by\n  rw [contDiffOn_succ_iff_fderivWithin hs, contDiffOn_clm_apply]\n\n"}
