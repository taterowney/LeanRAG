{"name":"Fintype.subtype_card","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\np : α → Prop\ns : Finset α\nH : ∀ (x : α), Iff (Membership.mem s x) (p x)\n⊢ Eq (Fintype.card (Subtype fun x => p x)) s.card","decl":"theorem subtype_card {p : α → Prop} (s : Finset α) (H : ∀ x : α, x ∈ s ↔ p x) :\n    @card { x // p x } (Fintype.subtype s H) = #s :=\n  Multiset.card_pmap _ _ _\n\n"}
{"name":"Fintype.card_of_subtype","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\np : α → Prop\ns : Finset α\nH : ∀ (x : α), Iff (Membership.mem s x) (p x)\ninst✝ : Fintype (Subtype fun x => p x)\n⊢ Eq (Fintype.card (Subtype fun x => p x)) s.card","decl":"theorem card_of_subtype {p : α → Prop} (s : Finset α) (H : ∀ x : α, x ∈ s ↔ p x)\n    [Fintype { x // p x }] : card { x // p x } = #s := by\n  rw [← subtype_card s H]\n  congr!\n\n"}
{"name":"Fintype.card_ofFinset","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\np : Set α\ns : Finset α\nH : ∀ (x : α), Iff (Membership.mem s x) (Membership.mem p x)\n⊢ Eq (Fintype.card ↑p) s.card","decl":"@[simp]\ntheorem card_ofFinset {p : Set α} (s : Finset α) (H : ∀ x, x ∈ s ↔ x ∈ p) :\n    @Fintype.card p (ofFinset s H) = #s :=\n  Fintype.subtype_card s H\n\n"}
{"name":"Fintype.card_of_finset'","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\np : Set α\ns : Finset α\nH : ∀ (x : α), Iff (Membership.mem s x) (Membership.mem p x)\ninst✝ : Fintype ↑p\n⊢ Eq (Fintype.card ↑p) s.card","decl":"theorem card_of_finset' {p : Set α} (s : Finset α) (H : ∀ x, x ∈ s ↔ x ∈ p) [Fintype p] :\n    Fintype.card p = #s := by rw [← card_ofFinset s H]; congr!\n\n"}
{"name":"Fintype.ofEquiv_card","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Fintype α\nf : Equiv α β\n⊢ Eq (Fintype.card β) (Fintype.card α)","decl":"theorem ofEquiv_card [Fintype α] (f : α ≃ β) : @card β (ofEquiv α f) = card α :=\n  Multiset.card_map _ _\n\n"}
{"name":"Fintype.card_congr","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : Equiv α β\n⊢ Eq (Fintype.card α) (Fintype.card β)","decl":"theorem card_congr {α β} [Fintype α] [Fintype β] (f : α ≃ β) : card α = card β := by\n  rw [← ofEquiv_card f]; congr!\n\n"}
{"name":"Fintype.card_congr'","module":"Mathlib.Data.Fintype.Card","initialProofState":"α β : Type u_4\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nh : Eq α β\n⊢ Eq (Fintype.card α) (Fintype.card β)","decl":"@[congr]\ntheorem card_congr' {α β} [Fintype α] [Fintype β] (h : α = β) : card α = card β :=\n  card_congr (by rw [h])\n\n"}
{"name":"Fintype.card_eq","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\nβ : Type u_5\n_F : Fintype α\n_G : Fintype β\n⊢ Iff (Eq (Fintype.card α) (Fintype.card β)) (Nonempty (Equiv α β))","decl":"theorem card_eq {α β} [_F : Fintype α] [_G : Fintype β] : card α = card β ↔ Nonempty (α ≃ β) :=\n  ⟨fun h =>\n    haveI := Classical.propDecidable\n    (truncEquivOfCardEq h).nonempty,\n    fun ⟨f⟩ => card_congr f⟩\n\n"}
{"name":"Fintype.card_ofSubsingleton","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\na : α\ninst✝ : Subsingleton α\n⊢ Eq (Fintype.card α) 1","decl":"/-- Note: this lemma is specifically about `Fintype.ofSubsingleton`. For a statement about\narbitrary `Fintype` instances, use either `Fintype.card_le_one_iff_subsingleton` or\n`Fintype.card_unique`. -/\ntheorem card_ofSubsingleton (a : α) [Subsingleton α] : @Fintype.card _ (ofSubsingleton a) = 1 :=\n  rfl\n\n"}
{"name":"Fintype.card_unique","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Unique α\nh : Fintype α\n⊢ Eq (Fintype.card α) 1","decl":"@[simp]\ntheorem card_unique [Unique α] [h : Fintype α] : Fintype.card α = 1 :=\n  Subsingleton.elim (ofSubsingleton default) h ▸ card_ofSubsingleton _\n\n"}
{"name":"Fintype.card_ofIsEmpty","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : IsEmpty α\n⊢ Eq (Fintype.card α) 0","decl":"/-- Note: this lemma is specifically about `Fintype.ofIsEmpty`. For a statement about\narbitrary `Fintype` instances, use `Fintype.card_eq_zero`. -/\ntheorem card_ofIsEmpty [IsEmpty α] : @Fintype.card α Fintype.ofIsEmpty = 0 :=\n  rfl\n\n"}
{"name":"Set.toFinset_card","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ns : Set α\ninst✝ : Fintype ↑s\n⊢ Eq s.toFinset.card (Fintype.card ↑s)","decl":"@[simp]\ntheorem toFinset_card {α : Type*} (s : Set α) [Fintype s] : s.toFinset.card = Fintype.card s :=\n  Multiset.card_map Subtype.val Finset.univ.val\n\n"}
{"name":"Finset.card_univ","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n⊢ Eq Finset.univ.card (Fintype.card α)","decl":"@[simp]\ntheorem Finset.card_univ [Fintype α] : #(univ : Finset α) = Fintype.card α := rfl\n\n"}
{"name":"Finset.eq_univ_of_card","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Fintype α\ns : Finset α\nhs : Eq s.card (Fintype.card α)\n⊢ Eq s Finset.univ","decl":"theorem Finset.eq_univ_of_card [Fintype α] (s : Finset α) (hs : #s = Fintype.card α) :\n    s = univ :=\n  eq_of_subset_of_card_le (subset_univ _) <| by rw [hs, Finset.card_univ]\n\n"}
{"name":"Finset.card_eq_iff_eq_univ","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Fintype α\ns : Finset α\n⊢ Iff (Eq s.card (Fintype.card α)) (Eq s Finset.univ)","decl":"theorem Finset.card_eq_iff_eq_univ [Fintype α] (s : Finset α) : #s = Fintype.card α ↔ s = univ :=\n  ⟨s.eq_univ_of_card, by\n    rintro rfl\n    exact Finset.card_univ⟩\n\n"}
{"name":"Finset.card_le_univ","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Fintype α\ns : Finset α\n⊢ LE.le s.card (Fintype.card α)","decl":"theorem Finset.card_le_univ [Fintype α] (s : Finset α) : #s ≤ Fintype.card α :=\n  card_le_card (subset_univ s)\n\n"}
{"name":"Finset.card_lt_univ_of_not_mem","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Fintype α\ns : Finset α\nx : α\nhx : Not (Membership.mem s x)\n⊢ LT.lt s.card (Fintype.card α)","decl":"theorem Finset.card_lt_univ_of_not_mem [Fintype α] {s : Finset α} {x : α} (hx : x ∉ s) :\n    #s < Fintype.card α :=\n  card_lt_card ⟨subset_univ s, not_forall.2 ⟨x, fun hx' => hx (hx' <| mem_univ x)⟩⟩\n\n"}
{"name":"Finset.card_lt_iff_ne_univ","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Fintype α\ns : Finset α\n⊢ Iff (LT.lt s.card (Fintype.card α)) (Ne s Finset.univ)","decl":"theorem Finset.card_lt_iff_ne_univ [Fintype α] (s : Finset α) :\n    #s < Fintype.card α ↔ s ≠ Finset.univ :=\n  s.card_le_univ.lt_iff_ne.trans (not_congr s.card_eq_iff_eq_univ)\n\n"}
{"name":"Finset.card_compl_lt_iff_nonempty","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : DecidableEq α\ns : Finset α\n⊢ Iff (LT.lt (HasCompl.compl s).card (Fintype.card α)) s.Nonempty","decl":"theorem Finset.card_compl_lt_iff_nonempty [Fintype α] [DecidableEq α] (s : Finset α) :\n    #sᶜ < Fintype.card α ↔ s.Nonempty :=\n  sᶜ.card_lt_iff_ne_univ.trans s.compl_ne_univ_iff_nonempty\n\n"}
{"name":"Finset.card_univ_diff","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ns : Finset α\n⊢ Eq (SDiff.sdiff Finset.univ s).card (HSub.hSub (Fintype.card α) s.card)","decl":"theorem Finset.card_univ_diff [DecidableEq α] [Fintype α] (s : Finset α) :\n    #(univ \\ s) = Fintype.card α - #s :=\n  Finset.card_sdiff (subset_univ s)\n\n"}
{"name":"Finset.card_compl","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ns : Finset α\n⊢ Eq (HasCompl.compl s).card (HSub.hSub (Fintype.card α) s.card)","decl":"theorem Finset.card_compl [DecidableEq α] [Fintype α] (s : Finset α) : #sᶜ = Fintype.card α - #s :=\n  Finset.card_univ_diff s\n\n"}
{"name":"Finset.card_add_card_compl","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ns : Finset α\n⊢ Eq (HAdd.hAdd s.card (HasCompl.compl s).card) (Fintype.card α)","decl":"@[simp]\ntheorem Finset.card_add_card_compl [DecidableEq α] [Fintype α] (s : Finset α) :\n    #s + #sᶜ = Fintype.card α := by\n  rw [Finset.card_compl, ← Nat.add_sub_assoc (card_le_univ s), Nat.add_sub_cancel_left]\n\n"}
{"name":"Finset.card_compl_add_card","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝¹ : DecidableEq α\ninst✝ : Fintype α\ns : Finset α\n⊢ Eq (HAdd.hAdd (HasCompl.compl s).card s.card) (Fintype.card α)","decl":"@[simp]\ntheorem Finset.card_compl_add_card [DecidableEq α] [Fintype α] (s : Finset α) :\n    #sᶜ + #s = Fintype.card α := by\n  rw [add_comm, card_add_card_compl]\n\n"}
{"name":"Fintype.card_compl_set","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝² : Fintype α\ns : Set α\ninst✝¹ : Fintype ↑s\ninst✝ : Fintype ↑(HasCompl.compl s)\n⊢ Eq (Fintype.card ↑(HasCompl.compl s)) (HSub.hSub (Fintype.card α) (Fintype.card ↑s))","decl":"theorem Fintype.card_compl_set [Fintype α] (s : Set α) [Fintype s] [Fintype (↥sᶜ : Sort _)] :\n    Fintype.card (↥sᶜ : Sort _) = Fintype.card α - Fintype.card s := by\n  classical rw [← Set.toFinset_card, ← Set.toFinset_card, ← Finset.card_compl, Set.toFinset_compl]\n\n"}
{"name":"Fintype.card_fin","module":"Mathlib.Data.Fintype.Card","initialProofState":"n : Nat\n⊢ Eq (Fintype.card (Fin n)) n","decl":"@[simp]\ntheorem Fintype.card_fin (n : ℕ) : Fintype.card (Fin n) = n :=\n  List.length_finRange n\n\n"}
{"name":"Fintype.card_fin_lt_of_le","module":"Mathlib.Data.Fintype.Card","initialProofState":"m n : Nat\nh : LE.le m n\n⊢ Eq (Fintype.card (Subtype fun i => LT.lt (↑i) m)) m","decl":"theorem Fintype.card_fin_lt_of_le {m n : ℕ} (h : m ≤ n) :\n    Fintype.card {i : Fin n // i < m} = m := by\n  conv_rhs => rw [← Fintype.card_fin m]\n  apply Fintype.card_congr\n  exact { toFun := fun ⟨⟨i, _⟩, hi⟩ ↦ ⟨i, hi⟩\n          invFun := fun ⟨i, hi⟩ ↦ ⟨⟨i, lt_of_lt_of_le hi h⟩, hi⟩\n          left_inv := fun i ↦ rfl\n          right_inv := fun i ↦ rfl }\n\n"}
{"name":"Finset.card_fin","module":"Mathlib.Data.Fintype.Card","initialProofState":"n : Nat\n⊢ Eq Finset.univ.card n","decl":"theorem Finset.card_fin (n : ℕ) : #(univ : Finset (Fin n)) = n := by simp\n\n"}
{"name":"fin_injective","module":"Mathlib.Data.Fintype.Card","initialProofState":"⊢ Function.Injective Fin","decl":"/-- `Fin` as a map from `ℕ` to `Type` is injective. Note that since this is a statement about\nequality of types, using it should be avoided if possible. -/\ntheorem fin_injective : Function.Injective Fin := fun m n h =>\n  (Fintype.card_fin m).symm.trans <| (Fintype.card_congr <| Equiv.cast h).trans (Fintype.card_fin n)\n\n"}
{"name":"Fin.val_eq_val_of_heq","module":"Mathlib.Data.Fintype.Card","initialProofState":"k l : Nat\ni : Fin k\nj : Fin l\nh : HEq i j\n⊢ Eq ↑i ↑j","decl":"theorem Fin.val_eq_val_of_heq {k l : ℕ} {i : Fin k} {j : Fin l} (h : HEq i j) :\n    (i : ℕ) = (j : ℕ) :=\n  (Fin.heq_ext_iff (fin_injective (type_eq_of_heq h))).1 h\n\n"}
{"name":"Fin.cast_eq_cast'","module":"Mathlib.Data.Fintype.Card","initialProofState":"n m : Nat\nh : Eq (Fin n) (Fin m)\n⊢ Eq (cast h) (Fin.cast ⋯)","decl":"/-- A reversed version of `Fin.cast_eq_cast` that is easier to rewrite with. -/\ntheorem Fin.cast_eq_cast' {n m : ℕ} (h : Fin n = Fin m) :\n    _root_.cast h = Fin.cast (fin_injective h) := by\n  cases fin_injective h\n  rfl\n\n"}
{"name":"card_finset_fin_le","module":"Mathlib.Data.Fintype.Card","initialProofState":"n : Nat\ns : Finset (Fin n)\n⊢ LE.le s.card n","decl":"theorem card_finset_fin_le {n : ℕ} (s : Finset (Fin n)) : #s ≤ n := by\n  simpa only [Fintype.card_fin] using s.card_le_univ\n\n"}
{"name":"Fintype.card_subtype_eq","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ny : α\ninst✝ : Fintype (Subtype fun x => Eq x y)\n⊢ Eq (Fintype.card (Subtype fun x => Eq x y)) 1","decl":"theorem Fintype.card_subtype_eq (y : α) [Fintype { x // x = y }] :\n    Fintype.card { x // x = y } = 1 :=\n  Fintype.card_unique\n\n"}
{"name":"Fintype.card_subtype_eq'","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ny : α\ninst✝ : Fintype (Subtype fun x => Eq y x)\n⊢ Eq (Fintype.card (Subtype fun x => Eq y x)) 1","decl":"theorem Fintype.card_subtype_eq' (y : α) [Fintype { x // y = x }] :\n    Fintype.card { x // y = x } = 1 :=\n  Fintype.card_unique\n\n"}
{"name":"Fintype.card_empty","module":"Mathlib.Data.Fintype.Card","initialProofState":"⊢ Eq (Fintype.card Empty) 0","decl":"theorem Fintype.card_empty : Fintype.card Empty = 0 :=\n  rfl\n\n"}
{"name":"Fintype.card_pempty","module":"Mathlib.Data.Fintype.Card","initialProofState":"⊢ Eq (Fintype.card PEmpty.{u_4 + 1}) 0","decl":"theorem Fintype.card_pempty : Fintype.card PEmpty = 0 :=\n  rfl\n\n"}
{"name":"Fintype.card_unit","module":"Mathlib.Data.Fintype.Card","initialProofState":"⊢ Eq (Fintype.card Unit) 1","decl":"theorem Fintype.card_unit : Fintype.card Unit = 1 :=\n  rfl\n\n"}
{"name":"Fintype.card_punit","module":"Mathlib.Data.Fintype.Card","initialProofState":"⊢ Eq (Fintype.card PUnit.{u_4 + 1}) 1","decl":"@[simp]\ntheorem Fintype.card_punit : Fintype.card PUnit = 1 :=\n  rfl\n\n"}
{"name":"Fintype.card_bool","module":"Mathlib.Data.Fintype.Card","initialProofState":"⊢ Eq (Fintype.card Bool) 2","decl":"@[simp]\ntheorem Fintype.card_bool : Fintype.card Bool = 2 :=\n  rfl\n\n"}
{"name":"Fintype.card_ulift","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ninst✝ : Fintype α\n⊢ Eq (Fintype.card (ULift.{u_5, u_4} α)) (Fintype.card α)","decl":"@[simp]\ntheorem Fintype.card_ulift (α : Type*) [Fintype α] : Fintype.card (ULift α) = Fintype.card α :=\n  Fintype.ofEquiv_card _\n\n"}
{"name":"Fintype.card_plift","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ninst✝ : Fintype α\n⊢ Eq (Fintype.card (PLift α)) (Fintype.card α)","decl":"@[simp]\ntheorem Fintype.card_plift (α : Type*) [Fintype α] : Fintype.card (PLift α) = Fintype.card α :=\n  Fintype.ofEquiv_card _\n\n"}
{"name":"Fintype.card_orderDual","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ninst✝ : Fintype α\n⊢ Eq (Fintype.card (OrderDual α)) (Fintype.card α)","decl":"@[simp]\ntheorem Fintype.card_orderDual (α : Type*) [Fintype α] : Fintype.card αᵒᵈ = Fintype.card α :=\n  rfl\n\n"}
{"name":"Fintype.card_lex","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ninst✝ : Fintype α\n⊢ Eq (Fintype.card (Lex α)) (Fintype.card α)","decl":"@[simp]\ntheorem Fintype.card_lex (α : Type*) [Fintype α] : Fintype.card (Lex α) = Fintype.card α :=\n  rfl\n\n"}
{"name":"Fintype.card_multiplicative","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ninst✝ : Fintype α\n⊢ Eq (Fintype.card (Multiplicative α)) (Fintype.card α)","decl":"@[simp] lemma Fintype.card_multiplicative (α : Type*) [Fintype α] :\n    card (Multiplicative α) = card α := Finset.card_map _\n\n"}
{"name":"Fintype.card_additive","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ninst✝ : Fintype α\n⊢ Eq (Fintype.card (Additive α)) (Fintype.card α)","decl":"@[simp] lemma Fintype.card_additive (α : Type*) [Fintype α] : card (Additive α) = card α :=\n  Finset.card_map _\n\n"}
{"name":"Fintype.finite","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\n_inst : Fintype α\n⊢ Finite α","decl":"protected theorem Fintype.finite {α : Type*} (_inst : Fintype α) : Finite α :=\n  ⟨Fintype.equivFin α⟩\n\n"}
{"name":"Finite.of_fintype","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ninst✝ : Fintype α\n⊢ Finite α","decl":"/-- For efficiency reasons, we want `Finite` instances to have higher\npriority than ones coming from `Fintype` instances. -/\n-- @[nolint fintype_finite] -- Porting note: do we need this\ninstance (priority := 900) Finite.of_fintype (α : Type*) [Fintype α] : Finite α :=\n  Fintype.finite ‹_›\n\n"}
{"name":"finite_iff_nonempty_fintype","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\n⊢ Iff (Finite α) (Nonempty (Fintype α))","decl":"theorem finite_iff_nonempty_fintype (α : Type*) : Finite α ↔ Nonempty (Fintype α) :=\n  ⟨fun _ => nonempty_fintype α, fun ⟨_⟩ => inferInstance⟩\n\n"}
{"name":"Finite.of_injective","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Sort u_4\nβ : Sort u_5\ninst✝ : Finite β\nf : α → β\nH : Function.Injective f\n⊢ Finite α","decl":"theorem Finite.of_injective {α β : Sort*} [Finite β] (f : α → β) (H : Injective f) : Finite α := by\n  rcases Finite.exists_equiv_fin β with ⟨n, ⟨e⟩⟩\n  classical exact .of_equiv (Set.range (e ∘ f)) (Equiv.ofInjective _ (e.injective.comp H)).symm\n\n-- see Note [lower instance priority]\n"}
{"name":"Finite.of_subsingleton","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Sort u_4\ninst✝ : Subsingleton α\n⊢ Finite α","decl":"instance (priority := 100) Finite.of_subsingleton {α : Sort*} [Subsingleton α] : Finite α :=\n  Finite.of_injective (Function.const α ()) <| Function.injective_of_subsingleton _\n\n-- Higher priority for `Prop`s\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/12096): removed @[nolint instance_priority], linter not ported yet\n"}
{"name":"prop","module":"Mathlib.Data.Fintype.Card","initialProofState":"p : Prop\n⊢ Finite p","decl":"instance prop (p : Prop) : Finite p :=\n  Finite.of_subsingleton\n\n"}
{"name":"Subtype.finite","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Sort u_4\ninst✝ : Finite α\np : α → Prop\n⊢ Finite (Subtype fun x => p x)","decl":"/-- This instance also provides `[Finite s]` for `s : Set α`. -/\ninstance Subtype.finite {α : Sort*} [Finite α] {p : α → Prop} : Finite { x // p x } :=\n  Finite.of_injective Subtype.val Subtype.coe_injective\n\n"}
{"name":"Finite.of_surjective","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Sort u_4\nβ : Sort u_5\ninst✝ : Finite α\nf : α → β\nH : Function.Surjective f\n⊢ Finite β","decl":"theorem Finite.of_surjective {α β : Sort*} [Finite α] (f : α → β) (H : Surjective f) : Finite β :=\n  Finite.of_injective _ <| injective_surjInv H\n\n"}
{"name":"Quot.finite","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Sort u_4\ninst✝ : Finite α\nr : α → α → Prop\n⊢ Finite (Quot r)","decl":"instance Quot.finite {α : Sort*} [Finite α] (r : α → α → Prop) : Finite (Quot r) :=\n  Finite.of_surjective _ Quot.mk_surjective\n\n"}
{"name":"Quotient.finite","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Sort u_4\ninst✝ : Finite α\ns : Setoid α\n⊢ Finite (Quotient s)","decl":"instance Quotient.finite {α : Sort*} [Finite α] (s : Setoid α) : Finite (Quotient s) :=\n  Quot.finite _\n\n"}
{"name":"Finite.exists_univ_list","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ninst✝ : Finite α\n⊢ Exists fun l => And l.Nodup (∀ (x : α), Membership.mem l x)","decl":"theorem Finite.exists_univ_list (α) [Finite α] : ∃ l : List α, l.Nodup ∧ ∀ x : α, x ∈ l := by\n  cases nonempty_fintype α\n  obtain ⟨l, e⟩ := Quotient.exists_rep (@univ α _).1\n  have := And.intro (@univ α _).2 (@mem_univ_val α _)\n  exact ⟨_, by rwa [← e] at this⟩\n\n"}
{"name":"List.Nodup.length_le_card","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ninst✝ : Fintype α\nl : List α\nh : l.Nodup\n⊢ LE.le l.length (Fintype.card α)","decl":"theorem List.Nodup.length_le_card {α : Type*} [Fintype α] {l : List α} (h : l.Nodup) :\n    l.length ≤ Fintype.card α := by\n  classical exact List.toFinset_card_of_nodup h ▸ l.toFinset.card_le_univ\n\n"}
{"name":"Fintype.card_le_of_injective","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : α → β\nhf : Function.Injective f\n⊢ LE.le (Fintype.card α) (Fintype.card β)","decl":"theorem card_le_of_injective (f : α → β) (hf : Function.Injective f) : card α ≤ card β :=\n  Finset.card_le_card_of_injOn f (fun _ _ => Finset.mem_univ _) fun _ _ _ _ h => hf h\n\n"}
{"name":"Fintype.card_le_of_embedding","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : Function.Embedding α β\n⊢ LE.le (Fintype.card α) (Fintype.card β)","decl":"theorem card_le_of_embedding (f : α ↪ β) : card α ≤ card β :=\n  card_le_of_injective f f.2\n\n"}
{"name":"Fintype.card_lt_of_injective_of_not_mem","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : α → β\nh : Function.Injective f\nb : β\nw : Not (Membership.mem (Set.range f) b)\n⊢ LT.lt (Fintype.card α) (Fintype.card β)","decl":"theorem card_lt_of_injective_of_not_mem (f : α → β) (h : Function.Injective f) {b : β}\n    (w : b ∉ Set.range f) : card α < card β :=\n  calc\n    card α = (univ.map ⟨f, h⟩).card := (card_map _).symm\n    _ < card β :=\n      Finset.card_lt_univ_of_not_mem (x := b) <| by\n        rwa [← mem_coe, coe_map, coe_univ, Set.image_univ]\n\n"}
{"name":"Fintype.card_lt_of_injective_not_surjective","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : α → β\nh : Function.Injective f\nh' : Not (Function.Surjective f)\n⊢ LT.lt (Fintype.card α) (Fintype.card β)","decl":"theorem card_lt_of_injective_not_surjective (f : α → β) (h : Function.Injective f)\n    (h' : ¬Function.Surjective f) : card α < card β :=\n  let ⟨_y, hy⟩ := not_forall.1 h'\n  card_lt_of_injective_of_not_mem f h hy\n\n"}
{"name":"Fintype.card_le_of_surjective","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : α → β\nh : Function.Surjective f\n⊢ LE.le (Fintype.card β) (Fintype.card α)","decl":"theorem card_le_of_surjective (f : α → β) (h : Function.Surjective f) : card β ≤ card α :=\n  card_le_of_injective _ (Function.injective_surjInv h)\n\n"}
{"name":"Fintype.card_range_le","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\nβ : Type u_5\nf : α → β\ninst✝¹ : Fintype α\ninst✝ : Fintype ↑(Set.range f)\n⊢ LE.le (Fintype.card ↑(Set.range f)) (Fintype.card α)","decl":"theorem card_range_le {α β : Type*} (f : α → β) [Fintype α] [Fintype (Set.range f)] :\n    Fintype.card (Set.range f) ≤ Fintype.card α :=\n  Fintype.card_le_of_surjective (fun a => ⟨f a, by simp⟩) fun ⟨_, a, ha⟩ => ⟨a, by simpa using ha⟩\n\n"}
{"name":"Fintype.card_range","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\nβ : Type u_5\nF : Type u_6\ninst✝³ : FunLike F α β\ninst✝² : EmbeddingLike F α β\nf : F\ninst✝¹ : Fintype α\ninst✝ : Fintype ↑(Set.range ⇑f)\n⊢ Eq (Fintype.card ↑(Set.range ⇑f)) (Fintype.card α)","decl":"theorem card_range {α β F : Type*} [FunLike F α β] [EmbeddingLike F α β] (f : F) [Fintype α]\n    [Fintype (Set.range f)] : Fintype.card (Set.range f) = Fintype.card α :=\n  Eq.symm <| Fintype.card_congr <| Equiv.ofInjective _ <| EmbeddingLike.injective f\n\n"}
{"name":"Fintype.exists_ne_map_eq_of_card_lt","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : α → β\nh : LT.lt (Fintype.card β) (Fintype.card α)\n⊢ Exists fun x => Exists fun y => And (Ne x y) (Eq (f x) (f y))","decl":"/-- The pigeonhole principle for finitely many pigeons and pigeonholes.\nThis is the `Fintype` version of `Finset.exists_ne_map_eq_of_card_lt_of_maps_to`.\n-/\ntheorem exists_ne_map_eq_of_card_lt (f : α → β) (h : Fintype.card β < Fintype.card α) :\n    ∃ x y, x ≠ y ∧ f x = f y :=\n  let ⟨x, _, y, _, h⟩ := Finset.exists_ne_map_eq_of_card_lt_of_maps_to h fun x _ => mem_univ (f x)\n  ⟨x, y, h⟩\n\n"}
{"name":"Fintype.card_eq_one_iff","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n⊢ Iff (Eq (Fintype.card α) 1) (Exists fun x => ∀ (y : α), Eq y x)","decl":"theorem card_eq_one_iff : card α = 1 ↔ ∃ x : α, ∀ y, y = x := by\n  rw [← card_unit, card_eq]\n  exact\n    ⟨fun ⟨a⟩ => ⟨a.symm (), fun y => a.injective (Subsingleton.elim _ _)⟩,\n     fun ⟨x, hx⟩ =>\n      ⟨⟨fun _ => (), fun _ => x, fun _ => (hx _).trans (hx _).symm, fun _ =>\n          Subsingleton.elim _ _⟩⟩⟩\n\n"}
{"name":"Fintype.card_eq_zero_iff","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n⊢ Iff (Eq (Fintype.card α) 0) (IsEmpty α)","decl":"theorem card_eq_zero_iff : card α = 0 ↔ IsEmpty α := by\n  rw [card, Finset.card_eq_zero, univ_eq_empty_iff]\n\n"}
{"name":"Fintype.card_eq_zero","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : IsEmpty α\n⊢ Eq (Fintype.card α) 0","decl":"@[simp] theorem card_eq_zero [IsEmpty α] : card α = 0 :=\n  card_eq_zero_iff.2 ‹_›\n\n"}
{"name":"Fintype.card_of_isEmpty","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : IsEmpty α\n⊢ Eq (Fintype.card α) 0","decl":"alias card_of_isEmpty := card_eq_zero\n\n"}
{"name":"Fintype.card_eq_one_iff_nonempty_unique","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n⊢ Iff (Eq (Fintype.card α) 1) (Nonempty (Unique α))","decl":"theorem card_eq_one_iff_nonempty_unique : card α = 1 ↔ Nonempty (Unique α) :=\n  ⟨fun h =>\n    let ⟨d, h⟩ := Fintype.card_eq_one_iff.mp h\n    ⟨{  default := d\n        uniq := h }⟩,\n    fun ⟨_h⟩ => Fintype.card_unique⟩\n\n"}
{"name":"Fintype.card_pos_iff","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n⊢ Iff (LT.lt 0 (Fintype.card α)) (Nonempty α)","decl":"theorem card_pos_iff : 0 < card α ↔ Nonempty α :=\n  Nat.pos_iff_ne_zero.trans <| not_iff_comm.mp <| not_nonempty_iff.trans card_eq_zero_iff.symm\n\n"}
{"name":"Fintype.card_pos","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Fintype α\nh : Nonempty α\n⊢ LT.lt 0 (Fintype.card α)","decl":"theorem card_pos [h : Nonempty α] : 0 < card α :=\n  card_pos_iff.mpr h\n\n"}
{"name":"Fintype.card_ne_zero","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : Nonempty α\n⊢ Ne (Fintype.card α) 0","decl":"@[simp]\ntheorem card_ne_zero [Nonempty α] : card α ≠ 0 :=\n  _root_.ne_of_gt card_pos\n\n"}
{"name":"Fintype.instNeZeroNatCardOfNonempty","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ninst✝ : Nonempty α\n⊢ NeZero (Fintype.card α)","decl":"instance [Nonempty α] : NeZero (card α) := ⟨card_ne_zero⟩\n\n"}
{"name":"Fintype.card_le_one_iff","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n⊢ Iff (LE.le (Fintype.card α) 1) (∀ (a b : α), Eq a b)","decl":"theorem card_le_one_iff : card α ≤ 1 ↔ ∀ a b : α, a = b :=\n  let n := card α\n  have hn : n = card α := rfl\n  match n, hn with\n  | 0, ha =>\n    ⟨fun _h => fun a => (card_eq_zero_iff.1 ha.symm).elim a, fun _ => ha ▸ Nat.le_succ _⟩\n  | 1, ha =>\n    ⟨fun _h => fun a b => by\n      let ⟨x, hx⟩ := card_eq_one_iff.1 ha.symm\n      rw [hx a, hx b], fun _ => ha ▸ le_rfl⟩\n  | n + 2, ha =>\n    ⟨fun h => False.elim <| by rw [← ha] at h; cases h with | step h => cases h; , fun h =>\n      card_unit ▸ card_le_of_injective (fun _ => ()) fun _ _ _ => h _ _⟩\n\n"}
{"name":"Fintype.card_le_one_iff_subsingleton","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n⊢ Iff (LE.le (Fintype.card α) 1) (Subsingleton α)","decl":"theorem card_le_one_iff_subsingleton : card α ≤ 1 ↔ Subsingleton α :=\n  card_le_one_iff.trans subsingleton_iff.symm\n\n"}
{"name":"Fintype.one_lt_card_iff_nontrivial","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n⊢ Iff (LT.lt 1 (Fintype.card α)) (Nontrivial α)","decl":"theorem one_lt_card_iff_nontrivial : 1 < card α ↔ Nontrivial α := by\n  rw [← not_iff_not, not_lt, not_nontrivial_iff_subsingleton, card_le_one_iff_subsingleton]\n\n"}
{"name":"Fintype.exists_ne_of_one_lt_card","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Fintype α\nh : LT.lt 1 (Fintype.card α)\na : α\n⊢ Exists fun b => Ne b a","decl":"theorem exists_ne_of_one_lt_card (h : 1 < card α) (a : α) : ∃ b : α, b ≠ a :=\n  haveI : Nontrivial α := one_lt_card_iff_nontrivial.1 h\n  exists_ne a\n\n"}
{"name":"Fintype.exists_pair_of_one_lt_card","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Fintype α\nh : LT.lt 1 (Fintype.card α)\n⊢ Exists fun a => Exists fun b => Ne a b","decl":"theorem exists_pair_of_one_lt_card (h : 1 < card α) : ∃ a b : α, a ≠ b :=\n  haveI : Nontrivial α := one_lt_card_iff_nontrivial.1 h\n  exists_pair_ne α\n\n"}
{"name":"Fintype.card_eq_one_of_forall_eq","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Fintype α\ni : α\nh : ∀ (j : α), Eq j i\n⊢ Eq (Fintype.card α) 1","decl":"theorem card_eq_one_of_forall_eq {i : α} (h : ∀ j, j = i) : card α = 1 :=\n  Fintype.card_eq_one_iff.2 ⟨i, h⟩\n\n"}
{"name":"Fintype.existsUnique_iff_card_one","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ninst✝¹ : Fintype α\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Iff (ExistsUnique fun a => p a) (Eq (Finset.filter (fun x => p x) Finset.univ).card 1)","decl":"theorem existsUnique_iff_card_one {α} [Fintype α] (p : α → Prop) [DecidablePred p] :\n    (∃! a : α, p a) ↔ #{x | p x} = 1 := by\n  rw [Finset.card_eq_one]\n  refine exists_congr fun x => ?_\n  simp only [forall_true_left, Subset.antisymm_iff, subset_singleton_iff', singleton_subset_iff,\n      true_and, and_comm, mem_univ, mem_filter]\n\n"}
{"name":"Fintype.exists_unique_iff_card_one","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ninst✝¹ : Fintype α\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Iff (ExistsUnique fun a => p a) (Eq (Finset.filter (fun x => p x) Finset.univ).card 1)","decl":"@[deprecated (since := \"2024-12-17\")] alias exists_unique_iff_card_one := existsUnique_iff_card_one\n\n"}
{"name":"Fintype.one_lt_card","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Fintype α\nh : Nontrivial α\n⊢ LT.lt 1 (Fintype.card α)","decl":"theorem one_lt_card [h : Nontrivial α] : 1 < Fintype.card α :=\n  Fintype.one_lt_card_iff_nontrivial.mpr h\n\n"}
{"name":"Fintype.one_lt_card_iff","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n⊢ Iff (LT.lt 1 (Fintype.card α)) (Exists fun a => Exists fun b => Ne a b)","decl":"theorem one_lt_card_iff : 1 < card α ↔ ∃ a b : α, a ≠ b :=\n  one_lt_card_iff_nontrivial.trans nontrivial_iff\n\n"}
{"name":"Fintype.two_lt_card_iff","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Fintype α\n⊢ Iff (LT.lt 2 (Fintype.card α)) (Exists fun a => Exists fun b => Exists fun c => And (Ne a b) (And (Ne a c) (Ne b c)))","decl":"nonrec theorem two_lt_card_iff : 2 < card α ↔ ∃ a b c : α, a ≠ b ∧ a ≠ c ∧ b ≠ c := by\n  simp_rw [← Finset.card_univ, two_lt_card_iff, mem_univ, true_and]\n\n"}
{"name":"Fintype.card_of_bijective","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : α → β\nhf : Function.Bijective f\n⊢ Eq (Fintype.card α) (Fintype.card β)","decl":"theorem card_of_bijective {f : α → β} (hf : Bijective f) : card α = card β :=\n  card_congr (Equiv.ofBijective f hf)\n\n"}
{"name":"Finite.surjective_of_injective","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Finite α\nf : α → α\nhinj : Function.Injective f\n⊢ Function.Surjective f","decl":"theorem surjective_of_injective {f : α → α} (hinj : Injective f) : Surjective f := by\n  intro x\n  have := Classical.propDecidable\n  cases nonempty_fintype α\n  have h₁ : image f univ = univ :=\n    eq_of_subset_of_card_le (subset_univ _)\n      ((card_image_of_injective univ hinj).symm ▸ le_rfl)\n  have h₂ : x ∈ image f univ := h₁.symm ▸ mem_univ x\n  obtain ⟨y, h⟩ := mem_image.1 h₂\n  exact ⟨y, h.2⟩\n\n"}
{"name":"Finite.injective_iff_surjective","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Finite α\nf : α → α\n⊢ Iff (Function.Injective f) (Function.Surjective f)","decl":"theorem injective_iff_surjective {f : α → α} : Injective f ↔ Surjective f :=\n  ⟨surjective_of_injective, fun hsurj =>\n    HasLeftInverse.injective ⟨surjInv hsurj, leftInverse_of_surjective_of_rightInverse\n      (surjective_of_injective (injective_surjInv _))\n      (rightInverse_surjInv _)⟩⟩\n\n"}
{"name":"Finite.injective_iff_bijective","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Finite α\nf : α → α\n⊢ Iff (Function.Injective f) (Function.Bijective f)","decl":"theorem injective_iff_bijective {f : α → α} : Injective f ↔ Bijective f := by\n  simp [Bijective, injective_iff_surjective]\n\n"}
{"name":"Finite.surjective_iff_bijective","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Finite α\nf : α → α\n⊢ Iff (Function.Surjective f) (Function.Bijective f)","decl":"theorem surjective_iff_bijective {f : α → α} : Surjective f ↔ Bijective f := by\n  simp [Bijective, injective_iff_surjective]\n\n"}
{"name":"Finite.injective_iff_surjective_of_equiv","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Finite α\nf : α → β\ne : Equiv α β\n⊢ Iff (Function.Injective f) (Function.Surjective f)","decl":"theorem injective_iff_surjective_of_equiv {f : α → β} (e : α ≃ β) : Injective f ↔ Surjective f :=\n  have : Injective (e.symm ∘ f) ↔ Surjective (e.symm ∘ f) := injective_iff_surjective\n  ⟨fun hinj => by\n    simpa [Function.comp] using e.surjective.comp (this.1 (e.symm.injective.comp hinj)),\n    fun hsurj => by\n    simpa [Function.comp] using e.injective.comp (this.2 (e.symm.surjective.comp hsurj))⟩\n\n"}
{"name":"Function.Injective.bijective_of_finite","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Finite α\nf : α → α\na✝ : Function.Injective f\n⊢ Function.Bijective f","decl":"alias ⟨_root_.Function.Injective.bijective_of_finite, _⟩ := injective_iff_bijective\n\n"}
{"name":"Function.Surjective.bijective_of_finite","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Finite α\nf : α → α\na✝ : Function.Surjective f\n⊢ Function.Bijective f","decl":"alias ⟨_root_.Function.Surjective.bijective_of_finite, _⟩ := surjective_iff_bijective\n\n"}
{"name":"Function.Surjective.injective_of_fintype","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Finite α\nf : α → β\ne : Equiv α β\na✝ : Function.Surjective f\n⊢ Function.Injective f","decl":"alias ⟨_root_.Function.Injective.surjective_of_fintype,\n    _root_.Function.Surjective.injective_of_fintype⟩ :=\n  injective_iff_surjective_of_equiv\n\n"}
{"name":"Function.Injective.surjective_of_fintype","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Finite α\nf : α → β\ne : Equiv α β\na✝ : Function.Injective f\n⊢ Function.Surjective f","decl":"alias ⟨_root_.Function.Injective.surjective_of_fintype,\n    _root_.Function.Surjective.injective_of_fintype⟩ :=\n  injective_iff_surjective_of_equiv\n\n"}
{"name":"Fintype.bijective_iff_injective_and_card","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : α → β\n⊢ Iff (Function.Bijective f) (And (Function.Injective f) (Eq (Fintype.card α) (Fintype.card β)))","decl":"theorem bijective_iff_injective_and_card (f : α → β) :\n    Bijective f ↔ Injective f ∧ card α = card β :=\n  ⟨fun h => ⟨h.1, card_of_bijective h⟩, fun h =>\n    ⟨h.1, h.1.surjective_of_fintype <| equivOfCardEq h.2⟩⟩\n\n"}
{"name":"Fintype.bijective_iff_surjective_and_card","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : α → β\n⊢ Iff (Function.Bijective f) (And (Function.Surjective f) (Eq (Fintype.card α) (Fintype.card β)))","decl":"theorem bijective_iff_surjective_and_card (f : α → β) :\n    Bijective f ↔ Surjective f ∧ card α = card β :=\n  ⟨fun h => ⟨h.2, card_of_bijective h⟩, fun h =>\n    ⟨h.1.injective_of_fintype <| equivOfCardEq h.2, h.1⟩⟩\n\n"}
{"name":"Function.LeftInverse.rightInverse_of_card_le","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : α → β\ng : β → α\nhfg : Function.LeftInverse f g\nhcard : LE.le (Fintype.card α) (Fintype.card β)\n⊢ Function.RightInverse f g","decl":"theorem _root_.Function.LeftInverse.rightInverse_of_card_le {f : α → β} {g : β → α}\n    (hfg : LeftInverse f g) (hcard : card α ≤ card β) : RightInverse f g :=\n  have hsurj : Surjective f := surjective_iff_hasRightInverse.2 ⟨g, hfg⟩\n  rightInverse_of_injective_of_leftInverse\n    ((bijective_iff_surjective_and_card _).2\n        ⟨hsurj, le_antisymm hcard (card_le_of_surjective f hsurj)⟩).1\n    hfg\n\n"}
{"name":"Function.RightInverse.leftInverse_of_card_le","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : α → β\ng : β → α\nhfg : Function.RightInverse f g\nhcard : LE.le (Fintype.card β) (Fintype.card α)\n⊢ Function.LeftInverse f g","decl":"theorem _root_.Function.RightInverse.leftInverse_of_card_le {f : α → β} {g : β → α}\n    (hfg : RightInverse f g) (hcard : card β ≤ card α) : LeftInverse f g :=\n  Function.LeftInverse.rightInverse_of_card_le hfg hcard\n\n"}
{"name":"Equiv.ofLeftInverseOfCardLE_apply","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nhβα : LE.le (Fintype.card β) (Fintype.card α)\nf : α → β\ng : β → α\nh : Function.LeftInverse g f\na✝ : α\n⊢ Eq ((Equiv.ofLeftInverseOfCardLE hβα f g h) a✝) (f a✝)","decl":"/-- Construct an equivalence from functions that are inverse to each other. -/\n@[simps]\ndef ofLeftInverseOfCardLE (hβα : card β ≤ card α) (f : α → β) (g : β → α) (h : LeftInverse g f) :\n    α ≃ β where\n  toFun := f\n  invFun := g\n  left_inv := h\n  right_inv := h.rightInverse_of_card_le hβα\n\n"}
{"name":"Equiv.ofLeftInverseOfCardLE_symm_apply","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nhβα : LE.le (Fintype.card β) (Fintype.card α)\nf : α → β\ng : β → α\nh : Function.LeftInverse g f\na✝ : β\n⊢ Eq ((Equiv.ofLeftInverseOfCardLE hβα f g h).symm a✝) (g a✝)","decl":"/-- Construct an equivalence from functions that are inverse to each other. -/\n@[simps]\ndef ofLeftInverseOfCardLE (hβα : card β ≤ card α) (f : α → β) (g : β → α) (h : LeftInverse g f) :\n    α ≃ β where\n  toFun := f\n  invFun := g\n  left_inv := h\n  right_inv := h.rightInverse_of_card_le hβα\n\n"}
{"name":"Equiv.ofRightInverseOfCardLE_symm_apply","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nhαβ : LE.le (Fintype.card α) (Fintype.card β)\nf : α → β\ng : β → α\nh : Function.RightInverse g f\na✝ : β\n⊢ Eq ((Equiv.ofRightInverseOfCardLE hαβ f g h).symm a✝) (g a✝)","decl":"/-- Construct an equivalence from functions that are inverse to each other. -/\n@[simps]\ndef ofRightInverseOfCardLE (hαβ : card α ≤ card β) (f : α → β) (g : β → α) (h : RightInverse g f) :\n    α ≃ β where\n  toFun := f\n  invFun := g\n  left_inv := h.leftInverse_of_card_le hαβ\n  right_inv := h\n\n"}
{"name":"Equiv.ofRightInverseOfCardLE_apply","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nhαβ : LE.le (Fintype.card α) (Fintype.card β)\nf : α → β\ng : β → α\nh : Function.RightInverse g f\na✝ : α\n⊢ Eq ((Equiv.ofRightInverseOfCardLE hαβ f g h) a✝) (f a✝)","decl":"/-- Construct an equivalence from functions that are inverse to each other. -/\n@[simps]\ndef ofRightInverseOfCardLE (hαβ : card α ≤ card β) (f : α → β) (g : β → α) (h : RightInverse g f) :\n    α ≃ β where\n  toFun := f\n  invFun := g\n  left_inv := h.leftInverse_of_card_le hαβ\n  right_inv := h\n\n"}
{"name":"Fintype.card_coe","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ns : Finset α\ninst✝ : Fintype (Subtype fun x => Membership.mem s x)\n⊢ Eq (Fintype.card (Subtype fun x => Membership.mem s x)) s.card","decl":"@[simp]\ntheorem Fintype.card_coe (s : Finset α) [Fintype s] : Fintype.card s = #s :=\n  @Fintype.card_of_finset' _ _ _ (fun _ => Iff.rfl) (id _)\n\n"}
{"name":"Finset.card_eq_of_equiv_fin","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ns : Finset α\nn : Nat\ni : Equiv (Subtype fun x => Membership.mem s x) (Fin n)\n⊢ Eq s.card n","decl":"theorem Finset.card_eq_of_equiv_fin {s : Finset α} {n : ℕ} (i : s ≃ Fin n) : #s = n :=\n  Fin.equiv_iff_eq.1 ⟨s.equivFin.symm.trans i⟩\n\n"}
{"name":"Finset.card_eq_of_equiv_fintype","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\ninst✝ : Fintype β\ni : Equiv (Subtype fun x => Membership.mem s x) β\n⊢ Eq s.card (Fintype.card β)","decl":"theorem Finset.card_eq_of_equiv_fintype {s : Finset α} [Fintype β] (i : s ≃ β) :\n    #s = Fintype.card β := card_eq_of_equiv_fin <| i.trans <| Fintype.equivFin β\n\n"}
{"name":"Finset.card_eq_of_equiv","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Finset α\nt : Finset β\ni : Equiv (Subtype fun x => Membership.mem s x) (Subtype fun x => Membership.mem t x)\n⊢ Eq s.card t.card","decl":"theorem Finset.card_eq_of_equiv {s : Finset α} {t : Finset β} (i : s ≃ t) : #s = #t :=\n  (card_eq_of_equiv_fintype i).trans (Fintype.card_coe _)\n\n"}
{"name":"Finset.exists_superset_card_eq","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Fintype α\nn : Nat\ns : Finset α\nhsn : LE.le s.card n\nhnα : LE.le n (Fintype.card α)\n⊢ Exists fun t => And (HasSubset.Subset s t) (Eq t.card n)","decl":"/-- We can inflate a set `s` to any bigger size. -/\nlemma Finset.exists_superset_card_eq [Fintype α] {n : ℕ} {s : Finset α} (hsn : #s ≤ n)\n    (hnα : n ≤ Fintype.card α) :\n    ∃ t, s ⊆ t ∧ #t = n := by simpa using exists_subsuperset_card_eq s.subset_univ hsn hnα\n\n"}
{"name":"Fintype.card_prop","module":"Mathlib.Data.Fintype.Card","initialProofState":"⊢ Eq (Fintype.card Prop) 2","decl":"@[simp]\ntheorem Fintype.card_prop : Fintype.card Prop = 2 :=\n  rfl\n\n"}
{"name":"set_fintype_card_le_univ","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ns : Set α\ninst✝ : Fintype ↑s\n⊢ LE.le (Fintype.card ↑s) (Fintype.card α)","decl":"theorem set_fintype_card_le_univ [Fintype α] (s : Set α) [Fintype s] :\n    Fintype.card s ≤ Fintype.card α :=\n  Fintype.card_le_of_embedding (Function.Embedding.subtype s)\n\n"}
{"name":"set_fintype_card_eq_univ_iff","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ns : Set α\ninst✝ : Fintype ↑s\n⊢ Iff (Eq (Fintype.card ↑s) (Fintype.card α)) (Eq s Set.univ)","decl":"theorem set_fintype_card_eq_univ_iff [Fintype α] (s : Set α) [Fintype s] :\n    Fintype.card s = Fintype.card α ↔ s = Set.univ := by\n  rw [← Set.toFinset_card, Finset.card_eq_iff_eq_univ, ← Set.toFinset_univ, Set.toFinset_inj]\n\n"}
{"name":"Function.Embedding.toEmbedding_equivOfFiniteSelfEmbedding","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Finite α\ne : Function.Embedding α α\n⊢ Eq e.equivOfFiniteSelfEmbedding.toEmbedding e","decl":"@[simp]\ntheorem toEmbedding_equivOfFiniteSelfEmbedding [Finite α] (e : α ↪ α) :\n    e.equivOfFiniteSelfEmbedding.toEmbedding = e := by\n  ext\n  rfl\n\n"}
{"name":"Function.Embedding.equiv_of_fintype_self_embedding_to_embedding","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Finite α\ne : Function.Embedding α α\n⊢ Eq e.equivOfFiniteSelfEmbedding.toEmbedding e","decl":"@[deprecated (since := \"2024-12-05\")]\nalias equiv_of_fintype_self_embedding_to_embedding := toEmbedding_equivOfFiniteSelfEmbedding\n\n"}
{"name":"Equiv.embeddingEquivOfFinite_symm_apply","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ninst✝ : Finite α\ne : Equiv α α\n⊢ Eq ((Equiv.embeddingEquivOfFinite α).symm e) e.toEmbedding","decl":"/-- On a finite type, equivalence between the self-embeddings and the bijections. -/\n@[simps] noncomputable def _root_.Equiv.embeddingEquivOfFinite (α : Type*) [Finite α] :\n    (α ↪ α) ≃ (α ≃ α) where\n  toFun e := e.equivOfFiniteSelfEmbedding\n  invFun e := e.toEmbedding\n  left_inv e := rfl\n  right_inv e := by ext; rfl\n\n"}
{"name":"Equiv.embeddingEquivOfFinite_apply","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ninst✝ : Finite α\ne : Function.Embedding α α\n⊢ Eq ((Equiv.embeddingEquivOfFinite α) e) e.equivOfFiniteSelfEmbedding","decl":"/-- On a finite type, equivalence between the self-embeddings and the bijections. -/\n@[simps] noncomputable def _root_.Equiv.embeddingEquivOfFinite (α : Type*) [Finite α] :\n    (α ↪ α) ≃ (α ≃ α) where\n  toFun e := e.equivOfFiniteSelfEmbedding\n  invFun e := e.toEmbedding\n  left_inv e := rfl\n  right_inv e := by ext; rfl\n\n"}
{"name":"Function.Embedding.isEmpty_of_card_lt","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nh : LT.lt (Fintype.card β) (Fintype.card α)\n⊢ IsEmpty (Function.Embedding α β)","decl":"/-- If `‖β‖ < ‖α‖` there are no embeddings `α ↪ β`.\nThis is a formulation of the pigeonhole principle.\n\nNote this cannot be an instance as it needs `h`. -/\n@[simp]\ntheorem isEmpty_of_card_lt [Fintype α] [Fintype β] (h : Fintype.card β < Fintype.card α) :\n    IsEmpty (α ↪ β) :=\n  ⟨fun f =>\n    let ⟨_x, _y, ne, feq⟩ := Fintype.exists_ne_map_eq_of_card_lt f h\n    ne <| f.injective feq⟩\n\n"}
{"name":"Function.Embedding.nonempty_of_card_le","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nh : LE.le (Fintype.card α) (Fintype.card β)\n⊢ Nonempty (Function.Embedding α β)","decl":"theorem nonempty_of_card_le [Fintype α] [Fintype β] (h : Fintype.card α ≤ Fintype.card β) :\n    Nonempty (α ↪ β) := by classical exact (truncOfCardLE h).nonempty\n\n"}
{"name":"Function.Embedding.nonempty_iff_card_le","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\n⊢ Iff (Nonempty (Function.Embedding α β)) (LE.le (Fintype.card α) (Fintype.card β))","decl":"theorem nonempty_iff_card_le [Fintype α] [Fintype β] :\n    Nonempty (α ↪ β) ↔ Fintype.card α ≤ Fintype.card β :=\n  ⟨fun ⟨e⟩ => Fintype.card_le_of_embedding e, nonempty_of_card_le⟩\n\n"}
{"name":"Function.Embedding.exists_of_card_le_finset","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Fintype α\ns : Finset β\nh : LE.le (Fintype.card α) s.card\n⊢ Exists fun f => HasSubset.Subset (Set.range ⇑f) ↑s","decl":"theorem exists_of_card_le_finset [Fintype α] {s : Finset β} (h : Fintype.card α ≤ #s) :\n    ∃ f : α ↪ β, Set.range f ⊆ s := by\n  rw [← Fintype.card_coe] at h\n  rcases nonempty_of_card_le h with ⟨f⟩\n  exact ⟨f.trans (Embedding.subtype _), by simp [Set.range_subset_iff]⟩\n\n"}
{"name":"Finset.univ_map_embedding","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ninst✝ : Fintype α\ne : Function.Embedding α α\n⊢ Eq (Finset.map e Finset.univ) Finset.univ","decl":"@[simp]\ntheorem Finset.univ_map_embedding {α : Type*} [Fintype α] (e : α ↪ α) : univ.map e = univ := by\n  rw [← e.toEmbedding_equivOfFiniteSelfEmbedding, univ_map_equiv_to_embedding]\n\n"}
{"name":"Fintype.card_lt_of_surjective_not_injective","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : α → β\nh : Function.Surjective f\nh' : Not (Function.Injective f)\n⊢ LT.lt (Fintype.card β) (Fintype.card α)","decl":"theorem card_lt_of_surjective_not_injective [Fintype α] [Fintype β] (f : α → β)\n    (h : Function.Surjective f) (h' : ¬Function.Injective f) : card β < card α :=\n  card_lt_of_injective_not_surjective _ (Function.injective_surjInv h) fun hg =>\n    have w : Function.Bijective (Function.surjInv h) := ⟨Function.injective_surjInv h, hg⟩\n    h' <| h.injective_of_fintype (Equiv.ofBijective _ w).symm\n\n"}
{"name":"Fintype.card_subtype_le","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\np : α → Prop\ninst✝ : DecidablePred p\n⊢ LE.le (Fintype.card (Subtype fun x => p x)) (Fintype.card α)","decl":"theorem Fintype.card_subtype_le [Fintype α] (p : α → Prop) [DecidablePred p] :\n    Fintype.card { x // p x } ≤ Fintype.card α :=\n  Fintype.card_le_of_embedding (Function.Embedding.subtype _)\n\n"}
{"name":"Fintype.card_subtype_lt","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\np : α → Prop\ninst✝ : DecidablePred p\nx : α\nhx : Not (p x)\n⊢ LT.lt (Fintype.card (Subtype fun x => p x)) (Fintype.card α)","decl":"theorem Fintype.card_subtype_lt [Fintype α] {p : α → Prop} [DecidablePred p] {x : α} (hx : ¬p x) :\n    Fintype.card { x // p x } < Fintype.card α :=\n  Fintype.card_lt_of_injective_of_not_mem (b := x) (↑) Subtype.coe_injective <| by\n    rwa [Subtype.range_coe_subtype]\n\n"}
{"name":"Fintype.card_subtype","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Fintype.card (Subtype fun x => p x)) (Finset.filter (fun x => p x) Finset.univ).card","decl":"theorem Fintype.card_subtype [Fintype α] (p : α → Prop) [DecidablePred p] :\n    Fintype.card { x // p x } = #{x | p x} := by\n  refine Fintype.card_of_subtype _ ?_\n  simp\n\n"}
{"name":"Fintype.card_subtype_compl","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝² : Fintype α\np : α → Prop\ninst✝¹ : Fintype (Subtype fun x => p x)\ninst✝ : Fintype (Subtype fun x => Not (p x))\n⊢ Eq (Fintype.card (Subtype fun x => Not (p x))) (HSub.hSub (Fintype.card α) (Fintype.card (Subtype fun x => p x)))","decl":"@[simp]\ntheorem Fintype.card_subtype_compl [Fintype α] (p : α → Prop) [Fintype { x // p x }]\n    [Fintype { x // ¬p x }] :\n    Fintype.card { x // ¬p x } = Fintype.card α - Fintype.card { x // p x } := by\n  classical\n    rw [Fintype.card_of_subtype (Set.toFinset { x | p x }ᶜ), Set.toFinset_compl,\n      Finset.card_compl, Fintype.card_of_subtype] <;>\n    · intro\n      simp only [Set.mem_toFinset, Set.mem_compl_iff, Set.mem_setOf]\n\n"}
{"name":"Fintype.card_subtype_mono","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\np q : α → Prop\nh : LE.le p q\ninst✝¹ : Fintype (Subtype fun x => p x)\ninst✝ : Fintype (Subtype fun x => q x)\n⊢ LE.le (Fintype.card (Subtype fun x => p x)) (Fintype.card (Subtype fun x => q x))","decl":"theorem Fintype.card_subtype_mono (p q : α → Prop) (h : p ≤ q) [Fintype { x // p x }]\n    [Fintype { x // q x }] : Fintype.card { x // p x } ≤ Fintype.card { x // q x } :=\n  Fintype.card_le_of_embedding (Subtype.impEmbedding _ _ h)\n\n"}
{"name":"Fintype.card_compl_eq_card_compl","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝⁴ : Finite α\np q : α → Prop\ninst✝³ : Fintype (Subtype fun x => p x)\ninst✝² : Fintype (Subtype fun x => Not (p x))\ninst✝¹ : Fintype (Subtype fun x => q x)\ninst✝ : Fintype (Subtype fun x => Not (q x))\nh : Eq (Fintype.card (Subtype fun x => p x)) (Fintype.card (Subtype fun x => q x))\n⊢ Eq (Fintype.card (Subtype fun x => Not (p x))) (Fintype.card (Subtype fun x => Not (q x)))","decl":"/-- If two subtypes of a fintype have equal cardinality, so do their complements. -/\ntheorem Fintype.card_compl_eq_card_compl [Finite α] (p q : α → Prop) [Fintype { x // p x }]\n    [Fintype { x // ¬p x }] [Fintype { x // q x }] [Fintype { x // ¬q x }]\n    (h : Fintype.card { x // p x } = Fintype.card { x // q x }) :\n    Fintype.card { x // ¬p x } = Fintype.card { x // ¬q x } := by\n  cases nonempty_fintype α\n  simp only [Fintype.card_subtype_compl, h]\n\n"}
{"name":"Fintype.card_quotient_le","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ns : Setoid α\ninst✝ : DecidableRel fun x1 x2 => HasEquiv.Equiv x1 x2\n⊢ LE.le (Fintype.card (Quotient s)) (Fintype.card α)","decl":"theorem Fintype.card_quotient_le [Fintype α] (s : Setoid α)\n    [DecidableRel ((· ≈ ·) : α → α → Prop)] : Fintype.card (Quotient s) ≤ Fintype.card α :=\n  Fintype.card_le_of_surjective _ Quotient.mk'_surjective\n\n"}
{"name":"Fintype.card_quotient_lt","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝¹ : Fintype α\ns : Setoid α\ninst✝ : DecidableRel fun x1 x2 => HasEquiv.Equiv x1 x2\nx y : α\nh1 : Ne x y\nh2 : HasEquiv.Equiv x y\n⊢ LT.lt (Fintype.card (Quotient s)) (Fintype.card α)","decl":"theorem Fintype.card_quotient_lt [Fintype α] {s : Setoid α} [DecidableRel ((· ≈ ·) : α → α → Prop)]\n    {x y : α} (h1 : x ≠ y) (h2 : x ≈ y) : Fintype.card (Quotient s) < Fintype.card α :=\n  Fintype.card_lt_of_surjective_not_injective _ Quotient.mk'_surjective fun w =>\n    h1 (w <| Quotient.eq.mpr h2)\n\n"}
{"name":"univ_eq_singleton_of_card_one","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ninst✝ : Fintype α\nx : α\nh : Eq (Fintype.card α) 1\n⊢ Eq Finset.univ (Singleton.singleton x)","decl":"theorem univ_eq_singleton_of_card_one {α} [Fintype α] (x : α) (h : Fintype.card α = 1) :\n    (univ : Finset α) = {x} := by\n  symm\n  apply eq_of_subset_of_card_le (subset_univ {x})\n  apply le_of_eq\n  simp [h, Finset.card_univ]\n\n"}
{"name":"Finite.wellFounded_of_trans_of_irrefl","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝² : Finite α\nr : α → α → Prop\ninst✝¹ : IsTrans α r\ninst✝ : IsIrrefl α r\n⊢ WellFounded r","decl":"theorem wellFounded_of_trans_of_irrefl (r : α → α → Prop) [IsTrans α r] [IsIrrefl α r] :\n    WellFounded r := by\n  classical\n  cases nonempty_fintype α\n  have (x y) (hxy : r x y) : #{z | r z x} < #{z | r z y} :=\n    Finset.card_lt_card <| by\n      simp only [Finset.lt_iff_ssubset.symm, lt_iff_le_not_le, Finset.le_iff_subset,\n          Finset.subset_iff, mem_filter, true_and, mem_univ, hxy]\n      exact\n        ⟨fun z hzx => _root_.trans hzx hxy,\n          not_forall_of_exists_not ⟨x, Classical.not_imp.2 ⟨hxy, irrefl x⟩⟩⟩\n  exact Subrelation.wf (this _ _) (measure _).wf\n\n-- See note [lower instance priority]\n"}
{"name":"Finite.to_wellFoundedLT","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝¹ : Finite α\ninst✝ : Preorder α\n⊢ WellFoundedLT α","decl":"instance (priority := 100) to_wellFoundedLT [Preorder α] : WellFoundedLT α :=\n  ⟨wellFounded_of_trans_of_irrefl _⟩\n\n-- See note [lower instance priority]\n"}
{"name":"Finite.to_wellFoundedGT","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝¹ : Finite α\ninst✝ : Preorder α\n⊢ WellFoundedGT α","decl":"instance (priority := 100) to_wellFoundedGT [Preorder α] : WellFoundedGT α :=\n  ⟨wellFounded_of_trans_of_irrefl _⟩\n\n"}
{"name":"Bool.instWellFoundedLT","module":"Mathlib.Data.Fintype.Card","initialProofState":"⊢ WellFoundedLT Bool","decl":"instance Bool.instWellFoundedLT : WellFoundedLT Bool := inferInstance\n"}
{"name":"Bool.instWellFoundedGT","module":"Mathlib.Data.Fintype.Card","initialProofState":"⊢ WellFoundedGT Bool","decl":"instance Bool.instWellFoundedGT : WellFoundedGT Bool := inferInstance\n"}
{"name":"Prop.instWellFoundedLT","module":"Mathlib.Data.Fintype.Card","initialProofState":"⊢ WellFoundedLT Prop","decl":"instance Prop.instWellFoundedLT : WellFoundedLT Prop := inferInstance\n"}
{"name":"Prop.instWellFoundedGT","module":"Mathlib.Data.Fintype.Card","initialProofState":"⊢ WellFoundedGT Prop","decl":"instance Prop.instWellFoundedGT : WellFoundedGT Prop := inferInstance\n\n-- @[nolint fintype_finite] -- Porting note: do we need this?\n"}
{"name":"Fintype.false","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Infinite α\n_h : Fintype α\n⊢ False","decl":"protected theorem Fintype.false [Infinite α] (_h : Fintype α) : False :=\n  not_finite α\n\n"}
{"name":"isEmpty_fintype","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\n⊢ Iff (IsEmpty (Fintype α)) (Infinite α)","decl":"@[simp]\ntheorem isEmpty_fintype {α : Type*} : IsEmpty (Fintype α) ↔ Infinite α :=\n  ⟨fun ⟨h⟩ => ⟨fun h' => (@nonempty_fintype α h').elim h⟩, fun ⟨h⟩ => ⟨fun h' => h h'.finite⟩⟩\n\n"}
{"name":"Finset.exists_minimal","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ninst✝ : Preorder α\ns : Finset α\nh : s.Nonempty\n⊢ Exists fun m => And (Membership.mem s m) (∀ (x : α), Membership.mem s x → Not (LT.lt x m))","decl":"theorem Finset.exists_minimal {α : Type*} [Preorder α] (s : Finset α) (h : s.Nonempty) :\n    ∃ m ∈ s, ∀ x ∈ s, ¬x < m := by\n  obtain ⟨c, hcs : c ∈ s⟩ := h\n  have : WellFounded (@LT.lt { x // x ∈ s } _) := Finite.wellFounded_of_trans_of_irrefl _\n  obtain ⟨⟨m, hms : m ∈ s⟩, -, H⟩ := this.has_min Set.univ ⟨⟨c, hcs⟩, trivial⟩\n  exact ⟨m, hms, fun x hx hxm => H ⟨x, hx⟩ trivial hxm⟩\n\n"}
{"name":"Finset.exists_maximal","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ninst✝ : Preorder α\ns : Finset α\nh : s.Nonempty\n⊢ Exists fun m => And (Membership.mem s m) (∀ (x : α), Membership.mem s x → Not (LT.lt m x))","decl":"theorem Finset.exists_maximal {α : Type*} [Preorder α] (s : Finset α) (h : s.Nonempty) :\n    ∃ m ∈ s, ∀ x ∈ s, ¬m < x :=\n  @Finset.exists_minimal αᵒᵈ _ s h\n\n"}
{"name":"Infinite.of_not_fintype","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nh : Fintype α → False\n⊢ Infinite α","decl":"theorem of_not_fintype (h : Fintype α → False) : Infinite α :=\n  isEmpty_fintype.mp ⟨h⟩\n\n"}
{"name":"Infinite.of_injective_to_set","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : Ne s Set.univ\nf : α → ↑s\nhf : Function.Injective f\n⊢ Infinite α","decl":"/-- If `s : Set α` is a proper subset of `α` and `f : α → s` is injective, then `α` is infinite. -/\ntheorem of_injective_to_set {s : Set α} (hs : s ≠ Set.univ) {f : α → s} (hf : Injective f) :\n    Infinite α :=\n  of_not_fintype fun h => by\n    classical\n      refine lt_irrefl (Fintype.card α) ?_\n      calc\n        Fintype.card α ≤ Fintype.card s := Fintype.card_le_of_injective f hf\n        _ = #s.toFinset := s.toFinset_card.symm\n        _ < Fintype.card α :=\n          Finset.card_lt_card <| by rwa [Set.toFinset_ssubset_univ, Set.ssubset_univ_iff]\n\n"}
{"name":"Infinite.of_surjective_from_set","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ns : Set α\nhs : Ne s Set.univ\nf : ↑s → α\nhf : Function.Surjective f\n⊢ Infinite α","decl":"/-- If `s : Set α` is a proper subset of `α` and `f : s → α` is surjective, then `α` is infinite. -/\ntheorem of_surjective_from_set {s : Set α} (hs : s ≠ Set.univ) {f : s → α} (hf : Surjective f) :\n    Infinite α :=\n  of_injective_to_set hs (injective_surjInv hf)\n\n"}
{"name":"Infinite.exists_not_mem_finset","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Infinite α\ns : Finset α\n⊢ Exists fun x => Not (Membership.mem s x)","decl":"theorem exists_not_mem_finset [Infinite α] (s : Finset α) : ∃ x, x ∉ s :=\n  not_forall.1 fun h => Fintype.false ⟨s, h⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"Infinite.instNontrivial","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ninst✝ : Infinite α\n⊢ Nontrivial α","decl":"instance (priority := 100) (α : Type*) [Infinite α] : Nontrivial α :=\n  ⟨let ⟨x, _hx⟩ := exists_not_mem_finset (∅ : Finset α)\n    let ⟨y, hy⟩ := exists_not_mem_finset ({x} : Finset α)\n    ⟨y, x, by simpa only [mem_singleton] using hy⟩⟩\n\n"}
{"name":"Infinite.nonempty","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ninst✝ : Infinite α\n⊢ Nonempty α","decl":"protected theorem nonempty (α : Type*) [Infinite α] : Nonempty α := by infer_instance\n\n"}
{"name":"Infinite.of_injective","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Sort u_4\nβ : Sort u_5\ninst✝ : Infinite β\nf : β → α\nhf : Function.Injective f\n⊢ Infinite α","decl":"theorem of_injective {α β} [Infinite β] (f : β → α) (hf : Injective f) : Infinite α :=\n  ⟨fun _I => (Finite.of_injective f hf).false⟩\n\n"}
{"name":"Infinite.of_surjective","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Sort u_4\nβ : Sort u_5\ninst✝ : Infinite β\nf : α → β\nhf : Function.Surjective f\n⊢ Infinite α","decl":"theorem of_surjective {α β} [Infinite β] (f : α → β) (hf : Surjective f) : Infinite α :=\n  ⟨fun _I => (Finite.of_surjective f hf).false⟩\n\n"}
{"name":"Infinite.instSigmaOfNonempty","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : α → Type u_4\ninst✝¹ : Infinite α\ninst✝ : ∀ (a : α), Nonempty (β a)\n⊢ Infinite (Sigma fun a => β a)","decl":"instance {β : α → Type*} [Infinite α] [∀ a, Nonempty (β a)] : Infinite ((a : α) × β a) :=\n  Infinite.of_surjective Sigma.fst Sigma.fst_surjective\n\n"}
{"name":"Infinite.sigma_of_right","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : α → Type u_4\na : α\ninst✝ : Infinite (β a)\n⊢ Infinite (Sigma fun a => β a)","decl":"theorem sigma_of_right {β : α → Type*} {a : α} [Infinite (β a)] :\n    Infinite ((a : α) × β a) :=\n  Infinite.of_injective (f := fun x ↦ ⟨a,x⟩) fun _ _ ↦ by simp\n\n"}
{"name":"Infinite.instSigmaOfNonempty_1","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : α → Type u_4\ninst✝¹ : Nonempty α\ninst✝ : ∀ (a : α), Infinite (β a)\n⊢ Infinite (Sigma fun a => β a)","decl":"instance {β : α → Type*} [Nonempty α] [∀ a, Infinite (β a)] : Infinite ((a : α) × β a) :=\n  Infinite.sigma_of_right (a := Classical.arbitrary α)\n\n"}
{"name":"instInfiniteNat","module":"Mathlib.Data.Fintype.Card","initialProofState":"⊢ Infinite Nat","decl":"instance : Infinite ℕ :=\n  Infinite.of_not_fintype <| by\n    intro h\n    exact (Finset.range _).card_le_univ.not_lt ((Nat.lt_succ_self _).trans_eq (card_range _).symm)\n\n"}
{"name":"Int.infinite","module":"Mathlib.Data.Fintype.Card","initialProofState":"⊢ Infinite Int","decl":"instance Int.infinite : Infinite ℤ :=\n  Infinite.of_injective Int.ofNat fun _ _ => Int.ofNat.inj\n\n"}
{"name":"instInfiniteMultisetOfNonempty","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Nonempty α\n⊢ Infinite (Multiset α)","decl":"instance [Nonempty α] : Infinite (Multiset α) :=\n  let ⟨x⟩ := ‹Nonempty α›\n  Infinite.of_injective (fun n => Multiset.replicate n x) (Multiset.replicate_left_injective _)\n\n"}
{"name":"instInfiniteListOfNonempty","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Nonempty α\n⊢ Infinite (List α)","decl":"instance [Nonempty α] : Infinite (List α) :=\n  Infinite.of_surjective ((↑) : List α → Multiset α) Quot.mk_surjective\n\n"}
{"name":"String.infinite","module":"Mathlib.Data.Fintype.Card","initialProofState":"⊢ Infinite String","decl":"instance String.infinite : Infinite String :=\n  Infinite.of_injective (String.mk) <| by\n    intro _ _ h\n    cases h with\n    | refl => rfl\n\n"}
{"name":"Infinite.set","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Infinite α\n⊢ Infinite (Set α)","decl":"instance Infinite.set [Infinite α] : Infinite (Set α) :=\n  Infinite.of_injective singleton Set.singleton_injective\n\n"}
{"name":"instInfiniteFinset","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Infinite α\n⊢ Infinite (Finset α)","decl":"instance [Infinite α] : Infinite (Finset α) :=\n  Infinite.of_injective singleton Finset.singleton_injective\n\n"}
{"name":"instInfiniteOption","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Infinite α\n⊢ Infinite (Option α)","decl":"instance [Infinite α] : Infinite (Option α) :=\n  Infinite.of_injective some (Option.some_injective α)\n\n"}
{"name":"Sum.infinite_of_left","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Infinite α\n⊢ Infinite (Sum α β)","decl":"instance Sum.infinite_of_left [Infinite α] : Infinite (α ⊕ β) :=\n  Infinite.of_injective Sum.inl Sum.inl_injective\n\n"}
{"name":"Sum.infinite_of_right","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Infinite β\n⊢ Infinite (Sum α β)","decl":"instance Sum.infinite_of_right [Infinite β] : Infinite (α ⊕ β) :=\n  Infinite.of_injective Sum.inr Sum.inr_injective\n\n"}
{"name":"Prod.infinite_of_right","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Nonempty α\ninst✝ : Infinite β\n⊢ Infinite (Prod α β)","decl":"instance Prod.infinite_of_right [Nonempty α] [Infinite β] : Infinite (α × β) :=\n  Infinite.of_surjective Prod.snd Prod.snd_surjective\n\n"}
{"name":"Prod.infinite_of_left","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Infinite α\ninst✝ : Nonempty β\n⊢ Infinite (Prod α β)","decl":"instance Prod.infinite_of_left [Infinite α] [Nonempty β] : Infinite (α × β) :=\n  Infinite.of_surjective Prod.fst Prod.fst_surjective\n\n"}
{"name":"instInfiniteProdSubtypeCommute","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝¹ : Mul α\ninst✝ : Infinite α\n⊢ Infinite (Subtype fun p => Commute p.1 p.2)","decl":"instance instInfiniteProdSubtypeCommute [Mul α] [Infinite α] :\n    Infinite { p : α × α // Commute p.1 p.2 } :=\n  Infinite.of_injective (fun a => ⟨⟨a, a⟩, rfl⟩) (by intro; simp)\n\n"}
{"name":"Infinite.exists_subset_card_eq","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ninst✝ : Infinite α\nn : Nat\n⊢ Exists fun s => Eq s.card n","decl":"/-- See `Infinite.exists_superset_card_eq` for a version that, for an `s : Finset α`,\nprovides a superset `t : Finset α`, `s ⊆ t` such that `#t` is fixed. -/\ntheorem exists_subset_card_eq (α : Type*) [Infinite α] (n : ℕ) : ∃ s : Finset α, #s = n :=\n  ⟨(range n).map (natEmbedding α), by rw [card_map, card_range]⟩\n\n"}
{"name":"Infinite.exists_superset_card_eq","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\ninst✝ : Infinite α\ns : Finset α\nn : Nat\nhn : LE.le s.card n\n⊢ Exists fun t => And (HasSubset.Subset s t) (Eq t.card n)","decl":"/-- See `Infinite.exists_subset_card_eq` for a version that provides an arbitrary\n`s : Finset α` for any cardinality. -/\ntheorem exists_superset_card_eq [Infinite α] (s : Finset α) (n : ℕ) (hn : #s ≤ n) :\n    ∃ t : Finset α, s ⊆ t ∧ #t = n := by\n  induction' n with n IH generalizing s\n  · exact ⟨s, subset_refl _, Nat.eq_zero_of_le_zero hn⟩\n  · rcases hn.eq_or_lt with hn' | hn'\n    · exact ⟨s, subset_refl _, hn'⟩\n    obtain ⟨t, hs, ht⟩ := IH _ (Nat.le_of_lt_succ hn')\n    obtain ⟨x, hx⟩ := exists_not_mem_finset t\n    refine ⟨Finset.cons x t hx, hs.trans (Finset.subset_cons _), ?_⟩\n    simp [hx, ht]\n\n"}
{"name":"not_injective_infinite_finite","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Sort u_4\nβ : Sort u_5\ninst✝¹ : Infinite α\ninst✝ : Finite β\nf : α → β\n⊢ Not (Function.Injective f)","decl":"theorem not_injective_infinite_finite {α β} [Infinite α] [Finite β] (f : α → β) : ¬Injective f :=\n  fun hf => (Finite.of_injective f hf).false\n\n"}
{"name":"Finite.exists_ne_map_eq_of_infinite","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Sort u_4\nβ : Sort u_5\ninst✝¹ : Infinite α\ninst✝ : Finite β\nf : α → β\n⊢ Exists fun x => Exists fun y => And (Ne x y) (Eq (f x) (f y))","decl":"/-- The pigeonhole principle for infinitely many pigeons in finitely many pigeonholes. If there are\ninfinitely many pigeons in finitely many pigeonholes, then there are at least two pigeons in the\nsame pigeonhole.\n\nSee also: `Fintype.exists_ne_map_eq_of_card_lt`, `Finite.exists_infinite_fiber`.\n-/\ntheorem Finite.exists_ne_map_eq_of_infinite {α β} [Infinite α] [Finite β] (f : α → β) :\n    ∃ x y : α, x ≠ y ∧ f x = f y := by\n  simpa [Injective, and_comm] using not_injective_infinite_finite f\n\n"}
{"name":"Function.Embedding.is_empty","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Sort u_4\nβ : Sort u_5\ninst✝¹ : Infinite α\ninst✝ : Finite β\n⊢ IsEmpty (Function.Embedding α β)","decl":"instance Function.Embedding.is_empty {α β} [Infinite α] [Finite β] : IsEmpty (α ↪ β) :=\n  ⟨fun f => not_injective_infinite_finite f f.2⟩\n\n"}
{"name":"Finite.exists_infinite_fiber","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Infinite α\ninst✝ : Finite β\nf : α → β\n⊢ Exists fun y => Infinite ↑(Set.preimage f (Singleton.singleton y))","decl":"/-- The strong pigeonhole principle for infinitely many pigeons in\nfinitely many pigeonholes.  If there are infinitely many pigeons in\nfinitely many pigeonholes, then there is a pigeonhole with infinitely\nmany pigeons.\n\nSee also: `Finite.exists_ne_map_eq_of_infinite`\n-/\ntheorem Finite.exists_infinite_fiber [Infinite α] [Finite β] (f : α → β) :\n    ∃ y : β, Infinite (f ⁻¹' {y}) := by\n  classical\n    by_contra! hf\n    cases nonempty_fintype β\n    haveI := fun y => fintypeOfNotInfinite <| hf y\n    let key : Fintype α :=\n      { elems := univ.biUnion fun y : β => (f ⁻¹' {y}).toFinset\n        complete := by simp }\n    exact key.false\n\n"}
{"name":"not_surjective_finite_infinite","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Sort u_4\nβ : Sort u_5\ninst✝¹ : Finite α\ninst✝ : Infinite β\nf : α → β\n⊢ Not (Function.Surjective f)","decl":"theorem not_surjective_finite_infinite {α β} [Finite α] [Infinite β] (f : α → β) : ¬Surjective f :=\n  fun hf => (Infinite.of_surjective f hf).not_finite ‹_›\n\n"}
{"name":"List.exists_pw_disjoint_with_card","module":"Mathlib.Data.Fintype.Card","initialProofState":"α : Type u_4\ninst✝ : Fintype α\nc : List Nat\nhc : LE.le c.sum (Fintype.card α)\n⊢ Exists fun o => And (Eq (List.map List.length o) c) (And (∀ (s : List α), Membership.mem o s → s.Nodup) (List.Pairwise List.Disjoint o))","decl":"/-- For any `c : List ℕ` whose sum is at most `Fintype.card α`,\n  we can find `o : List (List α)` whose members have no duplicate,\n  whose lengths given by `c`, and which are pairwise disjoint -/\ntheorem List.exists_pw_disjoint_with_card {α : Type*} [Fintype α]\n    {c : List ℕ} (hc : c.sum ≤ Fintype.card α) :\n    ∃ o : List (List α),\n      o.map length = c ∧ (∀ s ∈ o, s.Nodup) ∧ Pairwise List.Disjoint o := by\n  let klift (n : ℕ) (hn : n < Fintype.card α) : Fin (Fintype.card α) :=\n    (⟨n, hn⟩ : Fin (Fintype.card α))\n  let klift' (l : List ℕ) (hl : ∀ a ∈ l, a < Fintype.card α) :\n    List (Fin (Fintype.card α)) := List.pmap klift l hl\n  have hc'_lt : ∀ l ∈ c.ranges, ∀ n ∈ l, n < Fintype.card α := by\n    intro l hl n hn\n    apply lt_of_lt_of_le _ hc\n    rw [← mem_mem_ranges_iff_lt_sum]\n    exact ⟨l, hl, hn⟩\n  let l := (ranges c).pmap klift' hc'_lt\n  have hl : ∀ (a : List ℕ) (ha : a ∈ c.ranges),\n    (klift' a (hc'_lt a ha)).map Fin.valEmbedding = a := by\n    intro a ha\n    conv_rhs => rw [← List.map_id a]\n    rw [List.map_pmap]\n    simp [klift, Fin.valEmbedding_apply, Fin.val_mk, List.pmap_eq_map, List.map_id']\n  use l.map (List.map (Fintype.equivFin α).symm)\n  constructor\n  · -- length\n    rw [← ranges_length c]\n    simp only [l, klift', map_map, map_pmap, Function.comp_apply, length_map, length_pmap,\n      pmap_eq_map]\n  constructor\n  · -- nodup\n    intro s\n    rw [mem_map]\n    rintro ⟨t, ht, rfl⟩\n    apply Nodup.map (Equiv.injective _)\n    obtain ⟨u, hu, rfl⟩ := mem_pmap.mp ht\n    apply Nodup.of_map\n    rw [hl u hu]\n    exact ranges_nodup hu\n  · -- pairwise disjoint\n    refine Pairwise.map _ (fun s t ↦ disjoint_map (Equiv.injective _)) ?_\n    -- List.Pairwise List.disjoint l\n    apply Pairwise.pmap (List.ranges_disjoint c)\n    intro u hu v hv huv\n    apply disjoint_pmap\n    · intro a a' ha ha' h\n      simpa only [klift, Fin.mk_eq_mk] using h\n    exact huv\n\n"}
{"name":"Fintype.induction_subsingleton_or_nontrivial","module":"Mathlib.Data.Fintype.Card","initialProofState":"P : (α : Type u_4) → [inst : Fintype α] → Prop\nα : Type u_4\ninst✝ : Fintype α\nhbase : ∀ (α : Type u_4) [inst : Fintype α] [inst_1 : Subsingleton α], P α\nhstep : ∀ (α : Type u_4) [inst : Fintype α] [inst_1 : Nontrivial α], (∀ (β : Type u_4) [inst_2 : Fintype β], LT.lt (Fintype.card β) (Fintype.card α) → P β) → P α\n⊢ P α","decl":"/-- A custom induction principle for fintypes. The base case is a subsingleton type,\nand the induction step is for non-trivial types, and one can assume the hypothesis for\nsmaller types (via `Fintype.card`).\n\nThe major premise is `Fintype α`, so to use this with the `induction` tactic you have to give a name\nto that instance and use that name.\n-/\n@[elab_as_elim]\ntheorem Fintype.induction_subsingleton_or_nontrivial {P : ∀ (α) [Fintype α], Prop} (α : Type*)\n    [Fintype α] (hbase : ∀ (α) [Fintype α] [Subsingleton α], P α)\n    (hstep : ∀ (α) [Fintype α] [Nontrivial α],\n      (∀ (β) [Fintype β], Fintype.card β < Fintype.card α → P β) → P α) :\n    P α := by\n  obtain ⟨n, hn⟩ : ∃ n, Fintype.card α = n := ⟨Fintype.card α, rfl⟩\n  induction' n using Nat.strong_induction_on with n ih generalizing α\n  cases' subsingleton_or_nontrivial α with hsing hnontriv\n  · apply hbase\n  · apply hstep\n    intro β _ hlt\n    rw [hn] at hlt\n    exact ih (Fintype.card β) hlt _ rfl\n"}
