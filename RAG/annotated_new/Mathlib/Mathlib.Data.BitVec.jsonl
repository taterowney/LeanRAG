{"name":"BitVec.toNat_injective","module":"Mathlib.Data.BitVec","initialProofState":"n : Nat\n⊢ Function.Injective BitVec.toNat","decl":"theorem toNat_injective {n : Nat} : Function.Injective (BitVec.toNat : BitVec n → _)\n  | ⟨_, _⟩, ⟨_, _⟩, rfl => rfl\n\n"}
{"name":"BitVec.toFin_injective","module":"Mathlib.Data.BitVec","initialProofState":"n : Nat\n⊢ Function.Injective BitVec.toFin","decl":"theorem toFin_injective {n : Nat} : Function.Injective (toFin : BitVec n → _)\n  | ⟨_, _⟩, ⟨_, _⟩, rfl => rfl\n\n"}
{"name":"BitVec.toFin_nsmul","module":"Mathlib.Data.BitVec","initialProofState":"w n : Nat\nx : BitVec w\n⊢ Eq (HSMul.hSMul n x).toFin (HSMul.hSMul n x.toFin)","decl":"lemma toFin_nsmul (n : ℕ) (x : BitVec w)  : toFin (n • x) = n • x.toFin := rfl\n"}
{"name":"BitVec.toFin_zsmul","module":"Mathlib.Data.BitVec","initialProofState":"w : Nat\nz : Int\nx : BitVec w\n⊢ Eq (HSMul.hSMul z x).toFin (HSMul.hSMul z x.toFin)","decl":"lemma toFin_zsmul (z : ℤ) (x : BitVec w)  : toFin (z • x) = z • x.toFin := rfl\n"}
{"name":"BitVec.toFin_pow","module":"Mathlib.Data.BitVec","initialProofState":"w : Nat\nx : BitVec w\nn : Nat\n⊢ Eq (HPow.hPow x n).toFin (HPow.hPow x.toFin n)","decl":"lemma toFin_pow (x : BitVec w) (n : ℕ)    : toFin (x ^ n) = x.toFin ^ n := rfl\n\n"}
{"name":"BitVec.ofFin_neg","module":"Mathlib.Data.BitVec","initialProofState":"w : Nat\nx : Fin (HPow.hPow 2 w)\n⊢ Eq { toFin := Neg.neg x } (Neg.neg { toFin := x })","decl":"@[simp] lemma ofFin_neg {x : Fin (2 ^ w)} : ofFin (-x) = -(ofFin x) := by\n  rfl\n\n"}
{"name":"BitVec.ofFin_natCast","module":"Mathlib.Data.BitVec","initialProofState":"w n : Nat\n⊢ Eq { toFin := ↑n } ↑n","decl":"@[simp] lemma ofFin_natCast (n : ℕ) : ofFin (n : Fin (2^w)) = n := by\n  rfl\n\n"}
{"name":"BitVec.toFin_natCast","module":"Mathlib.Data.BitVec","initialProofState":"w n : Nat\n⊢ Eq (↑n).toFin ↑n","decl":"lemma toFin_natCast (n : ℕ) : toFin (n : BitVec w) = n := by\n  rfl\n\n"}
{"name":"BitVec.ofFin_intCast","module":"Mathlib.Data.BitVec","initialProofState":"w : Nat\nz : Int\n⊢ Eq { toFin := ↑z } ↑z","decl":"theorem ofFin_intCast (z : ℤ) : ofFin (z : Fin (2^w)) = ↑z := by\n  cases w\n  case zero =>\n    simp only [eq_nil]\n  case succ w =>\n    simp only [Int.cast, IntCast.intCast]\n    unfold Int.castDef\n    cases' z with z z\n    · rfl\n    · rw [ofInt_negSucc_eq_not_ofNat]\n      simp only [Nat.cast_add, Nat.cast_one, neg_add_rev]\n      rw [← add_ofFin, ofFin_neg, ofFin_ofNat, ofNat_eq_ofNat, ofFin_neg, ofFin_natCast,\n        natCast_eq_ofNat, negOne_eq_allOnes, ← sub_toAdd, allOnes_sub_eq_not]\n\n"}
{"name":"BitVec.toFin_intCast","module":"Mathlib.Data.BitVec","initialProofState":"w : Nat\nz : Int\n⊢ Eq (↑z).toFin ↑z","decl":"theorem toFin_intCast (z : ℤ) : toFin (z : BitVec w) = z := by\n  apply toFin_inj.mpr <| (ofFin_intCast z).symm\n\n"}
{"name":"BitVec.equivFin_apply","module":"Mathlib.Data.BitVec","initialProofState":"m : Nat\na : BitVec m\n⊢ Eq (BitVec.equivFin a) a.toFin","decl":"/-- The ring `BitVec m` is isomorphic to `Fin (2 ^ m)`. -/\n@[simps]\ndef equivFin {m : ℕ} : BitVec m ≃+* Fin (2 ^ m) where\n  toFun a := a.toFin\n  invFun a := ofFin a\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n  map_add' _ _ := rfl\n\n"}
{"name":"BitVec.equivFin_symm_apply_toFin","module":"Mathlib.Data.BitVec","initialProofState":"m : Nat\na : Fin (HPow.hPow 2 m)\n⊢ Eq (BitVec.equivFin.symm a).toFin a","decl":"/-- The ring `BitVec m` is isomorphic to `Fin (2 ^ m)`. -/\n@[simps]\ndef equivFin {m : ℕ} : BitVec m ≃+* Fin (2 ^ m) where\n  toFun a := a.toFin\n  invFun a := ofFin a\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n  map_add' _ _ := rfl\n\n"}
