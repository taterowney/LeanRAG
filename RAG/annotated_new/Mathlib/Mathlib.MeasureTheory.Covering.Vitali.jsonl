{"name":"Vitali.exists_disjoint_subfamily_covering_enlargement","module":"Mathlib.MeasureTheory.Covering.Vitali","initialProofState":"α : Type u_1\nι : Type u_2\nB : ι → Set α\nt : Set ι\nδ : ι → Real\nτ : Real\nhτ : LT.lt 1 τ\nδnonneg : ∀ (a : ι), Membership.mem t a → LE.le 0 (δ a)\nR : Real\nδle : ∀ (a : ι), Membership.mem t a → LE.le (δ a) R\nhne : ∀ (a : ι), Membership.mem t a → (B a).Nonempty\n⊢ Exists fun u => And (HasSubset.Subset u t) (And (u.PairwiseDisjoint B) (∀ (a : ι), Membership.mem t a → Exists fun b => And (Membership.mem u b) (And (Inter.inter (B a) (B b)).Nonempty (LE.le (δ a) (HMul.hMul τ (δ b))))))","decl":"/-- **Vitali covering theorem**: given a set `t` of subsets of a type, one may extract a disjoint\nsubfamily `u` such that the `τ`-enlargement of this family covers all elements of `t`, where `τ > 1`\nis any fixed number.\n\nWhen `t` is a family of balls, the `τ`-enlargement of `ball x r` is `ball x ((1+2τ) r)`. In general,\nit is expressed in terms of a function `δ` (think \"radius\" or \"diameter\"), positive and bounded on\nall elements of `t`. The condition is that every element `a` of `t` should intersect an\nelement `b` of `u` of size larger than that of `a` up to `τ`, i.e., `δ b ≥ δ a / τ`.\n\nWe state the lemma slightly more generally, with an indexed family of sets `B a` for `a ∈ t`, for\nwider applicability.\n-/\ntheorem exists_disjoint_subfamily_covering_enlargement (B : ι → Set α) (t : Set ι) (δ : ι → ℝ)\n    (τ : ℝ) (hτ : 1 < τ) (δnonneg : ∀ a ∈ t, 0 ≤ δ a) (R : ℝ) (δle : ∀ a ∈ t, δ a ≤ R)\n    (hne : ∀ a ∈ t, (B a).Nonempty) :\n    ∃ u ⊆ t,\n      u.PairwiseDisjoint B ∧ ∀ a ∈ t, ∃ b ∈ u, (B a ∩ B b).Nonempty ∧ δ a ≤ τ * δ b := by\n  /- The proof could be formulated as a transfinite induction. First pick an element of `t` with `δ`\n  as large as possible (up to a factor of `τ`). Then among the remaining elements not intersecting\n  the already chosen one, pick another element with large `δ`. Go on forever (transfinitely) until\n  there is nothing left.\n\n  Instead, we give a direct Zorn-based argument. Consider a maximal family `u` of disjoint sets\n  with the following property: if an element `a` of `t` intersects some element `b` of `u`, then it\n  intersects some `b' ∈ u` with `δ b' ≥ δ a / τ`. Such a maximal family exists by Zorn. If this\n  family did not intersect some element `a ∈ t`, then take an element `a' ∈ t` which does not\n  intersect any element of `u`, with `δ a'` almost as large as possible. One checks easily\n  that `u ∪ {a'}` still has this property, contradicting the maximality. Therefore, `u`\n  intersects all elements of `t`, and by definition it satisfies all the desired properties.\n  -/\n  let T : Set (Set ι) := { u | u ⊆ t ∧ u.PairwiseDisjoint B ∧\n    ∀ a ∈ t, ∀ b ∈ u, (B a ∩ B b).Nonempty → ∃ c ∈ u, (B a ∩ B c).Nonempty ∧ δ a ≤ τ * δ c }\n  -- By Zorn, choose a maximal family in the good set `T` of disjoint families.\n  obtain ⟨u, hu⟩ : ∃ m, Maximal (fun x ↦ x ∈ T) m := by\n    refine zorn_subset _ fun U UT hU => ?_\n    refine ⟨⋃₀ U, ?_, fun s hs => subset_sUnion_of_mem hs⟩\n    simp only [T, Set.sUnion_subset_iff, and_imp, exists_prop, forall_exists_index, mem_sUnion,\n      Set.mem_setOf_eq]\n    refine\n      ⟨fun u hu => (UT hu).1, (pairwiseDisjoint_sUnion hU.directedOn).2 fun u hu => (UT hu).2.1,\n        fun a hat b u uU hbu hab => ?_⟩\n    obtain ⟨c, cu, ac, hc⟩ : ∃ c, c ∈ u ∧ (B a ∩ B c).Nonempty ∧ δ a ≤ τ * δ c :=\n      (UT uU).2.2 a hat b hbu hab\n    exact ⟨c, ⟨u, uU, cu⟩, ac, hc⟩\n  -- The only nontrivial bit is to check that every `a ∈ t` intersects an element `b ∈ u` with\n  -- comparatively large `δ b`. Assume this is not the case, then we will contradict the maximality.\n  refine ⟨u, hu.prop.1, hu.prop.2.1, fun a hat => ?_⟩\n  by_contra! hcon\n  have a_disj : ∀ c ∈ u, Disjoint (B a) (B c) := by\n    intro c hc\n    by_contra h\n    rw [not_disjoint_iff_nonempty_inter] at h\n    obtain ⟨d, du, ad, hd⟩ : ∃ d, d ∈ u ∧ (B a ∩ B d).Nonempty ∧ δ a ≤ τ * δ d :=\n      hu.prop.2.2 a hat c hc h\n    exact lt_irrefl _ ((hcon d du ad).trans_le hd)\n  -- Let `A` be all the elements of `t` which do not intersect the family `u`. It is nonempty as it\n  -- contains `a`. We will pick an element `a'` of `A` with `δ a'` almost as large as possible.\n  let A := { a' | a' ∈ t ∧ ∀ c ∈ u, Disjoint (B a') (B c) }\n  have Anonempty : A.Nonempty := ⟨a, hat, a_disj⟩\n  let m := sSup (δ '' A)\n  have bddA : BddAbove (δ '' A) := by\n    refine ⟨R, fun x xA => ?_⟩\n    rcases (mem_image _ _ _).1 xA with ⟨a', ha', rfl⟩\n    exact δle a' ha'.1\n  obtain ⟨a', a'A, ha'⟩ : ∃ a' ∈ A, m / τ ≤ δ a' := by\n    have : 0 ≤ m := (δnonneg a hat).trans (le_csSup bddA (mem_image_of_mem _ ⟨hat, a_disj⟩))\n    rcases eq_or_lt_of_le this with (mzero | mpos)\n    · refine ⟨a, ⟨hat, a_disj⟩, ?_⟩\n      simpa only [← mzero, zero_div] using δnonneg a hat\n    · have I : m / τ < m := by\n        rw [div_lt_iff₀ (zero_lt_one.trans hτ)]\n        conv_lhs => rw [← mul_one m]\n        exact (mul_lt_mul_left mpos).2 hτ\n      rcases exists_lt_of_lt_csSup (Anonempty.image _) I with ⟨x, xA, hx⟩\n      rcases (mem_image _ _ _).1 xA with ⟨a', ha', rfl⟩\n      exact ⟨a', ha', hx.le⟩\n  clear hat hcon a_disj a\n  have a'_ne_u : a' ∉ u := fun H => (hne _ a'A.1).ne_empty (disjoint_self.1 (a'A.2 _ H))\n  -- we claim that `u ∪ {a'}` still belongs to `T`, contradicting the maximality of `u`.\n  refine a'_ne_u (hu.mem_of_prop_insert ⟨?_, ?_, ?_⟩)\n  · -- check that `u ∪ {a'}` is made of elements of `t`.\n    rw [insert_subset_iff]\n    exact ⟨a'A.1, hu.prop.1⟩\n  · -- Check that `u ∪ {a'}` is a disjoint family. This follows from the fact that `a'` does not\n    -- intersect `u`.\n    exact hu.prop.2.1.insert fun b bu _ => a'A.2 b bu\n  · -- check that every element `c` of `t` intersecting `u ∪ {a'}` intersects an element of this\n    -- family with large `δ`.\n    intro c ct b ba'u hcb\n    -- if `c` already intersects an element of `u`, then it intersects an element of `u` with\n    -- large `δ` by the assumption on `u`, and there is nothing left to do.\n    by_cases H : ∃ d ∈ u, (B c ∩ B d).Nonempty\n    · rcases H with ⟨d, du, hd⟩\n      rcases hu.prop.2.2 c ct d du hd with ⟨d', d'u, hd'⟩\n      exact ⟨d', mem_insert_of_mem _ d'u, hd'⟩\n    · -- Otherwise, `c` belongs to `A`. The element of `u ∪ {a'}` that it intersects has to be `a'`.\n      -- Moreover, `δ c` is smaller than the maximum `m` of `δ` over `A`, which is `≤ δ a' / τ`\n      -- thanks to the good choice of `a'`. This is the desired inequality.\n      push_neg at H\n      simp only [← disjoint_iff_inter_eq_empty] at H\n      rcases mem_insert_iff.1 ba'u with (rfl | H')\n      · refine ⟨b, mem_insert _ _, hcb, ?_⟩\n        calc\n          δ c ≤ m := le_csSup bddA (mem_image_of_mem _ ⟨ct, H⟩)\n          _ = τ * (m / τ) := by field_simp [(zero_lt_one.trans hτ).ne']\n          _ ≤ τ * δ b := by gcongr\n      · rw [← not_disjoint_iff_nonempty_inter] at hcb\n        exact (hcb (H _ H')).elim\n\n"}
{"name":"Vitali.exists_disjoint_subfamily_covering_enlargment","module":"Mathlib.MeasureTheory.Covering.Vitali","initialProofState":"α : Type u_1\nι : Type u_2\nB : ι → Set α\nt : Set ι\nδ : ι → Real\nτ : Real\nhτ : LT.lt 1 τ\nδnonneg : ∀ (a : ι), Membership.mem t a → LE.le 0 (δ a)\nR : Real\nδle : ∀ (a : ι), Membership.mem t a → LE.le (δ a) R\nhne : ∀ (a : ι), Membership.mem t a → (B a).Nonempty\n⊢ Exists fun u => And (HasSubset.Subset u t) (And (u.PairwiseDisjoint B) (∀ (a : ι), Membership.mem t a → Exists fun b => And (Membership.mem u b) (And (Inter.inter (B a) (B b)).Nonempty (LE.le (δ a) (HMul.hMul τ (δ b))))))","decl":"@[deprecated (since := \"2024-12-25\")]\nalias exists_disjoint_subfamily_covering_enlargment :=\n  exists_disjoint_subfamily_covering_enlargement\n\n"}
{"name":"Vitali.exists_disjoint_subfamily_covering_enlargement_closedBall","module":"Mathlib.MeasureTheory.Covering.Vitali","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝ : PseudoMetricSpace α\nt : Set ι\nx : ι → α\nr : ι → Real\nR : Real\nhr : ∀ (a : ι), Membership.mem t a → LE.le (r a) R\nτ : Real\nhτ : LT.lt 3 τ\n⊢ Exists fun u => And (HasSubset.Subset u t) (And (u.PairwiseDisjoint fun a => Metric.closedBall (x a) (r a)) (∀ (a : ι), Membership.mem t a → Exists fun b => And (Membership.mem u b) (HasSubset.Subset (Metric.closedBall (x a) (r a)) (Metric.closedBall (x b) (HMul.hMul τ (r b))))))","decl":"/-- Vitali covering theorem, closed balls version: given a family `t` of closed balls, one can\nextract a disjoint subfamily `u ⊆ t` so that all balls in `t` are covered by the τ-times\ndilations of balls in `u`, for some `τ > 3`. -/\ntheorem exists_disjoint_subfamily_covering_enlargement_closedBall\n    [PseudoMetricSpace α] (t : Set ι)\n    (x : ι → α) (r : ι → ℝ) (R : ℝ) (hr : ∀ a ∈ t, r a ≤ R) (τ : ℝ) (hτ : 3 < τ) :\n    ∃ u ⊆ t,\n      (u.PairwiseDisjoint fun a => closedBall (x a) (r a)) ∧\n        ∀ a ∈ t, ∃ b ∈ u, closedBall (x a) (r a) ⊆ closedBall (x b) (τ * r b) := by\n  rcases eq_empty_or_nonempty t with (rfl | _)\n  · exact ⟨∅, Subset.refl _, pairwiseDisjoint_empty, by simp⟩\n  by_cases ht : ∀ a ∈ t, r a < 0\n  · exact ⟨t, Subset.rfl, fun a ha b _ _ => by\n      #adaptation_note /-- nightly-2024-03-16\n      Previously `Function.onFun` unfolded in the following `simp only`,\n      but now needs a separate `rw`.\n      This may be a bug: a no import minimization may be required. -/\n      rw [Function.onFun]\n      simp only [Function.onFun, closedBall_eq_empty.2 (ht a ha), empty_disjoint],\n      fun a ha => ⟨a, ha, by simp only [closedBall_eq_empty.2 (ht a ha), empty_subset]⟩⟩\n  push_neg at ht\n  let t' := { a ∈ t | 0 ≤ r a }\n  rcases exists_disjoint_subfamily_covering_enlargement (fun a => closedBall (x a) (r a)) t' r\n      ((τ - 1) / 2) (by linarith) (fun a ha => ha.2) R (fun a ha => hr a ha.1) fun a ha =>\n      ⟨x a, mem_closedBall_self ha.2⟩ with\n    ⟨u, ut', u_disj, hu⟩\n  have A : ∀ a ∈ t', ∃ b ∈ u, closedBall (x a) (r a) ⊆ closedBall (x b) (τ * r b) := by\n    intro a ha\n    rcases hu a ha with ⟨b, bu, hb, rb⟩\n    refine ⟨b, bu, ?_⟩\n    have : dist (x a) (x b) ≤ r a + r b := dist_le_add_of_nonempty_closedBall_inter_closedBall hb\n    apply closedBall_subset_closedBall'\n    linarith\n  refine ⟨u, ut'.trans fun a ha => ha.1, u_disj, fun a ha => ?_⟩\n  rcases le_or_lt 0 (r a) with (h'a | h'a)\n  · exact A a ⟨ha, h'a⟩\n  · rcases ht with ⟨b, rb⟩\n    rcases A b ⟨rb.1, rb.2⟩ with ⟨c, cu, _⟩\n    exact ⟨c, cu, by simp only [closedBall_eq_empty.2 h'a, empty_subset]⟩\n\n"}
{"name":"Vitali.exists_disjoint_subfamily_covering_enlargment_closedBall","module":"Mathlib.MeasureTheory.Covering.Vitali","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝ : PseudoMetricSpace α\nt : Set ι\nx : ι → α\nr : ι → Real\nR : Real\nhr : ∀ (a : ι), Membership.mem t a → LE.le (r a) R\nτ : Real\nhτ : LT.lt 3 τ\n⊢ Exists fun u => And (HasSubset.Subset u t) (And (u.PairwiseDisjoint fun a => Metric.closedBall (x a) (r a)) (∀ (a : ι), Membership.mem t a → Exists fun b => And (Membership.mem u b) (HasSubset.Subset (Metric.closedBall (x a) (r a)) (Metric.closedBall (x b) (HMul.hMul τ (r b))))))","decl":"@[deprecated (since := \"2024-12-25\")]\nalias exists_disjoint_subfamily_covering_enlargment_closedBall :=\n  exists_disjoint_subfamily_covering_enlargement_closedBall\n\n"}
{"name":"Vitali.exists_disjoint_covering_ae","module":"Mathlib.MeasureTheory.Covering.Vitali","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝⁴ : PseudoMetricSpace α\ninst✝³ : MeasurableSpace α\ninst✝² : OpensMeasurableSpace α\ninst✝¹ : SecondCountableTopology α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsLocallyFiniteMeasure μ\ns : Set α\nt : Set ι\nC : NNReal\nr : ι → Real\nc : ι → α\nB : ι → Set α\nhB : ∀ (a : ι), Membership.mem t a → HasSubset.Subset (B a) (Metric.closedBall (c a) (r a))\nμB : ∀ (a : ι), Membership.mem t a → LE.le (μ (Metric.closedBall (c a) (HMul.hMul 3 (r a)))) (HMul.hMul (↑C) (μ (B a)))\nht : ∀ (a : ι), Membership.mem t a → (interior (B a)).Nonempty\nh't : ∀ (a : ι), Membership.mem t a → IsClosed (B a)\nhf : ∀ (x : α), Membership.mem s x → ∀ (ε : Real), GT.gt ε 0 → Exists fun a => And (Membership.mem t a) (And (LE.le (r a) ε) (Eq (c a) x))\n⊢ Exists fun u => And (HasSubset.Subset u t) (And u.Countable (And (u.PairwiseDisjoint B) (Eq (μ (SDiff.sdiff s (Set.iUnion fun a => Set.iUnion fun h => B a))) 0)))","decl":"/-- The measurable **Vitali covering theorem**.\n\nAssume one is given a family `t` of closed sets with nonempty interior, such that each `a ∈ t` is\nincluded in a ball `B (x, r)` and covers a definite proportion of the ball `B (x, 3 r)` for a given\nmeasure `μ` (think of the situation where `μ` is a doubling measure and `t` is a family of balls).\nConsider a (possibly non-measurable) set `s` at which the family is fine, i.e., every point of `s`\nbelongs to arbitrarily small elements of `t`. Then one can extract from `t` a disjoint subfamily\nthat covers almost all `s`.\n\nFor more flexibility, we give a statement with a parameterized family of sets.\n-/\ntheorem exists_disjoint_covering_ae\n    [PseudoMetricSpace α] [MeasurableSpace α] [OpensMeasurableSpace α]\n    [SecondCountableTopology α] (μ : Measure α) [IsLocallyFiniteMeasure μ] (s : Set α) (t : Set ι)\n    (C : ℝ≥0) (r : ι → ℝ) (c : ι → α) (B : ι → Set α) (hB : ∀ a ∈ t, B a ⊆ closedBall (c a) (r a))\n    (μB : ∀ a ∈ t, μ (closedBall (c a) (3 * r a)) ≤ C * μ (B a))\n    (ht : ∀ a ∈ t, (interior (B a)).Nonempty) (h't : ∀ a ∈ t, IsClosed (B a))\n    (hf : ∀ x ∈ s, ∀ ε > (0 : ℝ), ∃ a ∈ t, r a ≤ ε ∧ c a = x) :\n    ∃ u ⊆ t, u.Countable ∧ u.PairwiseDisjoint B ∧ μ (s \\ ⋃ a ∈ u, B a) = 0 := by\n  /- The idea of the proof is the following. Assume for simplicity that `μ` is finite. Applying the\n  abstract Vitali covering theorem with `δ = r` given by `hf`, one obtains a disjoint subfamily `u`,\n  such that any element of `t` intersects an element of `u` with comparable radius. Fix `ε > 0`.\n  Since the elements of `u` have summable measure, one can remove finitely elements `w_1, ..., w_n`.\n  so that the measure of the remaining elements is `< ε`. Consider now a point `z` not\n  in the `w_i`. There is a small ball around `z` not intersecting the `w_i` (as they are closed),\n  an element `a ∈ t` contained in this small ball (as the family `t` is fine at `z`) and an element\n  `b ∈ u` intersecting `a`, with comparable radius (by definition of `u`). Then `z` belongs to the\n  enlargement of `b`. This shows that `s \\ (w_1 ∪ ... ∪ w_n)` is contained in\n  `⋃ (b ∈ u \\ {w_1, ... w_n}) (enlargement of b)`. The measure of the latter set is bounded by\n  `∑ (b ∈ u \\ {w_1, ... w_n}) C * μ b` (by the doubling property of the measure), which is at most\n  `C ε`. Letting `ε` tend to `0` shows that `s` is almost everywhere covered by the family `u`.\n\n  For the real argument, the measure is only locally finite. Therefore, we implement the same\n  strategy, but locally restricted to balls on which the measure is finite. For this, we do not\n  use the whole family `t`, but a subfamily `t'` supported on small balls (which is possible since\n  the family is assumed to be fine at every point of `s`).\n  -/\n  classical\n  -- choose around each `x` a small ball on which the measure is finite\n  have : ∀ x, ∃ R, 0 < R ∧ R ≤ 1 ∧ μ (closedBall x (20 * R)) < ∞ := fun x ↦ by\n    refine ((eventually_le_nhds one_pos).and ?_).exists_gt\n    refine (tendsto_closedBall_smallSets x).comp ?_ (μ.finiteAt_nhds x).eventually\n    exact Continuous.tendsto' (by fun_prop) _ _ (mul_zero _)\n  choose R hR0 hR1 hRμ using this\n  -- we restrict to a subfamily `t'` of `t`, made of elements small enough to ensure that\n  -- they only see a finite part of the measure, and with a doubling property\n  let t' := { a ∈ t | r a ≤ R (c a) }\n  -- extract a disjoint subfamily `u` of `t'` thanks to the abstract Vitali covering theorem.\n  obtain ⟨u, ut', u_disj, hu⟩ : ∃ u ⊆ t',\n      u.PairwiseDisjoint B ∧ ∀ a ∈ t', ∃ b ∈ u, (B a ∩ B b).Nonempty ∧ r a ≤ 2 * r b := by\n    have A : ∀ a ∈ t', r a ≤ 1 := by\n      intro a ha\n      apply ha.2.trans (hR1 (c a))\n    have A' : ∀ a ∈ t', (B a).Nonempty :=\n      fun a hat' => Set.Nonempty.mono interior_subset (ht a hat'.1)\n    refine exists_disjoint_subfamily_covering_enlargement\n      B t' r 2 one_lt_two (fun a ha => ?_) 1 A A'\n    exact nonempty_closedBall.1 ((A' a ha).mono (hB a ha.1))\n  have ut : u ⊆ t := fun a hau => (ut' hau).1\n  -- As the space is second countable, the family is countable since all its sets have nonempty\n  -- interior.\n  have u_count : u.Countable := u_disj.countable_of_nonempty_interior fun a ha => ht a (ut ha)\n  -- the family `u` will be the desired family\n  refine ⟨u, fun a hat' => (ut' hat').1, u_count, u_disj, ?_⟩\n  -- it suffices to show that it covers almost all `s` locally around each point `x`.\n  refine measure_null_of_locally_null _ fun x _ => ?_\n  -- let `v` be the subfamily of `u` made of those sets intersecting the small ball `ball x (r x)`\n  let v := { a ∈ u | (B a ∩ ball x (R x)).Nonempty }\n  have vu : v ⊆ u := fun a ha => ha.1\n  -- they are all contained in a fixed ball of finite measure, thanks to our choice of `t'`\n  obtain ⟨K, μK, hK⟩ : ∃ K, μ (closedBall x K) < ∞ ∧\n      ∀ a ∈ u, (B a ∩ ball x (R x)).Nonempty → B a ⊆ closedBall x K := by\n    have Idist_v : ∀ a ∈ v, dist (c a) x ≤ r a + R x := by\n      intro a hav\n      apply dist_le_add_of_nonempty_closedBall_inter_closedBall\n      refine hav.2.mono ?_\n      apply inter_subset_inter _ ball_subset_closedBall\n      exact hB a (ut (vu hav))\n    set R0 := sSup (r '' v) with R0_def\n    have R0_bdd : BddAbove (r '' v) := by\n      refine ⟨1, fun r' hr' => ?_⟩\n      rcases (mem_image _ _ _).1 hr' with ⟨b, hb, rfl⟩\n      exact le_trans (ut' (vu hb)).2 (hR1 (c b))\n    rcases le_total R0 (R x) with (H | H)\n    · refine ⟨20 * R x, hRμ x, fun a au hax => ?_⟩\n      refine (hB a (ut au)).trans ?_\n      apply closedBall_subset_closedBall'\n      have : r a ≤ R0 := le_csSup R0_bdd (mem_image_of_mem _ ⟨au, hax⟩)\n      linarith [Idist_v a ⟨au, hax⟩, hR0 x]\n    · have R0pos : 0 < R0 := (hR0 x).trans_le H\n      have vnonempty : v.Nonempty := by\n        by_contra h\n        rw [nonempty_iff_ne_empty, Classical.not_not] at h\n        rw [h, image_empty, Real.sSup_empty] at R0_def\n        exact lt_irrefl _ (R0pos.trans_le (le_of_eq R0_def))\n      obtain ⟨a, hav, R0a⟩ : ∃ a ∈ v, R0 / 2 < r a := by\n        obtain ⟨r', r'mem, hr'⟩ : ∃ r' ∈ r '' v, R0 / 2 < r' :=\n          exists_lt_of_lt_csSup (vnonempty.image _) (half_lt_self R0pos)\n        rcases (mem_image _ _ _).1 r'mem with ⟨a, hav, rfl⟩\n        exact ⟨a, hav, hr'⟩\n      refine ⟨8 * R0, ?_, ?_⟩\n      · apply lt_of_le_of_lt (measure_mono _) (hRμ (c a))\n        apply closedBall_subset_closedBall'\n        rw [dist_comm]\n        linarith [Idist_v a hav, (ut' (vu hav)).2]\n      · intro b bu hbx\n        refine (hB b (ut bu)).trans ?_\n        apply closedBall_subset_closedBall'\n        have : r b ≤ R0 := le_csSup R0_bdd (mem_image_of_mem _ ⟨bu, hbx⟩)\n        linarith [Idist_v b ⟨bu, hbx⟩]\n  -- we will show that, in `ball x (R x)`, almost all `s` is covered by the family `u`.\n  refine ⟨_ ∩ ball x (R x), inter_mem_nhdsWithin _ (ball_mem_nhds _ (hR0 _)),\n    nonpos_iff_eq_zero.mp (le_of_forall_gt_imp_ge_of_dense fun ε εpos => ?_)⟩\n  -- the elements of `v` are disjoint and all contained in a finite volume ball, hence the sum\n  -- of their measures is finite.\n  have I : (∑' a : v, μ (B a)) < ∞ := by\n    calc\n      (∑' a : v, μ (B a)) = μ (⋃ a ∈ v, B a) := by\n        rw [measure_biUnion (u_count.mono vu) _ fun a ha => (h't _ (vu.trans ut ha)).measurableSet]\n        exact u_disj.subset vu\n      _ ≤ μ (closedBall x K) := (measure_mono (iUnion₂_subset fun a ha => hK a (vu ha) ha.2))\n      _ < ∞ := μK\n  -- we can obtain a finite subfamily of `v`, such that the measures of the remaining elements\n  -- add up to an arbitrarily small number, say `ε / C`.\n  obtain ⟨w, hw⟩ : ∃ w : Finset v, (∑' a : { a // a ∉ w }, μ (B a)) < ε / C :=\n    haveI : 0 < ε / C := by\n      simp only [ENNReal.div_pos_iff, εpos.ne', ENNReal.coe_ne_top, Ne, not_false_iff,\n        and_self_iff]\n    ((tendsto_order.1 (ENNReal.tendsto_tsum_compl_atTop_zero I.ne)).2 _ this).exists\n  -- main property: the points `z` of `s` which are not covered by `u` are contained in the\n  -- enlargements of the elements not in `w`.\n  have M : (s \\ ⋃ a ∈ u, B a) ∩\n      ball x (R x) ⊆ ⋃ a : { a // a ∉ w }, closedBall (c a) (3 * r a) := by\n    intro z hz\n    set k := ⋃ (a : v) (_ : a ∈ w), B a\n    have k_closed : IsClosed k := isClosed_biUnion_finset fun i _ => h't _ (ut (vu i.2))\n    have z_notmem_k : z ∉ k := by\n      simp only [k, not_exists, exists_prop, mem_iUnion, mem_sep_iff, forall_exists_index,\n        SetCoe.exists, not_and, exists_and_right, Subtype.coe_mk]\n      intro b hbv _ h'z\n      have : z ∈ (s \\ ⋃ a ∈ u, B a) ∩ ⋃ a ∈ u, B a :=\n        mem_inter (mem_of_mem_inter_left hz) (mem_biUnion (vu hbv) h'z)\n      simpa only [diff_inter_self]\n    -- since the elements of `w` are closed and finitely many, one can find a small ball around `z`\n    -- not intersecting them\n    have : ball x (R x) \\ k ∈ 𝓝 z := by\n      apply IsOpen.mem_nhds (isOpen_ball.sdiff k_closed) _\n      exact (mem_diff _).2 ⟨mem_of_mem_inter_right hz, z_notmem_k⟩\n    obtain ⟨d, dpos, hd⟩ : ∃ d, 0 < d ∧ closedBall z d ⊆ ball x (R x) \\ k :=\n      nhds_basis_closedBall.mem_iff.1 this\n    -- choose an element `a` of the family `t` contained in this small ball\n    obtain ⟨a, hat, ad, rfl⟩ : ∃ a ∈ t, r a ≤ min d (R z) ∧ c a = z :=\n      hf z ((mem_diff _).1 (mem_of_mem_inter_left hz)).1 (min d (R z)) (lt_min dpos (hR0 z))\n    have ax : B a ⊆ ball x (R x) := by\n      refine (hB a hat).trans ?_\n      refine Subset.trans ?_ (hd.trans Set.diff_subset)\n      exact closedBall_subset_closedBall (ad.trans (min_le_left _ _))\n    -- it intersects an element `b` of `u` with comparable diameter, by definition of `u`\n    obtain ⟨b, bu, ab, bdiam⟩ : ∃ b ∈ u, (B a ∩ B b).Nonempty ∧ r a ≤ 2 * r b :=\n      hu a ⟨hat, ad.trans (min_le_right _ _)⟩\n    have bv : b ∈ v := by\n      refine ⟨bu, ab.mono ?_⟩\n      rw [inter_comm]\n      exact inter_subset_inter_right _ ax\n    let b' : v := ⟨b, bv⟩\n    -- `b` cannot belong to `w`, as the elements of `w` do not intersect `closedBall z d`,\n    -- contrary to `b`\n    have b'_notmem_w : b' ∉ w := by\n      intro b'w\n      have b'k : B b' ⊆ k := @Finset.subset_set_biUnion_of_mem _ _ _ (fun y : v => B y) _ b'w\n      have : (ball x (R x) \\ k ∩ k).Nonempty := by\n        apply ab.mono (inter_subset_inter _ b'k)\n        refine ((hB _ hat).trans ?_).trans hd\n        exact closedBall_subset_closedBall (ad.trans (min_le_left _ _))\n      simpa only [diff_inter_self, Set.not_nonempty_empty]\n    let b'' : { a // a ∉ w } := ⟨b', b'_notmem_w⟩\n    -- since `a` and `b` have comparable diameters, it follows that `z` belongs to the\n    -- enlargement of `b`\n    have zb : c a ∈ closedBall (c b) (3 * r b) := by\n      rcases ab with ⟨e, ⟨ea, eb⟩⟩\n      have A : dist (c a) e ≤ r a := mem_closedBall'.1 (hB a hat ea)\n      have B : dist e (c b) ≤ r b := mem_closedBall.1 (hB b (ut bu) eb)\n      simp only [mem_closedBall]\n      linarith only [dist_triangle (c a) e (c b), A, B, bdiam]\n    suffices H : closedBall (c b'') (3 * r b'')\n        ⊆ ⋃ a : { a // a ∉ w }, closedBall (c a) (3 * r a) from H zb\n    exact subset_iUnion (fun a : { a // a ∉ w } => closedBall (c a) (3 * r a)) b''\n  -- now that we have proved our main inclusion, we can use it to estimate the measure of the points\n  -- in `ball x (r x)` not covered by `u`.\n  haveI : Countable v := (u_count.mono vu).to_subtype\n  calc\n    μ ((s \\ ⋃ a ∈ u, B a) ∩ ball x (R x)) ≤ μ (⋃ a : { a // a ∉ w }, closedBall (c a) (3 * r a)) :=\n      measure_mono M\n    _ ≤ ∑' a : { a // a ∉ w }, μ (closedBall (c a) (3 * r a)) := measure_iUnion_le _\n    _ ≤ ∑' a : { a // a ∉ w }, C * μ (B a) := (ENNReal.tsum_le_tsum fun a => μB a (ut (vu a.1.2)))\n    _ = C * ∑' a : { a // a ∉ w }, μ (B a) := ENNReal.tsum_mul_left\n    _ ≤ C * (ε / C) := by gcongr\n    _ ≤ ε := ENNReal.mul_div_le\n\n"}
