{"name":"CategoryTheory.GradedObject.categoryOfGradedObjects_id","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nÎ² : Type w\nX : (i : Î²) â†’ (fun x => C) i\ni : Î²\nâŠ¢ Eq (CategoryTheory.CategoryStruct.id X i) (CategoryTheory.CategoryStruct.id (X i))","decl":"@[simps!]\ninstance categoryOfGradedObjects (Î² : Type w) : Category.{max w v} (GradedObject Î² C) :=\n  CategoryTheory.pi fun _ => C\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10688): added to ease automation\n"}
{"name":"CategoryTheory.GradedObject.categoryOfGradedObjects_comp","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nÎ² : Type w\nXâœ Yâœ Zâœ : (i : Î²) â†’ (fun x => C) i\nf : Quiver.Hom Xâœ Yâœ\ng : Quiver.Hom Yâœ Zâœ\ni : Î²\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f g i) (CategoryTheory.CategoryStruct.comp (f i) (g i))","decl":"@[simps!]\ninstance categoryOfGradedObjects (Î² : Type w) : Category.{max w v} (GradedObject Î² C) :=\n  CategoryTheory.pi fun _ => C\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10688): added to ease automation\n"}
{"name":"CategoryTheory.GradedObject.hom_ext_iff","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nÎ² : Type u_1\nX Y : CategoryTheory.GradedObject Î² C\nf g : Quiver.Hom X Y\nâŠ¢ Iff (Eq f g) (âˆ€ (x : Î²), Eq (f x) (g x))","decl":"@[ext]\nlemma hom_ext {Î² : Type*} {X Y : GradedObject Î² C} (f g : X âŸ¶ Y) (h : âˆ€ x, f x = g x) : f = g := by\n  funext\n  apply h\n\n"}
{"name":"CategoryTheory.GradedObject.hom_ext","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nÎ² : Type u_1\nX Y : CategoryTheory.GradedObject Î² C\nf g : Quiver.Hom X Y\nh : âˆ€ (x : Î²), Eq (f x) (g x)\nâŠ¢ Eq f g","decl":"@[ext]\nlemma hom_ext {Î² : Type*} {X Y : GradedObject Î² C} (f g : X âŸ¶ Y) (h : âˆ€ x, f x = g x) : f = g := by\n  funext\n  apply h\n\n"}
{"name":"CategoryTheory.GradedObject.eval_map","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nÎ² : Type w\nb : Î²\nXâœ Yâœ : CategoryTheory.GradedObject Î² C\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.GradedObject.eval b).map f) (f b)","decl":"/-- The projection of a graded object to its `i`-th component. -/\n@[simps]\ndef eval {Î² : Type w} (b : Î²) : GradedObject Î² C â¥¤ C where\n  obj X := X b\n  map f := f b\n\n"}
{"name":"CategoryTheory.GradedObject.eval_obj","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nÎ² : Type w\nb : Î²\nX : CategoryTheory.GradedObject Î² C\nâŠ¢ Eq ((CategoryTheory.GradedObject.eval b).obj X) (X b)","decl":"/-- The projection of a graded object to its `i`-th component. -/\n@[simps]\ndef eval {Î² : Type w} (b : Î²) : GradedObject Î² C â¥¤ C where\n  obj X := X b\n  map f := f b\n\n"}
{"name":"CategoryTheory.GradedObject.isoMk_hom","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nÎ² : Type u_1\nX Y : CategoryTheory.GradedObject Î² C\ne : (i : Î²) â†’ CategoryTheory.Iso (X i) (Y i)\ni : Î²\nâŠ¢ Eq ((X.isoMk Y e).hom i) (e i).hom","decl":"/-- Constructor for isomorphisms in `GradedObject` -/\n@[simps]\ndef isoMk (e : âˆ€ i, X i â‰… Y i) : X â‰… Y where\n  hom i := (e i).hom\n  inv i := (e i).inv\n\n"}
{"name":"CategoryTheory.GradedObject.isoMk_inv","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nÎ² : Type u_1\nX Y : CategoryTheory.GradedObject Î² C\ne : (i : Î²) â†’ CategoryTheory.Iso (X i) (Y i)\ni : Î²\nâŠ¢ Eq ((X.isoMk Y e).inv i) (e i).inv","decl":"/-- Constructor for isomorphisms in `GradedObject` -/\n@[simps]\ndef isoMk (e : âˆ€ i, X i â‰… Y i) : X â‰… Y where\n  hom i := (e i).hom\n  inv i := (e i).inv\n\n"}
{"name":"CategoryTheory.GradedObject.isIso_of_isIso_apply","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nÎ² : Type u_1\nX Y : CategoryTheory.GradedObject Î² C\nf : Quiver.Hom X Y\nhf : âˆ€ (i : Î²), CategoryTheory.IsIso (f i)\nâŠ¢ CategoryTheory.IsIso f","decl":"lemma isIso_of_isIso_apply (f : X âŸ¶ Y) [hf : âˆ€ i, IsIso (f i)] :\n    IsIso f := by\n  change IsIso (isoMk X Y (fun i => asIso (f i))).hom\n  infer_instance\n\n"}
{"name":"CategoryTheory.GradedObject.isIso_apply_of_isIso","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nÎ² : Type u_1\nX Y : CategoryTheory.GradedObject Î² C\nf : Quiver.Hom X Y\ninstâœ : CategoryTheory.IsIso f\ni : Î²\nâŠ¢ CategoryTheory.IsIso (f i)","decl":"instance isIso_apply_of_isIso (f : X âŸ¶ Y) [IsIso f] (i : Î²) : IsIso (f i) := by\n  change IsIso ((eval i).map f)\n  infer_instance\n\n"}
{"name":"CategoryTheory.Iso.hom_inv_id_eval","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nJ : Type u_4\ninstâœ : CategoryTheory.Category.{u_5, u_1} C\nX Y : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Y\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (e.hom j) (e.inv j)) (CategoryTheory.CategoryStruct.id (X j))","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id_eval (e : X â‰… Y) (j : J) :\n    e.hom j â‰« e.inv j = ğŸ™ _ := by\n  rw [â† GradedObject.categoryOfGradedObjects_comp, e.hom_inv_id,\n    GradedObject.categoryOfGradedObjects_id]\n\n"}
{"name":"CategoryTheory.Iso.hom_inv_id_eval_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nJ : Type u_4\ninstâœ : CategoryTheory.Category.{u_5, u_1} C\nX Y : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Y\nj : J\nZ : C\nh : Quiver.Hom (X j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (e.hom j) (CategoryTheory.CategoryStruct.comp (e.inv j) h)) h","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id_eval (e : X â‰… Y) (j : J) :\n    e.hom j â‰« e.inv j = ğŸ™ _ := by\n  rw [â† GradedObject.categoryOfGradedObjects_comp, e.hom_inv_id,\n    GradedObject.categoryOfGradedObjects_id]\n\n"}
{"name":"CategoryTheory.Iso.inv_hom_id_eval_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nJ : Type u_4\ninstâœ : CategoryTheory.Category.{u_5, u_1} C\nX Y : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Y\nj : J\nZ : C\nh : Quiver.Hom (Y j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (e.inv j) (CategoryTheory.CategoryStruct.comp (e.hom j) h)) h","decl":"@[reassoc (attr := simp)]\nlemma inv_hom_id_eval (e : X â‰… Y) (j : J) :\n    e.inv j â‰« e.hom j = ğŸ™ _ := by\n  rw [â† GradedObject.categoryOfGradedObjects_comp, e.inv_hom_id,\n    GradedObject.categoryOfGradedObjects_id]\n\n"}
{"name":"CategoryTheory.Iso.inv_hom_id_eval","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nJ : Type u_4\ninstâœ : CategoryTheory.Category.{u_5, u_1} C\nX Y : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Y\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (e.inv j) (e.hom j)) (CategoryTheory.CategoryStruct.id (Y j))","decl":"@[reassoc (attr := simp)]\nlemma inv_hom_id_eval (e : X â‰… Y) (j : J) :\n    e.inv j â‰« e.hom j = ğŸ™ _ := by\n  rw [â† GradedObject.categoryOfGradedObjects_comp, e.inv_hom_id,\n    GradedObject.categoryOfGradedObjects_id]\n\n"}
{"name":"CategoryTheory.Iso.map_hom_inv_id_eval_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nD : Type u_2\nJ : Type u_4\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_1} C\ninstâœ : CategoryTheory.Category.{u_6, u_2} D\nX Y : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Y\nF : CategoryTheory.Functor C D\nj : J\nZ : D\nh : Quiver.Hom (F.obj (X j)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (e.hom j)) (CategoryTheory.CategoryStruct.comp (F.map (e.inv j)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_hom_inv_id_eval (e : X â‰… Y) (F : C â¥¤ D) (j : J) :\n    F.map (e.hom j) â‰« F.map (e.inv j) = ğŸ™ _ := by\n  rw [â† F.map_comp, â† GradedObject.categoryOfGradedObjects_comp, e.hom_inv_id,\n    GradedObject.categoryOfGradedObjects_id, Functor.map_id]\n\n"}
{"name":"CategoryTheory.Iso.map_hom_inv_id_eval","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nD : Type u_2\nJ : Type u_4\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_1} C\ninstâœ : CategoryTheory.Category.{u_6, u_2} D\nX Y : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Y\nF : CategoryTheory.Functor C D\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (e.hom j)) (F.map (e.inv j))) (CategoryTheory.CategoryStruct.id (F.obj (X j)))","decl":"@[reassoc (attr := simp)]\nlemma map_hom_inv_id_eval (e : X â‰… Y) (F : C â¥¤ D) (j : J) :\n    F.map (e.hom j) â‰« F.map (e.inv j) = ğŸ™ _ := by\n  rw [â† F.map_comp, â† GradedObject.categoryOfGradedObjects_comp, e.hom_inv_id,\n    GradedObject.categoryOfGradedObjects_id, Functor.map_id]\n\n"}
{"name":"CategoryTheory.Iso.map_inv_hom_id_eval_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nD : Type u_2\nJ : Type u_4\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_1} C\ninstâœ : CategoryTheory.Category.{u_6, u_2} D\nX Y : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Y\nF : CategoryTheory.Functor C D\nj : J\nZ : D\nh : Quiver.Hom (F.obj (Y j)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (e.inv j)) (CategoryTheory.CategoryStruct.comp (F.map (e.hom j)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_inv_hom_id_eval (e : X â‰… Y) (F : C â¥¤ D) (j : J) :\n    F.map (e.inv j) â‰« F.map (e.hom j) = ğŸ™ _ := by\n  rw [â† F.map_comp, â† GradedObject.categoryOfGradedObjects_comp, e.inv_hom_id,\n    GradedObject.categoryOfGradedObjects_id, Functor.map_id]\n\n"}
{"name":"CategoryTheory.Iso.map_inv_hom_id_eval","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nD : Type u_2\nJ : Type u_4\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_1} C\ninstâœ : CategoryTheory.Category.{u_6, u_2} D\nX Y : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Y\nF : CategoryTheory.Functor C D\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (e.inv j)) (F.map (e.hom j))) (CategoryTheory.CategoryStruct.id (F.obj (Y j)))","decl":"@[reassoc (attr := simp)]\nlemma map_inv_hom_id_eval (e : X â‰… Y) (F : C â¥¤ D) (j : J) :\n    F.map (e.inv j) â‰« F.map (e.hom j) = ğŸ™ _ := by\n  rw [â† F.map_comp, â† GradedObject.categoryOfGradedObjects_comp, e.inv_hom_id,\n    GradedObject.categoryOfGradedObjects_id, Functor.map_id]\n\n"}
{"name":"CategoryTheory.Iso.map_hom_inv_id_eval_app_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\nJ : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_5, u_1} C\ninstâœÂ¹ : CategoryTheory.Category.{u_7, u_2} D\ninstâœ : CategoryTheory.Category.{u_6, u_3} E\nX Yâœ : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Yâœ\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nj : J\nY : D\nZ : E\nh : Quiver.Hom ((F.obj (X j)).obj Y) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map (e.hom j)).app Y) (CategoryTheory.CategoryStruct.comp ((F.map (e.inv j)).app Y) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_hom_inv_id_eval_app (e : X â‰… Y) (F : C â¥¤ D â¥¤ E) (j : J) (Y : D) :\n    (F.map (e.hom j)).app Y â‰« (F.map (e.inv j)).app Y = ğŸ™ _ := by\n  rw [â† NatTrans.comp_app, â† F.map_comp, hom_inv_id_eval,\n    Functor.map_id, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.Iso.map_hom_inv_id_eval_app","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\nJ : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_5, u_1} C\ninstâœÂ¹ : CategoryTheory.Category.{u_7, u_2} D\ninstâœ : CategoryTheory.Category.{u_6, u_3} E\nX Yâœ : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Yâœ\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nj : J\nY : D\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map (e.hom j)).app Y) ((F.map (e.inv j)).app Y)) (CategoryTheory.CategoryStruct.id ((F.obj (X j)).obj Y))","decl":"@[reassoc (attr := simp)]\nlemma map_hom_inv_id_eval_app (e : X â‰… Y) (F : C â¥¤ D â¥¤ E) (j : J) (Y : D) :\n    (F.map (e.hom j)).app Y â‰« (F.map (e.inv j)).app Y = ğŸ™ _ := by\n  rw [â† NatTrans.comp_app, â† F.map_comp, hom_inv_id_eval,\n    Functor.map_id, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.Iso.map_inv_hom_id_eval_app_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\nJ : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_5, u_1} C\ninstâœÂ¹ : CategoryTheory.Category.{u_7, u_2} D\ninstâœ : CategoryTheory.Category.{u_6, u_3} E\nX Yâœ : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Yâœ\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nj : J\nY : D\nZ : E\nh : Quiver.Hom ((F.obj (Yâœ j)).obj Y) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map (e.inv j)).app Y) (CategoryTheory.CategoryStruct.comp ((F.map (e.hom j)).app Y) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_inv_hom_id_eval_app (e : X â‰… Y) (F : C â¥¤ D â¥¤ E) (j : J) (Y : D) :\n    (F.map (e.inv j)).app Y â‰« (F.map (e.hom j)).app Y = ğŸ™ _ := by\n  rw [â† NatTrans.comp_app, â† F.map_comp, inv_hom_id_eval,\n    Functor.map_id, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.Iso.map_inv_hom_id_eval_app","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\nJ : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_5, u_1} C\ninstâœÂ¹ : CategoryTheory.Category.{u_7, u_2} D\ninstâœ : CategoryTheory.Category.{u_6, u_3} E\nX Yâœ : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Yâœ\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nj : J\nY : D\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map (e.inv j)).app Y) ((F.map (e.hom j)).app Y)) (CategoryTheory.CategoryStruct.id ((F.obj (Yâœ j)).obj Y))","decl":"@[reassoc (attr := simp)]\nlemma map_inv_hom_id_eval_app (e : X â‰… Y) (F : C â¥¤ D â¥¤ E) (j : J) (Y : D) :\n    (F.map (e.inv j)).app Y â‰« (F.map (e.hom j)).app Y = ğŸ™ _ := by\n  rw [â† NatTrans.comp_app, â† F.map_comp, inv_hom_id_eval,\n    Functor.map_id, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.GradedObject.eqToHom_proj","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nI : Type u_1\nx x' : CategoryTheory.GradedObject I C\nh : Eq x x'\ni : I\nâŠ¢ Eq (CategoryTheory.eqToHom h i) (CategoryTheory.eqToHom â‹¯)","decl":"@[simp]\ntheorem eqToHom_proj {I : Type*} {x x' : GradedObject I C} (h : x = x') (i : I) :\n    (eqToHom h : x âŸ¶ x') i = eqToHom (funext_iff.mp h i) := by\n  subst h\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.comapEq_hom_app","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nÎ² Î³ : Type w\nf g : Î² â†’ Î³\nh : Eq f g\nX : CategoryTheory.GradedObject Î³ C\nb : Î²\nâŠ¢ Eq ((CategoryTheory.GradedObject.comapEq C h).hom.app X b) (CategoryTheory.eqToHom â‹¯)","decl":"/-- The natural isomorphism comparing between\npulling back along two propositionally equal functions.\n-/\n@[simps]\ndef comapEq {Î² Î³ : Type w} {f g : Î² â†’ Î³} (h : f = g) : comap C f â‰… comap C g where\n  hom := { app := fun X b => eqToHom (by dsimp; simp only [h]) }\n  inv := { app := fun X b => eqToHom (by dsimp; simp only [h]) }\n\n"}
{"name":"CategoryTheory.GradedObject.comapEq_inv_app","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nÎ² Î³ : Type w\nf g : Î² â†’ Î³\nh : Eq f g\nX : CategoryTheory.GradedObject Î³ C\nb : Î²\nâŠ¢ Eq ((CategoryTheory.GradedObject.comapEq C h).inv.app X b) (CategoryTheory.eqToHom â‹¯)","decl":"/-- The natural isomorphism comparing between\npulling back along two propositionally equal functions.\n-/\n@[simps]\ndef comapEq {Î² Î³ : Type w} {f g : Î² â†’ Î³} (h : f = g) : comap C f â‰… comap C g where\n  hom := { app := fun X b => eqToHom (by dsimp; simp only [h]) }\n  inv := { app := fun X b => eqToHom (by dsimp; simp only [h]) }\n\n"}
{"name":"CategoryTheory.GradedObject.comapEq_symm","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nÎ² Î³ : Type w\nf g : Î² â†’ Î³\nh : Eq f g\nâŠ¢ Eq (CategoryTheory.GradedObject.comapEq C â‹¯) (CategoryTheory.GradedObject.comapEq C h).symm","decl":"theorem comapEq_symm {Î² Î³ : Type w} {f g : Î² â†’ Î³} (h : f = g) :\n    comapEq C h.symm = (comapEq C h).symm := by aesop_cat\n\n"}
{"name":"CategoryTheory.GradedObject.comapEq_trans","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nÎ² Î³ : Type w\nf g h : Î² â†’ Î³\nk : Eq f g\nl : Eq g h\nâŠ¢ Eq (CategoryTheory.GradedObject.comapEq C â‹¯) ((CategoryTheory.GradedObject.comapEq C k).trans (CategoryTheory.GradedObject.comapEq C l))","decl":"theorem comapEq_trans {Î² Î³ : Type w} {f g h : Î² â†’ Î³} (k : f = g) (l : g = h) :\n    comapEq C (k.trans l) = comapEq C k â‰ªâ‰« comapEq C l := by aesop_cat\n\n"}
{"name":"CategoryTheory.GradedObject.eqToHom_apply","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nÎ² : Type w\nX Y : Î² â†’ C\nh : Eq X Y\nb : Î²\nâŠ¢ Eq (CategoryTheory.eqToHom h b) (CategoryTheory.eqToHom â‹¯)","decl":"theorem eqToHom_apply {Î² : Type w} {X Y : Î² â†’ C} (h : X = Y) (b : Î²) :\n    (eqToHom h : X âŸ¶ Y) b = eqToHom (by rw [h]) := by\n  subst h\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.comapEquiv_functor","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nÎ² Î³ : Type w\ne : Equiv Î² Î³\nâŠ¢ Eq (CategoryTheory.GradedObject.comapEquiv C e).functor (CategoryTheory.GradedObject.comap C â‡‘e.symm)","decl":"/-- The equivalence between Î²-graded objects and Î³-graded objects,\ngiven an equivalence between Î² and Î³.\n-/\n@[simps]\ndef comapEquiv {Î² Î³ : Type w} (e : Î² â‰ƒ Î³) : GradedObject Î² C â‰Œ GradedObject Î³ C where\n  functor := comap C (e.symm : Î³ â†’ Î²)\n  inverse := comap C (e : Î² â†’ Î³)\n  counitIso :=\n    (Pi.comapComp (fun _ => C) _ _).trans (comapEq C (by ext; simp))\n  unitIso :=\n    (comapEq C (by ext; simp)).trans (Pi.comapComp _ _ _).symm\n\n"}
{"name":"CategoryTheory.GradedObject.comapEquiv_unitIso","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nÎ² Î³ : Type w\ne : Equiv Î² Î³\nâŠ¢ Eq (CategoryTheory.GradedObject.comapEquiv C e).unitIso ((CategoryTheory.GradedObject.comapEq C â‹¯).trans (CategoryTheory.Pi.comapComp (fun x => C) â‡‘e â‡‘e.symm).symm)","decl":"/-- The equivalence between Î²-graded objects and Î³-graded objects,\ngiven an equivalence between Î² and Î³.\n-/\n@[simps]\ndef comapEquiv {Î² Î³ : Type w} (e : Î² â‰ƒ Î³) : GradedObject Î² C â‰Œ GradedObject Î³ C where\n  functor := comap C (e.symm : Î³ â†’ Î²)\n  inverse := comap C (e : Î² â†’ Î³)\n  counitIso :=\n    (Pi.comapComp (fun _ => C) _ _).trans (comapEq C (by ext; simp))\n  unitIso :=\n    (comapEq C (by ext; simp)).trans (Pi.comapComp _ _ _).symm\n\n"}
{"name":"CategoryTheory.GradedObject.comapEquiv_counitIso","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nÎ² Î³ : Type w\ne : Equiv Î² Î³\nâŠ¢ Eq (CategoryTheory.GradedObject.comapEquiv C e).counitIso ((CategoryTheory.Pi.comapComp (fun x => C) â‡‘e.symm â‡‘e).trans (CategoryTheory.GradedObject.comapEq C â‹¯))","decl":"/-- The equivalence between Î²-graded objects and Î³-graded objects,\ngiven an equivalence between Î² and Î³.\n-/\n@[simps]\ndef comapEquiv {Î² Î³ : Type w} (e : Î² â‰ƒ Î³) : GradedObject Î² C â‰Œ GradedObject Î³ C where\n  functor := comap C (e.symm : Î³ â†’ Î²)\n  inverse := comap C (e : Î² â†’ Î³)\n  counitIso :=\n    (Pi.comapComp (fun _ => C) _ _).trans (comapEq C (by ext; simp))\n  unitIso :=\n    (comapEq C (by ext; simp)).trans (Pi.comapComp _ _ _).symm\n\n"}
{"name":"CategoryTheory.GradedObject.comapEquiv_inverse","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœ : CategoryTheory.Category.{v, u} C\nÎ² Î³ : Type w\ne : Equiv Î² Î³\nâŠ¢ Eq (CategoryTheory.GradedObject.comapEquiv C e).inverse (CategoryTheory.GradedObject.comap C â‡‘e)","decl":"/-- The equivalence between Î²-graded objects and Î³-graded objects,\ngiven an equivalence between Î² and Î³.\n-/\n@[simps]\ndef comapEquiv {Î² Î³ : Type w} (e : Î² â‰ƒ Î³) : GradedObject Î² C â‰Œ GradedObject Î³ C where\n  functor := comap C (e.symm : Î³ â†’ Î²)\n  inverse := comap C (e : Î² â†’ Î³)\n  counitIso :=\n    (Pi.comapComp (fun _ => C) _ _).trans (comapEq C (by ext; simp))\n  unitIso :=\n    (comapEq C (by ext; simp)).trans (Pi.comapComp _ _ _).symm\n\n"}
{"name":"CategoryTheory.GradedObject.shiftFunctor_obj_apply","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nÎ² : Type u_1\ninstâœ : AddCommGroup Î²\ns : Î²\nX : Î² â†’ C\nt : Î²\nn : Int\nâŠ¢ Eq ((CategoryTheory.shiftFunctor (CategoryTheory.GradedObjectWithShift s C) n).obj X t) (X (HAdd.hAdd t (HSMul.hSMul n s)))","decl":"@[simp]\ntheorem shiftFunctor_obj_apply {Î² : Type*} [AddCommGroup Î²] (s : Î²) (X : Î² â†’ C) (t : Î²) (n : â„¤) :\n    (shiftFunctor (GradedObjectWithShift s C) n).obj X t = X (t + n â€¢ s) :=\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.shiftFunctor_map_apply","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\nÎ² : Type u_1\ninstâœ : AddCommGroup Î²\ns : Î²\nX Y : CategoryTheory.GradedObjectWithShift s C\nf : Quiver.Hom X Y\nt : Î²\nn : Int\nâŠ¢ Eq ((CategoryTheory.shiftFunctor (CategoryTheory.GradedObjectWithShift s C) n).map f t) (f (HAdd.hAdd t (HSMul.hSMul n s)))","decl":"@[simp]\ntheorem shiftFunctor_map_apply {Î² : Type*} [AddCommGroup Î²] (s : Î²)\n    {X Y : GradedObjectWithShift s C} (f : X âŸ¶ Y) (t : Î²) (n : â„¤) :\n    (shiftFunctor (GradedObjectWithShift s C) n).map f t = f (t + n â€¢ s) :=\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.zero_apply","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nÎ² : Type w\nX Y : CategoryTheory.GradedObject Î² C\nb : Î²\nâŠ¢ Eq (0 b) 0","decl":"@[simp, nolint simpNF]\ntheorem zero_apply [HasZeroMorphisms C] (Î² : Type w) (X Y : GradedObject Î² C) (b : Î²) :\n    (0 : X âŸ¶ Y) b = 0 :=\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.hasZeroObject","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroObject C\ninstâœ : CategoryTheory.Limits.HasZeroMorphisms C\nÎ² : Type w\nâŠ¢ CategoryTheory.Limits.HasZeroObject (CategoryTheory.GradedObject Î² C)","decl":"instance hasZeroObject [HasZeroObject C] [HasZeroMorphisms C] (Î² : Type w) :\n    HasZeroObject.{max w v} (GradedObject Î² C) := by\n  refine âŸ¨âŸ¨fun _ => 0, fun X => âŸ¨âŸ¨âŸ¨fun b => 0âŸ©, fun f => ?_âŸ©âŸ©, fun X =>\n    âŸ¨âŸ¨âŸ¨fun b => 0âŸ©, fun f => ?_âŸ©âŸ©âŸ©âŸ© <;> aesop_cat\n\n"}
{"name":"CategoryTheory.GradedObject.instFaithfulTotal","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"Î² : Type\nC : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasCoproducts C\nâŠ¢ (CategoryTheory.GradedObject.total Î² C).Faithful","decl":"/--\nThe `total` functor taking a graded object to the coproduct of its graded components is faithful.\nTo prove this, we need to know that the coprojections into the coproduct are monomorphisms,\nwhich follows from the fact we have zero morphisms and decidable equality for the grading.\n-/\ninstance : (total Î² C).Faithful where\n  map_injective {X Y} f g w := by\n    ext i\n    replace w := Sigma.Î¹ (fun i : Î² => X i) i â‰«= w\n    erw [colimit.Î¹_map, colimit.Î¹_map] at w\n    simp? at * says simp only [Discrete.functor_obj_eq_as, Discrete.natTrans_app] at *\n    exact Mono.right_cancellation _ _ w\n\n"}
{"name":"CategoryTheory.GradedObject.hasMap_of_iso","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_4} C\nX Y : CategoryTheory.GradedObject I C\ne : CategoryTheory.Iso X Y\np : I â†’ J\ninstâœ : X.HasMap p\nâŠ¢ Y.HasMap p","decl":"variable {X Y} in\nlemma hasMap_of_iso (e : X â‰… Y) (p: I â†’ J) [HasMap X p] : HasMap Y p := fun j => by\n  have Î± : Discrete.functor (X.mapObjFun p j) â‰… Discrete.functor (Y.mapObjFun p j) :=\n    Discrete.natIso (fun âŸ¨i, _âŸ© => (GradedObject.eval i).mapIso e)\n  exact hasColimitOfIso Î±.symm\n\n"}
{"name":"CategoryTheory.GradedObject.mapObj_ext_iff","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I â†’ J\ninstâœ : X.HasMap p\nA : C\nj : J\nf g : Quiver.Hom (X.mapObj p j) A\nâŠ¢ Iff (Eq f g) (âˆ€ (i : I) (hij : Eq (p i) j), Eq (CategoryTheory.CategoryStruct.comp (X.Î¹MapObj p i j hij) f) (CategoryTheory.CategoryStruct.comp (X.Î¹MapObj p i j hij) g))","decl":"@[ext]\nlemma mapObj_ext {A : C} {j : J} (f g : X.mapObj p j âŸ¶ A)\n    (hfg : âˆ€ (i : I) (hij : p i = j), X.Î¹MapObj p i j hij â‰« f = X.Î¹MapObj p i j hij â‰« g) :\n    f = g :=\n  Cofan.IsColimit.hom_ext (X.isColimitCofanMapObj p j) _ _ (fun âŸ¨i, hijâŸ© => hfg i hij)\n\n"}
{"name":"CategoryTheory.GradedObject.mapObj_ext","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I â†’ J\ninstâœ : X.HasMap p\nA : C\nj : J\nf g : Quiver.Hom (X.mapObj p j) A\nhfg : âˆ€ (i : I) (hij : Eq (p i) j), Eq (CategoryTheory.CategoryStruct.comp (X.Î¹MapObj p i j hij) f) (CategoryTheory.CategoryStruct.comp (X.Î¹MapObj p i j hij) g)\nâŠ¢ Eq f g","decl":"@[ext]\nlemma mapObj_ext {A : C} {j : J} (f g : X.mapObj p j âŸ¶ A)\n    (hfg : âˆ€ (i : I) (hij : p i = j), X.Î¹MapObj p i j hij â‰« f = X.Î¹MapObj p i j hij â‰« g) :\n    f = g :=\n  Cofan.IsColimit.hom_ext (X.isColimitCofanMapObj p j) _ _ (fun âŸ¨i, hijâŸ© => hfg i hij)\n\n"}
{"name":"CategoryTheory.GradedObject.Î¹_descMapObj","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I â†’ J\ninstâœ : X.HasMap p\nA : C\nj : J\nÏ† : (i : I) â†’ Eq (p i) j â†’ Quiver.Hom (X i) A\ni : I\nhi : Eq (p i) j\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (X.Î¹MapObj p i j hi) (X.descMapObj p Ï†)) (Ï† i hi)","decl":"@[reassoc (attr := simp)]\nlemma Î¹_descMapObj {A : C} {j : J}\n    (Ï† : âˆ€ (i : I) (_ : p i = j), X i âŸ¶ A) (i : I) (hi : p i = j) :\n    X.Î¹MapObj p i j hi â‰« X.descMapObj p Ï† = Ï† i hi := by\n  apply Cofan.IsColimit.fac\n\n"}
{"name":"CategoryTheory.GradedObject.Î¹_descMapObj_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I â†’ J\ninstâœ : X.HasMap p\nA : C\nj : J\nÏ† : (i : I) â†’ Eq (p i) j â†’ Quiver.Hom (X i) A\ni : I\nhi : Eq (p i) j\nZ : C\nh : Quiver.Hom A Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (X.Î¹MapObj p i j hi) (CategoryTheory.CategoryStruct.comp (X.descMapObj p Ï†) h)) (CategoryTheory.CategoryStruct.comp (Ï† i hi) h)","decl":"@[reassoc (attr := simp)]\nlemma Î¹_descMapObj {A : C} {j : J}\n    (Ï† : âˆ€ (i : I) (_ : p i = j), X i âŸ¶ A) (i : I) (hi : p i = j) :\n    X.Î¹MapObj p i j hi â‰« X.descMapObj p Ï† = Ï† i hi := by\n  apply Cofan.IsColimit.fac\n\n"}
{"name":"CategoryTheory.GradedObject.CofanMapObjFun.hasMap","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœ : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I â†’ J\nc : (j : J) â†’ X.CofanMapObjFun p j\nhc : (j : J) â†’ CategoryTheory.Limits.IsColimit (c j)\nâŠ¢ X.HasMap p","decl":"lemma hasMap (c : âˆ€ j, CofanMapObjFun X p j) (hc : âˆ€ j, IsColimit (c j)) :\n    X.HasMap p := fun j => âŸ¨_, hc jâŸ©\n\n"}
{"name":"CategoryTheory.GradedObject.CofanMapObjFun.inj_iso_hom","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I â†’ J\nj : J\ninstâœ : X.HasMap p\nc : X.CofanMapObjFun p j\nhc : CategoryTheory.Limits.IsColimit c\ni : I\nhi : Eq (p i) j\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofan.inj c âŸ¨i, hiâŸ©) (CategoryTheory.GradedObject.CofanMapObjFun.iso hc).hom) (X.Î¹MapObj p i j hi)","decl":"@[reassoc (attr := simp)]\nlemma inj_iso_hom (i : I) (hi : p i = j) :\n    c.inj âŸ¨i, hiâŸ© â‰« (c.iso hc).hom = X.Î¹MapObj p i j hi := by\n  apply IsColimit.comp_coconePointUniqueUpToIso_hom\n\n"}
{"name":"CategoryTheory.GradedObject.CofanMapObjFun.inj_iso_hom_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I â†’ J\nj : J\ninstâœ : X.HasMap p\nc : X.CofanMapObjFun p j\nhc : CategoryTheory.Limits.IsColimit c\ni : I\nhi : Eq (p i) j\nZ : C\nh : Quiver.Hom (X.mapObj p j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofan.inj c âŸ¨i, hiâŸ©) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.CofanMapObjFun.iso hc).hom h)) (CategoryTheory.CategoryStruct.comp (X.Î¹MapObj p i j hi) h)","decl":"@[reassoc (attr := simp)]\nlemma inj_iso_hom (i : I) (hi : p i = j) :\n    c.inj âŸ¨i, hiâŸ© â‰« (c.iso hc).hom = X.Î¹MapObj p i j hi := by\n  apply IsColimit.comp_coconePointUniqueUpToIso_hom\n\n"}
{"name":"CategoryTheory.GradedObject.CofanMapObjFun.Î¹MapObj_iso_inv_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I â†’ J\nj : J\ninstâœ : X.HasMap p\nc : X.CofanMapObjFun p j\nhc : CategoryTheory.Limits.IsColimit c\ni : I\nhi : Eq (p i) j\nZ : C\nh : Quiver.Hom c.pt Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (X.Î¹MapObj p i j hi) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.CofanMapObjFun.iso hc).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofan.inj c âŸ¨i, hiâŸ©) h)","decl":"@[reassoc (attr := simp)]\nlemma Î¹MapObj_iso_inv (i : I) (hi : p i = j) :\n    X.Î¹MapObj p i j hi â‰« (c.iso hc).inv = c.inj âŸ¨i, hiâŸ© := by\n  apply IsColimit.comp_coconePointUniqueUpToIso_inv\n\n"}
{"name":"CategoryTheory.GradedObject.CofanMapObjFun.Î¹MapObj_iso_inv","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I â†’ J\nj : J\ninstâœ : X.HasMap p\nc : X.CofanMapObjFun p j\nhc : CategoryTheory.Limits.IsColimit c\ni : I\nhi : Eq (p i) j\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (X.Î¹MapObj p i j hi) (CategoryTheory.GradedObject.CofanMapObjFun.iso hc).inv) (CategoryTheory.Limits.Cofan.inj c âŸ¨i, hiâŸ©)","decl":"@[reassoc (attr := simp)]\nlemma Î¹MapObj_iso_inv (i : I) (hi : p i = j) :\n    X.Î¹MapObj p i j hi â‰« (c.iso hc).inv = c.inj âŸ¨i, hiâŸ© := by\n  apply IsColimit.comp_coconePointUniqueUpToIso_inv\n\n"}
{"name":"CategoryTheory.GradedObject.Î¹_mapMap_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_5, u_4} C\nX Y : CategoryTheory.GradedObject I C\nÏ† : Quiver.Hom X Y\np : I â†’ J\ninstâœÂ¹ : X.HasMap p\ninstâœ : Y.HasMap p\ni : I\nj : J\nhij : Eq (p i) j\nZ : C\nh : Quiver.Hom (Y.mapObj p j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (X.Î¹MapObj p i j hij) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapMap Ï† p j) h)) (CategoryTheory.CategoryStruct.comp (Ï† i) (CategoryTheory.CategoryStruct.comp (Y.Î¹MapObj p i j hij) h))","decl":"@[reassoc (attr := simp)]\nlemma Î¹_mapMap (i : I) (j : J) (hij : p i = j) :\n    X.Î¹MapObj p i j hij â‰« mapMap Ï† p j = Ï† i â‰« Y.Î¹MapObj p i j hij := by\n  simp only [mapMap, Î¹_descMapObj]\n\n"}
{"name":"CategoryTheory.GradedObject.Î¹_mapMap","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_5, u_4} C\nX Y : CategoryTheory.GradedObject I C\nÏ† : Quiver.Hom X Y\np : I â†’ J\ninstâœÂ¹ : X.HasMap p\ninstâœ : Y.HasMap p\ni : I\nj : J\nhij : Eq (p i) j\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (X.Î¹MapObj p i j hij) (CategoryTheory.GradedObject.mapMap Ï† p j)) (CategoryTheory.CategoryStruct.comp (Ï† i) (Y.Î¹MapObj p i j hij))","decl":"@[reassoc (attr := simp)]\nlemma Î¹_mapMap (i : I) (j : J) (hij : p i = j) :\n    X.Î¹MapObj p i j hij â‰« mapMap Ï† p j = Ï† i â‰« Y.Î¹MapObj p i j hij := by\n  simp only [mapMap, Î¹_descMapObj]\n\n"}
{"name":"CategoryTheory.GradedObject.congr_mapMap","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_5, u_4} C\nX Y : CategoryTheory.GradedObject I C\np : I â†’ J\ninstâœÂ¹ : X.HasMap p\ninstâœ : Y.HasMap p\nÏ†â‚ Ï†â‚‚ : Quiver.Hom X Y\nh : Eq Ï†â‚ Ï†â‚‚\nâŠ¢ Eq (CategoryTheory.GradedObject.mapMap Ï†â‚ p) (CategoryTheory.GradedObject.mapMap Ï†â‚‚ p)","decl":"lemma congr_mapMap (Ï†â‚ Ï†â‚‚ : X âŸ¶ Y) (h : Ï†â‚ = Ï†â‚‚) : mapMap Ï†â‚ p = mapMap Ï†â‚‚ p := by\n  subst h\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.mapMap_id","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I â†’ J\ninstâœ : X.HasMap p\nâŠ¢ Eq (CategoryTheory.GradedObject.mapMap (CategoryTheory.CategoryStruct.id X) p) (CategoryTheory.CategoryStruct.id (X.mapObj p))","decl":"@[simp]\nlemma mapMap_id : mapMap (ğŸ™ X) p = ğŸ™ _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.GradedObject.mapMap_comp_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_4} C\nX Y Zâœ : CategoryTheory.GradedObject I C\nÏ† : Quiver.Hom X Y\nÏˆ : Quiver.Hom Y Zâœ\np : I â†’ J\ninstâœÂ² : X.HasMap p\ninstâœÂ¹ : Y.HasMap p\ninstâœ : Zâœ.HasMap p\nZ : CategoryTheory.GradedObject J C\nh : Quiver.Hom (Zâœ.mapObj p) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapMap (CategoryTheory.CategoryStruct.comp Ï† Ïˆ) p) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapMap Ï† p) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapMap Ïˆ p) h))","decl":"@[simp, reassoc]\nlemma mapMap_comp [Z.HasMap p] : mapMap (Ï† â‰« Ïˆ) p = mapMap Ï† p â‰« mapMap Ïˆ p := by aesop_cat\n\n"}
{"name":"CategoryTheory.GradedObject.mapMap_comp","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_4} C\nX Y Z : CategoryTheory.GradedObject I C\nÏ† : Quiver.Hom X Y\nÏˆ : Quiver.Hom Y Z\np : I â†’ J\ninstâœÂ² : X.HasMap p\ninstâœÂ¹ : Y.HasMap p\ninstâœ : Z.HasMap p\nâŠ¢ Eq (CategoryTheory.GradedObject.mapMap (CategoryTheory.CategoryStruct.comp Ï† Ïˆ) p) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapMap Ï† p) (CategoryTheory.GradedObject.mapMap Ïˆ p))","decl":"@[simp, reassoc]\nlemma mapMap_comp [Z.HasMap p] : mapMap (Ï† â‰« Ïˆ) p = mapMap Ï† p â‰« mapMap Ïˆ p := by aesop_cat\n\n"}
{"name":"CategoryTheory.GradedObject.mapIso_hom","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_5, u_4} C\nX Y : CategoryTheory.GradedObject I C\ne : CategoryTheory.Iso X Y\np : I â†’ J\ninstâœÂ¹ : X.HasMap p\ninstâœ : Y.HasMap p\ni : J\nâŠ¢ Eq ((CategoryTheory.GradedObject.mapIso e p).hom i) (CategoryTheory.GradedObject.mapMap e.hom p i)","decl":"/-- The isomorphism of `J`-graded objects `X.mapObj p â‰… Y.mapObj p` induced by an\nisomorphism `X â‰… Y` of graded objects and a map `p : I â†’ J`. -/\n@[simps]\nnoncomputable def mapIso : X.mapObj p â‰… Y.mapObj p where\n  hom := mapMap e.hom p\n  inv := mapMap e.inv p\n\n"}
{"name":"CategoryTheory.GradedObject.mapIso_inv","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_5, u_4} C\nX Y : CategoryTheory.GradedObject I C\ne : CategoryTheory.Iso X Y\np : I â†’ J\ninstâœÂ¹ : X.HasMap p\ninstâœ : Y.HasMap p\ni : J\nâŠ¢ Eq ((CategoryTheory.GradedObject.mapIso e p).inv i) (CategoryTheory.GradedObject.mapMap e.inv p i)","decl":"/-- The isomorphism of `J`-graded objects `X.mapObj p â‰… Y.mapObj p` induced by an\nisomorphism `X â‰… Y` of graded objects and a map `p : I â†’ J`. -/\n@[simps]\nnoncomputable def mapIso : X.mapObj p â‰… Y.mapObj p where\n  hom := mapMap e.hom p\n  inv := mapMap e.inv p\n\n"}
{"name":"CategoryTheory.GradedObject.map_map","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_4} C\np : I â†’ J\ninstâœ : âˆ€ (j : J), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete â†‘(Set.preimage p (Singleton.singleton j))) C\nXâœ Yâœ : CategoryTheory.GradedObject I C\nÏ† : Quiver.Hom Xâœ Yâœ\ni : J\nâŠ¢ Eq ((CategoryTheory.GradedObject.map C p).map Ï† i) (CategoryTheory.GradedObject.mapMap Ï† p i)","decl":"/-- Given a map `p : I â†’ J`, this is the functor `GradedObject I C â¥¤ GradedObject J C` which\nsends an `I`-object `X` to the graded object `X.mapObj p` which in degree `j : J` is given\nby the coproduct of those `X i` such that `p i = j`. -/\n@[simps]\nnoncomputable def map [âˆ€ (j : J), HasColimitsOfShape (Discrete (p â»Â¹' {j})) C] :\n    GradedObject I C â¥¤ GradedObject J C where\n  obj X := X.mapObj p\n  map Ï† := mapMap Ï† p\n\n"}
{"name":"CategoryTheory.GradedObject.map_obj","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœÂ¹ : CategoryTheory.Category.{u_5, u_4} C\np : I â†’ J\ninstâœ : âˆ€ (j : J), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete â†‘(Set.preimage p (Singleton.singleton j))) C\nX : CategoryTheory.GradedObject I C\nâŠ¢ Eq ((CategoryTheory.GradedObject.map C p).obj X) (X.mapObj p)","decl":"/-- Given a map `p : I â†’ J`, this is the functor `GradedObject I C â¥¤ GradedObject J C` which\nsends an `I`-object `X` to the graded object `X.mapObj p` which in degree `j : J` is given\nby the coproduct of those `X i` such that `p i = j`. -/\n@[simps]\nnoncomputable def map [âˆ€ (j : J), HasColimitsOfShape (Discrete (p â»Â¹' {j})) C] :\n    GradedObject I C â¥¤ GradedObject J C where\n  obj X := X.mapObj p\n  map Ï† := mapMap Ï† p\n\n"}
{"name":"CategoryTheory.GradedObject.hasMap_comp","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nK : Type u_3\nC : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I â†’ J\ninstâœÂ¹ : X.HasMap p\nq : J â†’ K\nr : I â†’ K\nhpqr : âˆ€ (i : I), Eq (q (p i)) (r i)\ninstâœ : (X.mapObj p).HasMap q\nâŠ¢ X.HasMap r","decl":"include hpqr in\nlemma hasMap_comp [(X.mapObj p).HasMap q] : X.HasMap r :=\n  fun k => âŸ¨_, isColimitCofanMapObjComp X p q r hpqr k _\n    (fun j _ => X.isColimitCofanMapObj p j) _ ((X.mapObj p).isColimitCofanMapObj q k)âŸ©\n\n"}
{"name":"CategoryTheory.GradedObject.Î¹MapObjOrZero_eq","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I â†’ J\ninstâœÂ² : X.HasMap p\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : DecidableEq J\ni : I\nj : J\nh : Eq (p i) j\nâŠ¢ Eq (X.Î¹MapObjOrZero p i j) (X.Î¹MapObj p i j h)","decl":"lemma Î¹MapObjOrZero_eq (h : p i = j) : X.Î¹MapObjOrZero p i j = X.Î¹MapObj p i j h := dif_pos h\n\n"}
{"name":"CategoryTheory.GradedObject.Î¹MapObjOrZero_eq_zero","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I â†’ J\ninstâœÂ² : X.HasMap p\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : DecidableEq J\ni : I\nj : J\nh : Ne (p i) j\nâŠ¢ Eq (X.Î¹MapObjOrZero p i j) 0","decl":"lemma Î¹MapObjOrZero_eq_zero (h : p i â‰  j) : X.Î¹MapObjOrZero p i j = 0 := dif_neg h\n\n"}
{"name":"CategoryTheory.GradedObject.Î¹MapObjOrZero_mapMap","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœâ´ : CategoryTheory.Category.{u_5, u_4} C\nX Y : CategoryTheory.GradedObject I C\nÏ† : Quiver.Hom X Y\np : I â†’ J\ninstâœÂ³ : X.HasMap p\ninstâœÂ² : Y.HasMap p\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : DecidableEq J\ni : I\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (X.Î¹MapObjOrZero p i j) (CategoryTheory.GradedObject.mapMap Ï† p j)) (CategoryTheory.CategoryStruct.comp (Ï† i) (Y.Î¹MapObjOrZero p i j))","decl":"variable {X Y} in\n@[reassoc (attr := simp)]\nlemma Î¹MapObjOrZero_mapMap :\n    X.Î¹MapObjOrZero p i j â‰« mapMap Ï† p j = Ï† i â‰« Y.Î¹MapObjOrZero p i j := by\n  by_cases h : p i = j\n  Â· simp only [Î¹MapObjOrZero_eq _ _ _ _ h, Î¹_mapMap]\n  Â· simp only [Î¹MapObjOrZero_eq_zero _ _ _ _ h, zero_comp, comp_zero]\n\n"}
{"name":"CategoryTheory.GradedObject.Î¹MapObjOrZero_mapMap_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninstâœâ´ : CategoryTheory.Category.{u_5, u_4} C\nX Y : CategoryTheory.GradedObject I C\nÏ† : Quiver.Hom X Y\np : I â†’ J\ninstâœÂ³ : X.HasMap p\ninstâœÂ² : Y.HasMap p\ninstâœÂ¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninstâœ : DecidableEq J\ni : I\nj : J\nZ : C\nh : Quiver.Hom (Y.mapObj p j) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (X.Î¹MapObjOrZero p i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapMap Ï† p j) h)) (CategoryTheory.CategoryStruct.comp (Ï† i) (CategoryTheory.CategoryStruct.comp (Y.Î¹MapObjOrZero p i j) h))","decl":"variable {X Y} in\n@[reassoc (attr := simp)]\nlemma Î¹MapObjOrZero_mapMap :\n    X.Î¹MapObjOrZero p i j â‰« mapMap Ï† p j = Ï† i â‰« Y.Î¹MapObjOrZero p i j := by\n  by_cases h : p i = j\n  Â· simp only [Î¹MapObjOrZero_eq _ _ _ _ h, Î¹_mapMap]\n  Â· simp only [Î¹MapObjOrZero_eq_zero _ _ _ _ h, zero_comp, comp_zero]\n\n"}
