{"name":"CategoryTheory.GradedObject.categoryOfGradedObjects_id","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒ≤ : Type w\nX : (i : Œ≤) ‚Üí (fun x => C) i\ni : Œ≤\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X i) (CategoryTheory.CategoryStruct.id (X i))","decl":"@[simps!]\ninstance categoryOfGradedObjects (Œ≤ : Type w) : Category.{max w v} (GradedObject Œ≤ C) :=\n  CategoryTheory.pi fun _ => C\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10688): added to ease automation\n"}
{"name":"CategoryTheory.GradedObject.categoryOfGradedObjects_comp","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒ≤ : Type w\nX‚úù Y‚úù Z‚úù : (i : Œ≤) ‚Üí (fun x => C) i\nf : Quiver.Hom X‚úù Y‚úù\ng : Quiver.Hom Y‚úù Z‚úù\ni : Œ≤\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g i) (CategoryTheory.CategoryStruct.comp (f i) (g i))","decl":"@[simps!]\ninstance categoryOfGradedObjects (Œ≤ : Type w) : Category.{max w v} (GradedObject Œ≤ C) :=\n  CategoryTheory.pi fun _ => C\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10688): added to ease automation\n"}
{"name":"CategoryTheory.GradedObject.hom_ext_iff","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒ≤ : Type u_1\nX Y : CategoryTheory.GradedObject Œ≤ C\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (‚àÄ (x : Œ≤), Eq (f x) (g x))","decl":"@[ext]\nlemma hom_ext {Œ≤ : Type*} {X Y : GradedObject Œ≤ C} (f g : X ‚ü∂ Y) (h : ‚àÄ x, f x = g x) : f = g := by\n  funext\n  apply h\n\n"}
{"name":"CategoryTheory.GradedObject.hom_ext","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒ≤ : Type u_1\nX Y : CategoryTheory.GradedObject Œ≤ C\nf g : Quiver.Hom X Y\nh : ‚àÄ (x : Œ≤), Eq (f x) (g x)\n‚ä¢ Eq f g","decl":"@[ext]\nlemma hom_ext {Œ≤ : Type*} {X Y : GradedObject Œ≤ C} (f g : X ‚ü∂ Y) (h : ‚àÄ x, f x = g x) : f = g := by\n  funext\n  apply h\n\n"}
{"name":"CategoryTheory.GradedObject.eval_map","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒ≤ : Type w\nb : Œ≤\nX‚úù Y‚úù : CategoryTheory.GradedObject Œ≤ C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.GradedObject.eval b).map f) (f b)","decl":"/-- The projection of a graded object to its `i`-th component. -/\n@[simps]\ndef eval {Œ≤ : Type w} (b : Œ≤) : GradedObject Œ≤ C ‚•§ C where\n  obj X := X b\n  map f := f b\n\n"}
{"name":"CategoryTheory.GradedObject.eval_obj","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒ≤ : Type w\nb : Œ≤\nX : CategoryTheory.GradedObject Œ≤ C\n‚ä¢ Eq ((CategoryTheory.GradedObject.eval b).obj X) (X b)","decl":"/-- The projection of a graded object to its `i`-th component. -/\n@[simps]\ndef eval {Œ≤ : Type w} (b : Œ≤) : GradedObject Œ≤ C ‚•§ C where\n  obj X := X b\n  map f := f b\n\n"}
{"name":"CategoryTheory.GradedObject.isoMk_hom","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒ≤ : Type u_1\nX Y : CategoryTheory.GradedObject Œ≤ C\ne : (i : Œ≤) ‚Üí CategoryTheory.Iso (X i) (Y i)\ni : Œ≤\n‚ä¢ Eq ((X.isoMk Y e).hom i) (e i).hom","decl":"/-- Constructor for isomorphisms in `GradedObject` -/\n@[simps]\ndef isoMk (e : ‚àÄ i, X i ‚âÖ Y i) : X ‚âÖ Y where\n  hom i := (e i).hom\n  inv i := (e i).inv\n\n"}
{"name":"CategoryTheory.GradedObject.isoMk_inv","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒ≤ : Type u_1\nX Y : CategoryTheory.GradedObject Œ≤ C\ne : (i : Œ≤) ‚Üí CategoryTheory.Iso (X i) (Y i)\ni : Œ≤\n‚ä¢ Eq ((X.isoMk Y e).inv i) (e i).inv","decl":"/-- Constructor for isomorphisms in `GradedObject` -/\n@[simps]\ndef isoMk (e : ‚àÄ i, X i ‚âÖ Y i) : X ‚âÖ Y where\n  hom i := (e i).hom\n  inv i := (e i).inv\n\n"}
{"name":"CategoryTheory.GradedObject.isIso_of_isIso_apply","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒ≤ : Type u_1\nX Y : CategoryTheory.GradedObject Œ≤ C\nf : Quiver.Hom X Y\nhf : ‚àÄ (i : Œ≤), CategoryTheory.IsIso (f i)\n‚ä¢ CategoryTheory.IsIso f","decl":"lemma isIso_of_isIso_apply (f : X ‚ü∂ Y) [hf : ‚àÄ i, IsIso (f i)] :\n    IsIso f := by\n  change IsIso (isoMk X Y (fun i => asIso (f i))).hom\n  infer_instance\n\n"}
{"name":"CategoryTheory.GradedObject.isIso_apply_of_isIso","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nŒ≤ : Type u_1\nX Y : CategoryTheory.GradedObject Œ≤ C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.IsIso f\ni : Œ≤\n‚ä¢ CategoryTheory.IsIso (f i)","decl":"instance isIso_apply_of_isIso (f : X ‚ü∂ Y) [IsIso f] (i : Œ≤) : IsIso (f i) := by\n  change IsIso ((eval i).map f)\n  infer_instance\n\n"}
{"name":"CategoryTheory.Iso.hom_inv_id_eval","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nJ : Type u_4\ninst‚úù : CategoryTheory.Category.{u_5, u_1} C\nX Y : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Y\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (e.hom j) (e.inv j)) (CategoryTheory.CategoryStruct.id (X j))","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id_eval (e : X ‚âÖ Y) (j : J) :\n    e.hom j ‚â´ e.inv j = ùüô _ := by\n  rw [‚Üê GradedObject.categoryOfGradedObjects_comp, e.hom_inv_id,\n    GradedObject.categoryOfGradedObjects_id]\n\n"}
{"name":"CategoryTheory.Iso.hom_inv_id_eval_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nJ : Type u_4\ninst‚úù : CategoryTheory.Category.{u_5, u_1} C\nX Y : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Y\nj : J\nZ : C\nh : Quiver.Hom (X j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (e.hom j) (CategoryTheory.CategoryStruct.comp (e.inv j) h)) h","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id_eval (e : X ‚âÖ Y) (j : J) :\n    e.hom j ‚â´ e.inv j = ùüô _ := by\n  rw [‚Üê GradedObject.categoryOfGradedObjects_comp, e.hom_inv_id,\n    GradedObject.categoryOfGradedObjects_id]\n\n"}
{"name":"CategoryTheory.Iso.inv_hom_id_eval_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nJ : Type u_4\ninst‚úù : CategoryTheory.Category.{u_5, u_1} C\nX Y : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Y\nj : J\nZ : C\nh : Quiver.Hom (Y j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (e.inv j) (CategoryTheory.CategoryStruct.comp (e.hom j) h)) h","decl":"@[reassoc (attr := simp)]\nlemma inv_hom_id_eval (e : X ‚âÖ Y) (j : J) :\n    e.inv j ‚â´ e.hom j = ùüô _ := by\n  rw [‚Üê GradedObject.categoryOfGradedObjects_comp, e.inv_hom_id,\n    GradedObject.categoryOfGradedObjects_id]\n\n"}
{"name":"CategoryTheory.Iso.inv_hom_id_eval","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nJ : Type u_4\ninst‚úù : CategoryTheory.Category.{u_5, u_1} C\nX Y : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Y\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (e.inv j) (e.hom j)) (CategoryTheory.CategoryStruct.id (Y j))","decl":"@[reassoc (attr := simp)]\nlemma inv_hom_id_eval (e : X ‚âÖ Y) (j : J) :\n    e.inv j ‚â´ e.hom j = ùüô _ := by\n  rw [‚Üê GradedObject.categoryOfGradedObjects_comp, e.inv_hom_id,\n    GradedObject.categoryOfGradedObjects_id]\n\n"}
{"name":"CategoryTheory.Iso.map_hom_inv_id_eval_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nD : Type u_2\nJ : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù : CategoryTheory.Category.{u_6, u_2} D\nX Y : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Y\nF : CategoryTheory.Functor C D\nj : J\nZ : D\nh : Quiver.Hom (F.obj (X j)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (e.hom j)) (CategoryTheory.CategoryStruct.comp (F.map (e.inv j)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_hom_inv_id_eval (e : X ‚âÖ Y) (F : C ‚•§ D) (j : J) :\n    F.map (e.hom j) ‚â´ F.map (e.inv j) = ùüô _ := by\n  rw [‚Üê F.map_comp, ‚Üê GradedObject.categoryOfGradedObjects_comp, e.hom_inv_id,\n    GradedObject.categoryOfGradedObjects_id, Functor.map_id]\n\n"}
{"name":"CategoryTheory.Iso.map_hom_inv_id_eval","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nD : Type u_2\nJ : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù : CategoryTheory.Category.{u_6, u_2} D\nX Y : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Y\nF : CategoryTheory.Functor C D\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (e.hom j)) (F.map (e.inv j))) (CategoryTheory.CategoryStruct.id (F.obj (X j)))","decl":"@[reassoc (attr := simp)]\nlemma map_hom_inv_id_eval (e : X ‚âÖ Y) (F : C ‚•§ D) (j : J) :\n    F.map (e.hom j) ‚â´ F.map (e.inv j) = ùüô _ := by\n  rw [‚Üê F.map_comp, ‚Üê GradedObject.categoryOfGradedObjects_comp, e.hom_inv_id,\n    GradedObject.categoryOfGradedObjects_id, Functor.map_id]\n\n"}
{"name":"CategoryTheory.Iso.map_inv_hom_id_eval_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nD : Type u_2\nJ : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù : CategoryTheory.Category.{u_6, u_2} D\nX Y : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Y\nF : CategoryTheory.Functor C D\nj : J\nZ : D\nh : Quiver.Hom (F.obj (Y j)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (e.inv j)) (CategoryTheory.CategoryStruct.comp (F.map (e.hom j)) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_inv_hom_id_eval (e : X ‚âÖ Y) (F : C ‚•§ D) (j : J) :\n    F.map (e.inv j) ‚â´ F.map (e.hom j) = ùüô _ := by\n  rw [‚Üê F.map_comp, ‚Üê GradedObject.categoryOfGradedObjects_comp, e.inv_hom_id,\n    GradedObject.categoryOfGradedObjects_id, Functor.map_id]\n\n"}
{"name":"CategoryTheory.Iso.map_inv_hom_id_eval","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nD : Type u_2\nJ : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù : CategoryTheory.Category.{u_6, u_2} D\nX Y : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Y\nF : CategoryTheory.Functor C D\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map (e.inv j)) (F.map (e.hom j))) (CategoryTheory.CategoryStruct.id (F.obj (Y j)))","decl":"@[reassoc (attr := simp)]\nlemma map_inv_hom_id_eval (e : X ‚âÖ Y) (F : C ‚•§ D) (j : J) :\n    F.map (e.inv j) ‚â´ F.map (e.hom j) = ùüô _ := by\n  rw [‚Üê F.map_comp, ‚Üê GradedObject.categoryOfGradedObjects_comp, e.inv_hom_id,\n    GradedObject.categoryOfGradedObjects_id, Functor.map_id]\n\n"}
{"name":"CategoryTheory.Iso.map_hom_inv_id_eval_app_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\nJ : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_7, u_2} D\ninst‚úù : CategoryTheory.Category.{u_6, u_3} E\nX Y‚úù : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Y‚úù\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nj : J\nY : D\nZ : E\nh : Quiver.Hom ((F.obj (X j)).obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map (e.hom j)).app Y) (CategoryTheory.CategoryStruct.comp ((F.map (e.inv j)).app Y) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_hom_inv_id_eval_app (e : X ‚âÖ Y) (F : C ‚•§ D ‚•§ E) (j : J) (Y : D) :\n    (F.map (e.hom j)).app Y ‚â´ (F.map (e.inv j)).app Y = ùüô _ := by\n  rw [‚Üê NatTrans.comp_app, ‚Üê F.map_comp, hom_inv_id_eval,\n    Functor.map_id, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.Iso.map_hom_inv_id_eval_app","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\nJ : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_7, u_2} D\ninst‚úù : CategoryTheory.Category.{u_6, u_3} E\nX Y‚úù : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Y‚úù\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nj : J\nY : D\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map (e.hom j)).app Y) ((F.map (e.inv j)).app Y)) (CategoryTheory.CategoryStruct.id ((F.obj (X j)).obj Y))","decl":"@[reassoc (attr := simp)]\nlemma map_hom_inv_id_eval_app (e : X ‚âÖ Y) (F : C ‚•§ D ‚•§ E) (j : J) (Y : D) :\n    (F.map (e.hom j)).app Y ‚â´ (F.map (e.inv j)).app Y = ùüô _ := by\n  rw [‚Üê NatTrans.comp_app, ‚Üê F.map_comp, hom_inv_id_eval,\n    Functor.map_id, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.Iso.map_inv_hom_id_eval_app_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\nJ : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_7, u_2} D\ninst‚úù : CategoryTheory.Category.{u_6, u_3} E\nX Y‚úù : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Y‚úù\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nj : J\nY : D\nZ : E\nh : Quiver.Hom ((F.obj (Y‚úù j)).obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map (e.inv j)).app Y) (CategoryTheory.CategoryStruct.comp ((F.map (e.hom j)).app Y) h)) h","decl":"@[reassoc (attr := simp)]\nlemma map_inv_hom_id_eval_app (e : X ‚âÖ Y) (F : C ‚•§ D ‚•§ E) (j : J) (Y : D) :\n    (F.map (e.inv j)).app Y ‚â´ (F.map (e.hom j)).app Y = ùüô _ := by\n  rw [‚Üê NatTrans.comp_app, ‚Üê F.map_comp, inv_hom_id_eval,\n    Functor.map_id, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.Iso.map_inv_hom_id_eval_app","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\nJ : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_1} C\ninst‚úù¬π : CategoryTheory.Category.{u_7, u_2} D\ninst‚úù : CategoryTheory.Category.{u_6, u_3} E\nX Y‚úù : CategoryTheory.GradedObject J C\ne : CategoryTheory.Iso X Y‚úù\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nj : J\nY : D\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((F.map (e.inv j)).app Y) ((F.map (e.hom j)).app Y)) (CategoryTheory.CategoryStruct.id ((F.obj (Y‚úù j)).obj Y))","decl":"@[reassoc (attr := simp)]\nlemma map_inv_hom_id_eval_app (e : X ‚âÖ Y) (F : C ‚•§ D ‚•§ E) (j : J) (Y : D) :\n    (F.map (e.inv j)).app Y ‚â´ (F.map (e.hom j)).app Y = ùüô _ := by\n  rw [‚Üê NatTrans.comp_app, ‚Üê F.map_comp, inv_hom_id_eval,\n    Functor.map_id, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.GradedObject.eqToHom_proj","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nI : Type u_1\nx x' : CategoryTheory.GradedObject I C\nh : Eq x x'\ni : I\n‚ä¢ Eq (CategoryTheory.eqToHom h i) (CategoryTheory.eqToHom ‚ãØ)","decl":"@[simp]\ntheorem eqToHom_proj {I : Type*} {x x' : GradedObject I C} (h : x = x') (i : I) :\n    (eqToHom h : x ‚ü∂ x') i = eqToHom (funext_iff.mp h i) := by\n  subst h\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.comapEq_hom_app","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒ≤ Œ≥ : Type w\nf g : Œ≤ ‚Üí Œ≥\nh : Eq f g\nX : CategoryTheory.GradedObject Œ≥ C\nb : Œ≤\n‚ä¢ Eq ((CategoryTheory.GradedObject.comapEq C h).hom.app X b) (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- The natural isomorphism comparing between\npulling back along two propositionally equal functions.\n-/\n@[simps]\ndef comapEq {Œ≤ Œ≥ : Type w} {f g : Œ≤ ‚Üí Œ≥} (h : f = g) : comap C f ‚âÖ comap C g where\n  hom := { app := fun X b => eqToHom (by dsimp; simp only [h]) }\n  inv := { app := fun X b => eqToHom (by dsimp; simp only [h]) }\n\n"}
{"name":"CategoryTheory.GradedObject.comapEq_inv_app","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒ≤ Œ≥ : Type w\nf g : Œ≤ ‚Üí Œ≥\nh : Eq f g\nX : CategoryTheory.GradedObject Œ≥ C\nb : Œ≤\n‚ä¢ Eq ((CategoryTheory.GradedObject.comapEq C h).inv.app X b) (CategoryTheory.eqToHom ‚ãØ)","decl":"/-- The natural isomorphism comparing between\npulling back along two propositionally equal functions.\n-/\n@[simps]\ndef comapEq {Œ≤ Œ≥ : Type w} {f g : Œ≤ ‚Üí Œ≥} (h : f = g) : comap C f ‚âÖ comap C g where\n  hom := { app := fun X b => eqToHom (by dsimp; simp only [h]) }\n  inv := { app := fun X b => eqToHom (by dsimp; simp only [h]) }\n\n"}
{"name":"CategoryTheory.GradedObject.comapEq_symm","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒ≤ Œ≥ : Type w\nf g : Œ≤ ‚Üí Œ≥\nh : Eq f g\n‚ä¢ Eq (CategoryTheory.GradedObject.comapEq C ‚ãØ) (CategoryTheory.GradedObject.comapEq C h).symm","decl":"theorem comapEq_symm {Œ≤ Œ≥ : Type w} {f g : Œ≤ ‚Üí Œ≥} (h : f = g) :\n    comapEq C h.symm = (comapEq C h).symm := by aesop_cat\n\n"}
{"name":"CategoryTheory.GradedObject.comapEq_trans","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒ≤ Œ≥ : Type w\nf g h : Œ≤ ‚Üí Œ≥\nk : Eq f g\nl : Eq g h\n‚ä¢ Eq (CategoryTheory.GradedObject.comapEq C ‚ãØ) ((CategoryTheory.GradedObject.comapEq C k).trans (CategoryTheory.GradedObject.comapEq C l))","decl":"theorem comapEq_trans {Œ≤ Œ≥ : Type w} {f g h : Œ≤ ‚Üí Œ≥} (k : f = g) (l : g = h) :\n    comapEq C (k.trans l) = comapEq C k ‚â™‚â´ comapEq C l := by aesop_cat\n\n"}
{"name":"CategoryTheory.GradedObject.eqToHom_apply","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒ≤ : Type w\nX Y : Œ≤ ‚Üí C\nh : Eq X Y\nb : Œ≤\n‚ä¢ Eq (CategoryTheory.eqToHom h b) (CategoryTheory.eqToHom ‚ãØ)","decl":"theorem eqToHom_apply {Œ≤ : Type w} {X Y : Œ≤ ‚Üí C} (h : X = Y) (b : Œ≤) :\n    (eqToHom h : X ‚ü∂ Y) b = eqToHom (by rw [h]) := by\n  subst h\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.comapEquiv_functor","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒ≤ Œ≥ : Type w\ne : Equiv Œ≤ Œ≥\n‚ä¢ Eq (CategoryTheory.GradedObject.comapEquiv C e).functor (CategoryTheory.GradedObject.comap C ‚áëe.symm)","decl":"/-- The equivalence between Œ≤-graded objects and Œ≥-graded objects,\ngiven an equivalence between Œ≤ and Œ≥.\n-/\n@[simps]\ndef comapEquiv {Œ≤ Œ≥ : Type w} (e : Œ≤ ‚âÉ Œ≥) : GradedObject Œ≤ C ‚âå GradedObject Œ≥ C where\n  functor := comap C (e.symm : Œ≥ ‚Üí Œ≤)\n  inverse := comap C (e : Œ≤ ‚Üí Œ≥)\n  counitIso :=\n    (Pi.comapComp (fun _ => C) _ _).trans (comapEq C (by ext; simp))\n  unitIso :=\n    (comapEq C (by ext; simp)).trans (Pi.comapComp _ _ _).symm\n\n"}
{"name":"CategoryTheory.GradedObject.comapEquiv_unitIso","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒ≤ Œ≥ : Type w\ne : Equiv Œ≤ Œ≥\n‚ä¢ Eq (CategoryTheory.GradedObject.comapEquiv C e).unitIso ((CategoryTheory.GradedObject.comapEq C ‚ãØ).trans (CategoryTheory.Pi.comapComp (fun x => C) ‚áëe ‚áëe.symm).symm)","decl":"/-- The equivalence between Œ≤-graded objects and Œ≥-graded objects,\ngiven an equivalence between Œ≤ and Œ≥.\n-/\n@[simps]\ndef comapEquiv {Œ≤ Œ≥ : Type w} (e : Œ≤ ‚âÉ Œ≥) : GradedObject Œ≤ C ‚âå GradedObject Œ≥ C where\n  functor := comap C (e.symm : Œ≥ ‚Üí Œ≤)\n  inverse := comap C (e : Œ≤ ‚Üí Œ≥)\n  counitIso :=\n    (Pi.comapComp (fun _ => C) _ _).trans (comapEq C (by ext; simp))\n  unitIso :=\n    (comapEq C (by ext; simp)).trans (Pi.comapComp _ _ _).symm\n\n"}
{"name":"CategoryTheory.GradedObject.comapEquiv_counitIso","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒ≤ Œ≥ : Type w\ne : Equiv Œ≤ Œ≥\n‚ä¢ Eq (CategoryTheory.GradedObject.comapEquiv C e).counitIso ((CategoryTheory.Pi.comapComp (fun x => C) ‚áëe.symm ‚áëe).trans (CategoryTheory.GradedObject.comapEq C ‚ãØ))","decl":"/-- The equivalence between Œ≤-graded objects and Œ≥-graded objects,\ngiven an equivalence between Œ≤ and Œ≥.\n-/\n@[simps]\ndef comapEquiv {Œ≤ Œ≥ : Type w} (e : Œ≤ ‚âÉ Œ≥) : GradedObject Œ≤ C ‚âå GradedObject Œ≥ C where\n  functor := comap C (e.symm : Œ≥ ‚Üí Œ≤)\n  inverse := comap C (e : Œ≤ ‚Üí Œ≥)\n  counitIso :=\n    (Pi.comapComp (fun _ => C) _ _).trans (comapEq C (by ext; simp))\n  unitIso :=\n    (comapEq C (by ext; simp)).trans (Pi.comapComp _ _ _).symm\n\n"}
{"name":"CategoryTheory.GradedObject.comapEquiv_inverse","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nŒ≤ Œ≥ : Type w\ne : Equiv Œ≤ Œ≥\n‚ä¢ Eq (CategoryTheory.GradedObject.comapEquiv C e).inverse (CategoryTheory.GradedObject.comap C ‚áëe)","decl":"/-- The equivalence between Œ≤-graded objects and Œ≥-graded objects,\ngiven an equivalence between Œ≤ and Œ≥.\n-/\n@[simps]\ndef comapEquiv {Œ≤ Œ≥ : Type w} (e : Œ≤ ‚âÉ Œ≥) : GradedObject Œ≤ C ‚âå GradedObject Œ≥ C where\n  functor := comap C (e.symm : Œ≥ ‚Üí Œ≤)\n  inverse := comap C (e : Œ≤ ‚Üí Œ≥)\n  counitIso :=\n    (Pi.comapComp (fun _ => C) _ _).trans (comapEq C (by ext; simp))\n  unitIso :=\n    (comapEq C (by ext; simp)).trans (Pi.comapComp _ _ _).symm\n\n"}
{"name":"CategoryTheory.GradedObject.shiftFunctor_obj_apply","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nŒ≤ : Type u_1\ninst‚úù : AddCommGroup Œ≤\ns : Œ≤\nX : Œ≤ ‚Üí C\nt : Œ≤\nn : Int\n‚ä¢ Eq ((CategoryTheory.shiftFunctor (CategoryTheory.GradedObjectWithShift s C) n).obj X t) (X (HAdd.hAdd t (HSMul.hSMul n s)))","decl":"@[simp]\ntheorem shiftFunctor_obj_apply {Œ≤ : Type*} [AddCommGroup Œ≤] (s : Œ≤) (X : Œ≤ ‚Üí C) (t : Œ≤) (n : ‚Ñ§) :\n    (shiftFunctor (GradedObjectWithShift s C) n).obj X t = X (t + n ‚Ä¢ s) :=\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.shiftFunctor_map_apply","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nŒ≤ : Type u_1\ninst‚úù : AddCommGroup Œ≤\ns : Œ≤\nX Y : CategoryTheory.GradedObjectWithShift s C\nf : Quiver.Hom X Y\nt : Œ≤\nn : Int\n‚ä¢ Eq ((CategoryTheory.shiftFunctor (CategoryTheory.GradedObjectWithShift s C) n).map f t) (f (HAdd.hAdd t (HSMul.hSMul n s)))","decl":"@[simp]\ntheorem shiftFunctor_map_apply {Œ≤ : Type*} [AddCommGroup Œ≤] (s : Œ≤)\n    {X Y : GradedObjectWithShift s C} (f : X ‚ü∂ Y) (t : Œ≤) (n : ‚Ñ§) :\n    (shiftFunctor (GradedObjectWithShift s C) n).map f t = f (t + n ‚Ä¢ s) :=\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.zero_apply","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nŒ≤ : Type w\nX Y : CategoryTheory.GradedObject Œ≤ C\nb : Œ≤\n‚ä¢ Eq (0 b) 0","decl":"@[simp, nolint simpNF]\ntheorem zero_apply [HasZeroMorphisms C] (Œ≤ : Type w) (X Y : GradedObject Œ≤ C) (b : Œ≤) :\n    (0 : X ‚ü∂ Y) b = 0 :=\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.hasZeroObject","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroObject C\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nŒ≤ : Type w\n‚ä¢ CategoryTheory.Limits.HasZeroObject (CategoryTheory.GradedObject Œ≤ C)","decl":"instance hasZeroObject [HasZeroObject C] [HasZeroMorphisms C] (Œ≤ : Type w) :\n    HasZeroObject.{max w v} (GradedObject Œ≤ C) := by\n  refine ‚ü®‚ü®fun _ => 0, fun X => ‚ü®‚ü®‚ü®fun b => 0‚ü©, fun f => ?_‚ü©‚ü©, fun X =>\n    ‚ü®‚ü®‚ü®fun b => 0‚ü©, fun f => ?_‚ü©‚ü©‚ü©‚ü© <;> aesop_cat\n\n"}
{"name":"CategoryTheory.GradedObject.instFaithfulTotal","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"Œ≤ : Type\nC : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasCoproducts C\n‚ä¢ (CategoryTheory.GradedObject.total Œ≤ C).Faithful","decl":"/--\nThe `total` functor taking a graded object to the coproduct of its graded components is faithful.\nTo prove this, we need to know that the coprojections into the coproduct are monomorphisms,\nwhich follows from the fact we have zero morphisms and decidable equality for the grading.\n-/\ninstance : (total Œ≤ C).Faithful where\n  map_injective {X Y} f g w := by\n    ext i\n    replace w := Sigma.Œπ (fun i : Œ≤ => X i) i ‚â´= w\n    erw [colimit.Œπ_map, colimit.Œπ_map] at w\n    simp? at * says simp only [Discrete.functor_obj_eq_as, Discrete.natTrans_app] at *\n    exact Mono.right_cancellation _ _ w\n\n"}
{"name":"CategoryTheory.GradedObject.hasMap_of_iso","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_4} C\nX Y : CategoryTheory.GradedObject I C\ne : CategoryTheory.Iso X Y\np : I ‚Üí J\ninst‚úù : X.HasMap p\n‚ä¢ Y.HasMap p","decl":"variable {X Y} in\nlemma hasMap_of_iso (e : X ‚âÖ Y) (p: I ‚Üí J) [HasMap X p] : HasMap Y p := fun j => by\n  have Œ± : Discrete.functor (X.mapObjFun p j) ‚âÖ Discrete.functor (Y.mapObjFun p j) :=\n    Discrete.natIso (fun ‚ü®i, _‚ü© => (GradedObject.eval i).mapIso e)\n  exact hasColimitOfIso Œ±.symm\n\n"}
{"name":"CategoryTheory.GradedObject.mapObj_ext_iff","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I ‚Üí J\ninst‚úù : X.HasMap p\nA : C\nj : J\nf g : Quiver.Hom (X.mapObj p j) A\n‚ä¢ Iff (Eq f g) (‚àÄ (i : I) (hij : Eq (p i) j), Eq (CategoryTheory.CategoryStruct.comp (X.ŒπMapObj p i j hij) f) (CategoryTheory.CategoryStruct.comp (X.ŒπMapObj p i j hij) g))","decl":"@[ext]\nlemma mapObj_ext {A : C} {j : J} (f g : X.mapObj p j ‚ü∂ A)\n    (hfg : ‚àÄ (i : I) (hij : p i = j), X.ŒπMapObj p i j hij ‚â´ f = X.ŒπMapObj p i j hij ‚â´ g) :\n    f = g :=\n  Cofan.IsColimit.hom_ext (X.isColimitCofanMapObj p j) _ _ (fun ‚ü®i, hij‚ü© => hfg i hij)\n\n"}
{"name":"CategoryTheory.GradedObject.mapObj_ext","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I ‚Üí J\ninst‚úù : X.HasMap p\nA : C\nj : J\nf g : Quiver.Hom (X.mapObj p j) A\nhfg : ‚àÄ (i : I) (hij : Eq (p i) j), Eq (CategoryTheory.CategoryStruct.comp (X.ŒπMapObj p i j hij) f) (CategoryTheory.CategoryStruct.comp (X.ŒπMapObj p i j hij) g)\n‚ä¢ Eq f g","decl":"@[ext]\nlemma mapObj_ext {A : C} {j : J} (f g : X.mapObj p j ‚ü∂ A)\n    (hfg : ‚àÄ (i : I) (hij : p i = j), X.ŒπMapObj p i j hij ‚â´ f = X.ŒπMapObj p i j hij ‚â´ g) :\n    f = g :=\n  Cofan.IsColimit.hom_ext (X.isColimitCofanMapObj p j) _ _ (fun ‚ü®i, hij‚ü© => hfg i hij)\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_descMapObj","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I ‚Üí J\ninst‚úù : X.HasMap p\nA : C\nj : J\nœÜ : (i : I) ‚Üí Eq (p i) j ‚Üí Quiver.Hom (X i) A\ni : I\nhi : Eq (p i) j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.ŒπMapObj p i j hi) (X.descMapObj p œÜ)) (œÜ i hi)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_descMapObj {A : C} {j : J}\n    (œÜ : ‚àÄ (i : I) (_ : p i = j), X i ‚ü∂ A) (i : I) (hi : p i = j) :\n    X.ŒπMapObj p i j hi ‚â´ X.descMapObj p œÜ = œÜ i hi := by\n  apply Cofan.IsColimit.fac\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_descMapObj_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I ‚Üí J\ninst‚úù : X.HasMap p\nA : C\nj : J\nœÜ : (i : I) ‚Üí Eq (p i) j ‚Üí Quiver.Hom (X i) A\ni : I\nhi : Eq (p i) j\nZ : C\nh : Quiver.Hom A Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.ŒπMapObj p i j hi) (CategoryTheory.CategoryStruct.comp (X.descMapObj p œÜ) h)) (CategoryTheory.CategoryStruct.comp (œÜ i hi) h)","decl":"@[reassoc (attr := simp)]\nlemma Œπ_descMapObj {A : C} {j : J}\n    (œÜ : ‚àÄ (i : I) (_ : p i = j), X i ‚ü∂ A) (i : I) (hi : p i = j) :\n    X.ŒπMapObj p i j hi ‚â´ X.descMapObj p œÜ = œÜ i hi := by\n  apply Cofan.IsColimit.fac\n\n"}
{"name":"CategoryTheory.GradedObject.CofanMapObjFun.hasMap","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I ‚Üí J\nc : (j : J) ‚Üí X.CofanMapObjFun p j\nhc : (j : J) ‚Üí CategoryTheory.Limits.IsColimit (c j)\n‚ä¢ X.HasMap p","decl":"lemma hasMap (c : ‚àÄ j, CofanMapObjFun X p j) (hc : ‚àÄ j, IsColimit (c j)) :\n    X.HasMap p := fun j => ‚ü®_, hc j‚ü©\n\n"}
{"name":"CategoryTheory.GradedObject.CofanMapObjFun.inj_iso_hom","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I ‚Üí J\nj : J\ninst‚úù : X.HasMap p\nc : X.CofanMapObjFun p j\nhc : CategoryTheory.Limits.IsColimit c\ni : I\nhi : Eq (p i) j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofan.inj c ‚ü®i, hi‚ü©) (CategoryTheory.GradedObject.CofanMapObjFun.iso hc).hom) (X.ŒπMapObj p i j hi)","decl":"@[reassoc (attr := simp)]\nlemma inj_iso_hom (i : I) (hi : p i = j) :\n    c.inj ‚ü®i, hi‚ü© ‚â´ (c.iso hc).hom = X.ŒπMapObj p i j hi := by\n  apply IsColimit.comp_coconePointUniqueUpToIso_hom\n\n"}
{"name":"CategoryTheory.GradedObject.CofanMapObjFun.inj_iso_hom_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I ‚Üí J\nj : J\ninst‚úù : X.HasMap p\nc : X.CofanMapObjFun p j\nhc : CategoryTheory.Limits.IsColimit c\ni : I\nhi : Eq (p i) j\nZ : C\nh : Quiver.Hom (X.mapObj p j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofan.inj c ‚ü®i, hi‚ü©) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.CofanMapObjFun.iso hc).hom h)) (CategoryTheory.CategoryStruct.comp (X.ŒπMapObj p i j hi) h)","decl":"@[reassoc (attr := simp)]\nlemma inj_iso_hom (i : I) (hi : p i = j) :\n    c.inj ‚ü®i, hi‚ü© ‚â´ (c.iso hc).hom = X.ŒπMapObj p i j hi := by\n  apply IsColimit.comp_coconePointUniqueUpToIso_hom\n\n"}
{"name":"CategoryTheory.GradedObject.CofanMapObjFun.ŒπMapObj_iso_inv_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I ‚Üí J\nj : J\ninst‚úù : X.HasMap p\nc : X.CofanMapObjFun p j\nhc : CategoryTheory.Limits.IsColimit c\ni : I\nhi : Eq (p i) j\nZ : C\nh : Quiver.Hom c.pt Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.ŒπMapObj p i j hi) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.CofanMapObjFun.iso hc).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofan.inj c ‚ü®i, hi‚ü©) h)","decl":"@[reassoc (attr := simp)]\nlemma ŒπMapObj_iso_inv (i : I) (hi : p i = j) :\n    X.ŒπMapObj p i j hi ‚â´ (c.iso hc).inv = c.inj ‚ü®i, hi‚ü© := by\n  apply IsColimit.comp_coconePointUniqueUpToIso_inv\n\n"}
{"name":"CategoryTheory.GradedObject.CofanMapObjFun.ŒπMapObj_iso_inv","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I ‚Üí J\nj : J\ninst‚úù : X.HasMap p\nc : X.CofanMapObjFun p j\nhc : CategoryTheory.Limits.IsColimit c\ni : I\nhi : Eq (p i) j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.ŒπMapObj p i j hi) (CategoryTheory.GradedObject.CofanMapObjFun.iso hc).inv) (CategoryTheory.Limits.Cofan.inj c ‚ü®i, hi‚ü©)","decl":"@[reassoc (attr := simp)]\nlemma ŒπMapObj_iso_inv (i : I) (hi : p i = j) :\n    X.ŒπMapObj p i j hi ‚â´ (c.iso hc).inv = c.inj ‚ü®i, hi‚ü© := by\n  apply IsColimit.comp_coconePointUniqueUpToIso_inv\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_mapMap_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_4} C\nX Y : CategoryTheory.GradedObject I C\nœÜ : Quiver.Hom X Y\np : I ‚Üí J\ninst‚úù¬π : X.HasMap p\ninst‚úù : Y.HasMap p\ni : I\nj : J\nhij : Eq (p i) j\nZ : C\nh : Quiver.Hom (Y.mapObj p j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.ŒπMapObj p i j hij) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapMap œÜ p j) h)) (CategoryTheory.CategoryStruct.comp (œÜ i) (CategoryTheory.CategoryStruct.comp (Y.ŒπMapObj p i j hij) h))","decl":"@[reassoc (attr := simp)]\nlemma Œπ_mapMap (i : I) (j : J) (hij : p i = j) :\n    X.ŒπMapObj p i j hij ‚â´ mapMap œÜ p j = œÜ i ‚â´ Y.ŒπMapObj p i j hij := by\n  simp only [mapMap, Œπ_descMapObj]\n\n"}
{"name":"CategoryTheory.GradedObject.Œπ_mapMap","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_4} C\nX Y : CategoryTheory.GradedObject I C\nœÜ : Quiver.Hom X Y\np : I ‚Üí J\ninst‚úù¬π : X.HasMap p\ninst‚úù : Y.HasMap p\ni : I\nj : J\nhij : Eq (p i) j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.ŒπMapObj p i j hij) (CategoryTheory.GradedObject.mapMap œÜ p j)) (CategoryTheory.CategoryStruct.comp (œÜ i) (Y.ŒπMapObj p i j hij))","decl":"@[reassoc (attr := simp)]\nlemma Œπ_mapMap (i : I) (j : J) (hij : p i = j) :\n    X.ŒπMapObj p i j hij ‚â´ mapMap œÜ p j = œÜ i ‚â´ Y.ŒπMapObj p i j hij := by\n  simp only [mapMap, Œπ_descMapObj]\n\n"}
{"name":"CategoryTheory.GradedObject.congr_mapMap","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_4} C\nX Y : CategoryTheory.GradedObject I C\np : I ‚Üí J\ninst‚úù¬π : X.HasMap p\ninst‚úù : Y.HasMap p\nœÜ‚ÇÅ œÜ‚ÇÇ : Quiver.Hom X Y\nh : Eq œÜ‚ÇÅ œÜ‚ÇÇ\n‚ä¢ Eq (CategoryTheory.GradedObject.mapMap œÜ‚ÇÅ p) (CategoryTheory.GradedObject.mapMap œÜ‚ÇÇ p)","decl":"lemma congr_mapMap (œÜ‚ÇÅ œÜ‚ÇÇ : X ‚ü∂ Y) (h : œÜ‚ÇÅ = œÜ‚ÇÇ) : mapMap œÜ‚ÇÅ p = mapMap œÜ‚ÇÇ p := by\n  subst h\n  rfl\n\n"}
{"name":"CategoryTheory.GradedObject.mapMap_id","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I ‚Üí J\ninst‚úù : X.HasMap p\n‚ä¢ Eq (CategoryTheory.GradedObject.mapMap (CategoryTheory.CategoryStruct.id X) p) (CategoryTheory.CategoryStruct.id (X.mapObj p))","decl":"@[simp]\nlemma mapMap_id : mapMap (ùüô X) p = ùüô _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.GradedObject.mapMap_comp_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_4} C\nX Y Z‚úù : CategoryTheory.GradedObject I C\nœÜ : Quiver.Hom X Y\nœà : Quiver.Hom Y Z‚úù\np : I ‚Üí J\ninst‚úù¬≤ : X.HasMap p\ninst‚úù¬π : Y.HasMap p\ninst‚úù : Z‚úù.HasMap p\nZ : CategoryTheory.GradedObject J C\nh : Quiver.Hom (Z‚úù.mapObj p) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapMap (CategoryTheory.CategoryStruct.comp œÜ œà) p) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapMap œÜ p) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapMap œà p) h))","decl":"@[simp, reassoc]\nlemma mapMap_comp [Z.HasMap p] : mapMap (œÜ ‚â´ œà) p = mapMap œÜ p ‚â´ mapMap œà p := by aesop_cat\n\n"}
{"name":"CategoryTheory.GradedObject.mapMap_comp","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_4} C\nX Y Z : CategoryTheory.GradedObject I C\nœÜ : Quiver.Hom X Y\nœà : Quiver.Hom Y Z\np : I ‚Üí J\ninst‚úù¬≤ : X.HasMap p\ninst‚úù¬π : Y.HasMap p\ninst‚úù : Z.HasMap p\n‚ä¢ Eq (CategoryTheory.GradedObject.mapMap (CategoryTheory.CategoryStruct.comp œÜ œà) p) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapMap œÜ p) (CategoryTheory.GradedObject.mapMap œà p))","decl":"@[simp, reassoc]\nlemma mapMap_comp [Z.HasMap p] : mapMap (œÜ ‚â´ œà) p = mapMap œÜ p ‚â´ mapMap œà p := by aesop_cat\n\n"}
{"name":"CategoryTheory.GradedObject.mapIso_hom","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_4} C\nX Y : CategoryTheory.GradedObject I C\ne : CategoryTheory.Iso X Y\np : I ‚Üí J\ninst‚úù¬π : X.HasMap p\ninst‚úù : Y.HasMap p\ni : J\n‚ä¢ Eq ((CategoryTheory.GradedObject.mapIso e p).hom i) (CategoryTheory.GradedObject.mapMap e.hom p i)","decl":"/-- The isomorphism of `J`-graded objects `X.mapObj p ‚âÖ Y.mapObj p` induced by an\nisomorphism `X ‚âÖ Y` of graded objects and a map `p : I ‚Üí J`. -/\n@[simps]\nnoncomputable def mapIso : X.mapObj p ‚âÖ Y.mapObj p where\n  hom := mapMap e.hom p\n  inv := mapMap e.inv p\n\n"}
{"name":"CategoryTheory.GradedObject.mapIso_inv","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_4} C\nX Y : CategoryTheory.GradedObject I C\ne : CategoryTheory.Iso X Y\np : I ‚Üí J\ninst‚úù¬π : X.HasMap p\ninst‚úù : Y.HasMap p\ni : J\n‚ä¢ Eq ((CategoryTheory.GradedObject.mapIso e p).inv i) (CategoryTheory.GradedObject.mapMap e.inv p i)","decl":"/-- The isomorphism of `J`-graded objects `X.mapObj p ‚âÖ Y.mapObj p` induced by an\nisomorphism `X ‚âÖ Y` of graded objects and a map `p : I ‚Üí J`. -/\n@[simps]\nnoncomputable def mapIso : X.mapObj p ‚âÖ Y.mapObj p where\n  hom := mapMap e.hom p\n  inv := mapMap e.inv p\n\n"}
{"name":"CategoryTheory.GradedObject.map_map","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_4} C\np : I ‚Üí J\ninst‚úù : ‚àÄ (j : J), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete ‚Üë(Set.preimage p (Singleton.singleton j))) C\nX‚úù Y‚úù : CategoryTheory.GradedObject I C\nœÜ : Quiver.Hom X‚úù Y‚úù\ni : J\n‚ä¢ Eq ((CategoryTheory.GradedObject.map C p).map œÜ i) (CategoryTheory.GradedObject.mapMap œÜ p i)","decl":"/-- Given a map `p : I ‚Üí J`, this is the functor `GradedObject I C ‚•§ GradedObject J C` which\nsends an `I`-object `X` to the graded object `X.mapObj p` which in degree `j : J` is given\nby the coproduct of those `X i` such that `p i = j`. -/\n@[simps]\nnoncomputable def map [‚àÄ (j : J), HasColimitsOfShape (Discrete (p ‚Åª¬π' {j})) C] :\n    GradedObject I C ‚•§ GradedObject J C where\n  obj X := X.mapObj p\n  map œÜ := mapMap œÜ p\n\n"}
{"name":"CategoryTheory.GradedObject.map_obj","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù¬π : CategoryTheory.Category.{u_5, u_4} C\np : I ‚Üí J\ninst‚úù : ‚àÄ (j : J), CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Discrete ‚Üë(Set.preimage p (Singleton.singleton j))) C\nX : CategoryTheory.GradedObject I C\n‚ä¢ Eq ((CategoryTheory.GradedObject.map C p).obj X) (X.mapObj p)","decl":"/-- Given a map `p : I ‚Üí J`, this is the functor `GradedObject I C ‚•§ GradedObject J C` which\nsends an `I`-object `X` to the graded object `X.mapObj p` which in degree `j : J` is given\nby the coproduct of those `X i` such that `p i = j`. -/\n@[simps]\nnoncomputable def map [‚àÄ (j : J), HasColimitsOfShape (Discrete (p ‚Åª¬π' {j})) C] :\n    GradedObject I C ‚•§ GradedObject J C where\n  obj X := X.mapObj p\n  map œÜ := mapMap œÜ p\n\n"}
{"name":"CategoryTheory.GradedObject.hasMap_comp","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nK : Type u_3\nC : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I ‚Üí J\ninst‚úù¬π : X.HasMap p\nq : J ‚Üí K\nr : I ‚Üí K\nhpqr : ‚àÄ (i : I), Eq (q (p i)) (r i)\ninst‚úù : (X.mapObj p).HasMap q\n‚ä¢ X.HasMap r","decl":"include hpqr in\nlemma hasMap_comp [(X.mapObj p).HasMap q] : X.HasMap r :=\n  fun k => ‚ü®_, isColimitCofanMapObjComp X p q r hpqr k _\n    (fun j _ => X.isColimitCofanMapObj p j) _ ((X.mapObj p).isColimitCofanMapObj q k)‚ü©\n\n"}
{"name":"CategoryTheory.GradedObject.ŒπMapObjOrZero_eq","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I ‚Üí J\ninst‚úù¬≤ : X.HasMap p\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : DecidableEq J\ni : I\nj : J\nh : Eq (p i) j\n‚ä¢ Eq (X.ŒπMapObjOrZero p i j) (X.ŒπMapObj p i j h)","decl":"lemma ŒπMapObjOrZero_eq (h : p i = j) : X.ŒπMapObjOrZero p i j = X.ŒπMapObj p i j h := dif_pos h\n\n"}
{"name":"CategoryTheory.GradedObject.ŒπMapObjOrZero_eq_zero","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_4} C\nX : CategoryTheory.GradedObject I C\np : I ‚Üí J\ninst‚úù¬≤ : X.HasMap p\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : DecidableEq J\ni : I\nj : J\nh : Ne (p i) j\n‚ä¢ Eq (X.ŒπMapObjOrZero p i j) 0","decl":"lemma ŒπMapObjOrZero_eq_zero (h : p i ‚â† j) : X.ŒπMapObjOrZero p i j = 0 := dif_neg h\n\n"}
{"name":"CategoryTheory.GradedObject.ŒπMapObjOrZero_mapMap","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_4} C\nX Y : CategoryTheory.GradedObject I C\nœÜ : Quiver.Hom X Y\np : I ‚Üí J\ninst‚úù¬≥ : X.HasMap p\ninst‚úù¬≤ : Y.HasMap p\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : DecidableEq J\ni : I\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.ŒπMapObjOrZero p i j) (CategoryTheory.GradedObject.mapMap œÜ p j)) (CategoryTheory.CategoryStruct.comp (œÜ i) (Y.ŒπMapObjOrZero p i j))","decl":"variable {X Y} in\n@[reassoc (attr := simp)]\nlemma ŒπMapObjOrZero_mapMap :\n    X.ŒπMapObjOrZero p i j ‚â´ mapMap œÜ p j = œÜ i ‚â´ Y.ŒπMapObjOrZero p i j := by\n  by_cases h : p i = j\n  ¬∑ simp only [ŒπMapObjOrZero_eq _ _ _ _ h, Œπ_mapMap]\n  ¬∑ simp only [ŒπMapObjOrZero_eq_zero _ _ _ _ h, zero_comp, comp_zero]\n\n"}
{"name":"CategoryTheory.GradedObject.ŒπMapObjOrZero_mapMap_assoc","module":"Mathlib.CategoryTheory.GradedObject","initialProofState":"I : Type u_1\nJ : Type u_2\nC : Type u_4\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_5, u_4} C\nX Y : CategoryTheory.GradedObject I C\nœÜ : Quiver.Hom X Y\np : I ‚Üí J\ninst‚úù¬≥ : X.HasMap p\ninst‚úù¬≤ : Y.HasMap p\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù : DecidableEq J\ni : I\nj : J\nZ : C\nh : Quiver.Hom (Y.mapObj p j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.ŒπMapObjOrZero p i j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.GradedObject.mapMap œÜ p j) h)) (CategoryTheory.CategoryStruct.comp (œÜ i) (CategoryTheory.CategoryStruct.comp (Y.ŒπMapObjOrZero p i j) h))","decl":"variable {X Y} in\n@[reassoc (attr := simp)]\nlemma ŒπMapObjOrZero_mapMap :\n    X.ŒπMapObjOrZero p i j ‚â´ mapMap œÜ p j = œÜ i ‚â´ Y.ŒπMapObjOrZero p i j := by\n  by_cases h : p i = j\n  ¬∑ simp only [ŒπMapObjOrZero_eq _ _ _ _ h, Œπ_mapMap]\n  ¬∑ simp only [ŒπMapObjOrZero_eq_zero _ _ _ _ h, zero_comp, comp_zero]\n\n"}
