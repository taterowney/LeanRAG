{"name":"Ideal.jacobson_bot_polynomial_le_sInf_map_maximal","module":"Mathlib.RingTheory.Jacobson.Polynomial","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ LE.le Bot.bot.jacobson (InfSet.sInf (Set.image (Ideal.map Polynomial.C) (setOf fun J => J.IsMaximal)))","decl":"theorem jacobson_bot_polynomial_le_sInf_map_maximal :\n    jacobson (⊥ : Ideal R[X]) ≤ sInf (map (C : R →+* R[X]) '' { J : Ideal R | J.IsMaximal }) := by\n  refine le_sInf fun J => exists_imp.2 fun j hj => ?_\n  haveI : j.IsMaximal := hj.1\n  refine Trans.trans (jacobson_mono bot_le) (le_of_eq ?_ : J.jacobson ≤ J)\n  suffices t : (⊥ : Ideal (Polynomial (R ⧸ j))).jacobson = ⊥ by\n    rw [← hj.2, jacobson_eq_iff_jacobson_quotient_eq_bot]\n    replace t := congr_arg (map (polynomialQuotientEquivQuotientPolynomial j).toRingHom) t\n    rwa [map_jacobson_of_bijective _, map_bot] at t\n    exact RingEquiv.bijective (polynomialQuotientEquivQuotientPolynomial j)\n  refine eq_bot_iff.2 fun f hf => ?_\n  have r1 : (X : (R ⧸ j)[X]) ≠ 0 := ne_of_apply_ne (coeff · 1) <| by simp\n  simpa [r1] using eq_C_of_degree_eq_zero (degree_eq_zero_of_isUnit ((mem_jacobson_bot.1 hf) X))\n\n"}
{"name":"Ideal.jacobson_bot_polynomial_of_jacobson_bot","module":"Mathlib.RingTheory.Jacobson.Polynomial","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nh : Eq Bot.bot.jacobson Bot.bot\n⊢ Eq Bot.bot.jacobson Bot.bot","decl":"theorem jacobson_bot_polynomial_of_jacobson_bot (h : jacobson (⊥ : Ideal R) = ⊥) :\n    jacobson (⊥ : Ideal R[X]) = ⊥ := by\n  refine eq_bot_iff.2 (le_trans jacobson_bot_polynomial_le_sInf_map_maximal ?_)\n  refine fun f hf => (Submodule.mem_bot R[X]).2 <| Polynomial.ext fun n =>\n    Trans.trans (?_ : coeff f n = 0) (coeff_zero n).symm\n  suffices f.coeff n ∈ Ideal.jacobson ⊥ by rwa [h, Submodule.mem_bot] at this\n  exact mem_sInf.2 fun j hj => (mem_map_C_iff.1 ((mem_sInf.1 hf) ⟨j, ⟨hj.2, rfl⟩⟩)) n\n\n"}
