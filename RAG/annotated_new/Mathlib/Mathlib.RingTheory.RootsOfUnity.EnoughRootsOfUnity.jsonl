{"name":"HasEnoughRootsOfUnity.prim","module":"Mathlib.RingTheory.RootsOfUnity.EnoughRootsOfUnity","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nn : Nat\nself : HasEnoughRootsOfUnity M n\n⊢ Exists fun m => IsPrimitiveRoot m n","decl":"/-- This is a type class recording that a commutative monoid `M` contains primitive `n`th\nroots of unity and such that the group of `n`th roots of unity is cyclic.\n\nSuch monoids are suitable targets in the context of duality statements for groups\nof exponent `n`. -/\nclass HasEnoughRootsOfUnity (M : Type*) [CommMonoid M] (n : ℕ) where\n  prim : ∃ m : M, IsPrimitiveRoot m n\n  cyc : IsCyclic <| rootsOfUnity n M\n\n"}
{"name":"HasEnoughRootsOfUnity.cyc","module":"Mathlib.RingTheory.RootsOfUnity.EnoughRootsOfUnity","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\nn : Nat\nself : HasEnoughRootsOfUnity M n\n⊢ IsCyclic (Subtype fun x => Membership.mem (rootsOfUnity n M) x)","decl":"/-- This is a type class recording that a commutative monoid `M` contains primitive `n`th\nroots of unity and such that the group of `n`th roots of unity is cyclic.\n\nSuch monoids are suitable targets in the context of duality statements for groups\nof exponent `n`. -/\nclass HasEnoughRootsOfUnity (M : Type*) [CommMonoid M] (n : ℕ) where\n  prim : ∃ m : M, IsPrimitiveRoot m n\n  cyc : IsCyclic <| rootsOfUnity n M\n\n"}
{"name":"HasEnoughRootsOfUnity.exists_primitiveRoot","module":"Mathlib.RingTheory.RootsOfUnity.EnoughRootsOfUnity","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nn : Nat\ninst✝ : HasEnoughRootsOfUnity M n\n⊢ Exists fun ζ => IsPrimitiveRoot ζ n","decl":"lemma exists_primitiveRoot (M : Type*) [CommMonoid M] (n : ℕ) [HasEnoughRootsOfUnity M n] :\n    ∃ ζ : M, IsPrimitiveRoot ζ n :=\n  HasEnoughRootsOfUnity.prim\n\n"}
{"name":"HasEnoughRootsOfUnity.rootsOfUnity_isCyclic","module":"Mathlib.RingTheory.RootsOfUnity.EnoughRootsOfUnity","initialProofState":"M : Type u_1\ninst✝¹ : CommMonoid M\nn : Nat\ninst✝ : HasEnoughRootsOfUnity M n\n⊢ IsCyclic (Subtype fun x => Membership.mem (rootsOfUnity n M) x)","decl":"instance rootsOfUnity_isCyclic (M : Type*) [CommMonoid M] (n : ℕ) [HasEnoughRootsOfUnity M n] :\n    IsCyclic (rootsOfUnity n M) :=\n  HasEnoughRootsOfUnity.cyc\n\n"}
{"name":"HasEnoughRootsOfUnity.of_dvd","module":"Mathlib.RingTheory.RootsOfUnity.EnoughRootsOfUnity","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nm n : Nat\ninst✝¹ : NeZero n\nhmn : Dvd.dvd m n\ninst✝ : HasEnoughRootsOfUnity M n\n⊢ HasEnoughRootsOfUnity M m","decl":"/-- If `HasEnoughRootsOfUnity M n` and `m ∣ n`, then also `HasEnoughRootsOfUnity M m`. -/\nlemma of_dvd (M : Type*) [CommMonoid M] {m n : ℕ} [NeZero n] (hmn : m ∣ n)\n    [HasEnoughRootsOfUnity M n] :\n    HasEnoughRootsOfUnity M m where\n  prim :=\n    have ⟨ζ, hζ⟩ := exists_primitiveRoot M n\n    have ⟨k, hk⟩ := hmn\n    ⟨ζ ^ k, IsPrimitiveRoot.pow (NeZero.pos n) hζ (mul_comm m k ▸ hk)⟩\n  cyc := Subgroup.isCyclic_of_le <| rootsOfUnity_le_of_dvd hmn\n\n"}
{"name":"HasEnoughRootsOfUnity.finite_rootsOfUnity","module":"Mathlib.RingTheory.RootsOfUnity.EnoughRootsOfUnity","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nn : Nat\ninst✝¹ : NeZero n\ninst✝ : HasEnoughRootsOfUnity M n\n⊢ Finite (Subtype fun x => Membership.mem (rootsOfUnity n M) x)","decl":"/-- If `M` satisfies `HasEnoughRootsOfUnity`, then the group of `n`th roots of unity\nin `M` is finite. -/\ninstance finite_rootsOfUnity (M : Type*) [CommMonoid M] (n : ℕ) [NeZero n]\n    [HasEnoughRootsOfUnity M n] :\n    Finite <| rootsOfUnity n M := by\n  have := rootsOfUnity_isCyclic M n\n  obtain ⟨g, hg⟩ := IsCyclic.exists_generator (α := rootsOfUnity n M)\n  have hg' : g ^ n = 1 := OneMemClass.coe_eq_one.mp g.prop\n  let f (j : ZMod n) : rootsOfUnity n M := g ^ (j.val : ℤ)\n  refine Finite.of_surjective f fun x ↦ ?_\n  obtain ⟨k, hk⟩ := Subgroup.mem_zpowers_iff.mp <| hg x\n  refine ⟨k, ?_⟩\n  simpa only [ZMod.natCast_val, ← hk, f, ZMod.coe_intCast] using (zpow_eq_zpow_emod' k hg').symm\n\n"}
{"name":"HasEnoughRootsOfUnity.natCard_rootsOfUnity","module":"Mathlib.RingTheory.RootsOfUnity.EnoughRootsOfUnity","initialProofState":"M : Type u_1\ninst✝² : CommMonoid M\nn : Nat\ninst✝¹ : NeZero n\ninst✝ : HasEnoughRootsOfUnity M n\n⊢ Eq (Nat.card (Subtype fun x => Membership.mem (rootsOfUnity n M) x)) n","decl":"/-- If `M` satisfies `HasEnoughRootsOfUnity`, then the group of `n`th roots of unity\nin `M` (is cyclic and) has order `n`. -/\nlemma natCard_rootsOfUnity (M : Type*) [CommMonoid M] (n : ℕ) [NeZero n]\n    [HasEnoughRootsOfUnity M n] :\n    Nat.card (rootsOfUnity n M) = n := by\n  obtain ⟨ζ, h⟩ := exists_primitiveRoot M n\n  rw [← IsCyclic.exponent_eq_card]\n  refine dvd_antisymm ?_ ?_\n  · exact Monoid.exponent_dvd_of_forall_pow_eq_one fun g ↦ OneMemClass.coe_eq_one.mp g.prop\n  · nth_rewrite 1 [h.eq_orderOf]\n    rw [← (h.isUnit <| NeZero.pos n).unit_spec, orderOf_units]\n    let ζ' : rootsOfUnity n M := ⟨(h.isUnit <| NeZero.pos n).unit, ?_⟩\n    · rw [← Subgroup.orderOf_mk]\n      exact Monoid.order_dvd_exponent ζ'\n    simp only [mem_rootsOfUnity, PNat.mk_coe]\n    rw [← Units.eq_iff, Units.val_pow_eq_pow_val, IsUnit.unit_spec, h.pow_eq_one, Units.val_one]\n\n"}
{"name":"IsCyclic.monoidHom_equiv_self","module":"Mathlib.RingTheory.RootsOfUnity.EnoughRootsOfUnity","initialProofState":"G : Type u_1\nM : Type u_2\ninst✝⁴ : CommGroup G\ninst✝³ : Finite G\ninst✝² : IsCyclic G\ninst✝¹ : CommMonoid M\ninst✝ : HasEnoughRootsOfUnity M (Nat.card G)\n⊢ Nonempty (MulEquiv (MonoidHom G (Units M)) G)","decl":"/-- The group of group homomorphims from a finite cyclic group `G` of order `n` into the\ngroup of units of a ring `M` with all roots of unity is isomorphic to `G` -/\nlemma IsCyclic.monoidHom_equiv_self (G M : Type*) [CommGroup G] [Finite G]\n    [IsCyclic G] [CommMonoid M] [HasEnoughRootsOfUnity M (Nat.card G)] :\n    Nonempty ((G →* Mˣ) ≃* G) := by\n  have : NeZero (Nat.card G) := ⟨Nat.card_pos.ne'⟩\n  have hord := HasEnoughRootsOfUnity.natCard_rootsOfUnity M (Nat.card G)\n  let e := (IsCyclic.monoidHom_mulEquiv_rootsOfUnity G Mˣ).some\n  exact ⟨e.trans (rootsOfUnityUnitsMulEquiv M (Nat.card G)) |>.trans (mulEquivOfCyclicCardEq hord)⟩\n\n"}
