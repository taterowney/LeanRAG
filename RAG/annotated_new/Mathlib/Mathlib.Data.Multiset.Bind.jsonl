{"name":"Multiset.coe_join","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nL : List (List α)\n⊢ Eq (↑(List.map Multiset.ofList L)).join ↑L.flatten","decl":"theorem coe_join : ∀ L : List (List α), join (L.map ((↑) : List α → Multiset α) :\n    Multiset (Multiset α)) = L.flatten\n  | [] => rfl\n  | l :: L => by\n      exact congr_arg (fun s : Multiset α => ↑l + s) (coe_join L)\n\n"}
{"name":"Multiset.join_zero","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\n⊢ Eq (Multiset.join 0) 0","decl":"@[simp]\ntheorem join_zero : @join α 0 = 0 :=\n  rfl\n\n"}
{"name":"Multiset.join_cons","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\ns : Multiset α\nS : Multiset (Multiset α)\n⊢ Eq (Multiset.cons s S).join (HAdd.hAdd s S.join)","decl":"@[simp]\ntheorem join_cons (s S) : @join α (s ::ₘ S) = s + join S :=\n  sum_cons _ _\n\n"}
{"name":"Multiset.join_add","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nS T : Multiset (Multiset α)\n⊢ Eq (HAdd.hAdd S T).join (HAdd.hAdd S.join T.join)","decl":"@[simp]\ntheorem join_add (S T) : @join α (S + T) = join S + join T :=\n  sum_add _ _\n\n"}
{"name":"Multiset.singleton_join","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\na : Multiset α\n⊢ Eq (Singleton.singleton a).join a","decl":"@[simp]\ntheorem singleton_join (a) : join ({a} : Multiset (Multiset α)) = a :=\n  sum_singleton _\n\n"}
{"name":"Multiset.mem_join","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\na : α\nS : Multiset (Multiset α)\n⊢ Iff (Membership.mem S.join a) (Exists fun s => And (Membership.mem S s) (Membership.mem s a))","decl":"@[simp]\ntheorem mem_join {a S} : a ∈ @join α S ↔ ∃ s ∈ S, a ∈ s :=\n  Multiset.induction_on S (by simp) <| by\n    simp +contextual [or_and_right, exists_or]\n\n"}
{"name":"Multiset.card_join","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nS : Multiset (Multiset α)\n⊢ Eq S.join.card (Multiset.map Multiset.card S).sum","decl":"@[simp]\ntheorem card_join (S) : card (@join α S) = sum (map card S) :=\n  Multiset.induction_on S (by simp) (by simp)\n\n"}
{"name":"Multiset.map_join","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\nf : α → β\nS : Multiset (Multiset α)\n⊢ Eq (Multiset.map f S.join) (Multiset.map (Multiset.map f) S).join","decl":"@[simp]\ntheorem map_join (f : α → β) (S : Multiset (Multiset α)) :\n    map f (join S) = join (map (map f) S) := by\n  induction S using Multiset.induction with\n  | empty => simp\n  | cons _ _ ih => simp [ih]\n\n"}
{"name":"Multiset.sum_join","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\ninst✝ : AddCommMonoid α\nS : Multiset (Multiset α)\n⊢ Eq S.join.sum (Multiset.map Multiset.sum S).sum","decl":"@[to_additive (attr := simp)]\ntheorem prod_join [CommMonoid α] {S : Multiset (Multiset α)} :\n    prod (join S) = prod (map prod S) := by\n  induction S using Multiset.induction with\n  | empty => simp\n  | cons _ _ ih => simp [ih]\n\n"}
{"name":"Multiset.prod_join","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\nS : Multiset (Multiset α)\n⊢ Eq S.join.prod (Multiset.map Multiset.prod S).prod","decl":"@[to_additive (attr := simp)]\ntheorem prod_join [CommMonoid α] {S : Multiset (Multiset α)} :\n    prod (join S) = prod (map prod S) := by\n  induction S using Multiset.induction with\n  | empty => simp\n  | cons _ _ ih => simp [ih]\n\n"}
{"name":"Multiset.rel_join","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\nr : α → β → Prop\ns : Multiset (Multiset α)\nt : Multiset (Multiset β)\nh : Multiset.Rel (Multiset.Rel r) s t\n⊢ Multiset.Rel r s.join t.join","decl":"theorem rel_join {r : α → β → Prop} {s t} (h : Rel (Rel r) s t) : Rel r s.join t.join := by\n  induction h with\n  | zero => simp\n  | cons hab hst ih => simpa using hab.add ih\n\n"}
{"name":"Multiset.coe_bind","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\nl : List α\nf : α → List β\n⊢ Eq ((↑l).bind fun a => ↑(f a)) ↑(l.flatMap f)","decl":"@[simp]\ntheorem coe_bind (l : List α) (f : α → List β) : (@bind α β l fun a => f a) = l.flatMap f := by\n  rw [List.flatMap, ← coe_join, List.map_map]\n  rfl\n\n"}
{"name":"Multiset.zero_bind","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\nf : α → Multiset β\n⊢ Eq (Multiset.bind 0 f) 0","decl":"@[simp]\ntheorem zero_bind : bind 0 f = 0 :=\n  rfl\n\n"}
{"name":"Multiset.cons_bind","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\na : α\ns : Multiset α\nf : α → Multiset β\n⊢ Eq ((Multiset.cons a s).bind f) (HAdd.hAdd (f a) (s.bind f))","decl":"@[simp]\ntheorem cons_bind : (a ::ₘ s).bind f = f a + s.bind f := by simp [bind]\n\n"}
{"name":"Multiset.singleton_bind","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\na : α\nf : α → Multiset β\n⊢ Eq ((Singleton.singleton a).bind f) (f a)","decl":"@[simp]\ntheorem singleton_bind : bind {a} f = f a := by simp [bind]\n\n"}
{"name":"Multiset.add_bind","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\ns t : Multiset α\nf : α → Multiset β\n⊢ Eq ((HAdd.hAdd s t).bind f) (HAdd.hAdd (s.bind f) (t.bind f))","decl":"@[simp]\ntheorem add_bind : (s + t).bind f = s.bind f + t.bind f := by simp [bind]\n\n"}
{"name":"Multiset.bind_zero","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\ns : Multiset α\n⊢ Eq (s.bind fun x => 0) 0","decl":"@[simp]\ntheorem bind_zero : s.bind (fun _ => 0 : α → Multiset β) = 0 := by simp [bind, join, nsmul_zero]\n\n"}
{"name":"Multiset.bind_add","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\ns : Multiset α\nf g : α → Multiset β\n⊢ Eq (s.bind fun a => HAdd.hAdd (f a) (g a)) (HAdd.hAdd (s.bind f) (s.bind g))","decl":"@[simp]\ntheorem bind_add : (s.bind fun a => f a + g a) = s.bind f + s.bind g := by simp [bind, join]\n\n"}
{"name":"Multiset.bind_cons","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\ns : Multiset α\nf : α → β\ng : α → Multiset β\n⊢ Eq (s.bind fun a => Multiset.cons (f a) (g a)) (HAdd.hAdd (Multiset.map f s) (s.bind g))","decl":"@[simp]\ntheorem bind_cons (f : α → β) (g : α → Multiset β) :\n    (s.bind fun a => f a ::ₘ g a) = map f s + s.bind g :=\n  Multiset.induction_on s (by simp)\n    (by simp +contextual [add_comm, add_left_comm, add_assoc])\n\n"}
{"name":"Multiset.bind_singleton","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\ns : Multiset α\nf : α → β\n⊢ Eq (s.bind fun x => Singleton.singleton (f x)) (Multiset.map f s)","decl":"@[simp]\ntheorem bind_singleton (f : α → β) : (s.bind fun x => ({f x} : Multiset β)) = map f s :=\n  Multiset.induction_on s (by rw [zero_bind, map_zero]) (by simp [singleton_add])\n\n"}
{"name":"Multiset.mem_bind","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\nb : β\ns : Multiset α\nf : α → Multiset β\n⊢ Iff (Membership.mem (s.bind f) b) (Exists fun a => And (Membership.mem s a) (Membership.mem (f a) b))","decl":"@[simp]\ntheorem mem_bind {b s} {f : α → Multiset β} : b ∈ bind s f ↔ ∃ a ∈ s, b ∈ f a := by\n  simp [bind]\n\n"}
{"name":"Multiset.card_bind","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\ns : Multiset α\nf : α → Multiset β\n⊢ Eq (s.bind f).card (Multiset.map (Function.comp Multiset.card f) s).sum","decl":"@[simp]\ntheorem card_bind : card (s.bind f) = (s.map (card ∘ f)).sum := by simp [bind]\n\n"}
{"name":"Multiset.bind_congr","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\nf g : α → Multiset β\nm : Multiset α\na✝ : ∀ (a : α), Membership.mem m a → Eq (f a) (g a)\n⊢ Eq (m.bind f) (m.bind g)","decl":"theorem bind_congr {f g : α → Multiset β} {m : Multiset α} :\n    (∀ a ∈ m, f a = g a) → bind m f = bind m g := by simp +contextual [bind]\n\n"}
{"name":"Multiset.bind_hcongr","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ β' : Type v\nm : Multiset α\nf : α → Multiset β\nf' : α → Multiset β'\nh : Eq β β'\nhf : ∀ (a : α), Membership.mem m a → HEq (f a) (f' a)\n⊢ HEq (m.bind f) (m.bind f')","decl":"theorem bind_hcongr {β' : Type v} {m : Multiset α} {f : α → Multiset β} {f' : α → Multiset β'}\n    (h : β = β') (hf : ∀ a ∈ m, HEq (f a) (f' a)) : HEq (bind m f) (bind m f') := by\n  subst h\n  simp only [heq_eq_eq] at hf\n  simp [bind_congr hf]\n\n"}
{"name":"Multiset.map_bind","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\nγ : Type u_2\nm : Multiset α\nn : α → Multiset β\nf : β → γ\n⊢ Eq (Multiset.map f (m.bind n)) (m.bind fun a => Multiset.map f (n a))","decl":"theorem map_bind (m : Multiset α) (n : α → Multiset β) (f : β → γ) :\n    map f (bind m n) = bind m fun a => map f (n a) := by simp [bind]\n\n"}
{"name":"Multiset.bind_map","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\nγ : Type u_2\nm : Multiset α\nn : β → Multiset γ\nf : α → β\n⊢ Eq ((Multiset.map f m).bind n) (m.bind fun a => n (f a))","decl":"theorem bind_map (m : Multiset α) (n : β → Multiset γ) (f : α → β) :\n    bind (map f m) n = bind m fun a => n (f a) :=\n  Multiset.induction_on m (by simp) (by simp +contextual)\n\n"}
{"name":"Multiset.bind_assoc","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\nγ : Type u_2\ns : Multiset α\nf : α → Multiset β\ng : β → Multiset γ\n⊢ Eq ((s.bind f).bind g) (s.bind fun a => (f a).bind g)","decl":"theorem bind_assoc {s : Multiset α} {f : α → Multiset β} {g : β → Multiset γ} :\n    (s.bind f).bind g = s.bind fun a => (f a).bind g :=\n  Multiset.induction_on s (by simp) (by simp +contextual)\n\n"}
{"name":"Multiset.bind_bind","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\nγ : Type u_2\nm : Multiset α\nn : Multiset β\nf : α → β → Multiset γ\n⊢ Eq (m.bind fun a => n.bind fun b => f a b) (n.bind fun b => m.bind fun a => f a b)","decl":"theorem bind_bind (m : Multiset α) (n : Multiset β) {f : α → β → Multiset γ} :\n    ((bind m) fun a => (bind n) fun b => f a b) = (bind n) fun b => (bind m) fun a => f a b :=\n  Multiset.induction_on m (by simp) (by simp +contextual)\n\n"}
{"name":"Multiset.bind_map_comm","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\nγ : Type u_2\nm : Multiset α\nn : Multiset β\nf : α → β → γ\n⊢ Eq (m.bind fun a => Multiset.map (fun b => f a b) n) (n.bind fun b => Multiset.map (fun a => f a b) m)","decl":"theorem bind_map_comm (m : Multiset α) (n : Multiset β) {f : α → β → γ} :\n    ((bind m) fun a => n.map fun b => f a b) = (bind n) fun b => m.map fun a => f a b :=\n  Multiset.induction_on m (by simp) (by simp +contextual)\n\n"}
{"name":"Multiset.sum_bind","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\ninst✝ : AddCommMonoid β\ns : Multiset α\nt : α → Multiset β\n⊢ Eq (s.bind t).sum (Multiset.map (fun a => (t a).sum) s).sum","decl":"@[to_additive (attr := simp)]\ntheorem prod_bind [CommMonoid β] (s : Multiset α) (t : α → Multiset β) :\n    (s.bind t).prod = (s.map fun a => (t a).prod).prod := by simp [bind]\n\n"}
{"name":"Multiset.prod_bind","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\ninst✝ : CommMonoid β\ns : Multiset α\nt : α → Multiset β\n⊢ Eq (s.bind t).prod (Multiset.map (fun a => (t a).prod) s).prod","decl":"@[to_additive (attr := simp)]\ntheorem prod_bind [CommMonoid β] (s : Multiset α) (t : α → Multiset β) :\n    (s.bind t).prod = (s.map fun a => (t a).prod).prod := by simp [bind]\n\n"}
{"name":"Multiset.rel_bind","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\nγ : Type u_2\nδ : Type u_3\nr : α → β → Prop\np : γ → δ → Prop\ns : Multiset α\nt : Multiset β\nf : α → Multiset γ\ng : β → Multiset δ\nh : Relator.LiftFun r (Multiset.Rel p) f g\nhst : Multiset.Rel r s t\n⊢ Multiset.Rel p (s.bind f) (t.bind g)","decl":"theorem rel_bind {r : α → β → Prop} {p : γ → δ → Prop} {s t} {f : α → Multiset γ}\n    {g : β → Multiset δ} (h : (r ⇒ Rel p) f g) (hst : Rel r s t) :\n    Rel p (s.bind f) (t.bind g) := by\n  apply rel_join\n  rw [rel_map]\n  exact hst.mono fun a _ b _ hr => h hr\n\n"}
{"name":"Multiset.count_sum","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\ninst✝ : DecidableEq α\nm : Multiset β\nf : β → Multiset α\na : α\n⊢ Eq (Multiset.count a (Multiset.map f m).sum) (Multiset.map (fun b => Multiset.count a (f b)) m).sum","decl":"theorem count_sum [DecidableEq α] {m : Multiset β} {f : β → Multiset α} {a : α} :\n    count a (map f m).sum = sum (m.map fun b => count a <| f b) :=\n  Multiset.induction_on m (by simp) (by simp)\n\n"}
{"name":"Multiset.count_bind","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\ninst✝ : DecidableEq α\nm : Multiset β\nf : β → Multiset α\na : α\n⊢ Eq (Multiset.count a (m.bind f)) (Multiset.map (fun b => Multiset.count a (f b)) m).sum","decl":"theorem count_bind [DecidableEq α] {m : Multiset β} {f : β → Multiset α} {a : α} :\n    count a (bind m f) = sum (m.map fun b => count a <| f b) :=\n  count_sum\n\n"}
{"name":"Multiset.le_bind","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_4\nβ : Type u_5\nf : α → Multiset β\nS : Multiset α\nx : α\nhx : Membership.mem S x\n⊢ LE.le (f x) (S.bind f)","decl":"theorem le_bind {α β : Type*} {f : α → Multiset β} (S : Multiset α) {x : α} (hx : x ∈ S) :\n    f x ≤ S.bind f := by\n  classical\n  refine le_iff_count.2 fun a ↦ ?_\n  obtain ⟨m', hm'⟩ := exists_cons_of_mem <| mem_map_of_mem (fun b ↦ count a (f b)) hx\n  rw [count_bind, hm', sum_cons]\n  exact Nat.le_add_right _ _\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): @[simp] removed because not in normal form\n"}
{"name":"Multiset.attach_bind_coe","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\ns : Multiset α\nf : α → Multiset β\n⊢ Eq (s.attach.bind fun i => f ↑i) (s.bind f)","decl":"theorem attach_bind_coe (s : Multiset α) (f : α → Multiset β) :\n    (s.attach.bind fun i => f i) = s.bind f :=\n  congr_arg join <| attach_map_val' _ _\n\n"}
{"name":"Multiset.nodup_bind","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\ns : Multiset α\nf : α → Multiset β\n⊢ Iff (s.bind f).Nodup (And (∀ (a : α), Membership.mem s a → (f a).Nodup) (Multiset.Pairwise (Function.onFun Disjoint f) s))","decl":"open scoped Function in -- required for scoped `on` notation\n@[simp] lemma nodup_bind :\n    Nodup (bind s f) ↔ (∀ a ∈ s, Nodup (f a)) ∧ s.Pairwise (Disjoint on f) := by\n  have : ∀ a, ∃ l : List β, f a = l := fun a => Quot.induction_on (f a) fun l => ⟨l, rfl⟩\n  choose f' h' using this\n  have : f = fun a ↦ ofList (f' a) := funext h'\n  have hd : Symmetric fun a b ↦ List.Disjoint (f' a) (f' b) := fun a b h ↦ h.symm\n  exact Quot.induction_on s <| by\n    unfold Function.onFun\n    simp [this, List.nodup_flatMap, pairwise_coe_iff_pairwise hd]\n\n"}
{"name":"Multiset.dedup_bind_dedup","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\ns : Multiset α\nf : α → Multiset β\n⊢ Eq (s.dedup.bind f).dedup (s.bind f).dedup","decl":"@[simp]\nlemma dedup_bind_dedup [DecidableEq α] [DecidableEq β] (s : Multiset α) (f : α → Multiset β) :\n    (s.dedup.bind f).dedup = (s.bind f).dedup := by\n  ext x\n  -- Porting note: was `simp_rw [count_dedup, mem_bind, mem_dedup]`\n  simp_rw [count_dedup]\n  refine if_congr ?_ rfl rfl\n  simp\n\n"}
{"name":"Multiset.coe_product","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\nl₁ : List α\nl₂ : List β\n⊢ Eq (SProd.sprod ↑l₁ ↑l₂) ↑(SProd.sprod l₁ l₂)","decl":"@[simp]\ntheorem coe_product (l₁ : List α) (l₂ : List β) :\n    (l₁ : Multiset α) ×ˢ (l₂ : Multiset β) = (l₁ ×ˢ l₂) := by\n  dsimp only [SProd.sprod]\n  rw [product, List.product, ← coe_bind]\n  simp\n\n"}
{"name":"Multiset.zero_product","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\nt : Multiset β\n⊢ Eq (SProd.sprod 0 t) 0","decl":"@[simp]\ntheorem zero_product : (0 : Multiset α) ×ˢ t = 0 :=\n  rfl\n\n"}
{"name":"Multiset.cons_product","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\na : α\ns : Multiset α\nt : Multiset β\n⊢ Eq (SProd.sprod (Multiset.cons a s) t) (HAdd.hAdd (Multiset.map (Prod.mk a) t) (SProd.sprod s t))","decl":"@[simp]\ntheorem cons_product : (a ::ₘ s) ×ˢ t = map (Prod.mk a) t + s ×ˢ t := by simp [SProd.sprod, product]\n\n"}
{"name":"Multiset.product_zero","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\ns : Multiset α\n⊢ Eq (SProd.sprod s 0) 0","decl":"@[simp]\ntheorem product_zero : s ×ˢ (0 : Multiset β) = 0 := by simp [SProd.sprod, product]\n\n"}
{"name":"Multiset.product_cons","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\nb : β\ns : Multiset α\nt : Multiset β\n⊢ Eq (SProd.sprod s (Multiset.cons b t)) (HAdd.hAdd (Multiset.map (fun a => { fst := a, snd := b }) s) (SProd.sprod s t))","decl":"@[simp]\ntheorem product_cons : s ×ˢ (b ::ₘ t) = (s.map fun a => (a, b)) + s ×ˢ t := by\n  simp [SProd.sprod, product]\n\n"}
{"name":"Multiset.product_singleton","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\na : α\nb : β\n⊢ Eq (SProd.sprod (Singleton.singleton a) (Singleton.singleton b)) (Singleton.singleton { fst := a, snd := b })","decl":"@[simp]\ntheorem product_singleton : ({a} : Multiset α) ×ˢ ({b} : Multiset β) = {(a, b)} := by\n  simp only [SProd.sprod, product, bind_singleton, map_singleton]\n\n"}
{"name":"Multiset.add_product","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\ns t : Multiset α\nu : Multiset β\n⊢ Eq (SProd.sprod (HAdd.hAdd s t) u) (HAdd.hAdd (SProd.sprod s u) (SProd.sprod t u))","decl":"@[simp]\ntheorem add_product (s t : Multiset α) (u : Multiset β) : (s + t) ×ˢ u = s ×ˢ u + t ×ˢ u := by\n  simp [SProd.sprod, product]\n\n"}
{"name":"Multiset.product_add","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\ns : Multiset α\nt u : Multiset β\n⊢ Eq (SProd.sprod s (HAdd.hAdd t u)) (HAdd.hAdd (SProd.sprod s t) (SProd.sprod s u))","decl":"@[simp]\ntheorem product_add (s : Multiset α) : ∀ t u : Multiset β, s ×ˢ (t + u) = s ×ˢ t + s ×ˢ u :=\n  Multiset.induction_on s (fun _ _ => rfl) fun a s IH t u => by\n    rw [cons_product, IH]\n    simp [add_comm, add_left_comm, add_assoc]\n\n"}
{"name":"Multiset.card_product","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\ns : Multiset α\nt : Multiset β\n⊢ Eq (SProd.sprod s t).card (HMul.hMul s.card t.card)","decl":"@[simp]\ntheorem card_product : card (s ×ˢ t) = card s * card t := by simp [SProd.sprod, product]\n\n"}
{"name":"Multiset.mem_product","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\ns : Multiset α\nt : Multiset β\np : Prod α β\n⊢ Iff (Membership.mem (s.product t) p) (And (Membership.mem s p.1) (Membership.mem t p.2))","decl":"@[simp] lemma mem_product : ∀ {p : α × β}, p ∈ @product α β s t ↔ p.1 ∈ s ∧ p.2 ∈ t\n  | (a, b) => by simp [product, and_left_comm]\n\n"}
{"name":"Multiset.Nodup.product","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\ns : Multiset α\nt : Multiset β\na✝¹ : s.Nodup\na✝ : t.Nodup\n⊢ (SProd.sprod s t).Nodup","decl":"protected theorem Nodup.product : Nodup s → Nodup t → Nodup (s ×ˢ t) :=\n  Quotient.inductionOn₂ s t fun l₁ l₂ d₁ d₂ => by simp [List.Nodup.product d₁ d₂]\n\n"}
{"name":"Multiset.coe_sigma","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nσ : α → Type u_4\nl₁ : List α\nl₂ : (a : α) → List (σ a)\n⊢ Eq ((↑l₁).sigma fun a => ↑(l₂ a)) ↑(l₁.sigma l₂)","decl":"@[simp]\ntheorem coe_sigma (l₁ : List α) (l₂ : ∀ a, List (σ a)) :\n    (@Multiset.sigma α σ l₁ fun a => l₂ a) = l₁.sigma l₂ := by\n  rw [Multiset.sigma, List.sigma, ← coe_bind]\n  simp\n\n"}
{"name":"Multiset.zero_sigma","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nσ : α → Type u_4\nt : (a : α) → Multiset (σ a)\n⊢ Eq (Multiset.sigma 0 t) 0","decl":"@[simp]\ntheorem zero_sigma : @Multiset.sigma α σ 0 t = 0 :=\n  rfl\n\n"}
{"name":"Multiset.cons_sigma","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nσ : α → Type u_4\na : α\ns : Multiset α\nt : (a : α) → Multiset (σ a)\n⊢ Eq ((Multiset.cons a s).sigma t) (HAdd.hAdd (Multiset.map (Sigma.mk a) (t a)) (s.sigma t))","decl":"@[simp]\ntheorem cons_sigma : (a ::ₘ s).sigma t = (t a).map (Sigma.mk a) + s.sigma t := by\n  simp [Multiset.sigma]\n\n"}
{"name":"Multiset.sigma_singleton","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nβ : Type v\na : α\nb : α → β\n⊢ Eq ((Singleton.singleton a).sigma fun a => Singleton.singleton (b a)) (Singleton.singleton ⟨a, b a⟩)","decl":"@[simp]\ntheorem sigma_singleton (b : α → β) :\n    (({a} : Multiset α).sigma fun a => ({b a} : Multiset β)) = {⟨a, b a⟩} :=\n  rfl\n\n"}
{"name":"Multiset.add_sigma","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nσ : α → Type u_4\ns t : Multiset α\nu : (a : α) → Multiset (σ a)\n⊢ Eq ((HAdd.hAdd s t).sigma u) (HAdd.hAdd (s.sigma u) (t.sigma u))","decl":"@[simp]\ntheorem add_sigma (s t : Multiset α) (u : ∀ a, Multiset (σ a)) :\n    (s + t).sigma u = s.sigma u + t.sigma u := by simp [Multiset.sigma]\n\n"}
{"name":"Multiset.sigma_add","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nσ : α → Type u_4\ns : Multiset α\nt u : (a : α) → Multiset (σ a)\n⊢ Eq (s.sigma fun a => HAdd.hAdd (t a) (u a)) (HAdd.hAdd (s.sigma t) (s.sigma u))","decl":"@[simp]\ntheorem sigma_add :\n    ∀ t u : ∀ a, Multiset (σ a), (s.sigma fun a => t a + u a) = s.sigma t + s.sigma u :=\n  Multiset.induction_on s (fun _ _ => rfl) fun a s IH t u => by\n    rw [cons_sigma, IH]\n    simp [add_comm, add_left_comm, add_assoc]\n\n"}
{"name":"Multiset.card_sigma","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nσ : α → Type u_4\ns : Multiset α\nt : (a : α) → Multiset (σ a)\n⊢ Eq (s.sigma t).card (Multiset.map (fun a => (t a).card) s).sum","decl":"@[simp]\ntheorem card_sigma : card (s.sigma t) = sum (map (fun a => card (t a)) s) := by\n  simp [Multiset.sigma, (· ∘ ·)]\n\n"}
{"name":"Multiset.mem_sigma","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\nσ : α → Type u_4\ns : Multiset α\nt : (a : α) → Multiset (σ a)\np : Sigma fun a => σ a\n⊢ Iff (Membership.mem (s.sigma t) p) (And (Membership.mem s p.fst) (Membership.mem (t p.fst) p.snd))","decl":"@[simp] lemma mem_sigma : ∀ {p : Σa, σ a}, p ∈ @Multiset.sigma α σ s t ↔ p.1 ∈ s ∧ p.2 ∈ t p.1\n  | ⟨a, b⟩ => by simp [Multiset.sigma, and_assoc, and_left_comm]\n\n"}
{"name":"Multiset.Nodup.sigma","module":"Mathlib.Data.Multiset.Bind","initialProofState":"α : Type u_1\ns : Multiset α\nσ : α → Type u_5\nt : (a : α) → Multiset (σ a)\na✝¹ : s.Nodup\na✝ : ∀ (a : α), (t a).Nodup\n⊢ (s.sigma t).Nodup","decl":"protected theorem Nodup.sigma {σ : α → Type*} {t : ∀ a, Multiset (σ a)} :\n    Nodup s → (∀ a, Nodup (t a)) → Nodup (s.sigma t) :=\n  Quot.induction_on s fun l₁ => by\n    choose f hf using fun a => Quotient.exists_rep (t a)\n    simpa [← funext hf] using List.Nodup.sigma\n\n"}
