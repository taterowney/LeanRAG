{"name":"Real.Gamma_integrand_isLittleO","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Real\n‚ä¢ Asymptotics.IsLittleO Filter.atTop (fun x => HMul.hMul (Real.exp (Neg.neg x)) (HPow.hPow x s)) fun x => Real.exp (HMul.hMul (Neg.neg (1 / 2)) x)","decl":"/-- Asymptotic bound for the `Œì` function integrand. -/\ntheorem Gamma_integrand_isLittleO (s : ‚Ñù) :\n    (fun x : ‚Ñù => exp (-x) * x ^ s) =o[atTop] fun x : ‚Ñù => exp (-(1 / 2) * x) := by\n  refine isLittleO_of_tendsto (fun x hx => ?_) ?_\n  ¬∑ exfalso; exact (exp_pos (-(1 / 2) * x)).ne' hx\n  have : (fun x : ‚Ñù => exp (-x) * x ^ s / exp (-(1 / 2) * x)) =\n      (fun x : ‚Ñù => exp (1 / 2 * x) / x ^ s)‚Åª¬π := by\n    ext1 x\n    field_simp [exp_ne_zero, exp_neg, ‚Üê Real.exp_add]\n    left\n    ring\n  rw [this]\n  exact (tendsto_exp_mul_div_rpow_atTop s (1 / 2) one_half_pos).inv_tendsto_atTop\n\n"}
{"name":"Real.GammaIntegral_convergent","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Real\nh : LT.lt 0 s\n‚ä¢ MeasureTheory.IntegrableOn (fun x => HMul.hMul (Real.exp (Neg.neg x)) (HPow.hPow x (HSub.hSub s 1))) (Set.Ioi 0) MeasureTheory.MeasureSpace.volume","decl":"/-- The Euler integral for the `Œì` function converges for positive real `s`. -/\ntheorem GammaIntegral_convergent {s : ‚Ñù} (h : 0 < s) :\n    IntegrableOn (fun x : ‚Ñù => exp (-x) * x ^ (s - 1)) (Ioi 0) := by\n  rw [‚Üê Ioc_union_Ioi_eq_Ioi (@zero_le_one ‚Ñù _ _ _ _), integrableOn_union]\n  constructor\n  ¬∑ rw [‚Üê integrableOn_Icc_iff_integrableOn_Ioc]\n    refine IntegrableOn.continuousOn_mul continuousOn_id.neg.rexp ?_ isCompact_Icc\n    refine (intervalIntegrable_iff_integrableOn_Icc_of_le zero_le_one).mp ?_\n    exact intervalIntegrable_rpow' (by linarith)\n  ¬∑ refine integrable_of_isBigO_exp_neg one_half_pos ?_ (Gamma_integrand_isLittleO _).isBigO\n    refine continuousOn_id.neg.rexp.mul (continuousOn_id.rpow_const ?_)\n    intro x hx\n    exact Or.inl ((zero_lt_one : (0 : ‚Ñù) < 1).trans_le hx).ne'\n\n"}
{"name":"Complex.GammaIntegral_convergent","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Complex\nhs : LT.lt 0 s.re\n‚ä¢ MeasureTheory.IntegrableOn (fun x => HMul.hMul (‚Üë(Real.exp (Neg.neg x))) (HPow.hPow (‚Üëx) (HSub.hSub s 1))) (Set.Ioi 0) MeasureTheory.MeasureSpace.volume","decl":"/-- The integral defining the `Œì` function converges for complex `s` with `0 < re s`.\n\nThis is proved by reduction to the real case. -/\ntheorem GammaIntegral_convergent {s : ‚ÑÇ} (hs : 0 < s.re) :\n    IntegrableOn (fun x => (-x).exp * x ^ (s - 1) : ‚Ñù ‚Üí ‚ÑÇ) (Ioi 0) := by\n  constructor\n  ¬∑ refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_Ioi\n    apply (continuous_ofReal.comp continuous_neg.rexp).continuousOn.mul\n    apply continuousOn_of_forall_continuousAt\n    intro x hx\n    have : ContinuousAt (fun x : ‚ÑÇ => x ^ (s - 1)) ‚Üëx :=\n      continuousAt_cpow_const <| ofReal_mem_slitPlane.2 hx\n    exact ContinuousAt.comp this continuous_ofReal.continuousAt\n  ¬∑ rw [‚Üê hasFiniteIntegral_norm_iff]\n    refine HasFiniteIntegral.congr (Real.GammaIntegral_convergent hs).2 ?_\n    apply (ae_restrict_iff' measurableSet_Ioi).mpr\n    filter_upwards with x hx\n    rw [norm_eq_abs, map_mul, abs_of_nonneg <| le_of_lt <| exp_pos <| -x,\n      abs_cpow_eq_rpow_re_of_pos hx _]\n    simp\n\n"}
{"name":"Complex.GammaIntegral_conj","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Complex\n‚ä¢ Eq ((starRingEnd Complex) s).GammaIntegral ((starRingEnd Complex) s.GammaIntegral)","decl":"theorem GammaIntegral_conj (s : ‚ÑÇ) : GammaIntegral (conj s) = conj (GammaIntegral s) := by\n  rw [GammaIntegral, GammaIntegral, ‚Üê integral_conj]\n  refine setIntegral_congr_fun measurableSet_Ioi fun x hx => ?_\n  dsimp only\n  rw [RingHom.map_mul, conj_ofReal, cpow_def_of_ne_zero (ofReal_ne_zero.mpr (ne_of_gt hx)),\n    cpow_def_of_ne_zero (ofReal_ne_zero.mpr (ne_of_gt hx)), ‚Üê exp_conj, RingHom.map_mul, ‚Üê\n    ofReal_log (le_of_lt hx), conj_ofReal, RingHom.map_sub, RingHom.map_one]\n\n"}
{"name":"Complex.GammaIntegral_ofReal","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Real\n‚ä¢ Eq (‚Üës).GammaIntegral ‚Üë(MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun x => HMul.hMul (Real.exp (Neg.neg x)) (HPow.hPow x (HSub.hSub s 1)))","decl":"theorem GammaIntegral_ofReal (s : ‚Ñù) :\n    GammaIntegral ‚Üës = ‚Üë(‚à´ x : ‚Ñù in Ioi 0, Real.exp (-x) * x ^ (s - 1)) := by\n  have : ‚àÄ r : ‚Ñù, Complex.ofReal r = @RCLike.ofReal ‚ÑÇ _ r := fun r => rfl\n  rw [GammaIntegral]\n  conv_rhs => rw [this, ‚Üê _root_.integral_ofReal]\n  refine setIntegral_congr_fun measurableSet_Ioi ?_\n  intro x hx; dsimp only\n  conv_rhs => rw [‚Üê this]\n  rw [ofReal_mul, ofReal_cpow (mem_Ioi.mp hx).le]\n  simp\n\n"}
{"name":"Complex.GammaIntegral_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"‚ä¢ Eq (Complex.GammaIntegral 1) 1","decl":"@[simp]\ntheorem GammaIntegral_one : GammaIntegral 1 = 1 := by\n  simpa only [‚Üê ofReal_one, GammaIntegral_ofReal, ofReal_inj, sub_self, rpow_zero,\n    mul_one] using integral_exp_neg_Ioi_zero\n\n"}
{"name":"Complex.tendsto_partialGamma","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Complex\nhs : LT.lt 0 s.re\n‚ä¢ Filter.Tendsto (fun X => s.partialGamma X) Filter.atTop (nhds s.GammaIntegral)","decl":"theorem tendsto_partialGamma {s : ‚ÑÇ} (hs : 0 < s.re) :\n    Tendsto (fun X : ‚Ñù => partialGamma s X) atTop (ùìù <| GammaIntegral s) :=\n  intervalIntegral_tendsto_integral_Ioi 0 (GammaIntegral_convergent hs) tendsto_id\n\n"}
{"name":"Complex.partialGamma_add_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Complex\nhs : LT.lt 0 s.re\nX : Real\nhX : LE.le 0 X\n‚ä¢ Eq ((HAdd.hAdd s 1).partialGamma X) (HSub.hSub (HMul.hMul s (s.partialGamma X)) (HMul.hMul (‚Üë(Real.exp (Neg.neg X))) (HPow.hPow (‚ÜëX) s)))","decl":"/-- The recurrence relation for the indefinite version of the `Œì` function. -/\ntheorem partialGamma_add_one {s : ‚ÑÇ} (hs : 0 < s.re) {X : ‚Ñù} (hX : 0 ‚â§ X) :\n    partialGamma (s + 1) X = s * partialGamma s X - (-X).exp * X ^ s := by\n  rw [partialGamma, partialGamma, add_sub_cancel_right]\n  have F_der_I : ‚àÄ x : ‚Ñù, x ‚àà Ioo 0 X ‚Üí HasDerivAt (fun x => (-x).exp * x ^ s : ‚Ñù ‚Üí ‚ÑÇ)\n      (-((-x).exp * x ^ s) + (-x).exp * (s * x ^ (s - 1))) x := by\n    intro x hx\n    have d1 : HasDerivAt (fun y : ‚Ñù => (-y).exp) (-(-x).exp) x := by\n      simpa using (hasDerivAt_neg x).exp\n    have d2 : HasDerivAt (fun y : ‚Ñù => (y : ‚ÑÇ) ^ s) (s * x ^ (s - 1)) x := by\n      have t := @HasDerivAt.cpow_const _ _ _ s (hasDerivAt_id ‚Üëx) ?_\n      ¬∑ simpa only [mul_one] using t.comp_ofReal\n      ¬∑ exact ofReal_mem_slitPlane.2 hx.1\n    simpa only [ofReal_neg, neg_mul] using d1.ofReal_comp.mul d2\n  have cont := (continuous_ofReal.comp continuous_neg.rexp).mul (continuous_ofReal_cpow_const hs)\n  have der_ible :=\n    (Gamma_integrand_deriv_integrable_A hs hX).add (Gamma_integrand_deriv_integrable_B hs hX)\n  have int_eval := integral_eq_sub_of_hasDerivAt_of_le hX cont.continuousOn F_der_I der_ible\n  -- We are basically done here but manipulating the output into the right form is fiddly.\n  apply_fun fun x : ‚ÑÇ => -x at int_eval\n  rw [intervalIntegral.integral_add (Gamma_integrand_deriv_integrable_A hs hX)\n      (Gamma_integrand_deriv_integrable_B hs hX),\n    intervalIntegral.integral_neg, neg_add, neg_neg] at int_eval\n  rw [eq_sub_of_add_eq int_eval, sub_neg_eq_add, neg_sub, add_comm, add_sub]\n  have : (fun x => (-x).exp * (s * x ^ (s - 1)) : ‚Ñù ‚Üí ‚ÑÇ) =\n      (fun x => s * (-x).exp * x ^ (s - 1) : ‚Ñù ‚Üí ‚ÑÇ) := by ext1; ring\n  rw [this]\n  have t := @integral_const_mul 0 X volume _ _ s fun x : ‚Ñù => (-x).exp * x ^ (s - 1)\n  rw [‚Üê t, ofReal_zero, zero_cpow]\n  ¬∑ rw [mul_zero, add_zero]; congr 2; ext1; ring\n  ¬∑ contrapose! hs; rw [hs, zero_re]\n\n"}
{"name":"Complex.GammaIntegral_add_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Complex\nhs : LT.lt 0 s.re\n‚ä¢ Eq (HAdd.hAdd s 1).GammaIntegral (HMul.hMul s s.GammaIntegral)","decl":"/-- The recurrence relation for the `Œì` integral. -/\ntheorem GammaIntegral_add_one {s : ‚ÑÇ} (hs : 0 < s.re) :\n    GammaIntegral (s + 1) = s * GammaIntegral s := by\n  suffices Tendsto (s + 1).partialGamma atTop (ùìù <| s * GammaIntegral s) by\n    refine tendsto_nhds_unique ?_ this\n    apply tendsto_partialGamma; rw [add_re, one_re]; linarith\n  have : (fun X : ‚Ñù => s * partialGamma s X - X ^ s * (-X).exp) =·∂†[atTop]\n      (s + 1).partialGamma := by\n    apply eventuallyEq_of_mem (Ici_mem_atTop (0 : ‚Ñù))\n    intro X hX\n    rw [partialGamma_add_one hs (mem_Ici.mp hX)]\n    ring_nf\n  refine Tendsto.congr' this ?_\n  suffices Tendsto (fun X => -X ^ s * (-X).exp : ‚Ñù ‚Üí ‚ÑÇ) atTop (ùìù 0) by\n    simpa using Tendsto.add (Tendsto.const_mul s (tendsto_partialGamma hs)) this\n  rw [tendsto_zero_iff_norm_tendsto_zero]\n  have :\n      (fun e : ‚Ñù => ‚Äñ-(e : ‚ÑÇ) ^ s * (-e).exp‚Äñ) =·∂†[atTop] fun e : ‚Ñù => e ^ s.re * (-1 * e).exp := by\n    refine eventuallyEq_of_mem (Ioi_mem_atTop 0) ?_\n    intro x hx; dsimp only\n    rw [norm_eq_abs, map_mul, abs.map_neg, abs_cpow_eq_rpow_re_of_pos hx,\n      abs_of_nonneg (exp_pos (-x)).le, neg_mul, one_mul]\n  exact (tendsto_congr' this).mpr (tendsto_rpow_mul_exp_neg_mul_atTop_nhds_zero _ _ zero_lt_one)\n\n"}
{"name":"Complex.GammaAux_recurrence1","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Complex\nn : Nat\nh1 : LT.lt (Neg.neg s.re) ‚Üën\n‚ä¢ Eq (Complex.GammaAux n s) (HDiv.hDiv (Complex.GammaAux n (HAdd.hAdd s 1)) s)","decl":"theorem GammaAux_recurrence1 (s : ‚ÑÇ) (n : ‚Ñï) (h1 : -s.re < ‚Üën) :\n    GammaAux n s = GammaAux n (s + 1) / s := by\n  induction' n with n hn generalizing s\n  ¬∑ simp only [CharP.cast_eq_zero, Left.neg_neg_iff] at h1\n    dsimp only [GammaAux]; rw [GammaIntegral_add_one h1]\n    rw [mul_comm, mul_div_cancel_right‚ÇÄ]; contrapose! h1; rw [h1]\n    simp\n  ¬∑ dsimp only [GammaAux]\n    have hh1 : -(s + 1).re < n := by\n      rw [Nat.cast_add, Nat.cast_one] at h1\n      rw [add_re, one_re]; linarith\n    rw [‚Üê hn (s + 1) hh1]\n\n"}
{"name":"Complex.GammaAux_recurrence2","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Complex\nn : Nat\nh1 : LT.lt (Neg.neg s.re) ‚Üën\n‚ä¢ Eq (Complex.GammaAux n s) (Complex.GammaAux (HAdd.hAdd n 1) s)","decl":"theorem GammaAux_recurrence2 (s : ‚ÑÇ) (n : ‚Ñï) (h1 : -s.re < ‚Üën) :\n    GammaAux n s = GammaAux (n + 1) s := by\n  cases' n with n n\n  ¬∑ simp only [CharP.cast_eq_zero, Left.neg_neg_iff] at h1\n    dsimp only [GammaAux]\n    rw [GammaIntegral_add_one h1, mul_div_cancel_left‚ÇÄ]\n    rintro rfl\n    rw [zero_re] at h1\n    exact h1.false\n  ¬∑ dsimp only [GammaAux]\n    have : GammaAux n (s + 1 + 1) / (s + 1) = GammaAux n (s + 1) := by\n      have hh1 : -(s + 1).re < n := by\n        rw [Nat.cast_add, Nat.cast_one] at h1\n        rw [add_re, one_re]; linarith\n      rw [GammaAux_recurrence1 (s + 1) n hh1]\n    rw [this]\n\n"}
{"name":"Complex.Gamma_def","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Complex\n‚ä¢ Eq (Complex.Gamma s) (Complex.GammaAux (Nat.floor (HSub.hSub 1 s.re)) s)","decl":"/-- The `Œì` function (of a complex variable `s`). -/\n@[pp_nodot]\nirreducible_def Gamma (s : ‚ÑÇ) : ‚ÑÇ :=\n  GammaAux ‚åä1 - s.re‚åã‚Çä s\n\n"}
{"name":"Complex.Gamma_eq_GammaAux","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Complex\nn : Nat\nh1 : LT.lt (Neg.neg s.re) ‚Üën\n‚ä¢ Eq (Complex.Gamma s) (Complex.GammaAux n s)","decl":"theorem Gamma_eq_GammaAux (s : ‚ÑÇ) (n : ‚Ñï) (h1 : -s.re < ‚Üën) : Gamma s = GammaAux n s := by\n  have u : ‚àÄ k : ‚Ñï, GammaAux (‚åä1 - s.re‚åã‚Çä + k) s = Gamma s := by\n    intro k; induction' k with k hk\n    ¬∑ simp [Gamma]\n    ¬∑ rw [‚Üê hk, ‚Üê add_assoc]\n      refine (GammaAux_recurrence2 s (‚åä1 - s.re‚åã‚Çä + k) ?_).symm\n      rw [Nat.cast_add]\n      have i0 := Nat.sub_one_lt_floor (1 - s.re)\n      simp only [sub_sub_cancel_left] at i0\n      refine lt_add_of_lt_of_nonneg i0 ?_\n      rw [‚Üê Nat.cast_zero, Nat.cast_le]; exact Nat.zero_le k\n  convert (u <| n - ‚åä1 - s.re‚åã‚Çä).symm; rw [Nat.add_sub_of_le]\n  by_cases h : 0 ‚â§ 1 - s.re\n  ¬∑ apply Nat.le_of_lt_succ\n    exact_mod_cast lt_of_le_of_lt (Nat.floor_le h) (by linarith : 1 - s.re < n + 1)\n  ¬∑ rw [Nat.floor_of_nonpos]\n    ¬∑ omega\n    ¬∑ linarith\n\n"}
{"name":"Complex.Gamma_add_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Complex\nh2 : Ne s 0\n‚ä¢ Eq (Complex.Gamma (HAdd.hAdd s 1)) (HMul.hMul s (Complex.Gamma s))","decl":"/-- The recurrence relation for the `Œì` function. -/\ntheorem Gamma_add_one (s : ‚ÑÇ) (h2 : s ‚â† 0) : Gamma (s + 1) = s * Gamma s := by\n  let n := ‚åä1 - s.re‚åã‚Çä\n  have t1 : -s.re < n := by simpa only [sub_sub_cancel_left] using Nat.sub_one_lt_floor (1 - s.re)\n  have t2 : -(s + 1).re < n := by rw [add_re, one_re]; linarith\n  rw [Gamma_eq_GammaAux s n t1, Gamma_eq_GammaAux (s + 1) n t2, GammaAux_recurrence1 s n t1]\n  field_simp\n\n"}
{"name":"Complex.Gamma_eq_integral","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Complex\nhs : LT.lt 0 s.re\n‚ä¢ Eq (Complex.Gamma s) s.GammaIntegral","decl":"theorem Gamma_eq_integral {s : ‚ÑÇ} (hs : 0 < s.re) : Gamma s = GammaIntegral s :=\n  Gamma_eq_GammaAux s 0 (by norm_cast; linarith)\n\n"}
{"name":"Complex.Gamma_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"‚ä¢ Eq (Complex.Gamma 1) 1","decl":"@[simp]\ntheorem Gamma_one : Gamma 1 = 1 := by rw [Gamma_eq_integral] <;> simp\n\n"}
{"name":"Complex.Gamma_nat_eq_factorial","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"n : Nat\n‚ä¢ Eq (Complex.Gamma (HAdd.hAdd (‚Üën) 1)) ‚Üën.factorial","decl":"theorem Gamma_nat_eq_factorial (n : ‚Ñï) : Gamma (n + 1) = n ! := by\n  induction n with\n  | zero => simp\n  | succ n hn =>\n    rw [Gamma_add_one n.succ <| Nat.cast_ne_zero.mpr <| Nat.succ_ne_zero n]\n    simp only [Nat.cast_succ, Nat.factorial_succ, Nat.cast_mul]\n    congr\n\n"}
{"name":"Complex.Gamma_ofNat_eq_factorial","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"n : Nat\ninst‚úù : (HAdd.hAdd n 1).AtLeastTwo\n‚ä¢ Eq (Complex.Gamma (OfNat.ofNat (HAdd.hAdd n 1))) ‚Üën.factorial","decl":"@[simp]\ntheorem Gamma_ofNat_eq_factorial (n : ‚Ñï) [(n + 1).AtLeastTwo] :\n    Gamma (ofNat(n + 1) : ‚ÑÇ) = n ! :=\n  mod_cast Gamma_nat_eq_factorial (n : ‚Ñï)\n\n"}
{"name":"Complex.Gamma_zero","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"‚ä¢ Eq (Complex.Gamma 0) 0","decl":"/-- At `0` the Gamma function is undefined; by convention we assign it the value `0`. -/\n@[simp]\ntheorem Gamma_zero : Gamma 0 = 0 := by\n  simp_rw [Gamma, zero_re, sub_zero, Nat.floor_one, GammaAux, div_zero]\n\n"}
{"name":"Complex.Gamma_neg_nat_eq_zero","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"n : Nat\n‚ä¢ Eq (Complex.Gamma (Neg.neg ‚Üën)) 0","decl":"/-- At `-n` for `n ‚àà ‚Ñï`, the Gamma function is undefined; by convention we assign it the value 0. -/\ntheorem Gamma_neg_nat_eq_zero (n : ‚Ñï) : Gamma (-n) = 0 := by\n  induction n with\n  | zero => rw [Nat.cast_zero, neg_zero, Gamma_zero]\n  | succ n IH =>\n    have A : -(n.succ : ‚ÑÇ) ‚â† 0 := by\n      rw [neg_ne_zero, Nat.cast_ne_zero]\n      apply Nat.succ_ne_zero\n    have : -(n : ‚ÑÇ) = -‚Üën.succ + 1 := by simp\n    rw [this, Gamma_add_one _ A] at IH\n    contrapose! IH\n    exact mul_ne_zero A IH\n\n"}
{"name":"Complex.Gamma_conj","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Complex\n‚ä¢ Eq (Complex.Gamma ((starRingEnd Complex) s)) ((starRingEnd Complex) (Complex.Gamma s))","decl":"theorem Gamma_conj (s : ‚ÑÇ) : Gamma (conj s) = conj (Gamma s) := by\n  suffices ‚àÄ (n : ‚Ñï) (s : ‚ÑÇ), GammaAux n (conj s) = conj (GammaAux n s) by\n    simp [Gamma, this]\n  intro n\n  induction n with\n  | zero => rw [GammaAux]; exact GammaIntegral_conj\n  | succ n IH =>\n    intro s\n    rw [GammaAux]\n    dsimp only\n    rw [div_eq_mul_inv _ s, RingHom.map_mul, conj_inv, ‚Üê div_eq_mul_inv]\n    suffices conj s + 1 = conj (s + 1) by rw [this, IH]\n    rw [RingHom.map_add, RingHom.map_one]\n\n"}
{"name":"Complex.integral_cpow_mul_exp_neg_mul_Ioi","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"a : Complex\nr : Real\nha : LT.lt 0 a.re\nhr : LT.lt 0 r\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => HMul.hMul (HPow.hPow (‚Üët) (HSub.hSub a 1)) (Complex.exp (Neg.neg (HMul.hMul ‚Üër ‚Üët)))) (HMul.hMul (HPow.hPow (HDiv.hDiv 1 ‚Üër) a) (Complex.Gamma a))","decl":"/-- Expresses the integral over `Ioi 0` of `t ^ (a - 1) * exp (-(r * t))` in terms of the Gamma\nfunction, for complex `a`. -/\nlemma integral_cpow_mul_exp_neg_mul_Ioi {a : ‚ÑÇ} {r : ‚Ñù} (ha : 0 < a.re) (hr : 0 < r) :\n    ‚à´ (t : ‚Ñù) in Ioi 0, t ^ (a - 1) * exp (-(r * t)) = (1 / r) ^ a * Gamma a := by\n  have aux : (1 / r : ‚ÑÇ) ^ a = 1 / r * (1 / r) ^ (a - 1) := by\n    nth_rewrite 2 [‚Üê cpow_one (1 / r : ‚ÑÇ)]\n    rw [‚Üê cpow_add _ _ (one_div_ne_zero <| ofReal_ne_zero.mpr hr.ne'), add_sub_cancel]\n  calc\n    _ = ‚à´ (t : ‚Ñù) in Ioi 0, (1 / r) ^ (a - 1) * (r * t) ^ (a - 1) * exp (-(r * t)) := by\n      refine MeasureTheory.setIntegral_congr_fun measurableSet_Ioi (fun x hx ‚Ü¶ ?_)\n      rw [mem_Ioi] at hx\n      rw [mul_cpow_ofReal_nonneg hr.le hx.le, ‚Üê mul_assoc, one_div, ‚Üê ofReal_inv,\n        ‚Üê mul_cpow_ofReal_nonneg (inv_pos.mpr hr).le hr.le, ‚Üê ofReal_mul r‚Åª¬π,\n        inv_mul_cancel‚ÇÄ hr.ne', ofReal_one, one_cpow, one_mul]\n    _ = 1 / r * ‚à´ (t : ‚Ñù) in Ioi 0, (1 / r) ^ (a - 1) * t ^ (a - 1) * exp (-t) := by\n      simp_rw [‚Üê ofReal_mul]\n      rw [integral_comp_mul_left_Ioi (fun x ‚Ü¶ _ * x ^ (a - 1) * exp (-x)) _ hr, mul_zero,\n        real_smul, ‚Üê one_div, ofReal_div, ofReal_one]\n    _ = 1 / r * (1 / r : ‚ÑÇ) ^ (a - 1) * (‚à´ (t : ‚Ñù) in Ioi 0, t ^ (a - 1) * exp (-t)) := by\n      simp_rw [‚Üê integral_mul_left, mul_assoc]\n    _ = (1 / r) ^ a * Gamma a := by\n      rw [aux, Gamma_eq_integral ha]\n      congr 2 with x\n      rw [ofReal_exp, ofReal_neg, mul_comm]\n\n"}
{"name":"Real.Gamma_eq_integral","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Real\nhs : LT.lt 0 s\n‚ä¢ Eq (Real.Gamma s) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun x => HMul.hMul (Real.exp (Neg.neg x)) (HPow.hPow x (HSub.hSub s 1)))","decl":"theorem Gamma_eq_integral {s : ‚Ñù} (hs : 0 < s) :\n    Gamma s = ‚à´ x in Ioi 0, exp (-x) * x ^ (s - 1) := by\n  rw [Gamma, Complex.Gamma_eq_integral (by rwa [Complex.ofReal_re] : 0 < Complex.re s)]\n  dsimp only [Complex.GammaIntegral]\n  simp_rw [‚Üê Complex.ofReal_one, ‚Üê Complex.ofReal_sub]\n  suffices ‚à´ x : ‚Ñù in Ioi 0, ‚Üë(exp (-x)) * (x : ‚ÑÇ) ^ ((s - 1 : ‚Ñù) : ‚ÑÇ) =\n      ‚à´ x : ‚Ñù in Ioi 0, ((exp (-x) * x ^ (s - 1) : ‚Ñù) : ‚ÑÇ) by\n    have cc : ‚àÄ r : ‚Ñù, Complex.ofReal r = @RCLike.ofReal ‚ÑÇ _ r := fun r => rfl\n    conv_lhs => rw [this]; enter [1, 2, x]; rw [cc]\n    rw [_root_.integral_ofReal, ‚Üê cc, Complex.ofReal_re]\n  refine setIntegral_congr_fun measurableSet_Ioi fun x hx => ?_\n  push_cast\n  rw [Complex.ofReal_cpow (le_of_lt hx)]\n  push_cast; rfl\n\n"}
{"name":"Real.Gamma_add_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Real\nhs : Ne s 0\n‚ä¢ Eq (Real.Gamma (HAdd.hAdd s 1)) (HMul.hMul s (Real.Gamma s))","decl":"theorem Gamma_add_one {s : ‚Ñù} (hs : s ‚â† 0) : Gamma (s + 1) = s * Gamma s := by\n  simp_rw [Gamma]\n  rw [Complex.ofReal_add, Complex.ofReal_one, Complex.Gamma_add_one, Complex.re_ofReal_mul]\n  rwa [Complex.ofReal_ne_zero]\n\n"}
{"name":"Real.Gamma_one","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"‚ä¢ Eq (Real.Gamma 1) 1","decl":"@[simp]\ntheorem Gamma_one : Gamma 1 = 1 := by\n  rw [Gamma, Complex.ofReal_one, Complex.Gamma_one, Complex.one_re]\n\n"}
{"name":"Complex.Gamma_ofReal","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Real\n‚ä¢ Eq (Complex.Gamma ‚Üës) ‚Üë(Real.Gamma s)","decl":"theorem _root_.Complex.Gamma_ofReal (s : ‚Ñù) : Complex.Gamma (s : ‚ÑÇ) = Gamma s := by\n  rw [Gamma, eq_comm, ‚Üê Complex.conj_eq_iff_re, ‚Üê Complex.Gamma_conj, Complex.conj_ofReal]\n\n"}
{"name":"Real.Gamma_nat_eq_factorial","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"n : Nat\n‚ä¢ Eq (Real.Gamma (HAdd.hAdd (‚Üën) 1)) ‚Üën.factorial","decl":"theorem Gamma_nat_eq_factorial (n : ‚Ñï) : Gamma (n + 1) = n ! := by\n  rw [Gamma, Complex.ofReal_add, Complex.ofReal_natCast, Complex.ofReal_one,\n    Complex.Gamma_nat_eq_factorial, ‚Üê Complex.ofReal_natCast, Complex.ofReal_re]\n\n"}
{"name":"Real.Gamma_ofNat_eq_factorial","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"n : Nat\ninst‚úù : (HAdd.hAdd n 1).AtLeastTwo\n‚ä¢ Eq (Real.Gamma (OfNat.ofNat (HAdd.hAdd n 1))) ‚Üën.factorial","decl":"@[simp]\ntheorem Gamma_ofNat_eq_factorial (n : ‚Ñï) [(n + 1).AtLeastTwo] :\n    Gamma (ofNat(n + 1) : ‚Ñù) = n ! :=\n  mod_cast Gamma_nat_eq_factorial (n : ‚Ñï)\n\n"}
{"name":"Real.Gamma_zero","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"‚ä¢ Eq (Real.Gamma 0) 0","decl":"/-- At `0` the Gamma function is undefined; by convention we assign it the value `0`. -/\n@[simp]\ntheorem Gamma_zero : Gamma 0 = 0 := by\n  simpa only [‚Üê Complex.ofReal_zero, Complex.Gamma_ofReal, Complex.ofReal_inj] using\n    Complex.Gamma_zero\n\n"}
{"name":"Real.Gamma_neg_nat_eq_zero","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"n : Nat\n‚ä¢ Eq (Real.Gamma (Neg.neg ‚Üën)) 0","decl":"/-- At `-n` for `n ‚àà ‚Ñï`, the Gamma function is undefined; by convention we assign it the value `0`.\n-/\ntheorem Gamma_neg_nat_eq_zero (n : ‚Ñï) : Gamma (-n) = 0 := by\n  simpa only [‚Üê Complex.ofReal_natCast, ‚Üê Complex.ofReal_neg, Complex.Gamma_ofReal,\n    Complex.ofReal_eq_zero] using Complex.Gamma_neg_nat_eq_zero n\n\n"}
{"name":"Real.Gamma_pos_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Real\nhs : LT.lt 0 s\n‚ä¢ LT.lt 0 (Real.Gamma s)","decl":"theorem Gamma_pos_of_pos {s : ‚Ñù} (hs : 0 < s) : 0 < Gamma s := by\n  rw [Gamma_eq_integral hs]\n  have : (Function.support fun x : ‚Ñù => exp (-x) * x ^ (s - 1)) ‚à© Ioi 0 = Ioi 0 := by\n    rw [inter_eq_right]\n    intro x hx\n    rw [Function.mem_support]\n    exact mul_ne_zero (exp_pos _).ne' (rpow_pos_of_pos hx _).ne'\n  rw [setIntegral_pos_iff_support_of_nonneg_ae]\n  ¬∑ rw [this, volume_Ioi, ‚Üê ENNReal.ofReal_zero]\n    exact ENNReal.ofReal_lt_top\n  ¬∑ refine eventually_of_mem (self_mem_ae_restrict measurableSet_Ioi) ?_\n    exact fun x hx => (mul_pos (exp_pos _) (rpow_pos_of_pos hx _)).le\n  ¬∑ exact GammaIntegral_convergent hs\n\n"}
{"name":"Real.Gamma_nonneg_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Real\nhs : LE.le 0 s\n‚ä¢ LE.le 0 (Real.Gamma s)","decl":"theorem Gamma_nonneg_of_nonneg {s : ‚Ñù} (hs : 0 ‚â§ s) : 0 ‚â§ Gamma s := by\n  obtain rfl | h := eq_or_lt_of_le hs\n  ¬∑ rw [Gamma_zero]\n  ¬∑ exact (Gamma_pos_of_pos h).le\n\n"}
{"name":"Real.integral_rpow_mul_exp_neg_mul_Ioi","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"a r : Real\nha : LT.lt 0 a\nhr : LT.lt 0 r\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => HMul.hMul (HPow.hPow t (HSub.hSub a 1)) (Real.exp (Neg.neg (HMul.hMul r t)))) (HMul.hMul (HPow.hPow (HDiv.hDiv 1 r) a) (Real.Gamma a))","decl":"open Complex in\n/-- Expresses the integral over `Ioi 0` of `t ^ (a - 1) * exp (-(r * t))`, for positive real `r`,\nin terms of the Gamma function. -/\nlemma integral_rpow_mul_exp_neg_mul_Ioi {a r : ‚Ñù} (ha : 0 < a) (hr : 0 < r) :\n    ‚à´ t : ‚Ñù in Ioi 0, t ^ (a - 1) * exp (-(r * t)) = (1 / r) ^ a * Gamma a := by\n  rw [‚Üê ofReal_inj, ofReal_mul, ‚Üê Gamma_ofReal, ofReal_cpow (by positivity), ofReal_div]\n  convert integral_cpow_mul_exp_neg_mul_Ioi (by rwa [ofReal_re] : 0 < (a : ‚ÑÇ).re) hr\n  refine integral_ofReal.symm.trans <| setIntegral_congr_fun measurableSet_Ioi (fun t ht ‚Ü¶ ?_)\n  norm_cast\n  simp_rw [‚Üê ofReal_cpow ht.le, RCLike.ofReal_mul, coe_algebraMap]\n\n"}
{"name":"Real.Gamma_ne_zero","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Real\nhs : ‚àÄ (m : Nat), Ne s (Neg.neg ‚Üëm)\n‚ä¢ Ne (Real.Gamma s) 0","decl":"/-- The Gamma function does not vanish on `‚Ñù` (except at non-positive integers, where the function\nis mathematically undefined and we set it to `0` by convention). -/\ntheorem Gamma_ne_zero {s : ‚Ñù} (hs : ‚àÄ m : ‚Ñï, s ‚â† -m) : Gamma s ‚â† 0 := by\n  suffices ‚àÄ {n : ‚Ñï}, -(n : ‚Ñù) < s ‚Üí Gamma s ‚â† 0 by\n    apply this\n    swap\n    ¬∑ exact ‚åä-s‚åã‚Çä + 1\n    rw [neg_lt, Nat.cast_add, Nat.cast_one]\n    exact Nat.lt_floor_add_one _\n  intro n\n  induction n generalizing s with\n  | zero =>\n    intro hs\n    refine (Gamma_pos_of_pos ?_).ne'\n    rwa [Nat.cast_zero, neg_zero] at hs\n  | succ _ n_ih =>\n    intro hs'\n    have : Gamma (s + 1) ‚â† 0 := by\n      apply n_ih\n      ¬∑ intro m\n        specialize hs (1 + m)\n        contrapose! hs\n        rw [‚Üê eq_sub_iff_add_eq] at hs\n        rw [hs]\n        push_cast\n        ring\n      ¬∑ rw [Nat.cast_add, Nat.cast_one, neg_add] at hs'\n        linarith\n    rw [Gamma_add_one, mul_ne_zero_iff] at this\n    ¬∑ exact this.2\n    ¬∑ simpa using hs 0\n\n"}
{"name":"Real.Gamma_eq_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Gamma.Basic","initialProofState":"s : Real\n‚ä¢ Iff (Eq (Real.Gamma s) 0) (Exists fun m => Eq s (Neg.neg ‚Üëm))","decl":"theorem Gamma_eq_zero_iff (s : ‚Ñù) : Gamma s = 0 ‚Üî ‚àÉ m : ‚Ñï, s = -m :=\n  ‚ü®by contrapose!; exact Gamma_ne_zero, by rintro ‚ü®m, rfl‚ü©; exact Gamma_neg_nat_eq_zero m‚ü©\n\n"}
