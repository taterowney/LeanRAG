{"name":"HSpace.hmul_e_e","module":"Mathlib.Topology.Homotopy.HSpaces","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nself : HSpace X\n⊢ Eq (HSpace.hmul { fst := HSpace.e, snd := HSpace.e }) HSpace.e","decl":"/-- A topological space `X` is an H-space if it behaves like a (potentially non-associative)\ntopological group, but where the axioms for a group only hold up to homotopy.\n-/\nclass HSpace (X : Type u) [TopologicalSpace X] where\n  hmul : C(X × X, X)\n  e : X\n  hmul_e_e : hmul (e, e) = e\n  eHmul :\n    (hmul.comp <| (const X e).prodMk <| ContinuousMap.id X).HomotopyRel (ContinuousMap.id X) {e}\n  hmulE :\n    (hmul.comp <| (ContinuousMap.id X).prodMk <| const X e).HomotopyRel (ContinuousMap.id X) {e}\n\n"}
{"name":"TopologicalGroup.one_eq_hSpace_e","module":"Mathlib.Topology.Homotopy.HSpaces","initialProofState":"G : Type u\ninst✝² : TopologicalSpace G\ninst✝¹ : Group G\ninst✝ : TopologicalGroup G\n⊢ Eq 1 HSpace.e","decl":"theorem one_eq_hSpace_e {G : Type u} [TopologicalSpace G] [Group G] [TopologicalGroup G] :\n    (1 : G) = HSpace.e :=\n  rfl\n\n/- In the following example we see that the H-space structure on the product of two topological\ngroups is definitionally equally to the product H-space-structure of the two groups. -/\n"}
{"name":"unitInterval.continuous_qRight","module":"Mathlib.Topology.Homotopy.HSpaces","initialProofState":"⊢ Continuous unitInterval.qRight","decl":"theorem continuous_qRight : Continuous qRight :=\n  continuous_projIcc.comp <|\n    Continuous.div (by fun_prop) (by fun_prop) fun _ ↦ (add_pos zero_lt_one).ne'\n\n"}
{"name":"unitInterval.qRight_zero_left","module":"Mathlib.Topology.Homotopy.HSpaces","initialProofState":"θ : ↑unitInterval\n⊢ Eq (unitInterval.qRight { fst := 0, snd := θ }) 0","decl":"theorem qRight_zero_left (θ : I) : qRight (0, θ) = 0 :=\n  Set.projIcc_of_le_left _ <| by simp only [coe_zero, mul_zero, zero_div, le_refl]\n\n"}
{"name":"unitInterval.qRight_one_left","module":"Mathlib.Topology.Homotopy.HSpaces","initialProofState":"θ : ↑unitInterval\n⊢ Eq (unitInterval.qRight { fst := 1, snd := θ }) 1","decl":"theorem qRight_one_left (θ : I) : qRight (1, θ) = 1 :=\n  Set.projIcc_of_right_le _ <|\n    (le_div_iff₀ <| add_pos zero_lt_one).2 <| by\n      dsimp only\n      rw [coe_one, one_mul, mul_one, add_comm, ← one_add_one_eq_two]\n      simp only [add_le_add_iff_right]\n      exact le_one _\n\n"}
{"name":"unitInterval.qRight_zero_right","module":"Mathlib.Topology.Homotopy.HSpaces","initialProofState":"t : ↑unitInterval\n⊢ Eq (↑(unitInterval.qRight { fst := t, snd := 0 })) (ite (LE.le (↑t) (1 / 2)) (HMul.hMul 2 ↑t) 1)","decl":"theorem qRight_zero_right (t : I) :\n    (qRight (t, 0) : ℝ) = if (t : ℝ) ≤ 1 / 2 then (2 : ℝ) * t else 1 := by\n  simp only [qRight, coe_zero, add_zero, div_one]\n  split_ifs\n  · rw [Set.projIcc_of_mem _ ((mul_pos_mem_iff zero_lt_two).2 _)]\n    refine ⟨t.2.1, ?_⟩\n    tauto\n  · rw [(Set.projIcc_eq_right _).2]\n    · linarith\n    · exact zero_lt_one\n\n"}
{"name":"unitInterval.qRight_one_right","module":"Mathlib.Topology.Homotopy.HSpaces","initialProofState":"t : ↑unitInterval\n⊢ Eq (unitInterval.qRight { fst := t, snd := 1 }) t","decl":"theorem qRight_one_right (t : I) : qRight (t, 1) = t :=\n  Eq.trans (by rw [qRight]; norm_num) <| Set.projIcc_val zero_le_one _\n\n"}
{"name":"Path.continuous_delayReflRight","module":"Mathlib.Topology.Homotopy.HSpaces","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Continuous fun p => Path.delayReflRight p.1 p.2","decl":"theorem continuous_delayReflRight : Continuous fun p : I × Path x y => delayReflRight p.1 p.2 :=\n  continuous_uncurry_iff.mp <|\n    (continuous_snd.comp continuous_fst).eval <|\n      continuous_qRight.comp <| continuous_snd.prod_mk <| continuous_fst.comp continuous_fst\n\n"}
{"name":"Path.delayReflRight_zero","module":"Mathlib.Topology.Homotopy.HSpaces","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx y : X\nγ : Path x y\n⊢ Eq (Path.delayReflRight 0 γ) (γ.trans (Path.refl y))","decl":"theorem delayReflRight_zero (γ : Path x y) : delayReflRight 0 γ = γ.trans (Path.refl y) := by\n  ext t\n  simp only [delayReflRight, trans_apply, refl_extend, Path.coe_mk_mk, Function.comp_apply,\n    refl_apply]\n  split_ifs with h; swap\n  on_goal 1 => conv_rhs => rw [← γ.target]\n  all_goals apply congr_arg γ; ext1; rw [qRight_zero_right]\n  exacts [if_neg h, if_pos h]\n\n"}
{"name":"Path.delayReflRight_one","module":"Mathlib.Topology.Homotopy.HSpaces","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx y : X\nγ : Path x y\n⊢ Eq (Path.delayReflRight 1 γ) γ","decl":"theorem delayReflRight_one (γ : Path x y) : delayReflRight 1 γ = γ := by\n  ext t\n  exact congr_arg γ (qRight_one_right t)\n\n"}
{"name":"Path.continuous_delayReflLeft","module":"Mathlib.Topology.Homotopy.HSpaces","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx y : X\n⊢ Continuous fun p => Path.delayReflLeft p.1 p.2","decl":"theorem continuous_delayReflLeft : Continuous fun p : I × Path x y => delayReflLeft p.1 p.2 :=\n  Path.continuous_symm.comp <|\n    continuous_delayReflRight.comp <|\n      continuous_fst.prod_mk <| Path.continuous_symm.comp continuous_snd\n\n"}
{"name":"Path.delayReflLeft_zero","module":"Mathlib.Topology.Homotopy.HSpaces","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx y : X\nγ : Path x y\n⊢ Eq (Path.delayReflLeft 0 γ) ((Path.refl x).trans γ)","decl":"theorem delayReflLeft_zero (γ : Path x y) : delayReflLeft 0 γ = (Path.refl x).trans γ := by\n  simp only [delayReflLeft, delayReflRight_zero, trans_symm, refl_symm, Path.symm_symm]\n\n"}
{"name":"Path.delayReflLeft_one","module":"Mathlib.Topology.Homotopy.HSpaces","initialProofState":"X : Type u\ninst✝ : TopologicalSpace X\nx y : X\nγ : Path x y\n⊢ Eq (Path.delayReflLeft 1 γ) γ","decl":"theorem delayReflLeft_one (γ : Path x y) : delayReflLeft 1 γ = γ := by\n  simp only [delayReflLeft, delayReflRight_one, Path.symm_symm]\n\n"}
