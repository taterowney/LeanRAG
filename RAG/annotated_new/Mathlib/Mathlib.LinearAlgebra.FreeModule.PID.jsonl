{"name":"eq_bot_of_generator_maximal_map_eq_zero","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nι : Type u_1\nb : Basis ι R M\nN : Submodule R M\nϕ : LinearMap (RingHom.id R) M R\nhϕ : ∀ (ψ : LinearMap (RingHom.id R) M R), Not (LT.lt (Submodule.map ϕ N) (Submodule.map ψ N))\ninst✝ : (Submodule.map ϕ N).IsPrincipal\nhgen : Eq (Submodule.IsPrincipal.generator (Submodule.map ϕ N)) 0\n⊢ Eq N Bot.bot","decl":"theorem eq_bot_of_generator_maximal_map_eq_zero (b : Basis ι R M) {N : Submodule R M}\n    {ϕ : M →ₗ[R] R} (hϕ : ∀ ψ : M →ₗ[R] R, ¬N.map ϕ < N.map ψ) [(N.map ϕ).IsPrincipal]\n    (hgen : generator (N.map ϕ) = (0 : R)) : N = ⊥ := by\n  rw [Submodule.eq_bot_iff]\n  intro x hx\n  refine b.ext_elem fun i ↦ ?_\n  rw [(eq_bot_iff_generator_eq_zero _).mpr hgen] at hϕ\n  rw [LinearEquiv.map_zero, Finsupp.zero_apply]\n  exact\n    (Submodule.eq_bot_iff _).mp (not_bot_lt_iff.1 <| hϕ (Finsupp.lapply i ∘ₗ ↑b.repr)) _\n      ⟨x, hx, rfl⟩\n\n"}
{"name":"eq_bot_of_generator_maximal_submoduleImage_eq_zero","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"R : Type u\nM : Type v\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nι : Type u_1\nN O : Submodule R M\nb : Basis ι R (Subtype fun x => Membership.mem O x)\nhNO : LE.le N O\nϕ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem O x) R\nhϕ : ∀ (ψ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem O x) R), Not (LT.lt (ϕ.submoduleImage N) (ψ.submoduleImage N))\ninst✝ : (ϕ.submoduleImage N).IsPrincipal\nhgen : Eq (Submodule.IsPrincipal.generator (ϕ.submoduleImage N)) 0\n⊢ Eq N Bot.bot","decl":"theorem eq_bot_of_generator_maximal_submoduleImage_eq_zero {N O : Submodule R M} (b : Basis ι R O)\n    (hNO : N ≤ O) {ϕ : O →ₗ[R] R} (hϕ : ∀ ψ : O →ₗ[R] R, ¬ϕ.submoduleImage N < ψ.submoduleImage N)\n    [(ϕ.submoduleImage N).IsPrincipal] (hgen : generator (ϕ.submoduleImage N) = 0) : N = ⊥ := by\n  rw [Submodule.eq_bot_iff]\n  intro x hx\n  refine (mk_eq_zero _ _).mp (show (⟨x, hNO hx⟩ : O) = 0 from b.ext_elem fun i ↦ ?_)\n  rw [(eq_bot_iff_generator_eq_zero _).mpr hgen] at hϕ\n  rw [LinearEquiv.map_zero, Finsupp.zero_apply]\n  refine (Submodule.eq_bot_iff _).mp (not_bot_lt_iff.1 <| hϕ (Finsupp.lapply i ∘ₗ ↑b.repr)) _ ?_\n  exact (LinearMap.mem_submoduleImage_of_le hNO).mpr ⟨x, hx, rfl⟩\n\n"}
{"name":"dvd_generator_iff","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"R : Type u_2\ninst✝² : CommRing R\ninst✝¹ : IsDomain R\nI : Ideal R\ninst✝ : Submodule.IsPrincipal I\nx : R\nhx : Membership.mem I x\n⊢ Iff (Dvd.dvd x (Submodule.IsPrincipal.generator I)) (Eq I (Ideal.span (Singleton.singleton x)))","decl":"theorem dvd_generator_iff {I : Ideal R} [I.IsPrincipal] {x : R} (hx : x ∈ I) :\n    x ∣ generator I ↔ I = Ideal.span {x} := by\n  conv_rhs => rw [← span_singleton_generator I]\n  rw [Ideal.submodule_span_eq, Ideal.span_singleton_eq_span_singleton, ← dvd_dvd_iff_associated,\n    ← mem_iff_generator_dvd]\n  exact ⟨fun h ↦ ⟨hx, h⟩, fun h ↦ h.2⟩\n\n"}
{"name":"generator_maximal_submoduleImage_dvd","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"R : Type u_2\ninst✝⁵ : CommRing R\nM : Type u_3\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : IsDomain R\ninst✝¹ : IsPrincipalIdealRing R\nN O : Submodule R M\nhNO : LE.le N O\nϕ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem O x) R\nhϕ : ∀ (ψ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem O x) R), Not (LT.lt (ϕ.submoduleImage N) (ψ.submoduleImage N))\ninst✝ : (ϕ.submoduleImage N).IsPrincipal\ny : M\nyN : Membership.mem N y\nϕy_eq : Eq (ϕ ⟨y, ⋯⟩) (Submodule.IsPrincipal.generator (ϕ.submoduleImage N))\nψ : LinearMap (RingHom.id R) (Subtype fun x => Membership.mem O x) R\n⊢ Dvd.dvd (Submodule.IsPrincipal.generator (ϕ.submoduleImage N)) (ψ ⟨y, ⋯⟩)","decl":"theorem generator_maximal_submoduleImage_dvd {N O : Submodule R M} (hNO : N ≤ O) {ϕ : O →ₗ[R] R}\n    (hϕ : ∀ ψ : O →ₗ[R] R, ¬ϕ.submoduleImage N < ψ.submoduleImage N)\n    [(ϕ.submoduleImage N).IsPrincipal] (y : M) (yN : y ∈ N)\n    (ϕy_eq : ϕ ⟨y, hNO yN⟩ = generator (ϕ.submoduleImage N)) (ψ : O →ₗ[R] R) :\n    generator (ϕ.submoduleImage N) ∣ ψ ⟨y, hNO yN⟩ := by\n  let a : R := generator (ϕ.submoduleImage N)\n  let d : R := IsPrincipal.generator (Submodule.span R {a, ψ ⟨y, hNO yN⟩})\n  have d_dvd_left : d ∣ a := (mem_iff_generator_dvd _).mp (subset_span (mem_insert _ _))\n  have d_dvd_right : d ∣ ψ ⟨y, hNO yN⟩ :=\n    (mem_iff_generator_dvd _).mp (subset_span (mem_insert_of_mem _ (mem_singleton _)))\n  refine dvd_trans ?_ d_dvd_right\n  rw [dvd_generator_iff, Ideal.span, ←\n    span_singleton_generator (Submodule.span R {a, ψ ⟨y, hNO yN⟩})]\n  · obtain ⟨r₁, r₂, d_eq⟩ : ∃ r₁ r₂ : R, d = r₁ * a + r₂ * ψ ⟨y, hNO yN⟩ := by\n      obtain ⟨r₁, r₂', hr₂', hr₁⟩ :=\n        mem_span_insert.mp (IsPrincipal.generator_mem (Submodule.span R {a, ψ ⟨y, hNO yN⟩}))\n      obtain ⟨r₂, rfl⟩ := mem_span_singleton.mp hr₂'\n      exact ⟨r₁, r₂, hr₁⟩\n    let ψ' : O →ₗ[R] R := r₁ • ϕ + r₂ • ψ\n    have : span R {d} ≤ ψ'.submoduleImage N := by\n      rw [span_le, singleton_subset_iff, SetLike.mem_coe, LinearMap.mem_submoduleImage_of_le hNO]\n      refine ⟨y, yN, ?_⟩\n      change r₁ * ϕ ⟨y, hNO yN⟩ + r₂ * ψ ⟨y, hNO yN⟩ = d\n      rw [d_eq, ϕy_eq]\n    refine\n      le_antisymm (this.trans (le_of_eq ?_)) (Ideal.span_singleton_le_span_singleton.mpr d_dvd_left)\n    rw [span_singleton_generator]\n    apply (le_trans _ this).eq_of_not_gt (hϕ ψ')\n    rw [← span_singleton_generator (ϕ.submoduleImage N)]\n    exact Ideal.span_singleton_le_span_singleton.mpr d_dvd_left\n  · exact subset_span (mem_insert _ _)\n\n"}
{"name":"Submodule.basis_of_pid_aux","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁵ : CommRing R\ninst✝⁴ : IsDomain R\ninst✝³ : IsPrincipalIdealRing R\ninst✝² : Finite ι\nO : Type u_4\ninst✝¹ : AddCommGroup O\ninst✝ : Module R O\nM N : Submodule R O\nb'M : Basis ι R (Subtype fun x => Membership.mem M x)\nN_bot : Ne N Bot.bot\nN_le_M : LE.le N M\n⊢ Exists fun y => And (Membership.mem M y) (Exists fun a => And (Membership.mem N (HSMul.hSMul a y)) (Exists fun M' => And (LE.le M' M) (Exists fun N' => And (LE.le N' N) (And (LE.le N' M') (And (∀ (c : R) (z : O), Membership.mem M' z → Eq (HAdd.hAdd (HSMul.hSMul c y) z) 0 → Eq c 0) (And (∀ (c : R) (z : O), Membership.mem N' z → Eq (HAdd.hAdd (HSMul.hSMul c (HSMul.hSMul a y)) z) 0 → Eq c 0) (∀ (n' : Nat) (bN' : Basis (Fin n') R (Subtype fun x => Membership.mem N' x)), Exists fun bN => ∀ (m' : Nat) (hn'm' : LE.le n' m') (bM' : Basis (Fin m') R (Subtype fun x => Membership.mem M' x)), Exists fun hnm => Exists fun bM => ∀ (as : Fin n' → R), (∀ (i : Fin n'), Eq (↑(bN' i)) (HSMul.hSMul (as i) ↑(bM' (Fin.castLE hn'm' i)))) → Exists fun as' => ∀ (i : Fin (HAdd.hAdd n' 1)), Eq (↑(bN i)) (HSMul.hSMul (as' i) ↑(bM (Fin.castLE hnm i))))))))))","decl":"/-- The induction hypothesis of `Submodule.basisOfPid` and `Submodule.smithNormalForm`.\n\nBasically, it says: let `N ≤ M` be a pair of submodules, then we can find a pair of\nsubmodules `N' ≤ M'` of strictly smaller rank, whose basis we can extend to get a basis\nof `N` and `M`. Moreover, if the basis for `M'` is up to scalars a basis for `N'`,\nthen the basis we find for `M` is up to scalars a basis for `N`.\n\nFor `basis_of_pid` we only need the first half and can fix `M = ⊤`,\nfor `smith_normal_form` we need the full statement,\nbut must also feed in a basis for `M` using `basis_of_pid` to keep the induction going.\n-/\ntheorem Submodule.basis_of_pid_aux [Finite ι] {O : Type*} [AddCommGroup O] [Module R O]\n    (M N : Submodule R O) (b'M : Basis ι R M) (N_bot : N ≠ ⊥) (N_le_M : N ≤ M) :\n    ∃ y ∈ M, ∃ a : R, a • y ∈ N ∧ ∃ M' ≤ M, ∃ N' ≤ N,\n      N' ≤ M' ∧ (∀ (c : R) (z : O), z ∈ M' → c • y + z = 0 → c = 0) ∧\n      (∀ (c : R) (z : O), z ∈ N' → c • a • y + z = 0 → c = 0) ∧\n      ∀ (n') (bN' : Basis (Fin n') R N'),\n        ∃ bN : Basis (Fin (n' + 1)) R N,\n          ∀ (m') (hn'm' : n' ≤ m') (bM' : Basis (Fin m') R M'),\n            ∃ (hnm : n' + 1 ≤ m' + 1) (bM : Basis (Fin (m' + 1)) R M),\n              ∀ as : Fin n' → R,\n                (∀ i : Fin n', (bN' i : O) = as i • (bM' (Fin.castLE hn'm' i) : O)) →\n                  ∃ as' : Fin (n' + 1) → R,\n                    ∀ i : Fin (n' + 1), (bN i : O) = as' i • (bM (Fin.castLE hnm i) : O) := by\n  -- Let `ϕ` be a maximal projection of `M` onto `R`, in the sense that there is\n  -- no `ψ` whose image of `N` is larger than `ϕ`'s image of `N`.\n  have : ∃ ϕ : M →ₗ[R] R, ∀ ψ : M →ₗ[R] R, ¬ϕ.submoduleImage N < ψ.submoduleImage N := by\n    obtain ⟨P, P_eq, P_max⟩ :=\n      set_has_maximal_iff_noetherian.mpr (inferInstance : IsNoetherian R R) _\n        (show (Set.range fun ψ : M →ₗ[R] R ↦ ψ.submoduleImage N).Nonempty from\n          ⟨_, Set.mem_range.mpr ⟨0, rfl⟩⟩)\n    obtain ⟨ϕ, rfl⟩ := Set.mem_range.mp P_eq\n    exact ⟨ϕ, fun ψ hψ ↦ P_max _ ⟨_, rfl⟩ hψ⟩\n  let ϕ := this.choose\n  have ϕ_max := this.choose_spec\n  -- Since `ϕ(N)` is an `R`-submodule of the PID `R`,\n  -- it is principal and generated by some `a`.\n  let a := generator (ϕ.submoduleImage N)\n  have a_mem : a ∈ ϕ.submoduleImage N := generator_mem _\n  -- If `a` is zero, then the submodule is trivial. So let's assume `a ≠ 0`, `N ≠ ⊥`.\n  by_cases a_zero : a = 0\n  · have := eq_bot_of_generator_maximal_submoduleImage_eq_zero b'M N_le_M ϕ_max a_zero\n    contradiction\n  -- We claim that `ϕ⁻¹ a = y` can be taken as basis element of `N`.\n  obtain ⟨y, yN, ϕy_eq⟩ := (LinearMap.mem_submoduleImage_of_le N_le_M).mp a_mem\n  have _ϕy_ne_zero : ϕ ⟨y, N_le_M yN⟩ ≠ 0 := fun h ↦ a_zero (ϕy_eq.symm.trans h)\n  -- Write `y` as `a • y'` for some `y'`.\n  have hdvd : ∀ i, a ∣ b'M.coord i ⟨y, N_le_M yN⟩ := fun i ↦\n    generator_maximal_submoduleImage_dvd N_le_M ϕ_max y yN ϕy_eq (b'M.coord i)\n  choose c hc using hdvd\n  cases nonempty_fintype ι\n  let y' : O := ∑ i, c i • b'M i\n  have y'M : y' ∈ M := M.sum_mem fun i _ ↦ M.smul_mem (c i) (b'M i).2\n  have mk_y' : (⟨y', y'M⟩ : M) = ∑ i, c i • b'M i :=\n    Subtype.ext\n      (show y' = M.subtype _ by\n        simp only [map_sum, map_smul]\n        rfl)\n  have a_smul_y' : a • y' = y := by\n    refine Subtype.mk_eq_mk.mp (show (a • ⟨y', y'M⟩ : M) = ⟨y, N_le_M yN⟩ from ?_)\n    rw [← b'M.sum_repr ⟨y, N_le_M yN⟩, mk_y', Finset.smul_sum]\n    refine Finset.sum_congr rfl fun i _ ↦ ?_\n    rw [← mul_smul, ← hc]\n    rfl\n  -- We found a `y` and an `a`!\n  refine ⟨y', y'M, a, a_smul_y'.symm ▸ yN, ?_⟩\n  have ϕy'_eq : ϕ ⟨y', y'M⟩ = 1 :=\n    mul_left_cancel₀ a_zero\n      (calc\n        a • ϕ ⟨y', y'M⟩ = ϕ ⟨a • y', _⟩ := (ϕ.map_smul a ⟨y', y'M⟩).symm\n        _ = ϕ ⟨y, N_le_M yN⟩ := by simp only [a_smul_y']\n        _ = a := ϕy_eq\n        _ = a * 1 := (mul_one a).symm\n        )\n  have ϕy'_ne_zero : ϕ ⟨y', y'M⟩ ≠ 0 := by simpa only [ϕy'_eq] using one_ne_zero\n  -- `M' := ker (ϕ : M → R)` is smaller than `M` and `N' := ker (ϕ : N → R)` is smaller than `N`.\n  let M' : Submodule R O := ϕ.ker.map M.subtype\n  let N' : Submodule R O := (ϕ.comp (inclusion N_le_M)).ker.map N.subtype\n  have M'_le_M : M' ≤ M := M.map_subtype_le (LinearMap.ker ϕ)\n  have N'_le_M' : N' ≤ M' := by\n    intro x hx\n    simp only [N', mem_map, LinearMap.mem_ker] at hx ⊢\n    obtain ⟨⟨x, xN⟩, hx, rfl⟩ := hx\n    exact ⟨⟨x, N_le_M xN⟩, hx, rfl⟩\n  have N'_le_N : N' ≤ N := N.map_subtype_le (LinearMap.ker (ϕ.comp (inclusion N_le_M)))\n  -- So fill in those results as well.\n  refine ⟨M', M'_le_M, N', N'_le_N, N'_le_M', ?_⟩\n  -- Note that `y'` is orthogonal to `M'`.\n  have y'_ortho_M' : ∀ (c : R), ∀ z ∈ M', c • y' + z = 0 → c = 0 := by\n    intro c x xM' hc\n    obtain ⟨⟨x, xM⟩, hx', rfl⟩ := Submodule.mem_map.mp xM'\n    rw [LinearMap.mem_ker] at hx'\n    have hc' : (c • ⟨y', y'M⟩ + ⟨x, xM⟩ : M) = 0 := by exact @Subtype.coe_injective O (· ∈ M) _ _ hc\n    simpa only [LinearMap.map_add, LinearMap.map_zero, LinearMap.map_smul, smul_eq_mul, add_zero,\n      mul_eq_zero, ϕy'_ne_zero, hx', or_false] using congr_arg ϕ hc'\n  -- And `a • y'` is orthogonal to `N'`.\n  have ay'_ortho_N' : ∀ (c : R), ∀ z ∈ N', c • a • y' + z = 0 → c = 0 := by\n    intro c z zN' hc\n    refine (mul_eq_zero.mp (y'_ortho_M' (a * c) z (N'_le_M' zN') ?_)).resolve_left a_zero\n    rw [mul_comm, mul_smul, hc]\n  -- So we can extend a basis for `N'` with `y`\n  refine ⟨y'_ortho_M', ay'_ortho_N', fun n' bN' ↦ ⟨?_, ?_⟩⟩\n  · refine Basis.mkFinConsOfLE y yN bN' N'_le_N ?_ ?_\n    · intro c z zN' hc\n      refine ay'_ortho_N' c z zN' ?_\n      rwa [← a_smul_y'] at hc\n    · intro z zN\n      obtain ⟨b, hb⟩ : _ ∣ ϕ ⟨z, N_le_M zN⟩ := generator_submoduleImage_dvd_of_mem N_le_M ϕ zN\n      refine ⟨-b, Submodule.mem_map.mpr ⟨⟨_, N.sub_mem zN (N.smul_mem b yN)⟩, ?_, ?_⟩⟩\n      · refine LinearMap.mem_ker.mpr (show ϕ (⟨z, N_le_M zN⟩ - b • ⟨y, N_le_M yN⟩) = 0 from ?_)\n        rw [LinearMap.map_sub, LinearMap.map_smul, hb, ϕy_eq, smul_eq_mul, mul_comm, sub_self]\n      · simp only [sub_eq_add_neg, neg_smul, coe_subtype]\n  -- And extend a basis for `M'` with `y'`\n  intro m' hn'm' bM'\n  refine ⟨Nat.succ_le_succ hn'm', ?_, ?_⟩\n  · refine Basis.mkFinConsOfLE y' y'M bM' M'_le_M y'_ortho_M' ?_\n    intro z zM\n    refine ⟨-ϕ ⟨z, zM⟩, ⟨⟨z, zM⟩ - ϕ ⟨z, zM⟩ • ⟨y', y'M⟩, LinearMap.mem_ker.mpr ?_, ?_⟩⟩\n    · rw [LinearMap.map_sub, LinearMap.map_smul, ϕy'_eq, smul_eq_mul, mul_one, sub_self]\n    · rw [LinearMap.map_sub, LinearMap.map_smul, sub_eq_add_neg, neg_smul]\n      rfl\n  -- It remains to show the extended bases are compatible with each other.\n  intro as h\n  refine ⟨Fin.cons a as, ?_⟩\n  intro i\n  rw [Basis.coe_mkFinConsOfLE, Basis.coe_mkFinConsOfLE]\n  refine Fin.cases ?_ (fun i ↦ ?_) i\n  · simp only [Fin.cons_zero, Fin.castLE_zero]\n    exact a_smul_y'.symm\n  · rw [Fin.castLE_succ]\n    simp only [Fin.cons_succ, Function.comp_apply, coe_inclusion, map_coe, coe_subtype, h i]\n\n"}
{"name":"Submodule.nonempty_basis_of_pid","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"R : Type u_2\ninst✝⁵ : CommRing R\nM : Type u_3\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : IsDomain R\ninst✝¹ : IsPrincipalIdealRing R\nι : Type u_4\ninst✝ : Finite ι\nb : Basis ι R M\nN : Submodule R M\n⊢ Exists fun n => Nonempty (Basis (Fin n) R (Subtype fun x => Membership.mem N x))","decl":"/-- A submodule of a free `R`-module of finite rank is also a free `R`-module of finite rank,\nif `R` is a principal ideal domain.\n\nThis is a `lemma` to make the induction a bit easier. To actually access the basis,\nsee `Submodule.basisOfPid`.\n\nSee also the stronger version `Submodule.smithNormalForm`.\n-/\ntheorem Submodule.nonempty_basis_of_pid {ι : Type*} [Finite ι] (b : Basis ι R M)\n    (N : Submodule R M) : ∃ n : ℕ, Nonempty (Basis (Fin n) R N) := by\n  haveI := Classical.decEq M\n  cases nonempty_fintype ι\n  induction N using inductionOnRank b with | ih N ih =>\n  let b' := (b.reindex (Fintype.equivFin ι)).map (LinearEquiv.ofTop _ rfl).symm\n  by_cases N_bot : N = ⊥\n  · subst N_bot\n    exact ⟨0, ⟨Basis.empty _⟩⟩\n  obtain ⟨y, -, a, hay, M', -, N', N'_le_N, -, -, ay_ortho, h'⟩ :=\n    Submodule.basis_of_pid_aux ⊤ N b' N_bot le_top\n  obtain ⟨n', ⟨bN'⟩⟩ := ih N' N'_le_N _ hay ay_ortho\n  obtain ⟨bN, _hbN⟩ := h' n' bN'\n  exact ⟨n' + 1, ⟨bN⟩⟩\n\n"}
{"name":"Submodule.basisOfPid_bot","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"R : Type u_2\ninst✝⁵ : CommRing R\nM : Type u_3\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : IsDomain R\ninst✝¹ : IsPrincipalIdealRing R\nι : Type u_4\ninst✝ : Finite ι\nb : Basis ι R M\n⊢ Eq (Submodule.basisOfPid b Bot.bot) ⟨0, Basis.empty (Subtype fun x => Membership.mem Bot.bot x)⟩","decl":"theorem Submodule.basisOfPid_bot {ι : Type*} [Finite ι] (b : Basis ι R M) :\n    Submodule.basisOfPid b ⊥ = ⟨0, Basis.empty _⟩ := by\n  obtain ⟨n, b'⟩ := Submodule.basisOfPid b ⊥\n  let e : Fin n ≃ Fin 0 := b'.indexEquiv (Basis.empty _ : Basis (Fin 0) R (⊥ : Submodule R M))\n  obtain rfl : n = 0 := by simpa using Fintype.card_eq.mpr ⟨e⟩\n  exact Sigma.eq rfl (Basis.eq_of_apply_eq <| finZeroElim)\n\n"}
{"name":"Module.free_of_finite_type_torsion_free","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁶ : CommRing R\nM : Type u_3\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : IsDomain R\ninst✝² : IsPrincipalIdealRing R\ninst✝¹ : Finite ι\ns : ι → M\nhs : Eq (Submodule.span R (Set.range s)) Top.top\ninst✝ : NoZeroSMulDivisors R M\n⊢ Module.Free R M","decl":"theorem Module.free_of_finite_type_torsion_free [_root_.Finite ι] {s : ι → M}\n    (hs : span R (range s) = ⊤) [NoZeroSMulDivisors R M] : Module.Free R M := by\n  cases nonempty_fintype ι\n  obtain ⟨n, b⟩ : Σn, Basis (Fin n) R M := Module.basisOfFiniteTypeTorsionFree hs\n  exact Module.Free.of_basis b\n\n"}
{"name":"Module.free_of_finite_type_torsion_free'","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"R : Type u_2\ninst✝⁴ : CommRing R\nM : Type u_3\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Finite R M\ninst✝ : NoZeroSMulDivisors R M\n⊢ Module.Free R M","decl":"instance Module.free_of_finite_type_torsion_free' [Module.Finite R M] [NoZeroSMulDivisors R M] :\n    Module.Free R M := by\n  obtain ⟨n, b⟩ : Σn, Basis (Fin n) R M := Module.basisOfFiniteTypeTorsionFree'\n  exact Module.Free.of_basis b\n\n"}
{"name":"instFreeSubtypeMemIdealOfFiniteOfNoZeroSMulDivisors","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"R : Type u_2\ninst✝² : CommRing R\nS : Type u_4\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nI : Ideal S\nhI₁ : Module.Finite R (Subtype fun x => Membership.mem I x)\nhI₂ : NoZeroSMulDivisors R (Subtype fun x => Membership.mem I x)\n⊢ Module.Free R (Subtype fun x => Membership.mem I x)","decl":"instance {S : Type*} [CommRing S] [Algebra R S] {I : Ideal S} [hI₁ : Module.Finite R I]\n    [hI₂ : NoZeroSMulDivisors R I] : Module.Free R I := by\n  have : Module.Finite R (restrictScalars R I) := hI₁\n  have : NoZeroSMulDivisors R (restrictScalars R I) := hI₂\n  change Module.Free R (restrictScalars R I)\n  exact Module.free_of_finite_type_torsion_free'\n\n"}
{"name":"Module.free_iff_noZeroSMulDivisors","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"R : Type u_2\ninst✝⁵ : CommRing R\nM : Type u_3\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : IsDomain R\ninst✝¹ : IsPrincipalIdealRing R\ninst✝ : Module.Finite R M\n⊢ Iff (Module.Free R M) (NoZeroSMulDivisors R M)","decl":"theorem Module.free_iff_noZeroSMulDivisors [Module.Finite R M] :\n    Module.Free R M ↔ NoZeroSMulDivisors R M :=\n  ⟨fun _ ↦ inferInstance, fun _ ↦ inferInstance⟩\n\n"}
{"name":"Basis.SmithNormalForm.mk.injEq","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"R : Type u_2\ninst✝² : CommRing R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN : Submodule R M\nι : Type u_4\nn : Nat\nbM✝ : Basis ι R M\nbN✝ : Basis (Fin n) R (Subtype fun x => Membership.mem N x)\nf✝ : Function.Embedding (Fin n) ι\na✝ : Fin n → R\nsnf✝ : ∀ (i : Fin n), Eq (↑(bN✝ i)) (HSMul.hSMul (a✝ i) (bM✝ (f✝ i)))\nbM : Basis ι R M\nbN : Basis (Fin n) R (Subtype fun x => Membership.mem N x)\nf : Function.Embedding (Fin n) ι\na : Fin n → R\nsnf : ∀ (i : Fin n), Eq (↑(bN i)) (HSMul.hSMul (a i) (bM (f i)))\n⊢ Eq (Eq { bM := bM✝, bN := bN✝, f := f✝, a := a✝, snf := snf✝ } { bM := bM, bN := bN, f := f, a := a, snf := snf }) (And (Eq bM✝ bM) (And (Eq bN✝ bN) (And (Eq f✝ f) (Eq a✝ a))))","decl":"/-- A Smith normal form basis for a submodule `N` of a module `M` consists of\nbases for `M` and `N` such that the inclusion map `N → M` can be written as a\n(rectangular) matrix with `a` along the diagonal: in Smith normal form. -/\nstructure Basis.SmithNormalForm (N : Submodule R M) (ι : Type*) (n : ℕ) where\n  /-- The basis of M. -/\n  bM : Basis ι R M\n  /-- The basis of N. -/\n  bN : Basis (Fin n) R N\n  /-- The mapping between the vectors of the bases. -/\n  f : Fin n ↪ ι\n  /-- The (diagonal) entries of the matrix. -/\n  a : Fin n → R\n  /-- The SNF relation between the vectors of the bases. -/\n  snf : ∀ i, (bN i : M) = a i • bM (f i)\n\n"}
{"name":"Basis.SmithNormalForm.snf","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"R : Type u_2\ninst✝² : CommRing R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN : Submodule R M\nι : Type u_4\nn : Nat\nself : Basis.SmithNormalForm N ι n\ni : Fin n\n⊢ Eq (↑(self.bN i)) (HSMul.hSMul (self.a i) (self.bM (self.f i)))","decl":"/-- A Smith normal form basis for a submodule `N` of a module `M` consists of\nbases for `M` and `N` such that the inclusion map `N → M` can be written as a\n(rectangular) matrix with `a` along the diagonal: in Smith normal form. -/\nstructure Basis.SmithNormalForm (N : Submodule R M) (ι : Type*) (n : ℕ) where\n  /-- The basis of M. -/\n  bM : Basis ι R M\n  /-- The basis of N. -/\n  bN : Basis (Fin n) R N\n  /-- The mapping between the vectors of the bases. -/\n  f : Fin n ↪ ι\n  /-- The (diagonal) entries of the matrix. -/\n  a : Fin n → R\n  /-- The SNF relation between the vectors of the bases. -/\n  snf : ∀ i, (bN i : M) = a i • bM (f i)\n\n"}
{"name":"Basis.SmithNormalForm.mk.sizeOf_spec","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"R : Type u_2\ninst✝⁵ : CommRing R\nM : Type u_3\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nN : Submodule R M\nι : Type u_4\nn : Nat\ninst✝² : SizeOf R\ninst✝¹ : SizeOf M\ninst✝ : SizeOf ι\nbM : Basis ι R M\nbN : Basis (Fin n) R (Subtype fun x => Membership.mem N x)\nf : Function.Embedding (Fin n) ι\na : Fin n → R\nsnf : ∀ (i : Fin n), Eq (↑(bN i)) (HSMul.hSMul (a i) (bM (f i)))\n⊢ Eq (SizeOf.sizeOf { bM := bM, bN := bN, f := f, a := a, snf := snf }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf bM)) (SizeOf.sizeOf bN)) (SizeOf.sizeOf f))","decl":"/-- A Smith normal form basis for a submodule `N` of a module `M` consists of\nbases for `M` and `N` such that the inclusion map `N → M` can be written as a\n(rectangular) matrix with `a` along the diagonal: in Smith normal form. -/\nstructure Basis.SmithNormalForm (N : Submodule R M) (ι : Type*) (n : ℕ) where\n  /-- The basis of M. -/\n  bM : Basis ι R M\n  /-- The basis of N. -/\n  bN : Basis (Fin n) R N\n  /-- The mapping between the vectors of the bases. -/\n  f : Fin n ↪ ι\n  /-- The (diagonal) entries of the matrix. -/\n  a : Fin n → R\n  /-- The SNF relation between the vectors of the bases. -/\n  snf : ∀ i, (bN i : M) = a i • bM (f i)\n\n"}
{"name":"Basis.SmithNormalForm.mk.inj","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"R : Type u_2\ninst✝² : CommRing R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nN : Submodule R M\nι : Type u_4\nn : Nat\nbM✝ : Basis ι R M\nbN✝ : Basis (Fin n) R (Subtype fun x => Membership.mem N x)\nf✝ : Function.Embedding (Fin n) ι\na✝ : Fin n → R\nsnf✝ : ∀ (i : Fin n), Eq (↑(bN✝ i)) (HSMul.hSMul (a✝ i) (bM✝ (f✝ i)))\nbM : Basis ι R M\nbN : Basis (Fin n) R (Subtype fun x => Membership.mem N x)\nf : Function.Embedding (Fin n) ι\na : Fin n → R\nsnf : ∀ (i : Fin n), Eq (↑(bN i)) (HSMul.hSMul (a i) (bM (f i)))\nx✝ : Eq { bM := bM✝, bN := bN✝, f := f✝, a := a✝, snf := snf✝ } { bM := bM, bN := bN, f := f, a := a, snf := snf }\n⊢ And (Eq bM✝ bM) (And (Eq bN✝ bN) (And (Eq f✝ f) (Eq a✝ a)))","decl":"/-- A Smith normal form basis for a submodule `N` of a module `M` consists of\nbases for `M` and `N` such that the inclusion map `N → M` can be written as a\n(rectangular) matrix with `a` along the diagonal: in Smith normal form. -/\nstructure Basis.SmithNormalForm (N : Submodule R M) (ι : Type*) (n : ℕ) where\n  /-- The basis of M. -/\n  bM : Basis ι R M\n  /-- The basis of N. -/\n  bN : Basis (Fin n) R N\n  /-- The mapping between the vectors of the bases. -/\n  f : Fin n ↪ ι\n  /-- The (diagonal) entries of the matrix. -/\n  a : Fin n → R\n  /-- The SNF relation between the vectors of the bases. -/\n  snf : ∀ i, (bN i : M) = a i • bM (f i)\n\n"}
{"name":"Basis.SmithNormalForm.repr_eq_zero_of_nmem_range","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝² : CommRing R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nN : Submodule R M\nsnf : Basis.SmithNormalForm N ι n\nm : Subtype fun x => Membership.mem N x\ni : ι\nhi : Not (Membership.mem (Set.range ⇑snf.f) i)\n⊢ Eq ((snf.bM.repr ↑m) i) 0","decl":"lemma repr_eq_zero_of_nmem_range {i : ι} (hi : i ∉ Set.range snf.f) :\n    snf.bM.repr m i = 0 := by\n  obtain ⟨m, hm⟩ := m\n  obtain ⟨c, rfl⟩ := snf.bN.mem_submodule_iff.mp hm\n  replace hi : ∀ j, snf.f j ≠ i := by simpa using hi\n  simp [Finsupp.single_apply, hi, snf.snf, map_finsupp_sum]\n\n"}
{"name":"Basis.SmithNormalForm.le_ker_coord_of_nmem_range","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝² : CommRing R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nN : Submodule R M\nsnf : Basis.SmithNormalForm N ι n\ni : ι\nhi : Not (Membership.mem (Set.range ⇑snf.f) i)\n⊢ LE.le N (LinearMap.ker (snf.bM.coord i))","decl":"lemma le_ker_coord_of_nmem_range {i : ι} (hi : i ∉ Set.range snf.f) :\n    N ≤ LinearMap.ker (snf.bM.coord i) :=\n  fun m hm ↦ snf.repr_eq_zero_of_nmem_range ⟨m, hm⟩ hi\n\n"}
{"name":"Basis.SmithNormalForm.repr_apply_embedding_eq_repr_smul","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝² : CommRing R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nN : Submodule R M\nsnf : Basis.SmithNormalForm N ι n\nm : Subtype fun x => Membership.mem N x\ni : Fin n\n⊢ Eq ((snf.bM.repr ↑m) (snf.f i)) ((snf.bN.repr (HSMul.hSMul (snf.a i) m)) i)","decl":"@[simp] lemma repr_apply_embedding_eq_repr_smul {i : Fin n} :\n    snf.bM.repr m (snf.f i) = snf.bN.repr (snf.a i • m) i := by\n  obtain ⟨m, hm⟩ := m\n  obtain ⟨c, rfl⟩ := snf.bN.mem_submodule_iff.mp hm\n  replace hm : (⟨Finsupp.sum c fun i t ↦ t • (↑(snf.bN i) : M), hm⟩ : N) =\n      Finsupp.sum c fun i t ↦ t • ⟨snf.bN i, (snf.bN i).2⟩ := by\n    ext; change _ = N.subtype _; simp [map_finsupp_sum]\n  classical\n  simp_rw [hm, map_smul, map_finsupp_sum, map_smul, Subtype.coe_eta, repr_self,\n    Finsupp.smul_single, smul_eq_mul, mul_one, Finsupp.sum_single, Finsupp.smul_apply, snf.snf,\n    map_smul, repr_self, Finsupp.smul_single, smul_eq_mul, mul_one, Finsupp.sum_apply,\n    Finsupp.single_apply, EmbeddingLike.apply_eq_iff_eq, Finsupp.sum_ite_eq',\n    Finsupp.mem_support_iff, ite_not, mul_comm, ite_eq_right_iff]\n  exact fun a ↦ (mul_eq_zero_of_right _ a).symm\n\n"}
{"name":"Basis.SmithNormalForm.repr_comp_embedding_eq_smul","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝² : CommRing R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nN : Submodule R M\nsnf : Basis.SmithNormalForm N ι n\nm : Subtype fun x => Membership.mem N x\n⊢ Eq (Function.comp ⇑(snf.bM.repr ↑m) ⇑snf.f) (HSMul.hSMul snf.a ⇑(snf.bN.repr m))","decl":"@[simp] lemma repr_comp_embedding_eq_smul :\n    snf.bM.repr m ∘ snf.f = snf.a • (snf.bN.repr m : Fin n → R) := by\n  ext i\n  simp [Pi.smul_apply (snf.a i)]\n\n"}
{"name":"Basis.SmithNormalForm.coord_apply_embedding_eq_smul_coord","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝² : CommRing R\nM : Type u_3\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nn : Nat\nN : Submodule R M\nsnf : Basis.SmithNormalForm N ι n\ni : Fin n\n⊢ Eq ((snf.bM.coord (snf.f i)).comp N.subtype) (HSMul.hSMul (snf.a i) (snf.bN.coord i))","decl":"@[simp] lemma coord_apply_embedding_eq_smul_coord {i : Fin n} :\n    snf.bM.coord (snf.f i) ∘ₗ N.subtype = snf.a i • snf.bN.coord i := by\n  ext m\n  simp [Pi.smul_apply (snf.a i)]\n\n"}
{"name":"Basis.SmithNormalForm.toMatrix_restrict_eq_toMatrix","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁴ : CommRing R\nM : Type u_3\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nn : Nat\nN : Submodule R M\nsnf : Basis.SmithNormalForm N ι n\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nf : LinearMap (RingHom.id R) M M\nhf : ∀ (x : M), Membership.mem N (f x)\nhf' : optParam (∀ (x : M), Membership.mem N x → Membership.mem N (f x)) ⋯\ni : Fin n\n⊢ Eq ((LinearMap.toMatrix snf.bN snf.bN) (f.restrict hf') i i) ((LinearMap.toMatrix snf.bM snf.bM) f (snf.f i) (snf.f i))","decl":"/-- Given a Smith-normal-form pair of bases for `N ⊆ M`, and a linear endomorphism `f` of `M`\nthat preserves `N`, the diagonal of the matrix of the restriction `f` to `N` does not depend on\nwhich of the two bases for `N` is used. -/\n@[simp]\nlemma toMatrix_restrict_eq_toMatrix [Fintype ι] [DecidableEq ι]\n    (f : M →ₗ[R] M) (hf : ∀ x, f x ∈ N) (hf' : ∀ x ∈ N, f x ∈ N := fun x _ ↦ hf x) {i : Fin n} :\n    LinearMap.toMatrix snf.bN snf.bN (LinearMap.restrict f hf') i i =\n    LinearMap.toMatrix snf.bM snf.bM f (snf.f i) (snf.f i) := by\n  rw [LinearMap.toMatrix_apply, LinearMap.toMatrix_apply,\n    snf.repr_apply_embedding_eq_repr_smul ⟨_, (hf _)⟩]\n  congr\n  ext\n  simp [snf.snf]\n\n"}
{"name":"Submodule.exists_smith_normal_form_of_le","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁵ : CommRing R\nM : Type u_3\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : IsDomain R\ninst✝¹ : IsPrincipalIdealRing R\ninst✝ : Finite ι\nb : Basis ι R M\nN O : Submodule R M\nN_le_O : LE.le N O\n⊢ Exists fun n => Exists fun o => Exists fun hno => Exists fun bO => Exists fun bN => Exists fun a => ∀ (i : Fin n), Eq (↑(bN i)) (HSMul.hSMul (a i) ↑(bO (Fin.castLE hno i)))","decl":"/-- If `M` is finite free over a PID `R`, then any submodule `N` is free\nand we can find a basis for `M` and `N` such that the inclusion map is a diagonal matrix\nin Smith normal form.\n\nSee `Submodule.smithNormalFormOfLE` for a version of this theorem that returns\na `Basis.SmithNormalForm`.\n\nThis is a strengthening of `Submodule.basisOfPidOfLE`.\n-/\ntheorem Submodule.exists_smith_normal_form_of_le [Finite ι] (b : Basis ι R M) (N O : Submodule R M)\n    (N_le_O : N ≤ O) :\n    ∃ (n o : ℕ) (hno : n ≤ o) (bO : Basis (Fin o) R O) (bN : Basis (Fin n) R N) (a : Fin n → R),\n      ∀ i, (bN i : M) = a i • bO (Fin.castLE hno i) := by\n  cases nonempty_fintype ι\n  induction O using inductionOnRank b generalizing N with | ih M0 ih =>\n  obtain ⟨m, b'M⟩ := M0.basisOfPid b\n  by_cases N_bot : N = ⊥\n  · subst N_bot\n    exact ⟨0, m, Nat.zero_le _, b'M, Basis.empty _, finZeroElim, finZeroElim⟩\n  obtain ⟨y, hy, a, _, M', M'_le_M, N', _, N'_le_M', y_ortho, _, h⟩ :=\n    Submodule.basis_of_pid_aux M0 N b'M N_bot N_le_O\n\n  obtain ⟨n', m', hn'm', bM', bN', as', has'⟩ := ih M' M'_le_M y hy y_ortho N' N'_le_M'\n  obtain ⟨bN, h'⟩ := h n' bN'\n  obtain ⟨hmn, bM, h''⟩ := h' m' hn'm' bM'\n  obtain ⟨as, has⟩ := h'' as' has'\n  exact ⟨_, _, hmn, bM, bN, as, has⟩\n\n"}
{"name":"Ideal.exists_smith_normal_form","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : IsDomain R\ninst✝⁴ : IsPrincipalIdealRing R\nS : Type u_4\ninst✝³ : CommRing S\ninst✝² : IsDomain S\ninst✝¹ : Algebra R S\ninst✝ : Finite ι\nb : Basis ι R S\nI : Ideal S\nhI : Ne I Bot.bot\n⊢ Exists fun b' => Exists fun a => Exists fun ab' => ∀ (i : ι), Eq (↑(ab' i)) (HSMul.hSMul (a i) (b' i))","decl":"/-- If `S` a finite-dimensional ring extension of a PID `R` which is free as an `R`-module,\nthen any nonzero `S`-ideal `I` is free as an `R`-submodule of `S`, and we can\nfind a basis for `S` and `I` such that the inclusion map is a square diagonal\nmatrix.\n\nSee also `Ideal.smithNormalForm` for a version of this theorem that returns\na `Basis.SmithNormalForm`.\n\nThe definitions `Ideal.ringBasis`, `Ideal.selfBasis`, `Ideal.smithCoeffs` are (noncomputable)\nchoices of values for this existential quantifier.\n-/\ntheorem Ideal.exists_smith_normal_form (b : Basis ι R S) (I : Ideal S) (hI : I ≠ ⊥) :\n    ∃ (b' : Basis ι R S) (a : ι → R) (ab' : Basis ι R I), ∀ i, (ab' i : S) = a i • b' i := by\n  cases nonempty_fintype ι\n  let ⟨bS, bI, f, a, snf⟩ := I.smithNormalForm b hI\n  let e : Fin (Fintype.card ι) ≃ ι :=\n    Equiv.ofBijective f\n      ((Fintype.bijective_iff_injective_and_card f).mpr ⟨f.injective, Fintype.card_fin _⟩)\n  have fe : ∀ i, f (e.symm i) = i := e.apply_symm_apply\n  exact\n    ⟨bS, a ∘ e.symm, (bI.reindex e).map ((restrictScalarsEquiv R S _ _).restrictScalars R),\n      fun i ↦ by\n        simp only [snf, fe, Basis.map_apply, LinearEquiv.restrictScalars_apply R,\n          Submodule.restrictScalarsEquiv_apply, Basis.coe_reindex, (· ∘ ·)]⟩\n\n"}
{"name":"Ideal.selfBasis_def","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : IsDomain R\ninst✝⁴ : IsPrincipalIdealRing R\nS : Type u_4\ninst✝³ : CommRing S\ninst✝² : IsDomain S\ninst✝¹ : Algebra R S\ninst✝ : Finite ι\nb : Basis ι R S\nI : Ideal S\nhI : Ne I Bot.bot\ni : ι\n⊢ Eq (↑((Ideal.selfBasis b I hI) i)) (HSMul.hSMul (Ideal.smithCoeffs b I hI i) ((Ideal.ringBasis b I hI) i))","decl":"/-- If `S` a finite-dimensional ring extension of a PID `R` which is free as an `R`-module,\nthen any nonzero `S`-ideal `I` is free as an `R`-submodule of `S`, and we can\nfind a basis for `S` and `I` such that the inclusion map is a square diagonal\nmatrix.\n-/\n@[simp]\ntheorem Ideal.selfBasis_def (b : Basis ι R S) (I : Ideal S) (hI : I ≠ ⊥) :\n    ∀ i, (Ideal.selfBasis b I hI i : S) = Ideal.smithCoeffs b I hI i • Ideal.ringBasis b I hI i :=\n  (Ideal.exists_smith_normal_form b I hI).choose_spec.choose_spec.choose_spec\n\n"}
{"name":"Ideal.smithCoeffs_ne_zero","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁶ : CommRing R\ninst✝⁵ : IsDomain R\ninst✝⁴ : IsPrincipalIdealRing R\nS : Type u_4\ninst✝³ : CommRing S\ninst✝² : IsDomain S\ninst✝¹ : Algebra R S\ninst✝ : Finite ι\nb : Basis ι R S\nI : Ideal S\nhI : Ne I Bot.bot\ni : ι\n⊢ Ne (Ideal.smithCoeffs b I hI i) 0","decl":"@[simp]\ntheorem Ideal.smithCoeffs_ne_zero (b : Basis ι R S) (I : Ideal S) (hI : I ≠ ⊥) (i) :\n    Ideal.smithCoeffs b I hI i ≠ 0 := by\n  intro hi\n  apply Basis.ne_zero (Ideal.selfBasis b I hI) i\n  refine Subtype.coe_injective ?_\n  simp [hi]\n\n-- Porting note: can be inferred in Lean 4 so no longer necessary\n\n"}
{"name":"LinearIndependent.restrict_scalars_algebras","module":"Mathlib.LinearAlgebra.FreeModule.PID","initialProofState":"R : Type u_1\nS : Type u_2\nM : Type u_3\nι : Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Algebra R S\ninst✝² : Module R M\ninst✝¹ : Module S M\ninst✝ : IsScalarTower R S M\nhinj : Function.Injective ⇑(algebraMap R S)\nv : ι → M\nli : LinearIndependent S v\n⊢ LinearIndependent R v","decl":"/-- A set of linearly independent vectors in a module `M` over a semiring `S` is also linearly\nindependent over a subring `R` of `K`. -/\ntheorem LinearIndependent.restrict_scalars_algebras {R S M ι : Type*} [CommSemiring R] [Semiring S]\n    [AddCommMonoid M] [Algebra R S] [Module R M] [Module S M] [IsScalarTower R S M]\n    (hinj : Function.Injective (algebraMap R S)) {v : ι → M} (li : LinearIndependent S v) :\n    LinearIndependent R v :=\n  LinearIndependent.restrict_scalars (by rwa [Algebra.algebraMap_eq_smul_one'] at hinj) li\n"}
