{"name":"isConformalMap_iff","module":"Mathlib.Analysis.InnerProductSpace.ConformalLinearMap","initialProofState":"E : Type u_1\nF : Type u_2\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : InnerProductSpace Real E\ninst✝ : InnerProductSpace Real F\nf : ContinuousLinearMap (RingHom.id Real) E F\n⊢ Iff (IsConformalMap f) (Exists fun c => And (LT.lt 0 c) (∀ (u v : E), Eq (Inner.inner (f u) (f v)) (HMul.hMul c (Inner.inner u v))))","decl":"/-- A map between two inner product spaces is a conformal map if and only if it preserves inner\nproducts up to a scalar factor, i.e., there exists a positive `c : ℝ` such that\n`⟪f u, f v⟫ = c * ⟪u, v⟫` for all `u`, `v`. -/\ntheorem isConformalMap_iff (f : E →L[ℝ] F) :\n    IsConformalMap f ↔ ∃ c : ℝ, 0 < c ∧ ∀ u v : E, ⟪f u, f v⟫ = c * ⟪u, v⟫ := by\n  constructor\n  · rintro ⟨c₁, hc₁, li, rfl⟩\n    refine ⟨c₁ * c₁, mul_self_pos.2 hc₁, fun u v => ?_⟩\n    simp only [real_inner_smul_left, real_inner_smul_right, mul_assoc, coe_smul',\n      coe_toContinuousLinearMap, Pi.smul_apply, inner_map_map]\n  · rintro ⟨c₁, hc₁, huv⟩\n    obtain ⟨c, hc, rfl⟩ : ∃ c : ℝ, 0 < c ∧ c₁ = c * c :=\n      ⟨√c₁, Real.sqrt_pos.2 hc₁, (Real.mul_self_sqrt hc₁.le).symm⟩\n    refine ⟨c, hc.ne', (c⁻¹ • f : E →ₗ[ℝ] F).isometryOfInner fun u v => ?_, ?_⟩\n    · simp only [real_inner_smul_left, real_inner_smul_right, huv, mul_assoc, coe_smul,\n        inv_mul_cancel_left₀ hc.ne', LinearMap.smul_apply, ContinuousLinearMap.coe_coe]\n    · ext1 x\n      exact (smul_inv_smul₀ hc.ne' (f x)).symm\n"}
