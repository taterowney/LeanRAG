{"name":"TopCat.Presheaf.SheafConditionEqualizerProducts.res_π_apply","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\ni : ι\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (F.obj { unop := iSup U })\n⊢ Eq ((CategoryTheory.Limits.limit.π (CategoryTheory.Discrete.functor fun i => F.obj { unop := U i }) { as := i }) ((TopCat.Presheaf.SheafConditionEqualizerProducts.res F U) x)) ((F.map (TopologicalSpace.Opens.leSupr U i).op) x)","decl":"@[simp, elementwise]\ntheorem res_π (i : ι) : res F U ≫ limit.π _ ⟨i⟩ = F.map (Opens.leSupr U i).op := by\n  rw [res, limit.lift_π, Fan.mk_π_app]\n\n"}
{"name":"TopCat.Presheaf.SheafConditionEqualizerProducts.res_π","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\ni : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.SheafConditionEqualizerProducts.res F U) (CategoryTheory.Limits.limit.π (CategoryTheory.Discrete.functor fun i => F.obj { unop := U i }) { as := i })) (F.map (TopologicalSpace.Opens.leSupr U i).op)","decl":"@[simp, elementwise]\ntheorem res_π (i : ι) : res F U ≫ limit.π _ ⟨i⟩ = F.map (Opens.leSupr U i).op := by\n  rw [res, limit.lift_π, Fan.mk_π_app]\n\n"}
{"name":"TopCat.Presheaf.SheafConditionEqualizerProducts.w","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\n⊢ Eq (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.SheafConditionEqualizerProducts.res F U) (TopCat.Presheaf.SheafConditionEqualizerProducts.leftRes F U)) (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.SheafConditionEqualizerProducts.res F U) (TopCat.Presheaf.SheafConditionEqualizerProducts.rightRes F U))","decl":"@[elementwise]\ntheorem w : res F U ≫ leftRes F U = res F U ≫ rightRes F U := by\n  dsimp [res, leftRes, rightRes]\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n  refine limit.hom_ext (fun _ => ?_)\n  simp only [limit.lift_π, limit.lift_π_assoc, Fan.mk_π_app, Category.assoc]\n  rw [← F.map_comp]\n  rw [← F.map_comp]\n  congr 1\n\n"}
{"name":"TopCat.Presheaf.SheafConditionEqualizerProducts.w_apply","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (F.obj { unop := iSup U })\n⊢ Eq ((TopCat.Presheaf.SheafConditionEqualizerProducts.leftRes F U) ((TopCat.Presheaf.SheafConditionEqualizerProducts.res F U) x)) ((TopCat.Presheaf.SheafConditionEqualizerProducts.rightRes F U) ((TopCat.Presheaf.SheafConditionEqualizerProducts.res F U) x))","decl":"@[elementwise]\ntheorem w : res F U ≫ leftRes F U = res F U ≫ rightRes F U := by\n  dsimp [res, leftRes, rightRes]\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n  refine limit.hom_ext (fun _ => ?_)\n  simp only [limit.lift_π, limit.lift_π_assoc, Fan.mk_π_app, Category.assoc]\n  rw [← F.map_comp]\n  rw [← F.map_comp]\n  congr 1\n\n"}
{"name":"TopCat.Presheaf.SheafConditionEqualizerProducts.fork_pt","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\n⊢ Eq (TopCat.Presheaf.SheafConditionEqualizerProducts.fork F U).pt (F.obj { unop := iSup U })","decl":"@[simp]\ntheorem fork_pt : (fork F U).pt = F.obj (op (iSup U)) :=\n  rfl\n\n"}
{"name":"TopCat.Presheaf.SheafConditionEqualizerProducts.fork_ι","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\n⊢ Eq (TopCat.Presheaf.SheafConditionEqualizerProducts.fork F U).ι (TopCat.Presheaf.SheafConditionEqualizerProducts.res F U)","decl":"@[simp]\ntheorem fork_ι : (fork F U).ι = res F U :=\n  rfl\n\n"}
{"name":"TopCat.Presheaf.SheafConditionEqualizerProducts.fork_π_app_walkingParallelPair_zero","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\n⊢ Eq ((TopCat.Presheaf.SheafConditionEqualizerProducts.fork F U).π.app CategoryTheory.Limits.WalkingParallelPair.zero) (TopCat.Presheaf.SheafConditionEqualizerProducts.res F U)","decl":"@[simp]\ntheorem fork_π_app_walkingParallelPair_zero : (fork F U).π.app WalkingParallelPair.zero = res F U :=\n  rfl\n\n-- Porting note: Shortcut simplifier\n"}
{"name":"TopCat.Presheaf.SheafConditionEqualizerProducts.fork_π_app_walkingParallelPair_one","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\n⊢ Eq ((TopCat.Presheaf.SheafConditionEqualizerProducts.fork F U).π.app CategoryTheory.Limits.WalkingParallelPair.one) (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.SheafConditionEqualizerProducts.res F U) (TopCat.Presheaf.SheafConditionEqualizerProducts.leftRes F U))","decl":"@[simp (high)]\ntheorem fork_π_app_walkingParallelPair_one :\n    (fork F U).π.app WalkingParallelPair.one = res F U ≫ leftRes F U :=\n  rfl\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctorObj_pt","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\nc : CategoryTheory.Limits.Cone ((CategoryTheory.Pairwise.diagram U).op.comp F)\n⊢ Eq (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctorObj F U c).pt c.pt","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps]\ndef coneEquivFunctorObj (c : Cone ((diagram U).op ⋙ F)) :\n    Cone (SheafConditionEqualizerProducts.diagram F U) where\n  pt := c.pt\n  π :=\n    { app := fun Z =>\n        WalkingParallelPair.casesOn Z (Pi.lift fun i : ι => c.π.app (op (single i)))\n          (Pi.lift fun b : ι × ι => c.π.app (op (pair b.1 b.2)))\n      naturality := fun Y Z f => by\n        cases Y <;> cases Z <;> cases f\n        · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n          refine limit.hom_ext fun i => ?_\n          dsimp\n          simp only [limit.lift_π, Category.id_comp, Fan.mk_π_app, CategoryTheory.Functor.map_id,\n            Category.assoc]\n          dsimp\n          simp only [limit.lift_π, Category.id_comp, Fan.mk_π_app]\n        · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n          refine limit.hom_ext fun ⟨i, j⟩ => ?_\n          dsimp [SheafConditionEqualizerProducts.leftRes]\n          simp only [limit.lift_π, limit.lift_π_assoc, Category.id_comp, Fan.mk_π_app,\n            Category.assoc]\n          have h := c.π.naturality (Quiver.Hom.op (Hom.left i j))\n          dsimp at h\n          simpa using h\n        · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n          refine limit.hom_ext fun ⟨i, j⟩ => ?_\n          dsimp [SheafConditionEqualizerProducts.rightRes]\n          simp only [limit.lift_π, limit.lift_π_assoc, Category.id_comp, Fan.mk_π_app,\n            Category.assoc]\n          have h := c.π.naturality (Quiver.Hom.op (Hom.right i j))\n          dsimp at h\n          simpa using h\n        · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n          refine limit.hom_ext fun i => ?_\n          dsimp\n          simp only [limit.lift_π, Category.id_comp, Fan.mk_π_app, CategoryTheory.Functor.map_id,\n            Category.assoc]\n          dsimp\n          simp only [limit.lift_π, Category.id_comp, Fan.mk_π_app] }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctorObj_π_app","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\nc : CategoryTheory.Limits.Cone ((CategoryTheory.Pairwise.diagram U).op.comp F)\nZ : CategoryTheory.Limits.WalkingParallelPair\n⊢ Eq ((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctorObj F U c).π.app Z) (CategoryTheory.Limits.WalkingParallelPair.casesOn Z (CategoryTheory.Limits.Pi.lift fun i => c.π.app { unop := CategoryTheory.Pairwise.single i }) (CategoryTheory.Limits.Pi.lift fun b => c.π.app { unop := CategoryTheory.Pairwise.pair b.1 b.2 }))","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps]\ndef coneEquivFunctorObj (c : Cone ((diagram U).op ⋙ F)) :\n    Cone (SheafConditionEqualizerProducts.diagram F U) where\n  pt := c.pt\n  π :=\n    { app := fun Z =>\n        WalkingParallelPair.casesOn Z (Pi.lift fun i : ι => c.π.app (op (single i)))\n          (Pi.lift fun b : ι × ι => c.π.app (op (pair b.1 b.2)))\n      naturality := fun Y Z f => by\n        cases Y <;> cases Z <;> cases f\n        · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n          refine limit.hom_ext fun i => ?_\n          dsimp\n          simp only [limit.lift_π, Category.id_comp, Fan.mk_π_app, CategoryTheory.Functor.map_id,\n            Category.assoc]\n          dsimp\n          simp only [limit.lift_π, Category.id_comp, Fan.mk_π_app]\n        · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n          refine limit.hom_ext fun ⟨i, j⟩ => ?_\n          dsimp [SheafConditionEqualizerProducts.leftRes]\n          simp only [limit.lift_π, limit.lift_π_assoc, Category.id_comp, Fan.mk_π_app,\n            Category.assoc]\n          have h := c.π.naturality (Quiver.Hom.op (Hom.left i j))\n          dsimp at h\n          simpa using h\n        · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n          refine limit.hom_ext fun ⟨i, j⟩ => ?_\n          dsimp [SheafConditionEqualizerProducts.rightRes]\n          simp only [limit.lift_π, limit.lift_π_assoc, Category.id_comp, Fan.mk_π_app,\n            Category.assoc]\n          have h := c.π.naturality (Quiver.Hom.op (Hom.right i j))\n          dsimp at h\n          simpa using h\n        · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n          refine limit.hom_ext fun i => ?_\n          dsimp\n          simp only [limit.lift_π, Category.id_comp, Fan.mk_π_app, CategoryTheory.Functor.map_id,\n            Category.assoc]\n          dsimp\n          simp only [limit.lift_π, Category.id_comp, Fan.mk_π_app] }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctor_obj_π_app","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\nc : CategoryTheory.Limits.Cone ((CategoryTheory.Pairwise.diagram U).op.comp F)\nZ : CategoryTheory.Limits.WalkingParallelPair\n⊢ Eq (((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctor F U).obj c).π.app Z) (CategoryTheory.Limits.WalkingParallelPair.rec (CategoryTheory.Limits.Pi.lift fun i => c.π.app { unop := CategoryTheory.Pairwise.single i }) (CategoryTheory.Limits.Pi.lift fun b => c.π.app { unop := CategoryTheory.Pairwise.pair b.1 b.2 }) Z)","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps!]\ndef coneEquivFunctor :\n    Limits.Cone ((diagram U).op ⋙ F) ⥤\n      Limits.Cone (SheafConditionEqualizerProducts.diagram F U) where\n  obj c := coneEquivFunctorObj F U c\n  map {c c'} f :=\n    { hom := f.hom\n      w := fun j => by\n        cases j <;>\n          · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n            refine limit.hom_ext fun i => ?_\n            simp only [Limits.Fan.mk_π_app, Limits.ConeMorphism.w, Limits.limit.lift_π,\n              Category.assoc, coneEquivFunctorObj_π_app] }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctor_map_hom","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\nc c' : CategoryTheory.Limits.Cone ((CategoryTheory.Pairwise.diagram U).op.comp F)\nf : Quiver.Hom c c'\n⊢ Eq ((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctor F U).map f).hom f.hom","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps!]\ndef coneEquivFunctor :\n    Limits.Cone ((diagram U).op ⋙ F) ⥤\n      Limits.Cone (SheafConditionEqualizerProducts.diagram F U) where\n  obj c := coneEquivFunctorObj F U c\n  map {c c'} f :=\n    { hom := f.hom\n      w := fun j => by\n        cases j <;>\n          · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n            refine limit.hom_ext fun i => ?_\n            simp only [Limits.Fan.mk_π_app, Limits.ConeMorphism.w, Limits.limit.lift_π,\n              Category.assoc, coneEquivFunctorObj_π_app] }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctor_obj_pt","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\nc : CategoryTheory.Limits.Cone ((CategoryTheory.Pairwise.diagram U).op.comp F)\n⊢ Eq ((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctor F U).obj c).pt c.pt","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps!]\ndef coneEquivFunctor :\n    Limits.Cone ((diagram U).op ⋙ F) ⥤\n      Limits.Cone (SheafConditionEqualizerProducts.diagram F U) where\n  obj c := coneEquivFunctorObj F U c\n  map {c c'} f :=\n    { hom := f.hom\n      w := fun j => by\n        cases j <;>\n          · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n            refine limit.hom_ext fun i => ?_\n            simp only [Limits.Fan.mk_π_app, Limits.ConeMorphism.w, Limits.limit.lift_π,\n              Category.assoc, coneEquivFunctorObj_π_app] }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverseObj_pt","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\nc : CategoryTheory.Limits.Cone (TopCat.Presheaf.SheafConditionEqualizerProducts.diagram F U)\n⊢ Eq (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverseObj F U c).pt c.pt","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps]\ndef coneEquivInverseObj (c : Limits.Cone (SheafConditionEqualizerProducts.diagram F U)) :\n    Limits.Cone ((diagram U).op ⋙ F) where\n  pt := c.pt\n  π :=\n    { app := by\n        intro x\n        induction x using Opposite.rec' with | h x => ?_\n        rcases x with (⟨i⟩ | ⟨i, j⟩)\n        · exact c.π.app WalkingParallelPair.zero ≫ Pi.π _ i\n        · exact c.π.app WalkingParallelPair.one ≫ Pi.π _ (i, j)\n      naturality := by\n        intro x y f\n        induction x using Opposite.rec' with | h x => ?_\n        induction y using Opposite.rec' with | h y => ?_\n        have ef : f = f.unop.op := rfl\n        revert ef\n        generalize f.unop = f'\n        rintro rfl\n        rcases x with (⟨i⟩ | ⟨⟩) <;> rcases y with (⟨⟩ | ⟨j, j⟩) <;> rcases f' with ⟨⟩\n        · dsimp\n          rw [F.map_id]\n          simp\n        · dsimp\n          simp only [Category.id_comp, Category.assoc]\n          have h := c.π.naturality WalkingParallelPairHom.left\n          dsimp [SheafConditionEqualizerProducts.leftRes] at h\n          simp only [Category.id_comp] at h\n          have h' := h =≫ Pi.π _ (i, j)\n          rw [h']\n          simp only [Category.assoc, limit.lift_π, Fan.mk_π_app]\n          rfl\n        · dsimp\n          simp only [Category.id_comp, Category.assoc]\n          have h := c.π.naturality WalkingParallelPairHom.right\n          dsimp [SheafConditionEqualizerProducts.rightRes] at h\n          simp only [Category.id_comp] at h\n          have h' := h =≫ Pi.π _ (j, i)\n          rw [h']\n          simp\n          rfl\n        · dsimp\n          rw [F.map_id]\n          simp }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverseObj_π_app","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\nc : CategoryTheory.Limits.Cone (TopCat.Presheaf.SheafConditionEqualizerProducts.diagram F U)\nx : Opposite (CategoryTheory.Pairwise ι)\n⊢ Eq ((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverseObj F U c).π.app x) (Opposite.rec' (fun x => CategoryTheory.Pairwise.casesOn x (fun i => CategoryTheory.CategoryStruct.comp (c.π.app CategoryTheory.Limits.WalkingParallelPair.zero) (CategoryTheory.Limits.Pi.π (fun i => F.obj { unop := U i }) i)) fun i j => CategoryTheory.CategoryStruct.comp (c.π.app CategoryTheory.Limits.WalkingParallelPair.one) (CategoryTheory.Limits.Pi.π (fun p => F.obj { unop := Min.min (U p.1) (U p.2) }) { fst := i, snd := j })) x)","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps]\ndef coneEquivInverseObj (c : Limits.Cone (SheafConditionEqualizerProducts.diagram F U)) :\n    Limits.Cone ((diagram U).op ⋙ F) where\n  pt := c.pt\n  π :=\n    { app := by\n        intro x\n        induction x using Opposite.rec' with | h x => ?_\n        rcases x with (⟨i⟩ | ⟨i, j⟩)\n        · exact c.π.app WalkingParallelPair.zero ≫ Pi.π _ i\n        · exact c.π.app WalkingParallelPair.one ≫ Pi.π _ (i, j)\n      naturality := by\n        intro x y f\n        induction x using Opposite.rec' with | h x => ?_\n        induction y using Opposite.rec' with | h y => ?_\n        have ef : f = f.unop.op := rfl\n        revert ef\n        generalize f.unop = f'\n        rintro rfl\n        rcases x with (⟨i⟩ | ⟨⟩) <;> rcases y with (⟨⟩ | ⟨j, j⟩) <;> rcases f' with ⟨⟩\n        · dsimp\n          rw [F.map_id]\n          simp\n        · dsimp\n          simp only [Category.id_comp, Category.assoc]\n          have h := c.π.naturality WalkingParallelPairHom.left\n          dsimp [SheafConditionEqualizerProducts.leftRes] at h\n          simp only [Category.id_comp] at h\n          have h' := h =≫ Pi.π _ (i, j)\n          rw [h']\n          simp only [Category.assoc, limit.lift_π, Fan.mk_π_app]\n          rfl\n        · dsimp\n          simp only [Category.id_comp, Category.assoc]\n          have h := c.π.naturality WalkingParallelPairHom.right\n          dsimp [SheafConditionEqualizerProducts.rightRes] at h\n          simp only [Category.id_comp] at h\n          have h' := h =≫ Pi.π _ (j, i)\n          rw [h']\n          simp\n          rfl\n        · dsimp\n          rw [F.map_id]\n          simp }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverse_obj_pt","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\nc : CategoryTheory.Limits.Cone (TopCat.Presheaf.SheafConditionEqualizerProducts.diagram F U)\n⊢ Eq ((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverse F U).obj c).pt c.pt","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps!]\ndef coneEquivInverse :\n    Limits.Cone (SheafConditionEqualizerProducts.diagram F U) ⥤\n      Limits.Cone ((diagram U).op ⋙ F) where\n  obj c := coneEquivInverseObj F U c\n  map {c c'} f :=\n    { hom := f.hom\n      w := by\n        intro x\n        induction x using Opposite.rec' with | h x => ?_\n        rcases x with (⟨i⟩ | ⟨i, j⟩)\n        · dsimp\n          dsimp only [Fork.ι]\n          rw [← f.w WalkingParallelPair.zero, Category.assoc]\n        · dsimp\n          rw [← f.w WalkingParallelPair.one, Category.assoc] }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverse_map_hom","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\nc c' : CategoryTheory.Limits.Cone (TopCat.Presheaf.SheafConditionEqualizerProducts.diagram F U)\nf : Quiver.Hom c c'\n⊢ Eq ((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverse F U).map f).hom f.hom","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps!]\ndef coneEquivInverse :\n    Limits.Cone (SheafConditionEqualizerProducts.diagram F U) ⥤\n      Limits.Cone ((diagram U).op ⋙ F) where\n  obj c := coneEquivInverseObj F U c\n  map {c c'} f :=\n    { hom := f.hom\n      w := by\n        intro x\n        induction x using Opposite.rec' with | h x => ?_\n        rcases x with (⟨i⟩ | ⟨i, j⟩)\n        · dsimp\n          dsimp only [Fork.ι]\n          rw [← f.w WalkingParallelPair.zero, Category.assoc]\n        · dsimp\n          rw [← f.w WalkingParallelPair.one, Category.assoc] }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverse_obj_π_app","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\nc : CategoryTheory.Limits.Cone (TopCat.Presheaf.SheafConditionEqualizerProducts.diagram F U)\nx : Opposite (CategoryTheory.Pairwise ι)\n⊢ Eq (((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverse F U).obj c).π.app x) (CategoryTheory.Pairwise.rec (fun a => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.ι c) (CategoryTheory.Limits.Pi.π (fun i => F.obj { unop := U i }) a)) (fun a a_1 => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.ι c) (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.SheafConditionEqualizerProducts.leftRes F U) (CategoryTheory.Limits.Pi.π (fun p => F.obj { unop := Min.min (U p.1) (U p.2) }) { fst := a, snd := a_1 }))) (Opposite.unop x))","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps!]\ndef coneEquivInverse :\n    Limits.Cone (SheafConditionEqualizerProducts.diagram F U) ⥤\n      Limits.Cone ((diagram U).op ⋙ F) where\n  obj c := coneEquivInverseObj F U c\n  map {c c'} f :=\n    { hom := f.hom\n      w := by\n        intro x\n        induction x using Opposite.rec' with | h x => ?_\n        rcases x with (⟨i⟩ | ⟨i, j⟩)\n        · dsimp\n          dsimp only [Fork.ι]\n          rw [← f.w WalkingParallelPair.zero, Category.assoc]\n        · dsimp\n          rw [← f.w WalkingParallelPair.one, Category.assoc] }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivUnitIsoApp_inv_hom","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\nc : CategoryTheory.Limits.Cone ((CategoryTheory.Pairwise.diagram U).op.comp F)\n⊢ Eq (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivUnitIsoApp F U c).inv.hom (CategoryTheory.CategoryStruct.id (((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctor F U).comp (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverse F U)).obj c).pt)","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps]\ndef coneEquivUnitIsoApp (c : Cone ((diagram U).op ⋙ F)) :\n    (𝟭 (Cone ((diagram U).op ⋙ F))).obj c ≅\n      (coneEquivFunctor F U ⋙ coneEquivInverse F U).obj c where\n  hom :=\n    { hom := 𝟙 _\n      w := fun j => by\n        induction j using Opposite.rec' with | h j => ?_\n        rcases j with ⟨⟩ <;>\n        · dsimp [coneEquivInverse]\n          simp only [Limits.Fan.mk_π_app, Category.id_comp, Limits.limit.lift_π] }\n  inv :=\n    { hom := 𝟙 _\n      w := fun j => by\n        induction j using Opposite.rec' with | h j => ?_\n        rcases j with ⟨⟩ <;>\n        · dsimp [coneEquivInverse]\n          simp only [Limits.Fan.mk_π_app, Category.id_comp, Limits.limit.lift_π] }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivUnitIsoApp_hom_hom","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\nc : CategoryTheory.Limits.Cone ((CategoryTheory.Pairwise.diagram U).op.comp F)\n⊢ Eq (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivUnitIsoApp F U c).hom.hom (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cone ((CategoryTheory.Pairwise.diagram U).op.comp F))).obj c).pt)","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps]\ndef coneEquivUnitIsoApp (c : Cone ((diagram U).op ⋙ F)) :\n    (𝟭 (Cone ((diagram U).op ⋙ F))).obj c ≅\n      (coneEquivFunctor F U ⋙ coneEquivInverse F U).obj c where\n  hom :=\n    { hom := 𝟙 _\n      w := fun j => by\n        induction j using Opposite.rec' with | h j => ?_\n        rcases j with ⟨⟩ <;>\n        · dsimp [coneEquivInverse]\n          simp only [Limits.Fan.mk_π_app, Category.id_comp, Limits.limit.lift_π] }\n  inv :=\n    { hom := 𝟙 _\n      w := fun j => by\n        induction j using Opposite.rec' with | h j => ?_\n        rcases j with ⟨⟩ <;>\n        · dsimp [coneEquivInverse]\n          simp only [Limits.Fan.mk_π_app, Category.id_comp, Limits.limit.lift_π] }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivUnitIso_hom_app_hom","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX✝ : TopCat\nF : TopCat.Presheaf C X✝\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X✝\nX : CategoryTheory.Limits.Cone ((CategoryTheory.Pairwise.diagram U).op.comp F)\n⊢ Eq ((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivUnitIso F U).hom.app X).hom (CategoryTheory.CategoryStruct.id X.pt)","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps!]\ndef coneEquivUnitIso :\n    𝟭 (Limits.Cone ((diagram U).op ⋙ F)) ≅ coneEquivFunctor F U ⋙ coneEquivInverse F U :=\n  NatIso.ofComponents (coneEquivUnitIsoApp F U)\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivUnitIso_inv_app_hom","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX✝ : TopCat\nF : TopCat.Presheaf C X✝\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X✝\nX : CategoryTheory.Limits.Cone ((CategoryTheory.Pairwise.diagram U).op.comp F)\n⊢ Eq ((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivUnitIso F U).inv.app X).hom (CategoryTheory.CategoryStruct.id X.pt)","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps!]\ndef coneEquivUnitIso :\n    𝟭 (Limits.Cone ((diagram U).op ⋙ F)) ≅ coneEquivFunctor F U ⋙ coneEquivInverse F U :=\n  NatIso.ofComponents (coneEquivUnitIsoApp F U)\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivCounitIso_inv_app_hom","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX✝ : TopCat\nF : TopCat.Presheaf C X✝\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X✝\nX : CategoryTheory.Limits.Cone (TopCat.Presheaf.SheafConditionEqualizerProducts.diagram F U)\n⊢ Eq ((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivCounitIso F U).inv.app X).hom (CategoryTheory.CategoryStruct.id X.pt)","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps!]\ndef coneEquivCounitIso :\n    coneEquivInverse F U ⋙ coneEquivFunctor F U ≅\n      𝟭 (Limits.Cone (SheafConditionEqualizerProducts.diagram F U)) :=\n  NatIso.ofComponents\n    (fun c =>\n      { hom :=\n          { hom := 𝟙 _\n            w := by\n              rintro ⟨_ | _⟩\n              · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n                refine limit.hom_ext fun ⟨j⟩ => ?_\n                dsimp [coneEquivInverse]\n                simp only [Limits.Fan.mk_π_app, Category.id_comp, Limits.limit.lift_π]\n              · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n                refine limit.hom_ext fun ⟨i, j⟩ => ?_\n                dsimp [coneEquivInverse]\n                simp only [Limits.Fan.mk_π_app, Category.id_comp, Limits.limit.lift_π] }\n        inv :=\n          { hom := 𝟙 _\n            w := by\n              rintro ⟨_ | _⟩\n              · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n                refine limit.hom_ext fun ⟨j⟩ => ?_\n                dsimp [coneEquivInverse]\n                simp only [Limits.Fan.mk_π_app, Category.id_comp, Limits.limit.lift_π]\n              · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n                refine limit.hom_ext fun ⟨i, j⟩ => ?_\n                dsimp [coneEquivInverse]\n                simp only [Limits.Fan.mk_π_app, Category.id_comp, Limits.limit.lift_π] } })\n    fun {c d} f => by\n    ext\n    dsimp\n    simp only [Category.comp_id, Category.id_comp]\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivCounitIso_hom_app_hom","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX✝ : TopCat\nF : TopCat.Presheaf C X✝\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X✝\nX : CategoryTheory.Limits.Cone (TopCat.Presheaf.SheafConditionEqualizerProducts.diagram F U)\n⊢ Eq ((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivCounitIso F U).hom.app X).hom (CategoryTheory.CategoryStruct.id X.pt)","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps!]\ndef coneEquivCounitIso :\n    coneEquivInverse F U ⋙ coneEquivFunctor F U ≅\n      𝟭 (Limits.Cone (SheafConditionEqualizerProducts.diagram F U)) :=\n  NatIso.ofComponents\n    (fun c =>\n      { hom :=\n          { hom := 𝟙 _\n            w := by\n              rintro ⟨_ | _⟩\n              · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n                refine limit.hom_ext fun ⟨j⟩ => ?_\n                dsimp [coneEquivInverse]\n                simp only [Limits.Fan.mk_π_app, Category.id_comp, Limits.limit.lift_π]\n              · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n                refine limit.hom_ext fun ⟨i, j⟩ => ?_\n                dsimp [coneEquivInverse]\n                simp only [Limits.Fan.mk_π_app, Category.id_comp, Limits.limit.lift_π] }\n        inv :=\n          { hom := 𝟙 _\n            w := by\n              rintro ⟨_ | _⟩\n              · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n                refine limit.hom_ext fun ⟨j⟩ => ?_\n                dsimp [coneEquivInverse]\n                simp only [Limits.Fan.mk_π_app, Category.id_comp, Limits.limit.lift_π]\n              · -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n                refine limit.hom_ext fun ⟨i, j⟩ => ?_\n                dsimp [coneEquivInverse]\n                simp only [Limits.Fan.mk_π_app, Category.id_comp, Limits.limit.lift_π] } })\n    fun {c d} f => by\n    ext\n    dsimp\n    simp only [Category.comp_id, Category.id_comp]\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquiv_functor","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\n⊢ Eq (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquiv F U).functor (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctor F U)","decl":"/--\nCones over `diagram U ⋙ F` are the same as a cones over the usual sheaf condition equalizer diagram.\n-/\n@[simps]\ndef coneEquiv :\n    Limits.Cone ((diagram U).op ⋙ F) ≌\n      Limits.Cone (SheafConditionEqualizerProducts.diagram F U) where\n  functor := coneEquivFunctor F U\n  inverse := coneEquivInverse F U\n  unitIso := coneEquivUnitIso F U\n  counitIso := coneEquivCounitIso F U\n\n-- Porting note: not supported in Lean 4\n-- attribute [local reducible]\n--   SheafConditionEqualizerProducts.res SheafConditionEqualizerProducts.leftRes\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquiv_unitIso","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\n⊢ Eq (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquiv F U).unitIso (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivUnitIso F U)","decl":"/--\nCones over `diagram U ⋙ F` are the same as a cones over the usual sheaf condition equalizer diagram.\n-/\n@[simps]\ndef coneEquiv :\n    Limits.Cone ((diagram U).op ⋙ F) ≌\n      Limits.Cone (SheafConditionEqualizerProducts.diagram F U) where\n  functor := coneEquivFunctor F U\n  inverse := coneEquivInverse F U\n  unitIso := coneEquivUnitIso F U\n  counitIso := coneEquivCounitIso F U\n\n-- Porting note: not supported in Lean 4\n-- attribute [local reducible]\n--   SheafConditionEqualizerProducts.res SheafConditionEqualizerProducts.leftRes\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquiv_inverse","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\n⊢ Eq (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquiv F U).inverse (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverse F U)","decl":"/--\nCones over `diagram U ⋙ F` are the same as a cones over the usual sheaf condition equalizer diagram.\n-/\n@[simps]\ndef coneEquiv :\n    Limits.Cone ((diagram U).op ⋙ F) ≌\n      Limits.Cone (SheafConditionEqualizerProducts.diagram F U) where\n  functor := coneEquivFunctor F U\n  inverse := coneEquivInverse F U\n  unitIso := coneEquivUnitIso F U\n  counitIso := coneEquivCounitIso F U\n\n-- Porting note: not supported in Lean 4\n-- attribute [local reducible]\n--   SheafConditionEqualizerProducts.res SheafConditionEqualizerProducts.leftRes\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquiv_counitIso","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nι : Type v'\nU : ι → TopologicalSpace.Opens ↑X\n⊢ Eq (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquiv F U).counitIso (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivCounitIso F U)","decl":"/--\nCones over `diagram U ⋙ F` are the same as a cones over the usual sheaf condition equalizer diagram.\n-/\n@[simps]\ndef coneEquiv :\n    Limits.Cone ((diagram U).op ⋙ F) ≌\n      Limits.Cone (SheafConditionEqualizerProducts.diagram F U) where\n  functor := coneEquivFunctor F U\n  inverse := coneEquivInverse F U\n  unitIso := coneEquivUnitIso F U\n  counitIso := coneEquivCounitIso F U\n\n-- Porting note: not supported in Lean 4\n-- attribute [local reducible]\n--   SheafConditionEqualizerProducts.res SheafConditionEqualizerProducts.leftRes\n\n"}
{"name":"TopCat.Presheaf.isSheaf_iff_isSheafEqualizerProducts","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\n⊢ Iff F.IsSheaf F.IsSheafEqualizerProducts","decl":"/-- The sheaf condition in terms of an equalizer diagram is equivalent\nto the default sheaf condition.\n-/\ntheorem isSheaf_iff_isSheafEqualizerProducts (F : Presheaf C X) :\n    F.IsSheaf ↔ F.IsSheafEqualizerProducts :=\n  (isSheaf_iff_isSheafPairwiseIntersections F).trans <|\n    Iff.intro (fun h _ U => ⟨isLimitSheafConditionForkOfIsLimitMapCone F U (h U).some⟩) fun h _ U =>\n      ⟨isLimitMapConeOfIsLimitSheafConditionFork F U (h U).some⟩\n\n"}
