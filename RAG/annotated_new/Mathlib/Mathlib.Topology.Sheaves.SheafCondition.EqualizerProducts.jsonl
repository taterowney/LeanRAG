{"name":"TopCat.Presheaf.SheafConditionEqualizerProducts.res_œÄ_apply","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\ni : Œπ\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (F.obj { unop := iSup U })\n‚ä¢ Eq ((CategoryTheory.Limits.limit.œÄ (CategoryTheory.Discrete.functor fun i => F.obj { unop := U i }) { as := i }) ((TopCat.Presheaf.SheafConditionEqualizerProducts.res F U) x)) ((F.map (TopologicalSpace.Opens.leSupr U i).op) x)","decl":"@[simp, elementwise]\ntheorem res_œÄ (i : Œπ) : res F U ‚â´ limit.œÄ _ ‚ü®i‚ü© = F.map (Opens.leSupr U i).op := by\n  rw [res, limit.lift_œÄ, Fan.mk_œÄ_app]\n\n"}
{"name":"TopCat.Presheaf.SheafConditionEqualizerProducts.res_œÄ","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\ni : Œπ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.SheafConditionEqualizerProducts.res F U) (CategoryTheory.Limits.limit.œÄ (CategoryTheory.Discrete.functor fun i => F.obj { unop := U i }) { as := i })) (F.map (TopologicalSpace.Opens.leSupr U i).op)","decl":"@[simp, elementwise]\ntheorem res_œÄ (i : Œπ) : res F U ‚â´ limit.œÄ _ ‚ü®i‚ü© = F.map (Opens.leSupr U i).op := by\n  rw [res, limit.lift_œÄ, Fan.mk_œÄ_app]\n\n"}
{"name":"TopCat.Presheaf.SheafConditionEqualizerProducts.w","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.SheafConditionEqualizerProducts.res F U) (TopCat.Presheaf.SheafConditionEqualizerProducts.leftRes F U)) (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.SheafConditionEqualizerProducts.res F U) (TopCat.Presheaf.SheafConditionEqualizerProducts.rightRes F U))","decl":"@[elementwise]\ntheorem w : res F U ‚â´ leftRes F U = res F U ‚â´ rightRes F U := by\n  dsimp [res, leftRes, rightRes]\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n  refine limit.hom_ext (fun _ => ?_)\n  simp only [limit.lift_œÄ, limit.lift_œÄ_assoc, Fan.mk_œÄ_app, Category.assoc]\n  rw [‚Üê F.map_comp]\n  rw [‚Üê F.map_comp]\n  congr 1\n\n"}
{"name":"TopCat.Presheaf.SheafConditionEqualizerProducts.w_apply","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\ninst : CategoryTheory.HasForget C\nx : (CategoryTheory.forget C).obj (F.obj { unop := iSup U })\n‚ä¢ Eq ((TopCat.Presheaf.SheafConditionEqualizerProducts.leftRes F U) ((TopCat.Presheaf.SheafConditionEqualizerProducts.res F U) x)) ((TopCat.Presheaf.SheafConditionEqualizerProducts.rightRes F U) ((TopCat.Presheaf.SheafConditionEqualizerProducts.res F U) x))","decl":"@[elementwise]\ntheorem w : res F U ‚â´ leftRes F U = res F U ‚â´ rightRes F U := by\n  dsimp [res, leftRes, rightRes]\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n  refine limit.hom_ext (fun _ => ?_)\n  simp only [limit.lift_œÄ, limit.lift_œÄ_assoc, Fan.mk_œÄ_app, Category.assoc]\n  rw [‚Üê F.map_comp]\n  rw [‚Üê F.map_comp]\n  congr 1\n\n"}
{"name":"TopCat.Presheaf.SheafConditionEqualizerProducts.fork_pt","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq (TopCat.Presheaf.SheafConditionEqualizerProducts.fork F U).pt (F.obj { unop := iSup U })","decl":"@[simp]\ntheorem fork_pt : (fork F U).pt = F.obj (op (iSup U)) :=\n  rfl\n\n"}
{"name":"TopCat.Presheaf.SheafConditionEqualizerProducts.fork_Œπ","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq (TopCat.Presheaf.SheafConditionEqualizerProducts.fork F U).Œπ (TopCat.Presheaf.SheafConditionEqualizerProducts.res F U)","decl":"@[simp]\ntheorem fork_Œπ : (fork F U).Œπ = res F U :=\n  rfl\n\n"}
{"name":"TopCat.Presheaf.SheafConditionEqualizerProducts.fork_œÄ_app_walkingParallelPair_zero","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq ((TopCat.Presheaf.SheafConditionEqualizerProducts.fork F U).œÄ.app CategoryTheory.Limits.WalkingParallelPair.zero) (TopCat.Presheaf.SheafConditionEqualizerProducts.res F U)","decl":"@[simp]\ntheorem fork_œÄ_app_walkingParallelPair_zero : (fork F U).œÄ.app WalkingParallelPair.zero = res F U :=\n  rfl\n\n-- Porting note: Shortcut simplifier\n"}
{"name":"TopCat.Presheaf.SheafConditionEqualizerProducts.fork_œÄ_app_walkingParallelPair_one","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq ((TopCat.Presheaf.SheafConditionEqualizerProducts.fork F U).œÄ.app CategoryTheory.Limits.WalkingParallelPair.one) (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.SheafConditionEqualizerProducts.res F U) (TopCat.Presheaf.SheafConditionEqualizerProducts.leftRes F U))","decl":"@[simp (high)]\ntheorem fork_œÄ_app_walkingParallelPair_one :\n    (fork F U).œÄ.app WalkingParallelPair.one = res F U ‚â´ leftRes F U :=\n  rfl\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctorObj_pt","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\nc : CategoryTheory.Limits.Cone ((CategoryTheory.Pairwise.diagram U).op.comp F)\n‚ä¢ Eq (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctorObj F U c).pt c.pt","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps]\ndef coneEquivFunctorObj (c : Cone ((diagram U).op ‚ãô F)) :\n    Cone (SheafConditionEqualizerProducts.diagram F U) where\n  pt := c.pt\n  œÄ :=\n    { app := fun Z =>\n        WalkingParallelPair.casesOn Z (Pi.lift fun i : Œπ => c.œÄ.app (op (single i)))\n          (Pi.lift fun b : Œπ √ó Œπ => c.œÄ.app (op (pair b.1 b.2)))\n      naturality := fun Y Z f => by\n        cases Y <;> cases Z <;> cases f\n        ¬∑ -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n          refine limit.hom_ext fun i => ?_\n          dsimp\n          simp only [limit.lift_œÄ, Category.id_comp, Fan.mk_œÄ_app, CategoryTheory.Functor.map_id,\n            Category.assoc]\n          dsimp\n          simp only [limit.lift_œÄ, Category.id_comp, Fan.mk_œÄ_app]\n        ¬∑ -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n          refine limit.hom_ext fun ‚ü®i, j‚ü© => ?_\n          dsimp [SheafConditionEqualizerProducts.leftRes]\n          simp only [limit.lift_œÄ, limit.lift_œÄ_assoc, Category.id_comp, Fan.mk_œÄ_app,\n            Category.assoc]\n          have h := c.œÄ.naturality (Quiver.Hom.op (Hom.left i j))\n          dsimp at h\n          simpa using h\n        ¬∑ -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n          refine limit.hom_ext fun ‚ü®i, j‚ü© => ?_\n          dsimp [SheafConditionEqualizerProducts.rightRes]\n          simp only [limit.lift_œÄ, limit.lift_œÄ_assoc, Category.id_comp, Fan.mk_œÄ_app,\n            Category.assoc]\n          have h := c.œÄ.naturality (Quiver.Hom.op (Hom.right i j))\n          dsimp at h\n          simpa using h\n        ¬∑ -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n          refine limit.hom_ext fun i => ?_\n          dsimp\n          simp only [limit.lift_œÄ, Category.id_comp, Fan.mk_œÄ_app, CategoryTheory.Functor.map_id,\n            Category.assoc]\n          dsimp\n          simp only [limit.lift_œÄ, Category.id_comp, Fan.mk_œÄ_app] }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctorObj_œÄ_app","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\nc : CategoryTheory.Limits.Cone ((CategoryTheory.Pairwise.diagram U).op.comp F)\nZ : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq ((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctorObj F U c).œÄ.app Z) (CategoryTheory.Limits.WalkingParallelPair.casesOn Z (CategoryTheory.Limits.Pi.lift fun i => c.œÄ.app { unop := CategoryTheory.Pairwise.single i }) (CategoryTheory.Limits.Pi.lift fun b => c.œÄ.app { unop := CategoryTheory.Pairwise.pair b.1 b.2 }))","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps]\ndef coneEquivFunctorObj (c : Cone ((diagram U).op ‚ãô F)) :\n    Cone (SheafConditionEqualizerProducts.diagram F U) where\n  pt := c.pt\n  œÄ :=\n    { app := fun Z =>\n        WalkingParallelPair.casesOn Z (Pi.lift fun i : Œπ => c.œÄ.app (op (single i)))\n          (Pi.lift fun b : Œπ √ó Œπ => c.œÄ.app (op (pair b.1 b.2)))\n      naturality := fun Y Z f => by\n        cases Y <;> cases Z <;> cases f\n        ¬∑ -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n          refine limit.hom_ext fun i => ?_\n          dsimp\n          simp only [limit.lift_œÄ, Category.id_comp, Fan.mk_œÄ_app, CategoryTheory.Functor.map_id,\n            Category.assoc]\n          dsimp\n          simp only [limit.lift_œÄ, Category.id_comp, Fan.mk_œÄ_app]\n        ¬∑ -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n          refine limit.hom_ext fun ‚ü®i, j‚ü© => ?_\n          dsimp [SheafConditionEqualizerProducts.leftRes]\n          simp only [limit.lift_œÄ, limit.lift_œÄ_assoc, Category.id_comp, Fan.mk_œÄ_app,\n            Category.assoc]\n          have h := c.œÄ.naturality (Quiver.Hom.op (Hom.left i j))\n          dsimp at h\n          simpa using h\n        ¬∑ -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n          refine limit.hom_ext fun ‚ü®i, j‚ü© => ?_\n          dsimp [SheafConditionEqualizerProducts.rightRes]\n          simp only [limit.lift_œÄ, limit.lift_œÄ_assoc, Category.id_comp, Fan.mk_œÄ_app,\n            Category.assoc]\n          have h := c.œÄ.naturality (Quiver.Hom.op (Hom.right i j))\n          dsimp at h\n          simpa using h\n        ¬∑ -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n          refine limit.hom_ext fun i => ?_\n          dsimp\n          simp only [limit.lift_œÄ, Category.id_comp, Fan.mk_œÄ_app, CategoryTheory.Functor.map_id,\n            Category.assoc]\n          dsimp\n          simp only [limit.lift_œÄ, Category.id_comp, Fan.mk_œÄ_app] }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctor_obj_œÄ_app","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\nc : CategoryTheory.Limits.Cone ((CategoryTheory.Pairwise.diagram U).op.comp F)\nZ : CategoryTheory.Limits.WalkingParallelPair\n‚ä¢ Eq (((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctor F U).obj c).œÄ.app Z) (CategoryTheory.Limits.WalkingParallelPair.rec (CategoryTheory.Limits.Pi.lift fun i => c.œÄ.app { unop := CategoryTheory.Pairwise.single i }) (CategoryTheory.Limits.Pi.lift fun b => c.œÄ.app { unop := CategoryTheory.Pairwise.pair b.1 b.2 }) Z)","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps!]\ndef coneEquivFunctor :\n    Limits.Cone ((diagram U).op ‚ãô F) ‚•§\n      Limits.Cone (SheafConditionEqualizerProducts.diagram F U) where\n  obj c := coneEquivFunctorObj F U c\n  map {c c'} f :=\n    { hom := f.hom\n      w := fun j => by\n        cases j <;>\n          ¬∑ -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n            refine limit.hom_ext fun i => ?_\n            simp only [Limits.Fan.mk_œÄ_app, Limits.ConeMorphism.w, Limits.limit.lift_œÄ,\n              Category.assoc, coneEquivFunctorObj_œÄ_app] }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctor_map_hom","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\nc c' : CategoryTheory.Limits.Cone ((CategoryTheory.Pairwise.diagram U).op.comp F)\nf : Quiver.Hom c c'\n‚ä¢ Eq ((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctor F U).map f).hom f.hom","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps!]\ndef coneEquivFunctor :\n    Limits.Cone ((diagram U).op ‚ãô F) ‚•§\n      Limits.Cone (SheafConditionEqualizerProducts.diagram F U) where\n  obj c := coneEquivFunctorObj F U c\n  map {c c'} f :=\n    { hom := f.hom\n      w := fun j => by\n        cases j <;>\n          ¬∑ -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n            refine limit.hom_ext fun i => ?_\n            simp only [Limits.Fan.mk_œÄ_app, Limits.ConeMorphism.w, Limits.limit.lift_œÄ,\n              Category.assoc, coneEquivFunctorObj_œÄ_app] }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctor_obj_pt","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\nc : CategoryTheory.Limits.Cone ((CategoryTheory.Pairwise.diagram U).op.comp F)\n‚ä¢ Eq ((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctor F U).obj c).pt c.pt","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps!]\ndef coneEquivFunctor :\n    Limits.Cone ((diagram U).op ‚ãô F) ‚•§\n      Limits.Cone (SheafConditionEqualizerProducts.diagram F U) where\n  obj c := coneEquivFunctorObj F U c\n  map {c c'} f :=\n    { hom := f.hom\n      w := fun j => by\n        cases j <;>\n          ¬∑ -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n            refine limit.hom_ext fun i => ?_\n            simp only [Limits.Fan.mk_œÄ_app, Limits.ConeMorphism.w, Limits.limit.lift_œÄ,\n              Category.assoc, coneEquivFunctorObj_œÄ_app] }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverseObj_pt","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\nc : CategoryTheory.Limits.Cone (TopCat.Presheaf.SheafConditionEqualizerProducts.diagram F U)\n‚ä¢ Eq (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverseObj F U c).pt c.pt","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps]\ndef coneEquivInverseObj (c : Limits.Cone (SheafConditionEqualizerProducts.diagram F U)) :\n    Limits.Cone ((diagram U).op ‚ãô F) where\n  pt := c.pt\n  œÄ :=\n    { app := by\n        intro x\n        induction x using Opposite.rec' with | h x => ?_\n        rcases x with (‚ü®i‚ü© | ‚ü®i, j‚ü©)\n        ¬∑ exact c.œÄ.app WalkingParallelPair.zero ‚â´ Pi.œÄ _ i\n        ¬∑ exact c.œÄ.app WalkingParallelPair.one ‚â´ Pi.œÄ _ (i, j)\n      naturality := by\n        intro x y f\n        induction x using Opposite.rec' with | h x => ?_\n        induction y using Opposite.rec' with | h y => ?_\n        have ef : f = f.unop.op := rfl\n        revert ef\n        generalize f.unop = f'\n        rintro rfl\n        rcases x with (‚ü®i‚ü© | ‚ü®‚ü©) <;> rcases y with (‚ü®‚ü© | ‚ü®j, j‚ü©) <;> rcases f' with ‚ü®‚ü©\n        ¬∑ dsimp\n          rw [F.map_id]\n          simp\n        ¬∑ dsimp\n          simp only [Category.id_comp, Category.assoc]\n          have h := c.œÄ.naturality WalkingParallelPairHom.left\n          dsimp [SheafConditionEqualizerProducts.leftRes] at h\n          simp only [Category.id_comp] at h\n          have h' := h =‚â´ Pi.œÄ _ (i, j)\n          rw [h']\n          simp only [Category.assoc, limit.lift_œÄ, Fan.mk_œÄ_app]\n          rfl\n        ¬∑ dsimp\n          simp only [Category.id_comp, Category.assoc]\n          have h := c.œÄ.naturality WalkingParallelPairHom.right\n          dsimp [SheafConditionEqualizerProducts.rightRes] at h\n          simp only [Category.id_comp] at h\n          have h' := h =‚â´ Pi.œÄ _ (j, i)\n          rw [h']\n          simp\n          rfl\n        ¬∑ dsimp\n          rw [F.map_id]\n          simp }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverseObj_œÄ_app","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\nc : CategoryTheory.Limits.Cone (TopCat.Presheaf.SheafConditionEqualizerProducts.diagram F U)\nx : Opposite (CategoryTheory.Pairwise Œπ)\n‚ä¢ Eq ((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverseObj F U c).œÄ.app x) (Opposite.rec' (fun x => CategoryTheory.Pairwise.casesOn x (fun i => CategoryTheory.CategoryStruct.comp (c.œÄ.app CategoryTheory.Limits.WalkingParallelPair.zero) (CategoryTheory.Limits.Pi.œÄ (fun i => F.obj { unop := U i }) i)) fun i j => CategoryTheory.CategoryStruct.comp (c.œÄ.app CategoryTheory.Limits.WalkingParallelPair.one) (CategoryTheory.Limits.Pi.œÄ (fun p => F.obj { unop := Min.min (U p.1) (U p.2) }) { fst := i, snd := j })) x)","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps]\ndef coneEquivInverseObj (c : Limits.Cone (SheafConditionEqualizerProducts.diagram F U)) :\n    Limits.Cone ((diagram U).op ‚ãô F) where\n  pt := c.pt\n  œÄ :=\n    { app := by\n        intro x\n        induction x using Opposite.rec' with | h x => ?_\n        rcases x with (‚ü®i‚ü© | ‚ü®i, j‚ü©)\n        ¬∑ exact c.œÄ.app WalkingParallelPair.zero ‚â´ Pi.œÄ _ i\n        ¬∑ exact c.œÄ.app WalkingParallelPair.one ‚â´ Pi.œÄ _ (i, j)\n      naturality := by\n        intro x y f\n        induction x using Opposite.rec' with | h x => ?_\n        induction y using Opposite.rec' with | h y => ?_\n        have ef : f = f.unop.op := rfl\n        revert ef\n        generalize f.unop = f'\n        rintro rfl\n        rcases x with (‚ü®i‚ü© | ‚ü®‚ü©) <;> rcases y with (‚ü®‚ü© | ‚ü®j, j‚ü©) <;> rcases f' with ‚ü®‚ü©\n        ¬∑ dsimp\n          rw [F.map_id]\n          simp\n        ¬∑ dsimp\n          simp only [Category.id_comp, Category.assoc]\n          have h := c.œÄ.naturality WalkingParallelPairHom.left\n          dsimp [SheafConditionEqualizerProducts.leftRes] at h\n          simp only [Category.id_comp] at h\n          have h' := h =‚â´ Pi.œÄ _ (i, j)\n          rw [h']\n          simp only [Category.assoc, limit.lift_œÄ, Fan.mk_œÄ_app]\n          rfl\n        ¬∑ dsimp\n          simp only [Category.id_comp, Category.assoc]\n          have h := c.œÄ.naturality WalkingParallelPairHom.right\n          dsimp [SheafConditionEqualizerProducts.rightRes] at h\n          simp only [Category.id_comp] at h\n          have h' := h =‚â´ Pi.œÄ _ (j, i)\n          rw [h']\n          simp\n          rfl\n        ¬∑ dsimp\n          rw [F.map_id]\n          simp }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverse_obj_pt","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\nc : CategoryTheory.Limits.Cone (TopCat.Presheaf.SheafConditionEqualizerProducts.diagram F U)\n‚ä¢ Eq ((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverse F U).obj c).pt c.pt","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps!]\ndef coneEquivInverse :\n    Limits.Cone (SheafConditionEqualizerProducts.diagram F U) ‚•§\n      Limits.Cone ((diagram U).op ‚ãô F) where\n  obj c := coneEquivInverseObj F U c\n  map {c c'} f :=\n    { hom := f.hom\n      w := by\n        intro x\n        induction x using Opposite.rec' with | h x => ?_\n        rcases x with (‚ü®i‚ü© | ‚ü®i, j‚ü©)\n        ¬∑ dsimp\n          dsimp only [Fork.Œπ]\n          rw [‚Üê f.w WalkingParallelPair.zero, Category.assoc]\n        ¬∑ dsimp\n          rw [‚Üê f.w WalkingParallelPair.one, Category.assoc] }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverse_map_hom","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\nc c' : CategoryTheory.Limits.Cone (TopCat.Presheaf.SheafConditionEqualizerProducts.diagram F U)\nf : Quiver.Hom c c'\n‚ä¢ Eq ((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverse F U).map f).hom f.hom","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps!]\ndef coneEquivInverse :\n    Limits.Cone (SheafConditionEqualizerProducts.diagram F U) ‚•§\n      Limits.Cone ((diagram U).op ‚ãô F) where\n  obj c := coneEquivInverseObj F U c\n  map {c c'} f :=\n    { hom := f.hom\n      w := by\n        intro x\n        induction x using Opposite.rec' with | h x => ?_\n        rcases x with (‚ü®i‚ü© | ‚ü®i, j‚ü©)\n        ¬∑ dsimp\n          dsimp only [Fork.Œπ]\n          rw [‚Üê f.w WalkingParallelPair.zero, Category.assoc]\n        ¬∑ dsimp\n          rw [‚Üê f.w WalkingParallelPair.one, Category.assoc] }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverse_obj_œÄ_app","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\nc : CategoryTheory.Limits.Cone (TopCat.Presheaf.SheafConditionEqualizerProducts.diagram F U)\nx : Opposite (CategoryTheory.Pairwise Œπ)\n‚ä¢ Eq (((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverse F U).obj c).œÄ.app x) (CategoryTheory.Pairwise.rec (fun a => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.Œπ c) (CategoryTheory.Limits.Pi.œÄ (fun i => F.obj { unop := U i }) a)) (fun a a_1 => CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.Œπ c) (CategoryTheory.CategoryStruct.comp (TopCat.Presheaf.SheafConditionEqualizerProducts.leftRes F U) (CategoryTheory.Limits.Pi.œÄ (fun p => F.obj { unop := Min.min (U p.1) (U p.2) }) { fst := a, snd := a_1 }))) (Opposite.unop x))","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps!]\ndef coneEquivInverse :\n    Limits.Cone (SheafConditionEqualizerProducts.diagram F U) ‚•§\n      Limits.Cone ((diagram U).op ‚ãô F) where\n  obj c := coneEquivInverseObj F U c\n  map {c c'} f :=\n    { hom := f.hom\n      w := by\n        intro x\n        induction x using Opposite.rec' with | h x => ?_\n        rcases x with (‚ü®i‚ü© | ‚ü®i, j‚ü©)\n        ¬∑ dsimp\n          dsimp only [Fork.Œπ]\n          rw [‚Üê f.w WalkingParallelPair.zero, Category.assoc]\n        ¬∑ dsimp\n          rw [‚Üê f.w WalkingParallelPair.one, Category.assoc] }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivUnitIsoApp_inv_hom","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\nc : CategoryTheory.Limits.Cone ((CategoryTheory.Pairwise.diagram U).op.comp F)\n‚ä¢ Eq (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivUnitIsoApp F U c).inv.hom (CategoryTheory.CategoryStruct.id (((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctor F U).comp (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverse F U)).obj c).pt)","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps]\ndef coneEquivUnitIsoApp (c : Cone ((diagram U).op ‚ãô F)) :\n    (ùü≠ (Cone ((diagram U).op ‚ãô F))).obj c ‚âÖ\n      (coneEquivFunctor F U ‚ãô coneEquivInverse F U).obj c where\n  hom :=\n    { hom := ùüô _\n      w := fun j => by\n        induction j using Opposite.rec' with | h j => ?_\n        rcases j with ‚ü®‚ü© <;>\n        ¬∑ dsimp [coneEquivInverse]\n          simp only [Limits.Fan.mk_œÄ_app, Category.id_comp, Limits.limit.lift_œÄ] }\n  inv :=\n    { hom := ùüô _\n      w := fun j => by\n        induction j using Opposite.rec' with | h j => ?_\n        rcases j with ‚ü®‚ü© <;>\n        ¬∑ dsimp [coneEquivInverse]\n          simp only [Limits.Fan.mk_œÄ_app, Category.id_comp, Limits.limit.lift_œÄ] }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivUnitIsoApp_hom_hom","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\nc : CategoryTheory.Limits.Cone ((CategoryTheory.Pairwise.diagram U).op.comp F)\n‚ä¢ Eq (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivUnitIsoApp F U c).hom.hom (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id (CategoryTheory.Limits.Cone ((CategoryTheory.Pairwise.diagram U).op.comp F))).obj c).pt)","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps]\ndef coneEquivUnitIsoApp (c : Cone ((diagram U).op ‚ãô F)) :\n    (ùü≠ (Cone ((diagram U).op ‚ãô F))).obj c ‚âÖ\n      (coneEquivFunctor F U ‚ãô coneEquivInverse F U).obj c where\n  hom :=\n    { hom := ùüô _\n      w := fun j => by\n        induction j using Opposite.rec' with | h j => ?_\n        rcases j with ‚ü®‚ü© <;>\n        ¬∑ dsimp [coneEquivInverse]\n          simp only [Limits.Fan.mk_œÄ_app, Category.id_comp, Limits.limit.lift_œÄ] }\n  inv :=\n    { hom := ùüô _\n      w := fun j => by\n        induction j using Opposite.rec' with | h j => ?_\n        rcases j with ‚ü®‚ü© <;>\n        ¬∑ dsimp [coneEquivInverse]\n          simp only [Limits.Fan.mk_œÄ_app, Category.id_comp, Limits.limit.lift_œÄ] }\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivUnitIso_hom_app_hom","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX‚úù : TopCat\nF : TopCat.Presheaf C X‚úù\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX‚úù\nX : CategoryTheory.Limits.Cone ((CategoryTheory.Pairwise.diagram U).op.comp F)\n‚ä¢ Eq ((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivUnitIso F U).hom.app X).hom (CategoryTheory.CategoryStruct.id X.pt)","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps!]\ndef coneEquivUnitIso :\n    ùü≠ (Limits.Cone ((diagram U).op ‚ãô F)) ‚âÖ coneEquivFunctor F U ‚ãô coneEquivInverse F U :=\n  NatIso.ofComponents (coneEquivUnitIsoApp F U)\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivUnitIso_inv_app_hom","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX‚úù : TopCat\nF : TopCat.Presheaf C X‚úù\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX‚úù\nX : CategoryTheory.Limits.Cone ((CategoryTheory.Pairwise.diagram U).op.comp F)\n‚ä¢ Eq ((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivUnitIso F U).inv.app X).hom (CategoryTheory.CategoryStruct.id X.pt)","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps!]\ndef coneEquivUnitIso :\n    ùü≠ (Limits.Cone ((diagram U).op ‚ãô F)) ‚âÖ coneEquivFunctor F U ‚ãô coneEquivInverse F U :=\n  NatIso.ofComponents (coneEquivUnitIsoApp F U)\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivCounitIso_inv_app_hom","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX‚úù : TopCat\nF : TopCat.Presheaf C X‚úù\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX‚úù\nX : CategoryTheory.Limits.Cone (TopCat.Presheaf.SheafConditionEqualizerProducts.diagram F U)\n‚ä¢ Eq ((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivCounitIso F U).inv.app X).hom (CategoryTheory.CategoryStruct.id X.pt)","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps!]\ndef coneEquivCounitIso :\n    coneEquivInverse F U ‚ãô coneEquivFunctor F U ‚âÖ\n      ùü≠ (Limits.Cone (SheafConditionEqualizerProducts.diagram F U)) :=\n  NatIso.ofComponents\n    (fun c =>\n      { hom :=\n          { hom := ùüô _\n            w := by\n              rintro ‚ü®_ | _‚ü©\n              ¬∑ -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n                refine limit.hom_ext fun ‚ü®j‚ü© => ?_\n                dsimp [coneEquivInverse]\n                simp only [Limits.Fan.mk_œÄ_app, Category.id_comp, Limits.limit.lift_œÄ]\n              ¬∑ -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n                refine limit.hom_ext fun ‚ü®i, j‚ü© => ?_\n                dsimp [coneEquivInverse]\n                simp only [Limits.Fan.mk_œÄ_app, Category.id_comp, Limits.limit.lift_œÄ] }\n        inv :=\n          { hom := ùüô _\n            w := by\n              rintro ‚ü®_ | _‚ü©\n              ¬∑ -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n                refine limit.hom_ext fun ‚ü®j‚ü© => ?_\n                dsimp [coneEquivInverse]\n                simp only [Limits.Fan.mk_œÄ_app, Category.id_comp, Limits.limit.lift_œÄ]\n              ¬∑ -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n                refine limit.hom_ext fun ‚ü®i, j‚ü© => ?_\n                dsimp [coneEquivInverse]\n                simp only [Limits.Fan.mk_œÄ_app, Category.id_comp, Limits.limit.lift_œÄ] } })\n    fun {c d} f => by\n    ext\n    dsimp\n    simp only [Category.comp_id, Category.id_comp]\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivCounitIso_hom_app_hom","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX‚úù : TopCat\nF : TopCat.Presheaf C X‚úù\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX‚úù\nX : CategoryTheory.Limits.Cone (TopCat.Presheaf.SheafConditionEqualizerProducts.diagram F U)\n‚ä¢ Eq ((TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivCounitIso F U).hom.app X).hom (CategoryTheory.CategoryStruct.id X.pt)","decl":"/-- Implementation of `SheafConditionPairwiseIntersections.coneEquiv`. -/\n@[simps!]\ndef coneEquivCounitIso :\n    coneEquivInverse F U ‚ãô coneEquivFunctor F U ‚âÖ\n      ùü≠ (Limits.Cone (SheafConditionEqualizerProducts.diagram F U)) :=\n  NatIso.ofComponents\n    (fun c =>\n      { hom :=\n          { hom := ùüô _\n            w := by\n              rintro ‚ü®_ | _‚ü©\n              ¬∑ -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n                refine limit.hom_ext fun ‚ü®j‚ü© => ?_\n                dsimp [coneEquivInverse]\n                simp only [Limits.Fan.mk_œÄ_app, Category.id_comp, Limits.limit.lift_œÄ]\n              ¬∑ -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n                refine limit.hom_ext fun ‚ü®i, j‚ü© => ?_\n                dsimp [coneEquivInverse]\n                simp only [Limits.Fan.mk_œÄ_app, Category.id_comp, Limits.limit.lift_œÄ] }\n        inv :=\n          { hom := ùüô _\n            w := by\n              rintro ‚ü®_ | _‚ü©\n              ¬∑ -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n                refine limit.hom_ext fun ‚ü®j‚ü© => ?_\n                dsimp [coneEquivInverse]\n                simp only [Limits.Fan.mk_œÄ_app, Category.id_comp, Limits.limit.lift_œÄ]\n              ¬∑ -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` can't see `limit.hom_ext` applies here:\n                refine limit.hom_ext fun ‚ü®i, j‚ü© => ?_\n                dsimp [coneEquivInverse]\n                simp only [Limits.Fan.mk_œÄ_app, Category.id_comp, Limits.limit.lift_œÄ] } })\n    fun {c d} f => by\n    ext\n    dsimp\n    simp only [Category.comp_id, Category.id_comp]\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquiv_functor","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquiv F U).functor (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivFunctor F U)","decl":"/--\nCones over `diagram U ‚ãô F` are the same as a cones over the usual sheaf condition equalizer diagram.\n-/\n@[simps]\ndef coneEquiv :\n    Limits.Cone ((diagram U).op ‚ãô F) ‚âå\n      Limits.Cone (SheafConditionEqualizerProducts.diagram F U) where\n  functor := coneEquivFunctor F U\n  inverse := coneEquivInverse F U\n  unitIso := coneEquivUnitIso F U\n  counitIso := coneEquivCounitIso F U\n\n-- Porting note: not supported in Lean 4\n-- attribute [local reducible]\n--   SheafConditionEqualizerProducts.res SheafConditionEqualizerProducts.leftRes\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquiv_unitIso","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquiv F U).unitIso (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivUnitIso F U)","decl":"/--\nCones over `diagram U ‚ãô F` are the same as a cones over the usual sheaf condition equalizer diagram.\n-/\n@[simps]\ndef coneEquiv :\n    Limits.Cone ((diagram U).op ‚ãô F) ‚âå\n      Limits.Cone (SheafConditionEqualizerProducts.diagram F U) where\n  functor := coneEquivFunctor F U\n  inverse := coneEquivInverse F U\n  unitIso := coneEquivUnitIso F U\n  counitIso := coneEquivCounitIso F U\n\n-- Porting note: not supported in Lean 4\n-- attribute [local reducible]\n--   SheafConditionEqualizerProducts.res SheafConditionEqualizerProducts.leftRes\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquiv_inverse","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquiv F U).inverse (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivInverse F U)","decl":"/--\nCones over `diagram U ‚ãô F` are the same as a cones over the usual sheaf condition equalizer diagram.\n-/\n@[simps]\ndef coneEquiv :\n    Limits.Cone ((diagram U).op ‚ãô F) ‚âå\n      Limits.Cone (SheafConditionEqualizerProducts.diagram F U) where\n  functor := coneEquivFunctor F U\n  inverse := coneEquivInverse F U\n  unitIso := coneEquivUnitIso F U\n  counitIso := coneEquivCounitIso F U\n\n-- Porting note: not supported in Lean 4\n-- attribute [local reducible]\n--   SheafConditionEqualizerProducts.res SheafConditionEqualizerProducts.leftRes\n\n"}
{"name":"TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquiv_counitIso","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\nŒπ : Type v'\nU : Œπ ‚Üí TopologicalSpace.Opens ‚ÜëX\n‚ä¢ Eq (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquiv F U).counitIso (TopCat.Presheaf.SheafConditionPairwiseIntersections.coneEquivCounitIso F U)","decl":"/--\nCones over `diagram U ‚ãô F` are the same as a cones over the usual sheaf condition equalizer diagram.\n-/\n@[simps]\ndef coneEquiv :\n    Limits.Cone ((diagram U).op ‚ãô F) ‚âå\n      Limits.Cone (SheafConditionEqualizerProducts.diagram F U) where\n  functor := coneEquivFunctor F U\n  inverse := coneEquivInverse F U\n  unitIso := coneEquivUnitIso F U\n  counitIso := coneEquivCounitIso F U\n\n-- Porting note: not supported in Lean 4\n-- attribute [local reducible]\n--   SheafConditionEqualizerProducts.res SheafConditionEqualizerProducts.leftRes\n\n"}
{"name":"TopCat.Presheaf.isSheaf_iff_isSheafEqualizerProducts","module":"Mathlib.Topology.Sheaves.SheafCondition.EqualizerProducts","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasProducts C\nX : TopCat\nF : TopCat.Presheaf C X\n‚ä¢ Iff F.IsSheaf F.IsSheafEqualizerProducts","decl":"/-- The sheaf condition in terms of an equalizer diagram is equivalent\nto the default sheaf condition.\n-/\ntheorem isSheaf_iff_isSheafEqualizerProducts (F : Presheaf C X) :\n    F.IsSheaf ‚Üî F.IsSheafEqualizerProducts :=\n  (isSheaf_iff_isSheafPairwiseIntersections F).trans <|\n    Iff.intro (fun h _ U => ‚ü®isLimitSheafConditionForkOfIsLimitMapCone F U (h U).some‚ü©) fun h _ U =>\n      ‚ü®isLimitMapConeOfIsLimitSheafConditionFork F U (h U).some‚ü©\n\n"}
