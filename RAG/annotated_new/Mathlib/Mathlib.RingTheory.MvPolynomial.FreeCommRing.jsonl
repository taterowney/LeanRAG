{"name":"FirstOrder.Ring.MvPolynomialSupportLEEquiv_symm_apply_coeff","module":"Mathlib.RingTheory.MvPolynomial.FreeCommRing","initialProofState":"ι : Type u_1\nκ : Type u_2\nR : Type u_3\ninst✝² : DecidableEq κ\ninst✝¹ : CommRing R\ninst✝ : DecidableEq R\np : ι → MvPolynomial κ R\n⊢ Eq ((FirstOrder.Ring.mvPolynomialSupportLEEquiv fun i => (p i).support).symm fun i => MvPolynomial.coeff (↑i.snd) (p i.fst)) ⟨p, ⋯⟩","decl":"@[simp]\ntheorem MvPolynomialSupportLEEquiv_symm_apply_coeff [DecidableEq κ] [CommRing R] [DecidableEq R]\n    (p : ι → MvPolynomial κ R) : (mvPolynomialSupportLEEquiv (fun i => (p i).support)).symm\n      (fun i => (p i.1).coeff i.2.1) = ⟨p, fun _ => Finset.Subset.refl _⟩ :=\n  (mvPolynomialSupportLEEquiv (R := R) (fun i : ι => (p i).support)).symm_apply_apply\n    ⟨p, fun _ => Finset.Subset.refl _⟩\n\n"}
{"name":"FirstOrder.Ring.lift_genericPolyMap","module":"Mathlib.RingTheory.MvPolynomial.FreeCommRing","initialProofState":"ι : Type u_1\nκ : Type u_2\nR : Type u_3\ninst✝² : DecidableEq κ\ninst✝¹ : CommRing R\ninst✝ : DecidableEq R\nmonoms : ι → Finset (Finsupp κ Nat)\nf : Sum (Sigma fun i => Subtype fun x => Membership.mem (monoms i) x) κ → R\ni : ι\n⊢ Eq ((FreeCommRing.lift f) (FirstOrder.Ring.genericPolyMap monoms i)) ((MvPolynomial.eval (Function.comp f Sum.inr)) (↑((FirstOrder.Ring.mvPolynomialSupportLEEquiv monoms).symm (Function.comp f Sum.inl)) i))","decl":"@[simp]\ntheorem lift_genericPolyMap [DecidableEq κ] [CommRing R]\n    [DecidableEq R] (monoms : ι → Finset (κ →₀ ℕ))\n    (f : (i : ι) × { x // x ∈ monoms i } ⊕ κ → R) (i : ι) :\n    FreeCommRing.lift f (genericPolyMap monoms i) =\n      MvPolynomial.eval (f ∘ Sum.inr)\n        (((mvPolynomialSupportLEEquiv monoms).symm\n          (f ∘ Sum.inl)).1 i) := by\n  simp only [genericPolyMap, Finsupp.prod_pow, map_sum, map_mul, lift_of, support,\n    mvPolynomialSupportLEEquiv, coeff, map_prod, Finset.sum_filter, MvPolynomial.eval_eq,\n    ne_eq, Function.comp, Equiv.coe_fn_symm_mk, Finsupp.coe_mk]\n  conv_rhs => rw [← Finset.sum_attach]\n  refine Finset.sum_congr rfl ?_\n  intros m _\n  simp only [Finsupp.prod, map_prod, map_pow, lift_of, Subtype.coe_eta, Finset.coe_mem,\n    exists_prop, true_and, dite_eq_ite, ite_true, ite_not]\n  split_ifs with h0 <;> simp_all\n\n"}
