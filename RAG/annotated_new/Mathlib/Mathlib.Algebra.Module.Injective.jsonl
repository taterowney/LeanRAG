{"name":"Module.injective_iff","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝² : Ring R\nQ : Type v\ninst✝¹ : AddCommGroup Q\ninst✝ : Module R Q\n⊢ Iff (Module.Injective R Q) (∀ ⦃X Y : Type v⦄ [inst : AddCommGroup X] [inst_1 : AddCommGroup Y] [inst_2 : Module R X] [inst_3 : Module R Y] (f : LinearMap (RingHom.id R) X Y), Function.Injective ⇑f → ∀ (g : LinearMap (RingHom.id R) X Q), Exists fun h => ∀ (x : X), Eq (h (f x)) (g x))","decl":"/--\nAn `R`-module `Q` is injective if and only if every injective `R`-linear map descends to a linear\nmap to `Q`, i.e. in the following diagram, if `f` is injective then there is an `R`-linear map\n`h : Y ⟶ Q` such that `g = h ∘ f`\n  ```\n  X --- f ---> Y\n  |\n  | g\n  v\n  Q\n  ```\n-/\n@[mk_iff] class Module.Injective : Prop where\n  out : ∀ ⦃X Y : Type v⦄ [AddCommGroup X] [AddCommGroup Y] [Module R X] [Module R Y]\n    (f : X →ₗ[R] Y) (_ : Function.Injective f) (g : X →ₗ[R] Q),\n    ∃ h : Y →ₗ[R] Q, ∀ x, h (f x) = g x\n\n"}
{"name":"Module.Injective.out","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝⁶ : Ring R\nQ : Type v\ninst✝⁵ : AddCommGroup Q\ninst✝⁴ : Module R Q\nself : Module.Injective R Q\nX Y : Type v\ninst✝³ : AddCommGroup X\ninst✝² : AddCommGroup Y\ninst✝¹ : Module R X\ninst✝ : Module R Y\nf : LinearMap (RingHom.id R) X Y\nx✝ : Function.Injective ⇑f\ng : LinearMap (RingHom.id R) X Q\n⊢ Exists fun h => ∀ (x : X), Eq (h (f x)) (g x)","decl":"/--\nAn `R`-module `Q` is injective if and only if every injective `R`-linear map descends to a linear\nmap to `Q`, i.e. in the following diagram, if `f` is injective then there is an `R`-linear map\n`h : Y ⟶ Q` such that `g = h ∘ f`\n  ```\n  X --- f ---> Y\n  |\n  | g\n  v\n  Q\n  ```\n-/\n@[mk_iff] class Module.Injective : Prop where\n  out : ∀ ⦃X Y : Type v⦄ [AddCommGroup X] [AddCommGroup Y] [Module R X] [Module R Y]\n    (f : X →ₗ[R] Y) (_ : Function.Injective f) (g : X →ₗ[R] Q),\n    ∃ h : Y →ₗ[R] Q, ∀ x, h (f x) = g x\n\n"}
{"name":"Module.Baer.of_equiv","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝⁴ : Ring R\nQ : Type v\ninst✝³ : AddCommGroup Q\ninst✝² : Module R Q\nM : Type u_1\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ne : LinearEquiv (RingHom.id R) Q M\nh : Module.Baer R Q\n⊢ Module.Baer R M","decl":"lemma of_equiv (e : Q ≃ₗ[R] M) (h : Module.Baer R Q) : Module.Baer R M := fun I g ↦\n  have ⟨g', h'⟩ := h I (e.symm ∘ₗ g)\n  ⟨e ∘ₗ g', by simpa [LinearEquiv.eq_symm_apply] using h'⟩\n\n"}
{"name":"Module.Baer.congr","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝⁴ : Ring R\nQ : Type v\ninst✝³ : AddCommGroup Q\ninst✝² : Module R Q\nM : Type u_1\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ne : LinearEquiv (RingHom.id R) Q M\n⊢ Iff (Module.Baer R Q) (Module.Baer R M)","decl":"lemma congr (e : Q ≃ₗ[R] M) : Module.Baer R Q ↔ Module.Baer R M := ⟨of_equiv e, of_equiv e.symm⟩\n\n"}
{"name":"Module.Baer.ExtensionOf.mk.sizeOf_spec","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝¹⁰ : Ring R\nQ : Type v\ninst✝⁹ : AddCommGroup Q\ninst✝⁸ : Module R Q\nM : Type u_1\nN : Type u_2\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ni : LinearMap (RingHom.id R) M N\nf : LinearMap (RingHom.id R) M Q\ninst✝³ : SizeOf R\ninst✝² : SizeOf Q\ninst✝¹ : SizeOf M\ninst✝ : SizeOf N\ntoLinearPMap : LinearPMap R N Q\nle : LE.le (LinearMap.range i) toLinearPMap.domain\nis_extension : ∀ (m : M), Eq (f m) (↑toLinearPMap ⟨i m, ⋯⟩)\n⊢ Eq (SizeOf.sizeOf { toLinearPMap := toLinearPMap, le := le, is_extension := is_extension }) (HAdd.hAdd 1 (SizeOf.sizeOf toLinearPMap))","decl":"/-- If we view `M` as a submodule of `N` via the injective linear map `i : M ↪ N`, then a submodule\nbetween `M` and `N` is a submodule `N'` of `N`. To prove Baer's criterion, we need to consider\npairs of `(N', f')` such that `M ≤ N' ≤ N` and `f'` extends `f`. -/\nstructure ExtensionOf extends LinearPMap R N Q where\n  le : LinearMap.range i ≤ domain\n  is_extension : ∀ m : M, f m = toLinearPMap ⟨i m, le ⟨m, rfl⟩⟩\n\n"}
{"name":"Module.Baer.ExtensionOf.mk.injEq","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝⁶ : Ring R\nQ : Type v\ninst✝⁵ : AddCommGroup Q\ninst✝⁴ : Module R Q\nM : Type u_1\nN : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\ni : LinearMap (RingHom.id R) M N\nf : LinearMap (RingHom.id R) M Q\ntoLinearPMap✝ : LinearPMap R N Q\nle✝ : LE.le (LinearMap.range i) toLinearPMap✝.domain\nis_extension✝ : ∀ (m : M), Eq (f m) (↑toLinearPMap✝ ⟨i m, ⋯⟩)\ntoLinearPMap : LinearPMap R N Q\nle : LE.le (LinearMap.range i) toLinearPMap.domain\nis_extension : ∀ (m : M), Eq (f m) (↑toLinearPMap ⟨i m, ⋯⟩)\n⊢ Eq (Eq { toLinearPMap := toLinearPMap✝, le := le✝, is_extension := is_extension✝ } { toLinearPMap := toLinearPMap, le := le, is_extension := is_extension }) (Eq toLinearPMap✝ toLinearPMap)","decl":"/-- If we view `M` as a submodule of `N` via the injective linear map `i : M ↪ N`, then a submodule\nbetween `M` and `N` is a submodule `N'` of `N`. To prove Baer's criterion, we need to consider\npairs of `(N', f')` such that `M ≤ N' ≤ N` and `f'` extends `f`. -/\nstructure ExtensionOf extends LinearPMap R N Q where\n  le : LinearMap.range i ≤ domain\n  is_extension : ∀ m : M, f m = toLinearPMap ⟨i m, le ⟨m, rfl⟩⟩\n\n"}
{"name":"Module.Baer.ExtensionOf.is_extension","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝⁶ : Ring R\nQ : Type v\ninst✝⁵ : AddCommGroup Q\ninst✝⁴ : Module R Q\nM : Type u_1\nN : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\ni : LinearMap (RingHom.id R) M N\nf : LinearMap (RingHom.id R) M Q\nself : Module.Baer.ExtensionOf i f\nm : M\n⊢ Eq (f m) (↑self.toLinearPMap ⟨i m, ⋯⟩)","decl":"/-- If we view `M` as a submodule of `N` via the injective linear map `i : M ↪ N`, then a submodule\nbetween `M` and `N` is a submodule `N'` of `N`. To prove Baer's criterion, we need to consider\npairs of `(N', f')` such that `M ≤ N' ≤ N` and `f'` extends `f`. -/\nstructure ExtensionOf extends LinearPMap R N Q where\n  le : LinearMap.range i ≤ domain\n  is_extension : ∀ m : M, f m = toLinearPMap ⟨i m, le ⟨m, rfl⟩⟩\n\n"}
{"name":"Module.Baer.ExtensionOf.le","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝⁶ : Ring R\nQ : Type v\ninst✝⁵ : AddCommGroup Q\ninst✝⁴ : Module R Q\nM : Type u_1\nN : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\ni : LinearMap (RingHom.id R) M N\nf : LinearMap (RingHom.id R) M Q\nself : Module.Baer.ExtensionOf i f\n⊢ LE.le (LinearMap.range i) self.domain","decl":"/-- If we view `M` as a submodule of `N` via the injective linear map `i : M ↪ N`, then a submodule\nbetween `M` and `N` is a submodule `N'` of `N`. To prove Baer's criterion, we need to consider\npairs of `(N', f')` such that `M ≤ N' ≤ N` and `f'` extends `f`. -/\nstructure ExtensionOf extends LinearPMap R N Q where\n  le : LinearMap.range i ≤ domain\n  is_extension : ∀ m : M, f m = toLinearPMap ⟨i m, le ⟨m, rfl⟩⟩\n\n"}
{"name":"Module.Baer.ExtensionOf.mk.inj","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝⁶ : Ring R\nQ : Type v\ninst✝⁵ : AddCommGroup Q\ninst✝⁴ : Module R Q\nM : Type u_1\nN : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\ni : LinearMap (RingHom.id R) M N\nf : LinearMap (RingHom.id R) M Q\ntoLinearPMap✝ : LinearPMap R N Q\nle✝ : LE.le (LinearMap.range i) toLinearPMap✝.domain\nis_extension✝ : ∀ (m : M), Eq (f m) (↑toLinearPMap✝ ⟨i m, ⋯⟩)\ntoLinearPMap : LinearPMap R N Q\nle : LE.le (LinearMap.range i) toLinearPMap.domain\nis_extension : ∀ (m : M), Eq (f m) (↑toLinearPMap ⟨i m, ⋯⟩)\nx✝ : Eq { toLinearPMap := toLinearPMap✝, le := le✝, is_extension := is_extension✝ } { toLinearPMap := toLinearPMap, le := le, is_extension := is_extension }\n⊢ Eq toLinearPMap✝ toLinearPMap","decl":"/-- If we view `M` as a submodule of `N` via the injective linear map `i : M ↪ N`, then a submodule\nbetween `M` and `N` is a submodule `N'` of `N`. To prove Baer's criterion, we need to consider\npairs of `(N', f')` such that `M ≤ N' ≤ N` and `f'` extends `f`. -/\nstructure ExtensionOf extends LinearPMap R N Q where\n  le : LinearMap.range i ≤ domain\n  is_extension : ∀ m : M, f m = toLinearPMap ⟨i m, le ⟨m, rfl⟩⟩\n\n"}
{"name":"Module.Baer.ExtensionOf.ext","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝⁶ : Ring R\nQ : Type v\ninst✝⁵ : AddCommGroup Q\ninst✝⁴ : Module R Q\nM : Type u_1\nN : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\ni : LinearMap (RingHom.id R) M N\nf : LinearMap (RingHom.id R) M Q\na b : Module.Baer.ExtensionOf i f\ndomain_eq : Eq a.domain b.domain\nto_fun_eq : ∀ ⦃x : Subtype fun x => Membership.mem a.domain x⦄ ⦃y : Subtype fun x => Membership.mem b.domain x⦄, Eq ↑x ↑y → Eq (↑a.toLinearPMap x) (↑b.toLinearPMap y)\n⊢ Eq a b","decl":"@[ext (iff := false)]\ntheorem ExtensionOf.ext {a b : ExtensionOf i f} (domain_eq : a.domain = b.domain)\n    (to_fun_eq :\n      ∀ ⦃x : a.domain⦄ ⦃y : b.domain⦄, (x : N) = y → a.toLinearPMap x = b.toLinearPMap y) :\n    a = b := by\n  rcases a with ⟨a, a_le, e1⟩\n  rcases b with ⟨b, b_le, e2⟩\n  congr\n  exact LinearPMap.ext domain_eq to_fun_eq\n\n"}
{"name":"Module.Baer.ExtensionOf.ext_iff","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝⁶ : Ring R\nQ : Type v\ninst✝⁵ : AddCommGroup Q\ninst✝⁴ : Module R Q\nM : Type u_1\nN : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\ni : LinearMap (RingHom.id R) M N\nf : LinearMap (RingHom.id R) M Q\na b : Module.Baer.ExtensionOf i f\n⊢ Iff (Eq a b) (Exists fun x => ∀ ⦃x : Subtype fun x => Membership.mem a.domain x⦄ ⦃y : Subtype fun x => Membership.mem b.domain x⦄, Eq ↑x ↑y → Eq (↑a.toLinearPMap x) (↑b.toLinearPMap y))","decl":"theorem ExtensionOf.ext_iff {a b : ExtensionOf i f} :\n    a = b ↔ ∃ _ : a.domain = b.domain, ∀ ⦃x : a.domain⦄ ⦃y : b.domain⦄,\n    (x : N) = y → a.toLinearPMap x = b.toLinearPMap y :=\n  ⟨fun r => r ▸ ⟨rfl, fun _ _ h => congr_arg a.toFun <| mod_cast h⟩, fun ⟨h1, h2⟩ =>\n    ExtensionOf.ext h1 h2⟩\n\n"}
{"name":"Module.Baer.chain_linearPMap_of_chain_extensionOf","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝⁶ : Ring R\nQ : Type v\ninst✝⁵ : AddCommGroup Q\ninst✝⁴ : Module R Q\nM : Type u_1\nN : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\ni : LinearMap (RingHom.id R) M N\nf : LinearMap (RingHom.id R) M Q\nc : Set (Module.Baer.ExtensionOf i f)\nhchain : IsChain (fun x1 x2 => LE.le x1 x2) c\n⊢ IsChain (fun x1 x2 => LE.le x1 x2) (Set.image (fun x => x.toLinearPMap) c)","decl":"theorem chain_linearPMap_of_chain_extensionOf {c : Set (ExtensionOf i f)}\n    (hchain : IsChain (· ≤ ·) c) :\n    IsChain (· ≤ ·) <| (fun x : ExtensionOf i f => x.toLinearPMap) '' c := by\n  rintro _ ⟨a, a_mem, rfl⟩ _ ⟨b, b_mem, rfl⟩ neq\n  exact hchain a_mem b_mem (ne_of_apply_ne _ neq)\n\n"}
{"name":"Module.Baer.ExtensionOf.le_max","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝⁶ : Ring R\nQ : Type v\ninst✝⁵ : AddCommGroup Q\ninst✝⁴ : Module R Q\nM : Type u_1\nN : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\ni : LinearMap (RingHom.id R) M N\nf : LinearMap (RingHom.id R) M Q\nc : Set (Module.Baer.ExtensionOf i f)\nhchain : IsChain (fun x1 x2 => LE.le x1 x2) c\nhnonempty : c.Nonempty\na : Module.Baer.ExtensionOf i f\nha : Membership.mem c a\n⊢ LE.le a (Module.Baer.ExtensionOf.max hchain hnonempty)","decl":"theorem ExtensionOf.le_max {c : Set (ExtensionOf i f)} (hchain : IsChain (· ≤ ·) c)\n    (hnonempty : c.Nonempty) (a : ExtensionOf i f) (ha : a ∈ c) :\n    a ≤ ExtensionOf.max hchain hnonempty :=\n  LinearPMap.le_sSup (IsChain.directedOn <| chain_linearPMap_of_chain_extensionOf hchain) <|\n    (Set.mem_image _ _ _).mpr ⟨a, ha, rfl⟩\n\n"}
{"name":"Module.Baer.extensionOfMax_is_max","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝⁷ : Ring R\nQ : Type v\ninst✝⁶ : AddCommGroup Q\ninst✝⁵ : Module R Q\nM : Type u_1\nN : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : Module R M\ninst✝¹ : Module R N\ni : LinearMap (RingHom.id R) M N\nf : LinearMap (RingHom.id R) M Q\ninst✝ : Fact (Function.Injective ⇑i)\na : Module.Baer.ExtensionOf i f\na✝ : LE.le (Module.Baer.extensionOfMax i f) a\n⊢ Eq a (Module.Baer.extensionOfMax i f)","decl":"theorem extensionOfMax_is_max :\n    ∀ (a : ExtensionOf i f), extensionOfMax i f ≤ a → a = extensionOfMax i f :=\n  fun _ ↦ (@zorn_le_nonempty (ExtensionOf i f) _ ⟨Inhabited.default⟩ fun _ hchain hnonempty =>\n    ⟨ExtensionOf.max hchain hnonempty, ExtensionOf.le_max hchain hnonempty⟩).choose_spec.eq_of_ge\n\n-- Porting note: helper function. Lean looks for an instance of `Sup (Type u)` when the\n-- right hand side is substituted in directly\n"}
{"name":"Module.Baer.ExtensionOfMaxAdjoin.eqn","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝⁷ : Ring R\nQ : Type v\ninst✝⁶ : AddCommGroup Q\ninst✝⁵ : Module R Q\nM : Type u_1\nN : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : Module R M\ninst✝¹ : Module R N\ni : LinearMap (RingHom.id R) M N\nf : LinearMap (RingHom.id R) M Q\ninst✝ : Fact (Function.Injective ⇑i)\ny : N\nx : Subtype fun x => Membership.mem (Module.Baer.supExtensionOfMaxSingleton i f y) x\n⊢ Eq (↑x) (HAdd.hAdd (↑(Module.Baer.ExtensionOfMaxAdjoin.fst i x)) (HSMul.hSMul (Module.Baer.ExtensionOfMaxAdjoin.snd i x) y))","decl":"theorem ExtensionOfMaxAdjoin.eqn {y : N} (x : supExtensionOfMaxSingleton i f y) :\n    ↑x = ↑(ExtensionOfMaxAdjoin.fst i x) + ExtensionOfMaxAdjoin.snd i x • y :=\n  (extensionOfMax_adjoin.aux1 i x).choose_spec.choose_spec\n\n"}
{"name":"Module.Baer.ExtensionOfMaxAdjoin.extendIdealTo_is_extension","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝⁷ : Ring R\nQ : Type v\ninst✝⁶ : AddCommGroup Q\ninst✝⁵ : Module R Q\nM : Type u_1\nN : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : Module R M\ninst✝¹ : Module R N\ni : LinearMap (RingHom.id R) M N\nf : LinearMap (RingHom.id R) M Q\ninst✝ : Fact (Function.Injective ⇑i)\nh : Module.Baer R Q\ny : N\nx : R\nmem : Membership.mem (Module.Baer.ExtensionOfMaxAdjoin.ideal i f y) x\n⊢ Eq ((Module.Baer.ExtensionOfMaxAdjoin.extendIdealTo i f h y) x) ((Module.Baer.ExtensionOfMaxAdjoin.idealTo i f y) ⟨x, mem⟩)","decl":"theorem ExtensionOfMaxAdjoin.extendIdealTo_is_extension (h : Module.Baer R Q) (y : N) :\n    ∀ (x : R) (mem : x ∈ ExtensionOfMaxAdjoin.ideal i f y),\n      ExtensionOfMaxAdjoin.extendIdealTo i f h y x = ExtensionOfMaxAdjoin.idealTo i f y ⟨x, mem⟩ :=\n  (h (ExtensionOfMaxAdjoin.ideal i f y) (ExtensionOfMaxAdjoin.idealTo i f y)).choose_spec\n\n"}
{"name":"Module.Baer.ExtensionOfMaxAdjoin.extendIdealTo_wd'","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝⁷ : Ring R\nQ : Type v\ninst✝⁶ : AddCommGroup Q\ninst✝⁵ : Module R Q\nM : Type u_1\nN : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : Module R M\ninst✝¹ : Module R N\ni : LinearMap (RingHom.id R) M N\nf : LinearMap (RingHom.id R) M Q\ninst✝ : Fact (Function.Injective ⇑i)\nh : Module.Baer R Q\ny : N\nr : R\neq1 : Eq (HSMul.hSMul r y) 0\n⊢ Eq ((Module.Baer.ExtensionOfMaxAdjoin.extendIdealTo i f h y) r) 0","decl":"theorem ExtensionOfMaxAdjoin.extendIdealTo_wd' (h : Module.Baer R Q) {y : N} (r : R)\n    (eq1 : r • y = 0) : ExtensionOfMaxAdjoin.extendIdealTo i f h y r = 0 := by\n  have : r ∈ ideal i f y := by\n    change (r • y) ∈ (extensionOfMax i f).toLinearPMap.domain\n    rw [eq1]\n    apply Submodule.zero_mem _\n  rw [ExtensionOfMaxAdjoin.extendIdealTo_is_extension i f h y r this]\n  dsimp [ExtensionOfMaxAdjoin.idealTo]\n  simp only [LinearMap.coe_mk, eq1, Subtype.coe_mk, ← ZeroMemClass.zero_def,\n    (extensionOfMax i f).toLinearPMap.map_zero]\n\n"}
{"name":"Module.Baer.ExtensionOfMaxAdjoin.extendIdealTo_wd","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝⁷ : Ring R\nQ : Type v\ninst✝⁶ : AddCommGroup Q\ninst✝⁵ : Module R Q\nM : Type u_1\nN : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : Module R M\ninst✝¹ : Module R N\ni : LinearMap (RingHom.id R) M N\nf : LinearMap (RingHom.id R) M Q\ninst✝ : Fact (Function.Injective ⇑i)\nh : Module.Baer R Q\ny : N\nr r' : R\neq1 : Eq (HSMul.hSMul r y) (HSMul.hSMul r' y)\n⊢ Eq ((Module.Baer.ExtensionOfMaxAdjoin.extendIdealTo i f h y) r) ((Module.Baer.ExtensionOfMaxAdjoin.extendIdealTo i f h y) r')","decl":"theorem ExtensionOfMaxAdjoin.extendIdealTo_wd (h : Module.Baer R Q) {y : N} (r r' : R)\n    (eq1 : r • y = r' • y) : ExtensionOfMaxAdjoin.extendIdealTo i f h y r =\n    ExtensionOfMaxAdjoin.extendIdealTo i f h y r' := by\n  rw [← sub_eq_zero, ← map_sub]\n  convert ExtensionOfMaxAdjoin.extendIdealTo_wd' i f h (r - r') _\n  rw [sub_smul, sub_eq_zero, eq1]\n\n"}
{"name":"Module.Baer.ExtensionOfMaxAdjoin.extendIdealTo_eq","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝⁷ : Ring R\nQ : Type v\ninst✝⁶ : AddCommGroup Q\ninst✝⁵ : Module R Q\nM : Type u_1\nN : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : Module R M\ninst✝¹ : Module R N\ni : LinearMap (RingHom.id R) M N\nf : LinearMap (RingHom.id R) M Q\ninst✝ : Fact (Function.Injective ⇑i)\nh : Module.Baer R Q\ny : N\nr : R\nhr : Membership.mem (Module.Baer.extensionOfMax i f).domain (HSMul.hSMul r y)\n⊢ Eq ((Module.Baer.ExtensionOfMaxAdjoin.extendIdealTo i f h y) r) (↑(Module.Baer.extensionOfMax i f).toLinearPMap ⟨HSMul.hSMul r y, hr⟩)","decl":"theorem ExtensionOfMaxAdjoin.extendIdealTo_eq (h : Module.Baer R Q) {y : N} (r : R)\n    (hr : r • y ∈ (extensionOfMax i f).domain) : ExtensionOfMaxAdjoin.extendIdealTo i f h y r =\n    (extensionOfMax i f).toLinearPMap ⟨r • y, hr⟩ := by\n    -- Porting note: in mathlib3 `AddHom.coe_mk` was not needed\n  simp only [ExtensionOfMaxAdjoin.extendIdealTo_is_extension i f h _ _ hr,\n    ExtensionOfMaxAdjoin.idealTo, LinearMap.coe_mk, Subtype.coe_mk, AddHom.coe_mk]\n\n"}
{"name":"Module.Baer.ExtensionOfMaxAdjoin.extensionToFun_wd","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝⁷ : Ring R\nQ : Type v\ninst✝⁶ : AddCommGroup Q\ninst✝⁵ : Module R Q\nM : Type u_1\nN : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : Module R M\ninst✝¹ : Module R N\ni : LinearMap (RingHom.id R) M N\nf : LinearMap (RingHom.id R) M Q\ninst✝ : Fact (Function.Injective ⇑i)\nh : Module.Baer R Q\ny : N\nx : Subtype fun x => Membership.mem (Module.Baer.supExtensionOfMaxSingleton i f y) x\na : Subtype fun x => Membership.mem (Module.Baer.extensionOfMax i f).domain x\nr : R\neq1 : Eq (↑x) (HAdd.hAdd (↑a) (HSMul.hSMul r y))\n⊢ Eq (Module.Baer.ExtensionOfMaxAdjoin.extensionToFun i f h x) (HAdd.hAdd (↑(Module.Baer.extensionOfMax i f).toLinearPMap a) ((Module.Baer.ExtensionOfMaxAdjoin.extendIdealTo i f h y) r))","decl":"theorem ExtensionOfMaxAdjoin.extensionToFun_wd (h : Module.Baer R Q) {y : N}\n    (x : supExtensionOfMaxSingleton i f y) (a : (extensionOfMax i f).domain)\n    (r : R) (eq1 : ↑x = ↑a + r • y) :\n    ExtensionOfMaxAdjoin.extensionToFun i f h x =\n      (extensionOfMax i f).toLinearPMap a + ExtensionOfMaxAdjoin.extendIdealTo i f h y r := by\n  cases' a with a ha\n  have eq2 :\n    (ExtensionOfMaxAdjoin.fst i x - a : N) = (r - ExtensionOfMaxAdjoin.snd i x) • y := by\n    change x = a + r • y at eq1\n    rwa [ExtensionOfMaxAdjoin.eqn, ← sub_eq_zero, ← sub_sub_sub_eq, sub_eq_zero, ← sub_smul]\n      at eq1\n  have eq3 :=\n    ExtensionOfMaxAdjoin.extendIdealTo_eq i f h (r - ExtensionOfMaxAdjoin.snd i x)\n      (by rw [← eq2]; exact Submodule.sub_mem _ (ExtensionOfMaxAdjoin.fst i x).2 ha)\n  simp only [map_sub, sub_smul, sub_eq_iff_eq_add] at eq3\n  unfold ExtensionOfMaxAdjoin.extensionToFun\n  rw [eq3, ← add_assoc, ← (extensionOfMax i f).toLinearPMap.map_add, AddMemClass.mk_add_mk]\n  congr\n  ext\n  dsimp\n  rw [Subtype.coe_mk, add_sub, ← eq1]\n  exact eq_sub_of_add_eq (ExtensionOfMaxAdjoin.eqn i x).symm\n\n"}
{"name":"Module.Baer.extensionOfMax_le","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝⁷ : Ring R\nQ : Type v\ninst✝⁶ : AddCommGroup Q\ninst✝⁵ : Module R Q\nM : Type u_1\nN : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : Module R M\ninst✝¹ : Module R N\ni : LinearMap (RingHom.id R) M N\nf : LinearMap (RingHom.id R) M Q\ninst✝ : Fact (Function.Injective ⇑i)\nh : Module.Baer R Q\ny : N\n⊢ LE.le (Module.Baer.extensionOfMax i f) (Module.Baer.extensionOfMaxAdjoin i f h y)","decl":"theorem extensionOfMax_le (h : Module.Baer R Q) {y : N} :\n    extensionOfMax i f ≤ extensionOfMaxAdjoin i f h y :=\n  ⟨le_sup_left, fun x x' EQ => by\n    symm\n    change ExtensionOfMaxAdjoin.extensionToFun i f h _ = _\n    rw [ExtensionOfMaxAdjoin.extensionToFun_wd i f h x' x 0 (by simp [EQ]), map_zero,\n      add_zero]⟩\n\n"}
{"name":"Module.Baer.extensionOfMax_to_submodule_eq_top","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝⁷ : Ring R\nQ : Type v\ninst✝⁶ : AddCommGroup Q\ninst✝⁵ : Module R Q\nM : Type u_1\nN : Type u_2\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup N\ninst✝² : Module R M\ninst✝¹ : Module R N\ni : LinearMap (RingHom.id R) M N\nf : LinearMap (RingHom.id R) M Q\ninst✝ : Fact (Function.Injective ⇑i)\nh : Module.Baer R Q\n⊢ Eq (Module.Baer.extensionOfMax i f).domain Top.top","decl":"theorem extensionOfMax_to_submodule_eq_top (h : Module.Baer R Q) :\n    (extensionOfMax i f).domain = ⊤ := by\n  refine Submodule.eq_top_iff'.mpr fun y => ?_\n  dsimp\n  rw [← extensionOfMax_is_max i f _ (extensionOfMax_le i f h), extensionOfMaxAdjoin,\n    Submodule.mem_sup]\n  exact ⟨0, Submodule.zero_mem _, y, Submodule.mem_span_singleton_self _, zero_add _⟩\n\n"}
{"name":"Module.Baer.extension_property","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝⁶ : Ring R\nQ : Type v\ninst✝⁵ : AddCommGroup Q\ninst✝⁴ : Module R Q\nM : Type u_1\nN : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R M\ninst✝ : Module R N\nh : Module.Baer R Q\nf : LinearMap (RingHom.id R) M N\nhf : Function.Injective ⇑f\ng : LinearMap (RingHom.id R) M Q\n⊢ Exists fun h => Eq (h.comp f) g","decl":"protected theorem extension_property (h : Module.Baer R Q)\n    (f : M →ₗ[R] N) (hf : Function.Injective f) (g : M →ₗ[R] Q) : ∃ h, h ∘ₗ f = g :=\n  haveI : Fact (Function.Injective f) := ⟨hf⟩\n  Exists.intro\n    { toFun := ((extensionOfMax f g).toLinearPMap\n        ⟨·, (extensionOfMax_to_submodule_eq_top f g h).symm ▸ ⟨⟩⟩)\n      map_add' := fun x y ↦ by rw [← LinearPMap.map_add]; congr\n      map_smul' := fun r x ↦ by rw [← LinearPMap.map_smul]; dsimp } <|\n    LinearMap.ext fun x ↦ ((extensionOfMax f g).is_extension x).symm\n\n"}
{"name":"Module.Baer.extension_property_addMonoidHom","module":"Mathlib.Algebra.Module.Injective","initialProofState":"Q : Type v\ninst✝² : AddCommGroup Q\nM : Type u_1\nN : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : AddCommGroup N\nh : Module.Baer Int Q\nf : AddMonoidHom M N\nhf : Function.Injective ⇑f\ng : AddMonoidHom M Q\n⊢ Exists fun h => Eq (h.comp f) g","decl":"theorem extension_property_addMonoidHom (h : Module.Baer ℤ Q)\n    (f : M →+ N) (hf : Function.Injective f) (g : M →+ Q) : ∃ h : N →+ Q, h.comp f = g :=\n  have ⟨g', hg'⟩ := h.extension_property f.toIntLinearMap hf g.toIntLinearMap\n  ⟨g', congr(LinearMap.toAddMonoidHom $hg')⟩\n\n"}
{"name":"Module.Baer.injective","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝² : Ring R\nQ : Type v\ninst✝¹ : AddCommGroup Q\ninst✝ : Module R Q\nh : Module.Baer R Q\n⊢ Module.Injective R Q","decl":"/-- **Baer's criterion** for injective module : a Baer module is an injective module, i.e. if every\nlinear map from an ideal can be extended, then the module is injective. -/\nprotected theorem injective (h : Module.Baer R Q) : Module.Injective R Q where\n  out X Y _ _ _ _ i hi f := by\n    obtain ⟨h, H⟩ := Module.Baer.extension_property h i hi f\n    exact ⟨h, DFunLike.congr_fun H⟩\n\n"}
{"name":"Module.Baer.of_injective","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝³ : Ring R\nQ : Type v\ninst✝² : AddCommGroup Q\ninst✝¹ : Module R Q\ninst✝ : Small.{v, u} R\ninj : Module.Injective R Q\n⊢ Module.Baer R Q","decl":"protected theorem of_injective [Small.{v} R] (inj : Module.Injective R Q) : Module.Baer R Q := by\n  intro I g\n  let eI := Shrink.linearEquiv I R\n  let eR := Shrink.linearEquiv R R\n  obtain ⟨g', hg'⟩ := Module.Injective.out (eR.symm.toLinearMap ∘ₗ I.subtype ∘ₗ eI.toLinearMap)\n    (eR.symm.injective.comp <| Subtype.val_injective.comp eI.injective) (g ∘ₗ eI.toLinearMap)\n  exact ⟨g' ∘ₗ eR.symm.toLinearMap, fun x mx ↦ by simpa [eI, eR] using hg' (equivShrink I ⟨x, mx⟩)⟩\n\n"}
{"name":"Module.Baer.iff_injective","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝³ : Ring R\nQ : Type v\ninst✝² : AddCommGroup Q\ninst✝¹ : Module R Q\ninst✝ : Small.{v, u} R\n⊢ Iff (Module.Baer R Q) (Module.Injective R Q)","decl":"protected theorem iff_injective [Small.{v} R] : Module.Baer R Q ↔ Module.Injective R Q :=\n  ⟨Module.Baer.injective, Module.Baer.of_injective⟩\n\n"}
{"name":"Module.ulift_injective_of_injective","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝³ : Ring R\nM : Type v\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Small.{v, u} R\ninj : Module.Injective R M\n⊢ Module.Injective R (ULift.{v', v} M)","decl":"lemma Module.ulift_injective_of_injective [Small.{v} R]\n    (inj : Module.Injective R M) :\n    Module.Injective R (ULift.{v'} M) := Module.Baer.injective fun I g ↦\n  have ⟨g', hg'⟩ := Module.Baer.iff_injective.mpr inj I (ULift.moduleEquiv.toLinearMap ∘ₗ g)\n  ⟨ULift.moduleEquiv.symm.toLinearMap ∘ₗ g', fun r hr ↦ ULift.ext _ _ <| hg' r hr⟩\n\n"}
{"name":"Module.injective_of_ulift_injective","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝² : Ring R\nM : Type v\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\ninj : Module.Injective R (ULift.{v', v} M)\n⊢ Module.Injective R M","decl":"lemma Module.injective_of_ulift_injective\n    (inj : Module.Injective R (ULift.{v'} M)) :\n    Module.Injective R M where\n  out X Y _ _ _ _ f hf g :=\n    let eX := ULift.moduleEquiv.{_,_,v'} (R := R) (M := X)\n    have ⟨g', hg'⟩ := inj.out (ULift.moduleEquiv.{_,_,v'}.symm.toLinearMap ∘ₗ f ∘ₗ eX.toLinearMap)\n      (by exact ULift.moduleEquiv.symm.injective.comp <| hf.comp eX.injective)\n      (ULift.moduleEquiv.symm.toLinearMap ∘ₗ g ∘ₗ eX.toLinearMap)\n    ⟨ULift.moduleEquiv.toLinearMap ∘ₗ g' ∘ₗ ULift.moduleEquiv.symm.toLinearMap,\n      fun x ↦ by exact congr(ULift.down $(hg' ⟨x⟩))⟩\n\n"}
{"name":"Module.injective_iff_ulift_injective","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type u\ninst✝³ : Ring R\nM : Type v\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Small.{v, u} R\n⊢ Iff (Module.Injective R M) (Module.Injective R (ULift.{v', v} M))","decl":"lemma Module.injective_iff_ulift_injective :\n    Module.Injective R M ↔ Module.Injective R (ULift.{v'} M) :=\n  ⟨Module.ulift_injective_of_injective R,\n   Module.injective_of_ulift_injective R⟩\n\n"}
{"name":"Module.Injective.extension_property","module":"Mathlib.Algebra.Module.Injective","initialProofState":"R : Type uR\ninst✝⁷ : Ring R\ninst✝⁶ : Small.{uM, uR} R\nM : Type uM\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninj : Module.Injective R M\nP : Type uP\ninst✝³ : AddCommGroup P\ninst✝² : Module R P\nP' : Type uP'\ninst✝¹ : AddCommGroup P'\ninst✝ : Module R P'\nf : LinearMap (RingHom.id R) P P'\nhf : Function.Injective ⇑f\ng : LinearMap (RingHom.id R) P M\n⊢ Exists fun h => Eq (h.comp f) g","decl":"lemma Module.Injective.extension_property\n    (f : P →ₗ[R] P') (hf : Function.Injective f)\n    (g : P →ₗ[R] M) : ∃ h : P' →ₗ[R] M, h ∘ₗ f = g :=\n  (Module.Baer.of_injective inj).extension_property f hf g\n\n"}
