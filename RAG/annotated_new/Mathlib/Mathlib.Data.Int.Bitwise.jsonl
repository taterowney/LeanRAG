{"name":"Int.bodd_zero","module":"Mathlib.Data.Int.Bitwise","initialProofState":"⊢ Eq (Int.bodd 0) Bool.false","decl":"@[simp]\ntheorem bodd_zero : bodd 0 = false :=\n  rfl\n\n"}
{"name":"Int.bodd_one","module":"Mathlib.Data.Int.Bitwise","initialProofState":"⊢ Eq (Int.bodd 1) Bool.true","decl":"@[simp]\ntheorem bodd_one : bodd 1 = true :=\n  rfl\n\n"}
{"name":"Int.bodd_two","module":"Mathlib.Data.Int.Bitwise","initialProofState":"⊢ Eq (Int.bodd 2) Bool.false","decl":"theorem bodd_two : bodd 2 = false :=\n  rfl\n\n"}
{"name":"Int.bodd_coe","module":"Mathlib.Data.Int.Bitwise","initialProofState":"n : Nat\n⊢ Eq (↑n).bodd n.bodd","decl":"@[simp, norm_cast]\ntheorem bodd_coe (n : ℕ) : Int.bodd n = Nat.bodd n :=\n  rfl\n\n"}
{"name":"Int.bodd_subNatNat","module":"Mathlib.Data.Int.Bitwise","initialProofState":"m n : Nat\n⊢ Eq (Int.subNatNat m n).bodd (m.bodd.xor n.bodd)","decl":"@[simp]\ntheorem bodd_subNatNat (m n : ℕ) : bodd (subNatNat m n) = xor m.bodd n.bodd := by\n  apply subNatNat_elim m n fun m n i => bodd i = xor m.bodd n.bodd <;>\n  intros i j <;>\n  simp only [Int.bodd, Int.bodd_coe, Nat.bodd_add] <;>\n  cases Nat.bodd i <;> simp\n\n"}
{"name":"Int.bodd_negOfNat","module":"Mathlib.Data.Int.Bitwise","initialProofState":"n : Nat\n⊢ Eq (Int.negOfNat n).bodd n.bodd","decl":"@[simp]\ntheorem bodd_negOfNat (n : ℕ) : bodd (negOfNat n) = n.bodd := by\n  cases n <;> simp +decide\n  rfl\n\n"}
{"name":"Int.bodd_neg","module":"Mathlib.Data.Int.Bitwise","initialProofState":"n : Int\n⊢ Eq (Neg.neg n).bodd n.bodd","decl":"@[simp]\ntheorem bodd_neg (n : ℤ) : bodd (-n) = bodd n := by\n  cases n with\n  | ofNat =>\n    rw [← negOfNat_eq, bodd_negOfNat]\n    simp\n  | negSucc n =>\n    rw [neg_negSucc, bodd_coe, Nat.bodd_succ]\n    change (!Nat.bodd n) = !(bodd n)\n    rw [bodd_coe]\n-- Porting note: Heavily refactored proof, used to work all with `simp`:\n-- `cases n <;> simp [Neg.neg, Int.natCast_eq_ofNat, Int.neg, bodd, -of_nat_eq_coe]`\n\n"}
{"name":"Int.bodd_add","module":"Mathlib.Data.Int.Bitwise","initialProofState":"m n : Int\n⊢ Eq (HAdd.hAdd m n).bodd (m.bodd.xor n.bodd)","decl":"@[simp]\ntheorem bodd_add (m n : ℤ) : bodd (m + n) = xor (bodd m) (bodd n) := by\n  cases' m with m m <;>\n  cases' n with n n <;>\n  simp only [ofNat_eq_coe, ofNat_add_negSucc, negSucc_add_ofNat,\n             negSucc_add_negSucc, bodd_subNatNat] <;>\n  simp only [negSucc_coe, bodd_neg, bodd_coe, ← Nat.bodd_add, Bool.xor_comm, ← Nat.cast_add]\n  rw [← Nat.succ_add, add_assoc]\n-- Porting note: Heavily refactored proof, used to work all with `simp`:\n-- `by cases m with m m; cases n with n n; unfold has_add.add;`\n-- `simp [int.add, -of_nat_eq_coe, bool.xor_comm]`\n\n"}
{"name":"Int.bodd_mul","module":"Mathlib.Data.Int.Bitwise","initialProofState":"m n : Int\n⊢ Eq (HMul.hMul m n).bodd (m.bodd.and n.bodd)","decl":"@[simp]\ntheorem bodd_mul (m n : ℤ) : bodd (m * n) = (bodd m && bodd n) := by\n  cases' m with m m <;> cases' n with n n <;>\n  simp only [ofNat_eq_coe, ofNat_mul_negSucc, negSucc_mul_ofNat, ofNat_mul_ofNat,\n             negSucc_mul_negSucc] <;>\n  simp only [negSucc_coe, bodd_neg, bodd_coe, ← Nat.bodd_mul]\n-- Porting note: Heavily refactored proof, used to be:\n-- `by cases m with m m; cases n with n n;`\n-- `simp [← int.mul_def, int.mul, -of_nat_eq_coe, bool.xor_comm]`\n\n"}
{"name":"Int.bodd_add_div2","module":"Mathlib.Data.Int.Bitwise","initialProofState":"n : Int\n⊢ Eq (HAdd.hAdd (cond n.bodd 1 0) (HMul.hMul 2 n.div2)) n","decl":"theorem bodd_add_div2 : ∀ n, cond (bodd n) 1 0 + 2 * div2 n = n\n  | (n : ℕ) => by\n    rw [show (cond (bodd n) 1 0 : ℤ) = (cond (bodd n) 1 0 : ℕ) by cases bodd n <;> rfl]\n    exact congr_arg ofNat n.bodd_add_div2\n  | -[n+1] => by\n    refine Eq.trans ?_ (congr_arg negSucc n.bodd_add_div2)\n    dsimp [bodd]; cases Nat.bodd n <;> dsimp [cond, not, div2, Int.mul]\n    · change -[2 * Nat.div2 n+1] = _\n      rw [zero_add]\n    · rw [zero_add, add_comm]\n      rfl\n\n"}
{"name":"Int.div2_val","module":"Mathlib.Data.Int.Bitwise","initialProofState":"n : Int\n⊢ Eq n.div2 (HDiv.hDiv n 2)","decl":"theorem div2_val : ∀ n, div2 n = n / 2\n  | (n : ℕ) => congr_arg ofNat n.div2_val\n  | -[n+1] => congr_arg negSucc n.div2_val\n\n"}
{"name":"Int.bit_val","module":"Mathlib.Data.Int.Bitwise","initialProofState":"b : Bool\nn : Int\n⊢ Eq (Int.bit b n) (HAdd.hAdd (HMul.hMul 2 n) (cond b 1 0))","decl":"theorem bit_val (b n) : bit b n = 2 * n + cond b 1 0 := by\n  cases b\n  · apply (add_zero _).symm\n  · rfl\n\n"}
{"name":"Int.bit_decomp","module":"Mathlib.Data.Int.Bitwise","initialProofState":"n : Int\n⊢ Eq (Int.bit n.bodd n.div2) n","decl":"theorem bit_decomp (n : ℤ) : bit (bodd n) (div2 n) = n :=\n  (bit_val _ _).trans <| (add_comm _ _).trans <| bodd_add_div2 _\n\n"}
{"name":"Int.bit_zero","module":"Mathlib.Data.Int.Bitwise","initialProofState":"⊢ Eq (Int.bit Bool.false 0) 0","decl":"@[simp]\ntheorem bit_zero : bit false 0 = 0 :=\n  rfl\n\n"}
{"name":"Int.bit_coe_nat","module":"Mathlib.Data.Int.Bitwise","initialProofState":"b : Bool\nn : Nat\n⊢ Eq (Int.bit b ↑n) ↑(Nat.bit b n)","decl":"@[simp]\ntheorem bit_coe_nat (b) (n : ℕ) : bit b n = Nat.bit b n := by\n  rw [bit_val, Nat.bit_val]\n  cases b <;> rfl\n\n"}
{"name":"Int.bit_negSucc","module":"Mathlib.Data.Int.Bitwise","initialProofState":"b : Bool\nn : Nat\n⊢ Eq (Int.bit b (Int.negSucc n)) (Int.negSucc (Nat.bit b.not n))","decl":"@[simp]\ntheorem bit_negSucc (b) (n : ℕ) : bit b -[n+1] = -[Nat.bit (not b) n+1] := by\n  rw [bit_val, Nat.bit_val]\n  cases b <;> rfl\n\n"}
{"name":"Int.bodd_bit","module":"Mathlib.Data.Int.Bitwise","initialProofState":"b : Bool\nn : Int\n⊢ Eq (Int.bit b n).bodd b","decl":"@[simp]\ntheorem bodd_bit (b n) : bodd (bit b n) = b := by\n  rw [bit_val]\n  cases b <;> cases bodd n <;> simp [(show bodd 2 = false by rfl)]\n\n"}
{"name":"Int.testBit_bit_zero","module":"Mathlib.Data.Int.Bitwise","initialProofState":"b : Bool\nn : Int\n⊢ Eq ((Int.bit b n).testBit 0) b","decl":"@[simp]\ntheorem testBit_bit_zero (b) : ∀ n, testBit (bit b n) 0 = b\n  | (n : ℕ) => by rw [bit_coe_nat]; apply Nat.testBit_bit_zero\n  | -[n+1] => by\n    rw [bit_negSucc]; dsimp [testBit]; rw [Nat.testBit_bit_zero]; clear testBit_bit_zero\n    cases b <;>\n      rfl\n\n"}
{"name":"Int.testBit_bit_succ","module":"Mathlib.Data.Int.Bitwise","initialProofState":"m : Nat\nb : Bool\nn : Int\n⊢ Eq ((Int.bit b n).testBit m.succ) (n.testBit m)","decl":"@[simp]\ntheorem testBit_bit_succ (m b) : ∀ n, testBit (bit b n) (Nat.succ m) = testBit n m\n  | (n : ℕ) => by rw [bit_coe_nat]; apply Nat.testBit_bit_succ\n  | -[n+1] => by\n    dsimp only [testBit]\n    simp only [bit_negSucc]\n    cases b <;> simp only [Bool.not_false, Bool.not_true, Nat.testBit_bit_succ]\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO\n-- private unsafe def bitwise_tac : tactic Unit :=\n--   sorry\n\n-- Porting note: Was `bitwise_tac` in mathlib\n"}
{"name":"Int.bitwise_or","module":"Mathlib.Data.Int.Bitwise","initialProofState":"⊢ Eq (Int.bitwise Bool.or) Int.lor","decl":"theorem bitwise_or : bitwise or = lor := by\n  funext m n\n  cases' m with m m <;> cases' n with n n <;> try {rfl}\n    <;> simp only [bitwise, natBitwise, Bool.not_false, Bool.or_true, cond_true, lor, Nat.ldiff,\n      negSucc.injEq, Bool.true_or, Nat.land]\n  · rw [Nat.bitwise_swap, Function.swap]\n    congr\n    funext x y\n    cases x <;> cases y <;> rfl\n  · congr\n    funext x y\n    cases x <;> cases y <;> rfl\n  · congr\n    funext x y\n    cases x <;> cases y <;> rfl\n\n-- Porting note: Was `bitwise_tac` in mathlib\n"}
{"name":"Int.bitwise_and","module":"Mathlib.Data.Int.Bitwise","initialProofState":"⊢ Eq (Int.bitwise Bool.and) Int.land","decl":"theorem bitwise_and : bitwise and = land := by\n  funext m n\n  cases' m with m m <;> cases' n with n n <;> try {rfl}\n    <;> simp only [bitwise, natBitwise, Bool.not_false, Bool.or_true,\n      cond_false, cond_true, lor, Nat.ldiff, Bool.and_true, negSucc.injEq,\n      Bool.and_false, Nat.land]\n  · rw [Nat.bitwise_swap, Function.swap]\n    congr\n    funext x y\n    cases x <;> cases y <;> rfl\n  · congr\n    funext x y\n    cases x <;> cases y <;> rfl\n\n-- Porting note: Was `bitwise_tac` in mathlib\n"}
{"name":"Int.bitwise_diff","module":"Mathlib.Data.Int.Bitwise","initialProofState":"⊢ Eq (Int.bitwise fun a b => a.and b.not) Int.ldiff","decl":"theorem bitwise_diff : (bitwise fun a b => a && not b) = ldiff := by\n  funext m n\n  cases' m with m m <;> cases' n with n n <;> try {rfl}\n    <;> simp only [bitwise, natBitwise, Bool.not_false, Bool.or_true,\n      cond_false, cond_true, lor, Nat.ldiff, Bool.and_true, negSucc.injEq,\n      Bool.and_false, Nat.land, Bool.not_true, ldiff, Nat.lor]\n  · congr\n    funext x y\n    cases x <;> cases y <;> rfl\n  · congr\n    funext x y\n    cases x <;> cases y <;> rfl\n  · rw [Nat.bitwise_swap, Function.swap]\n    congr\n    funext x y\n    cases x <;> cases y <;> rfl\n\n-- Porting note: Was `bitwise_tac` in mathlib\n"}
{"name":"Int.bitwise_xor","module":"Mathlib.Data.Int.Bitwise","initialProofState":"⊢ Eq (Int.bitwise Bool.xor) Int.xor","decl":"theorem bitwise_xor : bitwise xor = Int.xor := by\n  funext m n\n  cases' m with m m <;> cases' n with n n <;> try {rfl}\n    <;> simp only [bitwise, natBitwise, Bool.not_false, Bool.or_true, Bool.bne_eq_xor,\n      cond_false, cond_true, lor, Nat.ldiff, Bool.and_true, negSucc.injEq, Bool.false_xor,\n      Bool.true_xor, Bool.and_false, Nat.land, Bool.not_true, ldiff,\n      HOr.hOr, OrOp.or, Nat.lor, Int.xor, HXor.hXor, Xor.xor, Nat.xor]\n  · congr\n    funext x y\n    cases x <;> cases y <;> rfl\n  · congr\n    funext x y\n    cases x <;> cases y <;> rfl\n  · congr\n    funext x y\n    cases x <;> cases y <;> rfl\n\n"}
{"name":"Int.bitwise_bit","module":"Mathlib.Data.Int.Bitwise","initialProofState":"f : Bool → Bool → Bool\na : Bool\nm : Int\nb : Bool\nn : Int\n⊢ Eq (Int.bitwise f (Int.bit a m) (Int.bit b n)) (Int.bit (f a b) (Int.bitwise f m n))","decl":"@[simp]\ntheorem bitwise_bit (f : Bool → Bool → Bool) (a m b n) :\n    bitwise f (bit a m) (bit b n) = bit (f a b) (bitwise f m n) := by\n  cases' m with m m <;> cases' n with n n <;>\n  simp [bitwise, ofNat_eq_coe, bit_coe_nat, natBitwise, Bool.not_false, Bool.not_eq_false',\n    bit_negSucc]\n  · by_cases h : f false false <;> simp +decide [h]\n  · by_cases h : f false true <;> simp +decide [h]\n  · by_cases h : f true false <;> simp +decide [h]\n  · by_cases h : f true true <;> simp +decide [h]\n\n"}
{"name":"Int.lor_bit","module":"Mathlib.Data.Int.Bitwise","initialProofState":"a : Bool\nm : Int\nb : Bool\nn : Int\n⊢ Eq ((Int.bit a m).lor (Int.bit b n)) (Int.bit (a.or b) (m.lor n))","decl":"@[simp]\ntheorem lor_bit (a m b n) : lor (bit a m) (bit b n) = bit (a || b) (lor m n) := by\n  rw [← bitwise_or, bitwise_bit]\n\n"}
{"name":"Int.land_bit","module":"Mathlib.Data.Int.Bitwise","initialProofState":"a : Bool\nm : Int\nb : Bool\nn : Int\n⊢ Eq ((Int.bit a m).land (Int.bit b n)) (Int.bit (a.and b) (m.land n))","decl":"@[simp]\ntheorem land_bit (a m b n) : land (bit a m) (bit b n) = bit (a && b) (land m n) := by\n  rw [← bitwise_and, bitwise_bit]\n\n"}
{"name":"Int.ldiff_bit","module":"Mathlib.Data.Int.Bitwise","initialProofState":"a : Bool\nm : Int\nb : Bool\nn : Int\n⊢ Eq ((Int.bit a m).ldiff (Int.bit b n)) (Int.bit (a.and b.not) (m.ldiff n))","decl":"@[simp]\ntheorem ldiff_bit (a m b n) : ldiff (bit a m) (bit b n) = bit (a && not b) (ldiff m n) := by\n  rw [← bitwise_diff, bitwise_bit]\n\n"}
{"name":"Int.lxor_bit","module":"Mathlib.Data.Int.Bitwise","initialProofState":"a : Bool\nm : Int\nb : Bool\nn : Int\n⊢ Eq ((Int.bit a m).xor (Int.bit b n)) (Int.bit (a.xor b) (m.xor n))","decl":"@[simp]\ntheorem lxor_bit (a m b n) : Int.xor (bit a m) (bit b n) = bit (xor a b) (Int.xor m n) := by\n  rw [← bitwise_xor, bitwise_bit]\n\n"}
{"name":"Int.lnot_bit","module":"Mathlib.Data.Int.Bitwise","initialProofState":"b : Bool\nn : Int\n⊢ Eq (Int.bit b n).lnot (Int.bit b.not n.lnot)","decl":"@[simp]\ntheorem lnot_bit (b) : ∀ n, lnot (bit b n) = bit (not b) (lnot n)\n  | (n : ℕ) => by simp [lnot]\n  | -[n+1] => by simp [lnot]\n\n"}
{"name":"Int.testBit_bitwise","module":"Mathlib.Data.Int.Bitwise","initialProofState":"f : Bool → Bool → Bool\nm n : Int\nk : Nat\n⊢ Eq ((Int.bitwise f m n).testBit k) (f (m.testBit k) (n.testBit k))","decl":"@[simp]\ntheorem testBit_bitwise (f : Bool → Bool → Bool) (m n k) :\n    testBit (bitwise f m n) k = f (testBit m k) (testBit n k) := by\n  cases m <;> cases n <;> simp only [testBit, bitwise, natBitwise]\n  · by_cases h : f false false <;> simp [h]\n  · by_cases h : f false true <;> simp [h]\n  · by_cases h : f true false <;> simp [h]\n  · by_cases h : f true true <;> simp [h]\n\n"}
{"name":"Int.testBit_lor","module":"Mathlib.Data.Int.Bitwise","initialProofState":"m n : Int\nk : Nat\n⊢ Eq ((m.lor n).testBit k) ((m.testBit k).or (n.testBit k))","decl":"@[simp]\ntheorem testBit_lor (m n k) : testBit (lor m n) k = (testBit m k || testBit n k) := by\n  rw [← bitwise_or, testBit_bitwise]\n\n"}
{"name":"Int.testBit_land","module":"Mathlib.Data.Int.Bitwise","initialProofState":"m n : Int\nk : Nat\n⊢ Eq ((m.land n).testBit k) ((m.testBit k).and (n.testBit k))","decl":"@[simp]\ntheorem testBit_land (m n k) : testBit (land m n) k = (testBit m k && testBit n k) := by\n  rw [← bitwise_and, testBit_bitwise]\n\n"}
{"name":"Int.testBit_ldiff","module":"Mathlib.Data.Int.Bitwise","initialProofState":"m n : Int\nk : Nat\n⊢ Eq ((m.ldiff n).testBit k) ((m.testBit k).and (n.testBit k).not)","decl":"@[simp]\ntheorem testBit_ldiff (m n k) : testBit (ldiff m n) k = (testBit m k && not (testBit n k)) := by\n  rw [← bitwise_diff, testBit_bitwise]\n\n"}
{"name":"Int.testBit_lxor","module":"Mathlib.Data.Int.Bitwise","initialProofState":"m n : Int\nk : Nat\n⊢ Eq ((m.xor n).testBit k) ((m.testBit k).xor (n.testBit k))","decl":"@[simp]\ntheorem testBit_lxor (m n k) : testBit (Int.xor m n) k = xor (testBit m k) (testBit n k) := by\n  rw [← bitwise_xor, testBit_bitwise]\n\n"}
{"name":"Int.testBit_lnot","module":"Mathlib.Data.Int.Bitwise","initialProofState":"n : Int\nk : Nat\n⊢ Eq (n.lnot.testBit k) (n.testBit k).not","decl":"@[simp]\ntheorem testBit_lnot : ∀ n k, testBit (lnot n) k = not (testBit n k)\n  | (n : ℕ), k => by simp [lnot, testBit]\n  | -[n+1], k => by simp [lnot, testBit]\n\n"}
{"name":"Int.shiftLeft_neg","module":"Mathlib.Data.Int.Bitwise","initialProofState":"m n : Int\n⊢ Eq (HShiftLeft.hShiftLeft m (Neg.neg n)) (HShiftRight.hShiftRight m n)","decl":"@[simp]\ntheorem shiftLeft_neg (m n : ℤ) : m <<< (-n) = m >>> n :=\n  rfl\n\n"}
{"name":"Int.shiftRight_neg","module":"Mathlib.Data.Int.Bitwise","initialProofState":"m n : Int\n⊢ Eq (HShiftRight.hShiftRight m (Neg.neg n)) (HShiftLeft.hShiftLeft m n)","decl":"@[simp]\ntheorem shiftRight_neg (m n : ℤ) : m >>> (-n) = m <<< n := by rw [← shiftLeft_neg, neg_neg]\n\n-- Porting note: what's the correct new name?\n"}
{"name":"Int.shiftLeft_coe_nat","module":"Mathlib.Data.Int.Bitwise","initialProofState":"m n : Nat\n⊢ Eq (HShiftLeft.hShiftLeft ↑m ↑n) ↑(HShiftLeft.hShiftLeft m n)","decl":"@[simp]\ntheorem shiftLeft_coe_nat (m n : ℕ) : (m : ℤ) <<< (n : ℤ) = ↑(m <<< n) := by\n  unfold_projs; simp\n\n-- Porting note: what's the correct new name?\n"}
{"name":"Int.shiftRight_coe_nat","module":"Mathlib.Data.Int.Bitwise","initialProofState":"m n : Nat\n⊢ Eq (HShiftRight.hShiftRight ↑m ↑n) ↑(HShiftRight.hShiftRight m n)","decl":"@[simp]\ntheorem shiftRight_coe_nat (m n : ℕ) : (m : ℤ) >>> (n : ℤ) = m >>> n := by cases n <;> rfl\n\n"}
{"name":"Int.shiftLeft_negSucc","module":"Mathlib.Data.Int.Bitwise","initialProofState":"m n : Nat\n⊢ Eq (HShiftLeft.hShiftLeft (Int.negSucc m) ↑n) (Int.negSucc (Nat.shiftLeft' Bool.true m n))","decl":"@[simp]\ntheorem shiftLeft_negSucc (m n : ℕ) : -[m+1] <<< (n : ℤ) = -[Nat.shiftLeft' true m n+1] :=\n  rfl\n\n"}
{"name":"Int.shiftRight_negSucc","module":"Mathlib.Data.Int.Bitwise","initialProofState":"m n : Nat\n⊢ Eq (HShiftRight.hShiftRight (Int.negSucc m) ↑n) (Int.negSucc (HShiftRight.hShiftRight m n))","decl":"@[simp]\ntheorem shiftRight_negSucc (m n : ℕ) : -[m+1] >>> (n : ℤ) = -[m >>> n+1] := by cases n <;> rfl\n\n"}
{"name":"Int.shiftRight_add'","module":"Mathlib.Data.Int.Bitwise","initialProofState":"m : Int\nn k : Nat\n⊢ Eq (HShiftRight.hShiftRight m (HAdd.hAdd ↑n ↑k)) (HShiftRight.hShiftRight (HShiftRight.hShiftRight m ↑n) ↑k)","decl":"/-- Compare with `Int.shiftRight_add`, which doesn't have the coercions `ℕ → ℤ`. -/\ntheorem shiftRight_add' : ∀ (m : ℤ) (n k : ℕ), m >>> (n + k : ℤ) = (m >>> (n : ℤ)) >>> (k : ℤ)\n  | (m : ℕ), n, k => by\n    rw [shiftRight_coe_nat, shiftRight_coe_nat, ← Int.ofNat_add, shiftRight_coe_nat,\n      Nat.shiftRight_add]\n  | -[m+1], n, k => by\n    rw [shiftRight_negSucc, shiftRight_negSucc, ← Int.ofNat_add, shiftRight_negSucc,\n      Nat.shiftRight_add]\n\n"}
{"name":"Int.shiftLeft_add","module":"Mathlib.Data.Int.Bitwise","initialProofState":"m : Int\nn : Nat\nk : Int\n⊢ Eq (HShiftLeft.hShiftLeft m (HAdd.hAdd (↑n) k)) (HShiftLeft.hShiftLeft (HShiftLeft.hShiftLeft m ↑n) k)","decl":"theorem shiftLeft_add : ∀ (m : ℤ) (n : ℕ) (k : ℤ), m <<< (n + k) = (m <<< (n : ℤ)) <<< k\n  | (m : ℕ), n, (k : ℕ) =>\n    congr_arg ofNat (by simp [Nat.shiftLeft_eq, Nat.pow_add, mul_assoc])\n  | -[_+1], _, (k : ℕ) => congr_arg negSucc (Nat.shiftLeft'_add _ _ _ _)\n  | (m : ℕ), n, -[k+1] =>\n    subNatNat_elim n k.succ (fun n k i => (↑m) <<< i = (Nat.shiftLeft' false m n) >>> k)\n      (fun (i n : ℕ) =>\n        by dsimp; simp [← Nat.shiftLeft_sub _ , Nat.add_sub_cancel_left])\n      fun i n => by\n        dsimp\n        simp_rw [negSucc_eq, shiftLeft_neg, Nat.shiftLeft'_false, Nat.shiftRight_add,\n          ← Nat.shiftLeft_sub _ le_rfl, Nat.sub_self, Nat.shiftLeft_zero, ← shiftRight_coe_nat,\n          ← shiftRight_add', Nat.cast_one]\n  | -[m+1], n, -[k+1] =>\n    subNatNat_elim n k.succ\n      (fun n k i => -[m+1] <<< i = -[(Nat.shiftLeft' true m n) >>> k+1])\n      (fun i n =>\n        congr_arg negSucc <| by\n          rw [← Nat.shiftLeft'_sub, Nat.add_sub_cancel_left]; apply Nat.le_add_right)\n      fun i n =>\n      congr_arg negSucc <| by rw [add_assoc, Nat.shiftRight_add, ← Nat.shiftLeft'_sub _ _ le_rfl,\n          Nat.sub_self, Nat.shiftLeft']\n\n"}
{"name":"Int.shiftLeft_sub","module":"Mathlib.Data.Int.Bitwise","initialProofState":"m : Int\nn : Nat\nk : Int\n⊢ Eq (HShiftLeft.hShiftLeft m (HSub.hSub (↑n) k)) (HShiftRight.hShiftRight (HShiftLeft.hShiftLeft m ↑n) k)","decl":"theorem shiftLeft_sub (m : ℤ) (n : ℕ) (k : ℤ) : m <<< (n - k) = (m <<< (n : ℤ)) >>> k :=\n  shiftLeft_add _ _ _\n\n"}
{"name":"Int.shiftLeft_eq_mul_pow","module":"Mathlib.Data.Int.Bitwise","initialProofState":"m : Int\nn : Nat\n⊢ Eq (HShiftLeft.hShiftLeft m ↑n) (HMul.hMul m ↑(HPow.hPow 2 n))","decl":"theorem shiftLeft_eq_mul_pow : ∀ (m : ℤ) (n : ℕ), m <<< (n : ℤ) = m * (2 ^ n : ℕ)\n  | (m : ℕ), _ => congr_arg ((↑) : ℕ → ℤ) (by simp [Nat.shiftLeft_eq])\n  | -[_+1], _ => @congr_arg ℕ ℤ _ _ (fun i => -i) (Nat.shiftLeft'_tt_eq_mul_pow _ _)\n\n"}
{"name":"Int.one_shiftLeft","module":"Mathlib.Data.Int.Bitwise","initialProofState":"n : Nat\n⊢ Eq (HShiftLeft.hShiftLeft 1 ↑n) ↑(HPow.hPow 2 n)","decl":"theorem one_shiftLeft (n : ℕ) : 1 <<< (n : ℤ) = (2 ^ n : ℕ) :=\n  congr_arg ((↑) : ℕ → ℤ) (by simp [Nat.shiftLeft_eq])\n\n"}
{"name":"Int.zero_shiftLeft","module":"Mathlib.Data.Int.Bitwise","initialProofState":"n : Int\n⊢ Eq (HShiftLeft.hShiftLeft 0 n) 0","decl":"@[simp]\ntheorem zero_shiftLeft : ∀ n : ℤ, 0 <<< n = 0\n  | (n : ℕ) => congr_arg ((↑) : ℕ → ℤ) (by simp)\n  | -[_+1] => congr_arg ((↑) : ℕ → ℤ) (by simp)\n\n"}
{"name":"Int.zero_shiftRight'","module":"Mathlib.Data.Int.Bitwise","initialProofState":"n : Int\n⊢ Eq (HShiftRight.hShiftRight 0 n) 0","decl":"/-- Compare with `Int.zero_shiftRight`, which has `n : ℕ`. -/\n@[simp]\ntheorem zero_shiftRight' (n : ℤ) : 0 >>> n = 0 :=\n  zero_shiftLeft _\n\n"}
