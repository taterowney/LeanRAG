{"name":"Module.Presentation.CokernelData.π_lift","module":"Mathlib.Algebra.Module.Presentation.Cokernel","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nM₁ : Type v₁\nM₂ : Type v₂\ninst✝³ : AddCommGroup M₁\ninst✝² : Module A M₁\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module A M₂\npres₂ : Module.Presentation A M₂\nf : LinearMap (RingHom.id A) M₁ M₂\nι : Type w₁\ng₁ : ι → M₁\nself : pres₂.CokernelData f g₁\ni : ι\n⊢ Eq (pres₂.π (self.lift i)) (f (g₁ i))","decl":"/-- Given a linear map `f : M₁ →ₗ[A] M₂`, a presentation of `M₂` and a choice\nof generators of `M₁`, this structure specifies a lifting of the image by `f`\nof each generator of `M₁` as a linear combination of the generators of `M₂`. -/\nstructure CokernelData where\n  /-- a lifting of `f (g₁ i)` in `pres₂.G →₀ A` -/\n  lift (i : ι) : pres₂.G →₀ A\n  π_lift (i : ι) : pres₂.π (lift i) = f (g₁ i)\n\n"}
{"name":"Module.Presentation.CokernelData.mk.injEq","module":"Mathlib.Algebra.Module.Presentation.Cokernel","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nM₁ : Type v₁\nM₂ : Type v₂\ninst✝³ : AddCommGroup M₁\ninst✝² : Module A M₁\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module A M₂\npres₂ : Module.Presentation A M₂\nf : LinearMap (RingHom.id A) M₁ M₂\nι : Type w₁\ng₁ : ι → M₁\nlift✝ : ι → Finsupp pres₂.G A\nπ_lift✝ : ∀ (i : ι), Eq (pres₂.π (lift✝ i)) (f (g₁ i))\nlift : ι → Finsupp pres₂.G A\nπ_lift : ∀ (i : ι), Eq (pres₂.π (lift i)) (f (g₁ i))\n⊢ Eq (Eq { lift := lift✝, π_lift := π_lift✝ } { lift := lift, π_lift := π_lift }) (Eq lift✝ lift)","decl":"/-- Given a linear map `f : M₁ →ₗ[A] M₂`, a presentation of `M₂` and a choice\nof generators of `M₁`, this structure specifies a lifting of the image by `f`\nof each generator of `M₁` as a linear combination of the generators of `M₂`. -/\nstructure CokernelData where\n  /-- a lifting of `f (g₁ i)` in `pres₂.G →₀ A` -/\n  lift (i : ι) : pres₂.G →₀ A\n  π_lift (i : ι) : pres₂.π (lift i) = f (g₁ i)\n\n"}
{"name":"Module.Presentation.CokernelData.mk.sizeOf_spec","module":"Mathlib.Algebra.Module.Presentation.Cokernel","initialProofState":"A : Type u\ninst✝⁸ : Ring A\nM₁ : Type v₁\nM₂ : Type v₂\ninst✝⁷ : AddCommGroup M₁\ninst✝⁶ : Module A M₁\ninst✝⁵ : AddCommGroup M₂\ninst✝⁴ : Module A M₂\npres₂ : Module.Presentation A M₂\nf : LinearMap (RingHom.id A) M₁ M₂\nι : Type w₁\ng₁ : ι → M₁\ninst✝³ : SizeOf A\ninst✝² : SizeOf M₁\ninst✝¹ : SizeOf M₂\ninst✝ : SizeOf ι\nlift : ι → Finsupp pres₂.G A\nπ_lift : ∀ (i : ι), Eq (pres₂.π (lift i)) (f (g₁ i))\n⊢ Eq (SizeOf.sizeOf { lift := lift, π_lift := π_lift }) 1","decl":"/-- Given a linear map `f : M₁ →ₗ[A] M₂`, a presentation of `M₂` and a choice\nof generators of `M₁`, this structure specifies a lifting of the image by `f`\nof each generator of `M₁` as a linear combination of the generators of `M₂`. -/\nstructure CokernelData where\n  /-- a lifting of `f (g₁ i)` in `pres₂.G →₀ A` -/\n  lift (i : ι) : pres₂.G →₀ A\n  π_lift (i : ι) : pres₂.π (lift i) = f (g₁ i)\n\n"}
{"name":"Module.Presentation.CokernelData.mk.inj","module":"Mathlib.Algebra.Module.Presentation.Cokernel","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nM₁ : Type v₁\nM₂ : Type v₂\ninst✝³ : AddCommGroup M₁\ninst✝² : Module A M₁\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module A M₂\npres₂ : Module.Presentation A M₂\nf : LinearMap (RingHom.id A) M₁ M₂\nι : Type w₁\ng₁ : ι → M₁\nlift✝ : ι → Finsupp pres₂.G A\nπ_lift✝ : ∀ (i : ι), Eq (pres₂.π (lift✝ i)) (f (g₁ i))\nlift : ι → Finsupp pres₂.G A\nπ_lift : ∀ (i : ι), Eq (pres₂.π (lift i)) (f (g₁ i))\nx✝ : Eq { lift := lift✝, π_lift := π_lift✝ } { lift := lift, π_lift := π_lift }\n⊢ Eq lift✝ lift","decl":"/-- Given a linear map `f : M₁ →ₗ[A] M₂`, a presentation of `M₂` and a choice\nof generators of `M₁`, this structure specifies a lifting of the image by `f`\nof each generator of `M₁` as a linear combination of the generators of `M₂`. -/\nstructure CokernelData where\n  /-- a lifting of `f (g₁ i)` in `pres₂.G →₀ A` -/\n  lift (i : ι) : pres₂.G →₀ A\n  π_lift (i : ι) : pres₂.π (lift i) = f (g₁ i)\n\n"}
{"name":"Module.Presentation.CokernelData.ofSection_lift","module":"Mathlib.Algebra.Module.Presentation.Cokernel","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nM₁ : Type v₁\nM₂ : Type v₂\ninst✝³ : AddCommGroup M₁\ninst✝² : Module A M₁\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module A M₂\npres₂ : Module.Presentation A M₂\nf : LinearMap (RingHom.id A) M₁ M₂\nι : Type w₁\ng₁ : ι → M₁\ns : M₂ → Finsupp pres₂.G A\nhs : ∀ (m₂ : M₂), Eq (pres₂.π (s m₂)) m₂\ni : ι\n⊢ Eq ((Module.Presentation.CokernelData.ofSection pres₂ f g₁ s hs).lift i) (s (f (g₁ i)))","decl":"/-- Constructor for `Presentation.CokernelData` in case we have a chosen set-theoretic\nsection of the projection `(pres₂.G →₀ A) → M₂`. -/\n@[simps]\ndef CokernelData.ofSection (s : M₂ → (pres₂.G →₀ A))\n    (hs : ∀ (m₂ : M₂), pres₂.π (s m₂) = m₂) :\n    pres₂.CokernelData f g₁ where\n  lift i := s (f (g₁ i))\n  π_lift i := by simp [hs]\n\n"}
{"name":"Module.Presentation.nonempty_cokernelData","module":"Mathlib.Algebra.Module.Presentation.Cokernel","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nM₁ : Type v₁\nM₂ : Type v₂\ninst✝³ : AddCommGroup M₁\ninst✝² : Module A M₁\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module A M₂\npres₂ : Module.Presentation A M₂\nf : LinearMap (RingHom.id A) M₁ M₂\nι : Type w₁\ng₁ : ι → M₁\n⊢ Nonempty (pres₂.CokernelData f g₁)","decl":"instance nonempty_cokernelData :\n    Nonempty (pres₂.CokernelData f g₁) := by\n  obtain ⟨s, hs⟩ := pres₂.surjective_π.hasRightInverse\n  exact ⟨CokernelData.ofSection _ _ _ s hs⟩\n\n"}
{"name":"Module.Presentation.cokernelRelations_G","module":"Mathlib.Algebra.Module.Presentation.Cokernel","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nM₁ : Type v₁\nM₂ : Type v₂\ninst✝³ : AddCommGroup M₁\ninst✝² : Module A M₁\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module A M₂\npres₂ : Module.Presentation A M₂\nf : LinearMap (RingHom.id A) M₁ M₂\nι : Type w₁\ng₁ : ι → M₁\ndata : pres₂.CokernelData f g₁\n⊢ Eq (pres₂.cokernelRelations data).G pres₂.G","decl":"/-- The shape of the presentation by generators and relations of the cokernel\nof `f : M₁ →ₗ[A] M₂`. It consists of a generator for each generator of `M₂`, and\nthere are two types of relations: one for each relation in the presentation in `M₂`,\nand one for each generator of `M₁`. -/\n@[simps]\ndef cokernelRelations : Relations A where\n  G := pres₂.G\n  R := Sum pres₂.R ι\n  relation\n    | .inl r => pres₂.relation r\n    | .inr i => data.lift i\n\n"}
{"name":"Module.Presentation.cokernelRelations_R","module":"Mathlib.Algebra.Module.Presentation.Cokernel","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nM₁ : Type v₁\nM₂ : Type v₂\ninst✝³ : AddCommGroup M₁\ninst✝² : Module A M₁\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module A M₂\npres₂ : Module.Presentation A M₂\nf : LinearMap (RingHom.id A) M₁ M₂\nι : Type w₁\ng₁ : ι → M₁\ndata : pres₂.CokernelData f g₁\n⊢ Eq (pres₂.cokernelRelations data).R (Sum pres₂.R ι)","decl":"/-- The shape of the presentation by generators and relations of the cokernel\nof `f : M₁ →ₗ[A] M₂`. It consists of a generator for each generator of `M₂`, and\nthere are two types of relations: one for each relation in the presentation in `M₂`,\nand one for each generator of `M₁`. -/\n@[simps]\ndef cokernelRelations : Relations A where\n  G := pres₂.G\n  R := Sum pres₂.R ι\n  relation\n    | .inl r => pres₂.relation r\n    | .inr i => data.lift i\n\n"}
{"name":"Module.Presentation.cokernelRelations_relation","module":"Mathlib.Algebra.Module.Presentation.Cokernel","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nM₁ : Type v₁\nM₂ : Type v₂\ninst✝³ : AddCommGroup M₁\ninst✝² : Module A M₁\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module A M₂\npres₂ : Module.Presentation A M₂\nf : LinearMap (RingHom.id A) M₁ M₂\nι : Type w₁\ng₁ : ι → M₁\ndata : pres₂.CokernelData f g₁\nx✝ : Sum pres₂.R ι\n⊢ Eq ((pres₂.cokernelRelations data).relation x✝) (Module.Presentation.cokernelRelations.match_1 pres₂ (fun x => Finsupp pres₂.G A) x✝ (fun r => pres₂.relation r) fun i => data.lift i)","decl":"/-- The shape of the presentation by generators and relations of the cokernel\nof `f : M₁ →ₗ[A] M₂`. It consists of a generator for each generator of `M₂`, and\nthere are two types of relations: one for each relation in the presentation in `M₂`,\nand one for each generator of `M₁`. -/\n@[simps]\ndef cokernelRelations : Relations A where\n  G := pres₂.G\n  R := Sum pres₂.R ι\n  relation\n    | .inl r => pres₂.relation r\n    | .inr i => data.lift i\n\n"}
{"name":"Module.Presentation.cokernelSolution_var","module":"Mathlib.Algebra.Module.Presentation.Cokernel","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nM₁ : Type v₁\nM₂ : Type v₂\ninst✝³ : AddCommGroup M₁\ninst✝² : Module A M₁\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module A M₂\npres₂ : Module.Presentation A M₂\nf : LinearMap (RingHom.id A) M₁ M₂\nι : Type w₁\ng₁ : ι → M₁\ndata : pres₂.CokernelData f g₁\ng : (pres₂.cokernelRelations data).G\n⊢ Eq ((pres₂.cokernelSolution data).var g) ((LinearMap.range f).mkQ (pres₂.var g))","decl":"/-- The obvious solution in `M₂ ⧸ LinearMap.range f` to the equations in\n`pres₂.cokernelRelations data`. -/\n@[simps]\ndef cokernelSolution :\n    (pres₂.cokernelRelations data).Solution (M₂ ⧸ LinearMap.range f) where\n  var g := Submodule.mkQ _ (pres₂.var g)\n  linearCombination_var_relation := by\n    intro x\n    erw [← Finsupp.apply_linearCombination]\n    obtain (r | i) := x\n    · erw [pres₂.linearCombination_var_relation]\n      dsimp\n    · erw [data.π_lift]\n      simp\n\n"}
{"name":"Module.Presentation.cokernelSolution.isPresentation","module":"Mathlib.Algebra.Module.Presentation.Cokernel","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nM₁ : Type v₁\nM₂ : Type v₂\ninst✝³ : AddCommGroup M₁\ninst✝² : Module A M₁\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module A M₂\npres₂ : Module.Presentation A M₂\nf : LinearMap (RingHom.id A) M₁ M₂\nι : Type w₁\ng₁ : ι → M₁\ndata : pres₂.CokernelData f g₁\nhg₁ : Eq (Submodule.span A (Set.range g₁)) Top.top\n⊢ (pres₂.cokernelSolution data).IsPresentation","decl":"include hg₁ in\nlemma isPresentation : (pres₂.cokernelSolution data).IsPresentation :=\n  (isPresentationCore pres₂ data hg₁).isPresentation\n\n"}
{"name":"Module.Presentation.cokernel_R","module":"Mathlib.Algebra.Module.Presentation.Cokernel","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nM₁ : Type v₁\nM₂ : Type v₂\ninst✝³ : AddCommGroup M₁\ninst✝² : Module A M₁\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module A M₂\npres₂ : Module.Presentation A M₂\nf : LinearMap (RingHom.id A) M₁ M₂\nι : Type w₁\ng₁ : ι → M₁\ndata : pres₂.CokernelData f g₁\nhg₁ : Eq (Submodule.span A (Set.range g₁)) Top.top\n⊢ Eq (pres₂.cokernel data hg₁).R (Sum pres₂.R ι)","decl":"/-- The presentation of the cokernel of a linear map `f : M₁ →ₗ[A] M₂` that is obtained\nfrom a presentation `pres₂` of `M₂`, a choice of generators `g₁ : ι → M₁` of `M₁`,\nand an additional data in `pres₂.CokernelData f g₁`. -/\n@[simps!]\ndef cokernel : Presentation A (M₂ ⧸ LinearMap.range f) :=\n  ofIsPresentation (cokernelSolution.isPresentation pres₂ data hg₁)\n\n"}
{"name":"Module.Presentation.cokernel_var","module":"Mathlib.Algebra.Module.Presentation.Cokernel","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nM₁ : Type v₁\nM₂ : Type v₂\ninst✝³ : AddCommGroup M₁\ninst✝² : Module A M₁\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module A M₂\npres₂ : Module.Presentation A M₂\nf : LinearMap (RingHom.id A) M₁ M₂\nι : Type w₁\ng₁ : ι → M₁\ndata : pres₂.CokernelData f g₁\nhg₁ : Eq (Submodule.span A (Set.range g₁)) Top.top\ng : (pres₂.cokernelRelations data).G\n⊢ Eq ((pres₂.cokernel data hg₁).var g) (Submodule.Quotient.mk (pres₂.var g))","decl":"/-- The presentation of the cokernel of a linear map `f : M₁ →ₗ[A] M₂` that is obtained\nfrom a presentation `pres₂` of `M₂`, a choice of generators `g₁ : ι → M₁` of `M₁`,\nand an additional data in `pres₂.CokernelData f g₁`. -/\n@[simps!]\ndef cokernel : Presentation A (M₂ ⧸ LinearMap.range f) :=\n  ofIsPresentation (cokernelSolution.isPresentation pres₂ data hg₁)\n\n"}
{"name":"Module.Presentation.cokernel_G","module":"Mathlib.Algebra.Module.Presentation.Cokernel","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nM₁ : Type v₁\nM₂ : Type v₂\ninst✝³ : AddCommGroup M₁\ninst✝² : Module A M₁\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module A M₂\npres₂ : Module.Presentation A M₂\nf : LinearMap (RingHom.id A) M₁ M₂\nι : Type w₁\ng₁ : ι → M₁\ndata : pres₂.CokernelData f g₁\nhg₁ : Eq (Submodule.span A (Set.range g₁)) Top.top\n⊢ Eq (pres₂.cokernel data hg₁).G pres₂.G","decl":"/-- The presentation of the cokernel of a linear map `f : M₁ →ₗ[A] M₂` that is obtained\nfrom a presentation `pres₂` of `M₂`, a choice of generators `g₁ : ι → M₁` of `M₁`,\nand an additional data in `pres₂.CokernelData f g₁`. -/\n@[simps!]\ndef cokernel : Presentation A (M₂ ⧸ LinearMap.range f) :=\n  ofIsPresentation (cokernelSolution.isPresentation pres₂ data hg₁)\n\n"}
{"name":"Module.Presentation.cokernel_relation","module":"Mathlib.Algebra.Module.Presentation.Cokernel","initialProofState":"A : Type u\ninst✝⁴ : Ring A\nM₁ : Type v₁\nM₂ : Type v₂\ninst✝³ : AddCommGroup M₁\ninst✝² : Module A M₁\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module A M₂\npres₂ : Module.Presentation A M₂\nf : LinearMap (RingHom.id A) M₁ M₂\nι : Type w₁\ng₁ : ι → M₁\ndata : pres₂.CokernelData f g₁\nhg₁ : Eq (Submodule.span A (Set.range g₁)) Top.top\nr : (pres₂.cokernelRelations data).R\n⊢ Eq ((pres₂.cokernel data hg₁).relation r) (Module.Presentation.cokernelRelations.match_1 pres₂ (fun x => Finsupp pres₂.G A) r (fun r => pres₂.relation r) fun i => data.lift i)","decl":"/-- The presentation of the cokernel of a linear map `f : M₁ →ₗ[A] M₂` that is obtained\nfrom a presentation `pres₂` of `M₂`, a choice of generators `g₁ : ι → M₁` of `M₁`,\nand an additional data in `pres₂.CokernelData f g₁`. -/\n@[simps!]\ndef cokernel : Presentation A (M₂ ⧸ LinearMap.range f) :=\n  ofIsPresentation (cokernelSolution.isPresentation pres₂ data hg₁)\n\n"}
{"name":"Module.Presentation.ofExact_R","module":"Mathlib.Algebra.Module.Presentation.Cokernel","initialProofState":"A : Type u\ninst✝⁶ : Ring A\nM₁ : Type v₁\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁵ : AddCommGroup M₁\ninst✝⁴ : Module A M₁\ninst✝³ : AddCommGroup M₂\ninst✝² : Module A M₂\ninst✝¹ : AddCommGroup M₃\ninst✝ : Module A M₃\nf : LinearMap (RingHom.id A) M₁ M₂\ng : LinearMap (RingHom.id A) M₂ M₃\npres₂ : Module.Presentation A M₂\nι : Type w₁\ng₁ : ι → M₁\ndata : pres₂.CokernelData f g₁\nhfg : Function.Exact ⇑f ⇑g\nhg : Function.Surjective ⇑g\nhg₁ : Eq (Submodule.span A (Set.range g₁)) Top.top\n⊢ Eq (pres₂.ofExact data hfg hg hg₁).R (Sum pres₂.R ι)","decl":"/-- Given an exact sequence of `A`-modules `M₁ → M₂ → M₃ → 0`, this is the presentation\nof `M₃` that is obtained from a presentation `pres₂` of `M₂`, a choice of generators\n`g₁ : ι → M₁` of `M₁`, and an additional data in a `Presentation.CokernelData` structure. -/\n@[simps!]\nnoncomputable def ofExact {f : M₁ →ₗ[A] M₂} {g : M₂ →ₗ[A] M₃}\n    (pres₂ : Presentation.{w₂₀, w₂₁} A M₂) {ι : Type w₁} {g₁ : ι → M₁}\n    (data : pres₂.CokernelData f g₁)\n    (hfg : Function.Exact f g) (hg : Function.Surjective g)\n    (hg₁ : Submodule.span A (Set.range g₁) = ⊤) :\n    Presentation A M₃ :=\n  (pres₂.cokernel data hg₁).ofLinearEquiv (hfg.linearEquivOfSurjective hg)\n\n"}
{"name":"Module.Presentation.ofExact_relation","module":"Mathlib.Algebra.Module.Presentation.Cokernel","initialProofState":"A : Type u\ninst✝⁶ : Ring A\nM₁ : Type v₁\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁵ : AddCommGroup M₁\ninst✝⁴ : Module A M₁\ninst✝³ : AddCommGroup M₂\ninst✝² : Module A M₂\ninst✝¹ : AddCommGroup M₃\ninst✝ : Module A M₃\nf : LinearMap (RingHom.id A) M₁ M₂\ng : LinearMap (RingHom.id A) M₂ M₃\npres₂ : Module.Presentation A M₂\nι : Type w₁\ng₁ : ι → M₁\ndata : pres₂.CokernelData f g₁\nhfg : Function.Exact ⇑f ⇑g\nhg : Function.Surjective ⇑g\nhg₁ : Eq (Submodule.span A (Set.range g₁)) Top.top\nr : (pres₂.cokernel data hg₁).R\n⊢ Eq ((pres₂.ofExact data hfg hg hg₁).relation r) (Module.Presentation.cokernelRelations.match_1 pres₂ (fun x => Finsupp pres₂.G A) r (fun r => pres₂.relation r) fun i => data.lift i)","decl":"/-- Given an exact sequence of `A`-modules `M₁ → M₂ → M₃ → 0`, this is the presentation\nof `M₃` that is obtained from a presentation `pres₂` of `M₂`, a choice of generators\n`g₁ : ι → M₁` of `M₁`, and an additional data in a `Presentation.CokernelData` structure. -/\n@[simps!]\nnoncomputable def ofExact {f : M₁ →ₗ[A] M₂} {g : M₂ →ₗ[A] M₃}\n    (pres₂ : Presentation.{w₂₀, w₂₁} A M₂) {ι : Type w₁} {g₁ : ι → M₁}\n    (data : pres₂.CokernelData f g₁)\n    (hfg : Function.Exact f g) (hg : Function.Surjective g)\n    (hg₁ : Submodule.span A (Set.range g₁) = ⊤) :\n    Presentation A M₃ :=\n  (pres₂.cokernel data hg₁).ofLinearEquiv (hfg.linearEquivOfSurjective hg)\n\n"}
{"name":"Module.Presentation.ofExact_var","module":"Mathlib.Algebra.Module.Presentation.Cokernel","initialProofState":"A : Type u\ninst✝⁶ : Ring A\nM₁ : Type v₁\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁵ : AddCommGroup M₁\ninst✝⁴ : Module A M₁\ninst✝³ : AddCommGroup M₂\ninst✝² : Module A M₂\ninst✝¹ : AddCommGroup M₃\ninst✝ : Module A M₃\nf : LinearMap (RingHom.id A) M₁ M₂\ng✝ : LinearMap (RingHom.id A) M₂ M₃\npres₂ : Module.Presentation A M₂\nι : Type w₁\ng₁ : ι → M₁\ndata : pres₂.CokernelData f g₁\nhfg : Function.Exact ⇑f ⇑g✝\nhg : Function.Surjective ⇑g✝\nhg₁ : Eq (Submodule.span A (Set.range g₁)) Top.top\ng : (pres₂.cokernel data hg₁).G\n⊢ Eq ((pres₂.ofExact data hfg hg hg₁).var g) (g✝ (pres₂.var g))","decl":"/-- Given an exact sequence of `A`-modules `M₁ → M₂ → M₃ → 0`, this is the presentation\nof `M₃` that is obtained from a presentation `pres₂` of `M₂`, a choice of generators\n`g₁ : ι → M₁` of `M₁`, and an additional data in a `Presentation.CokernelData` structure. -/\n@[simps!]\nnoncomputable def ofExact {f : M₁ →ₗ[A] M₂} {g : M₂ →ₗ[A] M₃}\n    (pres₂ : Presentation.{w₂₀, w₂₁} A M₂) {ι : Type w₁} {g₁ : ι → M₁}\n    (data : pres₂.CokernelData f g₁)\n    (hfg : Function.Exact f g) (hg : Function.Surjective g)\n    (hg₁ : Submodule.span A (Set.range g₁) = ⊤) :\n    Presentation A M₃ :=\n  (pres₂.cokernel data hg₁).ofLinearEquiv (hfg.linearEquivOfSurjective hg)\n\n"}
{"name":"Module.Presentation.ofExact_G","module":"Mathlib.Algebra.Module.Presentation.Cokernel","initialProofState":"A : Type u\ninst✝⁶ : Ring A\nM₁ : Type v₁\nM₂ : Type v₂\nM₃ : Type v₃\ninst✝⁵ : AddCommGroup M₁\ninst✝⁴ : Module A M₁\ninst✝³ : AddCommGroup M₂\ninst✝² : Module A M₂\ninst✝¹ : AddCommGroup M₃\ninst✝ : Module A M₃\nf : LinearMap (RingHom.id A) M₁ M₂\ng : LinearMap (RingHom.id A) M₂ M₃\npres₂ : Module.Presentation A M₂\nι : Type w₁\ng₁ : ι → M₁\ndata : pres₂.CokernelData f g₁\nhfg : Function.Exact ⇑f ⇑g\nhg : Function.Surjective ⇑g\nhg₁ : Eq (Submodule.span A (Set.range g₁)) Top.top\n⊢ Eq (pres₂.ofExact data hfg hg hg₁).G pres₂.G","decl":"/-- Given an exact sequence of `A`-modules `M₁ → M₂ → M₃ → 0`, this is the presentation\nof `M₃` that is obtained from a presentation `pres₂` of `M₂`, a choice of generators\n`g₁ : ι → M₁` of `M₁`, and an additional data in a `Presentation.CokernelData` structure. -/\n@[simps!]\nnoncomputable def ofExact {f : M₁ →ₗ[A] M₂} {g : M₂ →ₗ[A] M₃}\n    (pres₂ : Presentation.{w₂₀, w₂₁} A M₂) {ι : Type w₁} {g₁ : ι → M₁}\n    (data : pres₂.CokernelData f g₁)\n    (hfg : Function.Exact f g) (hg : Function.Surjective g)\n    (hg₁ : Submodule.span A (Set.range g₁) = ⊤) :\n    Presentation A M₃ :=\n  (pres₂.cokernel data hg₁).ofLinearEquiv (hfg.linearEquivOfSurjective hg)\n\n"}
