{"name":"Filter.lift_top","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ng : Set Î± â†’ Filter Î²\nâŠ¢ Eq (Top.top.lift g) (g Set.univ)","decl":"@[simp]\ntheorem lift_top (g : Set Î± â†’ Filter Î²) : (âŠ¤ : Filter Î±).lift g = g univ := by simp [Filter.lift]\n\n-- Porting note: use `âˆƒ i, p i âˆ§ _` instead of `âˆƒ i (hi : p i), _`\n"}
{"name":"Filter.HasBasis.mem_lift_iff","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ³ : Type u_3\nÎ¹ : Sort u_6\np : Î¹ â†’ Prop\nsâœ : Î¹ â†’ Set Î±\nf : Filter Î±\nhf : f.HasBasis p sâœ\nÎ² : Î¹ â†’ Type u_5\npg : (i : Î¹) â†’ Î² i â†’ Prop\nsg : (i : Î¹) â†’ Î² i â†’ Set Î³\ng : Set Î± â†’ Filter Î³\nhg : âˆ€ (i : Î¹), (g (sâœ i)).HasBasis (pg i) (sg i)\ngm : Monotone g\ns : Set Î³\nâŠ¢ Iff (Membership.mem (f.lift g) s) (Exists fun i => And (p i) (Exists fun x => And (pg i x) (HasSubset.Subset (sg i x) s)))","decl":"/-- If `(p : Î¹ â†’ Prop, s : Î¹ â†’ Set Î±)` is a basis of a filter `f`, `g` is a monotone function\n`Set Î± â†’ Filter Î³`, and for each `i`, `(pg : Î² i â†’ Prop, sg : Î² i â†’ Set Î±)` is a basis\nof the filter `g (s i)`, then\n`(fun (i : Î¹) (x : Î² i) â†¦ p i âˆ§ pg i x, fun (i : Î¹) (x : Î² i) â†¦ sg i x)` is a basis\nof the filter `f.lift g`.\n\nThis basis is parametrized by `i : Î¹` and `x : Î² i`, so in order to formulate this fact using\n`Filter.HasBasis` one has to use `Î£ i, Î² i` as the index type, see `Filter.HasBasis.lift`.\nThis lemma states the corresponding `mem_iff` statement without using a sigma type. -/\ntheorem HasBasis.mem_lift_iff {Î¹} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} {f : Filter Î±}\n    (hf : f.HasBasis p s) {Î² : Î¹ â†’ Type*} {pg : âˆ€ i, Î² i â†’ Prop} {sg : âˆ€ i, Î² i â†’ Set Î³}\n    {g : Set Î± â†’ Filter Î³} (hg : âˆ€ i, (g <| s i).HasBasis (pg i) (sg i)) (gm : Monotone g)\n    {s : Set Î³} : s âˆˆ f.lift g â†” âˆƒ i, p i âˆ§ âˆƒ x, pg i x âˆ§ sg i x âŠ† s := by\n  refine (mem_biInf_of_directed ?_ âŸ¨univ, univ_sets _âŸ©).trans ?_\n  Â· intro tâ‚ htâ‚ tâ‚‚ htâ‚‚\n    exact âŸ¨tâ‚ âˆ© tâ‚‚, inter_mem htâ‚ htâ‚‚, gm inter_subset_left, gm inter_subset_rightâŸ©\n  Â· simp only [â† (hg _).mem_iff]\n    exact hf.exists_iff fun tâ‚ tâ‚‚ ht H => gm ht H\n\n"}
{"name":"Filter.HasBasis.lift","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ³ : Type u_3\nÎ¹ : Type u_6\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nf : Filter Î±\nhf : f.HasBasis p s\nÎ² : Î¹ â†’ Type u_5\npg : (i : Î¹) â†’ Î² i â†’ Prop\nsg : (i : Î¹) â†’ Î² i â†’ Set Î³\ng : Set Î± â†’ Filter Î³\nhg : âˆ€ (i : Î¹), (g (s i)).HasBasis (pg i) (sg i)\ngm : Monotone g\nâŠ¢ (f.lift g).HasBasis (fun i => And (p i.fst) (pg i.fst i.snd)) fun i => sg i.fst i.snd","decl":"/-- If `(p : Î¹ â†’ Prop, s : Î¹ â†’ Set Î±)` is a basis of a filter `f`, `g` is a monotone function\n`Set Î± â†’ Filter Î³`, and for each `i`, `(pg : Î² i â†’ Prop, sg : Î² i â†’ Set Î±)` is a basis\nof the filter `g (s i)`, then\n`(fun (i : Î¹) (x : Î² i) â†¦ p i âˆ§ pg i x, fun (i : Î¹) (x : Î² i) â†¦ sg i x)`\nis a basis of the filter `f.lift g`.\n\nThis basis is parametrized by `i : Î¹` and `x : Î² i`, so in order to formulate this fact using\n`has_basis` one has to use `Î£ i, Î² i` as the index type. See also `Filter.HasBasis.mem_lift_iff`\nfor the corresponding `mem_iff` statement formulated without using a sigma type. -/\ntheorem HasBasis.lift {Î¹} {p : Î¹ â†’ Prop} {s : Î¹ â†’ Set Î±} {f : Filter Î±} (hf : f.HasBasis p s)\n    {Î² : Î¹ â†’ Type*} {pg : âˆ€ i, Î² i â†’ Prop} {sg : âˆ€ i, Î² i â†’ Set Î³} {g : Set Î± â†’ Filter Î³}\n    (hg : âˆ€ i, (g (s i)).HasBasis (pg i) (sg i)) (gm : Monotone g) :\n    (f.lift g).HasBasis (fun i : Î£i, Î² i => p i.1 âˆ§ pg i.1 i.2) fun i : Î£i, Î² i => sg i.1 i.2 := by\n  refine âŸ¨fun t => (hf.mem_lift_iff hg gm).trans ?_âŸ©\n  simp [Sigma.exists, and_assoc, exists_and_left]\n\n"}
{"name":"Filter.mem_lift_sets","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\ng : Set Î± â†’ Filter Î²\nhg : Monotone g\ns : Set Î²\nâŠ¢ Iff (Membership.mem (f.lift g) s) (Exists fun t => And (Membership.mem f t) (Membership.mem (g t) s))","decl":"theorem mem_lift_sets (hg : Monotone g) {s : Set Î²} : s âˆˆ f.lift g â†” âˆƒ t âˆˆ f, s âˆˆ g t :=\n  (f.basis_sets.mem_lift_iff (fun s => (g s).basis_sets) hg).trans <| by\n    simp only [id, exists_mem_subset_iff]\n\n"}
{"name":"Filter.sInter_lift_sets","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\ng : Set Î± â†’ Filter Î²\nhg : Monotone g\nâŠ¢ Eq (setOf fun s => Membership.mem (f.lift g) s).sInter (Set.iInter fun s => Set.iInter fun h => (setOf fun t => Membership.mem (g s) t).sInter)","decl":"theorem sInter_lift_sets (hg : Monotone g) :\n    â‹‚â‚€ { s | s âˆˆ f.lift g } = â‹‚ s âˆˆ f, â‹‚â‚€ { t | t âˆˆ g s } := by\n  simp only [sInter_eq_biInter, mem_setOf_eq, Filter.mem_sets, mem_lift_sets hg, iInter_exists,\n    iInter_and, @iInter_comm _ (Set Î²)]\n\n"}
{"name":"Filter.mem_lift","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\ng : Set Î± â†’ Filter Î²\ns : Set Î²\nt : Set Î±\nht : Membership.mem f t\nhs : Membership.mem (g t) s\nâŠ¢ Membership.mem (f.lift g) s","decl":"theorem mem_lift {s : Set Î²} {t : Set Î±} (ht : t âˆˆ f) (hs : s âˆˆ g t) : s âˆˆ f.lift g :=\n  le_principal_iff.mp <|\n    show f.lift g â‰¤ ğ“Ÿ s from iInf_le_of_le t <| iInf_le_of_le ht <| le_principal_iff.mpr hs\n\n"}
{"name":"Filter.lift_le","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\ng : Set Î± â†’ Filter Î²\nh : Filter Î²\ns : Set Î±\nhs : Membership.mem f s\nhg : LE.le (g s) h\nâŠ¢ LE.le (f.lift g) h","decl":"theorem lift_le {f : Filter Î±} {g : Set Î± â†’ Filter Î²} {h : Filter Î²} {s : Set Î±} (hs : s âˆˆ f)\n    (hg : g s â‰¤ h) : f.lift g â‰¤ h :=\n  iInfâ‚‚_le_of_le s hs hg\n\n"}
{"name":"Filter.le_lift","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\ng : Set Î± â†’ Filter Î²\nh : Filter Î²\nâŠ¢ Iff (LE.le h (f.lift g)) (âˆ€ (s : Set Î±), Membership.mem f s â†’ LE.le h (g s))","decl":"theorem le_lift {f : Filter Î±} {g : Set Î± â†’ Filter Î²} {h : Filter Î²} :\n    h â‰¤ f.lift g â†” âˆ€ s âˆˆ f, h â‰¤ g s :=\n  le_iInfâ‚‚_iff\n\n"}
{"name":"Filter.lift_mono","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nfâ‚ fâ‚‚ : Filter Î±\ngâ‚ gâ‚‚ : Set Î± â†’ Filter Î²\nhf : LE.le fâ‚ fâ‚‚\nhg : LE.le gâ‚ gâ‚‚\nâŠ¢ LE.le (fâ‚.lift gâ‚) (fâ‚‚.lift gâ‚‚)","decl":"theorem lift_mono (hf : fâ‚ â‰¤ fâ‚‚) (hg : gâ‚ â‰¤ gâ‚‚) : fâ‚.lift gâ‚ â‰¤ fâ‚‚.lift gâ‚‚ :=\n  iInf_mono fun s => iInf_mono' fun hs => âŸ¨hf hs, hg sâŸ©\n\n"}
{"name":"Filter.lift_mono'","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\ngâ‚ gâ‚‚ : Set Î± â†’ Filter Î²\nhg : âˆ€ (s : Set Î±), Membership.mem f s â†’ LE.le (gâ‚ s) (gâ‚‚ s)\nâŠ¢ LE.le (f.lift gâ‚) (f.lift gâ‚‚)","decl":"theorem lift_mono' (hg : âˆ€ s âˆˆ f, gâ‚ s â‰¤ gâ‚‚ s) : f.lift gâ‚ â‰¤ f.lift gâ‚‚ := iInfâ‚‚_mono hg\n\n"}
{"name":"Filter.tendsto_lift","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Filter Î±\ng : Set Î± â†’ Filter Î²\nm : Î³ â†’ Î²\nl : Filter Î³\nâŠ¢ Iff (Filter.Tendsto m l (f.lift g)) (âˆ€ (s : Set Î±), Membership.mem f s â†’ Filter.Tendsto m l (g s))","decl":"theorem tendsto_lift {m : Î³ â†’ Î²} {l : Filter Î³} :\n    Tendsto m l (f.lift g) â†” âˆ€ s âˆˆ f, Tendsto m l (g s) := by\n  simp only [Filter.lift, tendsto_iInf]\n\n"}
{"name":"Filter.map_lift_eq","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Filter Î±\ng : Set Î± â†’ Filter Î²\nm : Î² â†’ Î³\nhg : Monotone g\nâŠ¢ Eq (Filter.map m (f.lift g)) (f.lift (Function.comp (Filter.map m) g))","decl":"theorem map_lift_eq {m : Î² â†’ Î³} (hg : Monotone g) : map m (f.lift g) = f.lift (map m âˆ˜ g) :=\n  have : Monotone (map m âˆ˜ g) := map_mono.comp hg\n  Filter.ext fun s => by\n    simp only [mem_lift_sets hg, mem_lift_sets this, exists_prop, mem_map, Function.comp_apply]\n\n"}
{"name":"Filter.comap_lift_eq","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Filter Î±\ng : Set Î± â†’ Filter Î²\nm : Î³ â†’ Î²\nâŠ¢ Eq (Filter.comap m (f.lift g)) (f.lift (Function.comp (Filter.comap m) g))","decl":"theorem comap_lift_eq {m : Î³ â†’ Î²} : comap m (f.lift g) = f.lift (comap m âˆ˜ g) := by\n  simp only [Filter.lift, comap_iInf]; rfl\n\n"}
{"name":"Filter.comap_lift_eq2","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Filter Î±\nm : Î² â†’ Î±\ng : Set Î² â†’ Filter Î³\nhg : Monotone g\nâŠ¢ Eq ((Filter.comap m f).lift g) (f.lift (Function.comp g (Set.preimage m)))","decl":"theorem comap_lift_eq2 {m : Î² â†’ Î±} {g : Set Î² â†’ Filter Î³} (hg : Monotone g) :\n    (comap m f).lift g = f.lift (g âˆ˜ preimage m) :=\n  le_antisymm (le_iInfâ‚‚ fun s hs => iInfâ‚‚_le (m â»Â¹' s) âŸ¨s, hs, Subset.rflâŸ©)\n    (le_iInfâ‚‚ fun _s âŸ¨s', hs', h_subâŸ© => iInfâ‚‚_le_of_le s' hs' <| hg h_sub)\n\n"}
{"name":"Filter.lift_map_le","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Filter Î±\ng : Set Î² â†’ Filter Î³\nm : Î± â†’ Î²\nâŠ¢ LE.le ((Filter.map m f).lift g) (f.lift (Function.comp g (Set.image m)))","decl":"theorem lift_map_le {g : Set Î² â†’ Filter Î³} {m : Î± â†’ Î²} : (map m f).lift g â‰¤ f.lift (g âˆ˜ image m) :=\n  le_lift.2 fun _s hs => lift_le (image_mem_map hs) le_rfl\n\n"}
{"name":"Filter.map_lift_eq2","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Filter Î±\ng : Set Î² â†’ Filter Î³\nm : Î± â†’ Î²\nhg : Monotone g\nâŠ¢ Eq ((Filter.map m f).lift g) (f.lift (Function.comp g (Set.image m)))","decl":"theorem map_lift_eq2 {g : Set Î² â†’ Filter Î³} {m : Î± â†’ Î²} (hg : Monotone g) :\n    (map m f).lift g = f.lift (g âˆ˜ image m) :=\n  lift_map_le.antisymm <| le_lift.2 fun _s hs => lift_le hs <| hg <| image_preimage_subset _ _\n\n"}
{"name":"Filter.lift_comm","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Filter Î±\ng : Filter Î²\nh : Set Î± â†’ Set Î² â†’ Filter Î³\nâŠ¢ Eq (f.lift fun s => g.lift (h s)) (g.lift fun t => f.lift fun s => h s t)","decl":"theorem lift_comm {g : Filter Î²} {h : Set Î± â†’ Set Î² â†’ Filter Î³} :\n    (f.lift fun s => g.lift (h s)) = g.lift fun t => f.lift fun s => h s t :=\n  le_antisymm\n    (le_iInf fun i => le_iInf fun hi => le_iInf fun j => le_iInf fun hj =>\n      iInf_le_of_le j <| iInf_le_of_le hj <| iInf_le_of_le i <| iInf_le _ hi)\n    (le_iInf fun i => le_iInf fun hi => le_iInf fun j => le_iInf fun hj =>\n      iInf_le_of_le j <| iInf_le_of_le hj <| iInf_le_of_le i <| iInf_le _ hi)\n\n"}
{"name":"Filter.lift_assoc","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Filter Î±\ng : Set Î± â†’ Filter Î²\nh : Set Î² â†’ Filter Î³\nhg : Monotone g\nâŠ¢ Eq ((f.lift g).lift h) (f.lift fun s => (g s).lift h)","decl":"theorem lift_assoc {h : Set Î² â†’ Filter Î³} (hg : Monotone g) :\n    (f.lift g).lift h = f.lift fun s => (g s).lift h :=\n  le_antisymm\n    (le_iInfâ‚‚ fun _s hs => le_iInfâ‚‚ fun t ht =>\n      iInf_le_of_le t <| iInf_le _ <| (mem_lift_sets hg).mpr âŸ¨_, hs, htâŸ©)\n    (le_iInfâ‚‚ fun t ht =>\n      let âŸ¨s, hs, h'âŸ© := (mem_lift_sets hg).mp ht\n      iInf_le_of_le s <| iInf_le_of_le hs <| iInf_le_of_le t <| iInf_le _ h')\n\n"}
{"name":"Filter.lift_lift_same_le_lift","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\ng : Set Î± â†’ Set Î± â†’ Filter Î²\nâŠ¢ LE.le (f.lift fun s => f.lift (g s)) (f.lift fun s => g s s)","decl":"theorem lift_lift_same_le_lift {g : Set Î± â†’ Set Î± â†’ Filter Î²} :\n    (f.lift fun s => f.lift (g s)) â‰¤ f.lift fun s => g s s :=\n  le_lift.2 fun _s hs => lift_le hs <| lift_le hs le_rfl\n\n"}
{"name":"Filter.lift_lift_same_eq_lift","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\ng : Set Î± â†’ Set Î± â†’ Filter Î²\nhgâ‚ : âˆ€ (s : Set Î±), Monotone fun t => g s t\nhgâ‚‚ : âˆ€ (t : Set Î±), Monotone fun s => g s t\nâŠ¢ Eq (f.lift fun s => f.lift (g s)) (f.lift fun s => g s s)","decl":"theorem lift_lift_same_eq_lift {g : Set Î± â†’ Set Î± â†’ Filter Î²} (hgâ‚ : âˆ€ s, Monotone fun t => g s t)\n    (hgâ‚‚ : âˆ€ t, Monotone fun s => g s t) : (f.lift fun s => f.lift (g s)) = f.lift fun s => g s s :=\n  lift_lift_same_le_lift.antisymm <|\n    le_lift.2 fun s hs => le_lift.2 fun t ht => lift_le (inter_mem hs ht) <|\n      calc\n        g (s âˆ© t) (s âˆ© t) â‰¤ g s (s âˆ© t) := hgâ‚‚ (s âˆ© t) inter_subset_left\n        _ â‰¤ g s t := hgâ‚ s inter_subset_right\n\n"}
{"name":"Filter.lift_principal","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ng : Set Î± â†’ Filter Î²\ns : Set Î±\nhg : Monotone g\nâŠ¢ Eq ((Filter.principal s).lift g) (g s)","decl":"theorem lift_principal {s : Set Î±} (hg : Monotone g) : (ğ“Ÿ s).lift g = g s :=\n  (lift_le (mem_principal_self _) le_rfl).antisymm (le_lift.2 fun _t ht => hg ht)\n\n"}
{"name":"Filter.monotone_lift","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœ : Preorder Î³\nf : Î³ â†’ Filter Î±\ng : Î³ â†’ Set Î± â†’ Filter Î²\nhf : Monotone f\nhg : Monotone g\nâŠ¢ Monotone fun c => (f c).lift (g c)","decl":"theorem monotone_lift [Preorder Î³] {f : Î³ â†’ Filter Î±} {g : Î³ â†’ Set Î± â†’ Filter Î²} (hf : Monotone f)\n    (hg : Monotone g) : Monotone fun c => (f c).lift (g c) := fun _ _ h => lift_mono (hf h) (hg h)\n\n"}
{"name":"Filter.lift_neBot_iff","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\ng : Set Î± â†’ Filter Î²\nhm : Monotone g\nâŠ¢ Iff (f.lift g).NeBot (âˆ€ (s : Set Î±), Membership.mem f s â†’ (g s).NeBot)","decl":"theorem lift_neBot_iff (hm : Monotone g) : (NeBot (f.lift g)) â†” âˆ€ s âˆˆ f, NeBot (g s) := by\n  simp only [neBot_iff, Ne, â† empty_mem_iff_bot, mem_lift_sets hm, not_exists, not_and]\n\n"}
{"name":"Filter.lift_const","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\ng : Filter Î²\nâŠ¢ Eq (f.lift fun x => g) g","decl":"@[simp]\ntheorem lift_const {f : Filter Î±} {g : Filter Î²} : (f.lift fun _ => g) = g :=\n  iInf_subtype'.trans iInf_const\n\n"}
{"name":"Filter.lift_inf","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\ng h : Set Î± â†’ Filter Î²\nâŠ¢ Eq (f.lift fun x => Min.min (g x) (h x)) (Min.min (f.lift g) (f.lift h))","decl":"@[simp]\ntheorem lift_inf {f : Filter Î±} {g h : Set Î± â†’ Filter Î²} :\n    (f.lift fun x => g x âŠ“ h x) = f.lift g âŠ“ f.lift h := by simp only [Filter.lift, iInf_inf_eq]\n\n"}
{"name":"Filter.lift_principal2","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nf : Filter Î±\nâŠ¢ Eq (f.lift Filter.principal) f","decl":"@[simp]\ntheorem lift_principal2 {f : Filter Î±} : f.lift ğ“Ÿ = f :=\n  le_antisymm (fun s hs => mem_lift hs (mem_principal_self s))\n    (le_iInf fun s => le_iInf fun hs => by simp only [hs, le_principal_iff])\n\n"}
{"name":"Filter.lift_iInf_le","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\nf : Î¹ â†’ Filter Î±\ng : Set Î± â†’ Filter Î²\nâŠ¢ LE.le ((iInf f).lift g) (iInf fun i => (f i).lift g)","decl":"theorem lift_iInf_le {f : Î¹ â†’ Filter Î±} {g : Set Î± â†’ Filter Î²} :\n    (iInf f).lift g â‰¤ â¨… i, (f i).lift g :=\n  le_iInf fun _ => lift_mono (iInf_le _ _) le_rfl\n\n"}
{"name":"Filter.lift_iInf","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\ninstâœ : Nonempty Î¹\nf : Î¹ â†’ Filter Î±\ng : Set Î± â†’ Filter Î²\nhg : âˆ€ (s t : Set Î±), Eq (g (Inter.inter s t)) (Min.min (g s) (g t))\nâŠ¢ Eq ((iInf f).lift g) (iInf fun i => (f i).lift g)","decl":"theorem lift_iInf [Nonempty Î¹] {f : Î¹ â†’ Filter Î±} {g : Set Î± â†’ Filter Î²}\n    (hg : âˆ€ s t, g (s âˆ© t) = g s âŠ“ g t) : (iInf f).lift g = â¨… i, (f i).lift g := by\n  refine lift_iInf_le.antisymm fun s => ?_\n  have H : âˆ€ t âˆˆ iInf f, â¨… i, (f i).lift g â‰¤ g t := by\n    intro t ht\n    refine iInf_sets_induct ht ?_ fun hs ht => ?_\n    Â· inhabit Î¹\n      exact iInfâ‚‚_le_of_le default univ (iInf_le _ univ_mem)\n    Â· rw [hg]\n      exact le_inf (iInfâ‚‚_le_of_le _ _ <| iInf_le _ hs) ht\n  simp only [mem_lift_sets (Monotone.of_map_inf hg), exists_imp, and_imp]\n  exact fun t ht hs => H t ht hs\n\n"}
{"name":"Filter.lift_iInf_of_directed","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\ninstâœ : Nonempty Î¹\nf : Î¹ â†’ Filter Î±\ng : Set Î± â†’ Filter Î²\nhf : Directed (fun x1 x2 => GE.ge x1 x2) f\nhg : Monotone g\nâŠ¢ Eq ((iInf f).lift g) (iInf fun i => (f i).lift g)","decl":"theorem lift_iInf_of_directed [Nonempty Î¹] {f : Î¹ â†’ Filter Î±} {g : Set Î± â†’ Filter Î²}\n    (hf : Directed (Â· â‰¥ Â·) f) (hg : Monotone g) : (iInf f).lift g = â¨… i, (f i).lift g :=\n  lift_iInf_le.antisymm fun s => by\n    simp only [mem_lift_sets hg, exists_imp, and_imp, mem_iInf_of_directed hf]\n    exact fun t i ht hs => mem_iInf_of_mem i <| mem_lift ht hs\n\n"}
{"name":"Filter.lift_iInf_of_map_univ","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\nf : Î¹ â†’ Filter Î±\ng : Set Î± â†’ Filter Î²\nhg : âˆ€ (s t : Set Î±), Eq (g (Inter.inter s t)) (Min.min (g s) (g t))\nhg' : Eq (g Set.univ) Top.top\nâŠ¢ Eq ((iInf f).lift g) (iInf fun i => (f i).lift g)","decl":"theorem lift_iInf_of_map_univ {f : Î¹ â†’ Filter Î±} {g : Set Î± â†’ Filter Î²}\n    (hg : âˆ€ s t, g (s âˆ© t) = g s âŠ“ g t) (hg' : g univ = âŠ¤) :\n    (iInf f).lift g = â¨… i, (f i).lift g := by\n  cases isEmpty_or_nonempty Î¹\n  Â· simp [iInf_of_empty, hg']\n  Â· exact lift_iInf hg\n\n"}
{"name":"Filter.lift'_top","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nh : Set Î± â†’ Set Î²\nâŠ¢ Eq (Top.top.lift' h) (Filter.principal (h Set.univ))","decl":"@[simp]\ntheorem lift'_top (h : Set Î± â†’ Set Î²) : (âŠ¤ : Filter Î±).lift' h = ğ“Ÿ (h univ) :=\n  lift_top _\n\n"}
{"name":"Filter.mem_lift'","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\nh : Set Î± â†’ Set Î²\nt : Set Î±\nht : Membership.mem f t\nâŠ¢ Membership.mem (f.lift' h) (h t)","decl":"theorem mem_lift' {t : Set Î±} (ht : t âˆˆ f) : h t âˆˆ f.lift' h :=\n  le_principal_iff.mp <| show f.lift' h â‰¤ ğ“Ÿ (h t) from iInf_le_of_le t <| iInf_le_of_le ht <| le_rfl\n\n"}
{"name":"Filter.tendsto_lift'","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Filter Î±\nh : Set Î± â†’ Set Î²\nm : Î³ â†’ Î²\nl : Filter Î³\nâŠ¢ Iff (Filter.Tendsto m l (f.lift' h)) (âˆ€ (s : Set Î±), Membership.mem f s â†’ Filter.Eventually (fun a => Membership.mem (h s) (m a)) l)","decl":"theorem tendsto_lift' {m : Î³ â†’ Î²} {l : Filter Î³} :\n    Tendsto m l (f.lift' h) â†” âˆ€ s âˆˆ f, âˆ€á¶  a in l, m a âˆˆ h s := by\n  simp only [Filter.lift', tendsto_lift, tendsto_principal, comp]\n\n"}
{"name":"Filter.HasBasis.lift'","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\nh : Set Î± â†’ Set Î²\nÎ¹ : Sort u_5\np : Î¹ â†’ Prop\ns : Î¹ â†’ Set Î±\nhf : f.HasBasis p s\nhh : Monotone h\nâŠ¢ (f.lift' h).HasBasis p (Function.comp h s)","decl":"theorem HasBasis.lift' {Î¹} {p : Î¹ â†’ Prop} {s} (hf : f.HasBasis p s) (hh : Monotone h) :\n    (f.lift' h).HasBasis p (h âˆ˜ s) :=\n  âŸ¨fun t => (hf.mem_lift_iff (fun i => hasBasis_principal (h (s i)))\n    (monotone_principal.comp hh)).trans <| by simp only [exists_const, true_and, comp]âŸ©\n\n"}
{"name":"Filter.mem_lift'_sets","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\nh : Set Î± â†’ Set Î²\nhh : Monotone h\ns : Set Î²\nâŠ¢ Iff (Membership.mem (f.lift' h) s) (Exists fun t => And (Membership.mem f t) (HasSubset.Subset (h t) s))","decl":"theorem mem_lift'_sets (hh : Monotone h) {s : Set Î²} : s âˆˆ f.lift' h â†” âˆƒ t âˆˆ f, h t âŠ† s :=\n  mem_lift_sets <| monotone_principal.comp hh\n\n"}
{"name":"Filter.eventually_lift'_iff","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\nh : Set Î± â†’ Set Î²\nhh : Monotone h\np : Î² â†’ Prop\nâŠ¢ Iff (Filter.Eventually (fun y => p y) (f.lift' h)) (Exists fun t => And (Membership.mem f t) (âˆ€ (y : Î²), Membership.mem (h t) y â†’ p y))","decl":"theorem eventually_lift'_iff (hh : Monotone h) {p : Î² â†’ Prop} :\n    (âˆ€á¶  y in f.lift' h, p y) â†” âˆƒ t âˆˆ f, âˆ€ y âˆˆ h t, p y :=\n  mem_lift'_sets hh\n\n"}
{"name":"Filter.sInter_lift'_sets","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\nh : Set Î± â†’ Set Î²\nhh : Monotone h\nâŠ¢ Eq (setOf fun s => Membership.mem (f.lift' h) s).sInter (Set.iInter fun s => Set.iInter fun h_1 => h s)","decl":"theorem sInter_lift'_sets (hh : Monotone h) : â‹‚â‚€ { s | s âˆˆ f.lift' h } = â‹‚ s âˆˆ f, h s :=\n  (sInter_lift_sets (monotone_principal.comp hh)).trans <| iInterâ‚‚_congr fun _ _ => csInf_Ici\n\n"}
{"name":"Filter.lift'_le","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\ng : Set Î± â†’ Set Î²\nh : Filter Î²\ns : Set Î±\nhs : Membership.mem f s\nhg : LE.le (Filter.principal (g s)) h\nâŠ¢ LE.le (f.lift' g) h","decl":"theorem lift'_le {f : Filter Î±} {g : Set Î± â†’ Set Î²} {h : Filter Î²} {s : Set Î±} (hs : s âˆˆ f)\n    (hg : ğ“Ÿ (g s) â‰¤ h) : f.lift' g â‰¤ h :=\n  lift_le hs hg\n\n"}
{"name":"Filter.lift'_mono","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nfâ‚ fâ‚‚ : Filter Î±\nhâ‚ hâ‚‚ : Set Î± â†’ Set Î²\nhf : LE.le fâ‚ fâ‚‚\nhh : LE.le hâ‚ hâ‚‚\nâŠ¢ LE.le (fâ‚.lift' hâ‚) (fâ‚‚.lift' hâ‚‚)","decl":"theorem lift'_mono (hf : fâ‚ â‰¤ fâ‚‚) (hh : hâ‚ â‰¤ hâ‚‚) : fâ‚.lift' hâ‚ â‰¤ fâ‚‚.lift' hâ‚‚ :=\n  lift_mono hf fun s => principal_mono.mpr <| hh s\n\n"}
{"name":"Filter.lift'_mono'","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\nhâ‚ hâ‚‚ : Set Î± â†’ Set Î²\nhh : âˆ€ (s : Set Î±), Membership.mem f s â†’ HasSubset.Subset (hâ‚ s) (hâ‚‚ s)\nâŠ¢ LE.le (f.lift' hâ‚) (f.lift' hâ‚‚)","decl":"theorem lift'_mono' (hh : âˆ€ s âˆˆ f, hâ‚ s âŠ† hâ‚‚ s) : f.lift' hâ‚ â‰¤ f.lift' hâ‚‚ :=\n  iInfâ‚‚_mono fun s hs => principal_mono.mpr <| hh s hs\n\n"}
{"name":"Filter.lift'_cong","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\nhâ‚ hâ‚‚ : Set Î± â†’ Set Î²\nhh : âˆ€ (s : Set Î±), Membership.mem f s â†’ Eq (hâ‚ s) (hâ‚‚ s)\nâŠ¢ Eq (f.lift' hâ‚) (f.lift' hâ‚‚)","decl":"theorem lift'_cong (hh : âˆ€ s âˆˆ f, hâ‚ s = hâ‚‚ s) : f.lift' hâ‚ = f.lift' hâ‚‚ :=\n  le_antisymm (lift'_mono' fun s hs => le_of_eq <| hh s hs)\n    (lift'_mono' fun s hs => le_of_eq <| (hh s hs).symm)\n\n"}
{"name":"Filter.map_lift'_eq","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Filter Î±\nh : Set Î± â†’ Set Î²\nm : Î² â†’ Î³\nhh : Monotone h\nâŠ¢ Eq (Filter.map m (f.lift' h)) (f.lift' (Function.comp (Set.image m) h))","decl":"theorem map_lift'_eq {m : Î² â†’ Î³} (hh : Monotone h) : map m (f.lift' h) = f.lift' (image m âˆ˜ h) :=\n  calc\n    map m (f.lift' h) = f.lift (map m âˆ˜ ğ“Ÿ âˆ˜ h) := map_lift_eq <| monotone_principal.comp hh\n    _ = f.lift' (image m âˆ˜ h) := by simp only [comp_def, Filter.lift', map_principal]\n\n"}
{"name":"Filter.lift'_map_le","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Filter Î±\ng : Set Î² â†’ Set Î³\nm : Î± â†’ Î²\nâŠ¢ LE.le ((Filter.map m f).lift' g) (f.lift' (Function.comp g (Set.image m)))","decl":"theorem lift'_map_le {g : Set Î² â†’ Set Î³} {m : Î± â†’ Î²} : (map m f).lift' g â‰¤ f.lift' (g âˆ˜ image m) :=\n  lift_map_le\n\n"}
{"name":"Filter.map_lift'_eq2","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Filter Î±\ng : Set Î² â†’ Set Î³\nm : Î± â†’ Î²\nhg : Monotone g\nâŠ¢ Eq ((Filter.map m f).lift' g) (f.lift' (Function.comp g (Set.image m)))","decl":"theorem map_lift'_eq2 {g : Set Î² â†’ Set Î³} {m : Î± â†’ Î²} (hg : Monotone g) :\n    (map m f).lift' g = f.lift' (g âˆ˜ image m) :=\n  map_lift_eq2 <| monotone_principal.comp hg\n\n"}
{"name":"Filter.comap_lift'_eq","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Filter Î±\nh : Set Î± â†’ Set Î²\nm : Î³ â†’ Î²\nâŠ¢ Eq (Filter.comap m (f.lift' h)) (f.lift' (Function.comp (Set.preimage m) h))","decl":"theorem comap_lift'_eq {m : Î³ â†’ Î²} : comap m (f.lift' h) = f.lift' (preimage m âˆ˜ h) := by\n  simp only [Filter.lift', comap_lift_eq, comp_def, comap_principal]\n\n"}
{"name":"Filter.comap_lift'_eq2","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Filter Î±\nm : Î² â†’ Î±\ng : Set Î² â†’ Set Î³\nhg : Monotone g\nâŠ¢ Eq ((Filter.comap m f).lift' g) (f.lift' (Function.comp g (Set.preimage m)))","decl":"theorem comap_lift'_eq2 {m : Î² â†’ Î±} {g : Set Î² â†’ Set Î³} (hg : Monotone g) :\n    (comap m f).lift' g = f.lift' (g âˆ˜ preimage m) :=\n  comap_lift_eq2 <| monotone_principal.comp hg\n\n"}
{"name":"Filter.lift'_principal","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nh : Set Î± â†’ Set Î²\ns : Set Î±\nhh : Monotone h\nâŠ¢ Eq ((Filter.principal s).lift' h) (Filter.principal (h s))","decl":"theorem lift'_principal {s : Set Î±} (hh : Monotone h) : (ğ“Ÿ s).lift' h = ğ“Ÿ (h s) :=\n  lift_principal <| monotone_principal.comp hh\n\n"}
{"name":"Filter.lift'_pure","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nh : Set Î± â†’ Set Î²\na : Î±\nhh : Monotone h\nâŠ¢ Eq ((Pure.pure a).lift' h) (Filter.principal (h (Singleton.singleton a)))","decl":"theorem lift'_pure {a : Î±} (hh : Monotone h) : (pure a : Filter Î±).lift' h = ğ“Ÿ (h {a}) := by\n  rw [â† principal_singleton, lift'_principal hh]\n\n"}
{"name":"Filter.lift'_bot","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nh : Set Î± â†’ Set Î²\nhh : Monotone h\nâŠ¢ Eq (Bot.bot.lift' h) (Filter.principal (h EmptyCollection.emptyCollection))","decl":"theorem lift'_bot (hh : Monotone h) : (âŠ¥ : Filter Î±).lift' h = ğ“Ÿ (h âˆ…) := by\n  rw [â† principal_empty, lift'_principal hh]\n\n"}
{"name":"Filter.le_lift'","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\nh : Set Î± â†’ Set Î²\ng : Filter Î²\nâŠ¢ Iff (LE.le g (f.lift' h)) (âˆ€ (s : Set Î±), Membership.mem f s â†’ Membership.mem g (h s))","decl":"theorem le_lift' {f : Filter Î±} {h : Set Î± â†’ Set Î²} {g : Filter Î²} :\n    g â‰¤ f.lift' h â†” âˆ€ s âˆˆ f, h s âˆˆ g :=\n  le_lift.trans <| forallâ‚‚_congr fun _ _ => le_principal_iff\n\n"}
{"name":"Filter.principal_le_lift'","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\nh : Set Î± â†’ Set Î²\nt : Set Î²\nâŠ¢ Iff (LE.le (Filter.principal t) (f.lift' h)) (âˆ€ (s : Set Î±), Membership.mem f s â†’ HasSubset.Subset t (h s))","decl":"theorem principal_le_lift' {t : Set Î²} : ğ“Ÿ t â‰¤ f.lift' h â†” âˆ€ s âˆˆ f, t âŠ† h s :=\n  le_lift'\n\n"}
{"name":"Filter.monotone_lift'","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\ninstâœ : Preorder Î³\nf : Î³ â†’ Filter Î±\ng : Î³ â†’ Set Î± â†’ Set Î²\nhf : Monotone f\nhg : Monotone g\nâŠ¢ Monotone fun c => (f c).lift' (g c)","decl":"theorem monotone_lift' [Preorder Î³] {f : Î³ â†’ Filter Î±} {g : Î³ â†’ Set Î± â†’ Set Î²} (hf : Monotone f)\n    (hg : Monotone g) : Monotone fun c => (f c).lift' (g c) := fun _ _ h => lift'_mono (hf h) (hg h)\n\n"}
{"name":"Filter.lift_lift'_assoc","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Filter Î±\ng : Set Î± â†’ Set Î²\nh : Set Î² â†’ Filter Î³\nhg : Monotone g\nhh : Monotone h\nâŠ¢ Eq ((f.lift' g).lift h) (f.lift fun s => h (g s))","decl":"theorem lift_lift'_assoc {g : Set Î± â†’ Set Î²} {h : Set Î² â†’ Filter Î³} (hg : Monotone g)\n    (hh : Monotone h) : (f.lift' g).lift h = f.lift fun s => h (g s) :=\n  calc\n    (f.lift' g).lift h = f.lift fun s => (ğ“Ÿ (g s)).lift h := lift_assoc (monotone_principal.comp hg)\n    _ = f.lift fun s => h (g s) := by simp only [lift_principal, hh, eq_self_iff_true]\n\n"}
{"name":"Filter.lift'_lift'_assoc","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Filter Î±\ng : Set Î± â†’ Set Î²\nh : Set Î² â†’ Set Î³\nhg : Monotone g\nhh : Monotone h\nâŠ¢ Eq ((f.lift' g).lift' h) (f.lift' fun s => h (g s))","decl":"theorem lift'_lift'_assoc {g : Set Î± â†’ Set Î²} {h : Set Î² â†’ Set Î³} (hg : Monotone g)\n    (hh : Monotone h) : (f.lift' g).lift' h = f.lift' fun s => h (g s) :=\n  lift_lift'_assoc hg (monotone_principal.comp hh)\n\n"}
{"name":"Filter.lift'_lift_assoc","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nf : Filter Î±\ng : Set Î± â†’ Filter Î²\nh : Set Î² â†’ Set Î³\nhg : Monotone g\nâŠ¢ Eq ((f.lift g).lift' h) (f.lift fun s => (g s).lift' h)","decl":"theorem lift'_lift_assoc {g : Set Î± â†’ Filter Î²} {h : Set Î² â†’ Set Î³} (hg : Monotone g) :\n    (f.lift g).lift' h = f.lift fun s => (g s).lift' h :=\n  lift_assoc hg\n\n"}
{"name":"Filter.lift_lift'_same_le_lift'","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\ng : Set Î± â†’ Set Î± â†’ Set Î²\nâŠ¢ LE.le (f.lift fun s => f.lift' (g s)) (f.lift' fun s => g s s)","decl":"theorem lift_lift'_same_le_lift' {g : Set Î± â†’ Set Î± â†’ Set Î²} :\n    (f.lift fun s => f.lift' (g s)) â‰¤ f.lift' fun s => g s s :=\n  lift_lift_same_le_lift\n\n"}
{"name":"Filter.lift_lift'_same_eq_lift'","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\ng : Set Î± â†’ Set Î± â†’ Set Î²\nhgâ‚ : âˆ€ (s : Set Î±), Monotone fun t => g s t\nhgâ‚‚ : âˆ€ (t : Set Î±), Monotone fun s => g s t\nâŠ¢ Eq (f.lift fun s => f.lift' (g s)) (f.lift' fun s => g s s)","decl":"theorem lift_lift'_same_eq_lift' {g : Set Î± â†’ Set Î± â†’ Set Î²} (hgâ‚ : âˆ€ s, Monotone fun t => g s t)\n    (hgâ‚‚ : âˆ€ t, Monotone fun s => g s t) :\n    (f.lift fun s => f.lift' (g s)) = f.lift' fun s => g s s :=\n  lift_lift_same_eq_lift (fun s => monotone_principal.comp (hgâ‚ s)) fun t =>\n    monotone_principal.comp (hgâ‚‚ t)\n\n"}
{"name":"Filter.lift'_inf_principal_eq","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\nh : Set Î± â†’ Set Î²\ns : Set Î²\nâŠ¢ Eq (Min.min (f.lift' h) (Filter.principal s)) (f.lift' fun t => Inter.inter (h t) s)","decl":"theorem lift'_inf_principal_eq {h : Set Î± â†’ Set Î²} {s : Set Î²} :\n    f.lift' h âŠ“ ğ“Ÿ s = f.lift' fun t => h t âˆ© s := by\n  simp only [Filter.lift', Filter.lift, (Â· âˆ˜ Â·), â† inf_principal, iInf_subtype', â† iInf_inf]\n\n"}
{"name":"Filter.lift'_neBot_iff","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\nh : Set Î± â†’ Set Î²\nhh : Monotone h\nâŠ¢ Iff (f.lift' h).NeBot (âˆ€ (s : Set Î±), Membership.mem f s â†’ (h s).Nonempty)","decl":"theorem lift'_neBot_iff (hh : Monotone h) : NeBot (f.lift' h) â†” âˆ€ s âˆˆ f, (h s).Nonempty :=\n  calc\n    NeBot (f.lift' h) â†” âˆ€ s âˆˆ f, NeBot (ğ“Ÿ (h s)) := lift_neBot_iff (monotone_principal.comp hh)\n    _ â†” âˆ€ s âˆˆ f, (h s).Nonempty := by simp only [principal_neBot_iff]\n\n"}
{"name":"Filter.lift'_id","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nf : Filter Î±\nâŠ¢ Eq (f.lift' id) f","decl":"@[simp]\ntheorem lift'_id {f : Filter Î±} : f.lift' id = f :=\n  lift_principal2\n\n"}
{"name":"Filter.lift'_iInf","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\ninstâœ : Nonempty Î¹\nf : Î¹ â†’ Filter Î±\ng : Set Î± â†’ Set Î²\nhg : âˆ€ (s t : Set Î±), Eq (g (Inter.inter s t)) (Inter.inter (g s) (g t))\nâŠ¢ Eq ((iInf f).lift' g) (iInf fun i => (f i).lift' g)","decl":"theorem lift'_iInf [Nonempty Î¹] {f : Î¹ â†’ Filter Î±} {g : Set Î± â†’ Set Î²}\n    (hg : âˆ€ s t, g (s âˆ© t) = g s âˆ© g t) : (iInf f).lift' g = â¨… i, (f i).lift' g :=\n  lift_iInf fun s t => by simp only [inf_principal, comp, hg]\n\n"}
{"name":"Filter.lift'_iInf_of_map_univ","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ¹ : Sort u_4\nf : Î¹ â†’ Filter Î±\ng : Set Î± â†’ Set Î²\nhg : âˆ€ {s t : Set Î±}, Eq (g (Inter.inter s t)) (Inter.inter (g s) (g t))\nhg' : Eq (g Set.univ) Set.univ\nâŠ¢ Eq ((iInf f).lift' g) (iInf fun i => (f i).lift' g)","decl":"theorem lift'_iInf_of_map_univ {f : Î¹ â†’ Filter Î±} {g : Set Î± â†’ Set Î²}\n    (hg : âˆ€ {s t}, g (s âˆ© t) = g s âˆ© g t) (hg' : g univ = univ) :\n    (iInf f).lift' g = â¨… i, (f i).lift' g :=\n  lift_iInf_of_map_univ (fun s t => by simp only [inf_principal, comp, hg])\n    (by rw [Function.comp_apply, hg', principal_univ])\n\n"}
{"name":"Filter.lift'_inf","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf g : Filter Î±\ns : Set Î± â†’ Set Î²\nhs : âˆ€ (tâ‚ tâ‚‚ : Set Î±), Eq (s (Inter.inter tâ‚ tâ‚‚)) (Inter.inter (s tâ‚) (s tâ‚‚))\nâŠ¢ Eq ((Min.min f g).lift' s) (Min.min (f.lift' s) (g.lift' s))","decl":"theorem lift'_inf (f g : Filter Î±) {s : Set Î± â†’ Set Î²} (hs : âˆ€ tâ‚ tâ‚‚, s (tâ‚ âˆ© tâ‚‚) = s tâ‚ âˆ© s tâ‚‚) :\n    (f âŠ“ g).lift' s = f.lift' s âŠ“ g.lift' s := by\n  rw [inf_eq_iInf, inf_eq_iInf, lift'_iInf hs]\n  refine iInf_congr ?_\n  rintro (_|_) <;> rfl\n\n"}
{"name":"Filter.lift'_inf_le","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf g : Filter Î±\ns : Set Î± â†’ Set Î²\nâŠ¢ LE.le ((Min.min f g).lift' s) (Min.min (f.lift' s) (g.lift' s))","decl":"theorem lift'_inf_le (f g : Filter Î±) (s : Set Î± â†’ Set Î²) :\n    (f âŠ“ g).lift' s â‰¤ f.lift' s âŠ“ g.lift' s :=\n  le_inf (lift'_mono inf_le_left le_rfl) (lift'_mono inf_le_right le_rfl)\n\n"}
{"name":"Filter.comap_eq_lift'","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î²\nm : Î± â†’ Î²\nâŠ¢ Eq (Filter.comap m f) (f.lift' (Set.preimage m))","decl":"theorem comap_eq_lift' {f : Filter Î²} {m : Î± â†’ Î²} : comap m f = f.lift' (preimage m) :=\n  Filter.ext fun _ => (mem_lift'_sets monotone_preimage).symm\n\n"}
{"name":"Filter.prod_def","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Filter Î±\ng : Filter Î²\nâŠ¢ Eq (SProd.sprod f g) (f.lift fun s => g.lift' fun t => SProd.sprod s t)","decl":"theorem prod_def {f : Filter Î±} {g : Filter Î²} :\n    f Ã—Ë¢ g = f.lift fun s => g.lift' fun t => s Ã—Ë¢ t := by\n  simpa only [Filter.lift', Filter.lift, (f.basis_sets.prod g.basis_sets).eq_biInf,\n    iInf_prod, iInf_and] using iInf_congr fun i => iInf_comm\n\n"}
{"name":"Filter.mem_prod_same_iff","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nla : Filter Î±\ns : Set (Prod Î± Î±)\nâŠ¢ Iff (Membership.mem (SProd.sprod la la) s) (Exists fun t => And (Membership.mem la t) (HasSubset.Subset (SProd.sprod t t) s))","decl":"alias mem_prod_same_iff := mem_prod_self_iff\n\n"}
{"name":"Filter.prod_same_eq","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nf : Filter Î±\nâŠ¢ Eq (SProd.sprod f f) (f.lift' fun t => SProd.sprod t t)","decl":"theorem prod_same_eq : f Ã—Ë¢ f = f.lift' fun t : Set Î± => t Ã—Ë¢ t :=\n  f.basis_sets.prod_self.eq_biInf\n\n"}
{"name":"Filter.tendsto_prod_self_iff","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nf : Prod Î± Î± â†’ Î²\nx : Filter Î±\ny : Filter Î²\nâŠ¢ Iff (Filter.Tendsto f (SProd.sprod x x) y) (âˆ€ (W : Set Î²), Membership.mem y W â†’ Exists fun U => And (Membership.mem x U) (âˆ€ (x x' : Î±), Membership.mem U x â†’ Membership.mem U x' â†’ Membership.mem W (f { fst := x, snd := x' })))","decl":"theorem tendsto_prod_self_iff {f : Î± Ã— Î± â†’ Î²} {x : Filter Î±} {y : Filter Î²} :\n    Filter.Tendsto f (x Ã—Ë¢ x) y â†” âˆ€ W âˆˆ y, âˆƒ U âˆˆ x, âˆ€ x x' : Î±, x âˆˆ U â†’ x' âˆˆ U â†’ f (x, x') âˆˆ W := by\n  simp only [tendsto_def, mem_prod_same_iff, prod_sub_preimage_iff, exists_prop]\n\n"}
{"name":"Filter.prod_lift_lift","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î±â‚ : Type u_5\nÎ±â‚‚ : Type u_6\nÎ²â‚ : Type u_7\nÎ²â‚‚ : Type u_8\nfâ‚ : Filter Î±â‚\nfâ‚‚ : Filter Î±â‚‚\ngâ‚ : Set Î±â‚ â†’ Filter Î²â‚\ngâ‚‚ : Set Î±â‚‚ â†’ Filter Î²â‚‚\nhgâ‚ : Monotone gâ‚\nhgâ‚‚ : Monotone gâ‚‚\nâŠ¢ Eq (SProd.sprod (fâ‚.lift gâ‚) (fâ‚‚.lift gâ‚‚)) (fâ‚.lift fun s => fâ‚‚.lift fun t => SProd.sprod (gâ‚ s) (gâ‚‚ t))","decl":"theorem prod_lift_lift {fâ‚ : Filter Î±â‚} {fâ‚‚ : Filter Î±â‚‚} {gâ‚ : Set Î±â‚ â†’ Filter Î²â‚}\n    {gâ‚‚ : Set Î±â‚‚ â†’ Filter Î²â‚‚} (hgâ‚ : Monotone gâ‚) (hgâ‚‚ : Monotone gâ‚‚) :\n    fâ‚.lift gâ‚ Ã—Ë¢ fâ‚‚.lift gâ‚‚ = fâ‚.lift fun s => fâ‚‚.lift fun t => gâ‚ s Ã—Ë¢ gâ‚‚ t := by\n  simp only [prod_def, lift_assoc hgâ‚]\n  apply congr_arg; funext x\n  rw [lift_comm]\n  apply congr_arg; funext y\n  apply lift'_lift_assoc hgâ‚‚\n\n"}
{"name":"Filter.prod_lift'_lift'","module":"Mathlib.Order.Filter.Lift","initialProofState":"Î±â‚ : Type u_5\nÎ±â‚‚ : Type u_6\nÎ²â‚ : Type u_7\nÎ²â‚‚ : Type u_8\nfâ‚ : Filter Î±â‚\nfâ‚‚ : Filter Î±â‚‚\ngâ‚ : Set Î±â‚ â†’ Set Î²â‚\ngâ‚‚ : Set Î±â‚‚ â†’ Set Î²â‚‚\nhgâ‚ : Monotone gâ‚\nhgâ‚‚ : Monotone gâ‚‚\nâŠ¢ Eq (SProd.sprod (fâ‚.lift' gâ‚) (fâ‚‚.lift' gâ‚‚)) (fâ‚.lift fun s => fâ‚‚.lift' fun t => SProd.sprod (gâ‚ s) (gâ‚‚ t))","decl":"theorem prod_lift'_lift' {fâ‚ : Filter Î±â‚} {fâ‚‚ : Filter Î±â‚‚} {gâ‚ : Set Î±â‚ â†’ Set Î²â‚}\n    {gâ‚‚ : Set Î±â‚‚ â†’ Set Î²â‚‚} (hgâ‚ : Monotone gâ‚) (hgâ‚‚ : Monotone gâ‚‚) :\n    fâ‚.lift' gâ‚ Ã—Ë¢ fâ‚‚.lift' gâ‚‚ = fâ‚.lift fun s => fâ‚‚.lift' fun t => gâ‚ s Ã—Ë¢ gâ‚‚ t :=\n  calc\n    fâ‚.lift' gâ‚ Ã—Ë¢ fâ‚‚.lift' gâ‚‚ = fâ‚.lift fun s => fâ‚‚.lift fun t => ğ“Ÿ (gâ‚ s) Ã—Ë¢ ğ“Ÿ (gâ‚‚ t) :=\n      prod_lift_lift (monotone_principal.comp hgâ‚) (monotone_principal.comp hgâ‚‚)\n    _ = fâ‚.lift fun s => fâ‚‚.lift fun t => ğ“Ÿ (gâ‚ s Ã—Ë¢ gâ‚‚ t) := by\n      { simp only [prod_principal_principal] }\n\n"}
