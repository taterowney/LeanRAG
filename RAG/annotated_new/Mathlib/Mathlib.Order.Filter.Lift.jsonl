{"name":"Filter.lift_top","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\ng : Set α → Filter β\n⊢ Eq (Top.top.lift g) (g Set.univ)","decl":"@[simp]\ntheorem lift_top (g : Set α → Filter β) : (⊤ : Filter α).lift g = g univ := by simp [Filter.lift]\n\n-- Porting note: use `∃ i, p i ∧ _` instead of `∃ i (hi : p i), _`\n"}
{"name":"Filter.HasBasis.mem_lift_iff","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nγ : Type u_3\nι : Sort u_6\np : ι → Prop\ns✝ : ι → Set α\nf : Filter α\nhf : f.HasBasis p s✝\nβ : ι → Type u_5\npg : (i : ι) → β i → Prop\nsg : (i : ι) → β i → Set γ\ng : Set α → Filter γ\nhg : ∀ (i : ι), (g (s✝ i)).HasBasis (pg i) (sg i)\ngm : Monotone g\ns : Set γ\n⊢ Iff (Membership.mem (f.lift g) s) (Exists fun i => And (p i) (Exists fun x => And (pg i x) (HasSubset.Subset (sg i x) s)))","decl":"/-- If `(p : ι → Prop, s : ι → Set α)` is a basis of a filter `f`, `g` is a monotone function\n`Set α → Filter γ`, and for each `i`, `(pg : β i → Prop, sg : β i → Set α)` is a basis\nof the filter `g (s i)`, then\n`(fun (i : ι) (x : β i) ↦ p i ∧ pg i x, fun (i : ι) (x : β i) ↦ sg i x)` is a basis\nof the filter `f.lift g`.\n\nThis basis is parametrized by `i : ι` and `x : β i`, so in order to formulate this fact using\n`Filter.HasBasis` one has to use `Σ i, β i` as the index type, see `Filter.HasBasis.lift`.\nThis lemma states the corresponding `mem_iff` statement without using a sigma type. -/\ntheorem HasBasis.mem_lift_iff {ι} {p : ι → Prop} {s : ι → Set α} {f : Filter α}\n    (hf : f.HasBasis p s) {β : ι → Type*} {pg : ∀ i, β i → Prop} {sg : ∀ i, β i → Set γ}\n    {g : Set α → Filter γ} (hg : ∀ i, (g <| s i).HasBasis (pg i) (sg i)) (gm : Monotone g)\n    {s : Set γ} : s ∈ f.lift g ↔ ∃ i, p i ∧ ∃ x, pg i x ∧ sg i x ⊆ s := by\n  refine (mem_biInf_of_directed ?_ ⟨univ, univ_sets _⟩).trans ?_\n  · intro t₁ ht₁ t₂ ht₂\n    exact ⟨t₁ ∩ t₂, inter_mem ht₁ ht₂, gm inter_subset_left, gm inter_subset_right⟩\n  · simp only [← (hg _).mem_iff]\n    exact hf.exists_iff fun t₁ t₂ ht H => gm ht H\n\n"}
{"name":"Filter.HasBasis.lift","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nγ : Type u_3\nι : Type u_6\np : ι → Prop\ns : ι → Set α\nf : Filter α\nhf : f.HasBasis p s\nβ : ι → Type u_5\npg : (i : ι) → β i → Prop\nsg : (i : ι) → β i → Set γ\ng : Set α → Filter γ\nhg : ∀ (i : ι), (g (s i)).HasBasis (pg i) (sg i)\ngm : Monotone g\n⊢ (f.lift g).HasBasis (fun i => And (p i.fst) (pg i.fst i.snd)) fun i => sg i.fst i.snd","decl":"/-- If `(p : ι → Prop, s : ι → Set α)` is a basis of a filter `f`, `g` is a monotone function\n`Set α → Filter γ`, and for each `i`, `(pg : β i → Prop, sg : β i → Set α)` is a basis\nof the filter `g (s i)`, then\n`(fun (i : ι) (x : β i) ↦ p i ∧ pg i x, fun (i : ι) (x : β i) ↦ sg i x)`\nis a basis of the filter `f.lift g`.\n\nThis basis is parametrized by `i : ι` and `x : β i`, so in order to formulate this fact using\n`has_basis` one has to use `Σ i, β i` as the index type. See also `Filter.HasBasis.mem_lift_iff`\nfor the corresponding `mem_iff` statement formulated without using a sigma type. -/\ntheorem HasBasis.lift {ι} {p : ι → Prop} {s : ι → Set α} {f : Filter α} (hf : f.HasBasis p s)\n    {β : ι → Type*} {pg : ∀ i, β i → Prop} {sg : ∀ i, β i → Set γ} {g : Set α → Filter γ}\n    (hg : ∀ i, (g (s i)).HasBasis (pg i) (sg i)) (gm : Monotone g) :\n    (f.lift g).HasBasis (fun i : Σi, β i => p i.1 ∧ pg i.1 i.2) fun i : Σi, β i => sg i.1 i.2 := by\n  refine ⟨fun t => (hf.mem_lift_iff hg gm).trans ?_⟩\n  simp [Sigma.exists, and_assoc, exists_and_left]\n\n"}
{"name":"Filter.mem_lift_sets","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Set α → Filter β\nhg : Monotone g\ns : Set β\n⊢ Iff (Membership.mem (f.lift g) s) (Exists fun t => And (Membership.mem f t) (Membership.mem (g t) s))","decl":"theorem mem_lift_sets (hg : Monotone g) {s : Set β} : s ∈ f.lift g ↔ ∃ t ∈ f, s ∈ g t :=\n  (f.basis_sets.mem_lift_iff (fun s => (g s).basis_sets) hg).trans <| by\n    simp only [id, exists_mem_subset_iff]\n\n"}
{"name":"Filter.sInter_lift_sets","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Set α → Filter β\nhg : Monotone g\n⊢ Eq (setOf fun s => Membership.mem (f.lift g) s).sInter (Set.iInter fun s => Set.iInter fun h => (setOf fun t => Membership.mem (g s) t).sInter)","decl":"theorem sInter_lift_sets (hg : Monotone g) :\n    ⋂₀ { s | s ∈ f.lift g } = ⋂ s ∈ f, ⋂₀ { t | t ∈ g s } := by\n  simp only [sInter_eq_biInter, mem_setOf_eq, Filter.mem_sets, mem_lift_sets hg, iInter_exists,\n    iInter_and, @iInter_comm _ (Set β)]\n\n"}
{"name":"Filter.mem_lift","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Set α → Filter β\ns : Set β\nt : Set α\nht : Membership.mem f t\nhs : Membership.mem (g t) s\n⊢ Membership.mem (f.lift g) s","decl":"theorem mem_lift {s : Set β} {t : Set α} (ht : t ∈ f) (hs : s ∈ g t) : s ∈ f.lift g :=\n  le_principal_iff.mp <|\n    show f.lift g ≤ 𝓟 s from iInf_le_of_le t <| iInf_le_of_le ht <| le_principal_iff.mpr hs\n\n"}
{"name":"Filter.lift_le","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Set α → Filter β\nh : Filter β\ns : Set α\nhs : Membership.mem f s\nhg : LE.le (g s) h\n⊢ LE.le (f.lift g) h","decl":"theorem lift_le {f : Filter α} {g : Set α → Filter β} {h : Filter β} {s : Set α} (hs : s ∈ f)\n    (hg : g s ≤ h) : f.lift g ≤ h :=\n  iInf₂_le_of_le s hs hg\n\n"}
{"name":"Filter.le_lift","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Set α → Filter β\nh : Filter β\n⊢ Iff (LE.le h (f.lift g)) (∀ (s : Set α), Membership.mem f s → LE.le h (g s))","decl":"theorem le_lift {f : Filter α} {g : Set α → Filter β} {h : Filter β} :\n    h ≤ f.lift g ↔ ∀ s ∈ f, h ≤ g s :=\n  le_iInf₂_iff\n\n"}
{"name":"Filter.lift_mono","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf₁ f₂ : Filter α\ng₁ g₂ : Set α → Filter β\nhf : LE.le f₁ f₂\nhg : LE.le g₁ g₂\n⊢ LE.le (f₁.lift g₁) (f₂.lift g₂)","decl":"theorem lift_mono (hf : f₁ ≤ f₂) (hg : g₁ ≤ g₂) : f₁.lift g₁ ≤ f₂.lift g₂ :=\n  iInf_mono fun s => iInf_mono' fun hs => ⟨hf hs, hg s⟩\n\n"}
{"name":"Filter.lift_mono'","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng₁ g₂ : Set α → Filter β\nhg : ∀ (s : Set α), Membership.mem f s → LE.le (g₁ s) (g₂ s)\n⊢ LE.le (f.lift g₁) (f.lift g₂)","decl":"theorem lift_mono' (hg : ∀ s ∈ f, g₁ s ≤ g₂ s) : f.lift g₁ ≤ f.lift g₂ := iInf₂_mono hg\n\n"}
{"name":"Filter.tendsto_lift","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\ng : Set α → Filter β\nm : γ → β\nl : Filter γ\n⊢ Iff (Filter.Tendsto m l (f.lift g)) (∀ (s : Set α), Membership.mem f s → Filter.Tendsto m l (g s))","decl":"theorem tendsto_lift {m : γ → β} {l : Filter γ} :\n    Tendsto m l (f.lift g) ↔ ∀ s ∈ f, Tendsto m l (g s) := by\n  simp only [Filter.lift, tendsto_iInf]\n\n"}
{"name":"Filter.map_lift_eq","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\ng : Set α → Filter β\nm : β → γ\nhg : Monotone g\n⊢ Eq (Filter.map m (f.lift g)) (f.lift (Function.comp (Filter.map m) g))","decl":"theorem map_lift_eq {m : β → γ} (hg : Monotone g) : map m (f.lift g) = f.lift (map m ∘ g) :=\n  have : Monotone (map m ∘ g) := map_mono.comp hg\n  Filter.ext fun s => by\n    simp only [mem_lift_sets hg, mem_lift_sets this, exists_prop, mem_map, Function.comp_apply]\n\n"}
{"name":"Filter.comap_lift_eq","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\ng : Set α → Filter β\nm : γ → β\n⊢ Eq (Filter.comap m (f.lift g)) (f.lift (Function.comp (Filter.comap m) g))","decl":"theorem comap_lift_eq {m : γ → β} : comap m (f.lift g) = f.lift (comap m ∘ g) := by\n  simp only [Filter.lift, comap_iInf]; rfl\n\n"}
{"name":"Filter.comap_lift_eq2","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\nm : β → α\ng : Set β → Filter γ\nhg : Monotone g\n⊢ Eq ((Filter.comap m f).lift g) (f.lift (Function.comp g (Set.preimage m)))","decl":"theorem comap_lift_eq2 {m : β → α} {g : Set β → Filter γ} (hg : Monotone g) :\n    (comap m f).lift g = f.lift (g ∘ preimage m) :=\n  le_antisymm (le_iInf₂ fun s hs => iInf₂_le (m ⁻¹' s) ⟨s, hs, Subset.rfl⟩)\n    (le_iInf₂ fun _s ⟨s', hs', h_sub⟩ => iInf₂_le_of_le s' hs' <| hg h_sub)\n\n"}
{"name":"Filter.lift_map_le","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\ng : Set β → Filter γ\nm : α → β\n⊢ LE.le ((Filter.map m f).lift g) (f.lift (Function.comp g (Set.image m)))","decl":"theorem lift_map_le {g : Set β → Filter γ} {m : α → β} : (map m f).lift g ≤ f.lift (g ∘ image m) :=\n  le_lift.2 fun _s hs => lift_le (image_mem_map hs) le_rfl\n\n"}
{"name":"Filter.map_lift_eq2","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\ng : Set β → Filter γ\nm : α → β\nhg : Monotone g\n⊢ Eq ((Filter.map m f).lift g) (f.lift (Function.comp g (Set.image m)))","decl":"theorem map_lift_eq2 {g : Set β → Filter γ} {m : α → β} (hg : Monotone g) :\n    (map m f).lift g = f.lift (g ∘ image m) :=\n  lift_map_le.antisymm <| le_lift.2 fun _s hs => lift_le hs <| hg <| image_preimage_subset _ _\n\n"}
{"name":"Filter.lift_comm","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\ng : Filter β\nh : Set α → Set β → Filter γ\n⊢ Eq (f.lift fun s => g.lift (h s)) (g.lift fun t => f.lift fun s => h s t)","decl":"theorem lift_comm {g : Filter β} {h : Set α → Set β → Filter γ} :\n    (f.lift fun s => g.lift (h s)) = g.lift fun t => f.lift fun s => h s t :=\n  le_antisymm\n    (le_iInf fun i => le_iInf fun hi => le_iInf fun j => le_iInf fun hj =>\n      iInf_le_of_le j <| iInf_le_of_le hj <| iInf_le_of_le i <| iInf_le _ hi)\n    (le_iInf fun i => le_iInf fun hi => le_iInf fun j => le_iInf fun hj =>\n      iInf_le_of_le j <| iInf_le_of_le hj <| iInf_le_of_le i <| iInf_le _ hi)\n\n"}
{"name":"Filter.lift_assoc","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\ng : Set α → Filter β\nh : Set β → Filter γ\nhg : Monotone g\n⊢ Eq ((f.lift g).lift h) (f.lift fun s => (g s).lift h)","decl":"theorem lift_assoc {h : Set β → Filter γ} (hg : Monotone g) :\n    (f.lift g).lift h = f.lift fun s => (g s).lift h :=\n  le_antisymm\n    (le_iInf₂ fun _s hs => le_iInf₂ fun t ht =>\n      iInf_le_of_le t <| iInf_le _ <| (mem_lift_sets hg).mpr ⟨_, hs, ht⟩)\n    (le_iInf₂ fun t ht =>\n      let ⟨s, hs, h'⟩ := (mem_lift_sets hg).mp ht\n      iInf_le_of_le s <| iInf_le_of_le hs <| iInf_le_of_le t <| iInf_le _ h')\n\n"}
{"name":"Filter.lift_lift_same_le_lift","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Set α → Set α → Filter β\n⊢ LE.le (f.lift fun s => f.lift (g s)) (f.lift fun s => g s s)","decl":"theorem lift_lift_same_le_lift {g : Set α → Set α → Filter β} :\n    (f.lift fun s => f.lift (g s)) ≤ f.lift fun s => g s s :=\n  le_lift.2 fun _s hs => lift_le hs <| lift_le hs le_rfl\n\n"}
{"name":"Filter.lift_lift_same_eq_lift","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Set α → Set α → Filter β\nhg₁ : ∀ (s : Set α), Monotone fun t => g s t\nhg₂ : ∀ (t : Set α), Monotone fun s => g s t\n⊢ Eq (f.lift fun s => f.lift (g s)) (f.lift fun s => g s s)","decl":"theorem lift_lift_same_eq_lift {g : Set α → Set α → Filter β} (hg₁ : ∀ s, Monotone fun t => g s t)\n    (hg₂ : ∀ t, Monotone fun s => g s t) : (f.lift fun s => f.lift (g s)) = f.lift fun s => g s s :=\n  lift_lift_same_le_lift.antisymm <|\n    le_lift.2 fun s hs => le_lift.2 fun t ht => lift_le (inter_mem hs ht) <|\n      calc\n        g (s ∩ t) (s ∩ t) ≤ g s (s ∩ t) := hg₂ (s ∩ t) inter_subset_left\n        _ ≤ g s t := hg₁ s inter_subset_right\n\n"}
{"name":"Filter.lift_principal","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\ng : Set α → Filter β\ns : Set α\nhg : Monotone g\n⊢ Eq ((Filter.principal s).lift g) (g s)","decl":"theorem lift_principal {s : Set α} (hg : Monotone g) : (𝓟 s).lift g = g s :=\n  (lift_le (mem_principal_self _) le_rfl).antisymm (le_lift.2 fun _t ht => hg ht)\n\n"}
{"name":"Filter.monotone_lift","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Preorder γ\nf : γ → Filter α\ng : γ → Set α → Filter β\nhf : Monotone f\nhg : Monotone g\n⊢ Monotone fun c => (f c).lift (g c)","decl":"theorem monotone_lift [Preorder γ] {f : γ → Filter α} {g : γ → Set α → Filter β} (hf : Monotone f)\n    (hg : Monotone g) : Monotone fun c => (f c).lift (g c) := fun _ _ h => lift_mono (hf h) (hg h)\n\n"}
{"name":"Filter.lift_neBot_iff","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Set α → Filter β\nhm : Monotone g\n⊢ Iff (f.lift g).NeBot (∀ (s : Set α), Membership.mem f s → (g s).NeBot)","decl":"theorem lift_neBot_iff (hm : Monotone g) : (NeBot (f.lift g)) ↔ ∀ s ∈ f, NeBot (g s) := by\n  simp only [neBot_iff, Ne, ← empty_mem_iff_bot, mem_lift_sets hm, not_exists, not_and]\n\n"}
{"name":"Filter.lift_const","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\n⊢ Eq (f.lift fun x => g) g","decl":"@[simp]\ntheorem lift_const {f : Filter α} {g : Filter β} : (f.lift fun _ => g) = g :=\n  iInf_subtype'.trans iInf_const\n\n"}
{"name":"Filter.lift_inf","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng h : Set α → Filter β\n⊢ Eq (f.lift fun x => Min.min (g x) (h x)) (Min.min (f.lift g) (f.lift h))","decl":"@[simp]\ntheorem lift_inf {f : Filter α} {g h : Set α → Filter β} :\n    (f.lift fun x => g x ⊓ h x) = f.lift g ⊓ f.lift h := by simp only [Filter.lift, iInf_inf_eq]\n\n"}
{"name":"Filter.lift_principal2","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nf : Filter α\n⊢ Eq (f.lift Filter.principal) f","decl":"@[simp]\ntheorem lift_principal2 {f : Filter α} : f.lift 𝓟 = f :=\n  le_antisymm (fun s hs => mem_lift hs (mem_principal_self s))\n    (le_iInf fun s => le_iInf fun hs => by simp only [hs, le_principal_iff])\n\n"}
{"name":"Filter.lift_iInf_le","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nf : ι → Filter α\ng : Set α → Filter β\n⊢ LE.le ((iInf f).lift g) (iInf fun i => (f i).lift g)","decl":"theorem lift_iInf_le {f : ι → Filter α} {g : Set α → Filter β} :\n    (iInf f).lift g ≤ ⨅ i, (f i).lift g :=\n  le_iInf fun _ => lift_mono (iInf_le _ _) le_rfl\n\n"}
{"name":"Filter.lift_iInf","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝ : Nonempty ι\nf : ι → Filter α\ng : Set α → Filter β\nhg : ∀ (s t : Set α), Eq (g (Inter.inter s t)) (Min.min (g s) (g t))\n⊢ Eq ((iInf f).lift g) (iInf fun i => (f i).lift g)","decl":"theorem lift_iInf [Nonempty ι] {f : ι → Filter α} {g : Set α → Filter β}\n    (hg : ∀ s t, g (s ∩ t) = g s ⊓ g t) : (iInf f).lift g = ⨅ i, (f i).lift g := by\n  refine lift_iInf_le.antisymm fun s => ?_\n  have H : ∀ t ∈ iInf f, ⨅ i, (f i).lift g ≤ g t := by\n    intro t ht\n    refine iInf_sets_induct ht ?_ fun hs ht => ?_\n    · inhabit ι\n      exact iInf₂_le_of_le default univ (iInf_le _ univ_mem)\n    · rw [hg]\n      exact le_inf (iInf₂_le_of_le _ _ <| iInf_le _ hs) ht\n  simp only [mem_lift_sets (Monotone.of_map_inf hg), exists_imp, and_imp]\n  exact fun t ht hs => H t ht hs\n\n"}
{"name":"Filter.lift_iInf_of_directed","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝ : Nonempty ι\nf : ι → Filter α\ng : Set α → Filter β\nhf : Directed (fun x1 x2 => GE.ge x1 x2) f\nhg : Monotone g\n⊢ Eq ((iInf f).lift g) (iInf fun i => (f i).lift g)","decl":"theorem lift_iInf_of_directed [Nonempty ι] {f : ι → Filter α} {g : Set α → Filter β}\n    (hf : Directed (· ≥ ·) f) (hg : Monotone g) : (iInf f).lift g = ⨅ i, (f i).lift g :=\n  lift_iInf_le.antisymm fun s => by\n    simp only [mem_lift_sets hg, exists_imp, and_imp, mem_iInf_of_directed hf]\n    exact fun t i ht hs => mem_iInf_of_mem i <| mem_lift ht hs\n\n"}
{"name":"Filter.lift_iInf_of_map_univ","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nf : ι → Filter α\ng : Set α → Filter β\nhg : ∀ (s t : Set α), Eq (g (Inter.inter s t)) (Min.min (g s) (g t))\nhg' : Eq (g Set.univ) Top.top\n⊢ Eq ((iInf f).lift g) (iInf fun i => (f i).lift g)","decl":"theorem lift_iInf_of_map_univ {f : ι → Filter α} {g : Set α → Filter β}\n    (hg : ∀ s t, g (s ∩ t) = g s ⊓ g t) (hg' : g univ = ⊤) :\n    (iInf f).lift g = ⨅ i, (f i).lift g := by\n  cases isEmpty_or_nonempty ι\n  · simp [iInf_of_empty, hg']\n  · exact lift_iInf hg\n\n"}
{"name":"Filter.lift'_top","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nh : Set α → Set β\n⊢ Eq (Top.top.lift' h) (Filter.principal (h Set.univ))","decl":"@[simp]\ntheorem lift'_top (h : Set α → Set β) : (⊤ : Filter α).lift' h = 𝓟 (h univ) :=\n  lift_top _\n\n"}
{"name":"Filter.mem_lift'","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\nh : Set α → Set β\nt : Set α\nht : Membership.mem f t\n⊢ Membership.mem (f.lift' h) (h t)","decl":"theorem mem_lift' {t : Set α} (ht : t ∈ f) : h t ∈ f.lift' h :=\n  le_principal_iff.mp <| show f.lift' h ≤ 𝓟 (h t) from iInf_le_of_le t <| iInf_le_of_le ht <| le_rfl\n\n"}
{"name":"Filter.tendsto_lift'","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\nh : Set α → Set β\nm : γ → β\nl : Filter γ\n⊢ Iff (Filter.Tendsto m l (f.lift' h)) (∀ (s : Set α), Membership.mem f s → Filter.Eventually (fun a => Membership.mem (h s) (m a)) l)","decl":"theorem tendsto_lift' {m : γ → β} {l : Filter γ} :\n    Tendsto m l (f.lift' h) ↔ ∀ s ∈ f, ∀ᶠ a in l, m a ∈ h s := by\n  simp only [Filter.lift', tendsto_lift, tendsto_principal, comp]\n\n"}
{"name":"Filter.HasBasis.lift'","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\nh : Set α → Set β\nι : Sort u_5\np : ι → Prop\ns : ι → Set α\nhf : f.HasBasis p s\nhh : Monotone h\n⊢ (f.lift' h).HasBasis p (Function.comp h s)","decl":"theorem HasBasis.lift' {ι} {p : ι → Prop} {s} (hf : f.HasBasis p s) (hh : Monotone h) :\n    (f.lift' h).HasBasis p (h ∘ s) :=\n  ⟨fun t => (hf.mem_lift_iff (fun i => hasBasis_principal (h (s i)))\n    (monotone_principal.comp hh)).trans <| by simp only [exists_const, true_and, comp]⟩\n\n"}
{"name":"Filter.mem_lift'_sets","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\nh : Set α → Set β\nhh : Monotone h\ns : Set β\n⊢ Iff (Membership.mem (f.lift' h) s) (Exists fun t => And (Membership.mem f t) (HasSubset.Subset (h t) s))","decl":"theorem mem_lift'_sets (hh : Monotone h) {s : Set β} : s ∈ f.lift' h ↔ ∃ t ∈ f, h t ⊆ s :=\n  mem_lift_sets <| monotone_principal.comp hh\n\n"}
{"name":"Filter.eventually_lift'_iff","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\nh : Set α → Set β\nhh : Monotone h\np : β → Prop\n⊢ Iff (Filter.Eventually (fun y => p y) (f.lift' h)) (Exists fun t => And (Membership.mem f t) (∀ (y : β), Membership.mem (h t) y → p y))","decl":"theorem eventually_lift'_iff (hh : Monotone h) {p : β → Prop} :\n    (∀ᶠ y in f.lift' h, p y) ↔ ∃ t ∈ f, ∀ y ∈ h t, p y :=\n  mem_lift'_sets hh\n\n"}
{"name":"Filter.sInter_lift'_sets","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\nh : Set α → Set β\nhh : Monotone h\n⊢ Eq (setOf fun s => Membership.mem (f.lift' h) s).sInter (Set.iInter fun s => Set.iInter fun h_1 => h s)","decl":"theorem sInter_lift'_sets (hh : Monotone h) : ⋂₀ { s | s ∈ f.lift' h } = ⋂ s ∈ f, h s :=\n  (sInter_lift_sets (monotone_principal.comp hh)).trans <| iInter₂_congr fun _ _ => csInf_Ici\n\n"}
{"name":"Filter.lift'_le","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Set α → Set β\nh : Filter β\ns : Set α\nhs : Membership.mem f s\nhg : LE.le (Filter.principal (g s)) h\n⊢ LE.le (f.lift' g) h","decl":"theorem lift'_le {f : Filter α} {g : Set α → Set β} {h : Filter β} {s : Set α} (hs : s ∈ f)\n    (hg : 𝓟 (g s) ≤ h) : f.lift' g ≤ h :=\n  lift_le hs hg\n\n"}
{"name":"Filter.lift'_mono","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf₁ f₂ : Filter α\nh₁ h₂ : Set α → Set β\nhf : LE.le f₁ f₂\nhh : LE.le h₁ h₂\n⊢ LE.le (f₁.lift' h₁) (f₂.lift' h₂)","decl":"theorem lift'_mono (hf : f₁ ≤ f₂) (hh : h₁ ≤ h₂) : f₁.lift' h₁ ≤ f₂.lift' h₂ :=\n  lift_mono hf fun s => principal_mono.mpr <| hh s\n\n"}
{"name":"Filter.lift'_mono'","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\nh₁ h₂ : Set α → Set β\nhh : ∀ (s : Set α), Membership.mem f s → HasSubset.Subset (h₁ s) (h₂ s)\n⊢ LE.le (f.lift' h₁) (f.lift' h₂)","decl":"theorem lift'_mono' (hh : ∀ s ∈ f, h₁ s ⊆ h₂ s) : f.lift' h₁ ≤ f.lift' h₂ :=\n  iInf₂_mono fun s hs => principal_mono.mpr <| hh s hs\n\n"}
{"name":"Filter.lift'_cong","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\nh₁ h₂ : Set α → Set β\nhh : ∀ (s : Set α), Membership.mem f s → Eq (h₁ s) (h₂ s)\n⊢ Eq (f.lift' h₁) (f.lift' h₂)","decl":"theorem lift'_cong (hh : ∀ s ∈ f, h₁ s = h₂ s) : f.lift' h₁ = f.lift' h₂ :=\n  le_antisymm (lift'_mono' fun s hs => le_of_eq <| hh s hs)\n    (lift'_mono' fun s hs => le_of_eq <| (hh s hs).symm)\n\n"}
{"name":"Filter.map_lift'_eq","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\nh : Set α → Set β\nm : β → γ\nhh : Monotone h\n⊢ Eq (Filter.map m (f.lift' h)) (f.lift' (Function.comp (Set.image m) h))","decl":"theorem map_lift'_eq {m : β → γ} (hh : Monotone h) : map m (f.lift' h) = f.lift' (image m ∘ h) :=\n  calc\n    map m (f.lift' h) = f.lift (map m ∘ 𝓟 ∘ h) := map_lift_eq <| monotone_principal.comp hh\n    _ = f.lift' (image m ∘ h) := by simp only [comp_def, Filter.lift', map_principal]\n\n"}
{"name":"Filter.lift'_map_le","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\ng : Set β → Set γ\nm : α → β\n⊢ LE.le ((Filter.map m f).lift' g) (f.lift' (Function.comp g (Set.image m)))","decl":"theorem lift'_map_le {g : Set β → Set γ} {m : α → β} : (map m f).lift' g ≤ f.lift' (g ∘ image m) :=\n  lift_map_le\n\n"}
{"name":"Filter.map_lift'_eq2","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\ng : Set β → Set γ\nm : α → β\nhg : Monotone g\n⊢ Eq ((Filter.map m f).lift' g) (f.lift' (Function.comp g (Set.image m)))","decl":"theorem map_lift'_eq2 {g : Set β → Set γ} {m : α → β} (hg : Monotone g) :\n    (map m f).lift' g = f.lift' (g ∘ image m) :=\n  map_lift_eq2 <| monotone_principal.comp hg\n\n"}
{"name":"Filter.comap_lift'_eq","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\nh : Set α → Set β\nm : γ → β\n⊢ Eq (Filter.comap m (f.lift' h)) (f.lift' (Function.comp (Set.preimage m) h))","decl":"theorem comap_lift'_eq {m : γ → β} : comap m (f.lift' h) = f.lift' (preimage m ∘ h) := by\n  simp only [Filter.lift', comap_lift_eq, comp_def, comap_principal]\n\n"}
{"name":"Filter.comap_lift'_eq2","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\nm : β → α\ng : Set β → Set γ\nhg : Monotone g\n⊢ Eq ((Filter.comap m f).lift' g) (f.lift' (Function.comp g (Set.preimage m)))","decl":"theorem comap_lift'_eq2 {m : β → α} {g : Set β → Set γ} (hg : Monotone g) :\n    (comap m f).lift' g = f.lift' (g ∘ preimage m) :=\n  comap_lift_eq2 <| monotone_principal.comp hg\n\n"}
{"name":"Filter.lift'_principal","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nh : Set α → Set β\ns : Set α\nhh : Monotone h\n⊢ Eq ((Filter.principal s).lift' h) (Filter.principal (h s))","decl":"theorem lift'_principal {s : Set α} (hh : Monotone h) : (𝓟 s).lift' h = 𝓟 (h s) :=\n  lift_principal <| monotone_principal.comp hh\n\n"}
{"name":"Filter.lift'_pure","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nh : Set α → Set β\na : α\nhh : Monotone h\n⊢ Eq ((Pure.pure a).lift' h) (Filter.principal (h (Singleton.singleton a)))","decl":"theorem lift'_pure {a : α} (hh : Monotone h) : (pure a : Filter α).lift' h = 𝓟 (h {a}) := by\n  rw [← principal_singleton, lift'_principal hh]\n\n"}
{"name":"Filter.lift'_bot","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nh : Set α → Set β\nhh : Monotone h\n⊢ Eq (Bot.bot.lift' h) (Filter.principal (h EmptyCollection.emptyCollection))","decl":"theorem lift'_bot (hh : Monotone h) : (⊥ : Filter α).lift' h = 𝓟 (h ∅) := by\n  rw [← principal_empty, lift'_principal hh]\n\n"}
{"name":"Filter.le_lift'","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\nh : Set α → Set β\ng : Filter β\n⊢ Iff (LE.le g (f.lift' h)) (∀ (s : Set α), Membership.mem f s → Membership.mem g (h s))","decl":"theorem le_lift' {f : Filter α} {h : Set α → Set β} {g : Filter β} :\n    g ≤ f.lift' h ↔ ∀ s ∈ f, h s ∈ g :=\n  le_lift.trans <| forall₂_congr fun _ _ => le_principal_iff\n\n"}
{"name":"Filter.principal_le_lift'","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\nh : Set α → Set β\nt : Set β\n⊢ Iff (LE.le (Filter.principal t) (f.lift' h)) (∀ (s : Set α), Membership.mem f s → HasSubset.Subset t (h s))","decl":"theorem principal_le_lift' {t : Set β} : 𝓟 t ≤ f.lift' h ↔ ∀ s ∈ f, t ⊆ h s :=\n  le_lift'\n\n"}
{"name":"Filter.monotone_lift'","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝ : Preorder γ\nf : γ → Filter α\ng : γ → Set α → Set β\nhf : Monotone f\nhg : Monotone g\n⊢ Monotone fun c => (f c).lift' (g c)","decl":"theorem monotone_lift' [Preorder γ] {f : γ → Filter α} {g : γ → Set α → Set β} (hf : Monotone f)\n    (hg : Monotone g) : Monotone fun c => (f c).lift' (g c) := fun _ _ h => lift'_mono (hf h) (hg h)\n\n"}
{"name":"Filter.lift_lift'_assoc","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\ng : Set α → Set β\nh : Set β → Filter γ\nhg : Monotone g\nhh : Monotone h\n⊢ Eq ((f.lift' g).lift h) (f.lift fun s => h (g s))","decl":"theorem lift_lift'_assoc {g : Set α → Set β} {h : Set β → Filter γ} (hg : Monotone g)\n    (hh : Monotone h) : (f.lift' g).lift h = f.lift fun s => h (g s) :=\n  calc\n    (f.lift' g).lift h = f.lift fun s => (𝓟 (g s)).lift h := lift_assoc (monotone_principal.comp hg)\n    _ = f.lift fun s => h (g s) := by simp only [lift_principal, hh, eq_self_iff_true]\n\n"}
{"name":"Filter.lift'_lift'_assoc","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\ng : Set α → Set β\nh : Set β → Set γ\nhg : Monotone g\nhh : Monotone h\n⊢ Eq ((f.lift' g).lift' h) (f.lift' fun s => h (g s))","decl":"theorem lift'_lift'_assoc {g : Set α → Set β} {h : Set β → Set γ} (hg : Monotone g)\n    (hh : Monotone h) : (f.lift' g).lift' h = f.lift' fun s => h (g s) :=\n  lift_lift'_assoc hg (monotone_principal.comp hh)\n\n"}
{"name":"Filter.lift'_lift_assoc","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : Filter α\ng : Set α → Filter β\nh : Set β → Set γ\nhg : Monotone g\n⊢ Eq ((f.lift g).lift' h) (f.lift fun s => (g s).lift' h)","decl":"theorem lift'_lift_assoc {g : Set α → Filter β} {h : Set β → Set γ} (hg : Monotone g) :\n    (f.lift g).lift' h = f.lift fun s => (g s).lift' h :=\n  lift_assoc hg\n\n"}
{"name":"Filter.lift_lift'_same_le_lift'","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Set α → Set α → Set β\n⊢ LE.le (f.lift fun s => f.lift' (g s)) (f.lift' fun s => g s s)","decl":"theorem lift_lift'_same_le_lift' {g : Set α → Set α → Set β} :\n    (f.lift fun s => f.lift' (g s)) ≤ f.lift' fun s => g s s :=\n  lift_lift_same_le_lift\n\n"}
{"name":"Filter.lift_lift'_same_eq_lift'","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Set α → Set α → Set β\nhg₁ : ∀ (s : Set α), Monotone fun t => g s t\nhg₂ : ∀ (t : Set α), Monotone fun s => g s t\n⊢ Eq (f.lift fun s => f.lift' (g s)) (f.lift' fun s => g s s)","decl":"theorem lift_lift'_same_eq_lift' {g : Set α → Set α → Set β} (hg₁ : ∀ s, Monotone fun t => g s t)\n    (hg₂ : ∀ t, Monotone fun s => g s t) :\n    (f.lift fun s => f.lift' (g s)) = f.lift' fun s => g s s :=\n  lift_lift_same_eq_lift (fun s => monotone_principal.comp (hg₁ s)) fun t =>\n    monotone_principal.comp (hg₂ t)\n\n"}
{"name":"Filter.lift'_inf_principal_eq","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\nh : Set α → Set β\ns : Set β\n⊢ Eq (Min.min (f.lift' h) (Filter.principal s)) (f.lift' fun t => Inter.inter (h t) s)","decl":"theorem lift'_inf_principal_eq {h : Set α → Set β} {s : Set β} :\n    f.lift' h ⊓ 𝓟 s = f.lift' fun t => h t ∩ s := by\n  simp only [Filter.lift', Filter.lift, (· ∘ ·), ← inf_principal, iInf_subtype', ← iInf_inf]\n\n"}
{"name":"Filter.lift'_neBot_iff","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\nh : Set α → Set β\nhh : Monotone h\n⊢ Iff (f.lift' h).NeBot (∀ (s : Set α), Membership.mem f s → (h s).Nonempty)","decl":"theorem lift'_neBot_iff (hh : Monotone h) : NeBot (f.lift' h) ↔ ∀ s ∈ f, (h s).Nonempty :=\n  calc\n    NeBot (f.lift' h) ↔ ∀ s ∈ f, NeBot (𝓟 (h s)) := lift_neBot_iff (monotone_principal.comp hh)\n    _ ↔ ∀ s ∈ f, (h s).Nonempty := by simp only [principal_neBot_iff]\n\n"}
{"name":"Filter.lift'_id","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nf : Filter α\n⊢ Eq (f.lift' id) f","decl":"@[simp]\ntheorem lift'_id {f : Filter α} : f.lift' id = f :=\n  lift_principal2\n\n"}
{"name":"Filter.lift'_iInf","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\ninst✝ : Nonempty ι\nf : ι → Filter α\ng : Set α → Set β\nhg : ∀ (s t : Set α), Eq (g (Inter.inter s t)) (Inter.inter (g s) (g t))\n⊢ Eq ((iInf f).lift' g) (iInf fun i => (f i).lift' g)","decl":"theorem lift'_iInf [Nonempty ι] {f : ι → Filter α} {g : Set α → Set β}\n    (hg : ∀ s t, g (s ∩ t) = g s ∩ g t) : (iInf f).lift' g = ⨅ i, (f i).lift' g :=\n  lift_iInf fun s t => by simp only [inf_principal, comp, hg]\n\n"}
{"name":"Filter.lift'_iInf_of_map_univ","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Sort u_4\nf : ι → Filter α\ng : Set α → Set β\nhg : ∀ {s t : Set α}, Eq (g (Inter.inter s t)) (Inter.inter (g s) (g t))\nhg' : Eq (g Set.univ) Set.univ\n⊢ Eq ((iInf f).lift' g) (iInf fun i => (f i).lift' g)","decl":"theorem lift'_iInf_of_map_univ {f : ι → Filter α} {g : Set α → Set β}\n    (hg : ∀ {s t}, g (s ∩ t) = g s ∩ g t) (hg' : g univ = univ) :\n    (iInf f).lift' g = ⨅ i, (f i).lift' g :=\n  lift_iInf_of_map_univ (fun s t => by simp only [inf_principal, comp, hg])\n    (by rw [Function.comp_apply, hg', principal_univ])\n\n"}
{"name":"Filter.lift'_inf","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : Filter α\ns : Set α → Set β\nhs : ∀ (t₁ t₂ : Set α), Eq (s (Inter.inter t₁ t₂)) (Inter.inter (s t₁) (s t₂))\n⊢ Eq ((Min.min f g).lift' s) (Min.min (f.lift' s) (g.lift' s))","decl":"theorem lift'_inf (f g : Filter α) {s : Set α → Set β} (hs : ∀ t₁ t₂, s (t₁ ∩ t₂) = s t₁ ∩ s t₂) :\n    (f ⊓ g).lift' s = f.lift' s ⊓ g.lift' s := by\n  rw [inf_eq_iInf, inf_eq_iInf, lift'_iInf hs]\n  refine iInf_congr ?_\n  rintro (_|_) <;> rfl\n\n"}
{"name":"Filter.lift'_inf_le","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : Filter α\ns : Set α → Set β\n⊢ LE.le ((Min.min f g).lift' s) (Min.min (f.lift' s) (g.lift' s))","decl":"theorem lift'_inf_le (f g : Filter α) (s : Set α → Set β) :\n    (f ⊓ g).lift' s ≤ f.lift' s ⊓ g.lift' s :=\n  le_inf (lift'_mono inf_le_left le_rfl) (lift'_mono inf_le_right le_rfl)\n\n"}
{"name":"Filter.comap_eq_lift'","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter β\nm : α → β\n⊢ Eq (Filter.comap m f) (f.lift' (Set.preimage m))","decl":"theorem comap_eq_lift' {f : Filter β} {m : α → β} : comap m f = f.lift' (preimage m) :=\n  Filter.ext fun _ => (mem_lift'_sets monotone_preimage).symm\n\n"}
{"name":"Filter.prod_def","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Filter α\ng : Filter β\n⊢ Eq (SProd.sprod f g) (f.lift fun s => g.lift' fun t => SProd.sprod s t)","decl":"theorem prod_def {f : Filter α} {g : Filter β} :\n    f ×ˢ g = f.lift fun s => g.lift' fun t => s ×ˢ t := by\n  simpa only [Filter.lift', Filter.lift, (f.basis_sets.prod g.basis_sets).eq_biInf,\n    iInf_prod, iInf_and] using iInf_congr fun i => iInf_comm\n\n"}
{"name":"Filter.mem_prod_same_iff","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nla : Filter α\ns : Set (Prod α α)\n⊢ Iff (Membership.mem (SProd.sprod la la) s) (Exists fun t => And (Membership.mem la t) (HasSubset.Subset (SProd.sprod t t) s))","decl":"alias mem_prod_same_iff := mem_prod_self_iff\n\n"}
{"name":"Filter.prod_same_eq","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nf : Filter α\n⊢ Eq (SProd.sprod f f) (f.lift' fun t => SProd.sprod t t)","decl":"theorem prod_same_eq : f ×ˢ f = f.lift' fun t : Set α => t ×ˢ t :=\n  f.basis_sets.prod_self.eq_biInf\n\n"}
{"name":"Filter.tendsto_prod_self_iff","module":"Mathlib.Order.Filter.Lift","initialProofState":"α : Type u_1\nβ : Type u_2\nf : Prod α α → β\nx : Filter α\ny : Filter β\n⊢ Iff (Filter.Tendsto f (SProd.sprod x x) y) (∀ (W : Set β), Membership.mem y W → Exists fun U => And (Membership.mem x U) (∀ (x x' : α), Membership.mem U x → Membership.mem U x' → Membership.mem W (f { fst := x, snd := x' })))","decl":"theorem tendsto_prod_self_iff {f : α × α → β} {x : Filter α} {y : Filter β} :\n    Filter.Tendsto f (x ×ˢ x) y ↔ ∀ W ∈ y, ∃ U ∈ x, ∀ x x' : α, x ∈ U → x' ∈ U → f (x, x') ∈ W := by\n  simp only [tendsto_def, mem_prod_same_iff, prod_sub_preimage_iff, exists_prop]\n\n"}
{"name":"Filter.prod_lift_lift","module":"Mathlib.Order.Filter.Lift","initialProofState":"α₁ : Type u_5\nα₂ : Type u_6\nβ₁ : Type u_7\nβ₂ : Type u_8\nf₁ : Filter α₁\nf₂ : Filter α₂\ng₁ : Set α₁ → Filter β₁\ng₂ : Set α₂ → Filter β₂\nhg₁ : Monotone g₁\nhg₂ : Monotone g₂\n⊢ Eq (SProd.sprod (f₁.lift g₁) (f₂.lift g₂)) (f₁.lift fun s => f₂.lift fun t => SProd.sprod (g₁ s) (g₂ t))","decl":"theorem prod_lift_lift {f₁ : Filter α₁} {f₂ : Filter α₂} {g₁ : Set α₁ → Filter β₁}\n    {g₂ : Set α₂ → Filter β₂} (hg₁ : Monotone g₁) (hg₂ : Monotone g₂) :\n    f₁.lift g₁ ×ˢ f₂.lift g₂ = f₁.lift fun s => f₂.lift fun t => g₁ s ×ˢ g₂ t := by\n  simp only [prod_def, lift_assoc hg₁]\n  apply congr_arg; funext x\n  rw [lift_comm]\n  apply congr_arg; funext y\n  apply lift'_lift_assoc hg₂\n\n"}
{"name":"Filter.prod_lift'_lift'","module":"Mathlib.Order.Filter.Lift","initialProofState":"α₁ : Type u_5\nα₂ : Type u_6\nβ₁ : Type u_7\nβ₂ : Type u_8\nf₁ : Filter α₁\nf₂ : Filter α₂\ng₁ : Set α₁ → Set β₁\ng₂ : Set α₂ → Set β₂\nhg₁ : Monotone g₁\nhg₂ : Monotone g₂\n⊢ Eq (SProd.sprod (f₁.lift' g₁) (f₂.lift' g₂)) (f₁.lift fun s => f₂.lift' fun t => SProd.sprod (g₁ s) (g₂ t))","decl":"theorem prod_lift'_lift' {f₁ : Filter α₁} {f₂ : Filter α₂} {g₁ : Set α₁ → Set β₁}\n    {g₂ : Set α₂ → Set β₂} (hg₁ : Monotone g₁) (hg₂ : Monotone g₂) :\n    f₁.lift' g₁ ×ˢ f₂.lift' g₂ = f₁.lift fun s => f₂.lift' fun t => g₁ s ×ˢ g₂ t :=\n  calc\n    f₁.lift' g₁ ×ˢ f₂.lift' g₂ = f₁.lift fun s => f₂.lift fun t => 𝓟 (g₁ s) ×ˢ 𝓟 (g₂ t) :=\n      prod_lift_lift (monotone_principal.comp hg₁) (monotone_principal.comp hg₂)\n    _ = f₁.lift fun s => f₂.lift fun t => 𝓟 (g₁ s ×ˢ g₂ t) := by\n      { simp only [prod_principal_principal] }\n\n"}
