{"name":"CategoryTheory.FreeBicategory.Hom.comp.injEq","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na b‚úù c : B\nf‚úù : CategoryTheory.FreeBicategory.Hom a b‚úù\ng‚úù : CategoryTheory.FreeBicategory.Hom b‚úù c\nb : B\nf : CategoryTheory.FreeBicategory.Hom a b\ng : CategoryTheory.FreeBicategory.Hom b c\n‚ä¢ Eq (Eq (f‚úù.comp g‚úù) (f.comp g)) (And (Eq b‚úù b) (And (HEq f‚úù f) (HEq g‚úù g)))","decl":"/-- 1-morphisms in the free bicategory. -/\ninductive Hom : B ‚Üí B ‚Üí Type max u v\n  | of {a b : B} (f : a ‚ü∂ b) : Hom a b\n  | id (a : B) : Hom a a\n  | comp {a b c : B} (f : Hom a b) (g : Hom b c) : Hom a c\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom.of.inj","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na b : B\nf‚úù f : Quiver.Hom a b\nx‚úù : Eq (CategoryTheory.FreeBicategory.Hom.of f‚úù) (CategoryTheory.FreeBicategory.Hom.of f)\n‚ä¢ Eq f‚úù f","decl":"/-- 1-morphisms in the free bicategory. -/\ninductive Hom : B ‚Üí B ‚Üí Type max u v\n  | of {a b : B} (f : a ‚ü∂ b) : Hom a b\n  | id (a : B) : Hom a a\n  | comp {a b c : B} (f : Hom a b) (g : Hom b c) : Hom a c\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom.comp.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù¬π : Quiver B\ninst‚úù : SizeOf B\na b c : B\nf : CategoryTheory.FreeBicategory.Hom a b\ng : CategoryTheory.FreeBicategory.Hom b c\n‚ä¢ Eq (SizeOf.sizeOf (f.comp g)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf c)) (SizeOf.sizeOf f)) (SizeOf.sizeOf g))","decl":"/-- 1-morphisms in the free bicategory. -/\ninductive Hom : B ‚Üí B ‚Üí Type max u v\n  | of {a b : B} (f : a ‚ü∂ b) : Hom a b\n  | id (a : B) : Hom a a\n  | comp {a b c : B} (f : Hom a b) (g : Hom b c) : Hom a c\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom.of.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù¬π : Quiver B\ninst‚úù : SizeOf B\na b : B\nf : Quiver.Hom a b\n‚ä¢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom.of f)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf f))","decl":"/-- 1-morphisms in the free bicategory. -/\ninductive Hom : B ‚Üí B ‚Üí Type max u v\n  | of {a b : B} (f : a ‚ü∂ b) : Hom a b\n  | id (a : B) : Hom a a\n  | comp {a b c : B} (f : Hom a b) (g : Hom b c) : Hom a c\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom.id.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù¬π : Quiver B\ninst‚úù : SizeOf B\na : B\n‚ä¢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom.id a)) (HAdd.hAdd 1 (SizeOf.sizeOf a))","decl":"/-- 1-morphisms in the free bicategory. -/\ninductive Hom : B ‚Üí B ‚Üí Type max u v\n  | of {a b : B} (f : a ‚ü∂ b) : Hom a b\n  | id (a : B) : Hom a a\n  | comp {a b c : B} (f : Hom a b) (g : Hom b c) : Hom a c\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom.comp.inj","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na b‚úù c : B\nf‚úù : CategoryTheory.FreeBicategory.Hom a b‚úù\ng‚úù : CategoryTheory.FreeBicategory.Hom b‚úù c\nb : B\nf : CategoryTheory.FreeBicategory.Hom a b\ng : CategoryTheory.FreeBicategory.Hom b c\nx‚úù : Eq (f‚úù.comp g‚úù) (f.comp g)\n‚ä¢ And (Eq b‚úù b) (And (HEq f‚úù f) (HEq g‚úù g))","decl":"/-- 1-morphisms in the free bicategory. -/\ninductive Hom : B ‚Üí B ‚Üí Type max u v\n  | of {a b : B} (f : a ‚ü∂ b) : Hom a b\n  | id (a : B) : Hom a a\n  | comp {a b c : B} (f : Hom a b) (g : Hom b c) : Hom a c\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom.of.injEq","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na b : B\nf‚úù f : Quiver.Hom a b\n‚ä¢ Eq (Eq (CategoryTheory.FreeBicategory.Hom.of f‚úù) (CategoryTheory.FreeBicategory.Hom.of f)) (Eq f‚úù f)","decl":"/-- 1-morphisms in the free bicategory. -/\ninductive Hom : B ‚Üí B ‚Üí Type max u v\n  | of {a b : B} (f : a ‚ü∂ b) : Hom a b\n  | id (a : B) : Hom a a\n  | comp {a b c : B} (f : Hom a b) (g : Hom b c) : Hom a c\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom‚ÇÇ.whisker_right.inj","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na b c : CategoryTheory.FreeBicategory B\nf g : Quiver.Hom a b\nh : Quiver.Hom b c\nŒ∑‚úù Œ∑ : CategoryTheory.FreeBicategory.Hom‚ÇÇ f g\nx‚úù : Eq (CategoryTheory.FreeBicategory.Hom‚ÇÇ.whisker_right h Œ∑‚úù) (CategoryTheory.FreeBicategory.Hom‚ÇÇ.whisker_right h Œ∑)\n‚ä¢ Eq Œ∑‚úù Œ∑","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom‚ÇÇ : ‚àÄ {a b : FreeBicategory B}, (a ‚ü∂ b) ‚Üí (a ‚ü∂ b) ‚Üí Type max u v\n  | id {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f f\n  | vcomp {a b} {f g h : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) : Hom‚ÇÇ f h\n  | whisker_left {a b c} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : Hom‚ÇÇ g h) :\n      Hom‚ÇÇ (f ‚â´ g) (f ‚â´ h)-- `Œ∑` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ‚ü∂ b} (h : b ‚ü∂ c) (Œ∑ : Hom‚ÇÇ f g) : Hom‚ÇÇ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ ((f ‚â´ g) ‚â´ h) (f ‚â´ (g ‚â´ h))\n  | associator_inv {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ (f ‚â´ (g ‚â´ h)) ((f ‚â´ g) ‚â´ h)\n  | right_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ (f ‚â´ (ùüô b)) f\n  | right_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f (f ‚â´ (ùüô b))\n  | left_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ ((ùüô a) ‚â´ f) f\n  | left_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f ((ùüô a) ‚â´ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom‚ÇÇ.right_unitor.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù¬π : Quiver B\ninst‚úù : SizeOf B\na b : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\n‚ä¢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom‚ÇÇ.right_unitor f)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf f))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom‚ÇÇ : ‚àÄ {a b : FreeBicategory B}, (a ‚ü∂ b) ‚Üí (a ‚ü∂ b) ‚Üí Type max u v\n  | id {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f f\n  | vcomp {a b} {f g h : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) : Hom‚ÇÇ f h\n  | whisker_left {a b c} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : Hom‚ÇÇ g h) :\n      Hom‚ÇÇ (f ‚â´ g) (f ‚â´ h)-- `Œ∑` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ‚ü∂ b} (h : b ‚ü∂ c) (Œ∑ : Hom‚ÇÇ f g) : Hom‚ÇÇ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ ((f ‚â´ g) ‚â´ h) (f ‚â´ (g ‚â´ h))\n  | associator_inv {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ (f ‚â´ (g ‚â´ h)) ((f ‚â´ g) ‚â´ h)\n  | right_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ (f ‚â´ (ùüô b)) f\n  | right_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f (f ‚â´ (ùüô b))\n  | left_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ ((ùüô a) ‚â´ f) f\n  | left_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f ((ùüô a) ‚â´ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom‚ÇÇ.right_unitor_inv.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù¬π : Quiver B\ninst‚úù : SizeOf B\na b : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\n‚ä¢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom‚ÇÇ.right_unitor_inv f)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf f))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom‚ÇÇ : ‚àÄ {a b : FreeBicategory B}, (a ‚ü∂ b) ‚Üí (a ‚ü∂ b) ‚Üí Type max u v\n  | id {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f f\n  | vcomp {a b} {f g h : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) : Hom‚ÇÇ f h\n  | whisker_left {a b c} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : Hom‚ÇÇ g h) :\n      Hom‚ÇÇ (f ‚â´ g) (f ‚â´ h)-- `Œ∑` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ‚ü∂ b} (h : b ‚ü∂ c) (Œ∑ : Hom‚ÇÇ f g) : Hom‚ÇÇ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ ((f ‚â´ g) ‚â´ h) (f ‚â´ (g ‚â´ h))\n  | associator_inv {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ (f ‚â´ (g ‚â´ h)) ((f ‚â´ g) ‚â´ h)\n  | right_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ (f ‚â´ (ùüô b)) f\n  | right_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f (f ‚â´ (ùüô b))\n  | left_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ ((ùüô a) ‚â´ f) f\n  | left_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f ((ùüô a) ‚â´ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom‚ÇÇ.left_unitor_inv.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù¬π : Quiver B\ninst‚úù : SizeOf B\na b : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\n‚ä¢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom‚ÇÇ.left_unitor_inv f)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf f))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom‚ÇÇ : ‚àÄ {a b : FreeBicategory B}, (a ‚ü∂ b) ‚Üí (a ‚ü∂ b) ‚Üí Type max u v\n  | id {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f f\n  | vcomp {a b} {f g h : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) : Hom‚ÇÇ f h\n  | whisker_left {a b c} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : Hom‚ÇÇ g h) :\n      Hom‚ÇÇ (f ‚â´ g) (f ‚â´ h)-- `Œ∑` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ‚ü∂ b} (h : b ‚ü∂ c) (Œ∑ : Hom‚ÇÇ f g) : Hom‚ÇÇ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ ((f ‚â´ g) ‚â´ h) (f ‚â´ (g ‚â´ h))\n  | associator_inv {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ (f ‚â´ (g ‚â´ h)) ((f ‚â´ g) ‚â´ h)\n  | right_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ (f ‚â´ (ùüô b)) f\n  | right_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f (f ‚â´ (ùüô b))\n  | left_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ ((ùüô a) ‚â´ f) f\n  | left_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f ((ùüô a) ‚â´ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom‚ÇÇ.left_unitor.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù¬π : Quiver B\ninst‚úù : SizeOf B\na b : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\n‚ä¢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom‚ÇÇ.left_unitor f)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf f))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom‚ÇÇ : ‚àÄ {a b : FreeBicategory B}, (a ‚ü∂ b) ‚Üí (a ‚ü∂ b) ‚Üí Type max u v\n  | id {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f f\n  | vcomp {a b} {f g h : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) : Hom‚ÇÇ f h\n  | whisker_left {a b c} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : Hom‚ÇÇ g h) :\n      Hom‚ÇÇ (f ‚â´ g) (f ‚â´ h)-- `Œ∑` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ‚ü∂ b} (h : b ‚ü∂ c) (Œ∑ : Hom‚ÇÇ f g) : Hom‚ÇÇ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ ((f ‚â´ g) ‚â´ h) (f ‚â´ (g ‚â´ h))\n  | associator_inv {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ (f ‚â´ (g ‚â´ h)) ((f ‚â´ g) ‚â´ h)\n  | right_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ (f ‚â´ (ùüô b)) f\n  | right_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f (f ‚â´ (ùüô b))\n  | left_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ ((ùüô a) ‚â´ f) f\n  | left_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f ((ùüô a) ‚â´ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom‚ÇÇ.associator_inv.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù¬π : Quiver B\ninst‚úù : SizeOf B\na b c d : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n‚ä¢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom‚ÇÇ.associator_inv f g h)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf c)) (SizeOf.sizeOf d)) (SizeOf.sizeOf f)) (SizeOf.sizeOf g)) (SizeOf.sizeOf h))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom‚ÇÇ : ‚àÄ {a b : FreeBicategory B}, (a ‚ü∂ b) ‚Üí (a ‚ü∂ b) ‚Üí Type max u v\n  | id {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f f\n  | vcomp {a b} {f g h : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) : Hom‚ÇÇ f h\n  | whisker_left {a b c} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : Hom‚ÇÇ g h) :\n      Hom‚ÇÇ (f ‚â´ g) (f ‚â´ h)-- `Œ∑` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ‚ü∂ b} (h : b ‚ü∂ c) (Œ∑ : Hom‚ÇÇ f g) : Hom‚ÇÇ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ ((f ‚â´ g) ‚â´ h) (f ‚â´ (g ‚â´ h))\n  | associator_inv {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ (f ‚â´ (g ‚â´ h)) ((f ‚â´ g) ‚â´ h)\n  | right_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ (f ‚â´ (ùüô b)) f\n  | right_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f (f ‚â´ (ùüô b))\n  | left_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ ((ùüô a) ‚â´ f) f\n  | left_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f ((ùüô a) ‚â´ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom‚ÇÇ.whisker_left.inj","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na b c : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\ng h : Quiver.Hom b c\nŒ∑‚úù Œ∑ : CategoryTheory.FreeBicategory.Hom‚ÇÇ g h\nx‚úù : Eq (CategoryTheory.FreeBicategory.Hom‚ÇÇ.whisker_left f Œ∑‚úù) (CategoryTheory.FreeBicategory.Hom‚ÇÇ.whisker_left f Œ∑)\n‚ä¢ Eq Œ∑‚úù Œ∑","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom‚ÇÇ : ‚àÄ {a b : FreeBicategory B}, (a ‚ü∂ b) ‚Üí (a ‚ü∂ b) ‚Üí Type max u v\n  | id {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f f\n  | vcomp {a b} {f g h : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) : Hom‚ÇÇ f h\n  | whisker_left {a b c} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : Hom‚ÇÇ g h) :\n      Hom‚ÇÇ (f ‚â´ g) (f ‚â´ h)-- `Œ∑` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ‚ü∂ b} (h : b ‚ü∂ c) (Œ∑ : Hom‚ÇÇ f g) : Hom‚ÇÇ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ ((f ‚â´ g) ‚â´ h) (f ‚â´ (g ‚â´ h))\n  | associator_inv {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ (f ‚â´ (g ‚â´ h)) ((f ‚â´ g) ‚â´ h)\n  | right_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ (f ‚â´ (ùüô b)) f\n  | right_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f (f ‚â´ (ùüô b))\n  | left_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ ((ùüô a) ‚â´ f) f\n  | left_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f ((ùüô a) ‚â´ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom‚ÇÇ.associator.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù¬π : Quiver B\ninst‚úù : SizeOf B\na b c d : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n‚ä¢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom‚ÇÇ.associator f g h)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf c)) (SizeOf.sizeOf d)) (SizeOf.sizeOf f)) (SizeOf.sizeOf g)) (SizeOf.sizeOf h))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom‚ÇÇ : ‚àÄ {a b : FreeBicategory B}, (a ‚ü∂ b) ‚Üí (a ‚ü∂ b) ‚Üí Type max u v\n  | id {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f f\n  | vcomp {a b} {f g h : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) : Hom‚ÇÇ f h\n  | whisker_left {a b c} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : Hom‚ÇÇ g h) :\n      Hom‚ÇÇ (f ‚â´ g) (f ‚â´ h)-- `Œ∑` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ‚ü∂ b} (h : b ‚ü∂ c) (Œ∑ : Hom‚ÇÇ f g) : Hom‚ÇÇ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ ((f ‚â´ g) ‚â´ h) (f ‚â´ (g ‚â´ h))\n  | associator_inv {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ (f ‚â´ (g ‚â´ h)) ((f ‚â´ g) ‚â´ h)\n  | right_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ (f ‚â´ (ùüô b)) f\n  | right_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f (f ‚â´ (ùüô b))\n  | left_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ ((ùüô a) ‚â´ f) f\n  | left_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f ((ùüô a) ‚â´ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom‚ÇÇ.whisker_left.injEq","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na b c : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\ng h : Quiver.Hom b c\nŒ∑‚úù Œ∑ : CategoryTheory.FreeBicategory.Hom‚ÇÇ g h\n‚ä¢ Eq (Eq (CategoryTheory.FreeBicategory.Hom‚ÇÇ.whisker_left f Œ∑‚úù) (CategoryTheory.FreeBicategory.Hom‚ÇÇ.whisker_left f Œ∑)) (Eq Œ∑‚úù Œ∑)","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom‚ÇÇ : ‚àÄ {a b : FreeBicategory B}, (a ‚ü∂ b) ‚Üí (a ‚ü∂ b) ‚Üí Type max u v\n  | id {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f f\n  | vcomp {a b} {f g h : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) : Hom‚ÇÇ f h\n  | whisker_left {a b c} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : Hom‚ÇÇ g h) :\n      Hom‚ÇÇ (f ‚â´ g) (f ‚â´ h)-- `Œ∑` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ‚ü∂ b} (h : b ‚ü∂ c) (Œ∑ : Hom‚ÇÇ f g) : Hom‚ÇÇ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ ((f ‚â´ g) ‚â´ h) (f ‚â´ (g ‚â´ h))\n  | associator_inv {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ (f ‚â´ (g ‚â´ h)) ((f ‚â´ g) ‚â´ h)\n  | right_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ (f ‚â´ (ùüô b)) f\n  | right_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f (f ‚â´ (ùüô b))\n  | left_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ ((ùüô a) ‚â´ f) f\n  | left_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f ((ùüô a) ‚â´ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom‚ÇÇ.id.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù¬π : Quiver B\ninst‚úù : SizeOf B\na b : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\n‚ä¢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom‚ÇÇ.id f)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf f))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom‚ÇÇ : ‚àÄ {a b : FreeBicategory B}, (a ‚ü∂ b) ‚Üí (a ‚ü∂ b) ‚Üí Type max u v\n  | id {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f f\n  | vcomp {a b} {f g h : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) : Hom‚ÇÇ f h\n  | whisker_left {a b c} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : Hom‚ÇÇ g h) :\n      Hom‚ÇÇ (f ‚â´ g) (f ‚â´ h)-- `Œ∑` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ‚ü∂ b} (h : b ‚ü∂ c) (Œ∑ : Hom‚ÇÇ f g) : Hom‚ÇÇ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ ((f ‚â´ g) ‚â´ h) (f ‚â´ (g ‚â´ h))\n  | associator_inv {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ (f ‚â´ (g ‚â´ h)) ((f ‚â´ g) ‚â´ h)\n  | right_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ (f ‚â´ (ùüô b)) f\n  | right_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f (f ‚â´ (ùüô b))\n  | left_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ ((ùüô a) ‚â´ f) f\n  | left_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f ((ùüô a) ‚â´ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom‚ÇÇ.vcomp.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù¬π : Quiver B\ninst‚úù : SizeOf B\na b : CategoryTheory.FreeBicategory B\nf g h : Quiver.Hom a b\nŒ∑ : CategoryTheory.FreeBicategory.Hom‚ÇÇ f g\nŒ∏ : CategoryTheory.FreeBicategory.Hom‚ÇÇ g h\n‚ä¢ Eq (SizeOf.sizeOf (Œ∑.vcomp Œ∏)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf f)) (SizeOf.sizeOf g)) (SizeOf.sizeOf h)) (SizeOf.sizeOf Œ∑)) (SizeOf.sizeOf Œ∏))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom‚ÇÇ : ‚àÄ {a b : FreeBicategory B}, (a ‚ü∂ b) ‚Üí (a ‚ü∂ b) ‚Üí Type max u v\n  | id {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f f\n  | vcomp {a b} {f g h : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) : Hom‚ÇÇ f h\n  | whisker_left {a b c} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : Hom‚ÇÇ g h) :\n      Hom‚ÇÇ (f ‚â´ g) (f ‚â´ h)-- `Œ∑` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ‚ü∂ b} (h : b ‚ü∂ c) (Œ∑ : Hom‚ÇÇ f g) : Hom‚ÇÇ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ ((f ‚â´ g) ‚â´ h) (f ‚â´ (g ‚â´ h))\n  | associator_inv {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ (f ‚â´ (g ‚â´ h)) ((f ‚â´ g) ‚â´ h)\n  | right_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ (f ‚â´ (ùüô b)) f\n  | right_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f (f ‚â´ (ùüô b))\n  | left_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ ((ùüô a) ‚â´ f) f\n  | left_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f ((ùüô a) ‚â´ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom‚ÇÇ.vcomp.injEq","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na b : CategoryTheory.FreeBicategory B\nf g‚úù h : Quiver.Hom a b\nŒ∑‚úù : CategoryTheory.FreeBicategory.Hom‚ÇÇ f g‚úù\nŒ∏‚úù : CategoryTheory.FreeBicategory.Hom‚ÇÇ g‚úù h\ng : Quiver.Hom a b\nŒ∑ : CategoryTheory.FreeBicategory.Hom‚ÇÇ f g\nŒ∏ : CategoryTheory.FreeBicategory.Hom‚ÇÇ g h\n‚ä¢ Eq (Eq (Œ∑‚úù.vcomp Œ∏‚úù) (Œ∑.vcomp Œ∏)) (And (Eq g‚úù g) (And (HEq Œ∑‚úù Œ∑) (HEq Œ∏‚úù Œ∏)))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom‚ÇÇ : ‚àÄ {a b : FreeBicategory B}, (a ‚ü∂ b) ‚Üí (a ‚ü∂ b) ‚Üí Type max u v\n  | id {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f f\n  | vcomp {a b} {f g h : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) : Hom‚ÇÇ f h\n  | whisker_left {a b c} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : Hom‚ÇÇ g h) :\n      Hom‚ÇÇ (f ‚â´ g) (f ‚â´ h)-- `Œ∑` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ‚ü∂ b} (h : b ‚ü∂ c) (Œ∑ : Hom‚ÇÇ f g) : Hom‚ÇÇ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ ((f ‚â´ g) ‚â´ h) (f ‚â´ (g ‚â´ h))\n  | associator_inv {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ (f ‚â´ (g ‚â´ h)) ((f ‚â´ g) ‚â´ h)\n  | right_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ (f ‚â´ (ùüô b)) f\n  | right_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f (f ‚â´ (ùüô b))\n  | left_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ ((ùüô a) ‚â´ f) f\n  | left_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f ((ùüô a) ‚â´ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom‚ÇÇ.whisker_right.injEq","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na b c : CategoryTheory.FreeBicategory B\nf g : Quiver.Hom a b\nh : Quiver.Hom b c\nŒ∑‚úù Œ∑ : CategoryTheory.FreeBicategory.Hom‚ÇÇ f g\n‚ä¢ Eq (Eq (CategoryTheory.FreeBicategory.Hom‚ÇÇ.whisker_right h Œ∑‚úù) (CategoryTheory.FreeBicategory.Hom‚ÇÇ.whisker_right h Œ∑)) (Eq Œ∑‚úù Œ∑)","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom‚ÇÇ : ‚àÄ {a b : FreeBicategory B}, (a ‚ü∂ b) ‚Üí (a ‚ü∂ b) ‚Üí Type max u v\n  | id {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f f\n  | vcomp {a b} {f g h : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) : Hom‚ÇÇ f h\n  | whisker_left {a b c} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : Hom‚ÇÇ g h) :\n      Hom‚ÇÇ (f ‚â´ g) (f ‚â´ h)-- `Œ∑` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ‚ü∂ b} (h : b ‚ü∂ c) (Œ∑ : Hom‚ÇÇ f g) : Hom‚ÇÇ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ ((f ‚â´ g) ‚â´ h) (f ‚â´ (g ‚â´ h))\n  | associator_inv {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ (f ‚â´ (g ‚â´ h)) ((f ‚â´ g) ‚â´ h)\n  | right_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ (f ‚â´ (ùüô b)) f\n  | right_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f (f ‚â´ (ùüô b))\n  | left_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ ((ùüô a) ‚â´ f) f\n  | left_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f ((ùüô a) ‚â´ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom‚ÇÇ.whisker_right.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù¬π : Quiver B\ninst‚úù : SizeOf B\na b c : CategoryTheory.FreeBicategory B\nf g : Quiver.Hom a b\nh : Quiver.Hom b c\nŒ∑ : CategoryTheory.FreeBicategory.Hom‚ÇÇ f g\n‚ä¢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom‚ÇÇ.whisker_right h Œ∑)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf c)) (SizeOf.sizeOf f)) (SizeOf.sizeOf g)) (SizeOf.sizeOf h)) (SizeOf.sizeOf Œ∑))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom‚ÇÇ : ‚àÄ {a b : FreeBicategory B}, (a ‚ü∂ b) ‚Üí (a ‚ü∂ b) ‚Üí Type max u v\n  | id {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f f\n  | vcomp {a b} {f g h : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) : Hom‚ÇÇ f h\n  | whisker_left {a b c} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : Hom‚ÇÇ g h) :\n      Hom‚ÇÇ (f ‚â´ g) (f ‚â´ h)-- `Œ∑` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ‚ü∂ b} (h : b ‚ü∂ c) (Œ∑ : Hom‚ÇÇ f g) : Hom‚ÇÇ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ ((f ‚â´ g) ‚â´ h) (f ‚â´ (g ‚â´ h))\n  | associator_inv {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ (f ‚â´ (g ‚â´ h)) ((f ‚â´ g) ‚â´ h)\n  | right_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ (f ‚â´ (ùüô b)) f\n  | right_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f (f ‚â´ (ùüô b))\n  | left_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ ((ùüô a) ‚â´ f) f\n  | left_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f ((ùüô a) ‚â´ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom‚ÇÇ.whisker_left.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù¬π : Quiver B\ninst‚úù : SizeOf B\na b c : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\ng h : Quiver.Hom b c\nŒ∑ : CategoryTheory.FreeBicategory.Hom‚ÇÇ g h\n‚ä¢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom‚ÇÇ.whisker_left f Œ∑)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf c)) (SizeOf.sizeOf f)) (SizeOf.sizeOf g)) (SizeOf.sizeOf h)) (SizeOf.sizeOf Œ∑))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom‚ÇÇ : ‚àÄ {a b : FreeBicategory B}, (a ‚ü∂ b) ‚Üí (a ‚ü∂ b) ‚Üí Type max u v\n  | id {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f f\n  | vcomp {a b} {f g h : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) : Hom‚ÇÇ f h\n  | whisker_left {a b c} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : Hom‚ÇÇ g h) :\n      Hom‚ÇÇ (f ‚â´ g) (f ‚â´ h)-- `Œ∑` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ‚ü∂ b} (h : b ‚ü∂ c) (Œ∑ : Hom‚ÇÇ f g) : Hom‚ÇÇ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ ((f ‚â´ g) ‚â´ h) (f ‚â´ (g ‚â´ h))\n  | associator_inv {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ (f ‚â´ (g ‚â´ h)) ((f ‚â´ g) ‚â´ h)\n  | right_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ (f ‚â´ (ùüô b)) f\n  | right_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f (f ‚â´ (ùüô b))\n  | left_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ ((ùüô a) ‚â´ f) f\n  | left_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f ((ùüô a) ‚â´ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom‚ÇÇ.vcomp.inj","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na b : CategoryTheory.FreeBicategory B\nf g‚úù h : Quiver.Hom a b\nŒ∑‚úù : CategoryTheory.FreeBicategory.Hom‚ÇÇ f g‚úù\nŒ∏‚úù : CategoryTheory.FreeBicategory.Hom‚ÇÇ g‚úù h\ng : Quiver.Hom a b\nŒ∑ : CategoryTheory.FreeBicategory.Hom‚ÇÇ f g\nŒ∏ : CategoryTheory.FreeBicategory.Hom‚ÇÇ g h\nx‚úù : Eq (Œ∑‚úù.vcomp Œ∏‚úù) (Œ∑.vcomp Œ∏)\n‚ä¢ And (Eq g‚úù g) (And (HEq Œ∑‚úù Œ∑) (HEq Œ∏‚úù Œ∏))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom‚ÇÇ : ‚àÄ {a b : FreeBicategory B}, (a ‚ü∂ b) ‚Üí (a ‚ü∂ b) ‚Üí Type max u v\n  | id {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f f\n  | vcomp {a b} {f g h : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) : Hom‚ÇÇ f h\n  | whisker_left {a b c} (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : Hom‚ÇÇ g h) :\n      Hom‚ÇÇ (f ‚â´ g) (f ‚â´ h)-- `Œ∑` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ‚ü∂ b} (h : b ‚ü∂ c) (Œ∑ : Hom‚ÇÇ f g) : Hom‚ÇÇ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ ((f ‚â´ g) ‚â´ h) (f ‚â´ (g ‚â´ h))\n  | associator_inv {a b c d} (f : a ‚ü∂ b) (g : b ‚ü∂ c) (h : c ‚ü∂ d) :\n      Hom‚ÇÇ (f ‚â´ (g ‚â´ h)) ((f ‚â´ g) ‚â´ h)\n  | right_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ (f ‚â´ (ùüô b)) f\n  | right_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f (f ‚â´ (ùüô b))\n  | left_unitor {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ ((ùüô a) ‚â´ f) f\n  | left_unitor_inv {a b} (f : a ‚ü∂ b) : Hom‚ÇÇ f ((ùüô a) ‚â´ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Rel.brecOn","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\nmotive‚úù : {a b : CategoryTheory.FreeBicategory B} ‚Üí {f g : Quiver.Hom a b} ‚Üí (a_1 a_2 : CategoryTheory.FreeBicategory.Hom‚ÇÇ f g) ‚Üí CategoryTheory.FreeBicategory.Rel a_1 a_2 ‚Üí Prop\na b : CategoryTheory.FreeBicategory B\nf g : Quiver.Hom a b\na‚úù¬π a‚úù : CategoryTheory.FreeBicategory.Hom‚ÇÇ f g\nx‚úù : CategoryTheory.FreeBicategory.Rel a‚úù¬π a‚úù\nih‚úù : ‚àÄ {a b : CategoryTheory.FreeBicategory B} {f g : Quiver.Hom a b} (a_1 a_2 : CategoryTheory.FreeBicategory.Hom‚ÇÇ f g) (x : CategoryTheory.FreeBicategory.Rel a_1 a_2), x.below ‚Üí motive‚úù a_1 a_2 x\n‚ä¢ motive‚úù a‚úù¬π a‚úù x‚úù","decl":"/-- Relations between 2-morphisms in the free bicategory. -/\ninductive Rel : ‚àÄ {a b : FreeBicategory B} {f g : a ‚ü∂ b}, Hom‚ÇÇ f g ‚Üí Hom‚ÇÇ f g ‚Üí Prop\n  | vcomp_right {a b} {f g h : Hom a b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏‚ÇÅ Œ∏‚ÇÇ : Hom‚ÇÇ g h) :\n      Rel Œ∏‚ÇÅ Œ∏‚ÇÇ ‚Üí Rel (Œ∑ ‚â´ Œ∏‚ÇÅ) (Œ∑ ‚â´ Œ∏‚ÇÇ)\n  | vcomp_left {a b} {f g h : Hom a b} (Œ∑‚ÇÅ Œ∑‚ÇÇ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) :\n      Rel Œ∑‚ÇÅ Œ∑‚ÇÇ ‚Üí Rel (Œ∑‚ÇÅ ‚â´ Œ∏) (Œ∑‚ÇÇ ‚â´ Œ∏)\n  | id_comp {a b} {f g : Hom a b} (Œ∑ : Hom‚ÇÇ f g) : Rel (ùüô f ‚â´ Œ∑) Œ∑\n  | comp_id {a b} {f g : Hom a b} (Œ∑ : Hom‚ÇÇ f g) : Rel (Œ∑ ‚â´ ùüô g) Œ∑\n  | assoc {a b} {f g h i : Hom a b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) (Œπ : Hom‚ÇÇ h i) :\n      Rel ((Œ∑ ‚â´ Œ∏) ‚â´ Œπ) (Œ∑ ‚â´ Œ∏ ‚â´ Œπ)\n  | whisker_left {a b c} (f : Hom a b) (g h : Hom b c) (Œ∑ Œ∑' : Hom‚ÇÇ g h) :\n      Rel Œ∑ Œ∑' ‚Üí Rel (f ‚óÅ Œ∑) (f ‚óÅ Œ∑')\n  | whisker_left_id {a b c} (f : Hom a b) (g : Hom b c) : Rel (f ‚óÅ ùüô g) (ùüô (f.comp g))\n  | whisker_left_comp {a b c} (f : Hom a b) {g h i : Hom b c} (Œ∑ : Hom‚ÇÇ g h) (Œ∏ : Hom‚ÇÇ h i) :\n      Rel (f ‚óÅ Œ∑ ‚â´ Œ∏) ((f ‚óÅ Œ∑) ‚â´ f ‚óÅ Œ∏)\n  | id_whisker_left {a b} {f g : Hom a b} (Œ∑ : Hom‚ÇÇ f g) : Rel (Hom.id a ‚óÅ Œ∑) (Œª_ f ‚â´ Œ∑ ‚â´ Œª‚Åª¬π_ g)\n  | comp_whisker_left {a b c d} (f : Hom a b) (g : Hom b c) {h h' : Hom c d} (Œ∑ : Hom‚ÇÇ h h') :\n     Rel (f.comp g ‚óÅ Œ∑) (Œ±_ f g h ‚â´ (f ‚óÅ g ‚óÅ Œ∑) ‚â´ Œ±‚Åª¬π_ f g h')\n  | whisker_right {a b c} (f g : Hom a b) (h : Hom b c) (Œ∑ Œ∑' : Hom‚ÇÇ f g) :\n      Rel Œ∑ Œ∑' ‚Üí Rel (Œ∑ ‚ñ∑ h) (Œ∑' ‚ñ∑ h)\n  | id_whisker_right {a b c} (f : Hom a b) (g : Hom b c) : Rel (ùüô f ‚ñ∑ g) (ùüô (f.comp g))\n  | comp_whisker_right {a b c} {f g h : Hom a b} (i : Hom b c) (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) :\n      Rel ((Œ∑ ‚â´ Œ∏) ‚ñ∑ i) ((Œ∑ ‚ñ∑ i) ‚â´ Œ∏ ‚ñ∑ i)\n  | whisker_right_id {a b} {f g : Hom a b} (Œ∑ : Hom‚ÇÇ f g) : Rel (Œ∑ ‚ñ∑ Hom.id b) (œÅ_ f ‚â´ Œ∑ ‚â´ œÅ‚Åª¬π_ g)\n  | whisker_right_comp {a b c d} {f f' : Hom a b} (g : Hom b c) (h : Hom c d) (Œ∑ : Hom‚ÇÇ f f') :\n      Rel (Œ∑ ‚ñ∑ g.comp h) (Œ±‚Åª¬π_ f g h ‚â´ ((Œ∑ ‚ñ∑ g) ‚ñ∑ h) ‚â´ Œ±_ f' g h)\n  | whisker_assoc {a b c d} (f : Hom a b) {g g' : Hom b c} (Œ∑ : Hom‚ÇÇ g g') (h : Hom c d) :\n      Rel ((f ‚óÅ Œ∑) ‚ñ∑ h) (Œ±_ f g h ‚â´ (f ‚óÅ Œ∑ ‚ñ∑ h) ‚â´ Œ±‚Åª¬π_ f g' h)\n  | whisker_exchange {a b c} {f g : Hom a b} {h i : Hom b c} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ h i) :\n      Rel ((f ‚óÅ Œ∏) ‚â´ Œ∑ ‚ñ∑ i) ((Œ∑ ‚ñ∑ h) ‚â´ g ‚óÅ Œ∏)\n  | associator_hom_inv {a b c d} (f : Hom a b) (g : Hom b c) (h : Hom c d) :\n      Rel (Œ±_ f g h ‚â´ Œ±‚Åª¬π_ f g h) (ùüô ((f.comp g).comp h))\n  | associator_inv_hom {a b c d} (f : Hom a b) (g : Hom b c) (h : Hom c d) :\n      Rel (Œ±‚Åª¬π_ f g h ‚â´ Œ±_ f g h) (ùüô (f.comp (g.comp h)))\n  | left_unitor_hom_inv {a b} (f : Hom a b) : Rel (Œª_ f ‚â´ Œª‚Åª¬π_ f) (ùüô ((Hom.id a).comp f))\n  | left_unitor_inv_hom {a b} (f : Hom a b) : Rel (Œª‚Åª¬π_ f ‚â´ Œª_ f) (ùüô f)\n  | right_unitor_hom_inv {a b} (f : Hom a b) : Rel (œÅ_ f ‚â´ œÅ‚Åª¬π_ f) (ùüô (f.comp (Hom.id b)))\n  | right_unitor_inv_hom {a b} (f : Hom a b) : Rel (œÅ‚Åª¬π_ f ‚â´ œÅ_ f) (ùüô f)\n  | pentagon {a b c d e} (f : Hom a b) (g : Hom b c) (h : Hom c d) (i : Hom d e) :\n      Rel ((Œ±_ f g h ‚ñ∑ i) ‚â´ Œ±_ f (g.comp h) i ‚â´ f ‚óÅ Œ±_ g h i)\n        (Œ±_ (f.comp g) h i ‚â´ Œ±_ f g (h.comp i))\n  | triangle {a b c} (f : Hom a b) (g : Hom b c) : Rel (Œ±_ f (Hom.id b) g ‚â´ f ‚óÅ Œª_ g) (œÅ_ f ‚ñ∑ g)\n\n"}
{"name":"CategoryTheory.FreeBicategory.mk_vcomp","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na b : CategoryTheory.FreeBicategory B\nf g h : Quiver.Hom a b\nŒ∑ : CategoryTheory.FreeBicategory.Hom‚ÇÇ f g\nŒ∏ : CategoryTheory.FreeBicategory.Hom‚ÇÇ g h\n‚ä¢ Eq (Œ∑.vcomp Œ∏).mk (CategoryTheory.CategoryStruct.comp Œ∑.mk Œ∏.mk)","decl":"@[simp]\ntheorem mk_vcomp {f g h : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) (Œ∏ : Hom‚ÇÇ g h) :\n    (Œ∑.vcomp Œ∏).mk = (Œ∑.mk ‚â´ Œ∏.mk : f ‚ü∂ h) :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.mk_whisker_left","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na b c : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\ng h : Quiver.Hom b c\nŒ∑ : CategoryTheory.FreeBicategory.Hom‚ÇÇ g h\n‚ä¢ Eq (CategoryTheory.FreeBicategory.Hom‚ÇÇ.whisker_left f Œ∑).mk (CategoryTheory.Bicategory.whiskerLeft f Œ∑.mk)","decl":"@[simp]\ntheorem mk_whisker_left (f : a ‚ü∂ b) {g h : b ‚ü∂ c} (Œ∑ : Hom‚ÇÇ g h) :\n    (Hom‚ÇÇ.whisker_left f Œ∑).mk = (f ‚óÅ Œ∑.mk : f ‚â´ g ‚ü∂ f ‚â´ h) :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.mk_whisker_right","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na b c : CategoryTheory.FreeBicategory B\nf g : Quiver.Hom a b\nŒ∑ : CategoryTheory.FreeBicategory.Hom‚ÇÇ f g\nh : Quiver.Hom b c\n‚ä¢ Eq (CategoryTheory.FreeBicategory.Hom‚ÇÇ.whisker_right h Œ∑).mk (CategoryTheory.Bicategory.whiskerRight Œ∑.mk h)","decl":"@[simp]\ntheorem mk_whisker_right {f g : a ‚ü∂ b} (Œ∑ : Hom‚ÇÇ f g) (h : b ‚ü∂ c) :\n    (Hom‚ÇÇ.whisker_right h Œ∑).mk = (Œ∑.mk ‚ñ∑ h : f ‚â´ h ‚ü∂ g ‚â´ h) :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.comp_def","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na b c : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\n‚ä¢ Eq (CategoryTheory.FreeBicategory.Hom.comp f g) (CategoryTheory.CategoryStruct.comp f g)","decl":"theorem comp_def : Hom.comp f g = f ‚â´ g :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.mk_id","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na b : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\n‚ä¢ Eq (Quot.mk CategoryTheory.FreeBicategory.Rel (CategoryTheory.FreeBicategory.Hom‚ÇÇ.id f)) (CategoryTheory.CategoryStruct.id f)","decl":"@[simp]\ntheorem mk_id : Quot.mk _ (Hom‚ÇÇ.id f) = ùüô f :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.mk_associator_hom","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na b c d : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n‚ä¢ Eq (Quot.mk CategoryTheory.FreeBicategory.Rel (CategoryTheory.FreeBicategory.Hom‚ÇÇ.associator f g h)) (CategoryTheory.Bicategory.associator f g h).hom","decl":"@[simp]\ntheorem mk_associator_hom : Quot.mk _ (Hom‚ÇÇ.associator f g h) = (Œ±_ f g h).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.mk_associator_inv","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na b c d : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n‚ä¢ Eq (Quot.mk CategoryTheory.FreeBicategory.Rel (CategoryTheory.FreeBicategory.Hom‚ÇÇ.associator_inv f g h)) (CategoryTheory.Bicategory.associator f g h).inv","decl":"@[simp]\ntheorem mk_associator_inv : Quot.mk _ (Hom‚ÇÇ.associator_inv f g h) = (Œ±_ f g h).inv :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.mk_left_unitor_hom","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na b : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\n‚ä¢ Eq (Quot.mk CategoryTheory.FreeBicategory.Rel (CategoryTheory.FreeBicategory.Hom‚ÇÇ.left_unitor f)) (CategoryTheory.Bicategory.leftUnitor f).hom","decl":"@[simp]\ntheorem mk_left_unitor_hom : Quot.mk _ (Hom‚ÇÇ.left_unitor f) = (Œª_ f).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.mk_left_unitor_inv","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na b : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\n‚ä¢ Eq (Quot.mk CategoryTheory.FreeBicategory.Rel (CategoryTheory.FreeBicategory.Hom‚ÇÇ.left_unitor_inv f)) (CategoryTheory.Bicategory.leftUnitor f).inv","decl":"@[simp]\ntheorem mk_left_unitor_inv : Quot.mk _ (Hom‚ÇÇ.left_unitor_inv f) = (Œª_ f).inv :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.mk_right_unitor_hom","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na b : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\n‚ä¢ Eq (Quot.mk CategoryTheory.FreeBicategory.Rel (CategoryTheory.FreeBicategory.Hom‚ÇÇ.right_unitor f)) (CategoryTheory.Bicategory.rightUnitor f).hom","decl":"@[simp]\ntheorem mk_right_unitor_hom : Quot.mk _ (Hom‚ÇÇ.right_unitor f) = (œÅ_ f).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.mk_right_unitor_inv","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na b : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\n‚ä¢ Eq (Quot.mk CategoryTheory.FreeBicategory.Rel (CategoryTheory.FreeBicategory.Hom‚ÇÇ.right_unitor_inv f)) (CategoryTheory.Bicategory.rightUnitor f).inv","decl":"@[simp]\ntheorem mk_right_unitor_inv : Quot.mk _ (Hom‚ÇÇ.right_unitor_inv f) = (œÅ_ f).inv :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.of_obj","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\na : B\n‚ä¢ Eq (CategoryTheory.FreeBicategory.of.obj a) (id a)","decl":"/-- Canonical prefunctor from `B` to `free_bicategory B`. -/\n@[simps]\ndef of : Prefunctor B (FreeBicategory B) where\n  obj := id\n  map := @fun _ _ => Hom.of\n\n"}
{"name":"CategoryTheory.FreeBicategory.of_map","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst‚úù : Quiver B\nx‚úù¬π x‚úù : B\nf : Quiver.Hom x‚úù¬π x‚úù\n‚ä¢ Eq (CategoryTheory.FreeBicategory.of.map f) (CategoryTheory.FreeBicategory.Hom.of f)","decl":"/-- Canonical prefunctor from `B` to `free_bicategory B`. -/\n@[simps]\ndef of : Prefunctor B (FreeBicategory B) where\n  obj := id\n  map := @fun _ _ => Hom.of\n\n"}
{"name":"CategoryTheory.FreeBicategory.liftHom_id","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : Quiver B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.CategoryStruct.{v‚ÇÇ, u‚ÇÇ} C\nF : Prefunctor B C\na : CategoryTheory.FreeBicategory B\n‚ä¢ Eq (CategoryTheory.FreeBicategory.liftHom F (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (F.obj a))","decl":"@[simp]\ntheorem liftHom_id (a : FreeBicategory B) : liftHom F (ùüô a) = ùüô (F.obj a) :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.liftHom_comp","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : Quiver B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.CategoryStruct.{v‚ÇÇ, u‚ÇÇ} C\nF : Prefunctor B C\na b c : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\n‚ä¢ Eq (CategoryTheory.FreeBicategory.liftHom F (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.FreeBicategory.liftHom F f) (CategoryTheory.FreeBicategory.liftHom F g))","decl":"@[simp]\ntheorem liftHom_comp {a b c : FreeBicategory B} (f : a ‚ü∂ b) (g : b ‚ü∂ c) :\n    liftHom F (f ‚â´ g) = liftHom F f ‚â´ liftHom F g :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.liftHom‚ÇÇ_congr","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : Quiver B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : Prefunctor B C\na b : CategoryTheory.FreeBicategory B\nf g : Quiver.Hom a b\nŒ∑ Œ∏ : CategoryTheory.FreeBicategory.Hom‚ÇÇ f g\nH : CategoryTheory.FreeBicategory.Rel Œ∑ Œ∏\n‚ä¢ Eq (CategoryTheory.FreeBicategory.liftHom‚ÇÇ F Œ∑) (CategoryTheory.FreeBicategory.liftHom‚ÇÇ F Œ∏)","decl":"theorem liftHom‚ÇÇ_congr {a b : FreeBicategory B} {f g : a ‚ü∂ b} {Œ∑ Œ∏ : Hom‚ÇÇ f g} (H : Rel Œ∑ Œ∏) :\n    liftHom‚ÇÇ F Œ∑ = liftHom‚ÇÇ F Œ∏ := by induction H <;> (dsimp [liftHom‚ÇÇ]; aesop_cat)\n\n"}
{"name":"CategoryTheory.FreeBicategory.lift_mapComp","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : Quiver B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : Prefunctor B C\na‚úù b‚úù c‚úù : CategoryTheory.FreeBicategory B\nx‚úù¬π : Quiver.Hom a‚úù b‚úù\nx‚úù : Quiver.Hom b‚úù c‚úù\n‚ä¢ Eq ((CategoryTheory.FreeBicategory.lift F).mapComp x‚úù¬π x‚úù) (CategoryTheory.Iso.refl ({ obj := F.obj, map := fun {X Y} => CategoryTheory.FreeBicategory.liftHom F, map‚ÇÇ := fun {a b} {f g} => Quot.lift (CategoryTheory.FreeBicategory.liftHom‚ÇÇ F) ‚ãØ, map‚ÇÇ_id := ‚ãØ, map‚ÇÇ_comp := ‚ãØ }.map (CategoryTheory.CategoryStruct.comp x‚úù¬π x‚úù)))","decl":"/-- A prefunctor from a quiver `B` to a bicategory `C` can be lifted to a pseudofunctor from\n`free_bicategory B` to `C`.\n-/\n@[simps]\ndef lift : Pseudofunctor (FreeBicategory B) C where\n  obj := F.obj\n  map := liftHom F\n  mapId _ := Iso.refl _\n  mapComp _ _ := Iso.refl _\n  map‚ÇÇ := Quot.lift (liftHom‚ÇÇ F) fun _ _ H => liftHom‚ÇÇ_congr F H\n  -- Porting note: We'd really prefer not to be doing this by hand.\n  -- in mathlib3 `tidy` did these inductions for us.\n  map‚ÇÇ_comp := by\n    intros a b f g h Œ∑ Œ∏\n    induction Œ∑ using Quot.rec\n    ¬∑ induction Œ∏ using Quot.rec <;> rfl\n    ¬∑ rfl\n  -- Porting note: still borked from here. The infoview doesn't update properly for me.\n  map‚ÇÇ_whisker_left := by\n    intro a b c f g h Œ∑\n    induction Œ∑ using Quot.rec\n    ¬∑ aesop_cat\n    ¬∑ rfl\n  map‚ÇÇ_whisker_right := by intro _ _ _ _ _ Œ∑ h; dsimp; induction Œ∑ using Quot.rec <;> aesop_cat\n\n"}
{"name":"CategoryTheory.FreeBicategory.lift_mapId","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : Quiver B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : Prefunctor B C\nx‚úù : CategoryTheory.FreeBicategory B\n‚ä¢ Eq ((CategoryTheory.FreeBicategory.lift F).mapId x‚úù) (CategoryTheory.Iso.refl ({ obj := F.obj, map := fun {X Y} => CategoryTheory.FreeBicategory.liftHom F, map‚ÇÇ := fun {a b} {f g} => Quot.lift (CategoryTheory.FreeBicategory.liftHom‚ÇÇ F) ‚ãØ, map‚ÇÇ_id := ‚ãØ, map‚ÇÇ_comp := ‚ãØ }.map (CategoryTheory.CategoryStruct.id x‚úù)))","decl":"/-- A prefunctor from a quiver `B` to a bicategory `C` can be lifted to a pseudofunctor from\n`free_bicategory B` to `C`.\n-/\n@[simps]\ndef lift : Pseudofunctor (FreeBicategory B) C where\n  obj := F.obj\n  map := liftHom F\n  mapId _ := Iso.refl _\n  mapComp _ _ := Iso.refl _\n  map‚ÇÇ := Quot.lift (liftHom‚ÇÇ F) fun _ _ H => liftHom‚ÇÇ_congr F H\n  -- Porting note: We'd really prefer not to be doing this by hand.\n  -- in mathlib3 `tidy` did these inductions for us.\n  map‚ÇÇ_comp := by\n    intros a b f g h Œ∑ Œ∏\n    induction Œ∑ using Quot.rec\n    ¬∑ induction Œ∏ using Quot.rec <;> rfl\n    ¬∑ rfl\n  -- Porting note: still borked from here. The infoview doesn't update properly for me.\n  map‚ÇÇ_whisker_left := by\n    intro a b c f g h Œ∑\n    induction Œ∑ using Quot.rec\n    ¬∑ aesop_cat\n    ¬∑ rfl\n  map‚ÇÇ_whisker_right := by intro _ _ _ _ _ Œ∑ h; dsimp; induction Œ∑ using Quot.rec <;> aesop_cat\n\n"}
{"name":"CategoryTheory.FreeBicategory.lift_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_map","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : Quiver B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : Prefunctor B C\nX‚úù Y‚úù : CategoryTheory.FreeBicategory B\na‚úù : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.FreeBicategory.lift F).map a‚úù) (CategoryTheory.FreeBicategory.liftHom F a‚úù)","decl":"/-- A prefunctor from a quiver `B` to a bicategory `C` can be lifted to a pseudofunctor from\n`free_bicategory B` to `C`.\n-/\n@[simps]\ndef lift : Pseudofunctor (FreeBicategory B) C where\n  obj := F.obj\n  map := liftHom F\n  mapId _ := Iso.refl _\n  mapComp _ _ := Iso.refl _\n  map‚ÇÇ := Quot.lift (liftHom‚ÇÇ F) fun _ _ H => liftHom‚ÇÇ_congr F H\n  -- Porting note: We'd really prefer not to be doing this by hand.\n  -- in mathlib3 `tidy` did these inductions for us.\n  map‚ÇÇ_comp := by\n    intros a b f g h Œ∑ Œ∏\n    induction Œ∑ using Quot.rec\n    ¬∑ induction Œ∏ using Quot.rec <;> rfl\n    ¬∑ rfl\n  -- Porting note: still borked from here. The infoview doesn't update properly for me.\n  map‚ÇÇ_whisker_left := by\n    intro a b c f g h Œ∑\n    induction Œ∑ using Quot.rec\n    ¬∑ aesop_cat\n    ¬∑ rfl\n  map‚ÇÇ_whisker_right := by intro _ _ _ _ _ Œ∑ h; dsimp; induction Œ∑ using Quot.rec <;> aesop_cat\n\n"}
{"name":"CategoryTheory.FreeBicategory.lift_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_obj","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : Quiver B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : Prefunctor B C\na‚úù : B\n‚ä¢ Eq ((CategoryTheory.FreeBicategory.lift F).obj a‚úù) (F.obj a‚úù)","decl":"/-- A prefunctor from a quiver `B` to a bicategory `C` can be lifted to a pseudofunctor from\n`free_bicategory B` to `C`.\n-/\n@[simps]\ndef lift : Pseudofunctor (FreeBicategory B) C where\n  obj := F.obj\n  map := liftHom F\n  mapId _ := Iso.refl _\n  mapComp _ _ := Iso.refl _\n  map‚ÇÇ := Quot.lift (liftHom‚ÇÇ F) fun _ _ H => liftHom‚ÇÇ_congr F H\n  -- Porting note: We'd really prefer not to be doing this by hand.\n  -- in mathlib3 `tidy` did these inductions for us.\n  map‚ÇÇ_comp := by\n    intros a b f g h Œ∑ Œ∏\n    induction Œ∑ using Quot.rec\n    ¬∑ induction Œ∏ using Quot.rec <;> rfl\n    ¬∑ rfl\n  -- Porting note: still borked from here. The infoview doesn't update properly for me.\n  map‚ÇÇ_whisker_left := by\n    intro a b c f g h Œ∑\n    induction Œ∑ using Quot.rec\n    ¬∑ aesop_cat\n    ¬∑ rfl\n  map‚ÇÇ_whisker_right := by intro _ _ _ _ _ Œ∑ h; dsimp; induction Œ∑ using Quot.rec <;> aesop_cat\n\n"}
{"name":"CategoryTheory.FreeBicategory.lift_toPrelaxFunctor_toPrelaxFunctorStruct_map‚ÇÇ","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u‚ÇÅ\ninst‚úù¬π : Quiver B\nC : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Bicategory C\nF : Prefunctor B C\na‚úù b‚úù : CategoryTheory.FreeBicategory B\nf‚úù g‚úù : Quiver.Hom a‚úù b‚úù\na : Quot CategoryTheory.FreeBicategory.Rel\n‚ä¢ Eq ((CategoryTheory.FreeBicategory.lift F).map‚ÇÇ a) (Quot.lift (CategoryTheory.FreeBicategory.liftHom‚ÇÇ F) ‚ãØ a)","decl":"/-- A prefunctor from a quiver `B` to a bicategory `C` can be lifted to a pseudofunctor from\n`free_bicategory B` to `C`.\n-/\n@[simps]\ndef lift : Pseudofunctor (FreeBicategory B) C where\n  obj := F.obj\n  map := liftHom F\n  mapId _ := Iso.refl _\n  mapComp _ _ := Iso.refl _\n  map‚ÇÇ := Quot.lift (liftHom‚ÇÇ F) fun _ _ H => liftHom‚ÇÇ_congr F H\n  -- Porting note: We'd really prefer not to be doing this by hand.\n  -- in mathlib3 `tidy` did these inductions for us.\n  map‚ÇÇ_comp := by\n    intros a b f g h Œ∑ Œ∏\n    induction Œ∑ using Quot.rec\n    ¬∑ induction Œ∏ using Quot.rec <;> rfl\n    ¬∑ rfl\n  -- Porting note: still borked from here. The infoview doesn't update properly for me.\n  map‚ÇÇ_whisker_left := by\n    intro a b c f g h Œ∑\n    induction Œ∑ using Quot.rec\n    ¬∑ aesop_cat\n    ¬∑ rfl\n  map‚ÇÇ_whisker_right := by intro _ _ _ _ _ Œ∑ h; dsimp; induction Œ∑ using Quot.rec <;> aesop_cat\n\n"}
