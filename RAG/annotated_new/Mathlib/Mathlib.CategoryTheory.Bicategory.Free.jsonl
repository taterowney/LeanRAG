{"name":"CategoryTheory.FreeBicategory.Hom.comp.injEq","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na b✝ c : B\nf✝ : CategoryTheory.FreeBicategory.Hom a b✝\ng✝ : CategoryTheory.FreeBicategory.Hom b✝ c\nb : B\nf : CategoryTheory.FreeBicategory.Hom a b\ng : CategoryTheory.FreeBicategory.Hom b c\n⊢ Eq (Eq (f✝.comp g✝) (f.comp g)) (And (Eq b✝ b) (And (HEq f✝ f) (HEq g✝ g)))","decl":"/-- 1-morphisms in the free bicategory. -/\ninductive Hom : B → B → Type max u v\n  | of {a b : B} (f : a ⟶ b) : Hom a b\n  | id (a : B) : Hom a a\n  | comp {a b c : B} (f : Hom a b) (g : Hom b c) : Hom a c\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom.of.inj","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na b : B\nf✝ f : Quiver.Hom a b\nx✝ : Eq (CategoryTheory.FreeBicategory.Hom.of f✝) (CategoryTheory.FreeBicategory.Hom.of f)\n⊢ Eq f✝ f","decl":"/-- 1-morphisms in the free bicategory. -/\ninductive Hom : B → B → Type max u v\n  | of {a b : B} (f : a ⟶ b) : Hom a b\n  | id (a : B) : Hom a a\n  | comp {a b c : B} (f : Hom a b) (g : Hom b c) : Hom a c\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom.comp.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝¹ : Quiver B\ninst✝ : SizeOf B\na b c : B\nf : CategoryTheory.FreeBicategory.Hom a b\ng : CategoryTheory.FreeBicategory.Hom b c\n⊢ Eq (SizeOf.sizeOf (f.comp g)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf c)) (SizeOf.sizeOf f)) (SizeOf.sizeOf g))","decl":"/-- 1-morphisms in the free bicategory. -/\ninductive Hom : B → B → Type max u v\n  | of {a b : B} (f : a ⟶ b) : Hom a b\n  | id (a : B) : Hom a a\n  | comp {a b c : B} (f : Hom a b) (g : Hom b c) : Hom a c\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom.of.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝¹ : Quiver B\ninst✝ : SizeOf B\na b : B\nf : Quiver.Hom a b\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom.of f)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf f))","decl":"/-- 1-morphisms in the free bicategory. -/\ninductive Hom : B → B → Type max u v\n  | of {a b : B} (f : a ⟶ b) : Hom a b\n  | id (a : B) : Hom a a\n  | comp {a b c : B} (f : Hom a b) (g : Hom b c) : Hom a c\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom.id.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝¹ : Quiver B\ninst✝ : SizeOf B\na : B\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom.id a)) (HAdd.hAdd 1 (SizeOf.sizeOf a))","decl":"/-- 1-morphisms in the free bicategory. -/\ninductive Hom : B → B → Type max u v\n  | of {a b : B} (f : a ⟶ b) : Hom a b\n  | id (a : B) : Hom a a\n  | comp {a b c : B} (f : Hom a b) (g : Hom b c) : Hom a c\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom.comp.inj","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na b✝ c : B\nf✝ : CategoryTheory.FreeBicategory.Hom a b✝\ng✝ : CategoryTheory.FreeBicategory.Hom b✝ c\nb : B\nf : CategoryTheory.FreeBicategory.Hom a b\ng : CategoryTheory.FreeBicategory.Hom b c\nx✝ : Eq (f✝.comp g✝) (f.comp g)\n⊢ And (Eq b✝ b) (And (HEq f✝ f) (HEq g✝ g))","decl":"/-- 1-morphisms in the free bicategory. -/\ninductive Hom : B → B → Type max u v\n  | of {a b : B} (f : a ⟶ b) : Hom a b\n  | id (a : B) : Hom a a\n  | comp {a b c : B} (f : Hom a b) (g : Hom b c) : Hom a c\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom.of.injEq","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na b : B\nf✝ f : Quiver.Hom a b\n⊢ Eq (Eq (CategoryTheory.FreeBicategory.Hom.of f✝) (CategoryTheory.FreeBicategory.Hom.of f)) (Eq f✝ f)","decl":"/-- 1-morphisms in the free bicategory. -/\ninductive Hom : B → B → Type max u v\n  | of {a b : B} (f : a ⟶ b) : Hom a b\n  | id (a : B) : Hom a a\n  | comp {a b c : B} (f : Hom a b) (g : Hom b c) : Hom a c\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom₂.whisker_right.inj","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na b c : CategoryTheory.FreeBicategory B\nf g : Quiver.Hom a b\nh : Quiver.Hom b c\nη✝ η : CategoryTheory.FreeBicategory.Hom₂ f g\nx✝ : Eq (CategoryTheory.FreeBicategory.Hom₂.whisker_right h η✝) (CategoryTheory.FreeBicategory.Hom₂.whisker_right h η)\n⊢ Eq η✝ η","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom₂ : ∀ {a b : FreeBicategory B}, (a ⟶ b) → (a ⟶ b) → Type max u v\n  | id {a b} (f : a ⟶ b) : Hom₂ f f\n  | vcomp {a b} {f g h : a ⟶ b} (η : Hom₂ f g) (θ : Hom₂ g h) : Hom₂ f h\n  | whisker_left {a b c} (f : a ⟶ b) {g h : b ⟶ c} (η : Hom₂ g h) :\n      Hom₂ (f ≫ g) (f ≫ h)-- `η` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ⟶ b} (h : b ⟶ c) (η : Hom₂ f g) : Hom₂ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ ((f ≫ g) ≫ h) (f ≫ (g ≫ h))\n  | associator_inv {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ (f ≫ (g ≫ h)) ((f ≫ g) ≫ h)\n  | right_unitor {a b} (f : a ⟶ b) : Hom₂ (f ≫ (𝟙 b)) f\n  | right_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f (f ≫ (𝟙 b))\n  | left_unitor {a b} (f : a ⟶ b) : Hom₂ ((𝟙 a) ≫ f) f\n  | left_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f ((𝟙 a) ≫ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom₂.right_unitor.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝¹ : Quiver B\ninst✝ : SizeOf B\na b : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom₂.right_unitor f)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf f))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom₂ : ∀ {a b : FreeBicategory B}, (a ⟶ b) → (a ⟶ b) → Type max u v\n  | id {a b} (f : a ⟶ b) : Hom₂ f f\n  | vcomp {a b} {f g h : a ⟶ b} (η : Hom₂ f g) (θ : Hom₂ g h) : Hom₂ f h\n  | whisker_left {a b c} (f : a ⟶ b) {g h : b ⟶ c} (η : Hom₂ g h) :\n      Hom₂ (f ≫ g) (f ≫ h)-- `η` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ⟶ b} (h : b ⟶ c) (η : Hom₂ f g) : Hom₂ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ ((f ≫ g) ≫ h) (f ≫ (g ≫ h))\n  | associator_inv {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ (f ≫ (g ≫ h)) ((f ≫ g) ≫ h)\n  | right_unitor {a b} (f : a ⟶ b) : Hom₂ (f ≫ (𝟙 b)) f\n  | right_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f (f ≫ (𝟙 b))\n  | left_unitor {a b} (f : a ⟶ b) : Hom₂ ((𝟙 a) ≫ f) f\n  | left_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f ((𝟙 a) ≫ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom₂.right_unitor_inv.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝¹ : Quiver B\ninst✝ : SizeOf B\na b : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom₂.right_unitor_inv f)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf f))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom₂ : ∀ {a b : FreeBicategory B}, (a ⟶ b) → (a ⟶ b) → Type max u v\n  | id {a b} (f : a ⟶ b) : Hom₂ f f\n  | vcomp {a b} {f g h : a ⟶ b} (η : Hom₂ f g) (θ : Hom₂ g h) : Hom₂ f h\n  | whisker_left {a b c} (f : a ⟶ b) {g h : b ⟶ c} (η : Hom₂ g h) :\n      Hom₂ (f ≫ g) (f ≫ h)-- `η` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ⟶ b} (h : b ⟶ c) (η : Hom₂ f g) : Hom₂ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ ((f ≫ g) ≫ h) (f ≫ (g ≫ h))\n  | associator_inv {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ (f ≫ (g ≫ h)) ((f ≫ g) ≫ h)\n  | right_unitor {a b} (f : a ⟶ b) : Hom₂ (f ≫ (𝟙 b)) f\n  | right_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f (f ≫ (𝟙 b))\n  | left_unitor {a b} (f : a ⟶ b) : Hom₂ ((𝟙 a) ≫ f) f\n  | left_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f ((𝟙 a) ≫ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom₂.left_unitor_inv.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝¹ : Quiver B\ninst✝ : SizeOf B\na b : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom₂.left_unitor_inv f)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf f))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom₂ : ∀ {a b : FreeBicategory B}, (a ⟶ b) → (a ⟶ b) → Type max u v\n  | id {a b} (f : a ⟶ b) : Hom₂ f f\n  | vcomp {a b} {f g h : a ⟶ b} (η : Hom₂ f g) (θ : Hom₂ g h) : Hom₂ f h\n  | whisker_left {a b c} (f : a ⟶ b) {g h : b ⟶ c} (η : Hom₂ g h) :\n      Hom₂ (f ≫ g) (f ≫ h)-- `η` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ⟶ b} (h : b ⟶ c) (η : Hom₂ f g) : Hom₂ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ ((f ≫ g) ≫ h) (f ≫ (g ≫ h))\n  | associator_inv {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ (f ≫ (g ≫ h)) ((f ≫ g) ≫ h)\n  | right_unitor {a b} (f : a ⟶ b) : Hom₂ (f ≫ (𝟙 b)) f\n  | right_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f (f ≫ (𝟙 b))\n  | left_unitor {a b} (f : a ⟶ b) : Hom₂ ((𝟙 a) ≫ f) f\n  | left_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f ((𝟙 a) ≫ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom₂.left_unitor.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝¹ : Quiver B\ninst✝ : SizeOf B\na b : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom₂.left_unitor f)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf f))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom₂ : ∀ {a b : FreeBicategory B}, (a ⟶ b) → (a ⟶ b) → Type max u v\n  | id {a b} (f : a ⟶ b) : Hom₂ f f\n  | vcomp {a b} {f g h : a ⟶ b} (η : Hom₂ f g) (θ : Hom₂ g h) : Hom₂ f h\n  | whisker_left {a b c} (f : a ⟶ b) {g h : b ⟶ c} (η : Hom₂ g h) :\n      Hom₂ (f ≫ g) (f ≫ h)-- `η` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ⟶ b} (h : b ⟶ c) (η : Hom₂ f g) : Hom₂ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ ((f ≫ g) ≫ h) (f ≫ (g ≫ h))\n  | associator_inv {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ (f ≫ (g ≫ h)) ((f ≫ g) ≫ h)\n  | right_unitor {a b} (f : a ⟶ b) : Hom₂ (f ≫ (𝟙 b)) f\n  | right_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f (f ≫ (𝟙 b))\n  | left_unitor {a b} (f : a ⟶ b) : Hom₂ ((𝟙 a) ≫ f) f\n  | left_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f ((𝟙 a) ≫ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom₂.associator_inv.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝¹ : Quiver B\ninst✝ : SizeOf B\na b c d : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom₂.associator_inv f g h)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf c)) (SizeOf.sizeOf d)) (SizeOf.sizeOf f)) (SizeOf.sizeOf g)) (SizeOf.sizeOf h))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom₂ : ∀ {a b : FreeBicategory B}, (a ⟶ b) → (a ⟶ b) → Type max u v\n  | id {a b} (f : a ⟶ b) : Hom₂ f f\n  | vcomp {a b} {f g h : a ⟶ b} (η : Hom₂ f g) (θ : Hom₂ g h) : Hom₂ f h\n  | whisker_left {a b c} (f : a ⟶ b) {g h : b ⟶ c} (η : Hom₂ g h) :\n      Hom₂ (f ≫ g) (f ≫ h)-- `η` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ⟶ b} (h : b ⟶ c) (η : Hom₂ f g) : Hom₂ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ ((f ≫ g) ≫ h) (f ≫ (g ≫ h))\n  | associator_inv {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ (f ≫ (g ≫ h)) ((f ≫ g) ≫ h)\n  | right_unitor {a b} (f : a ⟶ b) : Hom₂ (f ≫ (𝟙 b)) f\n  | right_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f (f ≫ (𝟙 b))\n  | left_unitor {a b} (f : a ⟶ b) : Hom₂ ((𝟙 a) ≫ f) f\n  | left_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f ((𝟙 a) ≫ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom₂.whisker_left.inj","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na b c : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\ng h : Quiver.Hom b c\nη✝ η : CategoryTheory.FreeBicategory.Hom₂ g h\nx✝ : Eq (CategoryTheory.FreeBicategory.Hom₂.whisker_left f η✝) (CategoryTheory.FreeBicategory.Hom₂.whisker_left f η)\n⊢ Eq η✝ η","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom₂ : ∀ {a b : FreeBicategory B}, (a ⟶ b) → (a ⟶ b) → Type max u v\n  | id {a b} (f : a ⟶ b) : Hom₂ f f\n  | vcomp {a b} {f g h : a ⟶ b} (η : Hom₂ f g) (θ : Hom₂ g h) : Hom₂ f h\n  | whisker_left {a b c} (f : a ⟶ b) {g h : b ⟶ c} (η : Hom₂ g h) :\n      Hom₂ (f ≫ g) (f ≫ h)-- `η` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ⟶ b} (h : b ⟶ c) (η : Hom₂ f g) : Hom₂ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ ((f ≫ g) ≫ h) (f ≫ (g ≫ h))\n  | associator_inv {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ (f ≫ (g ≫ h)) ((f ≫ g) ≫ h)\n  | right_unitor {a b} (f : a ⟶ b) : Hom₂ (f ≫ (𝟙 b)) f\n  | right_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f (f ≫ (𝟙 b))\n  | left_unitor {a b} (f : a ⟶ b) : Hom₂ ((𝟙 a) ≫ f) f\n  | left_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f ((𝟙 a) ≫ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom₂.associator.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝¹ : Quiver B\ninst✝ : SizeOf B\na b c d : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom₂.associator f g h)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf c)) (SizeOf.sizeOf d)) (SizeOf.sizeOf f)) (SizeOf.sizeOf g)) (SizeOf.sizeOf h))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom₂ : ∀ {a b : FreeBicategory B}, (a ⟶ b) → (a ⟶ b) → Type max u v\n  | id {a b} (f : a ⟶ b) : Hom₂ f f\n  | vcomp {a b} {f g h : a ⟶ b} (η : Hom₂ f g) (θ : Hom₂ g h) : Hom₂ f h\n  | whisker_left {a b c} (f : a ⟶ b) {g h : b ⟶ c} (η : Hom₂ g h) :\n      Hom₂ (f ≫ g) (f ≫ h)-- `η` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ⟶ b} (h : b ⟶ c) (η : Hom₂ f g) : Hom₂ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ ((f ≫ g) ≫ h) (f ≫ (g ≫ h))\n  | associator_inv {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ (f ≫ (g ≫ h)) ((f ≫ g) ≫ h)\n  | right_unitor {a b} (f : a ⟶ b) : Hom₂ (f ≫ (𝟙 b)) f\n  | right_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f (f ≫ (𝟙 b))\n  | left_unitor {a b} (f : a ⟶ b) : Hom₂ ((𝟙 a) ≫ f) f\n  | left_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f ((𝟙 a) ≫ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom₂.whisker_left.injEq","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na b c : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\ng h : Quiver.Hom b c\nη✝ η : CategoryTheory.FreeBicategory.Hom₂ g h\n⊢ Eq (Eq (CategoryTheory.FreeBicategory.Hom₂.whisker_left f η✝) (CategoryTheory.FreeBicategory.Hom₂.whisker_left f η)) (Eq η✝ η)","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom₂ : ∀ {a b : FreeBicategory B}, (a ⟶ b) → (a ⟶ b) → Type max u v\n  | id {a b} (f : a ⟶ b) : Hom₂ f f\n  | vcomp {a b} {f g h : a ⟶ b} (η : Hom₂ f g) (θ : Hom₂ g h) : Hom₂ f h\n  | whisker_left {a b c} (f : a ⟶ b) {g h : b ⟶ c} (η : Hom₂ g h) :\n      Hom₂ (f ≫ g) (f ≫ h)-- `η` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ⟶ b} (h : b ⟶ c) (η : Hom₂ f g) : Hom₂ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ ((f ≫ g) ≫ h) (f ≫ (g ≫ h))\n  | associator_inv {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ (f ≫ (g ≫ h)) ((f ≫ g) ≫ h)\n  | right_unitor {a b} (f : a ⟶ b) : Hom₂ (f ≫ (𝟙 b)) f\n  | right_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f (f ≫ (𝟙 b))\n  | left_unitor {a b} (f : a ⟶ b) : Hom₂ ((𝟙 a) ≫ f) f\n  | left_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f ((𝟙 a) ≫ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom₂.id.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝¹ : Quiver B\ninst✝ : SizeOf B\na b : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom₂.id f)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf f))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom₂ : ∀ {a b : FreeBicategory B}, (a ⟶ b) → (a ⟶ b) → Type max u v\n  | id {a b} (f : a ⟶ b) : Hom₂ f f\n  | vcomp {a b} {f g h : a ⟶ b} (η : Hom₂ f g) (θ : Hom₂ g h) : Hom₂ f h\n  | whisker_left {a b c} (f : a ⟶ b) {g h : b ⟶ c} (η : Hom₂ g h) :\n      Hom₂ (f ≫ g) (f ≫ h)-- `η` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ⟶ b} (h : b ⟶ c) (η : Hom₂ f g) : Hom₂ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ ((f ≫ g) ≫ h) (f ≫ (g ≫ h))\n  | associator_inv {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ (f ≫ (g ≫ h)) ((f ≫ g) ≫ h)\n  | right_unitor {a b} (f : a ⟶ b) : Hom₂ (f ≫ (𝟙 b)) f\n  | right_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f (f ≫ (𝟙 b))\n  | left_unitor {a b} (f : a ⟶ b) : Hom₂ ((𝟙 a) ≫ f) f\n  | left_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f ((𝟙 a) ≫ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom₂.vcomp.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝¹ : Quiver B\ninst✝ : SizeOf B\na b : CategoryTheory.FreeBicategory B\nf g h : Quiver.Hom a b\nη : CategoryTheory.FreeBicategory.Hom₂ f g\nθ : CategoryTheory.FreeBicategory.Hom₂ g h\n⊢ Eq (SizeOf.sizeOf (η.vcomp θ)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf f)) (SizeOf.sizeOf g)) (SizeOf.sizeOf h)) (SizeOf.sizeOf η)) (SizeOf.sizeOf θ))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom₂ : ∀ {a b : FreeBicategory B}, (a ⟶ b) → (a ⟶ b) → Type max u v\n  | id {a b} (f : a ⟶ b) : Hom₂ f f\n  | vcomp {a b} {f g h : a ⟶ b} (η : Hom₂ f g) (θ : Hom₂ g h) : Hom₂ f h\n  | whisker_left {a b c} (f : a ⟶ b) {g h : b ⟶ c} (η : Hom₂ g h) :\n      Hom₂ (f ≫ g) (f ≫ h)-- `η` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ⟶ b} (h : b ⟶ c) (η : Hom₂ f g) : Hom₂ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ ((f ≫ g) ≫ h) (f ≫ (g ≫ h))\n  | associator_inv {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ (f ≫ (g ≫ h)) ((f ≫ g) ≫ h)\n  | right_unitor {a b} (f : a ⟶ b) : Hom₂ (f ≫ (𝟙 b)) f\n  | right_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f (f ≫ (𝟙 b))\n  | left_unitor {a b} (f : a ⟶ b) : Hom₂ ((𝟙 a) ≫ f) f\n  | left_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f ((𝟙 a) ≫ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom₂.vcomp.injEq","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na b : CategoryTheory.FreeBicategory B\nf g✝ h : Quiver.Hom a b\nη✝ : CategoryTheory.FreeBicategory.Hom₂ f g✝\nθ✝ : CategoryTheory.FreeBicategory.Hom₂ g✝ h\ng : Quiver.Hom a b\nη : CategoryTheory.FreeBicategory.Hom₂ f g\nθ : CategoryTheory.FreeBicategory.Hom₂ g h\n⊢ Eq (Eq (η✝.vcomp θ✝) (η.vcomp θ)) (And (Eq g✝ g) (And (HEq η✝ η) (HEq θ✝ θ)))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom₂ : ∀ {a b : FreeBicategory B}, (a ⟶ b) → (a ⟶ b) → Type max u v\n  | id {a b} (f : a ⟶ b) : Hom₂ f f\n  | vcomp {a b} {f g h : a ⟶ b} (η : Hom₂ f g) (θ : Hom₂ g h) : Hom₂ f h\n  | whisker_left {a b c} (f : a ⟶ b) {g h : b ⟶ c} (η : Hom₂ g h) :\n      Hom₂ (f ≫ g) (f ≫ h)-- `η` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ⟶ b} (h : b ⟶ c) (η : Hom₂ f g) : Hom₂ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ ((f ≫ g) ≫ h) (f ≫ (g ≫ h))\n  | associator_inv {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ (f ≫ (g ≫ h)) ((f ≫ g) ≫ h)\n  | right_unitor {a b} (f : a ⟶ b) : Hom₂ (f ≫ (𝟙 b)) f\n  | right_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f (f ≫ (𝟙 b))\n  | left_unitor {a b} (f : a ⟶ b) : Hom₂ ((𝟙 a) ≫ f) f\n  | left_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f ((𝟙 a) ≫ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom₂.whisker_right.injEq","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na b c : CategoryTheory.FreeBicategory B\nf g : Quiver.Hom a b\nh : Quiver.Hom b c\nη✝ η : CategoryTheory.FreeBicategory.Hom₂ f g\n⊢ Eq (Eq (CategoryTheory.FreeBicategory.Hom₂.whisker_right h η✝) (CategoryTheory.FreeBicategory.Hom₂.whisker_right h η)) (Eq η✝ η)","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom₂ : ∀ {a b : FreeBicategory B}, (a ⟶ b) → (a ⟶ b) → Type max u v\n  | id {a b} (f : a ⟶ b) : Hom₂ f f\n  | vcomp {a b} {f g h : a ⟶ b} (η : Hom₂ f g) (θ : Hom₂ g h) : Hom₂ f h\n  | whisker_left {a b c} (f : a ⟶ b) {g h : b ⟶ c} (η : Hom₂ g h) :\n      Hom₂ (f ≫ g) (f ≫ h)-- `η` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ⟶ b} (h : b ⟶ c) (η : Hom₂ f g) : Hom₂ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ ((f ≫ g) ≫ h) (f ≫ (g ≫ h))\n  | associator_inv {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ (f ≫ (g ≫ h)) ((f ≫ g) ≫ h)\n  | right_unitor {a b} (f : a ⟶ b) : Hom₂ (f ≫ (𝟙 b)) f\n  | right_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f (f ≫ (𝟙 b))\n  | left_unitor {a b} (f : a ⟶ b) : Hom₂ ((𝟙 a) ≫ f) f\n  | left_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f ((𝟙 a) ≫ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom₂.whisker_right.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝¹ : Quiver B\ninst✝ : SizeOf B\na b c : CategoryTheory.FreeBicategory B\nf g : Quiver.Hom a b\nh : Quiver.Hom b c\nη : CategoryTheory.FreeBicategory.Hom₂ f g\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom₂.whisker_right h η)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf c)) (SizeOf.sizeOf f)) (SizeOf.sizeOf g)) (SizeOf.sizeOf h)) (SizeOf.sizeOf η))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom₂ : ∀ {a b : FreeBicategory B}, (a ⟶ b) → (a ⟶ b) → Type max u v\n  | id {a b} (f : a ⟶ b) : Hom₂ f f\n  | vcomp {a b} {f g h : a ⟶ b} (η : Hom₂ f g) (θ : Hom₂ g h) : Hom₂ f h\n  | whisker_left {a b c} (f : a ⟶ b) {g h : b ⟶ c} (η : Hom₂ g h) :\n      Hom₂ (f ≫ g) (f ≫ h)-- `η` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ⟶ b} (h : b ⟶ c) (η : Hom₂ f g) : Hom₂ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ ((f ≫ g) ≫ h) (f ≫ (g ≫ h))\n  | associator_inv {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ (f ≫ (g ≫ h)) ((f ≫ g) ≫ h)\n  | right_unitor {a b} (f : a ⟶ b) : Hom₂ (f ≫ (𝟙 b)) f\n  | right_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f (f ≫ (𝟙 b))\n  | left_unitor {a b} (f : a ⟶ b) : Hom₂ ((𝟙 a) ≫ f) f\n  | left_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f ((𝟙 a) ≫ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom₂.whisker_left.sizeOf_spec","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝¹ : Quiver B\ninst✝ : SizeOf B\na b c : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\ng h : Quiver.Hom b c\nη : CategoryTheory.FreeBicategory.Hom₂ g h\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.FreeBicategory.Hom₂.whisker_left f η)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a)) (SizeOf.sizeOf b)) (SizeOf.sizeOf c)) (SizeOf.sizeOf f)) (SizeOf.sizeOf g)) (SizeOf.sizeOf h)) (SizeOf.sizeOf η))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom₂ : ∀ {a b : FreeBicategory B}, (a ⟶ b) → (a ⟶ b) → Type max u v\n  | id {a b} (f : a ⟶ b) : Hom₂ f f\n  | vcomp {a b} {f g h : a ⟶ b} (η : Hom₂ f g) (θ : Hom₂ g h) : Hom₂ f h\n  | whisker_left {a b c} (f : a ⟶ b) {g h : b ⟶ c} (η : Hom₂ g h) :\n      Hom₂ (f ≫ g) (f ≫ h)-- `η` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ⟶ b} (h : b ⟶ c) (η : Hom₂ f g) : Hom₂ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ ((f ≫ g) ≫ h) (f ≫ (g ≫ h))\n  | associator_inv {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ (f ≫ (g ≫ h)) ((f ≫ g) ≫ h)\n  | right_unitor {a b} (f : a ⟶ b) : Hom₂ (f ≫ (𝟙 b)) f\n  | right_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f (f ≫ (𝟙 b))\n  | left_unitor {a b} (f : a ⟶ b) : Hom₂ ((𝟙 a) ≫ f) f\n  | left_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f ((𝟙 a) ≫ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Hom₂.vcomp.inj","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na b : CategoryTheory.FreeBicategory B\nf g✝ h : Quiver.Hom a b\nη✝ : CategoryTheory.FreeBicategory.Hom₂ f g✝\nθ✝ : CategoryTheory.FreeBicategory.Hom₂ g✝ h\ng : Quiver.Hom a b\nη : CategoryTheory.FreeBicategory.Hom₂ f g\nθ : CategoryTheory.FreeBicategory.Hom₂ g h\nx✝ : Eq (η✝.vcomp θ✝) (η.vcomp θ)\n⊢ And (Eq g✝ g) (And (HEq η✝ η) (HEq θ✝ θ))","decl":"/-- Representatives of 2-morphisms in the free bicategory. -/\ninductive Hom₂ : ∀ {a b : FreeBicategory B}, (a ⟶ b) → (a ⟶ b) → Type max u v\n  | id {a b} (f : a ⟶ b) : Hom₂ f f\n  | vcomp {a b} {f g h : a ⟶ b} (η : Hom₂ f g) (θ : Hom₂ g h) : Hom₂ f h\n  | whisker_left {a b c} (f : a ⟶ b) {g h : b ⟶ c} (η : Hom₂ g h) :\n      Hom₂ (f ≫ g) (f ≫ h)-- `η` cannot be earlier than `h` since it is a recursive argument.\n  | whisker_right {a b c} {f g : a ⟶ b} (h : b ⟶ c) (η : Hom₂ f g) : Hom₂ (f.comp h) (g.comp h)\n  | associator {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ ((f ≫ g) ≫ h) (f ≫ (g ≫ h))\n  | associator_inv {a b c d} (f : a ⟶ b) (g : b ⟶ c) (h : c ⟶ d) :\n      Hom₂ (f ≫ (g ≫ h)) ((f ≫ g) ≫ h)\n  | right_unitor {a b} (f : a ⟶ b) : Hom₂ (f ≫ (𝟙 b)) f\n  | right_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f (f ≫ (𝟙 b))\n  | left_unitor {a b} (f : a ⟶ b) : Hom₂ ((𝟙 a) ≫ f) f\n  | left_unitor_inv {a b} (f : a ⟶ b) : Hom₂ f ((𝟙 a) ≫ f)\n\n"}
{"name":"CategoryTheory.FreeBicategory.Rel.brecOn","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\nmotive✝ : {a b : CategoryTheory.FreeBicategory B} → {f g : Quiver.Hom a b} → (a_1 a_2 : CategoryTheory.FreeBicategory.Hom₂ f g) → CategoryTheory.FreeBicategory.Rel a_1 a_2 → Prop\na b : CategoryTheory.FreeBicategory B\nf g : Quiver.Hom a b\na✝¹ a✝ : CategoryTheory.FreeBicategory.Hom₂ f g\nx✝ : CategoryTheory.FreeBicategory.Rel a✝¹ a✝\nih✝ : ∀ {a b : CategoryTheory.FreeBicategory B} {f g : Quiver.Hom a b} (a_1 a_2 : CategoryTheory.FreeBicategory.Hom₂ f g) (x : CategoryTheory.FreeBicategory.Rel a_1 a_2), x.below → motive✝ a_1 a_2 x\n⊢ motive✝ a✝¹ a✝ x✝","decl":"/-- Relations between 2-morphisms in the free bicategory. -/\ninductive Rel : ∀ {a b : FreeBicategory B} {f g : a ⟶ b}, Hom₂ f g → Hom₂ f g → Prop\n  | vcomp_right {a b} {f g h : Hom a b} (η : Hom₂ f g) (θ₁ θ₂ : Hom₂ g h) :\n      Rel θ₁ θ₂ → Rel (η ≫ θ₁) (η ≫ θ₂)\n  | vcomp_left {a b} {f g h : Hom a b} (η₁ η₂ : Hom₂ f g) (θ : Hom₂ g h) :\n      Rel η₁ η₂ → Rel (η₁ ≫ θ) (η₂ ≫ θ)\n  | id_comp {a b} {f g : Hom a b} (η : Hom₂ f g) : Rel (𝟙 f ≫ η) η\n  | comp_id {a b} {f g : Hom a b} (η : Hom₂ f g) : Rel (η ≫ 𝟙 g) η\n  | assoc {a b} {f g h i : Hom a b} (η : Hom₂ f g) (θ : Hom₂ g h) (ι : Hom₂ h i) :\n      Rel ((η ≫ θ) ≫ ι) (η ≫ θ ≫ ι)\n  | whisker_left {a b c} (f : Hom a b) (g h : Hom b c) (η η' : Hom₂ g h) :\n      Rel η η' → Rel (f ◁ η) (f ◁ η')\n  | whisker_left_id {a b c} (f : Hom a b) (g : Hom b c) : Rel (f ◁ 𝟙 g) (𝟙 (f.comp g))\n  | whisker_left_comp {a b c} (f : Hom a b) {g h i : Hom b c} (η : Hom₂ g h) (θ : Hom₂ h i) :\n      Rel (f ◁ η ≫ θ) ((f ◁ η) ≫ f ◁ θ)\n  | id_whisker_left {a b} {f g : Hom a b} (η : Hom₂ f g) : Rel (Hom.id a ◁ η) (λ_ f ≫ η ≫ λ⁻¹_ g)\n  | comp_whisker_left {a b c d} (f : Hom a b) (g : Hom b c) {h h' : Hom c d} (η : Hom₂ h h') :\n     Rel (f.comp g ◁ η) (α_ f g h ≫ (f ◁ g ◁ η) ≫ α⁻¹_ f g h')\n  | whisker_right {a b c} (f g : Hom a b) (h : Hom b c) (η η' : Hom₂ f g) :\n      Rel η η' → Rel (η ▷ h) (η' ▷ h)\n  | id_whisker_right {a b c} (f : Hom a b) (g : Hom b c) : Rel (𝟙 f ▷ g) (𝟙 (f.comp g))\n  | comp_whisker_right {a b c} {f g h : Hom a b} (i : Hom b c) (η : Hom₂ f g) (θ : Hom₂ g h) :\n      Rel ((η ≫ θ) ▷ i) ((η ▷ i) ≫ θ ▷ i)\n  | whisker_right_id {a b} {f g : Hom a b} (η : Hom₂ f g) : Rel (η ▷ Hom.id b) (ρ_ f ≫ η ≫ ρ⁻¹_ g)\n  | whisker_right_comp {a b c d} {f f' : Hom a b} (g : Hom b c) (h : Hom c d) (η : Hom₂ f f') :\n      Rel (η ▷ g.comp h) (α⁻¹_ f g h ≫ ((η ▷ g) ▷ h) ≫ α_ f' g h)\n  | whisker_assoc {a b c d} (f : Hom a b) {g g' : Hom b c} (η : Hom₂ g g') (h : Hom c d) :\n      Rel ((f ◁ η) ▷ h) (α_ f g h ≫ (f ◁ η ▷ h) ≫ α⁻¹_ f g' h)\n  | whisker_exchange {a b c} {f g : Hom a b} {h i : Hom b c} (η : Hom₂ f g) (θ : Hom₂ h i) :\n      Rel ((f ◁ θ) ≫ η ▷ i) ((η ▷ h) ≫ g ◁ θ)\n  | associator_hom_inv {a b c d} (f : Hom a b) (g : Hom b c) (h : Hom c d) :\n      Rel (α_ f g h ≫ α⁻¹_ f g h) (𝟙 ((f.comp g).comp h))\n  | associator_inv_hom {a b c d} (f : Hom a b) (g : Hom b c) (h : Hom c d) :\n      Rel (α⁻¹_ f g h ≫ α_ f g h) (𝟙 (f.comp (g.comp h)))\n  | left_unitor_hom_inv {a b} (f : Hom a b) : Rel (λ_ f ≫ λ⁻¹_ f) (𝟙 ((Hom.id a).comp f))\n  | left_unitor_inv_hom {a b} (f : Hom a b) : Rel (λ⁻¹_ f ≫ λ_ f) (𝟙 f)\n  | right_unitor_hom_inv {a b} (f : Hom a b) : Rel (ρ_ f ≫ ρ⁻¹_ f) (𝟙 (f.comp (Hom.id b)))\n  | right_unitor_inv_hom {a b} (f : Hom a b) : Rel (ρ⁻¹_ f ≫ ρ_ f) (𝟙 f)\n  | pentagon {a b c d e} (f : Hom a b) (g : Hom b c) (h : Hom c d) (i : Hom d e) :\n      Rel ((α_ f g h ▷ i) ≫ α_ f (g.comp h) i ≫ f ◁ α_ g h i)\n        (α_ (f.comp g) h i ≫ α_ f g (h.comp i))\n  | triangle {a b c} (f : Hom a b) (g : Hom b c) : Rel (α_ f (Hom.id b) g ≫ f ◁ λ_ g) (ρ_ f ▷ g)\n\n"}
{"name":"CategoryTheory.FreeBicategory.mk_vcomp","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na b : CategoryTheory.FreeBicategory B\nf g h : Quiver.Hom a b\nη : CategoryTheory.FreeBicategory.Hom₂ f g\nθ : CategoryTheory.FreeBicategory.Hom₂ g h\n⊢ Eq (η.vcomp θ).mk (CategoryTheory.CategoryStruct.comp η.mk θ.mk)","decl":"@[simp]\ntheorem mk_vcomp {f g h : a ⟶ b} (η : Hom₂ f g) (θ : Hom₂ g h) :\n    (η.vcomp θ).mk = (η.mk ≫ θ.mk : f ⟶ h) :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.mk_whisker_left","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na b c : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\ng h : Quiver.Hom b c\nη : CategoryTheory.FreeBicategory.Hom₂ g h\n⊢ Eq (CategoryTheory.FreeBicategory.Hom₂.whisker_left f η).mk (CategoryTheory.Bicategory.whiskerLeft f η.mk)","decl":"@[simp]\ntheorem mk_whisker_left (f : a ⟶ b) {g h : b ⟶ c} (η : Hom₂ g h) :\n    (Hom₂.whisker_left f η).mk = (f ◁ η.mk : f ≫ g ⟶ f ≫ h) :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.mk_whisker_right","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na b c : CategoryTheory.FreeBicategory B\nf g : Quiver.Hom a b\nη : CategoryTheory.FreeBicategory.Hom₂ f g\nh : Quiver.Hom b c\n⊢ Eq (CategoryTheory.FreeBicategory.Hom₂.whisker_right h η).mk (CategoryTheory.Bicategory.whiskerRight η.mk h)","decl":"@[simp]\ntheorem mk_whisker_right {f g : a ⟶ b} (η : Hom₂ f g) (h : b ⟶ c) :\n    (Hom₂.whisker_right h η).mk = (η.mk ▷ h : f ≫ h ⟶ g ≫ h) :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.comp_def","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na b c : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\n⊢ Eq (CategoryTheory.FreeBicategory.Hom.comp f g) (CategoryTheory.CategoryStruct.comp f g)","decl":"theorem comp_def : Hom.comp f g = f ≫ g :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.mk_id","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na b : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\n⊢ Eq (Quot.mk CategoryTheory.FreeBicategory.Rel (CategoryTheory.FreeBicategory.Hom₂.id f)) (CategoryTheory.CategoryStruct.id f)","decl":"@[simp]\ntheorem mk_id : Quot.mk _ (Hom₂.id f) = 𝟙 f :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.mk_associator_hom","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na b c d : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n⊢ Eq (Quot.mk CategoryTheory.FreeBicategory.Rel (CategoryTheory.FreeBicategory.Hom₂.associator f g h)) (CategoryTheory.Bicategory.associator f g h).hom","decl":"@[simp]\ntheorem mk_associator_hom : Quot.mk _ (Hom₂.associator f g h) = (α_ f g h).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.mk_associator_inv","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na b c d : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\nh : Quiver.Hom c d\n⊢ Eq (Quot.mk CategoryTheory.FreeBicategory.Rel (CategoryTheory.FreeBicategory.Hom₂.associator_inv f g h)) (CategoryTheory.Bicategory.associator f g h).inv","decl":"@[simp]\ntheorem mk_associator_inv : Quot.mk _ (Hom₂.associator_inv f g h) = (α_ f g h).inv :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.mk_left_unitor_hom","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na b : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\n⊢ Eq (Quot.mk CategoryTheory.FreeBicategory.Rel (CategoryTheory.FreeBicategory.Hom₂.left_unitor f)) (CategoryTheory.Bicategory.leftUnitor f).hom","decl":"@[simp]\ntheorem mk_left_unitor_hom : Quot.mk _ (Hom₂.left_unitor f) = (λ_ f).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.mk_left_unitor_inv","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na b : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\n⊢ Eq (Quot.mk CategoryTheory.FreeBicategory.Rel (CategoryTheory.FreeBicategory.Hom₂.left_unitor_inv f)) (CategoryTheory.Bicategory.leftUnitor f).inv","decl":"@[simp]\ntheorem mk_left_unitor_inv : Quot.mk _ (Hom₂.left_unitor_inv f) = (λ_ f).inv :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.mk_right_unitor_hom","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na b : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\n⊢ Eq (Quot.mk CategoryTheory.FreeBicategory.Rel (CategoryTheory.FreeBicategory.Hom₂.right_unitor f)) (CategoryTheory.Bicategory.rightUnitor f).hom","decl":"@[simp]\ntheorem mk_right_unitor_hom : Quot.mk _ (Hom₂.right_unitor f) = (ρ_ f).hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.mk_right_unitor_inv","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na b : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\n⊢ Eq (Quot.mk CategoryTheory.FreeBicategory.Rel (CategoryTheory.FreeBicategory.Hom₂.right_unitor_inv f)) (CategoryTheory.Bicategory.rightUnitor f).inv","decl":"@[simp]\ntheorem mk_right_unitor_inv : Quot.mk _ (Hom₂.right_unitor_inv f) = (ρ_ f).inv :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.of_obj","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\na : B\n⊢ Eq (CategoryTheory.FreeBicategory.of.obj a) (id a)","decl":"/-- Canonical prefunctor from `B` to `free_bicategory B`. -/\n@[simps]\ndef of : Prefunctor B (FreeBicategory B) where\n  obj := id\n  map := @fun _ _ => Hom.of\n\n"}
{"name":"CategoryTheory.FreeBicategory.of_map","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u\ninst✝ : Quiver B\nx✝¹ x✝ : B\nf : Quiver.Hom x✝¹ x✝\n⊢ Eq (CategoryTheory.FreeBicategory.of.map f) (CategoryTheory.FreeBicategory.Hom.of f)","decl":"/-- Canonical prefunctor from `B` to `free_bicategory B`. -/\n@[simps]\ndef of : Prefunctor B (FreeBicategory B) where\n  obj := id\n  map := @fun _ _ => Hom.of\n\n"}
{"name":"CategoryTheory.FreeBicategory.liftHom_id","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u₁\ninst✝¹ : Quiver B\nC : Type u₂\ninst✝ : CategoryTheory.CategoryStruct.{v₂, u₂} C\nF : Prefunctor B C\na : CategoryTheory.FreeBicategory B\n⊢ Eq (CategoryTheory.FreeBicategory.liftHom F (CategoryTheory.CategoryStruct.id a)) (CategoryTheory.CategoryStruct.id (F.obj a))","decl":"@[simp]\ntheorem liftHom_id (a : FreeBicategory B) : liftHom F (𝟙 a) = 𝟙 (F.obj a) :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.liftHom_comp","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u₁\ninst✝¹ : Quiver B\nC : Type u₂\ninst✝ : CategoryTheory.CategoryStruct.{v₂, u₂} C\nF : Prefunctor B C\na b c : CategoryTheory.FreeBicategory B\nf : Quiver.Hom a b\ng : Quiver.Hom b c\n⊢ Eq (CategoryTheory.FreeBicategory.liftHom F (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.FreeBicategory.liftHom F f) (CategoryTheory.FreeBicategory.liftHom F g))","decl":"@[simp]\ntheorem liftHom_comp {a b c : FreeBicategory B} (f : a ⟶ b) (g : b ⟶ c) :\n    liftHom F (f ≫ g) = liftHom F f ≫ liftHom F g :=\n  rfl\n\n"}
{"name":"CategoryTheory.FreeBicategory.liftHom₂_congr","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u₁\ninst✝¹ : Quiver B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : Prefunctor B C\na b : CategoryTheory.FreeBicategory B\nf g : Quiver.Hom a b\nη θ : CategoryTheory.FreeBicategory.Hom₂ f g\nH : CategoryTheory.FreeBicategory.Rel η θ\n⊢ Eq (CategoryTheory.FreeBicategory.liftHom₂ F η) (CategoryTheory.FreeBicategory.liftHom₂ F θ)","decl":"theorem liftHom₂_congr {a b : FreeBicategory B} {f g : a ⟶ b} {η θ : Hom₂ f g} (H : Rel η θ) :\n    liftHom₂ F η = liftHom₂ F θ := by induction H <;> (dsimp [liftHom₂]; aesop_cat)\n\n"}
{"name":"CategoryTheory.FreeBicategory.lift_mapComp","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u₁\ninst✝¹ : Quiver B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : Prefunctor B C\na✝ b✝ c✝ : CategoryTheory.FreeBicategory B\nx✝¹ : Quiver.Hom a✝ b✝\nx✝ : Quiver.Hom b✝ c✝\n⊢ Eq ((CategoryTheory.FreeBicategory.lift F).mapComp x✝¹ x✝) (CategoryTheory.Iso.refl ({ obj := F.obj, map := fun {X Y} => CategoryTheory.FreeBicategory.liftHom F, map₂ := fun {a b} {f g} => Quot.lift (CategoryTheory.FreeBicategory.liftHom₂ F) ⋯, map₂_id := ⋯, map₂_comp := ⋯ }.map (CategoryTheory.CategoryStruct.comp x✝¹ x✝)))","decl":"/-- A prefunctor from a quiver `B` to a bicategory `C` can be lifted to a pseudofunctor from\n`free_bicategory B` to `C`.\n-/\n@[simps]\ndef lift : Pseudofunctor (FreeBicategory B) C where\n  obj := F.obj\n  map := liftHom F\n  mapId _ := Iso.refl _\n  mapComp _ _ := Iso.refl _\n  map₂ := Quot.lift (liftHom₂ F) fun _ _ H => liftHom₂_congr F H\n  -- Porting note: We'd really prefer not to be doing this by hand.\n  -- in mathlib3 `tidy` did these inductions for us.\n  map₂_comp := by\n    intros a b f g h η θ\n    induction η using Quot.rec\n    · induction θ using Quot.rec <;> rfl\n    · rfl\n  -- Porting note: still borked from here. The infoview doesn't update properly for me.\n  map₂_whisker_left := by\n    intro a b c f g h η\n    induction η using Quot.rec\n    · aesop_cat\n    · rfl\n  map₂_whisker_right := by intro _ _ _ _ _ η h; dsimp; induction η using Quot.rec <;> aesop_cat\n\n"}
{"name":"CategoryTheory.FreeBicategory.lift_mapId","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u₁\ninst✝¹ : Quiver B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : Prefunctor B C\nx✝ : CategoryTheory.FreeBicategory B\n⊢ Eq ((CategoryTheory.FreeBicategory.lift F).mapId x✝) (CategoryTheory.Iso.refl ({ obj := F.obj, map := fun {X Y} => CategoryTheory.FreeBicategory.liftHom F, map₂ := fun {a b} {f g} => Quot.lift (CategoryTheory.FreeBicategory.liftHom₂ F) ⋯, map₂_id := ⋯, map₂_comp := ⋯ }.map (CategoryTheory.CategoryStruct.id x✝)))","decl":"/-- A prefunctor from a quiver `B` to a bicategory `C` can be lifted to a pseudofunctor from\n`free_bicategory B` to `C`.\n-/\n@[simps]\ndef lift : Pseudofunctor (FreeBicategory B) C where\n  obj := F.obj\n  map := liftHom F\n  mapId _ := Iso.refl _\n  mapComp _ _ := Iso.refl _\n  map₂ := Quot.lift (liftHom₂ F) fun _ _ H => liftHom₂_congr F H\n  -- Porting note: We'd really prefer not to be doing this by hand.\n  -- in mathlib3 `tidy` did these inductions for us.\n  map₂_comp := by\n    intros a b f g h η θ\n    induction η using Quot.rec\n    · induction θ using Quot.rec <;> rfl\n    · rfl\n  -- Porting note: still borked from here. The infoview doesn't update properly for me.\n  map₂_whisker_left := by\n    intro a b c f g h η\n    induction η using Quot.rec\n    · aesop_cat\n    · rfl\n  map₂_whisker_right := by intro _ _ _ _ _ η h; dsimp; induction η using Quot.rec <;> aesop_cat\n\n"}
{"name":"CategoryTheory.FreeBicategory.lift_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_map","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u₁\ninst✝¹ : Quiver B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : Prefunctor B C\nX✝ Y✝ : CategoryTheory.FreeBicategory B\na✝ : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.FreeBicategory.lift F).map a✝) (CategoryTheory.FreeBicategory.liftHom F a✝)","decl":"/-- A prefunctor from a quiver `B` to a bicategory `C` can be lifted to a pseudofunctor from\n`free_bicategory B` to `C`.\n-/\n@[simps]\ndef lift : Pseudofunctor (FreeBicategory B) C where\n  obj := F.obj\n  map := liftHom F\n  mapId _ := Iso.refl _\n  mapComp _ _ := Iso.refl _\n  map₂ := Quot.lift (liftHom₂ F) fun _ _ H => liftHom₂_congr F H\n  -- Porting note: We'd really prefer not to be doing this by hand.\n  -- in mathlib3 `tidy` did these inductions for us.\n  map₂_comp := by\n    intros a b f g h η θ\n    induction η using Quot.rec\n    · induction θ using Quot.rec <;> rfl\n    · rfl\n  -- Porting note: still borked from here. The infoview doesn't update properly for me.\n  map₂_whisker_left := by\n    intro a b c f g h η\n    induction η using Quot.rec\n    · aesop_cat\n    · rfl\n  map₂_whisker_right := by intro _ _ _ _ _ η h; dsimp; induction η using Quot.rec <;> aesop_cat\n\n"}
{"name":"CategoryTheory.FreeBicategory.lift_toPrelaxFunctor_toPrelaxFunctorStruct_toPrefunctor_obj","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u₁\ninst✝¹ : Quiver B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : Prefunctor B C\na✝ : B\n⊢ Eq ((CategoryTheory.FreeBicategory.lift F).obj a✝) (F.obj a✝)","decl":"/-- A prefunctor from a quiver `B` to a bicategory `C` can be lifted to a pseudofunctor from\n`free_bicategory B` to `C`.\n-/\n@[simps]\ndef lift : Pseudofunctor (FreeBicategory B) C where\n  obj := F.obj\n  map := liftHom F\n  mapId _ := Iso.refl _\n  mapComp _ _ := Iso.refl _\n  map₂ := Quot.lift (liftHom₂ F) fun _ _ H => liftHom₂_congr F H\n  -- Porting note: We'd really prefer not to be doing this by hand.\n  -- in mathlib3 `tidy` did these inductions for us.\n  map₂_comp := by\n    intros a b f g h η θ\n    induction η using Quot.rec\n    · induction θ using Quot.rec <;> rfl\n    · rfl\n  -- Porting note: still borked from here. The infoview doesn't update properly for me.\n  map₂_whisker_left := by\n    intro a b c f g h η\n    induction η using Quot.rec\n    · aesop_cat\n    · rfl\n  map₂_whisker_right := by intro _ _ _ _ _ η h; dsimp; induction η using Quot.rec <;> aesop_cat\n\n"}
{"name":"CategoryTheory.FreeBicategory.lift_toPrelaxFunctor_toPrelaxFunctorStruct_map₂","module":"Mathlib.CategoryTheory.Bicategory.Free","initialProofState":"B : Type u₁\ninst✝¹ : Quiver B\nC : Type u₂\ninst✝ : CategoryTheory.Bicategory C\nF : Prefunctor B C\na✝ b✝ : CategoryTheory.FreeBicategory B\nf✝ g✝ : Quiver.Hom a✝ b✝\na : Quot CategoryTheory.FreeBicategory.Rel\n⊢ Eq ((CategoryTheory.FreeBicategory.lift F).map₂ a) (Quot.lift (CategoryTheory.FreeBicategory.liftHom₂ F) ⋯ a)","decl":"/-- A prefunctor from a quiver `B` to a bicategory `C` can be lifted to a pseudofunctor from\n`free_bicategory B` to `C`.\n-/\n@[simps]\ndef lift : Pseudofunctor (FreeBicategory B) C where\n  obj := F.obj\n  map := liftHom F\n  mapId _ := Iso.refl _\n  mapComp _ _ := Iso.refl _\n  map₂ := Quot.lift (liftHom₂ F) fun _ _ H => liftHom₂_congr F H\n  -- Porting note: We'd really prefer not to be doing this by hand.\n  -- in mathlib3 `tidy` did these inductions for us.\n  map₂_comp := by\n    intros a b f g h η θ\n    induction η using Quot.rec\n    · induction θ using Quot.rec <;> rfl\n    · rfl\n  -- Porting note: still borked from here. The infoview doesn't update properly for me.\n  map₂_whisker_left := by\n    intro a b c f g h η\n    induction η using Quot.rec\n    · aesop_cat\n    · rfl\n  map₂_whisker_right := by intro _ _ _ _ _ η h; dsimp; induction η using Quot.rec <;> aesop_cat\n\n"}
