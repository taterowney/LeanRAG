{"name":"szemeredi_regularity","module":"Mathlib.Combinatorics.SimpleGraph.Regularity.Lemma","initialProofState":"α : Type u_1\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\nG : SimpleGraph α\ninst✝ : DecidableRel G.Adj\nε : Real\nl : Nat\nhε : LT.lt 0 ε\nhl : LE.le l (Fintype.card α)\n⊢ Exists fun P => And P.IsEquipartition (And (LE.le l P.parts.card) (And (LE.le P.parts.card (SzemerediRegularity.bound ε l)) (P.IsUniform G ε)))","decl":"/-- Effective **Szemerédi Regularity Lemma**: For any sufficiently large graph, there is an\n`ε`-uniform equipartition of bounded size (where the bound does not depend on the graph). -/\ntheorem szemeredi_regularity (hε : 0 < ε) (hl : l ≤ card α) :\n    ∃ P : Finpartition univ,\n      P.IsEquipartition ∧ l ≤ #P.parts ∧ #P.parts ≤ bound ε l ∧ P.IsUniform G ε := by\n  obtain hα | hα := le_total (card α) (bound ε l)\n  -- If `card α ≤ bound ε l`, then the partition into singletons is acceptable.\n  · refine ⟨⊥, bot_isEquipartition _, ?_⟩\n    rw [card_bot, card_univ]\n    exact ⟨hl, hα, bot_isUniform _ hε⟩\n  -- Else, let's start from a dummy equipartition of size `initialBound ε l`.\n  let t := initialBound ε l\n  have htα : t ≤ #(univ : Finset α) :=\n    (initialBound_le_bound _ _).trans (by rwa [Finset.card_univ])\n  obtain ⟨dum, hdum₁, hdum₂⟩ :=\n    exists_equipartition_card_eq (univ : Finset α) (initialBound_pos _ _).ne' htα\n  obtain hε₁ | hε₁ := le_total 1 ε\n  -- If `ε ≥ 1`, then this dummy equipartition is `ε`-uniform, so we're done.\n  · exact ⟨dum, hdum₁, (le_initialBound ε l).trans hdum₂.ge,\n      hdum₂.le.trans (initialBound_le_bound ε l), (dum.isUniform_one G).mono hε₁⟩\n  -- Else, set up the induction on energy. We phrase it through the existence for each `i` of an\n  -- equipartition of size bounded by `stepBound^[i] (initialBound ε l)` and which is either\n  -- `ε`-uniform or has energy at least `ε ^ 5 / 4 * i`.\n  have : Nonempty α := by\n    rw [← Fintype.card_pos_iff]\n    exact (bound_pos _ _).trans_le hα\n  suffices h : ∀ i, ∃ P : Finpartition (univ : Finset α), P.IsEquipartition ∧ t ≤ #P.parts ∧\n    #P.parts ≤ stepBound^[i] t ∧ (P.IsUniform G ε ∨ ε ^ 5 / 4 * i ≤ P.energy G) by\n  -- For `i > 4 / ε ^ 5` we know that the partition we get can't have energy `≥ ε ^ 5 / 4 * i > 1`,\n  -- so it must instead be `ε`-uniform and we won.\n    obtain ⟨P, hP₁, hP₂, hP₃, hP₄⟩ := h (⌊4 / ε ^ 5⌋₊ + 1)\n    refine ⟨P, hP₁, (le_initialBound _ _).trans hP₂, hP₃.trans ?_,\n      hP₄.resolve_right fun hPenergy => lt_irrefl (1 : ℝ) ?_⟩\n    · rw [iterate_succ_apply', stepBound, bound]\n      gcongr\n      norm_num\n    calc\n      (1 : ℝ) = ε ^ 5 / ↑4 * (↑4 / ε ^ 5) := by\n        rw [mul_comm, div_mul_div_cancel₀ (pow_pos hε 5).ne']; norm_num\n      _ < ε ^ 5 / 4 * (⌊4 / ε ^ 5⌋₊ + 1) :=\n        ((mul_lt_mul_left <| by positivity).2 (Nat.lt_floor_add_one _))\n      _ ≤ (P.energy G : ℝ) := by rwa [← Nat.cast_add_one]\n      _ ≤ 1 := mod_cast P.energy_le_one G\n  -- Let's do the actual induction.\n  intro i\n  induction' i with i ih\n  -- For `i = 0`, the dummy equipartition is enough.\n  · refine ⟨dum, hdum₁, hdum₂.ge, hdum₂.le, Or.inr ?_⟩\n    rw [Nat.cast_zero, mul_zero]\n    exact mod_cast dum.energy_nonneg G\n  -- For the induction step at `i + 1`, find `P` the equipartition at `i`.\n  obtain ⟨P, hP₁, hP₂, hP₃, hP₄⟩ := ih\n  by_cases huniform : P.IsUniform G ε\n  -- If `P` is already uniform, then no need to break it up further. We can just return `P` again.\n  · refine ⟨P, hP₁, hP₂, ?_, Or.inl huniform⟩\n    rw [iterate_succ_apply']\n    exact hP₃.trans (le_stepBound _)\n  -- Else, `P` must instead have energy at least `ε ^ 5 / 4 * i`.\n  replace hP₄ := hP₄.resolve_left huniform\n  -- We gather a few numerical facts.\n  have hεl' : 100 ≤ 4 ^ #P.parts * ε ^ 5 :=\n    (hundred_lt_pow_initialBound_mul hε l).le.trans\n      (mul_le_mul_of_nonneg_right (pow_right_mono₀ (by norm_num) hP₂) <| by positivity)\n  have hi : (i : ℝ) ≤ 4 / ε ^ 5 := by\n    have hi : ε ^ 5 / 4 * ↑i ≤ 1 := hP₄.trans (mod_cast P.energy_le_one G)\n    rw [div_mul_eq_mul_div, div_le_iff₀ (show (0 : ℝ) < 4 by norm_num)] at hi\n    norm_num at hi\n    rwa [le_div_iff₀' (pow_pos hε _)]\n  have hsize : #P.parts ≤ stepBound^[⌊4 / ε ^ 5⌋₊] t :=\n    hP₃.trans (monotone_iterate_of_id_le le_stepBound (Nat.le_floor hi) _)\n  have hPα : #P.parts * 16 ^ #P.parts ≤ card α :=\n    (Nat.mul_le_mul hsize (Nat.pow_le_pow_of_le_right (by norm_num) hsize)).trans hα\n  -- We return the increment equipartition of `P`, which has energy `≥ ε ^ 5 / 4 * (i + 1)`.\n  refine ⟨increment hP₁ G ε, increment_isEquipartition hP₁ G ε, ?_, ?_, Or.inr <| le_trans ?_ <|\n    energy_increment hP₁ ((seven_le_initialBound ε l).trans hP₂) hεl' hPα huniform hε.le hε₁⟩\n  · rw [card_increment hPα huniform]\n    exact hP₂.trans (le_stepBound _)\n  · rw [card_increment hPα huniform, iterate_succ_apply']\n    exact stepBound_mono hP₃\n  · rw [Nat.cast_succ, mul_add, mul_one]\n    exact add_le_add_right hP₄ _\n"}
