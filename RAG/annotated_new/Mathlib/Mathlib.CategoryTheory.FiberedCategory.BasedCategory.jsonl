{"name":"CategoryTheory.BasedCategory.mk.injEq","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nobjâœ : Type uâ‚‚\ncategoryâœ : autoParam (CategoryTheory.Category.{vâ‚‚, uâ‚‚} objâœ) _autoâœ\npâœ : CategoryTheory.Functor objâœ ğ’®\nobj : Type uâ‚‚\ncategory : autoParam (CategoryTheory.Category.{vâ‚‚, uâ‚‚} obj) _autoâœ\np : CategoryTheory.Functor obj ğ’®\nâŠ¢ Eq (Eq { obj := objâœ, category := categoryâœ, p := pâœ } { obj := obj, category := category, p := p }) (And (Eq objâœ obj) (And (HEq categoryâœ category) (HEq pâœ p)))","decl":"/-- A based category over `ğ’®` is a category `ğ’³` together with a functor `p : ğ’³ â¥¤ ğ’®`. -/\n@[nolint checkUnivs]\nstructure BasedCategory (ğ’® : Type uâ‚) [Category.{vâ‚} ğ’®] where\n  /-- The type of objects in a `BasedCategory`-/\n  obj : Type uâ‚‚\n  /-- The underlying category of a `BasedCategory`. -/\n  category : Category.{vâ‚‚} obj := by infer_instance\n  /-- The functor to the base. -/\n  p : obj â¥¤ ğ’®\n\n"}
{"name":"CategoryTheory.BasedCategory.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\ninstâœ : SizeOf ğ’®\nobj : Type uâ‚‚\ncategory : autoParam (CategoryTheory.Category.{vâ‚‚, uâ‚‚} obj) _autoâœ\np : CategoryTheory.Functor obj ğ’®\nâŠ¢ Eq (SizeOf.sizeOf { obj := obj, category := category, p := p }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf obj)) (SizeOf.sizeOf category)) (SizeOf.sizeOf p))","decl":"/-- A based category over `ğ’®` is a category `ğ’³` together with a functor `p : ğ’³ â¥¤ ğ’®`. -/\n@[nolint checkUnivs]\nstructure BasedCategory (ğ’® : Type uâ‚) [Category.{vâ‚} ğ’®] where\n  /-- The type of objects in a `BasedCategory`-/\n  obj : Type uâ‚‚\n  /-- The underlying category of a `BasedCategory`. -/\n  category : Category.{vâ‚‚} obj := by infer_instance\n  /-- The functor to the base. -/\n  p : obj â¥¤ ğ’®\n\n"}
{"name":"CategoryTheory.BasedCategory.mk.inj","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nobjâœ : Type uâ‚‚\ncategoryâœ : autoParam (CategoryTheory.Category.{vâ‚‚, uâ‚‚} objâœ) _autoâœ\npâœ : CategoryTheory.Functor objâœ ğ’®\nobj : Type uâ‚‚\ncategory : autoParam (CategoryTheory.Category.{vâ‚‚, uâ‚‚} obj) _autoâœ\np : CategoryTheory.Functor obj ğ’®\nxâœ : Eq { obj := objâœ, category := categoryâœ, p := pâœ } { obj := obj, category := category, p := p }\nâŠ¢ And (Eq objâœ obj) (And (HEq categoryâœ category) (HEq pâœ p))","decl":"/-- A based category over `ğ’®` is a category `ğ’³` together with a functor `p : ğ’³ â¥¤ ğ’®`. -/\n@[nolint checkUnivs]\nstructure BasedCategory (ğ’® : Type uâ‚) [Category.{vâ‚} ğ’®] where\n  /-- The type of objects in a `BasedCategory`-/\n  obj : Type uâ‚‚\n  /-- The underlying category of a `BasedCategory`. -/\n  category : Category.{vâ‚‚} obj := by infer_instance\n  /-- The functor to the base. -/\n  p : obj â¥¤ ğ’®\n\n"}
{"name":"CategoryTheory.BasedFunctor.mk.injEq","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\ntoFunctorâœ : CategoryTheory.Functor ğ’³.obj ğ’´.obj\nwâœ : autoParam (Eq (toFunctorâœ.comp ğ’´.p) ğ’³.p) _autoâœ\ntoFunctor : CategoryTheory.Functor ğ’³.obj ğ’´.obj\nw : autoParam (Eq (toFunctor.comp ğ’´.p) ğ’³.p) _autoâœ\nâŠ¢ Eq (Eq { toFunctor := toFunctorâœ, w := wâœ } { toFunctor := toFunctor, w := w }) (Eq toFunctorâœ toFunctor)","decl":"/-- A functor between based categories is a functor between the underlying categories that commutes\nwith the projections. -/\nstructure BasedFunctor (ğ’³ : BasedCategory.{vâ‚‚, uâ‚‚} ğ’®) (ğ’´ : BasedCategory.{vâ‚ƒ, uâ‚ƒ} ğ’®) extends\n    ğ’³.obj â¥¤ ğ’´.obj where\n  w : toFunctor â‹™ ğ’´.p = ğ’³.p := by aesop_cat\n\n"}
{"name":"CategoryTheory.BasedFunctor.w","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nself : CategoryTheory.BasedFunctor ğ’³ ğ’´\nâŠ¢ Eq (self.comp ğ’´.p) ğ’³.p","decl":"/-- A functor between based categories is a functor between the underlying categories that commutes\nwith the projections. -/\nstructure BasedFunctor (ğ’³ : BasedCategory.{vâ‚‚, uâ‚‚} ğ’®) (ğ’´ : BasedCategory.{vâ‚ƒ, uâ‚ƒ} ğ’®) extends\n    ğ’³.obj â¥¤ ğ’´.obj where\n  w : toFunctor â‹™ ğ’´.p = ğ’³.p := by aesop_cat\n\n"}
{"name":"CategoryTheory.BasedFunctor.mk.inj","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\ntoFunctorâœ : CategoryTheory.Functor ğ’³.obj ğ’´.obj\nwâœ : autoParam (Eq (toFunctorâœ.comp ğ’´.p) ğ’³.p) _autoâœ\ntoFunctor : CategoryTheory.Functor ğ’³.obj ğ’´.obj\nw : autoParam (Eq (toFunctor.comp ğ’´.p) ğ’³.p) _autoâœ\nxâœ : Eq { toFunctor := toFunctorâœ, w := wâœ } { toFunctor := toFunctor, w := w }\nâŠ¢ Eq toFunctorâœ toFunctor","decl":"/-- A functor between based categories is a functor between the underlying categories that commutes\nwith the projections. -/\nstructure BasedFunctor (ğ’³ : BasedCategory.{vâ‚‚, uâ‚‚} ğ’®) (ğ’´ : BasedCategory.{vâ‚ƒ, uâ‚ƒ} ğ’®) extends\n    ğ’³.obj â¥¤ ğ’´.obj where\n  w : toFunctor â‹™ ğ’´.p = ğ’³.p := by aesop_cat\n\n"}
{"name":"CategoryTheory.BasedFunctor.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\ninstâœ : SizeOf ğ’®\ntoFunctor : CategoryTheory.Functor ğ’³.obj ğ’´.obj\nw : autoParam (Eq (toFunctor.comp ğ’´.p) ğ’³.p) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { toFunctor := toFunctor, w := w }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toFunctor)) (SizeOf.sizeOf w))","decl":"/-- A functor between based categories is a functor between the underlying categories that commutes\nwith the projections. -/\nstructure BasedFunctor (ğ’³ : BasedCategory.{vâ‚‚, uâ‚‚} ğ’®) (ğ’´ : BasedCategory.{vâ‚ƒ, uâ‚ƒ} ğ’®) extends\n    ğ’³.obj â¥¤ ğ’´.obj where\n  w : toFunctor â‹™ ğ’´.p = ğ’³.p := by aesop_cat\n\n"}
{"name":"CategoryTheory.BasedFunctor.id_toFunctor","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nâŠ¢ Eq (CategoryTheory.BasedFunctor.id ğ’³).toFunctor (CategoryTheory.Functor.id ğ’³.obj)","decl":"/-- The identity based functor. -/\n@[simps]\ndef id (ğ’³ : BasedCategory.{vâ‚‚, uâ‚‚} ğ’®) : ğ’³ â¥¤áµ‡ ğ’³ where\n  toFunctor := ğŸ­ ğ’³.obj\n\n"}
{"name":"CategoryTheory.BasedFunctor.comp_toFunctor","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nğ’µ : CategoryTheory.BasedCategory ğ’®\nF : CategoryTheory.BasedFunctor ğ’³ ğ’´\nG : CategoryTheory.BasedFunctor ğ’´ ğ’µ\nâŠ¢ Eq (F.comp G).toFunctor (F.comp G.toFunctor)","decl":"/-- The composition of two based functors. -/\n@[simps]\ndef comp {ğ’µ : BasedCategory.{vâ‚„, uâ‚„} ğ’®} (F : ğ’³ â¥¤áµ‡ ğ’´) (G : ğ’´ â¥¤áµ‡ ğ’µ) : ğ’³ â¥¤áµ‡ ğ’µ where\n  toFunctor := F.toFunctor â‹™ G.toFunctor\n  w := by rw [Functor.assoc, G.w, F.w]\n\n"}
{"name":"CategoryTheory.BasedFunctor.comp_id","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF : CategoryTheory.BasedFunctor ğ’³ ğ’´\nâŠ¢ Eq (F.comp (CategoryTheory.BasedFunctor.id ğ’´)) F","decl":"@[simp]\nlemma comp_id (F : ğ’³ â¥¤áµ‡ ğ’´) :  F â‹™ ğŸ­ ğ’´ = F :=\n  rfl\n\n"}
{"name":"CategoryTheory.BasedFunctor.id_comp","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF : CategoryTheory.BasedFunctor ğ’³ ğ’´\nâŠ¢ Eq ((CategoryTheory.BasedFunctor.id ğ’³).comp F) F","decl":"@[simp]\nlemma id_comp (F : ğ’³ â¥¤áµ‡ ğ’´) : ğŸ­ ğ’³ â‹™ F = F :=\n  rfl\n\n"}
{"name":"CategoryTheory.BasedFunctor.comp_assoc","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nğ’µ : CategoryTheory.BasedCategory ğ’®\nğ’œ : CategoryTheory.BasedCategory ğ’®\nF : CategoryTheory.BasedFunctor ğ’³ ğ’´\nG : CategoryTheory.BasedFunctor ğ’´ ğ’µ\nH : CategoryTheory.BasedFunctor ğ’µ ğ’œ\nâŠ¢ Eq ((F.comp G).comp H) (F.comp (G.comp H))","decl":"@[simp]\nlemma comp_assoc {ğ’µ : BasedCategory.{vâ‚„, uâ‚„} ğ’®} {ğ’œ : BasedCategory.{vâ‚…, uâ‚…} ğ’®} (F : ğ’³ â¥¤áµ‡ ğ’´)\n    (G : ğ’´ â¥¤áµ‡ ğ’µ) (H : ğ’µ â¥¤áµ‡ ğ’œ) : (F â‹™ G) â‹™ H = F â‹™ (G â‹™ H) :=\n  rfl\n\n"}
{"name":"CategoryTheory.BasedFunctor.w_obj","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF : CategoryTheory.BasedFunctor ğ’³ ğ’´\na : ğ’³.obj\nâŠ¢ Eq (ğ’´.p.obj (F.obj a)) (ğ’³.p.obj a)","decl":"@[simp]\nlemma w_obj (F : ğ’³ â¥¤áµ‡ ğ’´) (a : ğ’³.obj) : ğ’´.p.obj (F.obj a) = ğ’³.p.obj a := by\n  rw [â† Functor.comp_obj, F.w]\n\n"}
{"name":"CategoryTheory.BasedFunctor.instIsHomLiftObjPIdObj","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF : CategoryTheory.BasedFunctor ğ’³ ğ’´\na : ğ’³.obj\nâŠ¢ ğ’´.p.IsHomLift (CategoryTheory.CategoryStruct.id (ğ’³.p.obj a)) (CategoryTheory.CategoryStruct.id (F.obj a))","decl":"instance (F : ğ’³ â¥¤áµ‡ ğ’´) (a : ğ’³.obj) : IsHomLift ğ’´.p (ğŸ™ (ğ’³.p.obj a)) (ğŸ™ (F.obj a)) :=\n  IsHomLift.id (w_obj F a)\n\n"}
{"name":"CategoryTheory.BasedFunctor.preserves_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF : CategoryTheory.BasedFunctor ğ’³ ğ’´\nR S : ğ’®\na b : ğ’³.obj\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœ : ğ’³.p.IsHomLift f Ï†\nâŠ¢ ğ’´.p.IsHomLift f (F.map Ï†)","decl":"/-- For a based functor `F : ğ’³ âŸ¶ ğ’´`, then whenever an arrow `Ï†` in `ğ’³` lifts some `f` in `ğ’®`,\nthen `F(Ï†)` also lifts `f`. -/\ninstance preserves_isHomLift [IsHomLift ğ’³.p f Ï†] : IsHomLift ğ’´.p f (F.map Ï†) := by\n  apply of_fac ğ’´.p f (F.map Ï†) (Eq.trans (F.w_obj a) (domain_eq ğ’³.p f Ï†))\n    (Eq.trans (F.w_obj b) (codomain_eq ğ’³.p f Ï†))\n  rw [â† Functor.comp_map, congr_hom F.w]\n  simpa using (fac ğ’³.p f Ï†)\n\n"}
{"name":"CategoryTheory.BasedFunctor.isHomLift_map","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF : CategoryTheory.BasedFunctor ğ’³ ğ’´\nR S : ğ’®\na b : ğ’³.obj\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\ninstâœ : ğ’´.p.IsHomLift f (F.map Ï†)\nâŠ¢ ğ’³.p.IsHomLift f Ï†","decl":"/-- For a based functor `F : ğ’³ âŸ¶ ğ’´`, and an arrow `Ï†` in `ğ’³`, then `Ï†` lifts an arrow `f` in `ğ’®`\nif `F(Ï†)` does. -/\nlemma isHomLift_map [IsHomLift ğ’´.p f (F.map Ï†)] : IsHomLift ğ’³.p f Ï† := by\n  apply of_fac ğ’³.p f Ï†  (F.w_obj a â–¸ domain_eq ğ’´.p f (F.map Ï†))\n    (F.w_obj b â–¸ codomain_eq ğ’´.p f (F.map Ï†))\n  simp [congr_hom F.w.symm, fac ğ’´.p f (F.map Ï†)]\n\n"}
{"name":"CategoryTheory.BasedFunctor.isHomLift_iff","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF : CategoryTheory.BasedFunctor ğ’³ ğ’´\nR S : ğ’®\na b : ğ’³.obj\nf : Quiver.Hom R S\nÏ† : Quiver.Hom a b\nâŠ¢ Iff (ğ’´.p.IsHomLift f (F.map Ï†)) (ğ’³.p.IsHomLift f Ï†)","decl":"lemma isHomLift_iff : IsHomLift ğ’´.p f (F.map Ï†) â†” IsHomLift ğ’³.p f Ï† :=\n  âŸ¨fun _ â†¦ isHomLift_map F f Ï†, fun _ â†¦ preserves_isHomLift F f Ï†âŸ©\n\n"}
{"name":"CategoryTheory.BasedNatTrans.mk.injEq","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF G : CategoryTheory.BasedFunctor ğ’³ ğ’´\ntoNatTransâœ : CategoryTheory.NatTrans F.toFunctor G.toFunctor\nisHomLift'âœ : autoParam (âˆ€ (a : ğ’³.obj), ğ’´.p.IsHomLift (CategoryTheory.CategoryStruct.id (ğ’³.p.obj a)) (toNatTransâœ.app a)) _autoâœ\ntoNatTrans : CategoryTheory.NatTrans F.toFunctor G.toFunctor\nisHomLift' : autoParam (âˆ€ (a : ğ’³.obj), ğ’´.p.IsHomLift (CategoryTheory.CategoryStruct.id (ğ’³.p.obj a)) (toNatTrans.app a)) _autoâœ\nâŠ¢ Eq (Eq { toNatTrans := toNatTransâœ, isHomLift' := isHomLift'âœ } { toNatTrans := toNatTrans, isHomLift' := isHomLift' }) (Eq toNatTransâœ toNatTrans)","decl":"/-- A `BasedNatTrans` between two `BasedFunctor`s is a natural transformation `Î±` between the\nunderlying functors, such that for all `a : ğ’³`, `Î±.app a` lifts `ğŸ™ S` whenever `ğ’³.p.obj a = S`. -/\nstructure BasedNatTrans {ğ’³ : BasedCategory.{vâ‚‚, uâ‚‚} ğ’®} {ğ’´ : BasedCategory.{vâ‚ƒ, uâ‚ƒ} ğ’®}\n    (F G : ğ’³ â¥¤áµ‡ ğ’´) extends CategoryTheory.NatTrans F.toFunctor G.toFunctor where\n  isHomLift' : âˆ€ (a : ğ’³.obj), IsHomLift ğ’´.p (ğŸ™ (ğ’³.p.obj a)) (toNatTrans.app a) := by aesop_cat\n\n"}
{"name":"CategoryTheory.BasedNatTrans.isHomLift'","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF G : CategoryTheory.BasedFunctor ğ’³ ğ’´\nself : CategoryTheory.BasedNatTrans F G\na : ğ’³.obj\nâŠ¢ ğ’´.p.IsHomLift (CategoryTheory.CategoryStruct.id (ğ’³.p.obj a)) (self.app a)","decl":"/-- A `BasedNatTrans` between two `BasedFunctor`s is a natural transformation `Î±` between the\nunderlying functors, such that for all `a : ğ’³`, `Î±.app a` lifts `ğŸ™ S` whenever `ğ’³.p.obj a = S`. -/\nstructure BasedNatTrans {ğ’³ : BasedCategory.{vâ‚‚, uâ‚‚} ğ’®} {ğ’´ : BasedCategory.{vâ‚ƒ, uâ‚ƒ} ğ’®}\n    (F G : ğ’³ â¥¤áµ‡ ğ’´) extends CategoryTheory.NatTrans F.toFunctor G.toFunctor where\n  isHomLift' : âˆ€ (a : ğ’³.obj), IsHomLift ğ’´.p (ğŸ™ (ğ’³.p.obj a)) (toNatTrans.app a) := by aesop_cat\n\n"}
{"name":"CategoryTheory.BasedNatTrans.mk.inj","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF G : CategoryTheory.BasedFunctor ğ’³ ğ’´\ntoNatTransâœ : CategoryTheory.NatTrans F.toFunctor G.toFunctor\nisHomLift'âœ : autoParam (âˆ€ (a : ğ’³.obj), ğ’´.p.IsHomLift (CategoryTheory.CategoryStruct.id (ğ’³.p.obj a)) (toNatTransâœ.app a)) _autoâœ\ntoNatTrans : CategoryTheory.NatTrans F.toFunctor G.toFunctor\nisHomLift' : autoParam (âˆ€ (a : ğ’³.obj), ğ’´.p.IsHomLift (CategoryTheory.CategoryStruct.id (ğ’³.p.obj a)) (toNatTrans.app a)) _autoâœ\nxâœ : Eq { toNatTrans := toNatTransâœ, isHomLift' := isHomLift'âœ } { toNatTrans := toNatTrans, isHomLift' := isHomLift' }\nâŠ¢ Eq toNatTransâœ toNatTrans","decl":"/-- A `BasedNatTrans` between two `BasedFunctor`s is a natural transformation `Î±` between the\nunderlying functors, such that for all `a : ğ’³`, `Î±.app a` lifts `ğŸ™ S` whenever `ğ’³.p.obj a = S`. -/\nstructure BasedNatTrans {ğ’³ : BasedCategory.{vâ‚‚, uâ‚‚} ğ’®} {ğ’´ : BasedCategory.{vâ‚ƒ, uâ‚ƒ} ğ’®}\n    (F G : ğ’³ â¥¤áµ‡ ğ’´) extends CategoryTheory.NatTrans F.toFunctor G.toFunctor where\n  isHomLift' : âˆ€ (a : ğ’³.obj), IsHomLift ğ’´.p (ğŸ™ (ğ’³.p.obj a)) (toNatTrans.app a) := by aesop_cat\n\n"}
{"name":"CategoryTheory.BasedNatTrans.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF G : CategoryTheory.BasedFunctor ğ’³ ğ’´\ninstâœ : SizeOf ğ’®\ntoNatTrans : CategoryTheory.NatTrans F.toFunctor G.toFunctor\nisHomLift' : autoParam (âˆ€ (a : ğ’³.obj), ğ’´.p.IsHomLift (CategoryTheory.CategoryStruct.id (ğ’³.p.obj a)) (toNatTrans.app a)) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { toNatTrans := toNatTrans, isHomLift' := isHomLift' }) (HAdd.hAdd 1 (SizeOf.sizeOf toNatTrans))","decl":"/-- A `BasedNatTrans` between two `BasedFunctor`s is a natural transformation `Î±` between the\nunderlying functors, such that for all `a : ğ’³`, `Î±.app a` lifts `ğŸ™ S` whenever `ğ’³.p.obj a = S`. -/\nstructure BasedNatTrans {ğ’³ : BasedCategory.{vâ‚‚, uâ‚‚} ğ’®} {ğ’´ : BasedCategory.{vâ‚ƒ, uâ‚ƒ} ğ’®}\n    (F G : ğ’³ â¥¤áµ‡ ğ’´) extends CategoryTheory.NatTrans F.toFunctor G.toFunctor where\n  isHomLift' : âˆ€ (a : ğ’³.obj), IsHomLift ğ’´.p (ğŸ™ (ğ’³.p.obj a)) (toNatTrans.app a) := by aesop_cat\n\n"}
{"name":"CategoryTheory.BasedNatTrans.ext","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF G : CategoryTheory.BasedFunctor ğ’³ ğ’´\nÎ± Î² : CategoryTheory.BasedNatTrans F G\nh : Eq Î±.toNatTrans Î².toNatTrans\nâŠ¢ Eq Î± Î²","decl":"@[ext]\nlemma ext (Î² : BasedNatTrans F G) (h : Î±.toNatTrans = Î².toNatTrans) : Î± = Î² := by\n  cases Î±; subst h; rfl\n\n"}
{"name":"CategoryTheory.BasedNatTrans.ext_iff","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF G : CategoryTheory.BasedFunctor ğ’³ ğ’´\nÎ± Î² : CategoryTheory.BasedNatTrans F G\nâŠ¢ Iff (Eq Î± Î²) (Eq Î±.toNatTrans Î².toNatTrans)","decl":"@[ext]\nlemma ext (Î² : BasedNatTrans F G) (h : Î±.toNatTrans = Î².toNatTrans) : Î± = Î² := by\n  cases Î±; subst h; rfl\n\n"}
{"name":"CategoryTheory.BasedNatTrans.app_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF G : CategoryTheory.BasedFunctor ğ’³ ğ’´\nÎ± : CategoryTheory.BasedNatTrans F G\na : ğ’³.obj\nâŠ¢ ğ’´.p.IsHomLift (CategoryTheory.CategoryStruct.id (ğ’³.p.obj a)) (Î±.app a)","decl":"instance app_isHomLift (a : ğ’³.obj) : IsHomLift ğ’´.p (ğŸ™ (ğ’³.p.obj a)) (Î±.toNatTrans.app a) :=\n  Î±.isHomLift' a\n\n"}
{"name":"CategoryTheory.BasedNatTrans.isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF G : CategoryTheory.BasedFunctor ğ’³ ğ’´\nÎ± : CategoryTheory.BasedNatTrans F G\na : ğ’³.obj\nS : ğ’®\nha : Eq (ğ’³.p.obj a) S\nâŠ¢ ğ’´.p.IsHomLift (CategoryTheory.CategoryStruct.id S) (Î±.app a)","decl":"lemma isHomLift {a : ğ’³.obj} {S : ğ’®} (ha : ğ’³.p.obj a = S) :\n    IsHomLift ğ’´.p (ğŸ™ S) (Î±.toNatTrans.app a) := by\n  subst ha; infer_instance\n\n"}
{"name":"CategoryTheory.BasedNatTrans.id_toNatTrans","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF : CategoryTheory.BasedFunctor ğ’³ ğ’´\nâŠ¢ Eq (CategoryTheory.BasedNatTrans.id F).toNatTrans (CategoryTheory.NatTrans.id F.toFunctor)","decl":"/-- The identity natural transformation is a `BasedNatTrans`. -/\n@[simps]\ndef id (F : ğ’³ â¥¤áµ‡ ğ’´) : BasedNatTrans F F where\n  toNatTrans := CategoryTheory.NatTrans.id F.toFunctor\n  isHomLift' := fun a â†¦ of_fac ğ’´.p _ _ (w_obj F a) (w_obj F a) (by simp)\n\n"}
{"name":"CategoryTheory.BasedNatTrans.comp_toNatTrans","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF G H : CategoryTheory.BasedFunctor ğ’³ ğ’´\nÎ± : CategoryTheory.BasedNatTrans F G\nÎ² : CategoryTheory.BasedNatTrans G H\nâŠ¢ Eq (Î±.comp Î²).toNatTrans (Î±.vcomp Î².toNatTrans)","decl":"/-- Composition of `BasedNatTrans`, given by composition of the underlying natural\ntransformations. -/\n@[simps]\ndef comp {F G H : ğ’³ â¥¤áµ‡ ğ’´} (Î± : BasedNatTrans F G) (Î² : BasedNatTrans G H) : BasedNatTrans F H where\n  toNatTrans := CategoryTheory.NatTrans.vcomp Î±.toNatTrans Î².toNatTrans\n  isHomLift' := by\n    intro a\n    rw [CategoryTheory.NatTrans.vcomp_app]\n    infer_instance\n\n"}
{"name":"CategoryTheory.BasedNatTrans.homCategory_comp","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nXâœ Yâœ Zâœ : CategoryTheory.BasedFunctor ğ’³ ğ’´\nÎ± : CategoryTheory.BasedNatTrans Xâœ Yâœ\nÎ² : CategoryTheory.BasedNatTrans Yâœ Zâœ\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp Î± Î²) (Î±.comp Î²)","decl":"@[simps]\ninstance homCategory (ğ’³ : BasedCategory.{vâ‚‚, uâ‚‚} ğ’®) (ğ’´ : BasedCategory.{vâ‚ƒ, uâ‚ƒ} ğ’®) :\n    Category (ğ’³ â¥¤áµ‡ ğ’´) where\n  Hom := BasedNatTrans\n  id := BasedNatTrans.id\n  comp := BasedNatTrans.comp\n\n"}
{"name":"CategoryTheory.BasedNatTrans.homCategory_id","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF : CategoryTheory.BasedFunctor ğ’³ ğ’´\nâŠ¢ Eq (CategoryTheory.CategoryStruct.id F) (CategoryTheory.BasedNatTrans.id F)","decl":"@[simps]\ninstance homCategory (ğ’³ : BasedCategory.{vâ‚‚, uâ‚‚} ğ’®) (ğ’´ : BasedCategory.{vâ‚ƒ, uâ‚ƒ} ğ’®) :\n    Category (ğ’³ â¥¤áµ‡ ğ’´) where\n  Hom := BasedNatTrans\n  id := BasedNatTrans.id\n  comp := BasedNatTrans.comp\n\n"}
{"name":"CategoryTheory.BasedNatTrans.homCategory.ext","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF G : CategoryTheory.BasedFunctor ğ’³ ğ’´\nÎ± Î² : Quiver.Hom F G\nh : Eq Î±.toNatTrans Î².toNatTrans\nâŠ¢ Eq Î± Î²","decl":"@[ext]\nlemma homCategory.ext {F G : ğ’³ â¥¤áµ‡ ğ’´} (Î± Î² : F âŸ¶ G) (h : Î±.toNatTrans = Î².toNatTrans) : Î± = Î² :=\n  BasedNatTrans.ext Î± Î² h\n\n"}
{"name":"CategoryTheory.BasedNatTrans.homCategory.ext_iff","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF G : CategoryTheory.BasedFunctor ğ’³ ğ’´\nÎ± Î² : Quiver.Hom F G\nâŠ¢ Iff (Eq Î± Î²) (Eq Î±.toNatTrans Î².toNatTrans)","decl":"@[ext]\nlemma homCategory.ext {F G : ğ’³ â¥¤áµ‡ ğ’´} (Î± Î² : F âŸ¶ G) (h : Î±.toNatTrans = Î².toNatTrans) : Î± = Î² :=\n  BasedNatTrans.ext Î± Î² h\n\n"}
{"name":"CategoryTheory.BasedNatTrans.forgetful_obj","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF : CategoryTheory.BasedFunctor ğ’³ ğ’´\nâŠ¢ Eq ((CategoryTheory.BasedNatTrans.forgetful ğ’³ ğ’´).obj F) F.toFunctor","decl":"/-- The forgetful functor from the category of based functors `ğ’³ â¥¤áµ‡ ğ’´` to the category of\nfunctors of underlying categories, `ğ’³.obj â¥¤ ğ’´.obj`. -/\n@[simps]\ndef forgetful (ğ’³ : BasedCategory.{vâ‚‚, uâ‚‚} ğ’®) (ğ’´ : BasedCategory.{vâ‚ƒ, uâ‚ƒ} ğ’®) :\n    (ğ’³ â¥¤áµ‡ ğ’´) â¥¤ (ğ’³.obj â¥¤ ğ’´.obj) where\n  obj := fun F â†¦ F.toFunctor\n  map := fun Î± â†¦ Î±.toNatTrans\n\n"}
{"name":"CategoryTheory.BasedNatTrans.forgetful_map","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nXâœ Yâœ : CategoryTheory.BasedFunctor ğ’³ ğ’´\nÎ± : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq ((CategoryTheory.BasedNatTrans.forgetful ğ’³ ğ’´).map Î±) Î±.toNatTrans","decl":"/-- The forgetful functor from the category of based functors `ğ’³ â¥¤áµ‡ ğ’´` to the category of\nfunctors of underlying categories, `ğ’³.obj â¥¤ ğ’´.obj`. -/\n@[simps]\ndef forgetful (ğ’³ : BasedCategory.{vâ‚‚, uâ‚‚} ğ’®) (ğ’´ : BasedCategory.{vâ‚ƒ, uâ‚ƒ} ğ’®) :\n    (ğ’³ â¥¤áµ‡ ğ’´) â¥¤ (ğ’³.obj â¥¤ ğ’´.obj) where\n  obj := fun F â†¦ F.toFunctor\n  map := fun Î± â†¦ Î±.toNatTrans\n\n"}
{"name":"CategoryTheory.BasedNatTrans.instReflectsIsomorphismsBasedFunctorFunctorObjForgetful","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nâŠ¢ (CategoryTheory.BasedNatTrans.forgetful ğ’³ ğ’´).ReflectsIsomorphisms","decl":"instance : (forgetful ğ’³ ğ’´).ReflectsIsomorphisms where\n  reflects {F G} Î± _ := by\n    constructor\n    use {\n      toNatTrans := inv ((forgetful ğ’³ ğ’´).map Î±)\n      isHomLift' := fun a â†¦ by simp [lift_id_inv_isIso] }\n    aesop\n\n"}
{"name":"CategoryTheory.BasedNatTrans.instIsIsoFunctorObjOfBasedFunctor","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF G : CategoryTheory.BasedFunctor ğ’³ ğ’´\nÎ± : Quiver.Hom F G\ninstâœ : CategoryTheory.IsIso Î±\nâŠ¢ CategoryTheory.IsIso Î±.toNatTrans","decl":"instance {F G : ğ’³ â¥¤áµ‡ ğ’´} (Î± : F âŸ¶ G) [IsIso Î±] : IsIso (X := F.toFunctor) Î±.toNatTrans := by\n  rw [â† forgetful_map]; infer_instance\n\n"}
{"name":"CategoryTheory.BasedNatIso.id_hom","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF : CategoryTheory.BasedFunctor ğ’³ ğ’´\nâŠ¢ Eq (CategoryTheory.BasedNatIso.id F).hom (CategoryTheory.CategoryStruct.id F)","decl":"/-- The identity natural transformation is a based natural isomorphism. -/\n@[simps]\ndef id (F : ğ’³ â¥¤áµ‡ ğ’´) : F â‰… F where\n  hom := ğŸ™ F\n  inv := ğŸ™ F\n\n"}
{"name":"CategoryTheory.BasedNatIso.id_inv","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF : CategoryTheory.BasedFunctor ğ’³ ğ’´\nâŠ¢ Eq (CategoryTheory.BasedNatIso.id F).inv (CategoryTheory.CategoryStruct.id F)","decl":"/-- The identity natural transformation is a based natural isomorphism. -/\n@[simps]\ndef id (F : ğ’³ â¥¤áµ‡ ğ’´) : F â‰… F where\n  hom := ğŸ™ F\n  inv := ğŸ™ F\n\n"}
{"name":"CategoryTheory.BasedNatIso.isIso_of_toNatTrans_isIso","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nF G : CategoryTheory.BasedFunctor ğ’³ ğ’´\nÎ± : Quiver.Hom F G\ninstâœ : CategoryTheory.IsIso Î±.toNatTrans\nâŠ¢ CategoryTheory.IsIso Î±","decl":"lemma isIso_of_toNatTrans_isIso (Î± : F âŸ¶ G) [IsIso (X := F.toFunctor) Î±.toNatTrans] : IsIso Î± :=\n  have : IsIso ((forgetful ğ’³ ğ’´).map Î±) := by simp_all\n  Functor.ReflectsIsomorphisms.reflects (forgetful ğ’³ ğ’´) Î±\n\n"}
{"name":"CategoryTheory.BasedCategory.whiskerLeft_toNatTrans","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nğ’µ : CategoryTheory.BasedCategory ğ’®\nF : CategoryTheory.BasedFunctor ğ’³ ğ’´\nG H : CategoryTheory.BasedFunctor ğ’´ ğ’µ\nÎ± : Quiver.Hom G H\nâŠ¢ Eq (CategoryTheory.BasedCategory.whiskerLeft F Î±).toNatTrans (CategoryTheory.whiskerLeft F.toFunctor Î±.toNatTrans)","decl":"/-- Left-whiskering in the bicategory `BasedCategory` is given by whiskering the underlying functors\nand natural transformations. -/\n@[simps]\ndef whiskerLeft {ğ’µ : BasedCategory.{vâ‚„, uâ‚„} ğ’®} (F : ğ’³ â¥¤áµ‡ ğ’´) {G H : ğ’´ â¥¤áµ‡ ğ’µ} (Î± : G âŸ¶ H) :\n    F â‹™ G âŸ¶ F â‹™ H where\n  toNatTrans := CategoryTheory.whiskerLeft F.toFunctor Î±.toNatTrans\n  isHomLift' := fun a â†¦ Î±.isHomLift (F.w_obj a)\n\n"}
{"name":"CategoryTheory.BasedCategory.whiskerRight_toNatTrans","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nğ’´ : CategoryTheory.BasedCategory ğ’®\nğ’µ : CategoryTheory.BasedCategory ğ’®\nF G : CategoryTheory.BasedFunctor ğ’³ ğ’´\nÎ± : Quiver.Hom F G\nH : CategoryTheory.BasedFunctor ğ’´ ğ’µ\nâŠ¢ Eq (CategoryTheory.BasedCategory.whiskerRight Î± H).toNatTrans (CategoryTheory.whiskerRight Î±.toNatTrans H.toFunctor)","decl":"/-- Right-whiskering in the bicategory `BasedCategory` is given by whiskering the underlying\nfunctors and natural transformations. -/\n@[simps]\ndef whiskerRight {ğ’µ : BasedCategory.{vâ‚„, uâ‚„} ğ’®} {F G : ğ’³ â¥¤áµ‡ ğ’´} (Î± : F âŸ¶ G) (H : ğ’´ â¥¤áµ‡ ğ’µ) :\n    F â‹™ H âŸ¶ G â‹™ H where\n  toNatTrans := CategoryTheory.whiskerRight Î±.toNatTrans H.toFunctor\n  isHomLift' := fun _ â†¦ BasedFunctor.preserves_isHomLift _ _ _\n\n"}
{"name":"CategoryTheory.BasedCategory.instCategory_id","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nğ’³ : CategoryTheory.BasedCategory ğ’®\nâŠ¢ Eq (CategoryTheory.CategoryStruct.id ğ’³) (CategoryTheory.BasedFunctor.id ğ’³)","decl":"/-- The category of based categories. -/\n@[simps]\ninstance : Category (BasedCategory.{vâ‚‚, uâ‚‚} ğ’®) where\n  Hom := BasedFunctor\n  id := id\n  comp := comp\n\n"}
{"name":"CategoryTheory.BasedCategory.instCategory_comp","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nXâœ Yâœ Zâœ : CategoryTheory.BasedCategory ğ’®\nF : CategoryTheory.BasedFunctor Xâœ Yâœ\nG : CategoryTheory.BasedFunctor Yâœ Zâœ\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp F G) (F.comp G)","decl":"/-- The category of based categories. -/\n@[simps]\ninstance : Category (BasedCategory.{vâ‚‚, uâ‚‚} ğ’®) where\n  Hom := BasedFunctor\n  id := id\n  comp := comp\n\n"}
{"name":"CategoryTheory.BasedCategory.instStrict","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"ğ’® : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} ğ’®\nâŠ¢ CategoryTheory.Bicategory.Strict (CategoryTheory.BasedCategory ğ’®)","decl":"/-- The bicategory structure on `BasedCategory.{vâ‚‚, uâ‚‚} ğ’®` is strict. -/\ninstance : Bicategory.Strict (BasedCategory.{vâ‚‚, uâ‚‚} ğ’®) where\n\n"}
