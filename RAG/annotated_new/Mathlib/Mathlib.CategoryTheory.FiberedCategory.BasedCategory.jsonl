{"name":"CategoryTheory.BasedCategory.mk.injEq","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\nobj✝ : Type u₂\ncategory✝ : autoParam (CategoryTheory.Category.{v₂, u₂} obj✝) _auto✝\np✝ : CategoryTheory.Functor obj✝ 𝒮\nobj : Type u₂\ncategory : autoParam (CategoryTheory.Category.{v₂, u₂} obj) _auto✝\np : CategoryTheory.Functor obj 𝒮\n⊢ Eq (Eq { obj := obj✝, category := category✝, p := p✝ } { obj := obj, category := category, p := p }) (And (Eq obj✝ obj) (And (HEq category✝ category) (HEq p✝ p)))","decl":"/-- A based category over `𝒮` is a category `𝒳` together with a functor `p : 𝒳 ⥤ 𝒮`. -/\n@[nolint checkUnivs]\nstructure BasedCategory (𝒮 : Type u₁) [Category.{v₁} 𝒮] where\n  /-- The type of objects in a `BasedCategory`-/\n  obj : Type u₂\n  /-- The underlying category of a `BasedCategory`. -/\n  category : Category.{v₂} obj := by infer_instance\n  /-- The functor to the base. -/\n  p : obj ⥤ 𝒮\n\n"}
{"name":"CategoryTheory.BasedCategory.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\ninst✝ : SizeOf 𝒮\nobj : Type u₂\ncategory : autoParam (CategoryTheory.Category.{v₂, u₂} obj) _auto✝\np : CategoryTheory.Functor obj 𝒮\n⊢ Eq (SizeOf.sizeOf { obj := obj, category := category, p := p }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf obj)) (SizeOf.sizeOf category)) (SizeOf.sizeOf p))","decl":"/-- A based category over `𝒮` is a category `𝒳` together with a functor `p : 𝒳 ⥤ 𝒮`. -/\n@[nolint checkUnivs]\nstructure BasedCategory (𝒮 : Type u₁) [Category.{v₁} 𝒮] where\n  /-- The type of objects in a `BasedCategory`-/\n  obj : Type u₂\n  /-- The underlying category of a `BasedCategory`. -/\n  category : Category.{v₂} obj := by infer_instance\n  /-- The functor to the base. -/\n  p : obj ⥤ 𝒮\n\n"}
{"name":"CategoryTheory.BasedCategory.mk.inj","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\nobj✝ : Type u₂\ncategory✝ : autoParam (CategoryTheory.Category.{v₂, u₂} obj✝) _auto✝\np✝ : CategoryTheory.Functor obj✝ 𝒮\nobj : Type u₂\ncategory : autoParam (CategoryTheory.Category.{v₂, u₂} obj) _auto✝\np : CategoryTheory.Functor obj 𝒮\nx✝ : Eq { obj := obj✝, category := category✝, p := p✝ } { obj := obj, category := category, p := p }\n⊢ And (Eq obj✝ obj) (And (HEq category✝ category) (HEq p✝ p))","decl":"/-- A based category over `𝒮` is a category `𝒳` together with a functor `p : 𝒳 ⥤ 𝒮`. -/\n@[nolint checkUnivs]\nstructure BasedCategory (𝒮 : Type u₁) [Category.{v₁} 𝒮] where\n  /-- The type of objects in a `BasedCategory`-/\n  obj : Type u₂\n  /-- The underlying category of a `BasedCategory`. -/\n  category : Category.{v₂} obj := by infer_instance\n  /-- The functor to the base. -/\n  p : obj ⥤ 𝒮\n\n"}
{"name":"CategoryTheory.BasedFunctor.mk.injEq","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\ntoFunctor✝ : CategoryTheory.Functor 𝒳.obj 𝒴.obj\nw✝ : autoParam (Eq (toFunctor✝.comp 𝒴.p) 𝒳.p) _auto✝\ntoFunctor : CategoryTheory.Functor 𝒳.obj 𝒴.obj\nw : autoParam (Eq (toFunctor.comp 𝒴.p) 𝒳.p) _auto✝\n⊢ Eq (Eq { toFunctor := toFunctor✝, w := w✝ } { toFunctor := toFunctor, w := w }) (Eq toFunctor✝ toFunctor)","decl":"/-- A functor between based categories is a functor between the underlying categories that commutes\nwith the projections. -/\nstructure BasedFunctor (𝒳 : BasedCategory.{v₂, u₂} 𝒮) (𝒴 : BasedCategory.{v₃, u₃} 𝒮) extends\n    𝒳.obj ⥤ 𝒴.obj where\n  w : toFunctor ⋙ 𝒴.p = 𝒳.p := by aesop_cat\n\n"}
{"name":"CategoryTheory.BasedFunctor.w","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nself : CategoryTheory.BasedFunctor 𝒳 𝒴\n⊢ Eq (self.comp 𝒴.p) 𝒳.p","decl":"/-- A functor between based categories is a functor between the underlying categories that commutes\nwith the projections. -/\nstructure BasedFunctor (𝒳 : BasedCategory.{v₂, u₂} 𝒮) (𝒴 : BasedCategory.{v₃, u₃} 𝒮) extends\n    𝒳.obj ⥤ 𝒴.obj where\n  w : toFunctor ⋙ 𝒴.p = 𝒳.p := by aesop_cat\n\n"}
{"name":"CategoryTheory.BasedFunctor.mk.inj","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\ntoFunctor✝ : CategoryTheory.Functor 𝒳.obj 𝒴.obj\nw✝ : autoParam (Eq (toFunctor✝.comp 𝒴.p) 𝒳.p) _auto✝\ntoFunctor : CategoryTheory.Functor 𝒳.obj 𝒴.obj\nw : autoParam (Eq (toFunctor.comp 𝒴.p) 𝒳.p) _auto✝\nx✝ : Eq { toFunctor := toFunctor✝, w := w✝ } { toFunctor := toFunctor, w := w }\n⊢ Eq toFunctor✝ toFunctor","decl":"/-- A functor between based categories is a functor between the underlying categories that commutes\nwith the projections. -/\nstructure BasedFunctor (𝒳 : BasedCategory.{v₂, u₂} 𝒮) (𝒴 : BasedCategory.{v₃, u₃} 𝒮) extends\n    𝒳.obj ⥤ 𝒴.obj where\n  w : toFunctor ⋙ 𝒴.p = 𝒳.p := by aesop_cat\n\n"}
{"name":"CategoryTheory.BasedFunctor.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\ninst✝ : SizeOf 𝒮\ntoFunctor : CategoryTheory.Functor 𝒳.obj 𝒴.obj\nw : autoParam (Eq (toFunctor.comp 𝒴.p) 𝒳.p) _auto✝\n⊢ Eq (SizeOf.sizeOf { toFunctor := toFunctor, w := w }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toFunctor)) (SizeOf.sizeOf w))","decl":"/-- A functor between based categories is a functor between the underlying categories that commutes\nwith the projections. -/\nstructure BasedFunctor (𝒳 : BasedCategory.{v₂, u₂} 𝒮) (𝒴 : BasedCategory.{v₃, u₃} 𝒮) extends\n    𝒳.obj ⥤ 𝒴.obj where\n  w : toFunctor ⋙ 𝒴.p = 𝒳.p := by aesop_cat\n\n"}
{"name":"CategoryTheory.BasedFunctor.id_toFunctor","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n⊢ Eq (CategoryTheory.BasedFunctor.id 𝒳).toFunctor (CategoryTheory.Functor.id 𝒳.obj)","decl":"/-- The identity based functor. -/\n@[simps]\ndef id (𝒳 : BasedCategory.{v₂, u₂} 𝒮) : 𝒳 ⥤ᵇ 𝒳 where\n  toFunctor := 𝟭 𝒳.obj\n\n"}
{"name":"CategoryTheory.BasedFunctor.comp_toFunctor","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\n𝒵 : CategoryTheory.BasedCategory 𝒮\nF : CategoryTheory.BasedFunctor 𝒳 𝒴\nG : CategoryTheory.BasedFunctor 𝒴 𝒵\n⊢ Eq (F.comp G).toFunctor (F.comp G.toFunctor)","decl":"/-- The composition of two based functors. -/\n@[simps]\ndef comp {𝒵 : BasedCategory.{v₄, u₄} 𝒮} (F : 𝒳 ⥤ᵇ 𝒴) (G : 𝒴 ⥤ᵇ 𝒵) : 𝒳 ⥤ᵇ 𝒵 where\n  toFunctor := F.toFunctor ⋙ G.toFunctor\n  w := by rw [Functor.assoc, G.w, F.w]\n\n"}
{"name":"CategoryTheory.BasedFunctor.comp_id","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF : CategoryTheory.BasedFunctor 𝒳 𝒴\n⊢ Eq (F.comp (CategoryTheory.BasedFunctor.id 𝒴)) F","decl":"@[simp]\nlemma comp_id (F : 𝒳 ⥤ᵇ 𝒴) :  F ⋙ 𝟭 𝒴 = F :=\n  rfl\n\n"}
{"name":"CategoryTheory.BasedFunctor.id_comp","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF : CategoryTheory.BasedFunctor 𝒳 𝒴\n⊢ Eq ((CategoryTheory.BasedFunctor.id 𝒳).comp F) F","decl":"@[simp]\nlemma id_comp (F : 𝒳 ⥤ᵇ 𝒴) : 𝟭 𝒳 ⋙ F = F :=\n  rfl\n\n"}
{"name":"CategoryTheory.BasedFunctor.comp_assoc","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\n𝒵 : CategoryTheory.BasedCategory 𝒮\n𝒜 : CategoryTheory.BasedCategory 𝒮\nF : CategoryTheory.BasedFunctor 𝒳 𝒴\nG : CategoryTheory.BasedFunctor 𝒴 𝒵\nH : CategoryTheory.BasedFunctor 𝒵 𝒜\n⊢ Eq ((F.comp G).comp H) (F.comp (G.comp H))","decl":"@[simp]\nlemma comp_assoc {𝒵 : BasedCategory.{v₄, u₄} 𝒮} {𝒜 : BasedCategory.{v₅, u₅} 𝒮} (F : 𝒳 ⥤ᵇ 𝒴)\n    (G : 𝒴 ⥤ᵇ 𝒵) (H : 𝒵 ⥤ᵇ 𝒜) : (F ⋙ G) ⋙ H = F ⋙ (G ⋙ H) :=\n  rfl\n\n"}
{"name":"CategoryTheory.BasedFunctor.w_obj","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF : CategoryTheory.BasedFunctor 𝒳 𝒴\na : 𝒳.obj\n⊢ Eq (𝒴.p.obj (F.obj a)) (𝒳.p.obj a)","decl":"@[simp]\nlemma w_obj (F : 𝒳 ⥤ᵇ 𝒴) (a : 𝒳.obj) : 𝒴.p.obj (F.obj a) = 𝒳.p.obj a := by\n  rw [← Functor.comp_obj, F.w]\n\n"}
{"name":"CategoryTheory.BasedFunctor.instIsHomLiftObjPIdObj","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF : CategoryTheory.BasedFunctor 𝒳 𝒴\na : 𝒳.obj\n⊢ 𝒴.p.IsHomLift (CategoryTheory.CategoryStruct.id (𝒳.p.obj a)) (CategoryTheory.CategoryStruct.id (F.obj a))","decl":"instance (F : 𝒳 ⥤ᵇ 𝒴) (a : 𝒳.obj) : IsHomLift 𝒴.p (𝟙 (𝒳.p.obj a)) (𝟙 (F.obj a)) :=\n  IsHomLift.id (w_obj F a)\n\n"}
{"name":"CategoryTheory.BasedFunctor.preserves_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF : CategoryTheory.BasedFunctor 𝒳 𝒴\nR S : 𝒮\na b : 𝒳.obj\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝ : 𝒳.p.IsHomLift f φ\n⊢ 𝒴.p.IsHomLift f (F.map φ)","decl":"/-- For a based functor `F : 𝒳 ⟶ 𝒴`, then whenever an arrow `φ` in `𝒳` lifts some `f` in `𝒮`,\nthen `F(φ)` also lifts `f`. -/\ninstance preserves_isHomLift [IsHomLift 𝒳.p f φ] : IsHomLift 𝒴.p f (F.map φ) := by\n  apply of_fac 𝒴.p f (F.map φ) (Eq.trans (F.w_obj a) (domain_eq 𝒳.p f φ))\n    (Eq.trans (F.w_obj b) (codomain_eq 𝒳.p f φ))\n  rw [← Functor.comp_map, congr_hom F.w]\n  simpa using (fac 𝒳.p f φ)\n\n"}
{"name":"CategoryTheory.BasedFunctor.isHomLift_map","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF : CategoryTheory.BasedFunctor 𝒳 𝒴\nR S : 𝒮\na b : 𝒳.obj\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\ninst✝ : 𝒴.p.IsHomLift f (F.map φ)\n⊢ 𝒳.p.IsHomLift f φ","decl":"/-- For a based functor `F : 𝒳 ⟶ 𝒴`, and an arrow `φ` in `𝒳`, then `φ` lifts an arrow `f` in `𝒮`\nif `F(φ)` does. -/\nlemma isHomLift_map [IsHomLift 𝒴.p f (F.map φ)] : IsHomLift 𝒳.p f φ := by\n  apply of_fac 𝒳.p f φ  (F.w_obj a ▸ domain_eq 𝒴.p f (F.map φ))\n    (F.w_obj b ▸ codomain_eq 𝒴.p f (F.map φ))\n  simp [congr_hom F.w.symm, fac 𝒴.p f (F.map φ)]\n\n"}
{"name":"CategoryTheory.BasedFunctor.isHomLift_iff","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF : CategoryTheory.BasedFunctor 𝒳 𝒴\nR S : 𝒮\na b : 𝒳.obj\nf : Quiver.Hom R S\nφ : Quiver.Hom a b\n⊢ Iff (𝒴.p.IsHomLift f (F.map φ)) (𝒳.p.IsHomLift f φ)","decl":"lemma isHomLift_iff : IsHomLift 𝒴.p f (F.map φ) ↔ IsHomLift 𝒳.p f φ :=\n  ⟨fun _ ↦ isHomLift_map F f φ, fun _ ↦ preserves_isHomLift F f φ⟩\n\n"}
{"name":"CategoryTheory.BasedNatTrans.mk.injEq","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF G : CategoryTheory.BasedFunctor 𝒳 𝒴\ntoNatTrans✝ : CategoryTheory.NatTrans F.toFunctor G.toFunctor\nisHomLift'✝ : autoParam (∀ (a : 𝒳.obj), 𝒴.p.IsHomLift (CategoryTheory.CategoryStruct.id (𝒳.p.obj a)) (toNatTrans✝.app a)) _auto✝\ntoNatTrans : CategoryTheory.NatTrans F.toFunctor G.toFunctor\nisHomLift' : autoParam (∀ (a : 𝒳.obj), 𝒴.p.IsHomLift (CategoryTheory.CategoryStruct.id (𝒳.p.obj a)) (toNatTrans.app a)) _auto✝\n⊢ Eq (Eq { toNatTrans := toNatTrans✝, isHomLift' := isHomLift'✝ } { toNatTrans := toNatTrans, isHomLift' := isHomLift' }) (Eq toNatTrans✝ toNatTrans)","decl":"/-- A `BasedNatTrans` between two `BasedFunctor`s is a natural transformation `α` between the\nunderlying functors, such that for all `a : 𝒳`, `α.app a` lifts `𝟙 S` whenever `𝒳.p.obj a = S`. -/\nstructure BasedNatTrans {𝒳 : BasedCategory.{v₂, u₂} 𝒮} {𝒴 : BasedCategory.{v₃, u₃} 𝒮}\n    (F G : 𝒳 ⥤ᵇ 𝒴) extends CategoryTheory.NatTrans F.toFunctor G.toFunctor where\n  isHomLift' : ∀ (a : 𝒳.obj), IsHomLift 𝒴.p (𝟙 (𝒳.p.obj a)) (toNatTrans.app a) := by aesop_cat\n\n"}
{"name":"CategoryTheory.BasedNatTrans.isHomLift'","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF G : CategoryTheory.BasedFunctor 𝒳 𝒴\nself : CategoryTheory.BasedNatTrans F G\na : 𝒳.obj\n⊢ 𝒴.p.IsHomLift (CategoryTheory.CategoryStruct.id (𝒳.p.obj a)) (self.app a)","decl":"/-- A `BasedNatTrans` between two `BasedFunctor`s is a natural transformation `α` between the\nunderlying functors, such that for all `a : 𝒳`, `α.app a` lifts `𝟙 S` whenever `𝒳.p.obj a = S`. -/\nstructure BasedNatTrans {𝒳 : BasedCategory.{v₂, u₂} 𝒮} {𝒴 : BasedCategory.{v₃, u₃} 𝒮}\n    (F G : 𝒳 ⥤ᵇ 𝒴) extends CategoryTheory.NatTrans F.toFunctor G.toFunctor where\n  isHomLift' : ∀ (a : 𝒳.obj), IsHomLift 𝒴.p (𝟙 (𝒳.p.obj a)) (toNatTrans.app a) := by aesop_cat\n\n"}
{"name":"CategoryTheory.BasedNatTrans.mk.inj","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF G : CategoryTheory.BasedFunctor 𝒳 𝒴\ntoNatTrans✝ : CategoryTheory.NatTrans F.toFunctor G.toFunctor\nisHomLift'✝ : autoParam (∀ (a : 𝒳.obj), 𝒴.p.IsHomLift (CategoryTheory.CategoryStruct.id (𝒳.p.obj a)) (toNatTrans✝.app a)) _auto✝\ntoNatTrans : CategoryTheory.NatTrans F.toFunctor G.toFunctor\nisHomLift' : autoParam (∀ (a : 𝒳.obj), 𝒴.p.IsHomLift (CategoryTheory.CategoryStruct.id (𝒳.p.obj a)) (toNatTrans.app a)) _auto✝\nx✝ : Eq { toNatTrans := toNatTrans✝, isHomLift' := isHomLift'✝ } { toNatTrans := toNatTrans, isHomLift' := isHomLift' }\n⊢ Eq toNatTrans✝ toNatTrans","decl":"/-- A `BasedNatTrans` between two `BasedFunctor`s is a natural transformation `α` between the\nunderlying functors, such that for all `a : 𝒳`, `α.app a` lifts `𝟙 S` whenever `𝒳.p.obj a = S`. -/\nstructure BasedNatTrans {𝒳 : BasedCategory.{v₂, u₂} 𝒮} {𝒴 : BasedCategory.{v₃, u₃} 𝒮}\n    (F G : 𝒳 ⥤ᵇ 𝒴) extends CategoryTheory.NatTrans F.toFunctor G.toFunctor where\n  isHomLift' : ∀ (a : 𝒳.obj), IsHomLift 𝒴.p (𝟙 (𝒳.p.obj a)) (toNatTrans.app a) := by aesop_cat\n\n"}
{"name":"CategoryTheory.BasedNatTrans.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF G : CategoryTheory.BasedFunctor 𝒳 𝒴\ninst✝ : SizeOf 𝒮\ntoNatTrans : CategoryTheory.NatTrans F.toFunctor G.toFunctor\nisHomLift' : autoParam (∀ (a : 𝒳.obj), 𝒴.p.IsHomLift (CategoryTheory.CategoryStruct.id (𝒳.p.obj a)) (toNatTrans.app a)) _auto✝\n⊢ Eq (SizeOf.sizeOf { toNatTrans := toNatTrans, isHomLift' := isHomLift' }) (HAdd.hAdd 1 (SizeOf.sizeOf toNatTrans))","decl":"/-- A `BasedNatTrans` between two `BasedFunctor`s is a natural transformation `α` between the\nunderlying functors, such that for all `a : 𝒳`, `α.app a` lifts `𝟙 S` whenever `𝒳.p.obj a = S`. -/\nstructure BasedNatTrans {𝒳 : BasedCategory.{v₂, u₂} 𝒮} {𝒴 : BasedCategory.{v₃, u₃} 𝒮}\n    (F G : 𝒳 ⥤ᵇ 𝒴) extends CategoryTheory.NatTrans F.toFunctor G.toFunctor where\n  isHomLift' : ∀ (a : 𝒳.obj), IsHomLift 𝒴.p (𝟙 (𝒳.p.obj a)) (toNatTrans.app a) := by aesop_cat\n\n"}
{"name":"CategoryTheory.BasedNatTrans.ext","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF G : CategoryTheory.BasedFunctor 𝒳 𝒴\nα β : CategoryTheory.BasedNatTrans F G\nh : Eq α.toNatTrans β.toNatTrans\n⊢ Eq α β","decl":"@[ext]\nlemma ext (β : BasedNatTrans F G) (h : α.toNatTrans = β.toNatTrans) : α = β := by\n  cases α; subst h; rfl\n\n"}
{"name":"CategoryTheory.BasedNatTrans.ext_iff","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF G : CategoryTheory.BasedFunctor 𝒳 𝒴\nα β : CategoryTheory.BasedNatTrans F G\n⊢ Iff (Eq α β) (Eq α.toNatTrans β.toNatTrans)","decl":"@[ext]\nlemma ext (β : BasedNatTrans F G) (h : α.toNatTrans = β.toNatTrans) : α = β := by\n  cases α; subst h; rfl\n\n"}
{"name":"CategoryTheory.BasedNatTrans.app_isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF G : CategoryTheory.BasedFunctor 𝒳 𝒴\nα : CategoryTheory.BasedNatTrans F G\na : 𝒳.obj\n⊢ 𝒴.p.IsHomLift (CategoryTheory.CategoryStruct.id (𝒳.p.obj a)) (α.app a)","decl":"instance app_isHomLift (a : 𝒳.obj) : IsHomLift 𝒴.p (𝟙 (𝒳.p.obj a)) (α.toNatTrans.app a) :=\n  α.isHomLift' a\n\n"}
{"name":"CategoryTheory.BasedNatTrans.isHomLift","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF G : CategoryTheory.BasedFunctor 𝒳 𝒴\nα : CategoryTheory.BasedNatTrans F G\na : 𝒳.obj\nS : 𝒮\nha : Eq (𝒳.p.obj a) S\n⊢ 𝒴.p.IsHomLift (CategoryTheory.CategoryStruct.id S) (α.app a)","decl":"lemma isHomLift {a : 𝒳.obj} {S : 𝒮} (ha : 𝒳.p.obj a = S) :\n    IsHomLift 𝒴.p (𝟙 S) (α.toNatTrans.app a) := by\n  subst ha; infer_instance\n\n"}
{"name":"CategoryTheory.BasedNatTrans.id_toNatTrans","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF : CategoryTheory.BasedFunctor 𝒳 𝒴\n⊢ Eq (CategoryTheory.BasedNatTrans.id F).toNatTrans (CategoryTheory.NatTrans.id F.toFunctor)","decl":"/-- The identity natural transformation is a `BasedNatTrans`. -/\n@[simps]\ndef id (F : 𝒳 ⥤ᵇ 𝒴) : BasedNatTrans F F where\n  toNatTrans := CategoryTheory.NatTrans.id F.toFunctor\n  isHomLift' := fun a ↦ of_fac 𝒴.p _ _ (w_obj F a) (w_obj F a) (by simp)\n\n"}
{"name":"CategoryTheory.BasedNatTrans.comp_toNatTrans","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF G H : CategoryTheory.BasedFunctor 𝒳 𝒴\nα : CategoryTheory.BasedNatTrans F G\nβ : CategoryTheory.BasedNatTrans G H\n⊢ Eq (α.comp β).toNatTrans (α.vcomp β.toNatTrans)","decl":"/-- Composition of `BasedNatTrans`, given by composition of the underlying natural\ntransformations. -/\n@[simps]\ndef comp {F G H : 𝒳 ⥤ᵇ 𝒴} (α : BasedNatTrans F G) (β : BasedNatTrans G H) : BasedNatTrans F H where\n  toNatTrans := CategoryTheory.NatTrans.vcomp α.toNatTrans β.toNatTrans\n  isHomLift' := by\n    intro a\n    rw [CategoryTheory.NatTrans.vcomp_app]\n    infer_instance\n\n"}
{"name":"CategoryTheory.BasedNatTrans.homCategory_comp","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nX✝ Y✝ Z✝ : CategoryTheory.BasedFunctor 𝒳 𝒴\nα : CategoryTheory.BasedNatTrans X✝ Y✝\nβ : CategoryTheory.BasedNatTrans Y✝ Z✝\n⊢ Eq (CategoryTheory.CategoryStruct.comp α β) (α.comp β)","decl":"@[simps]\ninstance homCategory (𝒳 : BasedCategory.{v₂, u₂} 𝒮) (𝒴 : BasedCategory.{v₃, u₃} 𝒮) :\n    Category (𝒳 ⥤ᵇ 𝒴) where\n  Hom := BasedNatTrans\n  id := BasedNatTrans.id\n  comp := BasedNatTrans.comp\n\n"}
{"name":"CategoryTheory.BasedNatTrans.homCategory_id","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF : CategoryTheory.BasedFunctor 𝒳 𝒴\n⊢ Eq (CategoryTheory.CategoryStruct.id F) (CategoryTheory.BasedNatTrans.id F)","decl":"@[simps]\ninstance homCategory (𝒳 : BasedCategory.{v₂, u₂} 𝒮) (𝒴 : BasedCategory.{v₃, u₃} 𝒮) :\n    Category (𝒳 ⥤ᵇ 𝒴) where\n  Hom := BasedNatTrans\n  id := BasedNatTrans.id\n  comp := BasedNatTrans.comp\n\n"}
{"name":"CategoryTheory.BasedNatTrans.homCategory.ext","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF G : CategoryTheory.BasedFunctor 𝒳 𝒴\nα β : Quiver.Hom F G\nh : Eq α.toNatTrans β.toNatTrans\n⊢ Eq α β","decl":"@[ext]\nlemma homCategory.ext {F G : 𝒳 ⥤ᵇ 𝒴} (α β : F ⟶ G) (h : α.toNatTrans = β.toNatTrans) : α = β :=\n  BasedNatTrans.ext α β h\n\n"}
{"name":"CategoryTheory.BasedNatTrans.homCategory.ext_iff","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF G : CategoryTheory.BasedFunctor 𝒳 𝒴\nα β : Quiver.Hom F G\n⊢ Iff (Eq α β) (Eq α.toNatTrans β.toNatTrans)","decl":"@[ext]\nlemma homCategory.ext {F G : 𝒳 ⥤ᵇ 𝒴} (α β : F ⟶ G) (h : α.toNatTrans = β.toNatTrans) : α = β :=\n  BasedNatTrans.ext α β h\n\n"}
{"name":"CategoryTheory.BasedNatTrans.forgetful_obj","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF : CategoryTheory.BasedFunctor 𝒳 𝒴\n⊢ Eq ((CategoryTheory.BasedNatTrans.forgetful 𝒳 𝒴).obj F) F.toFunctor","decl":"/-- The forgetful functor from the category of based functors `𝒳 ⥤ᵇ 𝒴` to the category of\nfunctors of underlying categories, `𝒳.obj ⥤ 𝒴.obj`. -/\n@[simps]\ndef forgetful (𝒳 : BasedCategory.{v₂, u₂} 𝒮) (𝒴 : BasedCategory.{v₃, u₃} 𝒮) :\n    (𝒳 ⥤ᵇ 𝒴) ⥤ (𝒳.obj ⥤ 𝒴.obj) where\n  obj := fun F ↦ F.toFunctor\n  map := fun α ↦ α.toNatTrans\n\n"}
{"name":"CategoryTheory.BasedNatTrans.forgetful_map","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nX✝ Y✝ : CategoryTheory.BasedFunctor 𝒳 𝒴\nα : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.BasedNatTrans.forgetful 𝒳 𝒴).map α) α.toNatTrans","decl":"/-- The forgetful functor from the category of based functors `𝒳 ⥤ᵇ 𝒴` to the category of\nfunctors of underlying categories, `𝒳.obj ⥤ 𝒴.obj`. -/\n@[simps]\ndef forgetful (𝒳 : BasedCategory.{v₂, u₂} 𝒮) (𝒴 : BasedCategory.{v₃, u₃} 𝒮) :\n    (𝒳 ⥤ᵇ 𝒴) ⥤ (𝒳.obj ⥤ 𝒴.obj) where\n  obj := fun F ↦ F.toFunctor\n  map := fun α ↦ α.toNatTrans\n\n"}
{"name":"CategoryTheory.BasedNatTrans.instReflectsIsomorphismsBasedFunctorFunctorObjForgetful","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\n⊢ (CategoryTheory.BasedNatTrans.forgetful 𝒳 𝒴).ReflectsIsomorphisms","decl":"instance : (forgetful 𝒳 𝒴).ReflectsIsomorphisms where\n  reflects {F G} α _ := by\n    constructor\n    use {\n      toNatTrans := inv ((forgetful 𝒳 𝒴).map α)\n      isHomLift' := fun a ↦ by simp [lift_id_inv_isIso] }\n    aesop\n\n"}
{"name":"CategoryTheory.BasedNatTrans.instIsIsoFunctorObjOfBasedFunctor","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF G : CategoryTheory.BasedFunctor 𝒳 𝒴\nα : Quiver.Hom F G\ninst✝ : CategoryTheory.IsIso α\n⊢ CategoryTheory.IsIso α.toNatTrans","decl":"instance {F G : 𝒳 ⥤ᵇ 𝒴} (α : F ⟶ G) [IsIso α] : IsIso (X := F.toFunctor) α.toNatTrans := by\n  rw [← forgetful_map]; infer_instance\n\n"}
{"name":"CategoryTheory.BasedNatIso.id_hom","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF : CategoryTheory.BasedFunctor 𝒳 𝒴\n⊢ Eq (CategoryTheory.BasedNatIso.id F).hom (CategoryTheory.CategoryStruct.id F)","decl":"/-- The identity natural transformation is a based natural isomorphism. -/\n@[simps]\ndef id (F : 𝒳 ⥤ᵇ 𝒴) : F ≅ F where\n  hom := 𝟙 F\n  inv := 𝟙 F\n\n"}
{"name":"CategoryTheory.BasedNatIso.id_inv","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF : CategoryTheory.BasedFunctor 𝒳 𝒴\n⊢ Eq (CategoryTheory.BasedNatIso.id F).inv (CategoryTheory.CategoryStruct.id F)","decl":"/-- The identity natural transformation is a based natural isomorphism. -/\n@[simps]\ndef id (F : 𝒳 ⥤ᵇ 𝒴) : F ≅ F where\n  hom := 𝟙 F\n  inv := 𝟙 F\n\n"}
{"name":"CategoryTheory.BasedNatIso.isIso_of_toNatTrans_isIso","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\nF G : CategoryTheory.BasedFunctor 𝒳 𝒴\nα : Quiver.Hom F G\ninst✝ : CategoryTheory.IsIso α.toNatTrans\n⊢ CategoryTheory.IsIso α","decl":"lemma isIso_of_toNatTrans_isIso (α : F ⟶ G) [IsIso (X := F.toFunctor) α.toNatTrans] : IsIso α :=\n  have : IsIso ((forgetful 𝒳 𝒴).map α) := by simp_all\n  Functor.ReflectsIsomorphisms.reflects (forgetful 𝒳 𝒴) α\n\n"}
{"name":"CategoryTheory.BasedCategory.whiskerLeft_toNatTrans","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\n𝒵 : CategoryTheory.BasedCategory 𝒮\nF : CategoryTheory.BasedFunctor 𝒳 𝒴\nG H : CategoryTheory.BasedFunctor 𝒴 𝒵\nα : Quiver.Hom G H\n⊢ Eq (CategoryTheory.BasedCategory.whiskerLeft F α).toNatTrans (CategoryTheory.whiskerLeft F.toFunctor α.toNatTrans)","decl":"/-- Left-whiskering in the bicategory `BasedCategory` is given by whiskering the underlying functors\nand natural transformations. -/\n@[simps]\ndef whiskerLeft {𝒵 : BasedCategory.{v₄, u₄} 𝒮} (F : 𝒳 ⥤ᵇ 𝒴) {G H : 𝒴 ⥤ᵇ 𝒵} (α : G ⟶ H) :\n    F ⋙ G ⟶ F ⋙ H where\n  toNatTrans := CategoryTheory.whiskerLeft F.toFunctor α.toNatTrans\n  isHomLift' := fun a ↦ α.isHomLift (F.w_obj a)\n\n"}
{"name":"CategoryTheory.BasedCategory.whiskerRight_toNatTrans","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n𝒴 : CategoryTheory.BasedCategory 𝒮\n𝒵 : CategoryTheory.BasedCategory 𝒮\nF G : CategoryTheory.BasedFunctor 𝒳 𝒴\nα : Quiver.Hom F G\nH : CategoryTheory.BasedFunctor 𝒴 𝒵\n⊢ Eq (CategoryTheory.BasedCategory.whiskerRight α H).toNatTrans (CategoryTheory.whiskerRight α.toNatTrans H.toFunctor)","decl":"/-- Right-whiskering in the bicategory `BasedCategory` is given by whiskering the underlying\nfunctors and natural transformations. -/\n@[simps]\ndef whiskerRight {𝒵 : BasedCategory.{v₄, u₄} 𝒮} {F G : 𝒳 ⥤ᵇ 𝒴} (α : F ⟶ G) (H : 𝒴 ⥤ᵇ 𝒵) :\n    F ⋙ H ⟶ G ⋙ H where\n  toNatTrans := CategoryTheory.whiskerRight α.toNatTrans H.toFunctor\n  isHomLift' := fun _ ↦ BasedFunctor.preserves_isHomLift _ _ _\n\n"}
{"name":"CategoryTheory.BasedCategory.instCategory_id","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n𝒳 : CategoryTheory.BasedCategory 𝒮\n⊢ Eq (CategoryTheory.CategoryStruct.id 𝒳) (CategoryTheory.BasedFunctor.id 𝒳)","decl":"/-- The category of based categories. -/\n@[simps]\ninstance : Category (BasedCategory.{v₂, u₂} 𝒮) where\n  Hom := BasedFunctor\n  id := id\n  comp := comp\n\n"}
{"name":"CategoryTheory.BasedCategory.instCategory_comp","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\nX✝ Y✝ Z✝ : CategoryTheory.BasedCategory 𝒮\nF : CategoryTheory.BasedFunctor X✝ Y✝\nG : CategoryTheory.BasedFunctor Y✝ Z✝\n⊢ Eq (CategoryTheory.CategoryStruct.comp F G) (F.comp G)","decl":"/-- The category of based categories. -/\n@[simps]\ninstance : Category (BasedCategory.{v₂, u₂} 𝒮) where\n  Hom := BasedFunctor\n  id := id\n  comp := comp\n\n"}
{"name":"CategoryTheory.BasedCategory.instStrict","module":"Mathlib.CategoryTheory.FiberedCategory.BasedCategory","initialProofState":"𝒮 : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} 𝒮\n⊢ CategoryTheory.Bicategory.Strict (CategoryTheory.BasedCategory 𝒮)","decl":"/-- The bicategory structure on `BasedCategory.{v₂, u₂} 𝒮` is strict. -/\ninstance : Bicategory.Strict (BasedCategory.{v₂, u₂} 𝒮) where\n\n"}
