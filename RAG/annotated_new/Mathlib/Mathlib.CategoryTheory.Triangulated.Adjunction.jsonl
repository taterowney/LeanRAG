{"name":"CategoryTheory.Adjunction.isTriangulated_rightAdjoint","module":"Mathlib.CategoryTheory.Triangulated.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹³ : CategoryTheory.Limits.HasZeroObject C\ninst✝¹² : CategoryTheory.Limits.HasZeroObject D\ninst✝¹¹ : CategoryTheory.Preadditive C\ninst✝¹⁰ : CategoryTheory.Preadditive D\ninst✝⁹ : CategoryTheory.HasShift C Int\ninst✝⁸ : CategoryTheory.HasShift D Int\ninst✝⁷ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁶ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝⁵ : CategoryTheory.Pretriangulated C\ninst✝⁴ : CategoryTheory.Pretriangulated D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝³ : F.CommShift Int\ninst✝² : G.CommShift Int\ninst✝¹ : adj.CommShift Int\ninst✝ : F.IsTriangulated\n⊢ G.IsTriangulated","decl":"include adj in\n/--\nThe right adjoint of a triangulated functor is triangulated.\n-/\nlemma isTriangulated_rightAdjoint [F.IsTriangulated] : G.IsTriangulated where\n  map_distinguished T hT := by\n    have : G.Additive := adj.right_adjoint_additive\n    obtain ⟨Z, f, g, mem⟩ := distinguished_cocone_triangle (G.map T.mor₁)\n    obtain ⟨h, ⟨h₁, h₂⟩⟩ := complete_distinguished_triangle_morphism _ _\n      (F.map_distinguished _ mem) hT (adj.counit.app T.obj₁) (adj.counit.app T.obj₂) (by simp)\n    dsimp at h h₁ h₂ ⊢\n    have h₁' : f ≫ adj.unit.app Z ≫ G.map h = G.map T.mor₂ := by\n      simpa [homEquiv_apply] using DFunLike.congr_arg (adj.homEquiv _ _) h₁\n    have h₂' : g ≫ (G.commShiftIso (1 : ℤ)).inv.app T.obj₁ =\n        adj.homEquiv _ _ h ≫ G.map T.mor₃ := by\n      apply (adj.homEquiv _ _).symm.injective\n      simp only [Functor.comp_obj, homEquiv_counit, Functor.id_obj, Functor.map_comp, assoc,\n        homEquiv_unit, counit_naturality, counit_naturality_assoc, left_triangle_components_assoc,\n        ← h₂, adj.shift_counit_app, Iso.hom_inv_id_app_assoc]\n    rw [assoc] at h₂\n    have : Mono (adj.homEquiv _ _ h) := by\n      rw [mono_iff_cancel_zero]\n      intro _ φ hφ\n      obtain ⟨ψ, rfl⟩ := Triangle.coyoneda_exact₃ _ mem φ (by\n        dsimp\n        simp only [homEquiv_unit, Functor.comp_obj] at hφ\n        rw [← cancel_mono ((G.commShiftIso (1 : ℤ)).inv.app T.obj₁), assoc, h₂', zero_comp,\n          homEquiv_unit, assoc, reassoc_of% hφ, zero_comp])\n      dsimp at ψ hφ ⊢\n      obtain ⟨α, hα⟩ := T.coyoneda_exact₂ hT ((adj.homEquiv _ _).symm ψ)\n        ((adj.homEquiv _ _).injective (by simpa [homEquiv_counit, homEquiv_unit, ← h₁'] using hφ))\n      have eq := DFunLike.congr_arg (adj.homEquiv _ _ ) hα\n      simp only [homEquiv_counit, Functor.id_obj, homEquiv_unit, comp_id,\n        Functor.map_comp, unit_naturality_assoc, right_triangle_components] at eq\n      have eq' := comp_distTriang_mor_zero₁₂ _ mem\n      dsimp at eq eq'\n      rw [eq, assoc, assoc, eq', comp_zero, comp_zero]\n    have := isIso_of_yoneda_map_bijective (adj.homEquiv _ _ h) (fun Y => by\n      constructor\n      · intro φ₁ φ₂ hφ\n        rw [← cancel_mono (adj.homEquiv _ _ h)]\n        exact hφ\n      · intro φ\n        obtain ⟨ψ, hψ⟩ := Triangle.coyoneda_exact₁ _ mem (φ ≫ G.map T.mor₃ ≫\n          (G.commShiftIso (1 : ℤ)).hom.app T.obj₁) (by\n            dsimp\n            rw [assoc, assoc, ← G.commShiftIso_hom_naturality, ← G.map_comp_assoc,\n              comp_distTriang_mor_zero₃₁ _ hT, G.map_zero, zero_comp, comp_zero])\n        dsimp at ψ hψ\n        obtain ⟨α, hα⟩ : ∃ α, α = φ - ψ ≫ adj.homEquiv _ _ h := ⟨_, rfl⟩\n        have hα₀ : α ≫ G.map T.mor₃ = 0 := by\n          rw [hα, sub_comp, ← cancel_mono ((Functor.commShiftIso G (1 : ℤ)).hom.app T.obj₁),\n            assoc, sub_comp, assoc, assoc, hψ, zero_comp, sub_eq_zero,\n            ← cancel_mono ((Functor.commShiftIso G (1 : ℤ)).inv.app T.obj₁), assoc,\n            assoc, assoc, assoc, h₂', Iso.hom_inv_id_app, comp_id]\n        suffices ∃ (β : Y ⟶ Z), β ≫ adj.homEquiv _ _ h = α by\n          obtain ⟨β, hβ⟩ := this\n          refine ⟨ψ + β, ?_⟩\n          dsimp\n          rw [add_comp, hβ, hα, add_sub_cancel]\n        obtain ⟨β, hβ⟩ := T.coyoneda_exact₃ hT ((adj.homEquiv _ _).symm α)\n          ((adj.homEquiv _ _).injective (by simpa [homEquiv_unit, homEquiv_counit] using hα₀))\n        refine ⟨adj.homEquiv _ _ β ≫ f, ?_⟩\n        simpa [homEquiv_unit, h₁'] using congr_arg (adj.homEquiv _ _).toFun hβ.symm)\n    refine isomorphic_distinguished _ mem _ (Iso.symm ?_)\n    refine Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (asIso (adj.homEquiv Z T.obj₃ h)) ?_ ?_ ?_\n    · dsimp\n      simp\n    · apply (adj.homEquiv _ _).symm.injective\n      dsimp\n      simp only [homEquiv_unit, homEquiv_counit, Functor.map_comp, assoc,\n        counit_naturality, left_triangle_components_assoc, h₁, id_comp]\n    · dsimp\n      rw [Functor.map_id, comp_id, homEquiv_unit, assoc, ← G.map_comp_assoc, ← h₂,\n        Functor.map_comp, Functor.map_comp, assoc, unit_naturality_assoc, assoc,\n        Functor.commShiftIso_hom_naturality, ← adj.shift_unit_app_assoc,\n        ← Functor.map_comp, right_triangle_components, Functor.map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Adjunction.isTriangulated_leftAdjoint","module":"Mathlib.CategoryTheory.Triangulated.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹⁴ : CategoryTheory.Category.{u_3, u_2} D\ninst✝¹³ : CategoryTheory.Limits.HasZeroObject C\ninst✝¹² : CategoryTheory.Limits.HasZeroObject D\ninst✝¹¹ : CategoryTheory.Preadditive C\ninst✝¹⁰ : CategoryTheory.Preadditive D\ninst✝⁹ : CategoryTheory.HasShift C Int\ninst✝⁸ : CategoryTheory.HasShift D Int\ninst✝⁷ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁶ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝⁵ : CategoryTheory.Pretriangulated C\ninst✝⁴ : CategoryTheory.Pretriangulated D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝³ : F.CommShift Int\ninst✝² : G.CommShift Int\ninst✝¹ : adj.CommShift Int\ninst✝ : G.IsTriangulated\n⊢ F.IsTriangulated","decl":"include adj in\nopen Pretriangulated.Opposite Functor in\n/--\nThe left adjoint of a triangulated functor is triangulated.\n-/\nlemma isTriangulated_leftAdjoint [G.IsTriangulated] : F.IsTriangulated := by\n  have := isTriangulated_rightAdjoint adj.op\n  exact F.isTriangulated_of_op\n\n"}
{"name":"CategoryTheory.Adjunction.IsTriangulated.rightAdjoint_isTriangulated","module":"Mathlib.CategoryTheory.Triangulated.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝¹⁰ : CategoryTheory.Limits.HasZeroObject D\ninst✝⁹ : CategoryTheory.Preadditive C\ninst✝⁸ : CategoryTheory.Preadditive D\ninst✝⁷ : CategoryTheory.HasShift C Int\ninst✝⁶ : CategoryTheory.HasShift D Int\ninst✝⁵ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Pretriangulated D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝¹ : F.CommShift Int\ninst✝ : G.CommShift Int\nself : adj.IsTriangulated\n⊢ G.IsTriangulated","decl":"/--\nWe say that an adjunction `F ⊣ G` is triangulated if it is compatible with the `CommShift`\nstructures on `F` and `G` (in the sense of `Adjunction.CommShift`) and if both `F` and `G`\nare triangulated functors.\n-/\nclass IsTriangulated : Prop where\n  commShift : adj.CommShift ℤ := by infer_instance\n  leftAdjoint_isTriangulated : F.IsTriangulated := by infer_instance\n  rightAdjoint_isTriangulated : G.IsTriangulated := by infer_instance\n\n"}
{"name":"CategoryTheory.Adjunction.IsTriangulated.commShift","module":"Mathlib.CategoryTheory.Triangulated.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝¹⁰ : CategoryTheory.Limits.HasZeroObject D\ninst✝⁹ : CategoryTheory.Preadditive C\ninst✝⁸ : CategoryTheory.Preadditive D\ninst✝⁷ : CategoryTheory.HasShift C Int\ninst✝⁶ : CategoryTheory.HasShift D Int\ninst✝⁵ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Pretriangulated D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝¹ : F.CommShift Int\ninst✝ : G.CommShift Int\nself : adj.IsTriangulated\n⊢ adj.CommShift Int","decl":"/--\nWe say that an adjunction `F ⊣ G` is triangulated if it is compatible with the `CommShift`\nstructures on `F` and `G` (in the sense of `Adjunction.CommShift`) and if both `F` and `G`\nare triangulated functors.\n-/\nclass IsTriangulated : Prop where\n  commShift : adj.CommShift ℤ := by infer_instance\n  leftAdjoint_isTriangulated : F.IsTriangulated := by infer_instance\n  rightAdjoint_isTriangulated : G.IsTriangulated := by infer_instance\n\n"}
{"name":"CategoryTheory.Adjunction.IsTriangulated.leftAdjoint_isTriangulated","module":"Mathlib.CategoryTheory.Triangulated.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝¹⁰ : CategoryTheory.Limits.HasZeroObject D\ninst✝⁹ : CategoryTheory.Preadditive C\ninst✝⁸ : CategoryTheory.Preadditive D\ninst✝⁷ : CategoryTheory.HasShift C Int\ninst✝⁶ : CategoryTheory.HasShift D Int\ninst✝⁵ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\ninst✝² : CategoryTheory.Pretriangulated D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝¹ : F.CommShift Int\ninst✝ : G.CommShift Int\nself : adj.IsTriangulated\n⊢ F.IsTriangulated","decl":"/--\nWe say that an adjunction `F ⊣ G` is triangulated if it is compatible with the `CommShift`\nstructures on `F` and `G` (in the sense of `Adjunction.CommShift`) and if both `F` and `G`\nare triangulated functors.\n-/\nclass IsTriangulated : Prop where\n  commShift : adj.CommShift ℤ := by infer_instance\n  leftAdjoint_isTriangulated : F.IsTriangulated := by infer_instance\n  rightAdjoint_isTriangulated : G.IsTriangulated := by infer_instance\n\n"}
{"name":"CategoryTheory.Adjunction.IsTriangulated.mk'","module":"Mathlib.CategoryTheory.Triangulated.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹⁴ : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹³ : CategoryTheory.Limits.HasZeroObject C\ninst✝¹² : CategoryTheory.Limits.HasZeroObject D\ninst✝¹¹ : CategoryTheory.Preadditive C\ninst✝¹⁰ : CategoryTheory.Preadditive D\ninst✝⁹ : CategoryTheory.HasShift C Int\ninst✝⁸ : CategoryTheory.HasShift D Int\ninst✝⁷ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁶ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝⁵ : CategoryTheory.Pretriangulated C\ninst✝⁴ : CategoryTheory.Pretriangulated D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝³ : F.CommShift Int\ninst✝² : G.CommShift Int\ninst✝¹ : adj.CommShift Int\ninst✝ : F.IsTriangulated\n⊢ adj.IsTriangulated","decl":"/-- Constructor for `Adjunction.IsTriangulated`.\n-/\nlemma mk' [F.IsTriangulated] : adj.IsTriangulated where\n  rightAdjoint_isTriangulated := adj.isTriangulated_rightAdjoint\n\n"}
{"name":"CategoryTheory.Adjunction.IsTriangulated.mk''","module":"Mathlib.CategoryTheory.Triangulated.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁵ : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹⁴ : CategoryTheory.Category.{u_3, u_2} D\ninst✝¹³ : CategoryTheory.Limits.HasZeroObject C\ninst✝¹² : CategoryTheory.Limits.HasZeroObject D\ninst✝¹¹ : CategoryTheory.Preadditive C\ninst✝¹⁰ : CategoryTheory.Preadditive D\ninst✝⁹ : CategoryTheory.HasShift C Int\ninst✝⁸ : CategoryTheory.HasShift D Int\ninst✝⁷ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁶ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝⁵ : CategoryTheory.Pretriangulated C\ninst✝⁴ : CategoryTheory.Pretriangulated D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝³ : F.CommShift Int\ninst✝² : G.CommShift Int\ninst✝¹ : adj.CommShift Int\ninst✝ : G.IsTriangulated\n⊢ adj.IsTriangulated","decl":"/-- Constructor for `Adjunction.IsTriangulated`.\n-/\nlemma mk'' [G.IsTriangulated] : adj.IsTriangulated where\n  leftAdjoint_isTriangulated := adj.isTriangulated_leftAdjoint\n\n"}
{"name":"CategoryTheory.Adjunction.IsTriangulated.id","module":"Mathlib.CategoryTheory.Triangulated.Adjunction","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\n⊢ CategoryTheory.Adjunction.id.IsTriangulated","decl":"/-- The identity adjunction is triangulated.\n-/\ninstance id : (Adjunction.id (C := C)).IsTriangulated where\n\n"}
{"name":"CategoryTheory.Adjunction.IsTriangulated.comp","module":"Mathlib.CategoryTheory.Triangulated.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝²³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝²² : CategoryTheory.Category.{u_5, u_2} D\ninst✝²¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝²⁰ : CategoryTheory.Limits.HasZeroObject D\ninst✝¹⁹ : CategoryTheory.Preadditive C\ninst✝¹⁸ : CategoryTheory.Preadditive D\ninst✝¹⁷ : CategoryTheory.HasShift C Int\ninst✝¹⁶ : CategoryTheory.HasShift D Int\ninst✝¹⁵ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝¹⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝¹³ : CategoryTheory.Pretriangulated C\ninst✝¹² : CategoryTheory.Pretriangulated D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝¹¹ : F.CommShift Int\ninst✝¹⁰ : G.CommShift Int\nE : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_6, u_3} E\nF' : CategoryTheory.Functor D E\nG' : CategoryTheory.Functor E D\nadj' : CategoryTheory.Adjunction F' G'\ninst✝⁸ : CategoryTheory.Limits.HasZeroObject E\ninst✝⁷ : CategoryTheory.Preadditive E\ninst✝⁶ : CategoryTheory.HasShift E Int\ninst✝⁵ : ∀ (n : Int), (CategoryTheory.shiftFunctor E n).Additive\ninst✝⁴ : CategoryTheory.Pretriangulated E\ninst✝³ : F'.CommShift Int\ninst✝² : G'.CommShift Int\ninst✝¹ : adj.IsTriangulated\ninst✝ : adj'.IsTriangulated\n⊢ (adj.comp adj').IsTriangulated","decl":"/-- A composition of triangulated adjunctions is triangulated.\n-/\ninstance comp [adj.IsTriangulated] [adj'.IsTriangulated] : (adj.comp adj').IsTriangulated where\n\n"}
{"name":"CategoryTheory.Equivalence.IsTriangulated.instIsTriangulatedFunctor","module":"Mathlib.CategoryTheory.Triangulated.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹¹ : CategoryTheory.Limits.HasZeroObject D\ninst✝¹⁰ : CategoryTheory.Preadditive C\ninst✝⁹ : CategoryTheory.Preadditive D\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.HasShift D Int\ninst✝⁶ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁵ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝⁴ : CategoryTheory.Pretriangulated C\ninst✝³ : CategoryTheory.Pretriangulated D\nE : CategoryTheory.Equivalence C D\ninst✝² : E.functor.CommShift Int\ninst✝¹ : E.inverse.CommShift Int\ninst✝ : E.IsTriangulated\n⊢ E.functor.IsTriangulated","decl":"instance [E.IsTriangulated] : E.functor.IsTriangulated := inferInstance\n"}
{"name":"CategoryTheory.Equivalence.IsTriangulated.instIsTriangulatedInverse","module":"Mathlib.CategoryTheory.Triangulated.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹¹ : CategoryTheory.Limits.HasZeroObject D\ninst✝¹⁰ : CategoryTheory.Preadditive C\ninst✝⁹ : CategoryTheory.Preadditive D\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.HasShift D Int\ninst✝⁶ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁵ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝⁴ : CategoryTheory.Pretriangulated C\ninst✝³ : CategoryTheory.Pretriangulated D\nE : CategoryTheory.Equivalence C D\ninst✝² : E.functor.CommShift Int\ninst✝¹ : E.inverse.CommShift Int\ninst✝ : E.IsTriangulated\n⊢ E.inverse.IsTriangulated","decl":"instance [E.IsTriangulated] : E.inverse.IsTriangulated := inferInstance\n\n"}
{"name":"CategoryTheory.Equivalence.IsTriangulated.instIsTriangulatedInverseSymmOfFunctor","module":"Mathlib.CategoryTheory.Triangulated.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹¹ : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹⁰ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁹ : CategoryTheory.Limits.HasZeroObject D\ninst✝⁸ : CategoryTheory.Preadditive C\ninst✝⁷ : CategoryTheory.Preadditive D\ninst✝⁶ : CategoryTheory.HasShift C Int\ninst✝⁵ : CategoryTheory.HasShift D Int\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝² : CategoryTheory.Pretriangulated C\ninst✝¹ : CategoryTheory.Pretriangulated D\nE : CategoryTheory.Equivalence C D\ninst✝ : E.functor.CommShift Int\nh : E.functor.IsTriangulated\n⊢ E.symm.inverse.IsTriangulated","decl":"instance [h : E.functor.IsTriangulated] : E.symm.inverse.IsTriangulated := h\n"}
{"name":"CategoryTheory.Equivalence.IsTriangulated.instIsTriangulatedFunctorSymmOfInverse","module":"Mathlib.CategoryTheory.Triangulated.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹² : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹¹ : CategoryTheory.Category.{u_3, u_2} D\ninst✝¹⁰ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁹ : CategoryTheory.Limits.HasZeroObject D\ninst✝⁸ : CategoryTheory.Preadditive C\ninst✝⁷ : CategoryTheory.Preadditive D\ninst✝⁶ : CategoryTheory.HasShift C Int\ninst✝⁵ : CategoryTheory.HasShift D Int\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝² : CategoryTheory.Pretriangulated C\ninst✝¹ : CategoryTheory.Pretriangulated D\nE : CategoryTheory.Equivalence C D\ninst✝ : E.inverse.CommShift Int\nh : E.inverse.IsTriangulated\n⊢ E.symm.functor.IsTriangulated","decl":"instance [h : E.inverse.IsTriangulated] : E.symm.functor.IsTriangulated := h\n\n\n"}
{"name":"CategoryTheory.Equivalence.IsTriangulated.mk'","module":"Mathlib.CategoryTheory.Triangulated.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹¹ : CategoryTheory.Limits.HasZeroObject D\ninst✝¹⁰ : CategoryTheory.Preadditive C\ninst✝⁹ : CategoryTheory.Preadditive D\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.HasShift D Int\ninst✝⁶ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁵ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝⁴ : CategoryTheory.Pretriangulated C\ninst✝³ : CategoryTheory.Pretriangulated D\nE : CategoryTheory.Equivalence C D\ninst✝² : E.functor.CommShift Int\ninst✝¹ : E.inverse.CommShift Int\ninst✝ : E.CommShift Int\nh : E.functor.IsTriangulated\n⊢ E.IsTriangulated","decl":"/-- Constructor for `Equivalence.IsTriangulated`. -/\nlemma mk' (h : E.functor.IsTriangulated) : E.IsTriangulated where\n  rightAdjoint_isTriangulated := E.toAdjunction.isTriangulated_rightAdjoint\n\n"}
{"name":"CategoryTheory.Equivalence.IsTriangulated.mk''","module":"Mathlib.CategoryTheory.Triangulated.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝¹² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹¹ : CategoryTheory.Limits.HasZeroObject D\ninst✝¹⁰ : CategoryTheory.Preadditive C\ninst✝⁹ : CategoryTheory.Preadditive D\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.HasShift D Int\ninst✝⁶ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁵ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝⁴ : CategoryTheory.Pretriangulated C\ninst✝³ : CategoryTheory.Pretriangulated D\nE : CategoryTheory.Equivalence C D\ninst✝² : E.functor.CommShift Int\ninst✝¹ : E.inverse.CommShift Int\ninst✝ : E.CommShift Int\nh : E.inverse.IsTriangulated\n⊢ E.IsTriangulated","decl":"/-- Constructor for `Equivalence.IsTriangulated`. -/\nlemma mk'' (h : E.inverse.IsTriangulated) : E.IsTriangulated where\n  leftAdjoint_isTriangulated := (mk' E.symm h).rightAdjoint_isTriangulated\n\n"}
{"name":"CategoryTheory.Equivalence.IsTriangulated.refl","module":"Mathlib.CategoryTheory.Triangulated.Adjunction","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\n⊢ CategoryTheory.Equivalence.refl.IsTriangulated","decl":"/--\nThe identity equivalence is triangulated.\n-/\ninstance refl : (Equivalence.refl (C := C)).IsTriangulated := by\n  dsimp [Equivalence.IsTriangulated]\n  rw [refl_toAdjunction]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Equivalence.IsTriangulated.symm","module":"Mathlib.CategoryTheory.Triangulated.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹¹ : CategoryTheory.Limits.HasZeroObject D\ninst✝¹⁰ : CategoryTheory.Preadditive C\ninst✝⁹ : CategoryTheory.Preadditive D\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.HasShift D Int\ninst✝⁶ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁵ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝⁴ : CategoryTheory.Pretriangulated C\ninst✝³ : CategoryTheory.Pretriangulated D\nE : CategoryTheory.Equivalence C D\ninst✝² : E.functor.CommShift Int\ninst✝¹ : E.inverse.CommShift Int\ninst✝ : E.IsTriangulated\n⊢ E.symm.IsTriangulated","decl":"/-- If the equivalence `E` is triangulated, so is the equivalence `E.symm`.\n-/\ninstance symm [E.IsTriangulated] : E.symm.IsTriangulated where\n\n"}
{"name":"CategoryTheory.Equivalence.IsTriangulated.trans","module":"Mathlib.CategoryTheory.Triangulated.Adjunction","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝²³ : CategoryTheory.Category.{u_4, u_1} C\ninst✝²² : CategoryTheory.Category.{u_5, u_2} D\ninst✝²¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝²⁰ : CategoryTheory.Limits.HasZeroObject D\ninst✝¹⁹ : CategoryTheory.Preadditive C\ninst✝¹⁸ : CategoryTheory.Preadditive D\ninst✝¹⁷ : CategoryTheory.HasShift C Int\ninst✝¹⁶ : CategoryTheory.HasShift D Int\ninst✝¹⁵ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝¹⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝¹³ : CategoryTheory.Pretriangulated C\ninst✝¹² : CategoryTheory.Pretriangulated D\nE : CategoryTheory.Equivalence C D\ninst✝¹¹ : E.functor.CommShift Int\ninst✝¹⁰ : E.inverse.CommShift Int\nD' : Type u_3\ninst✝⁹ : CategoryTheory.Category.{u_6, u_3} D'\ninst✝⁸ : CategoryTheory.Limits.HasZeroObject D'\ninst✝⁷ : CategoryTheory.Preadditive D'\ninst✝⁶ : CategoryTheory.HasShift D' Int\ninst✝⁵ : ∀ (n : Int), (CategoryTheory.shiftFunctor D' n).Additive\ninst✝⁴ : CategoryTheory.Pretriangulated D'\nE' : CategoryTheory.Equivalence D D'\ninst✝³ : E'.functor.CommShift Int\ninst✝² : E'.inverse.CommShift Int\ninst✝¹ : E.IsTriangulated\ninst✝ : E'.IsTriangulated\n⊢ (E.trans E').IsTriangulated","decl":"/--\nIf equivalences `E : C ≌ D` and `E' : D ≌ F` are triangulated, so is `E.trans E'`.\n-/\ninstance trans [E.IsTriangulated] [E'.IsTriangulated] : (E.trans E').IsTriangulated := by\n  dsimp [Equivalence.IsTriangulated]\n  rw [trans_toAdjunction]\n  infer_instance\n\n"}
