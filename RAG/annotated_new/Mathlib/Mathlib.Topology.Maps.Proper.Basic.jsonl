{"name":"isProperMap_iff_clusterPt","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nâŠ¢ Iff (IsProperMap f) (And (Continuous f) (âˆ€ â¦ƒâ„± : Filter Xâ¦„ â¦ƒy : Yâ¦„, MapClusterPt y â„± f â†’ Exists fun x => And (Eq (f x) y) (ClusterPt x â„±)))","decl":"/-- A map `f : X â†’ Y` between two topological spaces is said to be **proper** if it is continuous\nand, for all `â„± : Filter X`, any cluster point of `map f â„±` is the image by `f` of a cluster point\nof `â„±`. -/\n@[mk_iff isProperMap_iff_clusterPt, fun_prop]\nstructure IsProperMap (f : X â†’ Y) extends Continuous f : Prop where\n  /-- By definition, if `f` is a proper map and `â„±` is any filter on `X`, then any cluster point of\n  `map f â„±` is the image by `f` of some cluster point of `â„±`. -/\n  clusterPt_of_mapClusterPt :\n    âˆ€ â¦ƒâ„± : Filter Xâ¦„, âˆ€ â¦ƒy : Yâ¦„, MapClusterPt y â„± f â†’ âˆƒ x, f x = y âˆ§ ClusterPt x â„±\n\n"}
{"name":"IsProperMap.clusterPt_of_mapClusterPt","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nself : IsProperMap f\nâ„± : Filter X\ny : Y\naâœ : MapClusterPt y â„± f\nâŠ¢ Exists fun x => And (Eq (f x) y) (ClusterPt x â„±)","decl":"/-- A map `f : X â†’ Y` between two topological spaces is said to be **proper** if it is continuous\nand, for all `â„± : Filter X`, any cluster point of `map f â„±` is the image by `f` of a cluster point\nof `â„±`. -/\n@[mk_iff isProperMap_iff_clusterPt, fun_prop]\nstructure IsProperMap (f : X â†’ Y) extends Continuous f : Prop where\n  /-- By definition, if `f` is a proper map and `â„±` is any filter on `X`, then any cluster point of\n  `map f â„±` is the image by `f` of some cluster point of `â„±`. -/\n  clusterPt_of_mapClusterPt :\n    âˆ€ â¦ƒâ„± : Filter Xâ¦„, âˆ€ â¦ƒy : Yâ¦„, MapClusterPt y â„± f â†’ âˆƒ x, f x = y âˆ§ ClusterPt x â„±\n\n"}
{"name":"IsProperMap.toContinuous","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nself : IsProperMap f\nâŠ¢ Continuous f","decl":"/-- A map `f : X â†’ Y` between two topological spaces is said to be **proper** if it is continuous\nand, for all `â„± : Filter X`, any cluster point of `map f â„±` is the image by `f` of a cluster point\nof `â„±`. -/\n@[mk_iff isProperMap_iff_clusterPt, fun_prop]\nstructure IsProperMap (f : X â†’ Y) extends Continuous f : Prop where\n  /-- By definition, if `f` is a proper map and `â„±` is any filter on `X`, then any cluster point of\n  `map f â„±` is the image by `f` of some cluster point of `â„±`. -/\n  clusterPt_of_mapClusterPt :\n    âˆ€ â¦ƒâ„± : Filter Xâ¦„, âˆ€ â¦ƒy : Yâ¦„, MapClusterPt y â„± f â†’ âˆƒ x, f x = y âˆ§ ClusterPt x â„±\n\n"}
{"name":"IsProperMap.continuous","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nh : IsProperMap f\nâŠ¢ Continuous f","decl":"/-- By definition, a proper map is continuous. -/\n@[fun_prop]\nlemma IsProperMap.continuous (h : IsProperMap f) : Continuous f := h.toContinuous\n\n"}
{"name":"IsProperMap.isClosedMap","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nh : IsProperMap f\nâŠ¢ IsClosedMap f","decl":"/-- A proper map is closed. -/\nlemma IsProperMap.isClosedMap (h : IsProperMap f) : IsClosedMap f := by\n  rw [isClosedMap_iff_clusterPt]\n  exact fun s y â†¦ h.clusterPt_of_mapClusterPt (â„± := ğ“Ÿ s) (y := y)\n\n"}
{"name":"isProperMap_iff_ultrafilter","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nâŠ¢ Iff (IsProperMap f) (And (Continuous f) (âˆ€ â¦ƒğ’° : Ultrafilter Xâ¦„ â¦ƒy : Yâ¦„, Filter.Tendsto f (â†‘ğ’°) (nhds y) â†’ Exists fun x => And (Eq (f x) y) (LE.le (â†‘ğ’°) (nhds x))))","decl":"/-- Characterization of proper maps by ultrafilters. -/\nlemma isProperMap_iff_ultrafilter : IsProperMap f â†” Continuous f âˆ§\n    âˆ€ â¦ƒğ’° : Ultrafilter Xâ¦„, âˆ€ â¦ƒy : Yâ¦„, Tendsto f ğ’° (ğ“ y) â†’ âˆƒ x, f x = y âˆ§ ğ’° â‰¤ ğ“ x := by\n  -- This is morally trivial since ultrafilters give all the information about cluster points.\n  rw [isProperMap_iff_clusterPt]\n  refine and_congr_right (fun _ â†¦ ?_)\n  constructor <;> intro H\n  Â· intro ğ’° y (hY : (Ultrafilter.map f ğ’° : Filter Y) â‰¤ _)\n    simp_rw [â† Ultrafilter.clusterPt_iff] at hY âŠ¢\n    exact H hY\n  Â· simp_rw [MapClusterPt, ClusterPt, â† Filter.push_pull', map_neBot_iff, â† exists_ultrafilter_iff,\n      forall_exists_index]\n    intro â„± y ğ’° hy\n    rcases H (tendsto_iff_comap.mpr <| hy.trans inf_le_left) with âŸ¨x, hxy, hxâŸ©\n    exact âŸ¨x, hxy, ğ’°, le_inf hx (hy.trans inf_le_right)âŸ©\n\n"}
{"name":"isProperMap_iff_ultrafilter_of_t2","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\nf : X â†’ Y\ninstâœ : T2Space Y\nâŠ¢ Iff (IsProperMap f) (And (Continuous f) (âˆ€ â¦ƒğ’° : Ultrafilter Xâ¦„ â¦ƒy : Yâ¦„, Filter.Tendsto f (â†‘ğ’°) (nhds y) â†’ Exists fun x => LE.le (â†‘ğ’°) (nhds x)))","decl":"lemma isProperMap_iff_ultrafilter_of_t2 [T2Space Y] : IsProperMap f â†” Continuous f âˆ§\n    âˆ€ â¦ƒğ’° : Ultrafilter Xâ¦„, âˆ€ â¦ƒy : Yâ¦„, Tendsto f ğ’° (ğ“ y) â†’ âˆƒ x, ğ’°.1 â‰¤ ğ“ x :=\n  isProperMap_iff_ultrafilter.trans <| and_congr_right fun hc â†¦ forallâ‚ƒ_congr fun _ğ’° _y hy â†¦\n    exists_congr fun x â†¦ and_iff_right_of_imp fun h â†¦\n      tendsto_nhds_unique ((hc.tendsto x).mono_left h) hy\n\n"}
{"name":"IsProperMap.ultrafilter_le_nhds_of_tendsto","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nh : IsProperMap f\nğ’° : Ultrafilter X\ny : Y\nhy : Filter.Tendsto f (â†‘ğ’°) (nhds y)\nâŠ¢ Exists fun x => And (Eq (f x) y) (LE.le (â†‘ğ’°) (nhds x))","decl":"/-- If `f` is proper and converges to `y` along some ultrafilter `ğ’°`, then `ğ’°` converges to some\n`x` such that `f x = y`. -/\nlemma IsProperMap.ultrafilter_le_nhds_of_tendsto (h : IsProperMap f) â¦ƒğ’° : Ultrafilter Xâ¦„ â¦ƒy : Yâ¦„\n    (hy : Tendsto f ğ’° (ğ“ y)) : âˆƒ x, f x = y âˆ§ ğ’° â‰¤ ğ“ x :=\n  (isProperMap_iff_ultrafilter.mp h).2 hy\n\n"}
{"name":"IsProperMap.comp","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : X â†’ Y\ng : Y â†’ Z\nhf : IsProperMap f\nhg : IsProperMap g\nâŠ¢ IsProperMap (Function.comp g f)","decl":"/-- The composition of two proper maps is proper. -/\nlemma IsProperMap.comp (hf : IsProperMap f) (hg : IsProperMap g) :\n    IsProperMap (g âˆ˜ f) := by\n  refine âŸ¨by fun_prop, fun â„± z h â†¦ ?_âŸ©\n  rw [mapClusterPt_comp] at h\n  rcases hg.clusterPt_of_mapClusterPt h with âŸ¨y, rfl, hyâŸ©\n  rcases hf.clusterPt_of_mapClusterPt hy with âŸ¨x, rfl, hxâŸ©\n  use x, rfl\n\n\n"}
{"name":"isProperMap_of_comp_of_surj","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : X â†’ Y\ng : Y â†’ Z\nhf : Continuous f\nhg : Continuous g\nhgf : IsProperMap (Function.comp g f)\nf_surj : Function.Surjective f\nâŠ¢ IsProperMap g","decl":"/-- If the composition of two continuous functions `g âˆ˜ f` is proper and `f` is surjective,\nthen `g` is proper. -/\nlemma isProperMap_of_comp_of_surj (hf : Continuous f)\n    (hg : Continuous g) (hgf : IsProperMap (g âˆ˜ f)) (f_surj : f.Surjective) : IsProperMap g := by\n  refine âŸ¨hg, fun â„± z h â†¦ ?_âŸ©\n  rw [â† â„±.map_comap_of_surjective f_surj, â† mapClusterPt_comp] at h\n  rcases hgf.clusterPt_of_mapClusterPt h with âŸ¨x, rfl, hxâŸ©\n  rw [â† â„±.map_comap_of_surjective f_surj]\n  exact âŸ¨f x, rfl, hx.map hf.continuousAt tendsto_mapâŸ©\n\n"}
{"name":"isProperMap_of_comp_of_inj","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\ninstâœ : TopologicalSpace Z\nf : X â†’ Y\ng : Y â†’ Z\nhf : Continuous f\nhg : Continuous g\nhgf : IsProperMap (Function.comp g f)\ng_inj : Function.Injective g\nâŠ¢ IsProperMap f","decl":"/-- If the composition of two continuous functions `g âˆ˜ f` is proper and `g` is injective,\nthen `f` is proper. -/\nlemma isProperMap_of_comp_of_inj {f : X â†’ Y} {g : Y â†’ Z} (hf : Continuous f) (hg : Continuous g)\n    (hgf : IsProperMap (g âˆ˜ f)) (g_inj : g.Injective) : IsProperMap f := by\n  refine âŸ¨hf, fun â„± y h â†¦ ?_âŸ©\n  rcases hgf.clusterPt_of_mapClusterPt (h.map hg.continuousAt tendsto_map) with âŸ¨x, hx1, hx2âŸ©\n  exact âŸ¨x, g_inj hx1, hx2âŸ©\n\n"}
{"name":"isProperMap_of_comp_of_t2","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\nf : X â†’ Y\ng : Y â†’ Z\ninstâœ : T2Space Y\nhf : Continuous f\nhg : Continuous g\nhgf : IsProperMap (Function.comp g f)\nâŠ¢ IsProperMap f","decl":"/-- If the composition of two continuous functions `f : X â†’ Y` and `g : Y â†’ Z` is proper\nand `Y` is T2, then `f` is proper. -/\nlemma isProperMap_of_comp_of_t2 [T2Space Y] (hf : Continuous f) (hg : Continuous g)\n    (hgf : IsProperMap (g âˆ˜ f)) : IsProperMap f := by\n  rw [isProperMap_iff_ultrafilter_of_t2]\n  refine âŸ¨hf, fun ğ’° y h â†¦ ?_âŸ©\n  rw [isProperMap_iff_ultrafilter] at hgf\n  rcases hgf.2 ((hg.tendsto y).comp h) with âŸ¨x, -, hxâŸ©\n  exact âŸ¨x, hxâŸ©\n\n"}
{"name":"IsProperMap.prodMap","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nW : Type u_4\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : X â†’ Y\ng : Z â†’ W\nhf : IsProperMap f\nhg : IsProperMap g\nâŠ¢ IsProperMap (Prod.map f g)","decl":"/-- A binary product of proper maps is proper. -/\nlemma IsProperMap.prodMap {g : Z â†’ W} (hf : IsProperMap f) (hg : IsProperMap g) :\n    IsProperMap (Prod.map f g) := by\n  simp_rw [isProperMap_iff_ultrafilter] at hf hg âŠ¢\n  constructor\n  -- Continuity is clear.\n  Â· exact hf.1.prodMap hg.1\n  -- Let `ğ’° : Ultrafilter (X Ã— Z)`, and assume that `f Ã— g` tends to some `(y, w) : Y Ã— W`\n  -- along `ğ’°`.\n  Â· intro ğ’° âŸ¨y, wâŸ© hyw\n  -- That means that `f` tends to `y` along `map fst ğ’°` and `g` tends to `w` along `map snd ğ’°`.\n    simp_rw [nhds_prod_eq, tendsto_prod_iff'] at hyw\n  -- Thus, by properness of `f` and `g`, we get some `x : X` and `z : Z` such that `f x = y`,\n  -- `g z = w`, `map fst ğ’°` tends to  `x`, and `map snd ğ’°` tends to `y`.\n    rcases hf.2 (show Tendsto f (Ultrafilter.map fst ğ’°) (ğ“ y) by simpa using hyw.1) with\n      âŸ¨x, hxy, hxâŸ©\n    rcases hg.2 (show Tendsto g (Ultrafilter.map snd ğ’°) (ğ“ w) by simpa using hyw.2) with\n      âŸ¨z, hzw, hzâŸ©\n  -- By the properties of the product topology, that means that `ğ’°` tends to `(x, z)`,\n  -- which completes the proof since `(f Ã— g)(x, z) = (y, w)`.\n    refine âŸ¨âŸ¨x, zâŸ©, Prod.ext hxy hzw, ?_âŸ©\n    rw [nhds_prod_eq, le_prod]\n    exact âŸ¨hx, hzâŸ©\n\n"}
{"name":"IsProperMap.prod_map","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_3\nW : Type u_4\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\ninstâœÂ¹ : TopologicalSpace Z\ninstâœ : TopologicalSpace W\nf : X â†’ Y\ng : Z â†’ W\nhf : IsProperMap f\nhg : IsProperMap g\nâŠ¢ IsProperMap (Prod.map f g)","decl":"@[deprecated (since := \"2024-10-06\")] alias IsProperMap.prod_map := IsProperMap.prodMap\n\n"}
{"name":"IsProperMap.pi_map","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"Î¹ : Type u_5\nX : Î¹ â†’ Type u_6\nY : Î¹ â†’ Type u_7\ninstâœÂ¹ : (i : Î¹) â†’ TopologicalSpace (X i)\ninstâœ : (i : Î¹) â†’ TopologicalSpace (Y i)\nf : (i : Î¹) â†’ X i â†’ Y i\nh : âˆ€ (i : Î¹), IsProperMap (f i)\nâŠ¢ IsProperMap fun x i => f i (x i)","decl":"/-- Any product of proper maps is proper. -/\nlemma IsProperMap.pi_map {X Y : Î¹ â†’ Type*} [âˆ€ i, TopologicalSpace (X i)]\n    [âˆ€ i, TopologicalSpace (Y i)] {f : (i : Î¹) â†’ X i â†’ Y i} (h : âˆ€ i, IsProperMap (f i)) :\n    IsProperMap (fun (x : âˆ€ i, X i) i â†¦ f i (x i)) := by\n  simp_rw [isProperMap_iff_ultrafilter] at h âŠ¢\n  constructor\n  -- Continuity is clear.\n  Â· exact continuous_pi fun i â†¦ (h i).1.comp (continuous_apply i)\n  -- Let `ğ’° : Ultrafilter (Î  i, X i)`, and assume that `Î  i, f i` tends to some `y : Î  i, Y i`\n  -- along `ğ’°`.\n  Â· intro ğ’° y hy\n  -- That means that each `f i` tends to `y i` along `map (eval i) ğ’°`.\n    have : âˆ€ i, Tendsto (f i) (Ultrafilter.map (eval i) ğ’°) (ğ“ (y i)) := by\n      simpa [tendsto_pi_nhds] using hy\n  -- Thus, by properness of all the `f i`s, we can choose some `x : Î  i, X i` such that, for all\n  -- `i`, `f i (x i) = y i` and `map (eval i) ğ’°` tends to  `x i`.\n    choose x hxy hx using fun i â†¦ (h i).2 (this i)\n  -- By the properties of the product topology, that means that `ğ’°` tends to `x`,\n  -- which completes the proof since `(Î  i, f i) x = y`.\n    refine âŸ¨x, funext hxy, ?_âŸ©\n    rwa [nhds_pi, le_pi]\n\n"}
{"name":"IsProperMap.isCompact_preimage","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nh : IsProperMap f\nK : Set Y\nhK : IsCompact K\nâŠ¢ IsCompact (Set.preimage f K)","decl":"/-- The preimage of a compact set by a proper map is again compact. See also\n`isProperMap_iff_isCompact_preimage` which proves that this property completely characterizes\nproper map when the codomain is compactly generated and Hausdorff. -/\nlemma IsProperMap.isCompact_preimage (h : IsProperMap f) {K : Set Y} (hK : IsCompact K) :\n    IsCompact (f â»Â¹' K) := by\n  rw [isCompact_iff_ultrafilter_le_nhds]\n  -- Let `ğ’° â‰¤ ğ“Ÿ (f â»Â¹' K)` an ultrafilter.\n  intro ğ’° hğ’°\n  -- In other words, we have `map f ğ’° â‰¤ ğ“Ÿ K`\n  rw [â† comap_principal, â† map_le_iff_le_comap, â† Ultrafilter.coe_map] at hğ’°\n  -- Thus, by compactness of `K`, the ultrafilter `map f ğ’°` tends to some `y âˆˆ K`.\n  rcases hK.ultrafilter_le_nhds _ hğ’° with âŸ¨y, hyK, hyâŸ©\n  -- Then, by properness of `f`, that means that `ğ’°` tends to some `x âˆˆ f â»Â¹' {y} âŠ† f â»Â¹' K`,\n  -- which completes the proof.\n  rcases h.ultrafilter_le_nhds_of_tendsto hy with âŸ¨x, rfl, hxâŸ©\n  exact âŸ¨x, hyK, hxâŸ©\n\n"}
{"name":"isProperMap_iff_isClosedMap_and_compact_fibers","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nâŠ¢ Iff (IsProperMap f) (And (Continuous f) (And (IsClosedMap f) (âˆ€ (y : Y), IsCompact (Set.preimage f (Singleton.singleton y)))))","decl":"/-- A map is proper if and only if it is closed and its fibers are compact. -/\ntheorem isProperMap_iff_isClosedMap_and_compact_fibers :\n    IsProperMap f â†” Continuous f âˆ§ IsClosedMap f âˆ§ âˆ€ y, IsCompact (f â»Â¹' {y}) := by\n  constructor <;> intro H\n  -- Note: In Bourbaki, the direct implication is proved by going through universally closed maps.\n  -- We could do the same (using a `TFAE` cycle) but proving it directly from\n  -- `IsProperMap.isCompact_preimage` is nice enough already so we don't bother with that.\n  Â· exact âŸ¨H.continuous, H.isClosedMap, fun y â†¦ H.isCompact_preimage isCompact_singletonâŸ©\n  Â· rw [isProperMap_iff_clusterPt]\n  -- Let `â„± : Filter X` and `y` some cluster point of `map f â„±`.\n    refine âŸ¨H.1, fun â„± y hy â†¦ ?_âŸ©\n  -- That means that the singleton `pure y` meets the \"closure\" of `map f â„±`, by which we mean\n  -- `Filter.lift' (map f â„±) closure`. But `f` is closed, so\n  -- `closure (map f â„±) = map f (closure â„±)` (see `IsClosedMap.lift'_closure_map_eq`).\n  -- Thus `map f (closure â„± âŠ“ ğ“Ÿ (f â»Â¹' {y})) = map f (closure â„±) âŠ“ ğ“Ÿ {y} â‰  âŠ¥`, hence\n  -- `closure â„± âŠ“ ğ“Ÿ (f â»Â¹' {y}) â‰  âŠ¥`.\n    rw [H.2.1.mapClusterPt_iff_lift'_closure H.1] at hy\n  -- Now, applying the compactness of `f â»Â¹' {y}` to the nontrivial filter\n  -- `closure â„± âŠ“ ğ“Ÿ (f â»Â¹' {y})`, we obtain that it has a cluster point `x âˆˆ f â»Â¹' {y}`.\n    rcases H.2.2 y (f := Filter.lift' â„± closure âŠ“ ğ“Ÿ (f â»Â¹' {y})) inf_le_right with âŸ¨x, hxy, hxâŸ©\n    refine âŸ¨x, hxy, ?_âŸ©\n  -- In particular `x` is a cluster point of `closure â„±`. Since cluster points of `closure â„±`\n  -- are exactly cluster points of `â„±` (see `clusterPt_lift'_closure_iff`), this completes\n  -- the proof.\n    rw [â† clusterPt_lift'_closure_iff]\n    exact hx.mono inf_le_left\n\n"}
{"name":"isProperMap_iff_isClosedMap_of_inj","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nf_cont : Continuous f\nf_inj : Function.Injective f\nâŠ¢ Iff (IsProperMap f) (IsClosedMap f)","decl":"/-- An injective and continuous function is proper if and only if it is closed. -/\nlemma isProperMap_iff_isClosedMap_of_inj (f_cont : Continuous f) (f_inj : f.Injective) :\n    IsProperMap f â†” IsClosedMap f := by\n  refine âŸ¨fun h â†¦ h.isClosedMap, fun h â†¦ ?_âŸ©\n  rw [isProperMap_iff_isClosedMap_and_compact_fibers]\n  exact âŸ¨f_cont, h, fun y â†¦ (subsingleton_singleton.preimage f_inj).isCompactâŸ©\n\n"}
{"name":"isProperMap_of_isClosedMap_of_inj","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nf_cont : Continuous f\nf_inj : Function.Injective f\nf_closed : IsClosedMap f\nâŠ¢ IsProperMap f","decl":"/-- A injective continuous and closed map is proper. -/\nlemma isProperMap_of_isClosedMap_of_inj (f_cont : Continuous f) (f_inj : f.Injective)\n    (f_closed : IsClosedMap f) : IsProperMap f :=\n  (isProperMap_iff_isClosedMap_of_inj f_cont f_inj).2 f_closed\n\n"}
{"name":"Homeomorph.isProperMap","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\ne : Homeomorph X Y\nâŠ¢ IsProperMap â‡‘e","decl":"/-- A homeomorphism is proper. -/\n@[simp] lemma Homeomorph.isProperMap (e : X â‰ƒâ‚œ Y) : IsProperMap e :=\n  isProperMap_of_isClosedMap_of_inj e.continuous e.injective e.isClosedMap\n\n"}
{"name":"IsHomeomorph.isProperMap","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nhf : IsHomeomorph f\nâŠ¢ IsProperMap f","decl":"protected lemma IsHomeomorph.isProperMap (hf : IsHomeomorph f) : IsProperMap f :=\n  isProperMap_of_isClosedMap_of_inj hf.continuous hf.injective hf.isClosedMap\n\n"}
{"name":"isProperMap_id","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nâŠ¢ IsProperMap id","decl":"/-- The identity is proper. -/\n@[simp] lemma isProperMap_id : IsProperMap (id : X â†’ X) := IsHomeomorph.id.isProperMap\n\n"}
{"name":"Topology.IsClosedEmbedding.isProperMap","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nhf : Topology.IsClosedEmbedding f\nâŠ¢ IsProperMap f","decl":"/-- A closed embedding is proper. -/\nlemma Topology.IsClosedEmbedding.isProperMap (hf : IsClosedEmbedding f) : IsProperMap f :=\n  isProperMap_of_isClosedMap_of_inj hf.continuous hf.injective hf.isClosedMap\n\n"}
{"name":"isProperMap_of_closedEmbedding","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nhf : Topology.IsClosedEmbedding f\nâŠ¢ IsProperMap f","decl":"@[deprecated (since := \"2024-10-20\")]\nalias isProperMap_of_closedEmbedding := IsClosedEmbedding.isProperMap\n\n"}
{"name":"IsClosed.isProperMap_subtypeVal","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nC : Set X\nhC : IsClosed C\nâŠ¢ IsProperMap Subtype.val","decl":"/-- The coercion from a closed subset is proper. -/\nlemma IsClosed.isProperMap_subtypeVal {C : Set X} (hC : IsClosed C) : IsProperMap ((â†‘) : C â†’ X) :=\n  hC.isClosedEmbedding_subtypeVal.isProperMap\n\n"}
{"name":"isProperMap_subtype_val_of_closed","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nC : Set X\nhC : IsClosed C\nâŠ¢ IsProperMap Subtype.val","decl":"@[deprecated (since := \"2024-10-20\")]\nalias isProperMap_subtype_val_of_closed := IsClosed.isProperMap_subtypeVal\n\n"}
{"name":"IsProperMap.restrict","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nC : Set X\nhf : IsProperMap f\nhC : IsClosed C\nâŠ¢ IsProperMap fun x => f â†‘x","decl":"/-- The restriction of a proper map to a closed subset is proper. -/\nlemma IsProperMap.restrict {C : Set X} (hf : IsProperMap f) (hC : IsClosed C) :\n    IsProperMap fun x : C â†¦ f x := hC.isProperMap_subtypeVal.comp  hf\n\n"}
{"name":"isProperMap_restr_of_proper_of_closed","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nC : Set X\nhf : IsProperMap f\nhC : IsClosed C\nâŠ¢ IsProperMap fun x => f â†‘x","decl":"@[deprecated (since := \"2024-10-20\")]\nalias isProperMap_restr_of_proper_of_closed := IsProperMap.restrict\n\n"}
{"name":"IsProperMap.isClosed_range","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nhf : IsProperMap f\nâŠ¢ IsClosed (Set.range f)","decl":"/-- The range of a proper map is closed. -/\nlemma IsProperMap.isClosed_range (hf : IsProperMap f) : IsClosed (range f) :=\n  hf.isClosedMap.isClosed_range\n\n"}
{"name":"isProperMap_iff_isClosedMap_and_tendsto_cofinite","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\nf : X â†’ Y\ninstâœ : T1Space Y\nâŠ¢ Iff (IsProperMap f) (And (Continuous f) (And (IsClosedMap f) (Filter.Tendsto f (Filter.cocompact X) Filter.cofinite)))","decl":"/-- Version of `isProperMap_iff_isClosedMap_and_compact_fibers` in terms of `cofinite` and\n`cocompact`. Only works when the codomain is `T1`. -/\nlemma isProperMap_iff_isClosedMap_and_tendsto_cofinite [T1Space Y] :\n    IsProperMap f â†” Continuous f âˆ§ IsClosedMap f âˆ§ Tendsto f (cocompact X) cofinite := by\n  simp_rw [isProperMap_iff_isClosedMap_and_compact_fibers, Tendsto,\n    le_cofinite_iff_compl_singleton_mem, mem_map, preimage_compl]\n  refine and_congr_right fun f_cont â†¦ and_congr_right fun _ â†¦\n    âŸ¨fun H y â†¦ (H y).compl_mem_cocompact, fun H y â†¦ ?_âŸ©\n  rcases mem_cocompact.mp (H y) with âŸ¨K, hK, hKyâŸ©\n  exact hK.of_isClosed_subset (isClosed_singleton.preimage f_cont)\n    (compl_le_compl_iff_le.mp hKy)\n\n"}
{"name":"Continuous.isProperMap","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ³ : TopologicalSpace X\ninstâœÂ² : TopologicalSpace Y\nf : X â†’ Y\ninstâœÂ¹ : CompactSpace X\ninstâœ : T2Space Y\nhf : Continuous f\nâŠ¢ IsProperMap f","decl":"/-- A continuous map from a compact space to a Tâ‚‚ space is a proper map. -/\ntheorem Continuous.isProperMap [CompactSpace X] [T2Space Y] (hf : Continuous f) : IsProperMap f :=\n  isProperMap_iff_isClosedMap_and_tendsto_cofinite.2 âŸ¨hf, hf.isClosedMap, by simpâŸ©\n\n"}
{"name":"IsProperMap.universally_closed","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u_1\nY : Type u_2\ninstâœÂ² : TopologicalSpace X\ninstâœÂ¹ : TopologicalSpace Y\nf : X â†’ Y\nZ : Type u_6\ninstâœ : TopologicalSpace Z\nh : IsProperMap f\nâŠ¢ IsClosedMap (Prod.map f id)","decl":"/-- A proper map `f : X â†’ Y` is **universally closed**: for any topological space `Z`, the map\n`Prod.map f id : X Ã— Z â†’ Y Ã— Z` is closed. We will prove in `isProperMap_iff_universally_closed`\nthat proper maps are exactly continuous maps which have this property, but this result should be\neasier to use because it allows `Z` to live in any universe. -/\ntheorem IsProperMap.universally_closed (Z) [TopologicalSpace Z] (h : IsProperMap f) :\n    IsClosedMap (Prod.map f id : X Ã— Z â†’ Y Ã— Z) :=\n  -- `f Ã— id` is proper as a product of proper maps, hence closed.\n  (h.prodMap isProperMap_id).isClosedMap\n\n"}
{"name":"isProperMap_iff_isClosedMap_filter","module":"Mathlib.Topology.Maps.Proper.Basic","initialProofState":"X : Type u\nY : Type v\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : TopologicalSpace Y\nf : X â†’ Y\nâŠ¢ Iff (IsProperMap f) (And (Continuous f) (IsClosedMap (Prod.map f id)))","decl":"/-- A map `f : X â†’ Y` is proper if and only if it is continuous and the map\n`(Prod.map f id : X Ã— Filter X â†’ Y Ã— Filter X)` is closed. This is stronger than\n`isProperMap_iff_universally_closed` since it shows that there's only one space to check to get\nproperness, but in most cases it doesn't matter. -/\ntheorem isProperMap_iff_isClosedMap_filter {X : Type u} {Y : Type v} [TopologicalSpace X]\n    [TopologicalSpace Y] {f : X â†’ Y} :\n    IsProperMap f â†” Continuous f âˆ§ IsClosedMap\n      (Prod.map f id : X Ã— Filter X â†’ Y Ã— Filter X) := by\n  constructor <;> intro H\n  -- The direct implication is clear.\n  Â· exact âŸ¨H.continuous, H.universally_closed _âŸ©\n  Â· rw [isProperMap_iff_ultrafilter]\n  -- Let `ğ’° : Ultrafilter X`, and assume that `f` tends to some `y` along `ğ’°`.\n    refine âŸ¨H.1, fun ğ’° y hy â†¦ ?_âŸ©\n  -- In `X Ã— Filter X`, consider the closed set `F := closure {(x, â„±) | â„± = pure x}`\n    let F : Set (X Ã— Filter X) := closure {xâ„± | xâ„±.2 = pure xâ„±.1}\n  -- Since `f Ã— id` is closed, the set `(f Ã— id) '' F` is also closed.\n    have := H.2 F isClosed_closure\n  -- Let us show that `(y, ğ’°) âˆˆ (f Ã— id) '' F`.\n    have : (y, â†‘ğ’°) âˆˆ Prod.map f id '' F :=\n  -- Note that, by the properties of the topology on `Filter X`, the function `pure : X â†’ Filter X`\n  -- tends to the point `ğ’°` of `Filter X` along the filter `ğ’°` on `X`. Since `f` tends to `y` along\n  -- `ğ’°`, we get that the function `(f, pure) : X â†’ (Y, Filter X)` tends to `(y, ğ’°)` along\n  -- `ğ’°`. Furthermore, each `(f, pure)(x) = (f Ã— id)(x, pure x)` is clearly an element of\n  -- the closed set `(f Ã— id) '' F`, thus the limit `(y, ğ’°)` also belongs to that set.\n      this.mem_of_tendsto (hy.prod_mk_nhds (Filter.tendsto_pure_self (ğ’° : Filter X)))\n        (Eventually.of_forall fun x â†¦ âŸ¨âŸ¨x, pure xâŸ©, subset_closure rfl, rflâŸ©)\n  -- The above shows that `(y, ğ’°) = (f x, ğ’°)`, for some `x : X` such that `(x, ğ’°) âˆˆ F`.\n    rcases this with âŸ¨âŸ¨x, _âŸ©, hx, âŸ¨_, _âŸ©âŸ©\n  -- We already know that `f x = y`, so to finish the proof we just have to check that `ğ’°` tends\n  -- to `x`. So, for `U âˆˆ ğ“ x` arbitrary, let's show that `U âˆˆ ğ’°`. Since `ğ’°` is a ultrafilter,\n  -- it is enough to show that `Uá¶œ` is not in `ğ’°`.\n    refine âŸ¨x, rfl, fun U hU â†¦ Ultrafilter.compl_not_mem_iff.mp fun hUc â†¦ ?_âŸ©\n    rw [mem_closure_iff_nhds] at hx\n  -- Indeed, if that was the case, the set `V := {ğ’¢ : Filter X | Uá¶œ âˆˆ ğ’¢}` would be a neighborhood\n  -- of `ğ’°` in `Filter X`, hence `U Ã—Ë¢ V` would be a neighborhood of `(x, ğ’°) : X Ã— Filter X`.\n  -- But recall that `(x, ğ’°) âˆˆ F = closure {(x, â„±) | â„± = pure x}`, so the neighborhood `U Ã—Ë¢ V`\n  -- must contain some element of the form `(z, pure z)`. In other words, we have `z âˆˆ U` and\n  -- `Uá¶œ âˆˆ pure z`, which means `z âˆˆ Uá¶œ` by the definition of pure.\n  -- This is a contradiction, which completes the proof.\n    rcases hx (U Ã—Ë¢ {ğ’¢ | Uá¶œ âˆˆ ğ’¢}) (prod_mem_nhds hU (isOpen_setOf_mem.mem_nhds hUc)) with\n      âŸ¨âŸ¨z, ğ’¢âŸ©, âŸ¨âŸ¨hz : z âˆˆ U, hz' : Uá¶œ âˆˆ ğ’¢âŸ©, rfl : ğ’¢ = pure zâŸ©âŸ©\n    exact hz' hz\n"}
