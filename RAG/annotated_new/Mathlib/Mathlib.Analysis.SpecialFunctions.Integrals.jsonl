{"name":"intervalIntegral.intervalIntegrable_pow","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nn : Nat\nŒº : MeasureTheory.Measure Real\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\n‚ä¢ IntervalIntegrable (fun x => HPow.hPow x n) Œº a b","decl":"@[simp]\ntheorem intervalIntegrable_pow : IntervalIntegrable (fun x => x ^ n) Œº a b :=\n  (continuous_pow n).intervalIntegrable a b\n\n"}
{"name":"intervalIntegral.intervalIntegrable_zpow","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nŒº : MeasureTheory.Measure Real\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\nn : Int\nh : Or (LE.le 0 n) (Not (Membership.mem (Set.uIcc a b) 0))\n‚ä¢ IntervalIntegrable (fun x => HPow.hPow x n) Œº a b","decl":"theorem intervalIntegrable_zpow {n : ‚Ñ§} (h : 0 ‚â§ n ‚à® (0 : ‚Ñù) ‚àâ [[a, b]]) :\n    IntervalIntegrable (fun x => x ^ n) Œº a b :=\n  (continuousOn_id.zpow‚ÇÄ n fun _ hx => h.symm.imp (ne_of_mem_of_not_mem hx) id).intervalIntegrable\n\n"}
{"name":"intervalIntegral.intervalIntegrable_rpow","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nŒº : MeasureTheory.Measure Real\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\nr : Real\nh : Or (LE.le 0 r) (Not (Membership.mem (Set.uIcc a b) 0))\n‚ä¢ IntervalIntegrable (fun x => HPow.hPow x r) Œº a b","decl":"/-- See `intervalIntegrable_rpow'` for a version with a weaker hypothesis on `r`, but assuming the\nmeasure is volume. -/\ntheorem intervalIntegrable_rpow {r : ‚Ñù} (h : 0 ‚â§ r ‚à® (0 : ‚Ñù) ‚àâ [[a, b]]) :\n    IntervalIntegrable (fun x => x ^ r) Œº a b :=\n  (continuousOn_id.rpow_const fun _ hx =>\n    h.symm.imp (ne_of_mem_of_not_mem hx) id).intervalIntegrable\n\n"}
{"name":"intervalIntegral.intervalIntegrable_rpow'","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b r : Real\nh : LT.lt (-1) r\n‚ä¢ IntervalIntegrable (fun x => HPow.hPow x r) MeasureTheory.MeasureSpace.volume a b","decl":"/-- See `intervalIntegrable_rpow` for a version applying to any locally finite measure, but with a\nstronger hypothesis on `r`. -/\ntheorem intervalIntegrable_rpow' {r : ‚Ñù} (h : -1 < r) :\n    IntervalIntegrable (fun x => x ^ r) volume a b := by\n  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => x ^ r) volume 0 c by\n    exact IntervalIntegrable.trans (this a).symm (this b)\n  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => x ^ r) volume 0 c := by\n    intro c hc\n    rw [intervalIntegrable_iff, uIoc_of_le hc]\n    have hderiv : ‚àÄ x ‚àà Ioo 0 c, HasDerivAt (fun x : ‚Ñù => x ^ (r + 1) / (r + 1)) (x ^ r) x := by\n      intro x hx\n      convert (Real.hasDerivAt_rpow_const (p := r + 1) (Or.inl hx.1.ne')).div_const (r + 1) using 1\n      field_simp [(by linarith : r + 1 ‚â† 0)]\n    apply integrableOn_deriv_of_nonneg _ hderiv\n    ¬∑ intro x hx; apply rpow_nonneg hx.1.le\n    ¬∑ refine (continuousOn_id.rpow_const ?_).div_const _; intro x _; right; linarith\n  intro c; rcases le_total 0 c with (hc | hc)\n  ¬∑ exact this c hc\n  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]\n    have m := (this (-c) (by linarith)).smul (cos (r * œÄ))\n    rw [intervalIntegrable_iff] at m ‚ä¢\n    refine m.congr_fun ?_ measurableSet_Ioc; intro x hx\n    rw [uIoc_of_le (by linarith : 0 ‚â§ -c)] at hx\n    simp only [Pi.smul_apply, Algebra.id.smul_eq_mul, log_neg_eq_log, mul_comm,\n      rpow_def_of_pos hx.1, rpow_def_of_neg (by linarith [hx.1] : -x < 0)]\n\n"}
{"name":"intervalIntegral.integrableOn_Ioo_rpow_iff","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"s t : Real\nht : LT.lt 0 t\n‚ä¢ Iff (MeasureTheory.IntegrableOn (fun x => HPow.hPow x s) (Set.Ioo 0 t) MeasureTheory.MeasureSpace.volume) (LT.lt (-1) s)","decl":"/-- The power function `x ‚Ü¶ x^s` is integrable on `(0, t)` iff `-1 < s`. -/\nlemma integrableOn_Ioo_rpow_iff {s t : ‚Ñù} (ht : 0 < t) :\n    IntegrableOn (fun x ‚Ü¶ x ^ s) (Ioo (0 : ‚Ñù) t) ‚Üî -1 < s := by\n  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ by simpa [intervalIntegrable_iff_integrableOn_Ioo_of_le ht.le]\n    using intervalIntegrable_rpow' h (a := 0) (b := t)‚ü©\n  contrapose! h\n  intro H\n  have I : 0 < min 1 t := lt_min zero_lt_one ht\n  have H' : IntegrableOn (fun x ‚Ü¶ x ^ s) (Ioo 0 (min 1 t)) :=\n    H.mono (Set.Ioo_subset_Ioo le_rfl (min_le_right _ _)) le_rfl\n  have : IntegrableOn (fun x ‚Ü¶ x‚Åª¬π) (Ioo 0 (min 1 t)) := by\n    apply H'.mono' measurable_inv.aestronglyMeasurable\n    filter_upwards [ae_restrict_mem measurableSet_Ioo] with x hx\n    simp only [norm_inv, Real.norm_eq_abs, abs_of_nonneg (le_of_lt hx.1)]\n    rwa [‚Üê Real.rpow_neg_one x, Real.rpow_le_rpow_left_iff_of_base_lt_one hx.1]\n    exact lt_of_lt_of_le hx.2 (min_le_left _ _)\n  have : IntervalIntegrable (fun x ‚Ü¶ x‚Åª¬π) volume 0 (min 1 t) := by\n    rwa [intervalIntegrable_iff_integrableOn_Ioo_of_le I.le]\n  simp [intervalIntegrable_inv_iff, I.ne] at this\n\n"}
{"name":"intervalIntegral.intervalIntegrable_cpow","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nŒº : MeasureTheory.Measure Real\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\nr : Complex\nh : Or (LE.le 0 r.re) (Not (Membership.mem (Set.uIcc a b) 0))\n‚ä¢ IntervalIntegrable (fun x => HPow.hPow (‚Üëx) r) Œº a b","decl":"/-- See `intervalIntegrable_cpow'` for a version with a weaker hypothesis on `r`, but assuming the\nmeasure is volume. -/\ntheorem intervalIntegrable_cpow {r : ‚ÑÇ} (h : 0 ‚â§ r.re ‚à® (0 : ‚Ñù) ‚àâ [[a, b]]) :\n    IntervalIntegrable (fun x : ‚Ñù => (x : ‚ÑÇ) ^ r) Œº a b := by\n  by_cases h2 : (0 : ‚Ñù) ‚àâ [[a, b]]\n  ¬∑ -- Easy case #1: 0 ‚àâ [a, b] -- use continuity.\n    refine (continuousOn_of_forall_continuousAt fun x hx => ?_).intervalIntegrable\n    exact Complex.continuousAt_ofReal_cpow_const _ _ (Or.inr <| ne_of_mem_of_not_mem hx h2)\n  rw [eq_false h2, or_false] at h\n  rcases lt_or_eq_of_le h with (h' | h')\n  ¬∑ -- Easy case #2: 0 < re r -- again use continuity\n    exact (Complex.continuous_ofReal_cpow_const h').intervalIntegrable _ _\n  -- Now the hard case: re r = 0 and 0 is in the interval.\n  refine (IntervalIntegrable.intervalIntegrable_norm_iff ?_).mp ?_\n  ¬∑ refine (measurable_of_continuousOn_compl_singleton (0 : ‚Ñù) ?_).aestronglyMeasurable\n    exact continuousOn_of_forall_continuousAt fun x hx =>\n      Complex.continuousAt_ofReal_cpow_const x r (Or.inr hx)\n  -- reduce to case of integral over `[0, c]`\n  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x : ‚Ñù => ‚Äñ(x : ‚ÑÇ) ^ r‚Äñ) Œº 0 c from\n    (this a).symm.trans (this b)\n  intro c\n  rcases le_or_lt 0 c with (hc | hc)\n  ¬∑ -- case `0 ‚â§ c`: integrand is identically 1\n    have : IntervalIntegrable (fun _ => 1 : ‚Ñù ‚Üí ‚Ñù) Œº 0 c := intervalIntegrable_const\n    rw [intervalIntegrable_iff_integrableOn_Ioc_of_le hc] at this ‚ä¢\n    refine IntegrableOn.congr_fun this (fun x hx => ?_) measurableSet_Ioc\n    dsimp only\n    rw [Complex.norm_eq_abs, Complex.abs_cpow_eq_rpow_re_of_pos hx.1, ‚Üê h', rpow_zero]\n  ¬∑ -- case `c < 0`: integrand is identically constant, *except* at `x = 0` if `r ‚â† 0`.\n    apply IntervalIntegrable.symm\n    rw [intervalIntegrable_iff_integrableOn_Ioc_of_le hc.le]\n    rw [‚Üê Ioo_union_right hc, integrableOn_union, and_comm]; constructor\n    ¬∑ refine integrableOn_singleton_iff.mpr (Or.inr ?_)\n      exact isFiniteMeasureOnCompacts_of_isLocallyFiniteMeasure.lt_top_of_isCompact\n        isCompact_singleton\n    ¬∑ have : ‚àÄ x : ‚Ñù, x ‚àà Ioo c 0 ‚Üí ‚ÄñComplex.exp (‚ÜëœÄ * Complex.I * r)‚Äñ = ‚Äñ(x : ‚ÑÇ) ^ r‚Äñ := by\n        intro x hx\n        rw [Complex.ofReal_cpow_of_nonpos hx.2.le, norm_mul, ‚Üê Complex.ofReal_neg,\n          Complex.norm_eq_abs (_ ^ _), Complex.abs_cpow_eq_rpow_re_of_pos (neg_pos.mpr hx.2), ‚Üê h',\n          rpow_zero, one_mul]\n      refine IntegrableOn.congr_fun ?_ this measurableSet_Ioo\n      rw [integrableOn_const]\n      refine Or.inr ((measure_mono Set.Ioo_subset_Icc_self).trans_lt ?_)\n      exact isFiniteMeasureOnCompacts_of_isLocallyFiniteMeasure.lt_top_of_isCompact isCompact_Icc\n\n"}
{"name":"intervalIntegral.intervalIntegrable_cpow'","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nr : Complex\nh : LT.lt (-1) r.re\n‚ä¢ IntervalIntegrable (fun x => HPow.hPow (‚Üëx) r) MeasureTheory.MeasureSpace.volume a b","decl":"/-- See `intervalIntegrable_cpow` for a version applying to any locally finite measure, but with a\nstronger hypothesis on `r`. -/\ntheorem intervalIntegrable_cpow' {r : ‚ÑÇ} (h : -1 < r.re) :\n    IntervalIntegrable (fun x : ‚Ñù => (x : ‚ÑÇ) ^ r) volume a b := by\n  suffices ‚àÄ c : ‚Ñù, IntervalIntegrable (fun x => (x : ‚ÑÇ) ^ r) volume 0 c by\n    exact IntervalIntegrable.trans (this a).symm (this b)\n  have : ‚àÄ c : ‚Ñù, 0 ‚â§ c ‚Üí IntervalIntegrable (fun x => (x : ‚ÑÇ) ^ r) volume 0 c := by\n    intro c hc\n    rw [‚Üê IntervalIntegrable.intervalIntegrable_norm_iff]\n    ¬∑ rw [intervalIntegrable_iff]\n      apply IntegrableOn.congr_fun\n      ¬∑ rw [‚Üê intervalIntegrable_iff]; exact intervalIntegral.intervalIntegrable_rpow' h\n      ¬∑ intro x hx\n        rw [uIoc_of_le hc] at hx\n        dsimp only\n        rw [Complex.norm_eq_abs, Complex.abs_cpow_eq_rpow_re_of_pos hx.1]\n      ¬∑ exact measurableSet_uIoc\n    ¬∑ refine ContinuousOn.aestronglyMeasurable ?_ measurableSet_uIoc\n      refine continuousOn_of_forall_continuousAt fun x hx => ?_\n      rw [uIoc_of_le hc] at hx\n      refine (continuousAt_cpow_const (Or.inl ?_)).comp Complex.continuous_ofReal.continuousAt\n      rw [Complex.ofReal_re]\n      exact hx.1\n  intro c; rcases le_total 0 c with (hc | hc)\n  ¬∑ exact this c hc\n  ¬∑ rw [IntervalIntegrable.iff_comp_neg, neg_zero]\n    have m := (this (-c) (by linarith)).const_mul (Complex.exp (œÄ * Complex.I * r))\n    rw [intervalIntegrable_iff, uIoc_of_le (by linarith : 0 ‚â§ -c)] at m ‚ä¢\n    refine m.congr_fun (fun x hx => ?_) measurableSet_Ioc\n    dsimp only\n    have : -x ‚â§ 0 := by linarith [hx.1]\n    rw [Complex.ofReal_cpow_of_nonpos this, mul_comm]\n    simp\n\n"}
{"name":"intervalIntegral.integrableOn_Ioo_cpow_iff","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"s : Complex\nt : Real\nht : LT.lt 0 t\n‚ä¢ Iff (MeasureTheory.IntegrableOn (fun x => HPow.hPow (‚Üëx) s) (Set.Ioo 0 t) MeasureTheory.MeasureSpace.volume) (LT.lt (-1) s.re)","decl":"/-- The complex power function `x ‚Ü¶ x^s` is integrable on `(0, t)` iff `-1 < s.re`. -/\ntheorem integrableOn_Ioo_cpow_iff {s : ‚ÑÇ} {t : ‚Ñù} (ht : 0 < t) :\n    IntegrableOn (fun x : ‚Ñù ‚Ü¶ (x : ‚ÑÇ) ^ s) (Ioo (0 : ‚Ñù) t) ‚Üî -1 < s.re := by\n  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ by simpa [intervalIntegrable_iff_integrableOn_Ioo_of_le ht.le]\n    using intervalIntegrable_cpow' h (a := 0) (b := t)‚ü©\n  have B : IntegrableOn (fun a ‚Ü¶ a ^ s.re) (Ioo 0 t) := by\n    apply (integrableOn_congr_fun _ measurableSet_Ioo).1 h.norm\n    intro a ha\n    simp [Complex.abs_cpow_eq_rpow_re_of_pos ha.1]\n  rwa [integrableOn_Ioo_rpow_iff ht] at B\n\n"}
{"name":"intervalIntegral.intervalIntegrable_id","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nŒº : MeasureTheory.Measure Real\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\n‚ä¢ IntervalIntegrable (fun x => x) Œº a b","decl":"@[simp]\ntheorem intervalIntegrable_id : IntervalIntegrable (fun x => x) Œº a b :=\n  continuous_id.intervalIntegrable a b\n\n"}
{"name":"intervalIntegral.intervalIntegrable_const","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nŒº : MeasureTheory.Measure Real\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\nc : Real\n‚ä¢ IntervalIntegrable (fun x => c) Œº a b","decl":"theorem intervalIntegrable_const : IntervalIntegrable (fun _ => c) Œº a b :=\n  continuous_const.intervalIntegrable a b\n\n"}
{"name":"intervalIntegral.intervalIntegrable_one_div","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nf : Real ‚Üí Real\nŒº : MeasureTheory.Measure Real\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\nh : ‚àÄ (x : Real), Membership.mem (Set.uIcc a b) x ‚Üí Ne (f x) 0\nhf : ContinuousOn f (Set.uIcc a b)\n‚ä¢ IntervalIntegrable (fun x => HDiv.hDiv 1 (f x)) Œº a b","decl":"theorem intervalIntegrable_one_div (h : ‚àÄ x : ‚Ñù, x ‚àà [[a, b]] ‚Üí f x ‚â† 0)\n    (hf : ContinuousOn f [[a, b]]) : IntervalIntegrable (fun x => 1 / f x) Œº a b :=\n  (continuousOn_const.div hf h).intervalIntegrable\n\n"}
{"name":"intervalIntegral.intervalIntegrable_inv","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nf : Real ‚Üí Real\nŒº : MeasureTheory.Measure Real\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\nh : ‚àÄ (x : Real), Membership.mem (Set.uIcc a b) x ‚Üí Ne (f x) 0\nhf : ContinuousOn f (Set.uIcc a b)\n‚ä¢ IntervalIntegrable (fun x => Inv.inv (f x)) Œº a b","decl":"@[simp]\ntheorem intervalIntegrable_inv (h : ‚àÄ x : ‚Ñù, x ‚àà [[a, b]] ‚Üí f x ‚â† 0)\n    (hf : ContinuousOn f [[a, b]]) : IntervalIntegrable (fun x => (f x)‚Åª¬π) Œº a b := by\n  simpa only [one_div] using intervalIntegrable_one_div h hf\n\n"}
{"name":"intervalIntegral.intervalIntegrable_exp","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nŒº : MeasureTheory.Measure Real\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\n‚ä¢ IntervalIntegrable Real.exp Œº a b","decl":"@[simp]\ntheorem intervalIntegrable_exp : IntervalIntegrable exp Œº a b :=\n  continuous_exp.intervalIntegrable a b\n\n"}
{"name":"IntervalIntegrable.log","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nf : Real ‚Üí Real\nŒº : MeasureTheory.Measure Real\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\nhf : ContinuousOn f (Set.uIcc a b)\nh : ‚àÄ (x : Real), Membership.mem (Set.uIcc a b) x ‚Üí Ne (f x) 0\n‚ä¢ IntervalIntegrable (fun x => Real.log (f x)) Œº a b","decl":"@[simp]\ntheorem _root_.IntervalIntegrable.log (hf : ContinuousOn f [[a, b]])\n    (h : ‚àÄ x : ‚Ñù, x ‚àà [[a, b]] ‚Üí f x ‚â† 0) :\n    IntervalIntegrable (fun x => log (f x)) Œº a b :=\n  (ContinuousOn.log hf h).intervalIntegrable\n\n"}
{"name":"intervalIntegral.intervalIntegrable_log","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nŒº : MeasureTheory.Measure Real\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\nh : Not (Membership.mem (Set.uIcc a b) 0)\n‚ä¢ IntervalIntegrable Real.log Œº a b","decl":"/-- See `intervalIntegrable_log'` for a version without any hypothesis on the interval, but\nassuming the measure is volume. -/\n@[simp]\ntheorem intervalIntegrable_log (h : (0 : ‚Ñù) ‚àâ [[a, b]]) : IntervalIntegrable log Œº a b :=\n  IntervalIntegrable.log continuousOn_id fun _ hx => ne_of_mem_of_not_mem hx h\n\n"}
{"name":"intervalIntegral.intervalIntegrable_log'","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ IntervalIntegrable Real.log MeasureTheory.MeasureSpace.volume a b","decl":"/-- The real logarithm is interval integrable (with respect to the volume measure) on every\ninterval. See `intervalIntegrable_log` for a version applying to any locally finite measure,\nbut with an additional hypothesis on the interval. -/\n@[simp]\ntheorem intervalIntegrable_log' : IntervalIntegrable log volume a b := by\n  -- Log is even, so it suffices to consider the case 0 < a and b = 0\n  apply intervalIntegrable_of_even (log_neg_eq_log ¬∑ |>.symm)\n  intro x hx\n  -- Split integral\n  apply IntervalIntegrable.trans (b := 1)\n  ¬∑ -- Show integrability on [0‚Ä¶1] using non-negativity of the derivative\n    rw [‚Üê neg_neg log]\n    apply IntervalIntegrable.neg\n    apply intervalIntegrable_deriv_of_nonneg (g := fun x ‚Ü¶ -(x * log x - x))\n    ¬∑ exact (continuous_mul_log.continuousOn.sub continuous_id.continuousOn).neg\n    ¬∑ intro s ‚ü®hs, _‚ü©\n      norm_num at *\n      simpa using (hasDerivAt_id s).sub (hasDerivAt_mul_log hs.ne.symm)\n    ¬∑ intro s ‚ü®hs‚ÇÅ, hs‚ÇÇ‚ü©\n      norm_num at *\n      exact (log_nonpos_iff hs‚ÇÅ.le).mpr hs‚ÇÇ.le\n  ¬∑ -- Show integrability on [1‚Ä¶t] by continuity\n    apply ContinuousOn.intervalIntegrable\n    apply Real.continuousOn_log.mono\n    apply Set.not_mem_uIcc_of_lt zero_lt_one at hx\n    simpa\n\n"}
{"name":"intervalIntegral.intervalIntegrable_sin","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nŒº : MeasureTheory.Measure Real\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\n‚ä¢ IntervalIntegrable Real.sin Œº a b","decl":"@[simp]\ntheorem intervalIntegrable_sin : IntervalIntegrable sin Œº a b :=\n  continuous_sin.intervalIntegrable a b\n\n"}
{"name":"intervalIntegral.intervalIntegrable_cos","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nŒº : MeasureTheory.Measure Real\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\n‚ä¢ IntervalIntegrable Real.cos Œº a b","decl":"@[simp]\ntheorem intervalIntegrable_cos : IntervalIntegrable cos Œº a b :=\n  continuous_cos.intervalIntegrable a b\n\n"}
{"name":"intervalIntegral.intervalIntegrable_one_div_one_add_sq","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nŒº : MeasureTheory.Measure Real\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\n‚ä¢ IntervalIntegrable (fun x => HDiv.hDiv 1 (HAdd.hAdd 1 (HPow.hPow x 2))) Œº a b","decl":"theorem intervalIntegrable_one_div_one_add_sq :\n    IntervalIntegrable (fun x : ‚Ñù => 1 / (‚Üë1 + x ^ 2)) Œº a b := by\n  refine (continuous_const.div ?_ fun x => ?_).intervalIntegrable a b\n  ¬∑ fun_prop\n  ¬∑ nlinarith\n\n"}
{"name":"intervalIntegral.intervalIntegrable_inv_one_add_sq","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nŒº : MeasureTheory.Measure Real\ninst‚úù : MeasureTheory.IsLocallyFiniteMeasure Œº\n‚ä¢ IntervalIntegrable (fun x => Inv.inv (HAdd.hAdd 1 (HPow.hPow x 2))) Œº a b","decl":"@[simp]\ntheorem intervalIntegrable_inv_one_add_sq :\n    IntervalIntegrable (fun x : ‚Ñù => (‚Üë1 + x ^ 2)‚Åª¬π) Œº a b := by\n  field_simp; exact mod_cast intervalIntegrable_one_div_one_add_sq\n\n"}
{"name":"intervalIntegral.mul_integral_comp_mul_right","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nf : Real ‚Üí Real\nc : Real\n‚ä¢ Eq (HMul.hMul c (intervalIntegral (fun x => f (HMul.hMul x c)) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HMul.hMul a c) (HMul.hMul b c) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem mul_integral_comp_mul_right : (c * ‚à´ x in a..b, f (x * c)) = ‚à´ x in a * c..b * c, f x :=\n  smul_integral_comp_mul_right f c\n\n"}
{"name":"intervalIntegral.mul_integral_comp_mul_left","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nf : Real ‚Üí Real\nc : Real\n‚ä¢ Eq (HMul.hMul c (intervalIntegral (fun x => f (HMul.hMul c x)) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HMul.hMul c a) (HMul.hMul c b) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem mul_integral_comp_mul_left : (c * ‚à´ x in a..b, f (c * x)) = ‚à´ x in c * a..c * b, f x :=\n  smul_integral_comp_mul_left f c\n\n"}
{"name":"intervalIntegral.inv_mul_integral_comp_div","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nf : Real ‚Üí Real\nc : Real\n‚ä¢ Eq (HMul.hMul (Inv.inv c) (intervalIntegral (fun x => f (HDiv.hDiv x c)) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HDiv.hDiv a c) (HDiv.hDiv b c) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem inv_mul_integral_comp_div : (c‚Åª¬π * ‚à´ x in a..b, f (x / c)) = ‚à´ x in a / c..b / c, f x :=\n  inv_smul_integral_comp_div f c\n\n"}
{"name":"intervalIntegral.mul_integral_comp_mul_add","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nf : Real ‚Üí Real\nc d : Real\n‚ä¢ Eq (HMul.hMul c (intervalIntegral (fun x => f (HAdd.hAdd (HMul.hMul c x) d)) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HAdd.hAdd (HMul.hMul c a) d) (HAdd.hAdd (HMul.hMul c b) d) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem mul_integral_comp_mul_add :\n    (c * ‚à´ x in a..b, f (c * x + d)) = ‚à´ x in c * a + d..c * b + d, f x :=\n  smul_integral_comp_mul_add f c d\n\n"}
{"name":"intervalIntegral.mul_integral_comp_add_mul","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nf : Real ‚Üí Real\nc d : Real\n‚ä¢ Eq (HMul.hMul c (intervalIntegral (fun x => f (HAdd.hAdd d (HMul.hMul c x))) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HAdd.hAdd d (HMul.hMul c a)) (HAdd.hAdd d (HMul.hMul c b)) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem mul_integral_comp_add_mul :\n    (c * ‚à´ x in a..b, f (d + c * x)) = ‚à´ x in d + c * a..d + c * b, f x :=\n  smul_integral_comp_add_mul f c d\n\n"}
{"name":"intervalIntegral.inv_mul_integral_comp_div_add","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nf : Real ‚Üí Real\nc d : Real\n‚ä¢ Eq (HMul.hMul (Inv.inv c) (intervalIntegral (fun x => f (HAdd.hAdd (HDiv.hDiv x c) d)) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HAdd.hAdd (HDiv.hDiv a c) d) (HAdd.hAdd (HDiv.hDiv b c) d) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem inv_mul_integral_comp_div_add :\n    (c‚Åª¬π * ‚à´ x in a..b, f (x / c + d)) = ‚à´ x in a / c + d..b / c + d, f x :=\n  inv_smul_integral_comp_div_add f c d\n\n"}
{"name":"intervalIntegral.inv_mul_integral_comp_add_div","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nf : Real ‚Üí Real\nc d : Real\n‚ä¢ Eq (HMul.hMul (Inv.inv c) (intervalIntegral (fun x => f (HAdd.hAdd d (HDiv.hDiv x c))) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HAdd.hAdd d (HDiv.hDiv a c)) (HAdd.hAdd d (HDiv.hDiv b c)) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem inv_mul_integral_comp_add_div :\n    (c‚Åª¬π * ‚à´ x in a..b, f (d + x / c)) = ‚à´ x in d + a / c..d + b / c, f x :=\n  inv_smul_integral_comp_add_div f c d\n\n"}
{"name":"intervalIntegral.mul_integral_comp_mul_sub","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nf : Real ‚Üí Real\nc d : Real\n‚ä¢ Eq (HMul.hMul c (intervalIntegral (fun x => f (HSub.hSub (HMul.hMul c x) d)) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HSub.hSub (HMul.hMul c a) d) (HSub.hSub (HMul.hMul c b) d) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem mul_integral_comp_mul_sub :\n    (c * ‚à´ x in a..b, f (c * x - d)) = ‚à´ x in c * a - d..c * b - d, f x :=\n  smul_integral_comp_mul_sub f c d\n\n"}
{"name":"intervalIntegral.mul_integral_comp_sub_mul","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nf : Real ‚Üí Real\nc d : Real\n‚ä¢ Eq (HMul.hMul c (intervalIntegral (fun x => f (HSub.hSub d (HMul.hMul c x))) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HSub.hSub d (HMul.hMul c b)) (HSub.hSub d (HMul.hMul c a)) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem mul_integral_comp_sub_mul :\n    (c * ‚à´ x in a..b, f (d - c * x)) = ‚à´ x in d - c * b..d - c * a, f x :=\n  smul_integral_comp_sub_mul f c d\n\n"}
{"name":"intervalIntegral.inv_mul_integral_comp_div_sub","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nf : Real ‚Üí Real\nc d : Real\n‚ä¢ Eq (HMul.hMul (Inv.inv c) (intervalIntegral (fun x => f (HSub.hSub (HDiv.hDiv x c) d)) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HSub.hSub (HDiv.hDiv a c) d) (HSub.hSub (HDiv.hDiv b c) d) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem inv_mul_integral_comp_div_sub :\n    (c‚Åª¬π * ‚à´ x in a..b, f (x / c - d)) = ‚à´ x in a / c - d..b / c - d, f x :=\n  inv_smul_integral_comp_div_sub f c d\n\n"}
{"name":"intervalIntegral.inv_mul_integral_comp_sub_div","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nf : Real ‚Üí Real\nc d : Real\n‚ä¢ Eq (HMul.hMul (Inv.inv c) (intervalIntegral (fun x => f (HSub.hSub d (HDiv.hDiv x c))) a b MeasureTheory.MeasureSpace.volume)) (intervalIntegral (fun x => f x) (HSub.hSub d (HDiv.hDiv b c)) (HSub.hSub d (HDiv.hDiv a c)) MeasureTheory.MeasureSpace.volume)","decl":"@[simp]\ntheorem inv_mul_integral_comp_sub_div :\n    (c‚Åª¬π * ‚à´ x in a..b, f (d - x / c)) = ‚à´ x in d - b / c..d - a / c, f x :=\n  inv_smul_integral_comp_sub_div f c d\n\n"}
{"name":"integral_cpow","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nr : Complex\nh : Or (LT.lt (-1) r.re) (And (Ne r (-1)) (Not (Membership.mem (Set.uIcc a b) 0)))\n‚ä¢ Eq (intervalIntegral (fun x => HPow.hPow (‚Üëx) r) a b MeasureTheory.MeasureSpace.volume) (HDiv.hDiv (HSub.hSub (HPow.hPow (‚Üëb) (HAdd.hAdd r 1)) (HPow.hPow (‚Üëa) (HAdd.hAdd r 1))) (HAdd.hAdd r 1))","decl":"theorem integral_cpow {r : ‚ÑÇ} (h : -1 < r.re ‚à® r ‚â† -1 ‚àß (0 : ‚Ñù) ‚àâ [[a, b]]) :\n    (‚à´ x : ‚Ñù in a..b, (x : ‚ÑÇ) ^ r) = ((b : ‚ÑÇ) ^ (r + 1) - (a : ‚ÑÇ) ^ (r + 1)) / (r + 1) := by\n  rw [sub_div]\n  have hr : r + 1 ‚â† 0 := by\n    cases' h with h h\n    ¬∑ apply_fun Complex.re\n      rw [Complex.add_re, Complex.one_re, Complex.zero_re, Ne, add_eq_zero_iff_eq_neg]\n      exact h.ne'\n    ¬∑ rw [Ne, ‚Üê add_eq_zero_iff_eq_neg] at h; exact h.1\n  by_cases hab : (0 : ‚Ñù) ‚àâ [[a, b]]\n  ¬∑ apply integral_eq_sub_of_hasDerivAt (fun x hx => ?_)\n      (intervalIntegrable_cpow (r := r) <| Or.inr hab)\n    refine hasDerivAt_ofReal_cpow_const' (ne_of_mem_of_not_mem hx hab) ?_\n    contrapose! hr; rwa [add_eq_zero_iff_eq_neg]\n  replace h : -1 < r.re := by tauto\n  suffices ‚àÄ c : ‚Ñù, (‚à´ x : ‚Ñù in (0)..c, (x : ‚ÑÇ) ^ r) =\n      (c : ‚ÑÇ) ^ (r + 1) / (r + 1) - (0 : ‚ÑÇ) ^ (r + 1) / (r + 1) by\n    rw [‚Üê integral_add_adjacent_intervals (@intervalIntegrable_cpow' a 0 r h)\n      (@intervalIntegrable_cpow' 0 b r h), integral_symm, this a, this b, Complex.zero_cpow hr]\n    ring\n  intro c\n  apply integral_eq_sub_of_hasDeriv_right\n  ¬∑ refine ((Complex.continuous_ofReal_cpow_const ?_).div_const _).continuousOn\n    rwa [Complex.add_re, Complex.one_re, ‚Üê neg_lt_iff_pos_add]\n  ¬∑ refine fun x hx => (hasDerivAt_ofReal_cpow_const' ?_ ?_).hasDerivWithinAt\n    ¬∑ rcases le_total c 0 with (hc | hc)\n      ¬∑ rw [max_eq_left hc] at hx; exact hx.2.ne\n      ¬∑ rw [min_eq_left hc] at hx; exact hx.1.ne'\n    ¬∑ contrapose! hr; rw [hr]; ring\n  ¬∑ exact intervalIntegrable_cpow' h\n\n"}
{"name":"integral_rpow","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b r : Real\nh : Or (LT.lt (-1) r) (And (Ne r (-1)) (Not (Membership.mem (Set.uIcc a b) 0)))\n‚ä¢ Eq (intervalIntegral (fun x => HPow.hPow x r) a b MeasureTheory.MeasureSpace.volume) (HDiv.hDiv (HSub.hSub (HPow.hPow b (HAdd.hAdd r 1)) (HPow.hPow a (HAdd.hAdd r 1))) (HAdd.hAdd r 1))","decl":"theorem integral_rpow {r : ‚Ñù} (h : -1 < r ‚à® r ‚â† -1 ‚àß (0 : ‚Ñù) ‚àâ [[a, b]]) :\n    ‚à´ x in a..b, x ^ r = (b ^ (r + 1) - a ^ (r + 1)) / (r + 1) := by\n  have h' : -1 < (r : ‚ÑÇ).re ‚à® (r : ‚ÑÇ) ‚â† -1 ‚àß (0 : ‚Ñù) ‚àâ [[a, b]] := by\n    cases h\n    ¬∑ left; rwa [Complex.ofReal_re]\n    ¬∑ right; rwa [‚Üê Complex.ofReal_one, ‚Üê Complex.ofReal_neg, Ne, Complex.ofReal_inj]\n  have :\n    (‚à´ x in a..b, (x : ‚ÑÇ) ^ (r : ‚ÑÇ)) = ((b : ‚ÑÇ) ^ (r + 1 : ‚ÑÇ) - (a : ‚ÑÇ) ^ (r + 1 : ‚ÑÇ)) / (r + 1) :=\n    integral_cpow h'\n  apply_fun Complex.re at this; convert this\n  ¬∑ simp_rw [intervalIntegral_eq_integral_uIoc, Complex.real_smul, Complex.re_ofReal_mul]\n    -- Porting note: was `change ... with ...`\n    have : Complex.re = RCLike.re := rfl\n    rw [this, ‚Üê integral_re]\n    ¬∑ rfl\n    refine intervalIntegrable_iff.mp ?_\n    cases' h' with h' h'\n    ¬∑ exact intervalIntegrable_cpow' h'\n    ¬∑ exact intervalIntegrable_cpow (Or.inr h'.2)\n  ¬∑ rw [(by push_cast; rfl : (r : ‚ÑÇ) + 1 = ((r + 1 : ‚Ñù) : ‚ÑÇ))]\n    simp_rw [div_eq_inv_mul, ‚Üê Complex.ofReal_inv, Complex.re_ofReal_mul, Complex.sub_re]\n    rfl\n\n"}
{"name":"integral_zpow","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nn : Int\nh : Or (LE.le 0 n) (And (Ne n (-1)) (Not (Membership.mem (Set.uIcc a b) 0)))\n‚ä¢ Eq (intervalIntegral (fun x => HPow.hPow x n) a b MeasureTheory.MeasureSpace.volume) (HDiv.hDiv (HSub.hSub (HPow.hPow b (HAdd.hAdd n 1)) (HPow.hPow a (HAdd.hAdd n 1))) (HAdd.hAdd (‚Üën) 1))","decl":"theorem integral_zpow {n : ‚Ñ§} (h : 0 ‚â§ n ‚à® n ‚â† -1 ‚àß (0 : ‚Ñù) ‚àâ [[a, b]]) :\n    ‚à´ x in a..b, x ^ n = (b ^ (n + 1) - a ^ (n + 1)) / (n + 1) := by\n  replace h : -1 < (n : ‚Ñù) ‚à® (n : ‚Ñù) ‚â† -1 ‚àß (0 : ‚Ñù) ‚àâ [[a, b]] := mod_cast h\n  exact mod_cast integral_rpow h\n\n"}
{"name":"integral_pow","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nn : Nat\n‚ä¢ Eq (intervalIntegral (fun x => HPow.hPow x n) a b MeasureTheory.MeasureSpace.volume) (HDiv.hDiv (HSub.hSub (HPow.hPow b (HAdd.hAdd n 1)) (HPow.hPow a (HAdd.hAdd n 1))) (HAdd.hAdd (‚Üën) 1))","decl":"@[simp]\ntheorem integral_pow : ‚à´ x in a..b, x ^ n = (b ^ (n + 1) - a ^ (n + 1)) / (n + 1) := by\n  simpa only [‚Üê Int.ofNat_succ, zpow_natCast] using integral_zpow (Or.inl n.cast_nonneg)\n\n"}
{"name":"integral_pow_abs_sub_uIoc","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nn : Nat\n‚ä¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.uIoc a b)) fun x => HPow.hPow (abs (HSub.hSub x a)) n) (HDiv.hDiv (HPow.hPow (abs (HSub.hSub b a)) (HAdd.hAdd n 1)) (HAdd.hAdd (‚Üën) 1))","decl":"/-- Integral of `|x - a| ^ n` over `Œô a b`. This integral appears in the proof of the\nPicard-Lindel√∂f/Cauchy-Lipschitz theorem. -/\ntheorem integral_pow_abs_sub_uIoc : ‚à´ x in Œô a b, |x - a| ^ n = |b - a| ^ (n + 1) / (n + 1) := by\n  rcases le_or_lt a b with hab | hab\n  ¬∑ calc\n      ‚à´ x in Œô a b, |x - a| ^ n = ‚à´ x in a..b, |x - a| ^ n := by\n        rw [uIoc_of_le hab, ‚Üê integral_of_le hab]\n      _ = ‚à´ x in (0)..(b - a), x ^ n := by\n        simp only [integral_comp_sub_right fun x => |x| ^ n, sub_self]\n        refine integral_congr fun x hx => congr_arg‚ÇÇ Pow.pow (abs_of_nonneg <| ?_) rfl\n        rw [uIcc_of_le (sub_nonneg.2 hab)] at hx\n        exact hx.1\n      _ = |b - a| ^ (n + 1) / (n + 1) := by simp [abs_of_nonneg (sub_nonneg.2 hab)]\n  ¬∑ calc\n      ‚à´ x in Œô a b, |x - a| ^ n = ‚à´ x in b..a, |x - a| ^ n := by\n        rw [uIoc_of_ge hab.le, ‚Üê integral_of_le hab.le]\n      _ = ‚à´ x in b - a..0, (-x) ^ n := by\n        simp only [integral_comp_sub_right fun x => |x| ^ n, sub_self]\n        refine integral_congr fun x hx => congr_arg‚ÇÇ Pow.pow (abs_of_nonpos <| ?_) rfl\n        rw [uIcc_of_le (sub_nonpos.2 hab.le)] at hx\n        exact hx.2\n      _ = |b - a| ^ (n + 1) / (n + 1) := by\n        simp [integral_comp_neg fun x => x ^ n, abs_of_neg (sub_neg.2 hab)]\n\n"}
{"name":"integral_id","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ Eq (intervalIntegral (fun x => x) a b MeasureTheory.MeasureSpace.volume) (HDiv.hDiv (HSub.hSub (HPow.hPow b 2) (HPow.hPow a 2)) 2)","decl":"@[simp]\ntheorem integral_id : ‚à´ x in a..b, x = (b ^ 2 - a ^ 2) / 2 := by\n  have := @integral_pow a b 1\n  norm_num at this\n  exact this\n\n"}
{"name":"integral_one","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ Eq (intervalIntegral (fun x => 1) a b MeasureTheory.MeasureSpace.volume) (HSub.hSub b a)","decl":"theorem integral_one : (‚à´ _ in a..b, (1 : ‚Ñù)) = b - a := by\n  simp only [mul_one, smul_eq_mul, integral_const]\n\n"}
{"name":"integral_const_on_unit_interval","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ Eq (intervalIntegral (fun x => b) a (HAdd.hAdd a 1) MeasureTheory.MeasureSpace.volume) b","decl":"theorem integral_const_on_unit_interval : ‚à´ _ in a..a + 1, b = b := by simp\n\n"}
{"name":"integral_inv","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nh : Not (Membership.mem (Set.uIcc a b) 0)\n‚ä¢ Eq (intervalIntegral (fun x => Inv.inv x) a b MeasureTheory.MeasureSpace.volume) (Real.log (HDiv.hDiv b a))","decl":"@[simp]\ntheorem integral_inv (h : (0 : ‚Ñù) ‚àâ [[a, b]]) : ‚à´ x in a..b, x‚Åª¬π = log (b / a) := by\n  have h' := fun x (hx : x ‚àà [[a, b]]) => ne_of_mem_of_not_mem hx h\n  rw [integral_deriv_eq_sub' _ deriv_log' (fun x hx => differentiableAt_log (h' x hx))\n      (continuousOn_inv‚ÇÄ.mono <| subset_compl_singleton_iff.mpr h),\n    log_div (h' b right_mem_uIcc) (h' a left_mem_uIcc)]\n\n"}
{"name":"integral_inv_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nha : LT.lt 0 a\nhb : LT.lt 0 b\n‚ä¢ Eq (intervalIntegral (fun x => Inv.inv x) a b MeasureTheory.MeasureSpace.volume) (Real.log (HDiv.hDiv b a))","decl":"@[simp]\ntheorem integral_inv_of_pos (ha : 0 < a) (hb : 0 < b) : ‚à´ x in a..b, x‚Åª¬π = log (b / a) :=\n  integral_inv <| not_mem_uIcc_of_lt ha hb\n\n"}
{"name":"integral_inv_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nha : LT.lt a 0\nhb : LT.lt b 0\n‚ä¢ Eq (intervalIntegral (fun x => Inv.inv x) a b MeasureTheory.MeasureSpace.volume) (Real.log (HDiv.hDiv b a))","decl":"@[simp]\ntheorem integral_inv_of_neg (ha : a < 0) (hb : b < 0) : ‚à´ x in a..b, x‚Åª¬π = log (b / a) :=\n  integral_inv <| not_mem_uIcc_of_gt ha hb\n\n"}
{"name":"integral_one_div","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nh : Not (Membership.mem (Set.uIcc a b) 0)\n‚ä¢ Eq (intervalIntegral (fun x => HDiv.hDiv 1 x) a b MeasureTheory.MeasureSpace.volume) (Real.log (HDiv.hDiv b a))","decl":"theorem integral_one_div (h : (0 : ‚Ñù) ‚àâ [[a, b]]) : ‚à´ x : ‚Ñù in a..b, 1 / x = log (b / a) := by\n  simp only [one_div, integral_inv h]\n\n"}
{"name":"integral_one_div_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nha : LT.lt 0 a\nhb : LT.lt 0 b\n‚ä¢ Eq (intervalIntegral (fun x => HDiv.hDiv 1 x) a b MeasureTheory.MeasureSpace.volume) (Real.log (HDiv.hDiv b a))","decl":"theorem integral_one_div_of_pos (ha : 0 < a) (hb : 0 < b) :\n    ‚à´ x : ‚Ñù in a..b, 1 / x = log (b / a) := by simp only [one_div, integral_inv_of_pos ha hb]\n\n"}
{"name":"integral_one_div_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nha : LT.lt a 0\nhb : LT.lt b 0\n‚ä¢ Eq (intervalIntegral (fun x => HDiv.hDiv 1 x) a b MeasureTheory.MeasureSpace.volume) (Real.log (HDiv.hDiv b a))","decl":"theorem integral_one_div_of_neg (ha : a < 0) (hb : b < 0) :\n    ‚à´ x : ‚Ñù in a..b, 1 / x = log (b / a) := by simp only [one_div, integral_inv_of_neg ha hb]\n\n"}
{"name":"integral_exp","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ Eq (intervalIntegral (fun x => Real.exp x) a b MeasureTheory.MeasureSpace.volume) (HSub.hSub (Real.exp b) (Real.exp a))","decl":"@[simp]\ntheorem integral_exp : ‚à´ x in a..b, exp x = exp b - exp a := by\n  rw [integral_deriv_eq_sub']\n  ¬∑ simp\n  ¬∑ exact fun _ _ => differentiableAt_exp\n  ¬∑ exact continuousOn_exp\n\n"}
{"name":"integral_exp_mul_complex","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nc : Complex\nhc : Ne c 0\n‚ä¢ Eq (intervalIntegral (fun x => Complex.exp (HMul.hMul c ‚Üëx)) a b MeasureTheory.MeasureSpace.volume) (HDiv.hDiv (HSub.hSub (Complex.exp (HMul.hMul c ‚Üëb)) (Complex.exp (HMul.hMul c ‚Üëa))) c)","decl":"theorem integral_exp_mul_complex {c : ‚ÑÇ} (hc : c ‚â† 0) :\n    (‚à´ x in a..b, Complex.exp (c * x)) = (Complex.exp (c * b) - Complex.exp (c * a)) / c := by\n  have D : ‚àÄ x : ‚Ñù, HasDerivAt (fun y : ‚Ñù => Complex.exp (c * y) / c) (Complex.exp (c * x)) x := by\n    intro x\n    conv => congr\n    rw [‚Üê mul_div_cancel_right‚ÇÄ (Complex.exp (c * x)) hc]\n    apply ((Complex.hasDerivAt_exp _).comp x _).div_const c\n    simpa only [mul_one] using ((hasDerivAt_id (x : ‚ÑÇ)).const_mul _).comp_ofReal\n  rw [integral_deriv_eq_sub' _ (funext fun x => (D x).deriv) fun x _ => (D x).differentiableAt]\n  ¬∑ ring\n  ¬∑ fun_prop\n\n"}
{"name":"integral_log_from_zero_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"b : Real\nht : LT.lt 0 b\n‚ä¢ Eq (intervalIntegral (fun s => Real.log s) 0 b MeasureTheory.MeasureSpace.volume) (HSub.hSub (HMul.hMul b (Real.log b)) b)","decl":"/-- Helper lemma for `integral_log`: case where `a = 0` and `b` is positive. -/\nlemma integral_log_from_zero_of_pos (ht : 0 < b) : ‚à´ s in (0)..b, log s = b * log b - b := by\n  -- Compute the integral by giving a primitive and considering it limit as x approaches 0 from the\n  -- right. The following lines were suggested by Gareth Ma on Zulip.\n  rw [integral_eq_sub_of_hasDerivAt_of_tendsto (f := fun x ‚Ü¶ x * log x - x)\n    (fa := 0) (fb := b * log b - b) (hint := intervalIntegrable_log')]\n  ¬∑ abel\n  ¬∑ exact ht\n  ¬∑ intro s ‚ü®hs, _ ‚ü©\n    simpa using (hasDerivAt_mul_log hs.ne.symm).sub (hasDerivAt_id s)\n  ¬∑ simpa [mul_comm] using ((tendsto_log_mul_rpow_nhds_zero zero_lt_one).sub\n      (tendsto_nhdsWithin_of_tendsto_nhds Filter.tendsto_id))\n  ¬∑ exact tendsto_nhdsWithin_of_tendsto_nhds (ContinuousAt.tendsto (by fun_prop))\n\n"}
{"name":"integral_log_from_zero","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"b : Real\n‚ä¢ Eq (intervalIntegral (fun s => Real.log s) 0 b MeasureTheory.MeasureSpace.volume) (HSub.hSub (HMul.hMul b (Real.log b)) b)","decl":"/-- Helper lemma for `integral_log`: case where `a = 0`. -/\nlemma integral_log_from_zero {b : ‚Ñù} : ‚à´ s in (0)..b, log s = b * log b - b := by\n    rcases lt_trichotomy b 0 with h | h | h\n    ¬∑ -- If t is negative, use that log is an even function to reduce to the positive case.\n      conv => arg 1; arg 1; intro t; rw [‚Üê log_neg_eq_log]\n      rw [intervalIntegral.integral_comp_neg, intervalIntegral.integral_symm, neg_zero,\n        integral_log_from_zero_of_pos (Left.neg_pos_iff.mpr h), log_neg_eq_log]\n      ring\n    ¬∑ simp [h]\n    ¬∑ exact integral_log_from_zero_of_pos h\n\n"}
{"name":"integral_log","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ Eq (intervalIntegral (fun s => Real.log s) a b MeasureTheory.MeasureSpace.volume) (HAdd.hAdd (HSub.hSub (HSub.hSub (HMul.hMul b (Real.log b)) (HMul.hMul a (Real.log a))) b) a)","decl":"@[simp]\ntheorem integral_log : ‚à´ s in a..b, log s = b * log b - a * log a - b + a := by\n  rw [‚Üê intervalIntegral.integral_add_adjacent_intervals (b := 0)]\n  ¬∑ rw [intervalIntegral.integral_symm, integral_log_from_zero, integral_log_from_zero]\n    ring\n  all_goals exact intervalIntegrable_log'\n\n"}
{"name":"integral_log_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ Eq (intervalIntegral (fun s => Real.log s) a b MeasureTheory.MeasureSpace.volume) (HAdd.hAdd (HSub.hSub (HSub.hSub (HMul.hMul b (Real.log b)) (HMul.hMul a (Real.log a))) b) a)","decl":"@[deprecated (since := \"2025-01-12\")]\nalias integral_log_of_pos := integral_log\n\n"}
{"name":"integral_log_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ Eq (intervalIntegral (fun s => Real.log s) a b MeasureTheory.MeasureSpace.volume) (HAdd.hAdd (HSub.hSub (HSub.hSub (HMul.hMul b (Real.log b)) (HMul.hMul a (Real.log a))) b) a)","decl":"@[deprecated (since := \"2025-01-12\")]\nalias integral_log_of_neg := integral_log\n\n"}
{"name":"integral_sin","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ Eq (intervalIntegral (fun x => Real.sin x) a b MeasureTheory.MeasureSpace.volume) (HSub.hSub (Real.cos a) (Real.cos b))","decl":"@[simp]\ntheorem integral_sin : ‚à´ x in a..b, sin x = cos a - cos b := by\n  rw [integral_deriv_eq_sub' fun x => -cos x]\n  ¬∑ ring\n  ¬∑ norm_num\n  ¬∑ simp only [differentiableAt_neg_iff, differentiableAt_cos, implies_true]\n  ¬∑ exact continuousOn_sin\n\n"}
{"name":"integral_cos","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ Eq (intervalIntegral (fun x => Real.cos x) a b MeasureTheory.MeasureSpace.volume) (HSub.hSub (Real.sin b) (Real.sin a))","decl":"@[simp]\ntheorem integral_cos : ‚à´ x in a..b, cos x = sin b - sin a := by\n  rw [integral_deriv_eq_sub']\n  ¬∑ norm_num\n  ¬∑ simp only [differentiableAt_sin, implies_true]\n  ¬∑ exact continuousOn_cos\n\n"}
{"name":"integral_cos_mul_complex","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"z : Complex\nhz : Ne z 0\na b : Real\n‚ä¢ Eq (intervalIntegral (fun x => Complex.cos (HMul.hMul z ‚Üëx)) a b MeasureTheory.MeasureSpace.volume) (HSub.hSub (HDiv.hDiv (Complex.sin (HMul.hMul z ‚Üëb)) z) (HDiv.hDiv (Complex.sin (HMul.hMul z ‚Üëa)) z))","decl":"theorem integral_cos_mul_complex {z : ‚ÑÇ} (hz : z ‚â† 0) (a b : ‚Ñù) :\n    (‚à´ x in a..b, Complex.cos (z * x)) = Complex.sin (z * b) / z - Complex.sin (z * a) / z := by\n  apply integral_eq_sub_of_hasDerivAt\n  swap\n  ¬∑ apply Continuous.intervalIntegrable\n    exact Complex.continuous_cos.comp (continuous_const.mul Complex.continuous_ofReal)\n  intro x _\n  have a := Complex.hasDerivAt_sin (‚Üëx * z)\n  have b : HasDerivAt (fun y => y * z : ‚ÑÇ ‚Üí ‚ÑÇ) z ‚Üëx := hasDerivAt_mul_const _\n  have c : HasDerivAt (Complex.sin ‚àò fun y : ‚ÑÇ => (y * z)) _ ‚Üëx := HasDerivAt.comp (ùïú := ‚ÑÇ) x a b\n  have d := HasDerivAt.comp_ofReal (c.div_const z)\n  simp only [mul_comm] at d\n  convert d using 1\n  conv_rhs => arg 1; rw [mul_comm]\n  rw [mul_div_cancel_right‚ÇÄ _ hz]\n\n"}
{"name":"integral_cos_sq_sub_sin_sq","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ Eq (intervalIntegral (fun x => HSub.hSub (HPow.hPow (Real.cos x) 2) (HPow.hPow (Real.sin x) 2)) a b MeasureTheory.MeasureSpace.volume) (HSub.hSub (HMul.hMul (Real.sin b) (Real.cos b)) (HMul.hMul (Real.sin a) (Real.cos a)))","decl":"theorem integral_cos_sq_sub_sin_sq :\n    ‚à´ x in a..b, cos x ^ 2 - sin x ^ 2 = sin b * cos b - sin a * cos a := by\n  simpa only [sq, sub_eq_add_neg, neg_mul_eq_mul_neg] using\n    integral_deriv_mul_eq_sub (fun x _ => hasDerivAt_sin x) (fun x _ => hasDerivAt_cos x)\n      continuousOn_cos.intervalIntegrable continuousOn_sin.neg.intervalIntegrable\n\n"}
{"name":"integral_one_div_one_add_sq","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ Eq (intervalIntegral (fun x => HDiv.hDiv 1 (HAdd.hAdd 1 (HPow.hPow x 2))) a b MeasureTheory.MeasureSpace.volume) (HSub.hSub (Real.arctan b) (Real.arctan a))","decl":"theorem integral_one_div_one_add_sq :\n    (‚à´ x : ‚Ñù in a..b, ‚Üë1 / (‚Üë1 + x ^ 2)) = arctan b - arctan a := by\n  refine integral_deriv_eq_sub' _ Real.deriv_arctan (fun _ _ => differentiableAt_arctan _)\n    (continuous_const.div ?_ fun x => ?_).continuousOn\n  ¬∑ fun_prop\n  ¬∑ nlinarith\n\n"}
{"name":"integral_inv_one_add_sq","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ Eq (intervalIntegral (fun x => Inv.inv (HAdd.hAdd 1 (HPow.hPow x 2))) a b MeasureTheory.MeasureSpace.volume) (HSub.hSub (Real.arctan b) (Real.arctan a))","decl":"@[simp]\ntheorem integral_inv_one_add_sq : (‚à´ x : ‚Ñù in a..b, (‚Üë1 + x ^ 2)‚Åª¬π) = arctan b - arctan a := by\n  simp only [‚Üê one_div, integral_one_div_one_add_sq]\n\n"}
{"name":"integral_mul_cpow_one_add_sq","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nt : Complex\nht : Ne t (-1)\n‚ä¢ Eq (intervalIntegral (fun x => HMul.hMul (‚Üëx) (HPow.hPow (HAdd.hAdd 1 (HPow.hPow (‚Üëx) 2)) t)) a b MeasureTheory.MeasureSpace.volume) (HSub.hSub (HDiv.hDiv (HPow.hPow (HAdd.hAdd 1 (HPow.hPow (‚Üëb) 2)) (HAdd.hAdd t 1)) (HMul.hMul 2 (HAdd.hAdd t 1))) (HDiv.hDiv (HPow.hPow (HAdd.hAdd 1 (HPow.hPow (‚Üëa) 2)) (HAdd.hAdd t 1)) (HMul.hMul 2 (HAdd.hAdd t 1))))","decl":"theorem integral_mul_cpow_one_add_sq {t : ‚ÑÇ} (ht : t ‚â† -1) :\n    (‚à´ x : ‚Ñù in a..b, (x : ‚ÑÇ) * ((1 : ‚ÑÇ) + ‚Üëx ^ 2) ^ t) =\n      ((1 : ‚ÑÇ) + (b : ‚ÑÇ) ^ 2) ^ (t + 1) / (2 * (t + ‚Üë1)) -\n      ((1 : ‚ÑÇ) + (a : ‚ÑÇ) ^ 2) ^ (t + 1) / (2 * (t + ‚Üë1)) := by\n  have : t + 1 ‚â† 0 := by contrapose! ht; rwa [add_eq_zero_iff_eq_neg] at ht\n  apply integral_eq_sub_of_hasDerivAt\n  ¬∑ intro x _\n    have f : HasDerivAt (fun y : ‚ÑÇ => 1 + y ^ 2) (2 * x : ‚ÑÇ) x := by\n      convert (hasDerivAt_pow 2 (x : ‚ÑÇ)).const_add 1\n      simp\n    have g :\n      ‚àÄ {z : ‚ÑÇ}, 0 < z.re ‚Üí HasDerivAt (fun z => z ^ (t + 1) / (2 * (t + 1))) (z ^ t / 2) z := by\n      intro z hz\n      convert (HasDerivAt.cpow_const (c := t + 1) (hasDerivAt_id _)\n        (Or.inl hz)).div_const (2 * (t + 1)) using 1\n      field_simp\n      ring\n    convert (HasDerivAt.comp (‚Üëx) (g _) f).comp_ofReal using 1\n    ¬∑ field_simp; ring\n    ¬∑ exact mod_cast add_pos_of_pos_of_nonneg zero_lt_one (sq_nonneg x)\n  ¬∑ apply Continuous.intervalIntegrable\n    refine continuous_ofReal.mul ?_\n    apply Continuous.cpow\n    ¬∑ exact continuous_const.add (continuous_ofReal.pow 2)\n    ¬∑ exact continuous_const\n    ¬∑ intro a\n      norm_cast\n      exact ofReal_mem_slitPlane.2 <| add_pos_of_pos_of_nonneg one_pos <| sq_nonneg a\n\n"}
{"name":"integral_mul_rpow_one_add_sq","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b t : Real\nht : Ne t (-1)\n‚ä¢ Eq (intervalIntegral (fun x => HMul.hMul x (HPow.hPow (HAdd.hAdd 1 (HPow.hPow x 2)) t)) a b MeasureTheory.MeasureSpace.volume) (HSub.hSub (HDiv.hDiv (HPow.hPow (HAdd.hAdd 1 (HPow.hPow b 2)) (HAdd.hAdd t 1)) (HMul.hMul 2 (HAdd.hAdd t 1))) (HDiv.hDiv (HPow.hPow (HAdd.hAdd 1 (HPow.hPow a 2)) (HAdd.hAdd t 1)) (HMul.hMul 2 (HAdd.hAdd t 1))))","decl":"theorem integral_mul_rpow_one_add_sq {t : ‚Ñù} (ht : t ‚â† -1) :\n    (‚à´ x : ‚Ñù in a..b, x * (‚Üë1 + x ^ 2) ^ t) =\n      (‚Üë1 + b ^ 2) ^ (t + 1) / (‚Üë2 * (t + ‚Üë1)) - (‚Üë1 + a ^ 2) ^ (t + 1) / (‚Üë2 * (t + ‚Üë1)) := by\n  have : ‚àÄ x s : ‚Ñù, (((‚Üë1 + x ^ 2) ^ s : ‚Ñù) : ‚ÑÇ) = (1 + (x : ‚ÑÇ) ^ 2) ^ (s : ‚ÑÇ) := by\n    intro x s\n    norm_cast\n    rw [ofReal_cpow, ofReal_add, ofReal_pow, ofReal_one]\n    exact add_nonneg zero_le_one (sq_nonneg x)\n  rw [‚Üê ofReal_inj]\n  convert integral_mul_cpow_one_add_sq (_ : (t : ‚ÑÇ) ‚â† -1)\n  ¬∑ rw [‚Üê intervalIntegral.integral_ofReal]\n    congr with x : 1\n    rw [ofReal_mul, this x t]\n  ¬∑ simp_rw [ofReal_sub, ofReal_div, this a (t + 1), this b (t + 1)]\n    push_cast; rfl\n  ¬∑ rw [‚Üê ofReal_one, ‚Üê ofReal_neg, Ne, ofReal_inj]\n    exact ht\n\n"}
{"name":"integral_sin_pow_aux","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nn : Nat\n‚ä¢ Eq (intervalIntegral (fun x => HPow.hPow (Real.sin x) (HAdd.hAdd n 2)) a b MeasureTheory.MeasureSpace.volume) (HSub.hSub (HAdd.hAdd (HSub.hSub (HMul.hMul (HPow.hPow (Real.sin a) (HAdd.hAdd n 1)) (Real.cos a)) (HMul.hMul (HPow.hPow (Real.sin b) (HAdd.hAdd n 1)) (Real.cos b))) (HMul.hMul (HAdd.hAdd (‚Üën) 1) (intervalIntegral (fun x => HPow.hPow (Real.sin x) n) a b MeasureTheory.MeasureSpace.volume))) (HMul.hMul (HAdd.hAdd (‚Üën) 1) (intervalIntegral (fun x => HPow.hPow (Real.sin x) (HAdd.hAdd n 2)) a b MeasureTheory.MeasureSpace.volume)))","decl":"theorem integral_sin_pow_aux :\n    (‚à´ x in a..b, sin x ^ (n + 2)) =\n      (sin a ^ (n + 1) * cos a - sin b ^ (n + 1) * cos b + (‚Üën + 1) * ‚à´ x in a..b, sin x ^ n) -\n        (‚Üën + 1) * ‚à´ x in a..b, sin x ^ (n + 2) := by\n  let C := sin a ^ (n + 1) * cos a - sin b ^ (n + 1) * cos b\n  have h : ‚àÄ Œ± Œ≤ Œ≥ : ‚Ñù, Œ≤ * Œ± * Œ≥ * Œ± = Œ≤ * (Œ± * Œ± * Œ≥) := fun Œ± Œ≤ Œ≥ => by ring\n  have hu : ‚àÄ x ‚àà [[a, b]],\n      HasDerivAt (fun y => sin y ^ (n + 1)) ((n + 1 : ‚Ñï) * cos x * sin x ^ n) x :=\n    fun x _ => by simpa only [mul_right_comm] using (hasDerivAt_sin x).pow (n + 1)\n  have hv : ‚àÄ x ‚àà [[a, b]], HasDerivAt (-cos) (sin x) x := fun x _ => by\n    simpa only [neg_neg] using (hasDerivAt_cos x).neg\n  have H := integral_mul_deriv_eq_deriv_mul hu hv ?_ ?_\n  ¬∑ calc\n      (‚à´ x in a..b, sin x ^ (n + 2)) = ‚à´ x in a..b, sin x ^ (n + 1) * sin x := by\n        simp only [_root_.pow_succ]\n      _ = C + (‚Üën + 1) * ‚à´ x in a..b, cos x ^ 2 * sin x ^ n := by simp [H, h, sq]; ring\n      _ = C + (‚Üën + 1) * ‚à´ x in a..b, sin x ^ n - sin x ^ (n + 2) := by\n        simp [cos_sq', sub_mul, ‚Üê pow_add, add_comm]\n      _ = (C + (‚Üën + 1) * ‚à´ x in a..b, sin x ^ n) - (‚Üën + 1) * ‚à´ x in a..b, sin x ^ (n + 2) := by\n        rw [integral_sub, mul_sub, add_sub_assoc] <;>\n          apply Continuous.intervalIntegrable <;> fun_prop\n  all_goals apply Continuous.intervalIntegrable; fun_prop\n\n"}
{"name":"integral_sin_pow","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nn : Nat\n‚ä¢ Eq (intervalIntegral (fun x => HPow.hPow (Real.sin x) (HAdd.hAdd n 2)) a b MeasureTheory.MeasureSpace.volume) (HAdd.hAdd (HDiv.hDiv (HSub.hSub (HMul.hMul (HPow.hPow (Real.sin a) (HAdd.hAdd n 1)) (Real.cos a)) (HMul.hMul (HPow.hPow (Real.sin b) (HAdd.hAdd n 1)) (Real.cos b))) (HAdd.hAdd (‚Üën) 2)) (HMul.hMul (HDiv.hDiv (HAdd.hAdd (‚Üën) 1) (HAdd.hAdd (‚Üën) 2)) (intervalIntegral (fun x => HPow.hPow (Real.sin x) n) a b MeasureTheory.MeasureSpace.volume)))","decl":"/-- The reduction formula for the integral of `sin x ^ n` for any natural `n ‚â• 2`. -/\ntheorem integral_sin_pow :\n    (‚à´ x in a..b, sin x ^ (n + 2)) =\n      (sin a ^ (n + 1) * cos a - sin b ^ (n + 1) * cos b) / (n + 2) +\n        (n + 1) / (n + 2) * ‚à´ x in a..b, sin x ^ n := by\n  field_simp\n  convert eq_sub_iff_add_eq.mp (integral_sin_pow_aux n) using 1\n  ring\n\n"}
{"name":"integral_sin_sq","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ Eq (intervalIntegral (fun x => HPow.hPow (Real.sin x) 2) a b MeasureTheory.MeasureSpace.volume) (HDiv.hDiv (HSub.hSub (HAdd.hAdd (HSub.hSub (HMul.hMul (Real.sin a) (Real.cos a)) (HMul.hMul (Real.sin b) (Real.cos b))) b) a) 2)","decl":"@[simp]\ntheorem integral_sin_sq : ‚à´ x in a..b, sin x ^ 2 = (sin a * cos a - sin b * cos b + b - a) / 2 := by\n  field_simp [integral_sin_pow, add_sub_assoc]\n\n"}
{"name":"integral_sin_pow_odd","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"n : Nat\n‚ä¢ Eq (intervalIntegral (fun x => HPow.hPow (Real.sin x) (HAdd.hAdd (HMul.hMul 2 n) 1)) 0 Real.pi MeasureTheory.MeasureSpace.volume) (HMul.hMul 2 ((Finset.range n).prod fun i => HDiv.hDiv (HAdd.hAdd (HMul.hMul 2 ‚Üëi) 2) (HAdd.hAdd (HMul.hMul 2 ‚Üëi) 3)))","decl":"theorem integral_sin_pow_odd :\n    (‚à´ x in (0)..œÄ, sin x ^ (2 * n + 1)) = 2 * ‚àè i ‚àà range n, (2 * (i : ‚Ñù) + 2) / (2 * i + 3) := by\n  induction' n with k ih; ¬∑ norm_num\n  rw [prod_range_succ_comm, mul_left_comm, ‚Üê ih, mul_succ, integral_sin_pow]\n  norm_cast\n  simp [-cast_add, field_simps]\n\n"}
{"name":"integral_sin_pow_even","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"n : Nat\n‚ä¢ Eq (intervalIntegral (fun x => HPow.hPow (Real.sin x) (HMul.hMul 2 n)) 0 Real.pi MeasureTheory.MeasureSpace.volume) (HMul.hMul Real.pi ((Finset.range n).prod fun i => HDiv.hDiv (HAdd.hAdd (HMul.hMul 2 ‚Üëi) 1) (HAdd.hAdd (HMul.hMul 2 ‚Üëi) 2)))","decl":"theorem integral_sin_pow_even :\n    (‚à´ x in (0)..œÄ, sin x ^ (2 * n)) = œÄ * ‚àè i ‚àà range n, (2 * (i : ‚Ñù) + 1) / (2 * i + 2) := by\n  induction' n with k ih; ¬∑ simp\n  rw [prod_range_succ_comm, mul_left_comm, ‚Üê ih, mul_succ, integral_sin_pow]\n  norm_cast\n  simp [-cast_add, field_simps]\n\n"}
{"name":"integral_sin_pow_pos","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"n : Nat\n‚ä¢ LT.lt 0 (intervalIntegral (fun x => HPow.hPow (Real.sin x) n) 0 Real.pi MeasureTheory.MeasureSpace.volume)","decl":"theorem integral_sin_pow_pos : 0 < ‚à´ x in (0)..œÄ, sin x ^ n := by\n  rcases even_or_odd' n with ‚ü®k, rfl | rfl‚ü© <;>\n  simp only [integral_sin_pow_even, integral_sin_pow_odd] <;>\n  refine mul_pos (by norm_num [pi_pos]) (prod_pos fun n _ => div_pos ?_ ?_) <;>\n  norm_cast <;>\n  omega\n\n"}
{"name":"integral_sin_pow_succ_le","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"n : Nat\n‚ä¢ LE.le (intervalIntegral (fun x => HPow.hPow (Real.sin x) (HAdd.hAdd n 1)) 0 Real.pi MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => HPow.hPow (Real.sin x) n) 0 Real.pi MeasureTheory.MeasureSpace.volume)","decl":"theorem integral_sin_pow_succ_le : (‚à´ x in (0)..œÄ, sin x ^ (n + 1)) ‚â§ ‚à´ x in (0)..œÄ, sin x ^ n := by\n  let H x h := pow_le_pow_of_le_one (sin_nonneg_of_mem_Icc h) (sin_le_one x) (n.le_add_right 1)\n  refine integral_mono_on pi_pos.le ?_ ?_ H <;> exact (continuous_sin.pow _).intervalIntegrable 0 œÄ\n\n"}
{"name":"integral_sin_pow_antitone","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"‚ä¢ Antitone fun n => intervalIntegral (fun x => HPow.hPow (Real.sin x) n) 0 Real.pi MeasureTheory.MeasureSpace.volume","decl":"theorem integral_sin_pow_antitone : Antitone fun n : ‚Ñï => ‚à´ x in (0)..œÄ, sin x ^ n :=\n  antitone_nat_of_succ_le integral_sin_pow_succ_le\n\n"}
{"name":"integral_cos_pow_aux","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nn : Nat\n‚ä¢ Eq (intervalIntegral (fun x => HPow.hPow (Real.cos x) (HAdd.hAdd n 2)) a b MeasureTheory.MeasureSpace.volume) (HSub.hSub (HAdd.hAdd (HSub.hSub (HMul.hMul (HPow.hPow (Real.cos b) (HAdd.hAdd n 1)) (Real.sin b)) (HMul.hMul (HPow.hPow (Real.cos a) (HAdd.hAdd n 1)) (Real.sin a))) (HMul.hMul (HAdd.hAdd (‚Üën) 1) (intervalIntegral (fun x => HPow.hPow (Real.cos x) n) a b MeasureTheory.MeasureSpace.volume))) (HMul.hMul (HAdd.hAdd (‚Üën) 1) (intervalIntegral (fun x => HPow.hPow (Real.cos x) (HAdd.hAdd n 2)) a b MeasureTheory.MeasureSpace.volume)))","decl":"theorem integral_cos_pow_aux :\n    (‚à´ x in a..b, cos x ^ (n + 2)) =\n      (cos b ^ (n + 1) * sin b - cos a ^ (n + 1) * sin a + (n + 1) * ‚à´ x in a..b, cos x ^ n) -\n        (n + 1) * ‚à´ x in a..b, cos x ^ (n + 2) := by\n  let C := cos b ^ (n + 1) * sin b - cos a ^ (n + 1) * sin a\n  have h : ‚àÄ Œ± Œ≤ Œ≥ : ‚Ñù, Œ≤ * Œ± * Œ≥ * Œ± = Œ≤ * (Œ± * Œ± * Œ≥) := fun Œ± Œ≤ Œ≥ => by ring\n  have hu : ‚àÄ x ‚àà [[a, b]],\n      HasDerivAt (fun y => cos y ^ (n + 1)) (-(n + 1 : ‚Ñï) * sin x * cos x ^ n) x :=\n    fun x _ => by\n      simpa only [mul_right_comm, neg_mul, mul_neg] using (hasDerivAt_cos x).pow (n + 1)\n  have hv : ‚àÄ x ‚àà [[a, b]], HasDerivAt sin (cos x) x := fun x _ => hasDerivAt_sin x\n  have H := integral_mul_deriv_eq_deriv_mul hu hv ?_ ?_\n  ¬∑ calc\n      (‚à´ x in a..b, cos x ^ (n + 2)) = ‚à´ x in a..b, cos x ^ (n + 1) * cos x := by\n        simp only [_root_.pow_succ]\n      _ = C + (n + 1) * ‚à´ x in a..b, sin x ^ 2 * cos x ^ n := by simp [C, H, h, sq, -neg_add_rev]\n      _ = C + (n + 1) * ‚à´ x in a..b, cos x ^ n - cos x ^ (n + 2) := by\n        simp [sin_sq, sub_mul, ‚Üê pow_add, add_comm]\n      _ = (C + (n + 1) * ‚à´ x in a..b, cos x ^ n) - (n + 1) * ‚à´ x in a..b, cos x ^ (n + 2) := by\n        rw [integral_sub, mul_sub, add_sub_assoc] <;>\n          apply Continuous.intervalIntegrable <;> fun_prop\n  all_goals apply Continuous.intervalIntegrable; fun_prop\n\n"}
{"name":"integral_cos_pow","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nn : Nat\n‚ä¢ Eq (intervalIntegral (fun x => HPow.hPow (Real.cos x) (HAdd.hAdd n 2)) a b MeasureTheory.MeasureSpace.volume) (HAdd.hAdd (HDiv.hDiv (HSub.hSub (HMul.hMul (HPow.hPow (Real.cos b) (HAdd.hAdd n 1)) (Real.sin b)) (HMul.hMul (HPow.hPow (Real.cos a) (HAdd.hAdd n 1)) (Real.sin a))) (HAdd.hAdd (‚Üën) 2)) (HMul.hMul (HDiv.hDiv (HAdd.hAdd (‚Üën) 1) (HAdd.hAdd (‚Üën) 2)) (intervalIntegral (fun x => HPow.hPow (Real.cos x) n) a b MeasureTheory.MeasureSpace.volume)))","decl":"/-- The reduction formula for the integral of `cos x ^ n` for any natural `n ‚â• 2`. -/\ntheorem integral_cos_pow :\n    (‚à´ x in a..b, cos x ^ (n + 2)) =\n      (cos b ^ (n + 1) * sin b - cos a ^ (n + 1) * sin a) / (n + 2) +\n        (n + 1) / (n + 2) * ‚à´ x in a..b, cos x ^ n := by\n  field_simp\n  convert eq_sub_iff_add_eq.mp (integral_cos_pow_aux n) using 1\n  ring\n\n"}
{"name":"integral_cos_sq","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ Eq (intervalIntegral (fun x => HPow.hPow (Real.cos x) 2) a b MeasureTheory.MeasureSpace.volume) (HDiv.hDiv (HSub.hSub (HAdd.hAdd (HSub.hSub (HMul.hMul (Real.cos b) (Real.sin b)) (HMul.hMul (Real.cos a) (Real.sin a))) b) a) 2)","decl":"@[simp]\ntheorem integral_cos_sq : ‚à´ x in a..b, cos x ^ 2 = (cos b * sin b - cos a * sin a + b - a) / 2 := by\n  field_simp [integral_cos_pow, add_sub_assoc]\n\n"}
{"name":"integral_sin_pow_mul_cos_pow_odd","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nm n : Nat\n‚ä¢ Eq (intervalIntegral (fun x => HMul.hMul (HPow.hPow (Real.sin x) m) (HPow.hPow (Real.cos x) (HAdd.hAdd (HMul.hMul 2 n) 1))) a b MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun u => HMul.hMul (HPow.hPow u m) (HPow.hPow (HSub.hSub 1 (HPow.hPow u 2)) n)) (Real.sin a) (Real.sin b) MeasureTheory.MeasureSpace.volume)","decl":"/-- Simplification of the integral of `sin x ^ m * cos x ^ n`, case `n` is odd. -/\ntheorem integral_sin_pow_mul_cos_pow_odd (m n : ‚Ñï) :\n    (‚à´ x in a..b, sin x ^ m * cos x ^ (2 * n + 1)) = ‚à´ u in sin a..sin b, u^m * (‚Üë1 - u ^ 2) ^ n :=\n  have hc : Continuous fun u : ‚Ñù => u ^ m * (‚Üë1 - u ^ 2) ^ n := by fun_prop\n  calc\n    (‚à´ x in a..b, sin x ^ m * cos x ^ (2 * n + 1)) =\n        ‚à´ x in a..b, sin x ^ m * (‚Üë1 - sin x ^ 2) ^ n * cos x := by\n      simp only [_root_.pow_zero, _root_.pow_succ, mul_assoc, pow_mul, one_mul]\n      congr! 5\n      rw [‚Üê sq, ‚Üê sq, cos_sq']\n    _ = ‚à´ u in sin a..sin b, u ^ m * (1 - u ^ 2) ^ n := by\n      -- Note(kmill): Didn't need `by exact`, but elaboration order seems to matter here.\n      exact integral_comp_mul_deriv (fun x _ => hasDerivAt_sin x) continuousOn_cos hc\n\n"}
{"name":"integral_sin_mul_cos‚ÇÅ","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ Eq (intervalIntegral (fun x => HMul.hMul (Real.sin x) (Real.cos x)) a b MeasureTheory.MeasureSpace.volume) (HDiv.hDiv (HSub.hSub (HPow.hPow (Real.sin b) 2) (HPow.hPow (Real.sin a) 2)) 2)","decl":"/-- The integral of `sin x * cos x`, given in terms of sin¬≤.\n  See `integral_sin_mul_cos‚ÇÇ` below for the integral given in terms of cos¬≤. -/\n@[simp]\ntheorem integral_sin_mul_cos‚ÇÅ : ‚à´ x in a..b, sin x * cos x = (sin b ^ 2 - sin a ^ 2) / 2 := by\n  simpa using integral_sin_pow_mul_cos_pow_odd 1 0\n\n"}
{"name":"integral_sin_sq_mul_cos","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ Eq (intervalIntegral (fun x => HMul.hMul (HPow.hPow (Real.sin x) 2) (Real.cos x)) a b MeasureTheory.MeasureSpace.volume) (HDiv.hDiv (HSub.hSub (HPow.hPow (Real.sin b) 3) (HPow.hPow (Real.sin a) 3)) 3)","decl":"@[simp]\ntheorem integral_sin_sq_mul_cos :\n    ‚à´ x in a..b, sin x ^ 2 * cos x = (sin b ^ 3 - sin a ^ 3) / 3 := by\n  have := @integral_sin_pow_mul_cos_pow_odd a b 2 0\n  norm_num at this; exact this\n\n"}
{"name":"integral_cos_pow_three","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ Eq (intervalIntegral (fun x => HPow.hPow (Real.cos x) 3) a b MeasureTheory.MeasureSpace.volume) (HSub.hSub (HSub.hSub (Real.sin b) (Real.sin a)) (HDiv.hDiv (HSub.hSub (HPow.hPow (Real.sin b) 3) (HPow.hPow (Real.sin a) 3)) 3))","decl":"@[simp]\ntheorem integral_cos_pow_three :\n    ‚à´ x in a..b, cos x ^ 3 = sin b - sin a - (sin b ^ 3 - sin a ^ 3) / 3 := by\n  have := @integral_sin_pow_mul_cos_pow_odd a b 0 1\n  norm_num at this; exact this\n\n"}
{"name":"integral_sin_pow_odd_mul_cos_pow","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nm n : Nat\n‚ä¢ Eq (intervalIntegral (fun x => HMul.hMul (HPow.hPow (Real.sin x) (HAdd.hAdd (HMul.hMul 2 m) 1)) (HPow.hPow (Real.cos x) n)) a b MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun u => HMul.hMul (HPow.hPow u n) (HPow.hPow (HSub.hSub 1 (HPow.hPow u 2)) m)) (Real.cos b) (Real.cos a) MeasureTheory.MeasureSpace.volume)","decl":"/-- Simplification of the integral of `sin x ^ m * cos x ^ n`, case `m` is odd. -/\ntheorem integral_sin_pow_odd_mul_cos_pow (m n : ‚Ñï) :\n    (‚à´ x in a..b, sin x ^ (2 * m + 1) * cos x ^ n) = ‚à´ u in cos b..cos a, u^n * (‚Üë1 - u ^ 2) ^ m :=\n  have hc : Continuous fun u : ‚Ñù => u ^ n * (‚Üë1 - u ^ 2) ^ m := by fun_prop\n  calc\n    (‚à´ x in a..b, sin x ^ (2 * m + 1) * cos x ^ n) =\n        -‚à´ x in b..a, sin x ^ (2 * m + 1) * cos x ^ n := by rw [integral_symm]\n    _ = ‚à´ x in b..a, (‚Üë1 - cos x ^ 2) ^ m * -sin x * cos x ^ n := by\n      simp only [_root_.pow_succ, pow_mul, _root_.pow_zero, one_mul, mul_neg, neg_mul,\n        integral_neg, neg_inj]\n      congr! 5\n      rw [‚Üê sq, ‚Üê sq, sin_sq]\n    _ = ‚à´ x in b..a, cos x ^ n * (‚Üë1 - cos x ^ 2) ^ m * -sin x := by congr; ext; ring\n    _ = ‚à´ u in cos b..cos a, u ^ n * (‚Üë1 - u ^ 2) ^ m :=\n      integral_comp_mul_deriv (fun x _ => hasDerivAt_cos x) continuousOn_sin.neg hc\n\n"}
{"name":"integral_sin_mul_cos‚ÇÇ","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ Eq (intervalIntegral (fun x => HMul.hMul (Real.sin x) (Real.cos x)) a b MeasureTheory.MeasureSpace.volume) (HDiv.hDiv (HSub.hSub (HPow.hPow (Real.cos a) 2) (HPow.hPow (Real.cos b) 2)) 2)","decl":"/-- The integral of `sin x * cos x`, given in terms of cos¬≤.\nSee `integral_sin_mul_cos‚ÇÅ` above for the integral given in terms of sin¬≤. -/\ntheorem integral_sin_mul_cos‚ÇÇ : ‚à´ x in a..b, sin x * cos x = (cos a ^ 2 - cos b ^ 2) / 2 := by\n  simpa using integral_sin_pow_odd_mul_cos_pow 0 1\n\n"}
{"name":"integral_sin_mul_cos_sq","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ Eq (intervalIntegral (fun x => HMul.hMul (Real.sin x) (HPow.hPow (Real.cos x) 2)) a b MeasureTheory.MeasureSpace.volume) (HDiv.hDiv (HSub.hSub (HPow.hPow (Real.cos a) 3) (HPow.hPow (Real.cos b) 3)) 3)","decl":"@[simp]\ntheorem integral_sin_mul_cos_sq :\n    ‚à´ x in a..b, sin x * cos x ^ 2 = (cos a ^ 3 - cos b ^ 3) / 3 := by\n  have := @integral_sin_pow_odd_mul_cos_pow a b 0 2\n  norm_num at this; exact this\n\n"}
{"name":"integral_sin_pow_three","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ Eq (intervalIntegral (fun x => HPow.hPow (Real.sin x) 3) a b MeasureTheory.MeasureSpace.volume) (HSub.hSub (HSub.hSub (Real.cos a) (Real.cos b)) (HDiv.hDiv (HSub.hSub (HPow.hPow (Real.cos a) 3) (HPow.hPow (Real.cos b) 3)) 3))","decl":"@[simp]\ntheorem integral_sin_pow_three :\n    ‚à´ x in a..b, sin x ^ 3 = cos a - cos b - (cos a ^ 3 - cos b ^ 3) / 3 := by\n  have := @integral_sin_pow_odd_mul_cos_pow a b 1 0\n  norm_num at this; exact this\n\n"}
{"name":"integral_sin_pow_even_mul_cos_pow_even","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\nm n : Nat\n‚ä¢ Eq (intervalIntegral (fun x => HMul.hMul (HPow.hPow (Real.sin x) (HMul.hMul 2 m)) (HPow.hPow (Real.cos x) (HMul.hMul 2 n))) a b MeasureTheory.MeasureSpace.volume) (intervalIntegral (fun x => HMul.hMul (HPow.hPow (HDiv.hDiv (HSub.hSub 1 (Real.cos (HMul.hMul 2 x))) 2) m) (HPow.hPow (HDiv.hDiv (HAdd.hAdd 1 (Real.cos (HMul.hMul 2 x))) 2) n)) a b MeasureTheory.MeasureSpace.volume)","decl":"/-- Simplification of the integral of `sin x ^ m * cos x ^ n`, case `m` and `n` are both even. -/\ntheorem integral_sin_pow_even_mul_cos_pow_even (m n : ‚Ñï) :\n    (‚à´ x in a..b, sin x ^ (2 * m) * cos x ^ (2 * n)) =\n      ‚à´ x in a..b, ((1 - cos (2 * x)) / 2) ^ m * ((1 + cos (2 * x)) / 2) ^ n := by\n  field_simp [pow_mul, sin_sq, cos_sq, ‚Üê sub_sub, (by ring : (2 : ‚Ñù) - 1 = 1)]\n\n"}
{"name":"integral_sin_sq_mul_cos_sq","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"a b : Real\n‚ä¢ Eq (intervalIntegral (fun x => HMul.hMul (HPow.hPow (Real.sin x) 2) (HPow.hPow (Real.cos x) 2)) a b MeasureTheory.MeasureSpace.volume) (HSub.hSub (HDiv.hDiv (HSub.hSub b a) 8) (HDiv.hDiv (HSub.hSub (Real.sin (HMul.hMul 4 b)) (Real.sin (HMul.hMul 4 a))) 32))","decl":"@[simp]\ntheorem integral_sin_sq_mul_cos_sq :\n    ‚à´ x in a..b, sin x ^ 2 * cos x ^ 2 = (b - a) / 8 - (sin (4 * b) - sin (4 * a)) / 32 := by\n  convert integral_sin_pow_even_mul_cos_pow_even 1 1 using 1\n  have h1 : ‚àÄ c : ‚Ñù, (‚Üë1 - c) / ‚Üë2 * ((‚Üë1 + c) / ‚Üë2) = (‚Üë1 - c ^ 2) / 4 := fun c => by ring\n  have h2 : Continuous fun x => cos (2 * x) ^ 2 := by fun_prop\n  have h3 : ‚àÄ x, cos x * sin x = sin (2 * x) / 2 := by intro; rw [sin_two_mul]; ring\n  have h4 : ‚àÄ d : ‚Ñù, 2 * (2 * d) = 4 * d := fun d => by ring\n  simp [h1, h2.intervalIntegrable, integral_comp_mul_left fun x => cos x ^ 2, h3, h4]\n  ring\n\n"}
{"name":"integral_sqrt_one_sub_sq","module":"Mathlib.Analysis.SpecialFunctions.Integrals","initialProofState":"‚ä¢ Eq (intervalIntegral (fun x => (HSub.hSub 1 (HPow.hPow x 2)).sqrt) (-1) 1 MeasureTheory.MeasureSpace.volume) (HDiv.hDiv Real.pi 2)","decl":"theorem integral_sqrt_one_sub_sq : ‚à´ x in (-1 : ‚Ñù)..1, ‚àö(1 - x ^ 2 : ‚Ñù) = œÄ / 2 :=\n  calc\n    _ = ‚à´ x in sin (-(œÄ / 2)).. sin (œÄ / 2), ‚àö(1 - x ^ 2 : ‚Ñù) := by rw [sin_neg, sin_pi_div_two]\n    _ = ‚à´ x in (-(œÄ / 2))..(œÄ / 2), ‚àö(1 - sin x ^ 2 : ‚Ñù) * cos x :=\n          (integral_comp_mul_deriv (fun x _ => hasDerivAt_sin x) continuousOn_cos\n            (by fun_prop)).symm\n    _ = ‚à´ x in (-(œÄ / 2))..(œÄ / 2), cos x ^ 2 := by\n          refine integral_congr_ae (MeasureTheory.ae_of_all _ fun _ h => ?_)\n          rw [uIoc_of_le (neg_le_self (le_of_lt (half_pos Real.pi_pos))), Set.mem_Ioc] at h\n          rw [‚Üê Real.cos_eq_sqrt_one_sub_sin_sq (le_of_lt h.1) h.2, pow_two]\n    _ = œÄ / 2 := by simp\n"}
