{"name":"instIsAddHaarMeasureUnitAddCircleVolume","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"⊢ MeasureTheory.MeasureSpace.volume.IsAddHaarMeasure","decl":"/-- The measure on `ℝ / ℤ` is a Haar measure. -/\nlocal instance : Measure.IsAddHaarMeasure (volume : Measure UnitAddCircle) :=\n  inferInstanceAs (Measure.IsAddHaarMeasure AddCircle.haarAddCircle)\n\n"}
{"name":"instIsProbabilityMeasureUnitAddCircleVolume","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"⊢ MeasureTheory.IsProbabilityMeasure MeasureTheory.MeasureSpace.volume","decl":"/-- The measure on `ℝ / ℤ` is a probability measure. -/\nlocal instance : IsProbabilityMeasure (volume : Measure UnitAddCircle) :=\n  inferInstanceAs (IsProbabilityMeasure AddCircle.haarAddCircle)\n\n"}
{"name":"UnitAddTorus.mFourier_neg","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"d : Type u_1\ninst✝ : Fintype d\nn : d → Int\nx : UnitAddTorus d\n⊢ Eq ((UnitAddTorus.mFourier (Neg.neg n)) x) ((starRingEnd Complex) ((UnitAddTorus.mFourier n) x))","decl":"lemma mFourier_neg : mFourier (-n) x = conj (mFourier n x) := by\n  simp only [mFourier, Pi.neg_apply, fourier_neg, ContinuousMap.coe_mk, map_prod]\n\n"}
{"name":"UnitAddTorus.mFourier_add","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"d : Type u_1\ninst✝ : Fintype d\nn : d → Int\nx : UnitAddTorus d\nm : d → Int\n⊢ Eq ((UnitAddTorus.mFourier (HAdd.hAdd m n)) x) (HMul.hMul ((UnitAddTorus.mFourier m) x) ((UnitAddTorus.mFourier n) x))","decl":"lemma mFourier_add {m : d → ℤ} : mFourier (m + n) x = mFourier m x * mFourier n x := by\n  simp only [mFourier, Pi.add_apply, fourier_add, ContinuousMap.coe_mk, ← Finset.prod_mul_distrib]\n\n"}
{"name":"UnitAddTorus.mFourier_zero","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"d : Type u_1\ninst✝ : Fintype d\n⊢ Eq (UnitAddTorus.mFourier 0) 1","decl":"lemma mFourier_zero : mFourier (0 : d → ℤ) = 1 := by\n  ext x\n  simp only [mFourier, Pi.zero_apply, fourier_zero, Finset.prod_const_one, ContinuousMap.coe_mk,\n    ContinuousMap.one_apply]\n\n"}
{"name":"UnitAddTorus.mFourier_norm","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"d : Type u_1\ninst✝ : Fintype d\nn : d → Int\n⊢ Eq (Norm.norm (UnitAddTorus.mFourier n)) 1","decl":"lemma mFourier_norm : ‖mFourier n‖ = 1 := by\n  apply le_antisymm\n  · refine (ContinuousMap.norm_le _ zero_le_one).mpr fun i ↦ ?_\n    simp only [mFourier, fourier_apply, ContinuousMap.coe_mk, norm_prod, Complex.norm_eq_abs,\n      Circle.abs_coe, Finset.prod_const_one, le_rfl]\n  · refine (le_of_eq ?_).trans ((mFourier n).norm_coe_le_norm fun _ ↦ 0)\n    simp only [mFourier, ContinuousMap.coe_mk, fourier_eval_zero, Finset.prod_const_one,\n      CStarRing.norm_one]\n\n"}
{"name":"UnitAddTorus.mFourier_single","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"d : Type u_1\ninst✝¹ : Fintype d\ninst✝ : DecidableEq d\nz : d → AddCircle 1\ni : d\n⊢ Eq ((UnitAddTorus.mFourier (Pi.single i 1)) z) ((fourier 1) (z i))","decl":"lemma mFourier_single [DecidableEq d] (z : d → AddCircle (1 : ℝ)) (i : d) :\n    mFourier (Pi.single i 1) z = fourier 1 (z i) := by\n  simp_rw [mFourier, ContinuousMap.coe_mk]\n  have := Finset.prod_mul_prod_compl {i} (fun j ↦ fourier ((Pi.single i (1 : ℤ) : d → ℤ) j) (z j))\n  rw [Finset.prod_singleton, Finset.prod_congr rfl (fun j hj ↦ ?_)] at this\n  · rw [← this, Finset.prod_const_one, mul_one, Pi.single_eq_same]\n  · rw [Finset.mem_compl, Finset.mem_singleton] at hj\n    simp only [Pi.single_eq_of_ne hj, fourier_zero]\n\n"}
{"name":"UnitAddTorus.mFourierSubalgebra_coe","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"d : Type u_1\ninst✝ : Fintype d\n⊢ Eq (Subalgebra.toSubmodule (UnitAddTorus.mFourierSubalgebra d).toSubalgebra) (Submodule.span Complex (Set.range UnitAddTorus.mFourier))","decl":"/-- The star subalgebra of `C(UnitAddTorus d, ℂ)` generated by `mFourier n` for `n ∈ ℤᵈ` is in fact\nthe linear span of these functions. -/\ntheorem mFourierSubalgebra_coe :\n    (mFourierSubalgebra d).toSubalgebra.toSubmodule = span ℂ (range mFourier) := by\n  apply adjoin_eq_span_of_subset\n  refine .trans (fun x ↦ Submonoid.closure_induction (fun _ ↦ id) ⟨0, ?_⟩ ?_) subset_span\n  · ext z\n    simp only [mFourier, Pi.zero_apply, fourier_zero, Finset.prod_const, one_pow,\n      ContinuousMap.coe_mk, ContinuousMap.one_apply]\n  · rintro _ _ _ _ ⟨m, rfl⟩ ⟨n, rfl⟩\n    refine ⟨m + n, ?_⟩\n    ext z\n    simp only [mFourier, Pi.add_apply, fourier_apply, fourier_add', Finset.prod_mul_distrib,\n      ContinuousMap.coe_mk, ContinuousMap.mul_apply]\n\n"}
{"name":"UnitAddTorus.mFourierSubalgebra_separatesPoints","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"d : Type u_1\ninst✝ : Fintype d\n⊢ (UnitAddTorus.mFourierSubalgebra d).SeparatesPoints","decl":"/-- The subalgebra of `C(UnitAddTorus d, ℂ)` generated by `mFourier n` for `n ∈ ℤᵈ` separates\npoints. -/\ntheorem mFourierSubalgebra_separatesPoints : (mFourierSubalgebra d).SeparatesPoints := by\n  classical\n  intro x y hxy\n  rw [Ne, funext_iff, not_forall] at hxy\n  obtain ⟨i, hi⟩ := hxy\n  refine ⟨_, ⟨mFourier (Pi.single i 1), subset_adjoin ⟨Pi.single i 1, rfl⟩, rfl⟩, ?_⟩\n  dsimp only\n  rw [mFourier_single, mFourier_single, fourier_one, fourier_one, Ne, Subtype.coe_inj]\n  contrapose! hi\n  exact AddCircle.injective_toCircle one_ne_zero hi\n\n"}
{"name":"UnitAddTorus.mFourierSubalgebra_closure_eq_top","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"d : Type u_1\ninst✝ : Fintype d\n⊢ Eq (UnitAddTorus.mFourierSubalgebra d).topologicalClosure Top.top","decl":"/-- The subalgebra of `C(UnitAddTorus d, ℂ)` generated by `mFourier n` for `n : d → ℤ` is dense. -/\ntheorem mFourierSubalgebra_closure_eq_top : (mFourierSubalgebra d).topologicalClosure = ⊤ :=\n  ContinuousMap.starSubalgebra_topologicalClosure_eq_top_of_separatesPoints _\n    mFourierSubalgebra_separatesPoints\n\n"}
{"name":"UnitAddTorus.span_mFourier_closure_eq_top","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"d : Type u_1\ninst✝ : Fintype d\n⊢ Eq (Submodule.span Complex (Set.range UnitAddTorus.mFourier)).topologicalClosure Top.top","decl":"/-- The linear span of the monomials `mFourier n` is dense in `C(UnitAddTorus d, ℂ)`. -/\ntheorem span_mFourier_closure_eq_top :\n    (span ℂ (range <| mFourier (d := d))).topologicalClosure = ⊤ := by\n  rw [← mFourierSubalgebra_coe]\n  exact congr_arg (Subalgebra.toSubmodule <| StarSubalgebra.toSubalgebra ·)\n    mFourierSubalgebra_closure_eq_top\n\n"}
{"name":"UnitAddTorus.coeFn_mFourierLp","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"d : Type u_1\ninst✝¹ : Fintype d\np : ENNReal\ninst✝ : Fact (LE.le 1 p)\nn : d → Int\n⊢ (MeasureTheory.ae MeasureTheory.MeasureSpace.volume).EventuallyEq ↑↑(UnitAddTorus.mFourierLp p n) ⇑(UnitAddTorus.mFourier n)","decl":"theorem coeFn_mFourierLp (p : ℝ≥0∞) [Fact (1 ≤ p)] (n : d → ℤ) :\n    mFourierLp p n =ᵐ[volume] mFourier n :=\n  ContinuousMap.coeFn_toLp volume (mFourier n)\n\n"}
{"name":"UnitAddTorus.span_mFourierLp_closure_eq_top","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"d : Type u_1\ninst✝¹ : Fintype d\np : ENNReal\ninst✝ : Fact (LE.le 1 p)\nhp : Ne p Top.top\n⊢ Eq (Submodule.span Complex (Set.range (UnitAddTorus.mFourierLp p))).topologicalClosure Top.top","decl":"/-- For each `1 ≤ p < ∞`, the linear span of the monomials `mFourier n` is dense in the `Lᵖ` space\nof functions on `UnitAddTorus d`. -/\ntheorem span_mFourierLp_closure_eq_top {p : ℝ≥0∞} [Fact (1 ≤ p)] (hp : p ≠ ∞) :\n    (span ℂ (range (@mFourierLp d _ p _))).topologicalClosure = ⊤ := by\n  simpa only [map_span, ContinuousLinearMap.coe_coe, ← range_comp, Function.comp_def] using\n    (ContinuousMap.toLp_denseRange ℂ volume ℂ hp).topologicalClosure_map_submodule\n      span_mFourier_closure_eq_top\n\n"}
{"name":"UnitAddTorus.orthonormal_mFourier","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"d : Type u_1\ninst✝ : Fintype d\n⊢ Orthonormal Complex (UnitAddTorus.mFourierLp 2)","decl":"/-- The monomials `mFourierLp 2 n` are an orthonormal set in `L²`. -/\ntheorem orthonormal_mFourier : Orthonormal ℂ (mFourierLp (d := d) 2) := by\n  rw [orthonormal_iff_ite]\n  intro m n\n  simp only [ContinuousMap.inner_toLp, ← mFourier_neg, ← mFourier_add]\n  split_ifs with h\n  · simpa only [h, neg_add_cancel, mFourier_zero, measure_univ, ENNReal.one_toReal, one_smul] using\n      integral_const (α := UnitAddTorus d) (μ := volume) (1 : ℂ)\n  rw [mFourier, ContinuousMap.coe_mk, MeasureTheory.integral_fintype_prod_eq_prod]\n  obtain ⟨i, hi⟩ := Function.ne_iff.mp h\n  apply Finset.prod_eq_zero (Finset.mem_univ i)\n  simpa only [eq_false_intro hi, if_false, ContinuousMap.inner_toLp, ← fourier_neg,\n    ← fourier_add] using (orthonormal_iff_ite.mp <| orthonormal_fourier) (m i) (n i)\n\n"}
{"name":"UnitAddTorus.coe_mFourierBasis","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"d : Type u_1\ninst✝ : Fintype d\n⊢ Eq (fun i => UnitAddTorus.mFourierBasis.repr.symm (lp.single 2 i 1)) (UnitAddTorus.mFourierLp 2)","decl":"/-- The elements of the Hilbert basis `mFourierBasis` are the functions `mFourierLp 2`, i.e. the\nmonomials `mFourier n` on `UnitAddTorus d` considered as elements of `L²`. -/\n@[simp]\ntheorem coe_mFourierBasis : ⇑(mFourierBasis (d := d)) = mFourierLp 2 := HilbertBasis.coe_mk _ _\n\n"}
{"name":"UnitAddTorus.mFourierBasis_repr","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"d : Type u_1\ninst✝ : Fintype d\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp Complex 2 MeasureTheory.MeasureSpace.volume) x\ni : d → Int\n⊢ Eq (↑(UnitAddTorus.mFourierBasis.repr f) i) (UnitAddTorus.mFourierCoeff (↑↑f) i)","decl":"/-- Under the isometric isomorphism `mFourierBasis` from `L²(UnitAddTorus d)` to `ℓ²(ℤᵈ, ℂ)`,\nthe `i`-th coefficient is `mFourierCoeff f i`. -/\ntheorem mFourierBasis_repr (f : L²(UnitAddTorus d)) (i : d → ℤ) :\n    mFourierBasis.repr f i = mFourierCoeff f i := by\n  trans ∫ t, conj (mFourierLp 2 i t) * f t\n  · rw [mFourierBasis.repr_apply_apply f i, MeasureTheory.L2.inner_def, coe_mFourierBasis]\n    simp only [RCLike.inner_apply]\n  · apply integral_congr_ae\n    filter_upwards [coeFn_mFourierLp 2 i] with _ ht\n    rw [ht, ← mFourier_neg, smul_eq_mul]\n\n"}
{"name":"UnitAddTorus.hasSum_mFourier_series_L2","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"d : Type u_1\ninst✝ : Fintype d\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp Complex 2 MeasureTheory.MeasureSpace.volume) x\n⊢ HasSum (fun i => HSMul.hSMul (UnitAddTorus.mFourierCoeff (↑↑f) i) (UnitAddTorus.mFourierLp 2 i)) f","decl":"/-- The Fourier series of an `L2` function `f` sums to `f` in the `L²` norm. -/\ntheorem hasSum_mFourier_series_L2 (f : L²(UnitAddTorus d)) :\n    HasSum (fun i ↦ mFourierCoeff f i • mFourierLp 2 i) f := by\n  simpa [← coe_mFourierBasis, mFourierBasis_repr] using mFourierBasis.hasSum_repr f\n\n"}
{"name":"UnitAddTorus.hasSum_prod_mFourierCoeff","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"d : Type u_1\ninst✝ : Fintype d\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp Complex 2 MeasureTheory.MeasureSpace.volume) x\n⊢ HasSum (fun i => HMul.hMul ((starRingEnd Complex) (UnitAddTorus.mFourierCoeff (↑↑f) i)) (UnitAddTorus.mFourierCoeff (↑↑g) i)) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun t => HMul.hMul ((starRingEnd Complex) (↑↑f t)) (↑↑g t))","decl":"/-- **Parseval's identity** for inner products: for `L²` functions `f, g` on `UnitAddTorus d`, the\ninner product of the Fourier coefficients of `f` and `g` is the inner product of `f` and `g`. -/\ntheorem hasSum_prod_mFourierCoeff (f g : L²(UnitAddTorus d)) :\n    HasSum (fun i ↦ conj (mFourierCoeff f i) * (mFourierCoeff g i)) (∫ t, conj (f t) * g t) := by\n  refine HasSum.congr_fun (mFourierBasis.hasSum_inner_mul_inner f g) (fun n ↦ ?_)\n  simp only [← mFourierBasis_repr, HilbertBasis.repr_apply_apply, inner_conj_symm]\n\n"}
{"name":"UnitAddTorus.hasSum_sq_mFourierCoeff","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"d : Type u_1\ninst✝ : Fintype d\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp Complex 2 MeasureTheory.MeasureSpace.volume) x\n⊢ HasSum (fun i => HPow.hPow (Norm.norm (UnitAddTorus.mFourierCoeff (↑↑f) i)) 2) (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun t => HPow.hPow (Norm.norm (↑↑f t)) 2)","decl":"/-- **Parseval's identity** for norms: for an `L²` function `f` on `UnitAddTorus d`, the sum of the\nsquared norms of the Fourier coefficients equals the `L²` norm of `f`. -/\ntheorem hasSum_sq_mFourierCoeff (f : L²(UnitAddTorus d)) :\n    HasSum (fun i ↦ ‖mFourierCoeff f i‖ ^ 2) (∫ t, ‖f t‖ ^ 2) := by\n  simpa only [← RCLike.inner_apply, inner_self_eq_norm_sq, ← integral_re\n    (L2.integrable_inner f f)] using RCLike.hasSum_re ℂ (hasSum_prod_mFourierCoeff f f)\n\n"}
{"name":"UnitAddTorus.mFourierCoeff_toLp","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"d : Type u_1\ninst✝ : Fintype d\nf : ContinuousMap (UnitAddTorus d) Complex\nn : d → Int\n⊢ Eq (UnitAddTorus.mFourierCoeff (↑↑((ContinuousMap.toLp 2 MeasureTheory.MeasureSpace.volume Complex) f)) n) (UnitAddTorus.mFourierCoeff (⇑f) n)","decl":"theorem mFourierCoeff_toLp (n : d → ℤ) :\n    mFourierCoeff (f.toLp 2 volume ℂ) n = mFourierCoeff f n :=\n  integral_congr_ae (ae_eq_rfl.mul <| f.coeFn_toAEEqFun _)\n\n"}
{"name":"UnitAddTorus.hasSum_mFourier_series_of_summable","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"d : Type u_1\ninst✝ : Fintype d\nf : ContinuousMap (UnitAddTorus d) Complex\nh : Summable (UnitAddTorus.mFourierCoeff ⇑f)\n⊢ HasSum (fun i => HSMul.hSMul (UnitAddTorus.mFourierCoeff (⇑f) i) (UnitAddTorus.mFourier i)) f","decl":"/-- If the sequence of Fourier coefficients of `f` is summable, then the Fourier series converges\nuniformly to `f`. -/\ntheorem hasSum_mFourier_series_of_summable (h : Summable (mFourierCoeff f)) :\n    HasSum (fun i ↦ mFourierCoeff f i • mFourier i) f := by\n  have sum_L2 := hasSum_mFourier_series_L2 (ContinuousMap.toLp 2 volume ℂ f)\n  simp only [mFourierCoeff_toLp] at sum_L2\n  refine ContinuousMap.hasSum_of_hasSum_Lp (.of_norm ?_) sum_L2\n  simpa only [norm_smul, mFourier_norm, mul_one] using h.norm\n\n"}
{"name":"UnitAddTorus.hasSum_mFourier_series_apply_of_summable","module":"Mathlib.Analysis.Fourier.AddCircleMulti","initialProofState":"d : Type u_1\ninst✝ : Fintype d\nf : ContinuousMap (UnitAddTorus d) Complex\nh : Summable (UnitAddTorus.mFourierCoeff ⇑f)\nx : UnitAddTorus d\n⊢ HasSum (fun i => HSMul.hSMul (UnitAddTorus.mFourierCoeff (⇑f) i) ((UnitAddTorus.mFourier i) x)) (f x)","decl":"/-- If the sequence of Fourier coefficients of `f` is summable, then the Fourier series of `f`\nconverges everywhere pointwise to `f`. -/\ntheorem hasSum_mFourier_series_apply_of_summable (h : Summable (mFourierCoeff f))\n    (x : UnitAddTorus d) : HasSum (fun i ↦ mFourierCoeff f i • mFourier i x) (f x) := by\n  simpa only [_root_.map_smul] using (ContinuousMap.evalCLM ℂ x).hasSum\n    (hasSum_mFourier_series_of_summable h)\n\n"}
