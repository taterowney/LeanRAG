{"name":"ContinuousLinearMap.norm_map_tail_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nEi : Fin n.succ → Type wEi\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : Fin n.succ) → NormedAddCommGroup (Ei i)\ninst✝² : (i : Fin n.succ) → NormedSpace 𝕜 (Ei i)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousLinearMap (RingHom.id 𝕜) (Ei 0) (ContinuousMultilinearMap 𝕜 (fun i => Ei i.succ) G)\nm : (i : Fin n.succ) → Ei i\n⊢ LE.le (Norm.norm ((f (m 0)) (Fin.tail m))) (HMul.hMul (Norm.norm f) (Finset.univ.prod fun i => Norm.norm (m i)))","decl":"theorem ContinuousLinearMap.norm_map_tail_le\n    (f : Ei 0 →L[𝕜] ContinuousMultilinearMap 𝕜 (fun i : Fin n => Ei i.succ) G) (m : ∀ i, Ei i) :\n    ‖f (m 0) (tail m)‖ ≤ ‖f‖ * ∏ i, ‖m i‖ :=\n  calc\n    ‖f (m 0) (tail m)‖ ≤ ‖f (m 0)‖ * ∏ i, ‖(tail m) i‖ := (f (m 0)).le_opNorm _\n    _ ≤ ‖f‖ * ‖m 0‖ * ∏ i, ‖tail m i‖ := mul_le_mul_of_nonneg_right (f.le_opNorm _) <| by positivity\n    _ = ‖f‖ * (‖m 0‖ * ∏ i, ‖(tail m) i‖) := by ring\n    _ = ‖f‖ * ∏ i, ‖m i‖ := by\n      rw [prod_univ_succ]\n      rfl\n\n"}
{"name":"ContinuousMultilinearMap.norm_map_init_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nEi : Fin n.succ → Type wEi\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : Fin n.succ) → NormedAddCommGroup (Ei i)\ninst✝² : (i : Fin n.succ) → NormedSpace 𝕜 (Ei i)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousMultilinearMap 𝕜 (fun i => Ei i.castSucc) (ContinuousLinearMap (RingHom.id 𝕜) (Ei (Fin.last n)) G)\nm : (i : Fin n.succ) → Ei i\n⊢ LE.le (Norm.norm ((f (Fin.init m)) (m (Fin.last n)))) (HMul.hMul (Norm.norm f) (Finset.univ.prod fun i => Norm.norm (m i)))","decl":"theorem ContinuousMultilinearMap.norm_map_init_le\n    (f : ContinuousMultilinearMap 𝕜 (fun i : Fin n => Ei <| castSucc i) (Ei (last n) →L[𝕜] G))\n    (m : ∀ i, Ei i) : ‖f (init m) (m (last n))‖ ≤ ‖f‖ * ∏ i, ‖m i‖ :=\n  calc\n    ‖f (init m) (m (last n))‖ ≤ ‖f (init m)‖ * ‖m (last n)‖ := (f (init m)).le_opNorm _\n    _ ≤ (‖f‖ * ∏ i, ‖(init m) i‖) * ‖m (last n)‖ :=\n      (mul_le_mul_of_nonneg_right (f.le_opNorm _) (norm_nonneg _))\n    _ = ‖f‖ * ((∏ i, ‖(init m) i‖) * ‖m (last n)‖) := mul_assoc _ _ _\n    _ = ‖f‖ * ∏ i, ‖m i‖ := by\n      rw [prod_univ_castSucc]\n      rfl\n\n"}
{"name":"ContinuousMultilinearMap.norm_map_cons_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nEi : Fin n.succ → Type wEi\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : Fin n.succ) → NormedAddCommGroup (Ei i)\ninst✝² : (i : Fin n.succ) → NormedSpace 𝕜 (Ei i)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousMultilinearMap 𝕜 Ei G\nx : Ei 0\nm : (i : Fin n) → Ei i.succ\n⊢ LE.le (Norm.norm (f (Fin.cons x m))) (HMul.hMul (HMul.hMul (Norm.norm f) (Norm.norm x)) (Finset.univ.prod fun i => Norm.norm (m i)))","decl":"theorem ContinuousMultilinearMap.norm_map_cons_le (f : ContinuousMultilinearMap 𝕜 Ei G) (x : Ei 0)\n    (m : ∀ i : Fin n, Ei i.succ) : ‖f (cons x m)‖ ≤ ‖f‖ * ‖x‖ * ∏ i, ‖m i‖ :=\n  calc\n    ‖f (cons x m)‖ ≤ ‖f‖ * ∏ i, ‖cons x m i‖ := f.le_opNorm _\n    _ = ‖f‖ * ‖x‖ * ∏ i, ‖m i‖ := by\n      rw [prod_univ_succ]\n      simp [mul_assoc]\n\n"}
{"name":"ContinuousMultilinearMap.norm_map_snoc_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nEi : Fin n.succ → Type wEi\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : Fin n.succ) → NormedAddCommGroup (Ei i)\ninst✝² : (i : Fin n.succ) → NormedSpace 𝕜 (Ei i)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousMultilinearMap 𝕜 Ei G\nm : (i : Fin n) → Ei i.castSucc\nx : Ei (Fin.last n)\n⊢ LE.le (Norm.norm (f (Fin.snoc m x))) (HMul.hMul (HMul.hMul (Norm.norm f) (Finset.univ.prod fun i => Norm.norm (m i))) (Norm.norm x))","decl":"theorem ContinuousMultilinearMap.norm_map_snoc_le (f : ContinuousMultilinearMap 𝕜 Ei G)\n    (m : ∀ i : Fin n, Ei <| castSucc i) (x : Ei (last n)) :\n    ‖f (snoc m x)‖ ≤ (‖f‖ * ∏ i, ‖m i‖) * ‖x‖ :=\n  calc\n    ‖f (snoc m x)‖ ≤ ‖f‖ * ∏ i, ‖snoc m x i‖ := f.le_opNorm _\n    _ = (‖f‖ * ∏ i, ‖m i‖) * ‖x‖ := by\n      rw [prod_univ_castSucc]\n      simp [mul_assoc]\n\n"}
{"name":"ContinuousLinearMap.uncurryLeft_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nEi : Fin n.succ → Type wEi\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : Fin n.succ) → NormedAddCommGroup (Ei i)\ninst✝² : (i : Fin n.succ) → NormedSpace 𝕜 (Ei i)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousLinearMap (RingHom.id 𝕜) (Ei 0) (ContinuousMultilinearMap 𝕜 (fun i => Ei i.succ) G)\nm : (i : Fin n.succ) → Ei i\n⊢ Eq (f.uncurryLeft m) ((f (m 0)) (Fin.tail m))","decl":"@[simp]\ntheorem ContinuousLinearMap.uncurryLeft_apply\n    (f : Ei 0 →L[𝕜] ContinuousMultilinearMap 𝕜 (fun i : Fin n => Ei i.succ) G) (m : ∀ i, Ei i) :\n    f.uncurryLeft m = f (m 0) (tail m) :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.curryLeft_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nEi : Fin n.succ → Type wEi\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : Fin n.succ) → NormedAddCommGroup (Ei i)\ninst✝² : (i : Fin n.succ) → NormedSpace 𝕜 (Ei i)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousMultilinearMap 𝕜 Ei G\nx : Ei 0\nm : (i : Fin n) → Ei i.succ\n⊢ Eq ((f.curryLeft x) m) (f (Fin.cons x m))","decl":"@[simp]\ntheorem ContinuousMultilinearMap.curryLeft_apply (f : ContinuousMultilinearMap 𝕜 Ei G) (x : Ei 0)\n    (m : ∀ i : Fin n, Ei i.succ) : f.curryLeft x m = f (cons x m) :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.curry_uncurryLeft","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nEi : Fin n.succ → Type wEi\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : Fin n.succ) → NormedAddCommGroup (Ei i)\ninst✝² : (i : Fin n.succ) → NormedSpace 𝕜 (Ei i)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousLinearMap (RingHom.id 𝕜) (Ei 0) (ContinuousMultilinearMap 𝕜 (fun i => Ei i.succ) G)\n⊢ Eq f.uncurryLeft.curryLeft f","decl":"@[simp]\ntheorem ContinuousLinearMap.curry_uncurryLeft\n    (f : Ei 0 →L[𝕜] ContinuousMultilinearMap 𝕜 (fun i : Fin n => Ei i.succ) G) :\n    f.uncurryLeft.curryLeft = f := by\n  ext m x\n  rw [ContinuousMultilinearMap.curryLeft_apply, ContinuousLinearMap.uncurryLeft_apply, tail_cons,\n    cons_zero]\n\n"}
{"name":"ContinuousMultilinearMap.uncurry_curryLeft","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nEi : Fin n.succ → Type wEi\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : Fin n.succ) → NormedAddCommGroup (Ei i)\ninst✝² : (i : Fin n.succ) → NormedSpace 𝕜 (Ei i)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousMultilinearMap 𝕜 Ei G\n⊢ Eq f.curryLeft.uncurryLeft f","decl":"@[simp]\ntheorem ContinuousMultilinearMap.uncurry_curryLeft (f : ContinuousMultilinearMap 𝕜 Ei G) :\n    f.curryLeft.uncurryLeft = f :=\n  ContinuousMultilinearMap.toMultilinearMap_injective <| f.toMultilinearMap.uncurry_curryLeft\n\n"}
{"name":"continuousMultilinearCurryLeftEquiv_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nEi : Fin n.succ → Type wEi\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : Fin n.succ) → NormedAddCommGroup (Ei i)\ninst✝² : (i : Fin n.succ) → NormedSpace 𝕜 (Ei i)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousMultilinearMap 𝕜 Ei G\nx : Ei 0\nv : (i : Fin n) → Ei i.succ\n⊢ Eq ((((continuousMultilinearCurryLeftEquiv 𝕜 Ei G) f) x) v) (f (Fin.cons x v))","decl":"@[simp]\ntheorem continuousMultilinearCurryLeftEquiv_apply\n    (f : ContinuousMultilinearMap 𝕜 Ei G) (x : Ei 0) (v : Π i : Fin n, Ei i.succ) :\n    continuousMultilinearCurryLeftEquiv 𝕜 Ei G f x v = f (cons x v) :=\n  rfl\n\n"}
{"name":"continuousMultilinearCurryLeftEquiv_symm_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nEi : Fin n.succ → Type wEi\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : Fin n.succ) → NormedAddCommGroup (Ei i)\ninst✝² : (i : Fin n.succ) → NormedSpace 𝕜 (Ei i)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousLinearMap (RingHom.id 𝕜) (Ei 0) (ContinuousMultilinearMap 𝕜 (fun i => Ei i.succ) G)\nv : (i : Fin n.succ) → Ei i\n⊢ Eq (((continuousMultilinearCurryLeftEquiv 𝕜 Ei G).symm f) v) ((f (v 0)) (Fin.tail v))","decl":"@[simp]\ntheorem continuousMultilinearCurryLeftEquiv_symm_apply\n    (f : Ei 0 →L[𝕜] ContinuousMultilinearMap 𝕜 (fun i : Fin n => Ei i.succ) G) (v : Π i, Ei i) :\n    (continuousMultilinearCurryLeftEquiv 𝕜 Ei G).symm f v = f (v 0) (tail v) :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.curryLeft_norm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nEi : Fin n.succ → Type wEi\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : Fin n.succ) → NormedAddCommGroup (Ei i)\ninst✝² : (i : Fin n.succ) → NormedSpace 𝕜 (Ei i)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousMultilinearMap 𝕜 Ei G\n⊢ Eq (Norm.norm f.curryLeft) (Norm.norm f)","decl":"@[simp]\ntheorem ContinuousMultilinearMap.curryLeft_norm (f : ContinuousMultilinearMap 𝕜 Ei G) :\n    ‖f.curryLeft‖ = ‖f‖ :=\n  (continuousMultilinearCurryLeftEquiv 𝕜 Ei G).norm_map f\n\n"}
{"name":"ContinuousLinearMap.uncurryLeft_norm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nEi : Fin n.succ → Type wEi\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : Fin n.succ) → NormedAddCommGroup (Ei i)\ninst✝² : (i : Fin n.succ) → NormedSpace 𝕜 (Ei i)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousLinearMap (RingHom.id 𝕜) (Ei 0) (ContinuousMultilinearMap 𝕜 (fun i => Ei i.succ) G)\n⊢ Eq (Norm.norm f.uncurryLeft) (Norm.norm f)","decl":"@[simp]\ntheorem ContinuousLinearMap.uncurryLeft_norm\n    (f : Ei 0 →L[𝕜] ContinuousMultilinearMap 𝕜 (fun i : Fin n => Ei i.succ) G) :\n    ‖f.uncurryLeft‖ = ‖f‖ :=\n  (continuousMultilinearCurryLeftEquiv 𝕜 Ei G).symm.norm_map f\n\n"}
{"name":"ContinuousMultilinearMap.uncurryRight_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nEi : Fin n.succ → Type wEi\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : Fin n.succ) → NormedAddCommGroup (Ei i)\ninst✝² : (i : Fin n.succ) → NormedSpace 𝕜 (Ei i)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousMultilinearMap 𝕜 (fun i => Ei i.castSucc) (ContinuousLinearMap (RingHom.id 𝕜) (Ei (Fin.last n)) G)\nm : (i : Fin n.succ) → Ei i\n⊢ Eq (f.uncurryRight m) ((f (Fin.init m)) (m (Fin.last n)))","decl":"@[simp]\ntheorem ContinuousMultilinearMap.uncurryRight_apply\n    (f : ContinuousMultilinearMap 𝕜 (fun i : Fin n => Ei <| castSucc i) (Ei (last n) →L[𝕜] G))\n    (m : ∀ i, Ei i) : f.uncurryRight m = f (init m) (m (last n)) :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.curryRight_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nEi : Fin n.succ → Type wEi\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : Fin n.succ) → NormedAddCommGroup (Ei i)\ninst✝² : (i : Fin n.succ) → NormedSpace 𝕜 (Ei i)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousMultilinearMap 𝕜 Ei G\nm : (i : Fin n) → Ei i.castSucc\nx : Ei (Fin.last n)\n⊢ Eq ((f.curryRight m) x) (f (Fin.snoc m x))","decl":"@[simp]\ntheorem ContinuousMultilinearMap.curryRight_apply (f : ContinuousMultilinearMap 𝕜 Ei G)\n    (m : ∀ i : Fin n, Ei <| castSucc i) (x : Ei (last n)) : f.curryRight m x = f (snoc m x) :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.curry_uncurryRight","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nEi : Fin n.succ → Type wEi\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : Fin n.succ) → NormedAddCommGroup (Ei i)\ninst✝² : (i : Fin n.succ) → NormedSpace 𝕜 (Ei i)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousMultilinearMap 𝕜 (fun i => Ei i.castSucc) (ContinuousLinearMap (RingHom.id 𝕜) (Ei (Fin.last n)) G)\n⊢ Eq f.uncurryRight.curryRight f","decl":"@[simp]\ntheorem ContinuousMultilinearMap.curry_uncurryRight\n    (f : ContinuousMultilinearMap 𝕜 (fun i : Fin n => Ei <| castSucc i) (Ei (last n) →L[𝕜] G)) :\n    f.uncurryRight.curryRight = f := by\n  ext m x\n  rw [ContinuousMultilinearMap.curryRight_apply, ContinuousMultilinearMap.uncurryRight_apply,\n    snoc_last, init_snoc]\n\n"}
{"name":"ContinuousMultilinearMap.uncurry_curryRight","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nEi : Fin n.succ → Type wEi\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : Fin n.succ) → NormedAddCommGroup (Ei i)\ninst✝² : (i : Fin n.succ) → NormedSpace 𝕜 (Ei i)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousMultilinearMap 𝕜 Ei G\n⊢ Eq f.curryRight.uncurryRight f","decl":"@[simp]\ntheorem ContinuousMultilinearMap.uncurry_curryRight (f : ContinuousMultilinearMap 𝕜 Ei G) :\n    f.curryRight.uncurryRight = f := by\n  ext m\n  rw [uncurryRight_apply, curryRight_apply, snoc_init_self]\n\n"}
{"name":"continuousMultilinearCurryRightEquiv_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nEi : Fin n.succ → Type wEi\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : Fin n.succ) → NormedAddCommGroup (Ei i)\ninst✝² : (i : Fin n.succ) → NormedSpace 𝕜 (Ei i)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousMultilinearMap 𝕜 Ei G\nv : (i : Fin n) → Ei i.castSucc\nx : Ei (Fin.last n)\n⊢ Eq ((((continuousMultilinearCurryRightEquiv 𝕜 Ei G) f) v) x) (f (Fin.snoc v x))","decl":"@[simp]\ntheorem continuousMultilinearCurryRightEquiv_apply\n    (f : ContinuousMultilinearMap 𝕜 Ei G) (v : Π i : Fin n, Ei <| castSucc i) (x : Ei (last n)) :\n    continuousMultilinearCurryRightEquiv 𝕜 Ei G f v x = f (snoc v x) :=\n  rfl\n\n"}
{"name":"continuousMultilinearCurryRightEquiv_symm_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nEi : Fin n.succ → Type wEi\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : Fin n.succ) → NormedAddCommGroup (Ei i)\ninst✝² : (i : Fin n.succ) → NormedSpace 𝕜 (Ei i)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousMultilinearMap 𝕜 (fun i => Ei i.castSucc) (ContinuousLinearMap (RingHom.id 𝕜) (Ei (Fin.last n)) G)\nv : (i : Fin n.succ) → Ei i\n⊢ Eq (((continuousMultilinearCurryRightEquiv 𝕜 Ei G).symm f) v) ((f (Fin.init v)) (v (Fin.last n)))","decl":"@[simp]\ntheorem continuousMultilinearCurryRightEquiv_symm_apply\n    (f : ContinuousMultilinearMap 𝕜 (fun i : Fin n => Ei <| castSucc i) (Ei (last n) →L[𝕜] G))\n    (v : Π i, Ei i) :\n    (continuousMultilinearCurryRightEquiv 𝕜 Ei G).symm f v = f (init v) (v (last n)) :=\n  rfl\n\n"}
{"name":"continuousMultilinearCurryRightEquiv_apply'","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nG : Type wG\nG' : Type wG'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nf : ContinuousMultilinearMap 𝕜 (fun i => G) G'\nv : Fin n → G\nx : G\n⊢ Eq ((((continuousMultilinearCurryRightEquiv' 𝕜 n G G') f) v) x) (f (Fin.snoc v x))","decl":"@[simp]\ntheorem continuousMultilinearCurryRightEquiv_apply'\n    (f : G[×n.succ]→L[𝕜] G') (v : Fin n → G) (x : G) :\n    continuousMultilinearCurryRightEquiv' 𝕜 n G G' f v x = f (snoc v x) :=\n  rfl\n\n"}
{"name":"continuousMultilinearCurryRightEquiv_symm_apply'","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nG : Type wG\nG' : Type wG'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nf : ContinuousMultilinearMap 𝕜 (fun i => G) (ContinuousLinearMap (RingHom.id 𝕜) G G')\nv : Fin (HAdd.hAdd n 1) → G\n⊢ Eq (((continuousMultilinearCurryRightEquiv' 𝕜 n G G').symm f) v) ((f (Fin.init v)) (v (Fin.last n)))","decl":"@[simp]\ntheorem continuousMultilinearCurryRightEquiv_symm_apply'\n    (f : G[×n]→L[𝕜] G →L[𝕜] G') (v : Fin (n + 1) → G) :\n    (continuousMultilinearCurryRightEquiv' 𝕜 n G G').symm f v = f (init v) (v (last n)) :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.curryRight_norm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nEi : Fin n.succ → Type wEi\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : Fin n.succ) → NormedAddCommGroup (Ei i)\ninst✝² : (i : Fin n.succ) → NormedSpace 𝕜 (Ei i)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousMultilinearMap 𝕜 Ei G\n⊢ Eq (Norm.norm f.curryRight) (Norm.norm f)","decl":"@[simp]\ntheorem ContinuousMultilinearMap.curryRight_norm (f : ContinuousMultilinearMap 𝕜 Ei G) :\n    ‖f.curryRight‖ = ‖f‖ :=\n  (continuousMultilinearCurryRightEquiv 𝕜 Ei G).norm_map f\n\n"}
{"name":"ContinuousMultilinearMap.uncurryRight_norm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nEi : Fin n.succ → Type wEi\nG : Type wG\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : (i : Fin n.succ) → NormedAddCommGroup (Ei i)\ninst✝² : (i : Fin n.succ) → NormedSpace 𝕜 (Ei i)\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : ContinuousMultilinearMap 𝕜 (fun i => Ei i.castSucc) (ContinuousLinearMap (RingHom.id 𝕜) (Ei (Fin.last n)) G)\n⊢ Eq (Norm.norm f.uncurryRight) (Norm.norm f)","decl":"@[simp]\ntheorem ContinuousMultilinearMap.uncurryRight_norm\n    (f : ContinuousMultilinearMap 𝕜 (fun i : Fin n => Ei <| castSucc i) (Ei (last n) →L[𝕜] G)) :\n    ‖f.uncurryRight‖ = ‖f‖ :=\n  (continuousMultilinearCurryRightEquiv 𝕜 Ei G).symm.norm_map f\n\n"}
{"name":"ContinuousMultilinearMap.uncurry0_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nG : Type wG\nG' : Type wG'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nx : G'\nm : Fin 0 → G\n⊢ Eq ((ContinuousMultilinearMap.uncurry0 𝕜 G x) m) x","decl":"variable (𝕜) in\n@[simp]\ntheorem ContinuousMultilinearMap.uncurry0_apply (x : G') (m : Fin 0 → G) :\n    ContinuousMultilinearMap.uncurry0 𝕜 G x m = x :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.curry0_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nG : Type wG\nG' : Type wG'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nf : ContinuousMultilinearMap 𝕜 (fun i => G) G'\n⊢ Eq f.curry0 (f 0)","decl":"@[simp]\ntheorem ContinuousMultilinearMap.curry0_apply (f : G[×0]→L[𝕜] G') : f.curry0 = f 0 :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.apply_zero_uncurry0","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nG : Type wG\nG' : Type wG'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nf : ContinuousMultilinearMap 𝕜 (fun i => G) G'\nx : Fin 0 → G\n⊢ Eq (ContinuousMultilinearMap.uncurry0 𝕜 G (f x)) f","decl":"@[simp]\ntheorem ContinuousMultilinearMap.apply_zero_uncurry0 (f : G[×0]→L[𝕜] G') {x : Fin 0 → G} :\n    ContinuousMultilinearMap.uncurry0 𝕜 G (f x) = f := by\n  ext m\n  simp [Subsingleton.elim x m]\n\n"}
{"name":"ContinuousMultilinearMap.uncurry0_curry0","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nG : Type wG\nG' : Type wG'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nf : ContinuousMultilinearMap 𝕜 (fun i => G) G'\n⊢ Eq (ContinuousMultilinearMap.uncurry0 𝕜 G f.curry0) f","decl":"theorem ContinuousMultilinearMap.uncurry0_curry0 (f : G[×0]→L[𝕜] G') :\n    ContinuousMultilinearMap.uncurry0 𝕜 G f.curry0 = f := by simp\n\n"}
{"name":"ContinuousMultilinearMap.curry0_uncurry0","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nG : Type wG\nG' : Type wG'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nx : G'\n⊢ Eq (ContinuousMultilinearMap.uncurry0 𝕜 G x).curry0 x","decl":"variable (𝕜 G) in\ntheorem ContinuousMultilinearMap.curry0_uncurry0 (x : G') :\n    (ContinuousMultilinearMap.uncurry0 𝕜 G x).curry0 = x :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.uncurry0_norm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nG : Type wG\nG' : Type wG'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nx : G'\n⊢ Eq (Norm.norm (ContinuousMultilinearMap.uncurry0 𝕜 G x)) (Norm.norm x)","decl":"variable (𝕜 G) in\n@[simp]\ntheorem ContinuousMultilinearMap.uncurry0_norm (x : G') :\n    ‖ContinuousMultilinearMap.uncurry0 𝕜 G x‖ = ‖x‖ :=\n  norm_constOfIsEmpty _ _ _\n\n"}
{"name":"ContinuousMultilinearMap.fin0_apply_norm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nG : Type wG\nG' : Type wG'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nf : ContinuousMultilinearMap 𝕜 (fun i => G) G'\nx : Fin 0 → G\n⊢ Eq (Norm.norm (f x)) (Norm.norm f)","decl":"@[simp]\ntheorem ContinuousMultilinearMap.fin0_apply_norm (f : G[×0]→L[𝕜] G') {x : Fin 0 → G} :\n    ‖f x‖ = ‖f‖ := by\n  obtain rfl : x = 0 := Subsingleton.elim _ _\n  refine le_antisymm (by simpa using f.le_opNorm 0) ?_\n  have : ‖ContinuousMultilinearMap.uncurry0 𝕜 G f.curry0‖ ≤ ‖f.curry0‖ :=\n    ContinuousMultilinearMap.opNorm_le_bound (norm_nonneg _) fun m => by\n      simp [-ContinuousMultilinearMap.apply_zero_uncurry0]\n  simpa [-Matrix.zero_empty] using this\n\n"}
{"name":"ContinuousMultilinearMap.curry0_norm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nG : Type wG\nG' : Type wG'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nf : ContinuousMultilinearMap 𝕜 (fun i => G) G'\n⊢ Eq (Norm.norm f.curry0) (Norm.norm f)","decl":"theorem ContinuousMultilinearMap.curry0_norm (f : G[×0]→L[𝕜] G') : ‖f.curry0‖ = ‖f‖ := by simp\n\n"}
{"name":"continuousMultilinearCurryFin0_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nG : Type wG\nG' : Type wG'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nf : ContinuousMultilinearMap 𝕜 (fun i => G) G'\n⊢ Eq ((continuousMultilinearCurryFin0 𝕜 G G') f) (f 0)","decl":"@[simp]\ntheorem continuousMultilinearCurryFin0_apply (f : G[×0]→L[𝕜] G') :\n    continuousMultilinearCurryFin0 𝕜 G G' f = f 0 :=\n  rfl\n\n"}
{"name":"continuousMultilinearCurryFin0_symm_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nG : Type wG\nG' : Type wG'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nx : G'\nv : Fin 0 → G\n⊢ Eq (((continuousMultilinearCurryFin0 𝕜 G G').symm x) v) x","decl":"@[simp]\ntheorem continuousMultilinearCurryFin0_symm_apply (x : G') (v : Fin 0 → G) :\n    (continuousMultilinearCurryFin0 𝕜 G G').symm x v = x :=\n  rfl\n\n"}
{"name":"continuousMultilinearCurryFin1_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nG : Type wG\nG' : Type wG'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nf : ContinuousMultilinearMap 𝕜 (fun i => G) G'\nx : G\n⊢ Eq (((continuousMultilinearCurryFin1 𝕜 G G') f) x) (f (Fin.snoc 0 x))","decl":"@[simp]\ntheorem continuousMultilinearCurryFin1_apply (f : G[×1]→L[𝕜] G') (x : G) :\n    continuousMultilinearCurryFin1 𝕜 G G' f x = f (Fin.snoc 0 x) :=\n  rfl\n\n"}
{"name":"continuousMultilinearCurryFin1_symm_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nG : Type wG\nG' : Type wG'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nf : ContinuousLinearMap (RingHom.id 𝕜) G G'\nv : Fin 1 → G\n⊢ Eq (((continuousMultilinearCurryFin1 𝕜 G G').symm f) v) (f (v 0))","decl":"@[simp]\ntheorem continuousMultilinearCurryFin1_symm_apply (f : G →L[𝕜] G') (v : Fin 1 → G) :\n    (continuousMultilinearCurryFin1 𝕜 G G').symm f v = f (v 0) :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.norm_domDomCongr","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nι : Type v\nι' : Type v'\nG : Type wG\nG' : Type wG'\ninst✝⁶ : Fintype ι\ninst✝⁵ : Fintype ι'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nσ : Equiv ι ι'\nf : ContinuousMultilinearMap 𝕜 (fun x => G) G'\n⊢ Eq (Norm.norm (ContinuousMultilinearMap.domDomCongr σ f)) (Norm.norm f)","decl":"@[simp]\ntheorem norm_domDomCongr (σ : ι ≃ ι') (f : ContinuousMultilinearMap 𝕜 (fun _ : ι => G) G') :\n    ‖domDomCongr σ f‖ = ‖f‖ := by\n  simp only [norm_def, LinearEquiv.coe_mk, ← σ.prod_comp,\n    (σ.arrowCongr (Equiv.refl G)).surjective.forall, domDomCongr_apply, Equiv.arrowCongr_apply,\n    Equiv.coe_refl, id_comp, comp_apply, Equiv.symm_apply_apply, id]\n\n"}
{"name":"ContinuousMultilinearMap.currySum_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nι : Type v\nι' : Type v'\nG : Type wG\nG' : Type wG'\ninst✝⁶ : Fintype ι\ninst✝⁵ : Fintype ι'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nf : ContinuousMultilinearMap 𝕜 (fun x => G) G'\nm : ι → G\nm' : ι' → G\n⊢ Eq ((f.currySum m) m') (f (Sum.elim m m'))","decl":"@[simp]\ntheorem currySum_apply (f : ContinuousMultilinearMap 𝕜 (fun _ : ι ⊕ ι' => G) G') (m : ι → G)\n    (m' : ι' → G) : f.currySum m m' = f (Sum.elim m m') :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.uncurrySum_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nι : Type v\nι' : Type v'\nG : Type wG\nG' : Type wG'\ninst✝⁶ : Fintype ι\ninst✝⁵ : Fintype ι'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nf : ContinuousMultilinearMap 𝕜 (fun x => G) (ContinuousMultilinearMap 𝕜 (fun x => G) G')\nm : Sum ι ι' → G\n⊢ Eq (f.uncurrySum m) ((f (Function.comp m Sum.inl)) (Function.comp m Sum.inr))","decl":"@[simp]\ntheorem uncurrySum_apply (f : ContinuousMultilinearMap 𝕜 (fun _ : ι => G)\n    (ContinuousMultilinearMap 𝕜 (fun _ : ι' => G) G'))\n    (m : ι ⊕ ι' → G) : f.uncurrySum m = f (m ∘ Sum.inl) (m ∘ Sum.inr) :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.curryFinFinset_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nG : Type wG\nG' : Type wG'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nk l : Nat\ns : Finset (Fin n)\nhk : Eq s.card k\nhl : Eq (HasCompl.compl s).card l\nf : ContinuousMultilinearMap 𝕜 (fun i => G) G'\nmk : Fin k → G\nml : Fin l → G\n⊢ Eq ((((ContinuousMultilinearMap.curryFinFinset 𝕜 G G' hk hl) f) mk) ml) (f fun i => Sum.elim mk ml ((finSumEquivOfFinset hk hl).symm i))","decl":"@[simp]\ntheorem curryFinFinset_apply (hk : #s = k) (hl : #sᶜ = l) (f : G[×n]→L[𝕜] G')\n    (mk : Fin k → G) (ml : Fin l → G) : curryFinFinset 𝕜 G G' hk hl f mk ml =\n      f fun i => Sum.elim mk ml ((finSumEquivOfFinset hk hl).symm i) :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.curryFinFinset_symm_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nG : Type wG\nG' : Type wG'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nk l : Nat\ns : Finset (Fin n)\nhk : Eq s.card k\nhl : Eq (HasCompl.compl s).card l\nf : ContinuousMultilinearMap 𝕜 (fun i => G) (ContinuousMultilinearMap 𝕜 (fun i => G) G')\nm : Fin n → G\n⊢ Eq (((ContinuousMultilinearMap.curryFinFinset 𝕜 G G' hk hl).symm f) m) ((f fun i => m ((finSumEquivOfFinset hk hl) (Sum.inl i))) fun i => m ((finSumEquivOfFinset hk hl) (Sum.inr i)))","decl":"@[simp]\ntheorem curryFinFinset_symm_apply (hk : #s = k) (hl : #sᶜ = l)\n    (f : G[×k]→L[𝕜] G[×l]→L[𝕜] G') (m : Fin n → G) : (curryFinFinset 𝕜 G G' hk hl).symm f m =\n      f (fun i => m <| finSumEquivOfFinset hk hl (Sum.inl i)) fun i =>\n        m <| finSumEquivOfFinset hk hl (Sum.inr i) :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.curryFinFinset_symm_apply_piecewise_const","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nG : Type wG\nG' : Type wG'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nk l : Nat\ns : Finset (Fin n)\nhk : Eq s.card k\nhl : Eq (HasCompl.compl s).card l\nf : ContinuousMultilinearMap 𝕜 (fun i => G) (ContinuousMultilinearMap 𝕜 (fun i => G) G')\nx y : G\n⊢ Eq (((ContinuousMultilinearMap.curryFinFinset 𝕜 G G' hk hl).symm f) (s.piecewise (fun x_1 => x) fun x => y)) ((f fun x_1 => x) fun x => y)","decl":"theorem curryFinFinset_symm_apply_piecewise_const (hk : #s = k) (hl : #sᶜ = l)\n    (f : G[×k]→L[𝕜] G[×l]→L[𝕜] G') (x y : G) :\n    (curryFinFinset 𝕜 G G' hk hl).symm f (s.piecewise (fun _ => x) fun _ => y) =\n      f (fun _ => x) fun _ => y :=\n  MultilinearMap.curryFinFinset_symm_apply_piecewise_const hk hl _ x y\n\n"}
{"name":"ContinuousMultilinearMap.curryFinFinset_symm_apply_const","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nG : Type wG\nG' : Type wG'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nk l : Nat\ns : Finset (Fin n)\nhk : Eq s.card k\nhl : Eq (HasCompl.compl s).card l\nf : ContinuousMultilinearMap 𝕜 (fun i => G) (ContinuousMultilinearMap 𝕜 (fun i => G) G')\nx : G\n⊢ Eq (((ContinuousMultilinearMap.curryFinFinset 𝕜 G G' hk hl).symm f) fun x_1 => x) ((f fun x_1 => x) fun x_1 => x)","decl":"@[simp]\ntheorem curryFinFinset_symm_apply_const (hk : #s = k) (hl : #sᶜ = l)\n    (f : G[×k]→L[𝕜] G[×l]→L[𝕜] G') (x : G) :\n    ((curryFinFinset 𝕜 G G' hk hl).symm f fun _ => x) = f (fun _ => x) fun _ => x :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.curryFinFinset_apply_const","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nn : Nat\nG : Type wG\nG' : Type wG'\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : NormedAddCommGroup G'\ninst✝ : NormedSpace 𝕜 G'\nk l : Nat\ns : Finset (Fin n)\nhk : Eq s.card k\nhl : Eq (HasCompl.compl s).card l\nf : ContinuousMultilinearMap 𝕜 (fun i => G) G'\nx y : G\n⊢ Eq ((((ContinuousMultilinearMap.curryFinFinset 𝕜 G G' hk hl) f) fun x_1 => x) fun x => y) (f (s.piecewise (fun x_1 => x) fun x => y))","decl":"theorem curryFinFinset_apply_const (hk : #s = k) (hl : #sᶜ = l) (f : G[×n]→L[𝕜] G')\n    (x y : G) : (curryFinFinset 𝕜 G G' hk hl f (fun _ => x) fun _ => y) =\n      f (s.piecewise (fun _ => x) fun _ => y) := by\n  refine (curryFinFinset_symm_apply_piecewise_const hk hl _ _ _).symm.trans ?_\n  rw [LinearIsometryEquiv.symm_apply_apply]\n\n"}
{"name":"ContinuousLinearMap.continuousMultilinearMapOption_apply_eq_self","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"𝕜 : Type u\nι : Type v\nE : ι → Type wE\ninst✝⁷ : Fintype ι\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : (i : ι) → NormedAddCommGroup (E i)\ninst✝⁴ : (i : ι) → NormedSpace 𝕜 (E i)\nF : Type u_1\nG : Type u_2\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nB : ContinuousLinearMap (RingHom.id 𝕜) G (ContinuousMultilinearMap 𝕜 E F)\na : G\nv : (i : ι) → E i\n⊢ Eq (B.continuousMultilinearMapOption fun x => { fst := a, snd := v }) ((B a) v)","decl":"lemma continuousMultilinearMapOption_apply_eq_self (B : G →L[𝕜] ContinuousMultilinearMap 𝕜 E F)\n    (a : G) (v : Π i, E i) : B.continuousMultilinearMapOption (fun _ ↦ (a, v)) = B a v := rfl\n\n"}
