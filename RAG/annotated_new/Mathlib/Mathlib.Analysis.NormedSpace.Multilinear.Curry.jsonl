{"name":"ContinuousLinearMap.norm_map_tail_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nEi : Fin n.succ â†’ Type wEi\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Fin n.succ) â†’ NormedAddCommGroup (Ei i)\ninstâœÂ² : (i : Fin n.succ) â†’ NormedSpace ğ•œ (Ei i)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousLinearMap (RingHom.id ğ•œ) (Ei 0) (ContinuousMultilinearMap ğ•œ (fun i => Ei i.succ) G)\nm : (i : Fin n.succ) â†’ Ei i\nâŠ¢ LE.le (Norm.norm ((f (m 0)) (Fin.tail m))) (HMul.hMul (Norm.norm f) (Finset.univ.prod fun i => Norm.norm (m i)))","decl":"theorem ContinuousLinearMap.norm_map_tail_le\n    (f : Ei 0 â†’L[ğ•œ] ContinuousMultilinearMap ğ•œ (fun i : Fin n => Ei i.succ) G) (m : âˆ€ i, Ei i) :\n    â€–f (m 0) (tail m)â€– â‰¤ â€–fâ€– * âˆ i, â€–m iâ€– :=\n  calc\n    â€–f (m 0) (tail m)â€– â‰¤ â€–f (m 0)â€– * âˆ i, â€–(tail m) iâ€– := (f (m 0)).le_opNorm _\n    _ â‰¤ â€–fâ€– * â€–m 0â€– * âˆ i, â€–tail m iâ€– := mul_le_mul_of_nonneg_right (f.le_opNorm _) <| by positivity\n    _ = â€–fâ€– * (â€–m 0â€– * âˆ i, â€–(tail m) iâ€–) := by ring\n    _ = â€–fâ€– * âˆ i, â€–m iâ€– := by\n      rw [prod_univ_succ]\n      rfl\n\n"}
{"name":"ContinuousMultilinearMap.norm_map_init_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nEi : Fin n.succ â†’ Type wEi\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Fin n.succ) â†’ NormedAddCommGroup (Ei i)\ninstâœÂ² : (i : Fin n.succ) â†’ NormedSpace ğ•œ (Ei i)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousMultilinearMap ğ•œ (fun i => Ei i.castSucc) (ContinuousLinearMap (RingHom.id ğ•œ) (Ei (Fin.last n)) G)\nm : (i : Fin n.succ) â†’ Ei i\nâŠ¢ LE.le (Norm.norm ((f (Fin.init m)) (m (Fin.last n)))) (HMul.hMul (Norm.norm f) (Finset.univ.prod fun i => Norm.norm (m i)))","decl":"theorem ContinuousMultilinearMap.norm_map_init_le\n    (f : ContinuousMultilinearMap ğ•œ (fun i : Fin n => Ei <| castSucc i) (Ei (last n) â†’L[ğ•œ] G))\n    (m : âˆ€ i, Ei i) : â€–f (init m) (m (last n))â€– â‰¤ â€–fâ€– * âˆ i, â€–m iâ€– :=\n  calc\n    â€–f (init m) (m (last n))â€– â‰¤ â€–f (init m)â€– * â€–m (last n)â€– := (f (init m)).le_opNorm _\n    _ â‰¤ (â€–fâ€– * âˆ i, â€–(init m) iâ€–) * â€–m (last n)â€– :=\n      (mul_le_mul_of_nonneg_right (f.le_opNorm _) (norm_nonneg _))\n    _ = â€–fâ€– * ((âˆ i, â€–(init m) iâ€–) * â€–m (last n)â€–) := mul_assoc _ _ _\n    _ = â€–fâ€– * âˆ i, â€–m iâ€– := by\n      rw [prod_univ_castSucc]\n      rfl\n\n"}
{"name":"ContinuousMultilinearMap.norm_map_cons_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nEi : Fin n.succ â†’ Type wEi\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Fin n.succ) â†’ NormedAddCommGroup (Ei i)\ninstâœÂ² : (i : Fin n.succ) â†’ NormedSpace ğ•œ (Ei i)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousMultilinearMap ğ•œ Ei G\nx : Ei 0\nm : (i : Fin n) â†’ Ei i.succ\nâŠ¢ LE.le (Norm.norm (f (Fin.cons x m))) (HMul.hMul (HMul.hMul (Norm.norm f) (Norm.norm x)) (Finset.univ.prod fun i => Norm.norm (m i)))","decl":"theorem ContinuousMultilinearMap.norm_map_cons_le (f : ContinuousMultilinearMap ğ•œ Ei G) (x : Ei 0)\n    (m : âˆ€ i : Fin n, Ei i.succ) : â€–f (cons x m)â€– â‰¤ â€–fâ€– * â€–xâ€– * âˆ i, â€–m iâ€– :=\n  calc\n    â€–f (cons x m)â€– â‰¤ â€–fâ€– * âˆ i, â€–cons x m iâ€– := f.le_opNorm _\n    _ = â€–fâ€– * â€–xâ€– * âˆ i, â€–m iâ€– := by\n      rw [prod_univ_succ]\n      simp [mul_assoc]\n\n"}
{"name":"ContinuousMultilinearMap.norm_map_snoc_le","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nEi : Fin n.succ â†’ Type wEi\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Fin n.succ) â†’ NormedAddCommGroup (Ei i)\ninstâœÂ² : (i : Fin n.succ) â†’ NormedSpace ğ•œ (Ei i)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousMultilinearMap ğ•œ Ei G\nm : (i : Fin n) â†’ Ei i.castSucc\nx : Ei (Fin.last n)\nâŠ¢ LE.le (Norm.norm (f (Fin.snoc m x))) (HMul.hMul (HMul.hMul (Norm.norm f) (Finset.univ.prod fun i => Norm.norm (m i))) (Norm.norm x))","decl":"theorem ContinuousMultilinearMap.norm_map_snoc_le (f : ContinuousMultilinearMap ğ•œ Ei G)\n    (m : âˆ€ i : Fin n, Ei <| castSucc i) (x : Ei (last n)) :\n    â€–f (snoc m x)â€– â‰¤ (â€–fâ€– * âˆ i, â€–m iâ€–) * â€–xâ€– :=\n  calc\n    â€–f (snoc m x)â€– â‰¤ â€–fâ€– * âˆ i, â€–snoc m x iâ€– := f.le_opNorm _\n    _ = (â€–fâ€– * âˆ i, â€–m iâ€–) * â€–xâ€– := by\n      rw [prod_univ_castSucc]\n      simp [mul_assoc]\n\n"}
{"name":"ContinuousLinearMap.uncurryLeft_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nEi : Fin n.succ â†’ Type wEi\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Fin n.succ) â†’ NormedAddCommGroup (Ei i)\ninstâœÂ² : (i : Fin n.succ) â†’ NormedSpace ğ•œ (Ei i)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousLinearMap (RingHom.id ğ•œ) (Ei 0) (ContinuousMultilinearMap ğ•œ (fun i => Ei i.succ) G)\nm : (i : Fin n.succ) â†’ Ei i\nâŠ¢ Eq (f.uncurryLeft m) ((f (m 0)) (Fin.tail m))","decl":"@[simp]\ntheorem ContinuousLinearMap.uncurryLeft_apply\n    (f : Ei 0 â†’L[ğ•œ] ContinuousMultilinearMap ğ•œ (fun i : Fin n => Ei i.succ) G) (m : âˆ€ i, Ei i) :\n    f.uncurryLeft m = f (m 0) (tail m) :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.curryLeft_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nEi : Fin n.succ â†’ Type wEi\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Fin n.succ) â†’ NormedAddCommGroup (Ei i)\ninstâœÂ² : (i : Fin n.succ) â†’ NormedSpace ğ•œ (Ei i)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousMultilinearMap ğ•œ Ei G\nx : Ei 0\nm : (i : Fin n) â†’ Ei i.succ\nâŠ¢ Eq ((f.curryLeft x) m) (f (Fin.cons x m))","decl":"@[simp]\ntheorem ContinuousMultilinearMap.curryLeft_apply (f : ContinuousMultilinearMap ğ•œ Ei G) (x : Ei 0)\n    (m : âˆ€ i : Fin n, Ei i.succ) : f.curryLeft x m = f (cons x m) :=\n  rfl\n\n"}
{"name":"ContinuousLinearMap.curry_uncurryLeft","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nEi : Fin n.succ â†’ Type wEi\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Fin n.succ) â†’ NormedAddCommGroup (Ei i)\ninstâœÂ² : (i : Fin n.succ) â†’ NormedSpace ğ•œ (Ei i)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousLinearMap (RingHom.id ğ•œ) (Ei 0) (ContinuousMultilinearMap ğ•œ (fun i => Ei i.succ) G)\nâŠ¢ Eq f.uncurryLeft.curryLeft f","decl":"@[simp]\ntheorem ContinuousLinearMap.curry_uncurryLeft\n    (f : Ei 0 â†’L[ğ•œ] ContinuousMultilinearMap ğ•œ (fun i : Fin n => Ei i.succ) G) :\n    f.uncurryLeft.curryLeft = f := by\n  ext m x\n  rw [ContinuousMultilinearMap.curryLeft_apply, ContinuousLinearMap.uncurryLeft_apply, tail_cons,\n    cons_zero]\n\n"}
{"name":"ContinuousMultilinearMap.uncurry_curryLeft","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nEi : Fin n.succ â†’ Type wEi\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Fin n.succ) â†’ NormedAddCommGroup (Ei i)\ninstâœÂ² : (i : Fin n.succ) â†’ NormedSpace ğ•œ (Ei i)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousMultilinearMap ğ•œ Ei G\nâŠ¢ Eq f.curryLeft.uncurryLeft f","decl":"@[simp]\ntheorem ContinuousMultilinearMap.uncurry_curryLeft (f : ContinuousMultilinearMap ğ•œ Ei G) :\n    f.curryLeft.uncurryLeft = f :=\n  ContinuousMultilinearMap.toMultilinearMap_injective <| f.toMultilinearMap.uncurry_curryLeft\n\n"}
{"name":"continuousMultilinearCurryLeftEquiv_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nEi : Fin n.succ â†’ Type wEi\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Fin n.succ) â†’ NormedAddCommGroup (Ei i)\ninstâœÂ² : (i : Fin n.succ) â†’ NormedSpace ğ•œ (Ei i)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousMultilinearMap ğ•œ Ei G\nx : Ei 0\nv : (i : Fin n) â†’ Ei i.succ\nâŠ¢ Eq ((((continuousMultilinearCurryLeftEquiv ğ•œ Ei G) f) x) v) (f (Fin.cons x v))","decl":"@[simp]\ntheorem continuousMultilinearCurryLeftEquiv_apply\n    (f : ContinuousMultilinearMap ğ•œ Ei G) (x : Ei 0) (v : Î  i : Fin n, Ei i.succ) :\n    continuousMultilinearCurryLeftEquiv ğ•œ Ei G f x v = f (cons x v) :=\n  rfl\n\n"}
{"name":"continuousMultilinearCurryLeftEquiv_symm_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nEi : Fin n.succ â†’ Type wEi\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Fin n.succ) â†’ NormedAddCommGroup (Ei i)\ninstâœÂ² : (i : Fin n.succ) â†’ NormedSpace ğ•œ (Ei i)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousLinearMap (RingHom.id ğ•œ) (Ei 0) (ContinuousMultilinearMap ğ•œ (fun i => Ei i.succ) G)\nv : (i : Fin n.succ) â†’ Ei i\nâŠ¢ Eq (((continuousMultilinearCurryLeftEquiv ğ•œ Ei G).symm f) v) ((f (v 0)) (Fin.tail v))","decl":"@[simp]\ntheorem continuousMultilinearCurryLeftEquiv_symm_apply\n    (f : Ei 0 â†’L[ğ•œ] ContinuousMultilinearMap ğ•œ (fun i : Fin n => Ei i.succ) G) (v : Î  i, Ei i) :\n    (continuousMultilinearCurryLeftEquiv ğ•œ Ei G).symm f v = f (v 0) (tail v) :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.curryLeft_norm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nEi : Fin n.succ â†’ Type wEi\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Fin n.succ) â†’ NormedAddCommGroup (Ei i)\ninstâœÂ² : (i : Fin n.succ) â†’ NormedSpace ğ•œ (Ei i)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousMultilinearMap ğ•œ Ei G\nâŠ¢ Eq (Norm.norm f.curryLeft) (Norm.norm f)","decl":"@[simp]\ntheorem ContinuousMultilinearMap.curryLeft_norm (f : ContinuousMultilinearMap ğ•œ Ei G) :\n    â€–f.curryLeftâ€– = â€–fâ€– :=\n  (continuousMultilinearCurryLeftEquiv ğ•œ Ei G).norm_map f\n\n"}
{"name":"ContinuousLinearMap.uncurryLeft_norm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nEi : Fin n.succ â†’ Type wEi\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Fin n.succ) â†’ NormedAddCommGroup (Ei i)\ninstâœÂ² : (i : Fin n.succ) â†’ NormedSpace ğ•œ (Ei i)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousLinearMap (RingHom.id ğ•œ) (Ei 0) (ContinuousMultilinearMap ğ•œ (fun i => Ei i.succ) G)\nâŠ¢ Eq (Norm.norm f.uncurryLeft) (Norm.norm f)","decl":"@[simp]\ntheorem ContinuousLinearMap.uncurryLeft_norm\n    (f : Ei 0 â†’L[ğ•œ] ContinuousMultilinearMap ğ•œ (fun i : Fin n => Ei i.succ) G) :\n    â€–f.uncurryLeftâ€– = â€–fâ€– :=\n  (continuousMultilinearCurryLeftEquiv ğ•œ Ei G).symm.norm_map f\n\n"}
{"name":"ContinuousMultilinearMap.uncurryRight_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nEi : Fin n.succ â†’ Type wEi\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Fin n.succ) â†’ NormedAddCommGroup (Ei i)\ninstâœÂ² : (i : Fin n.succ) â†’ NormedSpace ğ•œ (Ei i)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousMultilinearMap ğ•œ (fun i => Ei i.castSucc) (ContinuousLinearMap (RingHom.id ğ•œ) (Ei (Fin.last n)) G)\nm : (i : Fin n.succ) â†’ Ei i\nâŠ¢ Eq (f.uncurryRight m) ((f (Fin.init m)) (m (Fin.last n)))","decl":"@[simp]\ntheorem ContinuousMultilinearMap.uncurryRight_apply\n    (f : ContinuousMultilinearMap ğ•œ (fun i : Fin n => Ei <| castSucc i) (Ei (last n) â†’L[ğ•œ] G))\n    (m : âˆ€ i, Ei i) : f.uncurryRight m = f (init m) (m (last n)) :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.curryRight_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nEi : Fin n.succ â†’ Type wEi\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Fin n.succ) â†’ NormedAddCommGroup (Ei i)\ninstâœÂ² : (i : Fin n.succ) â†’ NormedSpace ğ•œ (Ei i)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousMultilinearMap ğ•œ Ei G\nm : (i : Fin n) â†’ Ei i.castSucc\nx : Ei (Fin.last n)\nâŠ¢ Eq ((f.curryRight m) x) (f (Fin.snoc m x))","decl":"@[simp]\ntheorem ContinuousMultilinearMap.curryRight_apply (f : ContinuousMultilinearMap ğ•œ Ei G)\n    (m : âˆ€ i : Fin n, Ei <| castSucc i) (x : Ei (last n)) : f.curryRight m x = f (snoc m x) :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.curry_uncurryRight","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nEi : Fin n.succ â†’ Type wEi\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Fin n.succ) â†’ NormedAddCommGroup (Ei i)\ninstâœÂ² : (i : Fin n.succ) â†’ NormedSpace ğ•œ (Ei i)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousMultilinearMap ğ•œ (fun i => Ei i.castSucc) (ContinuousLinearMap (RingHom.id ğ•œ) (Ei (Fin.last n)) G)\nâŠ¢ Eq f.uncurryRight.curryRight f","decl":"@[simp]\ntheorem ContinuousMultilinearMap.curry_uncurryRight\n    (f : ContinuousMultilinearMap ğ•œ (fun i : Fin n => Ei <| castSucc i) (Ei (last n) â†’L[ğ•œ] G)) :\n    f.uncurryRight.curryRight = f := by\n  ext m x\n  rw [ContinuousMultilinearMap.curryRight_apply, ContinuousMultilinearMap.uncurryRight_apply,\n    snoc_last, init_snoc]\n\n"}
{"name":"ContinuousMultilinearMap.uncurry_curryRight","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nEi : Fin n.succ â†’ Type wEi\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Fin n.succ) â†’ NormedAddCommGroup (Ei i)\ninstâœÂ² : (i : Fin n.succ) â†’ NormedSpace ğ•œ (Ei i)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousMultilinearMap ğ•œ Ei G\nâŠ¢ Eq f.curryRight.uncurryRight f","decl":"@[simp]\ntheorem ContinuousMultilinearMap.uncurry_curryRight (f : ContinuousMultilinearMap ğ•œ Ei G) :\n    f.curryRight.uncurryRight = f := by\n  ext m\n  rw [uncurryRight_apply, curryRight_apply, snoc_init_self]\n\n"}
{"name":"continuousMultilinearCurryRightEquiv_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nEi : Fin n.succ â†’ Type wEi\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Fin n.succ) â†’ NormedAddCommGroup (Ei i)\ninstâœÂ² : (i : Fin n.succ) â†’ NormedSpace ğ•œ (Ei i)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousMultilinearMap ğ•œ Ei G\nv : (i : Fin n) â†’ Ei i.castSucc\nx : Ei (Fin.last n)\nâŠ¢ Eq ((((continuousMultilinearCurryRightEquiv ğ•œ Ei G) f) v) x) (f (Fin.snoc v x))","decl":"@[simp]\ntheorem continuousMultilinearCurryRightEquiv_apply\n    (f : ContinuousMultilinearMap ğ•œ Ei G) (v : Î  i : Fin n, Ei <| castSucc i) (x : Ei (last n)) :\n    continuousMultilinearCurryRightEquiv ğ•œ Ei G f v x = f (snoc v x) :=\n  rfl\n\n"}
{"name":"continuousMultilinearCurryRightEquiv_symm_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nEi : Fin n.succ â†’ Type wEi\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Fin n.succ) â†’ NormedAddCommGroup (Ei i)\ninstâœÂ² : (i : Fin n.succ) â†’ NormedSpace ğ•œ (Ei i)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousMultilinearMap ğ•œ (fun i => Ei i.castSucc) (ContinuousLinearMap (RingHom.id ğ•œ) (Ei (Fin.last n)) G)\nv : (i : Fin n.succ) â†’ Ei i\nâŠ¢ Eq (((continuousMultilinearCurryRightEquiv ğ•œ Ei G).symm f) v) ((f (Fin.init v)) (v (Fin.last n)))","decl":"@[simp]\ntheorem continuousMultilinearCurryRightEquiv_symm_apply\n    (f : ContinuousMultilinearMap ğ•œ (fun i : Fin n => Ei <| castSucc i) (Ei (last n) â†’L[ğ•œ] G))\n    (v : Î  i, Ei i) :\n    (continuousMultilinearCurryRightEquiv ğ•œ Ei G).symm f v = f (init v) (v (last n)) :=\n  rfl\n\n"}
{"name":"continuousMultilinearCurryRightEquiv_apply'","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nG : Type wG\nG' : Type wG'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nf : ContinuousMultilinearMap ğ•œ (fun i => G) G'\nv : Fin n â†’ G\nx : G\nâŠ¢ Eq ((((continuousMultilinearCurryRightEquiv' ğ•œ n G G') f) v) x) (f (Fin.snoc v x))","decl":"@[simp]\ntheorem continuousMultilinearCurryRightEquiv_apply'\n    (f : G[Ã—n.succ]â†’L[ğ•œ] G') (v : Fin n â†’ G) (x : G) :\n    continuousMultilinearCurryRightEquiv' ğ•œ n G G' f v x = f (snoc v x) :=\n  rfl\n\n"}
{"name":"continuousMultilinearCurryRightEquiv_symm_apply'","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nG : Type wG\nG' : Type wG'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nf : ContinuousMultilinearMap ğ•œ (fun i => G) (ContinuousLinearMap (RingHom.id ğ•œ) G G')\nv : Fin (HAdd.hAdd n 1) â†’ G\nâŠ¢ Eq (((continuousMultilinearCurryRightEquiv' ğ•œ n G G').symm f) v) ((f (Fin.init v)) (v (Fin.last n)))","decl":"@[simp]\ntheorem continuousMultilinearCurryRightEquiv_symm_apply'\n    (f : G[Ã—n]â†’L[ğ•œ] G â†’L[ğ•œ] G') (v : Fin (n + 1) â†’ G) :\n    (continuousMultilinearCurryRightEquiv' ğ•œ n G G').symm f v = f (init v) (v (last n)) :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.curryRight_norm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nEi : Fin n.succ â†’ Type wEi\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Fin n.succ) â†’ NormedAddCommGroup (Ei i)\ninstâœÂ² : (i : Fin n.succ) â†’ NormedSpace ğ•œ (Ei i)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousMultilinearMap ğ•œ Ei G\nâŠ¢ Eq (Norm.norm f.curryRight) (Norm.norm f)","decl":"@[simp]\ntheorem ContinuousMultilinearMap.curryRight_norm (f : ContinuousMultilinearMap ğ•œ Ei G) :\n    â€–f.curryRightâ€– = â€–fâ€– :=\n  (continuousMultilinearCurryRightEquiv ğ•œ Ei G).norm_map f\n\n"}
{"name":"ContinuousMultilinearMap.uncurryRight_norm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nEi : Fin n.succ â†’ Type wEi\nG : Type wG\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : (i : Fin n.succ) â†’ NormedAddCommGroup (Ei i)\ninstâœÂ² : (i : Fin n.succ) â†’ NormedSpace ğ•œ (Ei i)\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : ContinuousMultilinearMap ğ•œ (fun i => Ei i.castSucc) (ContinuousLinearMap (RingHom.id ğ•œ) (Ei (Fin.last n)) G)\nâŠ¢ Eq (Norm.norm f.uncurryRight) (Norm.norm f)","decl":"@[simp]\ntheorem ContinuousMultilinearMap.uncurryRight_norm\n    (f : ContinuousMultilinearMap ğ•œ (fun i : Fin n => Ei <| castSucc i) (Ei (last n) â†’L[ğ•œ] G)) :\n    â€–f.uncurryRightâ€– = â€–fâ€– :=\n  (continuousMultilinearCurryRightEquiv ğ•œ Ei G).symm.norm_map f\n\n"}
{"name":"ContinuousMultilinearMap.uncurry0_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nG : Type wG\nG' : Type wG'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nx : G'\nm : Fin 0 â†’ G\nâŠ¢ Eq ((ContinuousMultilinearMap.uncurry0 ğ•œ G x) m) x","decl":"variable (ğ•œ) in\n@[simp]\ntheorem ContinuousMultilinearMap.uncurry0_apply (x : G') (m : Fin 0 â†’ G) :\n    ContinuousMultilinearMap.uncurry0 ğ•œ G x m = x :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.curry0_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nG : Type wG\nG' : Type wG'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nf : ContinuousMultilinearMap ğ•œ (fun i => G) G'\nâŠ¢ Eq f.curry0 (f 0)","decl":"@[simp]\ntheorem ContinuousMultilinearMap.curry0_apply (f : G[Ã—0]â†’L[ğ•œ] G') : f.curry0 = f 0 :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.apply_zero_uncurry0","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nG : Type wG\nG' : Type wG'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nf : ContinuousMultilinearMap ğ•œ (fun i => G) G'\nx : Fin 0 â†’ G\nâŠ¢ Eq (ContinuousMultilinearMap.uncurry0 ğ•œ G (f x)) f","decl":"@[simp]\ntheorem ContinuousMultilinearMap.apply_zero_uncurry0 (f : G[Ã—0]â†’L[ğ•œ] G') {x : Fin 0 â†’ G} :\n    ContinuousMultilinearMap.uncurry0 ğ•œ G (f x) = f := by\n  ext m\n  simp [Subsingleton.elim x m]\n\n"}
{"name":"ContinuousMultilinearMap.uncurry0_curry0","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nG : Type wG\nG' : Type wG'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nf : ContinuousMultilinearMap ğ•œ (fun i => G) G'\nâŠ¢ Eq (ContinuousMultilinearMap.uncurry0 ğ•œ G f.curry0) f","decl":"theorem ContinuousMultilinearMap.uncurry0_curry0 (f : G[Ã—0]â†’L[ğ•œ] G') :\n    ContinuousMultilinearMap.uncurry0 ğ•œ G f.curry0 = f := by simp\n\n"}
{"name":"ContinuousMultilinearMap.curry0_uncurry0","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nG : Type wG\nG' : Type wG'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nx : G'\nâŠ¢ Eq (ContinuousMultilinearMap.uncurry0 ğ•œ G x).curry0 x","decl":"variable (ğ•œ G) in\ntheorem ContinuousMultilinearMap.curry0_uncurry0 (x : G') :\n    (ContinuousMultilinearMap.uncurry0 ğ•œ G x).curry0 = x :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.uncurry0_norm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nG : Type wG\nG' : Type wG'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nx : G'\nâŠ¢ Eq (Norm.norm (ContinuousMultilinearMap.uncurry0 ğ•œ G x)) (Norm.norm x)","decl":"variable (ğ•œ G) in\n@[simp]\ntheorem ContinuousMultilinearMap.uncurry0_norm (x : G') :\n    â€–ContinuousMultilinearMap.uncurry0 ğ•œ G xâ€– = â€–xâ€– :=\n  norm_constOfIsEmpty _ _ _\n\n"}
{"name":"ContinuousMultilinearMap.fin0_apply_norm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nG : Type wG\nG' : Type wG'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nf : ContinuousMultilinearMap ğ•œ (fun i => G) G'\nx : Fin 0 â†’ G\nâŠ¢ Eq (Norm.norm (f x)) (Norm.norm f)","decl":"@[simp]\ntheorem ContinuousMultilinearMap.fin0_apply_norm (f : G[Ã—0]â†’L[ğ•œ] G') {x : Fin 0 â†’ G} :\n    â€–f xâ€– = â€–fâ€– := by\n  obtain rfl : x = 0 := Subsingleton.elim _ _\n  refine le_antisymm (by simpa using f.le_opNorm 0) ?_\n  have : â€–ContinuousMultilinearMap.uncurry0 ğ•œ G f.curry0â€– â‰¤ â€–f.curry0â€– :=\n    ContinuousMultilinearMap.opNorm_le_bound (norm_nonneg _) fun m => by\n      simp [-ContinuousMultilinearMap.apply_zero_uncurry0]\n  simpa [-Matrix.zero_empty] using this\n\n"}
{"name":"ContinuousMultilinearMap.curry0_norm","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nG : Type wG\nG' : Type wG'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nf : ContinuousMultilinearMap ğ•œ (fun i => G) G'\nâŠ¢ Eq (Norm.norm f.curry0) (Norm.norm f)","decl":"theorem ContinuousMultilinearMap.curry0_norm (f : G[Ã—0]â†’L[ğ•œ] G') : â€–f.curry0â€– = â€–fâ€– := by simp\n\n"}
{"name":"continuousMultilinearCurryFin0_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nG : Type wG\nG' : Type wG'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nf : ContinuousMultilinearMap ğ•œ (fun i => G) G'\nâŠ¢ Eq ((continuousMultilinearCurryFin0 ğ•œ G G') f) (f 0)","decl":"@[simp]\ntheorem continuousMultilinearCurryFin0_apply (f : G[Ã—0]â†’L[ğ•œ] G') :\n    continuousMultilinearCurryFin0 ğ•œ G G' f = f 0 :=\n  rfl\n\n"}
{"name":"continuousMultilinearCurryFin0_symm_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nG : Type wG\nG' : Type wG'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nx : G'\nv : Fin 0 â†’ G\nâŠ¢ Eq (((continuousMultilinearCurryFin0 ğ•œ G G').symm x) v) x","decl":"@[simp]\ntheorem continuousMultilinearCurryFin0_symm_apply (x : G') (v : Fin 0 â†’ G) :\n    (continuousMultilinearCurryFin0 ğ•œ G G').symm x v = x :=\n  rfl\n\n"}
{"name":"continuousMultilinearCurryFin1_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nG : Type wG\nG' : Type wG'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nf : ContinuousMultilinearMap ğ•œ (fun i => G) G'\nx : G\nâŠ¢ Eq (((continuousMultilinearCurryFin1 ğ•œ G G') f) x) (f (Fin.snoc 0 x))","decl":"@[simp]\ntheorem continuousMultilinearCurryFin1_apply (f : G[Ã—1]â†’L[ğ•œ] G') (x : G) :\n    continuousMultilinearCurryFin1 ğ•œ G G' f x = f (Fin.snoc 0 x) :=\n  rfl\n\n"}
{"name":"continuousMultilinearCurryFin1_symm_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nG : Type wG\nG' : Type wG'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nf : ContinuousLinearMap (RingHom.id ğ•œ) G G'\nv : Fin 1 â†’ G\nâŠ¢ Eq (((continuousMultilinearCurryFin1 ğ•œ G G').symm f) v) (f (v 0))","decl":"@[simp]\ntheorem continuousMultilinearCurryFin1_symm_apply (f : G â†’L[ğ•œ] G') (v : Fin 1 â†’ G) :\n    (continuousMultilinearCurryFin1 ğ•œ G G').symm f v = f (v 0) :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.norm_domDomCongr","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nÎ¹' : Type v'\nG : Type wG\nG' : Type wG'\ninstâœâ¶ : Fintype Î¹\ninstâœâµ : Fintype Î¹'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nÏƒ : Equiv Î¹ Î¹'\nf : ContinuousMultilinearMap ğ•œ (fun x => G) G'\nâŠ¢ Eq (Norm.norm (ContinuousMultilinearMap.domDomCongr Ïƒ f)) (Norm.norm f)","decl":"@[simp]\ntheorem norm_domDomCongr (Ïƒ : Î¹ â‰ƒ Î¹') (f : ContinuousMultilinearMap ğ•œ (fun _ : Î¹ => G) G') :\n    â€–domDomCongr Ïƒ fâ€– = â€–fâ€– := by\n  simp only [norm_def, LinearEquiv.coe_mk, â† Ïƒ.prod_comp,\n    (Ïƒ.arrowCongr (Equiv.refl G)).surjective.forall, domDomCongr_apply, Equiv.arrowCongr_apply,\n    Equiv.coe_refl, id_comp, comp_apply, Equiv.symm_apply_apply, id]\n\n"}
{"name":"ContinuousMultilinearMap.currySum_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nÎ¹' : Type v'\nG : Type wG\nG' : Type wG'\ninstâœâ¶ : Fintype Î¹\ninstâœâµ : Fintype Î¹'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nf : ContinuousMultilinearMap ğ•œ (fun x => G) G'\nm : Î¹ â†’ G\nm' : Î¹' â†’ G\nâŠ¢ Eq ((f.currySum m) m') (f (Sum.elim m m'))","decl":"@[simp]\ntheorem currySum_apply (f : ContinuousMultilinearMap ğ•œ (fun _ : Î¹ âŠ• Î¹' => G) G') (m : Î¹ â†’ G)\n    (m' : Î¹' â†’ G) : f.currySum m m' = f (Sum.elim m m') :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.uncurrySum_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nÎ¹' : Type v'\nG : Type wG\nG' : Type wG'\ninstâœâ¶ : Fintype Î¹\ninstâœâµ : Fintype Î¹'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nf : ContinuousMultilinearMap ğ•œ (fun x => G) (ContinuousMultilinearMap ğ•œ (fun x => G) G')\nm : Sum Î¹ Î¹' â†’ G\nâŠ¢ Eq (f.uncurrySum m) ((f (Function.comp m Sum.inl)) (Function.comp m Sum.inr))","decl":"@[simp]\ntheorem uncurrySum_apply (f : ContinuousMultilinearMap ğ•œ (fun _ : Î¹ => G)\n    (ContinuousMultilinearMap ğ•œ (fun _ : Î¹' => G) G'))\n    (m : Î¹ âŠ• Î¹' â†’ G) : f.uncurrySum m = f (m âˆ˜ Sum.inl) (m âˆ˜ Sum.inr) :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.curryFinFinset_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nG : Type wG\nG' : Type wG'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nk l : Nat\ns : Finset (Fin n)\nhk : Eq s.card k\nhl : Eq (HasCompl.compl s).card l\nf : ContinuousMultilinearMap ğ•œ (fun i => G) G'\nmk : Fin k â†’ G\nml : Fin l â†’ G\nâŠ¢ Eq ((((ContinuousMultilinearMap.curryFinFinset ğ•œ G G' hk hl) f) mk) ml) (f fun i => Sum.elim mk ml ((finSumEquivOfFinset hk hl).symm i))","decl":"@[simp]\ntheorem curryFinFinset_apply (hk : #s = k) (hl : #sá¶œ = l) (f : G[Ã—n]â†’L[ğ•œ] G')\n    (mk : Fin k â†’ G) (ml : Fin l â†’ G) : curryFinFinset ğ•œ G G' hk hl f mk ml =\n      f fun i => Sum.elim mk ml ((finSumEquivOfFinset hk hl).symm i) :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.curryFinFinset_symm_apply","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nG : Type wG\nG' : Type wG'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nk l : Nat\ns : Finset (Fin n)\nhk : Eq s.card k\nhl : Eq (HasCompl.compl s).card l\nf : ContinuousMultilinearMap ğ•œ (fun i => G) (ContinuousMultilinearMap ğ•œ (fun i => G) G')\nm : Fin n â†’ G\nâŠ¢ Eq (((ContinuousMultilinearMap.curryFinFinset ğ•œ G G' hk hl).symm f) m) ((f fun i => m ((finSumEquivOfFinset hk hl) (Sum.inl i))) fun i => m ((finSumEquivOfFinset hk hl) (Sum.inr i)))","decl":"@[simp]\ntheorem curryFinFinset_symm_apply (hk : #s = k) (hl : #sá¶œ = l)\n    (f : G[Ã—k]â†’L[ğ•œ] G[Ã—l]â†’L[ğ•œ] G') (m : Fin n â†’ G) : (curryFinFinset ğ•œ G G' hk hl).symm f m =\n      f (fun i => m <| finSumEquivOfFinset hk hl (Sum.inl i)) fun i =>\n        m <| finSumEquivOfFinset hk hl (Sum.inr i) :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.curryFinFinset_symm_apply_piecewise_const","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nG : Type wG\nG' : Type wG'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nk l : Nat\ns : Finset (Fin n)\nhk : Eq s.card k\nhl : Eq (HasCompl.compl s).card l\nf : ContinuousMultilinearMap ğ•œ (fun i => G) (ContinuousMultilinearMap ğ•œ (fun i => G) G')\nx y : G\nâŠ¢ Eq (((ContinuousMultilinearMap.curryFinFinset ğ•œ G G' hk hl).symm f) (s.piecewise (fun x_1 => x) fun x => y)) ((f fun x_1 => x) fun x => y)","decl":"theorem curryFinFinset_symm_apply_piecewise_const (hk : #s = k) (hl : #sá¶œ = l)\n    (f : G[Ã—k]â†’L[ğ•œ] G[Ã—l]â†’L[ğ•œ] G') (x y : G) :\n    (curryFinFinset ğ•œ G G' hk hl).symm f (s.piecewise (fun _ => x) fun _ => y) =\n      f (fun _ => x) fun _ => y :=\n  MultilinearMap.curryFinFinset_symm_apply_piecewise_const hk hl _ x y\n\n"}
{"name":"ContinuousMultilinearMap.curryFinFinset_symm_apply_const","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nG : Type wG\nG' : Type wG'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nk l : Nat\ns : Finset (Fin n)\nhk : Eq s.card k\nhl : Eq (HasCompl.compl s).card l\nf : ContinuousMultilinearMap ğ•œ (fun i => G) (ContinuousMultilinearMap ğ•œ (fun i => G) G')\nx : G\nâŠ¢ Eq (((ContinuousMultilinearMap.curryFinFinset ğ•œ G G' hk hl).symm f) fun x_1 => x) ((f fun x_1 => x) fun x_1 => x)","decl":"@[simp]\ntheorem curryFinFinset_symm_apply_const (hk : #s = k) (hl : #sá¶œ = l)\n    (f : G[Ã—k]â†’L[ğ•œ] G[Ã—l]â†’L[ğ•œ] G') (x : G) :\n    ((curryFinFinset ğ•œ G G' hk hl).symm f fun _ => x) = f (fun _ => x) fun _ => x :=\n  rfl\n\n"}
{"name":"ContinuousMultilinearMap.curryFinFinset_apply_const","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nn : Nat\nG : Type wG\nG' : Type wG'\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : NormedAddCommGroup G'\ninstâœ : NormedSpace ğ•œ G'\nk l : Nat\ns : Finset (Fin n)\nhk : Eq s.card k\nhl : Eq (HasCompl.compl s).card l\nf : ContinuousMultilinearMap ğ•œ (fun i => G) G'\nx y : G\nâŠ¢ Eq ((((ContinuousMultilinearMap.curryFinFinset ğ•œ G G' hk hl) f) fun x_1 => x) fun x => y) (f (s.piecewise (fun x_1 => x) fun x => y))","decl":"theorem curryFinFinset_apply_const (hk : #s = k) (hl : #sá¶œ = l) (f : G[Ã—n]â†’L[ğ•œ] G')\n    (x y : G) : (curryFinFinset ğ•œ G G' hk hl f (fun _ => x) fun _ => y) =\n      f (s.piecewise (fun _ => x) fun _ => y) := by\n  refine (curryFinFinset_symm_apply_piecewise_const hk hl _ _ _).symm.trans ?_\n  rw [LinearIsometryEquiv.symm_apply_apply]\n\n"}
{"name":"ContinuousLinearMap.continuousMultilinearMapOption_apply_eq_self","module":"Mathlib.Analysis.NormedSpace.Multilinear.Curry","initialProofState":"ğ•œ : Type u\nÎ¹ : Type v\nE : Î¹ â†’ Type wE\ninstâœâ· : Fintype Î¹\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : (i : Î¹) â†’ NormedAddCommGroup (E i)\ninstâœâ´ : (i : Î¹) â†’ NormedSpace ğ•œ (E i)\nF : Type u_1\nG : Type u_2\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nB : ContinuousLinearMap (RingHom.id ğ•œ) G (ContinuousMultilinearMap ğ•œ E F)\na : G\nv : (i : Î¹) â†’ E i\nâŠ¢ Eq (B.continuousMultilinearMapOption fun x => { fst := a, snd := v }) ((B a) v)","decl":"lemma continuousMultilinearMapOption_apply_eq_self (B : G â†’L[ğ•œ] ContinuousMultilinearMap ğ•œ E F)\n    (a : G) (v : Î  i, E i) : B.continuousMultilinearMapOption (fun _ â†¦ (a, v)) = B a v := rfl\n\n"}
