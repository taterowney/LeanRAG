{"name":"CategoryTheory.Functor.OfSequence.congr_f","module":"Mathlib.CategoryTheory.Functor.OfSequence","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : Nat ‚Üí C\nf : (n : Nat) ‚Üí Quiver.Hom (X n) (X (HAdd.hAdd n 1))\ni j : Nat\nh : Eq i j\n‚ä¢ Eq (f i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (f j) (CategoryTheory.eqToHom ‚ãØ)))","decl":"lemma congr_f (i j : ‚Ñï) (h : i = j) :\n    f i = eqToHom (by rw [h]) ‚â´ f j ‚â´ eqToHom (by rw [h]) := by\n  subst h\n  simp\n\n"}
{"name":"CategoryTheory.Functor.OfSequence.map_id","module":"Mathlib.CategoryTheory.Functor.OfSequence","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : Nat ‚Üí C\nf : (n : Nat) ‚Üí Quiver.Hom (X n) (X (HAdd.hAdd n 1))\ni : Nat\n‚ä¢ Eq (CategoryTheory.Functor.OfSequence.map f i i ‚ãØ) (CategoryTheory.CategoryStruct.id (X i))","decl":"lemma map_id (i : ‚Ñï) : map f i i (by omega) = ùüô _ := by\n  revert X f\n  induction i with\n  | zero => intros; rfl\n  | succ _ hi =>\n      intro X f\n      apply hi\n\n"}
{"name":"CategoryTheory.Functor.OfSequence.map_le_succ","module":"Mathlib.CategoryTheory.Functor.OfSequence","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : Nat ‚Üí C\nf : (n : Nat) ‚Üí Quiver.Hom (X n) (X (HAdd.hAdd n 1))\ni : Nat\n‚ä¢ Eq (CategoryTheory.Functor.OfSequence.map f i (HAdd.hAdd i 1) ‚ãØ) (f i)","decl":"lemma map_le_succ (i : ‚Ñï) : map f i (i + 1) (by omega) = f i := by\n  revert X f\n  induction i with\n  | zero => intros; rfl\n  | succ _ hi =>\n      intro X f\n      apply hi\n\n"}
{"name":"CategoryTheory.Functor.OfSequence.map_comp_assoc","module":"Mathlib.CategoryTheory.Functor.OfSequence","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : Nat ‚Üí C\nf : (n : Nat) ‚Üí Quiver.Hom (X n) (X (HAdd.hAdd n 1))\ni j k : Nat\nhij : LE.le i j\nhjk : LE.le j k\nZ : C\nh : Quiver.Hom (X k) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OfSequence.map f i k ‚ãØ) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OfSequence.map f i j hij) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OfSequence.map f j k hjk) h))","decl":"@[reassoc]\nlemma map_comp (i j k : ‚Ñï) (hij : i ‚â§ j) (hjk : j ‚â§ k) :\n    map f i k (hij.trans hjk) = map f i j hij ‚â´ map f j k hjk := by\n  revert X f j k\n  induction i with\n  | zero =>\n      intros X f j\n      revert X f\n      induction j with\n      | zero =>\n          intros X f k hij hjk\n          rw [map_id, id_comp]\n      | succ j hj =>\n          rintro X f (_|_|k) hij hjk\n          ¬∑ omega\n          ¬∑ obtain rfl : j = 0 := by omega\n            rw [map_id, comp_id]\n          ¬∑ simp only [map, Nat.reduceAdd]\n            rw [hj (fun n ‚Ü¶ f (n + 1)) (k + 1) (by omega) (by omega)]\n            obtain _|j := j\n            all_goals simp [map]\n  | succ i hi =>\n      rintro X f (_|j) (_|k)\n      ¬∑ omega\n      ¬∑ omega\n      ¬∑ omega\n      ¬∑ intros\n        exact hi _ j k (by omega) (by omega)\n\n-- `map` has good definitional properties when applied to explicit natural numbers\n"}
{"name":"CategoryTheory.Functor.OfSequence.map_comp","module":"Mathlib.CategoryTheory.Functor.OfSequence","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : Nat ‚Üí C\nf : (n : Nat) ‚Üí Quiver.Hom (X n) (X (HAdd.hAdd n 1))\ni j k : Nat\nhij : LE.le i j\nhjk : LE.le j k\n‚ä¢ Eq (CategoryTheory.Functor.OfSequence.map f i k ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functor.OfSequence.map f i j hij) (CategoryTheory.Functor.OfSequence.map f j k hjk))","decl":"@[reassoc]\nlemma map_comp (i j k : ‚Ñï) (hij : i ‚â§ j) (hjk : j ‚â§ k) :\n    map f i k (hij.trans hjk) = map f i j hij ‚â´ map f j k hjk := by\n  revert X f j k\n  induction i with\n  | zero =>\n      intros X f j\n      revert X f\n      induction j with\n      | zero =>\n          intros X f k hij hjk\n          rw [map_id, id_comp]\n      | succ j hj =>\n          rintro X f (_|_|k) hij hjk\n          ¬∑ omega\n          ¬∑ obtain rfl : j = 0 := by omega\n            rw [map_id, comp_id]\n          ¬∑ simp only [map, Nat.reduceAdd]\n            rw [hj (fun n ‚Ü¶ f (n + 1)) (k + 1) (by omega) (by omega)]\n            obtain _|j := j\n            all_goals simp [map]\n  | succ i hi =>\n      rintro X f (_|j) (_|k)\n      ¬∑ omega\n      ¬∑ omega\n      ¬∑ omega\n      ¬∑ intros\n        exact hi _ j k (by omega) (by omega)\n\n-- `map` has good definitional properties when applied to explicit natural numbers\n"}
{"name":"CategoryTheory.Functor.ofSequence_obj","module":"Mathlib.CategoryTheory.Functor.OfSequence","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : Nat ‚Üí C\nf : (n : Nat) ‚Üí Quiver.Hom (X n) (X (HAdd.hAdd n 1))\na‚úù : Nat\n‚ä¢ Eq ((CategoryTheory.Functor.ofSequence f).obj a‚úù) (X a‚úù)","decl":"/-- The functor `‚Ñï ‚•§ C` constructed from a sequence of\nmorphisms `f : X n ‚ü∂ X (n + 1)` for all `n : ‚Ñï`. -/\n@[simps obj]\ndef ofSequence : ‚Ñï ‚•§ C where\n  obj := X\n  map {i j} œÜ := OfSequence.map f i j (leOfHom œÜ)\n  map_id i := OfSequence.map_id f i\n  map_comp {i j k} Œ± Œ≤ := OfSequence.map_comp f i j k (leOfHom Œ±) (leOfHom Œ≤)\n\n"}
{"name":"CategoryTheory.Functor.ofSequence_map_homOfLE_succ","module":"Mathlib.CategoryTheory.Functor.OfSequence","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : Nat ‚Üí C\nf : (n : Nat) ‚Üí Quiver.Hom (X n) (X (HAdd.hAdd n 1))\nn : Nat\n‚ä¢ Eq ((CategoryTheory.Functor.ofSequence f).map (CategoryTheory.homOfLE ‚ãØ)) (f n)","decl":"@[simp]\nlemma ofSequence_map_homOfLE_succ (n : ‚Ñï) :\n    (ofSequence f).map (homOfLE (Nat.le_add_right n 1)) = f n :=\n  OfSequence.map_le_succ f n\n\n"}
{"name":"CategoryTheory.NatTrans.ofSequence_app","module":"Mathlib.CategoryTheory.Functor.OfSequence","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nF G : CategoryTheory.Functor Nat C\napp : (n : Nat) ‚Üí Quiver.Hom (F.obj n) (G.obj n)\nn : Nat\n‚ä¢ Eq ((CategoryTheory.NatTrans.ofSequence app).app n) (app n)","decl":"/-- Constructor for natural transformations `F ‚ü∂ G` in `‚Ñï ‚•§ C` which takes as inputs\nthe morphisms `F.obj n ‚ü∂ G.obj n` for all `n : ‚Ñï` and the naturality condition only\nfor morphisms of the form `n ‚ü∂ n + 1`. -/\n@[simps app]\ndef ofSequence : F ‚ü∂ G where\n  app := app\n  naturality := by\n    intro i j œÜ\n    obtain ‚ü®k, hk‚ü© := Nat.exists_eq_add_of_le (leOfHom œÜ)\n    obtain rfl := Subsingleton.elim œÜ (homOfLE (by omega))\n    revert i j\n    induction k with\n    | zero =>\n        intro i j hk\n        obtain rfl : j = i := by omega\n        simp\n    | succ k hk =>\n        intro i j hk'\n        obtain rfl : j = i + k + 1 := by omega\n        simp only [‚Üê homOfLE_comp (show i ‚â§ i + k by omega) (show i + k ‚â§ i + k + 1 by omega),\n          Functor.map_comp, assoc, naturality, reassoc_of% (hk rfl)]\n\n"}
{"name":"CategoryTheory.Functor.ofOpSequence_obj","module":"Mathlib.CategoryTheory.Functor.OfSequence","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX‚úù : Nat ‚Üí C\nf : (n : Nat) ‚Üí Quiver.Hom (X‚úù (HAdd.hAdd n 1)) (X‚úù n)\nX : Opposite Nat\n‚ä¢ Eq ((CategoryTheory.Functor.ofOpSequence f).obj X) (X‚úù (Opposite.unop X))","decl":"/-- The functor `‚Ñï·µí·µñ ‚•§ C` constructed from a sequence of\nmorphisms `f : X (n + 1) ‚ü∂ X n` for all `n : ‚Ñï`. -/\n@[simps! obj]\ndef ofOpSequence : ‚Ñï·µí·µñ ‚•§ C := (ofSequence (fun n ‚Ü¶ (f n).op)).leftOp\n\n-- `ofOpSequence` has good definitional properties when applied to explicit natural numbers\n"}
{"name":"CategoryTheory.Functor.ofOpSequence_map_homOfLE_succ","module":"Mathlib.CategoryTheory.Functor.OfSequence","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : Nat ‚Üí C\nf : (n : Nat) ‚Üí Quiver.Hom (X (HAdd.hAdd n 1)) (X n)\nn : Nat\n‚ä¢ Eq ((CategoryTheory.Functor.ofOpSequence f).map (CategoryTheory.homOfLE ‚ãØ).op) (f n)","decl":"@[simp]\nlemma ofOpSequence_map_homOfLE_succ (n : ‚Ñï) :\n    (ofOpSequence f).map (homOfLE (Nat.le_add_right n 1)).op = f n := by\n  simp [ofOpSequence]\n\n"}
{"name":"CategoryTheory.NatTrans.ofOpSequence_app","module":"Mathlib.CategoryTheory.Functor.OfSequence","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nF G : CategoryTheory.Functor (Opposite Nat) C\napp : (n : Nat) ‚Üí Quiver.Hom (F.obj { unop := n }) (G.obj { unop := n })\nn : Opposite Nat\n‚ä¢ Eq ((CategoryTheory.NatTrans.ofOpSequence app).app n) (app (Opposite.unop n))","decl":"/-- Constructor for natural transformations `F ‚ü∂ G` in `‚Ñï·µí·µñ ‚•§ C` which takes as inputs\nthe morphisms `F.obj ‚ü®n‚ü© ‚ü∂ G.obj ‚ü®n‚ü©` for all `n : ‚Ñï` and the naturality condition only\nfor morphisms of the form `n ‚ü∂ n + 1`. -/\n@[simps!]\ndef ofOpSequence : F ‚ü∂ G where\n  app n := app n.unop\n  naturality _ _ f := by\n    let œÜ : G.rightOp ‚ü∂ F.rightOp := ofSequence (fun n ‚Ü¶ (app n).op)\n      (fun n ‚Ü¶ Quiver.Hom.unop_inj (naturality n).symm)\n    exact Quiver.Hom.op_inj (œÜ.naturality f.unop).symm\n\n"}
