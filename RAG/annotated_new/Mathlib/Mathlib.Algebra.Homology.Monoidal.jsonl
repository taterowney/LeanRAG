{"name":"HomologicalComplex.instHasTensorOfHasTensorX","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst‚úù‚Å∑ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù‚Å∂ : CategoryTheory.MonoidalCategory C\ninst‚úù‚Åµ : CategoryTheory.Preadditive C\ninst‚úù‚Å¥ : (CategoryTheory.MonoidalCategory.curriedTensor C).Additive\ninst‚úù¬≥ : ‚àÄ (X‚ÇÅ : C), ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X‚ÇÅ).Additive\nI : Type u_2\ninst‚úù¬≤ : AddMonoid I\nc : ComplexShape I\ninst‚úù¬π : c.TensorSigns\nK‚ÇÅ K‚ÇÇ : HomologicalComplex C c\ninst‚úù : CategoryTheory.GradedObject.HasTensor K‚ÇÅ.X K‚ÇÇ.X\n‚ä¢ K‚ÇÅ.HasTensor K‚ÇÇ","decl":"instance (K‚ÇÅ K‚ÇÇ : HomologicalComplex C c) [GradedObject.HasTensor K‚ÇÅ.X K‚ÇÇ.X] :\n    HasTensor K‚ÇÅ K‚ÇÇ := by\n  assumption\n\n"}
{"name":"HomologicalComplex.instHasGoodTensor‚ÇÅ‚ÇÇOfHasGoodTensor‚ÇÅ‚ÇÇTensorX","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nI : Type u_2\ninst‚úù¬≤ : AddMonoid I\nc : ComplexShape I\ninst‚úù¬π : c.TensorSigns\nK‚ÇÅ K‚ÇÇ K‚ÇÉ : HomologicalComplex C c\ninst‚úù : CategoryTheory.GradedObject.HasGoodTensor‚ÇÅ‚ÇÇTensor K‚ÇÅ.X K‚ÇÇ.X K‚ÇÉ.X\n‚ä¢ K‚ÇÅ.HasGoodTensor‚ÇÅ‚ÇÇ K‚ÇÇ K‚ÇÉ","decl":"instance (K‚ÇÅ K‚ÇÇ K‚ÇÉ : HomologicalComplex C c)\n    [GradedObject.HasGoodTensor‚ÇÅ‚ÇÇTensor K‚ÇÅ.X K‚ÇÇ.X K‚ÇÉ.X] :\n    HasGoodTensor‚ÇÅ‚ÇÇ K‚ÇÅ K‚ÇÇ K‚ÇÉ :=\n  inferInstanceAs (GradedObject.HasGoodTensor‚ÇÅ‚ÇÇTensor K‚ÇÅ.X K‚ÇÇ.X K‚ÇÉ.X)\n\n"}
{"name":"HomologicalComplex.instHasGoodTensor‚ÇÇ‚ÇÉOfHasGoodTensorTensor‚ÇÇ‚ÇÉX","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù‚Å¥ : CategoryTheory.MonoidalCategory C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nI : Type u_2\ninst‚úù¬≤ : AddMonoid I\nc : ComplexShape I\ninst‚úù¬π : c.TensorSigns\nK‚ÇÅ K‚ÇÇ K‚ÇÉ : HomologicalComplex C c\ninst‚úù : CategoryTheory.GradedObject.HasGoodTensorTensor‚ÇÇ‚ÇÉ K‚ÇÅ.X K‚ÇÇ.X K‚ÇÉ.X\n‚ä¢ K‚ÇÅ.HasGoodTensor‚ÇÇ‚ÇÉ K‚ÇÇ K‚ÇÉ","decl":"instance (K‚ÇÅ K‚ÇÇ K‚ÇÉ : HomologicalComplex C c)\n    [GradedObject.HasGoodTensorTensor‚ÇÇ‚ÇÉ K‚ÇÅ.X K‚ÇÇ.X K‚ÇÉ.X] :\n    HasGoodTensor‚ÇÇ‚ÇÉ K‚ÇÅ K‚ÇÇ K‚ÇÉ :=\n  inferInstanceAs (GradedObject.HasGoodTensorTensor‚ÇÇ‚ÇÉ K‚ÇÅ.X K‚ÇÇ.X K‚ÇÉ.X)\n\n"}
{"name":"HomologicalComplex.instHasTensorXTensorUnit","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù‚Åµ : CategoryTheory.MonoidalCategory C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroObject C\nI : Type u_2\ninst‚úù¬≤ : AddMonoid I\nc : ComplexShape I\nK : HomologicalComplex C c\ninst‚úù¬π : DecidableEq I\ninst‚úù : ‚àÄ (X‚ÇÇ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).flip.obj X‚ÇÇ)\n‚ä¢ CategoryTheory.GradedObject.HasTensor (HomologicalComplex.tensorUnit C c).X K.X","decl":"instance : GradedObject.HasTensor (tensorUnit C c).X K.X :=\n  GradedObject.hasTensor_of_iso (tensorUnitIso C c) (Iso.refl _)\n\n"}
{"name":"HomologicalComplex.instHasTensorTensorUnit","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst‚úù‚Åπ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù‚Å∏ : CategoryTheory.MonoidalCategory C\ninst‚úù‚Å∑ : CategoryTheory.Preadditive C\ninst‚úù‚Å∂ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù‚Åµ : (CategoryTheory.MonoidalCategory.curriedTensor C).Additive\ninst‚úù‚Å¥ : ‚àÄ (X‚ÇÅ : C), ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X‚ÇÅ).Additive\nI : Type u_2\ninst‚úù¬≥ : AddMonoid I\nc : ComplexShape I\ninst‚úù¬≤ : c.TensorSigns\nK : HomologicalComplex C c\ninst‚úù¬π : DecidableEq I\ninst‚úù : ‚àÄ (X‚ÇÇ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).flip.obj X‚ÇÇ)\n‚ä¢ (HomologicalComplex.tensorUnit C c).HasTensor K","decl":"instance : HasTensor (tensorUnit C c) K :=\n  inferInstanceAs (GradedObject.HasTensor (tensorUnit C c).X K.X)\n\n"}
{"name":"HomologicalComplex.unit_tensor_d‚ÇÅ","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst‚úù‚Åπ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù‚Å∏ : CategoryTheory.MonoidalCategory C\ninst‚úù‚Å∑ : CategoryTheory.Preadditive C\ninst‚úù‚Å∂ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù‚Åµ : (CategoryTheory.MonoidalCategory.curriedTensor C).Additive\ninst‚úù‚Å¥ : ‚àÄ (X‚ÇÅ : C), ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X‚ÇÅ).Additive\nI : Type u_2\ninst‚úù¬≥ : AddMonoid I\nc : ComplexShape I\ninst‚úù¬≤ : c.TensorSigns\nK : HomologicalComplex C c\ninst‚úù¬π : DecidableEq I\ninst‚úù : ‚àÄ (X‚ÇÇ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).flip.obj X‚ÇÇ)\ni‚ÇÅ i‚ÇÇ j : I\n‚ä¢ Eq (HomologicalComplex.mapBifunctor.d‚ÇÅ (HomologicalComplex.tensorUnit C c) K (CategoryTheory.MonoidalCategory.curriedTensor C) c i‚ÇÅ i‚ÇÇ j) 0","decl":"@[simp]\nlemma unit_tensor_d‚ÇÅ (i‚ÇÅ i‚ÇÇ j : I) :\n    mapBifunctor.d‚ÇÅ (tensorUnit C c) K (curriedTensor C) c i‚ÇÅ i‚ÇÇ j = 0 := by\n  by_cases h‚ÇÅ : c.Rel i‚ÇÅ (c.next i‚ÇÅ)\n  ¬∑ by_cases h‚ÇÇ : ComplexShape.œÄ c c c (c.next i‚ÇÅ, i‚ÇÇ) = j\n    ¬∑ rw [mapBifunctor.d‚ÇÅ_eq _ _ _ _ h‚ÇÅ _ _ h‚ÇÇ, single_obj_d, Functor.map_zero,\n        zero_app, zero_comp, smul_zero]\n    ¬∑ rw [mapBifunctor.d‚ÇÅ_eq_zero' _ _ _ _ h‚ÇÅ _ _ h‚ÇÇ]\n  ¬∑ rw [mapBifunctor.d‚ÇÅ_eq_zero _ _ _ _ _ _ _ h‚ÇÅ]\n\n"}
{"name":"HomologicalComplex.instHasTensorXTensorUnit_1","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst‚úù‚Å∂ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù‚Åµ : CategoryTheory.MonoidalCategory C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroObject C\nI : Type u_2\ninst‚úù¬≤ : AddMonoid I\nc : ComplexShape I\nK : HomologicalComplex C c\ninst‚úù¬π : DecidableEq I\ninst‚úù : ‚àÄ (X‚ÇÅ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X‚ÇÅ)\n‚ä¢ CategoryTheory.GradedObject.HasTensor K.X (HomologicalComplex.tensorUnit C c).X","decl":"instance : GradedObject.HasTensor K.X (tensorUnit C c).X :=\n  GradedObject.hasTensor_of_iso (Iso.refl _) (tensorUnitIso C c)\n\n"}
{"name":"HomologicalComplex.instHasTensorTensorUnit_1","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst‚úù‚Åπ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù‚Å∏ : CategoryTheory.MonoidalCategory C\ninst‚úù‚Å∑ : CategoryTheory.Preadditive C\ninst‚úù‚Å∂ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù‚Åµ : (CategoryTheory.MonoidalCategory.curriedTensor C).Additive\ninst‚úù‚Å¥ : ‚àÄ (X‚ÇÅ : C), ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X‚ÇÅ).Additive\nI : Type u_2\ninst‚úù¬≥ : AddMonoid I\nc : ComplexShape I\ninst‚úù¬≤ : c.TensorSigns\nK : HomologicalComplex C c\ninst‚úù¬π : DecidableEq I\ninst‚úù : ‚àÄ (X‚ÇÅ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X‚ÇÅ)\n‚ä¢ K.HasTensor (HomologicalComplex.tensorUnit C c)","decl":"instance : HasTensor K (tensorUnit C c) :=\n  inferInstanceAs (GradedObject.HasTensor K.X (tensorUnit C c).X)\n\n"}
{"name":"HomologicalComplex.tensor_unit_d‚ÇÇ","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst‚úù‚Åπ : CategoryTheory.Category.{u_3, u_1} C\ninst‚úù‚Å∏ : CategoryTheory.MonoidalCategory C\ninst‚úù‚Å∑ : CategoryTheory.Preadditive C\ninst‚úù‚Å∂ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù‚Åµ : (CategoryTheory.MonoidalCategory.curriedTensor C).Additive\ninst‚úù‚Å¥ : ‚àÄ (X‚ÇÅ : C), ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X‚ÇÅ).Additive\nI : Type u_2\ninst‚úù¬≥ : AddMonoid I\nc : ComplexShape I\ninst‚úù¬≤ : c.TensorSigns\nK : HomologicalComplex C c\ninst‚úù¬π : DecidableEq I\ninst‚úù : ‚àÄ (X‚ÇÅ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X‚ÇÅ)\ni‚ÇÅ i‚ÇÇ j : I\n‚ä¢ Eq (HomologicalComplex.mapBifunctor.d‚ÇÇ K (HomologicalComplex.tensorUnit C c) (CategoryTheory.MonoidalCategory.curriedTensor C) c i‚ÇÅ i‚ÇÇ j) 0","decl":"@[simp]\nlemma tensor_unit_d‚ÇÇ (i‚ÇÅ i‚ÇÇ j : I) :\n    mapBifunctor.d‚ÇÇ K (tensorUnit C c) (curriedTensor C) c i‚ÇÅ i‚ÇÇ j = 0 := by\n  by_cases h‚ÇÅ : c.Rel i‚ÇÇ (c.next i‚ÇÇ)\n  ¬∑ by_cases h‚ÇÇ : ComplexShape.œÄ c c c (i‚ÇÅ, c.next i‚ÇÇ) = j\n    ¬∑ rw [mapBifunctor.d‚ÇÇ_eq _ _ _ _ _ h‚ÇÅ _ h‚ÇÇ, single_obj_d, Functor.map_zero,\n        zero_comp, smul_zero]\n    ¬∑ rw [mapBifunctor.d‚ÇÇ_eq_zero' _ _ _ _ _ h‚ÇÅ _ h‚ÇÇ]\n  ¬∑ rw [mapBifunctor.d‚ÇÇ_eq_zero _ _ _ _ _ _ _ h‚ÇÅ]\n\n"}
{"name":"HomologicalComplex.leftUnitor'_inv","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst‚úù‚Åπ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å∏ : CategoryTheory.MonoidalCategory C\ninst‚úù‚Å∑ : CategoryTheory.Preadditive C\ninst‚úù‚Å∂ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù‚Åµ : (CategoryTheory.MonoidalCategory.curriedTensor C).Additive\ninst‚úù‚Å¥ : ‚àÄ (X‚ÇÅ : C), ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X‚ÇÅ).Additive\nI : Type u_2\ninst‚úù¬≥ : AddMonoid I\nc : ComplexShape I\ninst‚úù¬≤ : c.TensorSigns\nK : HomologicalComplex C c\ninst‚úù¬π : DecidableEq I\ninst‚úù : ‚àÄ (X‚ÇÇ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).flip.obj X‚ÇÇ)\ni : I\n‚ä¢ Eq (K.leftUnitor'.inv i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (K.X i)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (HomologicalComplex.singleObjXSelf c 0 CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (K.X i)) ((HomologicalComplex.tensorUnit C c).ŒπTensorObj K 0 i i ‚ãØ)))","decl":"lemma leftUnitor'_inv (i : I) :\n    (leftUnitor' K).inv i = (Œª_ (K.X i)).inv ‚â´ ((singleObjXSelf c 0 (ùüô_ C)).inv ‚ñ∑ (K.X i)) ‚â´\n      ŒπTensorObj (tensorUnit C c) K 0 i i (zero_add i) := by\n  dsimp [leftUnitor']\n  rw [GradedObject.Monoidal.leftUnitor_inv_apply, assoc, assoc, Iso.cancel_iso_inv_left,\n    GradedObject.Monoidal.Œπ_tensorHom]\n  dsimp\n  rw [tensorHom_id, ‚Üê comp_whiskerRight_assoc]\n  congr 2\n  rw [‚Üê cancel_epi (GradedObject.Monoidal.tensorUnit‚ÇÄ (I := I)).hom, Iso.hom_inv_id_assoc]\n  dsimp [tensorUnitIso]\n  rw [dif_pos rfl]\n  rfl\n\n"}
{"name":"HomologicalComplex.leftUnitor'_inv_comm","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst‚úù‚Åπ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å∏ : CategoryTheory.MonoidalCategory C\ninst‚úù‚Å∑ : CategoryTheory.Preadditive C\ninst‚úù‚Å∂ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù‚Åµ : (CategoryTheory.MonoidalCategory.curriedTensor C).Additive\ninst‚úù‚Å¥ : ‚àÄ (X‚ÇÅ : C), ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X‚ÇÅ).Additive\nI : Type u_2\ninst‚úù¬≥ : AddMonoid I\nc : ComplexShape I\ninst‚úù¬≤ : c.TensorSigns\nK : HomologicalComplex C c\ninst‚úù¬π : DecidableEq I\ninst‚úù : ‚àÄ (X‚ÇÇ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).flip.obj X‚ÇÇ)\ni j : I\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.leftUnitor'.inv i) (((HomologicalComplex.tensorUnit C c).tensorObj K).d i j)) (CategoryTheory.CategoryStruct.comp (K.d i j) (K.leftUnitor'.inv j))","decl":"@[reassoc]\nlemma leftUnitor'_inv_comm (i j : I) :\n    (leftUnitor' K).inv i ‚â´ (tensorObj (tensorUnit C c) K).d i j =\n      K.d i j ‚â´ (leftUnitor' K).inv j := by\n  by_cases hij : c.Rel i j\n  ¬∑ simp only [leftUnitor'_inv, assoc, mapBifunctor.d_eq,\n      Preadditive.comp_add, mapBifunctor.Œπ_D‚ÇÅ, mapBifunctor.Œπ_D‚ÇÇ,\n      unit_tensor_d‚ÇÅ, comp_zero, zero_add]\n    rw [mapBifunctor.d‚ÇÇ_eq _ _ _ _ _ hij _ (by simp)]\n    dsimp\n    simp only [ComplexShape.Œµ_zero, one_smul, ‚Üê whisker_exchange_assoc,\n      id_whiskerLeft, assoc, Iso.inv_hom_id_assoc]\n  ¬∑ simp only [shape _ _ _ hij, comp_zero, zero_comp]\n\n"}
{"name":"HomologicalComplex.leftUnitor'_inv_comm_assoc","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst‚úù‚Åπ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å∏ : CategoryTheory.MonoidalCategory C\ninst‚úù‚Å∑ : CategoryTheory.Preadditive C\ninst‚úù‚Å∂ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù‚Åµ : (CategoryTheory.MonoidalCategory.curriedTensor C).Additive\ninst‚úù‚Å¥ : ‚àÄ (X‚ÇÅ : C), ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X‚ÇÅ).Additive\nI : Type u_2\ninst‚úù¬≥ : AddMonoid I\nc : ComplexShape I\ninst‚úù¬≤ : c.TensorSigns\nK : HomologicalComplex C c\ninst‚úù¬π : DecidableEq I\ninst‚úù : ‚àÄ (X‚ÇÇ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).flip.obj X‚ÇÇ)\ni j : I\nZ : C\nh : Quiver.Hom (((HomologicalComplex.tensorUnit C c).tensorObj K).X j) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.leftUnitor'.inv i) (CategoryTheory.CategoryStruct.comp (((HomologicalComplex.tensorUnit C c).tensorObj K).d i j) h)) (CategoryTheory.CategoryStruct.comp (K.d i j) (CategoryTheory.CategoryStruct.comp (K.leftUnitor'.inv j) h))","decl":"@[reassoc]\nlemma leftUnitor'_inv_comm (i j : I) :\n    (leftUnitor' K).inv i ‚â´ (tensorObj (tensorUnit C c) K).d i j =\n      K.d i j ‚â´ (leftUnitor' K).inv j := by\n  by_cases hij : c.Rel i j\n  ¬∑ simp only [leftUnitor'_inv, assoc, mapBifunctor.d_eq,\n      Preadditive.comp_add, mapBifunctor.Œπ_D‚ÇÅ, mapBifunctor.Œπ_D‚ÇÇ,\n      unit_tensor_d‚ÇÅ, comp_zero, zero_add]\n    rw [mapBifunctor.d‚ÇÇ_eq _ _ _ _ _ hij _ (by simp)]\n    dsimp\n    simp only [ComplexShape.Œµ_zero, one_smul, ‚Üê whisker_exchange_assoc,\n      id_whiskerLeft, assoc, Iso.inv_hom_id_assoc]\n  ¬∑ simp only [shape _ _ _ hij, comp_zero, zero_comp]\n\n"}
{"name":"HomologicalComplex.rightUnitor'_inv","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst‚úù‚Åπ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å∏ : CategoryTheory.MonoidalCategory C\ninst‚úù‚Å∑ : CategoryTheory.Preadditive C\ninst‚úù‚Å∂ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù‚Åµ : (CategoryTheory.MonoidalCategory.curriedTensor C).Additive\ninst‚úù‚Å¥ : ‚àÄ (X‚ÇÅ : C), ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X‚ÇÅ).Additive\nI : Type u_2\ninst‚úù¬≥ : AddMonoid I\nc : ComplexShape I\ninst‚úù¬≤ : c.TensorSigns\nK : HomologicalComplex C c\ninst‚úù¬π : DecidableEq I\ninst‚úù : ‚àÄ (X‚ÇÅ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X‚ÇÅ)\ni : I\n‚ä¢ Eq (K.rightUnitor'.inv i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (K.X i)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (K.X i) (HomologicalComplex.singleObjXSelf c 0 CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv) (K.ŒπTensorObj (HomologicalComplex.tensorUnit C c) i 0 i ‚ãØ)))","decl":"lemma rightUnitor'_inv (i : I) :\n    (rightUnitor' K).inv i = (œÅ_ (K.X i)).inv ‚â´ ((K.X i) ‚óÅ (singleObjXSelf c 0 (ùüô_ C)).inv) ‚â´\n      ŒπTensorObj K (tensorUnit C c) i 0 i (add_zero i) := by\n  dsimp [rightUnitor']\n  rw [GradedObject.Monoidal.rightUnitor_inv_apply, assoc, assoc, Iso.cancel_iso_inv_left,\n    GradedObject.Monoidal.Œπ_tensorHom]\n  dsimp\n  rw [id_tensorHom, ‚Üê MonoidalCategory.whiskerLeft_comp_assoc]\n  congr 2\n  rw [‚Üê cancel_epi (GradedObject.Monoidal.tensorUnit‚ÇÄ (I := I)).hom, Iso.hom_inv_id_assoc]\n  dsimp [tensorUnitIso]\n  rw [dif_pos rfl]\n  rfl\n\n"}
{"name":"HomologicalComplex.rightUnitor'_inv_comm","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst‚úù‚Åπ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù‚Å∏ : CategoryTheory.MonoidalCategory C\ninst‚úù‚Å∑ : CategoryTheory.Preadditive C\ninst‚úù‚Å∂ : CategoryTheory.Limits.HasZeroObject C\ninst‚úù‚Åµ : (CategoryTheory.MonoidalCategory.curriedTensor C).Additive\ninst‚úù‚Å¥ : ‚àÄ (X‚ÇÅ : C), ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X‚ÇÅ).Additive\nI : Type u_2\ninst‚úù¬≥ : AddMonoid I\nc : ComplexShape I\ninst‚úù¬≤ : c.TensorSigns\nK : HomologicalComplex C c\ninst‚úù¬π : DecidableEq I\ninst‚úù : ‚àÄ (X‚ÇÅ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X‚ÇÅ)\ni j : I\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (K.rightUnitor'.inv i) ((K.tensorObj (HomologicalComplex.tensorUnit C c)).d i j)) (CategoryTheory.CategoryStruct.comp (K.d i j) (K.rightUnitor'.inv j))","decl":"lemma rightUnitor'_inv_comm (i j : I) :\n    (rightUnitor' K).inv i ‚â´ (tensorObj K (tensorUnit C c)).d i j =\n      K.d i j ‚â´ (rightUnitor' K).inv j := by\n  by_cases hij : c.Rel i j\n  ¬∑ simp only [rightUnitor'_inv, assoc, mapBifunctor.d_eq,\n      Preadditive.comp_add, mapBifunctor.Œπ_D‚ÇÅ, mapBifunctor.Œπ_D‚ÇÇ,\n      tensor_unit_d‚ÇÇ, comp_zero, add_zero]\n    rw [mapBifunctor.d‚ÇÅ_eq _ _ _ _ hij _ _ (by simp)]\n    dsimp\n    simp only [one_smul, whisker_exchange_assoc,\n      MonoidalCategory.whiskerRight_id, assoc, Iso.inv_hom_id_assoc]\n  ¬∑ simp only [shape _ _ _ hij, comp_zero, zero_comp]\n\n"}
