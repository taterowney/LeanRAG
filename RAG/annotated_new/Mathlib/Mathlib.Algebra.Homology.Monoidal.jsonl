{"name":"HomologicalComplex.instHasTensorOfHasTensorX","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.MonoidalCategory C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : (CategoryTheory.MonoidalCategory.curriedTensor C).Additive\ninst✝³ : ∀ (X₁ : C), ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X₁).Additive\nI : Type u_2\ninst✝² : AddMonoid I\nc : ComplexShape I\ninst✝¹ : c.TensorSigns\nK₁ K₂ : HomologicalComplex C c\ninst✝ : CategoryTheory.GradedObject.HasTensor K₁.X K₂.X\n⊢ K₁.HasTensor K₂","decl":"instance (K₁ K₂ : HomologicalComplex C c) [GradedObject.HasTensor K₁.X K₂.X] :\n    HasTensor K₁ K₂ := by\n  assumption\n\n"}
{"name":"HomologicalComplex.instHasGoodTensor₁₂OfHasGoodTensor₁₂TensorX","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\ninst✝³ : CategoryTheory.Preadditive C\nI : Type u_2\ninst✝² : AddMonoid I\nc : ComplexShape I\ninst✝¹ : c.TensorSigns\nK₁ K₂ K₃ : HomologicalComplex C c\ninst✝ : CategoryTheory.GradedObject.HasGoodTensor₁₂Tensor K₁.X K₂.X K₃.X\n⊢ K₁.HasGoodTensor₁₂ K₂ K₃","decl":"instance (K₁ K₂ K₃ : HomologicalComplex C c)\n    [GradedObject.HasGoodTensor₁₂Tensor K₁.X K₂.X K₃.X] :\n    HasGoodTensor₁₂ K₁ K₂ K₃ :=\n  inferInstanceAs (GradedObject.HasGoodTensor₁₂Tensor K₁.X K₂.X K₃.X)\n\n"}
{"name":"HomologicalComplex.instHasGoodTensor₂₃OfHasGoodTensorTensor₂₃X","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.MonoidalCategory C\ninst✝³ : CategoryTheory.Preadditive C\nI : Type u_2\ninst✝² : AddMonoid I\nc : ComplexShape I\ninst✝¹ : c.TensorSigns\nK₁ K₂ K₃ : HomologicalComplex C c\ninst✝ : CategoryTheory.GradedObject.HasGoodTensorTensor₂₃ K₁.X K₂.X K₃.X\n⊢ K₁.HasGoodTensor₂₃ K₂ K₃","decl":"instance (K₁ K₂ K₃ : HomologicalComplex C c)\n    [GradedObject.HasGoodTensorTensor₂₃ K₁.X K₂.X K₃.X] :\n    HasGoodTensor₂₃ K₁ K₂ K₃ :=\n  inferInstanceAs (GradedObject.HasGoodTensorTensor₂₃ K₁.X K₂.X K₃.X)\n\n"}
{"name":"HomologicalComplex.instHasTensorXTensorUnit","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\nI : Type u_2\ninst✝² : AddMonoid I\nc : ComplexShape I\nK : HomologicalComplex C c\ninst✝¹ : DecidableEq I\ninst✝ : ∀ (X₂ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).flip.obj X₂)\n⊢ CategoryTheory.GradedObject.HasTensor (HomologicalComplex.tensorUnit C c).X K.X","decl":"instance : GradedObject.HasTensor (tensorUnit C c).X K.X :=\n  GradedObject.hasTensor_of_iso (tensorUnitIso C c) (Iso.refl _)\n\n"}
{"name":"HomologicalComplex.instHasTensorTensorUnit","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst✝⁹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁸ : CategoryTheory.MonoidalCategory C\ninst✝⁷ : CategoryTheory.Preadditive C\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : (CategoryTheory.MonoidalCategory.curriedTensor C).Additive\ninst✝⁴ : ∀ (X₁ : C), ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X₁).Additive\nI : Type u_2\ninst✝³ : AddMonoid I\nc : ComplexShape I\ninst✝² : c.TensorSigns\nK : HomologicalComplex C c\ninst✝¹ : DecidableEq I\ninst✝ : ∀ (X₂ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).flip.obj X₂)\n⊢ (HomologicalComplex.tensorUnit C c).HasTensor K","decl":"instance : HasTensor (tensorUnit C c) K :=\n  inferInstanceAs (GradedObject.HasTensor (tensorUnit C c).X K.X)\n\n"}
{"name":"HomologicalComplex.unit_tensor_d₁","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst✝⁹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁸ : CategoryTheory.MonoidalCategory C\ninst✝⁷ : CategoryTheory.Preadditive C\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : (CategoryTheory.MonoidalCategory.curriedTensor C).Additive\ninst✝⁴ : ∀ (X₁ : C), ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X₁).Additive\nI : Type u_2\ninst✝³ : AddMonoid I\nc : ComplexShape I\ninst✝² : c.TensorSigns\nK : HomologicalComplex C c\ninst✝¹ : DecidableEq I\ninst✝ : ∀ (X₂ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).flip.obj X₂)\ni₁ i₂ j : I\n⊢ Eq (HomologicalComplex.mapBifunctor.d₁ (HomologicalComplex.tensorUnit C c) K (CategoryTheory.MonoidalCategory.curriedTensor C) c i₁ i₂ j) 0","decl":"@[simp]\nlemma unit_tensor_d₁ (i₁ i₂ j : I) :\n    mapBifunctor.d₁ (tensorUnit C c) K (curriedTensor C) c i₁ i₂ j = 0 := by\n  by_cases h₁ : c.Rel i₁ (c.next i₁)\n  · by_cases h₂ : ComplexShape.π c c c (c.next i₁, i₂) = j\n    · rw [mapBifunctor.d₁_eq _ _ _ _ h₁ _ _ h₂, single_obj_d, Functor.map_zero,\n        zero_app, zero_comp, smul_zero]\n    · rw [mapBifunctor.d₁_eq_zero' _ _ _ _ h₁ _ _ h₂]\n  · rw [mapBifunctor.d₁_eq_zero _ _ _ _ _ _ _ h₁]\n\n"}
{"name":"HomologicalComplex.instHasTensorXTensorUnit_1","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.MonoidalCategory C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasZeroObject C\nI : Type u_2\ninst✝² : AddMonoid I\nc : ComplexShape I\nK : HomologicalComplex C c\ninst✝¹ : DecidableEq I\ninst✝ : ∀ (X₁ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X₁)\n⊢ CategoryTheory.GradedObject.HasTensor K.X (HomologicalComplex.tensorUnit C c).X","decl":"instance : GradedObject.HasTensor K.X (tensorUnit C c).X :=\n  GradedObject.hasTensor_of_iso (Iso.refl _) (tensorUnitIso C c)\n\n"}
{"name":"HomologicalComplex.instHasTensorTensorUnit_1","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst✝⁹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁸ : CategoryTheory.MonoidalCategory C\ninst✝⁷ : CategoryTheory.Preadditive C\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : (CategoryTheory.MonoidalCategory.curriedTensor C).Additive\ninst✝⁴ : ∀ (X₁ : C), ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X₁).Additive\nI : Type u_2\ninst✝³ : AddMonoid I\nc : ComplexShape I\ninst✝² : c.TensorSigns\nK : HomologicalComplex C c\ninst✝¹ : DecidableEq I\ninst✝ : ∀ (X₁ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X₁)\n⊢ K.HasTensor (HomologicalComplex.tensorUnit C c)","decl":"instance : HasTensor K (tensorUnit C c) :=\n  inferInstanceAs (GradedObject.HasTensor K.X (tensorUnit C c).X)\n\n"}
{"name":"HomologicalComplex.tensor_unit_d₂","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst✝⁹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁸ : CategoryTheory.MonoidalCategory C\ninst✝⁷ : CategoryTheory.Preadditive C\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : (CategoryTheory.MonoidalCategory.curriedTensor C).Additive\ninst✝⁴ : ∀ (X₁ : C), ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X₁).Additive\nI : Type u_2\ninst✝³ : AddMonoid I\nc : ComplexShape I\ninst✝² : c.TensorSigns\nK : HomologicalComplex C c\ninst✝¹ : DecidableEq I\ninst✝ : ∀ (X₁ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X₁)\ni₁ i₂ j : I\n⊢ Eq (HomologicalComplex.mapBifunctor.d₂ K (HomologicalComplex.tensorUnit C c) (CategoryTheory.MonoidalCategory.curriedTensor C) c i₁ i₂ j) 0","decl":"@[simp]\nlemma tensor_unit_d₂ (i₁ i₂ j : I) :\n    mapBifunctor.d₂ K (tensorUnit C c) (curriedTensor C) c i₁ i₂ j = 0 := by\n  by_cases h₁ : c.Rel i₂ (c.next i₂)\n  · by_cases h₂ : ComplexShape.π c c c (i₁, c.next i₂) = j\n    · rw [mapBifunctor.d₂_eq _ _ _ _ _ h₁ _ h₂, single_obj_d, Functor.map_zero,\n        zero_comp, smul_zero]\n    · rw [mapBifunctor.d₂_eq_zero' _ _ _ _ _ h₁ _ h₂]\n  · rw [mapBifunctor.d₂_eq_zero _ _ _ _ _ _ _ h₁]\n\n"}
{"name":"HomologicalComplex.leftUnitor'_inv","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst✝⁹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁸ : CategoryTheory.MonoidalCategory C\ninst✝⁷ : CategoryTheory.Preadditive C\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : (CategoryTheory.MonoidalCategory.curriedTensor C).Additive\ninst✝⁴ : ∀ (X₁ : C), ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X₁).Additive\nI : Type u_2\ninst✝³ : AddMonoid I\nc : ComplexShape I\ninst✝² : c.TensorSigns\nK : HomologicalComplex C c\ninst✝¹ : DecidableEq I\ninst✝ : ∀ (X₂ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).flip.obj X₂)\ni : I\n⊢ Eq (K.leftUnitor'.inv i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor (K.X i)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (HomologicalComplex.singleObjXSelf c 0 CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv (K.X i)) ((HomologicalComplex.tensorUnit C c).ιTensorObj K 0 i i ⋯)))","decl":"lemma leftUnitor'_inv (i : I) :\n    (leftUnitor' K).inv i = (λ_ (K.X i)).inv ≫ ((singleObjXSelf c 0 (𝟙_ C)).inv ▷ (K.X i)) ≫\n      ιTensorObj (tensorUnit C c) K 0 i i (zero_add i) := by\n  dsimp [leftUnitor']\n  rw [GradedObject.Monoidal.leftUnitor_inv_apply, assoc, assoc, Iso.cancel_iso_inv_left,\n    GradedObject.Monoidal.ι_tensorHom]\n  dsimp\n  rw [tensorHom_id, ← comp_whiskerRight_assoc]\n  congr 2\n  rw [← cancel_epi (GradedObject.Monoidal.tensorUnit₀ (I := I)).hom, Iso.hom_inv_id_assoc]\n  dsimp [tensorUnitIso]\n  rw [dif_pos rfl]\n  rfl\n\n"}
{"name":"HomologicalComplex.leftUnitor'_inv_comm","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst✝⁹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁸ : CategoryTheory.MonoidalCategory C\ninst✝⁷ : CategoryTheory.Preadditive C\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : (CategoryTheory.MonoidalCategory.curriedTensor C).Additive\ninst✝⁴ : ∀ (X₁ : C), ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X₁).Additive\nI : Type u_2\ninst✝³ : AddMonoid I\nc : ComplexShape I\ninst✝² : c.TensorSigns\nK : HomologicalComplex C c\ninst✝¹ : DecidableEq I\ninst✝ : ∀ (X₂ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).flip.obj X₂)\ni j : I\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.leftUnitor'.inv i) (((HomologicalComplex.tensorUnit C c).tensorObj K).d i j)) (CategoryTheory.CategoryStruct.comp (K.d i j) (K.leftUnitor'.inv j))","decl":"@[reassoc]\nlemma leftUnitor'_inv_comm (i j : I) :\n    (leftUnitor' K).inv i ≫ (tensorObj (tensorUnit C c) K).d i j =\n      K.d i j ≫ (leftUnitor' K).inv j := by\n  by_cases hij : c.Rel i j\n  · simp only [leftUnitor'_inv, assoc, mapBifunctor.d_eq,\n      Preadditive.comp_add, mapBifunctor.ι_D₁, mapBifunctor.ι_D₂,\n      unit_tensor_d₁, comp_zero, zero_add]\n    rw [mapBifunctor.d₂_eq _ _ _ _ _ hij _ (by simp)]\n    dsimp\n    simp only [ComplexShape.ε_zero, one_smul, ← whisker_exchange_assoc,\n      id_whiskerLeft, assoc, Iso.inv_hom_id_assoc]\n  · simp only [shape _ _ _ hij, comp_zero, zero_comp]\n\n"}
{"name":"HomologicalComplex.leftUnitor'_inv_comm_assoc","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst✝⁹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁸ : CategoryTheory.MonoidalCategory C\ninst✝⁷ : CategoryTheory.Preadditive C\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : (CategoryTheory.MonoidalCategory.curriedTensor C).Additive\ninst✝⁴ : ∀ (X₁ : C), ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X₁).Additive\nI : Type u_2\ninst✝³ : AddMonoid I\nc : ComplexShape I\ninst✝² : c.TensorSigns\nK : HomologicalComplex C c\ninst✝¹ : DecidableEq I\ninst✝ : ∀ (X₂ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).flip.obj X₂)\ni j : I\nZ : C\nh : Quiver.Hom (((HomologicalComplex.tensorUnit C c).tensorObj K).X j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.leftUnitor'.inv i) (CategoryTheory.CategoryStruct.comp (((HomologicalComplex.tensorUnit C c).tensorObj K).d i j) h)) (CategoryTheory.CategoryStruct.comp (K.d i j) (CategoryTheory.CategoryStruct.comp (K.leftUnitor'.inv j) h))","decl":"@[reassoc]\nlemma leftUnitor'_inv_comm (i j : I) :\n    (leftUnitor' K).inv i ≫ (tensorObj (tensorUnit C c) K).d i j =\n      K.d i j ≫ (leftUnitor' K).inv j := by\n  by_cases hij : c.Rel i j\n  · simp only [leftUnitor'_inv, assoc, mapBifunctor.d_eq,\n      Preadditive.comp_add, mapBifunctor.ι_D₁, mapBifunctor.ι_D₂,\n      unit_tensor_d₁, comp_zero, zero_add]\n    rw [mapBifunctor.d₂_eq _ _ _ _ _ hij _ (by simp)]\n    dsimp\n    simp only [ComplexShape.ε_zero, one_smul, ← whisker_exchange_assoc,\n      id_whiskerLeft, assoc, Iso.inv_hom_id_assoc]\n  · simp only [shape _ _ _ hij, comp_zero, zero_comp]\n\n"}
{"name":"HomologicalComplex.rightUnitor'_inv","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst✝⁹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁸ : CategoryTheory.MonoidalCategory C\ninst✝⁷ : CategoryTheory.Preadditive C\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : (CategoryTheory.MonoidalCategory.curriedTensor C).Additive\ninst✝⁴ : ∀ (X₁ : C), ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X₁).Additive\nI : Type u_2\ninst✝³ : AddMonoid I\nc : ComplexShape I\ninst✝² : c.TensorSigns\nK : HomologicalComplex C c\ninst✝¹ : DecidableEq I\ninst✝ : ∀ (X₁ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X₁)\ni : I\n⊢ Eq (K.rightUnitor'.inv i) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor (K.X i)).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (K.X i) (HomologicalComplex.singleObjXSelf c 0 CategoryTheory.MonoidalCategoryStruct.tensorUnit).inv) (K.ιTensorObj (HomologicalComplex.tensorUnit C c) i 0 i ⋯)))","decl":"lemma rightUnitor'_inv (i : I) :\n    (rightUnitor' K).inv i = (ρ_ (K.X i)).inv ≫ ((K.X i) ◁ (singleObjXSelf c 0 (𝟙_ C)).inv) ≫\n      ιTensorObj K (tensorUnit C c) i 0 i (add_zero i) := by\n  dsimp [rightUnitor']\n  rw [GradedObject.Monoidal.rightUnitor_inv_apply, assoc, assoc, Iso.cancel_iso_inv_left,\n    GradedObject.Monoidal.ι_tensorHom]\n  dsimp\n  rw [id_tensorHom, ← MonoidalCategory.whiskerLeft_comp_assoc]\n  congr 2\n  rw [← cancel_epi (GradedObject.Monoidal.tensorUnit₀ (I := I)).hom, Iso.hom_inv_id_assoc]\n  dsimp [tensorUnitIso]\n  rw [dif_pos rfl]\n  rfl\n\n"}
{"name":"HomologicalComplex.rightUnitor'_inv_comm","module":"Mathlib.Algebra.Homology.Monoidal","initialProofState":"C : Type u_1\ninst✝⁹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁸ : CategoryTheory.MonoidalCategory C\ninst✝⁷ : CategoryTheory.Preadditive C\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : (CategoryTheory.MonoidalCategory.curriedTensor C).Additive\ninst✝⁴ : ∀ (X₁ : C), ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X₁).Additive\nI : Type u_2\ninst✝³ : AddMonoid I\nc : ComplexShape I\ninst✝² : c.TensorSigns\nK : HomologicalComplex C c\ninst✝¹ : DecidableEq I\ninst✝ : ∀ (X₁ : C), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) ((CategoryTheory.MonoidalCategory.curriedTensor C).obj X₁)\ni j : I\n⊢ Eq (CategoryTheory.CategoryStruct.comp (K.rightUnitor'.inv i) ((K.tensorObj (HomologicalComplex.tensorUnit C c)).d i j)) (CategoryTheory.CategoryStruct.comp (K.d i j) (K.rightUnitor'.inv j))","decl":"lemma rightUnitor'_inv_comm (i j : I) :\n    (rightUnitor' K).inv i ≫ (tensorObj K (tensorUnit C c)).d i j =\n      K.d i j ≫ (rightUnitor' K).inv j := by\n  by_cases hij : c.Rel i j\n  · simp only [rightUnitor'_inv, assoc, mapBifunctor.d_eq,\n      Preadditive.comp_add, mapBifunctor.ι_D₁, mapBifunctor.ι_D₂,\n      tensor_unit_d₂, comp_zero, add_zero]\n    rw [mapBifunctor.d₁_eq _ _ _ _ hij _ _ (by simp)]\n    dsimp\n    simp only [one_smul, whisker_exchange_assoc,\n      MonoidalCategory.whiskerRight_id, assoc, Iso.inv_hom_id_assoc]\n  · simp only [shape _ _ _ hij, comp_zero, zero_comp]\n\n"}
