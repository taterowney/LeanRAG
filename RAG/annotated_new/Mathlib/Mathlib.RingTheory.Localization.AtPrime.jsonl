{"name":"Ideal.primeCompl_le_nonZeroDivisors","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nP : Ideal R\nhp : P.IsPrime\ninst✝ : NoZeroDivisors R\n⊢ LE.le P.primeCompl (nonZeroDivisors R)","decl":"theorem primeCompl_le_nonZeroDivisors [NoZeroDivisors R] : P.primeCompl ≤ nonZeroDivisors R :=\n  le_nonZeroDivisors_of_noZeroDivisors <| not_not_intro P.zero_mem\n\n"}
{"name":"Ideal.disjoint_map_primeCompl_iff_comap_le","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Type u_4\ninst✝¹ : Semiring S\nf : RingHom R S\np : Ideal R\nI : Ideal S\ninst✝ : p.IsPrime\n⊢ Iff (Disjoint ↑I ↑(Submonoid.map f p.primeCompl)) (LE.le (Ideal.comap f I) p)","decl":"lemma disjoint_map_primeCompl_iff_comap_le {S : Type*} [Semiring S] {f : R →+* S}\n    {p : Ideal R} {I : Ideal S} [p.IsPrime] :\n    Disjoint (I : Set S) (p.primeCompl.map f) ↔ I.comap f ≤ p := by\n  rw [disjoint_comm]\n  simp [Set.disjoint_iff, Set.ext_iff, Ideal.primeCompl, not_imp_not, SetLike.le_def]\n\n"}
{"name":"IsLocalization.AtPrime.Nontrivial","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nP : Ideal R\nhp : P.IsPrime\ninst✝ : IsLocalization.AtPrime S P\n⊢ Nontrivial S","decl":"theorem AtPrime.Nontrivial [IsLocalization.AtPrime S P] : Nontrivial S :=\n  nontrivial_of_ne (0 : S) 1 fun hze => by\n    rw [← (algebraMap R S).map_one, ← (algebraMap R S).map_zero] at hze\n    obtain ⟨t, ht⟩ := (eq_iff_exists P.primeCompl S).1 hze\n    have htz : (t : R) = 0 := by simpa using ht.symm\n    exact t.2 (htz.symm ▸ P.zero_mem : ↑t ∈ P)\n\n"}
{"name":"IsLocalization.AtPrime.isLocalRing","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nP : Ideal R\nhp : P.IsPrime\ninst✝ : IsLocalization.AtPrime S P\n⊢ IsLocalRing S","decl":"theorem AtPrime.isLocalRing [IsLocalization.AtPrime S P] : IsLocalRing S :=\n  -- Porting note: since I couldn't get local instance running, I just specify it manually\n  letI := AtPrime.Nontrivial S P\n  IsLocalRing.of_nonunits_add\n    (by\n      intro x y hx hy hu\n      cases' isUnit_iff_exists_inv.1 hu with z hxyz\n      have : ∀ {r : R} {s : P.primeCompl}, mk' S r s ∈ nonunits S → r ∈ P := fun {r s} =>\n        not_imp_comm.1 fun nr => isUnit_iff_exists_inv.2 ⟨mk' S ↑s (⟨r, nr⟩ : P.primeCompl),\n          mk'_mul_mk'_eq_one' _ _ <| show r ∈ P.primeCompl from nr⟩\n      rcases mk'_surjective P.primeCompl x with ⟨rx, sx, hrx⟩\n      rcases mk'_surjective P.primeCompl y with ⟨ry, sy, hry⟩\n      rcases mk'_surjective P.primeCompl z with ⟨rz, sz, hrz⟩\n      rw [← hrx, ← hry, ← hrz, ← mk'_add, ← mk'_mul, ← mk'_self S P.primeCompl.one_mem] at hxyz\n      rw [← hrx] at hx\n      rw [← hry] at hy\n      obtain ⟨t, ht⟩ := IsLocalization.eq.1 hxyz\n      simp only [mul_one, one_mul, Submonoid.coe_mul, Subtype.coe_mk] at ht\n      suffices (t : R) * (sx * sy * sz) ∈ P from\n        not_or_intro (mt hp.mem_or_mem <| not_or_intro sx.2 sy.2) sz.2\n          (hp.mem_or_mem <| (hp.mem_or_mem this).resolve_left t.2)\n      rw [← ht]\n      exact\n        P.mul_mem_left _ <| P.mul_mem_right _ <|\n            P.add_mem (P.mul_mem_right _ <| this hx) <| P.mul_mem_right _ <| this hy)\n\n"}
{"name":"IsLocalization.AtPrime.localRing","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nP : Ideal R\nhp : P.IsPrime\ninst✝ : IsLocalization.AtPrime S P\n⊢ IsLocalRing S","decl":"@[deprecated (since := \"2024-11-09\")] alias AtPrime.localRing := AtPrime.isLocalRing\n\n"}
{"name":"Localization.AtPrime.isLocalRing","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nP : Ideal R\nhp : P.IsPrime\n⊢ IsLocalRing (Localization P.primeCompl)","decl":"/-- The localization of `R` at the complement of a prime ideal is a local ring. -/\ninstance AtPrime.isLocalRing : IsLocalRing (Localization P.primeCompl) :=\n  IsLocalization.AtPrime.isLocalRing (Localization P.primeCompl) P\n\n"}
{"name":"IsLocalization.isDomain_of_local_atPrime","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"A : Type u_4\ninst✝¹ : CommRing A\ninst✝ : IsDomain A\nP : Ideal A\nx✝ : P.IsPrime\n⊢ IsDomain (Localization.AtPrime P)","decl":"/-- The localization of an integral domain at the complement of a prime ideal is an integral domain.\n-/\ninstance isDomain_of_local_atPrime {P : Ideal A} (_ : P.IsPrime) :\n    IsDomain (Localization.AtPrime P) :=\n  isDomain_localization P.primeCompl_le_nonZeroDivisors\n\n"}
{"name":"IsLocalization.AtPrime.isUnit_to_map_iff","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nI : Ideal R\nhI : I.IsPrime\ninst✝ : IsLocalization.AtPrime S I\nx : R\n⊢ Iff (IsUnit ((algebraMap R S) x)) (Membership.mem I.primeCompl x)","decl":"theorem isUnit_to_map_iff (x : R) : IsUnit ((algebraMap R S) x) ↔ x ∈ I.primeCompl :=\n  ⟨fun h hx =>\n    (isPrime_of_isPrime_disjoint I.primeCompl S I hI disjoint_compl_left).ne_top <|\n      (Ideal.map (algebraMap R S) I).eq_top_of_isUnit_mem (Ideal.mem_map_of_mem _ hx) h,\n    fun h => map_units S ⟨x, h⟩⟩\n\n-- Can't use typeclasses to infer the `IsLocalRing` instance, so use an `optParam` instead\n-- (since `IsLocalRing` is a `Prop`, there should be no unification issues.)\n"}
{"name":"IsLocalization.AtPrime.to_map_mem_maximal_iff","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nI : Ideal R\nhI : I.IsPrime\ninst✝ : IsLocalization.AtPrime S I\nx : R\nh : optParam (IsLocalRing S) ⋯\n⊢ Iff (Membership.mem (IsLocalRing.maximalIdeal S) ((algebraMap R S) x)) (Membership.mem I x)","decl":"theorem to_map_mem_maximal_iff (x : R) (h : IsLocalRing S := isLocalRing S I) :\n    algebraMap R S x ∈ IsLocalRing.maximalIdeal S ↔ x ∈ I :=\n  not_iff_not.mp <| by\n    simpa only [IsLocalRing.mem_maximalIdeal, mem_nonunits_iff, Classical.not_not] using\n      isUnit_to_map_iff S I x\n\n"}
{"name":"IsLocalization.AtPrime.comap_maximalIdeal","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nI : Ideal R\nhI : I.IsPrime\ninst✝ : IsLocalization.AtPrime S I\nh : optParam (IsLocalRing S) ⋯\n⊢ Eq (Ideal.comap (algebraMap R S) (IsLocalRing.maximalIdeal S)) I","decl":"theorem comap_maximalIdeal (h : IsLocalRing S := isLocalRing S I) :\n    (IsLocalRing.maximalIdeal S).comap (algebraMap R S) = I :=\n  Ideal.ext fun x => by simpa only [Ideal.mem_comap] using to_map_mem_maximal_iff _ I x\n\n"}
{"name":"IsLocalization.AtPrime.isUnit_mk'_iff","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nI : Ideal R\nhI : I.IsPrime\ninst✝ : IsLocalization.AtPrime S I\nx : R\ny : Subtype fun x => Membership.mem I.primeCompl x\n⊢ Iff (IsUnit (IsLocalization.mk' S x y)) (Membership.mem I.primeCompl x)","decl":"theorem isUnit_mk'_iff (x : R) (y : I.primeCompl) : IsUnit (mk' S x y) ↔ x ∈ I.primeCompl :=\n  ⟨fun h hx => mk'_mem_iff.mpr ((to_map_mem_maximal_iff S I x).mpr hx) h, fun h =>\n    isUnit_iff_exists_inv.mpr ⟨mk' S ↑y ⟨x, h⟩, mk'_mul_mk'_eq_one ⟨x, h⟩ y⟩⟩\n\n"}
{"name":"IsLocalization.AtPrime.mk'_mem_maximal_iff","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nI : Ideal R\nhI : I.IsPrime\ninst✝ : IsLocalization.AtPrime S I\nx : R\ny : Subtype fun x => Membership.mem I.primeCompl x\nh : optParam (IsLocalRing S) ⋯\n⊢ Iff (Membership.mem (IsLocalRing.maximalIdeal S) (IsLocalization.mk' S x y)) (Membership.mem I x)","decl":"theorem mk'_mem_maximal_iff (x : R) (y : I.primeCompl) (h : IsLocalRing S := isLocalRing S I) :\n    mk' S x y ∈ IsLocalRing.maximalIdeal S ↔ x ∈ I :=\n  not_iff_not.mp <| by\n    simpa only [IsLocalRing.mem_maximalIdeal, mem_nonunits_iff, Classical.not_not] using\n      isUnit_mk'_iff S I x y\n\n"}
{"name":"Localization.AtPrime.comap_maximalIdeal","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\nhI : I.IsPrime\n⊢ Eq (Ideal.comap (algebraMap R (Localization.AtPrime I)) (IsLocalRing.maximalIdeal (Localization I.primeCompl))) I","decl":"/-- The unique maximal ideal of the localization at `I.primeCompl` lies over the ideal `I`. -/\ntheorem AtPrime.comap_maximalIdeal :\n    Ideal.comap (algebraMap R (Localization.AtPrime I))\n        (IsLocalRing.maximalIdeal (Localization I.primeCompl)) =\n      I :=\n  -- Porting note: need to provide full name\n  IsLocalization.AtPrime.comap_maximalIdeal _ _\n\n"}
{"name":"Localization.AtPrime.map_eq_maximalIdeal","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\nhI : I.IsPrime\n⊢ Eq (Ideal.map (algebraMap R (Localization.AtPrime I)) I) (IsLocalRing.maximalIdeal (Localization I.primeCompl))","decl":"/-- The image of `I` in the localization at `I.primeCompl` is a maximal ideal, and in particular\nit is the unique maximal ideal given by the local ring structure `AtPrime.isLocalRing` -/\ntheorem AtPrime.map_eq_maximalIdeal :\n    Ideal.map (algebraMap R (Localization.AtPrime I)) I =\n      IsLocalRing.maximalIdeal (Localization I.primeCompl) := by\n  convert congr_arg (Ideal.map (algebraMap R (Localization.AtPrime I)))\n  -- Porting note: `algebraMap R ...` can not be solve by unification\n    (AtPrime.comap_maximalIdeal (hI := hI)).symm\n  -- Porting note: can not find `hI`\n  rw [map_comap I.primeCompl]\n\n"}
{"name":"Localization.le_comap_primeCompl_iff","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nP : Type u_3\ninst✝¹ : CommSemiring P\nI : Ideal R\nhI : I.IsPrime\nJ : Ideal P\ninst✝ : J.IsPrime\nf : RingHom R P\n⊢ Iff (LE.le I.primeCompl (Submonoid.comap f J.primeCompl)) (LE.le (Ideal.comap f J) I)","decl":"theorem le_comap_primeCompl_iff {J : Ideal P} [J.IsPrime] {f : R →+* P} :\n    I.primeCompl ≤ J.primeCompl.comap f ↔ J.comap f ≤ I :=\n  ⟨fun h x hx => by\n    contrapose! hx\n    exact h hx,\n   fun h _ hx hfxJ => hx (h hfxJ)⟩\n\n"}
{"name":"Localization.localRingHom_to_map","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nP : Type u_3\ninst✝¹ : CommSemiring P\nI : Ideal R\nhI : I.IsPrime\nJ : Ideal P\ninst✝ : J.IsPrime\nf : RingHom R P\nhIJ : Eq I (Ideal.comap f J)\nx : R\n⊢ Eq ((Localization.localRingHom I J f hIJ) ((algebraMap R (Localization.AtPrime I)) x)) ((algebraMap P (Localization.AtPrime J)) (f x))","decl":"theorem localRingHom_to_map (J : Ideal P) [J.IsPrime] (f : R →+* P) (hIJ : I = J.comap f)\n    (x : R) : localRingHom I J f hIJ (algebraMap _ _ x) = algebraMap _ _ (f x) :=\n  map_eq _ _\n\n"}
{"name":"Localization.localRingHom_mk'","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nP : Type u_3\ninst✝¹ : CommSemiring P\nI : Ideal R\nhI : I.IsPrime\nJ : Ideal P\ninst✝ : J.IsPrime\nf : RingHom R P\nhIJ : Eq I (Ideal.comap f J)\nx : R\ny : Subtype fun x => Membership.mem I.primeCompl x\n⊢ Eq ((Localization.localRingHom I J f hIJ) (IsLocalization.mk' (Localization.AtPrime I) x y)) (IsLocalization.mk' (Localization.AtPrime J) (f x) ⟨f ↑y, ⋯⟩)","decl":"theorem localRingHom_mk' (J : Ideal P) [J.IsPrime] (f : R →+* P) (hIJ : I = J.comap f) (x : R)\n    (y : I.primeCompl) :\n    localRingHom I J f hIJ (IsLocalization.mk' _ x y) =\n      IsLocalization.mk' (Localization.AtPrime J) (f x)\n        (⟨f y, le_comap_primeCompl_iff.mpr (ge_of_eq hIJ) y.2⟩ : J.primeCompl) :=\n  map_mk' _ _ _\n\n"}
{"name":"Localization.isLocalHom_localRingHom","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nP : Type u_3\ninst✝ : CommSemiring P\nI : Ideal R\nhI : I.IsPrime\nJ : Ideal P\nhJ : J.IsPrime\nf : RingHom R P\nhIJ : Eq I (Ideal.comap f J)\n⊢ IsLocalHom (Localization.localRingHom I J f hIJ)","decl":"@[instance]\ntheorem isLocalHom_localRingHom (J : Ideal P) [hJ : J.IsPrime] (f : R →+* P)\n    (hIJ : I = J.comap f) : IsLocalHom (localRingHom I J f hIJ) :=\n  IsLocalHom.mk fun x hx => by\n    rcases IsLocalization.mk'_surjective I.primeCompl x with ⟨r, s, rfl⟩\n    rw [localRingHom_mk'] at hx\n    rw [AtPrime.isUnit_mk'_iff] at hx ⊢\n    exact fun hr => hx ((SetLike.ext_iff.mp hIJ r).mp hr)\n\n"}
{"name":"Localization.isLocalRingHom_localRingHom","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nP : Type u_3\ninst✝ : CommSemiring P\nI : Ideal R\nhI : I.IsPrime\nJ : Ideal P\nhJ : J.IsPrime\nf : RingHom R P\nhIJ : Eq I (Ideal.comap f J)\n⊢ IsLocalHom (Localization.localRingHom I J f hIJ)","decl":"@[deprecated (since := \"2024-10-10\")]\nalias isLocalRingHom_localRingHom := isLocalHom_localRingHom\n\n"}
{"name":"Localization.localRingHom_unique","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nP : Type u_3\ninst✝¹ : CommSemiring P\nI : Ideal R\nhI : I.IsPrime\nJ : Ideal P\ninst✝ : J.IsPrime\nf : RingHom R P\nhIJ : Eq I (Ideal.comap f J)\nj : RingHom (Localization.AtPrime I) (Localization.AtPrime J)\nhj : ∀ (x : R), Eq (j ((algebraMap R (Localization.AtPrime I)) x)) ((algebraMap P (Localization.AtPrime J)) (f x))\n⊢ Eq (Localization.localRingHom I J f hIJ) j","decl":"theorem localRingHom_unique (J : Ideal P) [J.IsPrime] (f : R →+* P) (hIJ : I = J.comap f)\n    {j : Localization.AtPrime I →+* Localization.AtPrime J}\n    (hj : ∀ x : R, j (algebraMap _ _ x) = algebraMap _ _ (f x)) : localRingHom I J f hIJ = j :=\n  map_unique _ _ hj\n\n"}
{"name":"Localization.localRingHom_id","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nI : Ideal R\nhI : I.IsPrime\n⊢ Eq (Localization.localRingHom I I (RingHom.id R) ⋯) (RingHom.id (Localization.AtPrime I))","decl":"@[simp]\ntheorem localRingHom_id : localRingHom I I (RingHom.id R) (Ideal.comap_id I).symm = RingHom.id _ :=\n  localRingHom_unique _ _ _ _ fun _ => rfl\n\n-- Porting note: simplifier won't pick up this lemma, so deleted @[simp]\n"}
{"name":"Localization.localRingHom_comp","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nP : Type u_3\ninst✝¹ : CommSemiring P\nI : Ideal R\nhI : I.IsPrime\nS : Type u_4\ninst✝ : CommSemiring S\nJ : Ideal S\nhJ : J.IsPrime\nK : Ideal P\nhK : K.IsPrime\nf : RingHom R S\nhIJ : Eq I (Ideal.comap f J)\ng : RingHom S P\nhJK : Eq J (Ideal.comap g K)\n⊢ Eq (Localization.localRingHom I K (g.comp f) ⋯) ((Localization.localRingHom J K g hJK).comp (Localization.localRingHom I J f hIJ))","decl":"theorem localRingHom_comp {S : Type*} [CommSemiring S] (J : Ideal S) [hJ : J.IsPrime] (K : Ideal P)\n    [hK : K.IsPrime] (f : R →+* S) (hIJ : I = J.comap f) (g : S →+* P) (hJK : J = K.comap g) :\n    localRingHom I K (g.comp f) (by rw [hIJ, hJK, Ideal.comap_comap f g]) =\n      (localRingHom J K g hJK).comp (localRingHom I J f hIJ) :=\n  localRingHom_unique _ _ _ _ fun r => by\n    simp only [Function.comp_apply, RingHom.coe_comp, localRingHom_to_map]\n\n"}
{"name":"Localization.AtPrime.mapPiEvalRingHom_bijective","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"ι : Type u_4\nR : ι → Type u_5\ninst✝¹ : (i : ι) → CommSemiring (R i)\ni : ι\nI : Ideal (R i)\ninst✝ : I.IsPrime\n⊢ Function.Bijective ⇑(Localization.AtPrime.mapPiEvalRingHom I)","decl":"theorem mapPiEvalRingHom_bijective : Function.Bijective (mapPiEvalRingHom I) :=\n  Localization.mapPiEvalRingHom_bijective _\n\n"}
{"name":"Localization.AtPrime.mapPiEvalRingHom_comp_algebraMap","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"ι : Type u_4\nR : ι → Type u_5\ninst✝¹ : (i : ι) → CommSemiring (R i)\ni : ι\nI : Ideal (R i)\ninst✝ : I.IsPrime\n⊢ Eq ((Localization.AtPrime.mapPiEvalRingHom I).comp (algebraMap ((i : ι) → R i) (Localization.AtPrime (Ideal.comap (Pi.evalRingHom R i) I)))) ((algebraMap (R i) (Localization.AtPrime I)).comp (Pi.evalRingHom R i))","decl":"theorem mapPiEvalRingHom_comp_algebraMap :\n    (mapPiEvalRingHom I).comp (algebraMap _ _) = (algebraMap _ _).comp (Pi.evalRingHom R i) :=\n  IsLocalization.map_comp _\n\n"}
{"name":"Localization.AtPrime.mapPiEvalRingHom_algebraMap_apply","module":"Mathlib.RingTheory.Localization.AtPrime","initialProofState":"ι : Type u_4\nR : ι → Type u_5\ninst✝¹ : (i : ι) → CommSemiring (R i)\ni : ι\nI : Ideal (R i)\ninst✝ : I.IsPrime\nr : (i : ι) → R i\n⊢ Eq ((Localization.AtPrime.mapPiEvalRingHom I) ((algebraMap ((i : ι) → R i) (Localization.AtPrime (Ideal.comap (Pi.evalRingHom R i) I))) r)) ((algebraMap (R i) (Localization.AtPrime I)) (r i))","decl":"theorem mapPiEvalRingHom_algebraMap_apply {r : Π i, R i} :\n    mapPiEvalRingHom I (algebraMap _ _ r) = algebraMap _ _ (r i) :=\n  localRingHom_to_map ..\n\n"}
