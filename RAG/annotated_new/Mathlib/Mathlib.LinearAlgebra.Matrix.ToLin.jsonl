{"name":"Matrix.vecMulLinear_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nm : Type u_3\nn : Type u_4\ninst✝ : Fintype m\nM : Matrix m n R\nx : m → R\n⊢ Eq (M.vecMulLinear x) (Matrix.vecMul x M)","decl":"@[simp] theorem Matrix.vecMulLinear_apply [Fintype m] (M : Matrix m n R) (x : m → R) :\n    M.vecMulLinear x = x ᵥ* M := rfl\n\n"}
{"name":"Matrix.coe_vecMulLinear","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nm : Type u_3\nn : Type u_4\ninst✝ : Fintype m\nM : Matrix m n R\n⊢ Eq ⇑M.vecMulLinear fun v => Matrix.vecMul v M","decl":"theorem Matrix.coe_vecMulLinear [Fintype m] (M : Matrix m n R) :\n    (M.vecMulLinear : _ → _) = M.vecMul := rfl\n\n"}
{"name":"Matrix.vecMul_stdBasis","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nm : Type u_3\nn : Type u_4\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nM : Matrix m n R\ni : m\nj : n\n⊢ Eq (Matrix.vecMul ((LinearMap.stdBasis R (fun x => R) i) 1) M j) (M i j)","decl":"set_option linter.deprecated false in\n@[simp, deprecated Matrix.single_one_vecMul (since := \"2024-08-09\")]\ntheorem Matrix.vecMul_stdBasis [DecidableEq m] (M : Matrix m n R) (i j) :\n    (LinearMap.stdBasis R (fun _ ↦ R) i 1 ᵥ* M) j = M i j :=\n  congr_fun (Matrix.single_one_vecMul ..) j\n\n"}
{"name":"range_vecMulLinear","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\nm : Type u_3\nn : Type u_4\ninst✝ : Fintype m\nM : Matrix m n R\n⊢ Eq (LinearMap.range M.vecMulLinear) (Submodule.span R (Set.range M))","decl":"theorem range_vecMulLinear (M : Matrix m n R) :\n    LinearMap.range M.vecMulLinear = span R (range M) := by\n  letI := Classical.decEq m\n  simp_rw [range_eq_map, ← iSup_range_single, Submodule.map_iSup, range_eq_map, ←\n    Ideal.span_singleton_one, Ideal.span, Submodule.map_span, image_image, image_singleton,\n    Matrix.vecMulLinear_apply, iSup_span, range_eq_iUnion, iUnion_singleton_eq_range,\n    LinearMap.single, LinearMap.coe_mk, AddHom.coe_mk]\n  unfold vecMul\n  simp_rw [single_dotProduct, one_mul]\n\n"}
{"name":"Matrix.vecMul_injective_iff","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"m : Type u_3\nn : Type u_4\ninst✝¹ : Fintype m\nR : Type u_5\ninst✝ : CommRing R\nM : Matrix m n R\n⊢ Iff (Function.Injective fun v => Matrix.vecMul v M) (LinearIndependent R fun i => M i)","decl":"theorem Matrix.vecMul_injective_iff {R : Type*} [CommRing R] {M : Matrix m n R} :\n    Function.Injective M.vecMul ↔ LinearIndependent R (fun i ↦ M i) := by\n  rw [← coe_vecMulLinear]\n  simp only [← LinearMap.ker_eq_bot, Fintype.linearIndependent_iff, Submodule.eq_bot_iff,\n    LinearMap.mem_ker, vecMulLinear_apply]\n  refine ⟨fun h c h0 ↦ congr_fun <| h c ?_, fun h c h0 ↦ funext <| h c ?_⟩\n  · rw [← h0]\n    ext i\n    simp [vecMul, dotProduct]\n  · rw [← h0]\n    ext j\n    simp [vecMul, dotProduct]\n\n"}
{"name":"Matrix.linearIndependent_rows_of_isUnit","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"m : Type u_3\ninst✝² : Fintype m\nR : Type u_5\ninst✝¹ : CommRing R\nA : Matrix m m R\ninst✝ : DecidableEq m\nha : IsUnit A\n⊢ LinearIndependent R fun i => A i","decl":"lemma Matrix.linearIndependent_rows_of_isUnit {R : Type*} [CommRing R] {A : Matrix m m R}\n    [DecidableEq m] (ha : IsUnit A) : LinearIndependent R (fun i ↦ A i) := by\n  rw [← Matrix.vecMul_injective_iff]\n  exact Matrix.vecMul_injective_of_isUnit ha\n\n"}
{"name":"Matrix.toLinearMapRight'_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nm : Type u_3\nn : Type u_4\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nM : Matrix m n R\nv : m → R\n⊢ Eq ((Matrix.toLinearMapRight' M) v) (Matrix.vecMul v M)","decl":"@[simp]\ntheorem Matrix.toLinearMapRight'_apply (M : Matrix m n R) (v : m → R) :\n    (Matrix.toLinearMapRight') M v = v ᵥ* M := rfl\n\n"}
{"name":"Matrix.toLinearMapRight'_mul","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst✝³ : Fintype m\ninst✝² : DecidableEq m\ninst✝¹ : Fintype l\ninst✝ : DecidableEq l\nM : Matrix l m R\nN : Matrix m n R\n⊢ Eq (Matrix.toLinearMapRight' (HMul.hMul M N)) ((Matrix.toLinearMapRight' N).comp (Matrix.toLinearMapRight' M))","decl":"@[simp]\ntheorem Matrix.toLinearMapRight'_mul [Fintype l] [DecidableEq l] (M : Matrix l m R)\n    (N : Matrix m n R) :\n    Matrix.toLinearMapRight' (M * N) =\n      (Matrix.toLinearMapRight' N).comp (Matrix.toLinearMapRight' M) :=\n  LinearMap.ext fun _x ↦ (vecMul_vecMul _ M N).symm\n\n"}
{"name":"Matrix.toLinearMapRight'_mul_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst✝³ : Fintype m\ninst✝² : DecidableEq m\ninst✝¹ : Fintype l\ninst✝ : DecidableEq l\nM : Matrix l m R\nN : Matrix m n R\nx : l → R\n⊢ Eq ((Matrix.toLinearMapRight' (HMul.hMul M N)) x) ((Matrix.toLinearMapRight' N) ((Matrix.toLinearMapRight' M) x))","decl":"theorem Matrix.toLinearMapRight'_mul_apply [Fintype l] [DecidableEq l] (M : Matrix l m R)\n    (N : Matrix m n R) (x) :\n    Matrix.toLinearMapRight' (M * N) x =\n      Matrix.toLinearMapRight' N (Matrix.toLinearMapRight' M x) :=\n  (vecMul_vecMul _ M N).symm\n\n"}
{"name":"Matrix.toLinearMapRight'_one","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : Semiring R\nm : Type u_3\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\n⊢ Eq (Matrix.toLinearMapRight' 1) LinearMap.id","decl":"@[simp]\ntheorem Matrix.toLinearMapRight'_one :\n    Matrix.toLinearMapRight' (1 : Matrix m m R) = LinearMap.id := by\n  ext\n  simp [LinearMap.one_apply]\n\n"}
{"name":"Matrix.toLinearEquivRight'OfInv_symm_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nm : Type u_3\nn : Type u_4\ninst✝³ : Fintype m\ninst✝² : DecidableEq m\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nM : Matrix m n R\nM' : Matrix n m R\nhMM' : Eq (HMul.hMul M M') 1\nhM'M : Eq (HMul.hMul M' M) 1\na : m → R\na✝ : n\n⊢ Eq ((Matrix.toLinearEquivRight'OfInv hMM' hM'M).symm a a✝) ((Matrix.toLinearMapRight' M) a a✝)","decl":"/-- If `M` and `M'` are each other's inverse matrices, they provide an equivalence between `n → A`\nand `m → A` corresponding to `M.vecMul` and `M'.vecMul`. -/\n@[simps]\ndef Matrix.toLinearEquivRight'OfInv [Fintype n] [DecidableEq n] {M : Matrix m n R}\n    {M' : Matrix n m R} (hMM' : M * M' = 1) (hM'M : M' * M = 1) : (n → R) ≃ₗ[R] m → R :=\n  { LinearMap.toMatrixRight'.symm M' with\n    toFun := Matrix.toLinearMapRight' M'\n    invFun := Matrix.toLinearMapRight' M\n    left_inv := fun x ↦ by\n      rw [← Matrix.toLinearMapRight'_mul_apply, hM'M, Matrix.toLinearMapRight'_one, id_apply]\n    right_inv := fun x ↦ by\n      dsimp only -- Porting note: needed due to non-flat structures\n      rw [← Matrix.toLinearMapRight'_mul_apply, hMM', Matrix.toLinearMapRight'_one, id_apply] }\n\n"}
{"name":"Matrix.toLinearEquivRight'OfInv_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : Semiring R\nm : Type u_3\nn : Type u_4\ninst✝³ : Fintype m\ninst✝² : DecidableEq m\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nM : Matrix m n R\nM' : Matrix n m R\nhMM' : Eq (HMul.hMul M M') 1\nhM'M : Eq (HMul.hMul M' M) 1\na : n → R\na✝ : m\n⊢ Eq ((Matrix.toLinearEquivRight'OfInv hMM' hM'M) a a✝) ((Matrix.toLinearMapRight' M') a a✝)","decl":"/-- If `M` and `M'` are each other's inverse matrices, they provide an equivalence between `n → A`\nand `m → A` corresponding to `M.vecMul` and `M'.vecMul`. -/\n@[simps]\ndef Matrix.toLinearEquivRight'OfInv [Fintype n] [DecidableEq n] {M : Matrix m n R}\n    {M' : Matrix n m R} (hMM' : M * M' = 1) (hM'M : M' * M = 1) : (n → R) ≃ₗ[R] m → R :=\n  { LinearMap.toMatrixRight'.symm M' with\n    toFun := Matrix.toLinearMapRight' M'\n    invFun := Matrix.toLinearMapRight' M\n    left_inv := fun x ↦ by\n      rw [← Matrix.toLinearMapRight'_mul_apply, hM'M, Matrix.toLinearMapRight'_one, id_apply]\n    right_inv := fun x ↦ by\n      dsimp only -- Porting note: needed due to non-flat structures\n      rw [← Matrix.toLinearMapRight'_mul_apply, hMM', Matrix.toLinearMapRight'_one, id_apply] }\n\n"}
{"name":"Matrix.coe_mulVecLin","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nm : Type u_4\nn : Type u_5\ninst✝ : Fintype n\nM : Matrix m n R\n⊢ Eq (⇑M.mulVecLin) M.mulVec","decl":"theorem Matrix.coe_mulVecLin [Fintype n] (M : Matrix m n R) :\n    (M.mulVecLin : _ → _) = M.mulVec := rfl\n\n"}
{"name":"Matrix.mulVecLin_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nm : Type u_4\nn : Type u_5\ninst✝ : Fintype n\nM : Matrix m n R\nv : n → R\n⊢ Eq (M.mulVecLin v) (M.mulVec v)","decl":"@[simp]\ntheorem Matrix.mulVecLin_apply [Fintype n] (M : Matrix m n R) (v : n → R) :\n    M.mulVecLin v = M *ᵥ v :=\n  rfl\n\n"}
{"name":"Matrix.mulVecLin_zero","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nm : Type u_4\nn : Type u_5\ninst✝ : Fintype n\n⊢ Eq (Matrix.mulVecLin 0) 0","decl":"@[simp]\ntheorem Matrix.mulVecLin_zero [Fintype n] : Matrix.mulVecLin (0 : Matrix m n R) = 0 :=\n  LinearMap.ext zero_mulVec\n\n"}
{"name":"Matrix.mulVecLin_add","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nm : Type u_4\nn : Type u_5\ninst✝ : Fintype n\nM N : Matrix m n R\n⊢ Eq (HAdd.hAdd M N).mulVecLin (HAdd.hAdd M.mulVecLin N.mulVecLin)","decl":"@[simp]\ntheorem Matrix.mulVecLin_add [Fintype n] (M N : Matrix m n R) :\n    (M + N).mulVecLin = M.mulVecLin + N.mulVecLin :=\n  LinearMap.ext fun _ ↦ add_mulVec _ _ _\n\n"}
{"name":"Matrix.mulVecLin_transpose","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nm : Type u_4\nn : Type u_5\ninst✝ : Fintype m\nM : Matrix m n R\n⊢ Eq M.transpose.mulVecLin M.vecMulLinear","decl":"@[simp] theorem Matrix.mulVecLin_transpose [Fintype m] (M : Matrix m n R) :\n    Mᵀ.mulVecLin = M.vecMulLinear := by\n  ext; simp [mulVec_transpose]\n\n"}
{"name":"Matrix.vecMulLinear_transpose","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nm : Type u_4\nn : Type u_5\ninst✝ : Fintype n\nM : Matrix m n R\n⊢ Eq M.transpose.vecMulLinear M.mulVecLin","decl":"@[simp] theorem Matrix.vecMulLinear_transpose [Fintype n] (M : Matrix m n R) :\n    Mᵀ.vecMulLinear = M.mulVecLin := by\n  ext; simp [vecMul_transpose]\n\n"}
{"name":"Matrix.mulVecLin_submatrix","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nk : Type u_2\nl : Type u_3\nm : Type u_4\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : Fintype l\nf₁ : m → k\ne₂ : Equiv n l\nM : Matrix k l R\n⊢ Eq (M.submatrix f₁ ⇑e₂).mulVecLin ((LinearMap.funLeft R R f₁).comp (M.mulVecLin.comp (LinearMap.funLeft R R ⇑e₂.symm)))","decl":"theorem Matrix.mulVecLin_submatrix [Fintype n] [Fintype l] (f₁ : m → k) (e₂ : n ≃ l)\n    (M : Matrix k l R) :\n    (M.submatrix f₁ e₂).mulVecLin = funLeft R R f₁ ∘ₗ M.mulVecLin ∘ₗ funLeft _ _ e₂.symm :=\n  LinearMap.ext fun _ ↦ submatrix_mulVec_equiv _ _ _ _\n\n"}
{"name":"Matrix.mulVecLin_reindex","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nk : Type u_2\nl : Type u_3\nm : Type u_4\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : Fintype l\ne₁ : Equiv k m\ne₂ : Equiv l n\nM : Matrix k l R\n⊢ Eq ((Matrix.reindex e₁ e₂) M).mulVecLin ((↑(LinearEquiv.funCongrLeft R R e₁.symm)).comp (M.mulVecLin.comp ↑(LinearEquiv.funCongrLeft R R e₂)))","decl":"/-- A variant of `Matrix.mulVecLin_submatrix` that keeps around `LinearEquiv`s. -/\ntheorem Matrix.mulVecLin_reindex [Fintype n] [Fintype l] (e₁ : k ≃ m) (e₂ : l ≃ n)\n    (M : Matrix k l R) :\n    (reindex e₁ e₂ M).mulVecLin =\n      ↑(LinearEquiv.funCongrLeft R R e₁.symm) ∘ₗ\n        M.mulVecLin ∘ₗ ↑(LinearEquiv.funCongrLeft R R e₂) :=\n  Matrix.mulVecLin_submatrix _ _ _\n\n"}
{"name":"Matrix.mulVecLin_one","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\n⊢ Eq (Matrix.mulVecLin 1) LinearMap.id","decl":"@[simp]\ntheorem Matrix.mulVecLin_one [DecidableEq n] :\n    Matrix.mulVecLin (1 : Matrix n n R) = LinearMap.id := by\n  ext; simp [Matrix.one_apply, Pi.single_apply, eq_comm]\n\n"}
{"name":"Matrix.mulVecLin_mul","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nl : Type u_3\nm : Type u_4\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : Fintype m\nM : Matrix l m R\nN : Matrix m n R\n⊢ Eq (HMul.hMul M N).mulVecLin (M.mulVecLin.comp N.mulVecLin)","decl":"@[simp]\ntheorem Matrix.mulVecLin_mul [Fintype m] (M : Matrix l m R) (N : Matrix m n R) :\n    Matrix.mulVecLin (M * N) = (Matrix.mulVecLin M).comp (Matrix.mulVecLin N) :=\n  LinearMap.ext fun _ ↦ (mulVec_mulVec _ _ _).symm\n\n"}
{"name":"Matrix.ker_mulVecLin_eq_bot_iff","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nm : Type u_4\nn : Type u_5\ninst✝ : Fintype n\nM : Matrix m n R\n⊢ Iff (Eq (LinearMap.ker M.mulVecLin) Bot.bot) (∀ (v : n → R), Eq (M.mulVec v) 0 → Eq v 0)","decl":"theorem Matrix.ker_mulVecLin_eq_bot_iff {M : Matrix m n R} :\n    (LinearMap.ker M.mulVecLin) = ⊥ ↔ ∀ v, M *ᵥ v = 0 → v = 0 := by\n  simp only [Submodule.eq_bot_iff, LinearMap.mem_ker, Matrix.mulVecLin_apply]\n\n"}
{"name":"Matrix.mulVec_stdBasis","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nm : Type u_4\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nM : Matrix m n R\ni : m\nj : n\n⊢ Eq (M.mulVec ((LinearMap.stdBasis R (fun x => R) j) 1) i) (M i j)","decl":"set_option linter.deprecated false in\n@[deprecated Matrix.mulVec_single_one (since := \"2024-08-09\")]\ntheorem Matrix.mulVec_stdBasis [DecidableEq n] (M : Matrix m n R) (i j) :\n    (M *ᵥ LinearMap.stdBasis R (fun _ ↦ R) j 1) i = M i j :=\n  congr_fun (Matrix.mulVec_single_one ..) i\n\n"}
{"name":"Matrix.mulVec_stdBasis_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nm : Type u_4\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nM : Matrix m n R\nj : n\n⊢ Eq (M.mulVec ((LinearMap.stdBasis R (fun x => R) j) 1)) (M.transpose j)","decl":"set_option linter.deprecated false in\n@[simp, deprecated Matrix.mulVec_single_one (since := \"2024-08-09\")]\ntheorem Matrix.mulVec_stdBasis_apply [DecidableEq n] (M : Matrix m n R) (j) :\n    M *ᵥ LinearMap.stdBasis R (fun _ ↦ R) j 1 = Mᵀ j :=\n  Matrix.mulVec_single_one ..\n\n"}
{"name":"Matrix.range_mulVecLin","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nm : Type u_4\nn : Type u_5\ninst✝ : Fintype n\nM : Matrix m n R\n⊢ Eq (LinearMap.range M.mulVecLin) (Submodule.span R (Set.range M.transpose))","decl":"theorem Matrix.range_mulVecLin (M : Matrix m n R) :\n    LinearMap.range M.mulVecLin = span R (range Mᵀ) := by\n  rw [← vecMulLinear_transpose, range_vecMulLinear]\n\n"}
{"name":"Matrix.mulVec_injective_iff","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"m : Type u_4\nn : Type u_5\ninst✝¹ : Fintype n\nR : Type u_6\ninst✝ : CommRing R\nM : Matrix m n R\n⊢ Iff (Function.Injective M.mulVec) (LinearIndependent R fun i => M.transpose i)","decl":"theorem Matrix.mulVec_injective_iff {R : Type*} [CommRing R] {M : Matrix m n R} :\n    Function.Injective M.mulVec ↔ LinearIndependent R (fun i ↦ Mᵀ i) := by\n  change Function.Injective (fun x ↦ _) ↔ _\n  simp_rw [← M.vecMul_transpose, vecMul_injective_iff]\n\n"}
{"name":"Matrix.linearIndependent_cols_of_isUnit","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"m : Type u_4\nR : Type u_6\ninst✝² : CommRing R\ninst✝¹ : Fintype m\nA : Matrix m m R\ninst✝ : DecidableEq m\nha : IsUnit A\n⊢ LinearIndependent R fun i => A.transpose i","decl":"lemma Matrix.linearIndependent_cols_of_isUnit {R : Type*} [CommRing R] [Fintype m]\n    {A : Matrix m m R} [DecidableEq m] (ha : IsUnit A) :\n    LinearIndependent R (fun i ↦ A.transpose i) := by\n  rw [← Matrix.mulVec_injective_iff]\n  exact Matrix.mulVec_injective_of_isUnit ha\n\n"}
{"name":"Matrix.toLin'_apply'","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nm : Type u_4\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix m n R\n⊢ Eq (Matrix.toLin' M) M.mulVecLin","decl":"theorem Matrix.toLin'_apply' (M : Matrix m n R) : Matrix.toLin' M = M.mulVecLin :=\n  rfl\n\n"}
{"name":"LinearMap.toMatrix'_symm","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nm : Type u_4\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\n⊢ Eq LinearMap.toMatrix'.symm Matrix.toLin'","decl":"@[simp]\ntheorem LinearMap.toMatrix'_symm :\n    (LinearMap.toMatrix'.symm : Matrix m n R ≃ₗ[R] _) = Matrix.toLin' :=\n  rfl\n\n"}
{"name":"Matrix.toLin'_symm","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nm : Type u_4\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\n⊢ Eq Matrix.toLin'.symm LinearMap.toMatrix'","decl":"@[simp]\ntheorem Matrix.toLin'_symm :\n    (Matrix.toLin'.symm : ((n → R) →ₗ[R] m → R) ≃ₗ[R] _) = LinearMap.toMatrix' :=\n  rfl\n\n"}
{"name":"LinearMap.toMatrix'_toLin'","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nm : Type u_4\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix m n R\n⊢ Eq (LinearMap.toMatrix' (Matrix.toLin' M)) M","decl":"@[simp]\ntheorem LinearMap.toMatrix'_toLin' (M : Matrix m n R) : LinearMap.toMatrix' (Matrix.toLin' M) = M :=\n  LinearMap.toMatrix'.apply_symm_apply M\n\n"}
{"name":"Matrix.toLin'_toMatrix'","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nm : Type u_4\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nf : LinearMap (RingHom.id R) (n → R) (m → R)\n⊢ Eq (Matrix.toLin' (LinearMap.toMatrix' f)) f","decl":"@[simp]\ntheorem Matrix.toLin'_toMatrix' (f : (n → R) →ₗ[R] m → R) :\n    Matrix.toLin' (LinearMap.toMatrix' f) = f :=\n  Matrix.toLin'.apply_symm_apply f\n\n"}
{"name":"LinearMap.toMatrix'_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nm : Type u_4\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nf : LinearMap (RingHom.id R) (n → R) (m → R)\ni : m\nj : n\n⊢ Eq (LinearMap.toMatrix' f i j) (f (fun j' => ite (Eq j' j) 1 0) i)","decl":"@[simp]\ntheorem LinearMap.toMatrix'_apply (f : (n → R) →ₗ[R] m → R) (i j) :\n    LinearMap.toMatrix' f i j = f (fun j' ↦ if j' = j then 1 else 0) i := by\n  simp only [LinearMap.toMatrix', LinearEquiv.coe_mk, of_apply]\n  refine congr_fun ?_ _  -- Porting note: `congr` didn't do this\n  congr\n  ext j'\n  split_ifs with h\n  · rw [h, Pi.single_eq_same]\n  apply Pi.single_eq_of_ne h\n\n"}
{"name":"Matrix.toLin'_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nm : Type u_4\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix m n R\nv : n → R\n⊢ Eq ((Matrix.toLin' M) v) (M.mulVec v)","decl":"@[simp]\ntheorem Matrix.toLin'_apply (M : Matrix m n R) (v : n → R) : Matrix.toLin' M v = M *ᵥ v :=\n  rfl\n\n"}
{"name":"Matrix.toLin'_one","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\n⊢ Eq (Matrix.toLin' 1) LinearMap.id","decl":"@[simp]\ntheorem Matrix.toLin'_one : Matrix.toLin' (1 : Matrix n n R) = LinearMap.id :=\n  Matrix.mulVecLin_one\n\n"}
{"name":"LinearMap.toMatrix'_id","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\n⊢ Eq (LinearMap.toMatrix' LinearMap.id) 1","decl":"@[simp]\ntheorem LinearMap.toMatrix'_id : LinearMap.toMatrix' (LinearMap.id : (n → R) →ₗ[R] n → R) = 1 := by\n  ext\n  rw [Matrix.one_apply, LinearMap.toMatrix'_apply, id_apply]\n\n"}
{"name":"LinearMap.toMatrix'_one","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\n⊢ Eq (LinearMap.toMatrix' 1) 1","decl":"@[simp]\ntheorem LinearMap.toMatrix'_one : LinearMap.toMatrix' (1 : (n → R) →ₗ[R] n → R) = 1 :=\n  LinearMap.toMatrix'_id\n\n"}
{"name":"Matrix.toLin'_mul","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nl : Type u_3\nm : Type u_4\nn : Type u_5\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nM : Matrix l m R\nN : Matrix m n R\n⊢ Eq (Matrix.toLin' (HMul.hMul M N)) ((Matrix.toLin' M).comp (Matrix.toLin' N))","decl":"@[simp]\ntheorem Matrix.toLin'_mul [Fintype m] [DecidableEq m] (M : Matrix l m R) (N : Matrix m n R) :\n    Matrix.toLin' (M * N) = (Matrix.toLin' M).comp (Matrix.toLin' N) :=\n  Matrix.mulVecLin_mul _ _\n\n"}
{"name":"Matrix.toLin'_submatrix","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nk : Type u_2\nl : Type u_3\nm : Type u_4\nn : Type u_5\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : Fintype l\ninst✝ : DecidableEq l\nf₁ : m → k\ne₂ : Equiv n l\nM : Matrix k l R\n⊢ Eq (Matrix.toLin' (M.submatrix f₁ ⇑e₂)) ((LinearMap.funLeft R R f₁).comp ((Matrix.toLin' M).comp (LinearMap.funLeft R R ⇑e₂.symm)))","decl":"@[simp]\ntheorem Matrix.toLin'_submatrix [Fintype l] [DecidableEq l] (f₁ : m → k) (e₂ : n ≃ l)\n    (M : Matrix k l R) :\n    Matrix.toLin' (M.submatrix f₁ e₂) =\n      funLeft R R f₁ ∘ₗ (Matrix.toLin' M) ∘ₗ funLeft _ _ e₂.symm :=\n  Matrix.mulVecLin_submatrix _ _ _\n\n"}
{"name":"Matrix.toLin'_reindex","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nk : Type u_2\nl : Type u_3\nm : Type u_4\nn : Type u_5\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : Fintype l\ninst✝ : DecidableEq l\ne₁ : Equiv k m\ne₂ : Equiv l n\nM : Matrix k l R\n⊢ Eq (Matrix.toLin' ((Matrix.reindex e₁ e₂) M)) ((↑(LinearEquiv.funCongrLeft R R e₁.symm)).comp ((Matrix.toLin' M).comp ↑(LinearEquiv.funCongrLeft R R e₂)))","decl":"/-- A variant of `Matrix.toLin'_submatrix` that keeps around `LinearEquiv`s. -/\ntheorem Matrix.toLin'_reindex [Fintype l] [DecidableEq l] (e₁ : k ≃ m) (e₂ : l ≃ n)\n    (M : Matrix k l R) :\n    Matrix.toLin' (reindex e₁ e₂ M) =\n      ↑(LinearEquiv.funCongrLeft R R e₁.symm) ∘ₗ (Matrix.toLin' M) ∘ₗ\n        ↑(LinearEquiv.funCongrLeft R R e₂) :=\n  Matrix.mulVecLin_reindex _ _ _\n\n"}
{"name":"Matrix.toLin'_mul_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nl : Type u_3\nm : Type u_4\nn : Type u_5\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nM : Matrix l m R\nN : Matrix m n R\nx : n → R\n⊢ Eq ((Matrix.toLin' (HMul.hMul M N)) x) ((Matrix.toLin' M) ((Matrix.toLin' N) x))","decl":"/-- Shortcut lemma for `Matrix.toLin'_mul` and `LinearMap.comp_apply` -/\ntheorem Matrix.toLin'_mul_apply [Fintype m] [DecidableEq m] (M : Matrix l m R) (N : Matrix m n R)\n    (x) : Matrix.toLin' (M * N) x = Matrix.toLin' M (Matrix.toLin' N x) := by\n  rw [Matrix.toLin'_mul, LinearMap.comp_apply]\n\n"}
{"name":"LinearMap.toMatrix'_comp","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nl : Type u_3\nm : Type u_4\nn : Type u_5\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : Fintype l\ninst✝ : DecidableEq l\nf : LinearMap (RingHom.id R) (n → R) (m → R)\ng : LinearMap (RingHom.id R) (l → R) (n → R)\n⊢ Eq (LinearMap.toMatrix' (f.comp g)) (HMul.hMul (LinearMap.toMatrix' f) (LinearMap.toMatrix' g))","decl":"theorem LinearMap.toMatrix'_comp [Fintype l] [DecidableEq l] (f : (n → R) →ₗ[R] m → R)\n    (g : (l → R) →ₗ[R] n → R) :\n    LinearMap.toMatrix' (f.comp g) = LinearMap.toMatrix' f * LinearMap.toMatrix' g := by\n  suffices f.comp g = Matrix.toLin' (LinearMap.toMatrix' f * LinearMap.toMatrix' g) by\n    rw [this, LinearMap.toMatrix'_toLin']\n  rw [Matrix.toLin'_mul, Matrix.toLin'_toMatrix', Matrix.toLin'_toMatrix']\n\n"}
{"name":"LinearMap.toMatrix'_mul","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nm : Type u_4\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nf g : LinearMap (RingHom.id R) (m → R) (m → R)\n⊢ Eq (LinearMap.toMatrix' (HMul.hMul f g)) (HMul.hMul (LinearMap.toMatrix' f) (LinearMap.toMatrix' g))","decl":"theorem LinearMap.toMatrix'_mul [Fintype m] [DecidableEq m] (f g : (m → R) →ₗ[R] m → R) :\n    LinearMap.toMatrix' (f * g) = LinearMap.toMatrix' f * LinearMap.toMatrix' g :=\n  LinearMap.toMatrix'_comp f g\n\n"}
{"name":"LinearMap.toMatrix'_algebraMap","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nx : R\n⊢ Eq (LinearMap.toMatrix' ((algebraMap R (Module.End R (n → R))) x)) ((Matrix.scalar n) x)","decl":"@[simp]\ntheorem LinearMap.toMatrix'_algebraMap (x : R) :\n    LinearMap.toMatrix' (algebraMap R (Module.End R (n → R)) x) = scalar n x := by\n  simp [Module.algebraMap_end_eq_smul_id, smul_eq_diagonal_mul]\n\n"}
{"name":"Matrix.ker_toLin'_eq_bot_iff","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\n⊢ Iff (Eq (LinearMap.ker (Matrix.toLin' M)) Bot.bot) (∀ (v : n → R), Eq (M.mulVec v) 0 → Eq v 0)","decl":"theorem Matrix.ker_toLin'_eq_bot_iff {M : Matrix n n R} :\n    LinearMap.ker (Matrix.toLin' M) = ⊥ ↔ ∀ v, M *ᵥ v = 0 → v = 0 :=\n  Matrix.ker_mulVecLin_eq_bot_iff\n\n"}
{"name":"Matrix.range_toLin'","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nm : Type u_4\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix m n R\n⊢ Eq (LinearMap.range (Matrix.toLin' M)) (Submodule.span R (Set.range M.transpose))","decl":"theorem Matrix.range_toLin' (M : Matrix m n R) :\n    LinearMap.range (Matrix.toLin' M) = span R (range Mᵀ) :=\n  Matrix.range_mulVecLin _\n\n"}
{"name":"Matrix.toLin'OfInv_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nm : Type u_4\nn : Type u_5\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nM : Matrix m n R\nM' : Matrix n m R\nhMM' : Eq (HMul.hMul M M') 1\nhM'M : Eq (HMul.hMul M' M) 1\na : m → R\na✝ : n\n⊢ Eq ((Matrix.toLin'OfInv hMM' hM'M) a a✝) ((Matrix.toLin' M') a a✝)","decl":"/-- If `M` and `M'` are each other's inverse matrices, they provide an equivalence between `m → A`\nand `n → A` corresponding to `M.mulVec` and `M'.mulVec`. -/\n@[simps]\ndef Matrix.toLin'OfInv [Fintype m] [DecidableEq m] {M : Matrix m n R} {M' : Matrix n m R}\n    (hMM' : M * M' = 1) (hM'M : M' * M = 1) : (m → R) ≃ₗ[R] n → R :=\n  { Matrix.toLin' M' with\n    toFun := Matrix.toLin' M'\n    invFun := Matrix.toLin' M\n    left_inv := fun x ↦ by rw [← Matrix.toLin'_mul_apply, hMM', Matrix.toLin'_one, id_apply]\n    right_inv := fun x ↦ by\n      simp only\n      rw [← Matrix.toLin'_mul_apply, hM'M, Matrix.toLin'_one, id_apply] }\n\n"}
{"name":"Matrix.toLin'OfInv_symm_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nm : Type u_4\nn : Type u_5\ninst✝³ : DecidableEq n\ninst✝² : Fintype n\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nM : Matrix m n R\nM' : Matrix n m R\nhMM' : Eq (HMul.hMul M M') 1\nhM'M : Eq (HMul.hMul M' M) 1\na : n → R\na✝ : m\n⊢ Eq ((Matrix.toLin'OfInv hMM' hM'M).symm a a✝) ((Matrix.toLin' M) a a✝)","decl":"/-- If `M` and `M'` are each other's inverse matrices, they provide an equivalence between `m → A`\nand `n → A` corresponding to `M.mulVec` and `M'.mulVec`. -/\n@[simps]\ndef Matrix.toLin'OfInv [Fintype m] [DecidableEq m] {M : Matrix m n R} {M' : Matrix n m R}\n    (hMM' : M * M' = 1) (hM'M : M' * M = 1) : (m → R) ≃ₗ[R] n → R :=\n  { Matrix.toLin' M' with\n    toFun := Matrix.toLin' M'\n    invFun := Matrix.toLin' M\n    left_inv := fun x ↦ by rw [← Matrix.toLin'_mul_apply, hMM', Matrix.toLin'_one, id_apply]\n    right_inv := fun x ↦ by\n      simp only\n      rw [← Matrix.toLin'_mul_apply, hM'M, Matrix.toLin'_one, id_apply] }\n\n"}
{"name":"LinearMap.toMatrixAlgEquiv'_symm","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\n⊢ Eq LinearMap.toMatrixAlgEquiv'.symm Matrix.toLinAlgEquiv'","decl":"@[simp]\ntheorem LinearMap.toMatrixAlgEquiv'_symm :\n    (LinearMap.toMatrixAlgEquiv'.symm : Matrix n n R ≃ₐ[R] _) = Matrix.toLinAlgEquiv' :=\n  rfl\n\n"}
{"name":"Matrix.toLinAlgEquiv'_symm","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\n⊢ Eq Matrix.toLinAlgEquiv'.symm LinearMap.toMatrixAlgEquiv'","decl":"@[simp]\ntheorem Matrix.toLinAlgEquiv'_symm :\n    (Matrix.toLinAlgEquiv'.symm : ((n → R) →ₗ[R] n → R) ≃ₐ[R] _) = LinearMap.toMatrixAlgEquiv' :=\n  rfl\n\n"}
{"name":"LinearMap.toMatrixAlgEquiv'_toLinAlgEquiv'","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\n⊢ Eq (LinearMap.toMatrixAlgEquiv' (Matrix.toLinAlgEquiv' M)) M","decl":"@[simp]\ntheorem LinearMap.toMatrixAlgEquiv'_toLinAlgEquiv' (M : Matrix n n R) :\n    LinearMap.toMatrixAlgEquiv' (Matrix.toLinAlgEquiv' M) = M :=\n  LinearMap.toMatrixAlgEquiv'.apply_symm_apply M\n\n"}
{"name":"Matrix.toLinAlgEquiv'_toMatrixAlgEquiv'","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nf : LinearMap (RingHom.id R) (n → R) (n → R)\n⊢ Eq (Matrix.toLinAlgEquiv' (LinearMap.toMatrixAlgEquiv' f)) f","decl":"@[simp]\ntheorem Matrix.toLinAlgEquiv'_toMatrixAlgEquiv' (f : (n → R) →ₗ[R] n → R) :\n    Matrix.toLinAlgEquiv' (LinearMap.toMatrixAlgEquiv' f) = f :=\n  Matrix.toLinAlgEquiv'.apply_symm_apply f\n\n"}
{"name":"LinearMap.toMatrixAlgEquiv'_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nf : LinearMap (RingHom.id R) (n → R) (n → R)\ni j : n\n⊢ Eq (LinearMap.toMatrixAlgEquiv' f i j) (f (fun j' => ite (Eq j' j) 1 0) i)","decl":"@[simp]\ntheorem LinearMap.toMatrixAlgEquiv'_apply (f : (n → R) →ₗ[R] n → R) (i j) :\n    LinearMap.toMatrixAlgEquiv' f i j = f (fun j' ↦ if j' = j then 1 else 0) i := by\n  simp [LinearMap.toMatrixAlgEquiv']\n\n"}
{"name":"Matrix.toLinAlgEquiv'_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nM : Matrix n n R\nv : n → R\n⊢ Eq ((Matrix.toLinAlgEquiv' M) v) (M.mulVec v)","decl":"@[simp]\ntheorem Matrix.toLinAlgEquiv'_apply (M : Matrix n n R) (v : n → R) :\n    Matrix.toLinAlgEquiv' M v = M *ᵥ v :=\n  rfl\n\n"}
{"name":"Matrix.toLinAlgEquiv'_one","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\n⊢ Eq (Matrix.toLinAlgEquiv' 1) LinearMap.id","decl":"theorem Matrix.toLinAlgEquiv'_one : Matrix.toLinAlgEquiv' (1 : Matrix n n R) = LinearMap.id :=\n  Matrix.toLin'_one\n\n"}
{"name":"LinearMap.toMatrixAlgEquiv'_id","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\n⊢ Eq (LinearMap.toMatrixAlgEquiv' LinearMap.id) 1","decl":"@[simp]\ntheorem LinearMap.toMatrixAlgEquiv'_id :\n    LinearMap.toMatrixAlgEquiv' (LinearMap.id : (n → R) →ₗ[R] n → R) = 1 :=\n  LinearMap.toMatrix'_id\n\n"}
{"name":"LinearMap.toMatrixAlgEquiv'_comp","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nf g : LinearMap (RingHom.id R) (n → R) (n → R)\n⊢ Eq (LinearMap.toMatrixAlgEquiv' (f.comp g)) (HMul.hMul (LinearMap.toMatrixAlgEquiv' f) (LinearMap.toMatrixAlgEquiv' g))","decl":"theorem LinearMap.toMatrixAlgEquiv'_comp (f g : (n → R) →ₗ[R] n → R) :\n    LinearMap.toMatrixAlgEquiv' (f.comp g) =\n      LinearMap.toMatrixAlgEquiv' f * LinearMap.toMatrixAlgEquiv' g :=\n  LinearMap.toMatrix'_comp _ _\n\n"}
{"name":"LinearMap.toMatrixAlgEquiv'_mul","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type u_5\ninst✝¹ : DecidableEq n\ninst✝ : Fintype n\nf g : LinearMap (RingHom.id R) (n → R) (n → R)\n⊢ Eq (LinearMap.toMatrixAlgEquiv' (HMul.hMul f g)) (HMul.hMul (LinearMap.toMatrixAlgEquiv' f) (LinearMap.toMatrixAlgEquiv' g))","decl":"theorem LinearMap.toMatrixAlgEquiv'_mul (f g : (n → R) →ₗ[R] n → R) :\n    LinearMap.toMatrixAlgEquiv' (f * g) =\n      LinearMap.toMatrixAlgEquiv' f * LinearMap.toMatrixAlgEquiv' g :=\n  LinearMap.toMatrixAlgEquiv'_comp f g\n\n"}
{"name":"LinearMap.toMatrix_eq_toMatrix'","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nn : Type u_4\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\n⊢ Eq (LinearMap.toMatrix (Pi.basisFun R n) (Pi.basisFun R n)) LinearMap.toMatrix'","decl":"/-- `LinearMap.toMatrix'` is a particular case of `LinearMap.toMatrix`, for the standard basis\n`Pi.basisFun R n`. -/\ntheorem LinearMap.toMatrix_eq_toMatrix' :\n    LinearMap.toMatrix (Pi.basisFun R n) (Pi.basisFun R n) = LinearMap.toMatrix' :=\n  rfl\n\n"}
{"name":"Matrix.toLin_eq_toLin'","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nm : Type u_3\nn : Type u_4\ninst✝² : Fintype n\ninst✝¹ : Finite m\ninst✝ : DecidableEq n\n⊢ Eq (Matrix.toLin (Pi.basisFun R n) (Pi.basisFun R m)) Matrix.toLin'","decl":"/-- `Matrix.toLin'` is a particular case of `Matrix.toLin`, for the standard basis\n`Pi.basisFun R n`. -/\ntheorem Matrix.toLin_eq_toLin' : Matrix.toLin (Pi.basisFun R n) (Pi.basisFun R m) = Matrix.toLin' :=\n  rfl\n\n"}
{"name":"LinearMap.toMatrix_symm","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nm : Type u_3\nn : Type u_4\ninst✝⁶ : Fintype n\ninst✝⁵ : Finite m\ninst✝⁴ : DecidableEq n\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝³ : AddCommMonoid M₁\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nv₁ : Basis n R M₁\nv₂ : Basis m R M₂\n⊢ Eq (LinearMap.toMatrix v₁ v₂).symm (Matrix.toLin v₁ v₂)","decl":"@[simp]\ntheorem LinearMap.toMatrix_symm : (LinearMap.toMatrix v₁ v₂).symm = Matrix.toLin v₁ v₂ :=\n  rfl\n\n"}
{"name":"Matrix.toLin_symm","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nm : Type u_3\nn : Type u_4\ninst✝⁶ : Fintype n\ninst✝⁵ : Finite m\ninst✝⁴ : DecidableEq n\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝³ : AddCommMonoid M₁\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nv₁ : Basis n R M₁\nv₂ : Basis m R M₂\n⊢ Eq (Matrix.toLin v₁ v₂).symm (LinearMap.toMatrix v₁ v₂)","decl":"@[simp]\ntheorem Matrix.toLin_symm : (Matrix.toLin v₁ v₂).symm = LinearMap.toMatrix v₁ v₂ :=\n  rfl\n\n"}
{"name":"Matrix.toLin_toMatrix","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nm : Type u_3\nn : Type u_4\ninst✝⁶ : Fintype n\ninst✝⁵ : Finite m\ninst✝⁴ : DecidableEq n\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝³ : AddCommMonoid M₁\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nv₁ : Basis n R M₁\nv₂ : Basis m R M₂\nf : LinearMap (RingHom.id R) M₁ M₂\n⊢ Eq ((Matrix.toLin v₁ v₂) ((LinearMap.toMatrix v₁ v₂) f)) f","decl":"@[simp]\ntheorem Matrix.toLin_toMatrix (f : M₁ →ₗ[R] M₂) :\n    Matrix.toLin v₁ v₂ (LinearMap.toMatrix v₁ v₂ f) = f := by\n  rw [← Matrix.toLin_symm, LinearEquiv.apply_symm_apply]\n\n"}
{"name":"LinearMap.toMatrix_toLin","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nm : Type u_3\nn : Type u_4\ninst✝⁶ : Fintype n\ninst✝⁵ : Finite m\ninst✝⁴ : DecidableEq n\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝³ : AddCommMonoid M₁\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nv₁ : Basis n R M₁\nv₂ : Basis m R M₂\nM : Matrix m n R\n⊢ Eq ((LinearMap.toMatrix v₁ v₂) ((Matrix.toLin v₁ v₂) M)) M","decl":"@[simp]\ntheorem LinearMap.toMatrix_toLin (M : Matrix m n R) :\n    LinearMap.toMatrix v₁ v₂ (Matrix.toLin v₁ v₂ M) = M := by\n  rw [← Matrix.toLin_symm, LinearEquiv.symm_apply_apply]\n\n"}
{"name":"LinearMap.toMatrix_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nm : Type u_3\nn : Type u_4\ninst✝⁶ : Fintype n\ninst✝⁵ : Finite m\ninst✝⁴ : DecidableEq n\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝³ : AddCommMonoid M₁\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nv₁ : Basis n R M₁\nv₂ : Basis m R M₂\nf : LinearMap (RingHom.id R) M₁ M₂\ni : m\nj : n\n⊢ Eq ((LinearMap.toMatrix v₁ v₂) f i j) ((v₂.repr (f (v₁ j))) i)","decl":"theorem LinearMap.toMatrix_apply (f : M₁ →ₗ[R] M₂) (i : m) (j : n) :\n    LinearMap.toMatrix v₁ v₂ f i j = v₂.repr (f (v₁ j)) i := by\n  rw [LinearMap.toMatrix, LinearEquiv.trans_apply, LinearMap.toMatrix'_apply,\n    LinearEquiv.arrowCongr_apply, Basis.equivFun_symm_apply, Finset.sum_eq_single j, if_pos rfl,\n    one_smul, Basis.equivFun_apply]\n  · intro j' _ hj'\n    rw [if_neg hj', zero_smul]\n  · intro hj\n    have := Finset.mem_univ j\n    contradiction\n\n"}
{"name":"LinearMap.toMatrix_transpose_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nm : Type u_3\nn : Type u_4\ninst✝⁶ : Fintype n\ninst✝⁵ : Finite m\ninst✝⁴ : DecidableEq n\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝³ : AddCommMonoid M₁\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nv₁ : Basis n R M₁\nv₂ : Basis m R M₂\nf : LinearMap (RingHom.id R) M₁ M₂\nj : n\n⊢ Eq (((LinearMap.toMatrix v₁ v₂) f).transpose j) ⇑(v₂.repr (f (v₁ j)))","decl":"theorem LinearMap.toMatrix_transpose_apply (f : M₁ →ₗ[R] M₂) (j : n) :\n    (LinearMap.toMatrix v₁ v₂ f)ᵀ j = v₂.repr (f (v₁ j)) :=\n  funext fun i ↦ f.toMatrix_apply _ _ i j\n\n"}
{"name":"LinearMap.toMatrix_apply'","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nm : Type u_3\nn : Type u_4\ninst✝⁶ : Fintype n\ninst✝⁵ : Finite m\ninst✝⁴ : DecidableEq n\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝³ : AddCommMonoid M₁\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nv₁ : Basis n R M₁\nv₂ : Basis m R M₂\nf : LinearMap (RingHom.id R) M₁ M₂\ni : m\nj : n\n⊢ Eq ((LinearMap.toMatrix v₁ v₂) f i j) ((v₂.repr (f (v₁ j))) i)","decl":"theorem LinearMap.toMatrix_apply' (f : M₁ →ₗ[R] M₂) (i : m) (j : n) :\n    LinearMap.toMatrix v₁ v₂ f i j = v₂.repr (f (v₁ j)) i :=\n  LinearMap.toMatrix_apply v₁ v₂ f i j\n\n"}
{"name":"LinearMap.toMatrix_transpose_apply'","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nm : Type u_3\nn : Type u_4\ninst✝⁶ : Fintype n\ninst✝⁵ : Finite m\ninst✝⁴ : DecidableEq n\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝³ : AddCommMonoid M₁\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nv₁ : Basis n R M₁\nv₂ : Basis m R M₂\nf : LinearMap (RingHom.id R) M₁ M₂\nj : n\n⊢ Eq (((LinearMap.toMatrix v₁ v₂) f).transpose j) ⇑(v₂.repr (f (v₁ j)))","decl":"theorem LinearMap.toMatrix_transpose_apply' (f : M₁ →ₗ[R] M₂) (j : n) :\n    (LinearMap.toMatrix v₁ v₂ f)ᵀ j = v₂.repr (f (v₁ j)) :=\n  LinearMap.toMatrix_transpose_apply v₁ v₂ f j\n\n"}
{"name":"LinearMap.toMatrix_id","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\n⊢ Eq ((LinearMap.toMatrix v₁ v₁) LinearMap.id) 1","decl":"/-- This will be a special case of `LinearMap.toMatrix_id_eq_basis_toMatrix`. -/\ntheorem LinearMap.toMatrix_id : LinearMap.toMatrix v₁ v₁ id = 1 := by\n  ext i j\n  simp [LinearMap.toMatrix_apply, Matrix.one_apply, Finsupp.single_apply, eq_comm]\n\n"}
{"name":"LinearMap.toMatrix_one","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\n⊢ Eq ((LinearMap.toMatrix v₁ v₁) 1) 1","decl":"@[simp]\ntheorem LinearMap.toMatrix_one : LinearMap.toMatrix v₁ v₁ 1 = 1 :=\n  LinearMap.toMatrix_id v₁\n\n"}
{"name":"LinearMap.toMatrix_singleton","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nι : Type u_7\ninst✝ : Unique ι\nf : LinearMap (RingHom.id R) R R\ni j : ι\n⊢ Eq ((LinearMap.toMatrix (Basis.singleton ι R) (Basis.singleton ι R)) f i j) (f 1)","decl":"@[simp]\nlemma LinearMap.toMatrix_singleton {ι : Type*} [Unique ι] (f : R →ₗ[R] R) (i j : ι) :\n    f.toMatrix (.singleton ι R) (.singleton ι R) i j = f 1 := by\n  simp [toMatrix, Subsingleton.elim j default]\n\n"}
{"name":"Matrix.toLin_one","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\n⊢ Eq ((Matrix.toLin v₁ v₁) 1) LinearMap.id","decl":"@[simp]\ntheorem Matrix.toLin_one : Matrix.toLin v₁ v₁ 1 = LinearMap.id := by\n  rw [← LinearMap.toMatrix_id v₁, Matrix.toLin_toMatrix]\n\n"}
{"name":"LinearMap.toMatrix_reindexRange","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nm : Type u_3\nn : Type u_4\ninst✝⁷ : Fintype n\ninst✝⁶ : Finite m\ninst✝⁵ : DecidableEq n\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\nv₁ : Basis n R M₁\nv₂ : Basis m R M₂\ninst✝ : DecidableEq M₁\nf : LinearMap (RingHom.id R) M₁ M₂\nk : m\ni : n\n⊢ Eq ((LinearMap.toMatrix v₁.reindexRange v₂.reindexRange) f ⟨v₂ k, ⋯⟩ ⟨v₁ i, ⋯⟩) ((LinearMap.toMatrix v₁ v₂) f k i)","decl":"theorem LinearMap.toMatrix_reindexRange [DecidableEq M₁] (f : M₁ →ₗ[R] M₂) (k : m) (i : n) :\n    LinearMap.toMatrix v₁.reindexRange v₂.reindexRange f ⟨v₂ k, Set.mem_range_self k⟩\n        ⟨v₁ i, Set.mem_range_self i⟩ =\n      LinearMap.toMatrix v₁ v₂ f k i := by\n  simp_rw [LinearMap.toMatrix_apply, Basis.reindexRange_self, Basis.reindexRange_repr]\n\n"}
{"name":"LinearMap.toMatrix_algebraMap","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\nx : R\n⊢ Eq ((LinearMap.toMatrix v₁ v₁) ((algebraMap R (Module.End R M₁)) x)) ((Matrix.scalar n) x)","decl":"@[simp]\ntheorem LinearMap.toMatrix_algebraMap (x : R) :\n    LinearMap.toMatrix v₁ v₁ (algebraMap R (Module.End R M₁) x) = scalar n x := by\n  simp [Module.algebraMap_end_eq_smul_id, LinearMap.toMatrix_id, smul_eq_diagonal_mul]\n\n"}
{"name":"LinearMap.toMatrix_mulVec_repr","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nm : Type u_3\nn : Type u_4\ninst✝⁶ : Fintype n\ninst✝⁵ : Finite m\ninst✝⁴ : DecidableEq n\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝³ : AddCommMonoid M₁\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nv₁ : Basis n R M₁\nv₂ : Basis m R M₂\nf : LinearMap (RingHom.id R) M₁ M₂\nx : M₁\n⊢ Eq (((LinearMap.toMatrix v₁ v₂) f).mulVec ⇑(v₁.repr x)) ⇑(v₂.repr (f x))","decl":"theorem LinearMap.toMatrix_mulVec_repr (f : M₁ →ₗ[R] M₂) (x : M₁) :\n    LinearMap.toMatrix v₁ v₂ f *ᵥ v₁.repr x = v₂.repr (f x) := by\n  ext i\n  rw [← Matrix.toLin'_apply, LinearMap.toMatrix, LinearEquiv.trans_apply, Matrix.toLin'_toMatrix',\n    LinearEquiv.arrowCongr_apply, v₂.equivFun_apply]\n  congr\n  exact v₁.equivFun.symm_apply_apply x\n\n"}
{"name":"LinearMap.toMatrix_basis_equiv","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nl : Type u_2\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₁\ninst✝² : Module R M₂\ninst✝¹ : Fintype l\ninst✝ : DecidableEq l\nb : Basis l R M₁\nb' : Basis l R M₂\n⊢ Eq ((LinearMap.toMatrix b' b) ↑(b'.equiv b (Equiv.refl l))) 1","decl":"@[simp]\ntheorem LinearMap.toMatrix_basis_equiv [Fintype l] [DecidableEq l] (b : Basis l R M₁)\n    (b' : Basis l R M₂) :\n    LinearMap.toMatrix b' b (b'.equiv b (Equiv.refl l) : M₂ →ₗ[R] M₁) = 1 := by\n  ext i j\n  simp [LinearMap.toMatrix_apply, Matrix.one_apply, Finsupp.single_apply, eq_comm]\n\n"}
{"name":"LinearMap.toMatrix_smulBasis_left","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nm : Type u_3\nn : Type u_4\ninst✝⁹ : Fintype n\ninst✝⁸ : Finite m\ninst✝⁷ : DecidableEq n\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝⁶ : AddCommMonoid M₁\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M₁\ninst✝³ : Module R M₂\nv₁ : Basis n R M₁\nv₂ : Basis m R M₂\nG : Type u_7\ninst✝² : Group G\ninst✝¹ : DistribMulAction G M₁\ninst✝ : SMulCommClass G R M₁\ng : G\nf : LinearMap (RingHom.id R) M₁ M₂\n⊢ Eq ((LinearMap.toMatrix (HSMul.hSMul g v₁) v₂) f) ((LinearMap.toMatrix v₁ v₂) (f.comp (DistribMulAction.toLinearMap R M₁ g)))","decl":"theorem LinearMap.toMatrix_smulBasis_left {G} [Group G] [DistribMulAction G M₁]\n    [SMulCommClass G R M₁] (g : G) (f : M₁ →ₗ[R] M₂) :\n    LinearMap.toMatrix (g • v₁) v₂ f =\n      LinearMap.toMatrix v₁ v₂ (f ∘ₗ DistribMulAction.toLinearMap _ _ g) := by\n  ext\n  rw [LinearMap.toMatrix_apply, LinearMap.toMatrix_apply]\n  dsimp\n\n"}
{"name":"LinearMap.toMatrix_smulBasis_right","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nm : Type u_3\nn : Type u_4\ninst✝⁹ : Fintype n\ninst✝⁸ : Finite m\ninst✝⁷ : DecidableEq n\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝⁶ : AddCommMonoid M₁\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M₁\ninst✝³ : Module R M₂\nv₁ : Basis n R M₁\nv₂ : Basis m R M₂\nG : Type u_7\ninst✝² : Group G\ninst✝¹ : DistribMulAction G M₂\ninst✝ : SMulCommClass G R M₂\ng : G\nf : LinearMap (RingHom.id R) M₁ M₂\n⊢ Eq ((LinearMap.toMatrix v₁ (HSMul.hSMul g v₂)) f) ((LinearMap.toMatrix v₁ v₂) ((DistribMulAction.toLinearMap R M₂ (Inv.inv g)).comp f))","decl":"theorem LinearMap.toMatrix_smulBasis_right {G} [Group G] [DistribMulAction G M₂]\n    [SMulCommClass G R M₂] (g : G) (f : M₁ →ₗ[R] M₂) :\n    LinearMap.toMatrix v₁ (g • v₂) f =\n      LinearMap.toMatrix v₁ v₂ (DistribMulAction.toLinearMap _ _ g⁻¹ ∘ₗ f) := by\n  ext\n  rw [LinearMap.toMatrix_apply, LinearMap.toMatrix_apply]\n  dsimp\n\n"}
{"name":"Matrix.toLin_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nm : Type u_3\nn : Type u_4\ninst✝⁶ : Fintype n\ninst✝⁵ : Fintype m\ninst✝⁴ : DecidableEq n\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝³ : AddCommMonoid M₁\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nv₁ : Basis n R M₁\nv₂ : Basis m R M₂\nM : Matrix m n R\nv : M₁\n⊢ Eq (((Matrix.toLin v₁ v₂) M) v) (Finset.univ.sum fun j => HSMul.hSMul (M.mulVec (⇑(v₁.repr v)) j) (v₂ j))","decl":"theorem Matrix.toLin_apply (M : Matrix m n R) (v : M₁) :\n    Matrix.toLin v₁ v₂ M v = ∑ j, (M *ᵥ v₁.repr v) j • v₂ j :=\n  show v₂.equivFun.symm (Matrix.toLin' M (v₁.repr v)) = _ by\n    rw [Matrix.toLin'_apply, v₂.equivFun_symm_apply]\n\n"}
{"name":"Matrix.toLin_self","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nm : Type u_3\nn : Type u_4\ninst✝⁶ : Fintype n\ninst✝⁵ : Fintype m\ninst✝⁴ : DecidableEq n\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝³ : AddCommMonoid M₁\ninst✝² : AddCommMonoid M₂\ninst✝¹ : Module R M₁\ninst✝ : Module R M₂\nv₁ : Basis n R M₁\nv₂ : Basis m R M₂\nM : Matrix m n R\ni : n\n⊢ Eq (((Matrix.toLin v₁ v₂) M) (v₁ i)) (Finset.univ.sum fun j => HSMul.hSMul (M j i) (v₂ j))","decl":"@[simp]\ntheorem Matrix.toLin_self (M : Matrix m n R) (i : n) :\n    Matrix.toLin v₁ v₂ M (v₁ i) = ∑ j, M j i • v₂ j := by\n  rw [Matrix.toLin_apply, Finset.sum_congr rfl fun j _hj ↦ ?_]\n  rw [Basis.repr_self, Matrix.mulVec, dotProduct, Finset.sum_eq_single i, Finsupp.single_eq_same,\n    mul_one]\n  · intro i' _ i'_ne\n    rw [Finsupp.single_eq_of_ne i'_ne.symm, mul_zero]\n  · intros\n    have := Finset.mem_univ i\n    contradiction\n\n"}
{"name":"LinearMap.toMatrix_comp","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝¹¹ : CommSemiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst✝¹⁰ : Fintype n\ninst✝⁹ : Fintype m\ninst✝⁸ : DecidableEq n\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : Module R M₁\ninst✝⁴ : Module R M₂\nv₁ : Basis n R M₁\nv₂ : Basis m R M₂\nM₃ : Type u_7\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M₃\nv₃ : Basis l R M₃\ninst✝¹ : Finite l\ninst✝ : DecidableEq m\nf : LinearMap (RingHom.id R) M₂ M₃\ng : LinearMap (RingHom.id R) M₁ M₂\n⊢ Eq ((LinearMap.toMatrix v₁ v₃) (f.comp g)) (HMul.hMul ((LinearMap.toMatrix v₂ v₃) f) ((LinearMap.toMatrix v₁ v₂) g))","decl":"theorem LinearMap.toMatrix_comp [Finite l] [DecidableEq m] (f : M₂ →ₗ[R] M₃) (g : M₁ →ₗ[R] M₂) :\n    LinearMap.toMatrix v₁ v₃ (f.comp g) =\n    LinearMap.toMatrix v₂ v₃ f * LinearMap.toMatrix v₁ v₂ g := by\n  simp_rw [LinearMap.toMatrix, LinearEquiv.trans_apply, LinearEquiv.arrowCongr_comp _ v₂.equivFun,\n    LinearMap.toMatrix'_comp]\n\n"}
{"name":"LinearMap.toMatrix_mul","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\nf g : LinearMap (RingHom.id R) M₁ M₁\n⊢ Eq ((LinearMap.toMatrix v₁ v₁) (HMul.hMul f g)) (HMul.hMul ((LinearMap.toMatrix v₁ v₁) f) ((LinearMap.toMatrix v₁ v₁) g))","decl":"theorem LinearMap.toMatrix_mul (f g : M₁ →ₗ[R] M₁) :\n    LinearMap.toMatrix v₁ v₁ (f * g) = LinearMap.toMatrix v₁ v₁ f * LinearMap.toMatrix v₁ v₁ g := by\n  rw [LinearMap.mul_eq_comp, LinearMap.toMatrix_comp v₁ v₁ v₁ f g]\n\n"}
{"name":"LinearMap.toMatrix_pow","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\nf : LinearMap (RingHom.id R) M₁ M₁\nk : Nat\n⊢ Eq (HPow.hPow ((LinearMap.toMatrix v₁ v₁) f) k) ((LinearMap.toMatrix v₁ v₁) (HPow.hPow f k))","decl":"lemma LinearMap.toMatrix_pow (f : M₁ →ₗ[R] M₁) (k : ℕ) :\n    (toMatrix v₁ v₁ f) ^ k = toMatrix v₁ v₁ (f ^ k) := by\n  induction k with\n  | zero => simp\n  | succ k ih => rw [pow_succ, pow_succ, ih, ← toMatrix_mul]\n\n"}
{"name":"Matrix.toLin_mul","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝¹¹ : CommSemiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst✝¹⁰ : Fintype n\ninst✝⁹ : Fintype m\ninst✝⁸ : DecidableEq n\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : Module R M₁\ninst✝⁴ : Module R M₂\nv₁ : Basis n R M₁\nv₂ : Basis m R M₂\nM₃ : Type u_7\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M₃\nv₃ : Basis l R M₃\ninst✝¹ : Finite l\ninst✝ : DecidableEq m\nA : Matrix l m R\nB : Matrix m n R\n⊢ Eq ((Matrix.toLin v₁ v₃) (HMul.hMul A B)) (((Matrix.toLin v₂ v₃) A).comp ((Matrix.toLin v₁ v₂) B))","decl":"theorem Matrix.toLin_mul [Finite l] [DecidableEq m] (A : Matrix l m R) (B : Matrix m n R) :\n    Matrix.toLin v₁ v₃ (A * B) = (Matrix.toLin v₂ v₃ A).comp (Matrix.toLin v₁ v₂ B) := by\n  apply (LinearMap.toMatrix v₁ v₃).injective\n  haveI : DecidableEq l := fun _ _ ↦ Classical.propDecidable _\n  rw [LinearMap.toMatrix_comp v₁ v₂ v₃]\n  repeat' rw [LinearMap.toMatrix_toLin]\n\n"}
{"name":"Matrix.toLin_mul_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝¹¹ : CommSemiring R\nl : Type u_2\nm : Type u_3\nn : Type u_4\ninst✝¹⁰ : Fintype n\ninst✝⁹ : Fintype m\ninst✝⁸ : DecidableEq n\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : Module R M₁\ninst✝⁴ : Module R M₂\nv₁ : Basis n R M₁\nv₂ : Basis m R M₂\nM₃ : Type u_7\ninst✝³ : AddCommMonoid M₃\ninst✝² : Module R M₃\nv₃ : Basis l R M₃\ninst✝¹ : Finite l\ninst✝ : DecidableEq m\nA : Matrix l m R\nB : Matrix m n R\nx : M₁\n⊢ Eq (((Matrix.toLin v₁ v₃) (HMul.hMul A B)) x) (((Matrix.toLin v₂ v₃) A) (((Matrix.toLin v₁ v₂) B) x))","decl":"/-- Shortcut lemma for `Matrix.toLin_mul` and `LinearMap.comp_apply`. -/\ntheorem Matrix.toLin_mul_apply [Finite l] [DecidableEq m] (A : Matrix l m R) (B : Matrix m n R)\n    (x) : Matrix.toLin v₁ v₃ (A * B) x = (Matrix.toLin v₂ v₃ A) (Matrix.toLin v₁ v₂ B x) := by\n  rw [Matrix.toLin_mul v₁ v₂, LinearMap.comp_apply]\n\n"}
{"name":"Matrix.toLinOfInv_symm_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nm : Type u_3\nn : Type u_4\ninst✝⁷ : Fintype n\ninst✝⁶ : Fintype m\ninst✝⁵ : DecidableEq n\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\nv₁ : Basis n R M₁\nv₂ : Basis m R M₂\ninst✝ : DecidableEq m\nM : Matrix m n R\nM' : Matrix n m R\nhMM' : Eq (HMul.hMul M M') 1\nhM'M : Eq (HMul.hMul M' M) 1\na : M₂\n⊢ Eq ((Matrix.toLinOfInv v₁ v₂ hMM' hM'M).symm a) (((Matrix.toLin v₂ v₁) M') a)","decl":"/-- If `M` and `M` are each other's inverse matrices, `Matrix.toLin M` and `Matrix.toLin M'`\nform a linear equivalence. -/\n@[simps]\ndef Matrix.toLinOfInv [DecidableEq m] {M : Matrix m n R} {M' : Matrix n m R} (hMM' : M * M' = 1)\n    (hM'M : M' * M = 1) : M₁ ≃ₗ[R] M₂ :=\n  { Matrix.toLin v₁ v₂ M with\n    toFun := Matrix.toLin v₁ v₂ M\n    invFun := Matrix.toLin v₂ v₁ M'\n    left_inv := fun x ↦ by rw [← Matrix.toLin_mul_apply, hM'M, Matrix.toLin_one, id_apply]\n    right_inv := fun x ↦ by\n      simp only\n      rw [← Matrix.toLin_mul_apply, hMM', Matrix.toLin_one, id_apply] }\n\n"}
{"name":"Matrix.toLinOfInv_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nm : Type u_3\nn : Type u_4\ninst✝⁷ : Fintype n\ninst✝⁶ : Fintype m\ninst✝⁵ : DecidableEq n\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : AddCommMonoid M₂\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\nv₁ : Basis n R M₁\nv₂ : Basis m R M₂\ninst✝ : DecidableEq m\nM : Matrix m n R\nM' : Matrix n m R\nhMM' : Eq (HMul.hMul M M') 1\nhM'M : Eq (HMul.hMul M' M) 1\na : M₁\n⊢ Eq ((Matrix.toLinOfInv v₁ v₂ hMM' hM'M) a) (((Matrix.toLin v₁ v₂) M) a)","decl":"/-- If `M` and `M` are each other's inverse matrices, `Matrix.toLin M` and `Matrix.toLin M'`\nform a linear equivalence. -/\n@[simps]\ndef Matrix.toLinOfInv [DecidableEq m] {M : Matrix m n R} {M' : Matrix n m R} (hMM' : M * M' = 1)\n    (hM'M : M' * M = 1) : M₁ ≃ₗ[R] M₂ :=\n  { Matrix.toLin v₁ v₂ M with\n    toFun := Matrix.toLin v₁ v₂ M\n    invFun := Matrix.toLin v₂ v₁ M'\n    left_inv := fun x ↦ by rw [← Matrix.toLin_mul_apply, hM'M, Matrix.toLin_one, id_apply]\n    right_inv := fun x ↦ by\n      simp only\n      rw [← Matrix.toLin_mul_apply, hMM', Matrix.toLin_one, id_apply] }\n\n"}
{"name":"LinearMap.toMatrixAlgEquiv_symm","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\n⊢ Eq (LinearMap.toMatrixAlgEquiv v₁).symm (Matrix.toLinAlgEquiv v₁)","decl":"@[simp]\ntheorem LinearMap.toMatrixAlgEquiv_symm :\n    (LinearMap.toMatrixAlgEquiv v₁).symm = Matrix.toLinAlgEquiv v₁ :=\n  rfl\n\n"}
{"name":"Matrix.toLinAlgEquiv_symm","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\n⊢ Eq (Matrix.toLinAlgEquiv v₁).symm (LinearMap.toMatrixAlgEquiv v₁)","decl":"@[simp]\ntheorem Matrix.toLinAlgEquiv_symm :\n    (Matrix.toLinAlgEquiv v₁).symm = LinearMap.toMatrixAlgEquiv v₁ :=\n  rfl\n\n"}
{"name":"Matrix.toLinAlgEquiv_toMatrixAlgEquiv","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\nf : LinearMap (RingHom.id R) M₁ M₁\n⊢ Eq ((Matrix.toLinAlgEquiv v₁) ((LinearMap.toMatrixAlgEquiv v₁) f)) f","decl":"@[simp]\ntheorem Matrix.toLinAlgEquiv_toMatrixAlgEquiv (f : M₁ →ₗ[R] M₁) :\n    Matrix.toLinAlgEquiv v₁ (LinearMap.toMatrixAlgEquiv v₁ f) = f := by\n  rw [← Matrix.toLinAlgEquiv_symm, AlgEquiv.apply_symm_apply]\n\n"}
{"name":"LinearMap.toMatrixAlgEquiv_toLinAlgEquiv","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\nM : Matrix n n R\n⊢ Eq ((LinearMap.toMatrixAlgEquiv v₁) ((Matrix.toLinAlgEquiv v₁) M)) M","decl":"@[simp]\ntheorem LinearMap.toMatrixAlgEquiv_toLinAlgEquiv (M : Matrix n n R) :\n    LinearMap.toMatrixAlgEquiv v₁ (Matrix.toLinAlgEquiv v₁ M) = M := by\n  rw [← Matrix.toLinAlgEquiv_symm, AlgEquiv.symm_apply_apply]\n\n"}
{"name":"LinearMap.toMatrixAlgEquiv_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\nf : LinearMap (RingHom.id R) M₁ M₁\ni j : n\n⊢ Eq ((LinearMap.toMatrixAlgEquiv v₁) f i j) ((v₁.repr (f (v₁ j))) i)","decl":"theorem LinearMap.toMatrixAlgEquiv_apply (f : M₁ →ₗ[R] M₁) (i j : n) :\n    LinearMap.toMatrixAlgEquiv v₁ f i j = v₁.repr (f (v₁ j)) i := by\n  simp [LinearMap.toMatrixAlgEquiv, LinearMap.toMatrix_apply]\n\n"}
{"name":"LinearMap.toMatrixAlgEquiv_transpose_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\nf : LinearMap (RingHom.id R) M₁ M₁\nj : n\n⊢ Eq (((LinearMap.toMatrixAlgEquiv v₁) f).transpose j) ⇑(v₁.repr (f (v₁ j)))","decl":"theorem LinearMap.toMatrixAlgEquiv_transpose_apply (f : M₁ →ₗ[R] M₁) (j : n) :\n    (LinearMap.toMatrixAlgEquiv v₁ f)ᵀ j = v₁.repr (f (v₁ j)) :=\n  funext fun i ↦ f.toMatrix_apply _ _ i j\n\n"}
{"name":"LinearMap.toMatrixAlgEquiv_apply'","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\nf : LinearMap (RingHom.id R) M₁ M₁\ni j : n\n⊢ Eq ((LinearMap.toMatrixAlgEquiv v₁) f i j) ((v₁.repr (f (v₁ j))) i)","decl":"theorem LinearMap.toMatrixAlgEquiv_apply' (f : M₁ →ₗ[R] M₁) (i j : n) :\n    LinearMap.toMatrixAlgEquiv v₁ f i j = v₁.repr (f (v₁ j)) i :=\n  LinearMap.toMatrixAlgEquiv_apply v₁ f i j\n\n"}
{"name":"LinearMap.toMatrixAlgEquiv_transpose_apply'","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\nf : LinearMap (RingHom.id R) M₁ M₁\nj : n\n⊢ Eq (((LinearMap.toMatrixAlgEquiv v₁) f).transpose j) ⇑(v₁.repr (f (v₁ j)))","decl":"theorem LinearMap.toMatrixAlgEquiv_transpose_apply' (f : M₁ →ₗ[R] M₁) (j : n) :\n    (LinearMap.toMatrixAlgEquiv v₁ f)ᵀ j = v₁.repr (f (v₁ j)) :=\n  LinearMap.toMatrixAlgEquiv_transpose_apply v₁ f j\n\n"}
{"name":"Matrix.toLinAlgEquiv_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\nM : Matrix n n R\nv : M₁\n⊢ Eq (((Matrix.toLinAlgEquiv v₁) M) v) (Finset.univ.sum fun j => HSMul.hSMul (M.mulVec (⇑(v₁.repr v)) j) (v₁ j))","decl":"theorem Matrix.toLinAlgEquiv_apply (M : Matrix n n R) (v : M₁) :\n    Matrix.toLinAlgEquiv v₁ M v = ∑ j, (M *ᵥ v₁.repr v) j • v₁ j :=\n  show v₁.equivFun.symm (Matrix.toLinAlgEquiv' M (v₁.repr v)) = _ by\n    rw [Matrix.toLinAlgEquiv'_apply, v₁.equivFun_symm_apply]\n\n"}
{"name":"Matrix.toLinAlgEquiv_self","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\nM : Matrix n n R\ni : n\n⊢ Eq (((Matrix.toLinAlgEquiv v₁) M) (v₁ i)) (Finset.univ.sum fun j => HSMul.hSMul (M j i) (v₁ j))","decl":"@[simp]\ntheorem Matrix.toLinAlgEquiv_self (M : Matrix n n R) (i : n) :\n    Matrix.toLinAlgEquiv v₁ M (v₁ i) = ∑ j, M j i • v₁ j :=\n  Matrix.toLin_self _ _ _ _\n\n"}
{"name":"LinearMap.toMatrixAlgEquiv_id","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\n⊢ Eq ((LinearMap.toMatrixAlgEquiv v₁) LinearMap.id) 1","decl":"theorem LinearMap.toMatrixAlgEquiv_id : LinearMap.toMatrixAlgEquiv v₁ id = 1 := by\n  simp_rw [LinearMap.toMatrixAlgEquiv, AlgEquiv.ofLinearEquiv_apply, LinearMap.toMatrix_id]\n\n"}
{"name":"Matrix.toLinAlgEquiv_one","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\n⊢ Eq ((Matrix.toLinAlgEquiv v₁) 1) LinearMap.id","decl":"theorem Matrix.toLinAlgEquiv_one : Matrix.toLinAlgEquiv v₁ 1 = LinearMap.id := by\n  rw [← LinearMap.toMatrixAlgEquiv_id v₁, Matrix.toLinAlgEquiv_toMatrixAlgEquiv]\n\n"}
{"name":"LinearMap.toMatrixAlgEquiv_reindexRange","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nn : Type u_4\ninst✝⁴ : Fintype n\ninst✝³ : DecidableEq n\nM₁ : Type u_5\ninst✝² : AddCommMonoid M₁\ninst✝¹ : Module R M₁\nv₁ : Basis n R M₁\ninst✝ : DecidableEq M₁\nf : LinearMap (RingHom.id R) M₁ M₁\nk i : n\n⊢ Eq ((LinearMap.toMatrixAlgEquiv v₁.reindexRange) f ⟨v₁ k, ⋯⟩ ⟨v₁ i, ⋯⟩) ((LinearMap.toMatrixAlgEquiv v₁) f k i)","decl":"theorem LinearMap.toMatrixAlgEquiv_reindexRange [DecidableEq M₁] (f : M₁ →ₗ[R] M₁) (k i : n) :\n    LinearMap.toMatrixAlgEquiv v₁.reindexRange f\n        ⟨v₁ k, Set.mem_range_self k⟩ ⟨v₁ i, Set.mem_range_self i⟩ =\n      LinearMap.toMatrixAlgEquiv v₁ f k i := by\n  simp_rw [LinearMap.toMatrixAlgEquiv_apply, Basis.reindexRange_self, Basis.reindexRange_repr]\n\n"}
{"name":"LinearMap.toMatrixAlgEquiv_comp","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\nf g : LinearMap (RingHom.id R) M₁ M₁\n⊢ Eq ((LinearMap.toMatrixAlgEquiv v₁) (f.comp g)) (HMul.hMul ((LinearMap.toMatrixAlgEquiv v₁) f) ((LinearMap.toMatrixAlgEquiv v₁) g))","decl":"theorem LinearMap.toMatrixAlgEquiv_comp (f g : M₁ →ₗ[R] M₁) :\n    LinearMap.toMatrixAlgEquiv v₁ (f.comp g) =\n      LinearMap.toMatrixAlgEquiv v₁ f * LinearMap.toMatrixAlgEquiv v₁ g := by\n  simp [LinearMap.toMatrixAlgEquiv, LinearMap.toMatrix_comp v₁ v₁ v₁ f g]\n\n"}
{"name":"LinearMap.toMatrixAlgEquiv_mul","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\nf g : LinearMap (RingHom.id R) M₁ M₁\n⊢ Eq ((LinearMap.toMatrixAlgEquiv v₁) (HMul.hMul f g)) (HMul.hMul ((LinearMap.toMatrixAlgEquiv v₁) f) ((LinearMap.toMatrixAlgEquiv v₁) g))","decl":"theorem LinearMap.toMatrixAlgEquiv_mul (f g : M₁ →ₗ[R] M₁) :\n    LinearMap.toMatrixAlgEquiv v₁ (f * g) =\n      LinearMap.toMatrixAlgEquiv v₁ f * LinearMap.toMatrixAlgEquiv v₁ g := by\n  rw [LinearMap.mul_eq_comp, LinearMap.toMatrixAlgEquiv_comp v₁ f g]\n\n"}
{"name":"Matrix.toLinAlgEquiv_mul","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\nA B : Matrix n n R\n⊢ Eq ((Matrix.toLinAlgEquiv v₁) (HMul.hMul A B)) (((Matrix.toLinAlgEquiv v₁) A).comp ((Matrix.toLinAlgEquiv v₁) B))","decl":"theorem Matrix.toLinAlgEquiv_mul (A B : Matrix n n R) :\n    Matrix.toLinAlgEquiv v₁ (A * B) =\n      (Matrix.toLinAlgEquiv v₁ A).comp (Matrix.toLinAlgEquiv v₁ B) := by\n  convert Matrix.toLin_mul v₁ v₁ v₁ A B\n\n"}
{"name":"Matrix.toLin_finTwoProd_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\na b c d : R\nx : Prod R R\n⊢ Eq (((Matrix.toLin (Basis.finTwoProd R) (Basis.finTwoProd R)) (Matrix.of (Matrix.vecCons (Matrix.vecCons a (Matrix.vecCons b Matrix.vecEmpty)) (Matrix.vecCons (Matrix.vecCons c (Matrix.vecCons d Matrix.vecEmpty)) Matrix.vecEmpty)))) x) { fst := HAdd.hAdd (HMul.hMul a x.1) (HMul.hMul b x.2), snd := HAdd.hAdd (HMul.hMul c x.1) (HMul.hMul d x.2) }","decl":"@[simp]\ntheorem Matrix.toLin_finTwoProd_apply (a b c d : R) (x : R × R) :\n    Matrix.toLin (Basis.finTwoProd R) (Basis.finTwoProd R) !![a, b; c, d] x =\n      (a * x.fst + b * x.snd, c * x.fst + d * x.snd) := by\n  simp [Matrix.toLin_apply, Matrix.mulVec, dotProduct]\n\n"}
{"name":"Matrix.toLin_finTwoProd","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\na b c d : R\n⊢ Eq ((Matrix.toLin (Basis.finTwoProd R) (Basis.finTwoProd R)) (Matrix.of (Matrix.vecCons (Matrix.vecCons a (Matrix.vecCons b Matrix.vecEmpty)) (Matrix.vecCons (Matrix.vecCons c (Matrix.vecCons d Matrix.vecEmpty)) Matrix.vecEmpty)))) ((HAdd.hAdd (HSMul.hSMul a (LinearMap.fst R R R)) (HSMul.hSMul b (LinearMap.snd R R R))).prod (HAdd.hAdd (HSMul.hSMul c (LinearMap.fst R R R)) (HSMul.hSMul d (LinearMap.snd R R R))))","decl":"theorem Matrix.toLin_finTwoProd (a b c d : R) :\n    Matrix.toLin (Basis.finTwoProd R) (Basis.finTwoProd R) !![a, b; c, d] =\n      (a • LinearMap.fst R R R + b • LinearMap.snd R R R).prod\n        (c • LinearMap.fst R R R + d • LinearMap.snd R R R) :=\n  LinearMap.ext <| Matrix.toLin_finTwoProd_apply _ _ _ _\n\n"}
{"name":"toMatrix_distrib_mul_action_toLinearMap","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nn : Type u_4\ninst✝³ : Fintype n\ninst✝² : DecidableEq n\nM₁ : Type u_5\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\nv₁ : Basis n R M₁\nx : R\n⊢ Eq ((LinearMap.toMatrix v₁ v₁) (DistribMulAction.toLinearMap R M₁ x)) (Matrix.diagonal fun x_1 => x)","decl":"@[simp]\ntheorem toMatrix_distrib_mul_action_toLinearMap (x : R) :\n    LinearMap.toMatrix v₁ v₁ (DistribMulAction.toLinearMap R M₁ x) =\n    Matrix.diagonal fun _ ↦ x := by\n  ext\n  rw [LinearMap.toMatrix_apply, DistribMulAction.toLinearMap_apply, LinearEquiv.map_smul,\n    Basis.repr_self, Finsupp.smul_single_one, Finsupp.single_eq_pi_single, Matrix.diagonal_apply,\n    Pi.single_apply]\n\n"}
{"name":"LinearMap.toMatrix_prodMap","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝⁹ : CommSemiring R\nm : Type u_3\nn : Type u_4\ninst✝⁸ : Fintype n\ninst✝⁷ : Fintype m\ninst✝⁶ : DecidableEq n\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₁\ninst✝² : Module R M₂\nv₁ : Basis n R M₁\nv₂ : Basis m R M₂\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq (Sum n m)\nφ₁ : Module.End R M₁\nφ₂ : Module.End R M₂\n⊢ Eq ((LinearMap.toMatrix (v₁.prod v₂) (v₁.prod v₂)) (LinearMap.prodMap φ₁ φ₂)) (Matrix.fromBlocks ((LinearMap.toMatrix v₁ v₁) φ₁) 0 0 ((LinearMap.toMatrix v₂ v₂) φ₂))","decl":"lemma LinearMap.toMatrix_prodMap [DecidableEq m] [DecidableEq (n ⊕ m)]\n    (φ₁ : Module.End R M₁) (φ₂ : Module.End R M₂) :\n    toMatrix (v₁.prod v₂) (v₁.prod v₂) (φ₁.prodMap φ₂) =\n      Matrix.fromBlocks (toMatrix v₁ v₁ φ₁) 0 0 (toMatrix v₂ v₂ φ₂) := by\n  ext (i|i) (j|j) <;> simp [toMatrix]\n\n"}
{"name":"Algebra.toMatrix_lmul'","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring S\ninst✝² : Algebra R S\nm : Type u_3\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nb : Basis m R S\nx : S\ni j : m\n⊢ Eq ((LinearMap.toMatrix b b) ((Algebra.lmul R S) x) i j) ((b.repr (HMul.hMul x (b j))) i)","decl":"theorem toMatrix_lmul' (x : S) (i j) :\n    LinearMap.toMatrix b b (lmul R S x) i j = b.repr (x * b j) i := by\n  simp only [LinearMap.toMatrix_apply', coe_lmul_eq_mul, LinearMap.mul_apply']\n\n"}
{"name":"Algebra.toMatrix_lsmul","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring S\ninst✝² : Algebra R S\nm : Type u_3\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nb : Basis m R S\nx : R\n⊢ Eq ((LinearMap.toMatrix b b) ((Algebra.lsmul R R S) x)) (Matrix.diagonal fun x_1 => x)","decl":"@[simp]\ntheorem toMatrix_lsmul (x : R) :\n    LinearMap.toMatrix b b (Algebra.lsmul R R S x) = Matrix.diagonal fun _ ↦ x :=\n  toMatrix_distrib_mul_action_toLinearMap b x\n\n"}
{"name":"Algebra.leftMulMatrix_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring S\ninst✝² : Algebra R S\nm : Type u_3\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nb : Basis m R S\nx : S\n⊢ Eq ((Algebra.leftMulMatrix b) x) ((LinearMap.toMatrix b b) ((Algebra.lmul R S) x))","decl":"theorem leftMulMatrix_apply (x : S) : leftMulMatrix b x = LinearMap.toMatrix b b (lmul R S x) :=\n  rfl\n\n"}
{"name":"Algebra.leftMulMatrix_eq_repr_mul","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring S\ninst✝² : Algebra R S\nm : Type u_3\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nb : Basis m R S\nx : S\ni j : m\n⊢ Eq ((Algebra.leftMulMatrix b) x i j) ((b.repr (HMul.hMul x (b j))) i)","decl":"theorem leftMulMatrix_eq_repr_mul (x : S) (i j) : leftMulMatrix b x i j = b.repr (x * b j) i := by\n  -- This is defeq to just `toMatrix_lmul' b x i j`,\n  -- but the unfolding goes a lot faster with this explicit `rw`.\n  rw [leftMulMatrix_apply, toMatrix_lmul' b x i j]\n\n"}
{"name":"Algebra.leftMulMatrix_mulVec_repr","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring S\ninst✝² : Algebra R S\nm : Type u_3\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nb : Basis m R S\nx y : S\n⊢ Eq (((Algebra.leftMulMatrix b) x).mulVec ⇑(b.repr y)) ⇑(b.repr (HMul.hMul x y))","decl":"theorem leftMulMatrix_mulVec_repr (x y : S) :\n    leftMulMatrix b x *ᵥ b.repr y = b.repr (x * y) :=\n  (LinearMap.mulLeft R x).toMatrix_mulVec_repr b b y\n\n"}
{"name":"Algebra.toMatrix_lmul_eq","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring S\ninst✝² : Algebra R S\nm : Type u_3\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nb : Basis m R S\nx : S\n⊢ Eq ((LinearMap.toMatrix b b) (LinearMap.mulLeft R x)) ((Algebra.leftMulMatrix b) x)","decl":"@[simp]\ntheorem toMatrix_lmul_eq (x : S) :\n    LinearMap.toMatrix b b (LinearMap.mulLeft R x) = leftMulMatrix b x :=\n  rfl\n\n"}
{"name":"Algebra.leftMulMatrix_injective","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring S\ninst✝² : Algebra R S\nm : Type u_3\ninst✝¹ : Fintype m\ninst✝ : DecidableEq m\nb : Basis m R S\n⊢ Function.Injective ⇑(Algebra.leftMulMatrix b)","decl":"theorem leftMulMatrix_injective : Function.Injective (leftMulMatrix b) := fun x x' h ↦\n  calc\n    x = Algebra.lmul R S x 1 := (mul_one x).symm\n    _ = Algebra.lmul R S x' 1 := by rw [(LinearMap.toMatrix b b).injective h]\n    _ = x' := mul_one x'\n\n"}
{"name":"Algebra.smul_leftMulMatrix","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁸ : CommSemiring R\ninst✝⁷ : Semiring S\ninst✝⁶ : Algebra R S\nm : Type u_3\ninst✝⁵ : Fintype m\ninst✝⁴ : DecidableEq m\nb : Basis m R S\nG : Type u_4\ninst✝³ : Group G\ninst✝² : DistribMulAction G S\ninst✝¹ : SMulCommClass G R S\ninst✝ : SMulCommClass G S S\ng : G\nx : S\n⊢ Eq ((Algebra.leftMulMatrix (HSMul.hSMul g b)) x) ((Algebra.leftMulMatrix b) x)","decl":"@[simp]\ntheorem smul_leftMulMatrix {G} [Group G] [DistribMulAction G S]\n    [SMulCommClass G R S] [SMulCommClass G S S] (g : G) (x) :\n    leftMulMatrix (g • b) x = leftMulMatrix b x := by\n  ext\n  simp_rw [leftMulMatrix_apply, LinearMap.toMatrix_apply, coe_lmul_eq_mul, LinearMap.mul_apply',\n    Basis.repr_smul, Basis.smul_apply, LinearEquiv.trans_apply,\n    DistribMulAction.toLinearEquiv_symm_apply, mul_smul_comm, inv_smul_smul]\n\n"}
{"name":"LinearMap.restrictScalars_toMatrix","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nm : Type u_3\ninst✝⁹ : Fintype m\ninst✝⁸ : DecidableEq m\nA : Type u_4\nM : Type u_5\nn : Type u_6\ninst✝⁷ : Fintype n\ninst✝⁶ : DecidableEq n\ninst✝⁵ : CommSemiring A\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Module A M\ninst✝¹ : Algebra R A\ninst✝ : IsScalarTower R A M\nbA : Basis m R A\nbM : Basis n A M\nf : LinearMap (RingHom.id A) M M\n⊢ Eq ((LinearMap.toMatrix (bA.smulTower' bM) (bA.smulTower' bM)) (↑R f)) ((Matrix.comp n n m m R) (((LinearMap.toMatrix bM bM) f).map ⇑(Algebra.leftMulMatrix bA)))","decl":"lemma _root_.LinearMap.restrictScalars_toMatrix (f : M →ₗ[A] M) :\n    (f.restrictScalars R).toMatrix (bA.smulTower' bM) (bA.smulTower' bM) =\n      ((f.toMatrix bM bM).map (leftMulMatrix bA)).comp _ _ _ _ _ := by\n  ext; simp [toMatrix, Basis.repr, Algebra.leftMulMatrix_apply,\n    Basis.smulTower'_repr, Basis.smulTower'_apply, mul_comm]\n\n"}
{"name":"Algebra.smulTower_leftMulMatrix","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Semiring T\ninst✝⁷ : Algebra R S\ninst✝⁶ : Algebra S T\ninst✝⁵ : Algebra R T\ninst✝⁴ : IsScalarTower R S T\nm : Type u_4\nn : Type u_5\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq n\nb : Basis m R S\nc : Basis n S T\nx : T\nik jk : Prod m n\n⊢ Eq ((Algebra.leftMulMatrix (b.smulTower c)) x ik jk) ((Algebra.leftMulMatrix b) ((Algebra.leftMulMatrix c) x ik.2 jk.2) ik.1 jk.1)","decl":"theorem smulTower_leftMulMatrix (x) (ik jk) :\n    leftMulMatrix (b.smulTower c) x ik jk =\n      leftMulMatrix b (leftMulMatrix c x ik.2 jk.2) ik.1 jk.1 := by\n  simp only [leftMulMatrix_apply, LinearMap.toMatrix_apply, mul_comm, Basis.smulTower_apply,\n    Basis.smulTower_repr, Finsupp.smul_apply, id.smul_eq_mul, LinearEquiv.map_smul, mul_smul_comm,\n    coe_lmul_eq_mul, LinearMap.mul_apply']\n\n"}
{"name":"Algebra.smulTower_leftMulMatrix_algebraMap","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Semiring T\ninst✝⁷ : Algebra R S\ninst✝⁶ : Algebra S T\ninst✝⁵ : Algebra R T\ninst✝⁴ : IsScalarTower R S T\nm : Type u_4\nn : Type u_5\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq n\nb : Basis m R S\nc : Basis n S T\nx : S\n⊢ Eq ((Algebra.leftMulMatrix (b.smulTower c)) ((algebraMap S T) x)) (Matrix.blockDiagonal fun x_1 => (Algebra.leftMulMatrix b) x)","decl":"theorem smulTower_leftMulMatrix_algebraMap (x : S) :\n    leftMulMatrix (b.smulTower c) (algebraMap _ _ x) = blockDiagonal fun _ ↦ leftMulMatrix b x := by\n  ext ⟨i, k⟩ ⟨j, k'⟩\n  rw [smulTower_leftMulMatrix, AlgHom.commutes, blockDiagonal_apply, algebraMap_matrix_apply]\n  split_ifs with h <;> simp only at h <;> simp [h]\n\n"}
{"name":"Algebra.smulTower_leftMulMatrix_algebraMap_eq","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Semiring T\ninst✝⁷ : Algebra R S\ninst✝⁶ : Algebra S T\ninst✝⁵ : Algebra R T\ninst✝⁴ : IsScalarTower R S T\nm : Type u_4\nn : Type u_5\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq n\nb : Basis m R S\nc : Basis n S T\nx : S\ni j : m\nk : n\n⊢ Eq ((Algebra.leftMulMatrix (b.smulTower c)) ((algebraMap S T) x) { fst := i, snd := k } { fst := j, snd := k }) ((Algebra.leftMulMatrix b) x i j)","decl":"theorem smulTower_leftMulMatrix_algebraMap_eq (x : S) (i j k) :\n    leftMulMatrix (b.smulTower c) (algebraMap _ _ x) (i, k) (j, k) = leftMulMatrix b x i j := by\n  rw [smulTower_leftMulMatrix_algebraMap, blockDiagonal_apply_eq]\n\n"}
{"name":"Algebra.smulTower_leftMulMatrix_algebraMap_ne","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\nS : Type u_2\nT : Type u_3\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Semiring T\ninst✝⁷ : Algebra R S\ninst✝⁶ : Algebra S T\ninst✝⁵ : Algebra R T\ninst✝⁴ : IsScalarTower R S T\nm : Type u_4\nn : Type u_5\ninst✝³ : Fintype m\ninst✝² : Fintype n\ninst✝¹ : DecidableEq m\ninst✝ : DecidableEq n\nb : Basis m R S\nc : Basis n S T\nx : S\ni j : m\nk k' : n\nh : Ne k k'\n⊢ Eq ((Algebra.leftMulMatrix (b.smulTower c)) ((algebraMap S T) x) { fst := i, snd := k } { fst := j, snd := k' }) 0","decl":"theorem smulTower_leftMulMatrix_algebraMap_ne (x : S) (i j) {k k'} (h : k ≠ k') :\n    leftMulMatrix (b.smulTower c) (algebraMap _ _ x) (i, k) (j, k') = 0 := by\n  rw [smulTower_leftMulMatrix_algebraMap, blockDiagonal_apply_ne _ _ _ h]\n\n"}
{"name":"Basis.linearMap_repr_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\nM₁ : Type u_3\nM₂ : Type u_4\nι₁ : Type u_6\nι₂ : Type u_7\ninst✝⁷ : CommSemiring R\ninst✝⁶ : AddCommMonoid M₁\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M₁\ninst✝³ : Module R M₂\ninst✝² : Fintype ι₁\ninst✝¹ : Fintype ι₂\ninst✝ : DecidableEq ι₁\nb₁ : Basis ι₁ R M₁\nb₂ : Basis ι₂ R M₂\na✝ : LinearMap (RingHom.id R) M₁ M₂\n⊢ Eq ((b₁.linearMap b₂).repr a✝) ((Matrix.stdBasis R ι₂ ι₁).repr ((LinearMap.toMatrix b₁ b₂) a✝))","decl":"/-- The standard basis of the space linear maps between two modules\ninduced by a basis of the domain and codomain.\n\nIf `M₁` and `M₂` are modules with basis `b₁` and `b₂` respectively indexed\nby finite types `ι₁` and `ι₂`,\nthen `Basis.linearMap b₁ b₂` is the basis of `M₁ →ₗ[R] M₂` indexed by `ι₂ × ι₁`\nwhere `(i, j)` indexes the linear map that sends `b j` to `b i`\nand sends all other basis vectors to `0`. -/\n@[simps! (config := .lemmasOnly) repr_apply repr_symm_apply]\nnoncomputable\ndef linearMap (b₁ : Basis ι₁ R M₁) (b₂ : Basis ι₂ R M₂) :\n    Basis (ι₂ × ι₁) R (M₁ →ₗ[R] M₂) :=\n  (Matrix.stdBasis R ι₂ ι₁).map (LinearMap.toMatrix b₁ b₂).symm\n\n"}
{"name":"Basis.linearMap_repr_symm_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\nM₁ : Type u_3\nM₂ : Type u_4\nι₁ : Type u_6\nι₂ : Type u_7\ninst✝⁷ : CommSemiring R\ninst✝⁶ : AddCommMonoid M₁\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M₁\ninst✝³ : Module R M₂\ninst✝² : Fintype ι₁\ninst✝¹ : Fintype ι₂\ninst✝ : DecidableEq ι₁\nb₁ : Basis ι₁ R M₁\nb₂ : Basis ι₂ R M₂\na✝ : Finsupp (Prod ι₂ ι₁) R\n⊢ Eq ((b₁.linearMap b₂).repr.symm a✝) ((Matrix.toLin b₁ b₂) ((Finsupp.linearCombination R ⇑(Matrix.stdBasis R ι₂ ι₁)) a✝))","decl":"/-- The standard basis of the space linear maps between two modules\ninduced by a basis of the domain and codomain.\n\nIf `M₁` and `M₂` are modules with basis `b₁` and `b₂` respectively indexed\nby finite types `ι₁` and `ι₂`,\nthen `Basis.linearMap b₁ b₂` is the basis of `M₁ →ₗ[R] M₂` indexed by `ι₂ × ι₁`\nwhere `(i, j)` indexes the linear map that sends `b j` to `b i`\nand sends all other basis vectors to `0`. -/\n@[simps! (config := .lemmasOnly) repr_apply repr_symm_apply]\nnoncomputable\ndef linearMap (b₁ : Basis ι₁ R M₁) (b₂ : Basis ι₂ R M₂) :\n    Basis (ι₂ × ι₁) R (M₁ →ₗ[R] M₂) :=\n  (Matrix.stdBasis R ι₂ ι₁).map (LinearMap.toMatrix b₁ b₂).symm\n\n"}
{"name":"Basis.linearMap_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\nM₁ : Type u_3\nM₂ : Type u_4\nι₁ : Type u_6\nι₂ : Type u_7\ninst✝⁷ : CommSemiring R\ninst✝⁶ : AddCommMonoid M₁\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M₁\ninst✝³ : Module R M₂\ninst✝² : Fintype ι₁\ninst✝¹ : Fintype ι₂\ninst✝ : DecidableEq ι₁\nb₁ : Basis ι₁ R M₁\nb₂ : Basis ι₂ R M₂\nij : Prod ι₂ ι₁\n⊢ Eq ((b₁.linearMap b₂) ij) ((Matrix.toLin b₁ b₂) ((Matrix.stdBasis R ι₂ ι₁) ij))","decl":"lemma linearMap_apply (ij : ι₂ × ι₁) :\n    (b₁.linearMap b₂ ij) = (Matrix.toLin b₁ b₂) (Matrix.stdBasis R ι₂ ι₁ ij) := by\n  simp [linearMap]\n\n"}
{"name":"Basis.linearMap_apply_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\nM₁ : Type u_3\nM₂ : Type u_4\nι₁ : Type u_6\nι₂ : Type u_7\ninst✝⁷ : CommSemiring R\ninst✝⁶ : AddCommMonoid M₁\ninst✝⁵ : AddCommMonoid M₂\ninst✝⁴ : Module R M₁\ninst✝³ : Module R M₂\ninst✝² : Fintype ι₁\ninst✝¹ : Fintype ι₂\ninst✝ : DecidableEq ι₁\nb₁ : Basis ι₁ R M₁\nb₂ : Basis ι₂ R M₂\nij : Prod ι₂ ι₁\nk : ι₁\n⊢ Eq (((b₁.linearMap b₂) ij) (b₁ k)) (ite (Eq ij.2 k) (b₂ ij.1) 0)","decl":"lemma linearMap_apply_apply (ij : ι₂ × ι₁) (k : ι₁) :\n    (b₁.linearMap b₂ ij) (b₁ k) = if ij.2 = k then b₂ ij.1 else 0 := by\n  have := Classical.decEq ι₂\n  rw [linearMap_apply, Matrix.stdBasis_eq_stdBasisMatrix, Matrix.toLin_self]\n  dsimp only [Matrix.stdBasisMatrix, of_apply]\n  simp_rw [ite_smul, one_smul, zero_smul, ite_and, Finset.sum_ite_eq, Finset.mem_univ, if_true]\n\n"}
{"name":"Basis.end_repr_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nb : Basis ι R M\na✝ : LinearMap (RingHom.id R) M M\n⊢ Eq (b.end.repr a✝) ((Matrix.stdBasis R ι ι).repr ((LinearMap.toMatrix b b) a✝))","decl":"/-- The standard basis of the endomorphism algebra of a module\ninduced by a basis of the module.\n\nIf `M` is a module with basis `b` indexed by a finite type `ι`,\nthen `Basis.end b` is the basis of `Module.End R M` indexed by `ι × ι`\nwhere `(i, j)` indexes the linear map that sends `b j` to `b i`\nand sends all other basis vectors to `0`. -/\n@[simps! (config := .lemmasOnly) repr_apply repr_symm_apply]\nnoncomputable\nabbrev _root_.Basis.end (b : Basis ι R M) : Basis (ι × ι) R (Module.End R M) :=\n  b.linearMap b\n\n"}
{"name":"Basis.end_repr_symm_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nb : Basis ι R M\na✝ : Finsupp (Prod ι ι) R\n⊢ Eq (b.end.repr.symm a✝) ((Matrix.toLin b b) ((Finsupp.linearCombination R ⇑(Matrix.stdBasis R ι ι)) a✝))","decl":"/-- The standard basis of the endomorphism algebra of a module\ninduced by a basis of the module.\n\nIf `M` is a module with basis `b` indexed by a finite type `ι`,\nthen `Basis.end b` is the basis of `Module.End R M` indexed by `ι × ι`\nwhere `(i, j)` indexes the linear map that sends `b j` to `b i`\nand sends all other basis vectors to `0`. -/\n@[simps! (config := .lemmasOnly) repr_apply repr_symm_apply]\nnoncomputable\nabbrev _root_.Basis.end (b : Basis ι R M) : Basis (ι × ι) R (Module.End R M) :=\n  b.linearMap b\n\n"}
{"name":"Basis.end_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nb : Basis ι R M\nij : Prod ι ι\n⊢ Eq (b.end ij) ((Matrix.toLin b b) ((Matrix.stdBasis R ι ι) ij))","decl":"lemma end_apply (ij : ι × ι) : (b.end ij) = (Matrix.toLin b b) (Matrix.stdBasis R ι ι ij) :=\n  linearMap_apply b b ij\n\n"}
{"name":"Basis.end_apply_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"R : Type u_1\nM : Type u_2\nι : Type u_5\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nb : Basis ι R M\nij : Prod ι ι\nk : ι\n⊢ Eq ((b.end ij) (b k)) (ite (Eq ij.2 k) (b ij.1) 0)","decl":"lemma end_apply_apply (ij : ι × ι) (k : ι) : (b.end ij) (b k) = if ij.2 = k then b ij.1 else 0 :=\n  linearMap_apply_apply b b ij k\n\n"}
{"name":"endVecAlgEquivMatrixEnd_apply_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"ι : Type u_1\ninst✝⁸ : Fintype ι\ninst✝⁷ : DecidableEq ι\nR : Type u_2\ninst✝⁶ : CommSemiring R\nA : Type u_3\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\nM : Type u_4\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nf : Module.End A (ι → M)\ni j : ι\nx : M\n⊢ Eq (((endVecAlgEquivMatrixEnd ι R A M) f i j) x) (f (Pi.single j x) i)","decl":"/--\nLet `M` be an `A`-module. Every `A`-linear map `Mⁿ → Mⁿ` corresponds to a `n×n`-matrix whose entries\nare `R`-linear maps `M → M`. In another word, we have`End(Mⁿ) ≅ Matₙₓₙ(End(M))` defined by:\n`(f : Mⁿ → Mⁿ) ↦ (x ↦ f (0, ..., x at j-th position, ..., 0) i)ᵢⱼ` and\n`m : Matₙₓₙ(End(M)) ↦ (v ↦ ∑ⱼ mᵢⱼ(vⱼ))`.\n\nSee also `LinearMap.toMatrix'`\n-/\n@[simps!]\ndef endVecAlgEquivMatrixEnd :\n    Module.End A (ι → M) ≃ₐ[R] Matrix ι ι (Module.End A M) where\n  __ := endVecRingEquivMatrixEnd ι A M\n  commutes' r := by\n    ext\n    simp only [endVecRingEquivMatrixEnd, RingEquiv.toEquiv_eq_coe, Module.algebraMap_end_eq_smul_id,\n      Equiv.toFun_as_coe, EquivLike.coe_coe, RingEquiv.coe_mk, Equiv.coe_fn_mk,\n      LinearMap.smul_apply, id_coe, id_eq, Pi.smul_apply, Pi.single_apply, smul_ite, smul_zero,\n      LinearMap.coe_mk, AddHom.coe_mk, algebraMap_matrix_apply]\n    split_ifs <;> rfl\n\n"}
{"name":"endVecAlgEquivMatrixEnd_symm_apply_apply","module":"Mathlib.LinearAlgebra.Matrix.ToLin","initialProofState":"ι : Type u_1\ninst✝⁸ : Fintype ι\ninst✝⁷ : DecidableEq ι\nR : Type u_2\ninst✝⁶ : CommSemiring R\nA : Type u_3\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra R A\nM : Type u_4\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nm : Matrix ι ι (Module.End A M)\nx : ι → M\ni : ι\n⊢ Eq (((endVecAlgEquivMatrixEnd ι R A M).symm m) x i) (Finset.univ.sum fun j => (m i j) (x j))","decl":"/--\nLet `M` be an `A`-module. Every `A`-linear map `Mⁿ → Mⁿ` corresponds to a `n×n`-matrix whose entries\nare `R`-linear maps `M → M`. In another word, we have`End(Mⁿ) ≅ Matₙₓₙ(End(M))` defined by:\n`(f : Mⁿ → Mⁿ) ↦ (x ↦ f (0, ..., x at j-th position, ..., 0) i)ᵢⱼ` and\n`m : Matₙₓₙ(End(M)) ↦ (v ↦ ∑ⱼ mᵢⱼ(vⱼ))`.\n\nSee also `LinearMap.toMatrix'`\n-/\n@[simps!]\ndef endVecAlgEquivMatrixEnd :\n    Module.End A (ι → M) ≃ₐ[R] Matrix ι ι (Module.End A M) where\n  __ := endVecRingEquivMatrixEnd ι A M\n  commutes' r := by\n    ext\n    simp only [endVecRingEquivMatrixEnd, RingEquiv.toEquiv_eq_coe, Module.algebraMap_end_eq_smul_id,\n      Equiv.toFun_as_coe, EquivLike.coe_coe, RingEquiv.coe_mk, Equiv.coe_fn_mk,\n      LinearMap.smul_apply, id_coe, id_eq, Pi.smul_apply, Pi.single_apply, smul_ite, smul_zero,\n      LinearMap.coe_mk, AddHom.coe_mk, algebraMap_matrix_apply]\n    split_ifs <;> rfl\n\n"}
