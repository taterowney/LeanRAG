{"name":"BddAbove.range_comp_of_nonneg","module":"Mathlib.Algebra.Order.GroupWithZero.Bounds","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : Nonempty α\ninst✝² : Preorder β\ninst✝¹ : Zero β\ninst✝ : Preorder γ\nf : α → β\ng : β → γ\nhf : BddAbove (Set.range f)\nhf0 : LE.le 0 f\nhg : MonotoneOn g (setOf fun x => LE.le 0 x)\n⊢ BddAbove (Set.range fun x => g (f x))","decl":"/-- A variant of `BddAbove.range_comp` that assumes that `f` is nonnegative and `g` is monotone on\n  nonnegative values. -/\nlemma BddAbove.range_comp_of_nonneg {α β γ : Type*} [Nonempty α] [Preorder β] [Zero β] [Preorder γ]\n    {f : α → β} {g : β → γ} (hf : BddAbove (range f)) (hf0 : 0 ≤ f)\n    (hg : MonotoneOn g {x : β | 0 ≤ x}) : BddAbove (range (fun x => g (f x))) := by\n  have hg' : BddAbove (g '' (range f)) := by\n    apply hg.map_bddAbove (by rintro x ⟨a, rfl⟩; exact hf0 a)\n    · obtain ⟨b, hb⟩ := hf\n      use b, hb\n      simp only [mem_upperBounds, mem_range, forall_exists_index, forall_apply_eq_imp_iff] at hb\n      exact le_trans (hf0 Classical.ofNonempty) (hb Classical.ofNonempty)\n  change BddAbove (range (g ∘ f))\n  simpa only [Set.range_comp] using hg'\n\n"}
{"name":"bddAbove_range_mul","module":"Mathlib.Algebra.Order.GroupWithZero.Bounds","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁵ : Nonempty α\nu v : α → β\ninst✝⁴ : Preorder β\ninst✝³ : Zero β\ninst✝² : Mul β\ninst✝¹ : PosMulMono β\ninst✝ : MulPosMono β\nhu : BddAbove (Set.range u)\nhu0 : LE.le 0 u\nhv : BddAbove (Set.range v)\nhv0 : LE.le 0 v\n⊢ BddAbove (Set.range (HMul.hMul u v))","decl":"/-- If `u v : α → β` are nonnegative and bounded above, then `u * v` is bounded above. -/\ntheorem bddAbove_range_mul {α β : Type*} [Nonempty α] {u v : α → β} [Preorder β] [Zero β] [Mul β]\n    [PosMulMono β] [MulPosMono β] (hu : BddAbove (Set.range u)) (hu0 : 0 ≤ u)\n    (hv : BddAbove (Set.range v)) (hv0 : 0 ≤ v) : BddAbove (Set.range (u * v)) :=\n  letI : Zero (β × β) := ⟨(0, 0)⟩\n  BddAbove.range_comp_of_nonneg (f := fun i ↦ (u i, v i)) (g := fun x ↦ x.1 * x.2)\n    (bddAbove_range_prod.mpr ⟨hu, hv⟩) (fun x ↦ ⟨hu0 x, hv0 x⟩) ((monotone_fst.monotoneOn _).mul\n      (monotone_snd.monotoneOn _) (fun _ hx ↦ hx.1) (fun _ hx ↦ hx.2))\n"}
