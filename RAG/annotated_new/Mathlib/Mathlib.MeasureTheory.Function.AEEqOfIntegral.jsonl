{"name":"MeasureTheory.ae_eq_zero_of_forall_inner","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"Î± : Type u_1\nE : Type u_2\nğ•œ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : SecondCountableTopology E\nf : Î± â†’ E\nhf : âˆ€ (c : E), (MeasureTheory.ae Î¼).EventuallyEq (fun x => Inner.inner c (f x)) 0\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq f 0","decl":"theorem ae_eq_zero_of_forall_inner [NormedAddCommGroup E] [InnerProductSpace ğ•œ E]\n    [SecondCountableTopology E] {f : Î± â†’ E} (hf : âˆ€ c : E, (fun x => (inner c (f x) : ğ•œ)) =áµ[Î¼] 0) :\n    f =áµ[Î¼] 0 := by\n  let s := denseSeq E\n  have hs : DenseRange s := denseRange_denseSeq E\n  have hf' : âˆ€áµ x âˆ‚Î¼, âˆ€ n : â„•, inner (s n) (f x) = (0 : ğ•œ) := ae_all_iff.mpr fun n => hf (s n)\n  refine hf'.mono fun x hx => ?_\n  rw [Pi.zero_apply, â† @inner_self_eq_zero ğ•œ]\n  have h_closed : IsClosed {c : E | inner c (f x) = (0 : ğ•œ)} :=\n    isClosed_eq (continuous_id.inner continuous_const) continuous_const\n  exact @isClosed_property â„• E _ s (fun c => inner c (f x) = (0 : ğ•œ)) hs h_closed hx _\n\n"}
{"name":"MeasureTheory.ae_eq_zero_of_forall_dual_of_isSeparable","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"Î± : Type u_1\nE : Type u_2\nğ•œ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : RCLike ğ•œ\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nt : Set E\nht : TopologicalSpace.IsSeparable t\nf : Î± â†’ E\nhf : âˆ€ (c : NormedSpace.Dual ğ•œ E), (MeasureTheory.ae Î¼).EventuallyEq (fun x => c (f x)) 0\nh't : Filter.Eventually (fun x => Membership.mem t (f x)) (MeasureTheory.ae Î¼)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq f 0","decl":"theorem ae_eq_zero_of_forall_dual_of_isSeparable [NormedAddCommGroup E] [NormedSpace ğ•œ E]\n    {t : Set E} (ht : TopologicalSpace.IsSeparable t) {f : Î± â†’ E}\n    (hf : âˆ€ c : Dual ğ•œ E, (fun x => âŸªf x, câŸ«) =áµ[Î¼] 0) (h't : âˆ€áµ x âˆ‚Î¼, f x âˆˆ t) : f =áµ[Î¼] 0 := by\n  rcases ht with âŸ¨d, d_count, hdâŸ©\n  haveI : Encodable d := d_count.toEncodable\n  have : âˆ€ x : d, âˆƒ g : E â†’L[ğ•œ] ğ•œ, â€–gâ€– â‰¤ 1 âˆ§ g x = â€–(x : E)â€– :=\n    fun x => exists_dual_vector'' ğ•œ (x : E)\n  choose s hs using this\n  have A : âˆ€ a : E, a âˆˆ t â†’ (âˆ€ x, âŸªa, s xâŸ« = (0 : ğ•œ)) â†’ a = 0 := by\n    intro a hat ha\n    contrapose! ha\n    have a_pos : 0 < â€–aâ€– := by simp only [ha, norm_pos_iff, Ne, not_false_iff]\n    have a_mem : a âˆˆ closure d := hd hat\n    obtain âŸ¨x, hxâŸ© : âˆƒ x : d, dist a x < â€–aâ€– / 2 := by\n      rcases Metric.mem_closure_iff.1 a_mem (â€–aâ€– / 2) (half_pos a_pos) with âŸ¨x, h'x, hxâŸ©\n      exact âŸ¨âŸ¨x, h'xâŸ©, hxâŸ©\n    use x\n    have I : â€–aâ€– / 2 < â€–(x : E)â€– := by\n      have : â€–aâ€– â‰¤ â€–(x : E)â€– + â€–a - xâ€– := norm_le_insert' _ _\n      have : â€–a - xâ€– < â€–aâ€– / 2 := by rwa [dist_eq_norm] at hx\n      linarith\n    intro h\n    apply lt_irrefl â€–s x xâ€–\n    calc\n      â€–s x xâ€– = â€–s x (x - a)â€– := by simp only [h, sub_zero, ContinuousLinearMap.map_sub]\n      _ â‰¤ 1 * â€–(x : E) - aâ€– := ContinuousLinearMap.le_of_opNorm_le _ (hs x).1 _\n      _ < â€–aâ€– / 2 := by rw [one_mul]; rwa [dist_eq_norm'] at hx\n      _ < â€–(x : E)â€– := I\n      _ = â€–s x xâ€– := by rw [(hs x).2, RCLike.norm_coe_norm]\n  have hfs : âˆ€ y : d, âˆ€áµ x âˆ‚Î¼, âŸªf x, s yâŸ« = (0 : ğ•œ) := fun y => hf (s y)\n  have hf' : âˆ€áµ x âˆ‚Î¼, âˆ€ y : d, âŸªf x, s yâŸ« = (0 : ğ•œ) := by rwa [ae_all_iff]\n  filter_upwards [hf', h't] with x hx h'x\n  exact A (f x) h'x hx\n\n"}
{"name":"MeasureTheory.ae_eq_zero_of_forall_dual","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"Î± : Type u_1\nE : Type u_2\nğ•œ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : SecondCountableTopology E\nf : Î± â†’ E\nhf : âˆ€ (c : NormedSpace.Dual ğ•œ E), (MeasureTheory.ae Î¼).EventuallyEq (fun x => c (f x)) 0\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq f 0","decl":"theorem ae_eq_zero_of_forall_dual [NormedAddCommGroup E] [NormedSpace ğ•œ E]\n    [SecondCountableTopology E] {f : Î± â†’ E} (hf : âˆ€ c : Dual ğ•œ E, (fun x => âŸªf x, câŸ«) =áµ[Î¼] 0) :\n    f =áµ[Î¼] 0 :=\n  ae_eq_zero_of_forall_dual_of_isSeparable ğ•œ (.of_separableSpace Set.univ) hf\n    (Eventually.of_forall fun _ => Set.mem_univ _)\n\n"}
{"name":"MeasureTheory.ae_nonneg_of_forall_setIntegral_nonneg","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : MeasureTheory.Integrable f Î¼\nhf_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ LE.le 0 (MeasureTheory.integral (Î¼.restrict s) fun x => f x)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyLE 0 f","decl":"theorem ae_nonneg_of_forall_setIntegral_nonneg (hf : Integrable f Î¼)\n    (hf_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ 0 â‰¤ âˆ« x in s, f x âˆ‚Î¼) : 0 â‰¤áµ[Î¼] f := by\n  simp_rw [EventuallyLE, Pi.zero_apply]\n  rw [ae_const_le_iff_forall_lt_measure_zero]\n  intro b hb_neg\n  let s := {x | f x â‰¤ b}\n  have hs : NullMeasurableSet s Î¼ := nullMeasurableSet_le hf.1.aemeasurable aemeasurable_const\n  have mus : Î¼ s < âˆ := Integrable.measure_le_lt_top hf hb_neg\n  have h_int_gt : (âˆ« x in s, f x âˆ‚Î¼) â‰¤ b * (Î¼ s).toReal := by\n    have h_const_le : (âˆ« x in s, f x âˆ‚Î¼) â‰¤ âˆ« _ in s, b âˆ‚Î¼ := by\n      refine setIntegral_mono_ae_restrict hf.integrableOn (integrableOn_const.mpr (Or.inr mus)) ?_\n      rw [EventuallyLE, ae_restrict_iffâ‚€ (hs.mono Î¼.restrict_le_self)]\n      exact Eventually.of_forall fun x hxs => hxs\n    rwa [setIntegral_const, smul_eq_mul, mul_comm] at h_const_le\n  contrapose! h_int_gt with H\n  calc\n    b * (Î¼ s).toReal < 0 := mul_neg_of_neg_of_pos hb_neg <| ENNReal.toReal_pos H mus.ne\n    _ â‰¤ âˆ« x in s, f x âˆ‚Î¼ := by\n      rw [â† Î¼.restrict_toMeasurable mus.ne]\n      exact hf_zero _ (measurableSet_toMeasurable ..) (by rwa [measure_toMeasurable])\n\n"}
{"name":"MeasureTheory.ae_le_of_forall_setIntegral_le","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ Real\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nhf_le : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ LE.le (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => g x)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyLE f g","decl":"theorem ae_le_of_forall_setIntegral_le {f g : Î± â†’ â„} (hf : Integrable f Î¼) (hg : Integrable g Î¼)\n    (hf_le : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ (âˆ« x in s, f x âˆ‚Î¼) â‰¤ âˆ« x in s, g x âˆ‚Î¼) :\n    f â‰¤áµ[Î¼] g := by\n  rw [â† eventually_sub_nonneg]\n  refine ae_nonneg_of_forall_setIntegral_nonneg (hg.sub hf) fun s hs => ?_\n  rw [integral_sub' hg.integrableOn hf.integrableOn, sub_nonneg]\n  exact hf_le s hs\n\n"}
{"name":"MeasureTheory.ae_nonneg_restrict_of_forall_setIntegral_nonneg_inter","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nt : Set Î±\nhf : MeasureTheory.IntegrableOn f t Î¼\nhf_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ (Inter.inter s t)) Top.top â†’ LE.le 0 (MeasureTheory.integral (Î¼.restrict (Inter.inter s t)) fun x => f x)\nâŠ¢ (MeasureTheory.ae (Î¼.restrict t)).EventuallyLE 0 f","decl":"theorem ae_nonneg_restrict_of_forall_setIntegral_nonneg_inter {f : Î± â†’ â„} {t : Set Î±}\n    (hf : IntegrableOn f t Î¼)\n    (hf_zero : âˆ€ s, MeasurableSet s â†’ Î¼ (s âˆ© t) < âˆ â†’ 0 â‰¤ âˆ« x in s âˆ© t, f x âˆ‚Î¼) :\n    0 â‰¤áµ[Î¼.restrict t] f := by\n  refine ae_nonneg_of_forall_setIntegral_nonneg hf fun s hs h's => ?_\n  simp_rw [Measure.restrict_restrict hs]\n  apply hf_zero s hs\n  rwa [Measure.restrict_apply hs] at h's\n\n"}
{"name":"MeasureTheory.ae_nonneg_of_forall_setIntegral_nonneg_of_sigmaFinite","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.SigmaFinite Î¼\nf : Î± â†’ Real\nhf_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn f s Î¼\nhf_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ LE.le 0 (MeasureTheory.integral (Î¼.restrict s) fun x => f x)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyLE 0 f","decl":"theorem ae_nonneg_of_forall_setIntegral_nonneg_of_sigmaFinite [SigmaFinite Î¼] {f : Î± â†’ â„}\n    (hf_int_finite : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ IntegrableOn f s Î¼)\n    (hf_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ 0 â‰¤ âˆ« x in s, f x âˆ‚Î¼) : 0 â‰¤áµ[Î¼] f := by\n  apply ae_of_forall_measure_lt_top_ae_restrict\n  intro t t_meas t_lt_top\n  apply ae_nonneg_restrict_of_forall_setIntegral_nonneg_inter (hf_int_finite t t_meas t_lt_top)\n  intro s s_meas _\n  exact\n    hf_zero _ (s_meas.inter t_meas)\n      (lt_of_le_of_lt (measure_mono (Set.inter_subset_right)) t_lt_top)\n\n"}
{"name":"MeasureTheory.AEFinStronglyMeasurable.ae_nonneg_of_forall_setIntegral_nonneg","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : MeasureTheory.AEFinStronglyMeasurable f Î¼\nhf_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn f s Î¼\nhf_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ LE.le 0 (MeasureTheory.integral (Î¼.restrict s) fun x => f x)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyLE 0 f","decl":"theorem AEFinStronglyMeasurable.ae_nonneg_of_forall_setIntegral_nonneg {f : Î± â†’ â„}\n    (hf : AEFinStronglyMeasurable f Î¼)\n    (hf_int_finite : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ IntegrableOn f s Î¼)\n    (hf_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ 0 â‰¤ âˆ« x in s, f x âˆ‚Î¼) : 0 â‰¤áµ[Î¼] f := by\n  let t := hf.sigmaFiniteSet\n  suffices 0 â‰¤áµ[Î¼.restrict t] f from\n    ae_of_ae_restrict_of_ae_restrict_compl _ this hf.ae_eq_zero_compl.symm.le\n  haveI : SigmaFinite (Î¼.restrict t) := hf.sigmaFinite_restrict\n  refine\n    ae_nonneg_of_forall_setIntegral_nonneg_of_sigmaFinite (fun s hs hÎ¼ts => ?_) fun s hs hÎ¼ts => ?_\n  Â· rw [IntegrableOn, Measure.restrict_restrict hs]\n    rw [Measure.restrict_apply hs] at hÎ¼ts\n    exact hf_int_finite (s âˆ© t) (hs.inter hf.measurableSet) hÎ¼ts\n  Â· rw [Measure.restrict_restrict hs]\n    rw [Measure.restrict_apply hs] at hÎ¼ts\n    exact hf_zero (s âˆ© t) (hs.inter hf.measurableSet) hÎ¼ts\n\n"}
{"name":"MeasureTheory.ae_nonneg_restrict_of_forall_setIntegral_nonneg","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn f s Î¼\nhf_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ LE.le 0 (MeasureTheory.integral (Î¼.restrict s) fun x => f x)\nt : Set Î±\nht : MeasurableSet t\nhÎ¼t : Ne (Î¼ t) Top.top\nâŠ¢ (MeasureTheory.ae (Î¼.restrict t)).EventuallyLE 0 f","decl":"theorem ae_nonneg_restrict_of_forall_setIntegral_nonneg {f : Î± â†’ â„}\n    (hf_int_finite : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ IntegrableOn f s Î¼)\n    (hf_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ 0 â‰¤ âˆ« x in s, f x âˆ‚Î¼) {t : Set Î±}\n    (ht : MeasurableSet t) (hÎ¼t : Î¼ t â‰  âˆ) : 0 â‰¤áµ[Î¼.restrict t] f := by\n  refine\n    ae_nonneg_restrict_of_forall_setIntegral_nonneg_inter\n      (hf_int_finite t ht (lt_top_iff_ne_top.mpr hÎ¼t)) fun s hs _ => ?_\n  refine hf_zero (s âˆ© t) (hs.inter ht) ?_\n  exact (measure_mono Set.inter_subset_right).trans_lt (lt_top_iff_ne_top.mpr hÎ¼t)\n\n"}
{"name":"MeasureTheory.ae_eq_zero_restrict_of_forall_setIntegral_eq_zero_real","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn f s Î¼\nhf_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) 0\nt : Set Î±\nht : MeasurableSet t\nhÎ¼t : Ne (Î¼ t) Top.top\nâŠ¢ (MeasureTheory.ae (Î¼.restrict t)).EventuallyEq f 0","decl":"theorem ae_eq_zero_restrict_of_forall_setIntegral_eq_zero_real {f : Î± â†’ â„}\n    (hf_int_finite : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ IntegrableOn f s Î¼)\n    (hf_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ« x in s, f x âˆ‚Î¼ = 0) {t : Set Î±}\n    (ht : MeasurableSet t) (hÎ¼t : Î¼ t â‰  âˆ) : f =áµ[Î¼.restrict t] 0 := by\n  suffices h_and : f â‰¤áµ[Î¼.restrict t] 0 âˆ§ 0 â‰¤áµ[Î¼.restrict t] f from\n    h_and.1.mp (h_and.2.mono fun x hx1 hx2 => le_antisymm hx2 hx1)\n  refine\n    âŸ¨?_,\n      ae_nonneg_restrict_of_forall_setIntegral_nonneg hf_int_finite\n        (fun s hs hÎ¼s => (hf_zero s hs hÎ¼s).symm.le) ht hÎ¼tâŸ©\n  suffices h_neg : 0 â‰¤áµ[Î¼.restrict t] -f by\n    refine h_neg.mono fun x hx => ?_\n    rw [Pi.neg_apply] at hx\n    simpa using hx\n  refine\n    ae_nonneg_restrict_of_forall_setIntegral_nonneg (fun s hs hÎ¼s => (hf_int_finite s hs hÎ¼s).neg)\n      (fun s hs hÎ¼s => ?_) ht hÎ¼t\n  simp_rw [Pi.neg_apply]\n  rw [integral_neg, neg_nonneg]\n  exact (hf_zero s hs hÎ¼s).le\n\n"}
{"name":"MeasureTheory.ae_eq_zero_restrict_of_forall_setIntegral_eq_zero","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"Î± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nf : Î± â†’ E\nhf_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn f s Î¼\nhf_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) 0\nt : Set Î±\nht : MeasurableSet t\nhÎ¼t : Ne (Î¼ t) Top.top\nâŠ¢ (MeasureTheory.ae (Î¼.restrict t)).EventuallyEq f 0","decl":"theorem ae_eq_zero_restrict_of_forall_setIntegral_eq_zero {f : Î± â†’ E}\n    (hf_int_finite : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ IntegrableOn f s Î¼)\n    (hf_zero : âˆ€ s : Set Î±, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ« x in s, f x âˆ‚Î¼ = 0) {t : Set Î±}\n    (ht : MeasurableSet t) (hÎ¼t : Î¼ t â‰  âˆ) : f =áµ[Î¼.restrict t] 0 := by\n  rcases (hf_int_finite t ht hÎ¼t.lt_top).aestronglyMeasurable.isSeparable_ae_range with\n    âŸ¨u, u_sep, huâŸ©\n  refine ae_eq_zero_of_forall_dual_of_isSeparable â„ u_sep (fun c => ?_) hu\n  refine ae_eq_zero_restrict_of_forall_setIntegral_eq_zero_real ?_ ?_ ht hÎ¼t\n  Â· intro s hs hÎ¼s\n    exact ContinuousLinearMap.integrable_comp c (hf_int_finite s hs hÎ¼s)\n  Â· intro s hs hÎ¼s\n    rw [ContinuousLinearMap.integral_comp_comm c (hf_int_finite s hs hÎ¼s), hf_zero s hs hÎ¼s]\n    exact ContinuousLinearMap.map_zero _\n\n"}
{"name":"MeasureTheory.ae_eq_restrict_of_forall_setIntegral_eq","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"Î± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nf g : Î± â†’ E\nhf_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn f s Î¼\nhg_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn g s Î¼\nhfg_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => g x)\nt : Set Î±\nht : MeasurableSet t\nhÎ¼t : Ne (Î¼ t) Top.top\nâŠ¢ (MeasureTheory.ae (Î¼.restrict t)).EventuallyEq f g","decl":"theorem ae_eq_restrict_of_forall_setIntegral_eq {f g : Î± â†’ E}\n    (hf_int_finite : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ IntegrableOn f s Î¼)\n    (hg_int_finite : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ IntegrableOn g s Î¼)\n    (hfg_zero : âˆ€ s : Set Î±, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ« x in s, f x âˆ‚Î¼ = âˆ« x in s, g x âˆ‚Î¼)\n    {t : Set Î±} (ht : MeasurableSet t) (hÎ¼t : Î¼ t â‰  âˆ) : f =áµ[Î¼.restrict t] g := by\n  rw [â† sub_ae_eq_zero]\n  have hfg' : âˆ€ s : Set Î±, MeasurableSet s â†’ Î¼ s < âˆ â†’ (âˆ« x in s, (f - g) x âˆ‚Î¼) = 0 := by\n    intro s hs hÎ¼s\n    rw [integral_sub' (hf_int_finite s hs hÎ¼s) (hg_int_finite s hs hÎ¼s)]\n    exact sub_eq_zero.mpr (hfg_zero s hs hÎ¼s)\n  have hfg_int : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ IntegrableOn (f - g) s Î¼ := fun s hs hÎ¼s =>\n    (hf_int_finite s hs hÎ¼s).sub (hg_int_finite s hs hÎ¼s)\n  exact ae_eq_zero_restrict_of_forall_setIntegral_eq_zero hfg_int hfg' ht hÎ¼t\n\n"}
{"name":"MeasureTheory.ae_eq_zero_of_forall_setIntegral_eq_of_sigmaFinite","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"Î± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\ninstâœ : MeasureTheory.SigmaFinite Î¼\nf : Î± â†’ E\nhf_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn f s Î¼\nhf_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) 0\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq f 0","decl":"theorem ae_eq_zero_of_forall_setIntegral_eq_of_sigmaFinite [SigmaFinite Î¼] {f : Î± â†’ E}\n    (hf_int_finite : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ IntegrableOn f s Î¼)\n    (hf_zero : âˆ€ s : Set Î±, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ« x in s, f x âˆ‚Î¼ = 0) : f =áµ[Î¼] 0 := by\n  let S := spanningSets Î¼\n  rw [â† @Measure.restrict_univ _ _ Î¼, â† iUnion_spanningSets Î¼, EventuallyEq, ae_iff,\n    Measure.restrict_apply' (MeasurableSet.iUnion (measurableSet_spanningSets Î¼))]\n  rw [Set.inter_iUnion, measure_iUnion_null_iff]\n  intro n\n  have h_meas_n : MeasurableSet (S n) := measurableSet_spanningSets Î¼ n\n  have hÎ¼n : Î¼ (S n) < âˆ := measure_spanningSets_lt_top Î¼ n\n  rw [â† Measure.restrict_apply' h_meas_n]\n  exact ae_eq_zero_restrict_of_forall_setIntegral_eq_zero hf_int_finite hf_zero h_meas_n hÎ¼n.ne\n\n"}
{"name":"MeasureTheory.ae_eq_of_forall_setIntegral_eq_of_sigmaFinite","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"Î± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : CompleteSpace E\ninstâœ : MeasureTheory.SigmaFinite Î¼\nf g : Î± â†’ E\nhf_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn f s Î¼\nhg_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn g s Î¼\nhfg_eq : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => g x)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq f g","decl":"theorem ae_eq_of_forall_setIntegral_eq_of_sigmaFinite [SigmaFinite Î¼] {f g : Î± â†’ E}\n    (hf_int_finite : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ IntegrableOn f s Î¼)\n    (hg_int_finite : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ IntegrableOn g s Î¼)\n    (hfg_eq : âˆ€ s : Set Î±, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ« x in s, f x âˆ‚Î¼ = âˆ« x in s, g x âˆ‚Î¼) :\n    f =áµ[Î¼] g := by\n  rw [â† sub_ae_eq_zero]\n  have hfg : âˆ€ s : Set Î±, MeasurableSet s â†’ Î¼ s < âˆ â†’ (âˆ« x in s, (f - g) x âˆ‚Î¼) = 0 := by\n    intro s hs hÎ¼s\n    rw [integral_sub' (hf_int_finite s hs hÎ¼s) (hg_int_finite s hs hÎ¼s),\n      sub_eq_zero.mpr (hfg_eq s hs hÎ¼s)]\n  have hfg_int : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ IntegrableOn (f - g) s Î¼ := fun s hs hÎ¼s =>\n    (hf_int_finite s hs hÎ¼s).sub (hg_int_finite s hs hÎ¼s)\n  exact ae_eq_zero_of_forall_setIntegral_eq_of_sigmaFinite hfg_int hfg\n\n"}
{"name":"MeasureTheory.AEFinStronglyMeasurable.ae_eq_zero_of_forall_setIntegral_eq_zero","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"Î± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nf : Î± â†’ E\nhf_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn f s Î¼\nhf_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) 0\nhf : MeasureTheory.AEFinStronglyMeasurable f Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq f 0","decl":"theorem AEFinStronglyMeasurable.ae_eq_zero_of_forall_setIntegral_eq_zero {f : Î± â†’ E}\n    (hf_int_finite : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ IntegrableOn f s Î¼)\n    (hf_zero : âˆ€ s : Set Î±, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ« x in s, f x âˆ‚Î¼ = 0)\n    (hf : AEFinStronglyMeasurable f Î¼) : f =áµ[Î¼] 0 := by\n  let t := hf.sigmaFiniteSet\n  suffices f =áµ[Î¼.restrict t] 0 from\n    ae_of_ae_restrict_of_ae_restrict_compl _ this hf.ae_eq_zero_compl\n  haveI : SigmaFinite (Î¼.restrict t) := hf.sigmaFinite_restrict\n  refine ae_eq_zero_of_forall_setIntegral_eq_of_sigmaFinite ?_ ?_\n  Â· intro s hs hÎ¼s\n    rw [IntegrableOn, Measure.restrict_restrict hs]\n    rw [Measure.restrict_apply hs] at hÎ¼s\n    exact hf_int_finite _ (hs.inter hf.measurableSet) hÎ¼s\n  Â· intro s hs hÎ¼s\n    rw [Measure.restrict_restrict hs]\n    rw [Measure.restrict_apply hs] at hÎ¼s\n    exact hf_zero _ (hs.inter hf.measurableSet) hÎ¼s\n\n"}
{"name":"MeasureTheory.AEFinStronglyMeasurable.ae_eq_of_forall_setIntegral_eq","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"Î± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nf g : Î± â†’ E\nhf_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn f s Î¼\nhg_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn g s Î¼\nhfg_eq : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => g x)\nhf : MeasureTheory.AEFinStronglyMeasurable f Î¼\nhg : MeasureTheory.AEFinStronglyMeasurable g Î¼\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq f g","decl":"theorem AEFinStronglyMeasurable.ae_eq_of_forall_setIntegral_eq {f g : Î± â†’ E}\n    (hf_int_finite : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ IntegrableOn f s Î¼)\n    (hg_int_finite : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ IntegrableOn g s Î¼)\n    (hfg_eq : âˆ€ s : Set Î±, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ« x in s, f x âˆ‚Î¼ = âˆ« x in s, g x âˆ‚Î¼)\n    (hf : AEFinStronglyMeasurable f Î¼) (hg : AEFinStronglyMeasurable g Î¼) : f =áµ[Î¼] g := by\n  rw [â† sub_ae_eq_zero]\n  have hfg : âˆ€ s : Set Î±, MeasurableSet s â†’ Î¼ s < âˆ â†’ (âˆ« x in s, (f - g) x âˆ‚Î¼) = 0 := by\n    intro s hs hÎ¼s\n    rw [integral_sub' (hf_int_finite s hs hÎ¼s) (hg_int_finite s hs hÎ¼s),\n      sub_eq_zero.mpr (hfg_eq s hs hÎ¼s)]\n  have hfg_int : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ IntegrableOn (f - g) s Î¼ := fun s hs hÎ¼s =>\n    (hf_int_finite s hs hÎ¼s).sub (hg_int_finite s hs hÎ¼s)\n  exact (hf.sub hg).ae_eq_zero_of_forall_setIntegral_eq_zero hfg_int hfg\n\n"}
{"name":"MeasureTheory.Lp.ae_eq_zero_of_forall_setIntegral_eq_zero","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"Î± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\np : ENNReal\nf : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Î¼) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nhf_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn (â†‘â†‘f) s Î¼\nhf_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => â†‘â†‘f x) 0\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (â†‘â†‘f) 0","decl":"theorem Lp.ae_eq_zero_of_forall_setIntegral_eq_zero (f : Lp E p Î¼) (hp_ne_zero : p â‰  0)\n    (hp_ne_top : p â‰  âˆ) (hf_int_finite : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ IntegrableOn f s Î¼)\n    (hf_zero : âˆ€ s : Set Î±, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ« x in s, f x âˆ‚Î¼ = 0) : f =áµ[Î¼] 0 :=\n  AEFinStronglyMeasurable.ae_eq_zero_of_forall_setIntegral_eq_zero hf_int_finite hf_zero\n    (Lp.finStronglyMeasurable _ hp_ne_zero hp_ne_top).aefinStronglyMeasurable\n\n"}
{"name":"MeasureTheory.Lp.ae_eq_of_forall_setIntegral_eq","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"Î± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\np : ENNReal\nf g : Subtype fun x => Membership.mem (MeasureTheory.Lp E p Î¼) x\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nhf_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn (â†‘â†‘f) s Î¼\nhg_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn (â†‘â†‘g) s Î¼\nhfg : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => â†‘â†‘f x) (MeasureTheory.integral (Î¼.restrict s) fun x => â†‘â†‘g x)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq â†‘â†‘f â†‘â†‘g","decl":"theorem Lp.ae_eq_of_forall_setIntegral_eq (f g : Lp E p Î¼) (hp_ne_zero : p â‰  0) (hp_ne_top : p â‰  âˆ)\n    (hf_int_finite : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ IntegrableOn f s Î¼)\n    (hg_int_finite : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ IntegrableOn g s Î¼)\n    (hfg : âˆ€ s : Set Î±, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ« x in s, f x âˆ‚Î¼ = âˆ« x in s, g x âˆ‚Î¼) :\n    f =áµ[Î¼] g :=\n  AEFinStronglyMeasurable.ae_eq_of_forall_setIntegral_eq hf_int_finite hg_int_finite hfg\n    (Lp.finStronglyMeasurable _ hp_ne_zero hp_ne_top).aefinStronglyMeasurable\n    (Lp.finStronglyMeasurable _ hp_ne_zero hp_ne_top).aefinStronglyMeasurable\n\n"}
{"name":"MeasureTheory.ae_eq_zero_of_forall_setIntegral_eq_of_finStronglyMeasurable_trim","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"Î± : Type u_1\nE : Type u_2\nm m0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nhm : LE.le m m0\nf : Î± â†’ E\nhf_int_finite : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ MeasureTheory.IntegrableOn f s Î¼\nhf_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) 0\nhf : MeasureTheory.FinStronglyMeasurable f (Î¼.trim hm)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq f 0","decl":"theorem ae_eq_zero_of_forall_setIntegral_eq_of_finStronglyMeasurable_trim (hm : m â‰¤ m0) {f : Î± â†’ E}\n    (hf_int_finite : âˆ€ s, MeasurableSet[m] s â†’ Î¼ s < âˆ â†’ IntegrableOn f s Î¼)\n    (hf_zero : âˆ€ s : Set Î±, MeasurableSet[m] s â†’ Î¼ s < âˆ â†’ âˆ« x in s, f x âˆ‚Î¼ = 0)\n    (hf : FinStronglyMeasurable f (Î¼.trim hm)) : f =áµ[Î¼] 0 := by\n  obtain âŸ¨t, ht_meas, htf_zero, htÎ¼âŸ© := hf.exists_set_sigmaFinite\n  haveI : SigmaFinite ((Î¼.restrict t).trim hm) := by rwa [restrict_trim hm Î¼ ht_meas] at htÎ¼\n  have htf_zero : f =áµ[Î¼.restrict tá¶œ] 0 := by\n    rw [EventuallyEq, ae_restrict_iff' (MeasurableSet.compl (hm _ ht_meas))]\n    exact Eventually.of_forall htf_zero\n  have hf_meas_m : StronglyMeasurable[m] f := hf.stronglyMeasurable\n  suffices f =áµ[Î¼.restrict t] 0 from\n    ae_of_ae_restrict_of_ae_restrict_compl _ this htf_zero\n  refine measure_eq_zero_of_trim_eq_zero hm ?_\n  refine ae_eq_zero_of_forall_setIntegral_eq_of_sigmaFinite ?_ ?_\n  Â· intro s hs hÎ¼s\n    unfold IntegrableOn\n    rw [restrict_trim hm (Î¼.restrict t) hs, Measure.restrict_restrict (hm s hs)]\n    rw [â† restrict_trim hm Î¼ ht_meas, Measure.restrict_apply hs,\n      trim_measurableSet_eq hm (hs.inter ht_meas)] at hÎ¼s\n    refine Integrable.trim hm ?_ hf_meas_m\n    exact hf_int_finite _ (hs.inter ht_meas) hÎ¼s\n  Â· intro s hs hÎ¼s\n    rw [restrict_trim hm (Î¼.restrict t) hs, Measure.restrict_restrict (hm s hs)]\n    rw [â† restrict_trim hm Î¼ ht_meas, Measure.restrict_apply hs,\n      trim_measurableSet_eq hm (hs.inter ht_meas)] at hÎ¼s\n    rw [â† integral_trim hm hf_meas_m]\n    exact hf_zero _ (hs.inter ht_meas) hÎ¼s\n\n"}
{"name":"MeasureTheory.Integrable.ae_eq_zero_of_forall_setIntegral_eq_zero","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"Î± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nf : Î± â†’ E\nhf : MeasureTheory.Integrable f Î¼\nhf_zero : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) 0\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq f 0","decl":"theorem Integrable.ae_eq_zero_of_forall_setIntegral_eq_zero {f : Î± â†’ E} (hf : Integrable f Î¼)\n    (hf_zero : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ« x in s, f x âˆ‚Î¼ = 0) : f =áµ[Î¼] 0 := by\n  have hf_Lp : Memâ„’p f 1 Î¼ := memâ„’p_one_iff_integrable.mpr hf\n  let f_Lp := hf_Lp.toLp f\n  have hf_f_Lp : f =áµ[Î¼] f_Lp := (Memâ„’p.coeFn_toLp hf_Lp).symm\n  refine hf_f_Lp.trans ?_\n  refine Lp.ae_eq_zero_of_forall_setIntegral_eq_zero f_Lp one_ne_zero ENNReal.coe_ne_top ?_ ?_\n  Â· exact fun s _ _ => Integrable.integrableOn (L1.integrable_coeFn _)\n  Â· intro s hs hÎ¼s\n    rw [integral_congr_ae (ae_restrict_of_ae hf_f_Lp.symm)]\n    exact hf_zero s hs hÎ¼s\n\n"}
{"name":"MeasureTheory.Integrable.ae_eq_of_forall_setIntegral_eq","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"Î± : Type u_1\nE : Type u_2\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace Real E\ninstâœ : CompleteSpace E\nf g : Î± â†’ E\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nhfg : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) (MeasureTheory.integral (Î¼.restrict s) fun x => g x)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq f g","decl":"theorem Integrable.ae_eq_of_forall_setIntegral_eq (f g : Î± â†’ E) (hf : Integrable f Î¼)\n    (hg : Integrable g Î¼)\n    (hfg : âˆ€ s : Set Î±, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ« x in s, f x âˆ‚Î¼ = âˆ« x in s, g x âˆ‚Î¼) :\n    f =áµ[Î¼] g := by\n  rw [â† sub_ae_eq_zero]\n  have hfg' : âˆ€ s : Set Î±, MeasurableSet s â†’ Î¼ s < âˆ â†’ (âˆ« x in s, (f - g) x âˆ‚Î¼) = 0 := by\n    intro s hs hÎ¼s\n    rw [integral_sub' hf.integrableOn hg.integrableOn]\n    exact sub_eq_zero.mpr (hfg s hs hÎ¼s)\n  exact Integrable.ae_eq_zero_of_forall_setIntegral_eq_zero (hf.sub hg) hfg'\n\n"}
{"name":"MeasureTheory.ae_eq_zero_of_forall_setIntegral_isClosed_eq_zero","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"E : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : CompleteSpace E\nÎ² : Type u_3\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : BorelSpace Î²\nÎ¼ : MeasureTheory.Measure Î²\nf : Î² â†’ E\nhf : MeasureTheory.Integrable f Î¼\nh'f : âˆ€ (s : Set Î²), IsClosed s â†’ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) 0\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq f 0","decl":"/-- If an integrable function has zero integral on all closed sets, then it is zero\nalmost everywhere. -/\nlemma ae_eq_zero_of_forall_setIntegral_isClosed_eq_zero {Î¼ : Measure Î²} {f : Î² â†’ E}\n    (hf : Integrable f Î¼) (h'f : âˆ€ (s : Set Î²), IsClosed s â†’ âˆ« x in s, f x âˆ‚Î¼ = 0) :\n    f =áµ[Î¼] 0 := by\n  suffices âˆ€ s, MeasurableSet s â†’ âˆ« x in s, f x âˆ‚Î¼ = 0 from\n    hf.ae_eq_zero_of_forall_setIntegral_eq_zero (fun s hs _ â†¦ this s hs)\n  have A : âˆ€ (t : Set Î²), MeasurableSet t â†’ âˆ« (x : Î²) in t, f x âˆ‚Î¼ = 0\n      â†’ âˆ« (x : Î²) in tá¶œ, f x âˆ‚Î¼ = 0 := by\n    intro t t_meas ht\n    have I : âˆ« x, f x âˆ‚Î¼ = 0 := by rw [â† setIntegral_univ]; exact h'f _ isClosed_univ\n    simpa [ht, I] using integral_add_compl t_meas hf\n  intro s hs\n  induction s, hs using MeasurableSet.induction_on_open with\n  | isOpen U hU => exact compl_compl U â–¸ A _ hU.measurableSet.compl (h'f _ hU.isClosed_compl)\n  | compl s hs ihs => exact A s hs ihs\n  | iUnion g g_disj g_meas hg => simp [integral_iUnion g_meas g_disj hf.integrableOn, hg]\n\n"}
{"name":"MeasureTheory.ae_eq_zero_of_forall_setIntegral_isCompact_eq_zero","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"E : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : CompleteSpace E\nÎ² : Type u_3\ninstâœâ´ : TopologicalSpace Î²\ninstâœÂ³ : MeasurableSpace Î²\ninstâœÂ² : BorelSpace Î²\ninstâœÂ¹ : SigmaCompactSpace Î²\ninstâœ : R1Space Î²\nÎ¼ : MeasureTheory.Measure Î²\nf : Î² â†’ E\nhf : MeasureTheory.Integrable f Î¼\nh'f : âˆ€ (s : Set Î²), IsCompact s â†’ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) 0\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq f 0","decl":"/-- If an integrable function has zero integral on all compact sets in a sigma-compact space, then\nit is zero almost everywhere. -/\nlemma ae_eq_zero_of_forall_setIntegral_isCompact_eq_zero\n    [SigmaCompactSpace Î²] [R1Space Î²] {Î¼ : Measure Î²} {f : Î² â†’ E} (hf : Integrable f Î¼)\n    (h'f : âˆ€ (s : Set Î²), IsCompact s â†’ âˆ« x in s, f x âˆ‚Î¼ = 0) :\n    f =áµ[Î¼] 0 := by\n  apply ae_eq_zero_of_forall_setIntegral_isClosed_eq_zero hf (fun s hs â†¦ ?_)\n  let t : â„• â†’ Set Î² := fun n â†¦ closure (compactCovering Î² n) âˆ© s\n  suffices H : Tendsto (fun n â†¦ âˆ« x in t n, f x âˆ‚Î¼) atTop (ğ“ (âˆ« x in s, f x âˆ‚Î¼)) by\n    have A : âˆ€ n, âˆ« x in t n, f x âˆ‚Î¼ = 0 :=\n      fun n â†¦ h'f _ ((isCompact_compactCovering Î² n).closure.inter_right hs)\n    simp_rw [A, tendsto_const_nhds_iff] at H\n    exact H.symm\n  have B : s = â‹ƒ n, t n := by\n    rw [â† Set.iUnion_inter, iUnion_closure_compactCovering, Set.univ_inter]\n  rw [B]\n  apply tendsto_setIntegral_of_monotone\n  Â· intros n\n    exact (isClosed_closure.inter hs).measurableSet\n  Â· intros m n hmn\n    simp only [t, Set.le_iff_subset]\n    gcongr\n  Â· exact hf.integrableOn\n\n"}
{"name":"MeasureTheory.ae_eq_zero_of_forall_setIntegral_isCompact_eq_zero'","module":"Mathlib.MeasureTheory.Function.AEEqOfIntegral","initialProofState":"E : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : CompleteSpace E\nÎ² : Type u_3\ninstâœâ´ : TopologicalSpace Î²\ninstâœÂ³ : MeasurableSpace Î²\ninstâœÂ² : BorelSpace Î²\ninstâœÂ¹ : SigmaCompactSpace Î²\ninstâœ : R1Space Î²\nÎ¼ : MeasureTheory.Measure Î²\nf : Î² â†’ E\nhf : MeasureTheory.LocallyIntegrable f Î¼\nh'f : âˆ€ (s : Set Î²), IsCompact s â†’ Eq (MeasureTheory.integral (Î¼.restrict s) fun x => f x) 0\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq f 0","decl":"/-- If a locally integrable function has zero integral on all compact sets in a sigma-compact space,\nthen it is zero almost everywhere. -/\nlemma ae_eq_zero_of_forall_setIntegral_isCompact_eq_zero'\n    [SigmaCompactSpace Î²] [R1Space Î²] {Î¼ : Measure Î²} {f : Î² â†’ E} (hf : LocallyIntegrable f Î¼)\n    (h'f : âˆ€ (s : Set Î²), IsCompact s â†’ âˆ« x in s, f x âˆ‚Î¼ = 0) :\n    f =áµ[Î¼] 0 := by\n  rw [â† Î¼.restrict_univ, â† iUnion_closure_compactCovering]\n  apply (ae_restrict_iUnion_iff _ _).2 (fun n â†¦ ?_)\n  apply ae_eq_zero_of_forall_setIntegral_isCompact_eq_zero\n  Â· exact hf.integrableOn_isCompact (isCompact_compactCovering Î² n).closure\n  Â· intro s hs\n    rw [Measure.restrict_restrict' measurableSet_closure]\n    exact h'f _ (hs.inter_right isClosed_closure)\n\n"}
