{"name":"instZeroLEOneClassEReal","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ ZeroLEOneClass EReal","decl":"instance : ZeroLEOneClass EReal := inferInstanceAs (ZeroLEOneClass (WithBot (WithTop ℝ)))\n"}
{"name":"instDenselyOrderedEReal","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ DenselyOrdered EReal","decl":"instance : DenselyOrdered EReal :=\n  inferInstanceAs (DenselyOrdered (WithBot (WithTop ℝ)))\n\n"}
{"name":"instCharZeroEReal","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ CharZero EReal","decl":"instance : CharZero EReal := inferInstanceAs (CharZero (WithBot (WithTop ℝ)))\n\n"}
{"name":"EReal.coe_strictMono","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ StrictMono Real.toEReal","decl":"theorem coe_strictMono : StrictMono Real.toEReal :=\n  WithBot.coe_strictMono.comp WithTop.coe_strictMono\n\n"}
{"name":"EReal.coe_injective","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Function.Injective Real.toEReal","decl":"theorem coe_injective : Injective Real.toEReal :=\n  coe_strictMono.injective\n\n"}
{"name":"EReal.coe_le_coe_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : Real\n⊢ Iff (LE.le ↑x ↑y) (LE.le x y)","decl":"@[simp, norm_cast]\nprotected theorem coe_le_coe_iff {x y : ℝ} : (x : EReal) ≤ (y : EReal) ↔ x ≤ y :=\n  coe_strictMono.le_iff_le\n\n"}
{"name":"EReal.coe_lt_coe_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : Real\n⊢ Iff (LT.lt ↑x ↑y) (LT.lt x y)","decl":"@[simp, norm_cast]\nprotected theorem coe_lt_coe_iff {x y : ℝ} : (x : EReal) < (y : EReal) ↔ x < y :=\n  coe_strictMono.lt_iff_lt\n\n"}
{"name":"EReal.coe_eq_coe_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : Real\n⊢ Iff (Eq ↑x ↑y) (Eq x y)","decl":"@[simp, norm_cast]\nprotected theorem coe_eq_coe_iff {x y : ℝ} : (x : EReal) = (y : EReal) ↔ x = y :=\n  coe_injective.eq_iff\n\n"}
{"name":"EReal.coe_ne_coe_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : Real\n⊢ Iff (Ne ↑x ↑y) (Ne x y)","decl":"protected theorem coe_ne_coe_iff {x y : ℝ} : (x : EReal) ≠ (y : EReal) ↔ x ≠ y :=\n  coe_injective.ne_iff\n\n"}
{"name":"EReal.coe_zero","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem coe_zero : ((0 : ℝ) : EReal) = 0 := rfl\n\n"}
{"name":"EReal.coe_one","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem coe_one : ((1 : ℝ) : EReal) = 1 := rfl\n\n"}
{"name":"EReal.forall","module":"Mathlib.Data.Real.EReal","initialProofState":"p : EReal → Prop\n⊢ Iff (∀ (r : EReal), p r) (And (p Bot.bot) (And (p Top.top) (∀ (r : Real), p ↑r)))","decl":"protected lemma «forall» {p : EReal → Prop} : (∀ r, p r) ↔ p ⊥ ∧ p ⊤ ∧ ∀ r : ℝ, p r where\n  mp h := ⟨h _, h _, fun _ ↦ h _⟩\n  mpr h := EReal.rec h.1 h.2.2 h.2.1\n\n"}
{"name":"EReal.exists","module":"Mathlib.Data.Real.EReal","initialProofState":"p : EReal → Prop\n⊢ Iff (Exists fun r => p r) (Or (p Bot.bot) (Or (p Top.top) (Exists fun r => p ↑r)))","decl":"protected lemma «exists» {p : EReal → Prop} : (∃ r, p r) ↔ p ⊥ ∨ p ⊤ ∨ ∃ r : ℝ, p r where\n  mp := by rintro ⟨r, hr⟩; cases r <;> aesop\n  mpr := by rintro (h | h | ⟨r, hr⟩) <;> exact ⟨_, ‹_›⟩\n\n"}
{"name":"EReal.coe_mul","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : Real\n⊢ Eq (↑(HMul.hMul x y)) (HMul.hMul ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_mul (x y : ℝ) : (↑(x * y) : EReal) = x * y :=\n  rfl\n\n"}
{"name":"EReal.induction₂","module":"Mathlib.Data.Real.EReal","initialProofState":"P : EReal → EReal → Prop\ntop_top : P Top.top Top.top\ntop_pos : ∀ (x : Real), LT.lt 0 x → P Top.top ↑x\ntop_zero : P Top.top 0\ntop_neg : ∀ (x : Real), LT.lt x 0 → P Top.top ↑x\ntop_bot : P Top.top Bot.bot\npos_top : ∀ (x : Real), LT.lt 0 x → P (↑x) Top.top\npos_bot : ∀ (x : Real), LT.lt 0 x → P (↑x) Bot.bot\nzero_top : P 0 Top.top\ncoe_coe : ∀ (x y : Real), P ↑x ↑y\nzero_bot : P 0 Bot.bot\nneg_top : ∀ (x : Real), LT.lt x 0 → P (↑x) Top.top\nneg_bot : ∀ (x : Real), LT.lt x 0 → P (↑x) Bot.bot\nbot_top : P Bot.bot Top.top\nbot_pos : ∀ (x : Real), LT.lt 0 x → P Bot.bot ↑x\nbot_zero : P Bot.bot 0\nbot_neg : ∀ (x : Real), LT.lt x 0 → P Bot.bot ↑x\nbot_bot : P Bot.bot Bot.bot\nx y : EReal\n⊢ P x y","decl":"/-- Induct on two `EReal`s by performing case splits on the sign of one whenever the other is\ninfinite. -/\n@[elab_as_elim]\ntheorem induction₂ {P : EReal → EReal → Prop} (top_top : P ⊤ ⊤) (top_pos : ∀ x : ℝ, 0 < x → P ⊤ x)\n    (top_zero : P ⊤ 0) (top_neg : ∀ x : ℝ, x < 0 → P ⊤ x) (top_bot : P ⊤ ⊥)\n    (pos_top : ∀ x : ℝ, 0 < x → P x ⊤) (pos_bot : ∀ x : ℝ, 0 < x → P x ⊥) (zero_top : P 0 ⊤)\n    (coe_coe : ∀ x y : ℝ, P x y) (zero_bot : P 0 ⊥) (neg_top : ∀ x : ℝ, x < 0 → P x ⊤)\n    (neg_bot : ∀ x : ℝ, x < 0 → P x ⊥) (bot_top : P ⊥ ⊤) (bot_pos : ∀ x : ℝ, 0 < x → P ⊥ x)\n    (bot_zero : P ⊥ 0) (bot_neg : ∀ x : ℝ, x < 0 → P ⊥ x) (bot_bot : P ⊥ ⊥) : ∀ x y, P x y\n  | ⊥, ⊥ => bot_bot\n  | ⊥, (y : ℝ) => by\n    rcases lt_trichotomy y 0 with (hy | rfl | hy)\n    exacts [bot_neg y hy, bot_zero, bot_pos y hy]\n  | ⊥, ⊤ => bot_top\n  | (x : ℝ), ⊥ => by\n    rcases lt_trichotomy x 0 with (hx | rfl | hx)\n    exacts [neg_bot x hx, zero_bot, pos_bot x hx]\n  | (x : ℝ), (y : ℝ) => coe_coe _ _\n  | (x : ℝ), ⊤ => by\n    rcases lt_trichotomy x 0 with (hx | rfl | hx)\n    exacts [neg_top x hx, zero_top, pos_top x hx]\n  | ⊤, ⊥ => top_bot\n  | ⊤, (y : ℝ) => by\n    rcases lt_trichotomy y 0 with (hy | rfl | hy)\n    exacts [top_neg y hy, top_zero, top_pos y hy]\n  | ⊤, ⊤ => top_top\n\n"}
{"name":"EReal.induction₂_symm","module":"Mathlib.Data.Real.EReal","initialProofState":"P : EReal → EReal → Prop\nsymm : ∀ {x y : EReal}, P x y → P y x\ntop_top : P Top.top Top.top\ntop_pos : ∀ (x : Real), LT.lt 0 x → P Top.top ↑x\ntop_zero : P Top.top 0\ntop_neg : ∀ (x : Real), LT.lt x 0 → P Top.top ↑x\ntop_bot : P Top.top Bot.bot\npos_bot : ∀ (x : Real), LT.lt 0 x → P (↑x) Bot.bot\ncoe_coe : ∀ (x y : Real), P ↑x ↑y\nzero_bot : P 0 Bot.bot\nneg_bot : ∀ (x : Real), LT.lt x 0 → P (↑x) Bot.bot\nbot_bot : P Bot.bot Bot.bot\nx y : EReal\n⊢ P x y","decl":"/-- Induct on two `EReal`s by performing case splits on the sign of one whenever the other is\ninfinite. This version eliminates some cases by assuming that the relation is symmetric. -/\n@[elab_as_elim]\ntheorem induction₂_symm {P : EReal → EReal → Prop} (symm : ∀ {x y}, P x y → P y x)\n    (top_top : P ⊤ ⊤) (top_pos : ∀ x : ℝ, 0 < x → P ⊤ x) (top_zero : P ⊤ 0)\n    (top_neg : ∀ x : ℝ, x < 0 → P ⊤ x) (top_bot : P ⊤ ⊥) (pos_bot : ∀ x : ℝ, 0 < x → P x ⊥)\n    (coe_coe : ∀ x y : ℝ, P x y) (zero_bot : P 0 ⊥) (neg_bot : ∀ x : ℝ, x < 0 → P x ⊥)\n    (bot_bot : P ⊥ ⊥) : ∀ x y, P x y :=\n  @induction₂ P top_top top_pos top_zero top_neg top_bot (fun _ h => symm <| top_pos _ h)\n    pos_bot (symm top_zero) coe_coe zero_bot (fun _ h => symm <| top_neg _ h) neg_bot (symm top_bot)\n    (fun _ h => symm <| pos_bot _ h) (symm zero_bot) (fun _ h => symm <| neg_bot _ h) bot_bot\n\n"}
{"name":"EReal.mul_comm","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\n⊢ Eq (HMul.hMul x y) (HMul.hMul y x)","decl":"protected theorem mul_comm (x y : EReal) : x * y = y * x := by\n  induction x <;> induction y  <;>\n    try { rfl }\n  rw [← coe_mul, ← coe_mul, mul_comm]\n\n"}
{"name":"EReal.one_mul","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Eq (HMul.hMul 1 x) x","decl":"protected theorem one_mul : ∀ x : EReal, 1 * x = x\n  | ⊤ => if_pos one_pos\n  | ⊥ => if_pos one_pos\n  | (x : ℝ) => congr_arg Real.toEReal (one_mul x)\n\n"}
{"name":"EReal.zero_mul","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Eq (HMul.hMul 0 x) 0","decl":"protected theorem zero_mul : ∀ x : EReal, 0 * x = 0\n  | ⊤ => (if_neg (lt_irrefl _)).trans (if_pos rfl)\n  | ⊥ => (if_neg (lt_irrefl _)).trans (if_pos rfl)\n  | (x : ℝ) => congr_arg Real.toEReal (zero_mul x)\n\n"}
{"name":"EReal.canLift","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ CanLift EReal Real Real.toEReal fun r => And (Ne r Top.top) (Ne r Bot.bot)","decl":"instance canLift : CanLift EReal ℝ (↑) fun r => r ≠ ⊤ ∧ r ≠ ⊥ where\n  prf x hx := by\n    induction x\n    · simp at hx\n    · simp\n    · simp at hx\n\n"}
{"name":"EReal.toReal_top","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq Top.top.toReal 0","decl":"@[simp]\ntheorem toReal_top : toReal ⊤ = 0 :=\n  rfl\n\n"}
{"name":"EReal.toReal_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq Bot.bot.toReal 0","decl":"@[simp]\ntheorem toReal_bot : toReal ⊥ = 0 :=\n  rfl\n\n"}
{"name":"EReal.toReal_zero","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (EReal.toReal 0) 0","decl":"@[simp]\ntheorem toReal_zero : toReal 0 = 0 :=\n  rfl\n\n"}
{"name":"EReal.toReal_one","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (EReal.toReal 1) 1","decl":"@[simp]\ntheorem toReal_one : toReal 1 = 1 :=\n  rfl\n\n"}
{"name":"EReal.toReal_coe","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Eq (↑x).toReal x","decl":"@[simp]\ntheorem toReal_coe (x : ℝ) : toReal (x : EReal) = x :=\n  rfl\n\n"}
{"name":"EReal.bot_lt_coe","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ LT.lt Bot.bot ↑x","decl":"@[simp]\ntheorem bot_lt_coe (x : ℝ) : (⊥ : EReal) < x :=\n  WithBot.bot_lt_coe _\n\n"}
{"name":"EReal.coe_ne_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Ne (↑x) Bot.bot","decl":"@[simp]\ntheorem coe_ne_bot (x : ℝ) : (x : EReal) ≠ ⊥ :=\n  (bot_lt_coe x).ne'\n\n"}
{"name":"EReal.bot_ne_coe","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Ne Bot.bot ↑x","decl":"@[simp]\ntheorem bot_ne_coe (x : ℝ) : (⊥ : EReal) ≠ x :=\n  (bot_lt_coe x).ne\n\n"}
{"name":"EReal.coe_lt_top","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ LT.lt (↑x) Top.top","decl":"@[simp]\ntheorem coe_lt_top (x : ℝ) : (x : EReal) < ⊤ :=\n  WithBot.coe_lt_coe.2 <| WithTop.coe_lt_top _\n\n"}
{"name":"EReal.coe_ne_top","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Ne (↑x) Top.top","decl":"@[simp]\ntheorem coe_ne_top (x : ℝ) : (x : EReal) ≠ ⊤ :=\n  (coe_lt_top x).ne\n\n"}
{"name":"EReal.top_ne_coe","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Ne Top.top ↑x","decl":"@[simp]\ntheorem top_ne_coe (x : ℝ) : (⊤ : EReal) ≠ x :=\n  (coe_lt_top x).ne'\n\n"}
{"name":"EReal.bot_lt_zero","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ LT.lt Bot.bot 0","decl":"@[simp]\ntheorem bot_lt_zero : (⊥ : EReal) < 0 :=\n  bot_lt_coe 0\n\n"}
{"name":"EReal.bot_ne_zero","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Ne Bot.bot 0","decl":"@[simp]\ntheorem bot_ne_zero : (⊥ : EReal) ≠ 0 :=\n  (coe_ne_bot 0).symm\n\n"}
{"name":"EReal.zero_ne_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Ne 0 Bot.bot","decl":"@[simp]\ntheorem zero_ne_bot : (0 : EReal) ≠ ⊥ :=\n  coe_ne_bot 0\n\n"}
{"name":"EReal.zero_lt_top","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ LT.lt 0 Top.top","decl":"@[simp]\ntheorem zero_lt_top : (0 : EReal) < ⊤ :=\n  coe_lt_top 0\n\n"}
{"name":"EReal.zero_ne_top","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Ne 0 Top.top","decl":"@[simp]\ntheorem zero_ne_top : (0 : EReal) ≠ ⊤ :=\n  coe_ne_top 0\n\n"}
{"name":"EReal.top_ne_zero","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Ne Top.top 0","decl":"@[simp]\ntheorem top_ne_zero : (⊤ : EReal) ≠ 0 :=\n  (coe_ne_top 0).symm\n\n"}
{"name":"EReal.range_coe","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (Set.range Real.toEReal) (HasCompl.compl (Insert.insert Bot.bot (Singleton.singleton Top.top)))","decl":"theorem range_coe : range Real.toEReal = {⊥, ⊤}ᶜ := by\n  ext x\n  induction x <;> simp\n\n"}
{"name":"EReal.range_coe_eq_Ioo","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (Set.range Real.toEReal) (Set.Ioo Bot.bot Top.top)","decl":"theorem range_coe_eq_Ioo : range Real.toEReal = Ioo ⊥ ⊤ := by\n  ext x\n  induction x <;> simp\n\n"}
{"name":"EReal.coe_add","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : Real\n⊢ Eq (↑(HAdd.hAdd x y)) (HAdd.hAdd ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_add (x y : ℝ) : (↑(x + y) : EReal) = x + y :=\n  rfl\n\n-- `coe_mul` moved up\n\n"}
{"name":"EReal.coe_nsmul","module":"Mathlib.Data.Real.EReal","initialProofState":"n : Nat\nx : Real\n⊢ Eq (↑(HSMul.hSMul n x)) (HSMul.hSMul n ↑x)","decl":"@[norm_cast]\ntheorem coe_nsmul (n : ℕ) (x : ℝ) : (↑(n • x) : EReal) = n • (x : EReal) :=\n  map_nsmul (⟨⟨Real.toEReal, coe_zero⟩, coe_add⟩ : ℝ →+ EReal) _ _\n\n"}
{"name":"EReal.coe_eq_zero","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Iff (Eq (↑x) 0) (Eq x 0)","decl":"@[simp, norm_cast]\ntheorem coe_eq_zero {x : ℝ} : (x : EReal) = 0 ↔ x = 0 :=\n  EReal.coe_eq_coe_iff\n\n"}
{"name":"EReal.coe_eq_one","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Iff (Eq (↑x) 1) (Eq x 1)","decl":"@[simp, norm_cast]\ntheorem coe_eq_one {x : ℝ} : (x : EReal) = 1 ↔ x = 1 :=\n  EReal.coe_eq_coe_iff\n\n"}
{"name":"EReal.coe_ne_zero","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Iff (Ne (↑x) 0) (Ne x 0)","decl":"theorem coe_ne_zero {x : ℝ} : (x : EReal) ≠ 0 ↔ x ≠ 0 :=\n  EReal.coe_ne_coe_iff\n\n"}
{"name":"EReal.coe_ne_one","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Iff (Ne (↑x) 1) (Ne x 1)","decl":"theorem coe_ne_one {x : ℝ} : (x : EReal) ≠ 1 ↔ x ≠ 1 :=\n  EReal.coe_ne_coe_iff\n\n"}
{"name":"EReal.coe_nonneg","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Iff (LE.le 0 ↑x) (LE.le 0 x)","decl":"@[simp, norm_cast]\nprotected theorem coe_nonneg {x : ℝ} : (0 : EReal) ≤ x ↔ 0 ≤ x :=\n  EReal.coe_le_coe_iff\n\n"}
{"name":"EReal.coe_nonpos","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Iff (LE.le (↑x) 0) (LE.le x 0)","decl":"@[simp, norm_cast]\nprotected theorem coe_nonpos {x : ℝ} : (x : EReal) ≤ 0 ↔ x ≤ 0 :=\n  EReal.coe_le_coe_iff\n\n"}
{"name":"EReal.coe_pos","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Iff (LT.lt 0 ↑x) (LT.lt 0 x)","decl":"@[simp, norm_cast]\nprotected theorem coe_pos {x : ℝ} : (0 : EReal) < x ↔ 0 < x :=\n  EReal.coe_lt_coe_iff\n\n"}
{"name":"EReal.coe_neg'","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Iff (LT.lt (↑x) 0) (LT.lt x 0)","decl":"@[simp, norm_cast]\nprotected theorem coe_neg' {x : ℝ} : (x : EReal) < 0 ↔ x < 0 :=\n  EReal.coe_lt_coe_iff\n\n"}
{"name":"EReal.toReal_eq_zero_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Iff (Eq x.toReal 0) (Or (Eq x 0) (Or (Eq x Top.top) (Eq x Bot.bot)))","decl":"lemma toReal_eq_zero_iff {x : EReal} : x.toReal = 0 ↔ x = 0 ∨ x = ⊤ ∨ x = ⊥ := by\n  cases x <;> norm_num\n\n"}
{"name":"EReal.toReal_ne_zero_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Iff (Ne x.toReal 0) (And (Ne x 0) (And (Ne x Top.top) (Ne x Bot.bot)))","decl":"lemma toReal_ne_zero_iff {x : EReal} : x.toReal ≠ 0 ↔ x ≠ 0 ∧ x ≠ ⊤ ∧ x ≠ ⊥ := by\n  simp only [ne_eq, toReal_eq_zero_iff, not_or]\n\n"}
{"name":"EReal.toReal_eq_toReal","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nhx_top : Ne x Top.top\nhx_bot : Ne x Bot.bot\nhy_top : Ne y Top.top\nhy_bot : Ne y Bot.bot\n⊢ Iff (Eq x.toReal y.toReal) (Eq x y)","decl":"lemma toReal_eq_toReal {x y : EReal} (hx_top : x ≠ ⊤) (hx_bot : x ≠ ⊥)\n    (hy_top : y ≠ ⊤) (hy_bot : y ≠ ⊥) :\n    x.toReal = y.toReal ↔ x = y := by\n  lift x to ℝ using ⟨hx_top, hx_bot⟩\n  lift y to ℝ using ⟨hy_top, hy_bot⟩\n  simp\n\n"}
{"name":"EReal.toReal_nonneg","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\nhx : LE.le 0 x\n⊢ LE.le 0 x.toReal","decl":"lemma toReal_nonneg {x : EReal} (hx : 0 ≤ x) : 0 ≤ x.toReal := by\n  cases x\n  · norm_num\n  · exact toReal_coe _ ▸ EReal.coe_nonneg.mp hx\n  · norm_num\n\n"}
{"name":"EReal.toReal_nonpos","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\nhx : LE.le x 0\n⊢ LE.le x.toReal 0","decl":"lemma toReal_nonpos {x : EReal} (hx : x ≤ 0) : x.toReal ≤ 0 := by\n  cases x\n  · norm_num\n  · exact toReal_coe _ ▸ EReal.coe_nonpos.mp hx\n  · norm_num\n\n"}
{"name":"EReal.toReal_le_toReal","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nh : LE.le x y\nhx : Ne x Bot.bot\nhy : Ne y Top.top\n⊢ LE.le x.toReal y.toReal","decl":"theorem toReal_le_toReal {x y : EReal} (h : x ≤ y) (hx : x ≠ ⊥) (hy : y ≠ ⊤) :\n    x.toReal ≤ y.toReal := by\n  lift x to ℝ using ⟨ne_top_of_le_ne_top hy h, hx⟩\n  lift y to ℝ using ⟨hy, ne_bot_of_le_ne_bot hx h⟩\n  simpa using h\n\n"}
{"name":"EReal.coe_toReal","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\nhx : Ne x Top.top\nh'x : Ne x Bot.bot\n⊢ Eq (↑x.toReal) x","decl":"theorem coe_toReal {x : EReal} (hx : x ≠ ⊤) (h'x : x ≠ ⊥) : (x.toReal : EReal) = x := by\n  lift x to ℝ using ⟨hx, h'x⟩\n  rfl\n\n"}
{"name":"EReal.le_coe_toReal","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\nh : Ne x Top.top\n⊢ LE.le x ↑x.toReal","decl":"theorem le_coe_toReal {x : EReal} (h : x ≠ ⊤) : x ≤ x.toReal := by\n  by_cases h' : x = ⊥\n  · simp only [h', bot_le]\n  · simp only [le_refl, coe_toReal h h']\n\n"}
{"name":"EReal.coe_toReal_le","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\nh : Ne x Bot.bot\n⊢ LE.le (↑x.toReal) x","decl":"theorem coe_toReal_le {x : EReal} (h : x ≠ ⊥) : ↑x.toReal ≤ x := by\n  by_cases h' : x = ⊤\n  · simp only [h', le_top]\n  · simp only [le_refl, coe_toReal h' h]\n\n"}
{"name":"EReal.eq_top_iff_forall_lt","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Iff (Eq x Top.top) (∀ (y : Real), LT.lt (↑y) x)","decl":"theorem eq_top_iff_forall_lt (x : EReal) : x = ⊤ ↔ ∀ y : ℝ, (y : EReal) < x := by\n  constructor\n  · rintro rfl\n    exact EReal.coe_lt_top\n  · contrapose!\n    intro h\n    exact ⟨x.toReal, le_coe_toReal h⟩\n\n"}
{"name":"EReal.eq_bot_iff_forall_lt","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Iff (Eq x Bot.bot) (∀ (y : Real), LT.lt x ↑y)","decl":"theorem eq_bot_iff_forall_lt (x : EReal) : x = ⊥ ↔ ∀ y : ℝ, x < (y : EReal) := by\n  constructor\n  · rintro rfl\n    exact bot_lt_coe\n  · contrapose!\n    intro h\n    exact ⟨x.toReal, coe_toReal_le h⟩\n\n"}
{"name":"EReal.exists_between_coe_real","module":"Mathlib.Data.Real.EReal","initialProofState":"x z : EReal\nh : LT.lt x z\n⊢ Exists fun y => And (LT.lt x ↑y) (LT.lt (↑y) z)","decl":"lemma exists_between_coe_real {x z : EReal} (h : x < z) : ∃ y : ℝ, x < y ∧ y < z := by\n  obtain ⟨a, ha₁, ha₂⟩ := exists_between h\n  induction a with\n  | h_bot => exact (not_lt_bot ha₁).elim\n  | h_real a₀ => exact ⟨a₀, ha₁, ha₂⟩\n  | h_top => exact (not_top_lt ha₂).elim\n\n"}
{"name":"EReal.image_coe_Icc","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : Real\n⊢ Eq (Set.image Real.toEReal (Set.Icc x y)) (Set.Icc ↑x ↑y)","decl":"@[simp]\nlemma image_coe_Icc (x y : ℝ) : Real.toEReal '' Icc x y = Icc ↑x ↑y := by\n  refine (image_comp WithBot.some WithTop.some _).trans ?_\n  rw [WithTop.image_coe_Icc, WithBot.image_coe_Icc]\n  rfl\n\n"}
{"name":"EReal.image_coe_Ico","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : Real\n⊢ Eq (Set.image Real.toEReal (Set.Ico x y)) (Set.Ico ↑x ↑y)","decl":"@[simp]\nlemma image_coe_Ico (x y : ℝ) : Real.toEReal '' Ico x y = Ico ↑x ↑y := by\n  refine (image_comp WithBot.some WithTop.some _).trans ?_\n  rw [WithTop.image_coe_Ico, WithBot.image_coe_Ico]\n  rfl\n\n"}
{"name":"EReal.image_coe_Ici","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Eq (Set.image Real.toEReal (Set.Ici x)) (Set.Ico (↑x) Top.top)","decl":"@[simp]\nlemma image_coe_Ici (x : ℝ) : Real.toEReal '' Ici x = Ico ↑x ⊤ := by\n  refine (image_comp WithBot.some WithTop.some _).trans ?_\n  rw [WithTop.image_coe_Ici, WithBot.image_coe_Ico]\n  rfl\n\n"}
{"name":"EReal.image_coe_Ioc","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : Real\n⊢ Eq (Set.image Real.toEReal (Set.Ioc x y)) (Set.Ioc ↑x ↑y)","decl":"@[simp]\nlemma image_coe_Ioc (x y : ℝ) : Real.toEReal '' Ioc x y = Ioc ↑x ↑y := by\n  refine (image_comp WithBot.some WithTop.some _).trans ?_\n  rw [WithTop.image_coe_Ioc, WithBot.image_coe_Ioc]\n  rfl\n\n"}
{"name":"EReal.image_coe_Ioo","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : Real\n⊢ Eq (Set.image Real.toEReal (Set.Ioo x y)) (Set.Ioo ↑x ↑y)","decl":"@[simp]\nlemma image_coe_Ioo (x y : ℝ) : Real.toEReal '' Ioo x y = Ioo ↑x ↑y := by\n  refine (image_comp WithBot.some WithTop.some _).trans ?_\n  rw [WithTop.image_coe_Ioo, WithBot.image_coe_Ioo]\n  rfl\n\n"}
{"name":"EReal.image_coe_Ioi","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Eq (Set.image Real.toEReal (Set.Ioi x)) (Set.Ioo (↑x) Top.top)","decl":"@[simp]\nlemma image_coe_Ioi (x : ℝ) : Real.toEReal '' Ioi x = Ioo ↑x ⊤ := by\n  refine (image_comp WithBot.some WithTop.some _).trans ?_\n  rw [WithTop.image_coe_Ioi, WithBot.image_coe_Ioo]\n  rfl\n\n"}
{"name":"EReal.image_coe_Iic","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Eq (Set.image Real.toEReal (Set.Iic x)) (Set.Ioc Bot.bot ↑x)","decl":"@[simp]\nlemma image_coe_Iic (x : ℝ) : Real.toEReal '' Iic x = Ioc ⊥ ↑x := by\n  refine (image_comp WithBot.some WithTop.some _).trans ?_\n  rw [WithTop.image_coe_Iic, WithBot.image_coe_Iic]\n  rfl\n\n"}
{"name":"EReal.image_coe_Iio","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Eq (Set.image Real.toEReal (Set.Iio x)) (Set.Ioo Bot.bot ↑x)","decl":"@[simp]\nlemma image_coe_Iio (x : ℝ) : Real.toEReal '' Iio x = Ioo ⊥ ↑x := by\n  refine (image_comp WithBot.some WithTop.some _).trans ?_\n  rw [WithTop.image_coe_Iio, WithBot.image_coe_Iio]\n  rfl\n\n"}
{"name":"EReal.preimage_coe_Ici","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Eq (Set.preimage Real.toEReal (Set.Ici ↑x)) (Set.Ici x)","decl":"@[simp]\nlemma preimage_coe_Ici (x : ℝ) : Real.toEReal ⁻¹' Ici x = Ici x := by\n  change (WithBot.some ∘ WithTop.some) ⁻¹' (Ici (WithBot.some (WithTop.some x))) = _\n  refine preimage_comp.trans ?_\n  simp only [WithBot.preimage_coe_Ici, WithTop.preimage_coe_Ici]\n\n"}
{"name":"EReal.preimage_coe_Ioi","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Eq (Set.preimage Real.toEReal (Set.Ioi ↑x)) (Set.Ioi x)","decl":"@[simp]\nlemma preimage_coe_Ioi (x : ℝ) : Real.toEReal ⁻¹' Ioi x = Ioi x := by\n  change (WithBot.some ∘ WithTop.some) ⁻¹' (Ioi (WithBot.some (WithTop.some x))) = _\n  refine preimage_comp.trans ?_\n  simp only [WithBot.preimage_coe_Ioi, WithTop.preimage_coe_Ioi]\n\n"}
{"name":"EReal.preimage_coe_Ioi_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (Set.preimage Real.toEReal (Set.Ioi Bot.bot)) Set.univ","decl":"@[simp]\nlemma preimage_coe_Ioi_bot : Real.toEReal ⁻¹' Ioi ⊥ = univ := by\n  change (WithBot.some ∘ WithTop.some) ⁻¹' (Ioi ⊥) = _\n  refine preimage_comp.trans ?_\n  simp only [WithBot.preimage_coe_Ioi_bot, preimage_univ]\n\n"}
{"name":"EReal.preimage_coe_Iic","module":"Mathlib.Data.Real.EReal","initialProofState":"y : Real\n⊢ Eq (Set.preimage Real.toEReal (Set.Iic ↑y)) (Set.Iic y)","decl":"@[simp]\nlemma preimage_coe_Iic (y : ℝ) : Real.toEReal ⁻¹' Iic y = Iic y := by\n  change (WithBot.some ∘ WithTop.some) ⁻¹' (Iic (WithBot.some (WithTop.some y))) = _\n  refine preimage_comp.trans ?_\n  simp only [WithBot.preimage_coe_Iic, WithTop.preimage_coe_Iic]\n\n"}
{"name":"EReal.preimage_coe_Iio","module":"Mathlib.Data.Real.EReal","initialProofState":"y : Real\n⊢ Eq (Set.preimage Real.toEReal (Set.Iio ↑y)) (Set.Iio y)","decl":"@[simp]\nlemma preimage_coe_Iio (y : ℝ) : Real.toEReal ⁻¹' Iio y = Iio y := by\n  change (WithBot.some ∘ WithTop.some) ⁻¹' (Iio (WithBot.some (WithTop.some y))) = _\n  refine preimage_comp.trans ?_\n  simp only [WithBot.preimage_coe_Iio, WithTop.preimage_coe_Iio]\n\n"}
{"name":"EReal.preimage_coe_Iio_top","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (Set.preimage Real.toEReal (Set.Iio Top.top)) Set.univ","decl":"@[simp]\nlemma preimage_coe_Iio_top : Real.toEReal ⁻¹' Iio ⊤ = univ := by\n  change (WithBot.some ∘ WithTop.some) ⁻¹' (Iio (WithBot.some ⊤)) = _\n  refine preimage_comp.trans ?_\n  simp only [WithBot.preimage_coe_Iio, WithTop.preimage_coe_Iio_top]\n\n"}
{"name":"EReal.preimage_coe_Icc","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : Real\n⊢ Eq (Set.preimage Real.toEReal (Set.Icc ↑x ↑y)) (Set.Icc x y)","decl":"@[simp]\nlemma preimage_coe_Icc (x y : ℝ) : Real.toEReal ⁻¹' Icc x y = Icc x y := by\n  simp_rw [← Ici_inter_Iic]\n  simp\n\n"}
{"name":"EReal.preimage_coe_Ico","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : Real\n⊢ Eq (Set.preimage Real.toEReal (Set.Ico ↑x ↑y)) (Set.Ico x y)","decl":"@[simp]\nlemma preimage_coe_Ico (x y : ℝ) : Real.toEReal ⁻¹' Ico x y = Ico x y := by\n  simp_rw [← Ici_inter_Iio]\n  simp\n\n"}
{"name":"EReal.preimage_coe_Ioc","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : Real\n⊢ Eq (Set.preimage Real.toEReal (Set.Ioc ↑x ↑y)) (Set.Ioc x y)","decl":"@[simp]\nlemma preimage_coe_Ioc (x y : ℝ) : Real.toEReal ⁻¹' Ioc x y = Ioc x y := by\n  simp_rw [← Ioi_inter_Iic]\n  simp\n\n"}
{"name":"EReal.preimage_coe_Ioo","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : Real\n⊢ Eq (Set.preimage Real.toEReal (Set.Ioo ↑x ↑y)) (Set.Ioo x y)","decl":"@[simp]\nlemma preimage_coe_Ioo (x y : ℝ) : Real.toEReal ⁻¹' Ioo x y = Ioo x y := by\n  simp_rw [← Ioi_inter_Iio]\n  simp\n\n"}
{"name":"EReal.preimage_coe_Ico_top","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Eq (Set.preimage Real.toEReal (Set.Ico (↑x) Top.top)) (Set.Ici x)","decl":"@[simp]\nlemma preimage_coe_Ico_top (x : ℝ) : Real.toEReal ⁻¹' Ico x ⊤ = Ici x := by\n  rw [← Ici_inter_Iio]\n  simp\n\n"}
{"name":"EReal.preimage_coe_Ioo_top","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Eq (Set.preimage Real.toEReal (Set.Ioo (↑x) Top.top)) (Set.Ioi x)","decl":"@[simp]\nlemma preimage_coe_Ioo_top (x : ℝ) : Real.toEReal ⁻¹' Ioo x ⊤ = Ioi x := by\n  rw [← Ioi_inter_Iio]\n  simp\n\n"}
{"name":"EReal.preimage_coe_Ioc_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"y : Real\n⊢ Eq (Set.preimage Real.toEReal (Set.Ioc Bot.bot ↑y)) (Set.Iic y)","decl":"@[simp]\nlemma preimage_coe_Ioc_bot (y : ℝ) : Real.toEReal ⁻¹' Ioc ⊥ y = Iic y := by\n  rw [← Ioi_inter_Iic]\n  simp\n\n"}
{"name":"EReal.preimage_coe_Ioo_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"y : Real\n⊢ Eq (Set.preimage Real.toEReal (Set.Ioo Bot.bot ↑y)) (Set.Iio y)","decl":"@[simp]\nlemma preimage_coe_Ioo_bot (y : ℝ) : Real.toEReal ⁻¹' Ioo ⊥ y = Iio y := by\n  rw [← Ioi_inter_Iio]\n  simp\n\n"}
{"name":"EReal.preimage_coe_Ioo_bot_top","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (Set.preimage Real.toEReal (Set.Ioo Bot.bot Top.top)) Set.univ","decl":"@[simp]\nlemma preimage_coe_Ioo_bot_top : Real.toEReal ⁻¹' Ioo ⊥ ⊤ = univ := by\n  rw [← Ioi_inter_Iio]\n  simp\n\n"}
{"name":"EReal.toReal_coe_ennreal","module":"Mathlib.Data.Real.EReal","initialProofState":"x : ENNReal\n⊢ Eq (↑x).toReal x.toReal","decl":"@[simp]\ntheorem toReal_coe_ennreal : ∀ {x : ℝ≥0∞}, toReal (x : EReal) = ENNReal.toReal x\n  | ⊤ => rfl\n  | .some _ => rfl\n\n"}
{"name":"EReal.coe_ennreal_ofReal","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Eq ↑(ENNReal.ofReal x) ↑(Max.max x 0)","decl":"@[simp]\ntheorem coe_ennreal_ofReal {x : ℝ} : (ENNReal.ofReal x : EReal) = max x 0 :=\n  rfl\n\n"}
{"name":"EReal.coe_ennreal_toReal","module":"Mathlib.Data.Real.EReal","initialProofState":"x : ENNReal\nhx : Ne x Top.top\n⊢ Eq ↑x.toReal ↑x","decl":"lemma coe_ennreal_toReal {x : ℝ≥0∞} (hx : x ≠ ∞) : (x.toReal : EReal) = x := by\n  lift x to ℝ≥0 using hx\n  rfl\n\n"}
{"name":"EReal.coe_nnreal_eq_coe_real","module":"Mathlib.Data.Real.EReal","initialProofState":"x : NNReal\n⊢ Eq ↑↑x ↑↑x","decl":"theorem coe_nnreal_eq_coe_real (x : ℝ≥0) : ((x : ℝ≥0∞) : EReal) = (x : ℝ) :=\n  rfl\n\n"}
{"name":"EReal.coe_ennreal_zero","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem coe_ennreal_zero : ((0 : ℝ≥0∞) : EReal) = 0 :=\n  rfl\n\n"}
{"name":"EReal.coe_ennreal_one","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem coe_ennreal_one : ((1 : ℝ≥0∞) : EReal) = 1 :=\n  rfl\n\n"}
{"name":"EReal.coe_ennreal_top","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (↑Top.top) Top.top","decl":"@[simp, norm_cast]\ntheorem coe_ennreal_top : ((⊤ : ℝ≥0∞) : EReal) = ⊤ :=\n  rfl\n\n"}
{"name":"EReal.coe_ennreal_strictMono","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ StrictMono ENNReal.toEReal","decl":"theorem coe_ennreal_strictMono : StrictMono ((↑) : ℝ≥0∞ → EReal) :=\n  WithTop.strictMono_iff.2 ⟨fun _ _ => EReal.coe_lt_coe_iff.2, fun _ => coe_lt_top _⟩\n\n"}
{"name":"EReal.coe_ennreal_injective","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Function.Injective ENNReal.toEReal","decl":"theorem coe_ennreal_injective : Injective ((↑) : ℝ≥0∞ → EReal) :=\n  coe_ennreal_strictMono.injective\n\n"}
{"name":"EReal.coe_ennreal_eq_top_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x : ENNReal\n⊢ Iff (Eq (↑x) Top.top) (Eq x Top.top)","decl":"@[simp]\ntheorem coe_ennreal_eq_top_iff {x : ℝ≥0∞} : (x : EReal) = ⊤ ↔ x = ⊤ :=\n  coe_ennreal_injective.eq_iff' rfl\n\n"}
{"name":"EReal.coe_nnreal_ne_top","module":"Mathlib.Data.Real.EReal","initialProofState":"x : NNReal\n⊢ Ne (↑↑x) Top.top","decl":"theorem coe_nnreal_ne_top (x : ℝ≥0) : ((x : ℝ≥0∞) : EReal) ≠ ⊤ := coe_ne_top x\n\n"}
{"name":"EReal.coe_nnreal_lt_top","module":"Mathlib.Data.Real.EReal","initialProofState":"x : NNReal\n⊢ LT.lt (↑↑x) Top.top","decl":"@[simp]\ntheorem coe_nnreal_lt_top (x : ℝ≥0) : ((x : ℝ≥0∞) : EReal) < ⊤ := coe_lt_top x\n\n"}
{"name":"EReal.coe_ennreal_le_coe_ennreal_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : ENNReal\n⊢ Iff (LE.le ↑x ↑y) (LE.le x y)","decl":"@[simp, norm_cast]\ntheorem coe_ennreal_le_coe_ennreal_iff {x y : ℝ≥0∞} : (x : EReal) ≤ (y : EReal) ↔ x ≤ y :=\n  coe_ennreal_strictMono.le_iff_le\n\n"}
{"name":"EReal.coe_ennreal_lt_coe_ennreal_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : ENNReal\n⊢ Iff (LT.lt ↑x ↑y) (LT.lt x y)","decl":"@[simp, norm_cast]\ntheorem coe_ennreal_lt_coe_ennreal_iff {x y : ℝ≥0∞} : (x : EReal) < (y : EReal) ↔ x < y :=\n  coe_ennreal_strictMono.lt_iff_lt\n\n"}
{"name":"EReal.coe_ennreal_eq_coe_ennreal_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : ENNReal\n⊢ Iff (Eq ↑x ↑y) (Eq x y)","decl":"@[simp, norm_cast]\ntheorem coe_ennreal_eq_coe_ennreal_iff {x y : ℝ≥0∞} : (x : EReal) = (y : EReal) ↔ x = y :=\n  coe_ennreal_injective.eq_iff\n\n"}
{"name":"EReal.coe_ennreal_ne_coe_ennreal_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : ENNReal\n⊢ Iff (Ne ↑x ↑y) (Ne x y)","decl":"theorem coe_ennreal_ne_coe_ennreal_iff {x y : ℝ≥0∞} : (x : EReal) ≠ (y : EReal) ↔ x ≠ y :=\n  coe_ennreal_injective.ne_iff\n\n"}
{"name":"EReal.coe_ennreal_eq_zero","module":"Mathlib.Data.Real.EReal","initialProofState":"x : ENNReal\n⊢ Iff (Eq (↑x) 0) (Eq x 0)","decl":"@[simp, norm_cast]\ntheorem coe_ennreal_eq_zero {x : ℝ≥0∞} : (x : EReal) = 0 ↔ x = 0 := by\n  rw [← coe_ennreal_eq_coe_ennreal_iff, coe_ennreal_zero]\n\n"}
{"name":"EReal.coe_ennreal_eq_one","module":"Mathlib.Data.Real.EReal","initialProofState":"x : ENNReal\n⊢ Iff (Eq (↑x) 1) (Eq x 1)","decl":"@[simp, norm_cast]\ntheorem coe_ennreal_eq_one {x : ℝ≥0∞} : (x : EReal) = 1 ↔ x = 1 := by\n  rw [← coe_ennreal_eq_coe_ennreal_iff, coe_ennreal_one]\n\n"}
{"name":"EReal.coe_ennreal_ne_zero","module":"Mathlib.Data.Real.EReal","initialProofState":"x : ENNReal\n⊢ Iff (Ne (↑x) 0) (Ne x 0)","decl":"@[norm_cast]\ntheorem coe_ennreal_ne_zero {x : ℝ≥0∞} : (x : EReal) ≠ 0 ↔ x ≠ 0 :=\n  coe_ennreal_eq_zero.not\n\n"}
{"name":"EReal.coe_ennreal_ne_one","module":"Mathlib.Data.Real.EReal","initialProofState":"x : ENNReal\n⊢ Iff (Ne (↑x) 1) (Ne x 1)","decl":"@[norm_cast]\ntheorem coe_ennreal_ne_one {x : ℝ≥0∞} : (x : EReal) ≠ 1 ↔ x ≠ 1 :=\n  coe_ennreal_eq_one.not\n\n"}
{"name":"EReal.coe_ennreal_nonneg","module":"Mathlib.Data.Real.EReal","initialProofState":"x : ENNReal\n⊢ LE.le 0 ↑x","decl":"theorem coe_ennreal_nonneg (x : ℝ≥0∞) : (0 : EReal) ≤ x :=\n  coe_ennreal_le_coe_ennreal_iff.2 (zero_le x)\n\n"}
{"name":"EReal.range_coe_ennreal","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (Set.range ENNReal.toEReal) (Set.Ici 0)","decl":"@[simp] theorem range_coe_ennreal : range ((↑) : ℝ≥0∞ → EReal) = Set.Ici 0 :=\n  Subset.antisymm (range_subset_iff.2 coe_ennreal_nonneg) fun x => match x with\n    | ⊥ => fun h => absurd h bot_lt_zero.not_le\n    | ⊤ => fun _ => ⟨⊤, rfl⟩\n    | (x : ℝ) => fun h => ⟨.some ⟨x, EReal.coe_nonneg.1 h⟩, rfl⟩\n\n"}
{"name":"EReal.instCanLiftENNRealToERealLeOfNat","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ CanLift EReal ENNReal ENNReal.toEReal fun x => LE.le 0 x","decl":"instance : CanLift EReal ℝ≥0∞ (↑) (0 ≤ ·) := ⟨range_coe_ennreal.ge⟩\n\n"}
{"name":"EReal.coe_ennreal_pos","module":"Mathlib.Data.Real.EReal","initialProofState":"x : ENNReal\n⊢ Iff (LT.lt 0 ↑x) (LT.lt 0 x)","decl":"@[simp, norm_cast]\ntheorem coe_ennreal_pos {x : ℝ≥0∞} : (0 : EReal) < x ↔ 0 < x := by\n  rw [← coe_ennreal_zero, coe_ennreal_lt_coe_ennreal_iff]\n\n"}
{"name":"EReal.bot_lt_coe_ennreal","module":"Mathlib.Data.Real.EReal","initialProofState":"x : ENNReal\n⊢ LT.lt Bot.bot ↑x","decl":"@[simp]\ntheorem bot_lt_coe_ennreal (x : ℝ≥0∞) : (⊥ : EReal) < x :=\n  (bot_lt_coe 0).trans_le (coe_ennreal_nonneg _)\n\n"}
{"name":"EReal.coe_ennreal_ne_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"x : ENNReal\n⊢ Ne (↑x) Bot.bot","decl":"@[simp]\ntheorem coe_ennreal_ne_bot (x : ℝ≥0∞) : (x : EReal) ≠ ⊥ :=\n  (bot_lt_coe_ennreal x).ne'\n\n"}
{"name":"EReal.coe_ennreal_add","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : ENNReal\n⊢ Eq (↑(HAdd.hAdd x y)) (HAdd.hAdd ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_ennreal_add (x y : ENNReal) : ((x + y : ℝ≥0∞) : EReal) = x + y := by\n  cases x <;> cases y <;> rfl\n\n"}
{"name":"EReal.coe_ennreal_mul","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : ENNReal\n⊢ Eq (↑(HMul.hMul x y)) (HMul.hMul ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_ennreal_mul : ∀ x y : ℝ≥0∞, ((x * y : ℝ≥0∞) : EReal) = (x : EReal) * y\n  | ⊤, ⊤ => rfl\n  | ⊤, (y : ℝ≥0) => coe_ennreal_top_mul y\n  | (x : ℝ≥0), ⊤ => by\n    rw [mul_comm, coe_ennreal_top_mul, EReal.mul_comm, coe_ennreal_top]\n  | (x : ℝ≥0), (y : ℝ≥0) => by\n    simp only [← ENNReal.coe_mul, coe_nnreal_eq_coe_real, NNReal.coe_mul, EReal.coe_mul]\n\n"}
{"name":"EReal.coe_ennreal_nsmul","module":"Mathlib.Data.Real.EReal","initialProofState":"n : Nat\nx : ENNReal\n⊢ Eq (↑(HSMul.hSMul n x)) (HSMul.hSMul n ↑x)","decl":"@[norm_cast]\ntheorem coe_ennreal_nsmul (n : ℕ) (x : ℝ≥0∞) : (↑(n • x) : EReal) = n • (x : EReal) :=\n  map_nsmul (⟨⟨(↑), coe_ennreal_zero⟩, coe_ennreal_add⟩ : ℝ≥0∞ →+ EReal) _ _\n\n"}
{"name":"EReal.toENNReal_top","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq Top.top.toENNReal Top.top","decl":"@[simp] lemma toENNReal_top : (⊤ : EReal).toENNReal = ⊤ := rfl\n\n"}
{"name":"EReal.toENNReal_of_ne_top","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\nhx : Ne x Top.top\n⊢ Eq x.toENNReal (ENNReal.ofReal x.toReal)","decl":"@[simp]\nlemma toENNReal_of_ne_top {x : EReal} (hx : x ≠ ⊤) : x.toENNReal = ENNReal.ofReal x.toReal :=\n  if_neg hx\n\n"}
{"name":"EReal.toENNReal_eq_top_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Iff (Eq x.toENNReal Top.top) (Eq x Top.top)","decl":"@[simp]\nlemma toENNReal_eq_top_iff {x : EReal} : x.toENNReal = ⊤ ↔ x = ⊤ := by\n  by_cases h : x = ⊤\n  · simp [h]\n  · simp [h, toENNReal]\n\n"}
{"name":"EReal.toENNReal_ne_top_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Iff (Ne x.toENNReal Top.top) (Ne x Top.top)","decl":"lemma toENNReal_ne_top_iff {x : EReal} : x.toENNReal ≠ ⊤ ↔ x ≠ ⊤ := toENNReal_eq_top_iff.not\n\n"}
{"name":"EReal.toENNReal_of_nonpos","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\nhx : LE.le x 0\n⊢ Eq x.toENNReal 0","decl":"@[simp]\nlemma toENNReal_of_nonpos {x : EReal} (hx : x ≤ 0) : x.toENNReal = 0 := by\n  rw [toENNReal, if_neg (fun h ↦ ?_)]\n  · exact ENNReal.ofReal_of_nonpos (toReal_nonpos hx)\n  · exact zero_ne_top <| top_le_iff.mp <| h ▸ hx\n\n"}
{"name":"EReal.toENNReal_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq Bot.bot.toENNReal 0","decl":"lemma toENNReal_bot : (⊥ : EReal).toENNReal = 0 := toENNReal_of_nonpos bot_le\n"}
{"name":"EReal.toENNReal_zero","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (EReal.toENNReal 0) 0","decl":"lemma toENNReal_zero : (0 : EReal).toENNReal = 0 := toENNReal_of_nonpos le_rfl\n\n"}
{"name":"EReal.toENNReal_eq_zero_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Iff (Eq x.toENNReal 0) (LE.le x 0)","decl":"lemma toENNReal_eq_zero_iff {x : EReal} : x.toENNReal = 0 ↔ x ≤ 0 := by\n  induction x <;> simp [toENNReal]\n\n"}
{"name":"EReal.toENNReal_ne_zero_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Iff (Ne x.toENNReal 0) (LT.lt 0 x)","decl":"lemma toENNReal_ne_zero_iff {x : EReal} : x.toENNReal ≠ 0 ↔ 0 < x := by\n  simp [toENNReal_eq_zero_iff.not]\n\n"}
{"name":"EReal.coe_toENNReal","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\nhx : LE.le 0 x\n⊢ Eq (↑x.toENNReal) x","decl":"@[simp]\nlemma coe_toENNReal {x : EReal} (hx : 0 ≤ x) : (x.toENNReal : EReal) = x := by\n  rw [toENNReal]\n  by_cases h_top : x = ⊤\n  · rw [if_pos h_top, h_top]\n    rfl\n  rw [if_neg h_top]\n  simp only [coe_ennreal_ofReal, ge_iff_le, hx, toReal_nonneg, max_eq_left]\n  exact coe_toReal h_top fun _ ↦ by simp_all only [le_bot_iff, zero_ne_bot]\n\n"}
{"name":"EReal.coe_toENNReal_eq_max","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Eq (↑x.toENNReal) (Max.max 0 x)","decl":"lemma coe_toENNReal_eq_max {x : EReal} : x.toENNReal = max 0 x := by\n  rcases le_total 0 x with (hx | hx)\n  · rw [coe_toENNReal hx, max_eq_right hx]\n  · rw [toENNReal_of_nonpos hx, max_eq_left hx, coe_ennreal_zero]\n\n"}
{"name":"EReal.toENNReal_coe","module":"Mathlib.Data.Real.EReal","initialProofState":"x : ENNReal\n⊢ Eq (↑x).toENNReal x","decl":"@[simp]\nlemma toENNReal_coe {x : ℝ≥0∞} : (x : EReal).toENNReal = x := by\n  by_cases h_top : x = ⊤\n  · rw [h_top, coe_ennreal_top, toENNReal_top]\n  rwa [toENNReal, if_neg _, toReal_coe_ennreal, ENNReal.ofReal_toReal_eq_iff]\n  simp [h_top]\n\n"}
{"name":"EReal.real_coe_toENNReal","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Eq (↑x).toENNReal (ENNReal.ofReal x)","decl":"@[simp] lemma real_coe_toENNReal (x : ℝ) : (x : EReal).toENNReal = ENNReal.ofReal x := rfl\n\n"}
{"name":"EReal.toReal_toENNReal","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\nhx : LE.le 0 x\n⊢ Eq x.toENNReal.toReal x.toReal","decl":"@[simp]\nlemma toReal_toENNReal {x : EReal} (hx : 0 ≤ x) : x.toENNReal.toReal = x.toReal := by\n  by_cases h : x = ⊤\n  · simp [h]\n  · simp [h, toReal_nonneg hx]\n\n"}
{"name":"EReal.toENNReal_eq_toENNReal","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nhx : LE.le 0 x\nhy : LE.le 0 y\n⊢ Iff (Eq x.toENNReal y.toENNReal) (Eq x y)","decl":"lemma toENNReal_eq_toENNReal {x y : EReal} (hx : 0 ≤ x) (hy : 0 ≤ y) :\n    x.toENNReal = y.toENNReal ↔ x = y := by\n  induction x <;> induction y <;> simp_all\n\n"}
{"name":"EReal.toENNReal_le_toENNReal","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nh : LE.le x y\n⊢ LE.le x.toENNReal y.toENNReal","decl":"lemma toENNReal_le_toENNReal {x y : EReal} (h : x ≤ y) : x.toENNReal ≤ y.toENNReal := by\n  induction x\n  · simp\n  · by_cases hy_top : y = ⊤\n    · simp [hy_top]\n    simp only [toENNReal, coe_ne_top, ↓reduceIte, toReal_coe, hy_top]\n    exact ENNReal.ofReal_le_ofReal <| EReal.toReal_le_toReal h (coe_ne_bot _) hy_top\n  · simp_all\n\n"}
{"name":"EReal.toENNReal_lt_toENNReal","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nhx : LE.le 0 x\nhxy : LT.lt x y\n⊢ LT.lt x.toENNReal y.toENNReal","decl":"lemma toENNReal_lt_toENNReal {x y : EReal} (hx : 0 ≤ x) (hxy : x < y) :\n    x.toENNReal < y.toENNReal :=\n  lt_of_le_of_ne (toENNReal_le_toENNReal hxy.le)\n    fun h ↦ hxy.ne <| (toENNReal_eq_toENNReal hx (hx.trans_lt hxy).le).mp h\n\n"}
{"name":"EReal.coe_coe_eq_natCast","module":"Mathlib.Data.Real.EReal","initialProofState":"n : Nat\n⊢ Eq ↑↑n ↑n","decl":"theorem coe_coe_eq_natCast (n : ℕ) : (n : ℝ) = (n : EReal) := rfl\n\n"}
{"name":"EReal.natCast_ne_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"n : Nat\n⊢ Ne (↑n) Bot.bot","decl":"theorem natCast_ne_bot (n : ℕ) : (n : EReal) ≠ ⊥ := Ne.symm (ne_of_beq_false rfl)\n\n"}
{"name":"EReal.natCast_ne_top","module":"Mathlib.Data.Real.EReal","initialProofState":"n : Nat\n⊢ Ne (↑n) Top.top","decl":"theorem natCast_ne_top (n : ℕ) : (n : EReal) ≠ ⊤ := Ne.symm (ne_of_beq_false rfl)\n\n"}
{"name":"EReal.natCast_eq_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"m n : Nat\n⊢ Iff (Eq ↑m ↑n) (Eq m n)","decl":"@[norm_cast]\ntheorem natCast_eq_iff {m n : ℕ} : (m : EReal) = (n : EReal) ↔ m = n := by\n  rw [← coe_coe_eq_natCast n, ← coe_coe_eq_natCast m, EReal.coe_eq_coe_iff, Nat.cast_inj]\n\n"}
{"name":"EReal.natCast_ne_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"m n : Nat\n⊢ Iff (Ne ↑m ↑n) (Ne m n)","decl":"theorem natCast_ne_iff {m n : ℕ} : (m : EReal) ≠ (n : EReal) ↔ m ≠ n :=\n  not_iff_not.2 natCast_eq_iff\n\n"}
{"name":"EReal.natCast_le_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"m n : Nat\n⊢ Iff (LE.le ↑m ↑n) (LE.le m n)","decl":"@[norm_cast]\ntheorem natCast_le_iff {m n : ℕ} : (m : EReal) ≤ (n : EReal) ↔ m ≤ n := by\n  rw [← coe_coe_eq_natCast n, ← coe_coe_eq_natCast m, EReal.coe_le_coe_iff, Nat.cast_le]\n\n"}
{"name":"EReal.natCast_lt_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"m n : Nat\n⊢ Iff (LT.lt ↑m ↑n) (LT.lt m n)","decl":"@[norm_cast]\ntheorem natCast_lt_iff {m n : ℕ} : (m : EReal) < (n : EReal) ↔ m < n := by\n  rw [← coe_coe_eq_natCast n, ← coe_coe_eq_natCast m, EReal.coe_lt_coe_iff, Nat.cast_lt]\n\n"}
{"name":"EReal.natCast_mul","module":"Mathlib.Data.Real.EReal","initialProofState":"m n : Nat\n⊢ Eq (↑(HMul.hMul m n)) (HMul.hMul ↑m ↑n)","decl":"@[simp, norm_cast]\ntheorem natCast_mul (m n : ℕ) :\n    (m * n : ℕ) = (m : EReal) * (n : EReal) := by\n  rw [← coe_coe_eq_natCast, ← coe_coe_eq_natCast, ← coe_coe_eq_natCast, Nat.cast_mul, EReal.coe_mul]\n\n"}
{"name":"EReal.exists_rat_btwn_of_lt","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\na✝ : LT.lt a b\n⊢ Exists fun x => And (LT.lt a ↑↑x) (LT.lt (↑↑x) b)","decl":"theorem exists_rat_btwn_of_lt :\n    ∀ {a b : EReal}, a < b → ∃ x : ℚ, a < (x : ℝ) ∧ ((x : ℝ) : EReal) < b\n  | ⊤, _, h => (not_top_lt h).elim\n  | (a : ℝ), ⊥, h => (lt_irrefl _ ((bot_lt_coe a).trans h)).elim\n  | (a : ℝ), (b : ℝ), h => by simp [exists_rat_btwn (EReal.coe_lt_coe_iff.1 h)]\n  | (a : ℝ), ⊤, _ =>\n    let ⟨b, hab⟩ := exists_rat_gt a\n    ⟨b, by simpa using hab, coe_lt_top _⟩\n  | ⊥, ⊥, h => (lt_irrefl _ h).elim\n  | ⊥, (a : ℝ), _ =>\n    let ⟨b, hab⟩ := exists_rat_lt a\n    ⟨b, bot_lt_coe _, by simpa using hab⟩\n  | ⊥, ⊤, _ => ⟨0, bot_lt_coe _, coe_lt_top _⟩\n\n"}
{"name":"EReal.lt_iff_exists_rat_btwn","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\n⊢ Iff (LT.lt a b) (Exists fun x => And (LT.lt a ↑↑x) (LT.lt (↑↑x) b))","decl":"theorem lt_iff_exists_rat_btwn {a b : EReal} :\n    a < b ↔ ∃ x : ℚ, a < (x : ℝ) ∧ ((x : ℝ) : EReal) < b :=\n  ⟨fun hab => exists_rat_btwn_of_lt hab, fun ⟨_x, ax, xb⟩ => ax.trans xb⟩\n\n"}
{"name":"EReal.lt_iff_exists_real_btwn","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\n⊢ Iff (LT.lt a b) (Exists fun x => And (LT.lt a ↑x) (LT.lt (↑x) b))","decl":"theorem lt_iff_exists_real_btwn {a b : EReal} : a < b ↔ ∃ x : ℝ, a < x ∧ (x : EReal) < b :=\n  ⟨fun hab =>\n    let ⟨x, ax, xb⟩ := exists_rat_btwn_of_lt hab\n    ⟨(x : ℝ), ax, xb⟩,\n    fun ⟨_x, ax, xb⟩ => ax.trans xb⟩\n\n"}
{"name":"EReal.add_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Eq (HAdd.hAdd x Bot.bot) Bot.bot","decl":"@[simp]\ntheorem add_bot (x : EReal) : x + ⊥ = ⊥ :=\n  WithBot.add_bot _\n\n"}
{"name":"EReal.bot_add","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Eq (HAdd.hAdd Bot.bot x) Bot.bot","decl":"@[simp]\ntheorem bot_add (x : EReal) : ⊥ + x = ⊥ :=\n  WithBot.bot_add _\n\n"}
{"name":"EReal.add_eq_bot_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\n⊢ Iff (Eq (HAdd.hAdd x y) Bot.bot) (Or (Eq x Bot.bot) (Eq y Bot.bot))","decl":"@[simp]\ntheorem add_eq_bot_iff {x y : EReal} : x + y = ⊥ ↔ x = ⊥ ∨ y = ⊥ :=\n  WithBot.add_eq_bot\n\n"}
{"name":"EReal.add_ne_bot_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\n⊢ Iff (Ne (HAdd.hAdd x y) Bot.bot) (And (Ne x Bot.bot) (Ne y Bot.bot))","decl":"lemma add_ne_bot_iff {x y : EReal} : x + y ≠ ⊥ ↔ x ≠ ⊥ ∧ y ≠ ⊥ := WithBot.add_ne_bot\n\n"}
{"name":"EReal.bot_lt_add_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\n⊢ Iff (LT.lt Bot.bot (HAdd.hAdd x y)) (And (LT.lt Bot.bot x) (LT.lt Bot.bot y))","decl":"@[simp]\ntheorem bot_lt_add_iff {x y : EReal} : ⊥ < x + y ↔ ⊥ < x ∧ ⊥ < y := by\n  simp [bot_lt_iff_ne_bot]\n\n"}
{"name":"EReal.top_add_top","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (HAdd.hAdd Top.top Top.top) Top.top","decl":"@[simp]\ntheorem top_add_top : (⊤ : EReal) + ⊤ = ⊤ :=\n  rfl\n\n"}
{"name":"EReal.top_add_coe","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Eq (HAdd.hAdd Top.top ↑x) Top.top","decl":"@[simp]\ntheorem top_add_coe (x : ℝ) : (⊤ : EReal) + x = ⊤ :=\n  rfl\n\n"}
{"name":"EReal.top_add_of_ne_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\nh : Ne x Bot.bot\n⊢ Eq (HAdd.hAdd Top.top x) Top.top","decl":"/-- For any extended real number `x` which is not `⊥`, the sum of `⊤` and `x` is equal to `⊤`. -/\n@[simp]\ntheorem top_add_of_ne_bot {x : EReal} (h : x ≠ ⊥) : ⊤ + x = ⊤ := by\n  induction x\n  · exfalso; exact h (Eq.refl ⊥)\n  · exact top_add_coe _\n  · exact top_add_top\n\n"}
{"name":"EReal.top_add_iff_ne_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Iff (Eq (HAdd.hAdd Top.top x) Top.top) (Ne x Bot.bot)","decl":"/-- For any extended real number `x`, the sum of `⊤` and `x` is equal to `⊤`\nif and only if `x` is not `⊥`. -/\ntheorem top_add_iff_ne_bot {x : EReal} : ⊤ + x = ⊤ ↔ x ≠ ⊥ := by\n  constructor <;> intro h\n  · rintro rfl\n    rw [add_bot] at h\n    exact bot_ne_top h\n  · cases x with\n    | h_bot => contradiction\n    | h_top => rfl\n    | h_real r => exact top_add_of_ne_bot h\n\n"}
{"name":"EReal.add_top_of_ne_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\nh : Ne x Bot.bot\n⊢ Eq (HAdd.hAdd x Top.top) Top.top","decl":"/-- For any extended real number `x` which is not `⊥`, the sum of `x` and `⊤` is equal to `⊤`. -/\n@[simp]\ntheorem add_top_of_ne_bot {x : EReal} (h : x ≠ ⊥) : x + ⊤ = ⊤ := by\n  rw [add_comm, top_add_of_ne_bot h]\n\n"}
{"name":"EReal.add_top_iff_ne_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Iff (Eq (HAdd.hAdd x Top.top) Top.top) (Ne x Bot.bot)","decl":"/-- For any extended real number `x`, the sum of `x` and `⊤` is equal to `⊤`\nif and only if `x` is not `⊥`. -/\ntheorem add_top_iff_ne_bot {x : EReal} : x + ⊤ = ⊤ ↔ x ≠ ⊥ := by rw [add_comm, top_add_iff_ne_bot]\n\n"}
{"name":"EReal.add_pos","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\nha : LT.lt 0 a\nhb : LT.lt 0 b\n⊢ LT.lt 0 (HAdd.hAdd a b)","decl":"/-- For any two extended real numbers `a` and `b`, if both `a` and `b` are greater than `0`,\nthen their sum is also greater than `0`. -/\ntheorem add_pos {a b : EReal} (ha : 0 < a) (hb : 0 < b) : 0 < a + b := by\n  induction a\n  · exfalso; exact not_lt_bot ha\n  · induction b\n    · exfalso; exact not_lt_bot hb\n    · norm_cast at *; exact Left.add_pos ha hb\n    · exact add_top_of_ne_bot (bot_lt_zero.trans ha).ne' ▸ hb\n  · rw [top_add_of_ne_bot (bot_lt_zero.trans hb).ne']\n    exact ha\n\n"}
{"name":"EReal.coe_add_top","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Eq (HAdd.hAdd (↑x) Top.top) Top.top","decl":"@[simp]\ntheorem coe_add_top (x : ℝ) : (x : EReal) + ⊤ = ⊤ :=\n  rfl\n\n"}
{"name":"EReal.toReal_add","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nhx : Ne x Top.top\nh'x : Ne x Bot.bot\nhy : Ne y Top.top\nh'y : Ne y Bot.bot\n⊢ Eq (HAdd.hAdd x y).toReal (HAdd.hAdd x.toReal y.toReal)","decl":"theorem toReal_add {x y : EReal} (hx : x ≠ ⊤) (h'x : x ≠ ⊥) (hy : y ≠ ⊤) (h'y : y ≠ ⊥) :\n    toReal (x + y) = toReal x + toReal y := by\n  lift x to ℝ using ⟨hx, h'x⟩\n  lift y to ℝ using ⟨hy, h'y⟩\n  rfl\n\n"}
{"name":"EReal.toENNReal_add","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nhx : LE.le 0 x\nhy : LE.le 0 y\n⊢ Eq (HAdd.hAdd x y).toENNReal (HAdd.hAdd x.toENNReal y.toENNReal)","decl":"lemma toENNReal_add {x y : EReal} (hx : 0 ≤ x) (hy : 0 ≤ y) :\n    (x + y).toENNReal = x.toENNReal + y.toENNReal := by\n  induction x <;> induction y <;> try {· simp_all}\n  norm_cast\n  simp_rw [real_coe_toENNReal]\n  simp_all [ENNReal.ofReal_add]\n\n"}
{"name":"EReal.toENNReal_add_le","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\n⊢ LE.le (HAdd.hAdd x y).toENNReal (HAdd.hAdd x.toENNReal y.toENNReal)","decl":"lemma toENNReal_add_le {x y : EReal} : (x + y).toENNReal ≤ x.toENNReal + y.toENNReal := by\n  induction x <;> induction y <;> try {· simp}\n  exact ENNReal.ofReal_add_le\n\n"}
{"name":"EReal.addLECancellable_coe","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ AddLECancellable ↑x","decl":"theorem addLECancellable_coe (x : ℝ) : AddLECancellable (x : EReal)\n  | _, ⊤, _ => le_top\n  | ⊥, _, _ => bot_le\n  | ⊤, (z : ℝ), h => by simp only [coe_add_top, ← coe_add, top_le_iff, coe_ne_top] at h\n  | _, ⊥, h => by simpa using h\n  | (y : ℝ), (z : ℝ), h => by\n    simpa only [← coe_add, EReal.coe_le_coe_iff, add_le_add_iff_left] using h\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: add `MulLECancellable.strictMono*` etc\n"}
{"name":"EReal.add_lt_add_right_coe","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nh : LT.lt x y\nz : Real\n⊢ LT.lt (HAdd.hAdd x ↑z) (HAdd.hAdd y ↑z)","decl":"theorem add_lt_add_right_coe {x y : EReal} (h : x < y) (z : ℝ) : x + z < y + z :=\n  not_le.1 <| mt (addLECancellable_coe z).add_le_add_iff_right.1 h.not_le\n\n"}
{"name":"EReal.add_lt_add_left_coe","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nh : LT.lt x y\nz : Real\n⊢ LT.lt (HAdd.hAdd (↑z) x) (HAdd.hAdd (↑z) y)","decl":"theorem add_lt_add_left_coe {x y : EReal} (h : x < y) (z : ℝ) : (z : EReal) + x < z + y := by\n  simpa [add_comm] using add_lt_add_right_coe h z\n\n"}
{"name":"EReal.add_lt_add","module":"Mathlib.Data.Real.EReal","initialProofState":"x y z t : EReal\nh1 : LT.lt x y\nh2 : LT.lt z t\n⊢ LT.lt (HAdd.hAdd x z) (HAdd.hAdd y t)","decl":"theorem add_lt_add {x y z t : EReal} (h1 : x < y) (h2 : z < t) : x + z < y + t := by\n  rcases eq_or_ne x ⊥ with (rfl | hx)\n  · simp [h1, bot_le.trans_lt h2]\n  · lift x to ℝ using ⟨h1.ne_top, hx⟩\n    calc (x : EReal) + z < x + t := add_lt_add_left_coe h2 _\n    _ ≤ y + t := add_le_add_right h1.le _\n\n"}
{"name":"EReal.add_lt_add_of_lt_of_le'","module":"Mathlib.Data.Real.EReal","initialProofState":"x y z t : EReal\nh : LT.lt x y\nh' : LE.le z t\nhbot : Ne t Bot.bot\nhtop : Eq t Top.top → Eq z Top.top → Eq x Bot.bot\n⊢ LT.lt (HAdd.hAdd x z) (HAdd.hAdd y t)","decl":"theorem add_lt_add_of_lt_of_le' {x y z t : EReal} (h : x < y) (h' : z ≤ t) (hbot : t ≠ ⊥)\n    (htop : t = ⊤ → z = ⊤ → x = ⊥) : x + z < y + t := by\n  rcases h'.eq_or_lt with (rfl | hlt)\n  · rcases eq_or_ne z ⊤ with (rfl | hz)\n    · obtain rfl := htop rfl rfl\n      simpa\n    lift z to ℝ using ⟨hz, hbot⟩\n    exact add_lt_add_right_coe h z\n  · exact add_lt_add h hlt\n\n"}
{"name":"EReal.add_lt_add_of_lt_of_le","module":"Mathlib.Data.Real.EReal","initialProofState":"x y z t : EReal\nh : LT.lt x y\nh' : LE.le z t\nhz : Ne z Bot.bot\nht : Ne t Top.top\n⊢ LT.lt (HAdd.hAdd x z) (HAdd.hAdd y t)","decl":"/-- See also `EReal.add_lt_add_of_lt_of_le'` for a version with weaker but less convenient\nassumptions. -/\ntheorem add_lt_add_of_lt_of_le {x y z t : EReal} (h : x < y) (h' : z ≤ t) (hz : z ≠ ⊥)\n    (ht : t ≠ ⊤) : x + z < y + t :=\n  add_lt_add_of_lt_of_le' h h' (ne_bot_of_le_ne_bot hz h') fun ht' => (ht ht').elim\n\n"}
{"name":"EReal.add_lt_top","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nhx : Ne x Top.top\nhy : Ne y Top.top\n⊢ LT.lt (HAdd.hAdd x y) Top.top","decl":"theorem add_lt_top {x y : EReal} (hx : x ≠ ⊤) (hy : y ≠ ⊤) : x + y < ⊤ :=\n  add_lt_add hx.lt_top hy.lt_top\n\n"}
{"name":"EReal.add_ne_top","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nhx : Ne x Top.top\nhy : Ne y Top.top\n⊢ Ne (HAdd.hAdd x y) Top.top","decl":"lemma add_ne_top {x y : EReal} (hx : x ≠ ⊤) (hy : y ≠ ⊤) : x + y ≠ ⊤ :=\n  lt_top_iff_ne_top.mp <| add_lt_top hx hy\n\n"}
{"name":"EReal.add_ne_top_iff_ne_top₂","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nhx : Ne x Bot.bot\nhy : Ne y Bot.bot\n⊢ Iff (Ne (HAdd.hAdd x y) Top.top) (And (Ne x Top.top) (Ne y Top.top))","decl":"lemma add_ne_top_iff_ne_top₂ {x y : EReal} (hx : x ≠ ⊥) (hy : y ≠ ⊥) :\n    x + y ≠ ⊤ ↔ x ≠ ⊤ ∧ y ≠ ⊤ := by\n  refine ⟨?_, fun h ↦ add_ne_top h.1 h.2⟩\n  cases x <;> simp_all only [ne_eq, not_false_eq_true, top_add_of_ne_bot, not_true_eq_false,\n    IsEmpty.forall_iff]\n  cases y <;> simp_all only [not_false_eq_true, ne_eq, add_top_of_ne_bot, not_true_eq_false,\n    coe_ne_top, and_self, implies_true]\n\n"}
{"name":"EReal.add_ne_top_iff_ne_top_left","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nhy : Ne y Bot.bot\nhy' : Ne y Top.top\n⊢ Iff (Ne (HAdd.hAdd x y) Top.top) (Ne x Top.top)","decl":"lemma add_ne_top_iff_ne_top_left {x y : EReal} (hy : y ≠ ⊥) (hy' : y ≠ ⊤) :\n    x + y ≠ ⊤ ↔ x ≠ ⊤ := by\n  cases x <;> simp [add_ne_top_iff_ne_top₂, hy, hy']\n\n"}
{"name":"EReal.add_ne_top_iff_ne_top_right","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nhx : Ne x Bot.bot\nhx' : Ne x Top.top\n⊢ Iff (Ne (HAdd.hAdd x y) Top.top) (Ne y Top.top)","decl":"lemma add_ne_top_iff_ne_top_right {x y : EReal} (hx : x ≠ ⊥) (hx' : x ≠ ⊤) :\n    x + y ≠ ⊤ ↔ y ≠ ⊤ := add_comm x y ▸ add_ne_top_iff_ne_top_left hx hx'\n\n"}
{"name":"EReal.add_ne_top_iff_of_ne_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nhx : Ne x Bot.bot\nhy : Ne y Bot.bot\n⊢ Iff (Ne (HAdd.hAdd x y) Top.top) (And (Ne x Top.top) (Ne y Top.top))","decl":"lemma add_ne_top_iff_of_ne_bot {x y : EReal} (hx : x ≠ ⊥) (hy : y ≠ ⊥) :\n    x + y ≠ ⊤ ↔ x ≠ ⊤ ∧ y ≠ ⊤ := by\n  refine ⟨?_, fun h ↦ add_ne_top h.1 h.2⟩\n  induction x <;> simp_all\n  induction y <;> simp_all\n\n"}
{"name":"EReal.add_ne_top_iff_of_ne_bot_of_ne_top","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nhy : Ne y Bot.bot\nhy' : Ne y Top.top\n⊢ Iff (Ne (HAdd.hAdd x y) Top.top) (Ne x Top.top)","decl":"lemma add_ne_top_iff_of_ne_bot_of_ne_top {x y : EReal} (hy : y ≠ ⊥) (hy' : y ≠ ⊤) :\n    x + y ≠ ⊤ ↔ x ≠ ⊤ := by\n  induction x <;> simp [add_ne_top_iff_of_ne_bot, hy, hy']\n\n"}
{"name":"EReal.neg_top","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (Neg.neg Top.top) Bot.bot","decl":"@[simp]\ntheorem neg_top : -(⊤ : EReal) = ⊥ :=\n  rfl\n\n"}
{"name":"EReal.neg_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (Neg.neg Bot.bot) Top.top","decl":"@[simp]\ntheorem neg_bot : -(⊥ : EReal) = ⊤ :=\n  rfl\n\n"}
{"name":"EReal.coe_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Eq (↑(Neg.neg x)) (Neg.neg ↑x)","decl":"@[simp, norm_cast] theorem coe_neg (x : ℝ) : (↑(-x) : EReal) = -↑x := rfl\n\n"}
{"name":"EReal.coe_sub","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : Real\n⊢ Eq (↑(HSub.hSub x y)) (HSub.hSub ↑x ↑y)","decl":"@[simp, norm_cast] theorem coe_sub (x y : ℝ) : (↑(x - y) : EReal) = x - y := rfl\n\n"}
{"name":"EReal.coe_zsmul","module":"Mathlib.Data.Real.EReal","initialProofState":"n : Int\nx : Real\n⊢ Eq (↑(HSMul.hSMul n x)) (HSMul.hSMul n ↑x)","decl":"@[norm_cast]\ntheorem coe_zsmul (n : ℤ) (x : ℝ) : (↑(n • x) : EReal) = n • (x : EReal) :=\n  map_zsmul' (⟨⟨(↑), coe_zero⟩, coe_add⟩ : ℝ →+ EReal) coe_neg _ _\n\n"}
{"name":"EReal.toReal_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\n⊢ Eq (Neg.neg a).toReal (Neg.neg a.toReal)","decl":"@[simp]\ntheorem toReal_neg : ∀ {a : EReal}, toReal (-a) = -toReal a\n  | ⊤ => by simp\n  | ⊥ => by simp\n  | (x : ℝ) => rfl\n\n"}
{"name":"EReal.neg_eq_top_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Iff (Eq (Neg.neg x) Top.top) (Eq x Bot.bot)","decl":"@[simp]\ntheorem neg_eq_top_iff {x : EReal} : -x = ⊤ ↔ x = ⊥ :=\n  neg_injective.eq_iff' rfl\n\n"}
{"name":"EReal.neg_eq_bot_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Iff (Eq (Neg.neg x) Bot.bot) (Eq x Top.top)","decl":"@[simp]\ntheorem neg_eq_bot_iff {x : EReal} : -x = ⊥ ↔ x = ⊤ :=\n  neg_injective.eq_iff' rfl\n\n"}
{"name":"EReal.neg_eq_zero_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Iff (Eq (Neg.neg x) 0) (Eq x 0)","decl":"@[simp]\ntheorem neg_eq_zero_iff {x : EReal} : -x = 0 ↔ x = 0 :=\n  neg_injective.eq_iff' neg_zero\n\n"}
{"name":"EReal.neg_strictAnti","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ StrictAnti fun x => Neg.neg x","decl":"theorem neg_strictAnti : StrictAnti (- · : EReal → EReal) :=\n  WithBot.strictAnti_iff.2 ⟨WithTop.strictAnti_iff.2\n    ⟨coe_strictMono.comp_strictAnti fun _ _ => neg_lt_neg, fun _ => bot_lt_coe _⟩,\n      WithTop.forall.2 ⟨bot_lt_top, fun _ => coe_lt_top _⟩⟩\n\n"}
{"name":"EReal.neg_le_neg_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\n⊢ Iff (LE.le (Neg.neg a) (Neg.neg b)) (LE.le b a)","decl":"@[simp] theorem neg_le_neg_iff {a b : EReal} : -a ≤ -b ↔ b ≤ a := neg_strictAnti.le_iff_le\n\n"}
{"name":"EReal.neg_lt_neg_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\n⊢ Iff (LT.lt (Neg.neg a) (Neg.neg b)) (LT.lt b a)","decl":"@[simp] theorem neg_lt_neg_iff {a b : EReal} : -a < -b ↔ b < a := neg_strictAnti.lt_iff_lt\n\n"}
{"name":"EReal.neg_le","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\n⊢ Iff (LE.le (Neg.neg a) b) (LE.le (Neg.neg b) a)","decl":"/-- `-a ≤ b` if and only if `-b ≤ a` on `EReal`. -/\nprotected theorem neg_le {a b : EReal} : -a ≤ b ↔ -b ≤ a := by\n rw [← neg_le_neg_iff, neg_neg]\n\n"}
{"name":"EReal.neg_le_of_neg_le","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\nh : LE.le (Neg.neg a) b\n⊢ LE.le (Neg.neg b) a","decl":"/-- If `-a ≤ b` then `-b ≤ a` on `EReal`. -/\nprotected theorem neg_le_of_neg_le {a b : EReal} (h : -a ≤ b) : -b ≤ a := EReal.neg_le.mp h\n\n"}
{"name":"EReal.le_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\n⊢ Iff (LE.le a (Neg.neg b)) (LE.le b (Neg.neg a))","decl":"/-- `a ≤ -b` if and only if `b ≤ -a` on `EReal`. -/\nprotected theorem le_neg {a b : EReal} : a ≤ -b ↔ b ≤ -a := by\n  rw [← neg_le_neg_iff, neg_neg]\n\n"}
{"name":"EReal.le_neg_of_le_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\nh : LE.le a (Neg.neg b)\n⊢ LE.le b (Neg.neg a)","decl":"/-- If `a ≤ -b` then `b ≤ -a` on `EReal`. -/\nprotected theorem le_neg_of_le_neg {a b : EReal} (h : a ≤ -b) : b ≤ -a := EReal.le_neg.mp h\n\n"}
{"name":"EReal.neg_lt_comm","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\n⊢ Iff (LT.lt (Neg.neg a) b) (LT.lt (Neg.neg b) a)","decl":"/-- `-a < b` if and only if `-b < a` on `EReal`. -/\ntheorem neg_lt_comm {a b : EReal} : -a < b ↔ -b < a := by rw [← neg_lt_neg_iff, neg_neg]\n\n"}
{"name":"EReal.neg_lt_iff_neg_lt","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\n⊢ Iff (LT.lt (Neg.neg a) b) (LT.lt (Neg.neg b) a)","decl":"@[deprecated (since := \"2024-11-19\")] alias neg_lt_iff_neg_lt := neg_lt_comm\n\n"}
{"name":"EReal.neg_lt_of_neg_lt","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\nh : LT.lt (Neg.neg a) b\n⊢ LT.lt (Neg.neg b) a","decl":"/-- If `-a < b` then `-b < a` on `EReal`. -/\nprotected theorem neg_lt_of_neg_lt {a b : EReal} (h : -a < b) : -b < a := neg_lt_comm.mp h\n\n"}
{"name":"EReal.lt_neg_comm","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\n⊢ Iff (LT.lt a (Neg.neg b)) (LT.lt b (Neg.neg a))","decl":"/-- `-a < b` if and only if `-b < a` on `EReal`. -/\ntheorem lt_neg_comm {a b : EReal} : a < -b ↔ b < -a := by\n  rw [← neg_lt_neg_iff, neg_neg]\n\n"}
{"name":"EReal.lt_neg_of_lt_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\nh : LT.lt a (Neg.neg b)\n⊢ LT.lt b (Neg.neg a)","decl":"/-- If `a < -b` then `b < -a` on `EReal`. -/\nprotected theorem lt_neg_of_lt_neg {a b : EReal} (h : a < -b) : b < -a := lt_neg_comm.mp h\n\n"}
{"name":"EReal.neg_add","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nh1 : Or (Ne x Bot.bot) (Ne y Top.top)\nh2 : Or (Ne x Top.top) (Ne y Bot.bot)\n⊢ Eq (Neg.neg (HAdd.hAdd x y)) (HSub.hSub (Neg.neg x) y)","decl":"lemma neg_add {x y : EReal} (h1 : x ≠ ⊥ ∨ y ≠ ⊤) (h2 : x ≠ ⊤ ∨ y ≠ ⊥) :\n    - (x + y) = - x - y := by\n  induction x <;> induction y <;> try tauto\n  rw [← coe_add, ← coe_neg, ← coe_neg, ← coe_sub, neg_add']\n\n"}
{"name":"EReal.neg_sub","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nh1 : Or (Ne x Bot.bot) (Ne y Bot.bot)\nh2 : Or (Ne x Top.top) (Ne y Top.top)\n⊢ Eq (Neg.neg (HSub.hSub x y)) (HAdd.hAdd (Neg.neg x) y)","decl":"lemma neg_sub {x y : EReal} (h1 : x ≠ ⊥ ∨ y ≠ ⊥) (h2 : x ≠ ⊤ ∨ y ≠ ⊤) :\n    - (x - y) = - x + y := by\n  rw [sub_eq_add_neg, neg_add _ _, sub_eq_add_neg, neg_neg] <;> simp_all\n\n"}
{"name":"EReal.bot_sub","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Eq (HSub.hSub Bot.bot x) Bot.bot","decl":"@[simp]\ntheorem bot_sub (x : EReal) : ⊥ - x = ⊥ :=\n  bot_add x\n\n"}
{"name":"EReal.sub_top","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Eq (HSub.hSub x Top.top) Bot.bot","decl":"@[simp]\ntheorem sub_top (x : EReal) : x - ⊤ = ⊥ :=\n  add_bot x\n\n"}
{"name":"EReal.top_sub_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (HSub.hSub Top.top Bot.bot) Top.top","decl":"@[simp]\ntheorem top_sub_bot : (⊤ : EReal) - ⊥ = ⊤ :=\n  rfl\n\n"}
{"name":"EReal.top_sub_coe","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Eq (HSub.hSub Top.top ↑x) Top.top","decl":"@[simp]\ntheorem top_sub_coe (x : ℝ) : (⊤ : EReal) - x = ⊤ :=\n  rfl\n\n"}
{"name":"EReal.coe_sub_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Eq (HSub.hSub (↑x) Bot.bot) Top.top","decl":"@[simp]\ntheorem coe_sub_bot (x : ℝ) : (x : EReal) - ⊥ = ⊤ :=\n  rfl\n\n"}
{"name":"EReal.sub_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\nh : Ne x Bot.bot\n⊢ Eq (HSub.hSub x Bot.bot) Top.top","decl":"@[simp]\nlemma sub_bot {x : EReal} (h : x ≠ ⊥) : x - ⊥ = ⊤ := by\n  cases x <;> tauto\n\n"}
{"name":"EReal.top_sub","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\nhx : Ne x Top.top\n⊢ Eq (HSub.hSub Top.top x) Top.top","decl":"@[simp]\nlemma top_sub {x : EReal} (hx : x ≠ ⊤) : ⊤ - x = ⊤ := by\n  cases x <;> tauto\n\n"}
{"name":"EReal.sub_self","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\nh_top : Ne x Top.top\nh_bot : Ne x Bot.bot\n⊢ Eq (HSub.hSub x x) 0","decl":"@[simp]\nlemma sub_self {x : EReal} (h_top : x ≠ ⊤) (h_bot : x ≠ ⊥) : x - x = 0 := by\n  cases x <;> simp_all [← coe_sub]\n\n"}
{"name":"EReal.sub_self_le_zero","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ LE.le (HSub.hSub x x) 0","decl":"lemma sub_self_le_zero {x : EReal} : x - x ≤ 0 := by\n  cases x <;> simp\n\n"}
{"name":"EReal.sub_nonneg","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nh_top : Or (Ne x Top.top) (Ne y Top.top)\nh_bot : Or (Ne x Bot.bot) (Ne y Bot.bot)\n⊢ Iff (LE.le 0 (HSub.hSub x y)) (LE.le y x)","decl":"lemma sub_nonneg {x y : EReal} (h_top : x ≠ ⊤ ∨ y ≠ ⊤) (h_bot : x ≠ ⊥ ∨ y ≠ ⊥) :\n    0 ≤ x - y ↔ y ≤ x := by\n  cases x <;> cases y <;> simp_all [← EReal.coe_sub]\n\n"}
{"name":"EReal.sub_nonpos","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\n⊢ Iff (LE.le (HSub.hSub x y) 0) (LE.le x y)","decl":"lemma sub_nonpos {x y : EReal} : x - y ≤ 0 ↔ x ≤ y := by\n  cases x <;> cases y <;> simp [← EReal.coe_sub]\n\n"}
{"name":"EReal.sub_pos","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\n⊢ Iff (LT.lt 0 (HSub.hSub x y)) (LT.lt y x)","decl":"lemma sub_pos {x y : EReal} : 0 < x - y ↔ y < x := by\n  cases x <;> cases y <;> simp [← EReal.coe_sub]\n\n"}
{"name":"EReal.sub_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nh_top : Or (Ne x Top.top) (Ne y Top.top)\nh_bot : Or (Ne x Bot.bot) (Ne y Bot.bot)\n⊢ Iff (LT.lt (HSub.hSub x y) 0) (LT.lt x y)","decl":"lemma sub_neg {x y : EReal} (h_top : x ≠ ⊤ ∨ y ≠ ⊤) (h_bot : x ≠ ⊥ ∨ y ≠ ⊥) :\n    x - y < 0 ↔ x < y := by\n  cases x <;> cases y <;> simp_all [← EReal.coe_sub]\n\n"}
{"name":"EReal.sub_le_sub","module":"Mathlib.Data.Real.EReal","initialProofState":"x y z t : EReal\nh : LE.le x y\nh' : LE.le t z\n⊢ LE.le (HSub.hSub x z) (HSub.hSub y t)","decl":"theorem sub_le_sub {x y z t : EReal} (h : x ≤ y) (h' : t ≤ z) : x - z ≤ y - t :=\n  add_le_add h (neg_le_neg_iff.2 h')\n\n"}
{"name":"EReal.sub_lt_sub_of_lt_of_le","module":"Mathlib.Data.Real.EReal","initialProofState":"x y z t : EReal\nh : LT.lt x y\nh' : LE.le z t\nhz : Ne z Bot.bot\nht : Ne t Top.top\n⊢ LT.lt (HSub.hSub x t) (HSub.hSub y z)","decl":"theorem sub_lt_sub_of_lt_of_le {x y z t : EReal} (h : x < y) (h' : z ≤ t) (hz : z ≠ ⊥)\n    (ht : t ≠ ⊤) : x - t < y - z :=\n  add_lt_add_of_lt_of_le h (neg_le_neg_iff.2 h') (by simp [ht]) (by simp [hz])\n\n"}
{"name":"EReal.coe_real_ereal_eq_coe_toNNReal_sub_coe_toNNReal","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Eq (↑x) (HSub.hSub ↑↑x.toNNReal ↑↑(Neg.neg x).toNNReal)","decl":"theorem coe_real_ereal_eq_coe_toNNReal_sub_coe_toNNReal (x : ℝ) :\n    (x : EReal) = Real.toNNReal x - Real.toNNReal (-x) := by\n  rcases le_total 0 x with (h | h)\n  · lift x to ℝ≥0 using h\n    rw [Real.toNNReal_of_nonpos (neg_nonpos.mpr x.coe_nonneg), Real.toNNReal_coe, ENNReal.coe_zero,\n      coe_ennreal_zero, sub_zero]\n    rfl\n  · rw [Real.toNNReal_of_nonpos h, ENNReal.coe_zero, coe_ennreal_zero, coe_nnreal_eq_coe_real,\n      Real.coe_toNNReal, zero_sub, coe_neg, neg_neg]\n    exact neg_nonneg.2 h\n\n"}
{"name":"EReal.toReal_sub","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nhx : Ne x Top.top\nh'x : Ne x Bot.bot\nhy : Ne y Top.top\nh'y : Ne y Bot.bot\n⊢ Eq (HSub.hSub x y).toReal (HSub.hSub x.toReal y.toReal)","decl":"theorem toReal_sub {x y : EReal} (hx : x ≠ ⊤) (h'x : x ≠ ⊥) (hy : y ≠ ⊤) (h'y : y ≠ ⊥) :\n    toReal (x - y) = toReal x - toReal y := by\n  lift x to ℝ using ⟨hx, h'x⟩\n  lift y to ℝ using ⟨hy, h'y⟩\n  rfl\n\n"}
{"name":"EReal.toENNReal_sub","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nhy : LE.le 0 y\n⊢ Eq (HSub.hSub x y).toENNReal (HSub.hSub x.toENNReal y.toENNReal)","decl":"lemma toENNReal_sub {x y : EReal} (hy : 0 ≤ y) :\n    (x - y).toENNReal = x.toENNReal - y.toENNReal := by\n  induction x <;> induction y <;> try {· simp_all [zero_tsub, ENNReal.sub_top]}\n  rename_i x y\n  by_cases hxy : x ≤ y\n  · rw [toENNReal_of_nonpos <| sub_nonpos.mpr <| EReal.coe_le_coe_iff.mpr hxy]\n    exact (tsub_eq_zero_of_le <| toENNReal_le_toENNReal <| EReal.coe_le_coe_iff.mpr hxy).symm\n  · rw [toENNReal_of_ne_top (ne_of_beq_false rfl).symm, ← coe_sub, toReal_coe,\n      ofReal_sub x (EReal.coe_nonneg.mp hy)]\n    simp\n\n"}
{"name":"EReal.add_sub_cancel_right","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\nb : Real\n⊢ Eq (HSub.hSub (HAdd.hAdd a ↑b) ↑b) a","decl":"lemma add_sub_cancel_right {a : EReal} {b : Real} : a + b - b = a := by\n  cases a <;> norm_cast\n  exact _root_.add_sub_cancel_right _ _\n\n"}
{"name":"EReal.add_sub_cancel_left","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\nb : Real\n⊢ Eq (HSub.hSub (HAdd.hAdd (↑b) a) ↑b) a","decl":"lemma add_sub_cancel_left {a : EReal} {b : Real} : b + a - b = a := by\n  rw [add_comm, EReal.add_sub_cancel_right]\n\n"}
{"name":"EReal.sub_add_cancel","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\nb : Real\n⊢ Eq (HAdd.hAdd (HSub.hSub a ↑b) ↑b) a","decl":"lemma sub_add_cancel {a : EReal} {b : Real} : a - b + b = a := by\n  rw [add_comm, ← add_sub_assoc, add_sub_cancel_left]\n\n"}
{"name":"EReal.sub_add_cancel_right","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\nb : Real\n⊢ Eq (HSub.hSub (↑b) (HAdd.hAdd a ↑b)) (Neg.neg a)","decl":"lemma sub_add_cancel_right {a : EReal} {b : Real} : b - (a + b) = -a := by\n  cases a <;> norm_cast\n  exact _root_.sub_add_cancel_right _ _\n\n"}
{"name":"EReal.sub_add_cancel_left","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\nb : Real\n⊢ Eq (HSub.hSub (↑b) (HAdd.hAdd (↑b) a)) (Neg.neg a)","decl":"lemma sub_add_cancel_left {a : EReal} {b : Real} : b - (b + a) = -a := by\n  rw [add_comm, sub_add_cancel_right]\n\n"}
{"name":"EReal.le_sub_iff_add_le","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nhb : Or (Ne b Bot.bot) (Ne c Bot.bot)\nht : Or (Ne b Top.top) (Ne c Top.top)\n⊢ Iff (LE.le a (HSub.hSub c b)) (LE.le (HAdd.hAdd a b) c)","decl":"lemma le_sub_iff_add_le {a b c : EReal} (hb : b ≠ ⊥ ∨ c ≠ ⊥) (ht : b ≠ ⊤ ∨ c ≠ ⊤) :\n    a ≤ c - b ↔ a + b ≤ c := by\n  induction b with\n  | h_bot =>\n    simp only [ne_eq, not_true_eq_false, false_or] at hb\n    simp only [sub_bot hb, le_top, add_bot, bot_le]\n  | h_real b =>\n    rw [← (addLECancellable_coe b).add_le_add_iff_right, sub_add_cancel]\n  | h_top =>\n    simp only [ne_eq, not_true_eq_false, false_or, sub_top, le_bot_iff] at ht ⊢\n    refine ⟨fun h ↦ h ▸ (bot_add ⊤).symm ▸ bot_le, fun h ↦ ?_⟩\n    by_contra ha\n    exact (h.trans_lt (Ne.lt_top ht)).ne (add_top_iff_ne_bot.2 ha)\n\n"}
{"name":"EReal.sub_le_iff_le_add","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nh₁ : Or (Ne b Bot.bot) (Ne c Top.top)\nh₂ : Or (Ne b Top.top) (Ne c Bot.bot)\n⊢ Iff (LE.le (HSub.hSub a b) c) (LE.le a (HAdd.hAdd c b))","decl":"lemma sub_le_iff_le_add {a b c : EReal} (h₁ : b ≠ ⊥ ∨ c ≠ ⊤) (h₂ : b ≠ ⊤ ∨ c ≠ ⊥) :\n    a - b ≤ c ↔ a ≤ c + b := by\n  suffices a + (-b) ≤ c ↔ a ≤ c - (-b) by simpa [sub_eq_add_neg]\n  refine (le_sub_iff_add_le ?_ ?_).symm <;> simpa\n\n"}
{"name":"EReal.lt_sub_iff_add_lt","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nh₁ : Or (Ne b Bot.bot) (Ne c Top.top)\nh₂ : Or (Ne b Top.top) (Ne c Bot.bot)\n⊢ Iff (LT.lt c (HSub.hSub a b)) (LT.lt (HAdd.hAdd c b) a)","decl":"protected theorem lt_sub_iff_add_lt {a b c : EReal} (h₁ : b ≠ ⊥ ∨ c ≠ ⊤) (h₂ : b ≠ ⊤ ∨ c ≠ ⊥) :\n    c < a - b ↔ c + b < a :=\n  lt_iff_lt_of_le_iff_le (sub_le_iff_le_add h₁ h₂)\n\n"}
{"name":"EReal.sub_le_of_le_add","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nh : LE.le a (HAdd.hAdd b c)\n⊢ LE.le (HSub.hSub a c) b","decl":"theorem sub_le_of_le_add {a b c : EReal} (h : a ≤ b + c) : a - c ≤ b := by\n  induction c with\n  | h_bot => rw [add_bot, le_bot_iff] at h; simp only [h, bot_sub, bot_le]\n  | h_real c => exact (sub_le_iff_le_add (.inl (coe_ne_bot c)) (.inl (coe_ne_top c))).2 h\n  | h_top => simp only [sub_top, bot_le]\n\n"}
{"name":"EReal.sub_le_of_le_add'","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nh : LE.le a (HAdd.hAdd b c)\n⊢ LE.le (HSub.hSub a b) c","decl":"/-- See also `EReal.sub_le_of_le_add`.-/\ntheorem sub_le_of_le_add' {a b c : EReal} (h : a ≤ b + c) : a - b ≤ c :=\n  sub_le_of_le_add (add_comm b c ▸ h)\n\n"}
{"name":"EReal.add_le_of_le_sub","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nh : LE.le a (HSub.hSub b c)\n⊢ LE.le (HAdd.hAdd a c) b","decl":"lemma add_le_of_le_sub {a b c : EReal} (h : a ≤ b - c) : a + c ≤ b := by\n  rw [← neg_neg c]\n  exact sub_le_of_le_add h\n\n"}
{"name":"EReal.sub_lt_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nh₁ : Or (Ne b Bot.bot) (Ne c Bot.bot)\nh₂ : Or (Ne b Top.top) (Ne c Top.top)\n⊢ Iff (LT.lt (HSub.hSub c b) a) (LT.lt c (HAdd.hAdd a b))","decl":"lemma sub_lt_iff {a b c : EReal} (h₁ : b ≠ ⊥ ∨ c ≠ ⊥) (h₂ : b ≠ ⊤ ∨ c ≠ ⊤) :\n    c - b < a ↔ c < a + b :=\n  lt_iff_lt_of_le_iff_le (le_sub_iff_add_le h₁ h₂)\n\n"}
{"name":"EReal.add_lt_of_lt_sub","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nh : LT.lt a (HSub.hSub b c)\n⊢ LT.lt (HAdd.hAdd a c) b","decl":"lemma add_lt_of_lt_sub {a b c : EReal} (h : a < b - c) : a + c < b := by\n  contrapose! h\n  exact sub_le_of_le_add h\n\n"}
{"name":"EReal.sub_lt_of_lt_add","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nh : LT.lt a (HAdd.hAdd b c)\n⊢ LT.lt (HSub.hSub a c) b","decl":"lemma sub_lt_of_lt_add {a b c : EReal} (h : a < b + c) : a - c < b :=\n  add_lt_of_lt_sub <| by rwa [sub_eq_add_neg, neg_neg]\n\n"}
{"name":"EReal.sub_lt_of_lt_add'","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nh : LT.lt a (HAdd.hAdd b c)\n⊢ LT.lt (HSub.hSub a b) c","decl":"/-- See also `EReal.sub_lt_of_lt_add`.-/\nlemma sub_lt_of_lt_add' {a b c : EReal} (h : a < b + c) : a - b < c :=\n  sub_lt_of_lt_add <| by rwa [add_comm]\n\n"}
{"name":"EReal.le_of_forall_lt_iff_le","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\n⊢ Iff (∀ (z : Real), LT.lt x ↑z → LE.le y ↑z) (LE.le y x)","decl":"lemma le_of_forall_lt_iff_le {x y : EReal} : (∀ z : ℝ, x < z → y ≤ z) ↔ y ≤ x := by\n  refine ⟨fun h ↦ WithBot.le_of_forall_lt_iff_le.1 ?_, fun h _ x_z ↦ h.trans x_z.le⟩\n  rw [WithTop.forall]\n  aesop\n\n"}
{"name":"EReal.ge_of_forall_gt_iff_ge","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\n⊢ Iff (∀ (z : Real), LT.lt (↑z) y → LE.le (↑z) x) (LE.le y x)","decl":"lemma ge_of_forall_gt_iff_ge {x y : EReal} : (∀ z : ℝ, z < y → z ≤ x) ↔ y ≤ x := by\n  refine ⟨fun h ↦ WithBot.ge_of_forall_gt_iff_ge.1 ?_, fun h _ x_z ↦ x_z.le.trans h⟩\n  rw [WithTop.forall]\n  aesop\n\n"}
{"name":"EReal.add_le_of_forall_lt","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nh : ∀ (a' : EReal), LT.lt a' a → ∀ (b' : EReal), LT.lt b' b → LE.le (HAdd.hAdd a' b') c\n⊢ LE.le (HAdd.hAdd a b) c","decl":"lemma add_le_of_forall_lt {a b c : EReal} (h : ∀ a' < a, ∀ b' < b, a' + b' ≤ c) : a + b ≤ c := by\n  refine le_of_forall_lt_imp_le_of_dense fun d hd ↦ ?_\n  obtain ⟨a', ha', hd⟩ := exists_lt_add_left hd\n  obtain ⟨b', hb', hd⟩ := exists_lt_add_right hd\n  exact hd.le.trans (h _ ha' _ hb')\n\n"}
{"name":"EReal.le_add_of_forall_gt","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nh₁ : Or (Ne a Bot.bot) (Ne b Top.top)\nh₂ : Or (Ne a Top.top) (Ne b Bot.bot)\nh : ∀ (a' : EReal), GT.gt a' a → ∀ (b' : EReal), GT.gt b' b → LE.le c (HAdd.hAdd a' b')\n⊢ LE.le c (HAdd.hAdd a b)","decl":"lemma le_add_of_forall_gt {a b c : EReal} (h₁ : a ≠ ⊥ ∨ b ≠ ⊤) (h₂ : a ≠ ⊤ ∨ b ≠ ⊥)\n    (h : ∀ a' > a, ∀ b' > b, c ≤ a' + b') : c ≤ a + b := by\n  rw [← neg_le_neg_iff, neg_add h₁ h₂]\n  refine add_le_of_forall_lt fun a' ha' b' hb' ↦ EReal.le_neg_of_le_neg ?_\n  rw [neg_add (.inr hb'.ne_top) (.inl ha'.ne_top)]\n  exact h _ (EReal.lt_neg_of_lt_neg ha') _ (EReal.lt_neg_of_lt_neg hb')\n\n"}
{"name":"EReal.top_add_le_of_forall_add_le","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nh : ∀ (a' : EReal), LT.lt a' a → ∀ (b' : EReal), LT.lt b' b → LE.le (HAdd.hAdd a' b') c\n⊢ LE.le (HAdd.hAdd a b) c","decl":"@[deprecated (since := \"2024-11-19\")] alias top_add_le_of_forall_add_le := add_le_of_forall_lt\n"}
{"name":"EReal.add_le_of_forall_add_le","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nh : ∀ (a' : EReal), LT.lt a' a → ∀ (b' : EReal), LT.lt b' b → LE.le (HAdd.hAdd a' b') c\n⊢ LE.le (HAdd.hAdd a b) c","decl":"@[deprecated (since := \"2024-11-19\")] alias add_le_of_forall_add_le := add_le_of_forall_lt\n"}
{"name":"EReal.le_add_of_forall_le_add","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nh₁ : Or (Ne a Bot.bot) (Ne b Top.top)\nh₂ : Or (Ne a Top.top) (Ne b Bot.bot)\nh : ∀ (a' : EReal), GT.gt a' a → ∀ (b' : EReal), GT.gt b' b → LE.le c (HAdd.hAdd a' b')\n⊢ LE.le c (HAdd.hAdd a b)","decl":"@[deprecated (since := \"2024-11-19\")] alias le_add_of_forall_le_add := le_add_of_forall_gt\n\n"}
{"name":"ENNReal.toEReal_sub","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : ENNReal\nhy_top : Ne y Top.top\nh_le : LE.le y x\n⊢ Eq (↑(HSub.hSub x y)) (HSub.hSub ↑x ↑y)","decl":"lemma _root_.ENNReal.toEReal_sub {x y : ℝ≥0∞} (hy_top : y ≠ ∞) (h_le : y ≤ x) :\n    (x - y).toEReal = x.toEReal - y.toEReal := by\n  lift y to ℝ≥0 using hy_top\n  cases x with\n  | top => simp [coe_nnreal_eq_coe_real]\n  | coe x =>\n    simp only [coe_nnreal_eq_coe_real, ← ENNReal.coe_sub, NNReal.coe_sub (mod_cast h_le), coe_sub]\n\n"}
{"name":"EReal.top_mul_top","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (HMul.hMul Top.top Top.top) Top.top","decl":"@[simp] lemma top_mul_top : (⊤ : EReal) * ⊤ = ⊤ := rfl\n\n"}
{"name":"EReal.top_mul_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (HMul.hMul Top.top Bot.bot) Bot.bot","decl":"@[simp] lemma top_mul_bot : (⊤ : EReal) * ⊥ = ⊥ := rfl\n\n"}
{"name":"EReal.bot_mul_top","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (HMul.hMul Bot.bot Top.top) Bot.bot","decl":"@[simp] lemma bot_mul_top : (⊥ : EReal) * ⊤ = ⊥ := rfl\n\n"}
{"name":"EReal.bot_mul_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (HMul.hMul Bot.bot Bot.bot) Top.top","decl":"@[simp] lemma bot_mul_bot : (⊥ : EReal) * ⊥ = ⊤ := rfl\n\n"}
{"name":"EReal.coe_mul_top_of_pos","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\nh : LT.lt 0 x\n⊢ Eq (HMul.hMul (↑x) Top.top) Top.top","decl":"lemma coe_mul_top_of_pos {x : ℝ} (h : 0 < x) : (x : EReal) * ⊤ = ⊤ :=\n  if_pos h\n\n"}
{"name":"EReal.coe_mul_top_of_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\nh : LT.lt x 0\n⊢ Eq (HMul.hMul (↑x) Top.top) Bot.bot","decl":"lemma coe_mul_top_of_neg {x : ℝ} (h : x < 0) : (x : EReal) * ⊤ = ⊥ :=\n  (if_neg h.not_lt).trans (if_neg h.ne)\n\n"}
{"name":"EReal.top_mul_coe_of_pos","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\nh : LT.lt 0 x\n⊢ Eq (HMul.hMul Top.top ↑x) Top.top","decl":"lemma top_mul_coe_of_pos {x : ℝ} (h : 0 < x) : (⊤ : EReal) * x = ⊤ :=\n  if_pos h\n\n"}
{"name":"EReal.top_mul_coe_of_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\nh : LT.lt x 0\n⊢ Eq (HMul.hMul Top.top ↑x) Bot.bot","decl":"lemma top_mul_coe_of_neg {x : ℝ} (h : x < 0) : (⊤ : EReal) * x = ⊥ :=\n  (if_neg h.not_lt).trans (if_neg h.ne)\n\n"}
{"name":"EReal.mul_top_of_pos","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\na✝ : LT.lt 0 x\n⊢ Eq (HMul.hMul x Top.top) Top.top","decl":"lemma mul_top_of_pos : ∀ {x : EReal}, 0 < x → x * ⊤ = ⊤\n  | ⊥, h => absurd h not_lt_bot\n  | (x : ℝ), h => coe_mul_top_of_pos (EReal.coe_pos.1 h)\n  | ⊤, _ => rfl\n\n"}
{"name":"EReal.mul_top_of_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\na✝ : LT.lt x 0\n⊢ Eq (HMul.hMul x Top.top) Bot.bot","decl":"lemma mul_top_of_neg : ∀ {x : EReal}, x < 0 → x * ⊤ = ⊥\n  | ⊥, _ => rfl\n  | (x : ℝ), h => coe_mul_top_of_neg (EReal.coe_neg'.1 h)\n  | ⊤, h => absurd h not_top_lt\n\n"}
{"name":"EReal.top_mul_of_pos","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\nh : LT.lt 0 x\n⊢ Eq (HMul.hMul Top.top x) Top.top","decl":"lemma top_mul_of_pos {x : EReal} (h : 0 < x) : ⊤ * x = ⊤ := by\n  rw [EReal.mul_comm]\n  exact mul_top_of_pos h\n\n"}
{"name":"EReal.top_mul_of_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\nh : LT.lt x 0\n⊢ Eq (HMul.hMul Top.top x) Bot.bot","decl":"lemma top_mul_of_neg {x : EReal} (h : x < 0) : ⊤ * x = ⊥ := by\n  rw [EReal.mul_comm]\n  exact mul_top_of_neg h\n\n"}
{"name":"EReal.top_mul_coe_ennreal","module":"Mathlib.Data.Real.EReal","initialProofState":"x : ENNReal\nhx : Ne x 0\n⊢ Eq (HMul.hMul Top.top ↑x) Top.top","decl":"lemma top_mul_coe_ennreal {x : ℝ≥0∞} (hx : x ≠ 0) : ⊤ * (x : EReal) = ⊤ :=\n  top_mul_of_pos <| coe_ennreal_pos.mpr <| pos_iff_ne_zero.mpr hx\n\n"}
{"name":"EReal.coe_ennreal_mul_top","module":"Mathlib.Data.Real.EReal","initialProofState":"x : ENNReal\nhx : Ne x 0\n⊢ Eq (HMul.hMul (↑x) Top.top) Top.top","decl":"lemma coe_ennreal_mul_top {x : ℝ≥0∞} (hx : x ≠ 0) : (x : EReal) * ⊤ = ⊤ := by\n  rw [EReal.mul_comm, top_mul_coe_ennreal hx]\n\n"}
{"name":"EReal.coe_mul_bot_of_pos","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\nh : LT.lt 0 x\n⊢ Eq (HMul.hMul (↑x) Bot.bot) Bot.bot","decl":"lemma coe_mul_bot_of_pos {x : ℝ} (h : 0 < x) : (x : EReal) * ⊥ = ⊥ :=\n  if_pos h\n\n"}
{"name":"EReal.coe_mul_bot_of_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\nh : LT.lt x 0\n⊢ Eq (HMul.hMul (↑x) Bot.bot) Top.top","decl":"lemma coe_mul_bot_of_neg {x : ℝ} (h : x < 0) : (x : EReal) * ⊥ = ⊤ :=\n  (if_neg h.not_lt).trans (if_neg h.ne)\n\n"}
{"name":"EReal.bot_mul_coe_of_pos","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\nh : LT.lt 0 x\n⊢ Eq (HMul.hMul Bot.bot ↑x) Bot.bot","decl":"lemma bot_mul_coe_of_pos {x : ℝ} (h : 0 < x) : (⊥ : EReal) * x = ⊥ :=\n  if_pos h\n\n"}
{"name":"EReal.bot_mul_coe_of_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\nh : LT.lt x 0\n⊢ Eq (HMul.hMul Bot.bot ↑x) Top.top","decl":"lemma bot_mul_coe_of_neg {x : ℝ} (h : x < 0) : (⊥ : EReal) * x = ⊤ :=\n  (if_neg h.not_lt).trans (if_neg h.ne)\n\n"}
{"name":"EReal.mul_bot_of_pos","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\na✝ : LT.lt 0 x\n⊢ Eq (HMul.hMul x Bot.bot) Bot.bot","decl":"lemma mul_bot_of_pos : ∀ {x : EReal}, 0 < x → x * ⊥ = ⊥\n  | ⊥, h => absurd h not_lt_bot\n  | (x : ℝ), h => coe_mul_bot_of_pos (EReal.coe_pos.1 h)\n  | ⊤, _ => rfl\n\n"}
{"name":"EReal.mul_bot_of_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\na✝ : LT.lt x 0\n⊢ Eq (HMul.hMul x Bot.bot) Top.top","decl":"lemma mul_bot_of_neg : ∀ {x : EReal}, x < 0 → x * ⊥ = ⊤\n  | ⊥, _ => rfl\n  | (x : ℝ), h => coe_mul_bot_of_neg (EReal.coe_neg'.1 h)\n  | ⊤, h => absurd h not_top_lt\n\n"}
{"name":"EReal.bot_mul_of_pos","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\nh : LT.lt 0 x\n⊢ Eq (HMul.hMul Bot.bot x) Bot.bot","decl":"lemma bot_mul_of_pos {x : EReal} (h : 0 < x) : ⊥ * x = ⊥ := by\n  rw [EReal.mul_comm]\n  exact mul_bot_of_pos h\n\n"}
{"name":"EReal.bot_mul_of_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\nh : LT.lt x 0\n⊢ Eq (HMul.hMul Bot.bot x) Top.top","decl":"lemma bot_mul_of_neg {x : EReal} (h : x < 0) : ⊥ * x = ⊤ := by\n  rw [EReal.mul_comm]\n  exact mul_bot_of_neg h\n\n"}
{"name":"EReal.toReal_mul","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\n⊢ Eq (HMul.hMul x y).toReal (HMul.hMul x.toReal y.toReal)","decl":"lemma toReal_mul {x y : EReal} : toReal (x * y) = toReal x * toReal y := by\n  induction x, y using induction₂_symm with\n  | top_zero | zero_bot | top_top | top_bot | bot_bot => simp\n  | symm h => rwa [mul_comm, EReal.mul_comm]\n  | coe_coe => norm_cast\n  | top_pos _ h => simp [top_mul_coe_of_pos h]\n  | top_neg _ h => simp [top_mul_coe_of_neg h]\n  | pos_bot _ h => simp [coe_mul_bot_of_pos h]\n  | neg_bot _ h => simp [coe_mul_bot_of_neg h]\n\n"}
{"name":"EReal.instNoZeroDivisors","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ NoZeroDivisors EReal","decl":"instance : NoZeroDivisors EReal where\n  eq_zero_or_eq_zero_of_mul_eq_zero := by\n    intro a b h\n    contrapose! h\n    cases a <;> cases b <;> try {· simp_all [← EReal.coe_mul]}\n    · rcases lt_or_gt_of_ne h.2 with (h | h)\n        <;> simp [EReal.bot_mul_of_neg, EReal.bot_mul_of_pos, h]\n    · rcases lt_or_gt_of_ne h.1 with (h | h)\n        <;> simp [EReal.mul_bot_of_pos, EReal.mul_bot_of_neg, h]\n    · rcases lt_or_gt_of_ne h.1 with (h | h)\n        <;> simp [EReal.mul_top_of_neg, EReal.mul_top_of_pos, h]\n    · rcases lt_or_gt_of_ne h.2 with (h | h)\n        <;> simp [EReal.top_mul_of_pos, EReal.top_mul_of_neg, h]\n\n"}
{"name":"EReal.mul_pos_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\n⊢ Iff (LT.lt 0 (HMul.hMul a b)) (Or (And (LT.lt 0 a) (LT.lt 0 b)) (And (LT.lt a 0) (LT.lt b 0)))","decl":"lemma mul_pos_iff {a b : EReal} : 0 < a * b ↔ 0 < a ∧ 0 < b ∨ a < 0 ∧ b < 0 := by\n  induction a, b using EReal.induction₂_symm with\n  | symm h => simp [EReal.mul_comm, h, and_comm]\n  | top_top => simp\n  | top_pos _ hx => simp [EReal.top_mul_coe_of_pos hx, hx]\n  | top_zero => simp\n  | top_neg _ hx => simp [hx, EReal.top_mul_coe_of_neg hx, le_of_lt]\n  | top_bot => simp\n  | pos_bot _ hx => simp [hx, EReal.coe_mul_bot_of_pos hx, le_of_lt]\n  | coe_coe x y => simp [← coe_mul, _root_.mul_pos_iff]\n  | zero_bot => simp\n  | neg_bot _ hx => simp [hx, EReal.coe_mul_bot_of_neg hx]\n  | bot_bot => simp\n\n"}
{"name":"EReal.mul_nonneg_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\n⊢ Iff (LE.le 0 (HMul.hMul a b)) (Or (And (LE.le 0 a) (LE.le 0 b)) (And (LE.le a 0) (LE.le b 0)))","decl":"lemma mul_nonneg_iff {a b : EReal} : 0 ≤ a * b ↔ 0 ≤ a ∧ 0 ≤ b ∨ a ≤ 0 ∧ b ≤ 0 := by\n  simp_rw [le_iff_lt_or_eq, mul_pos_iff, zero_eq_mul (a := a)]\n  rcases lt_trichotomy a 0 with (h | h | h) <;> rcases lt_trichotomy b 0 with (h' | h' | h')\n    <;> simp only [h, h', true_or, true_and, or_true, and_true] <;> tauto\n\n"}
{"name":"EReal.mul_pos","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\nha : LT.lt 0 a\nhb : LT.lt 0 b\n⊢ LT.lt 0 (HMul.hMul a b)","decl":"/-- The product of two positive extended real numbers is positive. -/\nlemma mul_pos {a b : EReal} (ha : 0 < a) (hb : 0 < b) : 0 < a * b :=\n  mul_pos_iff.mpr (Or.inl ⟨ha, hb⟩)\n\n"}
{"name":"EReal.induction₂_neg_left","module":"Mathlib.Data.Real.EReal","initialProofState":"P : EReal → EReal → Prop\nneg_left : ∀ {x y : EReal}, P x y → P (Neg.neg x) y\ntop_top : P Top.top Top.top\ntop_pos : ∀ (x : Real), LT.lt 0 x → P Top.top ↑x\ntop_zero : P Top.top 0\ntop_neg : ∀ (x : Real), LT.lt x 0 → P Top.top ↑x\ntop_bot : P Top.top Bot.bot\nzero_top : P 0 Top.top\nzero_bot : P 0 Bot.bot\npos_top : ∀ (x : Real), LT.lt 0 x → P (↑x) Top.top\npos_bot : ∀ (x : Real), LT.lt 0 x → P (↑x) Bot.bot\ncoe_coe : ∀ (x y : Real), P ↑x ↑y\nx y : EReal\n⊢ P x y","decl":"/-- Induct on two ereals by performing case splits on the sign of one whenever the other is\ninfinite. This version eliminates some cases by assuming that `P x y` implies `P (-x) y` for all\n`x`, `y`. -/\n@[elab_as_elim]\nlemma induction₂_neg_left {P : EReal → EReal → Prop} (neg_left : ∀ {x y}, P x y → P (-x) y)\n    (top_top : P ⊤ ⊤) (top_pos : ∀ x : ℝ, 0 < x → P ⊤ x)\n    (top_zero : P ⊤ 0) (top_neg : ∀ x : ℝ, x < 0 → P ⊤ x) (top_bot : P ⊤ ⊥)\n    (zero_top : P 0 ⊤) (zero_bot : P 0 ⊥)\n    (pos_top : ∀ x : ℝ, 0 < x → P x ⊤) (pos_bot : ∀ x : ℝ, 0 < x → P x ⊥)\n    (coe_coe : ∀ x y : ℝ, P x y) : ∀ x y, P x y :=\n  have : ∀ y, (∀ x : ℝ, 0 < x → P x y) → ∀ x : ℝ, x < 0 → P x y := fun _ h x hx =>\n    neg_neg (x : EReal) ▸ neg_left <| h _ (neg_pos_of_neg hx)\n  @induction₂ P top_top top_pos top_zero top_neg top_bot pos_top pos_bot zero_top\n    coe_coe zero_bot (this _ pos_top) (this _ pos_bot) (neg_left top_top)\n    (fun x hx => neg_left <| top_pos x hx) (neg_left top_zero)\n    (fun x hx => neg_left <| top_neg x hx) (neg_left top_bot)\n\n"}
{"name":"EReal.induction₂_symm_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"P : EReal → EReal → Prop\nsymm : ∀ {x y : EReal}, P x y → P y x\nneg_left : ∀ {x y : EReal}, P x y → P (Neg.neg x) y\ntop_top : P Top.top Top.top\ntop_pos : ∀ (x : Real), LT.lt 0 x → P Top.top ↑x\ntop_zero : P Top.top 0\ncoe_coe : ∀ (x y : Real), P ↑x ↑y\nx y : EReal\n⊢ P x y","decl":"/-- Induct on two ereals by performing case splits on the sign of one whenever the other is\ninfinite. This version eliminates some cases by assuming that `P` is symmetric and `P x y` implies\n`P (-x) y` for all `x`, `y`. -/\n@[elab_as_elim]\nlemma induction₂_symm_neg {P : EReal → EReal → Prop}\n    (symm : ∀ {x y}, P x y → P y x)\n    (neg_left : ∀ {x y}, P x y → P (-x) y) (top_top : P ⊤ ⊤)\n    (top_pos : ∀ x : ℝ, 0 < x → P ⊤ x) (top_zero : P ⊤ 0) (coe_coe : ∀ x y : ℝ, P x y) :\n    ∀ x y, P x y :=\n  have neg_right : ∀ {x y}, P x y → P x (-y) := fun h => symm <| neg_left <| symm h\n  have : ∀ x, (∀ y : ℝ, 0 < y → P x y) → ∀ y : ℝ, y < 0 → P x y := fun _ h y hy =>\n    neg_neg (y : EReal) ▸ neg_right (h _ (neg_pos_of_neg hy))\n  @induction₂_neg_left P neg_left top_top top_pos top_zero (this _ top_pos) (neg_right top_top)\n    (symm top_zero) (symm <| neg_left top_zero) (fun x hx => symm <| top_pos x hx)\n    (fun x hx => symm <| neg_left <| top_pos x hx) coe_coe\n\n"}
{"name":"EReal.neg_mul","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\n⊢ Eq (HMul.hMul (Neg.neg x) y) (Neg.neg (HMul.hMul x y))","decl":"protected lemma neg_mul (x y : EReal) : -x * y = -(x * y) := by\n  induction x, y using induction₂_neg_left with\n  | top_zero | zero_top | zero_bot => simp only [zero_mul, mul_zero, neg_zero]\n  | top_top | top_bot => rfl\n  | neg_left h => rw [h, neg_neg, neg_neg]\n  | coe_coe => norm_cast; exact neg_mul _ _\n  | top_pos _ h => rw [top_mul_coe_of_pos h, neg_top, bot_mul_coe_of_pos h]\n  | pos_top _ h => rw [coe_mul_top_of_pos h, neg_top, ← coe_neg,\n    coe_mul_top_of_neg (neg_neg_of_pos h)]\n  | top_neg _ h => rw [top_mul_coe_of_neg h, neg_top, bot_mul_coe_of_neg h, neg_bot]\n  | pos_bot _ h => rw [coe_mul_bot_of_pos h, neg_bot, ← coe_neg,\n    coe_mul_bot_of_neg (neg_neg_of_pos h)]\n\n"}
{"name":"EReal.mul_neg_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\n⊢ Iff (LT.lt (HMul.hMul a b) 0) (Or (And (LT.lt 0 a) (LT.lt b 0)) (And (LT.lt a 0) (LT.lt 0 b)))","decl":"lemma mul_neg_iff {a b : EReal} : a * b < 0 ↔ 0 < a ∧ b < 0 ∨ a < 0 ∧ 0 < b := by\n  nth_rw 1 [← neg_zero]\n  rw [lt_neg_comm, ← mul_neg a, mul_pos_iff, neg_lt_comm, lt_neg_comm, neg_zero]\n\n"}
{"name":"EReal.mul_nonpos_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\n⊢ Iff (LE.le (HMul.hMul a b) 0) (Or (And (LE.le 0 a) (LE.le b 0)) (And (LE.le a 0) (LE.le 0 b)))","decl":"lemma mul_nonpos_iff {a b : EReal} : a * b ≤ 0 ↔ 0 ≤ a ∧ b ≤ 0 ∨ a ≤ 0 ∧ 0 ≤ b := by\n  nth_rw 1 [← neg_zero]\n  rw [EReal.le_neg, ← mul_neg, mul_nonneg_iff, EReal.neg_le, EReal.le_neg, neg_zero]\n\n"}
{"name":"EReal.mul_eq_top","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\n⊢ Iff (Eq (HMul.hMul a b) Top.top) (Or (And (Eq a Bot.bot) (LT.lt b 0)) (Or (And (LT.lt a 0) (Eq b Bot.bot)) (Or (And (Eq a Top.top) (LT.lt 0 b)) (And (LT.lt 0 a) (Eq b Top.top)))))","decl":"lemma mul_eq_top (a b : EReal) :\n    a * b = ⊤ ↔ (a = ⊥ ∧ b < 0) ∨ (a < 0 ∧ b = ⊥) ∨ (a = ⊤ ∧ 0 < b) ∨ (0 < a ∧ b = ⊤) := by\n  induction a, b using EReal.induction₂_symm with\n  | symm h =>\n    rw [EReal.mul_comm, h]\n    refine ⟨fun H ↦ ?_, fun H ↦ ?_⟩ <;>\n    cases H with\n      | inl h => exact Or.inr (Or.inl ⟨h.2, h.1⟩)\n      | inr h => cases h with\n        | inl h => exact Or.inl ⟨h.2, h.1⟩\n        | inr h => cases h with\n          | inl h => exact Or.inr (Or.inr (Or.inr ⟨h.2, h.1⟩))\n          | inr h => exact Or.inr (Or.inr (Or.inl ⟨h.2, h.1⟩))\n  | top_top => simp\n  | top_pos _ hx => simp [EReal.top_mul_coe_of_pos hx, hx]\n  | top_zero => simp\n  | top_neg _ hx => simp [hx.le, EReal.top_mul_coe_of_neg hx]\n  | top_bot => simp\n  | pos_bot _ hx => simp [hx.le, EReal.coe_mul_bot_of_pos hx]\n  | coe_coe x y =>\n    simpa only [EReal.coe_ne_bot, EReal.coe_neg', false_and, and_false, EReal.coe_ne_top,\n      EReal.coe_pos, or_self, iff_false, EReal.coe_mul] using EReal.coe_ne_top _\n  | zero_bot => simp\n  | neg_bot _ hx => simp [hx, EReal.coe_mul_bot_of_neg hx]\n  | bot_bot => simp\n\n"}
{"name":"EReal.mul_ne_top","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\n⊢ Iff (Ne (HMul.hMul a b) Top.top) (And (Or (Ne a Bot.bot) (LE.le 0 b)) (And (Or (LE.le 0 a) (Ne b Bot.bot)) (And (Or (Ne a Top.top) (LE.le b 0)) (Or (LE.le a 0) (Ne b Top.top)))))","decl":"lemma mul_ne_top (a b : EReal) :\n    a * b ≠ ⊤ ↔ (a ≠ ⊥ ∨ 0 ≤ b) ∧ (0 ≤ a ∨ b ≠ ⊥) ∧ (a ≠ ⊤ ∨ b ≤ 0) ∧ (a ≤ 0 ∨ b ≠ ⊤) := by\n  rw [ne_eq, mul_eq_top]\n  -- push the negation while keeping the disjunctions, that is converting `¬(p ∧ q)` into `¬p ∨ ¬q`\n  -- rather than `p → ¬q`, since we already have disjunctions in the rhs\n  set_option push_neg.use_distrib true in push_neg\n  rfl\n\n"}
{"name":"EReal.mul_eq_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\n⊢ Iff (Eq (HMul.hMul a b) Bot.bot) (Or (And (Eq a Bot.bot) (LT.lt 0 b)) (Or (And (LT.lt 0 a) (Eq b Bot.bot)) (Or (And (Eq a Top.top) (LT.lt b 0)) (And (LT.lt a 0) (Eq b Top.top)))))","decl":"lemma mul_eq_bot (a b : EReal) :\n    a * b = ⊥ ↔ (a = ⊥ ∧ 0 < b) ∨ (0 < a ∧ b = ⊥) ∨ (a = ⊤ ∧ b < 0) ∨ (a < 0 ∧ b = ⊤) := by\n  rw [← neg_eq_top_iff, ← EReal.neg_mul, mul_eq_top, neg_eq_bot_iff, neg_eq_top_iff,\n    neg_lt_comm, lt_neg_comm, neg_zero]\n  tauto\n\n"}
{"name":"EReal.mul_ne_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\n⊢ Iff (Ne (HMul.hMul a b) Bot.bot) (And (Or (Ne a Bot.bot) (LE.le b 0)) (And (Or (LE.le a 0) (Ne b Bot.bot)) (And (Or (Ne a Top.top) (LE.le 0 b)) (Or (LE.le 0 a) (Ne b Top.top)))))","decl":"lemma mul_ne_bot (a b : EReal) :\n    a * b ≠ ⊥ ↔ (a ≠ ⊥ ∨ b ≤ 0) ∧ (a ≤ 0 ∨ b ≠ ⊥) ∧ (a ≠ ⊤ ∨ 0 ≤ b) ∧ (0 ≤ a ∨ b ≠ ⊤) := by\n  rw [ne_eq, mul_eq_bot]\n  set_option push_neg.use_distrib true in push_neg\n  rfl\n\n"}
{"name":"EReal.toENNReal_mul","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nhx : LE.le 0 x\n⊢ Eq (HMul.hMul x y).toENNReal (HMul.hMul x.toENNReal y.toENNReal)","decl":"/-- `EReal.toENNReal` is multiplicative. For the version with the nonnegativity\nhypothesis on the second variable, see `EReal.toENNReal_mul'`. -/\nlemma toENNReal_mul {x y : EReal} (hx : 0 ≤ x) :\n    (x * y).toENNReal = x.toENNReal * y.toENNReal := by\n  induction x <;> induction y\n    <;> try {· simp_all [mul_nonpos_iff, ofReal_mul, ← coe_mul]}\n  · rcases eq_or_lt_of_le hx with (hx | hx)\n    · simp [← hx]\n    · simp_all [mul_top_of_pos hx]\n  · rename_i a\n    rcases lt_trichotomy a 0 with (ha | ha | ha)\n    · simp_all [le_of_lt, top_mul_of_neg (EReal.coe_neg'.mpr ha)]\n    · simp [ha]\n    · simp_all [top_mul_of_pos (EReal.coe_pos.mpr ha)]\n\n"}
{"name":"EReal.toENNReal_mul'","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\nhy : LE.le 0 y\n⊢ Eq (HMul.hMul x y).toENNReal (HMul.hMul x.toENNReal y.toENNReal)","decl":"/-- `EReal.toENNReal` is multiplicative. For the version with the nonnegativity\nhypothesis on the first variable, see `EReal.toENNReal_mul`. -/\nlemma toENNReal_mul' {x y : EReal} (hy : 0 ≤ y) :\n    (x * y).toENNReal = x.toENNReal * y.toENNReal := by\n  rw [EReal.mul_comm, toENNReal_mul hy, mul_comm]\n\n"}
{"name":"EReal.right_distrib_of_nonneg","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nha : LE.le 0 a\nhb : LE.le 0 b\n⊢ Eq (HMul.hMul (HAdd.hAdd a b) c) (HAdd.hAdd (HMul.hMul a c) (HMul.hMul b c))","decl":"lemma right_distrib_of_nonneg {a b c : EReal} (ha : 0 ≤ a) (hb : 0 ≤ b) :\n    (a + b) * c = a * c + b * c := by\n  rcases eq_or_lt_of_le ha with (rfl | a_pos)\n  · simp\n  rcases eq_or_lt_of_le hb with (rfl | b_pos)\n  · simp\n  rcases lt_trichotomy c 0 with (c_neg | rfl | c_pos)\n  · induction c\n    · rw [mul_bot_of_pos a_pos, mul_bot_of_pos b_pos, mul_bot_of_pos (add_pos a_pos b_pos),\n        add_bot ⊥]\n    · induction a\n      · exfalso; exact not_lt_bot a_pos\n      · induction b\n        · norm_cast\n        · norm_cast; exact right_distrib _ _ _\n        · norm_cast\n          rw [add_top_of_ne_bot (coe_ne_bot _), top_mul_of_neg c_neg, add_bot]\n      · rw [top_add_of_ne_bot (ne_bot_of_gt b_pos), top_mul_of_neg c_neg, bot_add]\n    · exfalso; exact not_top_lt c_neg\n  · simp\n  · induction c\n    · exfalso; exact not_lt_bot c_pos\n    · induction a\n      · exfalso; exact not_lt_bot a_pos\n      · induction b\n        · norm_cast\n        · norm_cast; exact right_distrib _ _ _\n        · norm_cast\n          rw [add_top_of_ne_bot (coe_ne_bot _), top_mul_of_pos c_pos,\n            add_top_of_ne_bot (coe_ne_bot _)]\n      · rw [top_add_of_ne_bot (ne_bot_of_gt b_pos), top_mul_of_pos c_pos,\n          top_add_of_ne_bot (ne_bot_of_gt (mul_pos b_pos c_pos))]\n    · rw [mul_top_of_pos a_pos, mul_top_of_pos b_pos, mul_top_of_pos (add_pos a_pos b_pos),\n        top_add_top]\n\n"}
{"name":"EReal.left_distrib_of_nonneg","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nha : LE.le 0 a\nhb : LE.le 0 b\n⊢ Eq (HMul.hMul c (HAdd.hAdd a b)) (HAdd.hAdd (HMul.hMul c a) (HMul.hMul c b))","decl":"lemma left_distrib_of_nonneg {a b c : EReal} (ha : 0 ≤ a) (hb : 0 ≤ b) :\n    c * (a + b) = c * a + c * b := by\n  nth_rewrite 1 [EReal.mul_comm]; nth_rewrite 2 [EReal.mul_comm]; nth_rewrite 3 [EReal.mul_comm]\n  exact right_distrib_of_nonneg ha hb\n\n"}
{"name":"EReal.left_distrib_of_nonneg_of_ne_top","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\nhx_nonneg : LE.le 0 x\nhx_ne_top : Ne x Top.top\ny z : EReal\n⊢ Eq (HMul.hMul x (HAdd.hAdd y z)) (HAdd.hAdd (HMul.hMul x y) (HMul.hMul x z))","decl":"lemma left_distrib_of_nonneg_of_ne_top {x : EReal} (hx_nonneg : 0 ≤ x)\n    (hx_ne_top : x ≠ ⊤) (y z : EReal) :\n    x * (y + z) = x * y + x * z := by\n  cases hx_nonneg.eq_or_gt with\n  | inl hx0 => simp [hx0]\n  | inr hx0 =>\n  lift x to ℝ using ⟨hx_ne_top, hx0.ne_bot⟩\n  cases y <;> cases z <;>\n    simp [mul_bot_of_pos hx0, mul_top_of_pos hx0, ← coe_mul];\n    rw_mod_cast [mul_add]\n\n"}
{"name":"EReal.right_distrib_of_nonneg_of_ne_top","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\nhx_nonneg : LE.le 0 x\nhx_ne_top : Ne x Top.top\ny z : EReal\n⊢ Eq (HMul.hMul (HAdd.hAdd y z) x) (HAdd.hAdd (HMul.hMul y x) (HMul.hMul z x))","decl":"lemma right_distrib_of_nonneg_of_ne_top {x : EReal} (hx_nonneg : 0 ≤ x)\n    (hx_ne_top : x ≠ ⊤) (y z : EReal) :\n    (y + z) * x = y * x + z * x := by\n  simpa only [EReal.mul_comm] using left_distrib_of_nonneg_of_ne_top hx_nonneg hx_ne_top y z\n\n"}
{"name":"EReal.nsmul_eq_mul","module":"Mathlib.Data.Real.EReal","initialProofState":"n : Nat\nx : EReal\n⊢ Eq (HSMul.hSMul n x) (HMul.hMul (↑n) x)","decl":"@[simp]\nlemma nsmul_eq_mul (n : ℕ) (x : EReal) : n • x = n * x := by\n  induction n with\n  | zero => rw [zero_smul, Nat.cast_zero, zero_mul]\n  | succ n ih =>\n    rw [succ_nsmul, ih, Nat.cast_succ]\n    convert (EReal.right_distrib_of_nonneg _ _).symm <;> simp\n\n"}
{"name":"EReal.abs_top","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq Top.top.abs Top.top","decl":"@[simp] theorem abs_top : (⊤ : EReal).abs = ⊤ := rfl\n\n"}
{"name":"EReal.abs_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq Bot.bot.abs Top.top","decl":"@[simp] theorem abs_bot : (⊥ : EReal).abs = ⊤ := rfl\n\n"}
{"name":"EReal.abs_def","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Eq (↑x).abs (ENNReal.ofReal (abs x))","decl":"theorem abs_def (x : ℝ) : (x : EReal).abs = ENNReal.ofReal |x| := rfl\n\n"}
{"name":"EReal.abs_coe_lt_top","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ LT.lt (↑x).abs Top.top","decl":"theorem abs_coe_lt_top (x : ℝ) : (x : EReal).abs < ⊤ :=\n  ENNReal.ofReal_lt_top\n\n"}
{"name":"EReal.abs_eq_zero_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Iff (Eq x.abs 0) (Eq x 0)","decl":"@[simp]\ntheorem abs_eq_zero_iff {x : EReal} : x.abs = 0 ↔ x = 0 := by\n  induction x\n  · simp only [abs_bot, ENNReal.top_ne_zero, bot_ne_zero]\n  · simp only [abs_def, coe_eq_zero, ENNReal.ofReal_eq_zero, abs_nonpos_iff]\n  · simp only [abs_top, ENNReal.top_ne_zero, top_ne_zero]\n\n"}
{"name":"EReal.abs_zero","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (EReal.abs 0) 0","decl":"@[simp]\ntheorem abs_zero : (0 : EReal).abs = 0 := by rw [abs_eq_zero_iff]\n\n"}
{"name":"EReal.coe_abs","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Eq ↑(↑x).abs ↑(abs x)","decl":"@[simp]\ntheorem coe_abs (x : ℝ) : ((x : EReal).abs : EReal) = (|x| : ℝ) := by\n  rw [abs_def, ← Real.coe_nnabs, ENNReal.ofReal_coe_nnreal]; rfl\n\n"}
{"name":"EReal.abs_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Eq (Neg.neg x).abs x.abs","decl":"@[simp]\nprotected theorem abs_neg : ∀ x : EReal, (-x).abs = x.abs\n  | ⊤ => rfl\n  | ⊥ => rfl\n  | (x : ℝ) => by rw [abs_def, ← coe_neg, abs_def, abs_neg]\n\n"}
{"name":"EReal.abs_mul","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\n⊢ Eq (HMul.hMul x y).abs (HMul.hMul x.abs y.abs)","decl":"@[simp]\ntheorem abs_mul (x y : EReal) : (x * y).abs = x.abs * y.abs := by\n  induction x, y using induction₂_symm_neg with\n  | top_zero => simp only [zero_mul, mul_zero, abs_zero]\n  | top_top => rfl\n  | symm h => rwa [mul_comm, EReal.mul_comm]\n  | coe_coe => simp only [← coe_mul, abs_def, _root_.abs_mul, ENNReal.ofReal_mul (abs_nonneg _)]\n  | top_pos _ h =>\n    rw [top_mul_coe_of_pos h, abs_top, ENNReal.top_mul]\n    rw [Ne, abs_eq_zero_iff, coe_eq_zero]\n    exact h.ne'\n  | neg_left h => rwa [neg_mul, EReal.abs_neg, EReal.abs_neg]\n\n"}
{"name":"EReal.sign_top","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (SignType.sign Top.top) 1","decl":"theorem sign_top : sign (⊤ : EReal) = 1 := rfl\n\n"}
{"name":"EReal.sign_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (SignType.sign Bot.bot) (-1)","decl":"theorem sign_bot : sign (⊥ : EReal) = -1 := rfl\n\n"}
{"name":"EReal.sign_coe","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Eq (SignType.sign ↑x) (SignType.sign x)","decl":"@[simp]\ntheorem sign_coe (x : ℝ) : sign (x : EReal) = sign x := by\n  simp only [sign, OrderHom.coe_mk, EReal.coe_pos, EReal.coe_neg']\n\n"}
{"name":"EReal.coe_coe_sign","module":"Mathlib.Data.Real.EReal","initialProofState":"x : SignType\n⊢ Eq ↑↑x ↑x","decl":"@[simp, norm_cast]\ntheorem coe_coe_sign (x : SignType) : ((x : ℝ) : EReal) = x := by cases x <;> rfl\n\n"}
{"name":"EReal.sign_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Eq (SignType.sign (Neg.neg x)) (Neg.neg (SignType.sign x))","decl":"@[simp] theorem sign_neg : ∀ x : EReal, sign (-x) = -sign x\n  | ⊤ => rfl\n  | ⊥ => rfl\n  | (x : ℝ) => by rw [← coe_neg, sign_coe, sign_coe, Left.sign_neg]\n\n"}
{"name":"EReal.sign_mul","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\n⊢ Eq (SignType.sign (HMul.hMul x y)) (HMul.hMul (SignType.sign x) (SignType.sign y))","decl":"@[simp]\ntheorem sign_mul (x y : EReal) : sign (x * y) = sign x * sign y := by\n  induction x, y using induction₂_symm_neg with\n  | top_zero => simp only [zero_mul, mul_zero, sign_zero]\n  | top_top => rfl\n  | symm h => rwa [mul_comm, EReal.mul_comm]\n  | coe_coe => simp only [← coe_mul, sign_coe, _root_.sign_mul, ENNReal.ofReal_mul (abs_nonneg _)]\n  | top_pos _ h =>\n    rw [top_mul_coe_of_pos h, sign_top, one_mul, sign_pos (EReal.coe_pos.2 h)]\n  | neg_left h => rw [neg_mul, sign_neg, sign_neg, h, neg_mul]\n\n"}
{"name":"EReal.sign_mul_abs","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Eq (HMul.hMul ↑(SignType.sign x) ↑x.abs) x","decl":"@[simp] protected theorem sign_mul_abs : ∀ x : EReal, (sign x * x.abs : EReal) = x\n  | ⊥ => by simp\n  | ⊤ => by simp\n  | (x : ℝ) => by rw [sign_coe, coe_abs, ← coe_coe_sign, ← coe_mul, sign_mul_abs]\n\n"}
{"name":"EReal.abs_mul_sign","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ Eq (HMul.hMul ↑x.abs ↑(SignType.sign x)) x","decl":"@[simp] protected theorem abs_mul_sign (x : EReal) : (x.abs * sign x : EReal) = x := by\n  rw [EReal.mul_comm, EReal.sign_mul_abs]\n\n"}
{"name":"EReal.sign_eq_and_abs_eq_iff_eq","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\n⊢ Iff (And (Eq x.abs y.abs) (Eq (SignType.sign x) (SignType.sign y))) (Eq x y)","decl":"theorem sign_eq_and_abs_eq_iff_eq {x y : EReal} :\n    x.abs = y.abs ∧ sign x = sign y ↔ x = y := by\n  constructor\n  · rintro ⟨habs, hsign⟩\n    rw [← x.sign_mul_abs, ← y.sign_mul_abs, habs, hsign]\n  · rintro rfl\n    exact ⟨rfl, rfl⟩\n\n"}
{"name":"EReal.le_iff_sign","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\n⊢ Iff (LE.le x y) (Or (LT.lt (SignType.sign x) (SignType.sign y)) (Or (And (Eq (SignType.sign x) SignType.neg) (And (Eq (SignType.sign y) SignType.neg) (LE.le y.abs x.abs))) (Or (And (Eq (SignType.sign x) SignType.zero) (Eq (SignType.sign y) SignType.zero)) (And (Eq (SignType.sign x) SignType.pos) (And (Eq (SignType.sign y) SignType.pos) (LE.le x.abs y.abs))))))","decl":"theorem le_iff_sign {x y : EReal} :\n    x ≤ y ↔ sign x < sign y ∨\n      sign x = SignType.neg ∧ sign y = SignType.neg ∧ y.abs ≤ x.abs ∨\n        sign x = SignType.zero ∧ sign y = SignType.zero ∨\n          sign x = SignType.pos ∧ sign y = SignType.pos ∧ x.abs ≤ y.abs := by\n  constructor\n  · intro h\n    refine (sign.monotone h).lt_or_eq.imp_right (fun hs => ?_)\n    rw [← x.sign_mul_abs, ← y.sign_mul_abs] at h\n    cases hy : sign y <;> rw [hs, hy] at h ⊢\n    · simp\n    · left; simpa using h\n    · right; right; simpa using h\n  · rintro (h | h | h | h)\n    · exact (sign.monotone.reflect_lt h).le\n    all_goals rw [← x.sign_mul_abs, ← y.sign_mul_abs]; simp [h]\n\n"}
{"name":"EReal.instPosMulMono","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ PosMulMono EReal","decl":"instance : PosMulMono EReal := posMulMono_iff_covariant_pos.2 <| .mk <| by\n  rintro ⟨x, x0⟩ a b h\n  simp only [le_iff_sign, EReal.sign_mul, sign_pos x0, one_mul, EReal.abs_mul] at h ⊢\n  exact h.imp_right <| Or.imp (And.imp_right <| And.imp_right (mul_le_mul_left' · _)) <|\n    Or.imp_right <| And.imp_right <| And.imp_right (mul_le_mul_left' · _)\n\n"}
{"name":"EReal.instMulPosMono","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ MulPosMono EReal","decl":"instance : MulPosMono EReal := posMulMono_iff_mulPosMono.1 inferInstance\n\n"}
{"name":"EReal.instPosMulReflectLT","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ PosMulReflectLT EReal","decl":"instance : PosMulReflectLT EReal := PosMulMono.toPosMulReflectLT\n\n"}
{"name":"EReal.instMulPosReflectLT","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ MulPosReflectLT EReal","decl":"instance : MulPosReflectLT EReal :=\n  MulPosMono.toMulPosReflectLT\n\n"}
{"name":"EReal.coe_pow","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\nn : Nat\n⊢ Eq (↑(HPow.hPow x n)) (HPow.hPow (↑x) n)","decl":"@[simp, norm_cast]\ntheorem coe_pow (x : ℝ) (n : ℕ) : (↑(x ^ n) : EReal) = (x : EReal) ^ n :=\n  map_pow (⟨⟨(↑), coe_one⟩, coe_mul⟩ : ℝ →* EReal) _ _\n\n"}
{"name":"EReal.coe_ennreal_pow","module":"Mathlib.Data.Real.EReal","initialProofState":"x : ENNReal\nn : Nat\n⊢ Eq (↑(HPow.hPow x n)) (HPow.hPow (↑x) n)","decl":"@[simp, norm_cast]\ntheorem coe_ennreal_pow (x : ℝ≥0∞) (n : ℕ) : (↑(x ^ n) : EReal) = (x : EReal) ^ n :=\n  map_pow (⟨⟨(↑), coe_ennreal_one⟩, coe_ennreal_mul⟩ : ℝ≥0∞ →* EReal) _ _\n\n"}
{"name":"EReal.min_neg_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\n⊢ Eq (Min.min (Neg.neg x) (Neg.neg y)) (Neg.neg (Max.max x y))","decl":"lemma min_neg_neg (x y : EReal) : min (-x) (-y) = -max x y := by\n  rcases le_total x y with (h | h) <;> simp_all\n\n"}
{"name":"EReal.max_neg_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"x y : EReal\n⊢ Eq (Max.max (Neg.neg x) (Neg.neg y)) (Neg.neg (Min.min x y))","decl":"lemma max_neg_neg (x y : EReal) : max (-x) (-y) = -min x y := by\n  rcases le_total x y with (h | h) <;> simp_all\n\n"}
{"name":"EReal.inv_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (Inv.inv Bot.bot) 0","decl":"@[simp]\nlemma inv_bot : (⊥ : EReal)⁻¹ = 0 := rfl\n\n"}
{"name":"EReal.inv_top","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (Inv.inv Top.top) 0","decl":"@[simp]\nlemma inv_top : (⊤ : EReal)⁻¹ = 0 := rfl\n\n"}
{"name":"EReal.coe_inv","module":"Mathlib.Data.Real.EReal","initialProofState":"x : Real\n⊢ Eq (↑(Inv.inv x)) (Inv.inv ↑x)","decl":"lemma coe_inv (x : ℝ) : (x⁻¹ : ℝ) = (x : EReal)⁻¹ := rfl\n\n"}
{"name":"EReal.inv_zero","module":"Mathlib.Data.Real.EReal","initialProofState":"⊢ Eq (Inv.inv 0) 0","decl":"@[simp]\nlemma inv_zero : (0 : EReal)⁻¹ = 0 := by\n  change (0 : ℝ)⁻¹ = (0 : EReal)\n  rw [GroupWithZero.inv_zero, coe_zero]\n\n"}
{"name":"EReal.inv_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\n⊢ Eq (Inv.inv (Neg.neg a)) (Neg.neg (Inv.inv a))","decl":"lemma inv_neg (a : EReal) : (-a)⁻¹ = -a⁻¹ := by\n  induction a\n  · rw [neg_bot, inv_top, inv_bot, neg_zero]\n  · rw [← coe_inv _, ← coe_neg _⁻¹, ← coe_neg _, ← coe_inv (-_)]\n    exact EReal.coe_eq_coe_iff.2 _root_.inv_neg\n  · rw [neg_top, inv_bot, inv_top, neg_zero]\n\n"}
{"name":"EReal.inv_inv","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\nh : Ne a Bot.bot\nh' : Ne a Top.top\n⊢ Eq (Inv.inv (Inv.inv a)) a","decl":"lemma inv_inv {a : EReal} (h : a ≠ ⊥) (h' : a ≠ ⊤) : (a⁻¹)⁻¹ = a := by\n  rw [← coe_toReal h' h, ← coe_inv a.toReal, ← coe_inv a.toReal⁻¹, _root_.inv_inv a.toReal]\n\n"}
{"name":"EReal.mul_inv","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\n⊢ Eq (Inv.inv (HMul.hMul a b)) (HMul.hMul (Inv.inv a) (Inv.inv b))","decl":"lemma mul_inv (a b : EReal) : (a * b)⁻¹ = a⁻¹ * b⁻¹ := by\n  induction a, b using EReal.induction₂_symm with\n  | top_top | top_zero | top_bot | zero_bot | bot_bot => simp\n  | @symm a b h => rw [mul_comm b a, mul_comm b⁻¹ a⁻¹]; exact h\n  | top_pos x x_pos => rw [top_mul_of_pos (EReal.coe_pos.2 x_pos), inv_top, zero_mul]\n  | top_neg x x_neg => rw [top_mul_of_neg (EReal.coe_neg'.2 x_neg), inv_bot, inv_top, zero_mul]\n  | pos_bot x x_pos => rw [mul_bot_of_pos (EReal.coe_pos.2 x_pos), inv_bot, mul_zero]\n  | coe_coe x y => rw [← coe_mul, ← coe_inv, _root_.mul_inv, coe_mul, coe_inv, coe_inv]\n  | neg_bot x x_neg => rw [mul_bot_of_neg (EReal.coe_neg'.2 x_neg), inv_top, inv_bot, mul_zero]\n\n"}
{"name":"EReal.sign_mul_inv_abs","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\n⊢ Eq (HMul.hMul (↑(SignType.sign a)) (Inv.inv ↑a.abs)) (Inv.inv a)","decl":"lemma sign_mul_inv_abs (a : EReal) : (sign a) * (a.abs : EReal)⁻¹ = a⁻¹ := by\n  induction a with\n  | h_bot | h_top => simp\n  | h_real a =>\n    rcases lt_trichotomy a 0 with (a_neg | rfl | a_pos)\n    · rw [sign_coe, _root_.sign_neg a_neg, coe_neg_one, neg_one_mul, ← inv_neg, abs_def a,\n        coe_ennreal_ofReal, max_eq_left (abs_nonneg a), ← coe_neg |a|, abs_of_neg a_neg, neg_neg]\n    · rw [coe_zero, sign_zero, SignType.coe_zero, abs_zero, coe_ennreal_zero, inv_zero, mul_zero]\n    · rw [sign_coe, _root_.sign_pos a_pos, SignType.coe_one, one_mul]\n      simp only [abs_def a, coe_ennreal_ofReal, abs_nonneg, max_eq_left]\n      congr\n      exact abs_of_pos a_pos\n\n"}
{"name":"EReal.sign_mul_inv_abs'","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\n⊢ Eq (HMul.hMul ↑(SignType.sign a) ↑(Inv.inv a.abs)) (Inv.inv a)","decl":"lemma sign_mul_inv_abs' (a : EReal) : (sign a) * ((a.abs⁻¹ : ℝ≥0∞) : EReal) = a⁻¹ := by\n  induction a with\n  | h_bot | h_top  => simp\n  | h_real a =>\n    rcases lt_trichotomy a 0 with (a_neg | rfl | a_pos)\n    · rw [sign_coe, _root_.sign_neg a_neg, coe_neg_one, neg_one_mul, abs_def a,\n        ← ofReal_inv_of_pos (abs_pos_of_neg a_neg), coe_ennreal_ofReal,\n        max_eq_left (inv_nonneg.2 (abs_nonneg a)), ← coe_neg |a|⁻¹, ← coe_inv a, abs_of_neg a_neg,\n        ← _root_.inv_neg, neg_neg]\n    · simp\n    · rw [sign_coe, _root_.sign_pos a_pos, SignType.coe_one, one_mul, abs_def a,\n        ← ofReal_inv_of_pos (abs_pos_of_pos a_pos), coe_ennreal_ofReal,\n          max_eq_left (inv_nonneg.2 (abs_nonneg a)), ← coe_inv a]\n      congr\n      exact abs_of_pos a_pos\n\n"}
{"name":"EReal.bot_lt_inv","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ LT.lt Bot.bot (Inv.inv x)","decl":"lemma bot_lt_inv (x : EReal) : ⊥ < x⁻¹ := by\n  cases x with\n  | h_bot => exact inv_bot ▸ bot_lt_zero\n  | h_top => exact EReal.inv_top ▸ bot_lt_zero\n  | h_real x => exact (coe_inv x).symm ▸ bot_lt_coe (x⁻¹)\n\n"}
{"name":"EReal.inv_lt_top","module":"Mathlib.Data.Real.EReal","initialProofState":"x : EReal\n⊢ LT.lt (Inv.inv x) Top.top","decl":"lemma inv_lt_top (x : EReal) : x⁻¹ < ⊤ := by\n  cases x with\n  | h_bot => exact inv_bot ▸ zero_lt_top\n  | h_top => exact EReal.inv_top ▸ zero_lt_top\n  | h_real x => exact (coe_inv x).symm ▸ coe_lt_top (x⁻¹)\n\n"}
{"name":"EReal.inv_nonneg_of_nonneg","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\nh : LE.le 0 a\n⊢ LE.le 0 (Inv.inv a)","decl":"lemma inv_nonneg_of_nonneg {a : EReal} (h : 0 ≤ a) : 0 ≤ a⁻¹ := by\n  cases a with\n  | h_bot | h_top => simp\n  | h_real a => rw [← coe_inv a, EReal.coe_nonneg, inv_nonneg]; exact EReal.coe_nonneg.1 h\n\n"}
{"name":"EReal.inv_nonpos_of_nonpos","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\nh : LE.le a 0\n⊢ LE.le (Inv.inv a) 0","decl":"lemma inv_nonpos_of_nonpos {a : EReal} (h : a ≤ 0) : a⁻¹ ≤ 0 := by\n  cases a with\n  | h_bot | h_top => simp\n  | h_real a => rw [← coe_inv a, EReal.coe_nonpos, inv_nonpos]; exact EReal.coe_nonpos.1 h\n\n"}
{"name":"EReal.inv_pos_of_pos_ne_top","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\nh : LT.lt 0 a\nh' : Ne a Top.top\n⊢ LT.lt 0 (Inv.inv a)","decl":"lemma inv_pos_of_pos_ne_top {a : EReal} (h : 0 < a) (h' : a ≠ ⊤) : 0 < a⁻¹ := by\n  cases a with\n  | h_bot => exact (not_lt_bot h).rec\n  | h_real a =>  rw [← coe_inv a]; norm_cast at *; exact inv_pos_of_pos h\n  | h_top => exact (h' (Eq.refl ⊤)).rec\n\n"}
{"name":"EReal.inv_neg_of_neg_ne_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\nh : LT.lt a 0\nh' : Ne a Bot.bot\n⊢ LT.lt (Inv.inv a) 0","decl":"lemma inv_neg_of_neg_ne_bot {a : EReal} (h : a < 0) (h' : a ≠ ⊥) : a⁻¹ < 0 := by\n  cases a with\n  | h_bot => exact (h' (Eq.refl ⊥)).rec\n  | h_real a => rw [← coe_inv a]; norm_cast at *; exact inv_lt_zero.2 h\n  | h_top => exact (not_top_lt h).rec\n\n"}
{"name":"EReal.div_eq_inv_mul","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\n⊢ Eq (HDiv.hDiv a b) (HMul.hMul (Inv.inv b) a)","decl":"protected lemma div_eq_inv_mul (a b : EReal) : a / b = b⁻¹ * a := EReal.mul_comm a b⁻¹\n\n"}
{"name":"EReal.coe_div","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : Real\n⊢ Eq (↑(HDiv.hDiv a b)) (HDiv.hDiv ↑a ↑b)","decl":"lemma coe_div (a b : ℝ) : (a / b : ℝ) = (a : EReal) / (b : EReal) := rfl\n\n"}
{"name":"EReal.natCast_div_le","module":"Mathlib.Data.Real.EReal","initialProofState":"m n : Nat\n⊢ LE.le (↑(HDiv.hDiv m n)) (HDiv.hDiv ↑m ↑n)","decl":"theorem natCast_div_le (m n : ℕ) :\n    (m / n : ℕ) ≤ (m : EReal) / (n : EReal) := by\n  rw [← coe_coe_eq_natCast, ← coe_coe_eq_natCast, ← coe_coe_eq_natCast, ← coe_div,\n    EReal.coe_le_coe_iff]\n  exact Nat.cast_div_le\n\n"}
{"name":"EReal.div_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\n⊢ Eq (HDiv.hDiv a Bot.bot) 0","decl":"@[simp]\nlemma div_bot {a : EReal} : a / ⊥ = 0 := inv_bot ▸ mul_zero a\n\n"}
{"name":"EReal.div_top","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\n⊢ Eq (HDiv.hDiv a Top.top) 0","decl":"@[simp]\nlemma div_top {a : EReal} : a / ⊤ = 0 := inv_top ▸ mul_zero a\n\n"}
{"name":"EReal.div_zero","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\n⊢ Eq (HDiv.hDiv a 0) 0","decl":"@[simp]\nlemma div_zero {a : EReal} : a / 0 = 0 := by\n  change a * 0⁻¹ = 0\n  rw [inv_zero, mul_zero a]\n\n"}
{"name":"EReal.zero_div","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\n⊢ Eq (HDiv.hDiv 0 a) 0","decl":"@[simp]\nlemma zero_div {a : EReal} : 0 / a = 0 := zero_mul a⁻¹\n\n"}
{"name":"EReal.top_div_of_pos_ne_top","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\nh : LT.lt 0 a\nh' : Ne a Top.top\n⊢ Eq (HDiv.hDiv Top.top a) Top.top","decl":"lemma top_div_of_pos_ne_top {a : EReal} (h : 0 < a) (h' : a ≠ ⊤) : ⊤ / a = ⊤ :=\n  top_mul_of_pos (inv_pos_of_pos_ne_top h h')\n\n"}
{"name":"EReal.top_div_of_neg_ne_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\nh : LT.lt a 0\nh' : Ne a Bot.bot\n⊢ Eq (HDiv.hDiv Top.top a) Bot.bot","decl":"lemma top_div_of_neg_ne_bot {a : EReal} (h : a < 0) (h' : a ≠ ⊥) : ⊤ / a = ⊥ :=\n  top_mul_of_neg (inv_neg_of_neg_ne_bot h h')\n\n"}
{"name":"EReal.bot_div_of_pos_ne_top","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\nh : LT.lt 0 a\nh' : Ne a Top.top\n⊢ Eq (HDiv.hDiv Bot.bot a) Bot.bot","decl":"lemma bot_div_of_pos_ne_top {a : EReal} (h : 0 < a) (h' : a ≠ ⊤) : ⊥ / a = ⊥ :=\n  bot_mul_of_pos (inv_pos_of_pos_ne_top h h')\n\n"}
{"name":"EReal.bot_div_of_neg_ne_bot","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\nh : LT.lt a 0\nh' : Ne a Bot.bot\n⊢ Eq (HDiv.hDiv Bot.bot a) Top.top","decl":"lemma bot_div_of_neg_ne_bot {a : EReal} (h : a < 0) (h' : a ≠ ⊥) : ⊥ / a = ⊤ :=\n  bot_mul_of_neg (inv_neg_of_neg_ne_bot h h')\n\n"}
{"name":"EReal.div_self","module":"Mathlib.Data.Real.EReal","initialProofState":"a : EReal\nh₁ : Ne a Bot.bot\nh₂ : Ne a Top.top\nh₃ : Ne a 0\n⊢ Eq (HDiv.hDiv a a) 1","decl":"lemma div_self {a : EReal} (h₁ : a ≠ ⊥) (h₂ : a ≠ ⊤) (h₃ : a ≠ 0) : a / a = 1 := by\n  rw [← coe_toReal h₂ h₁] at h₃ ⊢\n  rw [← coe_div, _root_.div_self (coe_ne_zero.1 h₃), coe_one]\n\n"}
{"name":"EReal.mul_div","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\n⊢ Eq (HMul.hMul a (HDiv.hDiv b c)) (HDiv.hDiv (HMul.hMul a b) c)","decl":"lemma mul_div (a b c : EReal) : a * (b / c) = (a * b) / c := by\n  change a * (b * c⁻¹) = (a * b) * c⁻¹\n  rw [mul_assoc]\n\n"}
{"name":"EReal.mul_div_right","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\n⊢ Eq (HMul.hMul (HDiv.hDiv a b) c) (HDiv.hDiv (HMul.hMul a c) b)","decl":"lemma mul_div_right (a b c : EReal) : (a / b) * c = (a * c) / b := by\n  rw [mul_comm, EReal.mul_div, mul_comm]\n\n"}
{"name":"EReal.div_div","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\n⊢ Eq (HDiv.hDiv (HDiv.hDiv a b) c) (HDiv.hDiv a (HMul.hMul b c))","decl":"lemma div_div (a b c : EReal) : a / b / c = a / (b * c) := by\n  change (a * b⁻¹) * c⁻¹ = a * (b * c)⁻¹\n  rw [mul_assoc a b⁻¹, mul_inv]\n\n"}
{"name":"EReal.div_mul_cancel","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\nh₁ : Ne b Bot.bot\nh₂ : Ne b Top.top\nh₃ : Ne b 0\n⊢ Eq (HMul.hMul (HDiv.hDiv a b) b) a","decl":"lemma div_mul_cancel {a b : EReal} (h₁ : b ≠ ⊥) (h₂ : b ≠ ⊤) (h₃ : b ≠ 0) : (a / b) * b = a := by\n  change (a * b⁻¹) * b = a\n  rw [mul_assoc, mul_comm b⁻¹ b]\n  change a * (b / b) = a\n  rw [div_self h₁ h₂ h₃, mul_one]\n\n"}
{"name":"EReal.mul_div_cancel","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\nh₁ : Ne b Bot.bot\nh₂ : Ne b Top.top\nh₃ : Ne b 0\n⊢ Eq (HMul.hMul b (HDiv.hDiv a b)) a","decl":"lemma mul_div_cancel {a b : EReal} (h₁ : b ≠ ⊥) (h₂ : b ≠ ⊤) (h₃ : b ≠ 0) : b * (a / b) = a := by\n  rw [mul_comm, div_mul_cancel h₁ h₂ h₃]\n\n"}
{"name":"EReal.mul_div_mul_cancel","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nh₁ : Ne c Bot.bot\nh₂ : Ne c Top.top\nh₃ : Ne c 0\n⊢ Eq (HDiv.hDiv (HMul.hMul a c) (HMul.hMul b c)) (HDiv.hDiv a b)","decl":"lemma mul_div_mul_cancel {a b c : EReal} (h₁ : c ≠ ⊥) (h₂ : c ≠ ⊤) (h₃ : c ≠ 0) :\n    (a * c) / (b * c) = a / b := by\n  change (a * c) * (b * c)⁻¹ = a * b⁻¹\n  rw [mul_assoc, mul_inv b c]\n  congr\n  exact mul_div_cancel h₁ h₂ h₃\n\n"}
{"name":"EReal.div_eq_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nhbot : Ne b Bot.bot\nhtop : Ne b Top.top\nhzero : Ne b 0\n⊢ Iff (Eq (HDiv.hDiv c b) a) (Eq c (HMul.hMul a b))","decl":"lemma div_eq_iff {a b c : EReal} (hbot : b ≠ ⊥) (htop : b ≠ ⊤) (hzero : b ≠ 0) :\n    c / b = a ↔ c = a * b := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · rw [← @mul_div_cancel c b hbot htop hzero, h, mul_comm a b]\n  · rw [h, mul_comm a b, ← mul_div b a b, @mul_div_cancel a b hbot htop hzero]\n\n"}
{"name":"EReal.monotone_div_right_of_nonneg","module":"Mathlib.Data.Real.EReal","initialProofState":"b : EReal\nh : LE.le 0 b\n⊢ Monotone fun a => HDiv.hDiv a b","decl":"lemma monotone_div_right_of_nonneg {b : EReal} (h : 0 ≤ b) : Monotone fun a ↦ a / b :=\n  fun _ _ h' ↦ mul_le_mul_of_nonneg_right h' (inv_nonneg_of_nonneg h)\n\n"}
{"name":"EReal.div_le_div_right_of_nonneg","module":"Mathlib.Data.Real.EReal","initialProofState":"a a' b : EReal\nh : LE.le 0 b\nh' : LE.le a a'\n⊢ LE.le (HDiv.hDiv a b) (HDiv.hDiv a' b)","decl":"lemma div_le_div_right_of_nonneg {a a' b : EReal} (h : 0 ≤ b) (h' : a ≤ a') :\n    a / b ≤ a' / b :=\n  monotone_div_right_of_nonneg h h'\n\n"}
{"name":"EReal.strictMono_div_right_of_pos","module":"Mathlib.Data.Real.EReal","initialProofState":"b : EReal\nh : LT.lt 0 b\nh' : Ne b Top.top\n⊢ StrictMono fun a => HDiv.hDiv a b","decl":"lemma strictMono_div_right_of_pos {b : EReal} (h : 0 < b) (h' : b ≠ ⊤) :\n    StrictMono fun a ↦ a / b := by\n  intro a a' a_lt_a'\n  apply lt_of_le_of_ne <| div_le_div_right_of_nonneg (le_of_lt h) (le_of_lt a_lt_a')\n  intro hyp\n  apply ne_of_lt a_lt_a'\n  rw [← @EReal.mul_div_cancel a b (ne_bot_of_gt h) h' (ne_of_gt h), hyp,\n    @EReal.mul_div_cancel a' b (ne_bot_of_gt h) h' (ne_of_gt h)]\n\n"}
{"name":"EReal.div_lt_div_right_of_pos","module":"Mathlib.Data.Real.EReal","initialProofState":"a a' b : EReal\nh₁ : LT.lt 0 b\nh₂ : Ne b Top.top\nh₃ : LT.lt a a'\n⊢ LT.lt (HDiv.hDiv a b) (HDiv.hDiv a' b)","decl":"lemma div_lt_div_right_of_pos {a a' b : EReal} (h₁ : 0 < b) (h₂ : b ≠ ⊤)\n    (h₃ : a < a') : a / b < a' / b :=\n  strictMono_div_right_of_pos h₁ h₂ h₃\n\n"}
{"name":"EReal.antitone_div_right_of_nonpos","module":"Mathlib.Data.Real.EReal","initialProofState":"b : EReal\nh : LE.le b 0\n⊢ Antitone fun a => HDiv.hDiv a b","decl":"lemma antitone_div_right_of_nonpos {b : EReal} (h : b ≤ 0) : Antitone fun a ↦ a / b := by\n  intro a a' h'\n  change a' * b⁻¹ ≤ a * b⁻¹\n  rw [← neg_neg (a * b⁻¹), ← neg_neg (a' * b⁻¹), neg_le_neg_iff, mul_comm a b⁻¹, mul_comm a' b⁻¹,\n    ← neg_mul b⁻¹ a, ← neg_mul b⁻¹ a', mul_comm (-b⁻¹) a, mul_comm (-b⁻¹) a', ← inv_neg b]\n  have : 0 ≤ -b := by apply EReal.le_neg_of_le_neg; simp [h]\n  exact div_le_div_right_of_nonneg this h'\n\n"}
{"name":"EReal.div_le_div_right_of_nonpos","module":"Mathlib.Data.Real.EReal","initialProofState":"a a' b : EReal\nh : LE.le b 0\nh' : LE.le a a'\n⊢ LE.le (HDiv.hDiv a' b) (HDiv.hDiv a b)","decl":"lemma div_le_div_right_of_nonpos {a a' b : EReal} (h : b ≤ 0) (h' : a ≤ a') :\n    a' / b ≤ a / b :=\n  antitone_div_right_of_nonpos h h'\n\n"}
{"name":"EReal.strictAnti_div_right_of_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"b : EReal\nh : LT.lt b 0\nh' : Ne b Bot.bot\n⊢ StrictAnti fun a => HDiv.hDiv a b","decl":"lemma strictAnti_div_right_of_neg {b : EReal} (h : b < 0) (h' : b ≠ ⊥) :\n    StrictAnti fun a ↦ a / b := by\n  intro a a' a_lt_a'\n  simp only\n  apply lt_of_le_of_ne <| div_le_div_right_of_nonpos (le_of_lt h) (le_of_lt a_lt_a')\n  intro hyp\n  apply ne_of_lt a_lt_a'\n  rw [← @EReal.mul_div_cancel a b h' (ne_top_of_lt h) (ne_of_lt h), ← hyp,\n    @EReal.mul_div_cancel a' b h' (ne_top_of_lt h) (ne_of_lt h)]\n\n"}
{"name":"EReal.div_lt_div_right_of_neg","module":"Mathlib.Data.Real.EReal","initialProofState":"a a' b : EReal\nh₁ : LT.lt b 0\nh₂ : Ne b Bot.bot\nh₃ : LT.lt a a'\n⊢ LT.lt (HDiv.hDiv a' b) (HDiv.hDiv a b)","decl":"lemma div_lt_div_right_of_neg {a a' b : EReal} (h₁ : b < 0) (h₂ : b ≠ ⊥)\n    (h₃ : a < a') : a' / b < a / b :=\n  strictAnti_div_right_of_neg h₁ h₂ h₃\n\n"}
{"name":"EReal.le_div_iff_mul_le","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nh : GT.gt b 0\nh' : Ne b Top.top\n⊢ Iff (LE.le a (HDiv.hDiv c b)) (LE.le (HMul.hMul a b) c)","decl":"lemma le_div_iff_mul_le {a b c : EReal} (h : b > 0) (h' : b ≠ ⊤) :\n    a ≤ c / b ↔ a * b ≤ c := by\n  nth_rw 1 [← @mul_div_cancel a b (ne_bot_of_gt h) h' (ne_of_gt h)]\n  rw [mul_div b a b, mul_comm a b]\n  exact StrictMono.le_iff_le (strictMono_div_right_of_pos h h')\n\n"}
{"name":"EReal.div_le_iff_le_mul","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nh : LT.lt 0 b\nh' : Ne b Top.top\n⊢ Iff (LE.le (HDiv.hDiv a b) c) (LE.le a (HMul.hMul b c))","decl":"lemma div_le_iff_le_mul {a b c : EReal} (h : 0 < b) (h' : b ≠ ⊤) :\n    a / b ≤ c ↔ a ≤ b * c := by\n  nth_rw 1 [← @mul_div_cancel c b (ne_bot_of_gt h) h' (ne_of_gt h)]\n  rw [mul_div b c b, mul_comm b]\n  exact StrictMono.le_iff_le (strictMono_div_right_of_pos h h')\n\n"}
{"name":"EReal.lt_div_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nh : LT.lt 0 b\nh' : Ne b Top.top\n⊢ Iff (LT.lt a (HDiv.hDiv c b)) (LT.lt (HMul.hMul a b) c)","decl":"lemma lt_div_iff {a b c : EReal} (h : 0 < b) (h' : b ≠ ⊤) :\n    a < c / b ↔ a * b < c := by\n  nth_rw 1 [← @mul_div_cancel a b (ne_bot_of_gt h) h' (ne_of_gt h)]\n  rw [EReal.mul_div b a b, mul_comm a b]\n  exact (strictMono_div_right_of_pos h h').lt_iff_lt\n\n"}
{"name":"EReal.div_lt_iff","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nh : LT.lt 0 b\nh' : Ne b Top.top\n⊢ Iff (LT.lt (HDiv.hDiv c b) a) (LT.lt c (HMul.hMul a b))","decl":"lemma div_lt_iff {a b c : EReal} (h : 0 < b) (h' : b ≠ ⊤) :\n    c / b < a ↔ c < a * b := by\n  nth_rw 1 [← @mul_div_cancel a b (ne_bot_of_gt h) h' (ne_of_gt h)]\n  rw [EReal.mul_div b a b, mul_comm a b]\n  exact (strictMono_div_right_of_pos h h').lt_iff_lt\n\n"}
{"name":"EReal.div_nonneg","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\nh : LE.le 0 a\nh' : LE.le 0 b\n⊢ LE.le 0 (HDiv.hDiv a b)","decl":"lemma div_nonneg {a b : EReal} (h : 0 ≤ a) (h' : 0 ≤ b) : 0 ≤ a / b :=\n  mul_nonneg h (inv_nonneg_of_nonneg h')\n\n"}
{"name":"EReal.div_nonpos_of_nonpos_of_nonneg","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\nh : LE.le a 0\nh' : LE.le 0 b\n⊢ LE.le (HDiv.hDiv a b) 0","decl":"lemma div_nonpos_of_nonpos_of_nonneg {a b : EReal} (h : a ≤ 0) (h' : 0 ≤ b) : a / b ≤ 0 :=\n  mul_nonpos_of_nonpos_of_nonneg h (inv_nonneg_of_nonneg h')\n\n"}
{"name":"EReal.div_nonpos_of_nonneg_of_nonpos","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\nh : LE.le 0 a\nh' : LE.le b 0\n⊢ LE.le (HDiv.hDiv a b) 0","decl":"lemma div_nonpos_of_nonneg_of_nonpos {a b : EReal} (h : 0 ≤ a) (h' : b ≤ 0) : a / b ≤ 0 :=\n  mul_nonpos_of_nonneg_of_nonpos h (inv_nonpos_of_nonpos h')\n\n"}
{"name":"EReal.div_nonneg_of_nonpos_of_nonpos","module":"Mathlib.Data.Real.EReal","initialProofState":"a b : EReal\nh : LE.le a 0\nh' : LE.le b 0\n⊢ LE.le 0 (HDiv.hDiv a b)","decl":"lemma div_nonneg_of_nonpos_of_nonpos {a b : EReal} (h : a ≤ 0) (h' : b ≤ 0) : 0 ≤ a / b :=\n  le_of_eq_of_le (Eq.symm zero_div) (div_le_div_right_of_nonpos h' h)\n\n"}
{"name":"EReal.div_right_distrib_of_nonneg","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nh : LE.le 0 a\nh' : LE.le 0 b\n⊢ Eq (HDiv.hDiv (HAdd.hAdd a b) c) (HAdd.hAdd (HDiv.hDiv a c) (HDiv.hDiv b c))","decl":"lemma div_right_distrib_of_nonneg {a b c : EReal} (h : 0 ≤ a) (h' : 0 ≤ b) :\n    (a + b) / c = (a / c) + (b / c) :=\n  EReal.right_distrib_of_nonneg h h'\n\n"}
{"name":"EReal.add_div_of_nonneg_right","module":"Mathlib.Data.Real.EReal","initialProofState":"a b c : EReal\nh : LE.le 0 c\n⊢ Eq (HDiv.hDiv (HAdd.hAdd a b) c) (HAdd.hAdd (HDiv.hDiv a c) (HDiv.hDiv b c))","decl":"lemma add_div_of_nonneg_right {a b c : EReal} (h : 0 ≤ c) :\n    (a + b) / c = a / c + b / c := by\n  apply right_distrib_of_nonneg_of_ne_top (inv_nonneg_of_nonneg h) (inv_lt_top c).ne\n\n"}
