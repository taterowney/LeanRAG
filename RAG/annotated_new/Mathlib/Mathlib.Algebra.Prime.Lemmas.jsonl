{"name":"comap_prime","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝⁵ : CommMonoidWithZero M\ninst✝⁴ : CommMonoidWithZero N\nF : Type u_3\nG : Type u_4\ninst✝³ : FunLike F M N\ninst✝² : MonoidWithZeroHomClass F M N\ninst✝¹ : FunLike G N M\ninst✝ : MulHomClass G N M\nf : F\ng : G\np : M\nhinv : ∀ (a : M), Eq (g (f a)) a\nhp : Prime (f p)\n⊢ Prime p","decl":"theorem comap_prime (hinv : ∀ a, g (f a : N) = a) (hp : Prime (f p)) : Prime p :=\n  ⟨fun h => hp.1 <| by simp [h], fun h => hp.2.1 <| h.map f, fun a b h => by\n    refine\n        (hp.2.2 (f a) (f b) <| by\n              convert map_dvd f h\n              simp).imp\n          ?_ ?_ <;>\n      · intro h\n        convert ← map_dvd g h <;> apply hinv⟩\n\n"}
{"name":"MulEquiv.prime_iff","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : CommMonoidWithZero M\ninst✝² : CommMonoidWithZero N\np : M\nE : Type u_5\ninst✝¹ : EquivLike E M N\ninst✝ : MulEquivClass E M N\ne : E\n⊢ Iff (Prime (e p)) (Prime p)","decl":"theorem MulEquiv.prime_iff {E : Type*} [EquivLike E M N] [MulEquivClass E M N] (e : E) :\n    Prime (e p) ↔ Prime p := by\n  let e := MulEquivClass.toMulEquiv e\n  exact ⟨comap_prime e e.symm fun a => by simp,\n    fun h => (comap_prime e.symm e fun a => by simp) <| (e.symm_apply_apply p).substr h⟩\n\n"}
{"name":"Prime.left_dvd_or_dvd_right_of_dvd_mul","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\np : M\nhp : Prime p\na b : M\na✝ : Dvd.dvd a (HMul.hMul p b)\n⊢ Or (Dvd.dvd p a) (Dvd.dvd a b)","decl":"theorem Prime.left_dvd_or_dvd_right_of_dvd_mul [CancelCommMonoidWithZero M] {p : M} (hp : Prime p)\n    {a b : M} : a ∣ p * b → p ∣ a ∨ a ∣ b := by\n  rintro ⟨c, hc⟩\n  rcases hp.2.2 a c (hc ▸ dvd_mul_right _ _) with (h | ⟨x, rfl⟩)\n  · exact Or.inl h\n  · rw [mul_left_comm, mul_right_inj' hp.ne_zero] at hc\n    exact Or.inr (hc.symm ▸ dvd_mul_right _ _)\n\n"}
{"name":"Prime.pow_dvd_of_dvd_mul_left","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\np a b : M\nhp : Prime p\nn : Nat\nh : Not (Dvd.dvd p a)\nh' : Dvd.dvd (HPow.hPow p n) (HMul.hMul a b)\n⊢ Dvd.dvd (HPow.hPow p n) b","decl":"theorem Prime.pow_dvd_of_dvd_mul_left [CancelCommMonoidWithZero M] {p a b : M} (hp : Prime p)\n    (n : ℕ) (h : ¬p ∣ a) (h' : p ^ n ∣ a * b) : p ^ n ∣ b := by\n  induction n with\n  | zero =>\n    rw [pow_zero]\n    exact one_dvd b\n  | succ n ih =>\n    obtain ⟨c, rfl⟩ := ih (dvd_trans (pow_dvd_pow p n.le_succ) h')\n    rw [pow_succ]\n    apply mul_dvd_mul_left _ ((hp.dvd_or_dvd _).resolve_left h)\n    rwa [← mul_dvd_mul_iff_left (pow_ne_zero n hp.ne_zero), ← pow_succ, mul_left_comm]\n\n"}
{"name":"Prime.pow_dvd_of_dvd_mul_right","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\np a b : M\nhp : Prime p\nn : Nat\nh : Not (Dvd.dvd p b)\nh' : Dvd.dvd (HPow.hPow p n) (HMul.hMul a b)\n⊢ Dvd.dvd (HPow.hPow p n) a","decl":"theorem Prime.pow_dvd_of_dvd_mul_right [CancelCommMonoidWithZero M] {p a b : M} (hp : Prime p)\n    (n : ℕ) (h : ¬p ∣ b) (h' : p ^ n ∣ a * b) : p ^ n ∣ a := by\n  rw [mul_comm] at h'\n  exact hp.pow_dvd_of_dvd_mul_left n h h'\n\n"}
{"name":"Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\np a b : M\nn : Nat\nhp : Prime p\nhpow : Dvd.dvd (HPow.hPow p n.succ) (HMul.hMul (HPow.hPow a n.succ) (HPow.hPow b n))\nhb : Not (Dvd.dvd (HPow.hPow p 2) b)\n⊢ Dvd.dvd p a","decl":"theorem Prime.dvd_of_pow_dvd_pow_mul_pow_of_square_not_dvd [CancelCommMonoidWithZero M] {p a b : M}\n    {n : ℕ} (hp : Prime p) (hpow : p ^ n.succ ∣ a ^ n.succ * b ^ n) (hb : ¬p ^ 2 ∣ b) : p ∣ a := by\n  -- Suppose `p ∣ b`, write `b = p * x` and `hy : a ^ n.succ * b ^ n = p ^ n.succ * y`.\n  rcases hp.dvd_or_dvd ((dvd_pow_self p (Nat.succ_ne_zero n)).trans hpow) with H | hbdiv\n  · exact hp.dvd_of_dvd_pow H\n  obtain ⟨x, rfl⟩ := hp.dvd_of_dvd_pow hbdiv\n  obtain ⟨y, hy⟩ := hpow\n  -- Then we can divide out a common factor of `p ^ n` from the equation `hy`.\n  have : a ^ n.succ * x ^ n = p * y := by\n    refine mul_left_cancel₀ (pow_ne_zero n hp.ne_zero) ?_\n    rw [← mul_assoc _ p, ← pow_succ, ← hy, mul_pow, ← mul_assoc (a ^ n.succ), mul_comm _ (p ^ n),\n      mul_assoc]\n  -- So `p ∣ a` (and we're done) or `p ∣ x`, which can't be the case since it implies `p^2 ∣ b`.\n  refine hp.dvd_of_dvd_pow ((hp.dvd_or_dvd ⟨_, this⟩).resolve_right fun hdvdx => hb ?_)\n  obtain ⟨z, rfl⟩ := hp.dvd_of_dvd_pow hdvdx\n  rw [pow_two, ← mul_assoc]\n  exact dvd_mul_right _ _\n\n"}
{"name":"prime_pow_succ_dvd_mul","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_3\ninst✝ : CancelCommMonoidWithZero M\np x y : M\nh : Prime p\ni : Nat\nhxy : Dvd.dvd (HPow.hPow p (HAdd.hAdd i 1)) (HMul.hMul x y)\n⊢ Or (Dvd.dvd (HPow.hPow p (HAdd.hAdd i 1)) x) (Dvd.dvd p y)","decl":"theorem prime_pow_succ_dvd_mul {M : Type*} [CancelCommMonoidWithZero M] {p x y : M} (h : Prime p)\n    {i : ℕ} (hxy : p ^ (i + 1) ∣ x * y) : p ^ (i + 1) ∣ x ∨ p ∣ y := by\n  rw [or_iff_not_imp_right]\n  intro hy\n  induction i generalizing x with\n  | zero => rw [pow_one] at hxy ⊢; exact (h.dvd_or_dvd hxy).resolve_right hy\n  | succ i ih =>\n    rw [pow_succ'] at hxy ⊢\n    obtain ⟨x', rfl⟩ := (h.dvd_or_dvd (dvd_of_mul_right_dvd hxy)).resolve_right hy\n    rw [mul_assoc] at hxy\n    exact mul_dvd_mul_left p (ih ((mul_dvd_mul_iff_left h.ne_zero).mp hxy))\n\n"}
{"name":"not_irreducible_pow","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_3\ninst✝ : Monoid M\nx : M\nn : Nat\nhn : Ne n 1\n⊢ Not (Irreducible (HPow.hPow x n))","decl":"theorem not_irreducible_pow {M} [Monoid M] {x : M} {n : ℕ} (hn : n ≠ 1) :\n    ¬ Irreducible (x ^ n) := by\n  cases n with\n  | zero => simp\n  | succ n =>\n    intro ⟨h₁, h₂⟩\n    have := h₂ _ _ (pow_succ _ _)\n    rw [isUnit_pow_iff (Nat.succ_ne_succ.mp hn), or_self] at this\n    exact h₁ (this.pow _)\n\n"}
{"name":"Irreducible.of_map","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\nN : Type u_2\nF : Type u_3\ninst✝⁴ : Monoid M\ninst✝³ : Monoid N\ninst✝² : FunLike F M N\ninst✝¹ : MonoidHomClass F M N\nf : F\ninst✝ : IsLocalHom f\nx : M\nhfx : Irreducible (f x)\n⊢ Irreducible x","decl":"theorem Irreducible.of_map {F : Type*} [Monoid M] [Monoid N] [FunLike F M N] [MonoidHomClass F M N]\n    {f : F} [IsLocalHom f] {x} (hfx : Irreducible (f x)) : Irreducible x :=\n  ⟨fun hu ↦ hfx.not_unit <| hu.map f,\n   by rintro p q rfl\n      exact (hfx.isUnit_or_isUnit <| map_mul f p q).imp (.of_map f _) (.of_map f _)⟩\n\n"}
{"name":"irreducible_units_mul","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : Units M\nb : M\n⊢ Iff (Irreducible (HMul.hMul (↑a) b)) (Irreducible b)","decl":"theorem irreducible_units_mul (a : Mˣ) (b : M) : Irreducible (↑a * b) ↔ Irreducible b := by\n  simp only [irreducible_iff, Units.isUnit_units_mul, and_congr_right_iff]\n  refine fun _ => ⟨fun h A B HAB => ?_, fun h A B HAB => ?_⟩\n  · rw [← a.isUnit_units_mul]\n    apply h\n    rw [mul_assoc, ← HAB]\n  · rw [← a⁻¹.isUnit_units_mul]\n    apply h\n    rw [mul_assoc, ← HAB, Units.inv_mul_cancel_left]\n\n"}
{"name":"irreducible_isUnit_mul","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na b : M\nh : IsUnit a\n⊢ Iff (Irreducible (HMul.hMul a b)) (Irreducible b)","decl":"theorem irreducible_isUnit_mul {a b : M} (h : IsUnit a) : Irreducible (a * b) ↔ Irreducible b :=\n  let ⟨a, ha⟩ := h\n  ha ▸ irreducible_units_mul a b\n\n"}
{"name":"irreducible_mul_units","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na : Units M\nb : M\n⊢ Iff (Irreducible (HMul.hMul b ↑a)) (Irreducible b)","decl":"theorem irreducible_mul_units (a : Mˣ) (b : M) : Irreducible (b * ↑a) ↔ Irreducible b := by\n  simp only [irreducible_iff, Units.isUnit_mul_units, and_congr_right_iff]\n  refine fun _ => ⟨fun h A B HAB => ?_, fun h A B HAB => ?_⟩\n  · rw [← Units.isUnit_mul_units B a]\n    apply h\n    rw [← mul_assoc, ← HAB]\n  · rw [← Units.isUnit_mul_units B a⁻¹]\n    apply h\n    rw [← mul_assoc, ← HAB, Units.mul_inv_cancel_right]\n\n"}
{"name":"irreducible_mul_isUnit","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na b : M\nh : IsUnit a\n⊢ Iff (Irreducible (HMul.hMul b a)) (Irreducible b)","decl":"theorem irreducible_mul_isUnit {a b : M} (h : IsUnit a) : Irreducible (b * a) ↔ Irreducible b :=\n  let ⟨a, ha⟩ := h\n  ha ▸ irreducible_mul_units a b\n\n"}
{"name":"irreducible_mul_iff","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : Monoid M\na b : M\n⊢ Iff (Irreducible (HMul.hMul a b)) (Or (And (Irreducible a) (IsUnit b)) (And (Irreducible b) (IsUnit a)))","decl":"theorem irreducible_mul_iff {a b : M} :\n    Irreducible (a * b) ↔ Irreducible a ∧ IsUnit b ∨ Irreducible b ∧ IsUnit a := by\n  constructor\n  · refine fun h => Or.imp (fun h' => ⟨?_, h'⟩) (fun h' => ⟨?_, h'⟩) (h.isUnit_or_isUnit rfl).symm\n    · rwa [irreducible_mul_isUnit h'] at h\n    · rwa [irreducible_isUnit_mul h'] at h\n  · rintro (⟨ha, hb⟩ | ⟨hb, ha⟩)\n    · rwa [irreducible_mul_isUnit hb]\n    · rwa [irreducible_isUnit_mul ha]\n\n"}
{"name":"Irreducible.map","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : Monoid M\ninst✝² : Monoid N\nF : Type u_3\ninst✝¹ : EquivLike F M N\ninst✝ : MulEquivClass F M N\nf : F\nx : M\nh : Irreducible x\n⊢ Irreducible (f x)","decl":"/--\nIrreducibility is preserved by multiplicative equivalences.\nNote that surjective + local hom is not enough. Consider the additive monoids `M = ℕ ⊕ ℕ`, `N = ℕ`,\nwith a surjective local (additive) hom `f : M →+ N` sending `(m, n)` to `2m + n`.\nIt is local because the only add unit in `N` is `0`, with preimage `{(0, 0)}` also an add unit.\nThen `x = (1, 0)` is irreducible in `M`, but `f x = 2 = 1 + 1` is not irreducible in `N`.\n-/\ntheorem Irreducible.map {x : M} (h : Irreducible x) : Irreducible (f x) :=\n  ⟨fun g ↦ h.not_unit g.of_map, fun a b g ↦\n    let f := MulEquivClass.toMulEquiv f\n    (h.isUnit_or_isUnit (symm_apply_apply f x ▸ map_mul f.symm a b ▸ congrArg f.symm g)).imp\n      (·.of_map) (·.of_map)⟩\n\n"}
{"name":"MulEquiv.irreducible_iff","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\nN : Type u_2\ninst✝³ : Monoid M\ninst✝² : Monoid N\nF : Type u_3\ninst✝¹ : EquivLike F M N\ninst✝ : MulEquivClass F M N\nf : F\na : M\n⊢ Iff (Irreducible (f a)) (Irreducible a)","decl":"theorem MulEquiv.irreducible_iff (f : F) {a : M} :\n    Irreducible (f a) ↔ Irreducible a :=\n  ⟨Irreducible.of_map, Irreducible.map f⟩\n\n"}
{"name":"Irreducible.not_square","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na : M\nha : Irreducible a\n⊢ Not (IsSquare a)","decl":"theorem Irreducible.not_square (ha : Irreducible a) : ¬IsSquare a := by\n  rw [isSquare_iff_exists_sq]\n  rintro ⟨b, rfl⟩\n  exact not_irreducible_pow (by decide) ha\n\n"}
{"name":"IsSquare.not_irreducible","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : CommMonoid M\na : M\nha : IsSquare a\n⊢ Not (Irreducible a)","decl":"theorem IsSquare.not_irreducible (ha : IsSquare a) : ¬Irreducible a := fun h => h.not_square ha\n\n"}
{"name":"succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\np : M\nhp : Prime p\na b : M\nk l : Nat\na✝² : Dvd.dvd (HPow.hPow p k) a\na✝¹ : Dvd.dvd (HPow.hPow p l) b\na✝ : Dvd.dvd (HPow.hPow p (HAdd.hAdd (HAdd.hAdd k l) 1)) (HMul.hMul a b)\n⊢ Or (Dvd.dvd (HPow.hPow p (HAdd.hAdd k 1)) a) (Dvd.dvd (HPow.hPow p (HAdd.hAdd l 1)) b)","decl":"theorem succ_dvd_or_succ_dvd_of_succ_sum_dvd_mul (hp : Prime p) {a b : M} {k l : ℕ} :\n    p ^ k ∣ a → p ^ l ∣ b → p ^ (k + l + 1) ∣ a * b → p ^ (k + 1) ∣ a ∨ p ^ (l + 1) ∣ b :=\n  fun ⟨x, hx⟩ ⟨y, hy⟩ ⟨z, hz⟩ =>\n  have h : p ^ (k + l) * (x * y) = p ^ (k + l) * (p * z) := by\n    simpa [mul_comm, pow_add, hx, hy, mul_assoc, mul_left_comm] using hz\n  have hp0 : p ^ (k + l) ≠ 0 := pow_ne_zero _ hp.ne_zero\n  have hpd : p ∣ x * y := ⟨z, by rwa [mul_right_inj' hp0] at h⟩\n  (hp.dvd_or_dvd hpd).elim\n    (fun ⟨d, hd⟩ => Or.inl ⟨d, by simp [*, pow_succ, mul_comm, mul_left_comm, mul_assoc]⟩)\n    fun ⟨d, hd⟩ => Or.inr ⟨d, by simp [*, pow_succ, mul_comm, mul_left_comm, mul_assoc]⟩\n\n"}
{"name":"Prime.not_square","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\np : M\nhp : Prime p\n⊢ Not (IsSquare p)","decl":"theorem Prime.not_square (hp : Prime p) : ¬IsSquare p :=\n  hp.irreducible.not_square\n\n"}
{"name":"IsSquare.not_prime","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\na : M\nha : IsSquare a\n⊢ Not (Prime a)","decl":"theorem IsSquare.not_prime (ha : IsSquare a) : ¬Prime a := fun h => h.not_square ha\n\n"}
{"name":"not_prime_pow","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\na : M\nn : Nat\nhn : Ne n 1\n⊢ Not (Prime (HPow.hPow a n))","decl":"theorem not_prime_pow {n : ℕ} (hn : n ≠ 1) : ¬Prime (a ^ n) := fun hp =>\n  not_irreducible_pow hn hp.irreducible\n\n"}
{"name":"DvdNotUnit.isUnit_of_irreducible_right","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : CommMonoidWithZero M\np q : M\nh : DvdNotUnit p q\nhq : Irreducible q\n⊢ IsUnit p","decl":"theorem DvdNotUnit.isUnit_of_irreducible_right [CommMonoidWithZero M] {p q : M}\n    (h : DvdNotUnit p q) (hq : Irreducible q) : IsUnit p := by\n  obtain ⟨_, x, hx, hx'⟩ := h\n  exact Or.resolve_right ((irreducible_iff.1 hq).right p x hx') hx\n\n"}
{"name":"not_irreducible_of_not_unit_dvdNotUnit","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : CommMonoidWithZero M\np q : M\nhp : Not (IsUnit p)\nh : DvdNotUnit p q\n⊢ Not (Irreducible q)","decl":"theorem not_irreducible_of_not_unit_dvdNotUnit [CommMonoidWithZero M] {p q : M} (hp : ¬IsUnit p)\n    (h : DvdNotUnit p q) : ¬Irreducible q :=\n  mt h.isUnit_of_irreducible_right hp\n\n"}
{"name":"DvdNotUnit.not_unit","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : CommMonoidWithZero M\np q : M\nhp : DvdNotUnit p q\n⊢ Not (IsUnit q)","decl":"theorem DvdNotUnit.not_unit [CommMonoidWithZero M] {p q : M} (hp : DvdNotUnit p q) : ¬IsUnit q := by\n  obtain ⟨-, x, hx, rfl⟩ := hp\n  exact fun hc => hx (isUnit_iff_dvd_one.mpr (dvd_of_mul_left_dvd (isUnit_iff_dvd_one.mp hc)))\n\n"}
{"name":"DvdNotUnit.ne","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\np q : M\nh : DvdNotUnit p q\n⊢ Ne p q","decl":"theorem DvdNotUnit.ne [CancelCommMonoidWithZero M] {p q : M} (h : DvdNotUnit p q) : p ≠ q := by\n  by_contra hcontra\n  obtain ⟨hp, x, hx', hx''⟩ := h\n  conv_lhs at hx'' => rw [← hcontra, ← mul_one p]\n  rw [(mul_left_cancel₀ hp hx'').symm] at hx'\n  exact hx' isUnit_one\n\n"}
{"name":"pow_injective_of_not_isUnit","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\nq : M\nhq : Not (IsUnit q)\nhq' : Ne q 0\n⊢ Function.Injective fun n => HPow.hPow q n","decl":"theorem pow_injective_of_not_isUnit [CancelCommMonoidWithZero M] {q : M} (hq : ¬IsUnit q)\n    (hq' : q ≠ 0) : Function.Injective fun n : ℕ => q ^ n := by\n  refine injective_of_lt_imp_ne fun n m h => DvdNotUnit.ne ⟨pow_ne_zero n hq', q ^ (m - n), ?_, ?_⟩\n  · exact not_isUnit_of_not_isUnit_dvd hq (dvd_pow (dvd_refl _) (Nat.sub_pos_of_lt h).ne')\n  · exact (pow_mul_pow_sub q h.le).symm\n\n"}
{"name":"pow_injective_of_not_unit","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\nq : M\nhq : Not (IsUnit q)\nhq' : Ne q 0\n⊢ Function.Injective fun n => HPow.hPow q n","decl":"@[deprecated (since := \"2024-09-22\")]\nalias pow_injective_of_not_unit := pow_injective_of_not_isUnit\n\n"}
{"name":"pow_inj_of_not_isUnit","module":"Mathlib.Algebra.Prime.Lemmas","initialProofState":"M : Type u_1\ninst✝ : CancelCommMonoidWithZero M\nq : M\nhq : Not (IsUnit q)\nhq' : Ne q 0\nm n : Nat\n⊢ Iff (Eq (HPow.hPow q m) (HPow.hPow q n)) (Eq m n)","decl":"theorem pow_inj_of_not_isUnit [CancelCommMonoidWithZero M] {q : M} (hq : ¬IsUnit q)\n    (hq' : q ≠ 0) {m n : ℕ} : q ^ m = q ^ n ↔ m = n :=\n  (pow_injective_of_not_isUnit hq hq').eq_iff\n\n"}
