{"name":"mabs_le'","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : Group α\na b : α\n⊢ Iff (LE.le (mabs a) b) (And (LE.le a b) (LE.le (Inv.inv a) b))","decl":"@[to_additive] lemma mabs_le' : |a|ₘ ≤ b ↔ a ≤ b ∧ a⁻¹ ≤ b := sup_le_iff\n\n"}
{"name":"abs_le'","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : AddGroup α\na b : α\n⊢ Iff (LE.le (abs a) b) (And (LE.le a b) (LE.le (Neg.neg a) b))","decl":"@[to_additive] lemma mabs_le' : |a|ₘ ≤ b ↔ a ≤ b ∧ a⁻¹ ≤ b := sup_le_iff\n\n"}
{"name":"le_abs_self","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : AddGroup α\na : α\n⊢ LE.le a (abs a)","decl":"@[to_additive] lemma le_mabs_self (a : α) : a ≤ |a|ₘ := le_sup_left\n\n"}
{"name":"le_mabs_self","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : Group α\na : α\n⊢ LE.le a (mabs a)","decl":"@[to_additive] lemma le_mabs_self (a : α) : a ≤ |a|ₘ := le_sup_left\n\n"}
{"name":"neg_le_abs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : AddGroup α\na : α\n⊢ LE.le (Neg.neg a) (abs a)","decl":"@[to_additive] lemma inv_le_mabs (a : α) : a⁻¹ ≤ |a|ₘ := le_sup_right\n\n"}
{"name":"inv_le_mabs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : Group α\na : α\n⊢ LE.le (Inv.inv a) (mabs a)","decl":"@[to_additive] lemma inv_le_mabs (a : α) : a⁻¹ ≤ |a|ₘ := le_sup_right\n\n"}
{"name":"abs_le_abs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : AddGroup α\na b : α\nh₀ : LE.le a b\nh₁ : LE.le (Neg.neg a) b\n⊢ LE.le (abs a) (abs b)","decl":"@[to_additive] lemma mabs_le_mabs (h₀ : a ≤ b) (h₁ : a⁻¹ ≤ b) : |a|ₘ ≤ |b|ₘ :=\n  (mabs_le'.2 ⟨h₀, h₁⟩).trans (le_mabs_self b)\n\n"}
{"name":"mabs_le_mabs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : Group α\na b : α\nh₀ : LE.le a b\nh₁ : LE.le (Inv.inv a) b\n⊢ LE.le (mabs a) (mabs b)","decl":"@[to_additive] lemma mabs_le_mabs (h₀ : a ≤ b) (h₁ : a⁻¹ ≤ b) : |a|ₘ ≤ |b|ₘ :=\n  (mabs_le'.2 ⟨h₀, h₁⟩).trans (le_mabs_self b)\n\n"}
{"name":"abs_neg","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : AddGroup α\na : α\n⊢ Eq (abs (Neg.neg a)) (abs a)","decl":"@[to_additive (attr := simp)] lemma mabs_inv (a : α) : |a⁻¹|ₘ = |a|ₘ := by simp [mabs, sup_comm]\n\n"}
{"name":"mabs_inv","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : Group α\na : α\n⊢ Eq (mabs (Inv.inv a)) (mabs a)","decl":"@[to_additive (attr := simp)] lemma mabs_inv (a : α) : |a⁻¹|ₘ = |a|ₘ := by simp [mabs, sup_comm]\n\n"}
{"name":"abs_sub_comm","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : AddGroup α\na b : α\n⊢ Eq (abs (HSub.hSub a b)) (abs (HSub.hSub b a))","decl":"@[to_additive] lemma mabs_div_comm (a b : α) : |a / b|ₘ = |b / a|ₘ := by rw [← mabs_inv, inv_div]\n\n"}
{"name":"mabs_div_comm","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : Group α\na b : α\n⊢ Eq (mabs (HDiv.hDiv a b)) (mabs (HDiv.hDiv b a))","decl":"@[to_additive] lemma mabs_div_comm (a b : α) : |a / b|ₘ = |b / a|ₘ := by rw [← mabs_inv, inv_div]\n\n"}
{"name":"abs_of_nonneg","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : AddGroup α\na : α\ninst✝ : AddLeftMono α\nh : LE.le 0 a\n⊢ Eq (abs a) a","decl":"@[to_additive] lemma mabs_of_one_le (h : 1 ≤ a) : |a|ₘ = a :=\n  sup_eq_left.2 <| (inv_le_one'.2 h).trans h\n\n"}
{"name":"mabs_of_one_le","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : Group α\na : α\ninst✝ : MulLeftMono α\nh : LE.le 1 a\n⊢ Eq (mabs a) a","decl":"@[to_additive] lemma mabs_of_one_le (h : 1 ≤ a) : |a|ₘ = a :=\n  sup_eq_left.2 <| (inv_le_one'.2 h).trans h\n\n"}
{"name":"abs_of_pos","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : AddGroup α\na : α\ninst✝ : AddLeftMono α\nh : LT.lt 0 a\n⊢ Eq (abs a) a","decl":"@[to_additive] lemma mabs_of_one_lt (h : 1 < a) : |a|ₘ = a := mabs_of_one_le h.le\n\n"}
{"name":"mabs_of_one_lt","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : Group α\na : α\ninst✝ : MulLeftMono α\nh : LT.lt 1 a\n⊢ Eq (mabs a) a","decl":"@[to_additive] lemma mabs_of_one_lt (h : 1 < a) : |a|ₘ = a := mabs_of_one_le h.le\n\n"}
{"name":"abs_of_nonpos","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : AddGroup α\na : α\ninst✝ : AddLeftMono α\nh : LE.le a 0\n⊢ Eq (abs a) (Neg.neg a)","decl":"@[to_additive] lemma mabs_of_le_one (h : a ≤ 1) : |a|ₘ = a⁻¹ :=\n  sup_eq_right.2 <| h.trans (one_le_inv'.2 h)\n\n"}
{"name":"mabs_of_le_one","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : Group α\na : α\ninst✝ : MulLeftMono α\nh : LE.le a 1\n⊢ Eq (mabs a) (Inv.inv a)","decl":"@[to_additive] lemma mabs_of_le_one (h : a ≤ 1) : |a|ₘ = a⁻¹ :=\n  sup_eq_right.2 <| h.trans (one_le_inv'.2 h)\n\n"}
{"name":"mabs_of_lt_one","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : Group α\na : α\ninst✝ : MulLeftMono α\nh : LT.lt a 1\n⊢ Eq (mabs a) (Inv.inv a)","decl":"@[to_additive] lemma mabs_of_lt_one (h : a < 1) : |a|ₘ = a⁻¹ := mabs_of_le_one h.le\n\n"}
{"name":"abs_of_neg","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : AddGroup α\na : α\ninst✝ : AddLeftMono α\nh : LT.lt a 0\n⊢ Eq (abs a) (Neg.neg a)","decl":"@[to_additive] lemma mabs_of_lt_one (h : a < 1) : |a|ₘ = a⁻¹ := mabs_of_le_one h.le\n\n"}
{"name":"abs_le_abs_of_nonneg","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : AddGroup α\na b : α\ninst✝ : AddLeftMono α\nha : LE.le 0 a\nhab : LE.le a b\n⊢ LE.le (abs a) (abs b)","decl":"@[to_additive] lemma mabs_le_mabs_of_one_le (ha : 1 ≤ a) (hab : a ≤ b) : |a|ₘ ≤ |b|ₘ := by\n  rwa [mabs_of_one_le ha, mabs_of_one_le (ha.trans hab)]\n\n"}
{"name":"mabs_le_mabs_of_one_le","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : Group α\na b : α\ninst✝ : MulLeftMono α\nha : LE.le 1 a\nhab : LE.le a b\n⊢ LE.le (mabs a) (mabs b)","decl":"@[to_additive] lemma mabs_le_mabs_of_one_le (ha : 1 ≤ a) (hab : a ≤ b) : |a|ₘ ≤ |b|ₘ := by\n  rwa [mabs_of_one_le ha, mabs_of_one_le (ha.trans hab)]\n\n"}
{"name":"mabs_one","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : Group α\ninst✝ : MulLeftMono α\n⊢ Eq (mabs 1) 1","decl":"@[to_additive (attr := simp)] lemma mabs_one : |(1 : α)|ₘ = 1 := mabs_of_one_le le_rfl\n\n"}
{"name":"abs_zero","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : AddGroup α\ninst✝ : AddLeftMono α\n⊢ Eq (abs 0) 0","decl":"@[to_additive (attr := simp)] lemma mabs_one : |(1 : α)|ₘ = 1 := mabs_of_one_le le_rfl\n\n"}
{"name":"one_le_mabs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝³ : Lattice α\ninst✝² : Group α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\na : α\n⊢ LE.le 1 (mabs a)","decl":"@[to_additive (attr := simp) abs_nonneg] lemma one_le_mabs (a : α) : 1 ≤ |a|ₘ := by\n  apply pow_two_semiclosed _\n  rw [mabs, pow_two, mul_sup,  sup_mul, ← pow_two, inv_mul_cancel, sup_comm, ← sup_assoc]\n  apply le_sup_right\n\n"}
{"name":"abs_nonneg","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝³ : Lattice α\ninst✝² : AddGroup α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\na : α\n⊢ LE.le 0 (abs a)","decl":"@[to_additive (attr := simp) abs_nonneg] lemma one_le_mabs (a : α) : 1 ≤ |a|ₘ := by\n  apply pow_two_semiclosed _\n  rw [mabs, pow_two, mul_sup,  sup_mul, ← pow_two, inv_mul_cancel, sup_comm, ← sup_assoc]\n  apply le_sup_right\n\n"}
{"name":"mabs_mabs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝³ : Lattice α\ninst✝² : Group α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\na : α\n⊢ Eq (mabs (mabs a)) (mabs a)","decl":"@[to_additive (attr := simp)] lemma mabs_mabs (a : α) : |(|a|ₘ)|ₘ = |a|ₘ :=\n  mabs_of_one_le <| one_le_mabs a\n\n"}
{"name":"abs_abs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝³ : Lattice α\ninst✝² : AddGroup α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\na : α\n⊢ Eq (abs (abs a)) (abs a)","decl":"@[to_additive (attr := simp)] lemma mabs_mabs (a : α) : |(|a|ₘ)|ₘ = |a|ₘ :=\n  mabs_of_one_le <| one_le_mabs a\n\n"}
{"name":"abs_add_le","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : AddCommGroup α\ninst✝ : AddLeftMono α\na b : α\n⊢ LE.le (abs (HAdd.hAdd a b)) (HAdd.hAdd (abs a) (abs b))","decl":"/-- The absolute value satisfies the triangle inequality. -/\n@[to_additive \"The absolute value satisfies the triangle inequality.\"]\nlemma mabs_mul_le (a b : α) : |a * b|ₘ ≤ |a|ₘ * |b|ₘ := by\n  apply sup_le\n  · exact mul_le_mul' (le_mabs_self a) (le_mabs_self b)\n  · rw [mul_inv]\n    exact mul_le_mul' (inv_le_mabs _) (inv_le_mabs _)\n\n"}
{"name":"mabs_mul_le","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : CommGroup α\ninst✝ : MulLeftMono α\na b : α\n⊢ LE.le (mabs (HMul.hMul a b)) (HMul.hMul (mabs a) (mabs b))","decl":"/-- The absolute value satisfies the triangle inequality. -/\n@[to_additive \"The absolute value satisfies the triangle inequality.\"]\nlemma mabs_mul_le (a b : α) : |a * b|ₘ ≤ |a|ₘ * |b|ₘ := by\n  apply sup_le\n  · exact mul_le_mul' (le_mabs_self a) (le_mabs_self b)\n  · rw [mul_inv]\n    exact mul_le_mul' (inv_le_mabs _) (inv_le_mabs _)\n\n"}
{"name":"abs_abs_sub_abs_le","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : AddCommGroup α\ninst✝ : AddLeftMono α\na b : α\n⊢ LE.le (abs (HSub.hSub (abs a) (abs b))) (abs (HSub.hSub a b))","decl":"@[to_additive]\nlemma mabs_mabs_div_mabs_le (a b : α) : |(|a|ₘ / |b|ₘ)|ₘ ≤ |a / b|ₘ := by\n  rw [mabs, sup_le_iff]\n  constructor\n  · apply div_le_iff_le_mul.2\n    convert mabs_mul_le (a / b) b\n    rw [div_mul_cancel]\n  · rw [div_eq_mul_inv, mul_inv_rev, inv_inv, mul_inv_le_iff_le_mul, mabs_div_comm]\n    convert mabs_mul_le (b / a) a\n    · rw [div_mul_cancel]\n\n"}
{"name":"mabs_mabs_div_mabs_le","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : CommGroup α\ninst✝ : MulLeftMono α\na b : α\n⊢ LE.le (mabs (HDiv.hDiv (mabs a) (mabs b))) (mabs (HDiv.hDiv a b))","decl":"@[to_additive]\nlemma mabs_mabs_div_mabs_le (a b : α) : |(|a|ₘ / |b|ₘ)|ₘ ≤ |a / b|ₘ := by\n  rw [mabs, sup_le_iff]\n  constructor\n  · apply div_le_iff_le_mul.2\n    convert mabs_mul_le (a / b) b\n    rw [div_mul_cancel]\n  · rw [div_eq_mul_inv, mul_inv_rev, inv_inv, mul_inv_le_iff_le_mul, mabs_div_comm]\n    convert mabs_mul_le (b / a) a\n    · rw [div_mul_cancel]\n\n"}
{"name":"sup_div_inf_eq_mabs_div","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : CommGroup α\ninst✝ : MulLeftMono α\na b : α\n⊢ Eq (HDiv.hDiv (Max.max a b) (Min.min a b)) (mabs (HDiv.hDiv b a))","decl":"@[to_additive] lemma sup_div_inf_eq_mabs_div (a b : α) : (a ⊔ b) / (a ⊓ b) = |b / a|ₘ := by\n  simp_rw [sup_div, div_inf, div_self', sup_comm, sup_sup_sup_comm, sup_idem]\n  rw [← inv_div, sup_comm (b := _ / _), ← mabs, sup_eq_left]\n  exact one_le_mabs _\n\n"}
{"name":"sup_sub_inf_eq_abs_sub","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : AddCommGroup α\ninst✝ : AddLeftMono α\na b : α\n⊢ Eq (HSub.hSub (Max.max a b) (Min.min a b)) (abs (HSub.hSub b a))","decl":"@[to_additive] lemma sup_div_inf_eq_mabs_div (a b : α) : (a ⊔ b) / (a ⊓ b) = |b / a|ₘ := by\n  simp_rw [sup_div, div_inf, div_self', sup_comm, sup_sup_sup_comm, sup_idem]\n  rw [← inv_div, sup_comm (b := _ / _), ← mabs, sup_eq_left]\n  exact one_le_mabs _\n\n"}
{"name":"sup_sq_eq_mul_mul_mabs_div","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : CommGroup α\ninst✝ : MulLeftMono α\na b : α\n⊢ Eq (HPow.hPow (Max.max a b) 2) (HMul.hMul (HMul.hMul a b) (mabs (HDiv.hDiv b a)))","decl":"@[to_additive two_nsmul_sup_eq_add_add_abs_sub]\nlemma sup_sq_eq_mul_mul_mabs_div (a b : α) : (a ⊔ b) ^ 2 = a * b * |b / a|ₘ := by\n  rw [← inf_mul_sup a b, ← sup_div_inf_eq_mabs_div, div_eq_mul_inv, ← mul_assoc, mul_comm,\n     mul_assoc, ← pow_two, inv_mul_cancel_left]\n\n"}
{"name":"two_nsmul_sup_eq_add_add_abs_sub","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : AddCommGroup α\ninst✝ : AddLeftMono α\na b : α\n⊢ Eq (HSMul.hSMul 2 (Max.max a b)) (HAdd.hAdd (HAdd.hAdd a b) (abs (HSub.hSub b a)))","decl":"@[to_additive two_nsmul_sup_eq_add_add_abs_sub]\nlemma sup_sq_eq_mul_mul_mabs_div (a b : α) : (a ⊔ b) ^ 2 = a * b * |b / a|ₘ := by\n  rw [← inf_mul_sup a b, ← sup_div_inf_eq_mabs_div, div_eq_mul_inv, ← mul_assoc, mul_comm,\n     mul_assoc, ← pow_two, inv_mul_cancel_left]\n\n"}
{"name":"inf_sq_eq_mul_div_mabs_div","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : CommGroup α\ninst✝ : MulLeftMono α\na b : α\n⊢ Eq (HPow.hPow (Min.min a b) 2) (HDiv.hDiv (HMul.hMul a b) (mabs (HDiv.hDiv b a)))","decl":"@[to_additive two_nsmul_inf_eq_add_sub_abs_sub]\nlemma inf_sq_eq_mul_div_mabs_div (a b : α) : (a ⊓ b) ^ 2 = a * b / |b / a|ₘ := by\n  rw [← inf_mul_sup a b, ← sup_div_inf_eq_mabs_div, div_eq_mul_inv, div_eq_mul_inv, mul_inv_rev,\n    inv_inv, mul_assoc, mul_inv_cancel_comm_assoc, ← pow_two]\n\n-- See, e.g. Zaanen, Lectures on Riesz Spaces\n-- 3rd lecture\n"}
{"name":"two_nsmul_inf_eq_add_sub_abs_sub","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : AddCommGroup α\ninst✝ : AddLeftMono α\na b : α\n⊢ Eq (HSMul.hSMul 2 (Min.min a b)) (HSub.hSub (HAdd.hAdd a b) (abs (HSub.hSub b a)))","decl":"@[to_additive two_nsmul_inf_eq_add_sub_abs_sub]\nlemma inf_sq_eq_mul_div_mabs_div (a b : α) : (a ⊓ b) ^ 2 = a * b / |b / a|ₘ := by\n  rw [← inf_mul_sup a b, ← sup_div_inf_eq_mabs_div, div_eq_mul_inv, div_eq_mul_inv, mul_inv_rev,\n    inv_inv, mul_assoc, mul_inv_cancel_comm_assoc, ← pow_two]\n\n-- See, e.g. Zaanen, Lectures on Riesz Spaces\n-- 3rd lecture\n"}
{"name":"abs_sub_sup_add_abs_sub_inf","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : AddCommGroup α\ninst✝ : AddLeftMono α\na b c : α\n⊢ Eq (HAdd.hAdd (abs (HSub.hSub (Max.max a c) (Max.max b c))) (abs (HSub.hSub (Min.min a c) (Min.min b c)))) (abs (HSub.hSub a b))","decl":"@[to_additive]\nlemma mabs_div_sup_mul_mabs_div_inf (a b c : α) :\n    |(a ⊔ c) / (b ⊔ c)|ₘ * |(a ⊓ c) / (b ⊓ c)|ₘ = |a / b|ₘ := by\n  letI : DistribLattice α := CommGroup.toDistribLattice α\n  calc\n    |(a ⊔ c) / (b ⊔ c)|ₘ * |(a ⊓ c) / (b ⊓ c)|ₘ =\n        (b ⊔ c ⊔ (a ⊔ c)) / ((b ⊔ c) ⊓ (a ⊔ c)) * |(a ⊓ c) / (b ⊓ c)|ₘ := by\n        rw [sup_div_inf_eq_mabs_div]\n    _ = (b ⊔ c ⊔ (a ⊔ c)) / ((b ⊔ c) ⊓ (a ⊔ c)) * ((b ⊓ c ⊔ a ⊓ c) / (b ⊓ c ⊓ (a ⊓ c))) := by\n        rw [sup_div_inf_eq_mabs_div (b ⊓ c) (a ⊓ c)]\n    _ = (b ⊔ a ⊔ c) / (b ⊓ a ⊔ c) * (((b ⊔ a) ⊓ c) / (b ⊓ a ⊓ c)) := by\n        rw [← sup_inf_right, ← inf_sup_right, sup_assoc, sup_comm c (a ⊔ c), sup_right_idem,\n          sup_assoc, inf_assoc, inf_comm c (a ⊓ c), inf_right_idem, inf_assoc]\n    _ = (b ⊔ a ⊔ c) * ((b ⊔ a) ⊓ c) / ((b ⊓ a ⊔ c) * (b ⊓ a ⊓ c)) := by rw [div_mul_div_comm]\n    _ = (b ⊔ a) * c / ((b ⊓ a) * c) := by\n        rw [mul_comm, inf_mul_sup, mul_comm (b ⊓ a ⊔ c), inf_mul_sup]\n    _ = (b ⊔ a) / (b ⊓ a) := by\n        rw [div_eq_mul_inv, mul_inv_rev, mul_assoc, mul_inv_cancel_left, ← div_eq_mul_inv]\n    _ = |a / b|ₘ := by rw [sup_div_inf_eq_mabs_div]\n\n"}
{"name":"mabs_div_sup_mul_mabs_div_inf","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : CommGroup α\ninst✝ : MulLeftMono α\na b c : α\n⊢ Eq (HMul.hMul (mabs (HDiv.hDiv (Max.max a c) (Max.max b c))) (mabs (HDiv.hDiv (Min.min a c) (Min.min b c)))) (mabs (HDiv.hDiv a b))","decl":"@[to_additive]\nlemma mabs_div_sup_mul_mabs_div_inf (a b c : α) :\n    |(a ⊔ c) / (b ⊔ c)|ₘ * |(a ⊓ c) / (b ⊓ c)|ₘ = |a / b|ₘ := by\n  letI : DistribLattice α := CommGroup.toDistribLattice α\n  calc\n    |(a ⊔ c) / (b ⊔ c)|ₘ * |(a ⊓ c) / (b ⊓ c)|ₘ =\n        (b ⊔ c ⊔ (a ⊔ c)) / ((b ⊔ c) ⊓ (a ⊔ c)) * |(a ⊓ c) / (b ⊓ c)|ₘ := by\n        rw [sup_div_inf_eq_mabs_div]\n    _ = (b ⊔ c ⊔ (a ⊔ c)) / ((b ⊔ c) ⊓ (a ⊔ c)) * ((b ⊓ c ⊔ a ⊓ c) / (b ⊓ c ⊓ (a ⊓ c))) := by\n        rw [sup_div_inf_eq_mabs_div (b ⊓ c) (a ⊓ c)]\n    _ = (b ⊔ a ⊔ c) / (b ⊓ a ⊔ c) * (((b ⊔ a) ⊓ c) / (b ⊓ a ⊓ c)) := by\n        rw [← sup_inf_right, ← inf_sup_right, sup_assoc, sup_comm c (a ⊔ c), sup_right_idem,\n          sup_assoc, inf_assoc, inf_comm c (a ⊓ c), inf_right_idem, inf_assoc]\n    _ = (b ⊔ a ⊔ c) * ((b ⊔ a) ⊓ c) / ((b ⊓ a ⊔ c) * (b ⊓ a ⊓ c)) := by rw [div_mul_div_comm]\n    _ = (b ⊔ a) * c / ((b ⊓ a) * c) := by\n        rw [mul_comm, inf_mul_sup, mul_comm (b ⊓ a ⊔ c), inf_mul_sup]\n    _ = (b ⊔ a) / (b ⊓ a) := by\n        rw [div_eq_mul_inv, mul_inv_rev, mul_assoc, mul_inv_cancel_left, ← div_eq_mul_inv]\n    _ = |a / b|ₘ := by rw [sup_div_inf_eq_mabs_div]\n\n"}
{"name":"mabs_sup_div_sup_le_mabs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : CommGroup α\ninst✝ : MulLeftMono α\na b c : α\n⊢ LE.le (mabs (HDiv.hDiv (Max.max a c) (Max.max b c))) (mabs (HDiv.hDiv a b))","decl":"@[to_additive] lemma mabs_sup_div_sup_le_mabs (a b c : α) : |(a ⊔ c) / (b ⊔ c)|ₘ ≤ |a / b|ₘ := by\n  apply le_of_mul_le_of_one_le_left _ (one_le_mabs _); rw [mabs_div_sup_mul_mabs_div_inf]\n\n"}
{"name":"abs_sup_sub_sup_le_abs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : AddCommGroup α\ninst✝ : AddLeftMono α\na b c : α\n⊢ LE.le (abs (HSub.hSub (Max.max a c) (Max.max b c))) (abs (HSub.hSub a b))","decl":"@[to_additive] lemma mabs_sup_div_sup_le_mabs (a b c : α) : |(a ⊔ c) / (b ⊔ c)|ₘ ≤ |a / b|ₘ := by\n  apply le_of_mul_le_of_one_le_left _ (one_le_mabs _); rw [mabs_div_sup_mul_mabs_div_inf]\n\n"}
{"name":"abs_inf_sub_inf_le_abs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : AddCommGroup α\ninst✝ : AddLeftMono α\na b c : α\n⊢ LE.le (abs (HSub.hSub (Min.min a c) (Min.min b c))) (abs (HSub.hSub a b))","decl":"@[to_additive] lemma mabs_inf_div_inf_le_mabs (a b c : α) : |(a ⊓ c) / (b ⊓ c)|ₘ ≤ |a / b|ₘ := by\n  apply le_of_mul_le_of_one_le_right _ (one_le_mabs _); rw [mabs_div_sup_mul_mabs_div_inf]\n\n-- Commutative case, Zaanen, 3rd lecture\n-- For the non-commutative case, see Birkhoff Theorem 19 (27)\n"}
{"name":"mabs_inf_div_inf_le_mabs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : CommGroup α\ninst✝ : MulLeftMono α\na b c : α\n⊢ LE.le (mabs (HDiv.hDiv (Min.min a c) (Min.min b c))) (mabs (HDiv.hDiv a b))","decl":"@[to_additive] lemma mabs_inf_div_inf_le_mabs (a b c : α) : |(a ⊓ c) / (b ⊓ c)|ₘ ≤ |a / b|ₘ := by\n  apply le_of_mul_le_of_one_le_right _ (one_le_mabs _); rw [mabs_div_sup_mul_mabs_div_inf]\n\n-- Commutative case, Zaanen, 3rd lecture\n-- For the non-commutative case, see Birkhoff Theorem 19 (27)\n"}
{"name":"Birkhoff_inequalities","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : AddCommGroup α\ninst✝ : AddLeftMono α\na b c : α\n⊢ LE.le (Max.max (abs (HSub.hSub (Max.max a c) (Max.max b c))) (abs (HSub.hSub (Min.min a c) (Min.min b c)))) (abs (HSub.hSub a b))","decl":"@[to_additive Birkhoff_inequalities]\nlemma m_Birkhoff_inequalities (a b c : α) :\n    |(a ⊔ c) / (b ⊔ c)|ₘ ⊔ |(a ⊓ c) / (b ⊓ c)|ₘ ≤ |a / b|ₘ :=\n  sup_le (mabs_sup_div_sup_le_mabs a b c) (mabs_inf_div_inf_le_mabs a b c)\n\n"}
{"name":"m_Birkhoff_inequalities","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : CommGroup α\ninst✝ : MulLeftMono α\na b c : α\n⊢ LE.le (Max.max (mabs (HDiv.hDiv (Max.max a c) (Max.max b c))) (mabs (HDiv.hDiv (Min.min a c) (Min.min b c)))) (mabs (HDiv.hDiv a b))","decl":"@[to_additive Birkhoff_inequalities]\nlemma m_Birkhoff_inequalities (a b c : α) :\n    |(a ⊔ c) / (b ⊔ c)|ₘ ⊔ |(a ⊓ c) / (b ⊓ c)|ₘ ≤ |a / b|ₘ :=\n  sup_le (mabs_sup_div_sup_le_mabs a b c) (mabs_inf_div_inf_le_mabs a b c)\n\n"}
{"name":"abs_choice","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : LinearOrder α\nx : α\n⊢ Or (Eq (abs x) x) (Eq (abs x) (Neg.neg x))","decl":"@[to_additive] lemma mabs_choice (x : α) : |x|ₘ = x ∨ |x|ₘ = x⁻¹ := max_choice _ _\n\n"}
{"name":"mabs_choice","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : LinearOrder α\nx : α\n⊢ Or (Eq (mabs x) x) (Eq (mabs x) (Inv.inv x))","decl":"@[to_additive] lemma mabs_choice (x : α) : |x|ₘ = x ∨ |x|ₘ = x⁻¹ := max_choice _ _\n\n"}
{"name":"le_mabs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (LE.le a (mabs b)) (Or (LE.le a b) (LE.le a (Inv.inv b)))","decl":"@[to_additive] lemma le_mabs : a ≤ |b|ₘ ↔ a ≤ b ∨ a ≤ b⁻¹ := le_max_iff\n\n"}
{"name":"le_abs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (LE.le a (abs b)) (Or (LE.le a b) (LE.le a (Neg.neg b)))","decl":"@[to_additive] lemma le_mabs : a ≤ |b|ₘ ↔ a ≤ b ∨ a ≤ b⁻¹ := le_max_iff\n\n"}
{"name":"mabs_eq_max_inv","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : LinearOrder α\na : α\n⊢ Eq (mabs a) (Max.max a (Inv.inv a))","decl":"@[to_additive] lemma mabs_eq_max_inv : |a|ₘ = max a a⁻¹ := rfl\n\n"}
{"name":"abs_eq_max_neg","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : LinearOrder α\na : α\n⊢ Eq (abs a) (Max.max a (Neg.neg a))","decl":"@[to_additive] lemma mabs_eq_max_inv : |a|ₘ = max a a⁻¹ := rfl\n\n"}
{"name":"lt_abs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (LT.lt a (abs b)) (Or (LT.lt a b) (LT.lt a (Neg.neg b)))","decl":"@[to_additive] lemma lt_mabs : a < |b|ₘ ↔ a < b ∨ a < b⁻¹ := lt_max_iff\n\n"}
{"name":"lt_mabs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (LT.lt a (mabs b)) (Or (LT.lt a b) (LT.lt a (Inv.inv b)))","decl":"@[to_additive] lemma lt_mabs : a < |b|ₘ ↔ a < b ∨ a < b⁻¹ := lt_max_iff\n\n"}
{"name":"abs_by_cases","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : LinearOrder α\na : α\nP : α → Prop\nh1 : P a\nh2 : P (Neg.neg a)\n⊢ P (abs a)","decl":"@[to_additive] lemma mabs_by_cases (P : α → Prop) (h1 : P a) (h2 : P a⁻¹) : P |a|ₘ :=\n  sup_ind _ _ h1 h2\n\n"}
{"name":"mabs_by_cases","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : LinearOrder α\na : α\nP : α → Prop\nh1 : P a\nh2 : P (Inv.inv a)\n⊢ P (mabs a)","decl":"@[to_additive] lemma mabs_by_cases (P : α → Prop) (h1 : P a) (h2 : P a⁻¹) : P |a|ₘ :=\n  sup_ind _ _ h1 h2\n\n"}
{"name":"eq_or_eq_inv_of_mabs_eq","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : LinearOrder α\na b : α\nh : Eq (mabs a) b\n⊢ Or (Eq a b) (Eq a (Inv.inv b))","decl":"@[to_additive] lemma eq_or_eq_inv_of_mabs_eq (h : |a|ₘ = b) : a = b ∨ a = b⁻¹ := by\n  simpa only [← h, eq_comm (a := |a|ₘ), inv_eq_iff_eq_inv] using mabs_choice a\n\n"}
{"name":"eq_or_eq_neg_of_abs_eq","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : LinearOrder α\na b : α\nh : Eq (abs a) b\n⊢ Or (Eq a b) (Eq a (Neg.neg b))","decl":"@[to_additive] lemma eq_or_eq_inv_of_mabs_eq (h : |a|ₘ = b) : a = b ∨ a = b⁻¹ := by\n  simpa only [← h, eq_comm (a := |a|ₘ), inv_eq_iff_eq_inv] using mabs_choice a\n\n"}
{"name":"mabs_eq_mabs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (Eq (mabs a) (mabs b)) (Or (Eq a b) (Eq a (Inv.inv b)))","decl":"@[to_additive] lemma mabs_eq_mabs : |a|ₘ = |b|ₘ ↔ a = b ∨ a = b⁻¹ := by\n  refine ⟨fun h ↦ ?_, by rintro (h | h) <;> simp [h, abs_neg]⟩\n  obtain rfl | rfl := eq_or_eq_inv_of_mabs_eq h <;>\n    simpa only [inv_eq_iff_eq_inv (a := |b|ₘ), inv_inv, inv_inj, or_comm] using mabs_choice b\n\n"}
{"name":"abs_eq_abs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (Eq (abs a) (abs b)) (Or (Eq a b) (Eq a (Neg.neg b)))","decl":"@[to_additive] lemma mabs_eq_mabs : |a|ₘ = |b|ₘ ↔ a = b ∨ a = b⁻¹ := by\n  refine ⟨fun h ↦ ?_, by rintro (h | h) <;> simp [h, abs_neg]⟩\n  obtain rfl | rfl := eq_or_eq_inv_of_mabs_eq h <;>\n    simpa only [inv_eq_iff_eq_inv (a := |b|ₘ), inv_inv, inv_inj, or_comm] using mabs_choice b\n\n"}
{"name":"even_abs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : LinearOrder α\na : α\n⊢ Iff (Even (abs a)) (Even a)","decl":"@[to_additive] lemma isSquare_mabs : IsSquare |a|ₘ ↔ IsSquare a :=\n  mabs_by_cases (IsSquare · ↔ _) Iff.rfl isSquare_inv\n\n"}
{"name":"isSquare_mabs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : LinearOrder α\na : α\n⊢ Iff (IsSquare (mabs a)) (IsSquare a)","decl":"@[to_additive] lemma isSquare_mabs : IsSquare |a|ₘ ↔ IsSquare a :=\n  mabs_by_cases (IsSquare · ↔ _) Iff.rfl isSquare_inv\n\n"}
{"name":"lt_of_mabs_lt","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Group α\ninst✝ : LinearOrder α\na b : α\na✝ : LT.lt (mabs a) b\n⊢ LT.lt a b","decl":"@[to_additive] lemma lt_of_mabs_lt : |a|ₘ < b → a < b := (le_mabs_self _).trans_lt\n\n"}
{"name":"lt_of_abs_lt","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : AddGroup α\ninst✝ : LinearOrder α\na b : α\na✝ : LT.lt (abs a) b\n⊢ LT.lt a b","decl":"@[to_additive] lemma lt_of_mabs_lt : |a|ₘ < b → a < b := (le_mabs_self _).trans_lt\n\n"}
{"name":"one_lt_mabs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Group α\ninst✝¹ : LinearOrder α\ninst✝ : MulLeftMono α\na : α\n⊢ Iff (LT.lt 1 (mabs a)) (Ne a 1)","decl":"@[to_additive (attr := simp) abs_pos] lemma one_lt_mabs : 1 < |a|ₘ ↔ a ≠ 1 := by\n  obtain ha | rfl | ha := lt_trichotomy a 1\n  · simp [mabs_of_lt_one ha, neg_pos, ha.ne, ha]\n  · simp\n  · simp [mabs_of_one_lt ha, ha, ha.ne']\n\n"}
{"name":"abs_pos","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : AddGroup α\ninst✝¹ : LinearOrder α\ninst✝ : AddLeftMono α\na : α\n⊢ Iff (LT.lt 0 (abs a)) (Ne a 0)","decl":"@[to_additive (attr := simp) abs_pos] lemma one_lt_mabs : 1 < |a|ₘ ↔ a ≠ 1 := by\n  obtain ha | rfl | ha := lt_trichotomy a 1\n  · simp [mabs_of_lt_one ha, neg_pos, ha.ne, ha]\n  · simp\n  · simp [mabs_of_one_lt ha, ha, ha.ne']\n\n"}
{"name":"abs_pos_of_pos","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : AddGroup α\ninst✝¹ : LinearOrder α\ninst✝ : AddLeftMono α\na : α\nh : LT.lt 0 a\n⊢ LT.lt 0 (abs a)","decl":"@[to_additive abs_pos_of_pos] lemma one_lt_mabs_pos_of_one_lt (h : 1 < a) : 1 < |a|ₘ :=\n  one_lt_mabs.2 h.ne'\n\n"}
{"name":"one_lt_mabs_pos_of_one_lt","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Group α\ninst✝¹ : LinearOrder α\ninst✝ : MulLeftMono α\na : α\nh : LT.lt 1 a\n⊢ LT.lt 1 (mabs a)","decl":"@[to_additive abs_pos_of_pos] lemma one_lt_mabs_pos_of_one_lt (h : 1 < a) : 1 < |a|ₘ :=\n  one_lt_mabs.2 h.ne'\n\n"}
{"name":"abs_pos_of_neg","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : AddGroup α\ninst✝¹ : LinearOrder α\ninst✝ : AddLeftMono α\na : α\nh : LT.lt a 0\n⊢ LT.lt 0 (abs a)","decl":"@[to_additive abs_pos_of_neg] lemma one_lt_mabs_of_lt_one (h : a < 1) : 1 < |a|ₘ :=\n  one_lt_mabs.2 h.ne\n\n"}
{"name":"one_lt_mabs_of_lt_one","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Group α\ninst✝¹ : LinearOrder α\ninst✝ : MulLeftMono α\na : α\nh : LT.lt a 1\n⊢ LT.lt 1 (mabs a)","decl":"@[to_additive abs_pos_of_neg] lemma one_lt_mabs_of_lt_one (h : a < 1) : 1 < |a|ₘ :=\n  one_lt_mabs.2 h.ne\n\n"}
{"name":"inv_mabs_le","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Group α\ninst✝¹ : LinearOrder α\ninst✝ : MulLeftMono α\na : α\n⊢ LE.le (Inv.inv (mabs a)) a","decl":"@[to_additive] lemma inv_mabs_le (a : α) : |a|ₘ⁻¹ ≤ a := by\n  obtain h | h := le_total 1 a\n  · simpa [mabs_of_one_le h] using (inv_le_one'.2 h).trans h\n  · simp [mabs_of_le_one h]\n\n"}
{"name":"neg_abs_le","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : AddGroup α\ninst✝¹ : LinearOrder α\ninst✝ : AddLeftMono α\na : α\n⊢ LE.le (Neg.neg (abs a)) a","decl":"@[to_additive] lemma inv_mabs_le (a : α) : |a|ₘ⁻¹ ≤ a := by\n  obtain h | h := le_total 1 a\n  · simpa [mabs_of_one_le h] using (inv_le_one'.2 h).trans h\n  · simp [mabs_of_le_one h]\n\n"}
{"name":"add_abs_nonneg","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : AddGroup α\ninst✝¹ : LinearOrder α\ninst✝ : AddLeftMono α\na : α\n⊢ LE.le 0 (HAdd.hAdd a (abs a))","decl":"@[to_additive add_abs_nonneg] lemma one_le_mul_mabs (a : α) : 1 ≤ a * |a|ₘ := by\n  rw [← mul_inv_cancel a]; exact mul_le_mul_left' (inv_le_mabs a) _\n\n"}
{"name":"one_le_mul_mabs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Group α\ninst✝¹ : LinearOrder α\ninst✝ : MulLeftMono α\na : α\n⊢ LE.le 1 (HMul.hMul a (mabs a))","decl":"@[to_additive add_abs_nonneg] lemma one_le_mul_mabs (a : α) : 1 ≤ a * |a|ₘ := by\n  rw [← mul_inv_cancel a]; exact mul_le_mul_left' (inv_le_mabs a) _\n\n"}
{"name":"neg_abs_le_neg","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : AddGroup α\ninst✝¹ : LinearOrder α\ninst✝ : AddLeftMono α\na : α\n⊢ LE.le (Neg.neg (abs a)) (Neg.neg a)","decl":"@[to_additive] lemma inv_mabs_le_inv (a : α) : |a|ₘ⁻¹ ≤ a⁻¹ := by simpa using inv_mabs_le a⁻¹\n\n"}
{"name":"inv_mabs_le_inv","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝² : Group α\ninst✝¹ : LinearOrder α\ninst✝ : MulLeftMono α\na : α\n⊢ LE.le (Inv.inv (mabs a)) (Inv.inv a)","decl":"@[to_additive] lemma inv_mabs_le_inv (a : α) : |a|ₘ⁻¹ ≤ a⁻¹ := by simpa using inv_mabs_le a⁻¹\n\n"}
{"name":"mabs_ne_one","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝³ : Group α\ninst✝² : LinearOrder α\ninst✝¹ : MulLeftMono α\na : α\ninst✝ : MulRightMono α\n⊢ Iff (Ne (mabs a) 1) (Ne a 1)","decl":"@[to_additive] lemma mabs_ne_one : |a|ₘ ≠ 1 ↔ a ≠ 1 :=\n  (one_le_mabs a).gt_iff_ne.symm.trans one_lt_mabs\n\n"}
{"name":"abs_ne_zero","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝³ : AddGroup α\ninst✝² : LinearOrder α\ninst✝¹ : AddLeftMono α\na : α\ninst✝ : AddRightMono α\n⊢ Iff (Ne (abs a) 0) (Ne a 0)","decl":"@[to_additive] lemma mabs_ne_one : |a|ₘ ≠ 1 ↔ a ≠ 1 :=\n  (one_le_mabs a).gt_iff_ne.symm.trans one_lt_mabs\n\n"}
{"name":"abs_eq_zero","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝³ : AddGroup α\ninst✝² : LinearOrder α\ninst✝¹ : AddLeftMono α\na : α\ninst✝ : AddRightMono α\n⊢ Iff (Eq (abs a) 0) (Eq a 0)","decl":"@[to_additive (attr := simp)] lemma mabs_eq_one : |a|ₘ = 1 ↔ a = 1 := not_iff_not.1 mabs_ne_one\n\n"}
{"name":"mabs_eq_one","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝³ : Group α\ninst✝² : LinearOrder α\ninst✝¹ : MulLeftMono α\na : α\ninst✝ : MulRightMono α\n⊢ Iff (Eq (mabs a) 1) (Eq a 1)","decl":"@[to_additive (attr := simp)] lemma mabs_eq_one : |a|ₘ = 1 ↔ a = 1 := not_iff_not.1 mabs_ne_one\n\n"}
{"name":"mabs_le_one","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝³ : Group α\ninst✝² : LinearOrder α\ninst✝¹ : MulLeftMono α\na : α\ninst✝ : MulRightMono α\n⊢ Iff (LE.le (mabs a) 1) (Eq a 1)","decl":"@[to_additive (attr := simp) abs_nonpos_iff] lemma mabs_le_one : |a|ₘ ≤ 1 ↔ a = 1 :=\n  (one_le_mabs a).le_iff_eq.trans mabs_eq_one\n\n"}
{"name":"abs_nonpos_iff","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝³ : AddGroup α\ninst✝² : LinearOrder α\ninst✝¹ : AddLeftMono α\na : α\ninst✝ : AddRightMono α\n⊢ Iff (LE.le (abs a) 0) (Eq a 0)","decl":"@[to_additive (attr := simp) abs_nonpos_iff] lemma mabs_le_one : |a|ₘ ≤ 1 ↔ a = 1 :=\n  (one_le_mabs a).le_iff_eq.trans mabs_eq_one\n\n"}
{"name":"abs_le_abs_of_nonpos","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝³ : AddGroup α\ninst✝² : LinearOrder α\ninst✝¹ : AddLeftMono α\na b : α\ninst✝ : AddRightMono α\nha : LE.le a 0\nhab : LE.le b a\n⊢ LE.le (abs a) (abs b)","decl":"@[to_additive] lemma mabs_le_mabs_of_le_one (ha : a ≤ 1) (hab : b ≤ a) : |a|ₘ ≤ |b|ₘ := by\n  rw [mabs_of_le_one ha, mabs_of_le_one (hab.trans ha)]; exact inv_le_inv_iff.mpr hab\n\n"}
{"name":"mabs_le_mabs_of_le_one","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝³ : Group α\ninst✝² : LinearOrder α\ninst✝¹ : MulLeftMono α\na b : α\ninst✝ : MulRightMono α\nha : LE.le a 1\nhab : LE.le b a\n⊢ LE.le (mabs a) (mabs b)","decl":"@[to_additive] lemma mabs_le_mabs_of_le_one (ha : a ≤ 1) (hab : b ≤ a) : |a|ₘ ≤ |b|ₘ := by\n  rw [mabs_of_le_one ha, mabs_of_le_one (hab.trans ha)]; exact inv_le_inv_iff.mpr hab\n\n"}
{"name":"mabs_lt","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝³ : Group α\ninst✝² : LinearOrder α\ninst✝¹ : MulLeftMono α\na b : α\ninst✝ : MulRightMono α\n⊢ Iff (LT.lt (mabs a) b) (And (LT.lt (Inv.inv b) a) (LT.lt a b))","decl":"@[to_additive] lemma mabs_lt : |a|ₘ < b ↔ b⁻¹ < a ∧ a < b :=\n  max_lt_iff.trans <| and_comm.trans <| by rw [inv_lt']\n\n"}
{"name":"abs_lt","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝³ : AddGroup α\ninst✝² : LinearOrder α\ninst✝¹ : AddLeftMono α\na b : α\ninst✝ : AddRightMono α\n⊢ Iff (LT.lt (abs a) b) (And (LT.lt (Neg.neg b) a) (LT.lt a b))","decl":"@[to_additive] lemma mabs_lt : |a|ₘ < b ↔ b⁻¹ < a ∧ a < b :=\n  max_lt_iff.trans <| and_comm.trans <| by rw [inv_lt']\n\n"}
{"name":"neg_lt_of_abs_lt","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝³ : AddGroup α\ninst✝² : LinearOrder α\ninst✝¹ : AddLeftMono α\na b : α\ninst✝ : AddRightMono α\nh : LT.lt (abs a) b\n⊢ LT.lt (Neg.neg b) a","decl":"@[to_additive] lemma inv_lt_of_mabs_lt (h : |a|ₘ < b) : b⁻¹ < a := (mabs_lt.mp h).1\n\n"}
{"name":"inv_lt_of_mabs_lt","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝³ : Group α\ninst✝² : LinearOrder α\ninst✝¹ : MulLeftMono α\na b : α\ninst✝ : MulRightMono α\nh : LT.lt (mabs a) b\n⊢ LT.lt (Inv.inv b) a","decl":"@[to_additive] lemma inv_lt_of_mabs_lt (h : |a|ₘ < b) : b⁻¹ < a := (mabs_lt.mp h).1\n\n"}
{"name":"max_div_min_eq_mabs'","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝³ : Group α\ninst✝² : LinearOrder α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\na b : α\n⊢ Eq (HDiv.hDiv (Max.max a b) (Min.min a b)) (mabs (HDiv.hDiv a b))","decl":"@[to_additive] lemma max_div_min_eq_mabs' (a b : α) : max a b / min a b = |a / b|ₘ := by\n  rcases le_total a b with ab | ba\n  · rw [max_eq_right ab, min_eq_left ab, mabs_of_le_one, inv_div]\n    rwa [div_le_one']\n  · rw [max_eq_left ba, min_eq_right ba, mabs_of_one_le]\n    rwa [one_le_div']\n\n"}
{"name":"max_sub_min_eq_abs'","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝³ : AddGroup α\ninst✝² : LinearOrder α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\na b : α\n⊢ Eq (HSub.hSub (Max.max a b) (Min.min a b)) (abs (HSub.hSub a b))","decl":"@[to_additive] lemma max_div_min_eq_mabs' (a b : α) : max a b / min a b = |a / b|ₘ := by\n  rcases le_total a b with ab | ba\n  · rw [max_eq_right ab, min_eq_left ab, mabs_of_le_one, inv_div]\n    rwa [div_le_one']\n  · rw [max_eq_left ba, min_eq_right ba, mabs_of_one_le]\n    rwa [one_le_div']\n\n"}
{"name":"max_div_min_eq_mabs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝³ : Group α\ninst✝² : LinearOrder α\ninst✝¹ : MulLeftMono α\ninst✝ : MulRightMono α\na b : α\n⊢ Eq (HDiv.hDiv (Max.max a b) (Min.min a b)) (mabs (HDiv.hDiv b a))","decl":"@[to_additive] lemma max_div_min_eq_mabs (a b : α) : max a b / min a b = |b / a|ₘ := by\n  rw [mabs_div_comm, max_div_min_eq_mabs']\n\n"}
{"name":"max_sub_min_eq_abs","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝³ : AddGroup α\ninst✝² : LinearOrder α\ninst✝¹ : AddLeftMono α\ninst✝ : AddRightMono α\na b : α\n⊢ Eq (HSub.hSub (Max.max a b) (Min.min a b)) (abs (HSub.hSub b a))","decl":"@[to_additive] lemma max_div_min_eq_mabs (a b : α) : max a b / min a b = |b / a|ₘ := by\n  rw [mabs_div_comm, max_div_min_eq_mabs']\n\n"}
{"name":"LatticeOrderedAddCommGroup.isSolid_solidClosure","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : AddCommGroup α\ns : Set α\n⊢ LatticeOrderedAddCommGroup.IsSolid (LatticeOrderedAddCommGroup.solidClosure s)","decl":"lemma isSolid_solidClosure (s : Set α) : IsSolid (solidClosure s) :=\n  fun _ ⟨y, hy, hxy⟩ _ hzx ↦ ⟨y, hy, hzx.trans hxy⟩\n\n"}
{"name":"LatticeOrderedAddCommGroup.solidClosure_min","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : AddCommGroup α\ns t : Set α\nhst : HasSubset.Subset s t\nht : LatticeOrderedAddCommGroup.IsSolid t\n⊢ HasSubset.Subset (LatticeOrderedAddCommGroup.solidClosure s) t","decl":"lemma solidClosure_min (hst : s ⊆ t) (ht : IsSolid t) : solidClosure s ⊆ t :=\n  fun _ ⟨_, hy, hxy⟩ ↦ ht (hst hy) hxy\n\n"}
{"name":"Pi.abs_apply","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"ι : Type u_2\nα : ι → Type u_3\ninst✝¹ : (i : ι) → AddGroup (α i)\ninst✝ : (i : ι) → Lattice (α i)\nf : (i : ι) → α i\ni : ι\n⊢ Eq (abs f i) (abs (f i))","decl":"@[simp] lemma abs_apply (f : ∀ i, α i) (i : ι) : |f| i = |f i| := rfl\n\n"}
{"name":"Pi.abs_def","module":"Mathlib.Algebra.Order.Group.Unbundled.Abs","initialProofState":"ι : Type u_2\nα : ι → Type u_3\ninst✝¹ : (i : ι) → AddGroup (α i)\ninst✝ : (i : ι) → Lattice (α i)\nf : (i : ι) → α i\n⊢ Eq (abs f) fun i => abs (f i)","decl":"lemma abs_def (f : ∀ i, α i) : |f| = fun i ↦ |f i| := rfl\n\n"}
