{"name":"BoxIntegral.TaggedPrepartition.mk.inj","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ntoPrepartition✝ : BoxIntegral.Prepartition I\ntag✝ : BoxIntegral.Box ι → ι → Real\ntag_mem_Icc✝ : ∀ (J : BoxIntegral.Box ι), Membership.mem (BoxIntegral.Box.Icc I) (tag✝ J)\ntoPrepartition : BoxIntegral.Prepartition I\ntag : BoxIntegral.Box ι → ι → Real\ntag_mem_Icc : ∀ (J : BoxIntegral.Box ι), Membership.mem (BoxIntegral.Box.Icc I) (tag J)\nx✝ : Eq { toPrepartition := toPrepartition✝, tag := tag✝, tag_mem_Icc := tag_mem_Icc✝ } { toPrepartition := toPrepartition, tag := tag, tag_mem_Icc := tag_mem_Icc }\n⊢ And (Eq toPrepartition✝ toPrepartition) (Eq tag✝ tag)","decl":"/-- A tagged prepartition is a prepartition enriched with a tagged point for each box of the\nprepartition. For simplicity we require that `tag` is defined for all boxes in `ι → ℝ` but\nwe will use only the values of `tag` on the boxes of the partition. -/\nstructure TaggedPrepartition (I : Box ι) extends Prepartition I where\n  /-- Choice of tagged point of each box in this prepartition:\n    we extend this to a total function, on all boxes in `ι → ℝ`. -/\n  tag : Box ι → ι → ℝ\n  /-- Each tagged point belongs to `I` -/\n  tag_mem_Icc : ∀ J, tag J ∈ Box.Icc I\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.mk.injEq","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ntoPrepartition✝ : BoxIntegral.Prepartition I\ntag✝ : BoxIntegral.Box ι → ι → Real\ntag_mem_Icc✝ : ∀ (J : BoxIntegral.Box ι), Membership.mem (BoxIntegral.Box.Icc I) (tag✝ J)\ntoPrepartition : BoxIntegral.Prepartition I\ntag : BoxIntegral.Box ι → ι → Real\ntag_mem_Icc : ∀ (J : BoxIntegral.Box ι), Membership.mem (BoxIntegral.Box.Icc I) (tag J)\n⊢ Eq (Eq { toPrepartition := toPrepartition✝, tag := tag✝, tag_mem_Icc := tag_mem_Icc✝ } { toPrepartition := toPrepartition, tag := tag, tag_mem_Icc := tag_mem_Icc }) (And (Eq toPrepartition✝ toPrepartition) (Eq tag✝ tag))","decl":"/-- A tagged prepartition is a prepartition enriched with a tagged point for each box of the\nprepartition. For simplicity we require that `tag` is defined for all boxes in `ι → ℝ` but\nwe will use only the values of `tag` on the boxes of the partition. -/\nstructure TaggedPrepartition (I : Box ι) extends Prepartition I where\n  /-- Choice of tagged point of each box in this prepartition:\n    we extend this to a total function, on all boxes in `ι → ℝ`. -/\n  tag : Box ι → ι → ℝ\n  /-- Each tagged point belongs to `I` -/\n  tag_mem_Icc : ∀ J, tag J ∈ Box.Icc I\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.mk.sizeOf_spec","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ninst✝ : SizeOf ι\ntoPrepartition : BoxIntegral.Prepartition I\ntag : BoxIntegral.Box ι → ι → Real\ntag_mem_Icc : ∀ (J : BoxIntegral.Box ι), Membership.mem (BoxIntegral.Box.Icc I) (tag J)\n⊢ Eq (SizeOf.sizeOf { toPrepartition := toPrepartition, tag := tag, tag_mem_Icc := tag_mem_Icc }) (HAdd.hAdd 1 (SizeOf.sizeOf toPrepartition))","decl":"/-- A tagged prepartition is a prepartition enriched with a tagged point for each box of the\nprepartition. For simplicity we require that `tag` is defined for all boxes in `ι → ℝ` but\nwe will use only the values of `tag` on the boxes of the partition. -/\nstructure TaggedPrepartition (I : Box ι) extends Prepartition I where\n  /-- Choice of tagged point of each box in this prepartition:\n    we extend this to a total function, on all boxes in `ι → ℝ`. -/\n  tag : Box ι → ι → ℝ\n  /-- Each tagged point belongs to `I` -/\n  tag_mem_Icc : ∀ J, tag J ∈ Box.Icc I\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.tag_mem_Icc","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nself : BoxIntegral.TaggedPrepartition I\nJ : BoxIntegral.Box ι\n⊢ Membership.mem (BoxIntegral.Box.Icc I) (self.tag J)","decl":"/-- A tagged prepartition is a prepartition enriched with a tagged point for each box of the\nprepartition. For simplicity we require that `tag` is defined for all boxes in `ι → ℝ` but\nwe will use only the values of `tag` on the boxes of the partition. -/\nstructure TaggedPrepartition (I : Box ι) extends Prepartition I where\n  /-- Choice of tagged point of each box in this prepartition:\n    we extend this to a total function, on all boxes in `ι → ℝ`. -/\n  tag : Box ι → ι → ℝ\n  /-- Each tagged point belongs to `I` -/\n  tag_mem_Icc : ∀ J, tag J ∈ Box.Icc I\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.mem_toPrepartition","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\n⊢ Iff (Membership.mem π.toPrepartition J) (Membership.mem π J)","decl":"@[simp]\ntheorem mem_toPrepartition {π : TaggedPrepartition I} : J ∈ π.toPrepartition ↔ J ∈ π := Iff.rfl\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.mem_mk","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nf : BoxIntegral.Box ι → ι → Real\nh : ∀ (J : BoxIntegral.Box ι), Membership.mem (BoxIntegral.Box.Icc I) (f J)\n⊢ Iff (Membership.mem { toPrepartition := π, tag := f, tag_mem_Icc := h } J) (Membership.mem π J)","decl":"@[simp]\ntheorem mem_mk (π : Prepartition I) (f h) : J ∈ mk π f h ↔ J ∈ π := Iff.rfl\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.iUnion_def","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\n⊢ Eq π.iUnion (Set.iUnion fun J => Set.iUnion fun h => ↑J)","decl":"theorem iUnion_def : π.iUnion = ⋃ J ∈ π, ↑J := rfl\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.iUnion_mk","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nf : BoxIntegral.Box ι → ι → Real\nh : ∀ (J : BoxIntegral.Box ι), Membership.mem (BoxIntegral.Box.Icc I) (f J)\n⊢ Eq { toPrepartition := π, tag := f, tag_mem_Icc := h }.iUnion π.iUnion","decl":"@[simp]\ntheorem iUnion_mk (π : Prepartition I) (f h) : (mk π f h).iUnion = π.iUnion := rfl\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.iUnion_toPrepartition","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\n⊢ Eq π.iUnion π.iUnion","decl":"@[simp]\ntheorem iUnion_toPrepartition : π.toPrepartition.iUnion = π.iUnion := rfl\n\n-- Porting note: Previous proof was `:= Set.mem_iUnion₂`\n"}
{"name":"BoxIntegral.TaggedPrepartition.mem_iUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\nx : ι → Real\n⊢ Iff (Membership.mem π.iUnion x) (Exists fun J => And (Membership.mem π J) (Membership.mem J x))","decl":"@[simp]\ntheorem mem_iUnion : x ∈ π.iUnion ↔ ∃ J ∈ π, x ∈ J := by\n  convert Set.mem_iUnion₂\n  rw [Box.mem_coe, mem_toPrepartition, exists_prop]\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.subset_iUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\nh : Membership.mem π J\n⊢ HasSubset.Subset (↑J) π.iUnion","decl":"theorem subset_iUnion (h : J ∈ π) : ↑J ⊆ π.iUnion :=\n  subset_biUnion_of_mem h\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.iUnion_subset","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\n⊢ HasSubset.Subset π.iUnion ↑I","decl":"theorem iUnion_subset : π.iUnion ⊆ I :=\n  iUnion₂_subset π.le_of_mem'\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.isPartition_iff_iUnion_eq","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\n⊢ Iff π.IsPartition (Eq π.iUnion ↑I)","decl":"theorem isPartition_iff_iUnion_eq : IsPartition π ↔ π.iUnion = I :=\n  Prepartition.isPartition_iff_iUnion_eq\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.filter_tag","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\np : BoxIntegral.Box ι → Prop\n⊢ Eq (π.filter p).tag π.tag","decl":"/-- The tagged partition made of boxes of `π` that satisfy predicate `p`. -/\n@[simps! (config := .asFn)]\ndef filter (p : Box ι → Prop) : TaggedPrepartition I :=\n  ⟨π.1.filter p, π.2, π.3⟩\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.filter_boxes_val","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\np : BoxIntegral.Box ι → Prop\n⊢ Eq (π.filter p).boxes.val (Multiset.filter (fun J => p J) π.boxes.val)","decl":"/-- The tagged partition made of boxes of `π` that satisfy predicate `p`. -/\n@[simps! (config := .asFn)]\ndef filter (p : Box ι → Prop) : TaggedPrepartition I :=\n  ⟨π.1.filter p, π.2, π.3⟩\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.mem_filter","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\np : BoxIntegral.Box ι → Prop\n⊢ Iff (Membership.mem (π.filter p) J) (And (Membership.mem π J) (p J))","decl":"@[simp]\ntheorem mem_filter {p : Box ι → Prop} : J ∈ π.filter p ↔ J ∈ π ∧ p J := by\n  classical exact Finset.mem_filter\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.iUnion_filter_not","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\np : BoxIntegral.Box ι → Prop\n⊢ Eq (π.filter fun J => Not (p J)).iUnion (SDiff.sdiff π.iUnion (π.filter p).iUnion)","decl":"@[simp]\ntheorem iUnion_filter_not (π : TaggedPrepartition I) (p : Box ι → Prop) :\n    (π.filter fun J => ¬p J).iUnion = π.iUnion \\ (π.filter p).iUnion :=\n  π.toPrepartition.iUnion_filter_not p\n\n"}
{"name":"BoxIntegral.Prepartition.mem_biUnionTagged","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.TaggedPrepartition J\n⊢ Iff (Membership.mem (π.biUnionTagged πi) J) (Exists fun J' => And (Membership.mem π J') (Membership.mem (πi J') J))","decl":"@[simp]\ntheorem mem_biUnionTagged (π : Prepartition I) {πi : ∀ J, TaggedPrepartition J} :\n    J ∈ π.biUnionTagged πi ↔ ∃ J' ∈ π, J ∈ πi J' :=\n  π.mem_biUnion\n\n"}
{"name":"BoxIntegral.Prepartition.tag_biUnionTagged","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.TaggedPrepartition J\nhJ : Membership.mem π J\nJ' : BoxIntegral.Box ι\nhJ' : Membership.mem (πi J) J'\n⊢ Eq ((π.biUnionTagged πi).tag J') ((πi J).tag J')","decl":"theorem tag_biUnionTagged (π : Prepartition I) {πi : ∀ J, TaggedPrepartition J} (hJ : J ∈ π) {J'}\n    (hJ' : J' ∈ πi J) : (π.biUnionTagged πi).tag J' = (πi J).tag J' := by\n  rw [← π.biUnionIndex_of_mem (πi := fun J => (πi J).toPrepartition) hJ hJ']\n  rfl\n\n"}
{"name":"BoxIntegral.Prepartition.iUnion_biUnionTagged","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.TaggedPrepartition J\n⊢ Eq (π.biUnionTagged πi).iUnion (Set.iUnion fun J => Set.iUnion fun h => (πi J).iUnion)","decl":"@[simp]\ntheorem iUnion_biUnionTagged (π : Prepartition I) (πi : ∀ J, TaggedPrepartition J) :\n    (π.biUnionTagged πi).iUnion = ⋃ J ∈ π, (πi J).iUnion :=\n  iUnion_biUnion _ _\n\n"}
{"name":"BoxIntegral.Prepartition.forall_biUnionTagged","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\np : (ι → Real) → BoxIntegral.Box ι → Prop\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.TaggedPrepartition J\n⊢ Iff (∀ (J : BoxIntegral.Box ι), Membership.mem (π.biUnionTagged πi) J → p ((π.biUnionTagged πi).tag J) J) (∀ (J : BoxIntegral.Box ι), Membership.mem π J → ∀ (J' : BoxIntegral.Box ι), Membership.mem (πi J) J' → p ((πi J).tag J') J')","decl":"theorem forall_biUnionTagged (p : (ι → ℝ) → Box ι → Prop) (π : Prepartition I)\n    (πi : ∀ J, TaggedPrepartition J) :\n    (∀ J ∈ π.biUnionTagged πi, p ((π.biUnionTagged πi).tag J) J) ↔\n      ∀ J ∈ π, ∀ J' ∈ πi J, p ((πi J).tag J') J' := by\n  simp only [mem_biUnionTagged]\n  refine ⟨fun H J hJ J' hJ' => ?_, fun H J' ⟨J, hJ, hJ'⟩ => ?_⟩\n  · rw [← π.tag_biUnionTagged hJ hJ']\n    exact H J' ⟨J, hJ, hJ'⟩\n  · rw [π.tag_biUnionTagged hJ hJ']\n    exact H J hJ J' hJ'\n\n"}
{"name":"BoxIntegral.Prepartition.IsPartition.biUnionTagged","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nh : π.IsPartition\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.TaggedPrepartition J\nhi : ∀ (J : BoxIntegral.Box ι), Membership.mem π J → (πi J).IsPartition\n⊢ (π.biUnionTagged πi).IsPartition","decl":"theorem IsPartition.biUnionTagged {π : Prepartition I} (h : IsPartition π)\n    {πi : ∀ J, TaggedPrepartition J} (hi : ∀ J ∈ π, (πi J).IsPartition) :\n    (π.biUnionTagged πi).IsPartition :=\n  h.biUnion hi\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.biUnionPrepartition_tag","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\n⊢ Eq (π.biUnionPrepartition πi).tag fun J => π.tag (π.biUnionIndex πi J)","decl":"/-- Given a tagged partition `π` of `I` and a (not tagged) partition `πi J hJ` of each `J ∈ π`,\nreturns the tagged partition of `I` into all the boxes of all `πi J hJ`. The tag of a box `J`\nis defined to be the `π.tag` of the box of the partition `π` that includes `J`.\n\nNote that usually the result is not a Henstock partition. -/\n@[simps (config := .asFn) tag]\ndef biUnionPrepartition (π : TaggedPrepartition I) (πi : ∀ J : Box ι, Prepartition J) :\n    TaggedPrepartition I where\n  toPrepartition := π.toPrepartition.biUnion πi\n  tag J := π.tag (π.toPrepartition.biUnionIndex πi J)\n  tag_mem_Icc _ := π.tag_mem_Icc _\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.IsPartition.biUnionPrepartition","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\nh : π.IsPartition\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\nhi : ∀ (J : BoxIntegral.Box ι), Membership.mem π J → (πi J).IsPartition\n⊢ (π.biUnionPrepartition πi).IsPartition","decl":"theorem IsPartition.biUnionPrepartition {π : TaggedPrepartition I} (h : IsPartition π)\n    {πi : ∀ J, Prepartition J} (hi : ∀ J ∈ π, (πi J).IsPartition) :\n    (π.biUnionPrepartition πi).IsPartition :=\n  h.biUnion hi\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.infPrepartition_toPrepartition","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\nπ' : BoxIntegral.Prepartition I\n⊢ Eq (π.infPrepartition π').toPrepartition (Min.min π.toPrepartition π')","decl":"@[simp]\ntheorem infPrepartition_toPrepartition (π : TaggedPrepartition I) (π' : Prepartition I) :\n    (π.infPrepartition π').toPrepartition = π.toPrepartition ⊓ π' := rfl\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.mem_infPrepartition_comm","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.TaggedPrepartition I\n⊢ Iff (Membership.mem (π₁.infPrepartition π₂.toPrepartition) J) (Membership.mem (π₂.infPrepartition π₁.toPrepartition) J)","decl":"theorem mem_infPrepartition_comm :\n    J ∈ π₁.infPrepartition π₂.toPrepartition ↔ J ∈ π₂.infPrepartition π₁.toPrepartition := by\n  simp only [← mem_toPrepartition, infPrepartition_toPrepartition, inf_comm]\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.IsPartition.infPrepartition","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ : BoxIntegral.TaggedPrepartition I\nh₁ : π₁.IsPartition\nπ₂ : BoxIntegral.Prepartition I\nh₂ : π₂.IsPartition\n⊢ (π₁.infPrepartition π₂).IsPartition","decl":"theorem IsPartition.infPrepartition (h₁ : π₁.IsPartition) {π₂ : Prepartition I}\n    (h₂ : π₂.IsPartition) : (π₁.infPrepartition π₂).IsPartition :=\n  h₁.inf h₂\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.isHenstock_biUnionTagged","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.TaggedPrepartition J\n⊢ Iff (π.biUnionTagged πi).IsHenstock (∀ (J : BoxIntegral.Box ι), Membership.mem π J → (πi J).IsHenstock)","decl":"@[simp]\ntheorem isHenstock_biUnionTagged {π : Prepartition I} {πi : ∀ J, TaggedPrepartition J} :\n    IsHenstock (π.biUnionTagged πi) ↔ ∀ J ∈ π, (πi J).IsHenstock :=\n  π.forall_biUnionTagged (fun x J => x ∈ Box.Icc J) πi\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.IsHenstock.card_filter_tag_eq_le","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\ninst✝ : Fintype ι\nh : π.IsHenstock\nx : ι → Real\n⊢ LE.le (Finset.filter (fun J => Eq (π.tag J) x) π.boxes).card (HPow.hPow 2 (Fintype.card ι))","decl":"/-- In a Henstock prepartition, there are at most `2 ^ Fintype.card ι` boxes with a given tag. -/\ntheorem IsHenstock.card_filter_tag_eq_le [Fintype ι] (h : π.IsHenstock) (x : ι → ℝ) :\n    #{J ∈ π.boxes | π.tag J = x} ≤ 2 ^ Fintype.card ι := by\n  classical\n  calc\n    #{J ∈ π.boxes | π.tag J = x} ≤ #{J ∈ π.boxes | x ∈ Box.Icc J} := by\n      refine Finset.card_le_card fun J hJ => ?_\n      rw [Finset.mem_filter] at hJ ⊢; rcases hJ with ⟨hJ, rfl⟩\n      exact ⟨hJ, h J hJ⟩\n    _ ≤ 2 ^ Fintype.card ι := π.toPrepartition.card_filter_mem_Icc_le x\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.isSubordinate_biUnionTagged","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nr : (ι → Real) → ↑(Set.Ioi 0)\ninst✝ : Fintype ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.TaggedPrepartition J\n⊢ Iff ((π.biUnionTagged πi).IsSubordinate r) (∀ (J : BoxIntegral.Box ι), Membership.mem π J → (πi J).IsSubordinate r)","decl":"@[simp]\ntheorem isSubordinate_biUnionTagged [Fintype ι] {π : Prepartition I}\n    {πi : ∀ J, TaggedPrepartition J} :\n    IsSubordinate (π.biUnionTagged πi) r ↔ ∀ J ∈ π, (πi J).IsSubordinate r :=\n  π.forall_biUnionTagged (fun x J => Box.Icc J ⊆ closedBall x (r x)) πi\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.IsSubordinate.biUnionPrepartition","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\nr : (ι → Real) → ↑(Set.Ioi 0)\ninst✝ : Fintype ι\nh : π.IsSubordinate r\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\n⊢ (π.biUnionPrepartition πi).IsSubordinate r","decl":"theorem IsSubordinate.biUnionPrepartition [Fintype ι] (h : IsSubordinate π r)\n    (πi : ∀ J, Prepartition J) : IsSubordinate (π.biUnionPrepartition πi) r :=\n  fun _ hJ => Subset.trans (Box.le_iff_Icc.1 <| π.toPrepartition.le_biUnionIndex hJ) <|\n    h _ <| π.toPrepartition.biUnionIndex_mem hJ\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.IsSubordinate.infPrepartition","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\nr : (ι → Real) → ↑(Set.Ioi 0)\ninst✝ : Fintype ι\nh : π.IsSubordinate r\nπ' : BoxIntegral.Prepartition I\n⊢ (π.infPrepartition π').IsSubordinate r","decl":"theorem IsSubordinate.infPrepartition [Fintype ι] (h : IsSubordinate π r) (π' : Prepartition I) :\n    IsSubordinate (π.infPrepartition π') r :=\n  h.biUnionPrepartition _\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.IsSubordinate.mono'","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nr₁ r₂ : (ι → Real) → ↑(Set.Ioi 0)\ninst✝ : Fintype ι\nπ : BoxIntegral.TaggedPrepartition I\nhr₁ : π.IsSubordinate r₁\nh : ∀ (J : BoxIntegral.Box ι), Membership.mem π J → LE.le (r₁ (π.tag J)) (r₂ (π.tag J))\n⊢ π.IsSubordinate r₂","decl":"theorem IsSubordinate.mono' [Fintype ι] {π : TaggedPrepartition I} (hr₁ : π.IsSubordinate r₁)\n    (h : ∀ J ∈ π, r₁ (π.tag J) ≤ r₂ (π.tag J)) : π.IsSubordinate r₂ :=\n  fun _ hJ _ hx => closedBall_subset_closedBall (h _ hJ) (hr₁ _ hJ hx)\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.IsSubordinate.mono","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nr₁ r₂ : (ι → Real) → ↑(Set.Ioi 0)\ninst✝ : Fintype ι\nπ : BoxIntegral.TaggedPrepartition I\nhr₁ : π.IsSubordinate r₁\nh : ∀ (x : ι → Real), Membership.mem (BoxIntegral.Box.Icc I) x → LE.le (r₁ x) (r₂ x)\n⊢ π.IsSubordinate r₂","decl":"theorem IsSubordinate.mono [Fintype ι] {π : TaggedPrepartition I} (hr₁ : π.IsSubordinate r₁)\n    (h : ∀ x ∈ Box.Icc I, r₁ x ≤ r₂ x) : π.IsSubordinate r₂ :=\n  hr₁.mono' fun J _ => h _ <| π.tag_mem_Icc J\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.IsSubordinate.diam_le","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nr : (ι → Real) → ↑(Set.Ioi 0)\ninst✝ : Fintype ι\nπ : BoxIntegral.TaggedPrepartition I\nh : π.IsSubordinate r\nhJ : Membership.mem π.boxes J\n⊢ LE.le (Metric.diam (BoxIntegral.Box.Icc J)) (HMul.hMul 2 ↑(r (π.tag J)))","decl":"theorem IsSubordinate.diam_le [Fintype ι] {π : TaggedPrepartition I} (h : π.IsSubordinate r)\n    (hJ : J ∈ π.boxes) : diam (Box.Icc J) ≤ 2 * r (π.tag J) :=\n  calc\n    diam (Box.Icc J) ≤ diam (closedBall (π.tag J) (r <| π.tag J)) :=\n      diam_mono (h J hJ) isBounded_closedBall\n    _ ≤ 2 * r (π.tag J) := diam_closedBall (le_of_lt (r _).2)\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.single_boxes_val","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nhJ : LE.le J I\nx : ι → Real\nh : Membership.mem (BoxIntegral.Box.Icc I) x\n⊢ Eq (BoxIntegral.TaggedPrepartition.single I J hJ x h).boxes.val (Singleton.singleton J)","decl":"/-- Tagged prepartition with single box and prescribed tag. -/\n@[simps! (config := .asFn)]\ndef single (I J : Box ι) (hJ : J ≤ I) (x : ι → ℝ) (h : x ∈ Box.Icc I) : TaggedPrepartition I :=\n  ⟨Prepartition.single I J hJ, fun _ => x, fun _ => h⟩\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.single_tag","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nhJ : LE.le J I\nx : ι → Real\nh : Membership.mem (BoxIntegral.Box.Icc I) x\n⊢ Eq (BoxIntegral.TaggedPrepartition.single I J hJ x h).tag fun x_1 => x","decl":"/-- Tagged prepartition with single box and prescribed tag. -/\n@[simps! (config := .asFn)]\ndef single (I J : Box ι) (hJ : J ≤ I) (x : ι → ℝ) (h : x ∈ Box.Icc I) : TaggedPrepartition I :=\n  ⟨Prepartition.single I J hJ, fun _ => x, fun _ => h⟩\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.mem_single","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nx : ι → Real\nJ' : BoxIntegral.Box ι\nhJ : LE.le J I\nh : Membership.mem (BoxIntegral.Box.Icc I) x\n⊢ Iff (Membership.mem (BoxIntegral.TaggedPrepartition.single I J hJ x h) J') (Eq J' J)","decl":"@[simp]\ntheorem mem_single {J'} (hJ : J ≤ I) (h : x ∈ Box.Icc I) : J' ∈ single I J hJ x h ↔ J' = J :=\n  Finset.mem_singleton\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.isPartition_single_iff","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nx : ι → Real\nhJ : LE.le J I\nh : Membership.mem (BoxIntegral.Box.Icc I) x\n⊢ Iff (BoxIntegral.TaggedPrepartition.single I J hJ x h).IsPartition (Eq J I)","decl":"theorem isPartition_single_iff (hJ : J ≤ I) (h : x ∈ Box.Icc I) :\n    (single I J hJ x h).IsPartition ↔ J = I :=\n  Prepartition.isPartition_single_iff hJ\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.isPartition_single","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nx : ι → Real\nh : Membership.mem (BoxIntegral.Box.Icc I) x\n⊢ (BoxIntegral.TaggedPrepartition.single I I ⋯ x h).IsPartition","decl":"theorem isPartition_single (h : x ∈ Box.Icc I) : (single I I le_rfl x h).IsPartition :=\n  Prepartition.isPartitionTop I\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.forall_mem_single","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nx : ι → Real\np : (ι → Real) → BoxIntegral.Box ι → Prop\nhJ : LE.le J I\nh : Membership.mem (BoxIntegral.Box.Icc I) x\n⊢ Iff (∀ (J' : BoxIntegral.Box ι), Membership.mem (BoxIntegral.TaggedPrepartition.single I J hJ x h) J' → p ((BoxIntegral.TaggedPrepartition.single I J hJ x h).tag J') J') (p x J)","decl":"theorem forall_mem_single (p : (ι → ℝ) → Box ι → Prop) (hJ : J ≤ I) (h : x ∈ Box.Icc I) :\n    (∀ J' ∈ single I J hJ x h, p ((single I J hJ x h).tag J') J') ↔ p x J := by simp\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.isHenstock_single_iff","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nx : ι → Real\nhJ : LE.le J I\nh : Membership.mem (BoxIntegral.Box.Icc I) x\n⊢ Iff (BoxIntegral.TaggedPrepartition.single I J hJ x h).IsHenstock (Membership.mem (BoxIntegral.Box.Icc J) x)","decl":"@[simp]\ntheorem isHenstock_single_iff (hJ : J ≤ I) (h : x ∈ Box.Icc I) :\n    IsHenstock (single I J hJ x h) ↔ x ∈ Box.Icc J :=\n  forall_mem_single (fun x J => x ∈ Box.Icc J) hJ h\n\n--@[simp] -- Porting note: Commented out, because `simp only [isHenstock_single_iff]` simplifies it\n"}
{"name":"BoxIntegral.TaggedPrepartition.isHenstock_single","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nx : ι → Real\nh : Membership.mem (BoxIntegral.Box.Icc I) x\n⊢ (BoxIntegral.TaggedPrepartition.single I I ⋯ x h).IsHenstock","decl":"theorem isHenstock_single (h : x ∈ Box.Icc I) : IsHenstock (single I I le_rfl x h) :=\n  (isHenstock_single_iff (le_refl I) h).2 h\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.isSubordinate_single","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nx : ι → Real\nr : (ι → Real) → ↑(Set.Ioi 0)\ninst✝ : Fintype ι\nhJ : LE.le J I\nh : Membership.mem (BoxIntegral.Box.Icc I) x\n⊢ Iff ((BoxIntegral.TaggedPrepartition.single I J hJ x h).IsSubordinate r) (HasSubset.Subset (BoxIntegral.Box.Icc J) (Metric.closedBall x ↑(r x)))","decl":"@[simp]\ntheorem isSubordinate_single [Fintype ι] (hJ : J ≤ I) (h : x ∈ Box.Icc I) :\n    IsSubordinate (single I J hJ x h) r ↔ Box.Icc J ⊆ closedBall x (r x) :=\n  forall_mem_single (fun x J => Box.Icc J ⊆ closedBall x (r x)) hJ h\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.iUnion_single","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nx : ι → Real\nhJ : LE.le J I\nh : Membership.mem (BoxIntegral.Box.Icc I) x\n⊢ Eq (BoxIntegral.TaggedPrepartition.single I J hJ x h).iUnion ↑J","decl":"@[simp]\ntheorem iUnion_single (hJ : J ≤ I) (h : x ∈ Box.Icc I) : (single I J hJ x h).iUnion = J :=\n  Prepartition.iUnion_single hJ\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.disjUnion_boxes","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.TaggedPrepartition I\nh : Disjoint π₁.iUnion π₂.iUnion\n⊢ Eq (π₁.disjUnion π₂ h).boxes (Union.union π₁.boxes π₂.boxes)","decl":"open scoped Classical in\n@[simp]\ntheorem disjUnion_boxes (h : Disjoint π₁.iUnion π₂.iUnion) :\n    (π₁.disjUnion π₂ h).boxes = π₁.boxes ∪ π₂.boxes := rfl\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.mem_disjUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.TaggedPrepartition I\nh : Disjoint π₁.iUnion π₂.iUnion\n⊢ Iff (Membership.mem (π₁.disjUnion π₂ h) J) (Or (Membership.mem π₁ J) (Membership.mem π₂ J))","decl":"@[simp]\ntheorem mem_disjUnion (h : Disjoint π₁.iUnion π₂.iUnion) :\n    J ∈ π₁.disjUnion π₂ h ↔ J ∈ π₁ ∨ J ∈ π₂ := by\n  classical exact Finset.mem_union\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.iUnion_disjUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.TaggedPrepartition I\nh : Disjoint π₁.iUnion π₂.iUnion\n⊢ Eq (π₁.disjUnion π₂ h).iUnion (Union.union π₁.iUnion π₂.iUnion)","decl":"@[simp]\ntheorem iUnion_disjUnion (h : Disjoint π₁.iUnion π₂.iUnion) :\n    (π₁.disjUnion π₂ h).iUnion = π₁.iUnion ∪ π₂.iUnion :=\n  Prepartition.iUnion_disjUnion h\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.disjUnion_tag_of_mem_left","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.TaggedPrepartition I\nh : Disjoint π₁.iUnion π₂.iUnion\nhJ : Membership.mem π₁ J\n⊢ Eq ((π₁.disjUnion π₂ h).tag J) (π₁.tag J)","decl":"theorem disjUnion_tag_of_mem_left (h : Disjoint π₁.iUnion π₂.iUnion) (hJ : J ∈ π₁) :\n    (π₁.disjUnion π₂ h).tag J = π₁.tag J :=\n  dif_pos hJ\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.disjUnion_tag_of_mem_right","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.TaggedPrepartition I\nh : Disjoint π₁.iUnion π₂.iUnion\nhJ : Membership.mem π₂ J\n⊢ Eq ((π₁.disjUnion π₂ h).tag J) (π₂.tag J)","decl":"theorem disjUnion_tag_of_mem_right (h : Disjoint π₁.iUnion π₂.iUnion) (hJ : J ∈ π₂) :\n    (π₁.disjUnion π₂ h).tag J = π₂.tag J :=\n  dif_neg fun h₁ => h.le_bot ⟨π₁.subset_iUnion h₁ J.upper_mem, π₂.subset_iUnion hJ J.upper_mem⟩\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.IsSubordinate.disjUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.TaggedPrepartition I\nr : (ι → Real) → ↑(Set.Ioi 0)\ninst✝ : Fintype ι\nh₁ : π₁.IsSubordinate r\nh₂ : π₂.IsSubordinate r\nh : Disjoint π₁.iUnion π₂.iUnion\n⊢ (π₁.disjUnion π₂ h).IsSubordinate r","decl":"theorem IsSubordinate.disjUnion [Fintype ι] (h₁ : IsSubordinate π₁ r) (h₂ : IsSubordinate π₂ r)\n    (h : Disjoint π₁.iUnion π₂.iUnion) : IsSubordinate (π₁.disjUnion π₂ h) r := by\n  classical\n  refine fun J hJ => (Finset.mem_union.1 hJ).elim (fun hJ => ?_) fun hJ => ?_\n  · rw [disjUnion_tag_of_mem_left _ hJ]\n    exact h₁ _ hJ\n  · rw [disjUnion_tag_of_mem_right _ hJ]\n    exact h₂ _ hJ\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.IsHenstock.disjUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.TaggedPrepartition I\nh₁ : π₁.IsHenstock\nh₂ : π₂.IsHenstock\nh : Disjoint π₁.iUnion π₂.iUnion\n⊢ (π₁.disjUnion π₂ h).IsHenstock","decl":"theorem IsHenstock.disjUnion (h₁ : IsHenstock π₁) (h₂ : IsHenstock π₂)\n    (h : Disjoint π₁.iUnion π₂.iUnion) : IsHenstock (π₁.disjUnion π₂ h) := by\n  classical\n  refine fun J hJ => (Finset.mem_union.1 hJ).elim (fun hJ => ?_) fun hJ => ?_\n  · rw [disjUnion_tag_of_mem_left _ hJ]\n    exact h₁ _ hJ\n  · rw [disjUnion_tag_of_mem_right _ hJ]\n    exact h₂ _ hJ\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.distortion_le_of_mem","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\ninst✝ : Fintype ι\nh : Membership.mem π J\n⊢ LE.le J.distortion π.distortion","decl":"theorem distortion_le_of_mem (h : J ∈ π) : J.distortion ≤ π.distortion :=\n  le_sup h\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.distortion_le_iff","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\ninst✝ : Fintype ι\nc : NNReal\n⊢ Iff (LE.le π.distortion c) (∀ (J : BoxIntegral.Box ι), Membership.mem π J → LE.le J.distortion c)","decl":"theorem distortion_le_iff {c : ℝ≥0} : π.distortion ≤ c ↔ ∀ J ∈ π, Box.distortion J ≤ c :=\n  Finset.sup_le_iff\n\n"}
{"name":"BoxIntegral.Prepartition.distortion_biUnionTagged","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nπ : BoxIntegral.Prepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.TaggedPrepartition J\n⊢ Eq (π.biUnionTagged πi).distortion (π.boxes.sup fun J => (πi J).distortion)","decl":"@[simp]\ntheorem _root_.BoxIntegral.Prepartition.distortion_biUnionTagged (π : Prepartition I)\n    (πi : ∀ J, TaggedPrepartition J) :\n    (π.biUnionTagged πi).distortion = π.boxes.sup fun J => (πi J).distortion := by\n  classical exact sup_biUnion _ _\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.distortion_biUnionPrepartition","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\ninst✝ : Fintype ι\nπ : BoxIntegral.TaggedPrepartition I\nπi : (J : BoxIntegral.Box ι) → BoxIntegral.Prepartition J\n⊢ Eq (π.biUnionPrepartition πi).distortion (π.boxes.sup fun J => (πi J).distortion)","decl":"@[simp]\ntheorem distortion_biUnionPrepartition (π : TaggedPrepartition I) (πi : ∀ J, Prepartition J) :\n    (π.biUnionPrepartition πi).distortion = π.boxes.sup fun J => (πi J).distortion := by\n  classical exact sup_biUnion _ _\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.distortion_disjUnion","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ₁ π₂ : BoxIntegral.TaggedPrepartition I\ninst✝ : Fintype ι\nh : Disjoint π₁.iUnion π₂.iUnion\n⊢ Eq (π₁.disjUnion π₂ h).distortion (Max.max π₁.distortion π₂.distortion)","decl":"@[simp]\ntheorem distortion_disjUnion (h : Disjoint π₁.iUnion π₂.iUnion) :\n    (π₁.disjUnion π₂ h).distortion = max π₁.distortion π₂.distortion := by\n  classical exact sup_union\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.distortion_of_const","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\ninst✝ : Fintype ι\nc : NNReal\nh₁ : π.boxes.Nonempty\nh₂ : ∀ (J : BoxIntegral.Box ι), Membership.mem π J → Eq J.distortion c\n⊢ Eq π.distortion c","decl":"theorem distortion_of_const {c} (h₁ : π.boxes.Nonempty) (h₂ : ∀ J ∈ π, Box.distortion J = c) :\n    π.distortion = c :=\n  (sup_congr rfl h₂).trans (sup_const h₁ _)\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.distortion_single","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI J : BoxIntegral.Box ι\nx : ι → Real\ninst✝ : Fintype ι\nhJ : LE.le J I\nh : Membership.mem (BoxIntegral.Box.Icc I) x\n⊢ Eq (BoxIntegral.TaggedPrepartition.single I J hJ x h).distortion J.distortion","decl":"@[simp]\ntheorem distortion_single (hJ : J ≤ I) (h : x ∈ Box.Icc I) :\n    distortion (single I J hJ x h) = J.distortion :=\n  sup_singleton\n\n"}
{"name":"BoxIntegral.TaggedPrepartition.distortion_filter_le","module":"Mathlib.Analysis.BoxIntegral.Partition.Tagged","initialProofState":"ι : Type u_1\nI : BoxIntegral.Box ι\nπ : BoxIntegral.TaggedPrepartition I\ninst✝ : Fintype ι\np : BoxIntegral.Box ι → Prop\n⊢ LE.le (π.filter p).distortion π.distortion","decl":"theorem distortion_filter_le (p : Box ι → Prop) : (π.filter p).distortion ≤ π.distortion := by\n  classical exact sup_mono (filter_subset _ _)\n\n"}
