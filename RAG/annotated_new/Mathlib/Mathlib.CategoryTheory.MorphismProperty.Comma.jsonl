{"name":"CategoryTheory.MorphismProperty.costructuredArrow_iso_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝² : CategoryTheory.Category.{u_5, u_1} A\nT : Type u_3\ninst✝¹ : CategoryTheory.Category.{u_4, u_3} T\nP : CategoryTheory.MorphismProperty T\ninst✝ : P.RespectsIso\nL : CategoryTheory.Functor A T\nX : T\nf g : CategoryTheory.CostructuredArrow L X\ne : CategoryTheory.Iso f g\n⊢ Iff (P f.hom) (P g.hom)","decl":"lemma costructuredArrow_iso_iff (P : MorphismProperty T) [P.RespectsIso]\n    {L : A ⥤ T} {X : T} {f g : CostructuredArrow L X} (e : f ≅ g) :\n    P f.hom ↔ P g.hom :=\n  P.comma_iso_iff e\n\n"}
{"name":"CategoryTheory.MorphismProperty.over_iso_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_3\ninst✝¹ : CategoryTheory.Category.{u_4, u_3} T\nP : CategoryTheory.MorphismProperty T\ninst✝ : P.RespectsIso\nX : T\nf g : CategoryTheory.Over X\ne : CategoryTheory.Iso f g\n⊢ Iff (P f.hom) (P g.hom)","decl":"lemma over_iso_iff (P : MorphismProperty T) [P.RespectsIso] {X : T} {f g : Over X} (e : f ≅ g) :\n    P f.hom ↔ P g.hom :=\n  P.comma_iso_iff e\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mk.injEq","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝² : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ntoComma✝ : CategoryTheory.Comma L R\nprop✝ : P toComma✝.hom\ntoComma : CategoryTheory.Comma L R\nprop : P toComma.hom\n⊢ Eq (Eq { toComma := toComma✝, prop := prop✝ } { toComma := toComma, prop := prop }) (Eq toComma✝ toComma)","decl":"/-- `P.Comma L R Q W` is the subcategory of `Comma L R` consisting of\nobjects `X : Comma L R` where `X.hom` satisfies `P`. The morphisms are given by\nmorphisms in `Comma L R` where the left one satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nprotected structure Comma (Q : MorphismProperty A) (W : MorphismProperty B) extends Comma L R where\n  prop : P toComma.hom\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mk.inj","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝² : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ntoComma✝ : CategoryTheory.Comma L R\nprop✝ : P toComma✝.hom\ntoComma : CategoryTheory.Comma L R\nprop : P toComma.hom\nx✝ : Eq { toComma := toComma✝, prop := prop✝ } { toComma := toComma, prop := prop }\n⊢ Eq toComma✝ toComma","decl":"/-- `P.Comma L R Q W` is the subcategory of `Comma L R` consisting of\nobjects `X : Comma L R` where `X.hom` satisfies `P`. The morphisms are given by\nmorphisms in `Comma L R` where the left one satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nprotected structure Comma (Q : MorphismProperty A) (W : MorphismProperty B) extends Comma L R where\n  prop : P toComma.hom\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁸ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝⁶ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝⁵ : SizeOf A\ninst✝⁴ : SizeOf B\ninst✝³ : SizeOf T\ninst✝² : ⦃X Y : T⦄ → (x : Quiver.Hom X Y) → SizeOf (P x)\ninst✝¹ : ⦃X Y : A⦄ → (x : Quiver.Hom X Y) → SizeOf (Q x)\ninst✝ : ⦃X Y : B⦄ → (x : Quiver.Hom X Y) → SizeOf (W x)\ntoComma : CategoryTheory.Comma L R\nprop : P toComma.hom\n⊢ Eq (SizeOf.sizeOf { toComma := toComma, prop := prop }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toComma)) (SizeOf.sizeOf prop))","decl":"/-- `P.Comma L R Q W` is the subcategory of `Comma L R` consisting of\nobjects `X : Comma L R` where `X.hom` satisfies `P`. The morphisms are given by\nmorphisms in `Comma L R` where the left one satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nprotected structure Comma (Q : MorphismProperty A) (W : MorphismProperty B) extends Comma L R where\n  prop : P toComma.hom\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.prop","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝² : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nself : CategoryTheory.MorphismProperty.Comma L R P Q W\n⊢ P self.hom","decl":"/-- `P.Comma L R Q W` is the subcategory of `Comma L R` consisting of\nobjects `X : Comma L R` where `X.hom` satisfies `P`. The morphisms are given by\nmorphisms in `Comma L R` where the left one satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nprotected structure Comma (Q : MorphismProperty A) (W : MorphismProperty B) extends Comma L R where\n  prop : P toComma.hom\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.ext_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝² : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nx y : CategoryTheory.MorphismProperty.Comma L R P Q W\n⊢ Iff (Eq x y) (And (Eq x.left y.left) (And (Eq x.right y.right) (HEq x.hom y.hom)))","decl":"/-- `P.Comma L R Q W` is the subcategory of `Comma L R` consisting of\nobjects `X : Comma L R` where `X.hom` satisfies `P`. The morphisms are given by\nmorphisms in `Comma L R` where the left one satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nprotected structure Comma (Q : MorphismProperty A) (W : MorphismProperty B) extends Comma L R where\n  prop : P toComma.hom\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.ext","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝² : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nx y : CategoryTheory.MorphismProperty.Comma L R P Q W\nleft : Eq x.left y.left\nright : Eq x.right y.right\nhom : HEq x.hom y.hom\n⊢ Eq x y","decl":"/-- `P.Comma L R Q W` is the subcategory of `Comma L R` consisting of\nobjects `X : Comma L R` where `X.hom` satisfies `P`. The morphisms are given by\nmorphisms in `Comma L R` where the left one satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nprotected structure Comma (Q : MorphismProperty A) (W : MorphismProperty B) extends Comma L R where\n  prop : P toComma.hom\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.ext","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝² : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nx y : X.Hom Y\nleft : Eq x.left y.left\nright : Eq x.right y.right\n⊢ Eq x y","decl":"/-- A morphism in `P.Comma L R Q W` is a morphism in `Comma L R` where the left\nhom satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nstructure Hom (X Y : P.Comma L R Q W) extends CommaMorphism X.toComma Y.toComma where\n  prop_hom_left : Q toCommaMorphism.left\n  prop_hom_right : W toCommaMorphism.right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.mk.injEq","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝² : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\ntoCommaMorphism✝ : CategoryTheory.CommaMorphism X.toComma Y.toComma\nprop_hom_left✝ : Q toCommaMorphism✝.left\nprop_hom_right✝ : W toCommaMorphism✝.right\ntoCommaMorphism : CategoryTheory.CommaMorphism X.toComma Y.toComma\nprop_hom_left : Q toCommaMorphism.left\nprop_hom_right : W toCommaMorphism.right\n⊢ Eq (Eq { toCommaMorphism := toCommaMorphism✝, prop_hom_left := prop_hom_left✝, prop_hom_right := prop_hom_right✝ } { toCommaMorphism := toCommaMorphism, prop_hom_left := prop_hom_left, prop_hom_right := prop_hom_right }) (Eq toCommaMorphism✝ toCommaMorphism)","decl":"/-- A morphism in `P.Comma L R Q W` is a morphism in `Comma L R` where the left\nhom satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nstructure Hom (X Y : P.Comma L R Q W) extends CommaMorphism X.toComma Y.toComma where\n  prop_hom_left : Q toCommaMorphism.left\n  prop_hom_right : W toCommaMorphism.right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁸ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝⁶ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\ninst✝⁵ : SizeOf A\ninst✝⁴ : SizeOf B\ninst✝³ : SizeOf T\ninst✝² : ⦃X Y : T⦄ → (x : Quiver.Hom X Y) → SizeOf (P x)\ninst✝¹ : ⦃X Y : A⦄ → (x : Quiver.Hom X Y) → SizeOf (Q x)\ninst✝ : ⦃X Y : B⦄ → (x : Quiver.Hom X Y) → SizeOf (W x)\ntoCommaMorphism : CategoryTheory.CommaMorphism X.toComma Y.toComma\nprop_hom_left : Q toCommaMorphism.left\nprop_hom_right : W toCommaMorphism.right\n⊢ Eq (SizeOf.sizeOf { toCommaMorphism := toCommaMorphism, prop_hom_left := prop_hom_left, prop_hom_right := prop_hom_right }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toCommaMorphism)) (SizeOf.sizeOf prop_hom_left)) (SizeOf.sizeOf prop_hom_right))","decl":"/-- A morphism in `P.Comma L R Q W` is a morphism in `Comma L R` where the left\nhom satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nstructure Hom (X Y : P.Comma L R Q W) extends CommaMorphism X.toComma Y.toComma where\n  prop_hom_left : Q toCommaMorphism.left\n  prop_hom_right : W toCommaMorphism.right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.mk.inj","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝² : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\ntoCommaMorphism✝ : CategoryTheory.CommaMorphism X.toComma Y.toComma\nprop_hom_left✝ : Q toCommaMorphism✝.left\nprop_hom_right✝ : W toCommaMorphism✝.right\ntoCommaMorphism : CategoryTheory.CommaMorphism X.toComma Y.toComma\nprop_hom_left : Q toCommaMorphism.left\nprop_hom_right : W toCommaMorphism.right\nx✝ : Eq { toCommaMorphism := toCommaMorphism✝, prop_hom_left := prop_hom_left✝, prop_hom_right := prop_hom_right✝ } { toCommaMorphism := toCommaMorphism, prop_hom_left := prop_hom_left, prop_hom_right := prop_hom_right }\n⊢ Eq toCommaMorphism✝ toCommaMorphism","decl":"/-- A morphism in `P.Comma L R Q W` is a morphism in `Comma L R` where the left\nhom satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nstructure Hom (X Y : P.Comma L R Q W) extends CommaMorphism X.toComma Y.toComma where\n  prop_hom_left : Q toCommaMorphism.left\n  prop_hom_right : W toCommaMorphism.right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.prop_hom_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝² : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nself : X.Hom Y\n⊢ W self.right","decl":"/-- A morphism in `P.Comma L R Q W` is a morphism in `Comma L R` where the left\nhom satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nstructure Hom (X Y : P.Comma L R Q W) extends CommaMorphism X.toComma Y.toComma where\n  prop_hom_left : Q toCommaMorphism.left\n  prop_hom_right : W toCommaMorphism.right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.ext_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝² : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nx y : X.Hom Y\n⊢ Iff (Eq x y) (And (Eq x.left y.left) (Eq x.right y.right))","decl":"/-- A morphism in `P.Comma L R Q W` is a morphism in `Comma L R` where the left\nhom satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nstructure Hom (X Y : P.Comma L R Q W) extends CommaMorphism X.toComma Y.toComma where\n  prop_hom_left : Q toCommaMorphism.left\n  prop_hom_right : W toCommaMorphism.right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.prop_hom_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝² : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nself : X.Hom Y\n⊢ Q self.left","decl":"/-- A morphism in `P.Comma L R Q W` is a morphism in `Comma L R` where the left\nhom satisfies `Q` and the right one satisfies `W`. -/\n@[ext]\nstructure Hom (X Y : P.Comma L R Q W) extends CommaMorphism X.toComma Y.toComma where\n  prop_hom_left : Q toCommaMorphism.left\n  prop_hom_right : W toCommaMorphism.right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.hom_mk","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝² : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : CategoryTheory.CommaMorphism X.toComma Y.toComma\nhf : Q f.left\nhg : W f.right\n⊢ Eq { toCommaMorphism := f, prop_hom_left := hf, prop_hom_right := hg }.hom f","decl":"@[simp, nolint simpVarHead]\nlemma Hom.hom_mk {X Y : P.Comma L R Q W}\n    (f : CommaMorphism X.toComma Y.toComma) (hf) (hg) :\n  Comma.Hom.hom ⟨f, hf, hg⟩ = f := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.hom_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝² : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : X.Hom Y\n⊢ Eq f.hom.left f.left","decl":"lemma Hom.hom_left {X Y : P.Comma L R Q W} (f : Comma.Hom X Y) : f.hom.left = f.left := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.hom_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝² : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : X.Hom Y\n⊢ Eq f.hom.right f.right","decl":"lemma Hom.hom_right {X Y : P.Comma L R Q W} (f : Comma.Hom X Y) : f.hom.right = f.right := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.id_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.ContainsIdentities\ninst✝ : W.ContainsIdentities\nX : CategoryTheory.MorphismProperty.Comma L R P Q W\n⊢ Eq X.id.right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- The identity morphism of an object in `P.Comma L R Q W`. -/\n@[simps]\ndef id [Q.ContainsIdentities] [W.ContainsIdentities] (X : P.Comma L R Q W) : Comma.Hom X X where\n  left := 𝟙 X.left\n  prop_hom_left := Q.id_mem X.toComma.left\n  prop_hom_right := W.id_mem X.toComma.right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.id_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.ContainsIdentities\ninst✝ : W.ContainsIdentities\nX : CategoryTheory.MorphismProperty.Comma L R P Q W\n⊢ Eq X.id.left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The identity morphism of an object in `P.Comma L R Q W`. -/\n@[simps]\ndef id [Q.ContainsIdentities] [W.ContainsIdentities] (X : P.Comma L R Q W) : Comma.Hom X X where\n  left := 𝟙 X.left\n  prop_hom_left := Q.id_mem X.toComma.left\n  prop_hom_right := W.id_mem X.toComma.right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.comp_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsStableUnderComposition\ninst✝ : W.IsStableUnderComposition\nX Y Z : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : X.Hom Y\ng : Y.Hom Z\n⊢ Eq (f.comp g).right (CategoryTheory.CategoryStruct.comp f.right g.right)","decl":"/-- Composition of morphisms in `P.Comma L R Q W`. -/\n@[simps]\ndef Hom.comp [Q.IsStableUnderComposition] [W.IsStableUnderComposition] {X Y Z : P.Comma L R Q W}\n    (f : Comma.Hom X Y) (g : Comma.Hom Y Z) :\n    Comma.Hom X Z where\n  left := f.left ≫ g.left\n  right := f.right ≫ g.right\n  prop_hom_left := Q.comp_mem _ _ f.prop_hom_left g.prop_hom_left\n  prop_hom_right := W.comp_mem _ _ f.prop_hom_right g.prop_hom_right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.comp_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsStableUnderComposition\ninst✝ : W.IsStableUnderComposition\nX Y Z : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : X.Hom Y\ng : Y.Hom Z\n⊢ Eq (f.comp g).left (CategoryTheory.CategoryStruct.comp f.left g.left)","decl":"/-- Composition of morphisms in `P.Comma L R Q W`. -/\n@[simps]\ndef Hom.comp [Q.IsStableUnderComposition] [W.IsStableUnderComposition] {X Y Z : P.Comma L R Q W}\n    (f : Comma.Hom X Y) (g : Comma.Hom Y Z) :\n    Comma.Hom X Z where\n  left := f.left ≫ g.left\n  right := f.right ≫ g.right\n  prop_hom_left := Q.comp_mem _ _ f.prop_hom_left g.prop_hom_left\n  prop_hom_right := W.comp_mem _ _ f.prop_hom_right g.prop_hom_right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.toCommaMorphism_eq_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : Quiver.Hom X Y\n⊢ Eq f.toCommaMorphism (CategoryTheory.MorphismProperty.Comma.Hom.hom f)","decl":"lemma toCommaMorphism_eq_hom {X Y : P.Comma L R Q W} (f : X ⟶ Y) : f.toCommaMorphism = f.hom := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.ext'","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nf g : Quiver.Hom X Y\nh : Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom f) (CategoryTheory.MorphismProperty.Comma.Hom.hom g)\n⊢ Eq f g","decl":"/-- Alternative `ext` lemma for `Comma.Hom`. -/\n@[ext]\nlemma Hom.ext' {X Y : P.Comma L R Q W} {f g : X ⟶ Y} (h : f.hom = g.hom) :\n    f = g := Comma.Hom.ext\n  (congrArg CommaMorphism.left h)\n  (congrArg CommaMorphism.right h)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.Hom.ext'_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nf g : Quiver.Hom X Y\n⊢ Iff (Eq f g) (Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom f) (CategoryTheory.MorphismProperty.Comma.Hom.hom g))","decl":"/-- Alternative `ext` lemma for `Comma.Hom`. -/\n@[ext]\nlemma Hom.ext' {X Y : P.Comma L R Q W} {f g : X ⟶ Y} (h : f.hom = g.hom) :\n    f = g := Comma.Hom.ext\n  (congrArg CommaMorphism.left h)\n  (congrArg CommaMorphism.right h)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.id_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nX : CategoryTheory.MorphismProperty.Comma L R P Q W\n⊢ Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.CategoryStruct.id X.toComma)","decl":"@[simp]\nlemma id_hom (X : P.Comma L R Q W) : (𝟙 X : X ⟶ X).hom = 𝟙 X.toComma := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.comp_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nX Y Z : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MorphismProperty.Comma.Hom.hom f) (CategoryTheory.MorphismProperty.Comma.Hom.hom g))","decl":"@[simp]\nlemma comp_hom {X Y Z : P.Comma L R Q W} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (f ≫ g).hom = f.hom ≫ g.hom := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.comp_left_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nX Y Z✝ : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z✝\nZ : A\nh : Quiver.Hom Z✝.left Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).left h) (CategoryTheory.CategoryStruct.comp f.left (CategoryTheory.CategoryStruct.comp g.left h))","decl":"@[reassoc]\nlemma comp_left {X Y Z : P.Comma L R Q W} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (f ≫ g).left = f.left ≫ g.left := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.comp_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nX Y Z : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).left (CategoryTheory.CategoryStruct.comp f.left g.left)","decl":"@[reassoc]\nlemma comp_left {X Y Z : P.Comma L R Q W} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (f ≫ g).left = f.left ≫ g.left := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.comp_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nX Y Z : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).right (CategoryTheory.CategoryStruct.comp f.right g.right)","decl":"@[reassoc]\nlemma comp_right {X Y Z : P.Comma L R Q W} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (f ≫ g).right = f.right ≫ g.right := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.comp_right_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nX Y Z✝ : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z✝\nZ : B\nh : Quiver.Hom Z✝.right Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).right h) (CategoryTheory.CategoryStruct.comp f.right (CategoryTheory.CategoryStruct.comp g.right h))","decl":"@[reassoc]\nlemma comp_right {X Y Z : P.Comma L R Q W} (f : X ⟶ Y) (g : Y ⟶ Z) :\n    (f ≫ g).right = f.right ≫ g.right := rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.homFromCommaOfIsIso_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝⁴ : Q.IsMultiplicative\ninst✝³ : W.IsMultiplicative\ninst✝² : Q.RespectsIso\ninst✝¹ : W.RespectsIso\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\ni : Quiver.Hom X.toComma Y.toComma\ninst✝ : CategoryTheory.IsIso i\n⊢ Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom (CategoryTheory.MorphismProperty.Comma.homFromCommaOfIsIso i)) i","decl":"/-- If `i` is an isomorphism in `Comma L R`, it is also a morphism in `P.Comma L R Q W`. -/\n@[simps hom]\ndef homFromCommaOfIsIso [Q.RespectsIso] [W.RespectsIso] {X Y : P.Comma L R Q W}\n    (i : X.toComma ⟶ Y.toComma) [IsIso i] :\n    X ⟶ Y where\n  __ := i\n  prop_hom_left := Q.of_isIso i.left\n  prop_hom_right := W.of_isIso i.right\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.instIsIsoHomFromCommaOfIsIso","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝⁴ : Q.IsMultiplicative\ninst✝³ : W.IsMultiplicative\ninst✝² : Q.RespectsIso\ninst✝¹ : W.RespectsIso\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\ni : Quiver.Hom X.toComma Y.toComma\ninst✝ : CategoryTheory.IsIso i\n⊢ CategoryTheory.IsIso (CategoryTheory.MorphismProperty.Comma.homFromCommaOfIsIso i)","decl":"instance [Q.RespectsIso] [W.RespectsIso] {X Y : P.Comma L R Q W} (i : X.toComma ⟶ Y.toComma)\n    [IsIso i] : IsIso (homFromCommaOfIsIso i) := by\n  constructor\n  use homFromCommaOfIsIso (inv i)\n  constructor <;> ext : 1 <;> simp\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.isoFromComma_inv","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝³ : Q.IsMultiplicative\ninst✝² : W.IsMultiplicative\ninst✝¹ : Q.RespectsIso\ninst✝ : W.RespectsIso\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\ni : CategoryTheory.Iso X.toComma Y.toComma\n⊢ Eq (CategoryTheory.MorphismProperty.Comma.isoFromComma i).inv (CategoryTheory.MorphismProperty.Comma.homFromCommaOfIsIso i.inv)","decl":"/-- Any isomorphism between objects of `P.Comma L R Q W` in `Comma L R` is also an isomorphism\nin `P.Comma L R Q W`.  -/\n@[simps]\ndef isoFromComma [Q.RespectsIso] [W.RespectsIso] {X Y : P.Comma L R Q W}\n    (i : X.toComma ≅ Y.toComma) : X ≅ Y where\n  hom := homFromCommaOfIsIso i.hom\n  inv := homFromCommaOfIsIso i.inv\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.isoFromComma_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝³ : Q.IsMultiplicative\ninst✝² : W.IsMultiplicative\ninst✝¹ : Q.RespectsIso\ninst✝ : W.RespectsIso\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\ni : CategoryTheory.Iso X.toComma Y.toComma\n⊢ Eq (CategoryTheory.MorphismProperty.Comma.isoFromComma i).hom (CategoryTheory.MorphismProperty.Comma.homFromCommaOfIsIso i.hom)","decl":"/-- Any isomorphism between objects of `P.Comma L R Q W` in `Comma L R` is also an isomorphism\nin `P.Comma L R Q W`.  -/\n@[simps]\ndef isoFromComma [Q.RespectsIso] [W.RespectsIso] {X Y : P.Comma L R Q W}\n    (i : X.toComma ≅ Y.toComma) : X ≅ Y where\n  hom := homFromCommaOfIsIso i.hom\n  inv := homFromCommaOfIsIso i.inv\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.isoMk_hom_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝³ : Q.IsMultiplicative\ninst✝² : W.IsMultiplicative\ninst✝¹ : Q.RespectsIso\ninst✝ : W.RespectsIso\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nl : CategoryTheory.Iso X.left Y.left\nr : CategoryTheory.Iso X.right Y.right\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L.map l.hom) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R.map r.hom))) _auto✝\n⊢ Eq (CategoryTheory.MorphismProperty.Comma.isoMk l r h).hom.right r.hom","decl":"/-- Constructor for isomorphisms in `P.Comma L R Q W` from isomorphisms of the left and right\ncomponents and naturality in the forward direction. -/\n@[simps!]\ndef isoMk [Q.RespectsIso] [W.RespectsIso] {X Y : P.Comma L R Q W} (l : X.left ≅ Y.left)\n    (r : X.right ≅ Y.right) (h : L.map l.hom ≫ Y.hom = X.hom ≫ R.map r.hom := by aesop_cat) :\n    X ≅ Y :=\n  isoFromComma (CategoryTheory.Comma.isoMk l r h)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.isoMk_inv_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝³ : Q.IsMultiplicative\ninst✝² : W.IsMultiplicative\ninst✝¹ : Q.RespectsIso\ninst✝ : W.RespectsIso\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nl : CategoryTheory.Iso X.left Y.left\nr : CategoryTheory.Iso X.right Y.right\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L.map l.hom) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R.map r.hom))) _auto✝\n⊢ Eq (CategoryTheory.MorphismProperty.Comma.isoMk l r h).inv.right r.inv","decl":"/-- Constructor for isomorphisms in `P.Comma L R Q W` from isomorphisms of the left and right\ncomponents and naturality in the forward direction. -/\n@[simps!]\ndef isoMk [Q.RespectsIso] [W.RespectsIso] {X Y : P.Comma L R Q W} (l : X.left ≅ Y.left)\n    (r : X.right ≅ Y.right) (h : L.map l.hom ≫ Y.hom = X.hom ≫ R.map r.hom := by aesop_cat) :\n    X ≅ Y :=\n  isoFromComma (CategoryTheory.Comma.isoMk l r h)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.isoMk_inv_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝³ : Q.IsMultiplicative\ninst✝² : W.IsMultiplicative\ninst✝¹ : Q.RespectsIso\ninst✝ : W.RespectsIso\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nl : CategoryTheory.Iso X.left Y.left\nr : CategoryTheory.Iso X.right Y.right\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L.map l.hom) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R.map r.hom))) _auto✝\n⊢ Eq (CategoryTheory.MorphismProperty.Comma.isoMk l r h).inv.left l.inv","decl":"/-- Constructor for isomorphisms in `P.Comma L R Q W` from isomorphisms of the left and right\ncomponents and naturality in the forward direction. -/\n@[simps!]\ndef isoMk [Q.RespectsIso] [W.RespectsIso] {X Y : P.Comma L R Q W} (l : X.left ≅ Y.left)\n    (r : X.right ≅ Y.right) (h : L.map l.hom ≫ Y.hom = X.hom ≫ R.map r.hom := by aesop_cat) :\n    X ≅ Y :=\n  isoFromComma (CategoryTheory.Comma.isoMk l r h)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.isoMk_hom_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝³ : Q.IsMultiplicative\ninst✝² : W.IsMultiplicative\ninst✝¹ : Q.RespectsIso\ninst✝ : W.RespectsIso\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nl : CategoryTheory.Iso X.left Y.left\nr : CategoryTheory.Iso X.right Y.right\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (L.map l.hom) Y.hom) (CategoryTheory.CategoryStruct.comp X.hom (R.map r.hom))) _auto✝\n⊢ Eq (CategoryTheory.MorphismProperty.Comma.isoMk l r h).hom.left l.hom","decl":"/-- Constructor for isomorphisms in `P.Comma L R Q W` from isomorphisms of the left and right\ncomponents and naturality in the forward direction. -/\n@[simps!]\ndef isoMk [Q.RespectsIso] [W.RespectsIso] {X Y : P.Comma L R Q W} (l : X.left ≅ Y.left)\n    (r : X.right ≅ Y.right) (h : L.map l.hom ≫ Y.hom = X.hom ≫ R.map r.hom := by aesop_cat) :\n    X ≅ Y :=\n  isoFromComma (CategoryTheory.Comma.isoMk l r h)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.forget_map","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nX✝ Y✝ : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.MorphismProperty.Comma.forget L R P Q W).map f) (CategoryTheory.MorphismProperty.Comma.Hom.hom f)","decl":"/-- The forgetful functor. -/\n@[simps]\ndef forget : P.Comma L R Q W ⥤ Comma L R where\n  obj X := X.toComma\n  map f := f.hom\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.forget_obj","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nX : CategoryTheory.MorphismProperty.Comma L R P Q W\n⊢ Eq ((CategoryTheory.MorphismProperty.Comma.forget L R P Q W).obj X) X.toComma","decl":"/-- The forgetful functor. -/\n@[simps]\ndef forget : P.Comma L R Q W ⥤ Comma L R where\n  obj X := X.toComma\n  map f := f.hom\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.instFaithfulCommaForget","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\n⊢ (CategoryTheory.MorphismProperty.Comma.forget L R P Q W).Faithful","decl":"instance : (forget L R P Q W).Faithful where\n  map_injective := Comma.Hom.ext'\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.instIsIsoCommaHom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝³ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝² : Q.IsMultiplicative\ninst✝¹ : W.IsMultiplicative\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\n⊢ CategoryTheory.IsIso (CategoryTheory.MorphismProperty.Comma.Hom.hom f)","decl":"instance {X Y : P.Comma L R Q W} (f : X ⟶ Y) [IsIso f] : IsIso f.hom :=\n  (forget L R P Q W).map_isIso f\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.hom_homFromCommaOfIsIso","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁷ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝⁵ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝⁴ : Q.IsMultiplicative\ninst✝³ : W.IsMultiplicative\ninst✝² : Q.RespectsIso\ninst✝¹ : W.RespectsIso\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\ni : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso (CategoryTheory.MorphismProperty.Comma.Hom.hom i)\n⊢ Eq (CategoryTheory.MorphismProperty.Comma.homFromCommaOfIsIso (CategoryTheory.MorphismProperty.Comma.Hom.hom i)) i","decl":"lemma hom_homFromCommaOfIsIso [Q.RespectsIso] [W.RespectsIso] {X Y : P.Comma L R Q W}\n    (i : X ⟶ Y) [IsIso i.hom] :\n    homFromCommaOfIsIso i.hom = i :=\n  rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.inv_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝³ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝² : Q.IsMultiplicative\ninst✝¹ : W.IsMultiplicative\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\n⊢ Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom (CategoryTheory.inv f)) (CategoryTheory.inv (CategoryTheory.MorphismProperty.Comma.Hom.hom f))","decl":"lemma inv_hom {X Y : P.Comma L R Q W} (f : X ⟶ Y) [IsIso f] : (inv f).hom = inv f.hom := by\n  apply IsIso.eq_inv_of_hom_inv_id\n  rw [← comp_hom, IsIso.hom_inv_id, id_hom]\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.instReflectsIsomorphismsCommaForgetOfRespectsIso","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝⁵ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝⁴ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝³ : Q.IsMultiplicative\ninst✝² : W.IsMultiplicative\ninst✝¹ : Q.RespectsIso\ninst✝ : W.RespectsIso\n⊢ (CategoryTheory.MorphismProperty.Comma.forget L R P Q W).ReflectsIsomorphisms","decl":"instance [Q.RespectsIso] [W.RespectsIso] : (forget L R P Q W).ReflectsIsomorphisms where\n  reflects f hf := by\n    simp only [forget_obj, forget_map] at hf\n    rw [← hom_homFromCommaOfIsIso f]\n    infer_instance\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.instFullTopCommaForget","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝² : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝ : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\n⊢ (CategoryTheory.MorphismProperty.Comma.forget L R P Top.top Top.top).Full","decl":"instance : (forget L R P ⊤ ⊤).Full :=\n  Functor.FullyFaithful.full (forgetFullyFaithful L R P)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.eqToHom_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nh : Eq X Y\n⊢ Eq (CategoryTheory.eqToHom h).left (CategoryTheory.eqToHom ⋯)","decl":"@[simp]\nlemma eqToHom_left {X Y : P.Comma L R Q W} (h : X = Y) :\n    (eqToHom h).left = eqToHom (by rw [h]) := by\n  subst h\n  rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.eqToHom_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nX Y : CategoryTheory.MorphismProperty.Comma L R P Q W\nh : Eq X Y\n⊢ Eq (CategoryTheory.eqToHom h).right (CategoryTheory.eqToHom ⋯)","decl":"@[simp]\nlemma eqToHom_right {X Y : P.Comma L R Q W} (h : X = Y) :\n    (eqToHom h).right = eqToHom (by rw [h]) := by\n  subst h\n  rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.lift_obj_toComma","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} A\nB : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} B\nT : Type u_3\ninst✝³ : CategoryTheory.Category.{u_7, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝² : Q.IsMultiplicative\ninst✝¹ : W.IsMultiplicative\nC : Type u_4\ninst✝ : CategoryTheory.Category.{u_8, u_4} C\nF : CategoryTheory.Functor C (CategoryTheory.Comma L R)\nhP : ∀ (X : C), P (F.obj X).hom\nhQ : ∀ {X Y : C} (f : Quiver.Hom X Y), Q (F.map f).left\nhW : ∀ {X Y : C} (f : Quiver.Hom X Y), W (F.map f).right\nX : C\n⊢ Eq ((CategoryTheory.MorphismProperty.Comma.lift F hP hQ hW).obj X).toComma (F.obj X)","decl":"/-- Lift a functor `F : C ⥤ Comma L R` to the subcategory `P.Comma L R Q W` under\nsuitable assumptions on `F`. -/\n@[simps obj_toComma map_hom]\ndef lift {C : Type*} [Category C] (F : C ⥤ Comma L R)\n    (hP : ∀ X, P (F.obj X).hom)\n    (hQ : ∀ {X Y} (f : X ⟶ Y), Q (F.map f).left)\n    (hW : ∀ {X Y} (f : X ⟶ Y), W (F.map f).right) :\n    C ⥤ P.Comma L R Q W where\n  obj X :=\n    { __ := F.obj X\n      prop := hP X }\n  map {X Y} f :=\n    { __ := F.map f\n      prop_hom_left := hQ f\n      prop_hom_right := hW f }\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.lift_map_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_5, u_1} A\nB : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_6, u_2} B\nT : Type u_3\ninst✝³ : CategoryTheory.Category.{u_7, u_3} T\nL : CategoryTheory.Functor A T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝² : Q.IsMultiplicative\ninst✝¹ : W.IsMultiplicative\nC : Type u_4\ninst✝ : CategoryTheory.Category.{u_8, u_4} C\nF : CategoryTheory.Functor C (CategoryTheory.Comma L R)\nhP : ∀ (X : C), P (F.obj X).hom\nhQ : ∀ {X Y : C} (f : Quiver.Hom X Y), Q (F.map f).left\nhW : ∀ {X Y : C} (f : Quiver.Hom X Y), W (F.map f).right\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom ((CategoryTheory.MorphismProperty.Comma.lift F hP hQ hW).map f)) (F.map f)","decl":"/-- Lift a functor `F : C ⥤ Comma L R` to the subcategory `P.Comma L R Q W` under\nsuitable assumptions on `F`. -/\n@[simps obj_toComma map_hom]\ndef lift {C : Type*} [Category C] (F : C ⥤ Comma L R)\n    (hP : ∀ X, P (F.obj X).hom)\n    (hQ : ∀ {X Y} (f : X ⟶ Y), Q (F.map f).left)\n    (hW : ∀ {X Y} (f : X ⟶ Y), W (F.map f).right) :\n    C ⥤ P.Comma L R Q W where\n  obj X :=\n    { __ := F.obj X\n      prop := hP X }\n  map {X Y} f :=\n    { __ := F.map f\n      prop_hom_left := hQ f\n      prop_hom_right := hW f }\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mapLeft_map_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nL₁ L₂ : CategoryTheory.Functor A T\nl : Quiver.Hom L₁ L₂\nhl : ∀ (X : CategoryTheory.MorphismProperty.Comma L₂ R P Q W), P (CategoryTheory.CategoryStruct.comp (l.app X.left) X.hom)\nX Y : CategoryTheory.MorphismProperty.Comma L₂ R P Q W\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.MorphismProperty.Comma.mapLeft R l hl).map f).left (CategoryTheory.MorphismProperty.Comma.Hom.hom f).left","decl":"variable (R) in\n/-- A natural transformation `L₁ ⟶ L₂` induces a functor `P.Comma L₂ R Q W ⥤ P.Comma L₁ R Q W`. -/\n@[simps!]\ndef mapLeft (l : L₁ ⟶ L₂) (hl : ∀ X : P.Comma L₂ R Q W, P (l.app X.left ≫ X.hom)) :\n    P.Comma L₂ R Q W ⥤ P.Comma L₁ R Q W :=\n  lift (forget _ _ _ _ _ ⋙ CategoryTheory.Comma.mapLeft R l) hl\n    (fun f ↦ f.prop_hom_left) (fun f ↦ f.prop_hom_right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mapLeft_obj_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nL₁ L₂ : CategoryTheory.Functor A T\nl : Quiver.Hom L₁ L₂\nhl : ∀ (X : CategoryTheory.MorphismProperty.Comma L₂ R P Q W), P (CategoryTheory.CategoryStruct.comp (l.app X.left) X.hom)\nX : CategoryTheory.MorphismProperty.Comma L₂ R P Q W\n⊢ Eq ((CategoryTheory.MorphismProperty.Comma.mapLeft R l hl).obj X).hom (CategoryTheory.CategoryStruct.comp (l.app X.left) X.hom)","decl":"variable (R) in\n/-- A natural transformation `L₁ ⟶ L₂` induces a functor `P.Comma L₂ R Q W ⥤ P.Comma L₁ R Q W`. -/\n@[simps!]\ndef mapLeft (l : L₁ ⟶ L₂) (hl : ∀ X : P.Comma L₂ R Q W, P (l.app X.left ≫ X.hom)) :\n    P.Comma L₂ R Q W ⥤ P.Comma L₁ R Q W :=\n  lift (forget _ _ _ _ _ ⋙ CategoryTheory.Comma.mapLeft R l) hl\n    (fun f ↦ f.prop_hom_left) (fun f ↦ f.prop_hom_right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mapLeft_map_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nL₁ L₂ : CategoryTheory.Functor A T\nl : Quiver.Hom L₁ L₂\nhl : ∀ (X : CategoryTheory.MorphismProperty.Comma L₂ R P Q W), P (CategoryTheory.CategoryStruct.comp (l.app X.left) X.hom)\nX Y : CategoryTheory.MorphismProperty.Comma L₂ R P Q W\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.MorphismProperty.Comma.mapLeft R l hl).map f).right (CategoryTheory.MorphismProperty.Comma.Hom.hom f).right","decl":"variable (R) in\n/-- A natural transformation `L₁ ⟶ L₂` induces a functor `P.Comma L₂ R Q W ⥤ P.Comma L₁ R Q W`. -/\n@[simps!]\ndef mapLeft (l : L₁ ⟶ L₂) (hl : ∀ X : P.Comma L₂ R Q W, P (l.app X.left ≫ X.hom)) :\n    P.Comma L₂ R Q W ⥤ P.Comma L₁ R Q W :=\n  lift (forget _ _ _ _ _ ⋙ CategoryTheory.Comma.mapLeft R l) hl\n    (fun f ↦ f.prop_hom_left) (fun f ↦ f.prop_hom_right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mapLeft_obj_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nL₁ L₂ : CategoryTheory.Functor A T\nl : Quiver.Hom L₁ L₂\nhl : ∀ (X : CategoryTheory.MorphismProperty.Comma L₂ R P Q W), P (CategoryTheory.CategoryStruct.comp (l.app X.left) X.hom)\nX : CategoryTheory.MorphismProperty.Comma L₂ R P Q W\n⊢ Eq ((CategoryTheory.MorphismProperty.Comma.mapLeft R l hl).obj X).left X.left","decl":"variable (R) in\n/-- A natural transformation `L₁ ⟶ L₂` induces a functor `P.Comma L₂ R Q W ⥤ P.Comma L₁ R Q W`. -/\n@[simps!]\ndef mapLeft (l : L₁ ⟶ L₂) (hl : ∀ X : P.Comma L₂ R Q W, P (l.app X.left ≫ X.hom)) :\n    P.Comma L₂ R Q W ⥤ P.Comma L₁ R Q W :=\n  lift (forget _ _ _ _ _ ⋙ CategoryTheory.Comma.mapLeft R l) hl\n    (fun f ↦ f.prop_hom_left) (fun f ↦ f.prop_hom_right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mapLeft_obj_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nR : CategoryTheory.Functor B T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nL₁ L₂ : CategoryTheory.Functor A T\nl : Quiver.Hom L₁ L₂\nhl : ∀ (X : CategoryTheory.MorphismProperty.Comma L₂ R P Q W), P (CategoryTheory.CategoryStruct.comp (l.app X.left) X.hom)\nX : CategoryTheory.MorphismProperty.Comma L₂ R P Q W\n⊢ Eq ((CategoryTheory.MorphismProperty.Comma.mapLeft R l hl).obj X).right X.right","decl":"variable (R) in\n/-- A natural transformation `L₁ ⟶ L₂` induces a functor `P.Comma L₂ R Q W ⥤ P.Comma L₁ R Q W`. -/\n@[simps!]\ndef mapLeft (l : L₁ ⟶ L₂) (hl : ∀ X : P.Comma L₂ R Q W, P (l.app X.left ≫ X.hom)) :\n    P.Comma L₂ R Q W ⥤ P.Comma L₁ R Q W :=\n  lift (forget _ _ _ _ _ ⋙ CategoryTheory.Comma.mapLeft R l) hl\n    (fun f ↦ f.prop_hom_left) (fun f ↦ f.prop_hom_right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mapRight_obj_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nR₁ R₂ : CategoryTheory.Functor B T\nr : Quiver.Hom R₁ R₂\nhr : ∀ (X : CategoryTheory.MorphismProperty.Comma L R₁ P Q W), P (CategoryTheory.CategoryStruct.comp X.hom (r.app X.right))\nX : CategoryTheory.MorphismProperty.Comma L R₁ P Q W\n⊢ Eq ((CategoryTheory.MorphismProperty.Comma.mapRight L r hr).obj X).hom (CategoryTheory.CategoryStruct.comp X.hom (r.app X.right))","decl":"variable (L) in\n/-- A natural transformation `R₁ ⟶ R₂` induces a functor `P.Comma L R₁ Q W ⥤ P.Comma L R₂ Q W`. -/\n@[simps!]\ndef mapRight (r : R₁ ⟶ R₂) (hr : ∀ X : P.Comma L R₁ Q W, P (X.hom ≫ r.app X.right)) :\n    P.Comma L R₁ Q W ⥤ P.Comma L R₂ Q W :=\n  lift (forget _ _ _ _ _ ⋙ CategoryTheory.Comma.mapRight L r) hr\n    (fun f ↦ f.prop_hom_left) (fun f ↦ f.prop_hom_right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mapRight_map_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nR₁ R₂ : CategoryTheory.Functor B T\nr : Quiver.Hom R₁ R₂\nhr : ∀ (X : CategoryTheory.MorphismProperty.Comma L R₁ P Q W), P (CategoryTheory.CategoryStruct.comp X.hom (r.app X.right))\nX Y : CategoryTheory.MorphismProperty.Comma L R₁ P Q W\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.MorphismProperty.Comma.mapRight L r hr).map f).right (CategoryTheory.MorphismProperty.Comma.Hom.hom f).right","decl":"variable (L) in\n/-- A natural transformation `R₁ ⟶ R₂` induces a functor `P.Comma L R₁ Q W ⥤ P.Comma L R₂ Q W`. -/\n@[simps!]\ndef mapRight (r : R₁ ⟶ R₂) (hr : ∀ X : P.Comma L R₁ Q W, P (X.hom ≫ r.app X.right)) :\n    P.Comma L R₁ Q W ⥤ P.Comma L R₂ Q W :=\n  lift (forget _ _ _ _ _ ⋙ CategoryTheory.Comma.mapRight L r) hr\n    (fun f ↦ f.prop_hom_left) (fun f ↦ f.prop_hom_right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mapRight_obj_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nR₁ R₂ : CategoryTheory.Functor B T\nr : Quiver.Hom R₁ R₂\nhr : ∀ (X : CategoryTheory.MorphismProperty.Comma L R₁ P Q W), P (CategoryTheory.CategoryStruct.comp X.hom (r.app X.right))\nX : CategoryTheory.MorphismProperty.Comma L R₁ P Q W\n⊢ Eq ((CategoryTheory.MorphismProperty.Comma.mapRight L r hr).obj X).left X.left","decl":"variable (L) in\n/-- A natural transformation `R₁ ⟶ R₂` induces a functor `P.Comma L R₁ Q W ⥤ P.Comma L R₂ Q W`. -/\n@[simps!]\ndef mapRight (r : R₁ ⟶ R₂) (hr : ∀ X : P.Comma L R₁ Q W, P (X.hom ≫ r.app X.right)) :\n    P.Comma L R₁ Q W ⥤ P.Comma L R₂ Q W :=\n  lift (forget _ _ _ _ _ ⋙ CategoryTheory.Comma.mapRight L r) hr\n    (fun f ↦ f.prop_hom_left) (fun f ↦ f.prop_hom_right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mapRight_obj_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nR₁ R₂ : CategoryTheory.Functor B T\nr : Quiver.Hom R₁ R₂\nhr : ∀ (X : CategoryTheory.MorphismProperty.Comma L R₁ P Q W), P (CategoryTheory.CategoryStruct.comp X.hom (r.app X.right))\nX : CategoryTheory.MorphismProperty.Comma L R₁ P Q W\n⊢ Eq ((CategoryTheory.MorphismProperty.Comma.mapRight L r hr).obj X).right X.right","decl":"variable (L) in\n/-- A natural transformation `R₁ ⟶ R₂` induces a functor `P.Comma L R₁ Q W ⥤ P.Comma L R₂ Q W`. -/\n@[simps!]\ndef mapRight (r : R₁ ⟶ R₂) (hr : ∀ X : P.Comma L R₁ Q W, P (X.hom ≫ r.app X.right)) :\n    P.Comma L R₁ Q W ⥤ P.Comma L R₂ Q W :=\n  lift (forget _ _ _ _ _ ⋙ CategoryTheory.Comma.mapRight L r) hr\n    (fun f ↦ f.prop_hom_left) (fun f ↦ f.prop_hom_right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Comma.mapRight_map_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"A : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} A\nB : Type u_2\ninst✝³ : CategoryTheory.Category.{u_5, u_2} B\nT : Type u_3\ninst✝² : CategoryTheory.Category.{u_6, u_3} T\nL : CategoryTheory.Functor A T\nP : CategoryTheory.MorphismProperty T\nQ : CategoryTheory.MorphismProperty A\nW : CategoryTheory.MorphismProperty B\ninst✝¹ : Q.IsMultiplicative\ninst✝ : W.IsMultiplicative\nR₁ R₂ : CategoryTheory.Functor B T\nr : Quiver.Hom R₁ R₂\nhr : ∀ (X : CategoryTheory.MorphismProperty.Comma L R₁ P Q W), P (CategoryTheory.CategoryStruct.comp X.hom (r.app X.right))\nX Y : CategoryTheory.MorphismProperty.Comma L R₁ P Q W\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.MorphismProperty.Comma.mapRight L r hr).map f).left (CategoryTheory.MorphismProperty.Comma.Hom.hom f).left","decl":"variable (L) in\n/-- A natural transformation `R₁ ⟶ R₂` induces a functor `P.Comma L R₁ Q W ⥤ P.Comma L R₂ Q W`. -/\n@[simps!]\ndef mapRight (r : R₁ ⟶ R₂) (hr : ∀ X : P.Comma L R₁ Q W, P (X.hom ≫ r.app X.right)) :\n    P.Comma L R₁ Q W ⥤ P.Comma L R₂ Q W :=\n  lift (forget _ _ _ _ _ ⋙ CategoryTheory.Comma.mapRight L r) hr\n    (fun f ↦ f.prop_hom_left) (fun f ↦ f.prop_hom_right)\n\n"}
{"name":"CategoryTheory.MorphismProperty.instFaithfulOverTopOverForget","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} T\nP : CategoryTheory.MorphismProperty T\nX : T\n⊢ (CategoryTheory.MorphismProperty.Over.forget P Top.top X).Faithful","decl":"instance : (Over.forget P ⊤ X).Faithful := inferInstanceAs <| (Comma.forget _ _ _ _ _).Faithful\n"}
{"name":"CategoryTheory.MorphismProperty.instFullOverTopOverForget","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} T\nP : CategoryTheory.MorphismProperty T\nX : T\n⊢ (CategoryTheory.MorphismProperty.Over.forget P Top.top X).Full","decl":"instance : (Over.forget P ⊤ X).Full := inferInstanceAs <| (Comma.forget _ _ _ _ _).Full\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.Hom.mk_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst✝ : Q.IsMultiplicative\nA B : P.Over Q X\nf : Quiver.Hom A.toComma B.toComma\nhf : Q f.left\n⊢ Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom (CategoryTheory.MorphismProperty.Over.Hom.mk f hf)) f","decl":"/-- Construct a morphism in `P.Over Q X` from a morphism in `Over.X`. -/\n@[simps hom]\ndef Over.Hom.mk {A B : P.Over Q X} (f : A.toComma ⟶ B.toComma) (hf : Q f.left) : A ⟶ B where\n  __ := f\n  prop_hom_left := hf\n  prop_hom_right := trivial\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.mk_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX A : T\nf : Quiver.Hom A X\nhf : P f\n⊢ Eq (CategoryTheory.MorphismProperty.Over.mk Q f hf).hom f","decl":"variable (Q) in\n/-- Make an object of `P.Over Q X` from a morphism `f : A ⟶ X` and a proof of `P f`. -/\n@[simps hom left]\nprotected def Over.mk {A : T} (f : A ⟶ X) (hf : P f) : P.Over Q X where\n  left := A\n  right := ⟨⟨⟩⟩\n  hom := f\n  prop := hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.mk_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX A : T\nf : Quiver.Hom A X\nhf : P f\n⊢ Eq (CategoryTheory.MorphismProperty.Over.mk Q f hf).left A","decl":"variable (Q) in\n/-- Make an object of `P.Over Q X` from a morphism `f : A ⟶ X` and a proof of `P f`. -/\n@[simps hom left]\nprotected def Over.mk {A : T} (f : A ⟶ X) (hf : P f) : P.Over Q X where\n  left := A\n  right := ⟨⟨⟩⟩\n  hom := f\n  prop := hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.homMk_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst✝ : Q.IsMultiplicative\nA B : P.Over Q X\nf : Quiver.Hom A.left B.left\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp f B.hom) A.hom) _auto✝\nhf : autoParam (Q f) _auto✝\n⊢ Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom (CategoryTheory.MorphismProperty.Over.homMk f w hf)) (CategoryTheory.Over.homMk f w)","decl":"/-- Make a morphism in `P.Over Q X` from a morphism in `T` with compatibilities. -/\n@[simps hom]\nprotected def Over.homMk {A B : P.Over Q X} (f : A.left ⟶ B.left)\n    (w : f ≫ B.hom = A.hom := by aesop_cat) (hf : Q f := by trivial) : A ⟶ B where\n  __ := CategoryTheory.Over.homMk f w\n  prop_hom_left := hf\n  prop_hom_right := trivial\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.isoMk_hom_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst✝¹ : Q.IsMultiplicative\ninst✝ : Q.RespectsIso\nA B : P.Over Q X\nf : CategoryTheory.Iso A.left B.left\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp f.hom B.hom) A.hom) _auto✝\n⊢ Eq (CategoryTheory.MorphismProperty.Over.isoMk f w).hom.left f.hom","decl":"/-- Make an isomorphism in `P.Over Q X` from an isomorphism in `T` with compatibilities. -/\n@[simps! hom_left inv_left]\nprotected def Over.isoMk [Q.RespectsIso] {A B : P.Over Q X} (f : A.left ≅ B.left)\n    (w : f.hom ≫ B.hom = A.hom := by aesop_cat) : A ≅ B :=\n  Comma.isoMk f (Discrete.eqToIso' rfl)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.isoMk_inv_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst✝¹ : Q.IsMultiplicative\ninst✝ : Q.RespectsIso\nA B : P.Over Q X\nf : CategoryTheory.Iso A.left B.left\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp f.hom B.hom) A.hom) _auto✝\n⊢ Eq (CategoryTheory.MorphismProperty.Over.isoMk f w).inv.left f.inv","decl":"/-- Make an isomorphism in `P.Over Q X` from an isomorphism in `T` with compatibilities. -/\n@[simps! hom_left inv_left]\nprotected def Over.isoMk [Q.RespectsIso] {A B : P.Over Q X} (f : A.left ≅ B.left)\n    (w : f.hom ≫ B.hom = A.hom := by aesop_cat) : A ≅ B :=\n  Comma.isoMk f (Discrete.eqToIso' rfl)\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.Hom.ext_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst✝ : Q.IsMultiplicative\nA B : P.Over Q X\nf g : Quiver.Hom A B\n⊢ Iff (Eq f g) (Eq f.left g.left)","decl":"@[ext]\nlemma Over.Hom.ext {A B : P.Over Q X} {f g : A ⟶ B} (h : f.left = g.left) : f = g := by\n  ext\n  · exact h\n  · simp\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.Hom.ext","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst✝ : Q.IsMultiplicative\nA B : P.Over Q X\nf g : Quiver.Hom A B\nh : Eq f.left g.left\n⊢ Eq f g","decl":"@[ext]\nlemma Over.Hom.ext {A B : P.Over Q X} {f g : A ⟶ B} (h : f.left = g.left) : f = g := by\n  ext\n  · exact h\n  · simp\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.w","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst✝ : Q.IsMultiplicative\nA B : P.Over Q X\nf : Quiver.Hom A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp f.left B.hom) A.hom","decl":"@[reassoc]\nlemma Over.w {A B : P.Over Q X} (f : A ⟶ B) :\n    f.left ≫ B.hom = A.hom := by\n  simp\n\n"}
{"name":"CategoryTheory.MorphismProperty.Over.w_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst✝ : Q.IsMultiplicative\nA B : P.Over Q X\nf : Quiver.Hom A B\nZ : T\nh : Quiver.Hom ((CategoryTheory.Functor.fromPUnit X).obj B.right) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f.left (CategoryTheory.CategoryStruct.comp B.hom h)) (CategoryTheory.CategoryStruct.comp A.hom h)","decl":"@[reassoc]\nlemma Over.w {A B : P.Over Q X} (f : A ⟶ B) :\n    f.left ≫ B.hom = A.hom := by\n  simp\n\n"}
{"name":"CategoryTheory.MorphismProperty.instFaithfulUnderTopUnderForget","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} T\nP : CategoryTheory.MorphismProperty T\nX : T\n⊢ (CategoryTheory.MorphismProperty.Under.forget P Top.top X).Faithful","decl":"instance : (Under.forget P ⊤ X).Faithful := inferInstanceAs <| (Comma.forget _ _ _ _ _).Faithful\n"}
{"name":"CategoryTheory.MorphismProperty.instFullUnderTopUnderForget","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} T\nP : CategoryTheory.MorphismProperty T\nX : T\n⊢ (CategoryTheory.MorphismProperty.Under.forget P Top.top X).Full","decl":"instance : (Under.forget P ⊤ X).Full := inferInstanceAs <| (Comma.forget _ _ _ _ _).Full\n\n"}
{"name":"CategoryTheory.MorphismProperty.Under.Hom.mk_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst✝ : Q.IsMultiplicative\nA B : P.Under Q X\nf : Quiver.Hom A.toComma B.toComma\nhf : Q f.right\n⊢ Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom (CategoryTheory.MorphismProperty.Under.Hom.mk f hf)) f","decl":"/-- Construct a morphism in `P.Under Q X` from a morphism in `Under.X`. -/\n@[simps hom]\ndef Under.Hom.mk {A B : P.Under Q X} (f : A.toComma ⟶ B.toComma) (hf : Q f.right) : A ⟶ B where\n  __ := f\n  prop_hom_left := trivial\n  prop_hom_right := hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.Under.mk_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX A : T\nf : Quiver.Hom X A\nhf : P f\n⊢ Eq (CategoryTheory.MorphismProperty.Under.mk Q f hf).hom f","decl":"variable (Q) in\n/-- Make an object of `P.Under Q X` from a morphism `f : A ⟶ X` and a proof of `P f`. -/\n@[simps hom left]\nprotected def Under.mk {A : T} (f : X ⟶ A) (hf : P f) : P.Under Q X where\n  left := ⟨⟨⟩⟩\n  right := A\n  hom := f\n  prop := hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.Under.mk_left","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX A : T\nf : Quiver.Hom X A\nhf : P f\n⊢ Eq (CategoryTheory.MorphismProperty.Under.mk Q f hf).left { as := PUnit.unit }","decl":"variable (Q) in\n/-- Make an object of `P.Under Q X` from a morphism `f : A ⟶ X` and a proof of `P f`. -/\n@[simps hom left]\nprotected def Under.mk {A : T} (f : X ⟶ A) (hf : P f) : P.Under Q X where\n  left := ⟨⟨⟩⟩\n  right := A\n  hom := f\n  prop := hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.Under.homMk_hom","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst✝ : Q.IsMultiplicative\nA B : P.Under Q X\nf : Quiver.Hom A.right B.right\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.hom f) B.hom) _auto✝\nhf : autoParam (Q f) _auto✝\n⊢ Eq (CategoryTheory.MorphismProperty.Comma.Hom.hom (CategoryTheory.MorphismProperty.Under.homMk f w hf)) (CategoryTheory.Under.homMk f w)","decl":"/-- Make a morphism in `P.Under Q X` from a morphism in `T` with compatibilities. -/\n@[simps hom]\nprotected def Under.homMk {A B : P.Under Q X} (f : A.right ⟶ B.right)\n    (w : A.hom ≫ f = B.hom := by aesop_cat) (hf : Q f := by trivial) : A ⟶ B where\n  __ := CategoryTheory.Under.homMk f w\n  prop_hom_left := trivial\n  prop_hom_right := hf\n\n"}
{"name":"CategoryTheory.MorphismProperty.Under.isoMk_inv_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst✝¹ : Q.IsMultiplicative\ninst✝ : Q.RespectsIso\nA B : P.Under Q X\nf : CategoryTheory.Iso A.right B.right\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.hom f.hom) B.hom) _auto✝\n⊢ Eq (CategoryTheory.MorphismProperty.Under.isoMk f w).inv.right f.inv","decl":"/-- Make an isomorphism in `P.Under Q X` from an isomorphism in `T` with compatibilities. -/\n@[simps! hom_right inv_right]\nprotected def Under.isoMk [Q.RespectsIso] {A B : P.Under Q X} (f : A.right ≅ B.right)\n    (w : A.hom ≫ f.hom = B.hom := by aesop_cat) : A ≅ B :=\n  Comma.isoMk (Discrete.eqToIso' rfl) f\n\n"}
{"name":"CategoryTheory.MorphismProperty.Under.isoMk_hom_right","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst✝¹ : Q.IsMultiplicative\ninst✝ : Q.RespectsIso\nA B : P.Under Q X\nf : CategoryTheory.Iso A.right B.right\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.hom f.hom) B.hom) _auto✝\n⊢ Eq (CategoryTheory.MorphismProperty.Under.isoMk f w).hom.right f.hom","decl":"/-- Make an isomorphism in `P.Under Q X` from an isomorphism in `T` with compatibilities. -/\n@[simps! hom_right inv_right]\nprotected def Under.isoMk [Q.RespectsIso] {A B : P.Under Q X} (f : A.right ≅ B.right)\n    (w : A.hom ≫ f.hom = B.hom := by aesop_cat) : A ≅ B :=\n  Comma.isoMk (Discrete.eqToIso' rfl) f\n\n"}
{"name":"CategoryTheory.MorphismProperty.Under.Hom.ext_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst✝ : Q.IsMultiplicative\nA B : P.Under Q X\nf g : Quiver.Hom A B\n⊢ Iff (Eq f g) (Eq f.right g.right)","decl":"@[ext]\nlemma Under.Hom.ext {A B : P.Under Q X} {f g : A ⟶ B} (h : f.right = g.right) : f = g := by\n  ext\n  · simp\n  · exact h\n\n"}
{"name":"CategoryTheory.MorphismProperty.Under.Hom.ext","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst✝ : Q.IsMultiplicative\nA B : P.Under Q X\nf g : Quiver.Hom A B\nh : Eq f.right g.right\n⊢ Eq f g","decl":"@[ext]\nlemma Under.Hom.ext {A B : P.Under Q X} {f g : A ⟶ B} (h : f.right = g.right) : f = g := by\n  ext\n  · simp\n  · exact h\n\n"}
{"name":"CategoryTheory.MorphismProperty.Under.w_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst✝ : Q.IsMultiplicative\nA B : P.Under Q X\nf : Quiver.Hom A B\nZ : T\nh : Quiver.Hom B.right Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp A.hom (CategoryTheory.CategoryStruct.comp f.right h)) (CategoryTheory.CategoryStruct.comp B.hom h)","decl":"@[reassoc]\nlemma Under.w {A B : P.Under Q X} (f : A ⟶ B) :\n    A.hom ≫ f.right = B.hom := by\n  simp\n\n"}
{"name":"CategoryTheory.MorphismProperty.Under.w","module":"Mathlib.CategoryTheory.MorphismProperty.Comma","initialProofState":"T : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} T\nP Q : CategoryTheory.MorphismProperty T\nX : T\ninst✝ : Q.IsMultiplicative\nA B : P.Under Q X\nf : Quiver.Hom A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp A.hom f.right) B.hom","decl":"@[reassoc]\nlemma Under.w {A B : P.Under Q X} (f : A ⟶ B) :\n    A.hom ≫ f.right = B.hom := by\n  simp\n\n"}
